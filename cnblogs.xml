<?xml version="1.0" encoding="UTF-8" ?>
    <rss version="2.0">
    <channel>
        <title><![CDATA[ 主页 - 博客园 ]]></title>
        <link><![CDATA[ https://www.cnblogs.com/ ]]></link>
        <lastBuildDate>2025-12-22T08:24:49.785Z</lastBuildDate>
        <description><![CDATA[
        主页 - 博客园 RSS
    ]]></description>
        <language>zh-cn</language>
        <item>
    <title><![CDATA[ 数据库表设计 ]]></title>
    <link>https://www.cnblogs.com/philry/p/18831261</link>
    <guid>ce84ef8a8c490c3bc80b5e246edcceb3</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/philry/p/18831261" title="发布于 2025-12-22 16:23">
    <span role="heading" aria-level="2">数据库表设计</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div>
<div><span style="font-size: 18px"><strong>字节</strong></span></div>
<div><span>首先需要达成共识的是：<strong>1个Byte字节等于8个bit位</strong>。bit是最小一级的信息单位，可以表示一个0或1（即二进制）；</span></div>
<div><span style="font-size: 18px"><strong>字符</strong></span></div>
<div>字符其实是一个统称，字母、数字、运算符号、标点符号和其他符号，以及一些功能性符号都属于字符。比如：&amp;、中、A。</div>
<div>那到底一个字符占用多少字节呢？这个问题其实取决于数据库所采用的编码格式。</div>
<div>一般来说一个英文字符（A、b）都占用1个字节。在UTF8编码下，一个中文汉字占3个字节；在GBK编码下，一个中文汉字占用2个字节。</div>
<div>
<div class="cnblogs_code">
<pre>完了，gg了！     ==&gt; 七个字符
hello,世界      ==&gt; 八个字符</pre>
</div>
<p><strong><span style="font-size: 16px">整数型</span></strong></p>
</div>
<div><span>整数类型一共有5种，包括 TINYINT、SMALLINT、MEDIUMINT、INT(INTEGER)和 BIGINT</span></div>
<div><span>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;有符号整型范围值&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;无符号整型范围值</span></div>
<div>TINYINT&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;1bytes&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;小整数值&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;-128 ~ 127&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;0 ~ 255&nbsp;</div>
<div>SMALLINT&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;2bytes&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;大整数值&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;-32768 ~ 32767&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;0 ~ 65535&nbsp;</div>
<div>MEDIUMINT&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;3bytes&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;大整数值&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;-8388608 ~ 8388607&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;0 ~ 16777215&nbsp;</div>
<div>INT和INTEGER&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;4bytes&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;大整数值&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;-2147483648 ~ 2147483647&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;0 ~ 4294967295&nbsp;</div>
<div>BIGINT&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;8bytes&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;极大整数值&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-2^63 ~ 2^63-1&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;0 ~ 2^64-1</div>
<div><span>&nbsp;</span></div>
<div>1、整数型的数值类型已经限制了取值范围，有符号整型和无符号整型都有，而M值并不代表可以存储的数值字符长度，它代表的是数据在显示时显示的最小长度；</div>
<div>2、当存储的字符长度超过M值时，没有任何的影响，只要不超过数值类型限制的范围；</div>
<div>3、当存储的字符长度小于M值时，只有在设置了zerofill用0来填充，才能够看到效果，换句话就是说，没有zerofill，M值就是无用的。</div>
<div>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;举例子，如果你设置int(11)，那么有个字段值是123，那么这个值在显示宽度上是3位，而设计的是显示的是11位，所以这时候，你如果在字段设计的时候，选择zerofill就可以发现，123变成了00000000123，也就是剩下的8位用0补足了。</div>
<div>所以我们在设计mysql数据库时，建表时，mysql会自动分配长度：int(11)、tinyint(4)、smallint(6)、mediumint(9)、bigint(20)。</div>
<div>所以，就用这些默认的显示长度就可以了。不用再去自己填长度，比如搞个int(10)、tinyint(1)之类的，基本没用。而且导致表的字段类型多样化</div>
<h3>字符串型</h3>
<div><strong>CHAR(M), VARCHAR(M)</strong></div>
<div>&nbsp;&nbsp; &nbsp;CHAR(M)定义的列的长度为固定的，M取值可以为0～255之间，当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。CHAR存储定长数据很方便，CHAR字段上的索引效率级高，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间,不足的自动用空格填充。</div>
<div>&nbsp;&nbsp; &nbsp;VARCHAR(M)定义的列的长度为可变长字符串，M取值可以为0~65535之间，(VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532字节）。VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)。VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。varchar存储变长数据，但存储效率没有CHAR高。如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为 VARCHAR(10)是最合算的。</div>
<div>&nbsp;&nbsp; &nbsp;CHAR和VARCHAR最大的不同就是一个是固定长度，一个是可变长度。</div>
<div>&nbsp;&nbsp; &nbsp;总结一下，从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点，所有当需要大量查询需求的时候，用char。当对于保存数据量过大的需求时，为了节省储存空间用varchar。</div>
<div>&nbsp;</div>
<div><span style="font-size: 15px"><strong>TEXT</strong></span></div>
<div>&nbsp;&nbsp; &nbsp;最大长度为65,535(2的16次方–1)字符的TEXT列。</div>
<div>&nbsp;&nbsp; &nbsp;Text主要是用来存放非二进制的文本，如论坛帖子,题目，或者百度知道的问题和回答之类。TEXT列不能有默认值，存储或检索过程中，不存在大小写转换，后面如果指定长度，不会报错误，但是这个长度是不起作用的，意思就是你插入数据的时候，超过你指定的长度还是可以正常插入。其实可以总结为用来储存大批量的文本信息的时候，使用TEXT。</div>
<div>&nbsp;</div>
<div><strong><span style="font-size: 15px">总结</span></strong></div>
<div>1，长度的区别，char范围是0～255，varchar最长是64k，如果遇到了大文本，考虑使用text，最大能到4G。</div>
<div>2，效率来说基本是char&gt;varchar&gt;text。</div>
<div>3，char和varchar可以有默认值，text不能指定默认值。</div>
<div>&nbsp;</div>
<h3>时间型</h3>
<div><span>DATETIME：类型用在你需要同时包含日期和时间信息的值时。MySQL检索并且以'YYYY-MM-DD HH:MM:SS'格式显示DATETIME值，支持的范围是'1000-01-01 00:00:00'到'9999-12-31 23:59:59'。</span></div>
<div><span>DATE：类型用在你仅需要日期值时，没有时间部分。MySQL检索并且以'YYYY-MM-DD'格式显示DATE值，支持的范围是'1000-01-01'到'9999-12-31'。</span></div>
<div><span>TIMESTAMP：列类型提供一种类型，你可以使用它自动地用当前的日期和时间标记INSERT或UPDATE的操作。</span></div>
<div><span>TIME：数据类型表示一天中的时间。MySQL检索并且以"HH:MM:SS"格式显示TIME值。支持的范围是'00:00:00'到'23:59:59'。</span></div>
<div>&nbsp;</div>
<div><span style="font-size: 16px"><strong>datetime和timestamp的区别：</strong></span></div>
<div>&nbsp;&nbsp; &nbsp;1.datetime 的日期范围比较大；如果有1970年以前的数据还是要用datetime.但是timestamp 所占存储空间比较小。</div>
<div>&nbsp;&nbsp; &nbsp;2.timestamp类型的列还有个特性：默认情况下,在 insert,update数据时，timestamp 列会自动以当前时间(CURRENT_TIMESTAMP)填充/更新。</div>
<div><span>&nbsp;&nbsp; &nbsp;3.timestamp比较受时区timezone的影响以及MYSQL版本和服务器的SQL MODE的影响。</span></div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp; &nbsp;UNSIGNED ZEROFILL：刚说过了，数字型字段当存储的字符长度小于INT(M)中的M值时，只有在设置了zerofill用0来填充，才能够看到效果，换句话就是说，没有zerofill，M值就是无用的。</div>
<div>&nbsp;&nbsp; &nbsp;timestamp有两个属性，分别是CURRENT_TIMESTAMP 和ON UPDATE CURRENT_TIMESTAMP两种，使用情况分别如下</div>
<div>&nbsp;</div>
<div><strong>1，CURRENT_TIMESTAMP&nbsp;</strong></div>
<div>当要向数据库执行insert操作时，如果有个timestamp字段属性设为</div>
<div>&nbsp;CURRENT_TIMESTAMP，则无论这个字段有没有set值都插入当前系统时间</div>
<div><strong>2，ON UPDATE CURRENT_TIMESTAMP</strong></div>
<div>当执行update操作是，并且字段有ON UPDATE CURRENT_TIMESTAMP属性。则字段无论值有没有变化，它的值也会跟着更新为当前UPDATE操作时的时间。</div>
<div>&nbsp;</div>
<h2><span style="font-size: 18px">字段的索引以及设置</span></h2>
<div><strong>先说下对索引的最简单的理解：</strong></div>
<div>如果你给一个唯一性的字段加上索引，比如一个字段是房间号，你不设置字段的情况下去搜索RoomNumber=101，那么数据库会去一条一条的搜索数据库中的RoomNumber字段，直到找到101给你返回，但如果你把RoomNumber设置为索引，那么数据库就会直接找到RoomNumber=101这条信息给你返回。</div>
<div>所以索引的作用是加快数据库搜索的效率，但是同样的，你给一个字段设置为索引，是要消耗资源的。</div>
<div>普通索引(INDEX)：最基本的索引，没有任何限制。</div>
<div>唯一索引(UNIQUE)：与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。</div>
<div>主键索引(PRIMARY)：它 是一种特殊的唯一索引，不允许有空值。</div>
<div><span>全文索引(FULLTEXT&nbsp;)：仅可用于 MyISAM 表，&nbsp;用于在一篇文章中，检索文本信息的,&nbsp;针对较大的数据，生成全文索引很耗时耗空间。</span></div>
<div>&nbsp;</div>
<div><span style="font-size: 14px"><strong>1.为什么长度几乎相等的字符串要选char而不是varchar？</strong></span></div>
<div>比如性别(gender)这个字段，只有两个值(男、女)，就一个字符，为什么用char(1),而不是varchar(1)?</div>
<div>因为char(1)就真的是只开辟了1个字符大小，而varchar(1)不是只开辟一个字符大小，varchar需要单独记录字符串长度的大小需要额外空间</div>
<div>&nbsp;</div>
<div><strong><span style="font-size: 14px">2.为什么在字段设计的时候有的人设置gender为tinyint,有点设置gender为char(1)?</span></strong></div>
<div>在设计表的时候可以通过0和1来标识男还是女，也可以通过 '男' 和 '女' 来标识，可是有什么区别呢?</div>
<div>这里就涉及到一个概念了，数据库字段长度的表示到底是 字符长度 还是 字节长度 ？</div>
<div>其实在MySQL中，varchar和char类型表示字符长度 ，而其他类型表示的长度都是字节长度</div>
<div>举个例子，'男' 如果用字符长度来表示就是1，但是用字节长度来表示就是3个字节 ，在UTF-8下中文基本都是三字节</div>
<div>而用0和1来标识男女就只需要一个字节</div>
<div><span>&nbsp;</span></div>
<div><span style="font-size: 14px"><strong>3.主键设计要合理</strong></span></div>
<div>主键设计的话，最好不要与业务逻辑有所关联。有些业务上的字段，比如身份证，虽然是唯一的，一些开发者喜欢用它来做主键，但是不是很建议哈。主键最好是毫无意义的一串独立不重复的数字，比如UUID，又或者Auto_increment自增的主键，或者是雪花算法生成的主键等等</div>
<div>&nbsp;</div>
<div><strong>4.选择合适的字段长度</strong></div>
<div>我们在设计表的时候，需要充分考虑一个字段的长度，比如一个用户名字段（它的长度5~20个字符），你觉得应该设置多长呢？可以考虑设置为 username varchar（32） 。字段长度一般设置为2的幂哈（也就是2的n次方）。</div>
<div>&nbsp;</div>
<div><strong>为什么字段长度一般要设置为2的幂呢？</strong></div>
<div>这是因为数据库在存储数据时，会使用位运算来处理字段的长度，而位运算对于2的幂次方比较方便。如果字段长度不是2的幂哈，则需要使用算术运算来处理，这样会降低数据库的性能。</div>
<div>&nbsp;</div>
<div>此外，设置字段长度为2的幂哈也有助于减少数据库的内存使用。数据库会根据字段长度来分配内存空间，如果字段长度不是2的幂哈，则需要使用更大的内存块来存储，这样会造成内存的浪费。</div>
<div>&nbsp;</div>
<div>因此，为了提高数据库的性能和优化内存使用，一般建议将字段长度设置为2的幂哈。如果确实需要更长的字段长度，可以使用变长字段类型（如VARCHAR）来适应不同的长度需求。</div>
<div>&nbsp;</div>
<div><strong>varchar(20)和varchar(255)有什么区别？</strong></div>
<div>通常情况下使用varchar(20)和varchar(255)占用的空间都是一样的,但是使用索引长度有所不同。</div>
<div>&nbsp;</div>
<div><strong>int(1)和nt(11)有什么区别？</strong></div>
<div>在MySQL中，对于int类型的字段，设置其长度并不是指存储的数字位数或最大值的大小，而是指显示宽度。</div>
<div>也就是说，长度设置对实际存储的数据范围和占用空间并无影响，它主要影响的是数据的显示格式。</div>
<div>&nbsp;</div>
<div><strong>举个例子：</strong></div>
<div>当长度设置为1的时候，表示当该字段值被查询并显示时，MySQL会为这个整数值分配至少1个字符的宽度。如果实际值的位数小于1，MySQL会在前面补足空格以达到指定的显示宽度；如果实际值的位数大于1，则按照实际位数显示。例如，一个值为123的INT字段，若设置长度为1，实际显示时仍会完整显示为“123”，不会截断。</div>
<div>当长度设置为11的时候，同理，表示当该字段值被查询并显示时，MySQL会为其分配至少11个字符的宽度。同样，如果实际值的位数小于11，前面补足空格；若大于11，则按实际位数显示。</div>
<div>那为什么会看到有人喜欢设置int(11)呢？</div>
<div>&nbsp;</div>
<div>最大可能位数： INT类型的最大可能位数是10位（不含正负号），即从-2,147,483,648到2,147,483,647。设置长度为11可以确保任何在这个范围内的整数值在显示时都不需要额外的填充空格。即使数值较小，如只有1位或2位，也能保证有足够的宽度来容纳可能出现的最大位数，使得数据显示整齐且易于阅读。</div>
<div>&nbsp;</div>
<div><strong>5.优先考虑逻辑删除，而不是物理删除</strong></div>
<div>什么是物理删除？什么是逻辑删除？</div>
<div>&nbsp;</div>
<div>物理删除：把数据从硬盘中删除，可释放存储空间</div>
<div>逻辑删除：给数据添加一个字段，比如is_deleted，以标记该数据已经逻辑删除。</div>
<div>物理删除就是执行delete语句，如删除account_no =‘xxx’的账户信息SQL如下：</div>
<div>&nbsp;</div>
<div>delete from account_info_tab whereaccount_no =‘666’;</div>
<div>逻辑删除呢，就是这样：</div>
<div>&nbsp;</div>
<div>update account_info_tab set is_deleted = 1 where account_no =‘666’;</div>
<div>&nbsp;</div>
<div><span style="font-size: 15px"><strong>那么为什么推荐逻辑删除而非物理删除？</strong></span></div>
<div>&nbsp; &nbsp; 1)、为什么不推荐使用物理删除，因为恢复数据很困难</div>
<div>&nbsp; &nbsp; 2)、物理删除会使自增主键不再连续</div>
<div>&nbsp; &nbsp; 3)、核心业务表 的数据不建议做物理删除，只适合做状态变更。</div>
<div>&nbsp;</div>
<div><span style="font-size: 15px"><strong>6.每个表都需要添加几个通用字段如主键、create_time、update_time</strong></span></div>
<div>表必备一般来说，或具备这几个字段：</div>
<div>&nbsp;</div>
<div>id： 主键，一个表必须得有主键，必须</div>
<div>create_time： 创建时间，必须</div>
<div>modifed_time: 修改时间，必须，更新记录时，需要更新它</div>
<div>version : 数据记录的版本号，用于乐观锁，非必须</div>
<div>remark ：数据记录备注，非必须</div>
<div>modified_by :修改人，非必须</div>
<div>creator ：创建人，非必须</div>
<div>&nbsp;</div>
<div><span style="font-size: 15px"><strong>7.尽可能的使用not null定义字段</strong></span></div>
<div>如果没有特殊的理由， 一般都建议将字段定义为 NOT NULL 。</div>
<div>&nbsp;</div>
<div><strong><span style="font-size: 14px">为什么要这样做呢？</span></strong></div>
<div>&nbsp; &nbsp; 1)、首先，NOT NULL 可以防止出现空指针的问题</div>
<div>&nbsp; &nbsp; 2)、其次，NULL 值的存储也需要额外的空间，它也会导致比较运算更为复杂，使优化器难以优化SQL</div>
<div>&nbsp; &nbsp; 3)、NULL 值有可能会导致索引失效</div>
<div><span style="font-size: 14px"><strong>8.设计表时，评估哪些字段需要加索引</strong></span></div>
<div>首先，评估你的表数据量。如果你的表数据量只有一百几十行，就没有必要加索引。否则设计表的时候，如果有查询条件的字段，一般就需要建立索引。但是索引也不能滥用：</div>
<div>&nbsp;</div>
<div>索引也不要建得太多，一般单表索引个数不要超过5个。因为创建过多的索引，会降低写得速度。</div>
<div>区分度不高的字段，不能加索引，如性别等</div>
<div>索引创建完后，还是要注意避免索引失效的情况，如使用mysql的内置函数，会导致索引失效的</div>
<div>索引过多的话，可以通过联合索引的话方式来优化。然后的话，索引还有一些规则，如覆盖索引，最左匹配原则等等。</div>
<div>假设你新建一张用户表，如下</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">CREATE</span> <span style="color: rgba(0, 0, 255, 1)">TABLE</span><span style="color: rgba(0, 0, 0, 1)"> user_info_tab (
  `id` </span><span style="color: rgba(0, 0, 255, 1)">int</span>(<span style="color: rgba(128, 0, 0, 1); font-weight: bold">11</span>) <span style="color: rgba(128, 128, 128, 1)">NOT</span> <span style="color: rgba(0, 0, 255, 1)">NULL</span><span style="color: rgba(0, 0, 0, 1)"> AUTO_INCREMENT,
  `</span><span style="color: rgba(255, 0, 255, 1)">user_id</span>` <span style="color: rgba(0, 0, 255, 1)">int</span>(<span style="color: rgba(128, 0, 0, 1); font-weight: bold">11</span>) <span style="color: rgba(128, 128, 128, 1)">NOT</span> <span style="color: rgba(0, 0, 255, 1)">NULL</span><span style="color: rgba(0, 0, 0, 1)">,
  `age` </span><span style="color: rgba(0, 0, 255, 1)">int</span>(<span style="color: rgba(128, 0, 0, 1); font-weight: bold">11</span>) <span style="color: rgba(0, 0, 255, 1)">DEFAULT</span> <span style="color: rgba(0, 0, 255, 1)">NULL</span><span style="color: rgba(0, 0, 0, 1)">,
  `name` </span><span style="color: rgba(0, 0, 255, 1)">varchar</span>(<span style="color: rgba(128, 0, 0, 1); font-weight: bold">255</span>) <span style="color: rgba(128, 128, 128, 1)">NOT</span> <span style="color: rgba(0, 0, 255, 1)">NULL</span><span style="color: rgba(0, 0, 0, 1)">,
  `create_time` </span><span style="color: rgba(0, 0, 255, 1)">datetime</span> <span style="color: rgba(128, 128, 128, 1)">NOT</span> <span style="color: rgba(0, 0, 255, 1)">NULL</span><span style="color: rgba(0, 0, 0, 1)">,
  `modifed_time` </span><span style="color: rgba(0, 0, 255, 1)">datetime</span> <span style="color: rgba(128, 128, 128, 1)">NOT</span> <span style="color: rgba(0, 0, 255, 1)">NULL</span><span style="color: rgba(0, 0, 0, 1)">,
  </span><span style="color: rgba(0, 0, 255, 1)">PRIMARY</span> <span style="color: rgba(0, 0, 255, 1)">KEY</span><span style="color: rgba(0, 0, 0, 1)"> (`id`)
) ENGINE</span><span style="color: rgba(128, 128, 128, 1)">=</span>InnoDB <span style="color: rgba(0, 0, 255, 1)">DEFAULT</span> CHARSET<span style="color: rgba(128, 128, 128, 1)">=</span><span style="color: rgba(0, 0, 0, 1)">utf8;
对于这张表，很可能会根据 </span><span style="color: rgba(255, 0, 255, 1)">user_id</span><span style="color: rgba(0, 0, 0, 1)"> 或者 name查询用户信息，并且，user_id是唯一的，因此是可以给user_id加上唯一索引，name加上普通索引
 
</span><span style="color: rgba(0, 0, 255, 1)">CREATE</span> <span style="color: rgba(0, 0, 255, 1)">TABLE</span><span style="color: rgba(0, 0, 0, 1)"> user_info_tab (
  `id` </span><span style="color: rgba(0, 0, 255, 1)">int</span>(<span style="color: rgba(128, 0, 0, 1); font-weight: bold">11</span>) <span style="color: rgba(128, 128, 128, 1)">NOT</span> <span style="color: rgba(0, 0, 255, 1)">NULL</span><span style="color: rgba(0, 0, 0, 1)"> AUTO_INCREMENT,
  `</span><span style="color: rgba(255, 0, 255, 1)">user_id</span>` <span style="color: rgba(0, 0, 255, 1)">int</span>(<span style="color: rgba(128, 0, 0, 1); font-weight: bold">11</span>) <span style="color: rgba(128, 128, 128, 1)">NOT</span> <span style="color: rgba(0, 0, 255, 1)">NULL</span><span style="color: rgba(0, 0, 0, 1)">,
  `age` </span><span style="color: rgba(0, 0, 255, 1)">int</span>(<span style="color: rgba(128, 0, 0, 1); font-weight: bold">11</span>) <span style="color: rgba(0, 0, 255, 1)">DEFAULT</span> <span style="color: rgba(0, 0, 255, 1)">NULL</span><span style="color: rgba(0, 0, 0, 1)">,
  `name` </span><span style="color: rgba(0, 0, 255, 1)">varchar</span>(<span style="color: rgba(128, 0, 0, 1); font-weight: bold">255</span>) <span style="color: rgba(128, 128, 128, 1)">NOT</span> <span style="color: rgba(0, 0, 255, 1)">NULL</span><span style="color: rgba(0, 0, 0, 1)">,
  `create_time` </span><span style="color: rgba(0, 0, 255, 1)">datetime</span> <span style="color: rgba(128, 128, 128, 1)">NOT</span> <span style="color: rgba(0, 0, 255, 1)">NULL</span><span style="color: rgba(0, 0, 0, 1)">,
  `modifed_time` </span><span style="color: rgba(0, 0, 255, 1)">datetime</span> <span style="color: rgba(128, 128, 128, 1)">NOT</span> <span style="color: rgba(0, 0, 255, 1)">NULL</span><span style="color: rgba(0, 0, 0, 1)">,
  </span><span style="color: rgba(0, 0, 255, 1)">PRIMARY</span> <span style="color: rgba(0, 0, 255, 1)">KEY</span><span style="color: rgba(0, 0, 0, 1)"> (`id`),
  </span><span style="color: rgba(0, 0, 255, 1)">KEY</span><span style="color: rgba(0, 0, 0, 1)"> `idx_name` (`name`) USING BTREE,
  </span><span style="color: rgba(0, 0, 255, 1)">UNIQUE</span> <span style="color: rgba(0, 0, 255, 1)">KEY</span> un_user_id (<span style="color: rgba(255, 0, 255, 1)">user_id</span><span style="color: rgba(0, 0, 0, 1)">)
) ENGINE</span><span style="color: rgba(128, 128, 128, 1)">=</span>InnoDB <span style="color: rgba(0, 0, 255, 1)">DEFAULT</span> CHARSET<span style="color: rgba(128, 128, 128, 1)">=</span>utf8;</pre>
</div>
</div>
<div><strong>9.不需要严格遵守3NF，通过业务字段冗余来减少表关联</strong></div>
<div>什么是数据库三范式（3NF），大家是否还有印象吗？</div>
<div>&nbsp;</div>
<div>第一范式：对属性的原子性，要求属性具有原子性，不可再分解；</div>
<div>第二范式：对记录的唯一性，要求记录有唯一标识，即实体的唯一性，即不存在部分依赖；</div>
<div>第三方式：对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；</div>
<div>我们设计表及其字段之间的关系, 应尽量满足第三范式。但是有时候，可以适当冗余，来提高效率。比如以下这张表</div>
<div>&nbsp;</div>
<div>商品名称&nbsp;&nbsp;&nbsp;&nbsp;商品型号&nbsp;&nbsp;&nbsp;&nbsp;单价&nbsp;&nbsp;&nbsp;&nbsp;数量&nbsp;&nbsp;&nbsp;&nbsp;总金额</div>
<div>手机&nbsp;&nbsp;&nbsp;&nbsp;华为&nbsp;&nbsp;&nbsp;&nbsp;9000&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;45000</div>
<div>以上这张存放商品信息的基本表。总金额这个字段的存在，表明该表的设计不满足第三范式，因为总金额可以由单价*数量得到，说明总金额是冗余字段。</div>
<div>但是，增加总金额这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。</div>
<div>&nbsp;</div>
<div><strong>10.不使用外键，都在代码层维护</strong></div>
<div>阿里的Java开发规范也明确规定了</div>
<div>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</div>
<div>&nbsp;</div>
<div><strong>我们为什么不推荐使用外键呢？</strong></div>
<div><span>&nbsp; &nbsp; 1)、使用外键存在性能问题、并发死锁问题、使用起来不方便等等。每次做DELETE或者UPDATE都必须考虑外键约束会导致开发的时候很难受,测试数据造数据也不方便。</span></div>
<div>&nbsp; &nbsp; 2)、还有一个场景不能使用外键，就是分库分表。</div>
<div>&nbsp;</div>
<div><strong>11.没有特殊场景一般都选择INNODB存储引擎</strong></div>
<div>建表是需要选择 存储引擎 的，我们一般都选择 INNODB 存储引擎，除非读写比率小于1%，才会考虑使用MyISAM(也就是基本上都是读的场景)</div>
<div>&nbsp;</div>
<div><strong>12.时间类型的选择</strong></div>
<div>我们设计表的时候，一般都需要加通用时间的字段，如 create_time、update_time等等，那对于时间的类型，我们应该如何选择？</div>
<div>对于MySQL来说，主要有 date、datetime、time、timestamp 和 year</div>
<div>&nbsp;</div>
<div>date ：表示的日期值, 格式yyyy-mm-dd,范围1000-01-01 到 9999-12-31，3字节</div>
<div>time ：表示的时间值，格式 hh:mm:ss，范围-838:59:59 到 838:59:59，3字节</div>
<div>datetime：表示的日期时间值,格式yyyy-mm-dd hh:mm:ss，范围1000-01-01 00:00:00到9999-12-31 23:59:59,8字节,跟时区无关</div>
<div>timestamp：表示的时间戳值,格式为yyyymmddhhmmss，范围1970-01-01 00:00:01到2038-01-19 03:14:07，4字节,跟时区有关</div>
<div>year：年份值，格式为yyyy。范围1901到2155，1字节</div>
<div>&nbsp;</div>
<div>总结：推荐优先使用datetime类型来保存日期和时间，因为存储范围更大，且跟时区无关</div>
<div>&nbsp;</div>
<div><strong>13.不建议在数据表中使用Text数据类型，而要单独开一张表放Text类型的数据呢？</strong></div>
<div>从BufferPool的角度考虑一下，大家认为BufferPool有什么关系呢？</div>
<div>一开始我是这样考虑的，Text字段一般来说会很大，如果要加载到BufferPool里面，会把内存撑爆？</div>
<div>我一开始是从这个角度去想的，但是后来想想，无论要不要将Text类型的字段的数据单独放到一张表，都不影响加载到BufferPool，所以撑爆内存的这个角度想不太对</div>
<div>换个角度，换到索引的角度去想一下</div>
<div>在MySQL的InnoDB引擎下，我们是通过B+树去存储索引结构的，在B+树中真正存储数据的都是叶子节点</div>
<div>而且我们一页只能存放16KB大小的数据，如果说你把Text数据和其他数据同时放在一张表，那么一条记录会比没放Text的时候要大很多，导致一个索引页存放的数据条数大大的减少</div>
<div><img width="516" data-src="https://img2024.cnblogs.com/blog/2337379/202504/2337379-20250417172029092-1505571045.png" class="lazyload"></div>
<div>&nbsp;</div>
<div><strong>14.考虑是否需要分库分表</strong></div>
<div><strong>什么是分库分表呢？</strong></div>
<div>分库：就是一个数据库分成多个数据库，部署到不同机器。</div>
<div><span>分表：就是一个数据库表分成多个表。</span></div>
<div>我们在设计表的时候，其实可以提前估算一下，是否需要做分库分表。比如一些用户信息，未来可能数据量到达百万设置千万的话，就可以提前考虑分库分表。</div>
<div>&nbsp;</div>
<div><strong>为什么需要分库分表？</strong></div>
<div>&nbsp; &nbsp; 1)、数据量太大的话，SQL的查询就会变慢。</div>
<div>&nbsp; &nbsp; 2)、如果一个查询SQL没命中索引，千百万数据量级别的表可能会拖垮整个数据库。</div>
<div><span>&nbsp; &nbsp; 3)、即使SQL命中了索引，如果表的数据量超过一千万的话，查询也是会明显变慢的。这是因为索引一般是B+树结构，数据千万级别的话，B+树的高度会增高，查询就变慢了，因为磁盘IO次数变多了</span></div>
<div>&nbsp;</div>
<div><strong>15.sql编写的一些优化经验</strong></div>
<div>查询SQL不要使用select * ,而是select(具体字段)</div>
<div>避免在where子句中使用or来连接条件（可能会导致索引失效，因为or要两个条件都有索引）、</div>
<div>避免在索引列上使用mysql的内置函数</div>
<div>避免在where子句中对字段进行表达式操作，还有隐式转换</div>
<div>避免在where子句中使用 != 或 &lt;&gt; 操作符</div>
<div>使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。</div>
<div>对查询进行优化，应考虑在where及order by涉及的列上建立索引</div>
<div>如果插入数据过多，考虑批量插入</div>
<div>在适当的时候，使用覆盖索引</div>
<div>使用explain 分析你SQL的计划</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
</div>
<div>&nbsp;</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-12-22 16:23">2025-12-22 16:23</span>&nbsp;
<a href="https://www.cnblogs.com/philry">是大芒果</a>&nbsp;
阅读(<span id="post_view_count">30</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18831261);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18831261', targetLink: 'https://www.cnblogs.com/philry/p/18831261', title: '数据库表设计' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ 位置消偏 ]]></title>
    <link>https://www.cnblogs.com/GlenTt/p/19383094</link>
    <guid>277b7d4f5c8b62f97ca0b41e1a23bafe</guid>
    <description>
    <![CDATA[ 
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/GlenTt/p/19383094" title="发布于 2025-12-22 16:22">
    <span role="heading" aria-level="2">位置消偏</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="位置偏差指的是在用户--item-不变的前提下把同一条内容放在不同位置用户的点击概率会系统性变化这部分变化是由位置本身引起的而不是内容质量变化引起的"><strong>位置偏差指的是：在用户 / item 不变的前提下，把同一条内容放在不同位置，用户的点击概率会系统性变化</strong>——这部分变化是由位置本身引起的，而不是内容质量变化引起的。</h3>
<p>1.Recommending What Video to Watch Next: A Multitask Ranking System（google）</p>
<p>2.PAL: A Position-bias Aware Learning Framework for CTR Prediction in Live Recommender Systems（华为）</p>
<hr>
<h2 id="一googlerecommending-what-video-to-watch-next">一、Google：Recommending What Video to Watch Next</h2>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3670197/202512/3670197-20251222160346128-1897569845.png" class="lazyload"><br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3670197/202512/3670197-20251222160441684-811142632.png" class="lazyload"></p>
<h3 id="1-消偏的核心思想">1. 消偏的核心思想</h3>
<p>YouTube 的“下一个看什么”模型使用线上日志训练，日志里存在明显的 <strong>selection bias / position bias</strong>：</p>
<p>排在前面的候选被看见、被点击的概率更高，并不完全因为它质量更高，而是因为上游系统已经给过“加成”。</p>
<p>这篇文章的思路，可以概括为一句话：</p>
<blockquote>
<p><strong>把“观测到的点击”拆成“内容本身的效用（utility）”和“各种展示条件带来的偏置（propensity）之和，在模型结构中用两个塔分别建模。</strong><br>
形式上，相当于在 logit 上做一个分解：</p>
</blockquote>
<p>logit(CTR(<em>x</em>,bias_feat))=<em>f</em>main​(<em>x</em>)+<em>g</em>bias​(bias_feat)</p>
<ul>
<li><em>f</em>main​(<em>x</em>)：用户–视频的“真实偏好”（希望尽量去掉位置等偏差）；</li>
<li><em>g</em>bias​(⋅)：位置、设备、候选来源、上一版系统评分等造成的偏移。</li>
</ul>
<p>训练时，<strong>两者相加</strong>来拟合日志中的点击；</p>
<p>排序上线时，可以选择只依赖 <em>f</em>main​(<em>x</em>)，或者显著弱化/归一化 <em>g</em>bias​，从而达到“减小偏差”的目的。</p>
<h3 id="2-具体实现结构">2. 具体实现结构</h3>
<ol>
<li>
<p><strong>Main Tower：多任务 MMoE Ranking 网络</strong></p>
<ul>
<li>输入：用户特征、历史行为（watch history）、候选视频特征、上下文特征等；</li>
<li>结构：embedding → shared-bottom DNN → MMoE（多个专家 + 每个任务各自的 gate）；</li>
<li>输出：多个任务头（click、watch time、满意度等）。</li>
</ul>
</li>
<li>
<p>这部分主要为 <strong>学习稳定的用户–视频表达</strong>，且要兼顾多个优化目标。</p>
</li>
<li>
<p><strong>Shallow Tower（Bias Tower）：浅层偏差网络</strong></p>
<ul>
<li>输入：只选与 selection bias 强相关的特征：position、上游排序分、设备、入口、语言等；</li>
<li>结构：一到两层的小 DNN；</li>
<li>输出：一个标量偏置 <em>g</em>bias​，加到 main tower 的 logit 上。</li>
</ul>
</li>
<li>
<p><strong>特征 Dropout：防止“全靠位置解释点击”</strong>如果简单把 position 交给 shallow tower，模型可能会走“捷径”：直接用位置来解释大部分点击，main tower 反而学不到有效的内容信号。因此训练中在 bias 特征上做较强的 dropout（或者给 shallow tower 很低的容量、较强正则），让 main tower 也必须承担足够的解释力。这样 <em>f</em>main​(<em>x</em>) 更接近“去位置偏差”的效用。</p>
</li>
<li>
<p><strong>Serving 策略</strong></p>
<ul>
<li>在排序阶段，常见做法是 <strong>不给 position 相关特征，或者固定为统一值</strong>，从而弱化甚至移除 <em>g</em>bias​ 对排序的影响；</li>
<li>如果某些模块确实需要“带偏的真实 CTR”（例如收益评估），还可以单独把 bias tower 再加回去算一个“现实 CTR”。</li>
</ul>
</li>
</ol>
<h3 id="3-各部分在消偏中的作用">3. 各部分在消偏中的作用</h3>
<ul>
<li><strong>Main Tower</strong>：主要承载“真实兴趣”的建模，是最终用于排序的核心分数；MMoE 解决多目标之间梯度冲突，使这个表示尽可能稳定、泛化好。</li>
<li><strong>Shallow Tower</strong>：把短期、强烈、但结构较简单的 bias（位置、入口、曝光策略）吸收入一个可控制的通道，避免 main tower 对这些因素过拟合。</li>
<li><strong>Bias 特征 Dropout / 小容量设计</strong>：强迫 main tower 不得不解释一部分点击信号，否则 shallow tower 会把所有监督“吃掉”，去偏效果就会失真。</li>
</ul>
<h3 id="4实验结果">4.实验结果</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3670197/202512/3670197-20251222160735172-498688773.png" class="lazyload"></p>
<p>1.训练样本的分布，被点击的样本其位置特征越靠前<br>
2.最后的position bias符合预期，越靠前，其position bias越大，当推理去除时，对靠后的样本，补偿就越大，起到一个debias 的作用</p>
<h3 id="5评价">5.评价</h3>
<ol>
<li><strong>偏差建模是“隐式”的，而不是严格的因果建模</strong>虽然直观上可以解释为“utility + propensity”，但从优化上看只是对 logit 做了一个可学习的分解，<strong>没有任何硬约束保证 <strong><em>f</em>main​</strong> 就是真实效用、</strong><em>g</em>bias​** 就是纯粹偏差**。两者之间存在可交换性：网络完全可以把一部分内容效用塞进 bias tower，只要整体 loss 不变。</li>
<li>能够处理的不只是 position bias，而是一揽子的“条件偏差”从工程角度很灵活，但从理论上说，它把所有与展示条件相关的因素统统扔进一个 shallow tower，难以区分各类 bias 的贡献，不适合做精细的公平性/因果分析。</li>
<li><strong>sample selection bias 仍然存在</strong>模型仍旧在上一版推荐系统生成的候选上训练，这天生带来 selection bias（没被召回的 item 没有 label）。shallow tower 只是在 ranking 这一层做了结构上的消偏，对候选生成阶段的偏差基本无能为力。</li>
<li><strong>“消偏效果”高度依赖工程细节</strong>例如：bias 特征放哪些、dropout 比例多大、shallow tower 容量如何设定、线上是否真的去掉 bias 特征等。这些并没有统一理论指引，更多依赖经验和 A/B 实验。</li>
</ol>
<hr>
<h2 id="二华为palposition-bias-aware-learning">二、华为：PAL（Position-bias Aware Learning）</h2>
<h3 id="1-消偏的核心思想-1">1. 消偏的核心思想</h3>
<p>PAL 背景更具体：在一些线上业务中，<strong>训练 CTR 模型时可以使用 position 特征，但排序预测阶段并不知道最终位置</strong>——先要根据 CTR 排序，排序结果再决定位置。这就产生了典型的“训练有位置、预测没位置”的矛盾。</p>
<p>工业界常见的粗暴做法：</p>
<ul>
<li>训练时让模型使用位置特征；</li>
<li>预测时给所有候选一个“默认位置”（比如 1、5、10），用该位置值喂进模型。</li>
</ul>
<p>不同默认位置会得到完全不同的排序结果，且很不稳定。</p>
<p>PAL 的核心思想是把点击拆成两个阶段的概率乘积，并对每一项分别建模：</p>
<p><em>p</em>(click∣<em>x</em>,<em>pos</em>)=<em>p</em>(seen∣<em>pos</em>)⋅<em>p</em>(click∣<em>x</em>,seen)</p>
<p>再做两个关键假设：</p>
<ol>
<li><strong>“是否被看到”只由 position 决定</strong>即 <em>p</em>(seen∣<em>x</em>,<em>pos</em>)≈<em>p</em>(seen∣<em>pos</em>)；</li>
<li><strong>在已经被看到的前提下，点击与 position 无关</strong>即 <em>p</em>(click∣<em>x</em>,<em>pos</em>,seen)≈<em>p</em>(click∣<em>x</em>,seen)。</li>
</ol>
<p>如此一来：</p>
<ul>
<li>第一项是纯粹的 <strong>位置曝光概率</strong>；</li>
<li>第二项可视为 <strong>“在所有 item 都被同样看见”时的真实兴趣点击率</strong>。</li>
</ul>
<p>训练阶段用乘积来拟合日志 CTR，</p>
<p>排序阶段直接用第二项 <em>p</em>(click∣<em>x</em>,seen)，自然就不再需要位置特征。</p>
<h3 id="2-具体实现结构-1">2. 具体实现结构</h3>
<ol>
<li>
<p><strong>ProbSeen(pos)：位置曝光模块</strong></p>
<ul>
<li>输入：position（可能再加少量页面级上下文）；</li>
<li>结构：embedding → 小型 DNN → sigmoid 输出到 [0,1]；</li>
<li>含义：学“该位置下被真正注意到的概率”，近似传统点击模型里的 examination 函数。</li>
</ul>
</li>
<li>
<p><strong>pCTR(x)：条件 CTR 模块</strong></p>
<ul>
<li>输入：用户、item、上下文等特征，但 <strong>不包含 position</strong>；</li>
<li>结构：任意现成 CTR 网络（DeepFM / Wide&amp;Deep / DIN等）；</li>
<li>输出：在“已看到”的前提下，点击概率。</li>
</ul>
</li>
<li>
<p><strong>联合训练</strong></p>
<ul>
<li>合成点击预测：</li>
</ul>
</li>
</ol>
<p><em>p</em>^​(<em>y</em>=1∣<em>x</em>,<em>pos</em>)=<em>ProbSeen</em>(<em>pos</em>)×<em>pCTR</em>(<em>x</em>)</p>
<ul>
<li>使用普通二分类交叉熵对观测到的 click label 做监督；</li>
<li>两个模块参数一次性 end-to-end 更新。</li>
</ul>
<p>这种训练方式保证了两部分<strong>在同一个目标下联合适配</strong>，而不是“先估曝光率，再单独训 CTR”。</p>
<ol start="4">
<li>
<p><strong>Serving 策略</strong></p>
<ul>
<li>排序阶段只上线 pCTR 模块：score = pCTR(x)；</li>
<li>如果系统某处需要“带位置”的现实 CTR，可再用离线学习到的 ProbSeen(pos) 补回。</li>
</ul>
</li>
</ol>
<h3 id="3-各部分在消偏中的作用-1">3. 各部分在消偏中的作用</h3>
<ul>
<li><strong>ProbSeen</strong>：显式承担位置偏差的建模任务，是 PAL 的“偏差塔”。</li>
<li><strong>pCTR</strong>：负责学习“内容兴趣 + 用户偏好”，在结构上完全与 position 解耦，是 PAL 想要的“去偏 CTR”。</li>
<li><strong>乘积形式</strong>：保证这两个模块都在概率域是可解释的；与加法形态相比，这更像传统 exam–click 模型：先看见，再点击。</li>
</ul>
<h3 id="4-批判性评价">4. 批判性评价</h3>
<ol>
<li>
<p><strong>核心假设过于理想化</strong></p>
<ul>
<li>实际上，用户是否“看到”一个推荐，不仅取决于位置，还取决于 <strong>item 的显眼程度、封面、标题长度、用户滚动速度、屏幕大小等</strong>；更合理的应是 <em>p</em>(seen∣<em>x</em>,<em>pos</em>)，而不只是 <em>pos</em>。</li>
<li>即便在“已被看到”条件下，位置仍可能影响点击，例如：首条更可信、后面的更像广告，等等。这些都会违背“点击与 position 无关”的假设。</li>
</ul>
</li>
<li>
<p>因此，PAL 在理论上是一个比较“干净”的分解，但在现实业务中一定会有系统偏差残留在 pCTR 模块里，消偏效果取决于场景是否“近似满足”这些假设。</p>
</li>
<li>
<p><strong>存在可辨识性问题</strong>数学上，如果把 ProbSeen 整体乘以常数 <em>c</em>，再把 pCTR 整体除以 <em>c</em>，乘积不变，loss 一样小。这说明两个模块在纯数据层面并不是强可辨识的。实际训练中，谁负责什么，很大程度依赖于：</p>
<ul>
<li>初始化方式；</li>
<li>两边网络容量；</li>
<li>正则化强度。</li>
</ul>
</li>
<li>
<p>这会导致结果对实现细节很敏感，很难保证“ProbSeen 真的是位置曝光概率”。</p>
</li>
<li>
<p><strong>只能处理“位置”这一维的偏差</strong>在很多业务里，selection bias 来自多种因素：入口、流量策略、探索策略、历史曝光频次等。PAL 把 bias 完全归因于 position，<strong>无法显式建模其他偏差来源</strong>；这些因素要么被 pCTR 强行吸收，要么只能另想办法处理。</p>
</li>
<li>
<p><strong>训练数据仍来源于偏置系统</strong>PAL 没有改变训练样本本身“来源于旧系统排序”的事实，因此在候选集选择层面的偏差仍旧存在，只是对 position 这一维度做了结构化处理。</p>
</li>
</ol>
<hr>
<h2 id="三两篇工作在消偏上的共同点与差异">三、两篇工作在消偏上的共同点与差异</h2>
<p><strong>共同点</strong></p>
<ul>
<li>
<p>都承认：日志里的点击混杂了“用户真实偏好”和“展示条件偏差”，不能直接当作“公平的真实喜好”；</p>
</li>
<li>
<p>都采用了 <strong>“主塔 + 偏差塔”</strong> 的结构分解：</p>
<ul>
<li>主塔强调内容/用户的效用；</li>
<li>偏差塔强调位置、入口、上游系统排序等引入的倾斜；</li>
</ul>
</li>
<li>
<p>排序上线时，都倾向于 <strong>只用主塔</strong>（或显著弱化偏差塔）来提高公平性和泛化。</p>
</li>
</ul>
<p><strong>差异</strong></p>
<ul>
<li>
<p><strong>分解形式不同</strong></p>
<ul>
<li>Google：logit 加法，偏差与效用是可加的；</li>
<li>PAL：概率乘法，偏差是“被看到概率”，效用是“看到后的点击概率”，解释接近经典点击模型。</li>
</ul>
</li>
<li>
<p><strong>偏差塔输入的范围不同</strong></p>
<ul>
<li>Google 的 shallow tower 可以吃多种 bias 特征（位置、上游排序分、设备等），更工程化；</li>
<li>PAL 的 ProbSeen 只吃 position，更专注但也更受限。</li>
</ul>
</li>
<li>
<p><strong>在“训练有位置、预测无位置”问题上的针对性</strong></p>
<ul>
<li>Google 方案更像是“即便预测时还有 position，我也让模型知道它只是偏置的一部分，有机会在 serving 时关掉它”；</li>
<li>PAL 则直接从概率分解出发，设计出一个在结构上就可以天然“训练有位置、预测不需要位置”的框架。</li>
</ul>
</li>
</ul>
<h3 id="实践经验">实践经验</h3>
<p>当前采用 shallow tower 引入位置特征，并与主塔通过加法或乘法进行交互，本质上是在整体样本分布下学习不同位置对应的平均点击贡献。然而在真实数据中，位置与内容质量高度相关，靠前位置天然聚集了用户更感兴趣的内容，靠后位置则相反，因此 shallow tower 学到的并非纯粹的位置因果效应，<strong><strong>而是位置偏置与内容分布偏置的混合结果</strong></strong>。训练阶段引入 shallow tower、推理阶段将其移除，会导致模型在训练与推理阶段的函数形式不一致，主塔参数已隐含依赖 shallow tower 的补偿效果，<strong><strong>从而难以保证去除的仅是位置贡献</strong></strong>。</p>
<p>无论采用加法还是乘法交互，该问题本质上都无法通过建模形式解决，实际表现往往是训练指标改善有限、线上效果不稳定，目前认为该类基于相关性分解的位置消偏思路在当前数据分布下存在根本局限。</p>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-12-22 16:22">2025-12-22 16:22</span>&nbsp;
<a href="https://www.cnblogs.com/GlenTt">GRITJW</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19383094);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19383094', targetLink: 'https://www.cnblogs.com/GlenTt/p/19383094', title: '位置消偏' })">举报</a>

		</p>
	 ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ MySQL 在哪些场景下不会写 binlog ]]></title>
    <link>https://www.cnblogs.com/ivictor/p/19382809</link>
    <guid>a9fcc8e5588c8766e623484def22e168</guid>
    <description>
    <![CDATA[ 
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ivictor/p/19382809" title="发布于 2025-12-22 15:47">
    <span role="heading" aria-level="2">MySQL 在哪些场景下不会写 binlog</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">背景</span></h1>
<p data-tool="mdnice编辑器"><span>在 MySQL 中，慢日志不仅可以记录在文件中，还可以记录在表中。具体是记录在文件还是表中是由<code><span>log_output</span></code><span>参数决定的。</span></span></p>
<p data-tool="mdnice编辑器"><span>该参数默认为<code><span>FILE</span></code><span>，即慢日志默认会记录在文件中。如果参数中包含<code><span>TABLE</span></code><span>，则慢日志还会记录在<code><span>mysql.slow_log</span></code><span>中，而<code><span>mysql.slow_log</span></code><span>使用的是 CSV 存储引擎。</span></span></span></span></span></p>
<p data-tool="mdnice编辑器"><span>最初研究这一问题，是为了确认在主从复制以及组复制（MGR）环境下，<code><span>mysql.slow_log</span></code><span>表中的慢日志是否会同步到其他节点。</span></span></p>
<p data-tool="mdnice编辑器"><span>随着分析的深入，发现 MySQL 实际上提供了多种机制和开关，用于确保操作不会写入 binlog。</span></p>
<p data-tool="mdnice编辑器"><span>由于&nbsp;<strong>ROW 格式</strong><span>&nbsp;是目前最常用的 binlog 格式，本文将从&nbsp;<strong>ROW 模式下 MySQL 判断操作是否写入 binlog 的实现逻辑</strong><span>&nbsp;入手，逐步引出相关控制开关，并分析它们各自的使用场景。</span></span></span></p>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">ROW 格式下判断操作是否写入 binlog 的实现逻辑</span></h1>
<p data-tool="mdnice编辑器"><span>在 ROW 格式下，将数据变化记录到 binlog 的核心是在<code><span>binlog_log_row</span></code><span>函数中实现的：</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVlibSwibjXiaMnylbHVGpQcib8UWIFerYZgIR9sxBIBCgO6hYKkExWrhsjMPIQa1yIOMmrRGFx1dEib6vlCuJygOxAZF/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>int<span>&nbsp;<span>binlog_log_row<span>(TABLE *table,&nbsp;<span>const<span>&nbsp;uchar *before_record,<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span>const<span>&nbsp;uchar *after_record, Log_func *log_func)<span>&nbsp;<span>{<span><br>bool<span>&nbsp;error =&nbsp;false<span>;<span><br><span>&nbsp; THD *const<span>&nbsp;thd = table-&gt;in_use;<span><br>// 判断当前操作是否需要写入 binlog<span><br>if<span>&nbsp;(check_table_binlog_row_based(thd, table)) {<span><br><span>&nbsp; &nbsp; ...<span><br><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(likely(!(error = write_locked_table_maps(thd)))) {<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;boolconst<span>&nbsp;has_trans = thd-&gt;lex-&gt;sql_command == SQLCOM_CREATE_TABLE ||<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;table-&gt;file-&gt;has_transactions();<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;// 根据操作类型，将行镜像写入 binlog<span><br><span>&nbsp; &nbsp; &nbsp; error = (*log_func)(thd, table, has_trans, before_record, after_record);<span><br><span>&nbsp; &nbsp; }<span><br><span>&nbsp; }<span><br><span><br>return<span>&nbsp;error ? HA_ERR_RBR_LOGGING_FAILED :&nbsp;0<span>;<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>首先调用&nbsp;<code><span>check_table_binlog_row_based</span></code><span>&nbsp;判断当前操作是否需要写入 binlog，若需要，则会针对不同的操作类型，调用不同的函数来处理。具体来说：</span></span></p>
<ul class="list-paddingleft-1">
<li><span>INSERT：<code><span>Write_rows_log_event::binlog_row_logging_function</span></code><span>。</span></span></li>
<li><span>UPDATE：<code><span>Update_rows_log_event::binlog_row_logging_function</span></code><span>。</span></span></li>
<li><span>DELETE：<code><span>Delete_rows_log_event::binlog_row_logging_function</span></code><span>。</span></span></li>
</ul>
<p data-tool="mdnice编辑器"><span>接下来，重点看看<code><span>check_table_binlog_row_based</span></code><span>函数的处理逻辑。</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVlibSwibjXiaMnylbHVGpQcib8UWIFerYZgIR9sxBIBCgO6hYKkExWrhsjMPIQa1yIOMmrRGFx1dEib6vlCuJygOxAZF/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>static<span>&nbsp;<span>bool<span>&nbsp;<span>check_table_binlog_row_based<span>(THD *thd, TABLE *table)<span>&nbsp;<span>{<span><br>if<span>&nbsp;(table-&gt;s-&gt;cached_row_logging_check ==&nbsp;-1<span>) {<span><br><span>&nbsp; &nbsp;&nbsp;<span>int<span>&nbsp;<span>const<span>&nbsp;<span>check<span>(table-&gt;s-&gt;tmp_table == NO_TMP_TABLE &amp;&amp;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !table-&gt;no_replicate &amp;&amp;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binlog_filter-&gt;db_ok(table-&gt;s-&gt;db.str))<span>;<span><br><span>&nbsp; &nbsp; table-&gt;s-&gt;cached_row_logging_check = check;<span><br><span>&nbsp; }<span><br><span><br><span>&nbsp; assert(table-&gt;s-&gt;cached_row_logging_check ==&nbsp;0<span>&nbsp;||<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;table-&gt;s-&gt;cached_row_logging_check ==&nbsp;1<span>);<span><br><span><br>return<span>&nbsp;(thd-&gt;is_current_stmt_binlog_format_row() &amp;&amp;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table-&gt;s-&gt;cached_row_logging_check &amp;&amp;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (thd-&gt;variables.option_bits &amp; OPTION_BIN_LOG) &amp;&amp;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mysql_bin_log.is_open());<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>要返回 false，只需满足以下任意一个条件：</span></p>
<ul class="list-paddingleft-1">
<li><span>当前 SQL 语句不能以 ROW 格式记录到 binlog 中：<code><span>thd-&gt;is_current_stmt_binlog_format_row()</span></code><span>为 false，例如 DDL 语句。</span></span></li>
<li><span>表不允许写入 binlog：<code><span>table-&gt;s-&gt;cached_row_logging_check</span></code><span>为 false。</span></span></li>
<li><span>当前线程未启用 binlog：<code><span>thd-&gt;variables.option_bits &amp; OPTION_BIN_LOG</span></code><span>为 false。</span></span></li>
<li><span>binlog 未打开：<code><span>mysql_bin_log.is_open()</span></code><span>&nbsp;为 false。</span></span></li>
</ul>
<p data-tool="mdnice编辑器"><span>因为第一个条件和第四个条件为 false 的情况并不常见，下面将重点分析<code><span>table-&gt;s-&gt;cached_row_logging_check</span></code><span>和<code><span>thd-&gt;variables.option_bits &amp; OPTION_BIN_LOG</span></code><span>为 false 时的场景。</span></span></span></p>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">cached_row_logging_check 为 false 的场景</span></h1>
<p data-tool="mdnice编辑器"><code><span>table-&gt;s-&gt;cached_row_logging_check</span></code><span>的赋值逻辑如下：</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVlibSwibjXiaMnylbHVGpQcib8UWIFerYZgIR9sxBIBCgO6hYKkExWrhsjMPIQa1yIOMmrRGFx1dEib6vlCuJygOxAZF/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>&nbsp;&nbsp;if<span>&nbsp;(table-&gt;s-&gt;cached_row_logging_check ==&nbsp;-1<span>) {<span><br><span>&nbsp; &nbsp;&nbsp;<span>int<span>&nbsp;<span>const<span>&nbsp;<span>check<span>(table-&gt;s-&gt;tmp_table == NO_TMP_TABLE &amp;&amp;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !table-&gt;no_replicate &amp;&amp;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binlog_filter-&gt;db_ok(table-&gt;s-&gt;db.str))<span>;<span><br><span>&nbsp; &nbsp; table-&gt;s-&gt;cached_row_logging_check = check;<span><br><span>&nbsp; }<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>要使其为 false，必须满足以下任意一个条件：</span></p>
<ol class="list-paddingleft-1">
<li><span>当前表是临时表：&nbsp;<code><span>table-&gt;s-&gt;tmp_table == NO_TMP_TABLE</span></code><span>为 false。</span></span></li>
<li><span>库名不满足 --replicate-do-db、--replicate-ignore-db 复制规则：<code><span>binlog_filter-&gt;db_ok(table-&gt;s-&gt;db.str)</span></code><span>为 false。</span></span></li>
<li><span>表设置了 no_replicate。该属性是在<code><span>open_table_from_share()</span></code><span>函数中根据表的类型和存储引擎能力标志设置的。</span></span></li>
</ol>
<p data-tool="mdnice编辑器"><span>no_replicate 的设置逻辑如下：</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVlibSwibjXiaMnylbHVGpQcib8UWIFerYZgIR9sxBIBCgO6hYKkExWrhsjMPIQa1yIOMmrRGFx1dEib6vlCuJygOxAZF/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>&nbsp;&nbsp;if<span>&nbsp;((share-&gt;table_category == TABLE_CATEGORY_LOG) ||<span><br><span>&nbsp; &nbsp; &nbsp; (share-&gt;table_category == TABLE_CATEGORY_RPL_INFO) ||<span><br><span>&nbsp; &nbsp; &nbsp; (share-&gt;table_category == TABLE_CATEGORY_GTID)) {<span><br><span>&nbsp; &nbsp; outparam-&gt;no_replicate =&nbsp;true<span>;<span><br><span>&nbsp; }&nbsp;else<span>&nbsp;if<span>&nbsp;(outparam-&gt;file) {<span><br><span>&nbsp; &nbsp;&nbsp;const<span>&nbsp;handler::Table_flags flags = outparam-&gt;file-&gt;ha_table_flags();<span><br><span>&nbsp; &nbsp; outparam-&gt;no_replicate =<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; !(flags &amp; (HA_BINLOG_STMT_CAPABLE | HA_BINLOG_ROW_CAPABLE)) ||<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; HA_HAS_OWN_BINLOGGING);<span><br><span>&nbsp; }&nbsp;else<span>&nbsp;{<span><br><span>&nbsp; &nbsp; outparam-&gt;no_replicate =&nbsp;false<span>;<span><br><span>&nbsp; }<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>可以看到，no_replicate 会在以下几种情况设置为 true。</span></p>
<p data-tool="mdnice编辑器"><span>一、特殊类别的表。包括：</span></p>
<ul class="list-paddingleft-1">
<li><span>TABLE_CATEGORY_LOG 类别的表，具体包括 mysql.general_log, mysql.slow_log。</span></li>
<li><span>TABLE_CATEGORY_RPL_INFO 类别的表，具体包括 mysql.slave_relay_log_info，mysql.slave_master_info，mysql.slave_worker_info。</span></li>
<li><span>TABLE_CATEGORY_GTID 类别的表，具体包括 mysql.gtid_executed。</span></li>
</ul>
<p data-tool="mdnice编辑器"><span>二、根据存储引擎的能力标志判断。</span></p>
<p data-tool="mdnice编辑器"><span>这些标志是每个存储引擎单独设置的，一般是在<code><span>m_int_table_flags</span></code><span>或<code><span>table_flags</span></code><span>函数中定义的，主要是用来向 Server 层声明：这个存储引擎的表，支持哪些能力/约束。与复制相关的标志有三个：</span></span></span></p>
<ul class="list-paddingleft-1">
<li><span>HA_BINLOG_STMT_CAPABLE：支持 STATEMENT 格式 binlog。</span></li>
<li><span>HA_BINLOG_ROW_CAPABLE：支持 ROW 格式 binlog</span></li>
<li><span>HA_HAS_OWN_BINLOGGING：该引擎自己管理 binlog（如 NDB Cluster）。</span></li>
</ul>
<p data-tool="mdnice编辑器"><span>在 MySQL 支持的存储引擎中，只有 perfschema（对应 performance_schema）和 temptable（MySQL 8.0 引入的内部临时表存储引擎，主要用来替代老的 MEMORY/MyISAM 内部临时表）不会设置 HA_BINLOG_STMT_CAPABLE 或 HA_BINLOG_ROW_CAPABLE。</span></p>
<p data-tool="mdnice编辑器"><span>所以，针对 performance_schema 表的操作不会写入 binlog。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVlibSwibjXiaMnylbHVGpQcib8UWIFerYZgIR9sxBIBCgO6hYKkExWrhsjMPIQa1yIOMmrRGFx1dEib6vlCuJygOxAZF/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code># ls mysql-8.4.3/storage/<span><br><span>archive &nbsp;blackhole &nbsp;csv &nbsp;example &nbsp;federated &nbsp;heap &nbsp;innobase &nbsp;myisam &nbsp;myisammrg &nbsp;ndb &nbsp;perfschema &nbsp;secondary_engine_mock &nbsp;temptable<span><br></span></span></span></code></span></pre>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">OPTION_BIN_LOG 为 false 的场景</span></h1>
<p data-tool="mdnice编辑器"><code><span>thd-&gt;variables</span></code><span>保存当前线程的会话级系统变量状态。其中，option_bits 是一个位图（bitmap），用于记录多个线程级选项标志，OPTION_BIN_LOG 则表示是否将当前线程的操作写入 binlog。</span></p>
<p data-tool="mdnice编辑器"><span>以下是几种典型场景。</span></p>
<p data-tool="mdnice编辑器"><span>一、显式关闭会话级 binlog</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVlibSwibjXiaMnylbHVGpQcib8UWIFerYZgIR9sxBIBCgO6hYKkExWrhsjMPIQa1yIOMmrRGFx1dEib6vlCuJygOxAZF/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>SET<span>&nbsp;SESSION<span>&nbsp;sql_log_bin =&nbsp;0<span>;<span><br></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>该参数对应的回调函数是<code><span>fix_sql_log_bin_after_update</span></code><span>。</span></span></p>
<p data-tool="mdnice编辑器"><span>当<code><span>sql_log_bin = 1</span></code><span>时，打开 OPTION_BIN_LOG，反之，则清除 OPTION_BIN_LOG。</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVlibSwibjXiaMnylbHVGpQcib8UWIFerYZgIR9sxBIBCgO6hYKkExWrhsjMPIQa1yIOMmrRGFx1dEib6vlCuJygOxAZF/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>static<span>&nbsp;<span>bool<span>&nbsp;<span>fix_sql_log_bin_after_update<span>(sys_var *, THD *thd,<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;enum_var_type type [[maybe_unused]])<span>&nbsp;<span>{<span><br><span>&nbsp; assert(type == OPT_SESSION);<span><br><span><br><span>&nbsp;&nbsp;if<span>&nbsp;(thd-&gt;variables.sql_log_bin)<span><br><span>&nbsp; &nbsp; thd-&gt;variables.option_bits |= OPTION_BIN_LOG;<span><br><span>&nbsp;&nbsp;else<span><br><span>&nbsp; &nbsp; thd-&gt;variables.option_bits &amp;= ~OPTION_BIN_LOG;<span><br><span><br><span>&nbsp;&nbsp;return<span>&nbsp;false<span>;<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>二、从库未启用 log_replica_updates</span></p>
<p data-tool="mdnice编辑器"><span>当实例作为从库运行，且未开启 log_replica_updates 时，从库 SQL 线程重放的操作默认不写 binlog。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVlibSwibjXiaMnylbHVGpQcib8UWIFerYZgIR9sxBIBCgO6hYKkExWrhsjMPIQa1yIOMmrRGFx1dEib6vlCuJygOxAZF/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>void<span>&nbsp;<span>set_slave_thread_options<span>(THD *thd)<span>&nbsp;<span>{<span><br><span>&nbsp; ...<span><br><span>&nbsp; ulonglong options = thd-&gt;variables.option_bits | OPTION_BIG_SELECTS;<span><br><span>&nbsp;&nbsp;if<span>&nbsp;(opt_log_replica_updates)<span><br><span>&nbsp; &nbsp; options |= OPTION_BIN_LOG;<span><br><span>&nbsp;&nbsp;else<span><br><span>&nbsp; &nbsp; options &amp;= ~OPTION_BIN_LOG;<span><br><span>&nbsp; ...<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>三、使用<code><span>Disable_binlog_guard</span></code><span>临时关闭 binlog</span></span></p>
<p data-tool="mdnice编辑器"><code><span>Disable_binlog_guard</span></code><span>用于在特定代码块内临时关闭 binlog，并在离开作用域时自动恢复原状态。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVlibSwibjXiaMnylbHVGpQcib8UWIFerYZgIR9sxBIBCgO6hYKkExWrhsjMPIQa1yIOMmrRGFx1dEib6vlCuJygOxAZF/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>class<span>&nbsp;<span>Disable_binlog_guard<span>&nbsp;{<span><br><span>&nbsp;public<span>:<span><br><span>explicit<span>&nbsp;<span>Disable_binlog_guard<span>(THD *thd)<span><br><span>&nbsp; &nbsp; &nbsp; :&nbsp;<span>m_thd<span>(thd)<span>,<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>m_binlog_disabled<span>(thd-&gt;variables.option_bits &amp; OPTION_BIN_LOG)<span>&nbsp;<span>{<span><br><span>&nbsp; &nbsp; thd-&gt;variables.option_bits &amp;= ~OPTION_BIN_LOG;<span><br><span>&nbsp; }<span><br><span><br><span>&nbsp; ~Disable_binlog_guard() {<span><br><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(m_binlog_disabled) m_thd-&gt;variables.option_bits |= OPTION_BIN_LOG;<span><br><span>&nbsp; }<span><br><span><br>private<span>:<span><br><span>&nbsp; THD *const<span>&nbsp;m_thd;<span><br>constbool<span>&nbsp;m_binlog_disabled;<span><br><span>};<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>Disable_binlog_guard 被调用的场景有：</span></p>
<p data-tool="mdnice编辑器"><span>3.1 实例初始化（<code><span>--initialize</span></code><span>）</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVlibSwibjXiaMnylbHVGpQcib8UWIFerYZgIR9sxBIBCgO6hYKkExWrhsjMPIQa1yIOMmrRGFx1dEib6vlCuJygOxAZF/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>static<span>&nbsp;<span>bool<span>&nbsp;<span>handle_bootstrap_impl<span>(handle_bootstrap_args *args)<span>&nbsp;<span>{<span><br><span>&nbsp; ...<span><br>if<span>&nbsp;(opt_initialize) {<span><br><span>&nbsp; &nbsp; assert(thd-&gt;system_thread == SYSTEM_THREAD_SERVER_INITIALIZE);<span><br><span><br><span>&nbsp; &nbsp; sysd::notify("STATUS=Initialization of MySQL system tables in progress\n"<span>);<span><br><span>&nbsp; &nbsp;&nbsp;<span><br><span>&nbsp; &nbsp;&nbsp;<span>const<span>&nbsp;Disable_binlog_guard&nbsp;<span>disable_binlog<span>(thd)<span>;<span><br><span>&nbsp; &nbsp;&nbsp;<span>const<span>&nbsp;Disable_sql_log_bin_guard&nbsp;<span>disable_sql_log_bin<span>(thd)<span>;<span><br><span><br><span>&nbsp; &nbsp; Compiled_in_command_iterator comp_iter;<span><br><span>&nbsp; &nbsp; rc = process_iterator(thd, &amp;comp_iter,&nbsp;true<span>);<span><br><span><br><span>&nbsp; &nbsp; thd-&gt;system_thread = SYSTEM_THREAD_INIT_FILE;<span><br><span><br><span>&nbsp; &nbsp; sysd::notify("STATUS=Initialization of MySQL system tables "<span>,<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rc ?&nbsp;"unsuccessful"<span>&nbsp;:&nbsp;"successful"<span>,&nbsp;"\n"<span>);<span><br><span><br><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(rc !=&nbsp;0<span>) {<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;returntrue<span>;<span><br><span>&nbsp; &nbsp; }<span><br><span>&nbsp; }<span><br><span>&nbsp; ...<span><br>returnfalse<span>;<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>3.2 实例升级</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVlibSwibjXiaMnylbHVGpQcib8UWIFerYZgIR9sxBIBCgO6hYKkExWrhsjMPIQa1yIOMmrRGFx1dEib6vlCuJygOxAZF/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>bool<span>&nbsp;<span>upgrade_system_schemas<span>(THD *thd)<span>&nbsp;<span>{<span><br><span>Disable_autocommit_guard&nbsp;<span>autocommit_guard<span>(thd)<span>;<span><br><span>&nbsp; Bootstrap_error_handler bootstrap_error_handler;<span><br><span><br><span>Server_option_guard&lt;<span>bool<span>&gt;&nbsp;<span>acl_guard<span>(&amp;opt_noacl,&nbsp;<span>true<span>)<span>;<span><br><span>Server_option_guard&lt;<span>bool<span>&gt;&nbsp;<span>general_log_guard<span>(&amp;opt_general_log,&nbsp;<span>false<span>)<span>;<span><br><span>Server_option_guard&lt;<span>bool<span>&gt;&nbsp;<span>slow_log_guard<span>(&amp;opt_slow_log,&nbsp;<span>false<span>)<span>;<span><br><span>Disable_binlog_guard&nbsp;<span>disable_binlog<span>(thd)<span>;<span><br><span>Disable_sql_log_bin_guard&nbsp;<span>disable_sql_log_bin<span>(thd)<span>;<span><br><span>&nbsp; ...<span><br><span>&nbsp; bootstrap_error_handler.set_log_error(false<span>);<span><br>bool<span>&nbsp;err =<span><br><span>&nbsp; &nbsp; &nbsp; fix_mysql_tables(thd) || fix_sys_schema(thd) || upgrade_help_tables(thd);<span><br>if<span>&nbsp;(!err) {<span><br><span>&nbsp; &nbsp;&nbsp;<span>/*<span><br><span>&nbsp; &nbsp; &nbsp; Initialize structures necessary for federated server from mysql.servers<span><br><span>&nbsp; &nbsp; &nbsp; table.<span><br><span>&nbsp; &nbsp; */<span><br><span>&nbsp; &nbsp; servers_init(thd);<span><br><span>&nbsp; &nbsp; err = (DBUG_EVALUATE_IF("force_fix_user_schemas"<span>,&nbsp;true<span>,<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dd::bootstrap::DD_bootstrap_ctx::instance()<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .is_server_upgrade_from_before(<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bootstrap::SERVER_VERSION_80011))<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;? check.check_all_schemas(thd)<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: check.check_system_schemas(thd)) ||<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check.repair_tables(thd) ||<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dd::tables::DD_properties::instance().set<span>(<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thd,&nbsp;"MYSQLD_VERSION_UPGRADED"<span>, MYSQL_VERSION_ID);<span><br><span>&nbsp; }<span><br><span>&nbsp; ...<span><br>return<span>&nbsp;dd::end_transaction(thd, err);<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>3.3 CREATE SERVER, ALTER SERVER 和 DROP SERVER 操作。</span></p>
<p data-tool="mdnice编辑器"><span>3.4 INSTALL COMPONENT, UNINSTALL COMPONENT 操作。</span></p>
<p data-tool="mdnice编辑器"><span>3.5 INSTALL PLUGIN, UNINSTALL PLUGIN 操作。</span></p>
<p data-tool="mdnice编辑器"><span>3.6 一些内部操作，例如 ALTER TABLE 过程中创建/删除临时表、DROP DATABASE 时清理数据库对象、更新数据字典表、后台线程自动更新列直方图。</span></p>
<p data-tool="mdnice编辑器"><span>除了上面介绍的这些场景，通过将&nbsp;<code><span>thd-&gt;lex-&gt;no_write_to_binlog</span></code><span>&nbsp;设置为<code><span>true</span></code><span>（<code><span>thd-&gt;lex</span></code><span>表示当前 SQL 语句的语法解析上下文），可以在语句级别控制该语句不写入 binlog。</span></span></span></span></p>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">NO_WRITE_TO_BINLOG 为 true 的场景</span></h1>
<p data-tool="mdnice编辑器"><span>以下场景会将 no_write_to_binlog 设置为 true。</span></p>
<ol class="list-paddingleft-1">
<li><span><span>SHUTDOWN、RESTART 命令。</span></span></li>
<li><span>RESET 系列命令，包括：RESET MASTER, RESET SLAVE, RESET PERSIST。</span></li>
<li><span>显式指定<code><span>NO_WRITE_TO_BINLOG</span></code><span>或<code><span>LOCAL</span></code><span>。部分维护类 SQL 命令（OPTIMIZE, ANALYZE, REPAIR, FLUSH）支持在语句中显式指定不写 binlog，如，</span></span></span></li>
</ol>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVlibSwibjXiaMnylbHVGpQcib8UWIFerYZgIR9sxBIBCgO6hYKkExWrhsjMPIQa1yIOMmrRGFx1dEib6vlCuJygOxAZF/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>OPTIMIZE<span>&nbsp;NO_WRITE_TO_BINLOG<span>&nbsp;TABLE<span>&nbsp;t1;<span><br>ANALYZE<span>&nbsp;LOCAL<span>&nbsp;TABLE<span>&nbsp;t1;<span><br>REPAIR<span>&nbsp;NO_WRITE_TO_BINLOG<span>&nbsp;TABLE<span>&nbsp;t1;<span><br>FLUSH<span>&nbsp;LOCAL<span>&nbsp;PRIVILEGES<span>;<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>需要注意的是，对于<code><span>FLUSH</span></code><span>命令，即使未显式指定<code><span>NO_WRITE_TO_BINLOG</span></code><span>，以下命令默认也不会写入 binlog：NO_WRITE_TO_BINLOG，FLUSH LOGS、FLUSH BINARY LOGS、FLUSH TABLES WITH READ LOCK、FLUSH TABLES tbl_name ... FOR EXPORT。</span></span></span></p>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">总结</span></h1>
<p data-tool="mdnice编辑器"><span>虽然上面列举的场景较多，但实际上并不需要大家刻意去记。</span></p>
<p data-tool="mdnice编辑器"><span>简单来说，</span></p>
<ul class="list-paddingleft-1">
<li>
<p><span>凡是 MySQL 内部自动执行的操作（即非用户手动执行的操作），通常不会写入 binlog。 典型场景包括：实例初始化与升级、<code><span>mysql.slow_log</span></code><span>表的写入、数据字典的维护、<code><span>performance_schema</span></code><span>表数据的更新等。</span></span></span></p>
</li>
<li>
<p><span>对 mysql 库下的表进行 <span>DML 操作，只要不属于上面提到的特殊类别的表，基本都会写入 binlog。</span></span></p>
<p><span>但若执行的是 DDL 操作（如 truncate），基本都会写入 binlog。</span></p>
</li>
<li>
<p><span>对 performance_schema 中的表进行 DML、DDL 操作会提示权限不足，即便是用 root 用户执行。但部分表允许执行 truncate 操作，且 truncate 操作不会写入 binlog。</span></p>
</li>
</ul>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-12-22 15:48">2025-12-22 15:47</span>&nbsp;
<a href="https://www.cnblogs.com/ivictor">iVictor</a>&nbsp;
阅读(<span id="post_view_count">24</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19382809);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19382809', targetLink: 'https://www.cnblogs.com/ivictor/p/19382809', title: 'MySQL 在哪些场景下不会写 binlog' })">举报</a>
</div>
	 ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ 具身智能：零基础入门睿尔曼机械臂（六）——手眼标定代码库详解，从原理到实践 ]]></title>
    <link>https://www.cnblogs.com/ChenAI-TGF/p/19382703</link>
    <guid>07f193168dc99b013739523a18c701fb</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ChenAI-TGF/p/19382703" title="发布于 2025-12-22 15:34">
    <span role="heading" aria-level="2">具身智能：零基础入门睿尔曼机械臂（六）——手眼标定代码库详解，从原理到实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前言">前言</h1>
<p>手眼标定是机器人视觉领域的关键技术，它解决了机械臂与相机之间的坐标转换问题，为精准抓取、视觉伺服等应用奠定基础。上一篇博客中我们讲解了手眼标定的概念以及原理，本文将详细解析睿尔曼官方提供的完整的手眼标定代码库，包括其结构设计、核心功能及使用方法，帮助读者快速掌握手眼标定的实现流程。</p>
<p>@</p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#前言" rel="noopener nofollow">前言</a></li><li><a href="#项目概述" rel="noopener nofollow">项目概述</a></li><li><a href="#项目结构" rel="noopener nofollow">项目结构</a></li><li><a href="#核心原理" rel="noopener nofollow">核心原理</a><ul><li><a href="#1-眼在手上模式eye-in-hand" rel="noopener nofollow">1. 眼在手上模式（Eye-in-Hand）</a></li><li><a href="#2-眼在手外模式eye-to-hand" rel="noopener nofollow">2. 眼在手外模式（Eye-to-Hand）</a></li></ul></li><li><a href="#核心代码解析" rel="noopener nofollow">核心代码解析</a><ul><li><a href="#一核心计算模块深度解析" rel="noopener nofollow">一、核心计算模块深度解析</a><ul><li><a href="#1-眼在手上标定compute_in_handpy" rel="noopener nofollow">1. 眼在手上标定（compute_in_hand.py）</a><ul><li><a href="#11-初始化与配置加载" rel="noopener nofollow">1.1 初始化与配置加载</a></li><li><a href="#12-标定板角点检测与相机外参计算" rel="noopener nofollow">1.2 标定板角点检测与相机外参计算</a></li><li><a href="#13-相机标定与位姿转换" rel="noopener nofollow">1.3 相机标定与位姿转换</a></li><li><a href="#14-手眼标定核心计算" rel="noopener nofollow">1.4 手眼标定核心计算</a></li></ul></li><li><a href="#2-眼在手外标定compute_to_handpy" rel="noopener nofollow">2. 眼在手外标定（compute_to_hand.py）</a><ul><li><a href="#21-核心差异点" rel="noopener nofollow">2.1 核心差异点</a></li><li><a href="#22-标定目标差异" rel="noopener nofollow">2.2 标定目标差异</a></li></ul></li></ul></li><li><a href="#二辅助模块解析" rel="noopener nofollow">二、辅助模块解析</a><ul><li><a href="#1-数据采集模块collect_datapy" rel="noopener nofollow">1. 数据采集模块（collect_data.py）</a></li><li><a href="#2-配置文件configyaml" rel="noopener nofollow">2. 配置文件（config.yaml）</a></li><li><a href="#3-日志模块libslog_settingpy" rel="noopener nofollow">3. 日志模块（libs/log_setting.py）</a></li><li><a href="#4-位姿处理工具save_posespy--save_poses2py" rel="noopener nofollow">4. 位姿处理工具（save_poses.py / save_poses2.py）</a></li></ul></li><li><a href="#三代码串联与整体流程" rel="noopener nofollow">三、代码串联与整体流程</a><ul><li><a href="#1-数据流向图" rel="noopener nofollow">1. 数据流向图</a></li></ul></li></ul></li><li><a href="#总结" rel="noopener nofollow">总结</a></li></ul></div><br>
<img alt="在这里插入图片描述" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3724025/202512/3724025-20251222153302574-1876873088.png" class="lazyload"><p></p>
<h1 id="项目概述">项目概述</h1>
<p>该代码库专注于实现两种常见的手眼标定模式：</p>
<ul>
<li><strong>眼在手上（Eye-in-Hand）</strong>：相机固定在机械臂末端，随机械臂一起运动</li>
<li><strong>眼在手外（Eye-to-Hand）</strong>：相机固定在机械臂外部，位置保持不变</li>
</ul>
<p>通过采集机械臂位姿和标定板图像，计算出相机与机械臂之间的坐标变换矩阵，最终实现目标从相机坐标系到机械臂基坐标系的转换。</p>
<h1 id="项目结构">项目结构</h1>
<pre><code>hand_eye_calibration/
├── README.md               # 项目说明文档
├── collect_data.py         # 数据采集程序
├── compute_in_hand.py      # 眼在手上标定计算
├── compute_to_hand.py      # 眼在手外标定计算
├── config.yaml             # 配置文件
├── requirements.txt        # 依赖包列表
├── save_poses.py           # 位姿数据处理工具
├── save_poses2.py          # 位姿数据处理工具
├── picture/                # 图片资源
└── libs/                   # 辅助工具库
    ├── auxiliary.py        # 辅助函数
    └── log_setting.py      # 日志配置
</code></pre>
<h1 id="核心原理">核心原理</h1>
<p>手眼标定的本质是求解坐标变换矩阵，两种模式分别对应不同的数学模型，上一章已经详细讲过其中的数学原理，这边我们简单复习一下：</p>
<h2 id="1-眼在手上模式eye-in-hand">1. 眼在手上模式（Eye-in-Hand）</h2>
<p>需要求解相机相对于机械臂末端的变换矩阵 $H^{EE}_{CAM}$，核心方程为：<br>
$$A_2^{-1} \cdot A_1 \cdot X = X \cdot B_2 \cdot B_1^{-1}$$<br>
其中：</p>
<ul>
<li>$A$ 表示机械臂末端在基坐标系下的位姿变换</li>
<li>$B$ 表示标定板在相机坐标系下的位姿变换</li>
<li>$X$ 即为待求的相机与末端的变换矩阵</li>
</ul>
<h2 id="2-眼在手外模式eye-to-hand">2. 眼在手外模式（Eye-to-Hand）</h2>
<p>需要求解相机相对于机械臂基坐标系的变换矩阵 $H^{ROB}_{CAM}$，核心方程同样遵循 $AX=XB$ 形式，只是矩阵定义不同。</p>
<h1 id="核心代码解析">核心代码解析</h1>
<h2 id="一核心计算模块深度解析">一、核心计算模块深度解析</h2>
<h3 id="1-眼在手上标定compute_in_handpy">1. 眼在手上标定（compute_in_hand.py）</h3>
<p>该模块是眼在手上模式的核心计算单元，负责将采集到的图像和位姿数据转换为相机与机械臂末端的坐标变换关系。</p>
<h4 id="11-初始化与配置加载">1.1 初始化与配置加载</h4>
<pre><code class="language-python">current_path = os.path.join(os.path.dirname(os.path.abspath(__file__)),"eye_hand_data")
images_path = os.path.join("eye_hand_data",find_latest_data_folder(current_path))
file_path = os.path.join(images_path,"poses.txt")

with open("config.yaml", 'r', encoding='utf-8') as file:
    data = yaml.safe_load(file)
XX = data.get("checkerboard_args").get("XX")  # 标定板长度方向角点数
YY = data.get("checkerboard_args").get("YY")  # 标定板宽度方向角点数
L = data.get("checkerboard_args").get("L")    # 角点间距（米）
</code></pre>
<ul>
<li><strong>路径处理</strong>：通过<code>find_latest_data_folder</code>自动定位最新采集的数据文件夹，确保使用最新标定数据</li>
<li><strong>配置加载</strong>：从<code>config.yaml</code>读取标定板参数，支持不同规格标定板的灵活适配</li>
</ul>
<h4 id="12-标定板角点检测与相机外参计算">1.2 标定板角点检测与相机外参计算</h4>
<pre><code class="language-python"># 标定板3D坐标定义（世界坐标系）
objp = np.zeros((XX * YY, 3), np.float32)
objp[:, :2] = np.mgrid[0:XX, 0:YY].T.reshape(-1, 2)
objp = L * objp  # 转换为实际物理尺寸

# 角点检测
for i in range(1, len(images_num) + 1):
    img = cv2.imread(image_file)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    ret, corners = cv2.findChessboardCorners(gray, (XX, YY), None)
    if ret:
        obj_points.append(objp)
        # 亚像素优化：提高角点检测精度到亚像素级别
        corners2 = cv2.cornerSubPix(gray, corners, (5, 5), (-1, -1), criteria)
        img_points.append(corners2)
</code></pre>
<ul>
<li><strong>世界坐标系定义</strong>：将标定板视为世界坐标系，Z轴为0，X/Y轴由角点网格定义</li>
<li><strong>亚像素优化</strong>：通过<code>cv2.cornerSubPix</code>将角点坐标从像素级优化到亚像素级（精度达0.1像素以下），为后续标定提供更高精度的输入</li>
</ul>
<h4 id="13-相机标定与位姿转换">1.3 相机标定与位姿转换</h4>
<pre><code class="language-python"># 相机标定：获取标定板在相机坐标系下的位姿
ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(
    obj_points, img_points, size, None, None)

# 机械臂位姿处理：将poses.txt转换为齐次变换矩阵
poses_main(file_path)
tool_pose = np.loadtxt("RobotToolPose.csv", delimiter=',')

# 提取旋转矩阵和平移向量
R_tool = []
t_tool = []
for i in range(int(N)):
    R_tool.append(tool_pose[0:3,4*i:4*i+3])  # 旋转矩阵部分
    t_tool.append(tool_pose[0:3,4*i+3])      # 平移向量部分
</code></pre>
<ul>
<li><strong>相机外参计算</strong>：<code>cv2.calibrateCamera</code>返回的<code>rvecs</code>和<code>tvecs</code>分别是标定板在相机坐标系下的旋转向量和平移向量</li>
<li><strong>机械臂位姿转换</strong>：<code>poses_main</code>函数将机械臂末端的位姿（通常是X,Y,Z,_rx,ry,rz）转换为齐次变换矩阵，存储于<code>RobotToolPose.csv</code></li>
</ul>
<h4 id="14-手眼标定核心计算">1.4 手眼标定核心计算</h4>
<pre><code class="language-python"># 使用Tsai算法求解手眼变换
R, t = cv2.calibrateHandEye(R_tool, t_tool, rvecs, tvecs, cv2.CALIB_HAND_EYE_TSAI)
</code></pre>
<ul>
<li><strong>参数解析</strong>：
<ul>
<li><code>R_tool</code>/<code>t_tool</code>：机械臂末端在基坐标系下的旋转矩阵/平移向量序列</li>
<li><code>rvecs</code>/<code>tvecs</code>：标定板在相机坐标系下的旋转向量/平移向量序列</li>
<li><code>cv2.CALIB_HAND_EYE_TSAI</code>：采用Tsai-Lenz算法（计算速度快，精度高）</li>
</ul>
</li>
<li><strong>输出</strong>：<code>R</code>为相机相对于机械臂末端的旋转矩阵，<code>t</code>为对应的平移向量</li>
</ul>
<h3 id="2-眼在手外标定compute_to_handpy">2. 眼在手外标定（compute_to_hand.py）</h3>
<p>该模块与<code>compute_in_hand.py</code>结构高度相似，但存在关键差异：</p>
<h4 id="21-核心差异点">2.1 核心差异点</h4>
<pre><code class="language-python"># 机械臂位姿处理函数不同
from save_poses2 import poses2_main
...
poses2_main(file_path)  # 替代compute_in_hand.py中的poses_main
</code></pre>
<ul>
<li><strong>位姿转换逻辑</strong>：<code>poses2_main</code>与<code>poses_main</code>的区别在于机械臂位姿的变换方向不同：
<ul>
<li>眼在手上：需要机械臂末端相对于基坐标系的变换（$A$矩阵）</li>
<li>眼在手外：需要基坐标系相对于机械臂末端的变换（$A^{-1}$矩阵）</li>
</ul>
</li>
</ul>
<h4 id="22-标定目标差异">2.2 标定目标差异</h4>
<pre><code class="language-python"># 眼在手外模式下，calibrateHandEye输出的是相机相对于基坐标系的变换
R, t = cv2.calibrateHandEye(R_tool, t_tool, rvecs, tvecs, cv2.CALIB_HAND_EYE_TSAI)
</code></pre>
<ul>
<li>眼在手上：$X = H^{EE}_{CAM}$（相机→末端）</li>
<li>眼在手外：$X = H^{ROB}_{CAM}$（相机→基坐标系）</li>
</ul>
<h2 id="二辅助模块解析">二、辅助模块解析</h2>
<h3 id="1-数据采集模块collect_datapy">1. 数据采集模块（collect_data.py）</h3>
<p>该模块实现图像与位姿的同步采集，确保每一组数据的时间一致性：</p>
<pre><code class="language-python"># 机械臂位姿获取
socket_command = '{"command": "get_current_arm_state"}'
state, pose = send_cmd(client, socket_command)

# 数据保存
with open(filename, 'a+') as f:
    pose_ = [str(i) for i in pose]
    new_line = f'{",".join(pose_)}\n'
    f.write(new_line)
cv2.imwrite(image_path, cv_img)
</code></pre>
<ul>
<li><strong>同步机制</strong>：通过按键触发（'s'键），确保同一时刻采集的图像和位姿被关联存储</li>
<li><strong>数据格式</strong>：
<ul>
<li>位姿：<code>poses.txt</code>中每行存储一组机械臂位姿（X,Y,Z,rx,ry,rz）</li>
<li>图像：按序号命名（1.jpg, 2.jpg...），与位姿文件行号一一对应</li>
</ul>
</li>
</ul>
<h3 id="2-配置文件configyaml">2. 配置文件（config.yaml）</h3>
<pre><code class="language-yaml">checkerboard_args:
  XX: 9        # 长度方向角点数
  YY: 6        # 宽度方向角点数
  L: 0.02      # 角点间距（米）
</code></pre>
<ul>
<li><strong>标定板参数</strong>：需根据实际使用的标定板修改，直接影响世界坐标系到图像坐标系的转换精度</li>
<li><strong>扩展性</strong>：可通过添加其他参数（如相机内参路径、日志级别等）增强配置灵活性</li>
</ul>
<h3 id="3-日志模块libslog_settingpy">3. 日志模块（libs/log_setting.py）</h3>
<pre><code class="language-python">class CommonLog(object):
    def __console(self, level, message):
        # 文件日志（按天轮转）
        fh = TimedRotatingFileHandler(
            self.logname, when='MIDNIGHT', interval=1, encoding='utf-8')
        # 控制台日志
        ch = logging.StreamHandler()
        
        self.logger.addHandler(fh)
        self.logger.addHandler(ch)
        # 记录日志后移除处理器，避免重复输出
        self.logger.removeHandler(ch)
        self.logger.removeHandler(fh)
</code></pre>
<ul>
<li><strong>双重输出</strong>：同时向控制台和文件输出日志，方便调试和记录</li>
<li><strong>日志轮转</strong>：按天分割日志文件，避免单文件过大，便于追溯历史标定过程</li>
</ul>
<h3 id="4-位姿处理工具save_posespy--save_poses2py">4. 位姿处理工具（save_poses.py / save_poses2.py）</h3>
<p>虽然未提供完整代码，但根据上下文可推断其功能：</p>
<ul>
<li><strong>功能</strong>：将机械臂位姿（欧拉角）转换为齐次变换矩阵</li>
<li><strong>核心公式</strong>：<pre><code class="language-python"># 欧拉角转旋转矩阵（以ZYX顺序为例）
R = Rz(rz) * Ry(ry) * Rx(rx)
# 构造齐次矩阵
H = [[R[0][0], R[0][1], R[0][2], x],
     [R[1][0], R[1][1], R[1][2], y],
     [R[2][0], R[2][1], R[2][2], z],
     [0,       0,       0,       1]]
</code></pre>
</li>
<li><strong>差异点</strong>：<code>save_poses2.py</code>会计算变换矩阵的逆，以适应眼在手外的数学模型</li>
</ul>
<h2 id="三代码串联与整体流程">三、代码串联与整体流程</h2>
<h3 id="1-数据流向图">1. 数据流向图</h3>
<pre><code>采集阶段：
机械臂 → [get_current_arm_state] → 位姿数据 → 写入poses.txt
   ↑
   同步触发（'s'键）
   ↓
相机 → [RealSense SDK] → 图像帧 → 保存为.jpg文件

计算阶段：
poses.txt → [save_poses.py/2] → 机械臂变换矩阵(R_tool, t_tool)
   ↓
.jpg文件 → [角点检测] → 图像点集 → [calibrateCamera] → 标定板位姿(rvecs, tvecs)
   ↓
[calibrateHandEye] → 手眼变换矩阵(R, t) → 输出旋转矩阵/平移向量/四元数
</code></pre>
<h1 id="总结">总结</h1>
<p>本代码库提供了一套完整的手眼标定解决方案，通过模块化设计实现了数据采集、标定计算等核心功能。无论是眼在手上还是眼在手外模式，都能通过简单的操作流程完成标定。实际应用中，需注意机械臂运动姿态的多样性和标定板的稳定性，以获得更高的标定精度。</p>
<p>通过本文的解析，相信读者已经对该代码库有了全面的了解，可以根据实际需求进行二次开发或直接应用于机器人视觉项目中。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-12-22 15:34">2025-12-22 15:34</span>&nbsp;
<a href="https://www.cnblogs.com/ChenAI-TGF">TTGF</a>&nbsp;
阅读(<span id="post_view_count">32</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19382703);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19382703', targetLink: 'https://www.cnblogs.com/ChenAI-TGF/p/19382703', title: '具身智能：零基础入门睿尔曼机械臂（六）——手眼标定代码库详解，从原理到实践' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ 在Odoo18中实现多选下拉框搜索功能 ]]></title>
    <link>https://www.cnblogs.com/lifuquan/p/19382615</link>
    <guid>a998f258bcb168de64661dc3aadcb055</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lifuquan/p/19382615" title="发布于 2025-12-22 15:22">
    <span role="heading" aria-level="2">在Odoo18中实现多选下拉框搜索功能</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="背景需求">背景需求</h2>
<p>最近在开发一个Odoo项目时，客户提出了一个特定的搜索需求：希望在列表页面中展示多个多选下拉框作为过滤条件。用户选中任意下拉选项时，列表需要实时查询并显示对应的结果。</p>
<p>这种设计相较于Odoo原生搜索更为直观，特别是当用户需要同时基于多个维度筛选数据时，操作更加便捷。<br>
<img src="https://img2024.cnblogs.com/blog/597896/202512/597896-20251222144812190-2038429530.png" alt="image" loading="lazy"></p>
<h2 id="odoo原生搜索的局限性">Odoo原生搜索的局限性</h2>
<p>Odoo作为一款国际化的开源ERP系统，其搜索功能设计理念与国内用户的使用习惯存在一定差异：</p>
<ul>
<li>搜索模式单一：默认采用"搜索框+预设过滤器"的模式</li>
<li>多条件过滤不够直观：需要点击过滤器图标，在弹出窗口中配置多个条件</li>
<li>用户体验差异：国外用户习惯文本搜索+条件组合，国内用户更习惯可视化的多选过滤</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/597896/202512/597896-20251222145301116-1805738145.png" alt="image" loading="lazy"></p>
<h2 id="解决方案自定义控件开发">解决方案：自定义控件开发</h2>
<p>面对这种需求差异，我们决定采用Odoo的自定义开发能力。Odoo提供了灵活的扩展机制，特别是基于QWeb模板引擎，我们可以通过以下方式实现自定义搜索控件：</p>
<ol>
<li>自定义多选下拉框组件</li>
<li>集成到搜索面板</li>
<li>重写列表视图控制器</li>
<li>动态构建搜索条件</li>
</ol>
<h2 id="完整方案实现">完整方案实现</h2>
<h5 id="1-多选下拉框组件-xml模板">1. 多选下拉框组件 (XML模板)</h5>
<p>首先需要在XML文件中定义自定义下拉框控件视图(multi_select_widget.xml)：</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;templates xml:space="preserve"&gt;
    &lt;t t-name="multi_select" owl="1"&gt;
        &lt;div class="multiselect-container" t-ref="multi_select_dropdown"&gt;
            &lt;div class="form-control" t-on-click="toggleDropdown"&gt;
                &lt;span t-if="state.selected.size === 0"&gt;
                    &lt;t t-esc="props.placeholder || 'Select options'"/&gt;
                &lt;/span&gt;
                &lt;div t-if="state.selected.size === 1" class="selected-options" &gt;
                    &lt;span class="badge bg-primary me-1" 
                              t-esc="[...state.selected][0]"/&gt;
                &lt;/div&gt;
                &lt;div t-if="state.selected.size &gt; 1" class="selected-options" &gt;
                    &lt;span class="badge bg-primary me-1"&gt;已选择&lt;t t-esc="state.selected.size"&gt;&lt;/t&gt;个&lt;t t-esc="props.fieldName"/&gt;&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div t-if="state.isOpen" class="dropdown-menu show"&gt;
                &lt;t t-foreach="props.options" t-as="option" t-key="option"&gt;
                    &lt;a href="#" class="dropdown-item" 
                       t-att-class="{'active': state.selected.has(option)}"
                       t-on-click="(ev) =&gt; this.selectOption(option, ev)"&gt;
                        &lt;t t-esc="option"/&gt;
                    &lt;/a&gt;
                &lt;/t&gt;
            &lt;/div&gt;
            &lt;style&gt;
                .multiselect-container{
                    margin: 3px;
                    width: 200px;
                }
            &lt;/style&gt;
        &lt;/div&gt;
    &lt;/t&gt;
&lt;/templates&gt;
</code></pre>
<h3 id="2-多选下拉框组件逻辑-javascript">2. 多选下拉框组件逻辑 (JavaScript)</h3>
<p>业务逻辑我们用js来实现(multi_select_widget.js)</p>
<pre><code>import { Component, useState, useRef, onMounted, onWillUnmount } from "@odoo/owl";

export class MultiSelectField extends Component {
    static template = "multi_select";
    static props = {
        options: Array,
        placeholder: { type: String, optional: true },
        fieldName: String,
        onChange: Function,
    };

    setup() {
        this.dropdownRef = useRef("multi_select_dropdown");
        this.state = useState({
            isOpen: false,
            selected: new Set(),
        });

        this.clickOutsideHandler = null;
        this.keydownHandler = null;

        onMounted(() =&gt; {
            this.setupEventListeners();
        });

        onWillUnmount(() =&gt; {
            this.cleanupEventListeners();
        });
    }

    toggleDropdown() {
        this.state.isOpen = !this.state.isOpen;
    }

    selectOption = (option, ev) =&gt; {
        if (this.state.selected.has(option)) {
            this.state.selected.delete(option);
        } else {
            this.state.selected.add(option);
        }
        this.props.onChange(this.props.fieldName, [...this.state.selected]);
    }

    setupEventListeners() {
        this.clickOutsideHandler = (event) =&gt; {
            if (!this.dropdownRef || !this.dropdownRef.el) return;

            if (!this.dropdownRef.el.contains(event.target)) {
                this.state.isOpen = false;
            }
        }

        this.keydownHandler = (event) =&gt; {
            if (event.key === 'Escape' &amp;&amp; this.state.isOpen) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
                this.state.isOpen = false;
            }
        }

        document.addEventListener('mousedown', this.clickOutsideHandler, true);
        document.addEventListener('touchstart', this.clickOutsideHandler, true);
        document.addEventListener('keydown', this.keydownHandler, true);
    }

    cleanupEventListeners() {
        if (this.clickOutsideHandler) {
            document.removeEventListener('mousedown', this.clickOutsideHandler, true);
            document.removeEventListener('touchstart', this.clickOutsideHandler, true);
        }

        if (this.keydownHandler) {
            document.removeEventListener('keydown', this.keydownHandler, true);
        }

        this.clickOutsideHandler = null;
        this.keydownHandler = null;
    }
}
</code></pre>
<h3 id="3自定义搜索面板-xml模板">3.自定义搜索面板 (XML模板)</h3>
<p>同样定义一个xml(search_widget.xml)</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;templates xml:space="preserve"&gt;
    &lt;t t-name="custom_search_panel" owl="1"&gt;
        &lt;div class="custom-search-panel" t-att-data-loading="state.loading"&gt;
            &lt;!-- 加载状态 --&gt;
            &lt;t t-if="state.loading"&gt;
                &lt;div class="loading-state text-center p-3"&gt;
                    &lt;i class="fa fa-spinner fa-spin me-2"&gt;&lt;/i&gt;
                    &lt;span&gt;正在加载数据...&lt;/span&gt;
                &lt;/div&gt;
            &lt;/t&gt;

            &lt;!-- 错误状态 --&gt;
            &lt;t t-if="state.error"&gt;
                &lt;div class="error-state alert alert-warning m-3"&gt;
                    &lt;i class="fa fa-exclamation-triangle me-2"&gt;&lt;/i&gt;
                    &lt;span t-esc="state.error"&gt;&lt;/span&gt;
                &lt;/div&gt;
            &lt;/t&gt;

            &lt;!-- 正常状态 --&gt;
            &lt;t t-if="!state.loading and !state.error"&gt;
                &lt;div class="search-filters-container"&gt;
                    &lt;!-- 多选下拉框组件 --&gt;
                    &lt;MultiSelectField 
                        fieldName="field_a" 
                        options="state.dropdownData.field_a" 
                        placeholder="'字段A筛选'"
                        onChange="(field, values) =&gt; handleSelection(field, values)"
                    /&gt;
                    
                    &lt;MultiSelectField 
                        fieldName="field_b" 
                        options="state.dropdownData.field_b" 
                        placeholder="'字段B筛选'"
                        onChange="(field, values) =&gt; handleSelection(field, values)"
                    /&gt;
                    
                    &lt;MultiSelectField 
                        fieldName="field_c" 
                        options="state.dropdownData.field_c" 
                        placeholder="'字段C筛选'"
                        onChange="(field, values) =&gt; handleSelection(field, values)"
                    /&gt;
                &lt;/div&gt;
            &lt;/t&gt;
            
            &lt;style&gt;
                .custom-search-panel {
                    padding: 16px;
                    background: #f8f9fa;
                    border-bottom: 1px solid #dee2e6;
                }
                
                .search-filters-container {
                    display: flex;
                    flex-wrap: wrap;
                    align-items: center;
                    gap: 12px;
                }
                
                .loading-state {
                    color: #6c757d;
                }
                
                .error-state {
                    max-width: 600px;
                    margin: 0 auto;
                }
            &lt;/style&gt;
        &lt;/div&gt;
    &lt;/t&gt;
&lt;/templates&gt;
</code></pre>
<h3 id="4搜索面板业务逻辑-javascript">4.搜索面板业务逻辑 (JavaScript)</h3>
<p>search_widget.js</p>
<pre><code>import { Component, useState, onWillStart } from "@odoo/owl";
import { registry } from "@web/core/registry";
import { useService } from "@web/core/utils/hooks";
import { MultiSelectField } from "./multi_select_widget";

export class CustomSearchPanel extends Component {
    static template = "custom_search_panel";
    static components = { MultiSelectField };

    setup() {
        // 获取服务
        this.ormService = useService("orm");
        
        // 初始化响应式状态
        this.state = useState({
            dropdownData: {
                field_a: [],
                field_b: [],
                field_c: [],
            },
            selectedValues: {
                field_a: [],
                field_b: [],
                field_c: [],
            },
            loading: false,
            error: null,
        });

        // 组件挂载前加载数据
        onWillStart(async () =&gt; {
            await this.loadDropdownData();
        });
    }

    // 加载下拉框数据
    loadDropdownData = async () =&gt; {
        this.state.loading = true;
        this.state.error = null;
        
        try {
            // 调用后端方法获取下拉框数据
            const dropdownData = await this.ormService.call(
                "your.model.name",  // 替换为实际模型名
                "get_filter_dropdown_data",  // 后端方法名
                [],
                {}
            );
            
            this.state.dropdownData = dropdownData;
        } catch (error) {
            console.error("加载下拉框数据失败:", error);
            this.state.error = "加载筛选数据失败，请稍后重试";
        } finally {
            this.state.loading = false;
        }
    }

    // 处理选择变化
    handleSelection = async (fieldName, selectedValues) =&gt; {
        // 更新选中值
        this.state.selectedValues[fieldName] = selectedValues;
        
        // 生成搜索条件
        const domain = this.generateSearchDomain();
        
        // 触发搜索更新
        this.triggerSearchUpdate(domain);
    }

    // 生成搜索条件
    generateSearchDomain() {
        const domain = [];
        
        Object.entries(this.state.selectedValues).forEach(([field, values]) =&gt; {
            if (values &amp;&amp; values.length &gt; 0) {
                // 使用 'in' 操作符支持多选
                domain.push([field, 'in', values]);
            }
        });
        
        return domain;
    }

    // 触发搜索更新
    triggerSearchUpdate(domain) {
        // 更新搜索模型
        this.env.searchModel.updateDomain(domain);
        
        // 发送自定义事件通知列表刷新
        this.env.bus.trigger('custom_search:updated', { 
            domain,
            timestamp: Date.now()
        });
    }
}

// 注册组件
registry.category("view_components").add("custom_search_panel", CustomSearchPanel);
</code></pre>
<h3 id="5自定义列表控制器-javascript">5.自定义列表控制器 (JavaScript)</h3>
<pre><code>import { registry } from "@web/core/registry";
import { listView } from "@web/views/list/list_view";
import { ListController } from "@web/views/list/list_controller";
import { CustomSearchPanel } from "./search_widget";
import { useBus } from "@web/core/utils/hooks";

// 扩展原生列表控制器
export class CustomListController extends ListController {
    static components = {
        ...ListController.components,
        SearchPanel: CustomSearchPanel,  // 替换搜索组件
    };
    
    static template = "web.ListView";

    setup() {
        super.setup();
        
        // 监听自定义搜索事件
        useBus(this.env.bus, "custom_search:updated", (ev) =&gt; {
            this.handleCustomSearch(ev.detail.domain);
        });
    }

    // 处理自定义搜索
    async handleCustomSearch(domain) {
        try {
            // 显示加载状态
            this.model.isLoading = true;
            this.render();
            
            // 加载数据
            await this.model.load({ domain });
            
            // 更新分页信息
            if (this.model.data) {
                this.model.pager.limit = this.model.data.length;
            }
        } catch (error) {
            console.error("搜索数据失败:", error);
        } finally {
            this.model.isLoading = false;
            this.render();
        }
    }
}

// 注册自定义列表视图
registry.category("views").add("custom_multi_select_list", {
    ...listView,
    Controller: CustomListController,
    display: {
        controlPanel: {
        'bottom-left': false,
        'bottom-right': false,
        },
    },
});
</code></pre>
<h3 id="6后端数据接口-python">6.后端数据接口 (Python)</h3>
<pre><code># models/your_model.py
from odoo import models, fields, api

class YourModel(models.Model):
    _name = 'your.model.name'
    _description = '示例模型'
    
    # 定义字段
    field_a = fields.Selection([
        ('option1', '选项1'),
        ('option2', '选项2'),
        ('option3', '选项3'),
    ], string='字段A')
    
    field_b = fields.Char(string='字段B')
    field_c = fields.Many2one('related.model', string='字段C')
    
    # 获取下拉框数据的方法
    @api.model
    def get_filter_dropdown_data(self):
        """返回所有下拉框的选项数据"""
        return {
            'field_a': self._get_field_a_options(),
            'field_b': self._get_field_b_options(),
            'field_c': self._get_field_c_options(),
        }
    
    def _get_field_a_options(self):
        """获取字段A的选项"""
        return [
            display_value 
            for value, display_value in self._fields['field_a'].selection
        ]
    
    def _get_field_b_options(self):
        """获取字段B的去重值"""
        records = self.search_read(
            [('field_b', '!=', False)],
            ['field_b'],
            limit=100
        )
        return sorted(list(set([
            record['field_b'] 
            for record in records 
            if record['field_b']
        ])))
    
    def _get_field_c_options(self):
        """获取字段C的关联选项"""
        related_records = self.env['related.model'].search_read(
            [],
            ['name'],
            limit=50
        )
        return [record['name'] for record in related_records]
</code></pre>
<h3 id="7-视图配置-xml">7. 视图配置 (XML)</h3>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;odoo&gt;
  
    &lt;!-- 自定义列表视图 --&gt;
    &lt;record id="view_custom_list" model="ir.ui.view"&gt;
        &lt;field name="name"&gt;your.model.custom.list&lt;/field&gt;
        &lt;field name="model"&gt;your.model.name&lt;/field&gt;
        &lt;field name="arch" type="xml"&gt;
            &lt;list js_class="custom_multi_select_list"&gt;
                &lt;field name="name" string="名称"/&gt;
                &lt;field name="field_a" string="字段A"/&gt;
                &lt;field name="field_b" string="字段B"/&gt;
                &lt;field name="field_c" string="字段C"/&gt;
                &lt;!-- 其他字段 --&gt;
            &lt;/list&gt;
        &lt;/field&gt;
    &lt;/record&gt;
&lt;/odoo&gt;
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-12-22 15:23">2025-12-22 15:22</span>&nbsp;
<a href="https://www.cnblogs.com/lifuquan">李怀瑾</a>&nbsp;
阅读(<span id="post_view_count">32</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19382615);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19382615', targetLink: 'https://www.cnblogs.com/lifuquan/p/19382615', title: '在Odoo18中实现多选下拉框搜索功能' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ 流式数据集：效率提升 100 倍！ ]]></title>
    <link>https://www.cnblogs.com/huggingface/p/19382568</link>
    <guid>1315e90e0d5d815aa6cac9012f6d16aa</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huggingface/p/19382568" title="发布于 2025-12-22 15:17">
    <span role="heading" aria-level="2">流式数据集：效率提升 100 倍！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="快速了解tldr">快速了解（TLDR）</h2>
<blockquote>
<p>现在只需一行代码，就能通过 <code>load_dataset('dataset', streaming=True)</code> 以流式方式加载数据集，无需下载！</p>
<p>无需复杂配置、不占磁盘空间、不再担心 “磁盘已满” 或 429 请求过多错误，立即开始训练 TB 级数据集！<br>
性能非常强劲：在 64×H100、256 个并发 worker 环境下，流式加载速度甚至超过本地 SSD！<br>
我们优化后的流式系统：请求数减少 100 倍 → 数据解析速度提升 10 倍 → 样本处理速度翻倍 → 即使在 256 个并发 worker 下也 0 崩溃。</p>
</blockquote>
<p><img alt="数据流式加载可视化" loading="lazy" data-src="https://img-s2.andfun.cn/devrel/posts/2025/12/2800184c9855d.gif" class="lazyload"></p>
<p>在机器学习中，特别是在处理 TB 级别的数据时，数据加载一直是个大难题。我们自己在训练 <a href="https://huggingface.co/blog/smollm3" target="_blank" rel="noopener nofollow">SmolLM3</a> 时也深有体会，有段时间每次训练前都得等上 3 小时下载数据。</p>
<p>虽然 <code>datasets</code> 库早就支持流式加载，但在大规模训练中依然面临瓶颈。今天，这一切都变了 🔥。我们花了几个月优化后端，全面提升流式数据集的速度与效率。</p>
<p>那我们到底做了哪些优化？⤵️</p>
<h2 id="一样简单的-api更强大的性能">一样简单的 API，更强大的性能</h2>
<p>首先最重要的一点：<strong>改进后的接口依然兼容原来的用法</strong>。你只需要加上 <code>streaming=True</code>，就能流式加载 Hugging Face 上的任意数据集，依旧简单直接。🚀</p>
<pre><code class="language-python">from datasets import load_dataset

# Stream a dataset instead of downloading it
dataset = load_dataset("HuggingFaceM4/FineVisionMax", split="train", streaming=True)
# Get the first example
print(next(iter(dataset)))
</code></pre>
<p>全球成千上万的 AI 开发者每天都在使用 <code>datasets</code>，现在他们无需改动任何代码，就能直接享受到更高的性能。</p>
<h2 id="问题挑战大规模流式加载">问题挑战：大规模流式加载</h2>
<p>流式加载一直是快速了解数据集的好方法，但在训练模型时，大多数人仍然选择将数据预先下载到本地，或使用 S3 等云存储——我们在训练 <a href="https://huggingface.co/blog/smolvlm2" target="_blank" rel="noopener nofollow">SmolVLM</a> 时也是这么做的。</p>
<p>我们希望改变这种情况，于是在开发 <a href="https://github.com/huggingface/nanoVLM" target="_blank" rel="noopener nofollow">nanoVLM</a> 时，尝试直接从 Hugging Face Hub 进行流式读取。</p>
<p>但很快就遇到一个严重问题：<strong>一次测试运行在不到一分钟的时间内发出了超过 10 万个请求，结果我们的 IP 被 Hub 屏蔽了！</strong>😅</p>
<p>问题的根源在于：<strong>每个 <code>DataLoader</code> 的 worker 都在独立初始化数据集</strong>，这导致大量冗余请求，形成了“请求风暴”，其中大部分其实是没必要的。</p>
<p>于是我们对启动逻辑进行了深度优化，<strong>最终将启动请求量减少了 100 倍</strong>。总体性能提升如下：</p>
<ul>
<li><strong>数据文件解析速度：提升 10 倍</strong></li>
<li><strong>启动请求效率：提高最多 100 倍</strong></li>
<li><strong>流式速度：提升最多 2 倍</strong></li>
<li><strong>在途请求效率：提升最多 2 倍</strong></li>
</ul>
<h2 id="技术揭秘我们具体改了什么">技术揭秘：我们具体改了什么？</h2>
<p>我们主要优化了两个阶段：<strong>启动阶段</strong> 和 <strong>流式加载阶段</strong>。</p>
<h3 id="1-启动优化-️">1. 启动优化 ⚡️</h3>
<p>初始的数据文件解析阶段会触发大量请求。我们进行了以下两项关键优化：</p>
<ul>
<li>
<p><strong>持久化数据文件缓存</strong>：现在所有 <code>DataLoader</code> worker 会共享数据文件列表缓存。第一个 worker 从 Hub 获取文件列表，其余 worker 直接从本地缓存中读取，从而<strong>几乎完全消除启动阶段的请求</strong>，大幅缩短加载时间，彻底告别“请求风暴”。</p>
</li>
<li>
<p><strong>优化文件解析逻辑</strong>：我们精简了初始 worker 向 Hub 请求文件列表的 API 调用数量，将多个请求进行打包处理，进一步<strong>降低启动延迟</strong>。</p>
</li>
</ul>
<h3 id="2-流式加载优化-️">2. 流式加载优化 🏎️</h3>
<p>为了提升训练过程中的流式吞吐量，我们新增了两个关键功能：</p>
<ul>
<li>
<p><strong>Parquet 数据预取（Prefetching）</strong>：我们为 Parquet 格式的数据集启用了预取功能。这意味着，在模型处理当前数据块的同时，<code>datasets</code> 库会在后台<strong>提前加载下一块数据</strong>。这样可以让整个数据管道始终保持“满负荷”，确保 GPU 不会因等待数据而处于空闲状态，大大提升训练效率。</p>
</li>
<li>
<p><strong>可配置缓冲机制（Buffering）</strong>：针对高级用户，我们开放了缓冲区的配置参数，支持自定义设置<strong>预取数量和数据块大小</strong>，方便根据自身硬件和网络情况进行 I/O 优化。</p>
</li>
</ul>
<p>以下是如何将默认流式请求大小从 32MiB 提升到 128MiB，并启用预取的示例代码：</p>
<pre><code class="language-python">import pyarrow
import pyarrow.dataset

fragment_scan_options = pyarrow.dataset.ParquetFragmentScanOptions(
    cache_options=pyarrow.CacheOptions(
        prefetch_limit=1,
        range_size_limit=128 &lt;&lt; 20
    ),
)
ds = load_dataset(parquet_dataset_id, streaming=True, fragment_scan_options=fragment_scan_options)
</code></pre>
<p>通过这些优化，你的数据加载速度可以提升一倍，训练效率更高！</p>
<h2 id="为什么比-s3-还快背后是-xet-技术">为什么比 S3 还快？背后是 Xet 技术</h2>
<p>Hugging Face 使用了 <strong>Xet 存储系统</strong>：这是一种去重式存储方案，上传和下载速度极快。与传统远程存储不同，Xet 会跳过重复数据，只传输独特内容。</p>
<p>比如，在 Hugging Face 上传大型数据集时，Xet 的去重机制大幅减少了数据传输量，上传更快；数据一上传完，就可以立即开始流式读取。</p>
<p>对于 Parquet 文件，Xet 利用 <a href="https://huggingface.co/blog/parquet-cdc" target="_blank" rel="noopener nofollow">Parquet 内容定义切块（CDC）</a> 来实现去重，进一步加快传输速度。</p>
<p>此外，我们还推出了 <code>pyspark_huggingface</code> 包，支持 Spark 直接读写 HF 数据集，内置对 Parquet CDC 和 Xet 的支持，大幅加快大数据处理。</p>
<h2 id="想自定义流式管道可以">想自定义流式管道？可以！</h2>
<p>有些数据格式 <code>datasets</code> 库还不支持，或者你希望获得更高的控制权，我们也提供了强大的自定义流式能力。</p>
<p><code>huggingface_hub</code> 库中的 <a href="https://huggingface.co/docs/huggingface_hub/guides/hf_file_system" target="_blank" rel="noopener nofollow">HfFileSystem</a> 可高效读取远程数据集文件：</p>
<pre><code class="language-python">from huggingface_hub import HfFileSystem

path = f"hf://datasets/{dataset_id}/{path_in_repo}"
with HfFileSystem().open(path) as f:
    # loop with .read() or .readline() to stream data
    # or do random access with .seek()
</code></pre>
<p>将 <code>HfFileSystem</code> 传入 PyTorch 的 <code>DataLoader</code> 时，会<strong>复用 <code>.ls()</code> 和 <code>.glob()</code> 的缓存结果</strong>，从而<strong>避免在列举数据文件时产生额外的网络请求</strong>，进一步提升流式加载的效率和稳定性。</p>
<h2 id="极限测试我们把它用在-nanovlm-上了">极限测试：我们把它用在 nanoVLM 上了！</h2>
<p>目前我们正在使用这些流式优化功能训练下一代 SmolVLM 模型。得益于新改进，流式加载比我们集群上的多层硬盘系统还要快，<strong>几乎等同于从本地 SSD 读取数据的速度</strong>！</p>
<p>过去，为了避免慢速网络，我们还要把数据拷贝到本地 SSD——整个过程花费 3 小时。而现在，直接流式加载，训练马上开始！</p>
<p>更多细节请看：<a href="https://github.com/huggingface/nanoVLM" target="_blank" rel="noopener nofollow">nanoVLM GitHub</a></p>
<h2 id="快速上手立见成效">快速上手，立见成效</h2>
<p>这些强大的新功能已经集成到 <code>datasets</code> 和 <code>huggingface_hub</code> 库中。想要体验全新的流式加载性能，只需升级你的库版本，并查阅<a href="https://huggingface.co/docs/datasets/stream" target="_blank" rel="noopener nofollow">官方文档</a>即可开始使用：</p>
<pre><code class="language-bash">pip install --upgrade datasets huggingface_hub
</code></pre>
<p>为庆祝这一更新，我们已将 FineVision 所有数据源合并并预先打乱成一个统一数据集：<a href="https://huggingface.co/datasets/HuggingFaceM4/FineVisionMax" target="_blank" rel="noopener nofollow">FineVisionMax</a>。你可以直接用它来训练 VLM 模型，无需手动处理多个数据集！</p>
<pre><code class="language-python">from datasets import load_dataset

# Stream a dataset instead of downloading it
dataset = load_dataset("HuggingFaceM4/FineVisionMax", split="train", streaming=True)
# Get the first example
print(next(iter(dataset)))
</code></pre>
<p>想了解我们是如何大规模运行的？欢迎查看：<a href="https://github.com/huggingface/nanoVLM" target="_blank" rel="noopener nofollow">nanoVLM 项目</a></p>
<p>祝你流式加载愉快！🤗</p>
<blockquote>
<p>英文原文: <a href="https://huggingface.co/blog/streaming-datasets" target="_blank" rel="noopener nofollow">https://huggingface.co/blog/streaming-datasets</a></p>
<p>原文作者: Andres Marafioti, Quentin Lhoest, ben burtenshaw, Pedro Cuenca, merve</p>
<p>译者: Luke,  Hugging Face Fellow</p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-12-22 15:18">2025-12-22 15:17</span>&nbsp;
<a href="https://www.cnblogs.com/huggingface">HuggingFace</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19382568);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19382568', targetLink: 'https://www.cnblogs.com/huggingface/p/19382568', title: '流式数据集：效率提升 100 倍！' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ 从 MCP 到 Agent Skills，AI Ready 的 .NET 10 正当时 ]]></title>
    <link>https://www.cnblogs.com/sheng-jie/p/19381647</link>
    <guid>a5ed226215532db4d76e49fdf856585d</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sheng-jie/p/19381647" title="发布于 2025-12-22 11:58">
    <span role="heading" aria-level="2">从 MCP 到 Agent Skills，AI Ready 的 .NET 10 正当时</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="使用-net-file-based-apps-编写高效-agent-skills-脚本指南">使用 .NET File-Based Apps 编写高效 Agent Skills 脚本指南</h1>
<h2 id="前言">前言</h2>
<p>AI 工具生态正在经历一场深刻的变革。从 Anthropic 推出的 <strong>Model Context Protocol (MCP)</strong> 到最新发布的 <strong>Agent Skills</strong>，我们见证了 AI 能力扩展方式的演进：MCP 为 AI 提供了访问外部数据和工具的标准化接口，而 Agent Skills 则更进一步，专注于将人类的专业知识和工作流程封装为 AI 可理解、可执行的格式。</p>
<p><strong>Agent Skills</strong> (<a href="https://agentskills.io" title="https://agentskills.io" target="_blank" rel="noopener nofollow">https://agentskills.io</a>) 中可以包含可执行脚本（位于 <code>scripts/</code> 目录），官方规范支持 Python、Bash、JavaScript 等语言。而 <strong>.NET 10 引入的 File-Based Apps</strong> 特性为这些脚本的编写提供了一个强大的新选择：单个 <code>.cs</code> 文件即可作为完整应用运行，内联依赖声明，支持跨平台部署和 Native AOT 编译。</p>
<p>本文将带你了解 Agent Skills 的规范，以及如何使用 .NET File-Based Apps 编写高效、可靠的 Skill 脚本。你会发现，.NET 为 Agent Skills 的脚本开发提供了类型安全、高性能和优秀跨平台支持的独特优势。</p>
<h2 id="一什么是-agent-skills">一、什么是 Agent Skills？</h2>
<p><img src="https://img2024.cnblogs.com/blog/577140/202512/577140-20251222115747883-716068741.png" alt="" loading="lazy"></p>
<h3 id="11-核心概念">1.1 核心概念</h3>
<p>Agent Skills 是一种轻量级、开放的格式，用于扩展 AI Agent 的能力和专业知识。本质上，<strong>一个 Skill 就是一个包含 <code>SKILL.md</code> 文件的文件夹</strong>。</p>
<p>该文件包含：</p>
<ul>
<li><strong>元数据</strong>：<code>name</code> 和 <code>description</code>（最少必需）</li>
<li><strong>指令</strong>：告诉 Agent 如何执行特定任务的 Markdown 文档</li>
<li><strong>可选资源</strong>：脚本、模板、参考文档等</li>
</ul>
<p>Skills 的核心价值在于：</p>
<ul>
<li><strong>专业知识封装</strong>：将特定领域的程序化知识（procedural knowledge）和公司/团队/用户特定的上下文打包</li>
<li><strong>按需加载</strong>：Agent 启动时只加载 Skill 的 <code>name</code> 和 <code>description</code>，任务匹配时才加载完整指令</li>
<li><strong>可执行能力</strong>：可以包含脚本、工具，扩展 Agent 的实际操作能力</li>
<li><strong>版本化管理</strong>：Skills 就是文件，易于编辑、版本控制和分享</li>
</ul>
<h3 id="12-agent-skills-能做什么">1.2 Agent Skills 能做什么？</h3>
<p>根据官方文档，Agent Skills 的主要应用场景包括：</p>
<h4 id="领域专长domain-expertise">领域专长（Domain Expertise）</h4>
<p>将专业知识打包为可复用的指令：</p>
<ul>
<li><strong>法律审查流程</strong>：标准化的合同审查检查清单和审批流程</li>
<li><strong>数据分析管道</strong>：统一的数据清洗、转换、可视化工作流</li>
<li><strong>代码审查规范</strong>：团队的编码标准、安全检查、性能优化指南</li>
<li><strong>医疗诊断协议</strong>：基于症状的诊断路径和治疗建议流程</li>
</ul>
<h4 id="新能力new-capabilities">新能力（New Capabilities）</h4>
<p>赋予 Agent 原本不具备的操作能力：</p>
<ul>
<li><strong>创建演示文稿</strong>：根据内容自动生成 PPT/Keynote</li>
<li><strong>构建 MCP 服务器</strong>：生成 Model Context Protocol 服务器代码</li>
<li><strong>分析数据集</strong>：执行统计分析、生成可视化图表</li>
<li><strong>处理 PDF 文档</strong>：拆分、合并、提取文本、填写表单</li>
</ul>
<h4 id="可重复工作流repeatable-workflows">可重复工作流（Repeatable Workflows）</h4>
<p>将多步骤任务转化为一致且可审计的流程：</p>
<ul>
<li><strong>CI/CD 流水线</strong>：标准化的构建、测试、部署步骤</li>
<li><strong>客户入职流程</strong>：账户创建、权限配置、培训材料发送</li>
<li><strong>月度报告生成</strong>：数据收集、分析、报告编写、分发</li>
<li><strong>代码重构任务</strong>：识别问题、建议改进、执行修改、验证测试</li>
</ul>
<h4 id="跨工具互操作interoperability">跨工具互操作（Interoperability）</h4>
<p>一次编写，多处使用：</p>
<ul>
<li>在 <strong>GitHub Copilot</strong> 中辅助编码</li>
<li>在 <strong>Cursor</strong> 中进行项目重构</li>
<li>在 <strong>Claude</strong> 中进行文档写作</li>
<li>在 <strong>Goose</strong> 中执行自动化任务</li>
</ul>
<p>这种标准化使得组织知识可以在不同工具间无缝流转。</p>
<h3 id="13-谁在支持-agent-skills">1.3 谁在支持 Agent Skills？</h3>
<p>目前已有多个主流 AI 开发工具支持该标准：</p>
<p><img src="https://img2024.cnblogs.com/blog/577140/202512/577140-20251222115747805-798970849.png" alt="" loading="lazy"></p>
<h2 id="二agent-skills-规范解读">二、Agent Skills 规范解读</h2>
<h3 id="21-基本目录结构">2.1 基本目录结构</h3>
<p>一个最简单的 Skill 只需要包含 <code>SKILL.md</code> 文件：</p>
<pre><code>skill-name/
└── SKILL.md          # 必需
</code></pre>
<p>可选的支持目录：</p>
<pre><code>skill-name/
├── SKILL.md          # 必需：技能描述和使用说明
├── scripts/          # 可选：可执行脚本
│   └── tool.py
├── references/       # 可选：详细参考文档
│   └── REFERENCE.md
└── assets/          # 可选：静态资源
    └── template.json
</code></pre>
<h3 id="22-skillmd-格式规范">2.2 SKILL.md 格式规范</h3>
<p><code>SKILL.md</code> 文件包含两部分：<strong>YAML frontmatter</strong> 和 <strong>Markdown 正文</strong>。</p>
<h4 id="frontmatter-必需字段">Frontmatter 必需字段</h4>
<pre><code class="language-yaml">---
name: skill-name
description: 描述技能功能和使用场景的文字，应包含帮助 Agent 识别相关任务的关键词
---
</code></pre>
<p><strong>name 字段规则</strong>：</p>
<ul>
<li>长度：1-64 字符</li>
<li>字符：仅允许小写字母、数字和连字符 (<code>a-z</code>, <code>-</code>)</li>
<li>不能以连字符开头或结尾</li>
<li>不能包含连续的连字符 (<code>--</code>)</li>
<li><strong>必须与父目录名完全一致</strong></li>
</ul>
<p><strong>description 字段规则</strong>：</p>
<ul>
<li>长度：1-1024 字符</li>
<li>应说明技能的功能和使用时机</li>
<li>包含关键词帮助 Agent 识别适用场景</li>
</ul>
<h4 id="可选字段">可选字段</h4>
<pre><code class="language-yaml">---
name: pdf-processing
description: Extract text from PDFs and merge multiple documents
license: MIT
compatibility: Requires Python 3.8+ and poppler-utils
metadata:
  author: your-org
  version: "1.0.0"
---
</code></pre>
<h3 id="23-渐进式信息披露">2.3 渐进式信息披露</h3>
<p>Agent Skills 采用渐进式加载策略来优化 token 使用：</p>
<ol>
<li><strong>元数据阶段</strong> (~100 tokens)：启动时加载所有 Skills 的 <code>name</code> 和 <code>description</code></li>
<li><strong>指令阶段</strong> (&lt;5000 tokens 推荐)：激活 Skill 时加载完整的 <code>SKILL.md</code></li>
<li><strong>资源阶段</strong> (按需)：仅在需要时加载 <code>scripts/</code>、<code>references/</code>、<code>assets/</code> 中的文件</li>
</ol>
<p><strong>最佳实践</strong>：</p>
<ul>
<li>保持 <code>SKILL.md</code> 在 500 行以内</li>
<li>将详细参考资料移至 <code>references/</code> 目录</li>
<li>避免深层嵌套的文件引用</li>
</ul>
<h2 id="三使用-net-file-based-apps-编写-agent-skills-脚本">三、使用 .NET File-Based Apps 编写 Agent Skills 脚本</h2>
<p>在进入具体实现之前，我们先来看看为什么 .NET File-Based Apps 是编写 Agent Skills 中 <code>scripts/</code> 目录下可执行脚本的优秀选择。</p>
<h3 id="30-net-作为脚本语言的独特优势">3.0 .NET 作为脚本语言的独特优势</h3>
<p>根据 Agent Skills 规范，<code>scripts/</code> 目录中的可执行代码应该自包含或明确记录依赖、包含有用的错误消息、优雅处理边界情况。常见的脚本语言包括 Python、Bash、JavaScript，而 .NET File-Based Apps 为此提供了一个强大的替代方案：</p>
<h4 id="对比其他脚本语言方案">对比其他脚本语言方案</h4>
<p>在为 Agent Skills 编写 <code>scripts/</code> 目录下的可执行脚本时，.NET File-Based Apps 与其他常用语言的对比：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>.NET File-Based Apps</th>
<th>Python 脚本</th>
<th>Node.js 脚本</th>
</tr>
</thead>
<tbody>
<tr>
<td>单文件运行</td>
<td>✅ <code>dotnet file.cs</code></td>
<td>✅ <code>python file.py</code></td>
<td>✅ <code>node file.js</code></td>
</tr>
<tr>
<td>依赖声明</td>
<td>✅ 文件内声明</td>
<td>⚠️ 需 <code>requirements.txt</code></td>
<td>⚠️ 需 <code>package.json</code></td>
</tr>
<tr>
<td>类型安全</td>
<td>✅ 编译时检查</td>
<td>❌ 运行时错误</td>
<td>⚠️ 需 TypeScript</td>
</tr>
<tr>
<td>性能</td>
<td>✅ Native AOT 编译</td>
<td>⚠️ 解释执行</td>
<td>⚠️ JIT 编译</td>
</tr>
<tr>
<td>跨平台部署</td>
<td>✅ 单个可执行文件</td>
<td>⚠️ 需 Python 运行时</td>
<td>⚠️ 需 Node.js 运行时</td>
</tr>
<tr>
<td>企业级库支持</td>
<td>✅ 丰富的 NuGet 生态</td>
<td>✅ PyPI 生态</td>
<td>✅ npm 生态</td>
</tr>
<tr>
<td>AI Agent 可读性</td>
<td>✅ 结构清晰、自文档化</td>
<td>✅ 简洁</td>
<td>✅ 简洁</td>
</tr>
</tbody>
</table>
<h4 id="net-的三大杀手锏">.NET 的三大杀手锏</h4>
<p><strong>1. 真正的自包含</strong><br>
依赖声明直接写在代码文件头部，Agent 一眼就能看懂需要什么包、什么版本，无需查找外部配置文件。</p>
<pre><code class="language-csharp">#:package PdfSharpCore@1.3.65
#:package Spectre.Console@0.49.1
</code></pre>
<p><strong>2. 从开发到生产无缝过渡</strong><br>
开发时直接运行 <code>.cs</code> 文件，生产时一键发布为 Native AOT 可执行文件，启动速度可达毫秒级，内存占用极小。</p>
<p><strong>3. AI 友好的代码结构</strong><br>
.NET 的强类型和清晰的语法结构，让 AI Agent 更容易理解代码意图、发现潜在问题、提出改进建议。</p>
<h3 id="31-什么是-net-file-based-apps">3.1 什么是 .NET File-Based Apps？</h3>
<p>.NET 10 引入的 File-Based Apps 特性允许将单个 <code>.cs</code> 文件作为完整的应用程序运行，无需传统的项目文件（<code>.csproj</code>）。关键特性包括：</p>
<ul>
<li><strong>单文件即应用</strong>：一个 <code>.cs</code> 文件包含完整程序</li>
<li><strong>内联依赖声明</strong>：通过特殊注释声明 NuGet 包</li>
<li><strong>直接运行</strong>：<code>dotnet file.cs</code> 即可执行</li>
<li><strong>支持发布</strong>：可以发布为独立可执行文件或 Native AOT</li>
<li><strong>零配置</strong>：无需 <code>csproj</code>、<code>sln</code> 等项目文件</li>
</ul>
<h3 id="32-file-based-apps-如何适配-agent-skills-需求">3.2 File-Based Apps 如何适配 Agent Skills 需求？</h3>
<p>Agent Skills 规范强调「简洁」、「自包含」、「可理解」，.NET File-Based Apps 的设计理念与之完美契合：</p>
<h4 id="适配点-1渐进式复杂度">适配点 1：渐进式复杂度</h4>
<pre><code class="language-csharp">// 入门：10 行代码的简单工具
#!/usr/bin/env dotnet
if (args.Length == 0) { Console.WriteLine("Hello, Agent!"); return; }
Console.WriteLine($"Processing: {args[0]}");

// 进阶：添加依赖和错误处理
#:package Newtonsoft.Json@13.0.3
using Newtonsoft.Json;
try { /* 处理逻辑 */ }
catch (Exception ex) { Console.Error.WriteLine(ex.Message); return 1; }

// 生产：发布为高性能可执行文件
#:property PublishAot=true
// 一行命令：dotnet publish -r win-x64
</code></pre>
<p>从原型到生产，同一个文件，逐步迭代，没有项目结构的重构成本。</p>
<h4 id="适配点-2ai-agent-的理解成本">适配点 2：AI Agent 的理解成本</h4>
<p><strong>Python 方案</strong>：Agent 需要找到并理解多个文件</p>
<pre><code>my-skill/
├── tool.py          # Agent 需要读取
├── requirements.txt # Agent 需要读取
└── README.md        # Agent 需要读取
</code></pre>
<p><strong>.NET 方案</strong>：一个文件包含所有信息</p>
<pre><code>my-skill/
└── scripts/
    └── tool.cs      # 依赖、逻辑、配置全在这里
</code></pre>
<p>Agent 只需读取一个文件，就能了解：</p>
<ul>
<li>需要什么依赖（<code>#:package</code>）</li>
<li>如何运行（<code>#!/usr/bin/env dotnet</code>）</li>
<li>做什么事（代码逻辑）</li>
<li>如何部署（<code>#:property</code>）</li>
</ul>
<h4 id="适配点-3企业级可靠性">适配点 3：企业级可靠性</h4>
<p>.NET 的类型系统在 Agent 驱动的开发中尤为重要：</p>
<pre><code class="language-csharp">// 编译时就能发现错误，而不是运行时崩溃
string pdfPath = args[0];  // Agent 知道这是字符串
int pageCount = GetPageCount(pdfPath);  // Agent 知道返回值是整数

// Python 中相同的错误可能运行时才暴露
# pdf_path = args[0]  # 类型不明确
# page_count = get_page_count(pdf_path)  # 返回值类型不明确
</code></pre>
<p>这意味着 Agent 在生成或修改代码时，有更多的安全护栏。</p>
<h4 id="适配点-4性能与资源效率">适配点 4：性能与资源效率</h4>
<p>AI Agent 可能频繁调用 Skills，启动性能至关重要：</p>
<pre><code class="language-bash"># Python 脚本启动
$ time python tool.py input.pdf
real    0m0.234s  # 需要加载解释器

# .NET File-Based App 启动
$ time dotnet tool.cs input.pdf
real    0m0.089s  # JIT 编译

# Native AOT 编译后
$ time ./tool input.pdf
real    0m0.012s  # 接近原生 C++ 性能
</code></pre>
<p>对于 Agent 执行的自动化任务，这种性能差异会累积成显著的时间节省。</p>
<h3 id="33-实战案例split-pdf-skill">3.3 实战案例：split-pdf Skill</h3>
<p>让我们以一个实际的 PDF 拆分工具为例，演示如何开发符合规范的 Agent Skill。</p>
<h4 id="步骤-1创建目录结构">步骤 1：创建目录结构</h4>
<pre><code class="language-bash">mkdir -p split-pdf/scripts
cd split-pdf
</code></pre>
<h4 id="步骤-2编写-skillmd">步骤 2：编写 SKILL.md</h4>
<p><code>SKILL.md</code> 是 Agent Skill 的核心，包含元数据和使用说明。创建 <code>SKILL.md</code> 文件：</p>
<pre><code class="language-markdown">---
name: split-pdf
description: Split PDF files into separate single-page documents or extract specific page ranges. Use when you need to divide a PDF into multiple files, extract particular pages, or process PDF pages individually. Works with multi-page PDF documents.
license: MIT
---

# Split PDF

将 PDF 文件拆分为多个单页文件或提取指定页面范围。

## 使用场景

- 将多页 PDF 拆分为独立的单页文件
- 提取 PDF 的特定页面范围
- 需要单独处理 PDF 各个页面时

## 使用方法

使用 `scripts/split-pdf.cs` 脚本进行 PDF 拆分：

### 拆分页面
# 拆分所有页面
dotnet scripts/split-pdf.cs input.pdf output-dir/
# 拆分第 1-5 页
dotnet scripts/split-pdf.cs input.pdf output-dir/ 1-5


## 输出格式

拆分后的文件命名格式：`{原文件名}_page_{页码}.pdf`

## 依赖项

- PdfSharpCore 1.3.65 - PDF 操作核心库
- Spectre.Console 0.49.1 - 美化的控制台输出



**注意**：
- `name` 必须与目录名 `split-pdf` 完全一致
- `description` 包含关键词 "split", "PDF", "pages" 帮助 Agent 识别场景
</code></pre>
<h4 id="步骤-3编写-file-based-app-脚本">步骤 3：编写 File-Based App 脚本</h4>
<p>在 <code>scripts/</code> 目录下创建 <code>.NET File-Based App 脚本 </code>split-pdf.cs`：</p>
<pre><code class="language-csharp">#!/usr/bin/env dotnet
#:package PdfSharpCore@1.3.65
#:package Spectre.Console@0.49.1
#:property PublishAot=true

using PdfSharpCore.Pdf;
using PdfSharpCore.Pdf.IO;
using Spectre.Console;
using System;
using System.IO;

// ==================== 参数校验 ====================
if (args.Length &lt; 2)
{
    AnsiConsole.MarkupLine("[red]错误: 参数不足[/]");
    AnsiConsole.MarkupLine("[yellow]用法: dotnet split-pdf.cs &lt;PDF文件&gt; &lt;输出目录&gt; [页面范围][/]");
    return 1;
}

var pdfPath = args[0];
var outputDir = args[1];
var pageRange = args.Length &gt;= 3 ? args[2] : null;

// 验证文件
if (!File.Exists(pdfPath))
{
    AnsiConsole.MarkupLine($"[red]错误: 文件不存在: {pdfPath}[/]");
    return 1;
}

// 创建输出目录
Directory.CreateDirectory(outputDir);

// ==================== 拆分 PDF ====================
try
{
    using var inputDocument = PdfReader.Open(pdfPath, PdfDocumentOpenMode.Import);
    var totalPages = inputDocument.PageCount;
    
    // 解析页面范围
    int startPage = 1, endPage = totalPages;
    if (!string.IsNullOrEmpty(pageRange))
    {
        var parts = pageRange.Split('-');
        if (parts.Length == 2 &amp;&amp; 
            int.TryParse(parts[0], out startPage) &amp;&amp; 
            int.TryParse(parts[1], out endPage))
        {
            startPage = Math.Max(1, Math.Min(startPage, totalPages));
            endPage = Math.Max(startPage, Math.Min(endPage, totalPages));
        }
    }

    var baseName = Path.GetFileNameWithoutExtension(pdfPath);
    
    await AnsiConsole.Progress()
        .StartAsync(async ctx =&gt;
        {
            var task = ctx.AddTask("拆分 PDF 页面", maxValue: endPage - startPage + 1);

            for (int i = startPage; i &lt;= endPage; i++)
            {
                using var outputDocument = new PdfDocument();
                outputDocument.AddPage(inputDocument.Pages[i - 1]);
                
                var outputPath = Path.Combine(outputDir, $"{baseName}_page_{i:D3}.pdf");
                outputDocument.Save(outputPath);
                
                task.Increment(1);
                await Task.CompletedTask;
            }
        });

    AnsiConsole.MarkupLine($"[green]✅ 拆分完成！已生成 {endPage - startPage + 1} 个文件[/]");
    return 0;
}
catch (Exception ex)
{
    AnsiConsole.MarkupLine($"[red]❌ 错误: {ex.Message}[/]");
    return 1;
}
</code></pre>
<p><strong>关键要素解析</strong>：</p>
<ol>
<li><strong>Shebang 行</strong>：<code>#!/usr/bin/env dotnet</code> - 使脚本可在 Unix 系统直接执行</li>
<li><strong>依赖声明</strong>：<code>#:package</code> 指令声明 NuGet 包及版本</li>
<li><strong>发布配置</strong>：<code>#:property PublishAot=true</code> - 支持 Native AOT 编译</li>
<li><strong>顶层语句</strong>：无需 <code>Main</code> 方法，直接编写逻辑</li>
<li><strong>返回值</strong>：使用 <code>return</code> 返回退出码</li>
</ol>
<h2 id="四测试与验证">四、测试与验证</h2>
<h3 id="41-本地测试">4.1 本地测试</h3>
<h4 id="直接运行测试">直接运行测试</h4>
<pre><code class="language-bash"># 准备测试 PDF 文件
cd split-pdf

# 测试拆分所有页面
dotnet scripts/split-pdf.cs test.pdf ./output/

# 测试拆分指定范围
dotnet scripts/split-pdf.cs test.pdf ./output/ 1-3

# 验证输出
ls ./output/
# 应该看到：test_page_001.pdf, test_page_002.pdf, test_page_003.pdf
</code></pre>
<h4 id="错误处理测试">错误处理测试</h4>
<pre><code class="language-bash"># 测试文件不存在
dotnet scripts/split-pdf.cs nonexistent.pdf ./output/

# 测试参数不足
dotnet scripts/split-pdf.cs

# 测试无效页面范围
dotnet scripts/split-pdf.cs test.pdf ./output/ 100-200
</code></pre>
<h3 id="42-agent-集成测试">4.2 Agent 集成测试</h3>
<p>在支持 Agent Skills 的环境中测试（如 GitHub Copilot）：</p>
<ol>
<li>将 Skill 放置在 <code>.github/skills/</code> 目录下</li>
<li>重启或刷新 Agent</li>
<li>测试 Agent 是否能发现和使用该 Skill</li>
</ol>
<pre><code>用户提问：请帮我把这个 PDF 文件拆分成单独的页面

Agent 行为：
1. 识别任务涉及 PDF 拆分
2. 查找并激活 split-pdf skill
3. 读取 SKILL.md 了解使用方法
4. 执行：dotnet scripts/split-pdf.cs document.pdf ./pages/
5. 向用户报告结果
</code></pre>
<h2 id="五最佳实践">五、最佳实践</h2>
<h3 id="51-脚本设计原则">5.1 脚本设计原则</h3>
<h4 id="清晰的参数设计">清晰的参数设计</h4>
<pre><code class="language-csharp">// ❌ 不好：参数含义不明
dotnet tool.cs input output 1

// ✅ 好：参数含义清晰
dotnet split-pdf.cs document.pdf ./pages/ 1-10
</code></pre>
<h4 id="友好的错误提示">友好的错误提示</h4>
<pre><code class="language-csharp">if (args.Length &lt; 2)
{
    AnsiConsole.MarkupLine("[red]错误: 参数不足[/]");
    AnsiConsole.MarkupLine("[yellow]用法: dotnet split-pdf.cs &lt;PDF文件&gt; &lt;输出目录&gt; [页面范围][/]");
    AnsiConsole.MarkupLine("[gray]示例: dotnet split-pdf.cs input.pdf ./output/ 1-5[/]");
    return 1;
}
</code></pre>
<h4 id="进度反馈">进度反馈</h4>
<p>使用 Spectre.Console 提供直观的进度显示：</p>
<pre><code class="language-csharp">await AnsiConsole.Progress()
    .StartAsync(async ctx =&gt;
    {
        var task = ctx.AddTask("处理中", maxValue: totalItems);
        foreach (var item in items)
        {
            // 处理逻辑
            task.Increment(1);
        }
    });
</code></pre>
<h3 id="52-依赖管理">5.2 依赖管理</h3>
<h4 id="选择稳定的包版本">选择稳定的包版本</h4>
<pre><code class="language-csharp">// ✅ 指定明确版本
#:package PdfSharpCore@1.3.65
#:package Spectre.Console@0.49.1

// ❌ 避免使用不稳定版本
#:package SomePackage@*
#:package BetaPackage@2.0.0-beta
</code></pre>
<h4 id="最小化依赖">最小化依赖</h4>
<p>只引入必需的包，减少潜在的兼容性问题。</p>
<h3 id="53-文档编写">5.3 文档编写</h3>
<h4 id="description-关键词策略">Description 关键词策略</h4>
<p>在 <code>description</code> 中包含：</p>
<ul>
<li><strong>动作关键词</strong>：split, extract, convert, merge</li>
<li><strong>领域关键词</strong>：PDF, document, pages</li>
<li><strong>场景关键词</strong>：when you need to divide, when working with</li>
</ul>
<pre><code class="language-yaml"># ✅ 好的 description
description: Split PDF files into separate single-page documents or extract specific page ranges. Use when you need to divide a PDF into multiple files, extract particular pages, or process PDF pages individually.

# ❌ 不够好
description: PDF tool for splitting.
</code></pre>
<h4 id="提供清晰的示例">提供清晰的示例</h4>
<p>在 <code>SKILL.md</code> 正文中提供：</p>
<ul>
<li>常见用例的示例</li>
<li>不同参数组合的效果</li>
<li>预期的输出格式</li>
</ul>
<h3 id="54-跨平台兼容性">5.4 跨平台兼容性</h3>
<h4 id="路径处理">路径处理</h4>
<pre><code class="language-csharp">// ✅ 使用 Path.Combine
var outputPath = Path.Combine(outputDir, $"{baseName}_page_{i:D3}.pdf");

// ❌ 避免硬编码路径分隔符
var outputPath = outputDir + "\\" + baseName + "_page_" + i + ".pdf";
</code></pre>
<h4 id="编码处理">编码处理</h4>
<pre><code class="language-csharp">// 确保控制台正确显示 Unicode
Console.OutputEncoding = System.Text.Encoding.UTF8;
</code></pre>
<h2 id="六进阶话题">六、进阶话题</h2>
<h3 id="61-支持多个相关工具">6.1 支持多个相关工具</h3>
<p>可以在一个 Skill 中包含多个相关脚本：</p>
<pre><code>pdf-toolkit/
├── SKILL.md
└── scripts/
    ├── split.cs
    ├── merge.cs
    └── extract-text.cs
</code></pre>
<p>在 <code>SKILL.md</code> 中说明每个工具的用途和使用场景。</p>
<h3 id="62-使用-references-目录">6.2 使用 References 目录</h3>
<p>对于复杂的 Skill，将详细文档分离：</p>
<pre><code>data-analysis/
├── SKILL.md           # 简要说明和快速开始
├── scripts/
│   └── analyze.cs
└── references/
    ├── REFERENCE.md   # 详细 API 参考
    ├── examples.md    # 更多示例
    └── algorithms.md  # 算法说明
</code></pre>
<p>在 <code>SKILL.md</code> 中引用：</p>
<pre><code class="language-markdown">详细的 API 参考请见 [REFERENCE.md](references/REFERENCE.md "REFERENCE.md")。
</code></pre>
<h3 id="63-native-aot-优化">6.3 Native AOT 优化</h3>
<p>对于性能敏感的工具，启用 Native AOT：</p>
<pre><code class="language-csharp">#:property PublishAot=true
#:property InvariantGlobalization=true  // 减小体积
</code></pre>
<p>发布时使用：</p>
<pre><code class="language-bash">dotnet publish scripts/tool.cs -r win-x64 --property:PublishAot=true
</code></pre>
<p><strong>Native AOT 优势</strong>：</p>
<ul>
<li>极快的启动时间</li>
<li>较小的内存占用</li>
<li>无需安装 .NET 运行时</li>
<li>单个可执行文件</li>
</ul>
<h3 id="64-团队协作">6.4 团队协作</h3>
<p>将 Skills 放入版本控制：</p>
<pre><code>.github/
└── skills/
    ├── split-pdf/
    ├── data-analysis/
    └── code-review/
</code></pre>
<p>在团队 README 中说明：</p>
<ul>
<li>如何安装 Skills</li>
<li>如何贡献新 Skills</li>
<li>编码规范和测试要求</li>
</ul>
<h2 id="七意义与展望">七、意义与展望</h2>
<h3 id="71-对开发者的价值">7.1 对开发者的价值</h3>
<p>Agent Skills 为开发者带来三大核心价值：</p>
<p><strong>能力复用</strong>：一次编写，在 Copilot、Cursor、Claude 等多个 Agent 产品中使用，还可跨团队共享或通过 GitHub 公开发布。</p>
<p><strong>知识沉淀</strong>：将团队最佳实践固化为版本化的 Skills，如代码审查规范、部署流程、数据分析模板等，确保工作流程的一致性。</p>
<p><strong>提升效率</strong>：通过明确的指导让 Agent 更准确地执行复杂任务，减少试错和修正，提供一致的输出质量。</p>
<h3 id="72-net-file-based-apps-的机遇">7.2 .NET File-Based Apps 的机遇</h3>
<p>File-Based Apps 为 .NET 带来了新的应用场景：</p>
<p><strong>降低门槛</strong>：从复杂的项目结构到单文件脚本，让 Python、Node.js 开发者也能轻松尝试 .NET。</p>
<p><strong>AI 协作优势</strong>：强类型系统帮助 AI 更准确理解代码、即时编译反馈加速修正、丰富的 API 文档提升 AI 可读性。</p>
<p><strong>性能差异化</strong>：Native AOT 编译在批量任务中的性能优势（启动快 90%+），不仅提升用户体验，也降低云端成本。</p>
<p><strong>生态拓展</strong>：.NET 开发者可以将企业实践打包为 Skills，在 AI Agent 生态中展现 .NET 价值，同时 .NET 的实践经验也能反哺 Agent Skills 标准演进。</p>
<h3 id="73-未来展望">7.3 未来展望</h3>
<p>Agent Skills 生态正在快速发展，可以期待：</p>
<ul>
<li><strong>Skills 市场</strong>：类似 npm 的包管理器和分发平台</li>
<li><strong>工具链集成</strong>：IDE 内置 Agent Skills 模板和验证工具</li>
<li><strong>应用拓展</strong>：从个人工具到企业知识库、教育培训、行业解决方案</li>
</ul>
<p>.NET File-Based Apps 在这个生态中的定位清晰：作为 Agent Skills 脚本的强类型、高性能选择，为开发者提供从原型到生产的无缝体验。</p>
<h2 id="八总结">八、总结</h2>
<p>通过本文的探索，我们看到 .NET File-Based Apps 作为 Agent Skills 脚本语言的独特价值：<strong>单文件自包含、强类型安全、Native AOT 高性能</strong>，完美匹配 Agent Skills 规范对脚本的要求。</p>
<h3 id="核心收获">核心收获</h3>
<p>本文从 Agent Skills 规范入手，通过 split-pdf 实战案例，展示了如何用 .NET File-Based Apps 编写高质量的 Skill 脚本，并探讨了其在 AI 时代的应用机遇。</p>
<h3 id="开始行动">开始行动</h3>
<p><strong>对于 .NET 开发者</strong>：用熟悉的 C# 为 Agent Skills 编写脚本，将专业知识封装为可复用的 Skills，在 AI 时代发挥 .NET 的价值。</p>
<p><strong>对于其他技术栈开发者</strong>：.NET File-Based Apps 和 Python 一样简洁，但提供了类型安全和 Native AOT 性能。值得尝试：<code>winget install Microsoft.DotNet.SDK.10</code> 然后创建你的第一个 <code>.cs</code> 脚本。</p>
<p><strong>下一步</strong>：动手实现你的第一个 Agent Skill，将专业知识转化为可复用的能力，在 AI 时代发挥更大价值。</p>
<h2 id="参考资源">参考资源</h2>
<ul>
<li><a href="https://agentskills.io/" title="Agent Skills 官方网站" target="_blank" rel="noopener nofollow">Agent Skills 官方网站</a></li>
<li><a href="https://agentskills.io/specification" title="Agent Skills 规范" target="_blank" rel="noopener nofollow">Agent Skills 规范</a></li>
<li><a href="https://github.com/agentskills/agentskills" title="Agent Skills GitHub" target="_blank" rel="noopener nofollow">Agent Skills GitHub</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/core/sdk/file-based-apps" target="_blank" rel="noopener nofollow">.NET File-Based Apps 文档</a></li>
<li><a href="https://github.com/anthropics/skills" title="anthropics/skills" target="_blank" rel="noopener nofollow">anthropics/skills</a></li>
</ul>
<hr>

</div>
<div id="MySignature" role="contentinfo">
    <div style="display: block; border: 2px solid #6ecaa8; padding: 10px; background: aliceblue">  
<img src="https://files.cnblogs.com/files/sheng-jie/maf-course-card-scan.bmp">
<blockquote>
<b>👆面向.NET开发者的AI Agent 开发课程【.NET+AI | 智能体开发进阶】已上线，欢迎扫码加入学习。👆</b>
</blockquote>
</div>

<img src="https://files.cnblogs.com/files/sheng-jie/scan-follow.bmp">
<blockquote>
<b>
关注我的公众号『向 AI 而行』，我们微信不见不散。
<br>
阅罢此文，如果您觉得本文不错并有所收获，请【打赏】或【推荐】，也可【评论】留下您的问题或建议与我交流。

你的支持是我不断创作和分享的不竭动力！</b>
</blockquote>

<div style="display: block; border: 2px solid #6ecaa8; padding: 10px; background: aliceblue" id="AllanboltSignature">    
        <div>作者：<a href="http://www.jianshu.com/u/39ec0e6b1844" target="_blank">『圣杰』</a></div>
        <div>出处：<a href="http://www.cnblogs.com/sheng-jie/" target="_blank">http://www.cnblogs.com/sheng-jie/</a></div>
        <div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。</div>  
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.12152777777777778" data-date-updated="2025-12-22 14:53">2025-12-22 11:58</span>&nbsp;
<a href="https://www.cnblogs.com/sheng-jie">「圣杰」</a>&nbsp;
阅读(<span id="post_view_count">317</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19381647);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19381647', targetLink: 'https://www.cnblogs.com/sheng-jie/p/19381647', title: '从 MCP 到 Agent Skills，AI Ready 的 .NET 10 正当时' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ Lit 架构解析：从 Web Components 到 lit-html 的底层原理 ]]></title>
    <link>https://www.cnblogs.com/zxlh1529/p/19370741</link>
    <guid>9b4d5fcca0fec481cf41ce9809b58233</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zxlh1529/p/19370741" title="发布于 2025-12-22 10:32">
    <span role="heading" aria-level="2">Lit 架构解析：从 Web Components 到 lit-html 的底层原理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Lit（原名 lit-element + lit-html）并不是一个“对标 React/Vue 的框架”，而是一套<strong>围绕 Web Components 的最小化渲染与响应式方案</strong>。</p>
<p>它的设计目标非常明确：</p>
<blockquote>
<p><strong>用最少的运行时代码，解决组件化与高性能 DOM 更新问题</strong></p>
</blockquote>
<p>本文将从架构层面，逐步拆解：</p>
<ul>
<li>Lit 在整个前端生态中的位置</li>
<li>Lit 的核心组成</li>
<li>lit-html 的模板与更新机制</li>
<li>Lit 与 React / Vue 的根本差异</li>
</ul>
<hr>
<h2 id="一lit-在前端架构中的定位">一、Lit 在前端架构中的定位</h2>
<h3 id="11-lit-解决的不是应用而是组件">1.1 Lit 解决的不是“应用”，而是“组件”</h3>
<p>对比常见框架的定位：</p>
<table>
<thead>
<tr>
<th>技术</th>
<th>核心目标</th>
</tr>
</thead>
<tbody>
<tr>
<td>React / Vue</td>
<td>构建完整应用</td>
</tr>
<tr>
<td>Lit</td>
<td>构建标准 Web Components</td>
</tr>
<tr>
<td>Web Components</td>
<td>浏览器原生组件模型</td>
</tr>
</tbody>
</table>
<p>Lit 的核心思想是：</p>
<blockquote>
<p><strong>不发明组件标准，只补齐 Web Components 的开发体验</strong></p>
</blockquote>
<hr>
<h3 id="12-lit-架构全景">1.2 Lit 架构全景</h3>
<pre><code class="language-text">浏览器原生能力
├── Custom Elements
├── Shadow DOM
├── HTML Template
│
Lit 提供
├── lit-html（渲染引擎）
├── 响应式系统
├── 生命周期封装
└── DX 改进（装饰器、模板语法）
</code></pre>
<blockquote>
<p><strong>Lit = Web Components + lit-html + 响应式封装</strong></p>
</blockquote>
<hr>
<h2 id="二lit-的整体架构拆解">二、Lit 的整体架构拆解</h2>
<h3 id="21-核心模块组成">2.1 核心模块组成</h3>
<p>现代 Lit（v3+）主要由三部分构成：</p>
<pre><code class="language-text">lit
├── ReactiveElement（响应式基础类）
├── LitElement（组件基类）
└── lit-html（模板 &amp; 渲染引擎）
</code></pre>
<p>它们的职责非常清晰：</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>职责</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReactiveElement</td>
<td>响应式属性、更新调度</td>
</tr>
<tr>
<td>LitElement</td>
<td>生命周期 + render 桥接</td>
</tr>
<tr>
<td>lit-html</td>
<td>高性能 DOM 渲染</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="22-继承关系">2.2 继承关系</h3>
<pre><code class="language-ts">HTMLElement
  └── ReactiveElement
        └── LitElement
              └── YourComponent
</code></pre>
<p>Lit <strong>没有虚拟 DOM 层</strong>，这是理解其底层原理的关键。</p>
<hr>
<h2 id="三web-components-是-lit-的根基">三、Web Components 是 Lit 的根基</h2>
<h3 id="31-custom-elements">3.1 Custom Elements</h3>
<pre><code class="language-ts">customElements.define('my-element', MyElement)
</code></pre>
<ul>
<li>浏览器原生注册</li>
<li>生命周期标准化</li>
<li>不依赖任何框架</li>
</ul>
<hr>
<h3 id="32-shadow-dom">3.2 Shadow DOM</h3>
<pre><code class="language-ts">this.attachShadow({ mode: 'open' })
</code></pre>
<ul>
<li>样式隔离</li>
<li>DOM 隔离</li>
<li>原生封装能力</li>
</ul>
<hr>
<h3 id="33-html-template">3.3 HTML Template</h3>
<pre><code class="language-html">&lt;template&gt;
  &lt;p&gt;Hello&lt;/p&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li>惰性解析</li>
<li>可复用</li>
<li>浏览器级优化</li>
</ul>
<p>Lit <strong>大量依赖 <code>&lt;template&gt;</code> 的原生特性</strong>。</p>
<hr>
<h2 id="四lit-html-的核心思想">四、lit-html 的核心思想</h2>
<h3 id="41-lit-html-是什么">4.1 lit-html 是什么</h3>
<p>lit-html 是 Lit 的<strong>渲染引擎</strong>，核心目标只有一个：</p>
<blockquote>
<p><strong>在不使用 Virtual DOM 的情况下，做到最小粒度 DOM 更新</strong></p>
</blockquote>
<hr>
<h3 id="42-模板是静态的数据是动态的">4.2 模板是“静态的”，数据是“动态的”</h3>
<pre><code class="language-ts">html`&lt;p&gt;Hello ${name}&lt;/p&gt;`
</code></pre>
<p>模板会被拆分为：</p>
<pre><code class="language-text">静态字符串数组 + 动态表达式数组
</code></pre>
<p>类似于：</p>
<pre><code class="language-ts">[
  "&lt;p&gt;Hello ",
  "&lt;/p&gt;"
]
</code></pre>
<hr>
<h3 id="43-templateresult-结构">4.3 TemplateResult 结构</h3>
<pre><code class="language-ts">{
  strings: TemplateStringsArray,
  values: any[]
}
</code></pre>
<blockquote>
<p><strong>模板结构在第一次渲染时就固定下来</strong></p>
</blockquote>
<hr>
<h2 id="五lit-html-的底层渲染流程importance">五、lit-html 的底层渲染流程（Importance）</h2>
<h3 id="51-首次渲染流程">5.1 首次渲染流程</h3>
<pre><code class="language-text">1. 解析模板字符串
2. 生成 &lt;template&gt; DOM
3. 标记动态插槽（Part）
4. clone template.content
5. 插入真实 DOM
</code></pre>
<p>动态插槽被称为 <strong>Part</strong>。</p>
<hr>
<h3 id="52-part更新单元">5.2 Part（更新单元）</h3>
<p>Lit 将 DOM 中“可能变化的位置”抽象成 Part：</p>
<table>
<thead>
<tr>
<th>Part 类型</th>
<th>对应位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>ChildPart</td>
<td>文本节点 / 子节点</td>
</tr>
<tr>
<td>AttributePart</td>
<td>普通属性</td>
</tr>
<tr>
<td>PropertyPart</td>
<td>DOM 属性</td>
</tr>
<tr>
<td>BooleanAttributePart</td>
<td>布尔属性</td>
</tr>
<tr>
<td>EventPart</td>
<td>事件</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="53-更新阶段没有-diff">5.3 更新阶段（没有 Diff）</h3>
<pre><code class="language-text">状态变化
  ↓
重新执行 render()
  ↓
生成新的 values
  ↓
逐个 Part 对比并更新
</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>不比较 DOM 树</li>
<li>只更新“表达式对应的节点”</li>
</ul>
<hr>
<h3 id="54-为什么比-virtual-dom-快">5.4 为什么比 Virtual DOM 快</h3>
<p>React/Vue：</p>
<pre><code class="language-text">state → vdom → diff → patch
</code></pre>
<p>lit-html：</p>
<pre><code class="language-text">state → values → Part.update()
</code></pre>
<blockquote>
<p><strong>Lit 的更新路径更短，内存占用更小</strong></p>
</blockquote>
<hr>
<h2 id="六lit-的响应式系统原理">六、Lit 的响应式系统原理</h2>
<h3 id="61-reactiveelement-的核心机制">6.1 ReactiveElement 的核心机制</h3>
<pre><code class="language-ts">@property({ type: String })
name = 'lit'
</code></pre>
<p>底层原理：</p>
<ol>
<li>将属性转为 getter/setter</li>
<li>setter 触发 <code>requestUpdate</code></li>
<li>更新被批量调度（microtask）</li>
<li>调用 <code>update()</code> → <code>render()</code></li>
</ol>
<hr>
<h3 id="62-更新是异步批量的">6.2 更新是异步批量的</h3>
<pre><code class="language-text">多次 set
  ↓
一次 render
</code></pre>
<p>类似 Vue 的 nextTick，但实现更轻量。</p>
<hr>
<h2 id="七lit-的生命周期设计">七、Lit 的生命周期设计</h2>
<pre><code class="language-ts">connectedCallback()
disconnectedCallback()
shouldUpdate()
willUpdate()
update()
updated()
</code></pre>
<p>特点：</p>
<ul>
<li>与 Custom Elements 生命周期对齐</li>
<li>不引入额外概念</li>
<li>更贴近浏览器模型</li>
</ul>
<hr>
<h2 id="八lit-与-react--vue-的根本差异">八、Lit 与 React / Vue 的根本差异</h2>
<h3 id="81-架构层面对比">8.1 架构层面对比</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>Lit</th>
<th>React</th>
<th>Vue</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心模型</td>
<td>Web Components</td>
<td>VDOM</td>
<td>VDOM + 响应式</td>
</tr>
<tr>
<td>DOM 更新</td>
<td>定点更新</td>
<td>Diff</td>
<td>Diff</td>
</tr>
<tr>
<td>样式隔离</td>
<td>Shadow DOM</td>
<td>CSS-in-JS</td>
<td>Scoped CSS</td>
</tr>
<tr>
<td>运行时</td>
<td>极小</td>
<td>较大</td>
<td>中等</td>
</tr>
<tr>
<td>框架侵入</td>
<td>极低</td>
<td>高</td>
<td>中</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="82-lit-的优势场景">8.2 Lit 的优势场景</h3>
<ul>
<li>组件库（跨框架）</li>
<li>微前端</li>
<li>Design System</li>
<li>嵌入第三方系统</li>
<li>对 bundle size 极敏感场景</li>
</ul>
<hr>
<h3 id="83-lit-的局限">8.3 Lit 的局限</h3>
<ul>
<li>不适合复杂应用状态管理</li>
<li>社区生态不如 React/Vue</li>
<li>对 Web Components 理解有门槛</li>
</ul>
<hr>
<h2 id="九一个关键结论">九、一个关键结论</h2>
<blockquote>
<p><strong>Lit 并不是“下一代前端框架”</strong><br>
<strong>而是“更接近浏览器的组件开发方式”</strong></p>
</blockquote>
<p>它选择相信浏览器，而不是包揽一切。</p>
<hr>
<h2 id="十总结">十、总结</h2>
<ul>
<li>Lit 的架构极度克制</li>
<li>lit-html 是一个“模板驱动的定点更新引擎”</li>
<li>没有 Virtual DOM 是它最重要的设计选择</li>
<li>Web Components 是它真正的护城河</li>
</ul>
<p>如果你需要构建：</p>
<ul>
<li><strong>长期维护的组件库</strong></li>
<li><strong>跨技术栈 UI 组件</strong></li>
<li><strong>低运行时成本的前端模块</strong></li>
</ul>
<p><a href="https://github.com/lit/lit" target="_blank" rel="noopener nofollow">Lit</a> 是一个非常值得深入理解的方案。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03263888888888889" data-date-updated="2025-12-22 11:19">2025-12-22 10:32</span>&nbsp;
<a href="https://www.cnblogs.com/zxlh1529">幼儿园技术家</a>&nbsp;
阅读(<span id="post_view_count">14</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19370741);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19370741', targetLink: 'https://www.cnblogs.com/zxlh1529/p/19370741', title: 'Lit 架构解析：从 Web Components 到 lit-html 的底层原理' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ Minio开始收费了？别慌，这5种免费的分布式文件系统更香！ ]]></title>
    <link>https://www.cnblogs.com/12lisu/p/19380992</link>
    <guid>ac01c3c2bb191f9ab905723fa329616d</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/19380992" title="发布于 2025-12-22 10:11">
    <span role="heading" aria-level="2">Minio开始收费了？别慌，这5种免费的分布式文件系统更香！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>最近，不少技术圈的朋友都在讨论一个话题：<strong>Minio是不是开始收费了？</strong></p>
<p>这背后其实涉及到一个更深刻的问题——开源许可证的商业化边界。</p>
<p>有些小伙伴在工作中可能已经遇到了这样的困惑：公司法务审查后，认为Minio的AGPLv3许可证在商业产品中使用存在风险，要求寻找替代方案。</p>
<p>今天就给大家推荐5种其他开源的分布式文件系统替代方案。</p>
<h2 id="01-minio许可证的罗生门">01 Minio许可证的“罗生门”</h2>
<p>MinIO自2025年10月起实施以下关键变化：</p>
<ul>
<li>停止免费Docker镜像分发‌：社区版不再提供预构建的Docker镜像，用户需从源码自行编译构建。‌</li>
<li>功能限制与移除‌：控制台管理功能被删除，仅保留基础存储能力。‌</li>
<li>社区版文档从官网移除，且不再接受新功能请求。‌‌</li>
</ul>
<p>‌许可证策略收紧‌：从Apache 2.0协议转向AGPLv3许可证，强化对衍生作品的约束，若违反需购买商业授权。‌</p>
<p>首先，让我们明确一点：<strong>Minio的核心产品仍然是开源的，使用AGPLv3许可证</strong>。</p>
<p>但是，这里有几个关键细节需要理解：</p>
<h3 id="agplv3许可证的传染性">AGPLv3许可证的“传染性”</h3>
<p>AGPLv3（GNU Affero通用公共许可证第3版）有一个著名特性：<strong>“网络服务即分发”</strong>。</p>
<p>简单来说，如果你的服务通过网络提供基于AGPLv3代码的功能，那么你必须开源整个服务的源代码。</p>
<pre><code class="language-java">// 假设你基于Minio开发了一个文件管理服务
public class FileManagementService {
    // 这段代码本身可能没问题...
    private MinioClient minioClient;
    
    public void processUserFile(UserFile file) {
        // 但是，如果你的整个服务基于AGPLv3代码
        // 根据严格解释，你可能需要开源整个项目
        minioClient.putObject(...);
        // 更多业务逻辑...
    }
}
</code></pre>
<h3 id="minio的商业化策略">Minio的商业化策略</h3>
<p>Minio公司确实提供了：</p>
<ol>
<li><strong>企业版</strong>：包含更多企业功能（如多站点复制、监控等）</li>
<li><strong>商业许可证</strong>：允许在不开放源代码的情况下使用Minio</li>
</ol>
<p>这使得很多公司面临选择：<strong>是接受AGPLv3的开源要求，还是购买商业许可证？</strong></p>
<h3 id="为什么这很重要">为什么这很重要？</h3>
<p>如果你的公司属于以下情况之一，可能需要重新考虑Minio的使用：</p>
<ul>
<li><strong>SaaS提供商</strong>：通过网络提供服务</li>
<li><strong>专有软件开发商</strong>：不希望开源核心代码</li>
<li><strong>对许可证合规性严格的企业</strong>：有专门的法务审查</li>
</ul>
<p>下面的决策流程图清晰地展示了这一困境：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202512/2238006-20251222100953131-1545189214.png" class="lazyload"></p>
<p><strong>接下来介绍的5个免费替代方案，可能会适合你。</strong></p>
<h2 id="02-seaweedfs极致简单的海量小文件专家">02 SeaweedFS：极致简单的海量小文件专家</h2>
<p>首先介绍的是我个人非常喜欢的<strong>SeaweedFS</strong>。</p>
<p>它最初是为小文件存储优化的，但现在已经成为功能全面的分布式文件系统。</p>
<h3 id="核心优势">核心优势</h3>
<ul>
<li><strong>完全开源</strong>：Apache License 2.0（商业友好）</li>
<li><strong>架构简单</strong>：学习曲线平缓</li>
<li><strong>性能卓越</strong>：特别适合海量小文件场景</li>
<li><strong>S3兼容</strong>：提供完整的S3 API支持</li>
</ul>
<h3 id="部署示例5分钟快速搭建">部署示例：5分钟快速搭建</h3>
<pre><code class="language-bash"># SeaweedFS的部署简单到令人惊讶
# 1. 下载（只有一个二进制文件！）
wget https://github.com/seaweedfs/seaweedfs/releases/download/3.55/linux_amd64.tar.gz
tar -xzf linux_amd64.tar.gz

# 2. 启动主服务器（管理元数据）
./weed master -ip=localhost -port=9333

# 3. 启动存储节点
./weed volume -dir="./data" -max=100 -mserver="localhost:9333" -port=8080

# 就是这么简单！现在你已经有了一个分布式文件系统
</code></pre>
<h3 id="java客户端集成示例">Java客户端集成示例</h3>
<pre><code class="language-java">// SeaweedFS的Java客户端使用示例
public class SeaweedFSExample {
    // SeaweedFS提供S3兼容接口，可以使用标准的AWS SDK
    private AmazonS3 s3Client;
    
    public void init() {
        // 配置连接到SeaweedFS的Filer组件（提供S3接口）
        AWSCredentials credentials = new BasicAWSCredentials(
            "your-access-key",  // SeaweedFS默认无需认证，但可以配置
            "your-secret-key"
        );
        
        s3Client = AmazonS3ClientBuilder.standard()
            .withEndpointConfiguration(
                new AwsClientBuilder.EndpointConfiguration(
                    "http://localhost:8333",  // Filer默认端口
                    "us-east-1"
                )
            )
            .withCredentials(new AWSStaticCredentialsProvider(credentials))
            .withPathStyleAccessEnabled(true)  // SeaweedFS需要此设置
            .build();
    }
    
    // 上传文件到SeaweedFS
    public void uploadFile(String bucketName, String objectKey, File file) {
        // 创建存储桶（如果需要）
        if (!s3Client.doesBucketExistV2(bucketName)) {
            s3Client.createBucket(bucketName);
        }
        
        // 上传文件
        s3Client.putObject(bucketName, objectKey, file);
        
        System.out.println("文件已上传至SeaweedFS");
        System.out.println("下载URL: http://localhost:8333/" + bucketName + "/" + objectKey);
    }
    
    // SeaweedFS特色功能：小文件合并存储
    public void uploadSmallFiles(List&lt;File&gt; smallFiles, String bucketName) {
        // SeaweedFS内部会自动将小文件合并存储
        // 这大大提高了海量小文件的存储效率
        
        for (int i = 0; i &lt; smallFiles.size(); i++) {
            File file = smallFiles.get(i);
            String objectKey = "small-file-" + i + "-" + file.getName();
            s3Client.putObject(bucketName, objectKey, file);
        }
        
        System.out.println("已上传 " + smallFiles.size() + " 个小文件");
        System.out.println("SeaweedFS会自动优化这些文件的存储");
    }
}
</code></pre>
<h3 id="适用场景">适用场景</h3>
<ul>
<li>图片、文档等小文件存储服务</li>
<li>需要快速部署和验证的场景</li>
<li>对S3兼容性有要求的迁移项目</li>
<li>资源有限的团队或环境</li>
</ul>
<p><strong>为什么选择SeaweedFS替代Minio？</strong></p>
<ol>
<li><strong>许可证更友好</strong>：Apache 2.0 vs AGPLv3</li>
<li><strong>部署更简单</strong>：单二进制文件 vs 需要Docker或复杂配置</li>
<li><strong>小文件性能更好</strong>：专门为小文件优化</li>
<li><strong>社区活跃</strong>：持续更新和维护</li>
</ol>
<h2 id="03-garage专注于去中心化的新选择">03 Garage：专注于去中心化的新选择</h2>
<p><strong>Garage</strong>是一个相对较新但非常有潜力的分布式对象存储系统，源自法国国立计算机与自动化研究所（INRIA）。</p>
<h3 id="核心特色">核心特色</h3>
<ul>
<li><strong>完全开源</strong>：Apache License 2.0</li>
<li><strong>去中心化设计</strong>：无单点故障</li>
<li><strong>轻量级</strong>：资源消耗少</li>
<li><strong>兼容S3 API</strong>：完美替代Minio</li>
</ul>
<h3 id="集群部署示例">集群部署示例</h3>
<pre><code class="language-yaml"># docker-compose.yml - 3节点Garage集群
version: '3.8'
services:
  garage1:
    image: dxflrs/garage:v0.9.0
    command: "garage server"
    environment:
      - GARAGE_NODE_NAME=node1
      - GARAGE_RPC_SECRET=my-secret-key
      - GARAGE_BIND_ADDR=0.0.0.0:3901
      - GARAGE_RPC_BIND_ADDR=0.0.0.0:3902
      - GARAGE_REPLICATION_MODE=3
    volumes:
      - ./data/garage1:/var/lib/garage
    ports:
      - "3901:3901"
      - "3902:3902"
      
  garage2:
    image: dxflrs/garage:v0.9.0
    command: "garage server"
    environment:
      - GARAGE_NODE_NAME=node2
      - GARAGE_RPC_SECRET=my-secret-key
      - GARAGE_BIND_ADDR=0.0.0.0:3901
      - GARAGE_RPC_BIND_ADDR=0.0.0.0:3902
      - GARAGE_SEED=garage1:3902
    volumes:
      - ./data/garage2:/var/lib/garage
      
  garage3:
    image: dxflrs/garage:v0.9.0
    command: "garage server"
    environment:
      - GARAGE_NODE_NAME=node3
      - GARAGE_RPC_SECRET=my-secret-key
      - GARAGE_BIND_ADDR=0.0.0.0:3901
      - GARAGE_RPC_BIND_ADDR=0.0.0.0:3902
      - GARAGE_SEED=garage1:3902
    volumes:
      - ./data/garage3:/var/lib/garage
</code></pre>
<h3 id="java集成代码">Java集成代码</h3>
<pre><code>// Garage的Java客户端示例
public class GarageExample {
    // Garage完全兼容S3 API，可以直接使用AWS SDK
    private AmazonS3 garageClient;
    
    public void initGarageConnection() {
        // Garage的配置与Minio非常相似
        AWSCredentials credentials = new BasicAWSCredentials(
            "GK...",  // Garage生成的访问密钥
            "..."     // 对应的秘密密钥
        );
        
        garageClient = AmazonS3ClientBuilder.standard()
            .withEndpointConfiguration(
                new AwsClientBuilder.EndpointConfiguration(
                    "http://localhost:3900",  // Garage的S3 API端口
                    "garage"  // 区域名称可自定义
                )
            )
            .withCredentials(new AWSStaticCredentialsProvider(credentials))
            .withPathStyleAccessEnabled(true)
            .build();
    }
    
    // 创建存储桶并设置策略
    public void createBucketWithPolicy(String bucketName) {
        // 创建存储桶
        garageClient.createBucket(bucketName);
        
        // Garage支持灵活的存储策略配置
        String bucketPolicy = """
        {
            "version": "2012-10-17",
            "statement": [
                {
                    "effect": "Allow",
                    "principal": "*",
                    "action": "s3:GetObject",
                    "resource": "arn:aws:s3:::%s/*"
                }
            ]
        }
        """.formatted(bucketName);
        
        garageClient.setBucketPolicy(bucketName, bucketPolicy);
        
        System.out.println("存储桶创建完成，已设置公开读取策略");
    }
    
    // 上传文件并生成访问URL
    public String uploadAndGenerateUrl(String bucketName, 
                                       String objectKey, 
                                       InputStream inputStream) {
        ObjectMetadata metadata = new ObjectMetadata();
        // 可以在这里设置内容类型等元数据
        metadata.setContentType("application/octet-stream");
        
        PutObjectRequest request = new PutObjectRequest(
            bucketName, objectKey, inputStream, metadata
        );
        
        garageClient.putObject(request);
        
        // 生成预签名URL（Garage支持此功能）
        java.util.Date expiration = new java.util.Date();
        long expTimeMillis = expiration.getTime();
        expTimeMillis += 1000 * 60 * 60; // 1小时有效期
        expiration.setTime(expTimeMillis);
        
        GeneratePresignedUrlRequest generatePresignedUrlRequest = 
            new GeneratePresignedUrlRequest(bucketName, objectKey)
                .withMethod(HttpMethod.GET)
                .withExpiration(expiration);
        
        return garageClient.generatePresignedUrl(
            generatePresignedUrlRequest).toString();
    }
}
</code></pre>
<h3 id="适用场景-1">适用场景</h3>
<ul>
<li>去中心化应用或区块链项目</li>
<li>需要轻量级对象存储的场景</li>
<li>研究或教育项目</li>
<li>对新兴技术有兴趣的团队</li>
</ul>
<h2 id="04-ceph企业级的全能开源方案">04 Ceph：企业级的全能开源方案</h2>
<p><strong>Ceph</strong>是最知名、功能最全面的开源分布式存储系统之一。</p>
<p>虽然它比Minio复杂得多，但也强大得多。</p>
<h3 id="为什么ceph是真正的免费">为什么Ceph是真正的免费？</h3>
<ul>
<li><strong>开源许可证</strong>：LGPL（较GPL更宽松）</li>
<li><strong>社区驱动</strong>：由Red Hat支持但社区主导</li>
<li><strong>无商业限制</strong>：可以自由用于商业产品</li>
</ul>
<h3 id="部署架构">部署架构</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202512/2238006-20251222101020635-2090096718.png" class="lazyload"></p>
<h3 id="java客户端操作ceph">Java客户端操作Ceph</h3>
<pre><code class="language-java">// 使用Ceph的S3兼容接口（RADOSGW）
public class CephExample {
    private AmazonS3 cephClient;
    
    public void initCephConnection() {
        // Ceph通过RADOSGW提供S3兼容接口
        // 配置方式与AWS S3几乎完全相同
        AWSCredentials credentials = new BasicAWSCredentials(
            System.getenv("CEPH_ACCESS_KEY"),
            System.getenv("CEPH_SECRET_KEY")
        );
        
        cephClient = AmazonS3ClientBuilder.standard()
            .withCredentials(new AWSStaticCredentialsProvider(credentials))
            .withEndpointConfiguration(
                new AwsClientBuilder.EndpointConfiguration(
                    "http://ceph-gateway.example.com:7480",
                    ""  // Ceph可以不指定区域
                )
            )
            .withPathStyleAccessEnabled(true)
            .build();
    }
    
    // Ceph的高级特性：多部分上传
    public void uploadLargeFileToCeph(String bucketName, 
                                      String objectKey, 
                                      File largeFile) 
                                      throws Exception {
        
        // 初始化多部分上传
        InitiateMultipartUploadRequest initRequest = 
            new InitiateMultipartUploadRequest(bucketName, objectKey);
        InitiateMultipartUploadResult initResponse = 
            cephClient.initiateMultipartUpload(initRequest);
        String uploadId = initResponse.getUploadId();
        
        // 分片上传（Ceph可以处理非常大的文件）
        long fileSize = largeFile.length();
        long partSize = 100 * 1024 * 1024; // 100MB分片
        long bytePosition = 0;
        List&lt;PartETag&gt; partETags = new ArrayList&lt;&gt;();
        int partNumber = 1;
        
        try (FileInputStream fis = new FileInputStream(largeFile)) {
            while (bytePosition &lt; fileSize) {
                long currentPartSize = Math.min(partSize, fileSize - bytePosition);
                
                UploadPartRequest uploadRequest = new UploadPartRequest()
                    .withBucketName(bucketName)
                    .withKey(objectKey)
                    .withUploadId(uploadId)
                    .withPartNumber(partNumber)
                    .withInputStream(fis)
                    .withPartSize(currentPartSize);
                
                UploadPartResult uploadResult = cephClient.uploadPart(uploadRequest);
                partETags.add(uploadResult.getPartETag());
                
                bytePosition += currentPartSize;
                partNumber++;
            }
            
            // 完成上传
            CompleteMultipartUploadRequest compRequest = 
                new CompleteMultipartUploadRequest(
                    bucketName, objectKey, uploadId, partETags);
            cephClient.completeMultipartUpload(compRequest);
            
        } catch (Exception e) {
            // 发生错误时中止上传
            cephClient.abortMultipartUpload(
                new AbortMultipartUploadRequest(bucketName, objectKey, uploadId));
            throw e;
        }
    }
    
    // Ceph特有的功能：获取存储使用情况
    public void checkCephUsage() {
        // 注意：Ceph不通过S3 API提供使用统计
        // 需要通过管理API或命令行获取
        System.out.println("Ceph使用统计需通过以下方式获取：");
        System.out.println("1. 命令行: ceph df");
        System.out.println("2. 管理API: /api/auth");
        System.out.println("3. Dashboard: 内置Web界面");
    }
}
</code></pre>
<h3 id="适用场景-2">适用场景</h3>
<ul>
<li>大型企业存储需求</li>
<li>需要同时支持对象、块和文件存储</li>
<li>已经有一定运维能力的团队</li>
<li>对可靠性和扩展性要求极高的场景</li>
</ul>
<h2 id="05-glusterfs简单可靠的横向扩展文件系统">05 GlusterFS：简单可靠的横向扩展文件系统</h2>
<p><strong>GlusterFS</strong>是一个开源的分布式横向扩展文件系统，特别适合需要POSIX文件系统语义的场景。</p>
<h3 id="核心优势-1">核心优势</h3>
<ul>
<li><strong>开源许可证</strong>：GPLv3（但无AGPL的网络服务条款）</li>
<li><strong>无元数据服务器</strong>：独特的无中心架构</li>
<li><strong>部署简单</strong>：易于理解和维护</li>
<li><strong>成熟稳定</strong>：经过多年生产验证</li>
</ul>
<h3 id="快速部署脚本">快速部署脚本</h3>
<pre><code class="language-bash">#!/bin/bash
# GlusterFS 3节点集群快速部署脚本

# 在三个节点上执行类似命令
# 节点1:
gluster peer probe node2
gluster peer probe node3

# 创建分布式卷（数据分散在所有节点）
gluster volume create gv0 disperse 3 node1:/data/brick1 node2:/data/brick1 node3:/data/brick1

# 或创建复制卷（数据在所有节点复制）
gluster volume create gv1 replica 3 node1:/data/brick2 node2:/data/brick2 node3:/data/brick2

# 启动卷
gluster volume start gv0
gluster volume start gv1

# 在客户端挂载
mount -t glusterfs node1:/gv0 /mnt/glusterfs
</code></pre>
<h3 id="java中使用glusterfs">Java中使用GlusterFS</h3>
<pre><code class="language-java">// 通过标准的Java文件API访问GlusterFS
public class GlusterFSExample {
    private Path glusterMountPoint;
    
    public GlusterFSExample(String mountPath) {
        this.glusterMountPoint = Paths.get(mountPath);
        
        // 验证挂载点
        if (!Files.exists(glusterMountPoint)) {
            throw new IllegalArgumentException("GlusterFS挂载点不存在: " + mountPath);
        }
        
        System.out.println("GlusterFS挂载点: " + mountPoint.toAbsolutePath());
    }
    
    // 写入文件 - GlusterFS自动处理数据分布
    public void writeFile(String filename, String content) throws IOException {
        Path filePath = glusterMountPoint.resolve(filename);
        
        // 创建父目录（如果需要）
        if (filePath.getParent() != null) {
            Files.createDirectories(filePath.getParent());
        }
        
        // 写入文件
        Files.write(filePath, 
                   content.getBytes(StandardCharsets.UTF_8),
                   StandardOpenOption.CREATE,
                   StandardOpenOption.WRITE,
                   StandardOpenOption.TRUNCATE_EXISTING);
        
        System.out.println("文件已写入GlusterFS: " + filePath);
    }
    
    // 读取文件
    public String readFile(String filename) throws IOException {
        Path filePath = glusterMountPoint.resolve(filename);
        
        if (Files.exists(filePath)) {
            byte[] content = Files.readAllBytes(filePath);
            return new String(content, StandardCharsets.UTF_8);
        }
        
        return null;
    }
    
    // 列出目录内容
    public List&lt;String&gt; listFiles(String directory) throws IOException {
        Path dirPath = glusterMountPoint.resolve(directory);
        
        if (Files.exists(dirPath) &amp;&amp; Files.isDirectory(dirPath)) {
            try (Stream&lt;Path&gt; stream = Files.list(dirPath)) {
                return stream
                    .filter(Files::isRegularFile)
                    .map(Path::getFileName)
                    .map(Path::toString)
                    .collect(Collectors.toList());
            }
        }
        
        return Collections.emptyList();
    }
    
    // 获取文件信息
    public void printFileInfo(String filename) throws IOException {
        Path filePath = glusterMountPoint.resolve(filename);
        
        if (Files.exists(filePath)) {
            BasicFileAttributes attrs = Files.readAttributes(
                filePath, BasicFileAttributes.class);
            
            System.out.println("文件: " + filename);
            System.out.println("大小: " + attrs.size() + " 字节");
            System.out.println("创建时间: " + attrs.creationTime());
            System.out.println("修改时间: " + attrs.lastModifiedTime());
            System.out.println("访问时间: " + attrs.lastAccessTime());
        }
    }
}
</code></pre>
<h3 id="适用场景-3">适用场景</h3>
<ul>
<li>需要标准文件系统接口的应用</li>
<li>媒体处理、日志存储等场景</li>
<li>已有大量基于文件API的遗留系统</li>
<li>希望避免学习新API的团队</li>
</ul>
<h2 id="06-openstack-swift企业级对象存储标准">06 OpenStack Swift：企业级对象存储标准</h2>
<p><strong>OpenStack Swift</strong>是OpenStack生态中的对象存储组件，是一个完全开源、高度可扩展的对象存储系统。</p>
<h3 id="开源承诺">开源承诺</h3>
<ul>
<li><strong>完全开源</strong>：Apache License 2.0</li>
<li><strong>社区治理</strong>：由OpenStack基金会管理</li>
<li><strong>无商业限制</strong>：真正的自由使用</li>
</ul>
<h3 id="swift集群架构">Swift集群架构</h3>
<pre><code class="language-python"># 简化的Swift集群配置示例
# swift.conf - 主要配置文件
[swift-hash]
# 随机hash种子，集群中所有节点必须相同
swift_hash_path_prefix = changeme
swift_hash_path_suffix = changeme

[storage-policy:0]
name = Policy-0
default = yes

# ring文件 - 数据分布配置
# 使用swift-ring-builder工具管理
$ swift-ring-builder account.builder create 10 3 24
$ swift-ring-builder container.builder create 10 3 24
$ swift-ring-builder object.builder create 10 3 24

# 添加存储节点
$ swift-ring-builder object.builder add r1z1-127.0.0.1:6010/sdb1 100
$ swift-ring-builder object.builder rebalance
</code></pre>
<h3 id="java客户端示例">Java客户端示例</h3>
<pre><code class="language-java">// 使用jclouds库访问OpenStack Swift
public class SwiftExample {
    private BlobStore blobStore;
    
    public void initSwiftConnection() {
        // 配置Swift连接
        Properties overrides = new Properties();
        overrides.setProperty("jclouds.swift.auth.version", "3");
        
        // Swift支持多种认证方式
        SwiftApi swiftApi = ContextBuilder.newBuilder("openstack-swift")
            .endpoint("http://swift.example.com:5000/v3")
            .credentials("project:username", "password")
            .overrides(overrides)
            .buildApi(SwiftApi.class);
        
        blobStore = swiftApi.getBlobStore("RegionOne");
    }
    
    // 上传对象到Swift
    public String uploadToSwift(String containerName, 
                                String objectName, 
                                InputStream data, 
                                long size) {
        
        // 确保容器存在
        if (!blobStore.containerExists(containerName)) {
            blobStore.createContainerInLocation(null, containerName);
        }
        
        // 创建Blob对象
        Blob blob = blobStore.blobBuilder(objectName)
            .payload(data)
            .contentLength(size)
            .contentType("application/octet-stream")
            .build();
        
        // 上传
        String etag = blobStore.putBlob(containerName, blob);
        
        System.out.println("对象上传成功，ETag: " + etag);
        
        // 生成临时URL（Swift支持此功能）
        return generateTempUrl(containerName, objectName);
    }
    
    private String generateTempUrl(String container, String object) {
        // Swift支持通过临时URL共享对象
        // 这里需要Swift集群配置了临时URL密钥
        long expires = System.currentTimeMillis() / 1000 + 3600; // 1小时后过期
        
        // 临时URL生成逻辑（实际实现更复杂）
        return String.format(
            "http://swift.example.com:8080/v1/AUTH_%s/%s/%s?temp_url_sig=xxx&amp;temp_url_expires=%d",
            "account", container, object, expires
        );
    }
    
    // 大对象分片上传（Swift称为"静态大对象"）
    public void uploadLargeObject(String container, 
                                  String objectName, 
                                  List&lt;File&gt; segments) {
        
        // 上传所有分片
        List&lt;String&gt; segmentPaths = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; segments.size(); i++) {
            String segmentName = String.format("%s/%08d", objectName, i);
            try (InputStream is = new FileInputStream(segments.get(i))) {
                uploadToSwift(container, segmentName, is, segments.get(i).length());
                segmentPaths.add(String.format("/%s/%s", container, segmentName));
            } catch (IOException e) {
                throw new RuntimeException("分片上传失败", e);
            }
        }
        
        // 创建清单文件
        String manifest = String.join("\n", segmentPaths);
        try (InputStream is = new ByteArrayInputStream(manifest.getBytes())) {
            blobStore.putBlob(container, 
                blobStore.blobBuilder(objectName)
                    .payload(is)
                    .contentLength(manifest.length())
                    .contentType("text/plain")
                    .build());
        } catch (IOException e) {
            throw new RuntimeException("清单文件创建失败", e);
        }
        
        System.out.println("大对象上传完成，共 " + segments.size() + " 个分片");
    }
}
</code></pre>
<h3 id="适用场景-4">适用场景</h3>
<ul>
<li>OpenStack云环境</li>
<li>需要高持久性保证的企业应用</li>
<li>多地域复制需求</li>
<li>已有OpenStack基础设施的团队</li>
</ul>
<h2 id="07-综合对比与选型指南">07 综合对比与选型指南</h2>
<p>现在我们已经了解了5个Minio的免费替代方案。</p>
<p>如何选择最适合你的那个？</p>
<p>下面的对比表格和决策指南可以帮助你：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202512/2238006-20251222101045370-1386142031.png" class="lazyload"></p>
<h3 id="详细对比表">详细对比表</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>SeaweedFS</th>
<th>Garage</th>
<th>Ceph</th>
<th>GlusterFS</th>
<th>OpenStack Swift</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>许可证</strong></td>
<td>Apache 2.0</td>
<td>Apache 2.0</td>
<td>LGPL</td>
<td>GPLv3</td>
<td>Apache 2.0</td>
</tr>
<tr>
<td><strong>部署复杂度</strong></td>
<td>⭐☆☆☆☆ (极简)</td>
<td>⭐⭐☆☆☆ (简单)</td>
<td>⭐⭐⭐⭐⭐ (复杂)</td>
<td>⭐⭐⭐☆☆ (中等)</td>
<td>⭐⭐⭐⭐☆ (较复杂)</td>
</tr>
<tr>
<td><strong>S3兼容性</strong></td>
<td>完全兼容</td>
<td>完全兼容</td>
<td>通过RADOSGW</td>
<td>通过第三方</td>
<td>原生支持</td>
</tr>
<tr>
<td><strong>文件系统支持</strong></td>
<td>有限</td>
<td>无</td>
<td>CephFS</td>
<td>原生POSIX</td>
<td>无</td>
</tr>
<tr>
<td><strong>适用规模</strong></td>
<td>中小规模</td>
<td>中小规模</td>
<td>超大规模</td>
<td>中大规模</td>
<td>大规模</td>
</tr>
<tr>
<td><strong>小文件性能</strong></td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐⭐☆☆</td>
<td>⭐⭐⭐☆☆</td>
<td>⭐⭐☆☆☆</td>
<td>⭐⭐⭐⭐☆</td>
</tr>
<tr>
<td><strong>大文件性能</strong></td>
<td>⭐⭐⭐☆☆</td>
<td>⭐⭐⭐⭐☆</td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐☆</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>运维要求</strong></td>
<td>低</td>
<td>低</td>
<td>高</td>
<td>中</td>
<td>中高</td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2>
<p>有些小伙伴在工作中可能会因为Minio的许可证变化而感到焦虑，但实际上，开源世界给了我们丰富的选择。</p>
<p>关键是要根据你的具体需求做出明智的决策：</p>
<ol>
<li>
<p><strong>如果你是小型团队或创业公司</strong>，需要快速部署且主要处理小文件，<strong>SeaweedFS</strong>是最佳选择。</p>
</li>
<li>
<p><strong>如果你在构建去中心化应用</strong>或需要极简架构，<strong>Garage</strong>值得考虑。</p>
</li>
<li>
<p><strong>如果你有企业级需求</strong>，需要同时支持对象、块和文件存储，<strong>Ceph</strong>是行业标准。</p>
</li>
<li>
<p><strong>如果你需要标准的文件系统接口</strong>，并且希望迁移简单，<strong>GlusterFS</strong>非常合适。</p>
</li>
<li>
<p><strong>如果你已经在OpenStack环境中</strong>或需要企业级对象存储，<strong>OpenStack Swift</strong>是最佳选择。</p>
</li>
</ol>
<p><strong>记住，技术选型的核心原则是：没有最好的系统，只有最适合的系统</strong>。</p>
<p>许可证只是考量的一个方面，你还需要考虑性能需求、团队技能、运维成本等多个因素。</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<p>更多项目实战在我的技术网站：<a href="http://www.susan.net.cn/project" target="_blank" rel="noopener nofollow">http://www.susan.net.cn/project</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-12-22 10:11">2025-12-22 10:11</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">349</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19380992);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19380992', targetLink: 'https://www.cnblogs.com/12lisu/p/19380992', title: 'Minio开始收费了？别慌，这5种免费的分布式文件系统更香！' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ AI 结对编程：如何让 AI 跳出死循环？ ]]></title>
    <link>https://www.cnblogs.com/guangzan/p/19380737</link>
    <guid>783729021538dbbf2b4365ff1378cf96</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/guangzan/p/19380737" title="发布于 2025-12-22 09:13">
    <span role="heading" aria-level="2">AI 结对编程：如何让 AI 跳出死循环？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="问题背景">问题背景</h2>
<p>在一次开发过程中，遇到了一个典型但又颇具迷惑性的渲染问题：Markdown 表格的行分割线在 Xcode 预览中正常显示，但在运行时完全消失。</p>
<p><img src="https://img2024.cnblogs.com/blog/1501373/202512/1501373-20251220234255623-652241356.png" alt="image" width="903" height="302" loading="lazy"></p>
<p>代码块中的代码内容在 Xcode 预览中正常显示，但在运行时完全消失。</p>
<p><img src="https://img2024.cnblogs.com/blog/1501373/202512/1501373-20251220234308601-1880066633.png" alt="image" width="630" height="394" loading="lazy"></p>
<p>这类问题通常与运行环境差异、渲染上下文或视图修饰符有关。接下来，我记录了自己与 AI 结对编程、一步步定位并解决问题的过程。</p>
<h2 id="问题分析过程">问题分析过程</h2>
<p>我并没有一开始就把两个现象同时抛给 AI。原因很简单，第二个问题（代码块消失）涉及的代码更复杂，极容易把 AI 带进错误方向。</p>
<p>直觉告诉我，这两个现象很可能是同一个根因的不同表现。因此，我选择先挑一个“看起来更简单”的现象：表格分割线消失，作为切入点，让 AI 先集中精力解决一个问题。</p>
<h3 id="第一阶段错误的假设">第一阶段：错误的假设</h3>
<p>AI 的第一反应非常“教科书式”，它将注意力放在了表格样式配置上：</p>
<pre><code class="language-swift">// Theme+Zane.swift
.table { configuration in
  configuration.label
    .fixedSize(horizontal: false, vertical: true)
    .markdownTableBorderStyle(.init(.horizontalBorders, color: .grid))
    .markdownMargin(top: .em(1.6), bottom: .zero)
}
</code></pre>
<p>它提出了几个假设：</p>
<ol>
<li>颜色 <code>.grid</code> 在运行时未正确解析</li>
<li>MarkdownUI 的边框样式在运行时未正确应用</li>
<li>环境变量（colorScheme）未正确传递</li>
</ol>
<p>这些假设看起来合理，但都隐含着一个前提：问题一定出在 Markdown 样式本身。</p>
<h3 id="第二阶段调试验证">第二阶段：调试验证</h3>
<p>为了验证这些假设，我按 AI 的建议加入了一些调试代码：</p>
<pre><code class="language-swift">// 打印 colorScheme 值
.onAppear {
    print("colorScheme: \(colorScheme == .dark ? "dark" : "light")")
}

// 临时改为红色验证
.markdownTableBorderStyle(.init(.horizontalBorders, color: .red))
</code></pre>
<p>结果非常明确：</p>
<ul>
<li>Xcode 预览：红色边框可见</li>
<li>实际运行：依然不可见</li>
<li>colorScheme 值正常</li>
</ul>
<p>这一步基本可以确认：</p>
<ul>
<li>MarkdownUI 的样式机制是生效的</li>
<li>边框颜色、主题配置本身没有问题</li>
<li>问题只存在于运行时渲染环境</li>
</ul>
<h3 id="第三阶段陷入死循环重复多次">第三阶段：陷入死循环（重复多次）</h3>
<p>我明确向 AI 反馈：</p>
<blockquote>
<p>MarkdownUI 和自定义主题之前一直正常，现在才出问题，说明根因很可能不在这里，请从其他方向排查。</p>
</blockquote>
<p>但 AI 并没有真正“换脑子”，而是开始在同一条错误路径上反复尝试：</p>
<ul>
<li>修改 <code>.grid</code> 颜色定义</li>
<li>改用系统颜色</li>
<li>调整边框样式配置</li>
<li>在 <code>tableCell</code> 中添加 overlay</li>
</ul>
<p>这正是 AI 结对编程中最常见的问题之一在错误假设下不断做局部优化，形成思维死循环。</p>
<h3 id="第四阶段跳出循环">第四阶段：跳出循环</h3>
<p>我不得不更明确、甚至有点“强硬”地约束 AI：</p>
<blockquote>
<p>MarkdownUI 和 MarkdownView 本身没有问题。禁止再修改任何 Markdown 相关代码。从其他方向重新排查。</p>
</blockquote>
<p>这一次，AI 才真正开始切换视角，把注意力转向：</p>
<ol>
<li><code>MarkdownView</code> 的修饰符</li>
<li>父视图的布局容器</li>
<li>父级容器滚动视图配置</li>
</ol>
<p>最终，问题定位到了这一段代码：</p>
<pre><code class="language-swift">LazyVStack(alignment: .leading, spacing: 16) {
    // ...
}
.padding()
.drawingGroup()  // ← 问题根源
.transaction { transaction in
    transaction.animation = nil
}
</code></pre>
<p>当我移除 .drawingGroup() 后：表格分割线恢复显示，代码块内容也一并正常了！</p>
<p>为什么 <code>.drawingGroup()</code> 会导致问题？<code>.drawingGroup()</code> 将视图内容合成到离屏渲染层，用于性能优化。但这个过程可能影响细线渲染：</p>
<ol>
<li>合成精度：细线（1px）在合成时可能被抗锯齿或采样影响</li>
<li>渲染上下文：离屏渲染与直接渲染的上下文不同</li>
<li>颜色混合：合成过程中的颜色混合可能使浅色边框变淡或消失</li>
</ol>
<h2 id="关于-ai-结对编程的思考">关于 AI 结对编程的思考</h2>
<p>AI 在结对编程中并不是“不会解决问题”，而是很容易在错误前提下持续消耗时间。</p>
<p>AI 高度依赖模式匹配。一旦问题被归类为“表格渲染异常”，它就会自然地把注意力集中在样式、颜色、主题等常见因素上，而对“之前一直正常、最近才出问题”这类时间线线索不够敏感。当初始假设没有被及时推翻时，AI 往往会在同一方向上不断微调，形成事实上的思维死循环。</p>
<p>要让 AI 跳出这种状态，关键并不是提供更多细节，而是强制改变它的分析边界。明确指出当前方向可能是错的、强调哪些部分已经被确认没有问题，甚至直接禁止继续修改某类代码，反而能显著提升排查效率。一旦分析范围被重新划定，AI 才会开始关注父视图、修饰符链或最近的改动这些更有价值的线索。</p>
<p>这也决定了 AI 结对编程的合理分工方式。人类负责判断方向、提供上下文和时间线；AI 负责搜索、枚举和验证可能性。当人类不主动介入纠偏时，AI 很容易在“看似合理”的路径上反复打磨，却始终无法触及根因。</p>
<p>最终，这次问题能够被定位到 <code>.drawingGroup()</code> ，并不是因为 AI 突然变得更聪明，而是因为分析视角发生了改变。这也提醒我，在与 AI 协作调试时，比“如何写代码”更重要的，是如何约束和引导它的思考方式。有时候，问题不在你盯着的地方，而在你忽略的地方。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-12-22 09:13">2025-12-22 09:13</span>&nbsp;
<a href="https://www.cnblogs.com/guangzan">guangzan</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19380737);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19380737', targetLink: 'https://www.cnblogs.com/guangzan/p/19380737', title: 'AI 结对编程：如何让 AI 跳出死循环？' })">举报</a>
</div>
         ]]>
    </description>
    </item>
        </channel>
        </rss>