<?xml version="1.0" encoding="UTF-8" ?>
    <rss version="2.0">
    <channel>
        <title><![CDATA[ 主页 - 博客园 ]]></title>
        <link><![CDATA[ https://www.cnblogs.com/ ]]></link>
        <lastBuildDate>2025-12-22T18:24:53.729Z</lastBuildDate>
        <description><![CDATA[
        主页 - 博客园 RSS
    ]]></description>
        <language>zh-cn</language>
        <item>
    <title><![CDATA[ 化整为零、分而治之、异步编排：一文读懂现代并发的底层心法 ]]></title>
    <link>https://www.cnblogs.com/poemyang/p/19384431</link>
    <guid>705b50635a578b80efd5de08849cf652</guid>
    <description>
    <![CDATA[ 
        <h2 class="post-title">
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/poemyang/p/19384431" title="发布于 2025-12-22 21:34">
    <span role="heading" aria-level="2">化整为零、分而治之、异步编排：一文读懂现代并发的底层心法</span>
    

</a>

        </h2>
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><strong>LongAdder：化整为零，热点分散</strong><br>
在Java多线程编程中，‌原子变量（如AtomicLong）‌通过CAS操作实现线程安全的累加。然而，在高并发场景下，大量线程争抢同一原子变量会引发严重的‌缓存一致性问题‌。<br>
‌ 1）缓存行伪共享‌：多个线程频繁更新同一缓存行，导致缓存失效和MESI协议频繁触发，处理器性能急剧下降。<br>
‌ 2）CAS冲突开销‌：CAS操作需自旋重试，线程竞争激烈时重试次数增加，进一步拖慢性能。<br>
为解决上述瓶颈，Java 8引入了‌LongAdder‌，其核心思想是‌“分散竞争，延迟求和‌”。<br>
‌ 1）分段累加‌：将单一累加变量拆分为多个‌分段变量（cells）‌，每个线程仅更新其专属的分段，避免全局竞争。<br>
‌ 2）基础值优化‌：在低并发场景下，直接更新基础值（base），减少分段数组的开销。<br>
‌ 3）最终一致性求和‌：通过遍历所有分段和基础值，延迟计算总和，降低实时竞争压力。<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/757914/202512/757914-20251222213334386-1756695412.png" class="lazyload"></p>
<p>LongAdder的内部实现原理，可以用下面的伪代码演示。</p>
<pre><code class="language-java">public class LongAdder {
    private final AtomicLong[] cells; // 分段数组，每个线程映射到特定分段
    private final AtomicLong base;    // 基础值，低并发时直接更新

    public LongAdder() {
        cells = new AtomicLong[16]; // 假设初始化16个分段
        for (int i = 0; i &lt; cells.length; i++) {
            cells[i] = new AtomicLong(0); // 初始化分段值为0
        }
        base = new AtomicLong(0); // 初始化基础值为0
    }

    public void add(long x) {
        // 1. 计算线程对应的分段索引（简单取模实现）
        int index = (int) (Thread.currentThread().getId() % cells.length);
        // 2. 对专属分段执行CAS累加，避免全局竞争
        cells[index].addAndGet(x);
    }

    public long sum() {
        // 3. 求和：累加基础值和所有分段值
        long sum = base.get();
        for (AtomicLong cell : cells) {
            sum += cell.get();
        }
        return sum;
    }
}
</code></pre>
<p>然而，LongAdder 并非万能钥匙。在并发度较低的场景，AtomicLong 的简单直接反而更高效，就好比小型聚会中，大家直接共享一个果盘更方便，而不需要多个果篮。另外，当需要频繁读取累计结果时，LongAdder 的汇总过程就像逐个篮子统计水果数量，略显繁琐，性能会受影响。Fork/Join：分而治之，任务窃取<br>
Java 7 引入的 ‌Fork/Join Framework‌ 是一种强大的并行编程模型，专为解决“分而治之”（Divide and Conquer）类型的问题而设计。它充分利用多核处理器的计算能力，通过分解任务、并行执行和合并结果，显著提升程序的执行效率。<br>
Fork/Join特别适合处理可以被分解成独立子任务的问题，以实现任务的并行执行，如排序、搜索等。<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/757914/202512/757914-20251222213344110-564578910.png" class="lazyload"></p>
<pre><code class="language-java">if (任务足够小) {
    直接计算并返回结果;
} else {
    将任务拆分为N个子任务;
    对每个子任务调用 fork() 进行并行计算;
    调用 join() 合并子任务的结果;
    返回最终结果;
}
</code></pre>
<p>在Java 8中引入的并行流计算（Parallel stream computing），内部就是采用的ForkJoinPool来实现的。例如，下面使用并行流实现数组并行求和计算。</p>
<pre><code class="language-java">public class SumArray {
    public static void main(String[] args) {
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
         // map在实际编程中，可以是耗时高，计算量大的任务
        int sum = numbers.parallelStream().map(i -&gt; i * i).reduce(0, Integer::sum);
    }
}
</code></pre>
<p><strong>并行编程模型</strong><br>
并行编程模型（Parallel programming model）是一种用于描述和组织并行计算的框架或范式。它提供了一组抽象概念、编程接口和规范，用于指导开发者在多核处理器、分布式系统或并行计算环境中编写并行程序。<br>
常见的并行编程模型包括：数据并行（Data parallelism）、任务并行（Task parallelism）、多线程并行（Multithread parallelism）等。工作窃取<br>
工作窃取（Work Stealing）是一种高效的并行计算调度策略，其主要目标是解决负载不均衡问题，以充分利用所有的处理器核心，从而提升程序的执行效率。<br>
在工作窃取模型中，每个处理器都维护着自己的双端队列（Deque），用于存储分配给自己的任务。当一个处理器完成了所有自己的任务后，它会尝试从其他处理器的任务队列的末尾“窃取”任务来执行。这种策略确保了所有的处理器都能尽可能地保持忙碌状态，从而提高整体的并行性能。<br>
工作窃取策略的一个显著优点是其能够动态地平衡负载。这意味着它能够适应各种不同的任务分布和处理器性能，从而在各种情况下都能提供优秀的性能。<br>
在实际编程实践中，工作窃取调度策略通常由并行编程框架或库来实现。例如，Java的Fork/Join框架就采用了工作窃取策略来动态地分配任务，C++的Intel TBB（Threading Building Blocks）库也使用了类似的策略。<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/757914/202512/757914-20251222213355165-1177992061.png" class="lazyload"></p>
<p><strong>CompletableFuture：构建优雅的异步流水线</strong><br>
CompletableFuture 是 Java 8 引入的一个核心类，它实现了 Future 接口，并在其基础上提供了更强大、更灵活的异步编程能力。与传统的 Future 相比，CompletableFuture 不仅能够表示一个异步计算的结果，还支持丰富的函数式编程特性，使得开发者能够以声明式的方式处理异步任务的执行流程。<br>
CompletableFuture 的核心优势在于其支持链式调用（Chaining），允许在一个 CompletableFuture 上附加多个操作（如转换结果、处理异常、组合多个任务等）。这些操作会在 CompletableFuture 完成时自动触发，从而形成一个流水线式的任务处理流程。<br>
‌ 以下是一个简单的示例，展示了 ‌CompletableFuture‌ 的链式调用。</p>
<pre><code class="language-java">// supplyAsync方法用于启动一个异步任务，thenApply方法用于在任务完成时对结果进行转换
CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
     ......
    // 异步任务，模拟网络请求
    return "Hello";
}).thenApply(result -&gt; {
    // 对结果进行转换
    return result + " World";
});
// 主线程等待异步操作完成
future.join();
// 获取异步执行结果
future.get();
</code></pre>
<p><strong>异步编程</strong><br>
异步编程是一种高效的编程范式，旨在优化程序的执行效率和资源利用率。它通过允许程序在等待耗时操作（如网络请求、文件I/O等）完成的同时，继续执行其他任务，从而避免了传统同步编程中的线程阻塞问题。这种非阻塞的执行方式显著提升了程序的响应速度和并发处理能力，尤其适用于I/O密集型任务。<br>
在传统的同步编程模型中，当一个操作需要较长时间完成时，程序会停滞在该操作上，直到操作结束，这种现象称为阻塞。相比之下，异步编程模型允许程序在启动一个耗时操作后，立即转而执行其他任务，而无需等待该操作完成。当操作完成后，程序会通过回调、事件或Future等机制收到通知，并处理操作结果。<br>
异步编程在多种编程语言中都有应用和实现。例如，Java中的CompletableFuture、JavaScript中的Promise，以及Python中的asyncio库等，都提供了强大的异步编程支持。<br>
以下是一个简单的同步与异步读取文件的对比示例（伪代码）。</p>
<pre><code class="language-java">// 同步执行读取文件操作
let a = read("a.txt");
// 同步等待上次一次文件操作完成
let b = read("b.txt");
// 假设单个文件读取耗时50ms，一共需要耗时100ms
print(a+b)

// 异步执行读取文件操作
let op_a = read_async("a.txt");
let op_b = read_async("b.txt");
let a = wait_until_get_ready(op_a);
let b = wait_until_get_ready(op_b);
// 假设单个文件读取耗时50ms， 由于两次读取文件操作同时异步执行，最终耗时50ms
print(a+b);

fn wait_until_get_ready(Operation) -&gt; Response {
  // 阻塞任务，挂起线程，直到operation就绪再唤醒线程（唤醒操作，需要操作系统和硬件的底层支撑）
}
</code></pre>
<p>异步编程可以更有效地处理并发问题。当程序需要同时处理多个任务时，异步编程可以让这些任务并发执行，而不是按顺序一个接一个地执行。然而，异步编程的实现离不开操作系统和硬件的底层支持。如果在异步任务执行完之前，处理线程一直对异步任务执行状态进行空轮询，这将会浪费处理器资源。因此，操作系统和硬件的底层支持，如Linux系统支持的select、poll、epoll等技术，对于异步编程的实现至关重要。<br>
以下是一个没有底层支持时，异步编程可能面临的问题的示例（伪代码）。</p>
<pre><code class="language-java">let op_a = read_async("a.txt");
let a = "";
// 如果没有操作系统和硬件的底层支撑，将不断轮询op_a的任务状态
while true {
  if op_a.is_finish() {
    a = op_a.get_content();
    break;
  }
}
print(a);
</code></pre>
<p><strong>链式调用</strong><br>
“回调地狱”（Callback Hell）是异步编程中常见的一个问题，尤其在 JavaScript 等单线程、事件驱动型语言中尤为突出。当多个异步操作需要按照特定顺序执行时，开发者可能不得不在一个回调函数中嵌套另一个回调函数，导致代码层级过深、可读性差、难以维护。<br>
以下是一个典型的“回调地狱”示例（JavaScript）。</p>
<pre><code class="language-java">login(user =&gt; {
    getStatus(status =&gt; {
        getOrder(order =&gt; {
            getPayment(payment =&gt; {
                getRecommendAdvertisements(ads =&gt; {
                    setTimeout(() =&gt; {
                        alert(ads)
                    }, 1000)
                })
            })
        })
    })
})
</code></pre>
<p>链式调用（Chaining）成为一种常用的优化手段。在 JavaScript 中，‌Promise‌ 机制提供了链式调用的能力。每个 ‌Promise‌ 对象都包含一个 ‌then‌ 方法，该方法返回一个新的 ‌Promise‌ 对象，从而允许开发者将多个异步操作串联起来，形成清晰的逻辑流。<br>
以下是一个使用 ‌Promise‌ 链式调用的示例（JavaScript）。</p>
<pre><code class="language-java">login(username, password)
    .then(user =&gt; getStatus(user.id))
    .then(status =&gt; getOrder(status.id))
    .then(order =&gt; getPayment(order.id))
    .then(payment =&gt; getRecommendAdvertisements(payment.total_amount))
    .then(ads =&gt; {/*...*/});
</code></pre>
<p>需要注意的是，‌Promise‌ 并不是一种可以将同步代码转变为异步代码的魔法工具。它只是一种编程手法，或者说是一种封装方式，并没有借助操作系统的额外能力。‌Promise‌ 的主要作用是提供了一种更优雅的方式来组织和管理异步操作，使得代码更易于阅读和理解。</p>
<p><strong>总结：与硬件共舞，与冲突和解</strong><br>
Disruptor的环形缓冲、LongAdder的分散热点、Fork/Join的工作窃取、CompletableFuture的异步编排——这些看似迥异的技术，实则殊途同归。它们共同揭示了现代并发设计的核心要义：与其在冲突发生后被动地加锁仲裁，不如在设计之初就主动地消除冲突。<br>
这标志着并发编程的关注点，已从“如何正确加锁”的战术层面，升华为“如何精妙分工、避免锁”的战略高度。<br>
当摩尔定律的红利逐渐消退，真正的性能突破不再依赖于硬件的暴力堆砌，而是源于软件层面与硬件底层机制的“共舞”。无论是利用缓存行特性的内存对齐，还是借助CAS原子指令的乐观更新，每一次技术优化都印证了一个理念：硬件性能的极致发挥，源于对计算本质的深刻理解。这正是并发编程从技术迈向艺术的精髓所在。</p>
<p><strong>很高兴与你相遇！如果你喜欢本文内容，记得关注哦!!!</strong></p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/poemyang/" target="_blank">poemyang</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/poemyang/p/19384431" target="_blank">https://www.cnblogs.com/poemyang/p/19384431</a></p>
</div>
<div class="clear"></div>

        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-12-22 21:34">2025-12-22 21:34</span>&nbsp;
<a href="https://www.cnblogs.com/poemyang">poemyang</a>&nbsp;
阅读(<span id="post_view_count">6</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19384431);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19384431', targetLink: 'https://www.cnblogs.com/poemyang/p/19384431', title: '化整为零、分而治之、异步编排：一文读懂现代并发的底层心法' })">举报</a>

        </p>
     ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ C#/.NET/.NET Core技术前沿周刊 | 第 64 期（2025年12.1-12.21） ]]></title>
    <link>https://www.cnblogs.com/Can-daydayup/p/19384367</link>
    <guid>6ab9454194159f7c496e6e62337f9e99</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Can-daydayup/p/19384367" title="发布于 2025-12-22 21:12">
    <span role="heading" aria-level="2">C#/.NET/.NET Core技术前沿周刊 | 第 64 期（2025年12.1-12.21）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><img src="https://img2024.cnblogs.com/blog/1336199/202509/1336199-20250902130707396-140987169.png" alt="image" loading="lazy"></p>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">前言</span></span></h2>
<p data-tool="mdnice编辑器">C#/.NET/.NET Core技术前沿周刊，你的每周技术指南针！记录、追踪C#/.NET/.NET Core领域、生态的每周最新、最实用、最有价值的技术文章、社区动态、优质项目和学习资源等。让你时刻站在技术前沿，助力技术成长与视野拓宽。</p>
<blockquote class="custom-blockquote multiquote-1" data-tool="mdnice编辑器">
<p>欢迎投稿、推荐或自荐优质文章、项目、学习资源等。</p>
</blockquote>
<ul data-tool="mdnice编辑器">
<li><strong>🏆技术前沿周刊Gitee开源地址：</strong> <a href="https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetWeekly.md" rel="noopener nofollow">https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetWeekly.md</a></li>
<li><strong>📰技术前沿周刊GitHub开源地址：</strong> <a href="https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetWeekly.md" rel="noopener nofollow">https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetWeekly.md</a></li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">精选 8 个 .NET 开发实用的类库，效率提升利器！</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 精选 8 个 .NET 开发实用的类库，.NET 开发效率提升利器！</li>
<li><strong>文章地址：</strong> <a href="https://mp.weixin.qq.com/s/hzHCwM3BaUyZO9HCqODIEQ" rel="noopener nofollow">https://mp.weixin.qq.com/s/hzHCwM3BaUyZO9HCqODIEQ</a></li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">Visual Studio 2026 正式版下载与安装详细教程（附带产品密钥）！</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 最近发现很多小伙伴反馈 Visual Studio 2026 安装占用磁盘空间较大，今天大姚出一期 Visual Studio 2026 正式版下载与安装详细教程，我们可以通过仅选择所需的工作负荷、组件、语言包来节省安装时间和磁盘空间，希望可以帮助到有需要的小伙伴！</li>
<li><strong>文章地址：</strong> <a href="https://mp.weixin.qq.com/s/wbZiTPjhKlFOeU3MgIbq0A" rel="noopener nofollow">https://mp.weixin.qq.com/s/wbZiTPjhKlFOeU3MgIbq0A</a></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251222211437061-990924613.png" alt="image" loading="lazy"></p>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">一个 .NET 开源免费、功能强大的 UI 自动化库</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> FlaUI 是一个 .NET 开源免费（MIT license）、功能强大 的 UI 自动化库，专为 Windows 桌面应用程序（如 Win32、WinForms、WPF、Store Apps 等应用）的自动化测试而设计。该项目基于 Microsoft 的原生 UI Automation 库构建，并作为这些库的封装器，提供了丰富的功能和灵活的 API，以便开发者能够高效地编写自动化测试脚本。</li>
<li><strong>文章地址：</strong> <a href="https://mp.weixin.qq.com/s/PE4S-fUyeG7U8Z78NYu6Rw" rel="noopener nofollow">https://mp.weixin.qq.com/s/PE4S-fUyeG7U8Z78NYu6Rw</a></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251222211450021-574322057.png" alt="image" loading="lazy"></p>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">Newtonsoft.Json 与 System.Text.Json 多态反序列化的安全性差异解析</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 多态反序列化是处理继承结构对象序列化的常见需求，但不同 JSON 序列化库的实现机制差异会带来显著的安全风险。微软 CA2326 规则明确警示：避免使用非安全的 JsonSerializerSettings 配置（如 Newtonsoft.Json 的 TypeNameHandling 非 None 值），否则可能引发类型注入攻击。本文将对比 Newtonsoft.Json 与 System.Text.Json 在多态反序列化中的实现差异，重点分析安全性问题，并通过代码实例验证两者的安全表现。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/MeteorSeed/p/19366736</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">.NET 和 .NET Framework 2025 年 12 月服务发布更新</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 欢迎来到我们 2025 年 12 月的联合.NET 服务更新。让我们进入.NET 和.NET Framework 的最新版本，这里简要介绍一下我们服务版本中的新内容。</li>
<li><strong>文章地址：</strong> https://devblogs.microsoft.com/dotnet/dotnet-and-dotnet-framework-december-2025-servicing-updates/</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251222211504791-248672978.png" alt="image" loading="lazy"></p>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">如何构建带有.NET MAUI 的 iOS 小部件</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 我是一名.NET 开发者，主要专注于.NET MAUI 到 ASP.NET 后端服务。因为我最近大量接触小部件，遇到了许多障碍和极其有限的文档，我决定写这篇文章，展示用 .NET MAUI 构建完整小部件是完全可能的。而且还能以类似原生开发环境的专业方式完成，不用担心每次新构建或更新都会让一切崩溃。</li>
<li><strong>文章地址：</strong> https://devblogs.microsoft.com/dotnet/how-to-build-ios-widgets-with-dotnet-maui</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">.NET 10 网络改进</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 和每次版本一样，我们会发布一篇关于.NET 网络领域新颖有趣变化和新增内容的博客文章。这次，我们将讨论 HTTP 改进、新的 Web 套接字 API、 安全变更以及许多网络原语的独特新增内容。</li>
<li><strong>文章地址：</strong> https://devblogs.microsoft.com/dotnet/dotnet-10-networking-improvements/</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">分享 4 款基于 C# 编写、实用、开源的 Visual Studio 扩展插件</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> EFCore.Visualizer 是一款可以直接在 Visual Studio 中查看 EF Core 查询计划调试器可视化工具（帮助开发者分析和优化数据库查询性能），目前，该可视化工具支持 SQL Server、PostgreSQL、SQLite、MySQL 和 Oracle。</li>
<li><strong>文章地址：</strong> <a href="https://mp.weixin.qq.com/s/DTX-UAZhle9dxnD4MjebCw" rel="noopener nofollow">https://mp.weixin.qq.com/s/DTX-UAZhle9dxnD4MjebCw</a></li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">完美复刻！一个基于 C# 和 WPF 开源的网易云音乐客户端</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> MusicApp 是一个基于 C# 和 WPF 技术开发的模仿网易云音乐界面的音乐应用项目。该项目旨在通过实践学习 WPF 开发，非常适合 WPF 入门学习者作为入门参考项目，本项目已实现基本音乐播放功能。</li>
<li><strong>文章地址：</strong> <a href="https://mp.weixin.qq.com/s/CIWd7qx-S95Xv02pZCBpgw" rel="noopener nofollow">https://mp.weixin.qq.com/s/CIWd7qx-S95Xv02pZCBpgw</a></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251222211523726-2094328585.png" alt="image" loading="lazy"></p>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">一款基于 .NET 和 Quartz.NET 开源的任务调度 Web 界面管理</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> quartzui 是一款基于 Quartz.NET 3.0（后升级至3.2.4）的任务调度 Web 界面管理工具，专为简化任务调度管理而设计。该项目支持通过 Web 界面进行任务调度配置、监控及管理，极大地提高了任务调度的便捷性和效率。</li>
<li><strong>文章地址：</strong> <a href="https://mp.weixin.qq.com/s/qByA7G0EFVY0S2J5l9in1A" rel="noopener nofollow">https://mp.weixin.qq.com/s/qByA7G0EFVY0S2J5l9in1A</a></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251222211541692-730702520.png" alt="image" loading="lazy"></p>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">一个 WPF 开源、免费的 SVG 图像查看控件</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> SVGImage 是一个为 WPF（Windows Presentation Foundation）应用程序设计、开源（MIT license）、免费的 SVG（Scalable Vector Graphics）图像查看控件。</li>
<li><strong>文章地址：</strong> <a href="https://mp.weixin.qq.com/s/69x0B6jhYja58Ze0NSi9ew" rel="noopener nofollow">https://mp.weixin.qq.com/s/69x0B6jhYja58Ze0NSi9ew</a></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251222211555043-1633800824.png" alt="image" loading="lazy"></p>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">一个基于 .NET + Vue3 开源、免费、精美的通用业务型后台管理系统</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> SimpleAdmin 是一个基于 .NET + Vue3 开发的通用业务型后台管理系统，适用于各类需要后台管理功能的企业级应用、网站后台、数据监控平台等场景。它提供了丰富的功能模块和精美的用户界面，能够帮助开发者快速搭建起稳定、高效的后台管理系统，提升开发效率和管理水平。</li>
<li><strong>文章地址：</strong> <a href="https://mp.weixin.qq.com/s/QV2B3et6Df9FrU3RzYDWrQ" rel="noopener nofollow">https://mp.weixin.qq.com/s/QV2B3et6Df9FrU3RzYDWrQ</a></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251222211607946-944175912.png" alt="image" loading="lazy"></p>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">精选 6 款开源的 WinForm UI 控件库，轻松让你的老牌 WinForm 应用焕然一新！</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 今天大姚给大家分享 6 款开源的 WinForm UI 控件库，轻松让你的老牌 WinForm 应用焕然一新！</li>
<li><strong>文章地址：</strong> https://mp.weixin.qq.com/s/l4ccmjKzodcwhxYDRTdukg</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">全面支持国产化！C# 开源跨平台 UI 框架，支持 Windows、Mac、Linux</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> CPF（Cross-Platform Framework）&nbsp;是一款基于 C# 开发的开源跨平台 UI 框架，专注于国产化适配与全平台支持（Windows/macOS/Linux）。项目采用模块化设计，提供高性能的渲染引擎与丰富的控件库，旨在解决国产操作系统生态中缺乏成熟 C# UI 解决方案的痛点，同时兼容主流国际平台。</li>
<li><strong>文章地址：</strong> https://mp.weixin.qq.com/s/qbmUS5gT1be6ZWpYm0FRPw</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">一个基于 .NET 开源、高性能、可扩展的套接字服务器应用程序框架</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> SuperSocket 是一个用于 .NET 的高性能、可扩展的套接字服务器应用程序框架。它为开发者提供了构建自定义网络通信应用程序的强大架构，支持包括 TCP、UDP 和 WebSocket 在内的多种协议。</li>
<li><strong>文章地址：</strong> https://mp.weixin.qq.com/s/oNA-dDh80e-WI__9Itf2JA</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">C#AI系列(7):从零开始LLM之Tokenizer实现</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> LLM只做一个事情，就是吃掉token吐出token，token是LLM（大语言模型）的基本元素。token与LLM的关系，相当于乐高积木与乐高工厂，我的世界方块与我的世界游戏。那么token到底是什么呢？有人翻译成令牌，有人翻译成词源。我们不妨换个概念理解，token就是最小操作、最小信息单元的意思。这个最小是相对于LLM要处理的原始文本来说的。举个栗子，当一个句子文本输入到电脑中，天然就就具有字符级别的切分。如果不打算继续拆分或组合，我们可以通过一个映射关系，将现有这些字符转换为整数数组，称为编码过程。编码后数组内的元素就是token，元素取值就等于token取值。LLM可以吃掉这个token数组，并吐出新数组。对这个新数组按前前述的映射进行逆转换，称为解码过程。解码后我们就能得到人类可以理解的文本了。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/luojin765/p/19378939</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">.NET10 New feature 新增功能介绍-JIT编译器改进</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 首先.NET10是一个LTS版本，微软官方支持3年，所以作为最新的主力版本，可以尽快升级使用。今天我们详细介绍一下.NET 10的一些新功能-JIT编译器改进。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/tianqing/p/19378803</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">.Net通过EFCore和仓储模式实现统一数据权限管控并且相关权限配置动态生成</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> .Net通过EFCore和仓储模式实现统一数据权限管控并且相关权限配置动态生成。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/net-kevin-li/p/19368351</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">OpenCVSharp：HOG行人检测</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> HOG行人检测是一种基于方向梯度直方图特征的计算机视觉目标检测技术，它通过计算图像局部区域的梯度方向直方图来描述目标的外观形状特征。该算法首先将图像分割为小的连通区域（细胞单元），计算每个单元内像素的梯度方向并生成直方图，然后将相邻的细胞单元组合成块并对块内的直方图进行归一化处理，最终形成能够有效描述行人轮廓和形状的特征向量。这些特征向量被输入到预先训练好的SVM分类器中，判断图像区域是否包含行人，并通过多尺度扫描策略在不同大小的窗口中搜索目标，从而实现对图像中行人的准确检测和定位。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/mingupupu/p/19365183</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">OpenCVSharp：学习人脸检测例子</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> OpenCVSharp关于人脸检测提供了两个例子，一个是使用级联分类器另一个是使用DNN模型。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/mingupupu/p/19363129</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">Aspire 13：从.NET 编排工具到真正的多语言云原生应用平台</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> Aspire 13 的发布标志着微软云原生开发工具链的一个决定性转折点。通过正式去除 ".NET" 前缀并更名为 "Aspire"，该平台已从一个以.NET 为中心的编排器演变为一个广泛的、多语言通用的应用平台 1。这一战略转变的核心在于将 Python 和 JavaScript (Node.js) 提升为与.NET 同等的一等公民，彻底解决了现代分布式系统开发中跨语言协作的碎片化痛点 2。本文将深入剖析 Aspire 13 的架构变革，重点阐述其如何通过标准化的 "AppHost" 模型来统一管理异构微服务的生命周期。我们将详细探讨新增的 Aspire.Hosting.Python 包及其对 Python 生态系统（如 uv 包管理器、ASGI 标准、虚拟环境）的深度集成；分析基于 OpenTelemetry (OTLP) 的统一可观测性架构如何消除语言间的监控壁垒；并揭示 Aspire 13 如何通过智能化的环境变量注入和自动化的 Dockerfile 生成，重塑了从本地开发到生产部署的完整工作流 1。此外，本文还将审视这一版本对底层基础设施的要求，包括对.NET 10 SDK 的依赖以及全新的生命周期管理工具 aspire do 的引入 2。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/shanyou/p/19360467</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">用 .NET 最小化 API 构建高性能 API</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 在当今快速发展的应用开发领域，构建快速、可扩展且可维护的API已成为现代应用的关键要求。随着.NET技术的不断演进，微软推出了最小化API(Minimal APIs)这一创新架构，旨在简化API开发流程同时显著提升性能。最小化API通过减少模板代码、优化启动时间，让开发者能够专注于业务逻辑而非框架复杂性，为构建高性能API提供了全新的解决方案。本文将深入探讨如何利用.NET中的最小化API架构构建高性能API，通过简洁的代码示例和实用建议，帮助开发者掌握这一现代API开发方法。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/powertoolsteam/p/19360421</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">2025年 WebTransport 生态深度研究：JavaScript 客户端与.NET 10 SignalR 的演进与融合</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 在实时网络通信领域，2025年标志着从传统的基于 TCP 的 WebSocket 协议向基于 UDP 和 QUIC 的下一代传输协议——WebTransport 的关键转型期。本报告旨在针对 WebTransport 在 JavaScript 客户端生态系统中的支持现状，以及微软.NET 10 框架下 ASP.NET Core SignalR 对该协议的服务端实现能力，进行详尽的基准测试与架构分析。研究显示，截至 2025 年第四季度，WebTransport 的生态呈现出显著的“两极分化”特征。在客户端方面，以 Chrome 和 Firefox 为代表的浏览器阵营已经实现了高度成熟且稳定的支持，不仅完全遵循 W3C 标准，更在流控制和拥塞管理上表现优异；然而，Apple 的 WebKit 内核（Safari）依旧是普及的最大阻碍，仅在实验性版本中有限度开放。在服务端方面，随着.NET 10 的发布，ASP.NET Core SignalR 将 WebTransport 从“实验性预览”正式推进至“生产就绪”阶段，尽管其对底层操作系统（如 Windows Server 2022/2025 和特定 Linux 发行版）的依赖依然构成了部署门槛。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/shanyou/p/19355053</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">OpenCVSharp：了解几种特征检测</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 前面已经介绍过了OpenCVSharp中封装的几个特征检测算法，其实里面还有很多特征检测算法，不再一篇一篇地介绍了，其它的都放在这一篇，简单过一下，有点印象即可。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/mingupupu/p/19352075</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">C#AI系列(6): C#离线实现高效OCR</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 实现OCR，我们直接从Tesseract（Apache 2.0，star 71.4K）开始。Tesseract 是目前最活跃、最精确的开源 OCR（光学字符识别）引擎之一，由 Google 维护。它能把图片中的印刷或手写文字转换成可编辑的纯文本、PDF、HTML 等多种格式，支持包括中文等 100 多种语言。Tesseract 4 以后引入基于深度学习的 LSTM 神经网络模型，对整行文字进行识别，准确率大幅提升。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/luojin765/p/19346320</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">OpenCVSharp：学习连通性检测的使用</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 连通性检测是计算机视觉中的一种基础图像处理技术，用于识别和标记二值图像中相互连接的像素区域。简单来说，它能够找出图像中所有独立的"连通区域"（即像素之间相互连接形成的区域）。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/mingupupu/p/19344713</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">WPF个人文档（一）—— 基础语法&amp;组件篇</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> WPF个人文档（一）—— 基础语法&amp;组件篇。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/leaf-7-scouts/p/19336808</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">.Net微服务网关注册和管理（基于Consul + Nginx实现）</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 在微服务架构中，API网关作为请求入口，负责路由转发、负载均衡、认证鉴权等核心功能。Consul提供服务注册与发现能力，Nginx作为高性能反向代理，二者结合可实现动态网关管理。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/net-kevin-li/p/19332353</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">.NET 10 网络改进：HTTP、安全与网络原语的全面升级</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 随着.NET 10的发布，微软在网络技术栈上带来了一系列令人兴奋的改进和新增功能。这些改进覆盖了HTTP协议处理、WebSockets API、安全增强以及网络基础原语等多个方面。本文将深入探讨这些技术改进，帮助开发者更好地理解和利用.NET 10在网络编程方面的最新能力。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/powertoolsteam/p/19330426</li>
</ul>
<h2 data-tool="mdnice编辑器"><span class="prefix"><span class="content">C#实现三菱MC通讯协议库（4C帧-格式1）</span></span></h2>
<ul data-tool="mdnice编辑器">
<li><strong>文章简介：</strong> 根据三菱的 Melsec 通讯协议(本文称MC协议)手册内容，使用串口实现了 PC 与 PLC 的通讯，能够通过QnA兼容4C帧的格式1实现 PC 读写 PLC 的软元件存储器内容(异步方法)，最后用一个 C#控制台项目测试了通讯库功能。</li>
<li><strong>文章地址：</strong> https://www.cnblogs.com/dragonet-Z/p/19318911</li>
</ul>
</div>
<div id="MySignature" role="contentinfo">
    <blockquote>
<p style="font-family:YouYuan;font-size: 16px;margin: 0 auto 0.01em auto;"><span style="font-size: 17px; ">作者名称：</span><a href="https://www.cnblogs.com/Can-daydayup/" target="_blank">追逐时光者</a></p>
<p style="font-family:YouYuan;font-size: 16px;margin: 0 auto 0.01em auto;"><span style="font-size: 17px; ">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>
<p style="font-family:YouYuan;font-size: 16px;margin: 0 auto 0.01em auto;">
本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a onclick="votePost(cb_entryId,'Digg')" href="javascript:void(0)" style="color:red;">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。
</p>
</blockquote>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.002777777777777778" data-date-updated="2025-12-22 21:16">2025-12-22 21:12</span>&nbsp;
<a href="https://www.cnblogs.com/Can-daydayup">追逐时光者</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19384367);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19384367', targetLink: 'https://www.cnblogs.com/Can-daydayup/p/19384367', title: 'C#/.NET/.NET Core技术前沿周刊 | 第 64 期（2025年12.1-12.21）' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ 【Ubuntu】Ubuntu 22.04 与 Windows 跨系统文件共享的完整方案 ]]></title>
    <link>https://www.cnblogs.com/Skyrim-sssuuu/p/19381887</link>
    <guid>6c901c7ccf4728990494f3442a345d0a</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Skyrim-sssuuu/p/19381887" title="发布于 2025-12-22 20:37">
    <span role="heading" aria-level="2">【Ubuntu】Ubuntu 22.04 与 Windows 跨系统文件共享的完整方案</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="引言">引言</h1>
<p>这应该也是个比较常见的需求，最近刚好就用到了，特在此记录一下。<br>
这篇随笔目的是：</p>
<ol>
<li><strong>将 Windows 的文件共享到 Ubuntu 中<br>
aim：方便将 Windows 本地文件工程转移到 Ubuntu</strong></li>
<li><strong>将 Ubuntu 的文件共享到 Windows 中<br>
aim：方便 Windows 某些程序方便定位某些位于 Ubuntu 上目标文件夹的路径</strong></li>
</ol>
<h1 id="参考文章">参考文章</h1>
<blockquote>
<p><a href="https://blog.csdn.net/qq_44078824/article/details/119847027" title="【详细步骤】Ubuntu安装Samba服务及配置共享文件夹" target="_blank" rel="noopener nofollow">【详细步骤】Ubuntu安装Samba服务及配置共享文件夹</a><br>
<a href="https://zhuanlan.zhihu.com/p/475119154" title="Ubuntu共享文件夹的创建和使用" target="_blank" rel="noopener nofollow">Ubuntu共享文件夹的创建和使用</a><br>
<a href="https://blog.csdn.net/ss_0507/article/details/150583096" title="Ubuntu22.04设置共享文件夹" target="_blank" rel="noopener nofollow">Ubuntu22.04设置共享文件夹</a></p>
</blockquote>
<h1 id="windows-文件共享到-ubuntu">Windows 文件共享到 Ubuntu</h1>
<h2 id="步骤一设置-windows-下的共享文件">步骤一：设置 Windows 下的共享文件</h2>
<p>我使用的是 VMware 这款虚拟机平台（其他的应该也差不多），操作如下：</p>
<ol>
<li><strong>右键虚拟机 -&gt; 设置</strong></li>
<li><strong>选项 -&gt; 共享文件夹 -&gt; 添加 -&gt; 选择 Windows 下的一个文件夹</strong></li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3619091/202512/3619091-20251222144536382-422437124.png" alt="3619091-20251222133645048-710056770" loading="lazy"></p>
<h2 id="步骤二将共享文件夹挂载在-ubuntu-下">步骤二：将共享文件夹挂载在 Ubuntu 下</h2>
<ol>
<li>
<p><strong>安装/更新工具包</strong></p>
<pre><code> // 以管理员权限更新系统软件包索引
 sudo apt update
 
 // 安装 VMware Tools 的开源替代版 open-vm-tools（实现虚拟机与主机的基础交互 / 共享功能）
 sudo apt install open-vm-tools
 
 // 更新 FUSE 版本
 sudo apt-get install fuse
</code></pre>
</li>
<li>
<p><strong>共享文件的文件夹位置在<code>/mnt/hgfs/</code>目录下，假如没有这个目录，就创建一个</strong></p>
<pre><code> sudo mkdir -p /mnt/hgfs/
</code></pre>
</li>
<li>
<p><strong>敲指令进入此目录，并进行挂载</strong></p>
<pre><code> // 进入 /mnt/hgfs/ 目录
 cd /mnt/hgfs/
 
 // 通过 VMware 的 hgfs 工具将主机所有共享文件夹挂载到虚拟机的/mnt/hgfs目录
 sudo vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other,uid=1000,gid=1000,umask=022
 
 // allow_other：允许普通用户访问挂载目录
 // uid=1000：将挂载目录的文件所有者设为 UID=1000 的普通用户（避免仅 root 可访问，可通过`id`命令查看）
 // gid=1000：将挂载目录的文件所属组设为 GID=1000 的用户组
 // umask=022：设置挂载目录的默认权限（让普通用户可读可写，其他用户只读）
</code></pre>
</li>
<li>
<p><strong>设置开机自动挂载</strong></p>
<pre><code> // 打开开机配置文件夹，编辑开机自动执行的命令
 sudo nano /etc/rc.local

 // 在配置文件夹中输入，即可完成开机自动挂载共享文件夹：
 sudo vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other,uid=1000,gid=1000,umask=022
</code></pre>
</li>
</ol>
<p>可以看到，已经挂载成功：</p>
<p><img src="https://img2024.cnblogs.com/blog/3619091/202512/3619091-20251222183127087-1919558918.png" alt="image" loading="lazy"></p>
<h1 id="ubuntu-文件共享到-windows">Ubuntu 文件共享到 Windows</h1>
<h2 id="步骤一安装-samba-工具设置共享目录的读写权限">步骤一：安装 samba 工具，设置共享目录的读写权限</h2>
<pre><code>// 以管理员权限更新系统软件包索引
sudo apt update

// Samba 服务的主程序（实现 Linux 与 Windows 的文件共享）
// Samba 的通用配置文件和工具（提供共享配置的基础依赖）
// Samba 的客户端工具（用于在 Linux 终端测试 / 访问远程共享目录）
sudo apt-get install samba samba-common smbclient

// 将home设置为共享
sudo chmod 777 /home
</code></pre>
<h2 id="步骤二samba-配置">步骤二：samba 配置</h2>
<ol>
<li>
<p><strong>添加 samba 用户，并设置密码</strong></p>
<pre><code> // 输入两次密码
 sudo smbpasswd -a 用户名
</code></pre>
</li>
<li>
<p><strong>使用 nano 修改 samba 配置文件</strong></p>
<pre><code> // 个人习惯用 nano
 sudo nano /etc/samba/smb.conf
 
 添加：
 [share]
 comment = share folder  # 共享描述
 browseable = yes        # 允许网络中可见该共享
 path = /home            # 共享文件夹的实际路径
 create mask = 0700      # 新建文件的默认权限（仅文件所有者可读/写/执行）
 directory mask = 0700   # 新建文件夹的默认权限（仅文件夹所有者可读/写/执行）
 valid users = shf       # 仅允许xxx用户访问该共享
 force user = shf        # 强制将共享内文件的所有者设为xxx（避免权限混乱）
 force group = shf       # 强制将共享内文件的所属组设为xxx
 public = yes            # 允许匿名访问（注：与valid users冲突，实际仅shf可访问）
 available = yes         # 启用该共享（设为no则禁用）
 writable = yes          # 允许对共享目录进行写入/修改/删除操作
</code></pre>
<p>如图，将其添加到此文件最后的位置：</p>
<p><img src="https://img2024.cnblogs.com/blog/3619091/202512/3619091-20251222201837632-881410970.png" alt="image" loading="lazy"></p>
</li>
<li>
<p><strong>重启samba服务器</strong></p>
<pre><code> sudo service smbd restart
</code></pre>
</li>
<li>
<p><strong>查看主机静态 IP 并测试是否能 Ping 通</strong><br>
由于之前已经配置好了简单的三网段，可以参考这篇文章：</p>
<blockquote>
<p><a href="https://www.cnblogs.com/Skyrim-sssuuu/p/19376866" title="【Ubuntu】Ubuntu 虚拟机配置三网段（桥接-WIFI、仅主机、桥接-开发板）" target="_blank">【Ubuntu】Ubuntu 虚拟机配置三网段（桥接-WIFI、仅主机、桥接-开发板）</a></p>
</blockquote>
<p>查看 IP 地址：</p>
<pre><code> ifconfig
</code></pre>
<p>返回如下图，其中<code>192.168.184.184</code>则是我给仅主机设置的静态 IP 地址，待会要用到。<br>
<img src="https://img2024.cnblogs.com/blog/3619091/202512/3619091-20251222201510793-1988332202.png" alt="image" loading="lazy"></p>
<pre><code> // 输入：
 ping -c 3 192.168.184.1
 返回：
 PING 192.168.184.1 (192.168.184.1) 56(84) bytes of data.
 64 bytes from 192.168.184.1: icmp_seq=1 ttl=128 time=0.378 ms
 64 bytes from 192.168.184.1: icmp_seq=2 ttl=128 time=0.423 ms
 64 bytes from 192.168.184.1: icmp_seq=3 ttl=128 time=0.438 ms

 --- 192.168.184.1 ping statistics ---
 3 packets transmitted, 3 received, 0% packet loss, time 2050ms
 rtt min/avg/max/mdev = 0.378/0.413/0.438/0.025 ms
</code></pre>
</li>
<li>
<p><strong>测试 Samba 共享是否正常</strong></p>
<pre><code> 输入：
 smbclient -L //localhost/home -U 用户名
 输入密码后即可返回：
 		Sharename       Type      Comment
 		---------       ----      -------
 		home            Disk      home guest share
 		print$          Disk      Printer Drivers
 		IPC$            IPC       IPC Service (ubuntu-skyrim server (Samba, Ubuntu))
 SMB1 disabled -- no workgroup available
</code></pre>
</li>
<li>
<p><strong>Windows 操作挂载共享文件夹</strong><br>
右键此电脑，选择映射网络驱动。</p>
<p><img src="https://img2024.cnblogs.com/blog/3619091/202512/3619091-20251222202958445-651518490.png" alt="image" loading="lazy"></p>
<p>选择一个驱动器，这里我选择了 H盘（由于我已经配置过了，所以后面会显示我的静态 IP 地址和共享文件夹），文件夹那里根据示例来填写即可：</p>
<pre><code> \\192.168.184.184\share
 注意这里 IP 地址后面好像只能填 share，我这里填写 home 不行。
 填写完后输入你的 Ubuntu 用户名和密码即可。
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3619091/202512/3619091-20251222203101977-1510784502.png" alt="image" loading="lazy"></p>
</li>
<li>
<p><strong>打开此电脑，查看共享文件夹</strong><br>
看到在网络位置多了一个盘，就说明挂载成功了。</p>
<p><img src="https://img2024.cnblogs.com/blog/3619091/202512/3619091-20251222203604661-363419804.png" alt="image" loading="lazy"></p>
</li>
</ol>
<h1 id="博客导航">博客导航</h1>
<blockquote>
<p><a href="https://www.cnblogs.com/Skyrim-sssuuu/p/19140894" title="博客导航" target="_blank">博客导航</a></p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/Skyrim-sssuuu/" target="_blank">膝盖中箭卫兵</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/Skyrim-sssuuu/p/19381887" target="_blank">https://www.cnblogs.com/Skyrim-sssuuu/p/19381887</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.002777777777777778" data-date-updated="2025-12-22 20:41">2025-12-22 20:37</span>&nbsp;
<a href="https://www.cnblogs.com/Skyrim-sssuuu">膝盖中箭卫兵</a>&nbsp;
阅读(<span id="post_view_count">14</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19381887);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19381887', targetLink: 'https://www.cnblogs.com/Skyrim-sssuuu/p/19381887', title: '【Ubuntu】Ubuntu 22.04 与 Windows 跨系统文件共享的完整方案' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ WPF 使用 RenderTransform 实现高性能平滑滚动的 ScrollViewer ]]></title>
    <link>https://www.cnblogs.com/TwilightLemon/p/19383555</link>
    <guid>a4f24e9455fd0d77473a326cd1062aa1</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TwilightLemon/p/19383555" title="发布于 2025-12-22 17:12">
    <span role="heading" aria-level="2">WPF 使用 RenderTransform 实现高性能平滑滚动的 ScrollViewer</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>在之前的两篇文章中，我们探讨了 WPF 中实现平滑滚动的不同方案：</p>
<ol>
<li><a href="https://blog.twlmgatito.cn/posts/wpf-smooth-scrollviewer" rel="noopener nofollow">WPF 如何流畅地滚动ScrollViewer 简单实现下</a>：基于&nbsp;<code>DoubleAnimation</code>&nbsp;的动画方案。</li>
<li><a href="https://blog.twlmgatito.cn/posts/wpf-fluent-scrollviewer-with-all-device-supported" rel="noopener nofollow">WPF 使用CompositionTarget.Rendering实现平滑流畅滚动的ScrollViewer</a>：基于&nbsp;<code>CompositionTarget.Rendering</code>&nbsp;的每帧布局更新方案。</li>
</ol>
<p>虽然第二版方案解决了触控板和物理惯性的问题，但它引入了一个新的性能瓶颈：每帧调用&nbsp;<code>ScrollToVerticalOffset</code>。这会导致 WPF 在每一帧都进行布局计算，在高负载场景下会直接卡死整个UI线程，造成掉帧或其他UI组件无响应。</p>
<p>为了解决这个问题，我进行了第三版（v3）设计，核心思路是：视觉层与逻辑层分离。</p>
<h2 id="三种方案对比">三种方案对比</h2>
<table>
<thead>
<tr><th align="left">方案</th><th align="left">实现方式</th><th align="left">优点</th><th align="left">缺点</th></tr>
</thead>
<tbody>
<tr>
<td align="left">v1 (动画版)</td>
<td align="left"><code>DoubleAnimation</code>&nbsp;驱动&nbsp;<code>VerticalOffset</code></td>
<td align="left">实现简单，代码量少</td>
<td align="left">无法保留惯性速度（动画打断）；触控板体验差；不支持触摸/笔。</td>
</tr>
<tr>
<td align="left">v2 (布局驱动)</td>
<td align="left"><code>Rendering</code>&nbsp;事件每帧调用&nbsp;<code>ScrollToVerticalOffset</code></td>
<td align="left">物理模型更真实；支持多种输入设备</td>
<td align="left">性能差：每帧触发 Layout 计算，高负载下掉帧严重。</td>
</tr>
<tr>
<td align="left">v3 (视觉分离)</td>
<td align="left"><code>RenderTransform</code>&nbsp;驱动视觉，低频同步逻辑位置</td>
<td align="left">高性能：视觉满帧运行，逻辑低频更新；物理模型完善。</td>
<td align="left">实现相对复杂，需要处理坐标系转换和帧同步。</td>
</tr>
</tbody>
</table>
<hr>
<p>现在来看看v3的效果（gif帧率好低）：</p>
<p><img alt="2025-12-22-17-04-20" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1188749/202512/1188749-20251222170546134-1859722965.gif" class="lazyload"></p>
<p>接下来，我们详细介绍 v3 版本的设计与实现原理。</p>
<h2 id="一视觉与逻辑分离">一、视觉与逻辑分离</h2>
<p>v3 的核心在于将“用户看到的滚动”（视觉层）和“控件实际的滚动”（逻辑层）分离。</p>
<ol>
<li>
<p>视觉层：</p>
<ul>
<li>使用&nbsp;<code>TranslateTransform</code>&nbsp;对&nbsp;<code>Content</code>&nbsp;进行位移。</li>
<li>在&nbsp;<code>CompositionTarget.Rendering</code>&nbsp;中以屏幕刷新率（如 60Hz 或 144Hz）更新&nbsp;<code>Transform.Y</code>。</li>
<li>因为&nbsp;<code>RenderTransform</code>&nbsp;只影响渲染而不触发布局（Measure/Arrange），所以性能极高，完全由 GPU 加速。</li>
</ul>
</li>
<li>
<p>逻辑层：</p>
<ul>
<li>维护实际的&nbsp;<code>ScrollViewer.VerticalOffset</code>。</li>
<li>降频更新：不再每帧调用&nbsp;<code>ScrollToVerticalOffset</code>，而是以较低的频率（如 24Hz）同步逻辑位置。</li>
<li>这保证了滚动条的位置更新和虚拟化加载新内容，同时避免了频繁的布局计算。</li>
</ul>
</li>
</ol>
<h3 id="渲染循环逻辑">渲染循环逻辑</h3>
<p>只需遵守一条坐标系变换规则：逻辑位置 = 视觉位置 + 视觉偏差。<br>当用户滚动时，视觉层将以“插帧”方式在逻辑层低帧率更新之间平滑过渡。</p>
<p>在每一帧的渲染回调中：</p>
<ol>
<li>计算物理模型的当前位置&nbsp;<code>_currentVisualOffset</code>。</li>
<li>计算视觉偏差&nbsp;<code>_visualDelta = _currentVisualOffset - _logicalOffset</code>。</li>
<li>应用&nbsp;<code>_transform.Y = -_visualDelta</code>，实现视觉上的平滑移动，不会触发布局重置。</li>
<li>累加时间，如果超过&nbsp;<code>ScrollBarUpdateInterval</code>&nbsp;(1/24s)，则调用&nbsp;<code>ScrollToVerticalOffset</code>&nbsp;同步逻辑位置，触发布局更新，从而允许滚动条同步和虚拟化等功能生效。</li>

</ol>
<h2 id="二物理模型设计">二、物理模型设计</h2>
<p>v3 版本的物理模型沿用了 v2 的设计，但做了一些改进以提升滚动体验。以下介绍完整的物理模型。</p>
<h3 id="21-缓动模型">2.1 缓动模型</h3>
<p>适用于鼠标滚轮。该模型包含两个核心部分：动态速度因子（决定滚多快）和物理衰减（决定滚多久）。</p>
<h4 id="动态速度因子-dynamic-velocity-factor">动态速度因子 (Dynamic Velocity Factor)</h4>
<p>在 v2 版本中，我们发现简单的线性速度叠加无法平衡缓慢滚动和快速滚动的体验。因此，v3 引入了一个基于时间间隔的动态速度因子。当用户快速连续滚动时，速度因子会呈指数级增长，从而产生更大的加速度。</p>
<p><span class="katex"><span class="katex-mathml">v<sub>f</sub>=(Vmax−Vmin)⋅e^(−Δt/20)+Vmin<span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s"><span class="vlist-r"><span class="vlist"><span class="mspace"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mopen"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s"><span class="vlist-r"><span class="vlist"><span class="mspace"><span class="mbin"><span class="mspace"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="vlist-s"><span class="vlist-r"><span class="vlist"><span class="mclose"><span class="mspace"><span class="mbin"><span class="mspace"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="sizing reset-size3 nulldelimiter size6 mopen"><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size3 size1"><span class="mord mtight"><span class="mord mtight"><span class="pstrut"><span class="mtight frac-line"><span class="pstrut"><span class="mtight sizing reset-size3 size1"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="vlist-s"><span class="vlist-r"><span class="vlist"><span class="sizing reset-size3 nulldelimiter size6 mclose"><span class="mspace"><span class="mbin"><span class="mspace"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="vlist-s">​</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml">Vmax<span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s">​<span class="vlist-r"><span class="vlist">：最大速度倍率，固定为 2.5。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml">Vmin<span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="vlist-s">​<span class="vlist-r"><span class="vlist">：最小速度倍率 (<code>MinVelocityFactor</code>)，默认为 1.2。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml">Δt<span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal">：两次滚动事件的时间间隔 (ms)。</span></span></span></span></span></span></span></li>

</ul>
<p>这意味着：如果你慢慢滚动，每次滚动的距离约为原始值的 1.2 倍；如果你疯狂拨动滚轮，这个倍率会迅速逼近 2.5 倍，与真实的物理滚动手感更接近。</p>
<h4 id="物理衰减">物理衰减</h4>
<p>模拟物理摩擦力，使滚动速度随时间自然衰减。</p>
<ul>
<li>速度衰减：<span class="katex"><span class="katex-mathml">v<sub>new</sub>=v<sub>old</sub>⋅f^t<sub>f</sub><span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s"><span class="vlist-r"><span class="vlist"><span class="mspace"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s"><span class="vlist-r"><span class="vlist"><span class="mspace"><span class="mbin"><span class="mspace"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size3 size1"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s">​</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>位置更新：<span class="katex"><span class="katex-mathml">x<sub>new</sub>=x<sub>old</sub>+v<sub>new</sub>⋅(t<sub>f</sub>/24)<span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s"><span class="vlist-r"><span class="vlist"><span class="mspace"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s"><span class="vlist-r"><span class="vlist"><span class="mspace"><span class="mbin"><span class="mspace"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s"><span class="vlist-r"><span class="vlist"><span class="mspace"><span class="mbin"><span class="mspace"><span class="base"><span class="strut"><span class="mord"><span class="mopen nulldelimiter"><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight"><span class="pstrut"><span class="frac-line"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size3 size1"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s">​<span class="vlist-r"><span class="vlist"><span class="vlist-s">​</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>

</ul>
<p>其中：</p>
<ul>
<li><span class="katex"><span class="katex-mathml">f<span class="katex-html"><span class="base"><span class="strut"><span class="mord mathnormal">：速率衰减系数，默认为 0.92。数值越小，停得越快。</span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml">t<sub>f</sub><span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s">​<span class="vlist-r"><span class="vlist">：时间标准化因子，<span class="katex"><span class="katex-mathml">dt/TargetFrameTime<span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mopen nulldelimiter"><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="pstrut"><span class="frac-line"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s">​<span class="vlist-r"><span class="vlist"><span class="mclose nulldelimiter">&nbsp;(基准帧率为 144Hz)，dt为绘制两帧之间的间隔时间。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>常数 24 是一个经验值，用于调整速度到位移的映射比例。</li>

</ul>
<h3 id="22-精确模型">2.2 精确模型</h3>
<p>适用于触控板。触控板本身提供了高精度的&nbsp;<code>Delta</code>&nbsp;值，我们不需要模拟惯性（系统已处理），只需要平滑地过渡到目标位置，避免画面撕裂或抖动。</p>
<ul>
<li>插值计算：<span class="base"><span class="mord"><span class="mord mathnormal">x<span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight"><sub>n</sub><span class="mord mathnormal mtight"><sub>e</sub><span class="mord mathnormal mtight"><sub>w</sub><span class="vlist-s"><sub>​</sub><span class="vlist-r"><span class="vlist"><span class="mspace"><span class="mrel">=<span class="mspace"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal">x<span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight"><sub>o</sub><span class="mord mathnormal mtight"><sub>l</sub><span class="mord mathnormal mtight"><sub>d</sub><span class="vlist-s">​<span class="vlist-r"><span class="vlist"><span class="mspace"><span class="mbin">+<span class="mspace"><span class="base"><span class="strut"><span class="mopen">(<span class="mord"><span class="mord mathnormal">x<span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight"><sub>t</sub><span class="mord mathnormal mtight"><sub>a</sub><span class="mord mathnormal mtight"><sub>r</sub><span class="mord mathnormal mtight"><sub>g</sub><span class="mord mathnormal mtight"><sub>e</sub><span class="mord mathnormal mtight"><sub>t</sub><span class="vlist-s"><sub>​</sub><span class="vlist-r"><span class="vlist"><span class="mspace"><span class="mbin">−<span class="mspace"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal">x<span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight"><sub>o</sub><span class="mord mathnormal mtight"><sub>l</sub><span class="mord mathnormal mtight"><sub>d</sub><span class="vlist-s">​<span class="vlist-r"><span class="vlist"><span class="mclose">)<span class="mspace"><span class="mbin">⋅<span class="mspace"><span class="base"><span class="strut"><span class="mopen">(<span class="mord">1<span class="mspace"><span class="mbin">−<span class="mspace"><span class="base"><span class="strut"><span class="mopen">(<span class="mord">1<span class="mspace"><span class="mbin">−<span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal">l<span class="mclose"><span class="mclose">)^<span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t<sub>f</sub><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight"><span class="mord mathnormal mtight"><span class="mord mathnormal mtight"><span class="mord mathnormal mtight"><span class="mord mathnormal mtight"><span class="vlist-s">​<span class="vlist-r"><span class="vlist"><span class="mclose">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><br></span></span></li>

</ul>
<p>其中：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="base"><span class="strut"><span class="mord mathnormal">l：插值系数 (<code>LerpFactor</code>)，默认为 0.5。数值越大，跟随越紧密。</span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s"><span class="vlist-r"><span class="vlist">t<sub>f</sub>：时间标准化因子。<span class="katex"><span class="katex-mathml"><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>

</ul>
<h2 id="三快速开始">三、快速开始</h2>
<p>在项目中引入FluentWpfCore包，然后使用：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">Window </span><span style="color: rgba(255, 0, 0, 1)">xmlns:fluent</span><span style="color: rgba(0, 0, 255, 1)">="clr-namespace:FluentWpf.Controls;assembly=FluentWpfCore"</span><span style="color: rgba(255, 0, 0, 1)"> 
        ...</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>

<span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">fluent:SmoothScrollViewer</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>
    <span style="color: rgba(0, 128, 0, 1)">&lt;!--</span><span style="color: rgba(0, 128, 0, 1)">可选 自定义模型及其参数</span><span style="color: rgba(0, 128, 0, 1)">--&gt;</span>
    <span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">fluent:SmoothScrollViewer.Physics</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>
        <span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">fluent:DefaultScrollPhysics </span><span style="color: rgba(255, 0, 0, 1)">MinVelocityFactor</span><span style="color: rgba(0, 0, 255, 1)">="1.2"</span> <span style="color: rgba(0, 0, 255, 1)">/&gt;</span>
    <span style="color: rgba(0, 0, 255, 1)">&lt;/</span><span style="color: rgba(128, 0, 0, 1)">fluent:SmoothScrollViewer.Physics</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span><span style="color: rgba(0, 0, 0, 1)">
    ...
</span><span style="color: rgba(0, 0, 255, 1)">&lt;/</span><span style="color: rgba(128, 0, 0, 1)">fluent:SmoothScrollViewer</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>

<span style="color: rgba(0, 0, 255, 1)">&lt;/</span><span style="color: rgba(128, 0, 0, 1)">Window</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span></pre>
</div>
<table>
<thead>
<tr><th>属性</th><th>类型</th><th>默认值</th><th>说明</th></tr>
</thead>
<tbody>
<tr>
<td><code>IsEnableSmoothScrolling</code></td>
<td><code>bool</code></td>
<td><code>true</code></td>
<td>启用或禁用平滑滚动动画（实际上会控制所有SmoothScrolling相关功能）</td>
</tr>
<tr>
<td><code>PreferredScrollOrientation</code></td>
<td><code>Orientation</code></td>
<td><code>Vertical</code></td>
<td>首选滚动方向：<code>Vertical</code>&nbsp;或&nbsp;<code>Horizontal</code></td>
</tr>
<tr>
<td><code>AllowTogglePreferredScrollOrientationByShiftKey</code></td>
<td><code>bool</code></td>
<td><code>true</code></td>
<td>允许通过按住 Shift 键切换滚动方向</td>
</tr>
<tr>
<td><code>Physics</code></td>
<td><code>IScrollPhysics</code></td>
<td><code>DefaultScrollPhysics</code></td>
<td>控制滚动动画行为的物理模型</td>
</tr>
</tbody>
</table>
<p>默认模型(<code>DefaultScrollPhysics</code>)可选参数：</p>
<table>
<thead>
<tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr>
</thead>
<tbody>
<tr>
<td><code>MinVelocityFactor</code></td>
<td><code>double</code></td>
<td><code>1.2</code></td>
<td>鼠标滚轮的最小速度倍率</td>
</tr>
<tr>
<td><code>Friction</code></td>
<td><code>double</code></td>
<td><code>0.92</code></td>
<td>鼠标滚轮的速度衰减系数</td>
</tr>
<tr>
<td><code>LerpFactor</code></td>
<td><code>double</code></td>
<td><code>0.5</code></td>
<td>触控板滚动的插值系数</td>
</tr>
</tbody>
</table>
<h2 id="四了解更多">四、了解更多</h2>
<h3 id="1-为什么要视觉满帧逻辑低频">1) 为什么要“视觉满帧、逻辑低频”</h3>
<p>在 WPF 里，<code>ScrollToVerticalOffset/ScrollToHorizontalOffset</code>&nbsp;不是一个“只改数值”的轻量操作。它往往会驱动：</p>
<ul>
<li>滚动条位置与&nbsp;<code>ScrollChanged</code>&nbsp;事件</li>
<li>布局与渲染链路（尤其是内容复杂时）</li>
<li>虚拟化容器的生成/回收（例如&nbsp;<code>VirtualizingStackPanel</code>）</li>
</ul>
<p>v2的实现把它放到&nbsp;<code>CompositionTarget.Rendering</code>&nbsp;的每一帧里调用，意味着UI线程必须在每帧都完成布局计算，这在内容复杂或CPU负载高时会直接卡死UI线程，导致掉帧或其他UI组件无响应。</p>
<p>v3 的分层策略是：</p>
<ul>
<li>视觉层：用&nbsp;<code>TranslateTransform</code>&nbsp;做位移补偿，只影响渲染，不触发布局。</li>
<li>逻辑层：用&nbsp;<code>ScrollTo*Offset</code>&nbsp;推进真实偏移，但频率降低到 24Hz。</li>
</ul>
<p>相当于把“高频的连续运动”交给 GPU（RenderTransform），把“低频但必要的状态推进”交给布局系统（ScrollTo）。或者理解为：视觉层做“动画”，逻辑层做“状态更新”，以低帧率推进布局计算，然后由视觉层平滑过渡，显著提升性能。</p>
<h3 id="2-关键状态视觉差值visual-delta">2) 关键状态：视觉差值（Visual Delta）</h3>
<p>在 v3 里，始终存在两个 offset：</p>
<ul>
<li>逻辑 offset：<code>ScrollViewer</code>&nbsp;真正的&nbsp;<code>VerticalOffset/HorizontalOffset</code>，决定滚动条与虚拟化。</li>
<li>视觉 offset：物理模型在每帧计算出的“应该看到的位置”。</li>
</ul>
<p>两者的差值就是视觉补偿量：</p>
<p><span class="katex"><span class="katex-mathml">Δ= visual offset −&nbsp;logical offset<span class="katex-html"><span class="base"><span class="strut"><span class="mord"><span class="mspace"><span class="mrel"><span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal"><span class="mord mathnormal"><span class="mord mathnormal"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s"><span class="vlist-r"><span class="vlist"><span class="mspace"><span class="mbin"><span class="mspace"><span class="base"><span class="strut"><span class="mord mathnormal"><span class="mord mathnormal"><span class="mord mathnormal"><span class="mord"><span class="mord mathnormal"><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="pstrut"><span class="mtight sizing reset-size6 size3"><span class="mord mtight"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="mord mtight mathnormal"><span class="vlist-s">​</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>视觉层每帧做的事情非常纯粹：把这个差值通过 Transform 反向抵消掉，让用户“看到”的内容位置跟随视觉 offset。</p>
<ul>
<li>垂直滚动：<code>Transform.Y = -Δ</code></li>
<li>水平滚动：<code>Transform.X = -Δ</code></li>
</ul>
<p>这样带来两个好处：</p>
<ol>
<li>逻辑层什么时候同步（调用&nbsp;<code>ScrollTo*Offset</code>）可以自由选择频率，不会影响视觉连续性。</li>
<li>当逻辑层因为外部原因突变（拖动滚动条、代码调用&nbsp;<code>ScrollTo...</code>、键盘导航）时，只要立刻重算差值，视觉层就仍然能保持连续。</li>
</ol>
<h3 id="3-为什么要用真实-dt而不是假设固定帧率">3) 为什么要用真实&nbsp;<code>dt</code>（而不是假设固定帧率）</h3>
<p><code>CompositionTarget.Rendering</code>&nbsp;的触发并不严格等间隔：后台负载、窗口被遮挡、显示器刷新率、系统节能策略都会让帧间隔波动。</p>
<p>因此实现中用&nbsp;<code>Stopwatch.GetTimestamp()</code>&nbsp;计算真实&nbsp;<code>dt</code>，并把&nbsp;<code>dt</code>&nbsp;传给物理模型。这意味着：</p>
<ul>
<li>低帧率时不会“走慢动作”或突然“加速冲刺”</li>
<li>高刷屏（120/144Hz）不会因为更高帧数而滚得更远</li>
</ul>
<p>配合&nbsp;<code>DefaultScrollPhysics</code>&nbsp;中的&nbsp;<code>timeFactor = dt / TargetFrameTime</code>，滚动手感可以在不同帧率下保持一致。</p>
<h3 id="4-关于逻辑同步频率">4) 关于逻辑同步频率</h3>
<p>实现把逻辑同步频率设为 24Hz（<code>ScrollBarUpdateInterval = 1/24s</code>），这是一个折中：</p>
<ul>
<li>频率更高：滚动条更“实时”，虚拟化更及时，但布局压力上升。</li>
<li>频率更低：性能更好，但滚动条会有视觉滞后，虚拟化加载可能会出现空白频闪。</li>
</ul>
<blockquote>
<p>一个可能的缓解思路是让虚拟化容器提前加载，会增加一点内存开销，但能减少空白频闪。</p>
</blockquote>
<p>一般来说：</p>
<ul>
<li>内容很重（大量图片、复杂控件、阴影/模糊多）：可以把同步频率调低一点。</li>
<li>列表虚拟化强依赖“及时生成下一屏”（例如聊天列表/文件列表）：可以适当提高，但要观察 CPU。</li>
</ul>
<h3 id="5-注意-scrollchanged-状态变更">5) 注意 ScrollChanged 状态变更</h3>
<p>只靠渲染循环还不够，因为用户可以通过滚动条拖动来改变 offset。实现里在&nbsp;<code>OnScrollChanged</code>&nbsp;中做了两件重要的事情：</p>
<ol>
<li>更新逻辑 offset（垂直/水平各自维护）。</li>
<li>如果当前正在平滑滚动，并且变化来自“当前激活方向”，就立刻更新 Transform，让画面位置保持连续。</li>
</ol>
<h3 id="6-横向滚动与-shift-切换">6) 横向滚动与 Shift 切换</h3>
<p>v3 支持横向与纵向两种滚动方向，并且提供了按住 Shift 切换滚动方向的特性。</p>
<h3 id="7-为什么滚动时要临时关闭-hittest">7) 为什么滚动时要临时关闭 HitTest</h3>
<p>渲染循环开始时把&nbsp;<code>IsHitTestVisible</code>&nbsp;设为&nbsp;<code>false</code>，结束时恢复。</p>
<p>高速滚动时，鼠标在大量元素上扫过会触发频繁的命中测试和状态变更（Hover、ToolTip、触发器）。 关闭命中测试能够显著降低这些开销，提升滚动性能。</p>
<p>当然，它也意味着滚动过程中无法点击内容。</p>
<h3 id="8-如何写你自己的物理模型">8) 如何写你自己的物理模型</h3>
<p><code>IScrollPhysics</code>&nbsp;的接口设计简单：</p>
<ul>
<li><code>OnScroll(...)</code>：只负责接收一次输入意图（delta + 是否精确 + 边界 + 时间间隔）。</li>
<li><code>Update(...)</code>：每帧推进到新位置（帧率无关）。</li>
<li><code>IsStable</code>：告诉外部何时可以退出渲染循环。</li>
</ul>
<h2 id="写在最后">写在最后</h2>
<div class="gc-titlebar">
<div class="gc-titlebar-left">
<div class="gc-owner">
<div id="GC8c94u6-avatar" class="gc-avatar"><a href="https://github.com/TwilightLemon/FluentWPFCore" rel="noopener nofollow">TwilightLemon/FluentWpfCore: A WPF library providing core Fluent Design controls, materials, and visual effects.</a></div>
</div>
</div>
</div>
<p>相关组件均开源在 FluentWpfCore 仓库，欢迎 star 和 PR！仓库保持活跃更新。</p>
<p>感谢阅读，文章如有不妥之处，请各位大佬不吝指正！</p>
<p>&nbsp;</p>
<p><img alt="" class="lazyloaded lazyload" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1188749/202407/1188749-20240702112134529-1920703459.png"></p>
<p>&nbsp; 本作品采用&nbsp;<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener nofollow">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>&nbsp;进行许可。欢迎转载、使用、重新发布，但务必保留文章署名TwilightLemon，不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-12-22 17:13">2025-12-22 17:12</span>&nbsp;
<a href="https://www.cnblogs.com/TwilightLemon">TwilightLemon</a>&nbsp;
阅读(<span id="post_view_count">108</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19383555);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19383555', targetLink: 'https://www.cnblogs.com/TwilightLemon/p/19383555', title: 'WPF 使用 RenderTransform 实现高性能平滑滚动的 ScrollViewer' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ 组合数学基础 ]]></title>
    <link>https://www.cnblogs.com/aceS0/p/19383425</link>
    <guid>908749cf8941cc07b3035993833e91b7</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aceS0/p/19383425" title="发布于 2025-12-22 16:57">
    <span role="heading" aria-level="2">组合数学基础</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><s>写了有点久，基本都写得oiwiki上的但自认为写的更好(至少对于我自己的理解来说)</s></p>
<h1 id="定义基础">定义基础</h1>
<h3 id="排列">排列</h3>
<p>从 <span class="math inline">\(n\)</span> 个元素中考虑顺序地选出 <span class="math inline">\(k\)</span> 个元素的方案数，写作 <span class="math inline">\(A_n^k\)</span>。</p>
<p>显然：</p>
<p></p><div class="math display">\[A_n^k = \frac{n!}{(n - k)!}
\]</div><p></p><h4 id="圆上排列">圆上排列</h4>
<p>一个长度为 <span class="math inline">\(n\)</span> 的圆环上选一段长度为 <span class="math inline">\(k\)</span> 的段的排列数，写作 <span class="math inline">\(Q_n^k\)</span> 。</p>
<p>当 $ n = k <span class="math inline">\(，显然有 ：\)</span>Q_n^n = \frac{A_n^n}{n}$</p>
<p>推广到  ，于是有：<span class="math inline">\(Q_n^k = \frac{A_n^k}{k}\)</span></p>
<h3 id="组合">组合</h3>
<p>从 <span class="math inline">\(n\)</span> 个元素中不计顺序地选出 <span class="math inline">\(k\)</span> 个元素的方案数，写作 <span class="math inline">\(C_n^k\)</span> 或 <span class="math inline">\(\binom{n}{k}\)</span> 。</p>
<p>有：</p>
<p></p><div class="math display">\[\binom{n}{k} = \frac{n!}{(n - k)!k!}
\]</div><p></p><h5 id="杨辉三角">杨辉三角</h5>
<p>$ \binom{i}{j} $ 的值实际上等于杨辉三角的第 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列。（若不存在则等于 <span class="math inline">\(0\)</span>）</p>
<h1 id="插板法">插板法</h1>
<h3 id="技巧的实现">技巧的实现</h3>
<p>现有 <span class="math inline">\(n\)</span> 个 完全相同 的元素，要求将其分为 <span class="math inline">\(k\)</span> 组，保证每组至少有一个元素，一共有多少种分法？</p>
<p>考虑拿 <span class="math inline">\(k - 1\)</span> 块板子插入到 <span class="math inline">\(n\)</span> 个元素两两形成的 <span class="math inline">\(n - 1\)</span> 个空里面，答案：</p>
<p></p><div class="math display">\[\binom{n - 1}{k - 1}
\]</div><p></p><h5 id="本质">本质</h5>
<p>求解 $x_1 + x_2 + x_3 + \cdots + x_k = n $的正整数解的<strong>组数</strong>。</p>
<h4 id="变式">变式</h4>
<h5 id="允许空集">允许空集：</h5>
<p>等于再加了 <span class="math inline">\(k\)</span> 个空能拿来插以作为空集。</p>
<p></p><div class="math display">\[\binom{n + k - 1}{k - 1} = \binom{n + k - 1}{n}
\]</div><p></p><p>*显然对于组合数，有: <span class="math inline">\(\binom{n}{m} = \binom{n}{n - m}\)</span></p>
<p>其本质可以扩展到求解 $x_1 + x_2 + x_3 + \cdots + x_k = n $的<strong>非负整数解</strong>的组数。</p>
<h5 id="对于每个--都有各自的下界即求-x_1--x_2--x_3--cdots--x_k--n--且-">对于每个 <span class="math inline">\(x_i\)</span> 都有各自的下界，即求 $x_1 + x_2 + x_3 + \cdots + x_k = n $ 且 <span class="math inline">\(x_i \ge a_i\)</span>：</h5>
<p>显然可以将 <span class="math inline">\(n\)</span> 减去 <span class="math inline">\(\sum a_i\)</span>，即每个 <span class="math inline">\(x_i\)</span> 都先取一个 <span class="math inline">\(a_i\)</span>。<br>
然后对于剩下的就转换成了允许空集的情况，显然有答案：</p>
<p></p><div class="math display">\[\binom{n + k - \sum a_i - 1}{n - \sum a_i}
\]</div><p></p><h5 id="不相邻排列">不相邻排列</h5>
<p>从 <span class="math inline">\(1\)</span> ~ <span class="math inline">\(n\)</span> 中取 <span class="math inline">\(k\)</span> 个数不存在两个相邻的数字的方案数。</p>
<p>可以理解为于 <span class="math inline">\(n\)</span> 中刨去 <span class="math inline">\(k - 1\)</span> 个数，再选 <span class="math inline">\(k\)</span> 个数。刨去的 <span class="math inline">\(k - 1\)</span> 个数使得这 <span class="math inline">\(k\)</span> 个数中每两个数间的其中一个数能被刨去，这样不论怎么选都是合法的。</p>
<p></p><div class="math display">\[\binom{n - (k - 1)}{k} = \binom{n - k + 1}{k}
\]</div><p></p><h1 id="进阶结论">进阶结论</h1>
<h3 id="多重集排列数-多重组合数">多重集排列数 （多重组合数）</h3>
<p>这两个名字表示的一个东西，都是一个多重集（不是集合，内部有序且有重复数字）的排列个数。</p>
<p>对于一个多重集 <span class="math inline">\(S = {n_1 \cdot a_1, n_2 \cdot a_2, \cdots, n_k \cdot a_k}\)</span>，内含 <span class="math inline">\(n_i\)</span> 个 <span class="math inline">\(a_i\)</span>，其排列个数为：</p>
<p></p><div class="math display">\[\binom{n}{n_1, n_2, \cdots, n_k} = \frac{n!}{n_1! n_2! \cdots n_k!} = \frac{n!}{\Pi_{i = 1}^{k} n_i!}
\]</div><p></p><p>先算出所有元素的排列数，再一次除以每种元素内部的排列数。</p>
<h3 id="多重集的组合数">多重集的组合数</h3>
<p>等价于求解 $x_1 + x_2 + x_3 + \cdots + x_k = n $ 的非负整数解的组数<br>
(<span class="math inline">\(\binom{n + k - 1}{n}\)</span>)</p>
<h3 id="二项式定理">二项式定理</h3>
<p></p><div class="math display">\[(a + b) ^ n = \sum_{i = 0}^{n} \binom{n}{i} a ^ i b ^ {n - i} 
\]</div><p></p><p>证明：数学归纳法</p>
<p>能证明到：</p>
<p></p><div class="math display">\[\binom{n}{k} +  \binom{n}{k - 1} = \binom{n + 1}{k}
\]</div><p></p><h5 id="扩展至多项式">扩展至多项式：</h5>
<p></p><div class="math display">\[(x_1 + x_2 + \cdots + x_t) ^ n = \sum_{x_1 + x_2 + x_3 + \cdots + x_k = n 的非负整数解} \binom{n}{n_1, n_2, \cdots, n_k} x_1^{n_1}x_2^{n_2}...
\]</div><p></p><p>当 <span class="math inline">\(x_1 = x_2 = \cdots = x_t = 1\)</span>，</p>
<p></p><div class="math display">\[\sum \binom{n}{n_1, n_2, \cdots, n_k} = t ^ n
\]</div><p></p><h3 id="各种推论">各种推论</h3>
<h5 id="1">1.</h5>
<p>对于定义，显然：</p>
<p></p><div class="math display">\[\binom{n}{k} = \frac{n}{k} \binom{n - 1}{k - 1}
\]</div><p></p><p>可以将组合数拆乘多项式进行证明</p>
<h5 id="2">2.</h5>
<p>对于从 <span class="math inline">\(n\)</span> 中取 <span class="math inline">\(m\)</span> 个，对于第 <span class="math inline">\(m\)</span> 个数取不取分类，根据定义显然有：</p>
<p></p><div class="math display">\[\binom{n}{m} = \binom{n - 1}{m} + \binom{n - 1}{m - 1}
\]</div><p></p><h5 id="3">3.</h5>
<p>我们假设要从 <span class="math inline">\(n\)</span> 个数中选若干个数(也可能不选)。</p>
<p>对于枚举选多少个来算答案，显然有:</p>
<p></p><div class="math display">\[\sum_{i = 0}^{n} \binom{n}{i}
\]</div><p></p><p>对于枚举每一为选不选，显然有：</p>
<p></p><div class="math display">\[2 ^ n
\]</div><p></p><p>于是我们得到了：</p>
<p></p><div class="math display">\[\sum_{i = 0}^{n} \binom{n}{i} = 2 ^ n
\]</div><p></p><p>不难发现这个是<strong>二项式定理</strong>在两项皆为的常数 <span class="math inline">\(1\)</span> 时的结论。</p>
<h5 id="4">4.</h5>
<p>考虑另一种二项式定理的特殊情况，两项分别为 <span class="math inline">\(1\)</span> &amp; <span class="math inline">\(-1\)</span>，<span class="math inline">\(n = 0\)</span>，显然有：$ \sum_{i=0}^{n} (-1)^{i} \binom{n}{i} = [n = 0]$</p>
<h5 id="5-">5. <span class="math inline">\(\mathit{Vandermonde} 卷积\)</span></h5>
<p>也叫范德蒙德恒等式。</p>
<p></p><div class="math display">\[\binom{n + m}{k} = \sum_{i = 0}^{k} \binom{n}{i}\binom{m}{k - i}
\]</div><p></p><p>证明：<br>
对于一个集合大小为 <span class="math inline">\(n\)</span> 要选 <span class="math inline">\(k\)</span> 个元素，可以将其拆成两个大小分别为 <span class="math inline">\(n\)</span> 与 <span class="math inline">\(m\)</span> 的集合，分别枚举两个集合各选多少。</p>
<h5 id="6">6.</h5>
<p>当范德蒙德卷积中，<span class="math inline">\(n = m = k\)</span> 时，显然有：</p>
<p></p><div class="math display">\[\binom{2n}{n} = \sum_{i = 0}^n\binom{n}{i}\binom{n}{n - i}
\]</div><p></p><p>即：</p>
<p></p><div class="math display">\[\binom{2n}{n} = \sum_{i = 0}^n\binom{n}{i}^2
\]</div><p></p><h5 id="7">7.</h5>
<p></p><div class="math display">\[\sum_{i = 0} ^ n i \binom{n}{i} = n2^{n - 1}
\]</div><p></p><p>证明：<br>
观察到等式的右边与3式右边的等式的求导形式一样，考虑对3式等式左边也进行求导。</p>
<p>考虑对二项式定理左边求导，并带入 <span class="math inline">\(b = 1\)</span>：</p>
<p></p><div class="math display">\[(\sum_{i = 0}^ n \binom{n}{i} a^i) ^\prime = \sum_{i = 0}^n \binom{n}{i}ia^{i - 1} 
\]</div><p></p><p>再将 <span class="math inline">\(a = 1\)</span> 带入：</p>
<p></p><div class="math display">\[(\sum_{i = 0}^ n \binom{n}{i} a^i) ^\prime = \sum_{i = 0}^n \binom{n}{i}ia^{i - 1} = \sum_{i = 0}^n i \binom{n}{i}
\]</div><p></p><p>得证。</p>
<h5 id="8">8.</h5>
<p></p><div class="math display">\[\sum_{i=0}^{n} i^2 \binom{n}{i} = n{(n+1)}{2^{n-2}}
\]</div><p></p><p>类比7式，再导一次(?)。</p>
<h5 id="9朱世杰恒等式">9.朱世杰恒等式</h5>
<p></p><div class="math display">\[\sum_{l=0}^{n} \binom{l}{k} = \binom{n+1}{k+1}
\]</div><p></p><p>这其实是组合数在使用<strong>杨辉三角</strong>进行求值的形式。（可以画个图看一下）</p>
<h5 id="10">10.</h5>
<p>若 <span class="math inline">\(F_x\)</span> 表示斐波那契数列第 <span class="math inline">\(x\)</span> 项，则有：</p>
<p></p><div class="math display">\[\sum_{i=0}^{n} \binom{n-i}{i} = F_{n+1}
\]</div><p></p><p>考虑数学归纳法。</p>
<p>当 <span class="math inline">\(k = 0, 1\)</span>时，<span class="math inline">\(F_0 = 1, F_1 = 1\)</span>，显然成立。</p>
<p>当 <span class="math inline">\(k &gt; 1\)</span>，假设等式成立。</p>
<p></p><div class="math display">\[\therefore F_{k - 1} = \sum_{i = 0}^{k - 1} \binom{k - i - 1}{i} \\
F_{k} = \sum_{i = 0}^{k} \binom{k - i}{i}\\
F_{k + 1} = \sum_{i = 0}^{k + 1} \binom{k - i + 1}{i}
\]</div><p></p><p></p><div class="math display">\[\therefore F_{k + 1} = \sum_{i = 0}^{k + 1} \binom{k - i + 1}{i}\\
= 1 + \sum_{i = 1}^{k + 1} \binom{k + 1 - i}{i}\\
= 1+ \sum_{i = 1}^{k + 1} \binom{k - i}{i - 1} + \sum_{i = 1}^{k + 1} \binom{k + 1 - i}{i - 1}\\
\]</div><p></p><p></p><div class="math display">\[\therefore F_{k + 1} = 1 + \sum_{i = 0}^{k} \binom{k - i}{i} + \sum_{i = 0}^{k + 1} \binom{k - i}{i - 1} - 1\\
= \sum_{i = 0}^{k} \binom{k - i}{i} + \sum_{i = 0}^{k + 1} \binom{k - i}{i - 1}
\]</div><p></p><p></p><div class="math display">\[\because F_{k - 1} = \sum_{i = 0}^{k - 1} \binom{k - i - 1}{i} \\
F_{k} = \sum_{i = 0}^{k} \binom{k - i}{i} \\
F_{k + 1} = F_k + F_{k - 1}
\]</div><p></p><p></p><div class="math display">\[\therefore 原等式成立
\]</div><p></p><h5 id="11李善兰恒等式">11.李善兰恒等式</h5>
<p></p><div class="math display">\[\binom{n + k}{n} ^ 2 = \sum_{j = 0}^k \binom{k}{j}^2 \binom{n + 2k - j}{2k}
\]</div><p></p><p>证明：范德蒙德卷积，但这里太窄写不下了。 <s>（其实是不会）</s></p>
<p>当然，杨辉三角也可以证明。</p>
<h1 id="mathitcatalan数-">$\mathit{Catalan}数 $</h1>
<ol>
<li></li>
</ol>
<p></p><div class="math display">\[C_n = \frac{1}{n + 1} \cdot \binom{2n}{n} = \frac{(2n)!}{n! \cdot (n + 1)!}, \quad n \geq 0.
\]</div><p></p><ol start="2">
<li></li>
</ol>
<p></p><div class="math display">\[C_n = \binom{2n}{n} - \binom{2n}{n + 1}, \quad n \geq 0.
\]</div><p></p><ol start="3">
<li></li>
</ol>
<p></p><div class="math display">\[C_n = \frac{4n - 2}{n + 1} C_{n - 1}, \quad n &gt; 0, \quad C_0 = 1.
\]</div><p></p><ol start="4">
<li></li>
</ol>
<p></p><div class="math display">\[C_n = \sum_{i=0}^{n-1}C_iC_{n-i-1}, \quad n &gt; 0, \quad C_0 = 1.
\]</div><p></p><p>作用：将形如3式或是4式的递推转换为1式进行快速求解。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.005555555555555556" data-date-updated="2025-12-22 17:05">2025-12-22 16:57</span>&nbsp;
<a href="https://www.cnblogs.com/aceS0">ACehomoxue</a>&nbsp;
阅读(<span id="post_view_count">26</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19383425);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19383425', targetLink: 'https://www.cnblogs.com/aceS0/p/19383425', title: '组合数学基础' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ 如何改变管理者的懒惰！ ]]></title>
    <link>https://www.cnblogs.com/zer0Black/p/19383224</link>
    <guid>319be3715b4719b35bf2e11a6ac5e39a</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zer0Black/p/19383224" title="发布于 2025-12-22 16:35">
    <span role="heading" aria-level="2">如何改变管理者的懒惰！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>我做了快8年技术管理工作，最近1年感受到外部业务的持续下滑压力，和内部团队的问题频发。觉察到问题比较严峻</p>
<p>仔细回想在6年前定好团队的架构，执行流程后，用2年时间把团队架构完善好，然后每年都是简单的小修小补。再也没有投入完整的时间考虑管理工作本身。已经3~4年没有仔细的考虑过团队的改善和优化了</p>
<p>写下此文，是剖析自己的问题，以及自己对后续工作的改进思考</p>
<h2 id="什么是管理者的懒惰">什么是管理者的懒惰</h2>
<p>健康的管理者已经不在事事亲力亲为，到处救火了。但管理是一个很玄妙的东西，做了不等于做好了！</p>
<p>通常初期做好一些基本的流程之后，团队就基本可以自己跑起来了。剩下的问题都是疑难杂症，比如团队不学习、团队之间的一些灰色地带怎么处理、团队氛围怎么提高等等</p>
<p>疑难杂症不处理，团队也能运行。但如果不进行持续管理和改善，久而久之，团队的执行力就会逐步下滑，早期的问题会越放越大，甚至可能团队间的矛盾会越来越深</p>
<p>管理不持续，等于没有管理。这就是<strong>管理者的懒惰</strong>。这种情况下无论管理者做再多执行层面，基础层面的工作，也没办法拉回来已经跑偏的团队</p>
<h2 id="怎么改变自身的懒惰">怎么改变自身的懒惰</h2>
<h3 id="调整心理">调整心理</h3>
<p>人都害怕麻烦，管理者也不例外。不处理疑难杂症的根因，在于不知从何下手和对畏难心理。从我自身来说，这两者都有。这也就是懒了</p>
<p>我通常会想：对管理的重新改进，可能意味着要打破现有的体系。但是现有的体系跑的好好的，咱去打破他干嘛呢，会不会变的更糟？</p>
<p>另外就是流程的改进影响的不是你自己，而是整个团队，设计的不好祸害的人太多。所以我在这方面特别谨慎</p>
<p>总之不管如何，想要改变团队，从改变自己做起。大的变革叫革命，小的变革叫优化。所以调整自己的心态，从小的优化做起。也把自己的时间算算账，多投入到管理工作一些。</p>
<p>不管怎么样，改变团队先从改变自己做起！</p>
<h3 id="梳理现有工作">梳理现有工作</h3>
<p>要把管理工作抓起来，首先要把现有的日常工作梳理清楚。注意，这里必须是日常工作的细粒度给整理出来。不要一概而论的如商务工作，项目跟进等等太粗放的维度。这是为了后续把能拆出去给别人的工作拆出去，把自己更多的时间留给管理上的改进。</p>
<p>我梳理自己的现有工作如下：</p>
<h5 id="商务方面">商务方面</h5>
<p>（1）日常投标商务文件安排和检查<br>
（2）合同管理（编写、安排盖章、检查）<br>
（3）发票开票和付款处理<br>
（4）项目售前沟通，出方案/报价<br>
（6）协助客户处理商务问题<br>
（7）找客户要应收<br>
（8）所有报价管理</p>
<h5 id="研发工作">研发工作</h5>
<p>（1）非正常项目交付文件编写<br>
（2）项目验收文件编写和会议参加<br>
（3）少部分项目架构思考编写<br>
（4）部分技术难题解决<br>
（5）部署工作标准化推进<br>
（6）少部分历史项目自己开发变更需求<br>
（7）少部分历史项目自己运维<br>
（8）硬件开发工作自己完成<br>
（9）嵌入式开发工作自己完成<br>
（10）部分项目带队进行需求调研<br>
（11）SSL证书申请<br>
（12）给客户编写专利<br>
（13）产品后续推进方向的统一规划<br>
（14）统一开发框架思考和上手修改</p>
<h5 id="交付工作">交付工作</h5>
<p>（1）交付方案设计（装修CAD）<br>
（2）交付计划安排<br>
（3）采购清单项梳理<br>
（4）交付过程中大项采购谈判与商务合同处理<br>
（5）盯大项采购交货<br>
（6）带队进行现场交付<br>
（7）交付验收资料准备</p>
<h5 id="服务器工作">服务器工作</h5>
<p>（1）检查研发反馈的服务器问题<br>
（2）内外网映射问题上手检查<br>
（3）研发临时需要的服务器环境准备<br>
（4）考虑服务器资源的分配和采购</p>
<h5 id="管理工作">管理工作</h5>
<p>（1）项目实施工作安排<br>
（2）交付工作流程梳理<br>
（3）各项工作的标准化SOP<br>
（4）月度绩效评估<br>
（5）月度目标制定评估（完成的不好）</p>
<h5 id="应该做没做好的工作">应该做没做好的工作</h5>
<p>（1）研发过程执行检查<br>
（2）售前可研工作的标准化<br>
（3）项目交付标准SOP流程撰写<br>
（4）SOP的持续宣贯<br>
（5）团队内部持续性培训<br>
（6）产品后续推进方向的统一规划</p>
<h3 id="拆分可标准化工作">拆分可标准化工作</h3>
<p>要把更多的时间腾出来做管理，就需要把既有的非本人必须做的事情标准化，然后分派出去。哪些是可拆分和标准化的工作呢？有这么几类：<br>
（1）不是你主抓，属于日常琐事的（如SSL证书申请）<br>
（2）明显已经可以界定不属于你的执行工作<br>
（3）可以教会别人的标准化执行工作（如简单的CAD装修图绘制）<br>
（4）能形成SOP由下属完成的工作（如交付计划执行、采购清单项梳理等）</p>
<p>以上任何事情，不管有多简单，都要形成SOP的文档。有人不会，简单的甩文档出去。复杂的对着文档实操讲解一遍。有SOP非常重要，这是一个团队能持续性标准化产出的关键，也是新人能快速上手工作的关键</p>
<p>经过梳理，可拆分出来给别人的工作如下：</p>
<h5 id="商务方面-1">商务方面</h5>
<p>（1）日常投标商务文件安排和检查 —— 编写SOP和反馈机制、相互检查机制，给出去<br>
（2）合同管理（编写、安排盖章、检查） —— 编写和盖章给出去，检查保留！<br>
（3）发票开票和付款处理 —— 编写SOP后给出去<br>
（4）项目售前沟通，出方案/报价<br>
（6）协助客户处理商务问题<br>
（7）找客户要应收<br>
（8）所有报价管理</p>
<h5 id="研发工作-1">研发工作</h5>
<p>（1）非正常项目交付文件编写 —— 给出去<br>
（2）项目验收文件编写和会议参加<br>
（3）少部分项目架构思考编写 —— 让自己保持技术敏感度，保留！<br>
（4）部分技术难题解决 —— 让自己保持技术敏感度，保留！<br>
（5）部署工作标准化推进<br>
（6）少部分历史项目自己开发变更需求 —— 给出去<br>
（7）少部分历史项目自己运维 —— 给出去<br>
（8）硬件开发工作自己完成 —— 无人可用，暂时保留！<br>
（9）嵌入式开发工作自己完成 —— 无人可用，暂时保留！<br>
（10）部分项目带队进行需求调研 —— 让自己对一线保持认知，保留！<br>
（11）SSL证书申请 —— 编写SOP后给出去<br>
（12）给客户编写专利 —— 指导，并给出去<br>
（13）统一开发框架思考和上手修改 —— 思考和细节整理，修改给出去</p>
<h5 id="交付工作-1">交付工作</h5>
<p>（1）交付方案设计（装修CAD）—— 无人可用，暂时保留！<br>
（2）交付计划安排 —— 编写SOP，指导并给出去<br>
（3）采购清单项梳理 —— 编写SOP，指导并给出去<br>
（4）交付过程中大项采购谈判与商务合同处理<br>
（5）盯大项采购交货 —— 做好安排，给出去<br>
（6）带队进行现场交付 —— 短期内暂时保留，团队稳定后给出去<br>
（7）交付验收资料准备 —— 准备给出去，保留检查工作</p>
<h5 id="服务器工作-1">服务器工作</h5>
<p>（1）检查研发反馈的服务器问题 —— 给出去<br>
（2）内外网映射问题上手检查 —— 给出去<br>
（3）研发临时需要的服务器环境准备 —— 给出去<br>
（4）考虑服务器资源的分配和采购 —— 保持对公司硬件资源敏感度，保留！</p>
<h5 id="管理工作-1">管理工作</h5>
<p>（1）项目实施工作安排 —— 强化本项工作，提高频次，保留！<br>
（2）交付工作流程梳理 —— 尽快完成，持续迭代，保留！<br>
（3）各项工作的标准化SOP —— 尽快完成，持续迭代，保留！<br>
（4）月度绩效评估  —— 重新梳理SOP，提高本项工作质量<br>
（5）月度目标制定评估（完成的不好） —— 重新梳理SOP，提高本项工作质量</p>
<h5 id="应该做没做好的工作-1">应该做没做好的工作</h5>
<p>（1）研发过程执行检查 —— 建立管理时间盒，为该项投入时间<br>
（2）售前可研工作的标准化—— 尽快完成，持续迭代，保留！<br>
（3）项目交付标准SOP流程撰写 —— 尽快完成，持续迭代，保留！<br>
（4）SOP的持续宣贯 —— 建立管理时间盒，为该项投入时间<br>
（5）团队内部持续性培训 —— 建立管理时间盒，为该项投入时间<br>
（6）产品后续推进方向的统一规划 —— 建立管理时间盒，为该项投入时间</p>
<p>根据以上评估，以我的情况为例，共计43项工作。</p>
<ul>
<li>短期内给出去的：15项</li>
<li>优化团队结构后可给出去的：4项</li>
<li>剩余本人工作项：<strong>24项</strong></li>
</ul>
<h3 id="重构管理时间盒">重构管理时间盒</h3>
<p>管理时间盒的目标是为了把日常要做的管理动作加到每月的行动计划中。通过行动计划固定管理动作，防止少做漏做不做。</p>
<p>在我之前给自己列出来的所有工作中，SOP等工作不属于日常工作，而属于一年一次或者半年一次的一次性工作，需要集中精力花大把时间来解决。</p>
<p>而研发过程执行检查、月度绩效/目标评估、团队持续性培训等则属于日常工作中必备的管理动作。先把管理工作确定了，然后再把其他的工作按照重要度安插在整月工作中。</p>
<p>在管理时间盒中，我仅把日常性管理工作加入时间盒，制定好完成节点和周期。其他日常性工作视情况进行安插。</p>
<p>我给自己定义的管理时间盒如下：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>管理方法</th>
<th>频次</th>
<th>具体时间</th>
<th>单次时长</th>
</tr>
</thead>
<tbody>
<tr>
<td>目标</td>
<td>月度绩效/目标评估</td>
<td>每月一次</td>
<td>每月5日，假期顺延</td>
<td>60分钟</td>
</tr>
<tr>
<td>计划</td>
<td>制定本月非日常工作（大项）的工作安排</td>
<td>每月一次</td>
<td>每月第一天，假期顺延</td>
<td>40分钟</td>
</tr>
<tr>
<td>执行</td>
<td>安排团队开团队晨会，随机参加一个</td>
<td>每周一次</td>
<td>每周二，出差顺延</td>
<td>15分钟</td>
</tr>
<tr>
<td>执行</td>
<td>项目随机检查</td>
<td>每月一次</td>
<td>每月20日，随机检查一个项目。检查计划制定、过程执行</td>
<td>60分钟</td>
</tr>
<tr>
<td>检查</td>
<td>随机找一个一线同事听取最近的用户反馈，项目开发反馈</td>
<td>每月一次</td>
<td>每月20日，假期/出差顺延</td>
<td>40分钟</td>
</tr>
<tr>
<td>改善</td>
<td>自身工作复盘</td>
<td>每月一次</td>
<td>每月最后一天，假期顺延</td>
<td>30分钟</td>
</tr>
</tbody>
</table>
<h3 id="监督执行">监督执行</h3>
<p>坚持执行自己定好的管理时间盒是最难的一步。如开头所说，人都有惰性，像管理这种对自己费时费力，对同事来说也出力不讨好的事情，很容易被自己放弃</p>
<p>我之前就经常以出差、杂事太多、当前有非常重要的工作等原因，把管理工作推迟、进而放弃。所以我计划采取两个常规步骤：（1）提醒；（2）自我激励/惩罚</p>
<p>提醒工作采用GTD工具，制定好执行时间和周期循环提醒。</p>
<p>自我激励/惩罚在每月月初制定计划的时候一同写好，并把计划和奖惩贴到工作提醒自己。</p>
<p>以上！希望我们都变成更好的自己</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-12-22 16:35">2025-12-22 16:35</span>&nbsp;
<a href="https://www.cnblogs.com/zer0Black">锅总的程序人生</a>&nbsp;
阅读(<span id="post_view_count">88</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19383224);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19383224', targetLink: 'https://www.cnblogs.com/zer0Black/p/19383224', title: '如何改变管理者的懒惰！' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ Unicode中如何表示未收录的生僻字 --浅谈IDS ]]></title>
    <link>https://www.cnblogs.com/electrolyte/p/19384748</link>
    <guid>4dc46233306e48c8231464c17871974a</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/electrolyte/p/19384748" title="发布于 2025-12-22 23:37">
    <span role="heading" aria-level="2">Unicode中如何表示未收录的生僻字 --浅谈IDS</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Unicode中的字符结构表示</p>
<p>Unicode标准是一个全球普遍接受的文字编码标准，它的理想是用一个巨大的字符集来表示世界上所有的字符，这样让全球的文字交流置于同一种体系之下，避免以前出现过的不同国家不同字符集互不统一造成的乱码，极大方便了全球的电子信息交流。</p>
<p>汉字是Unicode标准中内容最为庞大的子字符集，与英语等不同，汉字是每个字符有自己独立的意思，因此占用的字符数量巨大。目前Unicode 17标准中有15万个字符，中日韩统一汉字就占到了10万个以上。</p>
<p>但是即使是收字量如此之大，目前也无法涵盖汉字的所有字符，特别是手书时代有无数种不同的汉字变体或自造字，因此有大量字符是目前没有收录过的。另外还有一些新造的少量字符用于科技领域。这些未收入标准中的字符，就没有规定它们的字形。那这样的字符，应该怎么在电脑或手机等文本中表示它们呢？（文本方式之外，还是有很多办法的，图片，矢量图形，特殊的文件格式表示等等，但文本是最简洁最易交流的方式，使用频繁，甚至连化学结构的表达都有人发明SMILES文本来表达）。</p>
<p>为了在电脑时代表示这些字符，以前用过这样的用法，比如歘字在早期的字体中不存在，为了表示这个字，我们就用文字表示为“左焱右欠”，或者是“焱欠”，这是不得已的情况下变通表示，让读者能够理解的一种无奈的方法，它的缺点就是不太好表达更为复杂的结构。</p>
<p>因此，Unicode中提供了一种类似的方法，英文叫做Ideographic Description Characters, 中文翻译成 表意文字描述符，通过这些表示结构的字符与汉字部件结合来表示一个字的结构。因为定义了专门的表示结构的字符，其表达能力就大大增强了。</p>
<p>首先看标准中提供的表示结构的专用符号（来自wiki百科）</p>
<p><img alt="IDS 定义" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1298095/202512/1298095-20251222233558340-1090135818.png" class="lazyload"></p>
<p>这种表示法的结构，是先放一个结构符号，后面提供表示结构的部件。</p>
<p>比如前面提到的歘字，用IDS来表示表示，就是 ⿰焱欠，第一个字符表示这个字是左右结构，相当于文本描述的 左X右Y；接着是从左到右（或从上到下）的部件，分别是焱、欠。这样读者就可以明白，这个表示一个组合字， 左右结构，从左到右分别是焱和欠。</p>
<p>当然，有些字形比较复杂，可能由多个部件构成，需要更进一步的拆分才能表达出来，因此用IDS的表示法可以进行嵌套表示。比如焱，如果没有这个字符，这种品字型的结构，可以把它拆分为上下结构，下部继续拆解为左右结构。因此 ⿰焱欠 可以继续写成</p>
<p>⿰⿱火⿰火火欠。</p>
<p>这种结构的解析顺序，从左到右，没有括号来表达优先级。上面这串字符，按从左到右解读，意思是说，整个字是左右结构（⿰）；左边是上下结构（⿱），上面部件是火字，左边下面部件是左右组合的结构（⿰火火）。最后，右边是个欠字。</p>
<p>解读时要特别注意表示的结构中有几个部件，后面就要对应消耗几个部件。上例中，左边上部消耗一个火字，下面是左右结构，又消耗两个火字。最后剩下的欠字，对应着左右结构中的右边部件。</p>
<p>你肯定能明白，拆解的粒度与方法并不一定是唯一的，选择的部件也未必是唯一的，只要能准确表示结构就行。</p>
<p>这种表示方法开始用时，如果结构比如复杂可能不太好懂，需要多练习一下。为了方便练习，有个网站<a href="http://zi.tools" target="_blank" rel="noopener nofollow">zi.tools</a>提供了这种表示法的练习工具。有意思的是，这个网站还提供了检索具有特定结构的字符的功能，贴个图大家就很容易明白了，用？代表搜索的部件即可。</p>
<p><img alt="通过IDS查询类似结构的汉字" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1298095/202512/1298095-20251222233637085-124584678.png" class="lazyload"></p>
<p>这里隐藏了一个问题，即这些表示结构的符号如何输入，最简单的方法就是你在zi.tools这个网站上把字拆好，然后把右边的框内生成的文字复制过来。我猜测一般的输入法应该不包括这种不太常用的符号。</p>
<p>最后，展示一下𰻝𰻝面的𰻝字的IDS表示，注意这里是文本表示：</p>
<p>⿺辶⿳穴⿲月⿱⿲幺言幺⿲长马长刂心</p>
<p>下面是拆解时的截图：</p>
<p><img alt="Biang字的IDS表示" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1298095/202512/1298095-20251222235226675-33799755.png" class="lazyload"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.013888888888888888" data-date-updated="2025-12-22 23:57">2025-12-22 23:37</span>&nbsp;
<a href="https://www.cnblogs.com/electrolyte">dingxianghuan</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19384748);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19384748', targetLink: 'https://www.cnblogs.com/electrolyte/p/19384748', title: 'Unicode中如何表示未收录的生僻字 --浅谈IDS' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ Flink源码阅读：集群启动 ]]></title>
    <link>https://www.cnblogs.com/Jackeyzhe/p/19384633</link>
    <guid>d9127f876e0823c699dcd2b74b4260d9</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Jackeyzhe/p/19384633" title="发布于 2025-12-22 22:44">
    <span role="heading" aria-level="2">Flink源码阅读：集群启动</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1828322/202512/1828322-20251222224421655-1662683197.png" alt="Flink源码阅读：集群启动" class="desc_img">
        前文中，我们已经了解了 Flink 的三种执行图是怎么生成的。今天继续看一下 Flink 集群是如何启动的。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>前文中，我们已经了解了 Flink 的三种执行图是怎么生成的。今天继续看一下 Flink 集群是如何启动的。</p>
<h3 id="启动脚本">启动脚本</h3>
<p>集群启动脚本的位置在：</p>
<pre><code class="language-bash">flink-dist/src/main/flink-bin/bin/start-cluster.sh
</code></pre>
<p>脚本会负责启动 JobManager 和 TaskManager，我们主要关注 standalone 启动模式，具体的流程见下图。</p>
<p><img alt="startcluster" loading="lazy" data-src="https://res.cloudinary.com/dxydgihag/image/upload/v1764258366/Blog/flink/11/start-cluster.png" class="lazyload"></p>
<p>从图中可以看出 JobManager 是通过 jobmanager.sh 文件启动的，TaskManager 是通过taskmanager.sh 启动的，两者都调用了 flink-daemon.sh，通过传递不同的参数，最终运行不同的 Java 类。</p>
<pre><code class="language-bash">case $DAEMON in
    (taskexecutor)
        CLASS_TO_RUN=org.apache.flink.runtime.taskexecutor.TaskManagerRunner
    ;;

    (zookeeper)
        CLASS_TO_RUN=org.apache.flink.runtime.zookeeper.FlinkZooKeeperQuorumPeer
    ;;

    (historyserver)
        CLASS_TO_RUN=org.apache.flink.runtime.webmonitor.history.HistoryServer
    ;;

    (standalonesession)
        CLASS_TO_RUN=org.apache.flink.runtime.entrypoint.StandaloneSessionClusterEntrypoint
    ;;

    (standalonejob)
        CLASS_TO_RUN=org.apache.flink.container.entrypoint.StandaloneApplicationClusterEntryPoint
    ;;

    (sql-gateway)
        CLASS_TO_RUN=org.apache.flink.table.gateway.SqlGateway
        SQL_GATEWAY_CLASSPATH="`findSqlGatewayJar`":"`findFlinkPythonJar`"
    ;;

    (*)
        echo "Unknown daemon '${DAEMON}'. $USAGE."
        exit 1
    ;;
esac
</code></pre>
<h3 id="jobmanager-启动流程">JobManager 启动流程</h3>
<p>在 StandaloneSessionClusterEntrypoint 的 main 方法中，主要就是加载各种配置和环境变量，然后调用 ClusterEntrypoint.runClusterEntrypoint 来启动集群。跟着调用链一直找到 ClusterEntrypoint.runCluster 方法，这里会启动 ResourceManager、DispatcherRunner 等组件。</p>
<pre><code class="language-java">private void runCluster(Configuration configuration, PluginManager pluginManager)
        throws Exception {
    synchronized (lock) {
        // 初始化各种服务
        initializeServices(configuration, pluginManager);

        // 创建 DispatcherResourceManagerComponentFactory，
        // 包含了三个核心组件的 Factory
        // DispatcherRunnerFactory、ResourceManagerFactory、RestEndpointFactory
        final DispatcherResourceManagerComponentFactory
                dispatcherResourceManagerComponentFactory =
                        createDispatcherResourceManagerComponentFactory(configuration);

        // 启动 ResourceManager、DispatcherRunner、WebMonitorEndpoint
        clusterComponent =
                dispatcherResourceManagerComponentFactory.create(
                        configuration,
                        resourceId.unwrap(),
                        ioExecutor,
                        commonRpcService,
                        haServices,
                        blobServer,
                        heartbeatServices,
                        delegationTokenManager,
                        metricRegistry,
                        executionGraphInfoStore,
                        new RpcMetricQueryServiceRetriever(
                                metricRegistry.getMetricQueryServiceRpcService()),
                        failureEnrichers,
                        this);

        // 关闭服务
        clusterComponent
                .getShutDownFuture()
                .whenComplete(
                        (ApplicationStatus applicationStatus, Throwable throwable) -&gt; {
                            if (throwable != null) {
                                shutDownAsync(
                                        ApplicationStatus.UNKNOWN,
                                        ShutdownBehaviour.GRACEFUL_SHUTDOWN,
                                        ExceptionUtils.stringifyException(throwable),
                                        false);
                            } else {
                                // This is the general shutdown path. If a separate more
                                // specific shutdown was
                                // already triggered, this will do nothing
                                shutDownAsync(
                                        applicationStatus,
                                        ShutdownBehaviour.GRACEFUL_SHUTDOWN,
                                        null,
                                        true);
                            }
                        });
    }
}
</code></pre>
<p>下面来详细看一下这几个方法， initializeServices 就是负责初始化各种服务，有几个比较重要的可以着重关注下：</p>
<pre><code class="language-java">// 初始化并启动一个通用的 RPC Service
commonRpcService = RpcUtils.createRemoteRpcService(...);

// 创建一个 IO 线程池，线程数量位 CPU 核数 * 4
ioExecutor = Executors.newFixedThreadPool(...);

// 创建 HA 服务组件，根据配置初始化 Standalone、ZK、K8S 三种
haServices = createHaServices(configuration, ioExecutor, rpcSystem);

// 创建并启动 blobServer,blobServer 可以理解为是 Flink 内部的
blobServer = BlobUtils.createBlobServer(...);
blobServer.start();

// 创建心跳服务
heartbeatServices = createHeartbeatServices(configuration);

// 创建一个监控服务
processMetricGroup = MetricUtils.instantiateProcessMetricGroup(...);
</code></pre>
<p>createDispatcherResourceManagerComponentFactory 这个方法就是创建了三个工厂类，不需要过多介绍。我们重点关注 dispatcherResourceManagerComponentFactory.create 方法，即 ResourceManager、DispatcherRunner、WebMonitorEndpoint 是如何启动的。</p>
<h4 id="webmonitorendpoint">WebMonitorEndpoint</h4>
<p>WebMonitorEndpoint 的启动流程图如下，图中细箭头代表同一个方法中顺序调用，粗箭头代表进入上一个方法内部的调用。</p>
<p><img alt="webMonitorEndpoint" loading="lazy" data-src="https://res.cloudinary.com/dxydgihag/image/upload/v1764428386/Blog/flink/11/webmonitor.png" class="lazyload"></p>
<p>WebMonitorEndpoint 创建和启动步骤如下：</p>
<ol>
<li>
<p>通过工厂创建出了 WebMonitorEndpoint，这里就是比较常规的初始化操作。</p>
</li>
<li>
<p>调用 WebMonitorEndpoint 的 start 方法开始启动，start 方法内部先是创建了一个 Router 并调用 initializeHandlers 创建了一大堆 handler（是真的一大堆，这个方法有接近一千行，都是在创建 handler），创建完成之后，对 handler 进行排序和去重，再把它们都注册到 Router 中。这里排序是为了确保路由匹配的正确性，排序规则是先静态路径（/jobs/overview），后动态路径（/jobs/:jobid），假如我们没有排序，先注册了 /jobs/:jobid ，后注册 /jobs/overview ，这时当我们请求 /jobs/overview 时，就会被错误的路由到 /jobs/:jobid 上去。</p>
</li>
<li>
<p>是调用 startInternal 方法，在 startInternal 方法内部只有 leader 选举和启动缓存清理任务两个步骤。</p>
</li>
</ol>
<h4 id="resourcemanager">ResourceManager</h4>
<p><img alt="ResourceManager" loading="lazy" data-src="https://res.cloudinary.com/dxydgihag/image/upload/v1764517440/Blog/flink/11/resourceManager.png" class="lazyload"></p>
<p>ResourceManager 创建和启动步骤如下：</p>
<ol>
<li>
<p>调用 ResourceManagerServiceImpl.create 方法创建 ResourceManagerService，这里只是创建 ResourceManager 服务，实际创建 ResourceManager 在后面的步骤中。</p>
</li>
<li>
<p>调用 resourceManagerService.start 方法启动服务，这里就是启动选主服务，standalne 模式直接调用 grantLeadership 成为 leader。</p>
</li>
<li>
<p>成为 leader 后，就会调用 startNewLeaderResourceManager 方法，这个方法中会调用 resourceManagerFactory.createResourceManager 正式创建 resourceManager。创建完成后，就会调用 resourceManager.start 来启动它。</p>
</li>
<li>
<p>启动后会回调 ResourceManager.onStart 方法。这里调用 startHeartbeatServices 启动了两个心跳服务，一个是 ResourceManager 和 TaskManager 之间的心跳，一个是 ResourceManager 和 JobManager 之间的心跳，然后会启动 SlotManager。SlotManager 可以被当作 Flink 集群的资源调度中心。它会负责管理集群中的所有 Slot 资源，也需要响应 JobManager 的资源请求。</p>
</li>
</ol>
<h4 id="dispatcherrunner">DispatcherRunner</h4>
<p><img alt="dispatcherRunner" loading="lazy" data-src="https://res.cloudinary.com/dxydgihag/image/upload/v1764578180/Blog/flink/11/dispatcherRunner.png" class="lazyload"></p>
<ol>
<li>
<p>先创建工厂，创建完成后调用 DefaultDispatcherRunner.create 创建出 DispatcherRunner，接着是调用 start 启动选主流程。</p>
</li>
<li>
<p>选主完成后就调用 startNewDispatcherLeaderProcess 启动新的流程。启动新的流程需要先关闭旧流程，然后创建新的 dispatcherLeaderProcess，并调用 start 启动。</p>
</li>
<li>
<p>启动时，会回调 onStart 方法。</p>
</li>
<li>
<p>回调方法中，先启动 executionPlanStore，它主要是用于持久化 JobGraph。然后恢复执行计划，重建状态（如果是从失败中恢复），实例化 Dispatcher，完成作业启动。</p>
</li>
</ol>
<h3 id="taskmanager-启动流程">TaskManager 启动流程</h3>
<p><img alt="taskManager" loading="lazy" data-src="https://res.cloudinary.com/dxydgihag/image/upload/v1764666573/Blog/flink/11/taskManager.png" class="lazyload"></p>
<p>TaskManager 是 Flink 的执行节点，其最小执行单元是 slot。TaskManager 启动流程也主要是和资源管理相关，包括 slot 列表的管理和与 ResourceManager 的通信。</p>
<p>TaskManager 启动流程大体分为以下几部分：</p>
<ol>
<li>
<p>构建并启动 TaskManagerRunner（蓝色部分）</p>
</li>
<li>
<p>启动 TaskExecutor（红色部分）</p>
</li>
<li>
<p>完成与 ResourceManager 的连接（橙色部分）</p>
</li>
</ol>
<h4 id="启动-taskmanagerrunner">启动 TaskManagerRunner</h4>
<p>在 TaskManagerRunner 的 start 方法中，有两个步骤：</p>
<p>第一步是调用 startTaskManagerRunnerServices 创建和启动了很多服务，这一点和 JobManager 的启动流程比较像。这些服务包括了高可用服务、心跳服务、监控指标服务等，这里也创建了 taskExecutorService，它的启动在第二步。</p>
<p>第二步是调用 taskExecutorService.start 方法，启动 TaskExecutorService，它内部主要负责启动 TaskExecutor。</p>
<h4 id="启动-taskexecutor">启动 TaskExecutor</h4>
<p>TaskExecutor 是 TaskManager 内部的一个核心组件，负责帮助 TaskManager 完成 task 的部署和执行等核心操作。</p>
<p>在上一步调用 taskExecutor 的 start 方法后，会回调 onStart 方法，这里主要是三个步骤</p>
<ol>
<li>
<p>连接 ResourceManager 以及注册监听</p>
</li>
<li>
<p>启动 taskSlotTable</p>
</li>
<li>
<p>连接 JobMaster 以及注册监听</p>
</li>
</ol>
<p>第一步我们在下面详细解释。第二步启动的 TaskSlotTable 是 TaskManager 中负责资源的核心组件，它维护了一个 Slot 列表，管理每个 Slot 的状态，负责 Slot 的分配和释放。第三步主要是和 JobMaster 建立连接并保持心跳，同时也会接收 Slot 申请的请求。</p>
<h4 id="连接-resourcemanager">连接 ResourceManager</h4>
<p>TaskExecutor 注册完监听之后，会收到 ResourceManagerLeaderListener.notifyLeaderAddress 方法回调。回调方法中，会创建一个 TaskExecutorToResourceManagerConnection 实例并启动它。这个类是用来将 TaskExecutor 注册到 ResourceManager，注册成功会回调 onRegistrationSuccess 方法。回调成功的方法中，TaskManager 会调用 resourceManagerGateway.sendSlotReport 将 Slot 的状态进行上报。</p>
<h3 id="总结">总结</h3>
<p>本文介绍了 Flink 集群在 Standalone 模式下的启动过程，其中 JobManager 重点介绍了 WebMonitorEndpoint、ResourceManager 和 DispatcherRunner 这三个组件的启动过程。TaskManager 主要介绍了启动 TaskExecutor 和连接 ResourceManager 的过程。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-12-22 22:45">2025-12-22 22:44</span>&nbsp;
<a href="https://www.cnblogs.com/Jackeyzhe">Jackeyzhe</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19384633);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19384633', targetLink: 'https://www.cnblogs.com/Jackeyzhe/p/19384633', title: 'Flink源码阅读：集群启动' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ ROS2之URDF建模 ]]></title>
    <link>https://www.cnblogs.com/zyly/p/19384606</link>
    <guid>5d20f47004e2df5cd9a59e7d093453a6</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zyly/p/19384606" title="发布于 2025-12-22 22:31">
    <span role="heading" aria-level="2">ROS2之URDF建模</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><code>ROS</code>是机器人操作系统，当然要给机器人使用啦，不过在使用之前，还得让<code>ROS</code>认识下我们使用的机器人，如何把一个机器人介绍给<code>ROS</code>呢？</p>
<p>为此，<code>ROS</code>专门提供了一种机器人建模方法——<code>URDF</code>，用来描述机器人外观、性能等各方面属性。</p>
<h3 id="一urdf语法">一、<code>URDF</code>语法</h3>
<h4 id="11-机器人的组成">1.1 机器人的组成</h4>
<p>建模描述机器人的过程中，我们自己需要先熟悉机器人的组成和参数，比如机器人一般是由硬件结构、驱动系统、传感器系统、控制系统四大部分组成，市面上一些常见的机器人，无论是移动机器人还是机械臂，我们都可以按照这四大组成部分进行分解。</p>
<img src="https://gitee.com/zyly2033/blog-pic/raw/master/202512222019489.png" style="zoom: 80%">
<p>其中：</p>
<ul>
<li>硬件结构就是底盘、外壳、电机等实打实可以看到的设备；</li>
<li>驱动系统就是可以驱使这些设备正常使用的装置，比如电机的驱动器，电源管理系统等；</li>
<li>传感系统包括电机上的编码器、板载的<code>IMU</code>、安装的摄像头、雷达等等，便于机器人感知自己的状态和外部的环境；</li>
<li>控制系统就是我们开发过程的主要载体了，一般是树莓派、电脑等计算平台，以及里边的操作系统和应用软件。</li>
</ul>
<p>机器人建模的过程，其实就是按照类似的思路，通过建模语言，把机器人每一个部分都描述清楚，再组合起来的过程。</p>
<h4 id="12-什么是urdf">1.2 什么是<code>URDF</code></h4>
<p><code>URDF</code>（<code>Unified Robot Description Format</code>，统一机器人描述格式）是一种<code>XML</code>格式的文件，用于从物理和逻辑上描述一个机器人模型。</p>
<p>你可以把它理解为机器人的数字说明书或三维装配图，它告诉计算机：</p>
<ul>
<li>机器人由哪些零件（连杆、关节）组成；</li>
<li>这些零件长什么样（形状、尺寸、颜色）；</li>
<li>零件之间如何连接（位置、旋转、运动类型）；</li>
<li>零件的物理属性（质量、惯性）；</li>
</ul>
<h4 id="13-urdf组成">1.3 <code>URDF</code>组成</h4>
<p><code>URDF</code>主要描述两大核心元素：</p>
<ul>
<li>连杆（<code>Link</code>）：代表机器人的刚性部件，如机械臂的每一节臂杆、底盘、轮子、传感器支架等，包括：
<ul>
<li>视觉属性：形状（立方体、圆柱体、网格模型）、尺寸、颜色、纹理；</li>
<li>碰撞属性：用于物理仿真的简化几何形状；</li>
<li>惯性属性：质量、转动惯量（对仿真至关重要）。</li>
</ul>
</li>
<li>关节（<code>Joint</code>）：定义连杆之间的连接方式和运动关系，主要类型：
<ul>
<li>固定关节（<code>fixed</code>）：完全固定连接；</li>
<li>旋转关节（<code>revolute</code>）：绕单轴旋转，有角度限制（如机械臂关节）；</li>
<li>连续关节（<code>continuous</code>）：无限旋转（如轮子）；</li>
<li>平移关节（<code>prismatic</code>）：线性滑动；</li>
<li>平面关节（<code>planar</code>）：在平面内运动；</li>
<li>浮动关节（<code>floating</code>）：完全自由（<code>6</code>自由度）。</li>
</ul>
</li>
</ul>
<p>机器人描述由一组连杆元素和一组将连杆连接起来的关节元素组成；</p>
<img src="https://gitee.com/zyly2033/blog-pic/raw/master/202512222052818.png" style="zoom: 80%">
<p>因此，典型的机器人描述大致如下所示：</p>
<pre><code class="language-xml">&lt;?xml version="1.0"?&gt;
&lt;?xml-model href="https://raw.githubusercontent.com/ros/urdfdom/master/xsd/urdf.xsd" ?&gt;
&lt;robot name="pr2" xmlns="http://www.ros.org"&gt;
  &lt;link&gt; ... &lt;/link&gt;
  &lt;link&gt; ... &lt;/link&gt;
  &lt;link&gt; ... &lt;/link&gt;

  &lt;joint&gt;  ....  &lt;/joint&gt;
  &lt;joint&gt;  ....  &lt;/joint&gt;
  &lt;joint&gt;  ....  &lt;/joint&gt;
&lt;/robot&gt;
</code></pre>
<p>可以看到，<code>URDF</code>格式的根元素是一个 <code>&lt;robot&gt;</code> 元素。</p>
<h5 id="131-link元素">1.3.1 <code>link</code>元素</h5>
<p><code>link</code>元素描述了一个具有惯性、视觉特征和碰撞属性的刚体。以下是一个<code>link</code>元素的示例：</p>
<pre><code class="language-xml">&lt;link name="my_link"&gt;
  &lt;inertial&gt;
    &lt;origin xyz="0 0 0.5" rpy="0 0 0"/&gt;
    &lt;mass value="1"/&gt;
    &lt;inertia ixx="100"  ixy="0"  ixz="0" iyy="100" iyz="0" izz="100" /&gt;
  &lt;/inertial&gt;

  &lt;visual&gt;
    &lt;origin xyz="0 0 0" rpy="0 0 0" /&gt;
    &lt;geometry&gt;
      &lt;box size="1 1 1" /&gt;
    &lt;/geometry&gt;
    &lt;material name="Cyan"&gt;
      &lt;color rgba="0 1.0 1.0 1.0"/&gt;
    &lt;/material&gt;
  &lt;/visual&gt;

  &lt;collision&gt;
    &lt;origin xyz="0 0 0" rpy="0 0 0"/&gt;
    &lt;geometry&gt;
      &lt;cylinder radius="1" length="0.5"/&gt;
    &lt;/geometry&gt;
  &lt;/collision&gt;
&lt;/link&gt;
</code></pre>
<img src="https://gitee.com/zyly2033/blog-pic/raw/master/202512222058481.png" style="zoom: 80%">
<p><code>link</code>元素有一个属性，即<code>name</code>（必选）：用来描述连杆本身的名称.。此外，<code>link</code>包含若干部元素，接下来我们一一介绍。</p>
<h6 id="1311--惯性属性inertial">1.3.1.1  惯性属性<code>inertial</code></h6>
<p><code>inertial</code>（可选）：用于描述连杆的质量、其质心的位置以及其中心惯性属性。</p>
<p>其下可以包含如下元素：</p>
<ul>
<li><code>origin</code>（可选）：此位姿（平移、旋转）描述了连杆质心坐标系<code>C</code>相对于连杆坐标系<code>L</code>的位置和方向。
<ul>
<li><code>xyz</code> (可选)：表示从<code>Lo</code>（连杆坐标系原点）到<code>Co</code>（连杆质心）的位置向量，形式为 <code>x L̂x + y L̂y + z L̂z</code>，其中 <code>L̂x</code>、<code>L̂y</code>、<code>L̂z</code> 是连杆坐标系<code>L</code>的正交单位向量；</li>
<li><code>rpy</code>（可选）：表示<code>C</code>的单位向量<code>Ĉx</code>、<code>Ĉy</code>、<code>Ĉz</code>相对于连杆坐标系<code>L</code>的方向，以欧拉旋转（横滚<code>roll</code>、俯仰<code>pitch</code>、偏航<code>yaw</code>）序列表示，单位为弧度。注意：<code>Ĉx</code>、<code>Ĉy</code>、<code>Ĉz</code>不需要与连杆的惯性主轴对齐；</li>
</ul>
</li>
<li><code>mass</code>：连杆的质量由该元素的<code>value</code>属性表示；</li>
<li><code>inertia</code>：此连杆关于<code>Co</code>（连杆质心）的惯性矩<code>ixx</code>、<code>iyy</code>、<code>izz</code>和惯性积 <code>ixy</code>、<code>ixz</code>、<code>iyz</code>，这些值对应于固定在质心坐标系<code>C</code>中的单位向量<code>Ĉx</code>、<code>Ĉy</code>、<code>Ĉz</code>。注意：<code>Ĉx</code>、<code>Ĉy</code>、<code>Ĉz</code>相对于<code>L̂x</code>、<code>L̂y</code>、<code>L̂z</code> 的方向由 <code>&lt;origin&gt;</code> 标签中的<code>rpy</code>值指定。</li>
</ul>
<h6 id="1312-视觉属性visual">1.3.1.2 视觉属性<code>visual</code></h6>
<p><code>visual</code>（可选）：连杆的视觉属性，此元素指定了用于可视化目的的对象形状（长方体、圆柱体等）。</p>
<p>注意：同一个连杆可以存在多个 <code>&lt;visual&gt;</code> 标签实例。它们定义的几何体的并集形成了该连杆的视觉表示。</p>
<p>其下可以包含如下元素：</p>
<ul>
<li><code>origin</code> (可选)：视觉元素相对于连杆坐标系的参考坐标系；
<ul>
<li><code>xyz</code> (可选)：分别是<code>x</code>、<code>y</code>、<code>z</code>方向上的平移；</li>
<li><code>py</code> (可选)：表示固定轴的横滚、俯仰和偏航角度，单位为弧度；</li>
</ul>
</li>
<li><code>geometry</code>（必选）：表示几何形状，可以是以下之一：
<ul>
<li><code>&lt;box&gt;</code>
<ul>
<li><code>size</code>属性包含长方体的三个边长，长方体的原点位于其中心；</li>
</ul>
</li>
<li><code>&lt;cylinder&gt;</code>
<ul>
<li>指定半径和长度。圆柱体的原点位于其中心；</li>
</ul>
</li>
<li><code>&lt;sphere&gt;</code>
<ul>
<li>指定半径。球体的原点位于其中心；</li>
</ul>
</li>
<li><code>&lt;mesh&gt;</code>
<ul>
<li>由文件名指定的三角网格元素，以及一个可选的缩放比例，用于缩放网格的轴对齐边界框。任何几何格式都可以接受，但具体应用程序的兼容性取决于实现。对于最佳纹理和颜色支持，推荐的格式是 <code>Collada .dae</code>文件。引用同一模型的机器之间不会传输网格文件。它必须是本地文件。在文件名前加上 <code>package://&lt;packagename&gt;/&lt;path&gt;</code> 可以使网格文件的路径相对于包 <code>&lt;packagename&gt;</code>。</li>
</ul>
</li>
</ul>
</li>
<li><code>material</code>（可选）：视觉元素的材质，其<code>name</code>属性可以用于指定材质的名称；
<ul>
<li><code>&lt;color&gt;</code> (可选)
<ul>
<li><code>rgba</code>由一组四个数字（代表红/绿/蓝/透明度<code>alpha</code>）指定的材质颜色，每个数字的范围为 [<code>0</code>,<code>1</code>]；</li>
</ul>
</li>
<li><code>&lt;texture&gt;</code> (可选)
<ul>
<li>材质的纹理由文件名指定。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="1313-碰撞属性collision">1.3.1.3 碰撞属性<code>collision</code></h6>
<p><code>collision</code>用于描述碰撞参数，里边的内容似乎和<code>&lt;visual&gt;</code>一样，也有<code>&lt;geometry&gt;</code>和<code>&lt;origin&gt;</code>，看似相同，其实区别还是比较大的；</p>
<ul>
<li><code>origin</code> (可选)：碰撞元素相对于连杆坐标系的参考坐标系；
<ul>
<li><code>xyz</code> (可选)：分别是<code>x</code>、<code>y</code>、<code>z</code>方向上的平移；</li>
<li><code>py</code> (可选)：表示固定轴的横滚、俯仰和偏航角度，单位为弧度；</li>
</ul>
</li>
<li><code>geometry</code>：请参见上述视觉元素中的几何描述。</li>
</ul>
<h5 id="132-joint元素">1.3.2 <code>joint</code>元素</h5>
<p><code>joint</code>元素描述了关节的运动学和动力学特性，并指定了关节的安全限制。</p>
<p>以下是一个<code> joint</code>元素的示例：</p>
<pre><code class="language-xml">&lt;joint name="my_joint" type="floating"&gt;
   &lt;origin xyz="0 0 1" rpy="0 0 3.1416"/&gt;
   &lt;parent link="link1"/&gt;
   &lt;child link="link2"/&gt;

   &lt;calibration rising="0.0"/&gt;
   &lt;dynamics damping="0.0" friction="0.0"/&gt;
   &lt;limit effort="30" velocity="1.0" lower="-2.2" upper="0.7" /&gt;
   &lt;safety_controller k_velocity="10" k_position="15" soft_lower_limit="-2.0" soft_upper_limit="0.5" /&gt;
&lt;/joint&gt;
</code></pre>
<p>下面图中，蓝色关节表示出一个运动的轴，蓝色关节是可以围绕蓝色的轴旋转的，也就是<code>child</code>这个<code>link</code>是可以围绕<code>joint</code>上下旋转。</p>
<p><code>joint</code>连接两个<code>link</code>，需要分一个主次关系，主关节是<code>parent link</code>，子关节是<code>child link</code>， 在<code>xml</code>形式的描述中这个两个<code>link</code>是必须存在的。</p>
<img src="https://gitee.com/zyly2033/blog-pic/raw/master/202512222129254.png" style="zoom: 80%">
<p><code>joint</code>元素有两个属性：</p>
<ul>
<li>
<p><code>name</code>（必须）：指定关节的唯一名称；</p>
</li>
<li>
<p><code>type</code>（必须）：指定关节的类型，类型可以是以下之一；</p>
<ul>
<li>
<p><code>revolute</code> ：旋转关节，和<code>continuous</code>类型的区别在于不能无限旋转，而是带有角度限制，比如机械臂的两个连杆，就属于这种运动；</p>
</li>
<li>
<p><code>continuous</code>：旋转关节，可以围绕单轴无限旋转；比如小车的轮子，就属于这种类型；</p>
</li>
<li>
<p><code>prismatic</code>：滑动关节，可以沿某一个轴平移，也带有位置的极限，一般直线电机就是这种运动方式；</p>
</li>
<li>
<p><code>fixed</code>：固定关节，是唯一一种不允许运动的关节，不过使用还是比较频繁的，比如相机这个连杆，安装在机器人上，相对位置是不会变化的，此时使用的连接方式就是<code>fixed</code>；</p>
</li>
<li>
<p><code>floating</code>：浮动关节，允许进行平移、旋转运动；</p>
</li>
<li>
<p><code>planar</code> ：平面关节，允许在平面正交方向上平移或者旋转；</p>
</li>
</ul>
</li>
</ul>
<p>此外，<code>joint</code>包含若干部元素，接下来我们挑选部分介绍介绍。</p>
<h6 id="1321-origin">1.3.2.1 <code>origin</code></h6>
<p><code>origin</code>（可选）：表示从父连杆到子连杆的变换，元素属性有：</p>
<ul>
<li><code>xyz</code> (可选)：表示<code>x</code>、<code>y</code>、<code>z</code> 偏移量，所有位置均以米为单位指定；</li>
<li><code>rpy</code> (可选)：表示绕固定轴的旋转：先绕<code>x</code>轴横滚（<code>roll</code>），然后绕<code>y</code>轴俯仰（<code>pitch</code>），最后绕<code>z</code>轴偏航（<code>yaw</code>），所有角度均以弧度为单位指定。</li>
</ul>
<h6 id="1322-parent">1.3.2.2 <code>parent</code></h6>
<p><code>parent</code>描述父连杆名称，元素属性有：</p>
<ul>
<li><code>link</code>：在机器人树结构中作为此连杆父连杆的连杆名称。</li>
</ul>
<h6 id="1323-child">1.3.2.3 <code>child</code></h6>
<p><code>child</code>描述子连杆名称，元素属性有：</p>
<ul>
<li><code>link</code>：作为子连杆的连杆名称。</li>
</ul>
<h6 id="1324-calibration-">1.3.2.4 <code>calibration </code></h6>
<p>关节的参考位置，用来校准关节的绝对位置。</p>
<h6 id="1325-dynamics--">1.3.2.5 <code>dynamics  </code></h6>
<p>描述关节的物理属性，例如阻尼值、物理静摩擦力等，经常在动力学仿真中用到。</p>
<h6 id="1326-limit---">1.3.2.6 <code>limit   </code></h6>
<p>描述运动的一些极限值，包括关节运动的上下限位置、速度限制、力矩限制等。</p>
<h6 id="1327-mimic---">1.3.2.7 <code>mimic   </code></h6>
<p>描述该关节与已有关节的关系。</p>
<h6 id="1328-safety_controller--">1.3.2.8 <code>safety_controller  </code></h6>
<p>描述安全控制器参数。保护机器人关节的运动。</p>
<h3 id="二urdf案例">二、<code>URDF</code>案例</h3>
<p>创建<code>my_learning_urdf</code>的<code>Python</code>版本的功能包；</p>
<pre><code class="language-shell">pi@NanoPC-T6:~/dev_ws$ cd src
pi@NanoPC-T6:~/dev_ws/src$ ros2 pkg create --build-type ament_python my_learning_urdf
</code></pre>
<p>在包中创建如下文件夹：</p>
<ul>
<li><code>urdf</code>：存放机器人模型的<code>URDF</code>或<code>xacro</code>文件；</li>
<li><code>meshes</code>：放置<code>URDF</code>中引用的模型渲染文件；</li>
<li><code>launch</code>：保存相关启动文件；</li>
<li><code>rviz</code>：保存<code>rviz</code>的配置文件。</li>
</ul>
<p>我们需要修改<code>setup.py</code>文件，添加配置文件：</p>
<pre><code class="language-python">import os
from glob import glob

    ...

    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        (os.path.join('share', package_name, 'launch'), glob(os.path.join('launch', '*.launch.py'))),
        (os.path.join('share', package_name, 'urdf'), glob(os.path.join('urdf', '*.*'))),
        (os.path.join('share', package_name, 'urdf/sensors'), glob(os.path.join('urdf/sensors', '*.*'))),
        (os.path.join('share', package_name, 'meshes'), glob(os.path.join('meshes', '*.*'))),
        (os.path.join('share', package_name, 'rviz'), glob(os.path.join('rviz', '*.rviz'))),
    ],

    ...
</code></pre>
<h4 id="21-模型文件">2.1 模型文件</h4>
<p>在<code>urdf</code>下新建文件<code>mbot_base.urdf</code>；</p>
<pre><code class="language-xml">&lt;?xml version="1.0" ?&gt;
&lt;robot name="mbot"&gt;

    &lt;link name="base_link"&gt;
        &lt;visual&gt;
            &lt;origin xyz=" 0 0 0" rpy="0 0 0" /&gt; &lt;!-- 机器人中心，坐标系原点 --&gt;
            &lt;geometry&gt;
                &lt;cylinder length="0.16" radius="0.20"/&gt; &lt;!-- 直径0.4m，高0.16m的圆柱 --&gt;
            &lt;/geometry&gt;
            &lt;material name="yellow"&gt;
                &lt;color rgba="1 0.4 0 1"/&gt; &lt;!-- 橙黄色 --&gt;
            &lt;/material&gt;
        &lt;/visual&gt;
    &lt;/link&gt;

    &lt;joint name="left_wheel_joint" type="continuous"&gt;
        &lt;origin xyz="0 0.19 -0.05" rpy="0 0 0"/&gt; &lt;!-- 位置：Y轴+0.19，Z轴-0.05 --&gt;
        &lt;parent link="base_link"/&gt;
        &lt;child link="left_wheel_link"/&gt;
        &lt;axis xyz="0 1 0"/&gt;  &lt;!-- 绕Y轴旋转 --&gt;
    &lt;/joint&gt;

    &lt;link name="left_wheel_link"&gt;
        &lt;visual&gt;
            &lt;origin xyz="0 0 0" rpy="1.5707 0 0" /&gt; &lt;!-- 旋转90度（π/2=1.5707） --&gt;
            &lt;geometry&gt;
                &lt;cylinder radius="0.06" length = "0.025"/&gt; &lt;!-- 半径0.06m，厚0.025m --&gt;
            &lt;/geometry&gt;
            &lt;material name="white"&gt;
                &lt;color rgba="1 1 1 0.9"/&gt;
            &lt;/material&gt;
        &lt;/visual&gt;
    &lt;/link&gt;

    &lt;joint name="right_wheel_joint" type="continuous"&gt;
        &lt;origin xyz="0 -0.19 -0.05" rpy="0 0 0"/&gt;
        &lt;parent link="base_link"/&gt;
        &lt;child link="right_wheel_link"/&gt;
        &lt;axis xyz="0 1 0"/&gt;
    &lt;/joint&gt;

    &lt;link name="right_wheel_link"&gt;
        &lt;visual&gt;
            &lt;origin xyz="0 0 0" rpy="1.5707 0 0" /&gt;
            &lt;geometry&gt;
                &lt;cylinder radius="0.06" length = "0.025"/&gt;
            &lt;/geometry&gt;
            &lt;material name="white"&gt;
                &lt;color rgba="1 1 1 0.9"/&gt;
            &lt;/material&gt;
        &lt;/visual&gt;
    &lt;/link&gt;

    &lt;joint name="front_caster_joint" type="continuous"&gt;
        &lt;origin xyz="0.18 0 -0.095" rpy="0 0 0"/&gt;
        &lt;parent link="base_link"/&gt;
        &lt;child link="front_caster_link"/&gt;
        &lt;axis xyz="0 1 0"/&gt;
    &lt;/joint&gt;

    &lt;link name="front_caster_link"&gt;
        &lt;visual&gt;
            &lt;origin xyz="0 0 0" rpy="0 0 0"/&gt;
            &lt;geometry&gt;
                &lt;sphere radius="0.015" /&gt;
            &lt;/geometry&gt;
            &lt;material name="black"&gt;
                &lt;color rgba="0 0 0 0.95"/&gt;
            &lt;/material&gt;
        &lt;/visual&gt;
    &lt;/link&gt;

    &lt;joint name="back_caster_joint" type="continuous"&gt;
        &lt;origin xyz="-0.18 0 -0.095" rpy="0 0 0"/&gt;
        &lt;parent link="base_link"/&gt;
        &lt;child link="back_caster_link"/&gt;
        &lt;axis xyz="0 1 0"/&gt;
    &lt;/joint&gt;

    &lt;link name="back_caster_link"&gt;
        &lt;visual&gt;
            &lt;origin xyz="0 0 0" rpy="0 0 0"/&gt;
            &lt;geometry&gt;
                &lt;sphere radius="0.015" /&gt;
            &lt;/geometry&gt;
            &lt;material name="black"&gt;
                &lt;color rgba="0 0 0 0.95"/&gt;
            &lt;/material&gt;
        &lt;/visual&gt;
    &lt;/link&gt;

&lt;/robot&gt;
</code></pre>
<p>这将会创建一个两轮差分驱动机器人的<code>URDF</code>模型，包含若干个部分。</p>
<h5 id="211-1个主体base_link">2.1.1 <code>1</code>个主体<code>base_link</code></h5>
<p>圆柱体（直径<code>0.4</code>米，高<code>0.16</code>米），橙黄色，机器人中心，坐标系原点。</p>
<h5 id="212-2个驱动轮左右轮">2.1.2 <code>2</code>个驱动轮（左右轮）</h5>
<p>分别为<code>left_wheel_link</code>、<code>right_wheel_link</code>：</p>
<ul>
<li><code>left_wheel_link</code>：
<ul>
<li>圆柱体（半径<code>0.06</code>米，厚度<code>0.025</code>米）；</li>
<li>在基座坐标系中 <code>(0, 0.19, -0.05)</code>；</li>
<li>关节类型：<code>continuous</code>（连续旋转关节，无限旋转）；</li>
<li>旋转轴：绕<code>Y</code>轴 <code>(0, 1, 0)</code>；</li>
<li>视觉旋转：<code>rpy="1.5707 0 0"</code> 将圆柱旋转90度，使其直立（假设原始圆柱是平放的）；</li>
</ul>
</li>
<li><code>right_wheel_link</code>：与左轮对称布置，<code>Y</code>坐标为负；</li>
</ul>
<h5 id="213-2个万向轮前后脚轮用于支撑">2.1.3 <code>2</code>个万向轮（前后脚轮，用于支撑）</h5>
<p>分别为<code>front_caster_link</code>、<code>back_caster_link</code>：</p>
<ul>
<li><code>front_caster_link</code>：
<ul>
<li>形状：小球体（半径<code>0.015</code>米），模拟万向轮；</li>
<li>在基座坐标系中前方 <code>(0.18, 0, -0.095)</code>；</li>
<li>颜色：黑色；</li>
</ul>
</li>
<li><code>back_caster_link</code>：与前万向轮对称布置，<code>X</code>坐标为负（<code>-0.18</code>）。</li>
</ul>
<h4 id="22-launch文件">2.2 <code>launch</code>文件</h4>
<p>在<code>launch</code>文件夹下创建<code>display.launch.py</code>文件；</p>
<pre><code class="language-python">from ament_index_python.packages import get_package_share_path

from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.conditions import IfCondition, UnlessCondition
from launch.substitutions import Command, LaunchConfiguration

from launch_ros.actions import Node
from launch_ros.parameter_descriptions import ParameterValue

def generate_launch_description():
    urdf_tutorial_path = get_package_share_path('my_learning_urdf')
    # 设置默认的URDF文件和RViz配置文件路径
    default_model_path = urdf_tutorial_path / 'urdf/mbot_base.urdf'
    default_rviz_config_path = urdf_tutorial_path / 'rviz/urdf.rviz'

    # 命令行参数：--gui true/false，控制是否使用GUI界面发布关节状态
    gui_arg = DeclareLaunchArgument(name='gui', default_value='false', choices=['true', 'false'],
                                    description='Flag to enable joint_state_publisher_gui')
    
    # 命令行参数：--model &lt;路径&gt;，指定URDF文件路径
    model_arg = DeclareLaunchArgument(name='model', default_value=str(default_model_path),
                                      description='Absolute path to robot urdf file')
    
    # 命令行参数：--rvizconfig &lt;路径&gt;，指定RViz配置文件
    rviz_arg = DeclareLaunchArgument(name='rvizconfig', default_value=str(default_rviz_config_path),
                                     description='Absolute path to rviz config file')

    # 关键：使用xacro命令解析URDF文件（支持参数化、宏等高级特性）
    robot_description = ParameterValue(Command(['xacro ', LaunchConfiguration('model')]),
                                       value_type=str)
	
    # robot_state_publisher 节点
    robot_state_publisher_node = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{'robot_description': robot_description}]
    )

    # 关节状态发布器（二选一）
    # 文本版本（无GUI）
    joint_state_publisher_node = Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        condition=UnlessCondition(LaunchConfiguration('gui'))
    )

    # GUI版本（带滑动条控制）
    joint_state_publisher_gui_node = Node(
        package='joint_state_publisher_gui',
        executable='joint_state_publisher_gui',
        condition=IfCondition(LaunchConfiguration('gui'))
    )

    # rviz2 可视化节点
    rviz_node = Node(
        package='rviz2',
        executable='rviz2',
        name='rviz2',
        output='screen',
        arguments=['-d', LaunchConfiguration('rvizconfig')],
    )

    return LaunchDescription([
        gui_arg,
        model_arg,
        rviz_arg,
        joint_state_publisher_node,
        joint_state_publisher_gui_node,
        robot_state_publisher_node,
        rviz_node
    ])
</code></pre>
<p>这个<code>Launch</code>文件主要做三件事：</p>
<ul>
<li>加载机器人<code>URDF</code>模型（支持<code>xacro</code>格式）；</li>
<li>发布机器人的状态变换（<code>TF</code>）；</li>
<li>在<code>rviz2</code>中可视化机器人。</li>
</ul>
<h5 id="221-节点">2.2.1 节点</h5>
<p>脚本运行会创建以下几个节点：</p>
<ul>
<li><code>joint_state_publisher</code>：发布每个<code>joint</code>（除<code>fixed</code>类型）的状态，一个无界面的、基础版的关节状态发布器；</li>
<li><code>joint_state_publisher_gui</code>：发布每个<code>joint</code>（除<code>fixed</code>类型）的状态，可以通过<code>UI</code>界面对<code>joint</code>进行控制；</li>
<li><code>robot_state_publisher</code>：将机器人各个<code>links</code>、<code>joints</code>之间的关系，通过<code>TF</code>的形式，整理成三维姿态信息发布。</li>
<li><code>rviz2</code>：在<code>rviz2</code>中可视化机器人；</li>
</ul>
<p><code>joint_state_publisher</code>这是一个官方<code>ROS2</code>包，主要功能：</p>
<ul>
<li>
<p>输入：</p>
<ul>
<li>
<p>读取<code>URDF</code>中的关节定义；</p>
</li>
<li>
<p>接收用户或程序指定的关节角度；</p>
</li>
</ul>
</li>
<li>
<p>输出：</p>
<ul>
<li>
<p>发布 <code>/joint_states</code> 话题，消息类型为 <code>sensor_msgs/msg/JointState</code>；</p>
</li>
<li>
<p>包含所有关节的名称、位置、速度、力等信息。</p>
</li>
</ul>
</li>
</ul>
<h5 id="222-数据流与节点关系">2.2.2 数据流与节点关系</h5>
<p>数据流与节点关系:</p>
<pre><code class="language-tex">用户通过滑动条/GUI或程序 → joint_state_publisher(_gui)
                                     ↓ 发布/joint_states话题
                        robot_state_publisher
                                     ↓ 计算并发布TF变换
                              rviz2 和其他节点
                                     ↓ 接收TF并可视化
</code></pre>
<h4 id="23-urdfrviz">2.3 <code>urdf.rviz</code></h4>
<p>在<code>rviz</code>目录下新建<code>urdf.rviz</code>文件；</p>
<pre><code class="language-yaml">Panels:
  - Class: rviz_common/Displays
    Name: Displays
  - Class: rviz_common/Views
    Name: Views
Visualization Manager:
  Class: ""
  Displays:
    - Class: rviz_default_plugins/Grid
      Name: Grid
      Value: true
    - Alpha: 0.8
      Class: rviz_default_plugins/RobotModel
      Description Source: Topic
      Description Topic:
        Value: /robot_description
      Enabled: true
      Name: RobotModel
      Value: true
    - Class: rviz_default_plugins/TF
      Name: TF
      Value: true
  Global Options:
    Fixed Frame: base_link
    Frame Rate: 30
  Name: root
  Tools:
    - Class: rviz_default_plugins/MoveCamera
  Value: true
  Views:
    Current:
      Class: rviz_default_plugins/Orbit
      Distance: 1.7
      Name: Current View
      Pitch: 0.33
      Value: Orbit (rviz)
      Yaw: 5.5
Window Geometry:
  Height: 800
  Width: 1200
</code></pre>
<h4 id="24-编译运行">2.4 编译运行</h4>
<p>编译程序：</p>
<pre><code class="language-shell">pi@NanoPC-T6:~/dev_ws$ colcon build --paths src/my_learning_urdf
pi@NanoPC-T6:~/dev_ws$ source install/setup.sh
</code></pre>
<h5 id="241-可视化">2.4.1 可视化</h5>
<p>启动终端，运行如下命令；</p>
<pre><code class="language-shell">pi@NanoPC-T6:~/dev_ws$ ros2 launch my_learning_urdf display.launch.py
</code></pre>
<p>很快就可以看到<code>rviz</code>中显示的机器人模型啦，大家可以使用鼠标拖拽观察；</p>
<img src="https://gitee.com/zyly2033/blog-pic/raw/master/202512222247733.png" style="zoom: 80%">
<p>从可视化的效果来看，这个机器人由<code>5</code>个<code>link</code>和4个<code>joint</code>组成。</p>
<h5 id="242-查看urdf模型结构">2.4.2 查看<code>URDF</code>模型结构</h5>
<p>我们分析的对不对呢，可以在模型文件的路径下，使用<code>urdf_to_graphviz</code>这个小工具来分析下;</p>
<pre><code class="language-shell">pi@NanoPC-T6:~/dev_ws/src/my_learning_urdf/urdf$ urdf_to_graphviz mbot_base.urdf
WARNING: OUTPUT not given. This type of usage is deprecated!Usage: urdf_to_graphviz input.xml [OUTPUT]  Will create either $ROBOT_NAME.gv &amp; $ROBOT_NAME.pdf in CWD  or OUTPUT.gv &amp; OUTPUT.pdf.
Created file mbot.gv
Created file mbot.pdf

pi@NanoPC-T6:~/dev_ws/src/my_learning_urdf/urdf$ ls
mbot_base.urdf  mbot.gv  mbot.pdf
</code></pre>
<p>运行成功后会产生一个<code>pdf</code>文件，打开之后就可以看到<code>URDF</code>模型分析的结果啦，是不是和我们的猜测完全相同呢！</p>
<img src="https://gitee.com/zyly2033/blog-pic/raw/master/202512222230527.png" style="zoom: 80%">
<p><strong>参考文章</strong></p>
<p><strong>[1] <a href="https://book.guyuehome.com/ROS2/3.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/3.3_URDF/" target="_blank" rel="noopener nofollow">古月居<code>ROS2</code>入门教程学习笔记</a></strong></p>
<p><strong>[2] <a href="https://zhuanlan.zhihu.com/p/341599469" target="_blank" rel="noopener nofollow"><code>ROS</code>中阶笔记（二）：机器人系统设计—<code>URDF</code>机器人建模</a></strong></p>
<p><strong>[3] <a href="https://wiki.ros.org/urdf/XML/model" target="_blank" rel="noopener nofollow"><code>XML Robot Description Format</code> (<code>URDF</code>)</a></strong></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.05" data-date-updated="2025-12-22 23:43">2025-12-22 22:31</span>&nbsp;
<a href="https://www.cnblogs.com/zyly">大奥特曼打小怪兽</a>&nbsp;
阅读(<span id="post_view_count">12</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19384606);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19384606', targetLink: 'https://www.cnblogs.com/zyly/p/19384606', title: 'ROS2之URDF建模' })">举报</a>
</div>
         ]]>
    </description>
    </item>
<item>
    <title><![CDATA[ 从源码角度解析C++20新特性如何简化线程超时取消 ]]></title>
    <link>https://www.cnblogs.com/apocelipes/p/19384377</link>
    <guid>f70ef329719078d279e9912cea847e9a</guid>
    <description>
    <![CDATA[ 
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/apocelipes/p/19384377" title="发布于 2025-12-22 21:15">
    <span role="heading" aria-level="2">从源码角度解析C++20新特性如何简化线程超时取消</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>C++20中增加了很多重量级新特性，它不仅带来了ranges、concept和协程，也为多线程编程带来了jthread和stop_source这些强力辅助。利用这些新特性，我们可以更高效地编写并发程序。</p>
<p>今天要说的就是利用jthread和stop_source来简化线程超时控制的实现，最终我们可以实现一个简单高效、可维护性不输给号称“天生支持并发”的Go语言的版本。</p>
<h2 id="为什么需要超时控制">为什么需要超时控制</h2>
<p>超时控制是很常见的需求，最普遍的场景是为了防止程序卡住或者长时间占用资源，程序会主动取消掉一些超过允许运行时间的或者无响应的线程，比如一些耗时很长的网络连接处理线程等。当然用户等得不耐烦了手动点击取消任务执行也勉强可以算在内。</p>
<p>通常超时发生或者用户点击取消之后，我们都期待线程能迅速终止执行并让整个程序保持一个完整且安全的状态。然而现实是复杂的，想实现上述功能对于线程来说是一件难事，尤其在Linux系统上。</p>
<p>第一个难点是如何让线程知道自己要退出。对于进程来说这不是难点，因为不管进程在做什么，我们都可以靠向其发送信号来立即中断进程的执行（前提是线程没有屏蔽这个信号），这样进程的停止请求可以被立即感知到，进程从而可以尽快完成善后工作退出执行。同样的招数对多线程程序来说就没那么好用了——信号默认是发给整个进程的，为了能让每个线程独立地接收信号，我们需要保存线程的标识符并在每个线程中设置接收和屏蔽信号的mask，这大大增加了程序的复杂性；其次信号处理函数是整个进程内所有线程共享的，我们需要额外的手段来保证并发安全，同时还得兼顾信号处理函数需要可重入、快速执行的最佳实践，这会提高程序的开发难度。</p>
<p>第二个难点在于如何保证线程一定会退出执行。前面说到信号可以打断进程的执行，但这只是通知，实际上进程完全可以在信号处理函数返回后无视这个通知继续运行，或者有一种更普遍的场景——程序正好卡在某个系统调用上，而程序又设置了系统调用被信号中断后自动重启，这样即使我们有效通知了进程，进程也会在收完通知之后再次进入系统调用从而无法响应停止请求。所以作为保底手段，Linux可以发送<code>SIGKILL</code>这个信号强制终止进程，这个信号无法捕获也无法屏蔽，是我们货真价实的“底牌”。</p>
<p>上述的情况在多线程中同样存在，而且我们没有“底牌”可用——因为不管给哪个线程发送<code>SIGKILL</code>，都会杀死整个进程而不是单独接收到信号的那个线程。另外即使有办法强制终止线程（比如早期的JVM），我们还会遇到资源释放的问题。进程退出执行之后，内核会尽可能释放进程持有的所有资源，打开的文件会被关闭，缓冲区的内容会被刷新，文件锁之类的同步机制也会正常解锁；但线程并没有这种自动清理机制，清理工作完全需要手动执行，一旦进程没有释放自己持有的资源就退出，系统就会遇到各种数据损坏和死锁等并发问题，排查和修复会极其困难。</p>
<p>为了克服上述难点并安全高效地实现终止超时线程的执行，我们需要一些额外的控制手段。这也一直都是开发者中的热门话题。</p>
<p>在介绍C++20如何简化超时控制之前，我们先来看看前人的智慧成果。</p>
<h2 id="golang实现超时控制">Golang实现超时控制</h2>
<p>Golang是天生支持并发的语言，这一点可谓名副其实，尤其是在超时控制上。</p>
<p>我们直接看个例子，例子里有主线程和工作线程，工作线程超时时间为5秒，如果超过这个时间还有线程没完成工作，就取消所有线程的执行。Golang里没有系统级的线程，但我们可以用goroutine模拟。</p>
<p>在工作线程中我们用sleep代替耗时的工作，这样便于测试：</p>
<pre><code class="language-golang">func Work(ctx context.Context, id int) error {
	for range 10 {
		select {
		case &lt;-ctx.Done():
			fmt.Printf("worker %d: canceled\n", id)
			return ctx.Err()
		default:
		}
		if rand.IntN(2) == 0 {
			time.Sleep(500 * time.Millisecond)
		} else {
			time.Sleep(time.Second)
		}
	}
	fmt.Printf("worker %d: done\n", id)
	return nil
}
</code></pre>
<p>超时控制是<code>ctx</code>参数实现的，每次循环处理前我们都会主动检查线程是否需要退出，这种协作式的“请求-检查-响应”是各种语言中取消线程执行的常见做法。</p>
<p>这个工作函数执行时间在5秒到10秒之间，取值的步长在0.5秒，加上go标准库默认随机数是均匀分布的，所以整体执行时间的概率是正态分布的，在7.5秒左右我们很容易看到超时和正常运行结束两种情况。所以我们把超时时间分别设为4秒、7.5秒、11秒，来进行模拟运行实验：</p>
<pre><code class="language-golang">func main() {
    // 从命令行获取超时时间，单位毫秒
    timeout, err := strconv.Atoi(os.Args[1])
    if err != nil {
        panic(err)
    }
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeout)*time.Millisecond)
	now := time.Now()
	defer cancel()
	g := &amp;errgroup.Group{}
	for i := range 3 {
		g.Go(func() error {
			return Work(ctx, i)
		})
	}
	err = g.Wait()
	fmt.Printf("run time: %s\n", time.Since(now))
	if err != nil {
		if errors.Is(err, context.DeadlineExceeded) {
			fmt.Println("Tasks canceled")
			return
		}
		panic(err)
	}
	fmt.Println("All work done!")
}
</code></pre>
<p>代码很简单，关键在这行：<code>ctx, cancel := context.WithTimeout(context.Background(), 7500*time.Millisecond)</code>，只要我们设定的时间到了，<code>&lt;-ctx.Done()</code>就会从阻塞变为非阻塞，循环开始处的检查会发现这个变化，然后会退出线程的执行。代码中使用了<code>errgroup</code>，但这不是必须的，实际上有很多办法可以通知主线程，这里我选择了一种最通用的，代价是代码会稍微复杂一些。</p>
<p>运行代码，会看到下面这样的输出，结果有很大的随机成分，下面只是无数种可能中的一种：</p>
<pre><code class="language-console">$ go build -o test

$ ./test 4000
worker 1: canceled
worker 0: canceled
worker 2: canceled
run time: 4.00431275s
Tasks canceled

$ ./test 7500
worker 0: done
worker 2: done
worker 1: canceled
run time: 7.507776458s
Tasks canceled

$ ./test 11000
worker 1: done
worker 2: done
worker 0: done
run time: 8.509193125s
All work done!
</code></pre>
<p>可以看到超时控制发挥了作用，尽管内置的time计时有一些误差，但程序的总体的运行时间是小于等于超时时间的。</p>
<p>Golang的超时控制可以通过<code>context</code>简单实现，但需要工作线程主动检查主动配合，前文我们也提到了强制终止工作线程很可能会造成并发问题，因此所有的线程超时控制中都是采用的这种协作式退出机制，即使天生并发的语言也不能免俗。作为代价，我们需要谨慎编码以免工作线程无法响应退出请求，同时还需要付出一点在循环里检查是否需要退出执行的性能损失。</p>
<h2 id="c中的典型超时控制实现">C++中的典型超时控制实现</h2>
<p>c++没有方便好用的<code>context</code>，想要实现协作式退出得自己造轮子。</p>
<p>Golang好用是因为标准库和运行时调度器隐藏了实现的细节：<code>WithTimeout</code>实际上会创建一个定时器，到时间后调度器会执行定时器的回调函数主动关闭<code>ctx</code>内部的channel，这样<code>&lt;-ctx.Done()</code>就会从阻塞变成非阻塞，协程就能检查到这一变化从而退出执行。</p>
<p>核心只在于两点，以合适的方法标记线程已被取消和异步地在超时后设置取消标记。</p>
<p>第一点很容易解决，使用原子变量即可。第二点的异步通知有些棘手，但我们还是有几种选择：</p>
<ol>
<li>使用alarm和信号: <code>alarm</code>会注册一个定时器，到时间后给进程发送<code>SIGALRM</code>信号，虽说多线程程序里不推荐用信号，但在这个场景下在信号处理函数里设置原子变量是合适的，另外使用<code>alarm(0)</code>可以取消之前注册的定时器。</li>
<li>使用多线程：我们可以另外创建一个线程，并在其中等待到超时时间过去之后设置标志，这样主线程也不会阻塞。</li>
</ol>
<p>当然两个方案各有缺点：</p>
<ol>
<li><code>alarm</code>是整个进程共享的，且同时只能设置一个定时器，最后它只能设置秒级精度的超时时间；使用<code>setitimer</code>可以解决上面这些问题，但会出现不知道信号是哪个超时的定时器发送的问题。</li>
<li>多线程方案问题比较少，集中在变量生命周期和任务正常完成如何取消超时控制线程这两点上。</li>
</ol>
<p>综合来看使用多线程方案才能真正解决问题，跨平台性也更强。知道原理后我们就可以写实验代码了。</p>
<p>转换后的工作函数是这样的：</p>
<pre><code class="language-c++">namespace {
    std::atomic&lt;int&gt; canceled_flag{0};
    std::atomic&lt;int&gt; is_canceled{0};
}

void Work(int id)
{
    std::mt19937 rng{std::random_device{}()};
    std::uniform_int_distribution&lt;int&gt; dist(0, 1);

    for (int i = 0; i &lt; 10; ++i) {
        if (canceled_flag.load(std::memory_order_acquire) == 1) {
            std::osyncstream{std::cout} &lt;&lt; "worker: " &lt;&lt; id &lt;&lt; " canceled\n";
            is_canceled.store(1, std::memory_order_release);
            return;
        }
        if (dist(rng) == 0) {
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
        } else {
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }

    std::osyncstream{std::cout} &lt;&lt; "worker: " &lt;&lt; id &lt;&lt; " done\n";
}
</code></pre>
<p>代码和go版本的没有太大差异，唯一的区别是我们不靠返回值而是<code>is_canceled</code>标志来区分线程是否因为被取消而退出。只使用<code>canceled_flag</code>会导致竞态条件并导致误判，你可以想想是为什么，这算是课后练习。另外我在这还使用了memory_order，这不是必须的，但默认的cst内存序多少有些杀鸡用牛刀。</p>
<p>下面是主线程和超时控制线程的逻辑：</p>
<pre><code class="language-c++">int main(int argc, const char *argv[])
{
    if (argc != 2) {
        std::cerr &lt;&lt; "wrong arg\n";
        return 1;
    }
    auto timeout = std::stoi(argv[1]);

    std::vector&lt;std::thread&gt; workers;
    constexpr int worker_num = 3;
    workers.reserve(worker_num);
    for (int i = 0; i &lt; worker_num; ++i) {
        workers.emplace_back(work, i);
    }

    std::atomic&lt;int&gt; timeout_cancel_flag{0};
    std::thread{
        // 超时控制线程
        [&amp;timeout_cancel_flag](auto timeout){
            std::this_thread::sleep_for(timeout);
            if (timeout_cancel_flag.load(std::memory_order_acquire) == 1) { // 危险
                return;
            }
            canceled_flag.store(1, std::memory_order_release);
        }, std::chrono::milliseconds(timeout)
    }.detach();

    for (auto &amp;worker: workers) {
        worker.join();
    }
    timeout_cancel_flag.store(1, std::memory_order_release);

    if (is_canceled.load(std::memory_order_acquire) != 1) {
        std::osyncstream{std::cout} &lt;&lt; "All works done!\n";
    } else {
        std::osyncstream{std::cout} &lt;&lt; "Tasks canceled\n";
    }
}
</code></pre>
<p>整体上没什么难懂的地方，基本可以看做Golang版本的转译，如果线程都退出之后不管是否超时我们都要取消超时控制线程。整体上只有一点不一样：超时控制线程是detach的，因为我们不能让主线程阻塞。</p>
<p>然而这段代码有很致命的生命周期问题，想象一下如果worker都在timeout之前完成工作，且函数在timeout之前退出，但超时控制线程仍然需要睡眠到timeout为止，这时候它醒来访问到的<code>timeout_cancel_flag</code>将会是一个无效值。</p>
<p>问题出在两个地方，第一个是我们用了sleep，这不可中断，线程必须要等满timeout时间才能退出，这会造成线程泄漏；第二是因为sleep不可中断，导致我们的超时控制线程生命周期长于主线程和工作线程，在其中引用的主线程的局部变量很可能会失效。</p>
<p>解决方案当然也很多，最简单的就是用<code>std::shared_ptr</code>包裹我们需要跨线程访问的资源，这和在rust中使用<code>Arc</code>是一样的。但这种方案治标不治本，我们的超时控制线程仍然会有比其他线程长的生命周期。</p>
<p>第二种则是使用一种在超时等待中可以被中断的机制，c++20前我们有<code>std::timed_mutex</code>和条件变量可用。</p>
<p>改进后的代码：</p>
<pre><code class="language-c++">auto timeout_cancel_flag = std::make_shared&lt;std::condition_variable&gt;();
std::thread{
    [timeout_cancel_flag](auto timeout){
        std::mutex timeout_lock;
        std::unique_lock u{timeout_lock};
        if (timeout_cancel_flag-&gt;wait_for(u, timeout) == std::cv_status::timeout) {
            std::osyncstream{std::cout} &lt;&lt; "cancel all threads\n";
            canceled_flag.store(1, std::memory_order_release);
        } else {
            std::osyncstream{std::cout} &lt;&lt; "self was canceled by main thread\n";
        }
    }, std::chrono::milliseconds(timeout)
}.detach();

for (auto &amp;worker: workers) {
    worker.join();
}

timeout_cancel_flag-&gt;notify_all(); // 取消超时控制线程
</code></pre>
<p>我们可以使用条件变量的<code>wait_for</code>方法，它可以让当前线程阻塞到指定的时间，或者中途被<code>notify</code>唤醒。这完美实现了我们既要超时等待又要中途可被打断的需求。并且条件变量本身用<code>std::shared_ptr</code>包裹，不会有任何生命周期问题。</p>
<p>然而没有了生命周期问题，我们还有时序问题，如果主线程中的<code>notify_all()</code>早于控制线程中的<code>wait_for</code>执行（概率比较小但不为0），那么这次notify超时控制线程是收不到的，wait会一直阻塞到超过timeout，这时候再设置取消标志就没有意义了。想要解决这种“唤醒丢失”问题，我们需要借助wait重载的第三个参数，让它告诉我们超时控制线程本身是否被取消：</p>
<pre><code class="language-c++">struct TimeoutContext {
    std::atomic&lt;int&gt; canceled{0};
    std::mutex lock;
    std::condition_variable cv;
};

auto timeout_ctx = std::make_shared&lt;TimeoutContext&gt;();
std::thread{
    [timeout_ctx](auto timeout){
        // 必须使用ctx里的锁才能有效避免竞态条件
        std::unique_lock u{timeout_ctx-&gt;lock};
        if (!timeout_cancel_flag-&gt;wait_for(u, timeout, [&amp;](){ return timeout_ctx-&gt;canceled.load(std::memory_order_acquire) == 1; })) {
            // wait_for 返回 false，canceled是值还是0，说明是超时导致的返回
            std::osyncstream{std::cout} &lt;&lt; "cancel all threads\n";
            canceled_flag.store(1, std::memory_order_release);
        } else {
            // wait_for 返回 true，canceled被设置为1，说明主线程通知了取消
            std::osyncstream{std::cout} &lt;&lt; "self was canceled by main thread\n";
        }
    }, std::chrono::milliseconds(timeout)
}.detach();

for (auto &amp;worker: workers) {
    worker.join();
}

// 取消超时控制线程
{
    // 获取同一把锁，修改状态时要么超时控制线程还没运行，要么已经在wait了
    std::lock_guard lk(timeout_ctx-&gt;lock);
    timeout_ctx-&gt;canceled.store(1, std::memory_order_release);
}
// 解锁后才能通知
timeout_ctx-&gt;cv.notify_all();
</code></pre>
<p>因为有锁存在，所以不管怎么样运行顺序只有两种：</p>
<ol>
<li>超时线程先运行，一直到wait方法里解锁，我们可以保证wait一定在notify之前运行</li>
<li>主线程设置超时线程取消标志的代码先运行，这时wait是晚于notify执行的，但我们设置取消标志是先于wait的，而wait在休眠前会先检查谓词条件，所以条件变量会马上退出不会进行等待。</li>
<li>会不会存在wait中条件变量解除了锁，在即将进入休眠前主线程完成了执行？答案是不会的，标准有明文要求wait和它的兄弟函数里unlock+wait加在一起是原子的（实际上分为三部分，解锁+休眠、被唤醒、重新加锁，它们各自都是原子的）且和notify之间是全序关系——要么notify在前他们在后或者反过来，不可能同时执行。简单说，如果超时控制线程正在执行unlock+wait，这说明主线程没有拿到锁，此时主线程要么还没运行到notify（这种情况不会丢失唤醒），要么已经设置了标志并释放了锁，谓词会检测到标志被设置（谓词检测在锁的保护中），条件变量不进入休眠；如果notify在之后运行，则notify会看到超时控制线程已经进入wait，会唤醒它。所以不存在中间可以被打断的场景。</li>
</ol>
<p>现在不再有时序问题了。</p>
<p>总体来说这个实现还不错，能正常工作性能也尚可，很多框架也选择了类似的方案来实现线程的超时取消，比如Qt。然而它有几个显著的缺点：</p>
<ol>
<li>代码依赖很多全局状态</li>
<li>我们需要用<code>join</code>等待所有线程退出，这是因为标准库的thread不join就析构会导致程序崩溃，然而这是不必要的，我们只关心工作是否完成，剩下的资源释放和线程退出无需去等待</li>
<li>线程之间暴露了过多的实现细节，比如flag具体的值，再比如<code>std::condition_variable</code>用来通知超时控制线程</li>
<li>代码真的很复杂，想正确实现整体逻辑会比较麻烦，比如杜绝唤醒丢失</li>
</ol>
<p>尽管有这些缺点，但在新标准之前我们只能使用这个方案。当然如果放弃跨平台的话，Linux上更安全更简单的做法其实是<code>eventfd+epoll_wait</code>，它不需要太多的外部状态，且逻辑简单易懂，比用条件变量还要预防唤醒丢失强太多了，使用得当的话它的性能也不会比纯内存操作的条件变量差多少。</p>
<h2 id="c20带来的简化">C++20带来的简化</h2>
<p>C++20为并发编程体验带来了不少提升。</p>
<p>第一个就是<code>std::jthread</code>，它会在析构的时候自动join，从而避免了<code>std::thread</code>手动操作的麻烦。不仅如此，每个<code>jthread</code>中还包含一个<code>std::stop_token</code>，这可以简单实现线程的协作式取消执行。仅仅这一个新特性就已经解决了上一节说的缺点中的前两条。</p>
<p>第二个有用的新特性是<code>std::stop_source</code>和<code>std::stop_token</code>。一个<code>std::stop_source</code>可以产生多个<code>std::stop_token</code>，当一个source被取消的时候，每个从它那派生出来的token都会收到通知，这可以上位替代我们之前使用的<code>canceled_flag</code>。</p>
<p>第三个是<code>std::latch</code>，你可以把它当成go的<code>sync.WaitGroup</code>，它可以让我们在工作线程完成工作之后立即通知主线程，而不用调用<code>join</code>等待线程完全退出。</p>
<p>最后一个则是<code>std::condition_variable_any</code>新增了可以用<code>stop_token</code>中断等待的方法，无需我们自己手动notify，这样可以尽量隐藏实现细节。</p>
<p>我们首先改造工作函数：</p>
<pre><code class="language-c++">bool work(std::stop_token stoken, int id)
{
    std::mt19937 rng{std::random_device{}()};
    std::uniform_int_distribution&lt;int&gt; dist(0, 1);

    for (int i = 0; i &lt; 10; ++i) {
        if (stoken.stop_requested()) {
            std::osyncstream{std::cout} &lt;&lt; "worker: " &lt;&lt; id &lt;&lt; " canceled\n";
            return false;
        }
        if (dist(rng) == 0) {
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
        } else {
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }

    std::osyncstream{std::cout} &lt;&lt; "worker: " &lt;&lt; id &lt;&lt; " done\n";
    return true;
}
</code></pre>
<p>现在我们不依赖全局变量通知线程退出了。并且函数的返回值改成了bool，以表示线程是否是因为被取消而退出的。我们通过<code>stoken.stop_requested()</code>判断线程是否被取消。</p>
<p>接下来我们利用C++20改造主线程和超时控制：</p>
<pre><code class="language-c++">int main(int argc, const char *argv[])
{
    if (argc != 2) {
        std::cerr &lt;&lt; "wrong arg\n";
        return 1;
    }
    auto timeout = std::stoi(argv[1]);

    std::atomic&lt;int&gt; is_canceled{0};
    std::stop_source source;
    std::vector&lt;std::jthread&gt; workers;
    constexpr int worker_num = 3;
    std::latch wait_group{worker_num};
    workers.reserve(worker_num);
    for (int i = 0; i &lt; worker_num; ++i) {
        workers.emplace_back([&amp;](int id){
            if (!work(source.get_token(), id)) {
                is_canceled.store(1, std::memory_order_release);
            }
            wait_group.count_down(); // 三个线程都调用过之后，wait会解除阻塞
        }, i);
    }

    // 现在不需要专门detach了，效果是一样的
    std::jthread timeout_control{
        [&amp;source](std::stop_token stoken, std::chrono::milliseconds timeout){
            std::mutex timeout_lock;
            std::unique_lock u{timeout_lock};
            std::condition_variable_any timeout_cancel;
            if (!timeout_cancel.wait_for(u, stoken, timeout, [&amp;stoken] { return stoken.stop_requested(); })) {
                std::osyncstream{std::cout} &lt;&lt; "cancel all threads\n";
                source.request_stop();
            } else {
                std::osyncstream{std::cout} &lt;&lt; "self was canceled by main thread\n";
            }
        }, std::chrono::milliseconds(timeout)
    };

    wait_group.wait(); // 等工作线程完成
    timeout_control.request_stop(); // 工作线程退出后立即取消超时控制线程，即使线程已经执行完成也能安全调用这个方法

    if (is_canceled.load(std::memory_order_acquire) != 1) {
        std::osyncstream{std::cout} &lt;&lt; "All works done!\n";
    } else {
        std::osyncstream{std::cout} &lt;&lt; "Tasks canceled\n";
    }
}
</code></pre>
<p>可以看到我们现在完全不使用全局变量了，而且线程的协作式取消是<code>request_stop()</code>和<code>stop_requested()</code>共同完成的，不会暴露太多实现细节。</p>
<p>需要注意的是<code>!timeout_cancel.wait_for(u, stoken, timeout, [&amp;stoken] { return stoken.stop_requested(); })</code>这行代码。这行代码和普通条件变量的<code>wait_for</code>一样，只不过多了一个参数<code>stoken</code>，这个函数会阻塞住当前线程，直到超时、被notify或者stoken被取消。最后一个参数lambda的返回值会作为<code>wait_for</code>的返回值，这个lambda会在阻塞解除后立即调用，因此我们在这个函数里检查<code>stoken</code>是否被取消。如果<code>stoken</code>没有被取消，说明是因为超时导致的返回，因为我们在其他地方调用notify，因此在这时我们需要取消其他工作线程。</p>
<p>新代码不仅更简洁，而且没有上一节那样的时序问题：</p>
<ol>
<li>如果stoken的取消发生在整个wait之前。wait里的谓词检测会发现wait被取消</li>
<li>stoken的取消发生在谓词检测之后、unlock+wait之前。<code>condition_variable_any</code>里有内部锁，调用<code>notify_all</code>（取消stoken会自动调用）和<code>unlock+wait</code>之前都会先尝试获取这个锁，<code>unlock+wait</code>在获取锁之后会检查stoken是否被取消，所以如果<code>notify</code>先执行，那么wait会检测到stoken已取消；如果<code>unlock+wait</code>先执行，那么notify一定是在wait之后执行的，不存在丢失</li>
<li>取消发生在wait之后，这是最安全的情况，不会有唤醒丢失。</li>
</ol>
<p><code>condition_variable_any</code>内部持有的锁正好对应我们上一节的<code>TimeoutContext::lock</code>，而<code>stop_token</code>对应<code>TimeoutContext::canceled</code>，<code>request_stop()</code>则对应了加锁设置标志并调用notify。现在所有操作all in one，代码在保证安全的同时将复杂的细节全部隐藏。</p>
<p>尽管仍有一定复杂性，但利用<code>condition_variable_any</code>已经是比较理想的超时控制解决方案了。</p>
<h3 id="condition_variable_any是如何配合stop_token的">condition_variable_any是如何配合stop_token的</h3>
<p>最后还有一个小插曲，<code>condition_variable_any</code>是如何配合<code>stop_token</code>的。</p>
<p>C++20只给<code>condition_variable_any</code>添加了支持<code>stop_token</code>的接口，这是因为普通的条件变量和其他的锁几乎都是系统接口的简单包装，这些系统接口本身不支持中断，因此也没法为这些包装接口添加支持，而<code>condition_variable_any</code>为了支持所有种类的锁，几乎所有标准库的实现都在自己内部创建了一个普通的条件变量和内部锁，并基于这个条件变量重新实现了所有接口，因此给支持<code>stop_token</code>留下了余地。</p>
<p>我们以libcxx的实现为例：</p>
<pre><code class="language-c++">// notify全都要先加内部锁
inline void condition_variable_any::notify_one() _NOEXCEPT {
  { lock_guard&lt;mutex&gt; __lx(*__mut_); }
  // notify时最好要解锁，否则wait线程被唤醒后发现加不了锁又会再次休眠，效率很低
  // 锁只是为了让notify的调用和unlock+wait互斥
  __cv_.notify_one();
}

inline void condition_variable_any::notify_all() _NOEXCEPT {
  { lock_guard&lt;mutex&gt; __lx(*__mut_); }
  __cv_.notify_all();
}

// wait_for最终调用的这个方法
template &lt;class _Lock, class _Clock, class _Duration, class _Predicate&gt;
bool condition_variable_any::wait_until(
    _Lock&amp; __user_lock,
    stop_token __stoken,
    const chrono::time_point&lt;_Clock, _Duration&gt;&amp; __abs_time,
    _Predicate __pred) {
    // 先检查一次是否被取消，因为后面的操作都很重量级会浪费性能
  if (__stoken.stop_requested())
    return __pred();

  shared_ptr&lt;mutex&gt; __mut = __mut_;
  // 这行是关键，让底层的普通条件变量可以从wait中苏醒
  stop_callback __cb(__stoken, [this] { notify_all(); });

  while (true) {
    // 从wait中因为notify醒来会回到这里，调用最后的lambda来检查是否应该退出等待
    // 初次进入循环也会检查，以免进行不必要的等待
    // 检查其实在临界区之外，所以其实最好我们得持有传入的外部锁才能完全避免静态条件
    // 只不过恰好我们的谓词检查只检查了stoken是否被取消，和下面临界区内的一样，所以这地方的时序没有影响。我们在主线程中也无需加外部锁
    if (__pred())
      return true;

    // 先加内部锁，以免竞态条件出现，代码本身的注释已经解释清楚了，无需多言
    // We need to take the internal lock before checking stop_requested,
    // so that the notification cannot come in between the stop_requested
    // check and entering the wait.
    // Note that the stop_callback takes the same internal lock before notifying
    unique_lock&lt;mutex&gt; __internal_lock(*__mut);
    // 检查stop_token是否被取消
    // notify拿到锁先运行的话循环就会在这里退出
    if (__stoken.stop_requested())
      break;

    // 解锁用户传入的外部锁，和普通的条件变量一样
    __unlock_guard&lt;_Lock&gt; __unlock(__user_lock);
    unique_lock&lt;mutex&gt; __internal_lock2(
        std::move(__internal_lock)); // switch unlock order between __internal_lock and __user_lock

    // 内部锁的unlock+wait
    if (__cv_.wait_until(__internal_lock2, __abs_time) == cv_status::timeout)
      // 超时之后直接退出循环，否则回到循环开始处
      break;
  } // __internal_lock2.unlock(), __user_lock.lock()
  // 还会调用谓词，因此返回值总是能反应stoken是否被取消
  return __pred();
}

template &lt;class _Lock&gt;
struct __unlock_guard {
  _Lock&amp; __lock_;

  // 对象创建的时候解锁，析构的时候加锁
  _LIBCPP_HIDE_FROM_ABI __unlock_guard(_Lock&amp; __lock) : __lock_(__lock) { __lock_.unlock(); }

  _LIBCPP_HIDE_FROM_ABI ~__unlock_guard() _NOEXCEPT // turns exception to std::terminate
  {
    __lock_.lock();
  }

  __unlock_guard(const __unlock_guard&amp;)            = delete;
  __unlock_guard&amp; operator=(const __unlock_guard&amp;) = delete;
};
</code></pre>
<p>核心在于<code>stop_callback __cb(__stoken, [this] { notify_all(); });</code>这一行，<code>std::stop_callback</code>可以把回调函数注册给<code>stop_token</code>关联的<code>stop_source</code>，当source被要求停止时，注册的回调会在调用<code>request_stop()</code>的那个线程执行，回调可以注册多个，调用顺序是不确定的。</p>
<p>所以这行代码等于在我们要求取消<code>stoken</code>的时候，顺手调用<code>notify_all()</code>把底层的条件变量唤醒了，唤醒之后循环会检查lambda和<code>stoken</code>，然后发现自己被取消从而从wait中退出。这就是wait可以被立即中断的秘密。</p>
<p>不过如果token已经取消，<code>stop_callback</code>是不生效的，但这也没关系，因为在进入真正的等待支持，我们至少检查了两次<code>stoken</code>是否被取消，且第二次检查是被锁保护的，notify的callback不生效或者唤醒丢失了我们也能检查到stoken已经被取消，不会进入无意义的等待。</p>
<p>上面的代码也展现了<code>condition_variable_any</code>的问题，相比直接转发到系统接口的其他标准库功能，它的性能通常要差一些，对于性能要求较高的场景必须谨慎使用。</p>
<h2 id="总结">总结</h2>
<p>为了保证并发安全，上面的逻辑是有些绕的，但总结起来也就几句话：</p>
<ol>
<li>设置取消标志需要和unlock+wait互斥，这样超时控制线程才有机会检测自己是否被取消。</li>
<li>超时控制线程中的取消标志检查（C++20前的谓词匿名函数、C++20里的<code>stoken.stop_requested</code>）需要和unlock+wait在同一块临界区里，这样才能保证进入wait之前取消标志被正确检测到或者notify在wait之后才被调用。</li>
<li>notify通常在设置完取消标志之后执行，但不需要在临界区里，即使唤醒错过了我们也有保底措施。</li>
</ol>
<p>只要想明白这三点你就掌握了这种模式，以后遇到超时取消或者防止唤醒丢失的场景时不至于两眼一黑了。</p>
<p>这就是为什么要用现代C++，新特性有时候真的可以飞跃式提升开发效率，虽说这种程度和Golang相比还称不上优雅，但心智负担减轻了很多加班也没那么累了。</p>
<p>但话说回来，同样的需求如果不是追求极致性能/只能用C++，我更乐意用Golang去实现。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-12-22 21:15">2025-12-22 21:15</span>&nbsp;
<a href="https://www.cnblogs.com/apocelipes">apocelipes</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19384377);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19384377', targetLink: 'https://www.cnblogs.com/apocelipes/p/19384377', title: '从源码角度解析C++20新特性如何简化线程超时取消' })">举报</a>
</div>
         ]]>
    </description>
    </item>
        </channel>
        </rss>