{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "PowerDotNet平台化软件架构设计与实现系列（18）：商品管理平台",
      "link": "https://www.cnblogs.com/jeffwongishandsome/p/goods-platform-design-and-implement.html",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jeffwongishandsome/p/goods-platform-design-and-implement.html\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 12:11\">\n    <span>PowerDotNet平台化软件架构设计与实现系列（18）：商品管理平台</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>商品系统是电子商务的核心系统之一，是各种电商业务展开的基础和起点，没有调查就没有发言权，个人也深度参与设计开发和维护过商品系统，本文简单分享下PowerDotNet重写过的商品平台系统。</p>\n<p>十多年前我刚入行，首次接触电商业务系统开发，开发重点集中在财务、库管、订单等这些需要后台强力支持的系统，反而对商品有个刻板印象，就是觉得商品系统简单，字典型应用而已，难度不大。</p>\n<p>随着开发和填坑经验的累积以及业务知识面的扩大，从传统B2C到OTA到酒店到在线阅读再到生鲜电商，一路走来，当我真正独立设计实现过一次商品系统，才深刻意识到当初对商品的想法相当浅薄。</p>\n<p>商品作为电商业务基础主数据，在中小公司可以抽象到<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/basedata-system-design-and-implement.html\" target=\"_blank\">基础数据平台</a>中管理，个人工作过的公司就有这样处理的，不过大中型公司通常都会独立开发商品管理系统(CMS)，充分说明商品管理的重要性。</p>\n<p>PowerDotNet的商品平台Power.Commodity目前已经重写完成，有时写的很挣扎，这可能和个人追求完美要从良好到更好再到更加好的自我要求有关，更可能是间隔过长看不懂自己的祖传代码，^_-。</p>\n<p>想起代码大全里的话，大意是需求和设计文档都可能过时，而源代码往往是对软件的唯一精准描述，很多项目，程序员可以唯一得到的文档就是源代码本身。深度分析过祖传代码就能理解这话真是至理。</p>\n<p>在实现商品系统的过程中，我也跟风热血沸腾激情澎湃用上了如日中天的AI工具，比如Cursor、Copilot、通义千问和DeepSeek等，人工智能果然厉害，因为我真有一堆祖传商品代码需要和AI交叉验证。</p>\n<p>没有代码支撑的系统设计无异于镜花水月空中楼阁，可行性、可用性和稳定性都很可疑，Power.Commodity则建立在我个人实际工作过的商品系统代码基础之上，至少设计和实现都经受过生产环境考验。</p>\n<p>商品系统建模相对还是比较简单的，但面对复杂的业务场景，为了满足业务需要不得不做出设计上的妥协，这种其实就是个性化需求，个人经历过的很多个性化商品需求在Power.Commodity都没有实现。</p>\n<p>相对于传统的商品，个人也先后参与过服务商品、虚拟商品、汽车商品和生鲜商品的设计开发和维护工作，这四类商品有其不言而喻的特殊性和复杂度，一言以蔽之，通用性不足，本文只做一些概要说明。</p>\n<p>本文介绍的商品只是个人经验中最经典和传统的商品模型，特殊商品我热血沸腾激情澎湃写了几周都不太满意就撤销了很多代码，工作量实在巨大，尽管如此，依然符合我们先写出来再说出来的务实风格。</p>\n<p><strong>环境准备</strong></p>\n<p>1、（必须）.Net Framework4.5+</p>\n<p>2、（必须）关系型数据库MySQL或SqlServer或PostgreSQL或MariaDB四选一</p>\n<p>3、（必须）PowerDotNet<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/db-system-design-and-implement.html\" target=\"_blank\">数据库管理平台</a></p>\n<p>4、（必须）PowerDotNet配置中心<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/app-system-design-and-implement.html\" target=\"_blank\">Power.ConfigCenter</a></p>\n<p>5、（必须）PowerDotNet注册中心<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/service-governance-design-and-implement.html\" target=\"_blank\">Power.RegistryCenter</a></p>\n<p>6、（必须）PowerDotNet缓存平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/cache-platform-design-and-implement.html\" target=\"_blank\">Power.Cache</a></p>\n<p>7、（必须）PowerDotNet消息平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/messaging-queue-platform-design-and-implement.html\" target=\"_blank\">Power.Message</a></p>\n<p>8、（必须）PowerDotNet文件平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/file-platform-design-and-implement.html\" target=\"_blank\">Power.File</a></p>\n<p>9、（必须）PowerDotNet人员管理平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/human-crm-design-and-implement.html\" target=\"_blank\">Power.HCRM</a></p>\n<p>10、（必须）PowerDotNet基础数据平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/basedata-system-design-and-implement.html\" target=\"_blank\">Power.BaseData</a></p>\n<h3>一、名词术语</h3>\n<p>商品可以认为是影响传统电商业务全局的基础数据，在供应链、仓库、门店、订单、支付、财务、结算、配送等业务端被广泛使用，对电商业务正常运营流转有举足轻重的作用。</p>\n<p>所有的辩论，都是定义之争。作为给电商中的商品、渠道商品和货品都写过代码的资深开发，个人很熟悉不良商品设计给仓端、配端和财务等系统造成的问题，觉得有必要再明确商品的定义。</p>\n<p>商品特别基础，但有些公司直到倒闭了，对商品概念还含糊不清，别问我怎么知道的，我就是知道，咩哈哈。本着发现问题，定义问题，解决问题的原则，本文争取把商品管理写个清楚明白。</p>\n<p>职业生涯至今，有了些业务和技术积累，但在商品管理里经常碰到误把冯京作马凉的情况，反而是看上去盘根错节枝繁叶茂的支付、财务和CRM等系统处理起来更加得心应手融会贯通。</p>\n<p>虽然个人有多年的电商开发经验，自认为也非常了解商品系统，什么产品、商品、货品、原料、辅料、SPU、SKU、渠道商品、属性、规格、参数、标签、包装方案、BOM等等都耳熟能详。</p>\n<p>可是真要严格说出个所以然来，有些定义写出来真不那么让人信服，本文还是先对照着搜索引擎摘录一下，防止系统都做出来了，对基本概念还稀里糊涂的，让人觉得可靠性堪忧，咩哈哈。</p>\n<h4>1、商品</h4>\n<p>马克思主义政治经济学认为：人类劳动是最可贵的，它可以创造价值。这就是马克思主义在经济学里最出名的一个理论，即劳动价值论。</p>\n<p>根据这个基础的理论，马克思给商品的定义是“商品是用来交换的劳动产品”。</p>\n<p>一个物品要想成为商品必须满足两个条件：</p>\n<p>（1）、它必须是劳动产品</p>\n<p>一个物品要想成为商品它就必须是人类劳动的结晶，劳动创造价值，所有的商品都应该是人们劳动生产出来的，也就是说必须凝结了一定的人类劳动。</p>\n<p>（2）、它必须是用于交换的</p>\n<p>假如一件物品其本身只是凝结了人类劳动，但本身并没有用于交换，而只是用于自己消费，这种物品就算不上是商品，因为商品最大的外在表现形式在于交换。</p>\n<p><strong>商品的二重性</strong></p>\n<p>商品二重性是指商品具有使用价值和价值两重属性。商品是用来交换的劳动产品，具有使用价值和价值两种属性，商品是使用价值和价值的统一。</p>\n<p>商品的有用性，即能够用来满足人们某种需要的属性，就是商品的使用价值。</p>\n<p>凝结在商品中的一般人类劳动就是商品的价值，各种商品的价值，只有量的差别，而无质的不同。</p>\n<p>价值存在于商品体内，是商品的社会属性，体现着商品生产者相互交换劳动的社会关系。</p>\n<p>（1）、使用价值</p>\n<p>商品要能够交换就必须有用，使用价值是物品能够满足人们某种需要的属性，它是商品的自然属性，是构成社会财富的物质内容，是人类社会赖以生存和发展的物质基础。它体现了人与自然的关系。使用价值本身并不是政治经济学的研究对象。马克思政治经济学之所以要考察使用价值，是因为商品的使用价值是其交换价值的物质承担者。一种物品要成为商品，仅有使用价值是不够的，它还必须是用来交换的，即具有交换价值。商品除具有使用价值外，还具有交换价值。交换价值是一种使用价值同另一种使用价值相交换的量的关系或比例。</p>\n<p>（2）、价值</p>\n<p>价值是凝结在商品中的无差别的一般人类劳动，它是商品的社会属性，也是商品所特有的属性，体现了商品生产者相互比较和交换劳动的经济关系。马克思主义揭示了劳动是价值的源泉。价值是一个历史的范畴。作为商品的二因素之一，价值是商品最本质的因素。</p>\n<p>（3）使用价值和价值的关系</p>\n<p>价值是使用价值的基础，使用价值是价值的表现形式。&nbsp;</p>\n<p>商品是使用价值和价值的矛盾统一体，使用价值和价值之间存在着对立统一的辩证关系。</p>\n<p>首先，使用价值与价值是统一的。二者共处于一个统一体中，缺一就不成其为商品。价值的存在要以使用价值的存在为前提，没有使用价值的东西也就不会有价值；使用价值是价值的物质承担者，价值寓于使用价值之中。</p>\n<p>其次，使用价值与价值又是不同的、矛盾的。</p>\n<p>因为：第一，对同一商品生产者或消费者来说，同一商品的使用价值和价值不可兼得。商品生产者向消费者让渡使用价值以换取价值，消费者为得到使用价值而支付价值。</p>\n<p>第二，使用价值是商品的自然属性，体现人与自然的关系；而价值是商品的社会属性，体现商品生产者之间的经济关系。 使用价值是一切有用物品包括商品所共有的属性，是永恒的范畴；价值是商品所特有的属性，是商品经济的范畴，因而是历史的范畴。</p>\n<p>商品之所以具有使用价值和价值两个因素，是由于生产商品的劳动具有二重性。劳动二重性决定商品二因素，具体劳动创造使用价值，抽象劳动形成价值。 劳动二重性是商品二重性的根源。</p>\n<h4>2、SPU和SKU</h4>\n<p>（1）、SPU</p>\n<p>SPU = Standard Product Unit （标准化产品单元）</p>\n<p>SPU是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。</p>\n<p>（2）、SKU</p>\n<p>SKU = Stock Keeping Unit(库存量单位)</p>\n<p>SKU即库存进出计量的单位（买家购买、商家进货、供应商备货、工厂生产等都是依据SKU进行的），SKU是物理上不可分割的最小存货单元，也就是说一款商品，可以根据SKU来确定具体的货物存量。</p>\n<p>（3）、异同</p>\n<p>SPU和SKU都是一组属性名值对的大集合，一组相似SKU抽象出的公共集合的统称可以认为就是SPU，下面以一个通俗易懂的示例来直观理解SPU和SKU。</p>\n<p>华为P50 Pro手机是一种SPU；生产于中国大陆基于鸿蒙操作系统于2021年上市的黑色机身内存128GB运行内存8GB...的华为P50 Pro手机是一个SKU。</p>\n<p>可以看到一种商品SPU包含多种SKU，SPU（SKU1、SKU2……SKU n），且SKU唯一，具有详细属性规格参数的SPU就可以唯一定义一个SKU。</p>\n<p>因为规格（属性或参数）的不同，SKU容易产生组合爆炸难题。以华为P50 Pro为例，关键规格有颜色（黑色、白色、银色、金色）、机身内存（128G、256G、512G），可以组合出4x3=12个SKU。</p>\n<p>从市场交易的角度来说，SPU是一种抽象集合，是无形的，无法直接定价，虽然直观理解是有价值和使用价值的，但没有价格，不能被交易；而SKU有价值和使用价值，也有价格，可以进行买卖。</p>\n<p>通常我们口头上所说的商品，其实可以直观理解为SKU。当然我们口头上说买了一部华为P50 Pro手机是不严谨的，应该说买了一部黑色机身内存128GB运行内存8GB...（其他属性）的华为P50 Pro手机。</p>\n<p>特别提醒，商品、SKU和SPU是完全不同的三个独立概念，SPU到SKU再到商品，是从抽象逐步到具体的过程，商品模型决定了基本定义能否被严格区分，但现实开发中常有人把它们混用而不自知。</p>\n<h4>3、产品</h4>\n<p>产品是指被人们使用和消费，并能满足人们某种需求的任何东西，包括有形的物品、无形的服务、组织、观念或它们的组合。</p>\n<p>在经济领域中，通常也可理解为组织制造的任何制品或制品的组合。在现代汉语词典当中的解释为“生产出来的物品”。</p>\n<p>网上有很多文章将SPU说成是产品或者等价于产品，个人认为是不太严谨的，但是绝大多数电子商务环境下这么理解也是可以接受的。</p>\n<p>产品一般可以分为五个层次，即核心产品、基本产品、期望产品、附加产品、潜在产品。</p>\n<p>（1）、核心产品是指整体产品提供给购买者的直接利益和效用；</p>\n<p>（2）、基本产品是指核心产品的宏观化；</p>\n<p>（3）、期望产品是指顾客在购买产品时，一般会期望得到的一组特性或条件；</p>\n<p>（4）、附加产品是指超过顾客期望的产品；</p>\n<p>（5）、潜在产品是指产品或开发物在未来可能产生的改进和变革。</p>\n<p>简单来说就是“为了满足市场需要，而创建的用于运营的功能及服务”就是产品。</p>\n<p>在交换的时空场景、过程中，产品可以被称为商品，也就是说产品和商品是可以互相转换的。</p>\n<p>产品和商品的主要区别：产品不论是交换前与交换后都可称为产品。而当一种产品经过买卖交换进入使用过程后，如果不存在交换场景中就不能再称之为商品，只能称为产品。当这个产品又在交换的场景中的时候，那么在这段即将发生买卖交换的时间空间内，它又能被称之为商品。商品是用于买卖交换前的产品，产品经过买卖交换进入使用阶段后就不能称为商品了，只能称为产品。</p>\n<h4>4、货品</h4>\n<p><a href=\"https://baike.baidu.com/item/%E8%B4%A7%E5%93%81/4181397\" rel=\"noopener nofollow\" target=\"_blank\">货品</a>，汉语词语，读音是huò pǐn，意思是货物；也指货物的品种。</p>\n<p>百度百科里的这个2025年之前的（旧）解释真是坑爹，简直就和没解释一样。我们再来看看几个流行AI工具对货品的定义是什么样的。</p>\n<p>（1）、<a href=\"https://tongyi.aliyun.com/qianwen/\" rel=\"noopener nofollow\" target=\"_blank\">通义千问</a></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/32361/202501/32361-20250120194050109-691265243.png\" /></p>\n<p>（2）、字节<a href=\"https://www.doubao.com/chat/\" rel=\"noopener nofollow\" target=\"_blank\">豆包</a></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/32361/202501/32361-20250120194109127-1087604747.png\" /></p>\n<p>（3）、<a href=\"https://www.deepseek.com/\" rel=\"noopener nofollow\" target=\"_blank\">DeepSeek</a></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/32361/202501/32361-20250120194143085-651858788.png\" /></p>\n<p>（4）、<a href=\"https://yiyan.baidu.com/\" rel=\"noopener nofollow\" target=\"_blank\">文心一言</a></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/32361/202501/32361-20250120194159306-1190941789.png\" /></p>\n<p>（5）、<a href=\"https://hunyuan.tencent.com/\" rel=\"noopener nofollow\" target=\"_blank\">腾讯混元</a></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/32361/202501/32361-20250120194219993-1097272774.png\" /></p>\n<p>（6）、<a href=\"https://kimi.moonshot.cn/\" rel=\"noopener nofollow\" target=\"_blank\">Kimi</a></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/32361/202501/32361-20250120203106556-1605965651.png\" /></p>\n<p>根据AI工具给出的解释，我们能够得到如下结论：</p>\n<p>（1）、商品，更强调经济属性，是指为交换而生产的劳动产品，具有价值和使用价值。商品的核心在于“交换”。</p>\n<p>（2）、货品，更强调物理属性，是指具体的物品或货物，通常指库存、仓储或运输中的物品。货品的核心在于“物品本身”。</p>\n<p>个人认为货品这个名词本身就是很抽象的定义，对抽象本身再进行抽象，实现的结果就可能挺抽象的。</p>\n<p>曾经某电商公司以货品来重写商品系统，从设计之初到上线再到日常运营甚至公司关门大吉前都问题不断，尤其是货品表的一把梭设计，一张表一百几十个字段，让人大开眼界，咩哈哈。</p>\n<p>货品看上去是一种合理的抽象定义，但实践证明不宜用于商品系统设计，遗憾的是个人投入再多精力也无济于事。抽象和设计糟糕造成业务系统写不好，不比刻骨铭心爱而不得好受多少。</p>\n<h4>5、原料</h4>\n<p>用于进一步加工的材料即为原料，可以是其它加工过程的产物，也可以是自然界生长或自然形成的产物。</p>\n<p>原料可以进行采购，可以交换和买卖，其价格往往是标准价格或按质论价，典型示例如铁矿石等。</p>\n<p>原料在采购和买卖的过程中，有使用价值和价值，有价格，这样就自动转换为了商品。</p>\n<h4>6、辅料</h4>\n<p>对产品生产起辅助作用的材料。示例：服装的辅料，有拉链，纽扣，兜标等附属物；生鲜类产品的辅料有塑料箱、胶带等。</p>\n<p>辅料也可以进行采购，可以交换和买卖，在采购和买卖的过程中，有使用价值和价值，有价格，这样就自动转换为了商品。</p>\n<h4>7、BOM</h4>\n<p>BOM = Bill of Material，叫做物料清单，也叫产品结构表、物料表等。</p>\n<p>将产品的原材料、零配件、组合件予以拆解，并将各单项物料按物料代码、品名、规格、单位用量、损耗等依制造流程的顺序记录下来，排列为一个清单，这就是物料清单，也就是BOM。</p>\n<p>BOM是：</p>\n<p>(1) 、物资需求计划（Material Requirement Planning，MRP）的基础。</p>\n<p>(2) 、制造令发料的计算依据。</p>\n<p>(3) 、本质上是一项工程文件，不但是产品的规范说明，而且是制造流程的依据。</p>\n<p>(4) 、用来核算产品成本的基础。</p>\n<p>由以上知道BOM的重要性及其影响范围很大，故其内容必须随时保持正确及时。&nbsp;</p>\n<h4>8、渠道商品</h4>\n<p>发布到某个销售渠道的商品集合，例如线下实体店、线上商城、自助售货机、无人售货商店等渠道。渠道商品在业务系统处理过程中往往会增加很多额外工作量以适配不同渠道。</p>\n<p>渠道商品的架构设计和实现非常考验开发者的水平和经验，设计不好，除了增加工作量和系统复杂度，每次看到和维护不可描述的业务代码更是让人头疼，这也是个人经验之谈。</p>\n<h4>9、商品规格</h4>\n<p>商品规格（Goods specifications），是指一些足以反映商品品质的主要指标，如化学成分、含量、纯度、性能、容量、长短、粗细等。</p>\n<p>例如：买衣服的商品规格指的是尺寸的大小，一般的均码分大、中、小号；有的较细，上衣依据衣长、胸围、领长分大小，下裤依据裤长短、腰围分大小等等。</p>\n<h4>10、商品属性</h4>\n<p>商品属性，平常也叫商品参数，是指商品本身所固有的性质，是商品在不同领域差异性（不同于其他商品的性质）的集合。也就是说，商品属性是商品性质的集合，是商品差异性的集合。</p>\n<p>简单来说，商品属性是描述商品维度的字段，也就是商品的基本信息。</p>\n<p>属性或参数或规格，它们其实非常相似，当然商品属性、商品参数、商品规格的严格定义和区分一直有争议，本文不做过多讨论。</p>\n<h3>二、商品基础</h3>\n<p>任何系统都会或多或少用到些字典型的基础数据，商品系统当然也不例外。商品基础数据管理是主数据管理中非常重要的环节，在电商活动中商品基础数据出现频率极高。</p>\n<p>本文简单介绍几种最常见的查询检索用到的基础数据，包括品牌、分类、厂商等。</p>\n<h4>1、品牌</h4>\n<p>各种各样电子商务活动中出现频率最高的词汇之一就是品牌。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206132301842-1534048670.png\" /></p>\n<h4>2、厂商</h4>\n<p>商品的厂商和品牌息息相关。</p>\n<p>品牌和厂商通过关系表进行连接查询，品牌和厂商通常是一对一或一对多的关系。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206133412481-1600579638.png\" /></p>\n<h4>3、分类</h4>\n<p>商品分类是商品分组聚合最常用到的技术和业务手段，分类通常支持层级管理，最多二到三级为宜，很多电商公司分类层级都最多精确到三级分类。</p>\n<p>PowerDotNet实现的商品平台目前支持通用的三级商品分类，满足绝大多数电商业务需求，复杂度可控，可扩展性也适中。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206133145322-1984363967.png\" /></p>\n<h4>4、分类分组</h4>\n<p>商品分类自身也支持分组管理，比如商品分类可以分为前台分类、后台分类、营销分类、手机分类等等，按照业务需要进行扩展。</p>\n<p>当然商品分类分组不是必须，如果分类设计的好，可扩展性优秀，完全可以适配多种场景，不需要再独立进行分组管理。</p>\n<h4>5、其他</h4>\n<p>其他如商品标签、单位、产地、价保等基础数据本文不再列出。</p>\n<p>有些电商公司还会把尺码、颜色等抽象出来放在基础数据表里，PowerDotNet实现的商品平台没有采用这种做法。</p>\n<h3>三、SPU管理</h3>\n<p>SPU的抽象能够大大简化商品管理。让我们再来复习一遍SPU的定义。</p>\n<p>SPU = Standard Product Unit （标准化产品单元），SPU是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。</p>\n<h4>1、SPU档案</h4>\n<p>SPU包含的标准化的信息主要包括品牌、分类、厂商、区域、助记码等公共信息，个性化的信息不适合抽象到SPU中，可以在商品属性中独立添加或修改。</p>\n<p>SPU抽象的粒度非常考验业务或运营人员的经验和需求，缺少经验的业务运营人员经常会需要不断变更SPU的定义。</p>\n<p>比如，华为P40 Pro和华为P50 Pro可以定义成两个SPU，也可以直接定义成华为手机Pn系列一个SPU，这个就看实际运营需求，通常情况下SPU管理宜细不宜粗，越具体越好。</p>\n<p>SPU的管理对商品系统的稳定非常重要，如果系统里SPU需要经常变动，我们很可能需要重新抽象定义新的SPU。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206165019077-1805649348.png\" /></p>\n<p>SPU字段较多，新增SPU比较考验业务和运营人员的耐心，当然对于相似的SPU，商品平台提供了快速复制生成SPU的工具，几个必填参数改改或者留空后台自动生成，很容易就能添加一个SPU。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221208180545691-164593647.png\" /></p>\n<h4>2、审核SPU</h4>\n<p>SPU的管理对商品系统的稳定是如此重要，所以SPU所有新增或修改操作都需要人员审核，所有关于SPU的操作都要添加审计日志，特定环境或场景下可以依赖日志快速恢复或还原。</p>\n<h4>3、生成商品</h4>\n<p>SPU不是商品，但是可以通过SPU工具自动批量快速生成最终售卖的商品，有差异性的商品属性单独修改即可，这样就可以大大简化商品的添加操作。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221208180045247-2005847316.png\" /></p>\n<h3>四、属性管理</h3>\n<p>商品属性是对我们通常所说的商品规格、商品属性和商品参数的通用抽象。</p>\n<p>PowerDotNet重写的商品平台，对规格、属性和参数经过慎重考虑后进行了裁剪和取舍，直接按照商品属性来定义商品元数据，不延用规格而使用属性仅仅是因为作者的个人喜好，咩哈哈。</p>\n<p>商品属性的表设计采用了经典的元数据设计大法，按照属性名和属性值进行独立建表，可扩展性非常好，虽然查询检索可能会比较复杂，但是有成熟的技术手段如Lucene、ES等全文检索技术优化查询。</p>\n<p>属性名值对支持文本、单选和多选设计，这种设计方法对于电商系统中常见的单规格商品和多规格商品可以完美支持。</p>\n<p>有了元数据设计法，品牌、分类等商品基础属性通过名值对字典表也能完美适配，但很多电商都独立设计这几张数据表，一个原因是查询频繁，另一个可能是品牌有图片，分类有前台、APP显示名称等，业务字段较多。</p>\n<h4>1、属性名</h4>\n<p>属性名支持分组管理，这个抽象通常都是后台管理用到，前端逻辑不需要过分关注。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206141604963-2124763475.png\" /></p>\n<p>属性名也支持层级管理，通常不那么复杂的电商场景，只设计一级属性名即可。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206135652018-632561398.png\" /></p>\n<h4>&nbsp;2、属性值</h4>\n<p>根据属性名定义不同的属性值，对于单规格商品就设置一个值，多规格商品就设置多个属性值。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206141318522-2051644006.png\" /></p>\n<h4>&nbsp;3、商品属性</h4>\n<p>属性名和属性值定义好了，最终是要作用于商品上的，否则单独设计属性名和属性值也没有意义。</p>\n<p>商品、属性名和属性值可以通过传统的中间关系表产生关联，这样可以达到属性名值对作用于商品上的效果。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221207090434834-2105754989.png\" /></p>\n<p>PowerDotNet实现的商品平台更进一步，设计了商品属性表，这张表对属性名和属性值进行了大量冗余。这样设计的优点是属性名或者属性值变更时不会影响到现有的商品属性；缺点也比较明显，某些查询场景下需要行转列处理，冗余数据略多，如果相同的改动就需要作用于大部分商品，可能不得不改动大量的冗余数据。</p>\n<p>PowerDotNet开发的商品平台有商品属性名和商品属性值自动同步功能，可以按照商品、SPU、分类、品牌等不同维度和粒度进行批量同步数据操作，大大减少属性数据变更导致的业务和运营人员的工作量。</p>\n<p>当然这个中间商品属性表的维护还是需要人员花费大量精力和时间，毕竟商品属性很多，幸好有模板设计法，PowerDotNet内置了很多模板工具和方法，可以进行批量增删改操作，同样能大大减少工作量。</p>\n<p>不得不说，元数据大法好，模板大法好，PowerDotNet大法好，咩哈哈。</p>\n<h3>五、模板管理</h3>\n<p>电商平台的商品琳琅满目，属性成千上万，如果我们对商品属性管理按照商品一个一个进行录入，工作量巨大，而且容易出错。</p>\n<p>通过模板设计大法，我们完全没有必要按照商品进行一个一个管理，可以先定义好属性模板，按照SPU、分类、品牌等进行模板管理，只需要录入必须的基本的属性名和属性值就可以按照模板批量管理。</p>\n<p>当然，模板生成的商品属性通常都是通用的没有明显差异化的，需要个性化的商品属性我们可以按照商品一个一个进行补充，这种操作通常很少，工作量完全可以接受。</p>\n<h4>1、模板信息</h4>\n<p>可以按照SPU、分类、品牌等分组命名模板，望文知义，所见即所得，便于运营和管理。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206144318239-1587383372.png\" /></p>\n<h4>2、模板属性</h4>\n<p>定义模板是为了解决属性繁多易错的问题，所以模板就要和属性名、属性值产生关联关系。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206144422535-383976370.png\" /></p>\n<h4>3、复制模板</h4>\n<p>对于相似SPU、分类或品牌，PowerDotNet商品平台提供了快捷复制工具，可以按照已有模板批量复制模板和模板关联属性，大大减少业务工作量。</p>\n<h4>4、同步模板</h4>\n<p>模板的改动相对而言比较少，但是如果有变更，比如属性名值的增删改，我们可以通过同步工具自动批量将变更数据同步到各个商品中，业务要做的事情就是点下按钮而已。</p>\n<h4>5、SPU模板</h4>\n<p>一种SPU可以包含多种商品，定义好SPU模板，可以一键生成相同SPU下的一组商品的商品属性，差异化的属性再到商品属性管理页面下独立设置修改即可。</p>\n<p>举例：SPU为华为P50 Pro，主要差异属性有颜色（黑色、白色、银色、金色）和机身内存（128G、256G、512G），定义好模板，可以一键生成4x3=12个商品的所有商品属性。</p>\n<p>根据SPU自动生成商品的过程，其实也是自动生成SKU的过程，但这个过程在PowerDotNet商品管理里可以弱化，后续介绍SKU的时候再介绍下为什么要弱化这个过程。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206151538327-1922451407.png\" /></p>\n<h4>6、分类模板</h4>\n<p>如果某些分类下的商品属性非常相似，可以定义比SPU更粗力度的模板，批量生成相同分类下的商品属性，差异化的属性再到商品属性下独立设置修改即可。</p>\n<p>举例：三级分类为手机，定义好分类下的模板，可以一键批量生成手机分类下的商品属性。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206152127989-2138100602.png\" /></p>\n<h4>7、分类品牌模板</h4>\n<p>和分类模板的主要功能和作用类似，只不过分类品牌模板是在分类相同的情况下再找到相同品牌的商品，商品范围被缩小，差异化的属性再到商品属性下独立设置修改即可。</p>\n<p>举例：三级分类为手机，品牌为华为，定义好分类品牌下的模板，可以一键批量生成手机分类下华为手机的商品属性。</p>\n<p><img alt=\"\" src=\"https://img2022.cnblogs.com/blog/32361/202208/32361-20220809084739759-486578833.png\" /></p>\n<h3><strong>六、商品管理</strong></h3>\n<p>商品管理模块主要包括商品信息、商品属性、商品条码、商品价保、商品图片、商品视频等常用功能。</p>\n<p>有些公司的商品管理代码，对很多基础概念那叫一个不讲究，尤其是SPU和SKU，规格、属性和参数等容易混淆的内容，有经验的人看过就知道，不出意外的话，总有一天会出意外。</p>\n<h4>1、SKU</h4>\n<p>SKU = Stock Keeping Unit(库存量单位)，严格按照定义来看，显而易见，SKU肯定不完全等于商品，实际情况也确实是这样的，商品定义远远比SKU要复杂的多，商品要应对的变化也远比SKU复杂。</p>\n<p>在传统的商品管理体系设计和实现中，商品管理一般都会包含SPU、SKU和商品信息三层管理逻辑，商品ID(GoodsId)、SkuId和SpuId之间有关联关系，抽象程度越高，定义越明确，商品更容易管理。</p>\n<p>个人经验中，SKU主要基于商品的销售属性生成，常用于库存和价格管理，后台控制更多；而商品的整体定义，除了销售属性，还有条码、图片、视频和营销等等各种元素，前后台都有复杂控制逻辑。</p>\n<p>SPU可以根据模板自动生成SKU和商品，SKU属于商品和SPU之间的过渡角色，如果你开发过的WMS、MES和商品管理系统CMS都是以商品为准，SKU的地位就很尴尬，让人几乎感觉不到它的存在。</p>\n<p>PowerDotNet的SKU设计参考了前厂的商品管理，商品和SKU仅有简单的关联关系，实际商品管理都是以商品为准，弱化了SKU的存在，WMS和MES中的商品库存也是商品为准，这就是理论和实践的区别。</p>\n<h4>2、商品档案</h4>\n<p>支持商品信息的增删改查，支持快捷生成商品。通过模板可以批量生成商品属性，通过SPU可以一键批量生成商品。</p>\n<p>PowerDotNet实现的商品信息管理兼具易用性和可扩展性，查询也比较方便，对于中小公司，甚至不需要上全文检索，直接创建宽表根据RDBMS的查询功能即可实现基本业务需求。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221213145631931-195792669.png\" /></p>\n<p>商品信息字段比较多，商品管理后台提供了完善的偷懒工具，只要点击复制按钮，必填参数改一下或者不填由后台自动生成，可以大大提高录入数据速度和准确性，对于同品类或相同SPU的商品有奇效。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221208175354118-561045316.png\" /></p>\n<h4>3、商品属性</h4>\n<p>商品信息里的字段主要是常用检索字段和通用信息字段，商品属性定义更丰富的商品维度描述。</p>\n<p>字典表属性名和属性值修改后可以批量同步到商品属性中，这是一个比较危险的操作，尤其是销售属性的批量同步变更，需要业务反复查询对比确认后才能操作。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221208175449198-1936930492.png\" /></p>\n<p>前面属性管理处我们已经说过，PowerDotNet实现的商品平台对商品属性表做了大量冗余，支持自定义，支持修改特定商品属性名值对而不影响全局。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206190656761-1329187443.png\" /></p>\n<h4>4、商品条码</h4>\n<p>条码的应用非常广泛，PowerDotNet实现的商品条码支持商品普通条码和二维码的生成。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206210757518-412261095.png\" /></p>\n<p>某些商品还需要按渠道不同生成特定渠道的条码和二维码，PowerDotNet预留了扩展用以后续支持。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221212205016231-411154734.png\" /></p>\n<p>商品条码和商品库存有一定的关系，通常情况下，相同商品SKU的有效条码可以重复，重复个数和库存数相等，当然不严格的情况下条码也可以重复生成或作废，并不强求条码和库存数一定相等。</p>\n<h4>5、商品价保</h4>\n<p>价保基础表定义价保信息，商品再根据商品和价保关系表构成商品价保，这样设计的好处是价保信息可以复用。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206205759684-1812971442.png\" /></p>\n<p>其中价保关系表还特别设计了价保开始和结束时间，满足绝大多数电商促销活动的需求。当然有些电商的活动规则引擎会把价保自动放到规则中去，不需要在商品系统中进行价保维护。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206205820053-692332191.png\" /></p>\n<h4>6、商品图片</h4>\n<p>商品图片主要利用文件平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/file-platform-design-and-implement.html\" target=\"_blank\">Power.File</a>实现图片的管理，本文不再赘述。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206191530363-1760500606.png\" /></p>\n<h4>7、商品视频</h4>\n<p>和商品图片类似，目前短视频极其流行，视频文件大小较大，对文件服务器有较高要求。</p>\n<h4>8、商品统计</h4>\n<p>电商系统中商品众多，排序在商品展示中有重要作用，常见的排序指标比如评论数、收藏数、销量等等，这些数据主要由统计计算而来，直接设计存储在商品系统中非常合理，当然这些数据存储在其他系统（如CRM、订单等）中进行汇总定时通知到商品系统或者商品系统主动调用接口查询也是常见的可行方案。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221213145745193-1646418969.png\" /></p>\n<h4>9、其他</h4>\n<p>其他如商品买家秀等个性化数据没有设计在商品平台里，个人认为这些模块功能属于商品系统的可扩展设计，对于中小电商系统它们完全可以划归到<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/pcrm-design-and-implement.html\" target=\"_blank\">Power.PCRM</a>中去。</p>\n<p>商品库存则很明显需要开发库存或者进销存系统进行商品库存管理，复杂点的库存管理系统还需要包括原料、辅料、生产加工等等功能模块，这些正是WMS和MES系统的长项。</p>\n<p>为了查漏补缺，我试着问国内几个主流AI工具相同的问题“提供一份电子商务商品系统主要的数据库表设计”，最终比较满意的竟然是<a href=\"https://www.doubao.com/chat/\" rel=\"noopener nofollow\" target=\"_blank\">字节豆包</a>，而我预料中最可能接近答案的<a href=\"https://tongyi.aliyun.com/qianwen/\" rel=\"noopener nofollow\" target=\"_blank\">通义千问</a>还不如<a href=\"https://www.deepseek.com/\" rel=\"noopener nofollow\" target=\"_blank\">DeepSeek</a>给的结果靠谱。</p>\n<h3>七、日志管理</h3>\n<p>商品平台是电商系统最基础最重要最敏感的业务系统之一，所以对商品的增删改操作都要有业务操作日志，某些核心查询操作也需要按需记录审计日志。</p>\n<h4>1、商品日志</h4>\n<p>主要用于记录并管理商品的核心操作日志，特殊情况下还可根据这些日志进行业务数据还原和恢复。</p>\n<p>根据个人经验，所有基础数据表的修改，自定义商品属性、销售属性、价格等敏感参数都需要重点记录日志，防止修改错误需要紧急修复。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206192659006-980543551.png\" /></p>\n<h4>2、系统日志</h4>\n<p>系统日志相对商品日志，重要性就不那么突出，主要记录一些日常操作日志、对外提供接口日志、业务不敏感日志等。</p>\n<p>系统日志可通过定时任务自动归档或者清理。</p>\n<h3>八、特殊商品</h3>\n<p>上面列举的一系列商品功能只是最通用最基础的电商商品抽象，还有一些特殊商品，正是我实现过程中痛苦和挣扎的主要来源，可能还需要按需进行额外扩展设计和管理。</p>\n<p>Power.Commodity一开始只是我没事写点代码让自己高兴高兴的临时作品，目的也只是单纯总结和提取个人工作过的商品代码，但写着写着就发现越来越深不见底，尤其是特殊商品实在难以全部覆盖。</p>\n<p>本文不探讨特殊商品的具体管理设计开发和建设细节，因为这是另外一个漫长的故事了，对于体力活我也是有追求的，所谓识时务者为俊杰^_^，只简单说说个人实际参与设计开发过的几种特殊商品。</p>\n<h4>1、汽车商品</h4>\n<p>汽车商品是一种特殊商品，区别于一般商品的主要特点包括：</p>\n<p>（1）、零件多，技术含量高，属性多且复杂</p>\n<p>（2）、金额较大</p>\n<p>（3）、耐用品</p>\n<p>（4）、涉及重大安全问题</p>\n<p>（5）、有专属的交通法规，管理人员，道路辅助等</p>\n<p>（6）、大件，重量较大，不易快递或转运，配合门店或4S店销售</p>\n<p>（7）、是高档金融消费品，和金融保险联系紧密</p>\n<p>（8）、其他，如税费较多，汽车商品常见的5种税：车辆购置税、车船税、增值税、消费税、关税，除车款外其他费用包括上牌费、保险（交强险、商业险）等</p>\n<p>多层级属性是汽车商品的一个显著特点，汽车商品常见的一级属性包括品牌、厂商、车系、车款、车身、发动机、电动机、变速箱、底盘转向、车轮制动、安全装备、操控配置、外部配置、内部配置、座椅配置、多媒体配置、灯光配置、玻璃/后视镜、空调/冰箱、高科技配置等，每一个属性下又可以继续拆分出不同的子属性，比如多媒体配置，我们可以继续拆分出GPS导航、定位互动服务、中控台彩色大屏、蓝牙/车载电话、车载电视、后排液晶屏、外接音源接口、CD支持MP3/WMA、多媒体系统、扬声器品牌、扬声器数量、220V/230V电源系统等子属性。</p>\n<p>相比普通商品，汽车商品查询检索有较多的多规格设计，常见的除了分类和品牌外，还包括价格、排量（如1.1-1.6L、1.7-2.0L）、能源（如汽油、新能源）、结构（如两厢、三厢）、国别（如中国、欧系）、配置（如全景天窗、电动天窗）、驱动、变速箱、座位、进气形式、生产方式等。</p>\n<p>个人开发经验中，和汽车这种巨多规格和属性的商品类似的还包括药品和生鲜类商品，对于这种繁多而复杂的商品，一张宽表一把梭的设计特别容易造成开发和维护灾难。</p>\n<p>PowerDotNet的商品属性设计和模板方法完全可以应对汽车商品的多规格属性配置，只是属性层级多，属性字段也很多，查询逻辑略微复杂。</p>\n<h4>2、生鲜商品</h4>\n<p>生鲜商品的最大特点是任意性和随意性，正是因为这两个特性导致生鲜商品的标准化远远滞后于一般商品，而标准化在商品平台设计与实现中至关重要。</p>\n<p>我们还是以前面提到的华为手机举例，通过一个简单示例对比，看一下标准化生鲜商品为什么会比较困难：</p>\n<p>华为P50 Pro手机是一种SPU；生产于中国大陆基于鸿蒙操作系统于2021年上市的黑色机身内存128GB运行内存8GB...的华为P50 Pro手机是一个SKU。</p>\n<p>相对应的，生鲜类标准化商品会有如下描述：</p>\n<p>南汇8424西瓜是一种SPU；产于中国上海的于2021年上市的重量为XX公斤到YY公斤...的南汇8848西瓜是一个SKU。</p>\n<p>\"人不能两次踏进同一条河流\"，这是古希腊哲学家赫拉克利特说的。西瓜不能两次长出同一种重量，我们也可以说的富有哲理，咩哈哈。</p>\n<p>假如标准化不加约定和限制，仅仅根据生鲜类商品的重量就能组合出很多种商品，造成SKU组合爆炸难题。</p>\n<p>有人可能会有疑问，为什么不按照单位重量或体积进行商品定义，比如产于中国上海的于2021年上市的每公斤5元的南汇8848西瓜是一个SKU，然后用户下订单，直接按照实际购买重量乘以单价即可。</p>\n<p>这种方案看上去非常完美，但是有一个先天缺陷，重量是需要人力称出来的，生鲜电商由于是大规模线上经营，通常都是预先通过生产加工系统进行称重，然后更新库存，不可能像实体店那样当面现称现卖。</p>\n<p>这个问题的解决方案就是针对特定生鲜产品进行评估，对相同SPU的商品给出一个大致模糊的重量（或体积）范围以满足生产加工的需要，商定出一个用户能接受的价格，达到一种买和卖的平衡。</p>\n<p>在一些电商站点上，生鲜商品比普通售卖的商品看上去没有更加复杂，有些行业特点比如储运条件（常温、恒温、冷冻、冷藏等）通过属性名值对或者扩展表也能很好支持，之所以拿出来单独说，主要是因为生鲜商品标准化背后隐藏的复杂性。</p>\n<p>生鲜商品非标准化的物品很难用标准化的商品软件来管控，很多生鲜电商公司都只能按需自研信息化服务，比如供应链、生产加工、仓储管理、质检、运输、配送等等，难度可想而知。</p>\n<p>个人曾经参与开发维护过一套生鲜系统，业务逻辑之恶劣，实现之奇葩，单据之多样，软件流程之长，使用之不友好，每看一遍代码都差点灵魂出窍，业务系统做成这种效果也是常人所不能及也。咩哈哈。</p>\n<p>我尝试过用PowerDotNet新的商品设计思路重构一个生鲜商品系统，但是难度和工作量极大，还会影响其他系统，最后只能撤销改动放弃努力，曾经有过美好，但有些事物失去了就是失去了，不可强求。</p>\n<p>假如商品平台要支持生鲜商品的主要特性，可能原料、辅料、包装方案、BOM、计划单、提货单、加工单、反加工单、损益单、尾料、原料顶替等名词都要再温故知新一遍，往事历历在目却遥不可及也。</p>\n<p>通用性、标准性和普适性的公共服务系统才是PowerDotNet努力的方向，而任意性和随意性天生就是公共服务的天敌，抽象和实现的难度肉眼可见成倍剧增，所以最新商品平台设计暂不支持生鲜类商品。</p>\n<h4>3、虚拟商品</h4>\n<p>最典型而常见的几种虚拟商品如下：</p>\n<p>（1）、网络游戏卡，是按服务公司的规定以现金兑换虚拟点(积分)的形式，通过消耗虚拟点(积分)来享受服务的一种支付形式。</p>\n<p>（2）、移动/联通/电信/充值，包括话费充值，流量充值等。</p>\n<p>（3）、网络软件，一般是指系统的操作系统、协议和应用级的提供服务功能的专用软件。</p>\n<p>（4）、网站产品，以产品的眼光看待网站是网站产品的精髓所在。网站产品不同于软件产品、服务产品、工业产品等。网站产品是一类信息产品，以网站的形式提供信息、服务或二者的结合是它的主要表现形式。</p>\n<p>我个人最熟悉的虚拟商品，包括网文（按章节收费）和电子书以及游戏点卡，某些公司的虚拟货币充值也可以抽象成一种商品，只要让用户下订单花钱支付购买同时又没有直接拿到实物产品，就可以认为用户购买的是虚拟商品。</p>\n<h4>4、服务商品</h4>\n<p>服务型商品也是日常生产生活中经常碰到的一种商品类型。最典型的如火车票、汽车票、酒店、机票、旅游度假等商品。</p>\n<p>以我个人比较熟悉的某OTA（Online Travel Agency，在线旅行社）机票产品为例，服务型商品也非常考验开发人员的设计和架构水平。</p>\n<p>机票系统涉及到很多业务数据表，常见的比如区域、二字码、三字码、机场、航站楼、航线、航司、飞机机型、中转地、行程总时长、仓位、常旅客、机票、机票库存、报价信息等表。</p>\n<p>机票、火车票、汽车票、船票和邮轮等非常相似，看上去都是一个“占座”的商品形式，完全可以抽象出公共部分。而酒店则有一个间夜的概念，外加酒店内的附属商品管理，复杂度更胜一筹。</p>\n<p>我们可以将机票航线、航班号、起降时间和具体飞机及仓位的组合（也就是一张飞机票）直观理解为商品，常见的机票商品包括单程和往返机票，还可以根据不同航线组合出联程/多程机票。</p>\n<p>对于机票，大家还应该听说过中航信（含eTerm 或IBE+，两者都知道的，我只想说吾道不孤矣），机票查询和预定基本离不开它。</p>\n<p>注：IBE+（Internet Booking Engine），即中国航信互联网订座引擎，是基于因特网的开放平台技术，它为各种用户应用系统提供访问中国航信传统订座业务系统的途径，是采用API方式的接口。</p>\n<p>据我所知，机票库存可以通过中航信的eTerm软件来查询，行业内的一般做法是将eTerm软件功能封装成接口，供内部系统使用，当然除了eTerm，现在还有IBE+以API接口的形式提供查询和预定功能。</p>\n<p>机票的库存信息一般称为AV信息，这个称呼的来源主要源于eTerm（黑屏）查库存指令。由于库存信息非常重要，因此每家OTA都会花费很多的流量在获取航班的AV信息上。</p>\n<p>由于eTerm和IBE+的接口响应时间较慢，因此OTA采用的方法基本都是主动去获取AV信息，然后缓存起来，绝大多数用户查询时直接拿缓存数据即可，当然有些情况下还是会出现查询缓存失败，再去实时获取AV信息的情况。</p>\n<p>相较于汽车、生鲜和虚拟商品，PowerDotNet的商品系统可能只需要加一些业务扩展表就可以完美支持，而服务类商品通常业务复杂，不容易做成通用设计，所以PowerDotNet已完成的商品设计将服务商品排除在外。</p>\n<p>我尝试着使用国内流行的人工智能服务（<a href=\"https://tongyi.aliyun.com/qianwen/\" rel=\"noopener nofollow\" target=\"_blank\">通义千问</a>、<a href=\"https://www.doubao.com/chat/\" rel=\"noopener nofollow\" target=\"_blank\">字节豆包</a>、<a href=\"https://www.deepseek.com/\" rel=\"noopener nofollow\" target=\"_blank\">DeepSeek</a>、<a href=\"https://yiyan.baidu.com/\" rel=\"noopener nofollow\" target=\"_blank\">文心一言</a>和<a href=\"https://hunyuan.tencent.com/\" rel=\"noopener nofollow\" target=\"_blank\">腾讯混元</a>），实现机票预定功能，给出的代码真是一言难尽，AI目前还无法给出超过预期的方案，祖传代码暂时还是安全的^_^。</p>\n<p>假如后续仍然需要加入机票、酒店、火车票、汽车票等服务商品功能，最好按照服务商品的特殊规范进行抽象设计，独立出来服务商品平台未尝不是一个好方法，元数据和模板设计大法同样有用武之地。</p>\n<p>当然，目前看来PowerDotNet实现的商品管理系统还是比较基础的传统的商品管理，想做到大一统的支持各种形态的商品，还需要做很多设计和实现工作，虽然我个人手头有现成的业务代码和解决方案可参考，咩哈哈。</p>\n<h3>九、商品搜索</h3>\n<h4>1、实现功能</h4>\n<p>商品搜索实现的功能主要包括按关键字搜索、中文分词、历史搜索、热门搜索、推荐搜索、联想关键词等等，绝大多数大中型电商公司的全站搜索服务就包括商品搜索功能。</p>\n<h4>2、解决方案</h4>\n<p>商品搜索在商品管理上算是常用而又有点技术难度的功能了，曾经有一种简单直接高效的暴力设计方法，就是添加一张商品关键词表，不过随着NoSQL和NewSQL的兴起，这种设计方案已显得非常落后。</p>\n<p>个人早年有幸独立实现过一个典型而朴素的商品搜索功能，按照商品分类、标签以及任意关键字，通过MySQL的查询功能，模糊或精确匹配，按权重分页展示，现在想来依然十分好笑，咩哈哈。</p>\n<p>搜索有很多现成的解决方案，比如基于Lucene或者ElasticSearch全文检索实现的搜索服务，按不同数据源（比如商品）建立索引，通过分词优化匹配查询索引，可按需实现对应系统（如商品）查询服务。</p>\n<p>Lucene和ElasticSearch在实践中极易一不小心踩到很多坑，尤其是ElasticSearch，个人印象最深的是看上去简单常用的分页查询，在数据量很大或者有较多分片的情况下，越往后分页查询性能越拉跨。</p>\n<p>个人曾经所在电商公司使用ES实现基本搜索功能，外加Redis和SqlServer配合实现搜索服务兜底方案，性能恶劣的sql语句like模糊匹配是最差的选择，like查询默认选择可以使用索引的左匹配。</p>\n<p>搜索服务的设计与实现比较有技术挑战，尤其是全站搜索和商品搜索结合，值得再开一篇文章详细介绍，不过这就是更偏重于分词索引实现搜索服务的另一个话题了，本文不再展开详细说明。</p>\n<h3>十、商品排序</h3>\n<p>商品搜索和商品排序是密不可分的，对于商品搜索结果，我们总是要根据一定的排序规则展示给用户。下面列举电商中常见的几种商品排序：</p>\n<h4>1、直接根据商品属性排序</h4>\n<p>比如商品价格、上架时间、商品序号、自定义排序序号等</p>\n<h4>2、根据商品相关统计进行排序</h4>\n<p>比如商品销量、好评数、关注数、浏览次数、回购率等</p>\n<h4>3、根据商家相关统计进行排序</h4>\n<p>比如商家信用、商家门店数等</p>\n<h4>4、根据距离排序</h4>\n<p>最常见最典型的就是在线外卖订餐平台，根据消费者当前位置，按照距离排序</p>\n<h4>5、综合排序</h4>\n<p>在实际电商业务场景中，系统默认推荐排序不是简单的根据单一字段进行排序，而是综合排序。</p>\n<p>通常来说，综合排序是先按商品和搜索关键词的相关性过滤，然后按上下架时间做预选，最后在预选结果里根据商品人气及质量等方面进行排序。</p>\n<h3>十一、系统交互</h3>\n<p>商品系统是电商最核心的组成部分之一，是电商平台的基础数据服务系统，和很多内部业务系统保持互通关系，整理下个人开发和对接过的几种常见互联系统。</p>\n<h4>1、订单系统</h4>\n<p>毫无疑问，订单的生成离不开商品，企业在正常的经营过程中，必须有销售商品、产品、提供劳务等业务，订单系统主要提供商品售卖服务。</p>\n<h4>2、库存系统</h4>\n<p>库存系统主要用于管理商品库存，主要包括商品入库、商品出库，商品调拨和商品盘点等操作。我们熟知的仓储WMS系统就包括库存管理。</p>\n<h4>3、采购系统</h4>\n<p>电商中的商品一般来说主要由供应商提供，我们常见的采销系统或进销存系统或供应链系统等都和商品及库存紧密相关。</p>\n<p>某些特殊电商场景除了商品，还要考虑辅料、原料（物料）等，商品管理系统的设计直接关系到采销业务系统的复杂度。</p>\n<h4>4、门店系统</h4>\n<p>门店系统主要经营企业线下业务，门店系统的经营活动也离不开商品管理系统。</p>\n<h4>5、财务系统</h4>\n<p>财务系统是电商系统中最复杂的复合型公共服务型系统，财务单据经常和商品管理有千丝万缕的联系。</p>\n<p>十多年前在帝都某电商公司做财务开发，竟然要自己写SQL访问商品表的积分字段，写windows服务计算和统计用户积分，这么普通而自信的业务逻辑放在今天你敢信？这些其实都是要规避的不合理设计。</p>\n<h4>6、票券系统</h4>\n<p>票券系统是电商中常见的营销系统，针对商品分类、SPU甚至SKU的票券设计很常见。</p>\n<h4>7、广告系统</h4>\n<p>广告系统也是电商中常见的营销系统，针对商品的广告宣传层出不穷。</p>\n<h4>8、推荐系统</h4>\n<p>电商里的推荐系统不会孤立存在，往往和商品、CRM、订单等系统配合完成业务需求。</p>\n<h4>9、CRM</h4>\n<p>主要包括针对个人用户或会员的商品偏好收集和购买统计、积分赠送等等</p>\n<h4>10、其他系统</h4>\n<p>其他如活动等电商业务系统也和商品管理有些联系。</p>\n<h3>十二、其他</h3>\n<p>个人参与设计与开发的商品系统还涉及到以下功能：</p>\n<h4>1、商品详情</h4>\n<p>一个好的商品详情页，可以有效的提升单品的转化率，对于不同终端（比如PC、APP、H5等）的商品详情页设计侧重点也会有很多不同。</p>\n<p>商品详情页的接口设计也非常考验开发人员的编程经验，是采用大而全接口还是小而美接口，这需要开发人员根据实际情况做出合适的选择。</p>\n<h4>2、多语言</h4>\n<p>商品的多语言设计和实现也很普遍，对数据表的设计有更多更高要求，虽然多语言的工作绝大多数在我看来都是体力活。</p>\n<h4>3、组合商品</h4>\n<p>为了促进销售，很多商家在售卖时会利用“捆绑销售”的策略，这样就自然而然发明出了组合商品：人为将几个单独售卖的商品组合在一起进行合并售卖的商品。</p>\n<p>SKU(组合)=m*SKU1+n*SKU2+...p*SKUx</p>\n<p>组合商品的设计可能会对商品库存管理和订单拆单逻辑造成直接的负面影响，曾经在某电商公司做过一段时间开发，没少被组合商品搞得晕头转向，尤其是某些单据的业务逻辑那是相当炸裂。</p>\n<h4>4、商品数据同步</h4>\n<p>不同系统对商品主数据的要求是不一样的，有些业务系统仅仅提供商品接口即可满足业务需求，比如订单系统。</p>\n<p>但一些后台业务系统（如WMS、MES等），往往牵涉到商品的复杂SQL查询，商品数据同步至对应业务系统也是必要的，PowerDotNet数据同步平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/datax-task-scheduler-and-data-synchronization-design-and-implement.html\" target=\"_blank\">Power.DataX</a>可轻松解决数据同步问题。</p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\">\n    <div id=\"AllanboltSignature\">\n<p id=\"PSignature\"><br />\n作者：<a href=\"http://www.cnblogs.com/jeffwongishandsome/\" target=\"_blank\" title=\"据说点击推荐或者关注博主是一个程序员的优良品质，留言也是\">Jeff Wong</a> <br />\n出处：<a href=\"http://jeffwongishandsome.cnblogs.com/\" target=\"_blank\" title=\"关注要趁早啊，留言也可以啊，至少二选一吧！\">http://jeffwongishandsome.cnblogs.com/</a> <br />\n本文版权归作者和博客园共有，欢迎围观转载。转载时请您务必在文章明显位置给出原文链接，谢谢您的合作。 <br />\n</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2025-12-31 12:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jeffwongishandsome\">JeffWong</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "CodeSpirit 多语言国际化使用指南（Beta）",
      "link": "https://www.cnblogs.com/codelove/p/19417730",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/codelove/p/19417730\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 09:12\">\n    <span>CodeSpirit 多语言国际化使用指南（Beta）</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"-概述\">📋 概述</h2>\n<p>CodeSpirit 框架现已支持完整的前后端多语言国际化功能，提供中英文双语支持，基于 .NET 资源文件和 AMIS locale，通过 Settings 组件实现全局、租户、用户三级语言配置。</p>\n<p><strong>版本</strong>: v1.0.0<br />\n<strong>支持语言</strong>: 简体中文（zh-CN）、英文（en）<br />\n<strong>更新日期</strong>: 2025年12月28日</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251229184550117-1365827054.png\" /></p>\n<ul>\n<li>Github：xin-lai/CodeSpirit</li>\n<li>Gitee：magicodes/CodeSpirit</li>\n</ul>\n<h2 id=\"-核心特性\">🎯 核心特性</h2>\n<ul>\n<li>✅ <strong>双语支持</strong>：中文（默认）+ 英文</li>\n<li>✅ <strong>全栈覆盖</strong>：后端 API + 前端 UI</li>\n<li>✅ <strong>多级配置</strong>：系统默认 → 租户默认 → 用户偏好</li>\n<li>✅ <strong>类型安全</strong>：使用 .resx 资源文件，编译时强类型访问</li>\n<li>✅ <strong>动态切换</strong>：用户可实时切换语言，无需重新登录</li>\n<li>✅ <strong>AMIS 兼容</strong>：集成 AMIS 的 locale 机制</li>\n<li>✅ <strong>DataAnnotations 支持</strong>：验证特性自动本地化</li>\n<li>✅ <strong>DTO描述多语言</strong>：支持字段描述信息的多语言</li>\n<li>✅ <strong>零侵入</strong>：无需修改业务表结构，基于 Settings 组件</li>\n</ul>\n<h2 id=\"️-架构设计\">🏗️ 架构设计</h2>\n<h3 id=\"语言解析优先级\">语言解析优先级</h3>\n<pre><code>Cookie（用户手动切换）\n    ↓ (未设置)\nUser Settings（用户偏好）\n    ↓ (未设置)\nTenant Settings（租户默认）\n    ↓ (未设置)\nGlobal Settings（系统默认）\n    ↓ (未设置)\nzh-CN（最终回退）\n</code></pre>\n<h3 id=\"settings-存储结构\">Settings 存储结构</h3>\n<pre><code class=\"language-csharp\">// 全局默认语言\nModule: \"Localization\"\nKey: \"DefaultLanguage\"\nValue: \"zh-CN\"\nScope: Global\n\n// 租户默认语言\nModule: \"Localization\"\nKey: \"DefaultLanguage\"\nValue: \"en\"\nScope: Tenant\nScopeId: \"{tenantId}\"\n\n// 用户偏好语言\nModule: \"Localization\"\nKey: \"PreferredLanguage\"\nValue: \"en\"\nScope: User\nScopeId: \"{userId}\"\n</code></pre>\n<h2 id=\"-快速开始\">🚀 快速开始</h2>\n<h3 id=\"1-配置已完成\">1. 配置已完成</h3>\n<p>本地化服务已在 <code>ServiceDefaults</code> 中自动注册，无需额外配置。</p>\n<h3 id=\"2-后端使用\">2. 后端使用</h3>\n<h4 id=\"在-controller-中使用本地化\">在 Controller 中使用本地化</h4>\n<pre><code class=\"language-csharp\">using CodeSpirit.Localization.Resources;\nusing Microsoft.Extensions.Localization;\n\npublic class MyController : ApiControllerBase\n{\n    private readonly IStringLocalizer&lt;SharedResources&gt; _localizer;\n    \n    public MyController(IStringLocalizer&lt;SharedResources&gt; localizer)\n    {\n        _localizer = localizer;\n    }\n    \n    [HttpPost]\n    public IActionResult Create()\n    {\n        return Ok(new ApiResponse \n        { \n            Status = 1, \n            Msg = _localizer[\"Common.Save\"].Value \n        });\n    }\n}\n</code></pre>\n<h4 id=\"抛出本地化异常\">抛出本地化异常</h4>\n<pre><code class=\"language-csharp\">// 使用资源键\nthrow new BusinessException(\"Errors.InvalidStartTime\");\n\n// 带参数\nthrow new ValidationException(\"Errors.NotFound\", resourceId);\n</code></pre>\n<h3 id=\"3-dto-验证特性多语言\">3. DTO 验证特性多语言</h3>\n<pre><code class=\"language-csharp\">using CodeSpirit.Localization.Resources;\n\npublic class CreateQuestionDto\n{\n    [Display(Name = \"Content\", ResourceType = typeof(DisplayResources))]\n    [Required(ErrorMessageResourceType = typeof(ValidationResources), \n             ErrorMessageResourceName = \"Required\")]\n    [StringLength(2000, \n        ErrorMessageResourceType = typeof(ValidationResources),\n        ErrorMessageResourceName = \"StringLengthMax\")]\n    public string Content { get; set; } = string.Empty;\n}\n</code></pre>\n<p><strong>验证错误示例</strong>：</p>\n<p>中文环境：<code>题目内容不能为空</code><br />\n英文环境：<code>Content is required</code></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251229184639734-1657824800.png\" /></p>\n<h3 id=\"4-dto-描述信息多语言\">4. DTO 描述信息多语言</h3>\n<p>DTO 字段的描述信息（Description）也支持多语言，通过 <code>LocalizedDescriptionAttribute</code> 实现。</p>\n<h4 id=\"41-创建服务资源文件\">4.1 创建服务资源文件</h4>\n<p>各服务应创建自己的资源文件，保持服务独立性：</p>\n<p><strong>资源文件结构</strong>：</p>\n<pre><code>CodeSpirit.ExamApi/Resources/\n  ├── ExamDisplayResources.cs    # 资源占位类（包含ResourceManager）\n  ├── ExamDisplay.resx           # 中文资源\n  └── ExamDisplay.en.resx        # 英文资源\n</code></pre>\n<p><strong>资源键命名规范</strong>：</p>\n<ul>\n<li>DTO字段描述：<code>Description.{EntityName}.{PropertyName}</code></li>\n<li>示例：<code>Description.Question.Options</code>、<code>Description.Question.CorrectAnswer</code></li>\n</ul>\n<h4 id=\"42-在dto中使用\">4.2 在DTO中使用</h4>\n<pre><code class=\"language-csharp\">using CodeSpirit.Core.Attributes;\nusing CodeSpirit.ExamApi.Resources;\n\npublic class CreateQuestionDto\n{\n    [LocalizedDescription(\n        \"根据题目内容生成合适的选项\",  // 回退文本（可选）\n        ResourceKey = \"Description.Question.Options\",\n        ResourceType = typeof(ExamDisplayResources)\n    )]\n    public List&lt;string&gt; Options { get; set; }\n}\n</code></pre>\n<p><strong>使用方式</strong>：</p>\n<ul>\n<li><strong>方式1</strong>：仅使用资源键（推荐）</li>\n<li><strong>方式2</strong>：带回退文本（更安全，资源不可用时显示回退文本）</li>\n<li><strong>方式3</strong>：使用共享资源（仅适用于通用描述）</li>\n</ul>\n<h4 id=\"43-向后兼容\">4.3 向后兼容</h4>\n<p>现有的 <code>DescriptionAttribute</code> 仍然可以正常使用，系统会优先检查 <code>LocalizedDescriptionAttribute</code>，如果不存在则回退到 <code>DescriptionAttribute</code>。</p>\n<h4 id=\"44-资源文件组织原则\">4.4 资源文件组织原则</h4>\n<ul>\n<li><strong>共享资源</strong>：<code>CodeSpirit.Localization/Resources/</code> - 存放真正通用的、跨服务的资源</li>\n<li><strong>服务资源</strong>：<code>ApiServices/{ServiceName}/Resources/</code> - 存放服务特有的业务资源</li>\n</ul>\n<p><strong>最佳实践</strong>：</p>\n<ul>\n<li>各服务管理自己的资源文件，避免在共享资源中放置服务特定内容</li>\n<li>遵循 <code>Description.{EntityName}.{PropertyName}</code> 命名约定</li>\n<li>建议提供回退文本，确保资源不可用时仍能显示</li>\n</ul>\n<h4 id=\"45-技术实现\">4.5 技术实现</h4>\n<p>描述多语言的资源解析由 AMIS 表单生成时统一处理：</p>\n<ul>\n<li><strong>CultureResolver</strong>：从 HttpContext Features、Cookie 等多个来源获取当前语言</li>\n<li><strong>统一解析</strong>：<code>GetLocalizedDescription</code> 方法在表单生成时解析资源</li>\n<li><strong>回退机制</strong>：英文环境下确保正确加载英文资源，避免回退到中文</li>\n<li><strong>缓存优化</strong>：在同一请求中复用已解析的文化信息</li>\n</ul>\n<h3 id=\"5-前端使用\">5. 前端使用</h3>\n<h4 id=\"javascript\">JavaScript</h4>\n<pre><code class=\"language-javascript\">// 获取翻译文本\nconst message = CodeSpirit.i18n.t('Common.Save');\n\n// 带参数\nconst message = CodeSpirit.i18n.t('Validation.Required', { 0: '用户名' });\n\n// 切换语言\nCodeSpirit.i18n.switchLanguage('en');\n</code></pre>\n<h4 id=\"razor-页面\">Razor 页面</h4>\n<pre><code class=\"language-razor\">@using CodeSpirit.Localization.Resources\n@using Microsoft.Extensions.Localization\n@inject IStringLocalizer&lt;SharedResources&gt; Localizer\n\n&lt;h1&gt;@Localizer[\"Common.Save\"]&lt;/h1&gt;\n</code></pre>\n<h2 id=\"️-语言配置管理\">🎛️ 语言配置管理</h2>\n<h3 id=\"通过-api-设置语言\">通过 API 设置语言</h3>\n<p>系统已自动集成 Settings 组件，可以通过 Settings API 管理语言配置：</p>\n<h4 id=\"设置用户语言偏好\">设置用户语言偏好</h4>\n<pre><code class=\"language-csharp\">await _settingsService.SetUserSettingAsync(\n    module: \"Localization\",\n    key: \"PreferredLanguage\",\n    value: \"en\",\n    userId: currentUserId\n);\n</code></pre>\n<h4 id=\"设置租户默认语言\">设置租户默认语言</h4>\n<pre><code class=\"language-csharp\">await _settingsService.SetTenantSettingAsync(\n    module: \"Localization\",\n    key: \"DefaultLanguage\",\n    value: \"en\",\n    tenantId: currentTenantId\n);\n</code></pre>\n<h4 id=\"设置全局默认语言\">设置全局默认语言</h4>\n<pre><code class=\"language-csharp\">await _settingsService.SetGlobalSettingAsync(\n    module: \"Localization\",\n    key: \"DefaultLanguage\",\n    value: \"en\"\n);\n</code></pre>\n<h3 id=\"通过-ui-切换语言\">通过 UI 切换语言</h3>\n<p>用户可以在导航栏的语言切换器中选择语言，切换后会：</p>\n<ol>\n<li>设置 Cookie（<code>.AspNetCore.Culture</code>）</li>\n<li>刷新页面</li>\n<li>所有界面文本、错误消息自动切换为对应语言</li>\n</ol>\n<h2 id=\"-资源文件说明\">📚 资源文件说明</h2>\n<h3 id=\"共享资源localization组件\">共享资源（Localization组件）</h3>\n<table>\n<thead>\n<tr>\n<th>资源文件</th>\n<th>用途</th>\n<th>示例键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Shared.resx</code></td>\n<td>通用 UI 文本</td>\n<td><code>Common.Save</code>, <code>Common.Cancel</code></td>\n</tr>\n<tr>\n<td><code>Errors.resx</code></td>\n<td>错误消息</td>\n<td><code>Errors.NotFound</code>, <code>Errors.Unauthorized</code></td>\n</tr>\n<tr>\n<td><code>Validation.resx</code></td>\n<td>验证消息模板</td>\n<td><code>Required</code>, <code>StringLengthMax</code></td>\n</tr>\n<tr>\n<td><code>Display.resx</code></td>\n<td>字段显示名称</td>\n<td><code>Content</code>, <code>Type</code>, <code>Difficulty</code></td>\n</tr>\n</tbody>\n</table>\n<p>每个资源文件都有对应的英文版本（如 <code>Shared.en.resx</code>）。</p>\n<h3 id=\"服务特定资源各api服务\">服务特定资源（各API服务）</h3>\n<p>各服务应创建自己的资源文件，保持服务独立性：</p>\n<p><strong>命名规范</strong>：</p>\n<ul>\n<li>占位类：<code>{ServiceName}DisplayResources.cs</code></li>\n<li>资源文件：<code>{ServiceName}Display.resx</code>、<code>{ServiceName}Display.en.resx</code></li>\n</ul>\n<p><strong>示例</strong>：</p>\n<pre><code>CodeSpirit.ExamApi/Resources/\n  ├── ExamDisplayResources.cs    # 资源占位类（包含ResourceManager）\n  ├── ExamDisplay.resx           # 中文资源\n  └── ExamDisplay.en.resx        # 英文资源\n\nCodeSpirit.SurveyApi/Resources/\n  ├── SurveyDisplayResources.cs\n  ├── SurveyDisplay.resx\n  └── SurveyDisplay.en.resx\n</code></pre>\n<p><strong>资源键命名约定</strong>：</p>\n<ul>\n<li>DTO字段描述：<code>Description.{EntityName}.{PropertyName}</code></li>\n<li>示例：<code>Description.Question.Options</code>、<code>Description.Survey.Title</code></li>\n</ul>\n<h2 id=\"-常见场景\">🔧 常见场景</h2>\n<h3 id=\"场景-1用户切换语言\">场景 1：用户切换语言</h3>\n<ol>\n<li>\n<p>用户在导航栏选择 \"English\"</p>\n</li>\n<li>\n<p>JavaScript 调用 <code>CodeSpirit.i18n.switchLanguage('en')</code></p>\n</li>\n<li>\n<p>设置 Cookie 并刷新页面</p>\n</li>\n<li>\n<p>所有内容显示为英文</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251229184704171-1071541876.png\" /></p>\n</li>\n</ol>\n<h3 id=\"场景-2租户设置默认语言\">场景 2：租户设置默认语言</h3>\n<ol>\n<li>租户管理员在设置中选择默认语言为英文</li>\n<li>系统通过 Settings API 保存配置</li>\n<li>该租户下的所有用户默认使用英文</li>\n<li>用户仍可以设置自己的语言偏好</li>\n</ol>\n<h3 id=\"场景-3api-返回本地化错误\">场景 3：API 返回本地化错误</h3>\n<pre><code class=\"language-csharp\">// 中文环境\nthrow new BusinessException(\"Errors.NotFound\");\n// API 返回: { \"status\": 0, \"msg\": \"未找到资源\" }\n\n// 英文环境  \nthrow new BusinessException(\"Errors.NotFound\");\n// API 返回: { \"status\": 0, \"msg\": \"Resource not found\" }\n</code></pre>\n<h2 id=\"-amis-多语言\">🌐 AMIS 多语言</h2>\n<p>AMIS 组件会自动根据当前语言加载对应的 locale 文件：</p>\n<ul>\n<li><strong>中文环境</strong>：使用默认的 zh-CN locale</li>\n<li><strong>英文环境</strong>：动态加载 <code>sdk/6.13.0/locale/en-US.js</code></li>\n</ul>\n<p>AMIS 内置组件（日期选择器、分页器等）会自动显示对应语言。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251229184723949-1878507554.png\" /></p>\n<h2 id=\"-导航组件多语言\">🧭 导航组件多语言</h2>\n<p>导航组件（<code>CodeSpirit.Navigation</code>）提供了完整的多语言支持，用于实现动态导航菜单的多语言切换。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251229184735542-1462849359.png\" /></p>\n<h3 id=\"导航资源文件\">导航资源文件</h3>\n<p>导航组件使用专用的资源文件：</p>\n<p><strong>资源文件位置</strong>：</p>\n<pre><code>CodeSpirit.Navigation/Resources/\n  ├── NavigationResources.cs         # 资源占位类\n  ├── NavigationResources.resx       # 中文资源\n  └── NavigationResources.en.resx    # 英文资源\n</code></pre>\n<p><strong>资源键命名规范</strong>：</p>\n<ul>\n<li>模块名称：<code>Module.{ModuleName}</code>（如 <code>Module.Identity</code>、<code>Module.Survey</code>）</li>\n<li>控制器名称：<code>Controller.{ControllerName}</code>（如 <code>Controller.Users</code>、<code>Controller.Roles</code>）</li>\n</ul>\n<h3 id=\"在控制器中使用\">在控制器中使用</h3>\n<p>导航组件支持两种特性来配置多语言：<code>Module</code> 特性和 <code>NavigationAttribute</code> 特性。</p>\n<h4 id=\"使用-module-特性推荐\">使用 Module 特性（推荐）</h4>\n<p><code>Module</code> 特性用于定义模块级别的多语言配置，通常放在 <code>ApiControllerBase</code> 上：</p>\n<pre><code class=\"language-csharp\">using CodeSpirit.Core.Attributes;\nusing CodeSpirit.Core.Enums;\nusing CodeSpirit.Navigation.Resources;\n\n// 模块级配置（在 ApiControllerBase 上）\n[Module(\"identity\", \n    displayName: \"用户中心\",  // 回退文本\n    DisplayNameResourceKey = \"Module.Identity\",           // 资源键\n    DisplayNameResourceType = typeof(NavigationResources), // 资源类型\n    Icon = \"fa-solid fa-user-group\")]\n[Navigation(\n    Icon = \"fa-solid fa-user-group\", \n    PlatformType = PlatformType.Both,\n    TitleResourceKey = \"Module.Identity\",           // 与 Module 的资源键保持一致\n    TitleResourceType = typeof(NavigationResources)\n)]\npublic abstract class ApiControllerBase : CodeSpirit.Shared.Controllers.ApiControllerBase\n{\n}\n</code></pre>\n<h4 id=\"使用-navigationattribute-特性\">使用 NavigationAttribute 特性</h4>\n<p><code>NavigationAttribute</code> 用于控制器级别的多语言配置：</p>\n<pre><code class=\"language-csharp\">using CodeSpirit.Core.Attributes;\nusing CodeSpirit.Navigation.Resources;\nusing System.ComponentModel;\n\n// 控制器级配置\n[DisplayName(\"用户管理\")]\n[Navigation(\n    Icon = \"fa-solid fa-users\", \n    PlatformType = PlatformType.Tenant,\n    TitleResourceKey = \"Controller.Users\",\n    TitleResourceType = typeof(NavigationResources)\n)]\npublic class UsersController : ApiControllerBase\n{\n}\n</code></pre>\n<h3 id=\"配置要点\">配置要点</h3>\n<p><strong>Module 特性</strong>：</p>\n<ol>\n<li><strong>DisplayNameResourceKey</strong>：指定模块名称的资源键（必填）</li>\n<li><strong>DisplayNameResourceType</strong>：指定资源类型，通常为 <code>typeof(NavigationResources)</code>（必填）</li>\n<li><strong>displayName</strong>：回退文本，当资源不可用时显示（必填，建议提供）</li>\n</ol>\n<p><strong>NavigationAttribute 特性</strong>：</p>\n<ol>\n<li><strong>TitleResourceKey</strong>：指定资源键名称（推荐填写，与 Module 的 DisplayNameResourceKey 保持一致）</li>\n<li><strong>TitleResourceType</strong>：指定资源类型，通常为 <code>typeof(NavigationResources)</code>（推荐填写）</li>\n<li><strong>Title</strong>：回退文本，当资源不可用时显示（可选，建议提供）</li>\n</ol>\n<blockquote>\n<p><strong>最佳实践</strong>：在模块级配置中，建议在 <code>Navigation</code> 特性中也设置 <code>TitleResourceKey</code> 和 <code>TitleResourceType</code>，与 <code>Module</code> 特性的资源键保持一致，确保导航多语言功能完整可靠。</p>\n</blockquote>\n<h3 id=\"工作原理\">工作原理</h3>\n<ol>\n<li><strong>自动扫描</strong>：系统启动时，导航组件自动扫描所有控制器的 <code>NavigationAttribute</code></li>\n<li><strong>资源解析</strong>：根据当前语言（<code>CultureInfo.CurrentUICulture</code>）解析对应的资源文本</li>\n<li><strong>缓存机制</strong>：解析后的导航树缓存到分布式缓存（Redis），提升性能</li>\n<li><strong>动态切换</strong>：用户切换语言后，导航菜单会自动显示对应语言</li>\n</ol>\n<h3 id=\"️-重要注意事项\">⚠️ 重要注意事项</h3>\n<h4 id=\"1-缓存问题\">1. 缓存问题</h4>\n<p>导航组件使用分布式缓存来提升性能，但在以下情况下可能导致多语言不生效：</p>\n<p><strong>症状</strong>：切换语言后，导航菜单仍显示旧语言</p>\n<p><strong>原因</strong>：导航树已缓存，未重新解析多语言资源</p>\n<p><strong>解决方案</strong>：清空导航缓存</p>\n<h5 id=\"方法1通过缓存管理界面\">方法1：通过缓存管理界面</h5>\n<ol>\n<li>访问系统平台的<strong>缓存管理</strong>页面（路由：<code>/cacheManagement</code>）</li>\n<li>在缓存列表中搜索或找到导航缓存键：<code>CodeSpirit:Navigation:All</code></li>\n<li>点击该缓存项的\"删除\"按钮清空缓存</li>\n</ol>\n<blockquote>\n<p><strong>注意</strong>：缓存管理功能仅系统管理员可访问，属于系统平台功能。</p>\n</blockquote>\n<h5 id=\"方法2通过代码-api-调用\">方法2：通过代码 API 调用</h5>\n<pre><code class=\"language-csharp\">// 清空所有导航缓存\nawait _navigationService.ClearAllNavigationCacheAsync();\n\n// 清空特定模块缓存（实际上也会清空整个缓存）\nawait _navigationService.ClearModuleNavigationCacheAsync(\"Identity\");\n\n// 重新初始化导航树（清空并重建缓存）\nawait _navigationService.InitializeNavigationTree();\n</code></pre>\n<h5 id=\"方法3通过-http-api-调用\">方法3：通过 HTTP API 调用</h5>\n<pre><code class=\"language-bash\"># 清空所有导航缓存\nDELETE /api/navigation/cache\n\n# 清空特定模块缓存\nDELETE /api/navigation/cache?moduleName=Identity\n\n# 重新初始化导航树（清空并重建缓存）\nPOST /api/navigation/initialize\n</code></pre>\n<h4 id=\"2-资源文件编译\">2. 资源文件编译</h4>\n<p>确保资源文件正确配置为嵌入式资源：</p>\n<pre><code class=\"language-xml\">&lt;ItemGroup&gt;\n  &lt;EmbeddedResource Include=\"Resources\\NavigationResources.resx\"&gt;\n    &lt;Generator&gt;PublicResXFileCodeGenerator&lt;/Generator&gt;\n  &lt;/EmbeddedResource&gt;\n  &lt;EmbeddedResource Include=\"Resources\\NavigationResources.en.resx\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre>\n<h4 id=\"3-开发建议\">3. 开发建议</h4>\n<ul>\n<li><strong>模块配置</strong>：推荐同时使用 <code>Module</code> 和 <code>Navigation</code> 特性配置模块级多语言</li>\n<li><strong>回退文本</strong>：始终提供回退文本（<code>displayName</code>、<code>Title</code>），确保资源不可用时仍能显示</li>\n<li><strong>添加新导航项</strong>：添加后需清空缓存，确保新项生效</li>\n<li><strong>修改资源文本</strong>：修改后需重新编译项目，并清空缓存</li>\n<li><strong>测试多语言</strong>：切换语言后若不生效，优先检查缓存</li>\n<li><strong>资源键一致性</strong>：<code>Module</code> 的 <code>DisplayNameResourceKey</code> 和 <code>Navigation</code> 的 <code>TitleResourceKey</code> 通常使用相同的资源键</li>\n</ul>\n<h3 id=\"完整示例\">完整示例</h3>\n<p>以下是用户中心模块的完整多语言配置示例（来自实际代码）：</p>\n<pre><code class=\"language-csharp\">using CodeSpirit.Core;\nusing CodeSpirit.Core.Attributes;\nusing CodeSpirit.Core.Enums;\nusing CodeSpirit.Navigation.Resources;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.ComponentModel;\n\nnamespace CodeSpirit.IdentityApi.Controllers\n{\n    /// &lt;summary&gt;\n    /// 身份认证API控制器基类\n    /// &lt;/summary&gt;\n    [ApiController]\n    [Authorize(policy: \"DynamicPermissions\")]\n    [Route(\"api/identity/[controller]\")]\n    // 模块级配置（使用 Module 和 Navigation 特性）\n    [Module(\"identity\", \n        displayName: \"用户中心\",  // 回退文本\n        DisplayNameResourceKey = \"Module.Identity\",           // 资源键\n        DisplayNameResourceType = typeof(NavigationResources), // 资源类型\n        Icon = \"fa-solid fa-user-group\")]\n    [Navigation(\n        Icon = \"fa-solid fa-user-group\",\n        PlatformType = PlatformType.Both,\n        TitleResourceKey = \"Module.Identity\",\n        TitleResourceType = typeof(NavigationResources)\n    )]\n    public abstract class ApiControllerBase : CodeSpirit.Shared.Controllers.ApiControllerBase\n    {\n    }\n\n    /// &lt;summary&gt;\n    /// 用户管理控制器\n    /// &lt;/summary&gt;\n    [DisplayName(\"用户管理\")]\n    [Navigation(\n        Icon = \"fa-solid fa-users\", \n        PlatformType = PlatformType.Tenant,\n        TitleResourceKey = \"Controller.Users\",\n        TitleResourceType = typeof(NavigationResources)\n    )]\n    public class UsersController : ApiControllerBase\n    {\n        private readonly IUserService _userService;\n\n        public UsersController(IUserService userService)\n        {\n            _userService = userService;\n        }\n\n        /// &lt;summary&gt;\n        /// 获取用户列表\n        /// &lt;/summary&gt;\n        [HttpGet]\n        [DisplayName(\"获取用户列表\")]\n        public async Task&lt;ActionResult&lt;ApiResponse&lt;PageList&lt;UserDto&gt;&gt;&gt;&gt; GetUsers([FromQuery] UserQueryDto queryDto)\n        {\n            PageList&lt;UserDto&gt; users = await _userService.GetUsersAsync(queryDto);\n            return SuccessResponse(users);\n        }\n    }\n}\n</code></pre>\n<p><strong>资源文件内容</strong>：</p>\n<pre><code class=\"language-xml\">&lt;!-- NavigationResources.resx (中文) --&gt;\n&lt;data name=\"Module.Identity\"&gt;\n  &lt;value&gt;用户中心&lt;/value&gt;\n&lt;/data&gt;\n&lt;data name=\"Controller.Users\"&gt;\n  &lt;value&gt;用户管理&lt;/value&gt;\n&lt;/data&gt;\n\n&lt;!-- NavigationResources.en.resx (英文) --&gt;\n&lt;data name=\"Module.Identity\"&gt;\n  &lt;value&gt;User Center&lt;/value&gt;\n&lt;/data&gt;\n&lt;data name=\"Controller.Users\"&gt;\n  &lt;value&gt;User Management&lt;/value&gt;\n&lt;/data&gt;\n</code></pre>\n<h3 id=\"缓存键说明\">缓存键说明</h3>\n<p>导航组件使用以下缓存键：</p>\n<ul>\n<li><strong>缓存键</strong>：<code>CodeSpirit:Navigation:All</code></li>\n<li><strong>缓存策略</strong>：单一缓存 + 内存过滤</li>\n<li><strong>缓存时间</strong>：绝对过期 365 天，滑动过期 90 天</li>\n<li><strong>清空时机</strong>：\n<ul>\n<li>添加/修改导航项后</li>\n<li>修改资源文件后</li>\n<li>切换语言不生效时</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"-扩展支持\">📊 扩展支持</h2>\n<h3 id=\"添加新语言如日文\">添加新语言（如日文）</h3>\n<ol>\n<li><strong>更新配置</strong>：在 <code>appsettings.json</code> 中添加</li>\n</ol>\n<pre><code class=\"language-json\">{\n  \"Localization\": {\n    \"SupportedCultures\": [\n      { \"Code\": \"zh-CN\", \"DisplayName\": \"简体中文\" },\n      { \"Code\": \"en\", \"DisplayName\": \"English\" },\n      { \"Code\": \"ja\", \"DisplayName\": \"日本語\" }\n    ]\n  }\n}\n</code></pre>\n<ol start=\"2\">\n<li>\n<p><strong>添加资源文件</strong>：</p>\n<ul>\n<li><code>Shared.ja.resx</code></li>\n<li><code>Errors.ja.resx</code></li>\n<li><code>Validation.ja.resx</code></li>\n<li><code>Display.ja.resx</code></li>\n</ul>\n</li>\n<li>\n<p><strong>下载 AMIS locale</strong>：将 <code>ja-JP.js</code> 放到 <code>wwwroot/sdk/6.13.0/locale/</code></p>\n</li>\n<li>\n<p><strong>更新语言切换器</strong>：在 <code>MainNav.razor</code> 中添加日语选项</p>\n</li>\n</ol>\n<h2 id=\"️-配置说明\">⚙️ 配置说明</h2>\n<h3 id=\"appsettingsjson-配置\">appsettings.json 配置</h3>\n<pre><code class=\"language-json\">{\n  \"Localization\": {\n    \"DefaultCulture\": \"zh-CN\",\n    \"SupportedCultures\": [\n      { \"Code\": \"zh-CN\", \"DisplayName\": \"简体中文\" },\n      { \"Code\": \"en\", \"DisplayName\": \"English\" }\n    ],\n    \"EnableTenantLevelLanguage\": true,\n    \"EnableUserLevelLanguage\": true,\n    \"FallbackToParentCultures\": true,\n    \"SettingsModule\": \"Localization\",\n    \"SettingsKeys\": {\n      \"GlobalDefault\": \"DefaultLanguage\",\n      \"TenantDefault\": \"DefaultLanguage\",\n      \"UserPreference\": \"PreferredLanguage\"\n    }\n  }\n}\n</code></pre>\n<h2 id=\"-ui-组件\">🎨 UI 组件</h2>\n<h3 id=\"语言切换器\">语言切换器</h3>\n<p>位置：<code>Src/CodeSpirit.Web/Components/Shared/MainNav.razor</code></p>\n<p>用户点击下拉框选择语言，系统会：</p>\n<ol>\n<li>设置 Cookie</li>\n<li>刷新页面</li>\n<li>应用新语言到所有界面元素</li>\n</ol>\n<h2 id=\"-最佳实践\">📖 最佳实践</h2>\n<h3 id=\"1-资源键命名规范\">1. 资源键命名规范</h3>\n<ul>\n<li>使用点号分隔类别：<code>Errors.NotFound</code>, <code>Common.Save</code></li>\n<li>使用 PascalCase：<code>StringLengthMax</code>, <code>ValidationError</code></li>\n<li>避免重复前缀：✅ <code>Errors.NotFound</code> ❌ <code>Errors.ErrorsNotFound</code></li>\n</ul>\n<h3 id=\"2-参数化消息\">2. 参数化消息</h3>\n<pre><code class=\"language-csharp\">// 资源文件\n&lt;data name=\"UserCreated\"&gt;&lt;value&gt;用户 {0} 创建成功&lt;/value&gt;&lt;/data&gt;\n\n// 使用\n_localizer[\"UserCreated\", username]\n</code></pre>\n<h3 id=\"3-向后兼容\">3. 向后兼容</h3>\n<p>现有硬编码中文的代码继续正常工作：</p>\n<pre><code class=\"language-csharp\">// 旧代码（继续工作）\nthrow new BusinessException(\"未找到资源\");\n\n// 新代码（支持多语言）\nthrow new BusinessException(\"Errors.NotFound\");\n</code></pre>\n<h2 id=\"-故障排查\">🔍 故障排查</h2>\n<h3 id=\"资源键未找到\">资源键未找到</h3>\n<p>如果资源键不存在，系统会返回键名本身，不会抛出异常。</p>\n<h3 id=\"语言未生效\">语言未生效</h3>\n<ol>\n<li>检查 Settings 配置是否正确</li>\n<li>确认 Cookie 是否设置成功</li>\n<li>查看日志中的语言解析过程</li>\n</ol>\n<h3 id=\"资源文件未生成\">资源文件未生成</h3>\n<p>确保项目文件中配置了资源文件生成器：</p>\n<pre><code class=\"language-xml\">&lt;EmbeddedResource Update=\"Resources\\Shared.resx\"&gt;\n    &lt;Generator&gt;PublicResXFileCodeGenerator&lt;/Generator&gt;\n&lt;/EmbeddedResource&gt;\n</code></pre>\n<h2 id=\"-相关文档\">📘 相关文档</h2>\n<ul>\n<li><a href=\"https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/localization\" rel=\"noopener nofollow\" target=\"_blank\">ASP.NET Core 全球化和本地化</a></li>\n<li><a href=\"https://aisuda.bce.baidu.com/amis/zh-CN/docs/extend/i18n\" rel=\"noopener nofollow\" target=\"_blank\">AMIS 国际化文档</a></li>\n<li><a href=\"../Components/CodeSpirit.Settings/README.md\" rel=\"noopener nofollow\" target=\"_blank\">CodeSpirit Settings 组件</a></li>\n</ul>\n<h2 id=\"-faq\">💡 FAQ</h2>\n<h3 id=\"q-如何为某个用户永久设置语言\">Q: 如何为某个用户永久设置语言？</h3>\n<p>A: 通过 Settings API 设置用户级配置，系统会自动持久化到数据库。</p>\n<h3 id=\"q-amis-组件的多语言如何工作\">Q: AMIS 组件的多语言如何工作？</h3>\n<p>A: 系统会根据当前语言自动加载对应的 AMIS locale 文件（如 <code>en-US.js</code>），AMIS 内置组件会自动显示对应语言。</p>\n<h3 id=\"q-可以为不同租户设置不同的默认语言吗\">Q: 可以为不同租户设置不同的默认语言吗？</h3>\n<p>A: 可以。通过 Settings API 为每个租户设置 <code>Localization.DefaultLanguage</code>，该租户下的所有用户默认使用该语言（用户仍可自定义）。</p>\n<h3 id=\"q-如何添加更多语言\">Q: 如何添加更多语言？</h3>\n<p>A:</p>\n<ol>\n<li>在 <code>appsettings.json</code> 添加语言配置</li>\n<li>创建对应的资源文件（如 <code>Shared.ja.resx</code>）</li>\n<li>下载 AMIS locale 文件</li>\n<li>在语言切换器添加选项</li>\n</ol>\n<p>无需修改任何代码逻辑。</p>\n<h2 id=\"-dto描述多语言常见问题\">📝 DTO描述多语言常见问题</h2>\n<h3 id=\"q-如何为dto字段添加多语言描述\">Q: 如何为DTO字段添加多语言描述？</h3>\n<p>A: 使用 <code>LocalizedDescriptionAttribute</code>，指定 <code>ResourceKey</code> 和 <code>ResourceType</code>：</p>\n<pre><code class=\"language-csharp\">[LocalizedDescription(\n    ResourceKey = \"Description.Question.Options\",\n    ResourceType = typeof(ExamDisplayResources)\n)]\npublic List&lt;string&gt; Options { get; set; }\n</code></pre>\n<h3 id=\"q-资源文件找不到怎么办\">Q: 资源文件找不到怎么办？</h3>\n<p>A: 检查以下几点：</p>\n<ol>\n<li>资源文件是否正确嵌入（检查 <code>.csproj</code> 配置）</li>\n<li>资源键名称是否正确</li>\n<li>资源类型是否正确引用</li>\n<li>如果配置了回退文本，会使用回退文本</li>\n</ol>\n<h3 id=\"q-可以在运行时动态切换语言吗\">Q: 可以在运行时动态切换语言吗？</h3>\n<p>A: 可以。<code>LocalizedDescriptionAttribute</code> 会根据 <code>CultureInfo.CurrentUICulture</code> 自动获取对应语言的资源。语言切换由 <code>CodeSpirit.Localization</code> 组件的中间件处理。</p>\n<h3 id=\"q-导航组件支持哪些多语言配置方式\">Q: 导航组件支持哪些多语言配置方式？</h3>\n<p>A: 导航组件支持两种配置方式：</p>\n<ol>\n<li><strong>推荐方式</strong>：使用 <code>NavigationAttribute</code> 的 <code>TitleResourceKey</code> 和 <code>TitleResourceType</code></li>\n</ol>\n<pre><code class=\"language-csharp\">[Navigation(\n    TitleResourceKey = \"Controller.Users\",\n    TitleResourceType = typeof(NavigationResources)\n)]\n</code></pre>\n<ol start=\"2\">\n<li><strong>向后兼容</strong>：使用 <code>DisplayAttribute</code> 的 <code>Name</code> 和 <code>ResourceType</code></li>\n</ol>\n<pre><code class=\"language-csharp\">[Display(\n    Name = \"Controller.Users\",\n    ResourceType = typeof(NavigationResources)\n)]\n</code></pre>\n<p>如果同时配置了两者，<code>NavigationAttribute</code> 的配置优先级更高。</p>\n\n</div>\n<div id=\"MySignature\">\n    作者：<a href=\"http://www.cnblogs.com/codelove/\" target=\"_blank\">雪雁</a><br />出处：<a href=\"http://www.cnblogs.com/codelove/\" target=\"_blank\">http://www.cnblogs.com/codelove/</a>\n<br />如果喜欢作者的文章，请关注【CodeSpirit-码灵】公众号以便第一时间获得最新内容。本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。<br /><b>静听鸟语花香，漫赏云卷云舒。</b>\n<br />\n<img height=\"100\" src=\"https://images.cnblogs.com/cnblogs_com/codelove/315887/o_251224070213_%E5%85%AC%E4%BC%97%E5%8F%B7.jpg\" width=\"100\" />\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 09:12</span>&nbsp;\n<a href=\"https://www.cnblogs.com/codelove\">雪雁</a>&nbsp;\n阅读(<span id=\"post_view_count\">36</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一文理清FastAPI参数：从Query、Path到BaseModel的实战指南",
      "link": "https://www.cnblogs.com/ymtianyu/p/19424375",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19424375\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 08:57\">\n    <span>一文理清FastAPI参数：从Query、Path到BaseModel的实战指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文系统讲解了FastAPI中的核心参数类型，包括查询参数、路径参数以及请求体参数（JSON与表单）的定义、区别和使用方法。重点介绍了利用Pydantic BaseModel进行结构化数据验证和管理的优势与实践，并通过混合参数示例和完整代码展示了如何构建清晰、健壮且文档完善的API接口。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<p style=\"font-size: 18px; font-weight: bold; color: rgba(26, 26, 26, 1);\">刚学 FastAPI，是不是总被路径参数、查询参数、请求体这些概念绕晕，不知道数据从哪儿来、该怎么接？事实上，<strong style=\"color: rgba(186, 55, 42, 1);\">正确使用参数声明，能让你的 API 代码量减少一半，且自动获得完美的交互文档。</strong></p>\n<blockquote style=\"padding-left: 15px; margin: 20px 0; color: rgba(102, 102, 102, 1); font-style: italic;\">本文带你一次搞懂 FastAPI 中的所有核心参数类型：从简单的查询字符串（?name=value），到定义URL片段的路径参数，再到处理复杂 JSON 或表单数据的请求体。重点深入 Pydantic BaseModel，教你如何用它优雅地定义、验证和组织复杂数据，并自动生成 API 文档。读完你就能清晰地规划 API 的数据接口了。 <br /><br />- ✨ 查询参数与路径参数：基础与区别<br />- 📦 请求体参数：JSON (Body) 与 表单 (Form) 处理<br />- 🧩 混合参数：路径、查询、请求体同时使用<br />- 🏗️ 结构化利器：Pydantic BaseModel 详解与应用<br />- 🚀 完整实战示例与代码参考</blockquote>\n<h2 style=\"padding-bottom: 10px; margin-top: 40px;\">✨ 查询参数与路径参数：地基要打牢</h2>\n<p>这是两种最基础、最常用的参数，都直接体现在 URL 中。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">查询参数（Query Parameters）</strong>：跟在 URL 问号<code>?</code>后面，格式为<code>key1=value1&amp;key2=value2</code>。在 FastAPI 中，函数参数<strong>不是路径的一部分</strong>的，默认就是查询参数。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI\napp = FastAPI()\n\n@app.get(\"/items/\")\nasync def read_items(skip: int = 0, limit: int = 10):\n    # `skip`和`limit`就是查询参数，如：/items/?skip=20&amp;limit=5\n    return {\"skip\": skip, \"limit\": limit}</code></pre>\n<p>使用 <code>skip: int = 0</code> 形式，就定义了带默认值的可选参数。如果没有默认值（如 <code>name: str</code>），它就是必需的查询参数。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">路径参数（Path Parameters）</strong>：直接是 URL 路径的一部分，用花括号<code>{}</code>声明。通常用于唯一标识资源，比如根据ID获取某篇文章。</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):  # item_id 是路径参数\n    return {\"item_id\": item_id}</code></pre>\n<p>注意它们的顺序！如果把 <code>/items/{item_id}</code> 和 <code>/items/me</code> 两个端点都定义，<strong style=\"color: rgba(186, 55, 42, 1);\">要把具体的路径（<code>/items/me</code>）放在前面</strong>，否则<code>me </code>会被当成<code>item_id</code>的值。</p>\n<h2 style=\"padding-bottom: 10px; margin-top: 40px;\">📦 请求体参数：处理复杂数据</h2>\n<p>当你需要客户端发送较多数据（如创建新文章）时，就需要请求体。FastAPI 用 <code>Body()</code>, <code>Form()</code> 等工具函数来声明。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">JSON 请求体（Body）</strong>：最常见的 REST API 数据格式。使用 Pydantic 的 <code>BaseModel</code> 是最佳实践（下文详解），也可用 <code>Body()</code> 直接声明多个参数。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Body\n\n@app.put(\"/items/{item_id}\")\nasync def update_item(\n    item_id: int,\n    name: str = Body(...),  # Body(...) 表示必需项\n    description: str = Body(None)  # Body(None) 表示可选项\n):\n    return {\"item_id\": item_id, \"name\": name, \"description\": description}</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">表单数据（Form）</strong>：当数据来自 HTML 表单或需要上传文件时使用。如何要上传大文件，需要先安装 <code>python-multipart</code>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Form\n\n@app.post(\"/login/\")\nasync def login(username: str = Form(...), password: str = Form(...)):\n    return {\"username\": username}</code></pre>\n<h2 style=\"padding-bottom: 10px; margin-top: 40px;\">🧩 混合参数：自由组合，各司其职</h2>\n<p>FastAPI 能智能地区分参数来源，你可以同时使用路径、查询和请求体参数。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Path, Query, Body\n\n@app.put(\"/mixed-items/{item_id}\")\nasync def update_mixed_item(\n    *,\n    item_id: int = Path(..., title=\"商品ID\", ge=1),  # 路径参数，&gt;=1\n    q: str = Query(None, alias=\"query-string\"),      # 可选查询参数，别名\n    item: dict = Body(...)                           # 必需的JSON请求体\n):\n    results = {\"item_id\": item_id}\n    if q:\n        results.update({\"q\": q})\n    results.update({\"item\": item})\n    return results</code></pre>\n<p>这里用到了参数校验：<code>ge=1</code> 表示值大于等于1。<code>Query</code>, <code>Path</code>, <code>Body</code> 等函数让声明更明确且功能更强大（如添加描述、别名、校验）。</p>\n<h2 style=\"padding-bottom: 10px; margin-top: 40px;\">🏗️ 结构化利器：Pydantic BaseModel</h2>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">这是 FastAPI 的灵魂特性之一。</strong> BaseModel 让你用 Python 类来定义数据模型，它自动处理数据验证、序列化和文档生成。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from pydantic import BaseModel, EmailStr\nfrom typing import Optional, List\n\nclass UserCreate(BaseModel):\n    # 必需字段\n    username: str\n    email: EmailStr  # 内置邮箱格式验证\n    # 可选字段，带默认值\n    full_name: Optional[str] = None\n    # 列表类型\n    tags: List[str] = []\n\n@app.post(\"/users/\")\nasync def create_user(user: UserCreate):  # 一个参数接管整个请求体\n    # 直接访问已验证好的数据\n    if user.full_name:\n        greeting = f\"Hello, {user.full_name}!\"\n    else:\n        greeting = f\"Hello, {user.username}!\"\n    return {\"message\": greeting, \"user_info\": user.dict()}</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">BaseModel 的优势：</strong></p>\n- <strong>声明即验证：</strong> 字段类型不对、邮箱格式错误等会自动返回 422 错误。<br />- <strong>自动文档：</strong> Swagger UI 和 ReDoc 会自动显示模型结构和示例。<br />- <strong>代码清晰：</strong> 数据契约明确，业务逻辑与数据验证分离。<br />- <strong>嵌套自由：</strong> 模型可以嵌套其他模型，轻松处理复杂数据。<br />\n<h2 style=\"padding-bottom: 10px; margin-top: 40px;\">🚀 完整代码示例</h2>\n<p>下面是一个融合了主要参数类型的实战示例，你可以直接复制运行。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, Path, Query, Body\nfrom pydantic import BaseModel\nfrom typing import Optional\nfrom datetime import datetime\n\napp = FastAPI(title=\"参数详解示例\")\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float = Body(..., gt=0)\n    tax: Optional[float] = None\n    tags: list = []\n\n@app.post(\"/advanced-items/{category}\")\nasync def create_advanced_item(\n    category: str = Path(..., description=\"物品分类\"),\n    item_id: int = Query(..., ge=1, description=\"物品ID\"),\n    q: Optional[str] = Query(None, max_length=50),\n    urgent: bool = Query(False),\n    item: Item = Body(..., example={  # 为文档提供示例\n        \"name\": \"Foo\",\n        \"price\": 50.5,\n        \"tags\": [\"cool\", \"new\"]\n    })\n):\n    \"\"\"创建新物品的复杂端点\"\"\"\n    total = item.price + (item.tax if item.tax else 0)\n    result = {\n        \"category\": category,\n        \"item_id\": item_id,\n        \"query_string\": q,\n        \"urgent\": urgent,\n        \"item_name\": item.name,\n        \"total_price\": total,\n        \"created_at\": datetime.now().isoformat()\n    }\n    return result\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)</code></pre>\n<p>运行后，访问 <code>http://127.0.0.1:8000/docs</code>，你将看到一个功能齐全的交互式 API 文档，所有参数和模型都清晰可见。</p>\n<div style=\"text-align: center; margin: 40px 0;\"><hr style=\"border-right: none; border-bottom: none; border-left: none;\" /></div>\n<p style=\"text-align: center; color: rgba(119, 119, 119, 1); font-style: italic;\">喜欢本文？不要错过✨，点赞👍收藏⭐关注我👆，一起学习更多有用的知识，完善你我的技能树！也请路过的大佬给些建议和指教🙏🐶！</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 08:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">曲幽</a>&nbsp;\n阅读(<span id=\"post_view_count\">52</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "å¯¹é½è§„åˆ™å¤ª â€œè‹›åˆ»â€ï¼ŒPostgreSQLè¡¨å˜å¤§çš„ 3 ä¸ªæ ¸å¿ƒåŽŸå›",
      "link": "https://www.cnblogs.com/lyhabc/p/19161704/postgresql-table-size-increase-causes-alignment-padding",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lyhabc/p/19161704/postgresql-table-size-increase-causes-alignment-padding\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 08:00\">\n    <span>对齐规则太 “苛刻”，PostgreSQL表变大的 3 个核心原因</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1 style=\"text-align: center;\">对齐规则太 “苛刻”，PostgreSQL表变大的 3 个核心原因</h1>\n<p><span>相同的表结构和数据，在商业数据库中存储紧凑，到了PostgreSQL里却会明显变大？ 为什么有些数据库管理员（DBA）在将<span>Oracle</span>、<span>SQL Server和DB2</span><span>等商业数据库</span>迁移到PostgreSQL后表占用的磁盘空间增加20%-40%？</span></p>\n<p><span>本文将通过实际示例说明“对齐”与“填充”是如何造成这种差异的。</span></p>\n<h2><span><span>商业数据库中的行存储机制</span></span></h2>\n<p><span>SQL Server作为商业数据库，会将行数据存储在8KB大小的页（page）中，每一行的结构包含三部分：</span></p>\n<ol class=\"list-paddingleft-1\">\n<li><span>一个小型行头部（4字节，外加一个空值位图）；</span></li>\n<li><span>按定义顺序排列的所有固定长度列；</span></li>\n<li><span>通过“偏移数组”（offset array）管理的可变长度列。</span></li>\n</ol>\n<p><span>注意：</span><strong><span>SQL Server不对固定长度类型强制执行对齐规则</span></strong><span>。这意味着你可以在表中先定义一个BIT列、再定义一个BIGINT列、最后再定义一个BIT列，SQL Server会将这些字节紧密排列，不会产生空间浪费。</span></p>\n<p>&nbsp;</p>\n<p><img alt=\"QQ截图20251023212807\" src=\"https://img2024.cnblogs.com/blog/257159/202510/257159-20251023213645491-1192768041.png\" /></p>\n<p><span>通过实际代码来看具体效果：</span></p>\n<pre class=\"highlighter-hljs\"><code>-- SQL Server 代码\nCREATETABLE&nbsp;T_BadOrder\n(\n&nbsp; &nbsp; a&nbsp;BIT, &nbsp; &nbsp; &nbsp; &nbsp;-- 占用1字节\n&nbsp; &nbsp; b&nbsp;BIGINT, &nbsp; &nbsp;&nbsp;-- 占用8字节\n&nbsp; &nbsp; c&nbsp;BIT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- 占用1字节\n);\n\nINSERTINTO&nbsp;T_BadOrder&nbsp;VALUES&nbsp;(1,&nbsp;42,&nbsp;0);\n\n-- 计算数据占用（payload）大小：结果为10字节\nSELECTDATALENGTH(a) +&nbsp;DATALENGTH(b) +&nbsp;DATALENGTH(c)&nbsp;AS&nbsp;payload_bytes\nFROM&nbsp;T_BadOrder;\n\n-- 查看物理行的平均大小：结果为16字节（4字节行头部 + 10字节数据载荷 + 2字节空值位图掩码的字段计数）\nSELECT&nbsp;avg_record_size_in_bytes\nFROM&nbsp;sys.dm_db_index_physical_stats(DB_ID(), OBJECT_ID('T_BadOrder'),&nbsp;-1,&nbsp;NULL,&nbsp;'DETAILED')\nWHERE&nbsp;alloc_unit_type_desc =&nbsp;'IN_ROW_DATA';</code></pre>\n<p><span>可以看到，数据占用总计10字节，加上行头部和空值位图后，总大小为16字节。这里的重点是：字段a和字段b之间</span><strong><span>没有插入任何填充字节</span></strong><span>。</span></p>\n<h2><span><span>PostgreSQL中的行存储机制</span></span></h2>\n<p><span>PostgreSQL作为开源数据库，表中的每一行的结构如下：</span></p>\n<ol class=\"list-paddingleft-1\">\n<li><span>一个元组头部（tuple header，固定23字节），包含MVCC（多版本并发控制）所需的元数据（如事务ID、可见性标记等）；</span></li>\n<li><span>一个空值位图；（记录哪些字段是空值，每字段占 1 位，不足 1 字节则补满 1 字节，表如果有8个字段就占用1 字节）。</span></li>\n<li><span>按定义顺序排列的字段值。</span></li>\n</ol>\n<p><span>与商业数据库最大的不同是：</span><strong><span>PostgreSQL会强制要求数据类型对齐</span></strong><span>，具体规则如下：</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><span>BOOLEAN类型需要1字节对齐；</span></li>\n<li><span>SMALLINT类型需要2字节对齐；</span></li>\n<li><span>INT类型需要4字节对齐；</span></li>\n<li><span>BIGINT、double precision（双精度浮点数）、timestamp（时间戳）类型需要8字节对齐。</span></li>\n</ul>\n<p><span>如果某一字段的起始位置不符合对应的对齐要求，PostgreSQL会自动插入“填充字节”（padding bytes），将该字段“推”到正确的对齐边界上。我们用跟前文相同的表结构来测试：</span></p>\n<pre class=\"highlighter-hljs\"><code>-- PostgreSQL 代码\nCREATE&nbsp;TABLE&nbsp;t_bad\n(\n&nbsp; &nbsp; a&nbsp;boolean, &nbsp; &nbsp;-- 1字节（后续需补7字节填充）\n&nbsp; &nbsp; b&nbsp;bigint, &nbsp; &nbsp;&nbsp;-- 8字节（需8字节对齐，因此前一列要补填充）\n&nbsp; &nbsp; c&nbsp;boolean&nbsp; &nbsp; &nbsp;-- 1字节\n);\n\nINSERT&nbsp;INTO&nbsp;t_bad&nbsp;VALUES&nbsp;(true,&nbsp;42,&nbsp;false);\n\n-- 查看实际行大小：结果为41字节\nSELECT&nbsp;pg_column_size(t)&nbsp;AS&nbsp;row_bytes\nFROM&nbsp;t_bad t;</code></pre>\n<p><span>在这个例子中，元组头部（23 字节）+ 空值位图（1 字节）= 前 24 字节，PostgreSQL先为字段a分配1字节，然后插入7字节填充，这样字段b才能从8字节对齐边界开始存储；字段b之后是1字节的字段c。仅数据占用的大小就已经超过了SQL Server，还没算上PostgreSQL本身更大的元组头部。</span></p>\n<p><span>但如果我们根据“填充需求”调整字段的顺序，存储占用会显著减少：</span></p>\n<pre class=\"highlighter-hljs\"><code>-- PostgreSQL 代码\nCREATE&nbsp;TABLE&nbsp;t_good\n(\n&nbsp; &nbsp; b&nbsp;bigint, &nbsp; &nbsp;&nbsp;-- 8字节\n&nbsp; &nbsp; a&nbsp;boolean, &nbsp; &nbsp;-- 1字节（无需填充！）\n&nbsp; &nbsp; c&nbsp;boolean&nbsp; &nbsp; &nbsp;-- 1字节\n);\n\nINSERT&nbsp;INTO&nbsp;t_good&nbsp;VALUES&nbsp;(42,&nbsp;true,&nbsp;false);\n\n-- 查看实际行大小：结果为34字节（减少了7字节，因为无需为任何列插入填充）\nSELECT&nbsp;pg_column_size(t)&nbsp;AS&nbsp;row_bytes\nFROM&nbsp;t_good t;</code></pre>\n<p><span>调整后，行大小从41字节降至34字节，核心原因就是字段a不再需要填充字节，因为字段b（8字节）结束后，刚好满足字段a（1字节）的对齐要求。</span></p>\n<p><strong><span>关键原则：字段的顺序应从“占用空间最大”到“占用空间最小”排列！</span></strong></p>\n<p><strong><span>8字节对齐规则</span></strong><span>：</span><code><span>bigint</span></code><span>类型（8字节）要求其</span><strong><span>起始位置必须是8的倍数</span></strong><span>（比如8、16、24、32...）。这是硬件层面的优化。</span></p>\n<h3><span><span>具体位置计算</span></span></h3>\n<p><span>我们按字段的定义顺序（a → b → c）逐步计算每个字段的“起始位置”：</span></p>\n<ol class=\"list-paddingleft-1\">\n<li>\n<p><strong><span>字段a（boolean）的位置</span></strong><span>：</span><span><br /></span><span>前24字节是头部和空值位图，所以列a从</span><strong><span>第24字节</span></strong><span>开始存储。</span><span><br /></span><code><span>boolean</span></code><span>占1字节，因此字段a占用第24字节，结束在</span><strong><span>第24字节</span></strong><span>（24→24，共1字节）。</span></p>\n\n\n</li>\n<li>\n<p><strong><span>字段b（bigint）的位置</span></strong><span>：</span><span><br /></span><span>字段a结束后，下一个可用的起始位置是</span><strong><span>第25字节</span></strong><span>。</span><span><br /></span><span>但</span><code><span>bigint</span></code><span>要求起始位置是8的倍数（8的倍数：8、16、24、32、40...）。 &nbsp;第25字节不是8的倍数（25÷8=3.125，余数1），不符合要求。 &nbsp;因此需要填充字节，直到下一个8的倍数位置。最近的8的倍数是</span><strong><span>第32字节</span></strong><span>（8×4=32）。 从第25字节到第32字节，中间有32-25=7字节，这就是需要填充的</span><strong><span>7字节</span></strong><span>。所以字段b从第32字节开始，占用8字节（32→39字节）。</span></p>\n\n\n</li>\n<li>\n<p><strong><span>字段c（boolean）的位置</span></strong><span>：</span><span><br /></span><span>字段b结束在第39字节，下一个位置是第40字节。</span><span><br /></span><code><span>boolean</span></code><span>只需要1字节对齐（任何位置都可以），因此直接从第40字节开始，占用1字节（40→40字节）。</span></p>\n\n\n</li>\n\n</ol>\n<h3><span><span>总大小验证</span></span></h3>\n<p><span>整个行的总大小=头部（23）+ 空值位图（1）+ 字段a（1）+ 填充（7）+ 字段b（8）+ 字段c（1）= 23+1+1+7+8+1=41字节。</span></p>\n<h3><span><span>调整顺序后不需要填充</span></span></h3>\n<p><span>如果把</span><code><span>bigint</span></code><span>（b）放在第一个字段，情况就变了：</span></p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<span>字段b从第24字节开始（头部23+空值位图1=24），<span>24</span>是8的倍数（24÷8=3），符合</span><code><span>bigint</span></code><span>的对齐要求，无需填充。</span>\n</li>\n<li>\n<span>字段b占用24→31字节（8字节），之后字段a（boolean）从32字节开始（1字节对齐，无需填充），字段c从33字节开始，总大小减少7字节。</span>\n</li>\n\n</ul>\n<h2><span><span>可变长度字段的影响</span></span></h2>\n<p><span>当表中包含可变长度字段时，情况更有意思。两者的处理差异如下：</span></p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<span>在SQL Server中，可变长度数据通过行末尾的“偏移数组”管理；</span>\n</li>\n<li>\n<span>在PostgreSQL中，每一个可变长度值（如TEXT、VARCHAR、BYTEA、NUMERIC等）都自带一个4字节的“变长头部”（varlena header）。</span>\n</li>\n\n</ul>\n<p><span>我们通过下面两个表的表结构对比来看看实际影响：</span></p>\n<pre class=\"highlighter-hljs\"><code>-- PostgreSQL 代码：列顺序不合理的表\nCREATETABLE&nbsp;bad_order\n(\n&nbsp; &nbsp; a&nbsp;boolean,\n&nbsp; &nbsp; b&nbsp;bigint,\n&nbsp; &nbsp; c&nbsp;int,\n&nbsp; &nbsp; d&nbsp;timestamp,\n&nbsp; &nbsp; e&nbsp;smallint,\n&nbsp; &nbsp; f&nbsp;varchar(20),\n&nbsp; &nbsp; g&nbsp;numeric(18,2)\n);\n\n-- PostgreSQL 代码：列顺序合理的表\nCREATETABLE&nbsp;good_order\n(\n&nbsp; &nbsp; b&nbsp;bigint,\n&nbsp; &nbsp; d&nbsp;timestamp,\n&nbsp; &nbsp; c&nbsp;int,\n&nbsp; &nbsp; e&nbsp;smallint,\n&nbsp; &nbsp; a&nbsp;boolean,\n&nbsp; &nbsp; g&nbsp;numeric(18,2),\n&nbsp; &nbsp; f&nbsp;varchar(20)\n);\n\n-- 插入100万条测试数据\nINSERTINTO&nbsp;bad_order (a,b,c,d,e,f,g)\nSELECT\n&nbsp; (i %&nbsp;2&nbsp;=&nbsp;0), &nbsp;-- 布尔值：true/false交替\n&nbsp; (random()*1e9)::bigint, &nbsp;-- 随机大整数\n&nbsp; (random()*1e5)::int, &nbsp; &nbsp;&nbsp;-- 随机整数\n&nbsp; to_timestamp(1420070400&nbsp;+ (random()*1e6)::int), &nbsp;-- 随机时间戳\n&nbsp; (random()*32000)::int::smallint, &nbsp;-- 随机小整数\nsubstr(md5(random()::text),&nbsp;1, (random()*20)::int), &nbsp;-- 随机长度字符串（1-20字符）\n&nbsp; ((random()*1e7)::bigint)::numeric&nbsp;/&nbsp;100.0-- 随机数值（保留2位小数）\nFROM&nbsp;generate_series(1,1000000) i; &nbsp;-- 生成1-1000000的序列作为循环变量\n\n-- 将bad_order的数据按合理列顺序插入good_order\nINSERTINTO&nbsp;good_order\nSELECT&nbsp;b,d,c,e,a,g,f&nbsp;FROM&nbsp;bad_order;\n\n-- 对比两张表的平均行大小\nSELECT'bad_order'AS&nbsp;tbl,&nbsp;avg(pg_column_size(t))&nbsp;AS&nbsp;avg_row_bytes&nbsp;FROM&nbsp;bad_order t\nUNIONALL\nSELECT'good_order',&nbsp;avg(pg_column_size(t))&nbsp;FROM&nbsp;good_order t;</code></pre>\n<p><span>实际测试结果显示：</span><code><span>bad_order</span></code><span>因列顺序不合理和对齐问题，平均每行占用77字节；而</span><code><span>good_order</span></code><span>将“宽字节固定长度字段”放在前面、“可变长度字段”放在最后，最大限度减少了填充，平均每行仅占用66字节。</span></p>\n<h2><span><span>为什么PostgreSQL的行存储通常更大？</span></span></h2>\n<p><span>迁移后PostgreSQL行大小超过商业数据库，主要源于三个核心差异：</span></p>\n<ol class=\"list-paddingleft-1\">\n<li><strong><span>元组头部大小</span></strong><span>：PostgreSQL的行头部包含约23字节的MVCC元数据，而SQL Server仅为4字节；</span></li>\n<li><strong><span>对齐填充</span></strong><span>：PostgreSQL会插入填充字节以保证固定长度类型的对齐，而商业数据库则不会；</span></li>\n<li><strong><span>可变长度字段开销</span></strong><span>：PostgreSQL中每个可变长度字段都自带4字节的变长头部，商业数据库则无此开销。</span></li>\n</ol>\n<h3><span><span>PostgreSQL优化存储空间的核心逻辑包括下面几个方面：</span></span></h3>\n<ul class=\"list-paddingleft-1\">\n<li><span>先放“宽字节固定长度列”（如BIGINT、timestamp）；</span></li>\n<li><span>再放“中等字节固定长度列”（如INT）；</span></li>\n<li><span>接着放“小字节固定长度列”（如SMALLINT、BOOLEAN）；</span></li>\n<li><span>最后放“可变长度列”（如VARCHAR、TEXT、NUMERIC）。</span></li>\n</ul>\n<h2><span><span>总结</span></span></h2>\n<p><span>从<span>商业数据库</span>迁移到开源数据库PostgreSQL后表体积变大是为了支撑PostgreSQL的核心特性（MVCC）和跨架构的性能稳定性。这也意味着，我们不能期望商业数据库和开源数据库两者的存储大小完完全全“一一对应”，而且开源数据库跟商业数据库相比起来还是有一定的差距。</span></p>\n<p>&nbsp;</p>\n<p><img alt=\"\" class=\"medium-zoom-image\" src=\"https://img2024.cnblogs.com/blog/257159/202409/257159-20240908204310924-1005667056.png\" /></p>\n<p><strong>本文版权归作者所有，未经作者同意不得转载。</strong></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 08:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lyhabc\">桦仔</a>&nbsp;\n阅读(<span id=\"post_view_count\">139</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2025 年的 PHP 虽低调内敛没大改 但是更好用了",
      "link": "https://www.cnblogs.com/catchadmin/p/19424111",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19424111\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 08:00\">\n    <span>2025 年的 PHP 虽低调内敛没大改 但是更好用了</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"2025-年-php-的反常识变化\">2025 年 PHP 的“反常识”变化</h2>\n<p>2025 年的 PHP 并没有上演“脱胎换骨”。相反，它做的是更工程化、更实在的改进：把那些最容易割伤人的细节一点点打磨平整。</p>\n<p>你只要真的在生产环境里跑 PHP ，就会在这些地方感受到变化：</p>\n<ul>\n<li>写领域规则更顺手：不必靠一堆 getter/setter 才能把约束讲清楚。</li>\n<li>工具链更“较真”：对正确性更有立场，对“反正能跑”更不耐烦。</li>\n<li>框架生态继续抬高基线： PHP 8.2+ 已经不是尝鲜，而是默认门槛。比如 Laravel 12 的最低版本仍是 PHP 8.2。 (Laravel)</li>\n<li>PHP 8.5 于 2025 年 11 月发布，定位并不炫酷，却很像生产力放大器——前提是你愿意采用它更鼓励的写法。 (PHP)</li>\n</ul>\n<p>这不是功能清单，而是“工程体感总结”：哪些变化真的改变了日常写代码的方式，哪些做法减少了事故，以及哪些教训值得更早接受。</p>\n<p><a href=\"https://catchadmin.com/post/2025-12/php-in-2025-what-changed-what-stuck-next-time\" rel=\"noopener nofollow\" target=\"_blank\">原文 2025 年的 PHP：没大改，却更好用了</a></p>\n<h2 id=\"趋势-1-php-84-让规矩朴素的代码更容易写\">趋势 #1： PHP 8.4 让“规矩、朴素”的代码更容易写</h2>\n<p>PHP 8.4 虽然在 2024 年末发布，但 2025 年才在大多数团队里“落地”。原因很简单：生产升级从来不是一键完成。最关键的变化是 property hooks 与 asymmetric visibility。 (PHP)</p>\n<h3 id=\"property-hooks把规则贴在数据旁边\">Property hooks：把规则贴在数据旁边</h3>\n<p>以前你要表达不变式，常常会写成：私有属性 + getter/setter。它并不错误，但很容易让一个简单概念变得臃肿、仪式感过强。</p>\n<p>Property hooks 的价值在于：你可以在“读/写属性的那一刻”把规则讲明白，不再依赖大量样板。</p>\n<pre><code class=\"language-php\">&lt;?php\nfinal class Money\n{\n    public function __construct(\n        public string $currency,\n        public int $amountCents\n    ) {\n        if ($this-&gt;amountCents &lt; 0) {\n            throw new InvalidArgumentException(\"Amount cannot be negative.\");\n        }\n        if (!preg_match('/^[A-Z]{3}$/', $this-&gt;currency)) {\n            throw new InvalidArgumentException(\"Currency must be ISO-4217 format.\");\n        }\n    }\n}\nfinal class Invoice\n{\n    public function __construct(\n        public Money $total\n    ) {}\n    public Money $paid\n    {\n        set (Money $value) {\n            if ($value-&gt;currency !== $this-&gt;total-&gt;currency) {\n                throw new InvalidArgumentException(\"Currency mismatch.\");\n            }\n            if ($value-&gt;amountCents &gt; $this-&gt;total-&gt;amountCents) {\n                throw new InvalidArgumentException(\"Overpayment is not allowed.\");\n            }\n            $this-&gt;paid = $value;\n        }\n    }\n}\n</code></pre>\n<p>工程上的直观收益是：校验不再散落在各个 service 里，而能更自然地贴近它要保护的状态。</p>\n<p>现场教训：用 property hooks 做校验很合适；但如果你拿它做数据库 lazy-loading 之类的隐式 IO ，你会得到更难追踪的行为与更痛苦的调试体验。</p>\n<h3 id=\"asymmetric-visibility读给外部看写留给内部做\">Asymmetric visibility：读给外部看，写留给内部做</h3>\n<p>很多领域对象都想要“对外可读、对内可写”。过去你不是开 setter ，就是绕路。现在 PHP 8.4 把这种需求变得更直白。 (PHP)</p>\n<pre><code class=\"language-php\">&lt;?php\nfinal class Shipment\n{\n    public function __construct(\n        public private(set) string $status = 'CREATED',\n    ) {}\n    public function markInTransit(): void\n    {\n        $this-&gt;status = 'IN_TRANSIT';\n    }\n}\n</code></pre>\n<p>它减少了那种“为了 hydration/为了测试”而暴露 setter 的冲动——而这类冲动往往会无意间扩大系统的可变性与接口面。</p>\n<h2 id=\"趋势-2-php-85-更像一次写起来更舒服的升级\">趋势 #2： PHP 8.5 更像一次“写起来更舒服”的升级</h2>\n<p>PHP 8.5 在 2025 年 11 月 20 日发布。 (PHP)<br />\n相比轰动性的语法革新，它更像在开发体验上做加法： pipe operator ，以及更顺手的 clone-and-modify（社区常说 “clone with”）。 (stitcher.io)</p>\n<h3 id=\"pipe-operator把数据处理写成清晰的流水线\">Pipe operator：把数据处理写成清晰的流水线</h3>\n<p>业务代码里，数据变换非常常见。过去你要么写成嵌套调用，要么堆中间变量。 Pipe 的好处是：按步骤阅读更自然。</p>\n<pre><code class=\"language-php\">&lt;?php\nfunction trimAll(array $xs): array {\n    return array_map('trim', $xs);\n}\nfunction dropEmpty(array $xs): array {\n    return array_values(array_filter($xs, fn($x) =&gt; $x !== ''));\n}\nfunction unique(array $xs): array {\n    return array_values(array_unique($xs));\n}\n$tags = ['  php ', '', 'backend', 'PHP', 'backend '];\n$normalized = $tags\n    |&gt; trimAll(...)\n    |&gt; dropEmpty(...)\n    |&gt; array_map(strtolower(...), ...)\n    |&gt; unique(...);\nprint_r($normalized);\n</code></pre>\n<p>现场教训：每一步要“小且命名明确”。如果你一路 pipe 进匿名函数的大段逻辑，可读性会反过来下降。</p>\n<h3 id=\"uri-扩展少写正则多用标准解析\">URI 扩展：少写正则，多用标准解析</h3>\n<p>发布公告提到专门的 URI 扩展。 (PHP)<br />\n只要你做过重定向、回调、 OAuth 、支付、 webhook ，你就知道 URL 解析的坑有多“顽固”。方向上的价值很明确：用标准组件替换零散 regex。</p>\n<h3 id=\"clone-and-modify更安全的复制后微调\">clone-and-modify：更安全的“复制后微调”</h3>\n<p>DTO 、 command 、 event 这些“近似不可变对象”越来越常见。过去你要么 clone 后再手动改（容易漏），要么到处写 withX()。</p>\n<p>PHP 8.5 明确支持在 cloning 同时修改属性。 (PHP)<br />\n这会鼓励团队更多使用“复制后小改动”的安全模式。</p>\n<pre><code class=\"language-php\">&lt;?php\nfinal class CustomerProfile\n{\n    public function __construct(\n        public string $id,\n        public string $email,\n        public bool $marketingOptIn,\n    ) {}\n}\n$old = new CustomerProfile('c-123', 'old@mail.com', false);\n// Pseudocode-ish shape for the pattern:\n$new = clone $old;\n$new-&gt;email = 'new@mail.com';\n</code></pre>\n<h2 id=\"趋势-3框架把门槛抬高了你的依赖也会被一起拖着走\">趋势 #3：框架把门槛抬高了，你的依赖也会被一起拖着走</h2>\n<h3 id=\"laravel靠稳定与无聊赢\">Laravel：靠“稳定与无聊”赢</h3>\n<p>Laravel 12 延续维护导向，同时保持 PHP 8.2+ 基线。 (Laravel)<br />\n现实影响很直接：停在 PHP 8.0/8.1 的服务，会越来越难享受生态更新与安全支持。</p>\n<h3 id=\"symfony快节奏是压力也是优势\">Symfony：快节奏是压力，也是优势</h3>\n<p>Symfony 的时间线显示： Symfony 8.0 在 2025 年 11 月作为稳定线，并要求 PHP 8.4+。 (Symfony)<br />\n同时官方也给出了面向 2025 年 11 月下旬发布的准备建议。 (Symfony)</p>\n<p>现场教训： LTS 还是 latest ，本质是运维策略与预算问题。多服务体系里，最好明确一个默认选项，并公开例外。</p>\n<h2 id=\"趋势-4静态分析从加分项变成底线\">趋势 #4：静态分析从“加分项”变成“底线”</h2>\n<p>PHPStan 2.x 让越来越多团队把它放进合并门禁，因为它命中的 bug 往往就是事故前身。 (phpstan.org)</p>\n<p>稳妥的引入方式是渐进式，而不是一夜拉满：</p>\n<ul>\n<li>从低等级开始，先让 CI 跑起来但不阻断。</li>\n<li>修掉显而易见的问题：类型缺失、死分支、无意义 null 判断。</li>\n<li>baseline 只能当过渡，必须计划消化。</li>\n<li>逐模块提升门槛。</li>\n</ul>\n<p>示例配置与 CI：</p>\n<pre><code class=\"language-yaml\">parameters:\n  level: 6\n  paths:\n    - src\n  tmpDir: var/phpstan\n  checkMissingIterableValueType: false\n  reportUnmatchedIgnoredErrors: true\n</code></pre>\n<pre><code class=\"language-bash\">composer require --dev phpstan/phpstan\nvendor/bin/phpstan analyse --memory-limit=1G\n</code></pre>\n<h2 id=\"趋势-5测试写得更轻松但执行标准更现代\">趋势 #5：测试写得更轻松，但执行标准更现代</h2>\n<ul>\n<li>PHPUnit 11 要求 PHP 8.2+， PHPUnit 12 要求 PHP 8.3+。 (phpunit.de)</li>\n<li>Pest 4 要求 PHP 8.3+（ 2025 年 8 月发布）， Pest 3 对齐 PHP 8.2+。 (pestphp.com)</li>\n</ul>\n<p>Pest 的优势是降低写测试的阻力，尤其适合应用层测试。例子如下：</p>\n<pre><code class=\"language-php\">&lt;?php\nfinal class Discount\n{\n    public function apply(int $priceCents, int $percent): int\n    {\n        if ($percent &lt; 0 || $percent &gt; 100) {\n            throw new InvalidArgumentException(\"Percent must be 0..100\");\n        }\n        $cut = (int) round($priceCents * ($percent / 100));\n        return max(0, $priceCents - $cut);\n    }\n}\n</code></pre>\n<pre><code class=\"language-php\">&lt;?php\nuse PHPUnit\\Framework\\Attributes\\Test;\nit('applies percentage discount safely', function () {\n    $d = new Discount();\n    expect($d-&gt;apply(10000, 10))-&gt;toBe(9000);\n    expect($d-&gt;apply(10000, 0))-&gt;toBe(10000);\n    expect($d-&gt;apply(10000, 100))-&gt;toBe(0);\n});\nit('rejects invalid percentages', function () {\n    $d = new Discount();\n    expect(fn() =&gt; $d-&gt;apply(10000, -1))-&gt;toThrow(InvalidArgumentException::class);\n    expect(fn() =&gt; $d-&gt;apply(10000, 101))-&gt;toThrow(InvalidArgumentException::class);\n});\n</code></pre>\n<p>现场教训：优先测边界——这些地方最容易出事故：四舍五入、时间窗、幂等、空值、格式化。</p>\n<h2 id=\"趋势-6-composer-更安全导向依赖成了供应链问题\">趋势 #6： Composer 更安全导向，依赖成了供应链问题</h2>\n<p>Composer 的演进持续强化一个观念：依赖管理是生产基础设施。 (getcomposer.org)<br />\n2025 年末的 GitHub release notes 也体现了对安全与审计行为的加强。 (GitHub)</p>\n<p>实用卫生习惯包括：提交 lock 、使用 composer audit 、保持 platform 约束一致、定期依赖更新。</p>\n<pre><code class=\"language-json\">{\n  \"require\": {\n    \"php\": \"^8.3\"\n  },\n  \"config\": {\n    \"platform\": {\n      \"php\": \"8.3.0\"\n    }\n  }\n}\n</code></pre>\n<h2 id=\"趋势-7工具更-ai-但-adoption-的关键仍是-ide\">趋势 #7：工具更 AI ，但 adoption 的关键仍是 IDE</h2>\n<p>PhpStorm 2025.3 提到对 PHP 8.5 的支持与 agent 集成。 (The JetBrains Blog)<br />\n现实是： IDE 如果不支持新语法，新特性很难进入团队日常写法。</p>\n<h2 id=\"生产上最值得坚持的清单\">生产上最值得坚持的清单</h2>\n<ul>\n<li>把升级当作可管理的产品工作：定目标、做双版本 CI 、按顺序升级。</li>\n<li>做清晰边界：输入 DTO → 领域对象 → 输出映射。</li>\n<li>追求可调试性：减少隐式 null 、数组契约、无幂等重试。</li>\n<li>把可观测性放在关键决策点：结构化日志、 correlation ID。</li>\n<li>用语言特性降低偶然复杂度，而不是制造花活。</li>\n</ul>\n<h2 id=\"结论\">结论</h2>\n<p>2025 年的 PHP 更偏向奖励“稳定与克制”。 PHP 8.4 帮你更清楚地表达意图， PHP 8.5 让常见变换与不可变风格更顺手。 (PHP)<br />\n真正跑得更快的团队，往往不是追新，而是用这些变化把系统变得更可预测。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 08:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">9</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Redis 7.0 新特性之maxmemory-clients：限制客户端内存总使用量",
      "link": "https://www.cnblogs.com/ivictor/p/19424061",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ivictor/p/19424061\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 07:20\">\n    <span>Redis 7.0 新特性之maxmemory-clients：限制客户端内存总使用量</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1><span style=\"color: rgba(0, 128, 0, 1);\">背景</span></h1>\n<p><span>之前分享个 case（<a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=Mzg5OTY2MjU5MQ==&amp;mid=2247495615&amp;idx=1&amp;sn=130df46d573bbdd979dff98d82575dfe&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">Redis 内存突增时，如何定量分析其内存使用情况</a>），一个 Redis 实例的内存突增，<code><span>used_memory</span></code><span>最大时达到了 78.9G，而该实例的<code><span>maxmemory</span></code><span>配置却只有 16G，最终导致实例中的数据被大量驱逐。</span></span></span></p>\n<p><span>导致这个问题的一个常见原因是客户端占用的内存过多。</span></p>\n<p><span>Redis 中，客户端内存主要包括三部分：输入缓冲区（暂存客户端命令）、输出缓冲区（缓存发送给客户端的数据），以及客户端对象本身的开销。</span></p>\n<p><span>其中，输入缓冲区可通过<code><span>client-query-buffer-limit</span></code><span>限制，输出缓冲区可通过<code><span>client-output-buffer-limit</span></code><span>限制。</span></span></span></p>\n<p><span>但这两个参数<strong>只能限制单个客户端</strong><span>。</span></span></p>\n<p><span>在客户端数量较多的情况下，即使单个客户端占用不大，客户端内存的总量仍可能失控。</span></p>\n<p><span>为了解决这一问题，Redis 7.0 引入了<code><span>maxmemory-clients</span></code><span>，用于限制所有客户端可使用的内存总量。</span></span></p>\n<p><span>下面看看具体的实现细节。</span></p>\n<h1><span style=\"color: rgba(0, 128, 0, 1);\">配置</span></h1>\n<pre><span><code><span>standardConfig static_configs[] = {<span><br /><span>...<span><br /><span>&nbsp; &nbsp; createSSizeTConfig(\"maxmemory-clients\"<span>,&nbsp;NULL<span>, MODIFIABLE_CONFIG,&nbsp;-100<span>, SSIZE_MAX, server.maxmemory_clients,&nbsp;0<span>, MEMORY_CONFIG | PERCENT_CONFIG,&nbsp;NULL<span>, applyClientMaxMemoryUsage),<span><br /><span>...<span><br /><span>};<span><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>\n<p><code><span>maxmemory-clients</span></code><span>&nbsp;的默认值为 0，最小值为 -100，对应的内部变量是<code><span>server.maxmemory_clients</span></code><span>。</span></span></p>\n<p><span>该参数既可以设置为正数，也可以设置为负数：</span></p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p><span>正数：表示客户端内存总使用量的上限。因为该参数的类型是 MEMORY_CONFIG，所以可以指定 kb/mb/gb 之类的单位。不指定，则默认是字节。</span></p>\n</li>\n<li>\n<p><span>负数：表示按 maxmemory &nbsp;的百分比限制客户端内存。例如：<code><span>maxmemory-clients = -50</span></code><span>表示客户端内存总量不得超过 maxmemory 的 50%。</span></span></p>\n</li>\n</ul>\n<p><span>这一点是在<code><span>getClientEvictionLimit</span></code><span>函数中实现的。</span></span></p>\n<pre><span><code><span>size_t<span>&nbsp;<span>getClientEvictionLimit<span>(<span>void<span>)<span>&nbsp;<span>{<span><br /><span>&nbsp; &nbsp;&nbsp;size_t<span>&nbsp;maxmemory_clients_actual = SIZE_MAX;<span><br /><span><br /><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(server.maxmemory_clients &lt;&nbsp;0<span>&nbsp;&amp;&amp; server.maxmemory &gt;&nbsp;0<span>) {<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;unsignedlonglong<span>&nbsp;maxmemory_clients_bytes = (unsignedlonglong<span>)((double<span>)server.maxmemory * -(double<span>) server.maxmemory_clients /&nbsp;100<span>);<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(maxmemory_clients_bytes &lt;= SIZE_MAX)<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmemory_clients_actual = maxmemory_clients_bytes;<span><br /><span>&nbsp; &nbsp; }<span><br /><span>&nbsp; &nbsp;&nbsp;elseif<span>&nbsp;(server.maxmemory_clients &gt;&nbsp;0<span>)<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; maxmemory_clients_actual = server.maxmemory_clients;<span><br /><span>&nbsp; &nbsp;&nbsp;else<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return0<span>;<span><br /><span><br /><span>&nbsp; &nbsp;&nbsp;<span>/* Don't allow a too small maxmemory-clients to avoid cases where we can't communicate<span><br /><span>&nbsp; &nbsp; &nbsp;* at all with the server because of bad configuration */<span><br /><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(maxmemory_clients_actual &lt;&nbsp;1024<span>*128<span>)<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; maxmemory_clients_actual =&nbsp;1024<span>*128<span>;<span><br /><span><br /><span>&nbsp; &nbsp;&nbsp;return<span>&nbsp;maxmemory_clients_actual;<span><br /><span>}<span><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>\n<h1><span style=\"color: rgba(0, 128, 0, 1);\">实现细节</span></h1>\n<p><span>当通过<code><span>CONFIG SET</span></code><span>命令调整<code><span>maxmemory-clients</span></code><span>的值时，会调用<code><span>applyClientMaxMemoryUsage</span></code><span>函数进行处理。</span></span></span></span></p>\n<pre><span><code><span>static<span>&nbsp;<span>int<span>&nbsp;<span>applyClientMaxMemoryUsage<span>(<span>const<span>&nbsp;<span>char<span>&nbsp;**err)<span>&nbsp;<span>{<span><br /><span>&nbsp; &nbsp; ...<span><br /><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(server.maxmemory_clients !=&nbsp;0<span>)<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; initServerClientMemUsageBuckets();<span><br /><span>&nbsp; &nbsp; ...<span><br /><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(server.maxmemory_clients ==&nbsp;0<span>)<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; freeServerClientMemUsageBuckets();<span><br /><span>&nbsp; &nbsp;&nbsp;return<span>&nbsp;1<span>;<span><br /><span>}<span><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>\n<p><span>可以看到，当<code><span>server.maxmemory_clients</span></code><span>的值不为 0，会调用<code><span>initServerClientMemUsageBuckets()</span></code><span>。</span></span></span></p>\n<pre><span><code><span>void<span>&nbsp;<span>initServerClientMemUsageBuckets<span>()<span>&nbsp;<span>{<span><br /><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(server.client_mem_usage_buckets)<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return<span>;<span><br /><span>&nbsp; &nbsp; server.client_mem_usage_buckets = zmalloc(sizeof<span>(clientMemUsageBucket)*CLIENT_MEM_USAGE_BUCKETS);<span><br /><span>&nbsp; &nbsp;&nbsp;for<span>&nbsp;(int<span>&nbsp;j =&nbsp;0<span>; j &lt; CLIENT_MEM_USAGE_BUCKETS; j++) {<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; server.client_mem_usage_buckets[j].mem_usage_sum =&nbsp;0<span>;<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; server.client_mem_usage_buckets[j].clients = listCreate();<span><br /><span>&nbsp; &nbsp; }<span><br /><span>}<span><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>\n<p><span>该函数用于初始化<code><span>server.client_mem_usage_buckets</span></code><span>数组，数组长度由宏<code><span>CLIENT_MEM_USAGE_BUCKETS</span></code><span>决定，默认 19。</span></span></span></p>\n<p><span>每个元素表示一个桶（bucket）。 每个桶维护两类信息：</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><span>mem_usage_sum：该桶内所有客户端的内存占用总和。</span></li>\n<li><span>clients：属于该桶的客户端列表。</span></li>\n</ul>\n<p><span>当客户端内存发生变化时，Redis 会通过<code><span>updateClientMemUsageAndBucket</span></code><span>更新该客户端的内存使用情况（客户端使用的内存，对应<code><span>client list</span></code><span>输出中的<code><span>tot-mem</span></code><span>），并根据内存大小将客户端分配到对应的桶中：</span></span></span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>小于 32KB</strong><span>&nbsp;的客户端进入 0 号桶；</span></li>\n<li><strong>32KB～64KB</strong><span>&nbsp;的客户端进入 1 号桶；</span></li>\n<li><span>之后每个桶的范围按 2 倍递增；</span></li>\n<li><strong>≥ 4GB</strong><span>&nbsp;的客户端进入 18 号桶。</span></li>\n</ul>\n<p><span>此外，Redis 还会通过<code><span>clientsCron()</span></code><span>周期性地更新部分客户端的内存使用情况。&nbsp;<code><span>clientsCron()</span></code><span>&nbsp;的执行频率由<code><span>server.hz</span></code><span>控制，默认每秒 10 次。</span></span></span></span></p>\n<h1><span style=\"color: rgba(0, 128, 0, 1);\">适用的客户端类型</span></h1>\n<p><span>需要注意的是，并非所有客户端都会被统计内存并参与驱逐。具体判断逻辑如下：</span></p>\n<pre><span><code><span>int<span>&nbsp;<span>clientEvictionAllowed<span>(client *c)<span>&nbsp;<span>{<span><br /><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(server.maxmemory_clients ==&nbsp;0<span>&nbsp;|| c-&gt;flags &amp; CLIENT_NO_EVICT) {<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return<span>&nbsp;0<span>;<span><br /><span>&nbsp; &nbsp; }<span><br /><span>&nbsp; &nbsp;&nbsp;int<span>&nbsp;type = getClientType(c);<span><br /><span>&nbsp; &nbsp;&nbsp;return<span>&nbsp;(type == CLIENT_TYPE_NORMAL || type == CLIENT_TYPE_PUBSUB);<span><br /><span>}<span><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>\n<p><span>可以看到，只有满足以下条件的客户端才会被统计内存并参与驱逐：</span></p>\n<ol class=\"list-paddingleft-1\">\n<li><code><span>maxmemory_clients</span></code><span>不为 0。</span></li>\n<li><span>客户端未设置 CLIENT_NO_EVICT，在 Redis 7.0 中，支持通过<code><span>CLIENT NO-EVICT ON</span></code><span>命令显式关闭驱逐。</span></span></li>\n<li><span>客户端类型为 NORMAL 或 PUBSUB。也就是说，复制相关客户端不会被驱逐。</span></li>\n</ol>\n<h1><span style=\"color: rgba(0, 128, 0, 1);\">客户端驱逐细节</span></h1>\n<p><span>客户端驱逐是在<code><span>evictClients</span></code><span>函数中实现的。</span></span></p>\n<pre><span><code><span>void<span>&nbsp;<span>evictClients<span>(<span>void<span>)<span>&nbsp;<span>{<span><br /><span>&nbsp; &nbsp;&nbsp;// 如果 client_mem_usage_buckets 没被初始化，则直接返回<span><br /><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(!server.client_mem_usage_buckets)<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return<span>;<span><br /><span>&nbsp; &nbsp;&nbsp;// 从最大客户端内存桶开始驱逐<span><br /><span>&nbsp; &nbsp;&nbsp;int<span>&nbsp;curr_bucket = CLIENT_MEM_USAGE_BUCKETS-1<span>;<span><br /><span>&nbsp; &nbsp; listIter bucket_iter;<span><br /><span>&nbsp; &nbsp; listRewind(server.client_mem_usage_buckets[curr_bucket].clients, &amp;bucket_iter);<span><br /><span>&nbsp; &nbsp;&nbsp;// 获取客户端允许使用的最大内存<span><br /><span>&nbsp; &nbsp;&nbsp;size_t<span>&nbsp;client_eviction_limit = getClientEvictionLimit();<span><br /><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(client_eviction_limit ==&nbsp;0<span>)<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return<span>;<span><br /><span>&nbsp; &nbsp;&nbsp;// 循环驱逐，直到客户端总内存降到阈值以下或所有可驱逐客户端已释放<span><br /><span>&nbsp; &nbsp;&nbsp;while<span>&nbsp;(server.stat_clients_type_memory[CLIENT_TYPE_NORMAL] +<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;server.stat_clients_type_memory[CLIENT_TYPE_PUBSUB] &gt;= client_eviction_limit) {<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 获取当前桶的下一个客户端<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; listNode *ln = listNext(&amp;bucket_iter);<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(ln) {<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; client *c = ln-&gt;value;<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 生成客户端信息字符串，用于日志<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sds ci = catClientInfoString(sdsempty(),c);<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; serverLog(LL_NOTICE,&nbsp;\"Evicting client: %s\"<span>, ci);<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 释放客户端占用的资源<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeClient(c);<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sdsfree(ci);<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// stat_evictedclients对应的是info stats中的evicted_clients<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server.stat_evictedclients++;<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else<span>&nbsp;{<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 当前桶已空，切换到下一个较小客户端桶<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr_bucket--;<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 所有桶都已经遍历完，但内存仍超过阈值，记录警告<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(curr_bucket &lt;&nbsp;0<span>) {<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; serverLog(LL_WARNING,&nbsp;\"Over client maxmemory after evicting all evictable clients\"<span>);<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break<span>;<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; listRewind(server.client_mem_usage_buckets[curr_bucket].clients, &amp;bucket_iter);<span><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; }<span><br /><span>&nbsp; &nbsp; }<span><br /><span>}<span><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>\n<p><span>可以看到，该函数从最大内存桶开始驱逐，优先淘汰占用内存最多的客户端。</span></p>\n<p><span>对于被驱逐的客户端，会在日志中打印以下内容。</span></p>\n<pre><span><code><span>* Evicting client: id=993566 addr=243.247.151.0:46084 laddr=172.17.0.2:7379 fd=774 name= age=6 idle=1 flags=N db=0 sub=0 psub=0 ssub=0 multi=-1 qbuf=0 qbuf-free=20474 argv-mem=0 multi-mem=0 rbs=4096 rbp=0 obl=0 oll=1 omem=3145752 tot-mem=3171096 events=rw cmd=get user=default redir=-1 resp=2<span><br /></span></span></code></span></pre>\n<p><span>该函数的调用场景主要有两个：</span></p>\n<ol class=\"list-paddingleft-1\">\n<li><code><span>beforeSleep</span></code><span>：在处理完本轮所有命令、即将进入下一轮事件循环阻塞前执行。该阶段会处理客户端读写与阻塞状态、集群与复制维护、Key 过期、AOF 刷盘、异步释放客户端，以及客户端内存驱逐等操作。</span></li>\n<li><code><span>processCommand(client *c)</span></code><span>：在完整读取并解析一条客户端命令后调用，是所有命令的必经路径，用于执行命令合法性校验、ACL 权限检查、集群重定向判断、客户端内存限制、服务器内存淘汰、只读从库校验等一系列前置检查。</span></li>\n</ol>\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 07:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ivictor\">iVictor</a>&nbsp;\n阅读(<span id=\"post_view_count\">85</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Claude Skills MCP 技术解析",
      "link": "https://www.cnblogs.com/smartloli/p/19423547",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/smartloli/p/19423547\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 22:48\">\n    <span>Claude Skills MCP 技术解析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>1.概述</h1>\n<p>如果说大模型的推理能力决定了“它有多聪明”，那么 MCP 决定了它到底能不能在真实世界里把事做完。这篇文章不是简单介绍一个新名词，而是试图回答一个很多工程师心里都在问的问题：<strong>Claude 的 Skills 和 MCP，到底解决了什么？为什么它看起来比传统的 Tool / Function Calling 更“重”？</strong></p>\n<h1><strong>2.内容</strong></h1>\n<h2><strong>2.1&nbsp;从一个真实问题说起</strong></h2>\n<p>先说一个很常见的场景。你让一个大模型帮你做一件事：</p>\n<div class=\"cnblogs_code\">\n<pre>“帮我查一下这个用户的资料、最近 <span style=\"color: rgba(128, 0, 128, 1);\">30</span> 天的订单，然后给出运营建议。”</pre>\n</div>\n<p>如果你做过相关系统，第一反应一定是：</p>\n<ul>\n<li>要查用户表</li>\n<li>要查订单表</li>\n<li>要聚合数据</li>\n<li>要分析结果</li>\n</ul>\n<p>而传统 LLM 的做法往往是：</p>\n<ul>\n<li>用 Prompt 告诉模型“假装你查了数据库”</li>\n<li>或者用 Function Calling 勉强调用一两个接口</li>\n<li>或者在外部代码里硬写流程</li>\n</ul>\n<p>问题是，这些方式都存在明显短板：</p>\n<ul>\n<li>Prompt 是假能力</li>\n<li>Function Calling 是半自动</li>\n<li>外部流程是模型被动执行</li>\n</ul>\n<p>Claude 的 Skill + MCP，试图从底层解决这个问题。</p>\n<h2>2.2&nbsp;什么是 Claude Skills？先把误解说清楚</h2>\n<p>很多人第一次听到 Skill，会下意识理解为：</p>\n<div class=\"cnblogs_code\">\n<pre>“哦，就是 Tool。”</pre>\n</div>\n<p>但实际上 Claude Skills 和传统 Tool 并不是一个层级的东西。</p>\n<p><strong>1.直观理解一下</strong></p>\n<ul>\n<li>Tool：“这是一个函数，你可以调用。”</li>\n<li>Skills：“这是一个你被允许使用的能力边界，我已经帮你定义好了输入、输出和规则。”</li>\n</ul>\n<p><strong>2.Skill 更像什么？</strong></p>\n<ul>\n<li><strong>像一个系统 API + 类型系统 + 权限边界的组合体</strong></li>\n</ul>\n<p><strong>3.一个 Skill 至少包含什么？</strong></p>\n<p>一个完整的 Claude Skill，通常包含：</p>\n<ul>\n<li>能力名称（Name）</li>\n<li>能力描述（给模型看的）</li>\n<li>输入参数结构（JSON Schema）</li>\n<li>输出结果结构（JSON Schema）</li>\n<li>实际执行逻辑（运行在 Skill Server 中）</li>\n</ul>\n<p>也就是说，Skill 本身是“声明式”的，模型并不关心你是 Python、Java 还是 Rust 实现的。</p>\n<h2>2.3&nbsp;MCP（Model Context Protocol）到底是什么？</h2>\n<p>先给一个不那么官方的定义：</p>\n<div class=\"cnblogs_code\">\n<pre>MCP 是一套让大模型“安全、可控地使用外部能力，并把结果纳入推理过程”的协议。</pre>\n</div>\n<p>注意关键词不是“调用”，而是：</p>\n<ul>\n<li>安全</li>\n<li>可控</li>\n<li>纳入推理</li>\n</ul>\n<p>这三点，恰恰是很多 Tool 方案做不到的。</p>\n<p><strong>1.MCP 解决的核心不是“怎么调函数”</strong></p>\n<p>而是这几个问题：</p>\n<ul>\n<li>模型怎么知道有哪些能力可以用？</li>\n<li>模型怎么理解这些能力能干嘛？</li>\n<li>模型怎么保证参数不会乱传？</li>\n<li>执行结果怎么回到上下文继续推理？</li>\n<li>整个过程怎么被人类治理？</li>\n</ul>\n<p>MCP 是在解决“<strong>模型与现实系统之间的协议问题</strong>”。</p>\n<h2>2.4&nbsp;整体架构：Claude 是大脑，MCP 是神经系统</h2>\n<p>先看一张整体结构图：</p>\n<p><img alt=\"image\" height=\"826\" src=\"https://img2024.cnblogs.com/blog/666745/202512/666745-20251230222618784-1569725605.png\" width=\"1196\" /></p>\n<p>&nbsp;关键点在这里：</p>\n<ul>\n<li>Claude 不直接接触数据库</li>\n<li>Claude 不直接发 HTTP 请求</li>\n<li>Claude 只和 MCP “说话”</li>\n</ul>\n<p>&nbsp;这就像：<strong>大脑不会直接控制肌肉纤维，而是通过神经系统发信号。</strong></p>\n<h2><strong>2.5&nbsp;一次完整的 MCP 调用流程</strong></h2>\n<p>我们把一次完整调用拆开来看。</p>\n<h3><strong>1.场景</strong></h3>\n<p><strong>用户说：</strong></p>\n<div class=\"cnblogs_code\">\n<pre>“帮我查一下 test@example.com 这个用户的信息。”</pre>\n</div>\n<p><strong>1️⃣ Claude 先做什么？</strong></p>\n<p>Claude 首先做的是 语义判断：</p>\n<ul>\n<li>这是一个“查用户”的请求</li>\n<li>当前上下文里有没有能完成这件事的 Skill？</li>\n<li>如果 MCP Client 注册过类似：</li>\n</ul>\n<div class=\"cnblogs_code\">\n<pre>get_user_by_email</pre>\n</div>\n<p>Claude 就会继续。</p>\n<p><strong>2️⃣ Claude 生成 MCP 调用（结构化）</strong></p>\n<p>不是自然语言，而是类似这样的结构化请求：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">{\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">tool</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">get_user_by_email</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">arguments</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">: {\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">email</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">test@example.com</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n  }\n}</span></pre>\n</div>\n<p>这一步非常重要：<strong>模型已经从“生成文本”切换成“生成结构化意图”。</strong></p>\n<p><strong>3️⃣ MCP Client 做校验</strong></p>\n<p>MCP Client 会检查：</p>\n<ul>\n<li>Skill 是否存在</li>\n<li>参数是否符合 Schema</li>\n<li>是否有权限调用</li>\n</ul>\n<p>不通过，直接拦截。</p>\n<p><strong>4️⃣ Skill Server 执行真实逻辑</strong></p>\n<p>比如：</p>\n<ul>\n<li>查数据库</li>\n<li>调内部 API</li>\n<li>读取文件</li>\n</ul>\n<p><strong>5️⃣ 返回结构化结果</strong></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">{\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">u_123</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">name</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">email</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">test@example.com</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">level</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">VIP</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n}</span></pre>\n</div>\n<p><strong>6️⃣ Claude 把结果“吃”回上下文</strong></p>\n<p>注意这里不是“展示给用户”，而是：<strong>作为新上下文继续推理</strong>。Claude 可能会接着分析、对比、总结，最后才生成自然语言回复。</p>\n<h2>2.6&nbsp;一个最小可运行的 MCP Skill 示例</h2>\n<p>下面这个示例非常简单，但已经具备 MCP 的完整形态。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">from mcp.server import Server\n\nserver </span>= Server(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">user_service</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n\n@server.tool()\ndef get_user_by_email(email: str) </span>-&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> dict:\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">    Query user information by email\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span>    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> email == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">test@example.com</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        return {\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">u_123</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">name</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">email</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">: email,\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">level</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">VIP</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n        }\n    return {}\n\nserver.run()</span></pre>\n</div>\n<p>你会发现：</p>\n<ul>\n<li>没有 prompt</li>\n<li>没有 AI 逻辑</li>\n<li>只是纯能力定义</li>\n</ul>\n<p>但 Claude 会自动理解：</p>\n<ul>\n<li>什么时候用它</li>\n<li>怎么用</li>\n<li>用完之后怎么继续思考</li>\n</ul>\n<h2>2.7&nbsp;为什么 MCP 对 Agent 特别重要？</h2>\n<p>如果你做过 Agent，一定踩过这些坑：</p>\n<ul>\n<li>流程写死</li>\n<li>状态难维护</li>\n<li>一步失败全盘崩</li>\n<li>能力越多越混乱</li>\n</ul>\n<p>MCP 的好处在于：</p>\n<ul>\n<li>Agent 不需要提前写死流程，模型可以动态规划。</li>\n</ul>\n<p><strong>一个典型 Agent 行为</strong>：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">用户需求：\n\n“帮我分析这个用户最近的消费情况，并给出建议。”</span></pre>\n</div>\n<p>Claude 可能会：</p>\n<ul>\n<li>调用 get_user_profile</li>\n<li>调用 search_orders</li>\n<li>汇总数据</li>\n<li>给出分析和建议</li>\n<li>你不需要写 if/else 流程。</li>\n</ul>\n<h2>2.8&nbsp;MCP 和 Function Calling 的本质区别</h2>\n<p>很多人会问：</p>\n<ul>\n<li>“这和 OpenAI 的 Function Calling 有什么区别？”</li>\n</ul>\n<p>简单说一句：</p>\n<ul>\n<li>Function Calling 是能力点，MCP 是能力体系。</li>\n</ul>\n<p><img alt=\"image\" height=\"751\" src=\"https://img2024.cnblogs.com/blog/666745/202512/666745-20251230224051152-69932232.png\" width=\"1378\" /></p>\n<h2>2.9&nbsp;在真实工程中如何用好 MCP？</h2>\n<p>一些经验之谈：</p>\n<p><strong>Skill 设计建议</strong></p>\n<ul>\n<li>一个 Skill 只做一件事</li>\n<li>输入输出一定要稳定</li>\n<li>不要返回自然语言</li>\n<li>错误也要结构化</li>\n</ul>\n<p><strong>不要做的事情</strong></p>\n<ul>\n<li>把业务逻辑写进 Prompt</li>\n<li>一个 Skill 干五六件事</li>\n<li>让模型自己拼 SQL</li>\n<li>让 Skill 返回“分析结论”</li>\n</ul>\n<h2>2.10&nbsp;我对 MCP 的一个判断</h2>\n<p>站在工程视角，我认为：</p>\n<ul>\n<li>MCP 是目前最接近“大模型操作系统接口”的设计之一。</li>\n</ul>\n<p>它做的不是让模型“更聪明”，而是让模型：</p>\n<ul>\n<li>更可靠</li>\n<li>更可控</li>\n<li>更像一个真正能落地的系统组件</li>\n</ul>\n<h1>3.总结</h1>\n<p>如果你只是做 Demo，MCP 可能显得有点“重”。</p>\n<p>但如果你在做的是：</p>\n<ul>\n<li>企业级 AI 助手</li>\n<li>AI 编程系统</li>\n<li>多 Agent 自动化平台</li>\n</ul>\n<p>那 MCP 不是“可选项”，而是迟早要走到的那一步。</p>\n<h1 class=\"ds-markdown-paragraph\">4.结束语</h1>\n<p>这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！</p>\n<p>另外，博主出新书了《<span style=\"color: rgba(255, 0, 0, 1);\"><strong><a href=\"https://item.jd.com/14421833.html\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(255, 0, 0, 1);\">Hadoop与Spark大数据全景解析</span></a></strong></span>》、同时已出版的《<strong><span style=\"color: rgba(0, 0, 255, 1);\"><a href=\"https://item.jd.com/14699434.html\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">深入理解Hive</span></a></span></strong>》、《<span style=\"color: rgba(0, 0, 255, 1);\"><strong><a href=\"https://item.jd.com/12455361.html\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">Kafka并不难学</span></a></strong></span>》和《<span style=\"color: rgba(0, 0, 255, 1);\"><strong><a href=\"https://item.jd.com/12371763.html\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">Hadoop大数据挖掘从入门到进阶实战</span></a></strong></span>》也可以和新书配套使用，喜欢的朋友或同学， 可以<span style=\"color: rgba(255, 0, 0, 1);\"><strong>在公告栏那里点击购买链接购买博主的书</strong></span>进行学习，在此感谢大家的支持。关注下面公众号，根据提示，可免费获取书籍的教学视频。</p>\n</div>\n<div id=\"MySignature\">\n    <div>\n<b class=\"b1\"></b><b class=\"b2 d1\"></b><b class=\"b3 d1\"></b><b class=\"b4 d1\"></b>\n<div class=\"b d1 k\">  \n联系方式：\n<br />\n邮箱：smartloli.org@gmail.com\n<br />\n<strong style=\"color: green;\">QQ群（Hive与AI实战【新群】）：935396818</strong>\n<br />\nQQ群（Hadoop - 交流社区1）：424769183\n<br />\nQQ群（Kafka并不难学）：825943084\n<br />\n温馨提示：请大家加群的时候写上加群理由（姓名＋公司/学校），方便管理员审核，谢谢！\n<br />\n<h3>热爱生活，享受编程，与君共勉！</h3>  \n</div>\n<b class=\"b4b d1\"></b><b class=\"b3b d1\"></b><b class=\"b2b d1\"></b><b class=\"b1b\"></b>\n</div>\n<br />\n<div>\n<b class=\"b1\"></b><b class=\"b2 d1\"></b><b class=\"b3 d1\"></b><b class=\"b4 d1\"></b>\n<div class=\"b d1 k\">\n<h3>公众号：</h3>\n<h3><img src=\"https://www.cnblogs.com/images/cnblogs_com/smartloli/1324636/t_qr.png\" style=\"width: 8%; margin-left: 10px;\" /></h3>\n</div>\n<b class=\"b4b d1\"></b><b class=\"b3b d1\"></b><b class=\"b2b d1\"></b><b class=\"b1b\"></b>\n</div>\n<br />\n<div>\n<b class=\"b1\"></b><b class=\"b2 d1\"></b><b class=\"b3 d1\"></b><b class=\"b4 d1\"></b>\n<div class=\"b d1 k\">\n<h3>作者：哥不是小萝莉 ［<a href=\"http://www.kafka-eagle.org/\" style=\"color: green;\" target=\"_blank\">关于我</a>］［<a href=\"http://www.cnblogs.com/smartloli/p/4241701.html\" style=\"color: green;\" target=\"_blank\">犒赏</a>］</h3>\n<h3>出处：<a href=\"http://www.cnblogs.com/smartloli/\" style=\"color: green;\" target=\"_blank\">http://www.cnblogs.com/smartloli/</a></h3>\n<h3>转载请注明出处，谢谢合作！</h3>\n</div>\n<b class=\"b4b d1\"></b><b class=\"b3b d1\"></b><b class=\"b2b d1\"></b><b class=\"b1b\"></b>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 22:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/smartloli\">哥不是小萝莉</a>&nbsp;\n阅读(<span id=\"post_view_count\">62</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "规划中主要使用的地图类型",
      "link": "https://www.cnblogs.com/zylyehuo/p/19419173",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zylyehuo/p/19419173\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 20:07\">\n    <span>规划中主要使用的地图类型</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>博客地址：<a href=\"https://www.cnblogs.com/zylyehuo/\" target=\"_blank\">https://www.cnblogs.com/zylyehuo/</a></p>\n</blockquote>\n<h1 id=\"occupancy-grid-map\">Occupancy Grid Map</h1>\n<blockquote>\n<p>【占据栅格地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1GzwderECF/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">移动机器人运动规划-第一章(运动规划介绍与地图构建)-第三节(地图构建方法-Occupancy Grid Map)</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV14C4y1r7Jd/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">自动驾驶中的Occupancy Grid占用栅格算法</a></p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230091555060-1199064499.png\" /></p>\n<ul>\n<li>基于贝叶斯公式</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092048607-315558262.png\" /></p>\n<ul>\n<li>基于马尔科夫假设（当前的概率与之前的概率是独立的）</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092203011-2028367547.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092225738-123828824.png\" /></p>\n<ul>\n<li>发现存在相同项</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092347064-1157737378.png\" /></p>\n<ul>\n<li>将两个概率进行相除，约去相同项</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092755566-498805078.png\" /></p>\n<ul>\n<li>利用 log 函数，分离出先验状态</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093031164-242106556.png\" /></p>\n<ul>\n<li>还剩下“逆传感器模型”部分【不直观】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093249678-366631429.png\" /></p>\n<ul>\n<li>再利用贝叶斯公式，将“逆传感器模型”转换为“传感器模型”【基于当前栅格地图的状态，得到的这一次观测值应该是0还是1的概率】，发现又出现相同项</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093716424-1872441123.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093825914-1423272760.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094001016-1041041406.png\" /></p>\n<ul>\n<li>假设“传感器模型”是个定值【基于观测的更新方式】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094259734-1484359303.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094533636-1069601382.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094914148-745996427.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095200901-845289928.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095233736-1331029782.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095347220-253112120.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095358663-165236316.png\" /></p>\n<ul>\n<li>利用滚动的 Occupancy Grid Map，解决“大地图”问题</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095538388-1548681780.png\" /></p>\n<h1 id=\"tsdf\">TSDF</h1>\n<blockquote>\n<p>(Truncated Signed Distance Field)【截断符号距离场】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/personalrobotics/OpenChisel\" rel=\"noopener nofollow\" target=\"_blank\">An open-source version of the Chisel chunked TSDF library.</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1Xi4y1471W/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">运动规划之 TSDF map</a></p>\n</blockquote>\n<ul>\n<li>障碍物外面的值为正值，障碍物外面的值为负值</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230151947608-384612791.png\" /></p>\n<h1 id=\"esdf\">ESDF</h1>\n<blockquote>\n<p>(Euclidean Signed Distance Field)【欧几里得符号距离场】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1Hnwde9EFc?spm_id_from=333.788.player.switch&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651&amp;trackid=web_related_0.router-related-2206419-gx8f2.1767056746104.238\" rel=\"noopener nofollow\" target=\"_blank\">移动机器人运动规划-第一章(运动规划介绍与地图构建)-第三节(地图构建方法-ESDF)</a></p>\n</blockquote>\n<ul>\n<li>“一层”的是 ESDF，上面的小栅格是 Occupancy Grid Map</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095632105-2084501764.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230100013176-744146623.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230100121591-1498147498.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230100151782-1360282382.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230101513785-573529793.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135055798-1520530407.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135316095-806542410.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135735490-663923292.png\" /></p>\n<ul>\n<li>仅针对一维的伪代码</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135828974-1891255415.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230140300707-708995518.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230140520538-65060715.png\" /></p>\n<ul>\n<li>对于二维的情况，就是固定 x，根据不同的 y 求解到达障碍物的最小距离</li>\n<li>以第一列为例</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230140734954-316583447.png\" /></p>\n<ul>\n<li>以第二列为例（没有障碍物的情况，则每个位置的值都为 ∞）</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141116066-773952293.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141241727-845739716.png\" /></p>\n<ul>\n<li>接着固定 y，根据不同的 x 求解到达障碍物的最小距离</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141744667-376666185.png\" /></p>\n<ul>\n<li>以下面三行为例</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141817043-1907659702.png\" /></p>\n<ul>\n<li>对于第一个格子，x=1，选取【这个格子到别的格子的距离 + 别的格子里面的“值”】最小的结果</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230142536264-839975597.png\" /></p>\n<ul>\n<li>对于第二个格子，x=2</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230142732894-2092955561.png\" /></p>\n<ul>\n<li>利用两次“一维”的求解，获得二维的结果【三维类似】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230142837572-2122723745.png\" /></p>\n<ul>\n<li>障碍物里面存放的值的意义：到最近的 free 的栅格的距离，同时这个值放的是负值</li>\n<li>先将障碍物和 free 栅格进行翻转，然后进行计算</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143237644-1636509800.png\" /></p>\n<ul>\n<li>将计算后的值添加上负号</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143311745-18788185.png\" /></p>\n<ul>\n<li>再和原来的场进行叠加</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143344921-1946627573.png\" /></p>\n<ul>\n<li>先沿着 z 轴算，再沿着 y 轴算，最后沿着 x 轴算</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143458985-408992367.png\" /></p>\n<ul>\n<li>进行翻转操作【反向 ESDF】，计算障碍物内部的值【先沿着 z 轴算，再沿着 y 轴算，最后沿着 x 轴算】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143811950-1709618967.png\" /></p>\n<ul>\n<li>最后进行叠加</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143910379-1892087086.png\" /></p>\n<ul>\n<li>对于当前位置不在栅格中心的情况，利用插值进行解决</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230144224352-5167244.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230144333713-2132197098.png\" /></p>\n<ul>\n<li>ESDF 地图梯度的计算</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230144605924-1620303920.png\" /></p>\n<h1 id=\"gaussian-map\">Gaussian Map</h1>\n<h2 id=\"3dgs\">3DGS</h2>\n<blockquote>\n<p>(3D Gaussian Splatting)【3D 高斯溅射地图 / 前沿视觉地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/7833648056\" rel=\"noopener nofollow\" target=\"_blank\">3D Gaussian Splatting算法及其实现细节</a></p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://arxiv.org/pdf/2308.04079\" rel=\"noopener nofollow\" target=\"_blank\">3D Gaussian Splatting for Real-Time Radiance Field Rendering</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/graphdeco-inria/gaussian-splatting\" rel=\"noopener nofollow\" target=\"_blank\">代码</a></p>\n</blockquote>\n<h2 id=\"gp-map\">GP Map</h2>\n<blockquote>\n<p>(Gaussian Process Map)【高斯过程地图 / 概率连续地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/2751630763\" rel=\"noopener nofollow\" target=\"_blank\">什么是高斯过程（Gaussian Processes, GP）</a></p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://fabioramos.github.io/Publications_files/Simon_ISER2014.pdf\" rel=\"noopener nofollow\" target=\"_blank\">Gaussian process occupancy maps for dynamic environments</a></p>\n</blockquote>\n<h2 id=\"gmm\">GMM</h2>\n<blockquote>\n<p>(Gaussian Mixture Models)【高斯混合模型地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/151671154\" rel=\"noopener nofollow\" target=\"_blank\">如何通俗的理解高斯混合模型（Gaussian Mixture Models））</a></p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://zhuanlan.zhihu.com/p/151671154\" rel=\"noopener nofollow\" target=\"_blank\">Gaussian Mixture Models</a></p>\n</blockquote>\n<h1 id=\"nerf\">NeRF</h1>\n<blockquote>\n<p>(Neural Radiance Fields)【神经辐射场】</p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://arxiv.org/pdf/2003.08934\" rel=\"noopener nofollow\" target=\"_blank\">Representing Scenes as Neural Radiance Fields for View Synthesis</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/bmild/nerf\" rel=\"noopener nofollow\" target=\"_blank\">代码</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.matthewtancik.com/nerf\" rel=\"noopener nofollow\" target=\"_blank\">官网</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/jiaoyangwm/article/details/133804918\" rel=\"noopener nofollow\" target=\"_blank\">NeRF 首篇经典论文介绍（ECCV2020）</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1CC411V7oq/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">【较真系列】讲人话-NeRF全解（原理+代码+公式）</a></p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230152646680-808967645.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153232330-8093872.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153304058-1966233738.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153458012-810246374.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153627018-1090646223.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153701724-2140345591.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153801636-51891141.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153921564-421511957.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154119566-421233492.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154404671-1853328831.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154452220-1182229856.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154836620-1158102823.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155102446-1293304585.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155330237-169551366.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155631408-2064100778.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155728157-250263865.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155820644-869689816.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160626120-96920975.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160754127-1769142361.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160851194-233434887.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160937600-1841363.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161047152-122034867.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161318891-1616916806.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161437134-1545984944.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161723359-1462419215.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161925557-1973428927.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230174118921-38385255.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230174243818-575765853.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175016337-1136716337.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175052111-1485817129.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175157993-2141132230.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175345585-750664154.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175425714-1466271787.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175528313-2072746571.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175732929-1433112194.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175830148-1190162908.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 20:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zylyehuo\">zylyehuo</a>&nbsp;\n阅读(<span id=\"post_view_count\">26</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "解密Prompt系列67. 智能体的经济学：从架构选型到工具预算",
      "link": "https://www.cnblogs.com/gogoSandy/p/19425501",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/gogoSandy/p/19425501\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 10:57\">\n    <span>解密Prompt系列67. 智能体的经济学：从架构选型到工具预算</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"解密Prompt系列67. 智能体的经济学：从架构选型到工具预算\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1326688/202512/1326688-20251231105544313-938356706.png\" />\n        随着模型能力的提升，工业界开始反思：盲目增加智能体、盲目增加工具调用次数真的能“大力出奇迹”吗？本文串联了两篇Google论文，从宏观的架构选择到微观的工具预算感知，探讨如何科学地构建高效的Agent系统。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>导读：2025年是智能体爆发的一年。然而，随着模型能力的提升，工业界开始反思：盲目增加智能体、盲目增加工具调用次数真的能“大力出奇迹”吗？本文串联了两篇Google论文，从宏观的架构选择到微观的工具预算感知，探讨如何科学地构建高效的Agent系统。</p>\n<h2 id=\"part-1-宏观选型多智能体的科学定律\">Part 1. 宏观选型：多智能体的科学定律</h2>\n<blockquote>\n<ul>\n<li>Towards a Science of Scaling Agent Systems</li>\n</ul>\n</blockquote>\n<p>最近在很多分享交流上对于究竟使用单智能体vs多智能体有很多不同的声音。24年其实以多智能体架构为主，但是随着模型能力的提升，不少论文发现，多智能体带来的边际收益在递减，同时多智能体之间的沟通成本和信息碎片化，导致在部分任务上甚至不如单智能体的效果。</p>\n<p>而Google这篇论文没有停留在理论争辩，而是通过严谨的控制变量实验，揭示了架构选择与任务特征之间的深层数学关系。论文试图回答：</p>\n<ul>\n<li>影响智能体系统表现的决定性变量是什么？</li>\n<li>智能体间的“沟通”何时是蜜糖，何时是砒霜？</li>\n<li>是否存在一个通用的“最优架构”？</li>\n</ul>\n<h3 id=\"实验设计解耦与控制\">实验设计：解耦与控制</h3>\n<p>为了得出上述结论，作者设计了一个非常严谨的控制变量实验。以下是其具体的实验步骤：<br />\n<strong>步骤一：明确的Agentic任务范围</strong></p>\n<p>论文明确剔除了所有非智能体任务，毕竟多智能体隐式带来的Ensenble等推理效果很容易在HumanEval等任务上带来提升。这里智能体任务包含三个特点</p>\n<ul>\n<li>多步和环境交互</li>\n<li>基于部分观测的反复信息收集</li>\n<li>基于反馈的策略优化</li>\n</ul>\n<p>缺少以上条件的任务，其实都是在测试模型自身的推理能力，而非智能体在<strong>动态非确定环境性下</strong>工具调用和多步动态规划能力。基于以上条件论文选择了下面四个测试实验</p>\n<ul>\n<li><strong>Finance-Agent</strong>: 高可分解性，需多视角数据聚合。</li>\n<li><strong>BrowseComp-Plus</strong>: 动态网页浏览，具有高熵搜索空间 。</li>\n<li><strong>PlanCraft</strong>: 基于《我的世界》GUI界面的合成数据集，包含时空数据的规划任务，具有严格的序列依赖性。</li>\n<li><strong>Workbench</strong>: 评估业务流程自动化，涉及确定的代码执行和工具使用，例如发邮件、安排会议。</li>\n</ul>\n<p><strong>步骤二：梳理智能体架构分类</strong><br />\n为了解耦“多智能体”这个概念，作者将其拆解为 5 种标准架构进行对比：</p>\n<ul>\n<li>SAS：单智能体架构</li>\n<li>MAS：多智能体架构，论文按照信息流动方式和结构分成以下几类\n<ul>\n<li>Independent：所有智能体之间没有沟通，各干各个的，等同于Ensemble模型</li>\n<li>Centralized：中心化模式，Cluade称之为Orchestrator，主智能体负责规划分发任务给子智能体并汇总信息，整个信息流动中存在主导者和信息瓶颈。</li>\n<li>DeCentralized：去中心化，所有智能体All to All通信，论文使用的是辩论模式，其实也有也有像圆桌讨论、多角色讨论等其他模式，只不过是智能体的角色和所站论点的差异。</li>\n<li>Hybrid：兼顾中心规划和子智能体的横向沟通的混合模式</li>\n</ul>\n</li>\n</ul>\n<p>更具体的不同智能体架构的交互深度、沟通复杂度如下</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><strong>步骤三：变量控制</strong><br />\n所有架构使用完全相同的工具、指令和任务描述，和相同的总推理Token预算。所以会存在MAS下子智能体越多，那每个子智能体分配到的轮次就更少。</p>\n<h3 id=\"实验结论和分析\">实验结论和分析</h3>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>如上图是不同智能体结构在不同任务上的实验效果，实验结果并未给出一个“万能架构”，反而揭示了<strong>信息流结构（Information Flow Structure）</strong>才是决定架构优劣的根本。</p>\n<h4 id=\"多智能体收益高度依赖任务结构不存在永远最优的智能体架构\"><strong>多智能体收益高度依赖任务结构，不存在永远最优的智能体架构</strong></h4>\n<ul>\n<li><strong>正收益</strong>： 在可分解、并行的任务上，例如需要多角度信息收集的Finance Agent任务上，MAS 表现出色，中心化架构（Centralized）比单体（SAS）提升了 80.9% 。</li>\n<li><strong>微收益</strong>： 在动态搜索任务（BrowseComp-Plus）上，去中心化架构仅带来 9.2% 的提升 。</li>\n<li><strong>负收益</strong>： 在强序列依赖的规划任务（PlanCraft）上，所有 MAS 架构都导致性能下降，降幅在 39% 到 70% 之间 。</li>\n</ul>\n<h4 id=\"为什么多智能体在序列任务重失效\"><strong>为什么多智能体在序列任务重失效？</strong></h4>\n<p>作为算法工程师，我们需要透过现象看本质：<strong>这是Context Fragmentation（上下文碎片化）带来的必然结果。</strong></p>\n<ol>\n<li><strong>高可分解性任务</strong>：类比Finance Agent，以及单段落的大纲写作等任务</li>\n</ol>\n<p>这类任务的信息流特征是<strong>正交且独立</strong>，所以<br />\n<span class=\"math inline\">\\(P(task2|task1)\\sim P(task2)\\)</span>，也意味着子智能体之前几乎无需沟通交流或者状态同步，因此中心化结构能带来并发效率提升，以及覆盖更广的搜索空间。</p>\n<ol start=\"2\">\n<li><strong>强序列依赖任务</strong>：类比PlanCraft，以及Coding等任务</li>\n</ol>\n<p>这类任务的信息流特征是<strong>马尔科夫或者更长程的序列依赖</strong>，所以<span class=\"math inline\">\\(State_2=f(State_1, Action_1)\\)</span>，意味着每个智能体都要能获取前面智能体任务执行的全部输出以及隐含假设，才能继续执行。<strong>依赖全面完整的信息传递和大量的信息传输交流。而这正是SAS单智能体的模式</strong></p>\n<h4 id=\"重要的scaling法则\">重要的Scaling法则</h4>\n<p>同时论文还尝试进一步归因除架构之外的其他影响因素，包括</p>\n<ul>\n<li>\n<p><strong>工具-协作权衡（Tool-Coordination Trade-off）</strong>： 这是一个强负相关因素 (<span class=\"math inline\">\\(\\beta=-0.330\\)</span>)。任务涉及的工具越多（Tool-heavy），多智能体的通信开销（Overhead）就越严重，导致效率骤降。一个可能原因在于工具越多，复杂的tool schema会和复杂的协作指令抢夺模型有限的注意力空间（类似注意力抢占在多轮对话vs工具调用中也能观测到）。</p>\n</li>\n<li>\n<p><strong>能力饱和效应（Capability Saturation）</strong>： 当单体 Agent 的基线准确率已经超过 45% 时，增加更多 Agent 反而会因为协调成本带来负收益。因为高水平模型在同一任务上的一致性较高，而额外的沟通返回会引入语义漂移（类似传话过程中的传递误差）。除非是多智能体独立查询不同数据独立完成任务，否则只是推理协作提升不大。（所以本质还是信息流动的问题）</p>\n</li>\n<li>\n<p><strong>架构相关的错误放大（Error Amplification）</strong>： Independent架构会将错误放大 17.2倍（因为缺乏错误验证机制）,而中心化架构能显著通过中心的规划智能体作为verifier对所有子智能体的返回信息尽心验证提升系统鲁棒性。</p>\n</li>\n</ul>\n<p>所以整体上在智能体设计上几个点很明确，第一明确你任务的信息流结构、再评估单智能体的效果、最后评估你工具的复杂度再考虑使用什么类型的多智能体结构。</p>\n<h2 id=\"part-2-微观执行单智能体的预算感知\">Part 2. 微观执行：单智能体的预算感知</h2>\n<blockquote>\n<ul>\n<li>Budget aware Tool-USE Effective Agent Scaling</li>\n</ul>\n</blockquote>\n<p>聊完多智能体选型，接下来我们看下如何最大化单智能体在有限工具调用下的执行效果。论文揭示了实际应用中的一个现实问题，既我们不会无限等待模型去循环往复的调用工具，我们依旧是在追寻<strong>效率和效果的帕累托最优</strong>。</p>\n<p><strong>那Agent执行，本质就变成了一个条件优化问题，如何在有限的工具调用次数下，最大化智能体的执行效果。</strong></p>\n<h3 id=\"21-核心痛点盲目的hard-stop\">2.1 核心痛点：盲目的Hard Stop</h3>\n<p>现有Agent框架通常设置 max_steps（iteration）=XX 作为兜底，来强制截断模型超长的工具调用链路，但 Agent 本身不知道自己还剩多少次机会。这也导致简单的增加 step 限制并不能线性提升效果，因为 Agent 不知道自己“钱（Budget）”还剩多少，在实际任务执行时我们往往观测到<strong>两种失败模式</strong></p>\n<ul>\n<li><strong>Agent过早放弃没有收集到完整信息</strong></li>\n<li><strong>Agent在错误，或者很难成功的道路上反复尝试导致资源耗尽</strong></li>\n</ul>\n<h3 id=\"22-解决方案level1---显式感知\">2.2 解决方案Level1 - 显式感知</h3>\n<p>作者提出的 BATS (Budget Aware Test-time Scaling) 框架，本质上是在 Prompt Engineering 和控制流层面引入了模型可感知的<strong>预算条件约束</strong>。</p>\n<p>指令如下，论文在Prompt中动态加入了工具调用Budget，在每轮模型进行工具调用时，显式告知模型，当前可用的工具调用次数，以及针对不同的预算剩余，模型应该如何动态调整自己的工具调用策略。</p>\n<pre><code class=\"language-markdown\">## Budget\nYou have two independent budgets:\n- Query Budget (for search)\n- URL Budget (for browse)\nEach string in 'query' or 'url' consumes 1 unit respectively.\nAfter each &lt;tool_response&gt;, a &lt;budget&gt; tag shows remaining units.\nYou must ADAPT your strategy dynamically to the current budget state.\n### HIGH Budget (&gt;=70% remaining)\n- Search: 3-5 diverse queries in one batch.\n- Browse: up to 2-3 high-value URLs.\n- Goal: Broad exploration, build context fast.\n### MEDIUM Budget (30%-70%)\n- Search: 2-3 precise, refined queries per cycle.\n- Browse: 1-2 URLs that close key knowledge gaps.\n- Goal: Converge; eliminate uncertainty efficiently.\n### LOW Budget (10%-30%)\n- Search: 1 tightly focused query.\n- Browse: at most 1 most promising URL.\n- Goal: Verify a single critical fact or finalize answer.\n### CRITICAL (&lt;10% remaining or 0 in one budget)\n- Avoid using the depleted tool.\n- Only perform 1 minimal-cost query or browse if absolutely essential.\n- If uncertainty remains and no tool use is possible, output &lt;answer&gt;None&lt;/answer&gt;.\n</code></pre>\n<p>论文使用多个模型，在多个任务上对比了单纯使用ReACT，和加入Budget的ReACT的效果。</p>\n<ol>\n<li>\n<p>相同预算下，Budget Tracker可以实现更高的任务完成准确率<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>相同的准确率下，Budget Tracker的工具调用轮次更低<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>加入Budget Tracker后，提升工具调用次数可以更加持续地带来效果提升。换言之引入Budget Tracker可以提升智能体在单任务的执行上限。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n</li>\n</ol>\n<h3 id=\"解决方案level2---策略使用\">解决方案Level2 - 策略使用</h3>\n<p>Budget Tracker只是第一步，它负责“报账”让模型了解自己还有多少次机会，剩余全靠模型自己发挥，而再进一步我们可以系统告知模型如何利用这笔预算来规划复杂路径，包括如何优化Planning和Verification的效果。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>论文选用的智能体架构，是两个单线程的智能体，第一个智能体Planner负责规划，并根据规划步骤逐步调用工具回答并给出答案, 第二个整体Verification负责对第一个智能体给出的答案进行校验，并判断是否需要答案已经合格，后者需要深入挖掘、或者更换搜索方向。</p>\n<p>我们就单看下和Plan模块的结合，Budget预算对这个模块的影响包括</p>\n<ol>\n<li>Exploration： 预算决定了搜索树的宽度。预算足 <span class=\"math inline\">\\(\\rightarrow\\)</span> 制定多分支探索计划；预算紧 <span class=\"math inline\">\\(\\rightarrow\\)</span> 制定单点验证计划</li>\n<li>Verification：预算决定了回溯的深度。预算足 <span class=\"math inline\">\\(\\rightarrow\\)</span> 深入挖掘；预算紧  <span class=\"math inline\">\\(\\rightarrow\\)</span> 立刻转换方向或者直接输出答案</li>\n</ol>\n<p>具体规划相关的指令如下：</p>\n<pre><code class=\"language-markdown\">## About questions\nQuestions contain two types of constraints: exploration and verification.\n* Exploration: Broad, core requirements (e.g., birthday, profession). Use these for initial\nsearches to surface candidates. You may combine 1-2 to form stronger queries.\n* Verification: Narrow, specific details. Apply these only after you have candidates, to\nconfirm or filter them. Never begin with verification constraints.\nStart with exploration queries, then use verification to validate the results.\n## About planning\nMaintain a tree-structured checklist of actionable steps (each may require several tool calls).\n- Mark each step with its status: [ ] pending, [x] done, [!] failed, [~] partial.\n- Use numbered branches (1.1, 1.2) to represent alternative paths or candidate leads.\n- Log resource usage after execution: (Query=#, URL=#).\n- Keep all executed steps, never delete them, retain history to avoid repeats.\n- Update dynamically as you reason and gather info, adding or revising steps as needed.\n- Always consider current and remaining budget when updating the plan.\n</code></pre>\n<p>引入以上指令和Budget Tracker后，会观测到模型在不同预算前提下做出的如下行为改变。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>再进一步感觉可以把不同Latency要求场景中，对于模型尽量快执行完成、或者尽量更全收集信息等差异化约束条件，以及不同工具在不同场景的使用优先级打分等都作为模型可以动态感知信息注入到模型上文中，把当前RL Agent训练的思路都显式注入到推理上文中，是个值得尝试的思路。</p>\n<p>想看更全的大模型论文·微调预训练数据·开源框架·AIGC应用 &gt;&gt; <a href=\"https://github.com/DSXiangLi/DecryptPrompt\" rel=\"noopener nofollow\" target=\"_blank\">DecryPrompt</a></p>\n<hr />\n<p>2025年最后一天了，唠2块钱的，高烧已经烧了三天烧的一时不知今夕是何夕，似乎每次项目一上线，人一泄劲免疫力就跟着出走，睁眼一看已经是31号了，趁着早上烧还没起来抓紧把年底最后一篇博客传了。</p>\n<p><em>2026年祝自己和爸爸妈妈都身体贲棒，吃嘛嘛香，也祝大家明年都健健康康，无病无灾，今年就许了这一个愿望，希望会成真哦</em>~</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 10:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/gogoSandy\">风雨中的小七</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[微服务进阶场景实战] 微服务痛点 - 用实际经历告诉你它有多少陷阱",
      "link": "https://www.cnblogs.com/yhup/p/19425482",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yhup/p/19425482\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 10:54\">\n    <span>[微服务进阶场景实战] 微服务痛点 - 用实际经历告诉你它有多少陷阱</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"[微服务进阶场景实战] 微服务痛点 - 用实际经历告诉你它有多少陷阱\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105243692-1476815581.png\" />\n        本文深入探讨了微服务架构的核心概念与实践挑战。通过对比单体架构与微服务架构在新零售系统中的实现差异，揭示了微服务在精准扩展、独立发布、技术异构和持续优化等方面的优势。同时重点剖析了微服务落地的四大痛点：服务边界划分困难（受康威定律支配）、服务粒度失控、系统全貌难以掌握以及代码重复问题。文章指出微服务拆分本质上是一个需要平衡技术、业务和组织因素的持续治理过程，而非纯粹的技术决策。这些见解为后续微服务实战提供了重要的理论基础和风险预判。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>好了各位，热身结束！前面的内容我们主要梳理了基于那些“流行组件”的微服务常见玩法。既然已经有了不少成熟的开源工具，咱们的重点就在于弄清它们背后的原理，用起来心里才有底。</p>\n<p>从这一篇开始，我们要进入一个新阶段——<strong>微服务进阶场景实战</strong>。在真正深入具体业务场景之前，咱们不妨先退一步，聊聊更根本的问题：<strong>微服务到底是怎么回事，它究竟有什么优势，又会带来哪些挑战？</strong> 理解这些，后续的实战才不至于只见树木不见森林。</p>\n<h1 id=\"1-单体式架构vs微服务架构\">1 单体式架构VS微服务架构</h1>\n<h3 id=\"单体式架构-vs-微服务架构一个实战对比\"><strong>单体式架构 vs 微服务架构：一个实战对比</strong></h3>\n<p>为了清晰区分这两种架构模式，我们不妨从一个具体的新零售系统案例入手。假设某门店（涵盖自营店和加盟店）需要研发一套新零售系统，核心功能包括订单、营销、商品、门店、会员及加盟商管理等模块。在搭建新零售系统架构时，如果使用单体式架构进行设计，它的架构如图所示。<br />\n<img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133196-1930390780.jpg\" /></p>\n<p>若采用单体式架构，所有功能模块的代码会被打包进同一个应用程序中，数据也集中存储在单一数据库内。这种设计初期看似省事，但随着业务逻辑逐渐复杂，任何微小的代码改动都可能像触发连锁反应一样，导致整个系统意外崩溃——老实说，这类情况在不少开发团队中已是“家常便饭”。尽管每次故障后都会进行复盘，引入代码审查、风险评估、方案评审等流程，但问题往往周而复始。最终，为了控制风险，发布流程越来越冗长，迭代速度不断放缓，甚至陷入停滞。相比之下，<strong>那些采用更灵活架构的团队，其功能交付效率可能高出十倍以上。</strong></p>\n<p>要摆脱这种困境，核心举措是进行架构拆分：将相互耦合的模块分离，减少彼此干扰。于是，微服务架构登场。如上图所示，原有的单体应用被拆分为六个独立服务，分别处理订单、营销、商品、门店、会员及加盟商等业务逻辑，且每个服务拥有自己的专属数据库。<br />\n<img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133255-1507375404.jpg\" /></p>\n<p>如果服务间存在依赖关系，可通过定义<strong>清晰的接口、异步消息、共享缓存或数据同步</strong>等方式进行协作——这样既保持了服务的自治性，又确保了系统的整体连通性。</p>\n<h1 id=\"2-微服务的好处\">2 微服务的好处</h1>\n<p>将庞大的单体应用拆分为独立的微服务，并非为了追赶技术潮流。这一转变能为我们带来以下几个关键层面的显著提升：</p>\n<p><strong>1. 精准扩展，成本可控</strong><br />\n当某个业务模块（例如“秒杀促销”服务）面临流量洪峰时，在单体架构中你不得不对整个庞大应用进行扩容，资源浪费严重。而在微服务架构下，你可以<strong>精准地将资源“弹药”倾斜给压力最大的服务</strong>，仅需为该服务单独增加节点实例即可。这就像酒店的中央空调与独立空调——独立调控显然更灵活、更经济。</p>\n<p><strong>2. 独立发布，高效协同</strong><br />\n单体架构下，任何微小的功能上线都需要全应用打包、整体部署，迫使所有团队同步进行集成测试与上线协调，流程笨重。微服务化之后，每个服务团队在<strong>确保对外接口（契约）稳定</strong>的前提下，可以独立开发、测试与部署自己的服务。营销团队可以一天发布多次，而核心订单服务则按自身节奏稳步迭代，彼此互不阻塞，极大地提升了交付效率。</p>\n<p><strong>3. 技术异构，因“服”制宜</strong><br />\n在单体中，技术栈通常被强制统一。微服务则允许每个服务根据其<strong>特定的业务需求和技术特点，选择最合适的编程语言、框架乃至数据存储技术</strong>。例如，用Python处理数据分析服务，用Go编写高性能的网关，用Node.js构建实时推送服务。只要服务间通过标准协议（如HTTP/RPC）通信，其内部实现技术可以自主决策。</p>\n<p><strong>4. 拥抱重构，持续优化</strong><br />\n单体应用内代码高度耦合，任何重构都如履薄冰，极易引发不可预知的副作用，导致开发者不敢对“祖传代码”动刀，技术债务不断累积。微服务通过<strong>清晰的边界隔离了变化的影响范围</strong>。现在，你可以<strong>从容地对单个服务进行内部重构或技术升级</strong>，只要接口行为不变，就不会波及整个系统。这为代码质量的持续改善和技术栈的渐进式演进提供了坚实基础。</p>\n<hr />\n<h1 id=\"3-微服务的痛点\">3. 微服务的痛点</h1>\n<p>在产品研发中，引入一项技术来解决特定问题往往不难；真正的挑战在于能否<strong>精准评估并管理其伴随而来的复杂性与风险</strong>。对于微服务架构而言，这一点尤为关键。本节将深入探讨微服务实践中的典型问题，这些内容无论对于架构设计还是技术面试，都具有很高的参考价值。</p>\n<h2 id=\"31-痛点服务的职责边界划分\">3.1 痛点：服务的职责边界划分</h2>\n<p>微服务架构的一大难题，在于难以对某些<strong>模糊的职责</strong>进行清晰界定——例如，一个特定的功能到底应该属于服务A还是服务B？这绝非单纯的技术决策，而常常演变为涉及多方因素的“公司级谜题”。为了便于理解，我们通过几个具体场景，看看服务的划分是如何在实践中变得错综复杂的。</p>\n<h3 id=\"基于核心数据所有权划分\">基于核心数据所有权划分</h3>\n<p>这是最直观的原则。例如，根据商品ID查询商品详情的接口，自然应归属于<strong>商品服务</strong>；获取某个用户的所有订单列表，则理应由<strong>订单服务</strong>提供。</p>\n<h3 id=\"与业务运营团队的职能对齐\">与业务运营团队的职能对齐</h3>\n<p>职责划分需考虑实际使用系统的业务团队。例如，“每个商品在每个门店的实时库存”应该放在商品服务还是门店服务？由于库存通常由各门店的运营人员直接管理和维护，因此将其划归<strong>门店服务</strong>在逻辑上更为顺畅。</p>\n<h3 id=\"与产品管理职责对齐\">与产品管理职责对齐</h3>\n<p>产品团队的职责范围也会影响划分。假设一个新需求要求实现“特定门店只能销售特定商品”的功能。这个功能应该放在门店服务还是商品服务？这时，往往取决于该需求由哪条业务线的产品经理主导。如果是商品产品经理负责，就很可能落地到<strong>商品服务</strong>；反之则归入<strong>门店服务</strong>。</p>\n<h3 id=\"受项目工期与资源制约\">受项目工期与资源制约：</h3>\n<p>接续上面的例子，假设根据产品归属原则，该功能应划入门店服务。但可能出现这种情况：门店服务开发团队当前负载已满，无法排期；而商品服务团队恰好有空余资源，但他们并不熟悉门店服务的业务逻辑。为了满足业务方紧急的上线要求（比如两周内必须完成），妥协方案可能就是将此功能交由<strong>商品服务</strong>临时实现。尽管从设计上看这并不“优雅”或通用，但<strong>业务交付的压力常常会压倒架构的纯粹性</strong>。</p>\n<p>然而，所有因素中，最具决定性、也最难以协调的往往是第五点。</p>\n<h3 id=\"与组织架构强相关--康威定律的支配\">与组织架构强相关 — 康威定律的支配</h3>\n<p>这一点至关重要。程序员梅尔·康威在1967年提出的康威定律精辟指出：“设计系统的组织，其产生的设计等同于组织之间的沟通结构。”简而言之，<strong>系统的技术边界最终会无可避免地映射出公司的组织与权责边界</strong>。这不是一个技术选择，而是一个社会学事实。</p>\n<p><strong>一个来自“进销存供应链系统”的典型案例：</strong><br />\n<img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133184-1718280355.jpg\" /></p>\n<p>该系统与前述新零售系统紧密集成。最初，<strong>门店的商品库存</strong>管理职责属于新零售业务团队（其产研团队对接门店运营），而<strong>中央仓库库存</strong>管理职责属于独立的供应链团队，技术架构清晰反映了这一组织划分。</p>\n<p>后来，公司进行战略调整，领导决定将<strong>门店商品库存的管理职责也划归供应链总监统一负责</strong>。这一组织架构的变动，立即引发了技术架构的连锁反应：原来由新零售产研负责的门店库存需求，现在全部转移给供应链产研团队。</p>\n<p>于是，符合康威定律的驱动逻辑开始运行：供应链产研团队有充分的动机（包括绩效与成果导向）推动将门店库存的管理逻辑，从原先新零售体系下的服务中剥离，并迁移整合到他们自己控制的<strong>供应链库存服务</strong>中。因为这样最符合他们团队的责任边界和考核目标，尽管从纯粹的业务逻辑上看，库存管理似乎可以被拆分到不同上下文。</p>\n<p>这个案例深刻地揭示：<strong><u>微服务边界的划分远非纯粹的技术决策，它最深层的驱动力往往来自于业务归属、资源状况、上线压力，尤其是组织的结构与权责划分。</u></strong> 这也解释了为什么寻找放之四海而皆准的“服务划分原则”如此困难——它本质上是一个需要持续权衡、并随组织动态演进的治理过程。</p>\n<h2 id=\"32-痛点微服务粒度拆分\">3.2 痛点：微服务粒度拆分</h2>\n<p>微服务的另一个显著痛点是：<strong>服务数量容易失控</strong>。我们继续通过加盟商功能的演进案例来剖析这个问题。</p>\n<p>起初，新零售系统仅为加盟商提供登录和信息管理功能，这些功能完全可以容纳在一个单一服务中，简单直接。随着业务发展，加盟商的准入、开店、退出都涉及资金流转，因此必须引入财务功能（应收、应付、对账等）。随后，业务又扩展出加盟商员工管理、返点计算、子门店管理等一系列需求。</p>\n<p>此时，如果所有这些功能仍塞在单个“加盟商服务”里，显然已不合时宜。那么，<strong>拆分的时机和粒度应如何把握？</strong> 是在做财务功能时拆，还是在做员工管理时拆？这往往没有标准答案。</p>\n<p>一个常见的启动原则是：预估新功能的规模，如果它能构成一个需要3-4人持续维护的独立模块，就可能值得拆分为新服务。然而，一旦新服务被创建出来，其后续的修改成本通常不高，除非进行大规模重构。</p>\n<p>但现实往往偏离理想路径。为了避免开发人员闲置，公司会不断安排新功能开发。而开发者出于技术洁癖或明确工作边界的倾向，更乐意将相对独立的功能放入<strong>全新的专属服务</strong>中。于是，加盟商财务、员工管理、返点等功能可能纷纷独立成服。</p>\n<p><strong>绩效考核的隐形指挥棒加剧了这一问题。</strong> 开发人员的绩效难以量化，而“负责或创建的服务数量”却成了一个看似客观的指标。尽管公司不会正式将其设为KPI（否则数量必定激增），但在汇报工作时，提及自己维护了多个服务总会显得贡献突出。这种氛围一旦形成，同事们会潜意识里倾向于“造轮子”而非“修轮子”，人均维护5个以上微服务的局面可能悄然出现。</p>\n<p>后来，我们公司意识到了这个陷阱，并通过公开讨论和主动管控来抑制服务数量的无序增长，这取得了一定效果。但归根结底，<strong>“服务粒度多大合适？”本身就是一个没有确切答案的持续性治理难题。</strong></p>\n<h2 id=\"33-痛点没人知道系统整体架构的全貌\">3.3 痛点：没人知道系统整体架构的全貌</h2>\n<p>你是否经历过这样的场景：每隔一段时间，领导就会要求汇报各部门乃至全公司的微服务数量、每个服务的用途？随着服务总数突破几百个，汇报清单长得令人窒息。</p>\n<p>领导的抱怨随之而来：“系统已经复杂到没人能说清全貌了吗？出了问题，你们如何快速定位？” 而几位技术负责人可能面面相觑，内心os：“我连自己团队的完整服务列表都未必清楚。”</p>\n<p>在单体架构时代，理解整个系统的全貌虽不易，但仍是可能且必要的目标。而切换到微服务架构后，工程师们便放弃了掌握全局的企图，只深耕自己负责的“一亩三分地”，遇到问题再临时学习相关系统就好了。</p>\n<p>因此，<strong>“找不到一个能通晓所有微服务架构全貌的人”</strong>，成了微服务落地后一个普遍而真切的痛点。系统整体的可理解性与可维护性，在拆分为服务的那一刻起，就面临着持续性的挑战。</p>\n<h2 id=\"34-痛点重复代码多\">3.4 痛点：重复代码多</h2>\n<p>在单体架构中，公共代码抽取到统一的Common包中是天经地义的事。但在微服务世界里，代码复用之路往往布满荆棘。</p>\n<p>举个例子：A团队开发了一个优秀的日志自动埋点工具包。B团队得知后想引入，于是通过Maven依赖了该JAR包。但很快，B团队就遇到了JAR版本冲突——如果升级冲突的JAR，A团队原有的功能可能失效。为了快速解决问题，他们请求A团队进行兼容性适配。</p>\n<p>A团队为此专门发布了一个适配B团队环境的新版本JAR。然而，当C团队也想使用时，又遇到了全新的版本冲突问题。此时，A团队从投入产出比考量，已不愿再投入精力做新一轮兼容，干脆告知其他团队：“代码都在Git上，你们自己复制、修改吧。” 于是，同一段埋点逻辑，最终以多个略有差异的版本，散落在不同的微服务中。</p>\n<p>后续复盘时，大家认识到问题根源在于“依赖版本不统一”。一个旨在统一所有JAR版本的项目被立项，但第二天就因为紧急业务需求被搁置。此后，每次提起这个重要项目，总被更“紧急”的业务需求打断。大家逐渐明白：<strong>这件事的优先级永远无法高于直接业务需求，因为其投入产出比在短期内极不明确。</strong></p>\n<p>实际上，微服务之间存在一定重复代码或许是可以接受的成本。各部门通常会有自己的内部共享库，以实现部门内的代码复用。在实践中大家发现，<strong>维护这些有限的重复代码，其成本往往低于协调所有团队、统一版本、进行大规模重构所付出的巨大沟通与排期代价。</strong> 这成了微服务架构下一种无奈但务实的取舍。</p>\n<h2 id=\"35-痛点耗费更多服务器资源\">3.5 痛点：耗费更多服务器资源</h2>\n<p>有一个颇为典型的案例：一家小公司最初采用单体架构，整个系统平稳运行在5台服务器上。随着业务发展，团队深感系统耦合度太高，模块间干扰严重，于是决定进行架构演进，转向微服务。</p>\n<p>他们按功能模块将单体应用拆分成了6个独立的微服务。为确保高可用性，每个服务至少需部署2个实例，加上入口网关层部署2个节点，基础资源需求已增至14台。由于其中一个服务计算资源消耗较大，为保险起见又额外增加了一个节点。最终，<strong>服务器总数从5台跃升至15台</strong>。</p>\n<p>值得注意的是，在此期间业务流量并未增长，核心代码逻辑也基本未变，仅仅是架构拆分这一动作，就导致了基础设施成本的大幅上升，这在团队内部引发了讨论。有成员曾提出，能否通过“混合部署”来优化资源使用：例如在一台服务器上同时部署服务A和B，另一台上部署服务B和C，通过灵活编排来减少机器总数。<br />\n<img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133211-1757364366.jpg\" /></p>\n<p>但这个方案很快被搁置了。主要原因在于运维的简洁性：<strong>“一个服务对应专属节点”的模式，使得服务器可以直接以服务名命名，故障排查时一目了然。</strong> 如果采用混合部署，服务器角色将变得模糊，运维复杂度会显著增加。</p>\n<p>于是，一种在实践中常见的权衡出现了：团队倾向于接受“服务器资源相对廉价，多部署几台也无妨”的观点，暂时接受了更高的资源开销。事实上，这并非小公司独有的情况，许多大型组织也时常面临微服务带来的资源压力。</p>\n<p>然而，资源预算并非无限。不久后，技术负责人通常会收到来自财务部门的成本预警，要求团队优化服务器使用。随后便是一轮常见的资源审查对话：</p>\n<blockquote>\n<ul>\n<li>“这个服务为何占用这么多实例？是资源消耗过大吗？”</li>\n<li>“其实主要是为了满足跨数据中心部署的冗余要求。”</li>\n<li>“它的服务对象是谁？流量很高吗？”</li>\n<li>“目前主要是内部开发团队在使用。”</li>\n<li>“那么负载均衡是必需的吗？能否缩减为单实例？”</li>\n<li>“……可以调整。”</li>\n</ul>\n</blockquote>\n<p>经过一系列类似的评估，部分资源得以缩减。这个案例清晰地揭示了一个普遍现象：<strong>微服务架构在提升灵活性的同时，往往伴随着服务器等基础设施资源消耗的成倍增长，这对成本控制与资源精细化管理提出了更高要求。</strong></p>\n<h2 id=\"36-痛点分布式事务\">3.6 痛点：分布式事务</h2>\n<p>在传统的单体架构中，一个典型的“下单”流程可以简洁地封装在一个数据库事务中：创建订单、扣减库存、生成交易单、记录财务应收款，这些步骤要么全部成功，要么全部回滚。若中途出错，系统可自动回滚并提示用户重试。</p>\n<p>但在微服务架构下，同一流程的各个步骤可能分散在不同的服务中，每个服务操作着独立的数据库。这便引入了经典的<strong>分布式事务难题</strong>，开发团队不得不直面以下复杂决策：</p>\n<ol>\n<li><strong>如何实现回滚？</strong> 若一个步骤失败，是否要触发全局回滚？若是，则每个参与服务都必须实现相应的补偿（回滚）逻辑。那么，补偿操作本身失败又该如何？是否需要为“回滚操作”再设计回滚？或者，是否只对部分核心操作进行回滚？其边界又该如何划定？</li>\n<li><strong>是否采用重试与异步？</strong> 是否放弃回滚，改为让失败的操作自动重试？这通常意味着将同步调用改为异步。但如果异步调用超时，前端用户该如何感知？此时可能已产生部分更新的数据，又该如何补救？</li>\n</ol>\n<p>如果这只是少数特定场景的挑战，或许尚可应对。但问题在于，在微服务体系内，这类<strong>跨多个服务更新数据</strong>的场景几乎无处不在。如果每个场景都需要投入大量时间来设计、实现并沟通一套复杂的一致性逻辑，整个团队的开发效率与心力都将承受巨大负担。</p>\n<p>因此，在实践中，许多团队会权衡利弊，在大量非核心场景下采取一种更为务实的策略：<strong>优先保证核心“成功路径”的畅通</strong>。即默认跨服务调用均会成功，若某一步调用失败，则系统捕获异常、记录详细日志，后续由运维或开发人员线下人工处理数据不一致的问题。</p>\n<p>这种策略上线后，在真实的生产环境中，由于网络抖动、服务瞬时不可用等情况难以完全避免，常会出现“上游数据已变更，下游数据未更新”的<strong>数据不一致</strong>状态。</p>\n<p>分布式事务一直是微服务架构中公认的核心挑战与设计难点。在经历多次线上问题后，团队通常会下定决心，必须系统性地解决这一问题。我们将在后续章节专门探讨相关的成熟解决方案与架构模式</p>\n<h2 id=\"37-痛点服务之间的依赖\">3.7 痛点：服务之间的依赖</h2>\n<p>在软件设计中，我们通常遵循类与类之间避免循环依赖的原则，从而形成清晰的层次结构。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133144-1233010375.jpg\" /></p>\n<p>然而，当我们将这种依赖关系映射到微服务时，情况往往变得复杂。</p>\n<p>例如，商品系统需要根据门店类型设置不同价格，因此它需要调用门店系统的接口，这就产生了对门店服务的依赖。同时，门店系统需要管理商品库存，又必须依赖商品系统提供的商品基础信息。如此一来，两者便形成了<strong>循环依赖</strong>。</p>\n<p>再以底层的财务系统为例。理论上，它作为核心支撑系统，应尽可能独立。但现实中，它必须依赖订单服务（以明确费用来源）、会员服务（明确付款方）和门店服务（明确收款方）。随着业务需求不断叠加，服务间的依赖关系最终会演变成一张<strong>盘根错节、难以理清</strong>的网状结构，如图所示。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133199-1121810109.jpg\" /></p>\n<p>这种“你中有我，我中有你”的复杂依赖通常会引发两类典型问题：</p>\n<p><strong>1. 评估影响面时，牵一发而动全身</strong><br />\n某次，团队需要重构两个已上线的服务。由于此前线上出现过严重故障，技术负责人要求必须全面评估重构的影响范围。最初有方案提议，通过代码调用链逐级追溯所有上游服务，但因分析成本过高、易有遗漏而被否决。</p>\n<p>随后采用的方案是基于全链路日志，分析出这两个服务的所有直接与间接上游依赖。评估结果令人咋舌：超过半数的微服务都会受到影响。这直接导致在项目上线前的关键几天，大量无关团队的开发人员不得不一同加班，进行大规模的回归测试。</p>\n<p><strong>2. 为隔离影响，导致版本泛滥</strong><br />\n吸取了上述教训后，团队在面对新的重构需求时，转而采用一种“保险”策略：不直接修改原有服务（如 <code>abcServiceV1</code>），而是直接开发一个全新的 <code>abcServiceV2</code>。新代码调用V2，旧代码继续使用V1，计划在未来再下线V1。</p>\n<p>这种策略短期内避免了大规模协调，但却导致了服务数量的激增。更重要的是，开发人员很少真正去下线那些陈旧的V1服务。长此以往，系统里充斥着大量并存的新旧版本服务，使得维护复杂度不降反增。</p>\n<p>服务依赖治理是一项持续挑战，我们将在后续探讨相应的解决方案。</p>\n<h2 id=\"38-痛点联调的痛苦\">3.8 痛点：联调的痛苦</h2>\n<p>微服务架构显著改变了项目的协作节奏。以往的需求排期相对线性，而引入微服务后，则必须在开发前增加 <strong>“接口设计”</strong> 环节，在开发后增加 <strong>“服务联调”</strong> 环节。</p>\n<p>因此，每逢紧急需求，大家最关心的问题往往变成了：“接口文档好了吗？”“联调什么时候能开始？”之所以如此在意，是因为在软件项目中，最大的进度风险往往不是技术实现，而是<strong>跨团队的沟通与协调</strong>。</p>\n<p><strong>案例一：计划因他人优先级而延误</strong><br />\n门店系统有一个小改动，需要商品团队提供一个简单接口。商品团队回复：“手头有别的项目，周二可以给接口。”门店团队据此排期：周二对接，周三联调，周四、五测试，预计周五上线。</p>\n<p>然而，周二当天，商品团队的主项目突发紧急需求，必须通宵处理，承诺的接口无法交付。于是，门店团队整个上线计划被迫推迟。这类因他人优先级变动导致的延误，在实际开发中屡见不鲜。</p>\n<p><strong>案例二：大规模项目中的协调噩梦</strong><br />\n一个涉及30个服务、300多个接口的大型项目，在需求评审后，仅<strong>核对这300多个接口的文档</strong>就花费了两周时间。紧接着，协调十几个项目组安排联调时间，又耗去3天。</p>\n<p>尽管在开发过程中接口仍可能有微调，但前期的对齐确保了各团队在大致正确的方向上推进。真正的耗时大户是联调阶段，大量时间消耗在低效的沟通上：</p>\n<blockquote>\n<ul>\n<li>“你的接口怎么返回404？”</li>\n<li>“哦，环境部署错了，稍等。”</li>\n<li>“这个接口需要加个时间字段。”</li>\n<li>“可以，但我手头有别的活，明天给你行吗？”</li>\n<li>“不行啊，今天必须调完。”</li>\n</ul>\n</blockquote>\n<p>每个接口的联调都可能经历类似的拉锯。当300多个接口都需要如此协调，且各团队优先级不一致时，联调所花费的时间甚至可能与功能开发本身相当。</p>\n<p>如何提升联调效率，是一个亟待解决的问题。关于这个痛点，将在后面的文章会给出解决方案。</p>\n<h2 id=\"39-痛点部署上的难题\">3.9 痛点：部署上的难题</h2>\n<p>在单体架构时代，开发者可以在本地完整部署整个系统进行调试。但在微服务架构下，动辄涉及十几个服务，本地部署在资源（如内存）和知识层面都变得不可行。</p>\n<p>常见的解决方案是搭建一套共享的<strong>中心化联调环境</strong>，让开发者将本地开发的服务接入其中，与其他远程服务进行联调。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133154-236769282.jpg\" /></p>\n<p>然而，这种环境本身问题重重：</p>\n<p><strong>1. 数据状态残缺不全</strong><br />\n联调环境中的数据多是各开发者随意构造的“脏数据”，缺乏业务完整性。经常出现订单没有对应的收款单，或审批流程单据缺失等情况，导致端到端的业务流程根本无法走通。</p>\n<p><strong>2. 服务调用指向错误</strong><br />\n调试时经常发现接口字段缺失或报错，经过冗长的排查，最后发现原因可能是：“哦，我本地服务注册到联调环境时，不小心覆盖了别人刚部署的稳定版本”，或者“我调用的其实是另一个同事正在开发的、不稳定的服务实例”。</p>\n<p><strong>3. 环境极度不稳定</strong><br />\n由于开发者在频繁地部署和接入自己尚不稳定的服务，整个联调环境的状态时刻在波动，极其脆弱。它通常只能用于接口间的<strong>局部调试</strong>，而无法支持完整的业务流程验证。</p>\n<p>能否便捷地创建一套相对独立、稳定的测试环境？我们将在后面的文章中探讨相关的解决方案。</p>\n<h1 id=\"4-小结\">4 小结</h1>\n<p>至此，我们详细剖析了微服务的九大核心痛点。回顾一下，我们之前只列举了它的5点优势，却花了更多篇幅讨论其9个痛点。这或许会引发一个根本性的疑问：<strong>既然有这么多问题，为什么我们还要采用微服务？</strong></p>\n<p>作为一个技术人，笔者完全理解开发者对尝试新技术的热情。从个人成长角度，使用前沿技术能带来巨大的学习动力和职业资本。曾经，我和同事们也常抱怨领导过于保守，坚持使用“过时”的技术栈。</p>\n<p>然而，当角色转变为需要对团队乃至公司技术栈负责时，视角会发生变化。你必须冷静权衡：新旧系统兼容的额外维护成本、团队学习新技术的曲线与试错成本，这些往往是个体开发者难以充分感知的。正如一位同事的犀利点评：“程序员用三年学新技术、做迁移，三年后又有更新的技术出现，留下的技术债谁来偿还？个人凭借新技术跳槽获得了更高职位，那公司的烂摊子谁来接手？”</p>\n<p><strong>笔者并非反对技术进步，而是倡导对任何技术都应抱有敬畏之心——不仅要清楚其优势，更要透彻了解其代价与局限。</strong></p>\n<p>那么，回到最初的问题：为何仍需微服务？答案其实很朴素：对于持续复杂化的业务，单体架构终将演进到<strong>无论投入多少人力都无法高效迭代</strong>的境地。而微服务架构，尽管伴随诸多挑战，但至少能通过<strong>增加人手、分而治之</strong>的方式来维持系统的迭代能力与发展弹性。</p>\n<p>这正是我们忍受其痛点、并致力于解决这些痛点的根本原因。接下来，我们将进入微服务进阶实战场景，探讨如何系统性地应对本章所提及的各项挑战。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 10:54</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yhup\">yihuiComeOn</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}