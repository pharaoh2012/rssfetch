{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "多线程的这12种用途，99%的人不知道！",
      "link": "https://www.cnblogs.com/12lisu/p/19517803",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19517803\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 16:09\">\n    <span>多线程的这12种用途，99%的人不知道！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>并发编程是一项非常重要的技术，无论在面试，还是工作中出现的频率非常高。</p>\n<p>之前我发表的一篇《<a href=\"https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;mid=2247492962&amp;idx=1&amp;sn=17ed1d2ed950b4e9160218b296d19d4e&amp;chksm=c0e83d8af79fb49cc72fcafc8ed62822263106e54675ea8406a2e3daadb44e25364275af9082&amp;token=245805875&amp;lang=zh_CN#rd\" rel=\"noopener nofollow\" target=\"_blank\">聊聊并发编程的10个坑</a>》，在全网广受好评。说明了这类文章还是比较有价值的，接下来，打算继续聊聊并发编程这个话题。</p>\n<p>并发编程说白了就是多线程编程，但多线程一定比单线程效率更高？</p>\n<p>答：不一定，要看具体业务场景。</p>\n<p>毕竟如果使用了多线程，那么线程之间的竞争和抢占cpu资源，线程的上下文切换，也是相对来说比较耗时的操作。</p>\n<p>下面这几个问题在面试中，你必定遇到过：</p>\n<ol>\n<li>你在哪来业务场景中使用过多线程？</li>\n<li>怎么用的？</li>\n<li>踩过哪些坑？</li>\n</ol>\n<p>今天聊聊我之前在项目中用并发编程的12种业务场景，给有需要的朋友一个参考。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"1-简单定时任务\">1. 简单定时任务</h2>\n<p>各位亲爱的朋友，你没看错，<code>Thread</code>类真的能做定时任务。如果你看过一些<code>定时任务框架</code>的源码，你最后会发现，它们的底层也会使用Thread类。</p>\n<p>实现这种定时任务的具体代码如下：</p>\n<pre><code class=\"language-java\">public static void init() {\n    new Thread(() -&gt; {\n        while (true) {\n            try {\n                System.out.println(\"下载文件\");\n                Thread.sleep(1000 * 60 * 5);\n            } catch (Exception e) {\n                log.error(e);\n            }\n        }\n    }).start();\n}\n</code></pre>\n<p>使用Thread类可以做最简单的定时任务，在run方法中有个while的死循环（当然还有其他方式），执行我们自己的任务。有个需要特别注意的地方是，需要用<code>try...catch</code>捕获异常，否则如果出现异常，就直接退出循环，下次将无法继续执行了。</p>\n<p>但这种方式做的定时任务，只能周期性执行，不能支持定时在某个时间点执行。</p>\n<p>特别提醒一下，该线程建议定义成<code>守护线程</code>，可以通过<code>setDaemon</code>方法设置，让它在后台默默执行就好。</p>\n<p>使用场景：比如项目中有时需要每隔5分钟去<code>下载某个文件</code>，或者每隔10分钟去读取模板文件<code>生成静态html页面</code>等等，一些简单的周期性任务场景。</p>\n<p>使用<code>Thread</code>类做定时任务的优缺点：</p>\n<ul>\n<li>\n<p>优点：这种定时任务非常简单，学习成本低，容易入手，对于那些简单的周期性任务，是个不错的选择。</p>\n</li>\n<li>\n<p>缺点：不支持指定某个时间点执行任务，不支持延迟执行等操作，功能过于单一，无法应对一些较为复杂的场景。</p>\n</li>\n</ul>\n<h2 id=\"2监听器\">2.监听器</h2>\n<p>有时候，我们需要写个监听器，去监听某些数据的变化。</p>\n<p>比如：我们在使用<code>canal</code>的时候，需要监听<code>binlog</code>的变化，能够及时把数据库中的数据，同步到另外一个业务数据库中。</p>\n<p><img alt=\"\" class=\"lazyload\" /><br />\n如果直接写一个监听器去监听数据就太没意思了，我们想实现这样一个功能：在配置中心有个开关，配置监听器是否开启，如果开启了使用单线程异步执行。</p>\n<p>主要代码如下：</p>\n<pre><code class=\"language-java\">@Service\npublic CanalService {\n    private volatile boolean running = false;\n    private Thread thread;\n\n    @Autowired\n    private CanalConnector canalConnector;\n    \n    public void handle() {\n        //连接canal\n        while(running) {\n           //业务处理\n        }\n    }\n    \n    public void start() {\n       thread = new Thread(this::handle, \"name\");\n       running = true;\n       thread.start();\n    }\n    \n    public void stop() {\n       if(!running) {\n          return;\n       }\n       running = false;\n    }\n}\n</code></pre>\n<p>在start方法中开启了一个线程，在该线程中异步执行handle方法的具体任务。然后通过调用stop方法，可以停止该线程。</p>\n<p>其中，使用<code>volatile</code>关键字控制的running变量作为开关，它可以控制线程中的状态。</p>\n<p>接下来，有个比较关键的点是：如何通过配置中心的配置，控制这个开关呢？</p>\n<p>以<code>apollo</code>配置为例，我们在配置中心的后台，修改配置之后，自动获取最新配置的核心代码如下：</p>\n<pre><code class=\"language-java\">public class CanalConfig {\n    @Autowired\n    private CanalService canalService;\n\n    @ApolloConfigChangeListener\n    public void change(ConfigChangeEvent event) {\n        String value = event.getChange(\"test.canal.enable\").getNewValue();\n        if(BooleanUtils.toBoolean(value)) {\n            canalService.start();\n        } else {\n            canalService.stop();\n        }\n    }\n}\n</code></pre>\n<p>通过<code>apollo</code>的<code>ApolloConfigChangeListener</code>注解，可以监听配置参数的变化。</p>\n<p>如果<code>test.canal.enable</code>开关配置的true，则调用canalService类的start方法开启canal数据同步功能。如果开关配置的false，则调用canalService类的stop方法，自动停止canal数据同步功能。</p>\n<h2 id=\"3收集日志\">3.收集日志</h2>\n<p>在某些高并发的场景中，我们需要收集部分用户的日志（比如：用户登录的日志），写到数据库中，以便于做分析。</p>\n<p>但由于项目中，还没有引入消息中间件，比如：<code>kafka</code>、<code>rocketmq</code>等。</p>\n<p>如果直接将日志同步写入数据库，可能会影响接口性能。</p>\n<p>所以，大家很自然想到了异步处理。</p>\n<p>实现这个需求最简单的做法是，开启一个线程，异步写入数据到数据库即可。</p>\n<p>这样做，可以是可以。</p>\n<p>但如果用户登录操作的耗时，比异步写入数据库的时间要少得多。这样导致的结果是：生产日志的速度，比消费日志的速度要快得多，最终的性能瓶颈在消费端。</p>\n<p>其实，还有更优雅的处理方式，虽说没有使用消息中间件，但借用了它的思想。</p>\n<p>这套记录登录日志的功能，分为：日志生产端、日志存储端和日志消费端。</p>\n<p>如下图所示：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>先定义了一个阻塞队列。</p>\n<pre><code class=\"language-java\">@Component\npublic class LoginLogQueue {\n    private static final int QUEUE_MAX_SIZE    = 1000;\n\n    private BlockingQueueblockingQueue queue = new LinkedBlockingQueue&lt;&gt;(QUEUE_MAX_SIZE);\n\n    //生成消息\n    public boolean push(LoginLog loginLog) {\n        return this.queue.add(loginLog);\n    } \n\n    //消费消息\n    public LoginLog poll() {\n        LoginLog loginLog = null;\n        try {\n            loginLog = this.queue.take();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n}\n</code></pre>\n<p>然后定义了一个日志的生产者。</p>\n<pre><code class=\"language-java\">@Service\npublic class LoginSerivce {\n    \n    @Autowired\n    private LoginLogQueue loginLogQueue;\n\n    public int login(UserInfo userInfo) {\n        //业务处理\n        LoginLog loginLog = convert(userInfo);\n        loginLogQueue.push(loginLog);\n    }  \n}\n</code></pre>\n<p>接下来，定义了日志的消费者。</p>\n<pre><code class=\"language-java\">@Service\npublic class LoginInfoConsumer {\n    @Autowired\n    private LoginLogQueue queue;\n\n    @PostConstruct\n    public voit init {\n       new Thread(() -&gt; {\n          while (true) {\n              LoginLog loginLog = queue.take();\n              //写入数据库\n          }\n        }).start();\n    }\n}\n</code></pre>\n<p>当然，这个例子中使用单线程接收登录日志，为了提升性能，也可以使用线程池来处理业务逻辑（比如：写入数据库）等。</p>\n<h2 id=\"4excel导入\">4.excel导入</h2>\n<p>我们可能会经常收到运营同学提过来的excel数据导入需求，比如：将某一大类下的所有子类一次性导入系统，或者导入一批新的供应商数据等等。</p>\n<p>我们以导入供应商数据为例，它所涉及的业务流程很长，比如：</p>\n<ol>\n<li>调用天眼查接口校验企业名称和统一社会信用代码。</li>\n<li>写入供应商基本表</li>\n<li>写入组织表</li>\n<li>给供应商自动创建一个用户</li>\n<li>给该用户分配权限</li>\n<li>自定义域名</li>\n<li>发站内通知</li>\n</ol>\n<p>等等。</p>\n<p>如果在程序中，解析完excel，读取了所有数据之后。用单线程一条条处理业务逻辑，可能耗时会非常长。</p>\n<p>为了提升excel数据导入效率，非常有必要使用多线程来处理。</p>\n<p>当然在java中实现多线程的手段有很多种，下面重点聊聊java8中最简单的实现方式：<code>parallelStream</code>。</p>\n<p>伪代码如下：</p>\n<pre><code class=\"language-java\">supplierList.parallelStream().forEach(x -&gt; importSupplier(x));\n</code></pre>\n<p><code>parallelStream</code>是一个并行执行的流，它默认通过<code>ForkJoinPool</code>实现的，能提高你的多线程任务的速度。</p>\n<p><code>ForkJoinPool</code>处理的过程会分而治之，它的核心思想是：<code>将一个大任务切分成多个小任务</code>。每个小任务都能单独执行，最后它会把所用任务的执行结果进行汇总。</p>\n<p>下面用一张图简单介绍一下ForkJoinPool的原理：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>当然除了excel导入之外，还有类似的读取文本文件，也可以用类似的方法处理。</p>\n<blockquote>\n<p>温馨的提醒一下，如果一次性导入的数据非常多，用多线程处理，可能会使系统的cpu使用率飙升，需要特别关注。</p>\n</blockquote>\n<h2 id=\"5查询接口\">5.查询接口</h2>\n<p>很多时候，我们需要在某个查询接口中，调用其他服务的接口，组合数据之后，一起返回。</p>\n<p>比如有这样的业务场景：</p>\n<p>在用户信息查询接口中需要返回：用户名称、性别、等级、头像、积分、成长值等信息。</p>\n<p>而用户名称、性别、等级、头像在用户服务中，积分在积分服务中，成长值在成长值服务中。为了汇总这些数据统一返回，需要另外提供一个对外接口服务。</p>\n<p>于是，用户信息查询接口需要调用用户查询接口、积分查询接口 和 成长值查询接口，然后汇总数据统一返回。</p>\n<p>调用过程如下图所示：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>调用远程接口总耗时 530ms = 200ms + 150ms + 180ms</p>\n<p>显然这种串行调用远程接口性能是非常不好的，调用远程接口总的耗时为所有的远程接口耗时之和。</p>\n<p>那么如何优化远程接口性能呢？</p>\n<p>既然串行调用多个远程接口性能很差，为什么不改成并行呢？</p>\n<p>如下图所示：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>调用远程接口总耗时 200ms = 200ms（即耗时最长的那次远程接口调用）</p>\n<p>在java8之前可以通过实现<code>Callable</code>接口，获取线程返回结果。</p>\n<p>java8以后通过<code>CompleteFuture</code>类实现该功能。我们这里以CompleteFuture为例：</p>\n<pre><code class=\"language-java\">public UserInfo getUserInfo(Long id) throws InterruptedException, ExecutionException {\n    final UserInfo userInfo = new UserInfo();\n    CompletableFuture userFuture = CompletableFuture.supplyAsync(() -&gt; {\n        getRemoteUserAndFill(id, userInfo);\n        return Boolean.TRUE;\n    }, executor);\n\n    CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -&gt; {\n        getRemoteBonusAndFill(id, userInfo);\n        return Boolean.TRUE;\n    }, executor);\n\n    CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -&gt; {\n        getRemoteGrowthAndFill(id, userInfo);\n        return Boolean.TRUE;\n    }, executor);\n    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();\n\n    userFuture.get();\n    bonusFuture.get();\n    growthFuture.get();\n    return userInfo;\n}\n</code></pre>\n<p>温馨提醒一下，这两种方式别忘了使用<code>线程池</code>。示例中我用到了<code>executor</code>，表示自定义的线程池，为了防止高并发场景下，出现线程过多的问题。</p>\n<h2 id=\"6获取用户上下文\">6.获取用户上下文</h2>\n<p>不知道你在项目开发时，有没有遇到过这样的需求：用户登录之后，在所有的请求接口中，通过某个公共方法，就能获取到当前登录用户的信息？</p>\n<p>获取的用户上下文，我们以<code>CurrentUser</code>为例。</p>\n<p><code>CurrentUser</code>内部包含了一个<code>ThreadLocal</code>对象，它负责保存当前线程的用户上下文信息。当然为了保证在线程池中，也能从用户上下文中获取到正确的用户信息，这里用了阿里的<code>TransmittableThreadLocal</code>。伪代码如下：</p>\n<pre><code class=\"language-java\">@Data\npublic class CurrentUser {\n    private static final TransmittableThreadLocal&lt;CurrentUser&gt; THREA_LOCAL = new TransmittableThreadLocal&lt;&gt;();\n    \n    private String id;\n    private String userName;\n    private String password;\n    private String phone;\n    ...\n    \n    public statis void set(CurrentUser user) {\n      THREA_LOCAL.set(user);\n    }\n    \n    public static void getCurrent() {\n      return THREA_LOCAL.get();\n    }\n}\n</code></pre>\n<p>这里为什么用了阿里的TransmittableThreadLocal，而不是普通的ThreadLocal呢？在线程池中，由于线程会被多次复用，导致从普通的ThreadLocal中无法获取正确的用户信息。父线程中的参数，没法传递给子线程，而TransmittableThreadLocal很好解决了这个问题。</p>\n<p>然后在项目中定义一个全局的spring mvc拦截器，专门设置用户上下文到ThreadLocal中。伪代码如下：</p>\n<pre><code class=\"language-java\">public class UserInterceptor extends HandlerInterceptorAdapter {\n   \n   @Override  \n   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n      CurrentUser user = getUser(request);\n      if(Objects.nonNull(user)) {\n         CurrentUser.set(user);\n      }\n   } \n}\n</code></pre>\n<p>用户在请求我们接口时，会先触发该拦截器，它会根据用户cookie中的token，调用调用接口获取redis中的用户信息。如果能获取到，说明用户已经登录，则把用户信息设置到CurrentUser类的ThreadLocal中。</p>\n<p>接下来，在api服务的下层，即business层的方法中，就能轻松通过CurrentUser.getCurrent();方法获取到想要的用户上下文信息了。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>这套用户体系的想法是很good的，但深入使用后，发现了一个小插曲：</p>\n<p>api服务和mq消费者服务都引用了business层，business层中的方法两个服务都能直接调用。</p>\n<p>我们都知道在api服务中用户是需要登录的，而mq消费者服务则不需要登录。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>如果business中的某个方法刚开始是给api开发的，在方法深处使用了CurrentUser.getCurrent();获取用户上下文。但后来，某位新来的帅哥在mq消费者中也调用了那个方法，并未发觉这个小机关，就会中招，出现找不到用户上下文的问题。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>所以我当时的第一个想法是：代码没做兼容处理，因为之前这类问题偶尔会发生一次。</p>\n<p>想要解决这个问题，其实也很简单。只需先判断一下能否从CurrentUser中获取用户信息，如果不能，则取配置的系统用户信息。伪代码如下：</p>\n<pre><code class=\"language-java\">@Autowired\nprivate BusinessConfig businessConfig;\n\nCurrentUser user = CurrentUser.getCurrent();\nif(Objects.nonNull(user)) {\n   entity.setUserId(user.getUserId());\n   entity.setUserName(user.getUserName());\n} else {\n   entity.setUserId(businessConfig.getDefaultUserId());\n   entity.setUserName(businessConfig.getDefaultUserName());\n}\n</code></pre>\n<p>这种简单无公害的代码，如果只是在一两个地方加还OK。</p>\n<p>此外，众所周知，<code>SimpleDateFormat</code>在java8以前，是用来处理时间的工具类，它是非线程安全的。也就是说，用该方法解析日期会有线程安全问题。</p>\n<p>为了避免线程安全问题的出现，我们可以把SimpleDateFormat对象定义成<code>局部变量</code>。但如果你一定要把它定义成静态变量，可以使用ThreadLocal保存日期，也能解决线程安全问题。</p>\n<h2 id=\"8-传递参数\">8. 传递参数</h2>\n<p>之前见过有些同事写代码时，一个非常有趣的用法，即：使用<code>MDC</code>传递参数。</p>\n<p>MDC是什么？</p>\n<p><code>MDC</code>是<code>org.slf4j</code>包下的一个类，它的全称是<code>Mapped Diagnostic Context</code>，我们可以认为它是一个线程安全的存放诊断日志的容器。</p>\n<p><code>MDC</code>的底层是用了<code>ThreadLocal</code>来保存数据的。</p>\n<p>例如现在有这样一种场景：我们使用<code>RestTemplate</code>调用远程接口时，有时需要在<code>header</code>中传递信息，比如：traceId，source等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。</p>\n<p>这种业务场景就能通过<code>ClientHttpRequestInterceptor</code>接口实现，具体做法如下：</p>\n<p>第一步，定义一个LogFilter拦截所有接口请求，在MDC中设置traceId：</p>\n<pre><code class=\"language-java\">public class LogFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        MdcUtil.add(UUID.randomUUID().toString());\n        System.out.println(\"记录请求日志\");\n        chain.doFilter(request, response);\n        System.out.println(\"记录响应日志\");\n    }\n\n    @Override\n    public void destroy() {\n    }\n}\n</code></pre>\n<p>第二步，实现<code>ClientHttpRequestInterceptor</code>接口，MDC中获取当前请求的traceId，然后设置到header中：</p>\n<pre><code class=\"language-java\">public class RestTemplateInterceptor implements ClientHttpRequestInterceptor {\n\n    @Override\n    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {\n        request.getHeaders().set(\"traceId\", MdcUtil.get());\n        return execution.execute(request, body);\n    }\n}\n</code></pre>\n<p>第三步，定义配置类，配置上面定义的RestTemplateInterceptor类：</p>\n<pre><code class=\"language-java\">@Configuration\npublic class RestTemplateConfiguration {\n\n    @Bean\n    public RestTemplate restTemplate() {\n        RestTemplate restTemplate = new RestTemplate();\n        restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));\n        return restTemplate;\n    }\n\n    @Bean\n    public RestTemplateInterceptor restTemplateInterceptor() {\n        return new RestTemplateInterceptor();\n    }\n}\n</code></pre>\n<p>其中MdcUtil其实是利用MDC工具在<code>ThreadLocal</code>中存储和获取traceId</p>\n<pre><code class=\"language-java\">public class MdcUtil {\n\n    private static final String TRACE_ID = \"TRACE_ID\";\n\n    public static String get() {\n        return MDC.get(TRACE_ID);\n    }\n\n    public static void add(String value) {\n        MDC.put(TRACE_ID, value);\n    }\n}\n</code></pre>\n<p>当然，这个例子中没有演示MdcUtil类的add方法具体调的地方，我们可以在<code>filter</code>中执行接口方法之前，生成traceId，调用MdcUtil类的add方法添加到MDC中，然后在同一个请求的其他地方就能通过MdcUtil类的get方法获取到该traceId。</p>\n<p>能使用MDC保存traceId等参数的根本原因是，用户请求到应用服务器，<code>Tomcat</code>会从线程池中分配一个线程去处理该请求。</p>\n<p>那么该请求的整个过程中，保存到<code>MDC</code>的<code>ThreadLocal</code>中的参数，也是该线程独享的，所以不会有线程安全问题。</p>\n<h2 id=\"9-模拟高并发\">9. 模拟高并发</h2>\n<p>有时候我们写的接口，在低并发的场景下，一点问题都没有。</p>\n<p>但如果一旦出现高并发调用，该接口可能会出现一些意想不到的问题。</p>\n<p>为了防止类似的事情发生，一般在项目上线前，我们非常有必要对接口做一下<code>压力测试</code>。</p>\n<p>当然，现在已经有比较成熟的压力测试工具，比如：<code>Jmeter</code>、<code>LoadRunner</code>等。</p>\n<p>如果你觉得下载压测工具比较麻烦，也可以手写一个简单的模拟并发操作的工具，用<code>CountDownLatch</code>就能实现，例如：</p>\n<pre><code class=\"language-java\">public static void concurrenceTest() {\n    /**\n     * 模拟高并发情况代码\n     */\n    final AtomicInteger atomicInteger = new AtomicInteger(0);\n    final CountDownLatch countDownLatch = new CountDownLatch(1000); // 相当于计数器，当所有都准备好了，再一起执行，模仿多并发，保证并发量\n    final CountDownLatch countDownLatch2 = new CountDownLatch(1000); // 保证所有线程执行完了再打印atomicInteger的值\n    ExecutorService executorService = Executors.newFixedThreadPool(10);\n    try {\n        for (int i = 0; i &lt; 1000; i++) {\n            executorService.submit(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        countDownLatch.await(); //一直阻塞当前线程，直到计时器的值为0,保证同时并发\n                    } catch (InterruptedException e) {\n                        log.error(e.getMessage(),e);\n                    }\n                    //每个线程增加1000次，每次加1\n                    for (int j = 0; j &lt; 1000; j++) {\n                        atomicInteger.incrementAndGet();\n                    }\n                    countDownLatch2.countDown();\n                }\n            });\n            countDownLatch.countDown();\n        }\n\n        countDownLatch2.await();// 保证所有线程执行完\n        executorService.shutdown();\n    } catch (Exception e){\n        log.error(e.getMessage(),e);\n    }\n}\n</code></pre>\n<h2 id=\"10-处理mq消息\">10. 处理mq消息</h2>\n<p>在高并发的场景中，消息积压问题，可以说如影随形，真的没办法从根本上解决。表面上看，已经解决了，但后面不知道什么时候，就会冒出一次，比如这次：</p>\n<p>有天下午，产品过来说：有几个商户投诉过来了，他们说菜品有延迟，快查一下原因。</p>\n<p>这次问题出现得有点奇怪。</p>\n<p>为什么这么说？</p>\n<p>首先这个时间点就有点奇怪，平常出问题，不都是中午或者晚上用餐高峰期吗？怎么这次问题出现在下午？</p>\n<p>根据以往积累的经验，我直接看了<code>kafka</code>的<code>topic</code>的数据，果然上面消息有积压，但这次每个<code>partition</code>都积压了十几万的消息没有消费，比以往加压的消息数量增加了几百倍。这次消息积压得极不寻常。</p>\n<p>我赶紧查服务监控看看消费者挂了没，还好没挂。又查服务日志没有发现异常。这时我有点迷茫，碰运气问了问订单组下午发生了什么事情没？他们说下午有个促销活动，跑了一个<code>JOB</code>批量更新过有些商户的订单信息。</p>\n<p>这时，我一下子如梦初醒，是他们在JOB中批量发消息导致的问题。怎么没有通知我们呢？实在太坑了。</p>\n<p>虽说知道问题的原因了，倒是眼前积压的这十几万的消息该如何处理呢？</p>\n<p>此时，如果直接调大<code>partition</code>数量是不行的，历史消息已经存储到<code>4</code>个固定的partition，只有新增的消息才会到新的partition。我们重点需要处理的是已有的partition。</p>\n<p>直接加服务节点也不行，因为<code>kafka</code>允许同组的多个<code>partition</code>被一个<code>consumer</code>消费，但不允许一个partition被同组的多个consumer消费，可能会造成资源浪费。</p>\n<p>看来只有用<code>多线程</code>处理了。</p>\n<p>为了紧急解决问题，我改成了用线程池处理消息，核心线程和最大线程数都配置成了<code>50</code>。</p>\n<p>大致用法如下：</p>\n<ol>\n<li>先定义一个线程池：</li>\n</ol>\n<pre><code class=\"language-java\">@Configuration\npublic class ThreadPoolConfig {\n\n    @Value(\"${thread.pool.corePoolSize:5}\")\n    private int corePoolSize;\n\n    @Value(\"${thread.pool.maxPoolSize:10}\")\n    private int maxPoolSize;\n\n    @Value(\"${thread.pool.queueCapacity:200}\")\n    private int queueCapacity;\n\n    @Value(\"${thread.pool.keepAliveSeconds:30}\")\n    private int keepAliveSeconds;\n\n    @Value(\"${thread.pool.threadNamePrefix:ASYNC_}\")\n    private String threadNamePrefix;\n\n    @Bean(\"messageExecutor\")\n    public Executor messageExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(corePoolSize);\n        executor.setMaxPoolSize(maxPoolSize);\n        executor.setQueueCapacity(queueCapacity);\n        executor.setKeepAliveSeconds(keepAliveSeconds);\n        executor.setThreadNamePrefix(threadNamePrefix);\n        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());\n        executor.initialize();\n        return executor;\n    }\n}\n</code></pre>\n<ol start=\"2\">\n<li>再定义一个消息的consumer：</li>\n</ol>\n<pre><code class=\"language-java\">@Service\npublic class MyConsumerService {\n    @Autowired\n    private Executor messageExecutor;\n    \n    @KafkaListener(id=\"test\",topics={\"topic-test\"})\n    public void listen(String message){\n        System.out.println(\"收到消息：\" + message);\n        messageExecutor.submit(new MyWork(message);\n    }\n}\n</code></pre>\n<ol start=\"3\">\n<li>在定义的Runable实现类中处理业务逻辑：</li>\n</ol>\n<pre><code class=\"language-java\">public class MyWork implements Runnable {\n    private String message;\n    \n    public MyWork(String message) {\n       this.message = message;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(message);\n    }\n}\n</code></pre>\n<p>果然，调整之后消息积压数量确实下降的非常快，大约半小时后，积压的消息就非常顺利的处理完了。</p>\n<p>但此时有个更严重的问题出现：我收到了报警邮件，有两个订单系统的节点down机了。。。</p>\n<p>更详细内容，请看看我的另一篇文章《<a href=\"https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;mid=2247490289&amp;idx=1&amp;sn=bc311da9f4a4d3f48ee5dc207bf31a8b&amp;chksm=c0ebc219f79c4b0fc711116723b9df3a5531cda32f0f5d00f065910aa552af6ff03b3f1528fc&amp;token=751314179&amp;lang=zh_CN&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">我用kafka两年踩过的一些非比寻常的坑</a>》</p>\n<h2 id=\"11-统计数量\">11. 统计数量</h2>\n<p>在多线程的场景中，有时候需要统计数量，比如：用多线程导入供应商数据时，统计导入成功的供应商数有多少。</p>\n<p>如果这时候用count++统计次数，最终的结果可能会不准。因为count++并非原子操作，如果多个线程同时执行该操作，则统计的次数，可能会出现异常。</p>\n<p>为了解决这个问题，就需要使用<code>concurent</code>的<code>atomic</code>包下面的类，比如：<code>AtomicInteger</code>、<code>AtomicLong</code>等。</p>\n<pre><code class=\"language-java\">@Servcie\npublic class ImportSupplierService {\n  private static AtomicInteger count = new AtomicInteger(0);\n\n  public int importSupplier(List&lt;SupplierInfo&gt; supplierList) {\n       if(CollectionUtils.isEmpty(supplierList)) {\n           return 0;\n       }\n\n       supplierList.parallelStream().forEach(x -&gt; {\n           try {\n             importSupplier(x);\n             count.addAndGet(1);\n           } catch(Exception e) {\n              log.error(e.getMessage(),e);\n           }\n       );\n\n      return count.get();\n  }    \n}\n</code></pre>\n<p><code>AtomicInteger</code>的底层说白了使用<code>自旋锁</code>+<code>CAS</code>。</p>\n<pre><code class=\"language-java\">public final int incrementAndGet() {\n    for (;;) {\n        int current = get();\n        int next = current + 1;\n        if (compareAndSet(current, next))\n            return next;\n    }\n}\n</code></pre>\n<p><code>自旋锁</code>说白了就是一个<code>死循环</code>。</p>\n<p>而<code>CAS</code>是<code>比较</code>和<code>交换</code>的意思。</p>\n<p>它的实现逻辑是：将内存位置处的<code>旧值</code>与<code>预期值</code>进行比较，若相等，则将内存位置处的值替换为<code>新值</code>。若不相等，则不做任何操作。</p>\n<h2 id=\"12-延迟定时任务\">12. 延迟定时任务</h2>\n<p>我们经常有延迟处理数据的需求，比如：如果用户下单后，超过30分钟还未完成支付，则系统自动将该订单取消。</p>\n<p>这里需求就可以使用<code>延迟定时任务</code>实现。</p>\n<p><code>ScheduledExecutorService</code>是<code>JDK1.5+</code>版本引进的定时任务，该类位于<code>java.util.concurrent</code>并发包下。</p>\n<p>ScheduledExecutorService是基于多线程的，设计的初衷是为了解决<code>Timer</code>单线程执行，多个任务之间会互相影响的问题。</p>\n<p>它主要包含4个方法：</p>\n<ul>\n<li>schedule(Runnable command,long delay,TimeUnit unit)，带延迟时间的调度，只执行一次，调度之后可通过Future.get()阻塞直至任务执行完毕。</li>\n<li>schedule(Callable callable,long delay,TimeUnit unit)，带延迟时间的调度，只执行一次，调度之后可通过Future.get()阻塞直至任务执行完毕，并且可以获取执行结果。</li>\n<li>scheduleAtFixedRate，表示以固定频率执行的任务，如果当前任务耗时较多，超过定时周期period，则当前任务结束后会立即执行。</li>\n<li>scheduleWithFixedDelay，表示以固定延时执行任务，延时是相对当前任务结束为起点计算开始时间。</li>\n</ul>\n<p>实现这种定时任务的具体代码如下：</p>\n<pre><code class=\"language-java\">public class ScheduleExecutorTest {\n\n    public static void main(String[] args) {\n        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);\n        scheduledExecutorService.scheduleAtFixedRate(() -&gt; {\n            System.out.println(\"doSomething\");\n        },1000,1000, TimeUnit.MILLISECONDS);\n    }\n}\n</code></pre>\n<p>调用<code>ScheduledExecutorService</code>类的<code>scheduleAtFixedRate</code>方法实现周期性任务，每隔1秒钟执行一次，每次延迟1秒再执行。</p>\n<p>这种定时任务是阿里巴巴开发者规范中用来替代<code>Timer</code>类的方案，对于多线程执行周期性任务，是个不错的选择。</p>\n<p>使用<code>ScheduledExecutorService</code>类做延迟定时任务的优缺点：</p>\n<ul>\n<li>\n<p>优点：基于多线程的定时任务，多个任务之间不会相关影响，支持周期性的执行任务，并且带延迟功能。</p>\n</li>\n<li>\n<p>缺点：不支持一些较复杂的定时规则。</p>\n</li>\n</ul>\n<p>当然，你也可以使用分布式定时任务，比如：xxl-job或者elastic-job等等。</p>\n<p>其实，在实际工作中我使用多线程的场景远远不只这12种，在这里只是抛砖引玉，介绍了一些我认为比较常见的业务场景。</p>\n<p>此外，如果你对并发编程中的一些坑，比较感兴趣的话，可以看看我的另一个文章《<a href=\"https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;mid=2247492962&amp;idx=1&amp;sn=17ed1d2ed950b4e9160218b296d19d4e&amp;chksm=c0e83d8af79fb49cc72fcafc8ed62822263106e54675ea8406a2e3daadb44e25364275af9082&amp;token=245805875&amp;lang=zh_CN#rd\" rel=\"noopener nofollow\" target=\"_blank\">聊聊并发编程的10个坑</a>》，里面写的非常详细。</p>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 16:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "SEAL全同态加密BFV方案入门详解",
      "link": "https://www.cnblogs.com/zhaoweiwei/p/19510487/bfv",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zhaoweiwei/p/19510487/bfv\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 15:50\">\n    <span>SEAL全同态加密BFV方案入门详解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文介绍微软的开源全同态项目SEAL中BFV方案的相关数学理论基础，以及相应加解密的主要流程，最后简单地介绍了SEAL源码的编译过程及简单应用示例。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>Microsoft SEAL（Simple Encrypted Arithmetic Library）是微软开源的轻量级、高性能全同态加密（FHE）库，专为整数/浮点数的密文运算设计，支持BFV、CKKS、BGV等主流FHE方案，广泛应用于隐私计算、联邦学习、数据加密等场景，源码：<a href=\"https://github.com/microsoft/SEAL\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microsoft/SEAL</a>。</p>\n<h1>1 数学基础</h1>\n<h2>1.1 多项式环</h2>\n<p>SEAL使用的基础环是：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121153443048-88951557.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p align=\"left\">BFV的所有运算都在这个多项式环中进行，符号含义如下：</p>\n<p align=\"left\">Z<sub>q</sub>：系数域，即多项式的所有系数都取自“模q的整数集合”，q称为系数模数（一个大素数或多个素数的乘积），决定密文的噪声容忍度和运算深度。</p>\n<p align=\"left\">x<sup>N</sup>+1：多项式模，要求N是2的整数幂（如4096、8192），满足x<sup>N</sup>≡-1 (mod x<sup>N</sup>+1)，这意味着所有多项式的次数都不会超过N-1（超过的项可通过x<sup>N</sup> = -1降次）。</p>\n<p align=\"left\">R<sub>q</sub>元素形式：任意元素是一个次数≤ N - 1的多项式，形如：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121154506434-1453063209.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>&nbsp;</p>\n<h2>1.2 明文空间</h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121155707555-629451098.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>明文（待加密的整数）会被编码为R<sub>t</sub>中的多项式，t满足t≡1 (mod 2N)，这是批量加密的硬性要求，明文在进行加密前要进行编码，有两种编码方式：</p>\n<p><strong>单整数编码</strong>：将单个整数m编码为常数多项式f(x)=m，即所有高次项系数为0。</p>\n<p><strong>批量编码</strong>：将N个小整数[m<sub>0</sub>,m<sub>1</sub>,...,m<sub>N-1</sub>]直接做为多项式的系数，编码为：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121160312132-985918846.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h2>1.3 RLWE问题</h2>\n<p align=\"left\">BFV的安全性基于RLWE问题（Ring Learning With Errors）的计算困难性，简单描述为：</p>\n<p align=\"left\">给定多项式R<sub>q</sub>，选择一个秘密多项式s(x)∈R<sub>q</sub>（系数为0/1的短多项式），以及大量的“噪声多项式对”（a<sub>i</sub>(x), b<sub>i</sub>(x)），其中a<sub>i</sub>(x)是随机生成的，b<sub>i</sub>(x)=-a<sub>i</sub>(x)s(x)+e<sub>i</sub>(x) (mod q)是通过秘密多项式s(x)计算得到的“响应多项式”，加入噪声e<sub>i</sub>(x)是为了让b<sub>i</sub>(x)看起来像一个完全随机的多项式，从而隐藏s(x)的存在，而在计算上无法从这些多项式对中恢复出秘密多项式s(x)。对于b<sub>i</sub>(x)其生成时每一部分的作用如下：</p>\n<p align=\"left\">a<sub>i</sub>(x)：从多项式环R<sub>q</sub>中均匀随机生成的多项式，相当于“公共输入”，可以公开。</p>\n<p align=\"left\">s(x)：秘密多项式（系数仅为0或1），是整个RLWE问题的核心，必须严格保密。</p>\n<p align=\"left\">e<sub>i</sub>(x)：小系数噪声多项式（系数仅为-1、0、1），是“隐藏秘密”的关键。</p>\n<p align=\"left\">b<sub>i</sub>(x)：由a<sub>i</sub>(x)s(x)加上噪声得到的结果，与ai(x)一起构成公开的“多项式对”。</p>\n<p align=\"left\">如果没有噪声e<sub>i</sub>(x)，即e<sub>i</sub>(x)=0，那么b<sub>i</sub>(x)=-a<sub>i</sub>(x)s(x) (mod q)，此时攻击者可以通过多组(a<sub>i</sub>(x), b<sub>i</sub>(x))构建线性方程组，直接解密出秘密多项式s(x)，这就完全失去了安全性。而加入小噪声e<sub>i</sub>(x)后：</p>\n<p align=\"left\">b<sub>i</sub>(x)不再是a<sub>i</sub>(x)s(x)的精确结果，而是一个“近似值”；</p>\n<p align=\"left\">这个近似值的误差被控制在很小的范围内（由e<sub>i</sub>(x)的系数大小决定）；</p>\n<p align=\"left\">从计算角度，目前没有任何算法（包括量子算法）能高效地从这些带噪声的近似结果中恢复出s(x)，这正是RLWE问题的“计算困难性”来源，也是BFV适合后量子秘密场景的原因。</p>\n<h2>1.4 缩放因子</h2>\n<p>在BFV同态加密方案中，缩放因子（Scaling Factor）是连接明文空间（Z<sub>t</sub>）和密文空间（Z<sub>q</sub>）的核心系数，本质是为了让明文多项式能“适配”系数模数q的范围，同时保证解密时可以精确还原明文。BFV的明文模数t远小于系数模数q（t&lt;&lt;q)，比如t=65537，q=2<sup>60</sup>量级。</p>\n<p>明文多项式m(x)∈R<sub>t</sub>的系数范围是[0, t-1]，而密文多项式c(x)∈R<sub>q</sub>的系数范围是[0, q-1]，如果直接将明文m(x)放入密文公式，由于t太小，明文信息会被噪声和掩码完全淹没，无法解密。因此需要一个缩放因子，将明文系数放大到q的量级，再参与密文计算。缩放因子贯穿加密和解密两个核心步骤，是明文和密文的“桥梁”。</p>\n<p>（1）加密时：明文放大</p>\n<p>在加密步骤中，明文多项式m(x)不会直接代入密文公式，而是先乘于缩放因子Δ，再放入到公式：</p>\n<p>&nbsp;</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122103147623-1899019256.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>作用：将明文系数从[0, t-1]放大到[0,&nbsp;Δ*(t-1)]，这个范围在q的量级内，能避免明文被噪声覆盖。</p>\n<p>（2）解密时：明文缩小</p>\n<p>解密的核心步骤是先计算聚合多项式D(ct)，代入加密公式后可得：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122103532065-202805649.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>此时需要反向缩放来还原明文：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122103637412-765250880.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>概括来说，缩放因子不会直接参与运算，但会间接影响噪声的增长速度：</p>\n<p align=\"left\">1) 加法运算：密文加法是系数直接相加，噪声线性叠加，缩放因子不影响噪声增长；</p>\n<p align=\"left\">2) 乘法运算：密文乘法是多项式乘法，噪声会平方增长，而缩放因子Δ越大，噪声的规模也会越大，导致运算深度降低。</p>\n<p align=\"left\">因此，在参数配置时，需要在“明文范围（t大小）”和“运算深度（q大小）”之间做权衡：</p>\n<p align=\"left\">若t增大→Δ减小→噪声容忍度提升→运算深度增加；</p>\n<p align=\"left\">若t减小→Δ增大→噪声容忍度降低→运算深度减小。</p>\n<p align=\"left\">所以t与Δ成反比，需根据业务需求平衡明文范围和运算深度。</p>\n<h1>2 BFV核心流程</h1>\n<h2>2.1 参数配置</h2>\n<p>参数配置决定方案的性能与安全性，BFV核心参数有4个，需严格满足数学约束：</p>\n<p><img alt=\"image\" height=\"249\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121155055832-1091265286.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"798\" /></p>\n<p>参数约束：需满足q&gt;t*(2N)<sup>d</sup>*B（d是目标运算深度，B是噪声上限），否则运算过程中噪声会“爆炸”导致解密失败。</p>\n<h2>2.2 密钥生成</h2>\n<p>基于RLWE问题生成私钥、公钥、重线性化密钥3中密钥，核心是构造含噪声的多项式对。</p>\n<p>（1）私钥（sk）</p>\n<p>随机生成一个短多项式s(x)∈R<sub>q</sub>，系数仅为0或1（如s(x) = 1 + x<sup>2</sup> + x<sup>5</sup>），私钥就是s(x)。</p>\n<p>（2）公钥（pk）</p>\n<p>随机生成多项式a(x)∈R<sub>q</sub>，生成小希数噪声多项式e(x)∈R<sub>q</sub>，计算b(x) = -a(x)s(x) + e(x) (mod q)，公钥是多项式对pk = (b(x), a(x))，可公开传播。这里的噪声e(x)让攻击者无法从公钥对中恢复私钥s(x)，目的是解决“公钥本身的安全性”。</p>\n<p>（3）重线性化密钥（rlk）</p>\n<p>密文乘法会导致密文从“2项多项式”膨胀为“3项多项式”，后续运算效率骤降。重线性化密钥用于将膨胀后的密文压缩回2项，生成逻辑与公钥类似，本质是一组扩展的RLWE多项式对。</p>\n<h2>2.3 加密</h2>\n<p>将明文多项式转为密文多项式，BFV的密文是R<sub>q</sub>中的2项多项式对ct = (c<sub>0</sub>(x), c<sub>1</sub>(x))，加密过程分两步：</p>\n<p>（1）明文编码：将整数明文m编码为明文多项式m(x)∈R<sub>t</sub>；</p>\n<p>（2）添加噪声与混淆：</p>\n<p>随机生成两个小噪声多项式e<sub>0</sub>(x),e<sub>1</sub>(x)∈R<sub>q</sub>，随机生成一个“掩码多项式”u(x)∈R<sub>q</sub>（系数为0/1），计算密文：</p>\n<p><img alt=\"image\" height=\"72\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122101343624-1971179879.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"506\" /></p>\n<p>核心设计：密文中包含明文信息m(x)，但被噪声e<sub>0</sub>/e<sub>1</sub>和掩码u(x)混淆，只有私钥能去除混淆和噪声。该步骤中的掩码多项式u(x)和噪声多项式e<sub>0</sub>(x),e<sub>1</sub>(x)是两套独立的安全机制，它们解决的是完全不同的问题，不能互相替代，如下图：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122145538684-995418377.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>u(x)通过随机缩放实现公钥和明文间的非固定线性关系，噪声通过“近似”进一步打破它们之间精确的代数关系，使得攻击者无法从近似值中还原精确明文。</p>\n<h2>2.4 同态运算</h2>\n<p>这步的核心是：密文运算=多项式环运算，BFV支持秘密&amp;密文（Ct&amp;Ct）和密文&amp;明文（Ct&amp;Pt）的加减乘运算，所有运算都在多项式环R<sub>q</sub>中进行，且无需密钥。</p>\n<p><img alt=\"image\" height=\"252\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122102234951-828568152.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"925\" /></p>\n<p>运算后的密文仍然是合法的RLWE密文，可继续参与后续运算——这就是「同态性」的体现。</p>\n<h2>2.5 解密</h2>\n<p>解密是加密的逆运算，核心是去除噪声、还原明文多项式，步骤如下：</p>\n<p>（1）密文聚合</p>\n<p>用私钥s(x)计算聚合多项式：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122102616840-333286614.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>代入加密公式可推导：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122102653366-486423113.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>（2）噪声去除</p>\n<p>由于总噪声e<sub>total</sub>&lt;q/(2t)，可通过“舍入+模运算”还原明文：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122102808245-1880527419.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />（3）明文解码</p>\n<p>将解密后的多项式m(x)转换回整数（单整数取常数项，批量加密取所有系数）。</p>\n<p>解密成功条件：总噪声e<sub>total</sub>&lt;q/(2t)，若运算次数过多导致噪声爆炸，舍入后无法还原明文，则会解密失败——这是BFV“层次性”的本质，运算深度有限。</p>\n<h2>2.6 python示例</h2>\n<p>以下是一个完整的python示例程序：</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_09b97ffc-eef3-46ba-bb50-d1e4cf620627\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_09b97ffc-eef3-46ba-bb50-d1e4cf620627\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_09b97ffc-eef3-46ba-bb50-d1e4cf620627\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> numpy as np\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> random\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> PolynomialRing:\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> <span style=\"color: rgba(128, 0, 128, 1);\">__init__</span><span style=\"color: rgba(0, 0, 0, 1);\">(self, n, modulus):\n        self.n </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> n\n        self.modulus </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> modulus\n        self.phi </span>= np.zeros(n + 1, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        self.phi[0] </span>= 1<span style=\"color: rgba(0, 0, 0, 1);\">\n        self.phi[n] </span>= 1\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_add(self, a, b):\n        result </span>= np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            result[i] </span>= (a[i] + b[i]) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_mul(self, a, b):\n        result </span>= np.zeros(2 * self.n - 1, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> j <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n                result[i </span>+ j] = (result[i + j] + a[i] * b[j]) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> self.poly_mod(result)\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_mod(self, poly):\n        result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> poly.copy()\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span> range(len(result) - 1, self.n - 1, -1<span style=\"color: rgba(0, 0, 0, 1);\">):\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> result[i] !=<span style=\"color: rgba(0, 0, 0, 1);\"> 0:\n                coeff </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> result[i]\n                result[i] </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> 0\n                idx </span>= i -<span style=\"color: rgba(0, 0, 0, 1);\"> self.n\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> idx &lt;<span style=\"color: rgba(0, 0, 0, 1);\"> len(result):\n                    result[idx] </span>= (result[idx] - coeff) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> result[:self.n]\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_sub(self, a, b):\n        result </span>= np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            result[i] </span>= (a[i] - b[i]) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_scale(self, a, scalar):\n        result </span>= np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            result[i] </span>= (a[i] * scalar) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> random_poly(self):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> np.random.randint(0, self.modulus, self.n)\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> binary_poly(self):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> np.random.randint(0, 2<span style=\"color: rgba(0, 0, 0, 1);\">, self.n)\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> small_poly(self, bound=3<span style=\"color: rgba(0, 0, 0, 1);\">):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> np.random.randint(-bound, bound + 1<span style=\"color: rgba(0, 0, 0, 1);\">, self.n)\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> BFV:\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> <span style=\"color: rgba(128, 0, 128, 1);\">__init__</span>(self, n=256, q=1048576, t=256<span style=\"color: rgba(0, 0, 0, 1);\">):\n        self.n </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> n\n        self.q </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> q\n        self.t </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> t\n        self.ring </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> PolynomialRing(n, q)\n        self.plaintext_ring </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> PolynomialRing(n, t)\n        self.delta </span>= q //<span style=\"color: rgba(0, 0, 0, 1);\"> t\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> keygen(self):\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 产生密钥</span>\n        s =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.binary_poly()\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 挑战多项式</span>\n        a =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.random_poly()\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 随机多项式</span>\n        e =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.small_poly()\n        a_s </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_mul(a, s)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 响应多项式</span>\n        pk0 =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_sub(e, a_s)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 公钥</span>\n        pk =<span style=\"color: rgba(0, 0, 0, 1);\"> [pk0, a]\n        sk </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> s\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> pk, sk\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 编码明文</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> encode(self, message):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> isinstance(message, int):\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 单整数编码</span>\n            m = np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n            m[0] </span>= message %<span style=\"color: rgba(0, 0, 0, 1);\"> self.t\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 批量编码</span>\n            m = np.array(message, dtype=int) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.t\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> m\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用公钥加密</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> encrypt(self, pk, message):\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对明文进行编码</span>\n        m =<span style=\"color: rgba(0, 0, 0, 1);\"> self.encode(message)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对明文编码结果进行放大</span>\n        m_scaled =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_scale(m, self.delta)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\">print(\"m_scaled: {}\".format(m_scaled))</span>\n        \n        <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成掩码多项式</span>\n        u =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.binary_poly()\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 产生两个小噪声多项式</span>\n        e1 =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.small_poly()\n        e2 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.small_poly()\n        \n        pk0_u </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_mul(pk[0], u)\n        pk1_u </span>= self.ring.poly_mul(pk[1<span style=\"color: rgba(0, 0, 0, 1);\">], u)\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成密文c0</span>\n        c0 =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(pk0_u, e1)\n        c0 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(c0, m_scaled)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成密文c1</span>\n        c1 =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(pk1_u, e2)\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 返回密文</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> [c0, c1]\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> decrypt(self, sk, ciphertext):\n        c0, c1 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> ciphertext\n        s_c1 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_mul(sk, c1)\n        decrypted </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(c0, s_c1)\n        \n        result </span>= np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            result[i] </span>= round(decrypted[i] * self.t / self.q) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.t\n        \n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> add(self, c1, c2):\n        c0 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(c1[0], c2[0])\n        c1 </span>= self.ring.poly_add(c1[1], c2[1<span style=\"color: rgba(0, 0, 0, 1);\">])\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> [c0, c1]\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> main():\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">=== BFV 同态加密方案演示 ===\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    bfv </span>= BFV(n=256, q=1048576, t=256<span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">参数设置:</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  多项式次数 n = {bfv.n}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  密文模数 q = {bfv.q}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  明文模数 t = {bfv.t}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  缩放因子 Δ = {bfv.delta}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    pk, sk </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.keygen()\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密钥生成完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">私钥 s 前5个系数: {sk[:5]}...\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span><span style=\"color: rgba(0, 0, 0, 1);\">(sk)\n    \n    m1 </span>= 42<span style=\"color: rgba(0, 0, 0, 1);\">\n    m2 </span>= 17\n    <span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文 m1 = {m1}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文 m2 = {m2}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    c1 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.encrypt(pk, m1)\n    c2 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.encrypt(pk, m2)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">加密完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文 c1[0] 前5个系数: {c1[0][:5]}...</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文 c1[1] 前5个系数: {c1[1][:5]}...\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文c1 {}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">.format(c1))\n    \n    d1 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.decrypt(sk, c1)\n    d2 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.decrypt(sk, c2)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密结果 d1 = {d1[0]}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密结果 d2 = {d2[0]}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">=== 同态加法演示 ===</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    c_sum </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.add(c1, c2)\n    d_sum </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.decrypt(sk, c_sum)\n    expected_sum </span>= (m1 + m2) %<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.t\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文同态加法: c1 + c2</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密结果: {d_sum[0]}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">期望结果: {expected_sum}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">验证: {'成功' if d_sum[0] == expected_sum else '失败'}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">=== 多项式明文演示 ===</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    m_poly </span>= np.array([1, 2, 3, 4, 5] + [0] * 251, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n    c_poly </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.encrypt(pk, m_poly)\n    d_poly </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.decrypt(sk, c_poly)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">多项式明文前5个系数: {m_poly[:5]}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密结果前5个系数: {d_poly[:5]}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">验证: {'成功' if np.array_equal(d_poly[:5], m_poly[:5]) else '失败'}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> <span style=\"color: rgba(128, 0, 128, 1);\">__name__</span> == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">__main__</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n    main()</span></pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<h1>3 SEAL使用</h1>\n<h2>3.1 源码编译</h2>\n<p>这里仅简单介绍下Windows下使用VS2022环境进行编译，下载源码并安装cmake，运行VS2022安装菜单下的“Developer Command Prompt for VS 2022”命令行，执行命令进行配置：</p>\n<div class=\"cnblogs_code\">\n<pre>cmake -S . -B build -G <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Visual Studio 17 2022</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> -A x64 -DCMAKE_INSTALL_PREFIX=./<span style=\"color: rgba(0, 0, 255, 1);\">out</span></pre>\n</div>\n<p>这里编译的是64位版本，并将安装目录设置为当前目录下的out文件夹，配置完成后再执行以下命令进行编译</p>\n<div class=\"cnblogs_code\">\n<pre>cmake --build build --<span style=\"color: rgba(0, 0, 0, 1);\">config Release    #编译Release版本\ncmake </span>--build build --config Debug      #编译Debug版本</pre>\n</div>\n<p>编译完成后会生成seal-4.1.lib库文件：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122113702648-1311816022.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>然后执行以下命令进行安装：</p>\n<div class=\"cnblogs_code\">\n<pre>cmake --install build</pre>\n</div>\n<p>out下include中是头文件，lib中是静态库文件：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122114032047-1402497300.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h2>3.2 示例程序</h2>\n<p>使用VS2022创建空项目，并添加demo.cpp文件，内容如下：</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_1771d7b9-7319-4893-9ce5-5347e3e25b4a\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_1771d7b9-7319-4893-9ce5-5347e3e25b4a\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_1771d7b9-7319-4893-9ce5-5347e3e25b4a\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\"> 1</span> #include &lt;iostream&gt;\n<span style=\"color: rgba(0, 128, 128, 1);\"> 2</span> #include &lt;SEAL/SEAL.h&gt;\n<span style=\"color: rgba(0, 128, 128, 1);\"> 3</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 4</span> <span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">namespace</span><span style=\"color: rgba(0, 0, 0, 1);\"> std;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 5</span> <span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">namespace</span><span style=\"color: rgba(0, 0, 0, 1);\"> seal;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 6</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 7</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> main() {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 8</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 1：配置加密参数（BFV 方案）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 9</span> <span style=\"color: rgba(0, 0, 0, 1);\">    EncryptionParameters parms(scheme_type::bfv);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">10</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 多项式模数：4096（2的幂次）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">11</span>     size_t poly_modulus_degree = <span style=\"color: rgba(128, 0, 128, 1);\">4096</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">12</span> <span style=\"color: rgba(0, 0, 0, 1);\">    parms.set_poly_modulus_degree(poly_modulus_degree);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">13</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 明文模数：支持批量运算，取值范围 2^20</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">14</span>     parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, <span style=\"color: rgba(128, 0, 128, 1);\">20</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n</span><span style=\"color: rgba(0, 128, 128, 1);\">15</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 系数模数：使用 BFV 默认参数</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">16</span> <span style=\"color: rgba(0, 0, 0, 1);\">    parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree));\n</span><span style=\"color: rgba(0, 128, 128, 1);\">17</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">18</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文模数 t = </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; parms.plain_modulus().value() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">19</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文模数 t 比特数 = </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; parms.plain_modulus().bit_count() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">20</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">t mod 2N = </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; (parms.plain_modulus().value() % (<span style=\"color: rgba(128, 0, 128, 1);\">2</span> * poly_modulus_degree)) &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">21</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">22</span>     vector&lt;Modulus&gt; coeff_mods =<span style=\"color: rgba(0, 0, 0, 1);\"> CoeffModulus::BFVDefault(poly_modulus_degree);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">23</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">24</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 系数模数 q（多素数乘积）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">25</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n系数模数 q 的构成（素数列表）：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">26</span>     <span style=\"color: rgba(0, 0, 255, 1);\">int</span> total_bits = <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">27</span>     <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (size_t i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt; coeff_mods.size(); i++<span style=\"color: rgba(0, 0, 0, 1);\">) {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">28</span>         cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">第</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; i + <span style=\"color: rgba(128, 0, 128, 1);\">1</span> &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">个素数：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> coeff_mods[i].value()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">29</span>             &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">（比特数：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; coeff_mods[i].bit_count() &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">）</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">30</span>         total_bits +=<span style=\"color: rgba(0, 0, 0, 1);\"> coeff_mods[i].bit_count();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">31</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">32</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">系数模数总比特数 = </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; total_bits &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">33</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">34</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 2：创建加密上下文，验证参数合法性</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">35</span> <span style=\"color: rgba(0, 0, 0, 1);\">    SEALContext context(parms);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">36</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印上下文信息（可选，查看参数配置）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">37</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Context created successfully, scheme type: BFV</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">38</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">39</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 3：生成密钥（适配 SEAL 4.1 API，核心修改部分）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">40</span> <span style=\"color: rgba(0, 0, 0, 1);\">    KeyGenerator keygen(context);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">41</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4.1 版本：通过 create_public_key() 生成公钥（替代原 public_key()）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">42</span> <span style=\"color: rgba(0, 0, 0, 1);\">    PublicKey public_key;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">43</span> <span style=\"color: rgba(0, 0, 0, 1);\">    keygen.create_public_key(public_key);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">44</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4.1 版本：直接通过成员函数获取私钥（该接口未变更）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">45</span>     SecretKey secret_key =<span style=\"color: rgba(0, 0, 0, 1);\"> keygen.secret_key();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">46</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4.1 版本：通过 create_relin_keys() 生成评估密钥（替代原 relin_keys()）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">47</span> <span style=\"color: rgba(0, 0, 0, 1);\">    RelinKeys relin_keys;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">48</span> <span style=\"color: rgba(0, 0, 0, 1);\">    keygen.create_relin_keys(relin_keys);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">49</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">50</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 4：初始化加密器、解密器、评估器</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">51</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Encryptor encryptor(context, public_key);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">52</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Decryptor decryptor(context, secret_key);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">53</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Evaluator evaluator(context);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">54</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">55</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 5：明文准备（两个整数）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">56</span>     Plaintext plain1(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">123</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">57</span>     Plaintext plain2(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">456</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">58</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Original plaintext 1: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; plain1.to_string() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">59</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Original plaintext 2: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; plain2.to_string() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">60</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">61</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 6：加密明文为密文</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">62</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Ciphertext cipher1, cipher2;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">63</span> <span style=\"color: rgba(0, 0, 0, 1);\">    encryptor.encrypt(plain1, cipher1);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">64</span> <span style=\"color: rgba(0, 0, 0, 1);\">    encryptor.encrypt(plain2, cipher2);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">65</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Plaintext encrypted to ciphertext successfully</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">66</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">67</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 7：密文同态运算（加法 + 乘法）\n</span><span style=\"color: rgba(0, 128, 128, 1);\">68</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 密文加法</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">69</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Ciphertext cipher_add;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">70</span> <span style=\"color: rgba(0, 0, 0, 1);\">    evaluator.add(cipher1, cipher2, cipher_add);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">71</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 密文乘法 + 重线性化（减少密文大小）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">72</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Ciphertext cipher_mult;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">73</span> <span style=\"color: rgba(0, 0, 0, 1);\">    evaluator.multiply(cipher1, cipher2, cipher_mult);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">74</span> <span style=\"color: rgba(0, 0, 0, 1);\">    evaluator.relinearize_inplace(cipher_mult, relin_keys);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">75</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">76</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 8：解密密文，验证结果</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">77</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Plaintext plain_add, plain_mult;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">78</span> <span style=\"color: rgba(0, 0, 0, 1);\">    decryptor.decrypt(cipher_add, plain_add);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">79</span> <span style=\"color: rgba(0, 0, 0, 1);\">    decryptor.decrypt(cipher_mult, plain_mult);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">80</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Ciphertext add result: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; plain_add.to_string() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">81</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Ciphertext multiply result: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; plain_mult.to_string() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">82</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\">83</span>     <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">84</span> }</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<p>将之间产生的out文件夹下的include和lib拷贝到项目文件夹下，配置项目的C/C++编译包含头文件路径，库文件路径以及输入库，即可进行编译。</p>\n<p><img alt=\"image\" height=\"434\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122114406545-2054417852.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"593\" /></p>\n<p>编译完成后运行程序，输出如下：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122114732024-1409765149.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>在该示例程序中，多项式模数N是4096，明文模数t是1032193，位宽为20bits，系数模数q是3个素数的乘积68719403009*68719230977*137438822401=0x1ffff4400622fecd904df7f92001，位宽是109bits，示例中演示了0x123和0x456的加法和乘法运行，可见加密运算后的解密结果和未加密运算的结果完全一致。</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 15:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zhaoweiwei\">weiwei22844</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "绝望博弈！一众大模型加持的猜拳游戏，人类胜率竟不足10%？",
      "link": "https://www.cnblogs.com/greywen/p/19512202",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/greywen/p/19512202\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 08:29\">\n    <span>绝望博弈！一众大模型加持的猜拳游戏，人类胜率竟不足10%？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>基于 LLM + Next.js 的博弈实战猜拳游戏</h1>\n<p><strong>摘要</strong>：当你以为自己在和随机数生成器玩游戏时，对面的 AI 正在阅读你所有的历史出拳记录，并写了一篇关于你心理状态的小作文。本文带你拆解这个基于 Next.js 16 + Tailwind v4 + LLM 的“过度设计”+“没啥技术含量”+”有那么点意思“项目。</p>\n<p>👉 <strong>先给老板们体验:（具体规则有手就能玩！）</strong></p>\n<p>优先地址：<a href=\"https://rps.anhejin.cn\" rel=\"noopener nofollow\" target=\"_blank\">https://rps.anhejin.cn</a></p>\n<p>有条件的：<a href=\"https://rps-eta-ten.vercel.app\" rel=\"noopener nofollow\" target=\"_blank\">https://rps-eta-ten.vercel.app<br /></a></p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"423\" width=\"752\" /></p>\n<hr />\n<p>最近闲着没事，突然想这用AI写点代码。作为一名要把“简单需求复杂化”刻在 DNA 里的老前端，我决定拿最简单的“剪刀石头布”开刀。</p>\n<p>在这个 AI 满天飞的时代，还在用 <code>Math.random()</code> 写对手逻辑未免太没追求了。于是，我基于最新的技术栈（Next.js 16 + React 19），接入了 OpenAI等一众大模型，搞出了一个会“读心”、会嘲讽，甚至懂博弈论的猜拳游戏。</p>\n<h2>为什么是剪刀石头布？</h2>\n<p>别笑，剪刀石头布其实是一个极佳的博弈论模型。</p>\n<ul>\n<li><strong>新手</strong>：完全随机（Chaos）。</li>\n<li><strong>普通人</strong>：赢了保持，输了变招（Win-Stay, Lose-Shift）。</li>\n<li><strong>高手</strong>：预判你的预判。</li>\n\n\n\n\n\n\n\n\n\n\n</ul>\n<p>我的目标是：<strong>构建一个能看穿你心理的 AI，并且用目前最前沿的前端技术栈把它跑起来。</strong></p>\n<h2>技术选型：这就叫“杀鸡用牛刀”</h2>\n<p>为了配得上这个“高智商”AI，我在技术栈上直接拉满，全部采用了目前（2025-2026）的最新稳定版：</p>\n<ol>\n<li><strong>Next.js 16.1 (App Router)</strong>：服务端组件（RSC）处理核心逻辑，隐藏 AI 的 Prompt，保证你没法通过 F12 偷看答案。</li>\n<li><strong>React 19</strong>：享受最新的 Hooks 和并发特性。</li>\n<li><strong>Tailwind CSS v4</strong>：对，就是那个不用配置构建工具、性能起飞的 v4 版本。关键是AI喜欢用这个</li>\n<li><strong>SQLite + LibSQL</strong>：轻量级数据库，用来记仇——啊不，记录你的胜负数据。</li>\n\n\n\n\n\n\n\n\n\n\n</ol>\n<h2>核心玩法：AI 是怎么“读心”的？</h2>\n<p>这个项目的核心不在于 UI 有多炫（虽然 Tailwind 4 确实很润），而在于 <code>/lib/ai-service.ts</code> 里的那段逻辑。</p>\n<p>传统的游戏 AI 往往是预设好的 <code>if-else</code>。但在我的设计里，每一轮游戏，我都会把你在这个 Session 里的所有历史记录打包，像讲故事一样发给 LLM（大语言模型）：</p>\n<pre><code class=\"language-typescript\">\n// lib/ai-service.ts\n\n// 构建游戏历史描述\nconst historyDescription = history.length &gt; 0\n  ? history.map((h) =&gt;\n      `第${h.round}轮: 玩家出${translateChoice(h.player_choice)}, \n       AI出${translateChoice(h.ai_choice)}, \n       结果: ${translateResult(h.result)}`\n    ).join(\"\\n\")\n  : \"这是第一轮，没有历史记录。\";\n\n// ...发送给 LLM\nconst response = await client.chat.completions.create({\n  messages: [\n    { role: \"system\", content: systemPrompt },\n    { role: \"user\", content: userPrompt }, // 这里包含了 historyDescription\n  ],\n  // ...\n});\n</code></pre>\n<blockquote>\n<p>System: 你是一个猜拳高手，你的对手是一个普通人类。<br />\nUser: 前几轮战况如下：第1轮玩家出剪刀，你出布（输）；第2轮玩家出石头，你出布（赢）。现在是第3轮，请分析玩家的心理，并给出你的出拳。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n</blockquote>\n<p><strong>不仅如此，我给 AI 设定了两种模式：</strong></p>\n<ol>\n<li><strong>策略模式（Strategy）</strong>：降低模型的 <code>temperature</code>（随机性），让它进行严密的逻辑推理。比如它会分析：“玩家上一把输了，根据心理学，这把他大概率会出克制我上一把的招数，所以我预判他……”</li>\n<li><strong>混沌模式（Chaos）</strong>：拉高 <code>temperature</code>，让 AI 彻底放飞自我，主打一个乱拳打死老师傅。</li>\n\n\n\n\n\n\n\n\n\n\n\n\n</ol>\n<h2>优雅降级：当 GPT 脑干缺失时</h2>\n<p>作为老全栈，必须要考虑一种情况：<strong>如果 API 挂了，或者响应超时了怎么办？</strong></p>\n<p>难道让用户干等着转圈圈？绝对不行。</p>\n<p>我在后端实现了一套基于传统统计学的<strong>本地算法</strong>作为“备胎”。如果 LLM 在规定时间内没有响应，系统会无缝切换到本地逻辑。这个本地逻辑一点也不弱，它内置了经典的策略库（代码在 <code>lib/game.ts</code>）：</p>\n<pre><code class=\"language-typescript\">\n// lib/game.ts 里的心理学博弈逻辑\n\n// 1. 如果玩家上轮输了，倾向于出能克制AI上一招的选项 (Win-Stay, Lose-Shift的变种)\nif (lastResult === 'ai_win') {\n  const lastAIChoice = lastRound.ai_choice as Choice;\n  // 预测玩家会出克制我不上一把的牌\n  const predictedPlayerChoice = whatBeatsAI[lastAIChoice];\n  // 那我就预判你的预判\n  return counterMoves[predictedPlayerChoice];\n}\n\n// 2. 如果玩家上轮赢了，可能继续用同一招\nif (lastResult === 'player_win') {\n  // 玩家可能继续用同一招，直接克制它\n  return counterMoves[lastPlayerChoice];\n}\n</code></pre>\n<p>这些策略包括：</p>\n<ul>\n<li><strong>频率分析</strong>：如果你一直出石头，它就会疯狂出布。</li>\n<li><strong>反制连胜</strong>：如果你赢了，它会假设你会继续出一样的，直接克制你。</li>\n</ul>\n<p>在代码实现上，这只是一个简单的 <code>try-catch</code> 降级，但对用户体验来说是质的飞跃。用户根本感觉不到 AI 掉线了，只会感觉“这家伙怎么变风格了？”</p>\n<h2>全栈体验：Next.js App Router 的丝滑</h2>\n<p>在 Next.js 16 中，前后端的边界变得非常模糊（褒义）。本项目使用了 App Router 的 Route Handlers 来处理游戏逻辑。</p>\n<p>前端组件调用后端接口就像调用本地函数一样自然：</p>\n<pre><code class=\"language-typescript\">\n// src/app/game/[id]/page.tsx\nconst playRound = useCallback(async (choice: Choice | null, timeout: boolean = false) =&gt; {\n    // ...\n    const res = await fetch('/api/game/play', {\n        method: 'POST',\n        body: JSON.stringify({ /*...*/ }),\n    });\n    // ...\n}, []);\n</code></pre>\n<p>而在服务端 (<code>src/app/api/game/play/route.ts</code>)，我们完成了完整的业务闭环：</p>\n<pre><code class=\"language-typescript\">\n// src/app/api/game/play/route.ts\nexport async function POST(request: NextRequest) {\n    // 1. 身份校验与数据库读取\n    const { sessionId, playerChoice } = await request.json();\n    const baseSession = await db.execute(/*...*/);\n\n    // 2. 调用 AI (带超时降级)\n    // 如果 API 响应太慢，这里会自动切换到本地逻辑\n    const aiChoiceResult = await Promise.race([\n        getAIChoiceFromAPI(aiConfig, history, difficulty),\n        timeoutPromise // 设定的超时时间\n    ]);\n\n    // 3. 判定胜负 &amp; 写入数据库\n    const result = determineWinner(playerChoice, aiChoiceResult.choice);\n    // ...\n    \n    return NextResponse.json({ /*...*/ });\n}\n</code></pre>\n<p>这一套流程行云流水，类型安全虽然不如 Server Actions 极致，但通过共享类型定义（Shared Types），依然能保证前后端的一致性。不用写繁琐的 Swagger，不用搞复杂的 Redux，一把梭。</p>\n<h2>实际上手：由于太会嘲讽导致不想玩了</h2>\n<p>为了增加趣味性，我让 AI 不仅输出“石头/剪刀/布”，还要输出一段 <strong>Reasoning（推理过程）</strong> 和 <strong>Comment（赛后嘲讽）</strong>。</p>\n<p>当你输掉比赛时，你可能会看到这样的结算语：<br />\n<em>“我看你第一把犹豫了很久出了剪刀，我就知道你是个保守的人。下一把别这么明显了，人类。”</em></p>\n<p>说实话，代码写完后我自己测试了几把，胜率居然只有 40% 左右。看着屏幕上 AI 的嘲讽，我即使作为开发者也不禁怀疑：这玩意儿是不是真有意识？</p>\n<h2>体验地址</h2>\n<p>虽说代码没什么核心科技，但带来的博弈体验确实很有趣。我已经把项目部署上去了，欢迎来挑战（或者被虐）：</p>\n<p>👉 <strong>在线体验</strong></p>\n<p>优先地址：<a href=\"https://rps.anhejin.cn\" rel=\"noopener nofollow\" target=\"_blank\">https://rps.anhejin.cn</a></p>\n<p>有条件的：<a href=\"https://rps-eta-ten.vercel.app\" rel=\"noopener nofollow\" target=\"_blank\">https://rps-eta-ten.vercel.app<br /></a></p>\n<h2>总结</h2>\n<p>这个项目证明了一件事：<strong>技术是冰冷的，但通过简单的创意组合，可以创造出有温度（甚至有点烫手）的交互体验。</strong> Next.js 16 和 React 19 的组合让全栈开发的门槛进一步降低，让我们有更多精力去关注“玩法”本身，而不是被构建配置折磨。</p>\n<p>如果你对源码感兴趣，或者想改改 Prompt 把 AI 调教成“讨好型人格”，欢迎去 <a href=\"https://github.com/greywen/rps\" rel=\"noopener nofollow\">GitHub</a> 扒代码。</p>\n<hr />\n<p><em>注：</em></p>\n<ol>\n<li>本文仅供技术交流，玩游戏输给 AI 请勿用拳头击打显示器，开发者概不负责。</li>\n<li>这只是一个娱乐小游戏，结果具有随机性，不代表任何AI大模型的真实能力。</li>\n<li>游戏结果仅供娱乐，不应用于评估或比较AI模型的实际性能。</li>\n<li>网站不收集、存储或分享任何个人信息或用户数据。</li>\n\n\n\n\n\n\n\n\n\n\n\n\n</ol>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 08:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/greywen\">文过其实</a>&nbsp;\n阅读(<span id=\"post_view_count\">311</span>)&nbsp;\n评论(<span id=\"post_comment_count\">5</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AspNetCore开发笔记：WebApi项目集成企业微信和公众号",
      "link": "https://www.cnblogs.com/deali/p/19514332",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/deali/p/19514332\" id=\"cb_post_title_url\" title=\"发布于 2026-01-21 23:16\">\n    <span>AspNetCore开发笔记：WebApi项目集成企业微信和公众号</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>很久没写文章了，现在有了AI，其实已经不怎么需要写文章，反正不懂就问AI嘛。</p>\n<p>不过AI总是有盲区的，就比如国内的微信开发。</p>\n<p>微信的文档是公认的烂，而且经常悄咪咪改接口又不更新文档，所以AI对微信开发的API其实不怎么熟悉，经常给出一些错误的回复。</p>\n<p>本文记录一下最近我使用 C# WebApi 项目接入企业微信和公众号的过程，主要是用到自动回复功能。</p>\n<h2 id=\"前置工作\">前置工作</h2>\n<h3 id=\"依赖库\">依赖库</h3>\n<p>我用到了 <strong>SKIT.FlurlHttpClient.Wechat</strong> 这个系列的库：<a href=\"https://github.com/fudiwei/DotNetCore.SKIT.FlurlHttpClient.Wechat\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/fudiwei/DotNetCore.SKIT.FlurlHttpClient.Wechat</a></p>\n<p>原本想直接用 Flurl 对接的，毕竟现在手里有了锤子（AI），看啥都是钉子，啥都想造轮子。</p>\n<p>不过搜了一下我的收藏夹，发现有这个项目，封装了微信的大部分接口，那还要啥自行车，直接用就完事儿了。</p>\n<p>其中：</p>\n<ul>\n<li>企业微信：SKIT.FlurlHttpClient.Wechat.Work</li>\n<li>公众号：SKIT.FlurlHttpClient.Wechat.Api</li>\n</ul>\n<h3 id=\"微信配置信息\">微信配置信息</h3>\n<p>需要准备这些配置信息：</p>\n<p>企业微信：</p>\n<pre><code class=\"language-c#\">public class WechatWorkOptions {\n    public string CorpId { get; set; } = string.Empty;\n    // 应用ID\n    public int AgentId { get; set; }\n    // 应用密钥\n    public string Secret { get; set; } = string.Empty;\n    // 回调 Token\n    public string CallbackToken { get; set; } = string.Empty;\n    // 回调 EncodingAESKey\n    public string CallbackEncodingAESKey { get; set; } = string.Empty;\n}\n</code></pre>\n<p>公众号：</p>\n<pre><code class=\"language-c#\">public class WechatApiClientOptions {\n    public string AppId { get; set; } = string.Empty;\n    public string AppSecret { get; set; } = string.Empty;\n    public string CallbackToken { get; set; } = string.Empty;\n    public string CallbackEncodingAESKey { get; set; } = string.Empty;\n}\n</code></pre>\n<h3 id=\"注册服务\">注册服务</h3>\n<pre><code class=\"language-c#\">// 企业微信\nbuilder.Services.AddSingleton&lt;WechatWorkClient&gt;(sp =&gt; {\n    var options = sp.GetRequiredService&lt;IOptions&lt;WechatWorkOptions&gt;&gt;().Value;\n    return WechatWorkClientBuilder.Create(options).Build();\n});\n\n// 公众号\nbuilder.Services.AddSingleton&lt;WechatApiClient&gt;(sp =&gt; {\n    var options = sp.GetRequiredService&lt;IOptions&lt;WechatMpOptions&gt;&gt;().Value;\n    return WechatApiClientBuilder.Create(options).Build();\n});\n</code></pre>\n<p>准备工作就搞定了。</p>\n<h2 id=\"管理token\">管理token</h2>\n<p>微信的接口都需要用 AccessToken 才能调用，但微信又不想开发者每次都去请求获取token，所以只能获取一次然后自己保存了。</p>\n<p>C# 可以用 IMemoryCache 组件，很方便的管理这些临时存储的数据；Django框架也有内置的cache机制，其他语言框架可以用Redis这类NoSQL数据库来存储。扯远了，本文还是介绍C#的。</p>\n<p>我用一个 <code>WechatWorkTokenService</code> 服务来管理企业微信的token（公众号、小程序这种也是同理）</p>\n<pre><code class=\"language-c#\">public class WechatWorkTokenService(\n    WechatWorkClient client,\n    IMemoryCache cache,\n    IOptions&lt;WechatWorkOptions&gt; options\n) : IWechatWorkTokenService {\n    private const string CacheKey = \"WechatWorkAccessToken\";\n\n    // 用于并发控制，防止瞬间高并发导致多次请求 Token 接口\n    private static readonly SemaphoreSlim Semaphore = new SemaphoreSlim(1, 1);\n\n    /// &lt;summary&gt;\n    /// 获取 AccessToken\n    /// &lt;/summary&gt;\n    public async Task&lt;string&gt; GetAccessTokenAsync(CancellationToken cancellationToken = default) {\n        // 1. 尝试从缓存获取\n        if (cache.TryGetValue(CacheKey, out string? accessToken) &amp;&amp; !string.IsNullOrEmpty(accessToken)) {\n            return accessToken;\n        }\n\n        // 2. 缓存未命中，加锁请求\n        await Semaphore.WaitAsync(cancellationToken);\n        try {\n            // 双重检查，防止排队等待的线程再次请求\n            if (cache.TryGetValue(CacheKey, out accessToken) &amp;&amp; !string.IsNullOrEmpty(accessToken)) {\n                return accessToken;\n            }\n\n            // 3. 调用接口获取 Token\n            var request = new CgibinGetTokenRequest();\n            var response = await client.ExecuteCgibinGetTokenAsync(request, cancellationToken);\n\n            if (!response.IsSuccessful()) {\n                throw new Exception($\"获取 AccessToken 失败: {response.ErrorMessage} (Code: {response.ErrorCode})\");\n            }\n\n            accessToken = response.AccessToken;\n\n            // 4. 设置缓存\n            // 提前 5 分钟过期，确保在过期前刷新\n            // 如果 ExpiresIn 小于 300 秒，则设为一半时间\n            var expirySeconds = response.ExpiresIn &gt; 300 ? response.ExpiresIn - 300 : response.ExpiresIn / 2;\n            var cacheEntryOptions = new MemoryCacheEntryOptions()\n                .SetAbsoluteExpiration(TimeSpan.FromSeconds(expirySeconds));\n\n            cache.Set(CacheKey, accessToken, cacheEntryOptions);\n\n            return accessToken;\n        }\n        finally {\n            Semaphore.Release();\n        }\n    }\n}\n</code></pre>\n<h2 id=\"企业微信\">企业微信</h2>\n<p>企业微信的限制比较少，可以主动给用户发信息，所以可以把接收和发送信息分开，例如调用LLM处理回复的时候，会比较慢，可以把回复放到异步任务队列里去实现。</p>\n<h3 id=\"验证回调\">验证回调</h3>\n<p>直接上接口代码。</p>\n<p>在配置企业微信应用URL的时候，微信服务器会发送一个GET请求到配置的URL进行验证，后端程序需要验证签名，解密后把内容复读给微信服务器。</p>\n<p>下面这个接口就实现了这个验证方法。</p>\n<p>这样实现之后填写 <code>https://example.com/api/wechat/work/callback</code> 这个地址就好了。</p>\n<pre><code class=\"language-c#\">[ApiController]\n[AllowAnonymous]\n[Route(\"api/wechat/work/callback\")]\npublic class WechatWorkController(\n    WechatWorkClient client,\n    IBackgroundTaskQueue queue,\n    ILogger&lt;WechatWorkController&gt; logger\n) : ControllerBase {\n    /// &lt;summary&gt;\n    /// 回调验证 (GET)\n    /// &lt;/summary&gt;\n    [HttpGet]\n    public IActionResult Echo(\n        [FromQuery(Name = \"msg_signature\")] string msgSignature,\n        [FromQuery(Name = \"timestamp\")] string timestamp,\n        [FromQuery(Name = \"nonce\")] string nonce,\n        [FromQuery(Name = \"echostr\")] string echoStr\n    ) {\n        // 验证签名\n        var verifyResult = client.VerifyEventSignatureForEcho(\n            timestamp, nonce, echoStr, msgSignature, out string? replyEcho\n        );\n\n        if (verifyResult.Result) {\n            logger.LogInformation(\"Echo verification successful. ReplyEcho: {ReplyEcho}\", replyEcho);\n            return Content(replyEcho ?? string.Empty);\n        }\n\n        logger.LogWarning(\"Echo verification failed. Error: {Error}\", verifyResult.Error?.Message);\n        return BadRequest($\"Verify signature failed: {verifyResult.Error?.Message}\");\n    }\n}\n</code></pre>\n<h3 id=\"接收信息\">接收信息</h3>\n<p>接收信息和上面的验证都是一个URL，区别是接收信息时，微信服务器会向URL发POST请求。</p>\n<p>代码里有详细注释了，应该不用解释太多。</p>\n<pre><code class=\"language-c#\">/// &lt;summary&gt;\n/// 接收消息 (POST)\n/// &lt;/summary&gt;\n[HttpPost]\npublic async Task&lt;IActionResult&gt; Callback(\n    [FromQuery(Name = \"msg_signature\")] string msgSignature,\n    [FromQuery(Name = \"timestamp\")] string timestamp,\n    [FromQuery(Name = \"nonce\")] string nonce\n) {\n    // 必须读取原始 Request Body 流，而不能使用 [FromBody] 绑定\n    // 原因：\n    // 1. 微信签名验证依赖于原始请求体，任何空格、换行符的差异都会导致签名校验失败\n    // 2. 推送内容通常是加密的 XML，需要先获取原始字符串传给 SDK 进行解密\n    using var reader = new StreamReader(Request.Body);\n    var xml = await reader.ReadToEndAsync();\n\n    logger.LogDebug(\"Callback Body (Length: {Length}): {Xml}\", xml.Length, xml);\n\n    // 1. 验证签名\n    // 虽然 DeserializeEventFromXml 内部可能会包含解密过程，但显式验证签名是更安全的做法\n    var verifyResult = client.VerifyEventSignatureFromXml(timestamp, nonce, xml, msgSignature);\n    if (!verifyResult.Result) {\n        logger.LogWarning(\"Callback signature verification failed. Error: {Error}\", verifyResult.Error?.Message);\n        return BadRequest($\"Verify signature failed: {verifyResult.Error?.Message}\");\n    }\n\n    // 2. 使用 SKIT 库提供的扩展方法自动解密并反序列化\n    // 注意：需要在 WechatWorkClientOptions 中配置 PushToken 和 PushEncodingAESKey\n    WechatWorkEvent wechatEvent;\n    try {\n        wechatEvent = client.DeserializeEventFromXml(xml);\n        logger.LogInformation(\"Callback deserialized successfully. MessageType: {MessageType}, FromUser: {FromUser}, ToUser: {ToUser}\", wechatEvent.MessageType, wechatEvent.FromUserName, wechatEvent.ToUserName);\n    } catch (Exception ex) {\n        // 反序列化失败（通常是因为签名验证失败或解密失败）\n        logger.LogError(ex, \"Callback deserialization failed.\");\n        return BadRequest($\"Deserialization failed: {ex.Message}\");\n    }\n\n    // 处理逻辑\n    if (string.Equals(wechatEvent.MessageType, \"TEXT\", StringComparison.OrdinalIgnoreCase)) {\n        // 再次反序列化为具体的文本消息事件以获取 Content\n        var textEvent = client.DeserializeEventFromXml&lt;TextMessageEvent&gt;(xml);\n        if (textEvent != null &amp;&amp; !string.IsNullOrEmpty(textEvent.Content) &amp;&amp;\n            !string.IsNullOrEmpty(textEvent.FromUserName)) {\n            logger.LogInformation(\"Processing TEXT message from {FromUser}: {Content}\", textEvent.FromUserName, textEvent.Content);\n            await ProcessTextMessageAsync(textEvent.FromUserName, textEvent.Content);\n        }\n    }\n    else if (string.Equals(wechatEvent.MessageType, \"IMAGE\", StringComparison.OrdinalIgnoreCase)) {\n        var imageEvent = client.DeserializeEventFromXml&lt;ImageMessageEvent&gt;(xml);\n        if (imageEvent != null &amp;&amp; !string.IsNullOrEmpty(imageEvent.MediaId) &amp;&amp;\n            !string.IsNullOrEmpty(imageEvent.FromUserName)) {\n            logger.LogInformation(\"Processing IMAGE message from {FromUser}: {MediaId}\", imageEvent.FromUserName, imageEvent.MediaId);\n            await ProcessImageMessageAsync(imageEvent.FromUserName, imageEvent.MediaId);\n        }\n    }\n    else {\n        logger.LogInformation(\"Ignored message type: {MessageType}\", wechatEvent.MessageType);\n    }\n\n    return Ok(\"success\");\n}\n\n</code></pre>\n<h3 id=\"异步处理信息\">异步处理信息</h3>\n<p>因为企业微信可以主动给用户发信息，所以可以把接收和发送信息分开，例如调用LLM处理回复的时候，会比较慢，可以把回复放到异步任务队列里去实现。</p>\n<h4 id=\"文本信息\">文本信息</h4>\n<p>纯文本处理起来还是比较简单的。</p>\n<pre><code class=\"language-c#\">/// &lt;summary&gt;\n/// 异步处理文本消息\n/// &lt;/summary&gt;\nprivate async Task ProcessTextMessageAsync(string toUser, string content) {\n    await queue.QueueBackgroundWorkItemAsync(async (serviceProvider, token) =&gt; {\n        // 在后台任务中解析 Scoped 服务\n        var chatBot = serviceProvider.GetRequiredService&lt;IChatBotService&gt;();\n        var logger = serviceProvider.GetRequiredService&lt;ILogger&lt;WechatWorkController&gt;&gt;();\n\n        try {\n            logger.LogInformation(\"Processing background task for user {ToUser}\", toUser);\n\n            // 1. 调用 ChatBot 获取回复\n            string reply = await chatBot.ProcessMessageAsync(content);\n\n            // 2. 发送回复\n            var accessToken = await _tokenService.GetAccessTokenAsync();\n            var request = new CgibinMessageSendRequest {\n                AccessToken = accessToken,\n                AgentId = _agentId,\n                ToUserIdList = [toUser],\n                MessageType = \"text\",\n                MessageContentAsText = new CgibinMessageSendRequest.Types.TextMessage {\n                    Content = content\n                }\n            };\n            var response = await _client.ExecuteCgibinMessageSendAsync(request);\n            if (!response.IsSuccessful()){\n                throw new Exception($\"发送企业微信消息失败: {response.ErrorMessage} (Code: {response.ErrorCode})\");\n            }\n\n            logger.LogInformation(\"Reply sent to {ToUser}: {ReplyContent}\", toUser, reply);\n        } catch (Exception ex) {\n            logger.LogError(ex, \"Failed to process message for {ToUser}\", toUser);\n        }\n    });\n}\n</code></pre>\n<h4 id=\"图片信息\">图片信息</h4>\n<p>图片麻烦一点，微信不会直接把图片数据发来，而是搞了个 mediaId，要我们手动去下载。</p>\n<p>C# 这里还是方便的，直接把图片下载放到内存里交给第三方服务处理（如OCR），然后再把结果发出来。</p>\n<pre><code class=\"language-c#\">/// &lt;summary&gt;\n/// 异步处理图片消息\n/// &lt;/summary&gt;\nprivate async Task ProcessImageMessageAsync(string toUser, string mediaId) {\n    await queue.QueueBackgroundWorkItemAsync(async (serviceProvider, token) =&gt; {\n        var chatBot = serviceProvider.GetRequiredService&lt;IChatBotService&gt;();\n        var wechatService = serviceProvider.GetRequiredService&lt;IWechatWorkService&gt;();\n        var tokenService = serviceProvider.GetRequiredService&lt;IWechatWorkTokenService&gt;();\n        var logger = serviceProvider.GetRequiredService&lt;ILogger&lt;WechatWorkController&gt;&gt;();\n        var wechatClient = serviceProvider.GetRequiredService&lt;WechatWorkClient&gt;();\n\n        try {\n            logger.LogInformation(\"Processing background image task for user {ToUser}\", toUser);\n\n            // 1. Download Image\n            var accessToken = await tokenService.GetAccessTokenAsync(token);\n            var request = new CgibinMediaGetRequest {\n                AccessToken = accessToken,\n                MediaId = mediaId\n            };\n            var resp = await wechatClient.ExecuteCgibinMediaGetAsync(request, cancellationToken: token);\n\n            if (!resp.IsSuccessful()) {\n                logger.LogError(\"Failed to download image: {Error}\", resp.ErrorMessage);\n                await wechatService.SendTextMessageAsync(toUser, \"抱歉，无法获取图片内容。\");\n                return;\n            }\n\n            var bytes = resp.GetRawBytes();\n            var mimeType = \"image/jpeg\";\n            if (bytes.Length &gt; 0 &amp;&amp; bytes[0] == 0x89 &amp;&amp; bytes[1] == 0x50 &amp;&amp; bytes[2] == 0x4E &amp;&amp; bytes[3] == 0x47) {\n                mimeType = \"image/png\";\n            }\n\n            var items = new ChatMessageContentItemCollection {\n                new ImageContent(bytes, mimeType)\n            };\n\n            // 2. Call ChatBot\n            var chatMessage = new ChatMessageContent(AuthorRole.User, items);\n            var reply = await chatBot.ProcessMessageAsync(chatMessage);\n\n            // 3. Send Reply\n            await wechatService.SendTextMessageAsync(toUser, reply);\n\n            logger.LogInformation(\"Reply sent to {ToUser}\", toUser);\n        } catch (Exception ex) {\n            logger.LogError(ex, \"Failed to process image message for {ToUser}\", toUser);\n        }\n    });\n}\n</code></pre>\n<h2 id=\"公众号\">公众号</h2>\n<p>好，企业微信搞定了。接下来看看公众号。</p>\n<p>公众号和企业微信不一样，无法主动发信息，所以在收到用户信息时，要返回XML格式的相应，作为回复内容，5秒内必须回复。</p>\n<p>验证回调这里就不重复了，和企业微信是一样的。</p>\n<pre><code class=\"language-c#\">/// &lt;summary&gt;\n/// 接收消息 (POST)\n/// &lt;/summary&gt;\n[HttpPost]\npublic async Task&lt;IActionResult&gt; Callback(\n    [FromQuery(Name = \"msg_signature\")] string? msgSignature,\n    [FromQuery(Name = \"signature\")] string? signature,\n    [FromQuery(Name = \"timestamp\")] string timestamp,\n    [FromQuery(Name = \"nonce\")] string nonce,\n    [FromQuery(Name = \"encrypt_type\")] string? encryptType\n) {\n    using var reader = new StreamReader(Request.Body);\n    var xml = await reader.ReadToEndAsync();\n\n    _logger.LogDebug(\"Callback Body (Length: {Length}): {Xml}\", xml.Length, xml);\n\n    // 1. 验证签名\n    // 如果是安全模式 (encryptType == \"aes\")，使用 VerifyEventSignatureFromXml (需要 msg_signature)\n    // 如果是明文模式，SDK 内部 DeserializeEventFromXml 也会做一些校验，但通常明文模式签名校验使用 signature (VerifyEventSignatureForEcho logic)\n    // 这里主要处理安全模式，因为明文模式下通常不需要复杂的解密验证\n    if (string.Equals(encryptType, \"aes\", StringComparison.OrdinalIgnoreCase)) {\n        if (string.IsNullOrEmpty(msgSignature)) {\n            return BadRequest(\"msg_signature is required for aes encryption\");\n        }\n\n        var verifyResult = _client.VerifyEventSignatureFromXml(timestamp, nonce, xml, msgSignature);\n        if (!verifyResult.Result) {\n            _logger.LogWarning(\"Callback signature verification failed. Error: {Error}\", verifyResult.Error?.Message);\n            return BadRequest($\"Verify signature failed: {verifyResult.Error?.Message}\");\n        }\n    }\n    else {\n        // 明文模式，可以使用 signature 验证 (可选)\n        // var verifyResult = _client.VerifyEventSignatureForEcho(timestamp, nonce, signature);\n    }\n\n    // 2. 使用 SKIT 库自动解密并反序列化\n    WechatApiEvent wechatEvent;\n    try {\n        wechatEvent = _client.DeserializeEventFromXml(xml);\n        _logger.LogInformation(\"Callback deserialized successfully. MessageType: {MessageType}, FromUser: {FromUser}, ToUser: {ToUser}\",\n                               wechatEvent.MessageType, wechatEvent.FromUserName, wechatEvent.ToUserName);\n    } catch (Exception ex) {\n        _logger.LogError(ex, \"Callback deserialization failed.\");\n        return BadRequest($\"Deserialization failed: {ex.Message}\");\n    }\n\n    switch (wechatEvent.MessageType?.ToLower()) {\n        case \"text\":\n            var textEvent = _client.DeserializeEventFromXml&lt;TextMessageEvent&gt;(xml);\n            if (!string.IsNullOrEmpty(textEvent.Content) &amp;&amp;\n                !string.IsNullOrEmpty(textEvent.FromUserName)) {\n                _logger.LogInformation(\"Processing TEXT message from {FromUser}: {Content}\", textEvent.FromUserName, textEvent.Content);\n\n                var isSafetyMode = string.Equals(encryptType, \"aes\", StringComparison.OrdinalIgnoreCase);\n\n                var textReply = new TextMessageReply {\n                    ToUserName = textEvent.FromUserName,\n                    FromUserName = textEvent.ToUserName,\n                    MessageType = \"text\",\n                    Content = \"这里是回复给用户的内容\",\n                    CreateTimestamp = DateTimeOffset.Now.ToUnixTimeSeconds()\n                };\n\n                var replyXml = _client.SerializeEventToXml(textReply, isSafetyMode);\n                return Content(replyXml, \"application/xml\");\n            }\n            break;\n\n        default:\n            _logger.LogInformation(\"Ignored message type: {MessageType}\", wechatEvent.MessageType);\n            break;\n    }\n\n    return Ok(\"success\");\n}\n</code></pre>\n<p>可以看到代码里判断是 text 类型后，构造了 TextMessageReply 类型的数据，然后调用 SKIT.FlurlHttpClient.Wechat 库提供的 XML 序列化方法。</p>\n<p>这个库封装了直接序列化被动回复事件的扩展方法，默认会序列化为安全模式。</p>\n<h2 id=\"接入登录\">接入登录</h2>\n<p>微信登录和大部分第三方单点认证流程差不多，已经写过好多次了。</p>\n<p>不再赘述这个流程，感兴趣的同学可以看这篇文章: <a href=\"https://blog.deali.cn/p/django-taro-wechat-work-login\" rel=\"noopener nofollow\" target=\"_blank\">Django+Taro项目实现企业微信登录</a></p>\n<p>本次我没有接入登录，而是用了另一种方式实现微信和平台用户的关联，就是平台上生成一个key，让用户在微信发送，感觉还挺有意思的，另辟蹊径。</p>\n<p>所以这里搬运一下我之前做的单点认证项目里的代码吧，详情可以看这篇文章: <a href=\"https://blog.deali.cn/p/almost-abandoned-project-open-source\" rel=\"noopener nofollow\" target=\"_blank\">IdentityServerLite项目和近期的开源计划</a></p>\n<pre><code class=\"language-c#\">/// &lt;summary&gt;\n/// 企业微信登录 - 使用回调的 code 登录\n/// &lt;/summary&gt;\n/// &lt;param name=\"code\"&gt;&lt;/param&gt;\n/// &lt;param name=\"state\"&gt;一些让微信转发传给后端的参数，这里是单点认证项目的session_id&lt;/param&gt;\n[HttpGet(\"wecom/login\")]\npublic async Task&lt;IActionResult&gt; WecomLogin(string code, string? state = null) {\n    logger.LogInformation(\"企业微信登录，code: {code}, state: {state}, crop: {cropTag}\", code, state, cropTag);\n\n    if (string.IsNullOrWhiteSpace(state)) {\n        return BadRequest(new ApiResponse { Message = \"企业微信登录的 state 为空，无法获取 session\" });\n    }\n\n    var session = await authService.GetSession(state);\n    if (session == null) {\n        return NotFound(new ApiResponse { Message = $\"session {state} 不存在！\" });\n    }\n\n    var userInfo = await wecomService.GetUserInfo(code);\n    if (userInfo == null) {\n        return BadRequest(new ApiResponse { Message = \"获取 userinfo 错误！\" });\n    }\n\n    if (userInfo.Errcode != 0) {\n        return BadRequest(new ApiResponse { Message = $\"获取用户信息失败，企微错误信息: {userInfo.Errmsg}\" });\n    }\n\n    var wechatUser = await wecomService.GetUser(userInfo.Userid);\n    if (wechatUser == null) {\n        return BadRequest(new ApiResponse { Message = \"获取 user 错误！\" });\n    }\n\n    var user = await userRepo.Where(a =&gt; a.PhoneNumber == wechatUser.Userid).FirstAsync();\n    // 用户不存在的话，自动创建用户\n    if (user == null) {\n        user = await accountService.CreateUser(\n            await accountService.GenerateUsername(wechatUser.Name),\n            wechatUser.Userid,\n            wechatUser.Name\n        );\n\n        logger.LogInformation(\"用户 {Phone} 不存在，已创建新用户 {UserId}\", \n                              wechatUser.Userid, user.Id);\n        // return NotFound(new ApiResponse { Message = $\"用户 {wechatUser.Userid} 不存在！\" });\n    }\n\n    try {\n        var url = await authService.LoginSessionAndGetUri(session, user, true);\n        logger.LogInformation(\"企业微信登录成功，跳转到链接: {url}\", url);\n        return Redirect(url);\n    }\n    catch (Exception ex) {\n        ex.ToExceptionless().Submit();\n        return Problem($\"企业微信登录失败: LoginSessionAndGetUri 失败 - {ex.Message}\");\n    }\n}\n</code></pre>\n<h2 id=\"小结\">小结</h2>\n<p>大概就是这些了，很繁琐，不过还挺好用的，这些代码写完后几乎是一次就对接通过，想起来以前反复调试的经历，感叹：日子也是好起来了呀！😄</p>\n<p>另一点感叹：Semantic Kernel真好用，我用了太久langchain，应该早点上semantic kernel的。</p>\n\n</div>\n<div id=\"MySignature\">\n    微信公众号：「程序设计实验室」\n专注于互联网热门新技术探索与团队敏捷开发实践，包括架构设计、机器学习与数据分析算法、移动端开发、Linux、Web前后端开发等，欢迎一起探讨技术，分享学习实践经验。\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-21 23:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/deali\">程序设计实验室</a>&nbsp;\n阅读(<span id=\"post_view_count\">179</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "C#/.NET/.NET Core技术前沿周刊 | 第 66 期（2026年1.12-1.18）",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19514257",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19514257\" id=\"cb_post_title_url\" title=\"发布于 2026-01-21 22:41\">\n    <span>C#/.NET/.NET Core技术前沿周刊 | 第 66 期（2026年1.12-1.18）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202509/1336199-20250922202742912-411034871.png\" /></p>\n<h2><span>前言</span></h2>\n<p><span>C#/.NET/.NET Core技术前沿周刊，你的每周技术指南针！记录、追踪C#/.NET/.NET Core领域、生态的每周最新、最实用、最有价值的技术文章、社区动态、优质项目和学习资源等。让你时刻站在技术前沿，助力技术成长与视野拓宽。</span></p>\n<blockquote>\n<p><span>欢迎投稿、推荐或自荐优质文章、项目、学习资源等。</span></p>\n</blockquote>\n<ul class=\"list-paddingleft-1\">\n<li><strong>🏆技术前沿周刊Gitee开源地址：</strong><a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetWeekly.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetWeekly.md</span></a></li>\n<li><strong>📰技术前沿周刊GitHub开源地址：</strong><a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetWeekly.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetWeekly.md</span></a></li>\n</ul>\n<h2><span>如何用 .NET MAUI 构建 Android 小部件</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;本博客将介绍之前关于 iOS 小部件的互动小部件的 Android 部分。Android 通常更宽松，作更简单，你可以直接在 Visual Studio 里的 .NET MAUI 项目里构建所有内容。复杂性源于众多可用的任务选项以及需要考虑较旧的安卓版本。就像 iOS 小部件博客里一样，这也不是一步步的教程。相反，它突出显示了你在构建 Android 小部件时通常遇到障碍的顺序中最大且最重要的部分。它从创建一个简单的静态小部件开始，逐步发展成可配置、完全交互的小部件。</span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://devblogs.microsoft.com/dotnet/how-to-build-android-widgets-with-dotnet-maui/</span></li>\n</ul>\n<h2><span>.NET 和 .NET Framework 2026 年 1 月服务发布更新</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;欢迎来到我们 2026 年 1 月的联合.NET 服务更新。让我们进入.NET 和.NET Framework 的最新版本，这里简要介绍一下我们服务版本中的新内容。</span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://devblogs.microsoft.com/dotnet/dotnet-and-dotnet-framework-january-2026-servicing-updates/</span></li>\n</ul>\n<h2><span>如何一步步将 ASP.NET MVC 升级为.NET</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;将 ASP.NET MVC 应用从.NET Framework 升级到现代.NET 并不是简单的版本提升。此次迁移代表了运行时、托管模型、配置系统、依赖注入和 HTTP 流水线架构的转变。许多团队低估了这一点，把它当作标准的框架升级，结果在流程后期才发现他们应用中的核心假设已经不再成立。好消息是，Microsoft 提供了明确的指导和模式，使得正确操作时迁移过程可预测。本文介绍了一个实用的逐步策略，如何将基于.NET Framework 构建的 ASP.NET MVC 5 应用迁移到运行在现代.NET 上的 ASP.NET Core，同时最大限度地减少风险和停机时间。</span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://www.cnblogs.com/powertoolsteam/p/19486260</span></li>\n</ul>\n<h2><span>使用 MCP C# SDK 实现 MCP Tool</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;<span>MCP是由Anthropic创建的一个开放协议 现在有官方 C# SDK 了，官方 C# SDK 由原来的 mcpdotnet 发展而来，基于 Microsoft.Extensions.AI 实现，截止写文章的时候（2025-4-1）目前最新版本时 0.1.0-preview 4 了，这一版本中增加了 ModelContextProtocol.AspNetCore NuGet 包，使得实现基于 ASP.NET Core SSE 的 Mcp Server 更加简单了，之前的版本中需要将示例中的扩展拷贝到自己项目中去，有了这个 NuGet 包之后就不需要了，McpServer 目前主要的两种实现方式是 Stdio(标准输入输出) 和 SSE（Server Sent Event)，新的规范里提出了基于 Http 的支持，目前暂时还未支持</span></span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://mp.weixin.qq.com/s/JSIbOo17zcQrcuCLVWN4XQ</span></li>\n</ul>\n<h2><span>一款专为 WinUI XAML 设计的快速原型设计工具，生成的代码可轻松复制到Visual Studio中！</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;XAML Studio 是一款专为 WinUI XAML 设计的快速原型设计工具，基于 C# 开源（MIT license），生成的代码可轻松复制到 Visual Studio 中的应用中。XAML Studio 让你实时预览 XAML 代码，并与结果互动，就像它在你自己的应用中运行一样。</span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://mp.weixin.qq.com/s/Kf_MrpoC-I7UbhmUNLusow</span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260121223934530-1265321004.png\" /></p>\n<h2><span>一个致力于为 C# 程序员提供更佳的编码体验和效率的 Visual Studio 扩展插件</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;Codist 是一个使用 .NET 编写、开源免费的 Visual Studio 扩展插件，致力于为 C# 程序员提供更好的编程体验和生产效率。它不仅强化了语法高亮、快速信息提示、导航栏、滚动条和显示质量，还集成了自动版本号更新、括号自动补全、支持高级编辑功能的智能工具栏、代码分析等功能。</span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://mp.weixin.qq.com/s/UWuCIY4Q5PJeNClrQWPGEw</span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260121223949797-1643034810.png\" /></p>\n<h2><span>基于NetCorePal Cloud Framework的DDD架构管理系统实践</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;前段时间在做一个管理系统的项目，想尝试一下DDD架构在实际项目中的应用。经过一番调研，最终选择了NetCorePal Cloud Framework作为基础框架，结合.NET 10和Vue 3搭建了一套完整的前后端分离架构。今天就想和大家分享一下这个项目的架构设计和技术选型，希望能给正在做类似项目的朋友一些参考。</span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://www.cnblogs.com/aishangyipiyema/p/19499381</span></li>\n</ul>\n<p><span>整个项目采用了经典的三层架构，这个结构应该很多做DDD的朋友都比较熟悉。三层之间的依赖关系是单向的：Web层依赖Infrastructure层，Infrastructure层依赖Domain层，Domain层作为核心，不依赖任何其他层。</span></p>\n<pre><span><code><span>Ncp.Admin<br /><span>├── Domain（领域层）<br /><span>│ &nbsp; ├── AggregatesModel（聚合模型）<br /><span>│ &nbsp; └── DomainEvents（领域事件）<br /><span>├── Infrastructure（基础设施层）<br /><span>│ &nbsp; ├── EntityConfigurations（实体配置）<br /><span>│ &nbsp; └── Repositories（仓储实现）<br /><span>└── Web（表现层）<br /><span>&nbsp; &nbsp; ├── Application（应用服务层）<br /><span>&nbsp; &nbsp; │ &nbsp; ├── Commands（命令）<br /><span>&nbsp; &nbsp; │ &nbsp; ├── Queries（查询）<br /><span>&nbsp; &nbsp; │ &nbsp; └── DomainEventHandlers（领域事件处理器）<br /><span>&nbsp; &nbsp; └── Endpoints（API端点）<br /></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>\n<h2><span>WPF 使用 <span>HLSL + Clip 实现高亮歌词光照效果</span></span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;最近在搓一个Lyricify Lite类似物，原本使用渐变画刷实现歌词高亮，但是发现视觉效果与<span>Apple Music相去甚远：单纯使用白色渐变画刷缺乏“高亮”的光照感觉，而Apple Music的歌词高亮则更像是有光线投射在歌词上，形成一种柔和的发光效果。</span></span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://www.cnblogs.com/TwilightLemon/p/19497125</span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260121224009988-596818876.png\" /></p>\n<h2><span>基于.NET和C<a class=\"wx_topic_link\">#构建光伏IoT物模型方案</a></span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;本文主要介绍基于.NET和C<a class=\"wx_topic_link\">#构建光伏IoT物模型的方案</a>。</span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://www.cnblogs.com/tianqing/p/19490649</span></li>\n</ul>\n<h2><span>不服跑个分？.NET 10 大整数计算对阵 Java，结果令人意外</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;我对数值计算的执念，来自初中时代烟雾缭绕的网吧。那时玩《伝奇》，最让我着迷的不是打怪爆装备，而是角色面板里那条长长的经验值。看着数字不断跳动、累积，最终“叮”一声升级，那种简单的数值驱动整个世界运转的感觉，实在太奇妙了。</span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://www.cnblogs.com/sdcb/p/19484525/20261113-big-integer-dotnet-10-vs-java</span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260121224026142-562470130.png\" /></p>\n<h2><span>.NET Aspire 概述</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;.NET Aspire 是 Microsoft 在 Build 2024 上推出的一个开源框架，旨在简化使用 .NET 8 及更高版本创建分布式云原生应用的流程。它通过提供一套工具、模板和最佳实践，让开发者能够更专注于业务逻辑而非基础设施的搭建。本文将详细介绍 .NET Aspire 的核心功能、优势以及如何快速上手使用这一创新框架。</span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://www.cnblogs.com/powertoolsteam/p/19477015</span></li>\n</ul>\n<h2><span>总结归纳.NET 10 中 Minimal APIs 主要应用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;本文主要总结归纳.NET 10 中 Minimal APIs 主要应用场景。</span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://www.cnblogs.com/tianqing/p/19467531</span></li>\n</ul>\n<h2><span>C# 14 中的新增功能</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;C# 14 引入了多项重要更新，以下是主要功能的详细说明。</span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://www.cnblogs.com/net-kevin-li/p/19476883</span></li>\n</ul>\n<h2><span>跨越技术鸿沟：Aspire 赋能 JavaScript 与 Node.js 开发者的深度生态融合</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;在云原生应用开发的演进历程中，技术栈的异构性始终是一个核心特征。长期以来，企业级应用开发往往呈现出“双模IT”的特征：后端服务依赖于.NET 生态系统的强类型、高性能和企业级稳健性，而前端交互与部分微服务则广泛采用 JavaScript/TypeScript 生态系统的灵活性与庞大社区资源。这种多语言（Polyglot）架构虽然在功能上互补，但在开发运维（DevOps）的“内循环（Inner Loop）”中却制造了显著的摩擦。开发者常常需要在 Visual Studio 的调试器、复杂的 Docker Compose YAML 文件、散乱的 Shell 脚本以及手动维护的 .env 环境变量文件之间频繁切换。</span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://www.cnblogs.com/shanyou/p/19474912</span></li>\n</ul>\n<h2><span>.NET 磁盘管理-技术方案选型</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>文章简介：</strong><span>&nbsp;在家庭以及企业场景下的网络磁盘产品，使用Iscsi均需要对磁盘进行管理。不同Windows版本、安装第三方软件，导致每个C端用户的运行环境不同，对磁盘的管理带来一定的使用干扰，本文介绍下磁盘管理的几种方案以及存在的一些问题。</span></li>\n<li><strong>文章地址：</strong><span>&nbsp;https://www.cnblogs.com/kybs0/p/19473484</span></li>\n</ul>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-21 22:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">256</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一个小技巧轻松提升Dash应用debug效率",
      "link": "https://www.cnblogs.com/feffery/p/19513359",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/feffery/p/19513359\" id=\"cb_post_title_url\" title=\"发布于 2026-01-21 17:53\">\n    <span>一个小技巧轻松提升Dash应用debug效率</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<center style=\"font-size: 18px; font-weight: bold; padding-top: 40px;\">更多Dash应用开发干货知识、案例，欢迎关注“玩转Dash”微信公众号👇</center>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250703190053776-1837084116.png\" /></p>\n<h1 id=\"1-简介\">1 简介</h1>\n<p>大家好我是费老师。<code>Dash</code>作为基于<code>Python</code>进行<em>全栈应用开发</em>的流行框架，具有强大的<em>可伸缩性</em>——这意味着在同一套基于<strong>组件+回调函数</strong>的代码组织方式下，使用<code>Dash</code>可以轻松覆盖从小型简单应用，到大型复杂应用，各种复杂程度的应用开发任务。这也是<code>Dash</code>在世界范围内，被众多的大公司用于持续开发<em>企业级</em>数据应用的原因之一。</p>\n<center><img src=\"https://img2024.cnblogs.com/blog/1344061/202509/1344061-20250910154430584-1965899431.png\" width=\"50%\" /></center>\n<p>而随着所开发的<code>Dash</code>应用功能日益增长，我们则需要学习如何在应用开发过程中，更<strong>高效准确</strong>的<em>调试应用功能逻辑</em>，<em>定位异常问题所在</em>。</p>\n<p>今天的文章中，我们就来一起学习新版本<code>Dash</code>（&gt;=3.4.0版本）中增加的一些功能特性，帮助我们更精准快速的定位常见回调函数开发问题。</p>\n<h1 id=\"2-在回调图中用hidden和hide_all_callbacks参数聚焦回调函数\">2 在回调图中用hidden和hide_all_callbacks参数聚焦回调函数</h1>\n<p>虽然我之前在<em>公众号</em>、<em>玩转Dash知识星球</em>等平台发布的文章和课程中，并没有专门做过介绍，但很多同学应该对类似下面的界面有印象：我们在<code>Dash</code>应用开发阶段，为<code>app.run()</code>设置<code>debug=True</code>开启<em>开发调试模式</em>后，通过点击右下角开发模式工具条中的<strong>Callbacks</strong>按钮，可以展开一套可交互的<strong>有向图</strong>，我们可以将其称作<strong>回调图</strong>。</p>\n<center><img src=\"https://img2024.cnblogs.com/blog/1344061/202601/1344061-20260121175038215-1907019957.png\" /></center>\n<p>默认情况下，它记录并呈现当前<code>Dash</code>应用中全部的回调函数编排关系，这对于<strong>小型</strong>的<code>Dash</code>应用很直观明了，因为图中的<em>节点</em>和<em>边</em>比较少。但是对于页面众多、功能逻辑众多的中大型<code>Dash</code>应用来说，当你打开回调图时，看到的可能是下面这样庞大复杂的景象：</p>\n<center><img src=\"https://img2024.cnblogs.com/blog/1344061/202601/1344061-20260121175040979-568062826.png\" /></center>\n<p>😅这种情况下我们大概率会当做什么都没看见，默默的关闭回调图面板。。。</p>\n<center><img src=\"https://img2024.cnblogs.com/blog/1344061/202601/1344061-20260121175055369-1439370721.jpg\" /></center>\n<p>那么有没有办法在这个<em>回调图</em>中默认<em>不展示全部</em>的<em>回调关系</em>，只针对目前关注的部分回调函数进行展示呢？</p>\n<p>有的兄弟，有的，首先我们直接将<code>Dash</code>升级到<code>&gt;=3.4.0</code>版本：</p>\n<pre><code class=\"language-bash\">pip install dash -U\n</code></pre>\n<p>以实现“拼接两个输入框内容”的简单应用功能为例：</p>\n<pre><code class=\"language-python\">import dash\nfrom dash import html\nimport feffery_antd_components as fac\nfrom dash.dependencies import Input, Output\nfrom feffery_dash_utils.style_utils import style\n\napp = dash.Dash(__name__, suppress_callback_exceptions=True)\n\napp.layout = html.Div(\n    [\n        fac.AntdSpace(\n            [\n                fac.AntdInput(id=\"input1\", placeholder=\"请输入内容\"),\n                fac.AntdInput(id=\"input2\", placeholder=\"请输入内容\"),\n                fac.AntdText(id=\"output-texxt\"),\n            ]\n        )\n    ],\n    style=style(padding=50),\n)\n\n@app.callback(\n    Output(\"output-text\", \"children\"),\n    Input(\"input1\", \"value\"),\n    Input(\"input2\", \"value\"),\n)\ndef combine_inputs(input1, input2):\n    \"\"\"拼接输入的内容\"\"\"\n    return \"拼接结果：\" + (input1 or \"\") + (input2 or \"\")\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre>\n<p>在上面的示例代码中，我们<strong>“不小心”</strong>地把用于<em>显示拼接内容结果</em>的组件<code>id</code>参数写成了<code>output-texxt</code>🤯，这也是比较常见的导致回调函数不生效的原因之一：</p>\n<center><img src=\"https://img2024.cnblogs.com/blog/1344061/202601/1344061-20260121175057590-225038268.png\" /></center>\n<p>这种情况下，当我们在浏览器中发现相关功能没有如期运作时：</p>\n<center><img src=\"https://img2024.cnblogs.com/blog/1344061/202601/1344061-20260121175059670-668077126.gif\" /></center>\n<p>就可以<strong>优先考虑</strong>通过<em>回调图</em>查看对应回调函数的执行情况，可以看到虽然我们在相关输入框里输入了一些内容，但对应的回调函数一次都没执行（<code>count 0</code>）：</p>\n<center><img src=\"https://img2024.cnblogs.com/blog/1344061/202601/1344061-20260121175104165-1673715625.gif\" /></center>\n<p>这种情况下，我们<strong>首先</strong>就可以想到是不是对应回调函数中有<code>Output</code>角色的<code>id</code>，与对应组件定义的<code>id</code>参数不一样，经过修正，功能正确运作的情况下，在回调图结果中就可以看到该回调函数<em>执行了多少次</em>、<em>执行耗时</em>等有用的信息：</p>\n<center><img src=\"https://img2024.cnblogs.com/blog/1344061/202601/1344061-20260121175106405-386111932.gif\" /></center>\n<p>此时，我们再联想到上文中展示过的，对应中大型<code>Dash</code>应用的<strong>非常庞杂</strong>的回调图，假如上面这个回调函数<code>debug</code>的场景出现在类似规模的应用中，我们就可以基于<code>Dash&gt;=3.4.0</code>版本，首先在<code>app.run()</code>中设置<code>hide_all_callbacks=True</code>，这将在回调图中强制隐藏所有的回调函数：</p>\n<center><img src=\"https://img2024.cnblogs.com/blog/1344061/202601/1344061-20260121175111240-318613727.png\" /></center>\n<p>然后再为对应的回调函数<code>callback()</code>中设置<code>hidden=False</code>：</p>\n<center><img src=\"https://img2024.cnblogs.com/blog/1344061/202601/1344061-20260121175113131-149325016.png\" /></center>\n<p>这将以<em>更高的优先级</em>，在回调图中<strong>强制展示</strong>当前回调函数关系，这样无论是再复杂的<code>Dash</code>应用，我们都可以在<em>回调图</em>中只<strong>聚焦</strong>于我们关注的那些回调函数，大幅度提升应用功能调试效率🚀：</p>\n<center><img src=\"https://img2024.cnblogs.com/blog/1344061/202601/1344061-20260121175114783-1832623334.png\" /></center>\n<p>大家可以在日常开发<code>Dash</code>应用的过程中，多多利用今天介绍的技巧，开发出更稳健的应用💪~</p>\n<hr />\n<p>更多有关<code>Dash</code>应用开发的干货内容，欢迎持续关注我们❤️</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-21 17:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/feffery\">费弗里</a>&nbsp;\n阅读(<span id=\"post_view_count\">101</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【译】Visual Studio 2026 来了：更快、更智能，深受老用户的喜爱",
      "link": "https://www.cnblogs.com/MeteorSeed/p/19505675",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/MeteorSeed/p/19505675\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 13:48\">\n    <span>【译】Visual Studio 2026 来了：更快、更智能，深受老用户的喜爱</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>　　我们非常激动地宣布，Visual Studio 2026 现已正式发布！这一刻是我们与您携手共创的成果。您的反馈对本次版本的塑造作用超过了以往任何一次。自 2025 年 9 月推出 Insiders 通道以来，下载并测试该预览版的开发者数量创下了 Visual Studio 历史新高。</span></p>\n<p><span>　　在此次版本发布前的一年里，我们修复了超过 5000 个你们反馈的程序缺陷，并实现了300项功能需求。这是我们有史以来完成量最多的一次，而我们才刚刚开始！</span></p>\n<p><span>　　此次发布包含多项性能改进、重新设计的用户体验以及人工智能驱动开发方面的重大飞跃，旨在帮助开发者专注于真正重要的事情：创新。如今，每一次点击、每一次按键和每一次编译都更加流畅、快速且直观 —— 让您能够以前所未有的速度将想法转化为代码。</span></p>\n<p><span>　　您是否有过那种因卡顿而打断工作节奏的沮丧感？我们已努力让这种情况成为过去。极速的性能意味着启动速度显著提升，用户界面的响应也极为流畅，几乎让您感觉不到它的存在。新版将卡顿减少了 50% 以上，即便在大型项目中，也能让这款 IDE 给人一种轻巧、流畅的使用体验。无论您是在处理企业级规模的代码仓库，还是在小型代码库上进行修改，这都为高效完成工作树立了新的标准。</span></p>\n<p><span><img alt=\"1\" src=\"https://img2024.cnblogs.com/blog/270073/202601/270073-20260120112431903-1129042177.webp\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p><span>　　但这不仅仅是为了更快地加载解决方案。在加载内容时，UI 也能保持更高的响应性。事实上，那些令人烦恼的用户界面冻结现象已经减少了一半以上。</span></p>\n<p><span><img alt=\"2\" src=\"https://img2024.cnblogs.com/blog/270073/202601/270073-20260120112442788-477888352.webp\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p><span>　　统计数据固然不错，但真正重要的是实际使用起来的感受。这款集成开发环境运行得更快、更流畅，响应也更迅速。这是那些数字往往无法体现的。</span></p>\n<blockquote>\n<p>　　“哇！我刚刚打开了一个包含 100 多个项目的解决方案，简直不敢相信它启动并准备就绪的速度这么快！干得好，Visual Studio 团队！”</p>\n<p>　　—— Steve Smith，NimblePros 首席软件架构师</p>\n</blockquote>\n<p><span>　　Visual Studio 2026 是原生支持人工智能的，使其成为世界上首个智能 IDE。这并不意味着要改变您的工作方式，而是意味着在最关键的时刻为您提供智能支持。当您在调试棘手问题、分析性能或对应用程序进行现代化改造时，人工智能会介入，减少阻碍并呈现有用的见解，帮助您在不中断工作流程的情况下更快地推进工作。它的作用是提升您早已信赖的工作方式，而非取代它们。</span></p>\n<p><span>　　此版本还带来了新的 C# 和 C++ 智能体，专为那些每天都需要精准度和速度的专业开发者设计。这些功能扩展了您的能力范围，同时又不会增加复杂性，让您在更短时间内完成更多工作的同时，仍能保持掌控。Visual Studio 2026 并非为了人工智能而采用人工智能，而是您赖以完成工作的工具的自然演进，同时还能提高您的工作效率。</span></p>\n<p><span>　　这种发展为曾经看似遥不可及的可能性打开了大门，将人工智能自然地融入您的日常流程中。GitHub Copilot 已迅速成为 Visual Studio 中使用最广泛的功能之一，赢得了每天都依赖它的开发者们的赞誉。</span></p>\n<blockquote>\n<p><span><span>　　“Visual Studio 中的&nbsp;<span><span>Profiler Agent&nbsp;<span><span>立即突出显示了瓶颈，并指导我实现了更快、更简洁的性能 —— 就像有一个内置的性能教练一样。”</span></span></span></span></span></span></p>\n<p><span><span>　　—— Roberto Perez，Redis 高级全球解决方案架构师</span></span></p>\n</blockquote>\n<p><span>　　当您一整天都在使用 Visual Studio 时，每一次交互都至关重要。我们全力以赴完善核心功能 —— 减少操作阻碍、修复那些细微的“小麻烦”，并优化您的工作流程。此次发布引入了灵活的新设置系统、精美的现代化 UI 重新设计，以及数百项底层改进，从各方面提升了这款集成开发环境的使用体验。</span></p>\n<p><span><img alt=\"3\" src=\"https://img2024.cnblogs.com/blog/270073/202601/270073-20260120112521981-360736084.webp\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p><span>　　在过去 12 个月里，您的反馈帮助我们修复了 5000 多个程序缺陷，并新增了 300 多项功能需求。这是我们为 Visual Studio 重大版本发布所做的最大规模推进，而且这一势头还在持续增强。借助人工智能驱动的工具，我们识别和解决问题的速度不断加快，因此能够以前所未有的速度推出改进。</span></p>\n<blockquote>\n<p><span><span>　　“我最喜欢 Visual Studio 2026 的地方是它的性能以及清新明快的 UI —— 而对 Mermaid 图表的支持更是锦上添花。”</span></span></p>\n<p><span><span>　　—— Erik Ejlskov Jensen, Context&amp; A/S</span></span></p>\n</blockquote>\n<p><span>　　最棒的是：Visual Studio 2026 与您在 Visual Studio 2022 中创建的项目和扩展完全兼容。您可以直接打开现有的解决方案并立即开始编码，无需迁移步骤，也不会有意外情况。您钟爱的所有扩展也都能使用，因此您的工作区、工具和项目能够无缝过渡，让这款集成开发环境从首次启动起就给您一种熟悉亲切的感觉。</span></p>\n<p><span>　　如今有超过 4000 个可与 Visual Studio 2022 兼容的扩展，它们也都能在 Visual Studio 2026 上运行。您可以安心升级，而且您的设置会一如既往地稳定和熟悉。</span></p>\n<blockquote>\n<p><span><span>　　&nbsp;“从 Visual Studio 2022 获取扩展无疑是一大优势：我可以立即开始使用&nbsp;<span><span>Visual Studio<span><span>&nbsp;2026了。”</span></span></span></span></span></span></p>\n<p><span><span>　　—— Didier Donner，Aspen Technology 首席软件工程师</span></span></p>\n</blockquote>\n<p><span>&nbsp; &nbsp; 　　此外，借助 GitHub Copilot 的应用现代化功能，升级到 .NET 10 和最新的 C++ 构建工具的过程得到了加速，并且有专业知识提供指导，因此您能够充分利用所有最新的性能增强和功能。GitHub Copilot 新的 C++ 功能现已在 Private Preview 中推出。</span></p>\n<p><span>&nbsp; &nbsp; 　　长期以来，更新 Visual Studio 意味着您还必须升级您的 .NET 和 C++ 构建工具，因为它们与这个 IDE 紧密相连。这往往会带来不少麻烦，因为您可能想要最新的功能和漏洞修复，但更新可能会干扰您现有的项目，或者迫使您进行尚未准备好的工具链变更。</span></p>\n<p><span>&nbsp; &nbsp; 　　Visual Studio 2026 改变了这一切。现在，该 IDE 与其构建工具解耦，因此您可以随时更新 Visual Studio 本身，而不会影响您的 .NET 或 C++ 编译器。更棒的是，您将获得每月自动更新，这些更新会为您的 IDE 带来新功能、设计调整和生产力提升，同时能让您的工具链在您需要的时间内保持稳定。</span></p>\n<p><span>&nbsp; &nbsp; 　　如果您喜欢比其他人先试用新功能，那么 Insiders 通道很适合您。该通道会收到频繁的更新，让您能够评估最新功能，且不会影响您的主要设置，因为它可以与稳定版一同安装。许多人已经在使用它来保持更新。加入 Insiders，率先体验所有最新功能吧。</span></p>\n<p><span>&nbsp; &nbsp; 　　好奇在这个新版本中还能发现什么？查看发布说明以获取完整详情。</span></p>\n<p><span>&nbsp; &nbsp; 　　现在就下载 Visual Studio 2026，并前往 Visual Studio 开发者社区，分享哪些功能运行良好、您正在创建的内容，或者我们可以在哪些方面加以改进。我们在倾听。</span></p>\n<h1><span><span>接下来会发生什么</span></span></h1>\n<p><span>　　如果您是 Visual Studio 订阅者，只需登录 Visual Studio 2026，您的许可证就会自动激活。</span></p>\n<p><span>　　使用产品密钥的订阅者可以随时在 my.visualstudio.com上 找回这些密钥。</span></p>\n<p><span>　　对于想要购买独立专业版许可证的开发者而言，Visual Studio 2026 将于 2025 年 12 月 1 日起在微软应用商店上线。</span></p>\n<p><span>　　非常感谢我们的内测用户和 MVP，是您们让这次发布变得意义非凡。让我们继续携手共创编码的未来。</span></p>\n<p><span>　　怀着感激之情，</span></p>\n<p><span>　　—— Visual Studio 团队</span></p>\n<p><span>&nbsp;</span></p>\n<p><span>原文链接：<span>https://devblogs.microsoft.com/visualstudio/visual-studio-2026-is-here-faster-smarter-and-a-hit-with-early-adopters/</span></span></p>\n<p><span><span><img alt=\"me\" src=\"https://img2024.cnblogs.com/blog/270073/202508/270073-20250825145337681-1658462272.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></span></p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p><strong>作者：</strong><a href=\"http://www.cnblogs.com/MeteorSeed\">MeteorSeed</a></p>\n<p><strong>我希望您喜欢这篇博文，并一如既往地感谢您阅读并与朋友和同事分享我的博文。</strong></p>\n<p><strong>转载请注明出处。</strong></p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 13:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/MeteorSeed\">MeteorSeed</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "前端邪修：不用Vite也不用Webpack，把React拖回HTML时代的反工程化实践",
      "link": "https://www.cnblogs.com/deali/p/19516127",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/deali/p/19516127\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 11:21\">\n    <span>前端邪修：不用Vite也不用Webpack，把React拖回HTML时代的反工程化实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>最近一直忙于装修和开发新产品，文章都没时间更新，快速迭代的后果就是架构没有跟上功能增长的步伐，现在隐隐有脱离掌控的感觉，我这几天也把进度放慢下来，思考一下整体的规划。</p>\n<p>也顺便整理一下笔记，没有输出心里很不踏实🤣</p>\n<p>好了，说回正题，为什么标题叫“前端邪修”呢？在前端高度工程化的今天，各种工具层出不穷，大家都在说别更新了，学不动了，我直接反其道而行：</p>\n<ul>\n<li>不用 Vite</li>\n<li>不用 Webpack</li>\n<li>不跑 dev server</li>\n<li>不搞 HMR</li>\n<li>不维护 node_modules</li>\n</ul>\n<p><strong>直接在 HTML 文件里引入 React 写界面！</strong></p>\n<p>这听起来很像 2025 年还在用 Dreamweaver 写网页哈哈哈🤣</p>\n<p>本文记录一次可以称之为「前端邪修」的反工程化开发实践。</p>\n<h2 id=\"第一阶段-runtime-jsx\">第一阶段 Runtime JSX</h2>\n<p>一开始，我用的是最原始、也最“离经叛道”的 React 用法。</p>\n<pre><code class=\"language-html\">&lt;script src=\"react.development.js\"&gt;&lt;/script&gt;\n&lt;script src=\"react-dom.development.js\"&gt;&lt;/script&gt;\n&lt;script src=\"babel.min.js\"&gt;&lt;/script&gt;\n\n&lt;script type=\"text/babel\"&gt;\n  function App() {\n    return &lt;h1&gt;Hello World&lt;/h1&gt;;\n  }\n&lt;/script&gt;\n</code></pre>\n<p>特点很明显：</p>\n<ul>\n<li>不需要 Node</li>\n<li>不需要 npm / pnpm</li>\n<li>打开浏览器就能写 React</li>\n<li>JSX 由 <code>babel-standalone</code> 在浏览器里实时编译</li>\n</ul>\n<p>你别说，其实这种方法写起来还挺爽的（逃</p>\n<ul>\n<li>心智负担极低</li>\n<li>没有工具链焦虑</li>\n<li>HTML 即入口，所见即所得</li>\n</ul>\n<p>但缺点也很明显：</p>\n<ul>\n<li>各种依赖体积巨大，动辄几MB</li>\n<li>JSX runtime 编译极慢</li>\n<li>页面一复杂，加载时间肉眼可见地上升</li>\n</ul>\n<p>我这个简单的app，本地加载都要半分钟的时间🤣</p>\n<p>其实这种用法，是 <strong>React 官方早期 Demo + 教学级用法</strong>，后来被官方明确标注为：<code>Not recommended for production</code></p>\n<p>我之前也写过一篇文章介绍：<a href=\"https://blog.deali.cn/p/integrate-react-jsx-in-html\" rel=\"noopener nofollow\" target=\"_blank\">在HTML中引入React和JSX</a></p>\n<p>实践也证明了，这种方式只能当本地demo测试一下，根本不能作为production发布。</p>\n<h2 id=\"第二阶段\">第二阶段</h2>\n<blockquote>\n<p>gulp + babel，我只要 JSX 编译</p>\n</blockquote>\n<p>我选择了一个在今天看来非常“复古”的工具：<strong>gulp</strong>。</p>\n<p>这个工具虽然简单，但非常好用，我一直非常喜欢这个工具，可以在我的很多项目里看到 gulp 的身影：</p>\n<ul>\n<li><a href=\"https://blog.deali.cn/p/asp-net-core-npm-gulp-frontend-static-files\" rel=\"noopener nofollow\" target=\"_blank\">AspNetCore开发笔记：使用NPM和gulp管理前端静态文件</a></li>\n<li><a href=\"https://blog.deali.cn/p/django-npm-gulp-frontend-resources\" rel=\"noopener nofollow\" target=\"_blank\">Django项目引入NPM和gulp管理前端资源</a></li>\n<li><a href=\"http://blog.deali.cn/p/simple-alpinejs-abandon-webpack\" rel=\"noopener nofollow\" target=\"_blank\">返璞归真！使用 Alpine.js 开发交互式 web 应用，抛弃 node_modules 和 webpack 吧！</a></li>\n</ul>\n<p>用法是这样的：</p>\n<p>把 jsx 组件按照顺序，显示添加到待处理的列表里</p>\n<pre><code class=\"language-js\">const jsxComponents = [\n  \"Alert.jsx\",\n  \"Toast.jsx\",\n  \"Login.jsx\",\n  \"Register.jsx\",\n  \"ChatView.jsx\",\n  \"DetailView.jsx\",\n  \"App.jsx\"\n];\n</code></pre>\n<p>我放弃了自动依赖分析，这在现代前端里几乎是“原罪”。😂</p>\n<p>但在一个边界清晰、规模可控的项目里，它反而是最可控的方式。</p>\n<p>gulp 在这里做了简单的几个事情：</p>\n<ul>\n<li>JSX → JS</li>\n<li>多文件 → 一个 bundle</li>\n<li>压缩</li>\n</ul>\n<pre><code class=\"language-js\">gulp.task(\"concat:jsx\", () =&gt; {\n    return gulp.src(jsxComponents, { base: \".\" })\n        .pipe(babel({\n        presets: [\"@babel/preset-env\", \"@babel/preset-react\"]\n    }))\n        .pipe(concat(\"dist/js/app.bundle.js\"))\n        .pipe(terser()) // Use terser for minification\n        .pipe(gulp.dest(paths.root));\n});\n</code></pre>\n<p>没有 loader，没有 plugin 地狱，没有配置互相打架。</p>\n<p>最终产物只有一个：<code>dist/js/app.bundle.js</code></p>\n<h2 id=\"最终形态\">最终形态</h2>\n<p>构建完成后，整个应用的入口是一个极其朴素的 HTML 文件。</p>\n<pre><code class=\"language-html\">&lt;script src=\"lib/react/react.production.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"lib/react-dom/react-dom.production.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"lib/axios/axios.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"dist/js/app.bundle.js\"&gt;&lt;/script&gt;\n</code></pre>\n<p>几个我非常喜欢的点：</p>\n<ul>\n<li>\n<p>所有依赖都是显式的</p>\n</li>\n<li>\n<p>React 不需要 JSX 才能运行</p>\n</li>\n<li>\n<p>浏览器缓存是我自己控制的</p>\n<pre><code class=\"language-html\">&lt;script&gt;\n    (function () {\n        const scripts = [\n            \"dist/js/app.bundle.js\",\n        ];\n        const v = new Date().getTime();\n        scripts.forEach(src =&gt; {\n            document.write(`&lt;script src=\"${src}?v=${v}\"&gt;&lt;\\/script&gt;`);\n        });\n    })();\n&lt;/script&gt;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"为什么\">为什么？</h2>\n<p>这么做的起因其实很简单，我的后端需要一个简单的交互页面，而我既不想创建一个新的 Next.js/Vite 前端项目来做，也不想用后端模板渲染+HTMX/Alpine.js 这种方案。</p>\n<ul>\n<li>\n<p>前者的问题是<strong>成本</strong>：</p>\n<p>为了一个功能边界非常清晰的页面，引入一整套前端工程体系，意味着要额外维护一份项目结构、一套构建配置、以及一整条工具链生命周期。这种成本，对这个需求来说是<strong>过度的</strong>。</p>\n</li>\n<li>\n<p>后者的问题则在<strong>表达能力</strong>：</p>\n<p>后端模板渲染配合 HTMX 或 Alpine.js 确实轻量，但当页面开始出现较复杂的状态流转、组件复用和逻辑组合时，我很快就会开始“手动模拟一个组件系统”。与其在模板语法和指令里绕来绕去，不如直接使用一个我已经非常熟悉、心智模型也足够稳定的组件库（React生态）。</p>\n</li>\n</ul>\n<p>于是问题就变成了：</p>\n<blockquote>\n<p><strong>我能不能只使用 React 的“表达能力”，而不引入它背后的整套工程化体系？</strong></p>\n</blockquote>\n<p>这正是这套“前端邪修”方案的出发点。</p>\n<h2 id=\"价值\">价值</h2>\n<p>这套“前端邪修”方案解决了什么？</p>\n<p>用一句话总结：如何在不引入额外工程复杂度的前提下，获得一个足够舒适的交互层。</p>\n<p>具体来说，这个方案做到了几件事：</p>\n<ul>\n<li>不需要单独维护一个前端项目</li>\n<li>不需要 dev server、HMR 和复杂的构建配置</li>\n<li>不需要为一个小页面承担整套前端工程的长期成本</li>\n<li>但依然可以：\n<ul>\n<li>使用组件化思维</li>\n<li>管理清晰的状态和交互逻辑</li>\n<li>写出结构清楚、可维护的 UI 代码</li>\n</ul>\n</li>\n</ul>\n<p>这不是在追求最轻量，而是在追求：<strong>复杂度与需求规模之间的匹配。</strong></p>\n<p>当需求足够简单时，工程化本身就应该是可以被拆解、被克制、甚至被拒绝的。</p>\n<h2 id=\"取舍\">取舍</h2>\n<h3 id=\"-我得到的\">👍 我得到的</h3>\n<ul>\n<li>极低的心智负担</li>\n<li>极稳定的构建过程</li>\n<li>无运行时构建依赖</li>\n<li>非常适合：\n<ul>\n<li>Admin 系统</li>\n<li>AI 控制台</li>\n<li>内部工具</li>\n<li>WebView / 嵌入页面</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-我主动放弃的\">❌ 我主动放弃的</h3>\n<ul>\n<li>HMR</li>\n<li>自动 code splitting</li>\n<li>TypeScript 全链路</li>\n<li>生态插件红利</li>\n</ul>\n<h2 id=\"小结\">小结</h2>\n<p>我做的事情其实很简单：把复杂度一层一层拆掉，直到只剩下业务真正需要的那一层。</p>\n<p>我不推荐所有人这样做，但我会继续做一些反工程化的尝试，在AI时代反其道而行之，还挺有意思的😄</p>\n\n</div>\n<div id=\"MySignature\">\n    微信公众号：「程序设计实验室」\n专注于互联网热门新技术探索与团队敏捷开发实践，包括架构设计、机器学习与数据分析算法、移动端开发、Linux、Web前后端开发等，欢迎一起探讨技术，分享学习实践经验。\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 11:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/deali\">程序设计实验室</a>&nbsp;\n阅读(<span id=\"post_view_count\">139</span>)&nbsp;\n评论(<span id=\"post_comment_count\">3</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "我的“Python海龟”诞生了一枚金蛋孵出的却是精灵",
      "link": "https://www.cnblogs.com/lixingqiu/p/19516100",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lixingqiu/p/19516100\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 11:17\">\n    <span>我的“Python海龟”诞生了一枚金蛋孵出的却是精灵</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>时光回溯到2010年，那是一个充满探索与求知的年份。在此之前，我沉浸于使用Visual Basic语言开发3D小游戏，那种在代码的世界里创造出奇妙虚拟场景的感觉，让我乐此不疲。当时，我自认为Basic已经是相当简单的计算机语言了，然而，内心深处却始终有个疑问：是否存在一种比Basic更适合少儿编程的专用计算机语言呢？</p>\n<p>带着这个疑问，我开始在网络上广泛搜寻。功夫不负有心人，我终于发现了Scratch 1.4版。这只来自美国麻省理工的“小猫咪”，瞬间吸引了我的目光，从此我便深深爱上了它。2013年，怀揣着对少儿编程教育的热情，我开设了少儿编程培训班。到了2015年，我又将Python纳入教学体系，希望能为学生们带来更丰富的编程体验。经过几年的教学实践，到2018年时，我已经自己编写了较多的青少年Python教学资料。</p>\n<p>在这个过程中，我逐渐发现Python的小海龟功能存在一定的局限性。为了深入探究其原理，我打开了它的turtle.py源代码文件，仔细研究其中的奥秘。从2019年开始，我基于Python turtle模块，踏上了开发Python精灵模块的征程。Python精灵模块的核心是设计了一个名为Sprite的类，这一创新大大增加了海龟的功能，例如实现了像素级别的碰撞检测等。如今，所有人都可以通过简单的命令“pip install sprites”来安装并使用这个强大的Python精灵模块。</p>\n<p>近几年，我将主要精力投入到信息学奥赛的教学中。每日都在“苦思冥想”各种难题，力求为学生找到更有效的学习方法。2025年8月，暑假班结束，我又开始思考一个新的问题：如果C++的入门教学能够像Python turtle一样简单易懂，那无疑会给中国所有少年带来福音。</p>\n<p>为了实现这个目标，我在GitHub上广泛寻找前人的研究成果，下载了许多用C语言或者C++开发的类turtle库。其中，有小熊猫C++库里自带的C语言海龟作图，还有GoC等相关库。我还特意购买了相关书籍，准备教授中小学生，甚至买了一本少儿3维C++编程书。然而，经过深入研究和对比，我最终并没有选择使用它们，这背后有着多方面的原因。</p>\n<p>就拿小熊猫C++库里自带的C语言海龟作图来说，其作者显然没有Python少儿编程教育的经历。我曾尝试联系作者，希望他能将里面的命令改成类似Python turtle的风格，但考虑到不能总是麻烦他人，后来也就没有再继续联系。而GoC这个库，里面的命令也没有承接自Python turtle。为了方便儿童输入字符，它将命令设计成一个字符或两个字符，比如pen.o或者pen.oo之类的。其命令相对较少，功能也不够丰富，而且主要是在线使用，作者至今似乎都没有开发自己的编辑器。以前我使用过它的离线版，还需要借助notepad++。从本质上讲，它更像是为专攻信息学奥赛设计的前置课程工具。网上有人建议一、二年级的学生就开始学习GoC，但如果不打算专攻信奥赛，其实可以不必学习。为什么呢？</p>\n<p>从大脑发育的角度来看，一、二年级的学生，他们的大脑尚处于发育阶段。科学研究表明，这个阶段的孩子，大脑的前额叶皮质尚未完全成熟，抽象思维能力相对较弱。虽然有些孩子可能在早期就展现出了较强的学习能力和天赋，如果教练眼光独到，能识别出这些苗子，让他们尝试学习GoC也未尝不可。但现实情况是，不可能每个小学生都得去专攻信息学奥赛，毕竟信奥赛的竞争十分激烈，它就是学霸们的战场。而且，对于普通学生而言，他们的少儿编程学习经历应该是丰富多彩的，不应局限于C++编程。因为学习编程的本质并非仅仅掌握某种计算机语言，而是培养逻辑思维、创造力等多方面的能力。有些人大脑发育相对迟缓一些，如果硬要他们在低年级就开始学习C++，很可能会适得其反，就是拔苗助长。根据神经科学的研究，儿童在中低年级阶段，形象思维更为活跃，此时学习图形化编程更加符合他们的认知发展规律。等到他们年龄稍大，心智更加成熟，再去学习C++也不迟。大脑需要得到多方面的刺激，才能得到充分的锻炼和发展。就像一颗种子，需要在适宜的环境中，经历不同的养分滋养，才能茁壮成长。最终，有些学生到了高中阶段，随着大脑的进一步发育和知识的积累，会突然开窍，在学习编程等方面取得更大的进步。</p>\n<p>那么，面对绝大多数的普通学生群体，他们的学习路径通常是一、二年级学习图形化编程，三、四年级学习Python编程，到了一定阶段后再学习C++编程。在这种情况下，是否存在一种针对普通学生，能够完美衔接这一课程体系的C++课程呢？据我了解，这样的课程相对比较少，即便有，可能也不公开或者需要收费。毕竟中国地域广阔，很多事情我也难以全面知晓。但不管怎样，我决定自己全新开发一个，正所谓“金窝银窝不如自己草窝”。</p>\n<p>在开发过程中，首先面临的就是选择合适的库来作为基础。如果让我的C++库基于OpenGL，虽然可行，但我需要先花费大量时间去学习它，这对于我来说，学习成本过高。于是，我找到了曾经用过的easyX，并用它开发出了原形库。然而，在使用过程中，我发现很多底层的东西我无法掌控，无奈之下只能放弃。接着，我又发现了raylib，它基于SDL2，接口众多，封装得较为复杂。随后，我注意到了SFML，这是一个很不错的库，但考虑到它已经封装了很多内容，我想要掌握更多底层技术，最终还是弃用了它。最后，我选择了工业级别的SDL2库。这个库功能相对较少，但也意味着我自己的开发自由度更大，对底层的掌控力更强。</p>\n<p>所以，现在的版本是基于SDL2库开发的。最初，我将其命名为C++ Sprites库，后来又正式命名为C++精灵库。在开发过程中，我不断地进行修改和调试，只为让普通用户能够更好地上手使用。为了让这个库更加完善，我还中途开发了pxC++编辑器，这是专门为C++精灵库量身打造的编辑器。同时，我还开发了DevC++5.11升级包，使DevC++5.11能够支持C++精灵库，从而让它更好地融入到主流的中小学生C++教学生态中。</p>\n<p>现在的C++精灵库，比较完美地继承了Python turtle的血脉。不仅如此，我还针对Python turtle存在的不足之处进行了改进与优化。例如，我精心设计了fill命令，角色通过使用fill命令，就可以在封闭区域进行洪水填充。在设定画笔颜色方面，不仅能够让角色的画笔颜色命令接受字符串作为参数，还能接受1个整数或多个整数作为参数。这是因为我对pencolor命令进行了多次重载，使其具有更高的灵活性和自由度。</p>\n<p>此外，我还为角色的画笔增添了许多实用的方法。比如，设计了设定阴影度的penshade方法，以及设定颜色饱和度的pensat方法和设定颜色明度的penvalue方法。后来又进一步设计了直接设定颜色的Hue、Saturation及Value的penhsv方法，还有修改颜色透明度的penalpha方法。不仅如此，还为角色设计了贝塞尔曲线与样条曲线等方法。这些精心设计的设定，对于审美能力强的美术生来说，无疑提供了极大的便利，使他们能够更加轻松地创作出具有艺术效果的图形。</p>\n<p>现在我们所看到的“C++精灵库”，本质上是基于logo计算机语言编程教育理念在C++世界的延伸并有所超越。它借鉴了Python turtle简洁的API，并针对教育场景进行了深入优化。这样一来，学生们就能够在一个更强大、更接近工业标准的语言环境中，充分体验到“海龟作图”的乐趣与智慧。我们可以把Python turtle和C++精灵库比作是亲兄弟，无论先学习哪一个，再去学习另一个，都会有一种“似曾相识燕归来”的熟悉感，这就是所谓的“双倍赋能”。因为编程的世界在底层本来就是相通的，当我把它们的外观也设计得相似的时候，请不要感到惊讶！</p>\n<p>更值得一提的是，由于C++精灵库是基于SDL2库进行开发的，它还能够完美融入SDL2库的命令，为学生提供更深入的编程学习机会。想象一下，SDL2库在各行各业中的广泛应用场景，C++精灵库无疑为学生的未来学习和职业发展赋予了其他类C++ turtle库无法比拟的优势。</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-22 11:17</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lixingqiu\">李兴球</a>&nbsp;\n阅读(<span id=\"post_view_count\">124</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Qt技巧笔记(三)：QSpinBox数值微调框组件笔记",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19516012",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19516012\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 11:05\">\n    <span>Qt技巧笔记(三)：QSpinBox数值微调框组件笔记</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        QSpinBox是Qt框架中的一个部件(Widget)，用于提供一个方便用户输入整数值的界面元素。它通常以微调框(QSpinBox)的形式展示，用户可以通过微调框上的按钮或手动输入来增加或减少整数值。在实际使用中该控件主要用于整型或浮点的计数显示，与普通的LineEdit组件不同，该组件可以在前后增加特殊符号并提供了上下幅度的调整按钮，灵活性更强。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>​        Qt是一个跨平台C++图形界面开发库，利用Qt可以快速开发跨平台窗体应用程序，在Qt中我们可以通过拖拽的方式将不同组件放到指定的位置，实现图形化开发极大的方便了开发效率，本笔记将重点介绍QSpinBox数值微调组件的常用方法及灵活应用。</p>\n<p>​       QSpinBox是Qt框架中的一个部件(Widget)，用于提供一个方便用户输入整数值的界面元素。它通常以微调框(QSpinBox)的形式展示，用户可以通过微调框上的按钮或手动输入来增加或减少整数值。在实际使用中该控件主要用于整型或浮点的计数显示，与普通的LineEdit组件不同，该组件可以在前后增加特殊符号并提供了上下幅度的调整按钮，灵活性更强。其使用场景：</p>\n<ul>\n<li>\n<p><strong>数值输入</strong>：适用于需要用户输入整数值的场景，如设置计算参数、调整数量等。</p>\n</li>\n<li>\n<p><strong>调整参数</strong>：在需要进行微小调整的地方，提供直观的增减按钮。</p>\n</li>\n<li>\n<p><strong>限制输入范围</strong>：当需要确保用户输入在一定范围内时，可以设置参数的最大值和最小值；</p>\n</li>\n<li>\n<p><strong>只读展示</strong>：可以用于只读展示某个数值，不允许用户修改。</p>\n<p>以下是QSpinBox类的一些常用方法API，说明并概述成表格：</p>\n<table>\n<thead>\n<tr>\n<th>方法API</th>\n<th>描 述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>QSpinBox(QWidget *parent = nullptr)</code></td>\n<td>构造函数，创建一个整数微调框。</td>\n</tr>\n<tr>\n<td><code>int value() const</code></td>\n<td>获取当前微调框中的整数值。</td>\n</tr>\n<tr>\n<td><code>void setValue(int value)</code></td>\n<td>设置微调框的整数值。</td>\n</tr>\n<tr>\n<td><code>int minimum() const</code></td>\n<td>获取微调框的最小值。</td>\n</tr>\n<tr>\n<td><code>void setMinimum(int min)</code></td>\n<td>设置微调框的最小值。</td>\n</tr>\n<tr>\n<td><code>int maximum() const</code></td>\n<td>获取微调框的最大值。</td>\n</tr>\n<tr>\n<td><code>void setMaximum(int max)</code></td>\n<td>设置微调框的最大值。</td>\n</tr>\n<tr>\n<td><code>int singleStep() const</code></td>\n<td>获取单步步进值，即微调框在每次增减操作时的变化量。</td>\n</tr>\n<tr>\n<td><code>void setSingleStep(int step)</code></td>\n<td>设置单步步进值。</td>\n</tr>\n<tr>\n<td><code>int prefix() const</code></td>\n<td>获取前缀（显示在值之前的文本）。</td>\n</tr>\n<tr>\n<td><code>void setPrefix(const QString &amp;prefix)</code></td>\n<td>设置前缀。</td>\n</tr>\n<tr>\n<td><code>int suffix() const</code></td>\n<td>获取后缀（显示在值之后的文本）。</td>\n</tr>\n<tr>\n<td><code>QString cleanText() const</code></td>\n<td>获取文本表示的干净值，即不包含前缀和后缀的纯文本值。</td>\n</tr>\n<tr>\n<td><code>bool wrapping() const</code></td>\n<td>检查微调框是否启用了循环，即在达到最大或最小值时是否绕回。</td>\n</tr>\n<tr>\n<td><code>void setWrapping(bool on)</code></td>\n<td>启用或禁用微调框的循环。</td>\n</tr>\n<tr>\n<td><code>void stepUp()</code></td>\n<td>将微调框的值增加一个单步步进值</td>\n</tr>\n<tr>\n<td><code>void stepDown()</code></td>\n<td>将微调框的值减少一个单步步进值。</td>\n</tr>\n<tr>\n<td><code>void setAccelerated(bool on)</code></td>\n<td>启用或禁用加速，即按住上下箭头时值的变化速度是否逐渐加快。</td>\n</tr>\n<tr>\n<td><code>bool isAccelerated() const</code></td>\n<td>检查是否启用了加速。</td>\n</tr>\n<tr>\n<td><code>void setReadOnly(bool ro)</code></td>\n<td>设置微调框为只读模式，禁止用户编辑值。</td>\n</tr>\n<tr>\n<td><code>bool isReadOnly() const</code></td>\n<td>检查微调框是否为只读模式。</td>\n</tr>\n<tr>\n<td><code>void setAlignment(Qt::Alignment align)</code></td>\n<td>设置微调框中文本的对齐方式。</td>\n</tr>\n<tr>\n<td><code>Qt::Alignment alignment() const</code></td>\n<td>获取微调框中文本的对齐方式。</td>\n</tr>\n<tr>\n<td><code>void setButtonSymbols(QAbstractSpinBox::ButtonSymbols bs)</code></td>\n<td>设置增减按钮的显示方式。</td>\n</tr>\n<tr>\n<td><code>QAbstractSpinBox::ButtonSymbols buttonSymbols() const</code></td>\n<td>获取增减按钮的显示方式。</td>\n</tr>\n</tbody>\n</table>\n<p>这些方法涵盖了QSpinBox类中一些常用的设置和获取整数微调框属性的功能。其信号部分</p>\n<table>\n<thead>\n<tr>\n<th>信号声明</th>\n<th>信号说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>void textChanged(const QString &amp;text)</code></td>\n<td>微调框的文本发生改变时会触发，参数<code>QString</code>带有前缀和后缀</td>\n</tr>\n<tr>\n<td><code>void valueChanged(int i)</code></td>\n<td>微调框的⽂本发⽣改变时会触发，参数 int，表示当前的数值</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ul>\n<p>接下来将用一个简单的案例展示如何使用 QSpinBox组件，该组件有两个版本：QSpinBox用于展示单精度浮点数，而<code>QDoubleSpinBox()</code> 则可以展示精度更高的数值，需要注意的是，该组件有两个特殊参数，当使用setPrefix() 时可以指定在前方加入特殊符号，而使用 setSuffix() 时则可以在后方追加特殊符号，我们就可以后方追加为例。</p>\n<p>以下是一个使用 QSpinBox 的 C++ Qt 示例，展示了如何创建控件、设置属性并连接信号：</p>\n<pre><code class=\"language-C++\">#include &lt;QApplication&gt;\n#include &lt;QWidget&gt;\n#include &lt;QSpinBox&gt;\n#include &lt;QVBoxLayout&gt;\n#include &lt;QDebug&gt;\n\nclass MainWindow : public QWidget {\n    Q_OBJECT\npublic:\n    MainWindow() {\n        QSpinBox *spinBox = new QSpinBox(this);\n        spinBox-&gt;setRange(0, 100);      // 设置范围 0-100\n        spinBox-&gt;setValue(10);          // 设置初始值\n        spinBox-&gt;setSingleStep(5);      // 设置步长为 5\n\n        // 连接值改变信号到槽函数\n        connect(spinBox, QOverload&lt;int&gt;::of(&amp;QSpinBox::valueChanged),\n                this, &amp;MainWindow::onValueChanged);\n\n        QVBoxLayout *layout = new QVBoxLayout(this);\n        layout-&gt;addWidget(spinBox);\n    }\n\npublic slots:\n    void onValueChanged(int value) {\n        qDebug() &lt;&lt; \"Spin box value changed to:\" &lt;&lt; value;\n    }\n};\n\nint main(int argc, char *argv[]) {\n    QApplication app(argc, argv);\n    MainWindow window;\n    window.show();\n    return app.exec();\n}\n\n</code></pre>\n<h3 id=\"参考资料\">参考资料：</h3>\n<p><a href=\"https://cloud.tencent.com/developer/article/2370336\" rel=\"noopener nofollow\" target=\"_blank\">C++ Qt开发：SpinBox数值微调框组件-腾讯云开发者社区-腾讯云</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 11:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">34</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}