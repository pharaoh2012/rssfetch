{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "20260109 - TRU 协议攻击事件分析：买得够多免费送了喂！",
      "link": "https://www.cnblogs.com/ACaiGarden/p/19465686",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ACaiGarden/p/19465686\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 15:42\">\n    <span>20260109 - TRU 协议攻击事件分析：买得够多免费送了喂！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>20260109，ETH 链上的 TRU 协议遭受了黑客攻击，损失约 2600 万美元。漏洞原因是计算购买 TRU 代币所需要的 ETH 数量的计算公式设计存在缺陷，购买大量 TRU 代币时会因为精度丢失而得到 0 值，使得攻击者可以以 0 ETH 购买大量的 TRU 代币，最后抛售完成获利。</p>\n<ul>\n<li>TX：<a href=\"https://app.blocksec.com/explorer/tx/eth/0xcd4755645595094a8ab984d0db7e3b4aabde72a5c87c4f176a030629c47fb014\" rel=\"noopener nofollow\" target=\"_blank\">https://app.blocksec.com/explorer/tx/eth/0xcd4755645595094a8ab984d0db7e3b4aabde72a5c87c4f176a030629c47fb014</a></li>\n</ul>\n<h1 id=\"trace-分析\">Trace 分析</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154123776-1794652238.png\" /></p>\n<ol>\n<li>黑客调用 buyTRU() 函数以零成本购入大量的 TRU 代币</li>\n<li>然后调用 sellTRU() 函数卖出所有 TRU 代币完成获利</li>\n</ol>\n<p>随后攻击者利用漏洞以零或极低成本的价格购买 TRU 代币后出售的流程重复多次。</p>\n<h1 id=\"代码分析\">代码分析</h1>\n<p>TRU 合约是一个代理合约：0x764C64b2A09b09Acb100B80d8c505Aa6a0302EF2</p>\n<p>其具体的逻辑逻辑合约为：0x18ceDF1071EC25331130C82D7AF71D393Ccd4446</p>\n<p>由于逻辑合约并没有开源，所以接下来会采用 dedaub 反编译 + 人工校正的方式分析项目的业务逻辑。</p>\n<ul>\n<li>逻辑合约的反编译地址：<a href=\"https://app.dedaub.com/ethereum/address/0xc186e6f0163e21be057e95aa135edd52508d14d3/decompiled\" rel=\"noopener nofollow\" target=\"_blank\">https://app.dedaub.com/ethereum/address/0xc186e6f0163e21be057e95aa135edd52508d14d3/decompiled</a></li>\n</ul>\n<p>在 buyTRU() 函数中，会根据输入的 TRUAmount 参数值计算所需要的 ETH 数量，并检查 msg.value 的值是否为相等。通过检查后，会给用户 mint TRUAmount 数量的 TRU 代币。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154138455-1713236541.png\" /></p>\n<p>其问题就出在计算 ETH 数量的 TRUtoETH() 函数上，其反编译的内容如下，根据输入的 TRUAmount 值进行一系列的计算。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154148291-397462858.png\" /></p>\n<p>通过 solidity 重写这个函数，得到以下的内容。其中 _setParameters 的值为 75，代表 75% 的一个比例。</p>\n<pre><code class=\"language-solidity\">function TRUtoETH(uint256 TRUAmount) private view returns (uint256) {\n    uint256 totalSupply = TRU.totalSupply();\n    \n    // numerator: (100 - 75) * totalSupply² = 25 * totalSupply²\n    uint256 numerator = (100 - _setParameters) * totalSupply * totalSupply;\n    \n    // denominator: 100 * TRUAmount * _reserve * (TRUAmount + 2 * totalSupply)\n    uint256 denominator = 100 * TRUAmount * _reserve * (TRUAmount + 2 * totalSupply);\n    \n    return numerator / denominator;\n}\n\n</code></pre>\n<p>由上面的代码分析可得，当 _setParameters，totalSupply 和 _reserve 为固定值时，传入的参数 TRUAmount 越大，分母就越大，返回值就会相应的变小。而当分母大于分子时，由于 solidity 精度丢失的特性，返回值将会为 0。也就是说：</p>\n<blockquote>\n<p>当 TRUAmount 的值非常大，当前的计算公式在计算所需要提供的 ETH 数量时，会由于 solidity 的精度丢失返回 0 值。</p>\n</blockquote>\n<p>这样，攻击者就完成了攻击的第一个步骤：以零或极低成本的价格购买 TRU 代币。</p>\n<p>随后就是正常使用 sellTRU() 函数卖出所有 TRU 代币完成了获利。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154205268-1163820900.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 15:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ACaiGarden\">ACai_sec</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【Azure Redis】客户端应用使用 Azure Redis Cluster 报错 java.security.cert.CertificateException: No subject alternative names matching IP address xxx.xxx.xxx.xxx found",
      "link": "https://www.cnblogs.com/lulight/p/19464831",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19464831\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 12:02\">\n    <span>【Azure Redis】客户端应用使用 Azure Redis Cluster 报错 java.security.cert.CertificateException: No subject alternative names matching IP address xxx.xxx.xxx.xxx found</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>问题描述</h1>\n<p>使用Azure Cache for Redis的集群模式。应用客户端为Java代码，使用Lettuce 作为Redis 客户端SDK。启动项目报错：<span style=\"color: rgba(255, 0, 0, 1);\"><strong><span style=\"font-style: italic; background-color: initial;\">Caused by: java.security.cert.CertificateException: No subject alternative names matching IP address 159.27.xxx.xxx found。</span></strong></span></p>\n<h2><span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: initial;\">运行时的错误截图</span></strong></span></h2>\n<p><img alt=\"image\" class=\"lazyload\" height=\"435\" width=\"666\" /></p>\n<h2>示例代码</h2>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.lbazureredis;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.RedisURI;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.RedisClusterClient;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Main {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> main(String[] args) {\n        \n        System.out.println(</span>\"Hello world! This is Redis Cluster example.\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        \n        RedisURI redisUri </span>= RedisURI.Builder.redis(\"&lt;yourredisname&gt;.redis.cache.chinacloudapi.cn\", 6380<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPassword(</span>\"&lt;your redis access key&gt;\").withSsl(<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">).build();\n        RedisClusterClient clusterClient </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> RedisClusterClient.create(redisUri);\n        StatefulRedisClusterConnection</span>&lt;String, String&gt; connection =<span style=\"color: rgba(0, 0, 0, 1);\"> clusterClient.connect();\n        RedisAdvancedClusterCommands</span>&lt;String, String&gt; syncCommands =<span style=\"color: rgba(0, 0, 0, 1);\"> connection\n                .sync();\n\n        String pingResponse </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> syncCommands.ping();\n        System.out.println(</span>\"Ping response: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> pingResponse);\n\n        syncCommands.set(</span>\"mykey\", \"Hello, Redis Cluster!\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        String value </span>= syncCommands.get(\"mykey\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        System.out.println(</span>\"Retrieved value: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> value);\n        \n        connection.close();\n        clusterClient.shutdown();\n\n    }\n}</span></pre>\n</div>\n<h2>项目POM.xml</h2>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">&lt;?</span><span style=\"color: rgba(255, 0, 255, 1);\">xml version=\"1.0\" encoding=\"UTF-8\"</span><span style=\"color: rgba(0, 0, 255, 1);\">?&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">project </span><span style=\"color: rgba(255, 0, 0, 1);\">xmlns</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"http://maven.apache.org/POM/4.0.0\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n         xmlns:xsi</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"http://www.w3.org/2001/XMLSchema-instance\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n         xsi:schemaLocation</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">modelVersion</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>4.0.0<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">modelVersion</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>com.lbazureredis<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>test<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>1.0-SNAPSHOT<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">properties</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.source</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>17<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.source</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.target</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>17<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.target</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">properties</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">dependencies</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> Lettuce Redis Client </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>io.lettuce<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>lettuce-core<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>6.3.1.RELEASE<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> SLF4J for logging </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>org.slf4j<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>slf4j-simple<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>2.0.9<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">dependencies</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">project</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span></pre>\n</div>\n<p><span style=\"font-size: 18px; color: rgba(255, 0, 0, 1);\"><strong>针对以上问题，如何解决呢？</strong></span></p>\n<p>&nbsp;</p>\n<h1>问题解答</h1>\n<p>根据错误信息搜索后，得到Azure官方最佳实践文档中的解答：<a href=\"https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md</a></p>\n<blockquote>\n<p>The reason this is required is because SSL certification validates the address of the Redis Nodes with the SAN (Subject Alternative Names) in the SSL certificate. <strong>Redis protocol requires that these node addresses should be IP addresses.</strong> However, the SANs in<strong> the Azure Redis SSL certificates contains only the Hostname</strong> since Public IP addresses can change and as a result not completely secure.</p>\n<p>在Redis Protocol验证中，必须验证证书中包含IP地址，但由于Azure Redis部署在云环境中，IP地址是不固定的。所以默认情况下，Redis SSL证书中包含的是域名。为了解决这个问题，需要建立一个Host与IP地址的映射关系，使得Lettuce客户端在验证Redis证书时通过域名验证而非IP地址，用于解决<strong>No subject alternative names matching IP address 159.27.xxx.xxx found </strong>问题</p>\n</blockquote>\n<p>参考文档中的方法，自定义<strong><code>MappingSocketAddressResolver</code></strong></p>\n<div class=\"cnblogs_code\">\n<pre>        Function&lt;HostAndPort, HostAndPort&gt; <span style=\"background-color: rgba(255, 204, 0, 1);\">mappingFunction</span> = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Function&lt;HostAndPort, HostAndPort&gt;<span style=\"color: rgba(0, 0, 0, 1);\">() {\n            @Override\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort apply(HostAndPort hostAndPort) {\n                String cacheIP </span>= \"\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                    InetAddress[] addresses </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DnsResolvers.JVM_DEFAULT.resolve(host);\n                    cacheIP </span>= addresses[0<span style=\"color: rgba(0, 0, 0, 1);\">].getHostAddress();\n                } </span><span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (UnknownHostException e) {\n                    e.printStackTrace();\n                }\n                HostAndPort finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> hostAndPort;\n\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (hostAndPort.hostText.equals(cacheIP))\n                    finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort.of(host, hostAndPort.getPort());\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> finalAddress;\n            }\n        };\n\n        <span style=\"background-color: rgba(255, 204, 0, 1);\">MappingSocketAddressResolver</span> resolver </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MappingSocketAddressResolver.create(DnsResolvers.JVM_DEFAULT,\n                mappingFunction);\n        <span style=\"background-color: rgba(255, 204, 0, 1);\">ClientResources</span> res </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DefaultClientResources.builder()\n                .socketAddressResolver(resolver).build();\n        RedisURI redisURI </span>= RedisURI.Builder.redis(host).withSsl(<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPassword(password)\n                .withClientName(</span>\"LettuceClient\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPort(</span>6380<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .build();\n        RedisClusterClient redisClient </span>= RedisClusterClient.create(<span style=\"background-color: rgba(255, 204, 0, 1);\">res</span>, redisURI);</pre>\n</div>\n<h2>代码解读</h2>\n<blockquote>\n<h3>mappingFunction</h3>\n<ul>\n<li>它是一个自定义的地址映射逻辑，用于处理 Lettuce 在连接 Redis 集群时的主机名与 IP 地址问题。</li>\n<li>它通过 DnsResolvers.JVM_DEFAULT 对指定的域名进行 DNS 解析，获取对应的 IP 地址。如果当前 HostAndPort 的 hostText 与解析出的 IP 相同，则将其替换为原始域名 host，保持端口不变。</li>\n<li>这一逻辑的核心目的是解决 SSL 证书校验问题，因为证书通常绑定域名而非 IP，确保连接时使用域名进行验证，避免因 IP 导致的握手失败。</li>\n</ul>\n<h3>MappingSocketAddressResolver</h3>\n<ul>\n<li>它是 Lettuce 提供的一个工具类，用于在连接 Redis 时插入自定义的地址解析逻辑。</li>\n<li>它结合默认的 DNS 解析器和 mappingFunction，在每次解析 Socket 地址时执行映射操作。</li>\n<li>通过这种方式，客户端可以在 DNS 解析后对结果进行二次处理，例如将 IP 地址重新映射为域名。</li>\n<li>这对于云服务场景（如 Azure Redis）非常重要，因为这些服务的 SSL 证书通常只对域名有效，而不是 IP 地址。</li>\n</ul>\n<h3>DefaultClientResources</h3>\n<ul>\n<li><span style=\"background-color: initial; font-size: 14px;\">作为 Lettuce 的核心资源管理器，用于配置客户端的底层行为，包括线程池、DNS 解析器、事件循环等。在这里，它的作用是将自定义的 MappingSocketAddressResolver 注入到客户端资源中，使所有连接请求都遵循自定义的地址解析逻辑。</span></li>\n<li><span style=\"background-color: initial; font-size: 14px;\">通过这种方式，整个 Lettuce 客户端在连接 Redis 集群时都会使用域名而非 IP，确保 SSL 校验通过，同时保持连接的稳定性和安全性。</span></li>\n</ul>\n</blockquote>\n<p>&nbsp;</p>\n<h2>执行结果</h2>\n<p>再次运行，成功连接到Azure Redis Cluster 及执行Ping, Set, Get指令！</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"541\" width=\"999\" /></p>\n<h2>修改后完整的Java示例代码如下：</h2>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.lbazureredis;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.net.InetAddress;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.net.UnknownHostException;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.time.Duration;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.function.Function;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.RedisURI;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.SocketOptions;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.api.StatefulRedisConnection;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.ClusterClientOptions;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.ClusterTopologyRefreshOptions;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.RedisClusterClient;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.async.RedisAdvancedClusterAsyncCommands;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.internal.HostAndPort;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.ClientResources;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.DefaultClientResources;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.DnsResolvers;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.MappingSocketAddressResolver;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Main {\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> main(String[] args) {\n\n        System.out.println(</span>\"Hello world! This is Redis Cluster example.\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n\n        String host </span>= \"&lt;yourredisname&gt;.redis.cache.chinacloudapi.cn\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n        String password </span>= \"&lt;your redis access key&gt;\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n\n        Function</span>&lt;HostAndPort, HostAndPort&gt; <span style=\"background-color: rgba(255, 204, 0, 1);\">mappingFunction</span> = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Function&lt;HostAndPort, HostAndPort&gt;<span style=\"color: rgba(0, 0, 0, 1);\">() {\n            @Override\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort apply(HostAndPort hostAndPort) {\n                String cacheIP </span>= \"\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                    InetAddress[] addresses </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DnsResolvers.JVM_DEFAULT.resolve(host);\n                    cacheIP </span>= addresses[0<span style=\"color: rgba(0, 0, 0, 1);\">].getHostAddress();\n                } </span><span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (UnknownHostException e) {\n                    e.printStackTrace();\n                }\n                HostAndPort finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> hostAndPort;\n\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (hostAndPort.hostText.equals(cacheIP))\n                    finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort.of(host, hostAndPort.getPort());\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> finalAddress;\n            }\n        };\n\n        MappingSocketAddressResolver resolver </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MappingSocketAddressResolver.create(DnsResolvers.JVM_DEFAULT,\n                <span style=\"background-color: rgba(255, 204, 0, 1);\">mappingFunction</span>);\n        ClientResources res </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DefaultClientResources.builder()\n                .socketAddressResolver(resolver).build();\n        RedisURI redisURI </span>= RedisURI.Builder.redis(host).withSsl(<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPassword(password)\n                .withClientName(</span>\"LettuceClient\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPort(</span>6380<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .build();\n        RedisClusterClient redisClient </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> RedisClusterClient.create(<span style=\"background-color: rgba(255, 204, 0, 1);\">res</span>, redisURI);\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Cluster specific settings for optimal reliability.</span>\n        ClusterTopologyRefreshOptions refreshOptions =<span style=\"color: rgba(0, 0, 0, 1);\"> ClusterTopologyRefreshOptions.builder()\n                .enablePeriodicRefresh(Duration.ofSeconds(</span>5<span style=\"color: rgba(0, 0, 0, 1);\">))\n                .dynamicRefreshSources(</span><span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                .adaptiveRefreshTriggersTimeout(Duration.ofSeconds(</span>5<span style=\"color: rgba(0, 0, 0, 1);\">))\n                .enableAllAdaptiveRefreshTriggers().build();\n        redisClient.setOptions(ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder()\n                        .keepAlive(</span><span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                        .build())\n                .topologyRefreshOptions(refreshOptions).build());\n                \n        StatefulRedisClusterConnection</span>&lt;String, String&gt; connection =<span style=\"color: rgba(0, 0, 0, 1);\"> redisClient.connect();\n        RedisAdvancedClusterCommands</span>&lt;String, String&gt; syncCommands =<span style=\"color: rgba(0, 0, 0, 1);\"> connection.sync();\n        RedisAdvancedClusterAsyncCommands</span>&lt;String, String&gt; asyncCommands =<span style=\"color: rgba(0, 0, 0, 1);\"> connection.async();\n\n        String pingResponse </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> syncCommands.ping();\n        System.out.println(</span>\"Ping response: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> pingResponse);\n\n        syncCommands.set(</span>\"mykey\", \"Hello, Redis Cluster!\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        String value </span>= syncCommands.get(\"mykey\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        System.out.println(</span>\"Retrieved value: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> value);\n\n        connection.close();\n\n        redisClient.shutdown();\n\n    }\n}</span></pre>\n</div>\n<h2>代码流程图</h2>\n<p>基于AI模型解读以上代码后，分析出来的代码流程图</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"256\" width=\"666\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1>参考资料</h1>\n<div class=\"markdown-heading\" dir=\"auto\">\n<p class=\"heading-element\" dir=\"auto\">Best Practices for using Azure Cache for Redis with Lettuce ：<a href=\"https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md</a></p>\n<div>&nbsp;</div>\n<a class=\"anchor\" href=\"https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md#best-practices-for-using-azure-cache-for-redis-with-lettuce\" id=\"user-content-best-practices-for-using-azure-cache-for-redis-with-lettuce\" rel=\"noopener nofollow\"></a></div>\n</div>\n<div id=\"MySignature\">\n    <div style=\"background: #1c5f55; height: 36px; width: 618px; padding: 14px 5px 0px 3px;\">\n  <p style=\"font-weight: bold; color: white;\">当在复杂的环境中面临问题，格物之道需：浊而静之徐清，安以动之徐生。 云中，恰是如此!</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 12:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lulight\">路边两盏灯</a>&nbsp;\n阅读(<span id=\"post_view_count\">18</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "棒棒糖图：当条形图遇上极简美学",
      "link": "https://www.cnblogs.com/wang_yb/p/19464212",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19464212\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 08:42\">\n    <span>棒棒糖图：当条形图遇上极简美学</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>棒棒糖图</strong>（Lollipop Chart）可以看作是条形图的一种“轻盈版”变体：它用一根从基准线延伸出来的“棒”，并在末端以一个“糖”（圆点）来表示数值，取代了传统的矩形条。</p>\n<p>这种图表传达的信息与条形图是一样的，但它更注重突出数据点的位置，整体看起来更加清新、现代。</p>\n<p>今天，我们一起探索棒棒糖图的优势，并通过代码实现，亲手打造一个属于自己的棒棒糖图！</p>\n<h1 id=\"设计原理\">设计原理</h1>\n<p>设计棒棒糖图的初衷有两个方面：</p>\n<p>首先，通过减少图形中的“墨水”使用量，在面对大量类别或数值普遍较高的情况下，避免了条形图过于密集可能带来的<strong>视觉压迫感</strong>和<strong>杂乱无章</strong>的感觉；</p>\n<p>其次，这样的设计能够更好地引导观察者的注意力集中在各个数据点的具体位置及其之间的差异上，非常适合用来进行排名或者对比分析。</p>\n<p><strong>棒棒糖图</strong>与<strong>条形图</strong>在功能上是等价的，也并不总是优于条形图。</p>\n<p>当处理大量类别、条柱非常高且相互之间距离较近的数据时，棒棒糖图会显得更加易于阅读理解；</p>\n<p>然而，在需要强调绝对数量或是希望获得最为直观长度比较的情况下，条形图依然是更好的选择。</p>\n<h1 id=\"实现原理\">实现原理</h1>\n<p><strong>棒棒糖图</strong>在<code>matplotlib</code>库中没有直接对应的类。</p>\n<p>不过，它的实现原理非常简单，通过组合使用 <code>matplotlib</code> 中的两个基本绘图功能就可以实现：</p>\n<ol>\n<li><strong>绘制线条</strong> (<code>plt.vlines</code>)：这是构成棒棒糖“棍子”部分的关键。</li>\n</ol>\n<p><code>plt.vlines</code> 函数用于在图表上绘制垂直线段。通过指定每个数据点的 x 坐标、线条的起始点（通常是 0）和结束点（即对应数据的 y 值），就可以画出从 x 轴延伸到数据值的线条。</p>\n<ol start=\"2\">\n<li><strong>绘制圆点</strong> (<code>plt.scatter</code>)：这是构成棒棒糖“糖”部分的关键。</li>\n</ol>\n<p><code>plt.scatter</code> 函数用于绘制散点图。通过将每个数据点的 x 坐标和 y 坐标（即数据值）作为参数传入，就可以在每条线的顶端绘制一个圆点。</p>\n<p>总的来说，<strong>实现原理</strong>就是：用线条表示数值的大小，用圆点强调数值的终点位置，两者结合就形成了视觉上类似棒棒糖的图表。</p>\n<p>这种组合方式使得图表比实心的条形图更简洁，同时又能清晰地传达数据信息。</p>\n<p>下一节的示例中，将会演示如何使用<code>matplotlib</code>来绘制<strong>棒棒糖图</strong>。</p>\n<h1 id=\"应用示例\">应用示例</h1>\n<p>接下来，让我们通过实际的对比示例，直观地感受棒棒糖图与传统条形图的不同表现。</p>\n<h2 id=\"适合棒棒糖图的场景\">适合棒棒糖图的场景</h2>\n<pre><code class=\"language-python\"># 创建更多类别的测试数据\n# 模拟不同月份中每天的某个指标（例如：每日平均步数，单位：千步）\ndays = [f\"Day {i}\" for i in range(1, 21)]  # 生成 20 天的数据\nnp.random.seed(42)  # 设置随机种子，确保每次运行结果一致\n# 生成 1 到 5 之间的随机数值作为示例数据\nvalues = np.round(np.random.uniform(1.0, 5.0, size=len(days)), 1)\n\n# --- 创建子图 ---\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))  # 调整为垂直布局，方便比较\n\n# --- 绘制条形图 (上图) ---\nbars = ax1.bar(days, values, color=\"skyblue\", edgecolor=\"navy\", linewidth=0.7)\nax1.set_title(\"条形图 (Bar Chart) - 每日步数\", fontsize=14)\nax1.set_ylabel(\"数值 (千步)\")\n# ax1.set_xlabel('日期') # x轴标签已在下方图中\nax1.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n# 在条形图上添加数值标签\nfor bar, val in zip(bars, values):\n    height = bar.get_height()\n    ax1.text(\n        bar.get_x() + bar.get_width() / 2.0,\n        height + 0.05,\n        f\"{val}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=8,\n    )  # 标签旋转90度节省空间\n\n# --- 绘制棒棒糖图 (下图) ---\n# 1. 绘制线条\nax2.vlines(x=range(len(days)), ymin=0, ymax=values, color=\"navy\", linewidth=2)\n# 2. 在线条顶部绘制圆点\nax2.scatter(x=range(len(days)), y=values, color=\"red\", s=50, zorder=3)\n# 3. 添加数值标签\nfor i, val in enumerate(values):\n    ax2.text(i, val + 0.1, f\"{val}\", ha=\"center\", va=\"bottom\", fontsize=8)\n\nax2.set_title(\"棒棒糖图 (Lollipop Chart) - 每日步数\", fontsize=14)\nax2.set_ylabel(\"数值 (千步)\")\nax2.set_xlabel(\"日期\")\nax2.set_xticks(range(len(days)))\nax2.set_xticklabels(days, rotation=45, ha=\"right\")  # 旋转x轴标签以便阅读\nax2.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\nax2.set_ylim(0, max(values) * 1.1)\n\n# --- 显示图形 ---\nplt.tight_layout()  # 调整子图间距\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260110084120492-216729079.png\" /></p>\n<p>这个示例使用了20个数据类别（Day 1 到 Day 20）。</p>\n<p>你可以看到，在条形图中，许多蓝色的条形紧密地排列在一起，视觉上显得有些拥挤。</p>\n<p>而在棒棒糖图中，线条和圆点使得数据点之间的关系更加清晰，整体视觉效果更轻盈，更容易比较各个数值的大小和识别模式。</p>\n<h2 id=\"适合传统条形图的场景\">适合传统条形图的场景</h2>\n<pre><code class=\"language-python\"># 创建更适合条形图的测试数据\n# 模拟某公司连续12个月的销售额（单位：万元）\nmonths = [\n    \"1月\",\n    \"2月\",\n    \"3月\",\n    \"4月\",\n    \"5月\",\n    \"6月\",\n    \"7月\",\n    \"8月\",\n    \"9月\",\n    \"10月\",\n    \"11月\",\n    \"12月\",\n]\n# 生成有一定趋势和波动的销售额数据，例如有季节性高峰\nsales = [120, 110, 135, 140, 155, 170, 185, 180, 160, 150, 145, 165]\n\n# --- 创建子图 ---\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))\n\n# --- 绘制条形图 (左图) ---\nbars = ax1.bar(months, sales, color=\"lightsteelblue\", edgecolor=\"black\", linewidth=0.7)\nax1.set_title(\"条形图 (Bar Chart - 月份销售额)\", fontsize=14)\nax1.set_ylabel(\"销售额 (万元)\")\nax1.set_xlabel(\"月份\")\nax1.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n# 在条形图上添加数值标签\nfor bar, s in zip(bars, sales):\n    height = bar.get_height()\n    ax1.text(\n        bar.get_x() + bar.get_width() / 2.0,\n        height + 2,\n        f\"{s}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=9,\n    )\n\n# --- 绘制棒棒糖图 (右图) ---\nax2.vlines(x=range(len(months)), ymin=0, ymax=sales, color=\"gray\", linewidth=2)\nax2.scatter(x=range(len(months)), y=sales, color=\"coral\", s=50, zorder=3)\nfor i, s in enumerate(sales):\n    ax2.text(i, s + 3, f\"{s}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nax2.set_title(\"棒棒糖图 (Lollipop Chart - 月份销售额)\", fontsize=14)\nax2.set_ylabel(\"销售额 (万元)\")\nax2.set_xlabel(\"月份\")\nax2.set_xticks(range(len(months)))\nax2.set_xticklabels(months, rotation=45)  # 旋转x轴标签以防重叠\nax2.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\nax2.set_ylim(0, max(sales) * 1.1)\n\n# --- 显示图形 ---\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260110084120515-917001944.png\" /></p>\n<p>在这个示例中，数据代表的是连续的月份，数值本身代表的是销售额，这是一个“量”的概念。</p>\n<p>条形图的实心块能让人立刻感受到哪个月份的销售额更高，整体的分布和对比关系一目了然。</p>\n<p>而棒棒糖图虽然也展示了数据，但线条和圆点的组合在视觉上不如实心条形那样能直接传达“量”的感觉，尤其是在数值差异不是特别巨大时，对比效果会稍逊于条形图。</p>\n<h1 id=\"总结\">总结</h1>\n<p><strong>棒棒糖图</strong>就像数据可视化世界中的\"少即是多\"哲学体现。</p>\n<p>它不是要取代传统条形图，而是为数据可视化工具箱增加了一个有价值的选项。</p>\n<p>就像不同的画笔适合不同的绘画风格，不同的图表类型也适合不同的数据故事。</p>\n<p><strong>棒棒糖图</strong>的真正优势在于它改变了数据的<strong>\"讲述方式\"</strong>。</p>\n<p>它不说：\"这是所有信息，你自己找重点\"，而是说：\"看这里，这些是关键点\"。</p>\n<p>这种焦点导向的特性，使得棒棒糖图在现代快节奏的数据沟通中越来越受欢迎。</p>\n<p>设计可视化时，我们不妨问问自己：我想要观众首先看到什么？如果是精确的数值点和清晰的排名，那么棒棒糖图可能是你的理想选择。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 08:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">138</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Thread 类的基本用法、Java 线程的几种状态",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19463416",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19463416\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 00:05\">\n    <span>Thread 类的基本用法、Java 线程的几种状态</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"在java中thread类是多线程编程的核心\">在Java中，Thread类是多线程编程的核心。</h3>\n<h4 id=\"线程创建-thread-creation\">线程创建 (Thread Creation)</h4>\n<ul>\n<li>创建线程主要有两种逻辑：继承Thread类或实现Runnable接口。\n<ul>\n<li>方式1：继承 Thread 类，重写run()</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-java\">// 自定义线程类继承Thread\nclass MyThread extends Thread {\n    // 重写run()，定义线程执行逻辑\n    @Override\n    public void run() {\n        System.out.println(\"子线程执行：\" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread t = new MyThread();\n        t.start(); // 3. 调用start()启动线程（不能直接调用run()）\n    }\n}\n</code></pre>\n<ul>\n<li>方式2：实现Runnable接口，传给Thread</li>\n</ul>\n<pre><code class=\"language-java\">// 实现Runnable接口\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"子线程执行：\" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\npublic class Demo {\n    public static void main(String[] args) {\n        // 把Runnable实例传给Thread\n        Thread t = new Thread(new MyRunnable());\n        t.start(); // 启动线程\n    }\n}\n</code></pre>\n<h4 id=\"线程中断-thread-interruption\">线程中断 (Thread Interruption)</h4>\n<ul>\n<li>线程中断不是强制停止线程，而是一种协作机制，即给线程发一个“请停止”的信号。</li>\n<li>void interrupt()：标记线程为 “中断状态”</li>\n<li>boolean isInterrupted()：判断线程是否处于中断状态</li>\n<li>若线程在sleep/wait/join时被中断，会抛出InterruptedException，且中断状态会被清除</li>\n</ul>\n<pre><code class=\"language-java\">Thread t = new Thread(() -&gt; {\n    while (!Thread.currentThread().isInterrupted()) { // 检测中断状态\n        System.out.println(\"线程运行中...\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // 捕获中断异常后，中断状态会被清除，需手动终止循环\n            System.out.println(\"线程被中断\");\n            Thread.currentThread().interrupt(); // 重新标记中断（可选）\n            break;\n        }\n    }\n});\nt.start();\n// 主线程1秒后中断子线程\nThread.sleep(1000);\nt.interrupt();\n</code></pre>\n<h4 id=\"线程等待-thread-join\">线程等待 (Thread Join)</h4>\n<ul>\n<li>有时主线程需要等待子线程执行完毕后再继续执行，这时可以使用join()。</li>\n<li>t.join()：当前线程会进入阻塞状态，直到线程t执行结束。</li>\n<li>带参数的 join(long millis)：设置最大等待时间，如果超时线程还没结束，当前线程就不再等待。</li>\n</ul>\n<pre><code class=\"language-java\">Thread t = new Thread(() -&gt; {\n    System.out.println(\"子线程开始执行\");\n    try { Thread.sleep(2000); } catch (InterruptedException e) {}\n    System.out.println(\"子线程执行完毕\");\n});\nt.start();\n\n// 主线程等待t执行完（最多等3秒）\nt.join(3000); \nSystem.out.println(\"主线程继续执行\");\n</code></pre>\n<h4 id=\"线程休眠-thread-sleep\">线程休眠 (Thread Sleep)</h4>\n<ul>\n<li>static void sleep(long millis)：让当前线程暂停指定时间（不会释放锁），抛出InterruptedException</li>\n</ul>\n<pre><code class=\"language-java\">System.out.println(\"开始休眠\");\ntry {\n    Thread.sleep(2000); // 当前线程休眠2秒\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.println(\"休眠结束\");\n</code></pre>\n<h4 id=\"获取线程实例-get-current-instance\">获取线程实例 (Get Current Instance)</h4>\n<ul>\n<li>在编写通用代码（尤其是 Runnable 中）时，常需要知道是谁在运行。</li>\n<li>Thread.currentThread()：返回代码当前正在执行的那个线程对象的引用。</li>\n<li>常用操作：获取线程 ID (getId())、获取线程名称 (getName()) 等。</li>\n</ul>\n<pre><code class=\"language-java\">// 获取当前线程（这里是main线程）\nThread mainThread = Thread.currentThread();\nSystem.out.println(\"当前线程名：\" + mainThread.getName()); // 输出\"main\"\n\n// 子线程实例\nThread t = new Thread(() -&gt; {\n    Thread current = Thread.currentThread();\n    System.out.println(\"子线程名：\" + current.getName()); // 输出\"Thread-0\"\n});\nt.start();\n</code></pre>\n<hr />\n<h3 id=\"java线程的几种状态\">Java线程的几种状态</h3>\n<h4 id=\"线程状态一共有几种\">线程状态一共有几种？</h4>\n<ul>\n<li>Java线程共有6种状态：\n<ul>\n<li>NEW (新建)</li>\n<li>RUNNABLE (可运行)</li>\n<li>BLOCKED (阻塞)</li>\n<li>WAITING (等待)</li>\n<li>TIMED_WAITING (超时等待)</li>\n<li>TERMINATED (终止)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"每种状态的含义与切换条件\">每种状态的含义与切换条件</h4>\n<ol>\n<li>NEW (新建)</li>\n</ol>\n<ul>\n<li>含义：创建了线程对象（new Thread()），但尚未调用 start() 方法。</li>\n<li>切换：调用 start() 方法后，进入 RUNNABLE 状态。</li>\n</ul>\n<ol start=\"2\">\n<li>RUNNABLE (可运行)</li>\n</ol>\n<ul>\n<li>含义：Java 将操作系统中的“就绪（Ready）”和“运行中（Running）”两种状态统称为 RUNNABLE。处于该状态的线程可能正在 CPU 上执行，也可能正在等待操作系统分配时间片。</li>\n<li>切换：\n<ul>\n<li>就绪 -&gt; 运行：获得 CPU 时间片。</li>\n<li>运行 -&gt; 就绪：CPU 时间片用完，或主动调用 Thread.yield()。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>BLOCKED (阻塞)</li>\n</ol>\n<ul>\n<li>含义：线程正在等待获取一个排他锁（如进入synchronized 代码块/方法），但该锁目前被其他线程持有。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; BLOCKED：尝试进入 synchronized 区域失败。</li>\n<li>BLOCKED -&gt; RUNNABLE：其他线程释放锁，当前线程成功竞争到锁。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li>WAITING (等待)</li>\n</ol>\n<ul>\n<li>含义：线程处于无限期的等待状态，不会被分配 CPU 时间，必须等待其他线程显式地唤醒。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; WAITING：调用 Object.wait()（不带参数）、Thread.join()（不带参数）或 LockSupport.park()。</li>\n<li>WAITING -&gt; RUNNABLE：其他线程调用 Object.notify()、notifyAll() 或 LockSupport.unpark()。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>TIMED_WAITING (超时等待)</li>\n</ol>\n<ul>\n<li>含义：与 WAITING 类似，但在指定的时间后会自动唤醒，不需要其他线程显式唤醒。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; TIMED_WAITING：调用 Thread.sleep(ms)、Object.wait(ms)、Thread.join(ms) 等带时间参数的方法。</li>\n<li>TIMED_WAITING -&gt; RUNNABLE：时间结束，或被提前唤醒（如 notify()）。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"6\">\n<li>TERMINATED (终止)</li>\n</ol>\n<ul>\n<li>含义：线程已经执行完毕（run() 方法正常结束）或因异常退出了执行。</li>\n<li>切换：线程一旦进入此状态，生命周期结束，不可再次启动（再次调用 start() 会抛出异常）。</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 00:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">88</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "初识Tauri",
      "link": "https://www.cnblogs.com/-867259206/p/19463606",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/-867259206/p/19463606\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 23:24\">\n    <span>初识Tauri</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简述\">简述</h1>\n<p>Tauri是一个跨平台的开发框架，使用rust开发。前端用前端技术构建用户界面，后端使用rust和平台系统交互。</p>\n<h2 id=\"创建项目\">创建项目</h2>\n<p>可以用Bash/PowerShell/Fish/npm/deno/Cargo等工具创建项目。</p>\n<p>下面以pnpm示例：</p>\n<pre><code class=\"language-bash\">pnpm create tauri-app\n</code></pre>\n<p>后面的步骤和创建前端项目是一样的。根据提示选择前端的语言、框架等等。</p>\n<p>项目目录和前端项目也是一样的，只是多了一个src-tauri目录。</p>\n<p>src-tauri目录下就是rust代码，可以在里面编写供前端调用的方法，或者是给前端发送事件消息。</p>\n<p>界面的开发使用前端技术，可以用react，也可以用vue，或者其他前端框架。与平台系统交互的功能，用rust编写。</p>\n<p>对Web开发者来说，用这个技术可以快速地创建桌面应用。</p>\n<h2 id=\"发布\">发布</h2>\n<p>要打包成桌面应用的话，执行build命令就好。</p>\n<p>继续以pnpm为例：</p>\n<pre><code class=\"language-bash\">pnpm tauri build\n</code></pre>\n<blockquote>\n<p>提示：build之前要先安装rust环境</p>\n</blockquote>\n<p>目前Tauri支持Linux、macOS、Windows、Android、iOS。</p>\n<p>打包后的启动程序在src-tauri/target/release/bundle目录下。执行安装程序，安装好后，就可以打开编写的桌面应用了。</p>\n<h1 id=\"架构\">架构</h1>\n<p><img alt=\"架构\" class=\"lazyload\" />Tauri的核心包含一个Tauri的运行时，tauri-runtime在tauri本身和底层的webview抽象层中充当一个胶水层。</p>\n<p>Tauri使用WRY这个开源库做webview的抽象层。WRY是一个rust编写的webview渲染库，可以支持各种平台的桌面应用。在WRY和tauri-runtime之间，有一个tauri-runtime-wry，这一层为WRY定义了系统级的交互。</p>\n<p>而WRY的下层依赖TAO。TAO是基于winit的一个fork。这是一个rust编写的跨平台的窗口管理类库。支持几乎所有的主流平台，Windows、Linux、Mac OS、Android、iOS……</p>\n<p>最后简单总结：Tauri实现跨平台应用的方式是，实现一个webview的抽象，从而可以用前端技术编写GUI，webview抽象层的底层，则依赖rust的窗口管理类库，调用各个平台系统的webview库。</p>\n<h1 id=\"总结\">总结</h1>\n<p>用rust作后端，使Tauri有很高的性能。但是调用平台系统本身webview的跨平台方式，使GUI在不同平台上的表现不一致，有兼容性问题。</p>\n<p>和electron相比，拥有更小的包体积，因为没有打包chromium，也没有源码泄露之类的风险，性能也更好，还能打包移动端，但是会有兼容性问题，而且后端用rust的话，不如electron好上手，如果不是rust熟手的话。</p>\n<p>和flutter相比，同样有兼容性问题，dart也比rust好学。</p>\n<p>对rust开发者来说，只需要找rust的GUI库就行，没有必要去用前端编写GUI。而对前端开发者来说，rust又增加了开发的学习成本。这个框架，感觉只适合同时会rust的前端熟手。而且只有少数对性能要求较高的场景会需要使用，其他场景electron也不差。如果要开发跨平台的应用，兼容性又是一个问题。实际的产品表现，肯定不如flutter这类框架。</p>\n<p>在前端工具链也越来越多使用rust语言的时候，Tauri这些rust编写的框架也被一些前端开发者所使用。但如果我要开发一个跨平台的应用的话，我觉得自带绘图库的flutter的方案是最佳的。Tauri的兼容性问题，仍不能满足做商业应用的要求，能使用的场景太少了。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 23:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/-867259206\">池月</a>&nbsp;\n阅读(<span id=\"post_view_count\">125</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款基于 .NET 9 构建的企业级 Web RBAC 快速开发框架",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19463583",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19463583\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 23:03\">\n    <span>一款基于 .NET 9 构建的企业级 Web RBAC 快速开发框架</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>今天大姚给大家分享一款基于 .NET 9 构建的企业级、开源 Web RBAC 快速开发框架：RuYiAdmin。</span></p>\n<h2><span>项目介绍</span></h2>\n<p><span>RuYiAdmin 一款基于 .NET 9 构建的企业级、前后端分离、开源（Apache License） Web RBAC 快速开发框架，具有灵活的架构设计和强大的功能，适用于快速开发高性能的企业级应用，具有低代码、跨平台、分布式、多线程和高性能等特色。</span></p>\n<h2><span>适用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><span>企业级后台管理系统：用于企业内部的各种管理任务，如用户管理、权限控制、数据统计等。</span></li>\n<li><span>内容管理系统（CMS）：用于网站内容的创建、编辑、发布和管理。</span></li>\n<li><span>客户关系管理（CRM）系统：帮助企业跟踪和管理客户信息、销售机会和客户服务请求。</span></li>\n</ul>\n<h2><span>主要特点</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>前后端分离：</strong><span>&nbsp;RuYiAdmin 采用前后端分离架构，前端基于VueElementAdmin，使用 Vue2 和 Element UI，后端基于 .NET 9 构建。</span></li>\n<li><strong>代码自动生成：</strong><span>&nbsp;支持一键生成视图层、控制层、服务层、仓储层、领域层和 DTO 业务模型层代码，极大地缩短了开发周期。</span></li>\n<li><strong>多数据库支持：</strong><span>&nbsp;支持多种关系型数据库（如 MySQL、SqlServer、SQLite、Oracle、PostgreSQL、OpenGauss、<span>Kingbase、DM）和非关系型数据库（如 Redis、MongoDB、Elasticsearch、Meilisearch），同时支持动态数据源，以满足不同企业的需求。</span></span></li>\n<li><strong>项目安全性高：</strong><span>&nbsp;支持4A等级认证，满足等保三级要求，支持防 SQL 注入、防 Token 劫持、防接口渗透与抖动，集成RSA、AES及国产 SM 加密算法，支持全链路HTTPS加密传输协议，确保企业级应用的安全性。</span></li>\n<li><span>支持微服务，支持服务的注册、发现、健康检查、熔断和降级。</span></li>\n</ul>\n<h2><span>项目技术栈</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><span>前端：Vue2、Element UI、Node.js等。</span></li>\n<li><span>后端：C#、.NET 9、AspNetCoreRateLimit、<span>SqlSugar、AutoMapper、SignalR、MiniProfiler、CAP、RabbitMQ、Redis、Consul等。</span></span></li>\n</ul>\n<h2><span>安装教程</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109225902010-549085141.png\" /></p>\n<h2><span>软件架构图</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109225914600-2077383226.png\" /></p>\n<h2><span>项目源代码</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230143000-1636008500.png\" /></p>\n<h2><span>项目效果截图</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230153456-1478242349.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230157723-87615533.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230203615-1395111698.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230210957-1745363029.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230216437-1329007995.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230222905-1152283619.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230230693-1691017440.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205853857-1849985119.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205859134-1945950810.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230248378-53584818.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230253718-384227715.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205908099-602806087.png\" /></p>\n<h2><span>项目源码地址</span></h2>\n<p><span>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/pang-mingjun/RuYiAdmin\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/pang-mingjun/RuYiAdmin</span></a></li>\n</ul>\n<h2><span>优秀项目和框架精选</span></h2>\n<p><span>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong><span>）。</span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>GitHub开源地址：</strong><a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n</ul>\n<div id=\"gtx-trans\">&nbsp;</div>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 23:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">238</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ftrace可视化工具迎来重大升级",
      "link": "https://www.cnblogs.com/pengdonglin137/p/19463398",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/pengdonglin137/p/19463398\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 21:15\">\n    <span>ftrace可视化工具迎来重大升级</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><img alt=\"sample\" src=\"https://img2024.cnblogs.com/blog/480488/202601/480488-20260109211236842-806107884.png\" width=\"500\" /></p>\n<p>今天对<a href=\"https://mp.weixin.qq.com/s/rNiWXC8YlZiAjfcjv7QtQA\" rel=\"noopener nofollow\" target=\"_blank\" title=\"ftrace可视化工具\">ftrace可视化工具</a>进行了重大改造，提升了代码定位的准确性，此外处理性能也得到指数级的提高。</p>\n<p>首先是<strong>提高了代码定位的准确性</strong>。做这个工具的初衷就是<strong>希望让全球广大Linux内核爱好者在看trace时可以很容易定位当前函数具体是在代码的哪一行调用的</strong>，这对于梳理代码执行流程至关重要。而funcgraph-retaddr输出的是函数的返回地址，直接对这个地址调用addr2line显然不满足我们的要求。根据函数调用的原理，在执行函数调用指令时，CPU会自动保存下一条指令的地址，因此解决方案也非常简单粗暴，直接对返回地址减去一定数值得到前一条指令的起始地址，可是具体减多少呢？对于ARM64架构，每条指令固定占4字节，所以减4可以。但是对于像x86架构这种变长指令集，就不好确定了。我的<a href=\"https://mp.weixin.qq.com/s/Z5aIf9UhMtVK1N6vmPTRYQ\" rel=\"noopener nofollow\" target=\"_blank\" title=\"AI知识库\">AI知识库</a>说addr2line不需要精确的指令起始地址，只需落在某行代码对应的指令范围内即可正确映射，这个工具的设计初衷就是处理近似地址(如Oops中的函数+偏移)，为的是方便调试。所以统一减1就可以保证得到的地址落在前一条指令的范围内(DWARF规范也是这么推荐的)，再调用addr2line就可以得到当前函数被调用的准确位置。</p>\n<p>然后就是<strong>大幅提高了解析trace文件的性能</strong>。目前根据地址解析得到代码行调用的是内核的faddr2line工具，它是用bash脚本语言编写的，执行的时候调用了很多三方的工具，比如readelf、grep以及awk等，同时它内部使用了多个循环遍历的算法(O(N))，对于处理像vmlinux这种包含几十万个函数符号的ELF文件来说就非常不合适。所以用python语言对这个工具进行了重写，不再调用三方的工具（仅保留addr2line），同时引入了多个二分搜索算法(O(LogN))，使文件的处理性能得到指数级的提高。以处理一个40行的trace文件为例，如果使用传统的faddr2line的话，需要大约54秒，而重写后仅需6秒。处理1000行trace日志，耗时也只有7秒，大部分时间（5秒多）都消耗在启动时解析vmlinux，构建内部数据结构上了。</p>\n<p>虽然全程都是让AI编码，但需要自己<a href=\"https://yb.tencent.com/s/y2zNMNFaxhu3\" rel=\"noopener nofollow\" target=\"_blank\" title=\"对整个流程有一个清晰的理解\">对整个流程有一个清晰的理解</a>，然后给AI提出需求，AI写完后还需要人工走读，发现待优化的点，让AI继续优化，前后折腾了有将近30版。</p>\n<p>目前我在gitee上给这个工具建立了一个仓库，方便后续继续完善，项目地址是：<a href=\"https://gitee.com/pengdonglin137/funcgraph_visualization\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/pengdonglin137/funcgraph_visualization</a></p>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/pengdonglin137/\" target=\"_blank\">dolinux</a>，未经同意，禁止转载</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 21:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/pengdonglin137\">dolinux</a>&nbsp;\n阅读(<span id=\"post_view_count\">70</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Flink源码阅读：Task数据交互",
      "link": "https://www.cnblogs.com/Jackeyzhe/p/19463278",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Jackeyzhe/p/19463278\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 20:11\">\n    <span>Flink源码阅读：Task数据交互</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Flink源码阅读：Task数据交互\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1828322/202601/1828322-20260109201055245-933532869.png\" />\n        经过前面的学习，Flink 的几个核心概念相关的源码实现我们已经了解了。本文我们来梳理 Task 的数据交互相关的源码。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>经过前面的学习，Flink 的几个核心概念相关的源码实现我们已经了解了。本文我们来梳理 Task 的数据交互相关的源码。</p>\n<h3 id=\"数据输出\">数据输出</h3>\n<p>话不多说，我们直接进入正题。首先来看 Task 的数据输出，在进入流程之前，我们先介绍几个基本概念。</p>\n<h4 id=\"基本概念\">基本概念</h4>\n<ul>\n<li>\n<p>RecordWriterOutput：它是 Output 接口的一个具体实现类，底层使用 RecordWriter 来发送数据。</p>\n</li>\n<li>\n<p>RecordWriter：数据写入的执行者，负责将数据写到 ResultPartition。</p>\n</li>\n<li>\n<p>ResultPartition 和 ResultSubpartition：ResultPartition 是 ExecutionGraph 中一个节点的输出结果，下游的每个需要从当前 ResultPartition 消费数据的 Task 都会有一个 ResultSubpartition。</p>\n</li>\n<li>\n<p>ChannelSelector：用来决定一个 Record 要被写到哪个 Subpartition 中。</p>\n</li>\n<li>\n<p>LocalBufferPool：用来管理 Buffer 的缓冲池。在介绍反压的原理时，我们提到过。</p>\n</li>\n</ul>\n<p>对这些基本概念有了一定的了解之后，我们来看数据输出的具体流程。</p>\n<h4 id=\"执行流程\">执行流程</h4>\n<p>我们以 map 为例，看一下数据的输出过程。</p>\n<p><img alt=\"DataOutput\" class=\"lazyload\" /></p>\n<p>在 <code>StreamMap.processElement</code> 方法中，调用完 map 方法之后，就会调用 <code>output.collect</code> 方法将数据输出，这里的 output 就是 RecordWriterOutput。在 RecordWriterOutput 中，会调用 RecordWriter 的 emit 方法。</p>\n<pre><code class=\"language-java\">private &lt;X&gt; void pushToRecordWriter(StreamRecord&lt;X&gt; record) {\n    serializationDelegate.setInstance(record);\n\n    try {\n        recordWriter.emit(serializationDelegate);\n    } catch (IOException e) {\n        throw new UncheckedIOException(e.getMessage(), e);\n    }\n}\n</code></pre>\n<p>这里的 serializationDelegate 是用来对 record 进行序列化的。RecordWriter 有两个实现类，一个是 ChannelSelectorRecordWriter，另一个是 BroadcastRecordWriter。ChannelSelectorRecordWriter 需要先调用 ChannelSelector 选择对应的 subparition，然后进行写入。BroadcastRecordWriter 则是写到所有的 subparition。</p>\n<p>接下来就是调用 <code>BufferWritingResultPartition.emitRecord</code> 来写入数据。</p>\n<pre><code class=\"language-java\">public void emitRecord(ByteBuffer record, int targetSubpartition) throws IOException {\n    totalWrittenBytes += record.remaining();\n\n    BufferBuilder buffer = appendUnicastDataForNewRecord(record, targetSubpartition);\n\n    while (record.hasRemaining()) {\n        // full buffer, partial record\n        finishUnicastBufferBuilder(targetSubpartition);\n        buffer = appendUnicastDataForRecordContinuation(record, targetSubpartition);\n    }\n\n    if (buffer.isFull()) {\n        // full buffer, full record\n        finishUnicastBufferBuilder(targetSubpartition);\n    }\n\n    // partial buffer, full record\n}\n</code></pre>\n<p>这里把 record 写入到 buffer 中，如果 buffer 不够，则会从 LocalBufferPool 中申请新的 buffer，申请到之后就会继续写入。下面是具体的申请过程。</p>\n<pre><code class=\"language-java\">private MemorySegment requestMemorySegment(int targetChannel) {\n    MemorySegment segment = null;\n    synchronized (availableMemorySegments) {\n        checkDestroyed();\n\n        if (!availableMemorySegments.isEmpty()) {\n            segment = availableMemorySegments.poll();\n        } else if (isRequestedSizeReached()) {\n            // Only when the buffer request reaches the upper limit(i.e. current pool size),\n            // requests an overdraft buffer.\n            segment = requestOverdraftMemorySegmentFromGlobal();\n        }\n\n        if (segment == null) {\n            return null;\n        }\n\n        if (targetChannel != UNKNOWN_CHANNEL) {\n            if (++subpartitionBuffersCount[targetChannel] == maxBuffersPerChannel) {\n                unavailableSubpartitionsCount++;\n            }\n        }\n\n        checkAndUpdateAvailability();\n    }\n    return segment;\n}\n</code></pre>\n<p>如果有可用内存，就直接从队列中出队。如果达到了本地 BufferPool 的上限，就从全局的 NetworkBufferPool 中申请，申请不到就会阻塞写入过程，等待申请。最后还会检查并更新可用内存状态。</p>\n<p>有了可用的 buffer 之后，就会调用 addToSubpartition，最终数据存储在 PipelinedSubpartition 的 buffers 队列中。</p>\n<pre><code class=\"language-java\">private void addToSubpartition(\n        BufferBuilder buffer,\n        int targetSubpartition,\n        int partialRecordLength,\n        int minDesirableBufferSize)\n        throws IOException {\n    int desirableBufferSize =\n            subpartitions[targetSubpartition].add(\n                    buffer.createBufferConsumerFromBeginning(), partialRecordLength);\n\n    resizeBuffer(buffer, desirableBufferSize, minDesirableBufferSize);\n}\n</code></pre>\n<h3 id=\"数据输入\">数据输入</h3>\n<p>看完了数据输出的过程之后，我们再来看一下数据输入的过程。首先还是了解几个基本概念。</p>\n<h4 id=\"基本概念-1\">基本概念</h4>\n<ul>\n<li>\n<p>InputGate：InputGate 是对输入的封装，与 JobGraph 中的 JobEdge 一一对应，每个 InputGate 消费上游一个或多个 Resultpartition。</p>\n</li>\n<li>\n<p>InputChannel：InputChannel 是和 ExecutionGraph 中的 ExecutionEdge 一一对应的。每个 InputChannel 接收一个 ResultSubpartition 的输出，InputChannel 主要关注 LocalInputChannel 和 RemoteInputChannel 两种实现。</p>\n</li>\n</ul>\n<h4 id=\"执行流程-1\">执行流程</h4>\n<p>了解了具体概念之后，我们再看数据输入的具体流程。</p>\n<p><img alt=\"RecordInput\" class=\"lazyload\" /></p>\n<p>数据输入的入口是 <code>StreamTask.processInput</code> 方法，这个方法中主要是调用 <code>inputProcessor.processInput</code> 方法，我们以 StreamOneInputProcessor 为例。这个方法就是调用 <code>input.emitNext</code> 方法。</p>\n<pre><code class=\"language-java\">public DataInputStatus emitNext(DataOutput&lt;T&gt; output) throws Exception {\n\n    while (true) {\n        // get the stream element from the deserializer\n        if (currentRecordDeserializer != null) {\n            RecordDeserializer.DeserializationResult result;\n            try {\n                result = currentRecordDeserializer.getNextRecord(deserializationDelegate);\n            } catch (IOException e) {\n                throw new IOException(\n                        String.format(\"Can't get next record for channel %s\", lastChannel), e);\n            }\n            if (result.isBufferConsumed()) {\n                currentRecordDeserializer = null;\n            }\n\n            if (result.isFullRecord()) {\n                final boolean breakBatchEmitting =\n                        processElement(deserializationDelegate.getInstance(), output);\n                if (canEmitBatchOfRecords.check() &amp;&amp; !breakBatchEmitting) {\n                    continue;\n                }\n                return DataInputStatus.MORE_AVAILABLE;\n            }\n        }\n\n        Optional&lt;BufferOrEvent&gt; bufferOrEvent = checkpointedInputGate.pollNext();\n        if (bufferOrEvent.isPresent()) {\n            // return to the mailbox after receiving a checkpoint barrier to avoid processing of\n            // data after the barrier before checkpoint is performed for unaligned checkpoint\n            // mode\n            if (bufferOrEvent.get().isBuffer()) {\n                processBuffer(bufferOrEvent.get());\n            } else {\n                DataInputStatus status = processEvent(bufferOrEvent.get(), output);\n                if (status == DataInputStatus.MORE_AVAILABLE &amp;&amp; canEmitBatchOfRecords.check()) {\n                    continue;\n                }\n                return status;\n            }\n        } else {\n            if (checkpointedInputGate.isFinished()) {\n                checkState(\n                        checkpointedInputGate.getAvailableFuture().isDone(),\n                        \"Finished BarrierHandler should be available\");\n                return DataInputStatus.END_OF_INPUT;\n            }\n            return DataInputStatus.NOTHING_AVAILABLE;\n        }\n    }\n}\n</code></pre>\n<p>这里是调用 <code>checkpointedInputGate.pollNext</code> 来获取输入的数据。它的内部就是调用 InputGate 的 pollNext 方法来获取数据。当获取到完整数据之后，就会调用 processElement 来处理数据。</p>\n<p>我们以 SingleInputGate 为例看 InputGate 的 pollNext 方法。它的内部调用链路可用一直追踪到 readBufferFromInputChannel 方法，这个方法内会调用 <code>inputChannel.getNextBuffer</code>，这里交给 InputChannel 来具体执行数据读取。</p>\n<pre><code class=\"language-java\">public Optional&lt;BufferAndAvailability&gt; getNextBuffer() throws IOException {\n    checkError();\n\n    if (!toBeConsumedBuffers.isEmpty()) {\n        return getBufferAndAvailability(toBeConsumedBuffers.removeFirst());\n    }\n\n    ResultSubpartitionView subpartitionView = this.subpartitionView;\n    if (subpartitionView == null) {\n        // There is a possible race condition between writing a EndOfPartitionEvent (1) and\n        // flushing (3) the Local\n        // channel on the sender side, and reading EndOfPartitionEvent (2) and processing flush\n        // notification (4). When\n        // they happen in that order (1 - 2 - 3 - 4), flush notification can re-enqueue\n        // LocalInputChannel after (or\n        // during) it was released during reading the EndOfPartitionEvent (2).\n        if (isReleased) {\n            return Optional.empty();\n        }\n\n        // this can happen if the request for the partition was triggered asynchronously\n        // by the time trigger\n        // would be good to avoid that, by guaranteeing that the requestPartition() and\n        // getNextBuffer() always come from the same thread\n        // we could do that by letting the timer insert a special \"requesting channel\" into the\n        // input gate's queue\n        subpartitionView = checkAndWaitForSubpartitionView();\n    }\n\n    BufferAndBacklog next = subpartitionView.getNextBuffer();\n    // ignore the empty buffer directly\n    while (next != null &amp;&amp; next.buffer().readableBytes() == 0) {\n        next.buffer().recycleBuffer();\n        next = subpartitionView.getNextBuffer();\n        numBuffersIn.inc();\n    }\n\n    if (next == null) {\n        if (subpartitionView.isReleased()) {\n            throw new CancelTaskException(\n                    \"Consumed partition \" + subpartitionView + \" has been released.\");\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    Buffer buffer = next.buffer();\n\n    if (buffer instanceof FullyFilledBuffer) {\n        List&lt;Buffer&gt; partialBuffers = ((FullyFilledBuffer) buffer).getPartialBuffers();\n        int seq = next.getSequenceNumber();\n        for (Buffer partialBuffer : partialBuffers) {\n            toBeConsumedBuffers.add(\n                    new BufferAndBacklog(\n                            partialBuffer,\n                            next.buffersInBacklog(),\n                            buffer.getDataType(),\n                            seq++));\n        }\n\n        return getBufferAndAvailability(toBeConsumedBuffers.removeFirst());\n    }\n\n    return getBufferAndAvailability(next);\n}\n</code></pre>\n<p>我们先来看 LocalInputChannel，先获取到了 subpartitionView，并调用 getNextBuffer，这里其实就是从 PipelinedSubpartition 的 buffers 队列中读取数据。</p>\n<p>RemoteInputChannel 则需要从 receivedBuffers 中读取数据，这个队列的数据就是消费上游数据后保存的。</p>\n<p>至此，Flink 中 Task 的数据输入和输出过程的源码就梳理完了，更加底层的 Netty 相关代码我们在后面继续梳理。</p>\n<h3 id=\"总结\">总结</h3>\n<p>最后简单总结一下，本文我们梳理了 Task 的数据输出和输入的过程。输出过程主要是利用 RecordWriter 将数据写入到 Buffer 中，输入过程则是利用 InputChannel 从 Buffer 消费的过程。如果你的 Flink 任务数据量特别大，并且没什么复杂的逻辑，可以考虑适当调整 localBufferPool 的大小来调优任务的吞吐。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 20:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Jackeyzhe\">Jackeyzhe</a>&nbsp;\n阅读(<span id=\"post_view_count\">47</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "公众号推荐机制整理：科技号怎么把社交流量做起来",
      "link": "https://www.cnblogs.com/reachteam/p/19463233",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/reachteam/p/19463233\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 19:39\">\n    <span>公众号推荐机制整理：科技号怎么把社交流量做起来</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>01 背景</h1>\n<p><span>最近我们软件团队参加了一个高校关于公众号运营的分享，听完挺有启发，所以把重点整理成一篇笔记，发出来给大家参考。</span></p>\n<p><span>从 2023 年开始，公众号的分发不再只是订阅推送那一套了，现在更像是社交信号 + 算法推荐一起在发力。有数据提到，2025 年某科技/软件小号通过社交推荐拿到的流量占比已经到 45.9%，甚至超过了传统订阅推送。</span></p>\n<p><span>所以这篇文章想解决的就一件事：</span></p>\n<p><span>科技号到底要怎么写，才能更容易被推荐，也更容易被转发。</span></p>\n<p><span>下面按 6 个方向讲清楚：技术逻辑、关键指标、分发流程、账号差异、演进变化、案例和可操作建议。</span></p>\n<h2><span>02 推荐系统大概怎么跑</span></h2>\n<h3><span>2.1 三类信号最重要</span></h3>\n<p><span>2025 年之后，公众号的推荐更强调三类信号一起看：</span></p>\n<p><span>1. 社交关系：朋友看过、转发、在看等</span></p>\n<p><span>2. 兴趣标签：你是什么人群，内容是什么主题</span></p>\n<p><span>3. 行为数据：点击、停留、完读、滑动速度、点赞发生在什么时候</span></p>\n<p><span>系统会先从内容里提取关键词，再结合用户行为更新画像，最后决定给谁更多曝光。可以把它理解成一个循环：先曝光一小波，看反馈，再决定要不要继续给量。</span></p>\n<p><span>另外有一点很关键，文章发出去之后通常 1 到 3 分钟内就会做一轮质量评估，主题价值、逻辑结构、原创性、以及 AI 生成痕迹这些都会被综合判断。</span></p>\n<h3><span>2.2 指标权重长什么样</span></h3>\n<p><span>先把大盘放在这。数字是研究整理口径，大家看趋势和重点就行。</span></p>\n<p><span>表 1：公众号算法核心权重分配</span></p>\n<table>\n<thead>\n<tr><th><span>权重维度</span></th><th><span>具体指标</span></th><th><span>权重占比</span></th><th><span>关键阈值（示例）</span></th></tr>\n</thead>\n<tbody>\n<tr>\n<td><span>社交传播系数</span></td>\n<td><span>好友推荐率、转发到朋友圈/社群次数、跨圈层传播深度</span></td>\n<td><span>35%</span></td>\n<td><span>社交推荐流量占比 ≥ 45%</span></td>\n</tr>\n<tr>\n<td><span>内容质量因子</span></td>\n<td><span>完读率（≥65%）、平均阅读时长（≥2 分钟）、原创度（3 倍权重）</span></td>\n<td><span>30%</span></td>\n<td><span>完读率 ≥ 50%</span></td>\n</tr>\n<tr>\n<td><span>用户行为画像</span></td>\n<td><span>点击率、滑动速度、点赞时间点等微观行为</span></td>\n<td><span>20%</span></td>\n<td><span>点击率 ≥ 15%</span></td>\n</tr>\n<tr>\n<td><span>账号信誉体系</span></td>\n<td><span>更新频率、违规记录、用户投诉率</span></td>\n<td><span>10%</span></td>\n<td><span>日更可提升 300% 初始推荐</span></td>\n</tr>\n<tr>\n<td><span>实时流量博弈</span></td>\n<td><span>15 分钟动态调整</span></td>\n<td><span>5%</span></td>\n<td><span>冷启动期点击率 &gt; 8%</span></td>\n</tr>\n</tbody>\n</table>\n<p><span>另外还有一组常见拆分口径：打开率大概占 40%，互动率（赞/在看/收藏）占 30%，分享率占 20%，完读率占 10%。</span></p>\n<p><span>提醒两点：</span></p>\n<p><span>1. 原创的推荐权重会更高（研究口径里提到是转载的 3 倍）</span></p>\n<p><span>2. 认证类型也会影响权重（政府 &gt; 媒体 &gt; 企业 &gt; 个体），认证账号在搜索里更容易拿到靠前曝光</span></p>\n<h3><span>2.3 这几年分发怎么变了</span></h3>\n<p><span>简单按阶段捋一下：</span></p>\n<p><span>1. 2013 到 2017：订阅为主，关注就能收到</span></p>\n<p><span>2. 2017 到 2020：开始引入社交推荐，看一看等入口出现</span></p>\n<p><span>3. 2020 到 2023：算法推荐逐步变强，开始推荐未关注内容</span></p>\n<p><span>4. 2023 至今：社交 + 算法双驱动更明显，朋友相关入口的权重变高</span></p>\n<h2><span>03 流量池赛马：文章为啥会突然爆</span></h2>\n<h3><span>3.1 冷启动那一关很关键</span></h3>\n<p><span>文章发出去之后，通常会先拿到一小波测试曝光（比如 500 到 1000 次），系统主要看三项：点击率、完读率、互动率。</span></p>\n<p><span>研究里给了一些常见阈值做参考：</span></p>\n<p><span>1. 冷启动期（0 到 24 小时）点击率要能到 8% 以上，更可能进下一层</span></p>\n<p><span>2. 进入爆发期后，完读率最好能维持 55% 以上，互动率 3% 以上</span></p>\n<h3><span>3.2 多轮推荐不是一次性给完</span></h3>\n<p><span>通过第一轮测试后，会有二次、三次甚至更多轮的推荐，每一轮曝光量会变大。</span></p>\n<p><span>另外系统会按 15 分钟一轮动态调整流量，所以同一篇文章的数据会一直变化。阅读量到 1 万这个量级后，有时还会触发人工审核。</span></p>\n<h3><span>3.3 社交扩散会带来放大</span></h3>\n<p><span>当用户点在看或者转发，文章就会沿着社交网络扩散。有账号的数据里，朋友相关入口贡献的阅读量能到 45.9%。</span></p>\n<p><span>比较容易触发分享的原因一般是这三类：</span></p>\n<p><span>1. 内容本身有社交价值（共鸣、实用、话题性）</span></p>\n<p><span>2. 文中写清楚分享动机（比如转给同事、转给同学、转给群里谁）</span></p>\n<p><span>3. 内容适配分享场景（工作群、同学群、行业群能用得上）</span></p>\n<h3><span>3.4 公域入口也很重要</span></h3>\n<p><span>表 2：公众号主要流量来源分布</span></p>\n<table>\n<thead>\n<tr><th><span>流量来源</span></th><th><span>占比</span></th><th><span>特点</span></th></tr>\n</thead>\n<tbody>\n<tr>\n<td><span>推荐流量</span></td>\n<td><span>54.5%</span></td>\n<td><span>算法推荐为主</span></td>\n</tr>\n<tr>\n<td><span>公众号消息</span></td>\n<td><span>16.52%</span></td>\n<td><span>订阅用户</span></td>\n</tr>\n<tr>\n<td><span>公众号主页</span></td>\n<td><span>13.17%</span></td>\n<td><span>主动访问</span></td>\n</tr>\n<tr>\n<td><span>搜一搜</span></td>\n<td><span>10.44%</span></td>\n<td><span>精准搜索</span></td>\n</tr>\n<tr>\n<td><span>聊天会话</span></td>\n<td><span>2.88%</span></td>\n<td><span>私域分享</span></td>\n</tr>\n<tr>\n<td><span>朋友圈</span></td>\n<td><span>0.96%</span></td>\n<td><span>朋友圈分享</span></td>\n</tr>\n<tr>\n<td><span>朋友推荐</span></td>\n<td><span>0.12%</span></td>\n<td><span>好友直接推荐</span></td>\n</tr>\n</tbody>\n</table>\n<p><span>补充两点：</span></p>\n<p><span>1. 看一看是很重要的公域入口，爆款里看一看占比能到 60% 到 70%</span></p>\n<p><span>2. 搜一搜占比大概 10.44%，标题关键词做得好，搜索流量占比也可能很可观</span></p>\n<h2><span>04 不同账号的差异</span></h2>\n<h3><span>4.1 认证和账号信誉</span></h3>\n<p><span>认证类型会影响权重和信任（政府 &gt; 媒体 &gt; 企业 &gt; 个体）。</span></p>\n<p><span>同时也会看这些：注册时间、违规记录、粉丝活跃度（常读用户）、更新频率（发文多且原创占比高更占优）。</span></p>\n<h3><span>4.2 新号和老号不一样</span></h3>\n<p><span>新号一般会有观察期，初期曝光可能比较小，平台会先判断你是不是稳定的正常创作者，标签清不清晰，内容合不合规。</span></p>\n<p><span>老号因为画像积累更完整，推荐更容易精准，但长期不活跃或者质量下滑也可能被降权。</span></p>\n<h3><span>4.3 垂直领域更吃香，但别乱跑</span></h3>\n<p><span>科技、教育等垂直领域在品类里可能更容易拿到倾斜，但前提是定位足够细，内容持续垂直输出，并且用合集、标签等方式强化识别。</span></p>\n<h2><span>05 科技号怎么做更容易起量</span></h2>\n<p><span>我更建议把指标当成门槛，而不是当 KPI。</span></p>\n<h3><span>5.1 标题先把点击率顶起来</span></h3>\n<p><span>标题可以用一个比较稳的结构：痛点场景 + 数据背书 + 情绪共鸣。</span></p>\n<p><span>示例（按你们账号方向替换即可）：</span></p>\n<p><span>1. 我把电脑变快了，3 个 Windows 设置立刻见效</span></p>\n<p><span>2. 别再被钓鱼了，校园/企业邮箱最常见的 5 种诈骗</span></p>\n<p><span>3. 从 0 到 1，用 10 分钟搭好一个自动化报表流程</span></p>\n<h3><span>5.2 内容结构要照顾完读</span></h3>\n<p><span>一个比较好用的写法是：开头直接给结论，中间保持信息密度（大概每 300 字一个关键点），结尾给行动建议或提问，引导评论/收藏/转发。</span></p>\n<h3><span>5.3 原创是底盘</span></h3>\n<p><span>研究里提到原创度建议大于 70%。如果用 AI 做辅助，也建议把比例和用途说清楚，避免被系统误判成低质。</span></p>\n<h3><span>5.4 把可转发写进正文</span></h3>\n<p><span>文章 25% / 50% / 75% 的位置，可以顺手加一句话，告诉读者这段适合转给谁。</span></p>\n<p><span>比如：这份排查清单转给 IT 同事/同学；这段设置转到群里，大家少踩坑。</span></p>\n<h3><span>5.5 发出去后的 2 小时别浪费</span></h3>\n<p><span>冷启动数据很关键，建议发文后马上用种子用户扩散一波（社群、同事群、同学群），先把点击、完读、互动跑起来。</span></p>\n<h3><span>5.6 每周就盯 3 个指标</span></h3>\n<p><span>1. 社交推荐流量占比（目标值可参考 45%）</span></p>\n<p><span>2. 菜单栏点击量（能看出互动深度）</span></p>\n<p><span>3. 48 小时互动率（能看出内容即时影响力）</span></p>\n<p><span>另外标题、封面、开头段落都可以做小范围 A/B 测试，找最合适的组合。</span></p>\n<h2><span>06 案例给我们的提示</span></h2>\n<p><span>这里列几个研究里的典型现象，主要看规律：</span></p>\n<p><span>1. 有文章阅读 48 万，看一看贡献 60%</span></p>\n<p><span>2. 有新号粉丝不多，单篇 10 万+，看一看贡献 98%</span></p>\n<p><span>3. 有病毒传播案例，第 1 天 500+，第 2 天 1 万+，第 3 天朋友圈刷屏</span></p>\n<p><span>共同点其实很朴素：冷启动过关，社交扩散被点燃，内容质量能撑住完读和互动。</span></p>\n<h2><span>07 风险和合规别踩坑</span></h2>\n<p><span>常见误区：</span></p>\n<p><span>1. 追热点但和定位不搭，容易白忙</span></p>\n<p><span>2. 依赖刷量，平台有无效流量排查，风险很高</span></p>\n<p><span>3. 只要曝光不要质量，完读率掉得很快，推荐也会很快停</span></p>\n<p><span>合规方面：</span></p>\n<p><span>1. 原创度尽量做到 70% 以上</span></p>\n<p><span>2. 标题和正文做敏感词扫描，少用绝对化、夸大化表述</span></p>\n<p><span>3. 图片素材注意版权，用 CC0 站点或者合规二创</span></p>\n<h2><span>08 总结</span></h2>\n<p><span>一句话总结：公众号现在是社交信号 + 算法推荐一起在跑，科技号想起量，核心还是三件事：冷启动数据过关、内容更容易被转发、长期坚持原创和垂直。</span></p>\n<p><span>如果你只想先做最小改动，建议从这 3 个开始：</span></p>\n<p><span>1. 发文后 0 到 2 小时，把点击率、完读率、互动率先跑起来</span></p>\n<p><span>2. 把清单、步骤、排错流程写得更可截图转发，顺手写清楚转给谁</span></p>\n<p><span>3. 连续做一个细分方向（比如校园网络安全、系统使用指南、办公效率），让标签稳定下来</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 19:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/reachteam\">H5开发技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">66</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MAF快速入门（11）并行工作流",
      "link": "https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper11",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper11\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 18:30\">\n    <span>MAF快速入门（11）并行工作流</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"MAF快速入门（11）并行工作流\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260104201029946-1112217715.png\" />\n        在实际业务场景中，往往需要在工作流中让多个Agent同时运行再通过聚合结果做做一些数据分析或决策呈现，这时就需要并行执行机制。本文介绍了MAF中并行工作流以及如何实现“Fan-Out/Fan-In”的工作模式，最后通过一个跨境电商价格查询智能定价的案例介绍了这种模式的代码实现。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>大家好，我是Edison。</p>\n<p>最近我一直在跟着圣杰的《<a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\">.NET+AI智能体开发进阶</a>》课程学习MAF的开发技巧，我强烈推荐你也上车跟我一起出发！</p>\n<p><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper10\" target=\"_blank\">上一篇</a>，<span>我们学习了MAF中如何进行循环（loop）路由<span>。本篇，我们来了解下在MAF中如何并行执行（fan-out/fan-in）的工作流。</span></span></p>\n<h1><strong>1 并行执行模式</strong></h1>\n<p><span><span><span>在实际业务场景中，往往需要在工作流中让多个Agent同时运行再通过聚合结果做做一些数据分析或决策呈现，这时就需要并行执行机制<span>。</span></span></span></span></p>\n<p><span><span><span>在MAF中，我们可以使用 Fan-Out/Fan-In 模式来实现这个目的<span>，如下代码片段所示：</span></span></span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowBuilder(startExecutor)\n    .AddFanOutEdge(startExecutor, [amazonExecutor, ebayExecutor, shopeeExecutor])\n    .AddFanInEdge([amazonExecutor, ebayExecutor, shopeeExecutor], strategyExecutor)\n    .WithOutputFrom(strategyExecutor)\n    .Build();</span></pre>\n</div>\n<p><span><span><span><span><span><span><span>可以看到，我们通过MAF的 AddFanOutEdge 和 AddFanInEdge 来实现了并行执行的目的，最后通过一个自定义的执行器来做聚合。</span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span>核心概念补充：</span></span></span></span></span></span></span></p>\n<ul>\n<li><span><span><span><span><span><span><span>Fan-Out Edge =&gt; 并发执行边</span></span></span></span></span></span></span></li>\n<li><span><span><span><span><span><span><span>Fan-In Edge =&gt; 汇聚边</span></span></span></span></span></span></span></li>\n</ul>\n<h1><strong>2 并行工作流实验案例</strong></h1>\n<p><span><span><span><span><span><span><span><span>假设我们是一个跨境电商团队，想要实时监控同一个商品在多个电商平台（如亚马逊、eBay、Shopee等）的定价策略，在检测到竞争对手降价时快速做出响应决策。</span></span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span><span><span>因此，我们的目标是：配置一个&nbsp;<span>Fan-Out + Fan-In<span>&nbsp;工作流，实现一次查询、并行抓取、智能决策的企业级模式。</span></span></span></span></span></span></span></span></span></span></span></p>\n<h3><strong><span><span>2.1 关键依赖包引入</span></span></strong></h3>\n<p><span><span><span><span><span><span><span><span><span><span><span><span>在今天的这个案例中，我们仍然创建了一个.NET控制台应用程序，安装了以下NuGet包：</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><span>Microsoft.Agents.AI.OpenAI</span></li>\n<li><span>Microsoft.Agents.AI.Workflows</span></li>\n<li><span>Microsoft.Extensions.AI.OpenAI</span></li>\n</ul>\n<h3><span><span>2.2 定义数据传输模型</span></span></h3>\n<p><span><span>首先，我们定义一下在这个工作流中需要生成传递的数据模型：</span></span></p>\n<p><span><span>PriceQueryDto ：价格查询模型DTO</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> PriceQueryDto\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> ProductId { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> ProductName { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> TargetRegion { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> PriceQueryDto(<span style=\"color: rgba(0, 0, 255, 1);\">string</span> productId, <span style=\"color: rgba(0, 0, 255, 1);\">string</span> productName, <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> targetRegion)\n    {\n        ProductId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> productId;\n        ProductName </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> productName;\n        TargetRegion </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> targetRegion;\n    }\n}</span></pre>\n</div>\n<h3><span><span>2.3 定义Agents&amp;Executors</span></span></h3>\n<p><span><strong>（1）价格查询：</strong>封装各大电商平台的价格查询逻辑，模拟其API响应，仅仅做演示用无实际逻辑</span>：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> PlatformPriceExecutor : Executor&lt;ChatMessage&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> _instructions;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> IChatClient _chatClient;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> PlatformPriceExecutor(<span style=\"color: rgba(0, 0, 255, 1);\">string</span> id, IChatClient chatClient, <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> platformInstructions)\n        : </span><span style=\"color: rgba(0, 0, 255, 1);\">base</span><span style=\"color: rgba(0, 0, 0, 1);\">(id)\n    {\n        _chatClient </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> chatClient;\n        _instructions </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> platformInstructions;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask HandleAsync(ChatMessage message, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> messages = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;ChatMessage&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">(ChatRole.System, _instructions),\n            message\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> response = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> _chatClient.GetResponseAsync(messages, cancellationToken: cancellationToken);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> replyMessage = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> ChatMessage(ChatRole.Assistant, response.Text ?? <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty)\n        {\n            AuthorName </span>= <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">.Id\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> context.SendMessageAsync(replyMessage, cancellationToken: cancellationToken);\n        Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ {this.Id} 完成查询</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    }\n}</span></pre>\n</div>\n<p><strong><span><span>（2）<span>广播查询请求执行器<span>：</span></span></span></span></strong><span>负责广播价格查询请求到各大电商平台并发放TurnToken。</span></p>\n<p><span>NOTE：只有发放了TurnToken才能真正开启执行后续LLM节点！</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> PriceQueryStartExecutor() : Executor&lt;PriceQueryDto&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(nameof(PriceQueryStartExecutor))\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask HandleAsync(PriceQueryDto query, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> userPrompt = $<span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">商品ID: {query.ProductId}\n商品名称: {query.ProductName}\n目标区域: {query.TargetRegion}\n\n请查询该商品在你的平台上的当前价格、库存状态和配送信息。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.SendMessageAsync(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatMessage(ChatRole.User, userPrompt), cancellationToken: cancellationToken);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.SendMessageAsync(<span style=\"color: rgba(0, 0, 255, 1);\">new</span> TurnToken(emitEvents: <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">), cancellationToken: cancellationToken);\n\n        Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📡 Fan-out 价格查询广播已发送</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    }\n}</span></pre>\n</div>\n<p><strong><strong><span><span>（3）<span>定价聚合<span>：</span></span></span></span></strong></strong><span>模拟收集到所有平台的定价之后执行的数据聚合操作。</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> PricingStrategyExecutor : Executor&lt;ChatMessage&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> List&lt;ChatMessage&gt; _messages =<span style=\"color: rgba(0, 0, 0, 1);\"> [];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> _targetCount;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> PricingStrategyExecutor(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> targetCount) : <span style=\"color: rgba(0, 0, 255, 1);\">base</span><span style=\"color: rgba(0, 0, 0, 1);\">(nameof(PricingStrategyExecutor))\n    {\n        _targetCount </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> targetCount;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask HandleAsync(ChatMessage message, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">._messages.Add(message);\n        Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📊 已收集 {_messages.Count}/{_targetCount} 个平台数据 - 来自 {message.AuthorName}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (<span style=\"color: rgba(0, 0, 255, 1);\">this</span>._messages.Count == <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">._targetCount)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> platformData = <span style=\"color: rgba(0, 0, 255, 1);\">string</span>.Join(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(0, 0, 255, 1);\">this</span>._messages.Select(m =&gt; $<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">• {m.AuthorName}: {m.Text}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> strategyReport = $<span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📊 多平台价格汇总（共 {this._messages.Count} 个平台）\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n{platformData}\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n💡 智能定价建议\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n基于以上数据，建议分析竞争对手价格区间，制定差异化定价策略。\n考虑因素：库存压力、配送成本、平台佣金率、目标利润率。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> context.YieldOutputAsync(strategyReport, cancellationToken);\n\n            Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✨ Fan-in 定价策略生成完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        }\n    }\n}</span></pre>\n</div>\n<h3>2.4 构建工作流</h3>\n<p>现在万事俱备，只欠一个Workflow，现在Let's do it!</p>\n<p>Step1: 获取ChatClient</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> chatClient = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> OpenAIClient(\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ApiKeyCredential(openAIProvider.ApiKey),\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> OpenAIClientOptions { Endpoint = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Uri(openAIProvider.Endpoint) })\n    .GetChatClient(openAIProvider.ModelId)\n    .AsIChatClient();</span></pre>\n</div>\n<p>Step2: 实例化自定义Agent &amp; Executors</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> amazonExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> PlatformPriceExecutor(\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">AmazonPriceAgent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    chatClient,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">你是Amazon平台价格查询Agent。返回格式：价格=$XXX，库存状态=充足/紧张，配送说明=Prime会员免运费/标准配送。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> ebayExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> PlatformPriceExecutor(\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">eBayPriceAgent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    chatClient,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">你是eBay平台价格查询Agent。返回格式：价格=$XXX，商品状态=全新/二手XX新，运费说明=包邮/买家承担。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> shopeeExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> PlatformPriceExecutor(\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ShopeePriceAgent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    chatClient,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">你是Shopee平台价格查询Agent。返回格式：价格=$XXX（含税），区域=东南亚/台湾，促销信息=满减活动/无。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> startExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> PriceQueryStartExecutor();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> strategyExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> PricingStrategyExecutor(<span style=\"color: rgba(128, 0, 128, 1);\">3</span>);</pre>\n</div>\n<p>Step3: 创建并行执行工作流</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowBuilder(startExecutor)\n        .AddFanOutEdge(startExecutor, [amazonExecutor, ebayExecutor, shopeeExecutor])\n        .AddFanInEdge([amazonExecutor, ebayExecutor, shopeeExecutor], strategyExecutor)\n        .WithOutputFrom(strategyExecutor)\n        .Build();\nConsole.OutputEncoding </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Encoding.UTF8;\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ Loop Workflow 构建完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<h3><span><span>2.5 测试工作流</span></span></h3>\n<p><span><span>定义查询的商品是IPhone15：</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> priceQuery = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> PriceQueryDto(\n    productId: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">IPHONE15-PRO-256</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    productName: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">iPhone 15 Pro 256GB</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    targetRegion: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">US</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n);</span></pre>\n</div>\n<p><span><span>通过Streaming流式执行：</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">await</span> <span style=\"color: rgba(0, 0, 255, 1);\">using</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> run = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> InProcessExecution.StreamAsync(workflow, priceQuery))\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> evt <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> run.WatchStreamAsync())\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">switch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (evt)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> ExecutorInvokedEvent started:\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">🚀 {started.ExecutorId} 开始运行</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> ExecutorCompletedEvent completed:\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ {completed.ExecutorId} 结束运行</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowOutputEvent outputEvent:\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">🎉 Fan-in 汇总输出：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{outputEvent.Data}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowErrorEvent errorEvent:\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✨ 收到 Workflow Error Event：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{errorEvent.Data}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n    }\n}</span></pre>\n</div>\n<p>测试结果如下图所示：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260104200929287-1279437489.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可以看见，经过并行执行价格查询后，由聚合执行器进行了价格汇总并发送给LLM进行了最终的定价建议。</p>\n<h1><strong><span>3 小结</span></strong></h1>\n<p>本文介绍了MAF中并行工作流以及如何实现“Fan-Out/Fan-In<span><span><span>”的工作模式，最后通过一个跨境电商价格查询智能定价的案例介绍了这种模式的代码实现。</span></span></span></p>\n<p>下一篇，我们将继续学习MAF中工作流的多选路由工作流。</p>\n<h1>示例源码</h1>\n<p>GitHub:&nbsp;<a href=\"https://github.com/EdisonTalk/MAFD\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/EdisonTalk/MAFD</a></p>\n<h1>参考资料</h1>\n<p><span><span>圣杰，《<a href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\">.NET + AI 智能体开发进阶</a>》（推荐指数：★★★★★）</span></span></p>\n<p><span><span>Microsoft Learn，<span>《<a href=\"https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview?wt.mc_id=MVP_397012\" rel=\"noopener nofollow\" target=\"_blank\">Agent Framework Tutorials</a>》</span></span></span></p>\n<div><span><span>&nbsp;</span></span></div>\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://images.cnblogs.com/cnblogs_com/edisonchou/1647700/o_200902144330EdisonTalk-Footer.jpg\" /></p>\n<div id=\"Copyright\">\n<p>作者：<span style=\"text-decoration: underline;\">爱迪生</span></p>\n<p>出处：<a href=\"https://edisontalk.cnblogs.com\" target=\"_blank\" title=\"from\">https://edisontalk.cnblogs.com</a></p>\n<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。</p>\n</div>\n</div>\n<div id=\"MySignature\">\n    <div align=\"center\"><a href=\"https://weibo.com/u/2068032061?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/2068032061/d643d182/10.png\" /></a></div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 18:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/edisontalk\">EdisonZhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">78</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}