{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "从回调函数到Promise",
      "link": "https://www.cnblogs.com/LFeather/p/19583059",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/LFeather/p/19583059\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 10:47\">\n    <span>从回调函数到Promise</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近在面试中遇到了很多关于 <code>Promise</code> 的问题，因为以前的业务在请求方面并不复杂，多数时候都是在用 <code>async/await</code>，对 <code>Promise</code> 的理解还是有所欠缺，最近重新学习了一下 <code>Promise</code>，尽量避免写成API式的文章，主要还是结合自己的一些理解和思考来整理一下。</p>\n<h2 id=\"为什么要使用-promise\">为什么要使用 Promise</h2>\n<p>众所周知，JavaScript 的主线程是单线程执行的，所有的同步代码都是在一个线程中执行的，当遇到一些耗时操作时（比如网络请求、文件读取等），如果采用同步的方式去处理这些操作，就会阻塞主线程，导致页面卡顿，用户体验变差。为了解决这个问题，我们发明了异步编程，最早的异步编程方式是回调函数（Callback），我们先看一个简单的例子：</p>\n<pre><code class=\"language-javascript\">function add(getX, getY, finalCallback) {\n  var x, y;\n  getX(function (xVal) {\n    x = xVal;\n    if (y !== undefined) {\n      finalCallback(x + y);\n    }\n  });\n\n  getY(function (yVal) {\n    y = yVal;\n    if (x !== undefined) {\n      finalCallback(x + y);\n    }\n  });\n}\n\nfunction fetchX(xCallback) {\n  setTimeout(function () {\n    xCallback(2);\n  }, 1000);\n}\n\nfunction fetchY(yCallback) {\n  setTimeout(function () {\n    yCallback(3);\n  }, 1000);\n}\n\nadd(fetchX, fetchY, function (sum) {\n  console.log(\"Sum is: \" + sum);\n});\n</code></pre>\n<p><code>fetchX</code> 和 <code>fetchY</code> 是两个异步函数，分别模拟从服务器获取数据的过程，我们要进行 <code>x+y</code> 的计算，如果它们中的任何一个还没有准备好，就等待两者都准备好。我们逐步拆解这个过程：</p>\n<ol>\n<li>\n<p>调用 <code>add</code> 函数，传入 <code>fetchX</code>、<code>fetchY</code> 和回调函数。</p>\n</li>\n<li>\n<p>在 <code>add</code> 函数内部，调用 <code>getX</code>（即 <code>fetchX</code>），传入一个回调函数。</p>\n</li>\n</ol>\n<pre><code class=\"language-JavaScript\">function (xVal) {\n  x = xVal;\n  if (y !== undefined) {\n    finalCallback(x + y);\n  }\n}\n</code></pre>\n<ol start=\"3\">\n<li>\n<p><code>fetchX</code> 开始执行，经过1秒钟后，调用传入的回调函数（<code>xCallback</code>），将 <code>2</code> 作为参数传递进去。</p>\n</li>\n<li>\n<p>回调函数执行，<code>x</code> 被赋值为 <code>2</code>，然后检查 <code>y</code> 是否已经准备好（即 <code>y</code> 是否不为 <code>undefined</code>）。此时 <code>y</code> 还没有准备好，所以不会调用最终的 <code>finalCallback</code>。</p>\n</li>\n<li>\n<p>同样的过程发生在 <code>getY</code>（即 <code>fetchY</code>）上，经过1秒钟后，<code>y</code> 被赋值为 <code>3</code>，然后检查 <code>x</code> 是否已经准备好。此时 <code>x</code> 已经准备好了（<code>x=2</code>），所以调用 <code>finalCallback</code>，计算出最终的结果 <code>5</code>，并打印出来。</p>\n</li>\n</ol>\n<p>从这个例子中，我们是否能看出使用回调函数来处理异步操作存在一些问题？首先，也许这个思路很巧妙，但是代码很复杂，我在逐步拆解前很难直接理解这个过程。其次，如果有更多的异步操作需要处理，代码会变得更加复杂，难以维护，这就是著名的“回调地狱”问题。</p>\n<p>回想我刚上班时，使用的还是 jQuery，jQuery 的 Ajax 请求就是基于回调函数的，代码如下：</p>\n<pre><code class=\"language-javascript\">$.ajax({\n  url: \"https://api.example.com/data\",\n  method: \"GET\",\n  success: function (data) {\n    console.log(\"Data received:\", data);\n    $.ajax({\n      url: \"https://api.example.com/more-data\",\n      method: \"GET\",\n      success: function (moreData) {\n        console.log(\"More data received:\", moreData);\n        // 继续嵌套更多的回调...\n      },\n      error: function (err) {\n        console.error(\"Error fetching more data:\", err);\n      },\n    });\n  },\n  error: function (err) {\n    console.error(\"Error fetching data:\", err);\n  },\n});\n</code></pre>\n<p>显然，随着嵌套层级的增加，代码变得越来越难以阅读和维护，而且错误处理也变得复杂。所以回收这一节的标题，因为用回调函数来处理异步操作确实存在一些问题：</p>\n<ol>\n<li>可读性差：嵌套的回调函数使代码难以理解。</li>\n<li>错误处理复杂：每个回调函数都需要单独处理错误，导致代码冗长。</li>\n<li>控制流困难：管理多个异步操作的顺序和依赖关系变得复杂。</li>\n</ol>\n<p>等讲完 <code>Promise</code> 之后我们看下 <code>Promise</code> 是否能解决这些问题。</p>\n<h2 id=\"promise\">Promise</h2>\n<h3 id=\"是什么\">是什么</h3>\n<p>通俗的说，我们可以把 <code>Promise</code> 理解成一个异步操作的代理，它是异步操作的返回值，原本只有同步操作才能有返回值，异步操作只能使用我们上面所说的回调函数嵌套来获得结果。</p>\n<blockquote>\n<p>异步方法不会立即返回最终值，而是返回一个 <code>Promise</code>，以便在将来的某个时间点提供该值。</p>\n</blockquote>\n<p><code>Promise</code> 的基本用法应该都很熟悉了，我们创建一个 <code>Promise</code> 的例子：</p>\n<pre><code class=\"language-javascript\">// ES6 原生 Promise\nconst asyncTask = new Promise((resolve, reject) =&gt; {\n  // 模拟异步操作（比如接口请求、文件读取）\n  setTimeout(() =&gt; {\n    const success = true;\n    if (success) {\n      resolve(\"操作成功\"); // 成功回调\n    } else {\n      reject(\"操作失败\"); // 失败回调\n    }\n  }, 1000);\n});\n\n// 调用 Promise\nasyncTask\n  .then((result) =&gt; console.log(result)) // 输出：操作成功\n  .catch((error) =&gt; console.log(error))\n  .finally(() =&gt; console.log(\"操作完成\"));\n</code></pre>\n<p>可以看到，我们把异步操作 <code>setTimeout</code> 包装在 <code>Promise</code> 中，然后通过 <code>then</code>、<code>catch</code> 和 <code>finally</code> 来处理结果和错误，<code>setTimeout</code> 可以是任意异步操作，比如网络请求、文件读取等。</p>\n<p>隐藏在这些 API 之下的还有一个参数，一个 <code>Promise</code> 必然处于以下三种状态之一：</p>\n<ul>\n<li><strong><code>Pending</code>（进行中）</strong>：初始状态，既不是成功，也不是失败。</li>\n<li><strong><code>Fulfilled</code>（已成功）</strong>：操作成功完成。</li>\n<li><strong><code>Rejected</code>（已失败）</strong>：操作失败。</li>\n</ul>\n<p>这一部分内容可以参考 MDN 的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" rel=\"noopener nofollow\" target=\"_blank\">Promise - JavaScript | MDN</a>，讲得很清楚。</p>\n<p><img alt=\"\" src=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/promises.png\" /></p>\n<p>参考这张图，<code>Pending</code> 状态通向两个结果：<code>Fulfilled</code> 和 <code>Rejected</code>，这个过程是单向不可逆的，一旦状态改变，就会永久保持该状态。当任意一种情况发生时，<code>then</code> 方法注册的回调函数就会被调用，即不再处于\"待定\"（<code>Pending</code>）状态，称之为\"已敲定\"（<code>Settled</code>）。</p>\n<h4 id=\"rejected\">Rejected</h4>\n<p>我们先看 <code>Rejected</code> 的情况：</p>\n<pre><code class=\"language-JavaScript\">// catch\nconst failedTask = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    reject(\"操作失败\"); // 失败回调\n  }, 1000);\n});\n\nfailedTask\n  .then((result) =&gt; console.log(result))\n  .catch((error) =&gt; console.log(error)) // 输出：操作失败\n  .finally(() =&gt; console.log(\"操作完成\"));\n\n// then 第二个参数\nconst anotherFailedTask = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    reject(\"操作失败\"); // 失败回调\n  }, 1000);\n});\n\nanotherFailedTask\n  .then(\n    (result) =&gt; console.log(\"成功：\" + result),\n    (error) =&gt; console.log(\"失败：\" + error),\n  ) // 输出：操作失败\n  .finally(() =&gt; console.log(\"操作完成\"));\n</code></pre>\n<p>有两种方式可以捕获 <code>Promise</code> 的拒绝状态：一种是使用 <code>catch</code> 方法，另一种是将错误处理函数作为 <code>then</code> 方法的第二个参数传入。两种方式都能有效地处理 <code>Promise</code> 的拒绝状态，如果不进行错误处理，未捕获的拒绝会导致未处理的 <code>Promise</code> 拒绝警告。更详细的说明我们后面再聊，这里只看用法。</p>\n<h4 id=\"fulfilled\">Fulfilled</h4>\n<p>在构造器 <code>Promise(..)</code> 中，我们通常用两个回调函数来表示成功和失败的情况，这两个函数的命名并不固定，通常我们使用 <code>resolve</code> 和 <code>reject</code>，<code>reject</code> 很清楚地表示失败，并且代表 <code>Promise</code> 进入 <code>Rejected</code> 状态，而成功的回调函数 <code>resolve</code>（决议），它表示 <code>Promise</code> 进入 <code>Fulfilled</code> 状态，这里用 ES6 规范中的回调命名来说明：</p>\n<pre><code class=\"language-JavaScript\">myPromise.then((result) =&gt; onFulfilled, onRejected)\n</code></pre>\n<h4 id=\"链式调用\">链式调用</h4>\n<p>在提到 <code>Promise</code> 时，链式调用是一个非常重要的概念，上面的例子中，我们看到 <code>Promise</code> 对象可以调用 <code>then</code> 方法，而 <code>then</code> 方法又可以调用 <code>catch</code> 和 <code>finally</code> 方法，因为 <code>then</code> 方法返回的仍然是一个 <code>Promise</code> 对象，而 <code>catch</code> 和 <code>finally</code> 方法内在内部调用的也是 <code>then</code> 方法，这样它们就可以链式调用。</p>\n<pre><code class=\"language-JavaScript\">// Promise.resolve这种写法我们之后讨论\nPromise.resolve('第一步结果')\n  .then(res =&gt; {\n    console.log(res); // 打印：第一步结果\n    // return 普通值 → 新 Promise 状态为 fulfilled\n    return '第二步结果';\n  })\n  .then(res =&gt; {\n    console.log(res); // 打印：第二步结果\n    // return 新 Promise → 新 Promise 跟随该 Promise 的状态\n    return Promise.resolve('第三步结果');\n  })\n  .then(res =&gt; {\n    console.log(res); // 打印：第三步结果\n  });\n</code></pre>\n<p>通过例子可以看到，链式调用可以将多个异步操作串联起来，每个 <code>then</code> 方法处理上一个 <code>Promise</code> 的结果，这就解决了我们最开始提到的回调地狱问题，使代码更加清晰和易于维护。</p>\n<p>这个例子中还有一个细节，在 <code>then</code> 方法中通过 <code>return</code> 来传递值，当使用 <code>return</code> 返回一个普通值时，新的 <code>Promise</code> 会进入 <code>Fulfilled</code> 状态，也可以返回一个新的 <code>Promise</code> 对象，这样新的 <code>Promise</code> 会跟随该 <code>Promise</code> 的状态。值得注意的是，如果返回的是一个 <code>thenable</code> 对象（具有 <code>then</code> 方法的对象），<code>Promise</code> 也会等待该对象解决，这使得 <code>Promise</code> 可以与其他实现了类 <code>Promise</code> 接口的库进行互操作。</p>\n<p>大体上我们了解了 <code>Promise</code> 的用法，我们用 <code>Promise</code> 来实现嵌套异步操作：</p>\n<pre><code class=\"language-JavaScript\">function getFirstData() {\n  // 返回一个 Promise，用 setTimeout 模拟异步\n  return new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n      const data = \"第一个异步操作的结果\";\n      console.log(\"Data received:\", data);\n      // 异步成功，传递结果给下一个 .then()\n      resolve(data);\n    }, 1000);\n  });\n}\n\nfunction getSecondData(prevData) {\n  return new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n      const moreData = `第二个异步操作的结果（基于上一步：${prevData}）`;\n      console.log(\"More data received:\", moreData);\n      resolve(moreData); // 可选：继续传递结果给后续链式调用\n    }, 1000);\n  });\n}\n\n// 链式调用\ngetFirstData()\n  .then((data) =&gt; {\n    // 第一个异步成功后，执行第二个异步\n    return getSecondData(data);\n  })\n  .catch((err) =&gt; {\n    // 统一捕获所有异步操作的错误\n    console.error(\"异步操作出错：\", err);\n  });\n</code></pre>\n<h3 id=\"promise-解决了什么问题\">Promise 解决了什么问题</h3>\n<p>通过这个例子可以看到，我们一开始提出的回调函数的三个问题得到了不同程度的解决：</p>\n<ol>\n<li><strong>可读性提升</strong>：通过链式调用，代码结构更加清晰，每个异步操作都在自己的 <code>then</code> 块中处理，避免了嵌套回调的复杂性。</li>\n<li><strong>统一错误处理</strong>：使用 <code>catch</code> 方法可以统一捕获所有异步操作的错误，简化了错误处理逻辑。</li>\n<li><strong>控制流简化</strong>：通过链式调用，可以更容易地管理多个异步操作的顺序和依赖关系，使代码更易于理解。</li>\n</ol>\n<p>这里有点像一种 <code>if</code> 语句的替代写法：</p>\n<pre><code class=\"language-JavaScript\">if (condition1) {\n  // do something\n  if (condition2) {\n    // do something\n    if (condition3) {\n      // do something\n    }\n  }\n}\n\n// 可以改写为：\n\nif(!condition1) return;\n// do something\nif(!condition2) return;\n// do something\nif(!condition3) return;\n// do something\n\n</code></pre>\n<p>换个思路，作用相同，但代码的可读性会变高，不过 <code>Promise</code> 要复杂得多，我没有直接使用一开始的回调函数版本来对比，并非做不到，而是涉及了新的知识点，需要用到 <code>Promise</code> 的一些 API，我打算换一种角度来理解，然后我们再回头看这个对比。</p>\n<h3 id=\"promise-的-api-与原型\">Promise 的 API 与原型</h3>\n<p><code>Promise</code> 是 ES6（ES2015）引入的一种用于处理异步操作的<strong>对象</strong>，最近刚写了一篇关于原型的文章：<a href=\"https://www.cnblogs.com/LFeather/p/19312203\" target=\"_blank\">对于原型、原型链和继承的理解</a>，这里就是想从原型和面向对象的角度来加深一下理解，我们还是用前面的例子，分步拆解：</p>\n<pre><code class=\"language-javascript\">// ES6 原生 Promise\nconst asyncTask = new Promise((resolve, reject) =&gt; {\n  // 模拟异步操作（比如接口请求、文件读取）\n  setTimeout(() =&gt; {\n    const success = true;\n    if (success) {\n      resolve(\"操作成功\"); // 成功回调\n    } else {\n      reject(\"操作失败\"); // 失败回调\n    }\n  }, 1000);\n});\n\n// 调用 Promise\nasyncTask\n  .then((result) =&gt; console.log(result)) // 输出：操作成功\n  .catch((error) =&gt; console.log(error))\n  .finally(() =&gt; console.log(\"操作完成\"));\n</code></pre>\n<h4 id=\"构造函数-promise\">构造函数 Promise()</h4>\n<p>先从核心语句说起， <code>new Promise((resolve, reject) =&gt; { ... })</code> 这里事关两个概念：构造函数和 <code>new</code>。</p>\n<p><code>Promise()</code> 是一个构造器（Constructor）或者说构造函数，用于创建 <code>Promise</code> 对象。</p>\n<p>使用构造函数的形式来创建对象有几个好处：</p>\n<ol>\n<li>\n<p><strong>封装初始化逻辑</strong>：<code>Promise</code> 构造函数内部封装了初始化 <code>Promise</code> 对象所需的逻辑，比如设置初始状态（<code>pending</code>）、设置回调函数（<code>resolve</code> 和 <code>reject</code>）。</p>\n</li>\n<li>\n<p><strong>共享方法</strong>：通过构造函数创建的对象实例可以共享原型上的方法（如 <code>then</code>、<code>catch</code>、<code>finally</code>），避免每个实例都创建一份相同的方法，节省内存。</p>\n</li>\n<li>\n<p><strong>立即执行</strong>：当我们创建一个新的 <code>Promise</code> 实例时，传入的执行器函数（executor function）会立即执行，这使得我们可以在创建 <code>Promise</code> 的同时开始异步操作。</p>\n</li>\n</ol>\n<p>而 <code>new</code> 关键字用于创建一个新的对象实例，并将其原型链接到构造函数的原型对象上，也就是让新创建的对象继承构造函数原型上的方法和属性，结合上面的例子就是说我们创建的 <code>asyncTask</code> 对象会继承 <code>Promise.prototype</code> 上的方法，比如 <code>then</code>、<code>catch</code> 和 <code>finally</code>，这也就是为什么我们可以在 <code>asyncTask</code> 上调用这些方法，以及进行前面所说的链式调用。</p>\n<p>要注意的一点是，执行器函数的返回值对 <code>Promise</code> 的影响有限，在 <code>then</code> 方法中我们通过 <code>return</code> 来传递值，但在执行器函数中 <code>return</code> 语句仅影响控制流程，并不会直接改变 <code>Promise</code> 的状态，<code>Promise</code> 的状态只能通过调用 <code>resolve</code> 或 <code>reject</code> 来改变。</p>\n<pre><code class=\"language-JavaScript\">const myPromise = new Promise((resolve, reject) =&gt; {\n  // 一些异步操作\n  if (/* 操作成功 */) {\n    resolve(\"成功结果\");\n  } else {\n    reject(\"失败原因\");\n  }\n  return \"这个返回值不会影响 Promise 的状态\";\n});\n</code></pre>\n<h4 id=\"入参-resolve-reject-\">入参 (resolve, reject) =&gt;</h4>\n<p>接下来我们看构造函数的入参 <code>(resolve, reject) =&gt; { ... }</code> ，也就是执行器函数（executor function），它会在 <code>Promise</code> 实例创建时立即执行，这个上面说过了。使用 <code>Promise</code> 时，我们不会关注执行器函数，主要是使用这个函数的入参 <code>resolve</code> 和 <code>reject</code> 用来改变 <code>Promise</code> 的状态。</p>\n<pre><code class=\"language-JavaScript\">function executor(resolveFunc, rejectFunc) {\n  // 通常，`executor` 函数用于封装某些接受回调函数作为参数的异步操作，比如上面的 `setTimeout` 函数\n}\n</code></pre>\n<p>当调用 <code>resolve</code> 或 <code>reject</code> 时，<code>Promise</code> 的状态会立即改变，从 <code>pending</code> 变为 <code>fulfilled</code> 或 <code>rejected</code>，然后执行回调函数，这个回调函数就是我们通过 <code>then</code> 方法注册的函数。</p>\n<pre><code class=\"language-JavaScript\">const p = new Promise((resolve) =&gt; {\n  console.log('1. 执行器函数立即执行');\n  resolve('成功');\n  console.log('2. resolve 调用完成（同步）');\n});\n\nconsole.log('3. Promise 创建完成');\n\np.then((value) =&gt; {\n  console.log('5. then 回调执行:', value);\n});\n\nconsole.log('4. then 方法调用完成');\n\n// 输出顺序：\n// 1. 执行器函数立即执行\n// 2. resolve 调用完成（同步）\n// 3. Promise 创建完成\n// 4. then 方法调用完成\n// 5. then 回调执行: 成功\n</code></pre>\n<p>但我们用到 <code>Promise</code> 时主要还是用于异步任务，<code>then</code> 方法是典型的微任务（microtask），如果 <code>then</code> 方法先执行，里面的回调函数会被放入微任务队列，等待当前宏任务执行完毕后再执行。</p>\n<p>对于更细致的执行顺序，之前有写过一篇关于事件循环的文章，刚好是用 <code>Promise</code> 举例，可以参考：<a href=\"https://www.cnblogs.com/LFeather/p/16139014.html\" target=\"_blank\">有关 JavaScript 事件循环的若干疑问探究</a>。</p>\n<p><code>Promise</code> 内部的大致逻辑是这样的：</p>\n<pre><code class=\"language-JavaScript\">// Promise 内部简化实现\nclass MyPromise {\n  constructor(executor) {\n    this.state = 'pending';           // 状态\n    this.value = undefined;           // 结果值\n    this.onFulfilledCallbacks = [];   // ← 存储 then 的成功回调\n    this.onRejectedCallbacks = [];    // ← 存储 then 的失败回调\n\n    const resolve = (value) =&gt; {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled';\n        this.value = value;\n        // ← 关键：遍历回调队列，将所有回调加入微任务\n        this.onFulfilledCallbacks.forEach(callback =&gt; {\n          queueMicrotask(() =&gt; callback(value));\n        });\n      }\n    };\n\n    const reject = (reason) =&gt; {\n      if (this.state === 'pending') {\n        this.state = 'rejected';\n        this.value = reason;\n        this.onRejectedCallbacks.forEach(callback =&gt; {\n          queueMicrotask(() =&gt; callback(reason));\n        });\n      }\n    };\n\n    executor(resolve, reject);\n  }\n\n  then(onFulfilled, onRejected) {\n    // 如果 Promise 还是 pending，就把回调存起来\n    if (this.state === 'pending') {\n      this.onFulfilledCallbacks.push(onFulfilled);  // ← 存储回调\n      this.onRejectedCallbacks.push(onRejected);\n    }\n    // 如果 Promise 已经 fulfilled，立即将回调加入微任务\n    else if (this.state === 'fulfilled') {\n      queueMicrotask(() =&gt; onFulfilled(this.value));\n    }\n    // 如果 Promise 已经 rejected\n    else if (this.state === 'rejected') {\n      queueMicrotask(() =&gt; onRejected(this.value));\n    }\n\n    return new MyPromise(() =&gt; {}); // 简化，实际更复杂\n  }\n}\n</code></pre>\n<p>所以 <code>then</code> 中的回调函数被执行的前提是 <code>resolve</code> 或 <code>reject</code> 被调用并且 <code>then</code> 方法也被调用，这也是 <code>Promise</code> 能处理异步操作的关键。</p>\n<h4 id=\"静态方法\">静态方法</h4>\n<p>简单提一下，静态方法是直接挂载在构造函数上的方法，而不是实例对象上，以前面的例子来说，<code>asyncTask</code> 是 <code>Promise</code> 的一个实例对象，而 <code>Promise.all(..)</code> 和 <code>Promise.resolve(..)</code> 这种则是 <code>Promise</code> 构造函数的一个静态方法。</p>\n<p>基于上面的简单例子，<code>Promise</code> 大体上的用法我们已经了解了，但还有很多 API 没有涉及到，我们可以通过打印 <code>Promise</code> 的原型来查看：</p>\n<pre><code class=\"language-JavaScript\">console.log(Promise.prototype);\n</code></pre>\n<p><img alt=\"\" src=\"https://blog-1252364274.cos.ap-guangzhou.myqcloud.com/20260205173555584.png\" /></p>\n<p>我们可以看到 <code>then</code>、<code>catch</code> 和 <code>finally</code> 方法都在 <code>Promise.prototype</code> 上，这些方法是实例方法，意味着它们可以被任何 <code>Promise</code> 实例调用。</p>\n<p>由于安全机制，直接打印 <code>Promise</code> 本身是看不到原生代码的，我们换一种方式，只需要得到静态方法名就行：</p>\n<pre><code class=\"language-JavaScript\">console.log(Object.getOwnPropertyNames(Promise));\n\n// 输出：['length', 'name', 'prototype', 'all', 'allSettled', 'any', 'race', 'resolve', 'reject', 'withResolvers', 'try']\n</code></pre>\n<p>输出结果中有的熟悉有的不熟悉，因为我之前对 <code>Promise</code> 仅停留在会用的层面，所以有些我甚至是第一次知道，但没关系，通过原型再对照 MDN 文档，逐个学习一下。 <code>length</code>、<code>name</code> 和 <code>prototype</code> 是函数对象的默认属性，我们主要关注其他的静态方法：</p>\n<ol>\n<li><code>Promise.resolve(..)</code> 和 <code>Promise.reject(..)</code></li>\n</ol>\n<p>这两个方法应该是最常见的了，上面的例子中也用到过，<code>reject</code> 比较简单，返回一个拒绝状态的 <code>Promise</code> 对象，入参就是拒绝的原因：</p>\n<pre><code class=\"language-JavaScript\">const promiseReject = Promise.reject(new Error(\"失败原因\"));\npromiseReject.catch((reason) =&gt; {\n  console.log(reason.message);\n  // Expected output: 失败原因\n});\n\n// 或者\nfunction resolved(result) {\n  console.log(\"Resolved\");\n}\n\nfunction rejected(result) {\n  console.log(\"Rejected:\", result);\n}\n\nconst promiseReject2 = Promise.reject(\"失败原因\");\npromiseReject2.then(resolved, rejected);\n</code></pre>\n<p><code>resolve</code> 方法则比较复杂一些，它有两种返回形式：1. 如果入参是一个普通值（非 <code>Promise</code> 对象），则返回一个以该值为结果的已解决（<code>fulfilled</code>）状态的 <code>Promise</code> 对象，这一点与 <code>reject</code> 对应；2. 如果入参是一个 <code>Promise</code> 对象，则返回该 <code>Promise</code> 对象本身。</p>\n<pre><code class=\"language-JavaScript\">// 入参是普通值\nconst promise1 = Promise.resolve(123);\n\npromise1.then((value) =&gt; {\n  console.log(value);\n  // Expected output: 123\n});\n\n// 入参是 Promise 对象\nconst originalPromise = new Promise((resolve) =&gt; {\n  setTimeout(() =&gt; {\n    resolve(\"原始 Promise 结果\");\n  }, 1000);\n});\n\nconst promise2 = Promise.resolve(originalPromise);\npromise2.then((value) =&gt; {\n  console.log(value);\n  // Expected output: 原始 Promise 结果\n});\n</code></pre>\n<ol start=\"2\">\n<li><code>Promise.all(..)</code>、<code>Promise.race(..)</code>、<code>Promise.allSettled(..)</code> 和 <code>Promise.any(..)</code></li>\n</ol>\n<p>这四个我觉得可以放一起介绍，它们都是用于处理多个 <code>Promise</code> 对象的静态方法，入参都是一个可迭代对象（通常是数组），包含多个 <code>Promise</code> 对象，返回一个新的 <code>Promise</code> 对象，其他的区别用一张表格来说明：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Promise.all(..)</code></td>\n<td>全成功才成功，一失败就失败。</td>\n<td>成功时返回一个包含所有结果的数组，失败时返回第一个失败的原因。</td>\n</tr>\n<tr>\n<td><code>Promise.allSettled(..)</code></td>\n<td>等所有完成，无论成败。</td>\n<td>结果是一个包含每个 <code>Promise</code> 结果状态的数组。</td>\n</tr>\n<tr>\n<td><code>Promise.any(..)</code></td>\n<td>一成功就成功，全失败才失败。</td>\n<td>成功时返回第一个成功的结果，失败时返回一个 <code>AggregateError</code>，包含所有失败的原因。</td>\n</tr>\n<tr>\n<td><code>Promise.race(..)</code></td>\n<td>谁先完成（成败均可），就用谁的结果。</td>\n<td>结果是第一个解决或拒绝的 <code>Promise</code> 的结果或原因。</td>\n</tr>\n</tbody>\n</table>\n<p>关于 <code>Promise.all(..)</code> 的应用，我们最开始的回调函数就是一个很好的例子，我们可以用它来重写：</p>\n<pre><code class=\"language-JavaScript\">function fetchX() {\n  return new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n      resolve(2);\n    }, 1000);\n  });\n}\nfunction fetchY() {\n  return new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n      resolve(3);\n    }, 1000);\n  });\n}\n\nfunction add() {\n  return Promise.all([fetchX(), fetchY()]).then(([x, y]) =&gt; x + y);\n}\n\nadd().then((sum) =&gt; {\n  console.log(\"Sum is: \" + sum); // 输出：Sum is: 5\n});\n</code></pre>\n<p>如果有三个异步操作：</p>\n<pre><code class=\"language-JavaScript\">function fetchZ() {\n  return new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n      resolve(4);\n    }, 1000);\n  });\n}\n\nfunction addThree() {\n  return Promise.all([fetchX(), fetchY(), fetchZ()]).then(([x, y, z]) =&gt; x + y + z);\n}\n</code></pre>\n<p>MDN上的 <code>Promise.allSettled(..)</code> 例子：</p>\n<pre><code class=\"language-JavaScript\">Promise.allSettled([\n  Promise.resolve(33),\n  new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(66), 0)),\n  99,\n  Promise.reject(new Error(\"一个错误\")),\n]).then((values) =&gt; console.log(values));\n\n// [\n//   { status: 'fulfilled', value: 33 },\n//   { status: 'fulfilled', value: 66 },\n//   { status: 'fulfilled', value: 99 },\n//   { status: 'rejected', reason: Error: 一个错误 }\n// ]\n</code></pre>\n<p>这里的返回值有些不同，是一个对象数组，每个对象表示对应 <code>Promise</code> 的状态和结果。</p>\n<p><code>Promise.any(..)</code> 的返回值是第一个成功的结果，如果所有 <code>Promise</code> 都失败了，则返回一个 <code>AggregateError</code>，它包含所有失败的原因：</p>\n<pre><code class=\"language-JavaScript\">const promiseA = Promise.reject(\"失败原因 A\");\nconst promiseB = Promise.reject(\"失败原因 B\");\n\nPromise.any([promiseA, promiseB])\n  .then((value) =&gt; {\n    console.log(value);\n  })\n  .catch((error) =&gt; {\n    console.log(error);\n  });\n\n// 输出：AggregateError: All promises were rejected\n</code></pre>\n<p>与其他三个方法不同，<code>Promise.race(..)</code> 返回的 <code>Promise</code> 状态的敲定总是异步的，前面的三种方法入参的 <code>Promise</code> 数组中有一个甚至多个是已经解决（<code>fulfilled</code>）或拒绝（<code>rejected</code>）的 <code>Promise</code> 对象（简单来说，和上面的大部分例子一样，我们传入一个确定的值而不是异步方法），那么 <code>Promise.all(..)</code>、<code>Promise.allSettled(..)</code> 和 <code>Promise.any(..)</code> 会立即返回结果，而 <code>Promise.race(..)</code> 的返回值则是异步的。</p>\n<p>MDN 针对每个方法的返回值都有详细的说明，比如说 <code>Promise.all(..)</code> ，如果传入的参数为空，则它的状态会立即变为 <strong>已解决（<code>fulfilled</code>）</strong> 另外两种返回状态则为 <strong>异步兑现（asynchronously fulfilled）</strong> 和 <strong>异步拒绝（asynchronously rejected）</strong> ，而 <code>Promise.any(..)</code> 则是相反的，如果传入的参数为空，则它的状态会立即变为 <strong>已拒绝（<code>rejected</code>）</strong>，其他情况都是异步的。</p>\n<p>向 <code>Promise.race(..)</code> 传入一个空的可迭代对象会导致返回的 <code>Promise</code> 永远处于挂起状态（<code>pending</code>），因为没有任何 <code>Promise</code> 可以兑现或拒绝。</p>\n<pre><code class=\"language-JavaScript\">const foreverPendingPromise = Promise.race([]);\nconsole.log(foreverPendingPromise);\nsetTimeout(() =&gt; {\n  console.log(\"堆栈现在为空\");\n  console.log(foreverPendingPromise);\n});\n\n// 按顺序打印：\n// Promise { &lt;state&gt;: \"pending\" }\n// 堆栈现在为空\n// Promise { &lt;state&gt;: \"pending\" }\n</code></pre>\n<p><code>Promise.race(..)</code> 的异步性有什么意义呢？假设我们有一个网络请求操作，我们希望在一定时间内获得响应，否则就放弃请求，这时我们可以使用 <code>Promise.race(..)</code> 来实现超时控制：</p>\n<pre><code class=\"language-JavaScript\">const data = Promise.race([\n  fetch(\"/api\"),\n  new Promise((resolve, reject) =&gt; {\n    // 5 秒后拒绝\n    setTimeout(() =&gt; reject(new Error(\"请求超时\")), 5000);\n  }),\n])\n  .then((res) =&gt; res.json())\n  .catch((err) =&gt; displayError(err));\n</code></pre>\n<ol start=\"3\">\n<li><code>Promise.try()</code></li>\n</ol>\n<blockquote>\n<p><code>Promise.try()</code> 静态方法接受一个任意类型的回调函数（无论其是同步或异步，返回结果或抛出异常），并将其结果封装成一个 <code>Promise</code>。</p>\n</blockquote>\n<p>这是一个截止到目前（2026年2月）仍在提案阶段的 API，在一些现代浏览器和 Node.js 最新版本中已经可以使用，作用类似于 <code>async</code> 函数，可以将同步代码和异步代码统一处理为 <code>Promise</code> 对象：</p>\n<pre><code class=\"language-JavaScript\">Promise.try(() =&gt; {\n  // 这里可以是同步代码\n  const result = synchronousFunction();\n  return result;\n})\n  .then((value) =&gt; {\n    console.log(\"同步结果:\", value);\n  })\n  .catch((error) =&gt; {\n    console.error(\"错误:\", error);\n  });\n// 也可以是异步代码\nPromise.try(async () =&gt; {\n  const result = await asynchronousFunction();\n  return result;\n})\n  .then((value) =&gt; {\n    console.log(\"异步结果:\", value);\n  })\n  .catch((error) =&gt; {\n    console.error(\"错误:\", error);\n  });\n</code></pre>\n<ol start=\"4\">\n<li><code>Promise.withResolvers()</code></li>\n</ol>\n<blockquote>\n<p><code>Promise.withResolvers()</code> 静态方法返回一个对象，其包含一个新的 <code>Promise</code> 对象和两个函数，用于解决或拒绝它，对应于传入给 <code>Promise()</code> 构造函数执行器的两个参数。</p>\n</blockquote>\n<p>它完全等价于下面的代码：</p>\n<pre><code class=\"language-JavaScript\">let resolve, reject;\nconst promise = new Promise((res, rej) =&gt; {\n  resolve = res;\n  reject = rej;\n});\n</code></pre>\n<p>它的作用是简化创建一个可控的 <code>Promise</code> 对象，我们可以在外部调用 <code>resolve</code> 和 <code>reject</code> 来改变 <code>Promise</code> 的状态：</p>\n<pre><code class=\"language-JavaScript\">const { promise, resolve, reject } = Promise.withResolvers();\n// 模拟异步操作\nsetTimeout(() =&gt; {\n  const success = true;\n  if (success) {\n    resolve(\"操作成功\");\n  } else {\n    reject(\"操作失败\");\n  }\n}, 1000);\npromise\n  .then((result) =&gt; console.log(result))\n  .catch((error) =&gt; console.log(error))\n  .finally(() =&gt; console.log(\"操作完成\"));\n</code></pre>\n<p>这个 API 的使用场景比较少见，目前我还不能完全理解它的作用，感兴趣可以到 MDN 上查看。</p>\n<h2 id=\"asyncawait-与-promise\">async/await 与 Promise</h2>\n<p>最开始就说到 <code>async/await</code> 了，我是先接触到 <code>async/await</code> 这种写法的，然后才了解到它是基于 <code>Promise</code> 的语法糖，个人理解来说，<code>async/await</code> 让异步代码看起来更像同步代码，主要是提高代码的可读性和可维护性，就像 <code>Promise</code> 之于回调函数一样。</p>\n<p>在使用上，<code>async/await</code> 的争议集中在是否要使用 <code>try/catch</code> 来处理错误，我之前的处理方式是在请求的封装里使用 <code>try/catch</code> 来捕获错误，调用时正常使用 <code>async/await</code> ，其他地方处理异步操作还是直接使用 <code>Promise</code>。以前其实没有太深入考虑过合理性的问题，在新公司看代码规范时发现他们有针对这个问题讨论过，才意识到这个问题的重要性。关于这个问题争议比较大，而且关于 <code>async/await</code> 完全可以单独写一篇，这篇主要还是针对 <code>Promise</code> 的学习记录，再写下去也有些超篇幅了，之后学习时应该还会再聊到。</p>\n<h2 id=\"缺陷\">缺陷</h2>\n<p>这个部分对于我来说还是有些超纲了，但也有参考资料，列一下《你不知道的JavaScript》中卷提到的几个缺陷，不过这些纸质书有一定的时代性，内容仅供参考：</p>\n<ol>\n<li><strong>顺序错误处理</strong>： 如果构建了一个没有错误处理函数的Promise链，链中后续的 <code>then</code> 仍然会被执行，可能导致错误被忽略或处理不当。</li>\n<li><strong>单一值</strong>： <code>Promise</code> 只能处理单一值的传递，无法直接处理多个值或复杂的数据结构（可以传递封装的对象，但如果在链中的每一步都进行封装和解封，就有些笨重了）。</li>\n<li><strong>单决议</strong>： <code>Promise</code> 一旦被解决（<code>fulfilled</code>）或拒绝（<code>rejected</code>），其状态就不能再改变，无法重新解决或拒绝。</li>\n<li><strong>惯性</strong>： 时代性的体现，考虑当时的环境 <code>Promise</code> 还未普及，现在应该可以忽略这一点了。</li>\n<li><strong>不可取消</strong>： 一旦创建，<code>Promise</code> 就会一直执行，无法取消正在进行的异步操作。这个也有些时代性了，现在有 <code>AbortController</code> 可以配合 <code>fetch</code> 来实现取消请求的功能。</li>\n<li><strong>性能</strong>： 相较于回调函数，<code>Promise</code> 在创建和管理状态方面有一定的性能开销，但个人认为这在通常的应用场景中影响不大。</li>\n</ol>\n<h2 id=\"总结\">总结</h2>\n<p>说实话动笔之前就是觉得应该写一篇关于 <code>Promise</code> 的，但开始写之后发现没什么方向，相关资料也是浩如烟海，写这篇耗费了非常多的时间，开始不断地深挖细节后感觉有无穷无尽的问题，好在现在通过 AI 至少可以把这些问题大致理清楚，\"大致\"理解说明还有很多内容没有涉及，之后在项目中应该会更加注意 <code>Promise</code> 的应用，然后把《你不知道的JavaScript》的相关内容看完结合一下应该还可以再水一篇。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 10:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/LFeather\">夜尽丶</a>&nbsp;\n阅读(<span id=\"post_view_count\">48</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI开发-python-langchain框架（1-12 返回json-格式解析器）",
      "link": "https://www.cnblogs.com/yclh/p/19583025",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yclh/p/19583025\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 10:40\">\n    <span>AI开发-python-langchain框架（1-12 返回json-格式解析器）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>关键点来了，现在json格式是开发中是最为普遍的数据格式，尤其在前后端交互中应用十分广泛，如何让大模型返回的数据是标准的json格式？</p>\n<p>看如下代码：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">from langchain.prompts import PromptTemplate\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.output_parsers import JsonOutputParser\nfrom langchain_core.pydantic_v1 import BaseModel, Field\nimport os\n\n\n# 定义您想要的数据结构。\nclass Book(BaseModel):\n    title: str = Field(description=\"书名\")\n    author: str = Field(description=\"作者\")\n    description: str = Field(description=\"书的简介\")\n\n# Set up a parser + inject instructions into the prompt template.\noutput_parser = JsonOutputParser(pydantic_object=Book)\n\n\nformat_instructions = output_parser.get_format_instructions()\nprint('原版提示词')\nprint(format_instructions)\nprint('#############')\n\n\n#改成中文提示词\nformat_instructions = '''输出应格式化为符合以下 JSON 结构的 JSON 实例。\nJSON结构\n```\n{\n'title': '书的标题',\n'author': '作者',\n'description': '书的简介'\n}\n```\n'''\nprompt = PromptTemplate(\n    template=\"{format_instructions}\\n{query}\\n\",\n    input_variables=[\"query\"],\n    partial_variables={\"format_instructions\": format_instructions},\n)\n\n\n\n# 初始化聊天模型（使用DeepSeek API）\nllm = ChatOpenAI(\n    api_key=os.getenv(\"DEEPSEEK_API_KEY\"),            # 从环境变量读取API密钥\n    base_url=os.getenv(\"BASE_URL\"),                   # 从环境变量读取API基础URL（如 https://api.deepseek.com）\n    model=\"deepseek-v3:671b\",                         # 指定使用的模型版本\n    temperature=0.7,                                  # 生成随机性控制：0.7 适中创造性\n    max_tokens=1024                                   # 单次响应最大token数\n)\n\nchain = prompt | llm | output_parser\n\nprint('--------------')\n# 以及旨在提示语言模型填充数据结构的查询。\nquery = \"请给我介绍2本学习中国历史的经典书籍\"\nresult = chain.invoke({\"query\": query})\nprint(result)\n\n#流式输出\n# for s in chain.stream({\"query\": query}):\n#     print(s)\n</pre>\n</div>\n<p>&nbsp;输出：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">原版提示词\nThe output should be formatted as a JSON instance that conforms to the JSON schema below.\n\nAs an example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\nHere is the output schema:\n```\n{\"properties\": {\"title\": {\"title\": \"Title\", \"description\": \"\\u4e66\\u540d\", \"type\": \"string\"}, \"author\": {\"title\": \"Author\", \"description\": \"\\u4f5c\\u8005\", \"type\": \"string\"}, \"description\": {\"title\": \"Description\", \"description\": \"\\u4e66\\u7684\\u7b80\\u4ecb\", \"type\": \"string\"}}, \"required\": [\"title\", \"author\", \"description\"]}\n```\n#############\n--------------\n[{'title': '中国通史', 'author': '吕思勉', 'description': '《中国通史》是吕思勉先生的代表作之一，系统全面地介绍了中国从远古时代到近代的历史发展脉络。该书内容详实，分析深入，是学习中国历史的经典入门书籍。'}, {'title': '万历十五年', 'author': '黄仁宇', 'description': '《万历十五年》是黄仁宇先生的经典著作，以明朝万历十五年为切入点，通过细致入微的历史分析，展现了当时社会的政治、经济和文化状况。该书视角独特，文笔流畅，深受读者喜爱。'}]\n</pre>\n</div>\n<p>&nbsp;看这个返回数据是不是就是需要的标准json格式</p>\n<p>上面这段代码的核心是通过<strong>定义数据结构、构建提示词、调用大模型、解析输出</strong>的完整流程，精准控制大模型返回指定格式的 JSON 数据。</p>\n<p>首先通过 Pydantic 的 <code>BaseModel</code> 定义 <code>Book</code> 类，明确要求输出包含 <code>title</code>、<code>author</code>、<code>description</code> 三个字段及对应含义，为 JSON 输出提供规则蓝本；</p>\n<p>接着利用 <code>JsonOutputParser</code> 绑定该数据结构（关键点），既自动生成格式提示词，又能后续校验并解析模型输出，同时自定义中文格式提示词强化大模型对 JSON 结构的理解，确保字段与定义完全匹配；</p>\n<p>再通过 <code>PromptTemplate</code> 将格式要求与用户查询拼接为标准化提示词，明确告知大模型需返回符合结构的 JSON 实例；</p>\n<p>初始化兼容第三方模型的 <code>ChatOpenAI</code> 时，将 <code>temperature</code> 设为 0.7 平衡创造性与格式合规性，降低输出偏离 JSON 结构的概率；</p>\n<p>最后通过 LangChain 的链式调用（<code>prompt | llm | output_parser</code>）自动化完成 “提示词拼接→模型生成→JSON 解析” 全流程，</p>\n<p>最终输出可直接操作的 Python 字典，全程通过结构约束、提示词引导、解析器校验三重保障，实现大模型稳定返回合规 JSON 数据的核心目标。</p>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 10:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yclh\">万笑佛</a>&nbsp;\n阅读(<span id=\"post_view_count\">20</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "刚刚，Claude Opus 4.6 和 GPT-5.3-Codex 同时炸场！AI 编程要变天了",
      "link": "https://www.cnblogs.com/yupi/p/19583031",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19583031\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 10:40\">\n    <span>刚刚，Claude Opus 4.6 和 GPT-5.3-Codex 同时炸场！AI 编程要变天了</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"刚刚，Claude Opus 4.6 和 GPT-5.3-Codex 同时炸场！AI 编程要变天了\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202602/2225420-20260206102350805-967131892.png\" />\n        这次两家巨头同时发布新模型，互相贴脸开大，对我们用户来说是好事。可以看到，这两个模型都在往 实用方向 猛卷，是真的想让你日常工作中用得上。\n这两个大模型你会如何选择呢？\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-heading\"><span class=\"md-plain\">大家好，我是程序员鱼皮。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">今天凌晨，AI 圈又双叒炸了。Anthropic 和 OpenAI 几乎同时发布了自家的最新大模型 —— Claude Opus 4.6 和 GPT-5.3-Codex，中门对狙，火药味十足。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这次两家是真往编程和实际工作能力上卷了，不是那种 “跑分升了 2 个点” 就发篇博客的敷衍更新。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下面我带大家快速了解一下，这两个模型到底更新了什么？对我们程序员和 AI 玩家来说有什么用？</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">Claude Opus 4.6：更聪明、更能干、更持久</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先说 Anthropic 这边。Claude Opus 4.6 是目前 Claude 家族最强的模型，之前用 Claude Opus 4.5 编程就已经让我感觉 “AI 写代码无所不能” 了，而这次的 Opus 4.6 在多项评估中均处于最先进水平，包括智能编码、多学科推理、知识工作和智能搜索等。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">光看这个跑分我就贼激动了！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">实际上手后，我最直观的感受就是：<span class=\"md-pair-s \"><strong>干活更靠谱了</strong><span class=\"md-plain\">。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">具体更新了这些：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）编程能力大幅提升：Opus 4.6 能更好地在大型代码库中工作，调试和代码审查能力增强，写完代码还能自己检查错误。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我实测了一波，让之前的 Opus 4.5 和新出的 Opus 4.6 同时开发一个「聚合搜索引擎」项目：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>请你帮我开发一个聚合搜索网站，包含完整的前端和后端，能够同时从多个不同的搜索引擎搜索和聚合结果。<br /><span>应该先做 MVP 最小可行产品，整个过程不需要向我确认、不需要我提供 API Key，你必须确保功能正常可用。</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">几分钟后，二者都完成了任务：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但是对比一下实际搜索效果，Opus 4.5 完败，看到这我就放心了，以后我用 AI 编程估计 Bug 更少了~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）100 万 token 上下文窗口。Opus 系列第一次支持这么长的上下文，简单来说就是你可以一次性给它丢一大堆文件和代码，它都能记住并理解，不会像以前那样聊着聊着就失忆了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这也是我最最最期待的特性，复杂的前后端项目也可以在同一对话框中一把梭了！不用来来回回总结上下文和新开对话框。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">赣，准备嘎嘎烧 Tokens 了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）128k 输出 token。输出长度翻倍，意味着 Claude 可以一次性生成更长的代码和文档，不用再拆成好几次请求了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）自适应思考。以前开发者只能手选开启或关闭深度推理，现在 Claude 会自动判断这个问题需不需要深度思考。简单问题秒回，复杂问题慢慢想，智能调节，省时省钱。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">5）上下文压缩。以前跑长任务的时候，AI 经常会撞到上下文长度的天花板。现在 Claude 能自动压缩和总结之前的对话内容，让长时间运行的任务不会中途翻车。搭配 100 万 token 上下文，不敢想象有多持久！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">6）Claude Code 支持多智能体协作。你可以同时启动多个 AI Agent 并行工作，比如让几个 Agent 同时审查代码库的不同部分，效率直接翻倍。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">7）Claude in Excel 大升级。现在能处理更复杂的长时间任务，支持数据透视表、图表修改、条件格式、数据验证等，还能一次性处理多步骤操作。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">8）Claude in PowerPoint 上线。能读取你已有的模板、字体和母版，保持品牌风格一致，然后直接帮你生成完整的 PPT。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">大家对 Opus 4.6 也是一致好评，不少早期测试的公司都表示 “用了回不去”，Cursor 官方说 Opus 4.6 是他们内部长任务测试中的最强模型，Replit 说它的任务拆解和并行规划能力有了巨大飞跃。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">GPT-5.3-Codex：OpenAI 的编程杀手锏</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">再看 OpenAI 这边。这次发布的 GPT-5.3-Codex，剑指 <span class=\"md-pair-s \"><strong>最强编程 Agent</strong><span class=\"md-plain\">，而且不只是写代码，还能像你的同事一样边干活边和你沟通。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">相比 Claude 官方连发好几个帖子介绍自家新模型，OpenAI 官方这边则低调不少。Sam Altman 亲自在 X 上喊话：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">来看看具体有什么：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）编程跑分全面领先。SWE-Bench Pro 57% 和 TerminalBench 2.0 77%，编程相关基准都创了新高。尤其是 OSWorld（测试 AI 在真实桌面环境中完成任务的能力）直接从上一代的 38.2% 飙到 64.7%，这个提升幅度相当炸裂。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）速度更快、更省钱。完成同样的任务，token 消耗量不到上一代（5.2-Codex）的一半，而且每个 token 处理速度还快了 25%。又快又省，这才是实实在在的体验提升。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）边干活边汇报。以前你丢一个任务给 AI，只能干等结果。现在 GPT-5.3-Codex 会在工作过程中实时告诉你它在做什么、做到哪了，你随时可以插嘴调整方向，就像真的在和一个同事协作一样。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）超强的前端开发能力。官方直接展示了让它做赛车游戏和潜水游戏的效果，完整度高得离谱，有多个地图、道具系统和完整的游戏逻辑。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">生成普通网页时 AI 也更懂你的意图了，默认就能给你做出功能更丰富、设计更合理的页面。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">5）电脑操作能力增强。不只是写代码，它还能像人一样操作电脑完成各种任务，比如做 PPT、分析数据、处理表格，把编程 Agent 的边界扩展到了全能打工 Agent。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">6）自己训练自己。OpenAI 团队说 GPT-5.3-Codex 是第一个 <span class=\"md-pair-s \"><strong>参与了自身创造</strong><span class=\"md-plain\"> 的模型。团队用它的早期版本来调试训练过程、管理部署、分析测试结果。也就是说，AI 在加速 AI 自身的进化，以后的进化速度肯定会越来越快。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">7）网络安全能力大幅增强。这是第一个被 OpenAI 归类为高能力网络安全模型的版本，能主动发现代码漏洞。OpenAI 同时承诺投入 1000 万美元 API 额度支持网络防御研究。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">我的看法</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这次两家巨头同时发布新模型，互相贴脸开大，对我们用户来说是好事。可以看到，这两个模型都在往 <span class=\"md-pair-s \"><strong>实用方向</strong><span class=\"md-plain\"> 猛卷，是真的想让你日常工作中用得上。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这两个大模型应该如何选择呢？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">简单对比一下：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Claude Opus 4.6 是六边形战士，编程、办公、研究样样行，特别是在 Excel、PowerPoint 这些办公场景里做了很深的整合。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">GPT-5.3-Codex 把编程能力拉满，在代码生成、任务执行和人机协作上打出了差异化优势。</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过我估计网络和价格就已经劝退一大波国内用户了，如果你只是日常学习、或者做做工具类小项目，也不必盲目追求国外的大模型。很快 DeepSeek V4 等一系列国产大模型应该就要出来了，期待一波~</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-meta-i-c md-link md-expand\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 10:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">180</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Linux内核中模块定义宏机制解析",
      "link": "https://www.cnblogs.com/ttkwzyttk/p/19582878",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ttkwzyttk/p/19582878\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 10:10\">\n    <span>Linux内核中模块定义宏机制解析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文解析了 Linux 内核中的 module driver helper macro，讲解了 module_platform_driver 的实现原理与设计思想，展示了宏如何通过 宏拼接、可变参数、__init/__exit 和 module_init/module_exit 自动生成驱动注册与注销模板，是内核驱动开发者掌握标准写法的实用指南。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在编写 Linux 设备驱动时，尤其是 platform、I2C、SPI 等总线驱动，我们经常会看到类似下面的写法：</p>\n<pre><code class=\"language-c\">module_platform_driver(my_driver);\n</code></pre>\n<p>这类宏看起来很“魔法”，但实际上它们只是 Linux 内核为了减少样板代码而提供的一种 <strong>driver helper macro</strong>，本文主要讲解这类宏的用法与机制</p>\n<h1 id=\"一传统模块初始化方式\">一、传统模块初始化方式</h1>\n<p>这里以platform驱动为例，传统的驱动写法通常是这样的：</p>\n<pre><code class=\"language-c\">static struct platform_driver my_platform_driver = {\n    .probe  = my_probe,\n    .remove = my_remove,\n    .driver = {\n        .name = \"my_driver\",\n    },\n};\n\nstatic int __init my_init(void)\n{\n    return platform_driver_register(&amp;my_platform_driver);\n}\n\nstatic void __exit my_exit(void)\n{\n    platform_driver_unregister(&amp;my_platform_driver);\n}\n\nmodule_init(my_init);\nmodule_exit(my_exit);\nMODULE_LICENSE(\"GPL\");\n</code></pre>\n<p>这是一个标准的驱动模板，有驱动的入口init函数与出口exit函数，并通过<code>module_init</code>和<code>module_exit</code>接口函数进行注册，这种写法的样板代码高度重复，几乎每一个platform驱动都是一模一样的，内核中存在大量这种固定模式的代码，非常适合使用宏来简化</p>\n<h1 id=\"二模块定义宏的引入\">二、模块定义宏的引入</h1>\n<p>为了解决上述问题，Linux 内核引入了一组 <strong>module driver helper macro</strong>，用于简化驱动的注册与注销过程。</p>\n<p>以platform驱动为例，内核提供了</p>\n<pre><code class=\"language-c\">module_platform_driver(...)\n</code></pre>\n<p>虽然接口看着像是函数，但是他是由宏来实现的，使用该宏之后，上面的代码就可以简化为：</p>\n<pre><code class=\"language-c\">static struct platform_driver my_platform_driver = {\n    .probe  = my_probe,\n    .remove = my_remove,\n    .driver = {\n        .name = \"my_driver\",\n    },\n};\n\nmodule_platform_driver(my_platform_driver);\nMODULE_LICENSE(\"GPL\");\n</code></pre>\n<p>可以看见，使用该宏之后，就不需要再手写<code>__init</code>和<code>__exit</code>注册与注销接口函数了，也不需要再显式调用<code>platform_driver_register</code>和<code>platform_driver_unregister</code>接口函数了，与传统写法完全相同</p>\n<p>当然这种写法不仅仅只有platform驱动有，内核为不同的总线都提供了对应的宏定义</p>\n<pre><code class=\"language-c\">module_i2c_driver(my_i2c_driver);\nmodule_spi_driver(my_spi_driver);\nmodule_usb_driver(my_usb_driver);\nmodule_pci_driver(my_pci_driver);\n.......\n</code></pre>\n<p>他们遵循完全相同的设计思想：一个模块，只注册一个驱动，用一行宏搞定</p>\n<h1 id=\"三本质解析\">三、本质解析</h1>\n<p>这里还是以platform驱动为例，<code>module_platform_driver</code> 是一个宏封装。我们可以打开内核源码<code>kernel/include/linux/platform_device.h</code>找到对应的宏，如果为其他总线驱动，需要到对应的头文件中查找，如下所示</p>\n<pre><code class=\"language-c\">/* module_platform_driver() - Helper macro for drivers that don't do\n* anything special in module init/exit. This eliminates a lot of\n* boilerplate. Each module may only use this macro once, and\n* calling it replaces module_init() and module_exit()\n*/\n\n#define module_platform_driver(__platform_driver) \\\nmodule_driver(__platform_driver, platform_driver_register, \\\nplatform_driver_unregister)\n</code></pre>\n<p>可以看见<code>module_platform_driver</code>宏中又使用了<code>module_driver</code>这个宏定义，这个宏定在<code>kernel/include/linux/device/driver.h</code>头文件中，定义代码如下</p>\n<pre><code class=\"language-c\">/**\n\n* module_driver() - Helper macro for drivers that don't do anything\n* special in module init/exit. This eliminates a lot of boilerplate.\n* Each module may only use this macro once, and calling it replaces\n* module_init() and module_exit().\n*\n* @__driver: driver name\n* @__register: register function for this driver type\n* @__unregister: unregister function for this driver type\n* @...: Additional arguments to be passed to __register and __unregister.\n*\n* Use this macro to construct bus specific macros for registering\n* drivers, and do not use it on its own.\n*/\n#define module_driver(__driver, __register, __unregister, ...) \\\nstatic int __init __driver##_init(void) \\\n{ \\\nreturn __register(&amp;(__driver) , ##__VA_ARGS__); \\\n} \\\nmodule_init(__driver##_init); \\\nstatic void __exit __driver##_exit(void) \\\n{ \\\n__unregister(&amp;(__driver) , ##__VA_ARGS__); \\\n} \\\n\nmodule_exit(__driver##_exit);\n</code></pre>\n<p>在<code>module_driver</code>宏中就可以看见对应的驱动注册与注销的模板了，这里主要就是通过宏拼接以及可变参数宏来实现，读者可以自行宏展开进行分析，所有的模块宏<code>platform</code>驱动、<code>pci</code>驱动、<code>usb</code>驱动等等，底层都是调用了<code>module_driver</code>进行宏替换与拼接组成最后的模块注册模板，这里就不再赘述了</p>\n<h1 id=\"四使用场景\">四、使用场景</h1>\n<p>在主线内核中，这种写法已经成为<strong>事实标准</strong>，原因主要有：</p>\n<ul>\n<li>*<strong>减少样板代码</strong></li>\n<li><strong>统一驱动风格</strong></li>\n<li><strong>降低出错概率</strong></li>\n<li><strong>代码审查更友好</strong></li>\n</ul>\n<p>对于维护者来说，一眼看到<code>module_platform_driver(xxx_driver);</code> 就能立刻知道这是一个“标准的 platform 模块驱动。</p>\n<p>虽然 helper macro 很方便，但并非所有场景都适合。不建议使用的情况包括：</p>\n<ul>\n<li>一个模块中注册 <strong>多个 driver</strong></li>\n<li>模块 init 阶段还需要做额外初始化工作，使用模块宏的话，它的底层只能调用对应的<code>register</code>和<code>unregister</code>函数无法做其他操作</li>\n<li>对初始化/退出顺序有精细控制需求</li>\n</ul>\n<p>在这些场景下，手写 <code>module_init</code> / <code>module_exit</code> 反而更清晰。所以需要具体情况具体分析</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 10:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ttkwzyttk\">ttkwzyttk</a>&nbsp;\n阅读(<span id=\"post_view_count\">6</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ClawdBot 出圈记：AI Agent 正在走向大众",
      "link": "https://www.cnblogs.com/bugshare/p/19582865",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/bugshare/p/19582865\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 10:08\">\n    <span>ClawdBot 出圈记：AI Agent 正在走向大众</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>国内外的社交平台上，无论你是否关注 AI，最近大概率都刷到过 <strong>ClawdBot / OpenClaw</strong>。短短几天时间，这个项目在 GitHub 上已经斩获了 <strong>13 万+ Star</strong>，堪称现象级开源项目。</p>\n<p>它不仅再次点燃了大众对 <strong>AI Agent</strong> 的热情，也让「让 AI 真正帮你干活」这件事，从极客玩具逐步走向普通用户。</p>\n<hr />\n<h1 id=\"简介\">简介</h1>\n<h2 id=\"创始人\">创始人</h2>\n<p>先来看看 ClawdBot（现名 <strong>OpenClaw</strong>）的创始人 <strong>Peter Steinberger</strong>。</p>\n<p>他是奥地利人，毕业于 <strong>维也纳科技大学</strong>，是一位典型的技术天才。</p>\n<p>在因为 OpenClaw 被更多人熟知之前，Peter 就已经是靠代码成功创业、实现 <strong>身家上亿欧元</strong>、提前退休的程序员了。这次出山，更像是一次「技术理想主义者」的回归。</p>\n<p><img alt=\"steipete.png\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"命名之旅一只龙虾的蜕变史\">命名之旅：一只龙虾的蜕变史</h2>\n<p>OpenClaw 的名字，并不是一开始就确定的，反而经历了一段颇有戏剧性的演化过程。</p>\n<h3 id=\"clawd\">Clawd</h3>\n<p><strong>Clawd</strong> 诞生于 <strong>2025 年 11 月</strong>。一切看似都很完美，直到 <strong>Anthropic 的法务团队</strong> 非常礼貌地联系了作者，请他「重新考虑一下这个名字」。</p>\n<p>原因嘛，大家懂的 😄</p>\n<h3 id=\"moltbot\">Moltbot</h3>\n<p>接下来诞生的是 <strong>Moltbot</strong>。</p>\n<p>这个名字是在 <strong>凌晨 5 点</strong>，作者和社区成员在 Discord 上进行了一场略显混乱的头脑风暴后敲定的。</p>\n<p>“Molt（蜕皮）”象征着成长——就像龙虾不断脱壳，最终变成更强大的个体。寓意非常美好，但问题也很明显：</p>\n<blockquote>\n<p>听起来有点拗口，不太好念。</p>\n</blockquote>\n<h3 id=\"openclaw最终形态\">OpenClaw（最终形态）</h3>\n<p>最终，项目正式更名为 <strong>OpenClaw</strong>。</p>\n<ul>\n<li>商标检索结果：✅ 安全</li>\n<li>域名：✅ 已购买</li>\n<li>代码迁移：✅ 已完成</li>\n</ul>\n<p>这个名字也恰如其分地概括了项目的现状：</p>\n<ul>\n<li><strong>Open</strong>：完全开源，对所有人开放，社区驱动</li>\n<li><strong>Claw</strong>：龙虾之爪，传承最初的精神象征</li>\n</ul>\n<hr />\n<h2 id=\"什么是-openclaw\">什么是 OpenClaw？</h2>\n<p>一句话概括：</p>\n<blockquote>\n<p><strong>OpenClaw 是一个运行在你自己电脑上的开源 AI Agent 平台。</strong></p>\n</blockquote>\n<p>它可以与你日常使用的各种聊天工具无缝集成：</p>\n<ul>\n<li>WhatsApp</li>\n<li>Telegram</li>\n<li>Discord</li>\n<li>Slack</li>\n<li>Microsoft Teams</li>\n</ul>\n<p>无论你身在何处，只要能发消息，就能随时指挥你的 AI 助手。</p>\n<p>官网：</p>\n<p>👉 <a href=\"https://openclaw.ai/\" rel=\"noopener nofollow\" target=\"_blank\">https://openclaw.ai/</a></p>\n<hr />\n<h1 id=\"安装quickstart\">安装（QuickStart）</h1>\n<p>下面是官方提供的快速上手流程，基本一路回车 + 选择即可完成。</p>\n<ol>\n<li>快速安装 <code>curl -fsSL https://openclaw.ai/install.sh | bash</code></li>\n<li>提示 <em>I understand this is powerful and inherently risky</em> → 选择 <strong>Yes</strong></li>\n<li>Onboarding mode → <strong>QuickStart</strong></li>\n<li>Model / auth provider → <strong>Z.AI (GLM 4.7)</strong></li>\n<li>输入 <strong>Z.AI API Key</strong></li>\n<li>Default model → 默认</li>\n<li>Select channel → <strong>WhatsApp (QR link)</strong></li>\n<li>WhatsApp phone setup → <strong>This is my personal phone number</strong></li>\n<li>输入你的 <strong>WhatsApp 注册手机号</strong></li>\n<li>Configure skills now? → <strong>Yes</strong></li>\n<li>Node manager → <strong>npm</strong></li>\n<li>Install missing skill dependencies → <strong>Skip for now</strong></li>\n<li>GOOGLE_PLACES_API_KEY → <strong>No</strong></li>\n<li>Enable hooks → <strong>Skip for now</strong></li>\n<li>Hatch your bot → <strong>Hatch in TUI (recommended)</strong></li>\n</ol>\n<p><img alt=\"PixPin_2026-02-01_22-35-27.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"openclaw-能做什么\">OpenClaw 能做什么？</h1>\n<p>你可以把 OpenClaw 理解为：</p>\n<blockquote>\n<p><strong>一个 24 小时在线、可长期运行、能记住你习惯的「数字员工」。</strong></p>\n</blockquote>\n<p>它不仅能一次性完成任务，还可以：</p>\n<ul>\n<li>持续执行</li>\n<li>定时触发</li>\n<li>记住你的偏好</li>\n<li>通过手机聊天远程操控你的电脑</li>\n</ul>\n<h3 id=\"一些真实使用场景\">一些真实使用场景</h3>\n<ol>\n<li>\n<p><strong>信息收集与简报</strong></p>\n<blockquote>\n<p>“查一下 GitHub 今日热榜，整理成简报，每天早上 8 点发给我。”</p>\n</blockquote>\n</li>\n<li>\n<p><strong>自动化下载</strong></p>\n<blockquote>\n<p>“去某学习网站，帮我下载一套 Python 教学视频。”</p>\n</blockquote>\n</li>\n<li>\n<p><strong>抢票 / 抢资源</strong><br />\n有网友分享：通过 OpenClaw 成功抢到了高铁票（是否成功取决于运气 + 网络环境）。</p>\n</li>\n<li>\n<p><strong>浏览器与系统操作</strong><br />\n自动操作网页、表单填写、数据整理，真正做到「替你点鼠标」。</p>\n</li>\n</ol>\n<p><img alt=\"PixPin_2026-02-01_22-50-44.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"不可忽视的弊端\">不可忽视的弊端</h1>\n<p>在惊艳之外，OpenClaw 也并非没有成本。</p>\n<ol>\n<li>\n<p><strong>Token 消耗极大</strong><br />\n如果你用的是按量付费模型，真的会“烧钱”，建议先小规模尝试。</p>\n</li>\n<li>\n<p><strong>权限要求非常高</strong><br />\n它几乎等同于“把电脑交给 AI”，</p>\n<blockquote>\n<p>理论上，它<strong>确实有能力清空你的文件</strong>。</p>\n</blockquote>\n<p>所以：</p>\n<ul>\n<li>不要在主力生产环境直接使用</li>\n<li>不要授予不必要的权限</li>\n</ul>\n</li>\n<li>\n<p><strong>国内网络环境有门槛</strong><br />\n需要你具备一定的「KeXue上网」能力，否则体验会大打折扣。</p>\n</li>\n</ol>\n<hr />\n<h1 id=\"如何卸载-openclaw\">如何卸载 OpenClaw</h1>\n<p>如果你只是尝鲜，或者不打算继续使用，可以按下面步骤完整卸载。</p>\n<pre><code class=\"language-bash\">openclaw uninstall\n# 空格+箭头选择全部\n</code></pre>\n<p><img alt=\"PixPin_2026-02-02_09-23-18.png\" class=\"lazyload\" /></p>\n<pre><code class=\"language-bash\"># 定位安装路径\nwhich openclaw\n\n# 全局卸载\nnpm uninstall -g openclaw\n# 或\npnpm remove -g openclaw\n\n# 清理配置和缓存\nrm -rf ~/.openclaw\nrm -rf ~/.config/openclaw\nrm -rf ~/.cache/openclaw\n\n# /Users/用户名/.zshrc 里的openclaw删除下\n</code></pre>\n<hr />\n<h2 id=\"写在最后\">写在最后</h2>\n<p>OpenClaw 的爆火，并不只是又一个“好玩的 AI 项目”，而是一个非常清晰的信号：</p>\n<blockquote>\n<p><strong>AI Agent 正在从实验室，走向普通人的真实生活。</strong></p>\n</blockquote>\n<p>它或许还不完美，甚至有点危险，但毫无疑问——</p>\n<p><strong>未来，越来越多的工作，真的会交给 AI 来完成。</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 10:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/bugshare\">BugShare</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "QT快速开发框架",
      "link": "https://www.cnblogs.com/tlink/p/19582758",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tlink/p/19582758\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 09:49\">\n    <span>QT快速开发框架</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Qt Qt开发CMake\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"qtmachinedog告别重复造轮子qt-快速开发脚手架\">QtMachineDog：告别重复造轮子，Qt 快速开发脚手架</h1>\n<p><strong>\"不管多小的 Qt 项目，总有一堆琐碎但必要的事情要做。\"</strong></p>\n<p>作为一个 Qt 开发者，你是否经历过：</p>\n<ul>\n<li>每次新建项目都要重写一遍日志系统？</li>\n<li>程序崩溃后用户说\"不知道发生了什么\"，而你根本拿不到堆栈？</li>\n<li>配置文件散落在各处，版本升级后配置丢失？</li>\n<li>HTTP 请求封装写了无数次，每次都要重新解析 JSON？</li>\n<li>简单的数据 CRUD 操作，却要重写大量样板代码？</li>\n</ul>\n<p>这些问题<strong>和具体业务无关</strong>，却<strong>每个项目都要面对</strong>。这就是我做 <strong>QtMachineDog</strong> 的原因——<strong>把通用的事一次做好，让开发者专注于业务逻辑</strong>。</p>\n<p>开源地址：<a href=\"https://gitee.com/Tlink/machine\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/Tlink/machine</a></p>\n<hr />\n<h2 id=\"简单介绍\">简单介绍</h2>\n<p><strong>QtMachineDog</strong> 是一个基于 <strong>CMake</strong> 的 Qt 快速开发框架/脚手架。它不是试图替代 Qt，而是填补\"项目初始化\"到\"业务开发\"之间的空白——<strong>你不再需要为每个项目复制粘贴基础设施代码</strong>。</p>\n<p>核心定位：<strong>开箱即用的项目骨架，而非重量级业务框架</strong></p>\n<hr />\n<h2 id=\"功能亮点即拿即用\">功能亮点（即拿即用）</h2>\n<table>\n<thead>\n<tr>\n<th>功能模块</th>\n<th>解决的问题</th>\n<th>亮点特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>📜 日志系统</strong></td>\n<td>告别 qDebug() 满天飞</td>\n<td>分级日志、文件轮转、多线程安全</td>\n</tr>\n<tr>\n<td><strong>💥 全局异常处理</strong></td>\n<td>崩溃无迹可寻</td>\n<td>自动捕获崩溃信号，生成完整堆栈日志，<strong>再也不怕用户说\"程序突然没了\"</strong></td>\n</tr>\n<tr>\n<td><strong>⚙️ 配置中心</strong></td>\n<td>配置管理混乱</td>\n<td>全局统一的配置文件管理，支持版本兼容、自动备份</td>\n</tr>\n<tr>\n<td><strong>💾 持久化数据</strong></td>\n<td>数据存储重复造轮子</td>\n<td>封装好的本地存储方案，业务层直接调用</td>\n</tr>\n<tr>\n<td><strong>🌐 HTTP 模块</strong></td>\n<td>网络请求代码冗余</td>\n<td>基于现代 Qt 网络栈的请求封装，自动 JSON 解析、错误处理、超时重试</td>\n</tr>\n<tr>\n<td><strong>🗃️ 数据 CRUD 模板</strong></td>\n<td>每次都要写增删改查</td>\n<td><strong>可复制的业务模板</strong>，复制粘贴即可用于新模块，遵循统一设计模式</td>\n</tr>\n<tr>\n<td><strong>🏷️ 版本管理</strong></td>\n<td>版本号混乱、自动更新困难</td>\n<td>语义化版本管理，内置更新检查接口</td>\n</tr>\n<tr>\n<td><strong>🖥️ Self-Host Web 服务</strong></td>\n<td>需要内嵌 HTTP 服务</td>\n<td>内置轻量级 Web Server，可用于本地 API 或监控面板</td>\n</tr>\n<tr>\n<td><strong>🎨 FontAwesome 集成</strong></td>\n<td>图标资源管理麻烦</td>\n<td>内置 FontAwesome，支持<strong>动态颜色/大小控制</strong>，无需准备多套图标资源</td>\n</tr>\n<tr>\n<td><strong>🔗 动态库管理</strong></td>\n<td>DLL/SO 加载繁琐</td>\n<td>统一的动态链接库加载、热插拔支持</td>\n</tr>\n<tr>\n<td><strong>🔧 CMake 现代化</strong></td>\n<td>跨平台构建头疼</td>\n<td>全 CMake 构建，支持 Windows/Linux/macOS，第三方依赖自动拉取</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"-谁需要这个项目\">💡 谁需要这个项目？</h2>\n<p>✅ <strong>个人开发者</strong>：快速启动 Side Project，不用每次都配基础设施<br />\n✅ <strong>小团队</strong>：统一项目结构，新人上手成本降低 80%<br />\n✅ <strong>企业项目</strong>：作为基础脚手架，确保所有项目有统一的日志、崩溃收集标准、快速开发示例<br />\n✅ <strong>学习者</strong>：通过实战代码学习 Qt 工程化最佳实践（异常处理、CMake 模块化等）</p>\n<hr />\n<p>项目结构遵循<strong>模块化设计</strong>，你可以：</p>\n<ul>\n<li><strong>全量使用</strong>：作为完整脚手架启动新项目</li>\n<li><strong>按需摘取</strong>：只拷贝你需要的模块（如只拿 Crash Handler 和 Logger）到现有项目</li>\n</ul>\n<hr />\n<h2 id=\"-几个值得单独说的亮点\">🔍 几个值得单独说的亮点</h2>\n<h3 id=\"1-崩溃处理让玄学-bug现形\">1. 崩溃处理：让\"玄学 Bug\"现形</h3>\n<p><img alt=\"异常捕获\" class=\"lazyload\" /></p>\n<pre><code class=\"language-cpp\">void ExceptionHandler::setup()\n{\n    try {\n        spdlog::info(\"Setting up exception handlers...\");\n\n        // 1. 设置 C++ 异常处理\n        originalTerminateHandler = std::get_terminate();\n        std::set_terminate(&amp;ExceptionHandler::terminateHandler);\n\n        // 2. 设置 Qt 消息处理\n        originalQtMessageHandler = qInstallMessageHandler(&amp;ExceptionHandler::qtMessageHandler);\n\n        // 3. 设置信号处理 - 关键：捕获段错误等\n        std::signal(SIGSEGV, ExceptionHandler::signalHandler);  // 段错误\n        std::signal(SIGABRT, ExceptionHandler::signalHandler);  // abort()\n        std::signal(SIGFPE,  ExceptionHandler::signalHandler);  // 浮点异常\n        std::signal(SIGILL,  ExceptionHandler::signalHandler);  // 非法指令\n\n        // 注意：不要捕获 SIGTERM 和 SIGINT，让程序可以正常退出\n        // std::signal(SIGTERM, ExceptionHandler::signalHandler);  // 终止信号\n        // std::signal(SIGINT,  ExceptionHandler::signalHandler);   // Ctrl+C\n\n        spdlog::info(\"Exception handlers installed successfully\");\n\n    } catch (const std::exception&amp; e) {\n        spdlog::error(\"Failed to install exception handlers: {}\", e.what());\n    }\n}\n</code></pre>\n<h3 id=\"2-fontawesome字体图标选择与使用\">2. fontawesome字体图标选择与使用</h3>\n<p><img alt=\"图标选择\" class=\"lazyload\" /></p>\n<pre><code class=\"language-cpp\">\n    ui-&gt;btnErrorTest-&gt;setIcon(FontManager::ins().icon(0xf06a, {24,24}, QColor(200,0,0)));\n    ui-&gt;btnIconChoose-&gt;setIcon(FontManager::ins().icon(0xf2b4, {24,24}, QColor(0,0,255)));\n    ui-&gt;btnConfigLoad-&gt;setIcon(FontManager::ins().icon(0xf1de, {24,24}, QColor(\"#228B22\")));\n    ui-&gt;btnMylib-&gt;setIcon(FontManager::ins().icon(0xf0e7, {24,24}, QColor(255,0,0)));\n\n</code></pre>\n<p><img alt=\"ScreenShot_2026-02-06_093231_592\" class=\"lazyload\" /></p>\n<h3 id=\"3-crud-模板业务开发的复制粘贴神器本程序使用的数据库为sqlite\">3. CRUD 模板：业务开发的复制粘贴神器（本程序使用的数据库为sqlite）</h3>\n<p>项目提供了一套基于 Qt Model/View 的通用数据操作模板，<strong>开发新模块时，复制模板文件夹，改改类名就能用</strong>，包含：</p>\n<ul>\n<li>数据模型定义</li>\n<li>数据库操作接口</li>\n<li>视图绑定逻辑</li>\n<li>基础的增删改查 UI</li>\n</ul>\n<p><img alt=\"数据增删查改\" class=\"lazyload\" /></p>\n<p><img alt=\"数据增删查改2\" class=\"lazyload\" /></p>\n<pre><code>void UserDao::initTable()\n{\n    QSqlQuery q(DbManager::instance().db());\n    q.exec(\"CREATE TABLE IF NOT EXISTS user(\"\n           \"id   INTEGER PRIMARY KEY AUTOINCREMENT,\"\n           \"name TEXT NOT NULL,\"\n           \"username TEXT NOT NULL,\"\n           \"email TEXT NULL,\"\n           \"pwd TEXT NULL,\"\n           \"picpath TEXT NULL,\"\n           \"status  TEXT NOT NULL,\"\n           \"registertime TEXT NULL,\"\n           \"lastlogintime TEXT NULL,\"\n           \"phonenum TEXT NULL,\"\n           \"notes TEXT NULL,\"\n           \"age  INTEGER,\"\n           \"roles INTEGER,\"\n           \"gender INTEGER)\");\n\n}\n\nint UserDao::addUser(const User &amp;user)\n{\n    QSqlQuery q(DbManager::instance().db());\n    q.prepare(\"INSERT INTO user(name,username,email,picpath,status,registertime,lastlogintime,phonenum,age,roles,gender,pwd,notes) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)\");\n    q.addBindValue(user.name);\n    q.addBindValue(user.username);\n    q.addBindValue(user.email);\n    q.addBindValue(user.picpath);\n    q.addBindValue(user.status);\n    q.addBindValue(user.registertime);\n    q.addBindValue(user.lastlogintime);\n    q.addBindValue(user.phonenum);\n    q.addBindValue(user.age);\n    q.addBindValue(user.roles);\n    q.addBindValue(user.gender);\n    q.addBindValue(user.pwd);\n    q.addBindValue(user.notes);\n    if (!q.exec()) {\n        qWarning() &lt;&lt; \"insert user error:\" &lt;&lt; q.lastError().text();\n       // spdlog::error(\"insert user error:\"+ q.lastError().text().toStdString());\n        return -1;\n    }\n    return q.lastInsertId().toInt();\n}\n\nbool UserDao::deleteUser(int id)\n{\n    QSqlQuery q(DbManager::instance().db());\n    q.prepare(\"DELETE FROM user WHERE id=?\");\n    q.addBindValue(id);\n    return q.exec();\n}\nbool UserDao::updateUser(const User &amp;user)\n{\n    if (user.id &lt;= 0) return false;\n    QSqlQuery q(DbManager::instance().db());\n    q.prepare(\"UPDATE user SET name=?,username=?,email=?,picpath=?,status=?,registertime=?,lastlogintime=?,phonenum=?,age=?,roles=?,gender=?,pwd=?,notes=? WHERE id=?\");\n    q.addBindValue(user.name);\n    q.addBindValue(user.username);\n    q.addBindValue(user.email);\n    q.addBindValue(user.picpath);\n    q.addBindValue(user.status);\n    q.addBindValue(user.registertime);\n    q.addBindValue(user.lastlogintime);\n    q.addBindValue(user.phonenum);\n    q.addBindValue(user.age);\n    q.addBindValue(user.roles);\n    q.addBindValue(user.gender);\n    q.addBindValue(user.pwd);\n    q.addBindValue(user.notes);\n    q.addBindValue(user.id);\n    return q.exec();\n}\n</code></pre>\n<h3 id=\"4-selfhost-web服务-可内嵌-http-服务--内置轻量级-web-server可用于本地-api-或监控面板\">4. SelfHost Web服务-可内嵌 HTTP 服务 | 内置轻量级 Web Server，可用于本地 API 或监控面板</h3>\n<h2 id=\"_\"><img alt=\"selfhost_web\" class=\"lazyload\" /></h2>\n<h2 id=\"-写在最后\">💬 写在最后</h2>\n<p>QtMachineDog 不是一个大而全的框架，而是一个<strong>务实的解决方案</strong>——解决那些<strong>每个 Qt 项目都会遇到、却没有人系统整理过</strong>的问题。</p>\n<p>如果你也曾为\"又要重写日志系统\"而烦恼，不妨试试这个框架。<strong>把重复的事情交给 MachineDog，你专心做独一无二的功能。</strong></p>\n<hr />\n<h2 id=\"下一步集成aspnet-core发布后的selfhost\">🔧下一步集成asp.net core发布后的selfhost</h2>\n<p>使用SignalR，通过api来接受设备的实时状态，并轻量的web输出到网络<br />\nasp.net core相关的处理数据api demo<br />\n既保证了工业设备的稳重（桌面程序），又能使数据流动变得轻盈（web程序）</p>\n<h2 id=\"如果对你有帮助有启发请帮忙转发点赞star您的支持是我的最大动力\">如果对你有帮助有启发，请帮忙转发点赞，star，您的支持是我的最大动力</h2>\n<p>开源地址：<a href=\"https://gitee.com/Tlink/machine\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/Tlink/machine</a></p>\n<p><strong>#Qt #Qt开发 #CMake #开源项目 #C++ #跨平台开发</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 09:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tlink\">Tlink</a>&nbsp;\n阅读(<span id=\"post_view_count\">108</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI实战：用懒加载与Lifespan优雅管理重型依赖",
      "link": "https://www.cnblogs.com/ymtianyu/p/19582659",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19582659\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 09:28\">\n    <span>FastAPI实战：用懒加载与Lifespan优雅管理重型依赖</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文针对FastAPI应用在部署文生图等大模型时遇到的启动慢、资源占用高问题，深入剖析了应用启动（冷启动）与请求处理（热路径）的区别。核心介绍了利用懒加载模式与Lifespan事件管理上下文，将耗时的初始化操作从启动迁移到首次请求时或进行异步预热，从而实现服务的快速启动与高效资源利用，并提供了详细的代码示例与避坑指南。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2>你的FastAPI服务，是不是也在启动时\"负重跑步\"？</h2>\n<p>有没有遇到过这种场景：你兴冲冲地写完了一个文生图AI服务的接口，本地测试美滋滋。结果一上服务器，<code style=\"color: rgba(186, 55, 42, 1);\">docker build</code> 完，<code style=\"color: rgba(186, 55, 42, 1);\">docker run</code> 的那一瞬间，你感觉仿佛过了一个世纪——服务怎么还没起来？</p>\n<p>然后看日志，好家伙，卡在<code style=\"color: rgba(186, 55, 42, 1);\">Loading model...</code> 这一步了。模型好几个G，加载慢如牛。更糟的是，你的K8s健康检查可能因为启动超时，反复杀掉了还在\"热身\"的Pod，导致服务永远无法就绪🎯。</p>\n<p>今天，咱们就聊聊怎么给FastAPI服务\"减负\"，让启动飞快，同时又能优雅地管理那些\"重型武器\"（比如大模型、大数据连接）。核心就俩概念：<strong style=\"color: rgba(186, 55, 42, 1);\">懒加载</strong>和<strong style=\"color: rgba(186, 55, 42, 1);\">Lifespan事件</strong>。</p>\n<hr />\n<h2>🎯 先搞清问题：启动 vs 运行时</h2>\n<p>咱们得先分清两个阶段，这就像餐厅开业：</p>\n<div>\n<p>🔥 <strong>冷启动（应用启动）</strong>：相当于餐厅第一天开业。你不能让客人在门口等厨师把所有菜都做一遍尝过才开门。我们的目标是<strong style=\"color: rgba(186, 55, 42, 1);\">越快开门越好</strong>。</p>\n<p>🍳 <strong>热路径（请求处理）</strong>：客人点单后，后厨开始炒菜。这时候追求的是单道菜的出菜速度和质量。</p>\n</div>\n<p>很多兄弟（包括当初的我）会把加载模型这种\"备菜\"工作，直接扔在全局变量里，在应用启动时执行。结果就是\"开业\"仪式巨长无比。</p>\n<p>你可能会问：\"那我不用的时候不加载，用的时候再加载，不就行了？\"</p>\n<p>Bingo！这就是<strong style=\"color: rgba(186, 55, 42, 1);\">懒加载（Lazy Loading）</strong>的核心思想：把耗时初始化推迟到第一次真正需要它的时候。但在Web服务里，怎么优雅地实现它，并且管理它的生命周期呢？这就轮到<code style=\"color: rgba(186, 55, 42, 1);\">lifespan</code>出场了。</p>\n<h2>🤖 核心武器：Lifespan 事件管理器</h2>\n<p>在FastAPI（实际上是背后的Starlette）中，<code style=\"color: rgba(186, 55, 42, 1);\">lifespan</code> 是一个上下文管理器，它让你能精确控制应用<strong style=\"color: rgba(186, 55, 42, 1);\">启动前</strong>和<strong style=\"color: rgba(186, 55, 42, 1);\">关闭后</strong>该做什么。</p>\n<p>官方文档可能讲得有点抽象，我打个比方：它就像是你服务的\"私人管家\"。服务上线前（<code style=\"color: rgba(186, 55, 42, 1);\">startup</code>），管家帮你预热游泳池、打开花园灯；服务下线时（<code style=\"color: rgba(186, 55, 42, 1);\">shutdown</code>），管家帮你关灯、放掉泳池水，收拾得干干净净。</p>\n<p>重点来了：这个\"管家\"出现的时间点，比你所有接口的<code style=\"color: rgba(186, 55, 42, 1);\">dependencies</code>都要早！这意味着你可以在<code style=\"color: rgba(186, 55, 42, 1);\">lifespan</code>里准备好一些\"工厂\"或者\"连接池\"，但<strong style=\"color: rgba(186, 55, 42, 1);\">不一定非要立刻加载所有重型资源</strong>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nimport asyncio\n\n# 这是一个假的\"重型模型\"\nclass HeavyModel:\n    def __init__(self):\n        self.loaded = False\n    \n    async def load(self):\n        print(\"开始加载模型...这可能需要很久\")\n        await asyncio.sleep(5) # 模拟加载耗时\n        self.loaded = True\n        print(\"模型加载完毕！\")\n    \n    async def predict(self, text: str):\n        if not self.loaded:\n            await self.load() # 懒加载发生在这里！\n        return f\"预测结果 for: {text}\"\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup: 这里我们只初始化\"模型容器\"，但不加载模型本身\n    print(\"应用启动中...\")\n    model_container = {\"model\": HeavyModel()}\n    app.state.model = model_container[\"model\"]\n    \n    yield model_container # 这里的model_container会注入到请求的`app.state`中\n    \n    # Shutdown: 清理工作，比如关闭模型、释放GPU内存等\n    print(\"应用关闭中，执行清理...\")\n    app.state.model = None\n\napp = FastAPI(lifespan=lifespan)\n\n@app.get(\"/generate\")\nasync def generate(prompt: str):\n    # 首次请求时，才会真正触发模型加载\n    result = await app.state.model.predict(prompt)\n    return {\"result\": result}</code></pre>\n<p>看上面代码，<code style=\"color: rgba(186, 55, 42, 1);\">HeavyModel</code>在<code style=\"color: rgba(186, 55, 42, 1);\">lifespan</code>的启动阶段只是被<strong style=\"color: rgba(186, 55, 42, 1);\">实例化</strong>了，并没有调用耗时的<code style=\"color: rgba(186, 55, 42, 1);\">load()</code>方法。真正的加载发生在第一个请求调用<code style=\"color: rgba(186, 55, 42, 1);\">predict</code>时。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">这样做的好处是什么？</strong></p>\n<div>\n<p>1️⃣ <strong>启动速度飞起</strong>：你的服务几乎可以秒级就绪，通过健康检查。</p>\n<p>2️⃣ <strong>资源按需使用</strong>：如果某个Pod一直没收到相关请求，模型就永远不会加载，节省了宝贵的GPU内存。</p>\n<p>3️⃣ <strong>生命周期可控</strong>：你依然在<code style=\"color: rgba(186, 55, 42, 1);\">lifespan</code>的掌控之中，可以在关闭时优雅地释放资源。</p>\n</div>\n<h2>⚠️ 但是！小心这个\"天坑\"</h2>\n<p>懒加载虽好，但直接用在生产环境，可能会让第一个用户成为\"大冤种\"。想象一下，用户第一次请求，要白屏等待模型加载的几十秒，体验极差，而且这个请求很可能超时。</p>\n<p>所以，更优的生产级实践是：<strong style=\"color: rgba(186, 55, 42, 1);\">懒加载 + 异步预热</strong>。</p>\n<p>我们可以在<code style=\"color: rgba(186, 55, 42, 1);\">lifespan</code>启动完成后，<strong style=\"color: rgba(186, 55, 42, 1);\">悄悄地、异步地</strong>开始加载模型，而不是阻塞启动过程。</p>\n<pre class=\"language-python highlighter-hljs\"><code>@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    print(\"应用启动中...\")\n    model = HeavyModel()\n    app.state.model = model\n\n    # **关键技巧：创建一个后台任务异步预热**\n    async def _warm_up():\n        try:\n            await model.load()\n            print(\"模型预热完成！\")\n        except Exception as e:\n            print(f\"模型预热失败: {e}\")\n\n    # 不await，让它后台运行\n    asyncio.create_task(_warm_up())\n\n    yield\n    # Shutdown\n    print(\"应用关闭中...\")</code></pre>\n<p>这样，服务能立刻启动并响应健康检查。模型在后台默默加载，加载完成后才真正提供预测服务。对于加载期间的请求，你可以根据业务决定是返回一个\"服务预热中\"的友好提示，还是用队列让其等待。</p>\n<h2>🔧 更工程化的封装与注意事项</h2>\n<p>在实际项目中，我们不会把逻辑全写<code style=\"color: rgba(186, 55, 42, 1);\">lifespan</code>主函数里。我的习惯是封装一个<code style=\"color: rgba(186, 55, 42, 1);\">ModelManager</code>单例类，来统一管理加载状态、重试和并发安全。</p>\n<p>再说几个容易翻车的点：</p>\n<div>\n<p>🎯 <strong>并发请求时的重复加载</strong>：如果第一个请求A触发加载没完，请求B又来了，要确保不会初始化两个模型实例把内存撑爆。记得用锁（<code style=\"color: rgba(186, 55, 42, 1);\">asyncio.Lock</code>）或者检查状态变量。</p>\n<p>🎯 <strong>健康检查的设计</strong>：你的<code style=\"color: rgba(186, 55, 42, 1);\">/health</code>端点应该反映服务的真实状态。可以设计成：<code style=\"color: rgba(186, 55, 42, 1);\">{\"status\": \"warming_up\"}</code>，<code style=\"color: rgba(186, 55, 42, 1);\">{\"status\": \"ready\"}</code>。这样K8s的<code style=\"color: rgba(186, 55, 42, 1);\">readinessProbe</code>可以在模型就绪后才导入流量。</p>\n<p>🎯 <strong>关闭时的优雅终止</strong>：如果模型正在推理，直接关闭可能会导致GPU内存泄漏或数据错误。在<code style=\"color: rgba(186, 55, 42, 1);\">lifespan</code>的<span style=\"color: rgba(186, 55, 42, 1);\"><code>shutdown</code></span>阶段，最好设置一个标志位，让正在处理的请求完成，并拒绝新请求。</p>\n</div>\n<hr />\n<h3>最后啰嗦一句</h3>\n<p>技术选型没有银弹，懒加载和预热策略也要根据你的具体场景权衡。如果你的服务要求百分百确定性（比如金融风控），可能就需要在启动时忍受加载耗时，确保服务完全就绪。但对于大多数AI模型服务、推荐系统，<strong style=\"color: rgba(186, 55, 42, 1);\">\"快速启动，异步预热\"</strong>绝对是提升部署体验和资源效率的神器。</p>\n<p>希望这篇分享，能让你下次部署\"大家伙\"时，不再手忙脚乱。毕竟，谁不想让自己的服务既跑得快，又省资源呢？</p>\n<p>如果觉得有用，别忘了收藏一下，说不定下次部署前就得翻出来看看。你在部署重型服务时还踩过哪些坑？欢迎在评论区聊聊，咱们一起避坑！</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 09:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">一名程序媛呀</a>&nbsp;\n阅读(<span id=\"post_view_count\">16</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "概念解析：机器视觉如何赋予机器“三维双眼”——3D重建技术全景指南",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19582574",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19582574\" id=\"cb_post_title_url\" title=\"å‘å¸ƒäºŽ 2026-02-06 09:04\">\n    <span>æ¦‚å¿µè§£æžï¼šæœºå™¨è§†è§‰å¦‚ä½•èµ‹äºˆæœºå™¨â€œä¸‰ç»´åŒçœ¼â€â€”â€”3Dé‡å»ºæŠ€æœ¯å…¨æ™¯æŒ‡å—</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        åœ¨äººå·¥æ™ºèƒ½çš„æµªæ½®ä¸­ï¼Œå¦‚æžœè¯´ä¼ ç»Ÿçš„2Då›¾åƒè¯†åˆ«æ˜¯è®©æœºå™¨â€œè®¤å‡ºâ€ç‰©ä½“ï¼Œé‚£ä¹ˆ**3Dé‡å»ºï¼ˆ3D Reconstructionï¼‰**åˆ™æ˜¯è®©æœºå™¨çœŸæ­£â€œç†è§£â€ç‰©ç†ä¸–ç•Œã€‚é€šè¿‡æœºå™¨è§†è§‰å®žçŽ°3Dé‡å»ºï¼Œæ˜¯èµ‹äºˆæœºå™¨äººã€æ— äººæœºå’Œè‡ªåŠ¨é©¾é©¶æ±½è½¦ç©ºé—´æ„ŸçŸ¥èƒ½åŠ›çš„æ ¸å¿ƒæŠ€æœ¯ã€‚\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<hr />\n<p>@</p><div class=\"toc\"><div class=\"toc-container-header\">ç›®å½•</div><ul><li><a href=\"#å‰è¨€\" rel=\"noopener nofollow\">å‰è¨€</a></li><li><a href=\"#1-ä»€ä¹ˆæ˜¯é€šè¿‡æœºå™¨è§†è§‰å®žçŽ°3dé‡å»º\" rel=\"noopener nofollow\">1. ä»€ä¹ˆæ˜¯é€šè¿‡æœºå™¨è§†è§‰å®žçŽ°3Dé‡å»ºï¼Ÿ</a><ul><li><a href=\"#å®šä¹‰\" rel=\"noopener nofollow\">å®šä¹‰</a></li><li><a href=\"#æ ¸å¿ƒæœ¬è´¨ä»Ž2dåˆ°3dçš„é€†å‘æŠ•å½±\" rel=\"noopener nofollow\">æ ¸å¿ƒæœ¬è´¨ï¼šä»Ž2Dåˆ°3Dçš„é€†å‘æŠ•å½±</a></li><li><a href=\"#å…³é”®æ¦‚å¿µ\" rel=\"noopener nofollow\">å…³é”®æ¦‚å¿µ</a></li></ul></li><li><a href=\"#2-æ•ˆæžœæ¼”ç¤º3dé‡å»ºçš„è¿‡ç¨‹\" rel=\"noopener nofollow\">2. æ•ˆæžœæ¼”ç¤ºï¼š3Dé‡å»ºçš„è¿‡ç¨‹</a></li><li><a href=\"#3-ç›®å‰çš„ä¸»æµæ–¹æ³•\" rel=\"noopener nofollow\">3. ç›®å‰çš„ä¸»æµæ–¹æ³•</a><ul><li><a href=\"#ä¸€è¢«åŠ¨è§†è§‰passive-vision-ä»…ä¾èµ–çŽ¯å¢ƒå…‰\" rel=\"noopener nofollow\">ä¸€ã€è¢«åŠ¨è§†è§‰ï¼ˆPassive Visionï¼‰â€”â€” ä»…ä¾èµ–çŽ¯å¢ƒå…‰</a><ul><li><a href=\"#a--å•ç›®é‡å»ºmonocular-reconstruction\" rel=\"noopener nofollow\">A.  å•ç›®é‡å»ºï¼ˆMonocular Reconstructionï¼‰ï¼š</a><ul><li><a href=\"#ä»€ä¹ˆæ˜¯-sfmstructure-from-motion\" rel=\"noopener nofollow\">ä»€ä¹ˆæ˜¯ SfMï¼ˆStructure from Motionï¼‰ï¼Ÿ</a></li><li><a href=\"#sfm-çš„å…¨æµç¨‹æžç®€æ­¥éª¤ç‰ˆ\" rel=\"noopener nofollow\">SfM çš„å…¨æµç¨‹ï¼ˆæžç®€æ­¥éª¤ç‰ˆï¼‰</a></li><li><a href=\"#1-ç‰¹å¾æå–ä¸ŽåŒ¹é…-feature-extraction--matching\" rel=\"noopener nofollow\">1. ç‰¹å¾æå–ä¸ŽåŒ¹é… (Feature Extraction &amp; Matching)</a></li><li><a href=\"#2-è®¡ç®—å‡ ä½•å…³ç³»-estimating-epipolar-geometry\" rel=\"noopener nofollow\">2. è®¡ç®—å‡ ä½•å…³ç³» (Estimating Epipolar Geometry)</a></li><li><a href=\"#3-ä¸‰è§’æµ‹é‡-triangulation\" rel=\"noopener nofollow\">3. ä¸‰è§’æµ‹é‡ (Triangulation)</a></li><li><a href=\"#4-å¢žé‡å¼é‡å»º-incremental-reconstruction\" rel=\"noopener nofollow\">4. å¢žé‡å¼é‡å»º (Incremental Reconstruction)</a></li><li><a href=\"#5-å…¨å±€ä¼˜åŒ–å…‰æŸæ³•å¹³å·®-bundle-adjustment-ba\" rel=\"noopener nofollow\">5. å…¨å±€ä¼˜åŒ–ï¼šå…‰æŸæ³•å¹³å·® (Bundle Adjustment, BA)</a></li><li><a href=\"#ä¸ºä»€ä¹ˆå•ç›®-sfm-æ— æ³•æ„ŸçŸ¥ç»å¯¹å°ºåº¦\" rel=\"noopener nofollow\">ä¸ºä»€ä¹ˆå•ç›® SfM æ— æ³•æ„ŸçŸ¥â€œç»å¯¹å°ºåº¦â€ï¼Ÿ</a></li><li><a href=\"#sfm-çš„ä¸¤ç§ä¸»æµæµæ´¾\" rel=\"noopener nofollow\">SfM çš„ä¸¤ç§ä¸»æµæµæ´¾</a></li><li><a href=\"#å‚è€ƒæ–‡ä»¶\" rel=\"noopener nofollow\">å‚è€ƒæ–‡ä»¶</a></li></ul></li><li><a href=\"#b-åŒç›®å¤šç›®ç«‹ä½“è§†è§‰stereo-vision\" rel=\"noopener nofollow\">B. åŒç›®/å¤šç›®ç«‹ä½“è§†è§‰ï¼ˆStereo Visionï¼‰ï¼š</a><ul><li><a href=\"#1-æ ¸å¿ƒå®šä¹‰\" rel=\"noopener nofollow\">1. æ ¸å¿ƒå®šä¹‰</a></li><li><a href=\"#2-æ ¸å¿ƒæ•°å­¦åŽŸç†ä¸‰è§’æµ‹é‡triangulation\" rel=\"noopener nofollow\">2. æ ¸å¿ƒæ•°å­¦åŽŸç†ï¼šä¸‰è§’æµ‹é‡ï¼ˆTriangulationï¼‰</a></li><li><a href=\"#3-æ ‡å‡†ç®—æ³•æµç¨‹stereo-pipeline\" rel=\"noopener nofollow\">3. æ ‡å‡†ç®—æ³•æµç¨‹ï¼ˆStereo Pipelineï¼‰</a></li><li><a href=\"#4-åŒç›®è§†è§‰-vs-å•ç›®-sfm-çš„åŒºåˆ«\" rel=\"noopener nofollow\">4. åŒç›®è§†è§‰ vs. å•ç›® SfM çš„åŒºåˆ«</a></li><li><a href=\"#5-é€‚ç”¨åœºæ™¯ä¸Žå±€é™æ€§\" rel=\"noopener nofollow\">5. é€‚ç”¨åœºæ™¯ä¸Žå±€é™æ€§</a></li><li><a href=\"#6-å‚è€ƒèµ„æ–™ä¸Žç»å…¸æ–‡çŒ®\" rel=\"noopener nofollow\">6. å‚è€ƒèµ„æ–™ä¸Žç»å…¸æ–‡çŒ®</a></li></ul></li><li><a href=\"#c-ç¥žç»è¾å°„åœºnerf-neural-radiance-fields\" rel=\"noopener nofollow\">C. ç¥žç»è¾å°„åœºï¼ˆNeRF, Neural Radiance Fieldsï¼‰</a><ul><li><a href=\"#1-ä»€ä¹ˆæ˜¯-nerf\" rel=\"noopener nofollow\">1. ä»€ä¹ˆæ˜¯ NeRFï¼Ÿ</a></li><li><a href=\"#2-nerf-çš„æ ¸å¿ƒåŽŸç†5d-å‡½æ•°\" rel=\"noopener nofollow\">2. NeRF çš„æ ¸å¿ƒåŽŸç†ï¼š5D å‡½æ•°</a></li><li><a href=\"#3-nerf-çš„å·¥ä½œæµç¨‹\" rel=\"noopener nofollow\">3. NeRF çš„å·¥ä½œæµç¨‹</a></li><li><a href=\"#4-ä¸ºä»€ä¹ˆ-nerf-æ•ˆæžœè¿™ä¹ˆéœ‡æ’¼\" rel=\"noopener nofollow\">4. ä¸ºä»€ä¹ˆ NeRF æ•ˆæžœè¿™ä¹ˆéœ‡æ’¼ï¼Ÿ</a></li><li><a href=\"#5-å±€é™æ€§ä¸Žç›®å‰çš„ç“¶é¢ˆ\" rel=\"noopener nofollow\">5. å±€é™æ€§ä¸Žç›®å‰çš„ç“¶é¢ˆ</a></li><li><a href=\"#6-è¿›åŒ–ä¹‹è·¯nerf-çš„å­å­™ä»¬\" rel=\"noopener nofollow\">6. è¿›åŒ–ä¹‹è·¯ï¼ˆNeRF çš„å­å­™ä»¬ï¼‰</a></li><li><a href=\"#7-å‚è€ƒæ–‡çŒ®\" rel=\"noopener nofollow\">7. å‚è€ƒæ–‡çŒ®</a></li></ul></li><li><a href=\"#d-3d-gaussian-splatting-3dgs\" rel=\"noopener nofollow\">D. 3D Gaussian Splatting (3DGS)ï¼š</a><ul><li><a href=\"#1-ä»€ä¹ˆæ˜¯-3d-gaussian-splatting-3dgs\" rel=\"noopener nofollow\">1. ä»€ä¹ˆæ˜¯ 3D Gaussian Splatting (3DGS)ï¼Ÿ</a></li><li><a href=\"#2-æ ¸å¿ƒåŽŸç†3d-é«˜æ–¯æ¤­çƒä½“çš„åŸºå›\" rel=\"noopener nofollow\">2. æ ¸å¿ƒåŽŸç†ï¼š3D é«˜æ–¯æ¤­çƒä½“çš„â€œåŸºå› â€</a></li><li><a href=\"#3-å·¥ä½œæµç¨‹ä»Žç‚¹äº‘åˆ°ç²¾ç¾Žå»ºæ¨¡\" rel=\"noopener nofollow\">3. å·¥ä½œæµç¨‹ï¼šä»Žç‚¹äº‘åˆ°ç²¾ç¾Žå»ºæ¨¡</a></li><li><a href=\"#5-ç›®å‰çš„ç“¶é¢ˆä¸ŽæŒ‘æˆ˜\" rel=\"noopener nofollow\">5. ç›®å‰çš„ç“¶é¢ˆä¸ŽæŒ‘æˆ˜</a></li><li><a href=\"#6-å‚è€ƒæ–‡çŒ®\" rel=\"noopener nofollow\">6. å‚è€ƒæ–‡çŒ®</a></li></ul></li></ul></li><li><a href=\"#äºŒ-ä¸»åŠ¨è§†è§‰active-vision-è‡ªå¸¦å…‰æº\" rel=\"noopener nofollow\">äºŒ. ä¸»åŠ¨è§†è§‰ï¼ˆActive Visionï¼‰â€”â€” è‡ªå¸¦å…‰æº</a><ul><li><a href=\"#a-ç»“æž„å…‰æŠ€æœ¯\" rel=\"noopener nofollow\">A. ç»“æž„å…‰æŠ€æœ¯</a><ul><li><a href=\"#å®šä¹‰-1\" rel=\"noopener nofollow\"><strong>å®šä¹‰ï¼š</strong></a></li><li><a href=\"#2-æ ¸å¿ƒæ•°å­¦åŽŸç†å˜å½¢çš„ä¸‰è§’æµ‹é‡\" rel=\"noopener nofollow\">2. æ ¸å¿ƒæ•°å­¦åŽŸç†ï¼šå˜å½¢çš„ä¸‰è§’æµ‹é‡</a></li><li><a href=\"#3-ç¼–ç æ–¹å¼ç»“æž„å…‰çš„è¯­è¨€\" rel=\"noopener nofollow\">3. ç¼–ç æ–¹å¼ï¼šç»“æž„å…‰çš„â€œè¯­è¨€â€</a></li><li><a href=\"#4-æ·±åº¦è§£æžiphone-faceid-æ˜¯å¦‚ä½•å·¥ä½œçš„\" rel=\"noopener nofollow\">4. æ·±åº¦è§£æžï¼šiPhone FaceID æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ</a></li><li><a href=\"#5-ç»“æž„å…‰çš„ä¼˜ç¼ºç‚¹\" rel=\"noopener nofollow\">5. ç»“æž„å…‰çš„ä¼˜ç¼ºç‚¹</a></li></ul></li><li><a href=\"#6-å‚è€ƒæ–‡çŒ®-1\" rel=\"noopener nofollow\">6. å‚è€ƒæ–‡çŒ®</a></li><li><a href=\"#é£žè¡Œæ—¶é—´æ³•tof-time-of-flight\" rel=\"noopener nofollow\">é£žè¡Œæ—¶é—´æ³•ï¼ˆToF, Time of Flightï¼‰</a><ul><li><a href=\"#1-ä»€ä¹ˆæ˜¯-tof-é£žè¡Œæ—¶é—´æ³•\" rel=\"noopener nofollow\">1. ä»€ä¹ˆæ˜¯ ToF (é£žè¡Œæ—¶é—´æ³•)ï¼Ÿ</a></li><li><a href=\"#2-æ ¸å¿ƒæ•°å­¦åŽŸç†æžé€Ÿå…¬å¼\" rel=\"noopener nofollow\">2. æ ¸å¿ƒæ•°å­¦åŽŸç†ï¼šæžé€Ÿå…¬å¼</a></li><li><a href=\"#3-tof-çš„å·¥ä½œæµç¨‹\" rel=\"noopener nofollow\">3. ToF çš„å·¥ä½œæµç¨‹</a></li><li><a href=\"#4-tof-vs-ç»“æž„å…‰æœ‰ä»€ä¹ˆåŒºåˆ«\" rel=\"noopener nofollow\">4. ToF vs. ç»“æž„å…‰ï¼šæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ</a></li><li><a href=\"#5-ç›®å‰çš„ç“¶é¢ˆä¸ŽæŒ‘æˆ˜-1\" rel=\"noopener nofollow\">5. ç›®å‰çš„ç“¶é¢ˆä¸ŽæŒ‘æˆ˜</a></li><li><a href=\"#6-å‚è€ƒæ–‡çŒ®-2\" rel=\"noopener nofollow\">6. å‚è€ƒæ–‡çŒ®</a></li></ul></li></ul></li></ul></li><li><a href=\"#4-é€‚ç”¨åœºæ™¯\" rel=\"noopener nofollow\">4. é€‚ç”¨åœºæ™¯</a></li><li><a href=\"#5-ç›®å‰çš„ç“¶é¢ˆä¸Žé—®é¢˜\" rel=\"noopener nofollow\">5. ç›®å‰çš„ç“¶é¢ˆä¸Žé—®é¢˜</a></li><li><a href=\"#æ€»ç»“\" rel=\"noopener nofollow\">æ€»ç»“</a></li><li><a href=\"#å‚è€ƒæ–‡çŒ®\" rel=\"noopener nofollow\">å‚è€ƒæ–‡çŒ®</a></li></ul></div><p></p>\n<h1 id=\"å‰è¨€\">å‰è¨€</h1>\n<p>åœ¨äººå·¥æ™ºèƒ½çš„æµªæ½®ä¸­ï¼Œå¦‚æžœè¯´ä¼ ç»Ÿçš„2Då›¾åƒè¯†åˆ«æ˜¯è®©æœºå™¨â€œè®¤å‡ºâ€ç‰©ä½“ï¼Œé‚£ä¹ˆ<strong>3Dé‡å»ºï¼ˆ3D Reconstructionï¼‰</strong>åˆ™æ˜¯è®©æœºå™¨çœŸæ­£â€œç†è§£â€ç‰©ç†ä¸–ç•Œã€‚é€šè¿‡æœºå™¨è§†è§‰å®žçŽ°3Dé‡å»ºï¼Œæ˜¯èµ‹äºˆæœºå™¨äººã€æ— äººæœºå’Œè‡ªåŠ¨é©¾é©¶æ±½è½¦ç©ºé—´æ„ŸçŸ¥èƒ½åŠ›çš„æ ¸å¿ƒæŠ€æœ¯ã€‚</p>\n<h1 id=\"1-ä»€ä¹ˆæ˜¯é€šè¿‡æœºå™¨è§†è§‰å®žçŽ°3dé‡å»º\">1. ä»€ä¹ˆæ˜¯é€šè¿‡æœºå™¨è§†è§‰å®žçŽ°3Dé‡å»ºï¼Ÿ</h1>\n<h2 id=\"å®šä¹‰\">å®šä¹‰</h2>\n<p>é€šè¿‡æœºå™¨è§†è§‰å®žçŽ°çš„3Dé‡å»ºï¼Œæ˜¯æŒ‡åˆ©ç”¨å…‰å­¦ä¼ æ„Ÿå™¨ï¼ˆå¦‚ç›¸æœºï¼‰èŽ·å–çš„2Då›¾åƒåºåˆ—ï¼Œç»“åˆè®¡ç®—æœºè§†è§‰ç®—æ³•ï¼Œæ¢å¤ç‰©ä½“çš„ä¸‰ç»´å‡ ä½•å½¢çŠ¶ã€ç©ºé—´ä½ç½®ä»¥åŠè¡¨é¢çº¹ç†çš„è¿‡ç¨‹ã€‚</p>\n<h2 id=\"æ ¸å¿ƒæœ¬è´¨ä»Ž2dåˆ°3dçš„é€†å‘æŠ•å½±\">æ ¸å¿ƒæœ¬è´¨ï¼šä»Ž2Dåˆ°3Dçš„é€†å‘æŠ•å½±</h2>\n<p>åœ¨ç‰©ç†ä¸–ç•Œä¸­ï¼Œ3Dç‰©ä½“é€šè¿‡ç›¸æœºçš„é€é•œæˆåƒåœ¨2Dæ„Ÿå…‰å…ƒä»¶ä¸Šï¼Œè¿™æ˜¯ä¸€ä¸ª<strong>é™ç»´</strong>çš„è¿‡ç¨‹ï¼ˆä¸¢å¤±äº†æ·±åº¦ä¿¡æ¯$Z$ï¼‰ã€‚3Dé‡å»ºçš„ç›®æ ‡å°±æ˜¯é€šè¿‡æ•°å­¦æ¨¡åž‹å’Œç®—æ³•ï¼Œå°†è¿™äº›ä¸¢å¤±çš„æ·±åº¦ä¿¡æ¯æ‰¾å›žæ¥ï¼ŒæŠŠåƒç´ ç‚¹è¿˜åŽŸåˆ°ä¸‰ç»´åæ ‡ç³»ï¼ˆ$X, Y, Z$ï¼‰ä¸­ã€‚</p>\n<h2 id=\"å…³é”®æ¦‚å¿µ\">å…³é”®æ¦‚å¿µ</h2>\n<ul>\n<li><strong>ç‚¹äº‘ï¼ˆPoint Cloudï¼‰ï¼š</strong> é‡å»ºçš„ç¬¬ä¸€æ­¥é€šå¸¸æ˜¯ç”Ÿæˆå¤§é‡å¸¦æœ‰ç©ºé—´åæ ‡çš„é‡‡æ ·ç‚¹ã€‚</li>\n<li><strong>ä¸‰è§’å‰–åˆ†ï¼ˆTriangulationï¼‰ï¼š</strong> åˆ©ç”¨å‡ ä½•å…³ç³»ç¡®å®šç‚¹åœ¨ç©ºé—´ä¸­çš„ä½ç½®ã€‚</li>\n<li><strong>æ·±åº¦å›¾ï¼ˆDepth Mapï¼‰ï¼š</strong> æ¯ä¸ªåƒç´ ç‚¹ä»£è¡¨è·ç¦»ç›¸æœºè·ç¦»çš„å›¾åƒã€‚</li>\n</ul>\n<hr />\n<h1 id=\"2-æ•ˆæžœæ¼”ç¤º3dé‡å»ºçš„è¿‡ç¨‹\">2. æ•ˆæžœæ¼”ç¤ºï¼š3Dé‡å»ºçš„è¿‡ç¨‹</h1>\n<p>æˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹ä¸‰ä¸ªé˜¶æ®µæ¥æƒ³è±¡é‡å»ºçš„è§†è§‰æ•ˆæžœï¼š</p>\n<ol>\n<li><strong>ç¨€ç–é‡å»ºé˜¶æ®µï¼ˆSparse Reconstructionï¼‰ï¼š</strong><br />\nå±å¹•ä¸Šå‡ºçŽ°é›¶æ•£çš„ç‰¹å¾ç‚¹ï¼Œçœ‹èµ·æ¥åƒæ˜¯ä¸€ç¾¤å‘å…‰çš„è¤ç«è™«æž„æˆäº†ç‰©ä½“çš„è½®å»“ã€‚æ­¤æ—¶å¯ä»¥çœ‹æ¸…ç›¸æœºçš„è¿åŠ¨è½¨è¿¹ã€‚</li>\n<li><strong>ç¨ å¯†é‡å»ºé˜¶æ®µï¼ˆDense Reconstructionï¼‰ï¼š</strong><br />\nç‚¹äº‘å˜å¾—æžå…¶å¯†é›†ï¼Œç‰©ä½“çš„å½¢çŠ¶å·²ç»æ¸…æ™°å¯è¾¨ï¼Œåƒæ˜¯ç”±æ— æ•°ç»†å°çš„æ²™ç²’å †ç Œè€Œæˆçš„é›•å¡‘ã€‚</li>\n<li><strong>è¡¨é¢ç½‘æ ¼åŒ–ä¸Žçº¹ç†è´´å›¾ï¼ˆMeshing &amp; Texturingï¼‰ï¼š</strong><br />\nç®—æ³•åœ¨ç‚¹ä¸Žç‚¹ä¹‹é—´è¿žçº¿å½¢æˆä¸‰è§’é¢ç‰‡ï¼ˆMeshï¼‰ï¼Œå¹¶æŠŠç…§ç‰‡ä¸Šçš„é¢œè‰²â€œè´´â€ä¸ŠåŽ»ã€‚æ­¤æ—¶ï¼Œç‰©ä½“åœ¨å±å¹•ä¸Šçœ‹èµ·æ¥ä¸ŽçœŸå®žç…§ç‰‡æ— å¼‚ï¼Œä½†ä½ å¯ä»¥æ—‹è½¬ã€ç¼©æ”¾å®ƒã€‚</li>\n</ol>\n<p><img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /><br />\n<strong>æ¦‚å¿µè§£è¯»ï¼š</strong><br />\n<strong>1. Meshï¼ˆç½‘æ ¼ / ä¸‰è§’ç½‘æ ¼ï¼‰</strong><br />\nMesh æ˜¯ä¸‰ç»´æ¨¡åž‹çš„ â€œå‡ ä½•éª¨æž¶â€ï¼Œå®ƒç”±å¤§é‡ä¸‰è§’å½¢ï¼ˆæˆ–å¤šè¾¹å½¢ï¼‰é¢ç‰‡æ‹¼æŽ¥è€Œæˆï¼Œåªå®šä¹‰äº†ç‰©ä½“çš„ä¸‰ç»´å½¢çŠ¶ã€è½®å»“å’Œç»“æž„ï¼Œå°±åƒå»ºç­‘çš„é’¢ç­‹æ¡†æž¶ï¼Œæœ¬èº«æ²¡æœ‰é¢œè‰²å’Œçº¹ç†ã€‚<br />\n<strong>2. è´´å›¾ï¼ˆTexture Mappingï¼‰</strong><br />\nè´´å›¾æ˜¯ä¸€å¼ åŒ…å«é¢œè‰²ã€çº¹ç†ã€ç»†èŠ‚ä¿¡æ¯çš„äºŒç»´å›¾åƒï¼Œæ¯”å¦‚å¢™é¢çš„ç –çŸ³çº¹ç†ã€çª—æˆ·çš„çŽ»ç’ƒè´¨æ„Ÿã€‚å®ƒçš„ä½œç”¨æ˜¯æŠŠè¿™äº›è¡¨é¢ç»†èŠ‚ â€œè´´â€ åˆ° Mesh çš„å‡ ä½•æ¡†æž¶ä¸Šã€‚</p>\n<hr />\n<h1 id=\"3-ç›®å‰çš„ä¸»æµæ–¹æ³•\">3. ç›®å‰çš„ä¸»æµæ–¹æ³•</h1>\n<p>3Dé‡å»ºçš„æ–¹æ³•ä¸»è¦åˆ†ä¸º<strong>ä¸»åŠ¨è§†è§‰</strong>å’Œ<strong>è¢«åŠ¨è§†è§‰</strong>ä¸¤å¤§ç±»ï¼š</p>\n<h2 id=\"ä¸€è¢«åŠ¨è§†è§‰passive-vision-ä»…ä¾èµ–çŽ¯å¢ƒå…‰\">ä¸€ã€è¢«åŠ¨è§†è§‰ï¼ˆPassive Visionï¼‰â€”â€” ä»…ä¾èµ–çŽ¯å¢ƒå…‰</h2>\n<p>è¿™ç±»æ–¹æ³•ä¸å‘ç‰©ä½“å‘å°„èƒ½é‡ï¼Œä»…é€šè¿‡æ•æ‰çŽ¯å¢ƒå…‰æˆåƒã€‚</p>\n<h3 id=\"a--å•ç›®é‡å»ºmonocular-reconstruction\">A.  å•ç›®é‡å»ºï¼ˆMonocular Reconstructionï¼‰ï¼š</h3>\n<p><strong>åŽŸç†</strong>ï¼šåˆ©ç”¨<strong>è¿åŠ¨æ¢å¤ç»“æž„ï¼ˆSfM, Structure from Motionï¼‰</strong>ã€‚é€šè¿‡å•å°ç›¸æœºåœ¨ä¸åŒä½ç½®æ‹æ‘„çš„å¤šå¼ ç…§ç‰‡ï¼Œè®¡ç®—ç›¸æœºä½å§¿å˜åŒ–å¹¶é‡å»ºåœºæ™¯ã€‚</p>\n<p><strong>éš¾ç‚¹</strong>ï¼š å­˜åœ¨<strong>å°ºåº¦ä¸ç¡®å®šæ€§</strong>ï¼ˆä¸çŸ¥é“ç‰©ä½“åˆ°åº•æœ‰å¤šå¤§ï¼‰ã€‚</p>\n<p>ç®€å•æ¥è¯´ï¼ŒSfM å°±æ˜¯é€šè¿‡<strong>ç§»åŠ¨çš„ç›¸æœº</strong>æ‹æ‘„çš„ä¸€ç³»åˆ—<strong>2Då›¾åƒ</strong>ï¼Œæ¥æŽ¨ç®—å‡ºç‰©ä½“çš„<strong>3Då½¢çŠ¶</strong>å’Œç›¸æœºçš„<strong>ç©ºé—´è½¨è¿¹</strong>ã€‚</p>\n<p>ä¸‹é¢æˆ‘å°†éžå¸¸è¯¦ç»†åœ°ä¸ºä½ æ‹†è§£ SfM çš„åŽŸç†ã€æ­¥éª¤ä»¥åŠå®ƒèƒŒåŽçš„æ•°å­¦é€»è¾‘ã€‚</p>\n<hr />\n<h4 id=\"ä»€ä¹ˆæ˜¯-sfmstructure-from-motion\">ä»€ä¹ˆæ˜¯ SfMï¼ˆStructure from Motionï¼‰ï¼Ÿ</h4>\n<ul>\n<li><strong>Structureï¼ˆç»“æž„ï¼‰ï¼š</strong> æŒ‡çš„æ˜¯è¢«æ‹æ‘„ç‰©ä½“çš„ä¸‰ç»´åæ ‡ï¼ˆç‚¹äº‘ï¼‰ã€‚</li>\n<li><strong>Motionï¼ˆè¿åŠ¨ï¼‰ï¼š</strong> æŒ‡çš„æ˜¯ç›¸æœºåœ¨æ‹æ‘„æ¯ä¸€å¼ ç…§ç‰‡æ—¶çš„ä½ç½®ï¼ˆä½å§¿ï¼ŒPoseï¼‰ã€‚</li>\n<li><strong>Fromï¼ˆé€šè¿‡...æ¢å¤ï¼‰ï¼š</strong> å¼ºè°ƒäº†å› æžœå…³ç³»ã€‚</li>\n</ul>\n<p><strong>æ ¸å¿ƒæ€æƒ³ï¼š</strong><br />\næƒ³è±¡ä½ å›´ç€ä¸€ä¸ªé›•åƒè½¬åœˆæ‹ç…§ã€‚è™½ç„¶æ¯å¼ ç…§ç‰‡éƒ½æ˜¯å¹³é¢çš„ï¼ˆ2Dï¼‰ï¼Œä½†å½“ä½ ä»Žå·¦è¾¹ç§»åŠ¨åˆ°å³è¾¹æ—¶ï¼Œé›•åƒä¸Šçš„ç‰¹å¾ç‚¹ï¼ˆæ¯”å¦‚é¼»å­å°–ï¼‰åœ¨ç…§ç‰‡é‡Œçš„ä½ç½®ä¼šå‘ç”Ÿç§»åŠ¨ã€‚SfM ç®—æ³•å°±åƒä½ çš„å¤§è„‘ä¸€æ ·ï¼Œé€šè¿‡åˆ†æžè¿™äº›ç‚¹ç§»åŠ¨çš„å¹…åº¦ã€æ–¹å‘å’Œè§„å¾‹ï¼Œåè¿‡æ¥æŽ¨ç®—å‡ºï¼šâ€œå“¦ï¼ŒåŽŸæ¥é¼»å­å°–è·ç¦»æˆ‘è¿™ä¹ˆè¿œï¼Œè€Œæˆ‘åˆšæ‰å‘å³ç§»åŠ¨äº† 50 åŽ˜ç±³ã€‚â€</p>\n<hr />\n<h4 id=\"sfm-çš„å…¨æµç¨‹æžç®€æ­¥éª¤ç‰ˆ\">SfM çš„å…¨æµç¨‹ï¼ˆæžç®€æ­¥éª¤ç‰ˆï¼‰</h4>\n<p>ä¸€ä¸ªæ ‡å‡†çš„ SfM ç³»ç»Ÿé€šå¸¸åŒ…å«ä»¥ä¸‹äº”ä¸ªæ ¸å¿ƒæ­¥éª¤ï¼š</p>\n<p><img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></p>\n<h4 id=\"1-ç‰¹å¾æå–ä¸ŽåŒ¹é…-feature-extraction--matching\">1. ç‰¹å¾æå–ä¸ŽåŒ¹é… (Feature Extraction &amp; Matching)</h4>\n<ul>\n<li><strong>åšä»€ä¹ˆï¼š</strong> ç®—æ³•ä¼šåœ¨æ¯ä¸€å¼ ç…§ç‰‡ä¸­å¯»æ‰¾â€œåœ°æ ‡â€â€”â€”é‚£äº›æ— è®ºå…‰ç…§æ€Žä¹ˆå˜ã€è§’åº¦æ€Žä¹ˆå˜éƒ½èƒ½è®¤å‡ºæ¥çš„ç‚¹ï¼ˆé€šå¸¸ä½¿ç”¨ <strong>SIFT</strong> æˆ– <strong>ORB</strong> ç®—æ³•ï¼‰ã€‚</li>\n<li><strong>ç›®çš„ï¼š</strong> ç¡®å®šç¬¬ä¸€å¼ ç…§ç‰‡é‡Œçš„é‚£ä¸ªâ€œç‚¹â€å’Œç¬¬äºŒå¼ ç…§ç‰‡é‡Œçš„å“ªä¸ªâ€œç‚¹â€æ˜¯ç‰©ç†ä¸–ç•Œä¸­çš„åŒä¸€ä¸ªä½ç½®ã€‚</li>\n<li><strong>ç»“æžœï¼š</strong> å¾—åˆ°ä¸€å †é…å¯¹å¥½çš„åƒç´ ç‚¹åæ ‡ã€‚</li>\n</ul>\n<h4 id=\"2-è®¡ç®—å‡ ä½•å…³ç³»-estimating-epipolar-geometry\">2. è®¡ç®—å‡ ä½•å…³ç³» (Estimating Epipolar Geometry)</h4>\n<ul>\n<li><strong>åšä»€ä¹ˆï¼š</strong> åˆ©ç”¨<strong>å¯¹æžå‡ ä½•ï¼ˆEpipolar Geometryï¼‰</strong>ç†è®ºã€‚é€šè¿‡åŒ¹é…çš„ç‚¹å¯¹ï¼Œè®¡ç®—å‡ºä¸¤å¼ ç…§ç‰‡ä¹‹é—´çš„æ•°å­¦å˜æ¢å…³ç³»ï¼Œå³<strong>åŸºç¡€çŸ©é˜µï¼ˆFundamental Matrixï¼‰</strong>æˆ–<strong>æœ¬è´¨çŸ©é˜µï¼ˆEssential Matrixï¼‰</strong>ã€‚</li>\n<li><strong>åŽŸç†ï¼š</strong> å³ä½¿ä¸çŸ¥é“ç‰©ä½“çš„å½¢çŠ¶ï¼Œåªè¦æœ‰è¶³å¤Ÿçš„åŒ¹é…ç‚¹ï¼Œæˆ‘ä»¬å°±èƒ½ç®—å‡ºç›¸æœºä»Žä½ç½® A åˆ°ä½ç½® B åˆ°åº•æ—‹è½¬äº†å¤šå°‘åº¦ï¼Œå¹³ç§»äº†å¤šå°‘è·ç¦»ã€‚</li>\n</ul>\n<h4 id=\"3-ä¸‰è§’æµ‹é‡-triangulation\">3. ä¸‰è§’æµ‹é‡ (Triangulation)</h4>\n<ul>\n<li><strong>åšä»€ä¹ˆï¼š</strong> æœ‰äº†ç›¸æœºçš„ä½å§¿ï¼Œç®—æ³•ä¼šä»Žä¸¤ä¸ªç›¸æœºä¸­å¿ƒå‘åŒä¸€ä¸ªç‰¹å¾ç‚¹å‘å°„ä¸¤æ¡å°„çº¿ã€‚</li>\n<li><strong>åŽŸç†ï¼š</strong> è¿™ä¸¤æ¡å°„çº¿çš„äº¤ç‚¹ï¼Œå°±æ˜¯è¯¥ç‰¹å¾ç‚¹åœ¨ä¸‰ç»´ç©ºé—´ä¸­çš„çœŸå®žåæ ‡ï¼ˆ$X, Y, Z$ï¼‰ã€‚</li>\n<li><strong>ç»“æžœï¼š</strong> ç”Ÿæˆäº†æœ€åˆçš„ç¨€ç–ç‚¹äº‘ã€‚</li>\n</ul>\n<h4 id=\"4-å¢žé‡å¼é‡å»º-incremental-reconstruction\">4. å¢žé‡å¼é‡å»º (Incremental Reconstruction)</h4>\n<ul>\n<li><strong>åšä»€ä¹ˆï¼š</strong> ç®—æ³•ä¸ä¼šä¸€æ¬¡æ€§å¤„ç†å‡ ç™¾å¼ ç…§ç‰‡ï¼Œè€Œæ˜¯å…ˆä»Žä¸¤å¼ å¼€å§‹ï¼Œé‡å»ºå‡ºä¸€å°éƒ¨åˆ†ï¼Œç„¶åŽåƒæ‹¼å›¾ä¸€æ ·ï¼Œä¸æ–­åŠ å…¥ç¬¬ä¸‰å¼ ã€ç¬¬å››å¼ ç…§ç‰‡ã€‚</li>\n<li><strong>è¿‡ç¨‹ï¼š</strong> æ¯åŠ å…¥ä¸€å¼ æ–°ç…§ç‰‡ï¼Œå°±åˆ©ç”¨å·²æœ‰çš„ 3D ç‚¹äº‘æ¥åæŽ¨è¿™å¼ æ–°ç…§ç‰‡çš„ç›¸æœºä½ç½®ï¼ˆè¿™å« <strong>PnP</strong> ç®—æ³•ï¼‰ï¼Œç„¶åŽå†æŠŠæ–°çœ‹åˆ°çš„ç‚¹åŠ å…¥ç‚¹äº‘ã€‚</li>\n</ul>\n<h4 id=\"5-å…¨å±€ä¼˜åŒ–å…‰æŸæ³•å¹³å·®-bundle-adjustment-ba\">5. å…¨å±€ä¼˜åŒ–ï¼šå…‰æŸæ³•å¹³å·® (Bundle Adjustment, BA)</h4>\n<ul>\n<li><strong>è¿™æ˜¯ SfM çš„çµé­‚ï¼š</strong> éšç€ç…§ç‰‡è¶Šæ¥è¶Šå¤šï¼Œè¯¯å·®ä¼šç´¯ç§¯ï¼Œç‚¹äº‘ä¼šâ€œé£˜â€æŽ‰æˆ–å˜å½¢ã€‚</li>\n<li><strong>åšä»€ä¹ˆï¼š</strong> BA æ˜¯ä¸€é¡¹å¤§åž‹ä¼˜åŒ–å·¥ç¨‹ã€‚å®ƒä¼šåŒæ—¶è°ƒæ•´<strong>æ‰€æœ‰ç›¸æœºçš„ä½å§¿</strong>å’Œ<strong>æ‰€æœ‰ 3D ç‚¹çš„åæ ‡</strong>ï¼Œä½¿å¾—æ¯ä¸€ä¸ª 3D ç‚¹æŠ•å½±å›žç…§ç‰‡ä¸Šæ—¶ï¼Œä¸Žç…§ç‰‡é‡ŒåŽŸå§‹åƒç´ ç‚¹çš„è·ç¦»ï¼ˆ<strong>é‡æŠ•å½±è¯¯å·®</strong>ï¼‰æœ€å°ã€‚<br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></li>\n</ul>\n<hr />\n<h4 id=\"ä¸ºä»€ä¹ˆå•ç›®-sfm-æ— æ³•æ„ŸçŸ¥ç»å¯¹å°ºåº¦\">ä¸ºä»€ä¹ˆå•ç›® SfM æ— æ³•æ„ŸçŸ¥â€œç»å¯¹å°ºåº¦â€ï¼Ÿ</h4>\n<p>è¿™æ˜¯å•ç›®é‡å»ºæœ€è‡´å‘½çš„å¼±ç‚¹ï¼Œä¹Ÿæ˜¯é¢è¯•æˆ–å­¦æœ¯è®¨è®ºä¸­å¿…é—®çš„é—®é¢˜ã€‚</p>\n<p><strong>åŽŸç†ï¼š</strong><br />\nåœ¨æ•°å­¦ä¸Šï¼ŒSfM æ¢å¤å‡ºçš„ç©ºé—´ç»“æž„å…·æœ‰<strong>å°ºåº¦ç­‰æ¯”æ€§</strong>ã€‚</p>\n<ul>\n<li>å¦‚æžœä½ æ‹æ‘„ä¸€å¼ æ¡Œå­ä¸Šçš„æ°´æ¯ï¼Œé‡å»ºå‡ºæ¥çš„æ¨¡åž‹å¯èƒ½çœ‹èµ·æ¥å¾ˆå®Œç¾Žã€‚</li>\n<li>ä½†æ˜¯ï¼Œç®—æ³•æ— æ³•åˆ†è¾¨è¿™æ˜¯ä¸€ä¸ª<strong>çœŸå®žçš„é«˜ 10 åŽ˜ç±³çš„æ°´æ¯</strong>ï¼Œè¿˜æ˜¯ä¸€ä¸ª<strong>é«˜ 10 ç±³çš„å·¨åž‹æ°´æ¯æ¨¡åž‹</strong>ã€‚</li>\n</ul>\n<p><strong>åŽŸå› ï¼š</strong><br />\nåœ¨å•ç›®ç›¸æœºçœ‹æ¥ï¼Œä¸€ä¸ªå¾ˆå°çš„ç‰©ä½“ç¦»ç›¸æœºå¾ˆè¿‘ï¼Œå’Œä¸€ä¸ªå·¨å¤§çš„ç‰©ä½“ç¦»ç›¸æœºå¾ˆè¿œï¼Œåœ¨ç…§ç‰‡ä¸Šçš„åƒç´ è¡¨çŽ°æ˜¯ä¸€æ¨¡ä¸€æ ·çš„ã€‚é™¤éžä½ é¢å¤–å‘Šè¯‰ç®—æ³•ä¸€ä¸ªå‚è€ƒå€¼ï¼ˆæ¯”å¦‚ï¼šç…§ç‰‡é‡Œé‚£ä¸ªç¡¬å¸ç›´å¾„æ˜¯ 25mmï¼Œæˆ–è€…ä¸¤ä¸ªç›¸æœºå…¶å®žè·ç¦» 10cmï¼‰ï¼Œå¦åˆ™å®ƒåªèƒ½å‘Šè¯‰ä½ ï¼šâ€œA ç‚¹åˆ° B ç‚¹çš„è·ç¦»æ˜¯ C ç‚¹åˆ° D ç‚¹è·ç¦»çš„ 2 å€â€ï¼Œè€Œä¸èƒ½å‘Šè¯‰ä½ åˆ°åº•æ˜¯å¤šå°‘ç±³ã€‚</p>\n<hr />\n<h4 id=\"sfm-çš„ä¸¤ç§ä¸»æµæµæ´¾\">SfM çš„ä¸¤ç§ä¸»æµæµæ´¾</h4>\n<ol>\n<li>\n<p><strong>å¢žé‡å¼ SfM (Incremental SfM)ï¼š</strong></p>\n<ul>\n<li>ä»£è¡¨ä½œï¼š<strong>COLMAP</strong>ï¼ˆç›®å‰å­¦æœ¯ç•Œå’Œå·¥ä¸šç•Œæœ€å¸¸ç”¨çš„å¼€æºå·¥å…·ï¼‰ã€‚</li>\n<li>ä¼˜ç‚¹ï¼šéžå¸¸é²æ£’ï¼Œç²¾åº¦é«˜ã€‚</li>\n<li>ç¼ºç‚¹ï¼šæ…¢ï¼Œç…§ç‰‡å¤šäº†ä¹‹åŽä¼˜åŒ–éžå¸¸è€—æ—¶ã€‚<br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></li>\n</ul>\n</li>\n<li>\n<p><strong>å…¨å±€å¼ SfM (Global SfM)ï¼š</strong></p>\n<ul>\n<li>ä»£è¡¨ä½œï¼š<strong>TheiaSfM</strong>ã€‚</li>\n<li>ä¼˜ç‚¹ï¼šé€Ÿåº¦æžå¿«ï¼Œé€‚åˆå¤§è§„æ¨¡åœºæ™¯ã€‚</li>\n<li>ç¼ºç‚¹ï¼šå¯¹å¼‚å¸¸åŒ¹é…ç‚¹éžå¸¸æ•æ„Ÿï¼Œå®¹æ˜“å´©æºƒã€‚<br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></li>\n</ul>\n</li>\n</ol>\n<hr />\n<h4 id=\"å‚è€ƒæ–‡ä»¶\">å‚è€ƒæ–‡ä»¶</h4>\n<p>è‹¥è¦æ·±å…¥ç ”ç©¶ SfM çš„åº•å±‚æ•°å­¦ï¼Œä»¥ä¸‹æ–‡çŒ®æ˜¯å¿…è¯»çš„ï¼š</p>\n<ol>\n<li><strong>Agarwal, S., et al. (2011).</strong> <em>Building Rome in a Day</em>. Communications of the ACM.<br />\n(è¿™æ˜¯ SfM åŽ†å²ä¸Šçš„é‡Œç¨‹ç¢‘ï¼Œè¯æ˜Žäº†åˆ©ç”¨äº’è”ç½‘ä¸Šçš„æˆåƒä¸Šä¸‡å¼ ç…§ç‰‡é‡å»ºä¸€åº§åŸŽå¸‚æ˜¯å¯èƒ½çš„)ã€‚</li>\n<li><strong>SchÃ¶nberger, J. L., &amp; Frahm, J. M. (2016).</strong> <em>Structure-from-Motion Revisited</em>. CVPR.<br />\n(è¿™æ˜¯ <strong>COLMAP</strong> çš„æ ¸å¿ƒè®ºæ–‡ï¼Œç›®å‰è¢«å…¬è®¤ä¸ºå¢žé‡å¼ SfM çš„æœ€ä¼˜å®žè·µ)ã€‚</li>\n<li><strong>Triggs, B., et al. (1999).</strong> <em>Bundle Adjustment â€“ A Modern Synthesis</em>. Vision Algorithms: Theory and Practice.<br />\n(æ·±å…¥è®²è§£äº† SfM ä¸­æœ€å…³é”®çš„ä¼˜åŒ–ç®—æ³• BA)ã€‚</li>\n<li><strong>Snavely, N., Seitz, S. M., &amp; Szeliski, R. (2006).</strong> <em>Photo Tourism: Exploring image collections in 3D</em>. SIGGRAPH.<br />\n(é¦–æ¬¡å‘å¤§ä¼—å±•ç¤ºäº†å¦‚ä½•é€šè¿‡éžç»“æž„åŒ–ç…§ç‰‡é›†è¿›è¡Œ 3D å¯¼èˆª)ã€‚</li>\n<li><strong>Longuet-Higgins, H. C. (1981).</strong> <em>A computer algorithm for reconstructing a scene from two projections</em>. Nature.<br />\n(æå‡ºäº†è‘—åçš„å…«ç‚¹ç®—æ³•ï¼Œæ˜¯ SfM å‡ ä½•è®¡ç®—çš„åŸºçŸ³)ã€‚</li>\n</ol>\n<h3 id=\"b-åŒç›®å¤šç›®ç«‹ä½“è§†è§‰stereo-vision\">B. åŒç›®/å¤šç›®ç«‹ä½“è§†è§‰ï¼ˆStereo Visionï¼‰ï¼š</h3>\n<p><strong>åŽŸç†</strong>: æ¨¡æ‹Ÿäººç±»åŒçœ¼ã€‚é€šè¿‡è®¡ç®—å·¦å³ä¸¤ä¸ªç›¸æœºæ‹æ‘„å›¾åƒçš„<strong>è§†å·®ï¼ˆDisparityï¼‰</strong>ï¼Œåˆ©ç”¨ä¸‰è§’æµ‹é‡åŽŸç†è®¡ç®—æ·±åº¦ã€‚</p>\n<p>å¦‚æžœè¯´ SfMï¼ˆè¿åŠ¨æ¢å¤ç»“æž„ï¼‰æ˜¯æ¨¡ä»¿äººç±»â€œè¾¹èµ°è¾¹çœ‹â€æ¥è®¤çŸ¥ç©ºé—´ï¼Œé‚£ä¹ˆ<strong>åŒç›®ç«‹ä½“è§†è§‰ï¼ˆStereo Visionï¼‰</strong>åˆ™æ˜¯ç›´æŽ¥æ¨¡ä»¿äººç±»çš„<strong>åŒçœ¼ç»“æž„</strong>ã€‚</p>\n<p>å®ƒæ˜¯æœºå™¨è§†è§‰ä¸­æœ€ç»å…¸ã€åº”ç”¨æœ€å¹¿æ³›çš„æ·±åº¦æ„ŸçŸ¥æŠ€æœ¯ä¹‹ä¸€ã€‚ä¸‹é¢æˆ‘ä»¬æ·±åº¦æ‹†è§£åŒç›®ç«‹ä½“è§†è§‰çš„åŽŸç†ã€æ•°å­¦é€»è¾‘ä»¥åŠå®žçŽ°è¿‡ç¨‹ã€‚</p>\n<h4 id=\"1-æ ¸å¿ƒå®šä¹‰\">1. æ ¸å¿ƒå®šä¹‰</h4>\n<p>åŒç›®ç«‹ä½“è§†è§‰æ˜¯æŒ‡ä½¿ç”¨ä¸¤å°æˆåƒç‰¹æ€§ç›¸åŒï¼ˆç„¦è·ã€åƒç´ å°ºå¯¸ç­‰ä¸€è‡´ï¼‰çš„ç›¸æœºï¼Œå®‰è£…åœ¨åŒä¸€å¹³é¢ä¸Šï¼Œä¿æŒä¸€å®šçš„æ°´å¹³è·ç¦»ï¼ˆ<strong>åŸºçº¿ï¼ŒBaseline</strong>ï¼‰ï¼Œé€šè¿‡è®¡ç®—å·¦å³å›¾åƒä¸­åŒä¸€ç‰©ä½“åƒç´ ç‚¹çš„ç›¸å¯¹ä½å§¿å·®å¼‚ï¼Œæ¥èŽ·å–ç‰©ä½“ä¸‰ç»´ä¿¡æ¯çš„æ–¹æ³•ã€‚</p>\n<p><strong>ç›´è§‚ç†è§£ï¼š</strong><br />\nä¼¸å‡ºä½ çš„ä¸€æ ¹æ‰‹æŒ‡æ”¾åœ¨çœ¼å‰ï¼Œå…ˆé—­ä¸Šå·¦çœ¼çœ‹ï¼Œå†é—­ä¸Šå³çœ¼çœ‹ã€‚ä½ ä¼šå‘çŽ°æ‰‹æŒ‡ç›¸å¯¹äºŽèƒŒæ™¯çš„ä½ç½®å‘ç”Ÿäº†â€œè·³åŠ¨â€ã€‚</p>\n<ul>\n<li>æ‰‹æŒ‡ç¦»çœ¼ç›è¶Šè¿‘ï¼Œè·³åŠ¨å¹…åº¦ï¼ˆä½å§¿å·®å¼‚ï¼‰è¶Šå¤§ã€‚</li>\n<li>æ‰‹æŒ‡ç¦»çœ¼ç›è¶Šè¿œï¼Œè·³åŠ¨å¹…åº¦è¶Šå°ã€‚</li>\n<li>è¿™ç§è·³åŠ¨çš„ä½ç§»é‡ï¼Œåœ¨è®¡ç®—æœºè§†è§‰ä¸­è¢«ç§°ä¸º<strong>è§†å·®ï¼ˆDisparityï¼‰</strong>ã€‚</li>\n</ul>\n<hr />\n<h4 id=\"2-æ ¸å¿ƒæ•°å­¦åŽŸç†ä¸‰è§’æµ‹é‡triangulation\">2. æ ¸å¿ƒæ•°å­¦åŽŸç†ï¼šä¸‰è§’æµ‹é‡ï¼ˆTriangulationï¼‰</h4>\n<p>åŒç›®è§†è§‰çš„ç²¾é«“å¯ä»¥ç”¨ä¸€ä¸ªæžå…¶ç®€å•çš„å‡ ä½•å…¬å¼æ¥æ¦‚æ‹¬ã€‚</p>\n<p>å‡è®¾ä¸¤å°ç›¸æœºå®Œå…¨å¹³è¡Œï¼Œç„¦è·ä¸º $f$ï¼Œä¸¤ç›¸æœºä¸­å¿ƒè·ç¦»ï¼ˆåŸºçº¿ï¼‰ä¸º $B$ã€‚ç©ºé—´ä¸­ä¸€ç‚¹ $P$ åœ¨å·¦ç›¸æœºæˆåƒé¢ä¸Šçš„æ¨ªåæ ‡æ˜¯ $x_L$ï¼Œåœ¨å³ç›¸æœºæˆåƒé¢ä¸Šçš„æ¨ªåæ ‡æ˜¯ $x_R$ã€‚</p>\n<ol>\n<li><strong>è§†å·®ï¼ˆDisparityï¼‰å®šä¹‰ï¼š</strong> $d = x_L - x_R$</li>\n<li><strong>æ·±åº¦ï¼ˆDepthï¼‰è®¡ç®—å…¬å¼ï¼š</strong><br />\n$$Z = \\frac{f \\cdot B}{d}$$</li>\n</ol>\n<p><strong>è¿™ä¸ªå…¬å¼å‘Šè¯‰æˆ‘ä»¬ä¸¤ä¸ªå…³é”®ä¿¡æ¯ï¼š</strong></p>\n<ul>\n<li><strong>åæ¯”å…³ç³»ï¼š</strong> æ·±åº¦ $Z$ ä¸Žè§†å·® $d$ æˆåæ¯”ã€‚è§†å·®è¶Šå¤§ï¼Œç‰©ä½“è¶Šè¿‘ã€‚</li>\n<li><strong>å°ºåº¦ç¡®å®šæ€§ï¼š</strong> ä¸Žå•ç›® SfM ä¸åŒï¼Œç”±äºŽåŸºçº¿ $B$ æ˜¯æå‰æµ‹é‡å¥½çš„ç‰©ç†å¸¸æ•°ï¼ˆæ¯”å¦‚ä¸¤ç›¸æœºé—´è· 6 åŽ˜ç±³ï¼‰ï¼Œæ‰€ä»¥åŒç›®è§†è§‰å¯ä»¥ç›´æŽ¥è®¡ç®—å‡ºç‰©ä½“çš„<strong>çœŸå®žç‰©ç†è·ç¦»</strong>ï¼ˆç±³æˆ–æ¯«ç±³ï¼‰ï¼Œä¸å­˜åœ¨å°ºåº¦ä¸ç¡®å®šæ€§ã€‚</li>\n</ul>\n<hr />\n<h4 id=\"3-æ ‡å‡†ç®—æ³•æµç¨‹stereo-pipeline\">3. æ ‡å‡†ç®—æ³•æµç¨‹ï¼ˆStereo Pipelineï¼‰</h4>\n<p>å®žçŽ°é«˜è´¨é‡çš„åŒç›®é‡å»ºé€šå¸¸éœ€è¦ç»è¿‡ä»¥ä¸‹å››ä¸ªä¸¥è°¨çš„æ­¥éª¤ï¼š</p>\n<p><strong>ç¬¬ä¸€æ­¥ï¼šç›¸æœºæ ‡å®šï¼ˆCamera Calibrationï¼‰</strong></p>\n<ul>\n<li><strong>ç›®çš„ï¼š</strong> ç¡®å®šç›¸æœºçš„å†…å‚ï¼ˆç„¦è·ã€ä¸­å¿ƒç‚¹ï¼‰å’Œå¤–å‚ï¼ˆä¸¤ç›¸æœºä¹‹é—´çš„ç²¾ç¡®æ—‹è½¬å’Œå¹³ç§»å…³ç³»ï¼‰ã€‚</li>\n<li><strong>æ„ä¹‰ï¼š</strong> å¦‚æžœç›¸æœºé•œå¤´æœ‰ç•¸å˜ï¼ˆæ¯”å¦‚é±¼çœ¼æ•ˆæžœï¼‰ï¼Œæˆ–è€…ä¸¤ä¸ªç›¸æœºæ²¡è£…æ­£ï¼ŒåŽç»­è®¡ç®—å…¨æ˜¯é”™çš„ã€‚</li>\n</ul>\n<p><strong>ç¬¬äºŒæ­¥ï¼šç«‹ä½“æ ¡æ­£ï¼ˆStereo Rectificationï¼‰â€”â€” æžå…³é”®</strong></p>\n<ul>\n<li><strong>åšä»€ä¹ˆï¼š</strong> é€šè¿‡æ•°å­¦å˜æ¢ï¼ŒæŠŠæ‹æ‘„æ—¶çš„ä¸¤å¼ ç…§ç‰‡å¯¹é½ï¼Œä½¿å¾—å·¦å³å›¾åƒçš„<strong>æžçº¿ï¼ˆEpipolar Lineï¼‰å¤„äºŽåŒä¸€æ°´å¹³çº¿ä¸Š</strong>ã€‚</li>\n<li><strong>æ„ä¹‰ï¼š</strong> æ ¡æ­£åŽï¼Œå·¦å›¾ä¸­çš„ä¸€ä¸ªç‚¹ï¼Œåœ¨å³å›¾ä¸­ä¸€å®šèƒ½åœ¨<strong>åŒä¸€è¡Œ</strong>æ‰¾åˆ°ã€‚è¿™æŠŠä¸€ä¸ª 2D çš„æœç´¢é—®é¢˜é™ç»´æˆäº† 1D æœç´¢ï¼Œæžå¤§åœ°æé«˜äº†è¿ç®—é€Ÿåº¦ã€‚</li>\n</ul>\n<p><strong>ç¬¬ä¸‰æ­¥ï¼šç«‹ä½“åŒ¹é…ï¼ˆStereo Matchingï¼‰â€”â€” æœ€æ ¸å¿ƒã€æœ€éš¾</strong></p>\n<ul>\n<li><strong>åšä»€ä¹ˆï¼š</strong> ç®—æ³•è¦åœ¨å³å›¾çš„åŒä¸€è¡Œåƒç´ é‡Œï¼Œæ‰¾åˆ°é‚£ä¸ªå’Œå·¦å›¾ç‚¹â€œé•¿å¾—æœ€åƒâ€çš„ç‚¹ã€‚</li>\n<li><strong>ä¸»æµç®—æ³•ï¼š</strong>\n<ul>\n<li><strong>BM (Block Matching)ï¼š</strong> å¿«ï¼Œä½†ç²¾åº¦ä½Žï¼Œè¾¹ç¼˜ç²—ç³™ã€‚</li>\n<li><strong>SGM (Semi-Global Matching)ï¼š</strong> å·¥ä¸šç•Œçš„ä¸»æµï¼Œåœ¨é€Ÿåº¦å’Œç²¾åº¦é—´å–å¾—äº†æžä½³å¹³è¡¡ã€‚</li>\n<li><strong>æ·±åº¦å­¦ä¹ æ–¹æ³•ï¼š</strong> å¦‚ PSMNetï¼Œåˆ©ç”¨ç¥žç»ç½‘ç»œç›´æŽ¥è¾“å‡ºè§†å·®å›¾ï¼Œåœ¨å¤„ç†æ— çº¹ç†åŒºåŸŸè¡¨çŽ°æ›´å¥½ã€‚</li>\n</ul>\n</li>\n</ul>\n<p><strong>ç¬¬å››æ­¥ï¼šè§†å·®è½¬æ·±åº¦ï¼ˆDisparity to Depthï¼‰</strong></p>\n<ul>\n<li><strong>åšä»€ä¹ˆï¼š</strong> åˆ©ç”¨å‰é¢æåˆ°çš„å…¬å¼ $Z = (f \\cdot B) / d$ï¼Œå°†åƒç´ çº§çš„è§†å·®å›¾è½¬åŒ–ä¸ºç‰©ç†ä¸–ç•Œçš„æ·±åº¦å›¾ã€‚</li>\n</ul>\n<hr />\n<h4 id=\"4-åŒç›®è§†è§‰-vs-å•ç›®-sfm-çš„åŒºåˆ«\">4. åŒç›®è§†è§‰ vs. å•ç›® SfM çš„åŒºåˆ«</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">ç‰¹æ€§</th>\n<th style=\"text-align: left;\">åŒç›®ç«‹ä½“è§†è§‰ (Stereo)</th>\n<th style=\"text-align: left;\">å•ç›® SfM</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>ç›¸æœºæ•°é‡</strong></td>\n<td style=\"text-align: left;\">2å°æˆ–å¤šå°</td>\n<td style=\"text-align: left;\">1å°</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>æ‹æ‘„çŠ¶æ€</strong></td>\n<td style=\"text-align: left;\">å¯ä»¥é™æ€æ‹æ‘„ï¼ˆçž¬é—´æˆåƒï¼‰</td>\n<td style=\"text-align: left;\">å¿…é¡»ç§»åŠ¨ç›¸æœºï¼ˆåŠ¨æ€æ‹æ‘„ï¼‰</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>å°ºåº¦æ„ŸçŸ¥</strong></td>\n<td style=\"text-align: left;\">è‡ªåŠ¨èŽ·å¾—çœŸå®žç‰©ç†å°ºåº¦</td>\n<td style=\"text-align: left;\">æ— æ³•èŽ·å¾—çœŸå®žå°ºåº¦ï¼ˆä»…æœ‰æ¯”ä¾‹ï¼‰</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>å®žæ—¶æ€§</strong></td>\n<td style=\"text-align: left;\">é«˜ï¼ˆé€‚åˆé¿éšœã€æœºå™¨äººï¼‰</td>\n<td style=\"text-align: left;\">ä½Žï¼ˆè®¡ç®—é‡å¤§ï¼Œéœ€è¿åŠ¨åºåˆ—ï¼‰</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>é€‚ç”¨èŒƒå›´</strong></td>\n<td style=\"text-align: left;\">é€‚åˆè¿‘è·ç¦»ã€é«˜ç²¾åº¦æ„ŸçŸ¥</td>\n<td style=\"text-align: left;\">é€‚åˆå¤§åœºæ™¯ã€è¿œè·ç¦»å»ºæ¨¡</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h4 id=\"5-é€‚ç”¨åœºæ™¯ä¸Žå±€é™æ€§\">5. é€‚ç”¨åœºæ™¯ä¸Žå±€é™æ€§</h4>\n<p><strong>é€‚ç”¨åœºæ™¯ï¼š</strong></p>\n<ul>\n<li><strong>è½¦è½½è¾…åŠ©é©¾é©¶ï¼ˆADASï¼‰ï¼š</strong> è¯†åˆ«å‰æ–¹éšœç¢ç‰©è·ç¦»ã€‚</li>\n<li><strong>å·¥ä¸šæŠ“å–ï¼š</strong> æœºæ¢°è‡‚è¯†åˆ«é›¶ä»¶çš„ 3D ä½ç½®ã€‚</li>\n<li><strong>æ— äººæœºé¿éšœï¼š</strong> å®žæ—¶æ„ŸçŸ¥å‘¨å›´å¢™ä½“è·ç¦»ã€‚</li>\n</ul>\n<p><strong>å±€é™æ€§ï¼š</strong></p>\n<ol>\n<li><strong>çŽ¯å¢ƒçº¹ç†ä¾èµ–ï¼š</strong> å¦‚æžœå¢™é¢æ˜¯çº¯ç™½è‰²çš„ï¼Œç®—æ³•æ— æ³•åœ¨å³å›¾ä¸­æ‰¾åˆ°åŒ¹é…çš„ç‚¹ï¼ˆå› ä¸ºçœ‹èµ·æ¥éƒ½ä¸€æ ·ï¼‰ï¼Œä¼šå¯¼è‡´æ·±åº¦ä¸¢å¤±ã€‚</li>\n<li><strong>åŸºçº¿é™åˆ¶ï¼š</strong> æµ‹é‡è·ç¦»å—é™äºŽåŸºçº¿ $B$ã€‚å¦‚æžœè¦æµ‹ 100 ç±³å¤–çš„ç‰©ä½“ï¼ŒåŸºçº¿å¿…é¡»è¶³å¤Ÿå®½ï¼Œå¦åˆ™è§†å·® $d$ å¤ªå°ï¼Œä¼šå¯¼è‡´è¯¯å·®å‰§å¢žã€‚</li>\n<li><strong>é®æŒ¡é—®é¢˜ï¼š</strong> å·¦çœ¼çœ‹å¾—åˆ°çš„åœ°æ–¹ï¼Œå³çœ¼å¯èƒ½è¢«æŒ¡ä½äº†ï¼ˆæš—å½±åŒºï¼‰ï¼Œå¯¼è‡´æ— æ³•è®¡ç®—ã€‚</li>\n</ol>\n<hr />\n<h4 id=\"6-å‚è€ƒèµ„æ–™ä¸Žç»å…¸æ–‡çŒ®\">6. å‚è€ƒèµ„æ–™ä¸Žç»å…¸æ–‡çŒ®</h4>\n<ol>\n<li><strong>Scharstein, D., &amp; Szeliski, R. (2002).</strong> <em>A taxonomy and evaluation of dense two-frame stereo correspondence algorithms</em>. International Journal of Computer Vision.<br />\n(ç«‹ä½“åŒ¹é…é¢†åŸŸçš„åŸºçŸ³è®ºæ–‡ï¼Œå®šä¹‰äº†è¯„ä¼°æ ‡å‡†)ã€‚</li>\n<li><strong>Hirschmuller, H. (2005).</strong> <em>Accurate and efficient stereo processing by semi-global matching and mutual information</em>. CVPR.<br />\n(æå‡ºäº†è‘—åçš„ <strong>SGM ç®—æ³•</strong>ï¼Œè‡³ä»Šä»æ˜¯è¯¥é¢†åŸŸçš„å·¥ä¸šæ ‡å‡†)ã€‚</li>\n<li><strong>Marr, D., &amp; Poggio, T. (1979).</strong> <em>A computational theory of human stereo vision</em>. Proceedings of the Royal Society of London.<br />\n(ä»Žç”Ÿç‰©å­¦å’Œè®¡ç®—è§†è§‰è§’åº¦è§£é‡Šäº†äººç±»åŒçœ¼å¦‚ä½•æ„ŸçŸ¥æ·±åº¦)ã€‚</li>\n<li><strong>Konolige, K. (1998).</strong> <em>Small Vision Systems: Hardware and Implementation</em>. International Symposium on Robotics Research.<br />\n(è®²è§£äº†å®žæ—¶åŒç›®è§†è§‰ç³»ç»Ÿçš„æ—©æœŸç¡¬ä»¶å®žçŽ°)ã€‚</li>\n<li><strong>Zhang, Z. (2000).</strong> <em>A flexible new technique for camera calibration</em>. IEEE Transactions on Pattern Analysis and Machine Intelligence.<br />\n(è‘—åçš„â€œå¼ æ°æ ‡å®šæ³•â€ï¼ŒåŒç›®ç›¸æœºæ ‡å®šçš„å¿…å¤‡åŸºç¡€)ã€‚</li>\n</ol>\n<h3 id=\"c-ç¥žç»è¾å°„åœºnerf-neural-radiance-fields\">C. ç¥žç»è¾å°„åœºï¼ˆNeRF, Neural Radiance Fieldsï¼‰</h3>\n<pre><code>*   **å‰æ²¿ï¼š** 2020å¹´åŽçš„çˆ†å‘æ€§æŠ€æœ¯ã€‚åˆ©ç”¨æ·±åº¦å­¦ä¹ å°†åœºæ™¯è¡¨ç¤ºä¸ºä¸€ä¸ªè¿žç»­çš„ä½“ç§¯åœºï¼Œé€šè¿‡ä½“æ¸²æŸ“æŠ€æœ¯ç”Ÿæˆæžå…¶é€¼çœŸçš„3Dè§†å›¾ã€‚\n</code></pre>\n<p>å¦‚æžœè¯´ <strong>SfM</strong> æ˜¯åœ¨åšâ€œå‡ ä½•é¢˜â€ï¼Œ<strong>åŒç›®è§†è§‰</strong>æ˜¯åœ¨åšâ€œç‰©ç†é¢˜â€ï¼Œé‚£ä¹ˆ <strong>NeRFï¼ˆNeural Radiance Fieldsï¼Œç¥žç»è¾å°„åœºï¼‰</strong> å°±æ˜¯åœ¨ç”¨â€œäººå·¥æ™ºèƒ½ç®—æ³•â€è¿›è¡Œä¸€æ¬¡é©å‘½æ€§çš„<strong>è‰ºæœ¯åˆ›ä½œ</strong>ã€‚</p>\n<p>NeRF æ˜¯ 2020 å¹´è®¡ç®—æœºè§†è§‰é¢†åŸŸæœ€å…·é¢ è¦†æ€§çš„æŠ€æœ¯ä¹‹ä¸€ã€‚å®ƒå½»åº•æ”¹å˜äº†æˆ‘ä»¬å­˜å‚¨å’Œè¡¨çŽ° 3D ä¸–ç•Œçš„æ–¹å¼ã€‚</p>\n<hr />\n<h4 id=\"1-ä»€ä¹ˆæ˜¯-nerf\">1. ä»€ä¹ˆæ˜¯ NeRFï¼Ÿ</h4>\n<p><strong>å®šä¹‰ï¼š</strong><br />\nNeRF æ˜¯ä¸€ç§åˆ©ç”¨<strong>æ·±åº¦ç¥žç»ç½‘ç»œï¼ˆé€šå¸¸æ˜¯å¤šå±‚æ„ŸçŸ¥æœº MLPï¼‰</strong>æ¥éšå¼åœ°è¡¨ç¤º 3D åœºæ™¯çš„æŠ€æœ¯ã€‚å®ƒä¸å­˜å‚¨ç‚¹äº‘ï¼Œä¹Ÿä¸å­˜å‚¨ä¸‰è§’é¢ç‰‡ï¼Œè€Œæ˜¯å°†æ•´ä¸ª 3D åœºæ™¯ç¼–ç è¿›ä¸€ä¸ªç¥žç»ç½‘ç»œçš„<strong>æƒé‡</strong>é‡Œã€‚</p>\n<p><strong>æ ¸å¿ƒç›´è§‰ï¼š</strong><br />\næƒ³è±¡ç©ºé—´ä¸­å……æ»¡äº†â€œå¸¦é¢œè‰²çš„çƒŸé›¾â€ã€‚åœ¨æ¯ä¸€ä¸ªåæ ‡ç‚¹ä¸Šï¼ŒçƒŸé›¾éƒ½æœ‰ç‰¹å®šçš„é¢œè‰²å’Œæµ“åº¦ã€‚NeRF çš„ç›®æ ‡æ˜¯è®­ç»ƒä¸€ä¸ª AI åŠ©æ‰‹ï¼Œå½“ä½ é—®å®ƒï¼šâ€œåœ¨åæ ‡ $(x, y, z)$ è¿™ä¸ªç‚¹ï¼Œä»Ž $(\\theta, \\phi)$ è¿™ä¸ªè§’åº¦çœ‹è¿‡åŽ»æ˜¯ä»€ä¹ˆé¢œè‰²ï¼Ÿâ€å®ƒèƒ½ç«‹åˆ»è®¡ç®—å‡ºç»“æžœã€‚</p>\n<hr />\n<h4 id=\"2-nerf-çš„æ ¸å¿ƒåŽŸç†5d-å‡½æ•°\">2. NeRF çš„æ ¸å¿ƒåŽŸç†ï¼š5D å‡½æ•°</h4>\n<p>NeRF å°†åœºæ™¯è¡¨ç¤ºä¸ºä¸€ä¸ªè¿žç»­çš„ <strong>5D å‡½æ•°</strong>ï¼š</p>\n<ul>\n<li><strong>è¾“å…¥ (5ä¸ªå‚æ•°)ï¼š</strong> ç©ºé—´ä½ç½® $(x, y, z)$ + è§‚å¯Ÿè§†è§’ $(\\theta, \\phi)$ã€‚</li>\n<li><strong>è¾“å‡º (4ä¸ªå‚æ•°)ï¼š</strong> è¯¥ç‚¹çš„é¢œè‰² $RGB$ + è¯¥ç‚¹çš„ä½“ç§¯å¯†åº¦ $\\sigma$ï¼ˆå³å…‰çº¿é€šè¿‡è¿™é‡Œçš„é˜»åŠ›ï¼Œä»£è¡¨ç‰©ä½“æ˜¯å¦å­˜åœ¨ï¼‰ã€‚<br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></li>\n</ul>\n<ol>\n<li><strong>éšå¼è¡¨ç¤ºï¼ˆImplicit Representationï¼‰ï¼š</strong><br />\nä¼ ç»Ÿçš„ 3D æ¨¡åž‹åƒâ€œä¹é«˜ç§¯æœ¨â€ï¼ˆä½“ç´ ï¼‰æˆ–â€œæŠ˜çº¸â€ï¼ˆç½‘æ ¼ï¼‰ã€‚NeRF åƒâ€œä¸€æ®µä»£ç â€ï¼Œä½ ç»™å®ƒåæ ‡ï¼Œå®ƒåå‡ºé¢œè‰²ã€‚è¿™ä½¿å¾—å®ƒèƒ½è¡¨çŽ°æžå…¶ç²¾ç»†çš„ç»†èŠ‚ï¼Œè€Œä¸éœ€è¦æµ·é‡çš„å­˜å‚¨ç©ºé—´ã€‚</li>\n<li><strong>ä½ç½®ç¼–ç ï¼ˆPositional Encodingï¼‰ï¼š</strong><br />\nè¿™æ˜¯ NeRF èƒ½ç«çš„å…³é”®ã€‚ç¥žç»ç½‘ç»œå¤©ç”Ÿå€¾å‘äºŽå­¦ä¹ â€œå¹³æ»‘â€çš„ä¸œè¥¿ï¼Œå®¹æ˜“æŠŠå›¾åƒå˜æ¨¡ç³Šã€‚NeRF é€šè¿‡æŠŠåæ ‡è½¬æ¢æˆé«˜é¢‘æ­£å¼¦/ä½™å¼¦æ³¢ï¼Œå¼ºåˆ¶ç½‘ç»œè®°ä½ç»†èŠ‚ï¼ˆå¦‚ç‰©ä½“çš„è¾¹ç¼˜ã€ç»†å°çš„çº¹ç†ï¼‰ã€‚</li>\n<li><strong>å¯å¾®ä½“æ¸²æŸ“ï¼ˆDifferentiable Volume Renderingï¼‰ï¼š</strong><br />\nè¿™æ˜¯ NeRF çš„â€œæ¸²æŸ“å¼•æ“Žâ€ã€‚å®ƒæ²¿ç€ç›¸æœºå°„å‡ºçš„ä¸€æ¡å…‰çº¿è¿›è¡Œé‡‡æ ·ï¼ŒæŠŠè·¯å¾„ä¸Šæ‰€æœ‰ç‚¹çš„é¢œè‰²å’Œå¯†åº¦åŠ æƒç´¯åŠ ï¼Œæœ€ç»ˆå¾—åˆ°ä¸€ä¸ªåƒç´ çš„é¢œè‰²ã€‚å› ä¸ºæ•´ä¸ªè¿‡ç¨‹æ˜¯<strong>æ•°å­¦å¯å¯¼</strong>çš„ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡å¯¹æ¯”ç”Ÿæˆçš„å›¾åƒå’ŒçœŸå®žç…§ç‰‡çš„å·®å¼‚ï¼Œåˆ©ç”¨<strong>åå‘ä¼ æ’­</strong>æ¥è®­ç»ƒç½‘ç»œã€‚</li>\n</ol>\n<hr />\n<h4 id=\"3-nerf-çš„å·¥ä½œæµç¨‹\">3. NeRF çš„å·¥ä½œæµç¨‹</h4>\n<ol>\n<li><strong>å‡†å¤‡æ•°æ®ï¼š</strong> æ‹æ‘„å‡ åå¼ åˆ°ä¸Šç™¾å¼ ç‰©ä½“çš„ç…§ç‰‡ï¼Œå¹¶åˆ©ç”¨ <strong>SfM (å¦‚ COLMAP)</strong> ç®—å‡ºæ¯å¼ ç…§ç‰‡æ‹æ‘„æ—¶çš„ç²¾ç¡®ç›¸æœºä½ç½®ã€‚</li>\n<li><strong>å…‰çº¿æŠ•å°„ï¼š</strong> å¯¹äºŽå›¾åƒä¸Šçš„æ¯ä¸ªåƒç´ ï¼Œä»Žç›¸æœºä¸­å¿ƒå°„å‡ºä¸€æ¡ç©¿è¿‡è¯¥åƒç´ çš„å…‰çº¿ã€‚</li>\n<li><strong>é‡‡æ ·ä¸ŽæŸ¥è¯¢ï¼š</strong> åœ¨è¿™æ¡å…‰çº¿ä¸Šé‡‡æ ·æˆç™¾ä¸Šåƒä¸ªç‚¹ï¼ŒæŠŠè¿™äº›ç‚¹çš„åæ ‡ä¸¢è¿›ç¥žç»ç½‘ç»œé‡Œã€‚</li>\n<li><strong>åˆæˆé¢œè‰²ï¼š</strong> ç¥žç»ç½‘ç»œè¾“å‡ºè¿™äº›ç‚¹çš„é¢œè‰²å’Œå¯†åº¦ï¼Œé€šè¿‡ä½“æ¸²æŸ“å…¬å¼æŠŠå®ƒä»¬â€œæåˆâ€æˆä¸€ä¸ªåƒç´ é¢œè‰²ã€‚</li>\n<li><strong>ä¼˜åŒ–æƒé‡ï¼š</strong> æ¯”è¾ƒ AI ç”Ÿæˆçš„åƒç´ å’Œç…§ç‰‡é‡Œçš„çœŸå®žåƒç´ ã€‚å¦‚æžœä¸ä¸€æ ·ï¼Œå°±è°ƒæ•´ç¥žç»ç½‘ç»œçš„å‚æ•°ã€‚é‡å¤æˆåƒä¸Šä¸‡æ¬¡ï¼Œç›´åˆ°ç½‘ç»œèƒ½å®Œç¾Žé¢„æµ‹å‡ºä»»ä½•è§’åº¦çš„ç”»é¢ã€‚</li>\n</ol>\n<hr />\n<h4 id=\"4-ä¸ºä»€ä¹ˆ-nerf-æ•ˆæžœè¿™ä¹ˆéœ‡æ’¼\">4. ä¸ºä»€ä¹ˆ NeRF æ•ˆæžœè¿™ä¹ˆéœ‡æ’¼ï¼Ÿ</h4>\n<ul>\n<li><strong>ç…§ç‰‡çº§çš„çœŸå®žæ„Ÿï¼š</strong> å®ƒèƒ½å®Œç¾Žå¤„ç†å…‰æ³½è¡¨é¢ï¼ˆå¦‚é‡‘å±žçš„åå…‰ï¼‰ã€é€æ˜Žç‰©ä½“ï¼ˆå¦‚çŽ»ç’ƒæ¯ï¼‰ä»¥åŠæžå…¶å¤æ‚çš„å‡ ä½•ç»“æž„ï¼ˆå¦‚å¤´å‘ã€æ ‘å¶ï¼‰ï¼Œè¿™äº›éƒ½æ˜¯ä¼ ç»Ÿç‚¹äº‘æˆ– Mesh çš„å™©æ¢¦ã€‚</li>\n<li><strong>æ— é™çš„åˆ†è¾¨çŽ‡ï¼š</strong> å› ä¸ºæ˜¯è¿žç»­å‡½æ•°ï¼Œç†è®ºä¸Šä½ å¯ä»¥æ— é™æ”¾å¤§åœºæ™¯ã€‚</li>\n<li><strong>è§†è§’æ’å€¼ï¼š</strong> ä½ åªæ‹äº† 20 å¼ ç…§ç‰‡ï¼Œä½† NeRF å¯ä»¥ç”Ÿæˆç›¸æœºä»Žæœªç»è¿‡çš„ä½ç½®çš„å¹³æ»‘è§†é¢‘ï¼Œæ•ˆæžœå°±åƒåœ¨å¥½èŽ±åžç”µå½±é‡Œç©¿æ¢­ä¸€æ ·ã€‚</li>\n</ul>\n<hr />\n<h4 id=\"5-å±€é™æ€§ä¸Žç›®å‰çš„ç“¶é¢ˆ\">5. å±€é™æ€§ä¸Žç›®å‰çš„ç“¶é¢ˆ</h4>\n<p>å°½ç®¡æ•ˆæžœæƒŠè‰³ï¼Œä½†åŽŸç”Ÿ NeRF å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š</p>\n<ol>\n<li><strong>è®­ç»ƒæžæ…¢ï¼š</strong> 2020 å¹´åˆšå‡ºæ¥æ—¶ï¼Œè®­ç»ƒä¸€ä¸ªåœºæ™¯éœ€è¦å‡ å°æ—¶ç”šè‡³å‡ å¤©ã€‚</li>\n<li><strong>æ¸²æŸ“ï¼ˆæŽ¨ç†ï¼‰æžæ…¢ï¼š</strong> ç”Ÿæˆä¸€å¼ å›¾éœ€è¦å‡ ç§’é’Ÿï¼Œæ— æ³•åšåˆ°å®žæ—¶äº’åŠ¨ã€‚</li>\n<li><strong>åœºæ™¯æ˜¯æ­»æ¿çš„ï¼š</strong> åŽŸç”Ÿ NeRF åªèƒ½é‡å»ºé™æ€åœºæ™¯ï¼Œå¦‚æžœç”»é¢é‡Œæœ‰ä¸œè¥¿åœ¨åŠ¨ï¼Œæˆ–è€…å…‰çº¿å˜äº†ï¼Œæ¨¡åž‹å°±ä¼šå´©æºƒã€‚</li>\n<li><strong>éœ€è¦ç›¸æœºä½å§¿ï¼š</strong> å®ƒæžå…¶ä¾èµ– SfM æä¾›çš„ç²¾ç¡®åæ ‡ï¼Œå¦‚æžœç…§ç‰‡ä½å§¿ç®—é”™äº†ï¼ŒNeRF å‡ºæ¥çš„ç»“æžœä¼šæ˜¯ä¸€å›¢æµ†ç³Šã€‚</li>\n</ol>\n<hr />\n<h4 id=\"6-è¿›åŒ–ä¹‹è·¯nerf-çš„å­å­™ä»¬\">6. è¿›åŒ–ä¹‹è·¯ï¼ˆNeRF çš„å­å­™ä»¬ï¼‰</h4>\n<p>ä¸ºäº†è§£å†³ä¸Šè¿°é—®é¢˜ï¼Œè¯žç”Ÿäº†ä¸€ç³»åˆ—å˜ä½“ï¼š</p>\n<ul>\n<li><strong>Instant-NGP (NVIDIA)ï¼š</strong> å°†è®­ç»ƒæ—¶é—´ä»Žå°æ—¶çº§ç¼©çŸ­åˆ°äº†<strong>ç§’çº§</strong>ã€‚</li>\n<li><strong>Mip-NeRFï¼š</strong> è§£å†³äº†ç‰©ä½“åœ¨è¿œè¿‘åˆ‡æ¢æ—¶çš„é”¯é½¿é—®é¢˜ã€‚</li>\n<li><strong>D-NeRF / NSVFï¼š</strong> å°è¯•å¤„ç†ä¼šåŠ¨çš„ç‰©ä½“ï¼ˆåŠ¨æ€åœºæ™¯ï¼‰ã€‚</li>\n<li><strong>3D Gaussian Splatting (2023)ï¼š</strong> è™½ç„¶ä¸å®Œå…¨æ˜¯ NeRFï¼Œä½†å®ƒå¸å–äº† NeRF çš„æ€æƒ³ï¼Œå®žçŽ°äº†<strong>çœŸæ­£å®žæ—¶</strong>çš„é«˜è´¨é‡æ¸²æŸ“ï¼Œæ˜¯ç›®å‰æœ€ç«çš„æ›¿ä»£æ–¹æ¡ˆã€‚</li>\n</ul>\n<hr />\n<h4 id=\"7-å‚è€ƒæ–‡çŒ®\">7. å‚è€ƒæ–‡çŒ®</h4>\n<ol>\n<li><strong>Mildenhall, B., Srinivasan, P. P., Tancik, M., Barron, J. T., Ramamoorthi, R., &amp; Ng, R. (2020).</strong> <em>NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis</em>.<br />\nECCV. (NeRF çš„å¼€å±±ä¹‹ä½œ)ã€‚</li>\n<li><strong>MÃ¼ller, T., Evans, A., Schied, C., &amp; Keller, A. (2022).</strong> <em>Instant Neural Graphics Primitives with a Multiresolution Hash Encoding</em>. ACM Transactions on Graphics.<br />\n(NVIDIA æå‡ºçš„ Instant-NGPï¼Œè®© NeRF èµ°å‘å®žç”¨åŒ–)ã€‚</li>\n<li><strong>Barron, J. T., et al. (2021).</strong> <em>Mip-NeRF: A Multiscale Representation for Anti-Aliasing Neural Radiance Fields</em>. ICCV.<br />\n(è§£å†³äº†æŠ—é”¯é½¿å’Œå¤šå°ºåº¦é—®é¢˜)ã€‚</li>\n<li><strong>Tancik, M., et al. (2022).</strong> <em>Block-NeRF: Scalable Large Scene Neural View Synthesis</em>. CVPR.<br />\n(è¯æ˜Žäº† NeRF å¯ä»¥ç”¨æ¥é‡å»ºæ•´ä¸ªåŸŽå¸‚è¡—é“)ã€‚</li>\n<li><strong>Martin-Brualla, R., et al. (2021).</strong> <em>NeRF in the Wild: Neural Radiance Fields for Unconstrained Photo Collections</em>. CVPR.<br />\n(è§£å†³äº†åˆ©ç”¨äº’è”ç½‘ä¹±ä¸ƒå…«ç³Ÿçš„ç…§ç‰‡è¿›è¡Œé‡å»ºçš„é—®é¢˜)ã€‚</li>\n</ol>\n<h3 id=\"d-3d-gaussian-splatting-3dgs\">D. 3D Gaussian Splatting (3DGS)ï¼š</h3>\n<p><strong>æœ€æ–°ï¼š</strong> 2023å¹´å‡ºçŽ°çš„æŠ€æœ¯ï¼Œé€šè¿‡å¤§é‡3Dé«˜æ–¯æ¤­çƒä½“æ‹Ÿåˆåœºæ™¯ï¼Œå®žçŽ°äº†æ¯”NeRFæ›´å¿«çš„æ¸²æŸ“é€Ÿåº¦å’Œæžé«˜çš„é‡å»ºè´¨é‡ã€‚</p>\n<p>å¦‚æžœè¯´ <strong>NeRF</strong> æ˜¯ 3D é‡å»ºé¢†åŸŸçš„â€œæ•°å­—å¹»è§‰â€ï¼Œé‚£ä¹ˆ <strong>3D Gaussian Splatting (3DGS)</strong> å°±æ˜¯åœ¨ 2023 å¹´æ¨ªç©ºå‡ºä¸–çš„â€œæ•°å­—ç”»ç¬”â€ã€‚</p>\n<p>3DGS çš„å‡ºçŽ°ç›´æŽ¥è§£å†³äº† NeRF æ¸²æŸ“æ…¢ã€è®­ç»ƒä¹…çš„æ ¸å¿ƒç—›ç‚¹ï¼Œå°† 3D é‡å»ºæŽ¨å‘äº†<strong>å®žæ—¶ã€é«˜ç”»è´¨ã€å¯äº¤äº’</strong>çš„æ–°çºªå…ƒã€‚</p>\n<hr />\n<h4 id=\"1-ä»€ä¹ˆæ˜¯-3d-gaussian-splatting-3dgs\">1. ä»€ä¹ˆæ˜¯ 3D Gaussian Splatting (3DGS)ï¼Ÿ</h4>\n<p><strong>å®šä¹‰ï¼š</strong><br />\n3DGS æ˜¯ä¸€ç§åŸºäºŽ<strong>æ˜¾å¼è¾å°„åœºï¼ˆExplicit Radiance Fieldï¼‰</strong>çš„åœºæ™¯è¡¨ç¤ºæŠ€æœ¯ã€‚å®ƒä¸ä½¿ç”¨ç¥žç»ç½‘ç»œæ¥â€œçŒœâ€é¢œè‰²ï¼Œè€Œæ˜¯ç›´æŽ¥åœ¨ç©ºé—´ä¸­æŠ›æ´’æ•°ç™¾ä¸‡ä¸ªå¸¦æœ‰é¢œè‰²ã€å½¢çŠ¶å’Œé€æ˜Žåº¦çš„<strong>3D é«˜æ–¯æ¤­çƒä½“ï¼ˆGaussian Kernelsï¼‰</strong>ï¼Œé€šè¿‡è¿™äº›æ¤­çƒä½“çš„å åŠ æ¥æ‹¼å‡‘å‡ºæ•´ä¸ªä¸–ç•Œã€‚</p>\n<p><strong>å½¢è±¡æ¯”å–»ï¼š</strong></p>\n<ul>\n<li><strong>NeRF</strong> åƒæ˜¯ä¸€ä¸ªè®°å¿†åŠ›è¶…å¼ºçš„ç”»å¸ˆï¼šä½ é—®ä»–ç”»é‡ŒæŸä¸ªåæ ‡æ˜¯ä»€ä¹ˆé¢œè‰²ï¼Œä»–æƒ³ä¸€ä¸‹å‘Šè¯‰ä½ ã€‚</li>\n<li><strong>3DGS</strong> åƒæ˜¯ä¸€ä¸ªè´´çº¸å¤§å¸ˆï¼šä»–ç›´æŽ¥åœ¨é€æ˜Žçš„ç©ºé—´é‡Œè´´äº†æ•°ç™¾ä¸‡å¼ åŠé€æ˜Žçš„å½©è‰²è´´çº¸ï¼ˆæ¤­çƒä½“ï¼‰ï¼Œä½ ä»Žä»»ä½•è§’åº¦çœ‹è¿‡åŽ»ï¼Œè¿™äº›è´´çº¸å åŠ åœ¨ä¸€èµ·å°±æ˜¯ä¸€å¼ å®Œç¾Žçš„ç…§ç‰‡ã€‚</li>\n</ul>\n<hr />\n<h4 id=\"2-æ ¸å¿ƒåŽŸç†3d-é«˜æ–¯æ¤­çƒä½“çš„åŸºå› \">2. æ ¸å¿ƒåŽŸç†ï¼š3D é«˜æ–¯æ¤­çƒä½“çš„â€œåŸºå› â€</h4>\n<p>æ¯ä¸€ä¸ª 3D é«˜æ–¯æ¤­çƒä½“éƒ½åŒ…å«äº†ä¸€ç»„æžå…¶ç²¾ç®€çš„æ•°å­¦å‚æ•°ï¼ˆåŸºå› ï¼‰ï¼š</p>\n<ol>\n<li><strong>ä¸­å¿ƒä½ç½® (Position, $X, Y, Z$)ï¼š</strong> æ¤­çƒä½“åœ¨å“ªã€‚</li>\n<li><strong>åæ–¹å·®çŸ©é˜µ (Covariance, $\\Sigma$)ï¼š</strong> å†³å®šæ¤­çƒä½“çš„<strong>å½¢çŠ¶å’Œæ–¹å‘</strong>ã€‚ä¸ºäº†æ–¹ä¾¿è®¡ç®—ï¼Œå®ƒè¢«åˆ†è§£ä¸ºï¼š\n<ul>\n<li><strong>ç¼©æ”¾ (Scaling)ï¼š</strong> å®ƒæ˜¯é•¿çš„ã€åœ†çš„è¿˜æ˜¯æ‰çš„ã€‚</li>\n<li><strong>æ—‹è½¬ (Rotation)ï¼š</strong> å®ƒæ˜¯æ¨ªç€çš„è¿˜æ˜¯æ–œç€çš„ã€‚</li>\n</ul>\n</li>\n<li><strong>ä¸é€æ˜Žåº¦ (Opacity, $\\alpha$)ï¼š</strong> è¿™ä¸ªæ¤­çƒä½“æœ‰å¤šé€æ˜Žã€‚</li>\n<li><strong>çƒè°å‡½æ•°é¢œè‰² (Spherical Harmonics, SH)ï¼š</strong> è¿™æ˜¯ä¸€ç§ç‰¹æ®Šçš„é¢œè‰²è¡¨ç¤ºæ³•ã€‚å®ƒä¸åªæ˜¯ä¸€ä¸ªå•ä¸€é¢œè‰²ï¼Œè€Œæ˜¯è®°å½•äº†<strong>ä»Žä¸åŒæ–¹å‘çœ‹è¿™ä¸ªç‚¹æ—¶é¢œè‰²çš„å˜åŒ–</strong>ï¼ˆæ¯”å¦‚é‡‘å±žçš„é«˜å…‰ï¼‰ã€‚</li>\n</ol>\n<hr />\n<h4 id=\"3-å·¥ä½œæµç¨‹ä»Žç‚¹äº‘åˆ°ç²¾ç¾Žå»ºæ¨¡\">3. å·¥ä½œæµç¨‹ï¼šä»Žç‚¹äº‘åˆ°ç²¾ç¾Žå»ºæ¨¡</h4>\n<p><strong>ç¬¬ä¸€æ­¥ï¼šåˆå§‹åŒ– (Initialization)</strong><br />\n3DGS é€šå¸¸ä»¥ <strong>SfM (å¦‚ COLMAP)</strong> äº§ç”Ÿçš„ç¨€ç–ç‚¹äº‘ä½œä¸ºèµ·ç‚¹ã€‚æ¯ä¸ªç‚¹è¢«åˆå§‹åŒ–ä¸ºä¸€ä¸ªå°çš„ 3D é«˜æ–¯çƒã€‚</p>\n<p><strong>ç¬¬äºŒæ­¥ï¼šå¯å¾®æŠ•å½±ä¸Žæ¸²æŸ“ (Splatting &amp; Rasterization)</strong><br />\nè¿™æ˜¯ 3DGS é€Ÿåº¦æžå¿«çš„ç§˜è¯€ã€‚</p>\n<ul>\n<li>ç®—æ³•å°† 3D çš„æ¤­çƒä½“å¹³æ‰åŒ–ï¼ˆæŠ•å½±ï¼‰åˆ° 2D å±å¹•ä¸Šï¼Œå˜æˆä¸€ä¸ªä¸ª 2D æ¤­åœ†ã€‚</li>\n<li>é‡‡ç”¨<strong>åŸºäºŽåˆ†å—ï¼ˆTile-basedï¼‰çš„å¿«é€Ÿå…‰æ …åŒ–æ¸²æŸ“å™¨</strong>ã€‚å®ƒå°†å±å¹•åˆ†æˆè®¸å¤šå°æ ¼å­ï¼ˆTilesï¼‰ï¼Œåªæ¸²æŸ“å¯¹è¿™ä¸ªæ ¼å­æœ‰è´¡çŒ®çš„æ¤­çƒä½“ã€‚è¿™ä¸ŽçŽ°ä»£æ˜¾å¡ï¼ˆGPUï¼‰çš„å¤„ç†é€»è¾‘å®Œå…¨åŒ¹é…ã€‚<br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></li>\n</ul>\n<p><strong>ç¬¬ä¸‰æ­¥ï¼šè‡ªé€‚åº”å¯†åº¦æŽ§åˆ¶ (Adaptive Density Control)</strong><br />\nè¿™æ˜¯ 3DGS çš„â€œè¿›åŒ–â€è¿‡ç¨‹ã€‚åœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­ï¼Œç®—æ³•ä¼šè§‚å¯Ÿï¼š</p>\n<ul>\n<li><strong>å…‹éš† (Clone)ï¼š</strong> å¦‚æžœæŸä¸ªåœ°æ–¹å¤ªå¹³æ»‘ï¼Œç‚¹ä¸å¤Ÿç”¨ï¼Œå°±åœ¨é‚£å¤åˆ¶ä¸€ä¸ªç‚¹ã€‚</li>\n<li><strong>åˆ†è£‚ (Split)ï¼š</strong> å¦‚æžœæŸä¸ªæ¤­çƒä½“å¤ªå¤§ã€å¤ªæ¨¡ç³Šï¼Œå°±æŠŠå®ƒæ‹†æˆä¸¤ä¸ªå°çš„ã€‚</li>\n<li><strong>ä¿®å‰ª (Culling)ï¼š</strong> å¦‚æžœæŸä¸ªæ¤­çƒä½“ä¸é€æ˜Žåº¦æžä½Žï¼ŒåŸºæœ¬çœ‹ä¸è§ï¼Œå°±æŠŠå®ƒåˆ æŽ‰ã€‚</li>\n</ul>\n<hr />\n<p><strong>ä¸ºä»€ä¹ˆ 3DGS èƒ½åœ¨ 2023 å¹´å¼•çˆ†æŠ€æœ¯åœˆï¼Ÿ</strong></p>\n<ol>\n<li><strong>æ¸²æŸ“é€Ÿåº¦èµ·é£žï¼š</strong> NeRF æ¸²æŸ“ä¸€å¼ å›¾éœ€è¦å‡ ç§’é’Ÿï¼Œè€Œ 3DGS å¯ä»¥åœ¨æ™®é€šçš„ GPU ä¸Šå®žçŽ° <strong>100+ FPS</strong>ï¼ˆæ¯ç§’å¸§æ•°ï¼‰çš„å®žæ—¶æ¸²æŸ“ã€‚</li>\n<li><strong>è®­ç»ƒæ—¶é—´æžçŸ­ï¼š</strong> ä¸€ä¸ªä¸­ç­‰å¤æ‚çš„åœºæ™¯ï¼ŒNeRF å¯èƒ½è¦è®­ç»ƒå‡ å°æ—¶ï¼Œ3DGS åªéœ€è¦ <strong>5-10 åˆ†é’Ÿ</strong>ã€‚</li>\n<li><strong>æ˜¾å¼å­˜å‚¨ï¼š</strong> å› ä¸ºå®ƒæ˜¯æ•°ç™¾ä¸‡ä¸ªç‚¹ï¼Œä½ å¯ä»¥ç›´æŽ¥åœ¨ 3D è½¯ä»¶é‡Œçœ‹åˆ°è¿™äº›ç‚¹ï¼Œç”šè‡³å¯ä»¥æ‰‹åŠ¨åˆ é™¤ã€ç§»åŠ¨æˆ–ç¼©æ”¾å…¶ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œè¿™åœ¨ NeRF çš„ç¥žç»ç½‘ç»œæƒé‡é‡Œæ˜¯å‡ ä¹Žåšä¸åˆ°çš„ã€‚</li>\n<li><strong>è§†è§‰æ•ˆæžœæƒŠè‰³ï¼š</strong> 3DGS æ•æ‰ç²¾ç»†ç»†èŠ‚ï¼ˆå¦‚æ ‘å¶ã€æ¯›å‘ã€è–„é›¾ï¼‰çš„èƒ½åŠ›æžå¼ºï¼Œç”»é¢è¾¹ç¼˜æ¯” NeRF æ›´åŠ é”åˆ©ã€‚</li>\n</ol>\n<hr />\n<h4 id=\"5-ç›®å‰çš„ç“¶é¢ˆä¸ŽæŒ‘æˆ˜\">5. ç›®å‰çš„ç“¶é¢ˆä¸ŽæŒ‘æˆ˜</h4>\n<ol>\n<li><strong>æ˜¾å­˜åŽ‹åŠ›å¤§ (VRAM Intensive)ï¼š</strong> æ¸²æŸ“è™½ç„¶å¿«ï¼Œä½†è¦åœ¨æ˜¾å­˜é‡Œå­˜å‚¨æ•°ç™¾ä¸‡ä¸ªé«˜æ–¯å‚æ•°ï¼Œéžå¸¸åƒæ˜¾å­˜ï¼ˆé€šå¸¸éœ€è¦ 8GB ä»¥ä¸Šçš„æ˜¾å­˜æ‰èƒ½æµç•…è¿è¡Œå¤§åž‹åœºæ™¯ï¼‰ã€‚</li>\n<li><strong>å­˜å‚¨ç©ºé—´å·¨å¤§ï¼š</strong> ä¸€ä¸ªé«˜è´¨é‡åœºæ™¯çš„æ¨¡åž‹æ–‡ä»¶å¯èƒ½é«˜è¾¾ <strong>æ•°ç™¾ MB ç”šè‡³å‡ ä¸ª GB</strong>ï¼Œè€Œ NeRF åªéœ€è¦å‡  MB çš„ç¥žç»ç½‘ç»œæƒé‡ã€‚</li>\n<li><strong>ä¾èµ–åˆå§‹åŒ–ï¼š</strong> å¦‚æžœ SfM å‡ºæ¥çš„åˆå§‹ç‚¹äº‘å¤ªå·®ï¼ˆæ¯”å¦‚åœ¨å…‰æ»‘å¹³é¢ä¸Šæ²¡å–åˆ°ç‚¹ï¼‰ï¼Œ3DGS å¾ˆéš¾å‡­ç©ºç”Ÿæˆé«˜è´¨é‡çš„æ¤­çƒä½“ï¼Œä¼šå‡ºçŽ°æ˜Žæ˜¾çš„â€œç ´æ´žâ€ã€‚</li>\n<li><strong>ä¼ªå½± (Artifacts)ï¼š</strong> åœ¨è§†è§’å˜åŒ–å‰§çƒˆæ—¶ï¼Œæœ‰æ—¶ä¼šçœ‹åˆ°æ¤­çƒä½“åƒâ€œå½©è‰²é›ªèŠ±â€ä¸€æ ·æ¼‚æµ®ã€‚</li>\n</ol>\n<hr />\n<h4 id=\"6-å‚è€ƒæ–‡çŒ®\">6. å‚è€ƒæ–‡çŒ®</h4>\n<ol>\n<li><strong>Kerbl, B., Kopanas, G., LeimkÃ¼hler, T., &amp; Drettakis, G. (2023).</strong> <em>3D Gaussian Splatting for Real-Time Radiance Field Rendering</em>. ACM Transactions on Graphics (SIGGRAPH).<br />\n(3DGS çš„å¼€å±±é¼»ç¥–ï¼Œç›®å‰è¯¥é¢†åŸŸå¼•ç”¨é‡æœ€é«˜çš„è®ºæ–‡)ã€‚</li>\n<li><strong>Zwicker, M., Pfister, H., van Baar, J., &amp; Gross, M. (2001).</strong> <em>Surface Splatting</em>. SIGGRAPH.<br />\n(3DGS æ ¸å¿ƒæ€æƒ³â€œSplattingâ€çš„æ—©æœŸç†è®ºæ¥æº)ã€‚</li>\n<li><strong>Luan, F., et al. (2024).</strong> <em>GPS-Gaussian: Generalizable Pixel-wise 3D Gaussian Splatting for Real-time Human Novel View Synthesis</em>.<br />\n(å°† 3DGS åº”ç”¨äºŽäººä½“åŠ¨æ€å»ºæ¨¡çš„å‰æ²¿å·¥ä½œ)ã€‚</li>\n<li><strong>Niedermayr, S., et al. (2023).</strong> <em>Compressed 3D Gaussian Splatting for Highly Accessible Novel View Synthesis</em>.<br />\n(é’ˆå¯¹ 3DGS å­˜å‚¨ä½“ç§¯è¿‡å¤§é—®é¢˜çš„æ—©æœŸä¼˜åŒ–ç ”ç©¶)ã€‚</li>\n<li><strong>Chen, Z., et al. (2023).</strong> <em>MCMC-GS: Multi-Scale 3D Gaussian Splatting for Large-Scale Scene Reconstruction</em>.<br />\n(é’ˆå¯¹å¤§è§„æ¨¡åŸŽå¸‚åœºæ™¯çš„ 3DGS æ”¹è¿›ç®—æ³•)ã€‚</li>\n</ol>\n<h2 id=\"äºŒ-ä¸»åŠ¨è§†è§‰active-vision-è‡ªå¸¦å…‰æº\">äºŒ. ä¸»åŠ¨è§†è§‰ï¼ˆActive Visionï¼‰â€”â€” è‡ªå¸¦å…‰æº</h2>\n<p>è¿™ç±»æ–¹æ³•é€šè¿‡å‘ç‰©ä½“å‘å°„ç‰¹å®šå…‰çº¿æ¥è¾…åŠ©æµ‹é‡ã€‚</p>\n<ol>\n<li><strong>ç»“æž„å…‰ï¼ˆStructured Lightï¼‰ï¼š</strong>\n<ul>\n<li><strong>åŽŸç†ï¼š</strong> æŠ•å½±ä»ªå‘ç‰©ä½“æŠ•å°„ç‰¹å®šçš„å…‰æ …å›¾æ¡ˆï¼Œç›¸æœºæ‹æ‘„è¢«ç‰©ä½“è¡¨é¢ç•¸å˜åŽçš„å›¾æ¡ˆï¼Œé€šè¿‡æ•°å­¦è®¡ç®—å¾—å‡ºæ·±åº¦ã€‚</li>\n<li><strong>ä»£è¡¨ï¼š</strong> iPhoneçš„å‰ç½®FaceIDã€‚<br />\nå¦‚æžœè¯´ <strong>SfM</strong> å’Œ<strong>åŒç›®è§†è§‰</strong>æ˜¯åˆ©ç”¨â€œè‡ªç„¶çš„çœ¼ç›â€åŽ»è§‚å¯Ÿä¸–ç•Œï¼Œé‚£ä¹ˆ<strong>ç»“æž„å…‰ï¼ˆStructured Lightï¼‰</strong>åˆ™æ˜¯ç»™æœºå™¨è£…ä¸Šäº†ä¸€å°â€œä¸»åŠ¨æµ‹é‡å°ºâ€ã€‚</li>\n</ul>\n</li>\n</ol>\n<p>å®ƒæ˜¯ç›®å‰é«˜ç²¾åº¦ 3D æ‰«æã€äººè„¸è¯†åˆ«ï¼ˆå¦‚ iPhone FaceIDï¼‰å’Œå·¥ä¸šç²¾å¯†æ£€æµ‹é¢†åŸŸæœ€æ ¸å¿ƒçš„æŠ€æœ¯ã€‚</p>\n<hr />\n<h3 id=\"a-ç»“æž„å…‰æŠ€æœ¯\">A. ç»“æž„å…‰æŠ€æœ¯</h3>\n<h4 id=\"å®šä¹‰-1\"><strong>å®šä¹‰ï¼š</strong></h4>\n<p>ç»“æž„å…‰æ˜¯ä¸€ç§<strong>ä¸»åŠ¨è§†è§‰</strong>æµ‹é‡æŠ€æœ¯ã€‚å®ƒé€šè¿‡æŠ•å½±ä»ªå‘ç‰©ä½“è¡¨é¢æŠ•å°„ç‰¹å®šçš„<strong>å·²çŸ¥å›¾æ¡ˆ</strong>ï¼ˆå¦‚æ ¼ç‚¹ã€æ¡çº¹ã€ç¼–ç å›¾ï¼‰ï¼Œå†ç”±ç›¸æœºæ•æ‰è¿™äº›å›¾æ¡ˆåœ¨ç‰©ä½“è¡¨é¢å‘ç”Ÿçš„<strong>å‡ ä½•ç•¸å˜</strong>ï¼Œé€šè¿‡ä¸‰è§’æµ‹é‡åŽŸç†è®¡ç®—å‡ºç‰©ä½“çš„ä¸‰ç»´ç©ºé—´åæ ‡ã€‚</p>\n<p><strong>å½¢è±¡æ¯”å–»ï¼š</strong><br />\næƒ³è±¡ä½ åœ¨é»‘æš—ä¸­é¢å¯¹ä¸€é¢å‡¹å‡¸ä¸å¹³çš„å¢™ã€‚ä½ æ‰“å¼€ä¸€æ”¯æ‰‹ç”µç­’ï¼Œæ‰‹ç”µç­’çš„å…‰ç½©ä¸Šç”»ç€æ•´é½çš„æ–¹æ ¼ã€‚</p>\n<ul>\n<li>å¦‚æžœå¢™æ˜¯å¹³çš„ï¼Œä½ åœ¨å¢™ä¸Šçœ‹åˆ°çš„æ–¹æ ¼ä¹Ÿæ˜¯æ•´é½çš„ã€‚</li>\n<li>å¦‚æžœå¢™ä¸Šæœ‰ä¸ªå‘æˆ–è€…å‡¸èµ·ï¼Œæ–¹æ ¼çº¿å°±ä¼šå˜å¾—å¼¯æ›²ã€‚</li>\n<li>é€šè¿‡è§‚å¯Ÿæ–¹æ ¼çº¿â€œå¼¯äº†å¤šå°‘â€ï¼Œä½ å°±èƒ½æŽ¨ç®—å‡ºå¢™é¢çš„èµ·ä¼ã€‚è¿™å°±æ˜¯ç»“æž„å…‰ã€‚</li>\n</ul>\n<p><img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></p>\n<hr />\n<h4 id=\"2-æ ¸å¿ƒæ•°å­¦åŽŸç†å˜å½¢çš„ä¸‰è§’æµ‹é‡\">2. æ ¸å¿ƒæ•°å­¦åŽŸç†ï¼šå˜å½¢çš„ä¸‰è§’æµ‹é‡</h4>\n<p>ç»“æž„å…‰æœ¬è´¨ä¸Šæ˜¯<strong>åŒç›®è§†è§‰çš„å˜ç§</strong>ã€‚</p>\n<ul>\n<li>åœ¨åŒç›®è§†è§‰ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ä¸¤ä¸ªç›¸æœºä»Žä¸åŒè§’åº¦çœ‹åŒä¸€ä¸ªç‚¹ã€‚</li>\n<li>åœ¨ç»“æž„å…‰ä¸­ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ª<strong>æŠ•å½±ä»ª</strong>æ›¿ä»£äº†å…¶ä¸­ä¸€ä¸ªç›¸æœºã€‚</li>\n</ul>\n<p><strong>æ•°å­¦é€»è¾‘ï¼š</strong></p>\n<ol>\n<li><strong>å·²çŸ¥æ¡ä»¶ï¼š</strong> æŠ•å½±ä»ªæŠ•å°„å‡ºçš„å…‰æŸè§’åº¦æ˜¯å·²çŸ¥çš„ï¼Œç›¸æœºä¸ŽæŠ•å½±ä»ªä¹‹é—´çš„è·ç¦»ï¼ˆåŸºçº¿ $B$ï¼‰æ˜¯å›ºå®šçš„ã€‚</li>\n<li><strong>å¯»æ‰¾åŒ¹é…ï¼š</strong> æŠ•å½±ä»ªæŠ•å‡ºçš„æ¯ä¸€ä¸ªå…‰ç‚¹ï¼ˆæˆ–çº¿æ¡ï¼‰éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„â€œç¼–ç â€ã€‚ç›¸æœºæ‹åˆ°è¿™ä¸ªç‚¹åŽï¼Œç«‹åˆ»å°±èƒ½çŸ¥é“å®ƒæ˜¯ä»ŽæŠ•å½±ä»ªçš„å“ªä¸ªè§’åº¦å°„å‡ºæ¥çš„ã€‚</li>\n<li><strong>å‡ ä½•æ±‚è§£ï¼š</strong> æŠ•å½±ä»ªå‘å‡ºçš„å°„çº¿ä¸Žç›¸æœºæŽ¥æ”¶åˆ°çš„å°„çº¿åœ¨ç©ºé—´ä¸­ç›¸äº¤ã€‚æ ¹æ®<strong>æ­£å¼¦å®šç†</strong>æˆ–ç®€å•çš„<strong>ä¸‰è§’å‡½æ•°</strong>ï¼Œå³å¯è§£ç®—å‡ºè¯¥äº¤ç‚¹çš„ä¸‰ç»´åæ ‡ $(X, Y, Z)$ã€‚</li>\n</ol>\n<hr />\n<h4 id=\"3-ç¼–ç æ–¹å¼ç»“æž„å…‰çš„è¯­è¨€\">3. ç¼–ç æ–¹å¼ï¼šç»“æž„å…‰çš„â€œè¯­è¨€â€</h4>\n<p>ç»“æž„å…‰æœ€æ ¸å¿ƒçš„ç«žäº‰åŠ›åœ¨äºŽå¦‚ä½•è®¾è®¡æŠ•å°„çš„â€œå›¾æ¡ˆâ€ã€‚ç›®å‰ä¸»æµæœ‰ä¸‰ç§ï¼š</p>\n<p><strong>A. ç©ºé—´ç¼–ç  (Spatial Coding) â€”â€” ä»£è¡¨ï¼šiPhone FaceID</strong></p>\n<ul>\n<li><strong>åšæ³•ï¼š</strong> ä¸€æ¬¡æ€§æŠ•å°„ä¸€ä¸ªå¤æ‚çš„æ•£æ–‘å›¾æ¡ˆï¼ˆç±»ä¼¼æ»¡å¤©æ˜Ÿï¼‰ã€‚</li>\n<li><strong>ç‰¹ç‚¹ï¼š</strong> åªéœ€æ‹æ‘„ä¸€å¼ å›¾ç‰‡å³å¯å®Œæˆé‡å»ºï¼Œé€Ÿåº¦æžå¿«ï¼Œé€‚åˆåŠ¨æ€ç‰©ä½“ï¼ˆå¦‚äººè„¸ï¼‰ã€‚<br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></li>\n</ul>\n<p><strong>B. æ—¶é—´ç¼–ç  (Temporal Coding) â€”â€” ä»£è¡¨ï¼šå·¥ä¸š 3D æ‰«æä»ª</strong></p>\n<ul>\n<li><strong>åšæ³•ï¼š</strong> è¿žç»­æŠ•å°„å¤šå¼ ä¸åŒé¢‘çŽ‡çš„é»‘ç™½æ¡çº¹ï¼ˆå¦‚æ ¼é›·ç  + æ­£å¼¦æ¡çº¹ï¼‰ã€‚</li>\n<li><strong>ç‰¹ç‚¹ï¼š</strong> ç²¾åº¦æžé«˜ï¼ˆå¯è¾¾å¾®ç±³çº§ï¼‰ï¼Œä½†ç‰©ä½“å¿…é¡»ä¿æŒé™æ­¢ï¼Œå› ä¸ºéœ€è¦æ‹æ‘„å¤šå¼ ç…§ç‰‡ã€‚<br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></li>\n</ul>\n<p><strong>C. ç›¸ç§»æ³• (Phase Shifting)</strong></p>\n<ul>\n<li><strong>åšæ³•ï¼š</strong> æŠ•å°„å‘¨æœŸæ€§çš„æ­£å¼¦å…‰æ …ï¼Œé€šè¿‡åˆ†æžå…‰æ³¢ç›¸ä½çš„åç§»æ¥æå–é«˜åº¦ä¿¡æ¯ã€‚<br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></li>\n</ul>\n<hr />\n<h4 id=\"4-æ·±åº¦è§£æžiphone-faceid-æ˜¯å¦‚ä½•å·¥ä½œçš„\">4. æ·±åº¦è§£æžï¼šiPhone FaceID æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ</h4>\n<p>FaceID æ˜¯ç»“æž„å…‰æŠ€æœ¯å°åž‹åŒ–ã€æ¶ˆè´¹çº§åº”ç”¨çš„å·…å³°ã€‚å®ƒåŒ…å«ä¸‰ä¸ªæ ¸å¿ƒç»„ä»¶ï¼š</p>\n<ol>\n<li><strong>ç‚¹é˜µæŠ•å½±å™¨ (Dot Projector)ï¼š</strong> å‘ä½ çš„è„¸éƒ¨æŠ•å°„è¶…è¿‡ <strong>30,000 ä¸ª</strong>è‚‰çœ¼ä¸å¯è§çš„çº¢å¤–æ•£æ–‘ç‚¹ã€‚</li>\n<li><strong>çº¢å¤–æ‘„åƒå¤´ (Infrared Camera)ï¼š</strong> è¯»å–è¿™äº›æ•£æ–‘åœ¨è„¸éƒ¨èµ·ä¼ä¸‹å½¢æˆçš„ç•¸å˜å›¾åƒã€‚</li>\n<li><strong>æ³›å…‰æ„Ÿåº”å…ƒä»¶ (Flood Illuminator)ï¼š</strong> ç¡®ä¿åœ¨å…¨é»‘çŽ¯å¢ƒä¸‹ä¹Ÿèƒ½ç…§äº®è„¸éƒ¨ï¼Œä¾›çº¢å¤–ç›¸æœºè¯†åˆ«ã€‚</li>\n</ol>\n<p><strong>ä¸ºä»€ä¹ˆå®ƒå®‰å…¨ï¼Ÿ</strong><br />\nå› ä¸ºå®ƒä¸æ˜¯åœ¨å¯¹æ¯”â€œç…§ç‰‡â€ï¼Œè€Œæ˜¯åœ¨å¯¹æ¯”ä½ è„¸éƒ¨çš„<strong>ä¸‰ç»´åœ°å½¢å›¾</strong>ã€‚ç…§ç‰‡æ˜¯å¹³é¢çš„ï¼Œæ— æ³•äº§ç”Ÿç»“æž„å…‰çš„ç•¸å˜æ•ˆæžœï¼Œå› æ­¤æ— æ³•æ¬ºéª— FaceIDã€‚</p>\n<hr />\n<h4 id=\"5-ç»“æž„å…‰çš„ä¼˜ç¼ºç‚¹\">5. ç»“æž„å…‰çš„ä¼˜ç¼ºç‚¹</h4>\n<p><strong>ä¼˜ç‚¹ï¼š</strong></p>\n<ol>\n<li><strong>æ— éœ€çŽ¯å¢ƒçº¹ç†ï¼š</strong> å³ä½¿æ˜¯çº¯ç™½è‰²çš„å¢™ï¼Œç»“æž„å…‰ä¹Ÿèƒ½é‡å»ºï¼ˆå› ä¸ºå®ƒè‡ªå·±æŠ•å°„äº†çº¹ç†ï¼‰ï¼Œè¿™å¼¥è¡¥äº†åŒç›®è§†è§‰çš„çŸ­æ¿ã€‚</li>\n<li><strong>ç²¾åº¦æžé«˜ï¼š</strong> åœ¨è¿‘è·ç¦»ï¼ˆ1ç±³ä»¥å†…ï¼‰ï¼Œç»“æž„å…‰çš„ç²¾åº¦å¯ä»¥è½»æ¾è¾¾åˆ°æ¯«ç±³ç”šè‡³å¾®ç±³çº§ã€‚</li>\n<li><strong>ä¸»åŠ¨è¡¥å…‰ï¼š</strong> åœ¨å…¨é»‘çš„çŽ¯å¢ƒä¸‹ä¾ç„¶èƒ½å·¥ä½œã€‚</li>\n</ol>\n<p><strong>ç¼ºç‚¹ï¼š</strong></p>\n<ol>\n<li><strong>æ€•å¼ºå…‰ï¼š</strong> åœ¨å®¤å¤–å¼ºå…‰ï¼ˆå¦‚é˜³å…‰ï¼‰ä¸‹ï¼ŒæŠ•å½±ä»ªçš„å…‰ä¼šè¢«é˜³å…‰æ·¹æ²¡ï¼Œå¯¼è‡´å¤±æ•ˆã€‚</li>\n<li><strong>è·ç¦»é™åˆ¶ï¼š</strong> æŠ•å½±ä»ªåŠŸçŽ‡æœ‰é™ï¼Œé€šå¸¸åªé€‚ç”¨äºŽè¿‘è·ç¦»ï¼ˆå¦‚æ‰‹æœºè§£é”ã€æ¡Œé¢æ‰«æï¼‰ã€‚</li>\n<li><strong>æè´¨æ•æ„Ÿï¼š</strong> é¢å¯¹é•œé¢åå…‰ç‰©ä½“æˆ–å…¨é»‘å¸å…‰ç‰©ä½“ï¼ŒæŠ•å°„çš„å…‰ä¼šæ¶ˆå¤±æˆ–ä¹±å°„ï¼Œå¯¼è‡´æ— æ³•æˆåƒã€‚</li>\n</ol>\n<hr />\n<h3 id=\"6-å‚è€ƒæ–‡çŒ®-1\">6. å‚è€ƒæ–‡çŒ®</h3>\n<ol>\n<li><strong>Geng, J. (2011).</strong> <em>Structured-light 3D surface imaging: a tutorial</em>. Advances in Optics and Photonics.<br />\n(æœ€ç»å…¸çš„ç»“æž„å…‰ç»¼è¿°æ€§æ•™ç¨‹)ã€‚</li>\n<li><strong>Scharstein, D., &amp; Szeliski, R. (2003).</strong> <em>High-accuracy stereo depth maps using structured light</em>. CVPR.<br />\n(æŽ¢è®¨äº†å¦‚ä½•åˆ©ç”¨ç»“æž„å…‰èŽ·å–æžé«˜ç²¾åº¦çš„æ·±åº¦å›¾)ã€‚</li>\n<li><strong>Salvi, J., et al. (2004).</strong> <em>Pattern codification strategies in structured light systems</em>. Pattern Recognition.<br />\n(è¯¦ç»†å¯¹æ¯”äº†å„ç§ç¼–ç å›¾æ¡ˆçš„ä¼˜åŠ£)ã€‚</li>\n<li><strong>Apple Inc.</strong> <em>About Face ID advanced technology</em>. Support Documentation.<br />\n(è™½ç„¶ä¸æ˜¯å­¦æœ¯è®ºæ–‡ï¼Œä½†æ­ç¤ºäº†æ¶ˆè´¹çº§ç»“æž„å…‰ç³»ç»Ÿçš„ç¡¬ä»¶æž¶æž„)ã€‚</li>\n<li><strong>Zuo, C., et al. (2016).</strong> <em>Micro-structured-light 3D surface profiling: A review</em>. Measurement.<br />\n(èšç„¦äºŽå¾®è§‚é¢†åŸŸé«˜ç²¾åº¦ç»“æž„å…‰æµ‹é‡çš„ç»¼è¿°)ã€‚</li>\n</ol>\n<h3 id=\"é£žè¡Œæ—¶é—´æ³•tof-time-of-flight\">é£žè¡Œæ—¶é—´æ³•ï¼ˆToF, Time of Flightï¼‰</h3>\n<p><strong>åŽŸç†ï¼š</strong> å‘å°„çº¢å¤–è„‰å†²ï¼Œæµ‹é‡å…‰çº¿åå°„å›žæ¥çš„æ—¶é—´ã€‚<br />\n<strong>ä»£è¡¨ï¼š</strong> æ¿€å…‰é›·è¾¾ï¼ˆLiDARï¼‰ã€Kinect 2.0ã€‚<br />\nå¦‚æžœè¯´<strong>ç»“æž„å…‰</strong>æ˜¯åˆ©ç”¨â€œå‡ ä½•ç•¸å˜â€æ¥æµ‹é‡ï¼Œé‚£ä¹ˆ<strong>é£žè¡Œæ—¶é—´æ³•ï¼ˆToF, Time of Flightï¼‰</strong>å°±æ˜¯åˆ©ç”¨â€œç»å¯¹é€Ÿåº¦â€æ¥æµ‹é‡ã€‚</p>\n<p>ToF æ˜¯ç›®å‰ 3D æ„ŸçŸ¥é¢†åŸŸä¸­é€Ÿåº¦æœ€å¿«ã€å»¶è¿Ÿæœ€ä½Žçš„æŠ€æœ¯ã€‚å®ƒå¹¿æ³›åº”ç”¨äºŽè‡ªåŠ¨é©¾é©¶çš„æ¿€å…‰é›·è¾¾ï¼ˆLiDARï¼‰ã€æ‰‹æœºåŽç½®æ·±åº¦æ‘„åƒå¤´ï¼ˆå¦‚ iPhone çš„ LiDAR æ‰«æä»ªï¼‰ä»¥åŠæ—©æœŸçš„ä½“æ„Ÿæ¸¸æˆè®¾å¤‡ã€‚</p>\n<hr />\n<h4 id=\"1-ä»€ä¹ˆæ˜¯-tof-é£žè¡Œæ—¶é—´æ³•\">1. ä»€ä¹ˆæ˜¯ ToF (é£žè¡Œæ—¶é—´æ³•)ï¼Ÿ</h4>\n<p><strong>å®šä¹‰ï¼š</strong><br />\nToF æ˜¯ä¸€ç§é€šè¿‡æµ‹é‡å…‰æ³¢åœ¨ä¼ æ„Ÿå™¨ä¸Žç›®æ ‡ç‰©ä½“ä¹‹é—´â€œé£žè¡Œâ€çš„æ—¶é—´ï¼Œæ¥è®¡ç®—ç›®æ ‡è·ç¦»çš„æŠ€æœ¯ã€‚å› ä¸ºå…‰çš„ä¼ æ’­é€Ÿåº¦ $c$ æ˜¯å·²çŸ¥çš„å¸¸æ•°ï¼Œåªè¦çŸ¥é“äº†æ—¶é—´ $t$ï¼Œè·ç¦» $d$ ä¹Ÿå°±è¿Žåˆƒè€Œè§£ã€‚</p>\n<p><strong>å½¢è±¡æ¯”å–»ï¼š</strong><br />\næƒ³è±¡ä½ å¯¹ç€ä¸€å£æ·±äº•å¤§å–Šä¸€å£°ï¼Œç„¶åŽå¼€å§‹è®¡æ—¶ã€‚å½“ä½ å¬åˆ°å›žå£°æ—¶ï¼Œåœæ­¢è®¡æ—¶ã€‚</p>\n<ul>\n<li><strong>å£°çº³/é›·è¾¾ï¼š</strong> åˆ©ç”¨å£°æ³¢æˆ–æ— çº¿ç”µæ³¢çš„åå°„ã€‚</li>\n<li><strong>ToFï¼š</strong> åˆ©ç”¨å…‰æ³¢ï¼ˆé€šå¸¸æ˜¯ 850nm-940nm çš„è¿‘çº¢å¤–å…‰ï¼‰ã€‚ç”±äºŽå…‰é€Ÿæžå¿«ï¼ˆæ¯ç§’ 30 ä¸‡å…¬é‡Œï¼‰ï¼ŒToF èŠ¯ç‰‡éœ€è¦å…·å¤‡â€œçš®ç§’çº§â€ï¼ˆä¸‡äº¿åˆ†ä¹‹ä¸€ç§’ï¼‰çš„è®¡æ—¶ç²¾åº¦ã€‚</li>\n</ul>\n<hr />\n<h4 id=\"2-æ ¸å¿ƒæ•°å­¦åŽŸç†æžé€Ÿå…¬å¼\">2. æ ¸å¿ƒæ•°å­¦åŽŸç†ï¼šæžé€Ÿå…¬å¼</h4>\n<p>ToF çš„åŸºæœ¬åŽŸç†éžå¸¸ç›´è§‚ï¼Œä½†å®žçŽ°æ–¹æ³•åˆ†ä¸ºä¸¤ç§ä¸»è¦æµæ´¾ï¼š<strong>dToF</strong> å’Œ <strong>iToF</strong>ã€‚</p>\n<p><strong>A. dToF (Direct ToFï¼Œç›´æŽ¥æµ‹é‡) â€”â€” ä»£è¡¨ï¼šæ¿€å…‰é›·è¾¾ (LiDAR)</strong><br />\nè¿™æ˜¯æœ€ç¡¬æ ¸çš„æ–¹å¼ã€‚ä¼ æ„Ÿå™¨ç›´æŽ¥å‘å°„ä¸€ä¸ªæžçŸ­çš„å…‰è„‰å†²ï¼Œå¹¶å¯åŠ¨ä¸€ä¸ªè¶…é«˜ç²¾åº¦çš„â€œç§’è¡¨â€ï¼Œè®°å½•å…‰å­é£žå‡ºåŽ»å¹¶è·³å›žæ¥çš„ç¡®åˆ‡æ—¶é—´ $\\Delta t$ã€‚</p>\n<ul>\n<li><strong>å…¬å¼ï¼š</strong> $d = \\frac{c \\cdot \\Delta t}{2}$</li>\n<li><strong>éš¾ç‚¹ï¼š</strong> å…‰é€Ÿå¤ªå¿«ï¼Œå…‰èµ° 1 åŽ˜ç±³åªéœ€è¦çº¦ 33 çš®ç§’ã€‚è¿™å°±è¦æ±‚ä¼ æ„Ÿå™¨ï¼ˆé€šå¸¸æ˜¯ SPADï¼Œå•å…‰å­é›ªå´©äºŒæžç®¡ï¼‰å…·æœ‰æžå…¶ææ€–çš„å“åº”é€Ÿåº¦ã€‚</li>\n</ul>\n<p><strong>B. iToF (Indirect ToFï¼Œé—´æŽ¥æµ‹é‡) â€”â€” ä»£è¡¨ï¼šKinect 2.0</strong><br />\nç”±äºŽç²¾ç¡®è®¡æ—¶å¤ªéš¾ä¸”è´µï¼ŒiToF é‡‡ç”¨äº†â€œæ›²çº¿æ•‘å›½â€çš„æ–¹æ³•ï¼šå®ƒå‘å°„çš„æ˜¯<strong>è¿žç»­çš„æ­£å¼¦è°ƒåˆ¶å…‰æ³¢</strong>ï¼Œé€šè¿‡æµ‹é‡å‘å°„æ³¢ä¸Žåå°„æ³¢ä¹‹é—´çš„<strong>ç›¸ä½å·®ï¼ˆPhase Shiftï¼‰</strong>æ¥æŽ¨ç®—æ—¶é—´ã€‚</p>\n<ul>\n<li><strong>é€»è¾‘ï¼š</strong> ç›¸ä½åç§»äº†å¤šå°‘åº¦ï¼Œå°±ä»£è¡¨æ—¶é—´è¿‡åŽ»äº†å¤šä¹…ã€‚</li>\n<li><strong>ä¼˜ç‚¹ï¼š</strong> ç¡¬ä»¶æˆæœ¬è¾ƒä½Žï¼Œåƒç´ åˆ†è¾¨çŽ‡å¯ä»¥åšå¾—å¾ˆé«˜ï¼ˆç±»ä¼¼æ‰‹æœºæ‘„åƒå¤´ï¼‰ã€‚</li>\n</ul>\n<hr />\n<h4 id=\"3-tof-çš„å·¥ä½œæµç¨‹\">3. ToF çš„å·¥ä½œæµç¨‹</h4>\n<ol>\n<li><strong>å‘å°„å•å…ƒ (Emitter)ï¼š</strong> å‘å‡ºç»è¿‡è°ƒåˆ¶çš„çº¢å¤–æ¿€å…‰æˆ–è„‰å†²ã€‚</li>\n<li><strong>åå°„ (Reflection)ï¼š</strong> å…‰çº¿è§¦ç¢°ç‰©ä½“è¡¨é¢åŽå‘ç”Ÿå¼¥æ•£åå°„ã€‚</li>\n<li><strong>æŽ¥æ”¶å•å…ƒ (Sensor)ï¼š</strong> ä¸€ä¸ªç‰¹æ®Šçš„ CMOS å›¾åƒä¼ æ„Ÿå™¨æ•æ‰è¿”å›žçš„å…‰ä¿¡å·ã€‚</li>\n<li><strong>å¤„ç†å•å…ƒ (Processor)ï¼š</strong>\n<ul>\n<li>å¯¹äºŽ dToFï¼šç»Ÿè®¡å…‰å­åˆ°è¾¾çš„ç›´æ–¹å›¾ï¼Œç¡®å®šå³°å€¼æ—¶é—´ã€‚</li>\n<li>å¯¹äºŽ iToFï¼šè®¡ç®—æ¯ä¸ªåƒç´ ç‚¹çš„ç”µè·å·®å¼‚ï¼Œè½¬æ¢æˆç›¸ä½ï¼Œå†æ¢ç®—æˆæ·±åº¦å€¼ã€‚</li>\n</ul>\n</li>\n<li><strong>è¾“å‡ºï¼š</strong> ç”Ÿæˆä¸€å¼ <strong>æ·±åº¦å›¾ï¼ˆDepth Mapï¼‰</strong>ï¼Œæ¯ä¸ªåƒç´ ä»£è¡¨è¯¥ç‚¹çš„ç‰©ç†è·ç¦»ã€‚</li>\n</ol>\n<hr />\n<h4 id=\"4-tof-vs-ç»“æž„å…‰æœ‰ä»€ä¹ˆåŒºåˆ«\">4. ToF vs. ç»“æž„å…‰ï¼šæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">ç‰¹æ€§</th>\n<th style=\"text-align: left;\">ToF (é£žè¡Œæ—¶é—´æ³•)</th>\n<th style=\"text-align: left;\">ç»“æž„å…‰ (Structured Light)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>è®¡ç®—é‡</strong></td>\n<td style=\"text-align: left;\"><strong>æžä½Ž</strong>ï¼ˆç¡¬ä»¶ç›´æŽ¥è¾“å‡ºç»“æžœï¼‰</td>\n<td style=\"text-align: left;\"><strong>é«˜</strong>ï¼ˆéœ€è¦å¤æ‚çš„å›¾åƒå¯¹æ¯”åˆ†æžï¼‰</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>å·¥ä½œè·ç¦»</strong></td>\n<td style=\"text-align: left;\"><strong>è¿œ</strong>ï¼ˆæ¿€å…‰é›·è¾¾å¯è¾¾æ•°ç™¾ç±³ï¼‰</td>\n<td style=\"text-align: left;\"><strong>çŸ­</strong>ï¼ˆé€šå¸¸ 1 ç±³ä»¥å†…ï¼‰</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>æŠ—å¹²æ‰°æ€§</strong></td>\n<td style=\"text-align: left;\">è¾ƒå¼ºï¼ˆå°¤å…¶ dToF é€‚åˆå®¤å¤–ï¼‰</td>\n<td style=\"text-align: left;\">è¾ƒå¼±ï¼ˆå¼ºå…‰ä¸‹å›¾æ¡ˆä¼šè¢«æ·¹æ²¡ï¼‰</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>åˆ†è¾¨çŽ‡</strong></td>\n<td style=\"text-align: left;\">è¾ƒä½Žï¼ˆé€šå¸¸æ˜¯ QVGA çº§ï¼‰</td>\n<td style=\"text-align: left;\">è¾ƒé«˜ï¼ˆå¯ä»¥è¾¾åˆ°ç™¾ä¸‡åƒç´ ï¼‰</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>åº”ç”¨åœºæ™¯</strong></td>\n<td style=\"text-align: left;\">æ‰«åœ°æœºå™¨äººã€è‡ªåŠ¨é©¾é©¶ã€AR å»ºæ¨¡</td>\n<td style=\"text-align: left;\">æ‰‹æœºé¢éƒ¨è§£é”ã€ç²¾å¯†æ‰«æã€æ´»ä½“æ£€æµ‹</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h4 id=\"5-ç›®å‰çš„ç“¶é¢ˆä¸ŽæŒ‘æˆ˜-1\">5. ç›®å‰çš„ç“¶é¢ˆä¸ŽæŒ‘æˆ˜</h4>\n<ol>\n<li><strong>å¤šå¾„å¹²æ‰° (Multi-path Interference)ï¼š</strong><br />\nå¦‚æžœå…‰çº¿åœ¨å¢™è§’ç»è¿‡å¤šæ¬¡åå°„æ‰å›žåˆ°ä¼ æ„Ÿå™¨ï¼ŒToF ä¼šè¯¯ä»¥ä¸ºç‰©ä½“æ¯”å®žé™…æ›´è¿œï¼Œäº§ç”Ÿâ€œæ·±åº¦é‡å½±â€ã€‚</li>\n<li><strong>é£žç‚¹æ•ˆåº” (Flying Pixels)ï¼š</strong><br />\nåœ¨ç‰©ä½“çš„è¾¹ç¼˜ï¼Œä¸€ä¸ªåƒç´ å¯èƒ½åŒæ—¶æŽ¥æ”¶åˆ°ç‰©ä½“è¡¨é¢å’ŒèƒŒæ™¯å¢™çš„åå°„ä¿¡å·ï¼Œå¯¼è‡´è¾¹ç¼˜å‡ºçŽ°ä¸€åœˆèŽ«é¡»æœ‰çš„â€œé£žç‚¹â€ã€‚</li>\n<li><strong>çŽ¯å¢ƒå…‰å¹²æ‰°ï¼š</strong><br />\nè™½ç„¶ iToF åœ¨å®¤å†…è¡¨çŽ°ä¼˜å¼‚ï¼Œä½†åœ¨å¤ªé˜³å…‰ä¸‹ï¼Œçº¢å¤–å…‰å™ªå£°å·¨å¤§ï¼Œä¼šå¯¼è‡´ç²¾åº¦å¤§å¹…ä¸‹é™ï¼ˆdToF é€šè¿‡å•å…‰å­æŠ€æœ¯ç¼“è§£äº†è¿™ä¸€é—®é¢˜ï¼‰ã€‚</li>\n<li><strong>åŠŸè€—é—®é¢˜ï¼š</strong><br />\nå› ä¸ºè¦ä¸æ–­åœ°ä¸»åŠ¨å‘å°„å…‰ï¼ŒToF ä¼ æ„Ÿå™¨é€šå¸¸æ¯”æ™®é€šæ‘„åƒå¤´æ›´è€—ç”µã€‚</li>\n</ol>\n<hr />\n<h4 id=\"6-å‚è€ƒæ–‡çŒ®-2\">6. å‚è€ƒæ–‡çŒ®</h4>\n<ol>\n<li><strong>Hansard, M., Lee, S., Choi, O., &amp; Horaud, R. P. (2012).</strong> <em>Time-of-Flight Cameras: Principles, Methods and Applications</em>. Springer Briefs in Computer Science.<br />\n(æœ€ç³»ç»Ÿè®²è§£ ToF åŽŸç†çš„ç»å…¸ä¹¦ç±)ã€‚</li>\n<li><strong>Li, L. (2014).</strong> <em>Time-of-flight camera â€“ An introduction</em>. Technical report, Texas Instruments.<br />\n(TI å‘å¸ƒçš„å®˜æ–¹æŠ€æœ¯æŠ¥å‘Šï¼Œæ·±å…¥è®²è§£äº† iToF çš„ç”µå­å­¦å®žçŽ°)ã€‚</li>\n<li><strong>Horaud, R., et al. (2016).</strong> <em>An overview of gradient-based 3D reconstruction methods for Time-of-Flight RGB-D cameras</em>. Journal of Mathematical Imaging and Vision.<br />\n(æŽ¢è®¨äº†å¦‚ä½•ä¼˜åŒ– ToF çš„æ·±åº¦å›¾è´¨é‡)ã€‚</li>\n<li><strong>Bamji, C. S., et al. (2015).</strong> <em>A 0.13Î¼m CMOS System-on-Chip for a 512Ã—424 Time-of-Flight Image Sensor with Multi-Frequency Photo-Demodulation</em>. ISSCC.<br />\n(Kinect 2.0 èƒŒåŽèŠ¯ç‰‡çš„æŠ€æœ¯ç»†èŠ‚è®ºæ–‡)ã€‚</li>\n<li><strong>Niclass, C., et al. (2005).</strong> <em>A CMOS single photon avalanche diode array for 3D imaging</em>. IEEE International Solid-State Circuits Conference.<br />\n(dToF æ ¸å¿ƒç»„ä»¶ SPAD ä¼ æ„Ÿå™¨çš„å¥ åŸºæ€§ç ”ç©¶)ã€‚</li>\n</ol>\n<hr />\n<h1 id=\"4-é€‚ç”¨åœºæ™¯\">4. é€‚ç”¨åœºæ™¯</h1>\n<p>3Dé‡å»ºæŠ€æœ¯å·²ç»æ·±å…¥åˆ°å„è¡Œå„ä¸šï¼š</p>\n<ul>\n<li><strong>å·¥ä¸šè‡ªåŠ¨åŒ–ï¼š</strong> é«˜ç²¾åº¦é›¶ä»¶çš„å°ºå¯¸æ£€æµ‹ã€ç¼ºé™·æ‰«æã€æœºå™¨äººæŠ“å–å¼•å¯¼ã€‚</li>\n<li><strong>è‡ªåŠ¨é©¾é©¶ä¸Žæœºå™¨äººï¼š</strong> é¿éšœã€çŽ¯å¢ƒå»ºæ¨¡ï¼ˆSLAMï¼‰ã€é«˜ç²¾åœ°å›¾åˆ¶ä½œã€‚</li>\n<li><strong>æ–‡åŒ–é—äº§ä¿æŠ¤ï¼š</strong> å¯¹å¤å»ºç­‘ç‰©ã€æ–‡ç‰©è¿›è¡Œæ•°å­—åŒ–å»ºæ¨¡ï¼Œå®žçŽ°æ°¸æ’ä¿å­˜ã€‚</li>\n<li><strong>åŒ»ç–—æˆåƒï¼š</strong> ç‰™ç§‘æ‰«æå»ºæ¨¡ã€æ‰‹æœ¯å‰3Dæ¨¡æ‹Ÿã€‚</li>\n<li><strong>æ•°å­—å­ªç”Ÿä¸Žå…ƒå®‡å®™ï¼š</strong> å°†çŽ°å®žä¸–ç•Œçš„ç‰©ä½“å¿«é€Ÿå»ºæ¨¡å¹¶å¯¼å…¥æ¸¸æˆæˆ–è™šæ‹Ÿç©ºé—´ã€‚</li>\n<li><strong>ç”µå­å•†åŠ¡ï¼š</strong> æ‰‹æœºæ‰«æå•†å“å®žçŽ°3Dé¢„è§ˆï¼ˆå¦‚å®œå®¶å®¶å…·è¯•æ‘†ï¼‰ã€‚</li>\n</ul>\n<hr />\n<h1 id=\"5-ç›®å‰çš„ç“¶é¢ˆä¸Žé—®é¢˜\">5. ç›®å‰çš„ç“¶é¢ˆä¸Žé—®é¢˜</h1>\n<p>å°½ç®¡æŠ€æœ¯å‘å±•è¿…é€Ÿï¼Œä½†3Dé‡å»ºä»é¢ä¸´ä»¥ä¸‹ä¸¥å³»æŒ‘æˆ˜ï¼š</p>\n<ol>\n<li><strong>å¼±çº¹ç†ä¸Žé‡å¤çº¹ç†ï¼š</strong><br />\né¢å¯¹æ´ç™½çš„å¢™å£ã€çº¯è‰²æ¡Œé¢æˆ–çŽ»ç’ƒè¡¨é¢ï¼Œç®—æ³•å¾ˆéš¾æ‰¾åˆ°å¯é çš„ç‰¹å¾åŒ¹é…ç‚¹ï¼Œå¯¼è‡´é‡å»ºå¤±è´¥æˆ–å‡ºçŽ°â€œç ´æ´žâ€ã€‚</li>\n<li><strong>åå…‰ä¸Žé€æ˜Žç‰©ä½“ï¼š</strong><br />\né‡‘å±žè¡¨é¢çš„é«˜å…‰å’ŒçŽ»ç’ƒçš„æŠ˜å°„ä¼šè¯¯å¯¼ç›¸æœºï¼Œä½¿ç®—æ³•è®¡ç®—å‡ºé”™è¯¯çš„æ·±åº¦ã€‚</li>\n<li><strong>è®¡ç®—å¤æ‚åº¦ä¸Žå®žæ—¶æ€§ï¼š</strong><br />\né«˜ç²¾åº¦çš„ç¨ å¯†é‡å»ºéœ€è¦å·¨å¤§çš„ç®—åŠ›ï¼Œåœ¨ç§»åŠ¨è®¾å¤‡æˆ–åµŒå…¥å¼å¹³å°ä¸Šéš¾ä»¥å®žçŽ°è¶…é«˜ç²¾åº¦çš„å®žæ—¶é‡å»ºã€‚</li>\n<li><strong>é®æŒ¡é—®é¢˜ï¼š</strong><br />\nå½“ç‰©ä½“çš„ä¸€éƒ¨åˆ†è¢«æŒ¡ä½æ—¶ï¼Œç®—æ³•éœ€è¦é€šè¿‡å…ˆéªŒçŸ¥è¯†ï¼ˆAIçŒœæƒ³ï¼‰æ¥è¡¥å…¨ï¼Œè¿™å¾€å¾€ä¼šå¯¼è‡´ç²¾åº¦ä¸‹é™ã€‚</li>\n<li><strong>å…‰ç…§æ•æ„Ÿæ€§ï¼š</strong><br />\nè¿‡å¼ºæˆ–è¿‡æš—çš„å…‰çº¿éƒ½ä¼šä¸¥é‡å½±å“è¢«åŠ¨è§†è§‰æ–¹æ³•çš„ç‰¹å¾æå–è´¨é‡ã€‚</li>\n</ol>\n<hr />\n<h1 id=\"æ€»ç»“\">æ€»ç»“</h1>\n<p>é€šè¿‡æœºå™¨è§†è§‰å®žçŽ°3Dé‡å»ºæ˜¯è®¡ç®—æœºè§†è§‰é¢†åŸŸçš„â€œåœ£æ¯â€ä¹‹ä¸€ã€‚ä»Žç»å…¸çš„ä¸‰è§’å‡ ä½•åˆ°çŽ°ä»£çš„æ·±åº¦å­¦ä¹ ï¼ˆNeRF/3DGSï¼‰ï¼Œæˆ‘ä»¬æ­£å¤„äºŽä»Žâ€œæ‹å‡ºå¥½çœ‹çš„ç…§ç‰‡â€å‘â€œæž„å»ºå®Œç¾Žçš„æ•°å­—ä¸–ç•Œâ€è·¨è¶Šçš„æ—¶ä»£ã€‚éšç€ç®—åŠ›çš„æå‡å’Œç®—æ³•çš„ä¼˜åŒ–ï¼Œæœªæ¥çš„3Dé‡å»ºå°†å˜å¾—åƒæ‹ç…§ä¸€æ ·ç®€å•ä¸”ç²¾å‡†ã€‚</p>\n<hr />\n<h1 id=\"å‚è€ƒæ–‡çŒ®\">å‚è€ƒæ–‡çŒ®</h1>\n<p>ä¸ºäº†ä¿è¯ä¿¡æ¯çš„çœŸå®žæ€§ä¸Žå­¦æœ¯ä¸¥è°¨æ€§ï¼Œä»¥ä¸‹æ˜¯æœ¬åšå®¢å‚è€ƒçš„æ ¸å¿ƒæ–‡çŒ®ä¸Žç»å…¸æ•™æï¼š</p>\n<ol>\n<li><strong>Hartley, R., &amp; Zisserman, A. (2004).</strong> <em>Multiple View Geometry in Computer Vision</em>. Cambridge University Press.<br />\n(è®¡ç®—æœºè§†è§‰é¢†åŸŸçš„åœ£ç»ï¼Œè¯¦ç»†è®²è§£äº†å¤šè§†å›¾å‡ ä½•å’Œç›¸æœºæ¨¡åž‹)ã€‚</li>\n<li><strong>Mildenhall, B., et al. (2020).</strong> <em>NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis</em>. ECCV.<br />\n(ç¥žç»è¾å°„åœºå¥ åŸºä¹‹ä½œ)ã€‚</li>\n<li><strong>Kerbl, B., et al. (2023).</strong> <em>3D Gaussian Splatting for Real-Time Radiance Field Rendering</em>. ACM Transactions on Graphics.<br />\n(å½“å‰æœ€å‰æ²¿çš„å®žæ—¶3Dé‡å»ºç®—æ³•)ã€‚</li>\n<li><strong>Schonberger, J. L., &amp; Frahm, J. M. (2016).</strong> <em>Structure-from-Motion Revisited</em>. CVPR.<br />\n(COLMAPç®—æ³•çš„ç†è®ºåŸºç¡€)ã€‚</li>\n<li><strong>Newcombe, R. A., et al. (2011).</strong> <em>KinectFusion: Real-time 3D reconstruction and interaction using a moving depth camera</em>. ISMAR.<br />\n(ç»“æž„å…‰ä¸ŽToFå®žæ—¶é‡å»ºçš„ç»å…¸æ–‡çŒ®)ã€‚</li>\n</ol>\n<hr />\n<p><strong>ä½œè€…æç¤ºï¼š</strong> å¦‚æžœä½ å¯¹å…·ä½“çš„æŸä¸ªç®—æ³•ï¼ˆå¦‚å¦‚ä½•é…ç½®COLMAPæˆ–å¦‚ä½•è®­ç»ƒNeRFï¼‰æ„Ÿå…´è¶£ï¼Œæ¬¢è¿Žåœ¨è¯„è®ºåŒºç•™è¨€ï¼Œæˆ‘å°†åœ¨ä¸‹ä¸€æœŸè¯¦ç»†è®²è§£ï¼</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 09:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\né˜…è¯»(<span id=\"post_view_count\">0</span>)&nbsp;\nè¯„è®º(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">æ”¶è—</a>&nbsp;\n<a href=\"\">ä¸¾æŠ¥</a>\n</div>"
    },
    {
      "title": "别再只做 “点点点”！AI测试的六种不同玩法，附带Midscene详细教程！",
      "link": "https://www.cnblogs.com/jinjiangongzuoshi/p/19582572",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jinjiangongzuoshi/p/19582572\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 09:02\">\n    <span>别再只做 “点点点”！AI测试的六种不同玩法，附带Midscene详细教程！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>零基础新手，最大的学习障碍是\"恐惧感\"！</p>\n<p>上一篇，我们以AI编程切入，手把手带大家如何在10分钟内做出第一个应用，并且如何将它部署到互联网上。</p>\n<p>不需要你有任何编程基础，只要你会打字、会上网，就能跟着做。通过第一个项目，帮助大家建立<code>Vibe Coding</code> 的思维方式：<strong>关注 \"要做什么\" 而不是 \"怎么做\"</strong>。</p>\n<p>今天是牛刀小试的第二篇，我们来聊一聊AI测试，带大家感受一下AI在测试领域带来的魅力。</p>\n<p>同样，在这篇教程中，我们不聊AI测试的相关理论、晦涩难懂的技术，聊聊AI在UI自动化测试的一些新玩法、思路。</p>\n<blockquote>\n<p>本文为试读，原文发布到「狂师.AI进化社」教程专栏中，会有更加详细的AI测试教程，阅读体验更佳~</p>\n</blockquote>\n<h2 id=\"1传统ui测试工具是怎么做自动化的\">1、传统UI测试工具是怎么做自动化的？</h2>\n<p>传统 UI 自动化测试，核心是<strong>通过代码/脚本对页面元素做 “定位 -&gt; 操作 -&gt; 断言” 的程序化模拟</strong>，本质是用机器替代人工的手工点击、输入、校验操作，实现回归测试、重复场景测试的自动化执行，整体围绕 “元素定位” 这个核心展开，步骤固定且对页面稳定性要求极高。</p>\n<p>而传统 UI 自动化测试工具（如 Selenium、Appium、Playwright、Robot Framework 等），无论开源还是商用，实现思路基本一致，大体可以分为几步：</p>\n<h3 id=\"11-搭环境与工具适配\">1.1 搭环境与工具适配</h3>\n<p>根据被测应用的类型（Web 端 / 移动端 APP / 小程序）选择对应工具，比如：</p>\n<ul>\n<li>Web 端，一般首选用 <code>Selenium/Playwright</code></li>\n<li>移动端用 <code>Appium</code>，</li>\n<li>低代码封装用 <code>Robot Framework</code>；</li>\n</ul>\n<p>同时搭建配套环境，比如 Web 端需要配置浏览器驱动（ChromeDriver/GeckoDriver）、移动端需要配置模拟器/真机+ADB环境，再结合 Python/Java/JavaScript等开发语言，搭建基础的自动化测试框架。</p>\n<h3 id=\"12-定位页面元素\">1.2 定位页面元素</h3>\n<p>工具无法像人一样 “看” 到页面上的按钮、输入框、下拉框，只能通过<strong>页面元素的唯一标识</strong>来识别，这是所有自动化操作的前提。测试人员需要通过浏览器开发者工具（F12）/APP元素探查工具（UIAutomatorViewer），提取元素的专属属性，常用定位方式按优先级排序：</p>\n<ul>\n<li>\n<p>精准定位：id、name（唯一属性，优先级最高，最稳定）；</p>\n</li>\n<li>\n<p>通用定位：xpath、css selector（支持路径 / 属性匹配，适配无 id/name 的元素，如<code>//input[@placeholder='请输入账号']</code>）；</p>\n</li>\n<li>\n<p>兜底定位：class name、tag name、link text（易重复，仅用于无其他属性的场景）。</p>\n</li>\n</ul>\n<p><strong>核心要求</strong>：元素必须有稳定的标识，一旦元素属性被开发修改（如 id 从<code>btn-login</code>改成<code>btn-login-new</code>），脚本就会 “找不到元素”，直接执行失败。</p>\n<h3 id=\"13-开发自动化执行脚本\">1.3 开发自动化执行脚本</h3>\n<p>基于选定的语言和工具，编写脚本模拟人工操作，核心逻辑是 <strong>“操作链 + 校验点”</strong>，主流有两种开发模式：</p>\n<ul>\n<li>线性脚本：按手工测试的步骤依次编写，如 “打开浏览器→输入网址→点击账号输入框→输入账号→点击密码框→输入密码→点击登录按钮”，适合简单的单流程场景；</li>\n<li>模块化/关键字驱动：将重复操作封装成公共模块（如 “登录模块”“退出模块”），用例直接调用模块，减少代码冗余，适合大型项目的批量用例开发。</li>\n</ul>\n<p>并且，因为页面加载、接口请求会存在延迟和偶发性，为了确保脚本的稳定性，脚本中除了会包含<strong>操作指令</strong>（click/input/clear/select）等，必须加等待避免工具 “提前操作” 导致的失败—— 实际则需要，根据不同的场景引入不同的等待机制（强制等待/显式等待/隐式等待）。</p>\n<h3 id=\"14-执行测试\">1.4 执行测试</h3>\n<p>运行编写好的脚本，工具会自动驱动浏览器/模拟器，按脚本步骤执行操作；执行到关键节点时，会通过<strong>断言语句</strong>校验实际结果是否符合预期，比如 “登录后是否跳转到首页”“点击提交后是否显示‘提交成功’提示”“列表是否加载出指定数据”，断言通过则用例成功，失败则终止并记录错误。</p>\n<h3 id=\"15-生成测试报告与问题排查\">1.5 生成测试报告与问题排查</h3>\n<p>执行完成后，可以是由工具来自动生成报告，也可以是人工来整理报告。</p>\n<p>测试人员需要根据报告来排查问题，如区分是<strong>脚本问题</strong>（定位方式错误）、<strong>页面问题</strong>（元素属性修改）还是<strong>工具环境问题</strong>（驱动版本不兼容），再针对性修改。</p>\n<h2 id=\"2-传统ui自动化的核心痛点\">2. 传统UI自动化的核心痛点</h2>\n<p>正因为传统UI自动化工具，主要是依赖 “固定元素定位” 和 “死板脚本逻辑”，导致在如今快敏捷开发、高频迭代的场景中，暴露了诸多难以解决的问题：</p>\n<ol>\n<li>\n<p><strong>元素定位依赖“硬编码”</strong>：传统的UI自动化测试工具，比如Selenium、Appium、Playwright等，通常需要通过ID、Class、Xpath等固定的元素属性来定位元素，但前端开发常因需求调整修改DOM结构（比如组件库升级、样式优化、布局调整），导致元素ID、Class这类属性可能会出现动态变化，脚本极易因为这些变化，导致“找不到元素”，据统计，企业级项目中约<code>40%-60%</code>的UI自动化用例失败源于元素定位失效，而非真实功能缺陷。</p>\n</li>\n<li>\n<p><strong>维护成本极高</strong>：开发迭代会频繁修改页面元素属性、调整页面布局，测试人员需要同步修改所有相关脚本的定位方式，迭代越快，维护工作量越大，甚至出现 “维护脚本的时间超过开发脚本的时间”；</p>\n</li>\n<li>\n<p><strong>对非标准元素无能为力</strong>：无法识别图片、验证码、动态生成的元素（如随机 id、动态弹窗），遇到这类场景只能通过人工介入或额外的破解方案，自动化覆盖率受限；</p>\n</li>\n<li>\n<p><strong>学习门槛不低</strong>：需要掌握开发语言（Python/Java）、工具 API、框架封装，非技术背景的测试人员难以上手；</p>\n</li>\n<li>\n<p><strong>无法像人一样 “认知” 页面</strong>：工具只能识别元素属性，无法理解页面的语义和逻辑，比如 “红色的提交按钮”“位于页面底部的分页栏”，一旦元素位置变化，即使属性不变，也可能因脚本逻辑问题执行失败。</p>\n</li>\n</ol>\n<h2 id=\"3-ai技术在ui自动化测试的六种玩法\">3. AI技术在UI自动化测试的六种玩法</h2>\n<p>针对上述问题，AI 在 UI 自动化测试中的应用，可以有很多种组合玩法。</p>\n<p>核心是通过<strong>大语言模型（LLM）</strong>、<strong>计算机视觉（CV）、自然语言处理（NLP）、机器学习（ML）</strong> 等技术，解决传统方案中“元素定位难、脚本维护成本高、跨端兼容性差、人力依赖强”等问题。</p>\n<p>有了AI的融入，自动化测试，不再是依赖 “固定元素属性”，而是让测试工具像<strong>人一样 “看” 页面、“理解” 页面、“推理” 操作逻辑</strong>。</p>\n<p>以<strong>计算机视觉（CV）</strong>和<strong>自然语言处理（NLP）</strong> 为代表的AI技术为例，可以通过“感知界面内容+理解用户意图”的方式，推动UI自动化测试从“硬编码规则驱动”向“认知驱动”转型，其核心理念可概括为：<strong>让测试系统像人类一样“看懂界面”“听懂需求”，并自主完成操作与验证</strong>。</p>\n<h4 id=\"玩法-1利用ai-视觉定位--替代传统元素定位\">玩法 1：利用AI 视觉定位 —— 替代传统元素定位</h4>\n<p>基于<strong>计算机视觉（CV）+ 图像识别</strong>技术，让测试工具不再依赖元素的 <code>id/xpath</code> 等固定属性，而是像人一样通过 “视觉特征” 识别元素，比如 “页面顶部的蓝色登录按钮”“中间的白色输入框，占位符是请输入手机号”“右下角的红色提交按钮”。</p>\n<ul>\n<li>实现方式：测试人员只需用自然语言描述元素（或直接在页面上框选元素），AI 会提取元素的视觉特征（颜色、形状、位置、文字内容），生成唯一的视觉定位标识，即使元素属性被修改、位置被调整，只要视觉特征不变，工具就能精准识别；</li>\n<li>适配场景：高频迭代的页面、动态生成元素的场景、无标准属性的小众页面，彻底解决传统方案 “元素定位失效” 的核心痛点，大幅降低脚本维护成本。</li>\n</ul>\n<h4 id=\"玩法-2自然语言生成自动化用例--让人人都能做自动化\">玩法 2：自然语言生成自动化用例 —— 让人人都能做自动化</h4>\n<p>基于<strong>大语言模型（LLM）</strong>，实现 <strong>“自然语言描述需求→AI 自动生成自动化脚本 / 用例”</strong>，彻底降低自动化的学习门槛，非技术背景的测试人员、产品经理甚至开发，都能快速制作自动化用例。</p>\n<ul>\n<li>实现方式：测试人员只需用日常语言描述测试场景，比如 “打开 XX 网站，输入账号 admin、密码 123456，点击登录，校验是否跳转到首页，是否显示用户名 admin”，AI 会自动识别场景中的操作步骤、校验点，结合对应的测试工具（Selenium/Playwright），生成可直接运行的自动化脚本，还能自动添加等待机制、断言语句；</li>\n<li>延伸能力：还可以通过 “上传手工测试用例文档→AI 批量解析生成自动化用例”，实现用例的批量转化，大幅提升自动化覆盖率的转化效率。</li>\n</ul>\n<h4 id=\"玩法-3ai-智能维护脚本--自动化适配页面变化\">玩法 3：AI 智能维护脚本 —— 自动化适配页面变化</h4>\n<p>这是针对传统 “脚本维护成本高” 的核心优化，基于<strong>LLM + 视觉对比</strong>技术，让测试脚本具备 “自我修复” 能力，页面发生变化时，AI 会自动识别并修改脚本，无需人工介入。</p>\n<ul>\n<li>实现方式 1：脚本执行失败时，AI 会自动分析失败原因（如 “元素属性修改”“元素位置变化”），对比新旧页面的元素特征，自动更新脚本中的定位方式，再重新执行用例；</li>\n<li>实现方式 2：开发提交代码后，AI 会自动对比迭代前后的页面差异，识别出被修改的元素，批量更新所有相关的自动化脚本，实现 “页面变，脚本自动变”。</li>\n</ul>\n<h4 id=\"玩法-4ai-驱动的探索式测试--全自动覆盖页面场景\">玩法 4：AI 驱动的探索式测试 —— 全自动覆盖页面场景</h4>\n<p>传统自动化只能执行 “预设好的脚本”，覆盖的场景有限，而基于<strong>多模态 AI + 强化学习</strong>的探索式测试，让工具能像<strong>资深测试工程师一样，自主探索页面的所有功能场景</strong>，自动执行操作、校验结果，发现人工测试和传统自动化容易遗漏的 BUG。</p>\n<ul>\n<li>实现方式：AI 先通过视觉识别和语义理解，分析页面的所有元素（按钮、输入框、下拉框、链接等）和业务逻辑，生成合理的测试路径；然后自主执行操作（如随机点击、输入不同类型的数据、触发不同的交互组合），同时实时校验页面的响应结果（如是否报错、是否跳转到错误页面、数据是否显示异常），发现问题后自动截图、记录日志并标记 BUG 等级；</li>\n<li>核心价值：适合在新版本上线前，快速做全量场景的探索式测试，覆盖人工难以考虑到的边界场景、组合场景，提升测试的完整性。</li>\n</ul>\n<h4 id=\"玩法-5ai-生成测试数据--自动化适配场景造数据\">玩法 5：AI 生成测试数据 —— 自动化适配场景造数据</h4>\n<p>传统自动化测试中，测试数据（如账号、手机号、身份证号、订单号）需要人工准备或通过代码生成，而 AI 能根据测试场景，<strong>智能生成贴合业务的真实测试数据</strong>，还能自动适配边界值、异常值场景。</p>\n<ul>\n<li>实现方式：测试人员只需描述数据需求，比如 “生成 10 个有效的手机号”“生成 5 个不符合格式的身份证号”“生成 3 个符合电商平台规则的订单号，包含字母和数字”，AI 会自动生成对应的测试数据，还能直接将数据注入到自动化脚本中，实现 “数据 + 脚本” 的一体化执行。</li>\n</ul>\n<h4 id=\"玩法-6多模态-ai-测试--覆盖跨端--非标准-ui-场景\">玩法 6：多模态 AI 测试 —— 覆盖跨端 / 非标准 UI 场景</h4>\n<p>传统工具对<strong>图片、视频、小程序、H5 混合页面</strong>等非标准 UI 场景的覆盖率极低，而基于<strong>多模态大模型</strong>的 AI 测试，能融合 “视觉、文本、语音” 等多种信息，实现跨端、非标准 UI 场景的自动化测试。</p>\n<ul>\n<li>适配场景：识别页面中的图片验证码并自动破解、测试小程序中的图文混合模块、测试 APP 中的语音交互功能、测试电商平台的商品图片展示和点击功能等，彻底打破传统 UI 自动化的场景覆盖限制。</li>\n</ul>\n<p>除了上述提到的六种AI玩法外，其实还有很多，这里就不一一列举了，后面将会在「<strong>狂师. AI进化社</strong>」中，逐步分享。</p>\n<h2 id=\"4-ai测试工具\">4. AI测试工具</h2>\n<p>讲到这里，你可能会说，上面这些AI测试的玩法是不是都还是停留在理论层面，属于理想测试的状态吧，但现实是，你或许还停留在“井”里，事实是，已经有很多先辈，利用上面的这些AI玩法，已经在2倍、10倍、提升工作效能了。</p>\n<p>要实现上述的这些玩法，有两种方式：</p>\n<ul>\n<li>自己利用AI技术，自己开发，自己定制。（灵活度高，对技术要求也高）</li>\n<li>用现有的AI测试工具。（缺点有什么，用什么，优点是快，开箱即用）</li>\n</ul>\n<p>目前，市面上的AI测试工具有很多，在我之前公众号技术推文分享中，也给大家推荐过一些，比如<code>Testim</code>、<code>Applitools</code>、<code>Browser Use</code>、<code>Midscene</code>、<code>Playwright MCP</code>等。</p>\n<p>如果是你是AI零基础新手，此前，从来没有接触过AI测试工具，那我强烈你先使用<code>Midscene</code>。</p>\n<p><code>Midscene</code>作为AI测试工具中的典型代表，它更接近真实用户操作视角，对视觉变化适应性强，减少了对DOM的绝对依赖，相比有些AI测试工具来说，它在定位动态元素时更稳定，尤其在桥接模式下，还能复用浏览器Cookie，避免重复登录的问题。</p>\n<p>接下来，我就以<code>Midscene</code> 为例，来带大家感受一下Midscen`做UI自动化测试的魅力，不需要你写一行代码，不需要你定位元素，你只需要描述需求，指拿打拿，任何人都可以用它来开展自动化测试。</p>\n<blockquote>\n<p>其它的AI测试工具，后续会逐步分享到<strong>狂师.AI 进化社</strong>-&gt;<strong>AI工具百宝箱</strong>对应的版块中。</p>\n</blockquote>\n<h2 id=\"5-带你快速体验-midscens\">5. 带你快速体验 Midscens</h2>\n<p>由于本篇教程，并不是专门讲解<code>Midscens</code>的特性，主要是让大家提前感受一下AI测试所带来的实际效果。</p>\n<p>所以不会，花太多内容篇符来介绍<code>Midscens</code>特性，具体关于<code>Midscens</code>的工具介绍，后续在<strong>AI进化社</strong>中，会有专门工具教程分享。</p>\n<p>为了照顾新手，还是简单科普一下：</p>\n<blockquote>\n<p>Midscens，更具体一点的叫法，是<code>Midscene.js</code>，由字节跳动的Web Infra团队开发（一个负责字节内部Web基础设施效能提升的团队）。</p>\n<p>定位：是一款 AI驱动的自动化测试工具，且是开源的。</p>\n<p>它通过多模态大语言模型（LLM）实现对用户界面的“理解”，并自动执行端到端（e2e）测试任务，核心特点是能够直接解析 UI 元素的视觉和语义信息，模拟用户操作行为。</p>\n</blockquote>\n<p><strong>简单来说</strong>：<code>Midscene.js</code> 是一个让使用者，直接用自然语言的方式描述 UI 操作，由 AI帮你自动定位元素、生成脚本、执行测试”的智能 UI 自动化工具。人提需求，AI帮你自动执行测试，本质上和AI 编程的思想是一样的。</p>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260131214243942.png\" /></p>\n<p>更进一步的介绍，感兴趣的话，可以访问它的<a href=\"https://midscenejs.com/zh/\" rel=\"noopener nofollow\" target=\"_blank\">官网</a>来学习：<code>https://midscenejs.com/</code></p>\n<ul>\n<li>帮助文档：<a href=\"https://midscenejs.com/zh/introduction\" rel=\"noopener nofollow\" target=\"_blank\">https://midscenejs.com/zh/introduction</a></li>\n<li>源码地址：<a href=\"https://github.com/web-infra-dev/midscene\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/web-infra-dev/midscene</a></li>\n</ul>\n<p>这里，值得再提一点的是，<code>Midscene.js</code>虽最初是为Web自动化测试而设计的，但它也同样支持Android、iOS等多端应用，任意界面都可以。</p>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260131214515527.png\" /></p>\n<p>说了，这么多，新手该如何使用呢？概括起来，分几步：</p>\n<h3 id=\"51-环境准备\">5.1 环境准备</h3>\n<p><code>Midscene.js</code>，提供了多种集成使用方式：</p>\n<ul>\n<li>浏览器插件</li>\n<li>与 Playwright的SDK集成（又分为两种：一种直接用脚本方式集成和调用<code>Midscene Agent</code>，另外一种在 <code>Playwright</code> 的测试用例中集成<code>Midscene</code>模块）</li>\n<li>与Puppeteer的SDK集成 (也有两种集成方式，可参考Playwright，同上)</li>\n<li>命令行调用</li>\n<li>API调用</li>\n</ul>\n<p>需要注意，不同端，需要准备的环境会有所不一样，新手优先推荐以<strong>Web端+浏览器插件</strong>使用方式为主，通过使用<code>Midscene.js Chrome</code>插件，你可以快速在任意网页上体验 <code>Midscene</code> 的主要功能，而无需编写任何代码。</p>\n<p>其它的集成方式，以及<code>Android</code>、<code>iOS</code>端如何使用<code>Midscene</code>，后面会根据MVP迭代的安排，逐步在<code>AI 工具百宝箱</code>版块内更新，大家感兴趣的话，也可以提前查看<a href=\"https://midscenejs.com/zh/android-introduction.html\" rel=\"noopener nofollow\" target=\"_blank\">官方帮助文档</a>，官方文档里也提供了很多实战案例。</p>\n<h3 id=\"52-安装方法\">5.2 安装方法</h3>\n<p>如果想通过 <code>Midscene.js Chrome</code> 插件快速体验AI测试的话，我们需要先前往 Chrome 扩展商店安装 <code>Midscene 扩展</code></p>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201124737578.png\" /></p>\n<p>或者直接在<code>github</code>中下载releaese压缩包，直接拖到chrome浏览器扩展程序页中，即可安装</p>\n<pre><code>https://github.com/web-infra-dev/midscene/releases\n</code></pre>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201101301468.png\" /></p>\n<p>插件安装完成后，启动扩展（可能默认折叠在 Chrome 扩展列表中），你应该能在浏览器右侧看到名为 “Midscene” 的侧边栏。</p>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201125014786.png\" /></p>\n<h3 id=\"53-ai模型选择\">5.3 AI模型选择</h3>\n<p>安装完<code>Midscene</code>插件之后，你还无法立即正常使用它来开展自动化测试，因为你此时只是安装了一个躯壳，还没有指挥大脑，而这个大脑，就是我们常说的<strong>大模型</strong>。</p>\n<p>讲到这里，就不得不提一句 AI 工具的核心本质：<strong>几乎所有的 AI 测试工具，乃至各类 AI 编程工具，本质上都只是做了一层面向用户的交互应用层封装</strong>，其核心能力的实现，底层终究需要依托特定的大模型来驱动。而一款 AI 测试工具的实际使用效果好坏，也正与它背后选用的大模型能力强弱、适配性高低息息相关。</p>\n<p>而使用 AI 大模型驱动 UI 自动化的有两个关键点：规划合理的操作路径，以及准确找到需要交互的元素。其中“元素定位”能力的强弱，会直接影响到自动化任务的成功率。</p>\n<p>为了完成元素定位工作，UI 自动化框架一般有两种技术路线：</p>\n<ul>\n<li>基于 DOM + 截图标注：提前提取页面的 DOM 结构，结合截图做好标注，请模型“挑选”其中的内容。</li>\n<li>纯视觉：利用模型的视觉定位能力，基于截图完成所有分析工作，即模型收到的只有图片，没有 DOM，也没有标注信息。</li>\n</ul>\n<h4 id=\"1-midscene-支持纯视觉元素定位\">1. Midscene 支持纯视觉元素定位</h4>\n<p><code>Midscene</code> 早期同时兼容「DOM 定位」和「纯视觉」两种技术路线。</p>\n<p>但DOM 定位方案的稳定性不足，经常会在 Canvas 元素、CSS background-image 绘制的控件、跨域 iframe 中的内容、没有充分被辅助技术标注的元素等情况下出现定位偏差。</p>\n<p>与此同时，采用「纯视觉」方案，相对于DOM定位方案来说，优势明显，主要体现在：</p>\n<ul>\n<li><strong>效果稳定</strong>：在 UI 操作规划、组件定位、界面理解等领域的综合表现较好，能够帮助使用者更快上手。</li>\n<li><strong>适用于任意系统</strong>：自动化框架不再依赖 UI 渲染的技术栈。无论是 Android、iOS、桌面应用，还是浏览器中的 canvas 标签，只要能获取截图，Midscene 即可完成交互操作。</li>\n<li><strong>易于编写</strong>：抛弃各类 selector 和 DOM 之后，使用者与模型的“磨合”会变得更简单，不熟悉渲染技术的新人也能很快上手。</li>\n<li><strong>token 量显著下降</strong>：相较于 DOM 方案，视觉方案的 token 使用量最多可以减少 80%，成本更低，且本地运行速度也变得更快。</li>\n</ul>\n<p>因此，<strong>从 1.0 版本开始，Midscene 只支持纯视觉方案</strong>，在UI操作与元素定位方面，不再提供“提取 DOM”的兼容模式。</p>\n<h4 id=\"2-midscene推荐使用的视觉模型\">2. Midscene推荐使用的视觉模型</h4>\n<p>使用<code>Midscene</code>，选择模型时，也是有讲究的，并不是随便找个大模型都可以用，必须使用多模型模型，也就是需要支持图像输入，视觉能力的模型才可以。</p>\n<p>官方，推荐使用 <code>Midscene</code> 的默认模型有：</p>\n<ul>\n<li><a href=\"https://midscenejs.com/zh/model-common-config.html#doubao-seed-model\" rel=\"noopener nofollow\" target=\"_blank\">豆包 Seed 模型</a></li>\n<li><a href=\"https://midscenejs.com/zh/model-common-config.html#qwen3-vl\" rel=\"noopener nofollow\" target=\"_blank\">千问 Qwen3-VL</a></li>\n<li><a href=\"https://midscenejs.com/zh/model-common-config.html#qwen25-vl\" rel=\"noopener nofollow\" target=\"_blank\">千问 Qwen2.5-VL</a></li>\n<li><a href=\"https://midscenejs.com/zh/model-common-config.html#glm-v\" rel=\"noopener nofollow\" target=\"_blank\">智谱 GLM-V</a></li>\n<li><a href=\"https://midscenejs.com/zh/model-common-config.html#auto-glm\" rel=\"noopener nofollow\" target=\"_blank\">智谱 AutoGLM</a></li>\n<li><a href=\"https://midscenejs.com/zh/model-common-config.html#gemini-3-pro\" rel=\"noopener nofollow\" target=\"_blank\">Gemini-3-Pro / Gemini-3-Flash</a></li>\n<li><a href=\"https://midscenejs.com/zh/model-common-config.html#ui-tars\" rel=\"noopener nofollow\" target=\"_blank\">UI-TARS</a></li>\n</ul>\n<p>这些模型都具备良好的“元素定位”能力，且在任务规划、界面理解等场景上也有不错的表现。如果你不知道从哪里开始，选用你眼下最容易获得的模型即可。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">模型系列</th>\n<th style=\"text-align: left;\">部署</th>\n<th style=\"text-align: left;\">Midscene 评价</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">豆包 Seed 模型 <br /><a href=\"https://midscenejs.com/zh/model-common-config.html#doubao-seed-model\" rel=\"noopener nofollow\" target=\"_blank\">快速配置</a></td>\n<td style=\"text-align: left;\">火山引擎版本： <a href=\"https://www.volcengine.com/docs/82379/1799865\" rel=\"noopener nofollow\" target=\"_blank\">Doubao-Seed-1.6-Vision</a></td>\n<td style=\"text-align: left;\">⭐⭐⭐⭐                         UI 操作规划、定位能力较强 速度略慢</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">千问 Qwen3-VL<br /> <a href=\"https://midscenejs.com/zh/model-common-config.html#qwen3-vl\" rel=\"noopener nofollow\" target=\"_blank\">快速配置</a></td>\n<td style=\"text-align: left;\"><a href=\"https://help.aliyun.com/zh/model-studio/vision\" rel=\"noopener nofollow\" target=\"_blank\">阿里云</a> <a href=\"https://openrouter.ai/qwen\" rel=\"noopener nofollow\" target=\"_blank\">OpenRouter</a> <a href=\"https://ollama.com/library/qwen3-vl\" rel=\"noopener nofollow\" target=\"_blank\">Ollama(开源)</a></td>\n<td style=\"text-align: left;\">⭐⭐⭐⭐ <br />复杂场景断言能力不够稳定 性能超群，操作准确 有开源版本（<a href=\"https://huggingface.co/Qwen\" rel=\"noopener nofollow\" target=\"_blank\">HuggingFace</a> / <a href=\"https://github.com/QwenLM/\" rel=\"noopener nofollow\" target=\"_blank\">Github</a>）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">千问 Qwen2.5-VL <br /><a href=\"https://midscenejs.com/zh/model-common-config.html#qwen25-vl\" rel=\"noopener nofollow\" target=\"_blank\">快速配置</a></td>\n<td style=\"text-align: left;\"><a href=\"https://help.aliyun.com/zh/model-studio/vision\" rel=\"noopener nofollow\" target=\"_blank\">阿里云</a> <a href=\"https://openrouter.ai/qwen\" rel=\"noopener nofollow\" target=\"_blank\">OpenRouter</a></td>\n<td style=\"text-align: left;\">⭐⭐⭐ <br />综合效果不如 Qwen3-VL</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">智谱 GLM-4.6V <br /><a href=\"https://midscenejs.com/zh/model-common-config.html#glm-v\" rel=\"noopener nofollow\" target=\"_blank\">快速配置</a></td>\n<td style=\"text-align: left;\"><a href=\"https://docs.z.ai/guides/vlm/glm-4.6v\" rel=\"noopener nofollow\" target=\"_blank\">Z.AI (Global)</a> <a href=\"https://docs.bigmodel.cn/cn/guide/models/vlm/glm-4.6v\" rel=\"noopener nofollow\" target=\"_blank\">BigModel (CN)</a></td>\n<td style=\"text-align: left;\">全新接入，欢迎体验 模型权重开源<a href=\"https://huggingface.co/zai-org/GLM-4.6V\" rel=\"noopener nofollow\" target=\"_blank\">HuggingFace</a></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Gemini-3-Pro / Gemini-3-Flash <br /><a href=\"https://midscenejs.com/zh/model-common-config.html#gemini-3-pro\" rel=\"noopener nofollow\" target=\"_blank\">快速配置</a></td>\n<td style=\"text-align: left;\"><a href=\"https://ai.google.dev/gemini-api/docs/models/gemini\" rel=\"noopener nofollow\" target=\"_blank\">Google Cloud</a></td>\n<td style=\"text-align: left;\">⭐⭐⭐ <br />支持 Gemini-3-Flash 价格高于豆包和千问</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">UI-TARS<br /> <a href=\"https://midscenejs.com/zh/model-common-config.html#ui-tars\" rel=\"noopener nofollow\" target=\"_blank\">快速配置</a></td>\n<td style=\"text-align: left;\"><a href=\"https://www.volcengine.com/docs/82379/1536429\" rel=\"noopener nofollow\" target=\"_blank\">火山引擎</a></td>\n<td style=\"text-align: left;\">⭐⭐ <br />有探索能力，但在不同场景表现可能差异较大 有开源版本（<a href=\"https://huggingface.co/bytedance-research/UI-TARS-72B-SFT\" rel=\"noopener nofollow\" target=\"_blank\">HuggingFace</a> / <a href=\"https://github.com/bytedance/ui-tars\" rel=\"noopener nofollow\" target=\"_blank\">Github</a>）</td>\n</tr>\n</tbody>\n</table>\n<p>如果你完全没有头绪，我推荐选择<code>千问 Qwen3-VL</code>或智谱<code> GLM-4.6V</code>。</p>\n<h3 id=\"54-模型配置\">5.4 模型配置</h3>\n<h4 id=\"1-申请大模型api-key\">1. 申请大模型API KEY</h4>\n<p>以<code>千问 Qwen3-VL</code>为例。</p>\n<p>1、访问<code>DashScope</code>管理<a href=\"https://dashscope.console.aliyun.com/\" rel=\"noopener nofollow\" target=\"_blank\">控制台</a></p>\n<pre><code>https://dashscope.console.aliyun.com/\n</code></pre>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201122300613.png\" /></p>\n<p>2、点击开通服务（DashScope 模型服务），跳转到阿里云百炼平台</p>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201122342667.png\" /></p>\n<p>3、开通之后，新用户每个模型都会赚送100w的免费体验额度</p>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201122509525.png\" /></p>\n<p>在阿里云百炼模型广场中，可以查看到所有支持的模型</p>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201122837281.png\" /></p>\n<p>比如我们要选用的<code>qwen3-vl-plus</code>，这个是通义千问推出来的新版视觉理解模型，如果你不清楚，你能不能用这个模型，可以点击进入看一下还有没有免费额度</p>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201123211973.png\" /></p>\n<p>如果免费额度用完了，还想用，也可以再花点小钱，购买它的token套餐。</p>\n<p>4、选择<code>密钥管理</code>-&gt;创建<code>API KEY</code></p>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201123547539.png\" /></p>\n<p>复制<code>API Key</code>，不要泄露给别人，自己拿个小本本记下来就行</p>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201123629460.png\" /></p>\n<h4 id=\"2-配置环境变量\">2. 配置环境变量</h4>\n<p>有了API Key之后，需要将模型配置参数项放置在系统环境变量中，Midscene 会自动读取这些环境变量。</p>\n<p>配置环境变量常用的有两种方式：</p>\n<ul>\n<li>在 <code>Midscene Chrome</code> 插件中，你也可以使用这种 <code>export KEY=\"value\"</code> 配置格式</li>\n</ul>\n<pre><code class=\"language-bash\"># 替换为你自己的 API Key\nexport MIDSCENE_MODEL_BASE_URL=\"https://dashscope.aliyuncs.com/compatible-mode/v1\"\nexport MIDSCENE_MODEL_API_KEY=\"sk-abcdefghijklmnopqrstuvwxyz\"\nexport MIDSCENE_MODEL_NAME=\"qwen3-vl-plus\"\nexport MIDSCENE_MODEL_FAMILY=\"qwen3-vl\"\n</code></pre>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201125206521.png\" /></p>\n<ul>\n<li>在项目的运行路径下创建一个 <code>.env</code> 文件，并添加以下内容，Midscene 的命令行工具默认会读取这个文件。（该种方式适用于命令行工具）</li>\n</ul>\n<pre><code class=\"language-BASH\">MIDSCENE_MODEL_BASE_URL=\"https://dashscope.aliyuncs.com/compatible-mode/v1\"\nMIDSCENE_MODEL_API_KEY=\"sk-abcdefghijklmnopqrstuvwxyz\"\nMIDSCENE_MODEL_NAME=\"qwen3-vl-plus\"\nMIDSCENE_MODEL_FAMILY=\"qwen3-vl\"\n</code></pre>\n<blockquote>\n<p>请注意：这里不需要在每一行前添加 <code>export</code>，且只有 Midscene 命令行工具会默认读取这个文件</p>\n</blockquote>\n<h3 id=\"55-快速体验\">5.5 快速体验</h3>\n<p>讲到这里，所有的准备工作，都已经做好了，想必此时的你，已经迫不及待，要体验一下Midscene了。</p>\n<p>1、在Midscene输入框中，输入提示词指令：<code>打开浏览器，访问百度页面，在输入框中Python，点击搜索</code>，选择第一个Action类型，可以理解，该类型会根据你的需求自动帮你规划，执行，有点类似Agent一样。</p>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260202084359423.png\" /></p>\n<p>几个常用的操作类型：</p>\n<ul>\n<li>Action：AI自动规划执行任务</li>\n<li>Query：常用于提取数据</li>\n<li>Assert：常用于断言</li>\n<li>Tap（点击）：用于点击操作</li>\n</ul>\n<p>2、当点击运行后，Midscene会根据我们的指令意图，帮我们自动规则任务，执行操作，比如打开百度，自动找到百度页面的输入框，并输入Python，点击搜索等的操作。所有的控制过程，都不需要我们自己写代码，找元素定位，你只需要将你的要求用自然语言描述出来就可以了。</p>\n<p>具体执行效果，大家可以看这个动画视频，也可自行在本地尝试运行。</p>\n<blockquote>\n<p>这里面有一个小坑，如果你打开的是一个空网页，即地址栏为空时，发送指令时，会报错Cannot access a chrome:// URL</p>\n</blockquote>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201132348598.png\" /></p>\n<p>也就意味着，大家用Midscene浏览器插件进行AI自动化时，要先停留在某个页面，至少要确保地址栏不能为空，这个有点小鸡肋。当然影响不大，看官方后续会不会优化一下吧。</p>\n<p>3、除了这种常规用法，<code>Midscene</code>还支持桥接模式连接，<code>Midscene Chrome</code> 插件的桥接模式允许你使用本地脚本来控制桌面版 Chrome。脚本既能连接新标签页，也可以附着到当前激活的标签页。这种方式能复用本地浏览器的 cookies、插件和页面状态，与自动化脚本协作完成任务；在自动化领域也被称作 “man-in-the-loop”。</p>\n<p><strong>为什么需要桥接模式呢？</strong> 因为正常情况下，<code>Midscene</code>每次执行任务都会先打开一个全新的浏览器窗口，但很多场景下，操作页面都需要进行用户登录认证，通过桥接模式连接，可以直接复用本地已有的Cookie和页面状态，不必在执行AI测试任务期间手工来完成登录操作。</p>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201133546151.png\" /></p>\n<p>运行任务前，先点击 “Allow connection” ，执行后你会看到插件状态变为 “connected”</p>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201133639128.png\" /></p>\n<p>讲到这里，你已经基本掌握了如何利用插件的方式来简单使用<code>Midscene</code>了，但还不够。</p>\n<h3 id=\"56-进阶使用\">5.6 进阶使用</h3>\n<p>前面我们已经学习了，如何通过Chrome浏览器插件的方式来使用Midscene了，但这种方式比较鸡肋，不太适合<strong>规划化</strong>、<strong>持久化</strong>、<strong>资产化</strong>。</p>\n<p><strong>怎么理解呢？</strong></p>\n<p>你想，我们利用Midscene开展自动化时，总不能每次在执行自动化测试之前，还要人工手动打开浏览器插件，把指令手工喂给它吧，那这不叫自动化测试！</p>\n<p>自动化测试，最起码的一点要求，前期只要准备好了测试脚本或AI指令提示词，后续的所有执行动作，都应该是不需要人为介入的。</p>\n<p>还有更重要的一点，浏览器插件的这种方式，我们很难在企业中，将业务测试用例持久化、资产化复用起来。</p>\n<p>所以接下来，我再花一点点时间，分享一下，Midscene另外的一种进阶用法：<strong>命令行+配置文件</strong>的方式。</p>\n<p>简单来说，Midscene 定义了一种 YAML 格式的脚本，可以让开发者快速编写自动化脚本，并提供了对应的命令行工具来快速执行这些脚本。</p>\n<blockquote>\n<p>如果说插件的方式，只是为了提供给使用者简单体验一下，那<strong>命令行+配置文件</strong>方式，就比较适合企业内正式使用了。</p>\n</blockquote>\n<h4 id=\"1-如何上手\">1. 如何上手</h4>\n<p>1、全局安装 <code>@midscene/cli</code> （推荐新手使用）：</p>\n<pre><code>npm i -g @midscene/cli\n</code></pre>\n<p>或在项目中按需安装</p>\n<pre><code>npm i @midscene/cli --save-dev\n</code></pre>\n<p>2、新建一个项目目录，在目录下编写YAML配置文件，可以理解为YAML配置文件就是midscene的测试脚本，比如创建一个名为 <code>bing-search.yaml</code> 的文件：</p>\n<pre><code class=\"language-YAML\">web:\n  url: https://www.bing.com\n\ntasks:\n  - name: 搜索天气\n    flow:\n      - ai: 搜索 \"今日天气\"\n      - sleep: 3000\n      - aiAssert: 结果显示天气信息\n</code></pre>\n<p>3、在项目目录，创建.env文件，配置AI模型驱动的环境变量信息</p>\n<pre><code class=\"language-bash\">MIDSCENE_MODEL_BASE_URL=\"https://dashscope.aliyuncs.com/compatible-mode/v1\"\n# 替换成自己的API KEY\nMIDSCENE_MODEL_API_KEY=\"sk-abcdefghijklmnopqrstuvwxyz\"\nMIDSCENE_MODEL_NAME=\"qwen3-vl-plus\"\nMIDSCENE_MODEL_FAMILY=\"qwen3-vl\"\n</code></pre>\n<p>4、通过命令行来执行它：</p>\n<pre><code class=\"language-bash\">midscene ./bing-search.yaml\n# 如果在项目中安装了 Midscene\nnpx midscene ./bing-search.yaml\n</code></pre>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201141958373.png\" /></p>\n<p>5、在配置文件中，如果涉及到一些动态变量，可以通过 <code>${variable-name}</code> 引用环境变量来实现，如：</p>\n<pre><code>topic=weather today\n</code></pre>\n<pre><code># ...\n- ai: 在输入框中输入 ${topic}\n# ...\n</code></pre>\n<p>6、<code>@midscene/cli</code> 支持使用通配符匹配多个脚本来批量执行脚本，这相当于 <code>--files</code> 参数的简写。</p>\n<pre><code># 运行单个脚本\nmidscene ./bing-search.yaml\n\n# 使用通配符模式运行所有匹配的脚本\nmidscene './scripts/**/*.yaml'\n</code></pre>\n<p>7、执行完成后，输出目录会包含：</p>\n<ul>\n<li><code>--summary</code> 指定的 JSON 报告（默认 <code>index.json</code>），记录所有脚本的执行状态与统计数据。</li>\n<li>每个 YAML 文件对应的独立执行结果（JSON 格式）。</li>\n<li>每个脚本生成的可视化报告（HTML 格式）。</li>\n</ul>\n<p><img alt=\"\" src=\"https://image.kjdaohang.com/PicGo/20260201142119212.png\" /></p>\n<p>8、默认情况下脚本是在无头模式下运行，如果想打开浏览器窗口，可以带上<code>Headed</code>参数</p>\n<pre><code class=\"language-bash\"># 运行在 headed 模式\nmidscene /path/to/yaml --headed\n\n# 运行在 headed 模式并在结束后保留窗口\nmidscene /path/to/yaml --keep-window\n</code></pre>\n<p>9、如果你想在脚本中，使用桥接模式让 YAML 脚本驱动现有的桌面浏览器，复用 Cookies、插件或已有状态。先安装 Chrome 扩展，然后在 <code>web</code> 配置中加入：</p>\n<pre><code>web:\n  url: https://www.bing.com\n+ bridgeMode: newTabWithUrl\n</code></pre>\n<h4 id=\"2-命令行参数\">2. 命令行参数</h4>\n<p>命令行工具提供了多项参数，用于控制脚本的执行行为：</p>\n<ul>\n<li><code>--files &lt;file1&gt; &lt;file2&gt; ...</code>：指定脚本文件列表。默认按顺序执行（<code>--concurrent</code> 为 <code>1</code>），可通过 <code>--concurrent</code> 设置并发数量。支持 <a href=\"https://www.npmjs.com/package/glob\" rel=\"noopener nofollow\" target=\"_blank\">glob</a> 通配符语法。</li>\n<li><code>--concurrent &lt;number&gt;</code>：设置并发执行的数量，默认 <code>1</code>。</li>\n<li><code>--continue-on-error</code>：启用后，即使某个脚本失败也会继续执行后续脚本。默认关闭。</li>\n<li><code>--share-browser-context</code>：在多个脚本之间共享浏览器上下文（Cookies、<code>localStorage</code> 等），适合需要连续登录态的场景。默认关闭。</li>\n<li><code>--summary &lt;filename&gt;</code>：指定生成的 JSON 总结报告路径。</li>\n<li><code>--headed</code>：在带界面的浏览器中运行脚本，而非默认的无头模式。</li>\n<li><code>--keep-window</code>：脚本执行完成后保持浏览器窗口，会自动开启 <code>--headed</code> 模式。</li>\n<li><code>--config &lt;filename&gt;</code>：指定配置文件，文件中的参数会作为命令行参数的默认值。</li>\n<li><code>--web.userAgent &lt;ua&gt;</code>：设置浏览器 UA，覆盖所有脚本中的 <code>web.userAgent</code>。</li>\n<li><code>--web.viewportWidth &lt;width&gt;</code>：设置浏览器视口宽度，覆盖所有脚本中的 <code>web.viewportWidth</code>。</li>\n<li><code>--web.viewportHeight &lt;height&gt;</code>：设置浏览器视口高度，覆盖所有脚本中的 <code>web.viewportHeight</code>。</li>\n<li><code>--android.deviceId &lt;device-id&gt;</code>：设置安卓设备 ID，覆盖所有脚本中的 <code>android.deviceId</code>。</li>\n<li><code>--ios.wdaPort &lt;port&gt;</code>：设置 WebDriverAgent 端口，覆盖所有脚本中的 <code>ios.wdaPort</code>。</li>\n<li><code>--ios.wdaHost &lt;host&gt;</code>：设置 WebDriverAgent 主机地址，覆盖所有脚本中的 <code>ios.wdaHost</code>。</li>\n<li><code>--dotenv-debug</code>：开启 dotenv 的调试日志，默认关闭。</li>\n<li><code>--dotenv-override</code>：允许 dotenv 覆盖同名的全局环境变量，默认关闭。</li>\n</ul>\n<p>比如，使用 <code>--files</code> 指定执行顺序：</p>\n<pre><code class=\"language-bash\">midscene --files ./login.yaml ./buy/*.yaml ./checkout.yaml\n</code></pre>\n<p><code>midscene</code>支持并发运行，如以 4 个并发执行所有脚本，并在出错时继续运行：</p>\n<pre><code class=\"language-bash\">midscene --files './scripts/**/*.yaml' --concurrent 4 --continue-on-error\n</code></pre>\n<p>还可以把参数写到 YAML 配置文件中，并通过 <code>--config</code> 引用，命令行传入的参数优先级高于配置文件。</p>\n<pre><code class=\"language-bash\">files:\n  - './scripts/login.yaml'\n  - './scripts/search.yaml'\n  - './scripts/**/*.yaml'\n\nconcurrent: 4\ncontinueOnError: true\nshareBrowserContext: true\n</code></pre>\n<p>运行方式：</p>\n<pre><code class=\"language-bash\">midscene --config ./config.yaml\n</code></pre>\n<p>好了，通过学习Chrome插件和命令行的这两种方式，我相信你，已经可以完全能上手操作<code>midscene</code>，还在等什么🤣，赶紧体验一下AI测试的乐趣吧。</p>\n<blockquote>\n<p>除了文中提到的，midscene还有很多高级的进阶玩法，后面会统一分享到AI进化社内。</p>\n</blockquote>\n<h2 id=\"6-最在最后\">6. 最在最后</h2>\n<p>在牛刀小试版块，特意挑选了<strong>AI编程</strong>和<strong>AI测试</strong>两个场景下的小案例，通过在10分钟内完成第一个AI应用并上线，体验AI编程（Vibe Coding）、AI测试的核心魅力，帮助大家建立对AI能力的直观认知。（当然，目前你所看到的也才只是AI能力的冰山一角）</p>\n<p>回归标题，别再只做点点点的重复劳动！AI+LLM 测试的强大，核心就在于重构了测试的核心逻辑！不管AI技术发展如何强大，但技术终究要回归于人。</p>\n<p>而以 <code>Midscene</code> 为代表的 AI 自动化工具，正彻底改写传统测试、传统编程的游戏规则。它让测试人员、开发人员从纠结 “<strong>怎么做</strong>” 的技术细节里抽离，聚焦于 “<strong>要做什么</strong>” 的核心需求，真正从重复低效的手工操作中解放出来，将精力投入到更高价值的业务场景探索、产品质量深度洞察中，而这恰恰才是 AI+LLM 测试的真正魅力。</p>\n<p>我的实践表明：仅初步使用Midscene，脚本编写效率就提升了3倍以上，维护成本大幅下降，非技术人员也能快速上手写用例。这已不仅是工具升级，更是一场测试理念的进化。</p>\n<p>如果你还在苦于UI自动化，不妨从今天开始：</p>\n<ul>\n<li>安装Midscene插件，用自然语言写第一个测试脚本；</li>\n<li>从小场景验证，逐步扩展到核心业务流程；</li>\n<li>建立团队内的提示词库与最佳实践。</li>\n</ul>\n<p>AI不会取代测试工程师，但会用AI的测试人，必将淘汰那些仍停留在“<strong>手工+硬编码</strong>”时代的团队。如果您有更好的想法或实践，欢迎一起探讨！也欢迎板砖！😄</p>\n\n\n</div>\n<div id=\"MySignature\">\n    技术改变世界！\n         --狂诗绝剑\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 09:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jinjiangongzuoshi\">狂师</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Unsafe魔法类深度解析：Java底层操作的终极指南",
      "link": "https://www.cnblogs.com/sevencoding/p/19559023",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sevencoding/p/19559023\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 09:00\">\n    <span>Unsafe魔法类深度解析：Java底层操作的终极指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"介绍\">介绍</h2>\n<p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</p>\n<p>这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。</p>\n<p>先来看下这张图，对UnSafe类总体功能：</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404251040445.jpg\" /></p>\n<p>如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。</p>\n<h2 id=\"内存操作\">内存操作</h2>\n<h3 id=\"介绍-1\">介绍</h3>\n<p>如果你是一个写过 C 或者 C++ 的程序员，一定对内存操作不会陌生，而在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 <code>Unsafe</code> 中，提供的下列接口可以直接进行内存操作：</p>\n<pre><code class=\"language-java\">//分配新的本地空间\npublic native long allocateMemory(long bytes);\n//重新调整内存空间的大小\npublic native long reallocateMemory(long address, long bytes);\n//将内存设置为指定值\npublic native void setMemory(Object o, long offset, long bytes, byte value);\n//内存拷贝\npublic native void copyMemory(Object srcBase, long srcOffset,Object destBase, long destOffset,long bytes);\n//清除内存\npublic native void freeMemory(long address);\n</code></pre>\n<p>使用下面的代码进行测试：</p>\n<pre><code class=\"language-java\">private void memoryTest() {\n    int size = 4;\n    long addr = unsafe.allocateMemory(size);\n    long addr3 = unsafe.reallocateMemory(addr, size * 2);\n    System.out.println(\"addr: \"+addr);\n    System.out.println(\"addr3: \"+addr3);\n    try {\n        unsafe.setMemory(null,addr ,size,(byte)1);\n        for (int i = 0; i &lt; 2; i++) {\n            unsafe.copyMemory(null,addr,null,addr3+size*i,4);\n        }\n        System.out.println(unsafe.getInt(addr));\n        System.out.println(unsafe.getLong(addr3));\n    }finally {\n        unsafe.freeMemory(addr);\n        unsafe.freeMemory(addr3);\n    }\n}\n</code></pre>\n<p>先看结果输出：</p>\n<pre><code class=\"language-plain\">addr: 2433733895744\naddr3: 2433733894944\n16843009\n72340172838076673\n</code></pre>\n<p>分析一下运行结果，首先使用<code>allocateMemory</code>方法申请 4 字节长度的内存空间，调用<code>setMemory</code>方法向每个字节写入内容为<code>byte</code>类型的 1，当使用 Unsafe 调用<code>getInt</code>方法时，因为一个<code>int</code>型变量占 4 个字节，会一次性读取 4 个字节，组成一个<code>int</code>的值，对应的十进制结果为 16843009。</p>\n<p>你可以通过下图理解这个过程：</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130396.png\" /></p>\n<p>在代码中调用<code>reallocateMemory</code>方法重新分配了一块 8 字节长度的内存空间，通过比较<code>addr</code>和<code>addr3</code>可以看到和之前申请的内存地址是不同的。在代码中的第二个 for 循环里，调用<code>copyMemory</code>方法进行了两次内存的拷贝，每次拷贝内存地址<code>addr</code>开始的 4 个字节，分别拷贝到以<code>addr3</code>和<code>addr3+4</code>开始的内存空间上：</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130404.png\" /></p>\n<p>拷贝完成后，使用<code>getLong</code>方法一次性读取 8 个字节，得到<code>long</code>类型的值为 72340172838076673。</p>\n<p>需要注意，通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用<code>freeMemory</code>方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在<code>try</code>中执行对内存的操作，最终在<code>finally</code>块中进行内存的释放。</p>\n<p><strong>为什么要使用堆外内存？</strong></p>\n<ul>\n<li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</li>\n<li>提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>\n</ul>\n<h3 id=\"典型应用\">典型应用</h3>\n<p><code>DirectByteBuffer</code> 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。<code>DirectByteBuffer</code> 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。</p>\n<p>下图为 <code>DirectByteBuffer</code> 构造函数，创建 <code>DirectByteBuffer</code> 的时候，通过 <code>Unsafe.allocateMemory</code> 分配内存、<code>Unsafe.setMemory</code> 进行内存初始化，而后构建 <code>Cleaner</code> 对象用于跟踪 <code>DirectByteBuffer</code> 对象的垃圾回收，以实现当 <code>DirectByteBuffer</code> 被垃圾回收时，分配的堆外内存一起被释放。</p>\n<pre><code class=\"language-java\">DirectByteBuffer(int cap) {                   // package-private\n\n    super(-1, 0, cap, cap);\n    boolean pa = VM.isDirectMemoryPageAligned();\n    int ps = Bits.pageSize();\n    long size = Math.max(1L, (long)cap + (pa ? ps : 0));\n    Bits.reserveMemory(size, cap);\n\n    long base = 0;\n    try {\n        // 分配内存并返回基地址\n        base = unsafe.allocateMemory(size);\n    } catch (OutOfMemoryError x) {\n        Bits.unreserveMemory(size, cap);\n        throw x;\n    }\n    // 内存初始化\n    unsafe.setMemory(base, size, (byte) 0);\n    if (pa &amp;&amp; (base % ps != 0)) {\n        // Round up to page boundary\n        address = base + ps - (base &amp; (ps - 1));\n    } else {\n        address = base;\n    }\n    // 跟踪 DirectByteBuffer 对象的垃圾回收，以实现堆外内存释放\n    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n    att = null;\n}\n</code></pre>\n<h2 id=\"内存屏障\">内存屏障</h2>\n<h3 id=\"介绍-2\">介绍</h3>\n<p>在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（<code>Memory Barrier</code>）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。</p>\n<p>在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。</p>\n<p><code>Unsafe</code> 中提供了下面三个内存屏障相关方法：</p>\n<pre><code class=\"language-java\">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前\npublic native void loadFence();\n//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前\npublic native void storeFence();\n//内存屏障，禁止load、store操作重排序\npublic native void fullFence();\n</code></pre>\n<p>内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以<code>loadFence</code>方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。</p>\n<p>看到这估计很多小伙伴们会想到<code>volatile</code>关键字了，如果在字段上添加了<code>volatile</code>关键字，就能够实现字段在多线程下的可见性。基于读内存屏障，我们也能实现相同的功能。下面定义一个线程方法，在线程中去修改<code>flag</code>标志位，注意这里的<code>flag</code>是没有被<code>volatile</code>修饰的：</p>\n<pre><code class=\"language-java\">@Getter\nclass ChangeThread implements Runnable{\n    /**volatile**/ boolean flag=false;\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"subThread change flag to:\" + flag);\n        flag = true;\n    }\n}\n</code></pre>\n<p>在主线程的<code>while</code>循环中，加入内存屏障，测试是否能够感知到<code>flag</code>的修改变化：</p>\n<pre><code class=\"language-java\">public static void main(String[] args){\n    ChangeThread changeThread = new ChangeThread();\n    new Thread(changeThread).start();\n    while (true) {\n        boolean flag = changeThread.isFlag();\n        unsafe.loadFence(); //加入读内存屏障\n        if (flag){\n            System.out.println(\"detected flag changed\");\n            break;\n        }\n    }\n    System.out.println(\"main thread end\");\n}\n</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-plain\">subThread change flag to:false\ndetected flag changed\nmain thread end\n</code></pre>\n<p>而如果删掉上面代码中的<code>loadFence</code>方法，那么主线程将无法感知到<code>flag</code>发生的变化，会一直在<code>while</code>中循环。可以用图来表示上面的过程：</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130484.png\" /></p>\n<p>了解 Java 内存模型（<code>JMM</code>）的小伙伴们应该清楚，运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。</p>\n<h3 id=\"典型应用-1\">典型应用</h3>\n<p>在 Java 8 中引入了一种锁的新机制——<code>StampedLock</code>，它可以看成是读写锁的一个改进版本。<code>StampedLock</code> 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 <code>StampedLock</code> 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。</p>\n<p>为了解决这个问题，<code>StampedLock</code> 的 <code>validate</code> 方法会通过 <code>Unsafe</code> 的 <code>loadFence</code> 方法加入一个 <code>load</code> 内存屏障。</p>\n<pre><code class=\"language-java\">public boolean validate(long stamp) {\n   U.loadFence();\n   return (stamp &amp; SBITS) == (state &amp; SBITS);\n}\n</code></pre>\n<h2 id=\"对象操作\">对象操作</h2>\n<h3 id=\"介绍-3\">介绍</h3>\n<p><strong>例子</strong></p>\n<pre><code class=\"language-java\">import sun.misc.Unsafe;\nimport java.lang.reflect.Field;\n\npublic class Main {\n\n    private int value;\n\n    public static void main(String[] args) throws Exception{\n        Unsafe unsafe = reflectGetUnsafe();\n        assert unsafe != null;\n        long offset = unsafe.objectFieldOffset(Main.class.getDeclaredField(\"value\"));\n        Main main = new Main();\n        System.out.println(\"value before putInt: \" + main.value);\n        unsafe.putInt(main, offset, 42);\n        System.out.println(\"value after putInt: \" + main.value);\n  System.out.println(\"value after putInt: \" + unsafe.getInt(main, offset));\n    }\n\n    private static Unsafe reflectGetUnsafe() {\n        try {\n            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            field.setAccessible(true);\n            return (Unsafe) field.get(null);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n}\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"language-plain\">value before putInt: 0\nvalue after putInt: 42\nvalue after putInt: 42\n</code></pre>\n<p><strong>对象属性</strong></p>\n<p>对象成员属性的内存偏移量获取，以及字段属性值的修改，在上面的例子中我们已经测试过了。除了前面的<code>putInt</code>、<code>getInt</code>方法外，Unsafe 提供了全部 8 种基础数据类型以及<code>Object</code>的<code>put</code>和<code>get</code>方法，并且所有的<code>put</code>方法都可以越过访问权限，直接修改内存中的数据。阅读 openJDK 源码中的注释发现，基础数据类型和<code>Object</code>的读写稍有不同，基础数据类型是直接操作的属性值（<code>value</code>），而<code>Object</code>的操作则是基于引用值（<code>reference value</code>）。下面是<code>Object</code>的读写方法：</p>\n<pre><code class=\"language-java\">//在对象的指定偏移地址获取一个对象引用\npublic native Object getObject(Object o, long offset);\n//在对象指定偏移地址写入一个对象引用\npublic native void putObject(Object o, long offset, Object x);\n</code></pre>\n<p>除了对象属性的普通读写外，<code>Unsafe</code> 还提供了 <strong>volatile 读写</strong>和<strong>有序写入</strong>方法。<code>volatile</code>读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和<code>Object</code>类型，以<code>int</code>类型为例：</p>\n<pre><code class=\"language-java\">//在对象的指定偏移地址处读取一个int值，支持volatile load语义\npublic native int getIntVolatile(Object o, long offset);\n//在对象指定偏移地址处写入一个int，支持volatile store语义\npublic native void putIntVolatile(Object o, long offset, int x);\n</code></pre>\n<p>相对于普通读写来说，<code>volatile</code>读写具有更高的成本，因为它需要保证可见性和有序性。在执行<code>get</code>操作时，会强制从主存中获取属性值，在使用<code>put</code>方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。</p>\n<p>有序写入的方法有以下三个：</p>\n<pre><code class=\"language-java\">public native void putOrderedObject(Object o, long offset, Object x);\npublic native void putOrderedInt(Object o, long offset, int x);\npublic native void putOrderedLong(Object o, long offset, long x);\n</code></pre>\n<p>有序写入的成本相对<code>volatile</code>较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。为了解决这里的差异性，需要对内存屏障的知识点再进一步进行补充，首先需要了解两个指令的概念：</p>\n<ul>\n<li><code>Load</code>：将主内存中的数据拷贝到处理器的缓存中</li>\n<li><code>Store</code>：将处理器缓存的数据刷新到主内存中</li>\n</ul>\n<p>顺序写入与<code>volatile</code>写入的差别在于，在顺序写时加入的内存屏障类型为<code>StoreStore</code>类型，而在<code>volatile</code>写入时加入的内存屏障是<code>StoreLoad</code>类型，如下图所示：</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130467.png\" /></p>\n<p>在有序写入方法中，使用的是<code>StoreStore</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Store2</code>以及后续的存储指令操作。而在<code>volatile</code>写入中，使用的是<code>StoreLoad</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Load2</code>及后续的装载指令，并且，<code>StoreLoad</code>屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。</p>\n<p>综上所述，在上面的三类写入方法中，在写入效率方面，按照<code>put</code>、<code>putOrder</code>、<code>putVolatile</code>的顺序效率逐渐降低。</p>\n<p><strong>对象实例化</strong></p>\n<p>使用 <code>Unsafe</code> 的 <code>allocateInstance</code> 方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作：</p>\n<pre><code class=\"language-java\">@Data\npublic class A {\n    private int b;\n    public A(){\n        this.b =1;\n    }\n}\n</code></pre>\n<p>分别基于构造函数、反射以及 <code>Unsafe</code> 方法的不同方式创建对象进行比较：</p>\n<pre><code class=\"language-java\">public void objTest() throws Exception{\n    A a1=new A();\n    System.out.println(a1.getB());\n    A a2 = A.class.newInstance();\n    System.out.println(a2.getB());\n    A a3= (A) unsafe.allocateInstance(A.class);\n    System.out.println(a3.getB());\n}\n</code></pre>\n<p>打印结果分别为 1、1、0，说明通过<code>allocateInstance</code>方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了<code>Class</code>对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将 A 类的构造函数改为<code>private</code>类型，将无法通过构造函数和反射创建对象（可以通过构造函数对象 setAccessible 后创建对象），但<code>allocateInstance</code>方法仍然有效。</p>\n<h3 id=\"典型应用-2\">典型应用</h3>\n<ul>\n<li><strong>常规对象实例化方式</strong>：我们通常所用到的创建对象的方式，从本质上来讲，都是通过 new 机制来实现对象的创建。但是，new 机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</li>\n<li><strong>非常规的实例化方式</strong>：而 Unsafe 中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是 private 修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。</li>\n</ul>\n<h2 id=\"数组操作\">数组操作</h2>\n<h3 id=\"介绍-4\">介绍</h3>\n<p><code>arrayBaseOffset</code> 与 <code>arrayIndexScale</code> 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。</p>\n<pre><code class=\"language-java\">//返回数组中第一个元素的偏移地址\npublic native int arrayBaseOffset(Class&lt;?&gt; arrayClass);\n//返回数组中一个元素占用的大小\npublic native int arrayIndexScale(Class&lt;?&gt; arrayClass);\n</code></pre>\n<h3 id=\"典型应用-3\">典型应用</h3>\n<p>这两个与数据操作相关的方法，在 <code>java.util.concurrent.atomic</code> 包下的 <code>AtomicIntegerArray</code>（可以实现对 <code>Integer</code> 数组中每个元素的原子性操作）中有典型的应用，如下图 <code>AtomicIntegerArray</code> 源码所示，通过 <code>Unsafe</code> 的 <code>arrayBaseOffset</code>、<code>arrayIndexScale</code> 分别获取数组首元素的偏移地址 <code>base</code> 及单个元素大小因子 <code>scale</code> 。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 <code>getAndAdd</code> 方法即通过 <code>checkedByteOffset</code> 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作。</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130522.png\" /></p>\n<h2 id=\"cas-操作\">CAS 操作</h2>\n<h3 id=\"介绍-5\">介绍</h3>\n<p>这部分主要为 CAS 相关操作的方法。</p>\n<pre><code class=\"language-java\">/**\n  *  CAS\n  * @param o         包含要修改field的对象\n  * @param offset    对象中某field的偏移量\n  * @param expected  期望值\n  * @param update    更新值\n  * @return          true | false\n  */\npublic final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);\n\npublic final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);\n\npublic final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);\n</code></pre>\n<p><strong>什么是 CAS?</strong> CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，<code>Unsafe</code> 提供的 CAS 方法（如 <code>compareAndSwapXXX</code>）底层实现即为 CPU 指令 <code>cmpxchg</code> 。</p>\n<h3 id=\"典型应用-4\">典型应用</h3>\n<p>在 JUC 包的并发工具类中大量地使用了 CAS 操作，像在前面介绍<code>synchronized</code>和<code>AQS</code>的文章中也多次提到了 CAS，其作为乐观锁在并发工具类中广泛发挥了作用。在 <code>Unsafe</code> 类中，提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作。以<code>compareAndSwapInt</code>方法为例：</p>\n<pre><code class=\"language-java\">public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x);\n</code></pre>\n<p>参数中<code>o</code>为需要更新的对象，<code>offset</code>是对象<code>o</code>中整形字段的偏移量，如果这个字段的值与<code>expected</code>相同，则将字段的值设为<code>x</code>这个新值，并且此更新是不可被中断的，也就是一个原子操作。下面是一个使用<code>compareAndSwapInt</code>的例子：</p>\n<pre><code class=\"language-java\">private volatile int a;\npublic static void main(String[] args){\n    CasTest casTest=new CasTest();\n    new Thread(()-&gt;{\n        for (int i = 1; i &lt; 5; i++) {\n            casTest.increment(i);\n            System.out.print(casTest.a+\" \");\n        }\n    }).start();\n    new Thread(()-&gt;{\n        for (int i = 5 ; i &lt;10 ; i++) {\n            casTest.increment(i);\n            System.out.print(casTest.a+\" \");\n        }\n    }).start();\n}\n\nprivate void increment(int x){\n    while (true){\n        try {\n            long fieldOffset = unsafe.objectFieldOffset(CasTest.class.getDeclaredField(\"a\"));\n            if (unsafe.compareAndSwapInt(this,fieldOffset,x-1,x))\n                break;\n        } catch (NoSuchFieldException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<p>运行代码会依次输出：</p>\n<pre><code class=\"language-plain\">1 2 3 4 5 6 7 8 9\n</code></pre>\n<p>在上面的例子中，使用两个线程去修改<code>int</code>型属性<code>a</code>的值，并且只有在<code>a</code>的值等于传入的参数<code>x</code>减一时，才会将<code>a</code>的值变为<code>x</code>，也就是实现对<code>a</code>的加一的操作。流程如下所示：</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130526.png\" /></p>\n<p>需要注意的是，在调用<code>compareAndSwapInt</code>方法后，会直接返回<code>true</code>或<code>false</code>的修改结果，因此需要我们在代码中手动添加自旋的逻辑。在<code>AtomicInteger</code>类的设计中，也是采用了将<code>compareAndSwapInt</code>的结果作为循环条件，直至修改成功才退出死循环的方式来实现的原子性的自增操作。</p>\n<h2 id=\"线程调度\">线程调度</h2>\n<h3 id=\"介绍-6\">介绍</h3>\n<p><code>Unsafe</code> 类中提供了<code>park</code>、<code>unpark</code>、<code>monitorEnter</code>、<code>monitorExit</code>、<code>tryMonitorEnter</code>方法进行线程调度。</p>\n<pre><code class=\"language-java\">//取消阻塞线程\npublic native void unpark(Object thread);\n//阻塞线程\npublic native void park(boolean isAbsolute, long time);\n//获得对象锁（可重入锁）\n@Deprecated\npublic native void monitorEnter(Object o);\n//释放对象锁\n@Deprecated\npublic native void monitorExit(Object o);\n//尝试获取对象锁\n@Deprecated\npublic native boolean tryMonitorEnter(Object o);\n</code></pre>\n<p>方法 <code>park</code>、<code>unpark</code> 即可实现线程的挂起与恢复，将一个线程进行挂起是通过 <code>park</code> 方法实现的，调用 <code>park</code> 方法后，线程将一直阻塞直到超时或者中断等条件出现；<code>unpark</code> 可以终止一个挂起的线程，使其恢复正常。</p>\n<p>此外，<code>Unsafe</code> 源码中<code>monitor</code>相关的三个方法已经被标记为<code>deprecated</code>，不建议被使用：</p>\n<pre><code class=\"language-java\">//获得对象锁\n@Deprecated\npublic native void monitorEnter(Object var1);\n//释放对象锁\n@Deprecated\npublic native void monitorExit(Object var1);\n//尝试获得对象锁\n@Deprecated\npublic native boolean tryMonitorEnter(Object var1);\n</code></pre>\n<p><code>monitorEnter</code>方法用于获得对象锁，<code>monitorExit</code>用于释放对象锁，如果对一个没有被<code>monitorEnter</code>加锁的对象执行此方法，会抛出<code>IllegalMonitorStateException</code>异常。<code>tryMonitorEnter</code>方法尝试获取对象锁，如果成功则返回<code>true</code>，反之返回<code>false</code>。</p>\n<h3 id=\"典型应用-5\">典型应用</h3>\n<p>Java 锁和同步器框架的核心类 <code>AbstractQueuedSynchronizer</code> (AQS)，就是通过调用<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的，而 <code>LockSupport</code> 的 <code>park</code>、<code>unpark</code> 方法实际是调用 <code>Unsafe</code> 的 <code>park</code>、<code>unpark</code> 方式实现的。</p>\n<pre><code class=\"language-java\">public static void park(Object blocker) {\n    Thread t = Thread.currentThread();\n    setBlocker(t, blocker);\n    UNSAFE.park(false, 0L);\n    setBlocker(t, null);\n}\npublic static void unpark(Thread thread) {\n    if (thread != null)\n        UNSAFE.unpark(thread);\n}\n</code></pre>\n<p><code>LockSupport</code> 的<code>park</code>方法调用了 <code>Unsafe</code> 的<code>park</code>方法来阻塞当前线程，此方法将线程阻塞后就不会继续往后执行，直到有其他线程调用<code>unpark</code>方法唤醒当前线程。下面的例子对 <code>Unsafe</code> 的这两个方法进行测试：</p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n    Thread mainThread = Thread.currentThread();\n    new Thread(()-&gt;{\n        try {\n            TimeUnit.SECONDS.sleep(5);\n            System.out.println(\"subThread try to unpark mainThread\");\n            unsafe.unpark(mainThread);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }).start();\n\n    System.out.println(\"park main mainThread\");\n    unsafe.park(false,0L);\n    System.out.println(\"unpark mainThread success\");\n}\n</code></pre>\n<p>程序输出为：</p>\n<pre><code class=\"language-plain\">park main mainThread\nsubThread try to unpark mainThread\nunpark mainThread success\n</code></pre>\n<p>程序运行的流程也比较容易看懂，子线程开始运行后先进行睡眠，确保主线程能够调用<code>park</code>方法阻塞自己，子线程在睡眠 5 秒后，调用<code>unpark</code>方法唤醒主线程，使主线程能继续向下执行。整个流程如下图所示：</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130484.png\" /></p>\n<h2 id=\"class-操作\">Class 操作</h2>\n<h3 id=\"介绍-7\">介绍</h3>\n<p><code>Unsafe</code> 对<code>Class</code>的相关操作主要包括类加载和静态变量的操作方法。</p>\n<p><strong>静态属性读取相关的方法</strong></p>\n<pre><code class=\"language-java\">//获取静态属性的偏移量\npublic native long staticFieldOffset(Field f);\n//获取静态属性的对象指针\npublic native Object staticFieldBase(Field f);\n//判断类是否需要初始化（用于获取类的静态属性前进行检测）\npublic native boolean shouldBeInitialized(Class&lt;?&gt; c);\n</code></pre>\n<p>创建一个包含静态属性的类，进行测试：</p>\n<pre><code class=\"language-java\">@Data\npublic class User {\n    public static String name=\"Hydra\";\n    int age;\n}\nprivate void staticTest() throws Exception {\n    User user=new User();\n    // 也可以用下面的语句触发类初始化\n    // 1.\n    // unsafe.ensureClassInitialized(User.class);\n    // 2.\n    // System.out.println(User.name);\n    System.out.println(unsafe.shouldBeInitialized(User.class));\n    Field sexField = User.class.getDeclaredField(\"name\");\n    long fieldOffset = unsafe.staticFieldOffset(sexField);\n    Object fieldBase = unsafe.staticFieldBase(sexField);\n    Object object = unsafe.getObject(fieldBase, fieldOffset);\n    System.out.println(object);\n}\n</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"language-plain\">false\nHydra\n</code></pre>\n<p>在 <code>Unsafe</code> 的对象操作中，我们学习了通过<code>objectFieldOffset</code>方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用<code>staticFieldOffset</code>方法。在上面的代码中，只有在获取<code>Field</code>对象的过程中依赖到了<code>Class</code>，而获取静态变量的属性时不再依赖于<code>Class</code>。</p>\n<p>在上面的代码中首先创建一个<code>User</code>对象，这是因为如果一个类没有被初始化，那么它的静态属性也不会被初始化，最后获取的字段属性将是<code>null</code>。所以在获取静态属性前，需要调用<code>shouldBeInitialized</code>方法，判断在获取前是否需要初始化这个类。如果删除创建 User 对象的语句，运行结果会变为：</p>\n<pre><code class=\"language-plain\">true\nnull\n</code></pre>\n<p><strong>使用<code>defineClass</code>方法允许程序在运行时动态地创建一个类</strong></p>\n<pre><code class=\"language-java\">public native Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ClassLoader loader,ProtectionDomain protectionDomain);\n</code></pre>\n<p>在实际使用过程中，可以只传入字节数组、起始字节的下标以及读取的字节长度，默认情况下，类加载器（<code>ClassLoader</code>）和保护域（<code>ProtectionDomain</code>）来源于调用此方法的实例。下面的例子中实现了反编译生成后的 class 文件的功能：</p>\n<pre><code class=\"language-java\">private static void defineTest() {\n    String fileName=\"F:\\\\workspace\\\\unsafe-test\\\\target\\\\classes\\\\com\\\\cn\\\\model\\\\User.class\";\n    File file = new File(fileName);\n    try(FileInputStream fis = new FileInputStream(file)) {\n        byte[] content=new byte[(int)file.length()];\n        fis.read(content);\n        Class clazz = unsafe.defineClass(null, content, 0, content.length, null, null);\n        Object o = clazz.newInstance();\n        Object age = clazz.getMethod(\"getAge\").invoke(o, null);\n        System.out.println(age);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n</code></pre>\n<p>在上面的代码中，首先读取了一个<code>class</code>文件并通过文件流将它转化为字节数组，之后使用<code>defineClass</code>方法动态的创建了一个类，并在后续完成了它的实例化工作，流程如下图所示，并且通过这种方式创建的类，会跳过 JVM 的所有安全检查。</p>\n<p><img alt=\"\" src=\"https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717145000710.png\" /></p>\n<p>除了<code>defineClass</code>方法外，Unsafe 还提供了一个<code>defineAnonymousClass</code>方法：</p>\n<pre><code class=\"language-java\">public native Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);\n</code></pre>\n<p>使用该方法可以用来动态的创建一个匿名类，在<code>Lambda</code>表达式中就是使用 ASM 动态生成字节码，然后利用该方法定义实现相应的函数式接口的匿名类。在 JDK 15 发布的新特性中，在隐藏类（<code>Hidden classes</code>）一条中，指出将在未来的版本中弃用 <code>Unsafe</code> 的<code>defineAnonymousClass</code>方法。</p>\n<h3 id=\"典型应用-6\">典型应用</h3>\n<p>Lambda 表达式实现需要依赖 <code>Unsafe</code> 的 <code>defineAnonymousClass</code> 方法定义实现相应的函数式接口的匿名类。</p>\n<h2 id=\"系统信息\">系统信息</h2>\n<h3 id=\"介绍-8\">介绍</h3>\n<p>这部分包含两个获取系统相关信息的方法。</p>\n<pre><code class=\"language-java\">//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。\npublic native int addressSize();\n//内存页的大小，此值为2的幂次方。\npublic native int pageSize();\n</code></pre>\n<h3 id=\"典型应用-7\">典型应用</h3>\n<p>这两个方法的应用场景比较少，在<code>java.nio.Bits</code>类中，在使用<code>pageCount</code>计算所需的内存页的数量时，调用了<code>pageSize</code>方法获取内存页的大小。另外，在使用<code>copySwapMemory</code>方法拷贝内存时，调用了<code>addressSize</code>方法，检测 32 位系统的情况。</p>\n<h2 id=\"unsafe底层\">Unsafe底层</h2>\n<p>再看看Unsafe的compareAndSwap 方法来实现CAS操作，它是一个本地方法，实现位于unsafe.cpp中。</p>\n<pre><code class=\"language-java\">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))\n  UnsafeWrapper(\"Unsafe_CompareAndSwapInt\");\n  oop p = JNIHandles::resolve(obj);\n  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);\n  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;\nUNSAFE_END\n</code></pre>\n<p>可以看到它通过 Atomic::cmpxchg 来实现比较和替换操作。其中参数x是即将更新的值，参数e是原内存的值。</p>\n<p>如果是Linux的x86，Atomic::cmpxchg方法的实现如下：</p>\n<pre><code class=\"language-java\">inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {\n  int mp = os::is_MP();\n  __asm__ volatile (LOCK_IF_MP(%4) \"cmpxchgl %1,(%3)\"\n                    : \"=a\" (exchange_value)\n                    : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest), \"r\" (mp)\n                    : \"cc\", \"memory\");\n  return exchange_value;\n}\n</code></pre>\n<p>而windows的x86的实现如下：</p>\n<pre><code class=\"language-java\">inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {\n    int mp = os::isMP(); //判断是否是多处理器\n    _asm {\n        mov edx, dest\n        mov ecx, exchange_value\n        mov eax, compare_value\n        LOCK_IF_MP(mp)\n        cmpxchg dword ptr [edx], ecx\n    }\n}\n\n// Adding a lock prefix to an instruction on MP machine\n// VC++ doesn't like the lock prefix to be on a single line\n// so we can't insert a label after the lock prefix.\n// By emitting a lock prefix, we can define a label after it.\n#define LOCK_IF_MP(mp) __asm cmp mp, 0  \\\n                       __asm je L0      \\\n                       __asm _emit 0xF0 \\\n                       __asm L0:\n</code></pre>\n<p>如果是多处理器，为cmpxchg指令添加lock前缀。反之，就省略lock前缀(单处理器会不需要lock前缀提供的内存屏障效果)。这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能)。</p>\n<blockquote>\n<p>cmpxchg(void* ptr, int old, int new)，如果ptr和old的值一样，则把new写到ptr内存，否则返回ptr的值，整个操作是原子的。在Intel平台下，会用lock cmpxchg来实现，使用lock触发缓存锁，这样另一个线程想访问ptr的内存，就会被block住。</p>\n</blockquote>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 09:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sevencoding\">程序员Seven</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}