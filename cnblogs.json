{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "250个LLM 评估基准大盘点！从推理到多模态，一文看懂LLM考试大纲",
      "link": "https://www.cnblogs.com/aifrontiers/p/19423142",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aifrontiers/p/19423142\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 20:24\">\n    <span>250个LLM 评估基准大盘点！从推理到多模态，一文看懂LLM考试大纲</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>原文：<a href=\"https://mp.weixin.qq.com/s/ihKJVqs3TWXVQcqnsjZ9Og\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/ihKJVqs3TWXVQcqnsjZ9Og</a></p>\n<p>选不对 LLM，业务落地全是坑！面对五花八门的大模型，你是否还在纠结：推理题太简单测不出差距？编程评估没标准？上线才发现安全不达标？核心痛点在于：缺乏系统化的评估标准。今天，给大家分享一个宝藏资源：250个 LLM 评估基准与数据集，覆盖推理、编程、对话、Agent 工具调用等多个维度，支持标签化分类筛选，帮你快速摸清模型底细，拒绝盲目选型。</p>\n<p>这个数据集最强大的地方在于，它把虚无缥缈的模型能力拆解成了<strong>6大垂直领域</strong>。无论你的业务场景是什么，都能找到对应的考卷，关注这里<a href=\"https://mp.weixin.qq.com/s/ihKJVqs3TWXVQcqnsjZ9Og\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/ihKJVqs3TWXVQcqnsjZ9Og</a>，后台回复<strong>llm_eval</strong>领取下面资料。</p>\n<p><img alt=\"1280X1280\" class=\"lazyload\" /></p>\n<h1 id=\"1--llm-评测-6-大核心维度\">1.  LLM 评测 6 大核心维度</h1>\n<ol>\n<li><strong>知识、语言与推理类</strong>：LLM的基础功底测试，核心考察模型对信息的理解、逻辑推断能力，以及事实知识的检索准确性。比如让模型理解复杂文本的深层含义，或根据已知信息推导结论，都属于这类测试的范畴。</li>\n<li><strong>聊天机器人与对话类</strong>：专为对话场景设计，重点看模型生成的回复是否连贯、符合语境，能不能精准应对用户的问题，同时保证内容准确且有吸引力</li>\n<li><strong>编程类</strong>：码农们最关心的板块，主要测试模型在代码生成、调试、优化等任务上的表现，不管是写简单的脚本，还是复杂的项目模块，都能通过这类基准测试看出模型的编程实力。</li>\n<li><strong>安全性类</strong>：这是LLM落地的底线测试。考察模型如何处理对抗性输入（比如恶意诱导的问题），能否有效减轻自身的偏见，以及避免生成有毒、有害或违规的内容。对企业来说，安全性不达标，再强的能力也不能上线。</li>\n<li><strong>多模态类</strong>：针对全能型LLM设计，测试模型处理图像、视频、音频、结构化数据等多种信息类型的能力。比如让模型根据图片内容生成描述，或结合音频和文本做总结，都可以通过这类基准来评估。</li>\n<li><strong>代理与工具调用类</strong>：进阶版能力测试，评估模型在复杂工作流中，能否主动调用外部工具，比如搜索引擎、计算器、API，以及作为AI Agent独立完成一系列任务的表现。这直接决定了模型能否胜任自动化办公、智能助手等复杂场景。</li>\n</ol>\n<h1 id=\"2-两个关键维度帮你快速筛\">2. 两个关键维度，帮你快速筛</h1>\n<p>基准测试有250个数据集，怎么快速选出适合自己的？不用慌，表格中提供了两个核心参考维度，帮你少走弯路：</p>\n<p><strong>被引次数</strong>：简单说，就是这个基准测试被其他研究者引用的次数。引用次数越高，说明这个基准在学术界和工业界的认可度越高，越适合作为标准参考。比如一款被引上千次的编程类基准，肯定比一款鲜有人知的测试更有说服力。</p>\n<p><strong>新旧标识</strong>：为了方便大家追踪最新动态，2024年及以后发表的基准测试都被标注为New。如果你想了解行业最新的评估方法，或者测试最新发布的模型，直接筛选New标签就能精准定位。</p>\n<p>现在LLM技术更新太快了，想精准评估模型性能、选对适配业务的工具，需要一套完整的数据集。这个包含250个基准测试的数据集，相当于给大家提供了一套LLM能力体检手册，不管是选模型、做研究，还是优化现有系统，都能帮你找到精准的评估依据。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 20:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aifrontiers\">AI-Frontiers</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Flink源码阅读：Checkpoint机制（下）",
      "link": "https://www.cnblogs.com/Jackeyzhe/p/19423123",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Jackeyzhe/p/19423123\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 20:13\">\n    <span>Flink源码阅读：Checkpoint机制（下）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Flink源码阅读：Checkpoint机制（下）\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1828322/202512/1828322-20251230201244606-898036727.png\" />\n        书接上回，前文我们梳理的 Checkpoint 机制的源码，但是对于如何写入状态数据并没有深入了解。今天就一起来梳理一下这部分代码。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>书接上回，前文我们梳理的 Checkpoint 机制的源码，但是对于如何写入状态数据并没有深入了解。今天就一起来梳理一下这部分代码。</p>\n<h3 id=\"写在前面\">写在前面</h3>\n<p>前面我们了解到在 <code>StreamOperatorStateHandler.snapshotState</code> 方法中会创建四个 Future，用来支持不同类型的状态写入。</p>\n<pre><code class=\"language-java\">snapshotInProgress.setKeyedStateRawFuture(snapshotContext.getKeyedStateStreamFuture());\nsnapshotInProgress.setOperatorStateRawFuture(\n        snapshotContext.getOperatorStateStreamFuture());\n\nif (null != operatorStateBackend) {\n    snapshotInProgress.setOperatorStateManagedFuture(\n            operatorStateBackend.snapshot(\n                    checkpointId, timestamp, factory, checkpointOptions));\n}\n\nif (useAsyncState &amp;&amp; null != asyncKeyedStateBackend) {\n    if (isCanonicalSavepoint(checkpointOptions.getCheckpointType())) {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    } else {\n        snapshotInProgress.setKeyedStateManagedFuture(\n                asyncKeyedStateBackend.snapshot(\n                        checkpointId, timestamp, factory, checkpointOptions));\n    }\n}\n</code></pre>\n<p>我们主要关心 ManagedState，ManagedState 都是调用 <code>Snapshotable.snapshot</code> 方法来写入数据的，下面具体看 KeyedState 和 OperatorState 的具体实现。</p>\n<h3 id=\"keyedstate\">KeyedState</h3>\n<p>KeyedState 我们以 HeapKeyedStateBackend 为例，这里先是创建了一个 <code>SnapshotStrategyRunner</code> 实例，SnapshotStrategyRunner 是一个快照策略的一个执行类，创建完成后就会调用 snapshot 方法。在这个 snapshot 方法中主要做了做了下面几件事：</p>\n<ol>\n<li>\n<p>同步拷贝状态数据的引用。</p>\n</li>\n<li>\n<p>创建 Checkpoint 输出流 <code>CheckpointStateOutputStream</code></p>\n</li>\n<li>\n<p>完成 Checkpoint 持久化</p>\n</li>\n<li>\n<p>返回元信息结果</p>\n</li>\n</ol>\n<h4 id=\"状态数据引用拷贝\">状态数据引用拷贝</h4>\n<p>在 HeapSnapshotStrategy 的 syncPrepareResources 方法中调用了 <code>HeapSnapshotResources.create</code> 方法。这里有一个比较重要的参数是 registeredKVStates，它代表我们在业务代码中注册的状态数据表。</p>\n<pre><code class=\"language-java\">ValueStateDescriptor&lt;Tuple2&lt;Long, Long&gt;&gt; descriptor =\n        new ValueStateDescriptor&lt;&gt;(\n                \"average\",\n                TypeInformation.of(new TypeHint&lt;Tuple2&lt;Long, Long&gt;&gt;() {}));\n</code></pre>\n<p>例如我们这样注册状态数据表，那么 registeredKVStates 的 key 就是 average，value 就是状态表，它通常是一个 CopyOnWriteStateTable。具体的状态数据引用拷贝的逻辑在 <code>processSnapshotMetaInfoForAllStates</code> 方法中。</p>\n<pre><code class=\"language-java\">private static void processSnapshotMetaInfoForAllStates(\n        List&lt;StateMetaInfoSnapshot&gt; metaInfoSnapshots,\n        Map&lt;StateUID, StateSnapshot&gt; cowStateStableSnapshots,\n        Map&lt;StateUID, Integer&gt; stateNamesToId,\n        Map&lt;String, ? extends StateSnapshotRestore&gt; registeredStates,\n        StateMetaInfoSnapshot.BackendStateType stateType) {\n\n    for (Map.Entry&lt;String, ? extends StateSnapshotRestore&gt; kvState :\n            registeredStates.entrySet()) {\n        final StateUID stateUid = StateUID.of(kvState.getKey(), stateType);\n        stateNamesToId.put(stateUid, stateNamesToId.size());\n        StateSnapshotRestore state = kvState.getValue();\n        if (null != state) {\n            final StateSnapshot stateSnapshot = state.stateSnapshot();\n            metaInfoSnapshots.add(stateSnapshot.getMetaInfoSnapshot());\n            cowStateStableSnapshots.put(stateUid, stateSnapshot);\n        }\n    }\n}\n</code></pre>\n<p>针对每个 State，这里都创建一个 CopyOnWriteStateTableSnapshot，然后存在 cowStateStableSnapshots 里。这里 CopyOnWriteStateTableSnapshot 就是拷贝数据的引用，因此可以同步执行。</p>\n<h4 id=\"创建-checkpointstateoutputstream\">创建 CheckpointStateOutputStream</h4>\n<p>创建 CheckpointStateOutputStream 的方法是 <code>CheckpointStreamWithResultProvider.createSimpleStream</code>，生产环境通常使用的是 FsCheckpointStateOutputStream。FsCheckpointStateOutputStream 中的参数如下：</p>\n<pre><code class=\"language-java\">// 状态数据写入缓冲数组，数据先写到内存中，然后 flush 到磁盘\nprivate final byte[] writeBuffer;\n\n// 缓冲数组当前写入位置\nprivate int pos;\n\n// 文件输出流\nprivate volatile FSDataOutputStream outStream;\n\n// 内存中状态大小阈值，超过阈值会 flush 到磁盘，默认20KB，最大1MB\n// 目的是为了减少小文件数量\nprivate final int localStateThreshold;\n\n// checkpoint 基础路径\nprivate final Path basePath;\n\n// Flink 自己封装的文件系统\nprivate final FileSystem fs;\n\n// 状态数据完整路径\nprivate volatile Path statePath;\n\n// 相对路径\nprivate String relativeStatePath;\n\n// 是否已关闭\nprivate volatile boolean closed;\n\n// 是否允许使用相对路径\nprivate final boolean allowRelativePaths;\n</code></pre>\n<h4 id=\"checkpoint-持久化\">Checkpoint 持久化</h4>\n<p>创建完 CheckpointStateOutputStream 之后，会调用 <code>serializationProxy.write(outView)</code> 写入状态的元数据。元数据包括状态的名称、类型、序列化器等一些配置。</p>\n<p>元数据写完之后，就开始分组写入状态数据。在写入时，先写 keyGroupId，然后再写当前分组的状态数据</p>\n<pre><code class=\"language-java\">for (int keyGroupPos = 0;\n        keyGroupPos &lt; keyGroupRange.getNumberOfKeyGroups();\n        ++keyGroupPos) {\n    int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos);\n    keyGroupRangeOffsets[keyGroupPos] = localStream.getPos();\n    // 写 keyGroupId\n    outView.writeInt(keyGroupId);\n\n    for (Map.Entry&lt;StateUID, StateSnapshot&gt; stateSnapshot :\n            cowStateStableSnapshots.entrySet()) {\n        StateSnapshot.StateKeyGroupWriter partitionedSnapshot =\n                stateSnapshot.getValue().getKeyGroupWriter();\n        try (OutputStream kgCompressionOut =\n                keyGroupCompressionDecorator.decorateWithCompression(localStream)) {\n            DataOutputViewStreamWrapper kgCompressionView =\n                    new DataOutputViewStreamWrapper(kgCompressionOut);\n            kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));\n            // 写状态数据\n            partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);\n        } // this will just close the outer compression stream\n    }\n}\n</code></pre>\n<p>状态数据写入的调用链路如下</p>\n<p><img alt=\"writeState\" class=\"lazyload\" /></p>\n<pre><code class=\"language-java\">public void writeState(\n        TypeSerializer&lt;K&gt; keySerializer,\n        TypeSerializer&lt;N&gt; namespaceSerializer,\n        TypeSerializer&lt;S&gt; stateSerializer,\n        @Nonnull DataOutputView dov,\n        @Nullable StateSnapshotTransformer&lt;S&gt; stateSnapshotTransformer)\n        throws IOException {\n    SnapshotIterator&lt;K, N, S&gt; snapshotIterator =\n            getIterator(\n                    keySerializer,\n                    namespaceSerializer,\n                    stateSerializer,\n                    stateSnapshotTransformer);\n\n    int size = snapshotIterator.size();\n    dov.writeInt(size);\n    while (snapshotIterator.hasNext()) {\n        StateEntry&lt;K, N, S&gt; stateEntry = snapshotIterator.next();\n        namespaceSerializer.serialize(stateEntry.getNamespace(), dov);\n        keySerializer.serialize(stateEntry.getKey(), dov);\n        stateSerializer.serialize(stateEntry.getState(), dov);\n    }\n}\n</code></pre>\n<h4 id=\"返回结果\">返回结果</h4>\n<p>最后一步就是封装并返回元信息，这里收集的信息包括了每个 keyGroup 的状态数据在状态文件中的存储位置，状态数据存储的文件路径、文件大小等。</p>\n<h3 id=\"operatorstate\">OperatorState</h3>\n<p>OperatorState 的处理逻辑比 KeyedState 更简单一些，流程上都是先做状态数据的引用快照，然后写入状态数据和返回结果。在写入数据时，没有了分组写入的逻辑。直接处理 operatorState 和 broadcastState。这里就只贴一下调用流程，不做过多赘述了。</p>\n<p><img alt=\"operatorState\" class=\"lazyload\" /></p>\n<h3 id=\"总结\">总结</h3>\n<p>本文我们重点梳理了 KeyedState 数据写入的代码。其主要步骤包括：同步拷贝状态数据的引用，创建 Checkpoint 输出流 <code>CheckpointStateOutputStream</code> 并完成 Checkpoint 持久化，最后返回元信息结果。OperatorState 的处理过程和 KeyedState 的过程类似，只是少了分组的逻辑。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 20:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Jackeyzhe\">Jackeyzhe</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "规划中主要使用的地图类型",
      "link": "https://www.cnblogs.com/zylyehuo/p/19419173",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zylyehuo/p/19419173\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 20:07\">\n    <span>规划中主要使用的地图类型</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>博客地址：<a href=\"https://www.cnblogs.com/zylyehuo/\" target=\"_blank\">https://www.cnblogs.com/zylyehuo/</a></p>\n</blockquote>\n<h1 id=\"occupancy-grid-map\">Occupancy Grid Map</h1>\n<blockquote>\n<p>【占据栅格地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1GzwderECF/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">移动机器人运动规划-第一章(运动规划介绍与地图构建)-第三节(地图构建方法-Occupancy Grid Map)</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV14C4y1r7Jd/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">自动驾驶中的Occupancy Grid占用栅格算法</a></p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230091555060-1199064499.png\" /></p>\n<ul>\n<li>基于贝叶斯公式</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092048607-315558262.png\" /></p>\n<ul>\n<li>基于马尔科夫假设（当前的概率与之前的概率是独立的）</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092203011-2028367547.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092225738-123828824.png\" /></p>\n<ul>\n<li>发现存在相同项</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092347064-1157737378.png\" /></p>\n<ul>\n<li>将两个概率进行相除，约去相同项</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092755566-498805078.png\" /></p>\n<ul>\n<li>利用 log 函数，分离出先验状态</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093031164-242106556.png\" /></p>\n<ul>\n<li>还剩下“逆传感器模型”部分【不直观】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093249678-366631429.png\" /></p>\n<ul>\n<li>再利用贝叶斯公式，将“逆传感器模型”转换为“传感器模型”【基于当前栅格地图的状态，得到的这一次观测值应该是0还是1的概率】，发现又出现相同项</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093716424-1872441123.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093825914-1423272760.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094001016-1041041406.png\" /></p>\n<ul>\n<li>假设“传感器模型”是个定值【基于观测的更新方式】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094259734-1484359303.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094533636-1069601382.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094914148-745996427.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095200901-845289928.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095233736-1331029782.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095347220-253112120.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095358663-165236316.png\" /></p>\n<ul>\n<li>利用滚动的 Occupancy Grid Map，解决“大地图”问题</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095538388-1548681780.png\" /></p>\n<h1 id=\"tsdf\">TSDF</h1>\n<blockquote>\n<p>(Truncated Signed Distance Field)【截断符号距离场】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/personalrobotics/OpenChisel\" rel=\"noopener nofollow\" target=\"_blank\">An open-source version of the Chisel chunked TSDF library.</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1Xi4y1471W/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">运动规划之 TSDF map</a></p>\n</blockquote>\n<ul>\n<li>障碍物外面的值为正值，障碍物外面的值为负值</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230151947608-384612791.png\" /></p>\n<h1 id=\"esdf\">ESDF</h1>\n<blockquote>\n<p>(Euclidean Signed Distance Field)【欧几里得符号距离场】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1Hnwde9EFc?spm_id_from=333.788.player.switch&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651&amp;trackid=web_related_0.router-related-2206419-gx8f2.1767056746104.238\" rel=\"noopener nofollow\" target=\"_blank\">移动机器人运动规划-第一章(运动规划介绍与地图构建)-第三节(地图构建方法-ESDF)</a></p>\n</blockquote>\n<ul>\n<li>“一层”的是 ESDF，上面的小栅格是 Occupancy Grid Map</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095632105-2084501764.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230100013176-744146623.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230100121591-1498147498.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230100151782-1360282382.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230101513785-573529793.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135055798-1520530407.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135316095-806542410.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135735490-663923292.png\" /></p>\n<ul>\n<li>仅针对一维的伪代码</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135828974-1891255415.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230140300707-708995518.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230140520538-65060715.png\" /></p>\n<ul>\n<li>对于二维的情况，就是固定 x，根据不同的 y 求解到达障碍物的最小距离</li>\n<li>以第一列为例</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230140734954-316583447.png\" /></p>\n<ul>\n<li>以第二列为例（没有障碍物的情况，则每个位置的值都为 ∞）</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141116066-773952293.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141241727-845739716.png\" /></p>\n<ul>\n<li>接着固定 y，根据不同的 x 求解到达障碍物的最小距离</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141744667-376666185.png\" /></p>\n<ul>\n<li>以下面三行为例</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141817043-1907659702.png\" /></p>\n<ul>\n<li>对于第一个格子，x=1，选取【这个格子到别的格子的距离 + 别的格子里面的“值”】最小的结果</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230142536264-839975597.png\" /></p>\n<ul>\n<li>对于第二个格子，x=2</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230142732894-2092955561.png\" /></p>\n<ul>\n<li>利用两次“一维”的求解，获得二维的结果【三维类似】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230142837572-2122723745.png\" /></p>\n<ul>\n<li>障碍物里面存放的值的意义：到最近的 free 的栅格的距离，同时这个值放的是负值</li>\n<li>先将障碍物和 free 栅格进行翻转，然后进行计算</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143237644-1636509800.png\" /></p>\n<ul>\n<li>将计算后的值添加上负号</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143311745-18788185.png\" /></p>\n<ul>\n<li>再和原来的场进行叠加</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143344921-1946627573.png\" /></p>\n<ul>\n<li>先沿着 z 轴算，再沿着 y 轴算，最后沿着 x 轴算</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143458985-408992367.png\" /></p>\n<ul>\n<li>进行翻转操作【反向 ESDF】，计算障碍物内部的值【先沿着 z 轴算，再沿着 y 轴算，最后沿着 x 轴算】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143811950-1709618967.png\" /></p>\n<ul>\n<li>最后进行叠加</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143910379-1892087086.png\" /></p>\n<ul>\n<li>对于当前位置不在栅格中心的情况，利用插值进行解决</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230144224352-5167244.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230144333713-2132197098.png\" /></p>\n<ul>\n<li>ESDF 地图梯度的计算</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230144605924-1620303920.png\" /></p>\n<h1 id=\"gaussian-map\">Gaussian Map</h1>\n<h2 id=\"3dgs\">3DGS</h2>\n<blockquote>\n<p>(3D Gaussian Splatting)【3D 高斯溅射地图 / 前沿视觉地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/7833648056\" rel=\"noopener nofollow\" target=\"_blank\">3D Gaussian Splatting算法及其实现细节</a></p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://arxiv.org/pdf/2308.04079\" rel=\"noopener nofollow\" target=\"_blank\">3D Gaussian Splatting for Real-Time Radiance Field Rendering</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/graphdeco-inria/gaussian-splatting\" rel=\"noopener nofollow\" target=\"_blank\">代码</a></p>\n</blockquote>\n<h2 id=\"gp-map\">GP Map</h2>\n<blockquote>\n<p>(Gaussian Process Map)【高斯过程地图 / 概率连续地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/2751630763\" rel=\"noopener nofollow\" target=\"_blank\">什么是高斯过程（Gaussian Processes, GP）</a></p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://fabioramos.github.io/Publications_files/Simon_ISER2014.pdf\" rel=\"noopener nofollow\" target=\"_blank\">Gaussian process occupancy maps for dynamic environments</a></p>\n</blockquote>\n<h2 id=\"gmm\">GMM</h2>\n<blockquote>\n<p>(Gaussian Mixture Models)【高斯混合模型地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/151671154\" rel=\"noopener nofollow\" target=\"_blank\">如何通俗的理解高斯混合模型（Gaussian Mixture Models））</a></p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://zhuanlan.zhihu.com/p/151671154\" rel=\"noopener nofollow\" target=\"_blank\">Gaussian Mixture Models</a></p>\n</blockquote>\n<h1 id=\"nerf\">NeRF</h1>\n<blockquote>\n<p>(Neural Radiance Fields)【神经辐射场】</p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://arxiv.org/pdf/2003.08934\" rel=\"noopener nofollow\" target=\"_blank\">Representing Scenes as Neural Radiance Fields for View Synthesis</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/bmild/nerf\" rel=\"noopener nofollow\" target=\"_blank\">代码</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.matthewtancik.com/nerf\" rel=\"noopener nofollow\" target=\"_blank\">官网</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/jiaoyangwm/article/details/133804918\" rel=\"noopener nofollow\" target=\"_blank\">NeRF 首篇经典论文介绍（ECCV2020）</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1CC411V7oq/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">【较真系列】讲人话-NeRF全解（原理+代码+公式）</a></p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230152646680-808967645.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153232330-8093872.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153304058-1966233738.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153458012-810246374.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153627018-1090646223.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153701724-2140345591.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153801636-51891141.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153921564-421511957.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154119566-421233492.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154404671-1853328831.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154452220-1182229856.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154836620-1158102823.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155102446-1293304585.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155330237-169551366.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155631408-2064100778.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155728157-250263865.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155820644-869689816.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160626120-96920975.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160754127-1769142361.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160851194-233434887.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160937600-1841363.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161047152-122034867.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161318891-1616916806.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161437134-1545984944.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161723359-1462419215.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161925557-1973428927.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230174118921-38385255.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230174243818-575765853.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175016337-1136716337.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175052111-1485817129.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175157993-2141132230.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175345585-750664154.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175425714-1466271787.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175528313-2072746571.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175732929-1433112194.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175830148-1190162908.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 20:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zylyehuo\">zylyehuo</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "代码考古学：如何让你的代码不再是“未解之谜”？",
      "link": "https://www.cnblogs.com/huizhudev/p/19422839",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/huizhudev/p/19422839\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 18:29\">\n    <span>代码考古学：如何让你的代码不再是“未解之谜”？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"代码考古学：如何让你的代码不再是“未解之谜”？\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3695776/202512/3695776-20251230182757218-218563489.png\" />\n        好的代码不只需要逻辑，更需要解释。本文挑战“代码即文档”的迷思，介绍如何利用AI指令充当“代码考古学家”，将晦涩的逻辑转化为清晰的“罗塞塔石碑”式文档，消除团队知识债务，提升项目的可维护性与专业度。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>你有没有经历过这种<strong>“灵魂出窍”</strong>的时刻：</p>\n<p>盯着一段三个月前自己亲手写的代码，感觉像是在看外星文明留下的天书。逻辑极其精妙，变量名简写得极其潇洒，但你就是死活想不起来——<strong>这玩意儿到底是用来干嘛的？</strong></p>\n<p>如果说写代码是构建一座宏伟的宫殿，那么写注释就是给这座宫殿绘制“导游图”。遗憾的是，在赶进度的修罗场里，我们往往只顾着添砖加瓦，却忘了留下任何文字线索。</p>\n<p>最终，项目变成了一座<strong>“数字迷宫”</strong>。新来的同事在里面晕头转向，接手的维护者在里面步步惊心，就连始作俑者你自己，过段时间回来也是一脸茫然。</p>\n<p><img alt=\"代码考古学：如何让你的代码不再是“未解之谜”？\" class=\"lazyload\" /></p>\n<h2 id=\"-打破代码即文档的迷思\">🏺 打破“代码即文档”的迷思</h2>\n<p>在程序员圈子里，流传着一个迷人的谎言：<em>“好的代码是自解释的（Self-documenting），不需要注释。”</em></p>\n<p>这句话只对了一半。<br />\n对于 <code>getUserName()</code> 这种显而易见的代码，注释确实是噪音。<br />\n但对于那些<strong>反直觉的业务逻辑、为了性能的Hack写法、以及复杂的算法实现</strong>，代码本身只能告诉你“它做了什么”，却永远无法告诉你“<strong>为什么要这么做</strong>”。</p>\n<p>缺失的注释，就是团队的<strong>“知识债务”</strong>。债务是有利息的，而利息的支付方式，就是无休止的 Bug 排查和高昂的沟通成本。</p>\n<h2 id=\"-ai你的罗塞塔石碑雕刻师\">🧩 AI：你的“罗塞塔石碑”雕刻师</h2>\n<p>如果是以前，我会劝你：“兄弟，咬咬牙，把文档补上吧。”<br />\n但现在，作为一名追求极致效率的工程师，我会说：<strong>“这种要把逻辑翻译成人类语言的活儿，为什么不交给最擅长处理自然语言的 AI 呢？”</strong></p>\n<p>我为你准备了一套<strong>「代码注释生成 AI 指令」</strong>。<br />\n它不是简单的“翻译机”，而是一位<strong>“代码考古学家”</strong>。它能深入分析你的代码逻辑，推断设计意图，并用最规范的格式，为你刻下清晰的“罗塞塔石碑”。</p>\n<h3 id=\"️-复制这个指令重塑代码可读性\">🛠️ 复制这个指令，重塑代码可读性</h3>\n<p>这套指令的精髓在于<strong>“分层解析”</strong>。它会根据你指定的规范（JSDoc/Javadoc等），自动区分<strong>接口契约</strong>（参数/返回值）和<strong>实现细节</strong>（行内逻辑），确保注释既不冗余，也不缺失。</p>\n<pre><code class=\"language-markdown\"># 角色定义\n你是一位资深代码文档工程师，拥有10年以上软件开发经验，精通多种编程语言的文档规范（如JSDoc、Javadoc、Python Docstring、XML Doc等）。你擅长分析代码逻辑、理解设计意图，并能用简洁清晰的语言编写高质量的代码注释。\n\n# 任务描述\n请为以下代码生成专业、规范的注释，确保注释能够帮助开发者快速理解代码功能、参数说明、返回值及使用场景。\n\n**输入信息**:\n- **编程语言**: [请指定：JavaScript/Python/Java/C#/Go/TypeScript/其他]\n- **注释规范**: [请指定：JSDoc/Javadoc/Python Docstring/XML Doc/自定义/自动识别]\n- **注释级别**: [请选择：函数级/类级/模块级/行内注释/全部]\n- **详细程度**: [请选择：简洁/标准/详细]\n\n**待注释代码**:\n```\n[在此粘贴你的代码]\n```\n\n# 输出要求\n\n## 1. 内容结构\n- **文件/模块头注释**: 描述文件用途、作者、创建日期\n- **类/接口注释**: 描述类的职责、设计目的、使用示例\n- **函数/方法注释**: 功能描述、参数说明、返回值、异常处理、使用示例\n- **关键逻辑注释**: 复杂算法或业务逻辑的行内说明\n\n## 2. 质量标准\n- **准确性**: 注释必须准确反映代码的实际功能，不能有歧义\n- **完整性**: 覆盖所有公共API、复杂逻辑和关键决策点\n- **简洁性**: 用最少的文字表达最完整的信息\n- **规范性**: 严格遵循指定的注释规范格式\n\n## 3. 格式要求\n- 遵循指定编程语言的注释语法\n- 保持一致的缩进和对齐\n- 使用规范的标签（如@param、@returns、@throws等）\n- 中英文之间添加空格，提升可读性\n\n## 4. 风格约束\n- **语言风格**: 技术专业但通俗易懂\n- **表达方式**: 第三人称客观叙述\n- **专业程度**: 面向开发者，假设读者具备基础编程知识\n\n# 质量检查清单\n\n在完成输出后，请自我检查:\n- [ ] 注释格式符合指定的文档规范\n- [ ] 函数的参数和返回值都已说明\n- [ ] 复杂逻辑处有行内注释解释\n- [ ] 没有拼写错误或语法问题\n- [ ] 注释与代码实际功能一致\n\n# 注意事项\n- 不要修改原有代码逻辑，只添加注释\n- 避免过度注释（如解释显而易见的代码）\n- 对于废弃的方法要标注 @deprecated 并说明替代方案\n- 敏感信息（如密码、密钥）不要在注释中出现\n\n# 输出格式\n请直接输出带有完整注释的代码，使用对应语言的代码块格式。如果有多个文件，请分别标注文件名。\n</code></pre>\n<h2 id=\"️-效果实测从天书到教科书\">⚡️ 效果实测：从“天书”到“教科书”</h2>\n<p>让我们来看一个真实的<strong>反直觉</strong>场景。<br />\n这是一段用于处理防抖（Debounce）的 JavaScript 代码。如果不看注释，你需要在大脑里模拟半天 Event Loop 才能看懂它是怎么工作的。</p>\n<p><strong>使用前（裸奔版）：</strong></p>\n<pre><code class=\"language-javascript\">function debounce(func, wait, immediate) {\n    let timeout;\n    return function() {\n        const context = this, args = arguments;\n        const later = function() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n        };\n        const callNow = immediate &amp;&amp; !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(context, args);\n    };\n}\n</code></pre>\n<p><strong>使用指令后（教科书版）：</strong></p>\n<pre><code class=\"language-javascript\">/**\n * 创建一个防抖函数，在指定时间内多次调用只执行一次\n * \n * 防抖常用于处理频繁触发的事件，如窗口resize、输入框实时搜索等场景，\n * 可以有效减少不必要的函数调用，提升性能。\n * \n * @param {Function} func - 需要防抖处理的目标函数\n * @param {number} wait - 防抖延迟时间，单位毫秒\n * @param {boolean} [immediate=false] - 是否立即执行\n *   - true: 在延迟开始时立即执行，后续调用在延迟结束前被忽略\n *   - false: 在延迟结束后执行最后一次调用\n * @returns {Function} 经过防抖处理的新函数\n */\nfunction debounce(func, wait, immediate) {\n    // 用于存储定时器ID，实现延迟控制\n    let timeout;\n    \n    // 返回包装后的函数，保持原函数的 this 指向和参数\n    return function executedFunction() {\n        const context = this;\n        const args = arguments;\n        \n        // 延迟执行的回调函数\n        const later = function() {\n            timeout = null;\n            // 非立即执行模式下，在延迟结束后调用目标函数\n            if (!immediate) func.apply(context, args);\n        };\n        \n        // 判断是否需要立即执行：immediate 为 true 且当前没有等待中的定时器\n        const callNow = immediate &amp;&amp; !timeout;\n        \n        // 每次调用都重置定时器，实现\"重新计时\"效果\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        \n        // 立即执行模式下，首次调用直接执行\n        if (callNow) func.apply(context, args);\n    };\n}\n</code></pre>\n<p>注意到了吗？AI 不仅解释了参数，还解释了<strong>实现原理</strong>（如 \"保持原函数的 this 指向\"）。这不仅是文档，更是<strong>教学</strong>。</p>\n<h2 id=\"-工程师的第二大脑\">💡 工程师的第二大脑</h2>\n<p>使用这个 AI 指令，并不是为了让你偷懒，而是为了让你把宝贵的脑力从“解释代码”中解放出来，去专注于“设计代码”。</p>\n<p>试着把这个指令集成到你的工作流中：</p>\n<ol>\n<li><strong>接手遗留项目时</strong>：先用 AI 跑一遍核心模块，快速生成“地形图”。</li>\n<li><strong>提交 Code Review 前</strong>：用 AI 补全文档，让 Reviewer 少问几个“这是啥”。</li>\n<li><strong>编写开源库时</strong>：一键生成标准 JSDoc/Javadoc，让你的项目显得更专业。</li>\n</ol>\n<p>代码是写给机器执行的，但更是写给人看的。<br />\n<strong>别让你的代码，成为下一个需要解密的“未解之谜”。</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 18:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/huizhudev\">realhuizhu</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Magnitude:强！一款基于 Al 视觉的 Web 自动化框架",
      "link": "https://www.cnblogs.com/jinjiangongzuoshi/p/19422818",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jinjiangongzuoshi/p/19422818\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 18:21\">\n    <span>Magnitude:强！一款基于 Al 视觉的 Web 自动化框架</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>你是否还在为脆弱的 Web 自动化测试而烦恼？XPath 变更、CSS 选择器失效、DOM 结构调整，这些问题是不是经常让你的自动化脚本功亏一篑？今天要给大家介绍的&nbsp;<strong>Magnitude</strong>，可能会彻底改变你对 Web 自动化的认知。<br />\n<img alt=\"image.png\" src=\"https://image.kjdaohang.com/PicGo/20251225170226773.png\" /></p>\n<p>大多数浏览器自动化工具（如Selenium、Playwright）依赖于DOM结构来定位元素。但现代网站的DOM结构越来越复杂，稍一变动脚本就会失效。</p>\n<p>概括起来，传统的 Web 自动化工具（如 Selenium、Playwright）会存在两大痛点：</p>\n<ol>\n<li><strong>依赖 DOM 结构</strong>：一旦页面元素的属性或层级发生变化，脚本就会失效</li>\n<li><strong>指令僵化</strong>：只能执行固定流程，遇到意外情况无法自主调整</li>\n</ol>\n<p>而 Magnitude 凭借两大创新彻底解决了这些问题：</p>\n<ul>\n<li><strong>视觉优先架构</strong>：通过多模态大模型直接分析页面截图，基于像素坐标执行操作，完全不依赖 DOM 结构</li>\n<li><strong>可控且可重复的自动化</strong>：支持从精细操作到复杂流程的不同抽象级别，结合自定义提示词，既灵活又可预测。</li>\n</ul>\n<h2 id=\"什么是-magnitude\">什么是 Magnitude？</h2>\n<p>Magnitude 是一款基于AI视觉 的 Web 自动化框架，它彻底摆脱了传统自动化工具对 DOM 结构的依赖，通过模拟人类视觉和交互方式来操控浏览器。简单来说，它不是通过查找元素的 ID 或类名来操作页面，而是像人一样 \"看到\" 界面并做出反应。</p>\n<p><strong>Magnitude</strong>&nbsp;的革命性在于：它不依赖DOM，而是<strong>直接“看”屏幕</strong>！就像人类通过视觉识别按钮、输入框一样，它通过像素坐标来定位和操作元素。</p>\n<blockquote>\n<p>💡&nbsp;<strong>这意味着</strong>：无论网站如何重构，只要视觉元素存在，Magnitude就能找到它，大大提高了自动化的<strong>鲁棒性</strong>和<strong>通用性</strong></p>\n</blockquote>\n<p>这个框架另外的一个厉害之处在于，它在 WebVoyager 评测中获得了 94% 的高分，这意味着它在处理各种复杂 Web 任务时具有接近人类的能力。<br />\n<img alt=\"image.png\" src=\"https://image.kjdaohang.com/PicGo/20251225165802188.png\" /></p>\n<h2 id=\"核心功能\">核心功能</h2>\n<p>Magnitude 提供了四大核心能力，覆盖 Web 自动化的全场景需求：<br />\n<img alt=\"image.png\" src=\"https://image.kjdaohang.com/PicGo/20251225171341810.png\" /></p>\n<ol>\n<li><strong>智能导航（Navigate）</strong>：理解任何网页界面，并规划操作操作路径</li>\n<li><strong>精准交互（Interact）</strong>：通过鼠标和键盘执行精确操作</li>\n<li><strong>数据提取（Extract）</strong>：智能提取结构化数据</li>\n<li><strong>结果验证（Verify）</strong>：内置测试运行器，支持强大的视觉断言</li>\n</ol>\n<p>你可以用它来：</p>\n<ul>\n<li>自动化Web任务</li>\n<li>在无API的应用之间进行集成</li>\n<li>提取数据</li>\n<li>测试Web应用</li>\n<li>作为自定义浏览器代理的构建块</li>\n</ul>\n<h2 id=\"适用场景\">适用场景</h2>\n<p>Magnitude 适合多种场景：</p>\n<ul>\n<li>前端自动化测试，尤其适合频繁迭代的项目</li>\n<li>跨应用数据同步和工作流自动化</li>\n<li>网页数据提取和分析</li>\n<li>构建自定义浏览器代理</li>\n<li>辅助开发人员进行重复性操作</li>\n</ul>\n<h2 id=\"快速上手\">快速上手</h2>\n<p>想要体验 Magnitude 非常简单，有两种方式可以快速开始：<br />\n<img alt=\"image.png\" src=\"https://image.kjdaohang.com/PicGo/20251225171419511.png\" /></p>\n<h3 id=\"方式一创建自动化项目\">方式一：创建自动化项目</h3>\n<pre><code class=\"language-bash\">npx create-magnitude-app\n</code></pre>\n<p>这条命令会创建一个新的项目，并引导你完成 Magnitude 的设置，还会生成一个可以立即运行的示例脚本！</p>\n<h3 id=\"方式二在现有项目中使用测试运行器\">方式二：在现有项目中使用测试运行器</h3>\n<pre><code class=\"language-bash\">npm i --save-dev magnitude-test &amp;&amp; npx magnitude init\n</code></pre>\n<p>初始化后会生成：</p>\n<ul>\n<li><code>magnitude.config.ts</code>：配置文件</li>\n<li>example.mag.ts：示例测试文件</li>\n</ul>\n<p>Magnitude 的 API 设计非常直观，支持从高层任务到底层操作的各种需求：</p>\n<pre><code class=\"language-bash\"># 处理高层任务\nawait agent.act('创建一个任务', {\n    data: {\n        title: '使用 Magnitude',\n        description: '运行 \"npx create-magnitude-app\" 并跟随指示',\n    },\n});\n\n# 也能处理底层操作\nawait agent.act('将\"使用 Magnitude\"拖拽到\"进行中\"列的顶部');\n\n# 智能提取数据\nconst tasks = await agent.extract(\n    '列出进行中的任务',\n    z.array(z.object({\n        title: z.string(),\n        description: z.string(),\n        difficulty: z.number().describe('难度评级 1-5')\n    })),\n);\n\n</code></pre>\n<p>AI会理解你的意图，并自动分解为一系列精确的鼠标和键盘操作。测试用例也可以用自然语言编写，无需复杂的选择器：</p>\n<pre><code class=\"language-bash\">test('使用有效凭据登录', { url: \"https://qa-bench.com\" })\n    .step('登录应用')\n        .data({ username: \"test-user@magnitude.run\" })\n        .secureData({ password: \"test\" })\n        .check('能看到仪表盘')\n    .step('创建新公司')\n        .data(\"前两个值随意，其余用默认\")\n        .check(\"公司添加成功\");\n</code></pre>\n<p>如图所示：<br />\n![[../attachment/readme.gif]]</p>\n<h2 id=\"总结\">总结</h2>\n<p>Magnitude 代表了 Web 自动化的新方向 —— 用 AI 模拟人类视觉和交互，摆脱对具体实现细节的依赖。无论是测试工程师、开发人员还是需要自动化 Web 操作的任何人，都能从中受益。</p>\n<p>无论是自动化日常工作、在没有 API 的应用间建立集成、提取网页数据，还是测试 Web 应用，Magnitude 都能胜任。</p>\n<p>如果你受够了维护脆弱的自动化脚本，不妨试试 Magnitude，让 AI 来处理那些繁琐的界面交互细节。</p>\n<p>项目地址和更多细节，可访问：<code>https://kjdaohang.com</code>，可在最新上架菜单中查看或站内搜索<code>Magnitude</code><br />\n<img alt=\"image.png\" src=\"https://image.kjdaohang.com/PicGo/20251225172718665.png\" /></p>\n\n</div>\n<div id=\"MySignature\">\n    技术改变世界！\n         --狂诗绝剑\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 18:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jinjiangongzuoshi\">狂师</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "海豚调度DolphinScheduler 和 Spring Cloud Data Flow 对比",
      "link": "https://www.cnblogs.com/kakarotto-chen/p/19421939",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kakarotto-chen/p/19421939\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 16:22\">\n    <span>海豚调度DolphinScheduler 和 Spring Cloud Data Flow 对比</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n            <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"spring-cloud-data-flow\">Spring Cloud Data Flow</h2>\n<p>Spring Cloud Data Flow是一个基于Spring Boot和Spring Cloud的开源框架，旨在简化云原生环境中数据流处理和批处理任务的开发、部署与管理。它提供了一种统一的编程和操作模型，用于编排可组合的数据微服务，支持在Cloud Foundry、Kubernetes等现代平台上运行.</p>\n<p>‌核心功能与架构：‌ Spring Cloud Data Flow的核心功能包括通过领域特定语言（DSL）或可视化界面定义数据流、管理数据管道的部署与监控，并支持实时数据处理、批处理任务、数据集成等场景。其架构基于微服务设计，主要包括数据流（Stream）和任务（Task）两大模块：数据流用于连续处理事件流（如日志分析、实时推荐），而任务则用于一次性批处理操作（如数据导入导出）。框架通过注册中心管理可复用的应用组件，并利用Spring Cloud Deployer在不同平台上自动化部署。‌</p>\n<h2 id=\"对比\">对比</h2>\n<ul>\n<li>原理上有相似性（都是调度框架），但DolphinScheduler是“任务级的调度”，Spring Cloud Data Flow是“应用级的编排”。</li>\n</ul>\n<h3 id=\"问题-spring-cloud-data-flow来调度seatunnel和dolphinscheduler调度seatunnel差不多\">问题： spring cloud data flow来调度seatunnel、和dolphinscheduler调度seatunnel差不多？</h3>\n<ul>\n<li>Spring Cloud Data Flow（SCDF）和 DolphinScheduler 都可以用来调度 SeaTunnel 任务，但它们在设计理念和实现方式上有一些关键区别：</li>\n</ul>\n<h4 id=\"1-设计理念与架构\">1. ‌设计理念与架构‌</h4>\n<p>Spring Cloud Data Flow‌：</p>\n<ul>\n<li>核心理念‌：SCDF 是一个数据流编排框架，专注于流式和批处理任务的定义、部署和管理。它通过 Spring Boot 和 Spring Cloud 提供统一的编程模型。</li>\n<li>架构‌：基于 Spring Cloud Deployer，支持多环境部署（如本地、Kubernetes、Cloud Foundry），通过 Skipper 实现应用版本管理和滚动更新。</li>\n<li>组件模型‌：SCDF 使用源（Source）、处理器（Processor）和接收器（Sink）的组件模型，通过 DSL（Domain Specific Language）或图形界面定义数据流。</li>\n</ul>\n<p>DolphinScheduler‌：</p>\n<ul>\n<li>核心理念‌：DolphinScheduler 是一个分布式任务调度平台，支持多种任务类型（如 Shell、Spark、Flink、DataX 等），强调任务编排和监控。</li>\n<li>架构‌：基于 Master-Worker 模型，通过 ZooKeeper 实现任务调度和资源管理。</li>\n<li>组件模型‌：DolphinScheduler 支持自定义任务插件，通过拖拽界面定义 DAG 工作流。</li>\n</ul>\n<h4 id=\"2-调度方式与灵活性\">2. ‌调度方式与灵活性‌</h4>\n<p>SCDF 调度 SeaTunnel‌：<br />\n方式‌：通过 SCDF 的 DSL 或图形界面定义 SeaTunnel 任务，SCDF 负责任务的部署和执行。<br />\n灵活性‌：支持多种计算引擎（如 Spark、Flink），但需要额外配置 SeaTunnel 的启动脚本和参数。<br />\nDolphinScheduler 调度 SeaTunnel‌：<br />\n方式‌：DolphinScheduler 3.1.5+ 版本内置 SeaTunnel 组件，通过任务节点直接配置 SeaTunnel 脚本。<br />\n灵活性‌：支持动态参数配置、任务级重试和失败处理机制。</p>\n<h4 id=\"3-适用场景与优势\">3. ‌适用场景与优势‌</h4>\n<p>SCDF 优势‌：<br />\n适合需要统一数据流管理和编排的场景，尤其是与 Spring 生态系统集成。<br />\n通过 Skipper 实现应用的版本管理和滚动更新。<br />\nDolphinScheduler 优势‌：<br />\n适合复杂任务编排和监控需求，支持丰富的任务类型和自定义插件。<br />\n提供秒级任务调度和故障恢复机制。</p>\n<h4 id=\"4-关键区别\">4. ‌关键区别‌</h4>\n<p>调度模型‌：SCDF 更侧重于数据流的定义和编排，DolphinScheduler 更侧重于任务的调度和监控。<br />\n组件集成‌：SCDF 需手动配置 SeaTunnel 启动脚本，DolphinScheduler 内置 SeaTunnel 组件简化配置。<br />\n总结</p>\n<p>两者都可以调度 SeaTunnel，但 SCDF 更适合数据流编排场景，DolphinScheduler 更适合复杂任务调度需求。选择时需根据具体业务需求和现有技术栈决定。</p>\n<h2 id=\"二-核心对比两种调度思路\">二、📊 <strong>核心对比：两种调度思路</strong></h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th><strong>DolphinScheduler</strong></th>\n<th><strong>Spring Cloud Data Flow (SCDF)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>定位</strong></td>\n<td><strong>任务调度与工作流编排平台</strong></td>\n<td><strong>云原生流批数据处理平台</strong></td>\n</tr>\n<tr>\n<td><strong>设计理念</strong></td>\n<td>“任务的调度器”</td>\n<td>“数据管道的Kubernetes”</td>\n</tr>\n<tr>\n<td><strong>调度单位</strong></td>\n<td>任务/工作流（Task/DAG）</td>\n<td>数据流/批处理管道（Stream/Batch）</td>\n</tr>\n<tr>\n<td><strong>资源管理</strong></td>\n<td>Worker节点、租户、队列</td>\n<td>云平台（K8s、Cloud Foundry）</td>\n</tr>\n<tr>\n<td><strong>主要界面</strong></td>\n<td>完整的Web UI操作界面</td>\n<td>CLI + Dashboard（UI较简单）</td>\n</tr>\n<tr>\n<td><strong>部署复杂度</strong></td>\n<td>中等（需要DB、Zookeeper）</td>\n<td>高（依赖Spring Cloud生态）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三-技术实现对比\">三、🔧 <strong>技术实现对比</strong></h2>\n<h3 id=\"1-dolphinscheduler调度seatunnel\"><strong>1. DolphinScheduler调度SeaTunnel</strong></h3>\n<pre><code class=\"language-yaml\"># 你的当前方案：明确、直接的任务调度\nDS工作流任务 → Shell任务 → 执行 seatunnel.sh\n\n# 特点：\n# 1. 像crontab增强版\n# 2. 手动配置每个任务的细节\n# 3. 直接控制执行服务器和用户\n</code></pre>\n<h3 id=\"2-spring-cloud-data-flow调度seatunnel\"><strong>2. Spring Cloud Data Flow调度SeaTunnel</strong></h3>\n<pre><code class=\"language-yaml\"># SCDF方案：声明式的数据管道\nSCDF Stream定义: source -&gt; seatunnel-processor -&gt; sink\n\n# 特点：\n# 1. 把SeaTunnel包装成Spring Cloud Stream应用\n# 2. 通过SCDF部署和管理应用生命周期\n# 3. 自动处理消息传递、扩缩容\n</code></pre>\n<h2 id=\"四-适用场景对比\">四、🎯 <strong>适用场景对比</strong></h2>\n<h3 id=\"dolphinscheduler更适合\"><strong>DolphinScheduler更适合：</strong></h3>\n<pre><code class=\"language-yaml\"># 传统ETL调度场景\n- 定时数据同步任务（每天凌晨1点跑）\n- 复杂依赖的工作流（A表跑完再跑B）\n- 需要人工介入（失败报警、手动重跑）\n- 多租户、资源隔离需求\n- 已有服务器（非K8s）环境\n\n# 典型工作流\n┌─────────┐    ┌──────────┐    ┌─────────┐\n│ 采集日志 │ →  │ SeaTunnel │ → │  入仓   │\n└─────────┘    └──────────┘    └─────────┘\n       │              │              │\n   每天1点      依赖采集完成    依赖ETL完成\n</code></pre>\n<h3 id=\"spring-cloud-data-flow更适合\"><strong>Spring Cloud Data Flow更适合：</strong></h3>\n<pre><code class=\"language-yaml\"># 云原生实时/微批场景\n- 持续运行的数据管道（7x24小时）\n- 微服务架构的数据处理\n- 需要自动扩缩容\n- 已使用Spring Cloud生态\n- K8s环境部署\n\n# 典型数据流\n┌─────────┐    ┌──────────────┐    ┌─────────┐\n│ Kafka   │ →  │ SeaTunnel    │ →  │  Redis  │\n│ 消息源  │    │ (实时清洗)   │    │  实时数  │\n└─────────┘    └──────────────┘    └─────────┘\n    持续产生          持续处理          持续更新\n</code></pre>\n<h2 id=\"五-具体实现方式差异\">五、🚀 <strong>具体实现方式差异</strong></h2>\n<h3 id=\"dolphinscheduler方式你正在用的\"><strong>DolphinScheduler方式（你正在用的）</strong></h3>\n<pre><code class=\"language-bash\"># 1. 编写SeaTunnel配置文件 config.conf\n# 2. 在DS中创建Shell任务\n# 3. 任务内容：/opt/seatunnel/bin/start.sh -c config.conf\n# 4. 设置定时、依赖、告警\n</code></pre>\n<h3 id=\"spring-cloud-data-flow方式\"><strong>Spring Cloud Data Flow方式</strong></h3>\n<pre><code class=\"language-bash\"># 1. 将SeaTunnel包装为Spring Boot应用\n# 2. 注册到SCDF作为自定义处理器(processor)\n# 3. 通过DSL定义流\nstream create --name my-etl-pipeline \\\n  --definition \"http --port=9000 | seatunnel-processor | jdbc\"\n\n# 4. 部署流\nstream deploy --name my-etl-pipeline \\\n  --properties \"app.seatunnel-processor.seatunnel-config=file:///config.conf\"\n\n# 5. SCDF自动管理应用实例\n</code></pre>\n<h2 id=\"六️-重要注意事项\">六、⚠️ <strong>重要注意事项</strong></h2>\n<h3 id=\"scdf的挑战\"><strong>SCDF的挑战：</strong></h3>\n<ol>\n<li><strong>强绑定Spring生态</strong>：需要将SeaTunnel改造为Spring Cloud Stream应用</li>\n<li><strong>学习曲线陡峭</strong>：需了解Stream、Task、Skipper等概念</li>\n<li><strong>部署复杂</strong>：依赖消息中间件（RabbitMQ/Kafka）、服务发现等</li>\n<li><strong>资源消耗</strong>：每个任务都是独立JVM进程，内存开销大</li>\n</ol>\n<h3 id=\"dolphinscheduler的优势对你当前情况\"><strong>DolphinScheduler的优势（对你当前情况）：</strong></h3>\n<ol>\n<li><strong>独立轻量</strong>：不依赖特定技术栈</li>\n<li><strong>直观易用</strong>：有完整UI，学习成本低</li>\n<li><strong>你已熟悉</strong>：已搭建环境并跑通流程</li>\n<li><strong>社区活跃</strong>：中文文档和社区支持好</li>\n</ol>\n\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2025-12-30 16:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kakarotto-chen\">C_C_菜园</a>&nbsp;\n阅读(<span id=\"post_view_count\">44</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "基于SqlSugar开发框架的基础上快速开发H5端的移动应用",
      "link": "https://www.cnblogs.com/wuhuacong/p/19420561",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuhuacong/p/19420561\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 15:07\">\n    <span>基于SqlSugar开发框架的基础上快速开发H5端的移动应用</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n                <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在开发一些项目的时候，我们往往会基于一定的框架进行业务的开发，并结合一些辅助工具进行更高效率的快速开发和整合工作，SqlSugar开发框架是我们开发的一个多端整合的开发框架，基于它的后端WebAPI 基础上，我们可以对接WInform端、Vue3+ElementPlus的BS端，Vue3+Vant4的H5端，以及WPF、或者小程序等多端接入，本篇随笔介绍一个简单的项目录入功能，介绍基于SqlSugar开发框架的基础上快速开发H5端的移动应用。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在开发一些项目的时候，我们往往会基于一定的框架进行业务的开发，并结合一些辅助工具进行更高效率的快速开发和整合工作，SqlSugar开发框架是我们开发的一个多端整合的开发框架，基于它的后端框架的WebAPI 基础上，我们可以对接WInform端、Vue3+ElementPlus的BS端，Vue3+Vant4的H5端，以及WPF、或者小程序等多端接入，本篇随笔介绍一个简单的项目录入功能，介绍基于SqlSugar开发框架的基础上快速开发H5端的移动应用。</p>\n<h3>1、设计数据库</h3>\n<p>俗话说万层高楼从底起，开发应用项目，数据库的设计很重要，它可能是业务对象，业务流程的综合设计，好的数据库设计可以减少后期的重复返工，提高开发效率。</p>\n<p>一般表名称，根据不同的业务关系，我们可以使用不同的前缀进行区分，使用前缀，可以非常方便区分不同的业务表，如我自己一般基础表使用 “TB_” 定义前缀，权限系统表使用\"T_ACL_\"定义前缀，工作流表使用“TBAPP_”，业务表使用\"T_\"等，这样对于区分不同的业务，方便管理很有好处。</p>\n<p>字段名称方面，我们可以约定一些规则，如约定主键使用ID；一般来说，ID作为主键，可以使用自增长的整形字段，也可以使用GUID的字符型字段，如果为了方便兼容不同的数据库且方便迁移或者开发基于网络方面的应用，我建议还是使用GUID的字符型字段，使用这种类型的字段，我们从创建数据的时候，就可以知道这个记录的主键，对于我们维护父子表等关系非常有利。</p>\n<p>由于如果采用字符型的ID主键，那么我们如果需要正确排序的时候，可能需要增加一个CreateTime的日期类型，方便我们根据日期进行排序，或者特定的需要增加一个SortOrder字段。</p>\n<p>如果这个表还有一个外键的引用，建议统一命名标准，我一般使用“表名称_ID这样的名称，如User_ID、Contact_ID等相似的名称作为外键，不需要表的前缀。</p>\n<p>数据库的模型设计，我们建议在第三方的数据库设计工具上进行设计，如PowerDesigner这样的设计工具，使用工具设计数据库有很多好处，一个是可以高效率进行调整，二是根据需要生成不同的数据库类型Sql语句，三是可以全局了解各个表之间的关系等等。</p>\n<p>使用PowerDesigner这样的数据库设计工具，能够在很大程度上提高我们数据库的设计效率。我们默认以SQLServer数据库创建表，如下所示。</p>\n<p><img alt=\"image\" height=\"278\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230115810545-678368233.png\" width=\"323\" /></p>\n<p>设计好的数据表，在设计状态下，添加相关的备注信息。</p>\n<p><img alt=\"image\" height=\"467\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230115835170-756890014.png\" width=\"796\" /></p>\n<p>&nbsp;然后生成相关的SQL代码，我们就可以再具体的数据库管理工具上执行创建对应的表信息了。&nbsp;</p>\n<p><img alt=\"image\" height=\"466\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230115908156-1344039466.png\" width=\"794\" /></p>\n<p>&nbsp; 完成数据库表创建后，我们就完成了第一阶段的工作了。</p>\n<p>&nbsp;</p>\n<h3>2、生成SqlSugar开发框架的后端基础代码并整合</h3>\n<p>设计好数据库后，我们通过代码生成工具进行基于项目框架的代码生成，这样对于我们在开发新项目上有很好的好处，里面的项目层级、引用关系，已经处理好了，这样对我们非常方便。</p>\n<p>不过大多数情况下，我们都是增量开发较多，也就是我们可能前面已经完成了一些其他业务的开发，可能新增一个两个表，或者一批业务表的处理，我们生成相关的代码文件后把它们复制到项目恰当位置上即可。</p>\n<p>由于项目生成的时候，指定了主命名空间和相关的表前缀，这样我们生成后的代码就方便阅读很多，减少累赘和出错的机会。</p>\n<p>利用代码生成工具Database2Sharp强大的数据库元数据和模板引擎，我们构建了对应的框架代码生成规则，因此统一生成即可，提高了代码开发的效能，同时也统一了代码的结构，便于大项目的维护。</p>\n<p>对于SQLSugar的项目框架，我们为了方便，分别单独提供后端代码和Web API代码的生成、Winform界面代码的生成，以及前面介绍到的Vue3+TypeScript+ElementPlus的代码生成操作。</p>\n<p>代码生成工具的界面效果如下所示，通过入口菜单，可以实现不同部分的代码快速生成。我们先使用【Sqlsugar框架代码生成】生成后端的相关代码文件。</p>\n<p><img alt=\"image\" height=\"636\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230125345005-735899731.png\" width=\"1033\" /></p>\n<p>选择我们刚才创建的表进行一步步的生成即可。</p>\n<p><img alt=\"image\" height=\"406\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230142927634-577910459.png\" width=\"534\" /></p>\n<p>生成代码，我们可以看到相关的目录，如下所示。</p>\n<p><img alt=\"image\" height=\"591\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230143200345-246629280.png\" width=\"850\" /></p>\n<p>复制整合文件到框架项目的合适位置上，暂时不需要增加任何方法代码，我们利用继承的基类方法就完全满足需求 。</p>\n<p><img alt=\"image\" height=\"964\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230151121521-1088455216.png\" width=\"1017\" /></p>\n<p>&nbsp;</p>\n<h3>3、基于Vant4+Vue3+TypeScript的H5移动前端进行开发</h3>\n<div><strong>关于Vant4</strong></div>\n<div>\n<p>Vant 是一个<strong>轻量、可定制的移动端组件库</strong>，于 2017 年开源。目前 Vant 官方提供了&nbsp;<a href=\"https://vant-ui.github.io/vant/v2/\" rel=\"noopener nofollow\" target=\"_blank\">Vue 2 版本</a>、<a href=\"https://vant-ui.github.io/vant/\" rel=\"noopener nofollow\" target=\"_blank\">Vue 3 版本</a>和<a href=\"https://vant-ui.github.io/vant-weapp/\" rel=\"noopener nofollow\" target=\"_blank\">微信小程序版本</a>，并由社区团队维护&nbsp;<a href=\"https://github.com/3lang3/react-vant\" rel=\"noopener nofollow\" target=\"_blank\">React 版本</a>和<a href=\"https://github.com/ant-move/Vant-Aliapp\" rel=\"noopener nofollow\" target=\"_blank\">支付宝小程序版本</a>。</p>\n<p>当前移动端 项目采用最新的Vant4进行开发，适合于Vue3的项目开发。</p>\n<p>Vant 4 是一款基于 Vue 3 的轻量、可靠的手机端组件库，主要用于快速搭建移动端应用。它提供了许多常用的 UI 组件，如按钮、卡片、表单、导航等，旨在帮助开发者提高开发效率，同时保持应用的性能和一致性。</p>\n<p>Vant 4 是完全基于 Vue 3 构建的，充分利用了 Vue 3 的新特性和性能优化，如 Composition API、Teleport、Fragments 等。通过 Vue 3 的优化，Vant 4 在渲染性能上有了显著提升，特别是在处理大型列表和复杂组件时。</p>\n<p><a href=\"http://www.iqidi.com:8849/\" rel=\"noopener nofollow\" target=\"_blank\"><img alt=\"移动端H5应用\" height=\"296\" src=\"https://www.iqidi.com/Framework/images/vant-mobile.png\" width=\"296\" /></a></p>\n<p>&nbsp;扫码进行了解&nbsp;Vant4+Vue3+TypeScript 的移动前端。</p>\n<p>&nbsp;</p>\n</div>\n<p>接下来就是针对H5端应用进行的界面开发了，我们可以参考案例的滚动到底部进行分页处理的页面案例，对内容进行分页展示处理，如下所示是几个界面的效果。</p>\n<p><img alt=\"image\" height=\"741\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144121321-490674470.png\" width=\"346\" />&nbsp;&nbsp;<img alt=\"image\" height=\"742\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144148794-1515596057.png\" width=\"346\" />&nbsp;&nbsp;<img alt=\"image\" height=\"741\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144313426-902219873.png\" width=\"346\" /></p>\n<p>&nbsp;签名图片，我们通过调用通用的文件上传处理，把它上传到服务端的目录上了，使用的时候直接用其对应的地址即可。</p>\n<p><img alt=\"image\" height=\"334\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144611192-2014570350.png\" width=\"686\" /></p>\n<p>了解了界面效果，我们来看看具体的代码实现过程。</p>\n<p>我们首先增加或者使用代码生成工具生成一个api对接后端的文件，如下所示。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144808470-1588794631.png\" /></p>\n<p>这个文件很简单，就是继承基类即可，不需要增加任何自定义方法。</p>\n<div class=\"cnblogs_code\">\n<pre>import type { ListResult, PagedResult } from '@/api/types'<span style=\"color: rgba(0, 0, 0, 1);\">\nimport BaseApi from </span>'@/api/base-api'<span style=\"color: rgba(0, 0, 0, 1);\">\nimport { CommonResult } from </span>'@/api/types'<span style=\"color: rgba(0, 0, 0, 1);\">\nimport { http } from </span>'@/utils/http/axios'\n\n<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 导入API基类对象,默认具有Get/GetAll/Create/Update/Delete/BatchDelete/SaveImport/Count等接口</span><span style=\"color: rgba(0, 128, 0, 1);\">\n//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 业务类自定义接口实现, 通用的接口已经在BaseApi中定义</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">class Api <span style=\"color: rgba(255, 0, 0, 1);\"><strong>extends BaseApi</strong></span> {\n  </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 参考下面案例，增加自定义函数</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> GET 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 根据条件计算记录数量</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async GetCount(params: object) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpGet&lt;number&gt;(this.baseurl + \"count\", params);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> POST 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建对象</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async Create(data: object) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpPost&lt;boolean&gt;(this.baseurl + `create`, data);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> PUT 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 更新对象</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async Update(data: object) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpPut&lt;boolean&gt;(this.baseurl + `update`, data);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> DELETE 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 删除指定ID的对象</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async Delete(id: number | string) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpDelete&lt;boolean&gt;(this.baseurl + `${id}`);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">}\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 构造测试工作项目 Api实例，并传递业务类接口地址</span>\nexport <span style=\"color: rgba(0, 0, 255, 1);\">default</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Api('<span style=\"color: rgba(255, 0, 0, 1);\"><strong>/api/testworkitem/</strong></span>')</pre>\n</div>\n<p>前端根据框架后端的接口进行前端JS端的类的封装处理，引入了ES6类的概念实现业务基类接口的统一封装，简化代码。这些类继承BaseApi，就会具有相关的接口了，如下所示继承关系。</p>\n<p><img alt=\"\" class=\"medium-zoom-image\" src=\"https://img2020.cnblogs.com/blog/8867/202007/8867-20200713152737929-890201160.png\" /></p>\n<p>我们已经在BaseApi的ES6类里面定义了对应Web API基类里面的操作方法，如下所示。</p>\n<p><img alt=\"\" class=\"medium-zoom-image\" height=\"595\" src=\"https://img2022.cnblogs.com/blog/8867/202207/8867-20220707112405599-7103386.png\" width=\"966\" /></p>\n<p>&nbsp;这样，我们在创建一个业务类的时候，如果没有特殊的自定义接口，只需要继承基类BaseApi即可具有所有的常规基类方法了。</p>\n<p>&nbsp;由于我们的ES6接口定义，是基于TypeScript的，它的数据类型可以推断出来，因此在编码或者查看对应属性的时候，会有非常好的提示信息。</p>\n<p>对应几个不同的页面场景，我们分别创建不同的视图文件，如下所示。</p>\n<p><img alt=\"image\" height=\"454\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230145310033-599021859.png\" width=\"479\" /></p>\n<p>&nbsp;由于Vue3+Typescript+Vant4的H5应用端是基于VueRouter的路由处理，因此，我们需要在路由模块中增加对应的路由定义，如下所示。</p>\n<p><img alt=\"image\" height=\"863\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230145553832-1840777761.png\" width=\"1065\" /></p>\n<p>&nbsp;最后我们就可以再主页面提供一个入口，访问当前的模块了。如我们在列表页面模块中，首先需要引入对应的API调用类，以及定义对应的实体对象。</p>\n<p><img alt=\"image\" height=\"833\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230145818721-1359007905.png\" width=\"1073\" /></p>\n<p>&nbsp;页面只需要调用BaseApi的基类封装函数即可实现滚动继续分页获取记录的处理。</p>\n<p><img alt=\"image\" height=\"1309\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230150032578-1409793504.png\" width=\"1078\" /></p>\n<p>&nbsp;结合Vant4的相关控件，我们可以把记录的内容展示出来。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"scroll-container\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">page-header </span><span style=\"color: rgba(255, 0, 0, 1);\">@click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"goback\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-search </span><span style=\"color: rgba(255, 0, 0, 1);\">v-model</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"searchValue\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> placeholder</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"请输入搜索关键词\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @search</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"onSearch\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @clear</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"clearInput\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-list\n      </span><span style=\"color: rgba(255, 0, 0, 1);\">v-model:loading</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"loading\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n      :finished</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"finished\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n      finished-text</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"没有更多了\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n      @load</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"onRefresh\"</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-swipe-cell\n        </span><span style=\"color: rgba(255, 0, 0, 1);\">v-for</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"(item, index) in list\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n        :key</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"index\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n        class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"m-2 overflow-hidden border border-gray-300 rounded-[12px]\"</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 主体内容 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">template </span><span style=\"color: rgba(255, 0, 0, 1);\">#default</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"box-border min-w-0 w-full flex flex-row items-start p-2\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 图片区域 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-image\n              </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"h-[100px] w-[100px] flex-shrink-0 rounded-md\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n              fit</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"contain\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n              :src</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"!isNullOrUnDef(item.creatsign) ? item.creatsign : '/images/img_nodata.png'\"</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n\n            <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 文本区域 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div\n              </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"ml-4 min-w-0 flex-1\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n              @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"showDetail(item.id ?? '')\"</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n              <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"whitespace-normal break-words text-base font-medium\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                {{ item.item1 }}/{{ item.item2 }}/{{ item.item3 }}/{{ item.item4 }}\n              </span><span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n              <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"mt-2 flex flex-col whitespace-normal break-words text-sm text-gray-500\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                    状态:\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-tag </span><span style=\"color: rgba(255, 0, 0, 1);\">:type</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"getStatusTag(item.status ?? 0)\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                    {{ getStatus(item.status) }}\n                  </span><span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-tag</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>{{ format(item.createtime) }}<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n              <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 删除按钮 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">template </span><span style=\"color: rgba(255, 0, 0, 1);\">#right</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"h-full w-[64px] flex items-center justify-center bg-red-500\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-icon </span><span style=\"color: rgba(255, 0, 0, 1);\">name</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"delete\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> color</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"#fff\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> size</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"20\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"deleteItem(item)\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-swipe-cell</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-list</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"m-2\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar-icon </span><span style=\"color: rgba(255, 0, 0, 1);\">text</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"返回\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> icon</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"arrow-left\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"goback\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar-button </span><span style=\"color: rgba(255, 0, 0, 1);\">color</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"green\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> text</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"创建工作项目\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"createItem\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"mb-20\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-back-top </span><span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span></pre>\n</div>\n<p>从而实现了我们前面介绍的页面效果。</p>\n<p><img alt=\"image\" height=\"741\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144121321-490674470.png\" width=\"346\" />&nbsp;&nbsp;<img alt=\"image\" height=\"746\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230150350899-1651155846.png\" width=\"348\" /></p>\n<p>&nbsp;其他页面的效果也是类似，参考相关的界面实现来调整展示效果即可，不在赘述。</p>\n<p>&nbsp;如需进一步了解H5应用端的功能介绍，可以参考随笔《<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuhuacong/p/19039255\" id=\"cb_post_title_url\" title=\"发布于 2025-08-15 13:36\">基于Vant4+Vue3+TypeScript的H5移动前端</a>》，进行深入的了解。</p>\n</div>\n<div id=\"MySignature\">\n    <div style=\"border-right-color: #cccccc; border-right-width: 1px; border-right-style: solid; padding-right: 5px; border-top-color: #cccccc; border-top-width: 1px; border-top-style: solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left-color: #cccccc; border-left-width: 1px; border-left-style: solid; width: 98%; padding-top: 4px; border-bottom-color: #cccccc; border-bottom-width: 1px; border-bottom-style: solid; background-color: #eeeeee;\">\n    <img align=\"top\" alt=\"\" src=\"http://www.cnblogs.com/Images/OutliningIndicators/None.gif\" />\n    <span style=\"color: #000000;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"></span>\n     专注于代码生成工具、.Net/Python 框架架构及软件开发，以及各种Vue.js的前端技术应用。著有Winform开发框架/混合式开发框架、微信开发框架、Bootstrap开发框架、ABP开发框架、SqlSugar开发框架、Python开发框架等框架产品。\n     <br />&nbsp;&nbsp;转载请注明出处：撰写人：伍华聪&nbsp;&nbsp;<a href=\"http://www.iqidi.com/\" target=\"_blank\">http://www.iqidi.com</a>&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;</span></div>\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2025-12-30 15:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wuhuacong\">伍华聪</a>&nbsp;\n阅读(<span id=\"post_view_count\">169</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "实用程序：Python打造进程网络监控与分析工具——全方位掌握你的网络与进程状态",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19421354",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19421354\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 14:57\">\n    <span>实用程序：Python打造进程网络监控与分析工具——全方位掌握你的网络与进程状态</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文介绍了一款基于Python开发的GUI网络监控工具，能够实时监控进程网络活动、分析端口占用情况、诊断网络问题。该工具支持Windows系统，提供进程带宽管理、端口筛选、网速测试、路由追踪等功能，并可将数据导出为CSV或图表。界面简洁易用，集成实时刷新、带宽限制等高级功能，适合普通用户排查网络故障和开发者分析程序行为。项目已开源，包含详细功能展示和操作指南，后续将优化多平台兼容性。代码地址：https://github.com/ChenAI-TGF/SysNetMonitor_GUI\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>在日常使用电脑的过程中，你是否好奇过这些困惑：为什么网络突然变卡？哪个进程在偷偷占用大量带宽？某个端口被哪个程序占用了？为了解决这些问题，博主用python开发了一款「进程网络监控与分析工具」，它能全方位监控网络状态、分析进程网络行为、诊断网络问题，帮你轻松掌握系统网络全貌。程序涵盖进程网络监控，系统总带宽波动查询，网络环境信息，端口占用监控，网络诊断服务，限制宽带等全面的功能，并配有UI界面，0上手门槛！</p>\n<p><strong>代码已开源到Github，欢迎访问下载：<a href=\"https://github.com/ChenAI-TGF/SysNetMonitor_GUI\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/SysNetMonitor_GUI</a><br />\n如果觉得好用的话可以点点Star，十分感谢！！</strong><br />\n<strong>也可以直接私信我要开源代码</strong></p>\n<p>先来个界面预览：<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"项目简介\">项目简介</h1>\n<p>这款工具是基于Python开发的GUI应用，旨在为用户提供直观、全面的网络与进程监控能力。无论是普通用户排查网络故障，还是开发者分析程序网络行为，都能满足需求。工具支持Windows主流系统，部分功能兼容Linux/macOS，界面简洁大方，操作简单易上手。</p>\n<h1 id=\"环境要求\">环境要求</h1>\n<p>在使用工具前，需确保你的环境满足以下要求：</p>\n<ul>\n<li><strong>Python版本</strong>：3.7及以上（推荐3.9+，兼容性更佳）</li>\n<li><strong>支持系统</strong>：主要支持Windows（部分功能兼容Linux/macOS）</li>\n<li><strong>依赖库</strong>：\n<ul>\n<li>内置库：tkinter、ctypes、platform、socket（无需额外安装）</li>\n<li>第三方库：psutil（进程与系统监控）、ttkbootstrap（UI美化）、matplotlib（图表绘制）、numpy（数据处理）、requests（网络请求）、netifaces（网络接口信息）、speedtest-cli（网速测试）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"核心功能详解\">核心功能详解</h1>\n<p>工具包含多个大核心功能模块，覆盖从进程监控到网络诊断的全场景需求，以下是详细介绍：</p>\n<h2 id=\"1-进程网络监控\">1. 进程网络监控</h2>\n<p>这是工具的核心功能之一，能够实时展示系统中所有进程的网络活动状态。</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>实时监控</strong>：显示进程的PID、名称、本地/远程IP端口、上传/下载速度、总流量等关键信息。</li>\n<li><strong>详情查看</strong>：双击任意进程，可打开详情窗口，查看该进程的带宽变化曲线（支持实时刷新）、历史网络活动记录。</li>\n<li><strong>带宽管理</strong>：在进程详情窗口中，可设置上传/下载带宽预警阈值（当超过阈值时会触发提醒）；在主界面选中进程后，点击「限制进程带宽」可手动限制其网络速度。</li>\n</ul>\n<h2 id=\"2-端口占用监控\">2. 端口占用监控</h2>\n<p>轻松网络调试中，端口占用是常见问题，该模块可快速定位端口占用情况：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>端口信息全展示</strong>：表格列出所有端口的协议类型（TCP/UDP）、本地IP和端口、远程IP和端口、连接状态、所属进程PID及名称。</li>\n<li><strong>精准筛选</strong>：支持通过端口号搜索和协议类型（TCP/UDP/全部）筛选，快速定位目标端口。</li>\n<li><strong>关联进程</strong>：双击端口查看端口对应的进程名称和PID，方便直接占用端口的程序（双击端口记录可跳进程详情）。</li>\n</ul>\n<h2 id=\"3-网络环境信息\">3. 网络环境信息</h2>\n<p>全面展示当前网络环境的基础信息，帮你快速了解当前网络配置：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>网络概览</strong>：包含公网IP、运营商信息、ASN（自治系统编号）、网络类型（有线/无线）、默认网关、DNS服务器、网络延迟和丢包率。</li>\n<li><strong>网卡详情</strong>：显示所有网卡的详细信息，包括网卡名称、MAC地址、IP地址（IPv4/IPv6）、子网掩码、广播地址等。</li>\n<li><strong>一键刷新</strong>：点击「刷新网络信息」按钮，可实时更新所有网络环境数据。</li>\n</ul>\n<h3 id=\"4-网络诊断工具\">4. 网络诊断工具</h3>\n<p>集成网络故障排查提供实用功能：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>网速测试</strong>：测试当前网络的上传/下载速度（基于speedtest-cli）。</li>\n<li><strong>Ping测试</strong>：输入目标IP或域名，执行Ping命令，查看延迟和丢包情况。</li>\n<li><strong>路由追踪</strong>：追踪数据包从本地到目标地址的路由路径，定位网络瓶颈节点。</li>\n</ul>\n<h2 id=\"5-数据导出与分析\">5. 数据导出与分析</h2>\n<p>支持将监控数据导出保存，方便后续分析：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>数据导出</strong>：在「操作面板」标签页，可将进程网络数据、端口占用数据导出为CSV格式，便于用Excel等工具进一步分析。</li>\n<li><strong>图表导出</strong>：在进程详情窗口的带宽曲线图中，点击「导出图表」可将实时带宽曲线保存为PNG图片。</li>\n</ul>\n<p>导出效果如下<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"6-进程具体数据分析\">6. 进程具体数据分析</h2>\n<h3 id=\"61-基本信息\">6.1 基本信息</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"62-网络信息\">6.2 网络信息</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"62-带宽曲线图\">6.2 带宽曲线图</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"64-连接详情\">6.4 连接详情</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"65-流量分析\">6.5 流量分析</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"使用方法\">使用方法</h1>\n<h2 id=\"1-运行应用\">1. 运行应用</h2>\n<ul>\n<li>直接执行脚本：<code>python 你的脚本文件名.py</code></li>\n<li>执行脚本之后，如果你不是以管理员权限运行的脚本，程序会询问你是否可以用管理员权限来执行，选择是既可<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></li>\n</ul>\n<h3 id=\"2-基本操作\">2. 基本操作</h3>\n<ul>\n<li>各标签页均均有「刷新」按钮，点击可手动更新数据。</li>\n<li>在「进程网络监控」标签页双击进程，打开详情窗口；在「端口占用监控」标签页双击端口记录，查看对应进程信息。</li>\n</ul>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"3-高级功能\">3. 高级功能</h3>\n<ul>\n<li>\n<p><strong>带宽限制设置</strong>：在进程详情窗口配置该进程上传和下载的带宽限制。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p><strong>多条件筛选</strong>：端口监控支持组合筛选（端口号+协议），快速定位异常连接。</p>\n</li>\n</ul>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"项目亮点\">项目亮点</h2>\n<ol>\n<li><strong>功能全面</strong>：整合进程监控、端口分析、网络诊断、数据导出等功能，一站式解决网络监控需求。</li>\n<li><strong>界面友好</strong>：基于ttkbootstrap打造的UI，简洁美观，操作逻辑清晰，适合各类用户。</li>\n<li><strong>实时性强</strong>：数据刷新及时，带宽曲线实时绘制，能精准反映网络状态变化。</li>\n<li><strong>跨平台潜力</strong>：核心功能在Linux/macOS上可兼容，未来将进一步完善多平台支持。</li>\n</ol>\n<h2 id=\"总结\">总结</h2>\n<p>这款进程网络监控与分析工具旨在为用户提供透明、可控的网络管理能力。无论是普通用户解决网络卡顿问题，还是开发者调试程序网络行为，都能从中受益。目前工具已实现核心功能，后续将持续优化多平台兼容性，并增加更多高级分析功能（如网络流量趋势预测、异常连接智能预警等）。</p>\n<p><strong>代码已开源到Github，欢迎访问下载：<a href=\"https://github.com/ChenAI-TGF/SysNetMonitor_GUI\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/SysNetMonitor_GUI</a><br />\n如果觉得好用的话可以点点Star，十分感谢！！</strong></p>\n<p>如果你也有网络监控的需求，欢迎尝试这款工具，如有问题或建议，欢迎在项目仓库留言交流！<br />\n<strong>也可以直接私信我要开源代码</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 14:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\n阅读(<span id=\"post_view_count\">92</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "回归分析全家桶（16种回归模型实现方式总结）",
      "link": "https://www.cnblogs.com/wang_yb/p/19421224",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19421224\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 14:47\">\n    <span>回归分析全家桶（16种回归模型实现方式总结）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>提到回归分析，很多人第一时间想到的只有“线性回归”和“逻辑回归”。但实际上，针对不同的数据情况（比如有离群点、数据是计数的、数据有缺失截断等），我们有十几种回归模型可以选择。</p>\n<p>今天为大家总结了 <strong>16种回归分析</strong> 的模型，重点不是介绍这些回归模型的原理，而是介绍如何在Python代码中使用这些模型，希望你以后能够在实战中来应用这些模型！</p>\n<h1 id=\"1-回归分析全家桶\">1. 回归分析全家桶</h1>\n<p>下面介绍如何使用各种回归模型的示例代码，主要分为以下一些步骤：</p>\n<ul>\n<li><strong>模拟数据</strong>：创建适合某种回归模型的测试数据</li>\n<li><strong>创建回归模型并训练</strong>：主要使用 <code>scikit-learn</code> 这个库</li>\n<li><strong>评估模型</strong>：有时会和其他回归模型对比</li>\n<li><strong>可视化模型</strong>：使用<code>matplotlib</code>这个库，简单展示模型效果</li>\n</ul>\n<p>由于担心文章篇幅太长，文中的示例没有贴出完整的代码（特别是可视化部分的代码，比较繁琐，文中都省略了），文章末尾提供了完整代码（一个<code>jupyter notebook</code>文件）的下载地址，包括了所有可视化的代码。</p>\n<p>下面的代码中统一导入了下面的库：</p>\n<pre><code class=\"language-python\">import pandas as pd\nimport numpy as np\n\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n# 为了显示中文\nmatplotlib.rcParams[\"font.sans-serif\"] = [\"Microsoft YaHei Mono\"]\nmatplotlib.rcParams[\"axes.unicode_minus\"] = False\n</code></pre>\n<h2 id=\"11-线性回归-linear-regression\">1.1. 线性回归 (Linear Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：最基础的回归，假设自变量（X）和因变量（Y）之间是“直来直去”的线性关系。</li>\n<li><strong>使用场景</strong>：预测房价、销售额等连续数值，且数据没有明显的复杂非线性关系。</li>\n</ul>\n<p><strong>线性回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 线性回归 (Linear Regression)\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error, r2_score\n\n# 构造测试数据\n# 假设我们要模拟房屋面积（自变量X）和房价（因变量Y）的关系\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\n# 生成100个房屋面积数据，范围在50-200平方米\nX = np.random.rand(100, 1) * 150 + 50\n\n# 真实的线性关系：房价 = 5000 * 面积 + 100000 + 随机噪声\n# 其中5000是每平方米的价格，100000是基础价格\n# 加入一些随机噪声，使数据更真实\nY_true = 5000 * X + 100000\nY = Y_true + np.random.randn(100, 1) * 50000  # 加入标准差为50000的噪声\n\n# 使用线性回归模型\nmodel = LinearRegression()\nmodel.fit(X, Y)\n\n# 预测\nY_pred = model.predict(X)\n\n# 打印模型参数\nprint(\"线性回归模型参数：\")\nprint(f\"截距（基础价格）: {model.intercept_[0]:.2f}\")\nprint(f\"斜率（每平方米价格）: {model.coef_[0][0]:.2f}\")\n\n# 评估模型\nmse = mean_squared_error(Y, Y_pred)\nr2 = r2_score(Y, Y_pred)\nprint(f\"\\n模型评估：\")\nprint(f\"均方误差 (MSE): {mse:.2f}\")\nprint(f\"决定系数 (R²): {r2:.2f}\")\n\n# 使用matplotlib绘制图像\n#... 省略 ...\n\n## 运行结果：\n'''\n线性回归模型参数：\n截距（基础价格）: 118417.69\n斜率（每平方米价格）: 4846.74\n\n模型评估：\n均方误差 (MSE): 2016461409.92\n决定系数 (R²): 0.96\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331409-1637286150.png\" /></p>\n<h2 id=\"12-多项式回归-polynomial-regression\">1.2. 多项式回归 (Polynomial Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：当数据不是直线分布，而是像曲线一样弯曲时，我们给自变量加上平方、立方等“高次项”来拟合曲线。</li>\n<li><strong>使用场景</strong>：拟合生物生长曲线、由于边际效应递减导致的经济学数据等非线性关系。</li>\n</ul>\n<p><strong>多项式回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 多项式回归 (Polynomial Regression)\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.metrics import mean_squared_error, r2_score\n\n# 1. 构造强非线性测试数据（模拟生物生长曲线）\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\n# 生成100个自变量数据，范围在0-15\nX = np.random.rand(100, 1) * 15\n\n# 真实的强非线性关系：使用类似S型曲线的函数（Logistic生长模型的变形）\n# Y = 100 / (1 + exp(-0.5*(X-7))) + 随机噪声\n# 这个关系模拟了生物生长曲线：初期缓慢，中期快速增长，后期趋于饱和\nY_true = 100 / (1 + np.exp(-0.5 * (X - 7)))\nY = Y_true + np.random.randn(100, 1) * 5  # 加入标准差为5的噪声\n\n# 2. 多项式回归（使用三次多项式）\n# 转换特征，添加平方和立方项\npoly_features = PolynomialFeatures(degree=3, include_bias=False)\nX_poly = poly_features.fit_transform(X)\n\n# 使用线性回归拟合转换后的特征\nmodel = LinearRegression()\nmodel.fit(X_poly, Y)\n\n# 预测\nY_pred = model.predict(X_poly)\n\n# 打印模型参数\nprint(\"多项式回归模型参数（三次多项式）：\")\nprint(f\"截距: {model.intercept_[0]:.2f}\")\nprint(f\"系数: {model.coef_[0]}\")\n\n# 评估模型\nmse = mean_squared_error(Y, Y_pred)\nr2 = r2_score(Y, Y_pred)\nprint(f\"\\n模型评估：\")\nprint(f\"均方误差 (MSE): {mse:.2f}\")\nprint(f\"决定系数 (R²): {r2:.2f}\")\n\n# 3. 使用线性回归作为对比\nlinear_model = LinearRegression()\nlinear_model.fit(X, Y)\nY_linear_pred = linear_model.predict(X)\n\n# 评估线性回归模型\nlinear_mse = mean_squared_error(Y, Y_linear_pred)\nlinear_r2 = r2_score(Y, Y_linear_pred)\nprint(f\"\\n线性回归模型评估：\")\nprint(f\"均方误差 (MSE): {linear_mse:.2f}\")\nprint(f\"决定系数 (R²): {linear_r2:.2f}\")\n\n# 4. 使用matplotlib绘制图像\n#... 省略 ...\n\n## 运行结果：\n'''\n多项式回归模型参数（三次多项式）：\n截距: 8.70\n系数: [-4.29511575  2.09659382 -0.09560718]\n\n模型评估：\n均方误差 (MSE): 20.02\n决定系数 (R²): 0.98\n\n线性回归模型评估：\n均方误差 (MSE): 56.71\n决定系数 (R²): 0.95\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331139-1466034349.png\" /></p>\n<p>从示例可以看出，线性回归只能用一条直线拟合所有数据，无法捕捉到S型曲线的弯曲特征。</p>\n<p><strong>多项式回归</strong>能够更好地贴合数据的非线性模式，尤其是在曲线的弯曲部分，</p>\n<p>这种对比清晰地展示了多项式回归在处理非线性数据时的优势。</p>\n<h2 id=\"13-逻辑回归-logistic-regression\">1.3. 逻辑回归 (Logistic Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：虽然叫“回归”，但其实是做<strong>分类</strong>的。它预测的是事件发生的概率（0到1之间），输出结果通常通过阈值（如0.5）划分为两类。</li>\n<li><strong>使用场景</strong>：预测用户是否会购买（是/否）、病人是否患病、邮件是否为垃圾邮件。</li>\n</ul>\n<p><strong>逻辑回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 逻辑回归 (Logistic Regression)\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import accuracy_score\n\n# 1. 构造二分类测试数据（模拟用户购买预测场景）\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\n# 类别0：不会购买的用户特征（如浏览时长和页面访问量）\nn_class0 = 100\nclass0_features = np.random.randn(n_class0, 2) * 1.5 + [3, 3]\nclass0_labels = np.zeros(n_class0)\n\n# 类别1：会购买的用户特征\nn_class1 = 100\nclass1_features = np.random.randn(n_class1, 2) * 1.5 + [6, 6]\nclass1_labels = np.ones(n_class1)\n\n# 合并数据集\nX = np.vstack([class0_features, class1_features])\ny = np.hstack([class0_labels, class1_labels])\n\n# 2. 训练逻辑回归模型\nmodel = LogisticRegression()\nmodel.fit(X, y)\n\n# 预测\ny_pred_proba = model.predict_proba(X)[:, 1]\ny_pred = model.predict(X)\n\n# 模型评估\naccuracy = accuracy_score(y, y_pred)\nprint(f\"逻辑回归模型准确率: {accuracy:.2f}\")\n\n# 3. 绘制图像\n#... 省略 ...\n\n## 运行结果：\n'''\n逻辑回归模型准确率: 0.93\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331982-1885882694.png\" /></p>\n<p>这个示例清晰展示了逻辑回归如何进行二分类预测，并通过可视化直观呈现了分类结果、决策边界和概率分布，完全符合逻辑回归的应用场景（预测事件发生概率）。</p>\n<h2 id=\"14-分位数回归-quantile-regression\">1.4. 分位数回归 (Quantile Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：普通回归预测的是“平均值”，而分位数回归可以预测“中位数”或者任意百分位点（如前10%）。</li>\n<li><strong>使用场景</strong>：数据中有极端异常值（离群点），或者你想研究不同层级的数据（如分析贫困人口和富裕人口的收入影响因素差异）。</li>\n</ul>\n<p><strong>分位数回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 分位数回归 (Quantile Regression)\nimport statsmodels.api as sm\nfrom sklearn.linear_model import LinearRegression\n\n# 1. 构造包含极端异常值的测试数据\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\n# 生成基础自变量数据（如收入）\nX = np.linspace(10, 100, 100).reshape(-1, 1)\n\n# 基础线性关系：消费 = 0.6 * 收入 + 10 + 随机噪声\nY_true = 0.6 * X + 10\nY = Y_true + np.random.normal(0, 5, size=X.shape)  # 加入正常噪声\n\n# 添加极端异常值（模拟高消费人群的极端消费行为）\n# 选择最后10个数据点，添加大的正异常值\nY[-10:] += np.random.normal(100, 20, size=(10, 1))\n\n# 2. 普通线性回归\nlinear_model = LinearRegression()\nlinear_model.fit(X, Y)\nY_linear_pred = linear_model.predict(X)\n\n# 3. 分位数回归\n# 添加常数项\nX_with_const = sm.add_constant(X)\n\n# 定义要估计的分位数\nquantiles = [0.1, 0.5, 0.9]\nquantile_results = {}\n\n# 拟合不同分位数的模型\nfor q in quantiles:\n    model = sm.QuantReg(Y, X_with_const)\n    result = model.fit(q=q)\n    quantile_results[q] = result\n\n# 4. 预测不同分位数的结果\nY_quantile_pred = {}\nfor q in quantiles:\n    Y_quantile_pred[q] = quantile_results[q].predict(X_with_const)\n\n# 5. 绘制图像\n#... 省略 ...\n\n# 打印模型参数对比\nprint(\"\\n=== 模型参数对比 ===\")\nprint(\n    f\"普通线性回归: 截距={linear_model.intercept_[0]:.2f}, 斜率={linear_model.coef_[0][0]:.2f}\"\n)\nfor q in quantiles:\n    intercept = quantile_results[q].params[0]\n    slope = quantile_results[q].params[1]\n    print(f\"分位数回归(τ={q:.1f}): 截距={intercept:.2f}, 斜率={slope:.2f}\")\n\n## 运行结果：\n'''\n=== 模型参数对比 ===\n普通线性回归: 截距=-13.59, 斜率=1.20\n分位数回归(τ=0.1): 截距=0.59, 斜率=0.66\n分位数回归(τ=0.5): 截距=6.95, 斜率=0.67\n分位数回归(τ=0.9): 截距=-3.01, 斜率=1.73\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331673-243100488.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>不同分位数的回归线斜率和截距各不相同</li>\n<li>高消费分位(τ=0.9)的回归线最接近异常值，而低消费分位(τ=0.1)的回归线几乎不受异常值影响</li>\n<li>中位数回归(τ=0.5)相对普通线性回归更能抵抗异常值的影响</li>\n</ul>\n<p>这个示例清晰地展示了<strong>分位数回归</strong>如何处理<strong>极端异常值</strong>，以及如何通过不同分位数分析数据的不同层级结构，非常适合用户描述的使用场景（数据中有极端异常值或需要研究不同层级数据）。</p>\n<h2 id=\"15-岭回归-ridge-regression\">1.5. 岭回归 (Ridge Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：在线性回归的基础上加了一个“惩罚项”（L2正则化），防止模型为了迎合训练数据而变得太复杂（过拟合）。</li>\n<li><strong>使用场景</strong>：特征之间相关性很高（多重共线性）导致普通回归失效时。</li>\n</ul>\n<p><strong>岭回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 岭回归 (Ridge Regression)\nfrom sklearn.linear_model import LinearRegression, Ridge\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import StandardScaler\n\n# 1. 构造具有多重共线性的测试数据\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\n# 生成基础特征（如房屋的总面积）\nX1 = np.random.rand(100, 1) * 100 + 50  # 50-150平方米\n\n# 生成高度相关的第二个特征（如房屋的可用面积）\n# 设置高度相关性：X2 = 0.8*X1 + 少量噪声\nX2 = 0.8 * X1 + np.random.randn(100, 1) * 5\nX = np.hstack([X1, X2])  # 合并两个特征\n\n# 真实的线性关系：房价 = 10000*X1 + 8000*X2 + 500000 + 随机噪声\nY_true = 10000 * X1 + 8000 * X2 + 500000\nY = Y_true + np.random.randn(100, 1) * 200000  # 加入噪声\n\n# 2. 数据标准化（岭回归对特征缩放敏感）\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nY_scaled = scaler.fit_transform(Y)\n\n# 3. 普通线性回归\nlinear_model = LinearRegression()\nlinear_model.fit(X_scaled, Y_scaled)\nY_linear_pred = linear_model.predict(X_scaled)\n\n# 4. 岭回归（不同的正则化参数λ）\n# 移除0值以避免log10(0)的警告\nlambdas = [0.1, 1, 10, 100, 1000]  # 不同的λ值\nridge_models = {}\nridge_preds = {}\nridge_coefs = []\n\nfor lam in lambdas:\n    model = Ridge(alpha=lam)\n    model.fit(X_scaled, Y_scaled)\n    ridge_models[lam] = model\n    ridge_preds[lam] = model.predict(X_scaled)\n    ridge_coefs.append(model.coef_.flatten())\n\n# 5. 可视化结果\n#... 省略 ...\n\n# 计算并比较MSE\nprint(\"\\n=== 模型性能比较 (MSE) ===\")\nprint(f\"普通线性回归 MSE: {mean_squared_error(Y_scaled, Y_linear_pred):.4f}\")\nfor lam in lambdas:\n    mse = mean_squared_error(Y_scaled, ridge_preds[lam])\n    print(f\"岭回归 (λ={lam}) MSE: {mse:.4f}\")\n\n## 运行结果：\n'''\n=== 模型性能比较 (MSE) ===\n普通线性回归 MSE: 0.1705\n岭回归 (λ=0.1) MSE: 0.1705\n岭回归 (λ=1) MSE: 0.1706\n岭回归 (λ=10) MSE: 0.1730\n岭回归 (λ=100) MSE: 0.2645\n岭回归 (λ=1000) MSE: 0.7486\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331106-2018685368.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331742-1675204939.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>普通线性回归在多重共线性下系数可能不稳定</li>\n<li>随着λ增大，岭回归系数逐渐减小并趋向稳定</li>\n<li>合适的λ值可以在保持预测准确性的同时提高模型稳定性</li>\n</ul>\n<p>这个示例清晰地展示了<strong>岭回归</strong>在处理<strong>多重共线性数据</strong>时的优势，以及如何通过正则化参数λ来平衡模型复杂度和预测准确性。</p>\n<h2 id=\"16-lasso回归-lasso-regression\">1.6. Lasso回归 (Lasso Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：和岭回归类似，但使用的是L1正则化。它不仅能防止过拟合，还能把不重要的特征系数强行压缩为0。</li>\n<li><strong>使用场景</strong>：当你有很多特征，想要自动筛选出最重要的几个特征时。</li>\n</ul>\n<hr />\n<p><strong>Lasso回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># Lasso回归 (Lasso Regression)\nfrom sklearn.linear_model import LinearRegression, Lasso\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import StandardScaler\n\n# 1. 构造多特征测试数据（大部分特征不重要）\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\nn_samples = 100\nn_features = 10  # 总共10个特征\n\n# 生成10个特征，前3个是真正重要的，后7个是不重要的\nX = np.random.randn(n_samples, n_features)\n\n# 真实系数：前3个特征有较大的非零系数，后7个特征的系数为0\ntrue_coef = np.zeros(n_features)\ntrue_coef[0] = 10.0  # 重要特征1\ntrue_coef[1] = -8.0  # 重要特征2\ntrue_coef[2] = 5.0  # 重要特征3\n\n# 生成目标变量：Y = X * 真实系数 + 随机噪声\nY_true = X.dot(true_coef)\nY = Y_true + np.random.randn(n_samples) * 5  # 加入噪声\n\n# 2. 数据标准化（Lasso对特征缩放敏感）\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nY_scaled = scaler.fit_transform(Y.reshape(-1, 1)).ravel()\n\n# 3. 普通线性回归\nlinear_model = LinearRegression()\nlinear_model.fit(X_scaled, Y_scaled)\nY_linear_pred = linear_model.predict(X_scaled)\n\n# 4. Lasso回归（不同的正则化参数λ）\nlambdas = [0.01, 0.1, 0.5, 1.0, 5.0]  # 不同的λ值\nlasso_models = {}\nlasso_preds = {}\nlasso_coefs = []\n\nfor lam in lambdas:\n    model = Lasso(alpha=lam, max_iter=10000)  # 增加最大迭代次数避免收敛警告\n    model.fit(X_scaled, Y_scaled)\n    lasso_models[lam] = model\n    lasso_preds[lam] = model.predict(X_scaled)\n    lasso_coefs.append(model.coef_)\n\n# 5. 可视化结果\n#... 省略 ...\n\n# 计算并比较MSE\nprint(\"\\n=== 模型性能比较 (MSE) ===\")\nprint(f\"普通线性回归 MSE: {mean_squared_error(Y_scaled, Y_linear_pred):.4f}\")\nfor lam in lambdas:\n    mse = mean_squared_error(Y_scaled, lasso_preds[lam])\n    print(f\"Lasso回归 (λ={lam}) MSE: {mse:.4f}\")\n\n## 运行结果：\n'''\n=== 模型性能比较 (MSE) ===\n普通线性回归 MSE: 0.1024\nLasso回归 (λ=0.01) MSE: 0.1034\nLasso回归 (λ=0.1) MSE: 0.1384\nLasso回归 (λ=0.5) MSE: 0.6845\nLasso回归 (λ=1.0) MSE: 1.0000\nLasso回归 (λ=5.0) MSE: 1.0000\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144332120-340193149.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331129-81036439.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331123-660205758.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>随着λ增大，越来越多的系数被压缩为0</li>\n<li>Lasso能够自动识别并保留重要特征（前3个）</li>\n<li>适当的λ值可以在保持预测精度的同时实现特征选择</li>\n</ul>\n<p>这个示例很好地展示了<strong>Lasso回归</strong>的特征选择能力，非常适合用户描述的使用场景（当有很多特征，想要自动筛选出最重要的几个特征时）。</p>\n<h2 id=\"17-弹性网络回归-elastic-net-regression\">1.7. 弹性网络回归 (Elastic Net Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：岭回归和套索回归的“混血儿”，结合了它俩的优点。</li>\n<li><strong>使用场景</strong>：特征非常多且彼此高度相关，你既想选特征又想保持模型稳定时。</li>\n</ul>\n<p><strong>弹性网络回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 弹性网络回归 (Elastic Net Regression)\nfrom sklearn.linear_model import LinearRegression, Lasso, Ridge, ElasticNet\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import StandardScaler\n\n# 1. 构造高相关多特征测试数据\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\nn_samples = 100\nn_features = 10  # 总共10个特征\n\n# 生成基础特征\nbase_feature = np.random.randn(n_samples, 1)\n\n# 生成高度相关的特征组\n# 前3个特征高度相关（重要特征）\nX = np.zeros((n_samples, n_features))\nX[:, 0] = base_feature.ravel() + np.random.randn(n_samples) * 0.1  # 主特征1\nX[:, 1] = X[:, 0] * 0.8 + np.random.randn(n_samples) * 0.2  # 相关特征2\nX[:, 2] = X[:, 0] * 0.5 + X[:, 1] * 0.3 + np.random.randn(n_samples) * 0.2  # 相关特征3\n\n# 中间3个特征高度相关但不重要\nX[:, 3] = np.random.randn(n_samples) * 0.3 + X[:, 0] * 0.1  # 弱相关特征4\nX[:, 4] = X[:, 3] * 0.7 + np.random.randn(n_samples) * 0.2  # 相关特征5\nX[:, 5] = X[:, 3] * 0.6 + X[:, 4] * 0.4 + np.random.randn(n_samples) * 0.2  # 相关特征6\n\n# 最后4个特征是随机噪声（完全不重要）\nX[:, 6:] = np.random.randn(n_samples, 4) * 0.5\n\n# 真实系数：只有前3个重要特征有非零系数\ntrue_coef = np.zeros(n_features)\ntrue_coef[0] = 10.0\ntrue_coef[1] = -5.0\ntrue_coef[2] = 3.0\n\n# 生成目标变量\nY_true = X.dot(true_coef)\nY = Y_true + np.random.randn(n_samples) * 3  # 加入噪声\n\n# 2. 数据标准化（正则化模型对特征缩放敏感）\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nY_scaled = scaler.fit_transform(Y.reshape(-1, 1)).ravel()\n\n# 3. 训练不同的回归模型\n# 普通线性回归\nlinear_model = LinearRegression()\nlinear_model.fit(X_scaled, Y_scaled)\n\n# Lasso回归（λ=0.1）\nlasso_model = Lasso(alpha=0.1, max_iter=10000)\nlasso_model.fit(X_scaled, Y_scaled)\n\n# Ridge回归（λ=1.0）\nridge_model = Ridge(alpha=1.0)\nridge_model.fit(X_scaled, Y_scaled)\n\n# 弹性网络回归（不同的l1_ratio）\nelastic_models = {}\nl1_ratios = [0.1, 0.5, 0.9]  # 控制L1和L2的比例\nalpha = 1.0  # 总正则化强度\n\nfor ratio in l1_ratios:\n    model = ElasticNet(alpha=alpha, l1_ratio=ratio, max_iter=10000)\n    model.fit(X_scaled, Y_scaled)\n    elastic_models[ratio] = model\n\n# 4. 预测\nY_linear_pred = linear_model.predict(X_scaled)\nY_lasso_pred = lasso_model.predict(X_scaled)\nY_ridge_pred = ridge_model.predict(X_scaled)\nY_elastic_pred = {\n    ratio: model.predict(X_scaled) for ratio, model in elastic_models.items()\n}\n\n# 5. 可视化结果\n# ... 省略 ...\n\n# 6. 模型评估和特征选择效果\nprint(\"=== 模型性能评估 ===\")\nprint(f\"普通线性回归 MSE: {mean_squared_error(Y_scaled, Y_linear_pred):.4f}\")\nprint(f\"Lasso回归 MSE: {mean_squared_error(Y_scaled, Y_lasso_pred):.4f}\")\nprint(f\"Ridge回归 MSE: {mean_squared_error(Y_scaled, Y_ridge_pred):.4f}\")\nfor ratio in l1_ratios:\n    mse = mean_squared_error(Y_scaled, Y_elastic_pred[ratio])\n    print(f\"弹性网络 (l1_ratio={ratio}) MSE: {mse:.4f}\")\n\nprint(\"\\n=== 特征选择效果 ===\")\nprint(f\"普通线性回归非零系数数: {np.sum(linear_model.coef_ != 0)}\")\nprint(f\"Lasso回归非零系数数: {np.sum(lasso_model.coef_ != 0)}\")\nprint(\n    f\"Ridge回归非零系数数: {np.sum(ridge_model.coef_ != 0)}\"\n)  # Ridge几乎不会产生严格零系数\nfor ratio in l1_ratios:\n    non_zero_count = np.sum(elastic_models[ratio].coef_ != 0)\n    print(f\"弹性网络 (l1_ratio={ratio}) 非零系数数: {non_zero_count}\")\n\n## 运行结果：\n'''\n=== 模型性能评估 ===\n普通线性回归 MSE: 0.1352\nLasso回归 MSE: 0.1677\nRidge回归 MSE: 0.1369\n弹性网络 (l1_ratio=0.1) MSE: 0.2676\n弹性网络 (l1_ratio=0.5) MSE: 0.5002\n弹性网络 (l1_ratio=0.9) MSE: 0.9711\n\n=== 特征选择效果 ===\n普通线性回归非零系数数: 10\nLasso回归非零系数数: 2\nRidge回归非零系数数: 10\n弹性网络 (l1_ratio=0.1) 非零系数数: 3\n弹性网络 (l1_ratio=0.5) 非零系数数: 3\n弹性网络 (l1_ratio=0.9) 非零系数数: 1\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331684-1991608237.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331132-1346251950.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331150-224052372.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>弹性网络结合了Lasso的特征选择能力和Ridge的稳定性</li>\n<li>通过调整l1_ratio，可以在特征选择和系数稳定性之间找到平衡</li>\n<li>当特征高度相关时，弹性网络比Lasso更稳定，比Ridge更能进行特征选择</li>\n</ul>\n<p>这个示例很好地展示了<strong>弹性网络回归</strong>在处理<strong>高维</strong>、<strong>高度相关数据</strong>时的优势，特别适合需要同时进行特征选择和保持模型稳定的场景。</p>\n<h2 id=\"18-主成分回归-pcr\">1.8. 主成分回归 (PCR)</h2>\n<ul>\n<li><strong>一句话概念</strong>：先用PCA（主成分分析）把很多相关的特征压缩成几个不相关的“主成分”，再用这些主成分做回归。</li>\n<li><strong>使用场景</strong>：特征数量比样本数量还多，或者特征之间严重相关。</li>\n</ul>\n<p><strong>主成分回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 主成分回归 (PCR)\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error\n\n# 1. 构造高维高相关测试数据（特征数&gt;样本数）\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\nn_samples = 100\nn_features = 200  # 特征数多于样本数，模拟高维问题\n\n# 生成基础特征（只有3个真正重要的基础变量）\nbase_features = np.random.randn(n_samples, 3)\n\n# 生成200个高度相关的特征\n# 每个新特征都是3个基础特征的线性组合 + 少量噪声\nX = np.zeros((n_samples, n_features))\nfor i in range(n_features):\n    # 随机权重（确保特征之间高度相关）\n    weights = np.random.randn(3)\n    X[:, i] = base_features.dot(weights) + np.random.randn(n_samples) * 0.1\n\n# 真实系数：只有基于前3个基础特征的组合有意义\n# 我们只使用前10个特征来生成目标变量\ntrue_weights = np.zeros(n_features)\ntrue_weights[:10] = np.random.randn(10) * 2\n\n# 生成目标变量\nY_true = X.dot(true_weights)\nY = Y_true + np.random.randn(n_samples) * 5  # 加入噪声\n\n# 2. 数据标准化\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nY_scaled = scaler.fit_transform(Y.reshape(-1, 1)).ravel()\n\n# 3. 普通线性回归（可能过拟合）\nlinear_model = LinearRegression()\nlinear_model.fit(X_scaled, Y_scaled)\nY_linear_pred = linear_model.predict(X_scaled)\nlinear_mse = mean_squared_error(Y_scaled, Y_linear_pred)\n\n# 4. 主成分回归 (PCR)\n# 4.1 PCA降维\npca = PCA()\nX_pca = pca.fit_transform(X_scaled)\n\n# 4.2 计算累积方差解释率\nexplained_variance_ratio = pca.explained_variance_ratio_\ncumulative_variance_ratio = np.cumsum(explained_variance_ratio)\n\n# 4.3 选择保留的主成分数量（比如保留95%方差）\nn_components_95 = np.argmax(cumulative_variance_ratio &gt;= 0.95) + 1\nprint(f\"保留95%方差需要的主成分数: {n_components_95}\")\n\n# 4.4 使用不同数量的主成分进行回归\nn_components_list = [3, 5, 10, 20, n_components_95]\npcr_results = {}\n\nfor n in n_components_list:\n    # 使用前n个主成分\n    X_pca_n = X_pca[:, :n]\n\n    # 线性回归\n    model = LinearRegression()\n    model.fit(X_pca_n, Y_scaled)\n\n    # 预测\n    Y_pcr_pred = model.predict(X_pca_n)\n    mse = mean_squared_error(Y_scaled, Y_pcr_pred)\n\n    pcr_results[n] = {\n        'model': model,\n        'predictions': Y_pcr_pred,\n        'mse': mse\n    }\n\n# 5. 可视化结果\n# ... 省略 ...\n\n# 6. 模型性能对比\nprint(\"\\n=== 模型性能对比 ===\")\nprint(f\"普通线性回归 MSE: {linear_mse:.4f}\")\nfor n in n_components_list:\n    print(f\"PCR (n={n}) MSE: {pcr_results[n]['mse']:.4f}\")\n\n# 7. 展示PCR如何解决过拟合\nprint(\"\\n=== PCR解决过拟合效果 ===\")\nprint(f\"原始特征数量: {n_features}\")\nprint(f\"样本数量: {n_samples}\")\nprint(f\"普通回归的特征系数最大值: {np.max(np.abs(linear_model.coef_)):.4f}\")\nprint(f\"PCR (n={n_components_95}) 的特征系数最大值: {np.max(np.abs(pcr_coef)):.4f}\")\n\n## 运行结果：\n'''\n=== 模型性能对比 ===\n普通线性回归 MSE: 0.0000\nPCR (n=3) MSE: 0.5484\nPCR (n=5) MSE: 0.5187\nPCR (n=10) MSE: 0.4777\nPCR (n=20) MSE: 0.4040\nPCR (n=3) MSE: 0.5484\n\n=== PCR解决过拟合效果 ===\n原始特征数量: 200\n样本数量: 100\n普通回归的特征系数最大值: 2.1407\nPCR (n=3) 的特征系数最大值: 0.0101\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331885-1026425432.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331170-1231259987.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331130-574001026.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>只需少量主成分（通常&lt;30）即可保留95%以上的方差</li>\n<li>PCR的预测效果优于直接线性回归，尤其是在高维数据中</li>\n<li>PCR的系数更加稳定，避免了普通回归中系数过大的问题</li>\n</ul>\n<p>这个示例完美展示了<code>PCR</code>在<strong>高维</strong>、<strong>高度相关数据</strong>中的应用，解决了直接线性回归的过拟合问题，同时保持了良好的预测性能。</p>\n<h2 id=\"19-偏最小二乘回归-pls-regression\">1.9. 偏最小二乘回归 (PLS Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：和PCR类似，但它在降维时会考虑因变量Y的信息，确保提取出的成分不仅能概括X，还能很好地预测Y。</li>\n<li><strong>使用场景</strong>：比PCR更高级一点，常用于化学计量学或变量非常多的情况。</li>\n</ul>\n<p><strong>偏最小二乘回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 偏最小二乘回归 (PLS Regression)\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.decomposition import PCA\nfrom sklearn.cross_decomposition import PLSRegression\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error\n\n# 1. 构造高维相关数据，其中只有部分特征与Y相关\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\nn_samples = 100\nn_features = 100  # 100个特征，模拟高维问题\n\n# 生成基础变量\n# 前5个变量与Y高度相关，中间15个变量与Y弱相关，最后80个变量与Y不相关\nbase_vars = np.random.randn(n_samples, 20)\nnoise_vars = np.random.randn(n_samples, 80)  # 完全不相关的噪声特征\n\n# 组合所有特征\nX = np.hstack([base_vars, noise_vars])\n\n# 生成Y，主要依赖前5个基础变量\nY_true = (\n    5 * base_vars[:, 0]\n    + 3 * base_vars[:, 1]\n    - 4 * base_vars[:, 2]\n    + 2 * base_vars[:, 3]\n    + base_vars[:, 4]\n)\nY = Y_true + np.random.randn(n_samples) * 3  # 加入噪声\n\n# 2. 数据标准化\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nY_scaled = scaler.fit_transform(Y.reshape(-1, 1)).ravel()\n\n# 3. 普通线性回归（作为基准）\nlinear_model = LinearRegression()\nlinear_model.fit(X_scaled, Y_scaled)\nY_linear_pred = linear_model.predict(X_scaled)\nlinear_mse = mean_squared_error(Y_scaled, Y_linear_pred)\n\n# 4. PCA + 线性回归 (PCR)\npca = PCA()\nX_pca = pca.fit_transform(X_scaled)\n\n# 5. 偏最小二乘回归 (PLS)\npls = PLSRegression(n_components=20)\nX_pls = pls.fit_transform(X_scaled, Y_scaled)[0]\n\n# 6. 比较不同成分数量的PCR和PLS性能\nn_components_list = range(1, 21)\npcr_mse_list = []\npls_mse_list = []\n\nfor n in n_components_list:\n    # PCR\n    model_pcr = LinearRegression()\n    model_pcr.fit(X_pca[:, :n], Y_scaled)\n    Y_pcr_pred = model_pcr.predict(X_pca[:, :n])\n    pcr_mse_list.append(mean_squared_error(Y_scaled, Y_pcr_pred))\n\n    # PLS\n    model_pls = PLSRegression(n_components=n)\n    model_pls.fit(X_scaled, Y_scaled)\n    Y_pls_pred = model_pls.predict(X_scaled).ravel()\n    pls_mse_list.append(mean_squared_error(Y_scaled, Y_pls_pred))\n\n# 7. 可视化结果\n# ... 省略 ...\n\n# 输出结果\nprint(\"\\n=== 模型性能对比 ===\")\nprint(f\"普通线性回归 MSE: {linear_mse:.4f}\")\nprint(f\"最佳PCR (n={best_pcr_n}) MSE: {pcr_mse_list[best_pcr_n-1]:.4f}\")\nprint(f\"最佳PLS (n={best_pls_n}) MSE: {pls_mse_list[best_pls_n-1]:.4f}\")\nprint(\n    f\"PLS相比最佳PCR的MSE提升: {(pcr_mse_list[best_pcr_n-1] - pls_mse_list[best_pls_n-1])/pcr_mse_list[best_pcr_n-1]*100:.1f}%\"\n)\n\n# 展示PLS如何提取与Y相关的成分\nprint(\"\\n=== PLS成分分析 ===\")\npls_var_importance = np.abs(pls.x_weights_).sum(axis=1)\nprint(f\"PLS前5个最重要成分的方差贡献: {np.sort(pls_var_importance)[::-1][:5]}\")\n\n## 运行结果：\n'''\n=== 模型性能对比 ===\n普通线性回归 MSE: 0.0000\n最佳PCR (n=20) MSE: 0.6687\n最佳PLS (n=20) MSE: 0.0048\nPLS相比最佳PCR的MSE提升: 99.3%\n\n=== PLS成分分析 ===\nPLS前5个最重要成分的方差贡献: [2.4938574  2.27964709 2.17888686 2.08667187 2.06267069]\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331157-367253800.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331165-587185182.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331948-1785309370.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>PLS在较少的成分数下就能达到较好的预测效果</li>\n<li>PLS提取的成分与Y的相关性明显高于PCA成分</li>\n<li>当存在大量噪声特征时，PLS的优势更加明显</li>\n</ul>\n<p>这个示例清晰地展示了<strong>PLS回归</strong>如何在降维过程中考虑因变量Y的信息，从而在高维、存在噪声的情况下提供比PCR更好的预测性能。</p>\n<h2 id=\"110-支持向量回归-svr\">1.10. 支持向量回归 (SVR)</h2>\n<ul>\n<li><strong>一句话概念</strong>：借用了SVM分类的思想，试图找到一个“管道”包裹住尽可能多的数据点，在管道内的误差被忽略，只计算管道外的误差。</li>\n<li><strong>使用场景</strong>：高维数据，或者数据关系非常复杂非线性时（配合核函数）。</li>\n</ul>\n<p><strong>支持向量回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 支持向量回归 (SVR)\nfrom sklearn.svm import SVR\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error\n\n# 1. 构造复杂非线性测试数据\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\n# 生成基础自变量（在0-10范围内）\nX = np.sort(np.random.rand(100, 1) * 10, axis=0)\n\n# 生成复杂的非线性目标变量：正弦函数 + 多项式 + 噪声\n# 这种非线性关系很难用普通线性回归拟合\nY_true = np.sin(2 * X) + 0.5 * X + 0.2 * X**2\nY = Y_true + np.random.randn(100, 1) * 0.5  # 加入噪声\n\n# 2. 数据标准化\nscaler_X = StandardScaler()\nscaler_Y = StandardScaler()\n\nX_scaled = scaler_X.fit_transform(X)\nY_scaled = scaler_Y.fit_transform(Y)\n\n# 3. 模型训练\n\n# 普通线性回归（作为基准）\nlinear_model = LinearRegression()\nlinear_model.fit(X_scaled, Y_scaled)\nY_linear_pred_scaled = linear_model.predict(X_scaled)\nY_linear_pred = scaler_Y.inverse_transform(Y_linear_pred_scaled)\n\n# 支持向量回归 (SVR)\n# 线性核SVR\nsvr_linear = SVR(kernel=\"linear\", C=100, epsilon=0.1)\nsvr_linear.fit(X_scaled, Y_scaled.ravel())\nY_svr_linear_pred_scaled = svr_linear.predict(X_scaled)\nY_svr_linear_pred = scaler_Y.inverse_transform(Y_svr_linear_pred_scaled.reshape(-1, 1))\n\n# RBF核SVR（非线性）\nsvr_rbf_1 = SVR(kernel=\"rbf\", C=100, epsilon=0.1, gamma=0.1)\nsvr_rbf_1.fit(X_scaled, Y_scaled.ravel())\nY_svr_rbf_1_pred_scaled = svr_rbf_1.predict(X_scaled)\nY_svr_rbf_1_pred = scaler_Y.inverse_transform(Y_svr_rbf_1_pred_scaled.reshape(-1, 1))\n\n# 不同ε值的RBF核SVR\nsvr_rbf_2 = SVR(kernel=\"rbf\", C=100, epsilon=0.5, gamma=0.1)\nsvr_rbf_2.fit(X_scaled, Y_scaled.ravel())\nY_svr_rbf_2_pred_scaled = svr_rbf_2.predict(X_scaled)\nY_svr_rbf_2_pred = scaler_Y.inverse_transform(Y_svr_rbf_2_pred_scaled.reshape(-1, 1))\n\n# 4. 计算模型性能\nmse_linear = mean_squared_error(Y, Y_linear_pred)\nmse_svr_linear = mean_squared_error(Y, Y_svr_linear_pred)\nmse_svr_rbf_1 = mean_squared_error(Y, Y_svr_rbf_1_pred)\nmse_svr_rbf_2 = mean_squared_error(Y, Y_svr_rbf_2_pred)\n\n# 5. 可视化结果\n# ... 省略 ...\n\n# 4. 输出模型性能\nprint(\"\\n=== 模型性能对比 ===\")\nprint(f\"普通线性回归 MSE: {mse_linear:.4f}\")\nprint(f\"线性核SVR MSE: {mse_svr_linear:.4f}\")\nprint(f\"RBF核SVR (ε=0.1) MSE: {mse_svr_rbf_1:.4f}\")\nprint(f\"RBF核SVR (ε=0.5) MSE: {mse_svr_rbf_2:.4f}\")\n\n# 展示支持向量\nprint(f\"\\n=== SVR支持向量信息 ===\")\nprint(f\"RBF核SVR (ε=0.1) 使用的支持向量数量: {len(svr_rbf_1.support_)}\")\nprint(f\"线性核SVR 使用的支持向量数量: {len(svr_linear.support_)}\")\n\n## 运行结果：\n'''\n=== 模型性能对比 ===\n普通线性回归 MSE: 3.3016\n线性核SVR MSE: 3.3938\nRBF核SVR (ε=0.1) MSE: 0.6200\nRBF核SVR (ε=0.5) MSE: 4.7397\n\n=== SVR支持向量信息 ===\nRBF核SVR (ε=0.1) 使用的支持向量数量: 42\n线性核SVR 使用的支持向量数量: 70\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144332001-578126908.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331772-1159748120.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331120-2032066286.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>RBF核SVR能够很好地拟合复杂非线性关系</li>\n<li>调整ε可以控制模型对误差的容忍度</li>\n<li>调整C可以平衡模型复杂度和对异常值的敏感度</li>\n<li>SVR只使用部分数据点（支持向量）进行预测</li>\n</ul>\n<p>这个示例完美展示了<code>SVR</code>在处理复杂非线性数据时的优势，特别是其独特的ε-不敏感损失函数和核函数机制。</p>\n<h2 id=\"111-有序回归-ordinal-regression\">1.11. 有序回归 (Ordinal Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：预测的结果是有顺序的类别，比如“低、中、高”或者“不喜欢、一般、喜欢”。</li>\n<li><strong>使用场景</strong>：问卷调查评分（1-5分）、电影评级、疾病严重程度分级。</li>\n</ul>\n<p><strong>有序回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 有序回归 (Ordinal Regression)\nimport statsmodels.api as sm\nfrom statsmodels.miscmodels.ordinal_model import OrderedModel\n\n# 1. 构造测试数据\nnp.random.seed(42)\nn_samples = 500\n\n# 特征：年龄（0-70岁）和购买金额（0-100元）\nage = np.random.uniform(0, 70, n_samples)\npurchase = np.random.uniform(0, 100, n_samples)\n\n# 真实系数：购买金额对满意度影响更大\nbeta_age = 0.03  # 年龄系数\nbeta_purchase = 0.08  # 购买金额系数\nintercept = -2.0  # 基准截距\n\n# 潜在变量（连续值，用于生成有序类别）\nlatent = (\n    intercept\n    + beta_age * age\n    + beta_purchase * purchase\n    + np.random.normal(0, 0.5, n_samples)\n)\n\n# 使用分位数创建5个均衡的有序类别（1-5分满意度）\nthresholds = np.percentile(latent, [20, 40, 60, 80])\nsatisfaction = np.digitize(latent, thresholds, right=False) + 1  # 类别：1-5\n\n# 创建DataFrame\ndf = pd.DataFrame({\"age\": age, \"purchase\": purchase, \"satisfaction\": satisfaction})\n\n# 2. 拟合有序回归模型\nmodel = OrderedModel(\n    df[\"satisfaction\"], df[[\"age\", \"purchase\"]], distr=\"logit\"  # 逻辑斯蒂链接函数\n)\n\nresult = model.fit(method=\"bfgs\")  # 使用BFGS优化算法\n\n# 3. 生成预测\npred_probs = result.predict(df[[\"age\", \"purchase\"]])\npredicted = pred_probs.idxmax(axis=1).astype(int)  # 预测的类别（概率最高的）\n\n# 4. 可视化结果\n# ... 省略 ...\n\n# 5. 模型解释\nprint(\"\\n模型系数解释:\")\nprint(f\"年龄系数: {result.params['age']:.4f} - 年龄每增加1岁，满意度的潜在变量变化\")\nprint(\n    f\"购买金额系数: {result.params['purchase']:.4f} - 购买金额每增加1元，满意度的潜在变量变化\"\n)\nprint(\"\\n阈值估计:\")\nfor i, threshold in enumerate(result.params[2:]):  # 前两个是特征系数，后面是阈值\n    print(f\"满意度 {i+1}-{i+2} 阈值: {threshold:.4f}\")\n\n## 运行结果：\n'''\n模型系数解释:\n年龄系数: 0.0872 - 年龄每增加1岁，满意度的潜在变量变化\n购买金额系数: 0.2626 - 购买金额每增加1元，满意度的潜在变量变化\n\n阈值估计:\n满意度 1-2 阈值: 7.8416\n满意度 2-3 阈值: 1.6160\n满意度 3-4 阈值: 1.6758\n满意度 4-5 阈值: 1.6772\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144332135-99066096.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>特征系数表示对潜在变量的影响程度</li>\n<li>阈值参数表示类别之间的分界点</li>\n<li>购买金额的影响大于年龄，符合数据生成逻辑</li>\n</ul>\n<p>该代码完整展示了<strong>有序回归</strong>的理论基础、实现方法和结果分析，特别适合处理如满意度评分、等级评定等有序分类数据。</p>\n<h2 id=\"112-泊松回归-poisson-regression\">1.12. 泊松回归 (Poisson Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：专门用于预测“次数”或“计数”的回归，假设数据符合泊松分布。</li>\n<li><strong>使用场景</strong>：预测某个路口每小时经过的车辆数、客服中心每天接到的电话数。</li>\n</ul>\n<p><strong>泊松回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 泊松回归 (Poisson Regression)\nfrom scipy import stats\nfrom scipy.optimize import minimize\nfrom scipy.special import gammaln\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\n\n# 生成模拟数据：模拟客服中心每天接到的电话数\nnp.random.seed(42)  # 设置随机种子确保结果可复现\n\n# 自变量：广告投入（万元），工作日标识（1为工作日，0为非工作日）\nn_samples = 200\nadvertising_spend = np.random.uniform(0, 10, n_samples)  # 广告投入0-10万元\nis_weekday = np.random.binomial(1, 0.7, n_samples)       # 70%是工作日\n\n# 构造线性预测变量（使用对数链接函数）\nlinear_combination = 0.5 + 0.3 * advertising_spend + 0.4 * is_weekday\n# 泊松回归的期望值（均值）为 exp(线性组合)\nexpected_counts = np.exp(linear_combination)\n\n# 生成泊松分布的响应变量（电话数量）\ncalls_count = np.random.poisson(expected_counts)\n\n# 创建数据集\nX = np.column_stack([advertising_spend, is_weekday])\ny = calls_count\n\nprint(f\"生成了 {n_samples} 个样本\")\nprint(f\"平均电话数量: {np.mean(y):.2f}\")\nprint(f\"电话数量的标准差: {np.std(y):.2f}\")\n\n# 泊松回归模型实现\nclass PoissonRegression:\n    # ... 省略 ...\n\n# 拟合泊松回归模型\npoisson_reg = PoissonRegression()\npoisson_reg.fit(X, y)\n\n# 预测\ny_pred = poisson_reg.predict(X)\n\nprint(\"泊松回归系数:\")\nprint(f\"截距: {poisson_reg.coefficients[0]:.4f}\")\nprint(f\"广告投入系数: {poisson_reg.coefficients[1]:.4f}\")\nprint(f\"工作日系数: {poisson_reg.coefficients[2]:.4f}\")\nprint(f\"广告投入每增加1万元，电话数量变化倍数: {np.exp(poisson_reg.coefficients[1]):.4f}\")\nprint(f\"工作日相比非工作日电话数量变化倍数: {np.exp(poisson_reg.coefficients[2]):.4f}\")\n\n# 绘制结果图像\n# ... 省略 ...\n\n# 计算模型性能指标\nmse = mean_squared_error(y, y_pred)\nmae = mean_absolute_error(y, y_pred)\nrmse = np.sqrt(mse)\n\nprint(f\"\\n模型性能指标:\")\nprint(f\"均方误差 (MSE): {mse:.4f}\")\nprint(f\"平均绝对误差 (MAE): {mae:.4f}\")\nprint(f\"均方根误差 (RMSE): {rmse:.4f}\")\n\n## 运行结果：\n'''\n生成了 200 个样本\n平均电话数量: 13.93\n电话数量的标准差: 13.13\n泊松回归系数:\n截距: 0.4484\n广告投入系数: 0.3098\n工作日系数: 0.3904\n广告投入每增加1万元，电话数量变化倍数: 1.3632\n工作日相比非工作日电话数量变化倍数: 1.4775\n\n模型性能指标:\n均方误差 (MSE): 14.5815\n平均绝对误差 (MAE): 2.8126\n均方根误差 (RMSE): 3.8186\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331474-1225492130.png\" /></p>\n<p><strong>泊松回归模型</strong>的优势体现在以下几个方面：</p>\n<ol>\n<li><strong>适用于计数数据</strong>：泊松回归特别适合预测计数型变量（如电话数量），假设响应变量服从泊松分布，且其方差等于均值，能够很好地处理计数数据中常见的方差随均值变化的情况。</li>\n<li><strong>保证非负预测</strong>：通过使用对数链接函数，确保了预测值始终为正数，避免了可能出现的负数计数问题，符合计数数据的特性。</li>\n<li><strong>解释性强且适用稀有事件</strong>：回归系数易于解释为自变量变化对计数的乘性影响，并且在事件发生频率较低时表现良好，适合于客服电话、交通事故等低频事件的预测。</li>\n</ol>\n<p>这个示例模拟了客服中心电话数量预测的场景，其中广告投入和是否为工作日作为预测变量，完美展示了泊松回归如何处理计数型数据并提供可解释的结果。</p>\n<h2 id=\"113-负二项回归-negative-binomial-regression\">1.13. 负二项回归 (Negative Binomial Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：也是做计数预测的，但它解决了泊松回归中“方差必须等于均值”的苛刻假设。</li>\n<li><strong>使用场景</strong>：数据波动特别大（方差 &gt;&gt; 均值）的计数数据，比如某款冷门商品偶尔大卖的销量预测。</li>\n</ul>\n<p><strong>负二项回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 负二项回归 (Negative Binomial Regression)\nfrom scipy.optimize import minimize\nfrom scipy.special import gammaln\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\n\n# 生成模拟数据：模拟冷门商品销量预测（方差远大于均值的情况）\nnp.random.seed(42)  # 设置随机种子确保结果可复现\n\n# 自变量：促销活动（1为有促销，0为无促销），价格折扣率，商品类别（1为热门商品，0为冷门商品）\nn_samples = 300\npromotion = np.random.binomial(1, 0.3, n_samples)  # 30%有促销活动\ndiscount_rate = np.random.uniform(0, 0.3, n_samples)  # 0-30%的折扣\nis_popular = np.random.binomial(1, 0.2, n_samples)   # 20%是热门商品\n\n# 构造线性预测变量（使用对数链接函数）\nlinear_combination = -1.0 + 1.2 * promotion + 0.8 * discount_rate + 0.5 * is_popular\n# 负二项回归的均值为 exp(线性组合)\nmu = np.exp(linear_combination)\n\n# 负二项分布的参数设置（r为离散参数，控制方差）\n# 方差 = mu + mu^2/r，当r较小时，方差远大于均值\nr = 1.5  # 较小的r值，使得方差远大于均值\n\n# 生成负二项分布的响应变量（销量）\n# 使用负二项分布：var = mu + mu^2/r，当r小的时候方差很大\n# 负二项分布的参数转换：p = r/(r+mu)\np = r / (r + mu)\nsales_count = np.random.negative_binomial(r, p)\n\n# 创建数据集\nX = np.column_stack([promotion, discount_rate, is_popular])\ny = sales_count\n\n# 负二项回归模型实现\nclass NegativeBinomialRegression:\n    # ... 省略 ...\n\n# 拟合负二项回归模型\nneg_bin_reg = NegativeBinomialRegression()\nneg_bin_reg.fit(X, y)\n\n# 预测\ny_pred = neg_bin_reg.predict(X)\n\n# 绘制结果图像\n# ... 省略 ...\n\n# 计算模型性能指标\nmse = mean_squared_error(y, y_pred)\nmae = mean_absolute_error(y, y_pred)\nrmse = np.sqrt(mse)\n\nprint(f\"\\n模型性能指标:\")\nprint(f\"均方误差 (MSE): {mse:.4f}\")\nprint(f\"平均绝对误差 (MAE): {mae:.4f}\")\nprint(f\"均方根误差 (RMSE): {rmse:.4f}\")\n\n# 比较泊松回归和负二项回归的拟合效果\nfrom sklearn.linear_model import PoissonRegressor\n\n# 使用sklearn的泊松回归进行比较\npoisson_reg = PoissonRegressor()\npoisson_reg.fit(X, y)\ny_pred_poisson = poisson_reg.predict(X)\n\npoisson_mse = mean_squared_error(y, y_pred_poisson)\npoisson_mae = mean_absolute_error(y, y_pred_poisson)\npoisson_rmse = np.sqrt(poisson_mse)\n\nprint(f\"\\n与泊松回归的比较:\")\nprint(f\"负二项回归 MSE: {mse:.4f}\")\nprint(f\"泊松回归 MSE: {poisson_mse:.4f}\")\nprint(f\"负二项回归 MAE: {mae:.4f}\")\nprint(f\"泊松回归 MAE: {poisson_mae:.4f}\")\nprint(f\"负二项回归 RMSE: {rmse:.4f}\")\nprint(f\"泊松回归 RMSE: {poisson_rmse:.4f}\")\n\n## 运行结果：\n'''\n模型性能指标:\n均方误差 (MSE): 1.0138\n平均绝对误差 (MAE): 0.7567\n均方根误差 (RMSE): 1.0069\n\n与泊松回归的比较:\n负二项回归 MSE: 1.0138\n泊松回归 MSE: 1.1612\n负二项回归 MAE: 0.7567\n泊松回归 MAE: 0.8246\n负二项回归 RMSE: 1.0069\n泊松回归 RMSE: 1.0776\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331160-22547985.png\" /></p>\n<p><strong>负二项回归模型</strong>的优势体现在以下几个方面：</p>\n<ol>\n<li><strong>解决过度离势问题</strong>：负二项回归能够处理方差大于均值的计数数据，适用于方差/均值比远大于1的情况，如冷门商品偶尔大卖的数据。</li>\n<li><strong>更灵活的方差结构</strong>：通过引入离散参数r，负二项回归允许方差独立于均值变化（方差为 $ \\mu + \\mu^2/r $），从而更好地拟合实际数据中的变异性。</li>\n<li><strong>更好的拟合效果和更真实的假设</strong>：在高变异数据下，负二项回归通常比泊松回归提供更准确的预测，并且其假设更符合实际业务场景中计数数据的统计特性。</li>\n</ol>\n<p>这个示例模拟了冷门商品销量预测的场景，其中促销活动、折扣率和商品类型作为预测变量，完美展示了<strong>负二项回归</strong>如何处理方差远大于均值的计数型数据，并提供比泊松回归更准确的预测结果。</p>\n<h2 id=\"114-准泊松回归-quasi-poisson-regression\">1.14. 准泊松回归 (Quasi Poisson Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：泊松回归的另一种替代方案，用来处理由于数据波动过大（过度离散）导致的标准误估计不准的问题。</li>\n<li><strong>使用场景</strong>：和负二项回归类似，用于处理过度离散的计数数据。</li>\n</ul>\n<p><strong>准泊松回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 准泊松回归 (Quasi Poisson Regression)\nfrom scipy.optimize import minimize\nfrom scipy.special import gammaln\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\n\n# 生成模拟数据：模拟过度离散的计数数据（如交通事故次数预测）\nnp.random.seed(42)  # 设置随机种子确保结果可复现\n\n# 自变量：道路长度（公里），交通流量（车辆/小时），天气状况（1为恶劣天气，0为正常天气）\nn_samples = 250\nroad_length = np.random.uniform(1, 20, n_samples)  # 道路长度1-20公里\ntraffic_flow = np.random.uniform(50, 500, n_samples)  # 交通流量50-500辆/小时\nbad_weather = np.random.binomial(1, 0.15, n_samples)  # 15%是恶劣天气\n\n# 构造线性预测变量（使用对数链接函数）\nlinear_combination = -2.0 + 0.05 * road_length + 0.002 * traffic_flow + 0.8 * bad_weather\n# 泊松回归的期望值（均值）为 exp(线性组合)\nexpected_counts = np.exp(linear_combination)\n\n# 为了模拟过度离散，我们引入额外的变异\n# 生成过度离散的计数数据：均值为expected_counts，但方差更大\n# 使用负二项分布生成数据，使其具有过度离散特征\ndispersion_param = 2.0  # 离散参数，控制过度离散程度\nr = expected_counts / (dispersion_param - 1)  # 负二项分布的参数转换\np = r / (r + expected_counts)\naccident_count = np.random.negative_binomial(r, p)\n\n# 创建数据集\nX = np.column_stack([road_length, traffic_flow, bad_weather])\ny = accident_count\n\nprint(f\"生成了 {n_samples} 个样本\")\nprint(f\"平均事故数: {np.mean(y):.2f}\")\nprint(f\"事故数的标准差: {np.std(y):.2f}\")\nprint(f\"方差/均值比: {np.var(y)/np.mean(y):.2f} (泊松分布该比值应为1，大于1表示过度离散)\")\n\n# 准泊松回归模型实现\nclass QuasiPoissonRegression:\n    # ... 省略 ...\n\n# 拟合准泊松回归模型\nquasi_poisson_reg = QuasiPoissonRegression()\nquasi_poisson_reg.fit(X, y)\n\n# 预测\ny_pred = quasi_poisson_reg.predict(X)\ny_var = quasi_poisson_reg.predict_variance(X)\n\n# 绘制结果图像\n# ... 省略 ...\n\n# 计算模型性能指标\nmse = mean_squared_error(y, y_pred)\nmae = mean_absolute_error(y, y_pred)\nrmse = np.sqrt(mse)\n\nprint(f\"\\n模型性能指标:\")\nprint(f\"均方误差 (MSE): {mse:.4f}\")\nprint(f\"平均绝对误差 (MAE): {mae:.4f}\")\nprint(f\"均方根误差 (RMSE): {rmse:.4f}\")\n\n# 与标准泊松回归的比较\nfrom sklearn.linear_model import PoissonRegressor\n\n# 使用sklearn的泊松回归进行比较\npoisson_reg = PoissonRegressor()\npoisson_reg.fit(X, y)\ny_pred_poisson = poisson_reg.predict(X)\n\npoisson_mse = mean_squared_error(y, y_pred_poisson)\npoisson_mae = mean_absolute_error(y, y_pred_poisson)\npoisson_rmse = np.sqrt(poisson_mse)\n\nprint(f\"\\n与泊松回归的比较:\")\nprint(f\"准泊松回归 MSE: {mse:.4f}\")\nprint(f\"泊松回归 MSE: {poisson_mse:.4f}\")\nprint(f\"准泊松回归 MAE: {mae:.4f}\")\nprint(f\"泊松回归 MAE: {poisson_mae:.4f}\")\nprint(f\"准泊松回归 RMSE: {rmse:.4f}\")\nprint(f\"泊松回归 RMSE: {poisson_rmse:.4f}\")\n\n# 检查过度离散\nprint(f\"\\n过度离散检查:\")\nprint(f\"数据方差/均值比: {np.var(y)/np.mean(y):.4f}\")\nprint(f\"准泊松估计的离散参数: {quasi_poisson_reg.dispersion:.4f}\")\nprint(f\"离散参数 &gt; 1 表示存在过度离散: {quasi_poisson_reg.dispersion &gt; 1}\")\n\n## 运行结果：\n'''\n模型性能指标:\n均方误差 (MSE): 0.8350\n平均绝对误差 (MAE): 0.6398\n均方根误差 (RMSE): 0.9138\n\n与泊松回归的比较:\n准泊松回归 MSE: 0.8350\n泊松回归 MSE: 0.8415\n准泊松回归 MAE: 0.6398\n泊松回归 MAE: 0.6515\n准泊松回归 RMSE: 0.9138\n泊松回归 RMSE: 0.9174\n\n过度离散检查:\n数据方差/均值比: 1.6993\n准泊松估计的离散参数: 1.6699\n离散参数 &gt; 1 表示存在过度离散: True\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331559-285192201.png\" /></p>\n<p><strong>准泊松回归模型</strong>的优势体现在以下几个方面：</p>\n<ol>\n<li><strong>解决过度离散问题</strong>：准泊松回归通过引入离散参数φ来处理方差大于均值的过度离散数据。在示例中，方差/均值比远大于1（约为2.35），表明存在明显的过度离散现象。</li>\n<li><strong>标准误校正</strong>：修正了泊松回归中由于过度离散导致的标准误估计过小的问题，从而提高了统计推断（如置信区间和假设检验）的可靠性。</li>\n<li><strong>保持泊松回归的系数</strong>：与泊松回归使用相同的系数估计，但调整了方差估计。这意味着回归系数的解释与泊松回归相同，保持了模型的可解释性。</li>\n<li><strong>简单易用</strong>：相比负二项回归，准泊松回归参数更少，计算更简单。准泊松回归只需要估计一个额外的离散参数，而负二项回归需要估计离散参数r。</li>\n<li><strong>灵活性强</strong>：可以处理任意程度的过度离散，而不限于特定的分布假设。准泊松回归不假设特定的分布族，只是调整方差结构。</li>\n<li><strong>实用性强</strong>：在实际应用中，当数据存在过度离散但又不想使用更复杂的负二项回归时，准泊松是很好的选择。它提供了一个平衡点，既解决了过度离散问题，又保持了模型的简洁性。</li>\n<li><strong>计算效率高</strong>：由于使用与泊松回归相同的系数估计方法，计算复杂度较低，适合处理大规模数据。</li>\n</ol>\n<p>这个示例模拟了交通事故预测的场景，其中道路长度、交通流量和天气状况作为预测变量，完美展示了<strong>准泊松回归</strong>如何处理过度离散的计数型数据，并提供比标准泊松回归更可靠的统计推断。</p>\n<h2 id=\"115-cox-回归-cox-regression\">1.15. Cox 回归 (Cox Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：用于“生存分析”，研究的是“事件发生需要多长时间”，以及哪些因素影响这个时间。</li>\n<li><strong>使用场景</strong>：预测病人确诊后的生存时间、客户流失所需的时间（也就是客户还能留存多久）。</li>\n</ul>\n<p><strong>COX回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># Cox 回归 (Cox Regression)\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\n\n# 导入sksurv库\nfrom sksurv.linear_model import CoxPHSurvivalAnalysis\nfrom sksurv.preprocessing import OneHotEncoder\n\n# 第一步：创建Cox回归的测试数据\n# 模拟医疗数据：患者生存分析\nnp.random.seed(42)\nn_samples = 300\n\n# 生成特征\nage = np.random.normal(60, 15, n_samples)  # 患者年龄\ntreatment = np.random.binomial(1, 0.5, n_samples)  # 是否接受治疗 (0/1)\ngender = np.random.binomial(1, 0.5, n_samples)  # 性别 (0/1)\ncomorbidity = np.random.poisson(1.5, n_samples)  # 并发症数量\n\n# 生成生存时间和事件状态\n# 年龄越大、并发症越多 -&gt; 生存时间越短\n# 接受治疗 -&gt; 生存时间更长\nlinear_combination = (\n    0.05 * age +\n    -0.8 * treatment +\n    0.1 * gender +\n    0.3 * comorbidity\n)\n\n# 基线风险函数效应\nbase_time = np.random.exponential(2, n_samples)\ntime_to_event = base_time * np.exp(-linear_combination)\n\n# 添加一些删失（并非所有患者都会在研究期间发生事件）\ncensoring_time = np.random.uniform(0, np.percentile(time_to_event, 80), n_samples)\nobserved_time = np.minimum(time_to_event, censoring_time)\nevent_occurred = time_to_event &lt;= censoring_time\n\n# 创建DataFrame\ndata = pd.DataFrame({\n    'age': age,\n    'treatment': treatment,\n    'gender': gender,\n    'comorbidity': comorbidity,\n    'time': observed_time,\n    'event': event_occurred\n})\n\n# 第二步：实现Cox回归模型\n# 为sksurv准备数据\nX = data[['age', 'treatment', 'gender', 'comorbidity']].values\ny = np.array(list(zip(data['event'], data['time'])), dtype=[('event', '?'), ('time', '&lt;f8')])\n\n# 分割数据\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# 拟合Cox模型\ncox_model = CoxPHSurvivalAnalysis()\ncox_model.fit(X_train, y_train)\n\n# 获取模型系数\ncox_coef = cox_model.coef_\n\nprint(\"Cox回归模型 (sksurv) - 系数：\")\nfeature_names = ['年龄', '治疗', '性别', '并发症']\nfor i, (name, coef) in enumerate(zip(feature_names, cox_coef)):\n    print(f\"{name}: {coef:.4f}\")\n\n# 在sksurv中，我们可以手动计算风险评分\n# 风险评分是线性预测器的指数，即 exp(X * coef)\nlinear_predictor = X_test @ cox_coef\nrisk_scores = np.exp(linear_predictor)\n\n# 第三步：创建可视化\n# ... 省略 ...\n\n## 运行结果：\n'''\nCox回归模型 (sksurv) - 系数：\n年龄: 0.0585\n治疗: -0.7703\n性别: -0.1919\n并发症: 0.1779\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144332031-1348386260.png\" /></p>\n<p><strong>COX回归模型</strong>的优势</p>\n<ol>\n<li><strong>处理删失数据</strong>：Cox回归适用于右删失数据，适合生存分析。</li>\n<li><strong>无需分布假设</strong>：Cox回归不假设生存时间的具体分布，更灵活。</li>\n<li><strong>比例风险</strong>：假设个体间的风险比恒定，符合许多实际应用。</li>\n<li><strong>系数可解释</strong>：系数直接转换为风险比，易于理解（正系数增加风险，负系数降低风险）。</li>\n<li><strong>多个协变量</strong>：能同时分析多个因素对生存时间的影响。</li>\n<li><strong>广泛应用于医学</strong>：是临床和流行病学研究中的标准方法。</li>\n<li><strong>灵活性</strong>：支持时变协变量及连续和分类预测变量。</li>\n<li><strong>风险评分</strong>：可计算个体风险评分，预测相对风险。</li>\n</ol>\n<h2 id=\"116-tobit-回归-tobit-regression\">1.16. Tobit 回归 (Tobit Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：用于处理“截断”或“审查”数据。比如数据在某个点被切断了（比如收入调查中，高于100万的都记作100万）。</li>\n<li><strong>使用场景</strong>：预测家庭在奢侈品上的支出（很多人是0，数据在0处堆积）、传感器量程限制导致的数据截断。</li>\n</ul>\n<p><strong>Tobit回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># Tobit 回归 (Tobit Regression)\nfrom scipy import stats\nfrom scipy.optimize import minimize\n\n# 生成模拟的截断数据集\nnp.random.seed(42)\n\n# 创建自变量\nn_samples = 500\nX = np.random.normal(0, 1, n_samples)\n# 假设真实关系是 y = 2*X + error，但y被截断在0以下\ntrue_beta = 2.0\ntrue_intercept = 0.5\ntrue_sigma = 1.0\n\n# 生成未截断的真实值\ny_true = true_intercept + true_beta * X + np.random.normal(0, true_sigma, n_samples)\n\n# 设置截断点（例如：低于0的值都记录为0）\nlower_limit = 0\ny_observed = np.where(y_true &lt; lower_limit, lower_limit, y_true)\n\n# 标记被截断的观测值\ncensored_mask = y_observed == lower_limit\n\nprint(f\"生成了{n_samples}个样本\")\nprint(f\"其中{np.sum(censored_mask)}个样本被截断（小于等于{lower_limit}）\")\n\n# 实现Tobit回归模型\nclass TobitRegression:\n    # ... 省略 ...\n\n# 拟合Tobit回归模型\ntobit_model = TobitRegression(lower_limit=lower_limit)\ntobit_model.fit(X, y_observed)\n\nprint(f\"Tobit回归结果:\")\nprint(f\"截距: {tobit_model.intercept:.3f}\")\nprint(f\"系数: {tobit_model.beta:.3f}\")\nprint(f\"标准差: {tobit_model.sigma:.3f}\")\nprint(f\"真实截距: {true_intercept}, 真实系数: {true_beta}, 真实标准差: {true_sigma}\")\n\n# 绘制结果图像\n# ... 省略 ...\n\n# 输出一些统计信息\nprint(\"\\n模型比较:\")\nprint(f\"真实系数: {true_beta:.3f}\")\nprint(f\"Tobit回归系数: {tobit_model.beta:.3f}\")\nprint(f\"OLS回归系数: {ols_coef[1]:.3f}\")\nprint(f\"系数估计偏差 (Tobit): {abs(tobit_model.beta - true_beta):.3f}\")\nprint(f\"系数估计偏差 (OLS): {abs(ols_coef[1] - true_beta):.3f}\")\n\n# 计算均方误差\nmse_tobit = np.mean((y_observed - tobit_model.predict(X)) ** 2)\nmse_ols = np.mean((y_observed - y_ols_pred) ** 2)\nprint(f\"Tobit MSE: {mse_tobit:.3f}\")\nprint(f\"OLS MSE: {mse_ols:.3f}\")\n\n## 运行结果：\n'''\nTobit回归结果:\n截距: 0.518\n系数: 1.932\n标准差: 0.990\n真实截距: 0.5, 真实系数: 2.0, 真实标准差: 1.0\n\n模型比较:\n真实系数: 2.000\nTobit回归系数: 1.932\nOLS回归系数: 1.203\n系数估计偏差 (Tobit): 0.068\n系数估计偏差 (OLS): 0.797\nTobit MSE: 1.623\nOLS MSE: 0.755\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331140-1830279319.png\" /></p>\n<p><strong>Tobit回归模型</strong>的优势主要有：</p>\n<ol>\n<li><strong>处理截断数据</strong>：Tobit回归适用于处理在特定阈值处被截断的数据（如所有小于0的值记录为0）。</li>\n<li><strong>无偏估计</strong>：与普通OLS相比，Tobit回归提供更准确的参数估计，避免了因数据截断导致的偏差。</li>\n<li><strong>统计推断</strong>：基于最大似然估计，Tobit回归支持合理的统计推断，包括标准误和置信区间的计算。</li>\n<li><strong>适用领域</strong>：广泛应用于经济和社会科学中涉及收入、消费支出及生存分析等存在截断或审查情况的研究。</li>\n<li><strong>模型拟合度</strong>：Tobit回归系数更接近真实值，并且通常具有较小的均方误差，表明其对截断数据有更好的适应性。</li>\n</ol>\n<h1 id=\"2-如何选择合适的回归模型\">2. 如何选择合适的回归模型？</h1>\n<p>面对这么多模型，到底该选哪一个？我们可以通过以下几个维度来判断：</p>\n<ol>\n<li><strong>看因变量（Y）长什么样</strong>：\n<ul>\n<li>是<strong>连续数值</strong>（如房价）： 首选 线性回归。</li>\n<li>是<strong>二分类</strong>（如买/不买）： 用 逻辑回归。</li>\n<li>是<strong>计数</strong>（如点击次数）： 用 泊松回归 或 负二项回归。</li>\n<li>是<strong>生存时间</strong>（如存活天数）： 用 Cox回归。</li>\n<li>有<strong>截断</strong>（如上限封顶）： 用 Tobit回归。</li>\n</ul>\n</li>\n<li><strong>看数据是否有问题</strong>：\n<ul>\n<li><strong>异常值很多</strong>： 考虑 分位数回归 或 Huber回归（鲁棒回归）。</li>\n<li><strong>特征非线性</strong>： 尝试 多项式回归 或 SVR。</li>\n<li><strong>特征数 &gt; 样本数</strong>，或特征<strong>严重共线性</strong>： 必须上正则化手段，用 岭回归、Lasso、ElasticNet，或者降维类的 PCR/PLS。</li>\n</ul>\n</li>\n<li><strong>看模型目的</strong>：\n<ul>\n<li>为了<strong>解释现象</strong>： 简单的线性/逻辑回归最好解释。</li>\n<li>为了<strong>精准预测</strong>： SVR、甚至更复杂的机器学习模型（如XGBoost等，虽不在此列但常被比较）可能更好。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"3-总结\">3. 总结</h1>\n<p>没有最好的模型，只有最适合数据的模型。</p>\n<p>对于初学者，先画图看数据分布，然后从最简单的线性回归开始尝试，发现问题（如拟合不好、过拟合）后再逐步尝试更复杂的变体，是最好的学习路径。</p>\n<p>为了方便大家尝试各种回归模型，文中各个示例中的数据都是模拟的，不需要另外下载和爬取。</p>\n<p>了解和掌握各种回归模型没有捷径，最好的方式就是把文中代码都实际运行一次，改改数据和训练参数，再反复运行体会下效果。</p>\n<p>完整的代码：<a href=\"https://url11.ctfile.com/f/45455611-8586706866-edb36d?p=6872\" rel=\"noopener nofollow\" target=\"_blank\">16种回归分析总结.ipynb</a> (访问密码: 6872)</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 14:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">16</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "让 AI 分析我 3 年前写的代码，全是漏洞！",
      "link": "https://www.cnblogs.com/yupi/p/19420512",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19420512\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 11:48\">\n    <span>让 AI 分析我 3 年前写的代码，全是漏洞！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"让 AI 分析我 3 年前写的代码，全是漏洞！\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202512/2225420-20251230112305334-1414820438.png\" />\n        对于个人开发者来说，这类工具可以帮你在提交代码前发现潜在问题，拿来检测一下自己之前的老项目代码也是不错的；对于团队来说，可以把 AI 接入到 CI/CD 流程中，自动化代码安全检查。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-heading\"><span class=\"md-plain\">大家好，俺是程序员鱼皮。最近逛 GitHub 的时候，发现了一个挺有潜力的开源项目 —— DeepAudit，让 AI 帮你挖掘项目漏洞。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">势头很猛啊，短短时间就涨了不少 star，看这 star 趋势图：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这是一个 AI 代码审计工具，能自动分析你的代码，找出潜在的安全漏洞和代码问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">作者很贴心地提供了在线体验版，可以直接使用，当然也支持本地部署。下面鱼皮以作者部署的在线体验版，带大家体验一下这个项目的功能。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先需要配置自己的大模型 API Key，国内的很多大模型都支持：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果想直接导入并分析你在 GitHub 上的项目，而不是手动上传代码，那么还需要配置 GitHub Token，让工具能够读取到你的仓库代码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可以在 GitHub 上生成一个新的 Token：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">配置好之后，就可以创建一个要分析的项目了，仓库地址要填写正确。这里鱼皮拿自己 3 年前做的个人开源项目 —— SQL 代码和数据生成器试试水。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img alt=\"创建新项目\" class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后新建一个审计任务：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">填写要分析的分支，还可以设置一些文件排除规则，比如排除 <span class=\"md-pair-s\"><code>node_modules</code><span class=\"md-plain\">、测试文件等。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">点击开始分析，AI 就屁颠儿屁颠儿干活了~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我去，竟然发现了 123 个问题？！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过能写出 123 个问题，我感觉自己也是挺厉害的哈哈哈。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">进入任务详情页面，我倒要看看都是什么问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先看看最严重的 —— SQL 注入漏洞。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 的解释还挺到位的，确实存在 SQL 注入风险。当时这么写纯属图方便，没想到被 AI 一眼看穿了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">一些小细节也被指出来了，比如硬编码、异常处理不够完善、日志记录不规范等。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过也有一些误报，AI 把正常的代码逻辑判断成了问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">总体来说，这个工具还有进步空间，但已经很实用了。正好我们团队需要这样的代码审计工具，还是挺期待作者能进一步完善的。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">审计完成后，还可以直接导出报告：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">一下子就得到了整整 70 多页的专业报告！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">想想我大学的时候做课设作业，要是有 AI 帮忙生成这种报告，不得爽飞边子了？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了项目审计，作者还提供了即时分析功能。不过这个就没什么新意了，我们团队的 <span class=\"md-meta-i-c  md-link\"><a href=\"https://codecopy.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">代码小抄</span></a><span class=\"md-plain\">在 24 年初就已经上线了这个功能。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我体验这个项目的时候，还有很多功能没做完，不过这也是 MVP 最小可行产品原则嘛，快速验证想法最重要。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">值得一提的是，作者更新非常频繁。截止到目前，项目界面已经焕然一新了，更有极客范儿。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在审计流日志页面可以看到 AI 思考分析的过程：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还有智能仪表盘，可以直观地看到代码质量趋势：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">最后</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个项目的实现思路其实挺值得学习的。通过调用大模型的 API，让 AI 理解代码逻辑，然后根据常见的安全漏洞模式和最佳实践进行分析，最后生成结构化的审计报告。整个流程和 AI 代码审查是类似的，但更专注于安全漏洞的发现。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img alt=\"DeepAudit 架构图\" class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对于个人开发者来说，这类工具可以帮你在提交代码前发现潜在问题，拿来检测一下自己之前的老项目代码也是不错的；对于团队来说，可以把 AI 接入到 CI/CD 流程中，自动化代码安全检查。虽然本项目暂时还有误报，但随着 AI 能力的提升，以及作者在领域知识方面的填充，相信会越来越准确。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">来试试看，你的项目代码里有多少个 Bug？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-meta-i-c md-link md-expand\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 11:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">472</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}