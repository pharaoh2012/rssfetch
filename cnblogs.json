{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "LaTeX学习笔记：开场白与索引",
      "link": "https://www.cnblogs.com/owlman/p/19404057",
      "published": "",
      "description": "<h2 class=\"post-title\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/owlman/p/19404057\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 11:59\">\n    <span>LaTeX学习笔记：开场白与索引</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"开场白\">开场白</h2>\n<p>从这里开始，我将会陆续记录自己在学习 <span class=\"math inline\">\\(\\LaTeX\\)</span> 语言过程中所累积的心得体会，目的是帮助自己和读者更好地掌握基于这门语言（及排版系统）的学术写作技巧。下面，让我们先来简单了解一下 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的前世今生。</p>\n<h3 id=\"latex-的前世今生\">LaTeX 的前世今生</h3>\n<p>事情得先从 <span class=\"math inline\">\\(\\TeX\\)</span> 说起，众所周知，<span class=\"math inline\">\\(\\TeX\\)</span> 是美国著名的计算机教授高德纳（Donald Ervin Knuth）<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\" rel=\"noopener nofollow\">[1]</a></sup>为撰写其伟大著作《计算机程序设计艺术》专门开发的一套排版系统语言。由于《计算机程序设计艺术》是一部讨论计算机算法的鸿篇巨作，其中涉及了大量的数学问题，所以为其开发的排版系统自然就在编辑复杂的数学公式方面具备了与生俱来的优势，这种先天优势使得它在数学、物理学和计算机科学等与数学表述密切相关的学术领域中非常流行，甚至很多人学习 <span class=\"math inline\">\\(\\TeX\\)</span> 就是为了使用它在数学领域中的强大表述能力。</p>\n<p>但 <span class=\"math inline\">\\(\\TeX\\)</span> 的功能过于强大，它会要求我们在排版过程中精确描述到每一个细节，有时甚至是一个字母或标点也要照顾到。这对于大多数人来说，可能就学习成本太高，并且用起来太过繁琐和费时了。于是在上个世纪八十年代，美国计算机科学家莱斯利·兰伯特（Leslie Lamport）<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\" rel=\"noopener nofollow\">[2]</a></sup>在 <span class=\"math inline\">\\(\\TeX\\)</span> 的基础上开发出了 <span class=\"math inline\">\\(\\LaTeX\\)</span> 这个新的排版系统（截至 2025 年，<span class=\"math inline\">\\(\\LaTeX2e\\)</span> 目前仍为主流版本，但官方已在逐步过渡到 <span class=\"math inline\">\\(LaTeX3\\)</span>）。从本质上来说，该排版系统其实就是一组封装了 <span class=\"math inline\">\\(\\TeX\\)</span> 处理细节的宏，它可以让那些不了解排版和程序设计相关知识的人们也能使用 <span class=\"math inline\">\\(\\TeX\\)</span> 所提供的强大功能，并在几天甚至几个小时之内就能排版出具有专业质感的印刷品，而不必深陷于琐碎的排版细节中。</p>\n<p>在中文支持方面，现代 LaTeX 通常使用 XeTeX 或 LuaTeX 排版引擎。二者都支持 UTF-8 编码和系统字体，其中 XeTeX 在中文社区中应用更广，该引擎支持 UTF-8 编码和现代字体，可以直接使用本地计算机中安装的字体，这大大降低了 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的使用难度。</p>\n<h3 id=\"为什么要学习-latex\">为什么要学习 LaTeX？</h3>\n<p>或许很多人都会问：在已经有那么多所见即所得（WYSIWYG）的文档编辑器（例如 Microsoft Word、WPS Office）的今天，我们为什么还要学习这种看起来古老又复杂的排版工具呢？在我个人看来，这个问题的答案不仅关乎写作工具的选择，更反映出我们对“学术写作”这一工作的理解。就我个人而言，选择学习 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的原因主要如下：</p>\n<ul>\n<li>\n<p><strong>可专注于写作的结构化思维</strong>。与传统的文档编辑器不同，<span class=\"math inline\">\\(\\LaTeX\\)</span> 并不要求我们在写作的同时关心每个段落、字体、间距的具体样式，而是让我们先将注意力放在文档的内容及其逻辑结构（即标题、摘要、公式、图表、参考文献等）上，然后再通过命令和标记告诉它这些内容“是什么”，而不是“看起来像什么”。这种写作方式与程序员使用编程语言时的思维是相通的：可以很好地实现内容与形式的分离，表达与排版的解耦。这意味着，一旦文档结构清晰，格式就可以自动保持统一与专业。</p>\n</li>\n<li>\n<p><strong>这是在学习一种项目管理思维</strong>。当我们使用它写作时，我们不只是“编辑文字”，而是在构建一个可复现、可维护、可自动生成的文本系统系统。它让学术写作拥有了版本控制、可移植性与长期可读性——这正是科学研究所追求的严谨与可验证性。对于科研工作者来说，<span class=\"math inline\">\\(\\LaTeX\\)</span> 不仅是一种工具，更是一种思维方式：一旦掌握，你会发现它带来的不仅是排版的优雅，更是思考方式的变化。</p>\n</li>\n<li>\n<p><strong>学术界公认的排版标准</strong>。世界上绝大多数顶级学术期刊与会议模板都是基于 <span class=\"math inline\">\\(\\LaTeX\\)</span> 实现的，从《Nature》《IEEE Transactions》到 ACM、Springer 的论文集，几乎无一例外。它在数学公式、交叉引用、自动编号、参考文献管理等方面的表现，至今没有任何图形化编辑器能够完全替代。特别是在数学、物理、计算机科学、工程学等领域，<span class=\"math inline\">\\(\\LaTeX\\)</span> 已经成为一种“默认语言”。随着国内外高校和出版社对 <span class=\"math inline\">\\(\\LaTeX\\)</span> 支持的日益完善，越来越多的中文论文、学位论文模板、科研报告乃至书籍排版都已经提供了相应的 <span class=\"math inline\">\\(\\LaTeX\\)</span> 模板。对于想要从事学术研究、技术写作、教材编辑或科研出版的人而言，掌握 <span class=\"math inline\">\\(\\LaTeX\\)</span> 不仅是技能，更是一种职业素养的体现。</p>\n</li>\n</ul>\n<p>或许还会有人问，那么 <span class=\"math inline\">\\(\\LaTeX\\)</span> 和我们日常写博客与技术文档的 Markdown 有什么区别呢？其实，其中的区别就在于“日常”与“学术”，Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 页面。Markdown 的语法简单，易于上手，非常适合快速编写和分享文档。然而，Markdown 并不能像 <span class=\"math inline\">\\(\\LaTeX\\)</span> 那样处理复杂的数学公式，也不能像 LaTeX 那样生成高质量的 PDF 文档。因此，如果我们需要进行更为专业的学术写作，特别是涉及到数学公式和参考文献管理时，<span class=\"math inline\">\\(\\LaTeX\\)</span> 是一个更好的选择。</p>\n<p>总之，学习 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的过程，既是掌握一种排版工具的过程，也是训练逻辑表达与抽象思维的过程。它让我们在文字的世界中，以科学的方式组织思想，以优雅的方式表达知识。</p>\n<h2 id=\"笔记索引\">笔记索引</h2>\n<p>这一系列的笔记的内容将包括介绍它的前世今生，基本使用方式，以及在数学公式编辑、专业文献排版等方面的具体应用。下面是这一系列笔记的索引：</p>\n<ul>\n<li>[[LaTeX学习笔记：快速上手指南]]：<a href=\"https://www.cnblogs.com/owlman/p/19202175\" target=\"_blank\">博客园链接</a>；</li>\n<li>[[LaTeX学习笔记：文档排版基础]]：<a href=\"https://www.cnblogs.com/owlman/p/19256216\" target=\"_blank\">博客园链接</a>；</li>\n<li>[[LaTeX学习笔记：数学公式编辑]]：<a href=\"https://www.cnblogs.com/owlman/p/19199330\" target=\"_blank\">博客园链接</a>；</li>\n<li>[[LaTeX学习笔记：学术文档排版]]：<a href=\"https://www.cnblogs.com/owlman/p/19348573\" target=\"_blank\">博客园链接</a>；</li>\n</ul>\n<p>除我的个人博客之外，上述笔记将陆续更新在我于 github 上的<a href=\"https://github.com/owlman/CS_StudyNotes\" rel=\"noopener nofollow\" target=\"_blank\">计算机学习笔记库</a>中，并予以长期维护，欢迎读者随时参考。</p>\n<h2 id=\"学习资源\">学习资源</h2>\n<ul>\n<li>参考书籍：\n<ul>\n<li><a href=\"https://book.douban.com/subject/24703731/\" rel=\"noopener nofollow\" target=\"_blank\">《LaTeX 入门》</a>：作者是刘海洋，电子工业出版社于2013年出版，适合初学入门。</li>\n<li><a href=\"https://book.douban.com/subject/1418351/\" rel=\"noopener nofollow\" target=\"_blank\">《The TeXbook》</a>：作者是高德纳本人，系 <span class=\"math inline\">\\(\\TeX\\)</span> 领域最权威的参考书籍。这虽并不是 <span class=\"math inline\">\\(\\LaTeX\\)</span> 直接相关的教材，但如果想更好地理解 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的工作原理，以及掌握其底层的排版机制，回头去读一下这本书，系统性地学习一下 <span class=\"math inline\">\\(\\TeX\\)</span> 是一个非常好的选择。</li>\n</ul>\n</li>\n<li>网络资源：\n<ul>\n<li><a href=\"https://www.latex-project.org/\" rel=\"noopener nofollow\" target=\"_blank\">LaTeX 官方网站</a>：官方文档和教程。</li>\n<li><a href=\"http://www.ctex.org/\" rel=\"noopener nofollow\" target=\"_blank\">CTeX 官方网站</a>：中文 <span class=\"math inline\">\\(\\LaTeX\\)</span> 社区，提供中文文档和教程。</li>\n<li><a href=\"https://www.tug.org/texlive/\" rel=\"noopener nofollow\" target=\"_blank\">TeX Live 官方网站</a>：最完整的跨平台 <span class=\"math inline\">\\(\\TeX\\)</span> 发行版，包含 LaTeX、XeTeX、LuaTeX 等编译器与宏包集合。</li>\n<li><a href=\"https://www.overleaf.com/\" rel=\"noopener nofollow\" target=\"_blank\">Overleaf</a>：在线的 <span class=\"math inline\">\\(\\LaTeX\\)</span> 编辑器，支持实时预览和协作编辑。</li>\n<li><a href=\"https://www.ctan.org/\" rel=\"noopener nofollow\" target=\"_blank\">CTAN</a>：<span class=\"math inline\">\\(\\LaTeX\\)</span> 的官方包仓库，提供了大量的宏包和模板。</li>\n<li><a href=\"https://en.wikibooks.org/wiki/LaTeX\" rel=\"noopener nofollow\" target=\"_blank\">LaTeX wikibook</a>：一个详细的 <span class=\"math inline\">\\(\\LaTeX\\)</span> 学习指南，适合初学者。</li>\n</ul>\n</li>\n</ul>\n\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li class=\"footnote-item\" id=\"fn1\"><p>高德纳教授是现代计算机科学的先驱人物，他创立了算法分析理论，并在数个计算机理论分支上都做出了犹如基石一般的贡献，于1974年荣获图灵奖。 <a class=\"footnote-backref\" href=\"#fnref1\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n<li class=\"footnote-item\" id=\"fn2\"><p>莱斯利·兰伯特是来自纽约的一位计算机科学家，LaTeX排版系统的开发者，2013年荣获图灵奖。 <a class=\"footnote-backref\" href=\"#fnref2\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n</ol>\n</section>\n\n</div>\n<div class=\"clear\"></div>\n\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2025-12-26 11:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/owlman\">凌杰</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "【面试题】MySQL B+树索引高度计算",
      "link": "https://www.cnblogs.com/sun-10387834/p/19381299",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19381299\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 11:53\">\n    <span>【面试题】MySQL B+树索引高度计算</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"mysql-b树索引高度计算与性能阈值探讨\">MySQL B+树索引高度计算与性能阈值探讨</h1>\n<h3 id=\"一mysql-b树索引高度计算\">一、MySQL B+树索引高度计算</h3>\n<p>MySQL中InnoDB的主键索引采用B+树结构，索引高度（树的层数）决定了查询时磁盘IO的次数（高度=IO次数），核心计算逻辑围绕<strong>B+树的节点容量</strong>和<strong>数据行数</strong>展开。</p>\n<h4 id=\"1-核心前提innodb默认配置\">1. 核心前提（InnoDB默认配置）</h4>\n<ul>\n<li>\n<p><strong>页大小</strong>：默认16KB（16384字节），B+树的每个节点对应一个InnoDB页。</p>\n</li>\n<li>\n<p><strong>主键类型</strong>：影响索引项大小（如INT=4字节，BIGINT=8字节，VARCHAR(32)=32+2字节）。</p>\n</li>\n<li>\n<p><strong>指针大小</strong>：InnoDB中页指针固定为6字节（指向子节点页的地址）。</p>\n</li>\n<li>\n<p><strong>B+树结构</strong>：</p>\n<ul>\n<li>\n<p>非叶子节点：仅存储「主键值 + 页指针」，按主键排序，无数据行；</p>\n</li>\n<li>\n<p>叶子节点：存储「完整主键 + 行数据（或行数据指针）」，且叶子节点通过双向链表连接。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-计算步骤\">2. 计算步骤</h4>\n<h5 id=\"步骤1计算非叶子节点的单页容量能存多少个索引项\">步骤1：计算非叶子节点的单页容量（能存多少个索引项）</h5>\n<p>非叶子节点的索引项大小 = 主键字节数 + 指针字节数</p>\n<p>单页可存储索引项数 = 页大小 / 索引项大小（向下取整，需预留少量空间给页头/页尾，实际按90%可用计算）</p>\n<p><strong>示例</strong>：主键为INT（4字节），指针6字节 → 索引项=10字节</p>\n<p>单页可用空间≈16384 * 90% = 14745字节</p>\n<p>单页索引项数≈14745 / 10 ≈ 1474个</p>\n<h5 id=\"步骤2计算叶子节点的单页容量能存多少行数据\">步骤2：计算叶子节点的单页容量（能存多少行数据）</h5>\n<p>叶子节点行大小 = 主键字节数 + 其他列总字节数（或行指针大小，InnoDB聚簇索引直接存数据）</p>\n<p>单页可存储行数 = 页大小 / 行大小（向下取整，同样预留页结构空间）</p>\n<p><strong>示例</strong>：主键INT（4字节），行数据总大小≈100字节 → 单行大小≈104字节</p>\n<p>单页行数≈14745 / 104 ≈ 141行</p>\n<h5 id=\"步骤3计算b树高度对应的总数据量\">步骤3：计算B+树高度对应的总数据量</h5>\n<p>B+树是多叉树，高度h的总数据量公式：</p>\n<p><code>总行数 = 非叶子节点分支数^(h-1) * 叶子节点单页行数</code></p>\n<ul>\n<li>\n<p>高度1：仅根节点（叶子节点）→ 行数≈141行</p>\n</li>\n<li>\n<p>高度2：根节点（非叶子）+ 叶子节点 → 1474 * 141 ≈ 20.8万行</p>\n</li>\n<li>\n<p>高度3：根→中间节点→叶子 → 1474 * 1474 * 141 ≈ 3060万行</p>\n</li>\n<li>\n<p>高度4：1474³ * 141 ≈ 45亿行</p>\n</li>\n</ul>\n<h4 id=\"3-实际验证方式\">3. 实际验证方式</h4>\n<p>可通过InnoDB的系统表查询索引高度：</p>\n<pre><code class=\"language-SQL\">-- 查询表的主键索引高度（TABLE_ID需先查）\nSELECT \n  b.name AS index_name,\n  a.HEIGHT AS index_height\nFROM \n  information_schema.INNODB_SYS_INDEXES a\nJOIN \n  information_schema.INNODB_SYS_TABLES b ON a.TABLE_ID = b.TABLE_ID\nWHERE \n  b.NAME = '数据库名/表名' -- 如test/user\n  AND a.NAME = 'PRIMARY'; -- 主键索引\n</code></pre>\n<ul>\n<li>生产环境中，99%的表索引高度为3（少量小表为2），高度4极少（超亿级数据才会出现）。</li>\n</ul>\n<h3 id=\"二mysql单表不影响性能的最大记录数\">二、MySQL单表不影响性能的最大记录数</h3>\n<p><strong>结论先行</strong>：没有绝对数值，但业界通用经验是「千万级（1000万~1亿行）」，核心影响因素不是行数，而是<strong>索引高度、数据页缓存命中率、磁盘IO能力</strong>。</p>\n<h4 id=\"1-性能阈值的核心逻辑\">1. 性能阈值的核心逻辑</h4>\n<ul>\n<li>\n<p>索引高度≤3时：查询只需2~3次磁盘IO（根节点、中间节点常驻内存），性能基本无衰减；</p>\n</li>\n<li>\n<p>索引高度=4时：需4次IO，且中间节点可能无法全部缓存，性能开始明显下降；</p>\n</li>\n<li>\n<p>数据页缓存命中率：InnoDB缓冲池能缓存的热数据页越多，性能越好（千万级数据的热页基本可全缓存，亿级后缓存命中率骤降）。</p>\n</li>\n</ul>\n<h4 id=\"2-不同场景的阈值参考\">2. 不同场景的阈值参考</h4>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>场景</td>\n<td>不影响性能的最大行数</td>\n<td>核心限制因素</td>\n</tr>\n<tr>\n<td>主键查询+热数据</td>\n<td>1亿行</td>\n<td>缓冲池大小（≥32GB）</td>\n</tr>\n<tr>\n<td>普通索引查询+分页</td>\n<td>1000万行</td>\n<td>索引回表IO、分页排序开销</td>\n</tr>\n<tr>\n<td>频繁更新+多索引</td>\n<td>500万行</td>\n<td>索引维护开销、锁竞争</td>\n</tr>\n<tr>\n<td>机械硬盘（HDD）</td>\n<td>500万行</td>\n<td>随机IO速度慢（≈100 IOPS）</td>\n</tr>\n<tr>\n<td>固态硬盘（SSD）</td>\n<td>1亿行</td>\n<td>随机IO速度快（≈10万 IOPS）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-突破阈值的优化方案\">3. 突破阈值的优化方案</h4>\n<p>若数据量超阈值，需通过架构优化而非单表优化：</p>\n<ul>\n<li>\n<p>分库分表：水平分表（按主键哈希/范围），使单表行数回到千万级以内；</p>\n</li>\n<li>\n<p>冷热数据分离：将冷数据归档到只读库，热数据保留在主库；</p>\n</li>\n<li>\n<p>索引优化：减少冗余索引，使用覆盖索引避免回表，优化查询语句（如避免SELECT *）；</p>\n</li>\n<li>\n<p>硬件升级：SSD替代HDD，增大缓冲池（innodb_buffer_pool_size=物理内存的50%~70%）。</p>\n</li>\n</ul>\n<h3 id=\"三总结\">三、总结</h3>\n<ol>\n<li>\n<p>B+树索引高度计算：核心是「非叶子节点单页分支数^高度-1 × 叶子节点单页行数」，生产环境中高度基本为2~3；</p>\n</li>\n<li>\n<p>单表性能阈值：千万级（1000万~1亿）是通用的无性能衰减阈值，核心看索引高度和IO能力，而非绝对行数；</p>\n</li>\n<li>\n<p>性能优化的核心：保持索引高度≤3，提升缓冲池缓存命中率，超阈值后优先分库分表。</p>\n</li>\n</ol>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19381299\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19381299</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 11:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "专注之道，先立根基而后致远",
      "link": "https://www.cnblogs.com/spindrift/p/19403971",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/spindrift/p/19403971\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 11:46\">\n    <span>专注之道，先立根基而后致远</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#本文提要\" rel=\"noopener nofollow\">本文提要</a></li><li><a href=\"#正文\" rel=\"noopener nofollow\">正文</a></li><li><a href=\"#我的专注实操\" rel=\"noopener nofollow\">我的专注实操</a></li></ul></div><p></p>\n<h2 id=\"本文提要\">本文提要</h2>\n<p><img alt=\"专注.png\" src=\"https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/43484f54045e4f24a4d5967cb3d0bcf5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iux5Ye76ZW_56m6:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjk2Njk0MDY1Njg3ODQ0OCJ9&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1766806034&amp;x-orig-sign=JZjc%2FN80xAYY7rS8QCPjDpmmvDY%3D\" /></p>\n<h2 id=\"正文\">正文</h2>\n<p>很多人都将“心无旁骛，万事可成”奉为准则，把专注完全归因于愿力的驱动，认为仅凭一腔热忱就能凝神聚力、一往无前。但我认为，这种观点不够全面，甚至带有些许“鸡汤式”的静态思维。专注从来不是孤注一掷的偏执，更不是脱离现实的空想，它需要以人生定位为罗盘，以自我准备为基石，以取舍有度为尺度，在周全规划的土壤中才能生根发芽、茁壮成长。脱离根基的专注，就像无源之水、无本之木，终究难以长久。</p>\n<p>专注之先，在于明定位、知取舍。人生如四季流转，各阶段自有其核心使命：求学阶段当潜心笃志，夯实知识根基；青年时期可勇闯事业，拓展人生边界；暮年之后宜颐养身心，沉淀岁月智慧。若混淆阶段使命，妄图“一生只做一件事”，便难免陷入失衡的困境——就像有人在求学时执意深耕副业，终致学业荒废；有人退休后仍强行追赶事业高峰，徒增身心负担。正如春耕时强要秋收，寒冬时硬要播种，违背规律的专注，只会徒劳无功。更需明晓，人生目标从来不是单选题，而是多选题的精准取舍。依循二八定律，辨清核心目标与次要目标：关乎立身之本的目标需全力以赴，无关紧要的琐事做到及格即可，长远规划类的目标可暂缓搁置。诸如健身这类目标不可能一蹴而就，需循序渐进；而给孩子取名这类急事，虽耗时短却需优先完成。唯有找准当下定位，厘清职责边界，在可选目标中锚定优先级，方能让专注有的放矢，避免在多元需求中迷失方向。</p>\n<p>专注的根基，在于提升自我、补足短板。常言道“工欲善其事，必先利其器”，专注的成效，从来不只取决于愿力的强弱，更依赖自身的综合素养。如果没有恒心和毅力，即便有片刻的专注，也会在挫折与负面反馈面前半途而废；如果没有自控力，再清晰的目标也会被惰性与诱惑侵蚀；如果没有健康的体魄和强大的心理承受力，高强度的专注只会透支身心。这就要求我们提前做好准备、补足短板：想要深耕事业，可建立家务标准化流程提升效率，节省时间成本；想要直面职场挑战，可学习心理学知识，锤炼抗压抗挫能力；想要高效推进目标，需要掌握番茄工作法、四象限法则等时间管理技巧，学会科学的学习方法。同时，更要认清自我、顺应时代：明确自己的天赋禀赋、兴趣所在与意志边界——知道自己适合深耕细作而非闯荡开拓，明白自己擅长沉稳笃行而非急功近利；既要了解时代发展趋势，避免在过时的方向上盲目专注，也要接纳自身局限，有些特质难以强行改变，这也是人们常说的“一命二运三风水”中所蕴含的对客观现实的敬畏。这种“认清自己、了解时代”的清醒，才能让专注避开盲目，贴合本心与时代大势。</p>\n<p>专注的尺度，在于顺应时势、灵活调整。人们常说“穷则变，变则通，通则久”，专注绝不是一成不变的执念，而是需要具备灵活调整的应变能力。我们无法一辈子只专注于一件事，但可以在某一阶段、某一段时间内，对核心目标保持极致专注——这不是“一条腿走路”的失衡，而是“阶段聚焦”的智慧。就像在海上航行，既要锚定航向，也要根据风浪调整船舵；又像耕耘田地，既要专注劳作，也要顺应节气更换作物。脱离时代大势的专注，容易陷入“闭门造车”的困境，比如在数字化时代还固执地专注于传统手工作坊的低效生产；缺乏调整空间的专注，最终会变得像“刻舟求剑”那样僵化，比如年轻时没实现的舞蹈梦想，到八十岁再强行专注修习，虽有情怀却失去了应有的价值。只有兼顾时代需求与自身境遇，以目标为导向而非事件为导向，在坚守核心的同时预留调整空间，让专注与现实同频共振，才能在变化中站稳脚跟，在坚守中稳步前行、走得更远。</p>\n<p>人们常用木桶比喻人生，说能装多少水，取决于最短的那块木板。专注也是如此，它从来不是一种孤立的能力，而是由定位、取舍、自我提升、应变等诸多要素共同支撑的系统工程。没有定位的专注，是盲目的消耗；没有准备的专注，是徒劳的挣扎；没有弹性的专注，是僵化的执念。就像有人空有专注的愿力，却因为没理清人生阶段的职责、没补足自控力的短板，最终在繁杂事务与挫折中半途而废——这恰好印证了“任何一个环节脱节，整件事就可能失败”的道理。</p>\n<p>对我们来说，专注从来不是“两耳不闻窗外事”的孤僻，而是“胸有丘壑、眼底有光”的清醒。先明确定位以找准方向，理清当下阶段的核心职责；再提升自我以筑牢根基，补足能力短板、认清自我与时代；后顺应时势以灵活调整，合理把控专注的范围与节奏。如此，才能让专注真正成为披荆斩棘的利刃，在人生的征途上，走出一条既踏实沉稳、又开阔明亮的道路。这，便是专注的真谛，也是成长的正途。</p>\n<h2 id=\"我的专注实操\">我的专注实操</h2>\n<p><img alt=\"image.png\" src=\"https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/9a426cfe8194453caa80293be3ebf289~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iux5Ye76ZW_56m6:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjk2Njk0MDY1Njg3ODQ0OCJ9&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1766806201&amp;x-orig-sign=cLz2ue%2BOWprv7AG72%2FpBwS4Yo1E%3D\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 11:46</span>&nbsp;\n<a href=\"https://www.cnblogs.com/spindrift\">英击长空</a>&nbsp;\n阅读(<span id=\"post_view_count\">9</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "采样保持电路分析[原创www.cnblogs.com/helesheng]",
      "link": "https://www.cnblogs.com/helesheng/p/19401651",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/helesheng/p/19401651\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 11:34\">\n    <span>采样保持电路分析[原创www.cnblogs.com/helesheng]</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"采样保持电路分析[原创www.cnblogs.com/helesheng]\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1380455/202512/1380455-20251226112546839-978054094.png\" />\n        介绍了模数转换的采样保持电路（S/H）的原理，以精度改善为目的的全局反馈的设计，和以防止饱和为目的的钳位设计。最后分析了上述钳位设计不会造成精度损失的原因。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>上《数字电路》这门课的时候，学生问模数转换器（ADC）一章中的采样保持电路（本文图3电路）为什么要加钳位二极管VD1和VD2，我习惯性的随口回答：为了在保持阶段第一个运放的输出不会太大，也不会太小。回到办公室仔细想了一下，不禁反问自己国家半导体的经典电路LF398究竟为什么要设计这两个二极管，为什么不实用最直接的两个局部负反馈结构（如本文图1）。请教了同事、同学发现还是有很多值得分享记录的地方，现总结如下。以下原创内容欢迎网友转载，但请注明出处：<a href=\"https://www.cnblogs.com/helesheng\" target=\"_blank\">https://www.cnblogs.com/helesheng</a></p>\n<h1 id=\"1采样保持电路原型\">1、采样保持电路原型</h1>\n<p>示意图如1所示：运放A1、A2构成电压跟随器，两个跟随器分别用于实现“输入到采样保持电容<span class=\"math inline\">\\(C_h\\)</span>的阻抗变换”，以及“<span class=\"math inline\">\\(C_h\\)</span>到输出<span class=\"math inline\">\\(u_o\\)</span>的阻抗变换”。其中开关S是由MOS管构成的模拟开关，它导通的时候，实现<span class=\"math inline\">\\(C_h\\)</span>电压采样；关断时实现<span class=\"math inline\">\\(C_h\\)</span>电压保持。</p>\n<center>\n    <img src=\"https://img2024.cnblogs.com/blog/1380455/202512/1380455-20251226000627253-1066875295.jpg\" width=\"600\" />\n</center>\n<center>\n图1 采样保持电路原型\n</center>\n<p>这个电路的缺点是S处的开关MOS管关断的瞬间，其栅极G电压突变，栅极和源极之间的寄生电容<span class=\"math inline\">\\(C_{GS}\\)</span>上的电压差不能突变，从而导致<span class=\"math inline\">\\(U_{P2}\\)</span>处的保持电压被<span class=\"math inline\">\\(C_{GS}\\)</span>拉低，降低了保持精度和开关切换时间。</p>\n<h2 id=\"2采样保持电路改进1\">2、采样保持电路改进1</h2>\n<p>为了改善这个问题，将图1中A1构成的局部负反馈变为全局反馈，以通过A1的增益改善控制精度。得到图2所示的电路，其中<span class=\"math inline\">\\(R_{DS}\\)</span>是栅极寄生电容<span class=\"math inline\">\\(C_{GS}\\)</span>上的电荷完全释放完毕之前，S处于半导通状态下S的漏源之间的等效电阻。</p>\n<center>\n    <img src=\"https://img2024.cnblogs.com/blog/1380455/202512/1380455-20251226000646371-590667438.jpg\" width=\"600\" />\n</center>\n<center>\n图2 采样保持电路改进1\n</center>\n<p>图2具体分析：G端突然出现下跳，拉着A2的同相输入端也变低，从而导致A2输出变小，进而导致A1反相端输入也降低，A1的输出就会拉高来补偿采样电容<span class=\"math inline\">\\(C_h\\)</span>上的电压损失误差。其中<span class=\"math inline\">\\(C_{GS}\\)</span>只在电压很低时很大，所以当关断程度大，<span class=\"math inline\">\\(R_{DS}\\)</span>大的时候作用就不大了。所以只需要A1的输出电压能够在一个小范围波动，因此只需要A1的输出在很小的范围内波动就可以补偿<span class=\"math inline\">\\(C_h\\)</span>上的电压误差。</p>\n<h2 id=\"3采样保持电路改进2\">3、采样保持电路改进2</h2>\n<p>图2所示改进电路的问题是：当S完全断开后，A1处于完全开环的比较器状态，保持阶段如果输入<span class=\"math inline\">\\(u_i\\)</span>发生变化，会导致A1饱和输出高电平或低电平。S再次闭合采样时A1要从饱和状态回复到负反馈的工作状态一般需要1us左右，这将极大的限制采样保持器的最大工作频率。因此出现了图3所示的，真正实用的采样保持电路LF398。<br />\nVD1和VD2的作用是通过钳位保证A1在保持阶段不会进入饱和状态（实际上是一种非线性负反馈状态），从而提升了采样保持器的工作速度。而VD1和VD2也限制了图2中A1输出的补偿电压摆幅，不过根据上面的分析只需要A1的输出电压能够在一个小范围波动即可实现<span class=\"math inline\">\\(C_{GS}\\)</span>造成的保持电压波动。<br />\n因此，清华阎石老师的《数字电路》教材说这两个二极管通过钳位可以提升采样保持电路的工作速度。<br />\n哈工大杨春玲老师的《数字电路》教材中说VD1和VD2的作用是为了防止A1饱和后造成S两端压差过大，从而烧毁S，我觉得是没有根据的。</p>\n<center>\n    <img src=\"https://img2024.cnblogs.com/blog/1380455/202512/1380455-20251226000652118-1743701733.jpg\" width=\"600\" />\n</center>\n<center>\n图3 采样保持电路改进2(LF398)\n</center>\n<h2 id=\"4含二极管的局部非线性反馈精确性分析\">4、含二极管的局部非线性反馈精确性分析</h2>\n<p>S闭合时，二极管VD1和VD2两端电压相等：<br />\n此时由于A1和A2的虚断，<span class=\"math inline\">\\(U_{N2}、U_{P2}、u_o以及u_o’\\)</span>相等，<span class=\"math inline\">\\(u_i以及U_{NI}\\)</span>相等。如果<span class=\"math inline\">\\(u_o’\\)</span>与二极管上端的<span class=\"math inline\">\\(U_{NI}\\)</span>相差一个Δu（&lt;0.7V），则R1两侧就有电压差Δu，导致有电流流过R1。<br />\n这个电流即没法流入VD1和VD2，也没法流入A1的反相端，因此Δu只能为0。也就是<span class=\"math inline\">\\(u_o’等于u_i\\)</span>。<br />\n反过来描述这个过程：当<span class=\"math inline\">\\(u_o’和u_i\\)</span>有Δu这个差异时，不妨假设Δu&gt;0，<span class=\"math inline\">\\(u_o\\)</span>将等于<span class=\"math inline\">\\(u_o’并大于u_i\\)</span>。此时由于R1上不可能有电流，R1左右两边的电压相同，将使<span class=\"math inline\">\\(U_{NI}等于u_o’并大于u_i\\)</span>，此时运放A1将调整输出到让<span class=\"math inline\">\\(u_o’\\)</span>降低（A1反相输入端大于A2）,直至达到<span class=\"math inline\">\\(u_o’等于u_i\\)</span>，Δu等于0。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 11:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/helesheng\">helesheng</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "使用Java Stream，将集合转换为一对一Map",
      "link": "https://www.cnblogs.com/zwwhnly/p/19403765",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zwwhnly/p/19403765\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 11:23\">\n    <span>使用Java Stream，将集合转换为一对一Map</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2025-12-26 11:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zwwhnly\">申城异乡人</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n            <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Java Stream，Collectors.toMap收集器使用方法。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在日常的开发工作中，我们经常使用到Java Stream，特别是Stream API中提供的<code>Collectors.toList()</code>收集器，</p>\n<p>但有些场景下，我们需要将集合转换为Map，这时候就需要使用到Stream API中提供的另一个收集器：</p>\n<p><code>Collectors.toMap</code>，它可以将流中的元素映射为键值对，并收集到一个Map中。</p>\n<h2 id=\"1-三种主要的重载方法\">1. 三种主要的重载方法</h2>\n<p><code>Collectors.toMap</code>有3种重载方法，分别是：</p>\n<p>1)<strong>两个参数的重载方法（最简单的形式）</strong></p>\n<pre><code class=\"language-java\">public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,\n                                Function&lt;? super T, ? extends U&gt; valueMapper) {\n\treturn toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);\n}\n</code></pre>\n<p>2)<strong>三个参数的重载方法（包含冲突处理）</strong></p>\n<pre><code class=\"language-java\">public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,\n                                Function&lt;? super T, ? extends U&gt; valueMapper,\n                                BinaryOperator&lt;U&gt; mergeFunction) {\n    return toMap(keyMapper, valueMapper, mergeFunction, HashMap::new);\n}\n</code></pre>\n<p>3)<strong>四个参数的重载方法（指定Map实现）</strong></p>\n<pre><code class=\"language-java\">public static &lt;T, K, U, M extends Map&lt;K, U&gt;&gt;\n   Collector&lt;T, ?, M&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,\n                            Function&lt;? super T, ? extends U&gt; valueMapper,\n                            BinaryOperator&lt;U&gt; mergeFunction,\n                            Supplier&lt;M&gt; mapSupplier) {\n    BiConsumer&lt;M, T&gt; accumulator\n            = (map, element) -&gt; map.merge(keyMapper.apply(element),\n                                          valueMapper.apply(element), mergeFunction);\n    return new CollectorImpl&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);\n}\n</code></pre>\n<p>接下来，我们结合使用示例详细讲解。</p>\n<h2 id=\"2-使用示例\">2. 使用示例</h2>\n<h3 id=\"21-将对象的某些属性转换为map\">2.1 将对象的某些属性转换为Map</h3>\n<p>假设有一个城市列表，需要将其转换为Map，其中Key为城市ID、Value为城市名称，转换方法如下所示：</p>\n<pre><code class=\"language-java\">@Getter\n@Setter\npublic class City {\n    private Integer cityId;\n\n    private String cityName;\n\n    public City(Integer cityId, String cityName) {\n        this.cityId = cityId;\n        this.cityName = cityName;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(1, \"北京\"),\n        new City(2, \"上海\"),\n        new City(3, \"广州\"),\n        new City(4, \"深圳\")\n);\nMap&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName));\nSystem.out.println(cityMap);\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p></p>\n</blockquote>\n<h3 id=\"22-将对象列表转换为mapid---对象\">2.2 将对象列表转换为Map（ID -&gt; 对象）</h3>\n<p>仍然使用上面的城市列表，需要将其转换为Map，其中Key为城市ID、Value为城市对象，转换方法如下所示：</p>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(1, \"北京\"),\n        new City(2, \"上海\"),\n        new City(3, \"广州\"),\n        new City(4, \"深圳\")\n);\nMap&lt;Integer, City&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, city -&gt; city));\nCity city = cityMap.get(1);\nSystem.out.println(\"城市ID: \" + city.getCityId());\nSystem.out.println(\"城市名称: \" + city.getCityName());\n</code></pre>\n<p>输出结果如下所示：</p>\n<blockquote>\n<p>城市ID: 1<br />\n城市名称: 北京</p>\n</blockquote>\n<p>上面的写法等价于：</p>\n<pre><code class=\"language-java\">Map&lt;Integer, City&gt; cityMap = cityList.stream()\n    \t.collect(Collectors.toMap(City::getCityId, Function.identity()));\n</code></pre>\n<p>因为<code>Function.identity()</code>内部实现是下面这样的：</p>\n<pre><code class=\"language-java\">static &lt;T&gt; Function&lt;T, T&gt; identity() {\n    return t -&gt; t;\n}\n</code></pre>\n<h3 id=\"23-键冲突处理\">2.3 键冲突处理</h3>\n<p>假设上面的城市列表中有一个ID重复的城市：</p>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(1, \"北京\"),\n        new City(2, \"上海\"),\n        new City(3, \"广州\"),\n        new City(4, \"深圳\"),\n        new City(4, \"天津\")\n);\nMap&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName));\nSystem.out.println(\"城市ID: 4, 城市名称: \" + cityMap.get(4));\n</code></pre>\n<p>此时运行代码，会抛出<code>java.lang.IllegalStateException</code>异常，如下图所示：</p>\n<p><img alt=\"\" src=\"https://images.zwwhnly.com/picture/2025/snipaste_20251225_172725.png\" /></p>\n<p>有3种常见的键冲突处理方式，分别是保留旧值、使用新值和合并值，接下来一一讲解。</p>\n<p>1)方式一：保留旧值</p>\n<pre><code class=\"language-java\">Map&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName, (oldValue, newValue) -&gt; oldValue));\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>城市ID: 4, 城市名称: 深圳</p>\n</blockquote>\n<p>2)方式二：使用新值</p>\n<pre><code class=\"language-java\">Map&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName, (oldValue, newValue) -&gt; newValue));\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>城市ID: 4, 城市名称: 天津</p>\n</blockquote>\n<p>3)方式三：合并值</p>\n<pre><code class=\"language-java\">Map&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName, \n        \t\t(oldValue, newValue) -&gt; oldValue + \", \" + newValue));\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>城市ID: 4, 城市名称: 深圳, 天津</p>\n</blockquote>\n<h3 id=\"24-数据分组聚合\">2.4 数据分组聚合</h3>\n<p>假设有一个销售记录列表，需要将其转换为Map，其中Key为销售员、Value为该销售员的总销售额，转换方法如下所示：</p>\n<pre><code class=\"language-java\">@Getter\n@Setter\npublic class SalesRecord {\n    private String salesPerson;\n\n    private BigDecimal amount;\n\n    public SalesRecord(String salesPerson, BigDecimal amount) {\n        this.salesPerson = salesPerson;\n        this.amount = amount;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">List&lt;SalesRecord&gt; salesRecordList = Arrays.asList(\n        new SalesRecord(\"张三\", new BigDecimal(\"1000\")),\n        new SalesRecord(\"李四\", new BigDecimal(\"2000\")),\n        new SalesRecord(\"张三\", new BigDecimal(\"980\"))\n);\n\nMap&lt;String, BigDecimal&gt; salesRecordMap = salesRecordList.stream()\n        .collect(Collectors.toMap(SalesRecord::getSalesPerson, SalesRecord::getAmount, BigDecimal::add));\nSystem.out.println(salesRecordMap);\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p></p>\n</blockquote>\n<p>上面的例子是销售额累加，也可以只取最小值：</p>\n<pre><code class=\"language-java\">Map&lt;String, BigDecimal&gt; salesRecordMap = salesRecordList.stream()\n        .collect(Collectors.toMap(SalesRecord::getSalesPerson, SalesRecord::getAmount, BigDecimal::min));\n</code></pre>\n<p>此时的输出结果：</p>\n<blockquote>\n<p></p>\n</blockquote>\n<p>或者只取最大值：</p>\n<pre><code class=\"language-java\">Map&lt;String, BigDecimal&gt; salesRecordMap = salesRecordList.stream()\n        .collect(Collectors.toMap(SalesRecord::getSalesPerson, SalesRecord::getAmount, BigDecimal::max));\n</code></pre>\n<p>此时的输出结果：</p>\n<blockquote>\n<p></p>\n</blockquote>\n<h3 id=\"25-指定map实现\">2.5 指定Map实现</h3>\n<p>默认情况下，<code>Collectors.toMap</code>是将结果收集到HashMap中，如果有需要，我们也可以指定成TreeMap或者LinkedHashMap。</p>\n<p>如果想要保持插入顺序，可以指定使用LinkedHashMap：</p>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(2, \"上海\"),\n        new City(1, \"北京\"),\n        new City(4, \"深圳\"),\n        new City(3, \"广州\")\n);\nMap&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName,\n                (existing, replacement) -&gt; existing, LinkedHashMap::new));\nSystem.out.println(cityMap);\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p></p>\n</blockquote>\n<p>如果想要按键排序，可以指定使用TreeMap：</p>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(2, \"上海\"),\n        new City(1, \"北京\"),\n        new City(4, \"深圳\"),\n        new City(3, \"广州\")\n);\nMap&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName,\n                (existing, replacement) -&gt; existing, TreeMap::new));\nSystem.out.println(cityMap);\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p></p>\n</blockquote>\n<h2 id=\"3-注意事项\">3. 注意事项</h2>\n<h3 id=\"31-空异常\">3.1 空异常</h3>\n<p>如果valueMapper中取出的值有null值，会抛出<code>java.lang.NullPointerException</code>异常，如下示例：</p>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(1, \"北京\"),\n        new City(2, \"上海\"),\n        new City(3, \"广州\"),\n        new City(4, \"深圳\"),\n        new City(5, null)\n);\nMap&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName));\nSystem.out.println(cityMap);\n</code></pre>\n<p>运行以上代码会抛出异常，如下图所示：</p>\n<p><img alt=\"\" src=\"https://images.zwwhnly.com/picture/2025/snipaste_20251226_104553.png\" /></p>\n<p>有两种解决方案，第一种解决方案是过滤null值：</p>\n<pre><code class=\"language-java\">Map&lt;Integer, String&gt; cityMap = cityList.stream()\n        .filter(city -&gt; city.getCityName() != null)\n        .collect(Collectors.toMap(City::getCityId, City::getCityName));\n</code></pre>\n<p>第二种解决方案是提供默认值：</p>\n<pre><code class=\"language-java\">Map&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId,\n                city -&gt; Optional.ofNullable(city.getCityName()).orElse(\"未知\")));\n</code></pre>\n<h3 id=\"32-键重复异常\">3.2 键重复异常</h3>\n<p>如果出现重复键，且没有提供mergeFunction参数，会抛出<code>java.lang.IllegalStateException</code>异常，如下示例：</p>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(1, \"北京\"),\n        new City(2, \"上海\"),\n        new City(3, \"广州\"),\n        new City(4, \"深圳\"),\n        new City(4, \"天津\")\n);\nMap&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName));\nSystem.out.println(cityMap);\n</code></pre>\n<p>运行以上代码会抛出异常，如下图所示：</p>\n<p><img alt=\"\" src=\"https://images.zwwhnly.com/picture/2025/snipaste_20251225_172725.png\" /></p>\n<p>解决方案见本篇文章<strong>2.3 键冲突处理</strong>部分。</p>\n<h2 id=\"4-总结\">4. 总结</h2>\n<p><code>Collectors.toMap</code>是Stream API中提供的一个非常方便的收集器，它可以将流中的元素映射为键值对，并收集到一个Map中。</p>\n<p>它适用于一对一映射的场景，但在使用时，要注意避免<code>java.lang.NullPointerException</code>异常和</p>\n<p><code>java.lang.IllegalStateException</code>异常。</p>\n<blockquote>\n<p>文章持续更新，欢迎关注微信公众号「申城异乡人」第一时间阅读！</p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "使用cpp-httplib发布HTTP服务",
      "link": "https://www.cnblogs.com/charlee44/p/19402392",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/charlee44/p/19402392\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 09:05\">\n    <span>使用cpp-httplib发布HTTP服务</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        介绍了如何使用轻量级 C++ 库 cpp-httplib 快速构建支持文本、HTML 页面和 JSON 数据交互的 HTTP 服务器。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"1-引言\">1. 引言</h1>\n<p>cpp-httplib 是一个用 C++11 编写的轻量级、跨平台的 HTTP/HTTPS 服务器和客户端库。它由 yhirose 开发并维护，项目托管在 GitHub 上。在 C/C++ 生态中，笔者不能说 cpp-httplib 是最好的，但一定是最易于使用的 HTTP 服务器组件——它是基于头文件的库，只需要引入 httplib.h 这个头文件能实现所有基于 http/https 协议的功能。</p>\n<h1 id=\"2-实例\">2. 实例</h1>\n<h2 id=\"21-返回文本\">2.1 返回文本</h2>\n<p>首先写一个最简单的 Hello World ：</p>\n<pre><code class=\"language-cpp\">#include &lt;httplib.h&gt;\n\nusing namespace std;\n\nint main() {\n  httplib::Server svr;\n\n  svr.Get(\"/hi\", [](const httplib::Request &amp;, httplib::Response &amp;res) {\n    res.set_content(\"Hello World!\", \"text/plain\");\n  });\n\n  svr.listen(\"0.0.0.0\", 8080);\n\n  return 0;\n}\n</code></pre>\n<p>这段代码的意思很简单，启动一个 HTTP 服务器，然后监听 URL 为 <code>/hi</code> 、端口号为8080 的 Get 请求，并且返回一个 <code>Hello World!</code> 的文本。运行这个程序之后，在浏览器中输入<code>http://127.0.0.1:8080/hi</code>，即可看到这个文本。</p>\n<h2 id=\"22-返回页面\">2.2 返回页面</h2>\n<p>返回文本的 Hello World 太简单了，服务器能传输多种 MIME 类型（MIME Type）的数据到浏览器端显示，例如返回一个 HTML 页面：</p>\n<pre><code class=\"language-cpp\">#include \"HttpServer.h\"\n\n#include &lt;httplib.h&gt;\n\nusing namespace std;\n\nint main() {\n  httplib::Server svr;\n\n  svr.Get(\"/hi\", [](const httplib::Request &amp;, httplib::Response &amp;res) {\n    std::string html = R\"(\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Hello&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello World!&lt;/h1&gt;\n    &lt;p&gt;这是由 cpp-httplib 提供的 HTML 页面。&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n   )\";\n\n    res.set_content(html, \"text/html\");\n  });\n\n  std::cout &lt;&lt; \"Server listening on http://0.0.0.0:8080/hi\\n\";\n\n  svr.listen(\"0.0.0.0\", 8080);\n\n  return 0;\n}\n</code></pre>\n<h2 id=\"23-返回json\">2.3 返回JSON</h2>\n<p>在现代前后端分离的项目绝大多数都使用 JSON（JavaScript Object Notation）作为数据传输格式。这是当前 Web 开发的事实标准，RESTful API 也推荐使用 JSON 作为请求/响应体格式。那么这里笔者就实现一个 监听 Post 请求，返回 JSON 数据的例子：</p>\n<pre><code class=\"language-cpp\">#include &lt;httplib.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;string&gt;\n\nusing namespace std;\nusing namespace nlohmann;\n\nint main() {\n  httplib::Server svr;\n\n  svr.Post(\"/hi\", [](const httplib::Request&amp; req, httplib::Response&amp; res) {\n    try {\n      // 检查 Content-Type 是否为 application/json\n      auto content_type = req.get_header_value(\"Content-Type\");\n      if (content_type.find(\"application/json\") == std::string::npos) {\n        res.status = 400;\n        res.set_content(R\"({\"error\": \"Content-Type must be application/json\"})\",\n                        \"application/json\");\n        return;\n      }\n\n      // 解析请求体为 JSON\n      json request_data = json::parse(req.body);\n\n      // 示例：读取字段（假设客户端发送了 {\"name\": \"Alice\"}）\n      std::string name = request_data.value(\"name\", \"Anonymous\");\n\n      // 构造响应 JSON\n      json response_data;\n      response_data[\"greeting\"] = \"Hello, \" + name + \"!\";\n      response_data[\"original_request\"] = request_data;\n      response_data[\"status\"] = \"success\";\n\n      // 设置响应\n      res.set_content(response_data.dump(), \"application/json\");\n\n    } catch (const json::parse_error&amp; e) {\n      // JSON 解析失败\n      res.status = 400;\n      json err;\n      err[\"error\"] = \"Invalid JSON\";\n      err[\"message\"] = e.what();\n      res.set_content(err.dump(), \"application/json\");\n    } catch (const std::exception&amp; e) {\n      // 其他异常\n      res.status = 500;\n      json err;\n      err[\"error\"] = \"Internal server error\";\n      res.set_content(err.dump(), \"application/json\");\n    }\n  });\n\n  std::cout &lt;&lt; \"Server listening on http://0.0.0.0:8080/hi (POST with JSON)\\n\";\n  svr.listen(\"0.0.0.0\", 8080);\n\n  return 0;\n}\n</code></pre>\n<p>在这里，服务器接受的 HTTP 请求头中 <code>Content-Type</code> 字段的值是 <code>application/json</code> ，表明请求体是一个 JSON 数据。因此通过 nlohmann-json 库解析并装载到新的 <code>nlohmann::json</code> 对象中，最终返回这个 <code>nlohmann::json</code> 对象，并设置返回类型（<code>set_content</code>）也是 <code>application/json</code>。</p>\n<p>由于 Post 请求不能直接在浏览器通过 URL 访问到，在前后端分离的现代开发流程中，一般使用 Postman、ApiPost 等工具进行 API 的开发、测试与调试。使用 ApiPost 访问上述 API 的结果如下图所示：</p>\n<p><img alt=\"使用 ApiPost 测试后端 API\" class=\"lazyload\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 09:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/charlee44\">charlee44</a>&nbsp;\n阅读(<span id=\"post_view_count\">46</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "动态规划",
      "link": "https://www.cnblogs.com/sevencoding/p/19376840",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sevencoding/p/19376840\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 09:00\">\n    <span>动态规划</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"什么是动态规划\">什么是动态规划</h2>\n<p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p>\n<p>所以动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的，</p>\n<p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>\n<p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p>\n<p>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。</p>\n<p>所以贪心解决不了动态规划的问题。</p>\n<h2 id=\"动态规划的解题步骤\">动态规划的解题步骤</h2>\n<p>状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。</p>\n<p><strong>对于动态规划问题，可以拆解为如下五步曲：</strong></p>\n<ol>\n<li>确定dp数组（dp table）以及下标的含义</li>\n<li>确定递推公式</li>\n<li>dp数组如何初始化</li>\n<li>确定遍历顺序</li>\n<li>举例推导dp数组</li>\n</ol>\n<h2 id=\"01背包问题\">01背包问题</h2>\n<p>题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>\n<p>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。</p>\n<p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p>\n<p>举一个例子：背包最大重量为4。</p>\n<p>物品为：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>重量</th>\n<th>价值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>物品0</td>\n<td>1</td>\n<td>15</td>\n</tr>\n<tr>\n<td>物品1</td>\n<td>3</td>\n<td>20</td>\n</tr>\n<tr>\n<td>物品2</td>\n<td>4</td>\n<td>30</td>\n</tr>\n</tbody>\n</table>\n<p>问背包能背的物品最大价值是多少？</p>\n<h3 id=\"二维dp数组\">二维dp数组</h3>\n<ol>\n<li>确定dp数组以及下标的含义</li>\n</ol>\n<p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>\n<p><img alt=\"image-20240427150740757\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271507823.png\" /></p>\n<ol start=\"2\">\n<li>确定递推公式</li>\n</ol>\n<p>再回顾一下dp[i][j]]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>\n<p>那么可以有两个方向推出来dp[i][j]，</p>\n<ul>\n<li><strong>不放物品i</strong>：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)</li>\n<li><strong>放物品i</strong>：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li>\n</ul>\n<p>所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p>\n<ol start=\"3\">\n<li>dp数组如何初始化</li>\n</ol>\n<p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>\n<p>首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图：</p>\n<p><img alt=\"image-20240427151020339\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271510433.png\" /></p>\n<p>在看其他情况。</p>\n<p>状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p>\n<p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p>\n<p>那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。</p>\n<p>当j &gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。</p>\n<p>代码初始化如下：</p>\n<pre><code class=\"language-java\">for (int j = 0 ; j &lt; weight[0]; j++) {  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。\n    dp[0][j] = 0;\n}\n// 正序遍历\nfor (int j = weight[0]; j &lt;= bagweight; j++) {\n    dp[0][j] = value[0];\n}\n</code></pre>\n<p>此时dp数组初始化情况如图所示：</p>\n<p><img alt=\"image-20240427151108396\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271511457.png\" /></p>\n<p>dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？</p>\n<p>其实从递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p>\n<p><strong>初始-1，初始-2，初始100，都可以！</strong></p>\n<p>但只不过一开始就统一把dp数组统一初始为0，更方便一些。如图：</p>\n<p><img alt=\"image-20240427151142267\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271511333.png\" /></p>\n<ol start=\"4\">\n<li>确定遍历顺序</li>\n</ol>\n<p>在如下图中，可以看出，有两个遍历的维度：物品与背包重量</p>\n<p><img alt=\"image-20240427151229720\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271512812.png\" /></p>\n<p>那么问题来了，<strong>先遍历 物品还是先遍历背包重量呢？</strong></p>\n<p><strong>其实都可以！！ 但是先遍历物品更好理解</strong>。</p>\n<p><strong>理解递归的本质和递推的方向</strong>。</p>\n<p>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 递归公式中可以看出dp[i][j]是靠dp[i-1][j]和dp[i - 1][j - weight[i]]推导出来的。</p>\n<p>先遍历物品，再遍历背包：</p>\n<pre><code class=\"language-text\">// weight数组的大小 就是物品个数\nfor(int i = 1; i &lt; weight.size(); i++) { // 遍历物品\n    for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量\n        if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j];\n        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\n\n    }\n}\n</code></pre>\n<p>dp[i-1][j]和dp[i - 1][j - weight[i]] 都在dp[i][j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271514396.png\" /></p>\n<p>先遍历背包，再遍历物品：</p>\n<pre><code class=\"language-java\">// weight数组的大小 就是物品个数\nfor(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量\n    for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品\n        if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j];\n        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\n    }\n}\n</code></pre>\n<p>先遍历背包，再遍历物品的过程如图：</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271515988.png\" /></p>\n<p><strong>可以看出，虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导！</strong></p>\n<p>但先遍历物品再遍历背包这个顺序更好理解。</p>\n<ol start=\"5\">\n<li>举例推导dp数组</li>\n</ol>\n<p>来看一下对应的dp数组的数值，如图</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271516971.png\" /></p>\n<p>最后的答案就是dp[2][4]</p>\n<h3 id=\"一维dp数组滚动数组\">一维dp数组（滚动数组）</h3>\n<p>对于背包问题其实状态都是可以压缩的。</p>\n<p>在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p>\n<p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</strong></p>\n<p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p>\n<p>这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p>\n<p><strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>\n<p>动规五部曲分析如下：</p>\n<ol>\n<li>确定dp数组的定义</li>\n</ol>\n<p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>\n<ol start=\"2\">\n<li>一维dp数组的递推公式</li>\n</ol>\n<p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p>\n<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>\n<p>dp[j - weight[i]] + value[i] 表示 容量为  【j - 物品i重量】  的背包 加上 物品i 的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>\n<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p>\n<p>所以递归公式为：</p>\n<pre><code class=\"language-java\">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n</code></pre>\n<p>可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。</p>\n<ol start=\"3\">\n<li>一维dp数组如何初始化</li>\n</ol>\n<p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p>\n<p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p>\n<p>看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p>\n<p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>\n<p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p>\n<p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p>\n<ol start=\"4\">\n<li>一维dp数组遍历顺序</li>\n</ol>\n<p>代码如下：</p>\n<pre><code class=\"language-java\">for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品\n    for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量\n        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n    }\n}\n</code></pre>\n<p><strong>这里发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。为什么呢？</p>\n<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>\n<p>举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15</p>\n<p>如果正序遍历</p>\n<ul>\n<li>\n<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>\n</li>\n<li>\n<p>dp[2] = dp[2 - weight[0]] + value[0] = 30</p>\n</li>\n</ul>\n<p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p>\n<p>为什么倒序遍历，就可以保证物品只放入一次呢？</p>\n<p>倒序就是先算dp[2]</p>\n<ul>\n<li>\n<p>dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）</p>\n</li>\n<li>\n<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>\n</li>\n</ul>\n<p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p>\n<p><strong>那么问题又来了，为什么二维dp数组遍历的时候不用倒序呢？</strong></p>\n<p>因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！</p>\n<p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p>\n<p>不可以！</p>\n<p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p>\n<p>倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。</p>\n<ol start=\"5\">\n<li>举例推导dp数组</li>\n</ol>\n<p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271524585.png\" /></p>\n<h2 id=\"完全背包问题\">完全背包问题</h2>\n<p>题目描述：有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>\n<p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p>\n<p>例子同上，但每个物品有无数个，其实也就是可以重复取同一个物品。问背包能背的物品最大价值是多少？</p>\n<p>我们知道 01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p>\n<p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>\n<pre><code class=\"language-java\">// 先遍历物品，再遍历背包\nfor(int i = 0; i &lt; weight.size(); i++) { // 遍历物品\n    for(int j = weight[i]; j &lt;= bagWeight ; j++) { // 遍历背包容量\n        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n    }\n}\n</code></pre>\n<p>但是 <strong>为什么遍历物品在外层循环，遍历背包容量在内层循环？</strong>难道就不能遍历背包容量在外层，遍历物品在内层？</p>\n<p>01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。</p>\n<p><strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！</strong></p>\n<p>因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。</p>\n<p>遍历物品在外层循环，遍历背包容量在内层循环，状态如图：</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271528379.png\" /></p>\n<p>遍历背包容量在外层循环，遍历物品在内层循环，状态如图：</p>\n<p><img alt=\"\" src=\"https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271528597.png\" /></p>\n<p>看了这两个图，大家就会理解，完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值（这个值就是下标j之前所对应的dp[j]）。</p>\n<p>先遍历背包再遍历物品，代码如下：</p>\n<pre><code class=\"language-java\">// 先遍历背包，再遍历物品\nfor(int j = 0; j &lt;= bagWeight; j++) { // 遍历背包容量\n    for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品\n        if (j - weight[i] &gt;= 0) \n            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n    }\n}\n</code></pre>\n<h2 id=\"多重背包问题\">多重背包问题</h2>\n<p>题目描述：有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。</p>\n<p>多重背包和01背包是非常像的， 为什么和01背包像呢？每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。</p>\n<p>例如：</p>\n<p>背包最大重量为10。</p>\n<p>物品为：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>重量</th>\n<th>价值</th>\n<th>数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>物品0</td>\n<td>1</td>\n<td>15</td>\n<td>2</td>\n</tr>\n<tr>\n<td>物品1</td>\n<td>3</td>\n<td>20</td>\n<td>3</td>\n</tr>\n<tr>\n<td>物品2</td>\n<td>4</td>\n<td>30</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>问背包能背的物品最大价值是多少？</p>\n<p>和如下情况有区别么？</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>重量</th>\n<th>价值</th>\n<th>数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>物品0</td>\n<td>1</td>\n<td>15</td>\n<td>1</td>\n</tr>\n<tr>\n<td>物品0</td>\n<td>1</td>\n<td>15</td>\n<td>1</td>\n</tr>\n<tr>\n<td>物品1</td>\n<td>3</td>\n<td>20</td>\n<td>1</td>\n</tr>\n<tr>\n<td>物品1</td>\n<td>3</td>\n<td>20</td>\n<td>1</td>\n</tr>\n<tr>\n<td>物品1</td>\n<td>3</td>\n<td>20</td>\n<td>1</td>\n</tr>\n<tr>\n<td>物品2</td>\n<td>4</td>\n<td>30</td>\n<td>1</td>\n</tr>\n<tr>\n<td>物品2</td>\n<td>4</td>\n<td>30</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。</p>\n<p>代码如下：</p>\n<pre><code class=\"language-java\">int[] dp = new int[bagWeight + 1];\n\n//先遍历物品再遍历背包，作为01背包处理\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = bagWeight; j &gt;= weight[i]; j--) {\n        //遍历每种物品的个数\n        for (int k = 1; k &lt;= nums[i] &amp;&amp; (j - k * weight[i]) &gt;= 0; k++) {\n        \tdp[j] = Math.max(dp[j], dp[j - k * weight[i]] + k * value[i]);\n        }\n    }\n}\n</code></pre>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 09:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sevencoding\">程序员Seven</a>&nbsp;\n阅读(<span id=\"post_view_count\">39</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "未来已来 | 写给 .NET 开发者的 2025 年度总结",
      "link": "https://www.cnblogs.com/sheng-jie/p/19402252/goodbye-2025-welcome-2026",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sheng-jie/p/19402252/goodbye-2025-welcome-2026\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 08:45\">\n    <span>未来已来 | 写给 .NET 开发者的 2025 年度总结</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        2025年是.NET与AI融合的里程碑之年，未来已来，你准备好了吗？\n本文将为你系统梳理 2025 年.NET开发者最应该关注的技术趋势和重要事件，涵盖AI发展、.NET演进及两者融合的最新动态和趋势，以求帮助大家找准定位，迎接未来的挑战与机遇。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><img alt=\"c46eb915b6d1dbe9ffac26ed0bd36da6\" src=\"https://img2024.cnblogs.com/blog/577140/202512/577140-20251226085420897-692597100.jpg\" /></p>\n<h1 id=\"写给net-开发者的2025年度总结\">写给.NET 开发者的2025年度总结</h1>\n<blockquote>\n<p>相信今年大家没少看到 <em>《抱歉，C# 已经跌出第一梯队》</em>类似的文章，.NET 生态到底如何，本文将为你系统梳理 2025 年.NET开发者最应该关注的技术趋势和重要事件，涵盖AI发展、.NET演进及两者融合的最新动态和趋势，以求帮助大家找准定位，迎接未来的挑战与机遇。</p>\n</blockquote>\n<hr />\n<blockquote>\n<p>本文由我（圣杰）个人原创撰写，AI 辅助润色完成。</p>\n<p>本文仅陈述事实和表述个人观点，不贩卖焦虑，请放心阅读，文章较长，建议先点赞收藏。</p>\n<p>本文部分内容参考了微软官方博客、.NET 博客、NuGet 统计数据、TIOBE 编程语言指数等公开资料，可能存在疏漏，欢迎指正。</p>\n<p><strong>文末评论区留下你的2025年感悟和对2026年的期待，赢取奖品！</strong></p>\n</blockquote>\n<hr />\n<h2 id=\"-2025年的我\">🎯 2025年的我？</h2>\n<p>在开始之前，花几秒钟回顾一下你的2025：</p>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> 📚 <strong>紧跟潮流，学以致用</strong> — 学了不少新技术，工作中也用上了</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> 🚀 <strong>拥抱AI，效率翻倍</strong> — Vibe Coding真香，已经离不开AI助手</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> 🎉 <strong>收获满满，更上层楼</strong> — 升职加薪/跳槽成功/项目大卖</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> 😰 <strong>AI焦虑，何去何从</strong> — 担心被AI取代，不知道该学什么</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> 😩 <strong>疲于奔命，原地踏步</strong> — 忙于业务，没时间学习新技术</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> 🌱 <strong>转型探索，蓄势待发</strong> — 正在转型或探索新方向</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> 😎 <strong>佛系躺平，岁月静好</strong> — 稳定就好，不想卷了</label></li>\n</ul>\n<p>无论你是哪一种，这篇文章都希望能给你带来一些启发和方向。</p>\n<p><strong>可以的话，欢迎在评论区分享你的2025年感悟以及对2026年的期待，赢取礼品！</strong></p>\n<hr />\n<h2 id=\"前言\">前言</h2>\n<p>2025年，注定是技术发展史上浓墨重彩的一年。<br />\n回顾这一年，AI Agent席卷全球，.NET与AI深度融合，开发者工具百花齐放。作为.NET开发者，你准备好迎接这场变革了吗？</p>\n<p>如果说2023年是大模型元年，2024年是大模型落地元年，那么2025年毫无疑问是<strong>AI Agent元年</strong>。从简单的代码补全到能够自主规划、推理、调用工具的智能代理，AI的能力发生了质的飞跃。</p>\n<p>与此同时，.NET生态也迎来了重要的里程碑——.NET 10正式发布，C#语言在TIOBE榜单上持续攀升，NuGet周下载量突破55亿，Visual Studio 2026带来全新体验。更令人兴奋的是，微软在AI领域持续发力，Microsoft.Extensions.AI、Semantic Kernel、Microsoft Agent Framework等框架日趋成熟，.NET开发者拥有了构建AI应用的完整工具链。</p>\n<p>本文将从AI发展、.NET演进、.NET+AI融合三个维度，为你梳理2025年.NET开发者最应该关注的技术趋势和重要事件。</p>\n<hr />\n<h1 id=\"一ai-的发展\">一、AI 的发展</h1>\n<h2 id=\"11-史上最强-ai-模型不断刷新\">1.1 史上最强 AI 模型不断刷新</h2>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/443a2449-8373-42cb-9c75-d10522eeb5f9.png\" /></p>\n<p>2025年，AI模型能力突飞猛进，各大厂商你追我赶，不断刷新性能记录。</p>\n<h3 id=\"国外模型\">国外模型</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">厂商</th>\n<th style=\"text-align: left;\">模型</th>\n<th style=\"text-align: left;\">亮点/特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>OpenAI</strong></td>\n<td style=\"text-align: left;\">GPT-5.2</td>\n<td style=\"text-align: left;\">旗舰通用模型，推理与工具调用显著提升</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Anthropic</strong></td>\n<td style=\"text-align: left;\">Claude Opus 4.5</td>\n<td style=\"text-align: left;\">旗舰，编程与Agent表现最佳，Token效率高</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Google</strong></td>\n<td style=\"text-align: left;\">Gemini 3 Pro</td>\n<td style=\"text-align: left;\">旗舰模型，强化Deep Research与Gemini App体验</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>XAI</strong></td>\n<td style=\"text-align: left;\">Grok 4.1</td>\n<td style=\"text-align: left;\">卓越的情感智能</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"国内模型\">国内模型</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">厂商</th>\n<th style=\"text-align: left;\">模型</th>\n<th style=\"text-align: left;\">亮点/特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>阿里云</strong></td>\n<td style=\"text-align: left;\">Qwen3</td>\n<td style=\"text-align: left;\">全新旗舰，支持119种语言，推理与Agent能力大幅提升，开源版本引领国产大模型生态</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>智谱AI</strong></td>\n<td style=\"text-align: left;\">GLM-4.7</td>\n<td style=\"text-align: left;\">新一代旗舰，编程/Agent/推理/对话全面升级</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>DeepSeek</strong></td>\n<td style=\"text-align: left;\">DeepSeek-V3.2</td>\n<td style=\"text-align: left;\">旗舰模型，Agent能力强化，性价比领先</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>小米</strong></td>\n<td style=\"text-align: left;\">Mimo</td>\n<td style=\"text-align: left;\">全新旗舰模型，代码能力超过所有开源模型</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"对开发者的影响\">对开发者的影响</h3>\n<p>模型能力的提升直接惠及开发者：</p>\n<ul>\n<li><strong>更强的代码生成</strong>：复杂重构、架构设计、bug修复更加可靠</li>\n<li><strong>更长的上下文</strong>：处理大型代码库和长文档不再是问题</li>\n<li><strong>更好的工具调用</strong>：Agent能力大幅增强，自动化程度更高</li>\n<li><strong>更低的成本</strong>：同等能力下，API调用成本持续下降</li>\n</ul>\n<h2 id=\"12-agent时代来临\">1.2 Agent时代来临</h2>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/6ed42990-13c2-46d5-87ae-68ac2f3220cc.jpg\" /></p>\n<p>2025年，AI从\"助手\"进化为\"代理\"。</p>\n<p>过去的AI助手（如早期的Copilot）主要扮演\"智能补全\"的角色——你写一行代码，它帮你补全下一行。而今天的AI Agent则完全不同，它们具备了四大核心能力：</p>\n<ul>\n<li><strong>规划（Planning）</strong>：能够将复杂任务拆解为多个子任务，制定执行计划</li>\n<li><strong>推理（Reasoning）</strong>：能够基于上下文进行逻辑推理，做出判断和决策</li>\n<li><strong>工具调用（Tool Use）</strong>：能够调用外部API、执行代码、操作文件系统</li>\n<li><strong>记忆（Memory）</strong>：能够记住历史对话和操作，在长期任务中保持上下文</li>\n</ul>\n<p>这意味着，AI不再只是\"回答问题\"，而是能够\"完成任务\"。你可以告诉AI\"帮我重构这个模块的代码\"，它会自动分析代码结构、识别问题、制定重构方案、执行修改、运行测试，最终交付一个完整的结果。</p>\n<p>GitHub Copilot的Agent模式就是这一趋势的典型代表。当你在VS Code中使用Agent模式时，Copilot不再只是补全代码，而是能够理解你的意图，主动搜索代码库，修改多个文件，运行命令，直到任务完成。</p>\n<h2 id=\"13-协议的发展构建ai互操作标准\">1.3 协议的发展：构建AI互操作标准</h2>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/5ff81739-5dbf-45c1-9121-ac3f1fa7412b.png\" /></p>\n<p>Agent能力的爆发，离不开标准化协议的推动。2025年，四大协议共同构建了AI互操作的基础设施。</p>\n<h3 id=\"1-mcp协议-model-context-protocol\">1. MCP协议 (Model Context Protocol)</h3>\n<p>MCP由Anthropic发起，已成为AI工具调用的事实标准。</p>\n<p>在MCP出现之前，每个AI应用都需要为不同的工具编写专门的集成代码。MCP统一了AI模型与外部工具的交互方式，定义了：</p>\n<ul>\n<li><strong>Resources</strong>：AI可以读取的资源（文件、数据库、API响应等）</li>\n<li><strong>Tools</strong>：AI可以调用的函数（搜索、计算、操作等）</li>\n<li><strong>Prompts</strong>：预定义的提示模板</li>\n</ul>\n<p>有了MCP，开发者只需编写一次MCP Server，就能让所有支持MCP的AI客户端使用这个工具。目前，Claude、VS Code Copilot、Cursor等主流AI工具都已支持MCP协议。</p>\n<h3 id=\"2-a2a-agent-to-agent\">2. A2A (Agent-to-Agent)</h3>\n<p>A2A由Google发起，定义了Agent之间的通信标准。</p>\n<p>在复杂的业务场景中，单个Agent往往无法完成所有任务。例如，一个\"旅行规划Agent\"可能需要调用\"机票预订Agent\"、\"酒店预订Agent\"、\"行程规划Agent\"等多个专业Agent协同工作。</p>\n<p>A2A协议解决的就是这个问题。它定义了：</p>\n<ul>\n<li><strong>Agent Card</strong>：描述Agent的能力和接口</li>\n<li><strong>Task</strong>：Agent之间传递的任务请求和响应</li>\n<li><strong>Message</strong>：Agent之间的通信消息格式</li>\n</ul>\n<p>通过A2A，不同团队开发的Agent可以无缝协作，构建更强大的多Agent系统。</p>\n<h3 id=\"3-ag-ui-agent-user-interaction-protocol\">3. AG-UI (Agent User Interaction Protocol)</h3>\n<p>AG-UI定义了Agent与用户界面的交互协议。</p>\n<p>传统的AI应用通常是\"一问一答\"的模式，但Agent执行复杂任务时，用户需要实时了解进度、查看中间结果、提供反馈。AG-UI协议支持：</p>\n<ul>\n<li><strong>流式UI更新</strong>：实时显示Agent的思考过程和执行状态</li>\n<li><strong>进度反馈</strong>：展示任务完成百分比和预计剩余时间</li>\n<li><strong>交互式确认</strong>：在关键节点请求用户确认后再继续</li>\n</ul>\n<p>Microsoft Agent Framework已经内置了AG-UI支持，让开发者能够轻松构建用户友好的Agent应用。</p>\n<h3 id=\"4-agent-skills\">4. Agent Skills</h3>\n<p>Agent Skills是一种开放的标准格式，由Anthropic发起，用于赋予AI Agent新的能力和专业知识。</p>\n<p>与其他协议不同，Agent Skills不是一个通信协议，而是一种<strong>知识打包格式</strong>。它让Agent能够按需加载程序性知识和特定上下文（公司级、团队级、用户级），从而更准确、高效地完成任务。</p>\n<p>Agent Skills能够实现：</p>\n<ul>\n<li><strong>领域专业知识</strong>：将专业知识打包为可复用的指令（如法律审查流程、数据分析管道）</li>\n<li><strong>新增能力</strong>：赋予Agent新能力（如创建PPT、构建MCP Server、分析数据集）</li>\n<li><strong>可重复工作流</strong>：将多步骤任务转化为一致且可审计的工作流</li>\n<li><strong>互操作性</strong>：同一个Skill可在不同的Agent产品中复用</li>\n</ul>\n<p>目前，Agent Skills已被众多主流AI工具采纳，包括：GitHub Copilot、VS Code、Claude Code、Cursor、OpenAI Codex、Amp、Goose等。</p>\n<p>值得注意的是，.NET 10新增的直接运行.cs文件能力，让编写Agent Skills中的脚本变得更加简单——你可以直接用C#编写工具脚本，无需创建完整的项目。</p>\n<h2 id=\"14-ai-ide卷到冒烟\">1.4 AI IDE卷到冒烟</h2>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/52f4ed49-6726-453f-a7d0-8690aab1d33c.png\" /></p>\n<p>2025年，AI编程工具的竞争进入白热化阶段。你是否已经开启 Vibe Coding模式？</p>\n<h3 id=\"国外产品\">国外产品</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">产品</th>\n<th style=\"text-align: left;\">厂商</th>\n<th style=\"text-align: left;\">亮点/特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>GitHub Copilot</strong></td>\n<td style=\"text-align: left;\">GitHub</td>\n<td style=\"text-align: left;\">市场领导者，Agent模式支持自主任务，深度集成VS Code/VS</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Claude Code</strong></td>\n<td style=\"text-align: left;\">Anthropic</td>\n<td style=\"text-align: left;\">终端助手，擅长处理大型代码库，基于Claude模型</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Codex CLI</strong></td>\n<td style=\"text-align: left;\">OpenAI</td>\n<td style=\"text-align: left;\">命令行工具，轻量快速，适合终端工作流</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Cursor</strong></td>\n<td style=\"text-align: left;\">Cursor</td>\n<td style=\"text-align: left;\">AI-first IDE代表，体验流畅，支持多模型切换</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Windsurf</strong></td>\n<td style=\"text-align: left;\">Codeium</td>\n<td style=\"text-align: left;\">AI IDE，主打\"Flow\"概念，强调人机协作</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Kiro</strong></td>\n<td style=\"text-align: left;\">AWS</td>\n<td style=\"text-align: left;\">与AWS深度集成，适合云原生开发</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"国内产品\">国内产品</h3>\n<p>国内厂商也不甘落后，纷纷推出自己的AI编程工具：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">产品</th>\n<th style=\"text-align: left;\">厂商</th>\n<th style=\"text-align: left;\">亮点/特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>CodeBuddy</strong></td>\n<td style=\"text-align: left;\">腾讯云</td>\n<td style=\"text-align: left;\">支持多种语言和框架</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>TRAE</strong></td>\n<td style=\"text-align: left;\">字节跳动</td>\n<td style=\"text-align: left;\">基于豆包大模型</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Qoder</strong></td>\n<td style=\"text-align: left;\">阿里巴巴</td>\n<td style=\"text-align: left;\">与阿里云深度集成</td>\n</tr>\n</tbody>\n</table>\n<p>对于.NET开发者来说，有很多选择，但在众多AI编程工具中，<strong>GitHub Copilot</strong>仍然是首选——它与Visual Studio和VS Code的集成最为成熟，对C#的支持也最好。</p>\n<hr />\n<h1 id=\"二net-的发展\">二、.NET 的发展</h1>\n<h2 id=\"21-net-10-重磅发布\">2.1 .NET 10 重磅发布</h2>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/287fe363-b681-4277-889b-8bc456d9568a.png\" /></p>\n<p>2025年11月，.NET 10正式发布，这是.NET平台的又一个重要里程碑。</p>\n<h3 id=\"c-语言地位提升\">C# 语言地位提升</h3>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/155e5e23-229d-4cc1-9894-e581d85929b5.png\" /></p>\n<p>根据TIOBE编程语言指数，C#在2025年持续攀升，有望成为年度语言。这得益于：</p>\n<ul>\n<li>.NET跨平台能力的持续增强</li>\n<li>Unity游戏开发的持续火爆</li>\n<li>企业级应用开发的稳定需求</li>\n<li>AI/ML领域.NET生态的完善</li>\n</ul>\n<h3 id=\"net-10-核心亮点\">.NET 10 核心亮点</h3>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/13d755f1-a03f-46ef-9538-902a249a5d66.png\" /></p>\n<p>.NET 10延续了性能优先的传统，带来了多项重要改进：</p>\n<ul>\n<li><strong>性能持续优化</strong>：JIT编译器改进，内存占用更低</li>\n<li><strong>容器支持增强</strong>：更小的镜像体积，更快的启动速度</li>\n<li><strong>原生AOT改进</strong>：支持更多场景，编译速度提升</li>\n<li><strong>云原生增强</strong>：与Kubernetes、容器化部署的更好集成</li>\n</ul>\n<h3 id=\"nuget生态繁荣\">NuGet生态繁荣</h3>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/1395ae0a-449e-4d0c-9d28-049e20e7620d.png\" /></p>\n<p>NuGet周下载量突破55亿，这个数字充分说明了.NET生态的活跃程度。从Web开发到机器学习，从游戏开发到物联网，NuGet上几乎能找到所有你需要的库。</p>\n<h3 id=\"net-10支持直接运行cs文件\">.NET 10支持直接运行.cs文件</h3>\n<p>这是.NET 10最令人兴奋的特性之一。现在你可以直接运行单个.cs文件：</p>\n<pre><code class=\"language-bash\">dotnet run app.cs\n</code></pre>\n<p>不需要创建项目文件，不需要<code>Program.cs</code>的样板代码，就像运行Python脚本一样简单。这极大降低了.NET的入门门槛，也让编写快速原型和工具脚本变得更加方便。</p>\n<h3 id=\"dnx-登场net-的-npxuvx-时代\">dnx 登场：.NET 的 \"npx/uvx\" 时代</h3>\n<p>dnx（.NET eXperience）是.NET 10 SDK引入的全新工具执行脚本，本质上是<code>dotnet tool exec</code>命令的精简、用户友好的包装器。它标志着.NET正式进入\"一次性执行\"（one-shot）时代，与Python的<code>uvx</code>和Node.js的<code>npx</code>完全对标。</p>\n<h4 id=\"核心特性\">核心特性</h4>\n<ul>\n<li><strong>无需安装即可运行</strong>：直接从NuGet包运行.NET工具，无需永久性本地或全局安装</li>\n<li><strong>隔离执行环境</strong>：工具包临时下载到NuGet缓存中执行，不修改系统PATH环境变量，确保干净隔离</li>\n<li><strong>智能版本管理</strong>：默认使用指定工具包的最新版本，支持<code>@版本号</code>指定版本；优先使用本地<code>.config/dotnet-tools.json</code>中的配置</li>\n<li><strong>流畅的开发体验</strong>：简化工作流程，降低新工具的尝试门槛</li>\n</ul>\n<h4 id=\"使用示例\">使用示例</h4>\n<pre><code class=\"language-bash\"># 执行C#代码片段\ndnx dotnet-execute 'WriteLine(\"Hello dnx!!!\");' --using \"static System.Console\"\n\n# 快速生成GUID\ndnx dotnet-execute \"Guid.NewGuid()\" \n\n# 性能压测\ndnx LoadTestToolbox hammer --url https://www.example.com --min 1 --max 100\n\n# JSON转YAML\ndnx json2yaml -i:input.json -c\n\n# 解码JWT Token\ndnx dotnet-decode-jwt &lt;token&gt;\n</code></pre>\n<h4 id=\"与其他平台的对比\">与其他平台的对比</h4>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>dnx</th>\n<th>uvx</th>\n<th>npx</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按需执行</td>\n<td>✓</td>\n<td>✓</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>版本控制</td>\n<td>@版本号</td>\n<td>@版本号</td>\n<td>@版本号</td>\n</tr>\n<tr>\n<td>隔离执行</td>\n<td>独立NuGet缓存</td>\n<td>临时虚拟环境</td>\n<td>临时下载</td>\n</tr>\n<tr>\n<td>生态成熟度</td>\n<td>发展中</td>\n<td>统一uv工具链</td>\n<td>深度成熟</td>\n</tr>\n</tbody>\n</table>\n<p>这一创新将NuGet生态推向新的高度，为开发者工具分发开启了全新的可能性。</p>\n<h3 id=\"nuget-包支持分发-mcp-server\">NuGet 包支持分发 MCP Server</h3>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/71a22993-27ac-47e5-afd1-be9fb7f6dc57.png\" /></p>\n<p>这是.NET与AI生态融合的重要一步。现在你可以将MCP Server打包为NuGet包进行分发，用户只需安装NuGet包就能获得AI工具能力。这让.NET社区能够更便捷地共享AI工具。</p>\n<h2 id=\"22-c-14-新特性\">2.2 C# 14 新特性</h2>\n<p>随着.NET 10一同发布的C# 14，带来了多项实用的语言改进。</p>\n<h3 id=\"field-关键字\">field 关键字</h3>\n<p>现在可以在自动属性中直接访问后备字段：</p>\n<pre><code class=\"language-csharp\">public class Person\n{\n    public string Name\n    {\n        get =&gt; field;\n        set =&gt; field = value?.Trim() ?? throw new ArgumentNullException();\n    }\n}\n</code></pre>\n<p>不再需要显式声明私有字段，代码更加简洁。</p>\n<h3 id=\"扩展成员-extension-members\">扩展成员 (Extension Members)</h3>\n<p>C# 14大幅增强了扩展方法的能力，现在可以定义扩展属性、扩展静态成员等：</p>\n<pre><code class=\"language-csharp\">public extension IntExtensions for int\n{\n    public bool IsEven =&gt; this % 2 == 0;\n    public static int Zero =&gt; 0;\n}\n\n// 使用\nint x = 10;\nbool even = x.IsEven;  // true\nint zero = int.Zero;   // 0\n</code></pre>\n<h3 id=\"params集合增强\">params集合增强</h3>\n<p><code>params</code>关键字现在支持更多集合类型，不仅限于数组：</p>\n<pre><code class=\"language-csharp\">void PrintAll(params IEnumerable&lt;string&gt; items)\n{\n    foreach (var item in items)\n        Console.WriteLine(item);\n}\n\n// 可以传入List、Array等任何IEnumerable&lt;string&gt;\nPrintAll([\"a\", \"b\", \"c\"]);\nPrintAll(new List&lt;string&gt; { \"x\", \"y\" });\n</code></pre>\n<h2 id=\"23-框架生态更新\">2.3 框架生态更新</h2>\n<h3 id=\"aspire-13-发布\">Aspire 13 发布</h3>\n<p>.NET Aspire是微软推出的云原生应用开发框架，2025年迎来了重大升级——Aspire 13。这是迄今为止最大的一次发布：</p>\n<ul>\n<li><strong><code>aspire do</code> 命令</strong>：全新的构建、发布、部署流水线体验，支持自定义流水线步骤</li>\n<li><strong>Aspire MCP Server</strong>：Dashboard内置MCP服务器，AI助手可直接查询运行中的应用日志和追踪数据</li>\n<li><strong>多语言连接字符串</strong>：数据库资源自动暴露多种格式（.NET格式、Python URI格式、Java JDBC格式）</li>\n<li><strong>JavaScript/Python一等公民支持</strong>：<code>AddJavaScriptApp</code>、<code>AddPythonApp</code>等全新API</li>\n<li><strong>全新官网 aspire.dev</strong>：文档和资源全面迁移</li>\n</ul>\n<h3 id=\"aspnet-core-10\">ASP.NET Core 10</h3>\n<ul>\n<li><strong>Blazor增强</strong>：<code>[PersistentState]</code>声明式状态持久化、电路状态保持、嵌套表单验证、Passkey无密码认证、NotFound页面参数、JS互操作增强</li>\n<li><strong>Minimal API改进</strong>：内置<code>AddValidation()</code>验证支持、<code>TypedResults.ServerSentEvents</code>原生SSE、Record类型验证</li>\n<li><strong>OpenAPI 3.1原生支持</strong>：默认生成3.1规范、YAML格式输出、XML文档注释自动集成</li>\n<li><strong>认证授权指标</strong>：新增OpenTelemetry认证/授权指标，API端点智能返回401/403</li>\n</ul>\n<h3 id=\"maui-10\">MAUI 10</h3>\n<ul>\n<li><strong>.NET Aspire集成</strong>：新增项目模板，支持OpenTelemetry遥测和服务发现</li>\n<li><strong>XAML源生成器</strong>：编译时生成强类型代码，全局XML命名空间简化声明</li>\n<li><strong>控件增强</strong>：HybridWebView支持请求拦截、CollectionView性能优化、MediaPicker多选</li>\n<li><strong>平台改进</strong>：Android CoreCLR实验性支持、iOS绑定项目可在Windows构建</li>\n</ul>\n<h3 id=\"ef-core-10\">EF Core 10</h3>\n<p>EF Core 10作为LTS版本与.NET 10一同发布，带来了多项重要更新：</p>\n<ul>\n<li><strong>向量搜索支持</strong>：完整支持SQL Server 2025和Azure SQL的<code>vector</code>数据类型，通过<code>SqlVector&lt;float&gt;</code>和<code>VectorDistance()</code>函数实现AI语义搜索和RAG场景</li>\n<li><strong>JSON数据类型</strong>：原生支持SQL Server 2025的<code>json</code>列类型，查询效率大幅提升</li>\n<li><strong>LeftJoin/RightJoin操作符</strong>：支持.NET 10新增的LINQ左右连接方法，简化复杂查询</li>\n<li><strong>命名查询过滤器</strong>：支持为实体配置多个命名过滤器，可在查询中选择性禁用</li>\n<li><strong>复杂类型增强</strong>：支持可选复杂类型、JSON映射、结构体映射</li>\n<li><strong>ExecuteUpdate支持JSON列</strong>：可高效批量更新JSON文档属性</li>\n<li><strong>参数化集合改进</strong>：新的默认翻译模式，每个集合值转为独立参数，优化查询计划缓存</li>\n<li><strong>Cosmos DB全文搜索</strong>：支持全文搜索和混合搜索（RRF函数）</li>\n</ul>\n<h3 id=\"abp-10-发布\">ABP 10 发布</h3>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/ef66d34c-3f3e-4f0c-90ad-44e709f68bd6.png\" /></p>\n<p>作为.NET优秀的企业级应用框架，ABP在2025年发布了10.0版本，这是一次重大更新：</p>\n<ul>\n<li><strong>升级至.NET 10</strong>：全面支持最新的.NET 10 LTS版本</li>\n<li><strong>AI集成（Volo.Abp.AI）</strong>：提供统一的AI能力集成，支持Microsoft.Extensions.AI、Microsoft Agent Framework和Semantic Kernel，引入AI Workspace概念实现隔离配置</li>\n<li><strong>新增Workflow模块</strong>：集成Elsa Workflows，支持构建可视化、长期运行的事件驱动工作流</li>\n<li><strong>Mapperly替代AutoMapper</strong>：采用编译时源生成器，性能更优，无需运行时反射</li>\n<li><strong>Angular SSR支持</strong>：Angular模板支持服务端渲染，提升首屏加载和SEO体验</li>\n<li><strong>Blazorise升级至v1.8.2</strong>：Blazor UI组件库全面更新</li>\n<li><strong>EF Core共享实体类型</strong>：仓储支持运行时切换目标表，适用于多租户分表等场景</li>\n</ul>\n<h2 id=\"24-visual-studio-2026-发布\">2.4 Visual Studio 2026 发布</h2>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/4bef760a-ae61-423a-9ded-d457280bd5c2.png\" /></p>\n<p>2025年最令.NET开发者兴奋的消息之一，是Visual Studio 2026的发布。</p>\n<p>微软告别了延续多年的年份命名方式，全新的Visual Studio 2026带来了：</p>\n<ul>\n<li><strong>AI Copilot深度集成</strong>：Agent模式原生支持，无需额外插件</li>\n<li><strong>性能大幅提升</strong>：启动速度更快，内存占用更低</li>\n<li><strong>全新UI设计</strong>：现代化的界面，更好的暗色主题支持</li>\n<li><strong>Git集成增强</strong>：更强大的代码审查和合并体验</li>\n<li><strong>完整支持.NET 10和C# 14</strong>：开箱即用的最新技术栈支持</li>\n</ul>\n<hr />\n<h1 id=\"三net--ai-的深度融合\">三、.NET + AI 的深度融合</h1>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/8515ff6c-6b8d-426f-b2dd-d4d433a5429f.png\" /></p>\n<p>2025年，.NET与AI的融合达到了新的高度。微软提供了从底层抽象到上层框架的完整AI开发工具链。</p>\n<h2 id=\"31-microsoftextensionsai-meai\">3.1 Microsoft.Extensions.AI (MEAI)</h2>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/01384d21-ef01-448b-8e4c-0b381905bde1.png\" /></p>\n<p>MEAI是微软推出的AI服务统一抽象层，2025年更新到了10.0版本。</p>\n<h3 id=\"核心价值\">核心价值</h3>\n<p>MEAI解决的核心问题是：<strong>如何让你的代码不依赖于特定的AI提供商</strong>。</p>\n<p>就像<code>ILogger</code>让你的日志代码不依赖于特定的日志框架一样，MEAI的<code>IChatClient</code>让你的AI代码不依赖于OpenAI、Azure或其他任何提供商。</p>\n<h3 id=\"核心接口\">核心接口</h3>\n<pre><code class=\"language-csharp\">// 聊天客户端接口\npublic interface IChatClient\n{\n    Task&lt;ChatCompletion&gt; CompleteAsync(\n        IList&lt;ChatMessage&gt; chatMessages,\n        ChatOptions? options = null,\n        CancellationToken cancellationToken = default);\n}\n\n// 嵌入生成接口\npublic interface IEmbeddingGenerator&lt;TInput, TEmbedding&gt;\n{\n    Task&lt;GeneratedEmbeddings&lt;TEmbedding&gt;&gt; GenerateAsync(\n        IEnumerable&lt;TInput&gt; values,\n        EmbeddingGenerationOptions? options = null,\n        CancellationToken cancellationToken = default);\n}\n</code></pre>\n<h3 id=\"支持的提供商\">支持的提供商</h3>\n<p>MEAI支持多种AI提供商：</p>\n<ul>\n<li>OpenAI / Azure OpenAI</li>\n<li>Anthropic Claude</li>\n<li>Google Gemini</li>\n<li>Ollama（本地模型）</li>\n<li>更多社区实现...</li>\n</ul>\n<h3 id=\"中间件模式\">中间件模式</h3>\n<p>MEAI支持中间件模式，可以在AI调用链中插入各种处理逻辑：</p>\n<pre><code class=\"language-csharp\">IChatClient client = new ChatClientBuilder(openAIClient)\n    .UseLogging()           // 日志记录\n    .UseFunctionInvocation() // 函数调用\n    .UseRetry()             // 重试策略\n    .Build();\n</code></pre>\n<h2 id=\"32-semantic-kernel-sk\">3.2 Semantic Kernel (SK)</h2>\n<p>Semantic Kernel是微软2023年就推出的AI编排框架，2025年更新到1.68版本，功能更加成熟。</p>\n<h3 id=\"agent框架\">Agent框架</h3>\n<p>SK的Agent框架是其核心亮点，支持创建能够自主规划和执行任务的智能代理：</p>\n<pre><code class=\"language-csharp\">var agent = new ChatCompletionAgent\n{\n    Name = \"CodeReviewer\",\n    Instructions = \"你是一个代码审查专家，帮助开发者改进代码质量。\",\n    Kernel = kernel\n};\n\nvar response = await agent.InvokeAsync(\"请审查这段代码...\");\n</code></pre>\n<h3 id=\"与meai深度集成\">与MEAI深度集成</h3>\n<p>SK现在完全基于MEAI构建，这意味着：</p>\n<ul>\n<li>可以使用任何MEAI支持的AI提供商</li>\n<li>享受MEAI的中间件能力</li>\n<li>保持代码的可移植性</li>\n</ul>\n<h2 id=\"33-microsoft-agent-framework-maf\">3.3 Microsoft Agent Framework (MAF)</h2>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/889155e1-7343-4e6c-a13e-5743751c4cef.png\" /></p>\n<p>2025年10月，微软正式发布了Microsoft Agent Framework预览版，这是.NET开发者构建AI Agent的全新统一框架。</p>\n<h3 id=\"技术基础\">技术基础</h3>\n<p>MAF并非从零开始，而是建立在微软已有的AI技术栈之上：</p>\n<ul>\n<li><strong>Semantic Kernel</strong>：提供强大的编排能力</li>\n<li><strong>AutoGen</strong>：支持先进的多Agent协作和研究驱动技术</li>\n<li><strong>Microsoft.Extensions.AI</strong>：提供标准化的AI构建块</li>\n</ul>\n<p>MAF是这些技术的演进和统一，为.NET开发者提供了一致的Agent开发体验。</p>\n<h3 id=\"核心概念\">核心概念</h3>\n<p>MAF将Agent定义为：<strong>结合推理、上下文和工具来追求目标的系统</strong>。</p>\n<ul>\n<li><strong>推理与决策</strong>：通常由LLM驱动，也可以使用搜索算法、规划系统等</li>\n<li><strong>上下文感知</strong>：对话历史、知识库、企业数据等外部信息</li>\n<li><strong>工具使用</strong>：API、MCP工具、代码执行、数据查询等可调用能力</li>\n</ul>\n<h3 id=\"工作流类型\">工作流类型</h3>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/27e36926-8dfd-4286-ab9c-b0182f01ea6a.png\" /></p>\n<p>MAF支持多种工作流模式，满足不同场景需求：</p>\n<ul>\n<li><strong>Sequential（顺序）</strong>：Agent按顺序执行，结果沿链传递</li>\n<li><strong>Concurrent（并发）</strong>：多个Agent并行工作</li>\n<li><strong>Handoff（交接）</strong>：根据上下文在Agent之间转移控制权</li>\n<li><strong>GroupChat（群聊）</strong>：Agent在共享的实时对话空间中协作</li>\n</ul>\n<h3 id=\"代码示例\">代码示例</h3>\n<p>创建Agent只需几行代码：</p>\n<pre><code class=\"language-csharp\">// 创建写作Agent\nAIAgent writer = new ChatClientAgent(\n    chatClient,\n    new ChatClientAgentOptions\n    {\n        Name = \"Writer\",\n        Instructions = \"Write stories that are engaging and creative.\"\n    });\n\n// 创建编辑Agent\nAIAgent editor = new ChatClientAgent(\n    chatClient,\n    new ChatClientAgentOptions\n    {\n        Name = \"Editor\",\n        Instructions = \"Make the story more engaging, fix grammar, and enhance the plot.\"\n    });\n\n// 组合为工作流\nWorkflow workflow = AgentWorkflowBuilder.BuildSequential(writer, editor);\nAIAgent workflowAgent = await workflow.AsAgentAsync();\n\n// 执行\nvar response = await workflowAgent.RunAsync(\"Write a short story about a haunted house.\");\n</code></pre>\n<h3 id=\"面向开发者的-devui\">面向开发者的 DevUI</h3>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/432af237-cfb3-45f9-8538-56d85dd7b12d.png\" /></p>\n<p>MAF提供了直观的DevUI，帮助开发者可视化设计、调试和监控Agent和工作流，可通过安装<code>Microsoft.Agents.AI.DevUI</code>包快速集成。</p>\n<h3 id=\"生产就绪特性\">生产就绪特性</h3>\n<ul>\n<li><strong>ASP.NET集成</strong>：使用熟悉的Minimal API模式暴露Agent服务</li>\n<li><strong>依赖注入</strong>：通过<code>AddAIAgent</code>注册，支持Keyed Services</li>\n<li><strong>OpenTelemetry</strong>：内置可观测性，一行代码启用遥测</li>\n<li><strong>评估测试</strong>：集成Microsoft.Extensions.AI.Evaluations进行质量评估</li>\n</ul>\n<h2 id=\"34-协议sdk全面支持\">3.4 协议SDK全面支持</h2>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/69d3e61c-ea03-4df6-9db5-456d5b08b42f.png\" /></p>\n<p>.NET生态现在全面支持AI领域的主要协议，包括MCP、A2A和AG-UI协议。</p>\n<h3 id=\"mcp-c-sdk\">MCP C# SDK</h3>\n<p>官方的MCP .NET实现，基于 <code>ModelContextProtocol</code> 库，让你轻松创建MCP Server。.NET 10提供了项目模板，一行命令即可创建：</p>\n<pre><code class=\"language-bash\">dotnet new mcpserver -n MyMcpServer\n</code></pre>\n<p>使用 <code>[McpServerTool]</code> 属性定义工具：</p>\n<pre><code class=\"language-csharp\">[McpServerTool]\n[Description(\"Gets a random number between min and max.\")]\npublic int GetRandomNumber(\n    [Description(\"Minimum value\")] int min,\n    [Description(\"Maximum value\")] int max)\n{\n    return Random.Shared.Next(min, max + 1);\n}\n\n[McpServerTool]\n[Description(\"Describes random weather in the provided city.\")]\npublic string GetCityWeather(\n    [Description(\"Name of the city\")] string city)\n{\n    var weather = new[] { \"sunny\", \"rainy\", \"cloudy\" };\n    return $\"The weather in {city} is {weather[Random.Shared.Next(weather.Length)]}.\";\n}\n</code></pre>\n<p>更棒的是，MCP Server可以直接打包为NuGet包分发，用户通过<code>dnx</code>命令一键安装使用。</p>\n<h3 id=\"a2a-c-sdk\">A2A C# SDK</h3>\n<p>A2A .NET SDK 提供了完整的Agent间通信实现：</p>\n<pre><code class=\"language-bash\">dotnet add package A2A\ndotnet add package A2A.AspNetCore\n</code></pre>\n<p><strong>服务端</strong>：通过 <code>TaskManager</code> 管理Agent，使用 <code>MapA2A</code> 映射端点：</p>\n<pre><code class=\"language-csharp\">var taskManager = new TaskManager();\nvar agent = new EchoAgent();\nagent.Attach(taskManager);  // 注册回调：OnAgentCardQuery、OnMessageReceived\n\napp.MapA2A(taskManager, \"/echo\");\n</code></pre>\n<p><strong>客户端</strong>：使用 <code>A2ACardResolver</code> 发现Agent，<code>A2AClient</code> 发送消息：</p>\n<pre><code class=\"language-csharp\">var cardResolver = new A2ACardResolver(new Uri(\"https://localhost:5048/echo\"));\nvar agentCard = await cardResolver.GetAgentCardAsync();\n\nvar client = new A2AClient(new Uri(agentCard.Url));\nvar response = await client.SendMessageAsync(new MessageSendParams\n{\n    Message = new AgentMessage\n    {\n        Role = MessageRole.User,\n        Parts = [new TextPart { Text = \"Hello!\" }]\n    }\n});\n</code></pre>\n<p><strong>MAF集成</strong>：Microsoft Agent Framework 也提供了A2A协议支持（<code>Microsoft.Agents.A2A</code>），可以将MAF Agent暴露为A2A服务端，实现跨框架的Agent互操作。</p>\n<h3 id=\"net-对-ag-ui-的支持\">.NET 对 AG-UI 的支持</h3>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/3327/f3f9c33f-3d2d-46df-8ea7-84758bf026ec.png\" /></p>\n<p>MAF框架内置了AG-UI支持，实现Agent与用户界面的流式交互：</p>\n<pre><code class=\"language-bash\">dotnet add package Microsoft.Agents.AI.Hosting.AGUI.AspNetCore  # 服务端\ndotnet add package Microsoft.Agents.AI.AGUI                      # 客户端\n</code></pre>\n<p><strong>服务端</strong>：使用 <code>AddAGUI()</code> 注册服务，<code>MapAGUI()</code> 映射端点：</p>\n<pre><code class=\"language-csharp\">builder.Services.AddAGUI();\n\nAIAgent agent = chatClient.AsIChatClient().CreateAIAgent(\n    name: \"Assistant\",\n    instructions: \"你是一个友好的AI助手。\");\n\napp.MapAGUI(\"/\", agent);  // 自动处理SSE流式响应\n</code></pre>\n<p><strong>客户端</strong>：使用 <code>AGUIChatClient</code> 连接服务端，<code>RunStreamingAsync</code> 接收流式响应：</p>\n<pre><code class=\"language-csharp\">AGUIChatClient chatClient = new(httpClient, \"http://localhost:8888\");\nAIAgent agent = chatClient.CreateAIAgent(name: \"client\");\nAgentThread thread = agent.GetNewThread();\n\nawait foreach (var update in agent.RunStreamingAsync(messages, thread))\n{\n    if (update.Contents.OfType&lt;TextContent&gt;().FirstOrDefault() is { } text)\n        Console.Write(text.Text);\n}\n</code></pre>\n<h2 id=\"35-net-对-agent-skills-的支持\">3.5 .NET 对 Agent Skills 的支持</h2>\n<p>Agent Skills是一种轻量级、开放的格式，用于扩展AI Agent的能力。一个Skill本质上就是一个包含<code>SKILL.md</code>文件的文件夹：</p>\n<pre><code>skill-name/\n├── SKILL.md          # 必需：技能描述和使用说明\n├── scripts/          # 可选：可执行脚本\n│   └── tool.cs\n├── references/       # 可选：详细参考文档\n│   └── REFERENCE.md\n└── assets/           # 可选：静态资源\n    └── template.json\n</code></pre>\n<p><strong>SKILL.md格式</strong>：包含YAML frontmatter和Markdown正文：</p>\n<pre><code class=\"language-markdown\">---\nname: split-pdf\ndescription: Split PDF files into separate single-page documents. Use when you need to divide a PDF into multiple files.\nlicense: MIT\n---\n\n# Split PDF\n\n将PDF文件拆分为多个单页文件。\n\n## 使用方法\ndotnet scripts/split-pdf.cs input.pdf output-dir/\n</code></pre>\n<p><strong>.NET 10的独特优势</strong>：File-Based Apps让C#成为Agent Skills脚本的理想选择：</p>\n<pre><code class=\"language-csharp\">#!/usr/bin/env dotnet\n#:package PdfSharpCore@1.3.65\n#:package Spectre.Console@0.49.1\n\nusing PdfSharpCore.Pdf;\nusing PdfSharpCore.Pdf.IO;\nusing Spectre.Console;\n\nif (args.Length &lt; 2)\n{\n    AnsiConsole.MarkupLine(\"[red]用法: dotnet split-pdf.cs &lt;PDF文件&gt; &lt;输出目录&gt;[/]\");\n    return 1;\n}\n\nvar pdfPath = args[0];\nvar outputDir = args[1];\nDirectory.CreateDirectory(outputDir);\n\nusing var doc = PdfReader.Open(pdfPath, PdfDocumentOpenMode.Import);\nfor (int i = 0; i &lt; doc.PageCount; i++)\n{\n    using var output = new PdfDocument();\n    output.AddPage(doc.Pages[i]);\n    output.Save(Path.Combine(outputDir, $\"page_{i + 1:D3}.pdf\"));\n}\n\nAnsiConsole.MarkupLine($\"[green]✅ 拆分完成！生成 {doc.PageCount} 个文件[/]\");\nreturn 0;\n</code></pre>\n<p>与Python相比，.NET File-Based Apps的优势：依赖声明内联在文件中（<code>#:package</code>）、编译时类型检查、支持Native AOT编译实现毫秒级启动。</p>\n<hr />\n<h1 id=\"四展望2026\">四、展望2026</h1>\n<h2 id=\"41-技术趋势预测\">4.1 技术趋势预测</h2>\n<h3 id=\"agent能力持续增强\">Agent能力持续增强</h3>\n<p>2026年，我们将看到更强大的Agent：</p>\n<ul>\n<li><strong>更长的上下文</strong>：处理更复杂的任务</li>\n<li><strong>更好的规划</strong>：多步骤任务的成功率提升</li>\n<li><strong>更强的工具调用</strong>：支持更复杂的工具组合</li>\n</ul>\n<h3 id=\"多模态ai成为标配\">多模态AI成为标配</h3>\n<p>图像、音频、视频的理解和生成将成为AI的基础能力，而不是高级功能。.NET开发者需要准备好处理多模态数据。</p>\n<h3 id=\"ai原生应用架构演进\">AI原生应用架构演进</h3>\n<p>\"AI原生\"将成为新的架构范式，就像\"云原生\"改变了我们构建应用的方式一样。我们需要重新思考：</p>\n<ul>\n<li>如何设计AI友好的API</li>\n<li>如何构建可被AI调用的服务</li>\n<li>如何处理AI的不确定性</li>\n</ul>\n<h2 id=\"42-net开发者的机遇\">4.2 .NET开发者的机遇</h2>\n<h3 id=\"ai-agent-开发需求增长\">AI Agent 开发需求增长</h3>\n<p>企业对定制化AI Agent的需求正在爆发。根据Gartner预测，到2026年，超过80%的企业将部署某种形式的AI Agent。熟悉.NET和AI的开发者，有机会在以下领域大展身手：</p>\n<p><strong>企业级应用场景</strong>：</p>\n<ul>\n<li><strong>智能客服Agent</strong>：基于企业知识库的7x24小时智能问答系统</li>\n<li><strong>业务流程自动化</strong>：订单处理、报表生成、数据分析等重复性任务的自动化</li>\n<li><strong>代码助手</strong>：企业内部的代码审查、文档生成、技术债务检测工具</li>\n<li><strong>DevOps Agent</strong>：自动化部署、监控告警分析、故障诊断</li>\n</ul>\n<p><strong>技术实现路径</strong>：</p>\n<ul>\n<li><strong>开发MCP Server</strong>：将企业内部系统（ERP、CRM、数据库）封装为MCP工具，供AI调用</li>\n<li><strong>构建多Agent协作系统</strong>：使用MAF的Workflow模式，实现复杂业务流程的智能编排</li>\n<li><strong>创建领域专用Agent</strong>：结合.NET生态优势（如金融、制造、医疗），打造行业定制化解决方案</li>\n</ul>\n<p><strong>职业发展机遇</strong>：</p>\n<ul>\n<li><strong>AI应用架构师</strong>：设计企业级AI应用架构</li>\n<li><strong>Agent开发工程师</strong>：熟练掌握MEAI/MAF，成为团队核心</li>\n<li><strong>AI工具开发者</strong>：开发开源MCP Server和Agent Skills，构建个人品牌</li>\n</ul>\n<h3 id=\"net在ai领域的独特优势\">.NET在AI领域的独特优势</h3>\n<p>.NET在AI领域有其独特的优势：</p>\n<ul>\n<li><strong>性能</strong>：对于需要高性能的AI应用，.NET是理想选择</li>\n<li><strong>企业基础</strong>：大量企业系统基于.NET构建，AI增强有天然优势</li>\n<li><strong>工具链成熟</strong>：Visual Studio + Copilot是目前最好的AI辅助开发体验之一</li>\n<li><strong>生态完善</strong>：MEAI/SK/MAF提供了完整的AI开发工具链</li>\n</ul>\n<h3 id=\"持续学习建议\">持续学习建议</h3>\n<p>作为.NET开发者，建议重点关注：</p>\n<ol>\n<li><strong>学习Vibe Coding</strong>：提升AI辅助开发效率</li>\n<li><strong>关注AI模型发展</strong>：了解最新的AI能力和趋势</li>\n<li><strong>掌握MEAI</strong>：这是.NET AI开发的基础</li>\n<li><strong>学习Microsoft Agent Framework</strong>：Agent开发的核心框架</li>\n<li><strong>了解MCP/AG-UI/A2A协议</strong>：AI工具开发的事实标准</li>\n<li><strong>实践Agent开发</strong>：通过实际项目积累经验</li>\n</ol>\n<hr />\n<h1 id=\"五总结\">五、总结</h1>\n<p>2025年是.NET与AI融合的里程碑之年。</p>\n<p>回顾这一年：</p>\n<ul>\n<li><strong>AI进入Agent时代</strong>：从代码补全到自主完成任务，AI能力发生质变</li>\n<li><strong>协议标准化推动生态繁荣</strong>：MCP、A2A、AG-UI等协议构建了互操作基础</li>\n<li><strong>.NET 10带来重要升级</strong>：直接运行.cs文件、性能优化、AI集成增强</li>\n<li><strong>Visual Studio 2026全新体验</strong>：AI Copilot深度集成，开发效率大幅提升</li>\n<li><strong>.NET AI工具链日趋成熟</strong>：MEAI、SK、MAF提供了完整的开发能力</li>\n</ul>\n<p>对于.NET开发者来说，这是最好的时代。我们有成熟的语言和平台，有完善的工具链，有活跃的社区。现在，我们又有了强大的AI助力。</p>\n<p>拥抱AI，不是选择，而是必然。</p>\n<p>未来已来，你准备好了吗？</p>\n<hr />\n<h2 id=\"参考链接\">参考链接</h2>\n<ul>\n<li><a href=\"https://devblogs.microsoft.com/dotnet/announcing-dotnet-10/\" rel=\"noopener nofollow\" target=\"_blank\">.NET 10 发布公告</a></li>\n<li><a href=\"https://www.tiobe.com/tiobe-index/\" rel=\"noopener nofollow\" target=\"_blank\">TIOBE编程语言指数</a></li>\n<li><a href=\"https://www.nuget.org/stats\" rel=\"noopener nofollow\" target=\"_blank\">NuGet统计数据</a></li>\n<li><a href=\"https://modelcontextprotocol.io/\" rel=\"noopener nofollow\" target=\"_blank\">MCP协议官网</a></li>\n<li><a href=\"https://github.com/microsoft/semantic-kernel\" rel=\"noopener nofollow\" target=\"_blank\">Semantic Kernel GitHub</a></li>\n<li><a href=\"https://learn.microsoft.com/dotnet/ai/\" rel=\"noopener nofollow\" target=\"_blank\">Microsoft.Extensions.AI 文档</a></li>\n<li><a href=\"https://github.com/microsoft/agent-framework\" rel=\"noopener nofollow\" target=\"_blank\">Microsoft Agent Framework GitHub</a></li>\n</ul>\n<hr />\n<p><em>本文写于2025年12月25日，预祝所有开发者新年快乐，身体健康，工作顺心，心想事成，万事如意，家庭幸福美满！</em></p>\n<hr />\n<p><strong>欢迎在评论区分享你的2025年感悟以及对2026年的期待，赢取礼品！</strong><br />\n<strong>扫描评论区.NET+AI社区群二维码，共同学习不迷路</strong></p>\n\n</div>\n<div id=\"MySignature\">\n    <div style=\"display: block; border: 2px solid #6ecaa8; padding: 10px;\">  \n<img src=\"https://files.cnblogs.com/files/sheng-jie/maf-course-card-scan.bmp\" />\n<blockquote>\n<b>👆面向.NET开发者的AI Agent 开发课程【.NET+AI | 智能体开发进阶】已上线，欢迎扫码加入学习。👆</b>\n</blockquote>\n</div>\n\n<img src=\"https://files.cnblogs.com/files/sheng-jie/scan-follow.bmp\" />\n<blockquote>\n<b>\n关注我的公众号『向 AI 而行』，我们微信不见不散。\n<br />\n阅罢此文，如果您觉得本文不错并有所收获，请【打赏】或【推荐】，也可【评论】留下您的问题或建议与我交流。\n\n你的支持是我不断创作和分享的不竭动力！</b>\n</blockquote>\n\n<div id=\"AllanboltSignature\" style=\"display: block; border: 2px solid #6ecaa8; padding: 10px;\">    \n        <div>作者：<a href=\"http://www.jianshu.com/u/39ec0e6b1844\" target=\"_blank\">『圣杰』</a></div>\n        <div>出处：<a href=\"http://www.cnblogs.com/sheng-jie/\" target=\"_blank\">http://www.cnblogs.com/sheng-jie/</a></div>\n        <div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。</div>  \n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 08:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sheng-jie\">「圣杰」</a>&nbsp;\n阅读(<span id=\"post_view_count\">574</span>)&nbsp;\n评论(<span id=\"post_comment_count\">9</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI时代代码质量提升实战指南：别让效率成为质量的敌人",
      "link": "https://www.cnblogs.com/wasp520/p/19402247",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wasp520/p/19402247\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 08:42\">\n    <span>AI时代代码质量提升实战指南：别让效率成为质量的敌人</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"ai时代代码质量提升实战指南别让效率成为质量的敌人\">AI时代代码质量提升实战指南：别让效率成为质量的敌人</h1>\n<p><strong>请关注公众号【<a target=\"_blank\">碳硅化合物AI</a>】</strong></p>\n<h2 id=\"摘要\">摘要</h2>\n<p>AI代码生成工具确实让开发效率大幅提升，但同时也带来了新的挑战：代码质量参差不齐、技术债务快速积累、团队对代码理解不深。这篇文章从实际问题出发，结合DevOps、DORA模型、SPACE框架等先进工程管理理念，提出了一套在AI开发模式下保障代码质量的实战方案。通过质量内建、左移测试、价值流分析、度量驱动改进等系统性方法，在享受AI效率红利的同时，确保代码质量不滑坡。文章不仅提供了理论框架，还给出了可落地的实施路径和关键成功因素。</p>\n<hr />\n<h2 id=\"问题ai开发模式下的质量困境\">问题：AI开发模式下的质量困境</h2>\n<p>现在很多团队都在用AI工具生成代码，效率确实上来了，但问题也接踵而至。我见过不少团队，刚开始用AI的时候特别兴奋，觉得终于可以解放双手了，结果用了一段时间发现，代码是写出来了，但质量却越来越差，最后反而更累了。</p>\n<h3 id=\"代码理解盲区你不知道ai在想什么\">代码理解盲区：你不知道AI在想什么</h3>\n<p>最头疼的问题就是代码理解盲区。AI生成的代码不是你手写的，你对代码逻辑不熟悉，就像看别人写的代码一样，总觉得哪里不对劲，但又说不出来。我有个同事，用AI生成了一个复杂的算法，看起来逻辑是对的，但运行起来就是有问题。他花了半天时间才找到问题，原来是AI在边界条件处理上有个小bug，但这个小bug藏得很深，不仔细看根本发现不了。</p>\n<p>更麻烦的是，当代码出问题的时候，你都不知道AI是怎么想的。传统的代码，你至少知道作者当时的思路，但AI生成的代码，你只能靠猜。这就违背了\"代码即文档\"的理念，导致知识传递断层。新人接手项目的时候，看到一堆AI生成的代码，完全不知道从哪下手。</p>\n<h3 id=\"死代码堆积项目里的僵尸军团\">死代码堆积：项目里的\"僵尸军团\"</h3>\n<p>需求变化快，AI生成的代码中很多已经用不上了，但开发者识别不出来。我见过一个项目，代码库里有30%的代码都是死代码，都是AI生成的，但没人敢删，因为不知道删了会不会出问题。这些\"僵尸代码\"不仅占用资源，还增加了维护成本。每次重构的时候，都要先花时间搞清楚哪些代码是活的，哪些是死的。</p>\n<p>更糟糕的是，AI生成的代码往往有很多变体，同一个功能可能有三种不同的实现方式，都躺在代码库里。你改了一个，发现还有两个，改来改去，最后都不知道哪个是对的。</p>\n<h3 id=\"质量参差不齐ai也有心情不好的时候\">质量参差不齐：AI也有\"心情不好\"的时候</h3>\n<p>AI生成的代码量大，但质量不稳定。有时候生成的代码特别好，有时候生成的代码就是垃圾。我见过AI生成的一个方法，有200多行，圈复杂度高达25，正常人根本写不出这样的代码。但AI就生成了，而且看起来还能跑，就是没人敢动。</p>\n<p>缺乏统一的质量标准，导致技术债务快速积累。每个开发者用AI的方式不一样，生成的代码风格也不一样，最后整个项目的代码质量被拉低。你看着代码库，就像看一个拼凑起来的怪物，每个部分都长得不一样。</p>\n<h3 id=\"测试用例负担数量不等于质量\">测试用例负担：数量不等于质量</h3>\n<p>AI虽然能生成测试用例，但大量用例的维护成本也很高。我见过一个项目，AI生成了500多个测试用例，但真正有用的可能就100个。剩下的400个，要么是重复的，要么是测试边界情况但实际不会发生的，要么就是测试用例本身就有问题。</p>\n<p>更麻烦的是，这些测试用例的维护成本很高。每次代码改动，都要检查这些测试用例要不要改。有些测试用例写得特别复杂，你都不知道它在测试什么。最后，测试用例反而成了负担，而不是保障。</p>\n<h3 id=\"恶性循环越跑越快越跑越偏\">恶性循环：越跑越快，越跑越偏</h3>\n<p>AI让开发变快，项目进度更紧，更没时间重构和优化。这形成了\"快速开发-质量下降-维护困难-更没时间优化\"的死亡螺旋</p>\n<p>我见过一个团队，用AI快速开发了一个功能，上线后发现性能有问题，但没时间优化，只能加机器。结果成本越来越高，技术债务越积越多，最后整个项目都推倒重来了。</p>\n<h3 id=\"管理误区ai不是万能的\">管理误区：AI不是万能的</h3>\n<p>老板觉得AI万能，只关注速度，不断催促进度。但AI只是工具，不是魔法。我见过一个老板，看到AI能生成代码，就要求团队把开发时间缩短一半。结果团队为了赶进度，用AI生成了大量低质量代码，最后项目延期了，因为花在修复bug上的时间比开发时间还长。</p>\n<p>缺乏对质量成本的正确认知，是很多管理层的通病。他们不知道，在生产环境修复一个bug的成本，是在开发阶段修复的100倍。他们只看到AI带来的效率提升，没看到质量下降带来的成本增加。</p>\n<p>这些问题如果不解决，AI带来的效率提升最终会被技术债务吞噬。根据DORA研究报告，高质量团队的部署频率是低质量团队的200倍，而变更失败率只有后者的1/3。这说明质量不是效率的敌人，而是效率的基石。你只有把质量做好了，才能真正提升效率。</p>\n<hr />\n<h2 id=\"方法论质量与效率的平衡之道\">方法论：质量与效率的平衡之道</h2>\n<h3 id=\"核心理念质量内建quality-built-in\">核心理念：质量内建（Quality Built-in）</h3>\n<p>在AI开发模式下，我们需要建立\"质量内建\"的理念。这不是说不要效率，而是要在保证质量的前提下提升效率。就像丰田生产系统的\"质量内建\"理念，质量不是检查出来的，而是设计出来的。</p>\n<p>以前我们做质量保障，都是在代码写完之后再检查，发现问题再改。这种方式效率低，成本高。现在我们要把质量保障前移到开发阶段，在写代码的时候就保证质量。这样虽然前期投入多一点，但后期成本会大幅降低。</p>\n<p><strong>质量内建的核心思想</strong>：</p>\n<p><strong>左移测试（Shift Left）</strong>：把质量保障活动前移到开发阶段，而不是等到测试阶段才发现问题。AI生成的代码应该在提交前就完成质量检查。我见过一个团队，他们在本地就配置了pre-commit hook，每次提交代码前都会自动运行静态分析和单元测试。虽然每次提交多花了几秒钟，但避免了后期大量的bug修复工作。</p>\n<p><strong>持续反馈</strong>：建立快速反馈机制，让开发者能够立即知道代码质量问题，而不是等到代码审查或测试阶段。以前我们发现问题可能要等几天，现在几分钟就能知道。这样开发者可以立即修复问题，不会让问题积累。我见过一个团队，他们在IDE里集成了代码质量检查，写代码的时候就能看到问题提示，就像写Word文档时的拼写检查一样。</p>\n<p><strong>自动化优先</strong>：尽可能用自动化工具替代人工检查，减少人为错误，提高一致性。人工检查容易漏掉问题，而且不同的人标准不一样。自动化工具可以保证一致性，而且不会累。我见过一个团队，他们用自动化工具检查代码，发现的问题比人工检查多30%，而且检查时间缩短了80%。</p>\n<h3 id=\"理论基础dora模型与space框架\">理论基础：DORA模型与SPACE框架</h3>\n<h4 id=\"dora核心指标\">DORA核心指标</h4>\n<p>DORA（DevOps Research and Assessment）研究定义了四个关键指标来衡量研发效能：<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>关键洞察</strong>：高质量团队不是通过降低部署频率来保证质量，而是通过质量内建实现高频部署且低失败率。</p>\n<h4 id=\"space框架\">SPACE框架</h4>\n<p>SPACE框架从五个维度评估研发效能：<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"关键原则\">关键原则</h3>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"如何解决问题\">如何解决问题</h2>\n<h3 id=\"1-认识层面打破人月神话的陷阱\">1. 认识层面：打破\"人月神话\"的陷阱</h3>\n<h4 id=\"11-对老板和管理层理解质量成本模型\">1.1 对老板和管理层：理解质量成本模型</h4>\n<p>很多老板觉得，做质量保障就是花钱，看不到直接收益。其实不是这样的，质量保障是投资，不是成本。你前期投入一点，后期能省很多。</p>\n<p><strong>质量成本金字塔</strong>：<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>关键洞察</strong>：在AI开发模式下，预防成本虽然增加了（需要审查AI生成的代码），但失败成本会大幅降低。根据IBM的研究，在生产环境修复一个Bug的成本是在开发阶段修复的100倍。也就是说，你在开发阶段花1小时修复bug，相当于在生产环境节省100小时。</p>\n<p>我见过一个团队，他们用AI生成代码，但坚持做代码审查。虽然每次审查多花了30分钟，但避免了后期大量的bug修复工作。算下来，他们花在质量保障上的时间，比不做质量保障的团队少了一半。</p>\n<p><strong>建议措施</strong>：</p>\n<p><strong>设定合理的质量指标</strong>：不要只看代码量，要看代码质量。设定代码覆盖率、技术债务率、变更失败率等指标，纳入项目考核。我见过一个团队，他们把代码质量指标纳入KPI，结果代码质量提升了40%，bug数量减少了60%。</p>\n<p><strong>建立质量成本模型</strong>：量化质量投入的ROI。让老板看到，花在质量保障上的钱，能带来多少收益。我见过一个团队，他们做了一个质量成本模型，发现花在质量保障上的每1块钱，能节省10块钱的失败成本。老板看到这个数据，立马就支持了。</p>\n<p><strong>采用DORA指标衡量团队效能</strong>：不要只看开发速度，要看交付质量和稳定性。DORA指标能全面反映团队的效能，包括部署频率、变更前置时间、变更失败率、MTTR等。我见过一个团队，他们用DORA指标衡量效能，发现虽然开发速度不是最快的，但交付质量是最好的，客户满意度也是最高的。</p>\n<p><strong>为质量活动预留时间预算</strong>：建议每个迭代20%时间用于质量保障。这20%的时间包括代码审查、重构、技术债务清理等。我见过一个团队，他们每个迭代都预留20%的时间做质量保障，结果技术债务越来越少，开发速度反而越来越快。</p>\n<h4 id=\"12-对程序员建立质量意识\">1.2 对程序员：建立质量意识</h4>\n<p>很多程序员觉得，用AI生成代码，自己就不用管质量了。其实不是这样的，AI是放大器，不是替代品。<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>建议措施</strong>：<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"2-软件工程方法论建立质量保障体系\">2. 软件工程方法论：建立质量保障体系</h3>\n<h4 id=\"21-质量门禁机制cicd流水线集成\">2.1 质量门禁机制：CI/CD流水线集成</h4>\n<p>质量门禁不是简单的检查点，而是贯穿整个开发流程的自动化质量保障体系。<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>关键技术点详解</strong>：<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>1. 静态代码分析（Static Code Analysis）</strong></p>\n<p>静态代码分析能自动发现80%以上的潜在问题，比人工检查效率高得多。建议先用语言特定工具（ESLint、Pylint等），上手后再用SonarQube等综合性工具。阈值设定要合理：代码覆盖率≥80%，圈复杂度≤10，重复代码率≤3%，技术债务率≤5%。</p>\n<p><strong>2. 单元测试覆盖率</strong></p>\n<p>AI生成代码必须达到80%以上覆盖率（核心业务≥90%），测试用例也要经过审查确保有效性。</p>\n<p><strong>3. 代码审查流程（Code Review）</strong></p>\n<p>代码审查是质量保障的关键环节，参考Google标准，重点关注7个维度：<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>代码审查要给出建设性反馈，帮助作者提升代码质量，而不是简单找茬。</p>\n<p><strong>4. 依赖扫描（Dependency Scanning）</strong></p>\n<p>使用Snyk、OWASP Dependency-Check等工具检测CVE漏洞、许可证合规和版本管理。高危漏洞自动阻断合并。</p>\n<p><strong>5. 安全扫描（Security Scanning）</strong></p>\n<p>包括SAST（SonarQube、Checkmarx）、SCA（Snyk、WhiteSource）、密钥泄露检测（GitGuardian）和容器镜像扫描（Trivy）。</p>\n<h4 id=\"22-技术债务管理量化与可视化\">2.2 技术债务管理：量化与可视化</h4>\n<p>技术债务不是\"欠债\"，而是\"投资决策\"。关键是要量化债务成本，让管理层看到债务的代价。</p>\n<p><strong>技术债务量化模型</strong>：<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>技术债务分类</strong>：<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>技术债务管理流程</strong>：</p>\n<ol>\n<li><strong>识别</strong>：使用工具自动识别（SonarQube、CodeClimate）</li>\n<li><strong>评估</strong>：评估债务的严重程度和修复成本</li>\n<li><strong>优先级</strong>：根据业务影响和技术影响确定优先级</li>\n<li><strong>计划</strong>：制定重构计划，分配资源</li>\n<li><strong>执行</strong>：每个迭代预留20%时间用于技术债务清理</li>\n<li><strong>监控</strong>：持续监控债务趋势，防止债务积累</li>\n</ol>\n<p><strong>技术债务预算（Technical Debt Budget）</strong>：</p>\n<ul>\n<li>每个迭代预留20%时间用于技术债务清理</li>\n<li>新功能开发时，如果引入技术债务，必须在同一迭代内清理</li>\n<li>建立技术债务看板，可视化债务趋势</li>\n</ul>\n<h4 id=\"23-代码质量度量建立质量仪表盘\">2.3 代码质量度量：建立质量仪表盘</h4>\n<p>建立可量化的质量指标，用数据驱动质量改进。</p>\n<p><strong>核心质量指标（Quality Metrics）</strong>：<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>质量仪表盘（Quality Dashboard）</strong>：</p>\n<p>建立实时质量仪表盘，可视化展示：</p>\n<ul>\n<li>质量趋势：代码质量随时间的变化趋势</li>\n<li>质量分布：不同模块、不同团队的质量分布</li>\n<li>技术债务趋势：技术债务的积累和清理趋势</li>\n<li>DORA指标：部署频率、变更前置时间、变更失败率、MTTR</li>\n</ul>\n<p><strong>度量驱动改进（Metrics-Driven Improvement）</strong>：</p>\n<ol>\n<li><strong>设定基线</strong>：建立当前质量基线</li>\n<li><strong>设定目标</strong>：设定改进目标（SMART原则）</li>\n<li><strong>持续监控</strong>：定期检查质量指标</li>\n<li><strong>分析根因</strong>：当指标异常时，分析根本原因</li>\n<li><strong>采取行动</strong>：制定改进措施并执行</li>\n<li><strong>验证效果</strong>：验证改进措施是否有效</li>\n</ol>\n<h3 id=\"3-关键措施从规范到执行的完整体系\">3. 关键措施：从规范到执行的完整体系</h3>\n<h4 id=\"31-ai代码生成规范建立使用边界\">3.1 AI代码生成规范：建立使用边界</h4>\n<p><strong>明确生成范围</strong>：</p>\n<p><strong>AI代码生成使用边界</strong>：<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>生成后必审查</strong>：AI生成的代码必须经过人工审查（≥30分钟），审查重点包括逻辑正确性、安全性、性能、可维护性。保留生成记录，建立AI代码知识库。</p>\n<h4 id=\"32-代码审查机制google标准实践\">3.2 代码审查机制：Google标准实践</h4>\n<p>代码审查不是找茬，而是知识传递和质量保障。</p>\n<p><strong>审查流程</strong>：<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>审查原则（Google Code Review Standards）</strong>：</p>\n<ol>\n<li><strong>审查者应该批准那些改进代码库的PR</strong>，即使不完美</li>\n<li><strong>审查者应该追求\"正确\"而不是\"完美\"</strong></li>\n<li><strong>审查者应该给出建设性的反馈</strong>，解释为什么需要修改</li>\n<li><strong>审查者应该尽快完成审查</strong>，不要阻塞开发者</li>\n</ol>\n<p><strong>审查清单（Code Review Checklist）</strong>：</p>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> <strong>设计</strong>：代码设计是否合理？是否符合SOLID原则？</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> <strong>功能</strong>：代码是否实现了预期功能？是否有边界情况处理？</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> <strong>测试</strong>：是否有足够的测试覆盖？测试用例是否有效？</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> <strong>复杂度</strong>：代码是否过于复杂？是否可以简化？</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> <strong>命名</strong>：变量、方法、类名是否清晰？是否遵循命名规范？</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> <strong>注释</strong>：关键逻辑是否有注释？注释是否准确？</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> <strong>性能</strong>：是否有性能问题？是否有优化空间？</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> <strong>安全</strong>：是否有安全漏洞？是否有敏感信息泄露？</label></li>\n<li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"\" type=\"checkbox\" /><label> <strong>风格</strong>：是否符合团队编码规范？</label></li>\n</ul>\n<p><strong>审查时间管理</strong>：</p>\n<ul>\n<li>小型PR（&lt;200行）：审查时间≤2小时</li>\n<li>中型PR（200-500行）：审查时间≤4小时</li>\n<li>大型PR（&gt;500行）：建议拆分成多个小PR</li>\n<li>AI生成的代码：审查时间≥30分钟</li>\n</ul>\n<h4 id=\"33-测试策略优化测试金字塔实践\">3.3 测试策略优化：测试金字塔实践</h4>\n<p>遵循测试金字塔原则，建立分层的测试策略。</p>\n<p><strong>测试金字塔</strong>：<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>1. 单元测试（Unit Tests）- 70%</strong></p>\n<p>快速、独立、可重复，执行时间&lt;1分钟。覆盖单个方法、单个类，用Mock和Stub隔离外部依赖。AI生成代码必须编写单元测试，测试用例也要经过审查。</p>\n<p><strong>2. 集成测试（Integration Tests）- 20%</strong></p>\n<p>验证模块间交互，覆盖API接口、数据库交互、外部服务调用，执行时间&lt;10分钟。</p>\n<p><strong>3. 端到端测试（E2E Tests）- 10%</strong></p>\n<p>验证完整业务流程，只测试关键用户路径，执行时间&lt;30分钟。</p>\n<p><strong>测试用例质量</strong>：关注有效性而非数量，审查是否覆盖所有分支和边界情况，定期优化删除冗余用例。</p>\n<p><strong>自动化回归</strong>：每次代码提交、每日构建、发布前触发，并行执行缩短时间，失败立即通知。</p>\n<h3 id=\"4-组织支撑构建质量文化\">4. 组织支撑：构建质量文化</h3>\n<p>质量不是工具和流程的问题，而是文化和组织的问题。</p>\n<h4 id=\"41-质量文化从质量是qa的责任到质量是每个人的责任\">4.1 质量文化：从\"质量是QA的责任\"到\"质量是每个人的责任\"</h4>\n<p><strong>文化转变</strong>：</p>\n<ul>\n<li><strong>旧观念</strong>：质量是QA的责任，开发只管写代码</li>\n<li><strong>新观念</strong>：质量是每个人的责任，开发要对自己的代码质量负责</li>\n</ul>\n<p><strong>建立质量文化的关键措施</strong>：</p>\n<ol>\n<li><strong>领导示范</strong>：管理层要重视质量，为质量活动提供资源支持</li>\n<li><strong>质量分享</strong>：定期组织质量分享会，分享最佳实践和失败案例</li>\n<li><strong>质量奖励</strong>：设立质量奖，奖励质量优秀的团队和个人</li>\n<li><strong>质量培训</strong>：定期组织质量培训，提升团队的质量意识</li>\n</ol>\n<h4 id=\"42-培训体系持续学习与改进\">4.2 培训体系：持续学习与改进</h4>\n<p><strong>培训内容</strong>：</p>\n<ol>\n<li>\n<p><strong>代码质量基础</strong>：</p>\n<ul>\n<li>编码规范：团队编码规范、最佳实践</li>\n<li>代码审查：如何做好代码审查</li>\n<li>测试策略：如何编写有效的测试用例</li>\n</ul>\n</li>\n<li>\n<p><strong>工具使用</strong>：</p>\n<ul>\n<li>静态分析工具：SonarQube、Checkstyle等</li>\n<li>测试框架：JUnit、TestNG、Mockito等</li>\n<li>CI/CD工具：Jenkins、GitLab CI、GitHub Actions等</li>\n</ul>\n</li>\n<li>\n<p><strong>AI工具使用</strong>：</p>\n<ul>\n<li>如何有效使用AI生成代码</li>\n<li>如何审查AI生成的代码</li>\n<li>如何优化Prompt提升AI生成代码质量</li>\n</ul>\n</li>\n</ol>\n<p><strong>培训方式</strong>：</p>\n<ul>\n<li><strong>内部培训</strong>：技术分享会、代码审查工作坊</li>\n<li><strong>外部培训</strong>：参加行业会议、在线课程</li>\n<li><strong>实践驱动</strong>：通过实际项目实践，边做边学</li>\n</ul>\n<h4 id=\"43-激励机制质量与绩效挂钩\">4.3 激励机制：质量与绩效挂钩</h4>\n<p><strong>质量指标纳入绩效考核</strong>：</p>\n<ul>\n<li>\n<p><strong>个人指标</strong>：</p>\n<ul>\n<li>代码审查参与度：审查PR数量、审查质量</li>\n<li>代码质量：代码复杂度、测试覆盖率</li>\n<li>技术债务清理：清理的技术债务数量</li>\n</ul>\n</li>\n<li>\n<p><strong>团队指标</strong>：</p>\n<ul>\n<li>DORA指标：部署频率、变更失败率、MTTR</li>\n<li>质量趋势：代码质量趋势、技术债务趋势</li>\n<li>质量文化：质量分享次数、质量改进提案</li>\n</ul>\n</li>\n</ul>\n<p><strong>奖励机制</strong>：</p>\n<ul>\n<li><strong>质量之星</strong>：每月评选质量优秀的开发者</li>\n<li><strong>质量团队</strong>：每季度评选质量优秀的团队</li>\n<li><strong>质量改进奖</strong>：奖励提出质量改进建议的团队</li>\n</ul>\n<h4 id=\"44-工具支持降低质量保障成本\">4.4 工具支持：降低质量保障成本</h4>\n<p><strong>工具选型原则</strong>：自动化优先、集成友好、易于使用、可扩展性</p>\n<p><strong>推荐工具栈</strong>：</p>\n<ul>\n<li>代码质量分析：SonarQube、CodeClimate</li>\n<li>代码审查：GitHub、GitLab、Phabricator</li>\n<li>CI/CD：Jenkins、GitLab CI、GitHub Actions</li>\n<li>测试框架：JUnit、TestNG、Pytest</li>\n<li>依赖扫描：Snyk、OWASP Dependency-Check</li>\n<li>安全扫描：Checkmarx、Veracode</li>\n</ul>\n<hr />\n<h2 id=\"如何落地以公司级研发产品线为例\">如何落地：以公司级研发产品线为例</h2>\n<h3 id=\"阶段一建立基础1-2个月\">阶段一：建立基础（1-2个月）</h3>\n<p>这个阶段是最关键的，基础打不好，后面就很难推进了。我见过一个团队，他们想一步到位，结果工具配置不好，流程也不清楚，团队就不愿意用了。所以，这个阶段要稳扎稳打，先把基础打好。</p>\n<h4 id=\"11-搭建质量平台\">1.1 搭建质量平台</h4>\n<p>搭建质量平台是第一步，也是最关键的一步。平台搭建好了，后面的工作就好做了。我见过一个团队，他们花了一个月时间搭建平台，配置工具，建立流程。虽然前期投入大，但后面就轻松了。</p>\n<p><strong>技术架构</strong>：</p>\n<p>架构设计要简单，不要搞得太复杂。我见过一个团队，他们设计了很复杂的架构，结果维护成本很高，团队也不愿意用。后来他们简化了架构，只保留核心功能，团队就愿意用了。<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>实施步骤</strong>：</p>\n<p><strong>1. 集成SonarQube</strong>：安装配置服务器（注意性能），配置合理的质量阈值（建议从低阈值开始逐步提高），集成到CI/CD流水线实现自动化。</p>\n<p><strong>2. 配置CI/CD流水线</strong>：建立标准化的CI/CD模板（简单易用），集成质量门禁（避免误报），配置自动化通知机制（及时但不频繁）。</p>\n<p><strong>3. 建立代码审查流程</strong>：配置代码审查工具（GitLab/GitHub PR），建立明确的审查规则和流程，配置合理的通知机制。</p>\n<h4 id=\"12-制定规范\">1.2 制定规范</h4>\n<p><strong>规范文档</strong>：</p>\n<ol>\n<li>\n<p><strong>AI代码生成规范</strong>：</p>\n<ul>\n<li>明确AI生成代码的使用场景</li>\n<li>规定AI生成代码的审查要求</li>\n<li>建立AI代码知识库</li>\n</ul>\n</li>\n<li>\n<p><strong>代码审查清单</strong>：</p>\n<ul>\n<li>制定标准化的审查清单</li>\n<li>明确审查重点和标准</li>\n<li>建立审查反馈模板</li>\n</ul>\n</li>\n<li>\n<p><strong>质量指标阈值</strong>：</p>\n<ul>\n<li>代码覆盖率：新增代码≥80%</li>\n<li>圈复杂度：单个方法≤10</li>\n<li>重复代码率：≤3%</li>\n<li>技术债务率：≤5%</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"阶段二试点推广2-3个月\">阶段二：试点推广（2-3个月）</h3>\n<h4 id=\"21-选择试点项目\">2.1 选择试点项目</h4>\n<p><strong>试点项目选择标准</strong>：</p>\n<ul>\n<li>中等规模：代码量在1-5万行之间</li>\n<li>活跃开发：有持续的开发活动</li>\n<li>团队配合：团队愿意尝试新流程</li>\n<li>代表性：能代表公司主要技术栈</li>\n</ul>\n<p><strong>试点实施步骤</strong>：</p>\n<ol>\n<li>\n<p><strong>项目启动会</strong>：</p>\n<ul>\n<li>介绍质量保障体系</li>\n<li>明确试点目标和期望</li>\n<li>解答团队疑问</li>\n</ul>\n</li>\n<li>\n<p><strong>流程执行</strong>：</p>\n<ul>\n<li>严格执行质量流程</li>\n<li>记录问题和反馈</li>\n<li>每周进行回顾和改进</li>\n</ul>\n</li>\n<li>\n<p><strong>数据收集</strong>：</p>\n<ul>\n<li>收集质量指标数据</li>\n<li>收集团队反馈</li>\n<li>分析流程效果</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"22-培训团队\">2.2 培训团队</h4>\n<p><strong>培训计划</strong>：</p>\n<ol>\n<li>\n<p><strong>质量意识培训</strong>（2小时）：</p>\n<ul>\n<li>质量成本模型</li>\n<li>质量内建理念</li>\n<li>DORA指标介绍</li>\n</ul>\n</li>\n<li>\n<p><strong>工具使用培训</strong>（4小时）：</p>\n<ul>\n<li>SonarQube使用</li>\n<li>CI/CD流程</li>\n<li>代码审查工具</li>\n</ul>\n</li>\n<li>\n<p><strong>实践工作坊</strong>（4小时）：</p>\n<ul>\n<li>代码审查实战</li>\n<li>测试用例编写</li>\n<li>质量指标解读</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"阶段三全面推广3-6个月\">阶段三：全面推广（3-6个月）</h3>\n<h4 id=\"31-推广到所有项目\">3.1 推广到所有项目</h4>\n<p><strong>推广策略</strong>：</p>\n<ol>\n<li>\n<p><strong>分批推广</strong>：</p>\n<ul>\n<li>第一批：核心项目（1个月）</li>\n<li>第二批：重要项目（1个月）</li>\n<li>第三批：所有项目（1个月）</li>\n</ul>\n</li>\n<li>\n<p><strong>建立质量看板</strong>：</p>\n<ul>\n<li>可视化质量指标</li>\n<li>实时监控质量趋势</li>\n<li>自动生成质量报告</li>\n</ul>\n</li>\n<li>\n<p><strong>定期质量回顾</strong>：</p>\n<ul>\n<li>每月质量回顾会</li>\n<li>分析质量趋势</li>\n<li>识别改进机会</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"32-持续优化\">3.2 持续优化</h4>\n<p><strong>优化机制</strong>：</p>\n<ol>\n<li>\n<p><strong>度量驱动改进</strong>：</p>\n<ul>\n<li>定期分析质量指标</li>\n<li>识别异常和趋势</li>\n<li>制定改进措施</li>\n</ul>\n</li>\n<li>\n<p><strong>反馈循环</strong>：</p>\n<ul>\n<li>收集团队反馈</li>\n<li>分析流程问题</li>\n<li>持续优化流程</li>\n</ul>\n</li>\n<li>\n<p><strong>最佳实践沉淀</strong>：</p>\n<ul>\n<li>总结成功经验</li>\n<li>形成最佳实践文档</li>\n<li>在团队内部分享</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"关键成功因素\">关键成功因素</h3>\n<h4 id=\"1-管理层支持\">1. 管理层支持</h4>\n<p><strong>如何获得管理层支持</strong>：</p>\n<ul>\n<li><strong>数据说话</strong>：用数据展示质量问题的成本</li>\n<li><strong>ROI分析</strong>：展示质量投入的回报</li>\n<li><strong>对标分析</strong>：对比行业最佳实践</li>\n<li><strong>试点成果</strong>：用试点项目的成果说服管理层</li>\n</ul>\n<h4 id=\"2-工具自动化\">2. 工具自动化</h4>\n<p><strong>自动化原则</strong>：</p>\n<ul>\n<li><strong>能自动化的绝不人工</strong>：减少人为错误，提高一致性</li>\n<li><strong>快速反馈</strong>：自动化检查要在几分钟内完成</li>\n<li><strong>集成友好</strong>：工具要能无缝集成到开发流程中</li>\n</ul>\n<h4 id=\"3-循序渐进\">3. 循序渐进</h4>\n<p><strong>实施策略</strong>：</p>\n<ul>\n<li><strong>不要一次性要求太高</strong>：逐步提升标准</li>\n<li><strong>先易后难</strong>：先实施容易的，再实施困难的</li>\n<li><strong>允许试错</strong>：给团队试错和调整的空间</li>\n</ul>\n<h4 id=\"4-持续改进\">4. 持续改进</h4>\n<p><strong>改进机制</strong>：</p>\n<ul>\n<li><strong>定期回顾</strong>：每月进行质量回顾</li>\n<li><strong>数据驱动</strong>：用数据指导改进方向</li>\n<li><strong>快速迭代</strong>：小步快跑，持续优化</li>\n</ul>\n<h3 id=\"预期效果\">预期效果</h3>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"总结\">总结</h2>\n<p>AI代码生成工具确实能大幅提升开发效率，但我们不能忽视代码质量。通过建立质量内建、左移测试、价值流分析、度量驱动改进等系统性方法，可以在享受AI效率红利的同时，确保代码质量不滑坡。</p>\n<h3 id=\"核心观点\">核心观点</h3>\n<ol>\n<li><strong>质量内建，而非事后检查</strong>：质量不是检查出来的，而是设计出来的。要将质量保障活动前移到开发阶段，建立质量门禁机制。</li>\n<li><strong>效率和质量相辅相成</strong>：根据DORA研究，高质量团队的部署频率是低质量团队的200倍，而变更失败率只有后者的1/3。高质量不是效率的敌人，而是效率的基石。</li>\n<li><strong>度量驱动改进</strong>：建立可量化的质量指标，用数据说话。通过DORA指标、SPACE框架、质量仪表盘等工具，持续监控和改进。</li>\n<li><strong>技术债务要量化管理</strong>：技术债务不是\"欠债\"，而是\"投资决策\"。要量化债务成本，让管理层看到债务的代价，建立债务管理机制。</li>\n<li><strong>组织文化是关键</strong>：质量不是工具和流程的问题，而是文化和组织的问题。要建立\"质量是每个人的责任\"的文化氛围。</li>\n</ol>\n<h3 id=\"行动建议\">行动建议</h3>\n<p><strong>对管理层</strong>：</p>\n<ul>\n<li>理解质量成本模型，认识到质量投入的ROI</li>\n<li>为质量活动提供资源支持，预留质量预算</li>\n<li>将质量指标纳入绩效考核，建立激励机制</li>\n</ul>\n<p><strong>对技术团队</strong>：</p>\n<ul>\n<li>建立质量内建意识，不要依赖后期测试</li>\n<li>善用AI工具，但保持对代码的掌控力</li>\n<li>参与质量度量，了解自己的代码质量趋势</li>\n</ul>\n<p><strong>对组织</strong>：</p>\n<ul>\n<li>建立质量文化，从\"质量是QA的责任\"到\"质量是每个人的责任\"</li>\n<li>提供工具和平台支持，降低质量保障成本</li>\n<li>持续学习和改进，跟上行业最佳实践</li>\n</ul>\n<h3 id=\"未来展望\">未来展望</h3>\n<p>随着AI技术的不断发展，代码生成能力会越来越强，但质量保障的重要性不会降低，反而会更加重要。我见过一些团队，他们觉得AI这么强，质量保障就不需要了。结果代码质量越来越差，最后还是要做质量保障。</p>\n<p><strong>持续学习</strong>：AI技术在快速发展，我们要跟上节奏。我见过一个团队，他们定期学习AI技术，了解最新的工具和方法，结果用AI的效率越来越高。另一个团队，他们不学习，还用老方法，结果效率就低了。</p>\n<p><strong>持续改进</strong>：质量保障体系不是一成不变的，要根据实践经验持续优化。我见过一个团队，他们每个季度都会回顾质量保障体系，发现问题就改进，结果体系越来越完善。</p>\n<p><strong>持续创新</strong>：AI在质量保障中的应用还有很多空间。比如AI代码审查，可以自动发现一些问题，减轻审查者的负担。AI测试生成，可以自动生成测试用例，提高测试效率。我见过一个团队，他们用AI做代码审查，发现问题的效率提升了50%。</p>\n<p>但记住，AI是工具，不是替代品。我们要善用AI，但不能被AI绑架。我见过一个团队，他们完全依赖AI，结果AI出错了，他们也不知道，最后出了问题。只有保持对代码的掌控力，建立完善的质量保障体系，才能在AI时代走得更远。</p>\n<h3 id=\"写在最后\">写在最后</h3>\n<p>质量保障不是一朝一夕的事，需要长期坚持。我见过很多团队，他们一开始很重视质量保障，但坚持了一段时间就松懈了，结果质量又下降了。所以，质量保障要成为习惯，成为文化，才能持续下去。</p>\n<p>另外，质量保障不是一个人的事，是整个团队的事。我见过一个团队，他们只有QA在做质量保障，结果质量还是不好。后来他们让所有人都参与质量保障，质量就提升了。</p>\n<p>最后，质量保障不是成本，是投资。你前期投入一点，后期能省很多。我见过一个团队，他们不愿意做质量保障，结果后期花在修复bug上的时间，比做质量保障的时间多10倍。所以，质量保障是值得的。</p>\n<p>希望这篇文章能帮助正在使用AI工具开发的团队，建立完善的质量保障体系，在享受AI效率红利的同时，确保代码质量不滑坡。记住，质量不是效率的敌人，而是效率的基石。只有把质量做好了，才能真正提升效率。</p>\n<hr />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 08:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wasp520\">wasp</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "《HelloGitHub》第 117 期",
      "link": "https://www.cnblogs.com/xueweihan/p/19400116",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xueweihan/p/19400116\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 08:26\">\n    <span>《HelloGitHub》第 117 期</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>兴趣是最好的老师，<strong>HelloGitHub</strong> 让你对开源感兴趣！</p>\n</blockquote>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"简介\">简介</h2>\n<p><strong>HelloGitHub</strong> 分享 GitHub 上有趣、入门级的开源项目。</p>\n<blockquote>\n<p><a href=\"https://github.com/521xueweihan/HelloGitHub\" rel=\"noopener nofollow\" target=\"_blank\">github.com/521xueweihan/HelloGitHub</a></p>\n</blockquote>\n<p>这里有实战项目、入门教程、黑科技、开源书籍、大厂开源项目等，涵盖多种编程语言 Python、Java、Go、C/C++、Swift...让你在短时间内感受到开源的魅力，爱上开源！</p>\n<hr />\n<blockquote>\n<p>以下为本期内容｜每月 <strong>28</strong> 号更新</p>\n</blockquote>\n<h3 id=\"c-项目\">C 项目</h3>\n<p>1、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/ThatOtherAndrew/Hexecute\" rel=\"noopener nofollow\" target=\"_blank\">Hexecute</a>：Linux 桌面鼠标手势启动器。这是一款基于 Wayland 的手势启动器，可通过鼠标绘制图案快速启动应用。新手势录入只需一条命令并重复绘制 3 次，操作简单直观。所有手势数据均以 JSON 文件形式存储，方便编辑、备份和迁移。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>2、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/DavidXanatos/TaskExplorer\" rel=\"noopener nofollow\" target=\"_blank\">TaskExplorer</a>：更强大的 Windows 任务管理器。这是一款适用于 Windows 平台的高级任务管理工具，相比系统自带的任务管理器，能够实时显示更详细的进程信息，包括线程堆栈、文件句柄和网络连接等。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"c-项目-1\">C# 项目</h3>\n<p>3、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/jayfunc/BetterLyrics\" rel=\"noopener nofollow\" target=\"_blank\">BetterLyrics</a>：沉浸式桌面歌词显示工具。这是一款专为 Windows 设计的沉浸式歌词显示工具，能够自动识别播放器正在播放的音乐，实时检索本地或在线歌词，并通过流畅动画美观地展示在桌面上。来自 <a href=\"https://hellogithub.com/user/SgtQs9c54C8wjnv\" rel=\"noopener nofollow\" target=\"_blank\">@Zhe Fang</a> 的分享</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>4、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/Diorser/LiteMonitor\" rel=\"noopener nofollow\" target=\"_blank\">LiteMonitor</a>：小巧的 Windows 硬件监控工具。这是一款轻量、可定制的 Windows 硬件监控桌面工具，可实时显示 CPU、GPU、内存、网络等信息，支持任务栏显示、鼠标穿透、多语言和报警等功能。来自 <a href=\"https://hellogithub.com/user/DeMs5h4p73Tgi0X\" rel=\"noopener nofollow\" target=\"_blank\">@Diorser</a> 的分享</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>5、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/huynhsontung/Screenbox\" rel=\"noopener nofollow\" target=\"_blank\">Screenbox</a>：极简的 UWP 视频播放器。这是一款基于 LibVLCSharp 构建的视频播放器，拥有美观简洁的界面和流畅的播放体验，支持触屏、画中画、视频截图和投屏等功能，适用于 Windows 10/11 和 Xbox 平台。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"c-项目-2\">C++ 项目</h3>\n<p>6、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/iDescriptor/iDescriptor\" rel=\"noopener nofollow\" target=\"_blank\">iDescriptor</a>：跨平台的 iOS 设备管理工具。这是一款免费、开源、跨平台的 iPhone/iPad 设备管理工具，支持文件管理、导入相册、虚拟定位、AirPlay 投屏、数据线真伪识别等功能，适用于 Windows、Linux 和 macOS 系统。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"go-项目\">Go 项目</h3>\n<p>7、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/antonmedv/gitmal\" rel=\"noopener nofollow\" target=\"_blank\">gitmal</a>：Git 仓库一键转静态网站。这是一款 Go 语言开发的工具，可轻松将 Git 仓库转换为静态网站。它通过解析仓库的文件结构、提交历史和代码内容，提供类似 GitHub 的浏览体验，适用于展示个人开源项目代码。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>8、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/pressly/goose\" rel=\"noopener nofollow\" target=\"_blank\">goose</a>：开箱即用的数据库迁移工具。这是一个 Go 语言开发的数据库迁移工具，提供 CLI 和第三方库两种使用方式，可通过 SQL 文件实现常规迁移，也可编写 Go 代码处理复杂的迁移逻辑，兼容 Postgres、MySQL、ClickHouse 等数据库。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>9、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/KaijuEngine/kaiju\" rel=\"noopener nofollow\" target=\"_blank\">kaiju</a>：Go 语言的高性能游戏引擎。该项目是采用 Go 语言和 Vulkan 图形 API 构建的 2D/3D 游戏引擎，让开发者可以直接用 Go 开发游戏。它内置可视化编辑器、Soloud 音频库和 Bullet3 物理引擎，在降低游戏开发门槛的同时，实现了极高的渲染性能和低内存占用。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>10、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/psviderski/unregistry\" rel=\"noopener nofollow\" target=\"_blank\">unregistry</a>：像 rsync 一样同步 Docker 镜像。该项目可通过简单的 docker pussh 命令，将本地 Docker 镜像直接推送到远程服务器，无需依赖外部容器镜像仓库。仅传输缺失的镜像层，比 docker save/load 更快。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"java-项目\">Java 项目</h3>\n<p>11、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/apache/fesod\" rel=\"noopener nofollow\" target=\"_blank\">fesod</a>：告别内存溢出的 Java 电子表格处理库。这是一个高性能、低内存占用的 Java 电子表格处理库，基于 Apache POI 做了优化和封装，通过流式读取有效避免处理大文件时的 OOM 问题。</p>\n<p>12、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/GoogleContainerTools/jib\" rel=\"noopener nofollow\" target=\"_blank\">jib</a>：开箱即用的 Java 应用镜像构建工具。该项目是 Google 开源的 Java 应用容器镜像构建工具，无需运行 Docker 或编写 Dockerfile 即可构建镜像，提供 Maven/Gradle 插件、Java 库和 CLI 多种使用方式，简化 Java 应用的容器化流程。</p>\n<h3 id=\"javascript-项目\">JavaScript 项目</h3>\n<p>13、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/alpinejs/alpine\" rel=\"noopener nofollow\" target=\"_blank\">alpine</a>：极简轻量级 JavaScript 框架。这是一个轻量级、极简的 JavaScript 框架，专为前端交互设计，提供类似 Vue 的声明式语法，但无需构建工具，可直接在 HTML 中使用。适用于为静态页面增强交互体验，如表单处理、模态框、手风琴菜单等，既解决了 jQuery 繁琐的 DOM 操作，又避免了 Vue/React 等框架的复杂性和性能开销，非常适合前后端分离的轻量级项目或仅需少量动态行为的页面。来自 <a href=\"https://hellogithub.com/user/5dGtvaZ6H3L4QMY\" rel=\"noopener nofollow\" target=\"_blank\">@两双筷子sqldc</a> 的分享</p>\n<pre><code class=\"language-html\">&lt;div x-data=\"{ count: 0 }\"&gt;\n    &lt;button x-on:click=\"count++\"&gt;Increment&lt;/button&gt;\n \n    &lt;span x-text=\"count\"&gt;&lt;/span&gt;\n&lt;/div&gt;\n</code></pre>\n<p>14、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/hellodigua/ChatLab\" rel=\"noopener nofollow\" target=\"_blank\">ChatLab</a>：开箱即用的聊天记录分析工具。这是一款本地优先的聊天记录分析工具，无需上传数据到云端（AI 功能除外），支持 SQL 查询和 AI 智能挖掘、回顾个人聊天历史。来自 <a href=\"https://hellogithub.com/user/WBtGbD6wLYzy52A\" rel=\"noopener nofollow\" target=\"_blank\">@地瓜</a> 的分享</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>15、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/codemirror/dev\" rel=\"noopener nofollow\" target=\"_blank\">dev</a>：多功能 Web 代码编辑器组件。该项目是知名 Web 代码编辑器组件 CodeMirror 的核心开发仓库。通过 npm 即可安装，轻松开发出一个可扩展、易用的代码编辑器，支持语法高亮、自动补全、错误提示、代码折叠等功能。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>16、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/setube/ogame-vue-ts\" rel=\"noopener nofollow\" target=\"_blank\">ogame-vue-ts</a>：纯文字的太空策略游戏。这是一款基于 TypeScript 和 Vue 3 构建的纯文字太空策略游戏，灵感源自经典的 OGame 银河帝国游戏。玩家将在银河系中建设行星与月球、发展科技、打造舰队和防御系统，并进行进攻星球、军官招募等策略玩法。来自 <a href=\"https://hellogithub.com/user/OCYdts5lPczHag4\" rel=\"noopener nofollow\" target=\"_blank\">@谦君</a> 的分享</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>17、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/Lulzx/tinypdf\" rel=\"noopener nofollow\" target=\"_blank\">tinypdf</a>：极简零依赖 PDF 生成库。这是一个用 TypeScript 开发的 PDF 生成库，压缩后体积仅 3.3KB，核心代码不到 400 行。它删除了自定义字体、图片、压缩等非必要功能，适用于生成发票、收据、证书等简单文档。</p>\n<pre><code class=\"language-typescript\">import { pdf } from 'tinypdf'\nimport { writeFileSync } from 'fs'\n\nconst doc = pdf()\n\ndoc.page((ctx) =&gt; {\n  ctx.rect(50, 700, 200, 40, '#2563eb')           // blue rectangle\n  ctx.text('Hello PDF!', 60, 712, 24, { color: '#ffffff' })\n  ctx.line(50, 680, 250, 680, '#000000', 1)       // black line\n})\n\nwriteFileSync('output.pdf', doc.build())\n</code></pre>\n<h3 id=\"kotlin-项目\">Kotlin 项目</h3>\n<p>18、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/rainxchzed/Github-Store\" rel=\"noopener nofollow\" target=\"_blank\">Github-Store</a>：跨平台的 GitHub 应用商店。这是一款基于 Kotlin 开发的跨平台开源应用商店客户端，支持一键发现热门开源项目、下载安装包（如 APK、EXE、DMG 等），以及追踪已安装应用并提示更新。来自 <a href=\"https://hellogithub.com/user/odJT8IizUEw3Gx0\" rel=\"noopener nofollow\" target=\"_blank\">@Rainxch Zed</a> 的分享</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>19、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/Xed-Editor/Xed-Editor\" rel=\"noopener nofollow\" target=\"_blank\">Xed-Editor</a>：适用于 Android 的代码编辑器。这是一款开源的 Android 文本与代码编辑器，内置 Termux 终端可运行 Python 和 Node.js，支持 200+ 编程语言语法高亮、自动缩进和文件管理等功能。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"php-项目\">PHP 项目</h3>\n<p>20、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/monicahq/monica\" rel=\"noopener nofollow\" target=\"_blank\">monica</a>：开源的个人关系管理系统。这是一款基于 Laravel 和 Vue.js 构建的个人关系管理系统，可用于记录和管理与朋友、家人之间的互动细节，比如人情往来、生日提醒和活动安排等。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"python-项目\">Python 项目</h3>\n<p>21、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/hunvreus/devpush\" rel=\"noopener nofollow\" target=\"_blank\">devpush</a>：完全免费开源的自托管 PaaS。这是一个开源、可自托管的 Web 应用部署平台，可作为 Vercel 替代方案。实现在自己的服务器上通过 git 推送，自动完成应用的构建与发布，支持 Python、Node.js、PHP 等多种编程语言。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>22、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/theOehrly/Fast-F1\" rel=\"noopener nofollow\" target=\"_blank\">Fast-F1</a>：F1 比赛数据分析库。该项目是用于获取和分析 F1 赛事数据的 Python 库，支持查询比赛结果、赛程、圈速、轮胎、遥测和天气等多种数据。内置 API 请求和解析结果缓存机制，结合 Pandas 和 Matplotlib，适用于 F1 数据分析、可视化和教学等场景。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>23、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/Gururagavendra/gmail-cleaner\" rel=\"noopener nofollow\" target=\"_blank\">gmail-cleaner</a>：Gmail 邮箱清理工具。这是一款开源、注重隐私的 Gmail 批量清理工具，帮助用户快速整理收件箱。它基于 FastAPI 构建，提供 Web 界面，支持批量退订、删除、归档、标签管理和邮件信息导出等功能。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>24、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/RICHQAQ/PasteMD\" rel=\"noopener nofollow\" target=\"_blank\">PasteMD</a>：一键将 AI 生成内容粘贴到 Word。这是一款基于 Python 的 Windows 托盘工具，可自动将剪贴板中的 Markdown 和网页 AI 的富文本回复，通过 Pandoc 转换为 DOCX 格式，并直接插入到 Word/WPS 光标所在位置。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>25、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/rendercv/rendercv\" rel=\"noopener nofollow\" target=\"_blank\">rendercv</a>：像写代码一样制作你的简历。这是一款基于 Typst 的简历生成器，专为程序员、学生和学术研究人员设计。只需要编写纯文本 YAML 文件，即可一键生成排版精美、专业的 PDF 简历。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"rust-项目\">Rust 项目</h3>\n<p>26、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/reacherhq/check-if-email-exists\" rel=\"noopener nofollow\" target=\"_blank\">check-if-email-exists</a>：无需发邮件验证邮箱有效性的工具。这是一款用 Rust 开发的邮箱验证工具，通过正则表达式、DNS、SMTP 等多重校验，在不发送邮件的情况下验证邮箱有效性，支持 API 和 CLI 等使用方式。</p>\n<p>27、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/pamburus/hl\" rel=\"noopener nofollow\" target=\"_blank\">hl</a>：Rust 高性能命令行日志查看器。这是一款 Rust 写的高性能命令行日志查看和处理工具，能够将 JSON 和 logfmt 格式的结构化日志转换为高亮且易于人类阅读的格式。来自 <a href=\"https://hellogithub.com/user/TJ65FfbQU09PLHM\" rel=\"noopener nofollow\" target=\"_blank\">@刘睿华</a> 的分享</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"swift-项目\">Swift 项目</h3>\n<p>28、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/productdevbook/port-killer\" rel=\"noopener nofollow\" target=\"_blank\">port-killer</a>：一键释放端口的 macOS 应用。这是一款原生 macOS 菜单栏工具，能够自动发现正在监听的 TCP 端口，并一键结束占用进程，方便开发者快速释放常用端口。来自 <a href=\"https://hellogithub.com/user/ZWJkOqsvYbPgD8p\" rel=\"noopener nofollow\" target=\"_blank\">@DeShuiYu</a> 的分享</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"人工智能\">人工智能</h3>\n<p>29、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/Anionex/banana-slides\" rel=\"noopener nofollow\" target=\"_blank\">banana-slides</a>：AI 驱动的 PPT 生成工具。该项目基于 Nano Banana Pro API，能够根据用户的想法、大纲或文档（如 PDF、Markdown）自动生成结构清晰、排版精美的 PPT，并支持通过对话方式调整内容。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>30、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/steveyegge/beads\" rel=\"noopener nofollow\" target=\"_blank\">beads</a>：面向 AI 编程工具的记忆系统。该项目是专为 AI 编程工具设计的记忆系统，采用 Git 和 JSON 作为持久化存储，为 AI 编程智能体提供长期、结构化的记忆，解决其在处理长周期、复杂编程任务时出现的上下文丢失等问题。</p>\n<p>31、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/huggingface/huggingface_hub\" rel=\"noopener nofollow\" target=\"_blank\">huggingface_hub</a>：HF 的官方 Python 客户端。该项目是 Hugging Face 平台官方开源的 Python 客户端，提供了模型、数据集和 Spaces 的下载、上传、管理等功能。</p>\n<pre><code class=\"language-python\">from huggingface_hub import hf_hub_download\n\nhf_hub_download(\n    repo_id=\"deepseek-ai/DeepSeek-V3.2\",\n    filename=\"config.json\"\n)\n</code></pre>\n<p>32、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/changyeyu/LLM-RL-Visualized\" rel=\"noopener nofollow\" target=\"_blank\">LLM-RL-Visualized</a>：图解大模型技术原理。该项目包含 100 多张大模型技术原理图，系统介绍了大模型和强化学习，内容涵盖 LLM/VLM 大模型结构、训练算法（RL、RLHF、GRPO、DPO、SFT、CoT）、效果优化与 RAG 等。来自 <a href=\"https://hellogithub.com/user/59EQqBGDeXApw2L\" rel=\"noopener nofollow\" target=\"_blank\">@leafpVr5x</a> 的分享</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>33、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/vibrantlabsai/ragas\" rel=\"noopener nofollow\" target=\"_blank\">ragas</a>：RAG 应用自动化评测框架。这是一个专门用于评测和优化 RAG 应用的开源框架，提供客观、可量化的评测结果，并支持自动生成测试数据集。</p>\n<pre><code class=\"language-python\">import asyncio\nfrom ragas.metrics.collections import AspectCritic\nfrom ragas.llms import llm_factory\n\n# Setup your LLM\nllm = llm_factory(\"gpt-4o\")\n\n# Create a metric\nmetric = AspectCritic(\n    name=\"summary_accuracy\",\n    definition=\"Verify if the summary is accurate and captures key information.\",\n    llm=llm\n)\n\n# Evaluate\ntest_data = {\n    \"user_input\": \"summarise given text\\nThe company reported an 8% rise in Q3 2024, driven by strong performance in the Asian market. Sales in this region have significantly contributed to the overall growth. Analysts attribute this success to strategic marketing and product localization. The positive trend in the Asian market is expected to continue into the next quarter.\",\n    \"response\": \"The company experienced an 8% increase in Q3 2024, largely due to effective marketing strategies and product adaptation, with expectations of continued growth in the coming quarter.\",\n}\n\nscore = await metric.ascore(\n    user_input=test_data[\"user_input\"],\n    response=test_data[\"response\"]\n)\nprint(f\"Score: {score.value}\")\nprint(f\"Reason: {score.reason}\")\n</code></pre>\n<h3 id=\"其它\">其它</h3>\n<p>34、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/gautamkrishnar/blog-post-workflow\" rel=\"noopener nofollow\" target=\"_blank\">blog-post-workflow</a>：GitHub 个人主页动态自动同步工具。这是一个 GitHub Action 工具，可将你最新的博客文章或其他 RSS 源内容，自动同步展示在 GitHub 个人首页或项目 README 中。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>35、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/DigitalPlatDev/FreeDomain\" rel=\"noopener nofollow\" target=\"_blank\">FreeDomain</a>：领取你的免费域名。该项目是由非营利组织 DigitalPlat 发起，旨在为个人和组织免费提供域名注册服务。用户可注册一个免费域名，并将其托管在 Cloudflare、Hostry 等 DNS 提供商。来自 <a href=\"https://hellogithub.com/user/eK0Bv1dmJPxnrwy\" rel=\"noopener nofollow\" target=\"_blank\">@IZRINO</a> 的分享</p>\n<p>36、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/harmoninux/HiSH\" rel=\"noopener nofollow\" target=\"_blank\">HiSH</a>：鸿蒙上运行 Linux Shell。这是一款专为鸿蒙系统（HarmonyOS）设计的 Linux 模拟器与 Shell 工具。在鸿蒙设备上运行完整的 Linux 环境，让手机或平板变成一个轻量、便携的 Linux 开发终端。来自 <a href=\"https://hellogithub.com/user/3wdstqbPhxDfCBL\" rel=\"noopener nofollow\" target=\"_blank\">@hackeris</a> 的分享</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>37、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/Nigh/I-wanna-clean-keyboard\" rel=\"noopener nofollow\" target=\"_blank\">I-wanna-clean-keyboard</a>：让你在键盘上安心吃泡面的小工具。这是一款用于临时屏蔽笔记本键盘和鼠标输入的 Windows 工具。它采用 AutoHotkey 开发，界面简洁美观，一键即可屏蔽键盘输入，让你在清理键盘、做笔记或吃东西时避免误触，尤其适合笔记本用户。来自 <a href=\"https://hellogithub.com/user/JBczix10rXqNblQ\" rel=\"noopener nofollow\" target=\"_blank\">@vladelaina</a> 的分享</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>38、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/gnmyt/MySpeed\" rel=\"noopener nofollow\" target=\"_blank\">MySpeed</a>：开箱即用的网速测试工具。这是一款开源、轻量级的网络速度监控与统计工具，支持定期执行网速测试并生成统计图表，最多保留 30 天的历史数据。来自 <a href=\"https://hellogithub.com/user/ZWJkOqsvYbPgD8p\" rel=\"noopener nofollow\" target=\"_blank\">@DeShuiYu</a> 的分享</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>39、<a href=\"https://hellogithub.com/periodical/statistics/click?target=https://github.com/seriousm4x/UpSnap\" rel=\"noopener nofollow\" target=\"_blank\">UpSnap</a>：局域网设备唤醒工具。这是一款可自托管的网络唤醒 Web 应用，支持一键唤醒局域网内设备、端口状态监控、定时自动开机和网络设备自动发现功能。来自 <a href=\"https://hellogithub.com/user/i1wAIyo6P3NXkxm\" rel=\"noopener nofollow\" target=\"_blank\">@孤胆枪手</a> 的分享</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"最后\">最后</h2>\n<p>感谢参与分享开源项目的小伙伴们，欢迎更多的开源爱好者来 HelloGitHub 自荐/推荐开源项目。如果你发现了 GitHub 上有趣的项目，就<a href=\"https://hellogithub.com/periodical\" rel=\"noopener nofollow\" target=\"_blank\">点击这里</a>分享给大家伙吧！</p>\n<p>本期有你感兴趣的开源项目吗？如果有的话就留言告诉我吧～如果还没看过瘾，可以<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5MzYyNzQ0MQ==&amp;action=getalbum&amp;album_id=1331197538447310849&amp;scene=173&amp;from_msgid=2247511076&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">点击阅读</a>往期内容。</p>\n<p>感谢您的阅读，如果觉得本期内容还不错的话 <strong>求赞、求分享</strong> ❤️</p>\n\n</div>\n<div id=\"MySignature\">\n    <div>    \n    <p id=\"PSignature\">\n    <br />\n    作者：<a href=\"https://github.com/521xueweihan\" target=\"_blank\">削微寒</a>\n\n    <br />\n    <strong>扫描左侧的二维码可以联系到我</strong>\n    <br />\n\n    <a href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\" rel=\"license\"><img alt=\"知识共享许可协议\" src=\"https://licensebuttons.net/l/by-nc-nd/4.0/88x31.png\" style=\"border-width: 0;\" /></a><br />本作品采用<a href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\" rel=\"license\">署名-非商业性使用-禁止演绎 4.0 国际 </a>进行许可。\n    </p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 08:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xueweihan\">削微寒</a>&nbsp;\n阅读(<span id=\"post_view_count\">233</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}