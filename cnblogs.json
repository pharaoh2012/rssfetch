{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "深入浅出了解生成模型-8：生成加速策略概述",
      "link": "https://www.cnblogs.com/Big-Yellow/p/19530732",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Big-Yellow/p/19530732\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 23:16\">\n    <span>深入浅出了解生成模型-8：生成加速策略概述</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        扩散模型生成加速策略主要包括加速框架优化、Cache策略及量化技术。加速框架方面，可通过指定attention计算后端（如flash_attn）、torch.compile编译、torch.channels_last优化内存访问，或使用xFormers加速attention计算并降低显存，配合CPU卸载、设备分配等显存优化措施。Cache策略利用扩散过程时间冗余，如DeepCache缓存UNet高层特征、FORA复用DiT的Attn和MLP层特征，FBCache基于First Block L1误差判断是否复用残差，CacheDit结合前n层缓存与阈值判断实现加速。量化技术通过PTQ或QAT降低显存并加速，如Bitsandbytes的即时可逆int4/int8量化、SVDQuant分解权重吸收异常值后量化残差、GGUF格式的紧凑编码与多种PTQ量化级别。测试显示，结合channel优化、flash_attn及cache-dit等策略可有效缩短生图时间。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>原文：<a href=\"https://www.big-yellow-j.top/posts/2025/12/29/SDAcceralate.html\" rel=\"noopener nofollow\" target=\"_blank\">https://www.big-yellow-j.top/posts/2025/12/29/SDAcceralate.html</a></p>\n<h2 id=\"扩散模型生成加速策略\">扩散模型生成加速策略</h2>\n<p>Diffusion推理加速的方案，主要包括Cache、量化、分布式推理、采样器优化和蒸馏等。下面内容主要是去对Cache、计算加速框架以及量化技术进行介绍</p>\n<blockquote>\n<p>SD模型加速方式：<a href=\"https://github.com/xlite-dev/Awesome-DiT-Inference?tab=readme-ov-file#Quantization\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/xlite-dev/Awesome-DiT-Inference?tab=readme-ov-file#Quantization</a></p>\n</blockquote>\n<p>不过值得注意的是对于下面内容，首先介绍加速框架（这部分内容主要是介绍进行加速的一些小trick，主要是直接通过api去加速）、cache以及量化一般就会涉及到一些算法的基本原理。所有的测试代码：<a href=\"https://github.com/shangxiaaabb/ProjectCode/blob/main/code/Python/DFModelCode/DF_acceralate/df_acceralate.ipynb\" rel=\"noopener nofollow\" target=\"_blank\">df_acceralate.ipynb</a></p>\n<h3 id=\"一般加速框架以及显存优化措施\">一般加速框架以及显存优化措施</h3>\n<p>这部分内容的话比较杂（直接总结<a href=\"https://huggingface.co/docs/diffusers/optimization/fp16#scaled-dot-product-attention\" rel=\"noopener nofollow\" target=\"_blank\">huggingface</a>内容），1、<strong>直接使用attn计算加速后端</strong>，比如说一般就是直接使用比如说<code>flash_attn</code>进行attention计算加速，比如说：</p>\n<pre><code class=\"language-python\">pipeline.transformer.set_attention_backend(\"_flash_3_hub\") # 启用flash attn计算加速\npipeline.transformer.reset_attention_backend()             # 关闭flash attn计算加速\n</code></pre>\n<p>不过值得注意的是<code>_flash_3_hub</code> 只支持非hopper架构，因此可以直接就使用<code>set_attention_backend(\"flash\")</code>。2、<strong>直接使用</strong><code>torch.compile</code>进行加速，不过值得注意的是<strong>在开始使用过程中会比较慢</strong>，因为在执行时，它会将模型编译为优化的内核，所以相对会比较慢，但是如果对编译后模型进行批量测试在时间上就会有所提升比如说在代码<a href=\"https://github.com/shangxiaaabb/ProjectCode/blob/main/code/Python/DFModelCode/DF_acceralate/df_acceralate.ipynb\" rel=\"noopener nofollow\" target=\"_blank\">df_acceralate.ipynb</a>中测试结果使用compile在z-image上生成5张图片耗时：86.49s（<strong>平均生图时间</strong>4s）不使用compile：29.92（<strong>平均生图时间</strong>5s）；3、使用<code>torch.channels_last</code>去优化数据结构（<a href=\"https://docs.pytorch.org/tutorials/intermediate/memory_format_tutorial.html#performance-gains\" rel=\"noopener nofollow\" target=\"_blank\">torch文档</a>）：最主要的一点是通过channel_last让 GPU 在计算卷积 / attention 时，内存访问更连续，比如说一般数据的输入是NCHW那么在内存访问中格式是：<code>N0C0H0W0, N0C0H0W1, ..., N0C0H1W0, ...</code>这个里面通道C变化最慢，使用channel_list数据格式变为NHWC在内存中访问顺序是：<code>N0H0W0C0, N0H0W0C1, N0H0W0C2, ...</code>值得注意的是两部分数据在shape上是一致的只是strid不一致。使用方式也比较简单：</p>\n<pre><code class=\"language-python\"># 修改模型\nmodel = model.to(memory_format=torch.channels_last)\n# 修改输入\ninput = input.to(memory_format=torch.channels_last)\noutput = model(input)\n...\npipeline.unet.to(memory_format=torch.channels_last)\n</code></pre>\n<h4 id=\"1xformers加速\">1、xFormers加速</h4>\n<blockquote>\n<p>项目地址：<a href=\"https://github.com/facebookresearch/xformers\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/facebookresearch/xformers</a></p>\n</blockquote>\n<p>在SD模型中对于xformers基本使用方式如下所示：</p>\n<pre><code class=\"language-python\">import torch\nfrom diffusers import StableDiffusionXLPipeline\n\npipeline = StableDiffusionXLPipeline.from_pretrained(\n    \"stabilityai/stable-diffusion-xl-base-1.0\",\n    torch_dtype=torch.float16,\n).to(\"cuda\")\n# 使用xformer加速\npipeline.enable_xformers_memory_efficient_attention()\n# 关闭xformer加速\npipeline.disable_xformers_memory_efficient_attention()\n</code></pre>\n<p>xformers作用在于<strong>加速attention计算并降低显存</strong>，除此之外还提供了多种注意力实现方式，如casual attention等。根据<a href=\"https://facebookresearch.github.io/xformers/components/ops.html#xformers.ops.fmha.cutlass.FwOp\" rel=\"noopener nofollow\" target=\"_blank\">官方文档</a>中的描述，对于对于<code>xformers.ops.memory_efficient_attention</code>在使用上参数主要是：1、输入数据也就是QKV的格式上必须满足为：<code>[B, M, H, K]</code>分别表示的是其中B 为batch size, N为序列长度, num_heads为多头注意力头的个数, dim_head则为每个头对应的embeding size；2、attn_bias实际上充当为在使用mask attention时的mask；3、p也就是dropout对应值；4、op为Tuple，用于指定优化self-attention计算所采用的算子。基本使用方式如下：</p>\n<pre><code class=\"language-python\">import xformers.ops as xops\ny = xops.memory_efficient_attention(q, k, v)\ny = xops.memory_efficient_attention(q, k, v, p=0.2) # 使用dropout\ny = xops.memory_efficient_attention(\n    q, k, v,\n    attn_bias=xops.LowerTriangularMask()\n)# 使用casual 注意力\n</code></pre>\n<p>值得着重了解的就是其中<code>attn_bias</code>参数，简单直观的理解：用于控制注意力可见性和结构的统一接口，<strong>既可以表示 mask，也可以表示稀疏/局部/因果等高级注意力模式</strong>，并且以高性能方式融入 attention 内核。比如说：<br />\n1、<code>xops.LowerTriangularMask()</code>：常规的causal注意力也就是下三角mask<br />\n2、<code>xops.LocalAttentionFromBottomRightMask</code>：局部注意力，每个token只能看最近的window_size个token</p>\n<h4 id=\"2显存优化\">2、显存优化</h4>\n<blockquote>\n<p>这部分内容直接总结：<a href=\"https://huggingface.co/docs/diffusers/en/optimization/memory?device-map=pipeline+level#reduce-memory-usage\" rel=\"noopener nofollow\" target=\"_blank\">https://huggingface.co/docs/diffusers/en/optimization/memory?device-map=pipeline+level#reduce-memory-usage</a></p>\n</blockquote>\n<p>对于模型的显存过大可以考虑根据自身的设备进行分配，比如说将模型卸载到CPU或者将VAE等放到其它显卡上，在diffusers就提供了这些方法（这块内容直接问AI进行总结）：<br />\n<strong>1、CPU卸载</strong><br />\n它启用了一种极致级别的逐层（leaf-level / sequential）CPU offloading机制，核心思路是：把模型的计算图中<strong>最底层的参数（leaf modules，即最细粒度的子模块、层或权重块）默认放在 CPU 内存里存储</strong>。在前向传播（forward pass）过程中，只在真正需要计算某个具体层的时候，才把那一小块参数临时从 CPU 拷贝（onload）到 GPU。计算完这层之后，立刻把这块参数再 offload 回 CPU，释放 GPU 显存。然后再加载下一层，以此类推，一层一层顺序执行（sequential）。<br />\n<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231602481-1040500181.webp\" /><br />\n<strong>2、设备分配</strong><br />\n这部分主要是将生成模型中不同模型结构如VAE、CLIP去分配到其它显卡上：</p>\n<pre><code class=\"language-python\">import torch\nfrom diffusers import AutoModel, StableDiffusionXLPipeline\npipeline = StableDiffusionXLPipeline.from_pretrained(\n    \"stabilityai/stable-diffusion-xl-base-1.0\",\n    torch_dtype=torch.float16,\n    device_map=\"balanced\" # 使用balance就可以实现不同设备分配\n)\nprint(pipeline.hf_device_map)\n{'unet': 1, 'vae': 1, 'safety_checker': 0, 'text_encoder': 0}\n</code></pre>\n<p>亦或者直接自己定分配：</p>\n<pre><code class=\"language-python\">import torch\nfrom diffusers import AutoModel\ndevice_map = {\n    'pos_embed': 0, 'time_text_embed': 0, 'context_embedder': 0, 'x_embedder': 0, 'transformer_blocks': 0, 'single_transformer_blocks.0': 0, 'single_transformer_blocks.1': 0, 'single_transformer_blocks.2': 0, 'single_transformer_blocks.3': 0, 'single_transformer_blocks.4': 0, 'single_transformer_blocks.5': 0, 'single_transformer_blocks.6': 0, 'single_transformer_blocks.7': 0, 'single_transformer_blocks.8': 0, 'single_transformer_blocks.9': 0, 'single_transformer_blocks.10': 1, 'single_transformer_blocks.11': 1, 'single_transformer_blocks.12': 1, 'single_transformer_blocks.13': 1, 'single_transformer_blocks.14': 1, 'single_transformer_blocks.15': 1, 'single_transformer_blocks.16': 1, 'single_transformer_blocks.17': 1, 'single_transformer_blocks.18': 1, 'single_transformer_blocks.19': 1, 'single_transformer_blocks.20': 1, 'single_transformer_blocks.21': 'cpu', 'single_transformer_blocks.22': 'cpu', 'single_transformer_blocks.23': 'cpu', 'single_transformer_blocks.24': 'cpu', 'single_transformer_blocks.25': 'cpu', 'single_transformer_blocks.26': 'cpu', 'single_transformer_blocks.27': 'cpu', 'single_transformer_blocks.28': 'cpu', 'single_transformer_blocks.29': 'cpu', 'single_transformer_blocks.30': 'cpu', 'single_transformer_blocks.31': 'cpu', 'single_transformer_blocks.32': 'cpu', 'single_transformer_blocks.33': 'cpu', 'single_transformer_blocks.34': 'cpu', 'single_transformer_blocks.35': 'cpu', 'single_transformer_blocks.36': 'cpu', 'single_transformer_blocks.37': 'cpu', 'norm_out': 'cpu', 'proj_out': 'cpu'\n}\ntransformer = AutoModel.from_pretrained(\n    \"black-forest-labs/FLUX.1-dev\", \n    subfolder=\"transformer\",\n    device_map=device_map,\n    torch_dtype=torch.bfloat16\n)\n</code></pre>\n<h3 id=\"cache策略概述\">cache策略概述</h3>\n<p>cache指的是：<strong>缓存通过存储和重用不同层（例如注意力层和前馈层）的中间输出来加速推理，而不是在每个推理步骤执行整个计算</strong>。它以更多内存为代价显着提高了生成速度，并且不需要额外的训练。主要详细介绍两种：1、DeepCache；2、FORA。对于更加多的cache策略可以看<a href=\"https://zhuanlan.zhihu.com/p/711223667\" rel=\"noopener nofollow\" target=\"_blank\">知乎</a>，<strong>推荐直接使用</strong><a href=\"#cachedit\" rel=\"noopener nofollow\">CacheDit</a>来进行加速。</p>\n<h4 id=\"deepcache策略\">DeepCache策略</h4>\n<blockquote>\n<p>Paper:<a href=\"https://arxiv.org/pdf/2312.00858\" rel=\"noopener nofollow\" target=\"_blank\">https://arxiv.org/pdf/2312.00858</a><br />\nCode:<a href=\"https://link.zhihu.com/?target=https%3A//github.com/horseee/DeepCache\" rel=\"noopener nofollow\" target=\"_blank\">https://link.zhihu.com/?target=https%3A//github.com/horseee/DeepCache</a></p>\n</blockquote>\n<p><strong>主要针对UNet架构</strong>的Diffusion模型进行推理加速。DeepCache 是一种Training-free的扩散模型加速算法，核心思想是<strong>利用扩散模型序列去噪步骤中固有的时间冗余来减少计算开销</strong>。<br />\n<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231603400-1714104454.webp\" /><br />\n基于 U-Net 结构特性，发现相邻去噪步骤的高层特征具有显著时间一致性（Adjacent steps in the denoising process exhibit significant temporal similarity in high-level features.），比如说上图中作者在测试上采用block <span class=\"math inline\">\\(U_2\\)</span>的特征和其它所有的采样步之间相似性计算（图b），因此缓存这些高层特征并仅以低成本更新低层特征，从而避免重复计算。具体方法为：<br />\n<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231602316-18977204.webp\" /><br />\n比如说在官方的使用中有参数：<code>helper.set_params(cache_interval=3,cache_branch_id=0,)</code>表示是每3个时间步进行一次完成forward然后刷新cache，而其中参数cache_branch_id值得是一般而言在UNet中会定义<code>branch 0 → early / down blocks</code>等就是选择哪些层的输出。具体过程如下：t=1进行计算缓存，t=2,3都直接使用缓存，t=4完整计算得到缓存。</p>\n<h4 id=\"fora\">FORA</h4>\n<blockquote>\n<p>Paper: <a href=\"https://arxiv.org/pdf/2407.01425\" rel=\"noopener nofollow\" target=\"_blank\">https://arxiv.org/pdf/2407.01425</a><br />\nCode: <a href=\"https://github.com/prathebaselva/FORA\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/prathebaselva/FORA</a></p>\n</blockquote>\n<p><strong>主要是争对Dit架构</strong>的Diffusion模型进行推理加速。利用 Diffusion Transformer 扩散过程的重复特性实现了可用于DiT的Training-free的Cache加速算法。<br />\n<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231602779-569782593.webp\" /><br />\nFORA的核心在于发现Dit在去噪过程中，<strong>相邻时间步的Attn和MLP层特征存在显著重复性</strong>（如上图所示:在layer0、9、18、27这些层以及250步采样中，随后采样步约往后特征之间相似性也就越高。）。通过Caching特征，FORA 将这些重复计算的中间特征保存并在后续时间步直接复用，避免逐步重新计算。<br />\n<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231603384-1139937541.webp\" /><br />\n具体而言，模型以固定间隔 N 重新计算并缓存特征：当时间步 t 满足 t mod N=0 时，更新所有层的缓存；在后续 N-1 步中，直接检索cached的 Attn 和 MLP 特征，跳过重复计算。这种策略利用了 DiT 架构在邻近时间时间步的特征相似性，在不修改DiT模型结构的前提下实现加速。例如，在 250 步 DDIM 采样中，当 N=3 时，模型仅需在第 3、6、9... 步重新计算特征，其余步骤复用Cache，使计算量减少约 2/3。实验表明，FORA对后期去噪阶段的特征相似性利用更为高效，此时特征变化缓慢，缓存复用的性价比最高。</p>\n<h4 id=\"fbcache\">FBCache</h4>\n<blockquote>\n<p>项目地址：<a href=\"https://github.com/chengzeyi/ParaAttention/blob/main/doc/fastest_flux.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/chengzeyi/ParaAttention/blob/main/doc/fastest_flux.md</a></p>\n</blockquote>\n<p>通过缓存变换器模型中变换器块的输出，并在下一步推理中重新使用它们，可以降低计算成本，加快推理速度。然而，很难决定何时重新使用缓存以确保生成图像的质量。最近，TeaCache 提出，可以使用时间步嵌入来近似模型输出之间的差异。AdaCache 也表明，在多个图像和视频 DiT 基线中，<strong>缓存可以在不牺牲生成质量的情况下显著提高推理速度</strong>。不过，TeaCache 仍然有点复杂，因为它需要重新缩放策略来确保缓存的准确性。在 ParaAttention 中，<strong>发现可以直接使用第一个transformer输出的残差来近似模型输出之间的差异。当差值足够小时，我们可以重复使用之前推理步骤的残差</strong>，这意味着我们实际上跳过了去噪步骤。我们的实验证明了这一方法的有效性，我们可以在 FLUX.1-dev 推理上实现高达 1.5 倍的速度，而且质量非常好<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\" rel=\"noopener nofollow\">[1]</a></sup>。<br />\n简单来说就是上面提到的DeepCache/FORA在使用上太粗糙直接通过固定时间步去cache缓存这样忽视输出差异的非均匀性，因此后续的TeaCache发现模型输入与输出的强相关性，通过Timestep Emebdding（输入）来估计输出差异。而后FBCache又做了新的改进：<br />\n<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231602704-899465973.webp\" /><br />\n利用residual cache实现了一个基于First Block L1误差的Cache方案，误差小于指定阈值，就跳过当前步计算，复用residual cache，对当前步的输出进行估计。</p>\n<h4 id=\"cachedit\">CacheDit</h4>\n<p><a href=\"https://github.com/vipshop/cache-dit\" rel=\"noopener nofollow\" target=\"_blank\">cache-dit</a>这个框架主要是适用于Dit结构的扩散模型使用，其具体<a href=\"https://cache-dit.readthedocs.io/en/latest/user_guide/DBCACHE_DESIGN/\" rel=\"noopener nofollow\" target=\"_blank\">模型框架</a>如下：<br />\n<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231603414-1076713638.webp\" /><br />\n对于上述框架首先了解CacheDit中几个概念：1、<code>Fn</code>：表示需要计算前n层transformer block在时间步t并且详细解释一下CacheDit原理；2、<code>Bn</code>:表示进一步的融合后n层transformer block的信息去强化预测准确性。其中n=1时候就是FBCache。<br />\n因此对于CacheDit具体过程为：<strong>在t-1步时候</strong>，前n块block去计算他们的结果得到输出结果hidden state并且写入缓存中<span class=\"math inline\">\\(C_{t-1}\\)</span>，而后后几层进行完整结算。<strong>在t步时候</strong>，前n块block不完整计算，而是直接复用/近似 t-1 步的缓存<span class=\"math inline\">\\(C_{t-1}\\)</span>得到近似的结果，计算近似结果和缓存结果中差异（L1 范数），如果差异小于阈值直接复用缓存输入到后续的块中计算，反之就重新计算这n块结果。<br />\n其中具体使用如下：<a href=\"https://github.com/shangxiaaabb/ProjectCode/blob/main/code/Python/DFModelCode/DF_acceralate/df_acceralate.ipynb\" rel=\"noopener nofollow\" target=\"_blank\">df_acceralate.ipynb</a></p>\n<h3 id=\"量化技术概述\">量化技术概述</h3>\n<p><a href=\"https://www.big-yellow-j.top/posts/2025/10/11/Quantized.html\" rel=\"noopener nofollow\" target=\"_blank\">量化技术</a>是一种模型压缩的常见方法，将模型权重从高精度（如FP16或FP32）量化为低比特位（如INT8、INT4）去实现<strong>降低显存+生成加速</strong>。量化过程的基本范式，量化过程：<span class=\"math inline\">\\(Q=\\frac{W}{S}\\)</span>其中 <span class=\"math inline\">\\(S\\)</span>表示scale，反量化过程：<span class=\"math inline\">\\(\\hat{w}=QS\\)</span>，因此对于量化只需要保存：1、量化后权重；2、scale值（不同量化模型计算方式不同）。比如说（对称量化过程）对于：<code>1.21, -1.13, 0.22, 0.83, 2.11, -1.53, 0.79\t-0.54, 0.84</code>其中最大值为2.11那么可以计算出缩放系数为：<span class=\"math inline\">\\(\\frac{2.11}{127}=0.01661417\\)</span>（127代表int8数值范围-127，127）那么可以对数据缩放（量化）得到：<code>72, -69, 13, 49, 127, -93, 47, -33, 50</code>反量化可以得到：<code>1.19622024,....</code>（直接乘scale即可）具体计算数字之间差异，都是存在误差的。<br />\n常见的量化策略可以分为PTQ和QAT两大类。量化感知训练（Quantization-Aware Training）：在<strong>模型训练过程中进行量化</strong>，一般效果会更好一些，但需要额外训练数据和大量计算资源比如说qlora。后量化（PTQ）：在<strong>模型训练完成后，对模型进行量化</strong>，无需重新训练。对于线性量化下，浮点数与定点数之间的转换公式如下：<span class=\"math inline\">\\(Q=\\frac{R}{S}+Z;R=(Q-Z)*S\\)</span>，其中R 表示量化前的浮点数、Q 表示量化后的定点数、S（Scale）表示缩放因子的数值、Z（Zero）表示零点的数值。除此之外还会听到几个概念：<strong>1、对称量化</strong>：对称量化的核心思想是将浮点数量化为整数，且量化后的分布是关于零对称的；<strong>2、非对称量化</strong>：是一种用于将浮点数转换为整数表示的量化方法。与对称量化不同的是，这种方法在数据具有偏移（即非对称分布）时更有效，因为它可以减少量化误差。非对称量化会分别找出浮点数的最小值和最大值，分别量化到目标整数范围的最小值和最大值，充分利用量化后的整数范围。这可以使用一个缩放因子（scale）和偏移量（zero-point）来实现<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\" rel=\"noopener nofollow\">[2]</a></sup>。<br />\n比如说在LLM中常用的两种<strong>后量化技术</strong>：1、<strong>GPTQ量化技术</strong>：通过量化——补偿——量化迭代方法，首先量化<span class=\"math inline\">\\(W_{:,j}\\)</span>，而后去计算误差并且补充到 <span class=\"math inline\">\\(W_{:,j:(i+B)}\\)</span>而后进行迭代实现所有参数的量化；2、<strong>AWQ量化技术</strong>：模型计算过程中只有关键参数起作用因此对于关键参数保持原来的精度(FP16)，对其他权重进行低比特量化，但是这样不同进度参数会导致硬件问题，因此在AWQ中<strong>对所有权重均进行低比特量化，但是，在量化时，对于显著权重乘以较大的scale，相当于降低其量化误差；同时，对于非显著权重，乘以较小的scale，相当于给予更少的关注。</strong></p>\n<blockquote>\n<p>补充一个小知识，一般量化看到比较多就是W4A4这个一般指的就是权重和激活的4bit量化，其中权重一般就是<strong>对应该层的模型权重</strong>，激活就是<strong>对应该层的输入</strong></p>\n</blockquote>\n<h4 id=\"bitsandbytes-量化\">Bitsandbytes 量化</h4>\n<p>通过使用bitsandbytes量化来实现8-bit（int8）或者4-bit（int4、Qlora中一般就会使用）量化，不过区别上面提到的AWQ以及GPTQ量化，bitsandbytes不需要对模型进行训练（AWQ、GPTQ可能需要输入数据然后计算误差进行量化），前者需要通过数据来保证量化精度（量化过程是离线、一次性过程），后者量化过程是即时的可逆的。其技术原理如下：<span class=\"math inline\">\\(w≈s q\\)</span>其中w表示原始的FP16权重，q代表int4/int8权重，s缩放因子，其量化过程为对每一个block权重计算：<span class=\"math inline\">\\(\\max(\\text{abs}(w))\\)</span>而后去计算scale：<span class=\"math inline\">\\(s=\\frac{amx(\\| w\\|)}{2^{b-1}-1}\\)</span>而后代入公式就可以得到量化后权重，推理过程中进行：反量化 + 矩阵乘法融合在一个 CUDA kernel 中完成：<span class=\"math inline\">\\(Y=X(sq)\\)</span>。因此对于其使用也很简单，比如说在代码中：<a href=\"https://github.com/shangxiaaabb/ProjectCode/blob/main/code/Python/DFModelCode/DF_acceralate/cache_acceralate.py\" rel=\"noopener nofollow\" target=\"_blank\">cache_acceralate.py</a></p>\n<pre><code class=\"language-python\"># 在ZImagePipeline中参数为：\nclass ZImagePipeline(DiffusionPipeline, ZImageLoraLoaderMixin, FromSingleFileMixin):\n    def __init__(,..,vae, text_encoder, tokenizr, transformer):\n        ...\n# 因此可以直接对里面的text_encoder使用量化处理\n\nfrom diffusers import BitsAndBytesConfig as DiffusersBitsAndBytesConfig\nquantization_config = DiffusersBitsAndBytesConfig(\n    load_in_4bit=True,# 在模型加载阶段，将权重以 4-bit 量化形式加载\n    bnb_4bit_quant_type=\"nf4\",\n    bnb_4bit_compute_dtype=torch.bfloat16,# 指定 反量化后参与计算的 dtype\n    bnb_4bit_use_double_quant=True,#启用 Double Quantization（双重量化），也就是对block的scale在进行一次量化\n    llm_int8_skip_modules=[\"transformer_blocks.0.img_mod\"],# 指定 不参与 bitsandbytes 量化的模块\n)\ntransformer = AutoModel.from_pretrained(\n    model_name,\n    cache_dir=cache_dir,\n    subfolder=\"transformer\",\n    quantization_config=quantization_config,\n    torch_dtype=torch.bfloat16,\n    device_map=\"auto\",\n    mirror='https://hf-mirror.com'\n)\n</code></pre>\n<p>去对你的<code>model_name</code>里面的transformer进行量化处理，除此之外还有使用例子就是进行优化器量化，比如说</p>\n<pre><code class=\"language-python\"># 和使用adamw方式一样，使用qlora使用一般带上这个优化器\nimport bitsandbytes as bnb\noptimizer_class = bnb.optim.AdamW8bit\n</code></pre>\n<h4 id=\"svdquant量化\">SVDQuant量化</h4>\n<blockquote>\n<p><a href=\"https://github.com/nunchaku-ai/nunchaku\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/nunchaku-ai/nunchaku</a></p>\n</blockquote>\n<p>在扩散模型中，权重（Weights）和激活（Activations）往往包含大量异常值（极端大或小的值），这些值在低位量化（如4-bit INT4）时会引起严重误差，导致生成的图像失真或噪声增多。<br />\n<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231601731-775108244.webp\" /></p>\n<blockquote>\n<p>a：权重和激活值中都存在异常值，b：将激活值的异常值移动到权重中，c：将权重进行分解低秩的<span class=\"math inline\">\\(L_1L_2\\)</span>以及残差</p>\n</blockquote>\n<p>因此对于SVDQuant过程描述如下，对于权重和激活值：<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 以及 <span class=\"math inline\">\\(\\mathbf{X}\\)</span>，在最初这两部分值都是存在大量异常值，因此首先通过平滑操作将激活<span class=\"math inline\">\\(\\mathbf{X}\\)</span>中的异常值迁移到权重 <span class=\"math inline\">\\(\\mathbf{X}\\)</span>中得到更新后权重 <span class=\"math inline\">\\(\\hat{\\mathbf{W}}\\)</span>，这部分数据表述为：<span class=\"math inline\">\\(\\hat{\\mathbf{W}}=\\mathbf{W}\\odot S\\)</span>其中S是平滑因子，用于转移异常（⊙表示逐元素乘法）。这部分操作主要是因为：<strong>将异常值集中到权重侧，因为权重是静态的，更容易后续处理。激活侧的异常值减少后，量化难度降低</strong>。而后，进行SVD分解与低秩吸收，对更新后权重进行奇异值分解：$  \\hat{𝑾} = 𝑼 \\Sigma 𝑽^T  <span class=\"math inline\">\\(, 其中𝑼和𝑽是正交矩阵，\\)</span>\\Sigma<span class=\"math inline\">\\(是奇异值对角矩阵。保留前k个最大奇异值（低秩r，通常r &lt;&lt; min(m,n)，其中m,n是权重矩阵维度），形成低秩近似：\\)</span>  𝑳_1 𝑳_2 = 𝑼[:,:r] \\cdot \\Sigma[:r,:r] \\cdot 𝑽^T[:r,:]  <span class=\"math inline\">\\(。然后，计算残差：\\)</span>  𝑹 = \\hat{𝑾} - 𝑳_1 𝑳_2<span class=\"math inline\">\\(，其中只对残差\\)</span>𝑹<span class=\"math inline\">\\(进行量化（\\)</span>Q(𝑹)=\\text{round}(\\frac{𝑹}{S_𝑹})S_𝑹<span class=\"math inline\">\\(，其中\\)</span>S_𝑹<span class=\"math inline\">\\(为缩放因子）处理。低秩分支\\)</span>  𝑳_1 𝑳_2  $使用高精度（16-bit float）运行，专门“吸收”异常值和主要信息，而残差𝑹中的异常值和幅度显著减少，只需量化到4-bit。量化误差界限分析（从论文中）：量化误差上界可通过F范数和奇异值控制，证明低秩吸收后残差的量化难度降低（误差 ≤ $  \\frac{\\sqrt{\\log(\\text{size}(𝑹)\\pi)}}{q_{\\max}} \\mathbb{E}[|𝑹|_F]  $，其中q_max是量化最大值），<strong>最后的整体近似计算</strong>：</p>\n<p></p><div class=\"math display\">\\[\\hat{\\mathbf{X}}\\hat{\\mathbf{W}}=\\hat{\\mathbf{X}}(R+L_1L_2)≈\\hat{\\mathbf{X}}(L_1L_2)+Q(\\hat{\\mathbf{X}})Q(R)\n\\]</div><p></p><p>第一项是16-bit低秩分解，第二项为4-bit残差分支。整个过程对应：<br />\n<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231602130-1215683201.webp\" /></p>\n<h4 id=\"gguf\">GGUF</h4>\n<blockquote>\n<p>HF文档：<a href=\"https://huggingface.co/docs/hub/en/gguf\" rel=\"noopener nofollow\" target=\"_blank\">https://huggingface.co/docs/hub/en/gguf</a><br />\n<a href=\"https://unsloth.ai/docs/basics/inference-and-deployment/saving-to-gguf\" rel=\"noopener nofollow\" target=\"_blank\">https://unsloth.ai/docs/basics/inference-and-deployment/saving-to-gguf</a></p>\n</blockquote>\n<p>GGUF格式是用于存储大型模型预训练结果的，相较于Hugging Face和torch的bin文件，它采用了紧凑的二进制编码格式、优化的数据结构以及内存映射等技术，提供了更高效的数据存储和访问方式。GGUF 本身支持多种量化级别（Q2_K ~ Q8_0、IQ2 ~ IQ4 等），这些量化方式属于后训练量化（PTQ），和 AWQ、GPTQ、bitsandbytes 4bit 一样，都是在预训练模型上直接执行量化（不需要重新训练）。不过需要区别的是AWQ、GPTQ、SVDQuant都需要一小批数据而bitsandbytes以及GGUF不需要，在GGUF中可以实现量化方式有两类：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\"><strong>传统Q系列</strong>（按照权重逐层量化）</th>\n<th style=\"text-align: center;\"><strong>K-Quant系列</strong>（通过 block-wise + scale 优化）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231602722-1391696036.webp\" /></td>\n<td style=\"text-align: center;\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231602534-100439133.webp\" /></td>\n</tr>\n</tbody>\n</table>\n<p>其中<strong>传统Q系列</strong>主要是一整块权重共享一个 scale（缩放因子），每个权重用低 bit 整数表示，容易受到极端值的影响。 <strong>K-Quant系列</strong>一个 block 内，再分“子块”，每个子块有自己的 scale，其中S代表子块少、scale少；M代表子块多、scale多。</p>\n<h2 id=\"总结\">总结</h2>\n<p>本文主要是介绍一些在SD模型中加快生图的策略，1、直接使用加速框架进行优化，比如说指定attention计算后端方式、通过<code>torch.compile</code>进行编译、使用<code>torch.channels_last</code>去优化内存访问方式等；2、cache策略，发现在生成过程中在某些层/时间布之间图像的特征比较相似，因此就可以考虑将这些计算结果进行缓存在后续n步中直接加载缓存好的特征来实现生成加速，主要介绍框架是<code>cache-dit</code>；3、量化技术概述，<br />\n最后简单对比一下生成加速时间</p>\n<blockquote>\n<p>测试prompt: <code>超写实亚洲中年男性，年龄约45-55岁。面容坚毅、憔悴，带有生活阅历的痕迹（如眼角的细纹）。他穿着质感柔软的深灰色高领毛衣，外搭一件经典的卡其色风衣，站在寒风中周围是高楼大厦</code><br />\n从测试结果上图像的差异还是不大，时间的话从5.97--&gt;5.48（<strong>不一定严谨！</strong>）还是有效的</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">正常生图</th>\n<th style=\"text-align: center;\">+使用channel+ flash_attn</th>\n<th style=\"text-align: center;\">+使用cachedit</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231602310-1840320611.webp\" /></td>\n<td style=\"text-align: center;\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231602417-1468973015.webp\" /></td>\n<td style=\"text-align: center;\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/3395559/202601/3395559-20260125231602717-1497084798.webp\" /></td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><code>5.97</code></td>\n<td style=\"text-align: center;\"><code>5.67</code></td>\n<td style=\"text-align: center;\"><code>5.48</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考\">参考</h2>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li class=\"footnote-item\" id=\"fn1\"><p><a href=\"https://github.com/chengzeyi/ParaAttention/blob/main/doc/fastest_flux.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/chengzeyi/ParaAttention/blob/main/doc/fastest_flux.md</a> <a class=\"footnote-backref\" href=\"#fnref1\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n<li class=\"footnote-item\" id=\"fn2\"><p><a href=\"https://juejin.cn/post/7436976221068148786\" rel=\"noopener nofollow\" target=\"_blank\">https://juejin.cn/post/7436976221068148786</a> <a class=\"footnote-backref\" href=\"#fnref2\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n</ol>\n</section>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 23:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Big-Yellow\">Big-Yellow-J</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MCP 进化：让静态 Tool 进化为具备“上下文感知”的远程 Skills",
      "link": "https://www.cnblogs.com/noear/p/19530698",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/noear/p/19530698\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 22:47\">\n    <span>MCP 进化：让静态 Tool 进化为具备“上下文感知”的远程 Skills</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        摘要： Solon AI 通过将 Model Context Protocol (MCP) 封装为动态感知的 Skill，解决了传统静态工具交互的三大痛点：上下文噪音、权限真空和行为失控。Skill 通过智能准入（isSupported）、指令注入（getInstruction）和三态路由（getToolsName）实现动态分发，使模型仅感知当前场景所需的工具。实战示例展示了客户端与服务端的协作，支持多租户隔离和权限控制。该方案适用于复杂业务场景，但需注意其非标准化特性及适用边界。最终，Skill 架构提升\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在 AI Agent 的工程实践中，Model Context Protocol (MCP) 已成为连接大模型与外部世界的标准桥梁。然而，随着应用场景从“个人助手”向“企业级复杂业务”迈进，传统的 MCP 交互模式开始显露其 <strong>“静态化”</strong> 的瓶颈。</p>\n<p>Solon AI 支持将 MCP 封装为 Skill，实现了从“冷冰冰的 API 集合”到“具备感知能力的智能技能”的跨越。</p>\n<h3 id=\"一静态-tools-的三大痛点\">一、静态 Tools 的三大痛点</h3>\n<p>传统的 MCP 交互类似于一个“无法关闭的工具箱”，无论场景如何，所有工具一涌而上：</p>\n<ul>\n<li><strong>上下文噪音（Context Noise）：</strong> 即使是一个简单的问候，模型也会被注入成百上千行的工具 Schema 定义，白白浪费 Token，更干扰模型的推理专注度。</li>\n<li><strong>权限真空（Security Risks）：</strong> 模型对工具的可见性是“全量”的。难以根据当前登录用户的角色（如普通用户 vs 管理员）动态隐藏敏感操作（如：删除订单）。</li>\n<li><strong>行为失控（Instruction Gap）：</strong> 工具只提供了“能做什么”，却无法告诉模型“在当前背景下该怎么做”。模型缺乏针对特定业务场景的即时指令约束。</li>\n</ul>\n<h3 id=\"二核心解决方式感知挂载与动态分发\">二、核心解决方式：感知、挂载与动态分发</h3>\n<p>Solon AI 通过引入 Skill（Solon AI Skills） 生命周期 来包裹 MCP 协议，实现以下机制解决上述痛点：</p>\n<h4 id=\"a-智能准入-issupported\">A. 智能准入 (isSupported)：</h4>\n<p>只有当 Prompt 上下文（意图、租户信息、环境变量）满足条件时，技能才会被激活。</p>\n<h4 id=\"b-指令注入-getinstruction\">B. 指令注入 (getInstruction)：</h4>\n<p>在技能挂载时，自动为模型注入针对当前上下文的“行为准则”（System Message）。</p>\n<h4 id=\"c-三态路由-gettoolsname\">C. 三态路由 (getToolsName)：</h4>\n<p>服务端根据 Prompt 属性，动态决定给模型展示哪些工具。支持三种形态的路由方式：</p>\n<ul>\n<li>全量使用：未定义过滤逻辑时，显示所有业务工具。</li>\n<li>精准授权：仅展示当前用户权限范围内的工具。</li>\n<li>完全拒绝：即便技能激活，也可能因安全策略在此时封锁所有工具调用。</li>\n</ul>\n<h3 id=\"三实战示例\">三、实战示例</h3>\n<h4 id=\"1-客户端像本地技能一样调用\">1. 客户端：像本地技能一样调用</h4>\n<p>开发者只需关注业务属性的注入，无需操心工具的过滤逻辑，一切由 MCP Skill 代理与远程服务端约定与协商。</p>\n<pre><code class=\"language-java\">import org.noear.solon.ai.chat.ChatModel;\nimport org.noear.solon.ai.chat.prompt.Prompt;\nimport org.noear.solon.ai.mcp.McpChannel;\nimport org.noear.solon.ai.mcp.client.McpClientProvider;\nimport org.noear.solon.ai.mcp.client.McpSkillClient;\n\n//构建 mcp 客户端\nMcpClientProvider mcpClient = McpClientProvider.builder()\n                .channel(McpChannel.STREAMABLE)\n                .url(\"http://localhost:8081//skill/order\")\n                .build();\n\n// 构建带有业务属性的提示词\nPrompt prompt = Prompt.of(\"帮我取消订单 A001\")\n                .attrPut(\"tenant_id\", \"solon_001\")\n                .attrPut(\"user_role\", \"ADMIN\"); // 模拟管理员身份\n\n// 注入技能，模型将只看到“管理员”权限下的工具\nchatModel.prompt(prompt)\n         .options(o -&gt; o.skillAdd(new McpSkillClient(mcpClient))) //将 mcp 客户端 包装为 Solon AI Skills\n         .call();\n</code></pre>\n<h4 id=\"2-服务端实现具备感知力的技能\">2. 服务端：实现具备“感知力”的技能</h4>\n<p>服务端不再是盲目响应，而是通过解析 Prompt 决定自己的表现。</p>\n<pre><code class=\"language-java\">import org.noear.solon.ai.annotation.ToolMapping;\nimport org.noear.solon.ai.chat.prompt.Prompt;\nimport org.noear.solon.ai.mcp.McpChannel;\nimport org.noear.solon.ai.mcp.server.McpSkillServer;\nimport org.noear.solon.ai.mcp.server.annotation.McpServerEndpoint;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@McpServerEndpoint(channel = McpChannel.STREAMABLE_STATELESS, mcpEndpoint = \"/skill/order\")\npublic class OrderSkillServer extends McpSkillServer {\n    \n    @Override\n    public boolean isSupported(Prompt prompt) {\n        // 感知意图：只有涉及“订单”且租户合规时才激活\n        return prompt.getUserContent().contains(\"订单\") \n               &amp;&amp; prompt.attr(\"tenant_id\") != null;\n    }\n\n    @Override\n    public String getInstruction(Prompt prompt) {\n        // 动态指令：注入租户特定的业务规则\n        return \"你现在是租户[\" + prompt.attr(\"tenant_id\") + \"]的订单助手。\";\n    }\n\n    @Override\n    public List&lt;String&gt; getToolsName(Prompt prompt) {\n        // 权限隔离：根据用户角色动态下发工具名\n        List&lt;String&gt; tools = new ArrayList&lt;&gt;();\n        tools.add(\"OrderQuery\"); // 基础权限\n\n        if (\"ADMIN\".equals(prompt.attr(\"user_role\"))) {\n            tools.add(\"OrderCancel\"); // 仅管理员可见\n        }\n        return tools;\n    }\n\n    @ToolMapping(description = \"查询订单\")\n    public String OrderQuery(String id) { ... }\n\n    @ToolMapping(description = \"取消订单\")\n    public String OrderCancel(String id) { ... }\n}\n</code></pre>\n<h3 id=\"四skills-架构反思与局限性补充\">四、Skills 架构反思与局限性补充</h3>\n<p>尽管将 MCP 进化为 Skills 带来了显著的工程优势，但开发者仍需理清其技术边界：</p>\n<ul>\n<li>非标准化的架构增强：</li>\n</ul>\n<p>LLM 的底层标准仅包含 Prompt 和 Tool-Call。Skills 并非模型原生标准，也不属于 MCP 的公共协议规范，而是一种 架构设计模式（模式，是通用的）。它通常由 AI 开发框架（如 Solon AI）在消费侧实现，用于解决复杂业务下的能力调度问题。</p>\n<ul>\n<li>消费侧驱动的定制：</li>\n</ul>\n<p>MCP 向 Skills 的进化本质上是“业务驱动”或“领域驱动”的。在设计远程 MCP Skill 时，必须参考消费侧（即 Agent 执行引擎）的具体规范进行深度定制。</p>\n<ul>\n<li>适用场景的选择：</li>\n</ul>\n<p>Tool：适用于原子化、无状态、全量公开的简单功能插件。</p>\n<p>Skill：适用于需要上下文感知、多租户隔离、动态指令约束的复杂业务逻辑块。</p>\n<h3 id=\"五-好处总结\">五、 好处总结</h3>\n<p>将 MCP 进化为 Skills 之后，您的 AI Agent 架构将获得：</p>\n<ul>\n<li>极致的上下文纯净度：</li>\n</ul>\n<p>模型只看到此时此刻该看的工具（通过 getToolsName 实现按需加载，或权限控制）。</p>\n<ul>\n<li>天然的权限安全：</li>\n</ul>\n<p>通过服务端感知的动态分发，实现真正的跨进程角色权限控制（RBAC for Tools）。</p>\n<ul>\n<li>低耦合的业务演进：</li>\n</ul>\n<p>业务逻辑和规则变更集中在服务端，客户端 “无需” 任何代码改动即可获得最新能力。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 22:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/noear\">带刺的坐椅</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MySQL升级8.0.44后登录报错-系统表不支持'MyISAM'存储引擎",
      "link": "https://www.cnblogs.com/ldocser/p/19530406",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ldocser/p/19530406\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 20:10\">\n    <span>MySQL升级8.0.44后登录报错-系统表不支持'MyISAM'存储引擎</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"一故障现象\">一、故障现象</h1>\n<p>近期我们公司内部网络安全排查中，发现其中一个业务系统使用的是mysql8.0.11，存在几个高风险漏洞，经评估决定对其升级到最新版本MySQL8.0.44。升级后出现数据库无法远程登录，即使输入正确的密码也提示连接拒绝，报错如下图；<br />\n<img alt=\"MySQL远程登录报错\" class=\"lazyload\" /></p>\n<h1 id=\"二排查处理过程\">二、排查处理过程</h1>\n<h2 id=\"第一步尝试修改用户密码\">第一步：尝试修改用户密码</h2>\n<p>开始我以为是数据库用户的密码错误了，就想着使用root用户进去修改下用户密码。执行修改用户密码的sql，结果发现执行sql报错，提示系统表不支持MyISAM存储引擎，提示如下图：<br />\n<img alt=\"修改数据库用户密码报错\" class=\"lazyload\" /></p>\n<h2 id=\"第二步通过日志确认原因\">第二步：通过日志确认原因</h2>\n<p>通过查看 MySQL 数据库运行日志，发现数据库在启动时就已经发出警告，</p>\n<pre><code class=\"language-bash\">[Warning] [MY-010929] [Server] Storage engine 'MyISAM' does not support system tables. [mysql.user].\n[Warning] [MY-010929] [Server] Storage engine 'MyISAM' does not support system tables. [mysql.db].\n</code></pre>\n<p><img alt=\"系统表不支持'MyISAM'存储引擎\" class=\"lazyload\" /></p>\n<h2 id=\"第三步尝试使用mysql_upgrade手动升级数据结构\">第三步：尝试使用mysql_upgrade手动升级数据结构</h2>\n<p>使用 mysql_upgrade 命令使用手动升级方式，重新升级数据库表数据。提示已经不支持使用该方式手动升级数据库数据文件。借助翻译工具翻译后的内容可以看到：新版本的MySQL数据库在启动时会自动升级，但是也提供了 <code>--upgrade</code> 参数用于控制升级动作。可以尝试使用该方式强制升级mysql数据库。</p>\n<p><img alt=\"mysql_upgrade\" class=\"lazyload\" /></p>\n<blockquote>\n<p><strong>提示内容翻译</strong><br />\n<code>mysql_upgrade</code>&nbsp;客户端现已弃用。原先由该升级客户端执行的操作，现在均由服务器自身完成。<br />\n要执行升级，请使用新的 MySQL 二进制程序启动旧的数据目录。用户表的修复将自动进行，升级后无需重启。<br />\n当使用新版本的 MySQL 二进制程序启动旧数据目录时，升级过程会自动开始。为避免意外触发升级，请在启动 MySQL 二进制程序时使用&nbsp;<code>--upgrade=NONE</code>&nbsp;选项。此外，也提供了&nbsp;<code>--upgrade=FORCE</code>&nbsp;选项，用于按需强制执行服务器升级流程。<br />\n升级过程可能因多种原因而失败。若发生失败，MySQL 服务器在下次启动时将再次尝试执行升级序列。如果服务器反复升级失败，可使用&nbsp;<code>--upgrade=MINIMAL</code>&nbsp;选项启动服务器，以跳过升级流程，从而允许用户手动排查并修复问题。</p>\n</blockquote>\n<h2 id=\"第四步使用upgrade参数强制升级数据库\">第四步：使用upgrade参数强制升级数据库</h2>\n<p>根据刚才的提示，可以使用upgrade参数控制数据库的升级行为，查看upgrade参数如何使用，</p>\n<pre><code class=\"language-bash\">mysqld --verbose --help | grep -A 10 -B 10 -i \"upgrade\"\n</code></pre>\n<p><img alt=\"upgrade参数\" class=\"lazyload\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">参数值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">NONE</td>\n<td>如果自动升级服务器，则中止启动</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">MINIMAL</td>\n<td>启动服务器，但跳过非绝对必要的升级步骤</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">AUTO（默认）</td>\n<td>在需要时自动升级服务器</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">FORCE</td>\n<td>强制执行服务器升级</td>\n</tr>\n</tbody>\n</table>\n<p>根据提示内容，<code>FORCE</code> 可以强制服务器启动的时候执行升级操作。</p>\n<pre><code class=\"language-bash\"> mysqld --user=mysql --datadir=/..../mysql/ --upgrade=FORCE\n</code></pre>\n<p><img alt=\"使用upgrade参数强制升级数据库\" class=\"lazyload\" /></p>\n<p>查看MySQL的运行日志可以看出，在数据库启动过程中执行了升级操作，而且完成了升级，也没有出现之前 <code>Storage engine 'MyISAM' does not support system tables</code> 的字样。</p>\n<h2 id=\"第五步-正常启动数据库尝试登陆\">第五步： 正常启动数据库，尝试登陆</h2>\n<p>使用常规参数启动数据库服务，查看日志确认没有在出现类似告警，尝试使用mysql命令行工具登录数据库，经过尝试可以正常登录。</p>\n<pre><code class=\"language-bash\">systemctl restart  mysqld\nmysql -u'user' -p -h192.168.170.195\n</code></pre>\n<p><img alt=\"尝试使用mysql命令登陆数据库\" class=\"lazyload\" /></p>\n<p>开始逐个启动服务，逐步恢复业务系统。<br />\n到此为止完成本次故障处理。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 20:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ldocser\">小白爱运维</a>&nbsp;\n阅读(<span id=\"post_view_count\">38</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": ".NET周刊【12月】",
      "link": "https://www.cnblogs.com/InCerry/p/-/dotnet_week_25_12",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/InCerry/p/-/dotnet_week_25_12\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 19:40\">\n    <span>.NET周刊【12月】</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"公告\">公告</h2>\n<p>此前国内 .NET 周刊的更新节奏一直参考 .NET 国际周刊。但由于国际周刊更新频率不稳定，导致国内周刊发布也不固定，内容常常滞后于主线进展。</p>\n<p>因此，2026 年起将调整为新的更新模式：不再等待国际周刊同步。若国际周刊当周未更新，国内周刊将按计划正常发布；若国际周刊当周更新，其内容将整合至下一期国内周刊一并发布。</p>\n<p>本文为 2025 年周刊的收官篇。</p>\n<h2 id=\"国内文章\">国内文章</h2>\n<h3 id=\"avalonia-源码解读grid网格控件\">Avalonia 源码解读：Grid（网格控件）</h3>\n<p><a href=\"https://www.cnblogs.com/BettaFish/p/19354900/avalonia-grid\" target=\"_blank\">https://www.cnblogs.com/BettaFish/p/19354900/avalonia-grid</a></p>\n<p>Grid 是一种灵活且常用的布局控件，用于创建复杂的用户界面。本文以 Avalonia 框架为例，讲解 Grid 控件的工作原理和测量流程。Grid 通过行和列定义组织界面元素，计算过程中存在不同的大小定义方式。测量遵循优先确定大小原则，Grid 将元素分为几组测量。具体算法包括初始化行列定义和分组处理。文中详细描述了不同类型项的测量机制，适用于各种 XAML UI 框架。整体结构清晰，信息量大。</p>\n<h3 id=\"2025-年-webtransport-生态深度研究javascript-客户端与net-10-signalr-的演进与融合\">2025 年 WebTransport 生态深度研究：JavaScript 客户端与.NET 10 SignalR 的演进与融合</h3>\n<p><a href=\"https://www.cnblogs.com/shanyou/p/19355053\" target=\"_blank\">https://www.cnblogs.com/shanyou/p/19355053</a></p>\n<p>本文讨论了 WebTransport 协议在实时网络通信中的应用，特别是在 JavaScript 客户端和 ASP.NET Core SignalR 中的支持。至 2025 年，该协议标志着 TCP 向 UDP 和 QUIC 的转型。报告指出，Chrome 和 Firefox 已全面支持 WebTransport，Apple 的 WebKit 则存在障碍。在服务端，ASP.NET Core SignalR 已实现生产就绪。本文分析了 HTTP/3 和 QUIC 的优势，包括流独立性、可靠数据报和连接迁移等特性，为企业级架构师和开发者提供了实现指导。</p>\n<h3 id=\"精选-8-个-net-开发实用的类库效率提升利器\">精选 8 个 .NET 开发实用的类库，效率提升利器！</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19375857\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19375857</a></p>\n<p>这篇文章介绍了一些开源的 .NET 技术库，包括 Mapster、FlaUI、QuestPDF、BouncyCastle、IdGenerator、CsvHelper、Moq 和 xUnit。这些库各具特色，提供对象映射、自动化测试、PDF 生成、密码学功能、ID 生成、CSV 操作、模拟测试等功能。它们均为 MIT 许可，支持 .NET 生态，提高开发效率，减少重复代码和错误。文中提供了每个库的开源地址和详细介绍链接，方便开发者进一步学习。</p>\n<h3 id=\"opencvsharp了解几种特征检测\">OpenCVSharp：了解几种特征检测</h3>\n<p><a href=\"https://www.cnblogs.com/mingupupu/p/19352075\" target=\"_blank\">https://www.cnblogs.com/mingupupu/p/19352075</a></p>\n<p>文章介绍了 OpenCVSharp 库中多种特征检测算法，重点阐述了 FAST 算法与 FREAK 算法。FAST 算法以高效的特征点检测闻名，利用像素强度差异识别角点，特别适合实时应用。文章展示了 FAST 算法的实现代码，包括图像读取、处理与特征点绘制。FREAK 算法则模仿人类视网膜结构，快速提取二进制特征描述符，具有高效性的特点，适用于实时图像匹配。整体内容清晰，技术性强，适合对计算机视觉有兴趣的读者。</p>\n<h3 id=\"newtonsoftjson-与-systemtextjson-多态反序列化的安全性差异解析\">Newtonsoft.Json 与 System.Text.Json 多态反序列化的安全性差异解析</h3>\n<p><a href=\"https://www.cnblogs.com/MeteorSeed/p/19366736\" target=\"_blank\">https://www.cnblogs.com/MeteorSeed/p/19366736</a></p>\n<p>多态反序列化涉及继承结构对象序列化，是一项常见需求。不同 JSON 序列化库存在明显的安全风险。微软 CA2326 规则提示避免使用不安全的 JsonSerializerSettings。本文对比了 Newtonsoft.Json 和 System.Text.Json 的实现差异，重点分析了安全性问题。Newtonsoft.Json 允许 TypeNameHandling 反序列化，但易受到攻击，可能实例化敏感类型。相比之下，System.Text.Json 强调安全设计，默认不支持多态，需显式声明允许的类型，从根本上降低风险。通过代码示例，可以验证各自的安全性表现及潜在问题。</p>\n<h3 id=\"aspire-13从net-编排工具到真正的多语言云原生应用平台\">Aspire 13：从.NET 编排工具到真正的多语言云原生应用平台</h3>\n<p><a href=\"https://www.cnblogs.com/shanyou/p/19360467\" target=\"_blank\">https://www.cnblogs.com/shanyou/p/19360467</a></p>\n<p>Aspire 13 的发布标志着微软云原生开发工具箱的重大转变，去掉了“.NET”前缀，转向多语言支持，包括 Python 和 JavaScript。本文深入分析了 Aspire 13 的架构变化，探讨了新引入的统一 AppHost 模型和 Aspire.Hosting.Python 包的深度集成。Aspire 13 提供了标准化的服务协作，消除了跨语言监控的壁垒，同时简化了本地开发到生产部署的流程。本文还评估了该版本对 .NET 10 SDK 的依赖及其全新生命周期管理工具的影响，这一切标志着微软致力于构建多语言融合的开发平台。</p>\n<h3 id=\"用-net-最小化-api-构建高性能-api\">用 .NET 最小化 API 构建高性能 API</h3>\n<p><a href=\"https://www.cnblogs.com/powertoolsteam/p/19360421\" target=\"_blank\">https://www.cnblogs.com/powertoolsteam/p/19360421</a></p>\n<p>本文探讨了使用.NET 最小化 API 构建高性能 API 的方法。最小化 API 简化了开发流程，减少了模板代码，提升了启动性能。它摒弃了传统控制器结构，允许在 Program.cs 文件中直接定义路由。最小化 API 具备显著降低代码复杂度、提升内存使用效率和提高请求处理速度等优点。其设计原则包括保持端点简洁、使用类型化结果、支持依赖注入及输入验证等。通过支持异步编程和高效的数据访问策略，最小化 API 在高负载下表现突出，适合高并发应用场景。</p>\n<h3 id=\"openai-code-interpreter-coworker-架构审计与安全取证分析\">OpenAI Code Interpreter (\"Coworker\") 架构审计与安全取证分析</h3>\n<p><a href=\"https://www.cnblogs.com/shanyou/p/19350418\" target=\"_blank\">https://www.cnblogs.com/shanyou/p/19350418</a></p>\n<p>2025 年发生的 OpenAI Code Interpreter 泄露事件揭示了先进大语言模型执行环境的真实架构。初步假设其仅为 Python 环境，但实则是多语言混合系统，核心依赖于.NET 9（C#）构建的 XML 解析引擎。该环境运行在 Google 特征的 Chrome 容器中，并通过 @oai/walnut 包实现高效文档处理。泄露信息显示，C#在性能与安全性上优于 Python，架构采用‘Roundtrip’流程，确保数据结构完整性。这次事件表明，LLM 的能力受到规则限制，通过规范化的 Protobuf 格式与系统交互。</p>\n<h3 id=\"cvisionmaster-学习笔记目录-目录\">C#+VisionMaster 学习笔记(目录)-目录</h3>\n<p><a href=\"https://www.cnblogs.com/qq2806933146xiaobai/p/19354654\" target=\"_blank\">https://www.cnblogs.com/qq2806933146xiaobai/p/19354654</a></p>\n<p>这篇文章探讨了 C#与 VisionMaster 联合开发的多个方面，包括操作方案、模块、全局变量和设备控制等。目录不仅包括基础使用教程，还涉及控件的配置与控制。文章旨在补充相关知识，尤其对现有示例的不足之处进行改进，推动 AI 与图像处理的结合。作者希望提供全面的学习资料，并逐步更新基础教程以增强理解，适合对 C#与 VisionMaster 感兴趣的开发者和学习者。</p>\n<h3 id=\"译初探-visual-studio-2026-全新的用户体验\">【译】初探 Visual Studio 2026 全新的用户体验</h3>\n<p><a href=\"https://www.cnblogs.com/MeteorSeed/p/19307311\" target=\"_blank\">https://www.cnblogs.com/MeteorSeed/p/19307311</a></p>\n<p>Visual Studio 2026 通过注重清晰度、可访问性和简洁设计，提升了用户体验。更新包括排版、图标和布局改进，以减少干扰。新设置界面现代化，便于用户发现和调整。推出 11 款彩色主题，增强无障碍功能。编辑器外观设置允许用户自定义代码编辑环境，提供高对比度选项，满足可读性需求。用户可以与当前版本共存，轻松探索新功能并提供反馈，进一步改善体验。</p>\n<h3 id=\"你的代码正在腐烂为什么我们都不敢碰那座屎山\">你的代码正在腐烂：为什么我们都不敢碰那座“屎山”？</h3>\n<p><a href=\"https://www.cnblogs.com/huizhudev/p/19368567\" target=\"_blank\">https://www.cnblogs.com/huizhudev/p/19368567</a></p>\n<p>本文探讨了软件工程中的代码脆弱性现象，强调了重构时的恐惧感和维护难度。作者指出，代码腐烂是自然规律，必须主动重构。提出了利用 AI 模型提供重构建议，从而提升代码的安全性和可维护性。AI 可以识别代码异味并确保每次修改的安全性。文中强调了资深架构师的角色，以及重构的具体方法和任务要求，旨在引导开发者进行有效的代码重构。</p>\n<h3 id=\"net10-new-feature-新增功能介绍-jit-编译器改进\">.NET10 New feature 新增功能介绍-JIT 编译器改进</h3>\n<p><a href=\"https://www.cnblogs.com/tianqing/p/19378803\" target=\"_blank\">https://www.cnblogs.com/tianqing/p/19378803</a></p>\n<p>.NET 10 是最新的 LTS 版本，微软支持三年，提供了重要的新功能，特别是在 JIT 编译器方面。改进的 JIT 编译器使“好代码”能更高效地运行，无需编写特殊代码或使用 unsafe 选项。通过优化结构参数，JIT 能直接在寄存器中处理数据，减少内存访问。循环反转的优化提高了代码布局，增强了循环的识别。JIT 去虚拟化数组接口方法的能力，使遍历数组的代码执行更快，降低了抽象开销。这些改进为开发者提供了显著的性能提升。</p>\n<h3 id=\"opencvsharp学习人脸检测例子\">OpenCVSharp：学习人脸检测例子</h3>\n<p><a href=\"https://www.cnblogs.com/mingupupu/p/19363129\" target=\"_blank\">https://www.cnblogs.com/mingupupu/p/19363129</a></p>\n<p>本文介绍了 OpenCVSharp 中的人脸检测方法，包括级联分类器和 DNN 模型。详细讲解了 Haar 和 Lbp 级联分类器，说明了 haarcascade_frontalface_default.xml 文件的作用与使用方法。通过示例代码，展示了如何加载分类器及通过多尺度检测人脸，同时展示检测到的人脸。文章提供了必要的文件下载链接，支持读者进行实践。</p>\n<h3 id=\"maf-快速入门7工作流的状态共享\">MAF 快速入门（7）工作流的状态共享</h3>\n<p><a href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper07\" target=\"_blank\">https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper07</a></p>\n<p>本文介绍了使用 MAF 实现工作流状态共享的技巧，通过经典案例演示了如何在 AI 工作流中共享上下文数据。文章阐述了 WorkflowContext 模型的功能，以及如何通过 API 实现状态的读取与设置。作者展示了一个文档统计工作流的实践，包括读取文件和统计单词数及段落数的 Executor。文中提供了必要的准备工作和配置示例，强调了并发协作的基础。整体内容简洁明了，适合希望深入学习.NET 与 AI 结合的开发者。</p>\n<h3 id=\"opencvsharphog-行人检测\">OpenCVSharp：HOG 行人检测</h3>\n<p><a href=\"https://www.cnblogs.com/mingupupu/p/19365183\" target=\"_blank\">https://www.cnblogs.com/mingupupu/p/19365183</a></p>\n<p>HOG 行人检测是一种基于方向梯度直方图特征的计算机视觉目标检测技术。该算法将图像细分为小区域，计算并生成梯度方向直方图。相邻细胞单元组合后归一化，形成特征向量。特征向量通过 SVM 分类器判断图像区域是否包含行人，依赖多尺度扫描策略实现目标检测和定位。文章提供了完整的 C#代码示例，包括读取图像、创建 HOG 描述符及目标检测过程，适合实际应用。</p>\n<h3 id=\"net-通过-efcore-和仓储模式实现统一数据权限管控并且相关权限配置动态生成\">.Net 通过 EFCore 和仓储模式实现统一数据权限管控并且相关权限配置动态生成</h3>\n<p><a href=\"https://www.cnblogs.com/net-kevin-li/p/19368351\" target=\"_blank\">https://www.cnblogs.com/net-kevin-li/p/19368351</a></p>\n<p>本文介绍了在.NET 应用中使用 EFCore 和仓储模式实现数据权限管控的设计方案。文章定义了数据权限的四个层级，并通过具体的代码示例展示了基础仓储接口的设计和数据过滤的实现。作者提供了项目地址，便于读者参考和使用。整体结构清晰，逻辑性强，适合开发人员理解和应用。</p>\n<h3 id=\"aspire-与-azure-functions-深度集成架构范式工程实践与运维\">Aspire 与 Azure Functions 深度集成：架构范式、工程实践与运维</h3>\n<p><a href=\"https://www.cnblogs.com/shanyou/p/19376604\" target=\"_blank\">https://www.cnblogs.com/shanyou/p/19376604</a></p>\n<p>本文探讨了 Azure Functions 与 Aspire 的结合，强调其在云原生架构中的重要性。分布式应用开发面临的复杂性与传统微服务架构的运维难题被详细描述。Aspire 通过提供标准化的服务编排和依赖管理，改善了开发者体验。它将 Azure Functions 转变为主要资源，并依赖隔离工作进程模型，以实现生命周期管理和功能编排。AppHost 作为基础设施表示，简化了本地环境配置，提升了开发效率。</p>\n<h3 id=\"maui-库推荐二mpowerkit\">MAUI 库推荐二：MPowerKit</h3>\n<p><a href=\"https://www.cnblogs.com/sesametech-dotnet/p/19376927\" target=\"_blank\">https://www.cnblogs.com/sesametech-dotnet/p/19376927</a></p>\n<p>MPowerKit 是.NET MAUI 的导航框架，支持多种导航方式，灵感来源于 Prism。该框架提供与 Prism 相同的导航原则，但实现方式不同，性能稍有提升。其核心库包括多个接口，如 IInitializeAware、IDestructible 等，允许开发者控制页面初始化和销毁时的行为。使用时，只需在项目中引用相应的 NuGet 包，并在 MauiProgram 中添加配置代码即可启动和注册相关服务。MPowerKit 还支持 MVVM 设计模式，简化了应用程序的构建。</p>\n<h3 id=\"acp让-ai-编程工具配置从此告别碎片化--一款开源的-ai-配置管理平台\">ACP：让 AI 编程工具配置从此告别碎片化 —— 一款开源的 AI 配置管理平台</h3>\n<p><a href=\"https://www.cnblogs.com/fanshaoO/p/19351155\" target=\"_blank\">https://www.cnblogs.com/fanshaoO/p/19351155</a></p>\n<p>ACP（AI-Config-Plaza）是一个开源平台，旨在简化 AI 编程工具的配置管理。它通过统一管理和社区共享，解决了开发者在使用多个 AI 工具时的重复配置问题。ACP 提供了一站式管理，包括多种类型的参数配置和解决方案的组合。其命令行工具支持本地同步，极大地降低切换成本。开发者可分享优质配置，促进资源互用。项目采用全栈架构，支持多语言，欢迎开发者参与。ACP 旨在提高开发效率，积极推动社区合作。</p>\n<h3 id=\"用-net-maui-10--vs-copilot-从-0-开发一个签到-app四和-copilot-一起创建签到历史页面\">用 .NET MAUI 10 + VS Copilot 从 0 开发一个签到 App（四）和 Copilot 一起创建「签到历史页面」</h3>\n<p><a href=\"https://www.cnblogs.com/densen2014/p/19379931\" target=\"_blank\">https://www.cnblogs.com/densen2014/p/19379931</a></p>\n<p>本文介绍如何使用 .NET MAUI 和 VS Copilot 从零开发签到 App 的签到历史页面。前文完成了基本的签到页面，本篇重点在于展示用户的签到记录。文章首先明确目标，即实现签到历史页面，并列出实现步骤。Copilot 生成了签到历史页面的 XAML 代码，设计简洁，使用了 CollectionView，展示签到时间信息。同时，页面逻辑由 Copilot 自动生成，展示了良好的工程实践。整体内容围绕真实业务需求展开，实用性强。</p>\n<h3 id=\"未来已来--写给-net-开发者的-2025-年度总结\">未来已来 | 写给 .NET 开发者的 2025 年度总结</h3>\n<p><a href=\"https://www.cnblogs.com/sheng-jie/p/19402252/goodbye-2025-welcome-2026\" target=\"_blank\">https://www.cnblogs.com/sheng-jie/p/19402252/goodbye-2025-welcome-2026</a></p>\n<p>本文为.NET 开发者总结了 2025 年的技术趋势，重点讨论了 AI 与.NET 的融合和发展。指出了 AI 模型的快速进步及其对开发者的影响，包括更强的代码生成和自动化能力。强调了 AI 从助手向代理的进化，具备规划、推理、工具调用和记忆等核心能力。同时回顾了.NET 生态的重要里程碑，如.NET 10 发布和 C#在 TIOBE 榜单上的上升，展望未来的挑战与机遇。</p>\n<h3 id=\"从-mcp-到-agent-skillsai-ready-的-net-10-正当时\">从 MCP 到 Agent Skills，AI Ready 的 .NET 10 正当时</h3>\n<p><a href=\"https://www.cnblogs.com/sheng-jie/p/19381647\" target=\"_blank\">https://www.cnblogs.com/sheng-jie/p/19381647</a></p>\n<p>本文介绍了如何使用 .NET File-Based Apps 编写高效的 Agent Skills 脚本。Agent Skills 是一种轻量级的格式，旨在扩展 AI Agent 的能力，支持包括 Python 和 JavaScript 在内的多种语言。文章讲解了 Agent Skills 的核心概念、应用场景及其目录结构，强调了 .NET 在脚本开发中的类型安全和性能优势。作者指出，Agent Skills 使专业知识封装、按需加载和可执行能力成为可能，能够优化工作流和跨工具互操作性。整体上，文章为开发者提供了实践指导。</p>\n<h3 id=\"问世间exe-是何物直教-ai-沉默web-寡言1\">问世间，exe 是何物？直教 AI 沉默、Web 寡言（1）</h3>\n<p><a href=\"https://www.cnblogs.com/sunhui/p/19391507\" target=\"_blank\">https://www.cnblogs.com/sunhui/p/19391507</a></p>\n<p>这篇文章以爱丽丝的视角探讨了 WinForms 应用开发的奇妙世界。作者利用隐喻表达了. exe 文件的内在复杂性与潜力，强调了现代技术对传统编程的影响。爱丽丝从对浏览器的惊叹，到对 AI 和编程的探索，展现了技术演变带来的可能。文章对编译后软件灵魂的思考呼应了数字时代的变革。整体叙述充满幻想与启发，引发读者对编程与软件生命的深度思索。</p>\n<h3 id=\"所有-64-位-winform-应用都是-chromium-浏览器\">所有 64 位 WinForm 应用都是 Chromium 浏览器</h3>\n<p><a href=\"https://www.cnblogs.com/sunhui/p/19395609\" target=\"_blank\">https://www.cnblogs.com/sunhui/p/19395609</a></p>\n<p>文章讨论了 64 位 WinForm/MFC/WPF 应用与现代浏览器之间的关系，强调这类桌面应用其实可以被视为浏览器。作者结合个人经历和与 AI 的对话，提出桌面应用应融入 Web 生态，以便充分利用 AI 和 Web 技术，从而提升应用价值。虽然技术上可能面临一些挑战，但最终用户的需求可能推动开发者接受这种转变。文章观点新颖，挑战传统认知，有助于引发对未来软件开发趋势的思考。</p>\n<h3 id=\"wpf-使用-rendertransform-实现高性能平滑滚动的-scrollviewer\">WPF 使用 RenderTransform 实现高性能平滑滚动的 ScrollViewer</h3>\n<p><a href=\"https://www.cnblogs.com/TwilightLemon/p/19383555\" target=\"_blank\">https://www.cnblogs.com/TwilightLemon/p/19383555</a></p>\n<p>本文探讨了 WPF 中实现平滑滚动的三种方案，重点介绍了第三版设计（v3），将视觉层与逻辑层分离。v3 方案通过使用 TranslateTransform 降低频繁布局计算，提升性能，同时以较低频率更新逻辑位置，保证滚动体验流畅。文中详细描述了视觉与逻辑层的处理方式，以及物理模型的设计思路，特别是动态速度因子与物理衰减模型的应用，使得滚动体验更接近真实物理效果。整体思路清晰，有助于开发者理解和实现高效的滚动功能。</p>\n<h3 id=\"hellogithub第-117-期\">《HelloGitHub》第 117 期</h3>\n<p><a href=\"https://www.cnblogs.com/xueweihan/p/19400116\" target=\"_blank\">https://www.cnblogs.com/xueweihan/p/19400116</a></p>\n<p>HelloGitHub 是一个分享开源项目的平台，鼓励用户探索开源的魅力。它提供多种编程语言的入门项目和实战教程，包括 C、C#、C++、Go 等。该平台每月更新内容，涵盖多款工具，如用于 Linux 的手势启动器 Hexecute，以及流行的 C# 工具 BetterLyrics 和 LiteMonitor。通过简单易用的界面，这些工具提升了用户的开发体验。HelloGitHub 适合新手和有经验的开发者，促进了开源文化的传播。</p>\n<h3 id=\"基于莱布尼茨公式的编程语言计算性能基准测试\">基于莱布尼茨公式的编程语言计算性能基准测试</h3>\n<p><a href=\"https://www.cnblogs.com/shanyou/p/19408361\" target=\"_blank\">https://www.cnblogs.com/shanyou/p/19408361</a></p>\n<p>本文探讨了莱布尼茨公式计算圆周率的算法及其在性能基准测试中的应用。尽管收敛速度慢，莱布尼茨级数在浮点运算、循环逻辑和 ALU 压力测试中显示出不错的效用。文章分析了 62 种编程语言的性能，包括 C#和 C++，并探讨了 SIMD 技术和编译器优化在性能差异中的作用。C#在基准测试中表现优异，几乎与 C++ 平起平坐，挑战了托管语言性能的刻板印象。通过评估编译器的效率，文章揭示了现代语言在算法实现中的深度和复杂性。</p>\n<h3 id=\"net10-new-feature-新增功能介绍-类库新增功能\">.NET10 New feature 新增功能介绍-类库新增功能</h3>\n<p><a href=\"https://www.cnblogs.com/tianqing/p/19380073\" target=\"_blank\">https://www.cnblogs.com/tianqing/p/19380073</a></p>\n<p>本文介绍了.NET 10 类库的新增功能，包括 ISOWeek 对 DateOnly 类型的支持、数值字符串比较的新方法、单参数 TimeSpan.FromMilliseconds 重载、OrderedDictionary 的 TryAdd 和 TryGetValue 重载等。这些功能提高了代码的灵活性和可读性，方便了开发者在实际应用中的使用，反映了.NET 技术的持续演进和实用性。</p>\n<h3 id=\"ef-core将一个实体映射到多个表的正确方法\">【EF Core】将一个实体映射到多个表的正确方法</h3>\n<p><a href=\"https://www.cnblogs.com/tcjiaan/p/19394178\" target=\"_blank\">https://www.cnblogs.com/tcjiaan/p/19394178</a></p>\n<p>此文探讨实体拆分，即将一个实体映射到多个数据库表。通过举例说明，一个学生实体可以拆分为基础信息、补充信息和联系方式三个表，并强调这三个表行的对应关系。文章指出，设计中主键与外键可以设为同一列，确保数据一致性。最后，给出实体类的代码示例，计划将宠物映射到三个表，示范基本信息、特征和额外信息的拆分。这种处理方式提升了数据结构的清晰度与合理性。</p>\n<h3 id=\"通过-c-为-pdf-文档添加电子签名\">通过 C# 为 PDF 文档添加电子签名</h3>\n<p><a href=\"https://www.cnblogs.com/jazz-z/p/19396484\" target=\"_blank\">https://www.cnblogs.com/jazz-z/p/19396484</a></p>\n<p>电子签名在文档合规性中重要。基于 C# 的 Spire.PDF 库可以实现 PDF 电子签名，用户无需依赖第三方软件。文章详细阐述了库的使用方法，包括安装 .NET 库、核心依赖（.pfx 格式证书）和实现逻辑。介绍了加载 PDF 文档、解析证书、初始化签名器、执行签名以及保存文档的步骤。示例代码清晰易懂，适合需要电子签名的场景。文章内容具体、技术性强且具实用性。使用案例涵盖基础电子签名及可见签名等功能。</p>\n<h3 id=\"企业级多智能体系统mas架构深度研究c-与-python-生态系统的全面对比与战略评估\">企业级多智能体系统（MAS）架构深度研究：C# 与 Python 生态系统的全面对比与战略评估</h3>\n<p><a href=\"https://www.cnblogs.com/shanyou/p/19380471\" target=\"_blank\">https://www.cnblogs.com/shanyou/p/19380471</a></p>\n<p>这篇文章探讨了 C#与 Python 在企业级多智能体系统中的适用性。随着生成式人工智能的发展，企业软件架构面临转变。作者分析了 C#和 Python 的核心框架及产品，指出尽管 Python 在 AI 开发中占主导，但在多智能体的工程化实现中，C#展现出更强的性能和安全性。C#的任务并行库和静态类型系统减少了重构风险，同时.NET 的 Native AOT 技术降低了冷启动延迟。文章建议，对于复杂的企业级系统，C#是更稳健的选择，而 Python 则适用于快速原型和特定数据科学任务。</p>\n<h3 id=\"一款轻量级-winform-开源控件库让老界面秒变高颜值\">一款轻量级 WinForm 开源控件库，让老界面秒变高颜值</h3>\n<p><a href=\"https://www.cnblogs.com/1312mn/p/19201142\" target=\"_blank\">https://www.cnblogs.com/1312mn/p/19201142</a></p>\n<p>本文介绍了一款基于 WinForm 的自绘控件库，旨在提升用户界面的视觉效果和交互体验。该库通过自定义绘制技术，实现了丰富、灵活的控件设计，具备高度可定制性和动画效果，包括按钮、面板和文本框等。PPFlodPanel 控件突出其动画特性，为用户提供流畅的展开与折叠体验。作者通过重写控件的 OnPaint 方法，运用 GDI+ 图形库进行绘制，同时引入定时器机制来控制动画效果。这种方法有效地改善了 WinForm 应用的视觉呈现，具有较高的实用价值和技术深度。</p>\n<h3 id=\"一个-net-开源免费功能强大的-ui-自动化库\">一个 .NET 开源免费、功能强大的 UI 自动化库</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19395009\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19395009</a></p>\n<p>FlaUI 是一个开源的.NET UI 自动化库，专为 Windows 桌面应用的自动化测试设计。它基于 Microsoft 的 UI Automation 库构建，提供灵活的 API，便于开发者编写测试脚本。该库适用于功能测试、回归测试和 UI 验证等场景。文章包含创建项目的步骤以及具体代码示例，展示如何操作记事本。读者可以通过提供的 GitHub 链接获取项目源码，并关注相关优质项目和框架以提升开发效率。</p>\n<h3 id=\"net-数据摄取与向量化架构构建企业级检索增强生成rag管道\">.NET 数据摄取与向量化架构：构建企业级检索增强生成（RAG）管道</h3>\n<p><a href=\"https://www.cnblogs.com/shanyou/p/19408104\" target=\"_blank\">https://www.cnblogs.com/shanyou/p/19408104</a></p>\n<p>本文探讨了生成式人工智能在企业级应用开发中的应用，介绍了微软的 Microsoft.Extensions.DataIngestion 和 Microsoft.Extensions.VectorData 库。这些库标志着从实验性到标准化 AI 数据管道的转变。文章分析了如何通过统一文档表示解决非结构化数据处理的挑战，并探讨了数据摄取流程的标准化。模块化和解耦设计提高了灵活性，使开发者可以便捷地调整底层架构。此外，文中还阐述了选择 Markdown 作为中间格式的优势，增强了对大语言模型的兼容性。这些技术展现了现代 AI 应用的未来方向。</p>\n<h3 id=\"全栈开发实战wpfffmpeggis打造工业级雷达探测终端\">全栈开发实战：WPF+FFmpeg+GIS，打造工业级雷达探测终端</h3>\n<p><a href=\"https://www.cnblogs.com/yuanchenhui/p/19387990/radar-client\" target=\"_blank\">https://www.cnblogs.com/yuanchenhui/p/19387990/radar-client</a></p>\n<p>在工业软件的国产化和智能升级中，开发者需将技术转化为实用方案。本文介绍一款工业级雷达探测终端的开发过程，涵盖架构设计、编码和功能实现，融合 WPF、多协议通信、GIS 可视化等技术，确保高精度和易用性。系统采用模块化设计，保障稳定性并预留扩展空间。核心技术包括 GPU 加速可视化、高效数据处理和智能预警，能够精准监测、实时展示和报警满足个性化需求，实现多设备联动和历史数据回溯。整体设计注重用户体验，通过灵活的控制选项和直观的界面提升操作效率。</p>\n<h3 id=\"问世间exe-是何物直教-ai-沉默web-寡言4\">问世间，exe 是何物？直教 AI 沉默、Web 寡言（4）</h3>\n<p><a href=\"https://www.cnblogs.com/sunhui/p/19399320\" target=\"_blank\">https://www.cnblogs.com/sunhui/p/19399320</a></p>\n<p>这篇文章探讨了桌面应用程序的深层意义，认为编译后的 exe 文件并非简单工具，而是拥有自身生命的复杂系统。作者通过比喻和哲学思考，指出每个应用都是潜在的浏览器，强调开发者应意识到程序的无限可能性。文章在编程背后传达了关于选择和意图的重要理念，鼓励开发者拥抱新技术，发现隐藏在代码中的创新潜力。</p>\n<h3 id=\"译在-visual-studio-2026-中减少升级时间增加编码时间\">【译】在 Visual Studio 2026 中，减少升级时间，增加编码时间</h3>\n<p><a href=\"https://www.cnblogs.com/MeteorSeed/p/19403351\" target=\"_blank\">https://www.cnblogs.com/MeteorSeed/p/19403351</a></p>\n<p>Visual Studio 2026 提供更简便的安装体验，自动复制 Visual Studio 2022 的配置，节省配置时间。它支持多种工具集和 SDK，允许独立更新 IDE 而保持兼容性。设置助手可以快速重定向项目到最新版本，并轻松安装缺失的依赖项。内置的 GitHub Copilot 应用现代化功能，能帮助用户将项目迁移至 Azure。发布更新的速度加快，用户可通过“Update on Close”功能轻松保持最新版本。整体体验更加高效和便捷。</p>\n<h3 id=\"maf-快速入门8条件路由工作流\">MAF 快速入门（8）条件路由工作流</h3>\n<p><a href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper08\" target=\"_blank\">https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper08</a></p>\n<p>本文介绍了在 MAF 中如何实现条件路由，特别是在企业内部邮件检测的工作流中应用。条件路由可以根据邮件是否为垃圾邮件来决定后续处理步骤。使用 Conditional Edge 实现 if-else 决策，案例展示了如何通过 LLM 判断邮件，并将其转交给相应的节点。设置.NET 控制台应用程序，读取 LLM API 信息并定义数据模型。本文提供了实用的技术方案，适合开发者学习与应用。</p>\n<h3 id=\"cnetnet-core-技术前沿周刊--第-64-期2025-年-121-1221\">C#/.NET/.NET Core 技术前沿周刊 | 第 64 期（2025 年 12.1-12.21）</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19384367\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19384367</a></p>\n<p>这篇文章介绍了 C#/.NET/.NET Core 技术的最新动态，包括实用类库、Visual Studio 2026 的下载和安装教程、UI 自动化库 FlaUI、多态反序列化的安全性分析、.NET 和.NET Framework 的服务更新、如何用.NET MAUI 构建 iOS 小部件以及.NET 10 的网络改进。这些内容提供了最新的技术指南和实用工具，帮助开发者提升编程效率和简化开发流程。</p>\n<h3 id=\"基于-blazor-实现的样品扫码比对管理系统\">基于 Blazor 实现的样品扫码比对管理系统</h3>\n<p><a href=\"https://www.cnblogs.com/known/p/19399622\" target=\"_blank\">https://www.cnblogs.com/known/p/19399622</a></p>\n<p>样品扫码比对管理系统集成 PDA 和 PC 端，采用 C#+Blazor 框架开发。PC 端可录入样品信息、统计比对记录，PDA 端支持扫码登录和比对操作。系统共用网址，使用 PWA 技术，数据库为 MySQL，并部署于阿里云 ECS，安全措施包括 HTTPS 和 RBAC 权限控制。功能模块涵盖样品信息管理、比对记录查询和系统设置。技术难点在于实现 PDA 按键扫码和避免弹出软键盘，依赖 JS 模拟键盘输入。系统实现了效率和安全性。</p>\n<h3 id=\"bi-报表及可视化分析类工具使用经验总结上\">BI 报表及可视化分析类工具使用经验总结（上）</h3>\n<p><a href=\"https://www.cnblogs.com/davablog/p/19205294\" target=\"_blank\">https://www.cnblogs.com/davablog/p/19205294</a></p>\n<p>这篇文章总结了作者作为数据工程师使用的各种 BI 报表和可视化工具，包括微软 SSRS、Oracle BIEE、帆软 FineReport、网易有数 BI 等。作者分享了每种工具的特点和适用场景，指出了它们的优缺点和功能。文章还探讨了工具的部署架构，包括 C/S 和 B/S 架构的区别及具体应用。通过多年的实践经验，作者提供了对数据工程师在工作中如何选择和使用这些工具的指导，强调了工具在分析和展示数据中的重要性。</p>\n<h3 id=\"rabbitmq-发布订阅模式多实例消费者防止重复消费实现方式\">RabbitMQ 发布订阅模式多实例消费者防止重复消费实现方式</h3>\n<p><a href=\"https://www.cnblogs.com/zhaorong/p/19392986\" target=\"_blank\">https://www.cnblogs.com/zhaorong/p/19392986</a></p>\n<p>本文讨论了 RabbitMQ 在 C#中的应用，介绍了如何通过实现发布订阅模式来防止消息重复消费。文章提供了详细的环境搭建步骤，包括 Docker 上部署 RabbitMQ 及添加相关包，重点在于配置和代码示例，以便读者能够快速上手。针对 RabbitMQ.Client 的依赖管理，文中指出了版本更新后的异步处理变化，确保读者可顺利使用最新特性。整体内容通过实例引导读者实现基本功能，具有实用性和指导性。</p>\n<h3 id=\"maui-库推荐三syncfusionmauitoolkit\">MAUI 库推荐三：Syncfusion.Maui.Toolkit</h3>\n<p><a href=\"https://www.cnblogs.com/sesametech-dotnet/p/19401006\" target=\"_blank\">https://www.cnblogs.com/sesametech-dotnet/p/19401006</a></p>\n<p>Syncfusion Toolkit for .NET MAUI 是一个高质量的用户界面控件工具包，支持开发跨平台的高性能应用程序。它帮助开发者在短时间内创建美观且功能丰富的应用。该工具包支持多种控件，包括数据可视化、日历、编辑控件、导航和按钮等，适用于 iOS、Android、macOS 和 Windows。通过 NuGet 轻松安装，并且有详细的文档支持。项目地址为 <a href=\"https://github.com/syncfusion/maui-toolkit\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/syncfusion/maui-toolkit</a>，采用 MIT 授权，方便开发者使用。</p>\n<h3 id=\"译azure-mcp-服务器现已内置到-visual-studio-2026-中智能体工作流的新时代\">【译】Azure MCP 服务器现已内置到 Visual Studio 2026 中：智能体工作流的新时代</h3>\n<p><a href=\"https://www.cnblogs.com/MeteorSeed/p/19381988\" target=\"_blank\">https://www.cnblogs.com/MeteorSeed/p/19381988</a></p>\n<p>Azure MCP 服务器工具已在 Visual Studio 2026 中集成，使云资源管理更高效。开发人员可以利用自然语言生成代码，查询管理 Azure 资源。此工具简化了开发流程，减少上下文切换，提高了工作效率。Visual Studio 2026 提供了自动化 CI/CD 设置和 Azure CLI 命令生成等功能，进一步增强开发体验。通过此技术，开发者能够专注于构建创新、安全的应用程序，提升工作效果。</p>\n<h3 id=\"opencvsharp使用霍夫变换检测直线\">OpenCVSharp：使用霍夫变换检测直线</h3>\n<p><a href=\"https://www.cnblogs.com/mingupupu/p/19390228\" target=\"_blank\">https://www.cnblogs.com/mingupupu/p/19390228</a></p>\n<p>霍夫变换是一种计算机视觉技术，用于图像中几何形状的检测。它将图像点映射到参数空间，以识别直线等形状。该技术在图像噪声和部分遮挡中表现出鲁棒性，广泛应用于道路检测和文档分析。实践中，使用 Canny 边缘检测进行预处理，随后运行标准和概率霍夫变换，以提取和绘制检测到的线条。此过程提供了关于性能的耗时记录，确保了实用性和效率。</p>\n<h3 id=\"重试死信与补偿策略失败处置流水线的设计防雪崩的节流思路\">重试、死信与补偿策略——失败处置流水线的设计，防雪崩的节流思路</h3>\n<p><a href=\"https://www.cnblogs.com/shiyuelp/p/19401138\" target=\"_blank\">https://www.cnblogs.com/shiyuelp/p/19401138</a></p>\n<p>本文讨论如何在分布式系统中构建弹性消息系统，重点关注失败处理机制。通过精心设计的重试策略，文章强调了指数退避算法的重要性，以避免瞬时故障造成的资源浪费。内容涉及同步和异步重试的适用场景，以及基于异常类型的差异化重试策略，旨在确保系统在异常情况下的稳定性和可靠性。</p>\n<h3 id=\"aspnet-core-依赖注入的三种服务生命周期\">ASP.NET Core 依赖注入的三种服务生命周期</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19401414\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19401414</a></p>\n<p>依赖注入是实现控制反转的设计模式，用于构建松耦合应用。ASP.NET Core 内置强大的 DI 容器，支持瞬态、作用域和单例三种服务生命周期。瞬态服务在每次请求时创建新实例，适用于轻量级无状态服务。作用域服务在同一 HTTP 请求内共享实例，适合需要状态共享的场景，如数据库上下文。单例服务在应用生命周期内共享一个实例，适用于无状态的全局服务。文章详细解析了这三种生命周期的特点与适用场景，帮助开发者合理选择。参考资料来自官方文档。</p>\n<h3 id=\"net-如何优雅的实现发送邮件服务\">Net 如何优雅的实现发送邮件服务</h3>\n<p><a href=\"https://www.cnblogs.com/net-kevin-li/p/19403699\" target=\"_blank\">https://www.cnblogs.com/net-kevin-li/p/19403699</a></p>\n<p>本文介绍了如何使用.NET 中的 SmtpClient 类发送邮件，并提及了相关的企业级 SaaS 智能应用架构。作者强调前后端分离的设计，描述了所采用的技术如 Vue3 和 SignalR 等，且提供了项目的 GitHub 和 Gitee 地址。具体实现部分展示了 EmailService 类的代码，涵盖了邮件服务的初始化、配置 SMTP 客户端及发送邮件的基本方法，这些内容具有良好的技术深度和实用性。</p>\n<h3 id=\"分库分表数据源-shardingspheredatasource-的-connection-元数据误用问题分析\">分库分表数据源 ShardingSphereDataSource 的 Connection 元数据误用问题分析</h3>\n<p><a href=\"https://www.cnblogs.com/wuyuegb2312/p/19405814\" target=\"_blank\">https://www.cnblogs.com/wuyuegb2312/p/19405814</a></p>\n<p>本文讨论了使用 ShardingSphere 进行分库分表的应用及遇到的问题。作者分享了在直接操作数据库元数据时的一个具体案例，强调了逻辑库名与物理库名的区别。提供了代码示例，展示了如何查询以特定前缀命名的表，并对其进行结构变更。文章同样指出了代码中存在的潜在错误，确保对两种库名的正确使用至关重要。总结了调试过程中的经验教训，旨在帮助开发者更高效地处理类似问题。</p>\n<h2 id=\"今日人物\">今日人物</h2>\n<p><strong>埃德加·弗兰克·科德</strong>（英语：Edgar Frank Codd， 1923 年 8 月 23 日—2003 年 4 月 18 日），小名泰德·科德（Ted Codd），生于<a href=\"https://zh.wikipedia.org/wiki/%E8%8B%B1%E5%9B%BD\" rel=\"noopener nofollow\" target=\"_blank\">英国</a><a href=\"https://zh.wikipedia.org/wiki/%E8%8B%B1%E6%A0%BC%E5%85%B0\" rel=\"noopener nofollow\" target=\"_blank\">英格兰</a><a href=\"https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%A1%9E%E7%89%B9%E9%83%A1\" rel=\"noopener nofollow\" target=\"_blank\">多塞特郡</a>的<a href=\"https://zh.wikipedia.org/w/index.php?title=%E6%B3%A2%E7%89%B9%E5%85%B0_(%E5%A4%9A%E5%A1%9E%E7%89%B9%E9%83%A1)&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">波特兰</a>，<a href=\"https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA\" rel=\"noopener nofollow\" target=\"_blank\">计算机</a><a href=\"https://zh.wikipedia.org/wiki/%E7%A7%91%E5%AD%A6%E5%AE%B6\" rel=\"noopener nofollow\" target=\"_blank\">科学家</a>。他为<a href=\"https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93\" rel=\"noopener nofollow\" target=\"_blank\">关系型数据库</a><a href=\"https://zh.wikipedia.org/wiki/%E7%90%86%E8%AE%BA\" rel=\"noopener nofollow\" target=\"_blank\">理论</a>做出了奠基性的贡献。他在<a href=\"https://zh.wikipedia.org/wiki/IBM\" rel=\"noopener nofollow\" target=\"_blank\">IBM</a>工作期间，首创了<a href=\"https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B\" rel=\"noopener nofollow\" target=\"_blank\">关系模型</a>理论。他一生中为<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" rel=\"noopener nofollow\" target=\"_blank\">计算机科学</a>做出了很多有价值的贡献，而<a href=\"https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B\" rel=\"noopener nofollow\" target=\"_blank\">关系模型</a>，作为一个在<a href=\"https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">数据库管理</a>方面非常具有影响力的<a href=\"https://zh.wikipedia.org/w/index.php?title=%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">基础理论</a>，仍然被认为是他最引人瞩目的成就。</p>\n<p>埃德加·弗兰克·科德生于英格兰的<a href=\"https://zh.wikipedia.org/wiki/%E6%B3%A2%E7%89%B9%E5%85%B0%E5%B2%9B_(%E8%8B%B1%E5%9B%BD)\" rel=\"noopener nofollow\" target=\"_blank\">波特兰岛</a>。在<a href=\"https://zh.wikipedia.org/wiki/%E7%89%9B%E6%B4%A5%E5%A4%A7%E5%AD%A6%E5%9F%83%E5%85%8B%E5%A1%9E%E7%89%B9%E5%AD%A6%E9%99%A2\" rel=\"noopener nofollow\" target=\"_blank\">牛津大学埃克塞特学院</a>主修<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6\" rel=\"noopener nofollow\" target=\"_blank\">数学</a>与<a href=\"https://zh.wikipedia.org/wiki/%E5%8C%96%E5%AD%A6\" rel=\"noopener nofollow\" target=\"_blank\">化学</a>，<a href=\"https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%96%E7%95%8C%E5%A4%A7%E6%88%98\" rel=\"noopener nofollow\" target=\"_blank\">第二次世界大战</a>期间，成为<a href=\"https://zh.wikipedia.org/wiki/%E8%8B%B1%E5%9C%8B%E7%9A%87%E5%AE%B6%E7%A9%BA%E8%BB%8D\" rel=\"noopener nofollow\" target=\"_blank\">英国皇家空军</a>的<a href=\"https://zh.wikipedia.org/wiki/%E9%A3%9E%E8%A1%8C%E5%91%98\" rel=\"noopener nofollow\" target=\"_blank\">飞行员</a>参战。</p>\n<p>1948 年，他来到<a href=\"https://zh.wikipedia.org/wiki/%E7%BA%BD%E7%BA%A6\" rel=\"noopener nofollow\" target=\"_blank\">纽约</a>，加入了<a href=\"https://zh.wikipedia.org/wiki/IBM\" rel=\"noopener nofollow\" target=\"_blank\">IBM</a>公司，成为一名<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6\" rel=\"noopener nofollow\" target=\"_blank\">数学</a><a href=\"https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E5%91%98\" rel=\"noopener nofollow\" target=\"_blank\">程序员</a>。</p>\n<p>1953 年，出于对<a href=\"https://zh.wikipedia.org/wiki/%E5%8F%83%E8%AD%B0%E5%93%A1\" rel=\"noopener nofollow\" target=\"_blank\">参议员</a><a href=\"https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%C2%B7%E9%BA%A6%E5%8D%A1%E9%94%A1\" rel=\"noopener nofollow\" target=\"_blank\">约瑟夫·麦卡锡</a>的不满，他迁往<a href=\"https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%8B%BF%E5%A4%A7\" rel=\"noopener nofollow\" target=\"_blank\">加拿大</a><a href=\"https://zh.wikipedia.org/wiki/%E6%B8%A5%E5%A4%AA%E5%8D%8E\" rel=\"noopener nofollow\" target=\"_blank\">渥太华</a>，居住了十年。</p>\n<p>之后他回到<a href=\"https://zh.wikipedia.org/wiki/%E5%AF%86%E6%AD%87%E6%A0%B9%E5%A4%A7%E5%AD%A6\" rel=\"noopener nofollow\" target=\"_blank\">密歇根大学</a>并取得了<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" rel=\"noopener nofollow\" target=\"_blank\">计算机科学</a><a href=\"https://zh.wikipedia.org/wiki/%E5%8D%9A%E5%A3%AB\" rel=\"noopener nofollow\" target=\"_blank\">博士</a>学位。两年后，科德去往<a href=\"https://zh.wikipedia.org/wiki/IBM\" rel=\"noopener nofollow\" target=\"_blank\">IBM</a>公司位于<a href=\"https://zh.wikipedia.org/wiki/%E8%81%96%E8%8D%B7%E8%A5%BF_(%E5%8A%A0%E5%88%A9%E7%A6%8F%E5%B0%BC%E4%BA%9E%E5%B7%9E)\" rel=\"noopener nofollow\" target=\"_blank\">圣何塞</a>的<a href=\"https://zh.wikipedia.org/w/index.php?title=%E9%98%BF%E5%B0%94%E9%A9%AC%E7%99%BB%E7%A0%94%E7%A9%B6%E4%B8%AD%E5%BF%83&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">阿尔马登研究中心</a>工作。</p>\n<p>1968 年，针对“<a href=\"https://zh.wikipedia.org/wiki/%E7%B4%B0%E8%83%9E%E8%87%AA%E5%8B%95%E6%A9%9F\" rel=\"noopener nofollow\" target=\"_blank\">细胞自动机</a>”提出自己的“<a href=\"https://zh.wikipedia.org/w/index.php?title=%E7%A7%91%E5%BE%B7%E7%B4%B0%E8%83%9E%E8%87%AA%E5%8B%95%E6%A9%9F&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">科德细胞自动机</a>”（以<a href=\"https://zh.wikipedia.org/wiki/%E7%8E%8B%E6%B5%A9_(%E6%95%B0%E5%AD%A6%E5%AE%B6)\" rel=\"noopener nofollow\" target=\"_blank\">王浩</a>的“<a href=\"https://zh.wikipedia.org/w/index.php?title=Wang_B-machine&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">Wang B-machine</a>”为基础）论点，以探讨“<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E7%94%9F%E5%91%BD\" rel=\"noopener nofollow\" target=\"_blank\">人工生命</a>”议题。</p>\n<p>1981 年，科德因在<a href=\"https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93\" rel=\"noopener nofollow\" target=\"_blank\">关系型数据库</a>方面的贡献获得了<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96\" rel=\"noopener nofollow\" target=\"_blank\">图灵奖</a>。</p>\n<p>2003 年 4 月 18 日，科德因<a href=\"https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E7%97%85\" rel=\"noopener nofollow\" target=\"_blank\">心脏病</a>在<a href=\"https://zh.wikipedia.org/wiki/%E4%BD%9B%E7%BD%97%E9%87%8C%E8%BE%BE\" rel=\"noopener nofollow\" target=\"_blank\">佛罗里达</a><a href=\"https://zh.wikipedia.org/w/index.php?title=%E5%A8%81%E5%BB%89%E5%A7%86%E6%96%AF%E5%B2%9B&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">威廉姆斯岛</a>的家中去世，享年 79 岁。<img alt=\"img-1\" src=\"https://img2024.cnblogs.com/blog/997046/202601/997046-20260125193726518-2140612999.jpg\" /></p>\n<h2 id=\"c-net-交流群\">C# .NET 交流群</h2>\n<p>相信大家在开发中经常会遇到一些性能问题，苦于没有有效的工具去发现性能瓶颈，或者是发现瓶颈以后不知道该如何优化。之前一直有读者朋友询问有没有技术交流群，但是由于各种原因一直都没创建，现在很高兴的在这里宣布，我创建了一个专门交流.NET 性能优化经验的群组，主题包括但不限于：</p>\n<ul>\n<li>如何找到.NET 性能瓶颈，如使用 APM、dotnet tools 等工具</li>\n<li>.NET 框架底层原理的实现，如垃圾回收器、JIT 等等</li>\n<li>如何编写高性能的.NET 代码，哪些地方存在性能陷阱</li>\n</ul>\n<p>希望能有更多志同道合朋友加入，分享一些工作中遇到的.NET 问题和宝贵的分析优化经验。<strong>目前一群已满，现在开放二群。</strong>可以加我 vx，我拉你进群: <strong>ls1075</strong> 另外也创建了 <strong>QQ Group</strong>: 687779078，欢迎大家加入。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 19:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/InCerry\">InCerry</a>&nbsp;\n阅读(<span id=\"post_view_count\">63</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【EF Core】实体状态与变更追踪",
      "link": "https://www.cnblogs.com/tcjiaan/p/19528796",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tcjiaan/p/19528796\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 18:41\">\n    <span>【EF Core】实体状态与变更追踪</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>好长时间没有水文章了，请容老周解释一下。因为最近老周进了两个厂，第一个厂子呆了八天左右，第二个厂子还在调试。管理很严格，带的电子设备都要登记、办手续。当初觉得雷神笔记本的屏幕大，在车间调试代码方便，所以登记了这个型号。但这个游戏本功耗大，而且充电只能充到 83% 就充不进去了。只能白天在车间调试时用，其他时间玩手机。手机是那个 23800 mAH 的坦克3，所以电量多得是，充一次随便玩。在厂里很无聊，老周还另带了一台某宝买的开源掌机……扯远了。</p>\n<p>第二个厂子的项目很诡异，老周甚至怀疑有人故意捣乱。他们工人自己测试的时候，总是报莫名其妙的错；但是，只要老周过去和他们一起测，就一切正常。反正现在是测不出到底啥问题。从日志中记录的异常看，都是 Modbus TCP 连接超时。把 time out 改为 50 分钟，也照样在无限连接中。老周觉得是人为拨了网线的可能性更大。反正只要老周在现场就没问题，所以耗了近一个月也没结果。所以老周就请了四天假玩玩，不管他们同不同意，四天后老周准时回去报到。</p>\n<p>--------------------------------------------------------------------------------------------------------------------------------------------------------------------</p>\n<p>记得上一篇水文中，老周说了把一个实体映射到多个表的话题。注意，一实体一数据表的原则是不变的，这种特殊情况可以用在你这几个表可以组成一个整体，并且经常一起使用的，这样你在查询时就不用联合了，一般是一对一关系的。</p>\n<p>熟悉老周的人都知道，老周分享的都是纯知识和纯技术的东西。至于实际开发中怎么用，那是你的事。实际应用是没办法写教程的，你得看具体情况，灵活运用，不存在一个教程包万能的道理。做项目我从小周做成了老周，虽然没做过什么大项目，但小 Case 是不少的（吹吹牛皮）。你别小看那些杂七杂八的项目，哪个不是要六边形战士，哪个不是软硬结合，哪个不是既485又CAN又PLC又单片机的。别看它小，WinForms、Web、STM32（珠海极海的 APM32 也遇到过）、串口、Esp8266 全用上都是常见的事。这年头，不学点 C 语言连小项目都搞不起，哪像那些互联网巨头那么爽，天天盯着 HTML + CSS 玩。</p>\n<p>老周一直觉得，经验其实不重要的，跟一两周的项目你都有经验了，关键还得是基础扎实、技术过硬，这样才能来什么活接什么活。至于说基础问题，干活的家伙，实战更重要，理论的东西其实知道是啥就好，咱们又不用写论文评职称。你理论知识说得一套一套的，真用的时候不会用，那有啥用？不要排斥实用主义，实用主义其实是正确的，技术学了就是拿来用的，不用就没意义了。学习是分两种的：一种是内修——比如琴棋书画，这是文化底蕴，个人气质。这种你不必学了就要用（但也可以用），更重要的是养心养神，自我调整；另一种就是工作干活用的，叫技能，属于外修。从小老师都教我们要内外兼修。</p>\n<p>好了，不扯了。在开始今天的主题前，咱们补一个内容：既然实体能分布到多个表中，那反过来呢？能把多个实体映射到一个表中吗？当然可以了，官方称作“表拆分”。同样的道理，一般也是一对一的关系。</p>\n<p>光说不练，惨过失恋。咱们直接用实例来说明。假设下面有两个实体。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Person\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> PsID { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> Name { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">null</span>!<span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> Age {  <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 导航属性</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">public</span> PersonInfo OtherInfo { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">null</span>!<span style=\"color: rgba(0, 0, 0, 1);\">;\n}\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> PersonInfo\n{\n    </span><strong><span style=\"background-color: rgba(255, 255, 0, 1);\"><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> InfoID {  <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; }</span></strong>        <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 既做主键也做外键</span>\n    <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n    <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 体重\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> Weight { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n    <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 身高\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> Height {  <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n    <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 民族\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span>? Ethnicity {  <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n}</span></pre>\n</div>\n<p>待会儿咱们要做的是把这两个实体映射到一个表中，所以为了安全，你可以让 PersonInfo 实体的&nbsp;InfoID 属性变成私有成员，这可以防止三只手的人意外修改主键值。因为这个实体的 ID 值必须始终与 Person 的 ID 一致。</p>\n<p>下面代码是数据库上下文类。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> DemoDbContext : DbContext\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> DbSet&lt;Person&gt; People { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> DbSet&lt;PersonInfo&gt; PersonInfos { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">protected</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">data source=恭喜发财.db</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                                .LogTo(\n                                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 输出日志的委托</span>\n                                    action: msg =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> Console.WriteLine(msg),\n                                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 过滤器，只显示即将执行的命令日志，可以看到SQL语句</span>\n                                    filter: (eventId, _) =&gt; eventId.Id ==<span style=\"color: rgba(0, 0, 0, 1);\"> RelationalEventId.CommandExecuting\n                                );\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">protected</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> OnModelCreating(ModelBuilder modelBuilder)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 配置实体</span>\n        modelBuilder.Entity&lt;Person&gt;(pse =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n        {\n            pse.<strong><span style=\"background-color: rgba(255, 255, 0, 1);\">Property(e </span></strong></span><strong><span style=\"background-color: rgba(255, 255, 0, 1);\">=&gt; e.PsID).HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">person_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span></span></strong><span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: rgba(255, 255, 0, 1);\">)</span></strong>;\n            pse.Property(b </span>=&gt; b.Name).HasMaxLength(<span style=\"color: rgba(128, 0, 128, 1);\">16</span>).IsRequired().HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">person_name</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            pse.Property(d </span>=&gt; d.Age).HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">person_age</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 主键</span>\n            pse.HasKey(w =&gt; w.PsID).<strong><span style=\"background-color: rgba(255, 255, 0, 1);\">HasName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">PK_Person</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span></span></strong><span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: rgba(255, 255, 0, 1);\">)</span></strong>;\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 表名</span>\n            pse.<strong><span style=\"background-color: rgba(255, 255, 0, 1);\">ToTable(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">tb_people</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span></span></strong><span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: rgba(255, 255, 0, 1);\">)</span></strong>;\n        });\n        modelBuilder.Entity</span>&lt;PersonInfo&gt;(pie =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n        {\n            pie.<strong><span style=\"background-color: rgba(255, 255, 0, 1);\">Property(</span></strong></span><strong><span style=\"background-color: rgba(255, 255, 0, 1);\"><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">InfoID</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">person_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span></span></strong><span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: rgba(255, 255, 0, 1);\">).ValueGeneratedNever()</span></strong>;\n            pie.Property(r </span>=&gt; r.Height).HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">info_height</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            pie.Property(i </span>=&gt; i.Weight).HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">info_weight</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            pie.Property(k </span>=&gt; k.Ethnicity).HasMaxLength(<span style=\"color: rgba(128, 0, 128, 1);\">10</span>).HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">info_ethnic</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 主键</span>\n            pie.HasKey(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">InfoID</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).<strong><span style=\"background-color: rgba(255, 255, 0, 1);\">HasName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">PK_Person</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span></span></strong><span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: rgba(255, 255, 0, 1);\">)</span></strong>;\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 同一个表名</span>\n            pie.<strong><span style=\"background-color: rgba(255, 255, 0, 1);\">ToTable(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">tb_people</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span></span></strong><span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: rgba(255, 255, 0, 1);\">)</span></strong>;\n        });\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 两实体的关系</span>\n        modelBuilder.Entity&lt;Person&gt;().HasOne(n =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> n.OtherInfo)\n                                                          .WithOne()\n                                                          </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> info --&gt; person</span>\n                                                          .HasForeignKey&lt;PersonInfo&gt;(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">InfoID</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).HasConstraintName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">FK_PersonInfo</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                                                          </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> person --&gt; info</span>\n                                                          .HasPrincipalKey&lt;Person&gt;(p =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> p.PsID);\n    }\n}</span></pre>\n</div>\n<p>基本代码相信各位能看懂的。和配置一般实体区别不大，但要注意几点：</p>\n<p>1、两个实体所映射的表名要相同。这是F话了，都说映射到同一个表了，表名能不一样的？</p>\n<p>2、两个实体中作为主键的属性名可以不同，但类型要相同（可以减少翻车事故）；更重要的是：<span style=\"text-decoration: underline; font-size: 16px;\"><span style=\"color: rgba(255, 0, 0, 1); text-decoration: underline;\"><strong>一定要映射到同一个列名</strong></span></span>。因为映射后，两个实体作为主键的属性会合并；再者，<span style=\"text-decoration: underline;\"><span style=\"color: rgba(255, 0, 0, 1);\"><strong><span style=\"font-size: 16px;\">主键的约束名称也要相同</span></strong></span></span>，不解释了，一样的道理。</p>\n<div class=\"cnblogs_code\">\n<pre>modelBuilder.Entity&lt;Person&gt;(pse =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    pse.Property(e </span>=&gt; e.PsID).HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1); background-color: rgba(255, 255, 0, 1);\">person_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    ……\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 主键</span>\n    pse.HasKey(w =&gt; w.PsID).HasName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1); background-color: rgba(255, 255, 0, 1);\">PK_Person</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 表名</span>\n    pse.ToTable(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1); background-color: rgba(255, 255, 0, 1);\">tb_people</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n});\nmodelBuilder.Entity</span>&lt;PersonInfo&gt;(pie =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    pie.Property(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">InfoID</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).HasColumnName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1); background-color: rgba(255, 255, 0, 1);\">person_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">).ValueGeneratedNever();\n    ……\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 主键</span>\n    pie.HasKey(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">InfoID</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).HasName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1); background-color: rgba(255, 255, 0, 1);\">PK_Person</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 同一个表名</span>\n    pie.ToTable(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1); background-color: rgba(255, 255, 0, 1);\">tb_people</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n});</span></pre>\n</div>\n<p>对于第二个实体，ValueGeneratedNever 方法可以不调用，EF 会自动感知到不需要自动生成列值。</p>\n<p>3、两个实体配置为一对一关系，这个和常规实体操作一样。</p>\n<p>然后在 Main 方法中测试一下。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> Main(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">[] args)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span> context = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> DemoDbContext();\n    context.Database.EnsureDeleted();\n    context.Database.EnsureCreated();\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印数据库模型</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Console.WriteLine(context.Model.ToDebugString());\n}</span></pre>\n</div>\n<p>运行结果：</p>\n<div class=\"cnblogs_code\">\n<pre>      Executing DbCommand [Parameters=[], CommandType=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">Text</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, CommandTimeout=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">30</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">]\n      CREATE TABLE </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">tb_people</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\"> (\n          </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">person_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> INTEGER NOT NULL CONSTRAINT <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">PK_Person</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\"> PRIMARY KEY AUTOINCREMENT,\n          </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">person_name</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\"> TEXT NOT NULL,\n          </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">person_age</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\"> INTEGER NOT NULL,\n          </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">info_weight</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\"> REAL NOT NULL,\n          </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">info_height</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\"> REAL NOT NULL,\n          </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">info_ethnic</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\"> TEXT NULL\n      );\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 以下是数据库模型</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">Model:\n  EntityType: Person\n    Properties:\n      PsID (</span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">) Required PK AfterSave:Throw ValueGenerated.OnAdd\n      Age (</span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">) Required\n      Name (</span><span style=\"color: rgba(0, 0, 255, 1);\">string</span>) Required MaxLength(<span style=\"color: rgba(128, 0, 128, 1);\">16</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    Navigations:\n      OtherInfo (PersonInfo) Required ToDependent PersonInfo\n    Keys:\n      PsID PK\n  EntityType: PersonInfo\n    Properties:\n      InfoID (</span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">) Required PK FK AfterSave:Throw\n      Ethnicity (</span><span style=\"color: rgba(0, 0, 255, 1);\">string</span>) MaxLength(<span style=\"color: rgba(128, 0, 128, 1);\">10</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n      Height (</span><span style=\"color: rgba(0, 0, 255, 1);\">float</span><span style=\"color: rgba(0, 0, 0, 1);\">) Required\n      Weight (</span><span style=\"color: rgba(0, 0, 255, 1);\">float</span><span style=\"color: rgba(0, 0, 0, 1);\">) Required\n    Keys:\n      InfoID PK\n    Foreign keys:\n      PersonInfo {</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">InfoID</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>} -&gt; Person {<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">PsID</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>} Unique Required RequiredDependent Cascade ToDependent: OtherInfo</pre>\n</div>\n<p>--------------------------------------------------------------------------------------------------------------------------------------</p>\n<p>下面正片开始。今天咱们说说 EF Core 中几大主要功能模块之一——追踪（叫跟踪也行）。正常情况下，EF Core 从实体被查询出来的时候开始跟踪。跟踪前会为实体的各个属性/字段的值创建一个快照（就备份一下，不是拷贝对象，而是用一个字典来存放）。然后在特定条件下，会触发比较，即比较实体引用当前各属性的值与当初快照中的值，从而确定实体的状态。</p>\n<p>为了方便访问，DbContext 类会公开&nbsp;ChangeTracker 属性，通过它你能访问到由 EF Core 创建的&nbsp;ChangeTracker 实例（在Microsoft.EntityFrameworkCore.ChangeTracking 命名空间）。该类包含与实体追踪有关的信息。调用&nbsp;DetectChanges 方法会触发实体的追踪扫描，方法只负责触发状态检查，不返回任何结果，调用后实体的状态自动更新。实体的状态由&nbsp;EntityState 枚举表示。</p>\n<p>1、Unchanged：实体从数据库中查询出来后就是这个状态，前提是这个实体是从数据库中查出来的，也就是说它已经在数据库中了。</p>\n<p>2、Added：当你用 DbContext.Add 或 DbSet.Add 方法添加新实体后，实体就处在这个状态。实体只存在 EF Core 中，还没保存到数据库。提交时生成 INSERT 语句。</p>\n<p>3、Modified：已修改。实体自从数据库中查询出来到目前为止，它的某些属性或全部属性被修改过。提交时生成 UPDATE 语句。</p>\n<p>4、Deleted：已删除。实体已从 DbSet 中删除（还在数据库中）就是这个状态，提交后生成 DELETE 语句。</p>\n<p>5、Detached：失踪人口，EF Core 未追踪其状态。</p>\n<p>EF Core 内部有个名为&nbsp;IStateManager 的服务接口，默认实现类是&nbsp;StateManager。该类可以修改实体的状态，也可以控制开始/停止追踪实体的状态。咱们在写代码时不需要直接访问它，DbContext 以及 DbContext.ChangeTracker、DbSet 已经封装了相关访问入口。</p>\n<p>对 DbSet 对象来说，你调用 Add、Remove、Update 等方法只是更改了实体的状态，并没有真正更新到数据库，除非你调用 SaveChanges 方法。SaveChanges 方法内部会先调用&nbsp;DetectChanges 方法触发状态变更扫描，然后再根据实体的最新状态生成相应的 SQL 语句，再发送到数据库中执行。</p>\n<p>下面以插入新实体为例，演示一下。本示例在插入新实体前、后，以及提交到数据库后都打印一次实体的状态。</p>\n<p>先定义实体类。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Pet\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> Id { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> Name { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span>? Description { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span>? Category {  <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n}</span></pre>\n</div>\n<p>正规流程，写数据库上下文类。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> TestDbContext : DbContext\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">protected</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">data source=天宫赐福.db</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">protected</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> OnModelCreating(ModelBuilder modelBuilder)\n    {\n        modelBuilder.Entity</span>&lt;Pet&gt;(et =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n        {\n            et.ToTable(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">tb_pets</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            et.Property(g </span>=&gt; g.Name).HasMaxLength(<span style=\"color: rgba(128, 0, 128, 1);\">20</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            et.Property(k </span>=&gt; k.Description).HasMaxLength(<span style=\"color: rgba(128, 0, 128, 1);\">200</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            et.Property(q </span>=&gt; q.Category).HasMaxLength(<span style=\"color: rgba(128, 0, 128, 1);\">15</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            et.HasKey(m </span>=&gt; m.Id).HasName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">PK_PetID</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        });\n    }\n}</span></pre>\n</div>\n<p>好，现在进入测试环节。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> Main(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">[] args)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span> context = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TestDbContext();\n    context.Database.EnsureCreated();\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 添加一个实体</span>\n    Pet p = <span style=\"color: rgba(0, 0, 255, 1);\">new</span>() { Name = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Jack</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Description = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">不会游泳的巴西龟</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Category = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">爬行动物</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\"> };\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印一下状态</span>\n    Console.WriteLine(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">----------- 添加前 -------------</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine(context.ChangeTracker.DebugView.LongView);\n    context.Add(p);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 再打印一下状态</span>\n    Console.WriteLine(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n---------- 添加后 ------------</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine(context.ChangeTracker.DebugView.LongView);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 提交</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    context.SaveChanges();\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 再打印状态</span>\n    Console.WriteLine(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n---------- 提交后 ------------</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine(context.ChangeTracker.DebugView.LongView);\n}</span></pre>\n</div>\n<p>和 Model 类似，ChangeTracker 对象也有个 DebugView，用于获取调试用的信息。这个能打印出实体以及它的各个属性的状态。</p>\n<p>运行一遍，结果如下：</p>\n<div class=\"cnblogs_code\">\n<pre>----------- 添加前 -------------\n\n\n---------- 添加后 ------------<span style=\"color: rgba(0, 0, 0, 1);\">\nPet {Id: </span>-<span style=\"color: rgba(128, 0, 128, 1);\">2147482647</span><span style=\"color: rgba(0, 0, 0, 1);\">} Added\n    Id: </span>-<span style=\"color: rgba(128, 0, 128, 1);\">2147482647</span><span style=\"color: rgba(0, 0, 0, 1);\"> PK Temporary\n    Category: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">爬行动物</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Description: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">不会游泳的巴西龟</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Name: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">Jack</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>\n\n\n---------- 提交后 ------------<span style=\"color: rgba(0, 0, 0, 1);\">\nPet {Id: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">} Unchanged\n    Id: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\"> PK\n    Category: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">爬行动物</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Description: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">不会游泳的巴西龟</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Name: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">Jack</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span></pre>\n</div>\n<p>新实体被 Add 之前，它是没有被追踪的，所以打印状态信息空白。调用 Add 方法后，它的状态就变成 Added 了。此时，你不需要调用&nbsp;DetectChanges 方法，因为 Add 方法本身就会修改实体的状态。新实体还未存入数据库，所以主键 ID 赋了个负值，且是临时的。当调用 SaveChanges 方法后，提交数据库保存，并取回数据库生成的ID值，故此时 ID 的值是 1。而且，实体的状态被改回 Unchanged。这是合理的，现在新的实体已经在数据库了，而且自从插入后没有修改过，状态应当是 Unchaged。</p>\n<p>如果你有其他想法，希望在 SaveChanges 之后实体的状态不变回 Unchaged，可以这样调用 SaveChanges 方法。</p>\n<div class=\"cnblogs_code\">\n<pre>context.SaveChanges(acceptAllChangesOnSuccess: <span style=\"color: rgba(0, 0, 255, 1);\">false</span>);</pre>\n</div>\n<p>acceptAllChangesOnSuccess 参数设置为 false 后，数据库执行成功后不会改变实体的当前状态。于是，数据库中插入新记录后，实体状态还是 Added。</p>\n<div class=\"cnblogs_code\">\n<pre>---------- 添加后 ------------<span style=\"color: rgba(0, 0, 0, 1);\">\nPet {Id: </span>-<span style=\"color: rgba(128, 0, 128, 1);\">2147482647</span><span style=\"color: rgba(0, 0, 0, 1);\">} Added\n    Id: </span>-<span style=\"color: rgba(128, 0, 128, 1);\">2147482647</span><span style=\"color: rgba(0, 0, 0, 1);\"> PK Temporary\n    Category: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">爬行动物</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Description: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">不会游泳的巴西龟</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Name: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">Jack</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>\n\n\n---------- 提交后 ------------<span style=\"color: rgba(0, 0, 0, 1);\">\nPet {Id: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">} <strong><span style=\"background-color: rgba(255, 255, 0, 1);\">Added</span></strong>\n    Id: </span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\"> PK\n    Category: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">爬行动物</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Description: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">不会游泳的巴西龟</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    Name: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">Jack</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span></pre>\n</div>\n<p>这样做可能会导致逻辑错误，除非你有特殊用途，比如这样用。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span> context = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TestDbContext();\ncontext.Database.EnsureDeleted();\ncontext.Database.EnsureCreated();\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 处理事件</span>\ncontext.ChangeTracker.Tracked += (_, e) =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> backupcolor =<span style=\"color: rgba(0, 0, 0, 1);\"> Console.ForegroundColor;\n    Console.ForegroundColor </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> ConsoleColor.Green;\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">实体被追踪：\\n{e.Entry.DebugView.LongView}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.ForegroundColor </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> backupcolor;\n};\ncontext.ChangeTracker.StateChanged </span>+= (_, e) =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> bkColor =<span style=\"color: rgba(0, 0, 0, 1);\"> Console.ForegroundColor;\n    Console.ForegroundColor </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> ConsoleColor.Blue;\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">实体（ID={e.Entry.Property(nameof(Pet.Id)).CurrentValue}）状态改变：{e.OldState} --&gt; {e.NewState}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.ForegroundColor </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bkColor;\n};\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 新实体</span>\nPet p = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Pet { Name = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Tom</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Description = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">会游泳的鸟</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Category = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">猛禽</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\"> };\ncontext.Add(p);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保存，但状态不改变</span>\n<span style=\"background-color: rgba(255, 255, 0, 1);\">context.SaveChanges(<span style=\"color: rgba(0, 0, 255, 1);\">false</span></span><span style=\"color: rgba(0, 0, 0, 1);\"><span style=\"background-color: rgba(255, 255, 0, 1);\">)</span>;\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 因为是 Added 状态，所以还可以继续insert</span>\np.Name = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Simum</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\np.Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">三手青蛙</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\np.Category </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">两栖动物</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保存，状态改变</span>\n<span style=\"color: rgba(0, 0, 0, 1); background-color: rgba(255, 255, 0, 1);\">context.SaveChanges();\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 把它们查询出来看看</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> <span style=\"color: rgba(0, 0, 255, 1);\">set</span> = context.Set&lt;Pet&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n数据库中的记录：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span>(<span style=\"color: rgba(0, 0, 255, 1);\">var</span> pp <span style=\"color: rgba(0, 0, 255, 1);\">in</span> <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n{\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{pp.Id}  {pp.Name}  {pp.Description}  {pp.Category}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n}</span></pre>\n</div>\n<p>上面代码中，侦听了两个事件：Tracked——当 EF Core 开始跟踪某个实体时发生；当有实体的状态改变之后发生。其实还有一个&nbsp;StateChanging 事件，是在实体状态即将改变时发生。总结来说就是：状态改变之前发生&nbsp;StateChanging 事件，改变之后发生&nbsp;StateChanged 事件。要注意，StateChanged 和&nbsp;StateChanging 事件在 EF Core 首次追踪实体时不会引发。比如，刚开始追踪时状态为 Unchanged，不会引发事件，而之后状态变为 Added，就会引发事件（最开始那个状态不会触发事件）。</p>\n<p>上面代码处理 Tracked 事件，当开始追踪某实体时，打印一下调试信息，记录某状态；处理 StateChanged 事件，在开始追踪状态后，状态发生改变之后打印变化前后的状态。</p>\n<p>代码运行结果如下：</p>\n<p><img alt=\"image\" height=\"266\" src=\"https://img2024.cnblogs.com/blog/367389/202601/367389-20260125181401722-693660532.png\" width=\"288\" /></p>\n<p>首先，new 了一个 Pet 对象，赋值，再调用 Add 方法添加到数据集合中，此时状态会被改为 Added。Tracked 事件输出第一块绿色字体，表示实体开始追踪的状态为 Added，ID 值是随机分配的负值，并说明是临时主键值。</p>\n<p>然后调用 SaveChanges 方法并传递 false 给acceptAllChangesOnSuccess&nbsp;参数，表明 INSERT 进数据库后，状态不改变，还是 Added。</p>\n<p>然后，还是用那个实体实例，改变一下属性值，由于它的状态依旧是 Added，调用&nbsp;SaveChanges() 方法时未传参数，它会调用&nbsp;SaveChanges(acceptAllChangesOnSuccess: true)，结果是这次实体的状态变成了 Unchanged。就是输出结果中蓝色字体那一行。此时实体的 ID=2，记住这个值，待会儿用到。</p>\n<p>再往后，咱们 foreach 语句给 DbSet 会触发 EF Core 去查询数据库，于是，我们看到，控制台在“数据库中的记录：”一行之后又发生了 Tracked 事件，有一个 ID=1 的实体被追踪了，它刚从数据库中查询出来，就是第二块绿色字体那里。</p>\n<p>这时候你是不是迷乎了？不是从数据库查出两条记录吗，为什么只有 ID=1 的被追踪了，ID=2 呢？其实，ID = 2 已经被追踪了。忘了吗？它前面不是从 Added 状态变为 Unchanged 状态吗。这是因为咱们这一连串操作都在同一个 DbContext 实例的生命周期进行的，EF Core 对实体的追踪不会断开。</p>\n<p>如果你把上面的代码改成这样，那就明白了。</p>\n<div class=\"cnblogs_code\">\n<pre>    <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> Main(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">[] args)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">using</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> context = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TestDbContext())\n        {\n            context.Database.EnsureDeleted();\n            context.Database.EnsureCreated();\n\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 处理事件</span>\n            <span style=\"background-color: rgba(255, 255, 0, 1);\">context.ChangeTracker.Tracked +=</span><span style=\"color: rgba(0, 0, 0, 1);\"><span style=\"background-color: rgba(255, 255, 0, 1);\"> OnTracked;</span>\n            <span style=\"background-color: rgba(255, 255, 0, 1);\">context.ChangeTracker.StateChanged </span></span><span style=\"background-color: rgba(255, 255, 0, 1);\">+=<span style=\"color: rgba(0, 0, 0, 1);\"> OnStateChanged;\n\n</span></span>            <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 新实体</span>\n            Pet p = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Pet { Name = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Tom</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Description = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">会游泳的鸟</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Category = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">猛禽</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\"> };\n            context.Add(p);\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保存，但状态不改变</span>\n            context.SaveChanges(<span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 因为是 Added 状态，所以还可以继续insert</span>\n            p.Name = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Simum</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            p.Description </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">三手青蛙</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            p.Category </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">两栖动物</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保存，状态改变</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            context.SaveChanges();\n        }\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 把它们查询出来看看</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">using</span>(<span style=\"color: rgba(0, 0, 255, 1);\">var</span> context2 = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TestDbContext())\n        {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 依旧要处理事件</span>\n            <span style=\"background-color: rgba(255, 255, 0, 1);\">context2.ChangeTracker.Tracked +=</span><span style=\"color: rgba(0, 0, 0, 1);\"><span style=\"background-color: rgba(255, 255, 0, 1);\"> OnTracked;</span>\n            <span style=\"background-color: rgba(255, 255, 0, 1);\">context2.ChangeTracker.StateChanged </span></span><span style=\"background-color: rgba(255, 255, 0, 1);\">+=<span style=\"color: rgba(0, 0, 0, 1);\"> OnStateChanged;\n\n</span></span>            <span style=\"color: rgba(0, 0, 255, 1);\">var</span> <span style=\"color: rgba(0, 0, 255, 1);\">set</span> = context2.Set&lt;Pet&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n            Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n数据库中的记录：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> pp <span style=\"color: rgba(0, 0, 255, 1);\">in</span> <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n            {\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{pp.Id}  {pp.Name}  {pp.Description}  {pp.Category}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            }\n        }\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 下面两个方法处理事件</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> OnTracked(<span style=\"color: rgba(0, 0, 255, 1);\">object</span>?<span style=\"color: rgba(0, 0, 0, 1);\"> _,  EntityTrackedEventArgs e)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> backupcolor =<span style=\"color: rgba(0, 0, 0, 1);\"> Console.ForegroundColor;\n        Console.ForegroundColor </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> ConsoleColor.Green;\n        Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">实体被追踪：\\n{e.Entry.DebugView.LongView}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        Console.ForegroundColor </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> backupcolor;\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> OnStateChanged(<span style=\"color: rgba(0, 0, 255, 1);\">object</span>?<span style=\"color: rgba(0, 0, 0, 1);\"> _,  EntityStateChangedEventArgs e)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> bkColor =<span style=\"color: rgba(0, 0, 0, 1);\"> Console.ForegroundColor;\n        Console.ForegroundColor </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> ConsoleColor.Blue;\n        Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">实体（ID={e.Entry.Property(nameof(Pet.Id)).CurrentValue}）状态改变：{e.OldState} --&gt; {e.NewState}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        Console.ForegroundColor </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bkColor;\n    }</span></pre>\n</div>\n<p>现在再次运行，看看结果是不是符合你当初的期望。</p>\n<p><img alt=\"image\" height=\"378\" src=\"https://img2024.cnblogs.com/blog/367389/202601/367389-20260125183707220-446191187.png\" width=\"373\" /></p>\n<p>现在的情况是：向数据库插入记录是第一个 DbContext 实例，完事后就释放了，实体追踪器自然就挂了；随后创建了第二个 DbContext 实例，这时候从数据库中查询出两条记录都是没有被追踪的，所以要启动追踪，自然就能引发两次 Tracked 事件了。</p>\n<p>好了，各位，今天咱们就粗浅地聊到这里。后面老周还会继续讨论实体追踪的话题，本文主要是让大伙伴们了解一下实体的状态变化。</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 18:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tcjiaan\">东邪独孤</a>&nbsp;\n阅读(<span id=\"post_view_count\">44</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "看一遍就懂-大模型架构及encoder-decoder详细训练和推理计算过程",
      "link": "https://www.cnblogs.com/GlenTt/p/19527689",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GlenTt/p/19527689\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 18:21\">\n    <span>看一遍就懂-大模型架构及encoder-decoder详细训练和推理计算过程</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"看一遍就懂-大模型架构及encoder-decoder详细训练和推理计算过程\">看一遍就懂-大模型架构及encoder-decoder详细训练和推理计算过程</h1>\n<p><img alt=\"image\" class=\"lazyload\" /><br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<h2 id=\"一特殊token的意思\">一、特殊Token的意思</h2>\n<h3 id=\"不同模型架构的特殊token体系\">不同模型架构的特殊token体系</h3>\n<p><strong>BERT（Encoder-only，用于理解任务）</strong>：</p>\n<pre><code>&lt;CLS&gt;：放在句首，用于分类任务，其输出向量代表整句语义\n&lt;SEP&gt;：分隔符，用于句对任务（如问答、文本蕴含）\n&lt;PAD&gt;：填充符，用于batch内长度对齐\n&lt;MASK&gt;：掩码符，用于预训练的完形填空任务\n</code></pre>\n<p><strong>GPT（Decoder-only，用于生成任务）</strong>：</p>\n<pre><code>&lt;|endoftext|&gt;：既是文档结束符，也用作句子间分隔符\n&lt;PAD&gt;：填充符（但GPT很少用，因为生成任务不需要严格对齐）\n</code></pre>\n<p><strong>T5（Encoder-Decoder，统一框架）</strong>：</p>\n<pre><code>&lt;pad&gt;：填充\n&lt;eos&gt;：句子结束符\n&lt;unk&gt;：未知词\n没有专门的&lt;bos&gt;，因为T5用任务前缀（如\"translate English to German:\"）\n</code></pre>\n<p><strong>现代Encoder-Decoder（如BART、mBART、mT5）</strong>：</p>\n<pre><code>&lt;s&gt;：句子开始符（相当于&lt;bos&gt;）\n&lt;/s&gt;：句子结束符（相当于&lt;eos&gt;）\n&lt;pad&gt;：填充符\n</code></pre>\n<h3 id=\"我们的例子将使用经典的seq2seq符号体系\">我们的例子将使用经典的Seq2Seq符号体系</h3>\n<p>为了讲解清晰，我采用最经典、最直观的设定：</p>\n<pre><code>&lt;bos&gt;：Begin of Sequence，告诉decoder\"我要开始生成了\"\n&lt;eos&gt;：End of Sequence，告诉decoder\"我生成完了，该停了\"\n&lt;pad&gt;：Padding，在batch训练中让所有序列等长\n</code></pre>\n<hr />\n<h2 id=\"二完整训练流程的剧本从数据准备到参数更新\">二、完整训练流程的剧本（从数据准备到参数更新）</h2>\n<p>让我们以\"今天天气很好\"这个训练样本为主线，完整演绎一遍训练的全过程。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"第一幕数据预处理演员准备上场\">第一幕：数据预处理（演员准备上场）</h3>\n<h4 id=\"原始训练样本\">原始训练样本</h4>\n<pre><code>源语言（中文）：今天天气很好\n目标语言（中文）：今天天气很好  # 这是个复述任务的例子\n</code></pre>\n<h4 id=\"token化切词\">Token化（切词）</h4>\n<pre><code>源序列：[今, 天, 天, 气, 很, 好]\n目标序列：[今, 天, 天, 气, 很, 好]\n</code></pre>\n<h4 id=\"添加特殊token关键步骤\">添加特殊token（关键步骤！）</h4>\n<p><strong>Encoder输入（源序列加结束符）</strong>：</p>\n<pre><code>[今, 天, 天, 气, 很, 好, &lt;eos&gt;]\n长度 = 7\n</code></pre>\n<p>为什么Encoder要加<code>&lt;eos&gt;</code>？因为这告诉模型\"源句子到此结束了，没有更多信息了\"。在翻译任务中，这个信号很重要，它让模型知道不要再期待更多源语言词汇。</p>\n<p><strong>Decoder输入（目标序列加开始符）</strong>：</p>\n<pre><code>[&lt;bos&gt;, 今, 天, 天, 气, 很, 好]\n长度 = 7\n</code></pre>\n<p>为什么Decoder输入要加<code>&lt;bos&gt;</code>？这是生成的\"起始信号\"，就像告诉一个作家\"请开始写作\"。第一个词的生成需要一个初始上下文，<code>&lt;bos&gt;</code>就扮演这个角色。</p>\n<p><strong>训练标签（目标序列加结束符）</strong>：</p>\n<pre><code>[今, 天, 天, 气, 很, 好, &lt;eos&gt;]\n长度 = 7\n</code></pre>\n<p>为什么标签要加<code>&lt;eos&gt;</code>？因为我们要训练模型学会\"什么时候停止生成\"。最后一个时间步，模型应该预测<code>&lt;eos&gt;</code>而不是继续生成新词。</p>\n<h4 id=\"转换为id查词表\">转换为ID（查词表）</h4>\n<p>假设我们的词表（10个词）是：</p>\n<pre><code>词表 = {\n    &lt;pad&gt;: 0,\n    &lt;bos&gt;: 1,\n    &lt;eos&gt;: 2,\n    今: 3,\n    天: 4,\n    气: 5,\n    很: 6,\n    好: 7,\n    的: 8,\n    是: 9\n}\n</code></pre>\n<p>转换后：</p>\n<pre><code>Encoder输入 ID: [3, 4, 4, 5, 6, 7, 2]\nDecoder输入 ID: [1, 3, 4, 4, 5, 6, 7]\n标签 ID:        [3, 4, 4, 5, 6, 7, 2]\n</code></pre>\n<p>注意Decoder输入和标签的错位关系，这就是Teacher Forcing：输入是\"已知的正确答案\"，让模型在每一步都基于正确历史来预测下一个词。</p>\n<hr />\n<h3 id=\"第二幕encoder的计算旅程理解源句子\">第二幕：Encoder的计算旅程（理解源句子）</h3>\n<h4 id=\"场景1embedding层把id变成向量\">场景1：Embedding层（把ID变成向量）</h4>\n<pre><code class=\"language-python\"># 假设embedding维度 d_model = 4\nEmbedding矩阵 W_emb ∈ ℝ^(10×4)  # 词表大小10，每个词4维向量\n\n# 查表得到向量（我简化一下数值）\n今 (ID=3) → [0.8, 0.1, 0.3, 0.2]\n天 (ID=4) → [0.2, 0.9, 0.1, 0.4]\n天 (ID=4) → [0.2, 0.9, 0.1, 0.4]  # 相同的词embedding相同\n气 (ID=5) → [0.1, 0.2, 0.9, 0.1]\n很 (ID=6) → [0.4, 0.3, 0.2, 0.8]\n好 (ID=7) → [0.5, 0.4, 0.1, 0.6]\n&lt;eos&gt;(ID=2) → [0.3, 0.5, 0.6, 0.4]\n\nEncoder输入矩阵 X_enc^(0) = [7×4]\n</code></pre>\n<p><strong>为什么要用embedding？</strong> 因为神经网络不能直接处理离散的ID数字，必须转换为连续向量才能进行微分计算。Embedding本质是一个可学习的查找表，训练过程会让语义相近的词向量也接近。</p>\n<h4 id=\"场景2位置编码加入顺序信息\">场景2：位置编码（加入顺序信息）</h4>\n<pre><code class=\"language-python\"># 位置编码告诉模型\"这是第几个词\"\nPosition Encoding PE ∈ ℝ^(7×4)\n\npos=0 → [0.00, 1.00, 0.00, 1.00]\npos=1 → [0.84, 0.54, 0.10, 0.99]\npos=2 → [0.91, -0.42, 0.20, 0.98]\npos=3 → [0.14, -0.99, 0.30, 0.95]\npos=4 → [-0.76, -0.65, 0.39, 0.92]\npos=5 → [-0.96, 0.28, 0.48, 0.88]\npos=6 → [-0.28, 0.96, 0.56, 0.83]\n\n# 叠加到embedding上\nX_enc^(0) = X_enc^(0) + PE  # 逐元素相加\n</code></pre>\n<p><strong>为什么需要位置编码？</strong> 因为Self-Attention是置换不变的，它只看\"谁和谁相关\"，不管顺序。但语言是有顺序的，\"今天很好\"和\"很好今天\"意思不同。位置编码用正弦波函数给每个位置一个独特的\"身份标签\"。</p>\n<h4 id=\"场景3self-attention-layer-1词与词互相理解\">场景3：Self-Attention Layer 1（词与词互相理解）</h4>\n<p>现在进入第一层Self-Attention，这里<strong>没有mask</strong>，因为Encoder可以看到整个句子。</p>\n<pre><code class=\"language-python\"># 投影矩阵（简化为单位阵）\nW_Q = W_K = W_V = I_4\n\n# 计算Q, K, V\nQ = X_enc^(0) × W_Q = X_enc^(0)  [7×4]\nK = X_enc^(0) × W_K = X_enc^(0)  [7×4]\nV = X_enc^(0) × W_V = X_enc^(0)  [7×4]\n\n# 计算注意力分数\nScores = Q × K^T / √4  [7×7]\n\n# 这里是关键：Encoder的attention矩阵是全连接的！\n# 每个词都能看到所有其他词（包括自己）\n\n        今    天    天    气    很    好   &lt;eos&gt;\n今    [0.82, 0.69, 0.69, 0.58, 0.61, 0.72, 0.64]\n天    [0.69, 0.91, 0.91, 0.78, 0.82, 0.79, 0.81]\n天    [0.69, 0.91, 0.91, 0.78, 0.82, 0.79, 0.81]  # 两个\"天\"完全一样\n气    [0.58, 0.78, 0.78, 0.88, 0.76, 0.71, 0.75]\n很    [0.61, 0.82, 0.82, 0.76, 0.93, 0.84, 0.79]\n好    [0.72, 0.79, 0.79, 0.71, 0.84, 0.94, 0.85]\n&lt;eos&gt; [0.64, 0.81, 0.81, 0.75, 0.79, 0.85, 0.87]\n\n# Softmax（每行归一化）\nAttention_Weights = softmax(Scores)  [7×7]\n\n# 加权求和\nOutput = Attention_Weights × V  [7×4]\n</code></pre>\n<p><strong>这一步的意义是什么？</strong> 每个词通过关注其他所有词，把句子的全局信息融合进来。比如\"天气\"这个词，会同时关注\"今天\"和\"很好\"，理解这是在描述今天的天气状况。</p>\n<h4 id=\"场景4add--norm残差连接和归一化\">场景4：Add &amp; Norm（残差连接和归一化）</h4>\n<pre><code class=\"language-python\"># 残差连接：把输入直接加到输出上\nX_residual = X_enc^(0) + Output\n\n# Layer Normalization：让每个样本的均值=0，方差=1\nX_enc^(1) = LayerNorm(X_residual)  [7×4]\n</code></pre>\n<p><strong>为什么要残差连接？</strong> 防止深层网络的梯度消失，让原始信息能够\"直通\"到后面的层。就像高速公路的快车道，保证重要信息不会在传递过程中丢失。</p>\n<h4 id=\"场景5feed-forward层独立处理每个位置\">场景5：Feed-Forward层（独立处理每个位置）</h4>\n<pre><code class=\"language-python\"># 两层全连接网络，对每个token独立处理\nFFN(x) = W2 × ReLU(W1 × x + b1) + b2\n\n假设 W1: [4×16], W2: [16×4]  # 中间扩展到16维\n\n对每个位置计算：\nOutput_FFN = FFN(X_enc^(1))  [7×4]\n\n# 再次 Add &amp; Norm\nX_enc^(2) = LayerNorm(X_enc^(1) + Output_FFN)\n</code></pre>\n<p><strong>为什么需要FFN？</strong> Self-Attention擅长建模全局依赖，但是线性的。FFN提供非线性变换能力，让模型能学习更复杂的模式。中间维度扩展（4→16→4）增加了表达能力。</p>\n<h4 id=\"场景6堆叠多层加深理解\">场景6：堆叠多层（加深理解）</h4>\n<p>实际的Transformer会堆叠多层（如6层），每层都重复\"Self-Attention + FFN\"的结构。假设我们只有2层，那么：</p>\n<pre><code class=\"language-python\"># 经过第2层后得到最终的Encoder输出\nH_enc = X_enc^(final)  [7×4]\n\n具体数值（这是最终经过所有层后的结果）：\n        dim0   dim1   dim2   dim3\n今     [0.8,  0.1,  0.3,  0.2]\n天     [0.2,  0.9,  0.1,  0.4]\n天     [0.3,  0.8,  0.2,  0.3]\n气     [0.1,  0.2,  0.9,  0.1]\n很     [0.4,  0.3,  0.2,  0.8]\n好     [0.5,  0.4,  0.1,  0.6]\n&lt;eos&gt;  [0.4,  0.5,  0.5,  0.5]\n</code></pre>\n<p><strong>Encoder的最终产出是什么？</strong> 一个7×4的矩阵，每一行是一个源句子token的\"深度语义表示\"，已经融合了全句的上下文信息。这个矩阵将作为\"知识库\"提供给Decoder。</p>\n<hr />\n<h3 id=\"第三幕decoder的生成征程基于源句子生成目标\">第三幕：Decoder的生成征程（基于源句子生成目标）</h3>\n<h4 id=\"场景1decoder的输入准备\">场景1：Decoder的输入准备</h4>\n<pre><code class=\"language-python\">Decoder输入序列 ID: [1, 3, 4, 4, 5, 6, 7]\n对应token:         [&lt;bos&gt;, 今, 天, 天, 气, 很, 好]\n\n# Embedding + 位置编码\nX_dec^(0) = Embedding(Decoder输入) + PE  [7×4]\n</code></pre>\n<h4 id=\"场景2masked-self-attention只看过去\">场景2：Masked Self-Attention（只看过去）</h4>\n<p>这是Decoder的第一个attention层，与Encoder的区别就在于加了Causal Mask。</p>\n<pre><code class=\"language-python\"># 计算Q, K, V\nQ_dec = X_dec^(0) × W_Q  [7×4]\nK_dec = X_dec^(0) × W_K  [7×4]\nV_dec = X_dec^(0) × W_V  [7×4]\n\n# 计算原始分数\nScores = Q_dec × K_dec^T / √4  [7×7]\n\n# 应用Causal Mask（设置上三角为-∞）\nMask矩阵（下三角+对角线为1，上三角为0）：\n[[1, 0, 0, 0, 0, 0, 0],\n [1, 1, 0, 0, 0, 0, 0],\n [1, 1, 1, 0, 0, 0, 0],\n [1, 1, 1, 1, 0, 0, 0],\n [1, 1, 1, 1, 1, 0, 0],\n [1, 1, 1, 1, 1, 1, 0],\n [1, 1, 1, 1, 1, 1, 1]]\n\nMasked_Scores = 把Mask为0的位置设为-∞\n\n# Softmax后，未来位置的权重自动为0\nAttention_Weights = softmax(Masked_Scores)  [7×7]\n\n示例（第2行\"今\"的权重分布）：\n[0.45, 0.55, 0.00, 0.00, 0.00, 0.00, 0.00]\n ↑     ↑     ↑后面全是0\n bos   今\n\n# 输出\nOutput_self = Attention_Weights × V_dec  [7×4]\n</code></pre>\n<p><strong>为什么Decoder要mask？</strong> 因为训练时我们是并行处理整个序列的，但预测时只能一个一个生成。Mask确保训练和推理的信息流向一致，防止\"作弊\"。</p>\n<h4 id=\"场景3cross-attention从encoder借鉴知识\">场景3：Cross-Attention（从Encoder借鉴知识）</h4>\n<p>这是Encoder-Decoder架构的核心！</p>\n<pre><code class=\"language-python\"># Query来自Decoder的当前状态\nQ_cross = Output_self × W_Q  [7×4]\n\n# Key和Value来自Encoder的输出！\nK_cross = H_enc × W_K  [7×4]  ← 这是Encoder的最终输出\nV_cross = H_enc × W_V  [7×4]\n\n# 计算注意力（这里没有mask，可以看Encoder的所有位置）\nScores_cross = Q_cross × K_cross^T / √4  [7×7]\n                ↑Decoder7个位置  ↑Encoder7个位置\n\nAttention_Weights_cross = softmax(Scores_cross)  [7×7]\n\n# 示例：Decoder位置1（预测\"天\"）对Encoder各位置的关注\n位置1的权重: [0.15, 0.25, 0.20, 0.10, 0.12, 0.10, 0.08]\n              今   天   天   气   很   好  eos\n\n# 加权求和\nOutput_cross = Attention_Weights_cross × V_cross  [7×4]\n</code></pre>\n<p><strong>Cross-Attention的本质是什么？</strong> Decoder用当前生成状态作为\"问题\"（Query），在Encoder的语义矩阵中\"检索\"相关信息（Key），提取出有用的内容（Value）。就像翻译时，生成每个目标词都会回头看源句子的不同部分。</p>\n<h4 id=\"场景4feed-forward--add--norm\">场景4：Feed-Forward + Add &amp; Norm</h4>\n<pre><code class=\"language-python\"># 和Encoder一样的结构\nOutput_FFN = FFN(Output_cross)\nX_dec^(1) = LayerNorm(Output_cross + Output_FFN)  [7×4]\n\n# 这是Decoder第一层的最终输出\n</code></pre>\n<h4 id=\"场景5堆叠多层后的最终输出\">场景5：堆叠多层后的最终输出</h4>\n<p>假设Decoder也是2层，最终得到：</p>\n<pre><code class=\"language-python\">H_dec = X_dec^(final)  [7×4]\n\n# 这个矩阵的每一行代表Decoder在该位置的\"条件生成状态\"\n</code></pre>\n<hr />\n<h3 id=\"第四幕输出层与损失计算评判对错\">第四幕：输出层与损失计算（评判对错）</h3>\n<h4 id=\"场景1投影到词表空间\">场景1：投影到词表空间</h4>\n<pre><code class=\"language-python\"># 线性变换：4维 → 10维（词表大小）\nW_vocab ∈ ℝ^(4×10)\n\nLogits = H_dec × W_vocab  [7×10]\n\n# 每一行是一个位置对10个词的原始分数\n位置0（输入&lt;bos&gt;，预测\"今\"）：\nlogits[0] = [0.21, 0.18, 0.15, 0.89, 0.54, 0.32, 0.41, 0.38, 0.25, 0.19]\n           pad  bos  eos  今↑  天   气   很   好   的   是\n</code></pre>\n<h4 id=\"场景2softmax得到概率分布\">场景2：Softmax得到概率分布</h4>\n<pre><code class=\"language-python\">Probs = softmax(Logits)  [7×10]\n\n# 位置0的概率分布\nP[0] = softmax(logits[0])\n     = [0.067, 0.065, 0.063, 0.131, 0.094, 0.076, 0.083, 0.080, 0.070, 0.065]\n        pad   bos   eos   今↑   天    气    很    好    的    是\n                           13.1%\n\n# 全部7个位置的预测\n位置0预测分布：P(今)=13.1%, P(天)=9.4%, ...\n位置1预测分布：P(今)=8.2%, P(天)=15.3%, ...  ← 应该预测\"天\"\n位置2预测分布：...\n...\n位置6预测分布：P(&lt;eos&gt;)=18.5%, ...  ← 应该预测结束符\n</code></pre>\n<h4 id=\"场景3计算交叉熵损失\">场景3：计算交叉熵损失</h4>\n<pre><code class=\"language-python\"># 标签（真实答案）\nLabels = [3, 4, 4, 5, 6, 7, 2]  # 今,天,天,气,很,好,&lt;eos&gt;\n\n# 对每个位置计算损失\nLoss_0 = -log(P[0, 3]) = -log(0.131) = 2.03\nLoss_1 = -log(P[1, 4]) = -log(0.153) = 1.88\nLoss_2 = -log(P[2, 4]) = -log(0.147) = 1.92\nLoss_3 = -log(P[3, 5]) = -log(0.162) = 1.82\nLoss_4 = -log(P[4, 6]) = -log(0.159) = 1.84\nLoss_5 = -log(P[5, 7]) = -log(0.155) = 1.86\nLoss_6 = -log(P[6, 2]) = -log(0.185) = 1.69\n\n# 平均损失\nTotal_Loss = (2.03 + 1.88 + 1.92 + 1.82 + 1.84 + 1.86 + 1.69) / 7\n           = 1.86\n</code></pre>\n<p><strong>为什么用交叉熵？</strong> 它衡量预测分布和真实分布（one-hot）的距离。预测概率越高，损失越小。模型的目标就是最小化这个损失。</p>\n<hr />\n<h3 id=\"第五幕反向传播与参数更新学习提升\">第五幕：反向传播与参数更新（学习提升）</h3>\n<h4 id=\"损失对各层参数的梯度\">损失对各层参数的梯度</h4>\n<pre><code class=\"language-python\"># 梯度从输出层反向流动\n∂Loss/∂W_vocab → 更新词表投影矩阵\n  ↓\n∂Loss/∂H_dec → 流向Decoder最后一层\n  ↓\n∂Loss/∂(Decoder FFN参数) → 更新FFN\n  ↓\n∂Loss/∂(Cross-Attention参数) → 更新W_Q, W_K, W_V\n  ↓  ↓\n  ↓  ↓→ ∂Loss/∂H_enc → 流向Encoder！\n  ↓\n∂Loss/∂(Masked Self-Attention参数)\n  ↓\n∂Loss/∂X_dec^(0) → 流向Decoder embedding\n</code></pre>\n<p><strong>关键洞察：Encoder会被Decoder的损失训练！</strong> 虽然Encoder没有直接的监督信号，但Cross-Attention建立了桥梁，让生成任务的损失能反向传播到Encoder，督促它学习\"对生成有用\"的表示。</p>\n<h4 id=\"参数更新随机梯度下降\">参数更新（随机梯度下降）</h4>\n<pre><code class=\"language-python\">学习率 η = 0.001\n\nW_vocab^(new) = W_vocab^(old) - η × ∂Loss/∂W_vocab\nEncoder参数^(new) = Encoder参数^(old) - η × ∂Loss/∂Encoder参数\nDecoder参数^(new) = Decoder参数^(old) - η × ∂Loss/∂Decoder参数\n</code></pre>\n<p>一次训练步骤完成！模型会对成千上万个这样的样本重复这个过程，逐渐学会翻译、摘要、对话等任务。</p>\n<hr />\n<h2 id=\"三特殊token的深层作用机制\">三、特殊Token的深层作用机制</h2>\n<p>现在你已经看完了完整流程，让我深入解释特殊token为什么必不可少。</p>\n<h3 id=\"bos的三重作用\"><code>&lt;bos&gt;</code>的三重作用</h3>\n<p><strong>第一重：作为生成的起点</strong>。Decoder的第一个位置必须有一个输入，<code>&lt;bos&gt;</code>提供了一个\"中性的起始上下文\"。就像赛跑的发令枪，它本身没有语义，但给出了\"开始\"的信号。</p>\n<p><strong>第二重：在Self-Attention中充当锚点</strong>。第一个词（如\"今\"）的Query会同时关注<code>&lt;bos&gt;</code>和自己，<code>&lt;bos&gt;</code>的embedding会影响第一个词的生成倾向。比如在对话任务中，不同的对话类型可能训练出不同的<code>&lt;bos&gt;</code>表示。</p>\n<p><strong>第三重：在Cross-Attention中引导初始检索</strong>。<code>&lt;bos&gt;</code>位置的Query会去Encoder中检索信息，决定\"从哪里开始翻译/生成\"。在翻译任务中，模型可能学会让<code>&lt;bos&gt;</code>关注源句子的开头。</p>\n<h3 id=\"eos的三重作用\"><code>&lt;eos&gt;</code>的三重作用</h3>\n<p><strong>第一重（Encoder侧）：标记源句子边界</strong>。告诉Encoder\"句子结束了\"，在Self-Attention中，<code>&lt;eos&gt;</code>能汇聚全句信息，成为\"句子级表示\"。很多摘要任务会专门提取Encoder的<code>&lt;eos&gt;</code>向量作为句子摘要。</p>\n<p><strong>第二重（Decoder侧）：学习何时停止</strong>。训练时最后一个位置必须预测<code>&lt;eos&gt;</code>，这教会模型\"生成到合适长度就该停了\"。没有这个训练，模型可能永远不停地生成。</p>\n<p><strong>第三重（推理时）：实际停止信号</strong>。测试时，当模型输出<code>&lt;eos&gt;</code>，解码循环就终止。这是唯一能让模型自主决定生成长度的机制。</p>\n<h3 id=\"pad的作用batch训练专用\"><code>&lt;pad&gt;</code>的作用（Batch训练专用）</h3>\n<p>假设batch中有两个样本：</p>\n<pre><code>样本1: [今, 天, 很, 好, &lt;eos&gt;]          长度=5\n样本2: [明, 天, 会, 下, 雨, 吧, &lt;eos&gt;]  长度=7\n</code></pre>\n<p>为了并行处理，必须对齐到相同长度：</p>\n<pre><code>样本1: [今, 天, 很, 好, &lt;eos&gt;, &lt;pad&gt;, &lt;pad&gt;]  长度=7\n样本2: [明, 天, 会, 下, 雨, 吧, &lt;eos&gt;]        长度=7\n</code></pre>\n<p>在Attention计算时，<code>&lt;pad&gt;</code>位置会被mask掉（设为-∞），确保它们不参与实际计算，只是占位符。在损失计算时，<code>&lt;pad&gt;</code>位置也不计入损失。</p>\n<hr />\n<h2 id=\"四完整流程的理论意义总结\">四、完整流程的理论意义总结</h2>\n<h3 id=\"encoder-decoder为什么如此强大\">Encoder-Decoder为什么如此强大？</h3>\n<p><strong>信息的双向流动</strong>：Encoder通过双向Attention理解源句子，Decoder通过Causal Attention保证生成的自回归性，Cross-Attention则让两者协同工作。</p>\n<p><strong>端到端可微</strong>：从输入token到输出概率的整个链条都是可微的，可以用一个统一的损失函数端到端训练，不需要分模块训练。</p>\n<p><strong>Teacher Forcing的妙处</strong>：训练时给Decoder\"正确答案\"作为输入，让它学习\"基于正确历史的预测\"，避免了错误累积，大幅加速收敛。但推理时用自己的输出作为下一步输入（Autoregressive），这种训练-推理的不一致被称为Exposure Bias，是当前研究的热点。</p>\n<h3 id=\"与decoder-onlygpt的本质区别\">与Decoder-only（GPT）的本质区别</h3>\n<p>GPT没有Cross-Attention，只有Masked Self-Attention。它把输入和输出拼接成一个序列：</p>\n<pre><code>[源句子, &lt;sep&gt;, 目标句子]\n</code></pre>\n<p>全部用Causal Mask处理。这更简单，但无法像Encoder-Decoder那样\"先全面理解再生成\"，而是\"边看边生成\"。对于需要深度理解源文本的任务（如摘要、翻译），Encoder-Decoder理论上更有优势。</p>\n<hr />\n<h2 id=\"五用一个完整的比喻收尾\">五、用一个完整的比喻收尾</h2>\n<p>想象你在参加一场即兴翻译大赛：</p>\n<p><strong>Encoder（理解阶段）</strong>：你拿到一篇中文文章，仔细阅读每个句子，在纸上做标注，理解上下文，把关键信息提取成笔记。这个笔记就是<code>H_enc</code>。</p>\n<p><strong><code>&lt;bos&gt;</code>（开始翻译）</strong>：主持人说\"开始\"，你深吸一口气，准备说出第一个英文单词。</p>\n<p><strong>Decoder（生成阶段）</strong>：你一边回看笔记（Cross-Attention），一边注意自己已经说出的英文（Masked Self-Attention），然后说出下一个单词。每个单词都基于\"源文本理解+已生成历史\"做决策。</p>\n<p><strong><code>&lt;eos&gt;</code>（结束）</strong>：你翻译完最后一个词，说\"完毕\"，告诉评委你结束了。</p>\n<p><strong>损失函数（评分）</strong>：评委对照标准答案，给你的每个词打分，算出总分。</p>\n<p><strong>反向传播（复盘）</strong>：你根据评委反馈，调整自己的理解方式（Encoder）和表达策略（Decoder），下次做得更好。</p>\n<h1 id=\"encoder-decoder推理过程\">Encoder-Decoder推理过程</h1>\n<h2 id=\"开篇训练与推理的本质差异\">开篇：训练与推理的本质差异</h2>\n<p>当你完全理解了Encoder-Decoder的训练过程后，可能会产生一个错觉，认为推理只是把训练过程重新跑一遍，喂入新数据就能得到结果。但实际上，推理过程和训练过程有着本质的不同，这种差异如此重要，以至于理解它是掌握序列生成模型的关键一跃。</p>\n<p>在训练阶段，我们拥有\"上帝视角\"。我们已经知道正确答案是什么，所以可以把整个目标序列一次性喂给Decoder，让它在每个位置上并行地学习预测下一个词。这种并行化训练被称为Teacher Forcing，它就像一个严格的导师站在学生旁边，每走一步都告诉学生\"正确答案应该是这个\"，让学生基于正确的历史去学习下一步。这种方式高效、稳定，能让GPU的并行计算能力得到充分利用。</p>\n<p>但推理阶段是截然不同的故事。现在我们不知道答案，Decoder必须真正地一个词一个词地生成，每生成一个词都要立即把它作为下一步的输入，形成一个自回归的循环。这就像蒙着眼睛走钢丝，每一步都基于之前的步伐，一旦走错一步，后续的所有步骤都可能受到影响。这个过程是串行的、渐进的、不可回退的，完全依赖模型自己的判断。</p>\n<p>让我用一个生动的比喻来说明这个差异。训练就像在驾校练车，教练坐在副驾驶上，握着一个备用方向盘。每当你要转向时，教练会告诉你\"现在应该向左打30度\"，你只需要学习在看到路况时做出正确的判断。而推理则是你独自开车上路，没有教练，没有提示，你必须自己观察路况、做出决策、执行操作，而且每个决策都会影响接下来的路况。</p>\n<p>现在让我们深入到推理的每一个步骤，看看这个\"独自驾驶\"的过程到底是如何展开的。</p>\n<h2 id=\"推理的起点准备输入和初始化\">推理的起点：准备输入和初始化</h2>\n<p>假设我们已经训练好了一个中英翻译模型，现在要把中文句子\"今天天气很好\"翻译成英文。这是一个经典的Encoder-Decoder任务，让我们从头开始看这个推理过程。</p>\n<p>首先，我们需要准备Encoder的输入。和训练时一样，我们把源句子进行分词，添加结束符，然后转换为ID序列。这个过程完全一致，因为Encoder的工作方式在训练和推理时没有任何区别。具体来说，我们得到的序列是\"今、天、天、气、很、好、<code>&lt;eos&gt;</code>\"，转换为ID后是\"3, 4, 4, 5, 6, 7, 2\"，假设我们的词表中这些词对应的ID就是这样。</p>\n<p>接下来，Encoder开始工作。它把这个ID序列转换为embedding向量，每个词变成一个四维的向量。然后加上位置编码，让模型知道每个词在句子中的位置。这个加了位置编码的向量矩阵，形状是七行四列，送入Encoder的第一层。</p>\n<p>Encoder的每一层都执行相同的操作：首先是Self-Attention，让每个词都能看到整个句子的所有其他词，互相理解彼此的语义和关系。比如第一个\"天\"会注意到它前面的\"今\"，理解这是在说\"今天\"而不是\"天空\"。然后是Feed-Forward网络，对每个位置独立地进行非线性变换，提取更复杂的特征。经过残差连接和Layer Normalization后，输出被送入下一层。</p>\n<p>假设我们的模型有六层Encoder，那么这个七行四列的矩阵会经过六次这样的处理。每经过一层，向量中蕴含的语义就更加丰富和抽象。到最后一层输出时，我们得到的矩阵我们称之为H_enc，它的每一行都是一个源语言词的深度语义表示，已经融合了整个句子的上下文信息。这个矩阵将作为\"知识库\"，在整个生成过程中被Decoder反复查询。</p>\n<p>这里有一个关键的认知：Encoder的计算在推理时只需要执行一次。无论Decoder后面要生成多少个词，Encoder都不需要重新计算。这个H_enc矩阵会被保存在内存中，供后续所有时间步使用。这是一个重要的优化点，因为Encoder的计算量可能相当大，如果每生成一个词都重算一次就太浪费了。</p>\n<p>现在Encoder已经完成了它的使命，把源句子\"理解透彻\"了。接下来的重点转向Decoder，这才是推理阶段真正惊心动魄的部分。</p>\n<h2 id=\"第一步生成从bos到第一个单词\">第一步生成：从<code>&lt;bos&gt;</code>到第一个单词</h2>\n<p>Decoder的推理过程从一个特殊token开始，这就是<code>&lt;bos&gt;</code>，它代表\"Begin of Sequence\"，是生成的起点。在训练时，我们可以一次性把整个目标序列喂给Decoder，但现在我们什么都没有，只有这个起始符号。这就像作家面对空白稿纸时的第一个字，充满了不确定性。</p>\n<p>我们把<code>&lt;bos&gt;</code>（假设它的ID是1）转换为embedding向量，加上位置编码。这时位置索引是0，因为它是第一个位置。得到的向量是一个一行四列的矩阵，记为X_dec。这个向量送入Decoder的第一层。</p>\n<p>Decoder的第一个子层是Masked Self-Attention。你可能会问，现在只有一个token，还需要attention吗？答案是需要的，虽然这一步的attention计算会很简单。具体来说，这个<code>&lt;bos&gt;</code>向量会和它自己计算attention，Query是它自己，Key也是它自己，Value还是它自己。计算出的attention score就是一个标量，做softmax后权重是1.0，加权求和的结果还是它自己。这看起来像是一个恒等变换，但保持这个流程的一致性很重要，因为后续步骤会变得复杂。</p>\n<p>通过Self-Attention后，我们得到一个向量，它经过Add &amp; Norm后送入第二个子层，这就是Cross-Attention。这是Decoder真正开始\"查询\"Encoder知识库的地方。当前的向量作为Query，被投影成一个查询向量。而Encoder的输出H_enc，那个七行四列的矩阵，被投影成Keys和Values。</p>\n<p>现在进行的计算是：这个Query向量（一行四列）乘以Keys矩阵的转置（四行七列），得到一个一行七列的attention score向量。这个向量的每个元素代表Decoder当前状态对Encoder各个位置的关注程度。比如第一个元素表示对源句子第一个词\"今\"的关注度，第二个元素表示对第二个词\"天\"的关注度，以此类推。</p>\n<p>这些分数经过缩放（除以维度的平方根）然后做softmax，变成一个概率分布。假设计算出来的权重分布是\"0.12, 0.18, 0.15, 0.10, 0.13, 0.20, 0.12\"，这意味着在生成第一个英文单词时，模型最关注源句子中的\"好\"（权重0.20）和\"天\"（权重0.18）。这是有道理的，因为翻译\"今天天气很好\"时，英文很可能以\"Today\"或\"The weather\"开头，而这些都和源句子的这些词相关。</p>\n<p>这个attention权重向量（一行七列）乘以Values矩阵（七行四列），得到一个context向量（一行四列）。这个向量是Encoder所有位置信息的加权混合，代表了\"为了生成当前位置的词，从源句子中提取出的最相关信息\"。</p>\n<p>Context向量经过Add &amp; Norm后送入Feed-Forward网络，再经过一次Add &amp; Norm，完成Decoder第一层的计算。如果模型有六层Decoder，那么这个向量会经过六次\"Masked Self-Attention → Cross-Attention → FFN\"的循环，每一层都进一步精炼这个向量的语义。</p>\n<p>最终，我们得到Decoder最后一层的输出，一个一行四列的向量，记为h_dec。这个向量包含了\"基于源句子理解，应该生成什么样的第一个词\"的所有信息。但它还不是一个词，而是一个高维语义向量。</p>\n<p>现在到了关键的一步：把这个四维向量投影到词表空间。我们有一个输出投影矩阵W_vocab，形状是四行乘以词表大小（假设英文词表有10000个词）。向量h_dec（一行四列）乘以这个矩阵，得到一个一行10000列的logits向量。这个向量的每个元素对应一个英文单词的原始分数。</p>\n<p>对这个logits向量做softmax，我们得到一个概率分布。假设最高的几个概率是：\"Today\"对应0.35，\"The\"对应0.28，\"Weather\"对应0.12，\"It\"对应0.08，其他词的概率都很低。这个分布告诉我们，模型认为最可能的第一个词是\"Today\"，概率达到35%。</p>\n<p>在最简单的推理策略中，我们选择概率最高的词作为输出，这叫做贪心解码（Greedy Decoding）。所以我们选择\"Today\"作为第一个生成的词。这个词的ID（假设是8888）会被记录下来，因为它马上要作为下一步的输入。</p>\n<p>第一步生成完成了！我们用了一个<code>&lt;bos&gt;</code>符号，通过整个Decoder网络的计算，从10000个可能的英文单词中选出了\"Today\"。这个过程虽然复杂，但逻辑是清晰的：用起始信号触发生成，通过Cross-Attention查询源句子，通过Self-Attention整合已有信息（虽然现在只有一个token），最后输出一个词表概率分布并选择最优的词。</p>\n<h2 id=\"第二步生成自回归的开始\">第二步生成：自回归的开始</h2>\n<p>现在进入推理的核心机制：自回归循环。我们已经生成了第一个词\"Today\"，它不仅是输出的一部分，更重要的是，它要立即成为Decoder下一步的输入。这就是\"自回归\"的含义，每一步的输出都被回馈到输入中，形成一个闭环。</p>\n<p>具体来说，我们现在的Decoder输入序列是\"<code>&lt;bos&gt;</code>, Today\"，长度变成了2。我们把这两个词都转换为embedding，加上位置编码（<code>&lt;bos&gt;</code>的位置是0，\"Today\"的位置是1），得到一个二行四列的矩阵。这个矩阵送入Decoder的第一层。</p>\n<p>在Masked Self-Attention阶段，计算方式和训练时完全一样。我们计算Query、Key、Value矩阵（现在都是二行四列），然后计算Q乘以K的转置，得到一个二行二列的attention score矩阵。这个矩阵的四个元素分别代表：位置0对位置0的关注、位置0对位置1的关注、位置1对位置0的关注、位置1对位置1的关注。</p>\n<p>关键的Causal Mask在这里起作用。虽然我们现在只有两个词，但mask的逻辑依然适用：每个位置只能看到它自己和它之前的位置。所以attention矩阵的模式是：</p>\n<pre><code>      bos  Today\nbos   [1.0, 0.0 ]\nToday [0.4, 0.6 ]\n</code></pre>\n<p>位置0（<code>&lt;bos&gt;</code>）只能100%关注自己，而位置1（\"Today\"）可以同时关注<code>&lt;bos&gt;</code>（比如40%）和自己（60%）。这个mask确保了信息的单向流动，防止\"看到未来\"。</p>\n<p>Softmax后的attention权重乘以Value矩阵，得到输出向量。对于位置1（\"Today\"），这个输出向量融合了<code>&lt;bos&gt;</code>和\"Today\"两个embedding的信息，是一个\"条件化的语义表示\"。</p>\n<p>然后进入Cross-Attention。这里有一个非常重要的细节：虽然Decoder现在有两个位置，但Encoder的输出H_enc还是那个七行四列的矩阵，没有任何变化。每个Decoder位置都会独立地和整个Encoder做attention。</p>\n<p>具体来说，位置1（\"Today\"）的Query向量会和Encoder的七个Key向量计算相似度，得到七个attention score。假设这次的权重分布是\"0.08, 0.10, 0.12, 0.15, 0.25, 0.18, 0.12\"，你会发现模型现在更关注源句子中的\"很\"（0.25）和\"好\"（0.18）。这很合理，因为已经生成了\"Today\"，接下来可能要描述天气状况，所以关注\"很好\"这部分信息。</p>\n<p>Cross-Attention的输出（一个四维向量）经过FFN和多层堆叠，最终得到位置1的最终表示h_dec。注意，我们只需要这个位置1的向量，因为我们要预测的是第二个词。位置0的输出我们不关心，因为那对应的是已经生成过的<code>&lt;bos&gt;</code>的后续词，已经是历史了。</p>\n<p>这个h_dec向量再次通过W_vocab投影到词表，做softmax得到概率分布。假设这次的最高概率是：\"is\"对应0.42，\"the\"对应0.25，\"was\"对应0.18。模型认为第二个词最可能是\"is\"，所以我们选择它。</p>\n<p>现在我们的生成序列变成了\"Today is\"，这是一个合理的英文开头。但我们还没有结束，因为模型没有输出<code>&lt;eos&gt;</code>结束符。所以循环继续。</p>\n<h2 id=\"自回归循环的完整展开从is到eos\">自回归循环的完整展开：从\"is\"到\"<code>&lt;eos&gt;</code>\"</h2>\n<p>理解了第二步，你就理解了推理的全部核心。后续的每一步都是完全相同的模式：把当前已生成的序列作为Decoder输入，通过整个网络计算，输出下一个词的概率分布，选择最优词，添加到序列末尾，再次循环。</p>\n<p>让我详细展开第三步，帮你巩固这个理解。现在Decoder的输入是\"<code>&lt;bos&gt;</code>, Today, is\"，三个词，转换为三行四列的embedding矩阵。在Masked Self-Attention中，每个位置的attention权重分布遵循causal pattern：</p>\n<pre><code>          bos   Today  is\nbos      [1.0,  0.0,  0.0]\nToday    [0.3,  0.7,  0.0]\nis       [0.2,  0.4,  0.4]\n</code></pre>\n<p>位置2（\"is\"）能看到所有之前的信息，它的Query会同时关注<code>&lt;bos&gt;</code>（20%）、\"Today\"（40%）和自己（40%）。这让\"is\"的表示融合了整个已生成序列的信息。</p>\n<p>在Cross-Attention中，位置2的Query和Encoder的七个Key计算attention。假设这次的权重分布聚焦在源句子的\"天气\"（0.35）和\"很好\"（0.40）。模型已经生成了\"Today is\"，现在要描述具体内容，所以关注点自然转向了\"天气很好\"这个核心语义。</p>\n<p>经过所有层的计算后，位置2的输出向量投影到词表，假设概率分布显示\"nice\"是0.38，\"good\"是0.25，\"sunny\"是0.20。我们选择\"nice\"，序列变成\"Today is nice\"。</p>\n<p>第四步，输入变成四个词，Masked Self-Attention的矩阵变成四行四列，下三角都有值，上三角都是零。Cross-Attention中，新位置的Query可能开始关注源句子的\"天\"（天气）或\"今\"（今天），因为句子结构已经建立，现在可能需要补充细节。假设生成的词是\"weather\"，虽然这让句子语法不完美（应该是\"The weather is nice\"），但这正是自回归的风险：一旦前面的词选择不完美，后续就可能需要调整来适应。</p>\n<p>第五步可能生成\"today\"，序列变成\"Today is nice weather today\"。你可能注意到\"today\"出现了两次，这在人类看来有些冗余，但模型在每一步都是基于概率做贪心选择，无法\"回头修改\"。</p>\n<p>第六步，模型终于输出了<code>&lt;eos&gt;</code>，概率达到0.55，超过了所有其他词。这个特殊符号告诉我们：生成结束了。最终的翻译结果是\"Today is nice weather today\"，虽然不完美，但表达了源句子的核心意思。</p>\n<p>整个过程可以总结为一个while循环的伪代码：</p>\n<pre><code>generated_sequence = [&lt;bos&gt;]\nwhile True:\n    decoder_input = generated_sequence\n    encoder_output = H_enc (保持不变)\n    \n    decoder_hidden = Decoder(decoder_input, encoder_output)\n    last_position_hidden = decoder_hidden[-1]  # 只取最后一个位置\n    \n    logits = last_position_hidden @ W_vocab\n    probs = softmax(logits)\n    next_token = argmax(probs)  # 贪心选择\n    \n    generated_sequence.append(next_token)\n    \n    if next_token == &lt;eos&gt; or len(generated_sequence) &gt;= max_length:\n        break\n\nreturn generated_sequence[1:]  # 去掉&lt;bos&gt;返回\n</code></pre>\n<p>这个循环的每一次迭代都会让输入序列增长一个词，Decoder的计算量也会随之增加。如果最终生成了十个词，那么第十步的Masked Self-Attention就要处理一个十行十列的矩阵。这就是为什么推理速度会随着生成长度增加而变慢，因为每一步都比上一步多一点计算。</p>\n<h2 id=\"推理与训练的深层对比\">推理与训练的深层对比</h2>\n<p>现在你已经看完了完整的推理流程，让我们回过头来系统对比推理和训练的差异，这些差异不仅仅是技术细节，它们反映了序列生成任务的深层挑战。</p>\n<p>第一个差异是并行性。训练时，我们可以把整个目标序列一次性喂给Decoder，利用Causal Mask确保信息流向的正确性，让GPU的数千个核心并行计算。假设目标序列长度是十，那么十个位置的loss可以同时计算，梯度可以同时反向传播。但推理时，我们必须一个词一个词地串行生成，第二个词依赖第一个词的输出，第三个词依赖前两个词，无法并行。这导致推理速度远慢于训练，尤其是生成长文本时，可能需要几秒甚至几分钟。</p>\n<p>第二个差异是输入的来源。训练时，Decoder的每一步输入都是ground truth，即人工标注的正确答案。即使模型在某一步预测错了，下一步依然会用正确答案作为输入，这让模型能够\"重置错误\"，专注于学习每个独立位置的正确预测。但推理时，每一步的输入都是模型自己上一步的输出。如果第三步生成了一个不太合适的词，第四步就必须基于这个不完美的历史继续生成，错误可能累积和放大。这种训练-推理的不一致性被称为Exposure Bias，是当前研究的热点问题。</p>\n<p>第三个差异是确定性。训练时，损失函数是确定的，给定相同的输入和参数，计算出的梯度完全相同。但推理时，我们通常有多种解码策略可选。最简单的是贪心解码，每步选概率最高的词，这是确定性的。但还有随机采样，按照概率分布随机选词，每次运行可能得到不同结果。还有Beam Search，同时保留多个候选序列，选择全局概率最高的路径，这需要更多计算但通常质量更好。不同的解码策略会导致完全不同的输出，而在训练时没有这种选择的自由度。</p>\n<p>第四个差异是停止条件。训练时，序列长度是已知的，我们有明确的标签告诉模型\"这里应该结束\"。但推理时，模型必须自己决定什么时候停下来。它通过预测<code>&lt;eos&gt;</code>符号来表达\"我认为已经生成完整了\"。如果模型训练不够好，可能永远不输出<code>&lt;eos&gt;</code>，导致无限循环。所以实际系统中通常会设置一个最大长度限制作为保险，比如\"不管怎样，生成100个词后必须停止\"。</p>\n<p>第五个差异是计算图的动态性。训练时，整个计算图的形状是固定的，比如Decoder输入是十行四列，输出也是十行一万列（词表大小），整个前向传播和反向传播的张量形状都是静态的，可以高度优化。但推理时，每一步的输入长度都不同，第一步是一行四列，第二步是两行四列，第十步是十行四列。这种动态性让优化变得困难，也是为什么现代推理引擎（如vLLM、TensorRT-LLM）花了大量精力优化KV Cache等技术，来减少重复计算。</p>\n<h2 id=\"kv-cache推理优化的关键技术\">KV Cache：推理优化的关键技术</h2>\n<p>当你理解了推理的逐步生成过程后，你可能会发现一个巨大的浪费：每一步我们都要重新计算之前所有位置的Key和Value。</p>\n<p>具体来说，在第三步时，我们有三个输入token（<code>&lt;bos&gt;</code>, Today, is），Decoder会计算三个Query、三个Key、三个Value。但其实<code>&lt;bos&gt;</code>和\"Today\"的Key和Value在第二步时已经算过了！它们的值不会改变，因为它们只依赖于自己的位置和内容，不依赖未来的token。</p>\n<p>KV Cache的思想就是：把已经计算过的Key和Value存起来，后续步骤直接复用。具体来说，第一步我们计算并缓存一个Key和一个Value（都是四维向量），第二步计算新的一个Key和一个Value，拼接到缓存上，变成两个。第三步再计算一个，拼接上去，变成三个。这样每一步只需要计算新增位置的KV，而不需要重算整个历史。</p>\n<p>这个优化在Cross-Attention中更加显著。Encoder的Key和Value矩阵在整个生成过程中完全不变，我们可以在第一步就计算好并缓存，后续所有步骤直接使用，完全不需要重算。这大幅减少了计算量。</p>\n<p>在Self-Attention中，KV Cache的使用稍微复杂一些。新的Query需要和所有历史的Key计算attention，所以第十步的Query要和十个Key做点积。但由于我们缓存了之前九个Key，只需要计算新的第十个Key，然后把它和缓存拼接起来。这比重新计算十个Key要快得多。</p>\n<p>KV Cache带来的加速是巨大的，尤其是对于长序列生成任务。但它也有代价：内存占用。假设模型有六层Decoder，每层都要缓存KV，序列长度是100，那么我们需要存储六层乘以100个位置乘以两个矩阵（K和V）乘以四维，总共4800个浮点数。对于大模型（如GPT-3的12288维），这个内存开销可能达到几个GB。这就是为什么大模型推理需要大显存，很大一部分都被KV Cache占用了。<br />\n后续提出的MQA,GQA,MLA都是为了缓解KV cache。<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n大家有兴趣可以看这位博主讲的：<a href=\"https://www.bilibili.com/video/BV1BYXRYWEMj/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=fc3f7e0bcc8a0bca7d86fc8c60c5db3c\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV1BYXRYWEMj/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=fc3f7e0bcc8a0bca7d86fc8c60c5db3c</a></p>\n<h2 id=\"beam-search超越贪心的搜索策略\">Beam Search：超越贪心的搜索策略</h2>\n<p>贪心解码虽然简单快速，但它有一个明显的缺陷：它只看一步，不考虑长远影响。假设第一步选\"Today\"概率是0.35，选\"The\"是0.28，贪心会选\"Today\"。但可能\"The weather is nice today\"这个完整句子的联合概率，比\"Today is nice weather\"更高。贪心因为只看局部最优，错过了全局最优。</p>\n<p>Beam Search是一种折中方案，它不是只保留一个候选序列，而是同时保留多个（比如五个），这个数量叫做beam size。具体流程是：</p>\n<p>第一步，从词表中选出概率最高的五个词，比如\"Today\"（0.35）、\"The\"（0.28）、\"It\"（0.15）、\"Weather\"（0.12）、\"Good\"（0.10）。这五个词各自开启一条生成路径。</p>\n<p>第二步，对每条路径分别往后生成一个词。\"Today\"路径可能扩展出\"Today is\"、\"Today the\"、\"Today was\"等，\"The\"路径可能扩展出\"The weather\"、\"The sky\"等。现在我们有五条路径各自扩展出若干候选，总共可能有几十个。我们计算每个候选的累积概率（通常是对数概率的和），然后只保留全局最高的五个。</p>\n<p>比如经过第二步后，保留的五个可能是：\"The weather\"（-0.5）、\"Today is\"（-0.6）、\"The sky\"（-0.7）、\"It is\"（-0.8）、\"Today the\"（-0.9）。注意\"Today\"路径的其他扩展可能被淘汰了，因为全局得分不够高。</p>\n<p>这个过程持续进行，每一步都保留全局最优的五条路径，直到所有路径都输出了<code>&lt;eos&gt;</code>或达到最大长度。最后，我们选择累积概率最高的那条路径作为最终输出。</p>\n<p>Beam Search的优势是它能够\"回头\"。如果第一步选了\"Today\"但后续发展不好，它可以在后续步骤中逐渐被\"The\"路径赶超并淘汰。这让最终结果更可能是全局较优的。但代价是计算量增加了beam_size倍，因为每一步都要并行处理多条路径。</p>\n<p>在实践中，beam size通常取3到10之间。太小则效果接近贪心，太大则计算成本过高且容易陷入重复模式（模型可能会生成\"very very very good\"这样的重复序列，因为每个\"very\"都让概率稍微提高一点）。</p>\n<h2 id=\"推理中的其他挑战与技巧\">推理中的其他挑战与技巧</h2>\n<p>除了上面讨论的核心机制，推理还有很多细节和技巧值得了解。</p>\n<p>温度（Temperature）采样是控制生成多样性的常用手段。在做softmax之前，我们可以把logits除以一个温度参数T。当T接近0时，概率分布变得非常尖锐，几乎所有概率都集中在最高分词上，生成变得确定性和保守。当T大于1时，概率分布变得平缓，低概率词也有机会被选中，生成变得更随机和创造性。在创意写作任务中，高温度可以产生意想不到的表达，而在翻译等需要精确性的任务中，低温度更合适。</p>\n<p>Top-k采样是另一种常用技巧。它在采样时只考虑概率最高的k个词，把其他词的概率置零后重新归一化。这避免了极低概率的\"异常词\"被偶然选中，同时保持一定的随机性。Top-p（nucleus）采样则更加动态，它选择累积概率达到p（如0.9）的最小词集进行采样，词集大小会根据概率分布的形状自适应调整。</p>\n<p>重复惩罚是对抗生成重复的技术。如果某个词已经在生成序列中出现过，我们可以在下一步预测时降低它的logit分数，让模型倾向于选择新的词。这在对话和故事生成中很有用，可以避免模型陷入\"I think I think I think\"这样的循环。</p>\n<p>长度归一化在Beam Search中很重要。因为我们用对数概率的和作为得分，长序列的得分会自然地比短序列低（因为每一步都乘以一个小于1的概率）。为了公平比较不同长度的序列，我们通常会用总对数概率除以长度，或者用一个更复杂的长度惩罚公式。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-01-25 18:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GlenTt\">GlenTt</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "从0构建 3D GIF动画，看清计算机运行机制",
      "link": "https://www.cnblogs.com/reasa/p/19529889",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/reasa/p/19529889\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 15:39\">\n    <span>从0构建 3D GIF动画，看清计算机运行机制</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"从0构建-3d-gif动画看清计算机运行机制\">从0构建 3D GIF动画，看清计算机运行机制</h1>\n<p>在<a href=\"https://www.cnblogs.com/reasa/p/19521361\" target=\"_blank\">《从 0 构建 WAV 文件》</a>中，我们通过了解wav文件的结构与格式，学会了如何用朴素的方式构建声音文件；在<a href=\"https://www.cnblogs.com/reasa/p/19525923\" target=\"_blank\">《从 2D 转 3D 的本质》</a>中，我们领悟了游戏中所谓三维世界，不过是简单的投影。</p>\n<p>今天我们将了解一个更加复杂但有趣的文件格式-GIF，在了解其本质的同时，我们将不依赖任何庞大的图形库（如 OpenGL、DirectX）或图像库（如 OpenCV、ImageMagick），仅凭 <strong>C++ 标准库</strong>，完成上一篇文章用python实现的旋转立方体并以GIF文件的方式呈现出来。</p>\n<p>我们将进一步加深对计算机本质的理解：<strong>一切复杂的表象，归根结底都是“数学计算”与“数据存储”的结合。</strong></p>\n<h2 id=\"1-gif文件结构\">1. GIF文件结构</h2>\n<p>相比于 WAV 文件的简单粗暴，GIF 的结构要精密得多，因为它天生是为了网络传输而设计的（包含了压缩机制）。</p>\n<p>当我们用二进制视角观察 GIF 时，它是由一个个 <strong>数据块（Block）</strong> 组成的：</p>\n<p><img alt=\"\" src=\"https://www.techug.com/wordpress/wp-content/uploads/2017/06/680728-641be6583b65382d.png\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">数据块 (Block Name)</th>\n<th style=\"text-align: left;\">中文名称</th>\n<th style=\"text-align: left;\">字节数 (Bytes)</th>\n<th style=\"text-align: left;\">作用与核心逻辑</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>Header</strong></td>\n<td style=\"text-align: left;\">头标识</td>\n<td style=\"text-align: left;\">6</td>\n<td style=\"text-align: left;\">一般为 <code>GIF89a</code>，当然也有<code>GIF87a</code>,用于声明这是一个GIF文件，采用xx标准。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Logical Screen Descriptor</strong></td>\n<td style=\"text-align: left;\">逻辑屏幕描述符</td>\n<td style=\"text-align: left;\">7</td>\n<td style=\"text-align: left;\"><strong>画布设定</strong>：定义图像总宽高、背景色索引及是否使用全局调色板。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Global Color Table</strong></td>\n<td style=\"text-align: left;\">全局颜色表</td>\n<td style=\"text-align: left;\">3 × N</td>\n<td style=\"text-align: left;\"><strong>颜料盘</strong>：存储 RGB 颜色（如 <code>00 FF 00</code>），N 为颜色数（最大256）。 默认使用RGB颜色时，每个颜色均采用3个字节存储</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Application Extension</strong></td>\n<td style=\"text-align: left;\">应用程序扩展</td>\n<td style=\"text-align: left;\">19 (通常)</td>\n<td style=\"text-align: left;\">最常用的是 Netscape 扩展，用于“循环播放次数”。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Graphic Control Extension</strong></td>\n<td style=\"text-align: left;\">图形控制扩展</td>\n<td style=\"text-align: left;\">8</td>\n<td style=\"text-align: left;\"><strong>播放控制</strong>：定义每一帧的<strong>延迟时间</strong>（动画快慢）和透明色。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Image Descriptor</strong></td>\n<td style=\"text-align: left;\">图像描述符</td>\n<td style=\"text-align: left;\">10</td>\n<td style=\"text-align: left;\"><strong>帧属性</strong>：定义当前这一帧在画布上的位置（x, y）和尺寸。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Image Data</strong></td>\n<td style=\"text-align: left;\">图像数据</td>\n<td style=\"text-align: left;\">可变</td>\n<td style=\"text-align: left;\">用处如其名</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Trailer</strong></td>\n<td style=\"text-align: left;\">结束标识</td>\n<td style=\"text-align: left;\">1</td>\n<td style=\"text-align: left;\"><strong>终点</strong>：固定为 <code>0x3B</code> (分号)，标志文件彻底结束。</td>\n</tr>\n</tbody>\n</table>\n<p>其中，最重要的就是图像数据了，其他的块用于规定这些图像数据应当如何呈现到我们眼中或是告知文件的开始结束，因此对于我们来说，其他块基本上都有固定模板，只有图像数据需要我们自己定义。</p>\n<h2 id=\"2lzw-gif强制使用的图像压缩算法\">2.LZW-GIF强制使用的图像压缩算法</h2>\n<p>搞定了GIF的文件结构，接下来就需要我们解决另一个拦路虎，LZW——一个经典的无损图像压缩算法，为了解决他，我们可以从他的原理入手。</p>\n<p>LZW通过为复杂数据构建简单索引来减少存储的数据量，这一点是朴素的哈希算法，当然，这一算法的发明者通过一套特殊的规则使得其他人可以直接通过索引数据反推出复杂数据，而在GIF中，则是GIF发明公司将他所规定的规则写好，编写GIF的人根据这一套规则构建数据，然后其他人直接使用套用了这一套规则的解码器解码，便能将数据还原成原来的样子。</p>\n<p>GIF的解码器又是如何读取数据的呢？解码器初始时一次性读取9位数据，然后从字典中添加这一对应关系，根据GIF规范，一旦字典里的条目达到 512 个，解码器就会自动将读取位宽从 9 位增加到 10 位。如果我们直接存放数据，那么结果就是数据读取错位，解码出来的内容就会与我们想象中的不一样，如果我们想要让他的数据读取正常，通常做法就是：我们构建一个同步状态机，即模拟GIF解码器读取数据的过程写入数据，构建一个字典，以相同的标准增加写入位宽，从而让解码器读取时能正确读取。但是这一过程看着就十分繁琐，能不能用一个简单的方法来让解码器正常读取数据呢？</p>\n<h2 id=\"3解决方案\">3.解决方案</h2>\n<p>GIF 协议中有一个特殊的指令叫 <strong>Clear Code（清除代码，值为256）</strong>。它的作用是告诉解码器：“嘿，把之前的字典都忘了吧，我们重新开始。”</p>\n<p>利用这一点，我们可以在代码中采用了一种偷鸡的策略：</p>\n<ol>\n<li>我们不尝试去寻找复杂的重复模式。</li>\n<li>我们每写入一小段像素（例如 125 个），就立刻发送一个 <strong>Clear Code</strong>。</li>\n<li>这强制让 LZW 字典始终处于“初始状态”。在初始状态下，LZW 的编码就等同于直接输出像素的颜色索引值。</li>\n</ol>\n<p>现在，让我们来实现他</p>\n<h2 id=\"4-构建3d立方体\">4. 构建3d立方体</h2>\n<p>在上一篇关于 3D 本质的文章中，我们推导出了两个核心公式。在这个程序中，我们将直接把它们转化为 C++ 代码。</p>\n<h3 id=\"旋转公式\">旋转公式</h3>\n<p>为了让立方体动起来，我们需要每一帧都改变顶点的 <span class=\"math inline\">\\((x, y, z)\\)</span> 坐标。这里使用旋转矩阵的简化版：</p>\n<pre><code class=\"language-cpp\">Point3D rotate(Point3D p, float angle) {\n    // 绕 Y 轴旋转\n    float nx = p.x * cos(angle) - p.z * sin(angle);\n    float nz = p.x * sin(angle) + p.z * cos(angle);\n    // 绕 X 轴微调旋转，让旋转看起来更立体\n    float ny = p.y * cos(angle * 0.8f) - nz * sin(angle * 0.8f);\n    nz = p.y * sin(angle * 0.8f) + nz * cos(angle * 0.8f);\n    return {nx, ny, nz};\n}\n</code></pre>\n<h3 id=\"投影公式透视\">投影公式（透视）</h3>\n<p>如何把 3D 坐标变成屏幕上的像素点？记得那个核心法则吗？<strong>“近大远小，本质就是除以 Z”。</strong></p>\n<pre><code class=\"language-cpp\">pair&lt;int, int&gt; project(Point3D p, int W, int H) {\n    float fov = 160.0f;        // 视野系数\n    float viewer_dist = 4.0f;  // 眼睛离物体的距离\n    // 核心逻辑：除以 (z + dist)\n    float factor = fov / (viewer_dist + p.z);\n    return { (int)(p.x * factor + W / 2), (int)(p.y * factor + H / 2) };\n}\n</code></pre>\n<p>有了这两个函数，我们就能在内存里的一个二维数组（<code>vector&lt;u8&gt; pixels</code>）上画线了。</p>\n<h3 id=\"手写-gif-编码器\">手写 GIF 编码器</h3>\n<p>我们实现了一个极简的编码器（<code>struct GifBitStream</code>）。它的工作是把像素点的颜色索引（0或1）打包成变长的二进制码流。</p>\n<pre><code class=\"language-cpp\">// GIF 的数据存储不仅是字节，还需要处理“位操作”\n// 比如写入一个 9-bit 的代码，可能跨越两个字节\nstruct GifBitStream {\n    vector&lt;u8&gt; byteData;\n    u32 bitBuffer = 0;\n    int bitCount = 0;\n\n    void writeCode(u32 code, int size) {\n        // 将数据移位并存入缓冲区...\n        // 凑够8位就写入 byteData\n    }\n    // ...\n};\n</code></pre>\n<h3 id=\"特别说明绕过lzw的问题\">特别说明：绕过LZW的问题</h3>\n<p>生成的GIF没有压缩，体积较为大</p>\n<h2 id=\"4-完整代码\">4. 完整代码</h2>\n<p>下面是完整的 C++ 代码：</p>\n<ol>\n<li><strong>计算</strong>：旋转 3D 点 -&gt; 投影成 2D 点。</li>\n<li><strong>绘图</strong>：在内存的黑板上画线（Bresenham 直线算法）。</li>\n<li><strong>编码</strong>：将内存的黑板按照 GIF 协议压缩并写入文件。</li>\n</ol>\n<p><em>(代码较长，建议直接复制编译运行，感受生成的快感)</em></p>\n<pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define u8 uint8_t\n#define u16 uint16_t\n#define u32 uint32_t\nstruct Point3D { \n    float x, y, z; \n};\nstruct Edge { \n    int u, v; \n};\nPoint3D rotate(Point3D p, float angle) {\n    float nx = p.x * cos(angle) - p.z * sin(angle);\n    float nz = p.x * sin(angle) + p.z * cos(angle);\n    float ny = p.y * cos(angle * 0.8f) - nz * sin(angle * 0.8f);\n    nz = p.y * sin(angle * 0.8f) + nz * cos(angle * 0.8f);\n    return {nx, ny, nz};\n}\npair&lt;int, int&gt; project(Point3D p, int W, int H) {\n    float fov = 160.0f; \n    float viewer_dist = 4.0f;\n    float factor = fov / (viewer_dist + p.z);\n    return { (int)(p.x * factor + W / 2), (int)(p.y * factor + H / 2) };\n}\n\ninline void drawLine(vector&lt;u8&gt;&amp; buffer, int W, int H, int x0, int y0, int x1, int y1) {\n    int dx = abs(x1 - x0), sx = x0 &lt; x1 ? 1 : -1;\n    int dy = -abs(y1 - y0), sy = y0 &lt; y1 ? 1 : -1;\n    int err = dx + dy;\n    while (true) {\n        if (x0 &gt;= 0 &amp;&amp; x0 &lt; W &amp;&amp; y0 &gt;= 0 &amp;&amp; y0 &lt; H) buffer[y0 * W + x0] = 1;\n        if (x0 == x1 &amp;&amp; y0 == y1) break;\n        int e2 = 2 * err;\n        if (e2 &gt;= dy) { err += dy; x0 += sx; }\n        if (e2 &lt;= dx) { err += dx; y0 += sy; }\n    }\n}\n// --- GIF 二进制协议部分 ---\nstruct GifBitStream {\n    vector&lt;u8&gt; byteData;\n    u32 bitBuffer = 0;\n    int bitCount = 0;\n\n    // 写入指定位宽的代码\n    inline void writeCode(u32 code, int size) {\n        bitBuffer |= (code &lt;&lt; bitCount);\n        bitCount += size;\n        while (bitCount &gt;= 8) {\n            byteData.push_back(bitBuffer &amp; 0xFF);\n            bitBuffer &gt;&gt;= 8;\n            bitCount -= 8;\n        }\n    }\n    inline void flush(ofstream&amp; f) {\n        if (bitCount &gt; 0) byteData.push_back(bitBuffer &amp; 0xFF);\n        // GIF 规定：数据必须切成每块最大 255 字节的小块\n        for (size_t i = 0; i &lt; byteData.size(); i += 255) {\n            u8 blockSize = (u8)min((size_t)255, byteData.size() - i);\n            f.put(blockSize);\n            f.write((char*)&amp;byteData[i], blockSize);\n        }\n        f.put(0); // 块结束\n    }\n};\ninline void writeWord(ofstream&amp; f, u16 v) { \n    f.put(v &amp; 0xFF); \n    f.put((v &gt;&gt; 8) &amp; 0xFF); \n}\ninline void writeGifFrame(ofstream&amp; f, const vector&lt;u8&gt;&amp; pixels, int W, int H) {\n    // 1. 图形控制扩展 (帧间隔)\n    f.put(0x21); \n    f.put(0xF9); \n    f.put(0x04);\n    f.put(0x09);       // 属性：还原背景，不使用透明\n    writeWord(f, 4);   // 延迟 40ms (1/25 FPS)\n    f.put(0); \n    f.put(0);\n\n    // 2. 图像描述符\n    f.put(0x2C);\n\n    // 偏移\n    writeWord(f, 0); \n    writeWord(f, 0); \n\n    // 宽高\n    writeWord(f, W); \n    writeWord(f, H); \n    f.put(0x00);\n\n    // 3. 数据\n    f.put(0x08); // 8位色\n    GifBitStream stream;\n\n    const int ClearCode = 256; //清空指令\n    const int EOICode = 257;\n    stream.writeCode(ClearCode, 9); // 清空解码器字典\n    int pixCount = 0;\n    for (u8 p : pixels) {\n        stream.writeCode(p, 9);\n        pixCount++;\n        //每 125 个像素重置一次字典，保证位宽不变，不会提前读取到下一个字节\n        if (pixCount == 125) {\n            stream.writeCode(ClearCode, 9); \n            pixCount = 0;\n        }\n    }\n    stream.writeCode(EOICode, 9); // 结束\n    stream.flush(f);\n}\nsigned main(int argc,char* argv[]){\n    const int W = 200, H = 200;\n    ofstream f(\"cube_perfect.gif\", ios::binary); //以二进制方式写入GIF文件\n\n    // [Header] \n    f &lt;&lt; \"GIF89a\";//89a 标准\n\n    // [Logical Screen Descriptor]\n    writeWord(f, W); writeWord(f, H);\n    f.put(0xF7); // 开启全局调色板 (256色)\n    f.put(0); \n    f.put(0);\n\n    // [Global Color Table]全局调色板\n\n    // 0: 背景黑\n    f.put(0); \n    f.put(0); \n    f.put(0);    \n\n    // 1: 极客绿\n    f.put(0); \n    f.put(255); \n    f.put(0);     \n\n    //只用到两种颜色，其余填充黑色\n    for(int i = 2; i &lt; 256; i++){ \n        f.put(0); f.put(0); f.put(0); \n    }\n\n    // [Netscape Loop] 循环动画扩展\n    f.put(0x21); // Netscape块标识\n    f.put(0xFF); // 扩展类型标识\n    f.put(0x0B); // 信息长度\n    f &lt;&lt; \"NETSCAPE2.0\"; //应用程序信息\n    f.put(0x03); // 数据长度，到结束符前\n    f.put(0x01); //索引\n    writeWord(f, 0);  //无限循环，不停止\n    f.put(0); //结束符\n\n    // 3D 立方体点数据\n    vector&lt;Point3D&gt; verts = {\n        {-1,-1,1}, {1,-1,1}, {1,1,1}, {-1,1,1},\n        {-1,-1,-1}, {1,-1,-1}, {1,1,-1}, {-1,1,-1}\n    };\n    vector&lt;Edge&gt; edges = {\n        {0,1},{1,2},{2,3},{3,0}, {4,5},{5,6},{6,7},{7,4}, {0,4},{1,5},{2,6},{3,7}\n    };\n\n    cout &lt;&lt; \"Encoding 3D Cube to GIF...\" &lt;&lt; endl;\n    for (int i = 0; i &lt; 60; i++) { // 60帧动画\n        vector&lt;u8&gt; pixels(W * H, 0); // 黑色背景\n        float angle = i * 0.12f; // 每1/60s旋转角度\n\n        vector&lt;pair&lt;int, int&gt;&gt; p2d; \n        for (auto v : verts) \n            p2d.push_back(project(rotate(v, angle), W, H)); // 3D-&gt;2D投影\n        for (auto e : edges) \n            drawLine(pixels, W, H, p2d[e.u].first, p2d[e.u].second, p2d[e.v].first, p2d[e.v].second); // 画边\n\n        writeGifFrame(f, pixels, W, H); // 写入帧数据\n        cout &lt;&lt; \".\";\n    }\n\n    f.put(0x3B); // 文件结束符\n    f.close(); //关闭\n\n    cout &lt;&lt; \"\\nSuccess! Open 'cube_perfect.gif' in Chrome/Edge.\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>运行这段代码，你会惊讶地发现目录下多了一个 <code>cube_perfect.gif</code>。用浏览器打开它，一个绿色的线框立方体正在黑色的背景中流畅地旋转。</p>\n<h2 id=\"5-打通认知的任督二脉\">5. 打通认知的“任督二脉”</h2>\n<p>回顾这个系列的三篇文章，我们其实只做了一件事：<strong>祛魅（Demystification）</strong>。</p>\n<ol>\n<li><strong>WAV 篇</strong>：我们发现声音文件只是记录振幅的二进制队列，没有任何魔法。</li>\n<li><strong>3D 篇</strong>：我们发现那些酷炫的 3D 游戏，底层只是初中几何的“相似三角形”运算。</li>\n<li><strong>GIF 篇（本文）</strong>：我们将数学运算的结果（3D），按照文件协议（二进制），封装成了人类可见的动画。</li>\n</ol>\n<p>这就是计算机科学最迷人的地方。无论是生成一段 440Hz 的正弦波，还是渲染《黑神话：悟空》中复杂的场景，其本质都是一样的：</p>\n<p><strong>Input（数据） + Rules（算法/格式） = Output（数字世界）</strong></p>\n<p>当你能够徒手写出一个 WAV，徒手推导出一个 3D 投影，徒手拼装出一个 GIF 时，你就不再只是一个 API 的调用者，你开始成为一个真正的创造者。代码的荒原上，只要你掌握了规则，你就是上帝。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 15:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/reasa\">reasa</a>&nbsp;\n阅读(<span id=\"post_view_count\">70</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(不成功方案的分析)",
      "link": "https://www.cnblogs.com/lulight/p/19529821",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19529821\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 15:26\">\n    <span>【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(不成功方案的分析)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>问题描述</h1>\n<p>在先前的四篇博文</p>\n<p>1：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19523829\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-23 19:12\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案三)</a>&nbsp;</p>\n<p>2：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19514101\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-21 21:19\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案二)</a>&nbsp;</p>\n<p>3：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19503730\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-19 21:09\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案一)&nbsp;</a>&nbsp;</p>\n<p>4：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19495544\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-17 11:54\">【Azure APIM】如何解决后端API服务配置自签名证书时APIM请求报错500：Error occured while calling backend service</a>&nbsp;</p>\n<p>5：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19479238\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-13 21:08\">【Azure 环境】在Windows环境中使用OpenSSL生成自签名证书链步骤分享</a></p>\n<p>我们分别介绍了使用OpenSSL生成自签名证书，然后解决APIM服务对自签名证书的信任问题。不论是APIM托管的网关，还是自建的网关都可以通过安装证书后使得请求受信任，通过配置API跳过证书验证环节。</p>\n<p>在方案三中，开始从自建网关本身AKS POD”方面入手，通过配置 SSL_CERT_FILE 环境变量，来安装自签名证书 （根证书和中间证书）到POD中解决问题。</p>\n<p>除了以上三种方案的情况下：在AKS集群的官方文档中，说可以直接更新集群，把自定义证书颁发机构（CA）向节点的信任存储添加多达 10 个 base64 编码的证书。</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"340\" width=\"666\" /></p>\n<p>所以，基于这个文档，本文尝试了第四种方案：使用&nbsp;az aks update&nbsp;&nbsp;--custom-ca-trust-certificates 证书命令</p>\n<p>&nbsp;</p>\n<h1>方案步骤</h1>\n<h2>准备步骤：准备好中间证书和根证书合并一起的 .crt 内容</h2>\n<p>导出方法：通过浏览器导出中间证书+根证书的 crt 文件，其内容是 Base64 编码</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"289\" width=\"666\" /></p>\n<p>&nbsp;</p>\n<h2>第一步：把准备好的证书传递到AKS集群</h2>\n<p>因aks集群已经创建好，所以使用 az aks update 指令</p>\n<blockquote>\n<pre><code class=\"code-line\" dir=\"auto\">az aks update \\\n    --resource-group &lt;resource-group-name&gt; \\\n    --name &lt;cluster-name&gt; \\\n    --custom-ca-trust-certificates &lt;path-to-certificate-file&gt;</code></pre>\n</blockquote>\n<p>执行截图</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"285\" width=\"666\" /></p>\n<h2>第二步：验证自签名CA证书是否在节点中正常工作</h2>\n<div>\n<div>1：使用&nbsp;kubectl get nodes ，列出节点名称</div>\n<div>2：进入节点debug模式：使用&nbsp;kubectl debug node/&lt;节点名&gt; -it --image=mcr.azk8s.cn/aks/fundamental/base-ubuntu:v0.0.11， 如：kubectl debug node/<em>aks-agentpool-20066971-vmss00000j</em> -it --image=mcr.azk8s.cn/aks/fundamental/base-ubuntu:v0.0.11</div>\n<div>3：使用 chroot /host 命令，把操作目录从当前容器环境 切换到 节点操作环境</div>\n<div>4：对比访问两个不同自签名CA证书的URL</div>\n<div>&nbsp;</div>\n<div>操作结果截图：</div>\n<div>\n<p><img alt=\"image\" class=\"lazyload\" height=\"256\" width=\"666\" /></p>\n<p>&nbsp;</p>\n</div>\n<h2>第三步：访问APIM的自建网关请求，自签名证书依旧不被信任。</h2>\n<p>&nbsp;</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"271\" width=\"666\" /></p>\n<p>为什么呢？把自签名的根证书，中间证书都安装到AKS集群中了，为何使用debug模式就可以信任这个自签名证书，而 APIM Self-hosted gateway pod却不可以呢？</p>\n</div>\n<h1>疑问解答</h1>\n<p>Debug pod 之所以能信任，是因为它用的是通用 Ubuntu 基础镜像，走的是系统 CA bundle；</p>\n<p>APIM Self‑hosted Gateway 用的是微软封装的网关容器 + .NET TLS 验证路径，完全不看 node 的 CA。</p>\n<p>这一点在 AKS 官方文档中是明确写清楚的：“Certificates added to the AKS node trust store aren’t available to containers running in pods.”&nbsp;</p>\n<p>AKS Node 安装 CA，只对 Node 生效，对 Pod 无效。 这一点，在文章开头的官方文档截图中，也特别提醒。只是，最开始没有正确理解这句话的意义！</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"334\" width=\"666\" /></p>\n<p>&nbsp;</p>\n<p>所以，如果要解决APIM 中自签名CA证书的信任问题。目前验证下来，只有三种方式：</p>\n<p>1：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19503730\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-19 21:09\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案一)&nbsp;</a>&nbsp;</p>\n<p>2：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19514101\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-21 21:19\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案二)</a>&nbsp;</p>\n<p>3：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19523829\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-23 19:12\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案三)</a>&nbsp;</p>\n<p>&nbsp;</p>\n<p><em>[完]&nbsp;</em></p>\n<p>&nbsp;</p>\n<h1>参考资料</h1>\n<p id=\"use-custom-certificate-authorities-cas-in-azure-kubernetes-service-aks\">在 Azure Kubernetes 服务（AKS）中使用自定义证书颁发机构（CA） ：<a href=\"https://docs.azure.cn/zh-cn/aks/custom-certificate-authority\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.azure.cn/zh-cn/aks/custom-certificate-authority</a></p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\">\n    <div style=\"background: #1c5f55; height: 36px; width: 618px; padding: 14px 5px 0px 3px;\">\n  <p style=\"font-weight: bold; color: white;\">当在复杂的环境中面临问题，格物之道需：浊而静之徐清，安以动之徐生。 云中，恰是如此!</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 15:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lulight\">编码者卢布</a>&nbsp;\n阅读(<span id=\"post_view_count\">25</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "技术问题记录20260125",
      "link": "https://www.cnblogs.com/grey-wolf/p/19529664",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/grey-wolf/p/19529664\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 14:37\">\n    <span>技术问题记录20260125</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"问题1http报文转curl\">问题1：http报文转curl</h1>\n<h2 id=\"背景\">背景</h2>\n<p>处理线上问题时，偶尔是需要进行网络抓包的（如tcpdump），用wireshark分析抓包文件时，一般能看到http请求的报文。</p>\n<p>如下面这样：</p>\n<p><img alt=\"image-20260125135624273\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125135624273.png\" /></p>\n<p>有时候需要用postman这类工具来调用，进行复现，简单来说，需求就是：将上面图里的报文转换为postman这类工具里的请求。</p>\n<p>有时候请求比较复杂，header也多，手工搞比较麻烦，而且线上问题处理都比较赶时间，如果能快速转换的话，是最好不过了。</p>\n<p>我的方案是：分两步。先想办法，将上述报文转换为标准的curl命令，再将curl命令转换为postman请求。</p>\n<h2 id=\"报文转curl\">报文转curl</h2>\n<p>经过搜索，发现有这么一个在线网站：可以用这个在线网站： <a href=\"https://curl.se/h2c/\" rel=\"noopener nofollow\" target=\"_blank\">https://curl.se/h2c/</a></p>\n<p><img alt=\"image-20260125140012663\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125140012663.png\" /></p>\n<p>上面这个网站就是curl这个项目的官网，算是官方背景了。大家可以直接用这个，方便。</p>\n<p><img alt=\"image-20260125140131349\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125140131349.png\" /></p>\n<p>不过我发现，在转换content-type为：application/x-www-form-urlencoded 这种的时候，结果中会缺失这个header，如下：</p>\n<p><img alt=\"image-20260125140247867\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125140247867.png\" /></p>\n<p>我自己想办法修复了一下，我找到了这个工具的源码：</p>\n<p><a href=\"https://github.com/curl/h2c\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/curl/h2c</a></p>\n<p>源码仓库里还有linux命令行版本h2c，不过一样存在上述的bug。</p>\n<p><img alt=\"image-20260125140453271\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125140453271.png\" /></p>\n<p>我看了下源码，是perl语言写的，我当时想着，现在大模型也厉害，直接让他给我转换成java语言吧。</p>\n<p>最后我就转了个java版本，修复了那个bug，并且让大模型用javafx弄了个图形界面的版本（javafx代码我也看不懂，也懒得看，能用就行了）。</p>\n<p>源码我放在了：</p>\n<p><a href=\"https://gitee.com/dumpcao/http-to-curl-converter\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/dumpcao/http-to-curl-converter</a></p>\n<p>自己mvn package打个包就能用，或者直接用我仓库里提交的jar包，下下来双击运行就能用：</p>\n<p><img alt=\"image-20260125140657277\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125140657277.png\" /></p>\n<h2 id=\"curl转请求\">curl转请求</h2>\n<p>postman可以直接导入。</p>\n<p><img alt=\"image-20260125141145134\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125141145134.png\" /></p>\n<p>我用了apifox也支持curl导入，不过要繁琐一点，可自行搜索。</p>\n<h1 id=\"问题2集合比较工具\">问题2：集合比较工具</h1>\n<p>有时候，临时要对两个集合（如两个list、set）进行比较，数据可能来源于不懂技术的同事发给你的两个excel，比如看看到底有哪些差异，多了什么，少了什么等等。</p>\n<p>以前我有时候会用excel排序后对比，有时候也会写个临时代码来弄，但还是比较麻烦。</p>\n<p>发现了有这类在线工具，可网上搜索：集合比较。</p>\n<p>推荐1个我找到的：</p>\n<p><a href=\"https://jsons.top/menus.html\" rel=\"noopener nofollow\" target=\"_blank\">https://jsons.top/menus.html</a></p>\n<p><img alt=\"image-20260125141545909\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125141545909.png\" /></p>\n<p>或者现在也可以让大模型帮忙写一个，打成jar，随时可以本地执行。</p>\n<h1 id=\"问题3数据库序列设置\">问题3：数据库序列设置</h1>\n<p>我们现在用的国产数据库，是基于postgresql的，表的主键不是mysql那一套，都是从序列中获取。</p>\n<p>有时候我们会直接用insert语句插入数据库，且是手动指定了id值的：</p>\n<p><img alt=\"image-20260125141909399\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125141909399.png\" /></p>\n<p>这种sql执行完成后，由于是手动设置的id值，没从序列中获取，所以序列中的id值可能还是旧的，比如上述图片中，设置的id值都到4了。假设序列的最新值还是3，下一次有人从序列里取值，就会取到4，然后插入的话，就会报主键冲突。</p>\n<p>所以，我们自己得记得，执行了手动指定了id的sql后，要把序列值同步更新：</p>\n<p>就可以执行如下sql：</p>\n<pre><code class=\"language-sql\">-- 手动更新序列的值。设置序列table_config_id_seq的最新值为table_config中的最大值\nSELECT setval('table_config_id_seq', (SELECT max(id) FROM table_config));   \n\n-- 查看序列的当前值\nselect currval('table_config_id_seq');\t\n</code></pre>\n<h1 id=\"问题4dbeaver离线环境下下载驱动失败\">问题4：dbeaver离线环境下下载驱动失败</h1>\n<p>在没有互联网的机器上，安装了dbeaver，也会发现真正去连接数据库的时候，竟然还要联网去下载驱动，此时就会报错。</p>\n<p>我们可以这样，先在能联网的机器上，找到对应的数据库驱动（就是各种驱动jar包）：</p>\n<p><img alt=\"image-20260125142804539\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125142804539.png\" /></p>\n<p><img alt=\"image-20260125142835353\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125142835353.png\" /></p>\n<p><img alt=\"image-20260125142851236\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125142851236.png\" /></p>\n<p>拿到这个jar包后，拷贝到离线环境中，同样是在上述窗口中，删除全部的老的记录，再add file添加jar包，重连即可：</p>\n<p><img alt=\"image-20260125143005996\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125143005996.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 14:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/grey-wolf\">三国梦回</a>&nbsp;\n阅读(<span id=\"post_view_count\">30</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "langchain 快速入门(四)：搭建强大的AI Agent",
      "link": "https://www.cnblogs.com/ClownLMe/p/19529417",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19529417\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 13:28\">\n    <span>langchain 快速入门(四)：搭建强大的AI Agent</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简介\">简介</h1>\n<p>AI Agent 不仅仅是一个能聊天的机器人（如普通的 ChatGPT），而是一个能够感知环境、进行推理、自主决策并调用工具来完成特定任务的智能系统，更够完成更为复杂的AI场景需求。</p>\n<h1 id=\"ai-agent\">AI Agent</h1>\n<h3 id=\"功能\">功能</h3>\n<p>根据查阅的资料，agent的功能点如下：<br />\nAgent = LLM + 规划 + 记忆 + 工具使用<br />\n<strong>LLM：</strong> 用于回答，推理的AI模型<br />\n<strong>记忆：</strong> 短期记忆（对话历史），长期记忆（RAG知识库）<br />\n<strong>规划：</strong> 任务的执行流<br />\n<strong>工具：</strong> Agent可以调用的外部函数</p>\n<h1 id=\"一个简单的agent\">一个简单的Agent</h1>\n<h3 id=\"案例\">案例</h3>\n<p>案例描述：agent可以使用两个工具：1. 记录公司数据的RAG知识库   2. python精确计算器</p>\n<pre><code class=\"language-python\">import os\nfrom langchain_community.chat_models.tongyi import ChatTongyi\nfrom langchain_community.embeddings import DashScopeEmbeddings\nfrom langchain_community.vectorstores import FAISS\nfrom langchain_core.messages import ToolMessage\nfrom langchain_core.tools import tool\nfrom langchain_core.messages import HumanMessage, ToolMessage\nfrom langchain_core.documents import Document\nfrom langchain_text_splitters import RecursiveCharacterTextSplitter\n  \nos.environ[\"DASHSCOPE_API_KEY\"] = \"api_key\"\n  \n@tool\ndef calculator(expression: str) -&gt; str:\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; 计算数学表达式。需要精确计算时使用。\n&nbsp; &nbsp; 参数:\n&nbsp; &nbsp; &nbsp; &nbsp; expression: 数学算式，如 \"2 + 2\" 或 \"500 * 0.8\"。\n&nbsp; &nbsp; 返回:\n&nbsp; &nbsp; &nbsp; &nbsp; str: 计算结果，如 \"4.0\" 或 \"400.0\"。\n&nbsp; &nbsp; \"\"\"\n\n&nbsp; &nbsp; print(f\" &nbsp;[🛠️ 工具调用] 计算器正在计算: {expression}\")\n&nbsp; &nbsp; try:\n&nbsp; &nbsp; &nbsp; &nbsp; return str(eval(expression))\n&nbsp; &nbsp; except Exception as e:\n&nbsp; &nbsp; &nbsp; &nbsp; return f\"计算错误: {e}\"\n  \n@tool\ndef rag_search(query: str) -&gt; str:\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; 从数据库中搜索与查询公司内部相关的文档，包括公司计划名，代号，截止日期等详细信息。\n&nbsp; &nbsp; 参数:\n&nbsp; &nbsp; &nbsp; &nbsp; query (str): 要搜索的查询字符串。\n&nbsp; &nbsp; 返回:\n&nbsp; &nbsp; &nbsp; &nbsp; str: 与查询相关的文档内容。\n&nbsp; &nbsp; \"\"\"\n  \n&nbsp; &nbsp; # 从RAG数据库中检索文档\n&nbsp; &nbsp; raw_text = \"\"\"\n&nbsp; &nbsp; 【公司内部机密：代号“深蓝计划”】\n&nbsp; &nbsp; 1. 项目目标：开发一款能听懂猫语的翻译器。\n&nbsp; &nbsp; 2. 核心技术：基于Transformer的“喵声波”分析算法。\n&nbsp; &nbsp; 3. 团队暗号：如果有人问“今天天气怎么样？”，必须回答“我想吃鱼”。\n&nbsp; &nbsp; 4. 截止日期：2026年12月31日。\n&nbsp; &nbsp; 5. 经费预算：仅剩50元人民币，主要用于购买猫条。\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; \n&nbsp; &nbsp; RAG_PATH = \"faiss_index\"\n\n\n&nbsp; &nbsp; docs = [Document(page_content=raw_text)]\n&nbsp; &nbsp; text_splitter = RecursiveCharacterTextSplitter(chunk_size=25, chunk_overlap=5)\n&nbsp; &nbsp; split_docs = text_splitter.split_documents(docs)\n\n&nbsp; &nbsp; embeddings = DashScopeEmbeddings(model=\"text-embedding-v1\")\n\n&nbsp; &nbsp; if os.path.exists(RAG_PATH):\n&nbsp; &nbsp; &nbsp; &nbsp; print(\"公司内部数据库已存在\")\n&nbsp; &nbsp; &nbsp; &nbsp; ragdb = FAISS.load_local(RAG_PATH, embeddings, allow_dangerous_deserialization=True)\n&nbsp; &nbsp; else:\n&nbsp; &nbsp; &nbsp; &nbsp; print(\"创建公司内部数据库\")\n&nbsp; &nbsp; &nbsp; &nbsp; ragdb = FAISS.from_documents(split_docs, embeddings)\n&nbsp; &nbsp; &nbsp; &nbsp; ragdb.save_local(RAG_PATH)\n&nbsp; &nbsp; return \"\\n\\n\".join(doc.page_content for doc in ragdb.similarity_search(query, k=2))\n\ndef run_agent(query:str):\n\n&nbsp; &nbsp; #初始化模型\n&nbsp; &nbsp; tool_maps={\n&nbsp; &nbsp; &nbsp; &nbsp; \"rag_search\": rag_search,\n&nbsp; &nbsp; &nbsp; &nbsp; \"calculator\": calculator\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; llm = ChatTongyi(model_name=\"qwen-plus\")\n&nbsp; &nbsp; tool_llm = llm.bind_tools(tools=list(tool_maps.values()))\n\n&nbsp; &nbsp; message = [HumanMessage(content=query)]\n\n&nbsp; &nbsp; for i in range(5):\n&nbsp; &nbsp; \n&nbsp; &nbsp; &nbsp; &nbsp; print(\"=\"*20+\"\\n第\"+str(i+1)+\"轮\\n\"+query+\"\\n\"+\"=\"*20)\n&nbsp; &nbsp; &nbsp; &nbsp; response = tool_llm.invoke(message)\n\n&nbsp; &nbsp; &nbsp; &nbsp; message.append(response)\n&nbsp; &nbsp; &nbsp; &nbsp; print(f\"需要调用{len(response.tool_calls)}个方法\")\n\n&nbsp; &nbsp; &nbsp; &nbsp; if not response.tool_calls:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(\"最终结果：\" + response.content)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return\n\n&nbsp; &nbsp; &nbsp; &nbsp; for tool_call in response.tool_calls:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call_id = tool_call[\"id\"]\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func_name = tool_call[\"name\"]\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func_args = tool_call[\"args\"]\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 安全检查：确保模型调用的工具真的存在\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if func_name in tool_maps:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 运行 Python 函数\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tool_func = tool_maps[func_name]\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tool_output = tool_func.invoke(func_args)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(\"工具调用：\" + func_name + \"，参数：\" + str(func_args) + \"，结果：\" + tool_output)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tool_output = f\"错误: 工具 {func_name} 不存在。\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; message.append(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ToolMessage(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; content=tool_output,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tool_call_id=call_id,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name=func_name,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )\n\nif __name__ == \"__main__\":\n&nbsp; &nbsp; run_agent(\"公司计划是什么\")\n&nbsp; &nbsp; run_agent(\"公司的经费预算是多少，如果预算预算提高46%后多少\")\n&nbsp; &nbsp; run_agent(\"今天天气真好\")\n</code></pre>\n<h3 id=\"代码解析\">代码解析</h3>\n<p>要实现复杂的工具调用，必须实现AI的多轮对话，在langchain框架中，提供了大量的prompt模板，让开发者不需要过度想一些基础的prompt实现。</p>\n<p>上面代码的执行流程如下：<br />\n<strong>初始化2个工具函数-&gt;绑定LLM与工具-&gt;通过循环进行多轮对话</strong></p>\n<h5 id=\"初始化2个工具函数\">初始化2个工具函数</h5>\n<p>这里的<code>rag_search</code>上一篇文章讲了具体实现，这里就不废话了。</p>\n<pre><code class=\"language-python\">@tool\ndef calculator(expression: str) -&gt; str:\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; 计算数学表达式。需要精确计算时使用。\n&nbsp; &nbsp; 参数:\n&nbsp; &nbsp; &nbsp; &nbsp; expression: 数学算式，如 \"2 + 2\" 或 \"500 * 0.8\"。\n&nbsp; &nbsp; 返回:\n&nbsp; &nbsp; &nbsp; &nbsp; str: 计算结果，如 \"4.0\" 或 \"400.0\"。\n&nbsp; &nbsp; \"\"\"\n\n&nbsp; &nbsp; print(f\" &nbsp;[🛠️ 工具调用] 计算器正在计算: {expression}\")\n&nbsp; &nbsp; try:\n&nbsp; &nbsp; &nbsp; &nbsp; return str(eval(expression))\n&nbsp; &nbsp; except Exception as e:\n&nbsp; &nbsp; &nbsp; &nbsp; return f\"计算错误: {e}\"\n  \n@tool\ndef rag_search(query: str) -&gt; str:\n&nbsp; &nbsp; ......\n</code></pre>\n<p>工具函数的格式，主要有3个方面：</p>\n<ul>\n<li><strong>工具修饰：</strong> 利用<code>@tool</code>修饰器修饰</li>\n<li><strong>函数的描述：</strong> 这里放函数的描述，大模型通过这个描述定位工具，因此这部分必须详细，可以参考上面:\n<ol>\n<li>函数的描述</li>\n<li>函数的参数+例子</li>\n<li>函数的返回+例子</li>\n</ol>\n</li>\n<li><strong>工具的实现：</strong> 返回值要是字符串<br />\n如下：</li>\n</ul>\n<pre><code class=\"language-python\">@tool\ndef func_name(arg) -&gt; str:\n\t\"\"\"\n\t描述\n\t\"\"\"\n\t......\n</code></pre>\n<h5 id=\"绑定llm与工具\">绑定LLM与工具</h5>\n<p>工具的绑定非常的简单，只需要简单的<code>bind_tools</code>类方法就行</p>\n<pre><code class=\"language-python\">tool_maps={\n&nbsp; &nbsp; &nbsp; &nbsp; \"rag_search\": rag_search,\n&nbsp; &nbsp; &nbsp; &nbsp; \"calculator\": calculator\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; llm = ChatTongyi(model_name=\"qwen-plus\")\n&nbsp; &nbsp; tool_llm = llm.bind_tools(tools=list(tool_maps.values()))\n</code></pre>\n<h5 id=\"通过循环进行多轮对话重点\">通过循环进行多轮对话（重点）</h5>\n<p>工具的调用流程：<br />\n<strong>提示词-&gt;LLM-&gt;要调用的工具-&gt;LLM-&gt;结果</strong></p>\n<pre><code class=\"language-python\">\tmessage = [HumanMessage(content=query)]\n\n&nbsp; &nbsp; for i in range(5):\n&nbsp; &nbsp; \n&nbsp; &nbsp; &nbsp; &nbsp; print(\"=\"*20+\"\\n第\"+str(i+1)+\"轮\\n\"+query+\"\\n\"+\"=\"*20)\n&nbsp; &nbsp; &nbsp; &nbsp; response = tool_llm.invoke(message)\n\n&nbsp; &nbsp; &nbsp; &nbsp; message.append(response)\n&nbsp; &nbsp; &nbsp; &nbsp; print(f\"需要调用{len(response.tool_calls)}个方法\")\n\n&nbsp; &nbsp; &nbsp; &nbsp; if not response.tool_calls:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(\"最终结果：\" + response.content)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return\n\n&nbsp; &nbsp; &nbsp; &nbsp; for tool_call in response.tool_calls:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call_id = tool_call[\"id\"]\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func_name = tool_call[\"name\"]\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func_args = tool_call[\"args\"]\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 安全检查：确保模型调用的工具真的存在\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if func_name in tool_maps:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 运行 Python 函数\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tool_func = tool_maps[func_name]\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tool_output = tool_func.invoke(func_args)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(\"工具调用：\" + func_name + \"，参数：\" + str(func_args) + \"，结果：\" + tool_output)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tool_output = f\"错误: 工具 {func_name} 不存在。\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; message.append(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ToolMessage(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; content=tool_output,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tool_call_id=call_id,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name=func_name,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )\n</code></pre>\n<p>在调用<code>bind_tools</code>方法后，大模型的返回对象会多出<code>tool_calls</code>字段的数组数据，用于存放需要调用工具的参数，函数名，在调用函数后，将调用函数的结果封装成<code>ToolMessage</code>传入，再继续调用大模型。</p>\n<p><strong>注意：在调用LLM时可能LLM会不断要求Tool，由此可能发生死循环，因此要限制循环次数。</strong></p>\n<h1 id=\"安全与审思\">安全与审思</h1>\n<h3 id=\"风险评估\">风险评估</h3>\n<p>近些年，ai提示词注入频频发生，根据上面的案例：</p>\n<pre><code class=\"language-python\">@tool\ndef calculator(expression: str) -&gt; str:\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; 计算数学表达式。需要精确计算时使用。\n&nbsp; &nbsp; 参数:\n&nbsp; &nbsp; &nbsp; &nbsp; expression: 数学算式，如 \"2 + 2\" 或 \"500 * 0.8\"。\n&nbsp; &nbsp; 返回:\n&nbsp; &nbsp; &nbsp; &nbsp; str: 计算结果，如 \"4.0\" 或 \"400.0\"。\n&nbsp; &nbsp; \"\"\"\n\n&nbsp; &nbsp; print(f\" &nbsp;[🛠️ 工具调用] 计算器正在计算: {expression}\")\n&nbsp; &nbsp; try:\n&nbsp; &nbsp; &nbsp; &nbsp; return str(eval(expression))\n&nbsp; &nbsp; except Exception as e:\n&nbsp; &nbsp; &nbsp; &nbsp; return f\"计算错误: {e}\"\n</code></pre>\n<p>LLM在调用这个工具时使用了<code>eval</code>，这就造成了风险注入点，不法分子可能利用这个漏洞，获取电脑权限。</p>\n<h3 id=\"修复思路\">修复思路</h3>\n<p>修复上面漏洞，可以参考以下几个思路：</p>\n<ol>\n<li>通过指令提示词，让LLM忽略，并终止危险代码调用该函数</li>\n<li>在函数中用正则匹配危险代码，或设置白名单</li>\n<li>替换eval函数，将其换为更加安全的方法，如手动写死运算</li>\n</ol>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 13:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">50</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}