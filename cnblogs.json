{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "volatile",
      "link": "https://www.cnblogs.com/aicc123/p/19549365",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aicc123/p/19549365\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 16:33\">\n    <span>volatile</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"volatile是java并发编程中的轻量级同步机制核心解决可见性和有序性的问题\">volatile是Java并发编程中的轻量级同步机制，核心解决可见性和有序性的问题</h4>\n<h3 id=\"三大特性\">三大特性</h3>\n<pre><code>1.可见性：修改立即可见。  线程A修改了，线程B立即可见。\n2.有序性：禁止指令重排。  代码执行的顺序就是执行顺序。\n3.不保证原子性：符合操作仍可能出错。  i++这种操作仍需要sychornized或Atomic。\n</code></pre>\n<h3 id=\"volatile怎么解决可见性\">volatile怎么解决可见性</h3>\n<pre><code>volatile修饰共享变量\n每个线程读取共享变量时会从主内存中读取，如果他对其进行了操作并写回到主内存中，\n其他所有读取了这个共享变量的线程需重新从主内存中读取。\nvolatile保证了不同线程对共享变量操作的可见性，也就是当以一个线程修改了volatile修饰的变量并写回时，\n其他线程会立即看到最新的值\n</code></pre>\n<h3 id=\"volatile怎么解决有序性\">volatile怎么解决有序性</h3>\n<pre><code>为了提高性能，编译器和处理器通常会对编译完成的代码进行指令重排序。\n在单线程的情况下是没有问题的，但如果是多线程的话就会引起线程安全问题。\nvolatile使用了内部屏障来保证有序性\nJava编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。\n写操作：前面代码不能重排到后面；读操作：后面代码不能重排到前面\n</code></pre>\n<h3 id=\"volatile对比sychornized\">volatile对比sychornized</h3>\n<pre><code>相比于 synchronized 或者 Lock，volatile 是更轻量的，因为使用 volatile 不会发生上下文切换等开销很大的情况，不会让线程阻塞。但正是由于它的开销相对比较小，所以它的效果，也就是能力，相对也小一些。\n相似性：volatile 可以看作是一个轻量版的 synchronized，比如一个共享变量如果自始至终只被各个线程赋值和读取，而没有其他操作的话，那么就可以用 volatile 来代替 synchronized 或者代替原子变量，足以保证线程安全\n不可代替：但是在更多的情况下，volatile 是不能代替 synchronized 的，volatile 并没有提供原子性和互斥性。\n性能方面：volatile 属性的读写操作都是无锁的，正是因为无锁，所以不需要花费时间在获取锁和释放锁上，所以说它是高性能的，比 synchronized 性能更好\n</code></pre>\n<h3 id=\"使用场景\">使用场景</h3>\n<pre><code>场景1：状态标志位（最常用）\n</code></pre>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<pre><code>场景2：单例模式\n</code></pre>\n<p><img alt=\"image\" class=\"lazyload\" /><br />\n为什么需要 volatile？<br />\nnew Singleton() 实际分三步：1.分配内存 2.初始化对象 3.赋值引用。<br />\n如果没有 volatile，可能重排为 1→3→2，导致其他线程拿到未初始化的对象（空指针异常）。</p>\n<pre><code>场景3：读写锁的读操作（简单计数器）\n</code></pre>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 16:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aicc123\">acccccccccc</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "智慧景区管理系统 | 计算机毕设项目",
      "link": "https://www.cnblogs.com/iRuriCatt/p/19549300",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/iRuriCatt/p/19549300\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 16:23\">\n    <span>智慧景区管理系统 | 计算机毕设项目</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文介绍了一个基于Vue3和SpringBoot的智慧景区管理系统。系统采用前后端分离架构，后端使用SpringBoot3.3.5、MySQL8.0等技术，前端采用Vue3.5.13、ElementPlus等框架，实现了景区信息管理、在线购票、评论系统、数据统计等功能模块。系统具备完善的用户权限管理、支付集成和安全机制，通过Redis缓存、数据库优化等技术提升性能。该系统旨在为游客提供便捷的景区服务，同时优化景区管理效率，实现智能化运营。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"项目概述\">项目概述</h2>\n<p>该项目是一个基于Vue3和SpringBoot技术栈的智慧景区管理系统，采用前后端分离架构，构建了涵盖游客端和管理端的统一平台。系统支持景区信息展示、购票管理、评论系统和数据统计等功能，旨在提升游客的用户体验，优化景区管理效率，并增强服务的智能化与便捷性。</p>\n<h2 id=\"技术栈详情\">技术栈详情</h2>\n<h3 id=\"后端技术栈\">后端技术栈</h3>\n<ul>\n<li><strong>核心框架</strong>: Spring Boot 3.3.5</li>\n<li><strong>编程语言</strong>: Java 17</li>\n<li><strong>数据库</strong>: MySQL 8.0+</li>\n<li><strong>ORM框架</strong>: MyBatis 3.0.3</li>\n<li><strong>缓存服务</strong>: Redis 6.0+</li>\n<li><strong>安全认证</strong>: JWT Token认证机制</li>\n<li><strong>支付集成</strong>: 支付宝SDK 4.34.0</li>\n<li><strong>文件存储</strong>: 阿里云OSS</li>\n<li><strong>内容安全</strong>: 敏感词过滤 0.22.0</li>\n</ul>\n<h3 id=\"前端技术栈\">前端技术栈</h3>\n<ul>\n<li><strong>核心框架</strong>: Vue 3.5.13</li>\n<li><strong>构建工具</strong>: Vite 6.2.0</li>\n<li><strong>UI组件库</strong>: Element Plus 2.9.6</li>\n<li><strong>路由管理</strong>: Vue Router 4.5.0</li>\n<li><strong>状态管理</strong>: Pinia 3.0.1</li>\n<li><strong>HTTP客户端</strong>: Axios 1.8.3</li>\n<li><strong>数据可视化</strong>: ECharts 5.6.0</li>\n<li><strong>样式处理</strong>: Sass 1.85.1 + Tailwind CSS 3.4.19</li>\n</ul>\n<h2 id=\"核心功能模块实现\">核心功能模块实现</h2>\n<h3 id=\"1-景区信息管理模块\">1. 景区信息管理模块</h3>\n<h4 id=\"后端实现\">后端实现</h4>\n<ul>\n<li><strong>控制器</strong>: <code>AttractionsController.java</code> - 处理景区信息的增删改查操作</li>\n<li><strong>服务层</strong>: <code>AttractionsServiceImpl.java</code> - 实现景区业务逻辑</li>\n<li><strong>数据访问</strong>: <code>AttractionsMapper.java</code> - 景区数据持久化操作</li>\n<li><strong>实体类</strong>: <code>Attractions.java</code> - 景区信息实体</li>\n</ul>\n<h4 id=\"前端实现\">前端实现</h4>\n<ul>\n<li><strong>页面组件</strong>: <code>src/views/attractions/index.vue</code> - 景区列表页面</li>\n<li><strong>详情页面</strong>: <code>src/views/attractions/detail/index.vue</code> - 景区详情页面</li>\n<li><strong>管理页面</strong>: <code>src/views/admin/attractions/index.vue</code> - 景区管理后台</li>\n<li><strong>API接口</strong>: <code>src/apis/attraction.js</code> - 景区相关API调用</li>\n</ul>\n<h4 id=\"核心功能\">核心功能</h4>\n<ul>\n<li>景区信息展示（名称、描述、位置、价格、状态）</li>\n<li>景区图片管理（多图展示、主图设置）</li>\n<li>开放时间配置（按星期设置开放时间）</li>\n<li>景区状态管理（开放/关闭状态切换）</li>\n</ul>\n<p><img alt=\"PixPin_2026-01-29_11-39-57\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129153945795-151604024.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-41-31\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154017380-127463191.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-41-54\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154026757-1205993700.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-42-45\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154034843-1706985093.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-50-30\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154100865-1047619926.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_12-36-54\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154119482-759247282.png\" /></p>\n<h3 id=\"2-购票与订单管理模块\">2. 购票与订单管理模块</h3>\n<h4 id=\"后端实现-1\">后端实现</h4>\n<ul>\n<li><strong>控制器</strong>: <code>OrderController.java</code> - 处理订单相关操作</li>\n<li><strong>服务层</strong>: <code>OrderServiceImpl.java</code> - 订单业务逻辑实现</li>\n<li><strong>数据访问</strong>: <code>OrderMapper.java</code>、<code>OrderItemMapper.java</code> - 订单数据操作</li>\n<li><strong>支付集成</strong>: <code>AlipayController.java</code> - 支付宝支付接口</li>\n<li><strong>实体类</strong>: <code>Order.java</code>、<code>OrderItem.java</code> - 订单相关实体</li>\n</ul>\n<h4 id=\"前端实现-1\">前端实现</h4>\n<ul>\n<li><strong>预订组件</strong>: <code>src/components/BookingDialog.vue</code> - 门票预订对话框</li>\n<li><strong>订单页面</strong>: <code>src/views/user-center/order/index.vue</code> - 用户订单管理</li>\n<li><strong>管理页面</strong>: <code>src/views/admin/orders/index.vue</code> - 订单管理后台</li>\n<li><strong>支付页面</strong>: <code>src/views/payment/success.vue</code> - 支付成功页面</li>\n<li><strong>API接口</strong>: <code>src/apis/order.js</code> - 订单相关API</li>\n</ul>\n<h4 id=\"核心功能-1\">核心功能</h4>\n<ul>\n<li>在线门票预订（选择日期、数量、价格计算）</li>\n<li>支付宝支付集成（沙箱环境）</li>\n<li>订单状态管理（待支付、已支付、已完成、已取消）</li>\n<li>订单明细管理（景点信息、数量、单价、总价）</li>\n</ul>\n<p><img alt=\"PixPin_2026-01-29_11-42-58\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154222367-1026880591.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_12-46-43\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154312858-1144309213.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_12-47-39\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154507916-65485762.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-50-21\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154250476-1464096715.png\" /></p>\n<h3 id=\"3-活动管理模块\">3. 活动管理模块</h3>\n<h4 id=\"后端实现-2\">后端实现</h4>\n<ul>\n<li><strong>控制器</strong>: <code>EventController.java</code> - 活动相关操作处理</li>\n<li><strong>服务层</strong>: <code>EventServiceImpl.java</code> - 活动业务逻辑</li>\n<li><strong>数据访问</strong>: <code>EventMapper.java</code> - 活动数据操作</li>\n<li><strong>实体类</strong>: <code>Event.java</code>、<code>EventParticipant.java</code> - 活动及参与者实体</li>\n</ul>\n<h4 id=\"前端实现-2\">前端实现</h4>\n<ul>\n<li><strong>活动列表</strong>: <code>src/views/events/index.vue</code> - 活动列表页面</li>\n<li><strong>活动详情</strong>: <code>src/views/events/detail/index.vue</code> - 活动详情页面</li>\n<li><strong>管理页面</strong>: <code>src/views/admin/events/index.vue</code> - 活动管理后台</li>\n<li><strong>用户活动</strong>: <code>src/views/user-center/event/index.vue</code> - 用户活动管理</li>\n<li><strong>API接口</strong>: <code>src/apis/event.js</code> - 活动相关API</li>\n</ul>\n<h4 id=\"核心功能-2\">核心功能</h4>\n<ul>\n<li>活动信息管理（名称、描述、时间、地点、参与人数等）</li>\n<li>活动参与管理（用户报名、参与状态跟踪）</li>\n<li>活动状态管理（进行中、已结束、已取消）</li>\n<li>活动收藏功能（用户收藏感兴趣的活动）</li>\n<li>活动图片展示（活动封面图片管理）</li>\n</ul>\n<p><img alt=\"PixPin_2026-01-29_11-40-56\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154344977-374579448.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-44-29\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154352517-1110850957.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-46-00\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154239469-551883938.png\" /></p>\n<h3 id=\"4-评论管理模块\">4. 评论管理模块</h3>\n<h4 id=\"后端实现-3\">后端实现</h4>\n<ul>\n<li><strong>控制器</strong>: <code>CommentController.java</code> - 评论相关操作处理</li>\n<li><strong>服务层</strong>: <code>CommentServiceImpl.java</code> - 评论业务逻辑</li>\n<li><strong>数据访问</strong>: <code>CommentMapper.java</code> - 评论数据操作</li>\n<li><strong>敏感词过滤</strong>: <code>SensitiveWordUtil.java</code> - 评论内容安全过滤</li>\n<li><strong>实体类</strong>: <code>Comment.java</code> - 评论信息实体</li>\n</ul>\n<h4 id=\"前端实现-3\">前端实现</h4>\n<ul>\n<li><strong>评论组件</strong>: 集成在景点详情页面中</li>\n<li><strong>管理页面</strong>: <code>src/views/admin/comments/index.vue</code> - 评论管理后台</li>\n<li><strong>用户评论</strong>: <code>src/views/user-center/comment/index.vue</code> - 用户评论管理</li>\n<li><strong>API接口</strong>: <code>src/apis/comment.js</code> - 评论相关API</li>\n</ul>\n<h4 id=\"核心功能-3\">核心功能</h4>\n<ul>\n<li>多级评论系统（支持回复功能）</li>\n<li>评分系统（1-5分评分机制）</li>\n<li>敏感词自动过滤（确保评论内容安全）</li>\n<li>评论审核机制（待审核、通过、不通过）</li>\n<li>评论图片上传支持</li>\n</ul>\n<p><img alt=\"PixPin_2026-01-29_11-46-05\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154553185-1372239012.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-50-35\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154606119-181618713.png\" /></p>\n<h3 id=\"5-数据统计模块\">5. 数据统计模块</h3>\n<h4 id=\"后端实现-4\">后端实现</h4>\n<ul>\n<li><strong>控制器</strong>: <code>DashboardController.java</code> - 数据统计接口</li>\n<li><strong>服务层</strong>: <code>DashboardServiceImpl.java</code> - 统计业务逻辑</li>\n<li><strong>数据访问</strong>: <code>DashboardMapper.java</code> - 统计数据查询</li>\n<li><strong>实体类</strong>: 多种统计结果实体（销售额、订单数量等）</li>\n</ul>\n<h4 id=\"前端实现-4\">前端实现</h4>\n<ul>\n<li><strong>数据看板</strong>: <code>src/views/admin/dashboard/index.vue</code> - 管理后台数据统计</li>\n<li><strong>图表组件</strong>: 集成ECharts实现数据可视化</li>\n<li><strong>API接口</strong>: <code>src/apis/admin.js</code> - 统计数据API</li>\n</ul>\n<h4 id=\"核心功能-4\">核心功能</h4>\n<ul>\n<li>用户统计（总数、今日新增、管理员数量）</li>\n<li>订单统计（销售额、订单数量、完成率）</li>\n<li>评论统计（评论总数、评分分布）</li>\n<li>活动统计（活动数量、参与人数）</li>\n<li>访客统计（登录用户统计）</li>\n<li>实时数据可视化展示</li>\n</ul>\n<p><img alt=\"PixPin_2026-01-29_11-49-15\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154619105-1802790429.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-50-49\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154633224-1555891116.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-50-56\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154638408-653830508.png\" /></p>\n<h2 id=\"用户管理模块\">用户管理模块</h2>\n<h3 id=\"后端实现-5\">后端实现</h3>\n<ul>\n<li><strong>控制器</strong>: <code>UserController.java</code> - 用户注册、登录、信息管理</li>\n<li><strong>服务层</strong>: <code>UserServiceImpl.java</code> - 用户业务逻辑</li>\n<li><strong>数据访问</strong>: <code>UserMapper.java</code> - 用户数据操作</li>\n<li><strong>安全认证</strong>: JWT Token认证机制</li>\n<li><strong>验证码</strong>: <code>CaptchaController.java</code> - 图形验证码生成</li>\n<li><strong>操作日志</strong>: <code>UserLogController.java</code> - 用户操作记录</li>\n</ul>\n<h3 id=\"前端实现-5\">前端实现</h3>\n<ul>\n<li><strong>登录页面</strong>: <code>src/views/login/index.vue</code></li>\n<li><strong>注册页面</strong>: <code>src/views/register/index.vue</code></li>\n<li><strong>用户中心</strong>: <code>src/views/user-center/index.vue</code></li>\n<li><strong>个人信息</strong>: <code>src/views/user-center/userInfo/index.vue</code></li>\n<li><strong>API接口</strong>: <code>src/apis/user.js</code></li>\n</ul>\n<h3 id=\"核心功能-5\">核心功能</h3>\n<ul>\n<li>用户注册（邮箱/手机号注册，验证码校验）</li>\n<li>用户登录（多种登录方式，安全验证）</li>\n<li>权限管理（三级角色：游客、普通管理员、高级管理员）</li>\n<li>个人信息管理（头像上传、信息修改）</li>\n<li>操作日志记录（完整的用户行为审计）</li>\n</ul>\n<p><img alt=\"PixPin_2026-01-29_11-46-36\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154652265-1633343549.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-45-51\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154710577-380625228.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-50-14\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154725969-1974806414.png\" /></p>\n<h2 id=\"其他功能页面\">其他功能页面</h2>\n<p><img alt=\"PixPin_2026-01-29_11-39-24\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154754018-535624975.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-45-00\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154808217-1694065437.png\" /></p>\n<p><img alt=\"PixPin_2026-01-29_11-45-23\" src=\"https://img2024.cnblogs.com/blog/3096011/202601/3096011-20260129154815394-1448938435.png\" /></p>\n<h2 id=\"系统架构与安全设计\">系统架构与安全设计</h2>\n<h3 id=\"前后端分离架构\">前后端分离架构</h3>\n<ul>\n<li><strong>API设计</strong>: RESTful风格接口，统一响应格式</li>\n<li><strong>跨域处理</strong>: CORS配置，支持多域名访问</li>\n<li><strong>错误处理</strong>: 统一的异常处理机制</li>\n<li><strong>接口文档</strong>: 完整的API接口定义</li>\n</ul>\n<h3 id=\"安全机制设计\">安全机制设计</h3>\n<ul>\n<li><strong>身份认证</strong>: JWT Token认证，防止未授权访问</li>\n<li><strong>数据安全</strong>: 敏感信息MD5加密存储</li>\n<li><strong>内容安全</strong>: 敏感词过滤系统，确保评论内容安全</li>\n<li><strong>操作审计</strong>: 完整的用户操作日志记录</li>\n<li><strong>验证码机制</strong>: 图形验证码防止暴力破解</li>\n</ul>\n<h3 id=\"性能优化策略\">性能优化策略</h3>\n<ul>\n<li><strong>缓存应用</strong>: Redis热点数据缓存，提升响应速度</li>\n<li><strong>数据库优化</strong>: 连接池配置、索引优化</li>\n<li><strong>文件存储</strong>: 阿里云OSS CDN加速，图片压缩处理</li>\n</ul>\n<h2 id=\"数据库设计\">数据库设计</h2>\n<h3 id=\"核心数据表\">核心数据表</h3>\n<h4 id=\"用户相关表\">用户相关表</h4>\n<ul>\n<li><strong>users</strong>: 用户基本信息（ID、用户名、密码、邮箱、手机号、角色、头像等）</li>\n<li><strong>user_logs</strong>: 用户操作日志记录</li>\n</ul>\n<h4 id=\"景区相关表\">景区相关表</h4>\n<ul>\n<li><strong>attractions</strong>: 景区基本信息（名称、描述、位置、状态、价格等）</li>\n<li><strong>attraction_images</strong>: 景区图片管理</li>\n<li><strong>attraction_opening_hours</strong>: 景区开放时间配置</li>\n</ul>\n<h4 id=\"订单相关表\">订单相关表</h4>\n<ul>\n<li><strong>orders</strong>: 订单主表（用户ID、总金额、状态、支付方式等）</li>\n<li><strong>order_items</strong>: 订单明细表（景点ID、数量、单价、参观日期等）</li>\n</ul>\n<h4 id=\"活动相关表\">活动相关表</h4>\n<ul>\n<li><strong>events</strong>: 活动信息（名称、描述、开始时间、结束时间、地点、参与人数等）</li>\n<li><strong>event_participants</strong>: 活动参与记录（活动ID、用户ID、参与状态等）</li>\n</ul>\n<h4 id=\"评论相关表\">评论相关表</h4>\n<ul>\n<li><strong>comments</strong>: 评论信息（用户ID、目标ID、类型、内容、评分、状态等）</li>\n</ul>\n<h4 id=\"系统管理表\">系统管理表</h4>\n<ul>\n<li><strong>error_logs</strong>: 系统错误日志</li>\n<li><strong>feedbacks</strong>: 用户反馈信息</li>\n</ul>\n<p><strong>如需源码，请加QQ：3616087835</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 16:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/iRuriCatt\">iRuriCatt</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI是资本的胜利-未来可能是资本的天下",
      "link": "https://www.cnblogs.com/ztfjs/p/19549290/aiagent",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ztfjs/p/19549290/aiagent\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 16:20\">\n    <span>AI是资本的胜利-未来可能是资本的天下</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2>序</h2>\n<p>——工程师正在自掘坟墓，或许转行外卖才是唯一选择，但资本+AI能够统治一切。</p>\n<p>工业革命（蒸汽机）与 AI 革命最核心的本质差异—— 前者是动力赋能下的人力规模放大，后者是智力替代下的人力价值消解，资本对 AI 的终极诉求并非 “提升人力效率”，而是彻底重构生产要素，让 “人” 从核心创造者沦为边缘监督者，将劳动的价值锚点从人转移到机器、算力、模型这些资本可完全掌控的生产资料上。 ————这是资本的胜利。本文仅讨论AI对资本的实质，并不过多描述AI对人类发展的进步意义。</p>\n<h2>蒸汽机时代-动力赋能下的人力价值放大</h2>\n<p>蒸汽机的诞生，标志着人类从手工劳动迈入机器生产时代，但它自始至终都未曾动摇“人”作为生产核心的地位。其本质是用无生命的动力源，替代了人的体力劳动，却进一步放大了对掌握技能的人力的需求，形成了“机器赋能人、人驱动生产”的共生关系。 在蒸汽机普及前，纺织、采矿、运输等行业依赖人工劳作，生产效率受限于人的体力极限，规模扩张极为缓慢。蒸汽机的出现，打破了这一桎梏——一台蒸汽织布机的效率远超十名熟练织工，一台蒸汽机车的运力抵得上数十辆马车。但这种效率提升，并未导致人力需求的缩减，反而催生了更大规模的人力缺口。一方面，蒸汽机本身需要专业工人操作、调试、维护，原本的手工劳动者通过技能升级，转变为机器操作工，依然是生产流程中不可或缺的一环；另一方面，生产规模的爆发式增长，带动了上下游产业链的扩张，需要更多工人参与原料开采、产品加工、仓储运输、车间管理等环节。</p>\n<p>更关键的是，蒸汽机时代的价值创造锚点始终是人。机器是资本投入的生产资料，但没有工人的操控与技能输出，机器只是一堆无价值的钢铁。资本想要赚取更多利润，就必须雇佣更多工人、提升工人的技能水平，人力劳动依然是价值公式中的核心变量。此时的资本与工人，是“利益共生”关系——资本通过机器放大工人的劳动价值，工人通过依附资本的生产资料获得生存报酬，人在生产中的核心地位不可替代。</p>\n<h2>从AI辅助编程到AI自主编程：人的经验被数字概率替代</h2>\n<p>AI演进路径，我觉得从根源上背离了“工具赋能人”的传统逻辑,现阶段接触到的所有AI，例如manus、claude code、midjourney等不同领域的AI，它们被赋予的终极目标是用“数字概率”替代“人的经验”、”人的美感”、”人的一切脑力价值”，让机器接管最核心的智力劳动。从编程上看，从早期的代码补全工具，到如今能基于自然语言需求生成完整项目代码、自主排查Bug、优化程序性能的AI模型，AI正在逐步消解人们赖以生存的核心价值————经验积累与逻辑思考。 在传统编程模式中，程序员的核心竞争力源于长期实践积累的经验：对编程语言的熟练运用、对业务逻辑的深度理解、对复杂问题的排查能力、对系统架构的设计思维。这些经验是个性化的、不可复制的，是程序员在劳动力市场中议价的核心资本。但AI Coding的底层逻辑，是通过学习海量开源代码与技术文档，将人类的编程经验转化为数字概率模型——AI生成代码的过程，并非“思考”，而是基于数据训练形成的概率预测，它能快速输出符合语法、逻辑通顺的代码，却无需理解代码背后的业务本质与技术原理。</p>\n<p>这种替代带来的直接后果，是人的经验价值急剧缩水。当一名资深程序员花费数年积累的业务逻辑处理经验，能被AI通过数据训练在几小时内复刻；当程序员熬夜调试的Bug，AI能在几秒内定位并修复，人类的经验便不再是稀缺资源。资本无需再为程序员的经验积累支付高额薪酬，只需投入算力与模型训练成本，就能获得源源不断的“数字劳动力”，而程序员的工作，也从“创造性劳动”沦为“对AI生成结果的监督与修正”，经验的溢价空间被彻底压缩。</p>\n<h2>应届生的价值急剧下降：入门门槛与生存空间被双重挤压</h2>\n<p>在AI的冲击下，软件开发行业的人才结构正在发生剧烈重构，应届生成为受影响最直接、最深刻的群体，其劳动力价值急剧下降，入门与生存空间被双重挤压。传统编程行业中，应届生是“潜力股”——资本愿意投入成本培养应届生，让其从基础编码工作做起，逐步积累经验、成长为核心人才，应届生的“可培养性”是其核心价值所在。但AI Coding的普及，直接剥夺了应届生赖以成长的基础岗位与实践机会。 一方面，AI完全替代了应届生最擅长的基础编码工作。过去，应届生通过编写CRUD接口、简单业务逻辑代码、参与单元测试等基础工作积累经验，但如今这些工作已能被AI高效完成，且准确率与效率远超应届生。资本不再需要雇佣应届生从事基础开发，原本的入门岗位大幅缩减，应届生面临“无工可做”的困境。另一方面，行业对人才的需求标准发生扭曲，从“注重潜力与学习能力”转向“注重AI工具操控能力与代码审核效率”。部分企业更愿意雇佣能快速上手AI工具、高效审核AI生成代码的“熟练工”，而非需要花费时间培养、且效率不及AI的应届生。</p>\n<p>更残酷的是，应届生失去了“经验积累的阶梯”。没有基础编码的实践，应届生难以理解复杂系统的架构逻辑与业务底层原理，即便掌握了AI工具的使用，也只能停留在“监督者”的层面，无法成长为具备核心竞争力的高级人才。最终，应届生的价值被压缩到最低，要么接受低薪的“AI辅助岗”，要么被行业淘汰，资本则以极低的成本获得了“可替代的监督劳动力”。</p>\n<h2>智力资源普及廉价：资本掌控下的价值贬值</h2>\n<p>软件开发是典型的智力密集型行业，智力资源曾是少数人拥有的稀缺资源，也是程序员议价权的核心。但AI Coding的出现，让原本稀缺的智力资源变得“普及且廉价”，而这一切的主导者与受益者，正是资本。资本通过掌控AI模型与算力，将人类的智力成果转化为可复制、可批量输出的“数字商品”，彻底打破了智力资源的稀缺性。 在AI出现前，一名程序员的智力输出具有排他性——其编写的代码、设计的架构，只能为雇佣他的企业创造价值，资本想要获得更多智力资源，就必须雇佣更多程序员。但AI模型通过学习海量开源代码与技术文档，整合了全球程序员的智力成果，资本只需投入一次模型训练成本，就能无限次输出智力成果，且边际成本趋近于零。原本需要数十名程序员花费数月完成的项目，如今通过AI Coding工具，几名“监督者”就能在几周内完成，智力资源的使用效率被资本以“规模化复制”的方式拉满。</p>\n<p>同时，智力资源的价值被资本重新定义。过去，程序员的智力劳动直接转化为产品价值，薪酬与价值挂钩；如今，AI成为智力成果的“输出者”，程序员的智力劳动只是AI训练数据的一部分，其价值被稀释到海量数据中，无法单独量化。资本无需为个体的智力劳动支付高额报酬，只需支付少量“数据贡献费”（甚至无需支付，引发诸多知识产权争议），就能掌控海量智力资源，原本稀缺的智力资源，在资本的操作下变得廉价且可随意取用。</p>\n<h2>结合机器人：概率数字能够替代的人力范围扩大</h2>\n<p>AI Coding的价值替代，并非局限于软件开发行业。当AI的“概率数字决策”与机器人技术相结合，资本能够替代的人力范围将实现跨领域扩张，从智力劳动延伸到体力劳动与服务劳动，进一步巩固资本对生产要素的掌控权。AI提供“大脑决策”，机器人提供“肢体执行”，二者结合形成的“数字劳动力体系”，正在逐步替代人类在各行业的劳动角色。 在工业领域，传统机器人需要预设程序才能运行，灵活性与适应性极差，无法应对复杂场景。但结合AI的概率决策能力后，机器人能通过实时数据分析，自主调整操作流程、应对突发状况——比如AI驱动的工业机器人，能自主识别零件缺陷、优化装配路径，无需人类干预就能完成复杂生产任务，替代了原本需要熟练技工与程序员协同完成的工作。在服务领域，AI驱动的服务机器人能通过自然语言处理理解用户需求，结合场景数据做出概率决策，提供客服、导购、护理等服务，替代了大量基础服务岗位。</p>\n<p>这种跨领域替代的核心，依然是资本对生产要素的重构。AI的概率数字模型与机器人，都是资本可完全掌控的生产资料，资本无需再依赖不同行业的熟练劳动力，只需通过升级AI模型与机器人硬件，就能实现跨行业布局与人力替代。原本分散在各行业的劳动力价值，被统一锚定到资本掌控的“数字劳动力体系”中，人类的劳动范围被进一步压缩，资本的统治边界则持续扩大。</p>\n<h2>未来可能是资本的天下</h2>\n<p>当AI Coding重构了智力劳动的价值逻辑，当机器人技术扩大了人力替代的范围，当资本完全掌控了模型、算力、机器人这些核心生产资料，未来的社会生产格局，大概率将是资本的天下。资本通过掌控“数字劳动力体系”，实现了对价值创造的绝对主导，人在生产中的地位被边缘化，劳动的价值被彻底转移到资本的生产资料中。 从经济逻辑来看，资本的边际成本将持续降低，而人力的边际价值将持续缩水。资本只需一次性投入模型训练、算力搭建与机器人研发成本，就能获得无限期的价值输出；而人类劳动则面临“可替代性强、议价权弱”的困境，无论是程序员、技工还是服务人员，都只能在资本掌控的生产体系中，从事低价值的监督、维护工作，薪酬水平被资本牢牢压制。从垄断格局来看，掌握核心AI模型与算力资源的资本，将形成难以打破的行业垄断——新企业想要进入市场，必须投入巨额成本搭建AI与算力基础设施，而巨头资本通过规模效应与数据壁垒，能轻松挤压新竞争者，形成“资本越集中、垄断越强；垄断越强，资本越集中”的循环。</p>\n<p>这种格局下，资本不再是“服务于生产的媒介”，而是“生产的绝对主导者”，人类劳动从“价值创造的核心”沦为“资本生产资料的附属”。AI Coding的普及，只是资本掌控生产要素、巩固统治地位的第一步，当技术持续迭代，资本将彻底掌控价值创造的全链条，成为未来社会的绝对主导力量——这，便是资本通过AI革命赢得的终极胜利。</p>\n\n</div>\n<div id=\"MySignature\">\n    ========================================================\n转载请注明出处。\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 16:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ztfjs\">张泰峰</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "stable_baseline3 快速入门(一): 训练第一个强化学习模型",
      "link": "https://www.cnblogs.com/ClownLMe/p/19549111",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19549111\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 16:01\">\n    <span>stable_baseline3 快速入门(一): 训练第一个强化学习模型</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简介\">简介</h1>\n<p><strong>stable_baseline3</strong> 是一个基于 PyTorch 的强化学习算法开源库，里面集成了多种强化学习算法，使用这个开源库能够让我们不需要过度关注强化学习算法细节，专注于AI业务的开发。</p>\n<h1 id=\"环境配置\">环境配置</h1>\n<pre><code class=\"language-bash\">pip install stable-baselines3\npip install gymnasium\n</code></pre>\n<p>这里<code>stable-baselines3</code>会默认安装<code>pytroch</code>框架，但是是不带<code>cuda</code>版本的，这就意味着我们无法利用我们的显卡对模型进行训练。<br />\n下载<code>cuda</code>版本的<code>pytroch</code>步骤如下：</p>\n<ol>\n<li>卸载原来版本的<code>pytroch</code>框架</li>\n</ol>\n<pre><code class=\"language-bash\">pip uninstall torch torchvision torchaudio -y\n#这个是针对RTX 30/40/50显卡的。\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu126\n</code></pre>\n<p>如果其他版本请参考官网： <a href=\"https://pytorch.org/get-started/locally/\" rel=\"noopener nofollow\" target=\"_blank\">https://pytorch.org/get-started/locally/</a></p>\n<h1 id=\"认识stable_baseline3\">认识stable_baseline3</h1>\n<p><code>stable_baseline3</code>提供了许多模型，如下列表：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>动作空间</th>\n<th>建议应用场景</th>\n<th>核心优势</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>PPO</strong></td>\n<td>连续 &amp; 离散</td>\n<td><strong>全能选手</strong>，如机器人走动、金融交易、游戏 AI</td>\n<td>极其稳定，对超参数不敏感，支持大规模并行训练。</td>\n</tr>\n<tr>\n<td><strong>DQN</strong></td>\n<td>仅离散</td>\n<td>经典游戏（Atari）、开关控制、迷宫寻路</td>\n<td>理解简单，在离散控制领域非常经典且有效。</td>\n</tr>\n<tr>\n<td><strong>SAC</strong></td>\n<td>仅连续</td>\n<td>复杂物理模拟、机械臂抓取、自动驾驶</td>\n<td>探索效率极高，能自动寻找最优路径且不轻易陷入局部最优。</td>\n</tr>\n<tr>\n<td><strong>TD3</strong></td>\n<td>仅连续</td>\n<td>工业控制、无人机飞行、精密动作</td>\n<td>针对 DDPG 的缺陷做了改进，训练过程比 SAC 更平滑。</td>\n</tr>\n<tr>\n<td><strong>A2C</strong></td>\n<td>连续 &amp; 离散</td>\n<td>简单逻辑测试、快速原型验证</td>\n<td>结构简单，虽然不如 PPO 稳定，但在特定并行环境下速度极快。</td>\n</tr>\n</tbody>\n</table>\n<p>在<strong>声明模型</strong>中，可以设置多种参数，这里列出常用的：<br />\n目前不需要搞懂都有什么作用，后面有文章会详细讲解</p>\n<ol>\n<li>训练参数</li>\n</ol>\n<ul>\n<li><code>learning_rate</code>：学习率</li>\n<li><code>gamma</code>：折扣因子</li>\n<li><code>batch_size</code>：更新模型使用数据量</li>\n<li><code>verbose</code>：打印信息模式。0-静默模式，1-信息模式，2-调试模式</li>\n<li><code>device</code>：指定训练设备<code>cuda</code>使用显卡，<code>cpu</code>使用cpu</li>\n</ul>\n<ol start=\"2\">\n<li>模型规则</li>\n</ol>\n<ul>\n<li><code>MlpPolicy</code>：多层感知机。适用于状态是数值场景（传感器等）</li>\n<li><code>CnnPolicy</code>：卷积神经网络。适用于状态是图像场景（游戏等）</li>\n</ul>\n<h1 id=\"训练第一个强化学习模型\">训练第一个强化学习模型</h1>\n<h3 id=\"案例\">案例</h3>\n<p>案例描述：训练一个<code>gymnasium</code>默认提供的游戏环境，平衡杆游戏。</p>\n<pre><code class=\"language-python\">import gymnasium as gym\nfrom stable_baselines3 import PPO\n\nenv = gym.make(\"CartPole-v1\")\n\nmodel = PPO(\"MlpPolicy\", env, verbose=1, device=\"cuda\")\n\nprint(\"开始训练...\")\nmodel.learn(total_timesteps=10000)\n\nprint(\"正在保存模型...\")\nmodel.save(\"ppo_cartpole\")\n\nprint(\"正在读取模型...\")\nenv = gym.make(\"CartPole-v1\", render_mode=\"human\")\nloaded_model = PPO.load(\"ppo_cartpole\", env=env)\n\nprint(\"训练结束，开始演示...\")\nobs, _ = env.reset()\nfor i in range(1000):\n    action, _states = loaded_model.predict(obs, deterministic=True)\n\n    obs, reward, terminated, truncated, info = env.step(action)\n    \n    if terminated or truncated:\n        obs, _ = env.reset()\n\nenv.close()\n</code></pre>\n<h3 id=\"代码解释\">代码解释</h3>\n<p>代码流程如下：<br />\n<strong>初始化环境模型-&gt;训练模型-&gt;保存模型-&gt;加载模型-&gt;模型预测</strong></p>\n<h5 id=\"初始化环境模型\">初始化环境模型</h5>\n<p>初始化模型以及游戏的环境</p>\n<pre><code class=\"language-python\">env = gym.make(\"CartPole-v1\")\nmodel = PPO(\"MlpPolicy\", env, verbose=1, device=\"cuda\")\n\nenv = gym.make(\"CartPole-v1\", render_mode=\"human\")\n</code></pre>\n<ul>\n<li><code>gym</code>中的<code>make</code>方法利用默认的游戏环境，<code>CartPole-v1</code>是游戏名，下面有一个<code>render_mode=\"human\"</code>参数，用于标识是否展示画面。训练时展示画面会降低训练的速度，一般在预测时才使用</li>\n</ul>\n<h5 id=\"训练模型\">训练模型</h5>\n<pre><code class=\"language-python\">model.learn(total_timesteps=10000)\n</code></pre>\n<ul>\n<li><code>total_timesteps</code>：训练10000次</li>\n</ul>\n<h5 id=\"保存模型\">保存模型</h5>\n<pre><code class=\"language-python\">model.save(\"ppo_cartpole\")\n</code></pre>\n<ul>\n<li><code>\"ppo_cartpole\"</code> 为保存模型的名字，这里是保存在当前文件夹中。</li>\n</ul>\n<h5 id=\"加载模型\">加载模型</h5>\n<pre><code class=\"language-python\">loaded_model = PPO.load(\"ppo_cartpole\", env=env)\n</code></pre>\n<ul>\n<li>第一个参数：刚刚保存的模型路径</li>\n<li>第二个参数：训练的环境</li>\n</ul>\n<h5 id=\"模型预测\">模型预测</h5>\n<pre><code class=\"language-python\">obs, _ = env.reset()\nfor i in range(1000):\n    action, _states = loaded_model.predict(obs, deterministic=True)\n\n    obs, reward, terminated, truncated, info = env.step(action)\n    \n    if terminated or truncated:\n        obs, _ = env.reset()\n</code></pre>\n<ul>\n<li><code>env.reset()</code>重置环境，返回初始观测值<code>obs</code>和<code>info</code>(这里没用到)</li>\n<li>模型的<code>predict</code>方法用于根据观测值<code>obs</code>预测下一步行动。<strong>注意：deterministic参数要为True，不然会报错</strong></li>\n<li>模型的<code>step</code>方法根据行动值返回结果。（这些都是什么后面文章会讲）</li>\n</ul>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 16:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Python 高效实现 Excel 转 TXT 文本",
      "link": "https://www.cnblogs.com/jazz-z/p/19547652",
      "published": "",
      "description": "<div class=\"postcontent\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在数据处理场景中，将Excel文件转换为纯文本（TXT）格式便成为了一个常见的需求。传统的手动复制粘贴，不仅效率低下，更容易因格式不兼容、数据量庞大而引发错误。本文将解析如何通过 Spire.XLS for Python 实现 Excel 转 TXT 的高效、无依赖操作，提升数据处理效率和灵活性。</p>\n<blockquote>\n<p>安装指令：<code>pip install spire.xls​​</code><br />\n免费版：<code>​​pip install spire.xls.free​​ </code></p>\n</blockquote>\n<h2 id=\"基础示例单工作表-excel-转-txt\">基础示例：单工作表 Excel 转 TXT</h2>\n<p>以下是将一个 Excel 文件中的第一个工作表转换为 TXT 的完整步骤：</p>\n<h3 id=\"1-加载并读取excel文件\">1. 加载并读取Excel文件</h3>\n<pre><code class=\"language-python\">from spire.xls import *\nfrom spire.xls.common import *\n\nworkbook = Workbook()\nworkbook.LoadFromFile(\"示例.xlsx\")\n</code></pre>\n<h3 id=\"2-执行转换并保存\">2. 执行转换并保存</h3>\n<pre><code class=\"language-python\">sheet = workbook.Worksheets[0]\nsheet.SaveToFile(\"output.txt\", \"\\t\", Encoding.get_UTF8())\n</code></pre>\n<h3 id=\"参数说明\">参数说明</h3>\n<table>\n<thead>\n<tr>\n<th>参数类型</th>\n<th>示例值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>分隔符</td>\n<td><code>\\t</code> (制表符)</td>\n<td>定义 TXT 文件中各列数据之间的分隔方式，也可使用逗号 <code>,</code>、分号 <code>;</code> 等。</td>\n</tr>\n<tr>\n<td>编码方式</td>\n<td><code>Encoding.get_UTF8()</code>（国际通用编码）</td>\n<td>指定文本文件的编码格式，推荐使用 <code>UTF-8</code> 以保证中文等字符正常显示。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"进阶处理多工作表分别导出为-txt\">进阶处理：多工作表分别导出为 TXT</h2>\n<p>如果你的 Excel 文件包含多个工作表，并且希望将每个工作表保存为单独的 TXT 文件，可以使用以下代码：</p>\n<pre><code class=\"language-python\">from spire.xls import *\nfrom spire.xls.common import *\n\ndef excel_sheets_to_txt(input_file, output_folder, delimiter=\"\\t\"):\n  \n    # 创建Workbook对象\n    workbook = Workbook()\n    # 加载Excel文件\n    workbook.LoadFromFile(input_file)\n        \n    # 遍历所有工作表\n    for i in range(workbook.Worksheets.Count):\n        sheet = workbook.Worksheets[i]\n            \n        # 构建输出文件路径\n        output_file = f\"sheet_{i+1}_{sheet.Name}.txt\"\n        output_path = os.path.join(output_folder, output_file)\n            \n        # 将工作表内容保存为TXT文件\n        sheet.SaveToFile(output_path, delimiter, Encoding.get_UTF8())\n</code></pre>\n<h2 id=\"excel-转-txt-在自动化流程中的应用\">Excel 转 TXT 在自动化流程中的应用</h2>\n<p>将 Excel 转换为 TXT 不仅是格式的简单转换，更是实现数据自动化流程的重要环节。结合 Spire.XLS for Python，可轻松构建以下应用：</p>\n<ul>\n<li><strong>自动化报告生成</strong>： 从 Excel 模板中提取数据，生成纯文本格式的报告摘要，方便邮件发送或系统集成。</li>\n<li><strong>数据清洗与预处理</strong>： 将复杂格式的 Excel 数据转换为 TXT，作为其他数据分析工具（如Spark、Hadoop）的输入源，进行更深层次的处理。</li>\n<li><strong>配置管理</strong>： 将 Excel 中维护的系统配置、参数表等导出为 TXT 格式，便于脚本直接读取，同时更适合使用 Git 等工具进行版本管理。</li>\n</ul>\n<hr />\n<p>通过以上方法与示例，您可以快速掌握使用 Python 实现 Excel 到 TXT 的高效转换。该方案不仅提升了数据导出效率，也为后续的数据集成与自动化处理奠定了可靠基础。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"itemdesc\">\n                发表于 \n<span id=\"post-date\">2026-01-29 12:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jazz-z\">LAYONTHEGROUND</a>&nbsp;\n阅读(<span id=\"post_view_count\">43</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n            </div>"
    },
    {
      "title": "前端倒计时活动，为什么不推荐直接用 setTimeout / setInterval？",
      "link": "https://www.cnblogs.com/zxlh1529/p/19545350",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zxlh1529/p/19545350\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 11:44\">\n    <span>前端倒计时活动，为什么不推荐直接用 setTimeout / setInterval？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在商城项目中，「倒计时活动」几乎是绕不开的需求：<br />\n秒杀、限时优惠、拼团、支付剩余时间……</p>\n<p>我相信很多都跟我一样一开始写出类似这样的代码：</p>\n<pre><code class=\"language-js\">setInterval(() =&gt; {\n  remainTime--\n}, 1000)\n</code></pre>\n<h2 id=\"功能能跑但线上问题也会跟着跑出来\"><strong>功能能跑，但线上问题也会跟着跑出来。</strong></h2>\n<h2 id=\"一为什么-settimeout--setinterval-不适合活动倒计时\">一、为什么 setTimeout / setInterval 不适合活动倒计时？</h2>\n<h3 id=\"它们天生就不准\">它们天生就不准</h3>\n<p>很多人对定时器有一个误解：</p>\n<blockquote>\n<p><code>setInterval(fn, 1000)</code> ≠ 每 1000ms 准时执行</p>\n</blockquote>\n<p>原因只有一个：<br />\n<strong>JavaScript 是单线程的。</strong></p>\n<p>到这你先回想一下事件循环机制，有哪些？然后再往下看；如果实在想不起来就先上网搜下，或者看看我的<a href=\"https://www.cnblogs.com/zxlh1529/p/18829778\" target=\"_blank\">单线程原理</a>。</p>\n<ul>\n<li>事件循环机制</li>\n<li>主线程被渲染卡住</li>\n<li>执行大量 JS</li>\n<li>GC、布局、重绘</li>\n</ul>\n<p>都会导致定时器回调被<strong>延后执行</strong>。</p>\n<p>倒计时的表现就是：</p>\n<ul>\n<li>跳秒</li>\n<li>变慢</li>\n<li>和真实时间对不上</li>\n</ul>\n<hr />\n<h3 id=\"浏览器会故意降级定时器\">浏览器会「故意」降级定时器</h3>\n<p>这是活动倒计时最容易翻车的一点。</p>\n<p>当页面进入以下状态：</p>\n<ul>\n<li>后台 Tab</li>\n<li>页面最小化</li>\n<li>手机锁屏</li>\n</ul>\n<p>浏览器会主动做这些事：</p>\n<ul>\n<li>延长定时器触发间隔</li>\n<li>甚至直接暂停执行</li>\n</ul>\n<p>结果就是：</p>\n<blockquote>\n<p>用户切个 Tab 回来，<br />\n倒计时还显示 10 秒，<br />\n实际活动已经结束。</p>\n</blockquote>\n<p><strong>对活动类业务，这是不能接受的。</strong></p>\n<hr />\n<h3 id=\"settimeout-递归本质问题没变\">setTimeout 递归，本质问题没变</h3>\n<p>可能有的会写成这样：</p>\n<pre><code class=\"language-js\">function tick() {\n  setTimeout(() =&gt; {\n    remainTime--\n    tick()\n  }, 1000)\n}\n</code></pre>\n<p>看起来比 <code>setInterval</code> 稳一点，但实际上：</p>\n<ul>\n<li>依然受线程影响</li>\n<li>依然受浏览器限流</li>\n<li>依然不可靠</li>\n</ul>\n<p>只是“写法高级了”，问题没解决。</p>\n<hr />\n<h2 id=\"二倒计时的核心思路必须反过来\">二、倒计时的核心思路必须反过来</h2>\n<h3 id=\"错误思路很多第一版代码\">错误思路（很多第一版代码）</h3>\n<blockquote>\n<p>“我现在有 60 秒，每秒减 1”</p>\n</blockquote>\n<h3 id=\"正确思路真实业务\">正确思路（真实业务）</h3>\n<blockquote>\n<p>“活动有一个<strong>确定的结束时间点</strong>，我只计算<strong>当前时间与结束时间的差值</strong>”</p>\n</blockquote>\n<hr />\n<h3 id=\"正确的倒计时模型\">正确的倒计时模型</h3>\n<ol>\n<li>后端返回活动结束时间戳（<code>endTime</code>）</li>\n<li>前端永远不存“剩余秒数”</li>\n<li>每次渲染时：</li>\n</ol>\n<pre><code class=\"language-js\">const remain = endTime - Date.now()\n</code></pre>\n<blockquote>\n<p>前提是： <code>Date.now()</code> 是可信的</p>\n</blockquote>\n<p>这样做的好处是：</p>\n<ul>\n<li>页面卡顿不影响</li>\n<li>切 Tab 不影响</li>\n<li>页面刷新不影响</li>\n<li>时间一定是真实世界的时间</li>\n</ul>\n<hr />\n<h2 id=\"三requestanimationframe-在倒计时里的正确用法\">三、requestAnimationFrame 在倒计时里的正确用法</h2>\n<p>那么有的就得来犟一下：</p>\n<blockquote>\n<p>那是不是可以用 requestAnimationFrame？</p>\n</blockquote>\n<h3 id=\"nonono是这样的\">nonono，是这样的</h3>\n<blockquote>\n<p><strong>requestAnimationFrame 适合“展示型倒计时”，不适合直接当计时器。</strong></p>\n</blockquote>\n<hr />\n<h3 id=\"为什么-raf-比-setinterval-好一点\">为什么 rAF 比 setInterval 好一点？</h3>\n<ul>\n<li>跟随浏览器刷新节奏（通常 60fps）</li>\n<li>页面不可见时自动暂停（省性能）</li>\n<li>不会出现多个定时器竞争</li>\n</ul>\n<p>但它的问题也很明显：</p>\n<ul>\n<li>后台直接停</li>\n<li>不保证时间间隔</li>\n<li>本质还是“帧驱动”，不是“时间驱动”</li>\n</ul>\n<hr />\n<h3 id=\"正确用法raf--时间戳差值\">正确用法：rAF + 时间戳差值</h3>\n<pre><code class=\"language-js\">function startCountdown(endTime, update) {\n  function loop() {\n    const remain = endTime - Date.now()\n\n    if (remain &lt;= 0) {\n      update(0)\n      return\n    }\n\n    update(remain)\n    requestAnimationFrame(loop)\n  }\n\n  loop()\n}\n</code></pre>\n<ol>\n<li>rAF 只负责触发更新</li>\n<li>时间完全由 <code>Date.now()</code> 决定</li>\n<li>不用 rAF 去「数秒」</li>\n</ol>\n<p>这种方式非常适合：</p>\n<ul>\n<li>大屏倒计时</li>\n<li>动画数字变化</li>\n<li>强 UI 表现的倒计时</li>\n</ul>\n<hr />\n<h2 id=\"四真实业务里的性能坑\">四、真实业务里的性能坑</h2>\n<h3 id=\"多个倒计时--多个定时器\">多个倒计时 = 多个定时器</h3>\n<p>列表页如果有 20 个活动：</p>\n<ul>\n<li>20 个 <code>setInterval</code></li>\n<li>页面性能直线下降</li>\n</ul>\n<h3 id=\"组件卸载忘记清理\">组件卸载忘记清理</h3>\n<ul>\n<li>内存泄漏</li>\n<li>幽灵定时器</li>\n<li>难以排查的线上问题</li>\n</ul>\n<h3 id=\"前后端时间不同步\">前后端时间不同步</h3>\n<ul>\n<li>前端显示没结束</li>\n<li>后端接口已判定结束</li>\n<li>用户点击直接报错</li>\n</ul>\n<hr />\n<h2 id=\"五重点来了第三方方案怎么选\">五、重点来了：第三方方案怎么选？</h2>\n<h3 id=\"dayjs--date-fns强烈推荐\">dayjs / date-fns（强烈推荐）</h3>\n<p>它们<strong>不是倒计时库</strong>，但非常适合做倒计时。</p>\n<p>示例（dayjs）：</p>\n<pre><code class=\"language-js\">import dayjs from 'dayjs'\n\nconst endTime = dayjs('2026-01-30 20:00:00')\n\nsetInterval(() =&gt; {\n  const diff = endTime.diff(dayjs(), 'second')\n  console.log(diff &gt; 0 ? diff : 0)\n}, 1000)\n</code></pre>\n<ol>\n<li>时间计算可靠</li>\n<li>不依赖定时器精度</li>\n<li>和后端时间模型一致</li>\n</ol>\n<p><strong>这是我线上最常用的方案之一。</strong></p>\n<hr />\n<h3 id=\"自己封装一个全局时间驱动器\">自己封装一个「全局时间驱动器」</h3>\n<p>这是很多成熟项目最终都会走到的一步。</p>\n<p>核心思想：</p>\n<ul>\n<li>全局只存在一个 timer / rAF</li>\n<li>所有倒计时组件订阅它</li>\n<li>统一调度、统一销毁</li>\n</ul>\n<p>简单示意：</p>\n<pre><code class=\"language-js\">const listeners = new Set()\n\nsetInterval(() =&gt; {\n  const now = Date.now()\n  listeners.forEach(fn =&gt; fn(now))\n}, 1000)\n\nexport function subscribe(fn) {\n  listeners.add(fn)\n  return () =&gt; listeners.delete(fn)\n}\n</code></pre>\n<p>组件只关心：</p>\n<pre><code class=\"language-js\">subscribe(now =&gt; {\n  remain.value = endTime - now\n})\n</code></pre>\n<ol>\n<li>性能稳定</li>\n<li>行为一致</li>\n<li>易维护</li>\n</ol>\n<hr />\n<h3 id=\"ui-倒计时组件慎用\">UI 倒计时组件（慎用）</h3>\n<p>很多组件库提供：</p>\n<ul>\n<li><code>&lt;Countdown /&gt;</code></li>\n<li><code>&lt;Timer /&gt;</code></li>\n</ul>\n<p>适合：</p>\n<ul>\n<li>展示</li>\n<li>Demo</li>\n<li>非关键业务</li>\n</ul>\n<p>不适合：</p>\n<ul>\n<li>活动判定</li>\n<li>支付</li>\n<li>风控相关逻辑</li>\n</ul>\n<p><strong>展示可以用，业务别依赖。</strong></p>\n<hr />\n<h2 id=\"六so\">六、SO</h2>\n<blockquote>\n<p><strong>倒计时不是在“数秒”，而是点对点的时间差。</strong></p>\n</blockquote>\n<ul>\n<li><code>setTimeout / setInterval</code><br />\n只能当“触发器”</li>\n<li><code>requestAnimationFrame</code><br />\n只负责“渲染节奏”</li>\n<li>真正的时间<br />\n永远来自<strong>时间戳差值</strong></li>\n</ul>\n<p>如果一个倒计时：</p>\n<ul>\n<li>切 Tab 就不准</li>\n<li>刷新就重置</li>\n<li>和后端状态对不上</li>\n</ul>\n<p>那它<strong>大概率不是 UI 问题，而是时间模型错了。</strong></p>\n<p>再记住三个原则：</p>\n<ol>\n<li>前端时间永远不能当权威</li>\n<li>用「服务端时间差」而不是本地时间（服务端多分布只允许一个地方定义）</li>\n<li>关键状态以接口返回为准</li>\n</ol>\n<p>为什么说这三个，大家可以好好思考下，评论区欢迎大家讨论！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 11:44</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zxlh1529\">幼儿园技术家</a>&nbsp;\n阅读(<span id=\"post_view_count\">84</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "istio初探以及解决http-426的问题",
      "link": "https://www.cnblogs.com/MrVolleyball/p/19547269",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/MrVolleyball/p/19547269\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 11:19\">\n    <span>istio初探以及解决http-426的问题</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>在之前的文章中，我们花了大量的篇幅，从记录后端pod真实ip开始说起，然后引入envoy，再解决了各种各样的需求：配置自动重载、流量劫持、sidecar自动注入，到envoy的各种能力：熔断、流控、分流、透明代理、可观测性等等，已经可以支撑起一个完整的服务治理框架了</p>\n<p>而今天介绍的istio，正是前面提到的这些所有功能的集大成者，从本文开始，我们将详细介绍istio，并且与之前手搓的功能做一个详细的对比，为大家以后选择服务治理的某个功能提供参考</p>\n<h2 id=\"istio架构\">istio架构</h2>\n<pre><code>           ┌──────────────┐\n           │   istiod     │   ← 控制面\n           │ (Pilot+CA)   │\n           └──────┬───────┘\n                  │ xDS (gRPC / TLS)\n                  │\n┌────────────┐    │    ┌────────────┐\n│  Envoy     │◄───┼───►│   Envoy    │  ← 数据面\n│ (Sidecar)  │         │ (Sidecar)  │\n└─────▲──────┘         └─────▲──────┘\n      │ iptables             │\n      │                      │\n   App Pod                App Pod\n\n</code></pre>\n<ul>\n<li>数据面就是之前一直在研究的envoy，包括4/7代理、熔断、限流、可观测性等等，envoy就是执行由控制面下发的配置</li>\n<li>控制面istiod主要的职责：将配置下发到每一个envoy去。由于istio中配置以crd的形式成为了k8s的资源，所以要不断的监听k8s apiserver，将资源的变化翻译成envoy看得懂的配置，并且下发到envoy去</li>\n</ul>\n<p>至于其余istio的资源，我们后面详细介绍</p>\n<h2 id=\"istio安装\">istio安装</h2>\n<p>不说废话，先把istio安装上去再说</p>\n<p>首先准备好k8s集群，其次下载istio（这一步有可能需要上网）</p>\n<pre><code>curl -L https://istio.io/downloadIstio | sh -\ncd istio-*\nsudo ln -s $PWD/istioctl /usr/local/bin/istioctl\n</code></pre>\n<p>验证兼容性</p>\n<pre><code>istioctl x precheck\n</code></pre>\n<p>开始安装</p>\n<pre><code>istioctl install --set profile=default -y\n</code></pre>\n<p>由于镜像仓库没法直接使用，所以需要一些特殊的方法，具体可以看这篇文章： <a href=\"https://mp.weixin.qq.com/s/Vwesi9_8ThdODfkMi1033Q\" rel=\"noopener nofollow\" target=\"_blank\">快速拉取docker镜像</a></p>\n<p>需要的镜像有：</p>\n<pre><code>docker.io/istio/pilot:1.28.2\ndocker.io/istio/proxyv2:1.28.2\n</code></pre>\n<p>安装完成：</p>\n<pre><code>▶ kubectl -n istio-system get pod\nNAME                                    READY   STATUS    RESTARTS   AGE\nistio-ingressgateway-865c448856-qs8s2   1/1     Running   0          8s\nistiod-86c75775bb-j7qbg                 1/1     Running   0          12s\n\n</code></pre>\n<p>安装完成，要从哪儿开始呢？</p>\n<h2 id=\"istio的自动注入\">istio的自动注入</h2>\n<pre><code>kubectl label namespace default istio-injection=enabled\n</code></pre>\n<p>同之前envoy一样，给namespace打上标签之后，重启服务即可</p>\n<pre><code>kubectl rollout restart deploy nginx-test\n</code></pre>\n<p>重启之后sidecar已经注入进去了，我们来观察一下istio注入到底做了什么事情</p>\n<p>先describe看看events</p>\n<pre><code>Events:\n  Type    Reason     Age   From               Message\n  ----    ------     ----  ----               -------\n  Normal  Scheduled  8s    default-scheduler  Successfully assigned default/nginx-test-6f855b9bb9-9phsv to wilson\n  Normal  Pulled     8s    kubelet            Container image \"docker.io/istio/proxyv2:1.28.2\" already present on machine\n  Normal  Created    8s    kubelet            Created container: istio-init\n  Normal  Started    8s    kubelet            Started container istio-init\n  Normal  Pulled     8s    kubelet            Container image \"docker.io/istio/proxyv2:1.28.2\" already present on machine\n  Normal  Created    8s    kubelet            Created container: istio-proxy\n  Normal  Started    8s    kubelet            Started container istio-proxy\n  Normal  Pulled     6s    kubelet            Container image \"registry.cn-beijing.aliyuncs.com/wilsonchai/nginx:latest\" already present on machine\n  Normal  Created    6s    kubelet            Created container: nginx-test\n  Normal  Started    5s    kubelet            Started container nginx-test\n\n</code></pre>\n<p>1个initContainer，1个业务container和1个sidecar</p>\n<p>其中initContainer：</p>\n<pre><code>Init Containers:\n  istio-init:\n    Container ID:  containerd://2bf56cd37703d82a2a43e94e8c8d683ed66b0afe22bf7148a597d67b89a727a8\n    Image:         docker.io/istio/proxyv2:1.28.2\n    Image ID:      docker.m.daocloud.io/istio/proxyv2@sha256:39065152d6bd3e7fbf6bb04be43c7a8bbd16b5c7181c84e3d78fa164a945ae7f\n    Port:          &lt;none&gt;\n    Host Port:     &lt;none&gt;\n    Args:\n      istio-iptables\n      -p\n      15001\n      -z\n      15006\n      -u\n      1337\n      -m\n      REDIRECT\n      -i\n      *\n      -x\n\n      -b\n      *\n      -d\n      15090,15021,15020\n      --log_output_level=default:info\n...\n</code></pre>\n<p>和之前envoy中劫持流量的做法一样，istio依然是使用iptables将端口流量导入到代理之中处理</p>\n<p>尝试访问一下：</p>\n<pre><code>▶ curl 10.22.12.178:30785/test\ni am backend in backend-6d76f54494-g6srz\n</code></pre>\n<p>成功，再次查看istio-proxy日志。空的？为了调试方便，将其打开并且输出至控制台</p>\n<pre><code>kubectl -n istio-system edit cm istio\n\napiVersion: v1\ndata:\n  mesh: |-\n    accessLogFile: /dev/stdout\n  ...\n</code></pre>\n<p>至此，istio的第一个功能探索完毕，自动注入sidecar container并且完成了流量劫持</p>\n<h2 id=\"upgrade-required-426-的问题\">Upgrade Required 426 的问题</h2>\n<p>当前的架构是左图，现在要前进到右图</p>\n<p><img alt=\"watermarked-istio_1\" class=\"lazyload\" /></p>\n<p>其实就是在backend注入istio-proxy，直接重启就好</p>\n<pre><code>▶ kubectl get pod -owide\nNAME                          READY   STATUS        RESTARTS   AGE     IP            NODE     NOMINATED NODE   READINESS GATES\nbackend-5d4d7b598c-f7852      2/2     Running       0          13s     10.244.0.49   wilson   &lt;none&gt;           &lt;none&gt;\nnginx-test-6f855b9bb9-9phsv   2/2     Running       0          58m     10.244.0.48   wilson   &lt;none&gt;           &lt;none&gt;\n\n</code></pre>\n<p>注入完成，测试一下</p>\n<pre><code>▶ curl 10.22.12.178:30785/test\nUpgrade Required\n</code></pre>\n<pre><code>▶ kubectl logs -f -l app=nginx-test -c istio-proxy\n[2026-01-26T07:54:42.977Z] \"GET /test HTTP/1.1\" 426 - upstream=10.244.0.48:80 duration=6ms route=default\n[2026-01-26T07:54:42.978Z] \"- - -\" 0 - upstream=10.105.148.194:10000 duration=9ms route=-\n\n</code></pre>\n<p>在nginx注入istio-proxy，backend没有注入的时候并没有报错。而一旦nginx与backend都注入的时候就会出现Upgrade Required (426)错误，Nginx Sidecar 发现目标（Backend）是一个纯文本服务，它会回退到“透明代理”模式，简单地把 Nginx 发出的流量透传出去</p>\n<p>Nginx Sidecar 发现目标也有 Sidecar，它会尝试建立一个高度优化的、基于 mTLS 的隧道（关于mTLS后面会详细介绍）。如果此时 Nginx 发出的请求头（比如缺少 Host 字段，或者使用了 HTTP/1.0）不符合 Envoy 对这种隧道<br />\n协议的预期，Envoy 可能会向 Nginx 发送一个特殊的响应，或者 Nginx 在尝试通过这种隧道通信时，因为某些 Header 冲突（如 Connection: close）自发产生了 426 错误</p>\n<p>想要解决这个问题有两种方法</p>\n<h4 id=\"改造nginx中加入标记\">改造nginx中加入标记</h4>\n<pre><code>        location /test {\n            proxy_http_version 1.1; # 必须添加这一行\n            proxy_set_header Host $host; # 这一行也是必须的\n            proxy_pass http://backend_ups;\n        }\n\n</code></pre>\n<p>Nginx 的 proxy_pass 默认使用 HTTP/1.0。在 Istio 环境中，HTTP/1.0 不支持长连接（Keep-Alive）以及一些现代的协议协商，这与 Istio Sidecar（Envoy）默认的 L7 代理行为冲突，Istio 需要 HTTP/1.1 来支持复杂连接管理问题</p>\n<h4 id=\"改造backend-service\">改造backend service</h4>\n<p>如果nginx改造有难度，那也可以尝试改造backend-service</p>\n<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\n  namespace: default\nspec:\n  ports:\n  - name: tcp-80 # 原为 http-80 改为 tcp-80\n    port: 10000\n    protocol: TCP\n    targetPort: 10000\n  selector:\n    app: backend\n\n</code></pre>\n<p>Istio 只有在识别到流量是 HTTP 时才会进行深度的协议检查和转换。如果你把这个服务声明为 TCP，Istio 就会将其视为原始字节流进行透传，不再关心它是 HTTP/1.0 还是 1.1。优点就是彻底解决 426 问题，无需改 Nginx。<br />\n缺点则是你会失去 Istio 针对该服务的 HTTP 监控指标（如请求数、4xx/5xx 统计）、分布式追踪以及基于路径的路由功能</p>\n<h2 id=\"http-10-与-http-11\">http 1.0 与 http 1.1</h2>\n<p>这里再简单介绍一下两个协议版本的区别</p>\n<ul>\n<li>\n<p>连接管理（最显著的区别）</p>\n<ul>\n<li>HTTP 1.0：短连接 (Short-lived)，默认情况下，客户端每发起一个请求，都要与服务器建立一次 TCP 三次握手。请求结束并收到响应后，TCP 连接立即关闭。如果页面有 10 张图片，浏览器就要建立 10 次 TCP 连接。这带来了极高的延迟和资源开销。</li>\n<li>HTTP 1.1：持久连接 (Persistent Connection / Keep-Alive)。默认开启 Connection: keep-alive。一个 TCP 连接可以被多个请求复用。只有在明确声明 Connection: close 或连接超时后才会关闭。</li>\n<li>在 Istio 中： Envoy 极度依赖持久连接来维持高性能的 Sidecar 间隧道。HTTP 1.0 的频繁断开会让 Envoy 感到“压力山大”，甚至认为这是一种非标准的协议行为。</li>\n</ul>\n</li>\n<li>\n<p>Host Header</p>\n<ul>\n<li>HTTP 1.0：人们认为一个 IP 对应一个网站，所以请求头里不需要带域名信息。</li>\n<li>HTTP 1.1：随着虚拟主机（一个 IP 跑多个网站）的流行，HTTP 1.1 规定请求头必须包含 Host 字段。</li>\n<li>在 K8s/Istio 中： Istio 的路由决策、Service 的匹配完全依赖 Host 头。这也是为什么 Nginx 使用 HTTP 1.0 转发时，如果不手动补全 Host 头，后端往往会返回 404 或协议错误。</li>\n</ul>\n</li>\n</ul>\n<p>以上是istio必须要求HTTP 1.1最主要的两个因素，当然还有其他非常重要的区别</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>HTTP 1.0</th>\n<th>HTTP 1.1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>连接模型</td>\n<td>默认短连接，每次请求新开 TCP</td>\n<td>默认持久连接 (Keep-Alive)，复用 TCP</td>\n</tr>\n<tr>\n<td>Host 头部</td>\n<td>可选 (导致无法支持虚拟主机)</td>\n<td>必须 (支持一 IP 多域名)</td>\n</tr>\n<tr>\n<td>流水线 (Pipelining)</td>\n<td>不支持</td>\n<td>支持 (但在实际应用中受限)</td>\n</tr>\n<tr>\n<td>断点续传</td>\n<td>不支持</td>\n<td>支持 (通过 Range 头部)</td>\n</tr>\n<tr>\n<td>缓存控制</td>\n<td>简单 (Expires)</td>\n<td>复杂且强大 (Cache-Control, ETag)</td>\n</tr>\n<tr>\n<td>默认协议版本</td>\n<td>许多旧软件(如 Nginx proxy)的默认值</td>\n<td>现代 Web 应用的基石标准</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"小结\">小结</h2>\n<p>本章内容算是一个开胃小菜，成功安装了istio，并且解决了一个非常常见的426问题，至于怎么把之前在envoy的那些最佳实践搬迁到istio，那就是后面的内容了，敬请期待</p>\n<h2 id=\"后记\">后记</h2>\n<p>如果整个namespace都已经有了注入标签<code>istio-injection=enabled</code>，但是某个deployment不想让istio注入</p>\n<pre><code>kubectl patch deployment nginx -p '{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"sidecar.istio.io/inject\":\"false\"}}}}}'\n</code></pre>\n<h2 id=\"联系我\">联系我</h2>\n<ul>\n<li>联系我，做深入的交流</li>\n</ul>\n<p><img alt=\"\" class=\"lazyload\" height=\"200\" width=\"500\" /></p>\n<hr />\n<p>至此，本文结束<br />\n在下才疏学浅，有撒汤漏水的，请各位不吝赐教...</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/MrVolleyball/\" target=\"_blank\">it排球君</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/MrVolleyball/p/19547269\" target=\"_blank\">https://www.cnblogs.com/MrVolleyball/p/19547269</a></p>\n<div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须在文章页面给出原文连接，否则保留追究法律责任的权利。 </div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 11:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/MrVolleyball\">it排球君</a>&nbsp;\n阅读(<span id=\"post_view_count\">36</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "零门槛部署本地 AI 助手：Clawdbot/Meltbot 部署深度保姆级教程",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19545952",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19545952\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 00:14\">\n    <span>零门槛部署本地 AI 助手：Clawdbot/Meltbot 部署深度保姆级教程</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Clawdbot是一个多功能智能体（Agent），具备文件操作、代码执行、联网搜索等能力。本文详细介绍了其安装配置流程： 环境准备：全新安装Node.js（v22+/v24+）或彻底卸载旧版后安装新版，需确保环境变量配置正确； 权限设置：在PowerShell中解锁脚本执行权限； 一键安装：通过官方脚本自动部署主程序； 初始化向导：选择QuickStart模式，配置基础技能（Skills）和API（如Qwen或OpenAI），暂跳过高级选项。 完成上述步骤后即可启动Clawdbot，后续可扩展远程控制等功能\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<hr />\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"前言为什么选择-clawdbot-moltbot\">前言：为什么选择 Clawdbot (Moltbot)？</h1>\n<p>Clawdbot 不仅仅是一个聊天框。它是一个 <strong>智能体（Agent）</strong>，意味着它有“手”和“脚”：</p>\n<ul>\n<li><strong>手</strong>：它可以读写你电脑上的文件、执行代码、操控命令行。</li>\n<li><strong>脚</strong>：它可以联网搜索、访问 Google、分析网页。</li>\n<li><strong>大脑</strong>：你可以接入云端的 <strong>API</strong>，也可以利用自己的 <strong>GPU</strong> 运行本地模型。</li>\n</ul>\n<hr />\n<h1 id=\"第一阶段基建工程环境准备\">第一阶段：基建工程（环境准备）</h1>\n<h2 id=\"11-解决-nodejs-安装与版本问题\">1.1 解决 Node.js 安装与版本问题</h2>\n<h3 id=\"111全新安装nodejs电脑未安装过nodejs时\">1.1.1全新安装Node.js（电脑未安装过Node.js时）</h3>\n<p>如果你的电脑上从来没装过Node.js，无需执行卸载、删残留的步骤，直接按以下流程全新安装即可，步骤适配Windows系统，新手友好、全程默认下一步即可。</p>\n<p><strong>1. 下载适配的Node.js安装包</strong></p>\n<ol>\n<li>\n<p>打开<a href=\"https://nodejs.org/\" rel=\"noopener nofollow\" target=\"_blank\">Node.js 官方官网</a>，官网页面会自动识别你的系统（Windows）；<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>点击下载<strong>Windows Installer (64-bit)</strong> 格式的安装包（.msi后缀，64位是目前Windows电脑的主流，无需选32位）；</p>\n<blockquote>\n<p>小贴士：下载时建议保存到桌面/下载文件夹，方便找到安装包。</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>2. 安装Node.js（全程新手友好，默认下一步即可）</strong></p>\n<ol>\n<li>双击刚下载的.msi安装包，弹出安装向导，点击<strong>Next</strong>；</li>\n<li>勾选同意协议（I accept the terms in the License Agreement），点击<strong>Next</strong>；</li>\n<li><strong>关键点1</strong>：确认安装路径（默认是<code>C:\\Program Files\\nodejs\\</code>，新手<strong>不要修改</strong>，避免后续环境变量出问题），直接<strong>Next</strong>；</li>\n<li><strong>关键点2</strong>：进入「Custom Setup」自定义安装页，<strong>所有选项默认勾选即可</strong>（重点确认<code>Add Node.js to PATH</code>已勾选，这一步会自动把Node.js加入系统环境变量，不用手动配置，是最关键的一步），直接<strong>Next</strong>；</li>\n<li>后续页面无需修改任何高级选项，一直点击<strong>Next</strong>，最后点击<strong>Install</strong>开始安装，等待10-30秒（安装速度看电脑配置）；</li>\n<li>安装完成后，点击<strong>Finish</strong>关闭向导即可。</li>\n</ol>\n<p><strong>3. 版本验证</strong><br />\n<strong>必须重启终端</strong>（关闭所有已打开的PowerShell/CMD，重新打开），否则系统识别不到新安装的Node.js！</p>\n<ol>\n<li>按下<code>Win+R</code>，输入<code>PowerShell</code>，打开普通权限的PowerShell即可；</li>\n<li>输入验证命令：<pre><code class=\"language-powershell\">node -v\n</code></pre>\n</li>\n<li>回车后，若显示<code>v22.x.x</code>或<code>v24.x.x</code>（比如v22.10.0、v24.4.0），说明安装成功且版本符合要求；\n<blockquote>\n<p>可选验证：输入<code>npm -v</code>，会显示配套的npm版本（Node.js安装包会自动附带npm，无需单独安装），能正常输出版本即代表环境变量配置无误。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</blockquote>\n</li>\n</ol>\n<hr />\n<h3 id=\"112卸载旧版nodejs-安装新版电脑安装过nodejs但是版本不够新时\">1.1.2卸载旧版Node.js 安装新版（电脑安装过Node.js但是版本不够新时）</h3>\n<p>如果版本不够新，执行安装命令的时候程序会尝试安装新版的Node.js，但是大概率会失败，还是手动比较好，失败的话会显示以下界面：<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<strong>操作：</strong><br />\n1.可以直接通过新的安装包对上一个版本的Node.js进行remove<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ol start=\"2\">\n<li>去“控制面板”卸载旧的 Node.js。</li>\n<li><strong>关键点：</strong> 手动进入 <code>C:\\Program Files\\nodejs</code> 文件夹，把残留的文件全部删干净！</li>\n<li>前往 <a href=\"https://nodejs.org/\" rel=\"noopener nofollow\" target=\"_blank\">Node.js 官网</a> 下载最新的 <strong>v22 或 v24</strong> 稳定版并安装。</li>\n<li><strong>清楚之前的旧的环境变量</strong>（这一步非常重要！）</li>\n</ol>\n<ul>\n<li><strong>验证：</strong> 重新打开 PowerShell，输入 <code>node -v</code>。看到显示 <code>v22.x</code> 或 <code>v24.x</code> 才算过关。</li>\n</ul>\n<ol start=\"6\">\n<li>版本验证（和卸载旧版后的验证步骤一致）<br />\n<strong>必须重启终端</strong>（关闭所有已打开的PowerShell/CMD，重新打开），否则系统识别不到新安装的Node.js！</li>\n<li>按下<code>Win+R</code>，输入<code>PowerShell</code>，打开普通权限的PowerShell即可；</li>\n<li>输入验证命令：<pre><code class=\"language-powershell\">node -v\n</code></pre>\n</li>\n<li>回车后，若显示<code>v22.x.x</code>或<code>v24.x.x</code>（比如v22.10.0、v24.4.0），说明安装成功且版本符合要求；\n<blockquote>\n<p>可选验证：输入<code>npm -v</code>，会显示配套的npm版本（Node.js安装包会自动附带npm，无需单独安装），能正常输出版本即代表环境变量配置无误。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"12-解锁脚本执行权限\">1.2 解锁脚本执行权限</h2>\n<ul>\n<li><strong>问题：</strong> Windows 默认禁止运行脚本，会导致安装指令失效。</li>\n<li><strong>操作：</strong> 以管理员身份运行 PowerShell，执行：<pre><code class=\"language-powershell\">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n</code></pre>\n</li>\n</ul>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<p><strong>完成以上步骤后，你的Node.js环境就完全满足Clawdbot的要求了，可以直接进入后续的项目安装环节。</strong></p>\n<hr />\n<h1 id=\"第二阶段正式安装与初始化\">第二阶段：正式安装与初始化</h1>\n<h2 id=\"21-执行一键安装\">2.1 执行一键安装</h2>\n<ul>\n<li><strong>操作：</strong> 在 PowerShell 输入：<pre><code class=\"language-powershell\">iwr -useb https://clawd.bot/install.ps1 | iex\n</code></pre>\n</li>\n<li><strong>作用：</strong> 这行代码会自动下载主程序并配置环境变量。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n这个会持续一会才有进展，不要担心，如果太久可以按按回车看看是不是powershell刷新的问题<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n这个会持续一段时间才有进展，不要担心，</li>\n</ul>\n<h2 id=\"22-运行向导-onboarding\">2.2 运行向导 (Onboarding)</h2>\n<ul>\n<li><strong>操作：</strong> 输入 <code>moltbot onboard</code>。</li>\n<li><strong>详细选项说明：</strong>\n<ol>\n<li>\n<p><strong>Mode</strong>：选 <code>QuickStart</code>。</p>\n</li>\n<li>\n<p><strong>Provider (大脑)</strong>：建议选 <code>Qwen</code>。</p>\n<ul>\n<li><strong>注意：</strong> 此时会跳出网页让你授权，登录或者注册Qwen的账号既可。这步是为了先让机器人有个“临时大脑”跑起来。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n选择OpenAI Chat，拿到Key之后输入到界面中给Clawdbot。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n选择这个直接按回车即可。</li>\n</ul>\n</li>\n<li>\n<p><strong>Channels (远程控制)</strong>：选 <code>Skip for now</code>。我们先在本地跑通，以后再连 Telegram。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p><strong>Skills (技能)</strong>：选 <code>Yes</code>。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" />这些是最基本的Skill选择，选择Yes就好</p>\n</li>\n<li>\n<p><strong>Skill install</strong>：选 <code>npm</code>。</p>\n</li>\n</ol>\n</li>\n</ul>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ol start=\"5\">\n<li><strong>Skill Dependencies</strong>：选 <code>Skip for now</code>。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n这些是扩展的，目前配置比较麻烦，可以后续再配置<br />\n6. 一些其他配置<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n选择No，尽量都留到后面再配置<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></li>\n</ol>\n<h2 id=\"23-成功界面\">2.3 成功界面</h2>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" />、<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"第三阶段破解命令找不到与网关未授权\">第三阶段：破解“命令找不到”与“网关未授权”</h1>\n<h2 id=\"31-解决-moltbot-命令失效\">3.1 解决 moltbot 命令失效</h2>\n<ul>\n<li>\n<p><strong>现象：</strong> 安装完输入 <code>moltbot open</code> 提示“无法识别”。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p><strong>原因：</strong> 环境变量未刷新。</p>\n</li>\n<li>\n<p><strong>对策：</strong> 重启 PowerShell 窗口。如果还不行，执行npx moltbot open。</p>\n</li>\n</ul>\n<h2 id=\"32-提取身份令牌-token-登录网页\">3.2 提取身份令牌 (Token) 登录网页</h2>\n<ul>\n<li>\n<p><strong>现象：</strong> 访问 <code>http://localhost:18789</code> 显示“未授权：网关令牌缺失”。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p><strong>操作：</strong></p>\n<ol>\n<li>\n<p>打开文件夹 <code>C:\\Users\\你的用户名\\.clawdbot</code>。</p>\n</li>\n<li>\n<p>右键点击 <code>clawdbot.json</code>，用记事本打开。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>找到 <code>\"token\": \"xxxxxxx\"</code> 这一行，复制那串长代码。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>回到浏览器，点击右上角红色状态，把 Token 贴进去。<strong>一旦变绿，恭喜你，你的助理正式上线了！</strong><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n</ol>\n</li>\n</ul>\n<hr />\n<h1 id=\"第四阶段配置各种api\">第四阶段：配置各种API</h1>\n<ul>\n<li><strong>操作步骤：</strong>\n<ol>\n<li>在网页后台点击左侧 <strong>Skill(技能)</strong><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n可以看到有非常多的API可以配置，过程相对来说还是比较繁琐的，有机会的话下次专门再出一期博客来讲，目前的话他可以实现通过对话来进行一些本地的文件操作，命令操作等等。整体来说还是不错的</li>\n</ol>\n</li>\n</ul>\n<hr />\n<hr />\n<h2 id=\"总结你的-ai-现在能干什么\">总结：你的 AI 现在能干什么？</h2>\n<ol>\n<li><strong>对话</strong>：你可以问它任何问题。</li>\n<li><strong>读文件</strong>：把代码发给它，或者让它读你 F 盘的文档。</li>\n<li><strong>本地代码执行</strong>：让它用 Python 画一个股价走势图。</li>\n</ol>\n<p><strong>部署贴士总结：</strong></p>\n<ul>\n<li><strong>Node 版本必须 v22+</strong></li>\n<li><strong>Token 在配置文件里找</strong></li>\n<li><strong>本地 GPU 模型用 Ollama 桥接</strong></li>\n<li><strong>Google 搜索一定要开“搜索全网”开关</strong></li>\n</ul>\n<hr />\n<p><em>恭喜你完成了部署！现在，你的 Windows 已经不仅仅是一台电脑，而是一个拥有最强国产模型大脑和本地硬件加速的超级助手了。</em></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 00:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\n阅读(<span id=\"post_view_count\">568</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Kuboard 离线安装与 K3s 集群绑定完整指南",
      "link": "https://www.cnblogs.com/ghostmen/p/19548359",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ghostmen/p/19548359\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 14:29\">\n    <span>Kuboard 离线安装与 K3s 集群绑定完整指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"-目录\">📋 目录</h2>\n<ul>\n<li><a href=\"#%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E\" rel=\"noopener nofollow\">环境说明</a></li>\n<li><a href=\"#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\" rel=\"noopener nofollow\">准备工作</a></li>\n<li><a href=\"#%E4%B8%80%E5%87%86%E5%A4%87%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85\" rel=\"noopener nofollow\">一、准备离线安装包</a></li>\n<li><a href=\"#%E4%BA%8C%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8\" rel=\"noopener nofollow\">二、传输文件到服务器</a></li>\n<li><a href=\"#%E4%B8%89%E5%AE%89%E8%A3%85-kuboard\" rel=\"noopener nofollow\">三、安装 Kuboard</a></li>\n<li><a href=\"#%E5%9B%9B%E8%A7%A3%E5%86%B3-404-%E9%97%AE%E9%A2%98\" rel=\"noopener nofollow\">四、解决 404 问题</a></li>\n<li><a href=\"#%E4%BA%94%E7%BB%91%E5%AE%9A-k3s-%E9%9B%86%E7%BE%A4\" rel=\"noopener nofollow\">五、绑定 K3s 集群</a></li>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4\" rel=\"noopener nofollow\">常用管理命令</a></li>\n<li><a href=\"#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\" rel=\"noopener nofollow\">常见问题</a></li>\n</ul>\n<hr />\n<h2 id=\"环境说明\">环境说明</h2>\n<h3 id=\"服务器环境\">服务器环境</h3>\n<ul>\n<li><strong>服务器 IP</strong>: 10.12.12.110</li>\n<li><strong>操作系统</strong>: CentOS/RHEL</li>\n<li><strong>网络环境</strong>: 内网，无法访问外网</li>\n<li><strong>已安装服务</strong>: K3s v1.30.11+k3s1</li>\n</ul>\n<h3 id=\"本地环境\">本地环境</h3>\n<ul>\n<li><strong>操作系统</strong>: Windows</li>\n<li><strong>网络</strong>: 可以联网</li>\n<li><strong>已安装工具</strong>: Docker Desktop、SecureCRT</li>\n</ul>\n<hr />\n<h2 id=\"准备工作\">准备工作</h2>\n<h3 id=\"所需工具\">所需工具</h3>\n<ul>\n<li>Docker Desktop（Windows 本地）</li>\n<li>SecureCRT（SSH 连接工具）</li>\n<li>浏览器</li>\n</ul>\n<h3 id=\"网络要求\">网络要求</h3>\n<ul>\n<li>本地机器可以访问互联网</li>\n<li>本地机器可以 SSH 连接到服务器</li>\n<li>服务器处于内网环境</li>\n</ul>\n<hr />\n<h2 id=\"一准备离线安装包\">一、准备离线安装包</h2>\n<h3 id=\"11-下载-kuboard-镜像\">1.1 下载 Kuboard 镜像</h3>\n<p>在 Windows 本地（已安装 Docker Desktop）的 PowerShell 中执行：</p>\n<pre><code class=\"language-powershell\"># 使用国内镜像源下载 Kuboard v3\ndocker pull swr.cn-east-2.myhuaweicloud.com/kuboard/kuboard:v3\n\n# 重新标记镜像\ndocker tag swr.cn-east-2.myhuaweicloud.com/kuboard/kuboard:v3 eipwork/kuboard:v3\n\n# 验证镜像\ndocker images | Select-String kuboard\n</code></pre>\n<h3 id=\"12-导出镜像为-tar-文件\">1.2 导出镜像为 tar 文件</h3>\n<pre><code class=\"language-powershell\"># 创建目录\nNew-Item -ItemType Directory -Force -Path \"D:\\Documents\\kuboard-offline\\images\"\n\n# 导出镜像（约 126 MB）\ndocker save eipwork/kuboard:v3 -o \"D:\\Documents\\kuboard-offline\\images\\kuboard-v3.tar\"\n\n# 查看文件大小\nGet-ChildItem \"D:\\Documents\\kuboard-offline\\images\\kuboard-v3.tar\"\n</code></pre>\n<h3 id=\"13-下载-docker-离线安装包\">1.3 下载 Docker 离线安装包</h3>\n<pre><code class=\"language-powershell\"># 创建目录\nNew-Item -ItemType Directory -Force -Path \"D:\\Documents\\kuboard-offline\\docker\"\n\n# 下载 Docker 离线包（约 66.6 MB）\nInvoke-WebRequest -Uri \"https://download.docker.com/linux/static/stable/x86_64/docker-24.0.7.tgz\" -OutFile \"D:\\Documents\\kuboard-offline\\docker\\docker-24.0.7.tgz\"\n</code></pre>\n<h3 id=\"14-创建安装脚本\">1.4 创建安装脚本</h3>\n<p>在 <code>D:\\Documents\\kuboard-offline\\</code> 目录下创建 <code>install.sh</code> 文件：</p>\n<pre><code class=\"language-bash\">#!/bin/bash\n# Kuboard 离线安装脚本\n\nset -e\n\necho \"==========================================\"\necho \"Kuboard 离线安装\"\necho \"==========================================\"\n\n# 检查是否为 root 用户\nif [ \"$EUID\" -ne 0 ]; then \n    echo \"请使用 root 用户或 sudo 执行此脚本\"\n    exit 1\nfi\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" &amp;&amp; pwd)\"\n\n# 检查 Docker 是否已安装\nif ! command -v docker &amp;&gt; /dev/null; then\n    echo \"[1/4] 安装 Docker...\"\n    \n    if [ -f \"${SCRIPT_DIR}/docker/docker-24.0.7.tgz\" ]; then\n        cd \"${SCRIPT_DIR}/docker\"\n        tar -xzf docker-24.0.7.tgz\n        cp docker/* /usr/bin/\n        chmod +x /usr/bin/docker*\n        \n        # 创建 Docker systemd 服务\n        cat &gt; /etc/systemd/system/docker.service &lt;&lt; 'DOCKERSERVICE'\n[Unit]\nDescription=Docker Application Container Engine\nDocumentation=https://docs.docker.com\nAfter=network-online.target firewalld.service\nWants=network-online.target\n\n[Service]\nType=notify\nExecStart=/usr/bin/dockerd\nExecReload=/bin/kill -s HUP $MAINPID\nLimitNOFILE=infinity\nLimitNPROC=infinity\nTimeoutStartSec=0\nDelegate=yes\nKillMode=process\nRestart=on-failure\nStartLimitBurst=3\nStartLimitInterval=60s\n\n[Install]\nWantedBy=multi-user.target\nDOCKERSERVICE\n\n        systemctl daemon-reload\n        systemctl start docker\n        systemctl enable docker\n        \n        echo \"✓ Docker 安装完成\"\n    else\n        echo \"⚠ 未找到 Docker 安装包\"\n    fi\nelse\n    echo \"[1/4] Docker 已安装: $(docker --version)\"\nfi\n\necho \"\"\necho \"[2/4] 加载 Kuboard 镜像...\"\nif [ -f \"${SCRIPT_DIR}/images/kuboard-v3.tar\" ]; then\n    docker load -i \"${SCRIPT_DIR}/images/kuboard-v3.tar\"\n    echo \"✓ Kuboard 镜像加载完成\"\nelse\n    echo \"✗ 未找到 Kuboard 镜像文件\"\n    exit 1\nfi\n\necho \"\"\necho \"[3/4] 创建数据目录...\"\nmkdir -p /data/kuboard\necho \"✓ 数据目录创建完成: /data/kuboard\"\n\necho \"\"\necho \"[4/4] 启动 Kuboard 容器...\"\n\nSERVER_IP=\"10.12.12.110\"\n\n# 检查是否已有运行的 kuboard 容器\nif docker ps -a | grep -q kuboard; then\n    echo \"检测到已存在的 kuboard 容器，正在删除...\"\n    docker rm -f kuboard\nfi\n\n# 启动容器\ndocker run -d \\\n  --restart=unless-stopped \\\n  --name=kuboard \\\n  -p 80:80/tcp \\\n  -p 10081:10081/tcp \\\n  -e KUBOARD_ENDPOINT=\"http://${SERVER_IP}:80\" \\\n  -e KUBOARD_AGENT_SERVER_TCP_PORT=\"10081\" \\\n  -v /data/kuboard:/data \\\n  eipwork/kuboard:v3\n\necho \"\"\necho \"等待容器启动...\"\nsleep 5\n\n# 检查容器状态\nif docker ps | grep -q kuboard; then\n    echo \"✓ Kuboard 启动成功！\"\n    echo \"\"\n    echo \"==========================================\"\n    echo \"安装完成！\"\n    echo \"==========================================\"\n    echo \"访问地址: http://${SERVER_IP}\"\n    echo \"默认用户名: admin\"\n    echo \"默认密码: Kuboard123\"\n    echo \"\"\n    echo \"⚠️  请立即登录并修改默认密码！\"\n    echo \"==========================================\"\nelse\n    echo \"✗ Kuboard 启动失败，请查看日志:\"\n    docker logs kuboard\n    exit 1\nfi\n</code></pre>\n<h3 id=\"15-文件结构\">1.5 文件结构</h3>\n<p>准备完成后，目录结构如下：</p>\n<pre><code>D:\\Documents\\kuboard-offline\\\n├── docker/\n│   └── docker-24.0.7.tgz          (66.6 MB)\n├── images/\n│   └── kuboard-v3.tar             (126 MB)\n└── install.sh                      (安装脚本)\n</code></pre>\n<p><strong>总大小</strong>: 约 193 MB</p>\n<hr />\n<h2 id=\"二传输文件到服务器\">二、传输文件到服务器</h2>\n<h3 id=\"21-使用-securecrt-的-sftp-功能\">2.1 使用 SecureCRT 的 SFTP 功能</h3>\n<h4 id=\"连接到服务器\">连接到服务器</h4>\n<ol>\n<li>打开 SecureCRT</li>\n<li>新建会话或快速连接\n<ul>\n<li>协议：SSH2</li>\n<li>主机名：<code>10.12.12.110</code></li>\n<li>端口：<code>22</code></li>\n<li>用户名：<code>sudoroot</code></li>\n</ul>\n</li>\n<li>连接并输入密码</li>\n</ol>\n<h4 id=\"上传文件\">上传文件</h4>\n<ol>\n<li>按 <code>Alt + P</code> 打开 SFTP 窗口</li>\n<li>在 SFTP 窗口中执行：</li>\n</ol>\n<pre><code class=\"language-bash\"># 切换到服务器的 /tmp 目录\ncd /tmp\n\n# 切换本地目录到 D:\\Documents\nlcd D:\\Documents\n\n# 上传整个文件夹\nput -r kuboard-offline\n</code></pre>\n<ol start=\"3\">\n<li>等待传输完成（约 2-5 分钟）</li>\n</ol>\n<h3 id=\"22-验证文件传输\">2.2 验证文件传输</h3>\n<p>在 SecureCRT 命令行中执行：</p>\n<pre><code class=\"language-bash\"># 检查文件是否完整\nls -lh /tmp/kuboard-offline/\nls -lh /tmp/kuboard-offline/docker/\nls -lh /tmp/kuboard-offline/images/\n</code></pre>\n<hr />\n<h2 id=\"三安装-kuboard\">三、安装 Kuboard</h2>\n<h3 id=\"31-执行安装脚本\">3.1 执行安装脚本</h3>\n<p>在 SecureCRT 中执行：</p>\n<pre><code class=\"language-bash\"># 进入目录\ncd /tmp/kuboard-offline\n\n# 给脚本执行权限\nchmod +x install.sh\n\n# 执行安装\nsudo bash install.sh\n</code></pre>\n<h3 id=\"32-等待安装完成\">3.2 等待安装完成</h3>\n<p>安装脚本会自动完成以下操作：</p>\n<ol>\n<li>✅ 检查并安装 Docker（如果未安装）</li>\n<li>✅ 加载 Kuboard 镜像</li>\n<li>✅ 创建数据目录 <code>/data/kuboard</code></li>\n<li>✅ 启动 Kuboard 容器</li>\n</ol>\n<p>安装过程约需 <strong>1-3 分钟</strong>。</p>\n<h3 id=\"33-验证安装\">3.3 验证安装</h3>\n<pre><code class=\"language-bash\"># 查看容器状态\nsudo docker ps | grep kuboard\n\n# 查看日志\nsudo docker logs kuboard | tail -50\n\n# 测试本地访问\ncurl -I http://localhost:80\n</code></pre>\n<hr />\n<h2 id=\"四解决-404-问题\">四、解决 404 问题</h2>\n<h3 id=\"41-问题现象\">4.1 问题现象</h3>\n<p>初次安装后，访问 <code>http://10.12.12.110</code> 可能会遇到 <strong>404 page not found</strong> 错误。</p>\n<h3 id=\"42-问题原因\">4.2 问题原因</h3>\n<p>Kuboard v3 镜像的 nginx 配置文件默认生成不完整，缺少 <code>http {}</code> 块，导致无法正确处理 HTTP 请求。</p>\n<h3 id=\"43-解决方案更换端口并修复配置\">4.3 解决方案：更换端口并修复配置</h3>\n<h4 id=\"步骤-1停止现有容器并使用新端口\">步骤 1：停止现有容器并使用新端口</h4>\n<pre><code class=\"language-bash\"># 停止并删除现有容器\nsudo docker stop kuboard\nsudo docker rm kuboard\n\n# 使用 41878 端口重新启动\nsudo docker run -d \\\n  --restart=unless-stopped \\\n  --name=kuboard \\\n  -p 41878:80/tcp \\\n  -p 10081:10081/tcp \\\n  -e KUBOARD_ENDPOINT=\"http://10.12.12.110:41878\" \\\n  -e KUBOARD_AGENT_SERVER_TCP_PORT=\"10081\" \\\n  -v /data/kuboard:/data \\\n  eipwork/kuboard:v3\n\n# 等待容器启动\nsleep 30\n</code></pre>\n<h4 id=\"步骤-2修复-nginx-配置\">步骤 2：修复 nginx 配置</h4>\n<pre><code class=\"language-bash\"># 创建完整的 nginx 配置\nsudo docker exec kuboard sh -c 'cat &gt; /etc/nginx/nginx.conf &lt;&lt; \"EOF\"\nuser www-data;\nworker_processes auto;\npid /run/nginx.pid;\ninclude /etc/nginx/modules-enabled/*.conf;\n\nevents {\n    worker_connections 65535;\n}\n\nhttp {\n    sendfile on;\n    tcp_nopush on;\n    tcp_nodelay on;\n    keepalive_timeout 65;\n    types_hash_max_size 2048;\n\n    include /etc/nginx/mime.types;\n    default_type application/octet-stream;\n\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log;\n\n    gzip on;\n\n    server {\n        listen 80;\n        server_name _;\n        \n        client_max_body_size 1024m;\n\n        location / {\n            proxy_pass http://127.0.0.1:10080;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection \"upgrade\";\n        }\n    }\n}\n\nstream {}\nEOF'\n\n# 重载 nginx 配置\nsudo docker exec kuboard nginx -s reload\n</code></pre>\n<h4 id=\"步骤-3验证访问\">步骤 3：验证访问</h4>\n<pre><code class=\"language-bash\"># 测试本地访问\ncurl -I http://localhost:41878\n\n# 查看容器状态\nsudo docker ps | grep kuboard\n</code></pre>\n<h3 id=\"44-访问-kuboard\">4.4 访问 Kuboard</h3>\n<p>在浏览器中访问：</p>\n<p><strong><a href=\"http://10.12.12.110:41878\" rel=\"noopener nofollow\" target=\"_blank\">http://10.12.12.110:41878</a></strong></p>\n<p>登录信息：</p>\n<ul>\n<li><strong>用户名</strong>: <code>admin</code></li>\n<li><strong>密码</strong>: <code>Kuboard123</code></li>\n</ul>\n<p>⚠️ <strong>重要提醒</strong>：首次登录后请立即修改默认密码！</p>\n<hr />\n<h2 id=\"五绑定-k3s-集群\">五、绑定 K3s 集群</h2>\n<h3 id=\"51-检查-k3s-状态\">5.1 检查 K3s 状态</h3>\n<p>在 SecureCRT 中执行：</p>\n<pre><code class=\"language-bash\"># 检查 K3s 服务状态\nsudo systemctl status k3s\n\n# 查看节点信息\nsudo kubectl get nodes\n\n# 查看 kubeconfig 文件\nls -la /etc/rancher/k3s/k3s.yaml\n</code></pre>\n<h3 id=\"52-方法一使用-kubeconfig-导入推荐\">5.2 方法一：使用 KubeConfig 导入（推荐）</h3>\n<h4 id=\"步骤-1生成修改后的-kubeconfig\">步骤 1：生成修改后的 kubeconfig</h4>\n<p>在 SecureCRT 中执行：</p>\n<pre><code class=\"language-bash\"># 将 127.0.0.1 替换为服务器实际 IP\nsudo cat /etc/rancher/k3s/k3s.yaml | sed 's/127.0.0.1/10.12.12.110/g'\n</code></pre>\n<h4 id=\"步骤-2复制输出内容\">步骤 2：复制输出内容</h4>\n<p>执行上面命令后，会输出修改后的 kubeconfig，<strong>全部复制</strong>（从 <code>apiVersion: v1</code> 开始到最后）。</p>\n<h4 id=\"步骤-3在-kuboard-中导入\">步骤 3：在 Kuboard 中导入</h4>\n<ol>\n<li>浏览器访问 <strong><a href=\"http://10.12.12.110:41878\" rel=\"noopener nofollow\" target=\"_blank\">http://10.12.12.110:41878</a></strong></li>\n<li>使用 <code>admin/Kuboard123</code> 登录</li>\n<li>点击页面上的「<strong>添加集群</strong>」按钮</li>\n<li>选择「<strong>通过 KubeConfig 导入</strong>」</li>\n<li>将刚才复制的 kubeconfig 内容粘贴到文本框</li>\n<li>点击「<strong>确定</strong>」或「<strong>导入</strong>」</li>\n</ol>\n<h4 id=\"步骤-4验证集群连接\">步骤 4：验证集群连接</h4>\n<p>导入成功后，你应该能看到：</p>\n<ul>\n<li>集群名称：default</li>\n<li>节点数量：1</li>\n<li>K3s 版本：v1.30.11+k3s1</li>\n<li>节点状态：Ready</li>\n</ul>\n<h3 id=\"53-方法二使用-token-方式\">5.3 方法二：使用 Token 方式</h3>\n<p>如果 KubeConfig 导入失败，可以使用 Token 方式。</p>\n<h4 id=\"步骤-1创建-serviceaccount\">步骤 1：创建 ServiceAccount</h4>\n<p>在 SecureCRT 中执行：</p>\n<pre><code class=\"language-bash\"># 创建 Kuboard 专用账号和权限\ncat &lt;&lt;EOF | sudo kubectl apply -f -\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: kuboard\n\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: kuboard-admin\n  namespace: kuboard\n\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: kuboard-admin\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: cluster-admin\nsubjects:\n- kind: ServiceAccount\n  name: kuboard-admin\n  namespace: kuboard\n\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: kuboard-admin-token\n  namespace: kuboard\n  annotations:\n    kubernetes.io/service-account.name: kuboard-admin\ntype: kubernetes.io/service-account-token\nEOF\n</code></pre>\n<h4 id=\"步骤-2获取-token\">步骤 2：获取 Token</h4>\n<pre><code class=\"language-bash\"># 等待 Secret 创建\nsleep 5\n\n# 获取 Token\necho \"==========================================\"\necho \"Token:\"\necho \"==========================================\"\nsudo kubectl get secret kuboard-admin-token -n kuboard -o jsonpath='{.data.token}' | base64 -d\necho \"\"\necho \"\"\n\n# 获取 CA 证书\necho \"==========================================\"\necho \"CA Certificate:\"\necho \"==========================================\"\nsudo kubectl get secret kuboard-admin-token -n kuboard -o jsonpath='{.data.ca\\.crt}'\necho \"\"\n</code></pre>\n<h4 id=\"步骤-3在-kuboard-中添加集群\">步骤 3：在 Kuboard 中添加集群</h4>\n<ol>\n<li>访问 <strong><a href=\"http://10.12.12.110:41878\" rel=\"noopener nofollow\" target=\"_blank\">http://10.12.12.110:41878</a></strong></li>\n<li>点击「<strong>添加集群</strong>」</li>\n<li>选择「<strong>通过 Token 导入</strong>」或「<strong>手动添加</strong>」</li>\n<li>填写信息：\n<ul>\n<li><strong>集群名称</strong>：k3s-cluster（自定义）</li>\n<li><strong>API Server 地址</strong>：<code>https://10.12.12.110:6443</code></li>\n<li><strong>Token</strong>：粘贴步骤 2 获取的 Token</li>\n<li><strong>CA 证书</strong>：粘贴步骤 2 获取的 CA 证书（如果需要）</li>\n</ul>\n</li>\n<li>点击「<strong>确定</strong>」</li>\n</ol>\n<h3 id=\"54-验证集群绑定\">5.4 验证集群绑定</h3>\n<p>绑定成功后，在 Kuboard 界面中可以：</p>\n<ul>\n<li>查看集群节点状态</li>\n<li>查看命名空间列表</li>\n<li>查看工作负载（Deployments、Pods 等）</li>\n<li>管理配置和存储</li>\n<li>查看日志和监控数据</li>\n</ul>\n<hr />\n<h2 id=\"常用管理命令\">常用管理命令</h2>\n<h3 id=\"kuboard-容器管理\">Kuboard 容器管理</h3>\n<pre><code class=\"language-bash\"># 查看容器状态\nsudo docker ps | grep kuboard\n\n# 查看实时日志\nsudo docker logs -f kuboard\n\n# 重启服务\nsudo docker restart kuboard\n\n# 停止服务\nsudo docker stop kuboard\n\n# 启动服务\nsudo docker start kuboard\n\n# 查看容器详细信息\nsudo docker inspect kuboard\n</code></pre>\n<h3 id=\"数据备份\">数据备份</h3>\n<pre><code class=\"language-bash\"># 手动备份\nsudo tar -czf kuboard-backup-$(date +%Y%m%d).tar.gz /data/kuboard\n\n# 查看备份文件\nls -lh kuboard-backup-*.tar.gz\n\n# 恢复备份\nsudo tar -xzf kuboard-backup-20260129.tar.gz -C /\n</code></pre>\n<h3 id=\"端口检查\">端口检查</h3>\n<pre><code class=\"language-bash\"># 查看端口监听\nsudo netstat -tlnp | grep -E '41878|10081'\n\n# 测试本地访问\ncurl -I http://localhost:41878\n\n# 测试外部访问\ntelnet 10.12.12.110 41878\n</code></pre>\n<h3 id=\"k3s-集群管理\">K3s 集群管理</h3>\n<pre><code class=\"language-bash\"># 查看节点状态\nsudo kubectl get nodes\n\n# 查看所有 Pod\nsudo kubectl get pods --all-namespaces\n\n# 查看 K3s 服务状态\nsudo systemctl status k3s\n\n# 重启 K3s\nsudo systemctl restart k3s\n\n# 查看 K3s 日志\nsudo journalctl -u k3s -f\n</code></pre>\n<hr />\n<h2 id=\"常见问题\">常见问题</h2>\n<h3 id=\"q1-访问-kuboard-显示-404-错误\">Q1: 访问 Kuboard 显示 404 错误</h3>\n<p><strong>原因</strong>：nginx 配置不完整，缺少 <code>http {}</code> 块。</p>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li>更换端口（避开 80 端口）</li>\n<li>手动修复 nginx 配置（参考 <a href=\"#%E5%9B%9B%E8%A7%A3%E5%86%B3-404-%E9%97%AE%E9%A2%98\" rel=\"noopener nofollow\">四、解决 404 问题</a>）</li>\n</ol>\n<h3 id=\"q2-无法从浏览器访问-kuboard\">Q2: 无法从浏览器访问 Kuboard</h3>\n<p><strong>排查步骤</strong>：</p>\n<pre><code class=\"language-bash\"># 1. 检查容器是否运行\nsudo docker ps | grep kuboard\n\n# 2. 检查端口监听\nsudo netstat -tlnp | grep 41878\n\n# 3. 检查防火墙\nsudo firewall-cmd --list-ports\n\n# 4. 开放端口\nsudo firewall-cmd --permanent --add-port=41878/tcp\nsudo firewall-cmd --permanent --add-port=10081/tcp\nsudo firewall-cmd --reload\n</code></pre>\n<h3 id=\"q3-k3s-集群无法连接\">Q3: K3s 集群无法连接</h3>\n<p><strong>可能原因</strong>：</p>\n<ol>\n<li>API Server 地址错误（应该是服务器 IP，不是 127.0.0.1）</li>\n<li>Token 或证书错误</li>\n<li>K3s 服务未运行</li>\n</ol>\n<p><strong>解决方案</strong>：</p>\n<pre><code class=\"language-bash\"># 检查 K3s 状态\nsudo systemctl status k3s\n\n# 重启 K3s\nsudo systemctl restart k3s\n\n# 重新生成 kubeconfig\nsudo cat /etc/rancher/k3s/k3s.yaml | sed 's/127.0.0.1/10.12.12.110/g'\n</code></pre>\n<h3 id=\"q4-端口被占用\">Q4: 端口被占用</h3>\n<p><strong>检查端口占用</strong>：</p>\n<pre><code class=\"language-bash\">sudo netstat -tlnp | grep :41878\n</code></pre>\n<p><strong>更换端口</strong>：</p>\n<pre><code class=\"language-bash\"># 停止容器\nsudo docker rm -f kuboard\n\n# 使用新端口（如 8888）\nsudo docker run -d \\\n  --restart=unless-stopped \\\n  --name=kuboard \\\n  -p 8888:80/tcp \\\n  -p 10081:10081/tcp \\\n  -e KUBOARD_ENDPOINT=\"http://10.12.12.110:8888\" \\\n  -e KUBOARD_AGENT_SERVER_TCP_PORT=\"10081\" \\\n  -v /data/kuboard:/data \\\n  eipwork/kuboard:v3\n</code></pre>\n<h3 id=\"q5-docker-镜像拉取失败\">Q5: Docker 镜像拉取失败</h3>\n<p><strong>原因</strong>：国内网络访问 Docker Hub 受限。</p>\n<p><strong>解决方案</strong>：使用国内镜像源</p>\n<pre><code class=\"language-powershell\"># 使用华为云镜像源\ndocker pull swr.cn-east-2.myhuaweicloud.com/kuboard/kuboard:v3\n\n# 重新标记\ndocker tag swr.cn-east-2.myhuaweicloud.com/kuboard/kuboard:v3 eipwork/kuboard:v3\n</code></pre>\n<hr />\n<h2 id=\"总结\">总结</h2>\n<p>本文详细介绍了在内网环境下离线安装 Kuboard 并绑定 K3s 集群的完整流程：</p>\n<ol>\n<li><strong>准备阶段</strong>：在联网的 Windows 机器上下载 Kuboard 镜像和 Docker 离线包</li>\n<li><strong>传输阶段</strong>：使用 SecureCRT 的 SFTP 功能将文件传输到内网服务器</li>\n<li><strong>安装阶段</strong>：执行安装脚本，自动完成 Docker 和 Kuboard 的安装</li>\n<li><strong>修复阶段</strong>：解决 nginx 配置问题，更换端口确保正常访问</li>\n<li><strong>绑定阶段</strong>：通过 KubeConfig 或 Token 方式将 K3s 集群绑定到 Kuboard</li>\n</ol>\n<h3 id=\"关键要点\">关键要点</h3>\n<ul>\n<li>✅ 使用国内镜像源加速下载</li>\n<li>✅ 离线安装适用于内网环境</li>\n<li>✅ 手动修复 nginx 配置解决 404 问题</li>\n<li>✅ 使用非标准端口避免冲突</li>\n<li>✅ KubeConfig 方式是最简单的集群绑定方法</li>\n</ul>\n<h3 id=\"最终效果\">最终效果</h3>\n<ul>\n<li><strong>Kuboard 访问地址</strong>：<a href=\"http://10.12.12.110:41878\" rel=\"noopener nofollow\" target=\"_blank\">http://10.12.12.110:41878</a></li>\n<li><strong>默认账号</strong>：admin / Kuboard123</li>\n<li><strong>K3s 集群</strong>：已成功绑定，可通过 Kuboard 管理</li>\n</ul>\n<hr />\n<h2 id=\"参考资源\">参考资源</h2>\n<ul>\n<li>Kuboard 官网：<a href=\"https://kuboard.cn\" rel=\"noopener nofollow\" target=\"_blank\">https://kuboard.cn</a></li>\n<li>K3s 官网：<a href=\"https://k3s.io\" rel=\"noopener nofollow\" target=\"_blank\">https://k3s.io</a></li>\n<li>Docker 官网：<a href=\"https://www.docker.com\" rel=\"noopener nofollow\" target=\"_blank\">https://www.docker.com</a></li>\n<li>SecureCRT 官网：<a href=\"https://www.vandyke.com/products/securecrt/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.vandyke.com/products/securecrt/</a></li>\n</ul>\n<hr />\n<p><strong>作者</strong>：技术博客<br />\n<strong>日期</strong>：2026-01-29<br />\n<strong>版本</strong>：v1.0</p>\n<hr />\n<h2 id=\"附录\">附录</h2>\n<h3 id=\"a-完整的安装脚本\">A. 完整的安装脚本</h3>\n<p>参考 <a href=\"#%E4%B8%89%E5%AE%89%E8%A3%85-kuboard\" rel=\"noopener nofollow\">三、安装 Kuboard</a> 中的 <code>install.sh</code></p>\n<h3 id=\"b-nginx-完整配置\">B. nginx 完整配置</h3>\n<p>参考 <a href=\"#%E5%9B%9B%E8%A7%A3%E5%86%B3-404-%E9%97%AE%E9%A2%98\" rel=\"noopener nofollow\">四、解决 404 问题</a> 中的 nginx 配置</p>\n<h3 id=\"c-端口说明\">C. 端口说明</h3>\n<table>\n<thead>\n<tr>\n<th>端口</th>\n<th>用途</th>\n<th>协议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>41878</td>\n<td>Kuboard Web 界面</td>\n<td>HTTP</td>\n</tr>\n<tr>\n<td>10081</td>\n<td>Kuboard Agent 通信</td>\n<td>TCP/UDP</td>\n</tr>\n<tr>\n<td>6443</td>\n<td>K3s API Server</td>\n<td>HTTPS</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"d-目录结构\">D. 目录结构</h3>\n<pre><code>/data/kuboard/              # Kuboard 数据目录\n├── etcd-data/              # etcd 数据\n├── questdb/                # QuestDB 数据\n└── ...\n\n/etc/rancher/k3s/           # K3s 配置目录\n└── k3s.yaml                # K3s kubeconfig\n\n/tmp/kuboard-offline/       # 离线安装包\n├── docker/\n├── images/\n└── install.sh\n</code></pre>\n<hr />\n<p><strong>感谢阅读！如有问题，欢迎留言讨论。</strong> 🎉</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 14:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ghostmen\">ghostmen</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从零开始搭建部署 Moltbot/Clawdbot 完整攻略",
      "link": "https://www.cnblogs.com/aigclabs/p/19548083",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aigclabs/p/19548083\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 13:48\">\n    <span>从零开始搭建部署 Moltbot/Clawdbot 完整攻略</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>Moltbot（原名 Clawdbot）是 2026 年 1 月突然爆火的开源个人 AI 助手项目，由 Peter Steinberger（PSPDFKit 创始人）开发。</p>\n<p>Moltbot 是一个把&nbsp;<strong>本地算力 + 大模型 Agent 自动化</strong>&nbsp;玩到极致的开发者效率工具。</p>\n<p>Moltbot 目标是让 AI 不只是给建议，而是直接完成完整工程任务。</p>\n<div class=\"wp-caption alignnone\" id=\"attachment_9050\"><img alt=\"Moltbot\" class=\"size-full wp-image-9050 lazyload\" height=\"364\" width=\"1165\" />\n<div class=\"google-auto-placed ap_container\"><ins class=\"adsbygoogle adsbygoogle-noablate\">\n<div id=\"aswift_5_host\"></div>\n</ins></div>\n<p class=\"wp-caption-text\" id=\"caption-attachment-9050\">Moltbot</p>\n</div>\n<div class=\"auto-hide-last-sibling-br paragraph-vM4cn4 paragraph-element\">\n<p>Moltbot/Clawdbot 是一款功能全面的 AI 助手框架，核心能力涵盖以下维度：</p>\n<div class=\"container-XbLssQ md-box-line-break wrapper-GTUtdt undefined\">&nbsp;</div>\n<p>🤖&nbsp;<strong>多模型兼容</strong>：无缝对接 MiniMax、Claude、GLM、GPT 等主流大语言模型，灵活满足不同场景需求；</p>\n<div class=\"container-XbLssQ md-box-line-break wrapper-GTUtdt undefined\">&nbsp;</div>\n<p>💬&nbsp;<strong>多平台适配</strong>：支持与 WhatsApp、Telegram、Discord 等热门社交 / 通讯平台集成，实现跨平台交互；</p>\n<div class=\"container-XbLssQ md-box-line-break wrapper-GTUtdt undefined\">&nbsp;</div>\n<p>🛠️&nbsp;<strong>丰富工具生态</strong>：内置浏览器访问、文件系统操作、代码自动生成等实用工具，提升任务处理效率；</p>\n<div class=\"container-XbLssQ md-box-line-break wrapper-GTUtdt undefined\">&nbsp;</div>\n<p>🔧&nbsp;<strong>可拓展技能体系</strong>：支持自定义技能开发与接入，轻松扩展框架功能边界。</p>\n</div>\n<h2 class=\"header-uz7uol auto-hide-last-sibling-br\" id=\"toc_1\">版本说明</h2>\n<ul class=\"auto-hide-last-sibling-br\">\n<li><strong>Moltbot</strong>：框架官方标准名称，当前最新版本统一使用此名称对应的命令；</li>\n<li><strong>Clawdbot</strong>：框架旧版本使用的命令标识，部分长期用户可能仍沿用该称呼。</li>\n</ul>\n<div class=\"auto-hide-last-sibling-br paragraph-vM4cn4 paragraph-element\">本教程操作指引均以&nbsp;<strong>moltbot</strong>&nbsp;命令为准，若为 Clawdbot 旧版本用户，将教程中的命令替换为 Clawdbot 对应命令即可正常使用。</div>\n<div>\n<p>因为 Anthropic 在 1 月 27 日发律师函称 Clawd / Clawdbot与 Claude 太像，项目在当天紧急更名为 Moltbot（脱皮龙虾之意，吉祥物是小龙虾 Molty 🦞），但功能完全一致，旧命令 clawdbot 仍然兼容。</p>\n<div class=\"google-auto-placed ap_container\"><ins class=\"adsbygoogle adsbygoogle-noablate\">\n<div id=\"aswift_6_host\"></div>\n</ins></div>\n<p>与传统对话式大模型工具不同，它强调：</p>\n<ul>\n<li>任务自动规划（Planning）</li>\n<li>本地执行（Shell、文件系统、代码操作）</li>\n<li>失败反思与自修复（Reflection Loop）</li>\n</ul>\n<hr />\n<h2 id=\"toc_2\">安装方法</h2>\n<p><a href=\"https://app.qiip.cc/9049.html\" rel=\"noopener nofollow\" target=\"_blank\">https://app.qiip.cc/9049.html</a></p>\n<p>Moltbot 的安装被设计得极为友好，即使是非开发者也能快速上手。</p>\n</div>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/aigclabs/\" target=\"_blank\">AIGC实验室</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/aigclabs/p/19548083\" target=\"_blank\">https://www.cnblogs.com/aigclabs/p/19548083</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 13:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aigclabs\">AIGC实验室</a>&nbsp;\n阅读(<span id=\"post_view_count\">18</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}