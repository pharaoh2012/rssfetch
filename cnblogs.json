{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "棒棒糖图：当条形图遇上极简美学",
      "link": "https://www.cnblogs.com/wang_yb/p/19464212",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19464212\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 08:42\">\n    <span>棒棒糖图：当条形图遇上极简美学</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>棒棒糖图</strong>（Lollipop Chart）可以看作是条形图的一种“轻盈版”变体：它用一根从基准线延伸出来的“棒”，并在末端以一个“糖”（圆点）来表示数值，取代了传统的矩形条。</p>\n<p>这种图表传达的信息与条形图是一样的，但它更注重突出数据点的位置，整体看起来更加清新、现代。</p>\n<p>今天，我们一起探索棒棒糖图的优势，并通过代码实现，亲手打造一个属于自己的棒棒糖图！</p>\n<h1 id=\"设计原理\">设计原理</h1>\n<p>设计棒棒糖图的初衷有两个方面：</p>\n<p>首先，通过减少图形中的“墨水”使用量，在面对大量类别或数值普遍较高的情况下，避免了条形图过于密集可能带来的<strong>视觉压迫感</strong>和<strong>杂乱无章</strong>的感觉；</p>\n<p>其次，这样的设计能够更好地引导观察者的注意力集中在各个数据点的具体位置及其之间的差异上，非常适合用来进行排名或者对比分析。</p>\n<p><strong>棒棒糖图</strong>与<strong>条形图</strong>在功能上是等价的，也并不总是优于条形图。</p>\n<p>当处理大量类别、条柱非常高且相互之间距离较近的数据时，棒棒糖图会显得更加易于阅读理解；</p>\n<p>然而，在需要强调绝对数量或是希望获得最为直观长度比较的情况下，条形图依然是更好的选择。</p>\n<h1 id=\"实现原理\">实现原理</h1>\n<p><strong>棒棒糖图</strong>在<code>matplotlib</code>库中没有直接对应的类。</p>\n<p>不过，它的实现原理非常简单，通过组合使用 <code>matplotlib</code> 中的两个基本绘图功能就可以实现：</p>\n<ol>\n<li><strong>绘制线条</strong> (<code>plt.vlines</code>)：这是构成棒棒糖“棍子”部分的关键。</li>\n</ol>\n<p><code>plt.vlines</code> 函数用于在图表上绘制垂直线段。通过指定每个数据点的 x 坐标、线条的起始点（通常是 0）和结束点（即对应数据的 y 值），就可以画出从 x 轴延伸到数据值的线条。</p>\n<ol start=\"2\">\n<li><strong>绘制圆点</strong> (<code>plt.scatter</code>)：这是构成棒棒糖“糖”部分的关键。</li>\n</ol>\n<p><code>plt.scatter</code> 函数用于绘制散点图。通过将每个数据点的 x 坐标和 y 坐标（即数据值）作为参数传入，就可以在每条线的顶端绘制一个圆点。</p>\n<p>总的来说，<strong>实现原理</strong>就是：用线条表示数值的大小，用圆点强调数值的终点位置，两者结合就形成了视觉上类似棒棒糖的图表。</p>\n<p>这种组合方式使得图表比实心的条形图更简洁，同时又能清晰地传达数据信息。</p>\n<p>下一节的示例中，将会演示如何使用<code>matplotlib</code>来绘制<strong>棒棒糖图</strong>。</p>\n<h1 id=\"应用示例\">应用示例</h1>\n<p>接下来，让我们通过实际的对比示例，直观地感受棒棒糖图与传统条形图的不同表现。</p>\n<h2 id=\"适合棒棒糖图的场景\">适合棒棒糖图的场景</h2>\n<pre><code class=\"language-python\"># 创建更多类别的测试数据\n# 模拟不同月份中每天的某个指标（例如：每日平均步数，单位：千步）\ndays = [f\"Day {i}\" for i in range(1, 21)]  # 生成 20 天的数据\nnp.random.seed(42)  # 设置随机种子，确保每次运行结果一致\n# 生成 1 到 5 之间的随机数值作为示例数据\nvalues = np.round(np.random.uniform(1.0, 5.0, size=len(days)), 1)\n\n# --- 创建子图 ---\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))  # 调整为垂直布局，方便比较\n\n# --- 绘制条形图 (上图) ---\nbars = ax1.bar(days, values, color=\"skyblue\", edgecolor=\"navy\", linewidth=0.7)\nax1.set_title(\"条形图 (Bar Chart) - 每日步数\", fontsize=14)\nax1.set_ylabel(\"数值 (千步)\")\n# ax1.set_xlabel('日期') # x轴标签已在下方图中\nax1.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n# 在条形图上添加数值标签\nfor bar, val in zip(bars, values):\n    height = bar.get_height()\n    ax1.text(\n        bar.get_x() + bar.get_width() / 2.0,\n        height + 0.05,\n        f\"{val}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=8,\n    )  # 标签旋转90度节省空间\n\n# --- 绘制棒棒糖图 (下图) ---\n# 1. 绘制线条\nax2.vlines(x=range(len(days)), ymin=0, ymax=values, color=\"navy\", linewidth=2)\n# 2. 在线条顶部绘制圆点\nax2.scatter(x=range(len(days)), y=values, color=\"red\", s=50, zorder=3)\n# 3. 添加数值标签\nfor i, val in enumerate(values):\n    ax2.text(i, val + 0.1, f\"{val}\", ha=\"center\", va=\"bottom\", fontsize=8)\n\nax2.set_title(\"棒棒糖图 (Lollipop Chart) - 每日步数\", fontsize=14)\nax2.set_ylabel(\"数值 (千步)\")\nax2.set_xlabel(\"日期\")\nax2.set_xticks(range(len(days)))\nax2.set_xticklabels(days, rotation=45, ha=\"right\")  # 旋转x轴标签以便阅读\nax2.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\nax2.set_ylim(0, max(values) * 1.1)\n\n# --- 显示图形 ---\nplt.tight_layout()  # 调整子图间距\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260110084120492-216729079.png\" /></p>\n<p>这个示例使用了20个数据类别（Day 1 到 Day 20）。</p>\n<p>你可以看到，在条形图中，许多蓝色的条形紧密地排列在一起，视觉上显得有些拥挤。</p>\n<p>而在棒棒糖图中，线条和圆点使得数据点之间的关系更加清晰，整体视觉效果更轻盈，更容易比较各个数值的大小和识别模式。</p>\n<h2 id=\"适合传统条形图的场景\">适合传统条形图的场景</h2>\n<pre><code class=\"language-python\"># 创建更适合条形图的测试数据\n# 模拟某公司连续12个月的销售额（单位：万元）\nmonths = [\n    \"1月\",\n    \"2月\",\n    \"3月\",\n    \"4月\",\n    \"5月\",\n    \"6月\",\n    \"7月\",\n    \"8月\",\n    \"9月\",\n    \"10月\",\n    \"11月\",\n    \"12月\",\n]\n# 生成有一定趋势和波动的销售额数据，例如有季节性高峰\nsales = [120, 110, 135, 140, 155, 170, 185, 180, 160, 150, 145, 165]\n\n# --- 创建子图 ---\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))\n\n# --- 绘制条形图 (左图) ---\nbars = ax1.bar(months, sales, color=\"lightsteelblue\", edgecolor=\"black\", linewidth=0.7)\nax1.set_title(\"条形图 (Bar Chart - 月份销售额)\", fontsize=14)\nax1.set_ylabel(\"销售额 (万元)\")\nax1.set_xlabel(\"月份\")\nax1.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n# 在条形图上添加数值标签\nfor bar, s in zip(bars, sales):\n    height = bar.get_height()\n    ax1.text(\n        bar.get_x() + bar.get_width() / 2.0,\n        height + 2,\n        f\"{s}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=9,\n    )\n\n# --- 绘制棒棒糖图 (右图) ---\nax2.vlines(x=range(len(months)), ymin=0, ymax=sales, color=\"gray\", linewidth=2)\nax2.scatter(x=range(len(months)), y=sales, color=\"coral\", s=50, zorder=3)\nfor i, s in enumerate(sales):\n    ax2.text(i, s + 3, f\"{s}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nax2.set_title(\"棒棒糖图 (Lollipop Chart - 月份销售额)\", fontsize=14)\nax2.set_ylabel(\"销售额 (万元)\")\nax2.set_xlabel(\"月份\")\nax2.set_xticks(range(len(months)))\nax2.set_xticklabels(months, rotation=45)  # 旋转x轴标签以防重叠\nax2.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\nax2.set_ylim(0, max(sales) * 1.1)\n\n# --- 显示图形 ---\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260110084120515-917001944.png\" /></p>\n<p>在这个示例中，数据代表的是连续的月份，数值本身代表的是销售额，这是一个“量”的概念。</p>\n<p>条形图的实心块能让人立刻感受到哪个月份的销售额更高，整体的分布和对比关系一目了然。</p>\n<p>而棒棒糖图虽然也展示了数据，但线条和圆点的组合在视觉上不如实心条形那样能直接传达“量”的感觉，尤其是在数值差异不是特别巨大时，对比效果会稍逊于条形图。</p>\n<h1 id=\"总结\">总结</h1>\n<p><strong>棒棒糖图</strong>就像数据可视化世界中的\"少即是多\"哲学体现。</p>\n<p>它不是要取代传统条形图，而是为数据可视化工具箱增加了一个有价值的选项。</p>\n<p>就像不同的画笔适合不同的绘画风格，不同的图表类型也适合不同的数据故事。</p>\n<p><strong>棒棒糖图</strong>的真正优势在于它改变了数据的<strong>\"讲述方式\"</strong>。</p>\n<p>它不说：\"这是所有信息，你自己找重点\"，而是说：\"看这里，这些是关键点\"。</p>\n<p>这种焦点导向的特性，使得棒棒糖图在现代快节奏的数据沟通中越来越受欢迎。</p>\n<p>设计可视化时，我们不妨问问自己：我想要观众首先看到什么？如果是精确的数值点和清晰的排名，那么棒棒糖图可能是你的理想选择。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 08:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Thread 类的基本用法、Java 线程的几种状态",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19463416",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19463416\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 00:05\">\n    <span>Thread 类的基本用法、Java 线程的几种状态</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"在java中thread类是多线程编程的核心\">在Java中，Thread类是多线程编程的核心。</h3>\n<h4 id=\"线程创建-thread-creation\">线程创建 (Thread Creation)</h4>\n<ul>\n<li>创建线程主要有两种逻辑：继承Thread类或实现Runnable接口。\n<ul>\n<li>方式1：继承 Thread 类，重写run()</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-java\">// 自定义线程类继承Thread\nclass MyThread extends Thread {\n    // 重写run()，定义线程执行逻辑\n    @Override\n    public void run() {\n        System.out.println(\"子线程执行：\" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread t = new MyThread();\n        t.start(); // 3. 调用start()启动线程（不能直接调用run()）\n    }\n}\n</code></pre>\n<ul>\n<li>方式2：实现Runnable接口，传给Thread</li>\n</ul>\n<pre><code class=\"language-java\">// 实现Runnable接口\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"子线程执行：\" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\npublic class Demo {\n    public static void main(String[] args) {\n        // 把Runnable实例传给Thread\n        Thread t = new Thread(new MyRunnable());\n        t.start(); // 启动线程\n    }\n}\n</code></pre>\n<h4 id=\"线程中断-thread-interruption\">线程中断 (Thread Interruption)</h4>\n<ul>\n<li>线程中断不是强制停止线程，而是一种协作机制，即给线程发一个“请停止”的信号。</li>\n<li>void interrupt()：标记线程为 “中断状态”</li>\n<li>boolean isInterrupted()：判断线程是否处于中断状态</li>\n<li>若线程在sleep/wait/join时被中断，会抛出InterruptedException，且中断状态会被清除</li>\n</ul>\n<pre><code class=\"language-java\">Thread t = new Thread(() -&gt; {\n    while (!Thread.currentThread().isInterrupted()) { // 检测中断状态\n        System.out.println(\"线程运行中...\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // 捕获中断异常后，中断状态会被清除，需手动终止循环\n            System.out.println(\"线程被中断\");\n            Thread.currentThread().interrupt(); // 重新标记中断（可选）\n            break;\n        }\n    }\n});\nt.start();\n// 主线程1秒后中断子线程\nThread.sleep(1000);\nt.interrupt();\n</code></pre>\n<h4 id=\"线程等待-thread-join\">线程等待 (Thread Join)</h4>\n<ul>\n<li>有时主线程需要等待子线程执行完毕后再继续执行，这时可以使用join()。</li>\n<li>t.join()：当前线程会进入阻塞状态，直到线程t执行结束。</li>\n<li>带参数的 join(long millis)：设置最大等待时间，如果超时线程还没结束，当前线程就不再等待。</li>\n</ul>\n<pre><code class=\"language-java\">Thread t = new Thread(() -&gt; {\n    System.out.println(\"子线程开始执行\");\n    try { Thread.sleep(2000); } catch (InterruptedException e) {}\n    System.out.println(\"子线程执行完毕\");\n});\nt.start();\n\n// 主线程等待t执行完（最多等3秒）\nt.join(3000); \nSystem.out.println(\"主线程继续执行\");\n</code></pre>\n<h4 id=\"线程休眠-thread-sleep\">线程休眠 (Thread Sleep)</h4>\n<ul>\n<li>static void sleep(long millis)：让当前线程暂停指定时间（不会释放锁），抛出InterruptedException</li>\n</ul>\n<pre><code class=\"language-java\">System.out.println(\"开始休眠\");\ntry {\n    Thread.sleep(2000); // 当前线程休眠2秒\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.println(\"休眠结束\");\n</code></pre>\n<h4 id=\"获取线程实例-get-current-instance\">获取线程实例 (Get Current Instance)</h4>\n<ul>\n<li>在编写通用代码（尤其是 Runnable 中）时，常需要知道是谁在运行。</li>\n<li>Thread.currentThread()：返回代码当前正在执行的那个线程对象的引用。</li>\n<li>常用操作：获取线程 ID (getId())、获取线程名称 (getName()) 等。</li>\n</ul>\n<pre><code class=\"language-java\">// 获取当前线程（这里是main线程）\nThread mainThread = Thread.currentThread();\nSystem.out.println(\"当前线程名：\" + mainThread.getName()); // 输出\"main\"\n\n// 子线程实例\nThread t = new Thread(() -&gt; {\n    Thread current = Thread.currentThread();\n    System.out.println(\"子线程名：\" + current.getName()); // 输出\"Thread-0\"\n});\nt.start();\n</code></pre>\n<hr />\n<h3 id=\"java线程的几种状态\">Java线程的几种状态</h3>\n<h4 id=\"线程状态一共有几种\">线程状态一共有几种？</h4>\n<ul>\n<li>Java线程共有6种状态：\n<ul>\n<li>NEW (新建)</li>\n<li>RUNNABLE (可运行)</li>\n<li>BLOCKED (阻塞)</li>\n<li>WAITING (等待)</li>\n<li>TIMED_WAITING (超时等待)</li>\n<li>TERMINATED (终止)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"每种状态的含义与切换条件\">每种状态的含义与切换条件</h4>\n<ol>\n<li>NEW (新建)</li>\n</ol>\n<ul>\n<li>含义：创建了线程对象（new Thread()），但尚未调用 start() 方法。</li>\n<li>切换：调用 start() 方法后，进入 RUNNABLE 状态。</li>\n</ul>\n<ol start=\"2\">\n<li>RUNNABLE (可运行)</li>\n</ol>\n<ul>\n<li>含义：Java 将操作系统中的“就绪（Ready）”和“运行中（Running）”两种状态统称为 RUNNABLE。处于该状态的线程可能正在 CPU 上执行，也可能正在等待操作系统分配时间片。</li>\n<li>切换：\n<ul>\n<li>就绪 -&gt; 运行：获得 CPU 时间片。</li>\n<li>运行 -&gt; 就绪：CPU 时间片用完，或主动调用 Thread.yield()。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>BLOCKED (阻塞)</li>\n</ol>\n<ul>\n<li>含义：线程正在等待获取一个排他锁（如进入synchronized 代码块/方法），但该锁目前被其他线程持有。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; BLOCKED：尝试进入 synchronized 区域失败。</li>\n<li>BLOCKED -&gt; RUNNABLE：其他线程释放锁，当前线程成功竞争到锁。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li>WAITING (等待)</li>\n</ol>\n<ul>\n<li>含义：线程处于无限期的等待状态，不会被分配 CPU 时间，必须等待其他线程显式地唤醒。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; WAITING：调用 Object.wait()（不带参数）、Thread.join()（不带参数）或 LockSupport.park()。</li>\n<li>WAITING -&gt; RUNNABLE：其他线程调用 Object.notify()、notifyAll() 或 LockSupport.unpark()。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>TIMED_WAITING (超时等待)</li>\n</ol>\n<ul>\n<li>含义：与 WAITING 类似，但在指定的时间后会自动唤醒，不需要其他线程显式唤醒。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; TIMED_WAITING：调用 Thread.sleep(ms)、Object.wait(ms)、Thread.join(ms) 等带时间参数的方法。</li>\n<li>TIMED_WAITING -&gt; RUNNABLE：时间结束，或被提前唤醒（如 notify()）。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"6\">\n<li>TERMINATED (终止)</li>\n</ol>\n<ul>\n<li>含义：线程已经执行完毕（run() 方法正常结束）或因异常退出了执行。</li>\n<li>切换：线程一旦进入此状态，生命周期结束，不可再次启动（再次调用 start() 会抛出异常）。</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 00:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "初识Tauri",
      "link": "https://www.cnblogs.com/-867259206/p/19463606",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/-867259206/p/19463606\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 23:24\">\n    <span>初识Tauri</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简述\">简述</h1>\n<p>Tauri是一个跨平台的开发框架，使用rust开发。前端用前端技术构建用户界面，后端使用rust和平台系统交互。</p>\n<h2 id=\"创建项目\">创建项目</h2>\n<p>可以用Bash/PowerShell/Fish/npm/deno/Cargo等工具创建项目。</p>\n<p>下面以pnpm示例：</p>\n<pre><code class=\"language-bash\">pnpm create tauri-app\n</code></pre>\n<p>后面的步骤和创建前端项目是一样的。根据提示选择前端的语言、框架等等。</p>\n<p>项目目录和前端项目也是一样的，只是多了一个src-tauri目录。</p>\n<p>src-tauri目录下就是rust代码，可以在里面编写供前端调用的方法，或者是给前端发送事件消息。</p>\n<p>界面的开发使用前端技术，可以用react，也可以用vue，或者其他前端框架。与平台系统交互的功能，用rust编写。</p>\n<p>对Web开发者来说，用这个技术可以快速地创建桌面应用。</p>\n<h2 id=\"发布\">发布</h2>\n<p>要打包成桌面应用的话，执行build命令就好。</p>\n<p>继续以pnpm为例：</p>\n<pre><code class=\"language-bash\">pnpm tauri build\n</code></pre>\n<blockquote>\n<p>提示：build之前要先安装rust环境</p>\n</blockquote>\n<p>目前Tauri支持Linux、macOS、Windows、Android、iOS。</p>\n<p>打包后的启动程序在src-tauri/target/release/bundle目录下。执行安装程序，安装好后，就可以打开编写的桌面应用了。</p>\n<h1 id=\"架构\">架构</h1>\n<p><img alt=\"架构\" class=\"lazyload\" />Tauri的核心包含一个Tauri的运行时，tauri-runtime在tauri本身和底层的webview抽象层中充当一个胶水层。</p>\n<p>Tauri使用WRY这个开源库做webview的抽象层。WRY是一个rust编写的webview渲染库，可以支持各种平台的桌面应用。在WRY和tauri-runtime之间，有一个tauri-runtime-wry，这一层为WRY定义了系统级的交互。</p>\n<p>而WRY的下层依赖TAO。TAO是基于winit的一个fork。这是一个rust编写的跨平台的窗口管理类库。支持几乎所有的主流平台，Windows、Linux、Mac OS、Android、iOS……</p>\n<p>最后简单总结：Tauri实现跨平台应用的方式是，实现一个webview的抽象，从而可以用前端技术编写GUI，webview抽象层的底层，则依赖rust的窗口管理类库，调用各个平台系统的webview库。</p>\n<h1 id=\"总结\">总结</h1>\n<p>用rust作后端，使Tauri有很高的性能。但是调用平台系统本身webview的跨平台方式，使GUI在不同平台上的表现不一致，有兼容性问题。</p>\n<p>和electron相比，拥有更小的包体积，因为没有打包chromium，也没有源码泄露之类的风险，性能也更好，还能打包移动端，但是会有兼容性问题，而且后端用rust的话，不如electron好上手，如果不是rust熟手的话。</p>\n<p>和flutter相比，同样有兼容性问题，dart也比rust好学。</p>\n<p>对rust开发者来说，只需要找rust的GUI库就行，没有必要去用前端编写GUI。而对前端开发者来说，rust又增加了开发的学习成本。这个框架，感觉只适合同时会rust的前端熟手。而且只有少数对性能要求较高的场景会需要使用，其他场景electron也不差。如果要开发跨平台的应用，兼容性又是一个问题。实际的产品表现，肯定不如flutter这类框架。</p>\n<p>在前端工具链也越来越多使用rust语言的时候，Tauri这些rust编写的框架也被一些前端开发者所使用。但如果我要开发一个跨平台的应用的话，我觉得自带绘图库的flutter的方案是最佳的。Tauri的兼容性问题，仍不能满足做商业应用的要求，能使用的场景太少了。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 23:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/-867259206\">池月</a>&nbsp;\n阅读(<span id=\"post_view_count\">20</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款基于 .NET 9 构建的企业级 Web RBAC 快速开发框架",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19463583",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19463583\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 23:03\">\n    <span>一款基于 .NET 9 构建的企业级 Web RBAC 快速开发框架</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>今天大姚给大家分享一款基于 .NET 9 构建的企业级、开源 Web RBAC 快速开发框架：RuYiAdmin。</span></p>\n<h2><span>项目介绍</span></h2>\n<p><span>RuYiAdmin 一款基于 .NET 9 构建的企业级、前后端分离、开源（Apache License） Web RBAC 快速开发框架，具有灵活的架构设计和强大的功能，适用于快速开发高性能的企业级应用，具有低代码、跨平台、分布式、多线程和高性能等特色。</span></p>\n<h2><span>适用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><span>企业级后台管理系统：用于企业内部的各种管理任务，如用户管理、权限控制、数据统计等。</span></li>\n<li><span>内容管理系统（CMS）：用于网站内容的创建、编辑、发布和管理。</span></li>\n<li><span>客户关系管理（CRM）系统：帮助企业跟踪和管理客户信息、销售机会和客户服务请求。</span></li>\n</ul>\n<h2><span>主要特点</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>前后端分离：</strong><span>&nbsp;RuYiAdmin 采用前后端分离架构，前端基于VueElementAdmin，使用 Vue2 和 Element UI，后端基于 .NET 9 构建。</span></li>\n<li><strong>代码自动生成：</strong><span>&nbsp;支持一键生成视图层、控制层、服务层、仓储层、领域层和 DTO 业务模型层代码，极大地缩短了开发周期。</span></li>\n<li><strong>多数据库支持：</strong><span>&nbsp;支持多种关系型数据库（如 MySQL、SqlServer、SQLite、Oracle、PostgreSQL、OpenGauss、<span>Kingbase、DM）和非关系型数据库（如 Redis、MongoDB、Elasticsearch、Meilisearch），同时支持动态数据源，以满足不同企业的需求。</span></span></li>\n<li><strong>项目安全性高：</strong><span>&nbsp;支持4A等级认证，满足等保三级要求，支持防 SQL 注入、防 Token 劫持、防接口渗透与抖动，集成RSA、AES及国产 SM 加密算法，支持全链路HTTPS加密传输协议，确保企业级应用的安全性。</span></li>\n<li><span>支持微服务，支持服务的注册、发现、健康检查、熔断和降级。</span></li>\n</ul>\n<h2><span>项目技术栈</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><span>前端：Vue2、Element UI、Node.js等。</span></li>\n<li><span>后端：C#、.NET 9、AspNetCoreRateLimit、<span>SqlSugar、AutoMapper、SignalR、MiniProfiler、CAP、RabbitMQ、Redis、Consul等。</span></span></li>\n</ul>\n<h2><span>安装教程</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109225902010-549085141.png\" /></p>\n<h2><span>软件架构图</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109225914600-2077383226.png\" /></p>\n<h2><span>项目源代码</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230143000-1636008500.png\" /></p>\n<h2><span>项目效果截图</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230153456-1478242349.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230157723-87615533.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230203615-1395111698.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230210957-1745363029.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230216437-1329007995.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230222905-1152283619.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230230693-1691017440.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205853857-1849985119.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205859134-1945950810.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230248378-53584818.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230253718-384227715.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205908099-602806087.png\" /></p>\n<h2><span>项目源码地址</span></h2>\n<p><span>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/pang-mingjun/RuYiAdmin\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/pang-mingjun/RuYiAdmin</span></a></li>\n</ul>\n<h2><span>优秀项目和框架精选</span></h2>\n<p><span>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong><span>）。</span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>GitHub开源地址：</strong><a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n</ul>\n<div id=\"gtx-trans\">&nbsp;</div>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 23:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">49</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2026.1.9 闲话：DAG 计数",
      "link": "https://www.cnblogs.com/QEDQEDQED/p/19463492",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/QEDQEDQED/p/19463492\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 22:09\">\n    <span>2026.1.9 闲话：DAG 计数</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本人以后的学习笔记会尽量以闲话形式发出，避免对初学者造成困惑。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"19-闲话dag-计数\">1.9 闲话：DAG 计数</h1>\n<blockquote>\n<p>本人以后的学习笔记会尽量以闲话形式发出，避免对初学者造成困惑。</p>\n</blockquote>\n<p>超前情提要：jijidawang 和 xrlong 强烈推荐主旋律。</p>\n<p>前情提要：吃饭的时候，bjt 和 zxk 让我写主旋律，我果断接受了学习这道题的任务（</p>\n<p>但是由于抄了好几天的题解了，于是自己手推了一下，和自己搏斗了 INF 年，最终成功击败主旋律，写此题解纪念一下。</p>\n<h2 id=\"dag-容斥\">DAG 容斥</h2>\n<p>不是，这东西到底有啥用啊？上不如集合划分容斥，下不如子集反演。</p>\n<p>直接上子集反演推法了。</p>\n<p>由于一个 DAG 具有良好的递归子问题性质，假设现在有一个 DAG，那么删除所有入度为 0 的点后还是一个 DAG，可以发现如果这样构造出 DAG 的话是不重不漏的。</p>\n<p>下文的零度点指的就是入度为 0 的点。</p>\n<p>那么有一个简单的思路就是枚举所有的零度点转移，剩下的单独构成一个 DAG，列出简单的一个式子，假设 <span class=\"math inline\">\\(v(S, T)\\)</span> 表示从集合 <span class=\"math inline\">\\(S\\)</span> 到集合 <span class=\"math inline\">\\(T\\)</span> 的连边方案数，那么有：</p>\n<p></p><div class=\"math display\">\\[f_S = \\sum_{\\varnothing \\subset T \\subseteq S}v(T, S - T)f_T\n\\]</div><p></p><blockquote>\n<p>显然我们的转移不可能从滚木集合转移过来。</p>\n</blockquote>\n<p>其中 <span class=\"math inline\">\\(S - T\\)</span> 表示对称差。</p>\n<p>可是这样实在是有点自欺欺人了，我们发现一件惊恐的事情，就是 <span class=\"math inline\">\\(T\\)</span> 里也可能有零度点。</p>\n<p>假设现在处在 <span class=\"math inline\">\\(S\\)</span> 这个大的点集之下考虑，设 <span class=\"math inline\">\\(g_T\\)</span> 表示恰好 <span class=\"math inline\">\\(T\\)</span> 为零度点的方案数，<span class=\"math inline\">\\(h_T\\)</span> 表示钦定 <span class=\"math inline\">\\(T\\)</span> 为零度点的方案数。</p>\n<p>由于：</p>\n<p></p><div class=\"math display\">\\[h_T = \\sum_{T \\subseteq U \\subseteq S}{g_U} = v(T, S - T)f_{S - T}\n\\]</div><p></p><p>通过子集反演可得：</p>\n<p></p><div class=\"math display\">\\[g_T = \\sum_{T \\subseteq U \\subseteq S}{(-1)^{|U| - |T|}h_U} = \\sum_{T \\subseteq U \\subseteq S}{(-1)^{|U| - |T|}v(U, S - U)f_{S - U}}\n\\]</div><p></p><p>然后枚举一下零度点再推推式子就得到了：</p>\n<p><span class=\"math inline\">\\(\\begin{aligned}\nf_S &amp;= \\sum_{\\varnothing \\subset T \\subseteq S}{\\sum_{T \\subseteq U \\subseteq S}{(-1)^{|U| - |T|}v(U, S - U)f_{S - U}}} \\\\\n&amp;= \\sum_{\\varnothing \\subset U \\subseteq S}v(U, S - U)f_{S - U}\\sum_{\\varnothing \\subset T \\subseteq U}{{(-1)^{|U| - |T|}}} \\\\\n&amp;= \\sum_{\\varnothing \\subset U \\subseteq S}v(U, S - U)f_{S - U}(-1)^{|U|}(\\sum_{T \\subseteq U}{{(-1)^{|T|}}} - 1) \\\\\n&amp;= \\sum_{\\varnothing \\subset T \\subseteq S}(-1)^{|T| + 1}v(T, S - T)f_{S - T}\n\\end{aligned}\n\\)</span></p>\n<p>这就是经典的 DAG 容斥系数 <span class=\"math inline\">\\((-1)^{|T| + 1}\\)</span> 的一种推法了。</p>\n<p>个人感觉对于这类问题是多变的，所以会一个好理解的简单做法现场重新推一遍是最好的，就比如下面的主旋律，其形式并不相同。</p>\n<p>比起一些需要理解的做法，这个肯定是很简单的了。</p>\n<p>我们可以追溯一下本质，其实这个 <span class=\"math inline\">\\(T\\)</span> 还是在钦定那些点作为零度点，所以其实还是需要乘上一个 <span class=\"math inline\">\\(w_T\\)</span> 表示零度点之间的贡献，不过现在讨论的阶段不存在这个系数。</p>\n<h2 id=\"amusement-park\"><a href=\"https://www.luogu.com.cn/problem/P6846\" rel=\"noopener nofollow\" target=\"_blank\">Amusement Park</a></h2>\n<p>这题其实是需要一步转化的，就是发现对于一个合法的定向方式，其全部翻转后也是合法的，那么所有方案取平均值后就是方案数乘上 <span class=\"math inline\">\\(\\frac{m}{2}\\)</span>。</p>\n<p>其实上面那步是最难的。。。</p>\n<p>然后就是板子了，发现 <span class=\"math inline\">\\(v(S, T)\\)</span> 其实是 1，因为已经定好向了。</p>\n<p>然后 <span class=\"math inline\">\\(w_T\\)</span> 或者说是如果这个枚举的 <span class=\"math inline\">\\(T\\)</span> 不是一个独立集那就不能转移。</p>\n<h2 id=\"有标号-dag-计数\"><a href=\"https://www.luogu.com.cn/problem/P6295\" rel=\"noopener nofollow\" target=\"_blank\">有标号 DAG 计数</a></h2>\n<blockquote>\n<p>注：含多项式内容。</p>\n</blockquote>\n<p>首先要求弱联通，这点很没用，最后对 EGF 上发多项式 ln 即可。</p>\n<p>假设 <span class=\"math inline\">\\(f_i\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 个点构成的 DAG 方案数。</p>\n<p>其中可以得到 <span class=\"math inline\">\\(v(S, T) = 2^{|S||T|}\\)</span></p>\n<p>套用上面的式子得到：</p>\n<p></p><div class=\"math display\">\\[f_i = \\sum_{j = 1}^{i}\\binom{i}{j}f_{i - j}2^{ij}\n\\]</div><p></p><p>这其实本质是将 <span class=\"math inline\">\\(f_S\\)</span> 压缩到了 <span class=\"math inline\">\\(f_{|S|}\\)</span> 这个状态里。</p>\n<p>看着很想半在线卷积，不过还差点。</p>\n<p>由于：<span class=\"math inline\">\\(ij = \\binom{i + j}{2} - \\binom{i}{2} - \\binom{j}{2}\\)</span></p>\n<p></p><div class=\"math display\">\\[f_i = \\sum_{j = 1}^{i}{\\frac{i!}{j!(i - j)!}f_{i - j}\\frac{2^{\\binom{i}{2}}}{2^\\binom{j}{2}2^\\binom{i - j}{2}}}\n\\]</div><p></p><p>更改一下就出现卷积形式了：</p>\n<p></p><div class=\"math display\">\\[\\frac{f_i}{i!2^{\\binom{i}{2}}} = \\sum_{j = 1}^{i}{\\frac{1}{j!2^{\\binom{j}{2}}}\\frac{f_{i - j}}{(i - j)!2^{\\binom{i - j}{2}}}}\n\\]</div><p></p><p>现在得到了这样的形式：</p>\n<p></p><div class=\"math display\">\\[F_i = \\sum_{j = 1}^{i}{G_jF_{i - j}}\n\\]</div><p></p><p>其中 <span class=\"math inline\">\\(G_0 = 0\\)</span> 。</p>\n<p>如果你做过<a href=\"https://www.luogu.com.cn/problem/P4721\" rel=\"noopener nofollow\" target=\"_blank\">分治 FFT</a> 或者<a href=\"https://www.luogu.com.cn/problem/P4723\" rel=\"noopener nofollow\" target=\"_blank\">常系数齐次线性递推</a>的话。</p>\n<p>发现 <span class=\"math inline\">\\(F * G\\)</span> 卷积之后只有 <span class=\"math inline\">\\(x^0\\)</span> 次项系数是错的，加上就行了。</p>\n<p></p><div class=\"math display\">\\[F = F * G + 1\n\\]</div><p></p><p></p><div class=\"math display\">\\[F = \\frac{1}{1 - G}\n\\]</div><p></p><p>最后 ln 成答案就行。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<h2 id=\"主旋律\"><a href=\"https://www.luogu.com.cn/problem/P6295\" rel=\"noopener nofollow\" target=\"_blank\">主旋律</a></h2>\n<p>今日主角。</p>\n<p>首先先不要慌，如果一个图不是强连通图，那么其一定是由一堆强连通分量构成的大于一个点的 DAG。</p>\n<p>于是乎变成了 DAG 计数。</p>\n<p>现在假设 <span class=\"math inline\">\\(f_S\\)</span> 表示 <span class=\"math inline\">\\(S\\)</span> 构成的方案数, <span class=\"math inline\">\\(a_S\\)</span> 表示 <span class=\"math inline\">\\(S\\)</span> 构成的强连通图个数。</p>\n<p>此时转移时 <span class=\"math inline\">\\(v(S, T) = 2^{e(S, T)}\\)</span> 其中 <span class=\"math inline\">\\(e(S, T)\\)</span> 表示从 <span class=\"math inline\">\\(S\\)</span> 指向 <span class=\"math inline\">\\(T\\)</span> 的边数。</p>\n<p>但此时 <span class=\"math inline\">\\(w_T\\)</span> 是有意义的了，因为前面说的那些都是零度点，可这里不一样了，这些是没有入度的强连通分量，所以假设我们现在钦定一堆强连通分量作为零度集团，那么可以自己推一下，根据子集反演可得：如果钦定了 <span class=\"math inline\">\\(cnt\\)</span> 个强连通分量，那么容斥系数应当是 <span class=\"math inline\">\\((-1)^{cnt + 1}\\)</span>。</p>\n<p>如果先不管容斥系数的话，我们的 <span class=\"math inline\">\\(w_T\\)</span> 也是有良好的递归结构的，就是枚举新的强连通分量由那些点构成，但是这样会算重，所以需要钦定最小编号的点在新加入的强连通分量中。</p>\n<p>而容斥系数有什么含义呢，其实就是我们现在新加入一个强连通分量，那么其贡献应当为：<span class=\"math inline\">\\(-1\\)</span> 而非 <span class=\"math inline\">\\(+1\\)</span>。</p>\n<p>式子就是：</p>\n<p></p><div class=\"math display\">\\[w_S = \\sum_{\\varnothing \\subset T \\subseteq S}{-a_Tw_{S - T}}\n\\]</div><p></p><p>然后是 <span class=\"math inline\">\\(f_S\\)</span> 如何求得，由于容斥系数已经算过了，那么直接套用之前的式子：</p>\n<p></p><div class=\"math display\">\\[f_S = \\sum_{\\varnothing \\subset T \\subseteq S}{w_Tf_{S - T}2^{e(T, S - T)}}\n\\]</div><p></p><p></p><div class=\"math display\">\\[a_S = 2^{e(S, S)} - f_S\n\\]</div><p></p><p>不过这里有一个小问题，就是 <span class=\"math inline\">\\(f_S\\)</span> 和 <span class=\"math inline\">\\(w_S\\)</span> 冲突了，但是简单调整一下发现，<span class=\"math inline\">\\(w_S\\)</span> 需要的 <span class=\"math inline\">\\(f_S\\)</span> 其实是 <span class=\"math inline\">\\(a_S\\)</span> 单独形成一个强连通分量，这是不能转移到 <span class=\"math inline\">\\(f_S\\)</span> 里的。</p>\n<p>于是解决方案就是先不转移 <span class=\"math inline\">\\(f_S\\)</span> 对 <span class=\"math inline\">\\(w_S\\)</span> 的贡献，算完 <span class=\"math inline\">\\(f_S\\)</span> 后再算 <span class=\"math inline\">\\(w_S\\)</span>。</p>\n<p>不过这复杂度是 <span class=\"math inline\">\\(O(3^nn^2)\\)</span> 的。</p>\n<p>然后发现一点，就是 <span class=\"math inline\">\\(e(S, T)\\)</span> 其实等于：</p>\n<p></p><div class=\"math display\">\\[e(S, T) = \\sum_{i \\in S}{e(\\{i\\}, T)}\n\\]</div><p></p><p>然后预处理一下 <span class=\"math inline\">\\(e(\\{i\\}, T)\\)</span> 即可。</p>\n<p>精细实现复杂度变成 <span class=\"math inline\">\\(O(3^nn)\\)</span> 或 <span class=\"math inline\">\\(O(3^n)\\)</span>。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 22:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/QEDQEDQED\">QEDQEDQED</a>&nbsp;\n阅读(<span id=\"post_view_count\">34</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （五）门控循环单元 GRU",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19463351",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19463351\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 21:45\">\n    <span>吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （五）门控循环单元 GRU</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第一周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=159\" rel=\"noopener nofollow\" target=\"_blank\">1.9</a>的内容以及一些相关基础的补充。</p>\n<hr />\n<p>本周为第五课的第一周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本篇的内容关于<strong>门控循环单元 GRU</strong>，它通过改变 RNN 的隐藏层，来缓解 RNN 的梯度消失问题。</p>\n<h1 id=\"1-什么是-grugated-recurrent-unit\">1. 什么是 GRU（Gated Recurrent Unit）?</h1>\n<p>在<a href=\"https://www.cnblogs.com/Goblinscholar/p/19458774\" target=\"_blank\">前面的内容里</a>中我们已经提到过：RNN 的核心机制，是<strong>把历史信息压缩进一个不断传递的隐藏状态中</strong>。<br />\n结果就是我们已经分析过的结论：<strong>信息一旦隔得太远，就会在反复的线性变换和非线性映射中被不断稀释</strong>。<br />\n在反向传播时就体现为梯度越来越小，最终几乎传不回去，导致“开头被遗忘”，这就是 RNN 的<strong>长距离依赖问题</strong>。<br />\n显然，这并不是改善训练技巧可以解决的问题，而是 RNN 本身的结构造成的限制，自然而然地就引出了 NLP 领域的新问题 ：<strong>如何缓解 RNN 的长距离依赖问题？ 即如何让模型“记得更久一些”?</strong></p>\n<p>于是，在 2014 年发表的一篇论文： <a href=\"https://aclanthology.org/D14-1179.pdf\" rel=\"noopener nofollow\" target=\"_blank\">On the Properties of Neural Machine Translation: Encoder–Decoder Approaches</a> 中，提出了<strong>一种带有门控机制的循环单元结构</strong>，即后来被称为 <strong>GRU（Gated Recurrent Unit）</strong> 的模型。<br />\n该工作首次在 Encoder–Decoder 框架下系统性地引入 <strong>“更新门”和“重置门”</strong>，通过对隐藏状态的信息流进行选择性控制，从结构层面缓解了传统 RNN 在长序列建模中面临的困难。<br />\n同年的另一篇论文：<a href=\"https://arxiv.org/pdf/1412.3555.pdf\" rel=\"noopener nofollow\" target=\"_blank\">Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling</a>  对其实际效果进行了系统评估。实验结果证明了其优越的性能，这也使其迅速成为实际 NLP 系统中广泛采用的基础循环单元之一。</p>\n<p>出现了很多没见过的名词，别担心，下面我们就来详细展开。</p>\n<h2 id=\"11-gru-的解题思路\">1.1 GRU 的解题思路</h2>\n<p>首先，面对”如何让模型记得更久一些”的问题，GRU给出的答案是：</p>\n<blockquote>\n<p>既然记不住全部，那我能不能<strong>只记重要的？</strong></p>\n</blockquote>\n<p>这是什么意思？回忆一下 普通 RNN 是如何进行记忆的：</p>\n<p></p><div class=\"math display\">\\[新输入来了\\rightarrow旧状态所有信息参与计算\\rightarrow得到一个带有新输入信息的新隐藏状态\n\\]</div><p></p><p>我们已经很熟悉这个过程了：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260109204330405-1786363129.png\" /></p>\n<p><strong>但是，实际上，在真实语言中，我们并不是这样处理信息的。</strong><br />\n举个例子：</p>\n<blockquote>\n<p>“我昨天去北京出差，<br />\n在路上遇到了一个多年未见的朋友，<br />\n<strong>他</strong>现在在……”</p>\n</blockquote>\n<p>当你看到“他”的时候：</p>\n<ul>\n<li>你<strong>不需要</strong>记住“北京”，“昨天”。</li>\n<li>但你<strong>必须</strong>记住“朋友”。</li>\n<li>换句话说，当前时刻的理解，并不依赖于全部历史内容，而只依赖于<strong>与当前判断相关的信息。</strong></li>\n</ul>\n<p>再概括来讲，人脑在处理序列信息时，隐含着一个非常重要的能力：<strong>选择性记忆</strong>。<br />\n而 GRU 的设计，正是将这种“取舍能力”，通过门控结构的形式，<strong>显式地引入到 RNN 的隐藏层更新过程中</strong>。<br />\n简单展开一下，GRU 并没有改变 RNN 的整体框架：</p>\n<ul>\n<li>仍然是时间步 <span class=\"math inline\">\\(t = 1, 2, \\dots\\)</span></li>\n<li>仍然有输入 <span class=\"math inline\">\\(x^{&lt;t&gt;}\\)</span></li>\n<li>仍然有隐藏状态 <span class=\"math inline\">\\(a^{&lt;t&gt;}\\)</span></li>\n</ul>\n<p><strong>它真正改变的，只有一件事：在“旧状态 → 新状态”的过程中，加了两道可学习的“门”。</strong> 就是我们下面要说的 <strong>“更新门”和“重置门”</strong>。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260109204331014-1253999462.png\" /></p>\n<h2 id=\"12-gru-的更新门update-gate\">1.2 GRU 的更新门（Update Gate）</h2>\n<p>第一道门，叫 <strong>更新门（Update Gate）</strong>。<br />\n它负责回答的问题是：</p>\n<blockquote>\n<p>“当前这一步，我要<strong>保留多少过去的记忆</strong>？”</p>\n</blockquote>\n<p>也就是说：</p>\n<ul>\n<li>更新门开得越大 → 旧状态保留得越多</li>\n<li>更新门关得越紧 → 当前输入对隐藏状态的影响越大</li>\n</ul>\n<p>总结来说，更新门衡量的是：<strong>“这条历史信息，值不值得继续往后传？”</strong><br />\n这一设计直接解决了 RNN 的一个问题：普通 RNN 每一步都会用新输入强行覆盖旧隐藏状态，<br />\n长期信息容易被逐步稀释，而更新门让模型可以<strong>选择性保留重要历史信息</strong>。</p>\n<p>我们回到之前的例子：</p>\n<blockquote>\n<p>“我昨天去北京出差，<br />\n在路上遇到了一个多年未见的朋友，<br />\n<strong>他</strong>现在在……”</p>\n</blockquote>\n<p>在生成“他”对应的隐藏状态时：</p>\n<ul>\n<li>更新门会让模型<strong>保留“朋友”这个关键信息</strong>，因为它对理解代词至关重要</li>\n<li>同时，更新门会<strong>削弱“昨天”“北京”等不相关信息</strong>的影响</li>\n</ul>\n<p><strong>于是，通过更新门，模型可以自动判断哪些历史值得继续传递，哪些可以淡化。</strong><br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260109204331774-762429605.png\" /><br />\n其实，这种思路和我们之前在优化算法部分介绍的 <a href=\"https://www.cnblogs.com/Goblinscholar/p/19203145\" target=\"_blank\">指数加权平均</a> 很相似：旧状态像过去的平均值，更新门控制“平均时的新权重”，让重要信息得到保留。</p>\n<h2 id=\"13-gru-的重置门reset-gate\">1.3 GRU 的重置门（Reset Gate）</h2>\n<p>第二道门，叫 <strong>重置门（Reset Gate）</strong>。<br />\n它关心的不是“保留多少旧信息”，而是：</p>\n<blockquote>\n<p>“在生成新信息时，我要<strong>参考多少过去的历史</strong>？”</p>\n</blockquote>\n<p>可以把它想象成 <strong>选择记忆开关</strong>：</p>\n<ul>\n<li>当历史信息相关 → 重置门值接近 1 → 历史参与计算</li>\n<li>当历史信息不相关 → 重置门值接近 0 → 模型“暂时忘掉过去”</li>\n</ul>\n<p>这个设计是为了应对语言序列中的一类常见情况：句子突然换话题、上下文跳转很大等<strong>前面的内容对当前判断几乎没帮助</strong>的情况。</p>\n<p>还是这个例子：</p>\n<blockquote>\n<p>“我昨天去北京出差，<br />\n在路上遇到了一个多年未见的朋友，<br />\n<strong>他</strong>现在在……”</p>\n</blockquote>\n<p>当生成“他”对应的新隐藏状态时：</p>\n<ul>\n<li>重置门会让模型<strong>只关注“朋友”这个历史信息</strong></li>\n<li>忽略“昨天”、“北京”等与当前代词关系不大的信息<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260109204332322-610422982.png\" /><br />\n只看概念和例子， 你可能会觉得：<strong>更新门和重置门好像是一个作用啊？</strong><br />\n实际上，这绝非冗余设计，我们展开看看：</li>\n</ul>\n<h2 id=\"14-更新门和重置门\">1.4 更新门和重置门</h2>\n<p>实际上，更新门关注的是 <strong>“旧状态在下一步隐藏状态中保留多少”</strong>，它是一种<strong>全局记忆控制</strong>，关注的是“<strong>以后</strong>”。<br />\n而重置门关注的是 <strong>“在生成当前新隐藏状态时，历史信息是否被参考”</strong>，它是一种<strong>局部选择性</strong>，关注的是“<strong>现在</strong>”。</p>\n<table>\n<thead>\n<tr>\n<th>门</th>\n<th>功能</th>\n<th>控制对象</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>更新门</td>\n<td>记忆持续</td>\n<td>上一隐藏状态整体传递</td>\n<td>决定哪些历史要带到下一步，就像水龙头调节水流量</td>\n</tr>\n<tr>\n<td>重置门</td>\n<td>记忆使用</td>\n<td>当前候选隐藏状态计算</td>\n<td>决定本步是否参考历史，就像选择性翻阅笔记</td>\n</tr>\n</tbody>\n</table>\n<p>最终，<strong>更新门</strong>负责“信息能延续多远” ，<strong>重置门</strong>负责“信息在当前是否参与生成”。<br />\n两道门结合，使 GRU 能够<strong>在长序列中保留重要历史信息，同时在必要时灵活忘掉无关历史</strong>，实现“更好、更有用的记忆”。</p>\n<p>现在，了解了 GRU 的基本原理后，我们来看看如何实现 GRU 吧。</p>\n<h1 id=\"2-如何实现-gru-\">2. 如何实现 GRU ?</h1>\n<p><strong>这里需要提前说明一点，如果你看了原视频，会发现吴恩达老师并没有过多提及重置门，而是用一个新概念：“记忆细胞” 来进行讲解。实际上，记忆细胞是之后的 LSTM 中的概念，因为 GRU 可以看作是 LSTM 的简化形式，因此同样可以使用，但个人感觉不正式引入的前提下并不好理解，最终还是选择使用 GRU 本身的概念来进行这部分内容，在下一篇 LSTM 的介绍中再正式引入记忆细胞。</strong></p>\n<p>在理解了 GRU 的核心思想和两道门的作用之后，我们可以进一步探讨<strong>如何在实际模型中实现 GRU</strong>。实现上，其实并不复杂，本质上仍是<strong>对普通 RNN 的隐藏状态更新增加了门控计算</strong>。下面我们按逻辑逐步展开。</p>\n<h2 id=\"21-计算重置门\">2.1 计算重置门</h2>\n<p>在 GRU 的实现逻辑中，对于当前步新隐藏状态的计算，<strong>第一步是计算重置门</strong>。<br />\n<strong>重置门</strong> <span class=\"math inline\">\\(r^{\\langle t \\rangle}\\)</span> 决定了历史隐藏状态 <span class=\"math inline\">\\(a^{\\langle t-1 \\rangle}\\)</span> 在生成当前<strong>候选</strong>隐藏状态 <span class=\"math inline\">\\(\\tilde{a}^{\\langle t \\rangle}\\)</span> 时被参考的比例。<br />\n来具体演示一下这个过程：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260109204329605-853092304.png\" /><br />\n计算公式为：</p>\n<p></p><div class=\"math display\">\\[r^{\\langle t \\rangle} = sigmoid\\big( W_{xr} x^{\\langle t \\rangle} + W_{ar} a^{\\langle t-1 \\rangle} + b_r \\big)  \n\\]</div><p></p><p>你可以比较明显的发现，实际上重置门就是一个使用 <span class=\"math inline\">\\(sigmoid\\)</span> 激活函数的全连接层，最终的激活值，也就是重置门值会被 <span class=\"math inline\">\\(sigmoid\\)</span> 压缩到 <span class=\"math inline\">\\(0\\sim1\\)</span> 之间。用来表示一种<strong>权重</strong>：</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(r^{\\langle t \\rangle} \\approx 1\\)</span> 时，第 <span class=\"math inline\">\\(i\\)</span> 个隐藏单元会<strong>充分参考历史信息</strong>。</li>\n<li>当 <span class=\"math inline\">\\(r^{\\langle t \\rangle} \\approx 0\\)</span> 时，第 <span class=\"math inline\">\\(i\\)</span> 个隐藏单元会 <strong>“忘掉”历史信息</strong>，只依赖当前输入生成<strong>候选隐藏状态</strong>。</li>\n</ul>\n<p>什么叫<strong>候选隐藏状态</strong>？这就是我们的下一步内容。</p>\n<h2 id=\"22-计算候选隐藏状态\">2.2 计算候选隐藏状态</h2>\n<p>在计算完重置门 <span class=\"math inline\">\\(r^{\\langle t \\rangle}\\)</span> 后，下一步是生成 <strong>候选隐藏状态</strong> <span class=\"math inline\">\\(\\tilde{a}^{\\langle t \\rangle}\\)</span>，它表示<strong>当前步的新信息</strong>，结合了当前输入 <span class=\"math inline\">\\(x^{\\langle t \\rangle}\\)</span> 和经过重置门处理后的历史隐藏状态 <span class=\"math inline\">\\(a^{\\langle t-1 \\rangle}\\)</span>。<br />\n同样，我们在上一步的基础上进行演示：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260109204330627-116417863.png\" /></p>\n<p>摆出公式如下：</p>\n<p></p><div class=\"math display\">\\[\\tilde{a}^{\\langle t \\rangle} = \\tanh\\Big( W_{xa} x^{\\langle t \\rangle} + W_{aa} ( r^{\\langle t \\rangle} \\odot a^{\\langle t-1 \\rangle} ) + b_a \\Big)  \n\\]</div><p></p><p>其中<span class=\"math inline\">\\(r^{\\langle t \\rangle} \\odot a^{\\langle t-1 \\rangle}\\)</span>是指<strong>逐元素乘</strong>，这是将重置门作用于历史隐藏状态。<br />\n你会发现，这时我们得到的候选隐藏状态 <span class=\"math inline\">\\(\\tilde{a}^{\\langle t \\rangle}\\)</span> 就是是<strong>当前步的“新记忆”</strong>，它既包含当前输入信息 <span class=\"math inline\">\\(x^{\\langle t \\rangle}\\)</span>，也包含<strong>经过选择性过滤的历史信息</strong> <span class=\"math inline\">\\(r^{\\langle t \\rangle} \\odot a^{\\langle t-1 \\rangle}\\)</span>。</p>\n<p>到这里，你可能觉得已经实现一些优化了，但 GRU 告诉你：<strong>这还不够好</strong>。</p>\n<h2 id=\"23-计算更新门\">2.3 计算更新门</h2>\n<p>在生成候选隐藏状态 <span class=\"math inline\">\\(\\tilde{a}^{\\langle t \\rangle}\\)</span> 后，下一步是计算 <strong>更新门</strong> <span class=\"math inline\">\\(z^{\\langle t \\rangle}\\)</span>。<br />\n而更新门的作用是：<strong>决定历史隐藏状态 <span class=\"math inline\">\\(a^{\\langle t-1 \\rangle}\\)</span> 与候选隐藏状态 <span class=\"math inline\">\\(\\tilde{a}^{\\langle t \\rangle}\\)</span> 在最终隐藏状态 <span class=\"math inline\">\\(a^{\\langle t \\rangle}\\)</span> 中的融合比例</strong>。<br />\n我们继续进行演示：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260109204331403-214888700.png\" /><br />\n看完演示，我想一个问题已经呼之欲出了：<strong>更新门和重置门看起来就是把一个东西算了两遍啊？这么做的意义是什么？我直接把重置门值拿来用不行吗?</strong><br />\n这就涉及到二者在模型中所承担的<strong>语义作用</strong>：</p>\n<ul>\n<li>更新门用来记录<strong>全局</strong>中的重要记忆，它<strong>直接</strong>影响最终输出，同样梯度也直接影响它。</li>\n<li>重置门用来保存<strong>局部</strong>记忆，确保使用信息符合当前步需求，它通过候选状态<strong>间接</strong>影响最终输出，因此梯度对它的作用就没有那么“长期”。</li>\n</ul>\n<p><img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260109204603575-461036544.png\" /><br />\n因此：<strong>二者不能参数共享，而是一定要有独立的参数，以此通过反向传播实现二者的语义作用。</strong><br />\n同时要说明的是，我们这里演示的是逻辑上的计算顺序，你会发现二者的计算并不存在先后限制，因此在实际应用中可以同步计算二者。<br />\n公式表示为：</p>\n<p></p><div class=\"math display\">\\[z^{\\langle t \\rangle} = sigmoid\\big( W_{xz} x^{\\langle t \\rangle} + W_{az} a^{\\langle t-1 \\rangle} + b_z \\big)  \n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(sigmoid\\)</span> 函数将输出压缩到 <span class=\"math inline\">\\([0,1]\\)</span>，表示融合比例：</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(z^{\\langle t \\rangle}_i \\approx 1\\)</span> 时，第 <span class=\"math inline\">\\(i\\)</span> 个隐藏单元会<strong>更多保留历史信息</strong>。</li>\n<li>当 <span class=\"math inline\">\\(z^{\\langle t \\rangle}_i \\approx 0\\)</span> 时，第 <span class=\"math inline\">\\(i\\)</span> 个隐藏单元会<strong>更多采纳候选隐藏状态 <span class=\"math inline\">\\(\\tilde{a}^{\\langle t \\rangle}\\)</span> 的新信息</strong>。</li>\n</ul>\n<p>最后，我们<strong>将用更新门将历史隐藏状态与候选隐藏状态融合</strong>，得到最终隐藏状态 <span class=\"math inline\">\\(a^{\\langle t \\rangle}\\)</span>。</p>\n<h2 id=\"24-计算最终隐藏状态\">2.4 计算最终隐藏状态</h2>\n<p>在前面的步骤中，我们已经得到了三样关键量：</p>\n<ul>\n<li>上一时刻的隐藏状态 <span class=\"math inline\">\\(a^{\\langle t-1 \\rangle}\\)</span>（<strong>历史记忆</strong>）</li>\n<li>当前步生成的候选隐藏状态 <span class=\"math inline\">\\(\\tilde{a}^{\\langle t \\rangle}\\)</span>（<strong>新记忆</strong>）</li>\n<li>控制二者融合比例的更新门 <span class=\"math inline\">\\(z^{\\langle t \\rangle}\\)</span></li>\n</ul>\n<p>现在，GRU 要做的最后一件事，就是<strong>将“历史记忆”和“新记忆”按更新门的指示进行融合</strong>，从而得到当前时刻的最终隐藏状态 <span class=\"math inline\">\\(a^{\\langle t \\rangle}\\)</span>，就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260109204330960-1525113826.png\" /><br />\n最终的计算公式为：</p>\n<p></p><div class=\"math display\">\\[a^{\\langle t \\rangle} = z^{\\langle t \\rangle} \\odot a^{\\langle t-1 \\rangle} + (1 - z^{\\langle t \\rangle}) \\odot \\tilde{a}^{\\langle t \\rangle}  \n\\]</div><p></p><p>同样其中 <span class=\"math inline\">\\(\\odot\\)</span> 表示<strong>逐元素乘</strong>。<br />\n这个公式本身就非常直观，它表达的正是更新门的语义含义：</p>\n<ul>\n<li><span class=\"math inline\">\\(z^{\\langle t \\rangle}\\)</span> 决定了<strong>历史信息保留的比例</strong></li>\n<li><span class=\"math inline\">\\(1 - z^{\\langle t \\rangle}\\)</span> 决定了<strong>新信息写入的比例</strong></li>\n</ul>\n<p>也就是说：</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(z^{\\langle t \\rangle}_i \\approx 1\\)</span> 时， 第 <span class=\"math inline\">\\(i\\)</span> 个隐藏单元几乎<strong>直接复制上一时刻的状态</strong>，信息得以长期延续。</li>\n<li>当 <span class=\"math inline\">\\(z^{\\langle t \\rangle}_i \\approx 0\\)</span> 时， 第 <span class=\"math inline\">\\(i\\)</span> 个隐藏单元主要采用<strong>当前步生成的新信息</strong>。</li>\n</ul>\n<h2 id=\"25-小结\">2.5 小结</h2>\n<p>至此，一个 GRU 单元在时间步 <span class=\"math inline\">\\(t\\)</span> 的完整计算流程就结束了，完整顺序是这样的：</p>\n<ol>\n<li><strong>计算重置门</strong> <span class=\"math inline\">\\(r^{\\langle t \\rangle}\\)</span> → 用于调节历史隐藏状态在生成候选隐藏状态 <span class=\"math inline\">\\(\\tilde{a}^{\\langle t \\rangle}\\)</span> 时的参考程度：</li>\n</ol>\n<p></p><div class=\"math display\">\\[ r^{\\langle t \\rangle} = sigmoid(W_{xr} x^{\\langle t \\rangle} + W_{ar} a^{\\langle t-1 \\rangle} + b_r)  \n\\]</div><p></p><ol start=\"2\">\n<li><strong>计算候选隐藏状态</strong> <span class=\"math inline\">\\(\\tilde{a}^{\\langle t \\rangle}\\)</span> → 使用当前输入 <span class=\"math inline\">\\(x^{\\langle t \\rangle}\\)</span> 和重置门调节后的历史信息 ：</li>\n</ol>\n<p></p><div class=\"math display\">\\[    \\tilde{a}^{\\langle t \\rangle} = \\tanh(W_{x\\tilde{a}} x^{\\langle t \\rangle} + W_{a\\tilde{a}} (r^{\\langle t \\rangle} \\odot a^{\\langle t-1 \\rangle}) + b_{\\tilde{a}})  \n\\]</div><p></p><ol start=\"3\">\n<li><strong>计算更新门</strong> <span class=\"math inline\">\\(z^{\\langle t \\rangle}\\)</span> → 决定历史信息与新候选状态在最终隐藏状态中的融合比例：</li>\n</ol>\n<p></p><div class=\"math display\">\\[    z^{\\langle t \\rangle} =  sigmoid(W_{xz} x^{\\langle t \\rangle} + W_{az} a^{\\langle t-1 \\rangle} + b_z)  \n\\]</div><p></p><ol start=\"4\">\n<li><strong>计算最终隐藏状态</strong> <span class=\"math inline\">\\(a^{\\langle t \\rangle}\\)</span> → 使用更新门进行加权融合：</li>\n</ol>\n<p></p><div class=\"math display\">\\[    a^{\\langle t \\rangle} = z^{\\langle t \\rangle} \\odot a^{\\langle t-1 \\rangle} + (1 - z^{\\langle t \\rangle}) \\odot \\tilde{a}^{\\langle t \\rangle}  \n\\]</div><p></p><p>综合来看，GRU 缓解长距离依赖问题的方式可以概括为一句话：<strong>通过更新门建立“可复制的长期记忆通路”，通过重置门实现“按需使用的局部历史选择”，从结构上同时保护了信息和梯度的长期传递。</strong><br />\n它并不是“记忆更强”，而是<strong>更聪明地决定什么时候记、什么时候用、什么时候不动</strong>。<br />\n而且，你会发现 RGU 中同样有残差的思想：<br />\n从结构视角看，GRU 的更新门在时间维度上实现了一种“<strong>可学习的残差连接</strong>”：当更新门接近 1 时，隐藏状态几乎被原样复制，使信息与梯度能够跨越多个时间步稳定传播，这与 ResNet 通过恒等映射缓解深层网络退化问题在思想上是一致的。</p>\n<h1 id=\"3-总结\">3. 总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GRU 的核心思想</td>\n<td>不再“全部记住”，而是通过门控机制选择性地记忆与使用历史信息</td>\n<td>记笔记时只标重点，而不是全文背诵</td>\n</tr>\n<tr>\n<td>更新门（Update Gate）</td>\n<td>控制上一时刻隐藏状态在当前隐藏状态中保留的比例，直接决定最终输出</td>\n<td>水龙头：决定旧记忆“流”到下一步的多少</td>\n</tr>\n<tr>\n<td>重置门（Reset Gate）</td>\n<td>控制历史信息在生成当前候选隐藏状态时是否被参考</td>\n<td>翻笔记：这一步要不要看以前的内容</td>\n</tr>\n<tr>\n<td>候选隐藏状态</td>\n<td>在重置门调节下，由当前输入与部分历史信息生成的新记忆</td>\n<td>当前这一步新写下的草稿想法</td>\n</tr>\n<tr>\n<td>最终隐藏状态</td>\n<td>使用更新门在旧隐藏状态与候选隐藏状态之间进行加权融合</td>\n<td>在“照抄旧稿”和“采用新稿”之间做权衡</td>\n</tr>\n<tr>\n<td>更新门 vs 重置门</td>\n<td>更新门决定信息能“走多远”，重置门决定信息“现在用不用”</td>\n<td>一个管未来，一个管当下</td>\n</tr>\n<tr>\n<td>门不共享参数的原因</td>\n<td>二者承担不同语义角色，通过反向传播分别学习“长期保留”和“局部使用”的策略</td>\n<td>长期计划和临时决策不能用同一套标准</td>\n</tr>\n<tr>\n<td>梯度传播机制</td>\n<td>更新门接近 1 时，隐藏状态近似复制，梯度可跨时间步稳定传播</td>\n<td>给梯度修了一条高速公路</td>\n</tr>\n<tr>\n<td>GRU 与残差思想</td>\n<td>在时间维度上引入“可学习的恒等映射”，避免每一步都强制更新</td>\n<td>ResNet 的 skip connection，沿时间轴展开</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 21:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">20</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ftrace可视化工具迎来重大升级",
      "link": "https://www.cnblogs.com/pengdonglin137/p/19463398",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/pengdonglin137/p/19463398\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 21:15\">\n    <span>ftrace可视化工具迎来重大升级</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><img alt=\"sample\" src=\"https://img2024.cnblogs.com/blog/480488/202601/480488-20260109211236842-806107884.png\" width=\"500\" /></p>\n<p>今天对ftrace可视化工具进行了重大改造，提升了代码定位的准确性，此外处理性能也得到指数级的提高。</p>\n<p>首先是提高了代码定位的准确性。做这个工具的初衷就是希望让全球广大Linux内核爱好者在看trace时可以很容易定位当前函数具体是在代码的哪一行调用的，这对于梳理代码执行流程至关重要。而funcgraph-retaddr输出的是函数的返回地址，直接对这个地址调用addr2line显然不满足我们的要求。根据函数调用的原理，在执行函数调用指令时，CPU会自动保存下一条指令的地址，因此解决方案也非常简单粗暴，直接对返回地址减去一定数值得到前一条指令的起始地址，可是具体减多少呢？对于ARM64架构，每条指令固定占4字节，所以减4可以。但是对于像x86架构这种变长指令集，就不好确定了。我的AI知识库说addr2line不需要精确的指令起始地址，只需落在某行代码对应的指令范围内即可正确映射，这个工具的设计初衷就是处理近似地址(如Oops中的函数+偏移)，为的是方便调试。所以统一减1就可以保证得到的地址落在前一条指令的范围内(DWARF规范也是这么推荐的)，再调用addr2line就可以得到当前函数被调用的准确位置。</p>\n<p>然后就是大幅提高了解析trace文件的性能。目前根据地址解析得到代码行调用的是内核的faddr2line工具，它是用bash脚本语言编写的，执行的时候调用了很多三方的工具，比如readelf、grep以及awk等，同时它内部使用了多个循环遍历的算法(O(N))，对于处理像vmlinux这种包含几十万个函数符号的ELF文件来说就非常不合适。所以用python语言对这个工具进行了重写，不再调用三方的工具（仅保留addr2line），同时引入了多个二分搜索算法(O(LogN))，使文件的处理性能得到指数级的提高。以处理一个40行的trace文件为例，如果使用传统的faddr2line的话，需要大约54秒，而重写后仅需6秒。处理1000行trace日志，耗时也只有7秒，大部分时间（5秒多）都消耗在启动时解析vmlinux，构建内部数据结构上了。</p>\n<p>虽然全程都是让AI编码，但需要自己对整个流程有一个清晰的理解[1]，然后给AI提出需求，AI写完后还需要人工走读，发现待优化的点，让AI继续优化，前后折腾了有将近30版。</p>\n<p>目前我在gitee上给这个工具建立了一个仓库，方便后续继续完善，项目地址是：<a href=\"https://gitee.com/pengdonglin137/funcgraph_visualization\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/pengdonglin137/funcgraph_visualization</a></p>\n<p>[1] <a href=\"https://yb.tencent.com/s/y2zNMNFaxhu3\" rel=\"noopener nofollow\" target=\"_blank\">https://yb.tencent.com/s/y2zNMNFaxhu3</a></p>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/pengdonglin137/\" target=\"_blank\">dolinux</a>，未经同意，禁止转载</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 21:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/pengdonglin137\">dolinux</a>&nbsp;\n阅读(<span id=\"post_view_count\">34</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Flink源码阅读：Task数据交互",
      "link": "https://www.cnblogs.com/Jackeyzhe/p/19463278",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Jackeyzhe/p/19463278\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 20:11\">\n    <span>Flink源码阅读：Task数据交互</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Flink源码阅读：Task数据交互\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1828322/202601/1828322-20260109201055245-933532869.png\" />\n        经过前面的学习，Flink 的几个核心概念相关的源码实现我们已经了解了。本文我们来梳理 Task 的数据交互相关的源码。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>经过前面的学习，Flink 的几个核心概念相关的源码实现我们已经了解了。本文我们来梳理 Task 的数据交互相关的源码。</p>\n<h3 id=\"数据输出\">数据输出</h3>\n<p>话不多说，我们直接进入正题。首先来看 Task 的数据输出，在进入流程之前，我们先介绍几个基本概念。</p>\n<h4 id=\"基本概念\">基本概念</h4>\n<ul>\n<li>\n<p>RecordWriterOutput：它是 Output 接口的一个具体实现类，底层使用 RecordWriter 来发送数据。</p>\n</li>\n<li>\n<p>RecordWriter：数据写入的执行者，负责将数据写到 ResultPartition。</p>\n</li>\n<li>\n<p>ResultPartition 和 ResultSubpartition：ResultPartition 是 ExecutionGraph 中一个节点的输出结果，下游的每个需要从当前 ResultPartition 消费数据的 Task 都会有一个 ResultSubpartition。</p>\n</li>\n<li>\n<p>ChannelSelector：用来决定一个 Record 要被写到哪个 Subpartition 中。</p>\n</li>\n<li>\n<p>LocalBufferPool：用来管理 Buffer 的缓冲池。在介绍反压的原理时，我们提到过。</p>\n</li>\n</ul>\n<p>对这些基本概念有了一定的了解之后，我们来看数据输出的具体流程。</p>\n<h4 id=\"执行流程\">执行流程</h4>\n<p>我们以 map 为例，看一下数据的输出过程。</p>\n<p><img alt=\"DataOutput\" class=\"lazyload\" /></p>\n<p>在 <code>StreamMap.processElement</code> 方法中，调用完 map 方法之后，就会调用 <code>output.collect</code> 方法将数据输出，这里的 output 就是 RecordWriterOutput。在 RecordWriterOutput 中，会调用 RecordWriter 的 emit 方法。</p>\n<pre><code class=\"language-java\">private &lt;X&gt; void pushToRecordWriter(StreamRecord&lt;X&gt; record) {\n    serializationDelegate.setInstance(record);\n\n    try {\n        recordWriter.emit(serializationDelegate);\n    } catch (IOException e) {\n        throw new UncheckedIOException(e.getMessage(), e);\n    }\n}\n</code></pre>\n<p>这里的 serializationDelegate 是用来对 record 进行序列化的。RecordWriter 有两个实现类，一个是 ChannelSelectorRecordWriter，另一个是 BroadcastRecordWriter。ChannelSelectorRecordWriter 需要先调用 ChannelSelector 选择对应的 subparition，然后进行写入。BroadcastRecordWriter 则是写到所有的 subparition。</p>\n<p>接下来就是调用 <code>BufferWritingResultPartition.emitRecord</code> 来写入数据。</p>\n<pre><code class=\"language-java\">public void emitRecord(ByteBuffer record, int targetSubpartition) throws IOException {\n    totalWrittenBytes += record.remaining();\n\n    BufferBuilder buffer = appendUnicastDataForNewRecord(record, targetSubpartition);\n\n    while (record.hasRemaining()) {\n        // full buffer, partial record\n        finishUnicastBufferBuilder(targetSubpartition);\n        buffer = appendUnicastDataForRecordContinuation(record, targetSubpartition);\n    }\n\n    if (buffer.isFull()) {\n        // full buffer, full record\n        finishUnicastBufferBuilder(targetSubpartition);\n    }\n\n    // partial buffer, full record\n}\n</code></pre>\n<p>这里把 record 写入到 buffer 中，如果 buffer 不够，则会从 LocalBufferPool 中申请新的 buffer，申请到之后就会继续写入。下面是具体的申请过程。</p>\n<pre><code class=\"language-java\">private MemorySegment requestMemorySegment(int targetChannel) {\n    MemorySegment segment = null;\n    synchronized (availableMemorySegments) {\n        checkDestroyed();\n\n        if (!availableMemorySegments.isEmpty()) {\n            segment = availableMemorySegments.poll();\n        } else if (isRequestedSizeReached()) {\n            // Only when the buffer request reaches the upper limit(i.e. current pool size),\n            // requests an overdraft buffer.\n            segment = requestOverdraftMemorySegmentFromGlobal();\n        }\n\n        if (segment == null) {\n            return null;\n        }\n\n        if (targetChannel != UNKNOWN_CHANNEL) {\n            if (++subpartitionBuffersCount[targetChannel] == maxBuffersPerChannel) {\n                unavailableSubpartitionsCount++;\n            }\n        }\n\n        checkAndUpdateAvailability();\n    }\n    return segment;\n}\n</code></pre>\n<p>如果有可用内存，就直接从队列中出队。如果达到了本地 BufferPool 的上限，就从全局的 NetworkBufferPool 中申请，申请不到就会阻塞写入过程，等待申请。最后还会检查并更新可用内存状态。</p>\n<p>有了可用的 buffer 之后，就会调用 addToSubpartition，最终数据存储在 PipelinedSubpartition 的 buffers 队列中。</p>\n<pre><code class=\"language-java\">private void addToSubpartition(\n        BufferBuilder buffer,\n        int targetSubpartition,\n        int partialRecordLength,\n        int minDesirableBufferSize)\n        throws IOException {\n    int desirableBufferSize =\n            subpartitions[targetSubpartition].add(\n                    buffer.createBufferConsumerFromBeginning(), partialRecordLength);\n\n    resizeBuffer(buffer, desirableBufferSize, minDesirableBufferSize);\n}\n</code></pre>\n<h3 id=\"数据输入\">数据输入</h3>\n<p>看完了数据输出的过程之后，我们再来看一下数据输入的过程。首先还是了解几个基本概念。</p>\n<h4 id=\"基本概念-1\">基本概念</h4>\n<ul>\n<li>\n<p>InputGate：InputGate 是对输入的封装，与 JobGraph 中的 JobEdge 一一对应，每个 InputGate 消费上游一个或多个 Resultpartition。</p>\n</li>\n<li>\n<p>InputChannel：InputChannel 是和 ExecutionGraph 中的 ExecutionEdge 一一对应的。每个 InputChannel 接收一个 ResultSubpartition 的输出，InputChannel 主要关注 LocalInputChannel 和 RemoteInputChannel 两种实现。</p>\n</li>\n</ul>\n<h4 id=\"执行流程-1\">执行流程</h4>\n<p>了解了具体概念之后，我们再看数据输入的具体流程。</p>\n<p><img alt=\"RecordInput\" class=\"lazyload\" /></p>\n<p>数据输入的入口是 <code>StreamTask.processInput</code> 方法，这个方法中主要是调用 <code>inputProcessor.processInput</code> 方法，我们以 StreamOneInputProcessor 为例。这个方法就是调用 <code>input.emitNext</code> 方法。</p>\n<pre><code class=\"language-java\">public DataInputStatus emitNext(DataOutput&lt;T&gt; output) throws Exception {\n\n    while (true) {\n        // get the stream element from the deserializer\n        if (currentRecordDeserializer != null) {\n            RecordDeserializer.DeserializationResult result;\n            try {\n                result = currentRecordDeserializer.getNextRecord(deserializationDelegate);\n            } catch (IOException e) {\n                throw new IOException(\n                        String.format(\"Can't get next record for channel %s\", lastChannel), e);\n            }\n            if (result.isBufferConsumed()) {\n                currentRecordDeserializer = null;\n            }\n\n            if (result.isFullRecord()) {\n                final boolean breakBatchEmitting =\n                        processElement(deserializationDelegate.getInstance(), output);\n                if (canEmitBatchOfRecords.check() &amp;&amp; !breakBatchEmitting) {\n                    continue;\n                }\n                return DataInputStatus.MORE_AVAILABLE;\n            }\n        }\n\n        Optional&lt;BufferOrEvent&gt; bufferOrEvent = checkpointedInputGate.pollNext();\n        if (bufferOrEvent.isPresent()) {\n            // return to the mailbox after receiving a checkpoint barrier to avoid processing of\n            // data after the barrier before checkpoint is performed for unaligned checkpoint\n            // mode\n            if (bufferOrEvent.get().isBuffer()) {\n                processBuffer(bufferOrEvent.get());\n            } else {\n                DataInputStatus status = processEvent(bufferOrEvent.get(), output);\n                if (status == DataInputStatus.MORE_AVAILABLE &amp;&amp; canEmitBatchOfRecords.check()) {\n                    continue;\n                }\n                return status;\n            }\n        } else {\n            if (checkpointedInputGate.isFinished()) {\n                checkState(\n                        checkpointedInputGate.getAvailableFuture().isDone(),\n                        \"Finished BarrierHandler should be available\");\n                return DataInputStatus.END_OF_INPUT;\n            }\n            return DataInputStatus.NOTHING_AVAILABLE;\n        }\n    }\n}\n</code></pre>\n<p>这里是调用 <code>checkpointedInputGate.pollNext</code> 来获取输入的数据。它的内部就是调用 InputGate 的 pollNext 方法来获取数据。当获取到完整数据之后，就会调用 processElement 来处理数据。</p>\n<p>我们以 SingleInputGate 为例看 InputGate 的 pollNext 方法。它的内部调用链路可用一直追踪到 readBufferFromInputChannel 方法，这个方法内会调用 <code>inputChannel.getNextBuffer</code>，这里交给 InputChannel 来具体执行数据读取。</p>\n<pre><code class=\"language-java\">public Optional&lt;BufferAndAvailability&gt; getNextBuffer() throws IOException {\n    checkError();\n\n    if (!toBeConsumedBuffers.isEmpty()) {\n        return getBufferAndAvailability(toBeConsumedBuffers.removeFirst());\n    }\n\n    ResultSubpartitionView subpartitionView = this.subpartitionView;\n    if (subpartitionView == null) {\n        // There is a possible race condition between writing a EndOfPartitionEvent (1) and\n        // flushing (3) the Local\n        // channel on the sender side, and reading EndOfPartitionEvent (2) and processing flush\n        // notification (4). When\n        // they happen in that order (1 - 2 - 3 - 4), flush notification can re-enqueue\n        // LocalInputChannel after (or\n        // during) it was released during reading the EndOfPartitionEvent (2).\n        if (isReleased) {\n            return Optional.empty();\n        }\n\n        // this can happen if the request for the partition was triggered asynchronously\n        // by the time trigger\n        // would be good to avoid that, by guaranteeing that the requestPartition() and\n        // getNextBuffer() always come from the same thread\n        // we could do that by letting the timer insert a special \"requesting channel\" into the\n        // input gate's queue\n        subpartitionView = checkAndWaitForSubpartitionView();\n    }\n\n    BufferAndBacklog next = subpartitionView.getNextBuffer();\n    // ignore the empty buffer directly\n    while (next != null &amp;&amp; next.buffer().readableBytes() == 0) {\n        next.buffer().recycleBuffer();\n        next = subpartitionView.getNextBuffer();\n        numBuffersIn.inc();\n    }\n\n    if (next == null) {\n        if (subpartitionView.isReleased()) {\n            throw new CancelTaskException(\n                    \"Consumed partition \" + subpartitionView + \" has been released.\");\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    Buffer buffer = next.buffer();\n\n    if (buffer instanceof FullyFilledBuffer) {\n        List&lt;Buffer&gt; partialBuffers = ((FullyFilledBuffer) buffer).getPartialBuffers();\n        int seq = next.getSequenceNumber();\n        for (Buffer partialBuffer : partialBuffers) {\n            toBeConsumedBuffers.add(\n                    new BufferAndBacklog(\n                            partialBuffer,\n                            next.buffersInBacklog(),\n                            buffer.getDataType(),\n                            seq++));\n        }\n\n        return getBufferAndAvailability(toBeConsumedBuffers.removeFirst());\n    }\n\n    return getBufferAndAvailability(next);\n}\n</code></pre>\n<p>我们先来看 LocalInputChannel，先获取到了 subpartitionView，并调用 getNextBuffer，这里其实就是从 PipelinedSubpartition 的 buffers 队列中读取数据。</p>\n<p>RemoteInputChannel 则需要从 receivedBuffers 中读取数据，这个队列的数据就是消费上游数据后保存的。</p>\n<p>至此，Flink 中 Task 的数据输入和输出过程的源码就梳理完了，更加底层的 Netty 相关代码我们在后面继续梳理。</p>\n<h3 id=\"总结\">总结</h3>\n<p>最后简单总结一下，本文我们梳理了 Task 的数据输出和输入的过程。输出过程主要是利用 RecordWriter 将数据写入到 Buffer 中，输入过程则是利用 InputChannel 从 Buffer 消费的过程。如果你的 Flink 任务数据量特别大，并且没什么复杂的逻辑，可以考虑适当调整 localBufferPool 的大小来调优任务的吞吐。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 20:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Jackeyzhe\">Jackeyzhe</a>&nbsp;\n阅读(<span id=\"post_view_count\">24</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "公众号推荐机制整理：科技号怎么把社交流量做起来",
      "link": "https://www.cnblogs.com/reachteam/p/19463233",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/reachteam/p/19463233\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 19:39\">\n    <span>公众号推荐机制整理：科技号怎么把社交流量做起来</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>01 背景</h1>\n<p><span>最近我们软件团队参加了一个高校关于公众号运营的分享，听完挺有启发，所以把重点整理成一篇笔记，发出来给大家参考。</span></p>\n<p><span>从 2023 年开始，公众号的分发不再只是订阅推送那一套了，现在更像是社交信号 + 算法推荐一起在发力。有数据提到，2025 年某科技/软件小号通过社交推荐拿到的流量占比已经到 45.9%，甚至超过了传统订阅推送。</span></p>\n<p><span>所以这篇文章想解决的就一件事：</span></p>\n<p><span>科技号到底要怎么写，才能更容易被推荐，也更容易被转发。</span></p>\n<p><span>下面按 6 个方向讲清楚：技术逻辑、关键指标、分发流程、账号差异、演进变化、案例和可操作建议。</span></p>\n<h2><span>02 推荐系统大概怎么跑</span></h2>\n<h3><span>2.1 三类信号最重要</span></h3>\n<p><span>2025 年之后，公众号的推荐更强调三类信号一起看：</span></p>\n<p><span>1. 社交关系：朋友看过、转发、在看等</span></p>\n<p><span>2. 兴趣标签：你是什么人群，内容是什么主题</span></p>\n<p><span>3. 行为数据：点击、停留、完读、滑动速度、点赞发生在什么时候</span></p>\n<p><span>系统会先从内容里提取关键词，再结合用户行为更新画像，最后决定给谁更多曝光。可以把它理解成一个循环：先曝光一小波，看反馈，再决定要不要继续给量。</span></p>\n<p><span>另外有一点很关键，文章发出去之后通常 1 到 3 分钟内就会做一轮质量评估，主题价值、逻辑结构、原创性、以及 AI 生成痕迹这些都会被综合判断。</span></p>\n<h3><span>2.2 指标权重长什么样</span></h3>\n<p><span>先把大盘放在这。数字是研究整理口径，大家看趋势和重点就行。</span></p>\n<p><span>表 1：公众号算法核心权重分配</span></p>\n<table>\n<thead>\n<tr><th><span>权重维度</span></th><th><span>具体指标</span></th><th><span>权重占比</span></th><th><span>关键阈值（示例）</span></th></tr>\n</thead>\n<tbody>\n<tr>\n<td><span>社交传播系数</span></td>\n<td><span>好友推荐率、转发到朋友圈/社群次数、跨圈层传播深度</span></td>\n<td><span>35%</span></td>\n<td><span>社交推荐流量占比 ≥ 45%</span></td>\n</tr>\n<tr>\n<td><span>内容质量因子</span></td>\n<td><span>完读率（≥65%）、平均阅读时长（≥2 分钟）、原创度（3 倍权重）</span></td>\n<td><span>30%</span></td>\n<td><span>完读率 ≥ 50%</span></td>\n</tr>\n<tr>\n<td><span>用户行为画像</span></td>\n<td><span>点击率、滑动速度、点赞时间点等微观行为</span></td>\n<td><span>20%</span></td>\n<td><span>点击率 ≥ 15%</span></td>\n</tr>\n<tr>\n<td><span>账号信誉体系</span></td>\n<td><span>更新频率、违规记录、用户投诉率</span></td>\n<td><span>10%</span></td>\n<td><span>日更可提升 300% 初始推荐</span></td>\n</tr>\n<tr>\n<td><span>实时流量博弈</span></td>\n<td><span>15 分钟动态调整</span></td>\n<td><span>5%</span></td>\n<td><span>冷启动期点击率 &gt; 8%</span></td>\n</tr>\n</tbody>\n</table>\n<p><span>另外还有一组常见拆分口径：打开率大概占 40%，互动率（赞/在看/收藏）占 30%，分享率占 20%，完读率占 10%。</span></p>\n<p><span>提醒两点：</span></p>\n<p><span>1. 原创的推荐权重会更高（研究口径里提到是转载的 3 倍）</span></p>\n<p><span>2. 认证类型也会影响权重（政府 &gt; 媒体 &gt; 企业 &gt; 个体），认证账号在搜索里更容易拿到靠前曝光</span></p>\n<h3><span>2.3 这几年分发怎么变了</span></h3>\n<p><span>简单按阶段捋一下：</span></p>\n<p><span>1. 2013 到 2017：订阅为主，关注就能收到</span></p>\n<p><span>2. 2017 到 2020：开始引入社交推荐，看一看等入口出现</span></p>\n<p><span>3. 2020 到 2023：算法推荐逐步变强，开始推荐未关注内容</span></p>\n<p><span>4. 2023 至今：社交 + 算法双驱动更明显，朋友相关入口的权重变高</span></p>\n<h2><span>03 流量池赛马：文章为啥会突然爆</span></h2>\n<h3><span>3.1 冷启动那一关很关键</span></h3>\n<p><span>文章发出去之后，通常会先拿到一小波测试曝光（比如 500 到 1000 次），系统主要看三项：点击率、完读率、互动率。</span></p>\n<p><span>研究里给了一些常见阈值做参考：</span></p>\n<p><span>1. 冷启动期（0 到 24 小时）点击率要能到 8% 以上，更可能进下一层</span></p>\n<p><span>2. 进入爆发期后，完读率最好能维持 55% 以上，互动率 3% 以上</span></p>\n<h3><span>3.2 多轮推荐不是一次性给完</span></h3>\n<p><span>通过第一轮测试后，会有二次、三次甚至更多轮的推荐，每一轮曝光量会变大。</span></p>\n<p><span>另外系统会按 15 分钟一轮动态调整流量，所以同一篇文章的数据会一直变化。阅读量到 1 万这个量级后，有时还会触发人工审核。</span></p>\n<h3><span>3.3 社交扩散会带来放大</span></h3>\n<p><span>当用户点在看或者转发，文章就会沿着社交网络扩散。有账号的数据里，朋友相关入口贡献的阅读量能到 45.9%。</span></p>\n<p><span>比较容易触发分享的原因一般是这三类：</span></p>\n<p><span>1. 内容本身有社交价值（共鸣、实用、话题性）</span></p>\n<p><span>2. 文中写清楚分享动机（比如转给同事、转给同学、转给群里谁）</span></p>\n<p><span>3. 内容适配分享场景（工作群、同学群、行业群能用得上）</span></p>\n<h3><span>3.4 公域入口也很重要</span></h3>\n<p><span>表 2：公众号主要流量来源分布</span></p>\n<table>\n<thead>\n<tr><th><span>流量来源</span></th><th><span>占比</span></th><th><span>特点</span></th></tr>\n</thead>\n<tbody>\n<tr>\n<td><span>推荐流量</span></td>\n<td><span>54.5%</span></td>\n<td><span>算法推荐为主</span></td>\n</tr>\n<tr>\n<td><span>公众号消息</span></td>\n<td><span>16.52%</span></td>\n<td><span>订阅用户</span></td>\n</tr>\n<tr>\n<td><span>公众号主页</span></td>\n<td><span>13.17%</span></td>\n<td><span>主动访问</span></td>\n</tr>\n<tr>\n<td><span>搜一搜</span></td>\n<td><span>10.44%</span></td>\n<td><span>精准搜索</span></td>\n</tr>\n<tr>\n<td><span>聊天会话</span></td>\n<td><span>2.88%</span></td>\n<td><span>私域分享</span></td>\n</tr>\n<tr>\n<td><span>朋友圈</span></td>\n<td><span>0.96%</span></td>\n<td><span>朋友圈分享</span></td>\n</tr>\n<tr>\n<td><span>朋友推荐</span></td>\n<td><span>0.12%</span></td>\n<td><span>好友直接推荐</span></td>\n</tr>\n</tbody>\n</table>\n<p><span>补充两点：</span></p>\n<p><span>1. 看一看是很重要的公域入口，爆款里看一看占比能到 60% 到 70%</span></p>\n<p><span>2. 搜一搜占比大概 10.44%，标题关键词做得好，搜索流量占比也可能很可观</span></p>\n<h2><span>04 不同账号的差异</span></h2>\n<h3><span>4.1 认证和账号信誉</span></h3>\n<p><span>认证类型会影响权重和信任（政府 &gt; 媒体 &gt; 企业 &gt; 个体）。</span></p>\n<p><span>同时也会看这些：注册时间、违规记录、粉丝活跃度（常读用户）、更新频率（发文多且原创占比高更占优）。</span></p>\n<h3><span>4.2 新号和老号不一样</span></h3>\n<p><span>新号一般会有观察期，初期曝光可能比较小，平台会先判断你是不是稳定的正常创作者，标签清不清晰，内容合不合规。</span></p>\n<p><span>老号因为画像积累更完整，推荐更容易精准，但长期不活跃或者质量下滑也可能被降权。</span></p>\n<h3><span>4.3 垂直领域更吃香，但别乱跑</span></h3>\n<p><span>科技、教育等垂直领域在品类里可能更容易拿到倾斜，但前提是定位足够细，内容持续垂直输出，并且用合集、标签等方式强化识别。</span></p>\n<h2><span>05 科技号怎么做更容易起量</span></h2>\n<p><span>我更建议把指标当成门槛，而不是当 KPI。</span></p>\n<h3><span>5.1 标题先把点击率顶起来</span></h3>\n<p><span>标题可以用一个比较稳的结构：痛点场景 + 数据背书 + 情绪共鸣。</span></p>\n<p><span>示例（按你们账号方向替换即可）：</span></p>\n<p><span>1. 我把电脑变快了，3 个 Windows 设置立刻见效</span></p>\n<p><span>2. 别再被钓鱼了，校园/企业邮箱最常见的 5 种诈骗</span></p>\n<p><span>3. 从 0 到 1，用 10 分钟搭好一个自动化报表流程</span></p>\n<h3><span>5.2 内容结构要照顾完读</span></h3>\n<p><span>一个比较好用的写法是：开头直接给结论，中间保持信息密度（大概每 300 字一个关键点），结尾给行动建议或提问，引导评论/收藏/转发。</span></p>\n<h3><span>5.3 原创是底盘</span></h3>\n<p><span>研究里提到原创度建议大于 70%。如果用 AI 做辅助，也建议把比例和用途说清楚，避免被系统误判成低质。</span></p>\n<h3><span>5.4 把可转发写进正文</span></h3>\n<p><span>文章 25% / 50% / 75% 的位置，可以顺手加一句话，告诉读者这段适合转给谁。</span></p>\n<p><span>比如：这份排查清单转给 IT 同事/同学；这段设置转到群里，大家少踩坑。</span></p>\n<h3><span>5.5 发出去后的 2 小时别浪费</span></h3>\n<p><span>冷启动数据很关键，建议发文后马上用种子用户扩散一波（社群、同事群、同学群），先把点击、完读、互动跑起来。</span></p>\n<h3><span>5.6 每周就盯 3 个指标</span></h3>\n<p><span>1. 社交推荐流量占比（目标值可参考 45%）</span></p>\n<p><span>2. 菜单栏点击量（能看出互动深度）</span></p>\n<p><span>3. 48 小时互动率（能看出内容即时影响力）</span></p>\n<p><span>另外标题、封面、开头段落都可以做小范围 A/B 测试，找最合适的组合。</span></p>\n<h2><span>06 案例给我们的提示</span></h2>\n<p><span>这里列几个研究里的典型现象，主要看规律：</span></p>\n<p><span>1. 有文章阅读 48 万，看一看贡献 60%</span></p>\n<p><span>2. 有新号粉丝不多，单篇 10 万+，看一看贡献 98%</span></p>\n<p><span>3. 有病毒传播案例，第 1 天 500+，第 2 天 1 万+，第 3 天朋友圈刷屏</span></p>\n<p><span>共同点其实很朴素：冷启动过关，社交扩散被点燃，内容质量能撑住完读和互动。</span></p>\n<h2><span>07 风险和合规别踩坑</span></h2>\n<p><span>常见误区：</span></p>\n<p><span>1. 追热点但和定位不搭，容易白忙</span></p>\n<p><span>2. 依赖刷量，平台有无效流量排查，风险很高</span></p>\n<p><span>3. 只要曝光不要质量，完读率掉得很快，推荐也会很快停</span></p>\n<p><span>合规方面：</span></p>\n<p><span>1. 原创度尽量做到 70% 以上</span></p>\n<p><span>2. 标题和正文做敏感词扫描，少用绝对化、夸大化表述</span></p>\n<p><span>3. 图片素材注意版权，用 CC0 站点或者合规二创</span></p>\n<h2><span>08 总结</span></h2>\n<p><span>一句话总结：公众号现在是社交信号 + 算法推荐一起在跑，科技号想起量，核心还是三件事：冷启动数据过关、内容更容易被转发、长期坚持原创和垂直。</span></p>\n<p><span>如果你只想先做最小改动，建议从这 3 个开始：</span></p>\n<p><span>1. 发文后 0 到 2 小时，把点击率、完读率、互动率先跑起来</span></p>\n<p><span>2. 把清单、步骤、排错流程写得更可截图转发，顺手写清楚转给谁</span></p>\n<p><span>3. 连续做一个细分方向（比如校园网络安全、系统使用指南、办公效率），让标签稳定下来</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 19:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/reachteam\">H5开发技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">47</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MAF快速入门（11）并行工作流",
      "link": "https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper11",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper11\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 18:30\">\n    <span>MAF快速入门（11）并行工作流</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"MAF快速入门（11）并行工作流\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260104201029946-1112217715.png\" />\n        在实际业务场景中，往往需要在工作流中让多个Agent同时运行再通过聚合结果做做一些数据分析或决策呈现，这时就需要并行执行机制。本文介绍了MAF中并行工作流以及如何实现“Fan-Out/Fan-In”的工作模式，最后通过一个跨境电商价格查询智能定价的案例介绍了这种模式的代码实现。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>大家好，我是Edison。</p>\n<p>最近我一直在跟着圣杰的《<a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\">.NET+AI智能体开发进阶</a>》课程学习MAF的开发技巧，我强烈推荐你也上车跟我一起出发！</p>\n<p><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper10\" target=\"_blank\">上一篇</a>，<span>我们学习了MAF中如何进行循环（loop）路由<span>。本篇，我们来了解下在MAF中如何并行执行（fan-out/fan-in）的工作流。</span></span></p>\n<h1><strong>1 并行执行模式</strong></h1>\n<p><span><span><span>在实际业务场景中，往往需要在工作流中让多个Agent同时运行再通过聚合结果做做一些数据分析或决策呈现，这时就需要并行执行机制<span>。</span></span></span></span></p>\n<p><span><span><span>在MAF中，我们可以使用 Fan-Out/Fan-In 模式来实现这个目的<span>，如下代码片段所示：</span></span></span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowBuilder(startExecutor)\n    .AddFanOutEdge(startExecutor, [amazonExecutor, ebayExecutor, shopeeExecutor])\n    .AddFanInEdge([amazonExecutor, ebayExecutor, shopeeExecutor], strategyExecutor)\n    .WithOutputFrom(strategyExecutor)\n    .Build();</span></pre>\n</div>\n<p><span><span><span><span><span><span><span>可以看到，我们通过MAF的 AddFanOutEdge 和 AddFanInEdge 来实现了并行执行的目的，最后通过一个自定义的执行器来做聚合。</span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span>核心概念补充：</span></span></span></span></span></span></span></p>\n<ul>\n<li><span><span><span><span><span><span><span>Fan-Out Edge =&gt; 并发执行边</span></span></span></span></span></span></span></li>\n<li><span><span><span><span><span><span><span>Fan-In Edge =&gt; 汇聚边</span></span></span></span></span></span></span></li>\n</ul>\n<h1><strong>2 并行工作流实验案例</strong></h1>\n<p><span><span><span><span><span><span><span><span>假设我们是一个跨境电商团队，想要实时监控同一个商品在多个电商平台（如亚马逊、eBay、Shopee等）的定价策略，在检测到竞争对手降价时快速做出响应决策。</span></span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span><span><span>因此，我们的目标是：配置一个&nbsp;<span>Fan-Out + Fan-In<span>&nbsp;工作流，实现一次查询、并行抓取、智能决策的企业级模式。</span></span></span></span></span></span></span></span></span></span></span></p>\n<h3><strong><span><span>2.1 关键依赖包引入</span></span></strong></h3>\n<p><span><span><span><span><span><span><span><span><span><span><span><span>在今天的这个案例中，我们仍然创建了一个.NET控制台应用程序，安装了以下NuGet包：</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><span>Microsoft.Agents.AI.OpenAI</span></li>\n<li><span>Microsoft.Agents.AI.Workflows</span></li>\n<li><span>Microsoft.Extensions.AI.OpenAI</span></li>\n</ul>\n<h3><span><span>2.2 定义数据传输模型</span></span></h3>\n<p><span><span>首先，我们定义一下在这个工作流中需要生成传递的数据模型：</span></span></p>\n<p><span><span>PriceQueryDto ：价格查询模型DTO</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> PriceQueryDto\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> ProductId { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> ProductName { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> TargetRegion { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> PriceQueryDto(<span style=\"color: rgba(0, 0, 255, 1);\">string</span> productId, <span style=\"color: rgba(0, 0, 255, 1);\">string</span> productName, <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> targetRegion)\n    {\n        ProductId </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> productId;\n        ProductName </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> productName;\n        TargetRegion </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> targetRegion;\n    }\n}</span></pre>\n</div>\n<h3><span><span>2.3 定义Agents&amp;Executors</span></span></h3>\n<p><span><strong>（1）价格查询：</strong>封装各大电商平台的价格查询逻辑，模拟其API响应，仅仅做演示用无实际逻辑</span>：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> PlatformPriceExecutor : Executor&lt;ChatMessage&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> _instructions;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> IChatClient _chatClient;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> PlatformPriceExecutor(<span style=\"color: rgba(0, 0, 255, 1);\">string</span> id, IChatClient chatClient, <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> platformInstructions)\n        : </span><span style=\"color: rgba(0, 0, 255, 1);\">base</span><span style=\"color: rgba(0, 0, 0, 1);\">(id)\n    {\n        _chatClient </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> chatClient;\n        _instructions </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> platformInstructions;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask HandleAsync(ChatMessage message, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> messages = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;ChatMessage&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">(ChatRole.System, _instructions),\n            message\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> response = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> _chatClient.GetResponseAsync(messages, cancellationToken: cancellationToken);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> replyMessage = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> ChatMessage(ChatRole.Assistant, response.Text ?? <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty)\n        {\n            AuthorName </span>= <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">.Id\n        };\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> context.SendMessageAsync(replyMessage, cancellationToken: cancellationToken);\n        Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ {this.Id} 完成查询</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    }\n}</span></pre>\n</div>\n<p><strong><span><span>（2）<span>广播查询请求执行器<span>：</span></span></span></span></strong><span>负责广播价格查询请求到各大电商平台并发放TurnToken。</span></p>\n<p><span>NOTE：只有发放了TurnToken才能真正开启执行后续LLM节点！</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> PriceQueryStartExecutor() : Executor&lt;PriceQueryDto&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(nameof(PriceQueryStartExecutor))\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask HandleAsync(PriceQueryDto query, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> userPrompt = $<span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">商品ID: {query.ProductId}\n商品名称: {query.ProductName}\n目标区域: {query.TargetRegion}\n\n请查询该商品在你的平台上的当前价格、库存状态和配送信息。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.SendMessageAsync(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatMessage(ChatRole.User, userPrompt), cancellationToken: cancellationToken);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.SendMessageAsync(<span style=\"color: rgba(0, 0, 255, 1);\">new</span> TurnToken(emitEvents: <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">), cancellationToken: cancellationToken);\n\n        Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📡 Fan-out 价格查询广播已发送</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    }\n}</span></pre>\n</div>\n<p><strong><strong><span><span>（3）<span>定价聚合<span>：</span></span></span></span></strong></strong><span>模拟收集到所有平台的定价之后执行的数据聚合操作。</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> PricingStrategyExecutor : Executor&lt;ChatMessage&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> List&lt;ChatMessage&gt; _messages =<span style=\"color: rgba(0, 0, 0, 1);\"> [];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> _targetCount;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> PricingStrategyExecutor(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> targetCount) : <span style=\"color: rgba(0, 0, 255, 1);\">base</span><span style=\"color: rgba(0, 0, 0, 1);\">(nameof(PricingStrategyExecutor))\n    {\n        _targetCount </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> targetCount;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask HandleAsync(ChatMessage message, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">._messages.Add(message);\n        Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📊 已收集 {_messages.Count}/{_targetCount} 个平台数据 - 来自 {message.AuthorName}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (<span style=\"color: rgba(0, 0, 255, 1);\">this</span>._messages.Count == <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">._targetCount)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> platformData = <span style=\"color: rgba(0, 0, 255, 1);\">string</span>.Join(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(0, 0, 255, 1);\">this</span>._messages.Select(m =&gt; $<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">• {m.AuthorName}: {m.Text}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> strategyReport = $<span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📊 多平台价格汇总（共 {this._messages.Count} 个平台）\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n{platformData}\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n💡 智能定价建议\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n基于以上数据，建议分析竞争对手价格区间，制定差异化定价策略。\n考虑因素：库存压力、配送成本、平台佣金率、目标利润率。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> context.YieldOutputAsync(strategyReport, cancellationToken);\n\n            Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✨ Fan-in 定价策略生成完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        }\n    }\n}</span></pre>\n</div>\n<h3>2.4 构建工作流</h3>\n<p>现在万事俱备，只欠一个Workflow，现在Let's do it!</p>\n<p>Step1: 获取ChatClient</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> chatClient = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> OpenAIClient(\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ApiKeyCredential(openAIProvider.ApiKey),\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> OpenAIClientOptions { Endpoint = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Uri(openAIProvider.Endpoint) })\n    .GetChatClient(openAIProvider.ModelId)\n    .AsIChatClient();</span></pre>\n</div>\n<p>Step2: 实例化自定义Agent &amp; Executors</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> amazonExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> PlatformPriceExecutor(\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">AmazonPriceAgent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    chatClient,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">你是Amazon平台价格查询Agent。返回格式：价格=$XXX，库存状态=充足/紧张，配送说明=Prime会员免运费/标准配送。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> ebayExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> PlatformPriceExecutor(\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">eBayPriceAgent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    chatClient,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">你是eBay平台价格查询Agent。返回格式：价格=$XXX，商品状态=全新/二手XX新，运费说明=包邮/买家承担。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> shopeeExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> PlatformPriceExecutor(\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ShopeePriceAgent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    chatClient,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">你是Shopee平台价格查询Agent。返回格式：价格=$XXX（含税），区域=东南亚/台湾，促销信息=满减活动/无。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> startExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> PriceQueryStartExecutor();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> strategyExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> PricingStrategyExecutor(<span style=\"color: rgba(128, 0, 128, 1);\">3</span>);</pre>\n</div>\n<p>Step3: 创建并行执行工作流</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowBuilder(startExecutor)\n        .AddFanOutEdge(startExecutor, [amazonExecutor, ebayExecutor, shopeeExecutor])\n        .AddFanInEdge([amazonExecutor, ebayExecutor, shopeeExecutor], strategyExecutor)\n        .WithOutputFrom(strategyExecutor)\n        .Build();\nConsole.OutputEncoding </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Encoding.UTF8;\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ Loop Workflow 构建完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<h3><span><span>2.5 测试工作流</span></span></h3>\n<p><span><span>定义查询的商品是IPhone15：</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> priceQuery = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> PriceQueryDto(\n    productId: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">IPHONE15-PRO-256</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    productName: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">iPhone 15 Pro 256GB</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    targetRegion: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">US</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n);</span></pre>\n</div>\n<p><span><span>通过Streaming流式执行：</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">await</span> <span style=\"color: rgba(0, 0, 255, 1);\">using</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> run = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> InProcessExecution.StreamAsync(workflow, priceQuery))\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> evt <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> run.WatchStreamAsync())\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">switch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (evt)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> ExecutorInvokedEvent started:\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">🚀 {started.ExecutorId} 开始运行</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> ExecutorCompletedEvent completed:\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ {completed.ExecutorId} 结束运行</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowOutputEvent outputEvent:\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">🎉 Fan-in 汇总输出：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{outputEvent.Data}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowErrorEvent errorEvent:\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✨ 收到 Workflow Error Event：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{errorEvent.Data}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n    }\n}</span></pre>\n</div>\n<p>测试结果如下图所示：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260104200929287-1279437489.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可以看见，经过并行执行价格查询后，由聚合执行器进行了价格汇总并发送给LLM进行了最终的定价建议。</p>\n<h1><strong><span>3 小结</span></strong></h1>\n<p>本文介绍了MAF中并行工作流以及如何实现“Fan-Out/Fan-In<span><span><span>”的工作模式，最后通过一个跨境电商价格查询智能定价的案例介绍了这种模式的代码实现。</span></span></span></p>\n<p>下一篇，我们将继续学习MAF中工作流的多选路由工作流。</p>\n<h1>示例源码</h1>\n<p>GitHub:&nbsp;<a href=\"https://github.com/EdisonTalk/MAFD\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/EdisonTalk/MAFD</a></p>\n<h1>参考资料</h1>\n<p><span><span>圣杰，《<a href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\">.NET + AI 智能体开发进阶</a>》（推荐指数：★★★★★）</span></span></p>\n<p><span><span>Microsoft Learn，<span>《<a href=\"https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview?wt.mc_id=MVP_397012\" rel=\"noopener nofollow\" target=\"_blank\">Agent Framework Tutorials</a>》</span></span></span></p>\n<div><span><span>&nbsp;</span></span></div>\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://images.cnblogs.com/cnblogs_com/edisonchou/1647700/o_200902144330EdisonTalk-Footer.jpg\" /></p>\n<div id=\"Copyright\">\n<p>作者：<span style=\"text-decoration: underline;\">爱迪生</span></p>\n<p>出处：<a href=\"https://edisontalk.cnblogs.com\" target=\"_blank\" title=\"from\">https://edisontalk.cnblogs.com</a></p>\n<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。</p>\n</div>\n</div>\n<div id=\"MySignature\">\n    <div align=\"center\"><a href=\"https://weibo.com/u/2068032061?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/2068032061/d643d182/10.png\" /></a></div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 18:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/edisontalk\">EdisonZhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">35</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}