{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "20260109 - TRU 协议攻击事件分析：买得够多免费送了喂！",
      "link": "https://www.cnblogs.com/ACaiGarden/p/19465686",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ACaiGarden/p/19465686\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 15:42\">\n    <span>20260109 - TRU 协议攻击事件分析：买得够多免费送了喂！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>20260109，ETH 链上的 TRU 协议遭受了黑客攻击，损失约 2600 万美元。漏洞原因是计算购买 TRU 代币所需要的 ETH 数量的计算公式设计存在缺陷，购买大量 TRU 代币时会因为精度丢失而得到 0 值，使得攻击者可以以 0 ETH 购买大量的 TRU 代币，最后抛售完成获利。</p>\n<ul>\n<li>TX：<a href=\"https://app.blocksec.com/explorer/tx/eth/0xcd4755645595094a8ab984d0db7e3b4aabde72a5c87c4f176a030629c47fb014\" rel=\"noopener nofollow\" target=\"_blank\">https://app.blocksec.com/explorer/tx/eth/0xcd4755645595094a8ab984d0db7e3b4aabde72a5c87c4f176a030629c47fb014</a></li>\n</ul>\n<h1 id=\"trace-分析\">Trace 分析</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154123776-1794652238.png\" /></p>\n<ol>\n<li>黑客调用 buyTRU() 函数以零成本购入大量的 TRU 代币</li>\n<li>然后调用 sellTRU() 函数卖出所有 TRU 代币完成获利</li>\n</ol>\n<p>随后攻击者利用漏洞以零或极低成本的价格购买 TRU 代币后出售的流程重复多次。</p>\n<h1 id=\"代码分析\">代码分析</h1>\n<p>TRU 合约是一个代理合约：0x764C64b2A09b09Acb100B80d8c505Aa6a0302EF2</p>\n<p>其具体的逻辑逻辑合约为：0x18ceDF1071EC25331130C82D7AF71D393Ccd4446</p>\n<p>由于逻辑合约并没有开源，所以接下来会采用 dedaub 反编译 + 人工校正的方式分析项目的业务逻辑。</p>\n<ul>\n<li>逻辑合约的反编译地址：<a href=\"https://app.dedaub.com/ethereum/address/0xc186e6f0163e21be057e95aa135edd52508d14d3/decompiled\" rel=\"noopener nofollow\" target=\"_blank\">https://app.dedaub.com/ethereum/address/0xc186e6f0163e21be057e95aa135edd52508d14d3/decompiled</a></li>\n</ul>\n<p>在 buyTRU() 函数中，会根据输入的 TRUAmount 参数值计算所需要的 ETH 数量，并检查 msg.value 的值是否为相等。通过检查后，会给用户 mint TRUAmount 数量的 TRU 代币。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154138455-1713236541.png\" /></p>\n<p>其问题就出在计算 ETH 数量的 TRUtoETH() 函数上，其反编译的内容如下，根据输入的 TRUAmount 值进行一系列的计算。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154148291-397462858.png\" /></p>\n<p>通过 solidity 重写这个函数，得到以下的内容。其中 _setParameters 的值为 75，代表 75% 的一个比例。</p>\n<pre><code class=\"language-solidity\">function TRUtoETH(uint256 TRUAmount) private view returns (uint256) {\n    uint256 totalSupply = TRU.totalSupply();\n    \n    // numerator: (100 - 75) * totalSupply² = 25 * totalSupply²\n    uint256 numerator = (100 - _setParameters) * totalSupply * totalSupply;\n    \n    // denominator: 100 * TRUAmount * _reserve * (TRUAmount + 2 * totalSupply)\n    uint256 denominator = 100 * TRUAmount * _reserve * (TRUAmount + 2 * totalSupply);\n    \n    return numerator / denominator;\n}\n\n</code></pre>\n<p>由上面的代码分析可得，当 _setParameters，totalSupply 和 _reserve 为固定值时，传入的参数 TRUAmount 越大，分母就越大，返回值就会相应的变小。而当分母大于分子时，由于 solidity 精度丢失的特性，返回值将会为 0。也就是说：</p>\n<blockquote>\n<p>当 TRUAmount 的值非常大，当前的计算公式在计算所需要提供的 ETH 数量时，会由于 solidity 的精度丢失返回 0 值。</p>\n</blockquote>\n<p>这样，攻击者就完成了攻击的第一个步骤：以零或极低成本的价格购买 TRU 代币。</p>\n<p>随后就是正常使用 sellTRU() 函数卖出所有 TRU 代币完成了获利。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154205268-1163820900.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 15:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ACaiGarden\">ACai_sec</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【Azure Redis】客户端应用使用 Azure Redis Cluster 报错 java.security.cert.CertificateException: No subject alternative names matching IP address xxx.xxx.xxx.xxx found",
      "link": "https://www.cnblogs.com/lulight/p/19464831",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19464831\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 12:02\">\n    <span>【Azure Redis】客户端应用使用 Azure Redis Cluster 报错 java.security.cert.CertificateException: No subject alternative names matching IP address xxx.xxx.xxx.xxx found</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>问题描述</h1>\n<p>使用Azure Cache for Redis的集群模式。应用客户端为Java代码，使用Lettuce 作为Redis 客户端SDK。启动项目报错：<span style=\"color: rgba(255, 0, 0, 1);\"><strong><span style=\"font-style: italic; background-color: initial;\">Caused by: java.security.cert.CertificateException: No subject alternative names matching IP address 159.27.xxx.xxx found。</span></strong></span></p>\n<h2><span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: initial;\">运行时的错误截图</span></strong></span></h2>\n<p><img alt=\"image\" class=\"lazyload\" height=\"435\" width=\"666\" /></p>\n<h2>示例代码</h2>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.lbazureredis;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.RedisURI;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.RedisClusterClient;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Main {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> main(String[] args) {\n        \n        System.out.println(</span>\"Hello world! This is Redis Cluster example.\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        \n        RedisURI redisUri </span>= RedisURI.Builder.redis(\"&lt;yourredisname&gt;.redis.cache.chinacloudapi.cn\", 6380<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPassword(</span>\"&lt;your redis access key&gt;\").withSsl(<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">).build();\n        RedisClusterClient clusterClient </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> RedisClusterClient.create(redisUri);\n        StatefulRedisClusterConnection</span>&lt;String, String&gt; connection =<span style=\"color: rgba(0, 0, 0, 1);\"> clusterClient.connect();\n        RedisAdvancedClusterCommands</span>&lt;String, String&gt; syncCommands =<span style=\"color: rgba(0, 0, 0, 1);\"> connection\n                .sync();\n\n        String pingResponse </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> syncCommands.ping();\n        System.out.println(</span>\"Ping response: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> pingResponse);\n\n        syncCommands.set(</span>\"mykey\", \"Hello, Redis Cluster!\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        String value </span>= syncCommands.get(\"mykey\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        System.out.println(</span>\"Retrieved value: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> value);\n        \n        connection.close();\n        clusterClient.shutdown();\n\n    }\n}</span></pre>\n</div>\n<h2>项目POM.xml</h2>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">&lt;?</span><span style=\"color: rgba(255, 0, 255, 1);\">xml version=\"1.0\" encoding=\"UTF-8\"</span><span style=\"color: rgba(0, 0, 255, 1);\">?&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">project </span><span style=\"color: rgba(255, 0, 0, 1);\">xmlns</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"http://maven.apache.org/POM/4.0.0\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n         xmlns:xsi</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"http://www.w3.org/2001/XMLSchema-instance\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n         xsi:schemaLocation</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">modelVersion</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>4.0.0<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">modelVersion</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>com.lbazureredis<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>test<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>1.0-SNAPSHOT<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">properties</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.source</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>17<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.source</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.target</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>17<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.target</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">properties</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">dependencies</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> Lettuce Redis Client </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>io.lettuce<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>lettuce-core<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>6.3.1.RELEASE<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> SLF4J for logging </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>org.slf4j<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>slf4j-simple<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>2.0.9<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">dependencies</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">project</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span></pre>\n</div>\n<p><span style=\"font-size: 18px; color: rgba(255, 0, 0, 1);\"><strong>针对以上问题，如何解决呢？</strong></span></p>\n<p>&nbsp;</p>\n<h1>问题解答</h1>\n<p>根据错误信息搜索后，得到Azure官方最佳实践文档中的解答：<a href=\"https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md</a></p>\n<blockquote>\n<p>The reason this is required is because SSL certification validates the address of the Redis Nodes with the SAN (Subject Alternative Names) in the SSL certificate. <strong>Redis protocol requires that these node addresses should be IP addresses.</strong> However, the SANs in<strong> the Azure Redis SSL certificates contains only the Hostname</strong> since Public IP addresses can change and as a result not completely secure.</p>\n<p>在Redis Protocol验证中，必须验证证书中包含IP地址，但由于Azure Redis部署在云环境中，IP地址是不固定的。所以默认情况下，Redis SSL证书中包含的是域名。为了解决这个问题，需要建立一个Host与IP地址的映射关系，使得Lettuce客户端在验证Redis证书时通过域名验证而非IP地址，用于解决<strong>No subject alternative names matching IP address 159.27.xxx.xxx found </strong>问题</p>\n</blockquote>\n<p>参考文档中的方法，自定义<strong><code>MappingSocketAddressResolver</code></strong></p>\n<div class=\"cnblogs_code\">\n<pre>        Function&lt;HostAndPort, HostAndPort&gt; <span style=\"background-color: rgba(255, 204, 0, 1);\">mappingFunction</span> = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Function&lt;HostAndPort, HostAndPort&gt;<span style=\"color: rgba(0, 0, 0, 1);\">() {\n            @Override\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort apply(HostAndPort hostAndPort) {\n                String cacheIP </span>= \"\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                    InetAddress[] addresses </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DnsResolvers.JVM_DEFAULT.resolve(host);\n                    cacheIP </span>= addresses[0<span style=\"color: rgba(0, 0, 0, 1);\">].getHostAddress();\n                } </span><span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (UnknownHostException e) {\n                    e.printStackTrace();\n                }\n                HostAndPort finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> hostAndPort;\n\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (hostAndPort.hostText.equals(cacheIP))\n                    finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort.of(host, hostAndPort.getPort());\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> finalAddress;\n            }\n        };\n\n        <span style=\"background-color: rgba(255, 204, 0, 1);\">MappingSocketAddressResolver</span> resolver </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MappingSocketAddressResolver.create(DnsResolvers.JVM_DEFAULT,\n                mappingFunction);\n        <span style=\"background-color: rgba(255, 204, 0, 1);\">ClientResources</span> res </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DefaultClientResources.builder()\n                .socketAddressResolver(resolver).build();\n        RedisURI redisURI </span>= RedisURI.Builder.redis(host).withSsl(<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPassword(password)\n                .withClientName(</span>\"LettuceClient\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPort(</span>6380<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .build();\n        RedisClusterClient redisClient </span>= RedisClusterClient.create(<span style=\"background-color: rgba(255, 204, 0, 1);\">res</span>, redisURI);</pre>\n</div>\n<h2>代码解读</h2>\n<blockquote>\n<h3>mappingFunction</h3>\n<ul>\n<li>它是一个自定义的地址映射逻辑，用于处理 Lettuce 在连接 Redis 集群时的主机名与 IP 地址问题。</li>\n<li>它通过 DnsResolvers.JVM_DEFAULT 对指定的域名进行 DNS 解析，获取对应的 IP 地址。如果当前 HostAndPort 的 hostText 与解析出的 IP 相同，则将其替换为原始域名 host，保持端口不变。</li>\n<li>这一逻辑的核心目的是解决 SSL 证书校验问题，因为证书通常绑定域名而非 IP，确保连接时使用域名进行验证，避免因 IP 导致的握手失败。</li>\n</ul>\n<h3>MappingSocketAddressResolver</h3>\n<ul>\n<li>它是 Lettuce 提供的一个工具类，用于在连接 Redis 时插入自定义的地址解析逻辑。</li>\n<li>它结合默认的 DNS 解析器和 mappingFunction，在每次解析 Socket 地址时执行映射操作。</li>\n<li>通过这种方式，客户端可以在 DNS 解析后对结果进行二次处理，例如将 IP 地址重新映射为域名。</li>\n<li>这对于云服务场景（如 Azure Redis）非常重要，因为这些服务的 SSL 证书通常只对域名有效，而不是 IP 地址。</li>\n</ul>\n<h3>DefaultClientResources</h3>\n<ul>\n<li><span style=\"background-color: initial; font-size: 14px;\">作为 Lettuce 的核心资源管理器，用于配置客户端的底层行为，包括线程池、DNS 解析器、事件循环等。在这里，它的作用是将自定义的 MappingSocketAddressResolver 注入到客户端资源中，使所有连接请求都遵循自定义的地址解析逻辑。</span></li>\n<li><span style=\"background-color: initial; font-size: 14px;\">通过这种方式，整个 Lettuce 客户端在连接 Redis 集群时都会使用域名而非 IP，确保 SSL 校验通过，同时保持连接的稳定性和安全性。</span></li>\n</ul>\n</blockquote>\n<p>&nbsp;</p>\n<h2>执行结果</h2>\n<p>再次运行，成功连接到Azure Redis Cluster 及执行Ping, Set, Get指令！</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"541\" width=\"999\" /></p>\n<h2>修改后完整的Java示例代码如下：</h2>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.lbazureredis;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.net.InetAddress;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.net.UnknownHostException;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.time.Duration;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.function.Function;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.RedisURI;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.SocketOptions;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.api.StatefulRedisConnection;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.ClusterClientOptions;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.ClusterTopologyRefreshOptions;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.RedisClusterClient;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.async.RedisAdvancedClusterAsyncCommands;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.internal.HostAndPort;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.ClientResources;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.DefaultClientResources;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.DnsResolvers;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.MappingSocketAddressResolver;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Main {\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> main(String[] args) {\n\n        System.out.println(</span>\"Hello world! This is Redis Cluster example.\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n\n        String host </span>= \"&lt;yourredisname&gt;.redis.cache.chinacloudapi.cn\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n        String password </span>= \"&lt;your redis access key&gt;\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n\n        Function</span>&lt;HostAndPort, HostAndPort&gt; <span style=\"background-color: rgba(255, 204, 0, 1);\">mappingFunction</span> = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Function&lt;HostAndPort, HostAndPort&gt;<span style=\"color: rgba(0, 0, 0, 1);\">() {\n            @Override\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort apply(HostAndPort hostAndPort) {\n                String cacheIP </span>= \"\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                    InetAddress[] addresses </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DnsResolvers.JVM_DEFAULT.resolve(host);\n                    cacheIP </span>= addresses[0<span style=\"color: rgba(0, 0, 0, 1);\">].getHostAddress();\n                } </span><span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (UnknownHostException e) {\n                    e.printStackTrace();\n                }\n                HostAndPort finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> hostAndPort;\n\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (hostAndPort.hostText.equals(cacheIP))\n                    finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort.of(host, hostAndPort.getPort());\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> finalAddress;\n            }\n        };\n\n        MappingSocketAddressResolver resolver </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MappingSocketAddressResolver.create(DnsResolvers.JVM_DEFAULT,\n                <span style=\"background-color: rgba(255, 204, 0, 1);\">mappingFunction</span>);\n        ClientResources res </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DefaultClientResources.builder()\n                .socketAddressResolver(resolver).build();\n        RedisURI redisURI </span>= RedisURI.Builder.redis(host).withSsl(<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPassword(password)\n                .withClientName(</span>\"LettuceClient\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPort(</span>6380<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .build();\n        RedisClusterClient redisClient </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> RedisClusterClient.create(<span style=\"background-color: rgba(255, 204, 0, 1);\">res</span>, redisURI);\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Cluster specific settings for optimal reliability.</span>\n        ClusterTopologyRefreshOptions refreshOptions =<span style=\"color: rgba(0, 0, 0, 1);\"> ClusterTopologyRefreshOptions.builder()\n                .enablePeriodicRefresh(Duration.ofSeconds(</span>5<span style=\"color: rgba(0, 0, 0, 1);\">))\n                .dynamicRefreshSources(</span><span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                .adaptiveRefreshTriggersTimeout(Duration.ofSeconds(</span>5<span style=\"color: rgba(0, 0, 0, 1);\">))\n                .enableAllAdaptiveRefreshTriggers().build();\n        redisClient.setOptions(ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder()\n                        .keepAlive(</span><span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                        .build())\n                .topologyRefreshOptions(refreshOptions).build());\n                \n        StatefulRedisClusterConnection</span>&lt;String, String&gt; connection =<span style=\"color: rgba(0, 0, 0, 1);\"> redisClient.connect();\n        RedisAdvancedClusterCommands</span>&lt;String, String&gt; syncCommands =<span style=\"color: rgba(0, 0, 0, 1);\"> connection.sync();\n        RedisAdvancedClusterAsyncCommands</span>&lt;String, String&gt; asyncCommands =<span style=\"color: rgba(0, 0, 0, 1);\"> connection.async();\n\n        String pingResponse </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> syncCommands.ping();\n        System.out.println(</span>\"Ping response: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> pingResponse);\n\n        syncCommands.set(</span>\"mykey\", \"Hello, Redis Cluster!\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        String value </span>= syncCommands.get(\"mykey\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        System.out.println(</span>\"Retrieved value: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> value);\n\n        connection.close();\n\n        redisClient.shutdown();\n\n    }\n}</span></pre>\n</div>\n<h2>代码流程图</h2>\n<p>基于AI模型解读以上代码后，分析出来的代码流程图</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"256\" width=\"666\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1>参考资料</h1>\n<div class=\"markdown-heading\" dir=\"auto\">\n<p class=\"heading-element\" dir=\"auto\">Best Practices for using Azure Cache for Redis with Lettuce ：<a href=\"https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md</a></p>\n<div>&nbsp;</div>\n<a class=\"anchor\" href=\"https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md#best-practices-for-using-azure-cache-for-redis-with-lettuce\" id=\"user-content-best-practices-for-using-azure-cache-for-redis-with-lettuce\" rel=\"noopener nofollow\"></a></div>\n</div>\n<div id=\"MySignature\">\n    <div style=\"background: #1c5f55; height: 36px; width: 618px; padding: 14px 5px 0px 3px;\">\n  <p style=\"font-weight: bold; color: white;\">当在复杂的环境中面临问题，格物之道需：浊而静之徐清，安以动之徐生。 云中，恰是如此!</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 12:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lulight\">路边两盏灯</a>&nbsp;\n阅读(<span id=\"post_view_count\">18</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "棒棒糖图：当条形图遇上极简美学",
      "link": "https://www.cnblogs.com/wang_yb/p/19464212",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19464212\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 08:42\">\n    <span>棒棒糖图：当条形图遇上极简美学</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>棒棒糖图</strong>（Lollipop Chart）可以看作是条形图的一种“轻盈版”变体：它用一根从基准线延伸出来的“棒”，并在末端以一个“糖”（圆点）来表示数值，取代了传统的矩形条。</p>\n<p>这种图表传达的信息与条形图是一样的，但它更注重突出数据点的位置，整体看起来更加清新、现代。</p>\n<p>今天，我们一起探索棒棒糖图的优势，并通过代码实现，亲手打造一个属于自己的棒棒糖图！</p>\n<h1 id=\"设计原理\">设计原理</h1>\n<p>设计棒棒糖图的初衷有两个方面：</p>\n<p>首先，通过减少图形中的“墨水”使用量，在面对大量类别或数值普遍较高的情况下，避免了条形图过于密集可能带来的<strong>视觉压迫感</strong>和<strong>杂乱无章</strong>的感觉；</p>\n<p>其次，这样的设计能够更好地引导观察者的注意力集中在各个数据点的具体位置及其之间的差异上，非常适合用来进行排名或者对比分析。</p>\n<p><strong>棒棒糖图</strong>与<strong>条形图</strong>在功能上是等价的，也并不总是优于条形图。</p>\n<p>当处理大量类别、条柱非常高且相互之间距离较近的数据时，棒棒糖图会显得更加易于阅读理解；</p>\n<p>然而，在需要强调绝对数量或是希望获得最为直观长度比较的情况下，条形图依然是更好的选择。</p>\n<h1 id=\"实现原理\">实现原理</h1>\n<p><strong>棒棒糖图</strong>在<code>matplotlib</code>库中没有直接对应的类。</p>\n<p>不过，它的实现原理非常简单，通过组合使用 <code>matplotlib</code> 中的两个基本绘图功能就可以实现：</p>\n<ol>\n<li><strong>绘制线条</strong> (<code>plt.vlines</code>)：这是构成棒棒糖“棍子”部分的关键。</li>\n</ol>\n<p><code>plt.vlines</code> 函数用于在图表上绘制垂直线段。通过指定每个数据点的 x 坐标、线条的起始点（通常是 0）和结束点（即对应数据的 y 值），就可以画出从 x 轴延伸到数据值的线条。</p>\n<ol start=\"2\">\n<li><strong>绘制圆点</strong> (<code>plt.scatter</code>)：这是构成棒棒糖“糖”部分的关键。</li>\n</ol>\n<p><code>plt.scatter</code> 函数用于绘制散点图。通过将每个数据点的 x 坐标和 y 坐标（即数据值）作为参数传入，就可以在每条线的顶端绘制一个圆点。</p>\n<p>总的来说，<strong>实现原理</strong>就是：用线条表示数值的大小，用圆点强调数值的终点位置，两者结合就形成了视觉上类似棒棒糖的图表。</p>\n<p>这种组合方式使得图表比实心的条形图更简洁，同时又能清晰地传达数据信息。</p>\n<p>下一节的示例中，将会演示如何使用<code>matplotlib</code>来绘制<strong>棒棒糖图</strong>。</p>\n<h1 id=\"应用示例\">应用示例</h1>\n<p>接下来，让我们通过实际的对比示例，直观地感受棒棒糖图与传统条形图的不同表现。</p>\n<h2 id=\"适合棒棒糖图的场景\">适合棒棒糖图的场景</h2>\n<pre><code class=\"language-python\"># 创建更多类别的测试数据\n# 模拟不同月份中每天的某个指标（例如：每日平均步数，单位：千步）\ndays = [f\"Day {i}\" for i in range(1, 21)]  # 生成 20 天的数据\nnp.random.seed(42)  # 设置随机种子，确保每次运行结果一致\n# 生成 1 到 5 之间的随机数值作为示例数据\nvalues = np.round(np.random.uniform(1.0, 5.0, size=len(days)), 1)\n\n# --- 创建子图 ---\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))  # 调整为垂直布局，方便比较\n\n# --- 绘制条形图 (上图) ---\nbars = ax1.bar(days, values, color=\"skyblue\", edgecolor=\"navy\", linewidth=0.7)\nax1.set_title(\"条形图 (Bar Chart) - 每日步数\", fontsize=14)\nax1.set_ylabel(\"数值 (千步)\")\n# ax1.set_xlabel('日期') # x轴标签已在下方图中\nax1.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n# 在条形图上添加数值标签\nfor bar, val in zip(bars, values):\n    height = bar.get_height()\n    ax1.text(\n        bar.get_x() + bar.get_width() / 2.0,\n        height + 0.05,\n        f\"{val}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=8,\n    )  # 标签旋转90度节省空间\n\n# --- 绘制棒棒糖图 (下图) ---\n# 1. 绘制线条\nax2.vlines(x=range(len(days)), ymin=0, ymax=values, color=\"navy\", linewidth=2)\n# 2. 在线条顶部绘制圆点\nax2.scatter(x=range(len(days)), y=values, color=\"red\", s=50, zorder=3)\n# 3. 添加数值标签\nfor i, val in enumerate(values):\n    ax2.text(i, val + 0.1, f\"{val}\", ha=\"center\", va=\"bottom\", fontsize=8)\n\nax2.set_title(\"棒棒糖图 (Lollipop Chart) - 每日步数\", fontsize=14)\nax2.set_ylabel(\"数值 (千步)\")\nax2.set_xlabel(\"日期\")\nax2.set_xticks(range(len(days)))\nax2.set_xticklabels(days, rotation=45, ha=\"right\")  # 旋转x轴标签以便阅读\nax2.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\nax2.set_ylim(0, max(values) * 1.1)\n\n# --- 显示图形 ---\nplt.tight_layout()  # 调整子图间距\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260110084120492-216729079.png\" /></p>\n<p>这个示例使用了20个数据类别（Day 1 到 Day 20）。</p>\n<p>你可以看到，在条形图中，许多蓝色的条形紧密地排列在一起，视觉上显得有些拥挤。</p>\n<p>而在棒棒糖图中，线条和圆点使得数据点之间的关系更加清晰，整体视觉效果更轻盈，更容易比较各个数值的大小和识别模式。</p>\n<h2 id=\"适合传统条形图的场景\">适合传统条形图的场景</h2>\n<pre><code class=\"language-python\"># 创建更适合条形图的测试数据\n# 模拟某公司连续12个月的销售额（单位：万元）\nmonths = [\n    \"1月\",\n    \"2月\",\n    \"3月\",\n    \"4月\",\n    \"5月\",\n    \"6月\",\n    \"7月\",\n    \"8月\",\n    \"9月\",\n    \"10月\",\n    \"11月\",\n    \"12月\",\n]\n# 生成有一定趋势和波动的销售额数据，例如有季节性高峰\nsales = [120, 110, 135, 140, 155, 170, 185, 180, 160, 150, 145, 165]\n\n# --- 创建子图 ---\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))\n\n# --- 绘制条形图 (左图) ---\nbars = ax1.bar(months, sales, color=\"lightsteelblue\", edgecolor=\"black\", linewidth=0.7)\nax1.set_title(\"条形图 (Bar Chart - 月份销售额)\", fontsize=14)\nax1.set_ylabel(\"销售额 (万元)\")\nax1.set_xlabel(\"月份\")\nax1.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n# 在条形图上添加数值标签\nfor bar, s in zip(bars, sales):\n    height = bar.get_height()\n    ax1.text(\n        bar.get_x() + bar.get_width() / 2.0,\n        height + 2,\n        f\"{s}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=9,\n    )\n\n# --- 绘制棒棒糖图 (右图) ---\nax2.vlines(x=range(len(months)), ymin=0, ymax=sales, color=\"gray\", linewidth=2)\nax2.scatter(x=range(len(months)), y=sales, color=\"coral\", s=50, zorder=3)\nfor i, s in enumerate(sales):\n    ax2.text(i, s + 3, f\"{s}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nax2.set_title(\"棒棒糖图 (Lollipop Chart - 月份销售额)\", fontsize=14)\nax2.set_ylabel(\"销售额 (万元)\")\nax2.set_xlabel(\"月份\")\nax2.set_xticks(range(len(months)))\nax2.set_xticklabels(months, rotation=45)  # 旋转x轴标签以防重叠\nax2.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\nax2.set_ylim(0, max(sales) * 1.1)\n\n# --- 显示图形 ---\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260110084120515-917001944.png\" /></p>\n<p>在这个示例中，数据代表的是连续的月份，数值本身代表的是销售额，这是一个“量”的概念。</p>\n<p>条形图的实心块能让人立刻感受到哪个月份的销售额更高，整体的分布和对比关系一目了然。</p>\n<p>而棒棒糖图虽然也展示了数据，但线条和圆点的组合在视觉上不如实心条形那样能直接传达“量”的感觉，尤其是在数值差异不是特别巨大时，对比效果会稍逊于条形图。</p>\n<h1 id=\"总结\">总结</h1>\n<p><strong>棒棒糖图</strong>就像数据可视化世界中的\"少即是多\"哲学体现。</p>\n<p>它不是要取代传统条形图，而是为数据可视化工具箱增加了一个有价值的选项。</p>\n<p>就像不同的画笔适合不同的绘画风格，不同的图表类型也适合不同的数据故事。</p>\n<p><strong>棒棒糖图</strong>的真正优势在于它改变了数据的<strong>\"讲述方式\"</strong>。</p>\n<p>它不说：\"这是所有信息，你自己找重点\"，而是说：\"看这里，这些是关键点\"。</p>\n<p>这种焦点导向的特性，使得棒棒糖图在现代快节奏的数据沟通中越来越受欢迎。</p>\n<p>设计可视化时，我们不妨问问自己：我想要观众首先看到什么？如果是精确的数值点和清晰的排名，那么棒棒糖图可能是你的理想选择。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 08:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">106</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Thread 类的基本用法、Java 线程的几种状态",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19463416",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19463416\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 00:05\">\n    <span>Thread 类的基本用法、Java 线程的几种状态</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"在java中thread类是多线程编程的核心\">在Java中，Thread类是多线程编程的核心。</h3>\n<h4 id=\"线程创建-thread-creation\">线程创建 (Thread Creation)</h4>\n<ul>\n<li>创建线程主要有两种逻辑：继承Thread类或实现Runnable接口。\n<ul>\n<li>方式1：继承 Thread 类，重写run()</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-java\">// 自定义线程类继承Thread\nclass MyThread extends Thread {\n    // 重写run()，定义线程执行逻辑\n    @Override\n    public void run() {\n        System.out.println(\"子线程执行：\" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread t = new MyThread();\n        t.start(); // 3. 调用start()启动线程（不能直接调用run()）\n    }\n}\n</code></pre>\n<ul>\n<li>方式2：实现Runnable接口，传给Thread</li>\n</ul>\n<pre><code class=\"language-java\">// 实现Runnable接口\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"子线程执行：\" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\npublic class Demo {\n    public static void main(String[] args) {\n        // 把Runnable实例传给Thread\n        Thread t = new Thread(new MyRunnable());\n        t.start(); // 启动线程\n    }\n}\n</code></pre>\n<h4 id=\"线程中断-thread-interruption\">线程中断 (Thread Interruption)</h4>\n<ul>\n<li>线程中断不是强制停止线程，而是一种协作机制，即给线程发一个“请停止”的信号。</li>\n<li>void interrupt()：标记线程为 “中断状态”</li>\n<li>boolean isInterrupted()：判断线程是否处于中断状态</li>\n<li>若线程在sleep/wait/join时被中断，会抛出InterruptedException，且中断状态会被清除</li>\n</ul>\n<pre><code class=\"language-java\">Thread t = new Thread(() -&gt; {\n    while (!Thread.currentThread().isInterrupted()) { // 检测中断状态\n        System.out.println(\"线程运行中...\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // 捕获中断异常后，中断状态会被清除，需手动终止循环\n            System.out.println(\"线程被中断\");\n            Thread.currentThread().interrupt(); // 重新标记中断（可选）\n            break;\n        }\n    }\n});\nt.start();\n// 主线程1秒后中断子线程\nThread.sleep(1000);\nt.interrupt();\n</code></pre>\n<h4 id=\"线程等待-thread-join\">线程等待 (Thread Join)</h4>\n<ul>\n<li>有时主线程需要等待子线程执行完毕后再继续执行，这时可以使用join()。</li>\n<li>t.join()：当前线程会进入阻塞状态，直到线程t执行结束。</li>\n<li>带参数的 join(long millis)：设置最大等待时间，如果超时线程还没结束，当前线程就不再等待。</li>\n</ul>\n<pre><code class=\"language-java\">Thread t = new Thread(() -&gt; {\n    System.out.println(\"子线程开始执行\");\n    try { Thread.sleep(2000); } catch (InterruptedException e) {}\n    System.out.println(\"子线程执行完毕\");\n});\nt.start();\n\n// 主线程等待t执行完（最多等3秒）\nt.join(3000); \nSystem.out.println(\"主线程继续执行\");\n</code></pre>\n<h4 id=\"线程休眠-thread-sleep\">线程休眠 (Thread Sleep)</h4>\n<ul>\n<li>static void sleep(long millis)：让当前线程暂停指定时间（不会释放锁），抛出InterruptedException</li>\n</ul>\n<pre><code class=\"language-java\">System.out.println(\"开始休眠\");\ntry {\n    Thread.sleep(2000); // 当前线程休眠2秒\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.println(\"休眠结束\");\n</code></pre>\n<h4 id=\"获取线程实例-get-current-instance\">获取线程实例 (Get Current Instance)</h4>\n<ul>\n<li>在编写通用代码（尤其是 Runnable 中）时，常需要知道是谁在运行。</li>\n<li>Thread.currentThread()：返回代码当前正在执行的那个线程对象的引用。</li>\n<li>常用操作：获取线程 ID (getId())、获取线程名称 (getName()) 等。</li>\n</ul>\n<pre><code class=\"language-java\">// 获取当前线程（这里是main线程）\nThread mainThread = Thread.currentThread();\nSystem.out.println(\"当前线程名：\" + mainThread.getName()); // 输出\"main\"\n\n// 子线程实例\nThread t = new Thread(() -&gt; {\n    Thread current = Thread.currentThread();\n    System.out.println(\"子线程名：\" + current.getName()); // 输出\"Thread-0\"\n});\nt.start();\n</code></pre>\n<hr />\n<h3 id=\"java线程的几种状态\">Java线程的几种状态</h3>\n<h4 id=\"线程状态一共有几种\">线程状态一共有几种？</h4>\n<ul>\n<li>Java线程共有6种状态：\n<ul>\n<li>NEW (新建)</li>\n<li>RUNNABLE (可运行)</li>\n<li>BLOCKED (阻塞)</li>\n<li>WAITING (等待)</li>\n<li>TIMED_WAITING (超时等待)</li>\n<li>TERMINATED (终止)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"每种状态的含义与切换条件\">每种状态的含义与切换条件</h4>\n<ol>\n<li>NEW (新建)</li>\n</ol>\n<ul>\n<li>含义：创建了线程对象（new Thread()），但尚未调用 start() 方法。</li>\n<li>切换：调用 start() 方法后，进入 RUNNABLE 状态。</li>\n</ul>\n<ol start=\"2\">\n<li>RUNNABLE (可运行)</li>\n</ol>\n<ul>\n<li>含义：Java 将操作系统中的“就绪（Ready）”和“运行中（Running）”两种状态统称为 RUNNABLE。处于该状态的线程可能正在 CPU 上执行，也可能正在等待操作系统分配时间片。</li>\n<li>切换：\n<ul>\n<li>就绪 -&gt; 运行：获得 CPU 时间片。</li>\n<li>运行 -&gt; 就绪：CPU 时间片用完，或主动调用 Thread.yield()。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>BLOCKED (阻塞)</li>\n</ol>\n<ul>\n<li>含义：线程正在等待获取一个排他锁（如进入synchronized 代码块/方法），但该锁目前被其他线程持有。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; BLOCKED：尝试进入 synchronized 区域失败。</li>\n<li>BLOCKED -&gt; RUNNABLE：其他线程释放锁，当前线程成功竞争到锁。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li>WAITING (等待)</li>\n</ol>\n<ul>\n<li>含义：线程处于无限期的等待状态，不会被分配 CPU 时间，必须等待其他线程显式地唤醒。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; WAITING：调用 Object.wait()（不带参数）、Thread.join()（不带参数）或 LockSupport.park()。</li>\n<li>WAITING -&gt; RUNNABLE：其他线程调用 Object.notify()、notifyAll() 或 LockSupport.unpark()。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>TIMED_WAITING (超时等待)</li>\n</ol>\n<ul>\n<li>含义：与 WAITING 类似，但在指定的时间后会自动唤醒，不需要其他线程显式唤醒。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; TIMED_WAITING：调用 Thread.sleep(ms)、Object.wait(ms)、Thread.join(ms) 等带时间参数的方法。</li>\n<li>TIMED_WAITING -&gt; RUNNABLE：时间结束，或被提前唤醒（如 notify()）。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"6\">\n<li>TERMINATED (终止)</li>\n</ol>\n<ul>\n<li>含义：线程已经执行完毕（run() 方法正常结束）或因异常退出了执行。</li>\n<li>切换：线程一旦进入此状态，生命周期结束，不可再次启动（再次调用 start() 会抛出异常）。</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 00:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "初识Tauri",
      "link": "https://www.cnblogs.com/-867259206/p/19463606",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/-867259206/p/19463606\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 23:24\">\n    <span>初识Tauri</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简述\">简述</h1>\n<p>Tauri是一个跨平台的开发框架，使用rust开发。前端用前端技术构建用户界面，后端使用rust和平台系统交互。</p>\n<h2 id=\"创建项目\">创建项目</h2>\n<p>可以用Bash/PowerShell/Fish/npm/deno/Cargo等工具创建项目。</p>\n<p>下面以pnpm示例：</p>\n<pre><code class=\"language-bash\">pnpm create tauri-app\n</code></pre>\n<p>后面的步骤和创建前端项目是一样的。根据提示选择前端的语言、框架等等。</p>\n<p>项目目录和前端项目也是一样的，只是多了一个src-tauri目录。</p>\n<p>src-tauri目录下就是rust代码，可以在里面编写供前端调用的方法，或者是给前端发送事件消息。</p>\n<p>界面的开发使用前端技术，可以用react，也可以用vue，或者其他前端框架。与平台系统交互的功能，用rust编写。</p>\n<p>对Web开发者来说，用这个技术可以快速地创建桌面应用。</p>\n<h2 id=\"发布\">发布</h2>\n<p>要打包成桌面应用的话，执行build命令就好。</p>\n<p>继续以pnpm为例：</p>\n<pre><code class=\"language-bash\">pnpm tauri build\n</code></pre>\n<blockquote>\n<p>提示：build之前要先安装rust环境</p>\n</blockquote>\n<p>目前Tauri支持Linux、macOS、Windows、Android、iOS。</p>\n<p>打包后的启动程序在src-tauri/target/release/bundle目录下。执行安装程序，安装好后，就可以打开编写的桌面应用了。</p>\n<h1 id=\"架构\">架构</h1>\n<p><img alt=\"架构\" class=\"lazyload\" />Tauri的核心包含一个Tauri的运行时，tauri-runtime在tauri本身和底层的webview抽象层中充当一个胶水层。</p>\n<p>Tauri使用WRY这个开源库做webview的抽象层。WRY是一个rust编写的webview渲染库，可以支持各种平台的桌面应用。在WRY和tauri-runtime之间，有一个tauri-runtime-wry，这一层为WRY定义了系统级的交互。</p>\n<p>而WRY的下层依赖TAO。TAO是基于winit的一个fork。这是一个rust编写的跨平台的窗口管理类库。支持几乎所有的主流平台，Windows、Linux、Mac OS、Android、iOS……</p>\n<p>最后简单总结：Tauri实现跨平台应用的方式是，实现一个webview的抽象，从而可以用前端技术编写GUI，webview抽象层的底层，则依赖rust的窗口管理类库，调用各个平台系统的webview库。</p>\n<h1 id=\"总结\">总结</h1>\n<p>用rust作后端，使Tauri有很高的性能。但是调用平台系统本身webview的跨平台方式，使GUI在不同平台上的表现不一致，有兼容性问题。</p>\n<p>和electron相比，拥有更小的包体积，因为没有打包chromium，也没有源码泄露之类的风险，性能也更好，还能打包移动端，但是会有兼容性问题，而且后端用rust的话，不如electron好上手，如果不是rust熟手的话。</p>\n<p>和flutter相比，同样有兼容性问题，dart也比rust好学。</p>\n<p>对rust开发者来说，只需要找rust的GUI库就行，没有必要去用前端编写GUI。而对前端开发者来说，rust又增加了开发的学习成本。这个框架，感觉只适合同时会rust的前端熟手。而且只有少数对性能要求较高的场景会需要使用，其他场景electron也不差。如果要开发跨平台的应用，兼容性又是一个问题。实际的产品表现，肯定不如flutter这类框架。</p>\n<p>在前端工具链也越来越多使用rust语言的时候，Tauri这些rust编写的框架也被一些前端开发者所使用。但如果我要开发一个跨平台的应用的话，我觉得自带绘图库的flutter的方案是最佳的。Tauri的兼容性问题，仍不能满足做商业应用的要求，能使用的场景太少了。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 23:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/-867259206\">池月</a>&nbsp;\n阅读(<span id=\"post_view_count\">20</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款基于 .NET 9 构建的企业级 Web RBAC 快速开发框架",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19463583",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19463583\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 23:03\">\n    <span>一款基于 .NET 9 构建的企业级 Web RBAC 快速开发框架</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>今天大姚给大家分享一款基于 .NET 9 构建的企业级、开源 Web RBAC 快速开发框架：RuYiAdmin。</span></p>\n<h2><span>项目介绍</span></h2>\n<p><span>RuYiAdmin 一款基于 .NET 9 构建的企业级、前后端分离、开源（Apache License） Web RBAC 快速开发框架，具有灵活的架构设计和强大的功能，适用于快速开发高性能的企业级应用，具有低代码、跨平台、分布式、多线程和高性能等特色。</span></p>\n<h2><span>适用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><span>企业级后台管理系统：用于企业内部的各种管理任务，如用户管理、权限控制、数据统计等。</span></li>\n<li><span>内容管理系统（CMS）：用于网站内容的创建、编辑、发布和管理。</span></li>\n<li><span>客户关系管理（CRM）系统：帮助企业跟踪和管理客户信息、销售机会和客户服务请求。</span></li>\n</ul>\n<h2><span>主要特点</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>前后端分离：</strong><span>&nbsp;RuYiAdmin 采用前后端分离架构，前端基于VueElementAdmin，使用 Vue2 和 Element UI，后端基于 .NET 9 构建。</span></li>\n<li><strong>代码自动生成：</strong><span>&nbsp;支持一键生成视图层、控制层、服务层、仓储层、领域层和 DTO 业务模型层代码，极大地缩短了开发周期。</span></li>\n<li><strong>多数据库支持：</strong><span>&nbsp;支持多种关系型数据库（如 MySQL、SqlServer、SQLite、Oracle、PostgreSQL、OpenGauss、<span>Kingbase、DM）和非关系型数据库（如 Redis、MongoDB、Elasticsearch、Meilisearch），同时支持动态数据源，以满足不同企业的需求。</span></span></li>\n<li><strong>项目安全性高：</strong><span>&nbsp;支持4A等级认证，满足等保三级要求，支持防 SQL 注入、防 Token 劫持、防接口渗透与抖动，集成RSA、AES及国产 SM 加密算法，支持全链路HTTPS加密传输协议，确保企业级应用的安全性。</span></li>\n<li><span>支持微服务，支持服务的注册、发现、健康检查、熔断和降级。</span></li>\n</ul>\n<h2><span>项目技术栈</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><span>前端：Vue2、Element UI、Node.js等。</span></li>\n<li><span>后端：C#、.NET 9、AspNetCoreRateLimit、<span>SqlSugar、AutoMapper、SignalR、MiniProfiler、CAP、RabbitMQ、Redis、Consul等。</span></span></li>\n</ul>\n<h2><span>安装教程</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109225902010-549085141.png\" /></p>\n<h2><span>软件架构图</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109225914600-2077383226.png\" /></p>\n<h2><span>项目源代码</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230143000-1636008500.png\" /></p>\n<h2><span>项目效果截图</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230153456-1478242349.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230157723-87615533.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230203615-1395111698.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230210957-1745363029.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230216437-1329007995.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230222905-1152283619.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230230693-1691017440.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205853857-1849985119.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205859134-1945950810.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230248378-53584818.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230253718-384227715.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205908099-602806087.png\" /></p>\n<h2><span>项目源码地址</span></h2>\n<p><span>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/pang-mingjun/RuYiAdmin\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/pang-mingjun/RuYiAdmin</span></a></li>\n</ul>\n<h2><span>优秀项目和框架精选</span></h2>\n<p><span>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong><span>）。</span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>GitHub开源地址：</strong><a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n</ul>\n<div id=\"gtx-trans\">&nbsp;</div>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 23:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">49</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Flink源码阅读：Task数据交互",
      "link": "https://www.cnblogs.com/Jackeyzhe/p/19463278",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Jackeyzhe/p/19463278\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 20:11\">\n    <span>Flink源码阅读：Task数据交互</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Flink源码阅读：Task数据交互\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1828322/202601/1828322-20260109201055245-933532869.png\" />\n        经过前面的学习，Flink 的几个核心概念相关的源码实现我们已经了解了。本文我们来梳理 Task 的数据交互相关的源码。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>经过前面的学习，Flink 的几个核心概念相关的源码实现我们已经了解了。本文我们来梳理 Task 的数据交互相关的源码。</p>\n<h3 id=\"数据输出\">数据输出</h3>\n<p>话不多说，我们直接进入正题。首先来看 Task 的数据输出，在进入流程之前，我们先介绍几个基本概念。</p>\n<h4 id=\"基本概念\">基本概念</h4>\n<ul>\n<li>\n<p>RecordWriterOutput：它是 Output 接口的一个具体实现类，底层使用 RecordWriter 来发送数据。</p>\n</li>\n<li>\n<p>RecordWriter：数据写入的执行者，负责将数据写到 ResultPartition。</p>\n</li>\n<li>\n<p>ResultPartition 和 ResultSubpartition：ResultPartition 是 ExecutionGraph 中一个节点的输出结果，下游的每个需要从当前 ResultPartition 消费数据的 Task 都会有一个 ResultSubpartition。</p>\n</li>\n<li>\n<p>ChannelSelector：用来决定一个 Record 要被写到哪个 Subpartition 中。</p>\n</li>\n<li>\n<p>LocalBufferPool：用来管理 Buffer 的缓冲池。在介绍反压的原理时，我们提到过。</p>\n</li>\n</ul>\n<p>对这些基本概念有了一定的了解之后，我们来看数据输出的具体流程。</p>\n<h4 id=\"执行流程\">执行流程</h4>\n<p>我们以 map 为例，看一下数据的输出过程。</p>\n<p><img alt=\"DataOutput\" class=\"lazyload\" /></p>\n<p>在 <code>StreamMap.processElement</code> 方法中，调用完 map 方法之后，就会调用 <code>output.collect</code> 方法将数据输出，这里的 output 就是 RecordWriterOutput。在 RecordWriterOutput 中，会调用 RecordWriter 的 emit 方法。</p>\n<pre><code class=\"language-java\">private &lt;X&gt; void pushToRecordWriter(StreamRecord&lt;X&gt; record) {\n    serializationDelegate.setInstance(record);\n\n    try {\n        recordWriter.emit(serializationDelegate);\n    } catch (IOException e) {\n        throw new UncheckedIOException(e.getMessage(), e);\n    }\n}\n</code></pre>\n<p>这里的 serializationDelegate 是用来对 record 进行序列化的。RecordWriter 有两个实现类，一个是 ChannelSelectorRecordWriter，另一个是 BroadcastRecordWriter。ChannelSelectorRecordWriter 需要先调用 ChannelSelector 选择对应的 subparition，然后进行写入。BroadcastRecordWriter 则是写到所有的 subparition。</p>\n<p>接下来就是调用 <code>BufferWritingResultPartition.emitRecord</code> 来写入数据。</p>\n<pre><code class=\"language-java\">public void emitRecord(ByteBuffer record, int targetSubpartition) throws IOException {\n    totalWrittenBytes += record.remaining();\n\n    BufferBuilder buffer = appendUnicastDataForNewRecord(record, targetSubpartition);\n\n    while (record.hasRemaining()) {\n        // full buffer, partial record\n        finishUnicastBufferBuilder(targetSubpartition);\n        buffer = appendUnicastDataForRecordContinuation(record, targetSubpartition);\n    }\n\n    if (buffer.isFull()) {\n        // full buffer, full record\n        finishUnicastBufferBuilder(targetSubpartition);\n    }\n\n    // partial buffer, full record\n}\n</code></pre>\n<p>这里把 record 写入到 buffer 中，如果 buffer 不够，则会从 LocalBufferPool 中申请新的 buffer，申请到之后就会继续写入。下面是具体的申请过程。</p>\n<pre><code class=\"language-java\">private MemorySegment requestMemorySegment(int targetChannel) {\n    MemorySegment segment = null;\n    synchronized (availableMemorySegments) {\n        checkDestroyed();\n\n        if (!availableMemorySegments.isEmpty()) {\n            segment = availableMemorySegments.poll();\n        } else if (isRequestedSizeReached()) {\n            // Only when the buffer request reaches the upper limit(i.e. current pool size),\n            // requests an overdraft buffer.\n            segment = requestOverdraftMemorySegmentFromGlobal();\n        }\n\n        if (segment == null) {\n            return null;\n        }\n\n        if (targetChannel != UNKNOWN_CHANNEL) {\n            if (++subpartitionBuffersCount[targetChannel] == maxBuffersPerChannel) {\n                unavailableSubpartitionsCount++;\n            }\n        }\n\n        checkAndUpdateAvailability();\n    }\n    return segment;\n}\n</code></pre>\n<p>如果有可用内存，就直接从队列中出队。如果达到了本地 BufferPool 的上限，就从全局的 NetworkBufferPool 中申请，申请不到就会阻塞写入过程，等待申请。最后还会检查并更新可用内存状态。</p>\n<p>有了可用的 buffer 之后，就会调用 addToSubpartition，最终数据存储在 PipelinedSubpartition 的 buffers 队列中。</p>\n<pre><code class=\"language-java\">private void addToSubpartition(\n        BufferBuilder buffer,\n        int targetSubpartition,\n        int partialRecordLength,\n        int minDesirableBufferSize)\n        throws IOException {\n    int desirableBufferSize =\n            subpartitions[targetSubpartition].add(\n                    buffer.createBufferConsumerFromBeginning(), partialRecordLength);\n\n    resizeBuffer(buffer, desirableBufferSize, minDesirableBufferSize);\n}\n</code></pre>\n<h3 id=\"数据输入\">数据输入</h3>\n<p>看完了数据输出的过程之后，我们再来看一下数据输入的过程。首先还是了解几个基本概念。</p>\n<h4 id=\"基本概念-1\">基本概念</h4>\n<ul>\n<li>\n<p>InputGate：InputGate 是对输入的封装，与 JobGraph 中的 JobEdge 一一对应，每个 InputGate 消费上游一个或多个 Resultpartition。</p>\n</li>\n<li>\n<p>InputChannel：InputChannel 是和 ExecutionGraph 中的 ExecutionEdge 一一对应的。每个 InputChannel 接收一个 ResultSubpartition 的输出，InputChannel 主要关注 LocalInputChannel 和 RemoteInputChannel 两种实现。</p>\n</li>\n</ul>\n<h4 id=\"执行流程-1\">执行流程</h4>\n<p>了解了具体概念之后，我们再看数据输入的具体流程。</p>\n<p><img alt=\"RecordInput\" class=\"lazyload\" /></p>\n<p>数据输入的入口是 <code>StreamTask.processInput</code> 方法，这个方法中主要是调用 <code>inputProcessor.processInput</code> 方法，我们以 StreamOneInputProcessor 为例。这个方法就是调用 <code>input.emitNext</code> 方法。</p>\n<pre><code class=\"language-java\">public DataInputStatus emitNext(DataOutput&lt;T&gt; output) throws Exception {\n\n    while (true) {\n        // get the stream element from the deserializer\n        if (currentRecordDeserializer != null) {\n            RecordDeserializer.DeserializationResult result;\n            try {\n                result = currentRecordDeserializer.getNextRecord(deserializationDelegate);\n            } catch (IOException e) {\n                throw new IOException(\n                        String.format(\"Can't get next record for channel %s\", lastChannel), e);\n            }\n            if (result.isBufferConsumed()) {\n                currentRecordDeserializer = null;\n            }\n\n            if (result.isFullRecord()) {\n                final boolean breakBatchEmitting =\n                        processElement(deserializationDelegate.getInstance(), output);\n                if (canEmitBatchOfRecords.check() &amp;&amp; !breakBatchEmitting) {\n                    continue;\n                }\n                return DataInputStatus.MORE_AVAILABLE;\n            }\n        }\n\n        Optional&lt;BufferOrEvent&gt; bufferOrEvent = checkpointedInputGate.pollNext();\n        if (bufferOrEvent.isPresent()) {\n            // return to the mailbox after receiving a checkpoint barrier to avoid processing of\n            // data after the barrier before checkpoint is performed for unaligned checkpoint\n            // mode\n            if (bufferOrEvent.get().isBuffer()) {\n                processBuffer(bufferOrEvent.get());\n            } else {\n                DataInputStatus status = processEvent(bufferOrEvent.get(), output);\n                if (status == DataInputStatus.MORE_AVAILABLE &amp;&amp; canEmitBatchOfRecords.check()) {\n                    continue;\n                }\n                return status;\n            }\n        } else {\n            if (checkpointedInputGate.isFinished()) {\n                checkState(\n                        checkpointedInputGate.getAvailableFuture().isDone(),\n                        \"Finished BarrierHandler should be available\");\n                return DataInputStatus.END_OF_INPUT;\n            }\n            return DataInputStatus.NOTHING_AVAILABLE;\n        }\n    }\n}\n</code></pre>\n<p>这里是调用 <code>checkpointedInputGate.pollNext</code> 来获取输入的数据。它的内部就是调用 InputGate 的 pollNext 方法来获取数据。当获取到完整数据之后，就会调用 processElement 来处理数据。</p>\n<p>我们以 SingleInputGate 为例看 InputGate 的 pollNext 方法。它的内部调用链路可用一直追踪到 readBufferFromInputChannel 方法，这个方法内会调用 <code>inputChannel.getNextBuffer</code>，这里交给 InputChannel 来具体执行数据读取。</p>\n<pre><code class=\"language-java\">public Optional&lt;BufferAndAvailability&gt; getNextBuffer() throws IOException {\n    checkError();\n\n    if (!toBeConsumedBuffers.isEmpty()) {\n        return getBufferAndAvailability(toBeConsumedBuffers.removeFirst());\n    }\n\n    ResultSubpartitionView subpartitionView = this.subpartitionView;\n    if (subpartitionView == null) {\n        // There is a possible race condition between writing a EndOfPartitionEvent (1) and\n        // flushing (3) the Local\n        // channel on the sender side, and reading EndOfPartitionEvent (2) and processing flush\n        // notification (4). When\n        // they happen in that order (1 - 2 - 3 - 4), flush notification can re-enqueue\n        // LocalInputChannel after (or\n        // during) it was released during reading the EndOfPartitionEvent (2).\n        if (isReleased) {\n            return Optional.empty();\n        }\n\n        // this can happen if the request for the partition was triggered asynchronously\n        // by the time trigger\n        // would be good to avoid that, by guaranteeing that the requestPartition() and\n        // getNextBuffer() always come from the same thread\n        // we could do that by letting the timer insert a special \"requesting channel\" into the\n        // input gate's queue\n        subpartitionView = checkAndWaitForSubpartitionView();\n    }\n\n    BufferAndBacklog next = subpartitionView.getNextBuffer();\n    // ignore the empty buffer directly\n    while (next != null &amp;&amp; next.buffer().readableBytes() == 0) {\n        next.buffer().recycleBuffer();\n        next = subpartitionView.getNextBuffer();\n        numBuffersIn.inc();\n    }\n\n    if (next == null) {\n        if (subpartitionView.isReleased()) {\n            throw new CancelTaskException(\n                    \"Consumed partition \" + subpartitionView + \" has been released.\");\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    Buffer buffer = next.buffer();\n\n    if (buffer instanceof FullyFilledBuffer) {\n        List&lt;Buffer&gt; partialBuffers = ((FullyFilledBuffer) buffer).getPartialBuffers();\n        int seq = next.getSequenceNumber();\n        for (Buffer partialBuffer : partialBuffers) {\n            toBeConsumedBuffers.add(\n                    new BufferAndBacklog(\n                            partialBuffer,\n                            next.buffersInBacklog(),\n                            buffer.getDataType(),\n                            seq++));\n        }\n\n        return getBufferAndAvailability(toBeConsumedBuffers.removeFirst());\n    }\n\n    return getBufferAndAvailability(next);\n}\n</code></pre>\n<p>我们先来看 LocalInputChannel，先获取到了 subpartitionView，并调用 getNextBuffer，这里其实就是从 PipelinedSubpartition 的 buffers 队列中读取数据。</p>\n<p>RemoteInputChannel 则需要从 receivedBuffers 中读取数据，这个队列的数据就是消费上游数据后保存的。</p>\n<p>至此，Flink 中 Task 的数据输入和输出过程的源码就梳理完了，更加底层的 Netty 相关代码我们在后面继续梳理。</p>\n<h3 id=\"总结\">总结</h3>\n<p>最后简单总结一下，本文我们梳理了 Task 的数据输出和输入的过程。输出过程主要是利用 RecordWriter 将数据写入到 Buffer 中，输入过程则是利用 InputChannel 从 Buffer 消费的过程。如果你的 Flink 任务数据量特别大，并且没什么复杂的逻辑，可以考虑适当调整 localBufferPool 的大小来调优任务的吞吐。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 20:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Jackeyzhe\">Jackeyzhe</a>&nbsp;\n阅读(<span id=\"post_view_count\">24</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "公众号推荐机制整理：科技号怎么把社交流量做起来",
      "link": "https://www.cnblogs.com/reachteam/p/19463233",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/reachteam/p/19463233\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 19:39\">\n    <span>公众号推荐机制整理：科技号怎么把社交流量做起来</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>01 背景</h1>\n<p><span>最近我们软件团队参加了一个高校关于公众号运营的分享，听完挺有启发，所以把重点整理成一篇笔记，发出来给大家参考。</span></p>\n<p><span>从 2023 年开始，公众号的分发不再只是订阅推送那一套了，现在更像是社交信号 + 算法推荐一起在发力。有数据提到，2025 年某科技/软件小号通过社交推荐拿到的流量占比已经到 45.9%，甚至超过了传统订阅推送。</span></p>\n<p><span>所以这篇文章想解决的就一件事：</span></p>\n<p><span>科技号到底要怎么写，才能更容易被推荐，也更容易被转发。</span></p>\n<p><span>下面按 6 个方向讲清楚：技术逻辑、关键指标、分发流程、账号差异、演进变化、案例和可操作建议。</span></p>\n<h2><span>02 推荐系统大概怎么跑</span></h2>\n<h3><span>2.1 三类信号最重要</span></h3>\n<p><span>2025 年之后，公众号的推荐更强调三类信号一起看：</span></p>\n<p><span>1. 社交关系：朋友看过、转发、在看等</span></p>\n<p><span>2. 兴趣标签：你是什么人群，内容是什么主题</span></p>\n<p><span>3. 行为数据：点击、停留、完读、滑动速度、点赞发生在什么时候</span></p>\n<p><span>系统会先从内容里提取关键词，再结合用户行为更新画像，最后决定给谁更多曝光。可以把它理解成一个循环：先曝光一小波，看反馈，再决定要不要继续给量。</span></p>\n<p><span>另外有一点很关键，文章发出去之后通常 1 到 3 分钟内就会做一轮质量评估，主题价值、逻辑结构、原创性、以及 AI 生成痕迹这些都会被综合判断。</span></p>\n<h3><span>2.2 指标权重长什么样</span></h3>\n<p><span>先把大盘放在这。数字是研究整理口径，大家看趋势和重点就行。</span></p>\n<p><span>表 1：公众号算法核心权重分配</span></p>\n<table>\n<thead>\n<tr><th><span>权重维度</span></th><th><span>具体指标</span></th><th><span>权重占比</span></th><th><span>关键阈值（示例）</span></th></tr>\n</thead>\n<tbody>\n<tr>\n<td><span>社交传播系数</span></td>\n<td><span>好友推荐率、转发到朋友圈/社群次数、跨圈层传播深度</span></td>\n<td><span>35%</span></td>\n<td><span>社交推荐流量占比 ≥ 45%</span></td>\n</tr>\n<tr>\n<td><span>内容质量因子</span></td>\n<td><span>完读率（≥65%）、平均阅读时长（≥2 分钟）、原创度（3 倍权重）</span></td>\n<td><span>30%</span></td>\n<td><span>完读率 ≥ 50%</span></td>\n</tr>\n<tr>\n<td><span>用户行为画像</span></td>\n<td><span>点击率、滑动速度、点赞时间点等微观行为</span></td>\n<td><span>20%</span></td>\n<td><span>点击率 ≥ 15%</span></td>\n</tr>\n<tr>\n<td><span>账号信誉体系</span></td>\n<td><span>更新频率、违规记录、用户投诉率</span></td>\n<td><span>10%</span></td>\n<td><span>日更可提升 300% 初始推荐</span></td>\n</tr>\n<tr>\n<td><span>实时流量博弈</span></td>\n<td><span>15 分钟动态调整</span></td>\n<td><span>5%</span></td>\n<td><span>冷启动期点击率 &gt; 8%</span></td>\n</tr>\n</tbody>\n</table>\n<p><span>另外还有一组常见拆分口径：打开率大概占 40%，互动率（赞/在看/收藏）占 30%，分享率占 20%，完读率占 10%。</span></p>\n<p><span>提醒两点：</span></p>\n<p><span>1. 原创的推荐权重会更高（研究口径里提到是转载的 3 倍）</span></p>\n<p><span>2. 认证类型也会影响权重（政府 &gt; 媒体 &gt; 企业 &gt; 个体），认证账号在搜索里更容易拿到靠前曝光</span></p>\n<h3><span>2.3 这几年分发怎么变了</span></h3>\n<p><span>简单按阶段捋一下：</span></p>\n<p><span>1. 2013 到 2017：订阅为主，关注就能收到</span></p>\n<p><span>2. 2017 到 2020：开始引入社交推荐，看一看等入口出现</span></p>\n<p><span>3. 2020 到 2023：算法推荐逐步变强，开始推荐未关注内容</span></p>\n<p><span>4. 2023 至今：社交 + 算法双驱动更明显，朋友相关入口的权重变高</span></p>\n<h2><span>03 流量池赛马：文章为啥会突然爆</span></h2>\n<h3><span>3.1 冷启动那一关很关键</span></h3>\n<p><span>文章发出去之后，通常会先拿到一小波测试曝光（比如 500 到 1000 次），系统主要看三项：点击率、完读率、互动率。</span></p>\n<p><span>研究里给了一些常见阈值做参考：</span></p>\n<p><span>1. 冷启动期（0 到 24 小时）点击率要能到 8% 以上，更可能进下一层</span></p>\n<p><span>2. 进入爆发期后，完读率最好能维持 55% 以上，互动率 3% 以上</span></p>\n<h3><span>3.2 多轮推荐不是一次性给完</span></h3>\n<p><span>通过第一轮测试后，会有二次、三次甚至更多轮的推荐，每一轮曝光量会变大。</span></p>\n<p><span>另外系统会按 15 分钟一轮动态调整流量，所以同一篇文章的数据会一直变化。阅读量到 1 万这个量级后，有时还会触发人工审核。</span></p>\n<h3><span>3.3 社交扩散会带来放大</span></h3>\n<p><span>当用户点在看或者转发，文章就会沿着社交网络扩散。有账号的数据里，朋友相关入口贡献的阅读量能到 45.9%。</span></p>\n<p><span>比较容易触发分享的原因一般是这三类：</span></p>\n<p><span>1. 内容本身有社交价值（共鸣、实用、话题性）</span></p>\n<p><span>2. 文中写清楚分享动机（比如转给同事、转给同学、转给群里谁）</span></p>\n<p><span>3. 内容适配分享场景（工作群、同学群、行业群能用得上）</span></p>\n<h3><span>3.4 公域入口也很重要</span></h3>\n<p><span>表 2：公众号主要流量来源分布</span></p>\n<table>\n<thead>\n<tr><th><span>流量来源</span></th><th><span>占比</span></th><th><span>特点</span></th></tr>\n</thead>\n<tbody>\n<tr>\n<td><span>推荐流量</span></td>\n<td><span>54.5%</span></td>\n<td><span>算法推荐为主</span></td>\n</tr>\n<tr>\n<td><span>公众号消息</span></td>\n<td><span>16.52%</span></td>\n<td><span>订阅用户</span></td>\n</tr>\n<tr>\n<td><span>公众号主页</span></td>\n<td><span>13.17%</span></td>\n<td><span>主动访问</span></td>\n</tr>\n<tr>\n<td><span>搜一搜</span></td>\n<td><span>10.44%</span></td>\n<td><span>精准搜索</span></td>\n</tr>\n<tr>\n<td><span>聊天会话</span></td>\n<td><span>2.88%</span></td>\n<td><span>私域分享</span></td>\n</tr>\n<tr>\n<td><span>朋友圈</span></td>\n<td><span>0.96%</span></td>\n<td><span>朋友圈分享</span></td>\n</tr>\n<tr>\n<td><span>朋友推荐</span></td>\n<td><span>0.12%</span></td>\n<td><span>好友直接推荐</span></td>\n</tr>\n</tbody>\n</table>\n<p><span>补充两点：</span></p>\n<p><span>1. 看一看是很重要的公域入口，爆款里看一看占比能到 60% 到 70%</span></p>\n<p><span>2. 搜一搜占比大概 10.44%，标题关键词做得好，搜索流量占比也可能很可观</span></p>\n<h2><span>04 不同账号的差异</span></h2>\n<h3><span>4.1 认证和账号信誉</span></h3>\n<p><span>认证类型会影响权重和信任（政府 &gt; 媒体 &gt; 企业 &gt; 个体）。</span></p>\n<p><span>同时也会看这些：注册时间、违规记录、粉丝活跃度（常读用户）、更新频率（发文多且原创占比高更占优）。</span></p>\n<h3><span>4.2 新号和老号不一样</span></h3>\n<p><span>新号一般会有观察期，初期曝光可能比较小，平台会先判断你是不是稳定的正常创作者，标签清不清晰，内容合不合规。</span></p>\n<p><span>老号因为画像积累更完整，推荐更容易精准，但长期不活跃或者质量下滑也可能被降权。</span></p>\n<h3><span>4.3 垂直领域更吃香，但别乱跑</span></h3>\n<p><span>科技、教育等垂直领域在品类里可能更容易拿到倾斜，但前提是定位足够细，内容持续垂直输出，并且用合集、标签等方式强化识别。</span></p>\n<h2><span>05 科技号怎么做更容易起量</span></h2>\n<p><span>我更建议把指标当成门槛，而不是当 KPI。</span></p>\n<h3><span>5.1 标题先把点击率顶起来</span></h3>\n<p><span>标题可以用一个比较稳的结构：痛点场景 + 数据背书 + 情绪共鸣。</span></p>\n<p><span>示例（按你们账号方向替换即可）：</span></p>\n<p><span>1. 我把电脑变快了，3 个 Windows 设置立刻见效</span></p>\n<p><span>2. 别再被钓鱼了，校园/企业邮箱最常见的 5 种诈骗</span></p>\n<p><span>3. 从 0 到 1，用 10 分钟搭好一个自动化报表流程</span></p>\n<h3><span>5.2 内容结构要照顾完读</span></h3>\n<p><span>一个比较好用的写法是：开头直接给结论，中间保持信息密度（大概每 300 字一个关键点），结尾给行动建议或提问，引导评论/收藏/转发。</span></p>\n<h3><span>5.3 原创是底盘</span></h3>\n<p><span>研究里提到原创度建议大于 70%。如果用 AI 做辅助，也建议把比例和用途说清楚，避免被系统误判成低质。</span></p>\n<h3><span>5.4 把可转发写进正文</span></h3>\n<p><span>文章 25% / 50% / 75% 的位置，可以顺手加一句话，告诉读者这段适合转给谁。</span></p>\n<p><span>比如：这份排查清单转给 IT 同事/同学；这段设置转到群里，大家少踩坑。</span></p>\n<h3><span>5.5 发出去后的 2 小时别浪费</span></h3>\n<p><span>冷启动数据很关键，建议发文后马上用种子用户扩散一波（社群、同事群、同学群），先把点击、完读、互动跑起来。</span></p>\n<h3><span>5.6 每周就盯 3 个指标</span></h3>\n<p><span>1. 社交推荐流量占比（目标值可参考 45%）</span></p>\n<p><span>2. 菜单栏点击量（能看出互动深度）</span></p>\n<p><span>3. 48 小时互动率（能看出内容即时影响力）</span></p>\n<p><span>另外标题、封面、开头段落都可以做小范围 A/B 测试，找最合适的组合。</span></p>\n<h2><span>06 案例给我们的提示</span></h2>\n<p><span>这里列几个研究里的典型现象，主要看规律：</span></p>\n<p><span>1. 有文章阅读 48 万，看一看贡献 60%</span></p>\n<p><span>2. 有新号粉丝不多，单篇 10 万+，看一看贡献 98%</span></p>\n<p><span>3. 有病毒传播案例，第 1 天 500+，第 2 天 1 万+，第 3 天朋友圈刷屏</span></p>\n<p><span>共同点其实很朴素：冷启动过关，社交扩散被点燃，内容质量能撑住完读和互动。</span></p>\n<h2><span>07 风险和合规别踩坑</span></h2>\n<p><span>常见误区：</span></p>\n<p><span>1. 追热点但和定位不搭，容易白忙</span></p>\n<p><span>2. 依赖刷量，平台有无效流量排查，风险很高</span></p>\n<p><span>3. 只要曝光不要质量，完读率掉得很快，推荐也会很快停</span></p>\n<p><span>合规方面：</span></p>\n<p><span>1. 原创度尽量做到 70% 以上</span></p>\n<p><span>2. 标题和正文做敏感词扫描，少用绝对化、夸大化表述</span></p>\n<p><span>3. 图片素材注意版权，用 CC0 站点或者合规二创</span></p>\n<h2><span>08 总结</span></h2>\n<p><span>一句话总结：公众号现在是社交信号 + 算法推荐一起在跑，科技号想起量，核心还是三件事：冷启动数据过关、内容更容易被转发、长期坚持原创和垂直。</span></p>\n<p><span>如果你只想先做最小改动，建议从这 3 个开始：</span></p>\n<p><span>1. 发文后 0 到 2 小时，把点击率、完读率、互动率先跑起来</span></p>\n<p><span>2. 把清单、步骤、排错流程写得更可截图转发，顺手写清楚转给谁</span></p>\n<p><span>3. 连续做一个细分方向（比如校园网络安全、系统使用指南、办公效率），让标签稳定下来</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 19:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/reachteam\">H5开发技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">66</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "EF Core自定义映射PostgreSQL原生函数",
      "link": "https://www.cnblogs.com/netry/p/19452236/efcore_jsonb_extract_path_text_in_postgredb",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/netry/p/19452236/efcore_jsonb_extract_path_text_in_postgredb\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 15:09\">\n    <span>EF Core自定义映射PostgreSQL原生函数</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"背景\">背景</h1>\n<p>在 ASP.NET Core 应用开发中，使用 PostgreSQL的<code>jsonb</code>类型存储多语言数据是一种常见的方案。这种方式相比传统的多列存储或独立翻译表，在模式定义上更加灵活。</p>\n<p>例如，对于一个包含多语言简介的“艺术家”实体，我们通常如下定义：</p>\n<pre class=\"language-cs\"><code class=\"language-cs\">public class ArtistEntity \n{\n    public int Id { get; set; }\n\n    // 使用 jsonb 存储多语言字典：Key=语言代码(en, zh-CN), Value=内容\n    [Column(TypeName = \"jsonb\")] \n    public Dictionary&lt;string, string&gt; Biography { get; set; } = [];\n}</code></pre><h1 id=\"性能考量\">性能考量</h1>\n<p>虽然存储方便，但在读取时会面临流量和性能问题。在大多数业务场景中，前端仅需要展示当前用户语言（如英语）的内容。如果直接查询实体，EF Core会将包含所有语言的JSONB对象完整加载到内存中。对于包含几十种语言的长文本字段，这不仅浪费数据库 I/O，也增加了网络传输开销。</p>\n<p>尝试使用EF Core的字典索引器语法：</p>\n<pre class=\"language-cs\"><code class=\"language-cs\">// 期望生成的 SQL 是直接取值\nvar bio = context.Artists.Select(x =&gt; x.Biography[\"en\"]).FirstOrDefault();</code></pre><p>根据 <a href=\"https://www.npgsql.org/efcore/mapping/json.html?tabs=data-annotations%2Ccomplex-types%2Cjsondocument\" rel=\"noopener nofollow\" target=\"_blank\" title=\"Npgsql EF Core Provider\">Npgsql EF Core Provider</a> 文档，虽然 Provider 提供了如<code>EF.Functions.JsonContains</code>、<code>EF.Functions.JsonExists</code>等丰富的 JSONB 操作函数，但在处理 Dictionary 索引器的投影翻译时仍存在局限性。在某些复杂的 Select 投影中，它可能无法生成最优的<code> -&gt;&gt;</code> 操作符，或者导致查询在客户端求值。</p>\n<p>目前Npgsql的<code>EF.Functions</code>中并没有直接对应<code>jsonb_extract_path_text</code>的方法，而这个原生函数恰恰是解决此类需求最直接的方式。它能在数据库服务端完成解析，仅返回指定路径的文本值。</p>\n<h1 id=\"什么是-jsonb_extract_path_text\">什么是 jsonb_extract_path_text？</h1>\n<p><code>jsonb_extract_path_text</code>是PostgreSQL的原生函数（等同于操作符 <code>#&gt;&gt;</code>），专门用于从 JSON 数据中根据路径提取文本。</p>\n<p>相比于直接返回 JSON 对象，它能直接返回纯文本（text 类型），非常适合提取多语言字典中的单一语言值。<br />\n假设数据库里的 <code>Biography</code> 字段存储如下 JSON：</p>\n<pre><code>{\n  \"en\": \"Hello World\",\n  \"zh-CN\": \"你好世界\",\n  \"fr\": \"Bonjour le monde\"\n}\n</code></pre>\n<p>如果我们只想获取中文简介：</p>\n<pre><code>-- 使用函数提取 'zh-CN' 键的值\nSELECT jsonb_extract_path_text(\"Biography\", 'zh-CN') \nFROM \"Artists\";\n\n-- 结果仅返回字符串： \"你好世界\"\n</code></pre>\n<p>这种处理方式完全在数据库端完成，传输到应用层的只有这4个字符，而不是包含英文和法文的完整JSON 对象。</p>\n<h1 id=\"解决方案映射自定义函数\">解决方案：映射自定义函数</h1>\n<p>为了在EF Core中使用<code>jsonb_extract_path_text</code>，我们可以通过自定义函数映射来实现。</p>\n<h3 id=\"什么是-ef-core自定义函数\">什么是 EF Core自定义函数？</h3>\n<p>EF Core 的自定义函数映射（User-defined function mapping）允许开发者 C#方法直接映射到数据库中的 SQL 函数。在 LINQ 查询中使用这些被映射的 C# 方法时，EF Core不会在客户端执行它们，而是将它们“翻译”成对应的 SQL 片段发送给数据库执行。这就像是给了你一把钥匙，让你能够从 C# 代码中直接调用数据库特有的、强大的原生能力（如 PostgreSQL 的 JSON 处理、GIS 地理信息计算等），而无需编写原生的 SQL 字符串。</p>\n<h3 id=\"1-定义函数存根\">1. 定义函数存根</h3>\n<p>在 C# 中定义一个静态方法作为存根（Stub），用于告诉 EF Core 即使翻译 SQL。</p>\n<pre class=\"language-cs\"><code class=\"language-cs\">public static class DbFunctionsExtensions\n{\n    // 此方法仅用于 EF Core 查询映射，客户端调用时抛出异常\n    public static string JsonExtractPathText(this Dictionary&lt;string, string&gt; json, string key)\n    {\n        throw new NotSupportedException(\"此方法仅用于 EF Core 查询映射，不可在客户端执行。\");\n    }\n}</code></pre><h3 id=\"2-配置模型映射\">2. 配置模型映射</h3>\n<p>在 <code>OnModelCreating</code> 中通过 Fluent API 进行映射关系配置,  <code>HasDbFunction</code> 将其映射到数据库函数 <code>jsonb_extract_path_text</code>。</p>\n<pre class=\"language-cs\"><code class=\"language-cs\">protected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    modelBuilder.HasDbFunction(typeof(DbFunctionsExtensions)\n            .GetMethod(nameof(DbFunctionsExtensions.JsonExtractPathText),\n                [typeof(Dictionary&lt;string, string&gt;), typeof(string)])!)\n        .HasName(\"jsonb_extract_path_text\")\n        .IsBuiltIn();\n}</code></pre><p>或者，也可以使用 <code>[DbFunction] </code>特性直接配置映射关系，这样代码更加紧凑。</p>\n<pre class=\"language-cs\"><code class=\"language-cs\">using Microsoft.EntityFrameworkCore;\n\npublic static class DbFunctionsExtensions\n{\n    // 映射到 PostgreSQL 的内置函数 jsonb_extract_path_text\n    [DbFunction(\"jsonb_extract_path_text\", IsBuiltIn = true)]\n    public static string JsonExtractPathText(this Dictionary&lt;string, string&gt; json, string key)\n    {\n       throw new NotSupportedException(\"此方法仅用于 EF Core 查询映射，不可在客户端执行。\");\n    }\n}</code></pre><h3 id=\"3-使用示例\">3. 使用示例</h3>\n<p>配置完成后，可以在 LINQ 查询中直接调用该扩展方法：</p>\n<pre class=\"language-cs\"><code class=\"language-cs\">var query = db.Artists\n    .Select(entity =&gt; new \n    {\n        Id = entity.Id,\n        // 数据库仅返回当前语言的文本\n        Bio = entity.Biography.JsonExtractPathText(CultureInfo.CurrentUICulture.Name)\n    });</code></pre><p>生成的 SQL 将调用原生<code>jsonb_extract_path_text</code>函数，避免了全量传输 JSON 数据。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1181943/202601/1181943-20260107143638710-1533499015.png\" /></p>\n<h2 id=\"索引优化策略\">索引优化策略</h2>\n<p>针对 JSONB 字段的查询优化，需要根据具体需求选择合适的索引类型。</p>\n<ol>\n<li>GIN 索引：适用于“包含”类查询（如 Biography 是否包含 en 键）。</li>\n</ol>\n<pre><code>builder.Entity&lt;ArtistEntity&gt;()\n    .HasIndex(x =&gt; x.Biography)\n    .HasMethod(\"gin\");\n</code></pre>\n<ol start=\"2\">\n<li>函数索引 (B-Tree)：如果业务中存在大量基于特定语言（如英文名称）的精确查找或排序需求，GIN 索引效率较低。此时应针对热点语言创建函数索引：</li>\n</ol>\n<pre><code>-- 针对英语内容建立 B-Tree 索引\nCREATE INDEX idx_artist_bio_en ON \"Artists\" (( \"Biography\" -&gt;&gt; 'en' ));\n</code></pre>\n<h2 id=\"适用场景与局限性\">适用场景与局限性</h2>\n<p>虽然通过 <code>jsonb_extract_path_text</code> 可以减少网络传输，但这并不是所有场景下的万能解。</p>\n<ul>\n<li>\n<p>高并发读取：即便减少了传输量，解析 JSONB 在数据库层面依然有 CPU 开销。如果面临极高并发的读取请求（如首页热门列表），频繁让数据库解析 JSON 并不是最优解。在这种情况下，应当引入应用层缓存（如 Redis）或使用专门的搜索引擎（如 Elasticsearch）。</p>\n</li>\n<li>\n<p>数据结构复杂度：此方法最适合扁平的 Key-Value 结构。如果 JSON 结构非常复杂且嵌套深，维护路径映射会变得困难。</p>\n</li>\n<li>\n<p>数据库负载：将数据处理逻辑下推到数据库虽然方便，但会增加数据库 CPU 负载。在数据库资源已是瓶颈的系统中，需谨慎使用。</p>\n</li>\n</ul>\n<p>通过这种方式，我们在保持开发便利性的同时，通过利用数据库原生能力，解决了一个具体的性能问题。开发者应根据实际的数据量级和访问模式，决定是采用此直连方案还是引入更复杂的缓存架构。</p>\n<h1 id=\"参考链接\">参考链接</h1>\n<ul>\n<li><a href=\"https://learn.microsoft.com/en-us/ef/core/querying/user-defined-function-mapping\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/ef/core/querying/user-defined-function-mapping</a></li>\n<li><a href=\"https://github.com/npgsql/efcore.pg/issues/2703\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/npgsql/efcore.pg/issues/2703</a></li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    \n\n  \n  <div id=\"MySignature1\" style=\"color: 0; font-size: small;\">\n            <p>\n          作者： \n          <a href=\"https://www.cnblogs.com/netry/\"></a><a href=\"https://www.cnblogs.com/netry/\" target=\"_blank\">马行空的博客</a>\n      </p>\n      <p>\n          出处：\n          <a href=\"https://www.cnblogs.com/netry/p/19452236/efcore_jsonb_extract_path_text_in_postgredb\" target=\"_blank\">https://www.cnblogs.com/netry/p/19452236/efcore_jsonb_extract_path_text_in_postgredb</a>\n      </p>\n       \n \n      <p>\n          本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。\n      </p>\n  </div>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 15:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/netry\">马行空的博客</a>&nbsp;\n阅读(<span id=\"post_view_count\">187</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "51单片机_按键检测",
      "link": "https://www.cnblogs.com/WIRO/p/19461450",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/WIRO/p/19461450\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 14:49\">\n    <span>51单片机_按键检测</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"51单片机_按键检测\">51单片机_按键检测</h1>\n<h2 id=\"一独立按键介绍\">一、独立按键介绍</h2>\n<p>轻触按键相当于是一种电子开关</p>\n<p>按下时开关接通，松开时开关断开，实现原理是通过轻触按键内部的金属弹片受力弹动来实现接通和断开</p>\n<p><img alt=\"image-20260109110408710\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754276-1163410502.png\" /></p>\n<p><img alt=\"image-20260109110503289\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754526-1860924412.png\" /></p>\n<p>由于机械点的弹性作用，按键开关在闭合时不会马上稳定的接通，在断开时也不会一下子断开。因而在闭合和断开的瞬间均伴随着一连串的抖动。抖动时间的长短由按键的机械特性决定，一般为5ms到10ms。</p>\n<p>按键稳定闭合时间的长短由操作人员的按键动作决定，一般为零点几秒至数秒。按键抖动会引起按键被误读多次。为了确保CPU对按键的依次闭合仅作一次处理，必须及时进行消抖。</p>\n<p>按键消抖有两种方式，一种是硬件消抖，另一种是软件消抖。为了使电路更加简单，通常采用软件消抖。</p>\n<p>软件消抖一般来说一个简单的按键消抖就是先读取按键的状态，如果得到按键按下之后，延时10ms，再次读取按键状态，如果按键还是按下状态，那么说明按键已经按下。其中的延时10ms就是软件消抖处理。</p>\n<p>常用的软件去抖动方法：</p>\n<ol>\n<li>先设置IO口为高电平，由于开发板IO有上拉电阻，默认IO为高电平；</li>\n<li>读取IO口电平确认是否有按键按下；</li>\n<li>如果有IO电平为低电平后，延时几个毫秒；</li>\n<li>再读取该IO电平，如果仍为低电平，说明按键按下；</li>\n<li>执行相应按键的程序；</li>\n</ol>\n<h2 id=\"二独立按键检测原理\">二、独立按键检测原理</h2>\n<p>独立按键电路构成是由各个按键的一个管脚连接在一起接地，按键其它引脚分别接到单片机IO口。</p>\n<p>单片机的IO口既可作为输出也可作为输入使用，当检测按键时用的是它的输入功能，独立按键的一端接地，另一端与单片机的某个IO口相连，开始时先给IO口赋一高电平，然后让单片机不断检测该IO口是否变为低电平，当按键闭合时，相当于该IO口通过按键与地相连，变成低电平，程序一旦检测到IO口变为低电平则说明按键被按下，然后执行相应的指令。</p>\n<p><img alt=\"image-20260109110908433\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754146-1606670533.png\" /></p>\n<h2 id=\"三独立按键应用实践\">三、独立按键应用实践</h2>\n<h3 id=\"1实现按键控制led功能\">1）实现按键控制LED功能</h3>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\n\n/**\n * 主函数\n */\nvoid main()\n{\n\twhile(1)\n\t{\n\t\tif(P3_1 == 0)  \t\t\t  // 如果K1按键按下，则为低电平\n\t\t{\n\t\t\tDelay(20);\t\t\t  // 延时消抖\n\t\t\twhile(P3_1 == 0);\t  // 松手检测\n\t\t\tDelay(20);\t\t\t  // 延时消抖\n\t\t\n\t\t\tP2_0 = ~P2_0;\t\t  // LED1 取反\n\t\t}\n\t}\n}\n</code></pre>\n<p>这段代码依旧存在不灵敏的情况，下面是改进：</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\n\nvoid main()\n{\n    while(1)\n    {\n        if(P3_1 == 0)              // 检测按键是否按下\n        {\n            Delay(10);             // 延时消抖\n            if(P3_1 == 0)          // 再次确认按键确实按下\n            {\n                P2_0 = ~P2_0;      // 执行LED取反\n                \n                // 等待按键释放，避免连按\n                while(P3_1 == 0);  // 等待按键松开\n            }\n        }\n    }\n}\n</code></pre>\n<h3 id=\"2按键控制led灯二进制显示\">2）按键控制LED灯二进制显示</h3>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\n\nvoid main()\n{\n\tunsigned char LEDNum=0;\n\twhile(1)\n\t{\n\t\tif(P3_1==0)\t\t\t\t\t//如果K1按键按下\n\t\t{\n\t\t\tDelay(10);\t\t\t\t//延时消抖\n\t\t\tif(P3_1==0)\n\t\t\t{\n\t\t\t  LEDNum++;\t\t\t\t//变量自增\n\t\t\t  P2=~LEDNum;\t\t\t//变量取反输出给LED\n\t\t\t\twhile(P3_1==0);\t    //松手检测\n\t\t\t}\n\t\t}\n\t}\n}\n\n//  实现原理：\n//  +000  LEDNum 0000 0000  \t取反 —&gt;  1111 1111\n//  +001  LEDNum 0000 0001  \t取反 —&gt;  1111 1110\n//  +002  LEDNum 0000 0010  \t取反 —&gt;  1111 1101\n//  +003  LEDNum 0000 0011  \t取反 —&gt;  1111 1100\n//  ···\n//  +255  LEDNum 1111 1111  \t取反 —&gt;  0000 0000\n//  +256  溢出 -&gt; LEDNum 0000 0000  重新开始计数\n</code></pre>\n<h3 id=\"3按键实现led左右移动\">3）按键实现LED左右移动</h3>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\n\nunsigned char LEDNum;\n\nvoid main()\n{\n\tP2=~0x01;\t\t\t\t\t//上电默认LED1点亮 0000 0001 取反 -&gt; 1111 1110\n\twhile(1)\n\t{\n\t\tif(P3_0==0)\t\t\t    //如果K1按键按下，右移\n\t\t{ \n\t\t\tDelay(20);\n\t\t\twhile(P3_0==0);\n\t\t\tDelay(20);\n\t\t\t\n\t\t\tLEDNum++;\t\t\t //LEDNum自增\n\t\t\tif(LEDNum&gt;=8)\t\t //限制LEDNum自增范围\n\t\t\t\tLEDNum=0;\n\t\t\tP2=~(0x01&lt;&lt;LEDNum);\t //LED的第LEDNum位点亮\n\t\t}\n\t\tif(P3_1==0)\t\t\t\t //如果K2按键按下，左移\n\t\t{\n\t\t\tDelay(20);\n\t\t\twhile(P3_1==0);\n\t\t\tDelay(20);\n\t\t\t\n\t\t\tif(LEDNum==0)\t\t //LEDNum减到0后变为7\n\t\t\t\tLEDNum=7;\n\t\t\telse\t\t\t\t //LEDNum未减到0，自减\n\t\t\t\tLEDNum--;\n\t\t\tP2=~(0x01&lt;&lt;LEDNum);  //LED的第LEDNum位点亮\n\t\t}\n\t}\n}\n</code></pre>\n<p><code>P2=~(0x01&lt;&lt;LEDNum);</code>  实现原理如下：</p>\n<table>\n<thead>\n<tr>\n<th>LEDNum</th>\n<th>0x01 &lt;&lt; LEDNum (二进制)</th>\n<th>取反后 (二进制)</th>\n<th>效果说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td><code>0000 0001</code></td>\n<td><code>1111 1110</code></td>\n<td>LED0亮，其他灭</td>\n</tr>\n<tr>\n<td>1</td>\n<td><code>0000 0010</code></td>\n<td><code>1111 1101</code></td>\n<td>LED1亮，其他灭</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>0000 0100</code></td>\n<td><code>1111 1011</code></td>\n<td>LED2亮，其他灭</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>0000 1000</code></td>\n<td><code>1111 0111</code></td>\n<td>LED3亮，其他灭</td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>0001 0000</code></td>\n<td><code>1110 1111</code></td>\n<td>LED4亮，其他灭</td>\n</tr>\n<tr>\n<td>5</td>\n<td><code>0010 0000</code></td>\n<td><code>1101 1111</code></td>\n<td>LED5亮，其他灭</td>\n</tr>\n<tr>\n<td>6</td>\n<td><code>0100 0000</code></td>\n<td><code>1011 1111</code></td>\n<td>LED6亮，其他灭</td>\n</tr>\n<tr>\n<td>7</td>\n<td><code>1000 0000</code></td>\n<td><code>0111 1111</code></td>\n<td>LED7亮，其他灭</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"四矩阵按键\">四、矩阵按键</h2>\n<p>独立键盘与单片机连接时，每一个按键都需要单片机的一个I/O口。若某单片机系统需要较多按键，如果用独立按键便会占用过多的I/O口资源。</p>\n<p>当用到多个按键时，为了减少I/O口引脚，引入了矩阵按键。比如4*4矩阵键盘。</p>\n<p>对于4*4矩阵键盘，开发板上通常将16个按键排成4行4列。第一行将每个按键的一端连接在一起构成行线，第一列将每个按键的另一端连接在一起构成列线，这样便一共有4行4列共8根线。将这8根线连接到单片机的8个I/O口上，通过程序扫描键盘可以检测16个键。</p>\n<p>无论是独立键盘还是矩阵键盘，单片机检测其是否被按下的依据都是一样的，即检测与该键对应的I/O口是否为低电平。独立键盘有一端固定为低电平而矩阵键盘两端都与单片机I/O口相连，在检测时需编程通过单片机I/O口送出低电平。检测方法最常用的是行列扫描和线翻转法。</p>\n<ul>\n<li>行列扫描法检测时，先送一列为低电平，其余几列全为高电平，此时确定列数；然后立即轮流检测一次各行是否有低电平，若检测到某一行为低电平，此时确定了行数，便可以确认当前被按下的键是哪一行哪一列的。用同样方法轮流送各列一次低电平，再轮流检测一次各行是否变为低电平，这样即可检测完所有的按键，当有按键被按下时便可判断出按下的键是哪一个键。</li>\n<li>线翻转法检测时，就是使所有行线为低电平时，检测所有列线是否有低电平，如果有，就记录列线值；然后再翻转，使所有列线都为低电平，检测所有行线的值。由于有按键按下，行线的值也会有变化，记录行线的值，从而就可以检测到全部按键。</li>\n</ul>\n<p><strong>矩阵按键也需要按键消抖。</strong></p>\n<p><img alt=\"image-20260109120836392\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754496-78745305.png\" /></p>\n<p><img alt=\"image-20260109121508035\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754398-1331883375.png\" /></p>\n<p><img alt=\"image-20260109123822715\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754445-1533630463.png\" /></p>\n<p>以第一列代码作为示例，简单介绍下 <strong>逐列扫描</strong> 的检测原理：</p>\n<p><img alt=\"image-20260109124004422\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754216-452685151.png\" /></p>\n<ul>\n<li><code>P1=0xFF;</code> 把所有按键端口置为高电平，也就是关闭所有按键</li>\n<li><code>P1_3=0;</code>  将第一列按键置为低电平，其他按键依旧为高电平（关闭状态）</li>\n<li>使用  <code>If判断</code>  检测行按键，如果某一行为低电平，就返回 <code>KeyNumber</code> 编号</li>\n</ul>\n<p>其他3列按键的检测原理同上</p>\n<h2 id=\"五矩阵按键应用实践\">五、矩阵按键应用实践</h2>\n<h3 id=\"1实现lcd1602显示按键编号\">1）实现LCD1602显示按键编号</h3>\n<p>main.c</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\t\t  //包含Delay头文件\n#include \"LCD1602.h\"\t  //包含LCD1602头文件\n#include \"MatrixKey.h\"\t  //包含矩阵键盘头文件\n\nunsigned char KeyNum;\n\nvoid main()\n{\n\tLCD_Init();\t\t\t\t\t\t\t          //LCD初始化\n\tLCD_ShowString(1,1,\"MatrixKey:\");\t          //LCD显示字符串\n\twhile(1)\n\t{\n\t\tKeyNum=MatrixKey();\t\t\t\t          //获取矩阵键盘键码\n\t\tif(KeyNum)\t\t\t\t\t\t          //如果有按键按下\n\t\t{\n\t\t\tLCD_ShowNum(2,1,KeyNum,2);\t          //LCD显示键码\n\t\t}\n\t}\n}\n</code></pre>\n<p>Delay.c</p>\n<pre><code class=\"language-c\">\nvoid Delay(unsigned int xms)\n{\n\tunsigned char i, j;\n\twhile(xms--)\n\t{\n\t\ti = 2;\n\t\tj = 239;\n\t\tdo\n\t\t{\n\t\t\twhile (--j);\n\t\t} while (--i);\n\t}\n}\n</code></pre>\n<p>Delay.h</p>\n<pre><code class=\"language-c\">#ifndef __DELAY_H__\n#define __DELAY_H__\n\nvoid Delay(unsigned int xms);\n\n#endif\n\n</code></pre>\n<p>LCD1602.c</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n\n//引脚配置：\nsbit LCD_RS=P2^6;\nsbit LCD_RW=P2^5;\nsbit LCD_EN=P2^7;\n#define LCD_DataPort P0\n\n//函数定义：\n/**\n  * @brief  LCD1602延时函数，12MHz调用可延时1ms\n  * @param  无\n  * @retval 无\n  */\nvoid LCD_Delay()\n{\n\tunsigned char i, j;\n\n\ti = 2;\n\tj = 239;\n\tdo\n\t{\n\t\twhile (--j);\n\t} while (--i);\n}\n\n/**\n  * @brief  LCD1602写命令\n  * @param  Command 要写入的命令\n  * @retval 无\n  */\nvoid LCD_WriteCommand(unsigned char Command)\n{\n\tLCD_RS=0;\n\tLCD_RW=0;\n\tLCD_DataPort=Command;\n\tLCD_EN=1;\n\tLCD_Delay();\n\tLCD_EN=0;\n\tLCD_Delay();\n}\n\n/**\n  * @brief  LCD1602写数据\n  * @param  Data 要写入的数据\n  * @retval 无\n  */\nvoid LCD_WriteData(unsigned char Data)\n{\n\tLCD_RS=1;\n\tLCD_RW=0;\n\tLCD_DataPort=Data;\n\tLCD_EN=1;\n\tLCD_Delay();\n\tLCD_EN=0;\n\tLCD_Delay();\n}\n\n/**\n  * @brief  LCD1602设置光标位置\n  * @param  Line 行位置，范围：1~2\n  * @param  Column 列位置，范围：1~16\n  * @retval 无\n  */\nvoid LCD_SetCursor(unsigned char Line,unsigned char Column)\n{\n\tif(Line==1)\n\t{\n\t\tLCD_WriteCommand(0x80|(Column-1));\n\t}\n\telse if(Line==2)\n\t{\n\t\tLCD_WriteCommand(0x80|(Column-1+0x40));\n\t}\n}\n\n/**\n  * @brief  LCD1602初始化函数\n  * @param  无\n  * @retval 无\n  */\nvoid LCD_Init()\n{\n\tLCD_WriteCommand(0x38);//八位数据接口，两行显示，5*7点阵\n\tLCD_WriteCommand(0x0c);//显示开，光标关，闪烁关\n\tLCD_WriteCommand(0x06);//数据读写操作后，光标自动加一，画面不动\n\tLCD_WriteCommand(0x01);//光标复位，清屏\n}\n\n/**\n  * @brief  在LCD1602指定位置上显示一个字符\n  * @param  Line 行位置，范围：1~2\n  * @param  Column 列位置，范围：1~16\n  * @param  Char 要显示的字符\n  * @retval 无\n  */\nvoid LCD_ShowChar(unsigned char Line,unsigned char Column,char Char)\n{\n\tLCD_SetCursor(Line,Column);\n\tLCD_WriteData(Char);\n}\n\n/**\n  * @brief  在LCD1602指定位置开始显示所给字符串\n  * @param  Line 起始行位置，范围：1~2\n  * @param  Column 起始列位置，范围：1~16\n  * @param  String 要显示的字符串\n  * @retval 无\n  */\nvoid LCD_ShowString(unsigned char Line,unsigned char Column,char *String)\n{\n\tunsigned char i;\n\tLCD_SetCursor(Line,Column);\n\tfor(i=0;String[i]!='\\0';i++)\n\t{\n\t\tLCD_WriteData(String[i]);\n\t}\n}\n\n/**\n  * @brief  返回值=X的Y次方\n  */\nint LCD_Pow(int X,int Y)\n{\n\tunsigned char i;\n\tint Result=1;\n\tfor(i=0;i&lt;Y;i++)\n\t{\n\t\tResult*=X;\n\t}\n\treturn Result;\n}\n\n/**\n  * @brief  在LCD1602指定位置开始显示所给数字\n  * @param  Line 起始行位置，范围：1~2\n  * @param  Column 起始列位置，范围：1~16\n  * @param  Number 要显示的数字，范围：0~65535\n  * @param  Length 要显示数字的长度，范围：1~5\n  * @retval 无\n  */\nvoid LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)\n{\n\tunsigned char i;\n\tLCD_SetCursor(Line,Column);\n\tfor(i=Length;i&gt;0;i--)\n\t{\n\t\tLCD_WriteData(Number/LCD_Pow(10,i-1)%10+'0');\n\t}\n}\n\n/**\n  * @brief  在LCD1602指定位置开始以有符号十进制显示所给数字\n  * @param  Line 起始行位置，范围：1~2\n  * @param  Column 起始列位置，范围：1~16\n  * @param  Number 要显示的数字，范围：-32768~32767\n  * @param  Length 要显示数字的长度，范围：1~5\n  * @retval 无\n  */\nvoid LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length)\n{\n\tunsigned char i;\n\tunsigned int Number1;\n\tLCD_SetCursor(Line,Column);\n\tif(Number&gt;=0)\n\t{\n\t\tLCD_WriteData('+');\n\t\tNumber1=Number;\n\t}\n\telse\n\t{\n\t\tLCD_WriteData('-');\n\t\tNumber1=-Number;\n\t}\n\tfor(i=Length;i&gt;0;i--)\n\t{\n\t\tLCD_WriteData(Number1/LCD_Pow(10,i-1)%10+'0');\n\t}\n}\n\n/**\n  * @brief  在LCD1602指定位置开始以十六进制显示所给数字\n  * @param  Line 起始行位置，范围：1~2\n  * @param  Column 起始列位置，范围：1~16\n  * @param  Number 要显示的数字，范围：0~0xFFFF\n  * @param  Length 要显示数字的长度，范围：1~4\n  * @retval 无\n  */\nvoid LCD_ShowHexNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)\n{\n\tunsigned char i,SingleNumber;\n\tLCD_SetCursor(Line,Column);\n\tfor(i=Length;i&gt;0;i--)\n\t{\n\t\tSingleNumber=Number/LCD_Pow(16,i-1)%16;\n\t\tif(SingleNumber&lt;10)\n\t\t{\n\t\t\tLCD_WriteData(SingleNumber+'0');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLCD_WriteData(SingleNumber-10+'A');\n\t\t}\n\t}\n}\n\n/**\n  * @brief  在LCD1602指定位置开始以二进制显示所给数字\n  * @param  Line 起始行位置，范围：1~2\n  * @param  Column 起始列位置，范围：1~16\n  * @param  Number 要显示的数字，范围：0~1111 1111 1111 1111\n  * @param  Length 要显示数字的长度，范围：1~16\n  * @retval 无\n  */\nvoid LCD_ShowBinNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)\n{\n\tunsigned char i;\n\tLCD_SetCursor(Line,Column);\n\tfor(i=Length;i&gt;0;i--)\n\t{\n\t\tLCD_WriteData(Number/LCD_Pow(2,i-1)%2+'0');\n\t}\n}\n</code></pre>\n<p>LCD1602.h</p>\n<pre><code class=\"language-c\">#ifndef __LCD1602_H__\n#define __LCD1602_H__\n\n//用户调用函数：\nvoid LCD_Init();\nvoid LCD_ShowChar(unsigned char Line,unsigned char Column,char Char);\nvoid LCD_ShowString(unsigned char Line,unsigned char Column,char *String);\nvoid LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);\nvoid LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length);\nvoid LCD_ShowHexNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);\nvoid LCD_ShowBinNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);\n\n#endif\n\n</code></pre>\n<p>MatrixKey.c</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\n\n/**\n  * @brief  矩阵键盘读取按键键码\n  * @param  无\n  * @retval KeyNumber 按下按键的键码值\n\t\t\t如果按键按下不放，程序会停留在此函数，松手的一瞬间，返回按键键码，没有按键按下时，返回0\n  */\nunsigned char MatrixKey()\n{\n\tunsigned char KeyNumber=0;\n\t\n\tP1=0xFF;  // 1111 1111 全部置高电平，没有按键按下\n\tP1_3=0;   // 检测第一列\n\tif(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=1;}\n\tif(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=5;}\n\tif(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=9;}\n\tif(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=13;}\n\t\n\tP1=0xFF;  // 1111 1111 全部置高电平，没有按键按下\n\tP1_2=0;   // 检测第二列\n\tif(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=2;}\n\tif(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=6;}\n\tif(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=10;}\n\tif(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=14;}\n\t\n\tP1=0xFF;  // 1111 1111 全部置高电平，没有按键按下\n\tP1_1=0;   // 检测第三列\n\tif(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=3;}\n\tif(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=7;}\n\tif(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=11;}\n\tif(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=15;}\n\t\n\tP1=0xFF;  // 1111 1111 全部置高电平，没有按键按下\n\tP1_0=0;   // 检测第四列\n\tif(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=4;}\n\tif(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=8;}\n\tif(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=12;}\n\tif(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=16;}\n\t\n\treturn KeyNumber;\n}\n</code></pre>\n<p>MatrixKey.h</p>\n<pre><code class=\"language-c\">#ifndef __MATRIXKEY_H__\n#define __MATRIXKEY_H__\n\nunsigned char MatrixKey();\n\n#endif\n\n</code></pre>\n<h3 id=\"2使用矩阵键盘实现密码锁功能\">2）使用矩阵键盘实现密码锁功能</h3>\n<p>只需要修改main.c ,其余代码同上</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\n#include \"LCD1602.h\"\n#include \"MatrixKey.h\"\n\nunsigned char KeyNum;\nunsigned int Password,Count;\n\nvoid main()\n{\n\tLCD_Init();\n\tLCD_ShowString(1,1,\"Password:\");\n\twhile(1)\n\t{\n\t\tKeyNum=MatrixKey();\n\t\tif(KeyNum)\n\t\t{\n\t\t\tif(KeyNum&lt;=10)\t                      //如果S1~S10按键按下，输入密码\n\t\t\t{                                    \n\t\t\t\tif(Count&lt;4)\t                       //如果输入次数小于4\n\t\t\t\t{                                  \n\t\t\t\t\tPassword*=10;\t\t\t\t   //密码左移一位\n\t\t\t\t\tPassword+=KeyNum%10;\t\t   //获取一位密码\n\t\t\t\t\tCount++;\t                   //计次加一\n\t\t\t\t}\n\t\t\t\tLCD_ShowNum(2,1,Password,4);\t   //更新显示\n\t\t\t}                                    \n\t\t\tif(KeyNum==11)\t                       //如果S11按键按下，确认\n\t\t\t{                                    \n\t\t\t\tif(Password==2345)\t               //如果密码等于正确密码\n\t\t\t\t{                                  \n\t\t\t\t\tLCD_ShowString(1,14,\"OK \");\t   //显示OK\n\t\t\t\t\tPassword=0;\t\t               //密码清零\n\t\t\t\t\tCount=0;\t\t               //计次清零\n\t\t\t\t\tLCD_ShowNum(2,1,Password,4);   //更新显示\n\t\t\t\t}\n\t\t\t\telse\t\t\t\t               //否则\n\t\t\t\t{\n\t\t\t\t\tLCD_ShowString(1,14,\"ERR\");\t   //显示ERR\n\t\t\t\t\tPassword=0;\t\t               //密码清零\n\t\t\t\t\tCount=0;\t\t               //计次清零\n\t\t\t\t\tLCD_ShowNum(2,1,Password,4);   //更新显示\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(KeyNum==12)\t                       //如果S12按键按下，取消\n\t\t\t{\n\t\t\t\tPassword=0;\t\t                   //密码清零\n\t\t\t\tCount=0;\t\t                   //计次清零\n\t\t\t\tLCD_ShowNum(2,1,Password,4);\t   //更新显示\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre>\n<p><code>Password*=10;\t\t\t\t   //密码左移一位</code></p>\n<p><code>Password+=KeyNum%10;\t\t   //获取一位密码 </code></p>\n<p><strong>图表：按键序列 5 → 6 → 3 → 8 的处理过程</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">按键</th>\n<th style=\"text-align: left;\">运算前 Password</th>\n<th style=\"text-align: left;\">Password × 10</th>\n<th style=\"text-align: left;\">KeyNum % 10</th>\n<th style=\"text-align: left;\">运算后 Password</th>\n<th style=\"text-align: left;\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">5</td>\n<td style=\"text-align: left;\">0</td>\n<td style=\"text-align: left;\">0 × 10 = 0</td>\n<td style=\"text-align: left;\">5 % 10 = 5</td>\n<td style=\"text-align: left;\"><strong>5</strong></td>\n<td style=\"text-align: left;\">第一个数字直接存入</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">6</td>\n<td style=\"text-align: left;\">5</td>\n<td style=\"text-align: left;\">5 × 10 = 50</td>\n<td style=\"text-align: left;\">6 % 10 = 6</td>\n<td style=\"text-align: left;\"><strong>56</strong></td>\n<td style=\"text-align: left;\">5移到十位，6放在个位</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">3</td>\n<td style=\"text-align: left;\">56</td>\n<td style=\"text-align: left;\">56 × 10 = 560</td>\n<td style=\"text-align: left;\">3 % 10 = 3</td>\n<td style=\"text-align: left;\"><strong>563</strong></td>\n<td style=\"text-align: left;\">56变为560，3放在个位</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">8</td>\n<td style=\"text-align: left;\">563</td>\n<td style=\"text-align: left;\">563 × 10 = 5630</td>\n<td style=\"text-align: left;\">8 % 10 = 8</td>\n<td style=\"text-align: left;\"><strong>5638</strong></td>\n<td style=\"text-align: left;\">563变为5630，8放在个位</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 14:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/WIRO\">Q&amp;25</a>&nbsp;\n阅读(<span id=\"post_view_count\">113</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}