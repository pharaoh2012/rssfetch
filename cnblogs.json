{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "软件测试",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19527882",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19527882\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 23:49\">\n    <span>软件测试</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"软件测试定义\">软件测试定义</h4>\n<ul>\n<li>软件测试就是验证软件产品特性是否满⾜用户的需求。</li>\n</ul>\n<h4 id=\"软件测试开发程师和测试程师的区别\">软件测试开发⼯程师和测试⼯程师的区别</h4>\n<ul>\n<li>相同点：\n<ol>\n<li>都统称为测试⼈员</li>\n<li>对产品质量负责，保障产品的质量</li>\n</ol>\n</li>\n<li>不同点：测试开发⽐测试多开发⼆字，⽽这个开发并不是指业务开发，因为业务开发是开发⼈员的主要职责，这⾥的开发指的是需要开发测试效率⼯具，通过效率⼯具来提升测试效率和测试质量，⽐如我们的⾃动化、性能测试等就属于效率⼯具。</li>\n</ul>\n<h4 id=\"软件的命周期\">软件的⽣命周期</h4>\n<ul>\n<li>软件生命周期包括：需求分析、计划、设计、编码、测试、运行维护。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>具体内容</th>\n<th>产出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>需求分析</td>\n<td>分析用户需求是否合理，分别从市场需求、技术等⽅⾯进⾏分析。</td>\n<td>该阶段会输出需求等⽂档。</td>\n</tr>\n<tr>\n<td>计划</td>\n<td>对成⽴的需求执⾏需求执⾏计划，多⻓时间内完成该需求，每段时间具体完成哪些功能。</td>\n<td>该阶段会输出计划等⽂档。</td>\n</tr>\n<tr>\n<td>设计</td>\n<td>将需求细化成⼀个个任务，团队成员各司其职领取任务并进⾏技术设计（如何进⾏架构设计，设计哪些接⼝、采⽤什么技术）</td>\n<td>该阶段会输出技术等⽂档。</td>\n</tr>\n<tr>\n<td>编码</td>\n<td>开发⼈员参考需求⽂档、设计⽂档、交互图等等⽂件进⾏代码的编写。</td>\n<td>代码⽂件等⽂档。</td>\n</tr>\n<tr>\n<td>测试</td>\n<td>测试⼈员需要介⼊到软件的测试中来，参考测试⽤例对软件进⾏测试。</td>\n<td>测试⽤例、测试设计与计划、测试报告等⽂档</td>\n</tr>\n<tr>\n<td>运⾏维护</td>\n<td>项⽬测试结束之后，项⽬需要进⾏上线，并对产品进⾏线上的维护。线上的维护主要分为三个⽅⾯。分别为修复性维护、完善性维护和预防性维护。修复性维护：对项⽬中未发现的问题进⾏修复。完善性维护：对功能进⾏完善。预防性维护：居安思危，为了避免产品在线上出现⼀些其他不可预料的问题，进⾏⼀些防护的⼿段。</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"常见的开发模型\">常见的开发模型</h4>\n<ol>\n<li>瀑布模型:</li>\n</ol>\n<ul>\n<li>start--&gt;需求分析--&gt;计划--&gt;设计--&gt;编码--&gt;测试--&gt;end</li>\n<li>瀑布模型在软件⼯程中占有重要地位，是所有其他模型的基础框架。瀑布模型的每⼀个阶段都只执行⼀次，因此是线性顺序进⾏的软件开发模式。</li>\n<li>瀑布模型优缺点总结：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强调开发的阶段性；线性结构，每个阶段只执⾏⼀次;是其他模型的基础框架</td>\n<td>1.测试后置:前⾯各阶段遗留的⻛险推迟到测试阶段才被发现，导致项⽬⼤⾯积返⼯，失去了及早修复的机会；必须留有⾜够的时间给测试活动，否则导致测试不充分，将缺陷直接暴露给用户（产品质量差）2. 周期太⻓，产品很迟才能被看到和使⽤，可能会导致需求/功能过时</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>瀑布模型的适⽤场景：需求固定的⼩项⽬</li>\n</ul>\n<ol start=\"2\">\n<li>螺旋模型</li>\n</ol>\n<ul>\n<li>⼀般在软件开发初期阶段需求不是很明确时，采⽤渐进式的开发模式。螺旋模型是渐进式开发模型的代表之⼀。</li>\n<li>这对于那些规模庞⼤、复杂度⾼、⻛险⼤的项⽬尤其适合。这种迭代开发的模式给软件测试带来了新的要求，它不允许有⼀段独⽴的测试时间和阶段，测试必须跟随开发的迭代⽽迭代。因此，回归测试的重要性就不⾔⽽喻了。<br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强调严格的全过程⻛险管理。 强调各开发阶段的质量。增加⻛险分析和原型</td>\n<td>项⽬中可能存在的⻛险性与⻛险管理⼈员的技能⽔平有直接关系；需求⼈员、资⾦、时间的增加和投⼊，可能会导致项⽬的成本太⾼</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>适⽤场景：规模庞⼤、复杂度⾼、⻛险⼤的项⽬。</li>\n</ul>\n<ol start=\"3\">\n<li>增量模型、迭代模型</li>\n</ol>\n<ul>\n<li>增量开发能显著降低项⽬⻛险，结合软件持续构建机制，构成了当今流⾏的软件⼯程最佳实践之⼀。增量开发模型，⿎励⽤⼾反馈，在每个迭代过程中，促使开发⼩组以⼀种循环的、可预测的⽅式驱动产品的开发。因此，在这种开发模式下，每⼀次的迭代都意味着可能有需求的更改、构建出新的可执⾏软件版本，意味着测试需要频繁进⾏，测试⼈员需要与开发⼈员更加紧密地协作。</li>\n<li>与此类似的有⼀个迭代开发，增量开发和迭代开发往往容易被⼈，但是其实两者是有区别的。增量是逐块建造的概念，迭代是反复求精的概念。</li>\n<li>适⽤场景：⼤型项⽬，需求不明确</li>\n</ul>\n<ol start=\"4\">\n<li>敏捷模型</li>\n</ol>\n<ul>\n<li>敏捷模型主要旨在帮助项⽬快速适应变更请求。因此，敏捷模型的主要⽬的是促进项⽬的快速完成。要完成这项任务，需要敏捷。敏捷性是通过使过程适应项⽬，删除对特定项⽬可能不是必需的活动来实现的。此外，避免任何浪费时间和精⼒的事情。</li>\n<li>在敏捷模型中，需求被分解成许多可以增量开发的⼩部分。敏捷模型采⽤迭代开发。每个增量部分都是在迭代中开发的。每次迭代都旨在⼩⽽易于管理，并且只能在⼏周内完成。⼀次为客户计划、开发和部署⼀个迭代。没有制定⻓期计划。</li>\n<li>敏捷开发有很多种⽅式，其中scrum是⽐较流⾏的⼀种。在scrum模型中，主要有三个⻆⾊和五个重要会议。</li>\n<li>三个⻆⾊：scrum由product owner(产品经理)、scrum master(项⽬经理)和team(研发团队)组成。\n<ul>\n<li>其中product owner负责整理user story(⽤⼾故事)，定义其商业价值，对其进⾏排序，制定发布计划，对产品负责。</li>\n<li>scrum master负责召开各种会议，协调项⽬，为研发团队服务。</li>\n<li>研发团队则由不同技能的成员组成，通过紧密协同，完成每⼀次迭代的⽬标，交付产品。</li>\n</ul>\n</li>\n<li>五个会议：\n<ul>\n<li>迭代计划会议</li>\n<li>每日站会</li>\n<li>迭代评审会议</li>\n<li>迭代回顾会议</li>\n<li>需求细化会议</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"测试模型\">测试模型</h4>\n<ul>\n<li>测试模型中有两个⾮常重要且具有标志性的测试模型：V模型和W模型<br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n<li>优点：</li>\n</ul>\n<ol>\n<li>明确的标注了测试过程中存在的不同类型的测试，并且清楚的描述了这些测试阶段和开发过程期间各阶段的对应关系，有效提升测试的质量和效率。</li>\n<li>V模型指出：</li>\n</ol>\n<ul>\n<li>单元和集成测试应检测程序的执⾏是否满⾜软件设计的要求；</li>\n<li>系统测试应检测系统功能、性能的质量特性是否达到系统要求的指标；</li>\n<li>验收测试确定软件的实现是否满⾜⽤⼾需要或合同的要求<br />\n缺点：仅仅把测试作为在编码之后的⼀个阶段，未在需求阶段就介⼊测试。缺点同瀑布模型。</li>\n</ul>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<ul>\n<li>W模型增加了软件各开发阶段中应同步进⾏的验证和确认活动。W模型由两个V字型模型组成，分别代表测试与开发过程，图中明确表⽰出了测试与开发的并⾏关系。</li>\n<li>特点：测试的对象不仅是程序，需求、设计等同样要测试，测试与开发是同步进⾏的\u0001\u0001</li>\n<li>优点：\n<ul>\n<li>有利于尽早地全⾯的发现问题。例如，需求分析完成后，测试⼈员就应该参与到对需求的验证和确认活动中，以尽早地找出缺陷所在。同时，对需求的测试也有利于及时了解项⽬难度和测试⻛险，及早制定应对措施，显著减少总体测试时间，加快项⽬进度。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>需求、设计、编码等活动被视为串⾏的；</li>\n<li>测试和开发活动也保持着⼀种线性的前后关系，上⼀阶段完全结束，才可正式开始下⼀个阶段⼯作。</li>\n<li>重流程，⽆法⽀持敏捷开发模式。对于当前软件开发复杂多变的情况，W模型并不能解除测试管理⾯临着困惑。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"软件测试的命周期\">软件测试的⽣命周期</h4>\n<ul>\n<li>软件测试的⽣命周期是指测试流程，这个流程是按照⼀定顺序执⾏的⼀系列特定的步骤，去保证产品质量符合需求。在软件测试⽣命周期流程中，每个活动都按照计划的系统的执⾏。每个阶段有不同的⽬标和交付产物</li>\n<li>具体包括：需求分析、测试计划、测试设计以及测试开发、测试执行、测试评估、上线、运行维护。</li>\n<li>总之软件测试贯穿于软件的整个生命周期。</li>\n</ul>\n<h4 id=\"bug\">BUG</h4>\n<ul>\n<li>bug的定义：⼀个计算机bug指在计算机程序中存在的⼀个错误(error)、缺陷(flaw)、疏忽(mistake)或者故障(fault)，这些bug使程序⽆法正确的运⾏。Bug产⽣于程序的源代码或者程序设计阶段的疏忽或者错误。</li>\n<li>描述bug的要素：问题出现的版本、问题出现的环境、问题出现的步骤、预期结果、实际结果。</li>\n<li>bug级别：⼀般分为崩溃、严重、⼀般、次要。</li>\n<li>bug的⽣命周期：\n<ul>\n<li>测试⼈员在执⾏测试的过程中如有发现bug，需要在对应的bug管理平台来创建bug（bug⽣命起源），创建好的bug需要被开发⼈员修复，以及测试⼈员的持续跟踪和测试。<br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n</ul>\n</li>\n<li>New:新发现的bug,未经评审决定是否指派给开发人员进行修改</li>\n<li>Open:确认是bug,并且认为需要修改，指派给相应的开发人员</li>\n<li>Fixed:开发人员进行修改后标识为修改状态，待测试人员进行验证</li>\n<li>Rejected:如果认为不是bug,则拒绝修改</li>\n<li>Delay:如果认为暂时不需要修改或者暂时不能修改，则延后修改</li>\n<li>Closed:修改状态的bug经过测试人员的回归测试验证并通过，则关闭bug</li>\n<li>Reopen:如果经过验证bug依然存在，则需要重新打开bug,开发人员重新修改</li>\n<li>⽆效的bug：open-&gt;closed open-rejected-closed</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 23:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一天一个Python库：charset-normalizer - 自动化字符编码检测与规范化",
      "link": "https://www.cnblogs.com/min2k/p/19527462",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/min2k/p/19527462\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 20:28\">\n    <span>一天一个Python库：charset-normalizer - 自动化字符编码检测与规范化</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"charset-normalizer---自动化字符编码检测与规范化\">charset-normalizer - 自动化字符编码检测与规范化</h1>\n<h2 id=\"一什么是charset-normalizer\">一、什么是charset-normalizer？</h2>\n<p><strong>charset-normalizer</strong> 是一个用于可靠检测各种文本文件或数据块的字符编码的 Python 库。<br />\n它可以帮助你：</p>\n<ul>\n<li>自动识别未知编码的文本。</li>\n<li>规范化文本，使其在不同系统间或应用程序中保持一致，避免乱码问题。</li>\n<li>处理因编码错误导致的数据解析问题。</li>\n</ul>\n<h2 id=\"二应用场景\">二、应用场景</h2>\n<p><strong>charset-normalizer</strong> 广泛应用于以下实际场景：</p>\n<ul>\n<li><strong>数据清洗</strong>: 在处理从不同来源（如网页抓取、文件导入）获取的数据时，自动检测并统一字符编码，解决乱码问题。</li>\n<li><strong>文本处理工具</strong>: 开发文本编辑器、日志分析器或其他需要处理多种编码文本的工具时，提供强大的编码识别能力。</li>\n<li><strong>国际化应用</strong>: 确保应用程序能够正确处理和显示来自全球各地的用户输入和内容，避免因编码不兼容而出现乱码。</li>\n</ul>\n<h2 id=\"三如何安装\">三、如何安装</h2>\n<ol>\n<li>使用 pip 安装</li>\n</ol>\n<pre><code class=\"language-bash\">pip install charset-normalizer\n\n# 如果安装慢的话，推荐使用国内镜像源\npip install charset-normalizer -i https://www.python64.cn/pypi/simple/\n</code></pre>\n<ol start=\"2\">\n<li>使用 <a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行代码（无需本地安装）</li>\n</ol>\n<h2 id=\"四示例代码\">四、示例代码</h2>\n<p>检测一个未知编码的字符串的编码，并进行解码。</p>\n<pre><code class=\"language-python\">from charset_normalizer import from_bytes\n\n# 尝试检测这个可能是乱码的字节串\nunknown_bytes = b'\\xc3\\xa9l\\xc3\\xa9phant'  # 这是一个UTF-8编码的'éléphant'\n\n# 使用 from_bytes 进行编码检测和规范化\ndetection_result = from_bytes(unknown_bytes)\n\n# 获取最佳匹配的字符编码\nif detection_result:\n    best_encoding = detection_result.best().encoding\n    decoded_string = str(detection_result) # 转换为字符串，默认使用最佳编码\n    print(f\"检测到的最佳编码是: {best_encoding}\")\n    print(f\"解码后的字符串是: {decoded_string}\")\nelse:\n    print(\"未能检测到合适的编码。\")\n\n# 另外一个例子：一个简单的ASCII字符串\nascii_bytes = b'hello world'\nascii_detection = from_bytes(ascii_bytes)\n\nif ascii_detection:\n    print(f\"\\n'hello world' 的最佳编码是: {ascii_detection.best().encoding}\")\n    print(f\"'hello world' 解码后: {str(ascii_detection)}\")\nelse:\n    print(\"\\n未能检测到 'hello world' 的编码。\")\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/python-run/?code=from%20charset_normalizer%20import%20from_bytes%0A%0A%23%20%E5%B0%9D%E8%AF%95%E6%A3%80%E6%B5%8B%E8%BF%99%E4%B8%AA%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B9%B1%E7%A0%81%E7%9A%84%E5%AD%97%E8%8A%82%E4%B8%B2%0Aunknown_bytes%20%3D%20b'%5Cxc3%5Cxa9l%5Cxc3%5Cxa9phant'%20%20%23%20%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AAUTF-8%E7%BC%96%E7%A0%81%E7%9A%84'%C3%A9l%C3%A9phant'%0A%0A%23%20%E4%BD%BF%E7%94%A8%20from_bytes%20%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%84%E8%8C%83%E5%8C%96%0Adetection_result%20%3D%20from_bytes%28unknown_bytes%29%0A%0A%23%20%E8%8E%B7%E5%8F%96%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%0Aif%20detection_result%3A%0A%20%20%20%20best_encoding%20%3D%20detection_result.best%28%29.encoding%0A%20%20%20%20decoded_string%20%3D%20str%28detection_result%29%20%23%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%0A%20%20%20%20print%28f%22%E6%A3%80%E6%B5%8B%E5%88%B0%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E6%98%AF%3A%20%7Bbest_encoding%7D%22%29%0A%20%20%20%20print%28f%22%E8%A7%A3%E7%A0%81%E5%90%8E%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%3A%20%7Bdecoded_string%7D%22%29%0Aelse%3A%0A%20%20%20%20print%28%22%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84%E7%BC%96%E7%A0%81%E3%80%82%22%29%0A%0A%23%20%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ASCII%E5%AD%97%E7%AC%A6%E4%B8%B2%0Aascii_bytes%20%3D%20b'hello%20world'%0Aascii_detection%20%3D%20from_bytes%28ascii_bytes%29%0A%0Aif%20ascii_detection%3A%0A%20%20%20%20print%28f%22%5Cn'hello%20world'%20%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E6%98%AF%3A%20%7Bascii_detection.best%28%29.encoding%7D%22%29%0A%20%20%20%20print%28f%22'hello%20world'%20%E8%A7%A3%E7%A0%81%E5%90%8E%3A%20%7Bstr%28ascii_detection%29%7D%22%29%0Aelse%3A%0A%20%20%20%20print%28%22%5Cn%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%20'hello%20world'%20%E7%9A%84%E7%BC%96%E7%A0%81%E3%80%82%22%29\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行这段代码，结果如下：</p>\n<pre><code class=\"language-text\">检测到的最佳编码是: utf_8\n解码后的字符串是: &lt;charset_normalizer.models.CharsetMatches object at 0x7fea543bdb40&gt;\n\n'hello world' 的最佳编码是: ascii\n'hello world' 解码后: &lt;charset_normalizer.models.CharsetMatches object at 0x7fea543bda80&gt;\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/mermaid/?code=flowchart%20TB%0A%20%20A%5B%E5%BC%80%E5%A7%8B%5D%20--%3E%20B%7B%E5%AE%9A%E4%B9%89%E5%AD%97%E8%8A%82%E4%B8%B2%20unknown_bytes%7D%3B%0A%20%20B%20--%3E%20C%5B%E8%B0%83%E7%94%A8%20from_bytes%28unknown_bytes%29%5D%3B%0A%20%20C%20--%3E%20D%7B%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C%20detection_result%20%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%3F%7D%3B%0A%20%20D%20--%20%E6%98%AF%20--%3E%20E%5B%E8%8E%B7%E5%8F%96%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%20best_encoding%5D%3B%0A%20%20E%20--%3E%20F%5B%E8%A7%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%20decoded_string%5D%3B%0A%20%20F%20--%3E%20G%5B%E6%89%93%E5%8D%B0%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%5D%3B%0A%20%20D%20--%20%E5%90%A6%20--%3E%20H%5B%E6%89%93%E5%8D%B0%22%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E7%BC%96%E7%A0%81%22%E6%B6%88%E6%81%AF%5D%3B%0A%20%20G%20--%3E%20I%7B%E5%AE%9A%E4%B9%89%E5%AD%97%E8%8A%82%E4%B8%B2%20ascii_bytes%7D%3B%0A%20%20H%20--%3E%20I%3B%0A%20%20I%20--%3E%20J%5B%E8%B0%83%E7%94%A8%20from_bytes%28ascii_bytes%29%5D%3B%0A%20%20J%20--%3E%20K%7B%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C%20ascii_detection%20%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%3F%7D%3B%0A%20%20K%20--%20%E6%98%AF%20--%3E%20L%5B%E6%89%93%E5%8D%B0%20ascii_bytes%20%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E5%90%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%5D%3B%0A%20%20K%20--%20%E5%90%A6%20--%3E%20M%5B%E6%89%93%E5%8D%B0%22%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%20'hello%20world'%20%E7%9A%84%E7%BC%96%E7%A0%81%22%E6%B6%88%E6%81%AF%5D%3B%0A%20%20L%20--%3E%20N%5B%E7%BB%93%E6%9D%9F%5D%3B%0A%20%20M%20--%3E%20N%3B%0A\" rel=\"noopener nofollow\" target=\"_blank\">MermaidGo</a> 绘制示例代码的流程图，结果如下：</p>\n<p><img alt=\"MermerGo的charset-normalize的流程图\" class=\"lazyload\" /></p>\n<h2 id=\"五学习资源\">五、学习资源</h2>\n<ol>\n<li>开源项目：<a href=\"https://github.com/Ousret/charset_normalizer\" rel=\"noopener nofollow\" target=\"_blank\">charset-normalizer</a></li>\n<li>中文自述：<a href=\"https://www.python64.cn/readme/charset-normalizer/\" rel=\"noopener nofollow\" target=\"_blank\">REMDME</a></li>\n<li>在线运行：<a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a></li>\n</ol>\n<blockquote>\n<p>如果这篇文章对你有帮助，欢迎点赞、收藏、转发！<br />\n学习过程中有任何问题，欢迎在评论区留言交流～</p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 20:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/min2k\">敏编程</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Python 学习笔记：具体项目实践",
      "link": "https://www.cnblogs.com/owlman/p/19526745",
      "published": "",
      "description": "<h2 class=\"post-title\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/owlman/p/19526745\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 15:57\">\n    <span>Python 学习笔记：具体项目实践</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>[!NOTE] 笔记说明</p>\n<p>在阅读完了《[[基础语法学习|Python 学习笔记：基础语法学习]]》之后，相信读者已经初步体验到了 Python 社区所推崇的“优雅、明确、简单”的编码风格。在接下来的这篇笔记中，我们将会基于这些原则，逐步从脚本式代码过渡到结构清晰、依赖可控、可分发的 Python 项目。本篇将聚焦于：</p>\n<ul>\n<li>介绍如何遵循 PEP 规范（例如 PEP 8）来构建 Python 项目；</li>\n<li>介绍如何基于虚拟环境来安装并管理项目依赖（基于 uv 和 pip）；</li>\n<li>介绍将项目打包为可执行文件或可分发的扩展包（基于 uv）；</li>\n</ul>\n</blockquote>\n<h2 id=\"pep-规范与项目结构设计\">PEP 规范与项目结构设计</h2>\n<p>在我开始学习 Python 的那个年代，这门编程语言在大多数使用场景下仍然被当作一种用于编写单一脚本文件的工具，而非用于构建完整项目的开发语言。换言之，那时候所谓的 Python 程序往往都只是若干独立脚本的集合，并不构成严格意义上的“项目”，自然也谈不上系统化的项目结构设计。这并非偶然。Guido van Rossum 在最初设计 Python 时，其核心目标之一，正是用一种语法简洁、可读性良好的高级语言，来替代 Unix Shell 以完成常见的系统管理与自动化任务。在这样的设计初衷下，Python 更强调“快速完成一件事”，而非长期维护的大规模工程组织。</p>\n<p>然而，随着 Python 在近十余年间在科学计算、Web 开发、数据分析以及工程自动化等应用领域的蓬勃发展，人们对它的使用方式发生了根本性的变化。越来越多的开发者开始使用 Python 来构建功能复杂、生命周期较长的系统，这也使得代码的组织方式、模块边界以及项目结构设计逐渐成为一个无法回避的问题。因此，在讨论具体项目的实践之前，我们需要先解决一个经常被初学者忽视、但在真实工程中极其关键的问题：<strong>代码应该如何被组织，以及应当遵循怎样的规范来书写</strong>。</p>\n<p>在如今的 Python 社区中，人们针对工程化的项目结构设计已经形成了一整套的可遵循的规范文档，这些文档被统称为 <strong>Python Enhancement Proposals，简称 PEP</strong>。当然，PEP 中的大部分内容是用于规范语言设计或解释器实现的，而我们在这里要讨论的是面向项目工程化实践的那一小部分，其目的是在项目结构设计方面建立起统一的约定，以便显著降低项目被理解的成本。这可以使开发者之间无需反复适应不同的代码组织习惯，从而把注意力集中在<strong>业务逻辑本身</strong>。下面，就让我们以当前主流的 PEP 8 为例，来具体介绍一下 Python 项目结构设计的基本原则。</p>\n<h3 id=\"从脚本到项目结构上的转变\">从脚本到项目：结构上的转变</h3>\n<p>许多初学者在学习 Python 时，习惯于将所有代码写在单个 <code>.py</code> 文件中。这在学习阶段完全没有问题，但一旦进入真实而具体的项目，就会迅速暴露出可维护性上的瓶颈。而如果我们想要将自己的代码项目化，首先要做的就是安排好项目的目录结构。一个最基础、也是最常见的 Python 项目可以通过我们之前在《[[编程环境配置|Python 学习笔记：编程环境配置]]》一节中提到的 <code>uv</code> 项目管理工具来生成，其具体步骤如下：</p>\n<ol>\n<li>\n<p>在当前计算机的任意位置创建一个名为 <code>python_demo</code> 的目录，并使用命令行终端程序打开该目录。</p>\n</li>\n<li>\n<p>在命令行终端中执行 <code>uv init</code> 命令，这样就得到了一个初步符合 PEP 8 规范的 Python 项目，其项目结构通常如下所示：</p>\n<pre><code class=\"language-text\">python_demo\n├── .python-version # 用于指定 Python 解释器版本号的文件\n├── pyproject.toml  # 项目配置文件，用于填写一些项目元信息\n├── main.py         # 项目入口代码，现在是一个 Hello, World! 程序\n└── README.md       # 项目说明文件，用于填写项目简介\n</code></pre>\n</li>\n<li>\n<p>虽然上述项目结构已经足以应对一些小型的开发需求了，但如果我们想让它更贴近当前社区普遍认可的 PEP 实践，还需要进一步调整。为此，我们需要继续在 <code>python_demo</code> 目录下分别创建 <code>src</code> 和 <code>tests</code> 这两个子目录，并将之前位于项目根目录下的 <code>main.py</code> 文件移动到 <code>src</code> 目录中。调整后的项目结构如下所示：</p>\n<pre><code class=\"language-text\">python_demo\n├── .python-version        # 用于指定 Python 解释器版本号的文件\n├── pyproject.toml         # 项目配置文件，用于填写一些项目元信息\n├── README.md              # 项目说明文件，用于填写项目简介\n├── src                    # 用于存放项目代码的目录\n│   └── python_demo        # 用于存放模块代码的子目录\n│       ├── __init__.py    # 用于声明当前子目录为模块的空文件\n│       └── main.py        # 模块入口代码，现在是一个 Hello, World! 程序\n└── tests                  # 用于存放测试代码的目录\n</code></pre>\n<p>上述项目结构体现了几个重要的工程原则：</p>\n<ul>\n<li><strong>将项目配置与其实现分离</strong>：项目的配置文件（如 <code>pyproject.toml</code>）应被放置在根目录下，而项目的实现源码则被集中放置在 <code>src</code> 目录中。</li>\n<li><strong>将项目的测试代码与其实现分离</strong>：测试代码位于独立的 <code>tests</code> 目录中，避免与业务代码混杂。</li>\n<li><strong>项目结构的模块化</strong>：通过在特定的子目录中放置 <code>__init__.py</code> 文件，将其声明为模块，从而使得 Python 解释器能够正确识别该目录。例如，如果我们在这里希望将<code>src/python_demo</code>子目录声明为一个模块，并将<code>main.py</code>文件中的<code>hello</code>函数暴露给外部，那么就需要在该 <code>__init__.py</code> 文件中添加以下代码：</li>\n</ul>\n<pre><code class=\"language-python\">from .main import hello    \n</code></pre>\n</li>\n</ol>\n<p>当然，这里需要再次强调的是：PEP 8 中提出的这种项目结构设计规范不是强制标准，并不妨碍开发者们在组织项目方面的个性化发挥，但在生产环境中，它已经成为当前 Python 社区中被广泛认可的“最佳实践”之一。</p>\n<h3 id=\"为什么推荐使用-src-目录结构\">为什么推荐使用 <code>src</code> 目录结构</h3>\n<p>读者可能会觉得有点疑惑，为什么我们需要将程序的实现代码放置一个独立 <code>src</code> 目录中？这种做法在项目结构设计上的现实意义是什么？简而言之，它的直接目的是建立一个独立的、结构化的代码组织机制，以便有效地避免以下问题：</p>\n<ul>\n<li>意外导入当前目录下的同名模块；</li>\n<li>在未正确安装项目时，代码“看似可运行但并不规范”；</li>\n<li>部署或打包阶段出现路径相关的隐蔽错误。</li>\n</ul>\n<p>换句话说就是，设置 <code>src</code> 目录可以迫使我们<strong>以“已安装包”的方式来使用自己的项目代码</strong>，这与真实的部署和分发场景高度一致。另外，在拆分模块时，我们也要注意不要一味地“越细越好”，应遵循以下几个简单但实用的原则：</p>\n<ul>\n<li>每个模块只关注一类明确职责；</li>\n<li>模块名应反映其用途，而不是实现细节；</li>\n<li>避免在模块之间形成循环依赖；</li>\n<li>对外暴露的接口应尽量稳定，内部实现可以自由调整。</li>\n</ul>\n<p>总而言之，如果读者发现某个文件不断膨胀、同时承担多种职责时，往往就意味着它已经到了需要拆分的时刻。</p>\n<p>在这一节中，我们并没有编写任何“功能性代码”，但所做的工作却直接决定了项目未来的可维护性上限。通过遵循 PEP 规范，并在一开始就建立清晰的项目结构，我们为后续的依赖管理、测试、打包与分发打下了坚实基础。在下一节中，我们将从工程实践的角度出发，介绍如何基于虚拟环境来<strong>安装并管理项目依赖</strong>，并说明为什么在真实项目中，依赖管理应当被视为项目设计的一部分，而不是事后补救的步骤。</p>\n<h2 id=\"项目依赖的安装与管理\">项目依赖的安装与管理</h2>\n<p>在完成了上述项目结构设计的基本工作之后，我们接下来要解决的是另一个在具体项目实践中不可回避的问题：<strong>如何安装、隔离并稳定地管理项目依赖</strong>。对于 Python 项目而言，依赖管理不仅是要“能将项目所依赖的扩展包装上”，更重要的是要实现以下几个更本质的目标：</p>\n<ul>\n<li>确保不同项目之间所依赖的扩展包互不干扰；</li>\n<li>项目在不同机器、不同时间点上具有一致的运行环境；</li>\n<li>项目所依赖的这些扩展包在版本上是可追溯、可复现的。</li>\n</ul>\n<p>为了实现上述目标，Python 社区逐步形成了一套围绕虚拟环境（Virtual Environment）展开的通用实践。接下来，就让我们继续以 uv 这款项目管理工具为例，介绍现代 Python 项目中推荐的依赖管理方式。</p>\n<h3 id=\"使用-uv-来管理项目依赖\">使用 uv 来管理项目依赖</h3>\n<p>正如我之前在《[[编程环境配置|Python 学习笔记：编程环境配置]]》中所介绍的，在没有虚拟环境的情况下，Python 的第三方扩展通常会被安装到系统级解释器的 <code>site-packages</code> 目录中。这种做法在早期看似方便，但很快就会带来严重问题：</p>\n<ul>\n<li>不同项目对同一依赖的版本要求可能冲突；</li>\n<li>升级或卸载某个库可能意外破坏其他项目；</li>\n<li>很难准确还原某个历史版本项目的运行环境。</li>\n</ul>\n<p>虚拟环境的核心作用，就是为<strong>每个项目提供一个彼此独立的 Python 运行时环境</strong>，使解释器、第三方库以及相关工具只对当前项目可见。换言之，读者可以将虚拟环境理解为“项目的运行时沙箱”。但是，如果我们使用 Python 官方提供的解决方案，即先用<code>venv</code> 来创建虚拟环境，然后再用 pip 工具来安装并管理项目中的依赖，那么随着项目规模的扩大，我们很快就会遇到以下这些棘手问题：</p>\n<ul>\n<li>项目所依赖的扩展包在版本上并未被明确锁定，这会导致项目在不同时空环境中的行为不一致；</li>\n<li>不同机器上解析出的依赖树可能并不完全一致，这会导致项目在不同机器上的运行结果存在差异；</li>\n<li>随着项目依赖的变化，虚拟环境中会出现越来越多的“孤儿依赖”，这会导致项目体积的日益臃肿。</li>\n</ul>\n<p>为了更好地解决上述问题，在现代化的项目管理工具所提出的解决方案中，pip 工具通常不再被单独使用，而是用于充当“底层安装器”，配合 uv 这类更高层的依赖管理工具共同完成工作。在这里，我们可以将 uv 理解为一个集成了依赖解析、安装、锁文件生成等功能的工具链，它使得管理项目依赖的过程变得更加高效、稳定。除此之外，uv 在设计上也吸收了多种现有方案的优点，试着以更统一的方式解决依赖解析速度慢、环境复现不稳定、工具链分散、职责重叠等问题。</p>\n<p>在 uv 的工作流中，项目依赖的管理逻辑通常是围绕 <code>pyproject.toml</code> 文件展开的。例如在我们之前创建的 <code>python_demo</code> 项目中，<code>pyproject.toml</code> 文件的初始内容如下所示：</p>\n<pre><code class=\"language-toml\">[project]                                   # 项目元信息配置声明\nname = \"python-demo\"                        # 项目名称\nversion = \"0.1.0\"                           # 项目版本号\ndescription = \"Add your description here\"   # 项目简介\nreadme = \"README.md\"                        # 项目说明文件路径\nrequires.python = \"&gt;=3.13\"                  # 项目最低支持的 Python 版本\ndependencies = []                           # 项目的直接依赖列表\n</code></pre>\n<p>接下来，如果我们像之前在《[[编程环境配置|Python 学习笔记：编程环境配置]]》一文中所演示的那样，执行了 <code>uv add &lt;扩展包名&gt;</code> 这一用于安装依赖的命令，那么 uv 就会自动修改 <code>pyproject.toml</code> 文件，将我们安装的扩展包及其当前的版本信息添加到 <code>dependencies</code> 列表中，并同步生成一个名为 <code>uv.lock</code> 文件，用于锁定项目依赖的版本，如图 1 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 1</strong>: 使用 uv 安装依赖</p>\n<p>这时候，如果我们执行 <code>uv tree</code> 命令，就可以看到 uv 解析出的项目依赖树，如图 2 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 2</strong>: uv 解析出的项目依赖树</p>\n<p>从图 2 中可以看到，当前项目所安装的直接依赖是 <code>Flask</code>，而 <code>Flask</code> 又依赖了 <code>Werkzeug</code>、<code>Jinja2</code> 和 <code>itsdangerous</code> 等若干个扩展包，其中的诸如 <code>Werkzeug</code>、<code>Jinja2</code> 扩展包又继续依赖了 <code>MarkupSafe</code> 这个扩展包。这些信息被 uv 以树状结构展示出来，使得读者可以直观地了解项目依赖的层次关系，这比传统做法中使用 <code>pip list</code> 命令所获得的扁平化依赖列表要直观得多。</p>\n<p>更重要的是，当我们需要删除项目的某个直接依赖时，只需要执行 <code>uv remove &lt;扩展包名&gt;</code> 命令，uv 就会自动解析出该依赖所涉及的依赖树，并删除其中不再被其他依赖引用的间接依赖，这就解决了传统做法中使用 <code>pip uninstall &lt;扩展包名&gt;</code> 命令时，会产生的“孤儿依赖”问题，如图 3 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 3</strong>: 使用 uv 删除依赖</p>\n<h3 id=\"锁定依赖版本的重要性\">锁定依赖版本的重要性</h3>\n<p>当然了，在具体项目实践中，“能安装”并不等于“可复现”。为了确保项目在不同时间、不同环境中的行为一致，它所依赖的扩展包在版本上应当被明确锁定，而不是无限制地跟随最新版本更新。uv 在这方面通过创建 <code>uv.lock</code> 文件对版本锁定提供了原生支持，使依赖状态成为项目的一部分，而不是隐含在某台机器中。从工程化的角度来看，锁定依赖版本意味着项目的构建过程是可重复的，线上问题更容易回溯，协作成员的环境更加一致。这意味着，任何一个开发者只要完整地获得了一个项目的源码和配置文件，就可以通过执行 <code>uv sync</code> 这个命令，在本地完整地复现该项目的完整运行环境，如图 4 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 4</strong>: 使用 uv 复现项目运行环境</p>\n<p>现在，让我们再来系统地为读者总结一下 Python 项目中依赖管理的基本思路：</p>\n<ul>\n<li>虚拟环境是项目级隔离的基础设施；</li>\n<li>pip 负责执行安装，但并不擅长整体依赖管理；</li>\n<li>uv 提供了更现代、更稳定的依赖解析与管理能力；</li>\n<li>依赖版本应当被视为项目设计的一部分，而非临时决策。</li>\n</ul>\n<p>在下一节中，我们将进一步讨论：<strong>如何将一个已经结构清晰、依赖稳定的 Python 项目，打包为可执行文件或可分发的扩展包</strong>，并说明这些能力在具体项目实践中的意义。</p>\n<h2 id=\"项目的打包与分发\">项目的打包与分发</h2>\n<p>当一个 Python 项目完成了合理的目录结构设计，并且其依赖关系已经通过虚拟环境与锁文件得到了稳定的管理之后，我们接下来就该开始考虑项目的打包与分发问题了。请注意，“分发”这个词在工程化的语境中并不只是指把项目的源代码拷贝给别人，它通常还包含以下几种常见目标：</p>\n<ul>\n<li>作为 <strong>Python 扩展包</strong> 分发，供其他项目通过依赖方式引入；</li>\n<li>打包为 <strong>可执行命令行工具</strong>，供用户直接运行；</li>\n<li>在某些场景下，进一步打包为 <strong>独立可执行文件</strong>，以减少运行环境依赖。</li>\n</ul>\n<p>下面，我们将继续基于 uv 这款项目管理工具来为读者介绍当前 Python 社区所推荐的项目打包与分发方式。</p>\n<h3 id=\"使用-uv-来打包项目\">使用 uv 来打包项目</h3>\n<p>在早期，人们将 Python 项目打包成第三方扩展的方式是高度分散的。有的项目依赖与 <code>setup.py</code> 文件，有的项目通过自定义脚本发布，有的项目甚至完全没有明确的打包入口。这些做法在项目规模较小时尚可接受，但在多人协作、持续集成或长期维护场景中，我们就会遇到项目的构建流程不可复现、项目的成员之间使用的工具链难以统一、新成员难以上手等棘手的问题。为了解决这些问题，Python 社区逐步形成了一套围绕 <strong>PEP 517 / PEP 518 / PEP 621</strong> 的现代打包规范，其核心思想是：</p>\n<blockquote>\n<p><strong>将项目的元数据、构建方式与依赖声明集中到一个统一的配置入口中。</strong></p>\n</blockquote>\n<p>这个入口贯彻到如今具体的项目实践中就是 <code>pyproject.toml</code> 文件。换言之，如果想要顺利地完成项目的打包，我们首先需要确保 <code>pyproject.toml</code> 文件中包含了正确的配置。在上一节中，我们已经为读者介绍了如何在 <code>pyproject.toml</code> 文件中使用<code>[project]</code>配置项声明当前项目的基本元数据（包括项目的直接依赖列表）。接下来，让我们将目光转向与项目打包相关的<code>[build-system]</code>配置项，它用于声明项目打包所要使用的工具，先来看一个简单的示例：</p>\n<pre><code class=\"language-toml\">[project]                                    # 项目元信息配置声明\nname = \"python-demo\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.13\"\ndependencies = [\n    \"flask&gt;=3.1.0\",\n]\n\n[build-system]                               # 项目打包方式配置声明\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n</code></pre>\n<p>在上述文件的<code>[build-system]</code>部分，我们做了如下配置：</p>\n<ul>\n<li><code>requires</code> 列表声明了打包项目所依赖的构建工具；</li>\n<li><code>build-backend</code> 声明了打包项目时需要调用的后端工具；</li>\n</ul>\n<p>在这里，hatchling 是一个常用的构建后端工具，uv 会根据 build-backend 的配置来调用相应的底层后端工具来完成项目的打包。当然，uv 并不强制用户使用某一特定的底层后端工具，读者在这里也可以求选择使用 <code>setuptools</code>、<code>flit</code>、<code>poetry</code> 等来充当底层的后端工具，只需要将上述文件中的<code>[build-system]</code>部分修改为如下内容即可：</p>\n<pre><code class=\"language-toml\">requires = [\"setuptools&gt;=58.0.4\"]\nbuild-backend = \"setuptools.build_meta\"\n# 或者：\nrequires = [\"flit_core&gt;=3.2.0\"]\nbuild-backend = \"flit_core.build_backend\"\n# 或者：\nrequires = [\"poetry-core&gt;=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre>\n<p>在完成配置之后，我们就可以通过执行 <code>uv build</code> 命令将项目打包成 Python 社区通用的扩展包文件（扩展名为 <code>.whl</code> 的 wheel 文件，以及扩展名为 <code>.tar.gz</code> 的源码包文件）。在执行该命令的过程中，uv 会依次执行以下步骤：</p>\n<ol>\n<li>读取 <code>pyproject.toml</code>；</li>\n<li>调用指定的底层后端工具；</li>\n<li>在项目根目录下生成 <code>dist</code> 目录；</li>\n<li>将项目打包的结果输出到其中。</li>\n</ol>\n<p>例如具体到<code>python_demo</code>项目中，在我们执行了 <code>uv build</code> 命令后，就可以在项目根目录下的 <code>dist</code> 目录中分别看到名为 <code>python_demo-0.1.0-py3-none-any.whl</code> 的 wheel 文件，和名为 <code>python_demo-0.1.0.tar.gz</code> 的源码包文件，如图 5 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 5</strong>: 使用 uv 打包项目</p>\n<p>接下来，我们就可以将这些打包的结果上传至私有或公共包仓库、又或者直接分享给其他人，让他们通过 <code>uv pip install</code> 命令以自定义扩展包的形式安装到自己所在的 Python 运行环境中。例如在这里，当我们执行 <code>uv pip install dist/python_demo-0.1.0-py3-none-any.whl</code> 命令时，uv 就会自动调用 pip 解析出该扩展包的元数据与依赖关系，并按照其中声明的版本号来安装它，如图 6 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 6</strong>: 使用 pip 安装扩展包</p>\n<p>如读者所见，在执行完安装命令之后，我们就可以在当前虚拟环境中运行的 Python Shell 中使用 <code>import</code> 语句来导入并使用该扩展包了。</p>\n<h3 id=\"使用-uv-来构建-cli\">使用 uv 来构建 CLI</h3>\n<p>除了将项目打包成可供他人使用的扩展包之外，我们更多时候还需要将 Python 项目分发成命令行工具（CLI）的形式，直接提供给用户使用。例如，如果我们现在想将之前的 <code>python_demo</code> 项目实现成一个基于<code>Flask</code> 框架的 Web 服务应用。那么，首先，我们需要将项目根目录下的<code>src/python_demo/main.py</code> 文件修改为如下内容：</p>\n<pre><code class=\"language-python\">from flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello, World!\"\n\ndef main() -&gt; None:\n    app.run()\n</code></pre>\n<p>然后，我们就只需要想办法将该项目打包成 CLI 的方式，让用户在命令行中直接运行这个 Web 服务即可。为了实现这个目标，我们需要在 <code>pyproject.toml</code> 文件中为这个项目配置一个 CLI 入口点，这可以通过 <code>[project.scripts]</code> 配置项来完成，下面是一个简单的演示：</p>\n<pre><code class=\"language-toml\">[project]                                    # 项目元信息配置声明\nname = \"python-demo\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.13\"\ndependencies = [\n    \"flask&gt;=3.1.0\",\n]\n\n[build-system]                               # 项目打包方式配置声明\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[project.scripts]                           # CLI 入口点配置声明\nweb-hello = \"python_demo.main:main\"\n</code></pre>\n<p>在上述配置文件中，<code>[project.scripts]</code> 配置项下面包含了以下信息：</p>\n<ul>\n<li>在安装了该项目的分发包之后，当前  Python 运行环境中会生成一个名为 <code>web-hello</code> 的命令；</li>\n<li>当用户在当前 Python 运行环境中执行 <code>web-hello</code> 命令时，Python 解释器会自动调用 <code>python_demo.main:main</code> 方法。</li>\n</ul>\n<p>在完成上述配置之后，我们就可以通过执行 <code>uv build</code> 命令将项目打包成 CLI 的形式，并使用 <code>uv pip install</code> 命令安装它。在安装完成之后，我们就可以在当前 Python 运行环境中执行 <code>web-hello</code> 命令来启动这个 Web 服务了，如图 7 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 7</strong>: 使用 uv 构建 CLI</p>\n<p>需要注意的是，由于在某些面向非开发者的场景中，要求用户事先安装 Python 并配置环境并不具备现实的可操作性。这时，我们确实可以适当考虑将项目打包为独立可执行文件。但这类方案通常会存在诸如项目构建体积较大、构建流程更复杂、与平台强绑定等问题，因此在实际项目中并不推荐作为默认选择。</p>\n<h3 id=\"从工程角度理解打包的意义\">从工程角度理解“打包”的意义</h3>\n<p>将项目打包，并不仅仅是为了发布，更重要的是它带来的工程约束：</p>\n<ul>\n<li>项目必须拥有清晰的入口；</li>\n<li>元数据必须完整且一致；</li>\n<li>构建过程必须是可重复的。</li>\n</ul>\n<p>这些约束反过来，会倒逼项目在设计阶段就保持良好的结构与边界。</p>\n<h2 id=\"本篇小结\">本篇小结</h2>\n<p>在这一篇笔记中，我们完成了从“会写 Python 代码”到“能交付 Python 项目”的过渡：</p>\n<ul>\n<li>\n<p>通过 PEP 规范约束项目结构与编码风格；</p>\n</li>\n<li>\n<p>通过虚拟环境与 uv 管理依赖；</p>\n</li>\n<li>\n<p>通过标准化打包流程实现可复现的构建与分发。</p>\n<p>从这一刻开始，Python 不再只是脚本语言，而成为了一种<strong>可以被工程化、产品化的开发工具</strong>。</p>\n</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-01-24 15:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/owlman\">凌杰</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "忆往昔--OI生涯回忆",
      "link": "https://www.cnblogs.com/hicode002/p/-/oi-memories",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hicode002/p/-/oi-memories\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 11:45\">\n    <span>忆往昔--OI生涯回忆</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>突然大概明白了为什么这么失败了...其实我对OI/计算机的热情远没有那么高，至少不是那种特别喜欢写程序写项目的人，之前也只是用E语言/Python写各种小工具/爬虫，还研究过一段时间游戏开发（当然小学时候是不会英语用的中文编程），甚至那时候就会多线程并发（当然还是中文语言）那时候的确对写程序有很强的热情，至少说是一个自我满足的过程，得写了好几十个小工具而且思路也还比较清晰能坐在电脑面前很长时间，而且没有很强的炫耀思维。当然当时也是刷机爱好者，在那个年代感觉（小学时候）几乎没有很多的资源但是我那时候一直有个梦想就是给手机刷windows和手机双系统，（结果这个到今天也没实现emmm），然后刷坏了好几部手机，d当时还是Windows Phone时代，那时候我一直想着手机有一天也要有电脑的BIOS。（然后后来WOA项目真的做了）然后就是MC玩家还研究过命令方块（当时手机版刚出命令方块）（还是多玩我的世界盒子时代），当时体育课还把它都打印出来和同学讨论。<br />\n然后小学很早家里买了一堆操作系统安装和Dreamviewer/photoshop软件使用的书，当时还说要自己写一个博客，（谁知道现在前端都是vue+react，并且博客都是现成的模板），然后还有一本上世纪的VB编程（结果现在早淘汰了）。</p>\n<p>从这个意义上说我至少学OI前我的计算机学习的确是出于兴趣并且充满热情的，而且都是自学的。</p>\n<p>初二时候想着研究AI相关的（主要是流浪地球的MOSS吸引的），然后想着系统性的学python什么的正儿八经写一个自动化工具（当时也不懂AI的原理只知道要训练），然后一直没有好的自学资源（或者说当时我找不到），然后当时语文作文很差被家长勒令去上辅导班加上和老师/同学关系很差，所以说很难受。然后辅导班旁边有有一家新开的编程机构邀请我试听，然后去了，到那把我的情况一说，然后人家觉得我水平还可以跟我说了信息学竞赛和C++相关的，然后我一下子非常高兴，就跟家长说要学（在此之前所有兴趣班我都学不下去），然后刚好当时初中班主任对我态度很差，之前还说过我除了会点电脑啥都不会就是废物之类的话（确实我体育不好，谁叫她教体育的...),所以说就真让家长报班学了，当时还有另外一个骗子机构叫做童程童美，是教python的，用python写小游戏，但是我觉得有点水（事实证明这个机构后来的确暴雷了）。然后暑假2个月把C++语言基础学出来了，那时候突然一下子了解到自主招生，了解到一种神秘的东西叫做游记/退役记，然后才意识到，原来编程学的好可以保送/高考降分进入名校啊，突然意识到原来在有些地方他们的中学生活非常快乐而不是像我一样。然后当时翻到了很多NOIP考了好成绩被高中保送，然后高中在机房快乐的编程，感觉非常浪漫就像在童话的世界一样。还有一些学长高三提前降一本然后在学校爽玩然后在全校分享自己的经验，那种感觉就是一个从来没有见过的新世界呀！</p>\n<p>那时候我一下子意识到我也要像他们那样，那时候看到大佬们的游记里面提到的高大上听不懂名字的算法和数据结构，还有当时一个流行的话：暴力出奇迹，暴力进国集，想着只要我认真学习这些算法和数据结构，再有着良好的数学基础，再给我充足的时间，然后肯定可以拿到金牌进入国集!（而且看zyb大佬的博客大概的学习路线也确实是这样的）而且那时候整个西海岸连一个省一的都没有！所以说当时是我暗自就下定决心要把全部精力投入到这个上面，一定要拿到金牌，拿不到金牌拿一个银牌也行，那样到时候没有人会再嘲讽我！再也没有人会说我体育差/语文差!然后我想象着拿到牌子之后，我可以认识很多人，我可以有一天站在学校的讲台上讲着自己的经验，我保送/降分之后我可以弥补我之前没有做的事情，我可以做化学实验，我可以重新玩我喜欢的游戏，我可以有自己的游记下面也会有人评论！</p>\n<p>然后我那时候想着第一年先拿到普及组一等奖，那时候我虽然不理解很多算法连回溯都不太理解但是我代码能力还可以或者说心态很好，这些题都是直接上手写代码的。后来还配了NOI linux环境，还配置了GEDIT和VIM，当时还想着考场上是Linux环境,还担心会有一些编译错误，甚至默写头文件而不是使用万能头，然后还记着当时初中语文课（我语文课听不下去老师天天骂我，而且阅读题我从来不做因为总感觉自己的想法会被老师审阅是很不舒服的，只有考试才做因为阅卷老师是随机的），课上在课本的角落上在那边默写头文件/想题（当时都是一些模拟题）。然后到CSP考前我基本上刷完了历年所有普及组的前两题，这样说前两题根本没有什么难度，我拿个普及组省一没有任何问题。当时状态也是非常好，复赛的时候去日照那时候OI还是蒸蒸日上，疫情和强基计划还没有出台，日照的人很多，很多学校有庞大的队伍，当时的我也是感觉很羡慕</p>\n<p>然后是初三 自主招生 化学实验 CSP2020 自学记笔记（效率低的问题） 没有资源（不知道刷什么题） 想要有强校集训的氛围，但是这种快节奏的课容易走神，训练上面没有时间写代码，这是最严重的问题，中考超出50多分。 热情还是在的，当时会python还写过脚本学过爬虫 然后还在用e语言写窗口程序（当时不知道c#诶）</p>\n<p>中考结束后的暑假，那应该是状态前期比较好的一个暑假了吧...<br />\n暑假前期一中的自招班要提前去上一周课，当时是没有晚自习的，而且食堂特别好（后来才知道那段时间是特意那么搞的，平时食堂很烂），然后当时一中承诺学科竞赛要认真搞，我还想着联系教练（结果连教练都没有，笑，就是微机老师）。<br />\n印象最深的是当时一中的学姐学长回来宣讲，当时的我非常的心潮澎湃，看着他们描述的丰富多彩的大学生活，当然现实是从外表和言谈上已经完全看不出曾经是高中生了，所以确实应该有不错的大学生活。然后他们讲着在一中是怎么学习的，分享自己的经验，非常的从容。我当时就在想，假如有一天我进了省队拿了银牌或者以上，那么我也可以回来坐在那个讲台上，分享我学习OI的事情。那种激情确实很强的刺激我学习OI。</p>\n<p>我当时想法很简单要过完数据结构+图论的内容，然后后面再看DP。但是我当时只会照着OI-WIKI学，实际上学的太偏向模板了而且OIWIKI不是很通俗易懂。我当时列的计划不错，但是现实是我每天根本完不成，因为我看一会儿wiki然后看不懂就去搜搜了很多还是看不懂就浪费很多时间，再就是看一会儿经常往下翻总之还是有点静不下心。所以实际上我到8月份只学了线段树树状数组堆分块还有一些数论算法之类的，然后我就很急。这要开学可怎么办啊！我的想法是NOIP2021要拿高分然后冲省选的！然后第一次跟家长谈论停课。然后家长果然拒绝了还说了一些难听的话（大概就是以后我后悔了又要怪他之类的）（还有什么白养了之类的）。当然拒绝是理解的毕竟刚进入高中我对一中所谓的竞赛培养体系还抱有幻想。</p>\n<p>进入一中后，状态很好 然后最开始有教练，但是我想法太好了，有点飘了，然后意识到一个问题就是交流题目这种有刺激性的事会让我完全无法思考，所以晚自习做题效率很低。再就是代码能力还是差到后期头疼思维混乱了就只能出思路写不动代码。然后NOIP2021前实际上没学多少东西。 NOIP2021爆炸。接下来是复盘反思：数学基础薄弱，连方差的两种算法都不知道，概率期望不会算，排列组合水平差，所以恶补了很多数学，当然也是自学高中数学 然后实际上就偏离了对代码能力的培养：这和在学校没有电脑关系很大 再加上我对重点班的竞赛培养抱有幻想</p>\n<p>而且后来高一上几乎不怎么写作业然后期末级部30多名，然后被调进了所谓重点班。其实某种程度上说这也是噩梦的开始。我以为重点班老师会充分信任学生的能力，班里会有很多搞竞赛的，会有一个良好的氛围，即使压力很大，因为我之前也看过那些回忆录里面提到的竞赛班，很多都是长时间停课然后搞竞赛的，所以我的想法还是挺好的，所以那时候我都想好了要跟着学校进度走走看。然后就是高一下学期跟了一段时间文化课还去参加了SDOI2022，但是SDOI2022前没有任何准备，当时晚自习周末都没有去搞竞赛，就是偶尔跟着zgx搞一搞。但是只能说进入这个班之后压力骤增。老师并不是很信任这些学生，相反每周还要花很长的时间开班会来PUA。而且，这个班直接从普通班的楼搬出去了，某种意义上是物理隔离（当然你要主动去找也可以）。然后实际上老师和领导是有意鼓动这个班的内卷风气，而且PUA的内容就是清华北大。（其实我感觉去不去TP无所谓，华五好专业更好，真去TP可能就真抑郁了。。。）实际上班里并不支持学习竞赛，或者说学校是把竞赛看作是一种whk的补充或者说是为了强基校测准备的。（但是后来确实出了两个牌子一个PHO一个CHO，好像也没有额外的训练，当然我觉得CHO没有那么难）。在这样一个内卷的状态下实际上按照自己节奏学习WHK是一件很难的事情，实际上像物理，老师讲的很快而且实际上也讲不出什么，更多时间还是应该按照自己体系来进行学习（我高中物理跟这个老师成绩挺差的裸分有时候70多）（后来准备少创时候是按照小时百科重学了一遍相当于），然后真正的去理解一个题目。生物也是，后来我生物是看网课才得到比较大的提升。所以实际上这一个学期我是挺痛苦的，不仅没有学到OI上什么东西把SDOI2022浪费了，这可是我唯一去省选的机会啊。然后WHK上我又很痛苦，明明假期家长已经拉着我预习一遍了，我还要再学一遍干啥。所以实际上根本没办法静下心来，反而把时间都浪费了。这可能是最后悔的一件事。</p>\n<p>当时还有另外一个有趣的事情，就是5月时候，突然想把学生平板破解了，然后就和wk研究刷机，然后了解到华为的Bootloader，然后那时候有一个开源工具叫potatonv，但是不是很好用。后来我读了potatonv的源码手动复现了他的解锁原理。然后当时有一篇很著名的安全报告，或者说两篇描述的同一件事情：华为海思麒麟芯片上的安全启动漏洞，一个是taszk pdf的，一个是pangu的。然后当时看了，但是还有很多细节不理解，但是由于我的平板是麒麟659和论文对不起来再加上用不上，所以就放弃了，想着以后有什么时间再复现一下。结果拖了4年...（然后2025年上半年复现了，后果惨重）.然后当时我们两个研究了怎么解BL 刷TWRP，然后我们研究了好久双系统，最终找到了一种在SD卡上跑双系统的办法。当时，我突然看到一个项目叫做POSTMARKETOS，是在手机上面移植linux，但是当时一个是没时间再一个也不是很懂设备树什么的，但是就想着这件事，以后要研究怎么在手机上面移植Linux。另外当年最震撼的项目就算Renagade Project，在手机上安装Windows，这个可是我从小学开始的梦想啊！然后我就想着也许麒麟也可以移植UEFI（现在觉得这是不可能的我有点疯了）。另外一件事就是初二疫情的时候我入坑了Limbo模拟器吧，但是玩了一会儿发现手机模拟电脑架构速度太慢，所以就想着开KVM。当时KVM是圈子里面最高的神话。所以说我后来每次遇到一个手机/芯片，都想着在上面开KVM，但是到现在我还是没有研究清楚（现在状态毁了）。<br />\n从这件事来看，我当时还是有比较强烈的对计算机的热情的，虽然写不动算法竞赛题目的代码但是一些有趣的小项目工具我还是愿意写的，比如说yichafen爬虫，比如说谷歌小恐龙自动玩，还有写过OJ，虽然只是C++写的后端。还有当时我为什么还在用易语言写窗口程序！甚至和C语言结合起来！当时我为什么不想着学一门正经的窗口编程语言比如C#...但是我没有想过开发一个大型工程。当然当时更不会想着什么开发方向或者安全方向（虽然初二就研究过几次SQL注入但是发现大部分网站都修复了然后剩下的没有任何了解）。所以说这实际上也是埋下了一个伏笔。但是正常来说这样的状态大学接着系统的学习计算机或者打ICPC最后肯定看起来没什么问题，当然这是后话了。</p>\n<p>这种热情到NOIP前就已经消失殆尽了，当时为了停课都疯了，当时就好像一个失心魔，每天回家就要和父母大吵一架，大喊大叫(嗓子也喊坏了...)，然后在学校动不动早读的时候或者语文课的时候就砸桌子或者一个人跑出去然后开始哭，后来还写纸条给各科老师和主任希望只要有一个同意的。这样我的心态受到了很大的影响，本来想的是静下心思考认真训练，但是为了停课我的心态已经爆炸了心情已经很不好了，已经没有精力接着认真学习，而且这样我就感觉很急好像如果我NOIP考的不好所有人立马就会反对我，所以说实际上把所有希望都寄托在NOIP2022上了，这样自己一旦想不出题就特别焦虑，又不敢看题解，因为看题解之后我就感觉自己很傻然后心态更差了...所以那段时间每天投入大量的精力学习OI尤其是重心放在一些复杂的trick和思维题上面，当然也补了暑假zhengrui没学会的东西，但是收效甚微而且每天心情都很差经常大喊大叫然后很焦虑，然后基本上实际上一天什么也没干，而且我执行力差很多细节复杂的题的代码本来都没有写现在这个状态基本上就是只看题不写题了。<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260122000619030-1117947224.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260122000629006-1193078129.png\" /><br />\n那时候的题单到后来也没写完...而且以前题目写错了尤其是思路错了我会心态很好的调试，然后换思路，但是从高中开始，我越来越惧怕这种失败了，这种浪费时间的失败，因为时间紧迫，所以说一旦想错了我就很自责，久而久之就害怕写代码调试了。所以说这可能是导致我代码能力下降的又一个重要原因。<br />\n所以说实际上这时候NOIP是注定要爆炸的，10月份开始就有很清晰的预感，只不过心里总是想着万一上天眷顾我一次呢！万一题目合我的胃口呢！<br />\n但是那时候我还有一丝希望，因为还有CSP！<br />\n当时是星期三，我那天又很生气，然后想着停课，毕竟马上CSP了，</p>\n<p>但是现在想想，其实OI的失败是必然的，我早就没有良好的心态了，而且我做事情的目的已经从纯粹的兴趣变成了我要被别人认可我要被别人承认我要拿到成绩，这种目的性太强了，而且我的执行能力比较差，虽然也尝试过很多比如列计划，整理笔记等方式但是效果只能说没什么用。而且我的精力严重不够，就像前面说的那样，看一会儿电脑就头疼，而且在电脑前思维非常的混乱，如果不借助草稿纸，甚至感觉不能正常的思考。（这个现在倒是好一点，但是就是效率太低）即使休息的很好第二天也是很累浑身乏力，更何况有时候我会陷入幻想根本睡不着。而且我总是有一种幻想就是我可以像淄博的那两位那样或者像lx那样从没有资源没有支持的地方逆袭翻盘，但是实际上我的天赋根本不支持如此，而且实际上那些大佬虽然在弱校但是却能够经常出去集训，也就是说能够把握一手的考试方向和主流的题目，而且有一个正常的人际交往，而且他们的天赋都比较厉害。而且OI也没有以前纯粹了，以前圈子的互帮互助分享交流变成了一种很奇怪的p话文化，不仅仅是卖弱这么简单，而是有时候感觉有一种强烈的歧视感，而且虽然资源现在是够多了但是主流的方向还是不好自己把握。而且，题目的难度正在变怪，从原来的考察代码能力+算法/数据结构积累能力+一定的思维能力 变成了 思维能力为主或者说是更加偏向于数竞这种启发性的考试了。这在工程意义上我觉得不是什么好事儿。但是，关键问题是，OI退役后，事情并没有好起来。</p>\n<p>NOIP出分之后，我还是不服气，当时疫情隔离结束之后返校了。结果，返校之后，老师把我桌子拖到了最后一排。返校之后课上当时还在继续学习准备省选知识点，那时候状态还可以，还想着省选还可以翻盘。但是，当时级部主任把我平板没收了，看我上课在看平板。然后我心情就挺差的。不过当时我还是有自信的毕竟我觉得NOIP的T3只要当时清醒一点把DP方程改对就一点问题没有了。但是后来，家长开始说我，让我开始补文化课，然后又拿期末考试说事儿。而且，当时，刚好疫情解封前最混乱的时期，在学校里面关了两个周。那时候我在想的一件事是，我到底有没有能力或者说有没有希望省选翻盘？我当时翻了Cmd2001大佬的博客（他是noip2017二等奖然后省选翻盘NOI2018Ag）的翻盘记录，看着充满希望。</p>\n<p>然后当时中午午休的时候没有宿舍住（因为我走读），就跑到二楼的那个据说是生物竞赛的活动室里面。里面有一台电脑。我中午就躲在里面把门反锁，打开电脑听歌，然后就在那里哭。<br />\n直到有一天，那天的中午我感觉很冷，别人都回去睡觉了，我吃完饭在教室里全身发冷，即使有暖气。然后我就怀揣着希望进了竞赛室。那天竞赛室还有别人，我就没有使用电脑，然后坐在那里。屋子里面开空调了，很暖和<br />\n。过了一会儿，生物竞赛教练进来了。我刚要开口，他就说：谁让你进来的？来着干什么？是不是来这玩电脑？ 然后我想了一会儿，硬生生地没有开口：我是信息竞赛生。然后想了想带上所有东西头也不回的走了。那一瞬间，有一种绝望感，就是一种被世界抛弃了。然后，哪天晚上我就发烧了，结果是感染新冠了。</p>\n<p>自从这件事之后，我突然有一种学不下去省选内容的感觉，而且有一种几乎命中注定的感觉：无论怎么努力省选也不可能翻盘。后来我就很少再跟别人提及OI。直到WC快报名的时候，zgx家长问我家长要不要报，我一看，WC竟然改成线上了，这让我感觉有一种走形式的感觉。我看到之前博客里面大家去WC然后互相交流面基的感觉很快乐，但是这种东西已经没有了。我意识到，WC很贵我要是报了我家长到时候一定拿掏钱这个事来PUA我，于是，我主动拒绝了。就这样，我OI就退役了。从这之后，上大学之前，我就再没有碰过一道算法竞赛题，没有学习任何一个新算法。</p>\n<p>然后，我意识到我回归不了WHK了。之前我设想的我能坦然回归whk至少是省选结束之后，然后按照我自己的节奏好好的学习一下WHK。但是现实是，回归之后，家长/老师对我期望很高，希望我回到扔whk搞OI之前的状态--就是高一下期末660+的状态。而且我根本没有理由向别人说我能自己做好这件事。因为很简单：我只是NOIP低分省一连省选都没打就退役了，也没有什么牌子。所以说实际上他们的期望更高了但是信任度更低了。所以说，我期末考的并不好。当时有点害怕，害怕到高三还是回不到之前的状态。（但是事实证明实际上就算不搞OI我可能也没有一个理想的状态，因为我的精力严重不够）然后寒假就是被家长拉去搞whk了。</p>\n<p>这时候，谁能想到一个东西即将再次撞击我的命运。</p>\n<p>考上少年班之后，当时其实我很高兴。我想到，三年前，我坐在阶梯教室里面，看着台上的学长热情洋溢地讲着自己的大学生活和高中的努力（而且真的看不出是高中生了，明显是适应了大学生活），我幻想着有一天也能像他们一样。但是现在，我的确做到了，甚至说比他们做的更好（毕竟是xha第一个去的），我利用自己的省一奖项，降一本线进入华东五校止一---USTC，这相当于我已经做到了自主招生时代所谓的一本约。我想着我终于可以拾起来我之前没有做的事情，我可以出去转一转，我要出去讲OI课，有一天我也要回学校宣讲。我希望有一天xha有自己的竞赛组织，能够请一些人讲课（就像那些学长博客里面提到的那样学校请他们回去讲课）（我看到一个重庆大学的都被邀请回去了）。我想着我终于能够被承认了，然后我就可以有我的自由，然后就可以有我自己的大学生活了。但是，现实里面有一种隐隐的不详的预感。那天出分之后第二天家长就不让我去学校了，当然说是保护我，我觉得有一点道理。但是我还想着回学校吹一手(bushi).然后问题来了，家长开始PUA我了。大概意思就是考上之后不能放松，要更努力，暑假要提前预习，然后说意思就是我没有这个能力就是运气好之类的...然后我就有一种失落感，总感觉这个不是自己考上的。然后我发现进入重点班之后我开始严重的缺乏安全感，每天都有一种被监视的感觉，当然不是因为重点班内卷，而是有一种刻意营造出来的感觉。所以说我开始缺乏自信。然后家长开始PUA我，所以我暑假也没有自己的自由干事情，而且我也没怎么自己出去，因为我发现自己出去在家里几乎是不可能的，家长总要找一个借口陪着我。客观的讲陪着我当然也很好，但是我还是喜欢和朋友（当然可能是初中朋友）或者是其他搞oi的同学出去。说实话。而且我根本不想预习大学的任何东西因为我OI欠下来的东西还没有填上。再者说我之前也自学过高数。当时我和家长提大学打ICPC，谁知道他们先说什么ICPC再好被退学了有什么用？然后又是开始吵架...然后我暑假去了之前我初二去的那个机构，虽然只学了一年实际上也就是语言入门但是还一直保持联系。结果去了之后我一点也不自在，本来是我考上好学校，而那个机构只有普及组教学的水平，按理来说我是完全有理由平等的过去交流甚至可以去那边讲课。但是现实是我家长去了然后就开始低声下气在那边问大学要准备什么？大学xxx怎么怎么样，然后又是听机构的创始人东扯西扯说一些大道理，但是现实是在那边听一个QDU和石油大学毕业的，而且大概率是计算机学的不怎么样的人的经验没什么参考价值(毕竟这个机构工资不高正经人谁去啊），跟我说的东西和USTC的现实实际上是一点对不上，然后又问ICPC怎么样，结果xxx竟然说什么ICPC对于这种大学没什么用。那我只能说没啥意思了，这就把我家长给忽悠住了，刚好他不想让我大学打ICPC。毕竟现实是USTC 2025 ICPC预选赛报名队伍数量是全国最多的。反正去了一下午感觉很不舒服，就好像在那边受罪一样，全程我都不怎么说话。这件事我就挺失望的。我感觉不管我做到多好都没有人真正认可我。但是为什么他们就能认可别的Oier呢?</p>\n<p>然后暑假家长还是不让我大学打游戏。其实说实话我不愿意打游戏，但是这样我感觉很不舒服，连手机横屏都不敢了。而且现实是我好像连网购都没有网购过。我好像自己买的东西都不敢往家带，因为家长会翻书包，然后就会说我。（之前停课写的纸条被翻出来还挨骂了...)</p>\n<p>暑假时候当时还是缺乏自信不敢找同学玩，但是当时也有人来主动找我，gxh当时来找我，然后本来我们两个玩玩就挺好的，我两个高一上是同班同学，关系也不差。但是非要也不知道为什么家长非要去。那就变成那种无聊的饭局了...然后说是我们两个随便聊，现实是我根本开不了口因为两个家长一直在那边谈什么教育（当然又是经典的那些了...），然后我就在那边看手机，然后家长又骂我一顿说我出去吃饭怎么不说话...</p>\n<p>然后暑假就闷在家里也不知道干什么，被勒令预习，但是肯定是学不下去的，然后别的事情又放松不下来不敢干。我感觉家里已经不是让我放松的地方了...出门就去一趟日照而且感觉挺没意思的...所以说那时候就有一种强烈的感觉，这个学校不是我自己考上的，是别人恩赐给我的...我的能力其实不配。然后一种失望的感觉。</p>\n<p>就这样这个暑假过得很失败，甚至没有调整好开学前的状态，就是我找不到那种我刚开始搞OI时候那种我为了一个美好的事物然后全力的投入尽可能每个方面都做的很好的状态了。</p>\n<p>开学之后，然后你就知道了，彻底的crash...<br />\n而且最重要的是心里一点安全感没有，有一种我所做的一切都在被监视的感觉，根本没法静下心来学习。而且，我又找不到我对计算机的热情了，我只看到了一种很茫然的内卷。然后就是一点点的crash、...</p>\n<p>所以说为什么会这样，还是因为我想要的东西不仅没有被满足反而越来越远了，而且严重的内卷导致曾经我认为很厉害的东西现在可能已经烂大街了，这就消磨了我的热情。更重要的是长久缺失正反馈，失去自信，失去那种自然而然地感觉，相反后来充满着警觉感，在家里不敢和朋友打电话，不敢提出去玩的事情，不敢在家里把手机横屏，在公共场合总感觉别人盯着我，外面手机亮度开到最低总感觉别人在看我的手机屏幕，上课不敢记笔记总感觉别人盯着我。感觉我失去了安全感，或者说我的自由 我的隐私空间 我想做的事情 以及支撑我学OI最大的目标/动力这些并没有随着我考上中科大少创而有所缓解，反而加重了。有一种全世界都在和我作对没有人认可我的感觉，有一种即使很尽力了但是没有人相信我的感觉，所以突然就不想再碰OI了。之前在OI时候立志要培养的良好习惯，包括坚持记笔记，坚持深度思考，提高自控力（因为我确实从小自控力差执行能力差拖延严重，现在我觉得有可能是ADHD？）这些我自己觉得我做的不错的事情没有人相信我，相反我好像就像坐在监牢里面一样，这就是一种深深的失望。而且我又一种我没办法检验我自己全部能力的感觉。我高中基本上不写作业语文英语从来不学，但是高考语文121英语128（平时能上130，毕竟是高二考），所以我认为停课一段时间之后再补WHK并不是很困难的事情，但是没有人相信我。当然也不要指望竞赛圈的人能理解我，毕竟我不混圈，或者说我当时并不想当什么圈子的网红，而且竞赛圈大把人小学开始学习竞赛在强校有着充足的资源进行停课训练，所以说他们都看不上我们这些弱校的。（毕竟我们这一届是第一个NOIP省一喵，当然第一个是zgx）</p>\n<p>为了OI我之前4年不打游戏（其实在学OI之前家里不让打但是偷偷打），然后初二自学初三数学初三自学高中数学离散的部分，然后每个暑假又被家长拉着预习了高中其他科目，高一自学高中数学剩下的部分。高中又自学高数，线代，组合数学的一部分，具体数学，甚至还有一点群论，目的都是为了OI，当时想着我要提高数学水平因为当年NOI2019考了一道具体数学原题，所以我认为OI需要很高的数学水平。虽然我自学时候效率确实很低，经常忍不住往后翻或者干别的，但是的确也学了不少内容。但是即使这样我还是不能停课，然后明明提前自学过还是要开学上课，那我说我寒暑假不要预习其他科目了，反正开学还要上课，但是家长拉着我预习而且还跟我说什么不然就考不上大学，什么竞赛影响文化课就不要弄了，反正我做什么都不会相信我的能力，所以说我久而久之也不知道自己到底有没有这个能力了。然后我的同学后来把我当成小丑看因为他们别的竞赛似乎从来不需要停课，老师也觉得我很菜没有那个水平还整天装。但是现实是我的确也没有那个能力，比如说我的执行能力差，以及容易分心，比如说网上很多的经验是把竞赛资料打印出来课上看，但是现实是课上我根本看不下去过一会儿就会被课程的声音吸引就走神了，自习课能好一点，但是有时候周边同学的打扰就会让我完全静不下心无法思考，甚至我在做题时候如果和机房的zgx交流一点解法（哪怕只是几句话，这就是为什么高中不和别人交流问题了）那么这一晚上基本上做不下去了（现在越看越像ADHD）。但是whk上却不是这样，whk的内容偏简单不需要深度思考，逻辑链很短，更多的是一个心态和熟练度的问题，也就是如何以高正确率保证考场答完题，所以来说，在whk上这些困扰没有体现出来。而且长时间的OI学习让我满脸长痘整天头疼，也完全没有心情打理任何东西，所以外貌和声音也没有以前那么可爱了（现在后悔了...),但是当时想着只要我在OI上拿到牌子那么一切都会好起来，别人就一定会承认我的，所以根本没有在意这些。我以为考上大学之后就能够重新拾起来这些东西看看自己到底有没有这个能力，谁知道那种不被认可的感觉那种失望感让我觉得我的确是废物我没有什么能力。更重要的是我有点失去了目标。而且更重要的是我有一种很强的挫败感，就是我自己想做的事情总是因为各种原因做不好或者达不成希望，这可能就是我执行力太差加上命中缺这一环吧，我好像什么也干不好。大学之后，我原来想要的东西并没有实现，可是，来到科大，我并没有很快开始学习熟悉的计算机，相反，学校的数理基础课程占满了我的时间，别人都在内卷、科研，我想象中一个计算机式的大学生活并没有出现。（至少在我的印象里或者我看到学长宣讲/大佬博客的印象里），而且实际上我好像很多事情都还不会做。<br />\n高中时候实际上和同学关系也不算太差，但是也没有特别好的朋友 ，实际上也没什么社交，对异性也没什么兴趣（甚至说对性行为没什么兴趣）。高中也没有手机也不看什么娱乐的，虽然我破解了学校的学习平板，但是只是在上面看数学书/oi题/知乎上的学习性文章。生活上面实际上我很希望自由甚至说某种意义上学OI本身就是为了追求某种自由，但是高中时候学校家长没有给我这些，当时我也不是很在意因为所有心思都在OI上面，但是现在当我真正需要这些东西的时候发现好像我做不好生活上面的一些小事（当然也许是有ADHD导致的？），而且就像前面说的那样我失去了安全感。</p>\n<p>然后现在好想放松一下。</p>\n\n</div>\n<div id=\"MySignature\">\n    <p>黄粱一梦，终是一空</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/hicode002/\" target=\"_blank\">hicode002</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/hicode002/p/-/oi-memories\" target=\"_blank\">https://www.cnblogs.com/hicode002/p/-/oi-memories</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 11:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hicode002\">hicode002</a>&nbsp;\n阅读(<span id=\"post_view_count\">67</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Stern-Brocot 树",
      "link": "https://www.cnblogs.com/rgw2010/p/19525731",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rgw2010/p/19525731\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 11:39\">\n    <span>Stern-Brocot 树</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"p1797-模板stern-brocot-树\"><a href=\"https://www.luogu.com.cn/problem/P1797\" rel=\"noopener nofollow\" target=\"_blank\">P1797 【模板】Stern-Brocot 树</a></h2>\n<p><a href=\"https://www.luogu.com.cn/article/dv07cla2\" rel=\"noopener nofollow\" target=\"_blank\"><strong>洛谷同步题解。</strong></a></p>\n<blockquote>\n<p>前置知识：<span class=\"math inline\">\\(a \\perp b\\)</span> 等价于存在 <span class=\"math inline\">\\(x, y\\)</span> 使得 <span class=\"math inline\">\\(ax + by = 1\\)</span>。</p>\n</blockquote>\n<p>Stern-Brocot 树是一个包含着所有 <span class=\"math inline\">\\(m \\perp n\\)</span> 的全部非负的分数 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 的二叉树结构；其思想是从 <span class=\"math inline\">\\(0\\)</span> 阶 Stern-Brocot 序列 <span class=\"math inline\">\\(\\{\\frac{0}{1}, \\frac{1}{0} \\}\\)</span> 出发，高阶 Stern-Brocot 序列由以下递归操作定义：</p>\n<ul>\n<li>对于一个 <span class=\"math inline\">\\(k\\)</span> 阶 Stern-Brocot 序列，在其任意两个相邻分数 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 与 <span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 之间插入它们的<strong>中位分数</strong> <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span> 后形成的序列即为 <span class=\"math inline\">\\(k + 1\\)</span> 阶  Stern-Brocot 序列。</li>\n</ul>\n<p>例如：</p>\n<ul>\n<li>\n<p><span class=\"math inline\">\\(1\\)</span> 阶是 <span class=\"math inline\">\\(\\{ \\frac{0}{1}, \\frac{1}{1}, \\frac{1}{0} \\}\\)</span>。</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(2\\)</span> 阶是 <span class=\"math inline\">\\(\\{ \\frac{0}{1}, \\frac{1}{2}, \\frac{1}{1}, \\frac{2}{1}, \\frac{1}{0} \\}\\)</span>。</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(3\\)</span> 阶是 <span class=\"math inline\">\\(\\{ \\frac{0}{1}, \\frac{1}{3}, \\frac{1}{2}, \\frac{2}{3}, \\frac{1}{1}, \\frac{3}{2}, \\frac{2}{1}, \\frac{3}{1}, \\frac{1}{0} \\}\\)</span>。</p>\n</li>\n</ul>\n<p>容易看作二叉树的结构：</p>\n<ul>\n<li>每个分数都是 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span> 的形式，其中 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 是左上方离它最近的祖先，<span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 是右上方离它最近的祖先。</li>\n</ul>\n<p>oi-wiki 上的图较为形象，大家可以看着理解下：</p>\n<p><img alt=\"\" src=\"https://oi-wiki.org/math/number-theory/images/stern-brocot-tree.svg\" /></p>\n<p>为什么树上的都是最简分数？为什么不会重复出现某个分数？为什么所有可能的非负的最简分数都会在树上出现？</p>\n<p>容易发现这样一个性质，如果 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 和 <span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 在某一阶的 Stern-Brocot 序列中相邻，那么必然满足：</p>\n<p></p><div class=\"math display\">\\[m'n - mn' = 1\n\\]</div><p></p><blockquote>\n<p>证明考虑数学归纳法，初始 <span class=\"math inline\">\\(0\\)</span> 阶时有 <span class=\"math inline\">\\(1 \\cdot 1 - 0 \\cdot 0 = 1\\)</span>；若当前 <span class=\"math inline\">\\(k\\)</span> 阶 Stern-Brocot 序列中满足条件，那么在 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 与 <span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 中间插入的 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span>，相当于要证明：</p>\n<p></p><div class=\"math display\">\\[(m' + m)n - m(n + n') = 1\n\\]</div><p></p><p></p><div class=\"math display\">\\[m'(n + n') - (m + m') n' = 1\n\\]</div><p></p><p>第一个直接拆开 <span class=\"math inline\">\\(m'n + mn - mn - mn' = m'n - mn' = 1\\)</span>，第二个同理；于是得证。</p>\n</blockquote>\n<p>同时，上面 <span class=\"math inline\">\\(m'n - mn' = 1\\)</span> 这个式子也可以说明 <span class=\"math inline\">\\(m \\perp n, m' \\perp n'\\)</span>，那么可以得到树上的所有分数必然是<strong>最简分数</strong>。</p>\n<p>然后来考虑插入的分数的大小关系，显然有：</p>\n<p></p><div class=\"math display\">\\[\\frac{m}{n} &lt; \\frac{m + m'}{n + n'} &lt; \\frac{m'}{n}\n\\]</div><p></p><p>即一个中位分数在它原先两个值的中间，于是树上必然没有重复的分数。</p>\n<p>好，接下来要证所有正的最简分数 <span class=\"math inline\">\\(\\frac{a}{b}\\)</span> 都在树上出现，考虑反证法，初始显然：</p>\n<p></p><div class=\"math display\">\\[\\frac{m = 0}{n = 1} &lt; \\frac{a}{b} &lt; \\frac{m' = 1}{n' = 0}\n\\]</div><p></p><p>然后假设当前阶段有：</p>\n<p></p><div class=\"math display\">\\[\\frac{m}{n} &lt; \\frac{a}{b} &lt; \\frac{m'}{n'}\n\\]</div><p></p><p>考虑 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span> 与 <span class=\"math inline\">\\(\\frac{a}{b}\\)</span> 的大小关系：</p>\n<ul>\n<li>\n<p>若 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'} = \\frac{a}{b}\\)</span>，与命题矛盾，退出。</p>\n</li>\n<li>\n<p>若 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'} &lt; \\frac{a}{b}\\)</span>，令 <span class=\"math inline\">\\(m \\gets m + m', n' + n\\)</span>。</p>\n</li>\n<li>\n<p>否则 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'} &gt; \\frac{a}{b}\\)</span>，令 <span class=\"math inline\">\\(m' \\gets m + m', n' \\gets n + n'\\)</span>。</p>\n</li>\n</ul>\n<p>考虑证明这个过程不会无限进行下去，因为：</p>\n<p></p><div class=\"math display\">\\[\\begin{cases} \\frac{a}{b} - \\frac{m}{n} &gt; 0 \\\\ \\frac{m'}{n'} - \\frac{a}{b} &gt; 0 \\end{cases}\n\\]</div><p></p><p>即：</p>\n<p></p><div class=\"math display\">\\[\\begin{cases} an - mb &gt; 0 \\\\ m'b - n'a &gt; 0 \\end{cases}\n\\]</div><p></p><p>显然 <span class=\"math inline\">\\(an - mb, m'b - n'a\\)</span> 都是整数，于是：</p>\n<p></p><div class=\"math display\">\\[\\begin{cases} an - mb \\ge 1 \\\\ m'b - n'a \\ge 1 \\end{cases}\n\\]</div><p></p><p>然后必然有：</p>\n<p></p><div class=\"math display\">\\[(m' + n')(an - mb) + (m + n)(m'b - n'a) \\ge m' + n' + m + n\n\\]</div><p></p><p>前面把 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(b\\)</span> 专门提出来：</p>\n<p></p><div class=\"math display\">\\[a(n(m' + n') - n'(m + n)) + b(m'(m + n) - m(m' + n'))\n\\]</div><p></p><p>然后它们的系数可以根据 <span class=\"math inline\">\\(m'n - mn' = 1\\)</span> 化简成 <span class=\"math inline\">\\(1\\)</span>，于是：</p>\n<p></p><div class=\"math display\">\\[a + b \\ge m' + n' + m + n\n\\]</div><p></p><p>而上面每次操作中 <span class=\"math inline\">\\(m' + n' + m + n\\)</span> 都会增加，于是至多进行 <span class=\"math inline\">\\(a + b\\)</span> 次后就会退出，即找到 <span class=\"math inline\">\\(\\frac{a}{b}\\)</span>；于是证明了<strong>所有非负分数即正有理数</strong>都在树上，可以将 Stern-Brocot 树看作一个<strong>有理数的数系</strong>。</p>\n<p>因为每个正最简分数只出现一次，所以其与树上从根到它的路径是一一对应的，即我们可以用字母 <span class=\"math inline\">\\(L, R\\)</span> 来表示当前节点是往左右哪个儿子去走，一串 <span class=\"math inline\">\\(L, R\\)</span> 组成的序列就唯一的表示了一个位置；例如 <span class=\"math inline\">\\(LRRL\\)</span> 表示 <span class=\"math inline\">\\(\\frac{1}{1} \\to \\frac{1}{2} \\to \\frac{2}{3} \\to \\frac{3}{4} \\to \\frac{5}{7}\\)</span>；特别的，对于 <span class=\"math inline\">\\(\\frac{1}{1}\\)</span> 用 <span class=\"math inline\">\\(I\\)</span> 来表示。</p>\n<p>考虑这样一个问题，给出一组 <span class=\"math inline\">\\(L, R\\)</span> 组成的字符串 <span class=\"math inline\">\\(S\\)</span>，求出其对应的分数是什么？</p>\n<p>容易想到从初始 <span class=\"math inline\">\\(\\frac{1}{1}\\)</span> 开始，动态维护这个点是由左右哪两个节点合并的，初始是 <span class=\"math inline\">\\(\\frac{m = 0}{n = 1}, \\frac{m' = 1}{n' = 0}\\)</span>：</p>\n<ul>\n<li>\n<p>若 <span class=\"math inline\">\\(L\\)</span> 往左走：那么左祖先不会变，右祖先会变成当前节点；即 <span class=\"math inline\">\\(m' \\gets m + m', n' \\gets n + n'\\)</span>。</p>\n</li>\n<li>\n<p>若 <span class=\"math inline\">\\(R\\)</span> 往右左：同理，那么右祖先不会变，左祖先会变成当前节点；即 <span class=\"math inline\">\\(m \\gets m + m', n \\gets n + n'\\)</span>。</p>\n</li>\n</ul>\n<p>大家理解的时候可以看前面那个树的图来理解；然后我们就可以写下如下代码解决：</p>\n<pre><code class=\"language-cpp\">inline pair&lt;int, int&gt; getLR(string s){\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i] == 'L')\n\t\t  m_ = m + m_, n_ = n + n_;\n\t\telse\n\t\t  m = m + m_, n = n + n_;\n\t}\n\treturn mkp(m + m_, n + n_);\n}\n</code></pre>\n<p>当长度很长时，即给定是 <span class=\"math inline\">\\(L/R\\)</span> 每次走几次，也可以根据式子直接做：</p>\n<pre><code class=\"language-cpp\">inline pair&lt;int, int&gt; getLR(vector&lt;pair&lt;char, int&gt;&gt; s){\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i].fi == 'L')\n\t\t\tm_ = s[i].se * m + m_, n_ = s[i].se * n + n_;\n\t\telse\n\t\t\tm = m + s[i].se * m_, n = n + s[i].se * n_;\n\t}\n\treturn mkp(m + m_, n + n_);\n}\n</code></pre>\n<p>这种还是太程序性了，数学语言怎么表示？容易想到矩阵，即初始：</p>\n<p></p><div class=\"math display\">\\[M(S) = \\begin{pmatrix} n &amp; n' \\\\ m &amp; m' \\end{pmatrix}\n\\]</div><p></p><p>这里为啥不用像分数那样上面分子下面分母呢？主要是此时初始根节点的状态 <span class=\"math inline\">\\(M(I) =  \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}\\)</span> 这是一个单位矩阵，而用分数的表示形式的话不是单位矩阵要多乘一个矩阵，形式上也不那么清晰。</p>\n<p>然后考虑：</p>\n<p></p><div class=\"math display\">\\[M(SL) = \\begin{pmatrix} n &amp; n + n' \\\\ m &amp; m + m' \\end{pmatrix}\n\\]</div><p></p><p></p><div class=\"math display\">\\[M(SR) = \\begin{pmatrix} n + n' &amp; n' \\\\ m + m' &amp; m' \\end{pmatrix}\n\\]</div><p></p><p>那么可以推出 <span class=\"math inline\">\\(L, R\\)</span> 矩阵：</p>\n<p></p><div class=\"math display\">\\[L = \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix}\n\\]</div><p></p><p></p><div class=\"math display\">\\[R = \\begin{pmatrix} 1 &amp; 0 \\\\ 1 &amp; 1 \\end{pmatrix}\n\\]</div><p></p><p>即：</p>\n<p></p><div class=\"math display\">\\[M(SL) = M(S) L, M(SR) = M(S) R\n\\]</div><p></p><p>于是求 <span class=\"math inline\">\\(M(S)\\)</span> 时，可以看作是 <span class=\"math inline\">\\(S\\)</span> 中的 <span class=\"math inline\">\\(L, R\\)</span> 作矩阵乘法，例如 <span class=\"math inline\">\\(M(LRRL) = LRRL = \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 &amp; 0 \\\\ 1 &amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 &amp; 0 \\\\ 1 &amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix} = \\begin{pmatrix} 3 &amp; 4 \\\\ 2 &amp; 3 \\end{pmatrix}\\)</span>。</p>\n<p>于是求 <span class=\"math inline\">\\(S\\)</span> 所对应的分数只需要经过矩阵运算得到：</p>\n<p></p><div class=\"math display\">\\[f(S) = f(\\begin{pmatrix} n &amp; n' \\\\ m &amp; m' \\end{pmatrix}) = \\frac{m + m'}{n + n'}\n\\]</div><p></p><p>那么现在考虑给定一个分数 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span>，求其唯一对应 <span class=\"math inline\">\\(LR\\)</span> 序列这个问题？这就比较简单了，根据生成规则，我们知道 Stern-Brocot 树是一颗二叉搜索树，即左子树的点都比它小，右子树的点都比它大，于是可以通过比较与当前位置的值来决定。</p>\n<p>那么可以写下如下代码：</p>\n<pre><code class=\"language-cpp\">inline string backLR(int m, int n){\n\tstring ans = \"\";\n\tMat S;\n\twhile(1){\n\t\tauto t = f(S);\n\t\tif(t == mkp(m, n))\n\t\t  break;\n\t\tif(mkp(m, n) &lt; t){\n\t\t\tS = S * L;\n\t\t\tans.push_back('L');\n\t\t}\n\t\telse{\n\t\t\tS = S * R;\n\t\t\tans.push_back('R');\n\t\t}\n\t}\n\treturn ans;\n}\n</code></pre>\n<p>显然，这个效率较为低下，且要进行矩阵运算；考虑怎么优化一下，注意到：</p>\n<p></p><div class=\"math display\">\\[RS = \\begin{pmatrix} n &amp; n' \\\\ m + n &amp; m'  + n'\\end{pmatrix}\n\\]</div><p></p><p></p><div class=\"math display\">\\[LS = \\begin{pmatrix} n + m&amp; n' + m' \\\\ m&amp; m'\\end{pmatrix}\n\\]</div><p></p><p>那么：</p>\n<p></p><div class=\"math display\">\\[f(RS) = \\frac{n + n'}{m + n + m' + n'} = f(S) + 1\n\\]</div><p></p><p></p><div class=\"math display\">\\[f(LS) = \\frac{n + m + n' + m'}{m + m'}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\frac{1}{f(LS)} = \\frac{1}{f(LS)} + 1\n\\]</div><p></p><p>设 <span class=\"math inline\">\\(F(\\frac{p}{q})\\)</span> 表示其对应的字符串；那么我们可以看出，若第一步为 <span class=\"math inline\">\\(R\\)</span>，则 <span class=\"math inline\">\\(\\frac{m}{n} &gt; 1\\)</span>，否则第一步为 <span class=\"math inline\">\\(L\\)</span>，则 <span class=\"math inline\">\\(\\frac{m}{n} &lt; 1\\)</span>，于是可以递归的去做：</p>\n<p></p><div class=\"math display\">\\[\\frac{m}{n} = f(RS) \\to \\frac{m - n}{n} = f(S)  (m &gt; n)\n\\]</div><p></p><p></p><div class=\"math display\">\\[F(\\frac{m}{n}) = R + F(\\frac{n}{m - n}) (m &gt; n)\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\frac{m}{n} = f(LS) \\to \\frac{m}{n - m} = f(S) (m &lt; n)\n\\]</div><p></p><p></p><div class=\"math display\">\\[F(\\frac{m}{n}) = L + F(\\frac{m}{n - m}) (m &lt;n)\n\\]</div><p></p><p>那么可以写出如下代码：</p>\n<pre><code class=\"language-cpp\">inline string backLR(int m, int n){\n\tstring ans = \"\";\n\twhile(m != n){\n\t\tif(m &lt; n){\n\t\t\tans.push_back('L');\n\t\t\tn = n - m;\n\t\t}\n\t\telse{\n\t\t\tans.push_back('R');\n\t\t\tm = m - n;\n\t\t}\n\t}\n\treturn ans;\n}\n</code></pre>\n<p>你发现这特别像更像减损法，于是可以用辗转相除法类似的思路去优化，即：</p>\n<pre><code class=\"language-cpp\">inline vector&lt;pair&lt;char, int&gt;&gt; backLR(int m, int n){\n\tvector&lt;pair&lt;char, int&gt;&gt; ans;\n\twhile(m &amp;&amp; n &amp;&amp; m != n){\n\t\tif(m &lt; n){\n\t\t\tif(n % m == 0)\n\t\t\t  ans.push_back({'L', n / m - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'L', n / m});\n\t\t\tn = n % m;\n\t\t}\n\t\telse{\n\t\t\tif(m % n == 0)\n\t\t\t  ans.push_back({'R', m / n - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'R', m / n});\n\t\t\tm = m % n;\n\t\t}\n\t}\n\treturn ans;\n}\n</code></pre>\n<p>此时就可以做到 <span class=\"math inline\">\\(O(\\log n)\\)</span> 复杂度去找对应的路径。</p>\n<p>然后对于一个分数 <span class=\"math inline\">\\(\\frac{p}{q}\\)</span>，考虑其在树上一个子树 <span class=\"math inline\">\\(S\\)</span>，显然 <span class=\"math inline\">\\(S\\)</span> 是无限大的，但是显然其有界，在 <span class=\"math inline\">\\((\\frac{a}{b}, \\frac{c}{d})\\)</span> 之间，那么怎么求出 <span class=\"math inline\">\\(a, b, c, d\\)</span> 呢？回到前面每次插入的中位分数在两个值之间的性质，于是这只是换一个问法，显然只是在问合并出 <span class=\"math inline\">\\(\\frac{p = a + c}{q = b + d}\\)</span> 的是哪两个分数，比较简单，求出 <span class=\"math inline\">\\(\\frac{p}{q}\\)</span> 的 <span class=\"math inline\">\\(LR\\)</span> 串后模拟一下即可。</p>\n<p>对于树上问题，容易想到 LCA，那么考虑 Stern-Brocot 树上的两个点 <span class=\"math inline\">\\(\\frac{a}{b}, \\frac{c}{d}\\)</span>，怎么求出它们的 LCA？容易发现，找到 <span class=\"math inline\">\\(\\frac{a}{b}, \\frac{c}{d}\\)</span> 的 <span class=\"math inline\">\\(LR\\)</span> 串 <span class=\"math inline\">\\(F(\\frac{a}{c}), F(\\frac{c}{d})\\)</span>，它们 LCP 的长度就是它们 LCA 的深度；而这个长度是容易求的，然后它们的 LCA 就是这个 LCP 对应的节点，套用上面函数一下即可。</p>\n<p>同理，<span class=\"math inline\">\\(\\frac{p}{q}\\)</span> 的树上 <span class=\"math inline\">\\(k\\)</span> 级祖先也是可以算出 <span class=\"math inline\">\\(F(\\frac{p}{q})\\)</span> 后删掉末尾的 <span class=\"math inline\">\\(k\\)</span> 个字符后套用前面函数得出。</p>\n<p>显然单次时间复杂度都是 <span class=\"math inline\">\\(O(\\log w)\\)</span>，总时间复杂度为 <span class=\"math inline\">\\(O(T \\log w)\\)</span>。</p>\n<p><a href=\"https://www.luogu.com.cn/record/258759645\" rel=\"noopener nofollow\" target=\"_blank\">link</a></p>\n<h3 id=\"完整代码\">完整代码：</h3>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\n#define ls(k) k &lt;&lt; 1\n#define rs(k) k &lt;&lt; 1 | 1\n#define lowbit(x) x &amp; (-x)\n#define fi first\n#define se second\n#define popcnt(x) __builtin_popcount(x)\n#define open(s1, s2) freopen(s1, \"r\", stdin), freopen(s2, \"w\", stdout);\n#define mkp(x, y) make_pair(x, y)\nusing namespace std;\ntypedef __int128 __;\ntypedef long double lb;\ntypedef double db;\ntypedef unsigned long long ull;\ntypedef long long ll;\nbool Begin;\ninline ll read(){\n\tll x = 0, f = 1;\n\tchar c = getchar();\n\twhile(c &lt; '0' || c &gt; '9'){\n\t\tif(c == '-')\n\t\t\tf = -1;\n\t\tc = getchar();\n\t}\n\twhile(c &gt;= '0' &amp;&amp; c &lt;= '9'){\n\t\tx = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);\n\t\tc = getchar();\n\t}\n\treturn x * f;\n}\ninline void write(ll x){\n\tif(x &lt; 0){\n\t\tputchar('-');\n\t\tx = -x;\n\t}\n\tif(x &gt; 9)\n\t\twrite(x / 10);\n\tputchar(x % 10 + '0');\n}\ninline pair&lt;int, int&gt; getLR(vector&lt;pair&lt;char, int&gt;&gt; s){\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i].fi == 'L')\n\t\t\tm_ = s[i].se * m + m_, n_ = s[i].se * n + n_;\n\t\telse\n\t\t\tm = m + s[i].se * m_, n = n + s[i].se * n_;\n\t}\n\treturn mkp(m + m_, n + n_);\n}\ninline vector&lt;pair&lt;char, int&gt;&gt; backLR(int m, int n){\n\tvector&lt;pair&lt;char, int&gt;&gt; ans;\n\twhile(m &amp;&amp; n &amp;&amp; m != n){\n\t\tif(m &lt; n){\n\t\t\tif(n % m == 0)\n\t\t\t  ans.push_back({'L', n / m - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'L', n / m});\n\t\t\tn = n % m;\n\t\t}\n\t\telse{\n\t\t\tif(m % n == 0)\n\t\t\t  ans.push_back({'R', m / n - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'R', m / n});\n\t\t\tm = m % n;\n\t\t}\n\t}\n\treturn ans;\n}\ninline pair&lt;int, int&gt; getkfa(int m, int n, int k){\n\tauto V = backLR(m, n);\n\tint sum = 0, len = V.size();\n\tfor(int i = 0; i &lt; len; ++i)\n\t  sum += V[i].se;\n\tif(sum &lt; k)\n\t  return mkp(-1, -1);\n\tvector&lt;pair&lt;char, int&gt;&gt; fa;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(!k)\n\t\t  break;\n\t\tif(V[i].se &lt;= k){\n\t\t\tfa.push_back(V[i]);\n\t\t\tk -= V[i].se;\n\t\t}\n\t\telse{\n\t\t\tfa.push_back(mkp(V[i].fi, k));\n\t\t\tk = 0;\n\t\t}\n\t}\n\treturn getLR(fa);\n}\ninline pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt;&gt; range(int p, int q){\n\tauto s = backLR(p, q);\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i].fi == 'L')\n\t\t\tm_ = s[i].se * m + m_, n_ = s[i].se * n + n_;\n\t\telse\n\t\t\tm = m + s[i].se * m_, n = n + s[i].se * n_;\n\t}\n\treturn mkp(mkp(m, n), mkp(m_, n_));\n}\ninline pair&lt;int, int&gt; getlca(int a, int b, int c, int d){\n\tauto A = backLR(a, b), B = backLR(c, d);\n\tint s1 = 0, s2 = 0;\n\tfor(auto v : A)\n\t  s1 += v.se;\n\tfor(auto v : B)\n\t  s2 += v.se;\n\tif(s1 &lt; s2){\n\t\tswap(a, c), swap(b, d);\n\t\tswap(A, B);\n\t}\n\tvector&lt;pair&lt;char, int&gt;&gt; lca;\n\tint j = 0;\n\tfor(int i = 0; i &lt; (int)A.size(); ++i){\n\t\tint s = A[i].se;\n\t\twhile(j &lt; (int)B.size() &amp;&amp; s){\n\t\t\tif(B[j].fi != A[i].fi)\n\t\t\t  break;\n\t\t\tif(B[j].se &lt;= s){\n\t\t\t\ts -= B[j].se;\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[j].se -= s;\n\t\t\t\ts = 0;\n\t\t\t}\n\t\t}\n\t\tif(j == (int)B.size() || s){\n\t\t\tlca.push_back(mkp(A[i].fi, A[i].se - s));\n\t\t\tbreak;\n\t\t}\n\t\tlca.push_back(A[i]);\n\t}\n\treturn getLR(lca);\n}\nint T, a, b, c, d, p, q, len, x, k;\nchar C;\nchar op[20];\nint main(){\n\tT = read();\n\twhile(T--){\n\t\tscanf(\"%s\", op);\n\t\tif(op[0] == 'E'){\n\t\t\tp = read(), q = read();\n\t\t\tauto V = backLR(p, q);\n\t\t\twrite(V.size());\n\t\t\tputchar(' ');\n\t\t\tfor(auto t : V){\n\t\t\t\tputchar(t.fi);\n\t\t\t\tputchar(' ');\n\t\t\t\twrite(t.se);\n\t\t\t\tputchar(' ');\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(op[0] == 'D'){\n\t\t\tvector&lt;pair&lt;char, int&gt;&gt; V;\n\t\t\tlen = read();\n\t\t\twhile(len--){\n\t\t\t\tC = getchar();\n\t\t\t\tx = read();\n\t\t\t\tV.push_back({C, x});\n\t\t\t}\n\t\t\tauto t = getLR(V);\n\t\t\twrite(t.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se);\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(op[0] == 'L'){\n\t\t\ta = read(), b = read(), c = read(), d = read();\n\t\t\tauto t = getlca(a, b, c, d);\n\t\t\twrite(t.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se);\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(op[0] == 'A'){\n\t\t\tk = read(), a = read(), b = read();\n\t\t\tauto t = getkfa(a, b, k);\n\t\t\tif(t.fi &lt; 0){\n\t\t\t\tputs(\"-1\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twrite(t.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se);\n\t\t\tputchar('\\n');\t\t\t\n\t\t}\n\t\telse{\n\t\t\ta = read(), b = read();\n\t\t\tauto t = range(a, b);\n\t\t\twrite(t.fi.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.fi.se);\n\t\t\tputchar(' ');\t\n\t\t\twrite(t.se.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se.se);\n\t\t\tputchar('\\n');\t\n\t\t}\n\t}\n\treturn 0;\n}\n</code></pre>\n<h3 id=\"uva11350-stern-brocot-tree\"><a href=\"https://www.luogu.com.cn/problem/UVA11350\" rel=\"noopener nofollow\" target=\"_blank\">UVA11350 Stern-Brocot Tree</a></h3>\n<p><a href=\"https://www.luogu.com.cn/article/ol2ri7ez\" rel=\"noopener nofollow\" target=\"_blank\"><strong>洛谷同步题解。</strong></a></p>\n<p>模版这有，使用 <code>getLR</code> 即可。</p>\n<p><a href=\"https://www.luogu.com.cn/record/258771627\" rel=\"noopener nofollow\" target=\"_blank\">link</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 11:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rgw2010\">rgw2010</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "新书《鸿蒙HarmonyOS 6应用开发：从零基础到App上线》出版啦",
      "link": "https://www.cnblogs.com/aqi00/p/19504825",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19504825\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 11:23\">\n    <span>新书《鸿蒙HarmonyOS 6应用开发：从零基础到App上线》出版啦</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span><span>​</span></span><span id=\"cke_bm_160S\">基于最新鸿蒙系统的技术书籍《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》上市啦，要知道 HarmonyOS 6 在一个多月前的10月22日才正式发布，因此这本鸿蒙教程可谓贴近最新的 HarmonyOS 6 系统。</span>\n<p><span id=\"cke_bm_160S\"> 当前 HarmonyOS 6 的装机量迅猛增长，有望在春节前突破5000万台大关，可见鸿蒙系统的应用开发将越来越流行，甚至借助国产化的浪潮，未来在国内移动操作系统领域一举夺魁也不是不可能。<br />\n有鉴于此，博主精心编撰了 HarmonyOS 6 的应用开发教程《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》，从基础到高级，从理论到实战，从 UI 到 AI ，仅需一本书籍，即可让读者掌握鸿蒙应用的常见开发技能。</span></p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"鸿蒙应用开发\" class=\"lazyload\" height=\"436\" width=\"436\" /></span></span></span></span></p>\n<p>鸿蒙应用开发与安卓应用开发同为App开发，比如鸿蒙版微信和安卓版微信都是即时通信App，二者在实现技术上并无多少本质区别。所以《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》一书以《Android Studio开发实战：从零基础到App上线(第3版)》为蓝本，把安卓系统的App教程改造为鸿蒙系统的App教程，以便安卓开发者能够按图索骥迅速上手。欣喜的是，《Android Studio开发实战：从零基础到App上线(第3版)》提到的安卓开发技术，绝大部分都能在鸿蒙系统找到对应的平替技术，而且还是更简单的代码实现。<br />\n作为《Android Studio开发实战：从零基础到App上线(第3版)》一书的鸿蒙姊妹篇，《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》仍然采取了由浅入深、循序渐进的章节体例，其中前8章是基础部分，主要讲解 DevEco Studio 的环境搭建、ArkTS语言编程基础、鸿蒙App开发的各种常用组件、鸿蒙App开发的页面转场和消息交互、鸿蒙App的几种数据存储方式等；后8章是进阶部分，主要讲解鸿蒙App开发的后台任务、手势交互、动画特效、网络通信、多媒体、感知定位、人工智能、多端部署等。</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"android第三版\" class=\"lazyload\" height=\"439\" width=\"439\" /></span></span></span></span></p>\n<p>曾经有老读者咨询“从零基础到App上线”系列书籍的第4版何时面世，现在博主终于可以说，“从零基础到App上线”的第4版已经出版啦，而且第4版是鸿蒙版本的“从零基础到App上线”，它就叫做《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》，该书把安卓版教程平替为鸿蒙版教程，也是一个勇敢的尝试。<br />\n《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》在讲解知识点的同时给出了大量实战范例，方便读者迅速将所学的知识运用到实际开发中。通过本书的学习，读者能够掌握3类主流App的基本开发技术，包括购物App（电子商务）、聊天App（即时通信）、娱乐App（短视频分享）。另外，能够学会开发一些趣味应用，包括计算器、录音笔、电子相册、打牌游戏、指南针、水平仪、卫星浑天仪、登山助手、附近交友、速记助手、人脸识别等等。可见《Android Studio开发实战：从零基础到App上线(第3版)》一书提到的实战项目，本书基本提供了对应的鸿蒙版App。</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"鸿蒙系统\" class=\"lazyload\" height=\"237\" width=\"558\" /></span></span></span></span></p>\n<p>《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》的随书源码包括客户端部分和服务端部分，其中客户端的App代码基于 DevEco Studio 6.0.0 Release 开发，并使用 API 20 的 SDK （HarmonyOS 6.0.0）编译与调试通过，测试机型包括 Mate 60 Pro 和 nova 12 Pro 。配套的服务端源码采用 Java WEB 框架，结合 MySQL 数据库，并基于 IDEA 开发。<br />\n为了便于读者学习鸿蒙应用编程，《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》同时提供了随书源码和课件PPT，这些下载资源可以扫描该书前言末尾的二维码获得。最新的随书源码也可访问我的码云主页，下载页面是 https://gitee.com/aqi00/harmony 。</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 11:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">67</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "APEX实战第11篇：图形界面轻松解锁工作区账户",
      "link": "https://www.cnblogs.com/jyzhao/p/19524312/apex-shi-zhan-di11pian-tu-xing-jie-mian-qing-song",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jyzhao/p/19524312/apex-shi-zhan-di11pian-tu-xing-jie-mian-qing-song\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 00:21\">\n    <span>APEX实战第11篇：图形界面轻松解锁工作区账户</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2026-01-24 00:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jyzhao\">AlfredZhao</a>&nbsp;\n阅读(<span id=\"post_view_count\">61</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>APEX工作区的账户被锁定的原因基本都是因为该用户使用错误密码登录尝试的次数超过了安全限制。</p>\n<p>因为APEX为了账号的安全性考量，默认会有这样的安全策略设置：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202601/635610-20260124002157433-12653719.jpg\" /></p>\n<p>当然这个设置值是可以按需设置修改的，具体在这个地方：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202601/635610-20260124002157315-802019995.jpg\" /></p>\n<p>不过一般安全起见，也不建议去改太大，绝大多数场景还是默认就好。</p>\n<p>可如果因为哪位同事不小心尝试登录超出了安全限度，就会导致账号被锁定，此时也不必慌张，更不用去找具体命令，只要有权限登录 internal 的管理员在图形界面操作就可以顺利解锁账号，具体操作如下：</p>\n<p>首先需要管理员登录到 internal 的 Workspace，选择 <code>Manage Workspaces</code> -&gt; <code>Manage Developers and Users</code>，如下图所示：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202601/635610-20260124002157246-931642568.jpg\" /></p>\n<p>找到你被锁的具体 User，点击进去到下面这个界面，在 <code>Account Availability</code> 选择 <code>Unlocked</code> 解锁，<code>Apply Changes</code> 即可。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202601/635610-20260124002157361-181439318.jpg\" /></p>\n<p>操作完就可以退出 internal Workspace，登录自己的Workspace发现之前被锁定的账号已经可以正常登录了。</p>\n\n</div>\n<div id=\"MySignature\">\n    <a href=\"https://www.cnblogs.com/jyzhao/\" target=\"_blank\">AlfredZhao</a>©版权所有「从Oracle起航，领略精彩的IT技术。」<br />\n转载请注明原文链接：<a href=\"https://www.cnblogs.com/jyzhao/p/19524312/apex-shi-zhan-di11pian-tu-xing-jie-mian-qing-song\" target=\"_blank\">https://www.cnblogs.com/jyzhao/p/19524312/apex-shi-zhan-di11pian-tu-xing-jie-mian-qing-song</a>\n<hr />\n<div style=\"text-align: center; margin-top: 30px;\">\n  <p style=\"font-size: 14px; color: #555;\">\n    👋 感谢阅读，欢迎关注我的公众号 <b>「赵靖宇」</b>\n  </p>\n  <img src=\"https://images.cnblogs.com/cnblogs_com/jyzhao/824234/o_250208075013_qrcode-zjy.jpg\" style=\"border: 1px solid #ddd; border-radius: 8px;\" width=\"160\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第二周：词嵌入（五）GloVe 算法",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19524283",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19524283\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 23:59\">\n    <span>吴恩达深度学习课程五：自然语言处理  第二周：词嵌入（五）GloVe 算法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第二周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=170\" rel=\"noopener nofollow\" target=\"_blank\">2.8</a>的内容以及一些相关知识的补充。</p>\n<hr />\n<p>本周为第五课的第二周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本周的内容关于词嵌入，是一种<strong>相对于独热编码，更能保留语义信息的文本编码方式</strong>。通过词嵌入，模型不再只是“记住”词本身，而是能够<strong>基于语义关系进行泛化</strong>，在一定程度上实现类似“<strong>举一反三</strong>”的效果。词嵌入是 NLP 领域中最重要的基础技术之一。</p>\n<p>本篇的内容关于 <strong>GloVe 算法</strong>,是 Word2Vec 外，另一种以“全局”思想指导的词嵌入算法。</p>\n<h1 id=\"1-glove-算法思想\">1. GloVe 算法思想</h1>\n<p>在前面介绍 <a href=\"https://www.cnblogs.com/Goblinscholar/p/19504549\" target=\"_blank\">Word2Vec</a> 时，我们已经看到了一条非常清晰的学习路线：<strong>通过预测任务，让模型在训练中“顺便”学到词的向量表示</strong>。这种思路高效且直观，但也有一个绕不开的事实——它几乎完全依赖<strong>局部上下文</strong>。<br />\n这不难理解，在 Word2Vec 中，我们每次训练，都是使用<strong>窗口内的序列信息</strong>来学习相应的语义并更新词向量，每次更新只使用窗口内的词信息，词向量是在多次局部预测中逐步学习出来的。<br />\n由此，一个新的想法产生了：<strong>如果我们不只看窗口内的几步关系，而是把“整个语料里，词与词出现过多少次”都考虑进来，会发生什么？</strong></p>\n<p>GloVe 正是这一想法的产物。<br />\n在 2014 年，论文 <a href=\"https://aclanthology.org/D14-1162.pdf\" rel=\"noopener nofollow\" target=\"_blank\">GloVe: Global Vectors for Word Representation</a>被发表，论文认为<strong>词的语义信息，本质上蕴含在词与词的全局共现统计关系中，而词向量的任务，就是用一个低维连续空间去重现这种统计结构。</strong><br />\n最终，GloVe 将<strong>传统共现统计方法的全局视角</strong>，与<strong>分布式词向量的表达能力</strong>结合起来，形成了一种介于“计数方法”和“预测方法”之间的折中方案。<br />\n这里要专门说明的是，相比于传统神经网络，<strong>GloVe 没有隐藏层或激活函数</strong>，更像是一条通过词向量内积加偏置构成的<strong>线性计算流水线</strong>，但它仍然使用梯度下降来更新参数，实现对共现统计信息的拟合，我们很难用模型那一套来描述它，因此也相对较难理解。<br />\n下面就来分点展开 GloVe 算法的实现逻辑：</p>\n<h1 id=\"2-glove-算法的统计部分\">2. GloVe 算法的统计部分</h1>\n<p>GloVe 算法 的起手其实是传统的共现统计方法，<strong>这一部分并不涉及模型训练，而是对数据进行统计和处理，得到词汇间的全局关系。</strong><br />\n依旧分点来看这部分内容：</p>\n<h2 id=\"21-统计词共现矩阵\">2.1 统计词共现矩阵</h2>\n<p><strong>词共现矩阵</strong> 是传统统计方法里的基础概念，顾名思义，它是用来<strong>表示词与词之间共现关系的矩阵</strong>。</p>\n<p>规范一下，设词表大小为 <span class=\"math inline\">\\(V\\)</span>，定义一个矩阵 <span class=\"math inline\">\\(X \\in \\mathbb{R}^{V \\times V}\\)</span>，其中：</p>\n<p></p><div class=\"math display\">\\[X_{ij} = \\text{词 } j \\text{ 出现在词 } i \\text{ 上下文中的次数}  \n\\]</div><p></p><p>简单举个例子，假设语料只有一句话：</p>\n<blockquote>\n<p>I like deep learning</p>\n</blockquote>\n<p>显然，词表为：</p>\n<p></p><div class=\"math display\">\\[\\{\\text{I},\\ \\text{like},\\ \\text{deep},\\ \\text{learning}\\}  \n\\]</div><p></p><p>现在，设定<strong>上下文窗口大小为 1</strong>，即只考虑左右各一个词。<br />\n我们统计各词的共性关系如下：</p>\n<ol>\n<li>以 <strong>I</strong> 为中心：上下文只有 <em>like</em></li>\n<li>以 <strong>like</strong> 为中心：上下文是 <em>I</em> 和 <em>deep</em></li>\n<li>以 <strong>deep</strong> 为中心：上下文是 <em>like</em> 和 <em>learning</em></li>\n<li>以 <strong>learning</strong> 为中心：上下文只有 <em>deep</em></li>\n</ol>\n<p>由此，我们可以得到完整的词共现矩阵 <span class=\"math inline\">\\(X\\)</span>：</p>\n<p></p><div class=\"math display\">\\[X =\n\\begin{array}{c|cccc}\n &amp; \\text{I} &amp; \\text{like} &amp; \\text{deep} &amp; \\text{learning} \\\\\n\\hline\n\\text{I}        &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\\n\\text{like}     &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\\\\n\\text{deep}     &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\\\\n\\text{learning} &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\\n\\end{array}\n\\]</div><p></p><p>补充几点细节：</p>\n<ol>\n<li>在常见的统计设定中，通常<strong>手工设定</strong>不将词与自身计入共现关系，因此<strong>共现矩阵的对角线往往为 0</strong>，但在真实语料中，若相同词在窗口范围内连续出现，则对应的对角元素也可能为非零值。</li>\n<li>词共现矩阵往往是<strong>高度稀疏的</strong>，大多数词对在语料中根本不会共现。</li>\n<li><strong>词共现矩阵是否对称，取决于设计的统计方式</strong>，在对称窗口下，这里的 <span class=\"math inline\">\\(X\\)</span> 是对称的，若区分左右上下文，矩阵则不一定对称。</li>\n</ol>\n<p>由此，我们就完成了 GloVe 算法在统计部分的第一步。<br />\n下一步，我们会<strong>把共现次数 <span class=\"math inline\">\\(X_{ij}\\)</span> 转化为条件概率 <span class=\"math inline\">\\(P(j|i)\\)</span></strong>，进一步引入向量训练的目标。</p>\n<h2 id=\"22-统计条件概率-\">2.2 统计条件概率 <span class=\"math inline\">\\(P(j \\mid i)\\)</span></h2>\n<p>在完成共现矩阵统计后，GloVe 的下一步是把<strong>绝对共现次数</strong>转化为<strong>条件概率</strong>，从而刻画词与词之间更直观的关系。<br />\n我们定义条件概率为：</p>\n<p></p><div class=\"math display\">\\[P(j \\mid i) = \\frac{X_{ij}}{\\sum_k X_{ik}}  \n\\]</div><p></p><p>其中：</p>\n<ul>\n<li><span class=\"math inline\">\\(X_{ij}\\)</span> 是词 <span class=\"math inline\">\\(j\\)</span> 出现在词 <span class=\"math inline\">\\(i\\)</span> 上下文中的次数，来自词共现矩阵。</li>\n<li><span class=\"math inline\">\\(\\sum_k X_{ik}\\)</span> 是以词 <span class=\"math inline\">\\(i\\)</span> 为中心时，所有上下文词出现次数的总和</li>\n</ul>\n<p><strong>最终，<span class=\"math inline\">\\(P(j \\mid i)\\)</span> 表示在语料库中，已知中心词为 <span class=\"math inline\">\\(i\\)</span> 的前提下，上下文词为 <span class=\"math inline\">\\(j\\)</span> 的经验概率。</strong></p>\n<p>我们继续使用上一节中的例子，根据共现矩阵：</p>\n<p></p><div class=\"math display\">\\[X =\n\\begin{array}{c|cccc}\n &amp; \\text{I} &amp; \\text{like} &amp; \\text{deep} &amp; \\text{learning} \\\\\n\\hline\n\\text{I}        &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\\n\\text{like}     &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\\\\n\\text{deep}     &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\\\\n\\text{learning} &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\\n\\end{array}\n\\]</div><p></p><p>我们可以计算条件概率，例如：</p>\n<ol>\n<li>以 <strong>like</strong> 为中心：</li>\n</ol>\n<p></p><div class=\"math display\">\\[\\sum_k X_{\\text{like},k} = 1 + 0 + 1 + 0 = 2  \n\\]</div><p></p><p>于是：</p>\n<p></p><div class=\"math display\">\\[P(\\text{I} \\mid \\text{like}) = \\frac{1}{2} = 0.5, \\quad  \nP(\\text{deep} \\mid \\text{like}) = \\frac{1}{2} = 0.5  \n\\]</div><p></p><ol start=\"2\">\n<li>以 <strong>I</strong> 为中心：</li>\n</ol>\n<p></p><div class=\"math display\">\\[\\sum_k X_{\\text{I},k} = 0 + 1 + 0 + 0 = 1  \n\\]</div><p></p><p>所以：</p>\n<p></p><div class=\"math display\">\\[P(\\text{like} \\mid \\text{I}) = 1  \n\\]</div><p></p><p><strong>最终，通过这种方式，我们就得到了语料库中每个词的上下文概率分布。</strong><br />\n我们整理例子的概率分布矩阵如下：</p>\n<p></p><div class=\"math display\">\\[P =  \n\\begin{array}{c|cccc}  \n&amp; \\text{I} &amp; \\text{like} &amp; \\text{deep} &amp; \\text{learning} \\\\  \n\\hline  \n\\text{I} &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\\n\\text{like} &amp; 0.5 &amp; 0 &amp; 0.5 &amp; 0 \\\\  \n\\text{deep} &amp; 0 &amp; 0.5 &amp; 0 &amp; 0.5 \\\\  \n\\text{learning} &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\  \n\\end{array}  \n\\]</div><p></p><p>其中：</p>\n<ul>\n<li><strong>行表示中心词 <span class=\"math inline\">\\(i\\)</span></strong></li>\n<li><strong>列表示上下文词 <span class=\"math inline\">\\(j\\)</span></strong></li>\n<li><strong>每个元素 <span class=\"math inline\">\\(P_{ij}\\)</span></strong> 即为 <span class=\"math inline\">\\(P(j|i)\\)</span></li>\n</ul>\n<p>自此，我们就完成了GloVe 算法在统计部分的全部内容。<br />\n下面，就是它的建模部分。</p>\n<h1 id=\"3-glove-算法的模型部分\">3. GloVe 算法的模型部分</h1>\n<p>在完成统计阶段后，我们得到了全局的共现信息及概率分布。<strong>模型部分的核心任务</strong>就是：利用这些统计信息训练出词向量，使得词向量能够<strong>反映词与词之间的语义关系</strong>。</p>\n<p>GloVe 的核心思想可以概括为一句话：<strong>词向量的内积应该能够拟合词与词之间的共现概率</strong>。<br />\n我们依旧分点来进行这部分内容：</p>\n<h2 id=\"31-计算概率比例\">3.1 计算概率比例</h2>\n<p>首先，GloVe 并不直接去拟合条件概率 <span class=\"math inline\">\\(P(j|i)\\)</span>，而是利用<strong>概率比例</strong>刻画语义关系。<br />\n设有中心词 <span class=\"math inline\">\\(i\\)</span>，上下文词 <span class=\"math inline\">\\(j\\)</span> 和 <span class=\"math inline\">\\(k\\)</span>，则概率比例如下：</p>\n<p></p><div class=\"math display\">\\[\\frac{P(j \\mid i)}{P(k \\mid i)}  \n\\]</div><p></p><p>这并不难理解：</p>\n<ul>\n<li>如果比例大，说明 <span class=\"math inline\">\\(i\\)</span> 更倾向于与 <span class=\"math inline\">\\(j\\)</span> 一起出现。</li>\n<li>如果比例小，说明 <span class=\"math inline\">\\(i\\)</span> 更倾向于与 <span class=\"math inline\">\\(k\\)</span> 一起出现。</li>\n</ul>\n<p>继续使用同样的例子，我们刚刚得到条件概率矩阵如下：</p>\n<p></p><div class=\"math display\">\\[P =  \n\\begin{array}{c|cccc}  \n&amp; \\text{I} &amp; \\text{like} &amp; \\text{deep} &amp; \\text{learning} \\\\  \n\\hline  \n\\text{I} &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\  \n\\text{like} &amp; 0.5 &amp; 0 &amp; 0.5 &amp; 0 \\\\  \n\\text{deep} &amp; 0 &amp; 0.5 &amp; 0 &amp; 0.5 \\\\  \n\\text{learning} &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\  \n\\end{array}  \n\\]</div><p></p><p>对于中心词 <strong>like</strong>，其上下文词分别为 <strong>I</strong> 和 <strong>deep</strong>，则：</p>\n<p></p><div class=\"math display\">\\[\\frac{P(\\text{I} \\mid \\text{like})}{P(\\text{deep} \\mid \\text{like})} = \\frac{0.5}{0.5} = 1  \n\\]</div><p></p><p>这个比例表示，“like”与“I”和“deep”的关系<strong>同样强</strong>。<br />\n换句话说，如果模型想拟合这个关系，词向量在空间中的表现应该让 <strong>like-I</strong> 与 <strong>like-deep</strong> 的内积接近。</p>\n<p>而如果概率比例不是 1，例如假设在更大语料中统计到：</p>\n<p></p><div class=\"math display\">\\[P(\\text{I} \\mid \\text{like}) = 0.3, \\quad P(\\text{deep} \\mid \\text{like}) = 0.6  \n\\]</div><p></p><p>则比例为：</p>\n<p></p><div class=\"math display\">\\[\\frac{P(\\text{I} \\mid \\text{like})}{P(\\text{deep} \\mid \\text{like})} = \\frac{0.3}{0.6} = 0.5  \n\\]</div><p></p><p>这个比例小于 1，说明“like”<strong>更倾向于与 deep 一起出现</strong>，与 I 的关联较弱。模型训练时，GloVe 就会尝试让词向量 <strong>like-deep</strong> 的内积大于 <strong>like-I</strong> 的内积，以反映这种强弱关系。</p>\n<p>这一步，我们通过比例概率实现了对语义的量化，而下一步就是 GloVe 的核心内容：</p>\n<h2 id=\"32-构建向量关系\">3.2 构建向量关系</h2>\n<p>在这一步，GloVe 就可以将概率比例量化的<strong>语义偏好</strong>转化为<strong>向量空间中的相对位置</strong>，从而实现统计信息到词向量的映射。<br />\n换句话说，我们希望通过训练得到的词向量，使得在向量空间中，中心词与上下文词的相对位置<strong>能够反映它们在语料中的共现强弱</strong>。<br />\n来看看 GloVe 实现这一步的具体逻辑：</p>\n<p>首先，设定：</p>\n<ol>\n<li><strong>中心词</strong> <span class=\"math inline\">\\(i\\)</span> 的词向量为 <span class=\"math inline\">\\(w_i \\in \\mathbb{R}^d\\)</span></li>\n<li><strong>上下文词</strong> <span class=\"math inline\">\\(j,k\\)</span> 的词向量为 <span class=\"math inline\">\\(\\tilde w_j, \\tilde w_k \\in \\mathbb{R}^d\\)</span></li>\n</ol>\n<p>GloVe 通过以下假设将概率比例与向量联系起来：</p>\n<p></p><div class=\"math display\">\\[F(w_i, \\tilde w_j, \\tilde w_k) = \\frac{P(j \\mid i)}{P(k \\mid i)}  \n\\]</div><p></p><p>其中函数 <span class=\"math inline\">\\(F\\)</span> 的含义是：<strong>用向量操作去表示概率比例，模型的目标就是拟合这个函数 <span class=\"math inline\">\\(F\\)</span> 。</strong></p>\n<p>也就是说，我们的目标是：</p>\n<p></p><div class=\"math display\">\\[\\frac{P(j \\mid i)}{P(k \\mid i)} \\approx {\\text{模型预测的某个函数值}}{}  \n\\]</div><p></p><p><strong>但是，直接拟合比例本身有几个问题</strong>：</p>\n<ol>\n<li><strong>比例范围广</strong>：条件概率 <span class=\"math inline\">\\(P(j|i)\\)</span> 属于 <span class=\"math inline\">\\([0,1]\\)</span>，两个概率比值可能非常大或非常小（比如 <span class=\"math inline\">\\(0.001/0.5 = 0.002\\)</span>），直接拟合容易数值不稳定。</li>\n<li><strong>向量空间线性映射困难</strong>：我们希望用向量内积（<span class=\"math inline\">\\(w_i^\\top \\tilde w_j\\)</span>）表示关系，但向量内积是线性且可正可负，而概率比总是正且变化范围大，直接用内积去拟合会很不直观，也容易数值不稳定。</li>\n</ol>\n<p>所以我们需要一个<strong>桥梁函数</strong>，把比例转换成更适合线性建模的形式。</p>\n<h2 id=\"33-转换概率比例\">3.3 转换概率比例</h2>\n<p>在这里，GloVe 选择了 <strong>对数函数</strong>，把比例变成 <strong>内积差</strong>：</p>\n<p></p><div class=\"math display\">\\[\\log \\frac{P(j \\mid i)}{P(k \\mid i)} =\\log P(j|i) - \\log P(k|i) \\approx (w_i^\\top \\tilde w_j + b_i + \\tilde b_j) - (w_i^\\top \\tilde w_k + b_i + \\tilde b_k)\n\\]</div><p></p><p>我们来详细解释一下这步推导的逻辑：</p>\n<ol>\n<li><strong>对数的作用</strong>:<br />\n对数函数可以把原本范围很广的正数概率比压缩到数值更稳定的区间，并且把<strong>乘法关系转化为加法关系</strong>。数值范围收敛，更利于模型学习，同时便于线性处理。</li>\n<li><strong>对映射的影响</strong>：<br />\n取了对数之后，原本的比例关系就转化为“加减法”的形式，而向量内积本身就是线性可加的操作（<span class=\"math inline\">\\(w_i^\\top \\tilde w_j\\)</span> 是实数线性组合）。对数后的比例差可以直接用 <strong>线性模型</strong>（内积加偏置）来拟合，保证概率比越大，内积差越大；概率比越小，内积差越小。</li>\n<li><strong>偏置项的作用</strong> ：<br />\n偏置项 <span class=\"math inline\">\\(b_i, \\tilde b_j\\)</span> 用于<strong>捕捉词自身的出现频率差异</strong>。<br />\n高频词往往在语料中出现次数多，直接用向量内积可能被整体频率影响而偏离比例。<br />\n偏置项可以单独调整每个词的基准水平，让向量内积专注于<strong>词与词之间的相对关系</strong>，而不受词频本身干扰。</li>\n</ol>\n<p>最终，我们通过公式实现了这样的作用：</p>\n<p></p><div class=\"math display\">\\[\\text{概率比例（统计信息）} \\xrightarrow{\\log} \\text{线性可加的形式} \\xrightarrow{\\text{内积+偏置}} \\text{向量表示拟合目标}  \n\\]</div><p></p><p>回到例子，假设在某大语料中统计到：</p>\n<p></p><div class=\"math display\">\\[P(\\text{I} \\mid \\text{like}) = 0.3, \\quad P(\\text{deep} \\mid \\text{like}) = 0.6  \n\\]</div><p></p><p>则：</p>\n<p></p><div class=\"math display\">\\[\\log \\frac{P(\\text{I} \\mid \\text{like})}{P(\\text{deep} \\mid \\text{like})} = \\log 0.5 \\approx -0.693  \n\\]</div><p></p><p>因此，模型希望通过训练得到的向量，使得：</p>\n<p></p><div class=\"math display\">\\[(w_\\text{like}^\\top \\tilde w_\\text{I} + b_\\text{like} + \\tilde b_\\text{I}) - (w_\\text{like}^\\top \\tilde w_\\text{deep} + b_\\text{like} + \\tilde b_\\text{deep}) \\approx -0.693  \n\\]</div><p></p><p>这样，训练后，词向量在空间中，“like” 会更靠近 “deep”，远离 “I”，以反映概率比例。</p>\n<p>下面就是最后一步了：</p>\n<h2 id=\"34-构建损失函数并训练\">3.4 构建损失函数并训练</h2>\n<p>在完成概率比例到向量内积映射后，GloVe 还需要一个<strong>可优化的损失函数</strong>来让训练可执行。<br />\n这一步的思想是：<strong>让向量内积（加偏置）尽量逼近对数共现概率</strong>，同时对高频和低频词对做合理的权衡。</p>\n<p>GloVe 的损失函数定义为：</p>\n<p></p><div class=\"math display\">\\[J = \\sum_{i,j=1}^{V} f(X_{ij}) \\left( w_i^\\top \\tilde w_j + b_i + \\tilde b_j - \\log X_{ij} \\right)^2  \n\\]</div><p></p><p>看起来很复杂，实际上也不简单，我们详细解释一下各部分含义：</p>\n<ol>\n<li>\n<p><strong>权重函数 <span class=\"math inline\">\\(f(X_{ij})\\)</span></strong>：<br />\n为了平衡高频和低频词对的影响，GloVe 引入了一个加权函数：</p>\n<p></p><div class=\"math display\">\\[   f(x) =\n   \\begin{cases} \n   \\left(\\dfrac{x}{x_\\text{max}}\\right)^\\alpha, &amp; x &lt; x_\\text{max} \\\\\n   1, &amp; x \\ge x_\\text{max}\n   \\end{cases}\n\\]</div><p></p><p>这里 <span class=\"math inline\">\\(x_\\text{max}\\)</span> 是阈值，<span class=\"math inline\">\\(\\alpha\\)</span> 通常取 <span class=\"math inline\">\\(0.75\\)</span>。<br />\n这是为了让高频词对不会主导训练，低频词对仍有一定权重。</p>\n</li>\n<li>\n<p><strong><span class=\"math inline\">\\(w_i^\\top \\tilde w_j + b_i + \\tilde b_j\\)</span></strong>  ：模型预测的对数共现次数，即词向量加偏置的线性组合。</p>\n</li>\n<li>\n<p><strong><span class=\"math inline\">\\(\\log X_{ij}\\)</span></strong>  ：对应统计信息的对数共现次数，是我们希望模型逼近的目标。</p>\n</li>\n<li>\n<p><strong>平方误差 <span class=\"math inline\">\\((\\cdot)^2\\)</span></strong>  ：衡量预测值与目标值之间的差距，使模型通过梯度下降最小化误差。</p>\n</li>\n</ol>\n<p>这里就可以解释我们<a href=\"https://www.cnblogs.com/Goblinscholar/p/19494158\" target=\"_blank\">在本周第一篇</a>中留下的问题：<strong>词向量的长度受什么影响？</strong><br />\n因为高频词在语料中出现次数多，因此它的共现矩阵行/列上的元素整体偏大，经过训练后，模型为了尽量逼近 <span class=\"math inline\">\\(\\log X_{ij}\\)</span>，会使得这些高频词的向量内积整体偏大，从而对应的向量长度也相对较长。<br />\n<strong>也就是说，词向量的长度与词频正相关，但本身没有其他明确的语义解释，只是统计特性导致的结果。</strong></p>\n<p>同时，在这里你可能会有一个问题：<strong>我们刚刚引入了概率比例和内积差的关系，为什么损失函数里都没有用到？</strong><br />\n实际上，对某个中心词 <span class=\"math inline\">\\(i\\)</span>，任意两个上下文词 <span class=\"math inline\">\\(j,k\\)</span>，若你看损失梯度，会发现：<br />\n在优化过程中，梯度会自然调整 <span class=\"math inline\">\\(w_i\\)</span>，让 <strong>共现次数更多、概率大的词对应内积更大，共现次数更少、概率小的词对应内积更小</strong>。<br />\n换句话说，<strong>比例关系会通过梯度自动体现出来</strong>，不需要显式算比值，并且这样还避免了显式计算所有词对之间的概率比造成的计算开销。</p>\n<p>还是用我们的例子，假设在大语料中：</p>\n<table>\n<thead>\n<tr>\n<th>中心词</th>\n<th>上下文词</th>\n<th>共现次数 <span class=\"math inline\">\\(X_{ij}\\)</span></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>like</td>\n<td>I</td>\n<td>3</td>\n</tr>\n<tr>\n<td>like</td>\n<td>deep</td>\n<td>6</td>\n</tr>\n</tbody>\n</table>\n<p>则训练目标：</p>\n<ol>\n<li>对 <strong>like-I</strong>：\n<ul>\n<li>目标 <span class=\"math inline\">\\(\\log X_{\\text{like,I}} = \\log 3 \\approx 1.099\\)</span></li>\n<li>模型希望 <span class=\"math inline\">\\(w_\\text{like}^\\top \\tilde w_\\text{I} + b_\\text{like} + \\tilde b_\\text{I} \\approx 1.099\\)</span></li>\n</ul>\n</li>\n<li>对 <strong>like-deep</strong>：\n<ul>\n<li>目标 <span class=\"math inline\">\\(\\log X_{\\text{like,deep}} = \\log 6 \\approx 1.792\\)</span></li>\n<li>模型希望 <span class=\"math inline\">\\(w_\\text{like}^\\top \\tilde w_\\text{deep} + b_\\text{like} + \\tilde b_\\text{deep} \\approx 1.792\\)</span></li>\n</ul>\n</li>\n<li>权重函数 <span class=\"math inline\">\\(f(X_{ij})\\)</span> 可以调节两者在训练中的影响，使模型更稳健。</li>\n</ol>\n<p>训练时，GloVe <strong>会遍历所有有共现的词对</strong>，计算加权平方误差，利用梯度下降优化 <span class=\"math inline\">\\(w_i, \\tilde w_j, b_i, \\tilde b_j\\)</span>，直到误差收敛。<br />\n最后，你会发现，GloVe 的整个传播过程同时在维护两个词向量矩阵：</p>\n<ol>\n<li><strong>中心词向量 <span class=\"math inline\">\\(w_i\\)</span></strong></li>\n<li><strong>上下文词向量 <span class=\"math inline\">\\(\\tilde w_j\\)</span></strong><br />\n而通常，我们将两者相加或平均作为最终词向量：</li>\n</ol>\n<p></p><div class=\"math display\">\\[v_i = w_i + \\tilde w_i  \n\\]</div><p></p><p>这样得到的 <span class=\"math inline\">\\(v_i\\)</span> 便同时存在作为中心词和上下文词的语义距离，刻画了词与词之间的全局共现关系。</p>\n<h1 id=\"4-总结\">4. 总结</h1>\n<p>因为 GloVe 相比起来较为复杂，这里我们不再表格整理概念了，而是<strong>整体梳理一遍其传播过程</strong>。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260123235856508-1491140111.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-23 23:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">57</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "STM32之控制变量与函数的存储位置",
      "link": "https://www.cnblogs.com/lsksp/p/19527780",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lsksp/p/19527780\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 23:01\">\n    <span>STM32之控制变量与函数的存储位置</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        STM32 内存定位是优化系统性能、解决硬件兼容性问题的核心技巧，可解决 Cache 与 DMA 冲突、利用 ITCM/DTCM 提升访问速度、固定 DMA 缓冲区到合规的连续物理内存。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"stm32之控制变量与函数的存储位置\">STM32之控制变量与函数的存储位置</h1>\n<p>STM32 内存定位是优化系统性能、解决硬件兼容性问题的核心技巧，可解决 Cache 与 DMA 冲突、利用 ITCM/DTCM 提升访问速度、固定 DMA 缓冲区到合规的连续物理内存。</p>\n<h2 id=\"一变量定位方法\">一、变量定位方法</h2>\n<p>变量定位分两种方式，适配「单个变量精准定位」和「批量变量管理」场景。</p>\n<h3 id=\"方法-1attribute--内存地址单个变量\">方法 1：<strong>attribute</strong> + 内存地址（单个变量）</h3>\n<p>利用编译器<code>__attribute__((at(address)))</code>属性，直接绑定变量到指定地址，简单高效。</p>\n<pre><code class=\"language-c\">// 示例：uint32_t数组定位到0x20001000（4字节对齐）\n__ALIGNED(4) __attribute__((at(0x20001000))) uint32_t dma_buffer[1024] = {0};\n</code></pre>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>地址需在芯片有效内存范围，否则触发硬件故障；</li>\n<li>满足数据对齐要求（char=1 字节、short=2 字节、int/float=4 字节、double=8 字节）；</li>\n<li>避免与系统变量 / 栈 / 堆地址重叠（可查.map 文件确认）。</li>\n</ul>\n<h3 id=\"方法-2attribute--段名--分散加载文件批量变量\">方法 2：<strong>attribute</strong> + 段名 + 分散加载文件（批量变量）</h3>\n<p>批量定位多变量时，通过「自定义段名 + 分散加载文件」实现统一管理。</p>\n<h4 id=\"1-定义带自定义段名的变量\">1. 定义带自定义段名的变量</h4>\n<pre><code class=\"language-c\">// 多DMA缓冲区归类到\"MY_DMA_BUFFER\"段\n__attribute__((section(\"MY_DMA_BUFFER\"))) uint32_t uart_dma_buf[512] = {0};\n__attribute__((section(\"MY_DMA_BUFFER\"))) uint8_t i2c_dma_buf[256] = {0};\n</code></pre>\n<h4 id=\"2-修改分散加载文件sct\">2. 修改分散加载文件（.sct）</h4>\n<pre><code class=\"language-assembly\">; STM32内存定位示例 - 分散加载文件\nLR_IROM1 0x08000000 0x00020000  {      ; Flash加载区：0x08000000~0x08020000\n    ER_IROM1 0x08000000 0x00020000  {  ; Flash执行区\n        *.o (RESET, +First)\n        *(InRoot$$Sections)\n        .ANY (+RO)\n        .ANY (+XO)\n    }\n    RW_IRAM1 0x20000000 0x00020000  {  ; 普通SRAM数据区：0x20000000~0x20020000\n        .ANY (+RW +ZI)\n    }\n    ; 自定义DMA缓冲区段：0x20005000~0x20008000（12KB）\n    RW_DMA_BUFFER 0x20005000 0x00003000  {\n        *.o (MY_DMA_BUFFER)            ; 映射MY_DMA_BUFFER段到该区域\n    }\n}\n</code></pre>\n<h2 id=\"二函数定位方法\">二、函数定位方法</h2>\n<p>核心是将高频函数放到 ITCM 等高速内存提升执行速度，逻辑与变量类似，需映射到「执行区域」。</p>\n<h3 id=\"1-单个函数定位\">1. 单个函数定位</h3>\n<p>通过<code>__attribute__((section(\"段名\")))</code>标注函数，修改分散加载文件映射到 ITCM（以 STM32H7 的 ITCM=0x00000000 为例）。</p>\n<h4 id=\"1定义带段名的函数\">（1）定义带段名的函数</h4>\n<pre><code class=\"language-c\">// PID函数归类到MY_FUNC_SECTION段\n__attribute__((section(\"MY_FUNC_SECTION\"))) float pid_calc(float target, float current)\n{\n    static float err = 0, err_last = 0;\n    float kp = 1.2, ki = 0.1, kd = 0.05;\n    err = target - current;\n    float output = kp*err + ki*(err+err_last) + kd*(err-err_last);\n    err_last = err;\n    return output;\n}\n</code></pre>\n<h4 id=\"2修改分散加载文件\">（2）修改分散加载文件</h4>\n<pre><code class=\"language-assembly\">; 含函数定位的分散加载文件\nLR_IROM1 0x08000000 0x00020000  {      ; Flash加载区\n    ER_IROM1 0x08000000 0x00020000  {  ; Flash执行区\n        *.o (RESET, +First)\n        *(InRoot$$Sections)\n        .ANY (+RO)\n        .ANY (+XO)\n    }\n    RW_IRAM1 0x20000000 0x00020000  {  ; 普通SRAM数据区\n        .ANY (+RW +ZI)\n    }\n    ; ITCM执行区：0x00000000~0x00010000（64KB）\n    ER_ITCM 0x00000000 0x00010000  {\n        *.o (MY_FUNC_SECTION)          ; 映射函数段到ITCM\n    }\n}\n</code></pre>\n<h3 id=\"2-批量函数定位\">2. 批量函数定位</h3>\n<p>将整个.c 文件的函数定位到指定区域，两种方式：</p>\n<ul>\n<li>\n<p>编译器选项（ARMCC）：添加<code>--section=.text:MY_FUNC_SECTION</code>；</p>\n</li>\n<li>\n<p>分散加载文件直接指定文件：</p>\n<pre><code class=\"language-assembly\">ER_ITCM 0x00000000 0x00010000  {\n    pid.o (+XO)  ; pid.c所有可执行代码放到ITCM\n}\n</code></pre>\n</li>\n</ul>\n<h3 id=\"3-验证方法\">3. 验证方法</h3>\n<p>编译后打开工程<code>Output</code>文件夹的.map 文件，搜索函数名（如<code>pid_calc</code>），查看<code>Base Address</code>是否为 ITCM 起始地址（如 0x00000000 开头），确认定位成功。</p>\n<h2 id=\"三实战技巧与注意事项\">三、实战技巧与注意事项</h2>\n<h3 id=\"1-内存区域选择策略\">1. 内存区域选择策略</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">内存类型</th>\n<th style=\"text-align: center;\">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">DTCM</td>\n<td style=\"text-align: center;\">高频访问的全局变量（零等待周期）</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">ITCM</td>\n<td style=\"text-align: center;\">关键函数、中断服务程序</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">AXI SRAM</td>\n<td style=\"text-align: center;\">大容量 DMA 缓冲区</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">普通 SRAM</td>\n<td style=\"text-align: center;\">通用变量存储</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-缓存一致性处理\">2. 缓存一致性处理</h3>\n<p>使用 Cache 时，DMA 操作需保证缓存一致性：</p>\n<pre><code class=\"language-c\">// DMA发送前清理缓存\nSCB_CleanDCache_by_Addr(dma_buffer, sizeof(dma_buffer));\n\n// DMA接收后失效缓存\nSCB_InvalidateDCache_by_Addr(dma_buffer, sizeof(dma_buffer));\n</code></pre>\n<h3 id=\"3-核心注意事项\">3. 核心注意事项</h3>\n<ul>\n<li>地址越界：定位地址需匹配芯片内存范围，否则程序跑飞（核对芯片手册）；</li>\n<li>对齐错误：函数入口地址需 4 字节对齐，否则触发 HardFault 中断；</li>\n<li>Cache 一致性：Cache 区数据 / DMA 访问前需刷新缓存，避免数据错乱；</li>\n<li>段冲突：自定义段勿与系统段重叠，编译溢出需调整分散加载文件地址 / 大小。</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>STM32 内存定位是解决性能与兼容性问题的关键技能：</p>\n<ol>\n<li>变量可通过<code>__attribute__((at(地址)))</code>（单个）或段名 + 分散加载文件（批量）定位；</li>\n<li>函数需标注自定义段名，映射到 ITCM 等高速内存，通过.map 文件验证；</li>\n<li>需规避地址越界、对齐错误等问题，合理选择内存区域并处理缓存一致性。</li>\n</ol>\n<p>掌握该技术可显著提升 STM32 系统性能与可靠性，是嵌入式开发者进阶的必备技能。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 23:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lsksp\">比特向阳</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2026 年，macbook air 2015 升级注意事项",
      "link": "https://www.cnblogs.com/V1haoge/p/19527675",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/V1haoge/p/19527675\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 22:13\">\n    <span>2026 年，macbook air 2015 升级注意事项</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近看到 macbook air 2015 可以升级 m.2硬盘，随买了 SN570 ，容量 1T，为了升级耗费了好多天，试了好多坑，现在把这几个坑记录下</p>\n<h3 id=\"1-制作-macos-按照-u盘\">1. 制作 macos 按照 U盘</h3>\n<ul>\n<li>1.1 容量大于16G的好U盘</li>\n<li>1.2 关闭 WIFI</li>\n<li>1.3 使用磁盘工具抹除 U 盘，名称随便起 （我起的是 haoge）格式选：Mac OS扩展（日志式）方案：GUID 分区图</li>\n<li>1.4 打开终端 执行命令：<br />\n<code>sudo date 060100002023</code></li>\n<li>1.5 制作 U 盘命令：<br />\n<code>sudo /Applications/Install\\ macOS\\ Monterey.app/Contents/Resources/createinstallmedia --volume /Volumes/haoge</code>\n<ul>\n<li>Monterey  是我安装的系统版本名称</li>\n<li>haoge  是我的 U 盘名称</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-安装新硬盘\">2. 安装新硬盘</h3>\n<h3 id=\"3-重装系统\">3. 重装系统</h3>\n<ul>\n<li>3.1 开机同时按住 option 按键，直到打开选择磁盘的界面</li>\n<li>3.2 现选磁盘工具进行新硬盘的抹除操作，名称 随便起  格式选择 APFS  方案：GUID 分区图（可能没方案选项）</li>\n<li>3.3 关闭 WIFI</li>\n<li>3.4 打开终端 执行命令：<br />\n<code>date 060100002023</code></li>\n<li>3.5 然后就是安装系统了，一步一步走就行</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 22:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/V1haoge\">唯一浩哥</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}