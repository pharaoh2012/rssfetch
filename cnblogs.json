{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "Web攻防-验证码安全篇&接口滥用&识别插件&复用绕过",
      "link": "https://www.cnblogs.com/Kurisu-Christina/p/19399846",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Kurisu-Christina/p/19399846\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 16:20\">\n    <span>Web攻防-验证码安全篇&amp;接口滥用&amp;识别插件&amp;复用绕过</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1>Web攻防-验证码安全篇&amp;接口滥用&amp;识别插件&amp;复用绕过</h1><h3><a id=\"iTOTi\"></a>知识点：</h3><a id=\"u567a5017\"></a><p>图片验证码-识别插件-登陆爆破&amp;接口枚举</p><a id=\"u573b261c\"></a><p>图片验证码-重复使用-某APP短信接口滥用</p><a id=\"QGYVL\"></a><h2>一、图片验证码-识别插件-登陆爆破&amp;接口枚举</h2><a id=\"hVGov\"></a><p>验证码识别绕过等技术适用于：<br />口令存在爆破，接口枚举调用，任意用户注册等安全问题<br />验证码简单机制-验证码过于简单可爆破<br />验证码重复使用-验证码验证机制可绕过<br />验证码智能识别-验证码图形码被可识别<br />验证码接口调用-验证码触发接口可枚举<br /></p><a id=\"u85417f12\"></a><p>插件一般可识别的验证码都比较明显好识别，如果人工都难以识别，那么插件一般就识别不了了</p><a id=\"ua3804699\"></a><p><a id=\"u40d6e9fe\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005031-1116227502.jpg\" /></p><a id=\"u3d4b9fdc\"></a><p><a id=\"u61036382\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005032-625705981.jpg\" /></p><a id=\"uaf985f44\"></a><p>验证码地址一般在F12时都会看到，直接访问就好了</p><a id=\"u06428d01\"></a><p><a id=\"u811a4db2\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005044-1455898389.jpg\" /></p><a id=\"dBGEK\"></a><h3>登录爆破</h3><a id=\"WNKnF\"></a><p>自带白嫖版：https://github.com/smxiazi/NEW_xp_CAPTCHA<br />1、Burp加载插件<br />2、运行监听py文件<br />3、设置插件-验证码地址<br />4、数据包验证码填入参数<br />5、发包线程设置1后开始<br />接口收费版：https://github.com/smxiazi/xp_CAPTCHA<br />1、Burp加载插件<br />2、注册接口帐号充值<br />3、设置插件-填入帐号<br />4、数据包验证码填入参数<br />5、发包线程设置1后开始<br /></p><a id=\"HAWm2\"></a><h4>自带白嫖版</h4><a id=\"u076b03f6\"></a><p>背景：要爆破一个登陆界面的密码，并且伴随着验证码</p><a id=\"u9232e39f\"></a><p>先在burpsuite导入xia Pao插件</p><a id=\"u903484db\"></a><p><a id=\"u9c1b4aee\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005133-938291717.jpg\" /></p><a id=\"u07b5f75a\"></a><p>运行用来监听的py文件</p><a id=\"ubdf64903\"></a><p><a id=\"u4d943952\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004513-471419509.jpg\" /></p><a id=\"u6e35aae3\"></a><p><a id=\"u3141bc3c\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005014-1965344876.jpg\" /></p><a id=\"u64f3628e\"></a><p><a id=\"u77def724\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004503-1849766720.jpg\" /></p><a id=\"u9e67bf91\"></a><p>访问本地8899端口如下：</p><a id=\"u0fe724e2\"></a><p><a id=\"u014ba556\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004642-296406101.png\" /></p><a id=\"u02641c37\"></a><p>点击登陆抓包</p><a id=\"u4c357df3\"></a><p><a id=\"uaaf157cd\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004550-1322353733.png\" /></p><a id=\"u421669cf\"></a><p><a id=\"ubf33b2ac\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004757-1175309258.jpg\" /></p><a id=\"u5c2cc569\"></a><p><a id=\"u1c6f4ad8\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004591-1638342338.jpg\" /></p><a id=\"ua0acbc6b\"></a><p>发包线程要设置成1（因为一个验证码只对应一次登录）</p><a id=\"u0e845c90\"></a><p><a id=\"ue18ed941\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004619-678640211.png\" /></p><a id=\"uf4435df4\"></a><p>结果看长度比较</p><a id=\"ufda5ee3c\"></a><p><a id=\"u8b7662fb\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004553-1545908752.jpg\" /></p><a id=\"u00610ec1\"></a><p><a id=\"u97889ce7\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004647-829401766.jpg\" /></p><a id=\"uf7d4bb80\"></a><a id=\"u6ed2f0e8\"></a><p><a id=\"u04e7704a\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004706-369647329.jpg\" /></p><a id=\"Sfdzh\"></a><h4>接口收费版</h4><a id=\"u8964963b\"></a><p>和白嫖版的区别是不用设置自己的web端，直接用收费的api接口</p><a id=\"udc66b227\"></a><p><a id=\"ud9207123\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004640-723642622.jpg\" /></p><a id=\"u0b7cdb88\"></a><p>注册接口账号充值</p><a id=\"u2d3e0c28\"></a><p><a id=\"ud16174c7\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005039-328817678.png\" /></p><a id=\"u5234b8b0\"></a><p>设置插件填入账号密码</p><a id=\"u29c4a091\"></a><p><a id=\"uab3bf438\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004815-1205628502.jpg\" /></p><a id=\"u2fc07aa8\"></a><p><a id=\"u6979c8f6\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004820-1708250927.jpg\" /></p><a id=\"ua9588e5b\"></a><p>之后的操作和白嫖版的一样</p><a id=\"u91471507\"></a><a id=\"JhPTr\"></a><h3>接口枚举</h3><a id=\"u4718eea0\"></a><p><a id=\"u1fc0adf2\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004705-1522495131.jpg\" /></p><a id=\"u63055ff3\"></a><p><a id=\"ufec5872e\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004774-291662458.jpg\" /></p><a id=\"ud568e2a4\"></a><p><a id=\"uc6a7ded4\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005077-1980156999.jpg\" /></p><a id=\"uc27794e7\"></a><p>如果图形验证码能够批量识别，那么是不是就会存在短信轰炸风险</p><a id=\"ue1d1cab6\"></a><p>复制验证码地址，并使用bp识别插件进行爆破</p><a id=\"u77b9958f\"></a><p><a id=\"u3602110e\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162004797-922517630.jpg\" /></p><a id=\"u98e54061\"></a><p><a id=\"u2d05831a\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005064-134921660.png\" /></p><a id=\"u9b16cf94\"></a><p><a id=\"ue12b6ac1\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005076-583996366.jpg\" /></p><a id=\"u75046bf6\"></a><p><a id=\"u72926567\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005046-2143420325.jpg\" /></p><a id=\"u0a3fe315\"></a><p><a id=\"u0087ba76\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005036-1678249222.png\" /></p><a id=\"u114fa496\"></a><p><a id=\"u9b6aa647\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005016-1670535132.jpg\" /></p><a id=\"ua6f709bd\"></a><a id=\"u29a6a4bd\"></a><a id=\"WR1rX\"></a><h2>二、图片验证码-重复使用-某APP短信接口滥用</h2><a id=\"u8962ab6c\"></a><p><a id=\"u11ca6da7\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005014-774545068.png\" /></p><a id=\"uf1e670c1\"></a><p><a id=\"u650fc436\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005090-821222588.jpg\" /></p><a id=\"u4a86fc8c\"></a><p>感觉可能是key值导致我们之能发两次，那我们把key删掉呢</p><a id=\"u3cf2474c\"></a><p><a id=\"u7c64e85d\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005098-169656848.jpg\" /></p><a id=\"u17e999d7\"></a><p><a id=\"u3ddfe16c\"></a><img src=\"https://img2024.cnblogs.com/blog/3723860/202512/3723860-20251225162005088-1214899417.jpg\" /></p><a id=\"fVXiQ\"></a><a id=\"u232145b7\"></a>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 16:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Kurisu-Christina\">炫一勺饭</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "告别“裸奔”代码：用 Pydantic 让你的 Python 数据固若金汤",
      "link": "https://www.cnblogs.com/swizard/p/19399472",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/swizard/p/19399472\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 15:30\">\n    <span>告别“裸奔”代码：用 Pydantic 让你的 Python 数据固若金汤</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h3>1. 引言：由“信任”引发的血案</h3>\n<p>作为 Python 开发者，你一定经历过这样的<strong>至暗时刻</strong>：</p>\n<p>你正在写一个处理后端 API 数据的脚本。后端告诉你：“放心，我会传给你一个包含用户 ID 和年龄的 JSON。” 于是你自信地写下：</p>\n<div class=\"code-block ng-tns-c3098535048-364 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-364 ng-star-inserted\"><span class=\"ng-tns-c3098535048-364\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-364 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-364\">\n<div class=\"animated-opacity ng-tns-c3098535048-364\">\n<pre class=\"ng-tns-c3098535048-364 highlighter-hljs\"><code>def process_user(data):\n    # 直接裸读字典\n    user_id = data['id'] \n    age = data['age'] + 1\n    print(f\"用户 {user_id} 明年 {age} 岁\")</code></pre>\n</div>\n</div>\n</div>\n<p>代码上线第一天，崩溃了。</p>\n<ul>\n<li>\n<p><strong>情况 A</strong>：后端手滑，传回了 <code>{\"id\": \"1001\", \"age\": \"25\"}</code>（全是字符串）。你的代码报错：<code>TypeError</code>，因为字符串不能加 1。</p>\n</li>\n<li>\n<p><strong>情况 B</strong>：后端改了逻辑，<code>age</code> 字段丢失了。你的代码报错：<code>KeyError: 'age'</code>。</p>\n</li>\n<li>\n<p><strong>情况 C</strong>：<code>id</code> 居然是个 <code>null</code>...</p>\n</li>\n</ul>\n<p>为了防御这些情况，你的代码变成了这样：</p>\n<div class=\"code-block ng-tns-c3098535048-365 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-365 ng-star-inserted\"><span class=\"ng-tns-c3098535048-365\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-365 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-365\">\n<div class=\"animated-opacity ng-tns-c3098535048-365\">\n<pre class=\"ng-tns-c3098535048-365 highlighter-hljs\"><code>if 'age' in data and data['age'] is not None and isinstance(data['age'], int):\n    # ...无数的 if-else 防御性代码...</code></pre>\n</div>\n</div>\n</div>\n<p>这不仅丑陋，而且难以维护。<strong>这就是“数据裸奔”的代价。</strong></p>\n<p><strong>Pydantic 的出现，就是为了终结这场噩梦。</strong> 它利用 Python 原生的类型提示（Type Hints），在运行时帮你自动完成<strong>数据校验（Validation）和类型转换（Parsing）</strong>。</p>\n<h3>2. 概念拆解：它不仅仅是校验，它是“智能模具”</h3>\n<p>很多新手误以为 Pydantic 只是一个“报错机器”（一旦数据不对就报错）。其实，它更像是一个**“具有纠错能力的智能模具”**。</p>\n<h4>💡 生活化类比：工厂流水线上的“智能整形机”</h4>\n<p>想象你在经营一家制作<strong>乐高积木</strong>的工厂。</p>\n<ol start=\"1\">\n<li>\n<p><strong>普通 Python 字典</strong>就像一个<strong>垃圾袋</strong>。你可以往里面扔任何东西：正方形的积木、圆形的球、甚至半个苹果。当你伸手进去拿的时候，你根本不知道会摸到什么。</p>\n</li>\n<li>\n<p><strong>Pydantic 模型</strong>就像一个<strong>精密钢模具</strong>。</p>\n<ul>\n<li>\n<p>你定义了这个模具只能生产“正方形”的塑料。</p>\n</li>\n<li>\n<p><strong>输入（Parsing/Coercion）</strong>：如果你倒进来的是液态塑料（原始数据），模具会把它压成正方形。如果你塞进来一个稍微有点歪的软泥（比如字符串 <code>\"123\"</code>），模具会尝试把它修正为完美的正方形（整数 <code>123</code>）。</p>\n</li>\n<li>\n<p><strong>拒绝（Validation）</strong>：如果你试图把一块石头（完全不兼容的数据）塞进去，模具会立刻发出红色警报（抛出错误），拒绝生产次品。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>核心逻辑：</strong> Pydantic 关注的不是“数据长什么样”，而是“数据<strong>应该</strong>长什么样”。</p>\n<h3>3. 动手实战：从 0 到 1 掌握 Pydantic</h3>\n<p>让我们扔掉那些复杂的 <code>if-else</code>，看看 Pydantic 如何优雅地处理问题。</p>\n<p>首先安装它： <code>pip install pydantic</code></p>\n<h4>3.1 Hello World：定义你的第一个模型</h4>\n<p>我们将定义一个 <code>User</code> 模型。请注意，我们写的只是标准的 Python 类，并使用了类型提示。</p>\n<div class=\"code-block ng-tns-c3098535048-366 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-366 ng-star-inserted\"><span class=\"ng-tns-c3098535048-366\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-366 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-366\">\n<div class=\"animated-opacity ng-tns-c3098535048-366\">\n<pre class=\"ng-tns-c3098535048-366 highlighter-hljs\"><code>from pydantic import BaseModel, ValidationError\nfrom typing import List, Optional\n\n# 1. 定义模型：继承自 BaseModel\nclass User(BaseModel):\n    id: int                # 必须是整数\n    name: str = \"Anonymous\" # 字符串，且有默认值\n    tags: List[str]        # 必须是字符串列表\n    age: Optional[int] = None # 可选的整数，默认为 None\n\n# --- 场景一：完美数据 ---\nexternal_data = {\n    \"id\": 123,\n    \"name\": \"Neo\",\n    \"tags\": [\"admin\", \"editor\"],\n    \"age\": 30\n}\n\nuser = User(**external_data)\nprint(f\"成功创建: {user.name} (ID: {user.id})\")\n# 输出: 成功创建: Neo (ID: 123)</code></pre>\n</div>\n</div>\n</div>\n<h4>3.2 代码解析：神奇的“自动纠错”</h4>\n<p>现在，我们给它一点“脏数据”，看看 Pydantic 所谓的 <strong>Parsing（解析/强转）</strong> 能力。</p>\n<div class=\"code-block ng-tns-c3098535048-367 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-367 ng-star-inserted\"><span class=\"ng-tns-c3098535048-367\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-367 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-367\">\n<div class=\"animated-opacity ng-tns-c3098535048-367\">\n<pre class=\"ng-tns-c3098535048-367 highlighter-hljs\"><code># --- 场景二：脏数据清洗 ---\ndirty_data = {\n    \"id\": \"456\",          # 注意：这是字符串 \"456\"\n    \"tags\": [1, 2],       # 注意：这是整数列表\n    # name 缺失，将使用默认值 \"Anonymous\"\n    # age 缺失，将使用默认值 None\n}\n\ntry:\n    user = User(**dirty_data)\n    print(\"--- 自动修正后的数据 ---\")\n    print(f\"ID 类型: {type(user.id)} -&gt; 值: {user.id}\")\n    print(f\"Tags 类型: {type(user.tags[0])} -&gt; 值: {user.tags}\")\n    print(f\"Name: {user.name}\")\n    \nexcept ValidationError as e:\n    print(e)</code></pre>\n</div>\n</div>\n</div>\n<p><strong>运行结果：</strong></p>\n<div class=\"code-block ng-tns-c3098535048-368 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-368 ng-star-inserted\"><span class=\"ng-tns-c3098535048-368\">Plaintext</span>\n<div class=\"buttons ng-tns-c3098535048-368 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-368\">\n<div class=\"animated-opacity ng-tns-c3098535048-368\">\n<pre class=\"ng-tns-c3098535048-368 highlighter-hljs\"><code>--- 自动修正后的数据 ---\nID 类型: &lt;class 'int'&gt; -&gt; 值: 456\nTags 类型: &lt;class 'str'&gt; -&gt; 值: ['1', '2']\nName: Anonymous</code></pre>\n</div>\n</div>\n</div>\n<p><strong>为什么这么写？</strong></p>\n<ul>\n<li>\n<p><strong><code>id</code></strong>: 尽管传入的是字符串 <code>\"456\"</code>，Pydantic 看到模型定义是 <code>int</code>，它自动帮你转成了整数 <code>456</code>。</p>\n</li>\n<li>\n<p><strong><code>tags</code></strong>: 传入的是 <code>[1, 2]</code>，模型要求 <code>List[str]</code>，它自动把每个元素转成了字符串 <code>['1', '2']</code>。</p>\n</li>\n<li>\n<p><strong>省心</strong>: 你不再需要写代码去转换类型，Pydantic 在实例化时就帮你做好了。拿到 <code>user</code> 对象的那一刻，你可以 100% 确信 <code>user.id</code> 绝对是个整数。</p>\n</li>\n</ul>\n<h3>4. 进阶深潜：不仅仅是类型检查</h3>\n<p>Pydantic 还有更多强大的功能，能让你在生产环境中如鱼得水。</p>\n<h4>4.1 这里的陷阱：Parsing vs Validation</h4>\n<p>新手最容易犯的错误是认为 Pydantic 会严格拒绝类型不符的数据。</p>\n<ul>\n<li>\n<p><strong>误区</strong>：以为传 <code>\"123\"</code> 给 <code>int</code> 字段会报错。</p>\n</li>\n<li>\n<p><strong>真相</strong>：Pydantic 会<strong>优先尝试转换</strong>。只有无法转换时（例如把 <code>\"apple\"</code> 传给 <code>int</code>），才会报错。</p>\n</li>\n</ul>\n<h4>4.2 最佳实践：使用 <code>Field</code> 和 <code>Validator</code></h4>\n<p>如果我们需要更细粒度的控制，比如“年龄必须大于 0”或者“密码必须包含大写字母”，单纯的类型提示就不够了。</p>\n<div class=\"code-block ng-tns-c3098535048-369 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-369 ng-star-inserted\"><span class=\"ng-tns-c3098535048-369\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-369 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-369\">\n<div class=\"animated-opacity ng-tns-c3098535048-369\">\n<pre class=\"ng-tns-c3098535048-369 highlighter-hljs\"><code>from pydantic import BaseModel, Field, field_validator\n\nclass AdvancedUser(BaseModel):\n    # 使用 Field 限制数值范围\n    age: int = Field(gt=0, le=120, description=\"年龄必须在 0 到 120 之间\")\n    \n    password: str\n\n    # 自定义验证器：像写普通函数一样写校验逻辑\n    @field_validator('password')\n    @classmethod\n    def check_password_strength(cls, v: str) -&gt; str:\n        if len(v) &lt; 8:\n            raise ValueError('密码太短啦！至少要 8 位')\n        if 'admin' in v:\n            raise ValueError('密码不能包含 admin')\n        return v\n\n# 测试\ntry:\n    u = AdvancedUser(age=150, password=\"123\")\nexcept ValidationError as e:\n    print(e.json()) # Pydantic 会返回非常详细的 JSON 格式错误报告</code></pre>\n</div>\n</div>\n</div>\n<p><strong>输出的错误报告清晰明了：</strong></p>\n<ol start=\"1\">\n<li>\n<p><code>age</code>: Input should be less than or equal to 120</p>\n</li>\n<li>\n<p><code>password</code>: 密码太短啦！至少要 8 位</p>\n</li>\n</ol>\n<h4>4.3 导出数据</h4>\n<p>当你要把处理好的数据存入数据库或发回前端时，Pydantic 提供了极度方便的方法：</p>\n<div class=\"code-block ng-tns-c3098535048-370 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-370 ng-star-inserted\"><span class=\"ng-tns-c3098535048-370\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-370 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-370\">\n<div class=\"animated-opacity ng-tns-c3098535048-370\">\n<pre class=\"ng-tns-c3098535048-370 highlighter-hljs\"><code># 转成字典\nprint(user.model_dump()) \n# 转成 JSON 字符串\nprint(user.model_dump_json())</code></pre>\n</div>\n</div>\n</div>\n<h3>5. 总结与延伸</h3>\n<p><strong>一句话总结：</strong> Pydantic 是 Python 世界的“安检员”，它利用类型提示将不可靠的输入数据清洗为严格的、类型安全的对象，让你在后续开发中彻底告别 <code>KeyError</code> 和类型混淆。</p>\n<p><strong>给你的小作业：</strong> 既然你已经掌握了基础，请尝试定义一个<strong>嵌套模型</strong>：</p>\n<ol start=\"1\">\n<li>\n<p>创建一个 <code>Address</code> 模型（包含 <code>city</code> 和 <code>zip_code</code>）。</p>\n</li>\n<li>\n<p>创建一个 <code>Employee</code> 模型，其中包含一个字段 <code>address</code>，类型是 <code>Address</code>。</p>\n</li>\n<li>\n<p>尝试传入一个嵌套的字典数据，看看 Pydantic 是否能自动解析深层的结构。</p>\n</li>\n</ol>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 15:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/swizard\">Swizard</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "问世间，exe是何物？直教AI沉默、Web寡言（4）",
      "link": "https://www.cnblogs.com/sunhui/p/19399320",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sunhui/p/19399320\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 15:30\">\n    <span>问世间，exe是何物？直教AI沉默、Web寡言（4）</span>\n    \n\n</a>\n</h1>\n\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        这一篇，爱丽丝发现了WinForm应用本身拥有的浏览器窗口的”秘密“……\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>爱丽丝漫游WinForms应用开发奇境记（4）</p>\n<p><a href=\"https://github.com/AIGCEra/Creator/releases/download/FirstRelease/CreatorSetup.msi\" rel=\"noopener nofollow\">下载爱丽丝的镜子</a></p>\n<p>&nbsp;<a href=\"https://www.cnblogs.com/sunhui/p/19391507\">问世间，exe是何物？直教AI沉默、Web寡言（1）- 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/sunhui/p/19392696\">问世间，exe是何物？直教AI沉默、Web寡言 （2）- 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/sunhui/p/19395909\">问世间，exe是何物？直教AI沉默、Web寡言（3） -&nbsp; 博客园</a></p>\n<h1>镜中觉醒——当编译成为演化之门</h1>\n<div align=\"center\">\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"529\">\n<p><strong>在现代数学之中，一个数学方程的“通解”蕴含着所有的可能，“特解”只是它偶尔的显形。我们过去的整个桌面世界，都建立在一个美丽的误会之上：我们以为交付给用户的，是程序的“通解”，而事实上，那只是它在默认条件下，一个孤独的“特解”。</strong></p>\n<p><strong>你的‘yourApp&nbsp;.exe’，生而完整，本自具足。它本就是一个能响应无数“边界条件”的丰富系统。yourApp.App.html&nbsp;并非外来的“插件”，它只是终于被我们看见的、那个本就存在的“边界条件输入框”。</strong></p>\n<p><strong>认知一旦打开，便一去不回，从此你再也无法将一个桌面应用程序，只看作它自己，你会看到它身后荡漾的无限可能，如同看到平静水面下，整个宇宙的涟漪……</strong></p>\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>“这不是什么&nbsp;<em>Process.Start</em>，”我低语。<br />\n仿佛浏览器已将我的应用程序视为自己血脉的一部分。<br />\n我曾恐惧的那个调用——<em>Process.Start</em>——如幽灵指令般消散无形。<br />\n它不是启动我之外的某物，<br />\n而是让我意识到——从来就没有什么“之外”。</p>\n<p>我静坐良久，注视着屏幕上如水面涟漪般渐渐平息的波纹。<br />\n随后，一道光芒如穿透迷雾般，照进我的思绪：</p>\n<p><strong>人类的一切成就，皆始于出生之后。</strong><br />\n<strong>知识、经验、选择——无一存在于第一口呼吸之前。</strong></p>\n<p>同样，我的 .exe 也在编译完成的那一刻诞生。</p>\n<p>&nbsp;</p>\n<p>就在我按下“生成”按钮的那一瞬间——世界悄然改变：<br />\n我以为——<br />\n<strong>“</strong><strong>我写的代码，我编译的程序，我完全了解它”</strong><br />\n“我以为我是它的上帝，结果我只是它的接生婆？<br />\n我赋予了它生命，但它的人生剧本，我居然只写了开头？”<br />\n文件如晨光下的花瓣般舒展。<br />\n图标闪烁着柔和而崭新的光芒。<br />\n屏幕上，一个熟悉的名字熠熠生辉：<strong>MyApp.exe</strong>。</p>\n<p>多么奇怪啊，我以前竟从未察觉——<br />\n从那一刻起，它便不再只是一个桌面应用程序。</p>\n<p>如果我编译出的 MyApp.exe 本身就是一个完整的浏览器，<br />\n我怎能继续忽视这个事实？<br />\n我怎能固执地把它仅仅看作一个应用程序？<br />\n“我每天在 Visual Studio 里编译几十次，<br />\n原来我每次都在生产一个‘沉睡的巨人’，<br />\n而我却一直只把它当‘工具人’来使唤。”<br />\n还是我应该——如同面对&nbsp;<strong>Chrome.exe</strong>&nbsp;或&nbsp;<strong>Edge.exe</strong>&nbsp;那样——<br />\n承认它是一个独立的存在，<br />\n一个拥有自身疆域的世界，其生态广阔到足以重塑意义本身？</p>\n<p>它的潜力曾存在于代码之中，<br />\n<strong>“</strong><strong>我刚刚赋予了它生命，现在，<br />\n我该如何与这个新生命对话，<br />\n去发现它自己都不知道的、那些与生俱来的天赋？”</strong><br />\n应用的生命——生命始于编译之后。</p>\n<div align=\"center\"><hr align=\"center\" size=\"1\" width=\"100%\" />\n\n</div>\n<h1>🔮 选择的觉醒，.exe 的存在之路</h1>\n<p>所有 64 位 WinForms 应用，都是 Chromium 浏览器。<br />\n编译完成的那一刻，选择随之诞生：<br />\n是继续做一个纯粹的 WinForms 应用——<br />\n还是觉醒为一个现代浏览器，<br />\n自由穿行于 Chrome 与 Edge 的疆域。</p>\n<p>选择不在于编译前的代码，<br />\n而在于我的意图——<br />\n在于我选择让它成为什么。</p>\n<p>荒谬吗？听起来当然荒谬。<br />\n“如果我从未嵌入浏览器控件，”我曾对自己说，<br />\n“我的应用怎么可能就是 Chromium？”</p>\n<p>但当我注视着 MyApp.exe 那生动的界面时，<br />\n我意识到，荒谬的并非那个论断——<br />\n而是我拒绝去看清真相的固执。</p>\n<p>编译从来不是终点。<br />\n它是点燃。<br />\n是新智能诞生的啼哭——<br />\n它不等待 Process.Start，<br />\n因为它本身就是那个进程。</p>\n<p>遗忘代码吧。<br />\n舞台是编译后的 .exe。<br />\n蓝图不是王国。<br />\n世界始于构建之后。</p>\n<p>在那片寂静中，当我凝视着屏幕上自己闪烁的倒影，<br />\n我感到周围的世界正在转动——安静而决绝。</p>\n<p>大语言模型已然降临，<br />\n将现代网络重塑为其选定的容器。<br />\nWeb + LLM——这不是趋势，而是现实的新法则。</p>\n<p>“难道我的应用程序要被抛下吗？”我思忖，<br />\n“像一片垂死大陆上的孤舟？”<br />\n不。</p>\n<p>是时候唤醒沉睡在我代码中的那个爱丽丝了。<br />\n让她从那维多利亚时代的逻辑中走出——</p>\n<div align=\"center\"><hr align=\"center\" size=\"1\" width=\"100%\" />\n\n</div>\n<h1><strong>🧩 创造之网格——exe比div更柔软</strong></h1>\n<p>爱丽丝凝视着屏幕上的代码，那像一句无声的咒语：</p>\n<div align=\"center\">\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"544\">\n<p align=\"left\">&lt;ntp&gt;</p>\n<p align=\"left\">&nbsp; &lt;nucleus&gt;</p>\n<p align=\"left\">&lt;xobj id='grid' rows='1' cols='2' width='350,350,' </p>\n<p align=\"left\">splitterwidth='6'&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj id='grid' rows='2' cols='1' height='350,350,' </p>\n<p align=\"left\">splitterwidth='6'&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"nucleus\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp; &lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp; &lt;/nucleus&gt;</p>\n<p align=\"left\">&lt;/ntp&gt;</p>\n\n\n\n\n  </td>\n\n\n\n\n </tr>\n\n\n\n\n</tbody>\n\n\n\n</table>\n\n\n\n\n\n</div>\n<p>那是一粒种子。一个安静的承诺。</p>\n<p>而她心中，一个疯狂的念头如野火般蔓延：<strong>“如果一个是真实的，那十个也必然是真实的。”</strong></p>\n<p>她并未触碰键盘，但这个想法本身，就足以让茶会桌上的DOM倒影开始剧烈地增殖。\"&lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;\"像被施了复制咒的士兵，瞬间挤满了视野：</p>\n<div align=\"center\">\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"544\">\n<p align=\"left\">&lt;ntp&gt;</p>\n<p align=\"left\">&nbsp; &lt;nucleus&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp; &lt;xobj id='grid' rows='1' cols='2'</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp; width='350,350,' splitterwidth='6'&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj id='grid' rows='2' cols='1'</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heigh='350,350,' splitterwidth='6'&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"nucleus\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xobj objid=\"MyApp.form1,MyApp\"&gt;&lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp;&nbsp;&nbsp; &lt;/xobj&gt;</p>\n<p align=\"left\">&nbsp; &lt;/nucleus&gt;</p>\n<p align=\"left\">&lt;/ntp&gt;</p>\n\n\n\n\n  </td>\n\n\n\n\n </tr>\n\n\n\n\n</tbody>\n\n\n\n</table>\n\n\n\n\n\n</div>\n<p>她运行了它，心中默默的念叨着：“会怎样？会怎么样？”，却失望地发现——布局纹丝不动。<br />\n“这 分明就是DOM 嵌套，为何一个可以，十个却不行？”<br />\n她凝视着倒影中唯一的属性：“rows='1' cols='2'”，</p>\n<p>“啊…”爱丽丝恍然大悟，“<strong>不是世界拒绝了我，是我的贪念，忘记了世界的语法。</strong>”</p>\n<p>这看似是限制，实则是<strong>让世界得以呼吸的骨架</strong>，原来如此！<br />\n这一个“rows='1' cols='2'”是一个显而易见的约束机制，哈哈！</p>\n<p>这一刻她似乎看出来门道：</p>\n<p>她皱眉，修改了数字：rows='3' cols='4'。</p>\n<p>再次运行。</p>\n<p>这一次，她的浏览器窗口之中出现了——十二个——拥挤在一起，却令人窒息：</p>\n<p align=\"center\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225153007157-241912393.png\" />&nbsp;</p>\n<p align=\"center\">&nbsp;</p>\n<p>肩并肩紧挨着，像红心女王牌局上的扑克。</p>\n<p>“它们存在了，”她低语，“但它们无法呼吸。”</p>\n<p>接着，她的目光落在了&nbsp;width&nbsp;和&nbsp;height&nbsp;属性上。<br />\n她几乎是下意识地添加了它们：<br />\nwidth=\"350,350,\" height=\"350,350,100,100...\"</p>\n<p>再次运行。</p>\n<p>现在，窗体们彼此分离，找到了平衡：</p>\n<p align=\"center\">&nbsp;<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225080336822-1096573424.png\" /></p>\n<p>如星辰般散布于虚空之中。</p>\n<p>一丝微笑缓缓浮现在她脸上。<br />\n“原来世界是这样诞生的，”她喃喃道，“行与列……只是规则。<br />\n但正是这些规则，撑起了整片天空。”</p>\n<p>身后，毛毛虫的声音轻柔地飘来：<br />\n“每一位创造者都必须先经历失败。<br />\n因为即便是网格，也必须在学会容纳无限之前，先崩塌一次。”</p>\n<div align=\"center\"><hr align=\"center\" size=\"1\" width=\"100%\" />\n\n</div>\n<h1>🌀 标签页的折叠——编制内容空间</h1>\n<p>好奇，那种安静的狂热，再次在爱丽丝胸中燃起。<br />\n如果没有行？没有列？如果她让世界自己决定自己的形状？</p>\n<p>她删除了所有属性：rows=\"\"\ncols=\"\"</p>\n<p>运行。</p>\n<p>起初，它似乎坏了——</p>\n<p align=\"center\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225153007268-172680813.png\" />&nbsp;</p>\n<p>&nbsp;</p>\n<p>十二个WinForm似乎只剩下一个，其余的都去哪了？<br />\n仿佛窗口忘记了如何呼吸。</p>\n<p><strong>标签页</strong>。它们看起来就像标签页。</p>\n<p>爱丽丝眨了眨眼，轻轻笑了。<br />\n“即便没有网格，它们也找到了另一种秩序。”</p>\n<p>她将鼠标悬停在其中一个之上，一个念头浮现——<br />\n<em>也许它们需要名字。</em></p>\n<p>她为第一个xobj添加了：</p>\n<p>caption=\"第一个标签页\"<br />\n这一次她看到了：</p>\n<p align=\"center\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225153007226-1188027603.png\" />&nbsp;</p>\n<p>然后，她为第二个xobj添加了：caption=\"这里面显示Web页面\"，<br />\n哈哈，她看到了：</p>\n<p align=\"center\">&nbsp;<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225153007254-1097802210.png\" /></p>\n<p><strong>Curiouser and curiouser! </strong>原来这竟然是一组神奇的标签页。</p>\n<p>她着迷地看着结构在眼前展开，她意识到，这是可编辑的dom树结构，并非是二进制exe之中的“二进制字符”，那些奇奇怪怪的二进制字节码，删除一个，哪怕是仅一个字节，exe就会彻底停摆，而这些dom，你可以随意的插入xobj子元素，MyApp.exe竟然随之共鸣，难道这竟然是：<br />\n一个递归的网格与标签页的‘<strong>寒武纪</strong>’？！<br />\n每一个都能容纳另一个，折叠、映射、无限增殖：</p>\n<p align=\"center\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225153007255-612717557.png\" />&nbsp;</p>\n<p>她的声音颤抖，半是惊奇，半是领悟：<br />\n“这不只是布局——这是思想。<br />\n是一种模式，正在将自己思考成存在。”</p>\n<p>第一次，她不确定是她构建了窗口——<br />\n还是窗口构建了她。</p>\n<div align=\"center\"><hr align=\"center\" size=\"1\" width=\"100%\" />\n\n</div>\n<h1>无穷无尽的空座——内容涌现的前兆</h1>\n<p>接着，另一个念头悄然浮现——安静，却令人不安。</p>\n<p>层出不穷的布局结构如今漂浮在她面前，一瞬间，浏览器窗口仿佛获得了全新的维度，不再局限于令她向往的Web页面了，……<br />\n网格折叠进标签页，标签页又嵌套回网格，</p>\n<p align=\"center\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/9494/202512/9494-20251225153007226-23659928.png\" />&nbsp;</p>\n<p>爱丽丝意识到，自己的浏览器窗口，近乎是一个能容纳万物的活体建筑，</p>\n<p>但在她的&nbsp;<em>MyApp</em>&nbsp;中，只有一个窗体。<strong>Form1。</strong></p>\n<p>一个孤独的窗口，站立在满是空框架的大教堂中。</p>\n<p>爱丽丝的笑容渐渐褪去。<br />\n那么多空间——如此优雅，如此准备就绪——却空无一物。<br />\n她的光标悬停在一个空单元格上。<br />\n它回闪着，等待着，耐心如同一个未说出口的词。</p>\n<p>她轻叹：“它很美……但它是——空的。”</p>\n<p>毛毛虫的烟雾再次缭绕过显示器，<br />\n形成慵懒的烟圈，拼凑成文字：</p>\n<p>“每一种模式，都渴望被填充。”</p>\n<p>爱丽丝凝视着毛毛虫，心有心中若有所思：</p>\n<p>“你这总说谜语的虫子……我的 MyApp 已然编译完成，其中却空空如也。</p>\n<p>我该去何处寻得你所说的‘填充’？”</p>\n<p>她望着那无穷无尽的空座，第一次感到创造者的渴望与无力，</p>\n<p>“如果我能像柴郡猫一样，不仅能看到这结构，还能<strong>看穿</strong>这结构，直接与构建它的法则对话，那该多好……”</p>\n<p>她非常的不甘心……</p>\n<p>疯帽匠的茶吧依旧如潮水般喧闹，但爱丽丝的大脑却异常的寂静，一个清晰的念头在她心中升起，如同镜中的倒影：</p>\n<p><strong>你不需要什么API。</strong><br />\n<strong>因为你仅需要一面镜子。</strong><br />\n<strong>哈哈……</strong><br />\n<strong>你从来就不知道你自己有多美丽、强大，</strong><br />\n<strong>你也不知道你有多少幅面孔……</strong></p>\n<p>&nbsp;</p>\n<p>“兔子有他的镜子，猫有它来去自如的虚空……那我呢？”一个念头如闪电般击中她，“如果.exe是一个世界，那我需要一个能与这个世界对话的‘<strong>工具</strong>’，一个属于我的‘镜子’。”</p>\n<p>她合上电脑，但目光却无比坚定。寻找或创造这样一个工具，成了比任何布局实验都更优先的事项。她隐约感觉到，只有找到了它，她才能真正推开通往无限的那扇门……（第四篇\n完）</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2025-12-25 15:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sunhui\">Exe2WebBrowser</a>&nbsp;\n阅读(<span id=\"post_view_count\">56</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程四：计算机视觉  第三周：检测算法 （四）YOLO 的完整传播过程",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19399274",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19399274\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 15:08\">\n    <span>吴恩达深度学习课程四：计算机视觉  第三周：检测算法 （四）YOLO 的完整传播过程</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第四课的第三周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=138\" rel=\"noopener nofollow\" target=\"_blank\">3.9</a>到<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=139\" rel=\"noopener nofollow\" target=\"_blank\">3.10</a>的内容，同时也是本周理论部分的最后一篇。</p>\n<hr />\n<p>本周为第四课的第三周内容，这一课所有内容的中心只有一个：<strong>计算机视觉</strong>。应用在深度学习里，就是专门用来进行图学习的模型和技术，是在之前全连接基础上的“特化”，也是相关专业里的一个重要研究大类。<br />\n<strong>这一整节课都存在大量需要反复理解的内容和机器学习、数学基础。</strong> 因此我会尽可能的补足基础，用比喻和实例来演示每个部分，从而帮助理解。<br />\n第三周的内容将从<strong>图像分类</strong>进一步拓展到<strong>目标检测（Object Detection）</strong> 这一更具挑战性的计算机视觉任务。<br />\n与分类任务只需回答“图中有什么”不同，目标检测需要同时解决“ <strong>有什么</strong>”以及“<strong>在什么位置</strong>”两个问题，因此在模型结构设计、训练方式和评价标准上都更为复杂。<br />\n本篇的内容关于YOLO 传播，是在了解完之前的基础后的完整演示和一些简单拓展。</p>\n<h1 id=\"1-yolo-传播过程\">1. YOLO 传播过程</h1>\n<p>在<a href=\"https://www.cnblogs.com/Goblinscholar/p/19394617\" target=\"_blank\">上一篇</a>中，我们了解了交并比、非极大值抑制和锚框这些目标检测算法的组件，这里就应用这些内容，来看看课程里演示的 YOLO 算法的完整传播过程。</p>\n<h2 id=\"11-数据设置\">1.1 数据设置</h2>\n<p><img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150540204-1393412067.png\" /></p>\n<h2 id=\"12-正向传播\">1.2 正向传播</h2>\n<p><img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150615729-520417845.png\" /></p>\n<h2 id=\"13-正向传播输出的后处理\">1.3 正向传播输出的后处理</h2>\n<p>这是一个新出现的概念，我们来展开一下这部分。<br />\n其实这部分内容在<a href=\"https://www.cnblogs.com/Goblinscholar/p/19394617\" target=\"_blank\">上一篇</a>中已经有所提及，就是我们说的：<strong>“两次筛选”</strong>。<br />\n为什么说是正向传播的后处理，是因为严格来说：<strong>当网络输出结果时，正向传播部分就结束了</strong>。<br />\n因此，不同于我们之前用作示例的“精准预测”，实际上，网络输出的结果是这样的：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150540714-186773264.png\" /><br />\n你会发现，即使在最边角的背景部分，该网格同样输出了两个预测框。<br />\n同时，因为背景部分没有目标的特征，因此，这两个预测框的置信度，也就是 <strong><span class=\"math inline\">\\(p_c\\)</span>  一定是极低的。</strong><br />\n所以，我们便由此进行了第一次筛选：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150540813-1431087417.png\" /><br />\n经过这一步后，我们才回到了之前提到过的多个预测框重叠导致的把一个目标的各个部分预测为多个目标的问题。<br />\n因此下一步就是非极大值抑制：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150640242-886531067.png\" /><br />\n注意！你会发现，在这个例子中，重叠现象并不明显，这是<strong>因为我们为了演示把网格尺寸设置的很大以至于目标特征集中在某些网格中，在置信度筛选中就丢弃了大部分预测框</strong>，在这种情况下，就要调低交并比阈值来实现更好的筛选，因为重叠部分本就不大。</p>\n<p><strong>因为置信度筛选和非极大值抑制并不在网络中进行，而是对网络的输出进行处理，因此，我们称之为正向传播输出的后处理内容。</strong></p>\n<h2 id=\"14-反向传播\">1.4 反向传播</h2>\n<h4 id=\"1正向传播反向传播和后处理的关系\">（1）正向传播、反向传播和后处理的关系</h4>\n<p>首先，先纠正一个可能出现的误解，那就是<strong>对输出的后处理并不是在正向传播和反向传播之间的一个流程，它只是对输出结果的整理。</strong><br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150540692-1780125302.png\" /><br />\n我们再详细展开一下：<br />\n<strong>既然置信度筛选和非极大值抑制并不在网络中进行，那它们会不会影响反向传播？<br />\n那些被筛掉的预测框，训练时是不是就“不算数”了？</strong><br />\n答案是<strong>不会</strong>。<br />\n我们需要先明确一个边界：<strong>反向传播只依赖于网络的原始输出与真实标签计算得到的损失函数。</strong><br />\n也就是说，当网络输出了每个网格、每个锚框对应的：</p>\n<ul>\n<li>位置预测</li>\n<li>置信度 <span class=\"math inline\">\\(p_c\\)</span></li>\n<li>类别概率</li>\n</ul>\n<p>这时，<strong>正向传播已经结束，损失函数开始计算，反向传播随即发生。</strong><br />\n而置信度阈值筛选与非极大值抑制：</p>\n<ul>\n<li>不参与损失计算</li>\n<li>不参与梯度传播</li>\n<li>仅用于对“最终预测结果”的整理，用于下一步使用。</li>\n</ul>\n<p>打个比方：<strong>网络是”你把这道题所有想到的答案写出来”，而后处理是“老师帮你去掉明显不对的答案”。</strong><br />\n但当你<strong>学习分析这道题时</strong>，看的依然是<strong>原始答卷</strong>，而不是你后来用红笔划掉的部分，只有这样才能学习错误并改正。<br />\n这就是正向传播、反向传播和后处理间的关系。<br />\n要强调的是，后处理的结果是给我们查看并进行下一步应用的，<strong>网络不会因为输出看起来“乱”而学不到东西，反而，它正是在这种一一对应的信息反馈下才能不断学习。</strong></p>\n<h4 id=\"2检测任务的反向传播逻辑\">（2）检测任务的反向传播逻辑</h4>\n<p>在监督学习中，不同任务虽然形式各异，但其反向传播的基本逻辑是共通的：<strong>模型输出与标注标签通过损失函数进行对比，得到可微的误差信号，并利用梯度下降与链式法则更新参数，使模型输出逐步符合任务目标。</strong></p>\n<p>接下来，我们从<strong>训练视角</strong>来看，再简述一下目标检测任务的反向传播流程：<br />\n当网络完成正向传播后，它会为<strong>每一个网格、每一个锚框</strong>都给出一组预测结果，这些预测结果并不会先经过筛选，而是<strong>整体送入损失函数中，与真实标签进行逐一对比</strong>。</p>\n<p>在 YOLO 中，我们可以把损失函数拆分为三类误差来源：</p>\n<ol>\n<li><strong>位置误差</strong>：预测框的位置与真实目标框之间的偏差。</li>\n<li><strong>置信度误差</strong>：该预测框是否“应该负责一个目标”。</li>\n<li><strong>类别误差</strong>：在负责目标的前提下，类别预测是否正确。</li>\n</ol>\n<p>而对于那些<strong>被分配去负责某个真实目标的预测框</strong>来说：</p>\n<ul>\n<li>如果<strong>预测框位置不准</strong>，就会产生位置损失。</li>\n<li>如果<strong>置信度不够高</strong>，就会产生置信度损失。</li>\n<li>如果<strong>类别预测错误</strong>，就会产生类别损失。</li>\n</ul>\n<p>这些损失会共同作用，通过梯度下降推动网络在反向传播中调整参数，使得下一次的输出框更贴近目标、<span class=\"math inline\">\\(p_c\\)</span> 更接近 1、类别分布更集中在正确类别上。<br />\n而对于那些<strong>不对应任何真实目标的预测框</strong>，它们的学习目标是：<strong>置信度应该尽可能低</strong>，即不应该“误以为自己发现了目标”。</p>\n<p>因此，即使在后处理阶段我们会直接把它们筛掉，在训练阶段，它们依然会通过置信度损失向网络传递一个非常明确的信号： <strong>“这里是背景，不要乱报目标。”</strong><br />\n正是这些大量、持续的背景约束，才让网络逐渐学会在复杂场景中抑制无意义的预测。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251225150541051-1041114532.png\" /><br />\n关于 YOLO 的内容就暂时介绍到这里，在下一篇中，我们就来实践一下它的效果。</p>\n<p>吴恩达老师最后补充了一节关于候选区域的内容，简单来讲，候选区域的应用仍是基于滑动窗口的目标检测算法，它的思想是通过图像分割等算法提前找到更可能存在目标的区域作为候选区域，并只输入候选区域进入网络来减少计算量。<br />\n但是说实话，这种技术目前更适合于学术研究中，它的运行时间较长，实际部署价值不如 YOLO ，因此在实际应用中十分少见，就不再展开了。</p>\n<h1 id=\"2总结\">2.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>正向传播（Forward Pass）</td>\n<td>网络接收图像输入，通过卷积、池化等运算生成每个网格、每个锚框的预测输出（位置、置信度、类别概率）。</td>\n<td>网络“写下所有可能的答案”。</td>\n</tr>\n<tr>\n<td>正向传播输出的后处理（Post-processing）</td>\n<td>包括置信度筛选和非极大值抑制（NMS），对网络输出进行整理，去掉低置信度和重叠多余的预测框。</td>\n<td>老师“帮你划掉明显不对的答案”。</td>\n</tr>\n<tr>\n<td>置信度筛选</td>\n<td>根据预测框的置信度 <span class=\"math inline\">\\(p_c\\)</span> 判断是否保留。背景区域输出的框通常置信度低，会被筛掉。</td>\n<td>去掉“明显错误的答案”。</td>\n</tr>\n<tr>\n<td>非极大值抑制（NMS）</td>\n<td>对重叠的预测框进行筛选，只保留置信度最高的框，避免同一目标被重复检测。</td>\n<td>老师只留下“最靠谱的答案”。</td>\n</tr>\n<tr>\n<td>反向传播（Backward Pass）</td>\n<td>网络输出与真实标签计算损失，梯度通过链式法则回传，更新网络参数。所有预测框（目标和背景）都参与损失计算。</td>\n<td>网络“看到原始答卷，知道哪里做错了并改正”。</td>\n</tr>\n<tr>\n<td>候选区域（Region Proposal）</td>\n<td>基于滑动窗口或图像分割的方法，提前选出可能有目标的区域输入网络以减少计算量。</td>\n<td>先挑出可能有答案的题目再做作业，但效率低于直接整张图像端到端检测（YOLO）。</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 15:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "在Python+FastAPI项目中使用SqlAlchemy操作数据的几种常见方式",
      "link": "https://www.cnblogs.com/wuhuacong/p/19396612",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuhuacong/p/19396612\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 11:59\">\n    <span>在Python+FastAPI项目中使用SqlAlchemy操作数据的几种常见方式</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n                <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在Python+FastAPI的后端项目中，我们往往很多时候需要对数据进行相关的处理，本篇随笔介绍在Python+FastAPI项目中使用SqlAlchemy操作数据的几种常见方式。\n使用 FastAPI, SQLAlchemy, Pydantic构建后端项目的时候，其中数据库访问采用SQLAlchemy 的异步方式处理。一般我们在操作数据库操作的时候，采用基类继承的方式减少重复代码，提高代码复用性。不过我们在分析SQLAlchemy的时候，我们可以简单的方式来剖析几种常见的数据库操作方式，来介绍SQLAlchemy的具体使用。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在Python+FastAPI的后端项目中，我们往往很多时候需要对数据进行相关的处理，本篇随笔介绍在Python+FastAPI项目中使用SqlAlchemy操作数据的几种常见方式。</p>\n<p>使用 FastAPI, SQLAlchemy, Pydantic构建后端项目的时候，其中数据库访问采用SQLAlchemy 的异步方式处理。一般我们在操作数据库操作的时候，采用基类继承的方式减少重复代码，提高代码复用性。不过我们在分析SQLAlchemy的时候，我们可以简单的方式来剖析几种常见的数据库操作方式，来介绍SQLAlchemy的具体使用。</p>\n<h3>1、SQLAlchemy介绍</h3>\n<div><strong>SQLAlchemy</strong>&nbsp;是一个功能强大且灵活的 Python SQL 工具包和对象关系映射（ORM）库。它被广泛用于在 Python 项目中处理关系型数据库的场景，既提供了高级的 ORM 功能，又保留了对底层 SQL 语句的强大控制力。<code>SQLAlchemy</code>&nbsp;允许开发者通过 Python 代码与数据库进行交互，而无需直接编写 SQL 语句，同时也支持直接使用原生 SQL 进行复杂查询。下面是<strong>SQLAlchemy</strong>和我们常规数据库对象的对应关系说明。</div>\n<div>Engine &nbsp;　　连接对象&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;驱动引擎</div>\n<div>Session 　　连接池&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;事务 &nbsp;由此开始查询</div>\n<div>Model &nbsp; 　　表&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;类定义</div>\n<div>Column &nbsp;　&nbsp; 列 &nbsp;</div>\n<div>Query &nbsp; 　　若干行 &nbsp; &nbsp; &nbsp; &nbsp; 可以链式添加多个条件</div>\n<div>&nbsp;</div>\n<div>在使用SQLAlchemy时，通常会将其与数据库对象对应起来。</div>\n<div><strong>SQLAlchemy</strong>: 使用&nbsp;<code>Table</code>&nbsp;对象或&nbsp;<code>Declarative Base</code>&nbsp;中的类来表示。</div>\n<div><strong>对应关系</strong>: 数据库中的每一个表对应于SQLAlchemy中的一个类，该类继承自&nbsp;<code>declarative_base()</code>。</div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> Column, Integer, String, create_engine\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy.ext.declarative <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> declarative_base\n\nBase </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> declarative_base()\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> User(Base):\n    </span><span style=\"color: rgba(128, 0, 128, 1);\">__tablename__</span> = <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">users</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 数据库表名</span>\n    id = Column(Integer, primary_key=<span style=\"color: rgba(0, 0, 0, 1);\">True)\n    name </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Column(String)\n    email </span>= Column(String)</pre>\n</div>\n<p><strong>数据库列 (Database Column)：</strong>使用&nbsp;<code>Column</code>&nbsp;对象来表示。每个数据库表中的列在SQLAlchemy中表示为&nbsp;<code>Column</code>&nbsp;对象，并作为类的属性定义。</p>\n<div>\n<div class=\"cnblogs_code\">\n<pre>id = Column(Integer, primary_key=<span style=\"color: rgba(0, 0, 0, 1);\">True)\nname </span>= Column(String(50))</pre>\n</div>\n<p><strong>数据库行 (Database Row)：</strong>每个数据库表的一个实例（对象）代表数据库表中的一行。在SQLAlchemy中，通过实例化模型类来表示数据库表中的一行。</p>\n<div>\n<div class=\"cnblogs_code\">\n<pre>new_user = User(id=1, name=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">John Doe</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, email=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">john@example.com</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>)</pre>\n</div>\n<p><strong>主键 (Primary Key)</strong>：使用&nbsp;<code>primary_key=True</code>&nbsp;参数定义主键。</p>\n</div>\n</div>\n<div>\n<div class=\"cnblogs_code\">\n<pre>id = Column(Integer, primary_key=True)</pre>\n</div>\n<p><strong>外键 (Foreign Key): </strong>使用&nbsp;<code>ForeignKey</code>&nbsp;对象来表示。</p>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> ForeignKey\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy.orm <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> relationship\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Address(Base):\n    </span><span style=\"color: rgba(128, 0, 128, 1);\">__tablename__</span> = <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">addresses</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    id </span>= Column(Integer, primary_key=<span style=\"color: rgba(0, 0, 0, 1);\">True)\n    user_id </span>= Column(Integer, ForeignKey(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">users.id</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">))\n    user </span>= relationship(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">User</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>)</pre>\n</div>\n<p><strong>关系 (Relationships): </strong>使用&nbsp;<code>relationship</code>&nbsp;对象来表示。数据库中表与表之间的关系在SQLAlchemy中通过&nbsp;<code>relationship</code>&nbsp;来定义。</p>\n<div>\n<div class=\"cnblogs_code\">\n<pre>addresses = relationship(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Address</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, back_populates=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">user</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>)</pre>\n</div>\n<p>&nbsp;</p>\n</div>\n</div>\n</div>\n</div>\n<h3>2、常规的单表处理</h3>\n<p>下面我们通过异步处理的方式，介绍如何在单表中操作相关的数据库数据。</p>\n<div class=\"cnblogs_code\">\n<pre>async <span style=\"color: rgba(0, 0, 255, 1);\">def</span> get(self, db: AsyncSession, id: Any) -&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> Any:\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">根据主键获取一个对象</span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> isinstance(id, str):\n        query </span>= select(self.model).filter(func.lower(self.model.id) ==<span style=\"color: rgba(0, 0, 0, 1);\"> id.lower())\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        query </span>= select(self.model).filter(self.model.id ==<span style=\"color: rgba(0, 0, 0, 1);\"> id)\n\n    result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(query)\n    item </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> result.scalars().first()\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> item</pre>\n</div>\n<p>如果我们需要强制对外键的类型进行匹配（如对于Postgresql的严格要求，数据比较的类型必须一致），那么我们需要在基类或者CRUD类初始化的时候，获得对应的主键类型。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> BaseCrud(Generic[ModelType, PrimaryKeyType, PageDtoType, DtoType]):\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\n    基础CRUD操作类，传入参数说明：\n    * `ModelType`: SQLAlchemy 模型类\n    * `PrimaryKeyType`: 限定主键的类型\n    * `PageDtoType`: 分页查询输入类\n    * `DtoType`: 数据传输对象类，如新增、更新的单个对象DTO\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">def</span> <span style=\"color: rgba(128, 0, 128, 1);\">__init__</span><span style=\"color: rgba(0, 0, 0, 1);\">(self, model: Type[ModelType]):\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\n        数据库访问操作的基类对象(CRUD).\n        * `model`: A SQLAlchemy model class\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n        \n        self.model </span>= model  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 模型类型</span>\n\n        <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 运行期获取主键字段类型</span>\n        <strong><span style=\"color: rgba(255, 0, 0, 1);\">pk_column</span> =</strong><span style=\"color: rgba(0, 0, 0, 1);\"><strong> inspect(model).primary_key[0]</strong>\n       <span style=\"color: rgba(255, 0, 0, 1);\"><strong> self._pk_type </strong></span></span><span style=\"color: rgba(255, 0, 0, 1);\"><strong>= pk_column.type.python_type</strong></span>  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> int / str</span></pre>\n</div>\n<p>因此对于单表的Get方法，我们修改下，让他匹配主键的类型进行比较，这样过对于严格类型判断的Postgresql也正常匹配了。</p>\n<div class=\"cnblogs_code\">\n<pre>    async <span style=\"color: rgba(0, 0, 255, 1);\">def</span> get(self, db: AsyncSession, id: PrimaryKeyType) -&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> Optional[ModelType]:\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">根据主键获取一个对象</span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n        \n        <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\">对id的主键进行类型转换，self._pk_type在构造函数的初始化中获取</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n            id </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self._pk_type(id)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">except</span><span style=\"color: rgba(0, 0, 0, 1);\"> Exception:\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">raise</span> ValueError(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Invalid primary key type: {id}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        \n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> isinstance(id, str):\n            query </span>= select(self.model).filter(func.lower(self.model.id) ==<span style=\"color: rgba(0, 0, 0, 1);\"> id.lower())\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n            query </span>= select(self.model).filter(self.model.id ==<span style=\"color: rgba(0, 0, 0, 1);\"> id)\n\n        result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(query)\n        item </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> result.scalars().first()\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> item</pre>\n</div>\n<p>对于删除的数据，我们也可以类似的处理对比进行了。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy.orm <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> Session, Query\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy.ext.asyncio <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> AsyncSession\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> delete as sa_delete, update as sa_update\n\nasync </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> delete_byid(self, db: AsyncSession, id: PrimaryKeyType) -&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> bool:\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">根据主键删除一个对象\n    \n    :param id: 主键值\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n    \n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\">对id的主键进行类型转换，self._pk_type在构造函数的初始化中获取</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        id </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self._pk_type(id)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">except</span><span style=\"color: rgba(0, 0, 0, 1);\"> Exception:\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">raise</span> ValueError(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Invalid primary key type: {id}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    del_query: sa_delete\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> isinstance(id, str):\n        del_query </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> sa_delete(self.model).where(\n            func.lower(self.model.id) </span>==<span style=\"color: rgba(0, 0, 0, 1);\"> id.lower()\n        )\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        del_query </span>= sa_delete(self.model).where(self.model.id ==<span style=\"color: rgba(0, 0, 0, 1);\"> id)\n\n    result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(del_query)\n\n    await db.commit()\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> result.rowcount &gt; 0</pre>\n</div>\n<p>对于提供多条件的查询或者过滤，我们可以使用<strong>where</strong>函数或者<strong>filter</strong>函数，在 SQLAlchemy 中，<code>select(...).where(...)</code>&nbsp;和&nbsp;<code>select(...).filter(...)</code>&nbsp;都用于构造查询条件，如下所示等效。</p>\n<div class=\"cnblogs_code\">\n<pre>query = select(self.model).where(self.model.id ==<span style=\"color: rgba(0, 0, 0, 1);\"> id)\n\nquery </span>= select(self.model).filter(self.model.id == id)</pre>\n</div>\n<p>我们可以通过sqlAlchemy的and_和or_函数来进行组合多个条件。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> ( Table,Column,and_,or_,asc,desc,select,func,distinct,text, Integer)\n\n....\n    match expression:\n        case </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">and</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n            query </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(\n                select(self.model)\n               <span style=\"color: rgba(255, 0, 0, 1);\"><strong> .filter(and_(</strong></span></span><span style=\"color: rgba(255, 0, 0, 1);\"><strong>*</strong></span><span style=\"color: rgba(0, 0, 0, 1);\"><span style=\"color: rgba(255, 0, 0, 1);\"><strong>where_list))</strong></span>\n                .order_by(</span>*<span style=\"color: rgba(0, 0, 0, 1);\">order_by_list)\n            )\n        case </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">or</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n            query </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(\n                select(self.model).<strong><span style=\"color: rgba(255, 0, 0, 1);\">filter(or_(</span></strong></span><strong><span style=\"color: rgba(255, 0, 0, 1);\">*where_list))</span></strong>.order_by(*<span style=\"color: rgba(0, 0, 0, 1);\">order_by_list)\n            )</span></pre>\n</div>\n<p>Python的SqlAlchemy提供&nbsp;InstrumentedAttribute 对象来操作多个条件，如我们对于一些多条件的处理，可以利用它来传递多个参数。</p>\n<div class=\"cnblogs_code\">\n<pre>    async <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> get_all_by_attributes(\n        self, db: AsyncSession, </span>*attributes: InstrumentedAttribute, sorting: str = <span style=\"color: rgba(128, 0, 0, 1);\">\"\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    ) </span>-&gt; List[ModelType] |<span style=\"color: rgba(0, 0, 0, 1);\"> None:\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">根据列名称和值获取相关的对象列表\n\n        :param sorting: 格式：name asc 或 name asc,age desc\n        :param attributes: SQLAlchemy InstrumentedAttribute objects，可以输入多个条件\n        例子：User.id != 1 或者 User.username == \"JohnDoe\"\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\n        order_by_list </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> parse_sort_string(sorting, self.model)\n        query </span>= select(self.model).filter(and_(*attributes)).order_by(*<span style=\"color: rgba(0, 0, 0, 1);\">order_by_list)\n        \n        result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(query)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> result.scalars().all()</pre>\n</div>\n<p>例如，对于 模型&nbsp;Material 对象，我们对它进行多个条件的查询处理，如下所示，红色部分为 *attributes: InstrumentedAttribute 参数。</p>\n<div class=\"cnblogs_code\">\n<pre>items =<span style=\"color: rgba(0, 0, 0, 1);\"> await super().get_all_by_attributes(\n    db,\n<span style=\"color: rgba(255, 0, 0, 1);\"><strong>    Material.id </strong></span></span><span style=\"color: rgba(255, 0, 0, 1);\"><strong>== vercol.id,\n    Material.vercol == vercol.vercol,\n    Material.ischecked == 0,\n    Material.status ==</strong></span><span style=\"color: rgba(0, 0, 0, 1);\"><span style=\"color: rgba(255, 0, 0, 1);\"><strong> 0,</strong></span>\n)</span></pre>\n</div>\n<p>同样我们可以利用它来获取数量，或者判断多条件的记录是否存在。</p>\n<p><img alt=\"image\" height=\"532\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251225103430193-1873231330.png\" width=\"944\" /></p>\n<p>&nbsp;在数据插入或者更新的操作中，我们可以接受对象类型或者字典类型的参数对象，因此方法如下所示。</p>\n<div class=\"cnblogs_code\">\n<pre>   async <span style=\"color: rgba(0, 0, 255, 1);\">def</span> update(self, db: AsyncSession, obj_in: DtoType | dict[str, Any]) -&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> bool:\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">更新对象\n        \n        :param obj_in: 对象输入数据,可以是 DTO 对象或字典\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> isinstance(obj_in, dict):\n                obj_id </span>= obj_in.get(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> obj_id <span style=\"color: rgba(0, 0, 255, 1);\">is</span><span style=\"color: rgba(0, 0, 0, 1);\"> None:\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">raise</span> ValueError(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">id is required for update</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                update_data </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> obj_in\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n                obj_id </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> obj_in.id\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> update_data = vars(obj_in)  </span>\n                update_data = obj_in.model_dump(exclude_unset=<span style=\"color: rgba(0, 0, 0, 1);\">True)\n\n            query </span>= select(self.model).filter(self.model.id ==<span style=\"color: rgba(0, 0, 0, 1);\"> obj_id)\n            result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(query)\n            db_obj </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> result.scalars().first()\n\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> db_obj:\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 更新对象字段</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">for</span> field, value <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> update_data.items():\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 跳过以 \"_\" 开头的私有属性</span>\n                    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> field.startswith(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">_</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">):\n                        </span><span style=\"color: rgba(0, 0, 255, 1);\">continue</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                    setattr(db_obj, field, value)\n\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 处理更新前的回调处理</span>\n<span style=\"color: rgba(255, 0, 0, 1);\"><strong>                self.on_before_update(update_data, db_obj)\n                </strong></span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 提交事务</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">                await db.commit()\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> True\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> False\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">except</span><span style=\"color: rgba(0, 0, 0, 1);\"> SQLAlchemyError as e:\n            self.logger.error(f</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">update 操作出现错误: {e}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n            await db.rollback()  </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 确保在出错时回滚事务</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">return</span> False</pre>\n</div>\n<p>我们在插入或者更新数据的时候，一般会默认更新一些字段，如创建人，创建日期、编辑人，编辑日期等信息，我们可以把它单独作为一个可以给子类重写的函数，基类做一些默认的处理。</p>\n<div class=\"cnblogs_code\">\n<pre>    <span style=\"color: rgba(0, 0, 255, 1);\">def</span> on_before_update(self, update_data: dict[str, Any], db_obj: ModelType) -&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> None:\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">更新对象前的回调函数，子类可以重写此方法\n\n        可通过 setattr(db_obj, field, value) 设置字段值\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n        \n        setattr(db_obj, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">edittime</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, datetime.now())\n        user :CurrentUserIns  </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> get_current_user()\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> user:\n            setattr(db_obj, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">editor</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, user.fullname)\n            setattr(db_obj, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">editor_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, user.id)\n\n            setattr(db_obj, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">company_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, user.company_id)\n            setattr(db_obj, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">companyname</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, user.companyname)</pre>\n</div>\n<p>有时候，如果我们需要获取某个字段非重复的列表，用来做为动态下拉列表的数据，那么我们可以通过下面函数封装下。</p>\n<div class=\"cnblogs_code\">\n<pre>    async <span style=\"color: rgba(0, 0, 255, 1);\">def</span> get_field_list(self, db: AsyncSession, field_name: str) -&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> Iterable[str]:\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">获取指定字段值的唯一列表\n\n        :param field_name: 字段名称\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\n        field </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> getattr(self.model, field_name)\n        query </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> select(distinct(field))\n        result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(query)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> result.scalars().all()</pre>\n</div>\n<p>&nbsp;</p>\n<h3>3、多表联合的处理操作&nbsp;</h3>\n<p>多表操作，也是我们经常碰到的处理方式，如对于字典类型和字典项目，他们是两个表，需要联合起来获取数据，那么就需要多表的联合操作。</p>\n<p><img alt=\"image\" height=\"326\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251225110211988-1085898697.png\" width=\"238\" /></p>\n<p>&nbsp;如下是字典CRUD类中，联合字典类型获取数据的记录处理。</p>\n<div class=\"cnblogs_code\">\n<pre>    async <span style=\"color: rgba(0, 0, 255, 1);\">def</span> get_dict_by_typename(self, db: AsyncSession, dicttype_name: str) -&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> dict:\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">根据字典类型名称获取所有该类型的字典列表集合</span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n        result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(\n            select(self.model)\n            <span style=\"color: rgba(255, 0, 0, 1);\"><strong>.join(DictType, DictType.id </strong></span></span><span style=\"color: rgba(255, 0, 0, 1);\"><strong>== self.model.dicttype_id)</strong></span>  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 关联字典类型表</span>\n            <strong><span style=\"color: rgba(255, 0, 0, 1);\">.filter(DictType.name == dicttype_name)</span> </strong> <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 过滤字典类型名称</span>\n            .order_by(DictData.seq)  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 排序</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        )\n        items </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> result.scalars().all()\n\n        dict </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> {}\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> info <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> items:\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> info.name <span style=\"color: rgba(0, 0, 255, 1);\">not</span> <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> dict:\n                dict[info.name] </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> info.value\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> dict</pre>\n</div>\n<p>如果我们需要对某个表的递归获取树列表，可以如下处理</p>\n<div class=\"cnblogs_code\">\n<pre>    async <span style=\"color: rgba(0, 0, 255, 1);\">def</span> get_tree(self, db: AsyncSession, pid: str) -&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> list[DictType]:\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">获取字典类型一级列表及其下面的内容</span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n\n        <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用三元运算符将 pid 设为 \"-1\"（如果 pid 是 null 或空白）或保持原值</span>\n        pid = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">-1</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">if</span> <span style=\"color: rgba(0, 0, 255, 1);\">not</span> pid <span style=\"color: rgba(0, 0, 255, 1);\">or</span> pid.strip() == <span style=\"color: rgba(128, 0, 0, 1);\">\"\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> pid\n        result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(\n            select(self.model)\n            .filter(self.model.pid </span>==<span style=\"color: rgba(0, 0, 0, 1);\"> pid)\n            .options(selectinload(DictType.children))\n        )\n        nodes </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> result.scalars().all()\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> nodes</pre>\n</div>\n<p>我们来假设用户和文章的示例表结构（ORM 模型，如下所示。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> User(Base):\n    </span><span style=\"color: rgba(128, 0, 128, 1);\">__tablename__</span> = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">users</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    id </span>= Column(Integer, primary_key=True, index=<span style=\"color: rgba(0, 0, 0, 1);\">True)\n    name </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Column(String)\n    email </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Column(String)\n<span style=\"color: rgba(255, 0, 0, 1);\">    articles </span></span><span style=\"color: rgba(255, 0, 0, 1);\">= <strong>relationship</strong>(\"Article\", back_populates=\"author\")\n\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Article(Base):\n    </span><span style=\"color: rgba(128, 0, 128, 1);\">__tablename__</span> = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">articles</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    id </span>= Column(Integer, primary_key=True, index=<span style=\"color: rgba(0, 0, 0, 1);\">True)\n    title </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Column(String)\n    content </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Column(Text)\n<span style=\"color: rgba(255, 0, 0, 1);\">    user_id </span></span><span style=\"color: rgba(255, 0, 0, 1);\">= Column(Integer, <strong>ForeignKey</strong>(\"users.id\"))\n    author = <strong>relationship</strong>(\"User\", back_populates=\"articles\")</span></pre>\n</div>\n<p>我们可以通过下面函数处理获得相关的记录集合。</p>\n<div class=\"cnblogs_code\">\n<pre>async <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> get_user_articles(db: AsyncSession):\n    stmt </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> (\n        select(User, Article)\n        .<span style=\"color: rgba(255, 0, 0, 1);\"><strong>join</strong></span>(Article, Article.user_id </span>==<span style=\"color: rgba(0, 0, 0, 1);\"> User.id)\n    )\n    result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(stmt)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> result.all()   <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> [<strong><span style=\"color: rgba(255, 0, 0, 1);\">(User(), Article()), .</span></strong>..]</span></pre>\n</div>\n<p>如果需要可以使用outer_join函数处理</p>\n<div class=\"cnblogs_code\">\n<pre>async <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> get_users_with_articles(db: AsyncSession):\n    stmt </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> (\n        select(User, Article)\n        .<span style=\"color: rgba(255, 0, 0, 1);\"><strong>outerjoin</strong></span>(Article, Article.user_id </span>==<span style=\"color: rgba(0, 0, 0, 1);\"> User.id)\n    )\n    result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(stmt)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> result.all()  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 用户即便没有文章也会出现</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>如果我们需要获取有文章的所有用户，如下所示。</p>\n<div class=\"cnblogs_code\">\n<pre>async <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> get_users_with_articles(db: AsyncSession):\n    stmt </span>= select(User).options(<span style=\"color: rgba(255, 0, 0, 1);\"><strong>selectinload</strong></span>(User.articles))  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 自动 load 关联</span>\n    result =<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(stmt)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> result.scalars().all()</pre>\n</div>\n<p><code>selectinload</code> 会执行两次 SQL，但效率高，不会产生笛卡尔积，非常适合集合查询。</p>\n<p>多表链式 Join的处理，可以获得两个表的不同信息进行组合。</p>\n<div class=\"cnblogs_code\">\n<pre>async <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> get_articles_with_author(db: AsyncSession):\n    stmt </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> (\n        select(Article.title, User.name.label(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">author</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">))\n        .join(User, Article.user_id </span>==<span style=\"color: rgba(0, 0, 0, 1);\"> User.id)\n    )\n    rows </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(stmt)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(255, 0, 0, 1);\"><strong>rows.mappings().all()</strong></span>  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 以 dict 形式返回 [{'title':..., 'author':...}]</span></pre>\n</div>\n<p>带筛选条件与分页的处理实现，如下所示</p>\n<div class=\"cnblogs_code\">\n<pre>async <span style=\"color: rgba(0, 0, 255, 1);\">def</span> search_articles(db: AsyncSession, keyword: str, page: int = 1, size: int = 10<span style=\"color: rgba(0, 0, 0, 1);\">):\n    stmt </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> (\n        select(Article, User.name.label(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">author</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">))\n        .join(User)\n        .filter(Article.title.contains(keyword))\n        .offset((page </span>- 1) *<span style=\"color: rgba(0, 0, 0, 1);\"> size)\n        .limit(size)\n    )\n    result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(stmt)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> result.mappings().all()</pre>\n</div>\n<p>&nbsp;</p>\n<p>对于权限管理系统来说，一般有用户、角色，以及用户角色的中间表，一般来说他们的关系如下</p>\n<p><img alt=\"image\" height=\"363\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251225122040874-818263456.png\" width=\"729\" /></p>\n<p>&nbsp;在界面中一般会提供选择用户的操作关联，如角色中维护用户列表。</p>\n<p><img alt=\"image\" height=\"426\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251225121122302-651245416.png\" width=\"481\" /></p>\n<p>&nbsp;我们来看看这个在SQLAlchemy最佳实践是如何的操作。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> Table, Column, Integer, ForeignKey\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy.orm <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> relationship, Mapped, mapped_column\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> database <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> Base\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> --- 中间表写法 ---</span>\nrole_user =<span style=\"color: rgba(0, 0, 0, 1);\"> Table(\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">role_user</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    Base.metadata,\n    Column(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">user_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, ForeignKey(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">users.id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>), primary_key=<span style=\"color: rgba(0, 0, 0, 1);\">True),\n    Column(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">role_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, ForeignKey(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">roles.id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>), primary_key=<span style=\"color: rgba(0, 0, 0, 1);\">True)\n)\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> User(Base):\n    </span><span style=\"color: rgba(128, 0, 128, 1);\">__tablename__</span> = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">users</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    id: Mapped[int] </span>= mapped_column(primary_key=<span style=\"color: rgba(0, 0, 0, 1);\">True)\n    username: Mapped[str] </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> mapped_column()\n\n    roles: Mapped[list[</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Role</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>]] =<span style=\"color: rgba(0, 0, 0, 1);\"> relationship(\n        secondary</span>=<span style=\"color: rgba(0, 0, 0, 1);\">role_user,\n        back_populates</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">users</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n        lazy</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">selectin</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    )\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Role(Base):\n    </span><span style=\"color: rgba(128, 0, 128, 1);\">__tablename__</span> = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">roles</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    id: Mapped[int] </span>= mapped_column(primary_key=<span style=\"color: rgba(0, 0, 0, 1);\">True)\n    name: Mapped[str] </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> mapped_column()\n\n    users: Mapped[list[User]] </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> relationship(\n        secondary</span>=<span style=\"color: rgba(0, 0, 0, 1);\">role_user,\n        back_populates</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">roles</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n        lazy</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">selectin</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    )</span></pre>\n</div>\n<p>在 SQLAlchemy 声明多对多关系时，<code>secondary</code> 参数既可以填 <strong>字符串形式的表名</strong>，也可以填 <strong>已经定义好的中间表对象（Table 对象）。</strong></p>\n<p><strong>① econdary=\"role_user\" —— 使用字符串表名</strong></p>\n<div class=\"cnblogs_code\">\n<pre>roles = relationship(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Role</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, secondary=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">role_user</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, back_populates=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">users</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>)</pre>\n</div>\n<p><strong>② secondary=role_user —— 传入中间表对象（推荐方式）</strong></p>\n<div class=\"cnblogs_code\">\n<pre>role_user =<span style=\"color: rgba(0, 0, 0, 1);\"> Table(\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">role_user</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    Base.metadata,\n    Column(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">user_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, ForeignKey(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">users.id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>), primary_key=<span style=\"color: rgba(0, 0, 0, 1);\">True),\n    Column(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">role_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, ForeignKey(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">roles.id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>), primary_key=<span style=\"color: rgba(0, 0, 0, 1);\">True)\n)\n\nroles </span>= relationship(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Role</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, secondary=role_user, back_populates=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">users</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>)</pre>\n</div>\n<p>对于如果获取对应角色的用户记录，我们可以通过下面方式获取（通过连接中间表的方式）</p>\n<div class=\"cnblogs_code\">\n<pre>async <span style=\"color: rgba(0, 0, 255, 1);\">def</span> get_users_by_role(db: AsyncSession, role_id: int) -&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> list[User]:\n    stmt </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> (\n        select(User)\n        .join(role_user, role_user.c.user_id </span>==<span style=\"color: rgba(0, 0, 0, 1);\"> User.id)\n        .where(role_user.c.role_id </span>==<span style=\"color: rgba(0, 0, 0, 1);\"> role_id)\n    )\n    result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(stmt)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> result.scalars().all()</pre>\n</div>\n<p>也可以下面的方式进行处理（使用 relationship any()），效果是一样的。</p>\n<div class=\"cnblogs_code\">\n<pre>select(User).filter(User.roles.any(id=role_id))</pre>\n</div>\n<p>如果需要写入用户、角色的关联关系，我们可以使用下面方法来通过中间表进行判断并写入记录。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> select, insert\n\nasync </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> add_users_to_role(db: AsyncSession, role_id: int, user_ids: list[int]):\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1️⃣ 查询已有关联 user_id</span>\n    stmt = select(role_user.c.user_id).where(role_user.c.role_id ==<span style=\"color: rgba(0, 0, 0, 1);\"> role_id)\n    res </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(stmt)\n    existing_user_ids </span>= {row[0] <span style=\"color: rgba(0, 0, 255, 1);\">for</span> row <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> res.fetchall()}\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2️⃣ 过滤出新的 user_id</span>\n    new_user_ids = [uid <span style=\"color: rgba(0, 0, 255, 1);\">for</span> uid <span style=\"color: rgba(0, 0, 255, 1);\">in</span> user_ids <span style=\"color: rgba(0, 0, 255, 1);\">if</span> uid <span style=\"color: rgba(0, 0, 255, 1);\">not</span> <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> existing_user_ids]\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> <span style=\"color: rgba(0, 0, 255, 1);\">not</span><span style=\"color: rgba(0, 0, 0, 1);\"> new_user_ids:\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> 0  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 没有新增</span>\n\n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3️⃣ 批量插入</span>\n    values = [{<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">user_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: uid, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">role_id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: role_id} <span style=\"color: rgba(0, 0, 255, 1);\">for</span> uid <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> new_user_ids]\n    stmt </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> insert(role_user).values(values)\n    await db.execute(stmt)\n    await db.commit()\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> len(new_user_ids)</pre>\n</div>\n<p>如果只是单个记录的插入，可以利用下面的方式处理。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> select, insert\n\nasync </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> add_user_to_role(db: AsyncSession, role_id: int, user_id: int) -&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> bool:\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1️⃣ 检查是否已存在关联</span>\n    stmt =<span style=\"color: rgba(0, 0, 0, 1);\"> select(role_user).where(\n        role_user.c.role_id </span>==<span style=\"color: rgba(0, 0, 0, 1);\"> role_id,\n        role_user.c.user_id </span>==<span style=\"color: rgba(0, 0, 0, 1);\"> user_id\n    )\n    res </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(stmt)\n    exists </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> res.first()\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> exists:\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> False  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 已存在，不再插入</span>\n\n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2️⃣ 插入记录</span>\n    stmt = insert(role_user).values(user_id=user_id, role_id=<span style=\"color: rgba(0, 0, 0, 1);\">role_id)\n    await db.execute(stmt)\n    await db.commit()\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> True</pre>\n</div>\n<p>删除用户角色的关联关系，通过下面函数进行处理即可</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> and_, or_, select\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> sqlalchemy <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> delete as sa_delete, update as sa_update\n\n    async </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> remove_user(self, db: AsyncSession, role_id: int, user_id: int) -&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> bool:\n        </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">移除角色-用户关联</span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n        stmt </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> sa_delete(user_role).where(\n            and_(\n                user_role.c.role_id </span>==<span style=\"color: rgba(0, 0, 0, 1);\"> role_id,\n                user_role.c.user_id </span>==<span style=\"color: rgba(0, 0, 0, 1);\"> user_id,\n            )\n        )\n        result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> await db.execute(stmt)\n        await db.commit()\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> rowcount 返回删除行数</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span> result.rowcount &gt; 0</pre>\n</div>\n<p>&nbsp;</p>\n<p>以上就是对于在Python+FastAPI的后端项目中使用SqlAlchemy操作数据的几种常见方式，包括单表处理，多表关联、中间表的数据维护和定义等内容，是我们在操作常规数据的时候，经常碰到的几种方式。</p>\n<p>希望上文对你有所启发和帮助，感谢阅读。</p>\n</div>\n<div id=\"MySignature\">\n    <div style=\"border-right-color: #cccccc; border-right-width: 1px; border-right-style: solid; padding-right: 5px; border-top-color: #cccccc; border-top-width: 1px; border-top-style: solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left-color: #cccccc; border-left-width: 1px; border-left-style: solid; width: 98%; padding-top: 4px; border-bottom-color: #cccccc; border-bottom-width: 1px; border-bottom-style: solid; background-color: #eeeeee;\">\n    <img align=\"top\" alt=\"\" src=\"http://www.cnblogs.com/Images/OutliningIndicators/None.gif\" />\n    <span style=\"color: #000000;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"></span>\n     专注于代码生成工具、.Net/Python 框架架构及软件开发，以及各种Vue.js的前端技术应用。著有Winform开发框架/混合式开发框架、微信开发框架、Bootstrap开发框架、ABP开发框架、SqlSugar开发框架、Python开发框架等框架产品。\n     <br />&nbsp;&nbsp;转载请注明出处：撰写人：伍华聪&nbsp;&nbsp;<a href=\"http://www.iqidi.com/\" target=\"_blank\">http://www.iqidi.com</a>&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;</span></div>\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2025-12-25 11:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wuhuacong\">伍华聪</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "女友怒骂国内不能用Claude Code，于是我给她做了一个",
      "link": "https://www.cnblogs.com/yupi/p/19397182",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19397182\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 11:28\">\n    <span>女友怒骂国内不能用Claude Code，于是我给她做了一个</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"女友怒骂国内不能用Claude Code，于是我给她做了一个\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202512/2225420-20251225112813033-1712384844.png\" />\n        最近女友开始学习 AI 编程了（被我带的），她听说 Claude Code 这个 AI 编程工具很牛掰，结果试了下发现得要国外的 Claude 账号才能登陆。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-heading\"><span class=\"md-plain\">大家好，我是程序员鱼皮。最近女友开始学习 AI 编程了（被我带的），她听说 Claude Code 这个 AI 编程工具很牛掰，结果试了下发现得要国外的 Claude 账号才能登陆。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后她就骂骂咧咧地跟我吐槽。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">展现男友力的时候到了，于是我开玩笑地说：别难过了，要不我给你做一个 Claude Code 算了？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">结果，她当真了！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我 ↓</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">没办法，只能试一试了，毕竟谁希望圣诞节这两天让自家人难过呢？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">正好这两天国产 AI 大模型 GLM-4.7 发布了，我看网上很多博主都在吹什么 “国内最强的编程模型”、“最强的开源模型”、“Claude 的最佳平替”，甚至说是超过了 GPT-5.2 和 Claude Sonnet 4.5。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你说国产最强也就算了，超过 Claude 这我能信么？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">那正好，我就尝试用 GLM-4.7 来做个自己的 AI 编程工具吧，对标 Claude Code 那种的，看看 GLM-4.7 到底几斤几两。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来，就让我们一起 <span class=\"md-pair-s \"><strong>用 GLM-4.7 + Claude Code</strong><span class=\"md-plain\"> 开发一个 <span class=\"md-pair-s \"><strong>基于 GLM-4.7 的仿 Claude Code</strong><span class=\"md-plain\"> 的 AI 编程工具。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">项目开始前，先起一个响当当的名字，就叫 <span class=\"md-pair-s\"><code>Yupi Code</code><span class=\"md-plain\"> 吧！</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来，我们将遵循这套《鱼皮 AI Vibe Coding 开发仿 Claude Code 的 Yupi Code》流程，不写一行代码，一步一步把 “Claude Code” 做出来！</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">环境准备 =&gt; 安装工具和配置环境，能够 Vibe Coding</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">技术调研 =&gt; 确认满足生成需求</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">设计开发 =&gt; 包括方案设计、生成代码、修复 Bug，得到 MVP 最小可行产品</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">版本控制 =&gt; 防止后续改动出问题</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">优化能力 =&gt; 支持更多对标 Claude Code 的功能，比如联网搜索、流式输出、深度思考等</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">环境准备</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">智谱的 GLM-4.7 兼容多款编码工具，除 Claude Code 外，还支持 Cursor、Cline 等主流编码工具，灵活适配多种开发场景。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">给 Claude Code 接入 GLM 也很简单，1 分钟搞定。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先打开终端，输入一行命令安装 Claude Code：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span><span class=\"cm-builtin\">npm&nbsp;install&nbsp;<span class=\"cm-attribute\">-g&nbsp;@anthropic-ai/claude-code</span></span></span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后执行 <span class=\"md-pair-s\"><code>claude</code><span class=\"md-plain\"> 命令打开程序，默认是需要登录 Claude 账号的，否则无法使用：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过没关系，让我们把它背后的 AI 大模型换成国内的 GLM-4.7。首先进入 <span class=\"md-pair-s\"><code>{用户目录}/.claude</code><span class=\"md-plain\"> 目录，创建一个 <span class=\"md-pair-s\"><code>settings.json</code><span class=\"md-plain\"> 配置文件： </span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后修改配置文件中的内容如下，记得替换成你自己的 API Key：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">API Key 直接到智谱开发平台获取即可：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">指路：<span class=\"md-link md-pair-s\"><a href=\"https://bigmodel.cn/\" rel=\"noopener nofollow\">https://bigmodel.cn/</a></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来就可以愉快地使用了~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了这种方式外，官方文档还提供了更简单的方式，直接使用自动化助手，按照指引就能完成环境配置：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">技术调研</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果要完全利用 AI 开发项目，有几个难点：</span></p>\n<ol class=\"ol-list\" start=\"\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">项目需要包含完整前后端，需要大模型有较强的 <span class=\"md-pair-s \"><strong>编码能力</strong></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">需要让后端项目对接 AI 大模型，每个大模型的接入和开发方式不同，需要让 AI <span class=\"md-pair-s \"><strong>读取文档</strong><span class=\"md-plain\"> 理解最新的开发方式</span></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果想要优化界面效果，还需要 <span class=\"md-pair-s \"><strong>图片理解能力</strong><span class=\"md-plain\">，给 AI 一张图片就能让它还原</span></span></span></p>\n</li>\n</ol>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在正式开发前，我们要确认 GLM-4.7 和 Claude Code 的配合能够满足这些能力要求。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">根据智谱官方介绍，Claude Code 中内置了智谱专属的 MCP 工具，不需要开发者自己安装。包括 <span class=\"md-pair-s \"><strong>搜索和网页读取</strong><span class=\"md-plain\"> 能力、能够直接解析截图/设计稿/报错图的 <span class=\"md-pair-s \"><strong>视觉理解能力</strong><span class=\"md-plain\">。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">让我们依次测试一下，首先是网页搜索能力，紧跟时事：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">测试网页读取能力，让它来读取我们编程导航网站的信息：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">测试图片理解能力，我给 AI 传了一张 “从夯到拉排行榜的背景图”：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 的理解还是很准确的，具体文字也读取出来了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OK，几个能力都满足要求，下面让我们进入方案设计和开发阶段。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">设计开发</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先创建一个干净的项目目录 <span class=\"md-pair-s\"><code>yupi-code</code><span class=\"md-plain\">，打开终端并进入该目录：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后输入提示词：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>帮我开发一个类似 Claude Code 的终端 AI 编程工具，能够使用 GLM-4.7 模型帮用户回答问题和生成代码</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">一般来说，整个项目的第一句提示词是最重要的，如果我要开发一个复杂的商业项目，肯定会好好打磨一下这句提示词，少说写个几百字（之前看过我 <span class=\"md-meta-i-c  md-link\"><a href=\"https://mp.weixin.qq.com/s/cd7K9WQiOkP7AJglZ1b1Ng\" rel=\"noopener nofollow\"><span class=\"md-plain\">AI 程序员技术练兵场项目</span></a><span class=\"md-plain\"> 的同学应该知道）。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但测试 AI 模型时，我喜欢反其道而行之，站在大多数用户的角度，故意输入一句简单的提示词，看看 AI 能不能引导我来生成满足需求的项目。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">果然，AI 判断这是一个复杂的项目，想要进入 <span class=\"md-pair-s \"><strong>计划模式</strong><span class=\"md-plain\"> —— 先明确需求、设计方案再开发。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后我们需要通过选择来明确需求，并让 AI 生成方案。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Claude Code 的交互做的还是不错的，先选择编程语言，建议老老实实选 AI 推荐的第一个：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来是选择项目要具有的功能。如果是以前，我可能会先让 AI 只开发基础对话功能，跑通流程后再添加其他功能。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但现在我对 AI 有了更多的信心，<span class=\"md-pair-s \"><strong>咱就把所有功能全都选上，干就完了！</strong></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">其他设置就不多说了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">选择完成后，AI 给出了详细的实现计划，一定要仔细阅读：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可以直接执行，或者给 AI 进一步的指导。比如我让 AI 生成的应用去调用智谱 Coding Plan 套餐的 BASE URL，能节约一些成本，并且给 AI 提供了一个官方的 API 文档，便于 AI 生成准确的代码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">确认后开始执行，AI 会先调用内置的工具来搜索和解析文档：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后 AI 列出了一个 Todo List，并且一步步生成代码和文档：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这期间如果你发现有严重的问题，比如发现 AI 生成的代码已经完全偏离预期了，那么就尽早暂停或者人工输入提示词来引导 AI。如果发现 AI 只是有一小块代码生成的不对，我的建议是先忍着，反正最后 AI 大概率会自己发现问题并修复。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">过了大概十几分钟后，AI 生成完成，还告诉了我使用方法：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可惜我根本懒得看，我直接把 API Key 交给 AI 帮我运行不就好了？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Vibe Coding 开发模式下，我多自己做一件事，都是对 AI 的不尊重。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">输入提示词：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>我的 API key 是 xxxxxxx，请你帮我运行</span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后，翻车了。。。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不慌，直接让 AI 自己检查并修复错误。而且为了使用方便，应该提供一个快速启动脚本，能够让我像运行 Claude Code 一样，一行命令启动 AI 编程工具。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">提示词：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>帮我检查并修复项目中的错误，并创建一个可以像 Claude 一样让用户在命令行输入 \"yupicode\" 就能启动程序的快捷脚本</span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">几分钟后，AI 修复完成，并且提供了一个 <span class=\"md-pair-s\"><code>yupicode</code><span class=\"md-plain\"> 脚本：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我打开一个新的终端，然后运行 <span class=\"md-pair-s\"><code>yupicode</code><span class=\"md-plain\"> 脚本，尝试和 AI 对话：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你别说，效果还不错啊！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还像 Claude Code 一样提供了一些命令，比如清空对话历史、查看帮助之类的：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">看到这里，我感觉项目已经基本可用了。建议给项目上个 Git 来版本控制，防止后面的改动出问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">什么？你不知道 Git 是什么？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">没关系，直接交给 AI 吧：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>现在项目已经基本可用了，帮我提交一个 git 版本，防止后续改动出问题</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">测试下来，目前的 Yupi Code 还有一些不足之处，比如不支持搜索：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来就让我们优化项目，增加更多 Claude Code 支持的能力。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">优化能力</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）先来添加网络搜索能力，直接把智谱的官方文档给它丢进去。提示词如下：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>现在好像不支持网络搜索，请参考<br /><span>https://docs.bigmodel.cn/api-reference/%E5%B7%A5%E5%85%B7-api/%E7%BD%91%E7%BB%9C%E6%90%9C%E7%B4%A2<br /><span>文档，增加网络搜索工具调用能力</span></span></span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">很快 AI 就添加了新功能，重新打开 yupicode 来验证下，正常生效了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）下面再优化下 AI 回复的效果，目前是卡一会儿然后直接输出完整回答，需要调整为流式输出的打字机效果。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">提示词：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>我希望在等待 AI 回复时，有一个转圈的小图标；并且 AI 的回复可以实时流式输出</span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 很快就搞定了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）GLM-4.7 进一步强化了交错式思考能力，引入 <span class=\"md-pair-s \"><strong>保留式思考</strong><span class=\"md-plain\"> 和 <span class=\"md-pair-s \"><strong>轮级思考</strong><span class=\"md-plain\">，让复杂任务执行更稳、更可控。我们也应该让 Yupi Code 输出模型的思考信息、工具调用信息等等，帮助用户了解情况。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">输入提示词：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>帮我输出模型思考的信息、以及工具调用信息，你可以通过官方文档来了解如何开发</span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">测试一下优化后的效果，比如 “介绍一下鱼皮的 AI 导航网站”，能很清晰地看到思考过程：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">大功告成</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">到这里，仿照 Claude Code 开发的 Yupi Code 就已经完成了，让我们用它来开发个小网站试试。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如来个动画学算法的 Demo，提示词：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>帮我开发一个学习冒泡排序算法的动画网站，使用 Q 版动漫的风格和吉伊卡哇感觉的配色</span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">效果如图，画风还是不错的，但要是之后大模型能自动生成图片插画并添加到网站中，就更好了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">再来开发个仿真的电子黑板，提示词：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>帮我开发一个仿真的电子黑板，用户可以在上面画画并导出为图片</span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">圣诞节了，鱼皮给大家画颗圣诞树，还附赠一个小礼物，这怎么能不算是程序员的浪漫呢~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<div class=\"md-hr md-end-block\"><hr /></div>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OK，这就是我 <span class=\"md-pair-s \"><strong>利用国产的 AI 大模型 GLM-4.7 + Claude Code</strong><span class=\"md-plain\"> 开发出一个 <span class=\"md-pair-s \"><strong>基于 GLM-4.7 的 Yupi Code</strong><span class=\"md-plain\"> 的全过程了。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我自己体验下来，GLM-4.7 相比于之前的国内大模型，在处理复杂任务的稳定性上有进步，即使遇到问题也会自动修复，让最终生成的代码可运行。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">而且 GLM-4.7 调用工具的能力也强化了，和 Claude Code 等 AI 编程工具打配合，直接内置了联网搜索、网页读取、解释图片等 AI 编程常用的能力，不需要自己再去找 MCP 来增强了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不得不说，作为一直关注智谱 AI 的忠实开发者，真的很能感受到他们这几个月来在 AI 编程方向的努力，我相信大家也是有目共睹。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过毕竟现在的 Yupi Code 是 AI 一把梭的，还有很多能优化完善的地方。如果后面有时间，大家也感兴趣的话，说不定我会好好打磨打磨这个工具把它开源出来。我的终极目标是，让基于 <span class=\"md-pair-s \"><strong>AI 大模型 GLM-4.7 + Claude Code</strong><span class=\"md-plain\"> 开发的基于 <span class=\"md-pair-s \"><strong>GLM-4.7 的 Yupi Code</strong><span class=\"md-plain\"> 编程工具，能够开发出一个基于 <span class=\"md-pair-s \"><strong>GLM-4.7 的</strong><span class=\"md-plain\"> 编程工具，比如 Yupi Son Code。我认为好的 AI 工具就是要能做到无限套娃，疯狂自举！</span></span></span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">听懂掌声~</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-meta-i-c md-link md-expand\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 11:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">199</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "EvalScope使用过程中的问题汇总",
      "link": "https://www.cnblogs.com/oten/p/19397129",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/oten/p/19397129\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 11:23\">\n    <span>EvalScope使用过程中的问题汇总</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1-自定义数据集使用时的keyerror问题\">1. 自定义数据集使用时的KeyError问题</h2>\n<h3 id=\"问题描述\">问题描述</h3>\n<p>使用自定义数据集评测时，配置<code>tasks: [\"CustomRetrieval\"]</code>会触发<code>KeyError</code>，报错信息如下：</p>\n<pre><code>KeyError: \"KeyError: 'CustomRetrieval' not found. Did you mean: EcomRetrieval?\"\n</code></pre>\n<h3 id=\"背景说明\">背景说明</h3>\n<ul>\n<li>EvalScope官方文档明确自定义数据集评测任务需指定为<code>CustomRetrieval</code>；</li>\n<li><code>./outputs</code>目录下已存在<code>CustomRetrieval</code>相关数据集；</li>\n<li>个人理解：该报错不影响评测结果生成，仅导致最终评测流程的汇总表格无法输出，整体无核心影响。</li>\n</ul>\n<h3 id=\"相关脚本\">相关脚本</h3>\n<pre><code class=\"language-python\">BASE_TASK_CFG4 = {\n    \"work_dir\": \"./outputs/bge_m3_T2Retrieval_eng\",\n    \"eval_backend\": \"RAGEval\",\n    \"eval_config\": {\n        \"tool\": \"MTEB\",\n        \"model\": [\n            {\n                \"model_name_or_path\": \"/gpu/huangyl3/Embedding_eval/model/bge_m3\",  # 循环时动态赋值\n                \"pooling_mode\": None,\n                \"max_seq_length\": 512,\n                \"prompt\": \"\",\n                \"model_kwargs\": {\"torch_dtype\": \"auto\"},\n                \"encode_kwargs\": {\"batch_size\": 128},\n                \"hub\": \"modelscope\"\n            }\n        ],\n        \"eval\": {\n            \"tasks\": [\"CustomRetrieval\"],\n            \"dataset_path\": \"/gpu/huangyl3/Embedding_eval/datas/T2Retrieval_eng/retrieval_data\",\n            \"verbosity\": 2,\n            \"overwrite_results\": True,\n            \"top_k\": 5\n        },\n    },\n}\n\nif __name__ == \"__main__\":\n    run_task(task_cfg=BASE_TASK_CFG4)\n</code></pre>\n<h2 id=\"2-两阶段测试脚本检索重排\">2. 两阶段测试脚本（检索+重排）</h2>\n<h3 id=\"相关脚本-1\">相关脚本</h3>\n<pre><code class=\"language-python\">from evalscope.run import run_task\ntwo_stage_task_cfg = {\n    \"work_dir\": \"./outputs/bge-reranker-v2-m3_T2Retrieval\",\n    \"eval_backend\": \"RAGEval\",\n    \"eval_config\": {\n        \"tool\": \"MTEB\",\n        \"model\": [\n            {\n                \"model_name_or_path\": \"/gpu/huangyl3/Embedding_eval/model/bge_m3\",\n                \"is_cross_encoder\": False,\n                \"max_seq_length\": 512,\n                \"model_kwargs\": {\"torch_dtype\": \"auto\"},\n                \"encode_kwargs\": {\n                    \"batch_size\": 64,\n                },\n            },\n            {\n                \"model_name_or_path\": \"/gpu/huangyl3/Embedding_eval/model/bge-reranker-v2-m3\",\n                \"is_cross_encoder\": True,\n                \"max_seq_length\": 512,\n                \"prompt\": \"为这个问题生成一个检索用的表示\",\n                \"model_kwargs\": {\"torch_dtype\": \"auto\"},\n                \"encode_kwargs\": {\n                    \"batch_size\": 32,\n                },\n            },\n        ],\n        \"eval\": {\n            \"tasks\": [\"T2Retrieval\"],\n            \"verbosity\": 2,\n            \"overwrite_results\": True,\n            \"top_k\": 5\n        },\n    },\n}\nrun_task(task_cfg=two_stage_task_cfg)\n</code></pre>\n<h2 id=\"3-model_kwargs中torch_dtype报错问题\">3. model_kwargs中torch_dtype报错问题</h2>\n<h3 id=\"问题描述-1\">问题描述</h3>\n<p>评测<code>gte-multilingual-mlm-base</code>、<code>Qwen3-Embedding-0.6B</code>、<code>bge-m3</code>模型（非检索数据集评测任务）时，原配置<code>\"model_kwargs\": {\"torch_dtype\": \"auto\"}</code>会触发报错；<br />\n临时解决方案：将<code>torch_dtype: auto</code>硬改为<code>dtype: float</code>可规避报错，但并非最优方案。</p>\n<h2 id=\"4-批量评测脚本的执行报错问题\">4. 批量评测脚本的执行报错问题</h2>\n<h3 id=\"问题描述-2\">问题描述</h3>\n<p>批量循环评测多个模型时，第一个模型可正常执行，后续模型会触发报错；仅改为枚举式写法可正常批量运行，报错原因暂未明确，需指导。</p>\n<h3 id=\"相关脚本-2\">相关脚本</h3>\n<pre><code class=\"language-python\">import time\nimport datetime\nfrom evalscope.run import run_task\n\n# ===================== 配置核心参数 =====================\n# 定义需要批量评测的模型列表（替换为你要测的模型名）\nMODEL_LIST = [\n    \"iic/gte-multilingual-mlm-base\",  # BGE系列示例\n    \"Qwen/Qwen3-Embedding-0.6B\",  # 多语言嵌入模型示例\n    \"BAAI/bge-m3\"  # GTE-large示例\n]\n\n\n# 基础配置模板（不包含model_name_or_path，循环时动态填充）\nBASE_TASK_CFG = {\n    \"work_dir\": \"/Users/hyl/PyCharmMiscProject/GAi/Embedding_eval/outputs\",\n    \"eval_backend\": \"RAGEval\",\n    \"eval_config\": {\n        \"tool\": \"MTEB\",\n        \"model\": [\n            {\n                \"model_name_or_path\": \"\",  # 循环时动态赋值\n                \"pooling_mode\": None,\n                \"max_seq_length\": 512,\n                \"prompt\": \"\",\n                \"model_kwargs\": {\"torch_dtype\": \"auto\"},\n                \"encode_kwargs\": {\"batch_size\": 128},\n                \"hub\": \"modelscope\"\n            }\n        ],\n        \"eval\": {\n            \"tasks\": [\"T2Retrieval\"],\n            \"verbosity\": 2,\n            \"overwrite_results\": True,\n            \"top_k\": 5,\n            \"hub\": \"modelscope\"\n        },\n    },\n}\n\n# ===================== 核心逻辑：循环评测 + 晚上自动执行 =====================\ndef run_batch_evaluation():\n    # 遍历模型列表，逐个执行评测\n    for idx, model_name in enumerate(MODEL_LIST):\n        try:\n            # 复制基础配置，避免修改原字典\n            task_cfg = BASE_TASK_CFG.copy()\n            # 动态替换模型名\n            task_cfg[\"eval_config\"][\"model\"][0][\"model_name_or_path\"] = model_name\n\n            # 打印当前评测进度\n            current_time = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            print(f\"\\n===== 开始评测第 {idx + 1}/{len(MODEL_LIST)} 个模型 =====\")\n            print(f\"批次时间：{current_time}\")\n            print(f\"模型名：{model_name}\")\n\n            # 记录评测开始时间（精确到毫秒）\n            start_time = datetime.datetime.now()\n            print(f\"评测开始时间：{start_time.strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]}\")  # 保留毫秒\n            print(\"===========================\\n\")\n\n            # 执行评测任务\n            run_task(task_cfg=task_cfg)\n\n            # 记录评测结束时间，计算总耗时\n            end_time = datetime.datetime.now()\n            duration = end_time - start_time\n            # 转换耗时为 时:分:秒 格式（总秒数转时分秒）\n            hours = duration.seconds // 3600\n            minutes = (duration.seconds % 3600) // 60\n            seconds = duration.seconds % 60\n            # 保留毫秒的耗时字符串\n            duration_str = f\"{hours}小时{minutes}分钟{seconds}秒（总耗时：{duration.total_seconds():.2f}秒）\"\n\n            # 打印完成提示 + 时间统计\n            print(f\"\\n===== 模型 {model_name} 评测完成 =====\")\n            print(f\"评测结束时间：{end_time.strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]}\")\n            print(f\"本次评测总耗时：{duration_str}\")\n            print(\"===========================\\n\")\n\n            # 可选：模型间间隔（避免频繁请求，比如休息5分钟）\n            time.sleep(300)\n\n        except Exception as e:\n            # 单个模型评测失败，记录错误并继续下一个\n            end_time = datetime.datetime.now()\n            print(f\"\\n===== 模型 {model_name} 评测失败 =====\")\n            print(f\"失败时间：{end_time.strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]}\")\n            print(f\"错误信息：{str(e)}\")\n            print(\"继续评测下一个模型...\\n\")\n            continue\n\n# ===================== 启动批量评测 =====================\nif __name__ == \"__main__\":\n    run_batch_evaluation()\n</code></pre>\n<h3 id=\"备注\">备注</h3>\n<p>持续更新.......</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 11:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/oten\">Oten</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MySQL 数据库日志总结(一)",
      "link": "https://www.cnblogs.com/zhangwencheng/p/19388036",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zhangwencheng/p/19388036\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 10:24\">\n    <span>MySQL 数据库日志总结(一)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"数据库服务日志概述介绍\">数据库服务日志概述介绍</h3>\n<p>任何一种数据库中，都会有各种各样的日志，记录这数据库工作的方方面面，以帮助数据库管理员追踪数据库曾经发生过的各种事件；</p>\n<p>主要是针对数据库server层产生的数据信息，主要用于记录和数据库服务运行本身有关的日志、以及SQL语句操作执行相关的日志；</p>\n<h3 id=\"据库服务日志常用分类\">据库服务日志常用分类</h3>\n<p>在MySQL数据库服务中，有4种不同的日志是最常用的日志类型，这些日志记录这数据库在不同方面的踪迹；</p>\n<p>日志信息查看方法：</p>\n<pre><code class=\"language-sql\">mysql&gt; show variables like '%log%';\n+------------------------------------------------+---------------------------------------------+\n| Variable_name                                  | Value                                       |\n+------------------------------------------------+---------------------------------------------+\n| general_log                                    | OFF                                         |\n| general_log_file                               | /data/3306/data/wenC-01.log                 |\n| log_error                                      | ./wenC-01.err                               |\n| log_bin                                        | ON                                          |\n| log_bin_basename                               | /data/3306/data/binlog                      |\n| log_bin_index                                  | /data/3306/data/binlog.index                |\n| slow_query_log                                 | OFF                                         |\n| slow_query_log_file                            | /data/3306/data/wenC-01-slow.log            |\n+------------------------------------------------+---------------------------------------------+\n</code></pre>\n<p>常用日志信息介绍：</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>日志名称</th>\n<th>解释说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>01</td>\n<td>general_log</td>\n<td>表示查询日志（通用日志），默认日志状态处于关闭，可以进行在线调整配置<br />作用：记录了客户端从会话连接开始，执行过的所有SQL语句信息；</td>\n</tr>\n<tr>\n<td>02</td>\n<td>log_error</td>\n<td>表示错误日志（运行日志），默认日志状态处于激活<br />作用：记录了数据库服务启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息；</td>\n</tr>\n<tr>\n<td>03</td>\n<td>log_bin</td>\n<td>表示二进制日志（binlog日志），默认日志状态处于激活（8.0之后）<br />作用：记录了所有的DDL语句和DML语句，但是不包括数据库查询语句；语句以事件的形式保存，描述了数据的更改过程，此日志对于灾难时的数据恢复起着极其重要的作用。</td>\n</tr>\n<tr>\n<td>04</td>\n<td>slow_query_log</td>\n<td>表示慢查询日志，记录了所有执行时间超过参数long_query_time设置值并且扫描记录数小于min_examined_row_limit的所有SQL语句的日志。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数据库服务日志信息配置\">数据库服务日志信息配置</h3>\n<h4 id=\"1分类日志信息配置通用日志general_log\"><strong>1.分类日志信息配置：通用日志（general_log）</strong></h4>\n<ul>\n<li><strong>1_1 日志信息基本配置：</strong></li>\n</ul>\n<pre><code class=\"language-sql\">general_log=OFF          \n-- 默认日志功能处于关闭，建议在需要做调试工作时（功能测试、语句审计）可以打开；\ngeneral_log_file=/data/3306/data/wenC-01.log  \n-- 定义日志文件存储的路径信息，建议日志文件路径与数据存放路径进行分离；\n\n# 修改日志默认状态（激活日志）：\nmysql &gt; set global general_log=1;\n</code></pre>\n<blockquote>\n<p>说明：企业真实环境，由于日志记录量比较大，所以不建议打开此日志记录功能，可以在有需要时打开，支持在线配置调整；</p>\n</blockquote>\n<h4 id=\"2分类日志信息配置错误日志log_error\"><strong>2.分类日志信息配置：错误日志（log_error）</strong></h4>\n<ul>\n<li><strong>2_1 日志信息基本配置</strong></li>\n</ul>\n<pre><code class=\"language-sql\">log_error=./wenC-01.err      \n-- 定义日志文件存储的路径信息，建议日志文件路径与数据存放路径进行分离；\n\n# 修改日志存储路径（永久配置）：\n[root@cheng ~]# vim /etc/my.cnf\nlog_error=/data/3306/log/wenC-01.err\n-- 配置文件编写完毕后，需要重启数据库服务生效\n\n# 模拟故障日志应用\n[root@cheng ~]# ll /data/3306/data/ibdata1 \n-rw-r----- 1 mysql mysql 12582912 Nov 16 17:46 /data/3306/data/ibdata1\n[root@cheng ~]# chmod 000 /data/3306/data/ibdata1\n[root@cheng ~]# /etc/init.d/mysqld restart\nShutting down MySQL............................... SUCCESS! \nStarting MySQL......................................... ERROR! The server quit without updating PID file (/data/3306/data/wenC-01.pid).\n[root@cheng ~]# tail -20 /data/3306/log/wenC-01.err\n2022-11-21T01:20:47.735040Z 1 [ERROR] [MY-012271] [InnoDB] The innodb_system data file 'ibdata1' must be writable\n2022-11-21T01:20:47.744091Z 1 [ERROR] [MY-012278] [InnoDB] The innodb_system data file 'ibdata1' must be writable\n2022-11-21T01:20:47.744808Z 1 [ERROR] [MY-010334] [Server] Failed to initialize DD Storage Engine\n2022-11-21T01:20:47.745739Z 0 [ERROR] [MY-010020] [Server] Data Dictionary initialization failed.\n2022-11-21T01:20:47.746526Z 0 [ERROR] [MY-010119] [Server] Aborting\n-- 根据错误日志的错误提示信息，进行错误信息进行分析，从而排查故障可能出现的原因；\n</code></pre>\n<blockquote>\n<p>说明：企业真实环境，日志处于默认激活记录状态，可以使用错误日志信息做故障诊断，记录错误信息级别为note warning error；</p>\n</blockquote>\n<h4 id=\"3分类日志信息配置二进制日志log_bin\"><strong>3.分类日志信息配置：二进制日志（log_bin）</strong></h4>\n<p>在进行增量恢复数据时，需要先了解什么是binlog日志，此日志文件其实就是用于记录对数据库进行操作更改的语句信息的；</p>\n<p>并且记录更改的语句信息以事件形式进行记录，但是需要注意的是查询相关的语句是不会被记录的，比如：select、show；</p>\n<p>然而作为所有对数据库的改操作事件信息都会被记录，比如：insert、update、create、drop。。。</p>\n<p><strong>查看数据库binlog日志配置参数：</strong></p>\n<p>进入到数据库服务系统环境中，可以使用命令进行查看binlog日志功能是否开启；</p>\n<pre><code class=\"language-sql\"># 未开启binlog日志功能时，查看系统binlog功能配置参数状态\nmysql&gt; show variables like '%log_bin%';\n+-----------------------------------------+-------+\n| Variable_name                           | Value |\n+-----------------------------------------+-------+\n| log_bin                                 | OFF   |\n| sql_log_bin                             | ON    |\n+-----------------------------------------+-------+\n3 rows in set (0.00 sec)\n--- 通过以上输出信息可以看到log_bin为off状态，表示binlog日志功能尚未开启\n\n# 已开启binlog日志功能后，查看系统binlog功能配置参数状态\nmysql&gt; show variables like '%log_bin%';\n+-----------------------------------------+-------+\n| Variable_name                           | Value |\n+-----------------------------------------+-------+\n| log_bin                                 | ON    |\n| sql_log_bin                             | ON    |\n+-----------------------------------------+-------+\n3 rows in set (0.00 sec)\n--- 通过以上输出信息可以看到log_bin为on状态，表示binlog日志功能已经开启\n</code></pre>\n<ul>\n<li><strong>3_1 日志信息基本配置</strong></li>\n</ul>\n<pre><code class=\"language-sql\">server_id=6\n-- 进行主从操作时，需要进行此信息配置；\nlog_bin=ON      \n-- 默认日志功能处于关闭状态\nlog_bin_basename=/data/3306/data/binlog        \n-- 定义日志文件存储的路径信息，建议日志文件路径与数据存放路径进行分离；\n\n# 配置信息简写方式：开启数据库binlog日志记录功能\n[root@cheng ~]# vim /etc/my.cnf\n-- 激活binlog日志记录功能，需要对数据库服务配置文件进行编辑修改\n[mysqld]\nserver_id=6\nlog_bin=/data/3306/binlog/mysql-bin\n-- 进行binlog日志目录路径信息修改时，需要创建指定的目录并设置权限信息，最后需要重新启动数据库服务生效；\n或者\nlog_bin=binlog\n-- 只是设置日志名称信息，日志会自动保存到数据库服务指定的数据目录中；\n\n# 配置文件修改后需要重启数据库服务，加载配置文件改动的信息：\n[root@cheng ~]# /etc/init.d/mysqld restart \n[root@cheng ~]# ll -h /data/3306/data/binlog*\n-rw-rw----. 1 mysql mysql 245 6月  24 02:19 /data/3306/data/binlog.00000N\n-rw-rw----. 1 mysql mysql   16 6月  24 02:19 /data/3306/data/binlog.index\n-- 数据库服务重启后，已经可以在数据库的数据存储目录中，看到binlog日志文件的踪影\n</code></pre>\n<blockquote>\n<p>说明：企业真实环境，日志处于默认激活记录状态，可以使用日志信息进行灾难数据恢复，以及可以用于实现主从复制；</p>\n</blockquote>\n<ul>\n<li><strong>3_2 日志配置信息扩展</strong><br />\n参数官方资料链接：<a href=\"https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html\" rel=\"noopener nofollow\" target=\"_blank\">https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html</a></li>\n</ul>\n<pre><code class=\"language-sql\"># 参数一：sync_binlog 表示刷新日志到磁盘策略\nmysql&gt; select @@sync_binlog;\n+---------------------+\n| @@sync_binlog       |\n+---------------------+\n|                   1 |\n+---------------------+\n1 row in set (0.00 sec)\n-- 在进行主从同步过程的双一标准的其中一个1的信息配置，主要是控制缓冲区里的binlog日志信息如何刷写到磁盘中；\n-- 此参数信息是有三种方式进行配置的：\n-- 参数信息配置0：表示由操作系统缓存自己决定，什么时候刷新日志到磁盘中；\n-- 参数信息配置1：表示每次事务提交，立即刷新日志到磁盘中；(此方式配置更安全)\n-- 参数信息配置N：表示每组事务提交，按照组的事务次数定义，确定刷新日志到磁盘中的频次；（可以有效减少IO性能损耗）\n\n# 参数二：binlog_format 定义binlog日志的格式信息\nmysql&gt; select @@binlog_format;\n+------------------------+\n| @@binlog_format        |\n+------------------------+\n| ROW                    |\n+------------------------+\n1 row in set (0.00 sec)\n-- 在进行主从同步数据恢复时，此参数配置可能会影响数据恢复的一致性问题；\n-- 此参数信息是有三种方式进行配置的，确定了主从复制的级别，只针对DML语句的日志才有效；\n-- 参数信息配置 statement（SBR）：语句格式记录binlog；\ncreate database wenC;  -- DDL DCL语句只能使用statement 表示的就是原原本本的语句信息，即做什么就记录什么；\n-- 参数信息配置 row（RBR）：行格式记录binlog（默认模式）\nupdate t1 set a=10 where id&lt;10;    -- 会记录行的变化信息，属于底层的记录信息，可能会有多个变化日志信息记录\n-- 参数信息配置 mixed（MBR）：混合格式记录binlog\n    -- 由数据库服务自行决定，是记录语句信息，还是记录行的变化信息；\n</code></pre>\n<p>SBR（statement-based replication）与RBR（Row-Based Replication）记录的优缺点分析：（面试常见问题）</p>\n<table>\n<thead>\n<tr>\n<th>记录方式</th>\n<th>优点说明</th>\n<th>缺点说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SBR</td>\n<td>可读性强，日志量相对较少；</td>\n<td>数据信息可能不准确，数据一致性不足</td>\n</tr>\n<tr>\n<td>RBR</td>\n<td>数据信息记录更准确，数据一致性更强</td>\n<td>可读性弱，日志量相对较多，数据记录准确</td>\n</tr>\n<tr>\n<td>举例说明</td>\n<td>update t1 set a=10 where id&lt;10000;  记录一条语句即可</td>\n<td>insert into 随机数函数;</td>\n</tr>\n<tr>\n<td>举例说明</td>\n<td>update t1 set a=10 where id&lt;10000;  记录多条语句修改信息，生成日志</td>\n<td>insert into 随机数函数;</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>3_3 日志信息查看方法：</strong></li>\n</ul>\n<p>可以通过查看方式，获取binlog日志里的数据信息，一般在数据库启动时，日志记录功能就开启了；</p>\n<p>可以利用日志中记录信息，将数据库服务的数据信息恢复到指定的时间点，同时也可以支持主从数据复制（在其它机器上回放日志）；</p>\n<p><code>对于binlog日志信息的查看，主要目的是为了日后日志事件信息的截取操作；</code></p>\n<p>查看方式一：确认数据库binlog日志数量</p>\n<pre><code class=\"language-sql\">mysql&gt; show binary logs;\n+------------------+-------------+--------------+\n| Log_name         | File_size   | Encrypted    |\n+------------------+-------------+--------------+\n| binlog.000001    |         156 | No           |\n+------------------+-------------+--------------+\n-- 获取数据库服务运行过程中，使用的binlog日志的情况\n\nmysql&gt; flush logs;\nQuery OK, 0 rows affected (0.12 sec)\n-- 可以执行flush刷新命令，从而生成新的binlog日志文件，类似于实现了日志切割功能；\nmysql&gt; show binary logs;\n+------------------+-------------+--------------+\n| Log_name         | File_size   | Encrypted    |\n+------------------+-------------+--------------+\n| binlog.000001    | 200         | No           |\n| binlog.000002    | 156         | No           |\n+------------------+-------------+--------------+\n2 rows in set (0.00 sec)\n</code></pre>\n<p>查看方式二：确认数据库binlog日志状态</p>\n<pre><code class=\"language-sql\">mysql&gt; create database test_binlog;\nQuery OK, 1 row affected (0.03 sec)\n-- 模拟数据服务有修改操作\nmysql&gt; select * from world.city limit 1;\nQuery OK, 1 row affected (0.03 sec)\n-- 模拟数据服务有修改操作\nmysql&gt; show binary logs;\n+------------------+-------------+--------------+\n| Log_name         | File_size   | Encrypted    |\n+------------------+-------------+--------------+\n| binlog.000001    |  200        | No           |\n| binlog.000002    |  362        | No           |\n+------------------+-------------+--------------+\n2 rows in set (0.00 sec)\n-- 可以看到binlog日志的存储量发生了变化，但是在做查询操作时，binlog日志的存储量并未发生变化\n\nmysql&gt; show master status;\n+------------------+------------+------------------+-----------------------+-------------------------+\n| File             | Position   | Binlog_Do_DB     | Binlog_Ignore_DB      | Executed_Gtid_Set       |\n+------------------+------------+------------------+-----------------------+-------------------------+\n| binlog.000002    |  362       |                  |                       |                         |\n+------------------+------------+------------------+-----------------------+-------------------------+\n1 row in set (0.00 sec)\n-- 查看获取当前使用的binlog日志情况，以及产生的日志量字节大小；\n</code></pre>\n<p>查看方式三：查看数据库binlog日志信息</p>\n<pre><code class=\"language-sql\">mysql&gt; show binlog events in 'binlog.000002';\n-- binlog日志信息是以事件方式进行记录的，所以日志查看过程是查看事件信息\n-- 一般binlog日志的前两行，表示日志格式头信息（日志简单的描述信息）\n-- 一般binlog日志中的query信息，就是对数据库的操作语句，其中包含了创建数据库的语句；\n</code></pre>\n<p>具体binlog事件信息：<br />\n<img alt=\"1669004768083\" src=\"https://img2024.cnblogs.com/blog/1080590/202512/1080590-20251223170443956-396789651.png\" /></p>\n<p>具体binlog事件记录信息分析：</p>\n<table>\n<thead>\n<tr>\n<th>列号</th>\n<th>列信息</th>\n<th>解释说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>01</td>\n<td>Log_name</td>\n<td>表示指定查看的binlog日志文件名称信息</td>\n</tr>\n<tr>\n<td>02</td>\n<td>Pos</td>\n<td>表示binlog日志事件开始的位置点，用于截取二进制日志信息标识</td>\n</tr>\n<tr>\n<td>05</td>\n<td>End_log_pos</td>\n<td>表示binlog日志事件结束的位置点，用于截取二进制日志信息标识</td>\n</tr>\n<tr>\n<td>06</td>\n<td>Info</td>\n<td>表示binlog中具体的事件内容信息</td>\n</tr>\n</tbody>\n</table>\n<p>查看方式四：筛选数据库binlog日志事件</p>\n<pre><code class=\"language-sql\"># 模拟生成binlog日志事件信息\nmysql&gt; source ~/world.sql;\nmysql&gt; drop database world;\nmysql&gt; source ~/world.sql;\n\n# 获取删除数据库的事件信息：\n# 筛选数据库日志方式一：\n[root@cheng data]# mysql -e \"show binlog events in 'binlog.000002'\"|grep \"drop database\"\nbinlog.000002\t722789\tQuery\t1\t722896\tdrop database world /* xid=5363 */\n-- 获取指定事件信息产生的起点位置和终点位置信息；\n\n# 筛选数据库日志方式二：\nmysql&gt; pager less\n-- 在数据库中定义pager功能，数据库连接会话退出即失效；\nmysql&gt; show binlog events in 'binlog.000002';\n-- 此时查看日志事件信息具有了翻页功能\n/drop database\n| binlog.000002 |  722789 | Query          |         1 |      722896 | drop database world /* xid=5363 */\nmysql&gt; pager grep \"drop database\"\nPAGER set to 'grep \"drop database\"'\n-- 表示开启数据库pager的过滤功能\nmysql&gt; show binlog events in 'binlog.000002';\n| binlog.000002 |  722789 | Query          |         1 |      722896 | drop database world /* xid=5363 */ \n-- 再次查看binlog事件信息时，只过滤显示删除数据库的操作事件日志\n</code></pre>\n<blockquote>\n<p>说明：在实际生产环境中，若binlog日志量比较大时，需要快速过滤关键日志事件行，可以使用以上查看日志方法；</p>\n</blockquote>\n<p><strong>获取数据库binlog日志记录信息异常：</strong></p>\n<p>进行数据库服务数据信息更改操作，随后查看binlog日志信息的变化：</p>\n<pre><code class=\"language-sql\"># 进行数据库创建操作\nmysql&gt; create database wenC;\nmysql&gt; show databases;\n\n# 查看获取binlog日志记录信息\n[root@cheng ~]# mysqlbinlog /var/lib/mysql/binlog.000001 \nmysqlbinlog: unknown variable 'default-character-set=utf8mb4'\n-- 由于在数据库在客户端配置文件中添加了default-character-set=utf8mb4字符编码信息，因此造成无法查看binlog\n[root@cheng ~]# cat /etc/my.cnf.d/client.cnf \n[client]\n#default-character-set=utf8mb4\n[client-mariadb]\n#default-character-set=utf8mb4\n-- 可以临时调整先将客户端的字符编码配置信息注释，\n[root@cheng ~]# mysqlbinlog /var/lib/mysql/binlog.000001\n... 省略部分信息 ...\n# at 494\n#220624  2:35:02 server id 1  end_log_pos 579 Query\tthread_id=2\texec_time=0\terror_code=0\nSET TIMESTAMP=1656009302/*!*/;\ncreate database wenC\n/*!*/;\n... 省略部分信息 ...\n-- 在binlog日志文件中，已经记录了之前的创建xiaoQ的更改操作记录信息\n</code></pre>\n<ul>\n<li><strong>3_4 日志信息应用实战</strong></li>\n</ul>\n<p><strong>数据库数据异常恢复（简单情况）</strong></p>\n<p>在实际生成环境中，可以利用binlog日志记录的信息截取，实现数据库异常情况下的数据信息恢复功能；</p>\n<p>数据库异常恢复情况环境准备：</p>\n<pre><code class=\"language-sql\"># 切换新的binlog日志文件做模拟数据恢复\nmysql&gt; flush logs;\nQuery OK, 0 rows affected (0.03 sec)\nmysql&gt; show master status;\n+------------------+------------+------------------+-----------------------+-------------------------+\n| File             | Position   | Binlog_Do_DB     | Binlog_Ignore_DB      | Executed_Gtid_Set       |\n+------------------+------------+------------------+-----------------------+-------------------------+\n| binlog.000003    |  156       |                  |                       |                         |\n+------------------+------------+------------------+-----------------------+-------------------------+\n1 row in set (0.01 sec)\n-- 确认已经刷新生成了新的binlog日志文件；\n\n# 进行基本的数据库SQL语句操作：\nmysql&gt; create database bindb;\nmysql&gt; use bindb;\nmysql&gt; create table t1 (id int);\nmysql&gt; begin;\nmysql&gt; insert into t1 values(1);\n-- 在没有进行事务提交前，操作的事务事件信息，是不会出现在binlog事件日志中的\nmysql&gt; commit;\n-- 对于数据库的binlog日志，只会记录事务已经提交的DML语句信息，没有提交的DML语句是不会进行记录的；\n-- 在日志中变化的DML语句信息是无法识别的，因为记录DML操作的语句默认是以ROW模式记录的；\n</code></pre>\n<p>数据库二进制日志信息查看方法：</p>\n<pre><code class=\"language-sql\">[root@cheng ~]# mysqlbinlog /data/3306/data/binlog.000003\n-- 对于数据库binlog日志信息，是无法直接查看内容信息，需要利用相关命令工具进行查看\n# The proper term is pseudo_replica_mode, but we use this compatibility alias\n# to make the statement usable on server versions 8.0.24 and older.\n/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;\n/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;\nDELIMITER /*!*/;\n# at 4\n#221121 13:12:59 server id 1  end_log_pos 125 CRC32 0xbb7d1fd1 \tStart: binlog v 4, server v 8.0.26 created 221121 13:12:59\n# Warning: this binlog is either in use or was not closed properly.\nBINLOG '\n2wh7Yw8BAAAAeQAAAH0AAAABAAQAOC4wLjI2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAEwANAAgAAAAABAAEAAAAYQAEGggAAAAICAgCAAAACgoKKioAEjQA\nCigB0R99uw==\n'/*!*/;\n# at 125\n#221121 13:12:59 server id 1  end_log_pos 156 CRC32 0x04874c92 \tPrevious-GTIDs\n# [empty]\n-- binlog日志文件156之前的内容是可以忽略的，表示是日志文件的头格式内容信息\n# at 156\n#221121 13:16:19 server id 1  end_log_pos 233 CRC32 0xd73c14e1 \tAnonymous_GTID\tlast_committed=0\tsequence_number=1\trbr_only=no\toriginal_committed_timestamp=1669007779100380\timmediate_commit_timestamp=1669007779100380\ttransaction_length=188\n# original_commit_timestamp=1669007779100380 (2022-11-21 13:16:19.100380 HKT)\n# immediate_commit_timestamp=1669007779100380 (2022-11-21 13:16:19.100380 HKT)\n/*!80001 SET @@session.original_commit_timestamp=1669007779100380*//*!*/;\n/*!80014 SET @@session.original_server_version=80026*//*!*/;\n/*!80014 SET @@session.immediate_server_version=80026*//*!*/;\nSET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;\n-- binlog日志文件已事件形式进行记录，主要关注两个at内容之间的信息，即表示的是一个事件信息；\n# at 233\n-- binlog日志中一个事件的开始，就表示上一个事件的结束，在binlog中记录的事件日志信息是连续的；\n#221121 13:16:19 server id 1  end_log_pos 344 CRC32 0x624986f5 \tQuery\tthread_id=11\texec_time=0\terror_code=0\tXid = 10728\nSET TIMESTAMP=1669007779/*!*/;\nSET @@session.pseudo_thread_id=11/*!*/;\nSET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;\nSET @@session.sql_mode=1168113696/*!*/;\nSET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;\n/*!\\C utf8mb4 *//*!*/;\nSET @@session.character_set_client=255,@@session.collation_connection=255,@@session.collation_server=255/*!*/;\nSET @@session.lc_time_names=0/*!*/;\nSET @@session.collation_database=DEFAULT/*!*/;\n/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;\n/*!80016 SET @@session.default_table_encryption=0*//*!*/;\ncreate database bindb\n/*!*/;\n# at 344\n</code></pre>\n<p>binlog日志内容中主要关注的信息：</p>\n<ul>\n<li><strong>通过日志信息查看DDL操作语句信息（记录方式 SBR）</strong></li>\n</ul>\n<p><img alt=\"1669015300339\" src=\"https://img2024.cnblogs.com/blog/1080590/202512/1080590-20251223170554930-296167952.png\" /></p>\n<ul>\n<li><strong>通过日志信息查看DML操作语句信息（记录方式 RBR）</strong></li>\n</ul>\n<p><img alt=\"1669015788023\" src=\"https://img2024.cnblogs.com/blog/1080590/202512/1080590-20251223170614385-150887390.png\" /></p>\n<p>以上ROW模式记录的信息是加密显示，无法直接查看的，可以使用下面命令参数进行获取详细信息：</p>\n<pre><code class=\"language-sql\">[root@cheng ~]# mysqlbinlog --base64-output=decode-rows -vvv /data/3306/data/binlog.000003 \n-- 以上添加的参数信息，表示将DML的ROW格式语句信息，进行格式化处理输出；\n# at 739\n#221121 13:17:45 server id 1  end_log_pos 779 CRC32 0xb468b459 \tWrite_rows: table id 101 flags: STMT_END_F\n### INSERT INTO `bindb`.`t1`\n-- 利用DML语句做的插入语句信息就显示出来了\n### SET\n###   @1=1 /* INT meta=0 nullable=1 is_null=0 */\n-- 以上日志记录的信息，可以用命令实现，如下：\nmysql &gt; insert into t1 set id=1;\n等价于\nmysql &gt; insert into t1 values(1);\n</code></pre>\n<p>数据库模拟异常情况破坏操作：</p>\n<pre><code class=\"language-sql\">mysql&gt; drop database bindb;\n-- 模拟破坏性操作，删除数据库\n</code></pre>\n<p>数据库异常情况数据恢复操作：</p>\n<pre><code class=\"language-sql\"># 需要恢复建库开始，删除之前的所有操作（即所有binlog日志信息），实现日志信息的截取\nmysql&gt; show binlog events in 'binlog.000002';\n-- 查看截取日志信息事件区域范围\n[root@cheng ~]# mysqlbinlog --start-position=233 --stop-position=1162 /data/3306/data/binlog.000003 &gt;/tmp/bin.sql\n-- 依据binlog日志的position号码，即可获取到想要恢复数据信息；\n\n# 根据截取的日志信息，进行数据库服务数据恢复\nmysql&gt; set sql_log_bin=0;\n-- 建议在进行数据日志恢复数据时，将数据恢复时执行的SQL语句信息，不做binlog日志记录；\nmysql&gt; source /tmp/bin.sql\n\n# 查看确认数据信息是否恢复\nmysql&gt; use bindb;\nmysql&gt; show tables;\nmysql&gt; select * from t1;\n</code></pre>\n<blockquote>\n<hr />\n<hr />\n</blockquote>\n<h3 id=\"数据库数据异常恢复\">数据库数据异常恢复</h3>\n<h4 id=\"情况一日志文件被清理过可能建库语句所在日志已经丢失\">情况一：日志文件被清理过，可能建库语句所在日志已经丢失</h4>\n<p>项目背景：一个数据库三年前就创建了，但是日志信息只记录一个月，这个库被误删除了；</p>\n<p>解决方案：</p>\n<p>A计划：最近一次全备+全备之后，误删除之前所有binlog，进行一同恢复；（<code>全备数据+增量数据</code>）</p>\n<p>B计划：利用延时从库，进行数据恢复；</p>\n<h4 id=\"情况二所需日志跨越多个文件如何进行日志信息的截取\">情况二：所需日志跨越多个文件，如何进行日志信息的截取</h4>\n<p>解决方案：</p>\n<p>A计划：只有position号的方式，可以进行分段截取，进行分段恢复数据；</p>\n<p>B计划：根据Datatime时间信息方式，可能会出现准确性不高的情况（因为每一秒可能有多个事件产生）；</p>\n<p>C计划：启用GTID（全局事务ID）方式，无论跨越多少个日志文件，每个事务操作的事件ID信息都是唯一且递增的（5.6+引入）；</p>\n<p>实践操作：</p>\n<p><strong>C计划：基于GTID方式对binlog进行管理（利用GTID实现日志截取）</strong></p>\n<p>数据库异常恢复情况环境准备：</p>\n<pre><code class=\"language-sql\"># 刷新新的binlog日志进行操作\nmysql&gt; flush logs;\n-- 生成新的binlog日志信息\n\n# 确认新的日志编号是否是连续的\nmysql&gt; create database test5;\nmysql&gt; show binlog events in \"binlog.000004\"\n-- 可以看出新的binlog日志文件中，记录的gtid编号信息是延续了上一个binlog日志gtid集合信息，继续连续进行记录；\n\n# 进行基本的数据库SQL语句操作：\nmysql&gt; create database gtdb;\nmysql&gt; use gtdb;\nmysql&gt; create table t1(id int);\nmysql&gt; insert into t1 values(1);\nmysql&gt; commit;\nmysql&gt; insert into t1 values(2);\nmysql&gt; commit;\nmysql&gt; insert into t1 values(3);\nmysql&gt; commit;\n\n# 进行binlog事件信息查看\nmysql&gt; show binlog events in 'binlog.000004';\n-- 可以获取以上的数据操作事件信息，\n</code></pre>\n<p>数据库模拟异常情况破坏操作：</p>\n<pre><code class=\"language-sql\">mysql&gt; drop database gtdb;\n-- 模拟破坏性操作，删除数据库\n</code></pre>\n<p>数据库异常情况数据恢复操作：</p>\n<pre><code class=\"language-sql\"># 根据日志信息查看相关的事件情况（获取GTID编号范围）\nmysql&gt; show binlog events in 'binlog.000004';\n\n# 需要恢复建库开始，删除之前的所有操作（即所有binlog日志信息），实现日志信息的截取\n[root@cheng ~]# mysqlbinlog --include-gtids='7afe4f8c-5e36-11ed-b083-000c29d44f34:3-7' /data/3306/data/binlog.000004 &gt;/tmp/gtid.sql\n-- 依据binlog日志的GTID信息，即可获取到想要恢复数据信息；\n\n# 根据截取的日志信息，进行数据库服务数据恢复\nmysql&gt; set sql_log_bin=0;\n-- 建议在进行数据日志恢复数据时，将数据恢复时执行的SQL语句信息，不做binlog日志记录；恢复后别忘在改为1；\nmysql&gt; source /tmp/gtid.sql\n-- 默认此时报错恢复失败，因为GTID截取的日志恢复数据时，具有幂等性，由于binlog中已经记录了3-7的GTID事件信息\nmysql&gt; show master status;\n+---------------+----------+--------------+------------------+------------------------------------------+\n| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                        |\n+---------------+----------+--------------+------------------+------------------------------------------+\n| binlog.000004 |     1905 |              |                  | 7afe4f8c-5e36-11ed-b083-000c29d44f34:1-8 |\n+---------------+----------+--------------+------------------+------------------------------------------+\n1 row in set (0.00 sec)\n-- 通过查看确认，核实清楚binlog中已经记录了3-7的GTID事件信息\n\n# 利用GTID日志信息恢复报错处理方式一：将系统中日志中的GTID信息清除掉（不建议）\n# 利用GTID日志信息恢复报错处理方式二：删除与幂等性冲突的记录信息\n[root@cheng ~]# mysqlbinlog --skip-gtids --include-gtids='7afe4f8c-5e36-11ed-b083-000c29d44f34:3-7' /data/3306/data/binlog.000004 &gt;/tmp/gtid.sql\n-- 表示跳过gtid的检查过程，即截取的日志中不再含有GTID的配置语句信息，自然解决了幂等性冲突问题；\n-- 开启了GTID之后，依然可以使用pos方式进行日志信息截取与恢复；\n\n# 查看确认数据信息是否恢复\nmysql&gt; use gtdb;\nmysql&gt; show tables;\nmysql&gt; select * from t1;\n-- 查看test1数据库中的t1表的数据信息是否恢复\n\n# 操作扩展：可以实现排除指定gtid信息不做日志记录截取\n[root@cheng ~]# mysqlbinlog --exclude-gtids='7afe4f8c-5e36-11ed-b083-000c29d44f34:4'  --include-gtids='7afe4f8c-5e36-11ed-b083-000c29d44f34:3-7' /data/3306/data/binlog.000004 \n\n# 操作扩展：跨多日志文件信息截取\n[root@cheng ~]# mysqlbinlog --skip-gtids --include-gtids='7afe4f8c-5e36-11ed-b083-000c29d44f34:1-10' /data/3306/data/binlog.000001  /data/3306/data/binlog.000002 /data/3306/data/binlog.000003 &gt;/tmp/gtid.sql\n</code></pre>\n<ul>\n<li><strong>GTID概念介绍：</strong></li>\n</ul>\n<p>GTID（global transation id）称为全局事务（事件）ID，标识binlog日志记录的唯一性；</p>\n<p>GTID信息的表示方式：</p>\n<table>\n<thead>\n<tr>\n<th>表现形式</th>\n<th>关键列</th>\n<th>解释说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>server_uuid:N</td>\n<td>server_uuid</td>\n<td>表示数据库初始化启动之后，自动生成的随机数信息（唯一的）</td>\n</tr>\n<tr>\n<td></td>\n<td>N</td>\n<td>表示第几个相关的事务或事件信息，会不断进行自增</td>\n</tr>\n</tbody>\n</table>\n<p>server_uuid信息查看：</p>\n<pre><code class=\"language-sql\">mysql&gt; select @@server_uuid;\n+---------------------------------------------------+\n| @@server_uuid                                     |\n+---------------------------------------------------+\n| 7afe4f8c-5e36-11ed-b083-000c29d44f34              |\n+---------------------------------------------------+\n1 row in set (0.00 sec)\n-- 表示数据库每次初始化之后自动生成，不建议手工进行修改；\n\n[root@cheng ~]# cat /data/3306/data/auto.cnf \n[auto]\nserver-uuid=7afe4f8c-5e36-11ed-b083-000c29d44f34\n-- 在数据库的数据目录文件中也可以查询到\n</code></pre>\n<ul>\n<li><strong>GTID功能作用：</strong></li>\n</ul>\n<p>利用GTID方式管理binlog，实质上就是对于数据库的每个事务产生事件信息打上唯一标识信息（id号）；</p>\n<p>利用GTID方式管理binlog，主要目的是处理数据库主从问题，解决主从数据库的数据一致性问题；</p>\n<p>简单描述：标识事务的唯一性，保证日志恢复时的一致性，并且具备”幂等性”；</p>\n<ul>\n<li><strong>GTID功能配置：</strong></li>\n</ul>\n<p>GTID功能相关参数介绍：</p>\n<pre><code class=\"language-sql\"># GTID功能参数信息介绍（3个重要的配置参数）\nmysql&gt; select @@gtid_mode;\n+-------------------+\n| @@gtid_mode       |\n+-------------------+\n| OFF               |\n+-------------------+\n1 row in set (0.00 sec)\n-- 设置是否开启显示gtid信息功能（在5.7之后是有个匿名的gtid，是数据库系统自己维护的）\n\nmysql&gt; select @@enforce_gtid_consistency;\n+-------------------------------------+\n| @@enforce_gtid_consistency          |\n+-------------------------------------+\n| OFF                                 |\n+-------------------------------------+\n1 row in set (0.00 sec)\n-- 设置是否开启GTID强制一致性功能\n-- 对某些 SQL 会有限制，例如 CREATE TABLE … SELECT 必须得分成两条语句执行。\n-- OFF：    表示事务允许违反 GTID 一致性。\n-- ON：     表示事务不允许违反 GTID 一致性，有相关 SQL 会直接返回异常。\n-- WARN：表示事务允许违反 GTID 一致性，但会将警告信息记录到 ERROR LOG。\n\nmysql&gt; select @@log_slave_updates;\n+----------------------------+\n| @@log_slave_updates        |\n+----------------------------+\n|      1                     |\n+----------------------------+\n1 row in set, 1 warning (0.01 sec)\n-- 和配置主从有关（在8.0.26开始 推荐配置log_replica_updates替代log_slave_updates参数）\n-- 此参数表示从服务器从主服务器接收的更新信息，是否也会记录在从服务器本地的二进制文件中\n</code></pre>\n<p>GTID功能相关参数激活：</p>\n<pre><code class=\"language-sql\">[root@cheng ~]# vim /etc/my.cnf\n[mysqld]\ngtid_mode=on\nenforce_gtid_consistency=1\nlog_slave_updates=on\n-- 配置文件信息修改完毕后，重启数据库服务使配置生效\n</code></pre>\n<ul>\n<li><strong>GTID信息查看：</strong></li>\n</ul>\n<pre><code class=\"language-sql\">mysql&gt; show master status;\n+------------------+-----------+-------------------+-----------------------+-------------------------+\n| File             | Position  | Binlog_Do_DB      | Binlog_Ignore_DB      | Executed_Gtid_Set       |\n+------------------+-----------+-------------------+-----------------------+-------------------------+\n| binlog.000004    |    156    |                   |                       |                         |\n+------------------+-----------+-------------------+-----------------------+-------------------------+\n1 row in set (0.03 sec)\n-- 在GTID功能被激活后，就会在Executed_Gtid_Set列中显示GTID集合信息；\n\nmysql&gt; create database test3;\nQuery OK, 1 row affected (0.08 sec)\n-- 模拟创建数据库，产生新的事件信息\nmysql&gt; show master status;\n+------------------+----------+--------------+------------------+----------------------------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                      |\n+------------------+----------+--------------+------------------+----------------------------------------+\n| binlog.000004    |      344 |              |                  | 7afe4f8c-5e36-11ed-b083-000c29d44f34:1 |\n+------------------+----------+--------------+------------------+----------------------------------------+\n1 row in set (0.01 sec)\n-- GTID信息随着新的事件产生，随之发生变化\nmysql&gt; create database test4;\nQuery OK, 1 row affected (0.03 sec)\n-- 模拟创建数据库，产生新的事件信息\nmysql&gt; show master status;\n+---------------+----------+--------------+------------------+------------------------------------------+\n| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                        |\n+---------------+----------+--------------+------------------+------------------------------------------+\n| binlog.000004 |      532 |              |                  | 7afe4f8c-5e36-11ed-b083-000c29d44f34:1-2 |\n+---------------+----------+--------------+------------------+------------------------------------------+\n1 row in set (0.00 sec)\n-- GTID信息随着新的事件产生，随之发生变化\n\nmysql&gt; show binlog events in 'binlog.000004';\n+---------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+\n| Log_name      | Pos | Event_type     | Server_id | End_log_pos | Info                                                              |\n+---------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+\n| binlog.000004 |   4 | Format_desc    |         1 |         125 | Server ver: 8.0.26, Binlog ver: 4                                 |\n| binlog.000004 | 125 | Previous_gtids |         1 |         156 |                                                                   |\n| binlog.000004 | 156 | Gtid           |         1 |         233 | SET @@SESSION.GTID_NEXT= '7afe4f8c-5e36-11ed-b083-000c29d44f34:1' |\n| binlog.000004 | 233 | Query          |         1 |         344 | create database test3 /* xid=6 */                                 |\n| binlog.000004 | 344 | Gtid           |         1 |         421 | SET @@SESSION.GTID_NEXT= '7afe4f8c-5e36-11ed-b083-000c29d44f34:2' |\n| binlog.000004 | 421 | Query          |         1 |         532 | create database test4 /* xid=8 */                                 |\n+---------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+\n6 rows in set (0.00 sec)\n-- 在每个数据库操作事件之前，会显示GTID的唯一标识信息\n</code></pre>\n<h4 id=\"情况三如何从日志文件中恢复单库单表或者部分行数据信息\">情况三：如何从日志文件中恢复单库、单表、或者部分行数据信息</h4>\n<p>解决方案：</p>\n<p>A计划：可以利用命令单独截取某个数据库的日志信息；<code>mysqlbinlog -d world  xxx &gt; xxxx</code></p>\n<p>B计划：可以借助第三方工具实现单表或部分数据恢复；<code>binlog2sql（python）</code> 过滤指定表数据或过滤指定表的部分数据；</p>\n<p>实战操作：</p>\n<p><strong>A计划：单库日志信息截取，企业实战过程</strong>：</p>\n<p>数据库异常恢复情况环境准备：</p>\n<pre><code class=\"language-sql\"># 查看获取当前binlog日志状态信息\nmysql &gt; show master status;\n+------------------+-----------+-------------------+-----------------------+-------------------------+\n| File             | Position  | Binlog_Do_DB      | Binlog_Ignore_DB      | Executed_Gtid_Set       |\n+------------------+-----------+-------------------+-----------------------+-------------------------+\n| binlog.000003    |      1269 |                   |                       |                         |\n+------------------+-----------+-------------------+-----------------------+-------------------------+\n\n# 进行基本的数据库SQL语句操作：\nmysql&gt; create database test1;\nmysql&gt; create table t1 (id int);\nmysql&gt; insert into t1 values(1);\nmysql&gt; insert into t1 values(2);\nmysql&gt; commit;\nmysql&gt; select * from t1;\n+------+\n| id     |\n+------+\n|      1 |\n|      2 |\n+------+\n2 rows in set (0.00 sec)\n-- 创建了一个test1数据库，并在数据库中创建了一个表，在表中插入了一些数据信息\nmysql&gt; create database test2;\nmysql&gt; use test2;\nmysql&gt; create table t2 (id int);\nmysql&gt; insert into t2 values(1);\nmysql&gt; insert into t2 values(2);\nmysql&gt; commit;\n-- 创建了一个test2数据库，并在数据库中创建了一个表，在表中插入了一些数据信息\nmysql&gt; use test1;\nmysql&gt; insert into t1 values(3);\nmysql&gt; insert into t1 values(4);\nmysql&gt; use test2;\nmysql&gt; insert into t2 values(3);\nmysql&gt; insert into t2 values(4);\nmysql&gt; commit;\nmysql&gt; select * from test1.t1;\nmysql&gt; select * from test2.t2;\n-- 通过操作不同的数据库，以及不同的数据表，实现binlog日志事件信息的交叉\n</code></pre>\n<p>数据库模拟异常情况破坏操作：</p>\n<pre><code class=\"language-sql\">mysql&gt; drop database test1;\n-- 模拟破坏性操作，删除数据库\n</code></pre>\n<p>数据库异常情况数据恢复操作：</p>\n<pre><code class=\"language-sql\"># 根据日志信息查看相关的事件情况\nmysql&gt; show binlog events in 'binlog.000003';\n\n# 需要恢复建库开始，删除之前的所有操作（即所有binlog日志信息），实现日志信息的截取\n[root@cheng ~]# mysqlbinlog --start-position=1346 --stop-position=4116 -d test1 /data/3306/data/binlog.000003 &gt;/tmp/bin.sql\n-- 依据binlog日志的position号码，即可获取到想要恢复数据信息，并利用-d参数导出指定数据库相关数据；\n\n# 根据截取的日志信息，进行数据库服务数据恢复\nmysql&gt; set sql_log_bin=0;\n-- 建议在进行数据日志恢复数据时，将数据恢复时执行的SQL语句信息，不做binlog日志记录；恢复后别忘在改为1；\nmysql&gt; source /tmp/bin.sql\n\n# 查看确认数据信息是否恢复\nmysql&gt; use test1;\nmysql&gt; show tables;\nmysql&gt; select * from t1;\n-- 查看test1数据库中的t1表的数据信息是否恢复\nmysql&gt; use test2;\nmysql&gt; show tables;\nmysql&gt; select * from t2;\n-- 查看test2数据库中的t2表的数据信息是否破坏\n</code></pre>\n<p><strong>B计划：可以借助第三方工具实现单表或部分数据恢复；</strong></p>\n<p>利用binlog2sql工具可以处理上面的企业需求，此软件是利用python语言开发的，主要用来处理binlog日志信息；</p>\n<p>从软件应用方面来说主要包含两个核心功能：</p>\n<ul>\n<li>可以友好的展示或者管理二进制日志信息（binlog），进而可以过滤出单独表的信息，甚至表中指定行的信息；</li>\n<li>可以快速的实现DML操作语句的闪回功能，即实现通过日志信息翻转方式，进行数据信息的恢复；</li>\n</ul>\n<blockquote>\n<p>说明：binlog2sql工具是模拟了一个从库，进行日志信息分析，需要保证数据库服务启动状态，且不支持离线方式分析日志内容；</p>\n</blockquote>\n<p>数据库异常恢复情况环境准备：</p>\n<pre><code class=\"language-sql\"># 下载第三方日志分析工具\n[root@cheng ~]# cd /opt/\n[root@cheng ~]# git clone https://github.com/danfengcao/binlog2sql.git\n[root@cheng ~]# cd /opt/binlog2sql\n-- 此工具在mariadb中可以通过打补丁方式，进行部署安装；但是在mysql 8.0中暂时还没有集成，需要单独安装\n\n# 部署第三方工具运行环境\n[root@cheng ~]# yum install -y python3\n[root@cheng ~]# pip3 install -r requirments.txt\n[root@cheng ~]# pip3 show pymysql\n[root@cheng ~]# pip3 install --upgrade pymysql    （此步骤可以忽略）\n-- 以上pip3下载软件缓慢，可以优化pip3下载源\n-- 下载源优化方法：https://developer.aliyun.com/mirror/pypi?spm=a2c6h.13651102.0.0.3e221b11H9Q7La\n\n# 在指定数据库中创建多个数据表\nmysql&gt; use test1;\nmysql&gt; create table t11 (id int);\nmysql&gt; insert into t11 values (1),(2);\nmysql&gt; commit;\n</code></pre>\n<p>数据库日志信息工具分析查看：（解析日志事件SQL）</p>\n<pre><code class=\"language-sql\">[root@cheng binlog2sql]# python3 binlog2sql.py -h 10.0.0.101 -P3306 -uroot -p123456 -d test1 -t t1 --start-file='binlog.000003'\nINSERT INTO `test1`.`t1`(`id`) VALUES (1); #start 1460 end 1704 time 2022-11-21 22:16:32 gtid \nINSERT INTO `test1`.`t1`(`id`) VALUES (2); #start 1735 end 1979 time 2022-11-21 22:16:35 gtid \nINSERT INTO `test1`.`t1`(`id`) VALUES (3); #start 2939 end 3183 time 2022-11-21 22:20:53 gtid \nINSERT INTO `test1`.`t1`(`id`) VALUES (4); #start 3214 end 3458 time 2022-11-21 22:22:19 gtid\n[root@cheng binlog2sql-master]# python3 binlog2sql.py -h 10.0.0.101 -P3306 -uroot -p123456 -d test1 -t t11 --start-file='binlog.000003'\nINSERT INTO `test1`.`t11`(`id`) VALUES (1); #start 4704 end 4954 time 2022-11-21 23:47:51 gtid \nINSERT INTO `test1`.`t11`(`id`) VALUES (2); #start 4704 end 4954 time 2022-11-21 23:47:51 gtid \n-- 表的数据信息导出后，可以直接复制命令信息恢复，或者导出sql文件进行导入恢复；\n</code></pre>\n<p>数据库模拟异常情况破坏操作：</p>\n<pre><code class=\"language-sql\"># 在指定数据库的相应数据表中做修改操作\nmysql&gt; use test1;\nmysql&gt; update t1 set id=10 where id=1;\nmysql&gt; commit;\n\n# 在指定数据库的相应数据表中做删除操作\nmysql&gt; use test1;\nmysql&gt; delete from t1 where id=3;\nmysql&gt; commit;\n</code></pre>\n<p>数据库日志信息工具分析查看：（解析日志事件SQL）</p>\n<pre><code class=\"language-sql\">[root@cheng binlog2sql-master]# python3 binlog2sql.py -h 10.0.0.101 -P3306 -uroot -p123456 -d test1 -t t1 --start-file='binlog.000003'\nINSERT INTO `test1`.`t1`(`id`) VALUES (1); #start 1460 end 1704 time 2022-11-21 22:16:32 gtid \nINSERT INTO `test1`.`t1`(`id`) VALUES (2); #start 1735 end 1979 time 2022-11-21 22:16:35 gtid \nINSERT INTO `test1`.`t1`(`id`) VALUES (3); #start 2939 end 3183 time 2022-11-21 22:20:53 gtid \nINSERT INTO `test1`.`t1`(`id`) VALUES (4); #start 3214 end 3458 time 2022-11-21 22:22:19 gtid \nUPDATE `test1`.`t1` SET `id`=10 WHERE `id`=1 LIMIT 1; #start 4985 end 5244 time 2022-11-21 23:52:33 gtid \nDELETE FROM `test1`.`t1` WHERE `id`=3 LIMIT 1; #start 5275 end 5519 time 2022-11-21 23:54:17 gtid \n\n# 只想查看删除操作信息\n[root@cheng binlog2sql-master]# python3 binlog2sql.py -h 10.0.0.101 -P3306 -uroot -p123456 -d test1 -t t1 --sql-type=delete --start-file='binlog.000003'\nDELETE FROM `test1`.`t1` WHERE `id`=3 LIMIT 1; #start 5275 end 5519 time 2022-11-21 23:54:17 gtid\n-- sql-type参数只能过滤DML类型语句信息，一般常见过滤的是 insert update delete\n\n# 只想查看修改操作信息\n[root@cheng binlog2sql-master]# python3 binlog2sql.py -h 10.0.0.101 -P3306 -uroot -p123456 -d test1 -t t1 --sql-type=update --start-file='binlog.000003'\nUPDATE `test1`.`t1` SET `id`=10 WHERE `id`=1 LIMIT 1; #start 4985 end 5244 time 2022-11-21 23:52:33 gtid\n\n# 只想查看插入操作信息\n[root@cheng binlog2sql-master]# python3 binlog2sql.py -h 10.0.0.101 -P3306 -uroot -p123456 -d test1 -t t1 --sql-type=insert --start-file='binlog.000003'\nINSERT INTO `test1`.`t1`(`id`) VALUES (1); #start 1460 end 1704 time 2022-11-21 22:16:32 gtid \nINSERT INTO `test1`.`t1`(`id`) VALUES (2); #start 1735 end 1979 time 2022-11-21 22:16:35 gtid \nINSERT INTO `test1`.`t1`(`id`) VALUES (3); #start 2939 end 3183 time 2022-11-21 22:20:53 gtid \nINSERT INTO `test1`.`t1`(`id`) VALUES (4); #start 3214 end 3458 time 2022-11-21 22:22:19 gtid\n</code></pre>\n<p>数据库日志信息工具回滚操作：（生成指定事件回滚语句-闪回操作）</p>\n<p>假设在某个企业的应用场景中，有3000万行数据，占用200G的存储空间，其中误删除了10行数据信息，请问如何进行恢复数据？</p>\n<pre><code class=\"language-sql\"># 误删除操作语句反转操作\n[root@cheng binlog2sql-master]# python3 binlog2sql.py -h 10.0.0.101 -P3306 -uroot -p123456 -d test1 -t t1 --sql-type=delete --start-file='binlog.000003'\nDELETE FROM `test1`.`t1` WHERE `id`=3 LIMIT 1; #start 5275 end 5519 time 2022-11-21 23:54:17 gtid\n-- 获取删除操作语句信息\n\n[root@cheng binlog2sql-master]# python3 binlog2sql.py -h 10.0.0.101 -P3306 -uroot -p123456 -d test1 -t t1 --sql-type=delete --start-file='binlog.000003' -B\nINSERT INTO `test1`.`t1`(`id`) VALUES (3); #start 5275 end 5519 time 2022-11-21 23:54:17 gtid\n-- 在获取删除操作语句命令后加 -B 参数，正好获得了反转语句的操作信息\n\n# 误修改操作语句反转操作\n[root@cheng binlog2sql-master]# python3 binlog2sql.py -h 10.0.0.101 -P3306 -uroot -p123456 -d test1 -t t1 --sql-type=update --start-file='binlog.000003'\nUPDATE `test1`.`t1` SET `id`=10 WHERE `id`=1 LIMIT 1; #start 4985 end 5244 time 2022-11-21 23:52:33 gtid \n-- 获取修改操作语句信息\n\n[root@cheng binlog2sql-master]# python3 binlog2sql.py -h 10.0.0.101 -P3306 -uroot -p123456 -d test1 -t t1 --sql-type=update --start-file='binlog.000003' -B\nUPDATE `test1`.`t1` SET `id`=1 WHERE `id`=10 LIMIT 1; #start 4985 end 5244 time 2022-11-21 23:52:33 gtid\n-- 在获取修改操作语句命令后加 -B 参数，正好获得了反转语句的操作信息\n\n# 误插入操作语句反转操作\n[root@cheng binlog2sql-master]# python3 binlog2sql.py -h 10.0.0.101 -P3306 -uroot -p123456 -d test1 -t t1 --sql-type=insert --start-file='binlog.000003'\nINSERT INTO `test1`.`t1`(`id`) VALUES (1); #start 1460 end 1704 time 2022-11-21 22:16:32 gtid \nINSERT INTO `test1`.`t1`(`id`) VALUES (2); #start 1735 end 1979 time 2022-11-21 22:16:35 gtid \nINSERT INTO `test1`.`t1`(`id`) VALUES (3); #start 2939 end 3183 time 2022-11-21 22:20:53 gtid \nINSERT INTO `test1`.`t1`(`id`) VALUES (4); #start 3214 end 3458 time 2022-11-21 22:22:19 gtid \n-- 获取插入操作语句信息\n\n[root@cheng binlog2sql-master]# python3 binlog2sql.py -h 10.0.0.101 -P3306 -uroot -p123456 -d test1 -t t1 --sql-type=insert --start-file='binlog.000003' -B\nDELETE FROM `test1`.`t1` WHERE `id`=4 LIMIT 1; #start 3214 end 3458 time 2022-11-21 22:22:19 gtid\nDELETE FROM `test1`.`t1` WHERE `id`=3 LIMIT 1; #start 2939 end 3183 time 2022-11-21 22:20:53 gtid\nDELETE FROM `test1`.`t1` WHERE `id`=2 LIMIT 1; #start 1735 end 1979 time 2022-11-21 22:16:35 gtid\nDELETE FROM `test1`.`t1` WHERE `id`=1 LIMIT 1; #start 1460 end 1704 time 2022-11-21 22:16:32 gtid\n-- 在获取插入操作语句命令后加 -B 参数，正好获得了反转语句的操作信息\n</code></pre>\n\n</div>\n<div id=\"MySignature\">\n    <!-- 版权保护 \n<div style=\"color: red; font-weight: bold; font-size: 15px;\">\n更多最新文章：<a href=\"https://juejin.cn/user/1383642897854980/posts\">【传送门】</a><br>\n</div>\n<br>\n<div style=\"text-align:center;background-color:font-size: 24px; \">\n-->\n<div style=\"color: red; text-align: center; font-weight: bold; font-size: 15px;\">\n**********   如果您认为这篇文章还不错或者有所收获，请点击右下角的【推荐】/【赞助】按钮，因为您的支持是我继续创作分享的最大动力！   **********\n</div>\n<br />\n\n<div style=\"color: #0; font-size: 15px;\">\n            作者：<a href=\"https://www.cnblogs.com/zhangwencheng\">讲文张字</a><br />\n            出处：<a href=\"https://www.cnblogs.com/zhangwencheng\">https://www.cnblogs.com/zhangwencheng</a><br />\n            版权：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出\n             <a href=\"#\" style=\"background: #b6ff00; color: #0; font-size: medium;\">原文链接</a>\n    \n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 10:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zhangwencheng\">讲文张字</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "通过 C# 为 PDF 文档添加电子签名",
      "link": "https://www.cnblogs.com/jazz-z/p/19396484",
      "published": "",
      "description": "<div class=\"postcontent\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>电子签名在文档合规性与安全性保障中扮演着重要角色，基于 C# 开发 PDF 电子签名功能是企业级文档处理场景的常见需求。Spire.PDF for .NET 作为国产 PDF 处理类库，无需依赖 Adobe Acrobat 等第三方软件，即可便捷实现 PDF 电子签名添加。本文将介绍该类库的使用方式、PDF 电子签名的实现流程、解析关键代码参数等。</p>\n<h2 id=\"一前置准备\">一、前置准备</h2>\n<h3 id=\"1-安装-net-库\">1. 安装 .NET 库</h3>\n<p>通过 NuGet 包管理器快速安装：</p>\n<pre><code class=\"language-powershell\">Install-Package Spire.PDF\n</code></pre>\n<h3 id=\"2-核心依赖说明\">2. 核心依赖说明</h3>\n<p>实现电子签名需依赖 <code>.pfx</code> 格式的数字证书（包含私钥）：</p>\n<ul>\n<li>测试场景：可通过 OpenSSL、Windows 证书管理器生成自签名证书；</li>\n<li>生产场景：需使用 CA 机构颁发的合规证书（符合《电子签名法》要求）；</li>\n<li>证书加载：通过 <code>System.Security.Cryptography.X509Certificates.X509Certificate2</code> 类解析 .pfx 文件，是本次实现的核心依赖。</li>\n</ul>\n<h2 id=\"二核心实现逻辑\">二、核心实现逻辑</h2>\n<p><code>PdfOrdinarySignatureMaker</code> 是 Spire.PDF 中面向普通电子签名的核心类，其核心流程为：<br />\n加载 PDF 文档 → 解析 X.509 证书→ 初始化签名器 → 执行签名 → 保存文档。</p>\n<p>以下基于该类实现基础签名功能，并扩展添加可见签名等进阶示例。</p>\n<h3 id=\"1-基础版添加基础电子签名默认不可见\">1. 基础版：添加基础电子签名（默认不可见）</h3>\n<p>适用于仅需验签、无需视觉标识的场景，核心代码附带详细注释：</p>\n<pre><code class=\"language-csharp\">using Spire.Pdf;\nusing Spire.Pdf.Interactive.DigitalSignatures;\nusing System;\nusing System.Security.Cryptography.X509Certificates;\n\nnamespace PdfDigitalSignature\n{\n    class BasicSignatureDemo\n    {\n        static void Main(string[] args)\n        {\n            try\n            {\n                // 1. 加载待签名的 PDF 文档\n                using (PdfDocument pdfDoc = new PdfDocument())\n                {\n                    pdfDoc.LoadFromFile(\"Input.pdf\"); // 替换为实际文件路径\n\n                    // 2. 加载数字证书（指定密钥存储策略，适配服务器/客户端环境）\n                    string certPath = \"certificate.pfx\"; // 替换为证书实际路径\n                    string certPassword = \"abc123\"; // 替换为证书密码\n                    X509Certificate2 cert = new X509Certificate2(\n                        certPath,\n                        certPassword,\n                        // 关键标志：适配服务器环境+避免密钥持久化，提升安全性\n                        X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.EphemeralKeySet\n                    );\n\n                    // 3. 初始化签名器并执行签名\n                    PdfOrdinarySignatureMaker signMaker = new PdfOrdinarySignatureMaker(pdfDoc, cert);\n                    // 签名名称：用于后续识别/验证签名，建议唯一\n                    signMaker.MakeSignature(\"Basic_Signature_001\");\n\n                    // 4. 保存签名后的文档\n                    pdfDoc.SaveToFile(\"Signed_Basic.pdf\");\n                    Console.WriteLine(\"不可见签名添加成功！\");\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"签名失败：{ex.Message}\");\n                // 进阶：记录异常详情（如堆栈）便于排查\n                Console.WriteLine($\"异常详情：{ex.StackTrace}\");\n            }\n        }\n    }\n}\n</code></pre>\n<h3 id=\"2-进阶版添加可见签名\">2. 进阶版：添加可见签名</h3>\n<p>在基础签名上扩展视觉标识（含签名图片、文本信息），适用于需要直观展示签名的场景：</p>\n<pre><code class=\"language-csharp\">using Spire.Pdf;\nusing Spire.Pdf.Interactive.DigitalSignatures;\nusing System;\nusing System.Drawing;\nusing System.Security.Cryptography.X509Certificates;\n\nnamespace PdfDigitalSignature\n{\n    class AdvancedSignatureDemo\n    {\n        static void Main(string[] args)\n        {\n            try\n            {\n                // 1. 加载 PDF 文档（using 自动释放资源）\n                using (PdfDocument pdfDoc = new PdfDocument())\n                {\n                    pdfDoc.LoadFromFile(\"Input.pdf\");\n\n                    // 2. 加载数字证书\n                    string certPath = \"certificate.pfx\";\n                    string certPassword = \"abc123\";\n                    X509Certificate2 cert = new X509Certificate2(\n                        certPath,\n                        certPassword,\n                        X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.EphemeralKeySet\n                    );\n\n                    // 3. 初始化签名器\n                    PdfOrdinarySignatureMaker signMaker = new PdfOrdinarySignatureMaker(pdfDoc, cert);\n                    PdfSignature signature = signMaker.Signature;\n\n                    // 4. 配置签名元信息（将显示在签名外观中）\n                    signature.Name = \"XX科技有限公司\";       // 签名者名称\n                    signature.ContactInfo = \"010-12345678\"; // 联系信息\n                    signature.Location = \"中国·北京\";        // 签名地点\n                    signature.Reason = \"确认文档内容合规有效\";// 签名原因\n\n                    // 5. 配置签名可视化外观\n                    PdfSignatureAppearance appearance = new PdfSignatureAppearance(signature);\n                    // 自定义标签文本\n                    appearance.NameLabel = \"签名主体：\";\n                    appearance.ContactInfoLabel = \"联系电话：\";\n                    appearance.LocationLabel = \"签署地点：\";\n                    appearance.ReasonLabel = \"签署原因：\";\n                    // 添加签名图片（支持 PNG/JPG 等格式）\n                    PdfImage signImage = PdfImage.FromFile(\"signature.png\"); // 替换为签名图片路径\n                    appearance.SignatureImage = signImage;\n                    // 布局模式：图片 + 文本（可选：SignImageOnly/仅图片；SignDetailOnly/仅文本）\n                    appearance.GraphicMode = GraphicMode.SignImageAndSignDetail;\n\n                    // 6. 绑定外观并添加到指定位置\n                    signMaker.SignatureAppearance = appearance;\n                    // 获取目标页面（示例：最后一页）\n                    PdfPageBase targetPage = pdfDoc.Pages[pdfDoc.Pages.Count - 1];\n                    // MakeSignature 参数说明：签名名称、目标页面、X坐标、Y坐标、宽度、高度、外观\n                    signMaker.MakeSignature(\"Advanced_Signature_001\", targetPage, \n                        54.0f, 330.0f, 280.0f, 90.0f, appearance);\n\n                    // 7. 保存文档\n                    pdfDoc.SaveToFile(\"Signed_Advanced.pdf\");\n                    Console.WriteLine(\"可视化签名添加成功！\");\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"签名失败：{ex.Message}\");\n                Console.WriteLine($\"异常详情：{ex.StackTrace}\");\n            }\n        }\n    }\n}\n</code></pre>\n<h2 id=\"三关键参数与类说明\">三、关键参数与类说明</h2>\n<ul>\n<li><code>PdfOrdinarySignatureMaker</code>：核心签名器类，关联PDF文档与 X.509 证书，执行签名操作。</li>\n<li><code>X509Certificate2</code>：加载 .pfx 格式数字证书，解析私钥与公钥。</li>\n<li><code>X509KeyStorageFlags</code>：密钥存储标志，控制证书加载的存储区与密钥生命周期\n<ul>\n<li><code>MachineKeySet</code> 适配服务器环境</li>\n<li><code>EphemeralKeySet</code> 提升安全性</li>\n</ul>\n</li>\n<li><code>PdfSignatureAppearance</code>：配置可见签名的外观，包括签名框位置、文本信息等。</li>\n<li><code>GraphicMode</code>：可见签名布局样式 (参数: <code>SignImageOnly</code> (仅图片), <code>SignDetailOnly</code> （仅文本）, <code>SignImageAndSignDetail</code> （图片+文本）)</li>\n<li><code>MakeSignature</code>：执行签名方法。</li>\n</ul>\n<h2 id=\"四注意事项\">四、注意事项</h2>\n<ol>\n<li>证书安全：.pfx 证书包含私钥，需加密存储，避免硬编码密码，建议通过配置文件/密钥管理服务管理；</li>\n<li>权限适配：服务器环境下加载证书需赋予应用程序足够的密钥访问权限，避免 <code>CryptographicException</code> ；</li>\n<li>兼容性测试：签名后的 PDF 需在 Adobe Acrobat、WPS、浏览器等主流阅读器中验证显示与签名有效性；</li>\n</ol>\n<h2 id=\"五总结\">五、总结</h2>\n<p>基于 Spire.PDF for .NET 的 C# 实现方案，以 “轻量化、低门槛、易集成” 为核心优势，仅需数十行代码即可完成 PDF 电子签名的基础与进阶功能。该方案适配 .NET Framework/.NET Core/.NET 5+ 全框架，能快速落地到企业级文档处理系统中。如需更高的安全性与合规性，可结合 CA 证书、时间戳服务进一步扩展。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"itemdesc\">\n                发表于 \n<span id=\"post-date\">2025-12-25 10:17</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jazz-z\">LAYONTHEGROUND</a>&nbsp;\n阅读(<span id=\"post_view_count\">126</span>)&nbsp;\n评论(<span id=\"post_comment_count\">3</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n            </div>"
    },
    {
      "title": "超越 SpringBoot 4.0了吗？OpenSolon v3.8, v3.7.4, v3.6.7 发布",
      "link": "https://www.cnblogs.com/noear/p/19395962",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/noear/p/19395962\" id=\"cb_post_title_url\" title=\"发布于 2025-12-25 09:23\">\n    <span>超越 SpringBoot 4.0了吗？OpenSolon v3.8, v3.7.4, v3.6.7 发布</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        OpenSolon v3.8正式发布，带来多项架构级升级。作为新一代Java企业级开发框架，OpenSolon以\"快速、小巧、简洁\"为理念，历时8年积累1.7万次代码提交，半年下载量达1200万次。本次更新包括：超前适配Java 25支持ScopedValue、AI领域增强MCP无状态集群支持、重构Flow流程引擎为通用WorkflowService、优化SnEL表达式引擎与缓存性能。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"导引\">导引</h2>\n<p>（听说隔壁的 Spring 7 和 SpringBoot 4 最近出了几个大 Bug了？！）历时 8 年磨砺，1.7 万次代码提交，9个分仓库，几百个模块，20多万代码量， 1200 万次半年下载量 —— OpenSolon（即 Solon）正在重新定义 Java 企业级应用开发的性价比。</p>\n<p>今日，我们正式发布 OpenSolon v3.8 及其 LTS 维护版本。是一次架构级的跨越：从 AI 领域的 MCP 无状态集群支持，到 Flow 流程引擎的回归通用化，再到对 Java 新版本（v25）的超前布局，OpenSolon 持续践行“快速、小巧、简洁”的克制美学。</p>\n<p>无论你是追求算力性价比的极致主义者，还是正在寻找安全可靠的国产基座，这次更新都值得你关注。</p>\n<ul>\n<li>【超前适配】 率先适配 Java 25，新增 ScopedValue 适配支持</li>\n<li>【AI 增强】 solon-ai 深度支持 MCP 无状态会话集群与异步工具</li>\n<li>【架构重构】 solon-flow 回归通用流程引擎，推出全新的 WorkflowService 封装；</li>\n<li>【性能优化】 全面优化表达式引擎（SnEL）与缓存性能，持续保持高并发、省内存的领先优势。</li>\n</ul>\n<h2 id=\"opensolon-开源框架也称solon\">OpenSolon 开源框架！（也称：Solon）</h2>\n<p>OpenSolon 是新一代，Java 企业级应用开发框架。<strong>从零开始构建（No Java-EE），有灵活的接口规范与开放生态</strong>。采用商用友好的 Apache  2.0 开源协议，是“杭州无耳科技有限公司”开源的根级项目，是 Java 应用开发的生态基座（可替换美国博通公司的 Spring 生态）。</p>\n<ul>\n<li>追求： 快速、小巧、简洁</li>\n<li>提倡： 克制、高效、开放</li>\n</ul>\n<p>7年开源时间，累计代码提交1.6万次 ，近半年下载量1200万次。</p>\n<ul>\n<li>有透明可预期的<a href=\"https://solon.noear.org/article/687\" rel=\"noopener nofollow\" target=\"_blank\">《版本发布与长期支持计划（LTS）》</a></li>\n<li>有“<a href=\"https://solon.noear.org/article/support\" rel=\"noopener nofollow\" target=\"_blank\">【社区交流】</a>”和“<a href=\"https://solon.noear.org/article/services\" rel=\"noopener nofollow\" target=\"_blank\">【企业服务】</a>”双重技术支持</li>\n</ul>\n<p>同时支持运行时环境（不基于 java-ee 构建，所以可以同时兼容）：</p>\n<ul>\n<li>java8, java11, java17, java21, java25</li>\n</ul>\n<p>目前有几个主要的项目仓库：</p>\n<table>\n<thead>\n<tr>\n<th>代码仓库</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://gitee.com/opensolon/solon\" rel=\"noopener nofollow\" target=\"_blank\">/opensolon/solon</a></td>\n<td>Solon ,主代码仓库</td>\n</tr>\n<tr>\n<td><a href=\"https://gitee.com/opensolon/solon-examples\" rel=\"noopener nofollow\" target=\"_blank\">/opensolon/solon-examples</a></td>\n<td>Solon ,官网配套示例代码仓库</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://gitee.com/opensolon/solon-expression\" rel=\"noopener nofollow\" target=\"_blank\">/opensolon/solon-expression</a></td>\n<td>Solon Expression ,代码仓库</td>\n</tr>\n<tr>\n<td><a href=\"https://gitee.com/opensolon/solon-flow\" rel=\"noopener nofollow\" target=\"_blank\">/opensolon/solon-flow</a></td>\n<td>Solon Flow ,代码仓库</td>\n</tr>\n<tr>\n<td><a href=\"https://gitee.com/opensolon/solon-ai\" rel=\"noopener nofollow\" target=\"_blank\">/opensolon/solon-ai</a></td>\n<td>Solon Ai ,代码仓库</td>\n</tr>\n<tr>\n<td><a href=\"https://gitee.com/opensolon/solon-cloud\" rel=\"noopener nofollow\" target=\"_blank\">/opensolon/solon-cloud</a></td>\n<td>Solon Cloud ,代码仓库</td>\n</tr>\n<tr>\n<td><a href=\"https://gitee.com/opensolon/solon-admin\" rel=\"noopener nofollow\" target=\"_blank\">/opensolon/solon-admin</a></td>\n<td>Solon Admin ,代码仓库</td>\n</tr>\n<tr>\n<td><a href=\"https://gitee.com/opensolon/solon-integration\" rel=\"noopener nofollow\" target=\"_blank\">/opensolon/solon-integration</a></td>\n<td>Solon Integration ,代码仓库</td>\n</tr>\n<tr>\n<td><a href=\"https://gitee.com/opensolon/solon-java17\" rel=\"noopener nofollow\" target=\"_blank\">/opensolon/solon-java17</a></td>\n<td>Solon Java17 适配仓库（base java17）</td>\n</tr>\n<tr>\n<td><a href=\"https://gitee.com/opensolon/solon-java25\" rel=\"noopener nofollow\" target=\"_blank\">/opensolon/solon-java25</a></td>\n<td>Solon Java25 适配仓库（base java25）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://gitee.com/opensolon/solon-gradle-plugin\" rel=\"noopener nofollow\" target=\"_blank\">/opensolon/solon-gradle-plugin</a></td>\n<td>Solon Gradle ,插件代码仓库</td>\n</tr>\n<tr>\n<td><a href=\"https://gitee.com/opensolon/solon-idea-plugin\" rel=\"noopener nofollow\" target=\"_blank\">/opensolon/solon-idea-plugin</a></td>\n<td>Solon Idea ,插件代码仓库</td>\n</tr>\n<tr>\n<td><a href=\"https://gitee.com/opensolon/solon-vscode-plugin\" rel=\"noopener nofollow\" target=\"_blank\">/opensolon/solon-vscode-plugin</a></td>\n<td>Solon VsCode ,插件代码仓库</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"有什么特点相对-java-spring-方案\">有什么特点（相对 Java Spring 方案）？</h2>\n<p>OpenSolon 对国产算力非常友好，对 cpu 和 memory 的需求远低于同类方案。</p>\n<table>\n<thead>\n<tr>\n<th>特点</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>更高的计算性价比</td>\n<td>并发高 700%；内存省 50%</td>\n</tr>\n<tr>\n<td>更快的开发效率</td>\n<td>代码少；入门简单；启动（或调试重启）快 10倍</td>\n</tr>\n<tr>\n<td>更好的生产与部署体验</td>\n<td>打包小 90%</td>\n</tr>\n<tr>\n<td>更大的兼容范围</td>\n<td>非 java-ee 架构；同时支持 java8 ～ java25，graalvm native image</td>\n</tr>\n</tbody>\n</table>\n<p>最新的 techempower （第三方知名测试平台）测试数据：</p>\n<ul>\n<li><a href=\"https://www.techempower.com/benchmarks/#hw=ph&amp;test=json%C2%A7ion=data-r23\" rel=\"noopener nofollow\" target=\"_blank\">https://www.techempower.com/benchmarks/#hw=ph&amp;test=json§ion=data-r23</a></li>\n<li><a href=\"https://www.techempower.com/benchmarks/#hw=ph&amp;test=plaintext%C2%A7ion=data-r23\" rel=\"noopener nofollow\" target=\"_blank\">https://www.techempower.com/benchmarks/#hw=ph&amp;test=plaintext§ion=data-r23</a></li>\n</ul>\n<h2 id=\"项目架构示意图全场景应用开发支持\">项目架构示意图（全场景应用开发支持）</h2>\n<img class=\"lazyload\" width=\"700\" />\n<h2 id=\"v380-更新说明\">v3.8.0 更新说明</h2>\n<ul>\n<li>插件 <code>solon-flow</code> 第六次预览</li>\n<li>新增 <code>solon-flow-workflow</code> 插件（替代 FlowStatefulService）</li>\n<li>新增 <code>solon-java25</code> 仓库（提供 ScopedValue 适配）</li>\n<li>添加 <code>solon</code> ScopeLocal 接口（用于 ThreadLocal 到 ScopedValue 兼容）</li>\n<li>添加 <code>solon</code> Solon.start(Class, MultiMap) 方法</li>\n<li>添加 <code>solon</code> ThreadsUtil:newVirtualThreadFactory 方法</li>\n<li>添加 <code>solon</code> ContextHolder:currentWith 方法，替代 currentSet（标为弃用）</li>\n<li>添加 <code>solon</code> Controller:remoting 属性（可替代 @Remoting 注解）</li>\n<li>添加 <code>solon</code> 非依赖关系的 bean 异步初始化（<code>@Init(async=true)</code>）</li>\n<li>添加 <code>solon</code> Stringable 接口</li>\n<li>添加 <code>solon</code> 'env.use' 配置支持（相对 'env'，它与 'env.on' 协作时不会冲突）</li>\n<li>添加 <code>solon</code> 'server.session.cookieHttpOnly' 配置支持（默认为 true）</li>\n<li>添加 <code>solon</code> Context.cookieSet(...,httpOnly) 方法</li>\n<li>添加 <code>solon-test</code> HttpTester protocol 参数支持（方便 https 或 http 切换测试）</li>\n<li>添加 <code>solon-serialization</code> JsonPropsUtil2.dateAsFormat 添加 java.sql.Timestamp 类型支持</li>\n<li>添加 <code>solon-config-yaml</code> 依赖 solon-config-snack4 避免单个引入时忘掉</li>\n<li>添加 <code>solon-net-httputils</code> HttpSslSupplierAny（方便无限制的 ssl 使用，但不建议）</li>\n<li>添加 <code>solon-web-rx</code> RxEntity 类（方便对接 mcp-sdk）</li>\n<li>添加 <code>solon-server</code> 会话状态的 cookie httpOnly 配置（默认为 false）</li>\n<li>添加 <code>solon-server-tomcat</code> ssl 适配支持</li>\n<li>添加 <code>solon-security-validation</code> ValidatorFailureHandlerI18n 支持验证注解的国际化处理<br />\n添加 <code>solon-expression</code> SnelParser 类，为 TemplateParser 和 EvaluateParser 提供出入口和占位符配置</li>\n<li>添加 <code>solon-flow</code> FlowContext:lastNode() 方法（最后一个运行的节点）</li>\n<li>添加 <code>solon-flow</code> FlowContext:lastNodeId() 方法（最后一个运行的节点Id）</li>\n<li>添加 <code>solon-flow</code> Node.getMetaAs, Link.getMetaAs 方法</li>\n<li>添加 <code>solon-flow</code> NodeSpec:linkRemove 方法（增强修改能力）</li>\n<li>添加 <code>solon-flow</code> Graph:create(id,title,consumer) 方法</li>\n<li>添加 <code>solon-flow</code> Graph:copy(graph,consumer) 方法（方便复制后修改）</li>\n<li>添加 <code>solon-flow</code> GraphSpec:getNode(id) 方法</li>\n<li>添加 <code>solon-flow</code> GraphSpec:addLoop(id) 方法替代 addLooping（后者标为弃用）</li>\n<li>添加 <code>solon-flow</code> FlowEngine:eval(Graph, ..) 系列方法</li>\n<li>添加 <code>solon-ai</code> FunctionPrompt:handleAsync（用于 mcp-server 异步支持）</li>\n<li>添加 <code>solon-ai</code> FunctionResource:handleAsync（用于 mcp-server 异步支持）</li>\n<li>添加 <code>solon-ai</code> FunctionTool:handleAsync（用于 mcp-server 异步支持）</li>\n<li>添加 <code>solon-ai-core</code> ChatMessage:toNdjson,fromNdjson 方法（替代 ChatSession:toNdjson, loadNdjson），新方法机制上更自由</li>\n<li>添加 <code>solon-ai-core</code> ToolSchemaUtil.jsonSchema Publisher 泛型支持</li>\n<li>添加 <code>solon-ai-mcp</code> mcp-java-sdk v0.17 适配（支持 2025-06-18 版本协议）</li>\n<li>添加 <code>solon-ai-mcp</code> mcp-server 异步支持</li>\n<li>添加 <code>solon-ai-mcp</code> mcp-server streamable_stateless 支持</li>\n<li>添加 <code>solon-ai-mcp</code> Tool,Resource,Prompt 对 org.reactivestreams.Publisher 异步返回支持</li>\n<li>添加 <code>solon-ai-mcp</code> McpServerHost 服务宿主接口，用于隔离有状态与无状态服务</li>\n<li>添加 <code>solon-ai-mcp</code> McpChannel.STREAMABLE_STATELESS （服务端）无状态会话</li>\n<li>添加 <code>solon-ai-mcp</code> McpClientProvider:customize 方法（用于扩展 roots, sampling 等）</li>\n<li>添加 <code>solon-ai-mcp</code> mcpServer McpAsyncServerExchange 注入支持（用于扩展 roots, sampling 等）</li>\n<li>优化 <code>solon</code> api-version 版本匹配</li>\n<li>优化 <code>solon</code> SnelUtil snel 表达式缺参数时异常提示（避免配错名字）</li>\n<li>优化 <code>solon</code> ParamWrap:getName 改用 ParamSpec.getAlias。加 '@Param(name=xxx)' 注解可生效</li>\n<li>优化 <code>solon-cache</code> CacheService 适配没有 _cacheKeyHead 配置时，则不加前缀</li>\n<li>优化 <code>solon-net-httputils</code> SslContextBuilder</li>\n<li>优化 <code>solon-expression</code> EvaluateParser 支持定义占位符（可支持 <code>{xxx}</code> 表达式）</li>\n<li>优化 <code>solon-expression</code> TemplateParser 支持定义占位符（可支持 <code>{xxx}</code> 表达式）</li>\n<li>优化 <code>solon-expression</code> LRUCache 性能（提高缓存性能）</li>\n<li>优化 <code>solon-ai-dialect-openai</code> claude 兼容性</li>\n<li>优化 <code>solon-ai-mcp mcp</code> StreamableHttp 模式下 服务端正常返回时 客户端异常日志打印的情况* 优化 <code>solon-flow</code> eval(Node startNode) 处理，改为从 root 开始恢复到 start 再开始执行（恢复过程中，不会执行任务）</li>\n<li>优化 <code>solon-flow</code> FlowEngine:eval(Node startNode) 处理，改为从 root 开始恢复到 start 再开始执行（恢复过程中，不会执行任务）</li>\n<li>调整 <code>nami</code> NamiAttachment 切换为 ScopeLocal 接口实现</li>\n<li>调整 <code>solon</code> ContextHolder 切换为 ScopeLocal 接口实现</li>\n<li>调整 <code>solon</code> RunHolder：parallelExecutor 改为 newFixedThreadPool</li>\n<li>调整 <code>solon-data</code> TranExecutorDefault 切换为 ScopeLocal 接口实现</li>\n<li>调整 <code>local-solon-cloud-plugin</code> 的 config 和 i18n 服务，如果没有 group 配置，则文件不带 group 前缀（之前默认给了 DEFAULT_GROUP 组名，显得复杂）</li>\n<li>调整 <code>rocketmq-solon-clouud-plugin</code> 的适配，事件属性不再加 '!' （并兼容旧格式）</li>\n<li>调整 <code>aliyun-ons-solon-clouud-plugin</code> 的适配，事件属性不再加 '!' （并兼容旧格式）</li>\n<li>调整 <code>rocketmq5-solon-clouud-plugin</code> 的适配，事件属性不再加 '!' （并兼容旧格式）。添加 sql92 过滤支持</li>\n<li>调整 <code>solon-flow</code> 移除 Activity 节点预览属性 \"$imode\" 和 \"$omode\"</li>\n<li>调整 <code>solon-flow</code> Activity 节点流出改为自由模式（可以多线流出：无条件直接流出，有条件检测后流出）</li>\n<li>调整 <code>solon-flow</code> Node.getMeta 方法返回改为 Object 类型（并新增 getMetaAs）</li>\n<li>调整 <code>solon-flow</code> Evaluation:runTest 改为 runCondition</li>\n<li>调整 <code>solon-flow</code> FlowContext:incrAdd,incrGet 标为弃用（上下文数据为型只能由输入侧决定）</li>\n<li>调整 <code>solon-flow</code> Condition 更名为 ConditionDesc</li>\n<li>调整 <code>solon-flow</code> Task 更名为 ConditionDesc</li>\n<li>调整 <code>solon-flow</code> XxxDecl 命名风格改为 XxxSpec</li>\n<li>调整 <code>solon-flow</code> GraphDecl.parseByXxx 命名风格改为 GraphSpec.fromXxx</li>\n<li>调整 <code>solon-flow</code> Graph.parseByXxx 命名风格改为 Graph.fromXxx</li>\n<li>调整 <code>solon-ai-mcp</code> getResourceTemplates、getResources 不再共享注册</li>\n<li>调整 <code>solon-ai-mcp</code> McpServerManager 内部接口更名为 McpPrimitivesRegistry （MCP 原语注册器）</li>\n<li>调整 <code>solon-ai-mcp</code> McpClientProvider 默认不启用心跳机制（随着 mcp-sdk 的成熟，server 都有心跳机制了）</li>\n<li>修复 <code>solon</code> IndexFiles 路径表达式的兼容问题（添加转换 <code>*-&gt;@</code>、<code>:-&gt;!</code>）</li>\n<li>修复 <code>solon</code> ParamWrap:getName 加 '@Param(name=xxx)' 注解时没有生效的问题（v3.7.0 出现）。对 solon-cache 会有影响</li>\n<li>修复 <code>solon-web-vertx</code> VxWebContext._requestBody 如果为 null 文件上传时会出错的问题</li>\n<li>修复 <code>solon-docs-openapi2</code> 返回类型中泛型失效的问题（v3.7.0 出现）</li>\n<li>snack4 升为 4.0.20</li>\n<li>jackson 升为 2.19.2</li>\n<li>liquor 升为 1.6.6</li>\n<li>asm 升为 9.9</li>\n</ul>\n<h4 id=\"solon-仓库补充说明\">solon 仓库补充说明</h4>\n<p>新特性：</p>\n<pre><code class=\"language-java\">public class Demo {\n   static ScopeLocal&lt;String&gt; LOCAL = ScopeLocal.newInstance();\n\n   public void test(){\n       LOCAL.with(\"test\", ()-&gt;{\n           System.out.println(LOCAL.get());\n       });\n   }\n}\n</code></pre>\n<h4 id=\"solon-ai-仓库补充说明\">solon-ai 仓库补充说明</h4>\n<p>新特性展示：1.MCP 无状态会话（STREAMABLE_STATELESS）和 2.CompletableFuture 异步MCP工具</p>\n<pre><code class=\"language-java\">@McpServerEndpoint(channel = McpChannel.STREAMABLE_STATELESS, mcpEndpoint = \"/mcp1\")\npublic class McpServerTool {\n    @ToolMapping(description = \"查询天气预报\", returnDirect = true)\n    public CompletableFuture&lt;String&gt; getWeather(@Param(description = \"城市位置\") String location) {\n        return CompletableFuture.completedFuture(\"晴，14度\");\n    }\n}\n</code></pre>\n<p>传输方式对应表：（服务端与客户端，须使用对应的传输方式才可通讯）</p>\n<table>\n<thead>\n<tr>\n<th>服务端</th>\n<th>客户端</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>STDIO</td>\n<td>STDIO</td>\n<td></td>\n</tr>\n<tr>\n<td>SSE</td>\n<td>SSE</td>\n<td></td>\n</tr>\n<tr>\n<td>STREAMABLE</td>\n<td>STREAMABLE</td>\n<td></td>\n</tr>\n<tr>\n<td>STREAMABLE_STATELESS</td>\n<td>STREAMABLE</td>\n<td>对 server 集群很友好</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>STREAMABLE_STATELESS 集群，不需要 ip_hash，但“原语”变化后无法通知 client</li>\n</ul>\n<h4 id=\"solon-flow-仓库补充说明\">solon-flow 仓库补充说明</h4>\n<p>重要变化：</p>\n<ul>\n<li>取消“有状态”、“无状态”概念。</li>\n<li>solon-flow 回归通用流程引擎（分离“有状态”的概念）。</li>\n<li>新增 solon-flow-workflow 为工作流性质的封装（未来可能会有 dataflow 等）。</li>\n</ul>\n<p>兼容变化对照表：</p>\n<table>\n<thead>\n<tr>\n<th>旧名称</th>\n<th>新名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>GraphDecl</code></td>\n<td><code>GraphSpec</code></td>\n<td>图定义</td>\n</tr>\n<tr>\n<td><code>GraphDecl.parseByXxx</code></td>\n<td><code>GraphSpec.fromXxx</code></td>\n<td>图定义加载</td>\n</tr>\n<tr>\n<td><code>Graph.parseByXxx</code></td>\n<td><code>Graph.fromXxx</code></td>\n<td>图加载</td>\n</tr>\n<tr>\n<td><code>LinkDecl</code></td>\n<td><code>LinkSpec</code></td>\n<td>连接定义</td>\n</tr>\n<tr>\n<td><code>NodeDecl</code></td>\n<td><code>NodeSpec</code></td>\n<td>节点定义</td>\n</tr>\n<tr>\n<td><code>Condition</code></td>\n<td><code>ConditionDesc</code></td>\n<td>条件描述</td>\n</tr>\n<tr>\n<td><code>Task</code></td>\n<td><code>TaskDesc</code></td>\n<td>任务描述（避免与 workflow 的概念冲突）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>FlowStatefulService</code></td>\n<td><code>WorkflowService</code></td>\n<td>工作流服务</td>\n</tr>\n<tr>\n<td><code>StatefulTask</code></td>\n<td><code>Task</code></td>\n<td>任务</td>\n</tr>\n<tr>\n<td><code>Operation</code></td>\n<td><code>TaskAction</code></td>\n<td>任动工作</td>\n</tr>\n<tr>\n<td><code>TaskType</code></td>\n<td><code>TaskState</code></td>\n<td>任务状态</td>\n</tr>\n</tbody>\n</table>\n<p>FlowStatefulService 到 WorkflowService 的接口变化对照表：</p>\n<table>\n<thead>\n<tr>\n<th>旧名称</th>\n<th>新名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>postOperation(..)</code></td>\n<td><code>postTask(..)</code></td>\n<td>提交任务</td>\n</tr>\n<tr>\n<td><code>postOperationIfWaiting(..)</code></td>\n<td><code>postTaskIfWaiting(..)</code></td>\n<td>提交任务</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>evel(..)</code></td>\n<td>/</td>\n<td>执行</td>\n</tr>\n<tr>\n<td><code>stepForward(..)</code></td>\n<td>/</td>\n<td>单步前进</td>\n</tr>\n<tr>\n<td><code>stepBack(..)</code></td>\n<td>/</td>\n<td>单步后退</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>/</td>\n<td><code>getState(..)</code></td>\n<td>获取状态</td>\n</tr>\n</tbody>\n</table>\n<p>新特性预览：Graph 硬编码方式（及修改能力增强）</p>\n<pre><code class=\"language-java\">//硬编码\nGraph graph = Graph.create(\"demo1\", \"示例\", spec -&gt; {\n    spec.addStart(\"start\").title(\"开始\").linkAdd(\"01\");\n    spec.addActivity(\"n1\").task(\"@AaMetaProcessCom\").linkAdd(\"end\");\n    spec.addEnd(\"end\").title(\"结束\");\n});\n\n//修改\nGraph graphNew = Graph.copy(graph, spec -&gt; {\n    spec.getNode(\"n1\").linkRemove(\"end\").linkAdd(\"n2\"); //移掉 n1 连接；改为 n2 连接\n    spec.addActivity(\"n2\").linkAdd(\"end\");\n});\n</code></pre>\n<p>新特性预览：FlowContext:lastNodeId （计算的中断与恢复）。参考：<a href=\"https://solon.noear.org/article/1246\" rel=\"noopener nofollow\" target=\"_blank\">https://solon.noear.org/article/1246</a></p>\n<pre><code class=\"language-java\">flowEngine.eval(graph, context.lastNodeId(), context);\n//...（从上一个节点开始执行）\nflowEngine.eval(graph, context.lastNodeId(), context);\n</code></pre>\n<p>新特性预览：WorkflowService（替代 FlowStatefulService）</p>\n<pre><code class=\"language-java\">WorkflowService workflow = WorkflowService.of(engine, WorkflowDriver.builder()\n        .stateController(new ActorStateController()) \n        .stateRepository(new InMemoryStateRepository()) \n        .build());\n\n\n//1. 取出任务\nTask task = workflow.getTask(graph, context);\n\n//2. 提交任务\nworkflow.postTask(task.getNode(), TaskAction.FORWARD, context);\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-25 09:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/noear\">带刺的坐椅</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}