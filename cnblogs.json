{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "从春晚舞台到全球赛场：中国人形机器人，到底走到了哪一步？",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19627638",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19627638\" id=\"cb_post_title_url\" title=\"发布于 2026-02-21 10:56\">\n    <span>从春晚舞台到全球赛场：中国人形机器人，到底走到了哪一步？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        2026年春晚的机器人表演，并非单纯的舞台炫技，而是中国人形机器人产业的一次国家级路演。四家企业分别在**高动态运动控制、多机集群协同、仿生情感交互、具身智能落地**四大核心方向，展现了中国在人形机器人领域从跟跑到并跑、部分领域领跑的产业格局。相较于海外企业聚焦实验室参数、军事场景、长期测试的技术路线，中国企业更注重场景落地、成本控制、规模化量产，形成了差异化的竞争优势，推动人形机器人从实验室走向工业、商业、家庭等真实场景，2026年也被业内视为人形机器人规模化应用的元年。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>2026年央视春节联欢晚会创下春晚历史上机器人参与规模的新纪录，共有<strong>宇树科技、魔法原子、松延动力、银河通用</strong>四家核心国产人形机器人企业，携超200台机器人深度融入四大核心节目，覆盖武术、小品、歌舞、微电影全品类，全方位展现了中国人形机器人产业的技术突破与商业化落地能力。以下为各企业的详细拆解：</p>\n<h1 id=\"一宇树科技unitree-robotics\">一、宇树科技（Unitree Robotics）</h1>\n<h2 id=\"1-春晚节目表现\">1. 春晚节目表现</h2>\n<p>作为春晚“三朝元老”，宇树科技是武术节目《武BOT》的核心技术方，携20余台H2、G1系列人形机器人，与河南塔沟武术学校学员同台，完成<strong>全球首次全自主人形机器人集群武术表演</strong>。</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<p>节目中实现了3米弹射空翻、单脚连续空翻、蹬墙后空翻、Airflare大回旋七周半、4m/s集群快速跑位等高难度动作，同时完成挥剑、耍双节棍、醉拳等武术招式，集群动作同步误差小于0.1秒，全程零失误完成直播演出；同时在义乌分会场以“齐天大圣”造型机器人刷屏全网。</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"2-公司核心业务与实力\">2. 公司核心业务与实力</h2>\n<ul>\n<li>企业基础：2016年成立，总部位于杭州，国家级专精特新“小巨人”企业，<strong>全球足式机器人绝对龙头</strong>，四足机器人全球市占率超69.75%；2025年人形机器人出货量超5500台，位列全球第一。</li>\n<li>技术壁垒：实现从电机、减速器、控制器、运动控制算法到具身大模型的全栈自研，核心部件自研率超95%，国产化率超85%，累计拥有180余项授权专利。</li>\n<li>商业化落地：产品矩阵覆盖四足机器人Go/B2系列、人形机器人H/G/R三大系列，售价从3.99万元到65万元不等，已落地工业巡检、电力作业、科研教育、应急救援等场景；2024年营收突破10亿元，C轮融资后估值超120亿元，已完成IPO辅导，拟登陆科创板。</li>\n</ul>\n<h2 id=\"3-节目核心技术实现原理\">3. 节目核心技术实现原理</h2>\n<h3 id=\"0概述\">（0）概述</h3>\n<ul>\n<li><strong>硬件底层</strong>：主力机型H2全身自由度从19个提升至31个（单臂7个、单腿6个、3自由度腰部、2自由度颈部），动作精度达毫米级；自研内转子永磁同步电机扭矩密度达180Nm/kg，伺服响应速度0.001秒级，单臂峰值负载达21kg，支撑高爆发武术动作；搭载自研128线激光雷达与全新灵巧手，实现武术道具的稳定抓持与快速更换。</li>\n<li><strong>算法与集群控制</strong>：采用模型预测控制（MPC）+深度强化学习融合框架，机器人在仿真环境中完成上亿次动作迭代，自主习得复杂武术技巧与平衡控制；自研高并发集群控制系统与AI融合定位算法，通过3D激光雷达每秒上百次扫描舞台环境，实现无外部定位的全自主协同，攻克长序列表演的运动误差累计难题；依托5G专网+边缘计算，将集群指令传输延迟压缩至毫秒级，保障动作同步性。</li>\n<li><strong>直播容错机制</strong>：搭载全自主容错系统，机器人实时监测自身状态，跑偏后可快速归位；主控节点故障时0.3秒内切换备用主机，并有备用机器人待命，保障直播零失误。</li>\n</ul>\n<p><strong>《武BOT》节目中，机器人的所有动作可拆解为三大核心技术模块，每个模块都对应着全球性的技术难题，我们逐一拆解：</strong></p>\n<h3 id=\"1单机极限武术动作从能站稳到会打拳的核心突破\">（1）单机极限武术动作：从“能站稳”到“会打拳”的核心突破</h3>\n<p><strong>节目里做了什么</strong>：机器人完成了弹射空翻、Airflare大回旋、双节棍挥舞、醉拳倒地起身等连专业武术演员都需要长期训练的动作，甚至在3米弹射落地后，能瞬间调整平衡，无缝衔接下一个武术招式。</p>\n<p><strong>核心难点</strong>：这类高爆发动作的核心挑战，是机器人在重心剧烈变化、全身关节高速联动时，始终保持平衡，同时精准控制每一个动作的力度、角度和节奏——哪怕一个关节的扭矩输出偏差0.1%，就会导致机器人摔倒、表演失败。</p>\n<p><strong>底层实现原理</strong>：</p>\n<ul>\n<li>\n<p><strong>硬件底座：“肌肉骨骼”的极致性能</strong><br />\n主力机型H2全身自由度从19个提升至31个（单臂7个、单腿6个、3自由度腰部、2自由度颈部），相当于给机器人装上了能精准控制的“全身关节”；自研内转子永磁同步电机，扭矩密度达180Nm/kg，伺服响应速度达到0.001秒级，比人类神经反射速度快100倍，单臂峰值负载达21kg，能支撑高爆发的空翻、挥棍动作。<br />\n通俗类比：这就像给武术运动员装上了反应速度快100倍、力量控制精准到克的肌肉，既能爆发出空翻的爆发力，又能精准控制双节棍的轨迹，不伤到自己和搭档。</p>\n</li>\n<li>\n<p><strong>算法核心：“肌肉记忆”的AI训练</strong><br />\n采用<strong>模型预测控制（MPC）+深度强化学习</strong>的融合框架，这是机器人能完成复杂武术动作的核心。<br />\n通俗解释：团队先在数字仿真世界里，给机器人搭建了1:1的虚拟舞台，让AI控制的机器人在里面完成<strong>上亿次的动作训练</strong>——就像武术运动员在武馆里反复练习，摔倒了就调整参数重新来，最终让机器人自主习得复杂武术技巧和平衡控制能力。<br />\n其中，MPC算法相当于“实时教练”，每秒会对上百次机器人的重心、速度、关节状态进行预判，提前调整每个关节的扭矩输出，确保机器人在空翻、落地的全过程中，重心始终落在安全区间；而深度强化学习训练出的“肌肉记忆”，能让机器人在舞台地面有轻微打滑、重心出现偏差时，瞬间自主调整动作，就像武术运动员临场应变一样。</p>\n</li>\n<li>\n<p><strong>道具操作：“手眼协同”的精准控制</strong><br />\n机器人能稳定挥舞双节棍、长剑，核心在于搭载了自研128线激光雷达+视觉相机，配合全新灵巧手，每秒对道具的位置、自身的姿态进行上百次扫描校准，实现道具的稳定抓持与轨迹控制，确保双节棍的挥舞轨迹精准贴合武术动作设计，不会出现甩飞、节奏错位的问题。</p>\n</li>\n</ul>\n<h3 id=\"220余台机器人集群协同从单机跳到群体演的全球突破\">（2）20余台机器人集群协同：从“单机跳”到“群体演”的全球突破</h3>\n<p><strong>节目里做了什么</strong>：20余台机器人在没有外部定位设备的情况下，完成了4m/s高速跑位、复杂队形变换、与真人演员的实时对练，全程没有出现碰撞、跑偏，动作同步误差小于0.1秒，实现了全球首次全自主人形机器人集群武术表演。</p>\n<p><strong>核心难点</strong>：传统机器人集群表演，大多依赖舞台地面的二维码、外部动捕设备进行定位，相当于“开了外挂”；而宇树的机器人全程只靠自身机载传感器，在高速运动、舞台灯光复杂、真人演员动态移动的环境下，实现精准定位和协同，还要解决长序列表演中，每台机器人的动作误差累计问题——一旦一台机器人慢了0.05秒，整个集群的表演就会乱套。</p>\n<p><strong>底层实现原理</strong>：</p>\n<ul>\n<li>\n<p><strong>全自主定位：不依赖外挂的“环境感知”</strong><br />\n自研AI融合定位算法，通过机器人自带的3D激光雷达，每秒上百次扫描舞台环境，实时构建三维地图，同时匹配预存的舞台模型，计算出自身在舞台上的精准位置，定位精度达到毫米级，完全不需要外部动捕、二维码等辅助设备。<br />\n通俗类比：这就像你蒙着眼睛，但是你脑子里时刻知道自己在房间里的位置以及周围的情况，就能在熟悉的房间里精准走到指定位置，而且跑步前进也不会撞墙，精度还能达到毫米级。</p>\n</li>\n<li>\n<p><strong>高并发集群控制：零误差的“团队指挥”</strong><br />\n自研分布式集群控制系统，采用“统一时间基准+分布式轨迹规划”架构：首先通过5G专网+边缘计算，给所有机器人同步一个精准到微秒级的统一时间轴，确保每台机器人的动作“在同一个节拍上”，指令传输延迟压缩至毫秒级；<br />\n同时，主控系统只给机器人下发“目标位置、动作节拍”的核心指令，每台机器人自主规划自己的跑位路径、动作执行细节，还能实时感知周边机器人的位置，动态调整自己的路线，避免碰撞；哪怕某台机器人出现轻微跑偏，也能在0.2秒内自主调整归位，不影响整个集群的表演。</p>\n</li>\n<li>\n<p><strong>误差消除：长序列表演的“防跑偏机制”</strong><br />\n团队针对长序列武术表演，设计了“分段闭环校准”机制：把整个3分钟的节目，拆解成数十个关键动作节点，每完成一个节点的动作，所有机器人都会自动校准自身位置、动作节奏，把累计的误差清零，确保从节目开头到结尾，同步精度始终保持在0.1秒以内。</p>\n</li>\n</ul>\n<h3 id=\"3直播零失误国家级舞台的容错保障\">（3）直播零失误：国家级舞台的“容错保障”</h3>\n<p><strong>节目里做了什么</strong>：在春晚全球直播的高压场景下，20余台机器人全程零失误，没有出现一台故障、摔倒，完美完成表演。</p>\n<p><strong>底层实现原理</strong>：<br />\n搭载了全自主容错系统，每台机器人都会实时监测自身的电机温度、关节状态、电池电量、定位精度，一旦出现轻微异常，会自动调整动作参数，优先保障平衡和核心动作执行；如果出现主控节点故障，会在0.3秒内自动切换备用主机，同时舞台侧方还有待命的备用机器人，可在节目间隙无缝替换故障设备，彻底杜绝直播事故。</p>\n<h2 id=\"4-国内外技术对比\">4. 国内外技术对比</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>核心优势</th>\n<th>现存差距</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>运动性能</td>\n<td>高动态运动控制能力全球领先，完成了波士顿动力Atlas尚未实现的连续花式翻桌跑酷、集群协同武术表演等动作，单机极限动作参数跻身全球第一梯队</td>\n<td>在工业场景的长期稳定作业能力、复杂非结构化环境的泛化能力上，与波士顿动力、Agility Robotics仍有一定差距</td>\n</tr>\n<tr>\n<td>量产能力</td>\n<td>2025年出货量远超特斯拉Optimus（小批量测试阶段）、波士顿动力Atlas（非量产），是全球唯一实现高性能人形机器人万台级量产规划的企业</td>\n<td>-</td>\n</tr>\n<tr>\n<td>成本与供应链</td>\n<td>整机成本仅为Atlas的千分之一、Optimus的约1/3，核心部件成本仅为进口产品的1/10，全栈自研供应链摆脱海外技术依赖</td>\n<td>-</td>\n</tr>\n<tr>\n<td>智能能力</td>\n<td>-</td>\n<td>具身大模型的通用任务处理能力，相较于特斯拉Optimus的端到端大模型仍有提升空间</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"5-未来发展方向\">5. 未来发展方向</h2>\n<ul>\n<li>2026年目标人形机器人出货量1万-2万台，持续扩大全球市场份额；</li>\n<li>深化工业巡检、电力作业、应急救援等B端场景的规模化落地，实现单台机器人替代3人工作量；</li>\n<li>持续迭代具身智能大模型，提升机器人的通用任务处理能力与自主决策能力；</li>\n<li>推进消费级人形机器人的普及，以低价产品打开C端市场。</li>\n</ul>\n<h1 id=\"二魔法原子magiclab\">二、魔法原子（MagicLab）</h1>\n<h2 id=\"1-春晚节目表现-1\">1. 春晚节目表现</h2>\n<p>作为春晚智能机器人战略合作伙伴，魔法原子是本届春晚首家亮相的机器人企业。主会场歌曲《智造未来》中，携6台MagicBot Z1高动态小人形机器人、2台MagicBot Gen1全尺寸人形机器人，与易烊千玺、陈小春等艺人同台，完成360°托马斯回旋、侧空翻、同步舞蹈等高难度动作；宜宾分会场，上百台MagicDog四足机器人以“熊猫”造型完成<strong>全球首次百台级四足机器人公开舞台同步演绎</strong>；同时在贺岁短片中完成捞面、送餐等生活化操作。</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"2-公司核心业务与实力-1\">2. 公司核心业务与实力</h2>\n<ul>\n<li>企业基础：2024年1月成立，总部无锡，由追觅科技孵化，核心研发人员占比超70%；成立两年完成多轮融资，累计融资超5亿元，估值达35亿元。</li>\n<li>技术壁垒：核心硬件自研率超90%，覆盖关节模组、灵巧手、伺服电机、谐波减速器等23类核心部件，自研关节峰值扭矩最高达525N·m，跻身行业第一梯队；软件层面打造“<strong>原子万象”具身智能大模型</strong>，采用“大脑+小脑”双模架构。</li>\n<li>商业化落地：产品矩阵包括人形机器人MagicBot Gen1/Z1、四足机器人MagicDog系列，覆盖工业巡检、商业服务、家庭陪伴、文旅演艺、教育娱乐等场景，已在27个国家建立本地化团队。</li>\n</ul>\n<h2 id=\"3-节目核心技术实现原理-1\">3. 节目核心技术实现原理</h2>\n<p>魔法原子在春晚的表演，覆盖了“高动态街舞、百台级集群同步、生活化精细操作”三大完全不同的技术方向，我们逐一拆解每个动作的实现逻辑：</p>\n<h3 id=\"0概述-1\">（0）概述</h3>\n<ul>\n<li><strong>硬件底层</strong>：MagicBot Z1奔跑速度突破4m/s，搭载自研高功率密度关节模组，支撑高动态舞蹈与空翻动作；Gen1全尺寸人形机器人双臂最大负载达50kg，搭载自研6自由度灵巧手，实现捞面、端餐等精细操作。</li>\n<li><strong>集群控制</strong>：采用分布式集群控制系统，通过时间同步算法与多智能体轨迹规划，实现上百台四足机器人的毫秒级动作同步，同步误差小于0.01秒；通过纯视觉SLAM定位，实现无外部辅助的自主编队与动态避障。</li>\n<li><strong>智能算法</strong>：“原子万象”具身大模型采用快慢双模协同架构，“大脑”负责任务规划与场景理解，“小脑”负责实时运动控制与平衡调节，通过数百万条工业场景真实数据训练，实现任务的自主泛化。</li>\n</ul>\n<h3 id=\"1主会场街舞表演托马斯全旋与同步舞蹈的技术突破\">（1）主会场街舞表演：托马斯全旋与同步舞蹈的技术突破</h3>\n<p><strong>节目里做了什么</strong>：6台MagicBot Z1小人形机器人，与真人艺人同台完成了360°托马斯回旋、侧空翻、连续街舞动作，同时与音乐节拍、艺人动作完美同步，转身、摆臂、重心迁移全程连贯流畅，多机动作同步误差小于0.01秒。</p>\n<p><strong>核心难点</strong>：托马斯全旋这类街舞动作，需要机器人在单臂支撑全身重量的同时，完成腰部、腿部的高速圆周摆动，重心全程在快速变化，对关节的负载能力、扭矩控制精度、平衡调节速度提出了极致要求；同时多机协同舞蹈，需要每台机器人的每一个动作，都精准贴合音乐节拍，差0.01秒就会出现“抢拍、慢拍”的问题。</p>\n<p><strong>底层实现原理</strong>：</p>\n<ul>\n<li>\n<p><strong>硬件支撑：高功率密度的“关节心脏”</strong><br />\nMagicBot Z1搭载了自研的高功率密度一体化关节模组，在小尺寸机身内实现了超高扭矩输出，奔跑速度突破4m/s，单臂能稳定支撑整机8kg的重量，同时完成高速摆动，这是实现托马斯全旋的物理基础。<br />\n团队针对街舞动作的高频次、高负载特性，优化了关节的散热结构与电流管理策略，确保机器人在连续3分钟的高动态舞蹈中，不会因为关节过热触发保护机制，保证动作全程稳定输出。</p>\n</li>\n<li>\n<p><strong>平衡控制：动态重心的实时调节</strong><br />\n采用<strong>零力矩点（ZMP）平衡控制算法</strong>，配合全身力控技术，在托马斯全旋的全过程中，每秒数百次计算机器人的重心位置、支撑区域，实时调整手臂、腰部、腿部的关节角度和扭矩输出，确保重心始终落在支撑臂的安全范围内，不会出现侧翻、摔倒的问题。<br />\n通俗类比：这就像你单臂撑在地上做圆周摆腿，大脑需要全程感知自己的重心，随时调整手臂的发力、腰腹的扭转、腿部的摆动，确保自己不会摔倒——而机器人的“大脑”，每秒能做数百次这样的调整，精度比人类高上千倍。</p>\n</li>\n<li>\n<p><strong>节拍同步：零误差的“音乐卡点”</strong><br />\n团队给所有机器人搭建了统一的高精度时间同步系统，以音乐的音频波形为基准，把每一个舞蹈动作都精准对应到音乐的节拍点上，每台机器人的动作启动时间、执行时长，都精准锁定到毫秒级，确保6台机器人的动作完全同步，与艺人的表演、音乐的节奏完美契合。</p>\n</li>\n</ul>\n<h3 id=\"2宜宾分会场百台熊猫机器狗的集群表演\">（2）宜宾分会场：百台熊猫机器狗的集群表演</h3>\n<p><strong>节目里做了什么</strong>：上百台MagicDog四足机器人，以熊猫造型亮相，在宜宾分会场的城市广场上，完成了奔跑、列阵、队形变换、同步舞蹈，甚至实现了自然的歪头、点头等拟人化动作，全程动作整齐划一，没有出现一台掉队、碰撞。</p>\n<p><strong>核心难点</strong>：百台级四足机器人的户外集群表演，核心挑战有三个：一是户外广场地面不平整、灯光环境复杂，机器人的自主定位难度远高于室内舞台；二是百台机器人的动作同步，需要解决大规模集群的指令传输延迟、误差累计问题；三是熊猫外皮包裹后，机身散热空间被压缩，需要解决高负载连续运行的稳定性问题。</p>\n<p><strong>底层实现原理</strong>：</p>\n<ul>\n<li>\n<p><strong>分布式集群控制系统：百台机器人的“统一指挥”</strong><br />\n采用“主站+分布式从站”的集群控制架构，主站系统只负责下发整体的表演序列、队形变换指令，每台机器狗自主完成动作执行、路径规划、定位校准；通过时间敏感网络（TSN）技术，给所有机器人同步统一的时间基准，确保百台机器人的动作启动时间误差小于0.01秒，实现“整齐划一”的表演效果。</p>\n</li>\n<li>\n<p><strong>纯视觉SLAM定位：户外场景的精准导航</strong><br />\n每台机器狗都搭载了双目视觉相机+IMU惯性测量单元，通过纯视觉SLAM技术，实时构建户外场景的三维地图，匹配自身位置，同时感知周边其他机器人的位置，动态调整行进路线，避免碰撞；哪怕户外地面不平整、出现轻微打滑，也能自主调整步态，快速回到预定位置，完成队形变换。</p>\n</li>\n<li>\n<p><strong>散热与功率优化：外皮包裹下的稳定运行</strong><br />\n针对熊猫外皮压缩散热空间的问题，团队优化了整机的电流管理与功率控制策略，在不影响动作表现力的前提下，降低了连续运动状态下的关节发热量，同时优化了机身的散热结构，确保机器人在长达数分钟的连续表演中，不会因为过热触发保护，稳定完成所有动作。</p>\n</li>\n</ul>\n<h3 id=\"3贺岁短片捞面倒酒的精细操作\">（3）贺岁短片：捞面、倒酒的精细操作</h3>\n<p><strong>节目里做了什么</strong>：MagicBot Gen1全尺寸人形机器人，在短片中完成了捞面、端餐、倒酒等生活化操作，面条捞取、汤汁倾倒的力度控制精准，没有出现洒漏、面条断裂的问题。</p>\n<p><strong>核心难点</strong>：这类精细操作的核心挑战，是机器人对柔性物体（面条）、易碎容器（碗、酒杯）的力控精度——力度太大，会夹断面条、捏碎杯子；力度太小，会夹不住面条、端不稳碗；同时还要精准控制倾倒的角度和速度，确保汤汁、酒水不会洒漏。</p>\n<p><strong>底层实现原理</strong>：</p>\n<ul>\n<li>\n<p><strong>6自由度灵巧手：微米级的力控精度</strong><br />\nGen1搭载了自研6自由度灵巧手，指尖搭载了高精度力传感器，力控精度达到0.5N，能精准感知抓取物体的反馈力度，实现“柔性抓取”——捞面条时，能精准控制指尖的夹持力，既牢牢夹住面条，又不会把面条夹断；端碗时，能根据碗的重量、重心变化，实时调整手臂的姿态，确保碗始终保持水平，汤汁不会洒漏。</p>\n</li>\n<li>\n<p><strong>“大脑+小脑”双架构：从任务规划到精准执行</strong><br />\n自研的“原子万象”具身智能大模型，采用“大脑+小脑”的快慢双模协同架构：“大脑”负责任务规划与场景理解，比如接收到“捞面”的指令后，会自动拆解成“移动到锅前-张开手-伸入锅中-夹住面条-抬起-放入碗中”的分步动作；“小脑”负责实时运动控制与力控调节，在每一步动作执行中，实时调整手臂的位置、指尖的力度，应对面条的柔性变化、碗的重量变化，确保任务精准完成。</p>\n</li>\n</ul>\n<h2 id=\"4-国内外技术对比-1\">4. 国内外技术对比</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>核心优势</th>\n<th>现存差距</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>集群协同</td>\n<td>多机协同群控能力全球领先，完成全球首次百台级四足机器人公开舞台同步表演，分布式控制技术跻身行业第一梯队</td>\n<td>-</td>\n</tr>\n<tr>\n<td>产品性价比</td>\n<td>依托追觅科技的供应链优势，实现高自研率下的极致成本控制，产品性价比远超海外同级别产品</td>\n<td>-</td>\n</tr>\n<tr>\n<td>落地速度</td>\n<td>成立仅两年即实现多场景商业化落地，落地速度行业领先</td>\n<td>全尺寸人形机器人的长期稳定运行能力、复杂场景的泛化能力，相较于宇树科技、波士顿动力仍有差距</td>\n</tr>\n<tr>\n<td>智能能力</td>\n<td>-</td>\n<td>具身大模型的训练数据量与通用能力，相较于银河通用、特斯拉仍有提升空间</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"5-未来发展方向-1\">5. 未来发展方向</h2>\n<ul>\n<li>2026年工业场景计划千台级规模部署，在追觅工厂等场景落地物料搬运、点胶检测等工序；</li>\n<li>加速无人咖啡、无人药房等零售解决方案的推广，目标1-2年覆盖全球10000家门店；</li>\n<li>推进四足机器人导盲犬项目“光引001”的落地，切入助残普惠场景；</li>\n<li>持续拓展海外市场，提升全球化营收占比。</li>\n</ul>\n<h1 id=\"三松延动力noetix-robotics\">三、松延动力（Noetix Robotics）</h1>\n<h2 id=\"1-春晚节目表现-2\">1. 春晚节目表现</h2>\n<p>作为春晚<strong>仿生人形机器人独家合作伙伴</strong>，松延动力携5款机器人参演小品《奶奶的最爱》，成为首个登上春晚语言类节目的机器人企业。其中1:1复刻蔡明的仿生机器人，以近乎真人的面部神态、口型同步、微表情动作，与真人演员完成对戏；同时4台双足人形机器人完成端茶、互动等生活化动作。</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"2-公司核心业务与实力-2\">2. 公司核心业务与实力</h2>\n<ul>\n<li>企业基础：2023年9月成立，总部北京，创始团队来自清华、浙大；2025年一年内完成5轮融资，估值约20亿元。</li>\n<li>技术壁垒：核心技术覆盖仿生人脸驱动、多模态交互大模型、双足运动控制，是国内少数实现仿生人形机器人批量生产的企业；自研D2P数字人映射技术，实现虚拟数字人到实体机器人的精准映射。</li>\n<li>商业化落地：构建了N系列、E系列、轮式机器人W1、“小布米”系列的产品矩阵；旗下万元级消费级双足机器人“小布米”（定价9998元），2025年10月发售即斩获数千台订单，是<strong>全球首款万元级消费级双足人形机器人</strong>，产品已落地商业导览、教育科研、家庭陪伴等场景。</li>\n</ul>\n<h2 id=\"3-节目核心技术实现原理-2\">3. 节目核心技术实现原理</h2>\n<p>松延动力在小品中的表演，核心分为两大技术方向，也是仿生人形机器人最核心的两个难题：<strong>“长得像、演得真”的仿生交互</strong>，以及<strong>“走得稳、做得准”的生活化动作</strong>，我们逐一拆解：</p>\n<h3 id=\"0概述-2\">（0）概述</h3>\n<ul>\n<li><strong>仿生人脸核心技术</strong>：通过铂金硅胶添加高分子材料，提升面部拉伸自然度与耐久性；采用高紧凑型驱动设计，在仿生人脸内部集成32-40个微型电机，实现表情、口型、眼神的精准控制；自研D2P数字人映射技术，将虚拟数字人的表情、口型数据，实时映射到真实机器人的电机转角上，实现语音与口型的1:1同步。</li>\n<li><strong>多模态交互</strong>：自研多模态交互大模型，实现语音、表情、眼神、肢体动作的协同表达，比如对话时的呼吸起伏、颈部与手臂的配合动作，大幅提升拟人交互体验。</li>\n<li><strong>运动控制</strong>：自研双足运动控制算法，实现机器人在家庭场景的稳定行走、端茶、搀扶等高精度动作，适配非结构化的家庭环境。</li>\n</ul>\n<h3 id=\"1蔡明仿生机器人真人级复刻与实时对戏的核心技术\">（1）蔡明仿生机器人：真人级复刻与实时对戏的核心技术</h3>\n<p><strong>节目里做了什么</strong>：1:1复刻蔡明老师的仿生机器人，在小品中与真人演员完成实时对戏，说话时口型与台词完全同步，同时配合台词做出眨眼、微笑、撇嘴、头部微动作等真人级微表情，甚至能根据对手演员的台词，实时做出对应的神态反馈，仿真度极高，在后台被多位演员误认成真人。</p>\n<p><strong>核心难点</strong>：语言类节目对仿生机器人的要求，远高于歌舞表演——不仅要“长得像”，更要“演得真”：口型要与台词1:1同步，差一帧就会出现“对口型穿帮”；微表情要贴合人物情绪，僵硬一点就会显得很“假”；同时还要在狭小的人脸空间内，放下足够多的驱动电机，还要保证上镜效果，团队甚至需要把仿生人头整体缩小30%，对结构设计提出了极致挑战。</p>\n<p><strong>底层实现原理</strong>：</p>\n<ul>\n<li>\n<p><strong>仿生人脸硬件：真人级的“皮肤与肌肉”</strong><br />\n首先在外观上，团队通过3D扫描，1:1复刻了蔡明老师的面部轮廓、五官细节，采用添加了高分子材料的铂金硅胶制作仿生皮肤，不仅在视觉上无限接近真人皮肤的质感，还提升了皮肤的拉伸自然度与耐久性，在做出表情时，皮肤的拉伸、褶皱都与真人完全一致，不会出现“塑料感”。<br />\n最核心的突破，是高紧凑型驱动设计：团队在缩小30%的仿生人脸内部，集成了<strong>32个微型驱动电机</strong>，分别对应人脸的眉、眼、口、鼻等核心表情区域，相当于给机器人装上了“人工面部肌肉”，每个电机都能精准控制对应区域的皮肤位移，实现微笑、撇嘴、眨眼、抬眉等数十种真人微表情，最小动作幅度可达0.1毫米，完全还原真人的面部神态。</p>\n</li>\n<li>\n<p><strong>D2P数字人映射技术：口型与表情的1:1同步</strong><br />\n这是实现真人级对戏的核心技术，自研的D2P（数字人到物理人）映射技术，能把虚拟数字人的表情、口型数据，实时、精准地映射到实体机器人的电机上。<br />\n通俗解释：团队先提前采集了蔡明老师说台词时的面部动作、口型变化数据，制作了1:1的虚拟数字人；当机器人需要说台词时，系统会先把语音台词转化为虚拟数字人的口型、表情动作，再通过D2P技术，把这些动作转化为32个微型电机的转动角度、速度指令，实时驱动电机动作，最终实现语音与口型的1:1同步，表情与台词情绪的完美契合，哪怕是台词里的气口、重音，都能对应到口型的细微变化上。</p>\n</li>\n<li>\n<p><strong>多模态交互大模型：实时对戏的“灵性反馈”</strong><br />\n自研多模态交互大模型，能实时识别对手演员的台词、语气、甚至面部表情，快速理解对话语境，输出对应的台词、表情和肢体动作；同时还能实现语音、表情、眼神、肢体动作的协同表达，比如说话时配合自然的头部转动、呼吸起伏，甚至是说话间隙的眼神互动，完全还原真人对话的状态，彻底摆脱了传统机器人“念台词”的僵硬感。</p>\n</li>\n</ul>\n<h3 id=\"2小布米双足机器人家庭场景的生活化动作\">（2）“小布米”双足机器人：家庭场景的生活化动作</h3>\n<p><strong>节目里做了什么</strong>：4台“小布米”消费级双足机器人，在小品中完成了稳定行走、端茶、敬礼、与演员互动挥手等动作，在客厅的非结构化环境中，全程行走稳定，端茶时没有出现洒漏，动作流畅自然。</p>\n<p><strong>核心难点</strong>：消费级双足机器人，受限于成本和尺寸，硬件性能无法和工业级大机型相比，要在家庭的瓷砖、地毯等不同地面上，实现稳定行走，还要完成端茶等精细操作，对算法的轻量化、平衡控制能力提出了极高要求。</p>\n<p><strong>底层实现原理</strong>：</p>\n<ul>\n<li>\n<p><strong>轻量化双足运动控制算法：小机身的稳定行走</strong><br />\n“小布米”身高94厘米，体重仅12公斤，全身21个自由度，团队针对小尺寸双足机器人，自研了轻量化的模型预测控制算法，能在算力有限的主控芯片上，实现每秒上百次的步态规划与平衡调节，在瓷砖、地毯等不同地面上，都能自主调整步幅、步速和关节角度，实现稳定行走，哪怕被轻微触碰，也能快速调整重心，不会摔倒。</p>\n</li>\n<li>\n<p><strong>力控抓取：端茶不洒的精细操作</strong><br />\n机器人的手部搭载了微型力传感器，端茶时，能精准控制夹持杯子的力度，既牢牢握住杯子，又不会捏碎纸杯；同时在行走过程中，手臂会实时调整姿态，抵消行走带来的晃动，确保杯子始终保持水平，杯里的水不会洒漏，完美适配家庭场景的服务需求。</p>\n</li>\n</ul>\n<h2 id=\"4-国内外技术对比-2\">4. 国内外技术对比</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>核心优势</th>\n<th>现存差距</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>仿生交互</td>\n<td>仿生人脸的高集成度驱动技术、多模态情感交互能力处于国内第一梯队，打破了海外企业在高端仿生机器人领域的垄断</td>\n<td>高动态运动控制能力，相较于宇树科技、波士顿动力有明显差距</td>\n</tr>\n<tr>\n<td>消费级普及</td>\n<td>率先实现消费级双足机器人的万元级定价，打开了C端市场的普及路径，差异化避开工业赛道红海竞争，商业化落地速度领先</td>\n<td>工业场景的落地能力与技术积累，弱于银河通用、魔法原子</td>\n</tr>\n<tr>\n<td>量产能力</td>\n<td>实现了仿生人形机器人的批量生产，量产能力远超海外同类型高端仿生产品</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"5-未来发展方向-2\">5. 未来发展方向</h2>\n<ul>\n<li>持续深化仿生人形机器人的技术迭代，推动产品在商业导览、康养陪护场景的规模化落地；</li>\n<li>推进消费级机器人“小布米”的量产与普及，拓展教育娱乐、家庭陪伴C端市场；</li>\n<li>深化与高校、科研院所的合作，推动人形机器人教学平台的落地；</li>\n<li>持续优化成本，推动人形机器人进入普通家庭。</li>\n</ul>\n<h1 id=\"四银河通用galbot\">四、银河通用（GALBOT）</h1>\n<h2 id=\"1-春晚节目表现-3\">1. 春晚节目表现</h2>\n<p>作为春晚<strong>指定具身大模型机器人</strong>，银河通用在贺岁微电影《我最难忘的今宵》中，携Galbot G1轮式双臂机器人亮相，与沈腾、马丽搭档，完成盘核桃、捡玻璃碎片、叠衣服、货架取物、串烤肠等生活化任务，实现了<strong>春晚舞台首次无预设脚本的机器人自主决策作业</strong>，无需提前编程，即可根据场景实时完成任务规划与执行。</p>\n<h2 id=\"2-公司核心业务与实力-3\">2. 公司核心业务与实力</h2>\n<ul>\n<li>企业基础：2023年5月成立，总部北京，由北大王鹤博士、前ABB高管姚腾洲联合创立，核心成员来自华为天才少年计划、百度、微软等企业；2025年12月完成超3亿美元融资，估值达30亿美元。</li>\n<li>技术壁垒：国内极少数实现“百亿数据集—具身大模型—机器人本体—场景规模化落地”全链条闭环的企业；自研“银河星脑AstraBrain”具身大模型体系，首创虚实结合的训练范式，构建了百亿级机器人干活数据集，是全球具身机器人大模型数据量最大的公司之一。</li>\n<li>商业化落地：产品主打Galbot系列轮式双臂通用机器人，采用“轮式底盘+折叠腿”复合结构，已实现千台级规模化落地，覆盖工业制造、智慧零售、医疗康养、城市服务等六大领域，合作客户包括宁德时代、德国博世、丰田汽车、北汽、宣武医院等龙头企业，2025年工业订单突破千台，创下具身智能领域商业化订单纪录。</li>\n</ul>\n<h2 id=\"3-节目核心技术实现原理通俗专业版\">3. 节目核心技术实现原理（通俗专业版）</h2>\n<p>银河通用的表演，和其他三家企业最大的区别，是<strong>完全没有预设的固定脚本</strong>——其他机器人的表演，哪怕动作再复杂，也是提前编排好的固定程序；而银河通用的机器人，是根据现场场景和任务指令，自主思考、自主规划、自主执行，这也是具身智能最核心的能力。我们以节目中几个典型任务为例，拆解其底层实现原理：</p>\n<h3 id=\"概述\">概述</h3>\n<ul>\n<li><strong>具身大模型核心</strong>：首创“合成仿真数据为主、真机采集数据为辅”的虚实结合训练管线，解决了全球机器人干活数据匮乏的行业难题；自研GraspVLA、GroceryVLA、NavFoM等端到端具身大模型，对透明、高光、不规则物体的抓取成功率稳定在95%以上，实现了任务的自主规划、动态避障、长程导航。</li>\n<li><strong>硬件架构</strong>：采用“轮式底盘+折叠腿+双臂”的复合结构，兼顾高速移动与越障能力，身高173cm、臂展190cm、升降行程65cm，双臂最大负载达50kg，搭载自研6自由度灵巧手，实现毫米级精细操作。</li>\n<li><strong>一体化控制系统</strong>：采用“大脑-小脑-神经控制”一体化系统，“大脑”（具身大模型）负责场景理解与任务规划，“小脑”负责运动控制与平衡调节，“神经控制”负责关节的实时伺服响应，实现端到端的任务执行，无需预设脚本。</li>\n</ul>\n<h3 id=\"核心任务逻辑无脚本自主作业的全链路流程\">核心任务逻辑：无脚本自主作业的全链路流程</h3>\n<p>不管是盘核桃、捡玻璃碎片，还是叠衣服、串烤肠，机器人执行所有任务，都遵循着<strong>“感知-决策-执行-反馈优化”</strong>的端到端全链路，这也是它能实现无脚本作业的核心，我们逐层拆解：</p>\n<h4 id=\"第一步感知看懂眼前的场景和物体\">第一步：感知——“看懂”眼前的场景和物体</h4>\n<p><strong>节目里的挑战</strong>：机器人需要识别出核桃、玻璃碎片、衣服、烤肠、签子等完全不同的物体，尤其是透明的玻璃碎片，在浅色桌面上几乎“隐形”，传统视觉系统很容易识别失败；同时还要适应舞台复杂的灯光变化，准确判断每个物体的位置、形状、大小、材质。</p>\n<p><strong>底层实现原理</strong>：</p>\n<ul>\n<li>机器人搭载了多模态感知系统，包括双目深度相机、激光雷达、触觉传感器，能同时获取场景的视觉、深度、触觉信息；</li>\n<li>自研的视觉大模型，在训练阶段见过了数十亿张真实场景图片，能精准识别上万种日常物体，哪怕是形状不规则的碎玻璃、褶皱的衣服，也能快速识别并分割出物体轮廓；</li>\n<li>针对透明物体识别的行业难题，团队通过仿真环境生成了海量的透明物体数据——不同厚度、不同碎裂形状、不同光照条件下的玻璃碎片，让机器人在虚拟世界中“见过”各种可能的透明形态，理解了透明物体的反光、折射规律，最终实现对玻璃碎片的识别成功率稳定在99%以上，哪怕是只有几毫米的玻璃渣，也能精准定位。</li>\n</ul>\n<h4 id=\"第二步决策想清楚任务该怎么做\">第二步：决策——“想清楚”任务该怎么做</h4>\n<p><strong>节目里的挑战</strong>：比如“捡玻璃碎片”这个任务，没有提前编程告诉机器人“先捡大的、再捡小的，用夹子夹，放到垃圾桶里”，机器人需要自主理解任务目标，把大任务拆解成可执行的小步骤，还要应对突发情况——比如玻璃碎片滚到了桌子底下，要自主规划路线，调整手臂姿态去捡。</p>\n<p><strong>底层实现原理</strong>：</p>\n<ul>\n<li>核心是自研的“银河星脑AstraBrain”具身大模型，它就像机器人的“大脑”，通过百亿级的机器人操作数据训练，已经学会了上千种日常任务的执行逻辑，能根据任务指令，自主拆解动作步骤。<br />\n通俗类比：就像你让一个人“把地上的玻璃碎片捡干净”，他不用你一步步教，就会自己去找垃圾桶、拿工具，先捡大块再捡小块，还会注意不被划伤——银河通用的具身大模型，就是让机器人具备了这样的自主思考能力。</li>\n<li>针对春晚的场景，团队还对大模型进行了轻量化微调，让它能快速适配舞台场景，针对不同任务快速输出最优的动作规划，同时具备容错能力——如果第一次捡玻璃没夹住，会自主调整夹子的开合角度、夹持位置，重新尝试，直到任务完成。</li>\n</ul>\n<h4 id=\"第三步执行精准完成精细操作\">第三步：执行——“精准完成”精细操作</h4>\n<p><strong>节目里的挑战</strong>：不同任务对操作的要求完全不同：盘核桃需要双手配合，力度既要足够转动核桃，又不能捏碎；串烤肠需要精准把烤肠穿到签子上，偏差1毫米就会穿歪；叠衣服需要抓住衣服的边角，精准完成折叠动作，这些都对机器人的动作精度、力控能力提出了极高要求。</p>\n<p><strong>底层实现原理</strong>：</p>\n<ul>\n<li>\n<p><strong>硬件基础：灵活又精准的“手臂和手”</strong><br />\nGalbot G1采用“轮式底盘+折叠腿+双臂”的复合结构，双臂最大负载达50kg，重复定位精度可达±0.02毫米，比头发丝还细；搭载自研6自由度灵巧手，指尖配备高精度力传感器，力控精度可达0.3N，既能实现串烤肠的毫米级精准定位，又能实现盘核桃、叠衣服的柔性力控。</p>\n</li>\n<li>\n<p><strong>“大脑-小脑-神经”一体化控制系统</strong><br />\n采用三级控制架构，实现端到端的精准执行：“大脑”（具身大模型）输出任务规划和动作指令；“小脑”（运动控制算法）负责把指令拆解成每个关节的转动角度、扭矩参数，实时调节手臂的运动轨迹和力度；“神经控制”（伺服系统）负责0.001秒级的实时响应，确保每个关节都精准执行指令，最终实现任务的完美执行。</p>\n</li>\n<li>\n<p><strong>虚实结合的训练范式：让机器人提前“练会”所有动作</strong><br />\n团队首创“合成仿真数据为主、真机采集数据为辅”的训练管线，解决了全球机器人干活数据匮乏的行业难题。通俗解释：在数字仿真世界里，生成了数百万种不同大小、材质、形状的虚拟物体，还有各种不同的场景，让机器人在虚拟世界里完成上千亿次的操作训练，练出了一套适应性极强的“通用操作能力”；再用少量真实世界的数据做微调，就能让机器人在真实场景里，轻松完成各种没见过的任务，这也是它能在春晚舞台上，无脚本完成多种生活化任务的核心原因。</p>\n</li>\n</ul>\n<h3 id=\"4-国内外技术对比-3\">4. 国内外技术对比</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>核心优势</th>\n<th>现存差距</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>场景落地</td>\n<td>具身大模型的场景落地能力全球领先，实现了全球首个百台级机器人7×24小时自主运营的零售店，工业、零售场景的规模化落地能力，远超特斯拉Optimus、波士顿动力等海外企业</td>\n<td>双足人形机器人的高动态运动控制能力，相较于宇树科技、波士顿动力有差距</td>\n</tr>\n<tr>\n<td>技术创新</td>\n<td>首创的虚实结合训练范式，解决了全球机器人干活数据匮乏的行业难题，具身大模型的操作泛化能力跻身全球第一梯队</td>\n<td>消费级市场的布局与产品，相较于松延动力较为滞后</td>\n</tr>\n<tr>\n<td>工业能力</td>\n<td>轮式双臂机器人的重载操作、精细操作能力处于行业第一梯队，已获得头部制造企业的千台级订单，商业化落地规模全球领先</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"5-未来发展方向-3\">5. 未来发展方向</h3>\n<ul>\n<li>2026年加大“银河太空舱”无人零售解决方案在全国的推广力度，实现千店级规模部署；</li>\n<li>深化与宁德时代、博世等工业客户的合作，扩大工业场景的千台级部署规模；</li>\n<li>持续迭代具身大模型，提升机器人的通用任务泛化能力，拓展医疗康养、城市服务等场景；</li>\n<li>推进IPO进程，提升资本市场影响力，巩固具身智能领域的龙头地位。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></li>\n</ul>\n<h1 id=\"整体总结\">整体总结</h1>\n<p>2026年春晚的机器人表演，并非单纯的舞台炫技，而是中国人形机器人产业的一次国家级路演。四家企业分别在<strong>高动态运动控制、多机集群协同、仿生情感交互、具身智能落地</strong>四大核心方向，展现了中国在人形机器人领域从跟跑到并跑、部分领域领跑的产业格局。</p>\n<p>相较于海外企业聚焦实验室参数、军事场景、长期测试的技术路线，中国企业更注重场景落地、成本控制、规模化量产，形成了差异化的竞争优势，推动人形机器人从实验室走向工业、商业、家庭等真实场景，2026年也被业内视为人形机器人规模化应用的元年。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-21 10:56</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【本台讯】C++界现“神秘代码”：一行指令唤醒沉睡的数学之美",
      "link": "https://www.cnblogs.com/lixingqiu/p/19627496",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lixingqiu/p/19627496\" id=\"cb_post_title_url\" title=\"发布于 2026-02-21 08:34\">\n    <span>【本台讯】C++界现“神秘代码”：一行指令唤醒沉睡的数学之美</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<img alt=\"2026-02-21_081653\" class=\"lazyload\" />\n<p><span><span>​</span></span></p>\n<p>注意：以下记者与报道纯属虚构，但C++精灵库和它的案例与抖音号里视频却是真实存在的。</p>\n<h2>（本台记者 2026年2月21日 报道）<br />\n有记者报道，一个神秘的“精灵库”近日“涌现”在抖音。传说作者用这个精灵库做了几百个作品，有些作品已录成视频进行展示，瞬间在程序员圈子和数学爱好者中引发了“地震”。</h2>\n<p><span>要看抖音</span>视频在这里：<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\"><a class=\"cke_widget_editable cke_widget_element\" href=\"https://v.douyin.com/IEr8F2q2oic/\" rel=\"noopener nofollow\" title=\"https://v.douyin.com/IEr8F2q2oic/\">https://v.douyin.com/IEr8F2q2oic/</a></span></p>\n<p>记者在一段时长仅10秒的视频中看到，无数条翠绿色与银白色的线条，如同被赋予了生命的丝带，在纯黑的虚空中交织、旋转、绽放。它们时而如DNA双螺旋般精密缠绕，时而如飞鸟振翅般舒展灵动。令人震惊的是，这并非出自专业的图形设计软件，也不是Python或JavaScript的杰作，而是由古老而严谨的C++语言，通过一个名为sprites.h的“精灵库”实时渲染而成。</p>\n<h2>“格子衫”程序员的逆袭：从枯燥代码到视觉艺术</h2>\n<p>“以前我们教C++，学生面对的是黑底白字的控制台，输出个'Hello World'都要半天。”一位不愿透露姓名的资深计算机教师在接受本台记者采访时感叹道，“但这个‘精灵库’的出现，彻底打破了C++‘枯燥、难学、只能做后端’的刻板印象。”<br />\n记者深入研究了流出的核心代码，发现其简洁程度令人咋舌。传统的C++图形编程往往需要配置复杂的OpenGL环境、处理晦涩的窗口消息循环，动辄数百行代码才能画出一个圆。而在“精灵库”的加持下，一切变得像搭积木一样简单：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include <span class=\"hljs-string\">\"sprites.h\"  <span class=\"hljs-comment\">// 仿佛一句咒语，打开了图形世界的大门\nScreen s;             <span class=\"hljs-comment\">// 屏幕对象，呼之即来\nSprite r;             <span class=\"hljs-comment\">// 画笔角色，听候差遣</span></span></span></span></span></span></code></pre>\n<span class=\"cke_reset cke_widget_drag_handler_container\"><img class=\"cke_reset cke_widget_drag_handler lazyload\" height=\"15\" title=\"点击并拖拽以移动\" width=\"15\" /></span></div>\n<p>仅仅三行代码，一个图形化界面就已准备就绪。这种“链式调用”的写法——如<code>s.bgcolor(\"black\").tracer(0)</code>——被业内专家称为“让C++说人话”的革命性设计。</p>\n<h2><strong>数学公式的“舞蹈编排”</strong></h2>\n<p>视频中那令人眼花缭乱的动态效果，背后其实是严谨数学公式的狂欢。代码中的<code>draw_curver</code>函数，实际上是在指挥两个不同频率的正弦波进行一场探戈舞。</p>\n<p><code>float x = A * sin(30*t + 3);</code> 与 <code>float y = k*A * sin(10*t);</code>，这两行代码分别控制了X轴和Y轴的波动。而在<code>rotate_point</code>函数中，正弦与余弦的精密计算，让每一个坐标点都在空间中完成了华丽的转身。</p>\n<p>“这不仅仅是编程，这是数学的可视化艺术。”一位数学系教授在观看视频后评价道，“作者通过<code>rotate_angle += 0.02</code>这样简单的累加，就让静态的公式‘活’了过来，变成了流动的视觉盛宴。”</p>\n<h2><strong>教育界的新宠：让创意飞一会儿</strong></h2>\n<p>据悉，这个“精灵库”最大的价值在于极大地降低了C++编程的门槛。它屏蔽了底层复杂的图形渲染机制，让使用者只需关注逻辑与创意。</p>\n<p>在代码的<code>main</code>函数中，一个简洁的<code>while(s.exitonclick())</code>循环，就构建起了一个完整的动画引擎。清屏、绘制、刷新、延时，一气呵成。这意味着，即使是编程初学者，也能在第一课就做出属于自己的动画作品，而不是对着控制台发呆。</p>\n<p>目前，关于这个“精灵库”的下载方式和完整文档仍在技术社区中疯传。有评论家预测，这可能会引发一场C++教学法的革新——从此，C++不再只是工程师手中的锤子，更是艺术家手中的画笔。</p>\n<p>截至发稿时，记者再次观看那段视频，那些绿色的线条依然在屏幕上不知疲倦地旋转着，仿佛在无声地诉说着：<strong>代码，原来可以如此性感。</strong></p>\n<p><strong>程序所有代码在此：</strong></p>\n<p><span><span>​</span></span></p>\n<div class=\"cnblogs_code\">\n<pre>#include <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">sprites.h</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">包含C++精灵库 </span>\nScreen s;      <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">建立屏幕对象叫s</span>\nSprite r;      <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">建立角色叫r\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 旋转函数，输入原始坐标和旋转角度，返回旋转后的坐标</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">void</span> rotate_point(<span style=\"color: rgba(0, 0, 255, 1);\">float</span>&amp; x, <span style=\"color: rgba(0, 0, 255, 1);\">float</span>&amp; y, <span style=\"color: rgba(0, 0, 255, 1);\">float</span><span style=\"color: rgba(0, 0, 0, 1);\"> angle) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> cos_a = cos(angle);  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 角度的余弦值</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">float</span> sin_a = sin(angle);  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 角度的正弦值\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保存原始坐标（避免计算时覆盖）</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">float</span> x_original =<span style=\"color: rgba(0, 0, 0, 1);\"> x;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> y_original =<span style=\"color: rgba(0, 0, 0, 1);\"> y;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 应用旋转变换公式</span>\n    x = x_original * cos_a - y_original *<span style=\"color: rgba(0, 0, 0, 1);\"> sin_a;\n    y </span>= x_original * sin_a + y_original *<span style=\"color: rgba(0, 0, 0, 1);\"> cos_a;\n}\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">void</span> draw_curver(<span style=\"color: rgba(0, 0, 255, 1);\">float</span> k, <span style=\"color: rgba(0, 0, 255, 1);\">float</span><span style=\"color: rgba(0, 0, 0, 1);\"> rotate_angle){    \n   </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span>(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> A=<span style=\"color: rgba(128, 0, 128, 1);\">0</span>;A&lt;=<span style=\"color: rgba(128, 0, 128, 1);\">100</span>;A+=<span style=\"color: rgba(128, 0, 128, 1);\">10</span><span style=\"color: rgba(0, 0, 0, 1);\">){       \n       </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> t=-<span style=\"color: rgba(128, 0, 128, 1);\">2.0</span><span style=\"color: rgba(0, 0, 0, 1);\">;      \n       </span><span style=\"color: rgba(0, 0, 255, 1);\">while</span>(t&lt;=<span style=\"color: rgba(128, 0, 128, 1);\">2.0</span><span style=\"color: rgba(0, 0, 0, 1);\">){\n          </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> x = A * sin(<span style=\"color: rgba(128, 0, 128, 1);\">30</span>*t + <span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n          </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> y = k*A * sin(<span style=\"color: rgba(128, 0, 128, 1);\">10</span>*<span style=\"color: rgba(0, 0, 0, 1);\">t);          \n          </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对每个点进行旋转变换</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">          rotate_point(x, y, rotate_angle);          \n          r.penshade(x</span>+y).go(y,x);    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">.dot(1);</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">if</span>(!<span style=\"color: rgba(0, 0, 0, 1);\">r.isdown())r.pendown();\n          t </span>= t + <span style=\"color: rgba(128, 0, 128, 1);\">0.01</span><span style=\"color: rgba(0, 0, 0, 1);\">;                  \n       }    \n       r.penup();  \n    }\n}\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> main(){        <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">主功能块 </span>\n   s.bgcolor(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">black</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).tracer(<span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n   r.speed(</span><span style=\"color: rgba(128, 0, 128, 1);\">0</span>).color(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">lime</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">).pu().hide();\n   </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> k=<span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n   </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> rotate_angle = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">旋转角度变量，初始为0</span>\n   <span style=\"color: rgba(0, 0, 255, 1);\">while</span>(s.exitonclick()){  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">单击窗口按钮返回家false，所以while循环结束</span>\n      s.clear();            <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">清除所有画的东西\n      </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 传入旋转角度，让本次绘制的所有点都旋转</span>\n      draw_curver(<span style=\"color: rgba(128, 0, 128, 1);\">3</span>*<span style=\"color: rgba(0, 0, 0, 1);\">sin(k), rotate_angle);\n      s.update().wait(</span><span style=\"color: rgba(128, 0, 128, 1);\">0.01</span>);   <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">刷新并等待0.01秒，固定帧率</span>\n      k = k + <span style=\"color: rgba(128, 0, 128, 1);\">0.01</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n      rotate_angle </span>+= <span style=\"color: rgba(128, 0, 128, 1);\">0.02</span>;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 控制旋转速度（值越大转得越快）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">   }    \n   </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span>;    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">返回0</span>\n}</pre>\n</div>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-02-21 08:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lixingqiu\">李兴球</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从挖矿木马入侵到 Docker Rootless 加固，我的服务器安全复盘",
      "link": "https://www.cnblogs.com/deali/p/19626849",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/deali/p/19626849\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 20:45\">\n    <span>从挖矿木马入侵到 Docker Rootless 加固，我的服务器安全复盘</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>最近我连续几台服务器被挂了挖矿木马，CPU、带宽、磁盘 IO 被拉满，服务器直接卡死无法连接。</p>\n<p>排查后发现，核心诱因是 Docker 权限过高 + 服务漏洞暴露，导致攻击者通过容器突破权限控制。</p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/cec878553480eb4f/1097027d157aa49e.jpg\" /></p>\n<blockquote>\n<p>PS：本来想写一篇文章介绍排查过程的，不过还是嫌麻烦没写，放在本文一起讲吧~</p>\n</blockquote>\n<p>重装系统后，我在部署 Docker 时注意到官方提示的 Rootless（无根）模式 —— 这一模式能从根本上降低容器逃逸风险，遂深入研究并落地配置，现将完整过程整理分享，希望能帮到同样关注 Docker 安全的开发者。</p>\n<h2 id=\"rootless-模式是什么\">Rootless 模式是什么</h2>\n<p>普通情况下，Docker 守护进程（dockerd）是用 <code>root</code> 权限运行的，哪怕你用普通用户执行 <code>docker run</code>，底层还是 root 权限，这有安全风险（比如容器逃逸可能拿到主机 root）。</p>\n<p>Rootless 模式让 Docker 守护进程以<strong>普通用户权限</strong>运行，哪怕容器出问题，也无法获取主机的 root 权限，安全性大幅提升。</p>\n<p>有好处自然有代价，rootless 的代价是配置复杂，且部分功能受限（比如无法端口映射 &lt; 1024）。</p>\n<p>不过没关系，这些也可以通过配置解决。先从安装开始吧。</p>\n<h2 id=\"安装docker\">安装docker</h2>\n<p>本来安装是很简单的，不过加个定语：在国内网络环境，那就非常复杂了。</p>\n<p>本文介绍最简单的安装方式：使用docker官方脚本+清华镜像。</p>\n<pre><code class=\"language-bash\">export DOWNLOAD_URL=\"https://mirrors.tuna.tsinghua.edu.cn/docker-ce\"\n# 如您使用 curl\ncurl -fsSL https://ghfast.top/https://raw.githubusercontent.com/docker/docker-install/master/install.sh | sh\n# 如您使用 wget\nwget -O- https://ghfast.top/https://raw.githubusercontent.com/docker/docker-install/master/install.sh | sh\n</code></pre>\n<p>注意 <code>raw.githubusercontent.com</code> 这个域名也是无法访问的，可以使用 ghproxy 来加速。</p>\n<h2 id=\"安装完成提示\">安装完成提示</h2>\n<p>安装完成会有一个提示，这也是开启 Rootless 模式的关键入口：</p>\n<pre><code class=\"language-bash\">================================================================================\n\nTo run Docker as a non-privileged user, consider setting up the\nDocker daemon in rootless mode for your user:\n\n    dockerd-rootless-setuptool.sh install\n\nVisit https://docs.docker.com/go/rootless/ to learn about rootless mode.\n\n\nTo run the Docker daemon as a fully privileged service, but granting non-root\nusers access, refer to https://docs.docker.com/go/daemon-access/\n\nWARNING: Access to the remote API on a privileged Docker daemon is equivalent\n         to root access on the host. Refer to the 'Docker daemon attack surface'\n         documentation for details: https://docs.docker.com/go/attack-surface/\n\n================================================================================\n</code></pre>\n<p>我就是在这里开始使用 rootless 模式的。</p>\n<p>提示核心解读：</p>\n<ol>\n<li>推荐通过<code>dockerd-rootless-setuptool.sh install</code>开启 Rootless 模式，让普通用户无 root 权限运行 Docker；</li>\n<li>若坚持 root 权限运行 Docker，可参考文档给普通用户授权（如加入 docker 组），但风险更高；</li>\n<li>重点警告：暴露 Docker 远程 API（如 2375 端口）= 直接开放主机 root 权限，这是服务器被入侵的高频诱因！</li>\n</ol>\n<h2 id=\"安装必要依赖\">安装必要依赖</h2>\n<p>我直接运行 <code>dockerd-rootless-setuptool.sh install</code> 的时候，提示要缺乏依赖</p>\n<pre><code class=\"language-bash\">$ dockerd-rootless-setuptool.sh install\n[ERROR] Missing system requirements. Run the following commands to\n[ERROR] install the requirements and run this tool again.\n\n########## BEGIN ##########\nsudo sh -eux &lt;&lt;EOF\n# Install newuidmap &amp; newgidmap binaries\napt-get install -y uidmap\nEOF\n########## END ##########\n</code></pre>\n<p>输入提示的这行命令：</p>\n<pre><code class=\"language-bash\">sudo sh -eux &lt;&lt;EOF\n# Install newuidmap &amp; newgidmap binaries\napt-get install -y uidmap\nEOF\n</code></pre>\n<p>安装完成后，再次执行 <code>dockerd-rootless-setuptool.sh install</code></p>\n<p>以后操作 docker 服务，要加上 <code>--user</code></p>\n<pre><code class=\"language-bash\">systemctl --user start docker.service\n</code></pre>\n<h2 id=\"配置\">配置</h2>\n<p>rootless 模式下：</p>\n<ul>\n<li>所有 Docker 命令都要在<strong>安装 Rootless 的普通用户</strong>下执行（不要用 root）；</li>\n<li>如果重启服务器后 Docker 没自动启动，执行：<code>systemctl --user enable --now docker</code>；</li>\n<li>数据备份要找 <code>~/.local/share/docker</code> 目录（而非 <code>/var/lib/docker</code>）。</li>\n</ul>\n<h3 id=\"镜像加速器\">镜像加速器</h3>\n<p>默认情况下，Rootless Docker 的配置文件存放在当前用户的 <strong>XDG 配置目录</strong> 下，路径是：<code>~/.config/docker/daemon.json</code></p>\n<pre><code class=\"language-bash\"># 先创建目录（如果不存在）\nmkdir -p ~/.config/docker\n\n# 编辑配置文件（用 nano 或 vim 都可以）\nnano ~/.config/docker/daemon.json\n</code></pre>\n<p>配置加速器</p>\n<pre><code class=\"language-json\">{\n  \"registry-mirrors\": [\"https://你的阿里云镜像加速地址.mirror.aliyuncs.com\"],\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"100m\",\n    \"max-file\": \"3\"\n  }\n}\n</code></pre>\n<p>注意：之前大部分稳定好用的加速器都停止服务了，现在就没法推荐啥，大家各凭本事吧。</p>\n<h3 id=\"解决-无法绑定-1-1023-端口-的问题\">解决 “无法绑定 1-1023 端口” 的问题</h3>\n<p>需要给当前用户 “绑定低端口” 的权限：</p>\n<pre><code class=\"language-bash\"># 给当前用户授权绑定 1-1023 端口（仅对当前会话生效）\nsudo sysctl net.ipv4.ip_unprivileged_port_start=0\n\n# 永久生效（重启后也有效）\necho \"net.ipv4.ip_unprivileged_port_start=0\" | sudo tee -a /etc/sysctl.conf\nsudo sysctl -p  # 立即生效\n</code></pre>\n<p>执行后，你就能正常映射 80、443 等端口了。</p>\n<h3 id=\"重启生效\">重启生效</h3>\n<p>Rootless 模式的 Docker 重启命令和系统级不同，执行：</p>\n<pre><code class=\"language-bash\"># 重启当前用户的 Docker 服务\nsystemctl --user restart docker\n\n# 验证配置是否生效\ndocker info\n# 能在 \"Registry Mirrors\" 部分看到你配置的镜像加速地址就是成功的\n</code></pre>\n<p>正常输出示例：</p>\n<pre><code class=\"language-plaintext\">Rootless: true\nRegistry Mirrors:\n https://你的阿里云镜像加速地址.mirror.aliyuncs.com/\n</code></pre>\n<h3 id=\"rootless-模式不支持的配置项\">Rootless 模式不支持的配置项</h3>\n<p>部分系统级配置在 Rootless 下无效（因为没有 root 权限），比如：</p>\n<ul>\n<li><code>iptables: false</code>（网络规则由 slirp4netns 管理，而非 iptables）；</li>\n<li><code>storage-driver: overlay2</code>（默认已启用，无需手动配置）；</li>\n<li>远程 API 相关配置（如 <code>hosts: [\"tcp://0.0.0.0:2375\"]</code>，Rootless 下不建议开启）。</li>\n<li>任何涉及系统级目录（如<code>/var/run/docker.sock</code>）的配置。</li>\n</ul>\n<h2 id=\"volume问题\">volume问题</h2>\n<p>切换到 rootless 之后，我还发现了 swag 的 config 无法读写了。</p>\n<p>swag 的 compose.yaml 配置是这样：</p>\n<pre><code class=\"language-yaml\">services:\n  swag:\n    image: linuxserver/swag\n    container_name: swag\n    cap_add:\n      - NET_ADMIN\n    environment:\n      - PUID=1000\n      - PGID=1000\n    volumes:\n      - ./config:/config\n</code></pre>\n<p><strong>rootless Docker 里，容器内的 UID=1000 ≠ 宿主机的 UID=1000</strong></p>\n<p>所以 <strong>SWAG 在容器里 chown 了 <code>/config</code>，宿主机看到的是一个“映射后的陌生 UID（100999）”</strong></p>\n<h3 id=\"解决方法\">解决方法</h3>\n<p>rootless 官方推荐使用命名卷，但我要经常修改 config 里的文件，这个肯定不现实。</p>\n<p>那么还有一个方法，使用 ACL 放行。</p>\n<p>先安装相关工具：</p>\n<pre><code class=\"language-bash\">sudo apt update\nsudo apt install -y acl\n</code></pre>\n<p>在 swag 目录下执行</p>\n<pre><code class=\"language-bash\">setfacl -m u:ecs-user:rwx config\nsetfacl -R -m u:ecs-user:rwx config\nsetfacl -d -m u:ecs-user:rwx config\n</code></pre>\n<p>验证：</p>\n<pre><code class=\"language-bash\">getfacl config | sed -n '1,20p'\n</code></pre>\n<p>看到类似：</p>\n<pre><code>user::rwx\nuser:ecs-user:rwx\ngroup::r-x\nmask::rwx\nother::r-x\n</code></pre>\n<h2 id=\"小结\">小结</h2>\n<p>Rootless 模式虽比普通 Docker 配置稍繁琐，但能从根本上降低容器逃逸风险，尤其适合对外提供服务的生产服务器。核心总结：</p>\n<ol>\n<li>安装：结合清华镜像源解决国内下载问题，优先用普通用户安装 Rootless 模式；</li>\n<li>权限：禁止暴露 Docker 远程 API，给普通用户授权低端口绑定权限即可满足日常使用；</li>\n<li>配置：牢记 Rootless 模式的配置文件、数据目录均在用户目录下，与系统级 Docker 区分开；</li>\n<li>安全：即便开启 Rootless，运行容器时仍需注意服务安全（如 Redis 加密码、安全组限制端口访问）。</li>\n</ol>\n<p>此次踩坑让我深刻意识到：服务器安全无小事，哪怕是 Docker 这样的基础工具，也需从权限层面做好最小化管控，才能避免被挖矿木马等恶意程序趁虚而入。</p>\n\n\n</div>\n<div id=\"MySignature\">\n    微信公众号：「程序设计实验室」\n专注于互联网热门新技术探索与团队敏捷开发实践，包括架构设计、机器学习与数据分析算法、移动端开发、Linux、Web前后端开发等，欢迎一起探讨技术，分享学习实践经验。\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 20:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/deali\">程序设计实验室</a>&nbsp;\n阅读(<span id=\"post_view_count\">63</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "模拟退火算法",
      "link": "https://www.cnblogs.com/PaperPlaneFly/p/19626799",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/PaperPlaneFly/p/19626799\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 20:14\">\n    <span>模拟退火算法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"模拟退火算法\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220201320618-591678279.png\" />\n        模拟退火算法最早的思想由**Metropolis **等（** **1953** **）提出，** **1983** **年** **Kirkpatrick** **等将其应用于组合优化。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"模拟退火算法\">模拟退火算法</h1>\n<p>​    <strong>模拟退火算法最早的思想由</strong>Metropolis <strong>等（</strong> <strong>1953</strong> <strong>）提出，</strong> <strong>1983</strong> <strong>年</strong> <strong>Kirkpatrick</strong> <strong>等将其应用于组合优化。</strong></p>\n<p><strong>算法的目的</strong>：</p>\n<p><strong>克服优化过程陷入局部极小；</strong></p>\n<p><strong>克服初值依赖性。</strong></p>\n<h2 id=\"物理退火过程\">物理退火过程</h2>\n<p>在物理学中，<strong>退火</strong>是将金属加热到极高温度，然后让其<strong>极其缓慢</strong>地冷却的过程。</p>\n<ul>\n<li><strong>高温状态</strong>：原子运动剧烈，处于无序状态（高能量）。</li>\n<li><strong>等温过程</strong>  <strong>对于与环境换热而温度不变的封闭系统，系统状态的自发变化总是朝自由能减少的方向进行，当自由能达到最小时，系统达到平衡态；</strong></li>\n<li><strong>缓慢冷却</strong>：原子逐渐找到最稳定的位置，形成整齐的晶体结构。</li>\n<li><strong>最终状态</strong>：系统的<strong>内能最低</strong>（全局最优）。</li>\n</ul>\n<p>如果冷却得太快（<strong>淬火</strong>，Quenching），原子来不及调整位置就被“冻结”在杂乱的状态，系统处于亚稳态（局部最优，内能较高，材料脆）。</p>\n<p>温度越低，物体的能量状态越低，到达足够的低点时，液体开始冷凝与结晶，在结晶状态时，系统的能量状态最低。缓慢降温（退火时，可达到最低能量状态；但如果快速降温（淬火，会导致不是最低能态的非晶形。</p>\n<h2 id=\"boltzmann概率分布\"><strong>Boltzmann</strong>概率分布</h2>\n<p>在温度T，分子停留在状态r满足Boltzmann概率分布</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200000416-839968077.png\" /></p>\n<p><img alt=\"科学网—科学史-物理学编年史-80玻尔兹曼分布律 - 张延年的博文\" src=\"https://ts3.tc.mm.bing.net/th/id/OIP-C.F28T_kCjs5-MqGcOpdgA9wHaE1?rs=1&amp;pid=ImgDetMain&amp;o=7&amp;rm=3\" /></p>\n<p>在同一个温度T，选定两个能量E1&lt;E2，有</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200026317-2005365913.png\" /></p>\n<p><strong>（</strong>1<strong>）在同一个温度，分子停留在能量小状态的概率大于停留在能量大状态的概率</strong></p>\n<p><strong>（</strong>2<strong>）温度越高，不同能量状态对应的概率相差越小；温度足够高时，各状态对应概率基本相同。</strong></p>\n<p><strong>（</strong>3<strong>）随着温度的下降，能量最低状态对应概率越来越大；温度趋于</strong>0<strong>时，其状态趋于</strong>1</p>\n<h2 id=\"metropolis准则\"><strong>Metropolis</strong>准则</h2>\n<p><strong>以概率接受新状态</strong></p>\n<p>假设当前状态为 x，能量为 E(x)。</p>\n<p>我们随机生成了一个邻域新解 x'，能量为 E(x')。</p>\n<p>定义能量差为：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200221455-1081080706.png\" /></p>\n<p>简单来说，它的核心数学思想是：<strong>以一定的概率接受一个“更差”的解，从而跳出局部最优陷阱，最终趋向全局最优。</strong></p>\n<h4 id=\"情况-a新解更好-δe0\">情况 A：新解更好 (Δ<em>E</em>&lt;0)</h4>\n<p>如果新解的能量更低（比如在下山），我们<strong>100% 接受</strong>这个新解。</p>\n<p><em>P</em>(accept)=1</p>\n<p>这对应了贪心算法（Gradient Descent）的部分。</p>\n<h4 id=\"情况-b新解更差-δe0\">情况 B：新解更差 (Δ<em>E</em>&gt;0)</h4>\n<p>如果新解的能量更高（比如要爬坡，反方向），我们<strong>不是直接拒绝</strong>，而是<strong>以一定的概率接受它</strong>。这个概率 <em>P</em> 服从 <strong>玻尔兹曼分布 (Boltzmann Distribution)</strong>：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200357347-1971444950.png\" /></p>\n<ul>\n<li>\n<p>Δ<em>E</em>：能量差（肯定为正）。</p>\n</li>\n<li>\n<p><em>T</em>：当前的温度。</p>\n</li>\n<li>\n<p><em>k</em>：物理中的玻尔兹曼常数（在算法中通常设为 1）。</p>\n</li>\n</ul>\n<h4 id=\"1-温度-t-极高时-探索阶段\">(1) 温度 T 极高时 (探索阶段)</h4>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200411620-1794628474.png\" /></p>\n<p>接受概率接近 100%。哪怕新解比旧解差很多，算法也会接受。</p>\n<p>算法在搜索空间中<strong>随机游走 (Random Walk)</strong>，像个醉汉。这保证了它能翻越极高的山峰，从深坑里跳出来，遍历整个空间。</p>\n<h4 id=\"2-温度-t-降低时-过渡阶段\">(2) 温度 T 降低时 (过渡阶段)</h4>\n<p>随着 T 变小，分母变小，指数部分变成较大的负数。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200433875-1909155565.png\" /></p>\n<p>如果Delta E 很大（解变差很多），概率 P<span class=\"math inline\">\\(就会很小；如果 \\Delta E\\)</span>很小（只差一点点），概率 P$还比较大。</p>\n<p>算法开始变得挑剔。它仍然允许跳出浅坑（局部最优），但不再接受那些太离谱的差解。</p>\n<h4 id=\"3-温度-t-极低时-收敛阶段\">(3) 温度 T 极低时 (收敛阶段)</h4>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200452308-1356373863.png\" /></p>\n<p>接受更差解的概率几乎为 0。</p>\n<p>算法退化为<strong>贪心算法 (Hill Climbing)</strong>。它只接受好解，不再爬坡。这时候它应该已经落入了全局最优</p>\n<h2 id=\"降温系数\">降温系数</h2>\n<p>在每一个固定的温度 T下，算法进行多次迭代。这实际上是在生成一个马尔可夫链。 如果迭代次数足够多，系统会达到服从玻尔兹曼分布<strong>热平衡分布 (Stationary Distribution)</strong>。</p>\n<p>当 T缓慢下降时，概率分布图会变得越来越尖（Peaked），大部分概率密度会集中在全局最小值的附近。</p>\n<p>引入冷却系数：</p>\n<p><strong>数学上的最优降温 (对数冷却)</strong>： Geman 在 1984 年证明，如果降温速度足够慢，满足：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200507935-837856176.png\" /></p>\n<p>那么模拟退火以<strong>概率 1 收敛到全局最优解</strong>。 <em>缺点</em>：这个速度太慢了，慢到实际上无法使用（可能需要几百年）。</p>\n<p><strong>工程上的降温 (指数冷却)</strong>：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200518474-1965198914.png\" /></p>\n<p>这是对收敛速度和求解质量的折衷。虽然理论上不保证 100% 找到全局最优，但在有限时间内能找到“足够好”的解。</p>\n<h2 id=\"rosenbrock-函数验证\">Rosenbrock 函数验证</h2>\n<p>N 维 Rosenbrock 函数的通常定义如下：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{x}) = \\sum_{i=1}^{N-1} [100 (x_{i+1} - x_i^2)^2 + (1 - x_i)^2]\n\\]</div><p></p><p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200541507-1548156741.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200605031-939946155.png\" /></p>\n<h2 id=\"c库代码如下\">c++库代码如下</h2>\n<p>sa.hpp</p>\n<pre><code>#ifndef SA_SA_HPP\n#define SA_SA_HPP\n\n\n#include \"params.hpp\"\n#include \"policies.hpp\"\n#include \"detail/solver.hpp\"\n\nnamespace sa {\n\n\n    /**\n     * @brief 模拟退火通用求解函数\n     * * @tparam State 状态类型 (自动推导)\n     * @tparam EnergyFunc 能量函数类型 (自动推导)\n     * @tparam NeighborFunc 邻域函数类型 (可选)\n     * @tparam CoolingPolicy 降温策略 (可选)\n     * @tparam ConstraintPolicy 约束策略 (可选)\n     * * @param initial_state 初始状态值\n     * @param energy_func 能量函数句柄\n     * @param params 算法参数配置\n     * @param neighbor 邻域生成器实例\n     * @param cooling 降温器实例\n     * @param constraint 约束器实例\n     * @return std::pair&lt;State, double&gt; {最优状态, 最优能量值}\n     */\n    template&lt;\n            typename State,\n            typename EnergyFunc,\n            typename NeighborFunc = DefaultNeighbor&lt;State&gt;,\n            typename CoolingPolicy = ExponentialCooling,\n            typename ConstraintPolicy = std::nullptr_t\n    &gt;\n    auto solve(\n            const State&amp; initial_state,\n            EnergyFunc energy_func,\n            Params params = Params{},\n            NeighborFunc neighbor = NeighborFunc{},\n            CoolingPolicy cooling = CoolingPolicy{},\n            ConstraintPolicy constraint = ConstraintPolicy{}\n    ) {\n        using AcceptancePolicy = MetropolisAcceptance;\n\n        detail::Solver&lt;State, EnergyFunc, NeighborFunc, CoolingPolicy, AcceptancePolicy, ConstraintPolicy&gt;\n                solver(params, energy_func, neighbor, cooling, AcceptancePolicy{}, constraint);\n\n        return solver.solve(initial_state);\n    }\n\n} // namespace sa\n\n#endif // SA_SA_HPP\n</code></pre>\n<p>policies.hpp</p>\n<pre><code>#ifndef SA_POLICIES_HPP\n#define SA_POLICIES_HPP\n\n#include \"params.hpp\"\n#include \"detail/traits.hpp\"\n\n#include &lt;cmath&gt;\n#include &lt;random&gt;\n#include &lt;algorithm&gt;\n#include &lt;stdexcept&gt;\n#include &lt;vector&gt;\n\nnamespace sa {\n\n    // 默认降温策略\n    struct ExponentialCooling {\n        inline double operator()(double T, const Params&amp; p) const noexcept {\n            return T * p.alpha;\n        }\n    };\n\n\n    // 默认接受策略 (Metropolis 准则)\n    struct MetropolisAcceptance {\n        template&lt;typename RNG&gt;\n        bool operator()(double delta_E,\n                        double T,\n                        RNG&amp; rng,\n                        std::uniform_real_distribution&lt;double&gt;&amp; dist) const\n        {\n            if (delta_E &lt; 0.0) return true;\n            return std::exp(-delta_E / T) &gt; dist(rng);\n        }\n    };\n\n\n    // 默认连续邻域生成策略\n    template&lt;typename State&gt;\n    struct DefaultNeighbor {\n        double sigma = 1.0;\n\n        State operator()(const State&amp; current,\n                         double T,\n                         std::mt19937&amp; rng) const\n        {\n            if constexpr (std::is_arithmetic_v&lt;State&gt;) {\n                std::normal_distribution&lt;double&gt; dist(0.0, sigma * T);\n                return static_cast&lt;State&gt;(current + dist(rng));\n            }\n            else if constexpr (detail::is_std_vector_v&lt;State&gt;) {\n                using ValueType = typename State::value_type;\n                static_assert(std::is_arithmetic_v&lt;ValueType&gt;,\n                              \"vector value type must be arithmetic\");\n\n                std::normal_distribution&lt;double&gt; dist(0.0, sigma * T);\n                State candidate = current;\n                for (auto&amp; v : candidate)\n                    v = static_cast&lt;ValueType&gt;(v + dist(rng));\n                return candidate;\n            }\n            else {\n                static_assert(sizeof(State) == 0, \"No default neighbor for this State type\");\n                return current;\n            }\n        }\n    };\n\n\n    // 离散翻转邻域策略 (针对 vector&lt;bool&gt; 或 vector&lt;int&gt;)\n    template&lt;typename State&gt;\n    struct DiscreteFlipNeighbor {\n        State operator()(const State&amp; current,\n                         double T,\n                         std::mt19937&amp; rng) const\n        {\n            static_assert(detail::is_std_vector_v&lt;State&gt;, \"DiscreteFlipNeighbor requires std::vector\");\n            using ValueType = typename State::value_type;\n\n            static_assert(\n                    std::is_same_v&lt;ValueType, int&gt; || std::is_same_v&lt;ValueType, bool&gt;,\n                    \"DiscreteFlipNeighbor requires vector&lt;int&gt; or vector&lt;bool&gt;\"\n            );\n\n            State candidate = current;\n            std::uniform_int_distribution&lt;std::size_t&gt; dist(0, candidate.size() - 1);\n            std::size_t idx = dist(rng);\n\n            if constexpr (std::is_same_v&lt;ValueType, bool&gt;)\n                candidate[idx] = !candidate[idx];\n            else\n                candidate[idx] = 1 - candidate[idx];\n\n            return candidate;\n        }\n    };\n\n\n    // 边界约束策略 (Box Constraint)\n    template&lt;typename State&gt;\n    class BoxConstraintPolicy {\n    public:\n        using ValueType = std::conditional_t&lt;\n                std::is_arithmetic_v&lt;State&gt;,\n                State,\n                typename State::value_type&gt;;\n\n        BoxConstraintPolicy(ValueType lower, ValueType upper)\n                : lower_(lower), upper_(upper) {}\n\n        void apply(State&amp; state) const noexcept {\n            if constexpr (std::is_arithmetic_v&lt;State&gt;) {\n                state = std::clamp(state, lower_, upper_);\n            }\n            else {\n                for (auto&amp; v : state)\n                    v = std::clamp(v, lower_, upper_);\n            }\n        }\n\n    private:\n        ValueType lower_;\n        ValueType upper_;\n    };\n\n} // namespace sa\n\n#endif // SA_POLICIES_HPP\n</code></pre>\n<p>params.hpp</p>\n<pre><code>//\n// Created by 31007 on 2026/2/12.\n//\n\n#ifndef MATH_TYPES_HPP\n#define MATH_TYPES_HPP\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\nnamespace sa {\n    struct Params {\n        double      initial_temp     = 100.0;       // 初始温度\n        double      final_temp       = 1e-6;        // 终止温度\n        double      alpha            = 0.98;        // 降温系数\n        std::size_t iter_per_temp    = 100;         // 每个温度下的迭代次数\n        std::size_t max_total_iters  = 1'000'000;   // 最大总迭代次数 (防止死循环)\n        std::uint32_t seed           = 0;           // 随机种子 (0表示随机)\n    };\n\n} // namespace sa\n#endif //MATH_TYPES_HPP\n</code></pre>\n<p>solver.hpp</p>\n<pre><code>#ifndef SA_DETAIL_SOLVER_HPP\n#define SA_DETAIL_SOLVER_HPP\n\n#include \"../params.hpp\"\n#include &lt;random&gt;\n#include &lt;utility&gt;\n#include &lt;stdexcept&gt;\n\nnamespace sa::detail {\n\n    template&lt;\n            typename State,\n            typename EnergyFunc,\n            typename NeighborFunc,\n            typename CoolingPolicy,\n            typename AcceptancePolicy,\n            typename ConstraintPolicy\n    &gt;\n    class Solver {\n    public:\n        Solver(Params params,\n               EnergyFunc energy,\n               NeighborFunc neighbor,\n               CoolingPolicy cooling,\n               AcceptancePolicy acceptance,\n               ConstraintPolicy constraint)\n                : params_(params),\n                  energy_(energy),\n                  neighbor_(neighbor),\n                  cooling_(cooling),\n                  acceptance_(acceptance),\n                  constraint_(constraint),\n                  dist_(0.0, 1.0)\n        {\n            validate_params();\n\n            if (params_.seed == 0) {\n                std::random_device rd;\n                rng_ = std::mt19937(rd());\n            } else {\n                rng_ = std::mt19937(params_.seed);\n            }\n        }\n\n        std::pair&lt;State, double&gt; solve(const State&amp; initial_state) {\n            State current = initial_state;\n            double current_energy = energy_(current);\n\n            State best = current;\n            double best_energy = current_energy;\n\n            double T = params_.initial_temp;\n            std::size_t total_iters = 0;\n\n            while (T &gt; params_.final_temp &amp;&amp; total_iters &lt; params_.max_total_iters) {\n                for (std::size_t i = 0;\n                     i &lt; params_.iter_per_temp &amp;&amp; total_iters &lt; params_.max_total_iters;\n                     ++i, ++total_iters)\n                {\n                    State candidate = neighbor_(current, T, rng_);\n\n                    // 编译期判断是否存在约束策略\n                    if constexpr (!std::is_same_v&lt;ConstraintPolicy, std::nullptr_t&gt;) {\n                        constraint_.apply(candidate);\n                    }\n\n                    double candidate_energy = energy_(candidate);\n                    double delta = candidate_energy - current_energy;\n\n                    if (acceptance_(delta, T, rng_, dist_)) {\n                        current = std::move(candidate);\n                        current_energy = candidate_energy;\n\n                        if (current_energy &lt; best_energy) {\n                            best = current;\n                            best_energy = current_energy;\n                        }\n                    }\n                }\n                T = cooling_(T, params_);\n            }\n\n            return {std::move(best), best_energy};\n        }\n\n    private:\n        void validate_params() {\n            if (params_.initial_temp &lt;= 0.0) throw std::invalid_argument(\"initial_temp must be &gt; 0\");\n            if (params_.final_temp &lt;= 0.0) throw std::invalid_argument(\"final_temp must be &gt; 0\");\n            if (params_.alpha &lt;= 0.0 || params_.alpha &gt;= 1.0) throw std::invalid_argument(\"alpha must be in (0,1)\");\n            if (params_.iter_per_temp == 0) throw std::invalid_argument(\"iter_per_temp must be &gt; 0\");\n        }\n\n        Params params_;\n        EnergyFunc energy_;\n        NeighborFunc neighbor_;\n        CoolingPolicy cooling_;\n        AcceptancePolicy acceptance_;\n        ConstraintPolicy constraint_;\n\n        std::mt19937 rng_;\n        std::uniform_real_distribution&lt;double&gt; dist_;\n    };\n\n} // namespace sa::detail\n\n#endif // SA_DETAIL_SOLVER_HPP\n</code></pre>\n<p>traits.hpp</p>\n<pre><code>#ifndef SA_DETAIL_TRAITS_HPP\n#define SA_DETAIL_TRAITS_HPP\n\n#include &lt;vector&gt;\n#include &lt;type_traits&gt;\n\nnamespace sa::detail {\n\n    // 类型萃取：判断是否为 std::vector\n\n    template&lt;typename T&gt;\n    struct is_std_vector : std::false_type {};\n\n    template&lt;typename T, typename Alloc&gt;\n    struct is_std_vector&lt;std::vector&lt;T, Alloc&gt;&gt; : std::true_type {};\n\n    template&lt;typename T&gt;\n    inline constexpr bool is_std_vector_v = is_std_vector&lt;T&gt;::value;\n\n} // namespace sa::detail\n\n#endif // SA_DETAIL_TRAITS_HPP\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 20:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/PaperPlaneFly\">纸飞机低空飞行</a>&nbsp;\n阅读(<span id=\"post_view_count\">56</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "手把手教你使用vscode开发stm32！",
      "link": "https://www.cnblogs.com/chenyouyuan/p/19626759",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chenyouyuan/p/19626759\" id=\"cb_post_title_url\" title=\"å‘å¸ƒäºŽ 2026-02-20 19:31\">\n    <span>æ‰‹æŠŠæ‰‹æ•™ä½ ä½¿ç”¨vscodeå¼€å‘stm32ï¼</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        å·²ç»2026å¹´äº†ï¼Œä½ æ˜¯å¦è¿˜åœ¨ä½¿ç”¨å¤è€çš„keil5çš„è°ƒè¯•å‘¢ï¼Ÿæ˜¯å¦è¿˜åœ¨ä¸ºkeil5å¤åˆ¶ç²˜è´´ä»£ç åˆ°èŠå¤©å¼aiå†ç²˜è´´å›žæ¥è€Œçƒ¦æ¼å‘¢ï¼Ÿå¿«å¿«åŠ å…¥vscodeå¼€å‘stm32çš„å¤§éƒ¨é˜ŸæŽ¥å—å…‰è£çš„è¿›åŒ–å§ï¼\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"å¼€å‘å·¥å…·é…ç½®ç¯‡è¿ŽæŽ¥æ–°æ—¶ä»£--ä½¿ç”¨vscodeå¼€å‘stm32\">å¼€å‘å·¥å…·é…ç½®ç¯‡ï¼šè¿ŽæŽ¥æ–°æ—¶ä»£--ä½¿ç”¨vscodeå¼€å‘stm32</h1>\n<blockquote>\n<p>å·²ç»2026å¹´äº†ï¼Œä½ æ˜¯å¦è¿˜åœ¨ä½¿ç”¨å¤è€çš„keil5çš„è°ƒè¯•å‘¢ï¼Ÿæ˜¯å¦è¿˜åœ¨ä¸ºkeil5å¤åˆ¶ç²˜è´´ä»£ç åˆ°èŠå¤©å¼aiå†ç²˜è´´å›žæ¥è€Œçƒ¦æ¼å‘¢ï¼Ÿå¿«å¿«åŠ å…¥vscodeå¼€å‘stm32çš„å¤§éƒ¨é˜ŸæŽ¥å—å…‰è£çš„è¿›åŒ–å§ï¼</p>\n</blockquote>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">ç›®å½•</div><ul><li><a href=\"#å¼€å‘å·¥å…·é…ç½®ç¯‡è¿ŽæŽ¥æ–°æ—¶ä»£--ä½¿ç”¨vscodeå¼€å‘stm32\" rel=\"noopener nofollow\">å¼€å‘å·¥å…·é…ç½®ç¯‡ï¼šè¿ŽæŽ¥æ–°æ—¶ä»£--ä½¿ç”¨vscodeå¼€å‘stm32</a><ul><li><a href=\"#å‰è¨€\" rel=\"noopener nofollow\">å‰è¨€</a></li><li><a href=\"#æ‰€æœ‰ä¾èµ–çš„è½¯ä»¶ç™¾åº¦ç½‘ç›˜é“¾æŽ¥ä»¥åŠé…å¥—bç«™æ‰‹æŠŠæ‰‹è®²è§£è§†é¢‘\" rel=\"noopener nofollow\">æ‰€æœ‰ä¾èµ–çš„è½¯ä»¶ç™¾åº¦ç½‘ç›˜é“¾æŽ¥ä»¥åŠé…å¥—bç«™æ‰‹æŠŠæ‰‹è®²è§£è§†é¢‘</a></li><li><a href=\"#ä¸€ä¸‹è½½cubemxä»¥åŠå¯¹åº”stm32çš„halåº“\" rel=\"noopener nofollow\">ä¸€ã€ä¸‹è½½cubemxä»¥åŠå¯¹åº”stm32çš„halåº“</a></li><li><a href=\"#äºŒä¸‹è½½vscodeä»¥åŠæ’ä»¶\" rel=\"noopener nofollow\">äºŒã€ä¸‹è½½vscodeä»¥åŠæ’ä»¶</a><ul><li><a href=\"#stm32-for-vscode\" rel=\"noopener nofollow\">stm32 for vscode</a></li><li><a href=\"#makefiel\" rel=\"noopener nofollow\">makefiel</a></li></ul></li><li><a href=\"#ä¸‰stlinké©±åŠ¨å®‰è£\" rel=\"noopener nofollow\">ä¸‰ã€stlinké©±åŠ¨å®‰è£…</a></li><li><a href=\"#å››-é…ç½®å¼€å‘çŽ¯å¢ƒ\" rel=\"noopener nofollow\">å››ã€ é…ç½®å¼€å‘çŽ¯å¢ƒ</a><ul><li><a href=\"#é…ç½®çŽ¯å¢ƒå˜é‡\" rel=\"noopener nofollow\">é…ç½®çŽ¯å¢ƒå˜é‡</a></li><li><a href=\"#å…³äºŽlaunchjsonæ–‡ä»¶\" rel=\"noopener nofollow\">å…³äºŽlaunch.jsonæ–‡ä»¶</a></li><li><a href=\"#å…³äºŽtasksjsonæ–‡ä»¶\" rel=\"noopener nofollow\">å…³äºŽtasks.jsonæ–‡ä»¶</a></li></ul></li><li><a href=\"#å¼€å§‹è°ƒè¯•\" rel=\"noopener nofollow\">å¼€å§‹è°ƒè¯•</a><ul><li><a href=\"#stm32-svdæ–‡ä»¶\" rel=\"noopener nofollow\">stm32 svdæ–‡ä»¶</a></li></ul></li></ul></li></ul></div><p></p>\n<p>æœ¬ç¯‡æ–‡ç« ä¸»è¦å‚è€ƒæ¹–å—å¤§å­¦robomasterè·ƒé¹¿æˆ˜é˜Ÿçš„ç”µæŽ§å¼€æºéƒ¨åˆ†</p>\n<p><a href=\"https://gitee.com/hnuyuelurm/basic_framework/blob/master/.Doc/VSCode+Ozone%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md\" rel=\"noopener nofollow\" target=\"_blank\">.Doc/VSCode+Ozoneä½¿ç”¨æ–¹æ³•.md Â· HNUYueLuRM/basic_framework - Gitee.com</a></p>\n<h2 id=\"å‰è¨€\">å‰è¨€</h2>\n<p>æœ¬ç¯‡æ–‡ç« ä¸»è¦ä½¿ç”¨vscode + cubemxå¹³æ›¿keil5ï¼Œå®žçŽ°å¿«é€Ÿå¼€å‘ã€å®žæ—¶å¯è§†åŒ–å˜é‡ï¼ˆå…¨å±€ï¼‰ã€å¯ä»¥æŸ¥çœ‹å¯„å­˜å™¨å†…å®¹ã€copilotè¾…åŠ©å¼€å‘....</p>\n<p>æ”¯æŒstlinkï¼Œjlinkï¼Œdaplinkè°ƒè¯•å™¨ï¼Œæš‚æ—¶æ²¡æœ‰æ‰¾åˆ°çº¯é vscodeçš„å®žæ—¶å¯è§†åŒ–å‚æ•°æ³¢å½¢å›¾åŠŸèƒ½çš„æ’ä»¶</p>\n<p>å¦‚æžœå¤§å®¶è¿˜æœ‰å…¶ä»–å¥½ç”¨çš„æ–¹æ¡ˆæ¬¢è¿Žè®¨è®ºå™¢~</p>\n<h2 id=\"æ‰€æœ‰ä¾èµ–çš„è½¯ä»¶ç™¾åº¦ç½‘ç›˜é“¾æŽ¥ä»¥åŠé…å¥—bç«™æ‰‹æŠŠæ‰‹è®²è§£è§†é¢‘\">æ‰€æœ‰ä¾èµ–çš„è½¯ä»¶ç™¾åº¦ç½‘ç›˜é“¾æŽ¥ä»¥åŠé…å¥—bç«™æ‰‹æŠŠæ‰‹è®²è§£è§†é¢‘</h2>\n<p>å¯èƒ½ç½‘ç»œåŽŸå› å¯¼è‡´ä¸€äº›å®‰è£…æ— æ³•å®Œæˆï¼Œæ‰€ä»¥è¿™è¾¹æä¾›æ‰€ç”¨åˆ°çš„æ‰€æœ‰åŒ…ï¼Œæ ¹æ®éœ€è¦å®‰è£…å³å¯<br />\né€šè¿‡ç½‘ç›˜åˆ†äº«çš„æ–‡ä»¶ï¼šall_in_one.zip<br />\né“¾æŽ¥: <a href=\"https://pan.baidu.com/s/12brC2bPmu9wWa2h-VgIZmg?pwd=9xah\" rel=\"noopener nofollow\" target=\"_blank\">https://pan.baidu.com/s/12brC2bPmu9wWa2h-VgIZmg?pwd=9xah</a> æå–ç : 9xah<br />\n--æ¥è‡ªç™¾åº¦ç½‘ç›˜è¶…çº§ä¼šå‘˜v3çš„åˆ†äº«<br />\nbç«™è§†é¢‘é“¾æŽ¥<br />\n<a href=\"https://www.bilibili.com/video/BV1ZMfGBrEFy/?vd_source=f553a12b04c16a678ddc0064cc04563c\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV1ZMfGBrEFy/?vd_source=f553a12b04c16a678ddc0064cc04563c</a></p>\n<h2 id=\"ä¸€ä¸‹è½½cubemxä»¥åŠå¯¹åº”stm32çš„halåº“\">ä¸€ã€ä¸‹è½½cubemxä»¥åŠå¯¹åº”stm32çš„halåº“</h2>\n<p>cubemxå®˜ç½‘(éœ€è¦ç®€å•çš„æ³¨å†Œå³å¯)ï¼š</p>\n<p><a href=\"https://www.st.com/en/development-tools/stm32cubemx.html#get-software\" rel=\"noopener nofollow\" target=\"_blank\">https://www.st.com/en/development-tools/stm32cubemx.html#get-software</a></p>\n<p>ä¸‹è½½å®Œæˆä¹‹åŽç‚¹å‡»</p>\n<p><img alt=\"\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220181610339.png\" /></p>\n<p>ç›´æŽ¥åœ¨æœç´¢æ æœç´¢ä½ ä½¿ç”¨çš„stm32çš„åž‹å·ï¼Œä»¥f103ä½œä¸ºä¾‹å­</p>\n<p><img alt=\"image-20260220181746320\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220181746320.png\" /></p>\n<p>åŒå‡»è¦é€‰æ‹©çš„æ¿å­å³å¯è¿›å…¥</p>\n<p>å…¶ä½™è¯¦ç»†çš„é…ç½®å¯ä»¥å‚è€ƒå…¶ä»–æ•™ç¨‹</p>\n<p>ä¸»è¦æ³¨æ„çš„æ˜¯ï¼š</p>\n<p>sysçš„é…ç½®è¦é…ç½®æˆswæ¨¡å¼ï¼Œä¸ç„¶ä¼šåªèƒ½çƒ§å½•ä¸€æ¬¡</p>\n<p><img alt=\"image-20260220181938762\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220181938762.png\" /></p>\n<p>å¯¼å‡ºè¿™è¾¹é€‰æ‹©makefile</p>\n<p><img alt=\"image-20260220182046638\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220182046638.png\" /></p>\n<h2 id=\"äºŒä¸‹è½½vscodeä»¥åŠæ’ä»¶\">äºŒã€ä¸‹è½½vscodeä»¥åŠæ’ä»¶</h2>\n<p>vscodeå®˜ç½‘ï¼š</p>\n<p><a href=\"https://www.st.com/en/development-tools/stm32cubemx.html#get-software\" rel=\"noopener nofollow\" target=\"_blank\">https://www.st.com/en/development-tools/stm32cubemx.html#get-software</a></p>\n<p>éœ€è¦å®‰è£…çš„vscdoeæ’ä»¶ï¼š</p>\n<p>ç‚¹å‡»vscodeå·¦ä¾§çš„è¿™ä¸ªå›¾æ ‡</p>\n<p><img alt=\"image-20260220174816604\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174816604.png\" /></p>\n<h3 id=\"stm32-for-vscode\">stm32 for vscode</h3>\n<p><img alt=\"image-20260220160002646\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220160002646.png\" /></p>\n<p><img alt=\"image-20260220155925565\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220155925565.png\" /></p>\n<p>ç‚¹å‡»install build tools</p>\n<p><img alt=\"image-20260220175156853\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175156853.png\" /></p>\n<p>å‡ºçŽ°å¦‚ä¸Šé¡µé¢å³ä»£è¡¨å®‰è£…æˆåŠŸï¼ˆå¤§çº¦5~15åˆ†é’Ÿï¼‰</p>\n<p>å¦‚æžœç½‘ç»œä¸å¥½å£è¯­åˆ‡æ¢æ‰‹æœºçƒ­ç‚¹å†æ¬¡å°è¯•</p>\n<p>è¿˜ä¸è¡Œå°±ç›´æŽ¥ä½¿ç”¨æˆ‘çš„ç™¾åº¦ç½‘ç›˜åˆ†äº«çš„zipåŽ‹ç¼©åŒ…ï¼Œå»ºè®®æ”¾åˆ°dç›˜ï¼ˆå¦‚æžœæœ‰çš„è¯ï¼‰</p>\n<h3 id=\"makefiel\">makefiel</h3>\n<p><img alt=\"image-20260220155854381\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220155854381.png\" /></p>\n<h2 id=\"ä¸‰stlinké©±åŠ¨å®‰è£…\">ä¸‰ã€stlinké©±åŠ¨å®‰è£…</h2>\n<p>å¦‚æžœä½ ä¹‹å‰æ²¡æœ‰ä½¿ç”¨è¿‡stlinkï¼Œè¯·æ ¹æ®å¦‚ä¸‹é“¾æŽ¥å®Œæˆstlinké©±åŠ¨çš„å®‰è£…</p>\n<p><a href=\"https://www.st.com.cn/zh/development-tools/stsw-link009.html\" rel=\"noopener nofollow\" target=\"_blank\">STSW-LINK009 | Software - æ„æ³•åŠå¯¼ä½“</a><br />\næ ¹æ®è‡ªå·±çš„ç”µè„‘é…ç½®åŒå‡»ä»¥ä¸‹ä¸¤ä¸ªexeä¸­çš„ä¸€ä¸ª</p>\n<p><img alt=\"image-20260220184946316\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184946316.png\" /></p>\n<h2 id=\"å››-é…ç½®å¼€å‘çŽ¯å¢ƒ\">å››ã€ é…ç½®å¼€å‘çŽ¯å¢ƒ</h2>\n<h3 id=\"é…ç½®çŽ¯å¢ƒå˜é‡\">é…ç½®çŽ¯å¢ƒå˜é‡</h3>\n<ol>\n<li>\n<p>åœ¨vscodeæ‰¾åˆ°æœ€å·¦è¾¹çš„å››ä¸ªæ–¹å—å›¾æ ‡ï¼Œè¿™é‡Œæ˜¯æˆ‘ä»¬å®‰è£…æ‹“å±•çš„åœ°æ–¹</p>\n<p>ç‚¹å‡»ä¹‹åŽæ‰¾åˆ°stm32 for vscode</p>\n<p><img alt=\"image-20260220174706404\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174706404.png\" /></p>\n</li>\n<li>\n<p>æ‰“å¼€è¯¦æƒ…é¡µé¢--&gt;ç‚¹å‡»å³ä¸‹è§’è“è‰²çš„ç¼“å­˜æ–‡å­—ï¼Œæ‰“å¼€ç¼“å­˜æ–‡ä»¶å¤¹</p>\n<p><img alt=\"image-20260220175025884\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175025884.png\" /></p>\n<p>ç¼“å­˜æ–‡ä»¶å¤¹å¦‚ä¸‹</p>\n<p><img alt=\"image-20260220175310991\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175310991.png\" /></p>\n</li>\n<li>\n<p>è¿›å…¥@å¼€å¤´çš„æ–‡ä»¶å¤¹,å¦‚ä¸‹ï¼Œæˆ‘ä»¬ä¸ºäº†æ–¹ä¾¿ï¼ŒæŠŠè¯¥æ–‡ä»¶å¤¹ä¸‹é¢æ‰€æœ‰çš„ä¸œè¥¿è¿ç§»åˆ°Dç›˜ï¼ˆå¦‚æžœæœ‰çš„è¯ï¼‰ï¼Œåœ¨Dç›˜ç›®å½•ä¸‹æ–°å»ºä¸€ä¸ªæ–‡ä»¶å¤¹å«stm32toolsï¼ŒæŠŠæ–‡ä»¶å…¨éƒ¨æ”¾è¿›åŽ»</p>\n<p><img alt=\"image-20260220175354956\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175354956.png\" /></p>\n<p>è¿ç§»è·¯å¾„å¦‚ä¸‹å›¾ï¼ˆå› ä¸ºè¿™ä¸ªæ¼”ç¤ºçš„æœºå™¨æ²¡æœ‰åˆ†dç›˜ï¼Œæˆ‘å°±æ”¾åˆ°cç›˜äº†ï¼‰</p>\n<p><img alt=\"image-20260220175533984\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175533984.png\" /></p>\n</li>\n<li>\n<p>æŽ¥ä¸‹æ¥æŒ‰ä¸‹winé”®ï¼Œåœ¨æœç´¢æ æœç´¢çŽ¯å¢ƒ</p>\n<p>ç‚¹å‡»ç¼–è¾‘ç³»ç»ŸçŽ¯å¢ƒå˜é‡</p>\n<p><img alt=\"\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174138545.png\" /></p>\n<p>ç‚¹å‡»æœ€ä¸‹é¢çš„çŽ¯å¢ƒå˜é‡ï¼ˆNï¼‰</p>\n<p><img alt=\"image-20260220174230783\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174230783.png\" /></p>\n<p>åŒå‡»path</p>\n<p><img alt=\"image-20260220174323481\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174323481.png\" /></p>\n<p>ç‚¹å‡»å³è¾¹çš„æ–°å»ºå³å¯æ–°å»ºå˜é‡ï¼Œctrl+vç²˜è´´ä¸‰ä¸ªbinçš„è·¯å¾„ï¼ˆå¦‚ä¸‹å›¾ï¼Œæ ¹æ®è‡ªå·±çš„æ–‡ä»¶ä½ç½®æ¥</p>\n<p><img alt=\"image-20260220174405199\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174405199.png\" /></p>\n</li>\n</ol>\n<p>é…ç½®å®Œæˆä¹‹åŽwin + r</p>\n<p>åœ¨å¼¹å‡ºçš„çª—å£è¾“å…¥cmdï¼Œå›žè½¦</p>\n<p>ç²˜è´´å¦‚ä¸‹æŒ‡ä»¤è¿è¡Œ</p>\n<pre><code class=\"language-cmd\">arm-none-eabi-gcc -v\n</code></pre>\n<p>å¦‚æžœå‡ºçŽ°ç±»ä¼¼ä¸‹å›¾è¾“å‡ºï¼Œå°±ä»£è¡¨æˆåŠŸ</p>\n<p><img alt=\"image-20260220180204385\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220180204385.png\" /></p>\n<ol start=\"5\">\n<li>\n<p>æ‰“å¼€vscode è¿›å…¥åˆ°é¡¹ç›®æ–‡ä»¶å¤¹ï¼ˆå‰é¢åˆ›å»ºçš„cubemxé¡¹ç›®æ–‡ä»¶å¤¹ï¼‰</p>\n</li>\n<li>\n<p>ctrl + ï¼Œæ‰“å¼€è®¾ç½®ï¼Œæœç´¢stm32 for vscode<br />\n<img alt=\"image-20260220184204803\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184204803.png\" /><br />\nç‚¹å‡»åœ¨settings.jsonä¸­ç¼–è¾‘,å®Œå–„å¦‚ä¸‹è·¯å¾„</p>\n<p><img alt=\"image-20260220184315477\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184315477.png\" /><br />\nsettings.json(æ ¹æ®è‡ªå·±çš„è·¯å¾„é…ç½®)</p>\n<pre><code class=\"language-json\">{\n    \"stm32-for-vscode.openOCDPath\": \"C:\\\\stm32tools\\\\openocd\\\\0.12.0-7.1\\\\.content\\\\bin\\\\openocd.EXE\",\n    \"stm32-for-vscode.makePath\": \"C:\\\\stm32tools\\\\windows-build-tools\\\\4.4.1-3.1\\\\.content\\\\bin\\\\make.EXE\",\n    \"stm32-for-vscode.armToolchainPath\": \"C:\\\\stm32tools\\\\arm-none-eabi-gcc\\\\14.2.1-1.1.1\\\\.content\\\\bin\",\n    \"makefile.configureOnOpen\": true,\n    \"cortex-debug.stm32cubeprogrammer\": \"\",\n    \"cortex-debug.openocdPath\": \"C:\\\\stm32tools\\\\openocd\\\\0.12.0-7.1\\\\.content\\\\bin\\\\openocd.EXE\",\n    \"cortex-debug.armToolchainPath\": \"C:\\\\stm32tools\\\\arm-none-eabi-gcc\\\\14.2.1-1.1.1\\\\.content\\\\bin\",\n}\n</code></pre>\n</li>\n<li>\n<p>ctrl + ~</p>\n<p>åœ¨ç»ˆç«¯è¾“å…¥make -j12 æµ‹è¯•çœ‹çœ‹èƒ½å¦æˆåŠŸç¼–è¯‘,å¦‚ä¸‹å›¾å³ä»£è¡¨æˆåŠŸç¼–è¯‘</p>\n<p><img alt=\"image-20260220182335492\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220182335492.png\" /></p>\n</li>\n</ol>\n<h3 id=\"å…³äºŽlaunchjsonæ–‡ä»¶\">å…³äºŽlaunch.jsonæ–‡ä»¶</h3>\n<p>åœ¨å·¦è¾¹æ æ‰¾åˆ°è¿™ä¸ªå›¾æ ‡</p>\n<p><img alt=\"\" /></p>\n<p>ç‚¹å‡»ä¸€ä¸‹é‡Œé¢çš„åˆ›å»ºlaunchæ–‡ä»¶</p>\n<p>å°±å¯ä»¥åœ¨ç›®å½•çš„.vscodeæ–‡ä»¶å¤¹ä¸‹æ‰¾åˆ°</p>\n<p><img alt=\"image-20260220160146084\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220160146084.png\" /></p>\n<p>æˆ‘ä»¬ç›´æŽ¥å¤åˆ¶ä¸‹é¢æˆ‘ä¿®æ”¹å¥½çš„stlinkçš„ä»£ç ï¼ˆdaplinkã€jlinkæ¹–å¤§å¼€æºçš„giteeä»“åº“å·²ç»æä¾›ï¼‰</p>\n<pre><code class=\"language-json\">{\n    // å¯åŠ¨è°ƒè¯•çš„å¿«æ·é”®æ˜¯F5\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        // ä½¿ç”¨dap-link(å¦‚æ— çº¿è°ƒè¯•å™¨æ—¶çš„å‚è€ƒé…ç½®)\n        {\n            \"name\": \"STlink\",\n            \"cwd\": \"${workspaceRoot}\",\n            \"executable\": \"${workspaceRoot}\\\\build\\\\first.elf\", // è¦ä¸‹è½½åˆ°è°ƒè¯•å™¨çš„æ–‡ä»¶,èŠ±æ‹¬å·ä¸­çš„æ˜¯vscodeä¸¤ä¸ªé¢„å®šä¹‰çš„å‚æ•°\n            \"request\": \"launch\",\n            \"type\": \"cortex-debug\",\n            //ä½¿ç”¨J-link GDB Serveræ—¶å¿…é¡»;å…¶ä»–GBD Serveræ—¶å¯é€‰ï¼ˆæœ‰å¯èƒ½å¸®åŠ©è‡ªåŠ¨é€‰æ‹©SVDæ–‡ä»¶ï¼‰\n            //æ”¯æŒçš„è®¾å¤‡è§ https://www.segger.com/downloads/supported-devices.php\n            //svdæ–‡ä»¶ï¼Œæœ‰è¿™ä¸ªæ–‡ä»¶æ‰èƒ½æŸ¥çœ‹å¯„å­˜å™¨çš„å€¼ï¼Œæ¯ä¸ªå•ç‰‡æœºéƒ½ä¸åŒã€‚å¯ä»¥åœ¨ä»¥ä¸‹åœ°å€æ‰¾åˆ°https://github.com/modm-io/cmsis-svd-stm32 \n            //è¯¥é¡¹ç›®çš„æ ¹ç›®å½•å·²ç»æä¾›äº†Cåž‹å¼€å‘æ¿ä½¿ç”¨çš„å¤–è®¾svdæ–‡ä»¶\n            \"svdFile\": \"./STM32F103.svd\",\n            \"servertype\": \"openocd\", //ä½¿ç”¨çš„GDB Server\n            \"configFiles\": [\n                \"openocd_stlink.cfg\", // é…ç½®æ–‡ä»¶å·²ç»åœ¨æ ¹ç›®å½•æä¾›,è‹¥è¦ä¿®æ”¹ä»¥æ­¤ç±»æŽ¨,openocdçš„è·¯å¾„ä¸‹çš„share/scriptsä¸­æœ‰å„ç§å†™å¥½çš„é…ç½®æ–‡ä»¶\n            ],\n            \"runToEntryPoint\": \"main\", // è°ƒè¯•æ—¶åœ¨mainå‡½æ•°å…¥å£åœä¸‹\n            \"preLaunchTask\": \"build task\",//å…ˆè¿è¡ŒBuildä»»åŠ¡ç¼–è¯‘é¡¹ç›®,å–æ¶ˆæ³¨é‡Šå³å¯ä½¿ç”¨\n            \"liveWatch\": {\n                \"enabled\": true,\n                \"samplesPerSecond\": 4\n            }\n        },\n      \n    ],\n}\n</code></pre>\n<p>é…ç½®å®Œæˆä¹‹åŽåœ¨vscodeçš„å·¦ä¾§debugå›¾æ ‡å³å¯çœ‹åˆ°æ›´æ”¹é…ç½®çš„stlinkçš„é…ç½®<br />\n<img alt=\"image-20260220184555431\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184555431.png\" /></p>\n<h3 id=\"å…³äºŽtasksjsonæ–‡ä»¶\">å…³äºŽtasks.jsonæ–‡ä»¶</h3>\n<p>ä½ç½®ä¸Žlaunchæ–‡ä»¶ä¸€æ ·ï¼Œæ²¡æœ‰å°±æ–°å»ºä¸€ä¸ª</p>\n<pre><code class=\"language-json\">{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"build task\",         // ä»»åŠ¡æ ‡ç­¾\n            \"type\": \"shell\",               // ä»»åŠ¡ç±»åž‹,å› ä¸ºè¦è°ƒç”¨mingw32-make,æ˜¯åœ¨ç»ˆç«¯(CMD)é‡Œè¿è¡Œçš„,æ‰€ä»¥æ˜¯shellä»»åŠ¡\n            \"command\": \"make -j24\",// ä»»åŠ¡å‘½ä»¤,çº¿ç¨‹æ•°å¯ä»¥æ ¹æ®è‡ªå·±çš„ç”µè„‘ä¿®æ”¹,å»ºè®®ä¸Žcpuæ ¸æ•°ç›¸åŒ\n            \"problemMatcher\": [],          \n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            }\n        },\n        {\n            \"label\": \"download dap\",\n            \"type\": \"shell\",               // å¦‚æžœå¸Œæœ›åœ¨ä¸‹è½½å‰ç¼–è¯‘,å¯ä»¥æŠŠcommandæ¢æˆä¸‹é¢çš„å‘½ä»¤\n            \"command\":\"make -j24 ; make download_dap\", // \"mingw32-make -j24 ; mingw32-make download_dap\",\n            \"group\": {                     // å¦‚æžœæ²¡æœ‰ä¿®æ”¹ä»£ç ,ç¼–è¯‘ä»»åŠ¡ä¸ä¼šæ¶ˆè€—æ—¶é—´,å› æ­¤æŽ¨èä½¿ç”¨ä¸Šé¢çš„æ›¿æ¢.\n                \"kind\": \"build\",\n                \"isDefault\": false,\n            },\n        },\n        {\n            \"label\": \"download jlink\", // è¦ä½¿ç”¨æ­¤ä»»åŠ¡,éœ€æ·»åŠ jlinkçš„çŽ¯å¢ƒå˜é‡\n            \"type\": \"shell\",\n            \"command\":\"make -j24 ; make download_jlink\", // \"mingw32-make -j24 ; mingw32-make download_jlink\"\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": false,\n            }\n        },\n        {\n            \"label\": \"log\",\n            \"type\": \"shell\",\n            \"command\":\"JlinkRTTClient\",\n            \"args\": [],\n            \"problemMatcher\": [],\n            // \"dependsOn\":[\n            //     \"build task\", // å¯ä»¥æ·»åŠ å¤šä¸ª.\n            // ]\n            // è‹¥ä½¿ç”¨daplink,åˆ™å°†logä»»åŠ¡è®¾ç½®ä¸ºä¾èµ–äºŽjlink launchä»»åŠ¡,ä¿è¯jlink launchä»»åŠ¡å…ˆäºŽlogä»»åŠ¡æ‰§è¡Œ\n        }\n    ]\n}\n</code></pre>\n<h2 id=\"å¼€å§‹è°ƒè¯•\">å¼€å§‹è°ƒè¯•</h2>\n<p>åˆ°æ­¤é…ç½®åº”å½“å·²ç»å®Œæˆäº†ï¼ŒæŽ¥å¥½stlinkï¼Œè¿žæŽ¥å¥½stm32åŽå°±å¯ä»¥æ„‰å¿«çš„è°ƒè¯•å•¦ï¼Œç‚¹å‡»ç»¿è‰²çš„ä¸‰è§’å½¢å¼€å§‹ç¼–è¯‘å¹¶çƒ§å½•åˆ°å•ç‰‡æœº<br />\n<img alt=\"image-20260220184555431\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184555431.png\" /></p>\n<p>ç­‰å¾…ä¸€ä¼šåŽï¼Œå°±ä¼šå‡ºçŽ°ä¸‹å›¾æ‰€ç¤ºçš„è°ƒè¯•ç•Œé¢<br />\n<img alt=\"image-20260220185452486\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185452486.png\" /><br />\nåœ¨å·¦ä¾§å°±æ˜¯è°ƒè¯•å¸¸ç”¨çš„ä¸€äº›å·¥å…·<br />\n<img alt=\"image-20260220185552784\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185552784.png\" /></p>\n<p>cortex live watchå¯ä»¥å®žæ—¶æŸ¥çœ‹å…¨å±€å˜é‡çš„å€¼ï¼Œåªéœ€è¦ç‚¹å‡»åŠ å·<br />\n<img alt=\"image-20260220185701085\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185701085.png\" /></p>\n<p>ç²˜è´´éœ€è¦æŸ¥çœ‹çš„å˜é‡åç§°</p>\n<p><img alt=\"image-20260220185726335\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185726335.png\" /></p>\n<p>å°±å¯ä»¥å®žæ—¶æŸ¥çœ‹åˆ°å˜é‡çš„å€¼å•¦</p>\n<p><img alt=\"image-20260220185758953\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185758953.png\" /></p>\n<p>ä»Žå·¦åˆ°å³ ç¬¬ä¸€ä¸ªæ˜¯é‡ç½®resetï¼Œæš‚åœï¼Œé€è¿‡ç¨‹ï¼Œå•æ­¥ï¼Œå•æ­¥è·³å‡ºï¼Œé‡æ–°å¼€å§‹è°ƒè¯•ï¼Œé€€å‡º</p>\n<p><img alt=\"image-20260220185836594\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185836594.png\" /></p>\n<p>XPERIPHERALSå¿…é¡»é…ç½®ä¸Šé¢çš„svdæ–‡ä»¶æ‰èƒ½å¤Ÿçœ‹åˆ°å¯„å­˜å™¨å†…éƒ¨çš„å€¼</p>\n<p><img alt=\"image-20260220190044929\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220190044929.png\" /></p>\n<p>ä½ ä¹Ÿå¯ä»¥ä¼˜é›…çš„ä½¿ç”¨copilotå·¥å…·æ›´å¿«é€Ÿçš„å¼€å‘stm32å•¦</p>\n<h3 id=\"stm32-svdæ–‡ä»¶\">stm32 svdæ–‡ä»¶</h3>\n<p>stmç³»åˆ—svdä»“åº“ï¼š</p>\n<p><a href=\"https://github.com/modm-io/cmsis-svd-stm32\" rel=\"noopener nofollow\" target=\"_blank\">modm-io/cmsis-svd-stm32: CMSIS SVD files for all STM32 devices</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 19:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chenyouyuan\">ChenYY~</a>&nbsp;\né˜…è¯»(<span id=\"post_view_count\">79</span>)&nbsp;\nè¯„è®º(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">æ”¶è—</a>&nbsp;\n<a href=\"\">ä¸¾æŠ¥</a>\n</div>"
    },
    {
      "title": "“老东西，你懦弱了”——关于Vibe Coding与传统开发",
      "link": "https://www.cnblogs.com/SilverGo/p/19626693",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/SilverGo/p/19626693\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 17:51\">\n    <span>“老东西，你懦弱了”——关于Vibe Coding与传统开发</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>鄙人在昨天刷视频的时候，意外刷到了这样的一个video：<br />\n一幅梗图，列举了2025年和2023年的两套开发工具：<br />\n2025年，我们用TRAE、Claude、Copilot、Windows 11，<br />\n2023年，我们用Clion、IDEA、Vim、Emacs、perf、lldb、gdb、Linux。<br />\n文案是：“老东西，你懦弱了！”</p>\n<h1 id=\"_\"></h1>\n<p>从效率来讲，毫无疑问，2025年的这一套工具不仅开发效率大幅上涨，时间成本降低，从工具本身而言，其技术难度也上涨了。<br />\n但是，从程序员的角度而言，我们丧失了对底层的掌控，<br />\n2025年，动动嘴，什么都解决了。<br />\n2023年，一切都要自己动手。<br />\n2025年的我们，一切效率至上，我们利用AI，少写了很多原来需要自己写的代码，<br />\n可我们难道不应该想想，这真的对吗？</p>\n<p>我们应该问自己，当初为什么喜欢CS？<br />\n不就是因为CS本身的自由、解构与建构吗？<br />\n我们选择AI替我们写代码，是一种将未来交给黑盒的行为。<br />\n一旦出现了隐藏的、AI改不出来的错误，这些长期使用AI的“程序员”将直接傻眼。<br />\n程序员最终是要靠代码建构世界的，而不是PUA Agent的。</p>\n<p>但是完全摒弃AI也是不现实的，那么怎么权衡呢？<br />\n以下是鄙人的愚见：<br />\n1.将AI当作一个高级的手册<br />\n2.核心代码必须自己写<br />\n3.重复性的代码：比如补全某个switch，可以使用AI<br />\n4.架构讨论可以使用AI</p>\n<h1 id=\"结语\">结语</h1>\n<p>这篇文章非常短，而且因为时间原因，写的比较仓促，但是意思到了即可<br />\n在现在的AI时代，我们追求效率至上，但是我们更应该把持本心、坚守初心<br />\n长期完全依赖AI只会减弱自己的能力，否极泰来、物极必反，这是必然的<br />\n了解底层、在没有AI的情况下照样能够写出完美的代码，这才是程序员水平高的表现<br />\n谢谢阅读</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 17:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/SilverGo\">Ghost-Face</a>&nbsp;\n阅读(<span id=\"post_view_count\">153</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "小代码，大视野：评一个典型的“数学可视化 + 计算机图形学入门”的优秀案例(C++精灵库3D案例)",
      "link": "https://www.cnblogs.com/lixingqiu/p/19626608",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lixingqiu/p/19626608\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 16:43\">\n    <span>小代码，大视野：评一个典型的“数学可视化 + 计算机图形学入门”的优秀案例(C++精灵库3D案例)</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span><span>​看视频在这里：https://www.douyin.com/video/7608839461102734592</span></span></p>\n<p><span><span>程序代码在最下面。</span></span></p>\n<p><span id=\"cke_bm_12069S\">&nbsp;</span><span id=\"cke_bm_12069S\">这份代码和视频展示了一个非常典型的“数学可视化 + 计算机图形学入门”的优秀案例。它不仅仅是一段能运行的代码，更是一个将抽象数学公式转化为直观视觉艺术的教学演示。</span></p>\n<p><em id=\"__mceDel\"><span id=\"cke_bm_12069S\"> 以下是对该程序及视频的多维度评论：</span></em></p>\n<h2>1. 技术实现与图形学原理</h2>\n<p>这段代码虽然简短，但完整实现了一个微型3D 渲染管线的核心逻辑，这对于 C++ 初学者来说非常有价值：参数化曲面建模：<br />\n代码核心在于那三行坐标计算公式：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs language-cpp\">p.x =a * <span class=\"hljs-built_in\">cos(v) * <span class=\"hljs-built_in\">sin(u);\np.y =a * <span class=\"hljs-built_in\">cos(u) * <span class=\"hljs-built_in\">cos(v);\np.z = -a * <span class=\"hljs-built_in\">sin(v);</span></span></span></span></span></code></pre>\n<span class=\"cke_reset cke_widget_drag_handler_container\"><img class=\"cke_reset cke_widget_drag_handler lazyload\" height=\"15\" title=\"点击并拖拽以移动\" width=\"15\" /></span></div>\n<p>其中a=u。这是一个参数方程，通过&nbsp;u 和&nbsp;v 两个变量的变化生成三维空间中的点集。视频展示的形态类似于一个螺旋曲面或变形的圆锥面。这种将数学公式直接映射为几何形状的做法，是计算机图形学的基础。</p>\n<ul>\n<li>3D 变换（旋转）：</li>\n</ul>\n<p>rotateY 函数实现了标准的旋转矩阵运算。通过每一帧增加 rotate_angle，实现了物体绕 Y 轴的连续旋转动画。这是理解 3D 空间变换最直观的方式。</p>\n<ul>\n<li>透视投影（Perspective Projection）：</li>\n</ul>\n<p>project 函数中 double factor = scale / (2.0 + p.z); 是点睛之笔。它模拟了人眼“近大远小”的视觉效果。如果没有这一行，物体旋转时看起来会是平面的，加上这一行后，Z 轴的深度感立刻显现出来。</p>\n<ul>\n<li>双缓冲技术：</li>\n</ul>\n<p>screen.tracer(0) 和 screen.update() 的配合使用，意味着程序采用了双缓冲机制。先在后缓冲区绘制完所有点，再一次性显示到屏幕。这有效避免了画面绘制过程中的闪烁，保证了动画的流畅性。</p>\n<h2>2. 视觉效果与美学</h2>\n<p>&nbsp;</p>\n<ul>\n<li>点云风格（Point Cloud）：</li>\n</ul>\n<p>程序没有使用线条（Line）或多边形（Polygon）填充，而是使用了 dot(1) 绘制点。这种点云渲染风格不仅节省了计算量（不需要处理遮挡和光栅化），而且产生了一种复古的、类似示波器或早期矢量显示器的科技感。</p>\n<ul>\n<li>动态着色：</li>\n</ul>\n<p>pen.color(x+y) 这行代码非常巧妙。它没有使用复杂的纹理或光照模型，而是根据屏幕坐标(x,y) 的和来映射颜色。<br />\n优点：计算成本极低，且随着物体旋转，屏幕坐标变化，颜色也会随之流动，产生了一种彩虹般的流光效果，极大地增强了视觉吸引力。<br />\n缺点：颜色是绑定在屏幕空间而非物体表面的，所以颜色会随旋转“滑动”，但这恰恰形成了一种独特的动态美感。</p>\n<ul>\n<li>采样密度：</li>\n\n\n</ul>\n<p>u_steps 和 v_steps 均设为 250，意味着每帧要计算并绘制&nbsp;250×250=62,500&nbsp;个点。在 C++ 中这个计算量完全可以接受，视频中也确实展示了细腻且密集的曲面结构。</p>\n<h2>3. 教育意义与工具推广</h2>\n<p>&nbsp;</p>\n<ul>\n<li>降低 C++ 图形编程门槛：</li>\n\n\n</ul>\n<p>传统的 C++ 图形编程（如 OpenGL/DirectX）配置环境复杂，API 繁琐。视频下方的文字说明提到了 “C++ 精灵库” 和 DevC++。这表明该程序旨在通过封装好的简易库，让中学生或编程初学者能快速看到图形化成果，增强学习信心。</p>\n<ul>\n<li>跨学科融合：</li>\n\n\n</ul>\n<p>这个案例完美融合了数学（三角函数、参数方程）、物理（空间旋转）和计算机科学（循环、结构体、坐标映射）。它是 STEM 教育中非常好的素材。</p>\n<h2>4. 改进建议与思考</h2>\n<p>虽然程序运行效果很好，但如果想进一步优化或深入学习，可以考虑以下方向：</p>\n<ul>\n<li>深度缓冲（Z-Buffering）：</li>\n\n\n</ul>\n<p>目前的绘制顺序是固定的。如果曲面自身发生遮挡（例如旋转 180 度后，背面跑到前面），目前的逻辑可能会把背面的点画在正面的点上面，导致视觉穿帮。引入 Z 缓冲可以解决遮挡关系。</p>\n<ul>\n<li>光照模型：</li>\n\n\n</ul>\n<p>目前的颜色仅依赖坐标。如果引入法向量计算和简单的光照（如 Phong 模型），曲面的立体感会更强，能更清晰地看出凹凸结构。</p>\n<ul>\n<li>交互性：</li>\n\n\n</ul>\n<p>目前只能自动旋转。如果能通过鼠标拖动改变 rotate_angle，或者通过键盘改变参数a 的系数，用户就能实时探索不同参数下的曲面形态，互动性会大大增强。</p>\n<ul>\n<li>性能优化：</li>\n\n\n</ul>\n<p>虽然 6 万点不多，但如果要增加密度，可以考虑只绘制可见面，或者使用 GPU 加速（Shader），不过对于学习 CPU 逻辑来说，当前方案已经足够好。</p>\n<h2>总结</h2>\n<p>这是一个典型的“小代码，大视野”的优秀作品。<br />\n它证明了不需要庞大的游戏引擎，仅凭基础的 C++ 语法和数学知识，就能创造出令人惊叹的视觉艺术。对于视频作者而言，这不仅展示了编程能力，更展示了对数学之美的理解。对于观众而言，这是一个极佳的 C++ 图形化入门启蒙，能激发很多人对“代码如何创造世界”的好奇心。</p>\n<p>评分：☆☆☆☆☆&nbsp; (作为教学演示和数学可视化案例)</p>\n<div class=\"cnblogs_code\">\n<pre>#include <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">sprites.h</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">包含C++精灵库</span>\n#include &lt;cmath&gt;      <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 数学库（sin/cos/π等）</span>\n#include &lt;vector&gt;     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 存储顶点坐标</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">\nScreen screen;\nSprite pen{</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">blank</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">};  \n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">double</span> PI = M_PI;    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 定义常量</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">double</span> rotate_angle = <span style=\"color: rgba(128, 0, 128, 1);\">0.0</span>;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 旋转角度增量（控制动画速度）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> Point3D {    <span style=\"color: rgba(0, 0, 255, 1);\">double</span> x, y, z;};  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3D点结构体\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3D点绕Y轴旋转（实现动态旋转效果）</span>\nPoint3D rotateY(Point3D p, <span style=\"color: rgba(0, 0, 255, 1);\">double</span><span style=\"color: rgba(0, 0, 0, 1);\"> angle) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> cos_a =<span style=\"color: rgba(0, 0, 0, 1);\"> cos(angle);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> sin_a =<span style=\"color: rgba(0, 0, 0, 1);\"> sin(angle);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n        p.x </span>* cos_a - p.z *<span style=\"color: rgba(0, 0, 0, 1);\"> sin_a,\n        p.y,\n        p.x </span>* sin_a + p.z *<span style=\"color: rgba(0, 0, 0, 1);\"> cos_a\n    };\n}\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 透视投影：3D转2D（简化版，增强Z轴深度感）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">void</span> project(Point3D p, <span style=\"color: rgba(0, 0, 255, 1);\">int</span>&amp; screen_x, <span style=\"color: rgba(0, 0, 255, 1);\">int</span>&amp; screen_y, <span style=\"color: rgba(0, 0, 255, 1);\">double</span> scale = <span style=\"color: rgba(128, 0, 128, 1);\">100.0</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> factor = scale / (<span style=\"color: rgba(128, 0, 128, 1);\">2.0</span> + p.z);  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 透视因子（Z越大，投影越小）</span>\n    screen_x = static_cast&lt;<span style=\"color: rgba(0, 0, 255, 1);\">int</span>&gt;(p.x *<span style=\"color: rgba(0, 0, 0, 1);\"> factor);\n    screen_y </span>= static_cast&lt;<span style=\"color: rgba(0, 0, 255, 1);\">int</span>&gt;(p.y *<span style=\"color: rgba(0, 0, 0, 1);\"> factor);\n}\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> main() {        \n    screen.title(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">作者：李兴球</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).bgcolor(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">black</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).tracer(<span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    pen.hide().pu();\n    \n     </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 遍历参数u和v，计算并绘制所有点</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> u_steps = <span style=\"color: rgba(128, 0, 128, 1);\">250</span>;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> u方向采样数（越多越精细）</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> v_steps =<span style=\"color: rgba(128, 0, 128, 1);\">250</span>;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> v方向采样数</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">double</span> u_inc = <span style=\"color: rgba(128, 0, 128, 1);\">2</span> * PI /<span style=\"color: rgba(0, 0, 0, 1);\"> u_steps;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> v_inc = <span style=\"color: rgba(128, 0, 128, 1);\">2</span> * PI / v_steps;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> v范围-π~π，总跨度2π</span>\n   \n    <span style=\"color: rgba(0, 0, 255, 1);\">while</span><span style=\"color: rgba(0, 0, 0, 1);\"> (screen.exitonclick() ) {        \n        screen.clear();   </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 清空屏幕（每一帧重新绘制）           </span>\n        \n        <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt;= u_steps; ++<span style=\"color: rgba(0, 0, 0, 1);\">i) {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> u = i *<span style=\"color: rgba(0, 0, 0, 1);\"> u_inc;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> a = u;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> a = u（公式要求）</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> j = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; j &lt;= v_steps; ++<span style=\"color: rgba(0, 0, 0, 1);\">j) {\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> v = -PI + j * v_inc;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> v从-π到π               </span>\n                Point3D p;   <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算原始3D坐标（蜗牛曲面公式）</span>\n                p.x =a * cos(v) *<span style=\"color: rgba(0, 0, 0, 1);\"> sin(u);\n                p.y </span>=a * cos(u) *<span style=\"color: rgba(0, 0, 0, 1);\"> cos(v);\n                p.z </span>= -a *<span style=\"color: rgba(0, 0, 0, 1);\"> sin(v);\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 绕Y轴旋转，从而实现动态3D效果</span>\n                p =<span style=\"color: rgba(0, 0, 0, 1);\"> rotateY(p, rotate_angle);               \n                </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> x, y;\n                project(p, x, y);   </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 投影到2D屏幕坐标</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">if</span>(x&gt;=<span style=\"color: rgba(128, 0, 128, 1);\">400</span> || x&lt;=-<span style=\"color: rgba(128, 0, 128, 1);\">400</span> || y&gt;=<span style=\"color: rgba(128, 0, 128, 1);\">300</span> || y&lt;= -<span style=\"color: rgba(128, 0, 128, 1);\">300</span>)<span style=\"color: rgba(0, 0, 255, 1);\">continue</span><span style=\"color: rgba(0, 0, 0, 1);\">; \n                pen.color(x</span>+y).go(x, y).dot(<span style=\"color: rgba(128, 0, 128, 1);\">1</span>);  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 绘制当前点     </span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            \n            }\n        }\n        screen.update();\n        rotate_angle </span>+= <span style=\"color: rgba(128, 0, 128, 1);\">0.02</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (rotate_angle &gt; <span style=\"color: rgba(128, 0, 128, 1);\">2</span> * PI) rotate_angle -= <span style=\"color: rgba(128, 0, 128, 1);\">2</span> * PI;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 重置角度，避免溢出        </span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    }\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;    \n}</span></pre>\n</div>\n<p>&nbsp;</p>\n\n<span>\n<span>​</span></span>\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-02-20 16:43</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lixingqiu\">李兴球</a>&nbsp;\n阅读(<span id=\"post_view_count\">50</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吊打OpenClaw！国产AI助理MindX开源：Token消耗砍至10%，还能养出专属数字分身",
      "link": "https://www.cnblogs.com/Ray-liang/p/19626557",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Ray-liang/p/19626557\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 15:56\">\n    <span>吊打OpenClaw！国产AI助理MindX开源：Token消耗砍至10%，还能养出专属数字分身</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>作为一名重度AI工具使用者，26年1月29日在OpenClaw爆火时我第一时间上手体验，初体验确实惊艳——能自动处理后台任务、对接海外社交工具，但这份新鲜感仅维持了两天：QWenChat羊毛薅光、单轮会话的Token用量飙升至680%，一至卡死！日常用GPT-4/Opus更是日均成本50+元，而且全程适配海外生态，微信/飞书/钉钉这些国内办公刚需工具完全不支持，越用越觉得「这根本不是给中国人设计的工具」。</p>\n<p>更让我难以接受的是，当下的AI助理全陷入了「算力堆砌=智能」的内卷：用顶级云端大模型处理查天气、记备忘这种基础任务，就像请院士算加减乘除，既浪费算力又让用户为无意义的Token买单，而且所有数据上云，隐私毫无保障。</p>\n<p>我想既然如此，不如做一款<strong>真正适配国内用户、低成本、保隐私、能进化</strong>的AI个人助理——于是我用了13天开发了MindX，我将其称之为【心智】！这是一款基于仿生大脑架构设计的轻量级智能体，主打本地运行、Token消耗直降90%、全中文生态适配，还能通过长时记忆+自助训练，慢慢养出专属于你的数字分身。</p>\n<p>现在MindX已全开源，支持GitHub/Gitee双端获取，配套官方文档站http://mindx.chat，8G内存就能跑、CPU即可完成模型训练，还完全兼容OpenClaw技能生态，不用重新开发就能直接复用！</p>\n<h2 id=\"为什么说openclaw不适合国内普通用户\">为什么说OpenClaw不适合国内普通用户？</h2>\n<p>先客观说，OpenClaw的产品理念确实超前，但其设计初衷完全围绕海外用户，国内用户用起来全是「痛点」：</p>\n<ol>\n<li><strong>烧钱无底洞</strong>：官方推荐GPT-4+Opus配置，日常写备忘、执行命令行都要调用云端大模型，普通用户根本用不起；</li>\n<li><strong>中文生态拉胯</strong>：仅支持WhatsApp/Telegram/Discord，微信/飞书/钉钉这些国内90%职场人必用的工具完全不兼容；虽然国内大厂都光速支持国内通信适配，但仍然绕不开“堆算力”这个死穴；</li>\n<li><strong>越用越慢</strong>：基础存储式记忆系统，数据积累越多检索越慢，毫无优化可言；（只要你细心翻找记忆文件大多是垃圾文字与垃圾代码）</li>\n<li><strong>隐私无保障</strong>：部分功能依赖云端运行，日常对话、行为习惯等敏感数据全程上云，存在泄露风险；</li>\n<li><strong>资源占用高</strong>：对硬件要求苛刻，普通个人电脑部署后卡顿明显，轻量化体验为零。（即时解释的语言与原生码最大的差异）</li>\n</ol>\n<p>而这些痛点，正是MindX从设计之初就重点解决的核心问题——<strong>我们不做「海外产品的平替」，而是做「为国内用户量身定制的AI助理」</strong>。</p>\n<h2 id=\"mindx核心优势7大亮点直击国内用户刚需\">MindX核心优势：7大亮点，直击国内用户刚需</h2>\n<h3 id=\"-成本腰斩token消耗仅10本地运行几乎零成本\">🔥 成本腰斩：Token消耗仅10%，本地运行几乎零成本</h3>\n<p>MindX最核心的设计是<strong>仿生大脑架构</strong>，复刻人类「潜意识+主意识」的思考模式，从根源上减少无效算力消耗：</p>\n<ul>\n<li><strong>潜意识层（左脑+右脑）</strong>：用500M轻量级本地模型（Qwen3:0.6b）处理查天气、发消息、执行命令行等基础任务，全程本地运行，<strong>零Token消耗、零云端成本</strong>；</li>\n<li><strong>主意识层</strong>：仅在处理编程、写方案、复杂推理等专业任务时，按需调用云端大模型，精准控费；</li>\n<li>实测对比：同场景下，OpenClaw日均Token成本50元，MindX日均成本低至0.5元，核心场景成本直降99%，算力利用率提升80%+。</li>\n</ul>\n<p>为了防止被说我吹牛X，MindX的 Dashboad中有针对各个模型的Token消耗统计图表；各位可以验证钱是不是都烧在了“垃圾话”上面。</p>\n<h3 id=\"-全中文生态微信飞书钉钉qq全覆盖办公生活无缝衔接\">📱 全中文生态：微信/飞书/钉钉/QQ全覆盖，办公生活无缝衔接</h3>\n<p>这是MindX针对国内用户的核心定制化亮点，彻底解决OpenClaw的生态适配问题：</p>\n<ul>\n<li>支持<strong>飞书、微信、钉钉、QQ</strong>四大国内主流办公/社交工具，同时兼容WhatsApp/Telegram/iMessage等海外平台，真正实现全渠道消息统一处理；</li>\n<li>毫秒级响应国内平台消息，无需额外配置开发者工具，扫码即可绑定，职场人不用再在多个APP间切换，效率翻倍。</li>\n</ul>\n<p>打通国内外通信平台，是不是就可以让AI之间毫无阻隔地“畅聊”？</p>\n<h3 id=\"-隐私兜底100本地运行数据永不离身\">🔒 隐私兜底：100%本地运行，数据永不离身</h3>\n<p>个人助理掌握着我们的日常习惯、工作内容、隐私信息，数据安全是底线：</p>\n<ul>\n<li>MindX支持Ollama本地模型部署，<strong>所有对话、记忆、技能执行均在本地电脑完成</strong>，数据不上传任何云端，断网也能正常使用；</li>\n<li>记忆数据、训练模型全部存储在本地目录，用户可自主掌控，彻底告别数据泄露风险。</li>\n</ul>\n<h3 id=\"-长时记忆系统越用越懂你告别ai健忘症\">🧠 长时记忆系统：越用越懂你，告别AI「健忘症」</h3>\n<p>不同于OpenClaw的基础存储，MindX的记忆系统完全复刻人类记忆机制，分为<strong>永久性记忆、长期性记忆、短期性记忆</strong>，实现「学习-整理-遗忘-唤醒」的完整生命周期：</p>\n<ul>\n<li>自动从对话中提取关键信息，生成记忆摘要，去重清洗无效数据，检索速度随使用次数提升，<strong>越用越快</strong>（实测1万条记忆检索仅0.1秒）；</li>\n<li>基于「时间+重复+强调」复合权重排序，常提的信息权重更高，无需反复跟AI叮嘱同一件事，真正实现「一次告知，永久记住」。</li>\n</ul>\n<h3 id=\"-自主进化cpu即可训练6个月养出专属数字分身\">🚀 自主进化：CPU即可训练，6个月养出专属数字分身</h3>\n<p>MindX最特别的能力，就是能通过<strong>LoRA增量训练</strong>，基于你的对话数据持续优化，慢慢变成「另一个你」：</p>\n<ul>\n<li>500M轻量级底模，无需高端GPU，普通电脑的CPU就能完成训练，门槛极低；</li>\n<li>夜间后台自动训练，不占用白天使用时间，完全无感；</li>\n<li>进化时间线清晰：1周理解你的基本偏好，1个月熟悉你的工作习惯，3个月能预判你的需求，6个月彻底成为你的专属数字分身，贴合你的表达风格、思考逻辑。</li>\n</ul>\n<h3 id=\"️-生态兼容轻量部署零基础上手无缝复用openclaw技能\">🛠️ 生态兼容+轻量部署：零基础上手，无缝复用OpenClaw技能</h3>\n<p>为了降低用户使用和开发者贡献门槛，MindX在生态和部署上做了极致优化：</p>\n<ul>\n<li><strong>完全兼容OpenClaw技能</strong>：直接复制OpenClaw的技能即可使用，无需修改，支持任意编程语言CLI开发，技能安装、卸载一键完成；</li>\n<li><strong>轻量级部署</strong>：Go语言原生开发，编译后仅单一可执行文件，无大型数据库依赖，8G内存就能流畅运行，macOS/Linux全适配（Windows版本即将推出）；</li>\n<li><strong>一键安装</strong>：提供预编译包+一键安装脚本，新手无需编译源码，复制命令回车即可完成安装，5分钟上手使用。</li>\n</ul>\n<h3 id=\"-全链路灵活兼容从本地技能到多模型云边协同兼容任意智能体\">⚡ 全链路灵活兼容：从本地技能到多模型云边协同，兼容任意智能体</h3>\n<p>这是MindX最硬核的技术突破，彻底打破了传统AI助理的“封闭围墙”，实现了<strong>「端侧足够省、云端足够强、生态足够广」</strong>的全场景覆盖：</p>\n<ol>\n<li><strong>技能双引擎：本地与MCP无缝切换</strong><br />\nMindX同时原生支持<strong>本地技能</strong>（离线运行、极致隐私）与<strong>MCP协议技能</strong>（云端协同、能力丰富），无需修改代码，即可根据网络环境和隐私需求自动切换执行策略。</li>\n<li><strong>端侧极致量化：小模型也能办大事</strong><br />\n在端侧，MindX深度优化推理引擎，能让<strong>最小的量化模型</strong>（如Qwen3:0.6b）发挥出超出预期的能力，在完成日常任务时，响应速度接近云端大模型，且几乎不占用系统资源。</li>\n<li><strong>云端多模型协同：不做“单模型依赖”</strong><br />\n不同于其他工具仅支持1-2种云端大模型，MindX支持<strong>任意多种大模型同时工作</strong>。你可以为“写代码”绑定DeepSeek，为“写文案”绑定Claude，为“翻译”绑定Volcengine，MindX会根据任务类型智能调度最优模型，真正做到「术业有专攻」。</li>\n<li><strong>智能体即插即用：迁移成本为零</strong><br />\nMindX将智能体完全抽象为「AI助理的能力模型」。这意味着，你在其他平台训练好的、常用的智能体，都可以<strong>直接迁移到MindX中运行</strong>。无需重新调教，你的“老伙计”就能在MindX的仿生大脑架构下，结合长时记忆和本地技能，发挥出比原生平台更强的战斗力。</li>\n</ol>\n<h2 id=\"mindx-vs-openclaw全方位实测对比谁更适合国内用户\">MindX vs OpenClaw：全方位实测对比，谁更适合国内用户？</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">评估维度</th>\n<th style=\"text-align: left;\">MindX（国产定制）</th>\n<th style=\"text-align: left;\">OpenClaw（海外设计）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>日均Token成本</strong></td>\n<td style=\"text-align: left;\">~0.5元（本地优先，按需调用云端）</td>\n<td style=\"text-align: left;\">~50元（依赖GPT-4/Opus云端大模型）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>中文生态适配</strong></td>\n<td style=\"text-align: left;\">微信/飞书/钉钉/QQ全覆盖，毫秒级响应</td>\n<td style=\"text-align: left;\">仅支持海外平台，国内工具完全不兼容</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>记忆系统</strong></td>\n<td style=\"text-align: left;\">仿生长时记忆，自动整理，越用越快</td>\n<td style=\"text-align: left;\">基础存储，数据越多越慢，无优化</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>数据隐私</strong></td>\n<td style=\"text-align: left;\">100%本地运行，数据不上传云端</td>\n<td style=\"text-align: left;\">部分功能依赖云端，存在隐私泄露风险</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>自助训练</strong></td>\n<td style=\"text-align: left;\">支持LoRA增量训练，CPU即可运行，自主进化</td>\n<td style=\"text-align: left;\">不支持，始终依赖通用云端模型</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>硬件要求</strong></td>\n<td style=\"text-align: left;\">轻量级，8G内存即可流畅运行</td>\n<td style=\"text-align: left;\">资源占用高，普通电脑部署卡顿明显</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>技能生态</strong></td>\n<td style=\"text-align: left;\">兼容本地技能+MCP技能+OpenClaw技能</td>\n<td style=\"text-align: left;\">插件系统需特定格式，开发门槛较高</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>模型支持</strong></td>\n<td style=\"text-align: left;\"><strong>端侧最小量化模型 + 云端任意多模型协同</strong></td>\n<td style=\"text-align: left;\">仅支持特定云端大模型，选择受限</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>智能体迁移</strong></td>\n<td style=\"text-align: left;\"><strong>支持，可直接迁移任意智能体运行</strong></td>\n<td style=\"text-align: left;\">不支持，生态封闭</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>部署方式</strong></td>\n<td style=\"text-align: left;\">单一二进制文件，一键安装，本地无服务器依赖</td>\n<td style=\"text-align: left;\">本地/云端部署，配置复杂，依赖较多</td>\n</tr>\n</tbody>\n</table>\n<p><strong>结论</strong>：OpenClaw适合海外用户、不计成本的尝鲜者；而MindX更适合国内普通开发者、职场人，兼顾<strong>低成本、高隐私、全生态、超灵活</strong>，是日常使用的最优解。</p>\n<h2 id=\"5分钟快速上手零基础也能搞定8g内存就能跑\">5分钟快速上手：零基础也能搞定，8G内存就能跑</h2>\n<h3 id=\"前置条件\">前置条件</h3>\n<ul>\n<li>操作系统：macOS / Linux（Windows适配中）</li>\n<li>内存：8GB+（推荐16GB）</li>\n<li>网络：首次安装需下载模型（约2-5GB），后续可离线使用</li>\n</ul>\n<h3 id=\"步骤1安装mindx两种方式任选\">步骤1：安装MindX（两种方式任选）</h3>\n<h4 id=\"方式1预编译包推荐无需编译\">方式1：预编译包（推荐，无需编译）</h4>\n<pre><code class=\"language-bash\"># 下载最新版本（前往GitHub Releases获取链接）\nwget https://github.com/DotNetAge/mindx/releases/download/v0.1.0/mindx-v0.1.0-linux-amd64.tar.gz\n\n# 解压并安装\ntar -xzf mindx-v0.1.0-linux-amd64.tar.gz\ncd mindx-v0.1.0\nchmod +x install.sh &amp;&amp; ./install.sh\n</code></pre>\n<p>MindX会帮助你自动安装所有必要运行本地模型与依赖的软件，如ollama;</p>\n<h4 id=\"方式2从源码编译\">方式2：从源码编译</h4>\n<pre><code class=\"language-bash\"># 克隆仓库\ngit clone https://github.com/DotNetAge/mindx.git\ncd mindx\n\n# 一键构建并安装\nmake install\n</code></pre>\n<h3 id=\"步骤2启动mindx开始使用\">步骤2：启动MindX，开始使用</h3>\n<pre><code class=\"language-bash\">mindx start          # 启动后端服务\nmindx dashboard      # 打开Web界面（默认地址：http://localhost:911）\n# 或使用终端极简界面\nmindx tui\n</code></pre>\n<p>打开Web界面后，扫码绑定社交账号、选择本地模型，即可开始体验——查天气、同步飞书待办、执行命令行，全程本地运行，零Token消耗！</p>\n<h2 id=\"加入我们前100名核心贡献者招募共建国产ai助理生态\">加入我们：前100名核心贡献者招募，共建国产AI助理生态</h2>\n<p>MindX是全开源项目，基于MIT协议发布，初衷是打破海外AI工具的垄断，做一款真正属于中国人、让普通人用得起的AI个人助理。</p>\n<p>时间紧，任务重我只是用了过年这段时间拼老命地写出了整个体系，MindX现在只是个婴儿，还有很多的需要完善地方，更需要有更多与我有着同样初心的同道们加入到这个项目。为推动并争取让MindX成为属于我们国人自己的AI助理。</p>\n<p>目前项目正处于高速迭代期，<strong>诚邀前100名开发者加入核心贡献者阵营</strong>，无论你是会写代码的开发者、擅长写文档的内容创作者，还是仅想提建议的普通用户，都能参与，核心权益包括：</p>\n<ol>\n<li>✨ 专属身份标识：在GitHub README/官方文档站http://mindx.chat永久展示用户名；</li>\n<li>🎁 优先体验新功能：所有新版本、新功能优先体验，一对一技术支持；</li>\n<li>📈 产品决策权：参与项目路线规划，投票决定后续开发方向，你的想法能决定MindX的进化；</li>\n<li>🤝 生态共建者：加入核心开发者群，与同频开发者交流，共同打造国产AI助理生态。</li>\n</ol>\n<h3 id=\"贡献方式零门槛任选其一即可\">贡献方式（零门槛，任选其一即可）</h3>\n<ol>\n<li><strong>文档贡献</strong>：修正文档错别字、补充安装步骤截图、完善FAQ；</li>\n<li><strong>反馈建议</strong>：提交Bug反馈、功能建议，参与GitHub Discussions讨论；</li>\n<li><strong>代码贡献</strong>：修复新手友好型Bug、开发新功能、优化代码性能（仓库已标注good first issue）；</li>\n<li><strong>生态建设</strong>：开发专属技能、适配更多国内工具、分享使用教程。</li>\n</ol>\n<h3 id=\"参与路径\">参与路径</h3>\n<ol>\n<li>GitHub仓库：<a href=\"https://github.com/DotNetAge/mindx\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/DotNetAge/mindx</a></li>\n<li>Gitee仓库：<a href=\"https://gitee.com/DotNetAge/mindx\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/DotNetAge/mindx</a></li>\n<li>官方文档站：<a href=\"http://mindx.chat\" rel=\"noopener nofollow\" target=\"_blank\">http://mindx.chat</a></li>\n<li>贡献指南：前往仓库查看CONTRIBUTING.md，提交PR即可参与</li>\n</ol>\n<h2 id=\"写在最后\">写在最后</h2>\n<p>做MindX不是为了对标某一款产品，而是想打破当下AI行业「烧钱式内卷」的怪圈——AI助理的核心价值应该是「懂你、护你、不耗你」，而不是成为厂商收割Token的工具。（更希望不要被认为是广告贴给屏了，MindX是不为钱不为利只是为了靠谱的代码与项目）</p>\n<p>我们希望通过开源的方式，聚拢更多同频的开发者，一起打造一款<strong>低成本、高隐私、全生态、能进化</strong>的国产AI助理，让每个普通人都能享受到AI技术带来的便利，而不是被高昂的成本和封闭的生态拒之门外。</p>\n<p>现在，MindX的第一版已经落地，后续还会持续优化Windows适配、新增更多国内工具对接、完善记忆系统和训练能力，所有的进化，都期待有你的参与！</p>\n<p>最后，求个Star✨，你的支持，是我们持续开发的最大动力！<br />\nGitHub：<a href=\"https://github.com/DotNetAge/mindx\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/DotNetAge/mindx</a><br />\n官方文档：<a href=\"http://mindx.chat\" rel=\"noopener nofollow\" target=\"_blank\">http://mindx.chat</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 15:56</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Ray-liang\">Ray Liang</a>&nbsp;\n阅读(<span id=\"post_view_count\">68</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "凸优化数学基础笔记（六）：凸集、凸函数与凸规划",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19626486",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19626486\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 14:30\">\n    <span>凸优化数学基础笔记（六）：凸集、凸函数与凸规划</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        现有最优化方法对一般函数只能找到局部最优解，判断有无极值点以及它是否为全局最优解要用到函数凸性概念。一般在现实优化问题上，我们一般把优化问题变成凸优化问题，因为凸优化，**凸优化（Convex OPtimization）**是数学优化中的一个重要分支，研究的是在凸集上极小值的问题。下面首先介绍凸集。从直观上看，凸集是这样一些点的集合，它的内部没有“洞”（hole），边界不向内凹。凸集的基本特征，是其上任取两点所联成线段上的点依然属于这个集合。在数学上就是采用这种描述方法给凸集下定义的。首先给出凸组合的概念，在给出凸集和凸函数的定义，并简单讨论凸函数判定方法\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"凸优化数学基础笔记六凸集凸函数与凸规划\">凸优化数学基础笔记（六）：凸集、凸函数与凸规划</h1>\n<p>现有最优化方法对一般函数只能找到局部最优解，判断有无极值点以及它是否为全局最优解要用到函数凸性概念。一般在现实优化问题上，我们一般把优化问题变成凸优化问题，因为凸优化，凸优化（Convex OPtimization）是数学优化中的一个重要分支，研究的是在凸集上极小值的问题。下面首先介绍凸集。从直观上看，凸集是这样一些点的集合，它的内部没有“洞”（hole），边界不向内凹。凸集的基本特征，是其上任取两点所联成线段上的点依然属于这个集合。在数学上就是采用这种描述方法给凸集下定义的。首先给出凸组合的概念，在给出凸集和凸函数的定义，并简单讨论凸函数判定方法。</p>\n<h2 id=\"1凸-集convex-set\">1.凸 集（Convex Set）</h2>\n<p>​\t<strong>Definition 6.1（凸组合定义）</strong> 设<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2,\\cdots,\\mathbf{X}_l\\)</span> 是<span class=\"math inline\">\\(\\mathbf{R}^n\\)</span> 中的<span class=\"math inline\">\\(l\\)</span>个已知点。若对于某个点<span class=\"math inline\">\\(\\mathbf{X}\\in\\mathbf{R}^n\\)</span> 存在常数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2,\\cdots,\\alpha_{l}\\geq0\\)</span>，且<span class=\"math inline\">\\(\\sum_{i=1}^{l}\\alpha_i=1\\)</span> 使得<span class=\"math inline\">\\(\\mathbf{X}=\\sum_{i=1}^l\\alpha_i\\mathbf{X}_i\\)</span>，则称<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 是<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2,\\cdots,\\mathbf{X}_l\\)</span> 的<strong>凸组合</strong>。若 <span class=\"math inline\">\\(\\alpha_1,\\alpha_2,\\cdots,\\alpha_l&gt;0\\)</span> 且<span class=\"math inline\">\\(\\sum_{i=1}^l\\alpha_i=1\\)</span>，则称<span class=\"math inline\">\\(\\mathbf{X}\\)</span>是<span class=\"math inline\">\\(\\mathbf{X_1},\\mathbf{X}_2,\\cdots,\\mathbf{X}_l\\)</span> 的<strong>严格凸组合</strong>。</p>\n<p>​\t考虑两点<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{X}_2\\)</span>的凸组合<span class=\"math inline\">\\(\\mathbf{X}=\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\)</span> ，其中<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\geq{0}\\)</span> 且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>。把 <span class=\"math inline\">\\(\\alpha_2=1-\\alpha_1\\)</span> 代入<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 的凸组合中得到<span class=\"math inline\">\\(\\mathbf{X}=\\mathbf{X}_2+\\alpha_1(\\mathbf{X}_1-\\mathbf{X}_2)\\)</span> ，其中<span class=\"math inline\">\\(\\alpha\\in[0,1]\\)</span>。由解析几何知识可知，当 <span class=\"math inline\">\\(\\alpha_1\\)</span>从0变到1时，点<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 由点<span class=\"math inline\">\\(\\mathbf{X}_2\\)</span> 出发沿<span class=\"math inline\">\\(\\mathbf{X}_1-\\mathbf{X}_2\\)</span> 的方向移动到<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span> 。由此可知，<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{X}_2\\)</span> 所有严格凸组合的集合是不含<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{X}_2\\)</span> 两端点的线段。</p>\n<p>​\t<strong>Definition 6.2 （凸集的定义）</strong> 设集合<span class=\"math inline\">\\(\\mathbf{C}\\subseteq{\\mathbf{R}^n}\\)</span>。如果对于任意两点<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span> ，它们的任意两点<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span> ，它们的任意凸组合仍然属于<span class=\"math inline\">\\(\\mathbf{C}\\)</span> ，则称集合<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为<strong>凸集</strong>。特别地规定，空集是凸集。</p>\n<p>​\t<strong>Definition 6.3 (半空间的定义)</strong>  设<span class=\"math inline\">\\(\\mathbf{a}\\in\\mathbf{R}^n\\)</span> 且 <span class=\"math inline\">\\(\\mathbf{a}\\neq \\mathbf{0},b\\in{\\mathbf{R}^1}\\)</span> ，则集合<span class=\"math inline\">\\(\\{\\mathbf{X}|\\mathbf{a}^T\\mathbf{X}\\geq{b},\\mathbf{X}\\in{R^n}\\}\\)</span> 称为<span class=\"math inline\">\\(\\mathbf{R}^n\\)</span> 中的一个半空间。</p>\n<p>​\t容易地验证，空间<span class=\"math inline\">\\(\\mathbf{R}^n\\)</span>、半空间、超平面、直线、点、球都是凸集。</p>\n<p>​\t<strong>定理 6.1</strong> 任意一组凸集的交集仍然是<strong>凸集</strong>。</p>\n<p>​\t<strong>证 明：</strong> 设<span class=\"math inline\">\\(C=\\cap_{i\\in I}C_i\\)</span> ,其中<span class=\"math inline\">\\(I\\)</span>是<span class=\"math inline\">\\(\\{C_i\\}\\)</span> 的下标集，<span class=\"math inline\">\\(C_i\\)</span> 都是凸集。任取<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{C}\\)</span> , 则对于任意<span class=\"math inline\">\\(i\\in{I}\\)</span> 都有<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in \\mathbf{C}_i\\)</span>。任取<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in{[0,1]}\\)</span> 且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>，因为<span class=\"math inline\">\\(C_i\\)</span> 是凸集，有 <span class=\"math inline\">\\(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\in{C_i}\\)</span>。于是，<span class=\"math inline\">\\(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\in \\cap_{i\\in{I}}C_i=C\\)</span>，即<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 是凸集。</p>\n<h2 id=\"2凸函数convex-function\">2.凸函数（Convex Function）</h2>\n<p>​\t<strong>Definition 6.4 （凸函数的定义）</strong> 设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow\\mathbf{R}^1\\)</span> , 其中<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为凸集。若对于任意两点<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{C}\\)</span> 和任意一对满足<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span> 的数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in[0,1]\\)</span> ，都有 <span class=\"math inline\">\\(f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2)\\leq \\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2)\\)</span> ，则称<span class=\"math inline\">\\(f\\)</span> 为定义在<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 上的<strong>凸函数</strong>。若对于任意一对满足<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>的数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in(0,1)\\)</span> 都有：</p>\n<p></p><div class=\"math display\">\\[f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2)&lt;\\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2) \\tag{1}\n\\]</div><p></p><p>则称<span class=\"math inline\">\\(f\\)</span>为定义在凸集<span class=\"math inline\">\\(C\\)</span>上<strong>严格凸函数</strong>。</p>\n<p>​\t<strong>Definition 6.5</strong> 若函数<span class=\"math inline\">\\(g(\\mathbf{X})=-f(\\mathbf{X})\\)</span>在凸集<span class=\"math inline\">\\(C\\)</span> 上是（严格）凸函数，则称<span class=\"math inline\">\\(f\\)</span>是定义在凸集<span class=\"math inline\">\\(C\\)</span> 上的（严格）凹函数。</p>\n<p>​\t<strong>定理 6.2</strong> 设<span class=\"math inline\">\\(f:C\\subset\\mathbf{R}^n\\rightarrow\\mathbf{R}^1\\)</span>，其中<span class=\"math inline\">\\(\\mathbf{C}\\)</span>为非空凸集。若<span class=\"math inline\">\\(f\\)</span>是凸函数，则对于任意实数<span class=\"math inline\">\\(\\beta\\)</span>, 水平集<span class=\"math inline\">\\(\\mathbf{D}_{\\beta}=\\{\\mathbf{X}|f(\\mathbf{X})\\leq\\beta,\\mathbf{X}\\in{C}\\}\\)</span> 是凸集。</p>\n<p>​\t<strong>证  明：</strong> 若<span class=\"math inline\">\\(\\mathbf{D}_{\\beta}\\)</span>是空集，则<span class=\"math inline\">\\(\\mathbf{D}_{\\beta}\\)</span> 是凸集。以下设<span class=\"math inline\">\\(\\mathbf{D}_{\\beta}\\)</span> 非空，任取<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span> ,<span class=\"math inline\">\\(\\mathbf{X}_2\\in{D_{\\beta}}\\)</span> ,  则<span class=\"math inline\">\\(f(\\mathbf{X}_1)\\leq\\beta,f(\\mathbf{X}_2)\\leq\\beta\\)</span> 。设<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in[0,1]\\)</span> ,且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span> 根据<span class=\"math inline\">\\(f\\)</span>的凸性，必有</p>\n<p></p><div class=\"math display\">\\[f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2)\\leq \\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2)\\leq \\alpha_1\\beta+\\alpha_2\\beta=\\beta \\tag{2}\n\\]</div><p></p><p>即 <span class=\"math inline\">\\(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\in{\\mathbf{D}_{\\beta}}\\)</span> ,所以 <span class=\"math inline\">\\(\\mathbf{D}_{\\beta}\\)</span> 是凸集。</p>\n<h2 id=\"3判断凸函数的方法\">3.判断凸函数的方法</h2>\n<p>​\t判定一个函数是否为凸函数，一般来说比较困难，但函数可微时，有如下几个定理可供使用。</p>\n<p>​\t<strong>定理 6.3</strong> 设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow{\\mathbf{R}^1}\\)</span> 是可微函数，其中<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为凸集，则：</p>\n<ol>\n<li>\n<p><span class=\"math inline\">\\(f\\)</span>为凸函数的<strong>充要条件</strong>是，<span class=\"math inline\">\\(\\forall \\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span>, 都有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_2)\\geq f(\\mathbf{X}_1)+\\nabla{f(\\mathbf{X}_1)}^T(\\mathbf{X}_2-\\mathbf{X}_1) \\tag{3}\n\\]</div><p></p><p>​</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(f\\)</span>为严格凸函数的<strong>充要条件</strong>是，<span class=\"math inline\">\\(\\forall \\mathbf{X}_1,\\mathbf{X}_2\\in\\mathbf{C}\\)</span>,且<span class=\"math inline\">\\(\\mathbf{X}_1\\neq\\mathbf{X}_2\\)</span>,都有</p>\n</li>\n</ol>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_2)&gt;f(\\mathbf{X}_1)+\\nabla f(\\mathbf{X_1})^T(\\mathbf{X}_2-\\mathbf{X}_1) \\tag{4}\n\\]</div><p></p><p><strong>证 明：</strong> （1）<strong>必要性证明</strong>：已知<span class=\"math inline\">\\(f\\)</span>是<span class=\"math inline\">\\(\\mathbf{C}\\)</span>上的凸函数，证明式（3）。由凸函数定义可知，对满足<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span> 的任意正数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in[0,1]\\)</span>都有</p>\n<p></p><div class=\"math display\">\\[f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2)\\leq\\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2) \\tag{5}\n\\]</div><p></p><p>令<span class=\"math inline\">\\(\\alpha_2=t\\)</span>，则<span class=\"math inline\">\\(\\alpha_1=1-t\\)</span>，代入上式中，整理得到：</p>\n<p></p><div class=\"math display\">\\[\\frac{f(\\mathbf{X}_1+t(\\mathbf{X}_2-\\mathbf{X}_1))-f(\\mathbf{X}_1)}{t}\\leq f(\\mathbf{X}_2)-f(\\mathbf{X}_1) \\tag{6}\n\\]</div><p></p><p>令 <span class=\"math inline\">\\(t\\rightarrow{0}\\)</span> ,由<span class=\"math inline\">\\(f\\)</span>的可微性，利用一阶Taylor展开式，方向导数定义及式（6）可得：</p>\n<p></p><div class=\"math display\">\\[\\nabla f(\\mathbf{X}_1)^T(\\mathbf{X}_2-\\mathbf{X}_1)\\leq {f(\\mathbf{X}_2)-f(\\mathbf{X}_1)} \\tag{7}\n\\]</div><p></p><p>必要性得证；</p>\n<p><strong>充分性证明：</strong> 任取一对正数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in[0,1]\\)</span> ,且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>，考虑点 <span class=\"math inline\">\\(\\mathbf{X}=\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\)</span> 根据充分性假设，应有：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n&amp;f(\\mathbf{X}_1)\\geq f(\\mathbf{X})+\\nabla f(\\mathbf{X})^T(\\mathbf{X}_1-\\mathbf{X})\\\\\n&amp;f(\\mathbf{X}_2)\\geq f(\\mathbf{X})+\\nabla f(\\mathbf{X})^T(\\mathbf{X}_2-\\mathbf{X})\n\\end{aligned}\n\\tag{8}\n\\]</div><p></p><p>两式分别乘以<span class=\"math inline\">\\(\\alpha_1\\)</span> 和<span class=\"math inline\">\\(\\alpha_2\\)</span> 后相加，得到：</p>\n<p></p><div class=\"math display\">\\[\\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2)\\geq f(\\mathbf{X})+\\nabla f(\\mathbf{X})^T(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2-\\mathbf{X})=f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2) \\tag{9} \n\\]</div><p></p><p>由凸函数定义可知，<span class=\"math inline\">\\(f\\)</span> 是<span class=\"math inline\">\\(\\mathbf{C}\\)</span>上的凸函数。</p>\n<p>​\t（2）命题（2）充分性可仿照命题（1）的充分性证得；</p>\n<p>​\t必要性：因为严格凸函数本身是凸函数，所以<span class=\"math inline\">\\(\\forall \\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span> ,且<span class=\"math inline\">\\(\\mathbf{X}_1\\neq\\mathbf{X}_2\\)</span> 都有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_2)\\geq f(\\mathbf{X}_1)+\\nabla f(\\mathbf{X}_1)^T(\\mathbf{X}_2-\\mathbf{X}_1) \\tag{10}\n\\]</div><p></p><p>以下证明式中只能取\"&gt;\"号，假设存在<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span> 且<span class=\"math inline\">\\(\\mathbf{X}_1\\neq\\mathbf{X}_2\\)</span> ,满足</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_2)=f(\\mathbf{X}_1)+\\nabla f(\\mathbf{X}_1)^T(\\mathbf{X}_2-\\mathbf{X}_1) \\tag{11}\n\\]</div><p></p><p>取<span class=\"math inline\">\\(\\mathbf{X}=\\frac{1}{2}\\mathbf{X}_1+\\frac{1}{2}\\mathbf{X}_2\\)</span> ,由<span class=\"math inline\">\\(f\\)</span> 的严格凸性，有：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_3)&lt;\\frac{1}{2}f(\\mathbf{X}_1)+\\frac{1}{2}f(\\mathbf{X}_2) \\tag{12}\n\\]</div><p></p><p>把式（11）代入式（12）中，经整理得：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_3)&lt;f(\\mathbf{X}_1)+\\nabla f(\\mathbf{X}_1)^T(\\mathbf{X}_3-\\mathbf{X}_1) \\tag{13}\n\\]</div><p></p><p>根据本定理（1）部分结论得知，此时与<span class=\"math inline\">\\(f\\)</span>的凸性相矛盾。</p>\n<p>​\t<strong>定 理 6.4</strong> 设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow\\mathbf{R}^1\\)</span> 是二次可微函数，<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为非空开凸集，则<span class=\"math inline\">\\(f\\)</span>为<span class=\"math inline\">\\(C\\)</span>上为凸函数的充要条件是 ，<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 的Hessian矩阵<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X})\\)</span> 在凸集<span class=\"math inline\">\\(C\\)</span> 处处半正定，即<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X})\\succeq{0}\\)</span> 。</p>\n<p>​\t<strong>定 理6.5</strong>  设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow{\\mathbf{R}^1}\\)</span> 是二次可微函数，<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为非空凸集。若<span class=\"math inline\">\\(Hessian\\)</span>矩阵<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X})\\)</span> 在凸集<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 上到处正定，则 <span class=\"math inline\">\\(f\\)</span>在<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 上为严格凸函数。</p>\n<p>​      需要注意，该定理的逆命题不真。</p>\n<p>​      例如 <span class=\"math inline\">\\(f(x)=x^4\\)</span> 在<span class=\"math inline\">\\(\\mathbf{R}^1\\)</span> 上为严格凸函数，但是它的<span class=\"math inline\">\\(Hessian\\)</span>矩阵<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{x})=12x^2\\)</span>在点<span class=\"math inline\">\\(x=0\\)</span> 处是半正定的。</p>\n<h2 id=\"4凸规划-convex-programing\">4.凸规划 （Convex Programing）</h2>\n<p>​\t凸规划是数学优化中的一个重要概念，指目标函数（损失函数）为凸函数、可行域为凸集的优化问题，具有许多的优化性质，例如局部最优解就是全局最优解，且对偶理论成熟。广泛应用于机器学习，信号处理，金融工程等领域。</p>\n<p><strong>Definition 6.6 （凸规划问题）</strong> 设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow{\\mathbf{R}^1}\\)</span> ，其中 <span class=\"math inline\">\\(\\mathbf{C}\\)</span> 是非空凸集合 ，<span class=\"math inline\">\\(f\\)</span> 为凸函数，则形式如下：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n&amp;\\min f(\\mathbf{X})\\\\\n&amp;s.t. \\mathbf{X}\\in{\\mathbf{C}}\n\\end{aligned}\n\\tag{14}\n\\]</div><p></p><p>的优化问题为<strong>凸规划问题</strong>。更进一步，设将可行域的凸集可写为如下形式：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n\\mathbf{C}=\\{\\mathbf{X}|g_i(\\mathbf{X})\\geq0,i=1,\\cdots,l;h_j(\\mathbf{X})=0,j=1,\\cdots,m,\\mathbf{X}\\in R^n\\}\n\\end{aligned}\n\\tag{15}\n\\]</div><p></p><p>若<span class=\"math inline\">\\(g_1,g_2,\\cdots,g_l\\)</span> 都是<span class=\"math inline\">\\(\\mathbf{R}^n\\)</span> 上的凸函数，<span class=\"math inline\">\\(h_1,h_2,\\cdots,h_m\\)</span> 都是<span class=\"math inline\">\\(R^n\\)</span>上的线性函数，则容易验证<span class=\"math inline\">\\(C\\)</span>是凸集 。事实上，因为<span class=\"math inline\">\\(-g_1,-g_2,-g_l\\)</span>都是凸函数，根据定理6.2集合<span class=\"math inline\">\\(\\mathbf{C}_i=\\{\\mathbf{X}|-g(\\mathbf{X})_i\\leq0,\\mathbf{X}\\in{\\mathbf{R}^n}\\}(i=1,2,\\cdots,l)\\)</span> 也都是凸集。此外，超平面<span class=\"math inline\">\\(P_j=\\{\\mathbf{X}|h_j(\\mathbf{X})=0,\\mathbf{X}\\in{\\mathbf{R}^n}\\}(j=1,\\cdots,m)\\)</span> 也都是凸集。显然，<span class=\"math inline\">\\(C\\)</span>是<span class=\"math inline\">\\(C_1,\\cdots,C_l,P_1,\\cdots,P_m\\)</span> 的交集，也是凸集。于是，这种情况下凸规划问题又可表示成如下形式：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n&amp;\\min{f(\\mathbf{X})}\\\\\n&amp;s.t.\\begin{cases}\ng_i(\\mathbf{X})\\geq0 ,\\hspace{2em} i=1,2,\\cdots,l\\\\\nh_j(\\mathbf{X})=0,\\hspace{2em} j=1,2,\\cdots,m\n\\end{cases}\n\\end{aligned}\n\\tag{16}\n\\]</div><p></p><p>如下定理指明凸规划的一个重要性质。</p>\n<p>​\t<strong>定 理6.6</strong> 设<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是凸规划问题的局部极小值，</p>\n<ol>\n<li>若<span class=\"math inline\">\\(f\\)</span>是凸函数，则<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是凸规划问题的局部极小值点；</li>\n<li>若<span class=\"math inline\">\\(f\\)</span>是严格凸函数，则<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是凸规划问题的唯一全局极小值点。</li>\n</ol>\n<p><strong>证  明：</strong>（1）使用反证法。假设<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 不是全局极小值点，则必存在<span class=\"math inline\">\\(Z\\in\\mathbf{C}\\)</span> 使得 <span class=\"math inline\">\\(f(\\mathbf{Z})&lt;f(\\mathbf{X})\\)</span> 。对应<span class=\"math inline\">\\(\\mathbf{Z}\\)</span> 与<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> 的任意凸组合<span class=\"math inline\">\\(\\mathbf{X}=\\alpha_1\\mathbf{Z}+\\alpha_2\\mathbf{X}^*\\)</span>,其中<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in(0,1)\\)</span> 且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>，根据<span class=\"math inline\">\\(f\\)</span>的凸性，有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X})=f(\\alpha_1\\mathbf{Z}+\\alpha_2\\mathbf{X}^*)\\leq \\alpha_1f(\\mathbf{Z})+\\alpha_2f(\\mathbf{X}^*)&lt;\\alpha_1f(\\mathbf{X}^*)+\\alpha_2f(\\mathbf{X}^*)=f(\\mathbf{X}^*) \\tag{17}\n\\]</div><p></p><p>由此看到，当<span class=\"math inline\">\\(\\alpha_1&gt;0\\)</span>充分小时，<span class=\"math inline\">\\(\\mathbf{X}\\)</span>充分接近<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> ，注意到此时也有<span class=\"math inline\">\\(f(\\mathbf{X})&lt;f(\\mathbf{X}^*)\\)</span>，而这与<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> 是局部极小值点相矛盾，因此<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> 必是全局极小值。</p>\n<p>​\t        (2) 假设<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> 不是唯一全局的极小值点，必存在<span class=\"math inline\">\\(\\mathbf{X}^{'}\\in\\mathbf{C}\\)</span> 但<span class=\"math inline\">\\(\\mathbf{X}^{\\prime}\\neq\\mathbf{X}^*\\)</span>，使得<span class=\"math inline\">\\(f(\\mathbf{X}^{\\prime})=f(\\mathbf{X}^*)\\)</span>。考虑中点<span class=\"math inline\">\\(\\mathbf{X}=\\frac{1}{2}(\\mathbf{X}^{\\prime}+\\mathbf{X}^{*})\\in{\\mathbf{C}}\\)</span> 。由于 <span class=\"math inline\">\\(f\\)</span>的严格的凸性，有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X})=f(\\frac{1}{2}(\\mathbf{X^*}+\\mathbf{X}^{\\prime}))&lt;\\frac{1}{2}(f(\\mathbf{X}^*)+f(\\mathbf{X}^{\\prime}))=f(\\mathbf{X}^{*}) \\tag{18}\n\\]</div><p></p><p>此式与<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为全局极小值点相矛盾。这就证明了唯一性。</p>\n<p>​       由上面的推导可知，凸规划有如下优秀的重要性质：</p>\n<ol>\n<li>\n<p><strong>局部最优即全局最优</strong>：凸规划的任一局部极小值点都是全局极小值点；</p>\n</li>\n<li>\n<p><strong>最优解集为凸集</strong>：若存在最优解，则所有最优解构成一个凸集；</p>\n</li>\n<li>\n<p><strong>可微情况下的最优性条件</strong>：若<span class=\"math inline\">\\(f\\)</span>可微，则<span class=\"math inline\">\\(\\mathbf{x}^*\\)</span>为全局最优解的情况下，的充要条件：</p>\n<p></p><div class=\"math display\">\\[\\nabla f(\\mathbf{x}^*)^T(\\mathbf{y}-\\mathbf{x}^*)\\geq{0} \\hspace{2em}\\forall{y}\\in{X}\n\\]</div><p></p></li>\n<li>\n<p><strong>对偶理论</strong>：凸规划的对偶问题也是凸的，且强对偶性通常成立（在某些约束品性下，如Slater条件），即原问题与对偶问题的最优值相等。</p>\n</li>\n</ol>\n<p>其常见的优化问题的例子：</p>\n<ul>\n<li><strong>线性规划</strong>：目标函数和约束均为线性，显然满足凸性。</li>\n<li><strong>二次规划</strong>：目标函数为二次型 <span class=\"math inline\">\\(\\frac{1}{2}x^TQx+c^Tx\\)</span>，若 <span class=\"math inline\">\\(Q\\)</span> 半正定，则为凸二次规划。</li>\n<li><strong>最小二乘：</strong><span class=\"math inline\">\\(min||\\mathbf{A}x-b||_2^2\\)</span> 是凸的；</li>\n<li><strong>锥规划</strong>：如二阶锥规划、半定规划，都是凸规划的重要推广。</li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 14:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">52</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[拆解LangChain执行引擎]非常规Pending Write的持久化",
      "link": "https://www.cnblogs.com/jaydenai/p/19625923/non-regular-pending-writes",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jaydenai/p/19625923/non-regular-pending-writes\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 09:11\">\n    <span>[拆解LangChain执行引擎]非常规Pending Write的持久化</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        PendingWrite三元组的第二部分表示写入的Channel，但是对于一些特殊的场景，比如出错、无写入、中断和恢复，它们的值不再是一个普通的Channel名称\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>PendingWrite三元组的第二部分表示写入的Channel，但是对于一些特殊的场景，比如出错、无写入、中断和恢复，它们的值不再是一个普通的Channel名称，而是使用如下的值：</p>\n<ul>\n<li><code>__error__</code>：执行Node对应的任务出现异常；</li>\n<li><code>__no_writes__</code>：Node任务成功执行，但是没有执行针对Channel的输出；</li>\n<li><code>__interrupt__</code>：任务中断；</li>\n<li><code>__resume__</code>：表示恢复执行提供的数据；</li>\n</ul>\n<p>接下来我们两个例子来产生上述这几种特殊的Pending Write。我们先来模拟出错的场景，如下面的代码片段所示，我们执行的Pregel对象具有一个唯一的Node，它的处理函数直接抛出一个异常。</p>\n<pre><code class=\"language-python\">from langgraph.pregel import Pregel, NodeBuilder\nfrom langgraph.channels import LastValue\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom typing import Any\n\ndef handle(args: dict[str, Any])-&gt;None:\n    raise Exception(\"manllually raised exception\")\n\nnode = NodeBuilder().subscribe_to(\"start\").do(handle)\napp = Pregel(\n    nodes={\"body\": node},\n    channels={\"start\": LastValue(str)},\n    checkpointer=InMemorySaver(),\n    input_channels=[\"start\"],\n    output_channels=[],\n)\nconfig = {\"configurable\": {\"thread_id\": \"123\"}}\ntry:\n    result = app.invoke({\"start\": \"begin\"}, config=config)\nexcept Exception as ex:\n    print(f\"Caught exception:{ex}\" )\n\n(_, _, _, _, pending_writes) = app.checkpointer.get_tuple(config)\nprint(pending_writes)\n</code></pre>\n<p>我们在try/except块中完成针对Pregel的调用，并捕捉和输出得到的异常信息。接下来我们调用Checkpointer（一个InMemorySaver对象）的<code>get_tuple</code>方法得到对应的<code>CheckpointTuple</code>元组，然后将<code>pending_writes</code>部分输出出来。从如下所示的输出结果可以看出，这个Pending Write三元组的Channel名称被设置为 <code>__error__</code> ，整个Exception对象成为了写入的内容。</p>\n<pre><code>Caught exception:manllually raised exception\n[('f9ff1e88-4d82-f417-ad11-8fd870bfe647', '__error__', \"Exception('manllually raised exception')\")]\n</code></pre>\n<p>由于并不是所有的Node都有向Channel写入执行结果的需求，所以只要处理函数成功执行，即使没有Channel输出的行为，该任务的状态也会被视为<code>成功</code>，Checkpointer只是采用不同的形式来记录这种不需要写入的Pending Write。如下的这个程序不仅仅演示了这种<code>无输出写入</code>的场景，还同时模拟了中断和恢复。</p>\n<pre><code class=\"language-python\">from langgraph.pregel import Pregel, NodeBuilder\nfrom langgraph.channels import LastValue\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom typing import Any\nfrom langgraph.types import Command, interrupt\n\ndef foo(args: dict[str, Any]) -&gt; list[str]:\n    resume1 = interrupt(\"1st interrupt\")\n    assert resume1 == \"1st resume\"\n\n    resume2 = interrupt(\"2nd interrupt\")\n    assert resume2 == \"2nd resume\"\n\n    resume3 = interrupt(\"3rd interrupt\")\n    assert resume3 == \"3rd resume\"\n\n    return [resume1, resume2, resume3]\n\ndef bar(args: dict[str, Any]) -&gt; None:\n    pass\n\napp = Pregel(\n    nodes={\n        \"foo\": NodeBuilder().subscribe_only(\"start\").do(foo).write_to(\"output\"),\n        \"bar\": NodeBuilder().subscribe_only(\"start\").do(bar),\n    },\n    channels={\n        \"start\": LastValue(str),\n        \"output\": LastValue(list[str]),\n    },\n    input_channels=[\"start\"],\n    output_channels=[\"output\"],\n    checkpointer=InMemorySaver(),\n)\n\nconfig = {\"configurable\": {\"thread_id\": \"123\"}}\nresult = app.invoke(input={\"start\": \"begin\"}, config=config, stream_mode=\"tasks\")\n(_, _, _, _, pending_writes) = app.checkpointer.get_tuple(config)\nprint(f\"After invoke:\\n{pending_writes}\")\n\napp.invoke(input=Command(resume=\"1st resume\"), config=config)\n(_, _, _, _, pending_writes) = app.checkpointer.get_tuple(config)\nprint(f\"\\nAfter resume 1:\\n{pending_writes}\")\n\napp.invoke(input=Command(resume=\"2nd resume\"), config=config)\n(_, _, _, _, pending_writes) = app.checkpointer.get_tuple(config)\nprint(f\"\\nAfter resume 2:\\n{pending_writes}\")\n\nresult = app.invoke(input=Command(resume=\"3rd resume\"), config=config)\nassert result == {\"output\": [\"1st resume\", \"2nd resume\", \"3rd resume\"]}\n(_, _, _, _, pending_writes) = app.checkpointer.get_tuple(config)\nprint(f\"\\nAfter resume 3:\\n{pending_writes}\")\n</code></pre>\n<p>如上面的代码片段所示，我们为Pregel提供了两个并行执行的节点foo和bar，其中bar对应的函数并未执行任何有效操作，也没有任何的输出。我们为节点foo对应的处理函数制造了三次人为中断，所以需要至少四次调用才能结束。</p>\n<p>我们在创建的RunnableConfig对象中提供了统一的Thread ID，并将它作为后续方法调用的参数。针对Pregel的三次调用，第一次是为常规调用，后面两次分别是针对两次中断的恢复调用。我们在每次调用后，得到并输出Checkpointer记录下来的Pending Write。</p>\n<p>从如下的输出结果可以看出，第一次常规调用后， 节点foo停在第一个中断处，节点bar成功执行但没有输出，所以Checkpointer将它们作为Pending Write记录下来，Channel名称分别是<code>__interrupt__</code>和<code>__no_writes__</code>，前者的写入内容是一个<code>Interrupt</code>对象，它具有我们指定的值“1st interrupt”。我们也看到了Interrupt对象具有一个唯一标识，在恢复调用时我们可以利用此标识为其指定针对性的恢复数据（Command(resume={\"id\":\"resume value\")）。</p>\n<pre><code>After invoke:\n[('8d407c25-02f6-9101-d1b8-5a99c247edde', '__interrupt__', [Interrupt(value='1st interrupt', id='5603cdf275d8b8ba0633d272fa176fd3')]), ('22507855-e257-1b5b-eb1a-3c3fb0a071e9', '__no_writes__', None)]\n\nAfter resume 1:\n[('8d407c25-02f6-9101-d1b8-5a99c247edde', '__interrupt__', [Interrupt(value='2nd interrupt', id='5603cdf275d8b8ba0633d272fa176fd3')]), ('22507855-e257-1b5b-eb1a-3c3fb0a071e9', '__no_writes__', None), ('00000000-0000-0000-0000-000000000000', '__resume__', '1st resume'), ('8d407c25-02f6-9101-d1b8-5a99c247edde', '__resume__', ['1st resume'])]\n\nAfter resume 2:\n[('8d407c25-02f6-9101-d1b8-5a99c247edde', '__interrupt__', [Interrupt(value='3rd interrupt', id='5603cdf275d8b8ba0633d272fa176fd3')]), ('22507855-e257-1b5b-eb1a-3c3fb0a071e9', '__no_writes__', None), ('00000000-0000-0000-0000-000000000000', '__resume__', '2nd resume'), ('8d407c25-02f6-9101-d1b8-5a99c247edde', '__resume__', ['1st resume', '2nd resume'])]\n\nAfter resume 3:\n[]\n</code></pre>\n<p>针对第一个中断的恢复调用后，节点foo停在第二个中断处，此时Checkpointer会创建两个新的Pending Write持久化我们提供的Resume Value（“1st resume”），它的Channel名称就是<code>__resume__</code>，但为什么是两个呢？</p>\n<p>这实际上反映了 Pregel 处理<code>外部指令注入</code>与<code>Node内部消费</code>的同步机制。第一个被称为全局Resume Value（Global Resume Value）, 它代表从外部（通过Command(resume=...)）注入到图中的原始指令。由于它不是由图内Node产生的，因此 Task ID 为空，它是唤醒整个暂停状态的“总开关”。第二个节点foo对全局Resume Value的消费记录，所以具有一个明确的Taks ID。当节点foo被唤醒并执行到interrupt行时，它会从全局Resume Value读取数据。为了保证幂等性和可回溯性，系统会将<code>拿走了哪个Resume Value</code>记录在它的任务路径下。</p>\n<p>针对Resume的冗余设置是为了解决<code>重入与回溯</code>问题。全局记录证明了<code>用户确实提供了这个值</code>。Node记录证明了<code>这个值确实被这个特定的interrupt函数调用消费了</code>。一个Node内部可以连续调用多次interrupt函数，系统需要按顺序记录该Node消费过的所有Resume Value，以便在“时间旅行”或重试时能够精确对齐。</p>\n<p>当我们调用interrupt函数实施人为中断时，底层实际上会抛出一个<code>GraphInterrupt</code>异常，Pregel通过捕获这个异常进而生成针对性的PendingWrite，所以针对同一个任务有可能有一个唯一的中断类型的PendingWrite。由于恢复执行总是会<code>从头执行Node函数</code>，所以基于中断的PendingWrite并不会恢复执行造成任何影响。所以当我们完成第二次恢复调用后，持久化的中断PendingWrite反映的是针对第二次interrupt函数的调用，对应Interrupt对象的值为<code>2nd interrupt</code>。</p>\n<p>Resume Value必须按照顺序提供，因为每遇到一个interrpt函数的调用，都会利用前面介绍过的计算器提供的索引，从Resume Value列表中读取Resume Value作为该调用的返回值，所以持久化的第二个基于恢复的PendingWrite对应的值变成了包含两个Resume Value的列表（['1st resume', '2nd resume']）。</p>\n<p>在针对第三个中断的恢复执行结束后，fooNode完成了它的执行任务，而bar对应的任务本身就是成功状态，所以整个Superstep顺利结束，自然也就不存在Pending Write了。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 09:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jaydenai\">JaydenAI</a>&nbsp;\n阅读(<span id=\"post_view_count\">50</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}