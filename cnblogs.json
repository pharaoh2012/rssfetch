{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "Thread 类的基本用法、Java 线程的几种状态",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19463416",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19463416\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 00:05\">\n    <span>Thread 类的基本用法、Java 线程的几种状态</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"在java中thread类是多线程编程的核心\">在Java中，Thread类是多线程编程的核心。</h3>\n<h4 id=\"线程创建-thread-creation\">线程创建 (Thread Creation)</h4>\n<ul>\n<li>创建线程主要有两种逻辑：继承Thread类或实现Runnable接口。\n<ul>\n<li>方式1：继承 Thread 类，重写run()</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-java\">// 自定义线程类继承Thread\nclass MyThread extends Thread {\n    // 重写run()，定义线程执行逻辑\n    @Override\n    public void run() {\n        System.out.println(\"子线程执行：\" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread t = new MyThread();\n        t.start(); // 3. 调用start()启动线程（不能直接调用run()）\n    }\n}\n</code></pre>\n<ul>\n<li>方式2：实现Runnable接口，传给Thread</li>\n</ul>\n<pre><code class=\"language-java\">// 实现Runnable接口\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"子线程执行：\" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\npublic class Demo {\n    public static void main(String[] args) {\n        // 把Runnable实例传给Thread\n        Thread t = new Thread(new MyRunnable());\n        t.start(); // 启动线程\n    }\n}\n</code></pre>\n<h4 id=\"线程中断-thread-interruption\">线程中断 (Thread Interruption)</h4>\n<ul>\n<li>线程中断不是强制停止线程，而是一种协作机制，即给线程发一个“请停止”的信号。</li>\n<li>void interrupt()：标记线程为 “中断状态”</li>\n<li>boolean isInterrupted()：判断线程是否处于中断状态</li>\n<li>若线程在sleep/wait/join时被中断，会抛出InterruptedException，且中断状态会被清除</li>\n</ul>\n<pre><code class=\"language-java\">Thread t = new Thread(() -&gt; {\n    while (!Thread.currentThread().isInterrupted()) { // 检测中断状态\n        System.out.println(\"线程运行中...\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // 捕获中断异常后，中断状态会被清除，需手动终止循环\n            System.out.println(\"线程被中断\");\n            Thread.currentThread().interrupt(); // 重新标记中断（可选）\n            break;\n        }\n    }\n});\nt.start();\n// 主线程1秒后中断子线程\nThread.sleep(1000);\nt.interrupt();\n</code></pre>\n<h4 id=\"线程等待-thread-join\">线程等待 (Thread Join)</h4>\n<ul>\n<li>有时主线程需要等待子线程执行完毕后再继续执行，这时可以使用join()。</li>\n<li>t.join()：当前线程会进入阻塞状态，直到线程t执行结束。</li>\n<li>带参数的 join(long millis)：设置最大等待时间，如果超时线程还没结束，当前线程就不再等待。</li>\n</ul>\n<pre><code class=\"language-java\">Thread t = new Thread(() -&gt; {\n    System.out.println(\"子线程开始执行\");\n    try { Thread.sleep(2000); } catch (InterruptedException e) {}\n    System.out.println(\"子线程执行完毕\");\n});\nt.start();\n\n// 主线程等待t执行完（最多等3秒）\nt.join(3000); \nSystem.out.println(\"主线程继续执行\");\n</code></pre>\n<h4 id=\"线程休眠-thread-sleep\">线程休眠 (Thread Sleep)</h4>\n<ul>\n<li>static void sleep(long millis)：让当前线程暂停指定时间（不会释放锁），抛出InterruptedException</li>\n</ul>\n<pre><code class=\"language-java\">System.out.println(\"开始休眠\");\ntry {\n    Thread.sleep(2000); // 当前线程休眠2秒\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.println(\"休眠结束\");\n</code></pre>\n<h4 id=\"获取线程实例-get-current-instance\">获取线程实例 (Get Current Instance)</h4>\n<ul>\n<li>在编写通用代码（尤其是 Runnable 中）时，常需要知道是谁在运行。</li>\n<li>Thread.currentThread()：返回代码当前正在执行的那个线程对象的引用。</li>\n<li>常用操作：获取线程 ID (getId())、获取线程名称 (getName()) 等。</li>\n</ul>\n<pre><code class=\"language-java\">// 获取当前线程（这里是main线程）\nThread mainThread = Thread.currentThread();\nSystem.out.println(\"当前线程名：\" + mainThread.getName()); // 输出\"main\"\n\n// 子线程实例\nThread t = new Thread(() -&gt; {\n    Thread current = Thread.currentThread();\n    System.out.println(\"子线程名：\" + current.getName()); // 输出\"Thread-0\"\n});\nt.start();\n</code></pre>\n<hr />\n<h3 id=\"java线程的几种状态\">Java线程的几种状态</h3>\n<h4 id=\"线程状态一共有几种\">线程状态一共有几种？</h4>\n<ul>\n<li>Java线程共有6种状态：\n<ul>\n<li>NEW (新建)</li>\n<li>RUNNABLE (可运行)</li>\n<li>BLOCKED (阻塞)</li>\n<li>WAITING (等待)</li>\n<li>TIMED_WAITING (超时等待)</li>\n<li>TERMINATED (终止)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"每种状态的含义与切换条件\">每种状态的含义与切换条件</h4>\n<ol>\n<li>NEW (新建)</li>\n</ol>\n<ul>\n<li>含义：创建了线程对象（new Thread()），但尚未调用 start() 方法。</li>\n<li>切换：调用 start() 方法后，进入 RUNNABLE 状态。</li>\n</ul>\n<ol start=\"2\">\n<li>RUNNABLE (可运行)</li>\n</ol>\n<ul>\n<li>含义：Java 将操作系统中的“就绪（Ready）”和“运行中（Running）”两种状态统称为 RUNNABLE。处于该状态的线程可能正在 CPU 上执行，也可能正在等待操作系统分配时间片。</li>\n<li>切换：\n<ul>\n<li>就绪 -&gt; 运行：获得 CPU 时间片。</li>\n<li>运行 -&gt; 就绪：CPU 时间片用完，或主动调用 Thread.yield()。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>BLOCKED (阻塞)</li>\n</ol>\n<ul>\n<li>含义：线程正在等待获取一个排他锁（如进入synchronized 代码块/方法），但该锁目前被其他线程持有。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; BLOCKED：尝试进入 synchronized 区域失败。</li>\n<li>BLOCKED -&gt; RUNNABLE：其他线程释放锁，当前线程成功竞争到锁。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li>WAITING (等待)</li>\n</ol>\n<ul>\n<li>含义：线程处于无限期的等待状态，不会被分配 CPU 时间，必须等待其他线程显式地唤醒。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; WAITING：调用 Object.wait()（不带参数）、Thread.join()（不带参数）或 LockSupport.park()。</li>\n<li>WAITING -&gt; RUNNABLE：其他线程调用 Object.notify()、notifyAll() 或 LockSupport.unpark()。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>TIMED_WAITING (超时等待)</li>\n</ol>\n<ul>\n<li>含义：与 WAITING 类似，但在指定的时间后会自动唤醒，不需要其他线程显式唤醒。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; TIMED_WAITING：调用 Thread.sleep(ms)、Object.wait(ms)、Thread.join(ms) 等带时间参数的方法。</li>\n<li>TIMED_WAITING -&gt; RUNNABLE：时间结束，或被提前唤醒（如 notify()）。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"6\">\n<li>TERMINATED (终止)</li>\n</ol>\n<ul>\n<li>含义：线程已经执行完毕（run() 方法正常结束）或因异常退出了执行。</li>\n<li>切换：线程一旦进入此状态，生命周期结束，不可再次启动（再次调用 start() 会抛出异常）。</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 00:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MQTT状态管理Vuex全局状态管理",
      "link": "https://www.cnblogs.com/zhangyouwu/p/19463616",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zhangyouwu/p/19463616\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 23:39\">\n    <span>MQTT状态管理Vuex全局状态管理</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>1.uniapp集成MQTT协议，参考我的文章：https://www.cnblogs.com/zhangyouwu/p/19439905</p>\n<p>2.创建store/index.js</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 页面路径：store/index.js</span>\nimport { createStore } <span style=\"color: rgba(0, 0, 255, 1);\">from</span> <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">vuex</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">const</span> store =<span style=\"color: rgba(0, 0, 0, 1);\"> createStore({\n    state:{</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">存放状态</span>\n        <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">xcx_zt</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>:<span style=\"color: rgba(128, 0, 128, 1);\">0</span>,<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">程序是否在线</span>\n        <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">m_zt</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>:<span style=\"color: rgba(128, 0, 128, 1);\">0</span>,<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">设备是否在线</span>\n        <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">m_id</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>:<span style=\"color: rgba(128, 0, 0, 1);\">''</span>,<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">设备ID</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    },\n    mutations: {\n        chang_xcx_zt(state, n) {\n            state.xcx_zt </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> n\n        },\n        chang_m_zt(state, n) {\n            state.m_zt </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> n\n        },\n        chang_m_id(state, n) {\n            state.m_id </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> n\n        },\n    }\n})\n\nexport </span><span style=\"color: rgba(0, 0, 255, 1);\">default</span> store</pre>\n</div>\n<p>3.在&nbsp;<code>main.js</code>&nbsp;中导入文件，主要这2句</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"131\" width=\"296\" /></p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre>import store <span style=\"color: rgba(0, 0, 255, 1);\">from</span> <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">./store</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span></pre>\n</div>\n<div class=\"cnblogs_code\">\n<pre>app.use(store)</pre>\n</div>\n<p>&nbsp;4.修改mqtt.js</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed lazyload\" id=\"code_img_closed_a5642118-0284-428d-a408-0df02db1cd1c\" /><img class=\"code_img_opened lazyload\" id=\"code_img_opened_a5642118-0284-428d-a408-0df02db1cd1c\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_a5642118-0284-428d-a408-0df02db1cd1c\">\n<pre>import mqtt <span style=\"color: rgba(0, 0, 255, 1);\">from</span> <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">mqtt/dist/mqtt.min</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\nimport store </span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">@/store/index.js</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>\n<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> MQTT 配置（根据实际服务端修改）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">const</span> MQTT_CONFIG =<span style=\"color: rgba(0, 0, 0, 1);\"> {\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 不同端的连接协议：\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> H5: ws:</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">xxx:8083/mqtt 或 wss:</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">xxx:8084/mqtt\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 微信小程序: wxs:</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">xxx:8084/mqtt（需配置域名白名单）\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> App: tcp:</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">xxx:1883（需配置网络权限）</span>\n    host: <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">wxs://xxx:8084/mqtt</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">, \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> host: 'ws:</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">xxx:8083/mqtt', </span>\n    clientId: `wine-${Math.random().toString(<span style=\"color: rgba(128, 0, 128, 1);\">16</span>).substr(<span style=\"color: rgba(128, 0, 128, 1);\">2</span>, <span style=\"color: rgba(128, 0, 128, 1);\">8</span>)}`, <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 唯一客户端ID</span>\n    username: <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">zyw</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 服务端认证用户名（无则留空）</span>\n    password: <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">zyw123456</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 服务端认证密码（无则留空）</span>\n    keepalive: <span style=\"color: rgba(128, 0, 128, 1);\">60</span>, <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 心跳间隔（秒）</span>\n    reconnectPeriod: <span style=\"color: rgba(128, 0, 128, 1);\">5000</span>, <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 重连间隔（毫秒）</span>\n    clean: <span style=\"color: rgba(0, 0, 255, 1);\">true</span> <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 清除会话（true：断开后不保留订阅）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">}\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 全局 MQTT 客户端实例</span>\nlet client = <span style=\"color: rgba(0, 0, 255, 1);\">null</span>\n<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 消息回调函数（供页面监听）</span>\nlet messageCallback = <span style=\"color: rgba(0, 0, 255, 1);\">null</span>\n\n<span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\">*\n * 连接 MQTT 服务器\n * @param {Function} callback 消息接收回调 (topic, message) =&gt; {}\n </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\nexport function connectMQTT(callback) {\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保存消息回调</span>\n    messageCallback =<span style=\"color: rgba(0, 0, 0, 1);\"> callback\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 已连接则直接返回</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (client &amp;&amp;<span style=\"color: rgba(0, 0, 0, 1);\"> client.connected){\n        store.commit(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">chang_xcx_zt</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, <span style=\"color: rgba(128, 0, 128, 1);\">1</span>)<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">在线</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    } \n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建连接</span>\n    client =<span style=\"color: rgba(0, 0, 0, 1);\"> mqtt.connect(MQTT_CONFIG.host, {\n        clientId: MQTT_CONFIG.clientId,\n        username: MQTT_CONFIG.username,\n        password: MQTT_CONFIG.password,\n        keepalive: MQTT_CONFIG.keepalive,\n        reconnectPeriod: MQTT_CONFIG.reconnectPeriod,\n        clean: MQTT_CONFIG.clean\n    })\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 连接成功回调</span>\n    client.on(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">connect</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, () =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n        console.log(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">MQTT 连接成功：</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">, MQTT_CONFIG.clientId);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\">(MQTT_CONFIG.clientId){\n            store.commit(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">chang_xcx_zt</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, <span style=\"color: rgba(128, 0, 128, 1);\">1</span>)<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">在线</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (messageCallback) {\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> p_obj=<span style=\"color: rgba(0, 0, 0, 1);\">{};\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> p_data=<span style=\"color: rgba(0, 0, 0, 1);\">{};\n                \n                p_data.keyword</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">connect</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                p_data.clientId</span>=<span style=\"color: rgba(0, 0, 0, 1);\">MQTT_CONFIG.clientId;\n                p_data.msg</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">MQTT 连接成功</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                \n                p_obj.code</span>=<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                p_obj.data</span>=<span style=\"color: rgba(0, 0, 0, 1);\">p_data;\n                messageCallback(p_obj) </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 转字符串便于处理</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            }\n        }\n    })\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 接收消息回调</span>\n    client.on(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">message</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, (topic, message) =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n        console.log(`收到消息1：topic</span>=${topic}, message=<span style=\"color: rgba(0, 0, 0, 1);\">${message.toString()}`)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (messageCallback) {\n            messageCallback(topic, message.toString()) </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 转字符串便于处理</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        }\n    })\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 连接错误回调</span>\n    client.on(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">error</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, (error) =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n        console.error(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">MQTT 连接错误：</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">, error)\n        store.commit(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">chang_xcx_zt</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, <span style=\"color: rgba(128, 0, 128, 1);\">0</span>)<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">离线</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (messageCallback) {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> p_obj=<span style=\"color: rgba(0, 0, 0, 1);\">{};\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> p_data=<span style=\"color: rgba(0, 0, 0, 1);\">{};\n            p_data.keyword</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">error</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            p_data.error</span>=<span style=\"color: rgba(0, 0, 0, 1);\">error;\n            p_data.msg</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">MQTT 连接错误</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            \n            p_obj.code</span>=<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            p_obj.data</span>=<span style=\"color: rgba(0, 0, 0, 1);\">p_data;\n            messageCallback(p_obj) </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 转字符串便于处理</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        }\n        \n    })\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 断开连接回调</span>\n    client.on(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">close</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, () =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n        console.log(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">MQTT 连接断开</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        store.commit(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">chang_xcx_zt</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, <span style=\"color: rgba(128, 0, 128, 1);\">0</span>)<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">离线</span>\n\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (messageCallback) {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> p_obj=<span style=\"color: rgba(0, 0, 0, 1);\">{};\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> p_data=<span style=\"color: rgba(0, 0, 0, 1);\">{};\n            p_data.keyword</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">close</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            p_data.msg</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">MQTT 连接断开</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            \n            p_obj.code</span>=<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            p_obj.data</span>=<span style=\"color: rgba(0, 0, 0, 1);\">p_data;\n            messageCallback(p_obj) </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 转字符串便于处理</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        }\n    })\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 重连回调</span>\n    client.on(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">reconnect</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, () =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n        console.log(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">MQTT 正在重连...</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        store.commit(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">chang_xcx_zt</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, <span style=\"color: rgba(128, 0, 128, 1);\">0</span>)<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">离线</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (messageCallback) {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> p_obj=<span style=\"color: rgba(0, 0, 0, 1);\">{};\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> p_data=<span style=\"color: rgba(0, 0, 0, 1);\">{};\n            p_data.keyword</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">reconnect</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            p_data.msg</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">MQTT 正在重连</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            \n            p_obj.code</span>=<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            p_obj.data</span>=<span style=\"color: rgba(0, 0, 0, 1);\">p_data;\n            messageCallback(p_obj) </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 转字符串便于处理</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        }\n    })\n}\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\">*\n * 断开 MQTT 连接\n </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\nexport function disconnectMQTT(callback) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (client &amp;&amp;<span style=\"color: rgba(0, 0, 0, 1);\"> client.connected) {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保存消息回调</span>\n        messageCallback =<span style=\"color: rgba(0, 0, 0, 1);\"> callback\n        client.end()\n        client </span>= <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">\n        console.log(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">MQTT 主动断开连接</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        store.commit(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">chang_xcx_zt</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, <span style=\"color: rgba(128, 0, 128, 1);\">0</span>)<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">离线</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (messageCallback) {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> p_obj=<span style=\"color: rgba(0, 0, 0, 1);\">{};\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> p_data=<span style=\"color: rgba(0, 0, 0, 1);\">{};\n            p_data.keyword</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">disconnect</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            p_data.msg</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">MQTT 主动断开连接</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            \n            p_obj.code</span>=<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            p_obj.data</span>=<span style=\"color: rgba(0, 0, 0, 1);\">p_data;\n            messageCallback(p_obj) </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 转字符串便于处理</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        }\n        \n    }\n}\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\">*\n * 订阅 MQTT 主题\n * @param {String|Array} topic 主题（单个字符串或数组）\n * @param {Number} qos 服务质量（0/1/2，默认0）\n </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\nexport function subscribeMQTT(topic, qos </span>= <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n  </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!client || !<span style=\"color: rgba(0, 0, 0, 1);\">client.connected) {\n    console.error(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">MQTT 未连接，无法订阅</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\">\n  }\n  client.subscribe(topic, { qos }, (error) </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (error) {\n      console.error(`订阅主题 ${topic} 失败：`, error)\n    } </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n      console.log(`订阅主题 ${topic} 成功`)\n    }\n  })\n}\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\">*\n * 发布 MQTT 消息\n * @param {String} topic 主题\n * @param {String|Object} message 消息内容（对象会转为JSON字符串）\n * @param {Number} qos 服务质量（0/1/2，默认0）\n </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\nexport function publishMQTT(topic, message, qos </span>= <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n  </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!client || !<span style=\"color: rgba(0, 0, 0, 1);\">client.connected) {\n    console.error(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">MQTT 未连接，无法发布消息</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\">\n  }\n  </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 统一转为字符串</span>\n  <span style=\"color: rgba(0, 0, 255, 1);\">const</span> msg = <span style=\"color: rgba(0, 0, 255, 1);\">typeof</span> message === <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">object</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span> ?<span style=\"color: rgba(0, 0, 0, 1);\"> JSON.stringify(message) : message\n  client.publish(topic, msg, { qos }, (error) </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (error) {\n      console.error(`发布消息到 ${topic} 失败：`, error)\n    } </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n      console.log(`发布消息到 ${topic} 成功：`, msg)\n    }\n  })\n}\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\">*\n * 取消订阅 MQTT 主题\n * @param {String|Array} topic 主题（单个字符串或数组）\n </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\nexport function unsubscribeMQTT(topic) {\n  </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!client || !<span style=\"color: rgba(0, 0, 0, 1);\">client.connected) {\n    console.error(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">MQTT 未连接，无法取消订阅</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\">\n  }\n  client.unsubscribe(topic, (error) </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (error) {\n      console.error(`取消订阅 ${topic} 失败：`, error)\n    } </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n      console.log(`取消订阅 ${topic} 成功`)\n    }\n  })\n}\n\n\nmqtt.js</span></pre>\n</div>\n<span class=\"cnblogs_code_collapse\">mqtt.js</span></div>\n<p>5.创建在线组件/components/online/online.vue,<span style=\"color: rgba(255, 0, 0, 1);\">其中2个getApp().add_log方法是上传连接日志到服务器，请自行删除</span></p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed lazyload\" id=\"code_img_closed_87271cd2-a872-4a00-ae09-0f1d652be10d\" /><img class=\"code_img_opened lazyload\" id=\"code_img_opened_87271cd2-a872-4a00-ae09-0f1d652be10d\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_87271cd2-a872-4a00-ae09-0f1d652be10d\">\n<pre>&lt;template&gt;\n    &lt;view&gt;\n        &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">topfixed</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n            &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">topfixed_content</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n                &lt;!-- &lt;view :style=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">'height:'+statusBarHeight+'px;'</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;&lt;/view&gt; --&gt;\n                &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">topNavBox</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n                    &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">leftBtnBox</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n                        &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">gobackBox color-white font-28</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n                            &lt;view&gt;设备：&lt;/view&gt;\n                            &lt;block v-<span style=\"color: rgba(0, 0, 255, 1);\">if</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">m_zt==1</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n                                &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">flex</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n                                    &lt;u-icon name=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">pause-circle-fill</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> color=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">#00AA59</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> size=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">18</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;&lt;/u-icon&gt;\n                                    &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ml6</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;在线&lt;/view&gt;\n                                &lt;/view&gt;\n                            &lt;/block&gt;\n                            \n                            &lt;block v-<span style=\"color: rgba(0, 0, 255, 1);\">else</span>&gt;\n                                &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">flex</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n                                    &lt;u-icon name=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">minus-circle-fill</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> color=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">#ff0000</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> size=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">18</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;&lt;/u-icon&gt;\n                                    &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ml6</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;离线&lt;/view&gt;\n                                &lt;/view&gt;\n                            &lt;/block&gt;\n                        &lt;/view&gt;\n                        \n                    &lt;/view&gt;\n                &lt;/view&gt;\n                \n                &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">topNavBox</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n                    &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">leftBtnBox</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n                        &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">gobackBox color-white font-28</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n                            &lt;view&gt;程序：&lt;/view&gt;\n                            &lt;block v-<span style=\"color: rgba(0, 0, 255, 1);\">if</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">xcx_zt==1</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n                                &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">flex</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> @click=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">disconnect</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n                                    &lt;u-icon name=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">pause-circle-fill</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> color=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">#00AA59</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> size=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">18</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;&lt;/u-icon&gt;\n                                    &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ml6</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;在线&lt;/view&gt;\n                                &lt;/view&gt;\n                            &lt;/block&gt;\n                            \n                            &lt;block v-<span style=\"color: rgba(0, 0, 255, 1);\">else</span>&gt;\n                                &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">flex</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> @click=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">connect</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n                                    &lt;u-icon name=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">minus-circle-fill</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> color=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">#ff0000</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> size=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">18</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;&lt;/u-icon&gt;\n                                    &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ml6</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;离线&lt;/view&gt;\n                                &lt;/view&gt;\n                            &lt;/block&gt;\n                        &lt;/view&gt;\n                        \n                    &lt;/view&gt;\n                &lt;/view&gt;\n            &lt;/view&gt;\n        &lt;/view&gt;\n    &lt;/view&gt;\n&lt;/template&gt;\n\n&lt;script&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n    import { connectMQTT, subscribeMQTT, publishMQTT, disconnectMQTT } </span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">@/common/mqtt.js</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    export </span><span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n        name:</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">online</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n        props: {\n        },\n        \n        data() {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                statusBarHeight: uni.getSystemInfoSync ().statusBarHeight,</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">状态栏高度</span>\n                receiveMessage: <span style=\"color: rgba(128, 0, 0, 1);\">''</span> <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 接收的消息</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            }\n        },\n        computed: {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">程序：0离线 1在线</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            xcx_zt() {\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">.$store.state.xcx_zt;\n            },\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">设备：0离线 1在线</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            m_zt() {\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">.$store.state.m_zt;\n            }\n        },\n\n        methods: {\n            \n        \n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 连接MQTT</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            connect() {\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> _this=<span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                connectMQTT((res) </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n                    \n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">console.log(res);</span>\n                    <span style=\"color: rgba(0, 0, 255, 1);\">if</span>(res.code==<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">){\n                        getApp().add_log(res.data).then((resolve, reject) </span>=&gt; {<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">创建日志\n                            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">console.log(resolve);</span>\n                            <span style=\"color: rgba(0, 0, 255, 1);\">if</span>(resolve.code==<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">){\n                            }\n                        })\n                    }\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> var str=`主题：${topic}，内容：${message}`;\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> console.log(str)\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span> <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 监听接收的消息\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> _this.receiveMessage = `主题：${topic}，内容：${message}`</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">                })\n            },\n            \n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 订阅主题（示例：/uni-app/test）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            subscribe() {\n                subscribeMQTT(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">/uni-app/test</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n            },\n        \n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 发布消息（示例：向/uni-app/test发布消息）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            publish() {\n                publishMQTT(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">/uni-app/test</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">, {\n                    content: </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">Hello Uni-app MQTT</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                    time: </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Date().toLocaleString()\n                })\n            },\n        \n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 断开连接</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            disconnect() {\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> _this=<span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                disconnectMQTT((res) </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>(res.code==<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">){\n                        getApp().add_log(res.data).then((resolve, reject) </span>=&gt; {<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">创建日志\n                            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">console.log(resolve);</span>\n                            <span style=\"color: rgba(0, 0, 255, 1);\">if</span>(resolve.code==<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">){\n                                </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>.receiveMessage = <span style=\"color: rgba(128, 0, 0, 1);\">''</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                            }\n                        })\n                    }\n                \n                });                \n            }\n    \n            \n        }\n    }\n</span>&lt;/script&gt;\n\n&lt;style&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n.topfixed{\n        position: </span><span style=\"color: rgba(0, 0, 255, 1);\">fixed</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        top: </span><span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        left: </span><span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        z</span>-index: <span style=\"color: rgba(128, 0, 128, 1);\">20</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> // background-color: #fff; </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n        width: </span><span style=\"color: rgba(128, 0, 128, 1);\">100</span>%<span style=\"color: rgba(0, 0, 0, 1);\">;\n        padding: </span><span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\"> 20rpx;\n        box</span>-sizing: border-<span style=\"color: rgba(0, 0, 0, 1);\">box;\n    }\n    .topfixed_content{\n        width: </span><span style=\"color: rgba(128, 0, 128, 1);\">100</span>%<span style=\"color: rgba(0, 0, 0, 1);\">;\n    }\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> #ifdef H5 </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    .topfixed_content{\n        max</span>-<span style=\"color: rgba(0, 0, 0, 1);\">width: 420px;\n        margin: auto;\n    }\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\"> #endif </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    .topfixed .topNavBox{\n        width:</span><span style=\"color: rgba(128, 0, 128, 1);\">100</span>%<span style=\"color: rgba(0, 0, 0, 1);\">;\n        height:40px;\n        display: flex;\n        padding: 4px </span><span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        box</span>-sizing: border-<span style=\"color: rgba(0, 0, 0, 1);\">box;\n    }\n    .topfixed .topNavBox .leftBtnBox{\n        flex: none;\n        background</span>-color: rgba(<span style=\"color: rgba(128, 0, 128, 1);\">0</span>,<span style=\"color: rgba(128, 0, 128, 1);\">0</span>,<span style=\"color: rgba(128, 0, 128, 1);\">0</span>,<span style=\"color: rgba(128, 0, 128, 1);\">0.7</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        display: flex;\n        height: 32px;\n        border</span>-<span style=\"color: rgba(0, 0, 0, 1);\">radius: 100px;\n    }\n    .topfixed .topNavBox .leftBtnBox .gobackBox{\n        padding: </span><span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\"> 25rpx;\n        display: flex;\n        align</span>-<span style=\"color: rgba(0, 0, 0, 1);\">items: center;\n        position: relative;\n    }\n    .topfixed .topNavBox .leftBtnBox .gobackBox.goHomeBox::before{\n        content: </span><span style=\"color: rgba(128, 0, 0, 1);\">''</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        width: 1px;\n        height: 20px;\n        position: absolute;\n        left: </span><span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        top: </span><span style=\"color: rgba(128, 0, 128, 1);\">50</span>%<span style=\"color: rgba(0, 0, 0, 1);\">;\n        margin</span>-top: -<span style=\"color: rgba(0, 0, 0, 1);\">10px;\n        background</span>-<span style=\"color: rgba(0, 0, 0, 1);\">color: #fff;\n    }\n    \n    \n    \n</span>&lt;/style&gt;</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">online.vue</span></div>\n<p>6.App.vue内容，<span style=\"color: rgba(255, 0, 0, 1);\">其中add_log方法是上传连接日志到服务器，请自行删除</span></p>\n<div class=\"cnblogs_code\">\n<pre>&lt;script&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n    import { connectMQTT, subscribeMQTT, publishMQTT, disconnectMQTT } </span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">@/common/mqtt.js</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    export </span><span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n\n        onLaunch: function() {\n            console.log(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">App Launch</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 初始化MQTT连接（全局生效）\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">this.initMqtt();</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            \n            \n        },\n        onShow: function() {\n            console.log(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">App Show</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 应用切前台时检查连接，断开则重连</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">var</span> xcx_zt = <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">.$store.state.xcx_zt; \n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">console.log(\"cccc\",xcx_zt)</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">xcx_zt) {\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">.initMqtt()\n            }\n        },\n        onHide: function() {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">console.log('App Hide');\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 应用切后台：可选断开连接（根据业务需求）</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">.disMqtt();\n        },\n        \n        methods:{\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 连接MQTT</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            initMqtt() {\n                console.log(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">eee</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> _this=<span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                connectMQTT((res) </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n                    \n                    console.log(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ffff</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>(res.code==<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">){\n                        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">创建日志</span>\n                        <span style=\"color: rgba(0, 0, 255, 1);\">this</span>.add_log(res.data).then((resolve, reject) =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n                        })\n                    }\n                })\n            },\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 断开连接MQTT</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            disMqtt() {\n                console.log(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">dddd</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> _this=<span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                disconnectMQTT((res) </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>(res.code==<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">){\n                        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">创建日志</span>\n                        <span style=\"color: rgba(0, 0, 255, 1);\">this</span>.add_log(res.data).then((resolve, reject) =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n                        })\n                    }\n                });                \n            },\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">连接日志</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">async</span> add_log(<span style=\"color: rgba(0, 0, 255, 1);\">params</span><span style=\"color: rgba(0, 0, 0, 1);\">){\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> _this=<span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                \n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Promise((resolve, reject) =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n                    let p_obj</span>=<span style=\"color: rgba(0, 0, 0, 1);\">{};\n                    p_obj.code</span>=<span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                    p_obj.msg</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">操作失败</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                    \n                    let user_info </span>= uni.getStorageSync(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">user_info</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                    let post_obj</span>=<span style=\"color: rgba(0, 0, 0, 1);\">{};\n                    post_obj.user_id</span>=<span style=\"color: rgba(0, 0, 0, 1);\">user_info.id;\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">小程序\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> #ifdef MP-WEIXIN</span>\n                    let openid=uni.getStorageSync(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">openid</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                    post_obj.openid</span>=<span style=\"color: rgba(0, 0, 0, 1);\">openid;\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> #endif</span>\n                    post_obj.keyword=<span style=\"color: rgba(0, 0, 255, 1);\">params</span><span style=\"color: rgba(0, 0, 0, 1);\">.keyword;\n                    post_obj.</span><span style=\"color: rgba(0, 0, 255, 1);\">params</span>=<span style=\"color: rgba(0, 0, 255, 1);\">params</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                    \n                    uni.$u.api.mqtt_log(post_obj).then(res </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n                        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>(res.code==<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">){\n                            p_obj.code</span>=<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                            p_obj.msg</span>=<span style=\"color: rgba(0, 0, 0, 1);\">res.msg;\n                            resolve(p_obj);\n                            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                            \n                        }</span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">{\n                            p_obj.code</span>=<span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                            p_obj.msg</span>=<span style=\"color: rgba(0, 0, 0, 1);\">res.msg;\n                            resolve(p_obj);\n                            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                        }\n                    })\n                })\n                \n            },\n        \n        }\n    }\n</span>&lt;/script&gt;\n\n&lt;style lang=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">scss</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n    <span style=\"color: rgba(0, 128, 0, 1);\">/*</span><span style=\"color: rgba(0, 128, 0, 1);\">每个页面公共css </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span>\n\n&lt;/style&gt;</pre>\n</div>\n<p>&nbsp;</p>\n<p>7.创建测试文件/pages/index/index.vue,<span style=\"color: rgba(255, 0, 0, 1);\">其中tabBar是我自定义的菜单组件，请自行删除</span></p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed lazyload\" id=\"code_img_closed_3a881bd7-c7b9-48f8-b163-236f6a93b4c0\" /><img class=\"code_img_opened lazyload\" id=\"code_img_opened_3a881bd7-c7b9-48f8-b163-236f6a93b4c0\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_3a881bd7-c7b9-48f8-b163-236f6a93b4c0\">\n<pre>&lt;template&gt;\n    &lt;view <span style=\"color: rgba(0, 0, 255, 1);\">class</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"\"</span>&gt;\n        &lt;view&gt;\n            &lt;online&gt;&lt;/online&gt;\n        &lt;/view&gt;\n        &lt;map style=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">width: 100%; height: 300px;</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> :latitude=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">latitude</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> :longitude=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">longitude</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> :style=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">'height:'+windowHeight*2+'rpx;'</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;\n            \n        &lt;/map&gt;\n        \n        &lt;view&gt;\n            &lt;tabBar :pageIndex=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">100</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> :textType=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">1</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> @toTab=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">toTab</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>&gt;&lt;/tabBar&gt;\n        &lt;/view&gt;\n    &lt;/view&gt;\n&lt;/template&gt;\n\n&lt;script&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n    import tabBar </span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">@/components/tabBar/tabBar.vue</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    import online </span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">@/components/online/online.vue</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>;<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">是否在线</span>\n    export <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n        components: {\n            tabBar,\n            online,</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">是否在线</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        },\n        data() {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                windowHeight : uni.getSystemInfoSync().windowHeight,</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">屏幕高度</span>\n                title: <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">Hello</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                latitude:</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">34.259428</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                longitude:</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">108.947040</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            }\n        },\n        onLoad() {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 隐藏默认菜单栏</span>\n            uni.hideTabBar({animation: <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">});\n        },\n\n        onShow() {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 隐藏默认菜单栏</span>\n            uni.hideTabBar({animation: <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">});\n        },\n        methods: {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">菜单跳转</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            toTab(item){\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">console.log(item);</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">var</span> id =item.id;<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">1购买记录 2扫码饮酒 3我的\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">扫码饮酒</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">if</span>(id==<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">){\n                    uni.navigateTo({\n                        url:</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">/pages_a/order/list</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> url:'/pages_a/pour/pouring'</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">                    })\n                }</span><span style=\"color: rgba(0, 0, 255, 1);\">else</span> <span style=\"color: rgba(0, 0, 255, 1);\">if</span>(id==<span style=\"color: rgba(128, 0, 128, 1);\">2</span><span style=\"color: rgba(0, 0, 0, 1);\">){\n                    uni.navigateTo({\n                        url:</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">/pages/sao/index?m_id=1</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>\n                        <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">url:'/pages/sao/index'</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">                    })\n                    \n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> uni.scanCode({\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">     scanType: ['qrCode'], </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">只支持二维码\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">     onlyFromCamera: true,\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">     success: function(res) {\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">         console.log('条码类型：' + res.scanType);\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">         console.log('条码内容：' + res.result);\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">     }\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> });</span>\n                }<span style=\"color: rgba(0, 0, 255, 1);\">else</span> <span style=\"color: rgba(0, 0, 255, 1);\">if</span>(id==<span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\">){\n                    uni.switchTab({\n                        url:</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">/pages/my/index</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                    })\n                }\n                \n            }\n        }\n    }\n</span>&lt;/script&gt;\n\n&lt;style&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n    .content {\n        display: flex;\n        flex</span>-<span style=\"color: rgba(0, 0, 0, 1);\">direction: column;\n        align</span>-<span style=\"color: rgba(0, 0, 0, 1);\">items: center;\n        justify</span>-<span style=\"color: rgba(0, 0, 0, 1);\">content: center;\n    }\n\n    .logo {\n        height: 200rpx;\n        width: 200rpx;\n        margin</span>-<span style=\"color: rgba(0, 0, 0, 1);\">top: 200rpx;\n        margin</span>-<span style=\"color: rgba(0, 0, 0, 1);\">left: auto;\n        margin</span>-<span style=\"color: rgba(0, 0, 0, 1);\">right: auto;\n        margin</span>-<span style=\"color: rgba(0, 0, 0, 1);\">bottom: 50rpx;\n    }\n\n    .text</span>-<span style=\"color: rgba(0, 0, 0, 1);\">area {\n        display: flex;\n        justify</span>-<span style=\"color: rgba(0, 0, 0, 1);\">content: center;\n    }\n\n    .title {\n        font</span>-<span style=\"color: rgba(0, 0, 0, 1);\">size: 36rpx;\n        color: #8f8f94;\n    }\n</span>&lt;/style&gt;</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">index.vue</span></div>\n<p>结果</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 23:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zhangyouwu\">zhang_you_wu</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "初识Tauri",
      "link": "https://www.cnblogs.com/-867259206/p/19463606",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/-867259206/p/19463606\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 23:24\">\n    <span>初识Tauri</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简述\">简述</h1>\n<p>Tauri是一个跨平台的开发框架，使用rust开发。前端用前端技术构建用户界面，后端使用rust和平台系统交互。</p>\n<h2 id=\"创建项目\">创建项目</h2>\n<p>可以用Bash/PowerShell/Fish/npm/deno/Cargo等工具创建项目。</p>\n<p>下面以pnpm示例：</p>\n<pre><code class=\"language-bash\">pnpm create tauri-app\n</code></pre>\n<p>后面的步骤和创建前端项目是一样的。根据提示选择前端的语言、框架等等。</p>\n<p>项目目录和前端项目也是一样的，只是多了一个src-tauri目录。</p>\n<p>src-tauri目录下就是rust代码，可以在里面编写供前端调用的方法，或者是给前端发送事件消息。</p>\n<p>界面的开发使用前端技术，可以用react，也可以用vue，或者其他前端框架。与平台系统交互的功能，用rust编写。</p>\n<p>对Web开发者来说，用这个技术可以快速地创建桌面应用。</p>\n<h2 id=\"发布\">发布</h2>\n<p>要打包成桌面应用的话，执行build命令就好。</p>\n<p>继续以pnpm为例：</p>\n<pre><code class=\"language-bash\">pnpm tauri build\n</code></pre>\n<blockquote>\n<p>提示：build之前要先安装rust环境</p>\n</blockquote>\n<p>目前Tauri支持Linux、macOS、Windows、Android、iOS。</p>\n<p>打包后的启动程序在src-tauri/target/release/bundle目录下。执行安装程序，安装好后，就可以打开编写的桌面应用了。</p>\n<h1 id=\"架构\">架构</h1>\n<p><img alt=\"架构\" class=\"lazyload\" />Tauri的核心包含一个Tauri的运行时，tauri-runtime在tauri本身和底层的webview抽象层中充当一个胶水层。</p>\n<p>Tauri使用WRY这个开源库做webview的抽象层。WRY是一个rust编写的webview渲染库，可以支持各种平台的桌面应用。在WRY和tauri-runtime之间，有一个tauri-runtime-wry，这一层为WRY定义了系统级的交互。</p>\n<p>而WRY的下层依赖TAO。TAO是基于winit的一个fork。这是一个rust编写的跨平台的窗口管理类库。支持几乎所有的主流平台，Windows、Linux、Mac OS、Android、iOS……</p>\n<p>最后简单总结：Tauri实现跨平台应用的方式是，实现一个webview的抽象，从而可以用前端技术编写GUI，webview抽象层的底层，则依赖rust的窗口管理类库，调用各个平台系统的webview库。</p>\n<h1 id=\"总结\">总结</h1>\n<p>用rust作后端，使Tauri有很高的性能。但是调用平台系统本身webview的跨平台方式，使GUI在不同平台上的表现不一致，有兼容性问题。</p>\n<p>和electron相比，拥有更小的包体积，因为没有打包chromium，也没有源码泄露之类的风险，性能也更好，还能打包移动端，但是会有兼容性问题，而且后端用rust的话，不如electron好上手，如果不是rust熟手的话。</p>\n<p>和flutter相比，同样有兼容性问题，dart也比rust好学。</p>\n<p>对rust开发者来说，只需要找rust的GUI库就行，没有必要去用前端编写GUI。而对前端开发者来说，rust又增加了开发的学习成本。这个框架，感觉只适合同时会rust的前端熟手。而且只有少数对性能要求较高的场景会需要使用，其他场景electron也不差。如果要开发跨平台的应用，兼容性又是一个问题。实际的产品表现，肯定不如flutter这类框架。</p>\n<p>在前端工具链也越来越多使用rust语言的时候，Tauri这些rust编写的框架也被一些前端开发者所使用。但如果我要开发一个跨平台的应用的话，我觉得自带绘图库的flutter的方案是最佳的。Tauri的兼容性问题，仍不能满足做商业应用的要求，能使用的场景太少了。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 23:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/-867259206\">池月</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款基于 .NET 9 构建的企业级 Web RBAC 快速开发框架",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19463583",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19463583\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 23:03\">\n    <span>一款基于 .NET 9 构建的企业级 Web RBAC 快速开发框架</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>今天大姚给大家分享一款基于 .NET 9 构建的企业级、开源 Web RBAC 快速开发框架：RuYiAdmin。</span></p>\n<h2><span>项目介绍</span></h2>\n<p><span>RuYiAdmin 一款基于 .NET 9 构建的企业级、前后端分离、开源（Apache License） Web RBAC 快速开发框架，具有灵活的架构设计和强大的功能，适用于快速开发高性能的企业级应用，具有低代码、跨平台、分布式、多线程和高性能等特色。</span></p>\n<h2><span>适用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><span>企业级后台管理系统：用于企业内部的各种管理任务，如用户管理、权限控制、数据统计等。</span></li>\n<li><span>内容管理系统（CMS）：用于网站内容的创建、编辑、发布和管理。</span></li>\n<li><span>客户关系管理（CRM）系统：帮助企业跟踪和管理客户信息、销售机会和客户服务请求。</span></li>\n</ul>\n<h2><span>主要特点</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>前后端分离：</strong><span>&nbsp;RuYiAdmin 采用前后端分离架构，前端基于VueElementAdmin，使用 Vue2 和 Element UI，后端基于 .NET 9 构建。</span></li>\n<li><strong>代码自动生成：</strong><span>&nbsp;支持一键生成视图层、控制层、服务层、仓储层、领域层和 DTO 业务模型层代码，极大地缩短了开发周期。</span></li>\n<li><strong>多数据库支持：</strong><span>&nbsp;支持多种关系型数据库（如 MySQL、SqlServer、SQLite、Oracle、PostgreSQL、OpenGauss、<span>Kingbase、DM）和非关系型数据库（如 Redis、MongoDB、Elasticsearch、Meilisearch），同时支持动态数据源，以满足不同企业的需求。</span></span></li>\n<li><strong>项目安全性高：</strong><span>&nbsp;支持4A等级认证，满足等保三级要求，支持防 SQL 注入、防 Token 劫持、防接口渗透与抖动，集成RSA、AES及国产 SM 加密算法，支持全链路HTTPS加密传输协议，确保企业级应用的安全性。</span></li>\n<li><span>支持微服务，支持服务的注册、发现、健康检查、熔断和降级。</span></li>\n</ul>\n<h2><span>项目技术栈</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><span>前端：Vue2、Element UI、Node.js等。</span></li>\n<li><span>后端：C#、.NET 9、AspNetCoreRateLimit、<span>SqlSugar、AutoMapper、SignalR、MiniProfiler、CAP、RabbitMQ、Redis、Consul等。</span></span></li>\n</ul>\n<h2><span>安装教程</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109225902010-549085141.png\" /></p>\n<h2><span>软件架构图</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109225914600-2077383226.png\" /></p>\n<h2><span>项目源代码</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230143000-1636008500.png\" /></p>\n<h2><span>项目效果截图</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230153456-1478242349.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230157723-87615533.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230203615-1395111698.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230210957-1745363029.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230216437-1329007995.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230222905-1152283619.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230230693-1691017440.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205853857-1849985119.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205859134-1945950810.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230248378-53584818.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230253718-384227715.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205908099-602806087.png\" /></p>\n<h2><span>项目源码地址</span></h2>\n<p><span>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/pang-mingjun/RuYiAdmin\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/pang-mingjun/RuYiAdmin</span></a></li>\n</ul>\n<h2><span>优秀项目和框架精选</span></h2>\n<p><span>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong><span>）。</span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>GitHub开源地址：</strong><a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n</ul>\n<div id=\"gtx-trans\">&nbsp;</div>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 23:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Flink源码阅读：Task数据交互",
      "link": "https://www.cnblogs.com/Jackeyzhe/p/19463278",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Jackeyzhe/p/19463278\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 20:11\">\n    <span>Flink源码阅读：Task数据交互</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Flink源码阅读：Task数据交互\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1828322/202601/1828322-20260109201055245-933532869.png\" />\n        经过前面的学习，Flink 的几个核心概念相关的源码实现我们已经了解了。本文我们来梳理 Task 的数据交互相关的源码。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>经过前面的学习，Flink 的几个核心概念相关的源码实现我们已经了解了。本文我们来梳理 Task 的数据交互相关的源码。</p>\n<h3 id=\"数据输出\">数据输出</h3>\n<p>话不多说，我们直接进入正题。首先来看 Task 的数据输出，在进入流程之前，我们先介绍几个基本概念。</p>\n<h4 id=\"基本概念\">基本概念</h4>\n<ul>\n<li>\n<p>RecordWriterOutput：它是 Output 接口的一个具体实现类，底层使用 RecordWriter 来发送数据。</p>\n</li>\n<li>\n<p>RecordWriter：数据写入的执行者，负责将数据写到 ResultPartition。</p>\n</li>\n<li>\n<p>ResultPartition 和 ResultSubpartition：ResultPartition 是 ExecutionGraph 中一个节点的输出结果，下游的每个需要从当前 ResultPartition 消费数据的 Task 都会有一个 ResultSubpartition。</p>\n</li>\n<li>\n<p>ChannelSelector：用来决定一个 Record 要被写到哪个 Subpartition 中。</p>\n</li>\n<li>\n<p>LocalBufferPool：用来管理 Buffer 的缓冲池。在介绍反压的原理时，我们提到过。</p>\n</li>\n</ul>\n<p>对这些基本概念有了一定的了解之后，我们来看数据输出的具体流程。</p>\n<h4 id=\"执行流程\">执行流程</h4>\n<p>我们以 map 为例，看一下数据的输出过程。</p>\n<p><img alt=\"DataOutput\" class=\"lazyload\" /></p>\n<p>在 <code>StreamMap.processElement</code> 方法中，调用完 map 方法之后，就会调用 <code>output.collect</code> 方法将数据输出，这里的 output 就是 RecordWriterOutput。在 RecordWriterOutput 中，会调用 RecordWriter 的 emit 方法。</p>\n<pre><code class=\"language-java\">private &lt;X&gt; void pushToRecordWriter(StreamRecord&lt;X&gt; record) {\n    serializationDelegate.setInstance(record);\n\n    try {\n        recordWriter.emit(serializationDelegate);\n    } catch (IOException e) {\n        throw new UncheckedIOException(e.getMessage(), e);\n    }\n}\n</code></pre>\n<p>这里的 serializationDelegate 是用来对 record 进行序列化的。RecordWriter 有两个实现类，一个是 ChannelSelectorRecordWriter，另一个是 BroadcastRecordWriter。ChannelSelectorRecordWriter 需要先调用 ChannelSelector 选择对应的 subparition，然后进行写入。BroadcastRecordWriter 则是写到所有的 subparition。</p>\n<p>接下来就是调用 <code>BufferWritingResultPartition.emitRecord</code> 来写入数据。</p>\n<pre><code class=\"language-java\">public void emitRecord(ByteBuffer record, int targetSubpartition) throws IOException {\n    totalWrittenBytes += record.remaining();\n\n    BufferBuilder buffer = appendUnicastDataForNewRecord(record, targetSubpartition);\n\n    while (record.hasRemaining()) {\n        // full buffer, partial record\n        finishUnicastBufferBuilder(targetSubpartition);\n        buffer = appendUnicastDataForRecordContinuation(record, targetSubpartition);\n    }\n\n    if (buffer.isFull()) {\n        // full buffer, full record\n        finishUnicastBufferBuilder(targetSubpartition);\n    }\n\n    // partial buffer, full record\n}\n</code></pre>\n<p>这里把 record 写入到 buffer 中，如果 buffer 不够，则会从 LocalBufferPool 中申请新的 buffer，申请到之后就会继续写入。下面是具体的申请过程。</p>\n<pre><code class=\"language-java\">private MemorySegment requestMemorySegment(int targetChannel) {\n    MemorySegment segment = null;\n    synchronized (availableMemorySegments) {\n        checkDestroyed();\n\n        if (!availableMemorySegments.isEmpty()) {\n            segment = availableMemorySegments.poll();\n        } else if (isRequestedSizeReached()) {\n            // Only when the buffer request reaches the upper limit(i.e. current pool size),\n            // requests an overdraft buffer.\n            segment = requestOverdraftMemorySegmentFromGlobal();\n        }\n\n        if (segment == null) {\n            return null;\n        }\n\n        if (targetChannel != UNKNOWN_CHANNEL) {\n            if (++subpartitionBuffersCount[targetChannel] == maxBuffersPerChannel) {\n                unavailableSubpartitionsCount++;\n            }\n        }\n\n        checkAndUpdateAvailability();\n    }\n    return segment;\n}\n</code></pre>\n<p>如果有可用内存，就直接从队列中出队。如果达到了本地 BufferPool 的上限，就从全局的 NetworkBufferPool 中申请，申请不到就会阻塞写入过程，等待申请。最后还会检查并更新可用内存状态。</p>\n<p>有了可用的 buffer 之后，就会调用 addToSubpartition，最终数据存储在 PipelinedSubpartition 的 buffers 队列中。</p>\n<pre><code class=\"language-java\">private void addToSubpartition(\n        BufferBuilder buffer,\n        int targetSubpartition,\n        int partialRecordLength,\n        int minDesirableBufferSize)\n        throws IOException {\n    int desirableBufferSize =\n            subpartitions[targetSubpartition].add(\n                    buffer.createBufferConsumerFromBeginning(), partialRecordLength);\n\n    resizeBuffer(buffer, desirableBufferSize, minDesirableBufferSize);\n}\n</code></pre>\n<h3 id=\"数据输入\">数据输入</h3>\n<p>看完了数据输出的过程之后，我们再来看一下数据输入的过程。首先还是了解几个基本概念。</p>\n<h4 id=\"基本概念-1\">基本概念</h4>\n<ul>\n<li>\n<p>InputGate：InputGate 是对输入的封装，与 JobGraph 中的 JobEdge 一一对应，每个 InputGate 消费上游一个或多个 Resultpartition。</p>\n</li>\n<li>\n<p>InputChannel：InputChannel 是和 ExecutionGraph 中的 ExecutionEdge 一一对应的。每个 InputChannel 接收一个 ResultSubpartition 的输出，InputChannel 主要关注 LocalInputChannel 和 RemoteInputChannel 两种实现。</p>\n</li>\n</ul>\n<h4 id=\"执行流程-1\">执行流程</h4>\n<p>了解了具体概念之后，我们再看数据输入的具体流程。</p>\n<p><img alt=\"RecordInput\" class=\"lazyload\" /></p>\n<p>数据输入的入口是 <code>StreamTask.processInput</code> 方法，这个方法中主要是调用 <code>inputProcessor.processInput</code> 方法，我们以 StreamOneInputProcessor 为例。这个方法就是调用 <code>input.emitNext</code> 方法。</p>\n<pre><code class=\"language-java\">public DataInputStatus emitNext(DataOutput&lt;T&gt; output) throws Exception {\n\n    while (true) {\n        // get the stream element from the deserializer\n        if (currentRecordDeserializer != null) {\n            RecordDeserializer.DeserializationResult result;\n            try {\n                result = currentRecordDeserializer.getNextRecord(deserializationDelegate);\n            } catch (IOException e) {\n                throw new IOException(\n                        String.format(\"Can't get next record for channel %s\", lastChannel), e);\n            }\n            if (result.isBufferConsumed()) {\n                currentRecordDeserializer = null;\n            }\n\n            if (result.isFullRecord()) {\n                final boolean breakBatchEmitting =\n                        processElement(deserializationDelegate.getInstance(), output);\n                if (canEmitBatchOfRecords.check() &amp;&amp; !breakBatchEmitting) {\n                    continue;\n                }\n                return DataInputStatus.MORE_AVAILABLE;\n            }\n        }\n\n        Optional&lt;BufferOrEvent&gt; bufferOrEvent = checkpointedInputGate.pollNext();\n        if (bufferOrEvent.isPresent()) {\n            // return to the mailbox after receiving a checkpoint barrier to avoid processing of\n            // data after the barrier before checkpoint is performed for unaligned checkpoint\n            // mode\n            if (bufferOrEvent.get().isBuffer()) {\n                processBuffer(bufferOrEvent.get());\n            } else {\n                DataInputStatus status = processEvent(bufferOrEvent.get(), output);\n                if (status == DataInputStatus.MORE_AVAILABLE &amp;&amp; canEmitBatchOfRecords.check()) {\n                    continue;\n                }\n                return status;\n            }\n        } else {\n            if (checkpointedInputGate.isFinished()) {\n                checkState(\n                        checkpointedInputGate.getAvailableFuture().isDone(),\n                        \"Finished BarrierHandler should be available\");\n                return DataInputStatus.END_OF_INPUT;\n            }\n            return DataInputStatus.NOTHING_AVAILABLE;\n        }\n    }\n}\n</code></pre>\n<p>这里是调用 <code>checkpointedInputGate.pollNext</code> 来获取输入的数据。它的内部就是调用 InputGate 的 pollNext 方法来获取数据。当获取到完整数据之后，就会调用 processElement 来处理数据。</p>\n<p>我们以 SingleInputGate 为例看 InputGate 的 pollNext 方法。它的内部调用链路可用一直追踪到 readBufferFromInputChannel 方法，这个方法内会调用 <code>inputChannel.getNextBuffer</code>，这里交给 InputChannel 来具体执行数据读取。</p>\n<pre><code class=\"language-java\">public Optional&lt;BufferAndAvailability&gt; getNextBuffer() throws IOException {\n    checkError();\n\n    if (!toBeConsumedBuffers.isEmpty()) {\n        return getBufferAndAvailability(toBeConsumedBuffers.removeFirst());\n    }\n\n    ResultSubpartitionView subpartitionView = this.subpartitionView;\n    if (subpartitionView == null) {\n        // There is a possible race condition between writing a EndOfPartitionEvent (1) and\n        // flushing (3) the Local\n        // channel on the sender side, and reading EndOfPartitionEvent (2) and processing flush\n        // notification (4). When\n        // they happen in that order (1 - 2 - 3 - 4), flush notification can re-enqueue\n        // LocalInputChannel after (or\n        // during) it was released during reading the EndOfPartitionEvent (2).\n        if (isReleased) {\n            return Optional.empty();\n        }\n\n        // this can happen if the request for the partition was triggered asynchronously\n        // by the time trigger\n        // would be good to avoid that, by guaranteeing that the requestPartition() and\n        // getNextBuffer() always come from the same thread\n        // we could do that by letting the timer insert a special \"requesting channel\" into the\n        // input gate's queue\n        subpartitionView = checkAndWaitForSubpartitionView();\n    }\n\n    BufferAndBacklog next = subpartitionView.getNextBuffer();\n    // ignore the empty buffer directly\n    while (next != null &amp;&amp; next.buffer().readableBytes() == 0) {\n        next.buffer().recycleBuffer();\n        next = subpartitionView.getNextBuffer();\n        numBuffersIn.inc();\n    }\n\n    if (next == null) {\n        if (subpartitionView.isReleased()) {\n            throw new CancelTaskException(\n                    \"Consumed partition \" + subpartitionView + \" has been released.\");\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    Buffer buffer = next.buffer();\n\n    if (buffer instanceof FullyFilledBuffer) {\n        List&lt;Buffer&gt; partialBuffers = ((FullyFilledBuffer) buffer).getPartialBuffers();\n        int seq = next.getSequenceNumber();\n        for (Buffer partialBuffer : partialBuffers) {\n            toBeConsumedBuffers.add(\n                    new BufferAndBacklog(\n                            partialBuffer,\n                            next.buffersInBacklog(),\n                            buffer.getDataType(),\n                            seq++));\n        }\n\n        return getBufferAndAvailability(toBeConsumedBuffers.removeFirst());\n    }\n\n    return getBufferAndAvailability(next);\n}\n</code></pre>\n<p>我们先来看 LocalInputChannel，先获取到了 subpartitionView，并调用 getNextBuffer，这里其实就是从 PipelinedSubpartition 的 buffers 队列中读取数据。</p>\n<p>RemoteInputChannel 则需要从 receivedBuffers 中读取数据，这个队列的数据就是消费上游数据后保存的。</p>\n<p>至此，Flink 中 Task 的数据输入和输出过程的源码就梳理完了，更加底层的 Netty 相关代码我们在后面继续梳理。</p>\n<h3 id=\"总结\">总结</h3>\n<p>最后简单总结一下，本文我们梳理了 Task 的数据输出和输入的过程。输出过程主要是利用 RecordWriter 将数据写入到 Buffer 中，输入过程则是利用 InputChannel 从 Buffer 消费的过程。如果你的 Flink 任务数据量特别大，并且没什么复杂的逻辑，可以考虑适当调整 localBufferPool 的大小来调优任务的吞吐。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 20:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Jackeyzhe\">Jackeyzhe</a>&nbsp;\n阅读(<span id=\"post_view_count\">14</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "公众号推荐机制整理：科技号怎么把社交流量做起来",
      "link": "https://www.cnblogs.com/reachteam/p/19463233",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/reachteam/p/19463233\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 19:39\">\n    <span>公众号推荐机制整理：科技号怎么把社交流量做起来</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>01 背景</h1>\n<p><span>最近我们软件团队参加了一个高校关于公众号运营的分享，听完挺有启发，所以把重点整理成一篇笔记，发出来给大家参考。</span></p>\n<p><span>从 2023 年开始，公众号的分发不再只是订阅推送那一套了，现在更像是社交信号 + 算法推荐一起在发力。有数据提到，2025 年某科技/软件小号通过社交推荐拿到的流量占比已经到 45.9%，甚至超过了传统订阅推送。</span></p>\n<p><span>所以这篇文章想解决的就一件事：</span></p>\n<p><span>科技号到底要怎么写，才能更容易被推荐，也更容易被转发。</span></p>\n<p><span>下面按 6 个方向讲清楚：技术逻辑、关键指标、分发流程、账号差异、演进变化、案例和可操作建议。</span></p>\n<h2><span>02 推荐系统大概怎么跑</span></h2>\n<h3><span>2.1 三类信号最重要</span></h3>\n<p><span>2025 年之后，公众号的推荐更强调三类信号一起看：</span></p>\n<p><span>1. 社交关系：朋友看过、转发、在看等</span></p>\n<p><span>2. 兴趣标签：你是什么人群，内容是什么主题</span></p>\n<p><span>3. 行为数据：点击、停留、完读、滑动速度、点赞发生在什么时候</span></p>\n<p><span>系统会先从内容里提取关键词，再结合用户行为更新画像，最后决定给谁更多曝光。可以把它理解成一个循环：先曝光一小波，看反馈，再决定要不要继续给量。</span></p>\n<p><span>另外有一点很关键，文章发出去之后通常 1 到 3 分钟内就会做一轮质量评估，主题价值、逻辑结构、原创性、以及 AI 生成痕迹这些都会被综合判断。</span></p>\n<h3><span>2.2 指标权重长什么样</span></h3>\n<p><span>先把大盘放在这。数字是研究整理口径，大家看趋势和重点就行。</span></p>\n<p><span>表 1：公众号算法核心权重分配</span></p>\n<table>\n<thead>\n<tr><th><span>权重维度</span></th><th><span>具体指标</span></th><th><span>权重占比</span></th><th><span>关键阈值（示例）</span></th></tr>\n</thead>\n<tbody>\n<tr>\n<td><span>社交传播系数</span></td>\n<td><span>好友推荐率、转发到朋友圈/社群次数、跨圈层传播深度</span></td>\n<td><span>35%</span></td>\n<td><span>社交推荐流量占比 ≥ 45%</span></td>\n</tr>\n<tr>\n<td><span>内容质量因子</span></td>\n<td><span>完读率（≥65%）、平均阅读时长（≥2 分钟）、原创度（3 倍权重）</span></td>\n<td><span>30%</span></td>\n<td><span>完读率 ≥ 50%</span></td>\n</tr>\n<tr>\n<td><span>用户行为画像</span></td>\n<td><span>点击率、滑动速度、点赞时间点等微观行为</span></td>\n<td><span>20%</span></td>\n<td><span>点击率 ≥ 15%</span></td>\n</tr>\n<tr>\n<td><span>账号信誉体系</span></td>\n<td><span>更新频率、违规记录、用户投诉率</span></td>\n<td><span>10%</span></td>\n<td><span>日更可提升 300% 初始推荐</span></td>\n</tr>\n<tr>\n<td><span>实时流量博弈</span></td>\n<td><span>15 分钟动态调整</span></td>\n<td><span>5%</span></td>\n<td><span>冷启动期点击率 &gt; 8%</span></td>\n</tr>\n</tbody>\n</table>\n<p><span>另外还有一组常见拆分口径：打开率大概占 40%，互动率（赞/在看/收藏）占 30%，分享率占 20%，完读率占 10%。</span></p>\n<p><span>提醒两点：</span></p>\n<p><span>1. 原创的推荐权重会更高（研究口径里提到是转载的 3 倍）</span></p>\n<p><span>2. 认证类型也会影响权重（政府 &gt; 媒体 &gt; 企业 &gt; 个体），认证账号在搜索里更容易拿到靠前曝光</span></p>\n<h3><span>2.3 这几年分发怎么变了</span></h3>\n<p><span>简单按阶段捋一下：</span></p>\n<p><span>1. 2013 到 2017：订阅为主，关注就能收到</span></p>\n<p><span>2. 2017 到 2020：开始引入社交推荐，看一看等入口出现</span></p>\n<p><span>3. 2020 到 2023：算法推荐逐步变强，开始推荐未关注内容</span></p>\n<p><span>4. 2023 至今：社交 + 算法双驱动更明显，朋友相关入口的权重变高</span></p>\n<h2><span>03 流量池赛马：文章为啥会突然爆</span></h2>\n<h3><span>3.1 冷启动那一关很关键</span></h3>\n<p><span>文章发出去之后，通常会先拿到一小波测试曝光（比如 500 到 1000 次），系统主要看三项：点击率、完读率、互动率。</span></p>\n<p><span>研究里给了一些常见阈值做参考：</span></p>\n<p><span>1. 冷启动期（0 到 24 小时）点击率要能到 8% 以上，更可能进下一层</span></p>\n<p><span>2. 进入爆发期后，完读率最好能维持 55% 以上，互动率 3% 以上</span></p>\n<h3><span>3.2 多轮推荐不是一次性给完</span></h3>\n<p><span>通过第一轮测试后，会有二次、三次甚至更多轮的推荐，每一轮曝光量会变大。</span></p>\n<p><span>另外系统会按 15 分钟一轮动态调整流量，所以同一篇文章的数据会一直变化。阅读量到 1 万这个量级后，有时还会触发人工审核。</span></p>\n<h3><span>3.3 社交扩散会带来放大</span></h3>\n<p><span>当用户点在看或者转发，文章就会沿着社交网络扩散。有账号的数据里，朋友相关入口贡献的阅读量能到 45.9%。</span></p>\n<p><span>比较容易触发分享的原因一般是这三类：</span></p>\n<p><span>1. 内容本身有社交价值（共鸣、实用、话题性）</span></p>\n<p><span>2. 文中写清楚分享动机（比如转给同事、转给同学、转给群里谁）</span></p>\n<p><span>3. 内容适配分享场景（工作群、同学群、行业群能用得上）</span></p>\n<h3><span>3.4 公域入口也很重要</span></h3>\n<p><span>表 2：公众号主要流量来源分布</span></p>\n<table>\n<thead>\n<tr><th><span>流量来源</span></th><th><span>占比</span></th><th><span>特点</span></th></tr>\n</thead>\n<tbody>\n<tr>\n<td><span>推荐流量</span></td>\n<td><span>54.5%</span></td>\n<td><span>算法推荐为主</span></td>\n</tr>\n<tr>\n<td><span>公众号消息</span></td>\n<td><span>16.52%</span></td>\n<td><span>订阅用户</span></td>\n</tr>\n<tr>\n<td><span>公众号主页</span></td>\n<td><span>13.17%</span></td>\n<td><span>主动访问</span></td>\n</tr>\n<tr>\n<td><span>搜一搜</span></td>\n<td><span>10.44%</span></td>\n<td><span>精准搜索</span></td>\n</tr>\n<tr>\n<td><span>聊天会话</span></td>\n<td><span>2.88%</span></td>\n<td><span>私域分享</span></td>\n</tr>\n<tr>\n<td><span>朋友圈</span></td>\n<td><span>0.96%</span></td>\n<td><span>朋友圈分享</span></td>\n</tr>\n<tr>\n<td><span>朋友推荐</span></td>\n<td><span>0.12%</span></td>\n<td><span>好友直接推荐</span></td>\n</tr>\n</tbody>\n</table>\n<p><span>补充两点：</span></p>\n<p><span>1. 看一看是很重要的公域入口，爆款里看一看占比能到 60% 到 70%</span></p>\n<p><span>2. 搜一搜占比大概 10.44%，标题关键词做得好，搜索流量占比也可能很可观</span></p>\n<h2><span>04 不同账号的差异</span></h2>\n<h3><span>4.1 认证和账号信誉</span></h3>\n<p><span>认证类型会影响权重和信任（政府 &gt; 媒体 &gt; 企业 &gt; 个体）。</span></p>\n<p><span>同时也会看这些：注册时间、违规记录、粉丝活跃度（常读用户）、更新频率（发文多且原创占比高更占优）。</span></p>\n<h3><span>4.2 新号和老号不一样</span></h3>\n<p><span>新号一般会有观察期，初期曝光可能比较小，平台会先判断你是不是稳定的正常创作者，标签清不清晰，内容合不合规。</span></p>\n<p><span>老号因为画像积累更完整，推荐更容易精准，但长期不活跃或者质量下滑也可能被降权。</span></p>\n<h3><span>4.3 垂直领域更吃香，但别乱跑</span></h3>\n<p><span>科技、教育等垂直领域在品类里可能更容易拿到倾斜，但前提是定位足够细，内容持续垂直输出，并且用合集、标签等方式强化识别。</span></p>\n<h2><span>05 科技号怎么做更容易起量</span></h2>\n<p><span>我更建议把指标当成门槛，而不是当 KPI。</span></p>\n<h3><span>5.1 标题先把点击率顶起来</span></h3>\n<p><span>标题可以用一个比较稳的结构：痛点场景 + 数据背书 + 情绪共鸣。</span></p>\n<p><span>示例（按你们账号方向替换即可）：</span></p>\n<p><span>1. 我把电脑变快了，3 个 Windows 设置立刻见效</span></p>\n<p><span>2. 别再被钓鱼了，校园/企业邮箱最常见的 5 种诈骗</span></p>\n<p><span>3. 从 0 到 1，用 10 分钟搭好一个自动化报表流程</span></p>\n<h3><span>5.2 内容结构要照顾完读</span></h3>\n<p><span>一个比较好用的写法是：开头直接给结论，中间保持信息密度（大概每 300 字一个关键点），结尾给行动建议或提问，引导评论/收藏/转发。</span></p>\n<h3><span>5.3 原创是底盘</span></h3>\n<p><span>研究里提到原创度建议大于 70%。如果用 AI 做辅助，也建议把比例和用途说清楚，避免被系统误判成低质。</span></p>\n<h3><span>5.4 把可转发写进正文</span></h3>\n<p><span>文章 25% / 50% / 75% 的位置，可以顺手加一句话，告诉读者这段适合转给谁。</span></p>\n<p><span>比如：这份排查清单转给 IT 同事/同学；这段设置转到群里，大家少踩坑。</span></p>\n<h3><span>5.5 发出去后的 2 小时别浪费</span></h3>\n<p><span>冷启动数据很关键，建议发文后马上用种子用户扩散一波（社群、同事群、同学群），先把点击、完读、互动跑起来。</span></p>\n<h3><span>5.6 每周就盯 3 个指标</span></h3>\n<p><span>1. 社交推荐流量占比（目标值可参考 45%）</span></p>\n<p><span>2. 菜单栏点击量（能看出互动深度）</span></p>\n<p><span>3. 48 小时互动率（能看出内容即时影响力）</span></p>\n<p><span>另外标题、封面、开头段落都可以做小范围 A/B 测试，找最合适的组合。</span></p>\n<h2><span>06 案例给我们的提示</span></h2>\n<p><span>这里列几个研究里的典型现象，主要看规律：</span></p>\n<p><span>1. 有文章阅读 48 万，看一看贡献 60%</span></p>\n<p><span>2. 有新号粉丝不多，单篇 10 万+，看一看贡献 98%</span></p>\n<p><span>3. 有病毒传播案例，第 1 天 500+，第 2 天 1 万+，第 3 天朋友圈刷屏</span></p>\n<p><span>共同点其实很朴素：冷启动过关，社交扩散被点燃，内容质量能撑住完读和互动。</span></p>\n<h2><span>07 风险和合规别踩坑</span></h2>\n<p><span>常见误区：</span></p>\n<p><span>1. 追热点但和定位不搭，容易白忙</span></p>\n<p><span>2. 依赖刷量，平台有无效流量排查，风险很高</span></p>\n<p><span>3. 只要曝光不要质量，完读率掉得很快，推荐也会很快停</span></p>\n<p><span>合规方面：</span></p>\n<p><span>1. 原创度尽量做到 70% 以上</span></p>\n<p><span>2. 标题和正文做敏感词扫描，少用绝对化、夸大化表述</span></p>\n<p><span>3. 图片素材注意版权，用 CC0 站点或者合规二创</span></p>\n<h2><span>08 总结</span></h2>\n<p><span>一句话总结：公众号现在是社交信号 + 算法推荐一起在跑，科技号想起量，核心还是三件事：冷启动数据过关、内容更容易被转发、长期坚持原创和垂直。</span></p>\n<p><span>如果你只想先做最小改动，建议从这 3 个开始：</span></p>\n<p><span>1. 发文后 0 到 2 小时，把点击率、完读率、互动率先跑起来</span></p>\n<p><span>2. 把清单、步骤、排错流程写得更可截图转发，顺手写清楚转给谁</span></p>\n<p><span>3. 连续做一个细分方向（比如校园网络安全、系统使用指南、办公效率），让标签稳定下来</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 19:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/reachteam\">H5开发技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">28</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "EF Core自定义映射PostgreSQL原生函数",
      "link": "https://www.cnblogs.com/netry/p/19452236/efcore_jsonb_extract_path_text_in_postgredb",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/netry/p/19452236/efcore_jsonb_extract_path_text_in_postgredb\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 15:09\">\n    <span>EF Core自定义映射PostgreSQL原生函数</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"背景\">背景</h1>\n<p>在 ASP.NET Core 应用开发中，使用 PostgreSQL的<code>jsonb</code>类型存储多语言数据是一种常见的方案。这种方式相比传统的多列存储或独立翻译表，在模式定义上更加灵活。</p>\n<p>例如，对于一个包含多语言简介的“艺术家”实体，我们通常如下定义：</p>\n<pre class=\"language-cs\"><code class=\"language-cs\">public class ArtistEntity \n{\n    public int Id { get; set; }\n\n    // 使用 jsonb 存储多语言字典：Key=语言代码(en, zh-CN), Value=内容\n    [Column(TypeName = \"jsonb\")] \n    public Dictionary&lt;string, string&gt; Biography { get; set; } = [];\n}</code></pre><h1 id=\"性能考量\">性能考量</h1>\n<p>虽然存储方便，但在读取时会面临流量和性能问题。在大多数业务场景中，前端仅需要展示当前用户语言（如英语）的内容。如果直接查询实体，EF Core会将包含所有语言的JSONB对象完整加载到内存中。对于包含几十种语言的长文本字段，这不仅浪费数据库 I/O，也增加了网络传输开销。</p>\n<p>尝试使用EF Core的字典索引器语法：</p>\n<pre class=\"language-cs\"><code class=\"language-cs\">// 期望生成的 SQL 是直接取值\nvar bio = context.Artists.Select(x =&gt; x.Biography[\"en\"]).FirstOrDefault();</code></pre><p>根据 <a href=\"https://www.npgsql.org/efcore/mapping/json.html?tabs=data-annotations%2Ccomplex-types%2Cjsondocument\" rel=\"noopener nofollow\" target=\"_blank\" title=\"Npgsql EF Core Provider\">Npgsql EF Core Provider</a> 文档，虽然 Provider 提供了如<code>EF.Functions.JsonContains</code>、<code>EF.Functions.JsonExists</code>等丰富的 JSONB 操作函数，但在处理 Dictionary 索引器的投影翻译时仍存在局限性。在某些复杂的 Select 投影中，它可能无法生成最优的<code> -&gt;&gt;</code> 操作符，或者导致查询在客户端求值。</p>\n<p>目前Npgsql的<code>EF.Functions</code>中并没有直接对应<code>jsonb_extract_path_text</code>的方法，而这个原生函数恰恰是解决此类需求最直接的方式。它能在数据库服务端完成解析，仅返回指定路径的文本值。</p>\n<h1 id=\"什么是-jsonb_extract_path_text\">什么是 jsonb_extract_path_text？</h1>\n<p><code>jsonb_extract_path_text</code>是PostgreSQL的原生函数（等同于操作符 <code>#&gt;&gt;</code>），专门用于从 JSON 数据中根据路径提取文本。</p>\n<p>相比于直接返回 JSON 对象，它能直接返回纯文本（text 类型），非常适合提取多语言字典中的单一语言值。<br />\n假设数据库里的 <code>Biography</code> 字段存储如下 JSON：</p>\n<pre><code>{\n  \"en\": \"Hello World\",\n  \"zh-CN\": \"你好世界\",\n  \"fr\": \"Bonjour le monde\"\n}\n</code></pre>\n<p>如果我们只想获取中文简介：</p>\n<pre><code>-- 使用函数提取 'zh-CN' 键的值\nSELECT jsonb_extract_path_text(\"Biography\", 'zh-CN') \nFROM \"Artists\";\n\n-- 结果仅返回字符串： \"你好世界\"\n</code></pre>\n<p>这种处理方式完全在数据库端完成，传输到应用层的只有这4个字符，而不是包含英文和法文的完整JSON 对象。</p>\n<h1 id=\"解决方案映射自定义函数\">解决方案：映射自定义函数</h1>\n<p>为了在EF Core中使用<code>jsonb_extract_path_text</code>，我们可以通过自定义函数映射来实现。</p>\n<h3 id=\"什么是-ef-core自定义函数\">什么是 EF Core自定义函数？</h3>\n<p>EF Core 的自定义函数映射（User-defined function mapping）允许开发者 C#方法直接映射到数据库中的 SQL 函数。在 LINQ 查询中使用这些被映射的 C# 方法时，EF Core不会在客户端执行它们，而是将它们“翻译”成对应的 SQL 片段发送给数据库执行。这就像是给了你一把钥匙，让你能够从 C# 代码中直接调用数据库特有的、强大的原生能力（如 PostgreSQL 的 JSON 处理、GIS 地理信息计算等），而无需编写原生的 SQL 字符串。</p>\n<h3 id=\"1-定义函数存根\">1. 定义函数存根</h3>\n<p>在 C# 中定义一个静态方法作为存根（Stub），用于告诉 EF Core 即使翻译 SQL。</p>\n<pre class=\"language-cs\"><code class=\"language-cs\">public static class DbFunctionsExtensions\n{\n    // 此方法仅用于 EF Core 查询映射，客户端调用时抛出异常\n    public static string JsonExtractPathText(this Dictionary&lt;string, string&gt; json, string key)\n    {\n        throw new NotSupportedException(\"此方法仅用于 EF Core 查询映射，不可在客户端执行。\");\n    }\n}</code></pre><h3 id=\"2-配置模型映射\">2. 配置模型映射</h3>\n<p>在 <code>OnModelCreating</code> 中通过 Fluent API 进行映射关系配置,  <code>HasDbFunction</code> 将其映射到数据库函数 <code>jsonb_extract_path_text</code>。</p>\n<pre class=\"language-cs\"><code class=\"language-cs\">protected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    modelBuilder.HasDbFunction(typeof(DbFunctionsExtensions)\n            .GetMethod(nameof(DbFunctionsExtensions.JsonExtractPathText),\n                [typeof(Dictionary&lt;string, string&gt;), typeof(string)])!)\n        .HasName(\"jsonb_extract_path_text\")\n        .IsBuiltIn();\n}</code></pre><p>或者，也可以使用 <code>[DbFunction] </code>特性直接配置映射关系，这样代码更加紧凑。</p>\n<pre class=\"language-cs\"><code class=\"language-cs\">using Microsoft.EntityFrameworkCore;\n\npublic static class DbFunctionsExtensions\n{\n    // 映射到 PostgreSQL 的内置函数 jsonb_extract_path_text\n    [DbFunction(\"jsonb_extract_path_text\", IsBuiltIn = true)]\n    public static string JsonExtractPathText(this Dictionary&lt;string, string&gt; json, string key)\n    {\n       throw new NotSupportedException(\"此方法仅用于 EF Core 查询映射，不可在客户端执行。\");\n    }\n}</code></pre><h3 id=\"3-使用示例\">3. 使用示例</h3>\n<p>配置完成后，可以在 LINQ 查询中直接调用该扩展方法：</p>\n<pre class=\"language-cs\"><code class=\"language-cs\">var query = db.Artists\n    .Select(entity =&gt; new \n    {\n        Id = entity.Id,\n        // 数据库仅返回当前语言的文本\n        Bio = entity.Biography.JsonExtractPathText(CultureInfo.CurrentUICulture.Name)\n    });</code></pre><p>生成的 SQL 将调用原生<code>jsonb_extract_path_text</code>函数，避免了全量传输 JSON 数据。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1181943/202601/1181943-20260107143638710-1533499015.png\" /></p>\n<h2 id=\"索引优化策略\">索引优化策略</h2>\n<p>针对 JSONB 字段的查询优化，需要根据具体需求选择合适的索引类型。</p>\n<ol>\n<li>GIN 索引：适用于“包含”类查询（如 Biography 是否包含 en 键）。</li>\n</ol>\n<pre><code>builder.Entity&lt;ArtistEntity&gt;()\n    .HasIndex(x =&gt; x.Biography)\n    .HasMethod(\"gin\");\n</code></pre>\n<ol start=\"2\">\n<li>函数索引 (B-Tree)：如果业务中存在大量基于特定语言（如英文名称）的精确查找或排序需求，GIN 索引效率较低。此时应针对热点语言创建函数索引：</li>\n</ol>\n<pre><code>-- 针对英语内容建立 B-Tree 索引\nCREATE INDEX idx_artist_bio_en ON \"Artists\" (( \"Biography\" -&gt;&gt; 'en' ));\n</code></pre>\n<h2 id=\"适用场景与局限性\">适用场景与局限性</h2>\n<p>虽然通过 <code>jsonb_extract_path_text</code> 可以减少网络传输，但这并不是所有场景下的万能解。</p>\n<ul>\n<li>\n<p>高并发读取：即便减少了传输量，解析 JSONB 在数据库层面依然有 CPU 开销。如果面临极高并发的读取请求（如首页热门列表），频繁让数据库解析 JSON 并不是最优解。在这种情况下，应当引入应用层缓存（如 Redis）或使用专门的搜索引擎（如 Elasticsearch）。</p>\n</li>\n<li>\n<p>数据结构复杂度：此方法最适合扁平的 Key-Value 结构。如果 JSON 结构非常复杂且嵌套深，维护路径映射会变得困难。</p>\n</li>\n<li>\n<p>数据库负载：将数据处理逻辑下推到数据库虽然方便，但会增加数据库 CPU 负载。在数据库资源已是瓶颈的系统中，需谨慎使用。</p>\n</li>\n</ul>\n<p>通过这种方式，我们在保持开发便利性的同时，通过利用数据库原生能力，解决了一个具体的性能问题。开发者应根据实际的数据量级和访问模式，决定是采用此直连方案还是引入更复杂的缓存架构。</p>\n<h1 id=\"参考链接\">参考链接</h1>\n<ul>\n<li><a href=\"https://learn.microsoft.com/en-us/ef/core/querying/user-defined-function-mapping\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/ef/core/querying/user-defined-function-mapping</a></li>\n<li><a href=\"https://github.com/npgsql/efcore.pg/issues/2703\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/npgsql/efcore.pg/issues/2703</a></li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    \n\n  \n  <div id=\"MySignature1\" style=\"color: 0; font-size: small;\">\n            <p>\n          作者： \n          <a href=\"https://www.cnblogs.com/netry/\"></a><a href=\"https://www.cnblogs.com/netry/\" target=\"_blank\">马行空的博客</a>\n      </p>\n      <p>\n          出处：\n          <a href=\"https://www.cnblogs.com/netry/p/19452236/efcore_jsonb_extract_path_text_in_postgredb\" target=\"_blank\">https://www.cnblogs.com/netry/p/19452236/efcore_jsonb_extract_path_text_in_postgredb</a>\n      </p>\n       \n \n      <p>\n          本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。\n      </p>\n  </div>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 15:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/netry\">马行空的博客</a>&nbsp;\n阅读(<span id=\"post_view_count\">75</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "51单片机_按键检测",
      "link": "https://www.cnblogs.com/WIRO/p/19461450",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/WIRO/p/19461450\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 14:49\">\n    <span>51单片机_按键检测</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"51单片机_按键检测\">51单片机_按键检测</h1>\n<h2 id=\"一独立按键介绍\">一、独立按键介绍</h2>\n<p>轻触按键相当于是一种电子开关</p>\n<p>按下时开关接通，松开时开关断开，实现原理是通过轻触按键内部的金属弹片受力弹动来实现接通和断开</p>\n<p><img alt=\"image-20260109110408710\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754276-1163410502.png\" /></p>\n<p><img alt=\"image-20260109110503289\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754526-1860924412.png\" /></p>\n<p>由于机械点的弹性作用，按键开关在闭合时不会马上稳定的接通，在断开时也不会一下子断开。因而在闭合和断开的瞬间均伴随着一连串的抖动。抖动时间的长短由按键的机械特性决定，一般为5ms到10ms。</p>\n<p>按键稳定闭合时间的长短由操作人员的按键动作决定，一般为零点几秒至数秒。按键抖动会引起按键被误读多次。为了确保CPU对按键的依次闭合仅作一次处理，必须及时进行消抖。</p>\n<p>按键消抖有两种方式，一种是硬件消抖，另一种是软件消抖。为了使电路更加简单，通常采用软件消抖。</p>\n<p>软件消抖一般来说一个简单的按键消抖就是先读取按键的状态，如果得到按键按下之后，延时10ms，再次读取按键状态，如果按键还是按下状态，那么说明按键已经按下。其中的延时10ms就是软件消抖处理。</p>\n<p>常用的软件去抖动方法：</p>\n<ol>\n<li>先设置IO口为高电平，由于开发板IO有上拉电阻，默认IO为高电平；</li>\n<li>读取IO口电平确认是否有按键按下；</li>\n<li>如果有IO电平为低电平后，延时几个毫秒；</li>\n<li>再读取该IO电平，如果仍为低电平，说明按键按下；</li>\n<li>执行相应按键的程序；</li>\n</ol>\n<h2 id=\"二独立按键检测原理\">二、独立按键检测原理</h2>\n<p>独立按键电路构成是由各个按键的一个管脚连接在一起接地，按键其它引脚分别接到单片机IO口。</p>\n<p>单片机的IO口既可作为输出也可作为输入使用，当检测按键时用的是它的输入功能，独立按键的一端接地，另一端与单片机的某个IO口相连，开始时先给IO口赋一高电平，然后让单片机不断检测该IO口是否变为低电平，当按键闭合时，相当于该IO口通过按键与地相连，变成低电平，程序一旦检测到IO口变为低电平则说明按键被按下，然后执行相应的指令。</p>\n<p><img alt=\"image-20260109110908433\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754146-1606670533.png\" /></p>\n<h2 id=\"三独立按键应用实践\">三、独立按键应用实践</h2>\n<h3 id=\"1实现按键控制led功能\">1）实现按键控制LED功能</h3>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\n\n/**\n * 主函数\n */\nvoid main()\n{\n\twhile(1)\n\t{\n\t\tif(P3_1 == 0)  \t\t\t  // 如果K1按键按下，则为低电平\n\t\t{\n\t\t\tDelay(20);\t\t\t  // 延时消抖\n\t\t\twhile(P3_1 == 0);\t  // 松手检测\n\t\t\tDelay(20);\t\t\t  // 延时消抖\n\t\t\n\t\t\tP2_0 = ~P2_0;\t\t  // LED1 取反\n\t\t}\n\t}\n}\n</code></pre>\n<p>这段代码依旧存在不灵敏的情况，下面是改进：</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\n\nvoid main()\n{\n    while(1)\n    {\n        if(P3_1 == 0)              // 检测按键是否按下\n        {\n            Delay(10);             // 延时消抖\n            if(P3_1 == 0)          // 再次确认按键确实按下\n            {\n                P2_0 = ~P2_0;      // 执行LED取反\n                \n                // 等待按键释放，避免连按\n                while(P3_1 == 0);  // 等待按键松开\n            }\n        }\n    }\n}\n</code></pre>\n<h3 id=\"2按键控制led灯二进制显示\">2）按键控制LED灯二进制显示</h3>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\n\nvoid main()\n{\n\tunsigned char LEDNum=0;\n\twhile(1)\n\t{\n\t\tif(P3_1==0)\t\t\t\t\t//如果K1按键按下\n\t\t{\n\t\t\tDelay(10);\t\t\t\t//延时消抖\n\t\t\tif(P3_1==0)\n\t\t\t{\n\t\t\t  LEDNum++;\t\t\t\t//变量自增\n\t\t\t  P2=~LEDNum;\t\t\t//变量取反输出给LED\n\t\t\t\twhile(P3_1==0);\t    //松手检测\n\t\t\t}\n\t\t}\n\t}\n}\n\n//  实现原理：\n//  +000  LEDNum 0000 0000  \t取反 —&gt;  1111 1111\n//  +001  LEDNum 0000 0001  \t取反 —&gt;  1111 1110\n//  +002  LEDNum 0000 0010  \t取反 —&gt;  1111 1101\n//  +003  LEDNum 0000 0011  \t取反 —&gt;  1111 1100\n//  ···\n//  +255  LEDNum 1111 1111  \t取反 —&gt;  0000 0000\n//  +256  溢出 -&gt; LEDNum 0000 0000  重新开始计数\n</code></pre>\n<h3 id=\"3按键实现led左右移动\">3）按键实现LED左右移动</h3>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\n\nunsigned char LEDNum;\n\nvoid main()\n{\n\tP2=~0x01;\t\t\t\t\t//上电默认LED1点亮 0000 0001 取反 -&gt; 1111 1110\n\twhile(1)\n\t{\n\t\tif(P3_0==0)\t\t\t    //如果K1按键按下，右移\n\t\t{ \n\t\t\tDelay(20);\n\t\t\twhile(P3_0==0);\n\t\t\tDelay(20);\n\t\t\t\n\t\t\tLEDNum++;\t\t\t //LEDNum自增\n\t\t\tif(LEDNum&gt;=8)\t\t //限制LEDNum自增范围\n\t\t\t\tLEDNum=0;\n\t\t\tP2=~(0x01&lt;&lt;LEDNum);\t //LED的第LEDNum位点亮\n\t\t}\n\t\tif(P3_1==0)\t\t\t\t //如果K2按键按下，左移\n\t\t{\n\t\t\tDelay(20);\n\t\t\twhile(P3_1==0);\n\t\t\tDelay(20);\n\t\t\t\n\t\t\tif(LEDNum==0)\t\t //LEDNum减到0后变为7\n\t\t\t\tLEDNum=7;\n\t\t\telse\t\t\t\t //LEDNum未减到0，自减\n\t\t\t\tLEDNum--;\n\t\t\tP2=~(0x01&lt;&lt;LEDNum);  //LED的第LEDNum位点亮\n\t\t}\n\t}\n}\n</code></pre>\n<p><code>P2=~(0x01&lt;&lt;LEDNum);</code>  实现原理如下：</p>\n<table>\n<thead>\n<tr>\n<th>LEDNum</th>\n<th>0x01 &lt;&lt; LEDNum (二进制)</th>\n<th>取反后 (二进制)</th>\n<th>效果说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td><code>0000 0001</code></td>\n<td><code>1111 1110</code></td>\n<td>LED0亮，其他灭</td>\n</tr>\n<tr>\n<td>1</td>\n<td><code>0000 0010</code></td>\n<td><code>1111 1101</code></td>\n<td>LED1亮，其他灭</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>0000 0100</code></td>\n<td><code>1111 1011</code></td>\n<td>LED2亮，其他灭</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>0000 1000</code></td>\n<td><code>1111 0111</code></td>\n<td>LED3亮，其他灭</td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>0001 0000</code></td>\n<td><code>1110 1111</code></td>\n<td>LED4亮，其他灭</td>\n</tr>\n<tr>\n<td>5</td>\n<td><code>0010 0000</code></td>\n<td><code>1101 1111</code></td>\n<td>LED5亮，其他灭</td>\n</tr>\n<tr>\n<td>6</td>\n<td><code>0100 0000</code></td>\n<td><code>1011 1111</code></td>\n<td>LED6亮，其他灭</td>\n</tr>\n<tr>\n<td>7</td>\n<td><code>1000 0000</code></td>\n<td><code>0111 1111</code></td>\n<td>LED7亮，其他灭</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"四矩阵按键\">四、矩阵按键</h2>\n<p>独立键盘与单片机连接时，每一个按键都需要单片机的一个I/O口。若某单片机系统需要较多按键，如果用独立按键便会占用过多的I/O口资源。</p>\n<p>当用到多个按键时，为了减少I/O口引脚，引入了矩阵按键。比如4*4矩阵键盘。</p>\n<p>对于4*4矩阵键盘，开发板上通常将16个按键排成4行4列。第一行将每个按键的一端连接在一起构成行线，第一列将每个按键的另一端连接在一起构成列线，这样便一共有4行4列共8根线。将这8根线连接到单片机的8个I/O口上，通过程序扫描键盘可以检测16个键。</p>\n<p>无论是独立键盘还是矩阵键盘，单片机检测其是否被按下的依据都是一样的，即检测与该键对应的I/O口是否为低电平。独立键盘有一端固定为低电平而矩阵键盘两端都与单片机I/O口相连，在检测时需编程通过单片机I/O口送出低电平。检测方法最常用的是行列扫描和线翻转法。</p>\n<ul>\n<li>行列扫描法检测时，先送一列为低电平，其余几列全为高电平，此时确定列数；然后立即轮流检测一次各行是否有低电平，若检测到某一行为低电平，此时确定了行数，便可以确认当前被按下的键是哪一行哪一列的。用同样方法轮流送各列一次低电平，再轮流检测一次各行是否变为低电平，这样即可检测完所有的按键，当有按键被按下时便可判断出按下的键是哪一个键。</li>\n<li>线翻转法检测时，就是使所有行线为低电平时，检测所有列线是否有低电平，如果有，就记录列线值；然后再翻转，使所有列线都为低电平，检测所有行线的值。由于有按键按下，行线的值也会有变化，记录行线的值，从而就可以检测到全部按键。</li>\n</ul>\n<p><strong>矩阵按键也需要按键消抖。</strong></p>\n<p><img alt=\"image-20260109120836392\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754496-78745305.png\" /></p>\n<p><img alt=\"image-20260109121508035\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754398-1331883375.png\" /></p>\n<p><img alt=\"image-20260109123822715\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754445-1533630463.png\" /></p>\n<p>以第一列代码作为示例，简单介绍下 <strong>逐列扫描</strong> 的检测原理：</p>\n<p><img alt=\"image-20260109124004422\" src=\"https://img2024.cnblogs.com/blog/3732387/202601/3732387-20260109144754216-452685151.png\" /></p>\n<ul>\n<li><code>P1=0xFF;</code> 把所有按键端口置为高电平，也就是关闭所有按键</li>\n<li><code>P1_3=0;</code>  将第一列按键置为低电平，其他按键依旧为高电平（关闭状态）</li>\n<li>使用  <code>If判断</code>  检测行按键，如果某一行为低电平，就返回 <code>KeyNumber</code> 编号</li>\n</ul>\n<p>其他3列按键的检测原理同上</p>\n<h2 id=\"五矩阵按键应用实践\">五、矩阵按键应用实践</h2>\n<h3 id=\"1实现lcd1602显示按键编号\">1）实现LCD1602显示按键编号</h3>\n<p>main.c</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\t\t  //包含Delay头文件\n#include \"LCD1602.h\"\t  //包含LCD1602头文件\n#include \"MatrixKey.h\"\t  //包含矩阵键盘头文件\n\nunsigned char KeyNum;\n\nvoid main()\n{\n\tLCD_Init();\t\t\t\t\t\t\t          //LCD初始化\n\tLCD_ShowString(1,1,\"MatrixKey:\");\t          //LCD显示字符串\n\twhile(1)\n\t{\n\t\tKeyNum=MatrixKey();\t\t\t\t          //获取矩阵键盘键码\n\t\tif(KeyNum)\t\t\t\t\t\t          //如果有按键按下\n\t\t{\n\t\t\tLCD_ShowNum(2,1,KeyNum,2);\t          //LCD显示键码\n\t\t}\n\t}\n}\n</code></pre>\n<p>Delay.c</p>\n<pre><code class=\"language-c\">\nvoid Delay(unsigned int xms)\n{\n\tunsigned char i, j;\n\twhile(xms--)\n\t{\n\t\ti = 2;\n\t\tj = 239;\n\t\tdo\n\t\t{\n\t\t\twhile (--j);\n\t\t} while (--i);\n\t}\n}\n</code></pre>\n<p>Delay.h</p>\n<pre><code class=\"language-c\">#ifndef __DELAY_H__\n#define __DELAY_H__\n\nvoid Delay(unsigned int xms);\n\n#endif\n\n</code></pre>\n<p>LCD1602.c</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n\n//引脚配置：\nsbit LCD_RS=P2^6;\nsbit LCD_RW=P2^5;\nsbit LCD_EN=P2^7;\n#define LCD_DataPort P0\n\n//函数定义：\n/**\n  * @brief  LCD1602延时函数，12MHz调用可延时1ms\n  * @param  无\n  * @retval 无\n  */\nvoid LCD_Delay()\n{\n\tunsigned char i, j;\n\n\ti = 2;\n\tj = 239;\n\tdo\n\t{\n\t\twhile (--j);\n\t} while (--i);\n}\n\n/**\n  * @brief  LCD1602写命令\n  * @param  Command 要写入的命令\n  * @retval 无\n  */\nvoid LCD_WriteCommand(unsigned char Command)\n{\n\tLCD_RS=0;\n\tLCD_RW=0;\n\tLCD_DataPort=Command;\n\tLCD_EN=1;\n\tLCD_Delay();\n\tLCD_EN=0;\n\tLCD_Delay();\n}\n\n/**\n  * @brief  LCD1602写数据\n  * @param  Data 要写入的数据\n  * @retval 无\n  */\nvoid LCD_WriteData(unsigned char Data)\n{\n\tLCD_RS=1;\n\tLCD_RW=0;\n\tLCD_DataPort=Data;\n\tLCD_EN=1;\n\tLCD_Delay();\n\tLCD_EN=0;\n\tLCD_Delay();\n}\n\n/**\n  * @brief  LCD1602设置光标位置\n  * @param  Line 行位置，范围：1~2\n  * @param  Column 列位置，范围：1~16\n  * @retval 无\n  */\nvoid LCD_SetCursor(unsigned char Line,unsigned char Column)\n{\n\tif(Line==1)\n\t{\n\t\tLCD_WriteCommand(0x80|(Column-1));\n\t}\n\telse if(Line==2)\n\t{\n\t\tLCD_WriteCommand(0x80|(Column-1+0x40));\n\t}\n}\n\n/**\n  * @brief  LCD1602初始化函数\n  * @param  无\n  * @retval 无\n  */\nvoid LCD_Init()\n{\n\tLCD_WriteCommand(0x38);//八位数据接口，两行显示，5*7点阵\n\tLCD_WriteCommand(0x0c);//显示开，光标关，闪烁关\n\tLCD_WriteCommand(0x06);//数据读写操作后，光标自动加一，画面不动\n\tLCD_WriteCommand(0x01);//光标复位，清屏\n}\n\n/**\n  * @brief  在LCD1602指定位置上显示一个字符\n  * @param  Line 行位置，范围：1~2\n  * @param  Column 列位置，范围：1~16\n  * @param  Char 要显示的字符\n  * @retval 无\n  */\nvoid LCD_ShowChar(unsigned char Line,unsigned char Column,char Char)\n{\n\tLCD_SetCursor(Line,Column);\n\tLCD_WriteData(Char);\n}\n\n/**\n  * @brief  在LCD1602指定位置开始显示所给字符串\n  * @param  Line 起始行位置，范围：1~2\n  * @param  Column 起始列位置，范围：1~16\n  * @param  String 要显示的字符串\n  * @retval 无\n  */\nvoid LCD_ShowString(unsigned char Line,unsigned char Column,char *String)\n{\n\tunsigned char i;\n\tLCD_SetCursor(Line,Column);\n\tfor(i=0;String[i]!='\\0';i++)\n\t{\n\t\tLCD_WriteData(String[i]);\n\t}\n}\n\n/**\n  * @brief  返回值=X的Y次方\n  */\nint LCD_Pow(int X,int Y)\n{\n\tunsigned char i;\n\tint Result=1;\n\tfor(i=0;i&lt;Y;i++)\n\t{\n\t\tResult*=X;\n\t}\n\treturn Result;\n}\n\n/**\n  * @brief  在LCD1602指定位置开始显示所给数字\n  * @param  Line 起始行位置，范围：1~2\n  * @param  Column 起始列位置，范围：1~16\n  * @param  Number 要显示的数字，范围：0~65535\n  * @param  Length 要显示数字的长度，范围：1~5\n  * @retval 无\n  */\nvoid LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)\n{\n\tunsigned char i;\n\tLCD_SetCursor(Line,Column);\n\tfor(i=Length;i&gt;0;i--)\n\t{\n\t\tLCD_WriteData(Number/LCD_Pow(10,i-1)%10+'0');\n\t}\n}\n\n/**\n  * @brief  在LCD1602指定位置开始以有符号十进制显示所给数字\n  * @param  Line 起始行位置，范围：1~2\n  * @param  Column 起始列位置，范围：1~16\n  * @param  Number 要显示的数字，范围：-32768~32767\n  * @param  Length 要显示数字的长度，范围：1~5\n  * @retval 无\n  */\nvoid LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length)\n{\n\tunsigned char i;\n\tunsigned int Number1;\n\tLCD_SetCursor(Line,Column);\n\tif(Number&gt;=0)\n\t{\n\t\tLCD_WriteData('+');\n\t\tNumber1=Number;\n\t}\n\telse\n\t{\n\t\tLCD_WriteData('-');\n\t\tNumber1=-Number;\n\t}\n\tfor(i=Length;i&gt;0;i--)\n\t{\n\t\tLCD_WriteData(Number1/LCD_Pow(10,i-1)%10+'0');\n\t}\n}\n\n/**\n  * @brief  在LCD1602指定位置开始以十六进制显示所给数字\n  * @param  Line 起始行位置，范围：1~2\n  * @param  Column 起始列位置，范围：1~16\n  * @param  Number 要显示的数字，范围：0~0xFFFF\n  * @param  Length 要显示数字的长度，范围：1~4\n  * @retval 无\n  */\nvoid LCD_ShowHexNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)\n{\n\tunsigned char i,SingleNumber;\n\tLCD_SetCursor(Line,Column);\n\tfor(i=Length;i&gt;0;i--)\n\t{\n\t\tSingleNumber=Number/LCD_Pow(16,i-1)%16;\n\t\tif(SingleNumber&lt;10)\n\t\t{\n\t\t\tLCD_WriteData(SingleNumber+'0');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLCD_WriteData(SingleNumber-10+'A');\n\t\t}\n\t}\n}\n\n/**\n  * @brief  在LCD1602指定位置开始以二进制显示所给数字\n  * @param  Line 起始行位置，范围：1~2\n  * @param  Column 起始列位置，范围：1~16\n  * @param  Number 要显示的数字，范围：0~1111 1111 1111 1111\n  * @param  Length 要显示数字的长度，范围：1~16\n  * @retval 无\n  */\nvoid LCD_ShowBinNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)\n{\n\tunsigned char i;\n\tLCD_SetCursor(Line,Column);\n\tfor(i=Length;i&gt;0;i--)\n\t{\n\t\tLCD_WriteData(Number/LCD_Pow(2,i-1)%2+'0');\n\t}\n}\n</code></pre>\n<p>LCD1602.h</p>\n<pre><code class=\"language-c\">#ifndef __LCD1602_H__\n#define __LCD1602_H__\n\n//用户调用函数：\nvoid LCD_Init();\nvoid LCD_ShowChar(unsigned char Line,unsigned char Column,char Char);\nvoid LCD_ShowString(unsigned char Line,unsigned char Column,char *String);\nvoid LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);\nvoid LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length);\nvoid LCD_ShowHexNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);\nvoid LCD_ShowBinNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);\n\n#endif\n\n</code></pre>\n<p>MatrixKey.c</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\n\n/**\n  * @brief  矩阵键盘读取按键键码\n  * @param  无\n  * @retval KeyNumber 按下按键的键码值\n\t\t\t如果按键按下不放，程序会停留在此函数，松手的一瞬间，返回按键键码，没有按键按下时，返回0\n  */\nunsigned char MatrixKey()\n{\n\tunsigned char KeyNumber=0;\n\t\n\tP1=0xFF;  // 1111 1111 全部置高电平，没有按键按下\n\tP1_3=0;   // 检测第一列\n\tif(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=1;}\n\tif(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=5;}\n\tif(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=9;}\n\tif(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=13;}\n\t\n\tP1=0xFF;  // 1111 1111 全部置高电平，没有按键按下\n\tP1_2=0;   // 检测第二列\n\tif(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=2;}\n\tif(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=6;}\n\tif(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=10;}\n\tif(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=14;}\n\t\n\tP1=0xFF;  // 1111 1111 全部置高电平，没有按键按下\n\tP1_1=0;   // 检测第三列\n\tif(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=3;}\n\tif(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=7;}\n\tif(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=11;}\n\tif(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=15;}\n\t\n\tP1=0xFF;  // 1111 1111 全部置高电平，没有按键按下\n\tP1_0=0;   // 检测第四列\n\tif(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyNumber=4;}\n\tif(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyNumber=8;}\n\tif(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyNumber=12;}\n\tif(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyNumber=16;}\n\t\n\treturn KeyNumber;\n}\n</code></pre>\n<p>MatrixKey.h</p>\n<pre><code class=\"language-c\">#ifndef __MATRIXKEY_H__\n#define __MATRIXKEY_H__\n\nunsigned char MatrixKey();\n\n#endif\n\n</code></pre>\n<h3 id=\"2使用矩阵键盘实现密码锁功能\">2）使用矩阵键盘实现密码锁功能</h3>\n<p>只需要修改main.c ,其余代码同上</p>\n<pre><code class=\"language-c\">#include &lt;REGX52.H&gt;\n#include \"Delay.h\"\n#include \"LCD1602.h\"\n#include \"MatrixKey.h\"\n\nunsigned char KeyNum;\nunsigned int Password,Count;\n\nvoid main()\n{\n\tLCD_Init();\n\tLCD_ShowString(1,1,\"Password:\");\n\twhile(1)\n\t{\n\t\tKeyNum=MatrixKey();\n\t\tif(KeyNum)\n\t\t{\n\t\t\tif(KeyNum&lt;=10)\t                      //如果S1~S10按键按下，输入密码\n\t\t\t{                                    \n\t\t\t\tif(Count&lt;4)\t                       //如果输入次数小于4\n\t\t\t\t{                                  \n\t\t\t\t\tPassword*=10;\t\t\t\t   //密码左移一位\n\t\t\t\t\tPassword+=KeyNum%10;\t\t   //获取一位密码\n\t\t\t\t\tCount++;\t                   //计次加一\n\t\t\t\t}\n\t\t\t\tLCD_ShowNum(2,1,Password,4);\t   //更新显示\n\t\t\t}                                    \n\t\t\tif(KeyNum==11)\t                       //如果S11按键按下，确认\n\t\t\t{                                    \n\t\t\t\tif(Password==2345)\t               //如果密码等于正确密码\n\t\t\t\t{                                  \n\t\t\t\t\tLCD_ShowString(1,14,\"OK \");\t   //显示OK\n\t\t\t\t\tPassword=0;\t\t               //密码清零\n\t\t\t\t\tCount=0;\t\t               //计次清零\n\t\t\t\t\tLCD_ShowNum(2,1,Password,4);   //更新显示\n\t\t\t\t}\n\t\t\t\telse\t\t\t\t               //否则\n\t\t\t\t{\n\t\t\t\t\tLCD_ShowString(1,14,\"ERR\");\t   //显示ERR\n\t\t\t\t\tPassword=0;\t\t               //密码清零\n\t\t\t\t\tCount=0;\t\t               //计次清零\n\t\t\t\t\tLCD_ShowNum(2,1,Password,4);   //更新显示\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(KeyNum==12)\t                       //如果S12按键按下，取消\n\t\t\t{\n\t\t\t\tPassword=0;\t\t                   //密码清零\n\t\t\t\tCount=0;\t\t                   //计次清零\n\t\t\t\tLCD_ShowNum(2,1,Password,4);\t   //更新显示\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre>\n<p><code>Password*=10;\t\t\t\t   //密码左移一位</code></p>\n<p><code>Password+=KeyNum%10;\t\t   //获取一位密码 </code></p>\n<p><strong>图表：按键序列 5 → 6 → 3 → 8 的处理过程</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">按键</th>\n<th style=\"text-align: left;\">运算前 Password</th>\n<th style=\"text-align: left;\">Password × 10</th>\n<th style=\"text-align: left;\">KeyNum % 10</th>\n<th style=\"text-align: left;\">运算后 Password</th>\n<th style=\"text-align: left;\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">5</td>\n<td style=\"text-align: left;\">0</td>\n<td style=\"text-align: left;\">0 × 10 = 0</td>\n<td style=\"text-align: left;\">5 % 10 = 5</td>\n<td style=\"text-align: left;\"><strong>5</strong></td>\n<td style=\"text-align: left;\">第一个数字直接存入</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">6</td>\n<td style=\"text-align: left;\">5</td>\n<td style=\"text-align: left;\">5 × 10 = 50</td>\n<td style=\"text-align: left;\">6 % 10 = 6</td>\n<td style=\"text-align: left;\"><strong>56</strong></td>\n<td style=\"text-align: left;\">5移到十位，6放在个位</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">3</td>\n<td style=\"text-align: left;\">56</td>\n<td style=\"text-align: left;\">56 × 10 = 560</td>\n<td style=\"text-align: left;\">3 % 10 = 3</td>\n<td style=\"text-align: left;\"><strong>563</strong></td>\n<td style=\"text-align: left;\">56变为560，3放在个位</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">8</td>\n<td style=\"text-align: left;\">563</td>\n<td style=\"text-align: left;\">563 × 10 = 5630</td>\n<td style=\"text-align: left;\">8 % 10 = 8</td>\n<td style=\"text-align: left;\"><strong>5638</strong></td>\n<td style=\"text-align: left;\">563变为5630，8放在个位</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 14:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/WIRO\">Q&amp;25</a>&nbsp;\n阅读(<span id=\"post_view_count\">102</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "小白也能看懂的LLM-RL算法：PPO/DPO/GRPO/GSPO",
      "link": "https://www.cnblogs.com/aifrontiers/p/19461279",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aifrontiers/p/19461279\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 14:29\">\n    <span>小白也能看懂的LLM-RL算法：PPO/DPO/GRPO/GSPO</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>原文: <a href=\"https://mp.weixin.qq.com/s/9KT9LrMTXDGHSvGFrQhRkg\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/9KT9LrMTXDGHSvGFrQhRkg</a></p>\n<p><strong>LLM-RL往期文章推荐</strong></p>\n<p><a href=\"https://mp.weixin.qq.com/s/cx3qY42Lp0L3RaSOgsH77A\" rel=\"noopener nofollow\" target=\"_blank\">小白也能看懂的RL-PPO</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/nfN0dWT3ZfDuW7ZGfaG6dA\" rel=\"noopener nofollow\" target=\"_blank\">收藏！强化学习从入门到封神：5 本经典教材 + 8 大实战项目 + 7个免费视频，一站式搞定</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/4_6CBXMJhqmiYKSzsAXncg\" rel=\"noopener nofollow\" target=\"_blank\">小白也能看懂的RLHF：基础篇</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/8O7W8--x14-b1d3M9IS_3w\" rel=\"noopener nofollow\" target=\"_blank\">小白也能看懂的RLHF-PPO：原理篇</a></p>\n<p>强化学习 (RL, Reinforcement Learning) 已成为大模型后训练的关键环节，在前几篇中，我们对LLM-RL中最基础、最核心的PPO算法做了详细的拆解，有需要的可以点击上面链接阅读，本篇将介绍其他主流的LLM-RL算法。读完这篇后，你会发现，不管是哪种LLM-RL算法，本质都是将人类偏好融入到大模型中，差异点在于以何种方式/更高效地挖掘偏好数据的价值、如何在降低算力资源需求下保证模型性能、如何提高算法稳定性。</p>\n<p>在介绍LLM-RL各类策略算法前，我们将先解释一些基本概念，涵盖强化学习理解、价值函数、NLP中的强化学习。 随后，介绍RLHF的起源、设计思路、如何与大模型RLHF算法关联的。再对LLM-RL主流的（DPO、GRPO、GSPO）策略优化算法进行细致讲解，如各个算法原理、训练过程、优缺点等。为了能够更好地对比各个算法，也会捎带介绍下PPO算法。</p>\n<h1 id=\"1-基本概念\">1 基本概念</h1>\n<h2 id=\"11-强化学习理解\">1.1 强化学习理解</h2>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>强化学习关键在于「<strong>强化</strong>」这个词，简单理解就是「<strong>用反馈强化行为</strong>」，即用奖惩规则让智能体自己在试错中筛选出有效行为，再通过重复反馈把这些行为巩固成最优策略，本质就是「<strong>奖惩驱动的行为筛选与巩固</strong>」，咱们结合之<strong>训练小狗坐下</strong>的例子逐词解释下这句话。</p>\n<ul>\n<li>\n<p><strong>奖惩驱动</strong>：RL整个学习过程的核心动力来自<strong>奖励</strong> 和 <strong>惩罚/无奖励</strong>的即时反馈，比如小狗做对<strong>坐下</strong>就给零食（奖励），没做对就不给零食（无奖励），小狗的行为选择完全由这种反馈驱动。</p>\n</li>\n<li>\n<p><strong>行为筛选</strong>：智能体（小狗）会在动作空间里不断尝试不同行为，而奖惩就像一个筛选器，<strong>被奖励的行为会被保留，被惩罚/无奖励的行为会被淘汰</strong>。比如小狗一开始可能尝试蹦跳、趴着、摇尾巴等动作，这些动作都没得到零食，就会慢慢被筛选掉；只有<strong>坐下</strong>这个动作能拿到零食，就会被筛选出来。</p>\n</li>\n<li>\n<p><strong>行为巩固</strong>：被筛选出来的有效行为，会在一次次重复的「<strong>行为—奖励</strong>」循环中被强化，最终变成稳定的条件反射。比如小狗每次做坐下都能拿到零食，重复次数多了，它就会把<strong>听到指令→坐下</strong>这个行为固定下来，形成稳定的技能。</p>\n</li>\n</ul>\n<p>简单来说，「<strong>强化</strong>」不是增强能力，而是强化「<strong>动作 - 奖励之间</strong>」的关联，让智能体慢慢记住<strong>做什么能拿到好处，做什么会吃亏</strong>。就像训练小狗时，你不用强行掰它的腿让它坐下，只需要用零食的奖惩，让它自己悟出<strong>坐下=有吃的</strong>这个规律，最后形成稳定的行为习惯。</p>\n<p>接下来，我们继续以<strong>训练小狗坐下为例，</strong>理解下强化学习的关键要素、学习过程。</p>\n<p>强化学习的2个核心角色：</p>\n<ul>\n<li>\n<p><strong>智能体（Agent）</strong>：要学习<strong>坐下</strong>技能的<strong>小狗</strong></p>\n</li>\n<li>\n<p><strong>环境（Environment）</strong>：小狗所处的训练场景（比如家里的客厅、户外的院子等）</p>\n</li>\n</ul>\n<p>强化学习的3个关键要素：</p>\n<ul>\n<li>\n<p><strong>状态空间</strong> <span class=\"math inline\">\\(S\\)</span>：训练环境中所有可能出现的场景集合。比如小狗可能站着/趴着/对着玩具叫，也可能身边有陌生人经过，这些不同的状态都属于状态空间</p>\n</li>\n<li>\n<p><strong>动作空间</strong> <span class=\"math inline\">\\(A\\)</span>：小狗能做出的所有动作集合。比如小狗可以站着不动、趴着休息、摇尾巴、跳跃、坐下，这些都是它动作空间里的内容</p>\n</li>\n<li>\n<p><strong>奖励</strong> <span class=\"math inline\">\\(R\\)</span>：小狗处于某个状态、做出某个动作时，给出的即时反馈。比如小狗做出<strong>坐下</strong>动作时，给它一块零食；如果小狗乱蹦乱跳不配合，就不给零食甚至轻声制止。</p>\n</li>\n</ul>\n<p>那小狗（智能体）和训练环境是怎么互动的，最终学会坐下的呢？我们以训练中 <span class=\"math inline\">\\(t\\)</span>时刻的互动过程为例：</p>\n<ul>\n<li>\n<p>当前状态<span class=\"math inline\">\\(S\\_t\\)</span>：小狗正站在客厅里看着你，此时它还没做出目标动作，所以没拿到奖励，即时奖励<span class=\"math inline\">\\(R\\_t\\)</span>= 0</p>\n</li>\n<li>\n<p>小狗的动作<span class=\"math inline\">\\(A\\_t\\)</span>：你发出<strong>坐下</strong>的指令后，小狗可能做出各种反应，比如蹦跳、可能趴着，也可能偶然做出<strong>坐下</strong>的动作；</p>\n</li>\n<li>\n<p>新状态 <span class=\"math inline\">\\(S\\_{t+1}\\)</span>与新反馈与<span class=\"math inline\">\\(R\\_{t+1}\\)</span>：如果小狗刚才做的动作<span class=\"math inline\">\\(A\\_t\\)</span>=坐下，训练状态就变成<strong>小狗处于坐下状态</strong><span class=\"math inline\">\\(S\\_{t+1}\\)</span>，主人立刻给它一块零食作为奖励<span class=\"math inline\">\\(R\\_{t+1}\\)</span>=2 的正向奖励；如果小狗做的是其他动作，<span class=\"math inline\">\\(S\\_{t+1}\\)</span>可能变成小狗趴着或小狗蹦跳，主人不给零食<span class=\"math inline\">\\(R_{t+1}\\)</span>=0。</p>\n</li>\n</ul>\n<p>这样的互动会一次次重复：主人反复发出指令，小狗在不同状态下尝试不同动作，并根据是否拿到零食（奖励）总结经验。最终，小狗（智能体）就会学到一套最优玩法：当接收到<strong>坐下</strong>指令时，立刻做出<strong>坐下</strong>动作，以此稳定拿到零食奖励，这就是强化学习的核心逻辑。</p>\n<h2 id=\"12-价值函数\">1.2 价值函数</h2>\n<p>前面提到的<strong>即时奖励</strong><span class=\"math inline\">\\(R\\_t\\)</span>，只反映了当前状态<span class=\"math inline\">\\(S\\_t\\)</span>的收益，忽略了当前状态和动作对未来收益的影响。更合理的计算方式，需要兼顾<strong>即时收益</strong>和<strong>未来收益</strong>，公式如下：</p>\n<p></p><div class=\"math display\">\\[V\\_t = R_t + \\gamma V_{t+1}\n\\]</div><p></p><p>其中：</p>\n<ul>\n<li>\n<p><span class=\"math inline\">\\(V_t\\)</span>：<span class=\"math inline\">\\(t\\)</span>时刻的总收益（包含即时和未来收益）</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(R_t\\)</span>：<span class=\"math inline\">\\(t\\)</span>时刻的即时收益</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(V_{t+1}\\)</span>： <span class=\"math inline\">\\(t+1\\)</span>时刻的总收益，对 <span class=\"math inline\">\\(t\\)</span>时刻而言属于未来收益</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(\\gamma\\)</span>：折扣因子，用来调节未来收益在当前总收益中的权重</p>\n</li>\n</ul>\n<p>此处不展开强化学习价值函数的假设与推导，仅提供简化结论，方便读者聚焦于更好的理解各类算法策略的具体做法和直觉理解。</p>\n<h2 id=\"13-nlp中的强化学习\">1.3 NLP中的强化学习</h2>\n<p>对应到<span class=\"math inline\">\\(NLP\\)</span> 下，大语言模型就是智能体，输入的提示词 <span class=\"math inline\">\\(prompt\\)</span> 就对应状态 <span class=\"math inline\">\\(S\\)</span>，输出下一个<span class=\"math inline\">\\(token\\)</span> 就是动作 <span class=\"math inline\">\\(A\\)</span>，对 <span class=\"math inline\">\\(prompt+response\\)</span> 进行打分就是奖励 <span class=\"math inline\">\\(R\\)</span>，整体目标就是给定<span class=\"math inline\">\\(prompt\\)</span>，调整策略模型，生成符合人类喜好的<span class=\"math inline\">\\(response\\)</span>。</p>\n<h1 id=\"2-rlhf的起源\">2 RLHF的起源</h1>\n<p>论文标题：Deep Reinforcement Learning from Human Preferences</p>\n<p>论文地址：<a href=\"https://arxiv.org/pdf/1706.03741\" rel=\"noopener nofollow\" target=\"_blank\">https://arxiv.org/pdf/1706.03741</a></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>这篇发表于2017年NIPS的论文是强化学习领域的开创性成果，其核心设计直接奠定了大模型RLHF的技术基础，我们来看看这篇论文到底做出了哪些开创新工作、以及如何对RLHF带来启发的。</p>\n<h2 id=\"21-文章的核心问题创新与方法\">2.1 文章的核心：问题、创新与方法</h2>\n<ul>\n<li>\n<p><strong>解决的问题</strong>：传统强化学习的核心思路是为任务手工设计明确奖励函数，用以引导智能体学习。这种模式对于简单的应用场景还行，一旦涉及复杂场景，如机器人控制、游戏，会面临奖励函数难以精准定义、奖励设计违背人类真实需求的问题，直接影响是智能体行为与人类偏好严重错位，比如机器人为适配简单奖励规则会出现跛行式行走，智能驾驶智能体为追求得分奖励而忽视人类更看重的平稳驾驶体验。</p>\n</li>\n<li>\n<p><strong>核心创新</strong>：舍弃手工设计奖励，提出「<strong>用人类偏好反馈驱动强化学习</strong>」，无需真实奖励函数就可以让智能体对齐人类需求，大幅降低人类监督成本。</p>\n</li>\n<li>\n<p><strong>关键方法</strong>：构建「<strong>偏好收集→奖励建模→策略优化</strong>」三阶段闭环。① 偏好收集：让非专家对比1-2秒短轨迹片段（如机器人后空翻成败片段），快速给出偏好判断；② 奖励建模：用Bradley-Terry模型训练奖励模型，拟合人类偏好背后的隐性规则；③ 策略优化：通过A2C（游戏场景）、TRPO（机器人场景）算法，结合拟合的奖励模型持续更新策略。</p>\n</li>\n</ul>\n<h2 id=\"22-方法效果\">2.2 方法效果</h2>\n<p>论文在多个场景验证了所提方法的有效性：① MuJoCo机器人任务（8项）：仅700条人类查询，性能就接近手工奖励方案，1400条查询实现反超；② Atari游戏（7项）：5500条查询让多数任务性能显著提升；③ 可训练novel行为：1小时内教会机器人连续后空翻等人类难以演示的动作。核心亮点是仅需不到1%的环境交互反馈，就能达到甚至超越传统方法。</p>\n<h2 id=\"23-对大模型rlhf的启发\">2.3 对大模型RLHF的启发</h2>\n<p>论文的核心思想与设计，被RLHF完整继承并适配文本场景（后文会给出详细解读），成为其核心技术框架：</p>\n<ul>\n<li>\n<p><strong>核心逻辑复用</strong>：RLHF直接借鉴「<strong>用人类偏好替代手工奖励</strong>」的思路，解决大模型对话连贯性、礼貌性等难以量化的问题，避免大模型无法对齐人类偏好。</p>\n</li>\n<li>\n<p><strong>三步流程照抄</strong>：让标注员快速对比两条文本，选出人类偏好，训练模型学会怎么给文本打分，将人类偏好打分融合到PPO算法中优化大模型参数</p>\n</li>\n<li>\n<p><strong>关键突破的支撑</strong>：大模型文本任务维度极高，全量标注不现实，得益于论文验证的「<strong>少量反馈即可驱动模型优化</strong>」，RLHF仅用数万条偏好数据就实现了问答质量跃升。</p>\n</li>\n</ul>\n<p>从上面的描述可以看出，论文提出的「<strong>奖励难定义</strong>」、「<strong>三阶段闭环</strong>」、「<strong>低成本反馈</strong>」构成了RLHF的技术基石，启发了OpenAI的研发人员将「<strong>智能体对齐人类偏好</strong>」这一想法，从机器人、游戏领域成功迁移至大模型，成为ChatGPT一夜爆火的重要原因。</p>\n<h1 id=\"3-rlhf-ppo\">3 RLHF-PPO</h1>\n<p>论文标题：Training language models to follow instructions with human feedback 论文地址： <a href=\"https://arxiv.org/pdf/2203.02155\" rel=\"noopener nofollow\" target=\"_blank\">https://arxiv.org/pdf/2203.02155</a></p>\n<p>PPO（Proximal Policy Optimization）算法是 InstructGPT 模型实现人类反馈强化学习（RLHF）的核心，核心思想是通过约束策略更新幅度，在保证训练稳定性的前提下，最大化人类偏好导向的奖励，同时避免策略过度偏离初始监督模型。</p>\n<h2 id=\"31-rlhf-ppo的四大模型\">3.1 RLHF-PPO的四大模型</h2>\n<p>相比传统PPO算法，RLHF-PPO模型架构更为复杂，一共包含4个模型，比传统PPO多出了<strong>参考模型（Reference Model）</strong> 和<strong>奖励模型（Reward Model）</strong>。</p>\n<p>**四大模型作用和参数初始化：</p>\n<ul>\n<li>\n<p><strong>Actor Model</strong> <span class=\"math inline\">\\(\\pi_{\\theta}\\)</span> ：用SFT后的模型作为初始模型，通过PPO训练调整参数，得到最终的模型，使其生成的回答更符合人类偏好，<strong>参数可变</strong>。</p>\n</li>\n<li>\n<p><strong>Reference Model</strong> <span class=\"math inline\">\\(\\pi_{base}\\)</span>：SFT后的模型，用于限制Actor Model不要偏离Reference Model太远，<strong>参数冻结</strong>。</p>\n</li>\n<li>\n<p><strong>Reward Model</strong> <span class=\"math inline\">\\(r\\_{\\theta}\\)</span>：对模型回答打分，表示贴合人类偏好的程度，训练完后，在PPO中是<strong>参数冻结</strong>的。</p>\n</li>\n<li>\n<p><strong>Critic Model</strong> <span class=\"math inline\">\\(V_{t}\\)</span>：用于预测期望总收益，为优势函数 <span class=\"math inline\">\\(A_{t}\\)</span>提供基线，使策略更新更稳定，<strong>参数可变</strong>。</p>\n</li>\n</ul>\n<h2 id=\"32-rlhf-ppo的训练过程\">3.2 RLHF-PPO的训练过程</h2>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>我们回顾一下RLHF里的整体流程，如上图所示：</p>\n<p>Step 1：收集演示数据，训练监督策略（SFT）</p>\n<p>Step 2：收集对比数据，训练奖励模型（RM）</p>\n<p>Step 3：用强化学习（PPO）优化策略模型</p>\n<p>整个流程的核心是<strong>用人类偏好数据（演示、排序）指导模型训练</strong>，最终让大模型输出既有用、又符合人类意图的内容。</p>\n<p>下面，重点讨论PPO算法的训练过程</p>\n<h3 id=\"经验数据收集\">经验数据收集</h3>\n<ul>\n<li>\n<p>将一个batch的prompt喂给当前的Actor模型<span class=\"math inline\">\\(\\pi_{\\theta}\\)</span>，生成对应的响应序列response</p>\n</li>\n<li>\n<p>对于响应序列的每个token，计算以下中间变量：</p>\n<ul>\n<li>\n<p>Actor模型的对数概率<span class=\"math inline\">\\(log(\\pi_\\theta(a_t | s_t))\\)</span></p>\n</li>\n<li>\n<p>Reference模型的对数概率<span class=\"math inline\">\\(log(\\pi_{base}(a_t | s_t))\\)</span></p>\n</li>\n<li>\n<p>Critic模型根据当前状态 <span class=\"math inline\">\\(s\\_t\\)</span>的价值估计 $V_t $</p>\n</li>\n<li>\n<p>计算每个token的KL散度<span class=\"math inline\">\\(kl = log(\\pi_\\theta(a_t | s_t)) - log(\\pi_{base}(a_t | s_t)) = log \\frac {\\pi_\\theta(a_t | s_t)}{\\pi_{base}(a_t | s_t)}\\)</span></p>\n</li>\n<li>\n<p>若该token位于序列的最后一个，通过Reward Model 计算人类偏好分数<span class=\"math inline\">\\(r_{\\theta}\\)</span></p>\n</li>\n<li>\n<p>结合 Reward Model 计算人类偏好分数<span class=\"math inline\">\\(r_{\\theta}\\)</span>（只在最后一步）和 每个token 的 KL 惩罚 ，计算出每个token的最终即时奖励信号 $R_t $，以deepspeed-chat的RLHF为例， $R_t $的计算如下</p>\n</li>\n</ul>\n<p>$$\\begin{align} R_t = \\begin{cases} -kl\\_ctl *(log\\frac{\\pi_\\theta(a_t | s_t)}{\\pi_{base}(a_t | s_t)}), &amp;\\text t\\not =T \\\\ -kl\\_ctl *(log\\frac{\\pi_\\theta(a_t | s_t)}{\\pi_{base}(a_t | s_t)}) + r_\\theta, &amp;\\text t=T \\end{cases} \\end{align}$$</p>\n<ul>\n<li>使用最终即时奖励信号 $R_t $和Critic模型的价值估计 $V_t $，通过 GAE (Generalized Advantage Estimation) 方法计算每个 token 的优势 <span class=\"math inline\">\\(Adv_t\\)</span>，计算如下</li>\n</ul>\n</li>\n</ul>\n<p></p><div class=\"math display\">\\[\\begin{align} \\delta_t = R_t + \\gamma*V_{t+1} - V_t \\\\ Adv_t = \\delta_t + \\gamma* \\lambda*Adv_{t+1} \\end{align}\n\\]</div><p></p><p>将前面收集到的经验数据（prompt、<span class=\"math inline\">\\(log(\\pi_\\theta(a_t | s_t))\\)</span>、<span class=\"math inline\">\\(log(\\pi_{base}(a_t | s_t))\\)</span> 、<span class=\"math inline\">\\(Adv_t\\)</span>、...）构成批次，放到经验池中</p>\n<p>如果对上述计算过程有疑惑，可以回看<a href=\"https://mp.weixin.qq.com/s/8O7W8--x14-b1d3M9IS_3w\" rel=\"noopener nofollow\" target=\"_blank\">小白也能看懂的RLHF-PPO：原理篇</a>，文章有详细解读。</p>\n<h3 id=\"模型参数更新\">模型参数更新</h3>\n<ul>\n<li>\n<p>循环epochs次</p>\n<ul>\n<li>\n<p>对经验池的每个batch数据</p>\n<ul>\n<li>\n<p>Actor Model参数更新： PPO更新模型 <span class=\"math inline\">\\(\\pi_{\\theta}\\)</span> 参数，这里为了防止策略模型 <span class=\"math inline\">\\(\\pi_{\\theta}\\)</span> 过度偏离参考模型 <span class=\"math inline\">\\(\\pi_{base}\\)</span> ，有两种形式保证模型在有限的空间里微调参数，一种是引入PPO-KL散度，</p>\n<p>$$\\begin{align} L^{PPO-KL}(\\theta) = E_{\\tau \\sim {\\pi_{base}}}^t [\\frac{\\pi_\\theta(a_t | s_t)}{\\pi_{base}(a_t | s_t)} A_{t} - \\beta D_{KL}(\\pi_{base}(.|x_t) || \\pi_{\\theta}(.|x_t))] \\end {align}$$</p>\n<p>另一种PPO-CLIP比较直接，在目标函数中，限制新旧模型的差距在约定的区间内：</p>\n<p>$$\\begin{align} L^{PPO-CLIP}(\\theta) = E_{\\tau \\sim {\\pi_{base}}}^t [min( \\frac{\\pi_\\theta(a_t | s_t)}{\\pi_{base}(a_t | s_t)} A_{t},  \\ clip(\\frac{\\pi_\\theta(a_t | s_t)}{\\pi_{base}(a_t | s_t)}, 1-\\varepsilon,1+\\varepsilon)A_{t})] \\end {align}$$</p>\n</li>\n<li>\n<p>Critic Model参数更新：$$\\begin{align} L^{Critic}({\\phi}) &amp;= E_t [(R_t + \\gamma V_{t+1} - V_t)^2] \\end {align}$$</p>\n<p><span class=\"math inline\">\\(V\\_{t}\\)</span>: Critic模型对 <span class=\"math inline\">\\(t\\)</span>时刻收益的预估，即未来和即时收益的整体预估</p>\n<p>$ R_t + \\gamma*V_{t+1}<span class=\"math inline\">\\(: 计算得到的即时收益\\)</span>R_{t}$ ,<span class=\"math inline\">\\(\\gamma*V_{t+1}\\)</span> 为Critic模型预测出 <span class=\"math inline\">\\(t+1\\)</span>时刻之后的折损收益</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"模型参数同步\">模型参数同步</h3>\n<ul>\n<li>\n<p><strong>策略参数更新</strong>：完成经验池的数据训练迭代后，用新训练得到的Actor模型参数、Critic模型参数替换旧的模型参数。</p>\n</li>\n<li>\n<p><strong>丢弃旧数据</strong>：因这批数据是用旧策略模型收集的，与现有的新策略模型偏差较大，重要性采样的假设不再准确，所以必须丢弃当前这批数据。</p>\n</li>\n<li>\n<p><strong>循环训练流程</strong>：回到数据收集阶段，用更新后的策略模型与环境重新交互，采集全新的数据；之后重复整个训练流程，直到策略性能稳定收敛，或达到预设的训练步数。</p>\n</li>\n</ul>\n<p>以上就是PPO算法训练全流程的说明，核心环节包括：经验数据收集、模型参数更新和模型参数同步</p>\n<h2 id=\"33-rlhf-ppo的优缺点\">3.3 RLHF-PPO的优缺点</h2>\n<p><strong>优点</strong>：① 稳定性强：靠裁剪/KL惩罚限制策略更新幅，降低崩坏风险，易收敛；② 易落地：无需TRPO的二阶计算，用Adam优化器即可；核心超参数（如clip系数、GAE参数）易调试</p>\n<p><strong>缺点</strong>：① 训练成本高：涉及4个模型的运算/更新，是后续改进重点；② 梯度信息浪费：clip机制会截断大量梯度，拖慢训练、限制策略精细度；③ 样本利用率低：本质是on-policy架构，策略同步阶段需丢弃旧数据，新模型每次收集数据都会带来算力、时间成本。</p>\n<h1 id=\"4-dpo\">4 DPO</h1>\n<p>论文标题：Direct Preference Optimization: Your Language Model is Secretly a Reward Model 论文地址：<a href=\"https://arxiv.org/pdf/2305.18290\" rel=\"noopener nofollow\" target=\"_blank\">https://arxiv.org/pdf/2305.18290</a></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>如前文所述，PPO算法虽被证实有效，但也暴露诸多痛点。如需同时维护和运行四个模型，对计算资源和显存的要求极高；训练过程还伴随强化学习（RL）常见的不稳定性问题；一次完整的PPO训练，覆盖多个环节，调优的难度较大。</p>\n<p>能否找到一种方法，绕过显式训练奖励模型和复杂的强化学习环节，基于人类偏好数据直接优化策略模型呢？</p>\n<p>DPO正是在这一背景下诞生的创新方法，由斯坦福大学研究团队提出。其核心思想是摒弃「<strong>先训练奖励模型，再用RL优化策略</strong>」的两步流程，直接将人类偏好数据转化为对策略参数的二分类损失优化，大幅简化了训练链路。</p>\n<h2 id=\"41-dpo算法的原理\">4.1 DPO算法的原理</h2>\n<p>DPO 的关键理论支撑在于人类偏好数据里隐藏的奖励规则，而针对这个规则，存在一个<strong>最优策略</strong> <span class=\"math inline\">\\(\\pi^*\\)</span>，</p>\n<p>既能让模型获得的期望奖励尽可能高，又能控制策略模型<span class=\"math inline\">\\(\\pi_\\theta\\)</span>和参考模型 <span class=\"math inline\">\\(\\pi_{ref}\\)</span>之间的差异在合理的范围内。</p>\n<p>论文进一步证明了，这个最优策略 <span class=\"math inline\">\\(\\pi^*\\)</span>、参考策略模型 <span class=\"math inline\">\\(\\pi_{ref}\\)</span>以及偏好数据里藏着的奖励函数<span class=\"math inline\">\\(r_{\\theta}\\)</span> ，三者之间有明确的数学关系，详细的推导过程见论文。这意味着，不用单独训练一个奖励模型，直接拿偏好数据就能优化策略模型。</p>\n<p>具体来说，DPO 让正在训练的模型<span class=\"math inline\">\\(\\pi_\\theta\\)</span>，在面对同一个输入提示 <span class=\"math inline\">\\(x\\)</span>时，生成人类偏好的回答<span class=\"math inline\">\\(y_w\\)</span>，而不是被否定的回答<span class=\"math inline\">\\(y_l\\)</span>。对应的损失函数定义如下：</p>\n<p></p><div class=\"math display\">\\[\\begin{align} L_{DPO}(\\pi_\\theta, \\pi_{ref}) = -E_{(x, y_w, y_l) \\sim {D}}[log(\\sigma(\\beta * (log\\frac{\\pi_\\theta(y_w | x)}{\\pi_{ref}(y_w | x)} - log\\frac{\\pi_\\theta(y_l | x)}{\\pi_{ref}(y_l | x)})))] \\end {align}\n\\]</div><p></p><p>我们来拆解这个公式的几个关键部分：</p>\n<ul>\n<li>\n<p><strong>数据来源</strong> <span class=\"math inline\">\\(D\\)</span> : 是人类标注的偏好数据集，每个样本是 \"提示 <span class=\"math inline\">\\(x\\)</span> + 更优回答<span class=\"math inline\">\\(y_w\\)</span> + 较差回答<span class=\"math inline\">\\(y\\_l\\)</span>\" 的组合</p>\n</li>\n<li>\n<p><strong>概率比的比较</strong>:</p>\n<ul>\n<li>\n<p><span class=\"math inline\">\\(log\\frac{\\pi_\\theta(y_w | x)}{\\pi_{ref}(y_w | x)}\\)</span>：反映当前模型<span class=\"math inline\">\\(\\pi_\\theta\\)</span>相比参考模型<span class=\"math inline\">\\(\\pi_{ref}\\)</span>倾向于生成优质回答<span class=\"math inline\">\\(y_w\\)</span>的程度，这个值越大越好</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(log\\frac{\\pi_\\theta(y_l | x)}{\\pi_{ref}(y_l | x)}\\)</span>：反映当前模型<span class=\"math inline\">\\(\\pi_\\theta\\)</span>相比参考模型<span class=\"math inline\">\\(\\pi_{ref}\\)</span>倾向于生成差回答<span class=\"math inline\">\\(y_l\\)</span>的程度，这个值越小越好</p>\n</li>\n<li>\n<p>这两个概率比的差值，就是模型学到的<strong>优质回答比差回答好多少</strong>的信号，两者相差越大，说明模型越能区分好坏，并且越偏爱好的回答，相当于把偏好转化成了隐式奖励。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>调控因子</strong> <span class=\"math inline\">\\(\\beta\\)</span>：用来控制<span class=\"math inline\">\\(\\pi_\\theta\\)</span>和<span class=\"math inline\">\\(\\pi_{ref}\\)</span>的偏离程度，<span class=\"math inline\">\\(\\beta\\)</span>越大，表明模型需要更明显的偏好差异，才会认定一个回答比另一个好。</p>\n</li>\n<li>\n<p><strong>损失的作用</strong>：<span class=\"math inline\">\\(Sigmoid\\)</span>把奖励信号转成更优回答的概率，再用负对数似然损失来训练，本质是让模型尽可能准确地区分好回答和差回答。</p>\n</li>\n</ul>\n<h2 id=\"42-dpo的训练过程\">4.2 DPO的训练过程</h2>\n<p><strong>数据准备</strong>：收集人类偏好数据集 (<span class=\"math inline\">\\(x, y_w, y_l\\)</span>)</p>\n<p><strong>模型初始化</strong>：</p>\n<ul>\n<li>\n<p><strong>Actor Model</strong> <span class=\"math inline\">\\(\\pi_{\\theta}\\)</span> ：用SFT后的模型作为初始模型，<strong>参数可变</strong>。</p>\n</li>\n<li>\n<p><strong>Reference Model</strong> <span class=\"math inline\">\\(\\pi_{ref}\\)</span>：SFT后的模型，<strong>参数冻结</strong>。</p>\n</li>\n</ul>\n<p><strong>训练过程</strong>：</p>\n<ul>\n<li>\n<p>循环epochs次</p>\n<ul>\n<li>\n<p>从 数据集<span class=\"math inline\">\\(D\\)</span>中抽取 (<span class=\"math inline\">\\(x, y_w, y_l\\)</span>) batch数据</p>\n<ul>\n<li>\n<p>对于每个样本，计算公式（7）中的中间变量值 <span class=\"math inline\">\\(\\pi_\\theta(y_w | x)\\)</span>、<span class=\"math inline\">\\(\\pi_{ref}(y_w | x)\\)</span>、<span class=\"math inline\">\\(\\pi_\\theta(y_l | x)\\)</span>、<span class=\"math inline\">\\(\\pi_{ref}(y_w | x)\\)</span>及其对数概率。通常是计算序列的总对数概率， <span class=\"math inline\">\\(log \\pi_theta(y | x) = \\sum_t log \\pi_\\theta(token_t | x, y_{&lt;t})\\)</span></p>\n</li>\n<li>\n<p>代入 DPO 损失函数公式，计算损失，使用梯度下降更新 <span class=\"math inline\">\\(\\pi_{\\theta}\\)</span> 的参数。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>重复此过程，直到模型收敛或达到预定训练步数。</p>\n</li>\n</ul>\n<h2 id=\"43-dpo的优缺点\">4.3 DPO的优缺点</h2>\n<p><strong>优点</strong>：① 训练链路极简化：直接从偏好数据里提取隐式的奖励信息，没有复杂的数据采样过程，省掉了训练奖励模型、价值函数的步骤。② 资源占用少：仅有参考模型和策略模型，显存和计算资源的消耗大幅降低，训练也更稳定、更容易落地。</p>\n<p><strong>缺点</strong>：① 依赖大量高质量二元偏好数据：虽然可以借助开源 LLM 生成优质数据，但数据收集仍有难度；② 适配场景较局限：因高度依赖偏好数据，难以覆盖复杂推理任务，能力上限不及 PPO，仅胜在流程简单、训练成本低。</p>\n<h1 id=\"5-grpo\">5 GRPO</h1>\n<p>论文标题：DeepSeekMath: Pushing the Limits of Mathematical Reasoning in Open Language Models</p>\n<p>论文地址：<a href=\"https://arxiv.org/pdf/2402.03300\" rel=\"noopener nofollow\" target=\"_blank\">https://arxiv.org/pdf/2402.03300</a></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>DeepSeek团队发现，PPO算法中Critic模型，参数规模与Actor模型相当，显著增加了LLM训练的内存占用与计算成本；更关键的是，很多LLM任务（如数学推理、代码生成等））奖励信号稀疏（仅序列末尾由RM给出奖励），导致训练能精准估计每个token价值的Critic模型异常困难。</p>\n<p>Critic模型的核心作用是为优势函数计算提供基线以降低方差，能否用更高效方式替代Critic实现该目标呢？为此，DeepSeek团队提出GRPO（Group Relative Policy Optimization）算法，突破了对Critic模型的依赖，为策略模型的高效优化开辟了新路径。</p>\n<h2 id=\"51-grpo的原理\">5.1 GRPO的原理</h2>\n<p>GRPO取消了PPO中用于估计价值的Critic模型，通过同一Prompt下的群体信息来构造基线。即，针对单个 Prompt，让策略模型生成 <span class=\"math inline\">\\(G\\)</span> 个不同输出 <span class=\"math inline\">\\({\\{o_1, o_2, ..., o_G\\}}\\)</span>，用奖励模型给每个输出打分 <span class=\"math inline\">\\(r={\\{r_1, r_2, ..., r_G\\}}\\)</span>，计算这组奖励的均值与标准差，再将每个输出的原始奖励归一化，得到优势</p>\n<p></p><div class=\"math display\">\\[\\begin{align} \\hat{A}_{i,t} = \\widetilde{r}_i = \\frac{r_i - mean(r)}{std(r)} \\end{align}\n\\]</div><p></p><p>由上式得到反映群组相对好坏的分数，以此替代 Critic 提供的优势基线。</p>\n<p>由此看出，GRPO的训练仅需三个模型：</p>\n<ul>\n<li>\n<p><strong>策略模型</strong> <span class=\"math inline\">\\(\\\\pi_{\\theta}\\)</span> ：由SFT模型初始化，根据组内相对奖励动态更新参数，参数变化</p>\n</li>\n<li>\n<p><strong>参考模型</strong> <span class=\"math inline\">\\(\\pi_{ref}\\)</span>：冻结参数的SFT，参数不变</p>\n</li>\n<li>\n<p><strong>奖励模型</strong> <span class=\"math inline\">\\(r\\_{\\theta}\\)</span>：用于评估生成的完整响应序列的质量，为策略模型提供优化方向，冻结参数</p>\n</li>\n</ul>\n<p>GRPO算法沿用 PPO 的 clip 阶段结构，优势估计被替换为组内归一化奖励：</p>\n<p></p><div class=\"math display\">\\[\\begin{align}\nJ_{GPRO}(\\theta) = E[q\\sim P(Q), {o_i} \\sim \\pi_{\\theta_{old}(O|q)}] \n\\frac{1}{G} \\sum_{i=1}^G \\frac{1}{|o_i|} \\sum_{t=1}^{|o_i|} {\\{min [ratio_t *\\hat{A}_{i,t}, clip(ratio_t, 1-\\varepsilon, 1+\\varepsilon)\\}}*\\hat{A}_{i,t}] - \\beta D_{KL}[\\pi_\\theta || \\pi_{ref}]\\}\n\n\\end {align}\\]</div><p></p><p>式（9）的中间变量拆解如下：</p>\n<ul>\n<li>\n<p>$\\hat{A}_{i,t} $ 由公式（8）给出，作用于序列中每一个 token，就是说，所有 token 共享同一个优势</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(ratio_t=\\frac{\\pi_\\theta(o_{i,t} |q, o_{i,&lt;t})}{\\pi_{old}(o_{i,t} |q, o_{i,&lt;t})}\\)</span>, ，即新旧策略对同一动作的概率比</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(\\beta D_{KL}[\\pi_\\theta || \\pi_{ref}]\\)</span>，约束 策略模型不要偏离参考模型太远</p>\n</li>\n</ul>\n<h2 id=\"52-grpo的训练过程\">5.2 GRPO的训练过程</h2>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<ul>\n<li>\n<p><strong>输入项</strong>：初始策略模型 <span class=\"math inline\">\\(\\pi_{\\theta_{init}}\\)</span> 、奖励模型 <span class=\"math inline\">\\(r_{\\theta}\\)</span>、任务提示集 <span class=\"math inline\">\\(D\\)</span>，以及超参数 <span class=\"math inline\">\\(\\varepsilon\\)</span>,<span class=\"math inline\">\\(\\beta\\)</span>（控制训练稳定性、更新步长等）。</p>\n</li>\n<li>\n<p><strong>外层循环，总迭代轮次</strong> <span class=\"math inline\">\\(I\\)</span></p>\n<p>每一轮外层循环包含以下操作：</p>\n<ul>\n<li>\n<p>复制当前策略模型<span class=\"math inline\">\\(\\pi_{\\theta}\\)</span>的参数并冻结，将其作为参考模型<span class=\"math inline\">\\(\\pi_{ref}\\)</span></p>\n</li>\n<li>\n<p>进入内层循环（步长<span class=\"math inline\">\\(M\\)</span>），执行策略的更新</p>\n<ul>\n<li>\n<p>采样任务与旧策略：从任务提示集 <span class=\"math inline\">\\(D\\)</span>中采样一个批次 <span class=\"math inline\">\\(D_b\\)</span>, 将当前策略模型<span class=\"math inline\">\\(\\pi_{\\theta}\\)</span>暂存为旧策略 <span class=\"math inline\">\\(\\pi_{\\theta_{old}}\\)</span>（用于后续生成候选输出）</p>\n</li>\n<li>\n<p>生成候选输出并计算奖励：对批次中每个任务q，用旧策略旧策略 <span class=\"math inline\">\\(\\pi_{\\theta_{old}}\\)</span>生成G个候选输出 <span class=\"math inline\">\\({\\{o_1, o_2, ..., o_G\\}}\\)</span>，用奖励模型 $$r_{\\theta}$$为每个候选输出计算奖励 <span class=\"math inline\">\\({\\{r_1, r_2, ..., r_G\\}}\\)</span></p>\n</li>\n<li>\n<p>计算组相对优势： 由公式（8）计算群组相对优势 $\\hat{A}_{i,t} $</p>\n</li>\n<li>\n<p>优化策略模型：公式（9)（10）的梯度更新策略模型<span class=\"math inline\">\\(\\pi_{\\theta}\\)</span>的参数</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"53-grpo算法的优缺点\">5.3 GRPO算法的优缺点</h2>\n<p><strong>优点</strong>：① 稳定性更强：无需依赖价值函数，只要奖励模型能相对判断群体内策略优劣，降低对价值估计精度的依赖降低对价值估计精度的依赖，提升算法稳定性；② 训练成本更低：没有了Critic 模型，显存占用减少大幅降低，相同硬件可训练更大模型或更大batch；③ 易实现且适配并行：组内各策略可独立与环境交互、收集数据，便于利用分布式框架实现并行训练加速。</p>\n<p><strong>缺点</strong>：①存在固有偏差：归一化易偏好短答案或冗长错误输出，且标准差归一化使模型优先优化简单问题（奖励稳定），忽视难题（奖励波动大） ；② 目标不一致问题：奖励函数针对完整序列打分（需等待完整回答），而GRPO优化目标的重要性采样基于token级别计算损失，两者目标存在偏差；③ 高方差和不稳定问题：GRPO 在 token 级别计算重要性采样权重，单个token只被采样一次，难以校正偏离原始策略的 token 分布，易引入高方差噪声，导致梯度估计不稳定。</p>\n<h1 id=\"6-gspo\">6 GSPO</h1>\n<p>论文标题：Group Sequence Policy Optimization</p>\n<p>论文地址：<a href=\"https://arxiv.org/pdf/2507.18071\" rel=\"noopener nofollow\" target=\"_blank\">https://arxiv.org/pdf/2507.18071</a></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>GSPO(Group Sequence Policy Optimization，组序列策略优化)旨在解决GRPO中训练过程中存在的固有偏差、目标不一致、高方差和不稳定的问题。GSPO将RL中重要性采样的单位从令牌级别提升至整个序列级别，又引入了序列长度归一化， 确保不同长度的问题享有公平的优化尺度，从根源解决训练稳定性问题，完美适配 MoE 了架构。</p>\n<h2 id=\"61-gspo的原理和训练过程\">6.1 GSPO的原理和训练过程</h2>\n<p>首先，我们来看下GRPO和GSPO的目标函数</p>\n<ul>\n<li>GRPO目标函数</li>\n</ul>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>其中，<span class=\"math inline\">\\(ratio_t=\\frac{\\pi_\\theta(o_{i,t} |q, o_{i,&lt;t})}{\\pi_{old}(o_{i,t} |q, o_{i,&lt;t})}\\)</span></p>\n<ul>\n<li>GSPO目标函数</li>\n</ul>\n<p></p><div class=\"math display\">\\[ \\begin{align}\nJ_{GSPO}(\\theta) = E[x\\sim D, {\\{y_i}\\}_{i=1}^G \\sim \\pi_{\\theta_{old}(.|x)}] [\n\\frac{1}{G} \\sum_{i=1}^G min (s_i(\\theta) *\\hat{A}_i, clip(s_i(\\theta), 1-\\varepsilon, 1+\\varepsilon)*\\hat{A}_i)]\n\n\\end {align} \\]</div><p></p><p>其中，<span class=\"math inline\">\\(s_i(\\theta)=(\\frac{\\pi_\\theta(y_i |x)}{\\pi_{old}(y_i |x)}) ^{(\\frac{1}{|y_i|})} = exp(\\frac{1}{|y_i|} \\sum_{t=1}^{|y_i|}log\\frac{\\pi_\\theta(y_{i,t} |x, y_{i,&lt;t})}{\\pi_{old}(y_{i,t} |x, y_{i,&lt;t})})\\)</span> ，<span class=\"math inline\">\\(|y_i|\\)</span>是响应<span class=\"math inline\">\\(y_i\\)</span> 的长度，长度归一 化是关键，确保不同长度序列的重要性比率具有可比性，防止比率因序列过长而剧烈波动。注意，论文里为了简化，在公式（11）中没有加KL，实际应用中是有用KL的。</p>\n<p>通过对比GRPO与GSPO的核心公式，能清晰看出两者在重要性采样单位与计算逻辑上的关键差异。</p>\n<p>先看GRPO的目标函数，其加权优势的计算核心聚焦于<strong>token级别</strong>的，如<span class=\"math inline\">\\(ratio_t=\\frac{\\pi_\\theta(o_{i,t} |q, o_{i,&lt;t})}{\\pi_{old}(o_{i,t} |q, o_{i,&lt;t})}\\)</span>, 所示，针对第 <span class=\"math inline\">\\(i\\)</span>个序列中的第<span class=\"math inline\">\\(t\\)</span>个token进行运算。</p>\n<p>举个直观例子，若一个组包含5条样本序列，每条序列有20个token，GRPO需要为这5条序列的每一个token分别计算加权优势。</p>\n<p>两次平均操作：内层先对单条序列的20个token取平均，外层再对5条不同序列取平均，<strong>本质就是算术平均</strong>，最终得到梯度更新的有效信号。</p>\n<p>再看GSPO的目标函数，从公式<span class=\"math inline\">\\(s_i(\\theta)=(\\frac{\\pi_\\theta(y_i |x)}{\\pi_{old}(y_i |x)}) ^{(\\frac{1}{|y_i|})} = exp(\\frac{1}{|y_i|} \\sum_{t=1}^{|y_i|}log\\frac{\\pi_\\theta(y_{i,t} |x, y_{i,&lt;t})}{\\pi_{old}(y_{i,t} |x, y_{i,&lt;t})})\\)</span>, 可以看出，其加权优势的计算单位直接升级为<strong>序列级别，</strong>内层平均由算术平均本变为了几何平均，外层的计算逻辑依然不变。</p>\n<p>GSPO的训练过程和GRPO基本一致，差别在于目标函数中重要性采样计算逻辑，这里不做过多解释。</p>\n<h2 id=\"62-gspo的优缺点\">6.2 GSPO的优缺点</h2>\n<p><strong>优点</strong>：① 提升训练稳定性：GRPO 在 token 级进行重要性采样时，若某时间步生成错误 token，此时优势为 <span class=\"math inline\">\\(A\\_t &lt;0\\)</span>，旧策略生成该 token 的概率极低（如<span class=\"math inline\">\\(1e^{-8}\\)</span>），新策略生成概率即使仅为 0.001，重要性比值也会飙升至 <span class=\"math inline\">\\(10^5\\)</span>，通过公式(9) (10)发现，在<span class=\"math inline\">\\(A_t &lt;0\\)</span>情况下，这么大的重要性比值不会被裁剪，进而造成损失函数的大波动，噪声会不断累积，甚至模型会训崩。而 GSPO 以序列为单位计算重要性采样比值，即便个别 token的重要性比值飙升，经过几何平均后(经过Log运算、算术平均、指数运算)，也会被平滑，不会造成比值的大幅波动，从而避免了损失函数的震荡，保障了训练稳定性；② 适配 MoE 架构模型：GRPO 采用 token 级重要性采样，需依赖路由重放等技巧才能稳定训练；而 GSPO 基于序列级计算重要性采样，无需这类复杂操作即可实现 MoE 模型的稳定训练，大幅简化了训练流程，同时释放了 MoE 模型的潜力。</p>\n<p><strong>缺点</strong>：① 计算复杂度升高：相比 GRPO 的 token 级重要性采样，GSPO 切换为序列级计算后，算法的实现难度与计算成本有所增加。</p>\n<h1 id=\"7-参考资料\">7 参考资料</h1>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1932791271363154917\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/1932791271363154917</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/gSUw8bXraKy0RzVU_Crwcw\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/gSUw8bXraKy0RzVU_Crwcw</a></p>\n<p><a href=\"https://arxiv.org/pdf/1706.03741\" rel=\"noopener nofollow\" target=\"_blank\">https://arxiv.org/pdf/1706.03741</a></p>\n<p><a href=\"https://arxiv.org/pdf/2305.18290\" rel=\"noopener nofollow\" target=\"_blank\">https://arxiv.org/pdf/2305.18290</a></p>\n<p><a href=\"https://arxiv.org/pdf/2402.03300\" rel=\"noopener nofollow\" target=\"_blank\">https://arxiv.org/pdf/2402.03300</a></p>\n<p><a href=\"https://arxiv.org/pdf/2507.18071\" rel=\"noopener nofollow\" target=\"_blank\">https://arxiv.org/pdf/2507.18071</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 14:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aifrontiers\">AI-Frontiers</a>&nbsp;\n阅读(<span id=\"post_view_count\">33</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "干掉 Claude Code，这个开源 AI 编程工具杀疯了？",
      "link": "https://www.cnblogs.com/yupi/p/19460549",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19460549\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 11:30\">\n    <span>干掉 Claude Code，这个开源 AI 编程工具杀疯了？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"干掉 Claude Code，这个开源 AI 编程工具杀疯了？\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202601/2225420-20260109111409828-677596839.png\" />\n        最近我身边很多程序员朋友开始从 Claude Code 转向了另一个工具，正是突然大火的开源项目 OpenCode。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-heading\"><span class=\"md-plain\">大家好，我是程序员鱼皮。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Claude Code 一直是大家公认的 AI 编程命令行工具 Top 1，在 AI 和程序员圈子里几乎是神一般的存在。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但是，这狗玩意儿对中国用户可不太友好……</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先，如果你想要使用 Claude Code，就必须要有特殊的网络 + 官方账号，否则就会看到一片红。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，2025 年 9 月，Anthropic 公司不知道抽什么风，突然宣布 <span class=\"md-pair-s \"><strong>全面禁止中国控股企业使用 Claude 服务</strong><span class=\"md-plain\">，不仅包括中国大陆企业，连海外中资控股超过 50% 的公司都在封禁范围内！</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">甚至 Anthropic 还特别点名了中国，把咱们称为 <span class=\"md-pair-s \"><strong>敌对国家</strong><span class=\"md-plain\">！</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">天下苦 Claude Code 久矣！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但是最近我身边很多程序员朋友开始从 Claude Code 转向了另一个工具，正是突然大火的开源项目 OpenCode。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这玩意只用了半年的时间，就在 GitHub 上涨到了 5.2w Star！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这是个什么概念？比我在 GitHub 上开源的几十个项目的总和加起来都多！慕了慕了……</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenCode 到底是什么？凭什么这么火？</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">啥是 OpenCode？</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://opencode.ai/\" rel=\"noopener nofollow\"><span class=\"md-plain\">OpenCode</span></a><span class=\"md-plain\"> 是一款 100% 开源的 AI 编程命令行工具，可以在 <span class=\"md-pair-s \"><strong>终端、IDE、甚至桌面应用</strong><span class=\"md-plain\"> 中使用。</span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可能会问：这玩意儿跟 Claude Code 有啥区别？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">试试不就知道了？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来我带大家实操一下，从零开始安装、配置、到实际写代码，一条龙服务~</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">从 0 开始上手 OpenCode</span></h2>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">1、安装运行 OpenCode</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">直接进入 OpenCode 官网，复制一行命令：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">命令如下：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span><span class=\"cm-builtin\">curl&nbsp;<span class=\"cm-attribute\">-fsSL&nbsp;https://opencode.ai/install |&nbsp;<span class=\"cm-builtin\">bash</span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后在终端中执行，就可以完成安装了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">安装完成之后，输入 <span class=\"md-pair-s\"><code>opencode</code><span class=\"md-plain\"> 进入程序，接下来你就可以愉快地使用了~</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先来个经典的 Hello World，AI 成功给出了回复。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">恭喜，到这里你已经掌握了 OpenCode 的 70% 了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2、选择模式和模型</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenCode 支持 2 种模式，默认是 Build 模式，用来构建应用、生成代码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">按一下 Tab 键，就可以切换到 Plan 模式，用于生成执行计划。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">按一下 <span class=\"md-pair-s\"><code>Ctrl + p</code><span class=\"md-plain\"> 键，可以打开命令面板，里面有几十个内置命令。我们先来试着切换一下大模型：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">默认提供了 4 个免费模型：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">好家伙，连智谱最新的 GLM-4.7 竟然也免费？那我的 Coding Plan 套餐不是白开了？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了免费的模型外，OpenCode 支持超多的 AI 模型，你可以自由选择：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">选中模型后，配置自己的 API Key 就好了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你之前有 <span class=\"md-pair-s \"><strong>Claude Pro/Max 订阅账号</strong><span class=\"md-plain\">，可以直接登录使用，无缝从 Claude Code 迁移过来。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">3、快捷指令</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenCode 支持斜杠命令，输入 <span class=\"md-pair-s\"><code>/</code><span class=\"md-plain\">，能看到很多操作，比如查看模型列表、查看 Agents、管理 MCP、切换主题等等：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">支持几十个不同的主题，颜值都挺高的，从这点也能看出来 OpenCode 很注重用户的体验：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">输入 <span class=\"md-pair-s\"><code>@</code><span class=\"md-plain\"> 可以快速关联目录文件，给 AI 添加上下文： </span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">4、交互体验</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">相比于 Claude Code，OpenCode 真是把命令行的交互体验拉满了，甚至我觉得它是一个伪装成命令行的桌面应用。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可以点击某条消息，然后会弹出一个消息动作框，你可以撤回消息和 AI 的回复，也可以复制、或者基于当前对话新开一个对话框。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可以通过鼠标上下滚动来切换选单，并且可以直接通过鼠标点击进入下一步。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可以按 <span class=\"md-pair-s\"><code>Ctrl + p</code><span class=\"md-plain\"> 键打开命令面板，然后开启侧边栏：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后界面就变成了这样，你管这叫命令行？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">5、LSP 支持</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">细心的你一定看到了，右边的侧边栏有个 <span class=\"md-pair-s\"><code>LSP</code><span class=\"md-plain\">，这是什么鬼东西？老色批？</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">LSP（Language Server Protocol 语言服务器协议）是微软开发的一种通信协议，用于让代码编辑器和语言服务器之间进行通信。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">简单来说，<span class=\"md-pair-s \"><strong>LSP 就是让编辑器看懂代码的技术。</strong></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如你在 VS Code 里写代码，输入 <span class=\"md-pair-s\"><code>console.</code><span class=\"md-plain\"> 它会自动提示 <span class=\"md-pair-s\"><code>log</code><span class=\"md-plain\">、点击函数名能跳转到代码定义、写错代码会画红线提醒。这些代码编辑器的功能，背后都是 LSP 在干活。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenCode 支持 LSP，意味着 AI 能真正理解你的代码结构，而不是把代码当普通文字瞎猜，改起来更精准。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我让 AI 介绍我的 AI 答题平台项目中最有价值的代码，LSP 就派上用场了。它能帮 AI 快速定位某段代码在哪里被调用、引用了哪些变量，而不是让 AI 傻傻地全局搜索文本。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">6、回到之前的会话</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你不小心关闭了 OpenCode，不用担心，可以打开命令面板，选中 “Switch session” 切换会话：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">就能回到之前的聊天了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">桌面版 OpenCode</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">即使 OpenCode 支持了这么多改进用户体验的交互，但我估计大多数同学还是不喜欢小黑框的。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">没关系，OpenCode 还提供了桌面应用版本！macOS、Windows、Linux 全端支持，这是真的要卷死 Claude Code 的节奏啊……</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">指路：<span class=\"md-link md-pair-s\"><a href=\"https://opencode.ai/download\" rel=\"noopener nofollow\">https://opencode.ai/download</a></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过当我怀着满腔热血安装并打开它时，竟然报错了！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">经过一番排查，发现原来是我开了代理，关闭之后就正常运行了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但是用惯了 Cursor，这个交互体验真的有点敷衍了，不推荐大家使用。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">OpenCode 扩展能力</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">到目前为止，我觉得 OpenCode 在前端用户体验上全方面碾压 Claude Code，而且 OpenCode 完全兼容 Claude Code 的 Skills 系统！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Skills 是一种给 AI 准备的能力扩展包。你可以把它理解成给新同事准备的工作交接文档，里面包含任务执行方法、工具使用说明、模板素材等。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如你可以创建一个 <span class=\"md-pair-s\"><code>公司代码规范 Skill</code><span class=\"md-plain\">，把代码风格、命名规则、注释要求等写进去。之后 Claude Code 生成的代码就会自动遵循这些规范，不用每次都重复说明。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">根据官方文档，OpenCode 会自动搜索这些位置的 Skills：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>.opencode/skill/&lt;name&gt;/SKILL.md</code><span class=\"md-plain\">（项目目录）</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>~/.config/opencode/skill/&lt;name&gt;/SKILL.md</code><span class=\"md-plain\">（用户目录）</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>.claude/skills/&lt;name&gt;/SKILL.md</code><span class=\"md-plain\">（Claude Code 兼容）</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>~/.claude/skills/&lt;name&gt;/SKILL.md</code><span class=\"md-plain\">（Claude Code 兼容）</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">也就是说，如果你之前给 Claude Code 创建过自定义 Skills，直接拿过来就能用！又是无缝迁移。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">Oh My OpenCode 开挂插件</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你觉得 OpenCode 还不够强，可以试试 <span class=\"md-pair-s\"><code>Oh My OpenCode</code><span class=\"md-plain\"> 这个开源的 OpenCode 增强插件，已经 1w Star 了。</span></span></span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">项目地址：<span class=\"md-link md-pair-s\"><a href=\"https://github.com/code-yeongyu/oh-my-opencode\" rel=\"noopener nofollow\">https://github.com/code-yeongyu/oh-my-opencode</a></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个插件有多牛？看看用户评价：</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">\"It made me cancel my Cursor subscription.\"（它让我取消了 Cursor 订阅）</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">\"Knocked out 8000 eslint warnings with Oh My Opencode, just in a day\"（一天内用它解决了 8000 个 eslint 警告）</span></p>\n</blockquote>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Oh My OpenCode 的核心功能是引入了一个叫 <span class=\"md-pair-s \"><strong>Sisyphus</strong><span class=\"md-plain\"> 的智能体编排系统。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我特地去搜了一下：</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">西西弗斯（Sisyphus）是古希腊神话中一位因欺骗众神、挑战权威而被诸神惩罚的国王，他的惩罚是永无止境地将一块巨石推上山顶，而石头一到山顶便会滚落，如此周而复始，象征着徒劳无功、永无休止的任务，也代表着一种对荒诞命运的抗争精神。</span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个系统可以：</span></p>\n<ol class=\"ol-list\" start=\"\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">并行调度多个 AI 模型：比如让 GPT debug 的同时让 Gemini 写前端</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">自动任务管理：不完成任务不让停，像西西弗斯推石头一样锲而不舍</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">智能代码审查：自动检测并清理 AI 生成的冗余注释</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">LSP 深度集成：提供重命名、跳转定义等 IDE 级功能</span></p>\n</li>\n</ol>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">简单来说，Sisyphus 就是一个 AI 监工，它能同时指挥多个 AI 模型干活，还会盯着它们把任务做完。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">虽然官方说用一行命令就能完成安装，但我建议你先安装 bun，再执行 npx 来安装，否则可能会报错。</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span><span class=\"cm-builtin\">npm&nbsp;install bun&nbsp;<span class=\"cm-attribute\">-g<br /><span>npx oh-my-opencode install</span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">安装过程中，可能会问你有没有某些模型的订阅，我反正啥都没有，一直选 \"No\" 就行了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">安装完成后，再次进入 OpenCode，之后只需要在你的提示词里加上 <span class=\"md-pair-s\"><code>ultrawork</code><span class=\"md-plain\">（或 <span class=\"md-pair-s\"><code>ulw</code><span class=\"md-plain\">）这个开挂咒语，就能激活全部增强功能。自动调度多个 AI 模型同时工作、深度探索代码库、锲而不舍地执行。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下面我们试试看，正好来验证一下 OpenCode 做项目的能力如何？能不能把 Claude Code 一脚踹飞？</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">实战项目 - 用 OpenCode 做个 AI 健康助手</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">最近蚂蚁集团的 <span class=\"md-pair-s\"><code>蚂蚁阿福</code><span class=\"md-plain\"> AI 健康助手火了，地铁口、公司楼下的电视广告中随处可见何炅老师的身影。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">虽然我还没有用过它，但是听说它可以通过拍皮肤、拍报告提供 AI 初诊，还能智能回答医学科普和治疗建议。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">那我们也来做个类似的健康小助手网站吧！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">前有蚂蚁阿福，今有鱼皮阿坤。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先分析一下，我们要做的是包含前端 + 后端的全栈项目，而且后端还需要调用 AI 大模型来生成内容。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这里我选择用 <span class=\"md-pair-s \"><strong>Vercel AI Gateway</strong><span class=\"md-plain\"> 来实现 AI 能力，这是一款简单易用的 AI 网关。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">什么是 AI 网关？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">简单来说，它就像是火车站的检票口，你的应用发来的请求先经过网关，网关帮你处理认证、限流、监控等一系列复杂的操作，然后把请求转发给 AI 大模型。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">而且 Vercel AI Gateway 支持对接 500 多个大模型，还有免费额度，非常适合学习和小项目。</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">指路：<span class=\"md-link md-pair-s\"><a href=\"https://vercel.com/ai-gateway\" rel=\"noopener nofollow\">https://vercel.com/ai-gateway</a></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）首先你需要注册登录 Vercel，然后在控制台创建 API Key，注意不要泄露哦：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）启动 OpenCode，切换模型到编程能力很强、并且免费的 GLM-4.7，然后输入这段提示词：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>你是一位专业的程序员，请帮我开发《每日健康小助手》网站，用户可以通过和 AI 聊天来记录和管理每日健康状态。<br /><span><span>​<br /><span><span class=\" cm-header cm-header2\">## 开发要求<br /><span><span>​<br /><span><span class=\"cm-block-start cm-variable-2\">1.&nbsp;<span class=\"cm-variable-2\">需要包含完整的前端和后端，后端使用 Node.js<br /><span><span class=\"cm-block-start cm-variable-2\">2.&nbsp;<span class=\"cm-variable-2\">使用 Vercel 的 AI Gateway 实现 AI 能力，需要先通过官方文档来获取用法：https://vercel.com/docs/ai-gateway/getting-started<br /><span><span class=\"cm-block-start cm-variable-2\">3.&nbsp;<span class=\"cm-variable-2\">以完成核心功能为目标，确保项目可以正常运行<br /><span><span class=\"cm-block-start cm-variable-2\">4.&nbsp;<span class=\"cm-variable-2\">整体网站界面采用清新的绿色健康风格，响应式适配各种尺寸的设备<br /><span><span class=\"cm-block-start cm-variable-2\">5.&nbsp;<span class=\"cm-variable-2\">AI 需要主动询问用户的健康状况，比如睡眠、运动、饮食等</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">点击发送后，OpenCode 会自动使用网页抓取工具读取 Vercel AI Gateway 的官方文档，学习最新的用法：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">大概 5 分钟左右，AI 就完成了全部代码的生成，并且自动安装了依赖。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）我直接把之前拿到的 Vercel 的 API Key 提供给 AI，让它帮我启动项目：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）启动项目成功后，打开浏览器访问 <span class=\"md-pair-s\"><code>localhost:3000</code><span class=\"md-plain\">，测试一下效果。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">结果报错了！无法调用 AI。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可能是 AI 对 Vercel AI Gateway 文档的理解不到位，导致写错了调用 AI 的代码。于是我再次把文档输入给 AI，让它再战一次：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">结果又报错了，明明我已经给 AI 提供了 API Key，系统还是报错 “缺少 API Key”。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">于是我又调了一次 AI，告诉它 “这个 key 我之前已经提供给你了”。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">经过大概 5 次左右的报错和修复，仍然不能正常使用！我麻了啊……</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">于是，我有一个鬼点子：既然要跟 Claude Code 比较，那我不妨尝试用 Claude Code 修复这个 OpenCode 解决不了的问题？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">试试看！输入提示词：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>现在项目后端 AI 功能不可用<br /><span>请参考 https://vercel.com/docs/ai-gateway/getting-started 文档<br /><span>帮我修复后端，确保项目能正常运行</span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Claude Code 成功修复了问题，终于能够正常使用了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">💡 注意，如果你遇到了调用 AI 网络超时的问题，可以让 AI 把调用的 baseURL 改为 <span class=\"md-link md-pair-s\"><a href=\"https://ai-gateway.vercel.sh/v1\" rel=\"noopener nofollow\">https://ai-gateway.vercel.sh/v1</a></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">之前类似的任务我用 Claude Code / Cursor + GLM，不到 10 分钟就搞定了。这次竟然花了 20 分钟左右，还要经过来回拉扯，才能正常使用。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这让我不得不怀疑 OpenCode 的能力了。而且感觉 GLM 大模型在 OpenCode 中好像变笨了，不知道是不是我的错觉…… </span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不行，大家把 OpenCode 吹得这么牛批，我得再试试，一定是我用法的问题！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Ultrawork 模式</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还记得前面提到的 <span class=\"md-pair-s\"><code>ultrawork</code><span class=\"md-plain\">（或 <span class=\"md-pair-s\"><code>ulw</code><span class=\"md-plain\">）开挂咒语么？搞起！</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">进入战斗状态了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可以查看子代理运行详情，先按 <span class=\"md-pair-s\"><code>Ctrl + x</code><span class=\"md-plain\"> 键，再按方向键来查看不同的代理。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">而且当后台任务完成时，会有一个提示。可以看到 “研究 Vercel AI SDK 对话模式” 的任务已经完成。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过你猜怎么着？我等了将近 10 分钟，任务还没结束……</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">看看这个任务列表，需要这么复杂吗？连数据库都给我干出来了？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img alt=\"=\" class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我已经没耐心等下去了，毁灭吧！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">看来这种不算太复杂的工作并不能发挥出多代理的优势。就像你只是要打印一张纸，没必要发动全公司的人，有的研究打印的纸张类型、有的研究打印机的状态、有的研究怎么打印姿势更优雅。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">最后</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">经过上述简单的测试，我暂时对 OpenCode 保持观望状态。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">前端做的确实很不错，但后端的能力感觉跟 Claude Code 还有差距。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果只是追求前端使用方便，那我为什么不用 Cursor？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过 OpenCode 的成功说明了一个道理：<span class=\"md-pair-s \"><strong>谁离用户近、谁能发现痛点，谁就有超越巨头的机会。</strong></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Claude Code 确实很强，但它对中国用户的封禁，给了开源社区一个绝佳的机会。OpenCode 抓住了这个痛点，用更开放的方式赢得了用户的心。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">虽然效果有待提高，但毕竟 OpenCode 完全开源免费，对于喜欢折腾的程序员来说，可定制性更强。你甚至可以 fork 一份自己魔改，想怎么玩就怎么玩。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OK，就聊到这里。你用过 OpenCode 吗？欢迎评论区聊聊你的体验~</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-meta-i-c md-link md-expand\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 11:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">883</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}