{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "CodeSpirit-考试预生成方案（开源）",
      "link": "https://www.cnblogs.com/codelove/p/19419723",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/codelove/p/19419723\" id=\"cb_post_title_url\" title=\"发布于 2026-01-06 23:00\">\n    <span>CodeSpirit-考试预生成方案（开源）</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1-概述\">1. 概述</h2>\n<h3 id=\"11-背景\">1.1 背景</h3>\n<p>在考试系统中，当大量学生同时开始考试时，系统需要为每个学生创建考试记录（<code>ExamRecord</code>）和答题记录（<code>ExamAnswerRecord</code>）。传统的\"按需创建\"模式在高并发场景下存在以下问题：</p>\n<ul>\n<li>\n<p><strong>性能瓶颈</strong>：每次开始考试都需要执行数据库写入操作，响应时间在 200-500ms</p>\n</li>\n<li>\n<p><strong>并发压力</strong>：1000+ 学生同时开考时，数据库压力激增，可能导致超时或失败</p>\n</li>\n<li>\n<p><strong>用户体验</strong>：学生点击\"开始考试\"后需要等待较长时间才能进入考试界面</p>\n</li>\n</ul>\n<p><img alt=\"image-20251229202908907\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251230100134756-1611981628.png\" /></p>\n<ul>\n<li>Github：xin-lai/CodeSpirit</li>\n<li>Gitee：magicodes/CodeSpirit</li>\n</ul>\n<h3 id=\"12-解决方案\">1.2 解决方案</h3>\n<p><strong>考试记录预生成方案</strong>通过定时任务（每天凌晨1点）批量预生成所有已发布且尚未开始的考试的记录和答题记录，将数据库写入操作从\"考试开始时刻\"提前到\"凌晨低负载时段\"，从而：</p>\n<ul>\n<li>✅ <strong>性能提升</strong>：开始考试耗时从 200-500ms 降低到 10-50ms（命中预生成记录时）</li>\n<li>✅ <strong>并发优化</strong>：数据库写入压力分散到凌晨低负载时段，避免影响正在进行的考试</li>\n<li>✅ <strong>用户体验</strong>：学生点击开始后即刻进入考试，无感知延迟</li>\n<li>✅ <strong>数据一致性</strong>：题目顺序预先确定，避免并发冲突</li>\n</ul>\n<h3 id=\"13-核心特性\">1.3 核心特性</h3>\n<ul>\n<li><strong>定时预生成</strong>：每天凌晨1点通过定时任务统一预生成，避免影响正在进行的考试</li>\n<li><strong>智能预生成</strong>：仅预生成第一次考试记录（<code>AttemptNumber = 1</code>），后续考试动态创建</li>\n<li><strong>缓存优化</strong>：预生成记录写入缓存，开始考试时优先查询缓存，减少数据库查询</li>\n<li><strong>智能检测</strong>：开始考试时自动检测预生成记录，命中则快速启动，未命中则动态创建</li>\n<li><strong>垃圾清理</strong>：定时任务自动清理未使用的预生成记录，避免数据冗余</li>\n<li><strong>容错机制</strong>：预生成失败不影响考试发布，新增学生自动降级为动态创建</li>\n</ul>\n<hr />\n<h2 id=\"2-架构设计\">2. 架构设计</h2>\n<h3 id=\"21-系统架构图\">2.1 系统架构图</h3>\n<div class=\"mermaid\">sequenceDiagram\n    participant Admin as 管理员\n    participant Controller as ExamSettingsController\n    participant Service as ExamSettingService\n    participant ScheduledTask as 定时预生成任务\n    participant Cache as 缓存层\n    participant DB as 数据库\n    participant Student as 学生\n    participant StartExam as CreateExamRecordAsync\n    \n    Note over Admin,Service: 阶段1：考试发布\n    Admin-&gt;&gt;Controller: 发布考试\n    Controller-&gt;&gt;Service: PublishExamSettingAsync\n    Service-&gt;&gt;DB: 更新考试状态为Published\n    Service--&gt;&gt;Admin: 返回成功\n    \n    Note over ScheduledTask,DB: 阶段2：定时预生成（每天凌晨1点）\n    ScheduledTask-&gt;&gt;DB: 查询已发布且尚未开始的考试\n    ScheduledTask-&gt;&gt;DB: 检查是否已预生成\n    ScheduledTask-&gt;&gt;DB: 分批创建ExamRecord(NotStarted)\n    ScheduledTask-&gt;&gt;DB: 批量创建ExamAnswerRecord\n    ScheduledTask-&gt;&gt;Cache: 写入预生成记录ID（过期时间=考试结束时间）\n    ScheduledTask-&gt;&gt;ScheduledTask: 打印详细日志\n    \n    Note over Student,StartExam: 阶段3：学生开始考试\n    Student-&gt;&gt;StartExam: 点击开始考试\n    StartExam-&gt;&gt;Cache: 查询预生成记录ID\n    alt 缓存命中\n        StartExam-&gt;&gt;DB: 加载预生成记录\n        StartExam-&gt;&gt;DB: UPDATE状态为InProgress&lt;br/&gt;设置StartTime\n        StartExam--&gt;&gt;Student: 快速启动(10-50ms) ✅\n    else 缓存未命中（新增学生）\n        StartExam-&gt;&gt;DB: 动态创建完整记录\n        StartExam--&gt;&gt;Student: 常规启动(200-500ms) ⚠️\n    end\n    \n    Note over ScheduledTask,DB: 阶段4：定时清理（每天凌晨2点）\n    ScheduledTask-&gt;&gt;DB: 查询已结束考试的NotStarted记录\n    ScheduledTask-&gt;&gt;DB: 批量删除未使用记录\n    ScheduledTask-&gt;&gt;Cache: 清理相关缓存\n</div><h3 id=\"22-数据流设计\">2.2 数据流设计</h3>\n<div class=\"mermaid\">graph TB\n    A[考试发布] --&gt; B[更新状态为Published]\n    B --&gt; C[等待定时任务执行]\n    \n    D[\"定时任务\n    每天凌晨1点\"] --&gt; E[查询已发布且尚未开始的考试]\n    E --&gt; F{是否已预生成?}\n    F --&gt;|是| G[跳过该考试]\n    F --&gt;|否| H[获取学生分组列表]\n    H --&gt; I[分批处理学生列表]\n    I --&gt; J[\"创建ExamRecord\n    Status=NotStarted\"]\n    J --&gt; K[创建ExamAnswerRecord列表]\n    K --&gt; L[\"写入缓存\n    Key: exam:pregenerated:examId:studentId:1\n    Value: recordId\n    Expire: 考试结束时间+1小时\"]\n    L --&gt; M{是否还有批次?}\n    M --&gt;|是| I\n    M --&gt;|否| N[预生成完成]\n    \n    O[学生开始考试] --&gt; P[查询缓存]\n    P --&gt; Q{缓存命中?}\n    Q --&gt;|是| R[加载预生成记录]\n    R --&gt; S[\"更新状态为InProgress\n    设置StartTime\"]\n    S --&gt; T[\"快速启动 ✅\"]\n    Q --&gt;|否| U[动态创建记录]\n    U --&gt; V[\"常规启动 ⚠️\"]\n    \n    W[\"定时清理任务\n    每天凌晨2点\"] --&gt; X[查询已结束考试]\n    X --&gt; Y[查找NotStarted记录]\n    Y --&gt; Z[批量删除]\n    Z --&gt; AA[清理缓存]\n</div><h3 id=\"23-核心组件\">2.3 核心组件</h3>\n<h4 id=\"231-预生成服务-iexamrecordpregenerationservice\">2.3.1 预生成服务 (<code>IExamRecordPreGenerationService</code>)</h4>\n<p><strong>职责</strong>：</p>\n<ul>\n<li>批量预生成考试记录和答题记录</li>\n<li>管理预生成缓存</li>\n<li>提供缓存键生成方法</li>\n</ul>\n<p><strong>关键方法</strong>：</p>\n<ul>\n<li><code>PreGenerateExamRecordsAsync(long examId)</code> - 为指定考试预生成所有学生记录</li>\n<li><code>PreGenerateBatchAsync(long examId, IEnumerable&lt;long&gt; studentIds, int attemptNumber)</code> - 批量预生成指定学生记录</li>\n<li><code>GetPreGeneratedRecordCacheKey(long examId, long studentId, int attemptNumber)</code> - 生成缓存键</li>\n</ul>\n<h4 id=\"232-考试记录服务-examrecordservice\">2.3.2 考试记录服务 (<code>ExamRecordService</code>)</h4>\n<p><strong>职责</strong>：</p>\n<ul>\n<li>智能检测预生成记录</li>\n<li>动态创建记录（降级方案）</li>\n<li>管理记录状态转换</li>\n</ul>\n<p><strong>关键方法</strong>：</p>\n<ul>\n<li><code>CreateExamRecordAsync(long examId, long studentId, ...)</code> - 创建或激活考试记录\n<ul>\n<li>优先查询缓存获取预生成记录ID</li>\n<li>命中则更新状态和开始时间</li>\n<li>未命中则动态创建</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"233-任务处理器\">2.3.3 任务处理器</h4>\n<p><strong>定时预生成任务处理器</strong> (<code>ExamRecordScheduledPreGenerationTaskHandler</code>)：</p>\n<ul>\n<li>定时执行（每天凌晨1点）</li>\n<li>查询所有已发布且尚未开始的考试</li>\n<li>检查是否已预生成，避免重复处理</li>\n<li>分批处理学生列表</li>\n<li>记录详细日志</li>\n</ul>\n<p><strong>手动预生成任务处理器</strong> (<code>ExamRecordPreGenerationTaskHandler</code>)：</p>\n<ul>\n<li>用于手动触发单个考试的预生成</li>\n<li>接收考试ID参数</li>\n<li>分批处理学生列表</li>\n<li>记录详细日志</li>\n</ul>\n<p><strong>清理任务处理器</strong> (<code>ExamRecordCleanupTaskHandler</code>)：</p>\n<ul>\n<li>定时执行（每天凌晨2点）</li>\n<li>清理已结束考试的未使用记录</li>\n<li>同步清理缓存</li>\n</ul>\n<hr />\n<h2 id=\"3-核心设计要点\">3. 核心设计要点</h2>\n<h3 id=\"31-状态管理\">3.1 状态管理</h3>\n<h4 id=\"311-考试记录状态扩展\">3.1.1 考试记录状态扩展</h4>\n<p>新增 <code>NotStarted = 0</code> 状态，用于标识预生成的记录：</p>\n<pre><code class=\"language-csharp\">public enum ExamRecordStatus\n{\n    NotStarted = 0,    // 未开始（预生成状态）\n    InProgress = 1,    // 进行中\n    Submitted = 2,     // 已提交\n    Graded = 3         // 已批改\n}\n</code></pre>\n<h4 id=\"312-状态转换流程\">3.1.2 状态转换流程</h4>\n<pre><code>预生成 → NotStarted\n   ↓\n开始考试 → InProgress\n   ↓\n提交考试 → Submitted\n   ↓\n批改完成 → Graded\n</code></pre>\n<h3 id=\"32-缓存策略\">3.2 缓存策略</h3>\n<h4 id=\"321-缓存键设计\">3.2.1 缓存键设计</h4>\n<pre><code>exam:pregenerated:{examId}:{studentId}:{attemptNumber}\n</code></pre>\n<p><strong>示例</strong>：</p>\n<pre><code>exam:pregenerated:123:456:1\n</code></pre>\n<h4 id=\"322-缓存过期时间\">3.2.2 缓存过期时间</h4>\n<p><strong>核心原则</strong>：缓存过期时间 = 考试结束时间 + 1小时缓冲</p>\n<ul>\n<li>✅ <strong>正常情况</strong>：考试结束时间在未来 → 过期时间 = 结束时间 - 当前时间 + 1小时</li>\n<li>⚠️ <strong>异常情况</strong>：考试已结束或时间异常 → 使用默认7天过期</li>\n</ul>\n<p><strong>设计理由</strong>：</p>\n<ul>\n<li>确保考试期间缓存始终有效</li>\n<li>考试结束后保留1小时缓冲，处理延迟提交等场景</li>\n<li>避免缓存永久占用内存</li>\n</ul>\n<h3 id=\"33-分批处理策略\">3.3 分批处理策略</h3>\n<h4 id=\"331-批次大小\">3.3.1 批次大小</h4>\n<ul>\n<li><strong>默认批次大小</strong>：50 名学生/批</li>\n<li><strong>可配置</strong>：根据系统性能调整（常量 <code>BATCH_SIZE</code>）</li>\n</ul>\n<h4 id=\"332-批次间延迟\">3.3.2 批次间延迟</h4>\n<ul>\n<li><strong>延迟时间</strong>：200 毫秒（常量 <code>DELAY_BETWEEN_BATCHES_MS</code>）</li>\n<li><strong>设计目的</strong>：限制预生成速度，避免对 CPU 和数据库造成过大压力</li>\n<li><strong>执行时机</strong>：每处理完一批学生后，延迟 200ms 再处理下一批</li>\n<li><strong>性能平衡</strong>：在保证预生成效率的同时，不影响系统正常运行</li>\n</ul>\n<h4 id=\"333-开考前自动停止\">3.3.3 开考前自动停止</h4>\n<ul>\n<li><strong>停止阈值</strong>：开考前 5 分钟（常量 <code>STOP_BEFORE_EXAM_START_MINUTES</code>）</li>\n<li><strong>检测机制</strong>：每批次处理前检查当前时间与考试开始时间的间隔</li>\n<li><strong>触发条件</strong>：如果距离考试开始时间不足 5 分钟，立即停止预生成</li>\n<li><strong>设计目的</strong>：\n<ul>\n<li>避免在考试即将开始时进行大量数据库操作，确保系统资源优先服务于学生开考</li>\n<li>减少数据库负载，提升考试开始时的系统响应能力</li>\n</ul>\n</li>\n<li><strong>日志记录</strong>：停止时会记录已处理和剩余的学生数量</li>\n</ul>\n<p><strong>示例日志</strong>：</p>\n<pre><code>⚠️ 距离考试开始时间不足 5 分钟，停止预生成。已处理: 800/1000，剩余: 200 名学生未处理\n</code></pre>\n<h4 id=\"334-处理流程\">3.3.4 处理流程</h4>\n<ol>\n<li>获取所有需要预生成的学生ID列表</li>\n<li>按批次大小切分（默认 50 名/批）</li>\n<li><strong>检查开考时间</strong>：如果距开考不足 5 分钟，停止预生成</li>\n<li>每批使用事务保证原子性</li>\n<li>批次间延迟 200ms，避免系统压力过大</li>\n<li>记录每批成功/失败数量</li>\n<li>打印详细日志便于跟踪</li>\n</ol>\n<h3 id=\"34-容错机制\">3.4 容错机制</h3>\n<h4 id=\"341-预生成失败处理\">3.4.1 预生成失败处理</h4>\n<ul>\n<li><strong>不影响发布流程</strong>：预生成任务异步执行，失败不影响考试发布</li>\n<li><strong>降级方案</strong>：预生成失败的学生，开始考试时自动降级为动态创建</li>\n<li><strong>日志记录</strong>：详细记录失败原因和学生ID，便于排查</li>\n</ul>\n<h4 id=\"342-新增学生处理\">3.4.2 新增学生处理</h4>\n<ul>\n<li><strong>不预生成</strong>：考试发布后新增的学生，不进行预生成</li>\n<li><strong>动态创建</strong>：新增学生开始考试时，使用动态创建逻辑</li>\n<li><strong>性能影响</strong>：新增学生比例通常较低（&lt;5%），不影响整体性能</li>\n</ul>\n<h3 id=\"35-数据过滤\">3.5 数据过滤</h3>\n<h4 id=\"351-监控界面过滤\">3.5.1 监控界面过滤</h4>\n<ul>\n<li><strong>默认排除</strong>：监控和管理界面默认排除 <code>NotStarted</code> 状态的记录</li>\n<li><strong>可选查询</strong>：如需查看预生成记录，可显式指定状态查询</li>\n</ul>\n<h4 id=\"352-查询优化\">3.5.2 查询优化</h4>\n<pre><code class=\"language-sql\">-- 默认查询（排除预生成记录）\nSELECT * FROM ExamRecord \nWHERE Status != 0  -- NotStarted\n\n-- 显式查询预生成记录\nSELECT * FROM ExamRecord \nWHERE Status = 0  -- NotStarted\n</code></pre>\n<hr />\n<h2 id=\"4-性能优化\">4. 性能优化</h2>\n<h3 id=\"41-性能指标\">4.1 性能指标</h3>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>优化前</th>\n<th>优化后</th>\n<th>提升</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>开始考试耗时</td>\n<td>200-500ms</td>\n<td>10-50ms</td>\n<td><strong>90%+</strong></td>\n</tr>\n<tr>\n<td>数据库写入压力</td>\n<td>高峰期集中</td>\n<td>分散到发布时</td>\n<td><strong>98%</strong></td>\n</tr>\n<tr>\n<td>并发支持能力</td>\n<td>500+</td>\n<td>1000+</td>\n<td><strong>2倍</strong></td>\n</tr>\n<tr>\n<td>缓存命中率</td>\n<td>-</td>\n<td>&gt;85%</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"42-优化措施\">4.2 优化措施</h3>\n<h4 id=\"421-缓存优先查询\">4.2.1 缓存优先查询</h4>\n<ul>\n<li>开始考试时优先查询缓存，命中则直接加载记录</li>\n<li>缓存未命中才查询数据库，减少数据库压力</li>\n</ul>\n<h4 id=\"422-批量操作\">4.2.2 批量操作</h4>\n<ul>\n<li>预生成时使用批量插入（<code>AddRangeAsync</code>）</li>\n<li>清理时使用批量删除（<code>DeleteRangeAsync</code>）</li>\n</ul>\n<h4 id=\"423-事务优化\">4.2.3 事务优化</h4>\n<ul>\n<li>每批预生成使用独立事务，避免大事务锁表</li>\n<li>开始考试时使用分布式锁，防止并发创建</li>\n</ul>\n<hr />\n<h2 id=\"5-实施要点\">5. 实施要点</h2>\n<h3 id=\"51-关键时机\">5.1 关键时机</h3>\n<h4 id=\"511-预生成触发\">5.1.1 预生成触发</h4>\n<ul>\n<li><strong>触发时机</strong>：定时任务（每天凌晨1点）</li>\n<li><strong>执行方式</strong>：定时任务统一执行，避免影响正在进行的考试</li>\n<li><strong>执行范围</strong>：\n<ul>\n<li>仅预生成已发布且尚未开始的考试（<code>Status = Published</code> AND <code>StartTime &gt; 当前时间</code>）</li>\n<li>仅预生成第一次考试记录（<code>AttemptNumber = 1</code>）</li>\n<li>自动跳过已预生成的考试，避免重复处理</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"512-清理触发\">5.1.2 清理触发</h4>\n<ul>\n<li><strong>触发时机</strong>：定时任务（每天凌晨2点）</li>\n<li><strong>清理条件</strong>：\n<ul>\n<li>考试已结束（<code>EndTime &lt; 当前时间</code>）</li>\n<li>记录状态为 <code>NotStarted</code></li>\n<li>创建时间早于阈值（默认7天前）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"52-日志记录\">5.2 日志记录</h3>\n<h4 id=\"521-定时预生成日志\">5.2.1 定时预生成日志</h4>\n<pre><code>[INFO] ========================================\n[INFO] 考试记录定时预生成任务开始执行\n[INFO] ========================================\n[INFO] 找到 3 个已发布且尚未开始的考试\n[INFO] 考试 123 (数学期末考试) 已预生成，跳过\n[INFO] 开始为考试 456 (英语期末考试) 预生成记录\n[INFO] 获取到 1000 名学生需要预生成记录\n[INFO] 开始分批预生成，每批 50 名学生，共 20 批，批次间延迟 200ms\n[INFO] 第 1/20 批完成：成功 50，失败 0\n...\n[WARN] ⚠️ 距离考试开始时间不足 5 分钟，停止预生成。已处理: 800/1000，剩余: 200 名学生未处理\n[INFO] 考试 456 预生成完成 - 成功: 798, 跳过: 200\n[INFO] 定时预生成完成 - 总计: 3, 成功: 2, 跳过: 1, 失败: 0\n[INFO] ========================================\n</code></pre>\n<h4 id=\"522-开始考试日志\">5.2.2 开始考试日志</h4>\n<pre><code>[INFO] ✅ 命中预生成记录，快速启动：考试ID=123, 学生ID=456, 记录ID=789\n[WARN] ⚠️ 未命中预生成记录，执行动态创建：考试ID=123, 学生ID=999\n</code></pre>\n<h3 id=\"53-配置说明\">5.3 配置说明</h3>\n<h4 id=\"531-预生成性能控制参数\">5.3.1 预生成性能控制参数</h4>\n<p>以下配置参数在 <code>ExamRecordPreGenerationService.cs</code> 中以常量形式定义：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>默认值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>BATCH_SIZE</code></td>\n<td>50</td>\n<td>每批次处理的学生数量</td>\n</tr>\n<tr>\n<td><code>DELAY_BETWEEN_BATCHES_MS</code></td>\n<td>200ms</td>\n<td>批次间延迟时间，避免系统压力过大</td>\n</tr>\n<tr>\n<td><code>STOP_BEFORE_EXAM_START_MINUTES</code></td>\n<td>5分钟</td>\n<td>开考前多久停止预生成，确保系统资源优先服务于考试</td>\n</tr>\n</tbody>\n</table>\n<p><strong>调整建议</strong>：</p>\n<ul>\n<li><strong>批次大小</strong>：根据数据库性能调整，性能较好的系统可增大到 100</li>\n<li><strong>批次延迟</strong>：如果系统负载高，可增加到 500ms；负载低可减少到 100ms</li>\n<li><strong>停止阈值</strong>：建议保持 5 分钟，确保考试开始前系统稳定</li>\n</ul>\n<h4 id=\"532-定时任务配置\">5.3.2 定时任务配置</h4>\n<pre><code class=\"language-json\">{\n  \"ScheduledTasks\": {\n    \"Tasks\": [\n      {\n        \"Id\": \"exam-record-scheduled-pregeneration\",\n        \"Name\": \"考试记录定时预生成\",\n        \"Description\": \"每天凌晨1点为所有已发布且尚未开始的考试预生成记录\",\n        \"Type\": \"Cron\",\n        \"CronExpression\": \"0 0 1 * * *\",\n        \"HandlerType\": \"CodeSpirit.ExamApi.Tasks.ExamRecordScheduledPreGenerationTaskHandler\",\n        \"Timeout\": \"00:30:00\",\n        \"Enabled\": true\n      },\n      {\n        \"Id\": \"exam-record-cleanup\",\n        \"Name\": \"考试记录垃圾数据清理\",\n        \"Description\": \"清理未使用的预生成考试记录\",\n        \"HandlerType\": \"CodeSpirit.ExamApi.Tasks.ExamRecordCleanupTaskHandler\",\n        \"CronExpression\": \"0 0 2 * * *\",\n        \"Parameters\": \"{\\\"cleanupDays\\\": 7}\",\n        \"Enabled\": true\n      }\n    ]\n  }\n}\n</code></pre>\n<p><strong>Cron表达式说明</strong>：</p>\n<ul>\n<li><code>0 0 1 * * *</code> 表示每天凌晨1点执行（预生成任务）</li>\n<li><code>0 0 2 * * *</code> 表示每天凌晨2点执行（清理任务）</li>\n</ul>\n<hr />\n<h2 id=\"6-注意事项\">6. 注意事项</h2>\n<h3 id=\"61-数据一致性\">6.1 数据一致性</h3>\n<ul>\n<li>✅ <strong>题目顺序</strong>：预生成时确定题目顺序，避免并发冲突</li>\n<li>✅ <strong>事务保证</strong>：每批预生成使用事务，保证原子性</li>\n<li>✅ <strong>分布式锁</strong>：开始考试时使用分布式锁，防止重复创建</li>\n</ul>\n<h3 id=\"62-缓存一致性\">6.2 缓存一致性</h3>\n<ul>\n<li>✅ <strong>写入时机</strong>：预生成完成后立即写入缓存</li>\n<li>✅ <strong>更新时机</strong>：开始考试时清除预生成缓存</li>\n<li>✅ <strong>清理时机</strong>：定时清理任务同步清理缓存</li>\n</ul>\n<h3 id=\"63-监控建议\">6.3 监控建议</h3>\n<ul>\n<li>📊 <strong>预生成成功率</strong>：监控预生成任务的成功/失败比例</li>\n<li>📊 <strong>缓存命中率</strong>：监控开始考试时的缓存命中率</li>\n<li>📊 <strong>清理效果</strong>：监控定时清理任务删除的记录数量</li>\n<li>📊 <strong>性能指标</strong>：监控开始考试的响应时间分布</li>\n<li>📊 <strong>提前停止情况</strong>：监控预生成任务是否因接近开考时间而提前停止，如频繁发生应考虑提前发布考试</li>\n<li>📊 <strong>系统负载</strong>：监控预生成过程中的 CPU 和数据库负载，必要时调整批次大小和延迟时间</li>\n</ul>\n<h3 id=\"64-扩展性考虑\">6.4 扩展性考虑</h3>\n<ul>\n<li>🔄 <strong>多数据库支持</strong>：预生成逻辑与数据库类型无关，支持SQL Server和MySQL</li>\n<li>🔄 <strong>水平扩展</strong>：预生成任务可分布式执行，支持多实例部署</li>\n<li>🔄 <strong>配置化</strong>：批次大小、批次延迟、停止阈值等参数可配置，便于调优</li>\n</ul>\n<h3 id=\"65-性能调优建议\">6.5 性能调优建议</h3>\n<h4 id=\"651-批次大小调优\">6.5.1 批次大小调优</h4>\n<ul>\n<li><strong>小规模考试（&lt;500人）</strong>：批次大小可设为 100，快速完成预生成</li>\n<li><strong>大规模考试（&gt;1000人）</strong>：保持默认 50，避免单批次耗时过长</li>\n<li><strong>超大规模（&gt;5000人）</strong>：可减小到 30，配合更长的批次延迟（500ms）</li>\n</ul>\n<h4 id=\"652-发布时机建议\">6.5.2 发布时机建议</h4>\n<ul>\n<li><strong>推荐</strong>：考试开始前至少 1 天发布，确保在次日凌晨1点完成预生成</li>\n<li><strong>最低要求</strong>：考试开始前至少 1 小时发布（如果发布时间晚于凌晨1点，预生成将在下一个凌晨1点执行）</li>\n<li><strong>注意事项</strong>：\n<ul>\n<li>预生成任务在每天凌晨1点统一执行，不会在发布时立即执行</li>\n<li>如果考试在凌晨1点之后发布且当天开考，首批学生会使用动态创建模式（性能略差）</li>\n<li>建议提前发布考试，以便享受预生成带来的性能优化</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"653-系统负载控制\">6.5.3 系统负载控制</h4>\n<ul>\n<li><strong>高负载时段</strong>：增加批次延迟到 500ms，减少对正在进行的考试的影响</li>\n<li><strong>低负载时段</strong>：可减少批次延迟到 100ms，加快预生成速度</li>\n<li><strong>监控指标</strong>：CPU 使用率 &gt; 70% 或数据库连接数 &gt; 80% 时，应调整参数</li>\n</ul>\n<hr />\n<h2 id=\"7-测试验证\">7. 测试验证</h2>\n<h3 id=\"71-功能验证\">7.1 功能验证</h3>\n<ol>\n<li>\n<p><strong>预生成功能</strong></p>\n<ul>\n<li>✅ 发布考试后检查后台日志，确认预生成任务执行</li>\n<li>✅ 查询数据库，验证记录已创建且状态为 <code>NotStarted</code></li>\n<li>✅ 验证缓存中已写入预生成记录ID</li>\n</ul>\n</li>\n<li>\n<p><strong>智能启动</strong></p>\n<ul>\n<li>✅ 学生开始考试，检查是否命中预生成记录</li>\n<li>✅ 测量启动耗时（应降低到 10-50ms）</li>\n<li>✅ 验证题目顺序正确</li>\n</ul>\n</li>\n<li>\n<p><strong>动态补充</strong></p>\n<ul>\n<li>✅ 发布后新增学生到分组</li>\n<li>✅ 该学生开始考试，验证动态创建逻辑</li>\n</ul>\n</li>\n<li>\n<p><strong>垃圾清理</strong></p>\n<ul>\n<li>✅ 等待定时任务执行（或手动触发）</li>\n<li>✅ 检查日志和数据库，确认垃圾数据被清理</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"72-性能测试\">7.2 性能测试</h3>\n<ul>\n<li>📈 <strong>并发压力测试</strong>：模拟1000学生同时开考</li>\n<li>📈 <strong>对比测试</strong>：对比预生成前后的数据库压力和响应时间</li>\n<li>📈 <strong>缓存命中率测试</strong>：统计不同场景下的缓存命中率</li>\n</ul>\n<hr />\n<h2 id=\"8-总结\">8. 总结</h2>\n<p>考试记录预生成方案通过<strong>提前创建</strong>和<strong>缓存优化</strong>两大核心策略，显著提升了系统在高并发场景下的性能和用户体验。方案设计充分考虑了容错、扩展性和可维护性，是一个<strong>生产级</strong>的优化方案。</p>\n<h3 id=\"81-核心价值\">8.1 核心价值</h3>\n<ul>\n<li>🚀 <strong>性能提升</strong>：开始考试耗时降低 90%+</li>\n<li>💪 <strong>并发优化</strong>：数据库压力降低 98%</li>\n<li>😊 <strong>用户体验</strong>：无感知延迟，即刻进入考试</li>\n<li>🔒 <strong>数据一致性</strong>：题目顺序预先确定，避免冲突</li>\n</ul>\n<h3 id=\"82-适用场景\">8.2 适用场景</h3>\n<ul>\n<li>✅ 大规模考试（1000+ 学生）</li>\n<li>✅ 高并发开考场景</li>\n<li>✅ 对响应时间敏感的应用</li>\n<li>✅ 需要提升用户体验的场景</li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    作者：<a href=\"http://www.cnblogs.com/codelove/\" target=\"_blank\">雪雁</a><br />出处：<a href=\"http://www.cnblogs.com/codelove/\" target=\"_blank\">http://www.cnblogs.com/codelove/</a>\n<br />如果喜欢作者的文章，请关注【CodeSpirit-码灵】公众号以便第一时间获得最新内容。本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。<br /><b>静听鸟语花香，漫赏云卷云舒。</b>\n<br />\n<img height=\"100\" src=\"https://images.cnblogs.com/cnblogs_com/codelove/315887/o_251224070213_%E5%85%AC%E4%BC%97%E5%8F%B7.jpg\" width=\"100\" />\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-06 23:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/codelove\">雪雁</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （二）循环神经网络",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19449622",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19449622\" id=\"cb_post_title_url\" title=\"发布于 2026-01-06 22:53\">\n    <span>吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （二）循环神经网络</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第一周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=152\" rel=\"noopener nofollow\" target=\"_blank\">1.2</a>到<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.player.switch&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=154\" rel=\"noopener nofollow\" target=\"_blank\">1.4</a>的内容。</p>\n<hr />\n<p>本周为第五课的第一周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本篇的内容关于<strong>循环神经网络</strong>，在 NLP 中，循环神经网络就像卷积网络在 CV 中一样，是处理序列数据的核心特化模型，专门用于捕捉上下文依赖。</p>\n<h1 id=\"1-nlp-中的符号规范\">1. NLP 中的符号规范</h1>\n<p>在正式开始引入循环神经网络前，我们同样需要先了解一些相关的符号规范，主要是在数据的表示方面。</p>\n<h2 id=\"11-模型的输入与输出\">1.1 模型的输入与输出</h2>\n<p><img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260106225017927-302231808.png\" /><br />\n再复述一下：</p>\n<ol>\n<li><span class=\"math inline\">\\(x^{&lt;t&gt;}\\)</span> ：<strong>输入序列在第 <span class=\"math inline\">\\(t\\)</span> 个时间步的输入</strong>。</li>\n<li><span class=\"math inline\">\\(y^{&lt;t&gt;}\\)</span> ：<strong>输出序列在第 <span class=\"math inline\">\\(t\\)</span> 个时间步的输出</strong>。</li>\n<li><span class=\"math inline\">\\(T_x\\)</span>：<strong>输入序列的长度</strong>。</li>\n<li><span class=\"math inline\">\\(T_y\\)</span>：<strong>输出序列的长度</strong>。</li>\n</ol>\n<p>现在，结合我们之前的符号规范，就可以知道：<br />\n<strong><span class=\"math inline\">\\(X^{(n)&lt;t&gt;}\\)</span> 代表一批次输入中第 <span class=\"math inline\">\\(n\\)</span> 个样本的第 <span class=\"math inline\">\\(t\\)</span> 个元素。</strong></p>\n<h2 id=\"12-词典vocabulary\">1.2 词典（Vocabulary）</h2>\n<p>经过上一部分，我们知道，<span class=\"math inline\">\\(x^{&lt;t&gt;}\\)</span> 代表了一个序列中的某一个元素。<br />\n但是又有一个新的问题：在 NLP 任务中，<span class=\"math inline\">\\(x^{&lt;t&gt;}\\)</span> 往往是一个<strong>离散的符号</strong>，例如某个具体的词（如 <em>hello</em>、<em>Hi</em>），而神经网络本质上只能处理<strong>数值向量</strong>，并不能直接理解“词”这一抽象概念。</p>\n<p>因此，在将文本序列送入模型之前，我们必须先完成一件事情：给“词”一个能输入网络的表示方法，<strong>即建立一种从“词”到“数值表示”的映射规则。</strong><br />\n显然，这种映射关系必须是<strong>确定且唯一的</strong>，即每一个词都对应一个唯一的数值表示。<br />\n而<strong>其中一种</strong>表示方法，就是我们在多分类标签表示中使用的<strong>独热编码</strong>。<br />\n我们看一个简单的示例：<br />\n假设我们当前的<strong>词典</strong>只包含 4 个词：</p>\n<p></p><div class=\"math display\">\\[{\\text{hello},\\ \\text{Hi},\\ \\text{thanks},\\ \\text{bye}}\n\\]</div><p></p><p>我们可以为词典中的每一个词分配一个唯一的索引：</p>\n<p></p><div class=\"math display\">\\[\\text{hello}\\rightarrow 1,\\quad \\text{Hi}\\rightarrow 2,\\quad \\text{thanks}\\rightarrow 3,\\quad \\text{bye}\\rightarrow 4\n\\]</div><p></p><p>在这种设定下，每一个词都可以用一个<strong>长度为 4 的独热向量</strong>来表示。<br />\n例如：</p>\n<ul>\n<li><span class=\"math inline\">\\(\\text{hello}\\)</span> 对应的表示为：<span class=\"math inline\">\\(x = [1,0,0,0]\\)</span></li>\n<li><span class=\"math inline\">\\(\\text{Hi}\\)</span> 对应的表示为：<span class=\"math inline\">\\(x = [0,1,0,0]\\)</span><br />\n<strong>词典中的每个词都有且仅有一个位置为 1，其余位置全部为 0。</strong><br />\n从模型的角度来看，这样的表示方式意味着：模型在任意时刻接收到的输入，本质上是一个高维稀疏向量，这正好满足“词 → 数值向量”的一对一映射要求，因此能够直接作为神经网络的输入。</li>\n</ul>\n<p>然而，在真实的 NLP 任务中，一个不可忽视的现实问题是：<strong>词典的规模通常非常巨大。</strong><br />\n在常见的语言建模或翻译任务中，词典大小往往达到<strong>数万甚至百万级别</strong>。<br />\n这意味着：</p>\n<ul>\n<li>独热向量的维度极高</li>\n<li>向量极度稀疏</li>\n<li>计算和存储成本都非常不经济</li>\n</ul>\n<p>因此，在实际模型中，我们往往会采用一种更紧凑、也更具语义表达能力的词表示方法，叫做<strong>词向量（Embedding）</strong> ，我们会在之后的内容详细展开它。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260106224853098-1209020991.png\" /><br />\n此外，还会出现另一个问题：  <strong>测试或实际使用时，可能会遇到词典中从未出现过的词。</strong><br />\n对于这种<strong>不在词典中的词（Out-Of-Vocabulary，OOV）</strong>，常见的一种处理方式是在词典中额外引入一个特殊标记<code>&lt;UNK&gt;</code>，用于统一表示所有未知词，这种方式虽然简单，但也会丢失不同未知词之间的差异性，这也是后续子词建模方法要解决的问题之一。</p>\n<p>这些我们都会在之后的实际演示中详细展开，现在，先了解简单的符号规范后，我们正式开始引入循环神经网络。</p>\n<h1 id=\"2-循环神经网络recurrent-neural-networkrnn\">2. 循环神经网络（Recurrent Neural Network，RNN）</h1>\n<p>在<a href=\"https://www.cnblogs.com/Goblinscholar/p/19437798\" target=\"_blank\">上一篇</a>对序列模型的介绍中，我们已经知道：全连接网络和卷积网络并不适合用来处理序列数据。<br />\n我们需要一种模型，<strong>在处理当前输入的同时，能够保留并更新对“过去信息”的表示，让模型在理解当前内容时，不是孤立地“看这一刻”，而是基于整个上下文来判断。</strong><br />\n而这，就是 RNN 的基本思想。<br />\nRNN最早可追溯到 Jordan（1986）对序列连接主义模型的研究，而现代深度学习中常用的 RNN 基本形式，则来源于 Elman 在1990年发表的一篇论文： <a href=\"https://langev.com/pdf/elman90findingStructure.pdf?\" rel=\"noopener nofollow\" target=\"_blank\">Finding Structure in Time</a>中提出的递归状态网络结构。<br />\n可以看到，尽管论文距今已有几十年，但像最初的 CNN 一样，RNN 的思想并没有被时间淹没，而是不断被推广和创新，最终成为现代 NLP 中不可或缺的基础模型。</p>\n<p>现在，我们用一个最简单的<strong>单层循环神经网络</strong>来介绍 RNN 的传播过程及其特点。</p>\n<h2 id=\"21-单层循环神经网络的结构\">2.1 单层循环神经网络的结构</h2>\n<p>来看课程里这样一个循环网络的<strong>传播示意图</strong>：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260106224834808-1322487049.png\" /><br />\n你可能会觉得，这个结构看起来好像不像传统意义上的“单层网络”，反而更像每一层都直接接收原始输入的全连接网络。<br />\n其实这正体现了 RNN 与 FN 或 CNN 的本质区别：<strong>在 RNN 中，每个时间步的隐藏状态不会直接传给下一层，而是传递给下一个时间步的自身。</strong><br />\n也就是说，这个网络的实际结构是这样的：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260106224835295-122620775.png\" /><br />\n也就是说，RNN 本质上就是<strong>在全连接层基础上加了时间维度的循环连接</strong>。<br />\n你会发现，<strong>如果抛开传播逻辑不看，单层循环网络实际上就是一层全连接层。</strong><br />\n但这也恰恰说明了它的传播逻辑的重要性，到底是怎么样的设计能让单层的全连接层一跃而成为 NLP 的基石？<br />\n我们继续。</p>\n<h2 id=\"22-单层循环神经网络的正向传播\">2.2 单层循环神经网络的正向传播</h2>\n<p>了解了 RNN 的基本逻辑后， 现在，我们就来演示一下单层 RNN 的具体传播过程中的一些细节：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260106224834545-1669402886.png\" /><br />\n了解了这些后，我们规范一下单层 RNN 的正向传播过程：</p>\n<ol>\n<li><strong>初始状态</strong><br />\nRNN 在第一个时间步输入第一个元素 <span class=\"math inline\">\\(x^{&lt;1&gt;}\\)</span>（例如“韩”）时，同时会引入初始的伪激活值 (<span class=\"math inline\">\\(a^{&lt;0&gt;}\\)</span>) 作为网络的初始状态，<span class=\"math inline\">\\(a^{&lt;0&gt;}\\)</span> 通常设为零向量或随机初始化。</li>\n<li><strong>逐步处理序列</strong><br />\n每个时间步，RNN 会将当前输入 <span class=\"math inline\">\\(x^{&lt;t&gt;}\\)</span> 与上一时间步的隐藏状态 <span class=\"math inline\">\\(a^{&lt;t-1&gt;}\\)</span> 一起输入网络，计算当前的隐藏状态 <span class=\"math inline\">\\(a^{&lt;t&gt;}\\)</span>,例如在第二步，输入为 <span class=\"math inline\">\\(x^{&lt;2&gt;}\\)</span>（“信”）和 <span class=\"math inline\">\\(a^{&lt;1&gt;}\\)</span>，得到 <span class=\"math inline\">\\(a^{&lt;2&gt;}\\)</span>。</li>\n<li><strong>输出生成</strong><br />\n每一步的隐藏状态 <span class=\"math inline\">\\(a^{&lt;t&gt;}\\)</span> 都会产生一个预测输出 <span class=\"math inline\">\\(\\hat{y}^{&lt;t&gt;}\\)</span>。输出不仅依赖当前输入，也包含了前面时间步的历史信息，这就是 RNN 能够“记忆”序列上下文的原因。</li>\n<li><strong>信息传递</strong><br />\n隐藏状态会沿时间步向后传递，使后续时间步的输出能够利用之前所有的序列信息，最终一步输出 <span class=\"math inline\">\\(\\hat{y}^{&lt;T_x&gt;}\\)</span> 包含整个序列的信息，可用于完整序列的预测或判断。</li>\n</ol>\n<p>明白了传播逻辑后，我们便可以更好地理解 RNN 正向传播的公式表达，我们先<strong>说明一下网络中的参数表示：</strong><br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260106225018168-1671840978.png\" /><br />\n现在便摆出正向传播的通式如下：</p>\n<p></p><div class=\"math display\">\\[a^{&lt;t&gt;} = g(W_{aa} a^{&lt;t-1&gt;} + W_{ax} x^{&lt;t&gt;} + b_a)\n\\]</div><p></p><p></p><div class=\"math display\">\\[y^{&lt;t&gt;} = g(W_{ya} a^{&lt;t&gt;} + b_y)\n\\]</div><p></p><p>总结一下：RNN 的正向传播就是<strong>每个时间步将当前输入和上一隐藏状态结合，更新当前隐藏状态并生成输出，隐藏状态沿时间步传递，从而使网络能够逐步累积和利用序列历史信息</strong>。</p>\n<p>了解了正向传播的大致流程后，我们再看看 RNN 的反向传播是如何进行的。</p>\n<h2 id=\"23-单层循环神经网络的反向传播\">2.3 单层循环神经网络的反向传播</h2>\n<p>经过上一部分，我们已经知道：RNN 的正向传播，本质上是在<strong>时间维度上反复使用同一组参数</strong>，并通过隐藏状态把历史信息向后传递。</p>\n<p>那么问题自然就来了：  <strong>这些跨时间步传递的信息，反向传播时该怎么“算梯度”？</strong></p>\n<p>答案是： 怎么过去就怎么回来——RNN 的反向传播，并不是在“层”之间传播，而是<strong>在时间维度上反向传播</strong>，这种传播被称为 <strong>BPTT（Backpropagation Through Time）</strong> 。<br />\n我们来简要演示一下这个过程：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260106225121561-283647183.png\" /></p>\n<p>在监督学习中，反向传播的起点永远是<strong>损失函数</strong>，对于 RNN 来说，损失通常是<strong>所有时间步损失的累加</strong>（默认 <span class=\"math inline\">\\(T_x = T_y\\)</span>）：</p>\n<p></p><div class=\"math display\">\\[\\mathcal{L}\n=\n\\sum_{t=1}^{T_x}\n\\mathcal{L}^{&lt;t&gt;}(\\hat{y}^{&lt;t&gt;}, y^{&lt;t&gt;})\n\\]</div><p></p><p>也就是说，<strong>每一个时间步的输出都会对总损失产生贡献</strong>。<br />\n而对于单步的损失，最常用的仍然是我们比较熟悉的<a href=\"https://www.cnblogs.com/Goblinscholar/p/19133349\" target=\"_blank\">交叉熵损失</a>,你可以通过链接查看我们之前的介绍，应用在 RNN 中，它的公式是这样的：</p>\n<p></p><div class=\"math display\">\\[\\mathcal{L}\n=\n\\sum_{t=1}^{T_x}\n\\left(\n- \\sum_{k=1}^{C} y_k^{&lt;t&gt;} \\log \\hat{y}_k^{&lt;t&gt;}\n\\right)\n\\]</div><p></p><p>因此，反向传播时，我们会从最后一个时间步开始，逐步向前，把每个时间步的误差信号往回传， 由于参数在所有时间步共享，每个时间步的损失都会通过时间链路对这些参数产生梯度贡献，最终用于更新的梯度，是<strong>沿时间维度反向传播后，各时间步贡献的综合结果</strong>。</p>\n<p>这就是单层循环神经网络的反向传播，这样我们就对 RNN 的基本运行逻辑有了大体的了解。</p>\n<h1 id=\"3总结\">3.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>序列数据</td>\n<td>数据元素具有<strong>明确顺序</strong>，当前理解依赖历史上下文</td>\n<td>一句话的意思要从前往后读，不能只看中间一个词。</td>\n</tr>\n<tr>\n<td>时间步 <span class=\"math inline\">\\(t\\)</span></td>\n<td>序列中第 <span class=\"math inline\">\\(t\\)</span> 个位置，用于展开时间维度</td>\n<td>时间轴上的第 <span class=\"math inline\">\\(t\\)</span> 帧画面。</td>\n</tr>\n<tr>\n<td>输入 <span class=\"math inline\">\\(x^{}\\)</span></td>\n<td>第 <span class=\"math inline\">\\(t\\)</span> 个时间步送入模型的输入向量</td>\n<td>当前这一秒你听到的一个词。</td>\n</tr>\n<tr>\n<td>预测输出 <span class=\"math inline\">\\(\\hat{y}^{}\\)</span></td>\n<td>模型在第 <span class=\"math inline\">\\(t\\)</span> 个时间步给出的预测结果</td>\n<td>听到一句话后，此刻你做出的判断。</td>\n</tr>\n<tr>\n<td>序列长度 <span class=\"math inline\">\\(T_x, T_y\\)</span></td>\n<td>输入序列与输出序列的长度（可相同或不同）</td>\n<td>一段话的字数 vs 你回答时说了几句话。</td>\n</tr>\n<tr>\n<td>词典（Vocabulary）</td>\n<td>从词到索引的<strong>一一映射表</strong></td>\n<td>电话簿：名字 ↔ 电话号码</td>\n</tr>\n<tr>\n<td>RNN 核心思想</td>\n<td>当前状态由<strong>当前输入 + 过去状态</strong>共同决定</td>\n<td>你理解一句话时，会不断修正之前的理解。</td>\n</tr>\n<tr>\n<td>BPTT</td>\n<td>梯度沿时间维度反向传播</td>\n<td>从句尾倒回去反思：是哪一步理解错了。</td>\n</tr>\n<tr>\n<td>梯度累积</td>\n<td>参数梯度来自所有时间步的综合贡献</td>\n<td>每一句话的错误都会影响你下次的理解方式。</td>\n</tr>\n</tbody>\n</table>\n<p>。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-06 22:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AUC 的两种等价定义：从排序概率到 ROC 曲线的统一理解",
      "link": "https://www.cnblogs.com/GlenTt/p/19449279",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GlenTt/p/19449279\" id=\"cb_post_title_url\" title=\"发布于 2026-01-06 20:27\">\n    <span>AUC 的两种等价定义：从排序概率到 ROC 曲线的统一理解</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"auc-的两种等价定义从排序概率到-roc-曲线的统一理解\">AUC 的两种等价定义：从排序概率到 ROC 曲线的统一理解</h1>\n<p>在推荐系统与广告排序中，AUC 是最常用、也最容易被误解的离线评估指标之一。很多人同时接触过两种说法：<br />\n一种是“ROC 曲线下面积”，另一种是“正样本排在负样本前面的概率”。<strong>这并不是两种不同的指标，而是同一个指标的两种完全等价的定义</strong>。</p>\n<h2 id=\"一auc-的本质一个排序概率\">一、AUC 的本质：一个排序概率</h2>\n<h3 id=\"1-问题设定\">1. 问题设定</h3>\n<p>假设我们面对的是一个二分类 / 排序问题：</p>\n<ul>\n<li>每个样本 <span class=\"math inline\">\\(x_i\\)</span> 有真实标签 <span class=\"math inline\">\\(y_i \\in {0,1}\\)</span></li>\n<li>模型给出一个连续预测分数 <span class=\"math inline\">\\(s_i \\in \\mathbb{R}\\)</span></li>\n<li>分数越大，模型认为样本“越可能是正样本”</li>\n</ul>\n<p>定义：</p>\n<ul>\n<li>正样本集合<p></p><div class=\"math display\">\\[P = { i \\mid y_i = 1 }\n\\]</div><p></p></li>\n<li>负样本集合<p></p><div class=\"math display\">\\[N = { j \\mid y_j = 0 }\n\\]</div><p></p></li>\n</ul>\n<h3 id=\"2-auc-的概率定义最本质定义\">2. AUC 的概率定义（最本质定义）</h3>\n<p><strong>AUC 的概率定义是：</strong></p>\n<p>从正样本集合中随机抽取一个样本，从负样本集合中随机抽取一个样本，<br />\n正样本的预测分数大于负样本预测分数的概率。</p>\n<p>其数学形式为：</p>\n<p></p><div class=\"math display\">\\[\\mathrm{AUC}\n=\n\n\\frac{1}{|P|\\cdot|N|}\n\\sum_{p \\in P}\\sum_{n \\in N}\n\\left[\n\\mathbb{I}(s_p &gt; s_n)\n+\n\\frac{1}{2}\\mathbb{I}(s_p = s_n)\n\\right]\n\\]</div><p></p><p>其中：</p>\n<ul>\n<li><span class=\"math inline\">\\(\\mathbb{I}(\\cdot)\\)</span> 为指示函数</li>\n<li>当 <span class=\"math inline\">\\(s_p = s_n\\)</span> 时记为 <span class=\"math inline\">\\(0.5\\)</span>，表示随机打平</li>\n</ul>\n<h3 id=\"3-这一点意味着什么\">3. 这一点意味着什么？</h3>\n<ul>\n<li>AUC <strong>不依赖任何阈值</strong></li>\n<li>AUC <strong>不是一个分类指标，而是一个排序指标</strong></li>\n<li>AUC 衡量的是：<br />\n<strong>模型是否倾向于把正样本整体排在负样本前面</strong></li>\n</ul>\n<p>这也是为什么在推荐系统中，即便最终没有明确的“正负分类决策”，AUC 依然是最核心的离线评估指标之一。</p>\n<h2 id=\"二roc-曲线定义几何视角下的同一个量\">二、ROC 曲线定义：几何视角下的同一个量</h2>\n<h3 id=\"1-roc-曲线如何构造\">1. ROC 曲线如何构造</h3>\n<p>给定一组预测分数 <span class=\"math inline\">\\(s_i\\)</span>，我们引入一个阈值 <span class=\"math inline\">\\(\\tau\\)</span>：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(s_i \\ge \\tau\\)</span>，预测为正类</li>\n<li>若 <span class=\"math inline\">\\(s_i &lt; \\tau\\)</span>，预测为负类</li>\n</ul>\n<p>在每一个阈值 <span class=\"math inline\">\\(\\tau\\)</span> 下，可以计算：</p>\n<ul>\n<li>真阳性率（TPR）<p></p><div class=\"math display\">\\[\\mathrm{TPR}(\\tau)\n=\n\n\\frac{\\mathrm{TP}}{\\mathrm{P}}\n\\]</div><p></p></li>\n<li>假阳性率（FPR）<p></p><div class=\"math display\">\\[\\mathrm{FPR}(\\tau)\n=\n\n\\frac{\\mathrm{FP}}{\\mathrm{N}}\n\\]</div><p></p></li>\n</ul>\n<p>当阈值 <span class=\"math inline\">\\(\\tau\\)</span> 从 <span class=\"math inline\">\\(+\\infty\\)</span> 连续下降到 <span class=\"math inline\">\\(-\\infty\\)</span> 时，<br />\n点对 <span class=\"math inline\">\\((\\mathrm{FPR}(\\tau), \\mathrm{TPR}(\\tau))\\)</span> 在平面上形成一条曲线，即 <strong>ROC 曲线</strong>。</p>\n<h3 id=\"2-auc-的-roc-定义\">2. AUC 的 ROC 定义</h3>\n<p><strong>AUC 定义为 ROC 曲线下方的面积：</strong></p>\n<p></p><div class=\"math display\">\\[\\mathrm{AUC}\n=\n\n\\int_0^1 \\mathrm{TPR}(\\mathrm{FPR}) , d(\\mathrm{FPR})\n\\]</div><p></p><p>这是一个<strong>几何意义上的定义</strong>。</p>\n<h2 id=\"三两种定义为什么是完全等价的\">三、两种定义为什么是完全等价的？</h2>\n<p>一个统计学习中的经典结论是：</p>\n<p></p><div class=\"math display\">\\[\\boxed{\n\\mathrm{AUC}\n=\n\nP(s^+ &gt; s^-)\n}\n\\]</div><p></p><p>其中 <span class=\"math inline\">\\(s^+\\)</span> 表示正样本分数，<span class=\"math inline\">\\(s^-\\)</span> 表示负样本分数。</p>\n<p>直观解释如下：</p>\n<ul>\n<li>ROC 曲线本质是在 <strong>按照 score 从高到低扫描排序结果</strong></li>\n<li>每遇到一个正样本，TPR 增加</li>\n<li>每遇到一个负样本，FPR 增加</li>\n<li>某个正样本是否“早于”负样本被扫描到，正对应于<p></p><div class=\"math display\">\\[s^+ &gt; s^-\n\\]</div><p></p></li>\n</ul>\n<p>因此：</p>\n<blockquote>\n<p><strong>ROC 曲线下面积，等价于所有正负样本对中，排序正确的比例。</strong></p>\n</blockquote>\n<p>ROC 只是将“排序关系”用几何方式进行了表达。</p>\n<h2 id=\"四一个完整可手算的例子\">四、一个完整、可手算的例子</h2>\n<h3 id=\"1-样本与预测分数\">1. 样本与预测分数</h3>\n<table>\n<thead>\n<tr>\n<th>样本</th>\n<th>label</th>\n<th>score</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>1</td>\n<td>0.90</td>\n</tr>\n<tr>\n<td>B</td>\n<td>1</td>\n<td>0.60</td>\n</tr>\n<tr>\n<td>C</td>\n<td>0</td>\n<td>0.70</td>\n</tr>\n<tr>\n<td>D</td>\n<td>0</td>\n<td>0.40</td>\n</tr>\n<tr>\n<td>E</td>\n<td>0</td>\n<td>0.20</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>正样本：A, B</li>\n<li>负样本：C, D, E</li>\n<li>正负样本对总数：<span class=\"math inline\">\\(2 \\times 3 = 6\\)</span></li>\n</ul>\n<hr />\n<h3 id=\"2-按概率定义逐对比较\">2. 按概率定义逐对比较</h3>\n<table>\n<thead>\n<tr>\n<th>正样本</th>\n<th>负样本</th>\n<th>是否排序正确</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A(0.90)</td>\n<td>C(0.70)</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>A(0.90)</td>\n<td>D(0.40)</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>A(0.90)</td>\n<td>E(0.20)</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>B(0.60)</td>\n<td>C(0.70)</td>\n<td>✗</td>\n</tr>\n<tr>\n<td>B(0.60)</td>\n<td>D(0.40)</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>B(0.60)</td>\n<td>E(0.20)</td>\n<td>✓</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>排序正确对数：5</li>\n<li>总对数：6</li>\n</ul>\n<p></p><div class=\"math display\">\\[\\mathrm{AUC} = \\frac{5}{6} \\approx 0.833\n\\]</div><p></p><h2 id=\"五对应的计算代码\">五、对应的计算代码</h2>\n<p>下面给出两种 AUC 计算实现。</p>\n<h3 id=\"1-概率定义两两比较定义直译\">1. 概率定义（两两比较，定义直译）</h3>\n<pre><code class=\"language-python\">def auc_pairwise(labels, scores):\n    \"\"\"\n    基于 AUC 的概率定义（Pairwise Comparison）进行计算。\n\n    输入：\n    - labels: List[int] 或 1D array\n        样本真实标签，取值为 {0, 1}\n        1 表示正样本，0 表示负样本\n    - scores: List[float] 或 1D array\n        模型对每个样本给出的预测分数，分数越大表示越倾向正类\n\n    输出：\n    - auc: float\n        AUC 值，取值范围 [0, 1]\n\n    核心思想：\n    随机取一个正样本 p 和一个负样本 n，\n    统计 P(score_p &gt; score_n) 的比例\n    \"\"\"\n\n    # 提取正样本 (label=1) 的预测分数\n    pos_scores = [s for l, s in zip(labels, scores) if l == 1]\n\n    # 提取负样本 (label=0) 的预测分数\n    neg_scores = [s for l, s in zip(labels, scores) if l == 0]\n\n    # 排序正确的正负样本对数量（允许 0.5 的打平贡献）\n    correct = 0.0\n\n    # 正负样本对的总数量 |P| * |N|\n    total = len(pos_scores) * len(neg_scores)\n\n    # 对所有正负样本对进行两两比较\n    for sp in pos_scores:        # sp: positive sample score\n        for sn in neg_scores:    # sn: negative sample score\n            if sp &gt; sn:\n                # 正样本分数严格大于负样本分数，排序正确\n                correct += 1.0\n            elif sp == sn:\n                # 分数相等，按约定计为 0.5（随机打平）\n                correct += 0.5\n            # sp &lt; sn 时不加分，表示排序错误\n\n    # AUC = 排序正确的比例\n    return correct / total\n</code></pre>\n<p><strong>复杂度分析：</strong></p>\n<ul>\n<li>时间复杂度：<p></p><div class=\"math display\">\\[O(|P| \\cdot |N|)\n\\]</div><p></p>其中 <span class=\"math inline\">\\(|P|\\)</span> 为正样本数，<span class=\"math inline\">\\(|N|\\)</span> 为负样本数</li>\n<li>空间复杂度：<p></p><div class=\"math display\">\\[O(|P| + |N|)\n\\]</div><p></p></li>\n</ul>\n<p><strong>适用场景：</strong></p>\n<ul>\n<li>严格对应 AUC 的概率定义</li>\n<li>适合教学、理论验证、小规模数据</li>\n<li>不适用于工程和大规模离线计算</li>\n</ul>\n<hr />\n<h3 id=\"2-排序--rank-based-实现工程思想\">2. 排序 / Rank-based 实现（工程思想）</h3>\n<pre><code class=\"language-python\">import numpy as np\n\ndef auc_rank(labels, scores):\n    \"\"\"\n    基于排序（Rank / Mann–Whitney U）的 AUC 计算方法。\n\n    输入：\n    - labels: List[int] 或 1D numpy array\n        样本真实标签，取值为 {0, 1}\n    - scores: List[float] 或 1D numpy array\n        模型预测分数，分数越大表示越可能为正样本\n\n    输出：\n    - auc: float\n        AUC 值，取值范围 [0, 1]\n\n    核心思想：\n    1. 按预测分数从小到大排序\n    2. 扫描排序后的样本序列\n    3. 每遇到一个正样本，统计其前面已有多少负样本\n       这些负样本都被该正样本“正确地排在后面”\n    \"\"\"\n\n    # 转为 numpy array，便于排序和向量化操作\n    labels = np.asarray(labels)\n    scores = np.asarray(scores)\n\n    # 获取按照 score 从小到大排序后的索引\n    order = np.argsort(scores)\n\n    # 按排序后的顺序重排标签\n    labels_sorted = labels[order]\n\n    # 正样本数量 |P|\n    n_pos = np.sum(labels_sorted == 1)\n\n    # 负样本数量 |N|\n    n_neg = np.sum(labels_sorted == 0)\n\n    # 已扫描到的负样本数量（前缀负样本计数）\n    neg_count = 0\n\n    # 排序正确的正负样本对数量\n    correct = 0.0\n\n    # 从低分到高分扫描\n    for l in labels_sorted:\n        if l == 1:\n            # 当前是正样本：\n            # 它前面的所有负样本都满足 score_neg &lt; score_pos\n            correct += neg_count\n        else:\n            # 当前是负样本，增加负样本计数\n            neg_count += 1\n\n    # AUC = 排序正确的正负样本对 / 总正负样本对\n    return correct / (n_pos * n_neg)\n</code></pre>\n<p><strong>复杂度分析：</strong></p>\n<ul>\n<li>时间复杂度：<p></p><div class=\"math display\">\\[O(n \\log n)\n\\]</div><p></p>主要来自排序操作，其中 <span class=\"math inline\">\\(n = |P| + |N|\\)</span></li>\n<li>空间复杂度：<p></p><div class=\"math display\">\\[O(n)\n\\]</div><p></p></li>\n</ul>\n<p><strong>工程说明：</strong></p>\n<ul>\n<li>与 Mann–Whitney U 统计量完全等价</li>\n<li>是工业界离线 AUC 计算（Spark / MapReduce / Flink）的理论基础</li>\n<li>可自然扩展为分桶、分 user、分实验组的 AUC 统计</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-01-06 20:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GlenTt\">GlenTt</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "性能提升4倍！使用Granian作为Django项目的ASGI服务器",
      "link": "https://www.cnblogs.com/deali/p/19449242",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/deali/p/19449242\" id=\"cb_post_title_url\" title=\"发布于 2026-01-06 20:11\">\n    <span>性能提升4倍！使用Granian作为Django项目的ASGI服务器</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>最近我又继续在开发 DjangoStarter 的新版本了。</p>\n<p>之前为了实现 docker 部署，我把 Nginx 打包进了 DjangoStarter 的 compose 配置里了，不过这带来了配置的复杂度，特别是还要搭配框架实现 URL prefix 之类的功能。</p>\n<p>从 v3.2.x 版本开始，我就启动了减法计划，简化代码和功能，减少心智负担，这个 Nginx 容器也是我一直想去掉的。</p>\n<p>最近发现 Granian 这个 Rust 开发的 ASGI 服务器，性能高，而且还可以支持静态文件，正好完美符合我的需求，于是这次正好拿来替换原本使用的 Daphne</p>\n<h2 id=\"granian\">Granian</h2>\n<p>项目主页: <a href=\"https://github.com/emmett-framework/granian\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/emmett-framework/granian</a></p>\n<p>Granian 是一款高性能 Python Web Server，支持 ASGI、WSGI、RSGI，基于 Rust 编写，启动速度快、并发能力强，非常适合 Django / FastAPI / Starlette。</p>\n<p>官方描述为 “A Rust HTTP server for Python applications built on top of Hyper/Tokio”。</p>\n<p>特点：</p>\n<ul>\n<li>支持 <strong>ASGI 3</strong>、<strong>RSGI</strong>（Rust-Server-Gateway Interface）和 <strong>WSGI</strong> 接口。</li>\n<li>支持 HTTP/1 和 HTTP/2（未来计划 HTTP/3）协议。</li>\n<li>支持静态文件直出 (“Direct static files serving”)。</li>\n</ul>\n<h2 id=\"使用方式\">使用方式</h2>\n<p>很简单，不需要修改代码，只需要修改启动命令。</p>\n<p>目前搭配 DjangoStarter 使用的启动命令是这样的：</p>\n<pre><code class=\"language-bash\">granian --interface asgi --host 0.0.0.0 --port 8000 --static-path-route /static --static-path-mount ./static-dist config.asgi:application\n</code></pre>\n<p>类似 uvicorn，这个 granian 也支持热重载，加个 <code>--reload</code> 参数就行了</p>\n<h2 id=\"性能测试\">性能测试</h2>\n<p>本次用 wrk 进行性能测试</p>\n<h3 id=\"测试数据\">测试数据</h3>\n<p>以下数据在腾讯云 2 cores CPU + 2G 内存的服务器上测得。</p>\n<p>django 5.x + ninja + daphne</p>\n<pre><code>$ wrk -t4 -c200 -d30s http://127.0.0.1:9876/api/django-starter/monitoring/health\nRunning 30s test @ http://127.0.0.1:9876/api/django-starter/monitoring/health\n  4 threads and 200 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.97s     0.00us   1.97s   100.00%\n    Req/Sec    38.55     55.33   343.00     90.23%\n  1343 requests in 30.04s, 760.03KB read\n  Socket errors: connect 0, read 0, write 0, timeout 1342\nRequests/sec:     44.70\nTransfer/sec:     25.30KB\n</code></pre>\n<p>django 5.x + ninja + granian</p>\n<pre><code>$ wrk -t4 -c200 -d30s http://127.0.0.1:9875/api/django-starter/monitoring/hea\nlth\nRunning 30s test @ http://127.0.0.1:9875/api/django-starter/monitoring/health\n  4 threads and 200 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.20s    93.05ms   1.72s    82.69%\n    Req/Sec    83.13    105.81   460.00     83.72%\n  4980 requests in 30.04s, 2.85MB read\nRequests/sec:    165.76\nTransfer/sec:     97.31KB\n</code></pre>\n<p>因为好奇，我还找到之前一个很老的项目，使用WSGI部署的进行对比。</p>\n<p>以下数据在私有云的 4 cores CPU + 2G 内存服务器上测得。</p>\n<p>因为是完全不同的服务器硬件，数据仅供参考。</p>\n<p>Django 3.x + drf + uwsgi + nginx</p>\n<pre><code>$ wrk -t4 -c200 -d30s http://127.0.0.1:9001/api/health/\nRunning 30s test @ http://127.0.0.1:9001/api/health/\n  4 threads and 200 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency   295.30ms  373.95ms   1.96s    85.14%\n    Req/Sec   205.54     68.42   380.00     73.73%\n  19583 requests in 30.09s, 5.83MB read\n  Socket errors: connect 0, read 0, write 0, timeout 474\n  Non-2xx or 3xx responses: 12\nRequests/sec:    650.89\nTransfer/sec:    198.32KB\n</code></pre>\n<p>Django 3.x + ninja + uwsgi + nginx</p>\n<pre><code>$ wrk -t4 -c200 -d30s http://127.0.0.1:9001/api2/health\nRunning 30s test @ http://127.0.0.1:9001/api2/health\n  4 threads and 200 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency   203.75ms  280.30ms   1.95s    88.44%\n    Req/Sec   250.81    108.59   500.00     61.21%\n  22542 requests in 30.06s, 5.68MB read\n  Socket errors: connect 0, read 0, write 0, timeout 420\n  Non-2xx or 3xx responses: 12\nRequests/sec:    749.88\nTransfer/sec:    193.35KB\n</code></pre>\n<h3 id=\"结论\">结论</h3>\n<p>以下是使用 AI 对上面的测试数据进行分析的结论，不过 ASGI 和 uWSGI 不在同一台服务器进行测试，其实很难直接对比。目前看来切换到 Granian 确实可以提高4倍的性能。</p>\n<p>① Daphne 在 Django + ASGI 下的性能表现非常差</p>\n<ul>\n<li>延迟直接飙到 <strong>1.9 秒级别</strong>，</li>\n<li>wrk 200 并发几乎把它压扁，</li>\n<li><strong>1343 请求里 1342 超时</strong>，等于完全顶不住。</li>\n</ul>\n<p>说白了：<strong>Daphne 更像是开发环境服务器，不推荐上生产高并发。</strong></p>\n<p>② Granian 性能比 Daphne 好 3–4 倍，但仍然有限</p>\n<ul>\n<li>每秒处理 <strong>165 req/s</strong>（同机房、同代码）。</li>\n<li>延迟仍然在 <strong>1.2s</strong> 左右，远不算理想（在高并发下仍吃力）。</li>\n<li>优点是 ASGI 原生 + Rust 实现，比 Daphne 强太多。</li>\n</ul>\n<p>直观感受：<strong>Granian 能用，但你别指望它像 uWSGI 那样扛流量。</strong></p>\n<p>③ uWSGI（WSGI）表现碾压：单机可达 650–750 req/s 级别</p>\n<ul>\n<li>性能直接是 granian 的 <strong>4～5 倍</strong>。</li>\n<li>虽然是老架构（WSGI），但调优成熟、稳定、分配机制强，抗压能力远强于同类 ASGI 服务。</li>\n</ul>\n<p>简而言之：<strong>如果不用异步，WSGI 依旧是 Django 的最强部署方式（性能层面）。</strong></p>\n<h2 id=\"docker-compose\">docker-compose</h2>\n<p>这是精简后的 compose 配置</p>\n<pre><code class=\"language-yaml\">services:\n  app:\n    image: ${APP_IMAGE_NAME}:${APP_IMAGE_TAG}\n    container_name: $APP_NAME-app\n    command:\n      - granian\n      - --interface\n      - asgi\n      - --host\n      - 0.0.0.0\n      - --port\n      - \"${APP_INTERNAL_PORT:-8000}\"\n      - --static-path-route\n      - /static\n      - --static-path-mount\n      - /project/static-dist\n      - config.asgi:application\n</code></pre>\n<h2 id=\"命令行参数\">命令行参数</h2>\n<p>它的命令行结构很简单：</p>\n<pre><code class=\"language-bash\">granian [OPTIONS] APP\n</code></pre>\n<p>其中：</p>\n<ul>\n<li><strong>APP</strong> 是入口，例如：<code>config.asgi:application</code></li>\n<li><strong>OPTIONS</strong> 是各种配置参数</li>\n</ul>\n<p>下面按分类整理所有参数（附带说明与建议）。</p>\n<h3 id=\"-基础参数启动必要项\">🧩 基础参数（启动必要项）</h3>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>APP</code></td>\n<td><strong>要启动的应用入口</strong>（如 <code>mysite.asgi:application</code>）</td>\n<td>必填</td>\n</tr>\n<tr>\n<td><code>--interface</code></td>\n<td>接口类型：<code>asgi</code> / <code>asginl</code> / <code>rsgi</code> / <code>wsgi</code></td>\n<td>rsgi</td>\n</tr>\n<tr>\n<td><code>--host</code></td>\n<td>监听地址</td>\n<td>127.0.0.1</td>\n</tr>\n<tr>\n<td><code>--port</code></td>\n<td>端口</td>\n<td>8000</td>\n</tr>\n<tr>\n<td><code>--uds</code></td>\n<td>使用 Unix Domain Socket</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>--http</code></td>\n<td>HTTP 版本：<code>1</code>、<code>2</code>、<code>auto</code></td>\n<td>auto</td>\n</tr>\n<tr>\n<td><code>--workers</code></td>\n<td>Worker 进程数</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>👉 Django、FastAPI 用户一般写：</p>\n<pre><code>--interface asgi\n</code></pre>\n<h3 id=\"️-静态文件服务django-专用配置\">🗂️ 静态文件服务（Django 专用配置）</h3>\n<p>Granian 内置静态文件服务：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--static-path-route</code></td>\n<td>URL 路由前缀，例如 <code>/static</code></td>\n<td>/static</td>\n</tr>\n<tr>\n<td><code>--static-path-mount</code></td>\n<td>文件目录，例如 <code>/project/static-dist</code></td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>--static-path-expires</code></td>\n<td>缓存时间（秒）</td>\n<td>86400</td>\n</tr>\n</tbody>\n</table>\n<p>示例：</p>\n<pre><code>--static-path-route /static --static-path-mount /project/static-dist\n</code></pre>\n<h3 id=\"️-多进程线程事件循环选项\">⚙️ 多进程、线程、事件循环选项</h3>\n<p>Worker / Thread</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--workers</code></td>\n<td>Worker 数量</td>\n</tr>\n<tr>\n<td><code>--blocking-threads</code></td>\n<td>阻塞线程数</td>\n</tr>\n<tr>\n<td><code>--runtime-threads</code></td>\n<td>Runtime 线程数</td>\n</tr>\n<tr>\n<td><code>--runtime-blocking-threads</code></td>\n<td>Runtime I/O 阻塞线程</td>\n</tr>\n</tbody>\n</table>\n<p>建议：</p>\n<ul>\n<li><strong>CPU × 2</strong> 左右的 worker 容量通常够用</li>\n<li>大部分 ASGI 项目不需要调 thread 参数</li>\n</ul>\n<h3 id=\"-事件循环--runtime\">🔁 事件循环 &amp; Runtime</h3>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--loop</code></td>\n<td>事件循环：<code>auto</code>、<code>asyncio</code>、<code>rloop</code>、<code>uvloop</code></td>\n</tr>\n<tr>\n<td><code>--task-impl</code></td>\n<td>task 执行器：<code>asyncio</code> / <code>rust</code></td>\n</tr>\n<tr>\n<td><code>--runtime-mode</code></td>\n<td>单线程 <code>st</code> / 多线程 <code>mt</code></td>\n</tr>\n</tbody>\n</table>\n<p>适用建议：</p>\n<ul>\n<li>普通项目：用默认即可</li>\n<li>高并发：<code>--task-impl rust</code> 性能更强</li>\n</ul>\n<h3 id=\"-http1-与-http2-相关参数\">🔒 HTTP/1 与 HTTP/2 相关参数</h3>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>常用配置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HTTP/1</td>\n<td><code>--http1-buffer-size</code>、<code>--http1-keep-alive</code></td>\n</tr>\n<tr>\n<td>HTTP/2</td>\n<td><code>--http2-*</code> 一系列参数控制 flow control、窗口、keepalive、stream 数量等</td>\n</tr>\n</tbody>\n</table>\n<p>大部分项目无需调整，默认即可。</p>\n<h3 id=\"-日志logging\">📜 日志（Logging）</h3>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--log / --no-log</code></td>\n<td>启用日志</td>\n<td>enabled</td>\n</tr>\n<tr>\n<td><code>--log-level</code></td>\n<td>日志等级</td>\n<td>info</td>\n</tr>\n<tr>\n<td><code>--log-config</code></td>\n<td>使用 JSON 配置文件</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>--access-log</code></td>\n<td>开启 access log</td>\n<td>disabled</td>\n</tr>\n<tr>\n<td><code>--access-log-fmt</code></td>\n<td>Access log 格式</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<p>如果你希望生产环境有 Nginx 样式的 access log：</p>\n<pre><code>--access-log --access-log-fmt \"%a %r %s %b\"\n</code></pre>\n<h3 id=\"-热重载开发环境用\">🔁 热重载（开发环境用）</h3>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--reload</code></td>\n<td>开启自动重载</td>\n</tr>\n<tr>\n<td><code>--reload-paths</code></td>\n<td>指定监控目录</td>\n</tr>\n<tr>\n<td><code>--reload-ignore-*</code></td>\n<td>忽略目录、路径、pattern</td>\n</tr>\n</tbody>\n</table>\n<p>例如：</p>\n<pre><code>--reload --reload-paths src/\n</code></pre>\n<h3 id=\"-https\">🔐 HTTPS</h3>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--ssl-certificate</code></td>\n<td>证书文件</td>\n</tr>\n<tr>\n<td><code>--ssl-keyfile</code></td>\n<td>密钥文件</td>\n</tr>\n<tr>\n<td><code>--ssl-ca</code></td>\n<td>CA</td>\n</tr>\n<tr>\n<td><code>--ssl-client-verify</code></td>\n<td>客户端证书验证</td>\n</tr>\n</tbody>\n</table>\n<p>（一般反向代理交给 Nginx 做 HTTPS）</p>\n<h3 id=\"-其他有用但不常改的参数\">🧰 其他有用但不常改的参数</h3>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>--working-dir</code></td>\n<td>切换 WorkDir</td>\n</tr>\n<tr>\n<td><code>--env-files</code></td>\n<td>加载环境变量文件</td>\n</tr>\n<tr>\n<td><code>--factory</code></td>\n<td>APP 是 factory function 时使用</td>\n</tr>\n<tr>\n<td><code>--url-path-prefix</code></td>\n<td>应用挂载前缀</td>\n</tr>\n<tr>\n<td><code>--process-name</code></td>\n<td>自定义进程名</td>\n</tr>\n<tr>\n<td><code>--pid-file</code></td>\n<td>写入 PID 文件</td>\n</tr>\n<tr>\n<td><code>--version</code></td>\n<td>显示版本</td>\n</tr>\n<tr>\n<td><code>--help</code></td>\n<td>显示帮助</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div id=\"MySignature\">\n    微信公众号：「程序设计实验室」\n专注于互联网热门新技术探索与团队敏捷开发实践，包括架构设计、机器学习与数据分析算法、移动端开发、Linux、Web前后端开发等，欢迎一起探讨技术，分享学习实践经验。\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-06 20:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/deali\">程序设计实验室</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Zsh 配置笔记",
      "link": "https://www.cnblogs.com/owlman/p/19449225",
      "published": "",
      "description": "<h2 class=\"post-title\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/owlman/p/19449225\" id=\"cb_post_title_url\" title=\"发布于 2026-01-06 20:01\">\n    <span>Zsh 配置笔记</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>[!NOTE] 笔记说明</p>\n<p>这篇笔记主要记录了我在使用 Zsh 这款 Shell 的过程中所记录的一些心得与体会。它将会被存储在我个人的 <a href=\"https://github.com/owlman/CS_Studynotes\" rel=\"noopener nofollow\" target=\"_blank\">计算机专业笔记库</a> 中，以便日后查阅。</p>\n</blockquote>\n<h2 id=\"zsh-简介\">Zsh 简介</h2>\n<p>Z shell（以下简称 Zsh）是保罗·弗斯塔德（Paul Falstad）于 1990 年在普林斯顿大学求学时编写的、一款可用作交互式登录的 Shell。Zsh 对 <a href=\"https://zh.wikipedia.org/wiki/Bourne_shell\" rel=\"noopener nofollow\" target=\"_blank\">Bourne shell</a>做出了大量改进，同时加入了 <a href=\"https://zh.wikipedia.org/wiki/Bash\" rel=\"noopener nofollow\" target=\"_blank\">Bash</a>、<a href=\"https://zh.wikipedia.org/wiki/Korn_shell\" rel=\"noopener nofollow\" target=\"_blank\">ksh</a> 及 <a href=\"https://zh.wikipedia.org/wiki/Tcsh\" rel=\"noopener nofollow\" target=\"_blank\">tcsh</a> 的某些功能。</p>\n<p>2019 年，由于新版本的 Bash v5 将开源授权改成了 GPLv3 协议，而 Apple 公司一贯避免在系统组件中引入 GPLv3 软件。于是自从那时起，macOS 系统上的预置 Shell 就已从 Bash 改为了 Zsh。另外，<a href=\"https://zh.wikipedia.org/wiki/Kali_Linux\" rel=\"noopener nofollow\" target=\"_blank\">Kali Linux</a> 也使用 Zsh 作为预置 Shell。其主要特性包括：</p>\n<ul>\n<li>提供可编程的命令行补全功能，该功能可帮助用户键入常用命令选项及参数；</li>\n<li>提供可编程的命令行界面，包括将提示行信息显示在屏幕右侧，以及自动隐藏过长指令等功能；</li>\n<li>提供可与任意 Shell 共享的命令行历史记录；</li>\n<li>可在不借助外部程序的情况下实现文件的查找；</li>\n<li>改进了针对变量/数组的处理方式；</li>\n<li>允许在单缓冲区内编辑多行命令；</li>\n<li>支持针对命令的拼写检查；</li>\n<li>支持多种兼容模式（例如，Zsh 可在运行为<code>/bin/sh</code>的情况下伪装成 Bourne shell）</li>\n<li>支持以加载模块的方式引入额外的功能，包括支持 Unix 域套接字控制、FTP 客户端等；</li>\n<li>提供有<code>where</code>命令，该命令的使用方法与<code>which</code>命令类似，但返回的是指定指令在<code>$PATH</code>中的全部位置，而不是它当前最优先匹配的位置；</li>\n<li>允许用户为指定目录设置别名，例如，用户可以为<code>/usr/bin</code>设置别名<code>/u</code>，这样在输入<code>/u</code>时，Zsh 会自动将其替换为<code>/usr/bin</code>；</li>\n</ul>\n<h2 id=\"安装步骤\">安装步骤</h2>\n<p>在安装之前，我希望读者确定自己是在类 UNIX 系统下，因为 Zsh 是在类 UNIX 系统下运行的 Shell 程序，如果您使用的是 Windows 系统，推荐使用 Windows Subsystem for Linux（WSL）。下面书归正传，Zsh 在每个操作系统中的安装方式并不完全相同，下面是其在几种常见 Linux/UNIX 系统下的安装命令：</p>\n<pre><code class=\"language-bash\"># macOS 系统下的安装命令：\nbrew install zsh\n\n# ubuntu/debian 系统下的安装命令：\nsudo apt install zsh\n\n# CentOS 系统下的安装命令：\nsudo yum install zsh\n\n# ArchLinux/Manjaro 系统下的安装命令：\nsudo pacman -S zsh\n</code></pre>\n<p>如果您使用的是上述操作系统之一，在执行完相应的安装命令之后，就可以使用<code>cat /etc/shells</code>命令查看当前系统可以用的 Shell 了。然后，只要在该命令返回的结果中看到<code>/bin/zsh</code>，就说明 Zsh 已经安装好了，如图 1 所示。</p>\n\n<p><img alt=\"图 1：当前可用的 Shell\" class=\"lazyload\" /></p>\n<p><strong>图 1</strong>：当前可用的 Shell</p>\n<p>接下来，我们可以使用<code>chsh -s /bin/zsh</code>命令将 Zsh 设置为系统默认 Shell 了。如果到目前为止的操作一切顺利，现在只需要重新启动一个 Shell 会话（通常是一个命令行终端窗口），就会看到 Zsh 的初始配置了，如图 2 所示。</p>\n\n<p><img alt=\"图 2：Zsh 的配置引导界面\" class=\"lazyload\" /></p>\n<p><strong>图 2</strong>：Zsh 的配置引导界面</p>\n<p>在上述界面中，如果我们输入<code>q</code>会直接退出配置引导，下一次运行 zsh 时会再次进入配置引导。如果输入<code>0</code>，也会退出配置引导，但是会在当前用户目录生成一个空白的文件<code>.zshrc</code>（路径为<code>~/.zshrc</code>），并且不会再进入配置引导界面。换言之，Zsh 会不会在启动时进入配置引导界面取决于当前用户目录下是否存在<code>.zshrc</code>文件，该文件是 Zsh 的默认配置文件，人们可以使用 vim 编辑器打开它并进行源码级别的手动配置。而如果我们在这里输入<code>1</code>，就会开始进行一系列自定义的配置。但通常情况下，考虑到<code>.zshrc</code>文件中各项配置的复杂性，我们在这里并不推荐读者直接进行手动配置，使用 Oh-My-Zsh 来进行配置会是更好的选择。</p>\n<h2 id=\"oh-my-zsh\">Oh-My-Zsh</h2>\n<p>Oh-My-Zsh 是一款 Zsh 的配置管理工具，它提供了丰富的主题和插件，可以极大地美化命令行界面，并提高工作效率。我们需要这项工具的原因在于：原生的 Zsh 虽然很强大，但存在着以下几个配置成本方面的问题：</p>\n<ul>\n<li>稍复杂的配置就需要使用编码的方式修改<code>.zshrc</code>文件；</li>\n<li>命令的自动补全和提示需要手动调教；</li>\n<li>引入第三方主题与插件的相关配置就更为复杂了。</li>\n</ul>\n<p>而 Oh-My-Zsh 的作用就是把这些复杂的配置一次性打包好，确保开箱即用，它相对于 Bash、原生 Zsh 的优势如表 1 所示：</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>Bash</th>\n<th>原生 Zsh</th>\n<th>Oh My Zsh</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>自动补全</td>\n<td>基础</td>\n<td>强</td>\n<td><strong>非常强</strong></td>\n</tr>\n<tr>\n<td>配置难度</td>\n<td>低</td>\n<td>高</td>\n<td><strong>低</strong></td>\n</tr>\n<tr>\n<td>插件系统</td>\n<td>无</td>\n<td>无</td>\n<td><strong>有</strong></td>\n</tr>\n<tr>\n<td>主题</td>\n<td>基本无</td>\n<td>有</td>\n<td><strong>大量现成</strong></td>\n</tr>\n<tr>\n<td>上手速度</td>\n<td>快</td>\n<td>慢</td>\n<td><strong>最快</strong></td>\n</tr>\n</tbody>\n</table>\n<p><strong>表 1</strong>：Bash、原生 Zsh 与 Oh My Zsh 的对比</p>\n<p>在了解 Oh-My-Zsh 的基本信息以及所能发挥的功能之后，我们现在就来演示一下它的安装步骤：</p>\n<ul>\n<li>\n<p>在安装 Oh-My-Zsh 之前，需要确保本地已经安装了 Git，关于 Git 的安装与配置步骤，读者可参考我在《[[Git 使用笔记]]》中的记录；</p>\n</li>\n<li>\n<p>打开 Zsh 终端窗口，并在用户目录下使用 curl 或 wget 命令下载 Oh-My-Zsh 的安装脚本，并执行它：</p>\n<pre><code class=\"language-bash\"># 使用 curl 下载脚本并安装：\nsh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n\n# 使用 wget 下载脚本并安装：\nsh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\"\n</code></pre>\n</li>\n<li>\n<p>在执行上述命令过程中，我们需要同意 Oh-My-Zsh 使用自身的配置模板覆盖已有的<code>.zshrc</code>文件，如图 3 所示（由于我已完成配置，不便截图，此处引用来自<a href=\"https://www.haoyep.com/posts/zsh-config-oh-my-zsh/\" rel=\"noopener nofollow\" target=\"_blank\">网络的截图</a>）：</p>\n  \n<p><img alt=\"图 3：Oh-My-Zsh 的安装界面\" class=\"lazyload\" /></p>\n<p><strong>图 3</strong>：Oh-My-Zsh 的安装过程</p>\n</li>\n</ul>\n<p>待安装顺利完成之后，用户的<code>home</code>目录下会出现一个名为<code>.oh-my-zsh</code>的目录，该目录中存储的就是 Oh-My-Zsh 框架本身，及其主题和插件的实现代码。下面，我们从功能插件、外观配置与快捷命令三个方面来介绍基于 Oh-My-Zsh 配置 Zsh 的主要方法。</p>\n<h3 id=\"功能插件\">功能插件</h3>\n<p>Oh-My-Zsh 的核心竞争力主要来自于它所提供的那套极具开放性的，高度可定制的插件系统，这让我们可以根据自己的喜好进行选择和配置，打造一个富有个性的命令行终端界面。下面是我个人常用的一些插件及其相关介绍：</p>\n<table>\n<thead>\n<tr>\n<th>插件</th>\n<th>功能</th>\n<th>使用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>z</code></td>\n<td>可实现智能目录跳转。</td>\n<td><code>z &lt;目录名&gt;</code> （该目录需历史记录中出现过）</td>\n</tr>\n<tr>\n<td><code>git</code></td>\n<td>可用<code>ga</code>、<code>gc</code>等快捷命令。</td>\n<td><code>gc -m \"commit message\"</code></td>\n</tr>\n<tr>\n<td><code>extract</code></td>\n<td>提供<code>x</code>压缩包解压命令。</td>\n<td><code>x file_name.tar.gz</code></td>\n</tr>\n<tr>\n<td><code>web-search</code></td>\n<td>可实现网页搜索。</td>\n<td><code>google &lt;搜索内容&gt;</code>或<code>baidu &lt;搜索内容&gt;</code></td>\n</tr>\n<tr>\n<td><code>you-should-use</code></td>\n<td>命令行错误提示功能。</td>\n<td>在命令输入错误时，会给出正确的命令提示。</td>\n</tr>\n<tr>\n<td><code>zsh-completions</code></td>\n<td>命令行自动补齐功能。</td>\n<td>在输入命令时按<code>Tab</code>键会自动补齐。</td>\n</tr>\n<tr>\n<td><code>zsh-autosuggestions</code></td>\n<td>命令行自动提示功能。</td>\n<td>在输入命令时会自动给出提示。</td>\n</tr>\n<tr>\n<td><code>zsh-syntax-highlighting</code></td>\n<td>命令行语法高亮功能。</td>\n<td>在输入命令时会根据语法高亮。</td>\n</tr>\n</tbody>\n</table>\n<p>在 Oh-My-Zsh 中安装和启用插件通常可按照以下三个步骤来进行（如果是自带插件，则可跳过第一步）：</p>\n<ol>\n<li>\n<p>如果我们要启用的不是 Oh-My-Zsh 的内置插件，那该插件通常会在 Github 上有独立的仓库，人们需要先使用<code>git clone</code>命令将其下载到 Oh-My-Zsh 安装目录下的<code>custom/plugins</code>目录中（而内置插件则已存在于 Oh-My-Zsh 安装目录下的<code>plugins</code>目录中，无需下载），例如，我们现在要启用的是<code>zsh-autosuggestions</code>插件，这是一个第三方插件，这就需要先执行以下命令，将其下载到 Oh-My-Zsh 安装目录下的<code>custom/plugins</code>目录中：</p>\n<pre><code class=\"language-bash\">git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\n</code></pre>\n</li>\n<li>\n<p>使用 vim 这样的文本编辑器打开<code>.zshrc</code>文件，并在其中找到<code>plugins</code>字段，并将要启用的插件名称添加到该字段中（该字段的值是一个用空白符分隔的字符串），例如，如果我们现在要启用的插件包括<code>z</code>、<code>git</code>、<code>extract</code>、<code>web-search</code>、<code>you-should-use</code>、<code>zsh-completions</code>、<code>zsh-autosuggestions</code>、<code>zsh-syntax-highlighting</code>，那么<code>.zshrc</code>文件中<code>plugins</code>字段的值就该被设置如下：</p>\n<pre><code class=\"language-bash\">plugins=(\n    z \n    git\n    extract\n    web-search\n    you-should-use \n    zsh-completions \n    zsh-autosuggestions \n    zsh-syntax-highlighting \n    zsh-history-substring-search\n)\n</code></pre>\n</li>\n<li>\n<p>保存并关闭<code>.zshrc</code>文件，然后执行<code>source ~/.zshrc</code>或<code>omz reload</code>命令使配置生效。例如，图 4 所示的是启用<code>extract</code>插件之后，使用<code>x</code>命令解压文件的效果：</p>\n \n<p><img alt=\"图 4：extract 插件的效果\" class=\"lazyload\" /></p>\n<p><strong>图 4</strong>：extract 插件的效果</p>\n</li>\n</ol>\n<h3 id=\"外观配置\">外观配置</h3>\n<p>在 Oh-My-Zsh 中，我们可以通过一种被称之为“主题”的特殊插件来配置 Zsh 界面所呈现的外观，目的是通过各种特定的颜色和提示信息让命令行界面的易用性和美观性达到一个平衡。Oh-My-Zsh 内置了大量的主题，它们都被存放在 Oh-My-Zsh 安装目录下的<code>themes</code>目录中（也可以前往 <a href=\"https://github.com/ohmyzsh/ohmyzsh/wiki/Themes\" rel=\"noopener nofollow\" target=\"_blank\">Oh-My-Zsh 官方文档</a>查看），如图 5 所示：</p>\n\n<p><img alt=\"图 5：Oh-My-Zsh 内置的主题\" class=\"lazyload\" /></p>\n<p><strong>图 5</strong>：Oh-My-Zsh 内置的主题</p>\n<p>如果我们想启用上述任意一个 Oh-My-Zsh 的内置主题，就只需将<code>.zshrc</code>文件中的<code>ZSH_THEME</code>变量值修改为该主题的名称即可，例如，假设现在要启用的是<code>agnoster</code>主题，我们就只需要执行以下步骤：</p>\n<ul>\n<li>\n<p>先使用 vim 这样的文本编辑器打开<code>.zshrc</code>文件；</p>\n</li>\n<li>\n<p>找到<code>ZSH_THEME</code>变量，并将它的值设置如下即可：</p>\n<pre><code class=\"language-bash\">ZSH_THEME=\"agnoster\" # 默认主题为 robbyrussell\n</code></pre>\n</li>\n<li>\n<p>保存并关闭<code>.zshrc</code>文件，然后执行<code>source ~/.zshrc</code>命令使配置生效，其效果如图 6 所示：</p>\n  \n<p><img alt=\"图 6：agnoster 主题的效果\" class=\"lazyload\" /></p>\n<p><strong>图 6</strong>：agnoster 主题的效果</p>\n</li>\n</ul>\n<p>当然，除了上述内置主题之外，我们还可以选择安装其他开源的主题，例如，<a href=\"https://github.com/romkatv/powerlevel10k\" rel=\"noopener nofollow\" target=\"_blank\">powerlevel10k</a>就是一个非常受欢迎的，功能强大的主题，它提供了丰富的配置选项，可以让我们打造出各种个性化的命令行界面，其安装与配置步骤如下：</p>\n<ol>\n<li>\n<p>使用<code>git clone</code>命令将主题下载到 Oh-My-Zsh 安装目录下的<code>custom/themes</code>目录中：</p>\n<pre><code class=\"language-bash\">git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k\n</code></pre>\n</li>\n<li>\n<p>使用 vim 这样的文本编辑器打开<code>.zshrc</code>文件，并在其中找到<code>ZSH_THEME</code>变量，并将它的值设置为我们刚刚下载的主题名称即可：</p>\n<pre><code class=\"language-bash\">ZSH_THEME=\"powerlevel10k/powerlevel10k\"\n</code></pre>\n</li>\n<li>\n<p>保存并关闭<code>.zshrc</code>文件，然后执行<code>source ~/.zshrc</code>或<code>omz reload</code>命令使配置生效。在该主题配置首次生效时会启动一个配置向导（之后也可以通过执行<code>p10k configure</code>命令来启动该向导），引导我们完成主题的配置，如图 7 所示：</p>\n \n<p><img alt=\"图 7：powerlevel10k 主题的配置向导\" class=\"lazyload\" /></p>\n<p><strong>图 7</strong>：powerlevel10k 主题的配置向导</p>\n</li>\n<li>\n<p>接下来，我们只需要根据上述配置向导的提示，按照自己的喜欢一步一步地做出选择，就可以完成主题的配置，我个人的配置效果如图 8 所示：</p>\n \n<p><img alt=\"图 8：powerlevel10k 主题的配置效果\" class=\"lazyload\" /></p>\n<p><strong>图 8</strong>：powerlevel10k 主题的配置效果</p>\n</li>\n</ol>\n<h3 id=\"快捷命令\">快捷命令</h3>\n<p>对于类似于进入某个特定工作目录的常用命令，Zsh 提供了一种被称为 alias 的机制，让我们可以为其设置一个快捷命令。例如，<code>~/working/notes</code>目录是我们每次写笔记时要打开的目录，如果我们想使用 Zsh 的 alias 机制为<code>cd ~/working/notes</code>命令设置一个快捷命令，就可以使用 vim 编辑器打开在<code>.zshrc</code>文件，并在其中恰当的位置上添加如下配置：</p>\n<pre><code class=\"language-bash\">alias cd-notes=\"cd ~/working/notes\"\n</code></pre>\n<p>配置完成后，我们就可以使用<code>cd-notes</code>这个快捷命令命令来执行进入<code>~/working/notes</code>目录了。当然，除了手动配置的 Zsh alias 之外，在安装了Oh-My-Zsh 之后，我们还可以使用该框架所内置的一系列常用的 alias。例如在启用了<code>git</code>插件之后，我们就可以使用它提供的 alias 来执行 git 相关操作了，具体命令列表可查阅 Oh-My-Zsh 官方提供的 <a href=\"https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git\" rel=\"noopener nofollow\" target=\"_blank\">git 插件文档</a>。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-01-06 20:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/owlman\">凌杰</a>&nbsp;\n阅读(<span id=\"post_view_count\">14</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "C# 不依赖 OpenCV 的图像处理算法：滤波、锐化与边缘检测",
      "link": "https://www.cnblogs.com/1312mn/p/19444713",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/1312mn/p/19444713\" id=\"cb_post_title_url\" title=\"发布于 2026-01-06 14:28\">\n    <span>C# 不依赖 OpenCV 的图像处理算法：滤波、锐化与边缘检测</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>数字图像处理作为计算机视觉和多媒体技术的基础内容，其核心不仅在于理解算法原理，更在于动手实现与验证。为了深入掌握本项目选择从底层像素级别出发，使用C#语言手动实现各类经典图像处理算法，避免依赖现成的高级图像库。</p>\n<p>这种\"从零开始\"的方式虽然开发成本较高，却能真正厘清每个操作背后的数学逻辑与工程细节，也为后续学习更复杂的视觉任务打下坚实基础。</p>\n<h2 id=\"项目介绍\">项目介绍</h2>\n<p>项目是一个基于.NET 平台开发的桌面级数字图像处理工具，在通过图形化界面直观展示多种图像处理算法的效果。</p>\n<p>整个系统围绕System.Drawing.Bitmap类开发，直接操作像素数据完成各类变换，涵盖几何操作、灰度调整、噪声模拟、滤波去噪、边缘检测、图像分割等多个模块。</p>\n<p>项目代码结构清晰，功能完整，既可用于学习参考，也适合作为开发项目。</p>\n<h2 id=\"项目功能\">项目功能</h2>\n<p>1、支持图像的打开、保存及基本信息显示（如尺寸、颜色深度等）</p>\n<p>2、提供灰度化转换与灰度直方图可视化功能</p>\n<p>3、实现基本几何变换：旋转、放大、缩小、错切</p>\n<p>4、支持线性灰度变换与直方图均衡化以增强图像对比度</p>\n<p>5、可添加高斯噪声与椒盐噪声，并配套多种去噪滤波器</p>\n<p>6、集成多种边缘检测算子：Roberts、Sobel、Laplacian、LoG、Wallis、双向梯度等</p>\n<p>7、提供二值化处理及迭代阈值分割方法</p>\n<p>8、包含二值图像后处理功能，如孤立点去除、轮廓提取、区域测量等</p>\n<p>9、实现选择式掩膜滤波（LSMF）与KNN平滑滤波等进阶去噪策略<br />\n10、内置完整的撤销（Undo）与重做（Redo）机制，便于操作回溯与效果对比</p>\n<h2 id=\"项目特点\">项目特点</h2>\n<p>1、坚持从像素级别手动实现算法，不依赖OpenCV等封装库，强化原理理解</p>\n<p>2、界面采用WPF构建，交互友好，参数输入动态生成，操作流程清晰</p>\n<p>3、所有处理操作均可逆，支持多步历史记录，提升实验灵活性</p>\n<p>4、代码模块化程度高，每个功能对应独立方法，便于阅读与扩展<br />\n5、兼顾实用性，既能验证理论，也能处理真实图像任务</p>\n<h2 id=\"项目技术\">项目技术</h2>\n<table>\n<thead>\n<tr>\n<th>技术类别</th>\n<th>具体说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>开发语言</td>\n<td>C#</td>\n</tr>\n<tr>\n<td>运行平台</td>\n<td>.NET Framework（使用 <code>System.Drawing.Bitmap</code> 处理位图）</td>\n</tr>\n<tr>\n<td>UI 框架</td>\n<td>WPF（Windows Presentation Foundation）</td>\n</tr>\n<tr>\n<td>图像数据访问</td>\n<td>通过 <code>Bitmap.GetPixel</code> / <code>SetPixel</code> 及 <code>HBITMAP</code> 指针与 WPF <code>Image</code> 控件对接</td>\n</tr>\n<tr>\n<td>关键算法实现</td>\n<td>双线性插值（用于缩放/旋转）、卷积核运算（用于滤波与边缘检测）、直方图统计、噪声模型模拟等</td>\n</tr>\n<tr>\n<td>辅助技术</td>\n<td>使用 <code>Operation</code> 类封装操作历史，支持 Undo/Redo；通过 Interop 调用 Win32 API 实现位图转换</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"项目代码\">项目代码</h2>\n<h3 id=\"为图片添加高斯噪声\">为图片添加高斯噪声</h3>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 为图片添加高斯噪声\n/// &lt;/summary&gt;\nprivate void GaussNoise(int k)\n{\n    Random ran = new Random(GetRandomSeed());\n    Bitmap bmp_ = new Bitmap(bmp.Width, bmp.Height);\n    for (int i = 0; i &lt; bmp.Width; i++)\n    {\n        for (int j = 0; j &lt; bmp.Height; j++)\n        {\n            double r1 = ran.NextDouble();\n            double r2 = ran.NextDouble();\n            double result = Math.Sqrt((-2) * Math.Log(r2)) * Math.Sin(2 * Math.PI * r1);\n            result *= k;\n            Color c = bmp.GetPixel(i, j);\n\n            int rr = (int)(c.R + result),\n                gg = (int)(c.G + result),\n                bb = (int)(c.B + result);\n            if (rr &gt; 255) rr = 255;\n            else if (rr &lt; 0) rr = 0;\n            if (gg &gt; 255) gg = 255;\n            else if (gg &lt; 0) gg = 0;\n            if (bb &gt; 255) bb = 255;\n            else if (bb &lt; 0) bb = 0;\n            bmp_.SetPixel(i, j, Color.FromArgb(c.A, rr, gg, bb));\n        }\n    }\n    UpdateImg(ref bmp_);\n}\n</code></pre>\n<h3 id=\"为图片添加椒盐噪声\">为图片添加椒盐噪声</h3>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 为图片添加椒盐噪声\n/// &lt;/summary&gt;\n/// &lt;param name=\"SNR\"&gt;信噪比&lt;/param&gt;\n/// &lt;param name=\"pa\"&gt;图片为暗点的概率&lt;/param&gt;\nprivate void SaltNoise(double SNR, double pa)\n{\n    // 噪声点的数量\n    int NP = (int)(bmp.Width * bmp.Height * (1 - SNR));\n    Bitmap bmp_ = new Bitmap(bmp);\n    Random rand = new Random();\n    for (int i = 0; i &lt; NP; i++)\n    {\n        int r = rand.Next(0, bmp.Height), c = rand.Next(0, bmp.Width);\n        double prob = rand.NextDouble();\n        if (prob &gt; pa)\n        {\n            bmp_.SetPixel(c, r, Color.FromArgb(255, 255, 255));\n        }\n        else\n        {\n            bmp_.SetPixel(c, r, Color.FromArgb(0, 0, 0));\n        }\n    }\n    UpdateImg(ref bmp_);\n}\n</code></pre>\n<h2 id=\"项目效果\">项目效果</h2>\n<p>项目运行稳定，能够准确还原各类经典图像处理算法的预期效果。例如，在对自然图像进行灰度化后，直方图均衡化显著提升了整体对比度；添加椒盐噪声后，中值滤波有效抑制了噪点而保留边缘；使用Sobel或LoG算子可清晰提取物体轮廓。</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202601/576536-20260105210103962-1763205682.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"50%\" /></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202601/576536-20260105210118061-1765878502.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"50%\" /></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202601/576536-20260105210140975-938016934.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"50%\" /></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202601/576536-20260105210152223-942589643.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"50%\" /></p>\n<h2 id=\"总结\">总结</h2>\n<p>项目不仅是一次视觉的学习，更是一场对数字图像处理知识体系的深度实践。通过亲手编写每一个像素操作，可以穿透API的黑箱，真正理解\"图像\"在计算机中的表示方式以及各类变换的本质。这种自底向上的学习路径，虽略显笨拙，却最为扎实。对于希望夯实图像处理基础的大家而言，这个项目无疑是不错的参考。</p>\n<h2 id=\"关键词\">关键词</h2>\n<p>数字图像处理、C#、像素操作、几何变换、灰度变换、噪声抑制、边缘检测、图像分割、WPF、直方图均衡化</p>\n<h2 id=\"最后\">最后</h2>\n<p>如果你觉得这篇文章对你有帮助，不妨点个赞支持一下！你的支持是我继续分享知识的动力。如果有任何疑问或需要进一步的帮助，欢迎随时留言。</p>\n<p>也可以加入微信公众号[DotNet技术匠] 社区，与其他热爱技术的同行一起交流心得，共同成长！</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/576536/202505/576536-20250527195524293-1794896295.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"50%\" /></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-06 14:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/1312mn\">小码编匠</a>&nbsp;\n阅读(<span id=\"post_view_count\">271</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为什么说 IO 操作异步才有意义",
      "link": "https://www.cnblogs.com/kklldog/p/19449864",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kklldog/p/19449864\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 01:32\">\n    <span>为什么说 IO 操作异步才有意义</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>为什么说 IO 操作异步才有意义，CPU 密集操作异步没有意义</p>\n<h2 id=\"背景与问题\">背景与问题</h2>\n<p>在后端开发中，我们经常讨论异步编程模型，尤其是在 Node.js、Netty 等技术栈中。一个普遍的共识是：异步对于 IO 操作 效果显著，而对于 CPU 密集型操作 却意义不大，甚至可能起反作用。这背后的原因是什么？</p>\n<p>本文的目标就是深入计算机的底层运行机制，从根本上解释清楚这两类操作的本质区别，从而阐明异步的真正价值所在。</p>\n<hr />\n<h2 id=\"核心原理与类比\">核心原理与类比</h2>\n<p>要理解这个问题的核心，关键在于回答一个问题：在执行任务时，CPU 到底是在“等别人干活”，还是在“自己亲自干活”？</p>\n<h3 id=\"核心逻辑谁在干活一个餐厅的比喻\">核心逻辑：谁在干活？一个餐厅的比喻</h3>\n<p>我们可以用一个简单的餐厅模型来直观地理解。</p>\n<h3 id=\"io-操作异步最有用的场景\">IO 操作（异步最有用的场景）</h3>\n<ol>\n<li>场景定义: 典型的 IO 操作包括读取文件、请求数据库、访问网络接口等。</li>\n<li>核心特征: IO 操作的核心特征是 CPU 在大部分时间里都在“等”。对于 CPU 而言，这些操作极慢。CPU 执行指令的速度是纳秒级 (ns)，而一次网络或磁盘 IO 的耗时是毫秒级 (ms)，两者相差数个数量级。</li>\n</ol>\n<h3 id=\"微波炉比喻\">微波炉比喻:</h3>\n<ul>\n<li>这个过程好比你（CPU）在餐厅后厨用微波炉热饭（执行 IO 操作）。真正干活的是微波炉（硬盘/网卡）。巨大的速度差异意味着，你按一下微波炉的开关（发送 IO 请求），然后微波炉可能需要转很长时间才能把饭热好。</li>\n<li>同步模式：你按下微波炉的开关，然后像个雕像一样站在它面前干等，直到饭热好。在这期间，你什么别的事也做不了，这极大地浪费了 CPU 资源。</li>\n<li>异步模式：你按下开关，定个闹钟（设置回调），然后就立刻转身去切菜、打扫卫生。等微波炉“叮”的一声（中断通知），你再回来处理热好的饭。这种模式极大地提升了 CPU 利用率。</li>\n</ul>\n<h3 id=\"结论\">结论</h3>\n<p>IO 操作适合异步，因为工作主要由外部设备完成，CPU 本身处于闲置状态。异步编程模型可以有效利用这段宝贵的闲置时间去处理其他任务。</p>\n<h3 id=\"cpu-密集操作异步意义不大\">CPU 密集操作（异步意义不大）</h3>\n<p>场景定义: 典型的 CPU 密集型操作包括视频转码、数据加密解密、复杂的数学计算、训练神经网络等。</p>\n<h3 id=\"做酸辣土豆丝比喻\">做酸辣土豆丝比喻:</h3>\n<ul>\n<li>这个过程好比小红想要(CPU main thread)做一盘酸辣土豆丝（CPU 密集操作）。</li>\n<li>在这种场景下强行“异步”，行为就变成了：小红呼叫小明（CPU another thread）来替她切土豆，她跑去擦桌子,等小明切好土豆丝了，小红再回来继续起油锅烧土豆丝。</li>\n<li>这种行为的后果是，切土豆丝的总工作量一点没少，反而因为小红在土豆丝切好后再次接管烧菜这件事而引入了额外的“上下文切换开销”，导致整体效率变得更低。</li>\n<li>可能有同学不理解，觉得这个没问题啊，小红明明空出来了啊，去做别的事情了啊，这不是效率提高了吗？真的是这样吗？小红不呼叫小明切土豆，那小明这时候也是空闲的啊。小明直接去擦桌子，小红直接切土豆丝然后烧土豆丝，这个过程才是效率最高的。</li>\n</ul>\n<h3 id=\"结论-1\">结论</h3>\n<p>CPU 密集型任务不适合异步，因为调度其他线程来完成 CPU 密集操作的效率不如当前线程直接计算高。强行切换任务只会带来不必要的开销。</p>\n<h2 id=\"深入技术视角计算机如何处理任务\">深入技术视角：计算机如何处理任务</h2>\n<p>从更技术的层面来看，这两种场景的底层机制差异巨大。</p>\n<h3 id=\"io-密集型dma-的功劳\">IO 密集型：DMA 的功劳</h3>\n<p>CPU 在执行 IO 操作时之所以可以“脱身”，关键在于 DMA（直接存储器访问） 机制。</p>\n<p>当我们的代码执行一个 IO 请求（例如 Node.js 中的 fs.readFile()）时，CPU 实际上只是向磁盘控制器下达一个指令：“把这个文件的数据读到内存的这个位置，完成后通知我。”</p>\n<p>指令下达后，CPU 就立刻被释放，可以去处理其他任务了。真正的数据拷贝工作由 DMA 控制器全权负责，它会在磁盘和内存之间直接搬运数据，整个过程不需要占用 CPU。工作完成后，DMA 会通过一个中断信号通知 CPU。</p>\n<p>因此，这个过程可以精炼地总结为：异步 IO = CPU 外包工作 + 中断通知。</p>\n<h3 id=\"cpu-密集型线程的竞争\">CPU 密集型：线程的竞争</h3>\n<p>对于 CPU 密集型任务，情况完全不同。这类任务需要持续占用 CPU 的核心计算资源，例如 ALU（算术逻辑单元） 和寄存器。</p>\n<ul>\n<li>单线程阻塞: 在一个单线程环境（如 Node.js 主线程）中执行一个耗时很长的计算任务，会导致整个程序假死。因为 CPU 全力在计算，根本无暇响应任何其他事件（如网络请求、用户点击）。</li>\n<li>多线程开销: 在多线程环境中，如果大量并发的 CPU 密集型任务在少数几个 CPU 核心上运行，会导致 CPU 频繁进行上下文切换 (Context Switch)。操作系统需要不断地保存当前线程的运行状态（例如寄存器里的值、程序计数器等），再加载下一个线程的状态。这个“保存现场”和“恢复现场”的过程本身就会消耗大量 CPU 资源，导致实际用于计算的时间减少。</li>\n</ul>\n<h2 id=\"特殊情况何时-cpu-操作需要异步\">特殊情况：何时 CPU 操作需要“异步”？</h2>\n<p>虽然 CPU 密集型操作通过异步无法提高整体吞吐量，但在一种特殊场景下，这种“异步”是有意义的。</p>\n<ol>\n<li>核心目的: 此时，异步的目的不再是提升效率，而是为了保持响应性 (Responsiveness)。</li>\n<li>场景举例: 最典型的就是 GUI 界面，例如浏览器。假设你在网页中用 JavaScript 执行一个大规模的同步计算，UI 渲染线程会被完全阻塞，导致页面卡死，用户无法进行任何操作。</li>\n<li>解决方案: 我们可以通过 Web Worker 将计算任务放到一个独立的线程中，或者使用 setTimeout 将大任务拆分成许多小块分片执行。</li>\n<li>本质分析: 这种“异步化”处理并没有减少总的计算时间（甚至可能因为切换开销而变慢），但它的核心价值在于避免主线程被堵塞，从而保证了界面的流畅和用户的交互体验。</li>\n</ol>\n<hr />\n<h2 id=\"总结与延伸\">总结与延伸</h2>\n<p>通过以上的分析，我们可以清晰地看到 IO 密集型和 CPU 密集型任务在本质上的区别，以及异步模型适用性的根源。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">特性</th>\n<th style=\"text-align: left;\">IO 密集型 (IO-Bound)</th>\n<th style=\"text-align: left;\">CPU 密集型 (CPU-Bound)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>主要瓶颈</strong></td>\n<td style=\"text-align: left;\">网络、硬盘、数据库</td>\n<td style=\"text-align: left;\">CPU 计算能力</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>CPU 状态</strong></td>\n<td style=\"text-align: left;\">大部分时间在等待</td>\n<td style=\"text-align: left;\">大部分时间在全速运转</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>异步的价值</strong></td>\n<td style=\"text-align: left;\">极高。利用等待时间处理其他并发请求（高并发的核心）。</td>\n<td style=\"text-align: left;\">低。切换其他线程来代替当前线程计算不会有性能提升，只要开销</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>典型例子</strong></td>\n<td style=\"text-align: left;\">Web 服务器接口、文件上传下载</td>\n<td style=\"text-align: left;\">视频压缩、区块链挖矿、图像渲染</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>最佳策略</strong></td>\n<td style=\"text-align: left;\">异步非阻塞 (Async/Await, Reactive)</td>\n<td style=\"text-align: left;\">多进程、多线程并行 (Parallelism)</td>\n</tr>\n</tbody>\n</table>\n<p>一句话总结：</p>\n<p>异步是为了填补 CPU 的空窗期。IO 操作有巨大的空窗期，所以异步有意义；CPU 密集操作切换其他线程来代替当前线程计算不会有性能提升，只要开销。</p>\n<h2 id=\"关注我的公众号一起玩转技术\">关注我的公众号一起玩转技术</h2>\n<p><img alt=\"\" src=\"https://static.xbaby.xyz/qrcode.jpg\" /></p>\n\n</div>\n<div id=\"MySignature\">\n    <div id=\"AllanboltSignature\">        \n<p id=\"PSignature\">       \nQQ群：1022985150 VX：kklldog 一起探讨学习.NET技术\n<br />\n作者：<a href=\"http://www.cnblogs.com/kklldog\" target=\"_blank\">Agile.Zhou(kklldog)</a>            \n<br /> \n出处：<a href=\"http://www.cnblogs.com/kklldog/\" target=\"_blank\">http://www.cnblogs.com/kklldog/</a>\n<br />本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。\n </p>  \n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 01:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kklldog\">Agile.Zhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Claude Code 完全指南:使用方式、技巧与最佳实践",
      "link": "https://www.cnblogs.com/knqiufan/p/19449849",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/knqiufan/p/19449849\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 00:55\">\n    <span>Claude Code 完全指南:使用方式、技巧与最佳实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"claude-code-完全指南使用方式技巧与最佳实践\">Claude Code 完全指南:使用方式、技巧与最佳实践</h1>\n<p>最近在深度使用 Claude Code，发现真的很香！即整理了一份全面的指南，从零开始逐步了解 Claude Code 的核心功能、高级特性和最佳实践。这篇博客实际上更像是一本工具书，让我自己在使用时也能随时参考其内容，更好的使用这个强大的 AI 工具。</p>\n<h2 id=\"目录\">目录</h2>\n<ul>\n<li><a href=\"#%E4%B8%80claude-code-%E7%AE%80%E4%BB%8B\" rel=\"noopener nofollow\">一、Claude Code 简介</a></li>\n<li><a href=\"#%E4%BA%8C%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE\" rel=\"noopener nofollow\">二、安装与配置</a></li>\n<li><a href=\"#%E4%B8%89%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3\" rel=\"noopener nofollow\">三、核心概念详解</a></li>\n<li><a href=\"#%E5%9B%9B%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD\" rel=\"noopener nofollow\">四、高级功能</a></li>\n<li><a href=\"#%E4%BA%94%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C\" rel=\"noopener nofollow\">五、实用技巧与快捷操作</a></li>\n<li><a href=\"#%E5%85%AD%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\" rel=\"noopener nofollow\">六、最佳实践</a></li>\n<li><a href=\"#%E4%B8%83%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B\" rel=\"noopener nofollow\">七、实战案例</a></li>\n<li><a href=\"#%E5%85%AB%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\" rel=\"noopener nofollow\">八、常见问题与解决方案</a></li>\n</ul>\n<hr />\n<h2 id=\"一claude-code-简介\">一、Claude Code 简介</h2>\n<h3 id=\"11-什么是-claude-code\">1.1 什么是 Claude Code?</h3>\n<p>Claude Code(CC)是由 Anthropic 开发的<strong>系统级 AI Agent</strong>,它不仅是一个代码编写工具,更是一个可以通过自然语言指令完成各种电脑任务的智能助手。</p>\n<p><strong>核心特性:</strong></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>🔧 <strong>全功能访问</strong></td>\n<td>拥有系统级权限,可执行文件操作、运行命令、管理进程等</td>\n</tr>\n<tr>\n<td>🧠 <strong>超大上下文</strong></td>\n<td>支持 200K token 上下文窗口,可处理大型项目</td>\n</tr>\n<tr>\n<td>🔌 <strong>高度可扩展</strong></td>\n<td>支持 MCP、Skills、Plugins、Hooks 等多种扩展方式</td>\n</tr>\n<tr>\n<td>🤖 <strong>多代理协作</strong></td>\n<td>支持子代理(Subagents)并行处理复杂任务</td>\n</tr>\n<tr>\n<td>💬 <strong>自然交互</strong></td>\n<td>支持自然语言指令,无需学习复杂命令语法</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"12-claude-code-vs-传统工具\">1.2 Claude Code vs 传统工具</h3>\n<div class=\"mermaid\">graph LR\n    A[传统开发工具] --&gt; B[代码编辑器]\n    A --&gt; C[Chat AI工具]\n    A --&gt; D[Coding助手]\n\n    E[Claude Code] --&gt; F[代码编写]\n    E --&gt; G[对话问答]\n    E --&gt; H[数据分析]\n    E --&gt; I[文件管理]\n    E --&gt; J[爬虫自动化]\n    E --&gt; K[Office处理]\n\n    style E fill:#667eea\n    style F fill:#764ba2\n    style G fill:#764ba2\n    style H fill:#764ba2\n    style I fill:#764ba2\n    style J fill:#764ba2\n    style K fill:#764ba2\n</div><p><strong>核心差异:</strong></p>\n<ul>\n<li><strong>传统工具</strong>:单一功能,需要人工操作多个工具完成复杂任务</li>\n<li><strong>Claude Code</strong>:系统级 AI Agent,通过自然语言指令即可完成全流程任务</li>\n</ul>\n<hr />\n<h2 id=\"二安装与配置\">二、安装与配置</h2>\n<h3 id=\"21-前置准备\">2.1 前置准备</h3>\n<p><strong>必需工具:</strong></p>\n<table>\n<thead>\n<tr>\n<th>工具</th>\n<th>用途</th>\n<th>安装地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Node.js</td>\n<td>运行环境</td>\n<td><a href=\"https://nodejs.org\" rel=\"noopener nofollow\" target=\"_blank\">https://nodejs.org</a></td>\n</tr>\n<tr>\n<td>Git</td>\n<td>版本控制</td>\n<td><a href=\"https://git-scm.com\" rel=\"noopener nofollow\" target=\"_blank\">https://git-scm.com</a></td>\n</tr>\n<tr>\n<td>API Key</td>\n<td>模型服务</td>\n<td>智谱GLM/月之暗面K2/阿里Qwen等</td>\n</tr>\n</tbody>\n</table>\n<p><strong>验证安装:</strong></p>\n<pre><code class=\"language-bash\"># 检查 Node.js 版本\nnode -v\n\n# 检查 Git 版本\ngit --version\n</code></pre>\n<h3 id=\"22-安装-claude-code\">2.2 安装 Claude Code</h3>\n<p><strong>全局安装(推荐):</strong></p>\n<pre><code class=\"language-bash\">npm install -g @anthropic-ai/claude-code\n</code></pre>\n<p><strong>验证安装:</strong></p>\n<pre><code class=\"language-bash\">claude --version\n</code></pre>\n<h3 id=\"23-配置模型\">2.3 配置模型</h3>\n<p>Claude Code 支持多种模型配置方式,你可以根据自己的需求选择合适的模型。</p>\n<h4 id=\"方式一手动配置通用方式\">方式一:手动配置(通用方式)</h4>\n<p>手动配置适用于所有兼容 Anthropic API 的模型。配置方式如下:</p>\n<p><strong>Windows:</strong></p>\n<pre><code class=\"language-cmd\">setx ANTHROPIC_BASE_URL \"模型API地址\"\nsetx ANTHROPIC_AUTH_TOKEN \"你的API密钥\"\nsetx ANTHROPIC_MODEL \"模型名称\"\n</code></pre>\n<p><strong>macOS/Linux:</strong></p>\n<pre><code class=\"language-bash\">export ANTHROPIC_BASE_URL=模型API地址\nexport ANTHROPIC_AUTH_TOKEN=你的API密钥\nexport ANTHROPIC_MODEL=模型名称\n\n# 永久配置(添加到 ~/.bashrc 或 ~/.zshrc)\necho 'export ANTHROPIC_BASE_URL=模型API地址' &gt;&gt; ~/.bashrc\necho 'export ANTHROPIC_AUTH_TOKEN=你的API密钥' &gt;&gt; ~/.bashrc\necho 'export ANTHROPIC_MODEL=模型名称' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre>\n<p><strong>常用国内模型配置示例:</strong></p>\n<table>\n<thead>\n<tr>\n<th>模型</th>\n<th>API地址</th>\n<th>模型名称</th>\n<th>获取API Key</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>智谱 GLM-4.7</strong></td>\n<td><code>https://open.bigmodel.cn/api/anthropic</code></td>\n<td><code>GLM-4.7</code></td>\n<td><a href=\"https://open.bigmodel.cn/\" rel=\"noopener nofollow\" target=\"_blank\">https://open.bigmodel.cn/</a></td>\n</tr>\n<tr>\n<td><strong>Kimi K2</strong></td>\n<td><code>https://api.moonshot.cn/v1</code></td>\n<td><code>kimi-k2</code></td>\n<td><a href=\"https://platform.moonshot.cn/console/account\" rel=\"noopener nofollow\" target=\"_blank\">https://platform.moonshot.cn/console/account</a></td>\n</tr>\n<tr>\n<td><strong>通义千问</strong></td>\n<td><code>https://dashscope.aliyuncs.com/compatible-mode/v1</code></td>\n<td><code>qwen-coder-plus</code></td>\n<td><a href=\"https://bailian.console.aliyun.com/\" rel=\"noopener nofollow\" target=\"_blank\">https://bailian.console.aliyun.com/</a></td>\n</tr>\n<tr>\n<td><strong>DeepSeek</strong></td>\n<td><code>https://api.deepseek.com/v1</code></td>\n<td><code>deepseek-coder</code></td>\n<td><a href=\"https://platform.deepseek.com/\" rel=\"noopener nofollow\" target=\"_blank\">https://platform.deepseek.com/</a></td>\n</tr>\n</tbody>\n</table>\n<p><strong>配置示例(以智谱GLM为例):</strong></p>\n<pre><code class=\"language-bash\">export ANTHROPIC_BASE_URL=https://open.bigmodel.cn/api/anthropic\nexport ANTHROPIC_AUTH_TOKEN=your_glm_api_key\nexport ANTHROPIC_MODEL=GLM-4.7\n</code></pre>\n<p><strong>注意:</strong> 配置环境变量后需要重启终端或运行 <code>source ~/.bashrc</code> 使配置生效。</p>\n<h4 id=\"方式二使用自动化助手仅适用于智谱glm\">方式二:使用自动化助手(仅适用于智谱GLM)</h4>\n<p>如果选择使用智谱GLM系列模型,还可以使用自动化配置助手:</p>\n<pre><code class=\"language-bash\">npx @z_ai/coding-helper\n</code></pre>\n<p>按照交互式提示完成配置:</p>\n<ol>\n<li>选择界面语言</li>\n<li>设置 Coding 套餐</li>\n<li>配置 API 密钥</li>\n<li>选择编码工具</li>\n</ol>\n<p>这种方式可以自动完成智谱GLM模型的配置,适合不想手动设置环境变量的用户。</p>\n<h4 id=\"国内模型对比\">国内模型对比</h4>\n<table>\n<thead>\n<tr>\n<th>模型</th>\n<th>提供商</th>\n<th>代码能力</th>\n<th>价格</th>\n<th>优势</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>GLM-4.7</strong></td>\n<td>智谱AI</td>\n<td>⭐⭐⭐⭐⭐</td>\n<td>中等</td>\n<td>中文理解强,有Coding套餐</td>\n<td>中文项目为主</td>\n</tr>\n<tr>\n<td><strong>Kimi K2</strong></td>\n<td>月之暗面</td>\n<td>⭐⭐⭐⭐⭐</td>\n<td>较低</td>\n<td>超长上下文,MoE架构</td>\n<td>大型项目重构</td>\n</tr>\n<tr>\n<td><strong>Qwen-Coder-Plus</strong></td>\n<td>阿里云</td>\n<td>⭐⭐⭐⭐⭐</td>\n<td>低</td>\n<td>开源,性能优秀</td>\n<td>Python/JS项目</td>\n</tr>\n<tr>\n<td><strong>DeepSeek-Coder</strong></td>\n<td>深度求索</td>\n<td>⭐⭐⭐⭐</td>\n<td>极低</td>\n<td>价格优势</td>\n<td>预算有限的场景</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"24-启动-claude-code\">2.4 启动 Claude Code</h3>\n<p><strong>基本启动:</strong></p>\n<pre><code class=\"language-bash\">claude\n</code></pre>\n<p><strong>危险模式(跳过权限确认):</strong></p>\n<pre><code class=\"language-bash\">claude --dangerously-skip-permissions\n</code></pre>\n<p><strong>Headless 模式(非交互式):</strong></p>\n<pre><code class=\"language-bash\">git diff | claude -p \"解释这些更改\"\n</code></pre>\n<hr />\n<h2 id=\"三核心概念详解\">三、核心概念详解</h2>\n<p>了解了 Claude Code 的安装配置后，深入了解一下它的一些核心概念。这些概念是充分发挥 Claude Code 能力的基础。</p>\n<h3 id=\"31-skills技能包\">3.1 Skills(技能包)</h3>\n<h4 id=\"什么是-skills\">什么是 Skills?</h4>\n<p><strong>Skills</strong> 是预封装的工作流,就像游戏中的\"技能包\",用完即走,不占用上下文。它是别人已经编写好的、可直接使用的功能模块。</p>\n<p><strong>官方 Skills 库:</strong> <a href=\"https://github.com/anthropics/skills\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/skills</a> (32k+ Stars)</p>\n<h4 id=\"skills-的类型\">Skills 的类型</h4>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>User Skills</strong></td>\n<td>用户自定义技能,存储在本地</td>\n<td>个人工作流自动化</td>\n</tr>\n<tr>\n<td><strong>Plugin Skills</strong></td>\n<td>插件提供的技能,随插件安装</td>\n<td>frontend-design</td>\n</tr>\n<tr>\n<td><strong>Built-in Skills</strong></td>\n<td>Claude Code 内置技能</td>\n<td>commit, review-pr</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"常用官方-skills\">常用官方 Skills</h4>\n<pre><code class=\"language-bash\"># 前端设计技能\nnpx skills-installer install @anthropics/claude-code/frontend-design --client claude-code\n\n# 文档协同技能\nnpx skills-installer install @anthropics/claude-code/doc-coauthoring --client claude-code\n\n# Canvas 设计技能\nnpx skills-installer install @anthropics/claude-code/canvas-design --client claude-code\n\n# PDF 处理技能\nnpx skills-installer install @anthropics/claude-code/pdf --client claude-code\n\n# 算法艺术生成\nnpx skills-installer install @anthropics/claude-code/algorithmic-art --client claude-code\n</code></pre>\n<h4 id=\"如何使用-skills\">如何使用 Skills</h4>\n<p><strong>查看可用 Skills:</strong></p>\n<pre><code class=\"language-bash\">claude /skills\n</code></pre>\n<p><strong>调用 Skill:</strong></p>\n<pre><code class=\"language-bash\"># 在 Claude Code 对话中\n使用 frontend-design skill 优化 https://example.com\n\n使用 pdf skill 提取 report.pdf 中的表格数据\n</code></pre>\n<h4 id=\"如何编写自己的-skills\">如何编写自己的 Skills</h4>\n<p><strong>Skill 目录结构:</strong></p>\n<pre><code>my-skill/\n├── skill.json          # Skill 元数据\n├── skill.md            # Skill 文档\n├── api/                # API 定义(可选)\n└── tools/              # 自定义工具(可选)\n</code></pre>\n<p><strong>skill.json 示例:</strong></p>\n<pre><code class=\"language-json\">{\n  \"name\": \"my-custom-skill\",\n  \"description\": \"我的自定义技能\",\n  \"version\": \"1.0.0\",\n  \"author\": \"Your Name\",\n  \"categories\": [\"automation\"],\n  \"license\": \"MIT\",\n  \"skill\": {\n    \"file\": \"skill.md\",\n    \"description\": \"这个技能用于...\"\n  }\n}\n</code></pre>\n<p><strong>skill.md 示例:</strong></p>\n<pre><code class=\"language-markdown\"># My Custom Skill\n\n这个技能帮助用户快速完成[特定任务]。\n\n## 使用场景\n\n- 场景1:描述...\n- 场景2:描述...\n\n## 使用方式\n\n用户只需要告诉你要完成什么,这个技能就会自动:\n\n1. 分析需求\n2. 执行步骤\n3. 返回结果\n\n## 注意事项\n\n- 注意事项1\n- 注意事项2\n</code></pre>\n<p><strong>安装本地 Skill:</strong></p>\n<pre><code class=\"language-bash\"># 将技能复制到 Claude Code 配置目录\ncp -r my-skill ~/.claude/skills/\n\n# 或使用安装命令\nnpx skills-installer install ./my-skill --client claude-code\n</code></pre>\n<h3 id=\"32-hooks钩子\">3.2 Hooks(钩子)</h3>\n<h4 id=\"什么是-hooks\">什么是 Hooks?</h4>\n<p><strong>Hooks</strong> 是在特定事件触发时自动执行的脚本,用于自定义工作流、拦截危险操作、自动格式化代码等。</p>\n<p><strong>核心价值:</strong></p>\n<div class=\"mermaid\">graph LR\n    A[事件触发] --&gt; B{Hook 拦截}\n    B --&gt; C[执行自定义脚本]\n    C --&gt; D[返回结果]\n    D --&gt; E[继续/阻止操作]\n\n    style B fill:#f093fb\n    style C fill:#f5576c\n</div><h4 id=\"hook-事件类型\">Hook 事件类型</h4>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n<th>典型用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>user-prompt-submit</strong></td>\n<td>用户提交提示词前</td>\n<td>验证、修改提示词</td>\n</tr>\n<tr>\n<td><strong>tool-use</strong></td>\n<td>工具使用前</td>\n<td>权限检查、参数验证</td>\n</tr>\n<tr>\n<td><strong>after-tool-use</strong></td>\n<td>工具使用后</td>\n<td>日志记录、结果处理</td>\n</tr>\n<tr>\n<td><strong>permission-request</strong></td>\n<td>权限请求时</td>\n<td>拦截危险操作</td>\n</tr>\n<tr>\n<td><strong>notification</strong></td>\n<td>通知时</td>\n<td>发送告警、更新状态</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"hook-配置方式\">Hook 配置方式</h4>\n<p><strong>方式一:通过 /hooks 命令</strong></p>\n<pre><code class=\"language-bash\"># 在 Claude Code 中\n/hooks\n</code></pre>\n<p><strong>方式二:通过配置文件</strong></p>\n<p>在 <code>~/.claude/settings.json</code> 或项目 <code>.claude/settings.json</code> 中配置:</p>\n<pre><code class=\"language-json\">{\n  \"hooks\": {\n    \"user-prompt-submit-hook\": {\n      \"command\": \"npm run validate-prompt\",\n      \"enabled\": true\n    },\n    \"tool-use-hook\": {\n      \"command\": \"~/.claude/hooks/check-permission.sh\",\n      \"enabled\": true,\n      \"blocking\": true\n    },\n    \"after-tool-use-hook\": {\n      \"command\": \"echo 'Tool used: {{toolName}}' &gt;&gt; ~/.claude/hooks.log\",\n      \"enabled\": true\n    }\n  }\n}\n</code></pre>\n<h4 id=\"hook-实战示例\">Hook 实战示例</h4>\n<p><strong>拦截危险命令:</strong></p>\n<pre><code class=\"language-bash\">#!/bin/bash\n# ~/.claude/hooks/check-dangerous.sh\n\n# 读取工具调用信息\nTOOL_NAME=$(jq -r '.toolName' &lt;&lt;&lt; \"$CLAUDE_HOOK_INPUT\")\n\n# 危险操作列表\nDANGEROUS_TOOLS=(\"rm\" \"delete\" \"format\" \"shutdown\")\n\nif [[ \" ${DANGEROUS_TOOLS[@]} \" =~ \" ${TOOL_NAME} \" ]]; then\n  echo \"⚠️  警告:即将执行危险操作 - $TOOL_NAME\"\n  echo \"请确认是否继续? (yes/no)\"\n  read -r confirmation\n  if [[ \"$confirmation\" != \"yes\" ]]; then\n    exit 1  # 阻止操作\n  fi\nfi\n</code></pre>\n<p><strong>自动格式化代码:</strong></p>\n<pre><code class=\"language-json\">{\n  \"hooks\": {\n    \"after-write-hook\": {\n      \"command\": \"if [[ {{filePath}} == *.js ]]; then prettier --write {{filePath}}; fi\",\n      \"enabled\": true,\n      \"blocking\": false\n    }\n  }\n}\n</code></pre>\n<p><strong>发送通知:</strong></p>\n<pre><code class=\"language-json\">{\n  \"hooks\": {\n    \"task-complete-hook\": {\n      \"command\": \"notify-send 'Claude Code' '任务已完成'\",\n      \"enabled\": true\n    }\n  }\n}\n</code></pre>\n<h3 id=\"33-plugins插件\">3.3 Plugins(插件)</h3>\n<h4 id=\"什么是-plugins\">什么是 Plugins?</h4>\n<p><strong>Plugins</strong> 是打包在一起的扩展集合,可以包含:</p>\n<ul>\n<li>5 个 Skills</li>\n<li>10 个斜杠命令</li>\n<li>3 个 MCP 服务器配置</li>\n<li>2 个 SubAgent 定义</li>\n<li>若干 Hooks</li>\n</ul>\n<p><strong>Plugins vs Skills:</strong></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Skills</th>\n<th>Plugins</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>复杂度</strong></td>\n<td>简单工作流</td>\n<td>完整功能套件</td>\n</tr>\n<tr>\n<td><strong>内容</strong></td>\n<td>单一技能</td>\n<td>多种资源的集合</td>\n</tr>\n<tr>\n<td><strong>安装</strong></td>\n<td>独立安装</td>\n<td>一次性安装多个资源</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>单一任务</td>\n<td>完整解决方案</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"plugin-安装与使用\">Plugin 安装与使用</h4>\n<h5 id=\"哪里获取已有-plugins\">哪里获取已有 Plugins?</h5>\n<p><strong>官方插件市场:</strong></p>\n<table>\n<thead>\n<tr>\n<th>来源</th>\n<th>地址</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Anthropic Skills</strong></td>\n<td><a href=\"https://github.com/anthropics/skills\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/skills</a></td>\n<td>官方Skills库,包含多个插件</td>\n</tr>\n<tr>\n<td><strong>Claude Code Marketplace</strong></td>\n<td><a href=\"https://claudecodemarketplaces.com\" rel=\"noopener nofollow\" target=\"_blank\">https://claudecodemarketplaces.com</a></td>\n<td>插件市场目录</td>\n</tr>\n<tr>\n<td><strong>Awesome Claude Code</strong></td>\n<td><a href=\"https://awesomeclaude.ai/plugins\" rel=\"noopener nofollow\" target=\"_blank\">https://awesomeclaude.ai/plugins</a></td>\n<td>社区插件精选</td>\n</tr>\n</tbody>\n</table>\n<p><strong>添加插件市场:</strong></p>\n<pre><code class=\"language-bash\"># 添加官方Anthropic插件市场\nclaude /plugin marketplace add anthropics/skills\n\n# 添加本地插件市场\nclaude /plugin marketplace add ~/my-marketplace\n\n# 浏览可用插件\nclaude /plugin\n# 选择 \"Browse Plugins\" 查看完整列表\n</code></pre>\n<p><strong>常用官方插件:</strong></p>\n<pre><code class=\"language-bash\"># 文档处理插件套件\nclaude /plugin marketplace add anthropics/skills\nclaude /plugin install document-skills\n\n# 前端开发插件\nclaude /plugin install frontend-design\n\n# Git工作流插件\nclaude /plugin install git-workflow\n</code></pre>\n<h5 id=\"安装-plugin\">安装 Plugin</h5>\n<p><strong>从市场安装:</strong></p>\n<pre><code class=\"language-bash\">claude plugin install &lt;plugin-name&gt;\n</code></pre>\n<p><strong>从本地安装:</strong></p>\n<pre><code class=\"language-bash\"># 安装本地插件\nclaude plugin install ./my-plugin\n\n# 或使用完整路径\nclaude plugin install /path/to/my-plugin\n</code></pre>\n<p><strong>从GitHub安装:</strong></p>\n<pre><code class=\"language-bash\"># 直接从GitHub仓库安装\nclaude plugin install github:user/repo\n</code></pre>\n<h5 id=\"查看-plugins\">查看 Plugins</h5>\n<p><strong>查看已安装 Plugins:</strong></p>\n<pre><code class=\"language-bash\">claude /plugin\n</code></pre>\n<p><strong>浏览可用插件:</strong></p>\n<pre><code class=\"language-bash\"># 在Claude Code中输入\n/plugin\n# 选择 \"Browse Plugins\"\n</code></pre>\n<p><strong>卸载 Plugin:</strong></p>\n<pre><code class=\"language-bash\">claude plugin uninstall &lt;plugin-name&gt;\n</code></pre>\n<p><strong>创建自定义 Plugin:</strong></p>\n<pre><code>my-plugin/\n├── plugin.json           # Plugin 配置\n├── skills/              # Skills 目录\n│   ├── skill1/\n│   └── skill2/\n├── commands/            # 自定义斜杠命令\n│   └── my-command.md\n├── mcp/                 # MCP 配置\n│   └── mcp-config.json\n├── agents/              # SubAgent 定义\n│   └── agent1.json\n└── hooks/               # Hook 脚本\n    └── hook1.sh\n</code></pre>\n<p><strong>plugin.json 示例:</strong></p>\n<pre><code class=\"language-json\">{\n  \"name\": \"my-plugin\",\n  \"version\": \"1.0.0\",\n  \"description\": \"我的自定义插件\",\n  \"author\": \"Your Name\",\n  \"skills\": [\n    \"skills/skill1\",\n    \"skills/skill2\"\n  ],\n  \"commands\": [\n    {\n      \"name\": \"/my-command\",\n      \"description\": \"我的自定义命令\",\n      \"file\": \"commands/my-command.md\"\n    }\n  ],\n  \"mcpServers\": [\n    {\n      \"name\": \"my-mcp\",\n      \"config\": \"mcp/mcp-config.json\"\n    }\n  ],\n  \"agents\": [\n    {\n      \"name\": \"my-agent\",\n      \"config\": \"agents/agent1.json\"\n    }\n  ]\n}\n</code></pre>\n<h3 id=\"34-mcp-servers模型上下文协议服务器\">3.4 MCP Servers(模型上下文协议服务器)</h3>\n<h4 id=\"什么是-mcp\">什么是 MCP?</h4>\n<p><strong>MCP (Model Context Protocol)</strong> 是 AI 的扩展接口标准,通过添加 MCP 服务器可以扩展 Claude Code 获取外部工具、资源、服务的能力。</p>\n<p><strong>核心概念:</strong></p>\n<div class=\"mermaid\">graph LR\n    A[Claude Code] --&gt; B[MCP Client]\n    B --&gt; C[MCP Server 1]\n    B --&gt; D[MCP Server 2]\n    B --&gt; E[MCP Server N]\n\n    C --&gt; F[GitHub API]\n    D --&gt; G[Database]\n    E --&gt; H[Browser]\n\n    style A fill:#667eea\n    style B fill:#764ba2\n    style C fill:#f093fb\n    style D fill:#f093fb\n    style E fill:#f093fb\n</div><h4 id=\"常用-mcp-服务器\">常用 MCP 服务器</h4>\n<table>\n<thead>\n<tr>\n<th>MCP Server</th>\n<th>功能</th>\n<th>Star 数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>chrome-devtools-mcp</strong></td>\n<td>浏览器自动化,26个工具</td>\n<td>18.5k</td>\n</tr>\n<tr>\n<td><strong>github-mcp</strong></td>\n<td>GitHub API 集成</td>\n<td>10k+</td>\n</tr>\n<tr>\n<td><strong>postgres-mcp</strong></td>\n<td>PostgreSQL 数据库操作</td>\n<td>5k+</td>\n</tr>\n<tr>\n<td><strong>filesystem-mcp</strong></td>\n<td>增强文件系统操作</td>\n<td>3k+</td>\n</tr>\n<tr>\n<td><strong>web-search-mcp</strong></td>\n<td>网络搜索功能</td>\n<td>2k+</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"mcp-安装方式\">MCP 安装方式</h4>\n<p><strong>方式一:命令行安装</strong></p>\n<pre><code class=\"language-bash\">claude mcp add chrome-devtools npx chrome-devtools-mcp@latest\n</code></pre>\n<p><strong>方式二:配置文件安装</strong></p>\n<p>编辑 <code>~/.claude/mcp.json</code>:</p>\n<pre><code class=\"language-json\">{\n  \"mcpServers\": {\n    \"chrome-devtools\": {\n      \"command\": \"npx\",\n      \"args\": [\"chrome-devtools-mcp@latest\"],\n      \"disabled\": false\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_TOKEN\": \"your_github_token_here\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\"],\n      \"env\": {\n        \"POSTGRES_CONNECTION_STRING\": \"postgresql://user:password@localhost:5432/db\"\n      }\n    }\n  }\n}\n</code></pre>\n<p><strong>验证安装:</strong></p>\n<pre><code class=\"language-bash\"># 在 Claude Code 中\n/mcp\n\n# 或通过命令行\nclaude mcp list\nclaude mcp test chrome-devtools\n</code></pre>\n<h4 id=\"chrome-devtools-mcp-实战\">Chrome DevTools MCP 实战</h4>\n<p><strong>安装:</strong></p>\n<pre><code class=\"language-bash\">claude mcp add chrome-devtools npx chrome-devtools-mcp@latest\n</code></pre>\n<p><strong>使用示例:</strong></p>\n<pre><code class=\"language-bash\"># 在 Claude Code 中\n用Chrome浏览器打开 https://example.com,然后通过 chrome devtools mcp 完成以下任务:\n1. 截取页面截图\n2. 提取所有链接\n3. 分析页面结构\n4. 获取页面性能数据\n</code></pre>\n<p><strong>26个内置工具包括:</strong></p>\n<ul>\n<li><code>chrome_navigate</code>: 导航到指定 URL</li>\n<li><code>chrome_screenshot</code>: 截取页面截图</li>\n<li><code>chrome_click</code>: 点击元素</li>\n<li><code>chrome_fill</code>: 填写表单</li>\n<li><code>chrome_select</code>: 选择元素</li>\n<li><code>chrome_evaluate</code>: 执行 JavaScript</li>\n<li>等等...</li>\n</ul>\n<h3 id=\"35-subagents子代理\">3.5 Subagents(子代理)</h3>\n<h4 id=\"什么是-subagents\">什么是 Subagents?</h4>\n<p><strong>Subagents</strong> 是可以并行处理任务的独立 AI 代理,每个子代理拥有独立的 200K 上下文窗口,可以分配不同任务以提高效率。</p>\n<p><strong>核心优势:</strong></p>\n<div class=\"mermaid\">graph TB\n    A[主代理 Claude Code] --&gt; B[子代理1: 代码审查]\n    A --&gt; C[子代理2: 测试编写]\n    A --&gt; D[子代理3: 文档生成]\n    A --&gt; E[子代理4: 性能优化]\n\n    B --&gt; F[并行处理]\n    C --&gt; F\n    D --&gt; F\n    E --&gt; F\n\n    F --&gt; G[结果汇总]\n\n    style A fill:#667eea\n    style B fill:#f093fb\n    style C fill:#f093fb\n    style D fill:#f093fb\n    style E fill:#f093fb\n    style G fill:#764ba2\n</div><h4 id=\"subagent-配置\">Subagent 配置</h4>\n<p><strong>方式一:通过 /agents 命令</strong></p>\n<pre><code class=\"language-bash\">claude /agents\n</code></pre>\n<p><strong>方式二:配置文件</strong></p>\n<p>在 <code>~/.claude/agents.json</code> 或项目 <code>.claude/agents.json</code> 中配置:</p>\n<pre><code class=\"language-json\">{\n  \"agents\": {\n    \"code-reviewer\": {\n      \"description\": \"专门负责代码审查的子代理\",\n      \"model\": \"claude-opus-4-5\",\n      \"instructions\": \"你是一个专业的代码审查专家,专注于检查代码质量、安全漏洞和性能问题。\",\n      \"tools\": [\"read\", \"search\", \"git\"],\n      \"permissions\": {\n        \"allowWrite\": false\n      }\n    },\n    \"test-writer\": {\n      \"description\": \"专门负责编写测试的子代理\",\n      \"model\": \"claude-sonnet-4-5\",\n      \"instructions\": \"你是一个测试工程师,专注于编写全面的单元测试和集成测试。\",\n      \"tools\": [\"read\", \"write\", \"bash\"]\n    },\n    \"doc-generator\": {\n      \"description\": \"专门负责生成文档的子代理\",\n      \"model\": \"claude-sonnet-4-5\",\n      \"instructions\": \"你是一个技术文档专家,专注于生成清晰、准确的技术文档。\",\n      \"tools\": [\"read\", \"write\"]\n    }\n  }\n}\n</code></pre>\n<h4 id=\"subagent-使用示例\">Subagent 使用示例</h4>\n<p><strong>场景:完成一个功能开发</strong></p>\n<pre><code class=\"language-bash\"># 主任务\n我需要完成用户认证功能,请帮我:\n\n1. 使用 code-reviewer agent 审查现有认证代码\n2. 使用 test-writer agent 编写测试用例\n3. 使用 doc-generator agent 更新 API 文档\n\n这三个任务并行执行\n</code></pre>\n<p><strong>Claude Code 会自动:</strong></p>\n<ol>\n<li>创建三个独立的子代理</li>\n<li>分配各自的上下文(200K × 3)</li>\n<li>并行执行任务</li>\n<li>汇总结果返回</li>\n</ol>\n<h3 id=\"36-claudemd项目记忆文件\">3.6 CLAUDE.md(项目记忆文件)</h3>\n<h4 id=\"什么是-claudemd\">什么是 CLAUDE.md?</h4>\n<p><strong>CLAUDE.md</strong> 是 Claude Code 的\"项目记忆文件\",记录项目结构、构建命令、代码规范、架构决策等信息,让 Claude Code 快速理解项目上下文。</p>\n<h4 id=\"claudemd-的作用\">CLAUDE.md 的作用</h4>\n<table>\n<thead>\n<tr>\n<th>作用</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>📚 <strong>项目知识库</strong></td>\n<td>记录项目架构、技术栈、依赖关系</td>\n</tr>\n<tr>\n<td>🚀 <strong>快速启动</strong></td>\n<td>自动读取,无需重复解释项目背景</td>\n</tr>\n<tr>\n<td>🤝 <strong>团队协作</strong></td>\n<td>共享项目规范,确保团队理解一致</td>\n</tr>\n<tr>\n<td>🔄 <strong>持续迭代</strong></td>\n<td>随项目演进自动更新</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"claudemd-最佳位置\">CLAUDE.md 最佳位置</h4>\n<div class=\"mermaid\">graph TD\n    A[项目根目录_CLAUDE.md]\n    B[src_.claude_CLAUDE.md]\n    C[.claude_rules_auth.md]\n    D[home_.claude_CLAUDE.md]\n\n    A --&gt; E[全局项目配置]\n    B --&gt; F[模块级配置]\n    C --&gt; G[特定规则]\n    D --&gt; H[用户级配置]\n\n    style A fill:#667eea\n    style B fill:#764ba2\n    style C fill:#f093fb\n    style D fill:#f5576c\n    style E fill:#667eea\n    style F fill:#764ba2\n    style G fill:#f093fb\n    style H fill:#f5576c\n</div><p><strong>优先级:</strong> 特定规则 &gt; 模块配置 &gt; 项目配置 &gt; 用户配置</p>\n<h4 id=\"claudemd-示例\">CLAUDE.md 示例</h4>\n<p><strong>完整示例:</strong></p>\n<pre><code class=\"language-markdown\"># 项目名称: E-Commerce Platform\n\n## 项目概述\n这是一个基于 Node.js + React 的电商平台,支持商品管理、订单处理、支付集成等功能。\n\n## 技术栈\n- **前端:** React 18, TypeScript, Tailwind CSS, Redux Toolkit\n- **后端:** Node.js 20, Express, TypeScript\n- **数据库:** PostgreSQL 15, Redis 7\n- **认证:** JWT, OAuth 2.0\n- **测试:** Jest, Playwright\n- **部署:** Docker, Kubernetes\n\n## 项目结构\n\\`\\`\\`\nsrc/\n├── frontend/          # React 前端\n│   ├── components/    # 可复用组件\n│   ├── pages/         # 页面组件\n│   ├── store/         # Redux store\n│   └── utils/         # 工具函数\n├── backend/           # Node.js 后端\n│   ├── controllers/   # 控制器\n│   ├── services/      # 业务逻辑\n│   ├── models/        # 数据模型\n│   └── routes/        # API 路由\n└── shared/            # 共享代码\n    └── types/         # TypeScript 类型定义\n\\`\\`\\`\n\n## 常用命令\n\n### 开发环境\n\\`\\`\\`bash\n# 安装依赖\nnpm install\n\n# 启动前端开发服务器\nnpm run dev:frontend\n\n# 启动后端开发服务器\nnpm run dev:backend\n\n# 同时启动前后端\nnpm run dev\n\\`\\`\\`\n\n### 构建与部署\n\\`\\`\\`bash\n# 构建前端\nnpm run build:frontend\n\n# 构建后端\nnpm run build:backend\n\n# 构建所有\nnpm run build\n\n# Docker 构建\ndocker-compose build\ndocker-compose up\n\\`\\`\\`\n\n### 测试\n\\`\\`\\`bash\n# 运行所有测试\nnpm test\n\n# 前端单元测试\nnpm run test:frontend\n\n# 后端单元测试\nnpm run test:backend\n\n# E2E 测试\nnpm run test:e2e\n\n# 测试覆盖率\nnpm run test:coverage\n\\`\\`\\`\n\n### 代码质量\n\\`\\`\\`bash\n# 代码格式化\nnpm run format\n\n# 代码检查\nnpm run lint\n\n# 类型检查\nnpm run type-check\n\\`\\`\\`\n\n## 代码规范\n\n### 命名规范\n- **文件名:** kebab-case (user-profile.ts)\n- **组件名:** PascalCase (UserProfile)\n- **函数/变量:** camelCase (getUserProfile)\n- **常量:** UPPER_SNAKE_CASE (API_BASE_URL)\n- **类型/接口:** PascalCase (UserProfile)\n\n### Git 提交规范\n遵循 Conventional Commits:\n- \\`feat: 新功能\\`\n- \\`fix: 修复 bug\\`\n- \\`docs: 文档更新\\`\n- \\`style: 代码格式调整\\`\n- \\`refactor: 代码重构\\`\n- \\`test: 测试相关\\`\n- \\`chore: 构建/工具链更新\\`\n\n### 代码审查清单\n- [ ] 代码符合项目命名规范\n- [ ] 添加了必要的注释\n- [ ] 更新了相关文档\n- [ ] 编写了/更新了测试\n- [ ] 通过了所有测试\n- [ ] 通过了 lint 检查\n- [ ] 没有引入安全漏洞\n\n## 架构决策\n\n### ADR-001: 选择 TypeScript 而非 JavaScript\n**日期:** 2024-01-15\n**状态:** 已接受\n**理由:**\n- 类型安全减少运行时错误\n- 更好的 IDE 支持\n- 代码可维护性更高\n\n### ADR-002: 采用微服务架构\n**日期:** 2024-02-20\n**状态:** 已接受\n**理由:**\n- 便于团队并行开发\n- 独立部署和扩展\n- 技术栈灵活性\n\n## 环境变量\n\n### 必需变量\n\\`\\`\\`bash\nDATABASE_URL=postgresql://...\nREDIS_URL=redis://...\nJWT_SECRET=your-secret-key\nAPI_BASE_URL=https://api.example.com\n\\`\\`\\`\n\n### 可选变量\n\\`\\`\\`bash\nLOG_LEVEL=info\nNODE_ENV=development\nPORT=3000\n\\`\\`\\`\n\n## 常见问题\n\n### Q: 如何添加新的 API 端点?\nA:\n1. 在 \\`backend/routes/\\` 创建路由文件\n2. 在 \\`backend/controllers/\\` 创建控制器\n3. 在 \\`backend/services/\\` 实现业务逻辑\n4. 添加测试用例\n5. 更新 API 文档\n\n### Q: 如何调试前端状态管理问题?\nA:\n1. 使用 Redux DevTools 浏览器扩展\n2. 在 \\`src/frontend/store/\\` 添加日志\n3. 检查 action 和 reducer 逻辑\n\n## 重要注意事项\n\n1. **安全:** 永远不要在代码中硬编码密钥或敏感信息\n2. **性能:** 大数据查询必须使用分页\n3. **测试:** 所有新功能必须包含测试\n4. **文档:** API 变更必须更新文档\n5. **兼容性:** 确保向后兼容,使用版本控制\n\n## 相关资源\n- [项目 Wiki](https://wiki.example.com)\n- [API 文档](https://docs.example.com)\n- [设计规范](https://design.example.com)\n</code></pre>\n<h4 id=\"生成-claudemd-的方式\">生成 CLAUDE.md 的方式</h4>\n<p><strong>方式一:使用 /init 命令</strong></p>\n<pre><code class=\"language-bash\"># 在项目根目录\nclaude /init\n</code></pre>\n<p>Claude Code 会自动扫描项目并生成初始 CLAUDE.md</p>\n<p><strong>方式二:手动创建</strong></p>\n<pre><code class=\"language-bash\"># 创建基础文件\ntouch CLAUDE.md\n\n# 让 Claude Code 帮助生成\nclaude \"请根据当前项目结构生成 CLAUDE.md 文件\"\n</code></pre>\n<p><strong>方式三:模块化规则</strong></p>\n<pre><code class=\"language-bash\"># 在 .claude/rules/ 目录创建多个规则文件\n.claude/rules/\n├── auth.md          # 认证相关规则\n├── database.md      # 数据库相关规则\n├── api.md           # API 设计规范\n└── testing.md       # 测试规范\n</code></pre>\n<hr />\n<h2 id=\"四高级功能\">四、高级功能</h2>\n<p>实际上CC还有一些高级功能，这些功能将帮助更高效地完成复杂任务。</p>\n<h3 id=\"41-plan-模式规划模式\">4.1 Plan 模式(规划模式)</h3>\n<h4 id=\"什么是-plan-模式\">什么是 Plan 模式?</h4>\n<p><strong>Plan 模式</strong>是一种\"先规划、后执行\"的工作模式,Claude 会先分析项目架构、依赖关系并起草实现方案,确认后才开始编写代码。</p>\n<p><strong>核心价值:</strong></p>\n<div class=\"mermaid\">graph LR\n    A[接收任务] --&gt; B[分析项目]\n    B --&gt; C[探索代码库]\n    C --&gt; D[设计方案]\n    D --&gt; E{用户确认?}\n    E --&gt;|是| F[执行实现]\n    E --&gt;|否| G[调整方案]\n    G --&gt; D\n    F --&gt; H[完成任务]\n\n    style B fill:#667eea\n    style C fill:#764ba2\n    style D fill:#f093fb\n    style E fill:#f5576c\n    style F fill:#4facfe\n</div><h4 id=\"进入-plan-模式\">进入 Plan 模式</h4>\n<p><strong>快捷键:</strong></p>\n<pre><code class=\"language-bash\"># 按两次 Shift+Tab\nShift+Tab, Shift+Tab\n</code></pre>\n<p><strong>命令方式:</strong></p>\n<pre><code class=\"language-bash\">/plan\n</code></pre>\n<h4 id=\"plan-模式工作流程\">Plan 模式工作流程</h4>\n<p><strong>1. 探索阶段</strong></p>\n<ul>\n<li>读取相关文件</li>\n<li>分析代码结构</li>\n<li>理解依赖关系</li>\n</ul>\n<p><strong>2. 规划阶段</strong></p>\n<ul>\n<li>设计实现方案</li>\n<li>列出具体步骤</li>\n<li>识别潜在风险</li>\n</ul>\n<p><strong>3. 确认阶段</strong></p>\n<ul>\n<li>展示完整计划</li>\n<li>等待用户反馈</li>\n<li>根据反馈调整</li>\n</ul>\n<p><strong>4. 执行阶段</strong></p>\n<ul>\n<li>按计划实施</li>\n<li>实时反馈进度</li>\n<li>处理异常情况</li>\n</ul>\n<h4 id=\"plan-模式最佳实践\">Plan 模式最佳实践</h4>\n<p><strong>适合场景:</strong></p>\n<ul>\n<li>✅ 复杂功能开发(多文件、多步骤)</li>\n<li>✅ 架构重构</li>\n<li>✅ 性能优化</li>\n<li>✅ 代码迁移</li>\n<li>✅ 不熟悉的项目</li>\n</ul>\n<p><strong>不适合场景:</strong></p>\n<ul>\n<li>❌ 简单 bug 修复</li>\n<li>❌ 单行代码修改</li>\n<li>❌ 文档查询</li>\n<li>❌ 快速原型验证</li>\n</ul>\n<p><strong>使用技巧:</strong></p>\n<pre><code class=\"language-bash\"># 启用 Plan 模式\nShift+Tab × 2\n\n# 明确任务需求\n请帮我实现用户认证功能,包括:\n1. 用户注册\n2. 用户登录\n3. JWT token 验证\n4. 密码加密存储\n\n# Claude 会先探索并规划:\n# Plan: 实现用户认证功能\n#\n# 1. 分析现有代码结构\n# 2. 设计认证流程\n# 3. 创建数据模型\n# 4. 实现 API 端点\n# 5. 添加中间件\n# 6. 编写测试\n#\n# 确认后开始执行? (yes/no)\n\n# 确认后开始实施\nyes\n</code></pre>\n<h3 id=\"42-sandbox-模式沙箱模式\">4.2 Sandbox 模式(沙箱模式)</h3>\n<h4 id=\"什么是-sandbox-模式\">什么是 Sandbox 模式?</h4>\n<p><strong>Sandbox 模式</strong>通过定义允许的操作范围,拦截危险操作,提高安全性。</p>\n<p><strong>核心机制:</strong></p>\n<div class=\"mermaid\">graph TB\n    A[操作请求] --&gt; B{Sandbox 规则检查}\n    B --&gt;|允许| C[执行操作]\n    B --&gt;|拒绝| D[拦截并警告]\n    B --&gt;|需要确认| E[询问用户]\n\n    E --&gt;|允许| C\n    E --&gt;|拒绝| D\n\n    style B fill:#667eea\n    style C fill:#4facfe\n    style D fill:#f5576c\n    style E fill:#f093fb\n</div><h4 id=\"配置-sandbox-模式\">配置 Sandbox 模式</h4>\n<p><strong>方式一:通过 /permissions 命令</strong></p>\n<pre><code class=\"language-bash\">claude /permissions\n</code></pre>\n<p><strong>方式二:配置文件</strong></p>\n<p>编辑 <code>~/.claude/settings.json</code>:</p>\n<pre><code class=\"language-json\">{\n  \"permissions\": {\n    \"allow\": {\n      \"bash\": [\n        \"npm install\",\n        \"npm test\",\n        \"npm run build\",\n        \"git *\",\n        \"node -v\",\n        \"npm -v\"\n      ],\n      \"write\": [\n        \"src/**/*\",\n        \"tests/**/*\",\n        \"*.md\"\n      ],\n      \"read\": [\n        \"**/*\"\n      ]\n    },\n    \"deny\": {\n      \"bash\": [\n        \"rm -rf *\",\n        \"format *\",\n        \"shutdown\",\n        \"reboot\"\n      ],\n      \"write\": [\n        \"node_modules/**/*\",\n        \".git/**/*\",\n        \"/etc/*\",\n        \"/usr/*\"\n      ]\n    }\n  }\n}\n</code></pre>\n<h4 id=\"sandbox-最佳实践\">Sandbox 最佳实践</h4>\n<p><strong>最小权限原则:</strong></p>\n<pre><code class=\"language-json\">{\n  \"permissions\": {\n    \"allow\": {\n      \"bash\": [\"npm test\", \"npm run build\"],\n      \"write\": [\"src/**/*\", \"tests/**/*\"]\n    }\n  }\n}\n</code></pre>\n<p><strong>特定项目配置:</strong></p>\n<pre><code class=\"language-json\">// .claude/settings.json (项目级)\n{\n  \"permissions\": {\n    \"allow\": {\n      \"bash\": [\n        \"npm run dev:*\",\n        \"npm run test:*\",\n        \"npm run build:*\"\n      ],\n      \"write\": [\"src/**/*\", \"tests/**/*\", \"docs/**/*\"]\n    },\n    \"deny\": {\n      \"write\": [\"dist/**/*\", \"build/**/*\"]\n    }\n  }\n}\n</code></pre>\n<h3 id=\"43-headless-模式无头模式\">4.3 Headless 模式(无头模式)</h3>\n<h4 id=\"什么是-headless-模式\">什么是 Headless 模式?</h4>\n<p><strong>Headless 模式</strong>是非交互式运行方式,输出结果直接流向标准输出,可集成到 Shell 脚本或 CI/CD 流程中。</p>\n<p><strong>使用场景:</strong></p>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>🔄 <strong>CI/CD 集成</strong></td>\n<td>自动化代码审查</td>\n</tr>\n<tr>\n<td>📜 <strong>脚本自动化</strong></td>\n<td>批量处理任务</td>\n</tr>\n<tr>\n<td>🔍 <strong>快速分析</strong></td>\n<td>不需要交互的代码分析</td>\n</tr>\n<tr>\n<td>📊 <strong>报告生成</strong></td>\n<td>自动生成文档</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"headless-模式使用\">Headless 模式使用</h4>\n<p><strong>基本用法:</strong></p>\n<pre><code class=\"language-bash\"># 从管道输入\ngit diff | claude -p \"解释这些更改\"\n\n# 从文件输入\ncat file.txt | claude -p \"总结这个文件\"\n\n# 直接指定\nclaude -p \"检查代码质量\" &lt; src/main.js\n</code></pre>\n<p><strong>CI/CD 集成示例:</strong></p>\n<pre><code class=\"language-yaml\"># .github/workflows/claude-review.yml\nname: Claude Code Review\n\non:\n  pull_request:\n    types: [opened, synchronize]\n\njobs:\n  review:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '20'\n\n      - name: Install Claude Code\n        run: npm install -g @anthropic-ai/claude-code\n\n      - name: Run Code Review\n        run: |\n          git diff origin/main...HEAD | claude -p \"审查这个 PR 的代码变更\" &gt; review.txt\n\n      - name: Comment PR\n        uses: actions/github-script@v6\n        with:\n          script: |\n            const fs = require('fs');\n            const review = fs.readFileSync('review.txt', 'utf8');\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: review\n            });\n</code></pre>\n<p><strong>脚本自动化示例:</strong></p>\n<pre><code class=\"language-bash\">#!/bin/bash\n# batch-process.sh\n\nfor file in src/**/*.js; do\n  echo \"Processing $file...\"\n\n  # 使用 Claude Code 分析代码\n  claude -p \"检查文件 $file 的代码质量,包括:\n  1. 潜在的 bug\n  2. 性能问题\n  3. 安全漏洞\n  4. 代码规范违规\" &lt; \"$file\" &gt; \"reports/$(basename $file).md\"\n\n  echo \"✓ Completed $file\"\ndone\n\necho \"All files processed!\"\n</code></pre>\n<h3 id=\"44-vim-模式\">4.4 Vim 模式</h3>\n<h4 id=\"启用-vim-模式\">启用 Vim 模式</h4>\n<pre><code class=\"language-bash\">/vim\n</code></pre>\n<h4 id=\"vim-常用快捷键\">Vim 常用快捷键</h4>\n<table>\n<thead>\n<tr>\n<th>快捷键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>h</code></td>\n<td>左移光标</td>\n</tr>\n<tr>\n<td><code>j</code></td>\n<td>下移光标</td>\n</tr>\n<tr>\n<td><code>k</code></td>\n<td>上移光标</td>\n</tr>\n<tr>\n<td><code>l</code></td>\n<td>右移光标</td>\n</tr>\n<tr>\n<td><code>ciw</code></td>\n<td>修改单词</td>\n</tr>\n<tr>\n<td><code>dd</code></td>\n<td>删除行</td>\n</tr>\n<tr>\n<td><code>yy</code></td>\n<td>复制行</td>\n</tr>\n<tr>\n<td><code>p</code></td>\n<td>粘贴</td>\n</tr>\n<tr>\n<td><code>u</code></td>\n<td>撤销</td>\n</tr>\n<tr>\n<td><code>Ctrl+r</code></td>\n<td>重做</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"五实用技巧与快捷操作\">五、实用技巧与快捷操作</h2>\n<p>了解了 Claude Code 的高级功能后，分享一些实用的技巧和快捷操作，可以更高效地使用这个工具。</p>\n<h3 id=\"51-基础操作技巧\">5.1 基础操作技巧</h3>\n<h4 id=\"项目初始化init\">项目初始化(/init)</h4>\n<pre><code class=\"language-bash\"># 自动生成 CLAUDE.md\n/init\n\n# 或手动指定\nclaude /init \"这是一个 Node.js + React 项目\"\n</code></pre>\n<h4 id=\"快速引用上下文提及\">快速引用上下文(@提及)</h4>\n<pre><code class=\"language-bash\"># 引用单个文件\n@src/auth.ts\n\n# 引用整个目录\n@src/components/\n\n# 引用多个文件\n@src/auth.ts @src/user.ts @src/database.ts\n\n# 引用 MCP 服务器\n@mcp:github\n\n# 模糊匹配\n@auth  # 自动匹配 auth.ts, auth.controller.ts 等\n</code></pre>\n<h4 id=\"即时执行-bash-命令前缀\">即时执行 Bash 命令(!前缀)</h4>\n<pre><code class=\"language-bash\"># 查看状态\n!git status\n\n# 运行测试\n!npm test\n\n# 查看进程\n!ps aux | grep node\n\n# 组合使用\n!git diff &amp;&amp; echo \"=== Changes Summary ===\"\n</code></pre>\n<h4 id=\"回退操作双击-esc\">回退操作(双击 ESC)</h4>\n<pre><code class=\"language-bash\">ESC ESC\n</code></pre>\n<p><strong>选项:</strong></p>\n<ul>\n<li>仅回退对话</li>\n<li>仅回退代码</li>\n<li>同时回退对话和代码</li>\n</ul>\n<p><strong>注意:</strong> 已执行的 Bash 命令无法回退</p>\n<h3 id=\"52-效率提升技巧\">5.2 效率提升技巧</h3>\n<h4 id=\"反向搜索历史提示词ctrlr\">反向搜索历史提示词(Ctrl+R)</h4>\n<pre><code class=\"language-bash\">Ctrl+R    # 开始搜索\nCtrl+R    # 循环匹配项\nEnter     # 运行\nTab       # 编辑后运行\n</code></pre>\n<h4 id=\"提示词暂存ctrls\">提示词暂存(Ctrl+S)</h4>\n<pre><code class=\"language-bash\">Ctrl+S    # 暂存当前提示词\n# ... 处理其他事务 ...\n# 恢复暂存内容继续工作\n</code></pre>\n<p><strong>类似 Git stash,但用于提示词</strong></p>\n<h4 id=\"自定义状态栏statusline\">自定义状态栏(/statusline)</h4>\n<pre><code class=\"language-bash\">/statusline\n</code></pre>\n<p><strong>可显示信息:</strong></p>\n<ul>\n<li>Git 分支</li>\n<li>当前模型</li>\n<li>Token 用量</li>\n<li>上下文占比</li>\n<li>任务进度</li>\n</ul>\n<p><strong>配置示例:</strong></p>\n<pre><code class=\"language-json\">{\n  \"statusline\": {\n    \"segments\": [\n      \"git.branch\",\n      \"model.name\",\n      \"context.usage\",\n      \"token.cost\"\n    ],\n    \"refreshInterval\": 1000\n  }\n}\n</code></pre>\n<h4 id=\"可视化上下文context\">可视化上下文(/context)</h4>\n<pre><code class=\"language-bash\">/context\n</code></pre>\n<p><strong>显示:</strong></p>\n<ul>\n<li>当前 token 使用情况</li>\n<li>上下文占用百分比</li>\n<li>各文件占用大小</li>\n<li>建议优化方向</li>\n</ul>\n<h3 id=\"53-文件夹管理技巧\">5.3 文件夹管理技巧</h3>\n<h4 id=\"工作空间隔离\">工作空间隔离</h4>\n<p><strong>最佳实践:</strong></p>\n<pre><code class=\"language-bash\"># 为每个任务创建独立文件夹\nproject-1/\nproject-2/\ntask-a/\ntask-b/\n</code></pre>\n<p><strong>快速启动:</strong></p>\n<pre><code class=\"language-bash\"># Windows: 在地址栏输入 cmd\n# macOS: 在右键菜单选择\"服务 &gt; 新建终端位于文件夹\"\n\n# 然后启动 Claude Code\nclaude\n</code></pre>\n<h4 id=\"拖拽文件\">拖拽文件</h4>\n<p><strong>支持操作:</strong></p>\n<ul>\n<li>拖拽单个文件</li>\n<li>拖拽整个文件夹</li>\n<li>拖拽多个文件</li>\n</ul>\n<p><strong>使用场景:</strong></p>\n<pre><code class=\"language-bash\"># 拖拽文件后直接描述任务\n[拖入 auth.ts]\n这个认证模块有安全问题,请帮我审查并修复\n</code></pre>\n<h3 id=\"54-粘贴技巧\">5.4 粘贴技巧</h3>\n<h4 id=\"文本粘贴\">文本粘贴</h4>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>在 CC 中粘贴文本</strong></td>\n<td>鼠标右键 → 粘贴</td>\n</tr>\n<tr>\n<td><strong>在普通命令行粘贴</strong></td>\n<td>Ctrl+V</td>\n</tr>\n<tr>\n<td><strong>在 CC 中粘贴图片</strong></td>\n<td>复制图片 → Alt+V (Windows) / Ctrl+V (macOS)</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意:</strong></p>\n<ul>\n<li>CC 中不能用 Ctrl+V 粘贴文本</li>\n<li>CC 中不能用 Ctrl+A 全选</li>\n<li>图片必须在打开状态复制,预览状态无法粘贴</li>\n</ul>\n<h3 id=\"55-常用斜杠命令速查\">5.5 常用斜杠命令速查</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n<th>使用频率</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>/clear</code></td>\n<td>清空对话历史</td>\n<td>⭐⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td><code>/compact</code></td>\n<td>清空对话但保留摘要</td>\n<td>⭐⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td><code>/context</code></td>\n<td>可视化上下文使用</td>\n<td>⭐⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td><code>/model</code></td>\n<td>切换模型</td>\n<td>⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td><code>/cost</code></td>\n<td>显示费用统计</td>\n<td>⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td><code>/export</code></td>\n<td>导出对话</td>\n<td>⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td><code>/add-dir</code></td>\n<td>添加工作目录</td>\n<td>⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td><code>/status</code></td>\n<td>查看系统状态</td>\n<td>⭐⭐⭐</td>\n</tr>\n<tr>\n<td><code>/mcp</code></td>\n<td>管理 MCP 服务器</td>\n<td>⭐⭐⭐</td>\n</tr>\n<tr>\n<td><code>/skills</code></td>\n<td>列出可用技能</td>\n<td>⭐⭐⭐</td>\n</tr>\n<tr>\n<td><code>/hooks</code></td>\n<td>管理钩子</td>\n<td>⭐⭐</td>\n</tr>\n<tr>\n<td><code>/agents</code></td>\n<td>管理子代理</td>\n<td>⭐⭐</td>\n</tr>\n<tr>\n<td><code>/vim</code></td>\n<td>切换 Vim 模式</td>\n<td>⭐⭐</td>\n</tr>\n<tr>\n<td><code>/theme</code></td>\n<td>更换主题</td>\n<td>⭐</td>\n</tr>\n<tr>\n<td><code>/doctor</code></td>\n<td>诊断环境</td>\n<td>⭐⭐⭐⭐</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"六最佳实践\">六、最佳实践</h2>\n<p>继续。提供并建立一些最佳实践以提升团队协作和开发效率。</p>\n<h3 id=\"61-项目组织最佳实践\">6.1 项目组织最佳实践</h3>\n<h4 id=\"目录结构规范\">目录结构规范</h4>\n<pre><code class=\"language-bash\">project/\n├── .claude/                    # Claude Code 配置\n│   ├── settings.json           # 项目级设置\n│   ├── agents.json             # 子代理配置\n│   ├── rules/                  # 模块化规则\n│   │   ├── auth.md\n│   │   ├── database.md\n│   │   └── api.md\n│   └── mcp.json                # MCP 配置\n├── src/                        # 源代码\n├── tests/                      # 测试代码\n├── docs/                       # 文档\n├── CLAUDE.md                   # 项目主配置\n└── README.md                   # 项目说明\n</code></pre>\n<h4 id=\"claudemd-层级配置\">CLAUDE.md 层级配置</h4>\n<div class=\"mermaid\">graph TD\n    A[用户级_home_claude_CLAUDE_md]\n    B[项目级_CLAUDE_md]\n    C[模块级_src_claude_CLAUDE_md]\n    D[特定规则_claude_rules]\n\n    A --&gt; E[合并规则]\n    B --&gt; E\n    C --&gt; E\n    D --&gt; E\n    E --&gt; F[最终配置]\n\n    style A fill:#f5576c\n    style B fill:#667eea\n    style C fill:#764ba2\n    style D fill:#f093fb\n    style E fill:#4facfe\n    style F fill:#00d2ff\n</div><h3 id=\"62-工作流最佳实践\">6.2 工作流最佳实践</h3>\n<h4 id=\"探索-规划-编码-提交工作流\">探索-规划-编码-提交工作流</h4>\n<p>这是一个完整的开发工作流程,需要配合特定的Skills和MCP使用。</p>\n<p><strong>前置准备 - 安装必要工具:</strong></p>\n<pre><code class=\"language-bash\"># 1. 安装代码分析MCP(可选,用于深度分析)\nclaude mcp add github npx -y @modelcontextprotocol/server-github\n\n# 2. 安装commit skill(用于生成规范的commit消息)\nnpx skills-installer install @anthropics/claude-code/commit --client claude-code\n\n# 3. 安装Chrome DevTools MCP(用于浏览器测试,可选)\nclaude mcp add chrome-devtools npx chrome-devtools-mcp@latest\n</code></pre>\n<p><strong>详细工作流程:</strong></p>\n<p><strong>第1步:探索阶段 - 理解项目</strong></p>\n<pre><code class=\"language-bash\"># 启动Claude Code\nclaude\n\n# 探索项目架构\n请帮我分析这个项目的架构,重点关注:\n1. 整体项目结构\n2. 认证模块的实现\n3. 依赖关系\n4. 技术栈\n\n# 使用@引用特定目录\n@src/\n\n# 如果有GitHub仓库,使用GitHub MCP\n请使用github MCP查看最近的commit历史和issue\n</code></pre>\n<p><strong>第2步:规划阶段 - 使用Plan模式</strong></p>\n<pre><code class=\"language-bash\"># 进入Plan模式(按两次Shift+Tab)\nShift+Tab, Shift+Tab\n\n# 或使用命令\n/plan\n\n# 明确任务需求\n我需要添加 OAuth2.0 认证支持,请规划实现方案,包括:\n1. 需要创建哪些新文件\n2. 需要修改哪些现有文件\n3. 需要安装哪些依赖\n4. 实现步骤顺序\n5. 潜在的风险点\n\n# Claude会生成详细计划,等待你的确认\n# Plan: 添加OAuth2.0认证支持\n#\n# 1. 分析现有认证代码\n# 2. 设计OAuth2.0流程\n# 3. 创建OAuth控制器\n# 4. 实现token生成和验证\n# 5. 添加测试用例\n# 6. 更新文档\n#\n# 预计需要修改的文件:\n# - src/auth/oauth.controller.ts (新建)\n# - src/auth/auth.service.ts (修改)\n# - src/config/oauth.config.ts (新建)\n#\n# 确认后开始执行? (yes/no)\n\n# 确认后开始实施\nyes\n</code></pre>\n<p><strong>第3步:编码阶段 - 实施计划</strong></p>\n<pre><code class=\"language-bash\"># 让Claude按照计划实施\n按照上面的计划开始实施\n\n# 如果遇到问题,可以要求暂停\n暂停,让我先检查一下这一步\n\n# 继续实施\n继续下一步\n\n# 运行测试\n!npm test\n\n# 修复失败的测试\n测试失败了,请帮我修复\n</code></pre>\n<p><strong>第4步:提交阶段 - 使用commit skill</strong></p>\n<pre><code class=\"language-bash\"># 使用commit skill生成规范的commit消息\n使用commit skill为这些更改创建一个规范的commit消息\n\n# Claude会分析变更并生成commit\n# commit skill会:\n# 1. 分析git diff\n# 2. 生成符合Conventional Commits的消息\n# 3. 自动创建commit\n\n# 或手动指导commit\n请帮我创建git commit,包含这些更改\ncommit消息格式: feat(auth): 添加OAuth2.0认证支持\n</code></pre>\n<h4 id=\"测试驱动开发tdd工作流\">测试驱动开发(TDD)工作流</h4>\n<p><strong>前置准备 - 安装测试相关工具:</strong></p>\n<pre><code class=\"language-bash\"># 1. 安装测试编写skill(可选)\nnpx skills-installer install @anthropics/claude-code/test-writer --client claude-code\n\n# 2. 或者配置test-writer子代理(后面详细说明)\n</code></pre>\n<p><strong>TDD工作流程:</strong></p>\n<pre><code class=\"language-bash\"># 第1步:先写测试\n# 使用test-writer skill或agent\n使用test-writer skill为用户登录功能编写测试,包括:\n1. 正常登录场景\n2. 错误密码场景\n3. 用户不存在场景\n4. Token验证场景\n\n@src/auth/login.controller.ts\n\n# 第2步:运行测试(预期失败)\n!npm test\n\n# 第3步:实现最小可行代码\n测试失败了,请实现登录功能使测试通过,只写能通过的代码\n\n# 第4步:重构代码\n代码通过了但不够优雅,请重构以提高可读性,但保持测试通过\n\n# 第5步:重复循环\n继续添加新功能的测试...\n</code></pre>\n<h4 id=\"代码审查工作流\">代码审查工作流</h4>\n<p><strong>前置准备 - 创建和配置代码审查子代理:</strong></p>\n<p><strong>方式1:使用 /agents 命令创建</strong></p>\n<pre><code class=\"language-bash\"># 在Claude Code中\nclaude\n/agents\n\n# 选择 \"Create new agent\"\n# 按提示配置:\n- Name: code-reviewer\n- Description: 专门负责代码审查的子代理\n- Instructions: 你是一个代码审查专家,专注于检查代码质量、安全漏洞和性能问题\n- Tools: read, search, git\n- Permissions: 禁止写入(allowWrite: false)\n</code></pre>\n<p><strong>方式2:手动配置文件</strong></p>\n<pre><code class=\"language-bash\"># 创建agents配置文件\nmkdir -p ~/.claude\ncat &gt; ~/.claude/agents.json &lt;&lt; 'EOF'\n{\n  \"agents\": {\n    \"code-reviewer\": {\n      \"description\": \"专门负责代码审查的子代理\",\n      \"model\": \"claude-sonnet-4-5\",\n      \"instructions\": \"你是一个专业的代码审查专家。专注于:\\n1. 代码质量(Clean Code原则)\\n2. 安全漏洞(OWASP Top 10)\\n3. 性能问题(算法复杂度、资源使用)\\n4. 最佳实践\\n\\n请以结构化方式输出审查结果。\",\n      \"tools\": [\"read\", \"search\", \"git\"],\n      \"permissions\": {\n        \"allowWrite\": false\n      }\n    },\n    \"security-reviewer\": {\n      \"description\": \"专注于安全问题的子代理\",\n      \"model\": \"claude-sonnet-4-5\",\n      \"instructions\": \"你是一个安全专家,专注于识别:\\n1. SQL注入、XSS、CSRF等漏洞\\n2. 敏感信息泄露\\n3. 权限控制问题\\n4. 依赖安全问题\",\n      \"tools\": [\"read\", \"search\"],\n      \"permissions\": {\n        \"allowWrite\": false\n      }\n    },\n    \"performance-reviewer\": {\n      \"description\": \"专注于性能问题的子代理\",\n      \"model\": \"claude-sonnet-4-5\",\n      \"instructions\": \"你是一个性能优化专家,专注于:\\n1. 算法效率\\n2. 内存使用\\n3. 数据库查询优化\\n4. 缓存策略\",\n      \"tools\": [\"read\", \"search\"],\n      \"permissions\": {\n        \"allowWrite\": false\n      }\n    }\n  }\n}\nEOF\n\n# 验证配置\nclaude\n/agents\n# 应该看到刚创建的三个agent\n</code></pre>\n<p><strong>使用代码审查工作流:</strong></p>\n<pre><code class=\"language-bash\"># 第1步:使用子代理并行审查\n# 代码质量审查\n使用code-reviewer agent审查以下文件的代码质量:\n- 是否符合Clean Code原则\n- 是否有代码异味\n- 是否易于维护\n\n@src/auth.ts @src/user.ts @src/database.ts\n\n# 安全审查(并行)\n使用security-reviewer agent审查这些文件的安全问题:\n- SQL注入风险\n- XSS漏洞\n- 敏感信息泄露\n\n@src/auth.ts @src/user.ts @src/database.ts\n\n# 性能审查(并行)\n使用performance-reviewer agent审查这些文件的性能问题:\n- 算法复杂度\n- 数据库查询效率\n- 内存使用\n\n@src/auth.ts @src/user.ts @src/database.ts\n\n# 第2步:生成综合审查报告\n请综合以上三个agent的审查结果,生成一份详细报告,包括:\n- 发现的问题列表\n- 每个问题的严重程度(Critical/High/Medium/Low)\n- 具体的修复建议\n- 修复优先级排序\n\n# 第3步:逐个修复问题\n根据审查报告,请帮我修复Critical和High级别的问题:\n1. 先修复安全问题\n2. 再修复性能问题\n3. 最后修复代码质量问题\n\n# 第4步:重新审查\n修复完成后,使用code-reviewer agent重新审查修复后的代码\n</code></pre>\n<h3 id=\"63-团队协作最佳实践\">6.3 团队协作最佳实践</h3>\n<h4 id=\"共享-claudemd\">共享 CLAUDE.md</h4>\n<p><strong>场景:</strong>团队项目</p>\n<p><strong>实施步骤:</strong></p>\n<ol>\n<li>在项目根目录创建 CLAUDE.md</li>\n<li>团队共同维护</li>\n<li>定期更新</li>\n<li>版本控制</li>\n</ol>\n<p><strong>示例:</strong></p>\n<pre><code class=\"language-markdown\"># 团队项目规范\n\n## 团队约定\n- 代码审查至少 1 人 approve\n- 所有 PR 必须通过 CI\n- 文档与代码同步更新\n\n## 分工信息\n- @alice: 前端负责人\n- @bob: 后端负责人\n- @charlie: DevOps\n\n## 沟通渠道\n- Slack: #team-channel\n- JIRA: 项目看板\n</code></pre>\n<h4 id=\"github-集成\">GitHub 集成</h4>\n<p><strong>安装 GitHub App:</strong></p>\n<pre><code class=\"language-bash\">/install-github-app\n</code></pre>\n<p><strong>使用 PR 评论:</strong></p>\n<pre><code class=\"language-bash\"># 在 PR 中\n@.claude 请审查这个 PR 的代码变更\n\n# 自动添加问题到 CLAUDE.md\n/pr-comments\n</code></pre>\n<h3 id=\"64-性能优化最佳实践\">6.4 性能优化最佳实践</h3>\n<h4 id=\"上下文管理\">上下文管理</h4>\n<p><strong>策略:</strong></p>\n<pre><code class=\"language-bash\"># 长对话定期 compact\n/compact \"保留以下要点: ...\"\n\n# 新任务先 clear\n/clear\n\n# 监控上下文使用\n/context\n\n# 定期 export 备份\n/export conversation-2026-01-06.json\n</code></pre>\n<h4 id=\"token-优化\">Token 优化</h4>\n<table>\n<thead>\n<tr>\n<th>技巧</th>\n<th>说明</th>\n<th>节省效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>使用 @提及</strong></td>\n<td>只加载需要的文件</td>\n<td>30-50%</td>\n</tr>\n<tr>\n<td><strong>定期 /compact</strong></td>\n<td>清理历史保留摘要</td>\n<td>40-60%</td>\n</tr>\n<tr>\n<td><strong>避免重复加载</strong></td>\n<td>检查 /context 输出</td>\n<td>20-30%</td>\n</tr>\n<tr>\n<td><strong>使用 Subagents</strong></td>\n<td>并行处理减少串行上下文</td>\n<td>50-70%</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"模型选择策略\">模型选择策略</h4>\n<p><strong>国外模型选择策略:</strong></p>\n<div class=\"mermaid\">graph LR\n    A[简单任务] --&gt; B[Haiku 4.5]\n    C[中等复杂度] --&gt; D[Sonnet 4.5]\n    E[高复杂度] --&gt; F[Opus 4.5]\n\n    B --&gt; G[成本优化]\n    D --&gt; H[平衡性能]\n    F --&gt; I[质量优先]\n\n    style A fill:#4facfe\n    style C fill:#667eea\n    style E fill:#f5576c\n    style B fill:#4facfe\n    style D fill:#667eea\n    style F fill:#f5576c\n</div><p><strong>国外模型使用建议:</strong></p>\n<ul>\n<li><strong>快速查询/格式化:</strong> Haiku 4.5 - 最快最便宜</li>\n<li><strong>日常开发/代码编写:</strong> Sonnet 4.5 - 性价比平衡</li>\n<li><strong>架构设计/复杂重构:</strong> Opus 4.5 - 最高质量</li>\n</ul>\n<p><strong>国内模型选择策略:</strong></p>\n<div class=\"mermaid\">graph LR\n    A[简单任务] --&gt; B[DeepSeek-Coder]\n    C[中文项目] --&gt; D[GLM-4.7]\n    E[大型项目] --&gt; F[Kimi K2]\n    G[Python/JS] --&gt; H[Qwen-Coder-Plus]\n\n    B --&gt; I[极低成本]\n    D --&gt; J[中文优化]\n    F --&gt; K[超长上下文]\n    H --&gt; L[开源优秀]\n\n    style A fill:#00d2ff\n    style C fill:#667eea\n    style E fill:#f093fb\n    style G fill:#4facfe\n    style B fill:#00d2ff\n    style D fill:#667eea\n    style F fill:#f093fb\n    style H fill:#4facfe\n</div><p><strong>国内模型使用建议:</strong></p>\n<table>\n<thead>\n<tr>\n<th>任务类型</th>\n<th>推荐模型</th>\n<th>理由</th>\n<th>价格(相对)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>简单查询</strong></td>\n<td>DeepSeek-Coder</td>\n<td>极低成本,够用</td>\n<td>⭐</td>\n</tr>\n<tr>\n<td><strong>中文项目</strong></td>\n<td>GLM-4.7</td>\n<td>中文理解最强,有Coding套餐</td>\n<td>⭐⭐⭐</td>\n</tr>\n<tr>\n<td><strong>大型重构</strong></td>\n<td>Kimi K2</td>\n<td>超长上下文(2M+),MoE架构</td>\n<td>⭐⭐</td>\n</tr>\n<tr>\n<td><strong>Python/JS</strong></td>\n<td>Qwen-Coder-Plus</td>\n<td>开源,Python/JS性能优秀</td>\n<td>⭐⭐</td>\n</tr>\n<tr>\n<td><strong>预算有限</strong></td>\n<td>DeepSeek-Coder</td>\n<td>价格优势明显</td>\n<td>⭐</td>\n</tr>\n<tr>\n<td><strong>团队协作</strong></td>\n<td>GLM-4.7</td>\n<td>有团队套餐,管理方便</td>\n<td>⭐⭐⭐</td>\n</tr>\n</tbody>\n</table>\n<p><strong>模型切换策略:</strong></p>\n<pre><code class=\"language-bash\"># 方式1:使用 /model 命令快速切换\nclaude\n/model\n# 选择对应模型\n\n# 方式2:临时切换(当前会话)\nexport ANTHROPIC_MODEL=kimi-k2\nclaude\n\n# 方式3:针对不同任务使用不同配置\n# 创建alias\nalias cc-glm='ANTHROPIC_MODEL=GLM-4.7 claude'\nalias cc-kimi='ANTHROPIC_MODEL=kimi-k2 claude'\nalias cc-qwen='ANTHROPIC_MODEL=qwen-coder-plus claude'\n\n# 使用\ncc-glm   # 使用智谱GLM\ncc-kimi  # 使用Kimi\ncc-qwen  # 使用通义千问\n</code></pre>\n<p><strong>成本优化建议:</strong></p>\n<div class=\"mermaid\">graph TB\n    A[任务开始] --&gt; B{任务类型?}\n    B --&gt;|简单查询| C[DeepSeek-Coder]\n    B --&gt;|中文开发| D[GLM-4.7]\n    B --&gt;|大型重构| E[Kimi K2]\n    B --&gt;|Python项目| F[Qwen-Coder-Plus]\n    B --&gt;|高质量要求| G[Sonnet 4.5]\n\n    C --&gt; H[成本: $]\n    D --&gt; I[成本: $$]\n    E --&gt; J[成本: $$]\n    F --&gt; K[成本: $$]\n    G --&gt; L[成本: $$$$]\n\n    style A fill:#667eea\n    style C fill:#00d2ff\n    style D fill:#f093fb\n    style E fill:#f5576c\n    style F fill:#4facfe\n    style G fill:#764ba2\n</div><p><strong>混合使用策略:</strong></p>\n<pre><code class=\"language-bash\"># 日常开发用国产模型(便宜)\nexport ANTHROPIC_MODEL=GLM-4.7\n\n# 遇到复杂任务时临时切换到高质量模型\n/model\n# 选择 Opus 4.5\n\n# 完成后切换回国产模型\n/model\n# 选择 GLM-4.7\n</code></pre>\n<h3 id=\"65-安全最佳实践\">6.5 安全最佳实践</h3>\n<h4 id=\"sandbox-配置\">Sandbox 配置</h4>\n<pre><code class=\"language-json\">{\n  \"permissions\": {\n    \"allow\": {\n      \"bash\": [\"npm run *\", \"git *\"],\n      \"write\": [\"src/**/*\", \"tests/**/*\"],\n      \"read\": [\"**/*.ts\", \"**/*.js\", \"**/*.json\"]\n    },\n    \"deny\": {\n      \"bash\": [\"rm -rf *\", \"format *\", \"shutdown\"],\n      \"write\": [\"node_modules/**/*\", \".git/**/*\", \"/etc/*\", \"/usr/*\"]\n    }\n  }\n}\n</code></pre>\n<h4 id=\"hooks-安全检查\">Hooks 安全检查</h4>\n<pre><code class=\"language-bash\">#!/bin/bash\n# ~/.claude/hooks/security-check.sh\n\n# 检查敏感操作\nif [[ \"$TOOL_NAME\" == \"Bash\" ]]; then\n  COMMAND=$(jq -r '.command' &lt;&lt;&lt; \"$CLAUDE_HOOK_INPUT\")\n\n  # 危险命令黑名单\n  DANGEROUS_CMDS=(\"rm -rf\" \"format\" \"shutdown\" \"reboot\" \"chmod 000\")\n\n  for cmd in \"${DANGEROUS_CMDS[@]}\"; do\n    if [[ \"$COMMAND\" == *\"$cmd\"* ]]; then\n      echo \"🚫 拦截危险命令: $COMMAND\"\n      exit 1\n    fi\n  done\nfi\n</code></pre>\n<h4 id=\"敏感信息保护\">敏感信息保护</h4>\n<pre><code class=\"language-markdown\"># CLAUDE.md 安全规范\n\n## 禁止事项\n- ❌ 在代码中硬编码密钥\n- ❌ 在 CLAUDE.md 中记录密码\n- ❌ 在 Git 提交中包含凭证\n\n## 推荐做法\n- ✅ 使用环境变量\n- ✅ 使用 .env 文件(不提交)\n- ✅ 使用密钥管理服务(AWS Secrets Manager 等)\n- ✅ .gitignore 排除敏感文件\n</code></pre>\n<hr />\n<h2 id=\"七实战案例\">七、实战案例</h2>\n<p>简单几个案例看看如何运用到实际工作中。</p>\n<h3 id=\"71-案例1批量文件重命名\">7.1 案例1:批量文件重命名</h3>\n<p><strong>需求:</strong>将文件夹中所有文件名改为规范的英文名称</p>\n<p><strong>实现:</strong></p>\n<pre><code class=\"language-bash\"># 拖拽文件夹到 Claude Code\n\n请将文件夹中的所有文件名改成规范的英文名称,只改名字,不改序号\n\n# Claude Code 自动:\n# 1. 读取文件夹内容\n# 2. 分析文件名\n# 3. 批量重命名\n# 4. 报告结果\n</code></pre>\n<h3 id=\"72-案例2自动化数据抓取\">7.2 案例2:自动化数据抓取</h3>\n<p><strong>需求:</strong>抓取公众号多页文章数据并导出 Excel</p>\n<p><strong>实现:</strong></p>\n<pre><code class=\"language-bash\"># 使用 Chrome DevTools MCP\n\n用Chrome浏览器打开这个链接:[公众号链接]\n\n然后通过 chrome devtools mcp 完成:\n1. 获取第1、2、3页每篇文章的详细数据\n2. 包括标题、阅读量、点赞量、发布时间等\n3. 保存到 Excel 表格中\n\n# Claude Code 自动:\n# 1. 启动 Chrome\n# 2. 导航到页面\n# 3. 翻页抓取数据\n# 4. 生成 Excel 报告\n</code></pre>\n<p><strong>效果对比:</strong></p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>耗时</th>\n<th>准确率</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>人工</strong></td>\n<td>30分钟</td>\n<td>90%</td>\n</tr>\n<tr>\n<td><strong>Claude Code + MCP</strong></td>\n<td>5分钟</td>\n<td>99%</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"73-案例3代码质量审查\">7.3 案例3:代码质量审查</h3>\n<p><strong>需求:</strong>审查 PR 的代码变更</p>\n<p><strong>实现:</strong></p>\n<pre><code class=\"language-bash\"># 使用 code-reviewer subagent\n\n使用 code-reviewer agent 审查这个 PR:\n- 代码质量\n- 安全漏洞\n- 性能问题\n- 最佳实践\n\n@src/ @tests/\n\n# Claude Code 自动:\n# 1. 读取所有相关文件\n# 2. 应用审查标准\n# 3. 生成详细报告\n# 4. 提供修复建议\n</code></pre>\n<h3 id=\"74-案例4自动化测试生成\">7.4 案例4:自动化测试生成</h3>\n<p><strong>需求:</strong>为新功能编写测试</p>\n<p><strong>实现:</strong></p>\n<pre><code class=\"language-bash\"># 使用 test-writer subagent\n\n使用 test-writer agent 为用户认证功能编写测试:\n- 单元测试\n- 集成测试\n- E2E 测试\n- 边界情况测试\n\n@src/auth.ts @src/auth.controller.ts\n\n# Claude Code 自动:\n# 1. 分析代码逻辑\n# 2. 识别测试场景\n# 3. 编写测试用例\n# 4. 运行测试验证\n</code></pre>\n<h3 id=\"75-案例5cicd-集成\">7.5 案例5:CI/CD 集成</h3>\n<p><strong>需求:</strong>在 PR 创建时自动审查代码</p>\n<p><strong>实现:</strong></p>\n<pre><code class=\"language-yaml\"># .github/workflows/claude-review.yml\n\nname: Claude Auto Review\n\non:\n  pull_request:\n    types: [opened, synchronize]\n\njobs:\n  review:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install Claude Code\n        run: npm install -g @anthropic-ai/claude-code\n\n      - name: Configure Claude\n        run: |\n          echo \"配置模型...\"\n          export ANTHROPIC_MODEL=\"claude-sonnet-4-5\"\n\n      - name: Run Review\n        run: |\n          git diff origin/main...HEAD &gt; diff.txt\n          claude -p \"审查这个 PR 的代码变更,重点关注:\n          1. 安全漏洞\n          2. 性能问题\n          3. 代码规范\n          请提供详细审查意见\" &lt; diff.txt &gt; review.txt\n\n      - name: Comment on PR\n        uses: actions/github-script@v6\n        with:\n          script: |\n            const fs = require('fs');\n            const review = fs.readFileSync('review.txt', 'utf8');\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: `## 🤖 Claude Code 自动审查\\n\\n${review}`\n            });\n</code></pre>\n<hr />\n<h2 id=\"八常见问题与解决方案\">八、常见问题与解决方案</h2>\n<p>在使用 Claude Code 的过程中,你可能会遇到一些常见问题。本章节收集了最常见的问题及其解决方案,帮助你快速排除故障。</p>\n<h3 id=\"81-安装问题\">8.1 安装问题</h3>\n<h4 id=\"q1-npm-install-失败\">Q1: npm install 失败</h4>\n<p><strong>问题:</strong></p>\n<pre><code class=\"language-bash\">npm ERR! code EACCES\nnpm ERR! syscall access\n</code></pre>\n<p><strong>解决方案:</strong></p>\n<pre><code class=\"language-bash\"># 方式1: 使用 sudo (macOS/Linux)\nsudo npm install -g @anthropic-ai/claude-code\n\n# 方式2: 修改 npm 全局目录\nmkdir ~/.npm-global\nnpm config set prefix '~/.npm-global'\nexport PATH=~/.npm-global/bin:$PATH\nnpm install -g @anthropic-ai/claude-code\n\n# 方式3: 使用 nvm (推荐)\nnvm install --lts\nnpm install -g @anthropic-ai/claude-code\n</code></pre>\n<h4 id=\"q2-claude-命令未找到\">Q2: claude 命令未找到</h4>\n<p><strong>问题:</strong></p>\n<pre><code class=\"language-bash\">bash: claude: command not found\n</code></pre>\n<p><strong>解决方案:</strong></p>\n<pre><code class=\"language-bash\"># 检查 npm 全局路径\nnpm config get prefix\n\n# 添加到 PATH\nexport PATH=$(npm config get prefix)/bin:$PATH\n\n# 永久配置\necho 'export PATH=$(npm config get prefix)/bin:$PATH' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre>\n<h3 id=\"82-配置问题\">8.2 配置问题</h3>\n<h4 id=\"q3-模型配置不生效\">Q3: 模型配置不生效</h4>\n<p><strong>问题:</strong>配置后仍显示默认模型</p>\n<p><strong>解决方案:</strong></p>\n<pre><code class=\"language-bash\"># 1. 验证环境变量\necho $ANTHROPIC_BASE_URL\necho $ANTHROPIC_AUTH_TOKEN\necho $ANTHROPIC_MODEL\n\n# 2. 重新启动终端\n# 配置环境变量后必须重启终端才能生效\n\n# 3. 使用 claude /status 检查\nclaude\n/status\n\n# 4. 手动设置(临时)\nclaude\n/model\n# 选择第4个(自定义模型)\n</code></pre>\n<h4 id=\"q4-mcp-服务器无法连接\">Q4: MCP 服务器无法连接</h4>\n<p><strong>问题:</strong></p>\n<pre><code class=\"language-bash\">Error: MCP server 'chrome-devtools' failed to start\n</code></pre>\n<p><strong>解决方案:</strong></p>\n<pre><code class=\"language-bash\"># 1. 检查 MCP 状态\nclaude\n/mcp\n\n# 2. 测试连接\nclaude mcp test chrome-devtools\n\n# 3. 重新安装\nclaude mcp remove chrome-devtools\nclaude mcp add chrome-devtools npx chrome-devtools-mcp@latest\n\n# 4. 检查网络\nnpx chrome-devtools-mcp@latest --version\n\n# 5. 查看日志\nclaude /doctor\n</code></pre>\n<h3 id=\"83-使用问题\">8.3 使用问题</h3>\n<h4 id=\"q5-上下文超出限制\">Q5: 上下文超出限制</h4>\n<p><strong>问题:</strong></p>\n<pre><code>Context exceeded: Request too large\n</code></pre>\n<p><strong>解决方案:</strong></p>\n<pre><code class=\"language-bash\"># 1. 查看上下文使用\n/context\n\n# 2. 使用 compact 保留摘要\n/compact \"保留项目背景和当前任务\"\n\n# 3. 使用 clear 清空历史\n/clear\n\n# 4. 减少文件引用\n# 不要用 @src/ 引用整个目录\n# 改用 @src/file1.ts @src/file2.ts 精确引用\n\n# 5. 使用 Subagents 分担上下文\n# 将大任务拆分给多个子代理\n</code></pre>\n<h4 id=\"q6-代码生成质量差\">Q6: 代码生成质量差</h4>\n<p><strong>问题:</strong>生成的代码不符合项目规范</p>\n<p><strong>解决方案:</strong></p>\n<pre><code class=\"language-bash\"># 1. 完善 CLAUDE.md\n# 在 CLAUDE.md 中明确代码规范\n\n# 2. 使用 Plan 模式\nShift+Tab × 2\n# 让 Claude 先理解项目再编写代码\n\n# 3. 提供示例\n# 这是符合规范的代码示例:\n@src/good-example.ts\n# 请参照这个风格编写新功能\n\n# 4. 明确要求\n请编写符合以下规范的代码:\n- 使用 TypeScript 严格模式\n- 遵循项目命名规范\n- 包含完整的错误处理\n- 添加必要的注释\n</code></pre>\n<h3 id=\"84-性能问题\">8.4 性能问题</h3>\n<h4 id=\"q7-响应速度慢\">Q7: 响应速度慢</h4>\n<p><strong>问题:</strong>Claude Code 响应延迟高</p>\n<p><strong>解决方案:</strong></p>\n<pre><code class=\"language-bash\"># 1. 检查网络\nping api.anthropic.com\n\n# 2. 切换更快的模型\n/model\n# 选择 Haiku 4.5(最快) 或国产模型\n\n# 3. 优化提示词\n# 避免冗长的提示词,直接说明需求\n\n# 4. 减少上下文\n/context\n# 如果接近 100%,使用 /compact 清理\n\n# 5. 使用本地模型(如果有)\nexport ANTHROPIC_BASE_URL=http://localhost:8000\n</code></pre>\n<h4 id=\"q8-token-消耗过快\">Q8: Token 消耗过快</h4>\n<p><strong>问题:</strong>费用增长过快</p>\n<p><strong>解决方案:</strong></p>\n<pre><code class=\"language-bash\"># 1. 监控费用\n/cost\n\n# 2. 定期 compact\n/compact \"保留关键信息\"\n\n# 3. 新任务先 clear\n/clear\n\n# 4. 使用更便宜的模型\n# Haiku &lt; Sonnet &lt; Opus\n# 国产模型(更便宜)\n\n# 5. 优化工作流\n# 避免反复修改,一次性明确需求\n</code></pre>\n<h3 id=\"85-调试技巧\">8.5 调试技巧</h3>\n<h4 id=\"启用调试模式\">启用调试模式</h4>\n<pre><code class=\"language-bash\"># 设置环境变量\nexport CLAUDE_DEBUG=true\nexport CLAUDE_LOG_LEVEL=debug\n\n# 启动 Claude Code\nclaude\n\n# 查看日志\ntail -f ~/.claude/logs/claude.log\n</code></pre>\n<h4 id=\"使用-doctor-诊断\">使用 /doctor 诊断</h4>\n<pre><code class=\"language-bash\">claude\n/doctor\n</code></pre>\n<p><strong>检查项:</strong></p>\n<ul>\n<li>✅ 安装版本</li>\n<li>✅ 配置文件</li>\n<li>✅ API 连接</li>\n<li>✅ MCP 服务器</li>\n<li>✅ 权限设置</li>\n<li>✅ 环境变量</li>\n</ul>\n<hr />\n<h2 id=\"附录\">附录</h2>\n<h3 id=\"a-快速参考卡\">A. 快速参考卡</h3>\n<h4 id=\"核心命令速查\">核心命令速查</h4>\n<pre><code class=\"language-bash\"># 基础操作\nclaude                    # 启动 Claude Code\nclaude -p \"prompt\"        # Headless 模式\nclaude --version          # 查看版本\n\n# 斜杠命令\n/clear                    # 清空对话\n/compact                  # 压缩对话\n/context                  # 查看上下文\n/cost                     # 查看费用\n/model                    # 切换模型\n/mcp                      # 管理 MCP\n/skills                   # 查看 Skills\n/hooks                    # 管理 Hooks\n/agents                   # 管理子代理\n/status                   # 系统状态\n/doctor                   # 诊断环境\n\n# 快捷键\nCtrl+R                    # 搜索历史\nCtrl+S                    # 暂存提示词\nCtrl+C                    # 中止操作\nShift+Tab × 2             # Plan 模式\nESC ESC                   # 回退操作\nAlt+V                     # 粘贴图片\n\n# 文件操作\n@file.ts                  # 引用文件\n@src/                     # 引用目录\n!command                  # 执行 Bash\n</code></pre>\n<h3 id=\"b-配置文件清单\">B. 配置文件清单</h3>\n<table>\n<thead>\n<tr>\n<th>配置文件</th>\n<th>位置</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>CLAUDE.md</strong></td>\n<td>项目根目录</td>\n<td>项目配置</td>\n</tr>\n<tr>\n<td><strong>settings.json</strong></td>\n<td>~/.claude/ 或项目/.claude/</td>\n<td>全局/项目设置</td>\n</tr>\n<tr>\n<td><strong>agents.json</strong></td>\n<td>~/.claude/ 或项目/.claude/</td>\n<td>子代理配置</td>\n</tr>\n<tr>\n<td><strong>mcp.json</strong></td>\n<td>~/.claude/</td>\n<td>MCP 服务器配置</td>\n</tr>\n<tr>\n<td><strong>hooks/</strong></td>\n<td>~/.claude/hooks/</td>\n<td>Hook 脚本</td>\n</tr>\n<tr>\n<td><strong>skills/</strong></td>\n<td>~/.claude/skills/</td>\n<td>自定义 Skills</td>\n</tr>\n<tr>\n<td><strong>rules/</strong></td>\n<td>项目/.claude/rules/</td>\n<td>模块化规则</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"c-推荐资源\">C. 推荐资源</h3>\n<h4 id=\"官方资源\">官方资源</h4>\n<ul>\n<li><strong>Claude Code 官网:</strong> <a href=\"https://code.claude.com\" rel=\"noopener nofollow\" target=\"_blank\">https://code.claude.com</a></li>\n<li><strong>文档:</strong> <a href=\"https://code.claude.com/docs\" rel=\"noopener nofollow\" target=\"_blank\">https://code.claude.com/docs</a></li>\n<li><strong>GitHub:</strong> <a href=\"https://github.com/anthropics/claude-code\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/claude-code</a></li>\n<li><strong>Skills 库:</strong> <a href=\"https://github.com/anthropics/skills\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/skills</a></li>\n<li><strong>MCP 服务器:</strong> <a href=\"https://github.com/modelcontextprotocol\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/modelcontextprotocol</a></li>\n</ul>\n<hr />\n<h2 id=\"总结\">总结</h2>\n<p>Claude Code 真的很强，是一个强大的系统级 AI Agent，用好这个工具能为自己提高很多工作效率。</p>\n<h3 id=\"核心能力清单\">核心能力清单</h3>\n<ul>\n<li>✅ <strong>Skills:</strong> 预封装的工作流,快速复用专业能力</li>\n<li>✅ <strong>Hooks:</strong> 事件驱动的自动化,打造个性化工作流</li>\n<li>✅ <strong>Plugins:</strong> 完整解决方案,一键安装多功能套件</li>\n<li>✅ <strong>MCP Servers:</strong> 外部服务集成,无限扩展能力边界</li>\n<li>✅ <strong>Subagents:</strong> 并行处理复杂任务,提升团队协作效率</li>\n<li>✅ <strong>CLAUDE.md:</strong> 项目记忆系统,让 AI 理解你的项目</li>\n<li>✅ <strong>Plan 模式:</strong> 先规划后执行,减少返工提高质量</li>\n<li>✅ <strong>Sandbox 模式:</strong> 安全防护机制,保护你的工作环境</li>\n<li>✅ <strong>Headless 模式:</strong> CI/CD 集成,实现自动化工作流</li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/knqiufan/\" target=\"_blank\">knqiufan</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/knqiufan/p/19449849\" target=\"_blank\">https://www.cnblogs.com/knqiufan/p/19449849</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 00:55</span>&nbsp;\n<a href=\"https://www.cnblogs.com/knqiufan\">knqiufan</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "数据可视化五大黄金原则：让你的图表“会说话”",
      "link": "https://www.cnblogs.com/wang_yb/p/19449591",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19449591\" id=\"cb_post_title_url\" title=\"发布于 2026-01-06 22:29\">\n    <span>数据可视化五大黄金原则：让你的图表“会说话”</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在日常工作中，你是否遇到过这种情况：你辛辛苦苦跑完数据，画了一张图表发给老板或客户，结果对方盯着看了半天，问了一句：“<strong>所以，你想表达什么？</strong>”</p>\n<p>这就像讲笑话没人笑一样尴尬。图表的本质不是 <strong>“画图”</strong>，而是 <strong>“沟通”</strong>。</p>\n<p>今天，我将分享 5 个提升可视化效果的原则，并用 <code>Python</code> 的 <code>matplotlib</code> 库手把手教你如何实现。</p>\n<h1 id=\"1-原则1展示数据而非装饰\">1. 原则1：展示数据，而非装饰</h1>\n<p>想象一下，你在阅读一本小说，但每页都充满了无关的插图，你会感到困惑和分心。</p>\n<p><strong>数据可视化</strong>也是如此——读者需要的是数据本身，而不是华丽的装饰。</p>\n<p>所以，我们需要展示<strong>最重要</strong>的数据，而不是<strong>尽可能多</strong>的数据。</p>\n<p>让我们看看一个常见的错误做法和改进后的做法：</p>\n<pre><code class=\"language-python\"># 创建示例数据\nnp.random.seed(42)\ncategories = [\"产品A\", \"产品B\", \"产品C\", \"产品D\", \"产品E\"]\nsales_bad = np.random.randint(50, 200, 5)\nsales_good = np.random.randint(50, 200, 5)\n\n# 错误做法：过度装饰，数据不突出\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))\n\n# 左侧：过度装饰的图表\nax1.bar(categories, sales_bad, color=[\"red\", \"blue\", \"green\", \"orange\", \"purple\"])\n\n# 添加不必要的元素\n# ...\n\n# 右侧：简洁聚焦的图表\nax2.bar(categories, sales_good, color=\"steelblue\", alpha=0.8)\n# 在柱子上直接标注数值\nfor i, v in enumerate(sales_good):\n    ax2.text(i, v + 5, str(v), ha=\"center\", fontweight=\"bold\")\n\n# 突出最高值\n# ...\n# 移除不必要的边框\n# ...\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260106222835311-981055803.png\" /></p>\n<p>在这个示例中，根据原则1，我们<strong>主要改进</strong>了：</p>\n<ul>\n<li>移除背景水印和过度装饰</li>\n<li>直接在柱状图上标注数值，避免视线来回移动</li>\n<li>突出显示最重要的数据点（产品C）</li>\n<li>简化标题，直接传达核心信息</li>\n</ul>\n<h1 id=\"2-原则2减少混乱保持简洁\">2. 原则2：减少混乱，保持简洁</h1>\n<p>想象一下一个杂乱无章的房间，你想找一本书，却要翻遍各个角落。</p>\n<p>混乱的图表也会让读者经历同样的挫折。</p>\n<p>所以，每个额外的视觉元素都应该有明确的目的，否则就应该移除。</p>\n<pre><code class=\"language-python\"># 创建示例数据\nnp.random.seed(123)\nmonths = [\n    \"1月\",\n    #...\n    \"12月\",\n]\ntemperature = np.random.normal(20, 5, 12) + np.sin(np.linspace(0, 2 * np.pi, 12)) * 3\nprecipitation = (\n    np.random.normal(50, 15, 12) + np.cos(np.linspace(0, 2 * np.pi, 12)) * 20\n)\n\n# 左侧：混乱的图表\nax1.plot(months, temperature, \"ro-\", linewidth=2, markersize=8, label=\"温度\")\n# ...\n\n# 创建第二个y轴（混乱的常见来源）\nax1b = ax1.twinx()\nax1b.plot(months, precipitation, \"bs--\", linewidth=2, markersize=8, label=\"降水量\")\n# ...\n\n# 添加网格和过多标签\n# ...\n\n# 右侧：简洁的图表\n# 分开显示两个指标\nax2a = plt.subplot(grid[0, 1])\nax2b = plt.subplot(grid[1, 1])\n\n# 温度图表\nax2a.plot(months, temperature, color=\"#E74C3C\", linewidth=2.5)\nax2a.fill_between(months, temperature.min(), temperature, color=\"#E74C3C\", alpha=0.1)\n\n# 突出显示最高温度\nmax_temp_idx = np.argmax(temperature)\nax2a.plot(\n    months[max_temp_idx], temperature[max_temp_idx], \"o\", color=\"#E74C3C\", markersize=10\n)\n# ...\n\n# 降水量图表\nax2b.bar(months, precipitation, color=\"#3498DB\", alpha=0.7)\n# 突出显示最高降水量\nmax_precip_idx = np.argmax(precipitation)\n# ...\n\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260106222835292-272601904.png\" /></p>\n<p>在这个示例中，根据原则2，我们<strong>主要改进</strong>了：</p>\n<ul>\n<li>将双Y轴图表拆分为两个独立的图表</li>\n<li>移除过多的图例和网格线</li>\n<li>使用填充和标记突出关键数据点</li>\n<li>简化标题，每个图表只表达一个核心信息</li>\n</ul>\n<h1 id=\"3-原则3图文结合引导读者\">3. 原则3：图文结合，引导读者</h1>\n<p>好的可视化图表就像一个会讲故事的导游，而文字就是它的讲解词。</p>\n<p>文字应该帮助读者理解数据，而不是制造障碍。</p>\n<pre><code class=\"language-python\"># 创建示例数据\nnp.random.seed(42)\nyears = np.arange(2010, 2023)\ncompany_a = np.random.normal(100, 10, 13) + np.linspace(0, 50, 13)\ncompany_b = np.random.normal(100, 10, 13) + np.linspace(0, 30, 13)\n\n# 左侧：缺乏引导的图表\nax1.plot(years, company_a, \"b-\", linewidth=2, label=\"公司A\")\nax1.plot(years, company_b, \"r-\", linewidth=2, label=\"公司B\")\n\n# 右侧：图文结合的图表\nax2.plot(years, company_a, color=\"#2E86C1\", linewidth=3, alpha=0.8)\nax2.plot(years, company_b, color=\"#E74C3C\", linewidth=3, alpha=0.8)\n\n# 直接标注线条，避免图例\nax2.text(\n    2022.2, company_a[-1], \"公司A\", color=\"#2E86C1\", fontweight=\"bold\", va=\"center\"\n)\nax2.text(\n    2022.2, company_b[-1], \"公司B\", color=\"#E74C3C\", fontweight=\"bold\", va=\"center\"\n)\n\n# 添加标题和副标题\n# ...\n\n# 添加关键事件注释\n# ...\n\n# 突出关键数据点\n# ...\n\n# 简洁的坐标轴\n# ...\n\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260106222835329-396667946.png\" /></p>\n<p>在这个示例中，根据原则3，我们<strong>主要改进</strong>了：</p>\n<ul>\n<li>直接在线条旁标注，消除图例</li>\n<li>使用标题直接传达核心发现</li>\n<li>添加注释解释关键事件</li>\n<li>使用填充区域突出重要差异</li>\n</ul>\n<h1 id=\"4-原则4避免意面图分解复杂信息\">4. 原则4：避免意面图，分解复杂信息</h1>\n<p>\"意面图\"是指线条交错、难以分辨的图表，就像一碗缠在一起的意大利面。</p>\n<p>当图表变得过于复杂时，最好的方法是分解它。</p>\n<pre><code class=\"language-python\"># 创建示例数据：多个产品多年的销售数据\nnp.random.seed(123)\nyears = np.arange(2015, 2024)\nproducts = ['手机', '平板', '笔记本', '智能手表', '耳机']\n\n# 生成数据\nsales_data = {}\nfor product in products:\n    base = np.random.randint(30, 80)\n    trend = np.linspace(0, np.random.randint(20, 60), 9)\n    noise = np.random.normal(0, 5, 9)\n    sales_data[product] = base + trend + noise\n\n# 左侧：意面图\ncolors = plt.cm.Set2(np.linspace(0, 1, len(products)))\nfor idx, (product, sales) in enumerate(sales_data.items()):\n    ax1.plot(years, sales, color=colors[idx], linewidth=2, marker='o', label=product)\n\n# 右侧：分解后的图表 - 使用子图\nfig2, axes = plt.subplots(2, 3, figsize=(15, 8))\naxes = axes.flatten()\n\n# 绘制每个产品的独立图表\nfor idx, (product, sales) in enumerate(sales_data.items()):\n    ax = axes[idx]\n    ax.plot(years, sales, color='#2980B9', linewidth=2.5, marker='o', markersize=6)\n\n    # 填充区域\n    ax.fill_between(years, sales.min(), sales, color='#2980B9', alpha=0.1)\n\n    # 设置标题和标签\n    # ...\n\n    # 标记最高点\n    max_idx = np.argmax(sales)\n    ax.plot(years[max_idx], sales[max_idx], 'o', color='#E74C3C', markersize=8)\n    # ...\n\n    # 简化网格\n    # ...\n\n# 隐藏最后一个子图（我们只有5个产品）\naxes[-1].axis('off')\n\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260106222835313-1108722144.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260106222835312-166951632.png\" /></p>\n<p>在这个示例中，根据原则4，我们<strong>主要改进</strong>了：</p>\n<ul>\n<li>将复杂的多线条图表分解为多个简单图表</li>\n<li>每个子图聚焦一个产品，避免线条交错</li>\n<li>在每个子图中独立标注关键信息</li>\n<li>保持一致的视觉风格便于比较</li>\n</ul>\n<h1 id=\"5-原则5从灰色开始有策略地使用颜色\">5. 原则5：从灰色开始，有策略地使用颜色</h1>\n<p>颜色是可视化中最强大的工具之一，但也是最容易被滥用的。</p>\n<p>从灰度开始设计，可以确保你使用的每个颜色都有明确的目的。</p>\n<pre><code class=\"language-python\"># 创建示例数据\nnp.random.seed(123)\ncities = [\"北京\", \"上海\", \"广州\", \"深圳\", \"成都\", \"武汉\", \"西安\", \"杭州\"]\nmonths = [\n    \"1月\",\n    # ...\n    \"12月\",\n]\n\n# 生成各城市的月度AQI数据\naqi_data = {}\nfor city in cities:\n    base = np.random.randint(60, 100)  # 基础AQI值\n    seasonal = np.sin(np.linspace(0, 2 * np.pi, 12)) * 20  # 季节性变化\n    noise = np.random.normal(0, 10, 12)  # 随机噪声\n    aqi_data[city] = np.clip(base + seasonal + noise, 30, 180)  # 限制在30-180之间\n\n# 计算各城市的年平均AQI\navg_aqi = {city: np.mean(values) for city, values in aqi_data.items()}\n\n# 创建图表对比\nfig = plt.figure(figsize=(12, 6))\n\n# 阶段1：全灰色基础图表\nax1 = plt.subplot(1, 2, 1)\n\n# 全灰色版本\nfor city in cities:\n    ax1.plot(months, aqi_data[city], color=\"#7F8C8D\", linewidth=1.5, alpha=0.6)  # 灰色\n# ...\n\n# 阶段2：识别关键数据后添加初步颜色\nax2 = plt.subplot(1, 2, 2)\n\n# 找出空气质量最好和最差的城市\nsorted_cities = sorted(avg_aqi.items(), key=lambda x: x[1])\nbest_city = sorted_cities[0][0]  # AQI最低的城市\nworst_city = sorted_cities[-1][0]  # AQI最高的城市\n# ...\n\n# 添加标签\n# ...\n\n# 添加空气质量标准线\n# ...\n\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260106222835318-180053858.png\" /></p>\n<p>在这个示例中，根据原则5，我们<strong>主要改进</strong>了：</p>\n<ul>\n<li>从全灰色开始，确保图表结构清晰</li>\n<li>只对关键数据点使用强调色</li>\n<li>使用颜色突出最重要的发现</li>\n<li>通过细节点缀（如虚线、标记）提供额外上下文</li>\n</ul>\n<h1 id=\"6-总结\">6. 总结</h1>\n<p><strong>数据可视化</strong>不仅仅是关于 <code>plt.plot()</code> 的技术，更多的是关于<strong>心理学</strong>和<strong>设计</strong>。</p>\n<ol>\n<li><strong>展示数据</strong>：把聚光灯打在重点上。</li>\n<li><strong>减少混乱</strong>：删掉一切不必要的墨水。</li>\n<li><strong>图文结合</strong>：标题就是结论，标注代替图例。</li>\n<li><strong>避免意面图</strong>：复杂问题拆解看。</li>\n<li><strong>从灰色开始</strong>：克制地使用颜色。</li>\n</ol>\n<p>希望这些原则能帮你在下一次做图时，画出让人眼前一亮的作品！</p>\n<p>文中的代码是一些核心的片段，完整的代码共享在：<a href=\"https://url11.ctfile.com/f/45455611-8593028016-1f332d?p=6872\" rel=\"noopener nofollow\" target=\"_blank\">可视化5个黄金原则.ipynb</a> (访问密码: 6872)</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-06 22:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">6</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "解决java客户端连接ssh失败问题",
      "link": "https://www.cnblogs.com/hellxz/p/19449582",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hellxz/p/19449582\" id=\"cb_post_title_url\" title=\"发布于 2026-01-06 22:24\">\n    <span>解决java客户端连接ssh失败问题</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"问题现象\">问题现象</h2>\n<p>有的运维工具使用了java的ssh客户端，这些客户端和服务端间有时会出现加密算法协商失败和主机密钥类型协商失败的问题，该问题是由于新客户端/服务端禁用了相关的不安全算法和密钥类型，本文简要记录下该问题的解决方法以备不时之需。</p>\n<p>错误常见提示如下：</p>\n<pre><code>#加密算法协商失败\nUnable to negotiate with 192.168.56.99 port 54234: no matching key exchange method found. Their offer: diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1 [preauth]\n\n#主机密钥类型协商失败\nUnable to negotiate with 192.168.56.99 port 22: no matching host key type found. Their offer: ssh-rsa,ssh-dss [preauth]\n</code></pre>\n<h2 id=\"解决方法\">解决方法</h2>\n<p>二选一：</p>\n<h3 id=\"较新的客户端兼容旧服务端\"><strong>较新的客户端兼容旧服务端</strong></h3>\n<p>以Jsch为例，升级新版本。</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.jcraft&lt;/groupId&gt;\n    &lt;artifactId&gt;jsch&lt;/artifactId&gt;\n    &lt;version&gt;0.1.55&lt;/version&gt; &lt;!-- 检查最新版本 --&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>代码中配置连接属性：</p>\n<pre><code class=\"language-java\">import com.jcraft.jsch.*;\n\npublic class SSHConnector {\n    public static void main(String[] args) {\n        try {\n            JSch jsch = new JSch();\n            \n            // 设置支持的算法\n            java.util.Properties config = new java.util.Properties();\n            \n            // 关键配置：指定算法\n            config.put(\"kex\", \"diffie-hellman-group1-sha1,diffie-hellman-group14-sha1\");\n            config.put(\"server_host_key\", \"ssh-rsa,ssh-dss\");\n            config.put(\"cipher.s2c\", \"aes128-ctr,aes128-cbc,3des-cbc\");\n            config.put(\"cipher.c2s\", \"aes128-ctr,aes128-cbc,3des-cbc\");\n            config.put(\"mac.s2c\", \"hmac-sha1\");\n            config.put(\"mac.c2s\", \"hmac-sha1\");\n            \n            Session session = jsch.getSession(\"username\", \"172.16.29.254\", 22);\n            session.setConfig(config);\n            session.setPassword(\"password\");\n            session.setConfig(\"StrictHostKeyChecking\", \"no\"); // 临时测试用\n            \n            session.connect(30000); // 30秒超时\n            System.out.println(\"连接成功\");\n            \n            session.disconnect();\n        } catch (JSchException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<h3 id=\"较新的服务端兼容旧客户端\"><strong>较新的服务端兼容旧客户端</strong></h3>\n<p><code>/etc/ssh/sshd_config</code>追加以下内容，这里添加的算法取决于Their offer后边提示的类型，一般只添加部分即可，推荐使用<code>+</code>追加额外算法。</p>\n<pre><code class=\"language-bash\">#解决no matching key exchange method found报错\nKexAlgorithms +diffie-hellman-group14-sha1\n#解决no matching host key type found报错\nHostKeyAlgorithms +ssh-rsa\n</code></pre>\n<h2 id=\"附查看服务端ssh支持算法\">附查看服务端ssh支持算法</h2>\n<pre><code class=\"language-bash\">hellxz@hz:~$ sudo sshd -T | grep -E \"^hostkeyalg|^kexalg\"\nkexalgorithms sntrup761x25519-sha512@openssh.com,curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group14-sha256,diffie-hellman-group14-sha1\nhostkeyalgorithms ssh-ed25519-cert-v01@openssh.com,ecdsa-sha2-nistp256-cert-v01@openssh.com,ecdsa-sha2-nistp384-cert-v01@openssh.com,ecdsa-sha2-nistp521-cert-v01@openssh.com,sk-ssh-ed25519-cert-v01@openssh.com,sk-ecdsa-sha2-nistp256-cert-v01@openssh.com,rsa-sha2-512-cert-v01@openssh.com,rsa-sha2-256-cert-v01@openssh.com,ssh-ed25519,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,sk-ssh-ed25519@openssh.com,sk-ecdsa-sha2-nistp256@openssh.com,rsa-sha2-512,rsa-sha2-256,ssh-rsa\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-06 22:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hellxz\">东北小狐狸</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}