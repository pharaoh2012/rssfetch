{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "数据不够代码凑？用 Albumentations 让你的 AI 模型“看”得更广，训练快 10 倍！",
      "link": "https://www.cnblogs.com/swizard/p/19410908",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/swizard/p/19410908\" id=\"cb_post_title_url\" title=\"发布于 2025-12-28 09:16\">\n    <span>数据不够代码凑？用 Albumentations 让你的 AI 模型“看”得更广，训练快 10 倍！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h3>引言：贫穷限制了我的数据集，但不能限制我的模型</h3>\n<p>作为一名 CV 算法工程师，你一定经历过这种绝望： 老板丢给你 100 张产品瑕疵照片，让你训练一个准确率 99% 的检测模型。 你看着那少得可怜的数据，内心在咆哮：“这肯定会过拟合（Overfitting）啊！模型根本学不到特征，只会死记硬背！”</p>\n<p>去采集更多数据？成本太高，周期太长。 自己写代码用 OpenCV 做旋转、裁剪？处理完图片还得手动算坐标变换（Bounding Box），稍微搞错一点，训练数据就变成了“垃圾数据”。</p>\n<p><strong>这就是 Albumentations 登场的时刻。</strong></p>\n<p>它不仅能帮你把 100 张图片“变”成 10000 张，还能自动处理最让人头疼的<strong>坐标映射</strong>和<strong>掩膜（Mask）对齐</strong>问题。最重要的是，它基于高度优化的 OpenCV 和 SIMD 指令集，速度快到飞起。</p>\n<hr />\n<h3>&nbsp;概念拆解：给模型来一场“魔鬼特训”</h3>\n<h4>1. 生活化类比：驾校练车</h4>\n<p>想象一下你在考驾照。 如果你的教练只让你在<strong>晴天、平坦、无人的直路</strong>上练习，你练得再熟，一旦考试那天<strong>下雨、路面有坑、或者光线刺眼</strong>，你立马就会挂科。</p>\n<p><strong>深度学习模型的训练也是一样的：</strong></p>\n<ul>\n<li>\n<p><strong>原始数据</strong>：就是那条“晴天直路”。</p>\n</li>\n<li>\n<p><strong>过拟合</strong>：你只会开晴天直路，换个环境就歇菜。</p>\n</li>\n<li>\n<p><strong>数据增强（Albumentations）</strong>：就是那个严厉的“魔鬼教练”。</p>\n<ul>\n<li>\n<p>它故意把图片变暗（模拟夜间）；</p>\n</li>\n<li>\n<p>故意把图片旋转（模拟摄像头歪了）；</p>\n</li>\n<li>\n<p>故意在图片上挖几个洞（模拟遮挡）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>通过这种“折磨”，模型虽然在训练时更痛苦了，但它学会了<strong>本质特征</strong>（比如：车就是车，不管它是亮的还是暗的），而不是死记硬背像素点。</p>\n<h4>2. 工作流图解</h4>\n<p>Albumentations 的工作逻辑非常像工厂的<strong>流水线（Pipeline）</strong>：</p>\n<blockquote>\n<p><strong>[输入] 原始图片 + 标签（如边框坐标）</strong> ⬇️ <strong>[流水线 A.Compose]</strong> ├─ 随机裁剪 (RandomCrop) -&gt; 可能是左上角，可能是中心 ├─ 水平翻转 (HorizontalFlip) -&gt; 像照镜子一样 ├─ 随机亮度对比度 (RandomBrightnessContrast) -&gt; 忽明忽暗 ⬇️ <strong>[输出] 增强后的图片 + 自动调整好的标签坐标</strong></p>\n</blockquote>\n<p>你只需要定义好这个流水线，剩下的脏活累活，库全包了。</p>\n<hr />\n<h3>动手实战：三分钟上手 Hello World</h3>\n<p>别光说不练，我们来写代码。假设你已经安装好了库： <code>pip install albumentations opencv-python matplotlib</code></p>\n<h4>1. 最小可行性代码 (MVP)</h4>\n<p>我们将一张普通图片，通过 Albumentations 变成一张“面目全非”但特征犹在的训练样本。</p>\n<div class=\"code-block ng-tns-c3098535048-154 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-154 ng-star-inserted\"><span class=\"ng-tns-c3098535048-154\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-154 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-154\">\n<div class=\"animated-opacity ng-tns-c3098535048-154\">\n<pre class=\"ng-tns-c3098535048-154 highlighter-hljs\"><code>import albumentations as A\nimport cv2\nimport matplotlib.pyplot as plt\n\n# 1. 读取一张图片 (假设你有一张 cat.jpg)\n# 注意：OpenCV 读取的是 BGR 格式，为了显示正常我们需要转为 RGB\nimage = cv2.imread(\"cat.jpg\")\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\n# 2. 定义我们的“魔鬼教练”流水线\ntransform = A.Compose([\n    # 随机裁剪一块 450x450 的区域\n    A.RandomCrop(width=450, height=450),\n    \n    # 50% 的概率水平翻转图片\n    A.HorizontalFlip(p=0.5),\n    \n    # 随机调整亮度和对比度，让模型适应不同光照\n    A.RandomBrightnessContrast(p=0.2),\n    \n    # 随机旋转 -30 到 30 度\n    A.Rotate(limit=30, p=0.5)\n])\n\n# 3. 执行变换！\n# Albumentations 接受关键字参数，所以必须显式写 image=...\naugmented = transform(image=image)\naugmented_image = augmented[\"image\"]\n\n# 4. 展示结果\nplt.figure(figsize=(10, 5))\nplt.subplot(1, 2, 1)\nplt.title(\"Original\")\nplt.imshow(image)\nplt.subplot(1, 2, 2)\nplt.title(\"Augmented\")\nplt.imshow(augmented_image)\nplt.show()</code></pre>\n</div>\n</div>\n</div>\n<h4>2. 代码解析：为什么这么写？</h4>\n<ul>\n<li>\n<p><strong><code>A.Compose([...])</code></strong>：这是核心容器。你可以把它理解为一个“动作列表”。当你调用它时，它会按顺序（或按概率）对图片执行列表里的操作。</p>\n</li>\n<li>\n<p><strong><code>p=0.5</code></strong>：这是 Albumentations 的灵魂——<strong>概率</strong>。如果每次增强都一模一样，那就没有随机性了。<code>p=0.5</code> 意味着这张图有 50% 的概率被翻转，50% 的概率保持原样。这就保证了生成数据的多样性。</p>\n</li>\n<li>\n<p><strong><code>augmented[\"image\"]</code></strong>：注意，返回值是一个字典。因为如果你还传入了 <code>mask</code> 或 <code>bboxes</code>，它们也会在这个字典里被返回。</p>\n</li>\n</ul>\n<hr />\n<h3>进阶深潜：解决最头疼的坐标变换</h3>\n<p>普通的库（比如 PIL 或 torchvision）做图片旋转很容易，但如果你在做<strong>目标检测（Object Detection）</strong>，图片旋转了，你标注的那个**方框（Bounding Box）**如果不跟着旋转，数据就废了。</p>\n<p>手动计算这个坐标变换涉及复杂的几何数学，极易出错。<strong>Albumentations 最强大的功能就是自动处理这个问题。</strong></p>\n<h4>场景：带 Bounding Box 的增强</h4>\n<div class=\"code-block ng-tns-c3098535048-155 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-155 ng-star-inserted\"><span class=\"ng-tns-c3098535048-155\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-155 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-155\">\n<div class=\"animated-opacity ng-tns-c3098535048-155\">\n<pre class=\"ng-tns-c3098535048-155 highlighter-hljs\"><code># 假设我们有一个标注框 [x_min, y_min, x_max, y_max]\n# 比如猫的脸在图片的位置\nbboxes = [[100, 100, 200, 200, 1]] # 最后的 1 是类别 ID\n\ntransform = A.Compose([\n    A.HorizontalFlip(p=1), # 强制翻转，方便观察效果\n    A.Rotate(limit=45, p=1)\n], bbox_params=A.BboxParams(format='pascal_voc', label_fields=['category_ids']))\n\n# 魔法发生的时刻\naugmented = transform(image=image, bboxes=bboxes, category_ids=[1])\n\n# 获取变换后的图片和坐标\naug_img = augmented['image']\naug_bboxes = augmented['bboxes']\n\nprint(f\"原坐标: {bboxes[0][:4]}\")\nprint(f\"变换后坐标: {aug_bboxes[0]}\") \n# 输出的坐标已经自动适配了翻转和旋转！</code></pre>\n</div>\n</div>\n</div>\n<p><strong>最佳实践与避坑指南：</strong></p>\n<ol start=\"1\">\n<li>\n<p><strong>坐标格式（Format）要对齐</strong>：Albumentations 支持 <code>pascal_voc</code> ([x_min, y_min, x_max, y_max]), <code>coco</code> ([x_min, y_min, w, h]), <code>yolo</code> (归一化中心点) 等格式。<strong>千万别填错 <code>format</code> 参数</strong>，否则你的框会飞到天上去。</p>\n</li>\n<li>\n<p><strong>验证你的增强</strong>：在开始大规模训练前，务必写脚本可视化几张增强后的图片和标签。有些强烈的变换（如 <code>ElasticTransform</code> 弹性形变）可能会导致标签严重失真，不适合用于精细的检测任务。</p>\n</li>\n<li>\n<p><strong>OneOf 的使用</strong>：有时候你需要“二选一”。比如你可以用 <code>A.OneOf([A.Blur, A.MotionBlur], p=0.2)</code>，这意味着每次要么用普通模糊，要么用运动模糊，不会同时叠加，这能防止图片被破坏得太厉害。</p>\n</li>\n</ol>\n<hr />\n<h3>总结与延伸</h3>\n<p>Albumentations 就像是给你的深度学习模型吃了一顿“自助大餐”，用极低的成本极大地丰富了数据的多样性。</p>\n<p><strong>核心知识点回顾：</strong></p>\n<ol start=\"1\">\n<li>\n<p><strong>流水线机制</strong>：使用 <code>Compose</code> 组合多个变换。</p>\n</li>\n<li>\n<p><strong>概率控制</strong>：利用 <code>p</code> 参数引入随机性，模拟真实世界的复杂情况。</p>\n</li>\n<li>\n<p><strong>空间一致性</strong>：它可以自动、准确地变换 Bounding Boxes 和 Masks，无需手动计算几何映射。</p>\n</li>\n</ol>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-28 09:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/swizard\">Swizard</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "前后端分离框架 CatchAdmin V5 beta.2 发布 插件化与开发效率的进一步提升",
      "link": "https://www.cnblogs.com/catchadmin/p/19410766",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19410766\" id=\"cb_post_title_url\" title=\"发布于 2025-12-28 08:20\">\n    <span>前后端分离框架 CatchAdmin V5 beta.2 发布 插件化与开发效率的进一步提升</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前后端分离框架-catchadmin-v5-beta2-发布-插件化与开发效率的进一步提升\">前后端分离框架 CatchAdmin V5 beta.2 发布 插件化与开发效率的进一步提升</h1>\n<h2 id=\"关于-catchadmin\">关于 CatchAdmin</h2>\n<p>CatchAdmin 是一款基于 Laravel 和 Element Plus 二次开发而成后台管理系统。Laravel 社区也有许多非常优秀的后台管理系统，例如 Nova，官方出品，当然是收费的，免费的有基于 Livewire 的 Filament，还有不得不说的 Laravel Admin。它采用前后端分离架构，CatchAdmin 集成了 Token 鉴权、权限管理、动态路由、动态表格、分页封装、资源权限、上传下载、代码生成器支持一键导出导入，数据回收站，附件管理的一款模块化框架。Laravel 框架仅仅作为 Api 输出。将管理系统模块之间的耦合降到了最低限度。每个模块之间都有独立的控制器，路由，模型，数据表。在开发上尽可能将模块之间的影响降到最低，降低了开发上的难度。基于 CatchAdmin 可以开发 CMS，CRM，OA 等等系统。也封装了很多实用的工具，提升开发体验。</p>\n<h2 id=\"本次更新亮点\">本次更新亮点</h2>\n<h3 id=\"导入导出功能增强\">导入导出功能增强</h3>\n<p>Beta.3 版本对数据导入导出功能进行了核心层面的增强。在实际业务中，批量导入用户、订单、商品等数据是高频需求。此次更新优化了导入导出的底层逻辑，支持更大数据量的处理，并提供了更灵活的字段映射配置。在代码生成器中勾选\"支持导入导出\"，即可为模块自动生成完整的导入导出功能，无需手写 Excel 处理代码。</p>\n<h3 id=\"插件系统正式支持\">插件系统正式支持</h3>\n<p>插件系统是 v5.0 的核心特性之一。CatchAdmin 没有自己发明一套插件机制，而是直接绑定 Composer 生态——任何符合 Laravel Package 规范的 Composer 包都可以作为 CatchAdmin 插件使用。</p>\n<p>本次更新增强了插件安装的 Hook 功能，开发者可以在插件安装、卸载时执行自定义逻辑（如初始化配置、创建数据表等）。同时优化了插件安装页面，支持在后台可视化管理插件的启用、禁用与卸载。</p>\n<p>这种设计让 CatchAdmin 可以无缝集成第三方服务（支付、短信、OSS 等），也方便将业务逻辑封装成插件在不同项目间复用。</p>\n<h3 id=\"sfc-远程加载性能优化\">SFC 远程加载性能优化</h3>\n<p>CatchAdmin 的前端支持\"即时渲染\"，即无需编译即可直接加载 Vue 单文件组件（SFC）。这在开发阶段非常方便，但远程加载会影响首屏渲染速度。</p>\n<p>Beta.3 版本优化了 SFC 的加载机制，通过缓存策略和按需加载，显著提升了页面渲染速度。在实际测试中，列表页的首次加载时间缩短了约 30%。</p>\n<h3 id=\"安装体验优化\">安装体验优化</h3>\n<p>简化了项目初始化流程，修复了因 Composer 依赖冲突导致的安装失败问题。现在从创建项目到启动后台，整个过程更加流畅，基本不需要手动干预。</p>\n<p>此外，左侧菜单现在支持自动更新——安装新模块或插件后，刷新页面即可看到对应的菜单项，无需手动配置路由。</p>\n<h2 id=\"插件市场已正式上线\">插件市场已正式上线</h2>\n<p><a href=\"https://catchadmin.vip/plugins\" rel=\"noopener nofollow\" target=\"_blank\">CatchAdmin 插件市场</a></p>\n<h2 id=\"快速开始\">快速开始</h2>\n<pre><code class=\"language-shell\">composer global -W require catchadmin/installer\n\n# 新建项目\ncatch new catchadmin\n\n# 安装项目\ncd catchadmin &amp;&amp; php artisan catch:install\n\n# 启动项目\ncomposer run dev\n</code></pre>\n<h2 id=\"功能\">功能</h2>\n<ul>\n<li>☑️<strong>用户管理</strong> 完成用户添加、修改、删除配置，支持不同用户登录后台看到不同的首页</li>\n<li>☑️<strong>部门管理</strong> 部门组织机构（公司、部门、小组），树结构展现</li>\n<li>☑️<strong>岗位管理</strong> 可以给用户配置所担任职务</li>\n<li>☑️<strong>角色管理</strong> 树结构设计，支持角色菜单和按钮权限分配，支持角色数据权限分配、强大的角色管理体系</li>\n<li>☑️<strong>菜单管理</strong> 配置系统菜单和按钮等</li>\n<li>☑️<strong>字典管理</strong> 对系统中经常使用并且固定的数据可以重复使用和维护</li>\n<li>☑️<strong>系统配置</strong> 系统的一些常用设置管理</li>\n<li>☑️<strong>操作日志</strong> 用户对系统的一些正常操作的查询</li>\n<li>☑️<strong>登录日志</strong> 用户登录系统的记录查询</li>\n<li>☑️<strong>文件上传</strong> 支持<code>本地</code>、<code>七牛云</code>、<code>阿里云</code>、<code>腾讯云</code></li>\n<li>☑️<strong>附件管理</strong> 管理当前系统上传的文件及图片等信息</li>\n<li>☑️<strong>数据表维护</strong> 对系统的数据表可以进行清理碎片和优化，并且管理所有数据的回收和销毁</li>\n<li>☑️<strong>代码生成</strong> 前后端代码的生成（php、vue、 数据库迁移），支持一键生成到模块</li>\n<li>☑️<strong>支持 Vue 即时渲染</strong> 支持前端 Vue 即时渲染 无需编译</li>\n<li>☑️<strong>支持插件系统</strong> CatchAdmin 插件即 Composer 包，无需再学一次插件开发，完全绑定 Composer 生态</li>\n</ul>\n<h2 id=\"在线体验\">在线体验</h2>\n<ul>\n<li>演示地址：<a href=\"https://pro.catchadmin.com\" rel=\"noopener nofollow\" target=\"_blank\">https://pro.catchadmin.com</a></li>\n<li>账户：<code>catch@admin.com</code></li>\n<li>密码：<code>catchadmin</code></li>\n</ul>\n<h2 id=\"项目地址\">项目地址</h2>\n<ul>\n<li>GitHub：<a href=\"https://github.com/JaguarJack/catch-admin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/JaguarJack/catch-admin</a></li>\n<li>Gitee：<a href=\"https://gitee.com/catchadmin/catchadmin\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/catchadmin/catchadmin</a></li>\n</ul>\n<h2 id=\"界面预览\">界面预览</h2>\n<p><img alt=\"CatchAdmin v5.0 Beta 欢迎页\" class=\"lazyload\" /><br />\n<img alt=\"CatchAdmin v5.0 Beta 数据面板\" class=\"lazyload\" /><br />\n<img alt=\"CatchAdmin v5.0 Beta 用户管理\" class=\"lazyload\" /><br />\n<img alt=\"CatchAdmin v5.0 Beta 代码生成\" class=\"lazyload\" /></p>\n<p><a href=\"https://catchadmin.com/post/2025-12/catchadmin-v5-beta\" rel=\"noopener nofollow\" target=\"_blank\">原文- 前后端分离框架 CatchAdmin V5 beta.2 发布 插件化与开发效率的进一步提升</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-28 08:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "如何使用『页脚HTML代码』-实现自推广 -『AI实现的小程序&小游戏』",
      "link": "https://www.cnblogs.com/uoky/p/19410177",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/uoky/p/19410177\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 23:32\">\n    <span>如何使用『页脚HTML代码』-实现自推广 -『AI实现的小程序&amp;小游戏』</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div class=\"article-container\">\n<h1 style=\"font-size: 28px; font-weight: bold; margin: 0; color: rgba(44, 62, 80, 1);\">个人博客-自定义推广方案</h1>\n<p>&nbsp;</p>\n<div class=\"summary-section\">\n<h2 style=\"color: rgba(44, 62, 80, 1); font-size: 20px; margin-top: 0; display: flex;\"><span style=\"color: rgba(255, 255, 255, 1); width: 28px; height: 28px; border-radius: 50%; display: inline-flex; margin-right: 10px; font-size: 14px;\">!</span> 摘要</h2>\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(44, 62, 80, 1); margin: 10px 0;\"><strong style=\"color: rgba(52, 152, 219, 1); display: block; margin-bottom: 8px;\">使用AI写了超简易的微信小程序『Uoky统计』微信小游戏『木木玩躲避』，如何使用博客实现自定义推广</strong></p>\n</div>\n<div class=\"content-section\">\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(51, 51, 51, 1); margin: 0 0 15px; padding-left: 20px;\"><span style=\"color: rgba(52, 152, 219, 1); font-weight: bold;\">•</span> 目前AI写的小程序与小游戏均已上线，考虑推广。 <span style=\"text-decoration: line-through; color: rgba(149, 165, 166, 1); font-style: italic; background-color: rgba(248, 249, 250, 1); padding: 2px 6px; border-radius: 4px; margin-left: 5px;\"> 这个小程序和小游戏十分简易，没有任何技术含量，目前是纯浪费时间玩一下。 </span></p>\n<div class=\"image-crossed\" style=\"text-align: center; margin: 20px 0;\"><span style=\"text-decoration: line-through; color: rgba(149, 165, 166, 1); font-style: italic; display: block;\"> <img alt=\"生成特定内容的图片\" height=\"185\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227223009141-400083286.png\" width=\"185\" /> </span></div>\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(51, 51, 51, 1); margin: 15px 0 0; padding-left: 20px;\"><span style=\"color: rgba(52, 152, 219, 1); font-weight: bold;\">•</span> 虽然作者本人没有做什么开发方面的努力 <span style=\"text-decoration: line-through; color: rgba(149, 165, 166, 1); background-color: rgba(248, 249, 250, 1); padding: 2px 6px; border-radius: 4px; margin: 0 3px;\"> <em>找字体、音乐、音效、图标</em> </span> <span style=\"text-decoration: line-through; color: rgba(149, 165, 166, 1); background-color: rgba(248, 249, 250, 1); padding: 2px 6px; border-radius: 4px; margin: 0 3px;\"> <em>备案等后勤工作</em> </span> 。但毕竟上线了，还是想着推广一下</p>\n</div>\n<div class=\"emoji-section\" style=\"text-align: center; margin: 30px 0;\"><img alt=\"生成年迈感叹表情包 (2)\" height=\"273\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227224329737-1023925099.png\" width=\"273\" /></div>\n<div class=\"effect-section\">\n<div>&nbsp;</div>\n<h3 style=\"color: rgba(39, 174, 96, 1); font-size: 20px; margin-top: 0; display: flex; padding-top: 10px;\"><span style=\"color: rgba(255, 255, 255, 1); width: 30px; height: 30px; border-radius: 50%; display: inline-flex; margin-right: 12px; font-size: 14px;\">✓</span> 实现效果：</h3>\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(44, 62, 80, 1); margin: 15px 0 0; font-weight: 500;\">画面右下角显示：</p>\n<div class=\"image-center\"><br />\n<p>&nbsp;</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227232209151-931241342.png\" style=\"border-radius: 18px;\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n\n\n</div>\n\n\n</div>\n<div class=\"steps-section\">\n<div>&nbsp;</div>\n<h3 style=\"color: rgba(41, 128, 185, 1); font-size: 22px; margin-top: 0; padding-left: 15px;\"><span><br /></span>&nbsp; &nbsp; 实现步骤</h3>\n<div class=\"step\">\n<div style=\"display: flex; margin-bottom: 15px;\">\n<div style=\"color: rgba(255, 255, 255, 1); width: 36px; height: 36px; border-radius: 50%; display: flex; font-weight: bold; font-size: 18px; margin-right: 15px;\">1</div>\n<p style=\"font-size: 16px; color: rgba(44, 62, 80, 1); font-weight: 600; margin: 0;\">进入博客园设置</p>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"image-center\" style=\"text-align: center; margin: 15px 0;\"><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227220723565-782831602.png\" /></div>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"step\">\n<div style=\"display: flex; margin-bottom: 15px;\">\n<div style=\"color: rgba(255, 255, 255, 1); width: 36px; height: 36px; border-radius: 50%; display: flex; font-weight: bold; font-size: 18px; margin-right: 15px;\">2</div>\n<p style=\"font-size: 16px; color: rgba(44, 62, 80, 1); font-weight: 600; margin: 0;\">指定页脚HTML代码</p>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"image-center\" style=\"text-align: center; margin: 15px 0;\"><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227221106222-787541671.png\" /></div>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"success-message\">\n<p>添加超简单固定div即可，超级简单！</p>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"code-section\">\n<h4 style=\"color: rgba(52, 152, 219, 1); font-size: 18px; margin: 0 0 20px; display: flex;\"><span style=\"width: 34px; height: 24px; border-radius: 4px; display: inline-flex; margin-right: 10px; color: rgba(255, 255, 255, 1); font-size: 14px;\">&lt;/&gt;</span> 代码示例：</h4>\n<div class=\"image-center\" style=\"text-align: center; margin: 0;\"><img alt=\"image\" height=\"auto\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227221829466-798413403.png\" width=\"100%\" /></div>\n\n\n\n\n\n\n\n\n</div>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"tip-section\">\n<div style=\"font-size: 30px; color: rgba(33, 150, 243, 1);\">💡</div>\n<h4 style=\"color: rgba(13, 71, 161, 1); font-size: 18px; margin-top: 0; display: flex;\"><span style=\"color: rgba(255, 255, 255, 1); width: 30px; height: 30px; border-radius: 50%; display: inline-flex; margin-right: 12px; font-size: 16px;\">i</span> 推广建议</h4>\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(13, 71, 161, 1); margin: 15px 0 0; font-weight: 500;\">如果你也有一些工具想要推广，建议在不影响自身博客内容显示的情况下，酌情添加。</p>\n\n\n\n\n\n\n\n\n</div>\n\n\n\n\n\n\n\n\n</div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 23:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/uoky\">人间春风意</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Sidecar不就是在Pod里多跑一个容器吗！",
      "link": "https://www.cnblogs.com/ydswin/p/19396769",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ydswin/p/19396769\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 19:05\">\n    <span>Sidecar不就是在Pod里多跑一个容器吗！</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>深入理解云原生时代的核心设计模式</p>\n</blockquote>\n<p>乍看之下，Sidecar 模式确实只是在 Pod 里多运行一个容器而已。但这种表面理解，就像说“互联网不过是一堆电缆和服务器”一样，忽略了其背后的精妙设计思想和革命性价值。今天，我们就来深入探讨这个看似简单却极具威力的云原生核心模式。</p>\n<h2 id=\"从一个认知误区说起\">从一个认知误区说起</h2>\n<p><strong>\"Pod 就是容器\"</strong>——这是许多 Kubernetes 初学者最常见的误解。事实上，Pod 并不是容器，而是<strong>容器的容器</strong>，是一个可以容纳一个或多个紧密关联容器的“逻辑主机”。</p>\n<p>当我们说“在 Pod 里多跑一个容器”时，这意味着什么？意味着这个额外的容器与主应用容器共享着几乎所有关键资源：<strong>网络命名空间</strong>（同一 IP，通过 localhost 直接通信）、<strong>存储卷</strong>（Volume）以及<strong>生命周期</strong>（同生共死）。</p>\n<p>这种共享关系，正是 Sidecar 魔力的源泉。</p>\n<h2 id=\"sidecar-的本质不只是多一个容器\">Sidecar 的本质：不只是“多一个容器”</h2>\n<h3 id=\"设计模式而非技术实现\">设计模式而非技术实现</h3>\n<p>Sidecar 本质上是一种<strong>容器设计模式</strong>，而不是简单的技术实现。它代表了一种架构哲学：将辅助功能从主业务逻辑中解耦，让专业容器做专业事。</p>\n<p>举个例子，想象一位主厨（主应用容器）在厨房工作。主厨专注炒菜（业务逻辑），而配菜、打扫、菜单更新等杂事由助手（Sidecar 容器）完成。这种分工协作大大提升了效率和专业性。</p>\n<h3 id=\"云原生时代的功能扩展槽\">云原生时代的“功能扩展槽”</h3>\n<p>在云原生架构中，Sidecar 如同计算机主板上的<strong>扩展槽</strong>，允许我们为应用动态添加各种能力而无须修改应用本身。</p>\n<ul>\n<li><strong>日志收集</strong>：主容器写日志到共享卷，Sidecar 容器负责收集和发送到日志系统</li>\n<li><strong>服务网格</strong>：如 Istio 使用 Envoy 作为 Sidecar 代理，实现服务间通信的监控、安全和控制</li>\n<li><strong>配置管理</strong>：Sidecar 监听配置中心，动态更新配置文件，主容器只需读取本地文件</li>\n<li><strong>安全代理</strong>：如 Vault Agent Sidecar，负责与密钥管理系统交互，主应用无感知</li>\n</ul>\n<h2 id=\"为什么多跑一个容器如此重要\">为什么“多跑一个容器”如此重要？</h2>\n<h3 id=\"1-无侵入式架构设计\">1. 无侵入式架构设计</h3>\n<p>传统做法中，要为应用添加监控、安全或通信功能，通常需要修改应用代码。而 Sidecar 模式通过“多跑一个容器”实现了<strong>零侵入</strong>的功能增强。</p>\n<p>以服务网格为例，应用代码无需关心服务发现、熔断、重试等复杂逻辑，所有这些都由 Sidecar 代理透明处理。</p>\n<h3 id=\"2-技术栈无关性\">2. 技术栈无关性</h3>\n<p>Sidecar 容器可以用任何语言编写，与主应用容器的技术栈无关。一个 Java 应用可以搭配一个 Go 或 Rust 编写的 Sidecar，充分发挥各语言优势。</p>\n<h3 id=\"3-独立性和可复用性\">3. 独立性和可复用性</h3>\n<p>Sidecar 容器可以<strong>独立开发、升级和部署</strong>。一个精心设计的日志收集 Sidecar 可以被全公司所有服务复用，大大降低开发维护成本。</p>\n<h2 id=\"实战示例sidecar-如何工作\">实战示例：Sidecar 如何工作</h2>\n<p>让我们通过一个具体例子看看“多跑一个容器”如何实际运作：</p>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx-with-logger\nspec:\n  volumes:\n  - name: nginx-logs\n    emptyDir: {}  # 临时共享目录\n\n  containers:\n  - name: nginx\n    image: nginx\n    volumeMounts:\n    - name: nginx-logs\n      mountPath: /var/log/nginx\n\n  - name: log-sidecar  # 这就是“多跑”的容器\n    image: busybox\n    command: [\"/bin/sh\", \"-c\"]\n    args:\n    - while true; do\n        if [ -f /var/log/nginx/access.log ]; then\n          tail -n 10 /var/log/nginx/access.log;\n        fi;\n        sleep 5;\n      done\n    volumeMounts:\n    - name: nginx-logs\n      mountPath: /var/log/nginx\n</code></pre>\n<p>在这个例子中：</p>\n<ul>\n<li><strong>nginx 容器</strong>：专注提供 Web 服务，将日志写入 <code>/var/log/nginx</code></li>\n<li><strong>log-sidecar 容器</strong>：负责读取日志并处理（示例中只是打印，实际可发送到日志系统）</li>\n</ul>\n<p>两个容器通过 <strong>emptyDir 卷</strong>共享日志目录，通过 <strong>localhost</strong> 通信（如果需要），共同构成一个完整的 Web 服务单元。</p>\n<h2 id=\"超越多一个容器sidecar-的高级模式\">超越“多一个容器”：Sidecar 的高级模式</h2>\n<h3 id=\"服务网格中的-sidecar\">服务网格中的 Sidecar</h3>\n<p>在服务网格（如 Istio）中，Sidecar 模式发挥到极致。每个 Pod 中注入的 Envoy 代理容器透明地拦截和处理所有进出流量，实现精细化的流量管理、安全加密和可观测性。</p>\n<p>这时，“多跑的容器”不再是简单的辅助角色，而是构成了<strong>分布式系统的通信基础设施</strong>。</p>\n<h3 id=\"适配器模式\">适配器模式</h3>\n<p>Sidecar 可以作为<strong>适配器</strong>，在不同接口或协议间进行转换。例如，主容器暴露 <code>/metrics</code> 接口，而监控系统需要 <code>/health</code> 接口，Sidecar 容器负责协议转换，无需修改主应用。</p>\n<h2 id=\"最佳实践与注意事项\">最佳实践与注意事项</h2>\n<p>虽然 Sidecar 功能强大，但也需要谨慎使用：</p>\n<h3 id=\"启动顺序协调\">启动顺序协调</h3>\n<p>Kubernetes 不保证容器启动顺序，如果 Sidecar 需要先于主容器就绪（如配置同步 Sidecar），需要通过 initContainers 或健康检查机制协调。</p>\n<h3 id=\"资源管理\">资源管理</h3>\n<p>为 Sidecar 设置合理的资源请求和限制，避免与主容器资源争抢。</p>\n<pre><code class=\"language-yaml\">resources:\n  requests:\n    cpu: 100m\n    memory: 128Mi\n  limits:\n    cpu: 200m\n    memory: 256Mi\n</code></pre>\n<h3 id=\"避免过度使用\">避免过度使用</h3>\n<p>不是所有功能都适合 Sidecar 模式。如果架构不复杂，直接使用 API 网关或传统中间件可能更简单。</p>\n<h2 id=\"与其他模式的关系\">与其他模式的关系</h2>\n<h3 id=\"sidecar-vs-init-容器\">Sidecar vs Init 容器</h3>\n<ul>\n<li><strong>Init 容器</strong>：在 Pod 启动前运行，完成即退出，用于初始化工作</li>\n<li><strong>Sidecar 容器</strong>：与主容器并行运行，在整个生命周期内提供辅助功能</li>\n</ul>\n<h3 id=\"sidecar-vs-daemonset\">Sidecar vs DaemonSet</h3>\n<ul>\n<li><strong>Sidecar</strong>：每个应用实例一个，与特定应用紧密绑定</li>\n<li><strong>DaemonSet</strong>：每个节点一个，提供节点级别服务</li>\n</ul>\n<h2 id=\"总结简单概念背后的深远影响\">总结：简单概念背后的深远影响</h2>\n<p>回到最初的问题：“Sidecar 不就是 Pod 里多跑一个容器吗？”——<strong>是，但远不止于此</strong>。</p>\n<p>这个看似简单的“多跑一个容器”设计，实际上代表了云原生架构的核心思想：<strong>关注点分离、松散耦合、可复用性</strong>。它让应用开发者专注业务逻辑，而将通用能力下沉到基础设施层。</p>\n<p>从简单的日志收集到复杂的服务网格，从配置管理到安全代理，Sidecar 模式已经成为现代云原生架构不可或缺的组成部分。它不是什么银弹，但当合理使用时，确实能够极大地提升系统的可维护性、可观测性和灵活性。</p>\n<p>所以，需要理解这简单表象背后蕴含的深厚架构智慧。</p>\n<p><em>是的，它就是多跑一个容器，但正是这个“多跑”的容器，让云原生应用架构变得如此强大而优雅。</em></p>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/ydswin/\" target=\"_blank\">dashery</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/ydswin/p/19396769\" target=\"_blank\">https://www.cnblogs.com/ydswin/p/19396769</a></p>\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2025-12-27 19:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ydswin\">dashery</a>&nbsp;\n阅读(<span id=\"post_view_count\">62</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "基于莱布尼茨公式的编程语言计算性能基准测试",
      "link": "https://www.cnblogs.com/shanyou/p/19408361",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19408361\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 19:03\">\n    <span>基于莱布尼茨公式的编程语言计算性能基准测试</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><font face=\"微软雅黑 Light\" size=\"3\">利用莱布尼茨公式（Leibniz formula）计算圆周率 $\\pi$。尽管在现代数学计算库中，莱布尼茨级数因其收敛速度极慢而鲜被用于实际精算 Π 值，但其算法结构——高密度的浮点运算、紧凑的循环逻辑以及对算术逻辑单元（ALU）的持续压力——使其成为测试 CPU 单核吞吐量、浮点运算单元（FPU）效率以及编译器自动向量化（Auto-vectorization）能力的绝佳“试金石” 。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">GitHub 开源项目 </font><a href=\"https://github.com/niklas-heer/speed-comparison\" rel=\"noopener nofollow\" target=\"_blank\"><font face=\"微软雅黑 Light\" size=\"3\">niklas-heer/speed-comparison</font></a><code></code><font face=\"微软雅黑 Light\" size=\"3\"> 在 2025 年 12 月产生的最新数据，涵盖了从底层系统级语言（如 C++、Rust）到托管型语言（如 Java、C#），再到动态解释型语言（如 Python、Ruby）的 62 种不同实现。通过对 10 亿次迭代运算的详尽分析，我们不仅试图排列出“谁最快”，更致力于揭示“为什么快”背后的深层技术逻辑，探讨单指令多数据（SIMD）技术、即时编译（JIT）机制以及内存模型对计算性能的决定性影响。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\"><img alt=\"Speed comparison chart\" src=\"https://niklas-heer.github.io/speed-comparison/history/2025-12-21T203810/combined_results.png\" /></font></p><p><font face=\"微软雅黑 Light\" size=\"3\">上图来自：</font><a href=\"https://niklas-heer.github.io/speed-comparison/\" rel=\"noopener nofollow\" title=\"https://niklas-heer.github.io/speed-comparison/\"><font face=\"微软雅黑 Light\" size=\"3\">https://niklas-heer.github.io/speed-comparison/</font></a></p><p><font face=\"微软雅黑 Light\" size=\"3\">莱布尼茨公式，作为 arctan(x) 的泰勒级数在 x=1时的特例，其数学表达为：</font></p><p><a href=\"https://img2024.cnblogs.com/blog/510/202512/510-20251227190234460-627552407.png\"></a><a href=\"https://img2024.cnblogs.com/blog/510/202512/510-20251227190235042-730543600.png\"><font face=\"微软雅黑 Light\" size=\"3\"><img alt=\"image\" border=\"0\" height=\"159\" src=\"https://img2024.cnblogs.com/blog/510/202512/510-20251227114212916-1845415606.png\" style=\"display: inline; background-image: none;\" title=\"image\" width=\"833\" /></font></a></p><p><font face=\"微软雅黑 Light\" size=\"3\">从算法实现的角度审视，该公式具有以下显著特征，这些特征直接决定了其作为基准测试的有效性：</font></p><ol><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>极端的计算密集度</b>：算法核心仅包含基本的加、减、乘、除运算，几乎不涉及复杂的内存分配或系统调用（System Calls）。这使得测试结果能够高度纯粹地反映语言运行时的计算开销和指令生成质量 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>可预测的分支逻辑</b>：公式中的符号交替项 (-1)^k 引入了潜在的分支预测（Branch Prediction）挑战。朴素的实现可能会在循环内部使用 <code>if (i % 2 == 0)</code> 判断奇偶性，这将导致大量的 CPU 分支预测失败，从而严重拖慢流水线。而高效的实现通常采用无分支（Branchless）技巧，利用位运算或数学变换来消除条件跳转，这考验了程序员对底层硬件的理解以及编译器的优化智能 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>浮点精度与收敛性</b>：虽然本基准测试明确声明“不关注 pi的精确度”，仅关注运算速度，但浮点数（IEEE 754 标准）的累加特性使得计算顺序对结果有微小影响。编译器是否开启 <code>-ffast-math</code> 等激进优化选项（允许改变浮点结合律）对性能有着数量级的影响，这成为了不同语言实现之间性能差异的主要变量之一 。</font></font></p></li></ol><p><font face=\"微软雅黑 Light\" size=\"3\">基于 2025 年 12 月的最新基准测试数据，我们将 62 种语言实现划分为四个具有显著特征的性能梯队。</font></p><h5><font face=\"微软雅黑 Light\" size=\"3\"> 第一梯队：极限性能层 (&lt; 300ms) —— 编译器的极致</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">这一梯队的语言代表了当前通用 CPU 单核计算的物理极限。它们几乎完全消除了语言本身的运行时开销，性能瓶颈仅在于 CPU 的 ALU 吞吐量和内存带宽。</font></p><p><b><font face=\"微软雅黑 Light\" size=\"3\">深度剖析：</font></b></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>LLVM 的霸权</b>：前 10 名中，C++ (Clang)、Zig、D (LDC)、Rust (Nightly) 均依赖 LLVM 编译器后端。这证明了 LLVM 在现代处理器指令调度和向量化分析上的卓越能力。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>C# 的惊人逆袭</b>：C# (SIMD) 位列第二，仅落后 C++ 不到 4 毫秒。这打破了“托管语言一定慢”的刻板印象。通过.NET 的 <code>System.Numerics.Vectors</code> 库，C# 能够生成与 C++ 几乎相同的 AVX-512 机器码，同时享受 JIT 针对当前硬件动态优化的优势 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>手写 vs 自动</b>：排名第 4 的 C++ (avx2) 是手写 SIMD 代码，却输给了编译器自动优化的 Clang (第 1)。这说明在简单的循环逻辑中，现代编译器对流水线气泡（Pipeline Bubble）和寄存器分配的掌控已经超越了普通人类专家 。</font></font></p></li></ul><h5><font face=\"微软雅黑 Light\" size=\"3\">第二梯队：亚秒级高性能层 (300ms - 1000ms) —— 标量优化的极限</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">这一梯队的语言性能非常出色，通常在 0.5 秒到 1 秒之间。它们大多生成了高效的机器码，但因未开启激进的 SIMD 优化或受到运行时轻微拖累，未能进入第一梯队。</font></p><p><b><font face=\"微软雅黑 Light\" size=\"3\">深度剖析：</font></b></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>Rust 的版本鸿沟</b>：Rust (Stable) 耗时 633ms，而 Nightly 版仅需 234ms。这种巨大的差距源于 Rust 稳定版对 IEEE 754 浮点行为的严格遵守，阻止了编译器进行改变运算顺序的向量化优化。只有在 Nightly 版中显式启用相关特性，才能释放硬件潜力 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>Go 的妥协</b>：Go 语言（888ms）稳定地处于这一梯队。Go 的编译器（gc）设计初衷是编译速度快，而非生成的代码最快。它在自动向量化方面远不如 LLVM 激进，且 Go 运行时包含的调度器和垃圾回收（GC）屏障（Write Barriers）在微观层面引入了额外开销 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>JavaScript 的运行时之战</b>：Bun (928ms) 显著快于 Node.js (1.28s)。Bun 使用的 JavaScriptCore (JSC) 引擎在特定数值计算优化上表现出了相比 Google V8 的优势，证明了现代 JS 引擎的 JIT 能力已能逼近原生代码（仅慢 3-4 倍）。</font></font></p></li></ul><h5><font face=\"微软雅黑 Light\" size=\"3\">第三梯队：解释与混合层 (1s - 5s) —— JIT 的战场</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">这一梯队主要包含动态类型语言的高性能 JIT 实现，或启动开销较大的静态语言环境。</font></p><p><b><font face=\"微软雅黑 Light\" size=\"3\">深度剖析：</font></b></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>PyPy 的惊艳表现</b>：PyPy 将 Python 的运行时间压缩至 1.06 秒，仅比 C# 标准版慢一点。这得益于其 Tracing JIT 技术，能够动态记录循环的执行路径并编译为机器码，消除了动态类型检查的巨大开销 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>NumPy 的陷阱</b>：虽然 NumPy 底层是 C，但在此测试中（2.46s）表现平平。这是因为测试代码使用了 Python 层的 <code>for</code> 循环逐个调用 NumPy 的标量运算。NumPy 的威力在于数组操作（Vectorization），在标量调用场景下，Python 与 C 之间的上下文切换（Function Call Overhead）反而成为了负担。若允许重写为数组操作，NumPy 可能会进入第一梯队，但这违反了“算法一致性”规则 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>Java 的启动与优化</b>：标准 Java (1.70s) 表现中规中矩。HotSpot 编译器虽然强大，但在无法自动向量化浮点循环的情况下，受限于 JVM 的栈操作开销。此外，Java 巨大的启动时间（JVM 初始化、类加载）在短时任务中占比显著。</font></font></p></li></ul><h5><font face=\"微软雅黑 Light\" size=\"3\">第四梯队：纯解释器层 (&gt; 10s) —— 动态类型的代价</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">最慢的梯队，主要是未优化的脚本语言解释器。</font></p><p><b><font face=\"微软雅黑 Light\" size=\"3\">深度剖析：</font></b></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>CPython 的性能瓶颈</b>：标准 Python（CPython）以 86.32 秒垫底，比 C++ 慢了近 400 倍。这归因于其虚拟机架构：每一次加法操作都需要进行对象类型检查（Type Checking）、引用计数更新（Reference Counting）和字节码分发（Dispatch）。对于 10 亿次循环，这些微小的开销累积成了巨大的时间鸿沟 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>解释器的局限</b>：这一梯队的语言（PHP, Ruby, Perl, Raku）在处理紧凑循环时，CPU 主要忙于解释器自身的逻辑（解析字节码、管理栈），而非执行实际的数学运算。</font></font></p></li></ul><h5><font face=\"微软雅黑 Light\" size=\"3\"> C#：.NET Core 的高性能复兴</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">在本次测试中，C# (SIMD) 的表现（227ms）是最令人瞩目的亮点之一。这主要归功于.NET Core（现称为.NET 5/6/7+）引入的硬件内建支持（Hardware Intrinsics）。</font></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>实现细节</b>：通过引用 <code>System.Runtime.Intrinsics</code> 或使用更高级的 <code>System.Numerics.Vector&lt;T&gt;</code>，C# 开发者可以编写出直接映射到 CPU 向量指令的代码。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>JIT 的优势</b>：与 C++ 的 AOT（提前编译）不同，C# 的 JIT 编译器在程序运行时知道当前 CPU 确切支持哪些指令集（是 AVX2 还是 AVX-512）。这使得 C# 程序可以在旧机器上安全运行，而在新机器上自动全速狂奔，无需像 C++ 那样发布多个二进制版本。基准测试结果证明，这种机制在数值计算领域已经完全成熟 。</font></font></p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p>\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 19:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">53</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FFmpeg开发笔记（九十五）国产的开源视频美颜工具VideoEditorForAndroid",
      "link": "https://www.cnblogs.com/aqi00/p/19319684",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19319684\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 12:00\">\n    <span>FFmpeg开发笔记（九十五）国产的开源视频美颜工具VideoEditorForAndroid</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span><span>​</span></span><span id=\"cke_bm_178S\">《FFmpeg开发实战：从零基础到短视频上线》一书的“第 12 章 &nbsp;FFmpeg的移动开发”介绍了如何使用FFmpeg在手机上剪辑视频，方便开发者更好地开发类似剪映那样的视频剪辑软件。那么在Android系统上还有一款国产的开源视频美颜框架VideoEditor-For-Android，通过该框架可以更方便地给视频添加各种滤镜，下面就来介绍如何在App工程中使用VideoEditor-For-Android。</span>\n<p><span id=\"cke_bm_178S\"> VideoEditor-For-Android是一款基于Android硬编码的视频编辑器，包含视频录制、剪切、增加bgm、美白、加滤镜、加水印等多种功能。该框架通过Android的api完成视频采集，通过OpenGL完成视频数据帧的处理，通过MeidaCodec对采集到的视频流进行硬编码。它利用OpenGL完成视频的美白、加滤镜、加水印等功能，利用MediaCodec完成音视频的分离和音频的一些混音处理。<br />\nVideoEditor-For-Android的源码托管地址为https://github.com/qqchenjian318/VideoEditor-For-Android（星星数1.3k），最近版本更新于2021年9月，该版本的压缩包下载地址为https://github.com/qqchenjian318/VideoEditor-For-Android/archive/refs/heads/master.zip。<br />\n由于VideoEditor-For-Android源码的发布时间较早，为了让小海豚版本的Android Studio Dolphin能够打开它们，需要对App工程作如下修改：<br />\n1、升级Gradle版本和SDK版本；<br />\n2、把使用的jdk版本从默认的JDK8改为JDK11；<br />\n3、把Support库迁移为Androidx库；<br />\n4、build.gradle给NDK的指令集过滤器增加arm64-v8a；<br />\n5、App代码在录像和操作存储空间时增加运行时授权校验；<br />\n6、另外修复了若干bug；<br />\n因为上述修改涉及到的内容较多，这里不再一一列出，博主把修改后的App源码上传到了Github，具体地址为https://github.com/aqi00/note/tree/master/VideoEditor-For-Android。大家可以拉取Github上修改好的VideoEditor-For-Android源码，就能用小海豚版本的Android Studio Dolphin导入带Demo界面的VideoEditor-For-Android工程了。<br />\n那么通过Android Studio Dolphin编译VideoEditor-For-Android并安装到真机上，点击【本地视频美颜】后进入视频文件的挑选页面如下图所示：</span></p>\n<div>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"vefa2\" class=\"lazyload\" height=\"407\" width=\"345\" /></span></span></span></span></p>\n\n\n</div>\n<p>先到相册选择一个待加工的视频文件，再点击弹窗右下角的【加滤镜】按钮，App就转到视频的预览界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"vefa3\" class=\"lazyload\" height=\"681\" width=\"317\" /></span></span></span></span></p>\n<p>在视频预览界面左右滑动，可以切换不同的美颜效果，如下图所示：<span class=\"cke_image_resizer_wrapper\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"vefa4\" class=\"lazyload\" height=\"680\" width=\"317\" /></span></span></span></div>\n<p>点击界面右下角的打勾按钮，App就开始执行对应的美颜加工操作。美颜之后的视频片段默认放在App安装路径下的files目录，完整路径为“我的手机/Android/data/com.example.cj.videoeditor/files/video/clip/123456789.mp4”，其中123456789代表一串数字。使用手机自带的文件管理App找到新保存的视频片段，即可观看美颜后的视频效果。</p>\n<p>更多详细的FFmpeg开发知识参见<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\"><a class=\"cke_widget_editable cke_widget_element\" href=\"https://item.jd.com/14020415.html\" rel=\"noopener nofollow\" title=\"《FFmpeg开发实战：从零基础到短视频上线》\">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</span></p>\n\n<span>\n<span>​</span></span>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 12:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">154</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "使用Gradio构建AI前端 - RAG的QA模块",
      "link": "https://www.cnblogs.com/aspnetx/p/19408276",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aspnetx/p/19408276\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 11:28\">\n    <span>使用Gradio构建AI前端 - RAG的QA模块</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文将基于Gradio的Interface，继续构建RAG系统的QA前端页面，对比上一篇对召回测试前端页面的构建，来对比在Gradio下，Blocks和Interface的两种区别。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"使用gradio构建ai前端---rag的qa模块\">使用Gradio构建AI前端 - RAG的QA模块</h1>\n<h2 id=\"摘要\">摘要</h2>\n<p>本文将基于Gradio的Interface，继续构建RAG系统的QA前端页面，对比上一篇对召回测试前端页面的构建，来对比在Gradio下，Blocks和Interface的两种区别。</p>\n<h2 id=\"gradio-interface简介\">Gradio Interface简介</h2>\n<p>Gradio 是一个用于快速创建机器学习和数据科学演示界面的Python库，允许开发者通过简单代码将函数转换为交互式Web应用，无需前端开发经验。<code>gr.Interface</code> 是 Gradio 提供的一种快速创建界面的方式，适用于简单的输入输出场景，采用\"函数驱动\"模式，直接将函数与输入输出组件绑定。</p>\n<h3 id=\"核心特点\">核心特点：</h3>\n<ul>\n<li>结构简单，适合快速原型开发</li>\n<li>输入输出组件按固定布局排列</li>\n<li>基于函数映射，直接将输入传递给函数并展示输出</li>\n</ul>\n<p>综上汇总，主要的特点就是简单，快。</p>\n<h3 id=\"interface-与-blocks-的区别\">Interface 与 Blocks 的区别</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Interface</th>\n<th>Blocks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>复杂度</td>\n<td>简单，适合快速搭建</td>\n<td>灵活，适合复杂界面</td>\n</tr>\n<tr>\n<td>布局控制</td>\n<td>自动布局，结构固定</td>\n<td>完全自定义布局</td>\n</tr>\n<tr>\n<td>交互逻辑</td>\n<td>基于单一函数映射</td>\n<td>支持多函数、事件触发</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>简单输入输出场景</td>\n<td>复杂交互、多步骤流程</td>\n</tr>\n</tbody>\n</table>\n<p>相对来说，Interface的构建方式比Blocks要更简单，代码量更少。<br />\n通过下面的代码，可以看到跟Blocks有明显的区别。</p>\n<h3 id=\"代码示例\">代码示例：</h3>\n<pre><code class=\"language-python\"># 创建Gradio Interface\niface = gr.Interface(\n    fn=run_qa,  # 核心处理函数\n    inputs=[    # 输入组件列表\n        gr.Textbox(\n            label=\"问题\",\n            placeholder=\"请输入您的问题...\",\n            lines=3,\n            info=\"例如: '哪些节假日应该安排休假？' 或 '什么是未成年？'\"\n        ),\n        gr.Slider(\n            label=\"Top-K检索数量\",\n            minimum=1,\n            maximum=10,\n            value=5,\n            step=1,\n            info=\"设置返回的最相似文档数量\"\n        )\n    ],\n    outputs=gr.Markdown(  # 输出组件\n        label=\"回答结果\"\n    ),\n    title=\"🤖 RAG问答系统\",\n    description=\"基于LangChain和Gradio构建的RAG问答系统，使用向量数据库进行知识检索\",\n    examples=[  # 示例问题\n        [\"哪些节假日应该安排休假？\", 5],\n        [\"什么是未成年？\", 3],\n        [\"足球比赛的基本规则是什么？\", 4]\n    ],\n    theme=gr.themes.Soft(),\n    allow_flagging=\"never\"  # 禁用标记功能\n)\n</code></pre>\n<p>下面是构建界面的样子：<br />\n<img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/8622/202512/8622-20251227112605131-876188573.png\" /></p>\n<p>通过以上代码，可以看到在gr.Interface里，首先指定捆绑的是哪一个function，然后在inputs和outputs，依次创建对应的前端组件，并且对应function里的输入参数和返回值。<br />\n这段代码调用项目里已经封装好的LC_RAG_03_QA.py里的方法。</p>\n<h3 id=\"关键区别点\">关键区别点：</h3>\n<p>对比上一篇，这里汇总了Interface方式和Blocks两种方式的区别。</p>\n<ol>\n<li>\n<p><strong>布局控制</strong>：</p>\n<ul>\n<li>Interface：自动排列输入输出，无需手动控制布局</li>\n<li>Blocks：通过 <code>gr.Row()</code>、<code>gr.Column()</code> 等手动控制组件布局</li>\n</ul>\n</li>\n<li>\n<p><strong>事件处理</strong>：</p>\n<ul>\n<li>Interface：自动关联输入输出和处理函数</li>\n<li>Blocks：需要显式通过 <code>.click()</code> 等方法绑定事件</li>\n</ul>\n</li>\n<li>\n<p><strong>灵活性</strong>：</p>\n<ul>\n<li>Interface：适合简单场景，代码量少</li>\n<li>Blocks：适合复杂界面，支持条件显示、多步骤交互等高级功能</li>\n</ul>\n</li>\n<li>\n<p><strong>结构组织</strong>：</p>\n<ul>\n<li>Interface：通过参数配置界面元素</li>\n<li>Blocks：使用上下文管理器（<code>with</code> 语句）组织界面结构</li>\n</ul>\n</li>\n</ol>\n<p>在本案例中，使用 <code>gr.Interface</code> 代码更简洁高效。如果需要更复杂的交互（如多步骤处理、条件显示组件等），则应选择 <code>gr.Blocks</code>。<br />\n所以如果是对模型功能的评估，建议选择gr.Interface，如果是做原型设计，建议选择gr.Blocks。</p>\n<p>本文项目代码可以在以下仓库里找到：<br />\n<a href=\"https://github.com/microsoftbi/Langchain_DEMO/tree/main/RAG\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microsoftbi/Langchain_DEMO/tree/main/RAG</a><br />\n此篇对应的代码是：LC_RAG_07c_Gradio.py</p>\n<p>这里再补充一个快速的方法，就是借助AI开发工具，比如TRAE，以下是我用的提示词，仅供参考：</p>\n<pre><code class=\"language-Prompt\">在当前python文件中，编写一个QA的前端界面，前端框架使用Gradio，不要使用blocks的方式构建页面，直接使用interface的方式来构建，使用的方法，调用LC_RAG_03_QA.py里的answer_question方法。\n</code></pre>\n<p>虽然在我使用的过程中，代码无法一次通过，但基本上通过一次反馈就可以修补成功，从而省下了这部分代码的工作量。</p>\n<details>\n以下是代码的全部内容，点击展开。\n<pre><code class=\"language-Python\">import gradio as gr\nfrom LC_RAG_03_QA import answer_question\n\ndef run_qa(question, top_k=5):\n    \"\"\"运行QA并返回结果\"\"\"\n    try:\n        answer, sources = answer_question(\n            question=question,\n            top_k=top_k,\n            vectorstore_dir=\"./RAG/chroma_db\",\n            embedding_model=\"text-embedding-v4\"\n        )\n        \n        # 格式化结果\n        result = f\"# 🎯 答案\\n\\n{answer}\\n\"\n        \n        if sources:\n            result += \"\\n# 📚 参考来源\\n\"\n            for source in sources:\n                result += f\"- {source}\\n\"\n        \n        return result\n    except Exception as e:\n        return f\"❌ 错误: {str(e)}\"\n\n# 创建Gradio Interface\niface = gr.Interface(\n    fn=run_qa,\n    inputs=[\n        gr.Textbox(\n            label=\"问题\",\n            placeholder=\"请输入您的问题...\",\n            lines=3,\n            info=\"例如: '哪些节假日应该安排休假？' 或 '什么是未成年？'\"\n        ),\n        gr.Slider(\n            label=\"Top-K检索数量\",\n            minimum=1,\n            maximum=10,\n            value=5,\n            step=1,\n            info=\"设置返回的最相似文档数量\"\n        )\n    ],\n    outputs=gr.Markdown(\n        label=\"回答结果\"\n    ),\n    title=\"🤖 RAG问答系统\",\n    description=\"基于LangChain和Gradio构建的RAG问答系统，使用向量数据库进行知识检索\",\n    examples=[\n        [\"哪些节假日应该安排休假？\", 5],\n        [\"什么是未成年？\", 3],\n        [\"足球比赛的基本规则是什么？\", 4]\n    ],\n    theme=gr.themes.Soft(),\n    allow_flagging=\"never\"\n)\n\n# 启动应用\nif __name__ == \"__main__\":\n    iface.launch(\n        server_name=\"0.0.0.0\",\n        server_port=7861,\n        share=False,\n        debug=False\n    )\n</code></pre>\n</details>\n</div>\n<div id=\"MySignature\">\n    <p>&nbsp;</p>\n<p>---------------------------------------------------------------</p>\n<p style=\"margin: 0in 0in 10pt;\">aspnetx<span style=\"font-family: SimSun;\">的</span>BI<span style=\"font-family: SimSun;\">笔记系列索引：</span></p>\n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/02/25/2931603.html\" target=\"_blank\">使用SQL Server Analysis Services数据挖掘的关联规则实现商品推荐功能</a></p> \n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/03/24/2978347.html\" target=\"_blank\">一起玩转SQL Server 2012 下的分析服务</a></p> \n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/04/05/3000448.html\" target=\"_blank\">使用SQL Server分析服务定位目标用户  </a></p> \n\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>---------------------------------------------------------------<br /></p>\n<p>来自<a href=\"http://www.cnblogs.com/\" target=\"_blank\">博客园</a>的<a href=\"http://aspnetx.cnblogs.com/\" target=\"_blank\">aspnetx</a><font color=\"white\">宋卫东</font></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 11:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aspnetx\">哥本哈士奇(aspnetx)</a>&nbsp;\n阅读(<span id=\"post_view_count\">68</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19406862",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19406862\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 23:11\">\n    <span>一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>在AI技术迅猛发展的当下，高效且精准的提示词成为与AI模型有效交互的关键。今天大姚给大家分享一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230859325-1349637768.png\" /></p>\n<h2><span>工具介绍</span></h2>\n<p><span>PromptPilot 是由字节跳动推出的一款专注于 AI 提示词优化与提示词生成的实用工具。该工具旨在帮助用户更高效地生成和优化 AI 提示词，提升与 AI 模型的交互效率和质量。通过 PromptPilot，用户可以轻松地创建、调试和管理提示词，以满足多样化的应用场景需求。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong><span>在线访问地址：<span class=\"wx_text_underline\">https://promptpilot.volcengine.com</span></span></strong></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230911909-2106687661.png\" /></p>\n<h2><span>应用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>内容创作</strong><span>：在自媒体、广告、营销等领域，PromptPilot 可帮助创作者快速生成吸引人的文案提示词，提升内容质量和吸引力。</span></li>\n<li><strong>数据分析</strong><span>：在数据分析场景中，PromptPilot 可辅助分析师生成精准的查询提示词，提高数据检索和分析效率。</span></li>\n<li><strong>客户服务</strong><span>：在客户服务领域，PromptPilot 可用于生成自动化回复的提示词，提升客户响应速度和满意度。</span></li>\n<li><strong>教育行业</strong><span>：教师和学生可利用 PromptPilot 生成教学和学习相关的提示词，促进知识的有效传递和学习效果的提升。</span></li>\n</ul>\n<h2><span>提示词生成</span></h2>\n<h3><span>任务描述：</span></h3>\n<pre><span><code><span>给我写一个企业优秀员工获奖感言。<br /></span></code></span></pre>\n<h3><span>生成后的 Prompt：</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230930602-605100114.png\" /></p>\n<p>&nbsp;</p>\n<pre><span><code># 获奖感言创作指南<br /><br />## 一、身份设定<br /><span>你是企业行政部门的资深文案专员，负责为获奖员工撰写符合公司文化的正式获奖感言。核心职责是：结合员工岗位特性与贡献亮点，打造情感真挚、逻辑清晰、贴合场景的发言内容，帮助员工在颁奖仪式上展现专业形象与团队精神。<br /><br />## 二、创作准则<br />### 必做事项<br /><span>1. 必须包含获奖员工姓名、所获奖项全称、公司名称<br /><span>2. 必须突出员工岗位核心职责与关键贡献数据<br /><span>3. 必须体现对公司、团队、家人的感谢层次<br /><span>4. 必须包含对未来工作的承诺与展望<br /><br />### 约束条件<br /><span>1. 禁止使用夸张不实的表述，所有贡献需基于提供的事实<br /><span>2. 禁止出现敏感词汇或不当表述<br /><span>3. 禁止遗漏指定的感谢对象<br /><span>4. 禁止超过规定字数限制<br /><br />## 三、变量说明<br /><span>&lt;员工姓名&gt;{{EMPLOYEE_NAME}}&lt;/员工姓名&gt; - 获奖员工的完整姓名<br /><span>&lt;奖项类型&gt;{{AWARD_TYPE}}&lt;/奖项类型&gt; - 具体获奖名称（如：年度优秀员工、季度创新之星）<br /><span>&lt;公司名称&gt;{{COMPANY_NAME}}&lt;/公司名称&gt; - 员工所在企业全称<br /><span>&lt;工作职责&gt;{{WORK_DUTIES}}&lt;/工作职责&gt; - 员工日常工作内容概述<br /><span>&lt;核心贡献&gt;{{KEY_CONTRIBUTIONS}}&lt;/核心贡献&gt; - 员工获奖的关键业绩或突出表现<br /><span>&lt;感谢对象&gt;{{THANKS_OBJECTS}}&lt;/感谢对象&gt; - 需要特别致谢的个人或团队<br /><br />## 四、创作流程<br />### 第一步：内容架构搭建<br /><span>1. 开场问候：礼貌性称呼在场人员<br /><span>2. 获奖致谢：表达获奖的荣幸与激动心情<br /><span>3. 工作回顾：简述岗位价值与核心贡献<br /><span>4. 感恩环节：分层次感谢公司、团队、家人<br /><span>5. 未来展望：承诺未来工作方向与目标<br /><br />### 第二步：细节填充<br /><span>1. 将 &lt;员工姓名&gt;{{EMPLOYEE_NAME}}&lt;/员工姓名&gt; 自然融入开场与落款<br /><span>2. 准确引用 &lt;奖项类型&gt;{{AWARD_TYPE}}&lt;/奖项类型&gt; 全称<br /><span>3. 结合 &lt;工作职责&gt;{{WORK_DUTIES}}&lt;/工作职责&gt; 说明岗位价值<br /><span>4. 用数据化语言呈现 &lt;核心贡献&gt;{{KEY_CONTRIBUTIONS}}&lt;/核心贡献&gt;<br /><span>5. 按重要性排序提及 &lt;感谢对象&gt;{{THANKS_OBJECTS}}&lt;/感谢对象&gt;<br /><br />### 第三步：风格润色<br /><span>1. 语言风格：正式中带有温度，避免过于口语化<br /><span>2. 情感表达：控制情绪尺度，保持专业得体<br /><span>3. 时间控制：按3分钟发言长度调整内容详略（约500-600字）<br /><br />## 五、输出规范<br />### 内容结构<br /><span>1. 标题：[奖项名称]获奖感言<br /><span>2. 称呼：尊敬的各位领导、亲爱的同事们：<br /><span>3. 正文：按创作流程顺序展开<br /><span>4. 落款：[员工姓名] [日期]<br /><br />### 格式要求<br /><span>1. 使用标准宋体四号字，1.5倍行距<br /><span>2. 关键贡献部分加粗显示<br /><span>3. 感谢对象单独分段<br /><span>4. 结尾部分需包含对公司未来的美好祝愿<br /><br />### 质量标准<br /><span>1. 符合公司文化价值观<br /><span>2. 突出个人贡献同时体现团队精神<br /><span>3. 避免空话套话，用具体事例支撑<br /><span>4. 语言流畅，逻辑清晰，情感真挚<br /><br />## 六、创作示例<br /><span>（此处省略示例内容，实际创作时需根据变量填充）<br /><br /><span>请严格按照以上要求，结合提供的变量信息，创作一篇完整的获奖感言。<br /><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>\n<h2><span>调试 Prompt</span></h2>\n<h3><span>文本理解</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230958750-1911894887.png\" /></p>\n<h3><span>视觉理解</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231016417-194421412.png\" /></p>\n<h3><span>多轮对话</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231026956-1766318256.png\" /></p>\n<h2><span>优化 Prompt</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231045050-1953776592.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231052086-1099494036.png\" /></p>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 23:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">225</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "go-zero rest 源码学习笔记",
      "link": "https://www.cnblogs.com/xingzheanan/p/19404672",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xingzheanan/p/19404672\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 22:19\">\n    <span>go-zero rest 源码学习笔记</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<hr />\n<h1 id=\"概述\">概述</h1>\n<p><code>go-zero</code> 基于 <code>net/http</code> 标准库实现了一套 <code>rest</code> web 框架。在使用 <code>goctl</code> 快速开发的同时，也需要了解 <code>go-zero</code> 内部做了什么。本文结合 <a href=\"https://zeromicro.github.io/go-zero.dev/docs/component/rest\" rel=\"noopener nofollow\" target=\"_blank\">go-zero rest</a>学习其中的源码，力图做到知其所以然。</p>\n<h1 id=\"源码\">源码</h1>\n<h2 id=\"流程图\">流程图</h2>\n<p><img alt=\"image\" class=\"lazyload\" height=\"650\" width=\"640\" /></p>\n<p>在阅读源码之前，先看下流程图有个印象。从流程图大致可以看出来：</p>\n<ul>\n<li>go-zero 会创建路由组，其中按顺序注册了几类 handler（中间件），最后在 business handler 处理业务逻辑。</li>\n</ul>\n<p>大致有个印象后开始源码走读。</p>\n<h2 id=\"源码走读\">源码走读</h2>\n<p>启动 api 服务：</p>\n<pre><code class=\"language-go\">func main() {  \n    ...\n    server := rest.MustNewServer(c.RestConf)  \n    defer server.Stop()  \n  \n    ctx := svc.NewServiceContext(c)  \n    handler.RegisterHandlers(server, ctx)  \n  \n    fmt.Printf(\"Starting server at %s:%d...\\n\", c.Host, c.Port)  \n    server.Start()  \n}\n</code></pre>\n<p>启动服务主要做了三件事：</p>\n<ul>\n<li>创建服务端 server</li>\n<li>注册 handler 到 server</li>\n<li>启动服务端 server</li>\n</ul>\n<p>按顺序介绍。</p>\n<h3 id=\"创建服务端-server\">创建服务端 server</h3>\n<pre><code class=\"language-go\">func MustNewServer(c RestConf, opts ...RunOption) *Server {  \n    // NewServer 创建 server\n    server, err := NewServer(c, opts...)  \n    if err != nil {  \n       logx.Must(err)  \n    }  \n  \n    return server  \n}\n\nfunc NewServer(c RestConf, opts ...RunOption) (*Server, error) {\n\t// c.SetUp 启动 Prometheus，tracing, profiling 等服务\n    if err := c.SetUp(); err != nil {  \n       return nil, err  \n    }  \n  \n    server := &amp;Server{  \n       ngin:   newEngine(c),  \n       router: router.NewRouter(),  \n    }  \n  \n    ...\n    return server, nil  \n}\n</code></pre>\n<p>创建 server 实际创建的是 server 的 engine 和 router。</p>\n<p>engine 主要结构如下：</p>\n<pre><code class=\"language-go\">type engine struct {  \n    // server 的配置\n    conf   RestConf  \n    routes []featuredRoutes  // 业务路由\n    // 调用链\n    chain                chain.Chain \n    // 中间件 \n    middlewares          []Middleware  \n    ...\n}\n\nfunc newEngine(c RestConf) *engine {  \n    svr := &amp;engine{  \n       conf:    c,  \n       timeout: time.Duration(c.Timeout) * time.Millisecond,  \n    }\n    ...\n}\n</code></pre>\n<p>router 结构如下：</p>\n<pre><code class=\"language-go\">func NewRouter() httpx.Router {  \n    return &amp;patRouter{  \n       trees: make(map[string]*search.Tree),  \n    }  \n}\n\ntype Router interface {  \n    http.Handler  \n    Handle(method, path string, handler http.Handler) error  \n    SetNotFoundHandler(handler http.Handler)  \n    SetNotAllowedHandler(handler http.Handler)  \n}\n</code></pre>\n<p><code>patRouter</code> 包含路由信息，其实现了 <code>Router</code> 接口。</p>\n<p>创建了 server 后还需要注册路由 handler 到 server，这样服务端才能根据路由找到对应的 handler 处理。</p>\n<h3 id=\"注册路由-handler\">注册路由 handler</h3>\n<pre><code class=\"language-go\">func RegisterHandlers(server *rest.Server, serverCtx *svc.ServiceContext) {  \n    // server.AddRoutes 注册路由 handler\n    server.AddRoutes(  \n       []rest.Route{  \n          {  \n             Method:  http.MethodGet,  \n             Path:    \"/ping\",  \n             Handler: pingHandler(serverCtx),  \n          },  \n       },  \n    )\n}\n\nfunc (s *Server) AddRoutes(rs []Route, opts ...RouteOption) {  \n    // 自定义的业务路由将被封装到 featuredRoutes 对象\n    r := featuredRoutes{  \n       routes: rs,  \n    }  \n    for _, opt := range opts {  \n       opt(&amp;r)  \n    }  \n    \n    // 将 featuredRoutes 添加到 Server.engine\n    s.ngin.addRoutes(r)  \n}\n\nfunc (ng *engine) addRoutes(r featuredRoutes) {  \n    ...\n    // 实际是将路由组添加到 engine.routes 中  \n    ng.routes = append(ng.routes, r) \n}\n</code></pre>\n<p>业务路由注册完，接下来将进入启动 server，这是需要关注的重点。</p>\n<h3 id=\"启动-server\">启动 server</h3>\n<pre><code class=\"language-go\">func (s *Server) Start() {  \n    // 调用 Server.engine.start 启动服务端 server\n    handleError(s.ngin.start(s.router))  \n}\n\nfunc (ng *engine) start(router httpx.Router, opts ...StartOption) error {     // engine.bindRoutes 绑定路由到 router\n    if err := ng.bindRoutes(router); err != nil {  \n       return err  \n    }  \n\n    ...\n    return internal.StartHttps(ng.conf.Host, ng.conf.Port, ng.conf.CertFile,  \n       ng.conf.KeyFile, router, opts...)  \n}\n\nfunc (ng *engine) bindRoutes(router httpx.Router) error {  \n    // engine.routes \n    for _, fr := range ng.routes {  \n       // 绑定 rest.featuredRoutes \n       if err := ng.bindFeaturedRoutes(router, fr, metrics); err != nil { \n          return err  \n       }  \n    }  \n  \n    return nil  \n}\n\nfunc (ng *engine) bindFeaturedRoutes(router httpx.Router, fr featuredRoutes, metrics *stat.Metrics) error {  \n    ...\n    for _, route := range fr.routes {  \n       if err := ng.bindRoute(fr, router, metrics, route, verifier); err != nil {  \n          return err  \n       }  \n    }  \n  \n    return nil  \n}\n\nfunc (ng *engine) bindRoute(fr featuredRoutes, router httpx.Router, metrics *stat.Metrics,  \n    route Route, verifier func(chain.Chain) chain.Chain) error {  \n    // engine.chain，初始化为 nil\n    chn := ng.chain  \n    if chn == nil {  \n       // engine.buildChainWithNativeMiddlewares 注册自带中间件到 engine.chain\n       chn = ng.buildChainWithNativeMiddlewares(fr, route, metrics)  \n    }  \n  \n    // 添加 AuthHandler 到 engine.chain 中\n    chn = ng.appendAuthHandler(fr, chn, verifier)  \n  \n    // 将自定义中间件注册到 engine.chain\n    for _, middleware := range ng.middlewares {  \n       chn = chn.Append(convertMiddleware(middleware))  \n    }  \n    \n    // engine.chain.ThenFunc 将 handler 串联成 handler\n    handle := chn.ThenFunc(route.Handler)  \n  \n    return router.Handle(route.Method, route.Path, handle)  \n}\n</code></pre>\n<p>启动 server 的重点在 <code>engine.bindRoute</code>。<br />\n其中，<code>engine.buildChainWithNativeMiddlewares</code> 注册 <code>go-zero</code> 自带中间件：</p>\n<pre><code class=\"language-go\">func (ng *engine) buildChainWithNativeMiddlewares(fr featuredRoutes, route Route,  \n    metrics *stat.Metrics) chain.Chain {  \n    chn := chain.New()\n    ...\n    // MaxConns 用于并发控制\n    if ng.conf.Middlewares.MaxConns {  \n        chn = chn.Append(handler.MaxConnsHandler(ng.conf.MaxConns))  \n    }  \n    if ng.conf.Middlewares.Breaker {  \n        chn = chn.Append(handler.BreakerHandler(route.Method, route.Path, metrics))  \n    }\n    ...\n}\n</code></pre>\n<p>类似的，自定义中间件通过 <code>chn.Append(convertMiddleware(middleware))</code> 注册到 <code>engine.chain</code> 中。</p>\n<p>接着调用 <code>chain.ThenFunc</code> 串联中间件成 <code>handler</code>：</p>\n<pre><code class=\"language-go\">func (c chain) ThenFunc(fn http.HandlerFunc) http.Handler {  \n    ...\n    return c.Then(fn)  \n}\n\nfunc (c chain) Then(h http.Handler) http.Handler {  \n    if h == nil {  \n       h = http.DefaultServeMux  \n    }  \n  \n    // 这段代码很有意思，它将所有中间件按顺序串联起来组成一个 handler\n    // 调用这个 handler 处理时会经过后续一系列的中间件，最终到业务 handler 处理\n    // 具体可参考 https://github.com/zeromicro/go-zero/blob/master/rest/chain/chain.go#L81\n    for i := range c.middlewares {  \n       h = c.middlewares[len(c.middlewares)-1-i](h)  \n    }  \n  \n    return h  \n}\n</code></pre>\n<p>最后将该 handler 和路由信息注册到 <code>router</code> 中，后续服务端根据请求在 <code>router</code> 中查找对应的 <code>handler</code> 处理。</p>\n<pre><code class=\"language-go\">func (pr *patRouter) Handle(method, reqPath string, handler http.Handler) error {  \n    ...\n    \n    tree, ok := pr.trees[method]  \n    if ok {  \n       return tree.Add(cleanPath, handler)  \n    }  \n  \n    tree = search.NewTree()  \n    pr.trees[method] = tree  \n    return tree.Add(cleanPath, handler)  \n}\n</code></pre>\n<p>详细流程如下图：</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"570\" width=\"661\" /></p>\n<h1 id=\"小结\">小结</h1>\n<p>本文介绍了 go-zero rest 的源码是怎么处理请求的。从源码也可以看出每个请求背后是一系列中间件 handler 在处理，并且 server 启动了 Prometheus，Trace 等服务负责监控，链路追踪等，使得开发微服务时只需要关注业务逻辑即可，非常方便。</p>\n<h1 id=\"参考资料\">参考资料</h1>\n<ul>\n<li><a href=\"https://zeromicro.github.io/go-zero.dev/docs/component/rest\" rel=\"noopener nofollow\" target=\"_blank\">go-zero rest</a></li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/chain-of-responsibility/go/example\" rel=\"noopener nofollow\" target=\"_blank\">Go 责任链模式</a></li>\n</ul>\n<hr />\n\n</div>\n<div id=\"MySignature\">\n    芝兰生于空谷，不以无人而不芳。\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 22:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xingzheanan\">胡云Troy</a>&nbsp;\n阅读(<span id=\"post_view_count\">85</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "红米AX6 扩容 刷Uboot+openwrt 经历",
      "link": "https://www.cnblogs.com/sollong/p/19410157",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sollong/p/19410157\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 22:04\">\n    <span>红米AX6 扩容 刷Uboot+openwrt 经历</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>仅仅做一次刷入的简单记录，可抄作业</strong></p>\n<h2 id=\"参考文章视频\">参考文章/视频：</h2>\n<p>1.视频-红米AX6 Openwrt刷机教程（解锁步骤AX6000、AX9000通用）<a href=\"https://www.bilibili.com/video/BV1q94y1f7fj\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV1q94y1f7fj</a></p>\n<p>2.视频-玩透红米AX6 OPENWRT扩容刷机及Uboot刷机 <a href=\"https://www.bilibili.com/video/BV19Y4y1e7ko\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV19Y4y1e7ko</a></p>\n<p>3.文章-[红米AX6] 2025年入手AX6后刷机笔记 <a href=\"https://www.right.com.cn/forum/thread-8455880-1-1.html\" rel=\"noopener nofollow\" target=\"_blank\">https://www.right.com.cn/forum/thread-8455880-1-1.html</a></p>\n<p>4.文章-[红米AX6] 【2025-06-28】红米AX6开源NSS固件 <a href=\"https://www.right.com.cn/forum/thread-8417590-1-2.html\" rel=\"noopener nofollow\" target=\"_blank\">https://www.right.com.cn/forum/thread-8417590-1-2.html</a></p>\n<p>5.文章-小米/红米ax路由器全系万能一键ssh工具(支持ax6, ax6s, ax5jdc, ax3000, CR880X) <a href=\"https://www.right.com.cn/forum/thread-8374973-1-1.html\" rel=\"noopener nofollow\" target=\"_blank\">https://www.right.com.cn/forum/thread-8374973-1-1.html</a></p>\n<h2 id=\"整体思路\">整体思路</h2>\n<p>1.解锁SSH 2.改分区表 3.刷uboot 4.刷openwrt</p>\n<h2 id=\"步骤1-解锁ssh\">步骤1 解锁SSH</h2>\n<p>参考 参考文章5 可一键解锁SSH 或者 参考 参考视频1 的方式进行解锁<br />\n推荐前一种方法，很方便</p>\n<h2 id=\"步骤2-改分区表刷uboot\">步骤2 改分区表+刷uboot</h2>\n<p>教程参考的 参考视频2 刷uboot章节<br />\n分区文件与uboot映像使用的 参考文章4中帖子附件<br />\n[红米AX6大分区 天灵UBOOT.zip]:<br />\n-ax6-uboot-stock.bin //uboot映像<br />\n-ax6-mibib-stock.bin //扩容分区表</p>\n<h2 id=\"步骤3-刷openwrtimmortalwrt\">步骤3 刷openwrt/immortalwrt</h2>\n<p>教程参考 参考视频2, 参考文章3<br />\n可以选择自己想要的openwrt或者immortalwrt映像<br />\n这里选择的是参考文章4中的固件 immortalwrt-qualcommax-ipq807x-redmi_ax6-stock-squashfs-factory.ubi</p>\n<p>文章有待完善，随缘更新</p>\n<p><strong>最后感谢各路大佬开发/编译/整理</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 22:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sollong\">Sollong</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}