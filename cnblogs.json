{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "并查集及其应用专题--全网最详细版",
      "link": "https://www.cnblogs.com/hicode002/p/-/union_set",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hicode002/p/-/union_set\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 19:57\">\n    <span>并查集及其应用专题--全网最详细版</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"并查集\">并查集</h1>\n<p>并查集是用来查找和合并集合关系的<br />\n这个集合必须是不交集<br />\n支持查找和合并两种操作，修改后可以支持删除单个元素并分离集合。<br />\n使用动态开点线段树还可以实现可持久化并查集</p>\n<p>来自 <a href=\"https://oi-wiki.org/ds/dsu/\" rel=\"noopener nofollow\" target=\"_blank\">https://oi-wiki.org/ds/dsu/</a></p>\n<p>并查集类似于树，普通并查集是无向的，但是加权并查集是可以做到有向的，详见NOI2001食物链</p>\n<h2 id=\"查找操作查找两个元素是否在同一集合\">查找操作：查找两个元素是否在同一集合</h2>\n<p>假设有一个集合，元素是{1,2,3}<br />\n还有一个集合元素是{4,5,6}<br />\n现在查找2和4在不在同一个集合，则需要枚举2所在或4所在集合所有元素直到找到4或到最后也没有4<br />\n太慢了，有一个更好的方法，如果我们随便选一个集合中的某个元素作为该集合的代表元素，<br />\n其它该集合中的元素都指向这个元素<br />\n当查找元素所在集合时，只要找到这个元素的指向的元素的最顶级元素即根，这个根就是代表节点<br />\n最后判断这两个元素的根是否相同即可<br />\n这里遇到一个问题，就是这个根元素怎么标记呢，可以让它所指向的元素是自己，这样询问时只要遇到指向元素是自己的元素，那么说明找到根了，即可停止<br />\n我们把这个指向的元素叫做这个元素的父亲<br />\n注意树不只有两层，因为在合并操作时集合被合并，原先两个集合的根中有一个变成了子节点，此时层数会增加，而这个代表元素是整棵树的根，这个点的父亲只是它的原来的集合的根，因为集合已经合并，所以判断两个元素是否在同一集合中时要用整棵树的根，因此要递归寻找这个元素的父亲直到元素的父亲是自身时停止寻找并返回该元素。当然这个过程可以循环解决，只需要定义临时变量为该元素的父亲，然后这个变量不断等于这个变量的父亲，直到其父亲等于自身为止，然后返回该变量即可<br />\n举例：<br />\n假设集合1以3为根，集合2以6为根，则<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260124162032821-1549875642.png\" /><br />\n2和4的根分别是3和6，不等，所以不在一个集合<br />\n1和3的根分别是3和3，相等，所以在一个集合。</p>\n<h2 id=\"合并操作\">合并操作：</h2>\n<p>把两个元素 所在集合 合并为一个集合，合并后两个集合等同于在一个大集合中，此时一个元素所在集合的根要变成子节点，另一个作为大集合的根。<br />\n如何合并：<br />\n很简单，先查找两个元素的根，然后把一个根的父亲改为另一个根，这样就完成了合并 ，但是如果两个元素的根相同说明在一个集合就直接返回不用合并<br />\n例：<br />\n以查找时为例<br />\n合并前：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260124162032821-1549875642.png\" /><br />\n假设新根是6<br />\n合并后：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260124162149379-1024618492.png\" /><br />\n再查找2和4：<br />\n2的父亲是3，3的父亲是6，6的父亲是6<br />\n4的父亲是6<br />\n在一个集合<br />\n注意合并时要把一个根直接接到另一个根上，而不是接到子节点上！！</p>\n<h2 id=\"路径压缩\">路径压缩</h2>\n<p>在查找时我们不关心这个元素的父亲，只要这个元素通过找父亲能找到根即可，所以每次查找后把查找的这条链上的元素的父亲直接改为根，这样不影响查找，而且减少以后查找的次数（减小树高）<br />\n递归时只要返回时return fa[x]=find(fa[x])即可，这样会递归到最后找到根把父亲从上往下回溯着改<br />\n循环法要找到根后再开一个循环，先让循环变量=它的父亲，然后把它的父亲改为根，直到 父亲=父亲 时停止（到根了），这是自下往上的。<br />\n但是一次只能保证这条链上的，不能是全树都改好，所以后面删除元素时比较麻烦</p>\n<h2 id=\"按秩合并启发式合并\">按秩合并：(启发式合并）</h2>\n<p>在合并时我们要将其中一个元素所在集合的根变为子节点，另一个变为新根，可是哪一个变为子节点呢？<br />\n显然将尺寸小的接到尺寸大的集合上更好，这样查找大的时还是那个复杂度，可反之要花更多的时间，但是尺寸小的集合造成影响小，所以要把尺寸小的接到尺寸大的集合上<br />\n但是尺寸是什么呢？<br />\n尺寸既可以是一个集合的元素个数即点数，也可以是树的高度，它们优化的效果是等价的<br />\n如果以点数为尺寸，那么合并时把点数小的根父亲等于点数大的根，点数大的根的点数+=点数小的根的点数，这个叫做启发式合并，其他数据结构也常用<br />\n如果以高度为尺寸，那么合并时把高度小的根父亲等于高度大的根，但是高度不变，为什么？ 这个叫做按秩合并，不是很常用<br />\n只要a的高度小于b，因为高度是整数，所以a的高度比b至少少一，把a接到b的下面，此时这个高度不能超过b<br />\n什么时候高度改变？当a和b高度相等时，可以随便接，但是无论怎么接高度都增加1<br />\n假如a接在b下面，那么b的这个子树的高度为b，而b的其他子树中最大的高度是b-1，因此b的高度变为b+1!</p>\n<h2 id=\"复杂度\">复杂度：</h2>\n<p><span class=\"math inline\">\\(n\\)</span>个元素，<span class=\"math inline\">\\(m\\)</span>次操作（查找或合并）<br />\n空间复杂度：<br />\n由于每个元素都有一个父亲，所以<span class=\"math inline\">\\(fa\\)</span>数组大小是<span class=\"math inline\">\\(n\\)</span>，故空间复杂度<span class=\"math inline\">\\(O（n）\\)</span><br />\n时间复杂度：<br />\n既使用路径压缩，又使用按秩合并:<br />\n每个操作平均时间复杂度<span class=\"math inline\">\\(O(α(n))\\)</span><br />\n<span class=\"math inline\">\\(α\\)</span>是反阿克曼函数，近似于常数</p>\n<p>总操作平均复杂度<span class=\"math inline\">\\(O(mα(n))\\)</span><br />\n只使用路径压缩：<br />\n总操作平均复杂度<span class=\"math inline\">\\(O(mα(n))\\)</span><br />\n总操作最坏复杂度<span class=\"math inline\">\\(O(m log⁡n )\\)</span><br />\n只使用按秩合并：<br />\n总操作平均复杂度<span class=\"math inline\">\\(O(m log⁡n )\\)</span></p>\n<h2 id=\"删除操作\">删除操作：</h2>\n<p>修改后的并查集支持单个元素的删除<br />\n但是需要注意的是删除不是说删除这个点和这个点所连的点，而是仅仅删除这个点，其余与他相连的点仍然在原并查集中，但这个点独立成一个集合<br />\n在完美形态的并查集中，每个节点的父亲都是根，此时删除一个节点就是把这个节点的父亲改为自己，这样不影响其他节点，但是实际上路径压缩只能将这条链上的节点的父亲改为根，所以实际并查集形态不可估计<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260124162414092-577349486.png\" /><br />\n删除2后<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260124162431589-133329972.png\" /><br />\n那么我们可以用盒子来代替这个真正的节点去合并，而我们真正的每一个节点都指向每一个盒子<br />\n详细：<br />\n每一个节点都对应一个盒子，每个节点的父亲起初都是对应的一个新盒子<br />\n当我们合并集合时，我们只合并节点指向的盒子的所在集合，仍然符合按秩合并<br />\n当我们删除时把节点的父亲改为一个新的，从未使用过的盒子，原盒子保持空，这样原来集合的关系可以通过这个空盒子保留<br />\n当我们查找时查找节点所在盒子的根<br />\n仍然可以用路径压缩<br />\n一旦这个节点被删除，就到了新盒子，此时这个节点和原来的集合并不在一个集合中，所以删除有效<br />\n删除的节点再和别的节点合并改变的是它新盒子的集合<br />\n与原来集合无关<br />\n还可以有还原操作，就是删除后把这个节点还原到它最近被删除的集合中，显然可以再合并 ，但也可以数组记录每个节点上一次被删除的盒子编号，然后把这个节点的指向改为上一次被删除的盒子编号，这样就完全还原上一次这个节点的形态，不需要合并了</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint fa[10006],fa1[90006],t=10007,lasts[10006];\t\ninline int finds(int x ){\n\tif(fa1[x]==x)return x;\n\treturn fa1[x]=finds(fa1[x]);\n}\ninline void inserts(int x,int y){\n\tint a=finds(x),b=finds(y);\n\tif(a==b)return;\n\tfa1[a]=b;\n}\ninline void deletes(int x){\n\tlasts[x]=fa[x];\n\tfa[x]=t;\n\t++t;\n}\ninline void restore(int x){\n\tfa[x]=lasts[x];\n}\nint main(){\n\tmemset(fa,-1,sizeof fa);\n\tmemset(lasts,0,sizeof lasts);\n\tfor(int i=0;i&lt;90006;++i){\n\t\tfa1[i]=i;\n\t}\n\tint m;\n\tcin&gt;&gt;m;\n\tfor(int i=0;i&lt;m;++i){\n\t\tchar op ;int x,y;\n\t\tcin&gt;&gt;op;\n\t\tif(op=='U'){\n\t\t\tcin&gt;&gt;x&gt;&gt;y;\n\t\t\tif(fa[x]==-1)fa[x]=x;\n\t\t\tif(fa[y]==-1)fa[y]=y;\n\t\t\tinserts(fa[x],fa[y]);\n\t\t\t\n\t\t}else if(op=='F'){\n\t\t\tcin&gt;&gt;x&gt;&gt;y;\n\t\t\tif(fa[x]==-1)fa[x]=x;\n\t\t\tif(fa[y]==-1)fa[y]=y;\n\t\t\tif(finds(fa[x])!=finds(fa[y])){\n\t\t\t\tcout&lt;&lt;0&lt;&lt;endl;\n\t\t\t}else{\n\t\t\t\tcout&lt;&lt;1&lt;&lt;endl;\n\t\t\t}\n\t\t}else if(op=='D'){\n\t\t\tcin&gt;&gt;x;\n\t\t\tdeletes(x);\n\t\t}else{\n\t\t\tcin&gt;&gt;x;\n\t\t\trestore(x);\n\t\t}\n\t}\n\treturn 0;\n}\n</code></pre>\n<h2 id=\"带权并查集\">带权并查集：</h2>\n<p>本质是并查集的向量拓展<br />\n把树看成dag图，每个元素的权值记录的是它和它父亲之间的边权，主要记录的是一种关系，这里是一些普通的数字，但在实际问题中边权往往是一些关系，最后可能还要取模<br />\n目的是利用路径压缩求出元素到根节点的边权和，然后给定任意两个元素求出这两个元素之间的某些关系（与根有关的和差）<br />\n假设权值数组为<span class=\"math inline\">\\(w\\)</span><br />\n路径压缩时可以先递归找根并存储，然后把w[x]+=w[fa[x]]，最后把fa[x]改成根<br />\n因为是递归，所以会先找到根，然后回溯像前缀和一样层层加，直到加到当前元素为止，此时w[x]就为x到根节点的权值和，同时这条链上的元素都把权值改了<br />\n但是重点在合并<br />\n合并两个元素x，y所在集合，其中x，y两个元素之间权值为有向值s（把x合并到y或把y合并到x）<br />\n由于x到y和y到x只需调换顺序即可，所以只考虑x到y<br />\n假如x的根是px，，y的根是py，省略中间的链，因为路径压缩时会改，问题在于x到y的权值明确，x到px的权值明确，y到py的权值明确，但是px到py就不知道了<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260124162708674-1940796842.png\" /><br />\n可以辅助线来解决<br />\n先求x到py，这里x到y和y到py等价于x到py，所以x到py权值用向量加法为s+v2<br />\n同理，x到py又等于v1+px到py<br />\n所以px到py=s+v2-v1<br />\n这是个抽象问题，这里加的是向量，而不是向量的模，很懵逼<br />\n但是实际问题往往要取模或者是压根再开一个数组，详见NOI2002银河英雄传说<br />\n基础操作就是这些，还有一些例题</p>\n<h3 id=\"hdu-3038-how-many-answers-are-wrong\">HDU-3038-How Many Answers Are Wrong</h3>\n<p>来自 <a href=\"https://blog.csdn.net/yjr3426619/article/details/82315133\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/yjr3426619/article/details/82315133</a></p>\n<p>有M个数，不知道它们具体的值，但是知道某两个数之间（包括这两个数）的所有数之和，现在给出N个这样的区间和信息，需要判断有多少个这样的区间和与前边已知的区间和存在矛盾。例如给出区间和<span class=\"math inline\">\\([1,4]\\)</span>为20，<span class=\"math inline\">\\([3,4]\\)</span>为15，再给出<span class=\"math inline\">\\([1,2]\\)</span>为30，显然这个<span class=\"math inline\">\\([1,2]\\)</span>的值就有问题，它应该为20-15=5。<br />\n由于不知道每句区间是否正确，所以要根据先前的正确的区间来推出这个区间，如果推不出就是对的，因为是新的，如果推出了，若题目给的与之前的正确的区间推出的区间的值相等就说明正确，可以忽略，若不相等，则不正确，也忽略，留下正确的值<br />\n注意不相等是唯一矛盾的时候，<span class=\"math inline\">\\([1,10]=50\\)</span>  ,<span class=\"math inline\">\\([1,5]=100\\)</span>这看起来不对，但实际上题目没说每个数是正数，所以这也是对的，可能<span class=\"math inline\">\\([6,10]=-50\\)</span><br />\n我们想到区间的合并，很像并查集<br />\n但是这是个闭区间，没有公共点，我们需要半开半闭区间，不能全开区间，这样<span class=\"math inline\">\\([1,4]=(0,5)\\)</span>   <span class=\"math inline\">\\([3,4]=(2,5)\\)</span>   <span class=\"math inline\">\\([1,2]=(0,3)\\)</span>，没有公共点<br />\n常见左闭右开区间，这样<span class=\"math inline\">\\([1,4]=[1,5)\\)</span>  <span class=\"math inline\">\\([1,2]=[1,3)\\)</span>   <span class=\"math inline\">\\([3,4]=[3，5)\\)</span><br />\n可以把1 3和3 5合成1 5<br />\n所以要先改区间<br />\n然后就可以用并查集了。<br />\n看图：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260124163306555-1040943616.png\" /><br />\n这两种都是对的<br />\n都是向量的加法<br />\n第一种以5为根，合并时并没有真正1 3连边和求值，要 求 1 3时只需要用1 5的和减去3 5的和即可<br />\n第二种以1为根，合并时用公式s+v2-v1，因为3是孤立点，所以v2=0，即s-v1，这就算出了1 3<br />\n然后求1 3的和用1 3的和 减去 1 1的和即可<br />\n由此可见询问区间x y时是sum x  -  sum y还是反过来完全取决于合并时把x的集合并到y还是把y的集合并到x，如果x-》y就sum x  -sum y<br />\n如果y-》x就sum y -sum x<br />\n所以不能启发式合并<br />\n那么什么时候算不出x y的和？<br />\n当区间两个端点在一个集合时说明两个sum可以用向量求，而不在一个集合时求不出，因为两个集合没有交集，中间的数不知道是多少<br />\n因此，思路如下：<br />\n读入区间<br />\n合并两个区间端点，若在一个集合中时公式算出和，比对给出的，不合法记录下来<br />\n不在一个集合时认为这个和是对的，把这两个合并，以这个和为权值<br />\n合并时用基本向量公式<br />\n若x-&gt;y就用w(x,y)+w（y,py)-w(x,px)<br />\n若y-&gt;x就用w(x,y)+w(x,px)-w(y,py)<br />\npx就是x的根<br />\nw就是之间的和<br />\n初始化把w数组置为0，即使是根节点到自身也满足上面的公式<br />\n把fa【i】=i不要等于-1，容易出错</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint fa[2000003],v[2000003];\ninline int find(int x){\n\tif(fa[x]==x)return x;\n\tint k=find(fa[x]);\n\tv[x]+=v[fa[x]];\n\tfa[x]=k;\n\treturn k;\n}\ninline void inserts(int x,int y,int a,int b,int z){\n\tfa[a]=b;\n\tv[a]=z+v[y]-v[x];\n}\nint main(){\n\tmemset(fa,-1,sizeof fa);\n\tmemset(v,0,sizeof v);\n\tint n,m;\n\tcin&gt;&gt;n&gt;&gt;m;\n\tint cnt=0;\n\tfor(int i=0;i&lt;m;++i){\n\t\tint x,y,z;\n\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n\t\ty=y+1;//闭区间改成开区间 \n\t\tif(fa[x]==-1)fa[x]=x;\n\t\tif(fa[y]==-1)fa[y]=y;\n\t\tint a=find(x),b=find(y);\t\n\t\tif(a!=b){\n\t\t\tinserts(x,y,a,b,z);\n\t\t}else{\n\t\t\tif(v[x]-v[y]!=z)cnt++;\n\t\t}\n\t}\n\tcout&lt;&lt;cnt&lt;&lt;endl;\n\treturn 0;\n}\n\n</code></pre>\n<p>另一个例题：</p>\n<h3 id=\"hihocoder-1515-分数调查\">HihoCoder-1515-分数调查</h3>\n<p>描述<br />\n小Hi的学校总共有N名学生，编号1-N。学校刚刚进行了一场全校的古诗文水平测验。</p>\n<p>学校没有公布测验的成绩，所以小Hi只能得到一些小道消息，例如X号同学的分数比Y号同学的分数高S分。</p>\n<p>小Hi想知道利用这些消息，能不能判断出某两位同学之间的分数高低？</p>\n<p>输入<br />\n第一行包含三个整数N, M和Q。N表示学生总数，M表示小Hi知道消息的总数，Q表示小Hi想询问的数量。</p>\n<p>以下M行每行三个整数，X, Y和S。表示X号同学的分数比Y号同学的分数高S分。</p>\n<p>以下Q行每行两个整数，X和Y。表示小Hi想知道X号同学的分数比Y号同学的分数高几分。</p>\n<p>对于50%的数据，$1 &lt;= N, M, Q &lt;= 1000 $</p>\n<p>对于100%的数据，<span class=\"math inline\">\\(1 &lt;= N, M, Q&lt;= 100000 1 &lt;= X, Y &lt;= N -1000 &lt;= S &lt;= 1000\\)</span></p>\n<p>数据保证没有矛盾。</p>\n<p>输出<br />\n对于每个询问，如果不能判断出X比Y高几分输出-1。否则输出X比Y高的分数。</p>\n<p>样例输入</p>\n<p>10 5 3<br />\n1 2 10<br />\n2 3 10<br />\n4 5 -10<br />\n5 6 -10<br />\n2 5 10<br />\n1 10<br />\n1 5<br />\n3 5<br />\n样例输出</p>\n<p>-1<br />\n20<br />\n0</p>\n<p>分析一下：<br />\n考虑传递性和向量性<br />\n显然是图，x比y高可以x-》y连一条边，权值是x比y高的分数<br />\n看图：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260124163431046-1074997319.png\" /><br />\n3比2高3分，2比1高5分，所以3比1高8分<br />\n具有传递性</p>\n<p>向量合并：<br />\n对于1比2高8分<br />\n3比4高3分<br />\n1比3高3分<br />\n则1比4高6分<br />\n则2比4高-2分<br />\n注意当x比y低时就是x比y高y比x高的分数的相反数<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260124163544199-37076875.png\" /><br />\n具有向量性<br />\n因此可以用并查集<br />\n那么怎么由x到根节点权值和y到根节点权值推出x比y高的分呢?<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260124163601865-836423128.png\" /><br />\n即w【x】-w【y】<br />\n什么时候无解呢？<br />\n当x与y在一个并查集时可以根据根节点来求x与y的权值，当x与y不在一个并查集时不能得出x到y的权值，<br />\n如：<br />\n1比2高3分，3比4高2分，无法求出2比3高的分数<br />\nw数组代表x比x的父亲高的分数<br />\n路径压缩时统计和，得知x到根的权值<br />\n合并时同样不能启发式合并，要把x合并到y<br />\n向量法计算合并后的权值<br />\n合并x和y所在集合<br />\n询问时先判断x与y是否在一个并查集，是输出w[x]-w[y]<br />\n不是输出-1!</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n\nusing namespace std;\nint fa[100003],v[100003];\ninline int find(int x){\n\tif(fa[x]==x)return x;\n\tint k=find(fa[x]);\n\tv[x]+=v[fa[x]];\n\treturn fa[x]=k;\n}\ninline void inserts(int a,int b,int x,int y,int z){\n\tfa[a]=b;\n\tv[a]=z+v[y]-v[x];\n}\nint main(){\n\tmemset(fa,-1,sizeof fa);\n\tmemset(v,0,sizeof v);\n\tint n,m,q;\n\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;q;\n\tfor(int i=0;i&lt;m;++i){\n\t\tint x,y,k;\n\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;k;\n\t\tif(fa[x]==-1)fa[x]=x;\n\t\tif(fa[y]==-1)fa[y]=y;\n\t\tint a=find(x),b=find(y);\n\t\tif(a!=b){\n\t\t\tinserts(a,b,x,y,k);\n\t\t}\n\t}\n\tfor(int i=0;i&lt;q;++i){\n\t\tint x,y;\n\t\tcin&gt;&gt;x&gt;&gt;y;\n//\t\tcout&lt;&lt;9;\n\t\tif(fa[x]==-1)fa[x]=x;\n\t\tif(fa[y]==-1)fa[y]=y;\t//这里注意可能x和y还没出现过，所以要检验-1，因为-1做下标会re \n\t\tint g=find(x),f=find(y);\n\t\tif(g!=f){\n\t\t\tcout&lt;&lt;-1&lt;&lt;endl;\n\t\t}else{\n\t\t\tcout&lt;&lt;v[x]-v[y]&lt;&lt;endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}\n</code></pre>\n<h2 id=\"种类并查集\">种类并查集：</h2>\n<p>当我们在维护一些复杂的传递关系时，普通的并查集无法满足需求<br />\n维护朋友的朋友是朋友，敌人的敌人是朋友，<br />\n异性的异性是同性<br />\n<span class=\"math inline\">\\(a\\)</span>吃<span class=\"math inline\">\\(b\\)</span> <span class=\"math inline\">\\(b\\)</span>吃<span class=\"math inline\">\\(c\\)</span> 则<span class=\"math inline\">\\(c\\)</span>吃<span class=\"math inline\">\\(a\\)</span><br />\n这种具有反向传递性的关系时，可以用加权并查集<br />\n当然很复杂<br />\n于是有一种占空间更大但是简单的种类并查集<br />\n我们可以根据关系的数目确定出要把fa数组开一定的倍数<br />\n然后把这个数组分成几类，用来维护反向传递性<br />\n洛谷P1525 关押罪犯</p>\n<p>来自 <a href=\"https://zhuanlan.zhihu.com/p/97813717\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/97813717</a></p>\n<p>团伙<br />\n食物链<br />\n异性问题<br />\n这是最简单的<br />\n因为只有男和女两种<br />\n当a和b同性b和c同性时a和c同性，这是基础并查集的合并<br />\n当a和b异性b和c异性时a和c同性<br />\n当a和b同性b和c异性则a和c异性<br />\n后两个具有反向传递性<br />\n这里我们fa多开一倍数组<br />\n我们假定<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(a+n\\)</span>为异性，<span class=\"math inline\">\\(n\\)</span>是正常开的数组大小<br />\n所以当<span class=\"math inline\">\\(a\\)</span>为<span class=\"math inline\">\\(n-1\\)</span>时<span class=\"math inline\">\\(a+n=2n-1\\)</span>，因此需要开两倍数组<br />\n当<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>是同性时，我们可以合并<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>所在集合，因为都是同性<br />\n还可以合并<span class=\"math inline\">\\(a+n\\)</span>和<span class=\"math inline\">\\(b+n\\)</span>所在集合，因为<span class=\"math inline\">\\(a+n\\)</span>是与<span class=\"math inline\">\\(a\\)</span>异性的，<span class=\"math inline\">\\(b+n\\)</span>是与<span class=\"math inline\">\\(b\\)</span>异性的，当<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>同性时，<span class=\"math inline\">\\(a\\)</span>的异性和<span class=\"math inline\">\\(b\\)</span>的异性是同性<br />\n而<span class=\"math inline\">\\(a+n\\)</span>里的所有元素全是一个性别<br />\n<span class=\"math inline\">\\(b+n\\)</span>也是<br />\n所以可以合并<br />\n当<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>异性时<br />\n那么把<span class=\"math inline\">\\(a\\)</span>的异性和<span class=\"math inline\">\\(b\\)</span>合并，把<span class=\"math inline\">\\(b\\)</span>的异性和<span class=\"math inline\">\\(a\\)</span>合并<br />\n即合并<span class=\"math inline\">\\(a+n,b\\)</span>      ;   <span class=\"math inline\">\\(b+n,a\\)</span><br />\n因为<span class=\"math inline\">\\(a\\)</span>的异性肯定和<span class=\"math inline\">\\(b\\)</span>同性<br />\n<span class=\"math inline\">\\(b\\)</span>的异性肯定和<span class=\"math inline\">\\(a\\)</span>同性</p>\n<p>为什么这样可以做到那三条？<br />\n第一条显然满足<br />\n第三条<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>同性则<span class=\"math inline\">\\(a,b\\)</span>    <span class=\"math inline\">\\(a+n,b+n\\)</span>分别在一个并查集，<span class=\"math inline\">\\(b\\)</span>和<span class=\"math inline\">\\(c\\)</span>异性则<span class=\"math inline\">\\(b+n  ,c\\)</span>           <span class=\"math inline\">\\(c+n,b\\)</span>分别在一个并查集，所以<span class=\"math inline\">\\(a+n\\)</span>和<span class=\"math inline\">\\(c\\)</span>     <span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(c+n\\)</span>分别在一个并查集，<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(c\\)</span>不在一个并查集，所以<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(c\\)</span>是异性<br />\n第二条比较复杂<br />\n<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>是异性时<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>不在一个并查集，但是<span class=\"math inline\">\\(b\\)</span>和<span class=\"math inline\">\\(a+n\\)</span>，，<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b+n\\)</span>分别都在一个并查集<br />\n<span class=\"math inline\">\\(b\\)</span>和<span class=\"math inline\">\\(c\\)</span>异性时<span class=\"math inline\">\\(b\\)</span>和<span class=\"math inline\">\\(c\\)</span>不在一个并查集，但是<span class=\"math inline\">\\(b\\)</span>和<span class=\"math inline\">\\(c+n\\)</span> ，，<span class=\"math inline\">\\(c\\)</span>和<span class=\"math inline\">\\(b+n\\)</span>分别在一个并查集<br />\n所以<span class=\"math inline\">\\(a+n\\)</span>和<span class=\"math inline\">\\(c+n\\)</span>在一个并查集，，<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(c\\)</span>也在一个并查集<br />\n所以<span class=\"math inline\">\\(a+n\\)</span>和<span class=\"math inline\">\\(c+n\\)</span>,,,<span class=\"math inline\">\\(a\\)</span>,<span class=\"math inline\">\\(c\\)</span>分别在一个并查集<br />\n即它们分别同性<br />\n所以第二条满足</p>\n<p>那么查找时问<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>同性还是异性只需要看：<br />\n<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>在一个并查集时说明是同性，<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>不在一个并查集时若<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b+n\\)</span>同性<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>就是异性（就两种性别）<br />\n注意<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>不在一个并查集不能说明是异性<br />\n因为如1 2同性<br />\n3 4同性<br />\n再说2 3同性，2和3<br />\n不在一个并查集中，而2的异性集合中没有3，所以2 3同性这是对的</p>\n<p>但是原题：<br />\n每次给出两个昆虫的关系（异性关系），然后发现这些条件中是否有悖论</p>\n<p>来自 <a href=\"https://blog.csdn.net/sunmaoxiang/article/details/80959300?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/sunmaoxiang/article/details/80959300?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control</a></p>\n<p>所以要动态判断<br />\n当输入<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>后<br />\n若<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>有一个没有初始化就先初始化（<span class=\"math inline\">\\(a，b，a+n，b+n\\)</span>中没有初始化的都要初始化）然后把<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>按照前面的规则合并<br />\n然后这个数据是对的</p>\n<p>若<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>已经初始化也不能说明它们的关系已经确定，如上面的例子，此时判断<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>关系是否与输入的相符，若相符就是对的，若不符就是不对的，就跳过。若不在一个并查集中且<span class=\"math inline\">\\(a\\)</span>的异性和<span class=\"math inline\">\\(b\\)</span>也不在一个并查集中关系就未确定，此时<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>的关系再合并，<span class=\"math inline\">\\(a\\)</span>和<span class=\"math inline\">\\(b\\)</span>的关系是对的<br />\n这时路径压缩和按秩合并都可以用</p>\n<pre><code>#include&lt;iostream&gt; \n#include&lt;cstdio&gt; \n#include&lt;cstring&gt;\nusing namespace std;\nint fa[200002];\ninline int find(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=find(fa[x]);\n}\ninline void inserts(int x,int y){\n\tint a=find(x),b=find(y);\n\tif(a==b)return;\n\tfa[a]=b;\n}\nint main(){\n\tint n,m;\n\tcin&gt;&gt;n&gt;&gt;m;\n\tmemset(fa,-1,sizeof fa);\n\tfor(int i=0;i&lt;m;++i){\n\t\tint x,y;\n\t\tcin&gt;&gt;x&gt;&gt;y;\n\t\tif(fa[x]==-1)fa[x]=x;\n\t\tif(fa[y]==-1)fa[y]=y;\n\t\tint a=find(x),b=find(y);\n\t\tif(a==b)cout&lt;&lt;\"N\"&lt;&lt;endl;\n\t\telse{\n\t\t\tif(fa[y+n]==-1)fa[y+n]=y+n;//注意y+n x+n可能没用过，所以要先初始化 \n\t\t\tif(fa[x+n]==-1)fa[x+n]=x+n;\n\t\t\tinserts(x,y+n);\n\t\t\tinserts(x+n,y);\n\t\t\tcout&lt;&lt;\"Y\"&lt;&lt;endl;\n\t\t}\n\t}\n\treturn 0;\n} \n</code></pre>\n<p>再用加权并查集做一下：<br />\nw数组记录x到x父亲的关系（1异性 0同性）<br />\n路径压缩时求和，但是要取模2<br />\n为什么？<br />\n有1号 2号 3号<br />\n成链状，现在把3路径压缩，使得w【3】是1与3的关系<br />\n1与2同性且2与3同性时：w[1]=0   w[2]=0       w[3]=0      w[3new]=w[1]+w[2]+w[3]=0  0%2=0      满足1 3同性<br />\n1与2同性且2与3异性时  w[1]=0  w[2]=0  w[3]=1   w[3new]=w[1]+w[2]+w[3]=1  1%2=1  满足1 3异性<br />\n1与2异性且2与3同性时w[1]=0  w[2]=1  w[3]=0   w[3new]=w[1]+w[2]+w[3]=1   1%2=1  满足1 3异性<br />\n1与2异性且2与3异性时最重要  w[1]=0  w[2]=1  w[3]=1  w[3new]=w[1]+w[2]+w[3]=2  2%2=0   满足异性的异性是同性<br />\n可见在压缩求和时可以顺便%2，这样最后的关系是正确的，实际上这是分了两类，所以%2</p>\n<p>然后合并，同样不能按秩合并<br />\n向量法<br />\n具有向量性，但要取模<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260124164323599-1904309385.png\" /><br />\n由此可见，我们把y连到x的向量公式<span class=\"math inline\">\\(w[py]=w(x,y)+w[x]-w[y]+2\\)</span>再取模2即可，这样合并后px和py的关系是正确的<br />\n+2是为了防止<span class=\"math inline\">\\(w[x]\\)</span>与<span class=\"math inline\">\\(w(x,y)\\)</span>都是为0，而<span class=\"math inline\">\\(w[y]=1\\)</span>，会出现负数</p>\n<p>那么询问关系时怎么处理？<br />\n询问<span class=\"math inline\">\\(x\\)</span>和<span class=\"math inline\">\\(y\\)</span>的关系<br />\n当<span class=\"math inline\">\\(x\\)</span>和<span class=\"math inline\">\\(y\\)</span>在一个并查集时即<span class=\"math inline\">\\(x\\)</span>和<span class=\"math inline\">\\(y\\)</span>的关系确定<br />\n当<span class=\"math inline\">\\(x\\)</span>和<span class=\"math inline\">\\(y\\)</span>不在一个并查集时<span class=\"math inline\">\\(x\\)</span>和<span class=\"math inline\">\\(y\\)</span>的关系不确定，给出的这个关系是对的，然后合并<br />\n注意与种类并查集不同的是：<span class=\"math inline\">\\(x\\)</span>和<span class=\"math inline\">\\(y\\)</span>在一个并查集并不能说明x和y的关系是同性，只能说明它们有明确的关系，而同异性是根据权值数组w来确定的<br />\n当关系确定时<br />\n若<span class=\"math inline\">\\(x\\)</span>和<span class=\"math inline\">\\(y\\)</span>的共同根节点是<span class=\"math inline\">\\(px\\)</span>，那么<span class=\"math inline\">\\(x\\)</span>和<span class=\"math inline\">\\(y\\)</span>的关系就是$(w[x]-w[y]+2) \\mod 2 $<br />\n+2同样防止出现负数<br />\n如<span class=\"math inline\">\\(x\\)</span>到<span class=\"math inline\">\\(px\\)</span>是1，y到py是1<br />\n则<span class=\"math inline\">\\(x\\)</span>到<span class=\"math inline\">\\(y\\)</span>是1-1=0 0%2=0<br />\n符合要求<br />\n然后判断与给出的是否符合即可<br />\n注意初始化每个节点的w都是0，即根节点和它自己是同性，否则会造成问题。<br />\n注意这里给出<span class=\"math inline\">\\(x\\)</span> <span class=\"math inline\">\\(y\\)</span>时我们把<span class=\"math inline\">\\(y\\)</span>连向<span class=\"math inline\">\\(x\\)</span></p>\n<pre><code>#include&lt;iostream&gt;//x连接向y\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint fa[1006],w[1006];\ninline int finds(int x){\n\tif(fa[x]==x)return x;\n\tint k=finds(fa[x]);\n\tw[x]=(w[x]+w[fa[x]])%2;\n\treturn fa[x]=k;\n}\ninline void inserts(int x ,int y,int a,int b,int z){\n\tfa[a]=b;\n\tw[a]=z+w[y]-w[x];\n\tw[a]=w[a]+2;\n\tw[a]=w[a]%2;\n}\nint main(){\n\tmemset(fa,-1,sizeof fa);\n\tmemset(w,0,sizeof w);\n\tint n,m;\n\tcin&gt;&gt;n&gt;&gt;m;\n\tfor(int i=0;i&lt;m;++i){\n\t\tint x,y;\n\t\tcin&gt;&gt;x&gt;&gt;y;\n\t\tif(fa[x]==-1)fa[x]=x;\n\t\tif(fa[y]==-1)fa[y]=y;\n\t\tint a=finds(x),b=finds(y);\n\t\tif(a!=b){\n\t\t\tinserts(x,y,a,b,1);\n\t\t\tcout&lt;&lt;\"Y\"&lt;&lt;endl;\n\t\t\t\n\t\t}else{\n\t\t\tif((w[y]-w[x]+2)%2==1){\n\t\t\t\tcout&lt;&lt;\"Y\"&lt;&lt;endl;\n\t\t\t}else{\n\t\t\t\tcout&lt;&lt;\"N\"&lt;&lt;endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n</code></pre>\n<p>种类并查集可以维护敌人的敌人是朋友这样的关系，这种说法不够准确，较为本质地说，种类并查集（包括普通并查集）维护的是一种循环对称的关系。</p>\n<p>来自 <a href=\"https://zhuanlan.zhihu.com/p/97813717\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/97813717</a></p>\n<p>还有一类问题：<br />\n拆地毯</p>\n<p>修复公路   贪心<br />\n||<br />\n营救   贪心<br />\n这两道题等价，都是最大值的最小化<br />\n星球大战   倒推</p>\n<p>这些题都是些思维题，主要是倒推和贪心<br />\n拆地毯是星球大战和修复公路结合</p>\n<h2 id=\"并查集联通块数量统计\">并查集联通块数量统计</h2>\n<p>关于并查集联通块数量统计，首先要知道初始状态的联通块个数，然后每一次合并是若不在一个并查集则合并能使联通块数量减少<span class=\"math inline\">\\(1\\)</span>，若在一个并查集则没有贡献，切忌哈希统计<br />\n这指的是一个节点原先是独立的集合时。<br />\n但是如果是一个节点从原先不存在到出现并连边，联通块的数量要分类讨论<br />\n若这个点没有任何边将要和它相连，那么出现后联通块个数反而加一，，若这个节点出现并连第一条边，则联通块数量不变，因为节点出现相当于增加了一个联通块，连一条边合并后联通块减少了<span class=\"math inline\">\\(1\\)</span>，所以不变<br />\n若这个节点已经出现且连的不是第一条边，那么合并（当然不在一个集合时）后联通块数量减少<span class=\"math inline\">\\(1\\)</span>，因为此时这个节点已经在一个集合中了，若再与另一个集合连边，就会使得集合数目减少<span class=\"math inline\">\\(1\\)</span></p>\n<p>当遇到拆毁/彻底删除（连着点和边一起删除，破坏了集合关系）时，应该倒推，寻求全部<br />\n删除后的状态，然后倒着合并<br />\n当遇到移动集合元素，分离单一元素为独立集合（保持原来集合关系，只是那一个元素空了）时，应该用盒子来做，，即源节点指向盒子，对于合并与查找都是操作盒子，当移动或分离改变源节点指向的盒子，就可以保留原来集合关系，但是实现源节点的转移或分离。</p>\n<h2 id=\"并查集的另一种写法\">并查集的另一种写法</h2>\n<p>就是路径压缩 启发式合并  找父亲 使用了一个数组完成<br />\n当f【i】为负数时，说明这个节点是根节点，此时f[i]的值是这个根节点的树的节点个数的相反数<br />\n当f[i]为正数时，f[i]是i的父亲<br />\n这样查找x的根时，当f[x]&lt;0时返回x，是根节点，其余情况照常路径压缩return f[x]=find(f[x])<br />\n合并时x y先找根节点，如果根节点不同，那么就进行合并<br />\n设x的根为rx<br />\ny的根为ry<br />\n如果f[rx]&gt;f[ry]  就交换rx和ry<br />\n这样f[rx]一定&lt;=f[ry]<br />\n即-f[rx]&gt;=-f[ry]<br />\n此时rx的树的尺寸大小&gt;=ry的树的尺寸大小<br />\nrx做根<br />\nf[rx]+=f[ry]<br />\n更新rx的尺寸的相反数<br />\nf[ry]=rx<br />\n此时ry就指向了rx，做了儿子<br />\n这两步顺序不能错，因为在第二步之前f[ry]记录的是ry下的树尺寸的相反数，f[rx]+=f[ry]可以更新尺寸，而第二步是因为ry做了儿子，所以f[ry]成了ry的父亲，如果颠倒，那么f[rx]就可能变成正数从而误认为不是根节点</p>\n<p>理解：<br />\n对于两个集合的根节点rx，ry<br />\n它们的f已经计算好，是它们的树的尺寸的相反数，合并是通过比较这个尺寸来实现启发式 合并，然后假设rx做新根<br />\n那么rx的尺寸相反数自然要更新，加上ry的尺寸的相反数（都是负数），然后ry的f就变成了指向父亲的作用，ry的父亲是rx<br />\n查找时若x是根节点，f[x]不一定=-1，也有可能&lt;-1，代表的是尺寸的相反数，同时能说明找到了根节点<br />\n当f[x]&gt;0时说明f【x】是x的父亲，要继续递归并路径压缩<br />\n初始化时f[]要置为-1，代表每个树尺寸为1</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint f[10006];\ninline int finds(const int&amp;x ){\n\tif(f[x]&lt;0)return x;\n\treturn f[x]=finds(f[x]);\n}\ninline void unions(const int&amp;x,const int &amp;y){\n\tint rx=finds(x);\n\tint ry=finds(y);\n\tif(rx==ry)return;\n\tif(f[rx]&gt;f[ry])swap(rx,ry);\n\tf[rx]+=f[ry];\n\tf[ry]=rx;\n\t\n}\nint main(){\n\tmemset(f,-1,sizeof f);\n\tint n,m;\n\tcin&gt;&gt;n&gt;&gt;m;\n\tfor(int i=1;i&lt;=m;++i){\n\t\tint opt;\n\t\tcin&gt;&gt;opt;\n\t\tint x1,y1;\n\t\tcin&gt;&gt;x1&gt;&gt;y1;\n\t\tif(opt==1){\n\t\t\tunions(x1,y1);\n\t\t}else{\n\t\t\tint rx1=finds(x1);\n\t\t\tint ry1=finds(y1);\n\t\t\tif(rx1==ry1)cout&lt;&lt;\"Y\"&lt;&lt;endl;\n\t\t\telse cout&lt;&lt;\"N\"&lt;&lt;endl;\n\t\t}\n\t}\n\treturn 0;\n}\n</code></pre>\n<hr />\n<h2 id=\"例题详解\">例题详解</h2>\n<h3 id=\"p1197-jsoi2008星球大战\">P1197 [JSOI2008]星球大战</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P1197\" rel=\"noopener nofollow\" target=\"_blank\">https://www.luogu.com.cn/problem/P1197</a></p>\n<p>特殊的倒推法<br />\n问题等价于<span class=\"math inline\">\\(n\\)</span>个节点<span class=\"math inline\">\\(m\\)</span>条无向边<br />\n然后拆掉一些点和它们相连的所有边，每拆一个点就输出联通块个数<br />\n暴力肯定超时<br />\n有合并且无向，可以用并查集<br />\n需要想一个特殊的方法<br />\n我们不拆点，这样很困难<br />\n我们倒着加点<br />\n先把除了所有拆的点有关的所有边之外的剩下的边用并查集合并<br />\n这是拆掉这些点后的状态，枚举剩下的点求出联通块个数<br />\n然后从后往前加点，因为前面的点拆掉时后面的点还要连着<br />\n接下来每加一个点就把它们相连的边合并一下，然后合并时若两个点都在一个并查集则合并这两个点对联通块没有影响，若不在一个并查集那么合并，注意加一个节点可能合并多条边并减小多个联通块数目<br />\n然后把这个减小后的变量记录 下来逆序输出<br />\n我们要把所有要摧毁的点所相连的边存起来，以便于后面倒推加边，并且剩下的边要合并起来作为所有都拆毁后的联通块，联通块一定要边合并边统计，切忌最后哈希统计<br />\n我们如果哈希记下边，读拆毁点时找边太难了，但我们可以哈希记下拆毁点，再遍历边时找出拆毁点相连的边会容易，同时还可以合并剩下的边，这是哈希的第一个妙用<br />\n原来<span class=\"math inline\">\\(n\\)</span>个点<br />\n去掉<span class=\"math inline\">\\(k\\)</span>个后<span class=\"math inline\">\\(n-k\\)</span>个，此时每合并一次减小一个联通块</p>\n<p>接下来倒着加点，把点所连的边合并<br />\n注意：<br />\n有时一条边的另一个点也是拆毁点，此时要看先后顺序来决定是否连边<br />\n当拆毁点靠前时，实际上这个点现在已经被拆毁，不能向他连边<br />\n当拆毁点靠后时，这个点已经恢复，所以要向他连边<br />\n因为从后往前，所以每恢复一个点就要把<span class=\"math inline\">\\(hash\\)</span>改为<span class=\"math inline\">\\(2\\)</span>，即已恢复，此时可以向他连边，而非拆毁点肯定要向他连边，而<span class=\"math inline\">\\(hash\\)</span>为<span class=\"math inline\">\\(1\\)</span>的还处于拆毁状态，不连边<br />\n然后算联通块的个数<br />\n注意：<br />\n这里拆毁节点不是把边断开，而是连同点一块删除，因此加边后联通块不能减1</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;vector&gt;\nusing namespace std;\nint fa[400006];\nstruct edge{\n\tint a,b;\n}edges[200006];\nint goal[400006];\nint hash1[400006];//hash1数组记录这个节点状态，0为不是要摧毁的节点，1为当前已摧毁的节点，2为当前未摧毁的节点（即已倒退回来到这个节点）\nvector&lt;int&gt; edge2[400006];//每一个要摧毁的节点所相连的边\nint out[400006];//因为从后往前加边，所以要逆序输出\nint num=0;\ninline int finds(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=finds(fa[x]);\n}\ninline void inserts(int x,int y,int a,int b){\n//\tif(a==b)return ;\n\tfa[a]=b;\n}\nint main(){\n\tmemset(hash1,0,sizeof hash1);\n\tfor(int i=0;i&lt;400006;++i){\n\t\tfa[i]=i;\n\t}//不要memset -1，这样后面要一个个改，要提前初始化好\n\tint n,m;\n\tcin&gt;&gt;n&gt;&gt;m;\n\tfor(int i=0;i&lt;m;++i){\n\t\tint x,y;\n\t\tcin&gt;&gt;x&gt;&gt;y;\n\t\tedges[i].a =x;//edge数组存边\n\t\tedges[i].b=y;\n\t}\n\tint k;\n\tcin&gt;&gt;k;\n\tfor(int i=0;i&lt;k;++i){\n\t\tcin&gt;&gt;goal[i];\n\t\thash1[goal[i]]=1;//哈希表定为1因为这个点是已经拆毁了的\n\t}\n\tint lian1=n-k;\n\tfor(int i=0;i&lt;m;++i){\n\t\tif(hash1[edges[i].a ]==1){\n\t\t\tedge2[edges[i].a].push_back(edges[i].b );\n\t\t\t \n\t\t}//这两个if要并列不要else，因为两个a b点有可能都是要拆毁的点\n\t\tif(hash1[edges[i].b ]==1){\n\t\t\tedge2[edges[i].b].push_back(edges[i].a );\n\t\t\t \n\t\t}\n\t\tif((!hash1[edges[i].a ])&amp;&amp;(!hash1[edges[i].b ])){\n\t\t\tint root1=finds(edges[i].a ),root2=finds(edges[i].b);//如果两个都不拆毁，那么就要合并来算出联通块\n\t\t\tif(root1!=root2){//根节点相同时合并没有用，联通块不变\n\t\t\t\tinserts(edges[i].a,edges[i].b,root1,root2);\n\t\t\t\tlian1-=1;\t\n\t\t\t}\n\t\t}\n\t}\n\t//cout&lt;&lt;lian1&lt;&lt;endl;\n\tout[num]=lian1;\n\t++num;\n\tfor(int i=k-1;i&gt;=0;--i){//要等于0，因为全部恢复后是全连好的联通块，是要求输出的\n\t\tint root1=finds(goal[i] );\n\t\tint fl1=1,fl2=1;//fl1是看这个点是否孤立，若整个遍历没有可以连的边说明它是孤立的，此时恢复后联通块反而加1，fl2看这个点是否是第一次连边\n\t\t若是，说明这是把原先不存在的点和一个集合连边，此时一旦连起之后联通块不减少，因为原先这个点不存在，而现在连起之后就存在了\n\t\t而若不是第一次连边，那么这个点已经存在了，此时它与其他点构成了集合\n\t\t那么这是连边就能将联通块个数减一\n\t\tfor(int j=0;j&lt;edge2[goal[i]].size();++j){\n\t\t\tif(hash1[edge2[goal[i]][j]]!=1){\n\t\t\t\tfl1=0;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint root2=finds(edge2[goal[i]][j]);\n\t\t\t\t\n\t\t\t\tif(root1!=root2){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tinserts(edge2[goal[i]][j],goal[i],root2,root1);\n\t\t\t\t\tif(fl2){\n\t\t\t\t\t\tfl2=0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlian1-=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(fl1)lian1+=1;\n\t\thash1[goal[i]]=2;\n\t\tout[num++]=lian1;\n\t}\n\tfor(int i=num-1;i&gt;=0;--i){\n\t\tcout&lt;&lt;out[i]&lt;&lt;endl;\n\t}\n\treturn 0;\n}\n</code></pre>\n<h3 id=\"p1111-修复公路\">P1111 修复公路</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P1111\" rel=\"noopener nofollow\" target=\"_blank\">https://www.luogu.com.cn/problem/P1111</a></p>\n<p>这是并查集的贪心算法<br />\n<span class=\"math inline\">\\(n\\)</span>个节点<span class=\"math inline\">\\(m\\)</span>条无向边，给定边的修好时间<br />\n求最小能使<span class=\"math inline\">\\(n\\)</span>个节点相互连通的时间<br />\n无向图，连边相当于合并，可以使用并查集<br />\n因为是最小。可以考虑贪心，先把边按时间由小到大排序并遍历<br />\n然后从小开始遍历，每遍历一条边就把这两个节点合并起来，用<span class=\"math inline\">\\(size\\)</span>数组记录根的尺寸，启发式合并，如果这个根的<span class=\"math inline\">\\(size\\)</span>是<span class=\"math inline\">\\(n\\)</span>，那就说明所有节点都在一个并查集中，就输出此时的时间，否则若到最后也没有联通，就输出<span class=\"math inline\">\\(-1\\)</span></p>\n<p>为什么贪心正确?<br />\n我们选择的时间是从小到大中刚刚保持联通的时间，假设有完成联通的时间比这个小的情况，那么之前遍历到的时间中就必定有这个时间，那么答案就会更小，而如果有联通时间比这个大的话那么这个时间下已经保持联通，再加边也没有用，不如这个更小的时间<br />\n虽然前面合并的时候有一些对联通无用的重复边被加上了，但这并不影响答案，因为我们不求和，而是求一个满足条件的最小值，时间是一点点流逝的，修建公路是同步进行的，修这些无用的公路之时也在修有用的公路，所以这些重复边对答案没有影响<br />\n这个题与<br />\nP1396 营救</p>\n<p>来自 <a href=\"https://www.luogu.com.cn/problem/P1396\" rel=\"noopener nofollow\" target=\"_blank\">https://www.luogu.com.cn/problem/P1396</a><br />\n有相似之处</p>\n<h3 id=\"p1396-营救\">P1396 营救</h3>\n<p>来自 <a href=\"https://www.luogu.com.cn/problem/P1396\" rel=\"noopener nofollow\" target=\"_blank\">https://www.luogu.com.cn/problem/P1396</a></p>\n<p>这是个重点题<br />\n题目的意思是说找一条从<span class=\"math inline\">\\(s\\)</span>到<span class=\"math inline\">\\(t\\)</span>的路径使其边权的最大值是所有每条<span class=\"math inline\">\\(s\\)</span>到<span class=\"math inline\">\\(t\\)</span>的路径中边权最大值最小的那个<br />\n就是说<span class=\"math inline\">\\(s\\)</span>到<span class=\"math inline\">\\(t\\)</span>的某条路径权值是这条<span class=\"math inline\">\\(s\\)</span>到<span class=\"math inline\">\\(t\\)</span> 路径中边权的最大值<br />\n而要求一条路径使其权值最小，输出这个最小值</p>\n<p>而最小值最大是指<span class=\"math inline\">\\(s\\)</span>到<span class=\"math inline\">\\(t\\)</span>某条路径权值是这条路径中边权的最小值<br />\n要求1条路径使得权值最大</p>\n<p>也可以按边权从小到大排序，从小开始合并，直到刚好<span class=\"math inline\">\\(s\\)</span>到<span class=\"math inline\">\\(t\\)</span>联通，输出这个权值</p>\n<p>为什么成立呢？</p>\n<p>考虑这个权值显然是这里<span class=\"math inline\">\\(s\\)</span>到<span class=\"math inline\">\\(t\\)</span>边权中的最大值，但如何保证它是所有路径中最小的？<br />\n假设还有联通路径的最大值比这个还小，那么这条路径的所有边权都比这个还小，那么它们应该在这个的前面访问到，如果前面能构成联通，那么就会更早选择，而不会选择这个，所以是这个最小的</p>\n<p>最小值最大就应该从大到小排序合并到刚好联通为止<br />\n而这个权值也是当前路径的最小值。<br />\n假设还有联通路径的最小值比这个还大，那么路径所有边权都比这个大，那么它们就会在这个之前访问，若能构成联通就会更早选择，可是选择了这个就说明没有比这个还大的解</p>\n<h3 id=\"p2330-scoi2005繁忙的都市\">P2330 [SCOI2005]繁忙的都市</h3>\n<p>来自 <a href=\"https://www.luogu.com.cn/problem/P2330\" rel=\"noopener nofollow\" target=\"_blank\">https://www.luogu.com.cn/problem/P2330</a></p>\n<p>改造的道路尽量少就是要刚好保持联通不要有无用的边<br />\n所以从小到大排序合并时如果当前的两个点已经在一个并查集中就说明这条边无用，不要统计数量，跳过</p>\n<h3 id=\"p2121-拆地毯\">P2121 拆地毯</h3>\n<p>来自 <a href=\"https://www.luogu.com.cn/problem/P2121\" rel=\"noopener nofollow\" target=\"_blank\">https://www.luogu.com.cn/problem/P2121</a></p>\n<p>不要求联通，只是要求取的点不能有环<br />\n所以就像星球大战那样先把所有边拆掉，然后按权值从大到小排序<br />\n注意这里统计和，从大到小遍历，把当前两个点合并，如果发现已经在一个并查集就说明已经联通，再加边就会形成环，就不要把这个权值加进去</p>\n<p>一直加到<span class=\"math inline\">\\(k\\)</span>个真正的地毯（不成环），输出和<br />\n因为这是从大到小最大的<span class=\"math inline\">\\(k\\)</span>个或是除去一些之后最大的<span class=\"math inline\">\\(k\\)</span>个<br />\n所以和是最大的</p>\n\n</div>\n<div id=\"MySignature\">\n    <p>黄粱一梦，终是一空</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/hicode002/\" target=\"_blank\">hicode002</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/hicode002/p/-/union_set\" target=\"_blank\">https://www.cnblogs.com/hicode002/p/-/union_set</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-27 19:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hicode002\">hicode002</a>&nbsp;\n阅读(<span id=\"post_view_count\">13</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "请在vscode中使用opencode",
      "link": "https://www.cnblogs.com/zer0Black/p/19535702",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zer0Black/p/19535702\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 19:32\">\n    <span>请在vscode中使用opencode</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>使用Opencode时，通常需要处理文件，使用Vscode编辑器可以在内部同时操作opencode和查看相关文件（如果经常使用的是office文件，可以使用open插件打开）</p>\n<p>！<strong>如果你同时用其他编辑器写代码慎用</strong>，如IDEA和VSCODE同时打开代码，代码编译会出现冲突</p>\n<h1 id=\"安装\">安装</h1>\n<h3 id=\"安装vscode\">安装Vscode</h3>\n<p>直接下载安装即可，官网地址为<br />\n<a href=\"https://code.visualstudio.com/\" rel=\"noopener nofollow\" target=\"_blank\">Visual Studio Code - The open source AI code editor</a></p>\n<h3 id=\"安装插件\">安装插件</h3>\n<h4 id=\"安装opencode插件\">安装Opencode插件</h4>\n<p><img alt=\"file-20260126211848481\" class=\"lazyload\" /></p>\n<h4 id=\"安装open插件\">安装open插件</h4>\n<p>该插件用于打开非代码格式的文件<br />\n<img alt=\"file-20260126205632445\" class=\"lazyload\" /></p>\n<p>安装后，可使用右键<code>Open with default application</code>打开xlsx、docx、pptx等文件<br />\n<img alt=\"file-20260126205659790\" class=\"lazyload\" /></p>\n<h1 id=\"如何使用\">如何使用</h1>\n<h3 id=\"打开vscode\">打开Vscode</h3>\n<p>Opencode会以你打开的文件夹作为根目录界定工作范围</p>\n<p>在需要工作的文件夹，右键打开Vscode</p>\n<p><img alt=\"file-20260126210555856\" class=\"lazyload\" /></p>\n<h3 id=\"在vscode中打开opencode\">在Vscode中打开opencode</h3>\n<p><img alt=\"file-20260126212027716\" class=\"lazyload\" /></p>\n<h4 id=\"在opencode中如何换行\">在opencode中如何换行？</h4>\n<p>如果用的是windows的终端，使用<code>ctrl+enter</code>换行</p>\n<p>如果用的vscode中打开，使用<code>alt+enter</code>换行</p>\n<p><img alt=\"file-20260126212225038\" class=\"lazyload\" /></p>\n<h4 id=\"如何复制粘贴\">如何复制粘贴</h4>\n<p>复制：左键涂抹要复制的内容，松开鼠标自动复制<br />\n粘贴：右键粘贴</p>\n<h1 id=\"其他\">其他</h1>\n<h3 id=\"windows11右键菜单恢复\">windows11右键菜单恢复</h3>\n<p>执行如下命令：</p>\n<pre><code># 先执行我\nreg.exe add \"HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32\" /f /ve\n\n# 再执行我\ntaskkill /f /im explorer.exe &amp; start explorer.exe\n</code></pre>\n<p>改为原始菜单模式，去掉显示更多选项<br />\n<img alt=\"file-20260126202356705\" class=\"lazyload\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-27 19:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zer0Black\">锅总的程序人生</a>&nbsp;\n阅读(<span id=\"post_view_count\">32</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "PostgreSQL：新增语句：特殊处理：ON CONFLICT ... DO (UPDATE SET ...)/(NOTHING)",
      "link": "https://www.cnblogs.com/kakarotto-chen/p/19538290",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kakarotto-chen/p/19538290\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 15:16\">\n    <span>PostgreSQL：新增语句：特殊处理：ON CONFLICT ... DO (UPDATE SET ...)/(NOTHING)</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n            <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1普通的insert-into\">1、普通的insert into</h2>\n<ul>\n<li>如果（主键/唯一建）存在，则会报错</li>\n<li>新需求：就算冲突也不报错，用其他处理逻辑</li>\n</ul>\n<h2 id=\"2基本语法insert-into--on-conflict--do-update-set-nothing\">2、基本语法（INSERT INTO ... ON CONFLICT (...) DO (UPDATE SET ...)/(NOTHING)）</h2>\n<ul>\n<li>语法图</li>\n</ul>\n<div class=\"mermaid\">flowchart TD\n    A[开始: INSERT发生主键/唯一冲突] --&gt; B{冲突后的期望是?}\n    B --&gt;|“保留旧数据，&lt;br&gt;静默跳过”| C[使用 ON CONFLICT DO NOTHING]\n    B --&gt;|“用新数据替换或修改旧数据”| D[使用 ON CONFLICT DO UPDATE SET]\n    \n    D --&gt; E{需要精细控制吗?}\n    E --&gt;|“是，只更新部分字段”| F[在SET中仅指定目标字段]\n    E --&gt;|“是，需满足条件才更新”| G[添加WHERE子句]\n    E --&gt;|“否，全量覆盖”| H[使用EXCLUDED.*或指定所有字段]\n</div><ul>\n<li>🔀 两种核心处理逻辑<br />\n为了方便你对比和理解，我将它们总结在下表中：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">处理逻辑</th>\n<th style=\"text-align: left;\">关键字</th>\n<th style=\"text-align: left;\">核心行为与目的</th>\n<th style=\"text-align: left;\">类比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>1. 静默放弃</strong></td>\n<td style=\"text-align: left;\"><strong><code>DO NOTHING</code></strong></td>\n<td style=\"text-align: left;\">如果冲突（数据已存在），就<strong>什么也不做</strong>，静默地保留现有数据，并让语句成功结束。</td>\n<td style=\"text-align: left;\"><strong>“无视”</strong>：看到店里已有同样的商品，就决定不放了，直接离开。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>2. 更新覆盖</strong></td>\n<td style=\"text-align: left;\"><strong><code>DO UPDATE SET ...</code></strong></td>\n<td style=\"text-align: left;\">如果冲突（数据已存在），就用<strong>新值更新</strong>已有的那条记录。</td>\n<td style=\"text-align: left;\"><strong>“置换”</strong>：看到店里已有同样的商品，就用你手里的新款替换掉旧款。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>语法1：DO UPDATE SET</li>\n</ul>\n<pre><code class=\"language-sql\">INSERT INTO 表名 (列1, 列2, ...)\nVALUES (值1, 值2, ...)\nON CONFLICT (冲突列[可以多个]) \nDO UPDATE SET\n    列1 = EXCLUDED.列1,\n    列2 = EXCLUDED.列2,\n    ...;\n</code></pre>\n<ul>\n<li>语法2：DO NOTHING</li>\n</ul>\n<pre><code class=\"language-sql\">INSERT INTO table_name (column1, column2, ...)\nVALUES (value1, value2, ...)\nON CONFLICT (冲突列[可以多个])\nDO NOTHING;\n</code></pre>\n<h2 id=\"3示例\">3、示例</h2>\n<h3 id=\"31简单示例\">3.1、简单示例</h3>\n<pre><code class=\"language-sql\">-- 示例1: DO NOTHING - 确保数据唯一，重复则忽略\n-- 场景：收集用户邮箱，同一邮箱只记录第一次出现\nINSERT INTO user_emails (email, collected_at, source)\nVALUES ('alice@example.com', NOW(), '官网抽奖')\nON CONFLICT (email) \nDO NOTHING; -- 如果邮箱已存在，则静默跳过，不报错\n\n-- 示例2: DO UPDATE SET - 用最新信息覆盖旧记录\n-- 场景：更新用户的最后登录状态\nINSERT INTO user_sessions (user_id, last_login_ip, last_login_time, login_count)\nVALUES (123, '192.168.1.100', NOW(), 1)\nON CONFLICT (user_id) \nDO UPDATE SET\n    last_login_ip = EXCLUDED.last_login_ip, -- 使用本次尝试插入的新IP\n    last_login_time = EXCLUDED.last_login_time, -- 更新时间\n    login_count = user_sessions.login_count + 1; -- 在原有次数上累加\n</code></pre>\n<h3 id=\"32on-conflict-多列组合唯一约束示例\">3.2、ON CONFLICT 多列组合唯一约束示例</h3>\n<p><strong>场景说明</strong><br />\n假设我们有一个<strong>学生选课记录表</strong>，设计逻辑是：</p>\n<ul>\n<li>单个学生可以选多门课</li>\n<li>单门课程可以被多个学生选</li>\n<li>但 <strong>一个学生不能重复选同一门课</strong>（即 <code>(student_id, course_id)</code> 组合必须唯一）</li>\n</ul>\n<p><strong>示例表结构</strong></p>\n<pre><code class=\"language-sql\">CREATE TABLE student_courses (\n    -- 自增主键，但不是业务唯一键\n    id SERIAL PRIMARY KEY,\n    student_id INT NOT NULL,\n    course_id INT NOT NULL,\n    selected_at TIMESTAMP DEFAULT NOW(),\n    status VARCHAR(20) DEFAULT 'active',\n\n    -- 关键：为(student_id, course_id)创建组合唯一约束\n    CONSTRAINT unique_student_course UNIQUE (student_id, course_id)\n);\n</code></pre>\n<p><strong>示例数据</strong><br />\n假设表中已有数据：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>student_id</th>\n<th>course_id</th>\n<th>selected_at</th>\n<th>status</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1001</td>\n<td>101</td>\n<td>2024-01-01</td>\n<td>active</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1001</td>\n<td>102</td>\n<td>2024-01-02</td>\n<td>active</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1002</td>\n<td>101</td>\n<td>2024-01-03</td>\n<td>active</td>\n</tr>\n</tbody>\n</table>\n<p><strong>场景1：尝试重复选课 → 使用 DO NOTHING</strong><br />\n学生1001想再次选择课程101（已存在），我们静默拒绝：</p>\n<pre><code class=\"language-sql\">INSERT INTO student_courses (student_id, course_id, selected_at)\nVALUES (1001, 101, NOW()) -- (1001,101)组合已存在！\nON CONFLICT (student_id, course_id) -- 指定两列组合为冲突目标\nDO NOTHING; -- 什么都不做，防止重复选课\n\n-- 结果：语句执行成功，但没有插入新行\n-- 表数据保持不变\n</code></pre>\n<p><strong>场景2：尝试重复选课 → 使用 DO UPDATE SET</strong><br />\n学生1001重复选课101，但我们允许更新选择时间和状态：</p>\n<pre><code class=\"language-sql\">INSERT INTO student_courses (student_id, course_id, selected_at, status)\nVALUES (1001, 101, NOW(), 'renewed') -- 再次尝试选择已选课程\nON CONFLICT (student_id, course_id) -- 检测(student_id, course_id)组合冲突\nDO UPDATE SET\n    selected_at = EXCLUDED.selected_at, -- 更新时间戳\n    status = EXCLUDED.status, -- 更新状态\n    id = student_courses.id -- 保持原id不变，避免主键冲突\n    \nRETURNING *; -- 返回更新后的行\n\n-- 结果：不会创建新行，而是更新id=1的记录\n-- 将selected_at更新为当前时间，status更新为'renewed'\n</code></pre>\n<p><strong>场景3：混合情况处理</strong><br />\n批量插入选课记录，处理各种冲突情况：</p>\n<pre><code class=\"language-sql\">INSERT INTO student_courses (student_id, course_id, selected_at)\nVALUES \n    (1001, 103, NOW()), -- 新组合：插入成功\n    (1001, 101, NOW()), -- 已存在组合：触发ON CONFLICT\n    (1002, 102, NOW())  -- 新组合：插入成功\nON CONFLICT (student_id, course_id)\nDO UPDATE SET\n    selected_at = EXCLUDED.selected_at,\n    status = 'refreshed'\nRETURNING student_id, course_id, selected_at;\n</code></pre>\n<p><strong>输出结果可能：</strong></p>\n<pre><code> student_id | course_id |       selected_at       \n------------+-----------+-------------------------\n       1001 |       103 | 2024-06-15 10:30:00.000  -- 新插入\n       1001 |       101 | 2024-06-15 10:30:00.000  -- 更新（冲突处理）\n       1002 |       102 | 2024-06-15 10:30:00.000  -- 新插入\n</code></pre>\n<h3 id=\"33其他多列唯一约束示例\">3.3、其他多列唯一约束示例</h3>\n<p>示例1：会议室预订系统</p>\n<pre><code class=\"language-sql\">-- 确保同一会议室在同一时间段不被重复预订\n-- 唯一约束：(room_id, date, time_slot)\nINSERT INTO room_bookings (room_id, date, time_slot, booker_name)\nVALUES (101, '2024-06-20', '09:00-10:00', '张三')\nON CONFLICT (room_id, date, time_slot)\nDO NOTHING; -- 时间段冲突则直接拒绝\n</code></pre>\n<p><strong>示例2：用户-产品评分表</strong></p>\n<pre><code class=\"language-sql\">-- 确保一个用户对同一产品只能评分一次\n-- 唯一约束：(user_id, product_id)\nINSERT INTO product_ratings (user_id, product_id, rating, review)\nVALUES (5001, 3005, 5, '非常好用')\nON CONFLICT (user_id, product_id)\nDO UPDATE SET\n    rating = EXCLUDED.rating,\n    review = EXCLUDED.review,\n    rated_at = NOW();\n</code></pre>\n<p><strong>关键要点总结</strong></p>\n<ol>\n<li><strong>语法格式</strong>：<code>ON CONFLICT (column1, column2, ...)</code> 用括号包含多个列</li>\n<li><strong>约束要求</strong>：这些列必须已定义组合唯一约束（可以是复合主键或复合唯一约束）</li>\n<li><strong>冲突检测</strong>：只有当<strong>所有指定列的值都完全匹配</strong>时，才被认为是冲突</li>\n<li><strong>常见场景</strong>：多对多关系表、时间-资源组合、用户-实体关联表等</li>\n</ol>\n<p>这种多列约束特别适合处理<strong>业务层面的组合唯一性要求</strong>，而不仅仅是技术上的主键唯一性。</p>\n<h2 id=\"4特殊参数解析冲突列可以多个\">4、特殊参数解析：冲突列[可以多个]</h2>\n<ul>\n<li>ON CONFLICT 后面必须指定一个：唯一约束（主键也可以）字段\n<ul>\n<li>多个字段唯一也可以</li>\n</ul>\n</li>\n</ul>\n<p><strong>关键机制</strong>：</p>\n<ul>\n<li>\n<p><strong>冲突目标</strong>：<code>ON CONFLICT</code> 后面必须指定一个<strong>唯一约束</strong>，通常是主键或唯一索引。当插入的数据在这个约束上与已有数据冲突时，就会触发 <code>UPDATE</code> 操作。</p>\n</li>\n<li>\n<p><strong>约束要求：这些列必须已定义组合唯一约束（可以是复合主键或复合唯一约束）</strong></p>\n</li>\n<li>\n<p><strong>EXCLUDED 伪表</strong>：在 <code>DO UPDATE SET</code> 子句中，你可以使用 <code>EXCLUDED.列名</code> 来引用<strong>本次尝试插入但发生了冲突的那些值</strong>，这是实现“用新值覆盖旧值”的关键。</p>\n</li>\n</ul>\n<h2 id=\"returning参数见下篇\">RETURNING参数，见下篇</h2>\n\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-01-27 15:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kakarotto-chen\">C_C_菜园</a>&nbsp;\n阅读(<span id=\"post_view_count\">63</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "langchain 快速入门(六)：实现多agent协作",
      "link": "https://www.cnblogs.com/ClownLMe/p/19538384",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19538384\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 14:27\">\n    <span>langchain 快速入门(六)：实现多agent协作</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简介\">简介</h1>\n<p><strong>多Agent协作</strong>能够将一个复杂的任务拆解成一个个子任务给专门的agent，能够解决复杂问题，实现复杂的ai工作流。</p>\n<h1 id=\"多agent协作\">多Agent协作</h1>\n<p>不同的Agent，有不同的能力，我们可能会有各种实际需求，例如：实时识别车牌位置（Yolo）-&gt;识别车牌内容（qwen-vl）-&gt; LLM管理记录车牌信息。通过多Agent协作的工作流，能够实现拍照答题，自动剪辑，ppt生成等一系列复杂问题。</p>\n<p>下面用一个简单的案例，来说明。</p>\n<h1 id=\"简单的多agent协作\">简单的多Agent协作</h1>\n<h3 id=\"示例\">示例</h3>\n<p>需求：查一下阿里、腾讯、百度的PE，并计算平均值。</p>\n<pre><code class=\"language-python\">import os\nimport operator\nfrom pydantic import BaseModel, Field\nfrom langchain_community.chat_models.tongyi import ChatTongyi\nfrom langchain_core.tools import tool\nfrom langchain_core.messages import HumanMessage, BaseMessage, ToolMessage, SystemMessage\nfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder\nfrom typing import Annotated, List, Literal, TypedDict\nfrom langgraph.graph import StateGraph, END\n\nos.environ[\"DASHSCOPE_API_KEY\"] = \"apikey\"\nllm = ChatTongyi(model=\"qwen-plus\")\n\n@tool\ndef web_search(query: str):\n    \"\"\"用于查找最新的股票数据、公司财报信息。\"\"\"\n    results = []\n    if \"阿里\" in query: results.append(\"阿里巴巴(BABA) PE: 15.5\")\n    if \"腾讯\" in query: results.append(\"腾讯控股(0700) PE: 18.2\")\n    if \"百度\" in query: results.append(\"百度(BIDU) PE: 11.8\")\n    \n    if not results:\n        return \"未找到数据\"\n    return \" ; \".join(results)\n\n@tool\ndef python_calculator(code: str):\n    \"\"\"用于计算。输入必须是 python 代码。\"\"\"\n    try:\n        result = eval(code)\n        return f\"计算结果: {result}\"\n    except Exception as e:\n        return f\"计算错误: {e}\"\n\ndef create_agent(state: dict, llm, tools, system_prompt):\n    llm_tools = llm.bind_tools(tools)\n    \n    prompt = [SystemMessage(content=system_prompt)] + state[\"messages\"]\n    response = llm_tools.invoke(prompt)\n\n    results = [response]\n\n    for tool_call in response.tool_calls:\n        func_name = tool_call[\"name\"]\n        args = tool_call[\"args\"]\n        call_id = tool_call[\"id\"]\n        \n        func = next((t for t in tools if t.name == func_name), None)\n\n        if func:\n            tool_output = func.invoke(args)\n            tool_msg = ToolMessage(\n                content=str(tool_output),\n                name=func_name,\n                tool_call_id=call_id\n            )\n            results.append(tool_msg)\n\n    return {\"messages\": results}\n\nclass State(TypedDict):\n    messages: Annotated[List[BaseMessage], operator.add]\n    next: str\n\ndef researcher_node(state):\n    return create_agent(\n        state=state,\n        llm=llm,\n        tools=[web_search],\n        system_prompt=\"你是一个研究员。只负责查数据，找到数据后直接输出原话，不需要计算。\"\n    )\n\ndef coder_node(state):\n    return create_agent(\n        state=state,\n        llm=llm,\n        tools=[python_calculator],\n        system_prompt=\"你是一个程序员。根据上面研究员查到的数据，写代码计算平均值。\"\n    )\n\ndef finish_node(state):\n    return create_agent(\n        state=state,\n        llm=llm,\n        tools=[],\n        system_prompt=\"任务完成，简短的总结最终结果。\"\n    )\n\ndef supervisor_node(state):\n    system_prompt = (\n        \"你是项目经理。根据对话历史决定下一步交给谁。\"\n        \"查数据找 Researcher，计算找 Coder，识别图片找 Photographer。\"\n        \"如果任务完成，必须选择 FINISH。\"\n    )\n\n    prompt = ChatPromptTemplate.from_messages([\n        (\"system\", system_prompt),\n        MessagesPlaceholder(variable_name=\"messages\"),\n        (\"system\", \"根据以上情况，请做出选择。\"),\n    ])\n\n    class RouteResponse(BaseModel):\n        next: Literal[\"Researcher\", \"Coder\", \"FINISH\"] = Field(\n            ..., \n            description=\"下一步交给谁？如果任务完成请选 FINISH\"\n        )\n\n    chain = prompt | llm.with_structured_output(RouteResponse)\n\n    response = chain.invoke(state)\n\n    return {\"next\": response.next}\n\ndef init_agent():\n    workflow = StateGraph(State)\n    workflow.add_node(\"Researcher\", researcher_node)\n    workflow.add_node(\"Coder\", coder_node)\n    workflow.add_node(\"Supervisor\", supervisor_node)\n    workflow.add_node(\"Finish\", finish_node)\n\n    workflow.add_edge(\"Researcher\", \"Supervisor\")\n    workflow.add_edge(\"Coder\", \"Supervisor\")\n    workflow.add_edge(\"Finish\", END)\n    workflow.add_conditional_edges(\n        \"Supervisor\",\n        lambda state: state[\"next\"],{\n        \"Researcher\": \"Researcher\",\n        \"Coder\": \"Coder\",\n        \"FINISH\": \"Finish\",\n    })\n\n    workflow.set_entry_point(\"Supervisor\")\n\n    return workflow.compile()\n\nif __name__ == \"__main__\":\n    agent = init_agent()\n    for result in agent.stream({\n        \"messages\": [HumanMessage(content=\"查一下阿里、腾讯、百度的PE，并计算平均值。\")]\n        }):\n        for key, value in result.items():\n            if key == \"Supervisor\":\n                print(\"[\" + key + \"] 去向: \" + value[\"next\"])\n            else:\n                print(\"[\" + key + \"] 回复: \" + value['messages'][-1].content)\n\n</code></pre>\n<h3 id=\"代码解释\">代码解释</h3>\n<p>代码一共用到了4个agent：</p>\n<ol>\n<li>agent Researcher，其有一个工具，负责搜索某些内容</li>\n<li>agent coder，其有一个工具，负责进行精确计算</li>\n<li>agent finish，其没有工具，负责总结内容</li>\n<li>agent Supervisor，其没有工具，负责管理上面3个agent，决定任务的去向<br />\n上面案例使用的是langgraph组件，这里就不详细讲解了，请看之前文章。</li>\n</ol>\n<p><strong>代码流程：</strong> 初始化工具库-&gt;初始化agent-&gt;构建图-&gt;运行</p>\n<h3 id=\"初始化工具库\">初始化工具库</h3>\n<pre><code class=\"language-python\">@tool\ndef web_search(query: str):\n    \"\"\"用于查找最新的股票数据、公司财报信息。\"\"\"\n    results = []\n    if \"阿里\" in query: results.append(\"阿里巴巴(BABA) PE: 15.5\")\n    if \"腾讯\" in query: results.append(\"腾讯控股(0700) PE: 18.2\")\n    if \"百度\" in query: results.append(\"百度(BIDU) PE: 11.8\")\n    \n    if not results:\n        return \"未找到数据\"\n    return \" ; \".join(results)\n\n@tool\ndef python_calculator(code: str):\n    \"\"\"用于计算。输入必须是 python 代码。\"\"\"\n    try:\n        result = eval(code)\n        return f\"计算结果: {result}\"\n    except Exception as e:\n        return f\"计算错误: {e}\"\n</code></pre>\n<p>这里的<code>web_search</code>使用的是虚假的模拟信息，上面的工具描述不够完整，但是能用，如果用实际案例，请描述完整，工具的描述参考之前文章。</p>\n<h1 id=\"初始化agent\">初始化agent</h1>\n<h5 id=\"其他3个agent\">其他3个agent</h5>\n<pre><code class=\"language-python\">def create_agent(state: dict, llm, tools, system_prompt):\n    llm_tools = llm.bind_tools(tools)\n    \n    prompt = [SystemMessage(content=system_prompt)] + state[\"messages\"]\n    response = llm_tools.invoke(prompt)\n\n    results = [response]\n\n    for tool_call in response.tool_calls:\n        func_name = tool_call[\"name\"]\n        args = tool_call[\"args\"]\n        call_id = tool_call[\"id\"]\n        \n        func = next((t for t in tools if t.name == func_name), None)\n\n        if func:\n            tool_output = func.invoke(args)\n            tool_msg = ToolMessage(\n                content=str(tool_output),\n                name=func_name,\n                tool_call_id=call_id\n            )\n            results.append(tool_msg)\n\ndef researcher_node(state):\n    return create_agent(\n        state=state,\n        llm=llm,\n        tools=[web_search],\n        system_prompt=\"你是一个研究员。只负责查数据，找到数据后直接输出原话，不需要计算。\"\n    )\n\ndef coder_node(state):\n    return create_agent(\n        state=state,\n        llm=llm,\n        tools=[python_calculator],\n        system_prompt=\"你是一个程序员。根据上面研究员查到的数据，写代码计算平均值。\"\n    )\n\ndef finish_node(state):\n    return create_agent(\n        state=state,\n        llm=llm,\n        tools=[],\n        system_prompt=\"任务完成，简短的总结最终结果。\"\n    )\n</code></pre>\n<p>流程相对简单，<code>create_agent</code>细节前面文章已经讲解，这里就不废话了。</p>\n<h5 id=\"管理agent\">管理agent</h5>\n<pre><code class=\"language-python\">def supervisor_node(state):\n    system_prompt = (\n        \"你是项目经理。根据对话历史决定下一步交给谁。\"\n        \"查数据找 Researcher，计算找 Coder，识别图片找 Photographer。\"\n        \"如果任务完成，必须选择 FINISH。\"\n    )\n\n    prompt = ChatPromptTemplate.from_messages([\n        (\"system\", system_prompt),\n        MessagesPlaceholder(variable_name=\"messages\"),\n        (\"system\", \"根据以上情况，请做出选择。\"),\n    ])\n\n    class RouteResponse(BaseModel):\n        next: Literal[\"Researcher\", \"Coder\", \"FINISH\"] = Field(\n            ..., \n            description=\"下一步交给谁？如果任务完成请选 FINISH\"\n        )\n\n    chain = prompt | llm.with_structured_output(RouteResponse)\n\n    response = chain.invoke(state)\n\n    return {\"next\": response.next}\n</code></pre>\n<p>这一步需要简单说明：</p>\n<pre><code class=\"language-python\">class RouteResponse(BaseModel):\n    next: Literal[\"Researcher\", \"Coder\", \"FINISH\"] = Field(\n        ..., \n        description=\"下一步交给谁？如果任务完成请选 FINISH\"\n    )\nchain = prompt | llm.with_structured_output(RouteResponse)\n</code></pre>\n<ul>\n<li>LLM中的<code>with_structured_output</code>方法是langchain提供的一个组件，功能是，限定LLM的输出格式，返回相应格式的字典。</li>\n<li>定义输出格式限定的类：</li>\n</ul>\n<ol>\n<li>该类是<code>BaseModel</code>的子类</li>\n<li><code>Literal</code>是选择，要求ai从<code>\"Researcher\", \"Coder\", \"FINISH\"</code>三选一</li>\n<li><code>Field</code>描述变量，尽量详尽，描述+例子，因为是给大模型看的</li>\n</ol>\n<pre><code class=\"language-python\">class classname(BaseModel):\n\tfieldname: fieldtype = Field(..., description=\"描述\")\n</code></pre>\n<h3 id=\"构建图重要\">构建图（重要）</h3>\n<pre><code class=\"language-python\">def init_agent():\n    workflow = StateGraph(State)\n    workflow.add_node(\"Researcher\", researcher_node)\n    workflow.add_node(\"Coder\", coder_node)\n    workflow.add_node(\"Supervisor\", supervisor_node)\n    workflow.add_node(\"Finish\", finish_node)\n\n    workflow.add_edge(\"Researcher\", \"Supervisor\")\n    workflow.add_edge(\"Coder\", \"Supervisor\")\n    workflow.add_edge(\"Finish\", END)\n    workflow.add_conditional_edges(\n        \"Supervisor\",\n        lambda state: state[\"next\"],{\n        \"Researcher\": \"Researcher\",\n        \"Coder\": \"Coder\",\n        \"FINISH\": \"Finish\",\n    })\n\n    workflow.set_entry_point(\"Supervisor\")\n\n    return workflow.compile()\n</code></pre>\n<p>这一步相当于连接工作流，构建的流程图如下：</p>\n<pre><code>       +---------------------------+\n       |           开始             |\n       +-------------+-------------+\n                     |\n                     v\n       +---------------------------+\n       |       Supervisor          |&lt;----------------+\n       | (通过当前任务状态，返回next) |                 |\n       +-------------+-------------+                 |\n                     |(根据state中next判断去向)        |\n        _____________|_____________                  |\n       /             |             \\                 |\n      /              |              \\                |\n     v               v               v               |\n+------------+  +------------+  +------------+       |\n| Researcher |  |   Coder    |  |   Finish   |       |\n|  (Agent)   |  |  (Agent)   |  | (Cleanup)  |       |\n+-----+------+  +-----+------+  +-----+------+       |\n      |               |               |              |\n      |               |               v              |\n      |               |         +------------+       |\n      +---------------+         |    END     |       |\n              |                 +------------+       |\n              |                                      |\n              +--------------------------------------+\n                    (返回重新选择下一个agent)\n</code></pre>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-27 14:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">35</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "spring boot3--自动配置与手动配置",
      "link": "https://www.cnblogs.com/alineverstop/p/19537574",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/alineverstop/p/19537574\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 11:50\">\n    <span>spring boot3--自动配置与手动配置</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"springboot自动配置\">springboot自动配置</h1>\n<p>自动配置了大量组件，配置信息可以在application.properties文件中修改。</p>\n<p>当添加了特定的Starter POM后，springboot会根据类路径上的jar包来自动配置bean（比如：springboot发现类路径上的MyBatis相关类，springboot会自动配置MyBatis相关的bean）。</p>\n<p>springboot使用默认配置来设置这些功能，开发人员也可以自定义配置来覆盖默认配置。</p>\n<h2 id=\"这些配置信息如何生效的\">这些配置信息如何生效的？</h2>\n<p>通过@ConfigurationProperties注解将配置信息注入到组件中的属性类的。属性类一般以Properties结尾。比如tomcat组件的ServerProperties类，就是将配置信息中server开头的配置注入到属性中，比如server.port=8080会被绑定到属性中</p>\n<pre><code class=\"language-java\">@ConfigurationProperties(\"server\")\npublic class ServerProperties {\n    private @Nullable Integer port;\n    private @Nullable InetAddress address;\n  .....\n}\n</code></pre>\n<h2 id=\"自动配置是按需加载的\">自动配置是按需加载的</h2>\n<p>springboot提供很多自动配置类，这些自动配置不是全部生效，它是按需加载的，导入了哪个启动器，则该启动器对应的配置类才会被加载。</p>\n<p>任何启动器都会关联一个启动器：spring-boot-Starter，它是springboot框架最核心的启动器。</p>\n<p>spring-boot-Starter又关联引入spring-boot-auto从figure。所有的自动配置类都在这里。</p>\n<p>自动配置类用来创建相应的组件。</p>\n<h2 id=\"按需加载如何实现\">按需加载如何实现？</h2>\n<p>使用条件注解可以实现按需加载。</p>\n<p>条件注解基于某些条件决定是否应该创建一个bean。这些注解通常用在自动配置类上，以确保只有在特定条件满足时才会应用相应的配置。</p>\n<p>条件注解可以用在类上，也可以用在方法上。</p>\n<p>常见的条件注解有：</p>\n<ul>\n<li>@ConditionalOnClass 指定类存在时才创建bean</li>\n<li>@ConditionalOnMissingClass 指定类不存在时才创建bean</li>\n<li>@ConditionalOnBean 容器中存在指定bean时才创建bean</li>\n<li>@ConditionalOnMissingBean 容器中不存在指定bean时才创建bean</li>\n<li>@ConditionalOnProperty 配置文件中存在指定属性时，才创建bean</li>\n<li>@ConditionalOnResource 指定资源存在时才创建bean</li>\n<li>@ConditionalOnWebApplication 应用程序是Web应用时才创建bean</li>\n<li>@ConditionalOnNotWebApplication 应用程序不是Web应用时才创建bean</li>\n</ul>\n<h2 id=\"修改默认的包扫描规则\">修改默认的包扫描规则</h2>\n<p>修改扫描规则有2种方式：</p>\n<p>在主入口类上添加以下注解的任意一个都可以修改包扫描规则（扫描com包及其子孙包）</p>\n<ol>\n<li>\n<pre><code class=\"language-java\">@ComponentScan(\"com\")\n</code></pre>\n</li>\n<li>\n<pre><code class=\"language-java\">@SpringBootApplication(scanBasePackages = \"com\")\n</code></pre>\n</li>\n</ol>\n<h1 id=\"自动配置的实现原理\">自动配置的实现原理</h1>\n<ol>\n<li>\n<p>程序从main方法开始执行，主入口类上使用@SpringBootApplication进行标注</p>\n</li>\n<li>\n<p>@SpringBootApplication是复合注解，代表以下三个注解的功能</p>\n<p>a. @SpringBootConfiguration:它被@Configuration标注。表明主入口类是一个配置类，此时该配置开始加载。</p>\n<p>b. @ComponentScan 默认扫描主入口类所在包及其子孙包，因此spring-boot-autoconfigure 自动配置类是无法加载的，那么这些自动配置类又是怎么生效的呢？</p>\n<p>c. <strong>@EnableAutoConfiguration 该注解的作用就是启用自动配置</strong></p>\n</li>\n<li>\n<p>@EnableAutoConfiguration  被@Import({AutoConfigurationImportSelector.class})标注</p>\n</li>\n</ol>\n<p>​        @Import({AutoConfigurationImportSelector.class})的作用是将AutoConfigurationImportSelector作为一个bean加载到Ioc容器中</p>\n<p>​        这个bean的作用是：负责收集和选择所有符合条件的自动配置类。</p>\n<h2 id=\"总结\">总结</h2>\n<ol>\n<li>运行环境准备阶段\n<ul>\n<li>引入Web启动器</li>\n<li>最终传递引入了自动配置的jar包</li>\n<li>自动配置的jar包中有152个自动配置类，到此运行环境准备完毕</li>\n</ul>\n</li>\n<li>运行阶段\n<ul>\n<li>@EnableAutoConfiguration  启用自动配置，将152个自动配置类全部加载到Ioc容器中。然后根据开发场景筛选出必须得自动配置类</li>\n<li>自动配置类加载了很多组件</li>\n<li>每个组件需要的数据来自属性类</li>\n<li>属性类的属性来自配置文件</li>\n</ul>\n</li>\n</ol>\n<p>总之一句话。导入启动器，修改配置文件。就可以完成对应功能的开发。</p>\n<h1 id=\"springmvc配置\">springmvc配置</h1>\n<pre><code class=\"language-properties\"># 让springboot的静态资源处理失效\nspring.web.resources.add-mappings=false\n# 配置静态资源的访问URL\nspring.mvc.static-path-pattern=/**\n#  静态资源文件存储位置默认配置\nspring.web.resources.static-locations=classpath:/META-INF/resources/, classpath:/resources/, classpath:/static/, classpath:/public/\n\n</code></pre>\n<p>springboot对静态资源是如何处理的？</p>\n<p>什么样的URL ？访问哪个位置上的资源文件？</p>\n<h2 id=\"webjars\">webjars</h2>\n<p>webjars是现在前后端分离中比较重要的一种静态资源打包方式。</p>\n<p>webjars是一种常用的前端库（如jQuery）打包成jar包的形式，方便在java程序中使用。</p>\n<p>webjars提供了一种标准化的方式来管理前端库，使其更容易集成到java项目中，并且可以利用Maven的依赖管理功能。</p>\n<pre><code class=\"language-xml\">&lt;!--        webjars,将前端库打成jar包--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.webjars.npm&lt;/groupId&gt;\n            &lt;artifactId&gt;vue&lt;/artifactId&gt;\n            &lt;version&gt;3.5.12&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>默认规则是：当请求路径是/wbjars/**,则会去classpath:/MEAT-INF/resources/webjars/找。</p>\n<h2 id=\"静态资源缓存处理\">静态资源缓存处理</h2>\n<p>静态资源缓存是指浏览器的缓存行为，浏览器可以缓存（js、CSS、图片、声音、视频）到浏览器中，下一次用户访问同样的资源就直接从缓存中获取，不再从服务器获取，这样能减少服务器压力，提高相应效率。</p>\n<p>可以通过配置来修改默认的缓存机制。</p>\n<pre><code class=\"language-properties\">＃静态资源缓存设置\n＃缓存有效期设置\nspring.web.resources.cache.period=3600\n# 缓存控制设置\nspring.web.resources.cache.cachecontrol.max-age=20\n# 是否启用最后一次修改时间的比对\nspring.web.resources.cache.use-last-modified=true\n</code></pre>\n<h2 id=\"静态indexhtml的支持\">静态index.html的支持</h2>\n<p>spring会自动处理位于静态资源目录下的index.html（文件名必须是index.html），使其成为应用程序的主页。</p>\n<p>注意：此时不能配置静态资源访问url（spring.mvc.static-path-pattern），必须使用默认的配置</p>\n<h2 id=\"faviconico\">favicon.ico</h2>\n<p>将favicon.ico放在静态资源根目录下，就会自动生效。</p>\n<h1 id=\"spring-boot的web手动配置静态资源处理\">spring boot的web手动配置（静态资源处理）</h1>\n<h2 id=\"编写代码的方式\">编写代码的方式</h2>\n<h3 id=\"第一种方式-实现webmvcconfigurer接口\">第一种方式 实现WebMvcConfigurer接口</h3>\n<pre><code class=\"language-java\">// 添加这个注解后，表示不再使用springboot提供的默认配置\n// @EnableWebMvc\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    \n    // 静态资源处理需要重写的方法\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        // 使用注册器registry 绑定 pathPatterns 以及真实的静态资源文件存储路径\n        registry.addResourceHandler(\"/abc/**\") // 配置路径访问模式\n                .addResourceLocations(\"classpath:/static1/\", \"classpath:/static2/\", \"classpath:/static3/\"); // 配置静态资源路径\n    }\n}\n</code></pre>\n<h3 id=\"第二种方式\">第二种方式</h3>\n<pre><code class=\"language-java\">@Configuration\npublic class WebConfig2 {\n\n    @Bean\n    public WebMvcConfigurer addResourceHandlers() {\n        return new WebMvcConfigurer() {\n            @Override\n            public void addResourceHandlers(ResourceHandlerRegistry registry) {\n                registry.addResourceHandler(\"/abc/**\") // 配置路径访问模式\n                        .addResourceLocations(\"classpath:/static1/\", \"classpath:/static2/\", \"classpath:/static3/\"); // 配置静态资源路径\n            }\n        };\n    }\n}\n</code></pre>\n<h1 id=\"web请求的路径匹配\">web请求的路径匹配</h1>\n<pre><code class=\"language-properties\"># 前端请求的url 匹配到controller中的某个方法\n# 使用ant风格的路径匹配规则，默认值是path_pattern_matcher\n# path_pattern_matcher兼容且支持ant风格\n# 在ant风格中** 可以出现在任何位置，但在path_pattern_matcher风格中，** 只能出现在末尾\n# spring6 下的ant风格 ** 也只能出现在末尾\nspring.mvc.pathmatch.matching-strategy=ant_path_matcher\n</code></pre>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/alineverstop/\" target=\"_blank\">NE_STOP</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/alineverstop/p/19537574\" target=\"_blank\">https://www.cnblogs.com/alineverstop/p/19537574</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-27 11:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/alineverstop\">NE_STOP</a>&nbsp;\n阅读(<span id=\"post_view_count\">29</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Agent Skills 傻瓜式教程，26 年最火 AI 技术就这？",
      "link": "https://www.cnblogs.com/yupi/p/19537546",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19537546\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 11:47\">\n    <span>Agent Skills 傻瓜式教程，26 年最火 AI 技术就这？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Agent Skills 傻瓜式教程，26 年最火 AI 技术就这？\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202601/2225420-20260127105356424-1456834479.png\" />\n        Agent Skills 不仅仅是个技术概念，更是一种新的工作方式。你可以把它融入到自己的日常工作中，比如把重复的任务封装成技能、把团队的最佳实践固化成技能，让 AI 真正成为你的得力助手。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-heading\"><span class=\"md-plain\">你是小阿巴，正在用 AI 开发网站。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">为了让 AI 生成的效果更好，你告诉 AI：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">界面不要使用蓝紫渐变色</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不要生成一大堆没用的文档</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你要遵循公司的代码规范</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">阿巴阿巴，洋洋洒洒几百字。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">之后每次开发网站时，你都要写这么一段又臭又长的提示词，太麻烦了！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">于是聪明的你开始想办法。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先把常用的提示词保存到单独的文件（比如 <span class=\"md-pair-s\"><code>prompts.md</code><span class=\"md-plain\">），每次手动投喂给 AI。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后创建了资源文件夹，把公司的代码规范、设计素材都塞进去，告诉 AI 参考这些写。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接着你还写了一些脚本，让 AI 生成代码后自动执行格式化、运行测试、提交代码到 Git。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">最后我再写个 <span class=\"md-pair-s\"><code>AGENTS.md</code><span class=\"md-plain\"> 文件，把所有规范和工作流程都写进去，让 AI 自动读取。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你沾沾自喜：嘿嘿，俺这套工作流，堪称完美！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但很快，你发现了问题，随着规范越写越多，文档越来越臃肿，每次对话都要占用很多 AI 上下文空间，浪费 tokens。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">于是你找到号称 “没有人比他更不懂 AI” 的鱼皮求助：阿巴阿巴，俺还能咋办啊……</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：不是有 Agent Skills 么？为啥不直接用？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你一脸懵：啥玩意儿？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：这可是最近 AI 圈儿爆火的技术，下面我来带你玩转 Agent Skills，让你知道它是什么、怎么用、有什么魔力、怎么自己开发。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">点个收藏，我们开始~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">⭐️ 推荐观看视频动画版，更通俗易懂：<span class=\"md-meta-i-c  md-link\"><a href=\"https://www.bilibili.com/video/BV1T7zzBQEaA/\" rel=\"noopener nofollow\"><span class=\"md-plain\">https://bilibili.com/video/BV1T7zzBQEaA</span></a></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">什么是 Agent Skills？</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Agent Skills 是 Anthropic 推出的 <span class=\"md-meta-i-c  md-link\"><a href=\"https://platform.claude.com/docs/zh-CN/agents-and-tools/agent-skills/overview\" rel=\"noopener nofollow\"><span class=\"md-plain\">一套开放标准</span></a><span class=\"md-plain\">，目的是让 AI 能够学习使用各种专业技能，而不用每次都重复输入提示词。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">简单来说，它就是给 AI 装备的 <span class=\"md-pair-s \"><strong>技能包</strong><span class=\"md-plain\">。技能包里有精心设计的提示词、代码脚本、还有各种资源文件。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">把 AI 想象成一个职场小白，给他装上 <span class=\"md-pair-s\"><code>文档处理技能</code><span class=\"md-plain\">，它就立刻知道怎么生成 PPT、处理 Excel 表格；装上 <span class=\"md-pair-s\"><code>代码规范技能</code><span class=\"md-plain\">，它就知道怎么按照公司标准写代码。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你挠挠头：等等…… 这不就是俺在做的事吗？把教 AI 做事的文档和 AI 要用到的文件打包成文件夹？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：差不多，但 Anthropic 把它做成了一个通用标准，而且在实现原理上有一些新花样……</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你捶胸顿足：可恶啊，俺差点就改变世界了！这能有什么新花样？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：我先来带你用一下 Agent Skills，再跟你说说其中的奥秘。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">Agent Skills 入门实战</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">目前对 Agent Skills 支持最完善的工具是 Anthropic 官方的 <span class=\"md-meta-i-c  md-link\"><a href=\"https://claude.com/product/claude-code\" rel=\"noopener nofollow\"><span class=\"md-plain\">Claude Code</span></a><span class=\"md-plain\">，我们就以此为例，安装并使用 Skills。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">1、安装 Skills 技能</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先打开 Claude Code 并输入命令，添加官方技能市场：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/plugin marketplace add anthropics/skills</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这就像是在你的 AI 助手里开通了一个技能商店，接下来你就可以从商店中获取技能了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在 Claude Code 中输入命令，安装官方提供的技能包：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/plugin install example-skills@anthropic-agent-skills</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个 example-skills 包含了一堆官方示例技能，包括前端设计、网页测试、动图制作等等。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">装完之后，你就可以直接让 AI 使用这些技能了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2、前端设计技能</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如你要做一个网站，以前没装技能的时候，AI 生成的代码又是那个熟悉的蓝紫渐变色，千篇一律的 AI 审美。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">现在安装了 frontend-design 这个 <span class=\"md-pair-s \"><strong>教 AI 生成专业设计感网站</strong><span class=\"md-plain\"> 的技能后，你输入：“帮我开发个人作品集网站”。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 会主动问你：我发现你安装了前端设计技能，需要用它来生成更具设计感的页面吗？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">确认之后，AI 会利用技能生成代码，告别蓝紫渐变，生成独特风格的精美页面。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我们不用每次都给 AI 输入一大堆相同的提示词，装一次技能就行了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">3、文档处理技能</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了代码相关的技能，官方还提供了文档处理技能包。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">同样在 Claude Code 中输入一行命令安装：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/plugin install document-skills@anthropic-agent-skills</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个技能包里有 PPT 制作、Word 文档生成、Excel 数据分析、PDF 解析等技能。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来如果你让 AI 做个 PPT，它会自动调用 PPT 制作技能，直接生成排版好的 PPT 文件，帮你节省几个小时。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">揭秘 Agent Skills 内部原理</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你好奇道：咦，为什么 Skills 能做到安装即用？技能包里面到底有啥？AI 又是怎么知道该用哪个技能的？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：好问题。<span class=\"md-meta-i-c  md-link\"><a href=\"https://agentskills.io/what-are-skills\" rel=\"noopener nofollow\"><span class=\"md-plain\">技能</span></a><span class=\"md-plain\"> 其实就是一个包含 <span class=\"md-pair-s\"><code>SKILL.md</code><span class=\"md-plain\"> 技能说明文件的文件夹，还可以包含可执行脚本、资源和参考文档。</span></span></span></span></span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>my-skill/<br /><span>├── SKILL.md &nbsp; &nbsp; &nbsp; &nbsp; # 必需：指令和元数据<br /><span>├── scripts/ &nbsp; &nbsp; &nbsp; &nbsp; # 可选：可执行脚本<br /><span>├── references/ &nbsp; &nbsp; &nbsp; # 可选：参考文档<br /><span>└── assets/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 可选：模板和资源</span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">由于每个技能的复杂度不同，结构也会存在区别。我们可以在本地目录中找到已安装的技能文件夹。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">以官方的 PPT 制作技能为例，它的结构是这样的：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>skills/pptx/<br /><span>├── SKILL.md &nbsp; &nbsp; &nbsp; &nbsp; # 技能说明书（必需）<br /><span>├── ooxml/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # OOXML 相关资源<br /><span>├── scripts/ &nbsp; &nbsp; &nbsp; &nbsp; # 处理脚本<br /><span>├── html2pptx.md &nbsp; &nbsp; # HTML 转 PPT 说明<br /><span>├── ooxml.md &nbsp; &nbsp; &nbsp; &nbsp; # OOXML 格式说明<br /><span>└── LICENSE.txt &nbsp; &nbsp; &nbsp; # 许可证</span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">包含一个核心的技能说明文档 <span class=\"md-pair-s\"><code>SKILL.md</code><span class=\"md-plain\">，还有脚本、参考文档和各种资源文件。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">而 frontend-design 前端设计技能只有一个 <span class=\"md-pair-s\"><code>SKILL.md</code><span class=\"md-plain\"> 文件。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>SKILL.md</code><span class=\"md-plain\"> 文件是每个技能的核心，它包含两个关键部分。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">第一部分是 <span class=\"md-pair-s \"><strong>元数据</strong><span class=\"md-plain\">，用 YAML 格式写在文件开头：</span></span></span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span><span class=\"cm-def\">---<br /><span><span class=\"cm-atom\">name<span class=\"cm-meta\">:&nbsp;frontend-design<br /><span><span class=\"cm-atom\">description<span class=\"cm-meta\">:&nbsp;生成具有专业设计感的前端代码，避免千篇一律的 AI 审美<br /><span><span class=\"cm-def\">---</span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">其中 <span class=\"md-pair-s\"><code>name</code><span class=\"md-plain\"> 是技能的名字。<span class=\"md-pair-s\"><code>description</code><span class=\"md-plain\"> 是技能的描述，告诉 AI 什么时候应该使用这个技能。描述写得越清晰，AI 就越容易在合适的时机调用它。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">第二部分是 <span class=\"md-pair-s \"><strong>指令内容</strong><span class=\"md-plain\">，就是一套经过精心设计的提示词，指导 AI 具体怎么做。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">以 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/anthropics/skills/blob/main/skills/frontend-design/SKILL.md\" rel=\"noopener nofollow\"><span class=\"md-plain\">frontend-design</span></a><span class=\"md-plain\"> 技能为例，它的指令内容包括：</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">设计思考：在写代码前，先分析产品目的、用户群体、技术约束，然后选择一个大胆的美学方向（极简、复古未来、工业风、有机自然、奢华精致等）</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">前端美学指南：包括字体选择（避免 Arial、Inter 等烂大街字体，选择有个性的组合）、配色主题（主色调配鲜明点缀色）、动效设计、空间构成、背景和视觉细节</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">避坑指南：明确禁止紫色渐变、系统字体、千篇一律的布局等 AI 审美陷阱</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你挠了挠头：如果有多个 SKills，AI 怎么知道该用哪个技能呢？如果把每个技能说明文档都塞给 AI，不是很占用上下文么？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：这就要说到 <span class=\"md-pair-s \"><strong>渐进式披露（Progressive Disclosure）</strong><span class=\"md-plain\"> 这个核心机制了。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">当你让 AI 执行任务时，它会先扫描技能目录，但不会把所有内容都加载到上下文中。而是只读取每个技能的元数据（名字和描述），发现描述和任务相关，就知道该用这个技能了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后才把完整的技能说明文档读进来，按照里面的指令执行：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">并根据需要加载技能包中的其他资源：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>用到哪个查哪个</strong><span class=\"md-plain\">，既精准匹配又节省上下文，这就是渐进式披露的精髓。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">所以 Agent Skills 的本质就是 <span class=\"md-pair-s \"><strong>把专业知识打包成一个文件夹，让 AI 按需读取并使用</strong><span class=\"md-plain\">。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">跨工具的 Agent Skills</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你问：除了 Claude Code 之外，其他 AI 工具支持 Agent Skills 么？俺平时用 Cursor 比较多……</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：当然能！<span class=\"md-meta-i-c  md-link\"><a href=\"https://agentskills.io/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Agent Skills</span></a><span class=\"md-plain\"> 已经成为通用标准，Cursor、VS Code、Codex 等工具都支持。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Skills 的社区也非常活跃，你可以在 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.claudeskill.site/zh/skills\" rel=\"noopener nofollow\"><span class=\"md-plain\">Claude Skills Hub 市场</span></a><span class=\"md-plain\">、开源的 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/ComposioHQ/awesome-claude-skills\" rel=\"noopener nofollow\"><span class=\"md-plain\">Awesome Claude Skills</span></a><span class=\"md-plain\"> 等地方找到很多现成的技能。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如有个叫 <span class=\"md-meta-i-c  md-link\"><a href=\"https://ui-ux-pro-max-skill.nextlevelbuilder.io/\" rel=\"noopener nofollow\"><span class=\"md-plain\">UI UX Pro MAX</span></a><span class=\"md-plain\"> 的技能特别火，专门用于提升 AI 的设计能力。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">用法很简单，首先按照 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/nextlevelbuilder/ui-ux-pro-max-skill\" rel=\"noopener nofollow\"><span class=\"md-plain\">开源仓库文档</span></a><span class=\"md-plain\"> 的指引，安装官方提供的命令行工具：</span></span></span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span><span class=\"cm-builtin\">npm&nbsp;install&nbsp;<span class=\"cm-attribute\">-g&nbsp;uipro-cli</span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后进入到你的项目目录下，根据使用的 AI 工具执行对应的命令。比如我这里用 Cursor：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>uipro init&nbsp;<span class=\"cm-attribute\">--ai&nbsp;cursor</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它会自动把技能安装到 Cursor 的配置目录里。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">安装完成后，可以看到它的文件结构：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来，当你让 AI 开发一个网站时，可以使用斜杠命令手动触发技能，或者让 AI 自动识别技能。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）AI 会根据你的需求识别出产品类型和需要的页面类型</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）然后调用 <span class=\"md-pair-s\"><code>search.py</code><span class=\"md-plain\"> 搜索脚本，在 data 目录里进行多维度搜索，找到适合的配色、字体、布局风格</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）综合搜索结果，生成完整的设计方案（主色调、字体组合、间距规范等）</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）最后，再按照设计方案生成代码</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这样一来，生成的界面既专业又有设计感。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 不需要把所有规则都背下来，而是用到哪个查哪个，这就是 Agent Skills 的精髓。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">创建自己的 Agent Skills</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">用了很多别人的技能后，你产生了一个大胆的想法：俺能不能把公司的周报格式封装成一个技能？以后推荐给新来的同事，还能卖个几块钱，嘿嘿嘿~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮笑道：有点儿东西，你打算怎么做呢？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你会心一笑：当然是发挥程序员最擅长的事情 —— 复制粘贴！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">俺先复制一个官方的技能包，修改目录名称为自己的。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后修改技能说明文档 <span class=\"md-pair-s\"><code>SKILL.md</code><span class=\"md-plain\"> 的元数据、指令内容这些关键部分。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">示例 <span class=\"md-pair-s\"><code>SKILL.md</code><span class=\"md-plain\"> 文件：</span></span></span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span><span class=\"cm-hr\">---<br /><span>name: company-weekly-report<br /><span>description: 生成符合公司规范的项目周报，包含进度汇总、问题跟踪和下周计划<br /><span><span class=\"cm-hr\">---<br /><span><span>​<br /><span><span class=\" cm-header cm-header1\"># 公司周报生成技能<br /><span><span>​<br /><span>当用户要求生成周报时，请按以下步骤执行：<br /><span><span>​<br /><span><span class=\" cm-header cm-header2\">## 1. 收集信息<br /><span><span class=\"cm-block-start cm-variable-2\">-&nbsp;<span class=\"cm-variable-2\">询问本周完成的主要工作<br /><span><span class=\"cm-block-start cm-variable-2\">-&nbsp;<span class=\"cm-variable-2\">询问遇到的问题和解决方案<br /><span><span class=\"cm-block-start cm-variable-2\">-&nbsp;<span class=\"cm-variable-2\">询问下周计划<br /><span><span>​<br /><span><span class=\" cm-header cm-header2\">## 2. 格式规范<br /><span><span class=\"cm-block-start cm-variable-2\">-&nbsp;<span class=\"cm-variable-2\">使用公司蓝色主题<br /><span><span class=\"cm-block-start cm-variable-2\">-&nbsp;<span class=\"cm-variable-2\">标题使用微软雅黑加粗<br /><span><span class=\"cm-block-start cm-variable-2\">-&nbsp;<span class=\"cm-variable-2\">每个模块不超过 5 个要点<br /><span><span>​<br /><span><span class=\" cm-header cm-header2\">## 3. 输出格式<br /><span><span class=\"cm-block-start cm-variable-2\">-&nbsp;<span class=\"cm-variable-2\">默认输出 Markdown<br /><span><span class=\"cm-block-start cm-variable-2\">-&nbsp;<span class=\"cm-variable-2\">如需 PPT，调用 pptx 技能</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">最后，把公司的 Logo、PPT 模板、报告样例放在子文件夹里就行了。妈妈再也不用担心我的周报了~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：不错不错，但其实有更简单规范的方法。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在前面安装的 example-skills 官方示例技能包里，有一个叫 <span class=\"md-pair-s\"><code>Skill Creator</code><span class=\"md-plain\"> 的技能，专门用来帮你创建新技能。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你只需要跟 AI 说：“帮我创建一个专门生成公司周报的技能”</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来 AI 会问你几个问题，一步一步回答就好：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你希望周报包含哪些主要部分？</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你希望周报以什么格式输出?</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你通常会如何使用这个周报技能?</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">希望周报的语言风格是什么?</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">很快，一个完整的技能包就生成了，你会看到一个 <span class=\"md-pair-s\"><code>.skill</code><span class=\"md-plain\"> 为后缀的文件，本质上是一个 zip 压缩包。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可以把它解压到你的个人技能目录（<span class=\"md-pair-s\"><code>~/.claude/skills/</code><span class=\"md-plain\">）下，你的所有项目都能用。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你想让这个技能只在某个项目生效，可以把它放到项目的 <span class=\"md-pair-s\"><code>.claude/skills/</code><span class=\"md-plain\"> 目录下，并且利用 Git 同步给项目组其他成员。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">测试没问题后，你还可以把它开源到 GitHub，或者上传到 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.claudeskill.site/zh/skills\" rel=\"noopener nofollow\"><span class=\"md-plain\">Claude Skills Hub</span></a><span class=\"md-plain\"> 这样的社区平台，让所有用户都能用。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">Skills / MCP / 斜杠命令的区别</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你开心极了：原来开发一个 Skills 这么简单！但是，这玩意儿跟之前火爆的 MCP 和斜杠命令有啥区别？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：好问题！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>MCP 就像给 AI 装上了 “手和眼睛”</strong><span class=\"md-plain\">，让 AI 能够连接外部工具和数据源，比如搜索网页、读取代码仓库、查询数据库。适合需要获取数据或操作外部系统的场景。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>而 Agent Skills 更像是给 AI 发了一本 “工作手册”</strong><span class=\"md-plain\">，把专业知识和工作流程打包起来，教 AI 在特定领域该怎么做。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">至于斜杠命令，它就像是快捷键，是需要你手动输入 <span class=\"md-pair-s\"><code>/command</code><span class=\"md-plain\"> 命令来触发的固定操作；而 Skills 的特点是 AI 可以自动识别该用什么技能，不需要你显式调用。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对了，其实 MCP 和 Skills 是可以结合起来的。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">举个例子，如果你想让 AI 帮你发周报：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">MCP 负责获取数据：从任务管理数据库拉取这周的任务列表</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Skills 负责加工数据：把获取到的原始数据整理成老板爱看的格式</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">一个提供食材，一个提供配方。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">Agent Skills 凭什么大火？</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你看着技能文件夹的结构，突然怪叫一声：等等，俺突然意识到一个问题…… 这不就是我们程序员玩烂的 “封装、复用、模块化、懒加载” 那一套吗？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">写几个代码文件、打个包、发到网上，让其他程序员下载下来用，不是一回事儿么？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">为什么 Agent Skills 能突然让整个 AI 圈为之疯狂？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：好问题，从技术的角度来看，它并没有发明什么惊天动地的算法。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在我看来，它能火主要是 2 个原因。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">第一，它是开放标准，封装一次技能包后就能在各种 AI 工具里复用，还能通过社区共享。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">更重要的是，Skills 能立刻让 AI 的工作更专业可靠，让普通人 “无感” 地享受技术带来的价值。以前想让 AI 变聪明，你得学提示词工程、配置各种工具链。现在只需要像装 APP 一样安装技能包，AI 就立刻变专业了。一项技术的成功，不在于它有多复杂，而在于它能让普通用户不关注技术细节的情况下，感受到技术的价值。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">结尾</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你点点头：学会了学废了！降低门槛，才是技术走向大众的钥匙。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：没错，Agent Skills 不仅仅是个技术概念，更是一种新的工作方式。你可以把它融入到自己的日常工作中，比如把重复的任务封装成技能、把团队的最佳实践固化成技能，让 AI 真正成为你的得力助手。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在这个 Vibe Coding 盛行的年代，技术的门槛正在崩塌，而想象力的边界正在无限扩张。你可以在我免费开源的<span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/liyupi/ai-guide\" rel=\"noopener nofollow\"><span class=\"md-plain\">《AI 编程零基础入门教程》</span></a><span class=\"md-plain\">中学到更多 AI 编程技巧，也欢迎关注我的账号，学习更多 AI 和编程的技巧。</span></span></span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">开源指路：<span class=\"md-link md-pair-s\"><a href=\"https://github.com/liyupi/ai-guide\" rel=\"noopener nofollow\">https://github.com/liyupi/ai-guide</a></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">那么问题来了，你最想让 AI 学会什么技能呢？</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-meta-i-c md-link md-expand\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-27 11:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">76</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "面积图的奇妙变形：流图与地平线图",
      "link": "https://www.cnblogs.com/wang_yb/p/19536752",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19536752\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 09:52\">\n    <span>面积图的奇妙变形：流图与地平线图</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>想象一下面积图就像一层层叠起来的彩色玻璃片，每一层代表一个类别，从下往上堆叠，形成整体的视觉冲击。</p>\n<p>但有时我们需要更特别的方式来展示数据的变化：是像河流一样蜿蜒流淌，还是像地平线上的群山连绵起伏？</p>\n<p>今天，本文将介绍两种创意<strong>面积图变体</strong>——<strong>流图</strong>和<strong>地平线图</strong>，它们能让你的时间序列数据讲述更生动的故事。</p>\n<h1 id=\"1-流图数据的河流\">1. 流图：数据的河流</h1>\n<p>如果把传统的堆叠面积图想象成一块块整齐堆叠的积木，那么<strong>流图</strong>就像一条蜿蜒流淌的河流，河道的宽窄变化自然流畅，波峰波谷过渡平滑。</p>\n<p>它特别适合展示多个类别数据随时间的变化趋势，尤其是当你想强调整体流动感和各部分的相对比例变化时。</p>\n<p><strong>流图</strong>的<strong>核心思想</strong>是将传统的堆叠面积图进行\"平滑\"处理。</p>\n<p>在<code>matplotlib</code>中，我们可以使用<code>fill_between</code>函数结合样条插值来创建平滑的边缘。</p>\n<p>关键在于将堆叠的数据进行累积，然后对累积边界进行平滑处理。</p>\n<pre><code class=\"language-python\"># 数据准备\nx = np.linspace(0, 10, 100)\n# 构造三组波浪数据\ny1 = 2 + np.sin(x)            # 基础波动\ny2 = 2 + np.cos(x - 1.5)      # 错位波动\ny3 = 2 + np.sin(x + 2)        # 再次错位\n\n# 省略 ...\n\n# 绘图设置\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))\n\n# --- 左图：普通堆叠面积图 (baseline='zero') ---\nax1.stackplot(x, y_data, labels=labels, colors=colors, baseline='zero', alpha=0.8)\n# 省略 ...\n\n# --- 右图：流图 (baseline='sym') ---\n# 'sym' 表示对称中心布局\nax2.stackplot(x, y_data, labels=labels, colors=colors, baseline='sym', alpha=0.8)\nax2.axhline(0, color='black', ls='--', alpha=0.1) # 画一条中心参考线\n# 省略 ...\n\n# 去除右图边框，增加流动感\nfor spine in ax2.spines.values():\n    spine.set_visible(False)\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260127095106236-1661454977.png\" /></p>\n<p><strong>流图</strong>解决了一个视觉错觉问题：在普通<strong>堆叠面积图</strong>中，上面的数据层会因为下面数据层的起伏而被迫“扭曲”，很难看出它原本的形状。</p>\n<p><strong>流图</strong>通过中心布局，减少了这种扭曲，非常适合展示随时间变化的趋势和不同类别权重的波动，这种有机的形态还能给读者带来极强的审美愉悦感。</p>\n<h1 id=\"2-地平线图数据的群山\">2. 地平线图：数据的群山</h1>\n<p>想象一下远处的地平线上有一排连绵的山脉，每座山的高度代表一个数据值。</p>\n<p><strong>地平线图</strong>就是这样一种可视化技术，它将时间序列数据压缩在一个很小的垂直空间内，通过颜色和分层来展示数据的变化。</p>\n<p>特别适合在有限空间内展示多个时间序列的对比。</p>\n<p><strong>地平线图</strong>的<strong>核心思想</strong>是数据分层和颜色渐变。</p>\n<p>它将数据值分成若干层（通常是2-3层），每层用一种颜色表示。当数据值超过一层时，就用更深的颜色或不同的颜色填充。这样可以在很小的垂直空间内展示很大的数据范围。</p>\n<pre><code class=\"language-python\">from datetime import timedelta\n\n# 生成模拟数据：过去10年五大科技公司的股价波动\nnp.random.seed(42)\n\n# 生成日期范围：过去10年，每月一个数据点\ndates = pd.date_range(\"2013-01-01\", \"2023-01-01\", freq=\"ME\")\ncompanies = [\"苹果\", \"谷歌\", \"微软\", \"亚马逊\", \"Meta\"]\n\n# 生成各公司的股价模拟数据（标准化到相似范围）\ndata = {}\nfor company in companies:\n    # 基础趋势：每家公司有不同的增长趋势，但最终都在70-90范围内\n    # 省略 ...\n\n# 转换为DataFrame\ndf = pd.DataFrame(data, index=dates)\n\n# 创建对比图表\nfig, axes = plt.subplots(2, 1, figsize=(14, 10))\n\n# ============ 传统堆叠面积图 ============\ncolors = [\"#FF6B6B\", \"#4ECDC4\", \"#45B7D1\", \"#FFD166\", \"#9B5DE5\"]\n\n# 为堆叠面积图重新归一化数据\ndf_normalized = df.div(df.sum(axis=1), axis=0) * 100\ny_cumulative = np.zeros(len(df))\n\nfor i, company in enumerate(companies):\n    axes[0].fill_between(\n        df.index,\n        y_cumulative,\n        y_cumulative + df_normalized[company].values,\n        color=colors[i],\n        alpha=0.7,\n        label=company,\n        edgecolor=\"white\",\n        linewidth=0.5,\n    )\n    y_cumulative += df_normalized[company].values\n\n# 省略 ...\n\n# ============ 地平线图：股价波动对比 ============\n# 生成股价变化百分比数据（更能体现波动对比）\nnp.random.seed(42)\nprice_changes = {}\nfor company in companies:\n    # 生成均值附近波动的变化数据\n    # 省略 ...\n\n# 关键参数：定义“波段”\nBAND_HEIGHT = 3.0  # 每个颜色波段代表的变化率幅度 (%)\nNUM_BANDS = 3  # 正负方向各使用的波段层数\n\ndf = pd.DataFrame(price_changes, index=dates)\n\n# 为每家公司计算并绘制地平线\nfor i, company in enumerate(companies):\n    # 公司的基准Y轴位置（水平线）\n    # 省略 ...\n\n    # 分层与绘制：从第1层到第NUM_BANDS层\n    for band in range(NUM_BANDS):\n        # --- 处理正偏差（上涨）---\n        # 计算当前层的数据：偏差值减去已绘制层的高度，并限制在本层高度内\n        # 省略 ...\n\n        # --- 处理负偏差（下跌）---\n        # 对负值取绝对值，进行类似处理\n        # 省略 ...\n\n# 美化图表\n# 省略 ...\n\n# 6. 添加图例\nimport matplotlib.patches as mpatches\n\nlegend_patches = []\n# 省略 ...\n\nplt.tight_layout(h_pad=5)\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260127095106427-578985873.png\" /></p>\n<p><strong>地平线图</strong>是空间利用大师。当你有 20 个股票或者 50 个城市的温度需要放在一张图里对比时，普通的面积图会挤成一团乱麻。</p>\n<p><strong>地平线图</strong>可以将每个序列压缩成一个窄窄的横条，但在保持视觉分辨率的同时，还能让你看清极值（通过深颜色）。</p>\n<h1 id=\"3-总结\">3. 总结</h1>\n<p>数据可视化不仅是科学，也是艺术。<strong>流图</strong>和<strong>地平线图</strong>这两种面积图变体，分别从<strong>\"流动之美\"</strong>和<strong>\"空间效率\"</strong>两个角度拓展了面积图的可能性。</p>\n<p>它们证明了，通过对基础图表的创意改造，我们可以让数据讲述更丰富、更生动的故事。</p>\n<p>下次当你面对时间序列数据时，不妨问问自己：我的数据像一条蜿蜒的河流，还是像地平线上的群山？选择适合的可视化方式，让你的数据真正\"流动\"起来或\"层叠\"起来。</p>\n<p>记住，最好的可视化不是最复杂的，而是最能清晰传达信息、启发思考的那一个。</p>\n<p>完整的代码共享在：<a href=\"https://url11.ctfile.com/f/45455611-8635132430-f06d31?p=6872\" rel=\"noopener nofollow\" target=\"_blank\">面积图的2个变种.ipynb</a> (访问密码: 6872)</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-27 09:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">58</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于 C# 和 Nuke 打造现代化构建系统的最佳实践",
      "link": "https://www.cnblogs.com/newbe36524/p/19536496",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/newbe36524/p/19536496\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 08:54\">\n    <span>基于 C# 和 Nuke 打造现代化构建系统的最佳实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"告别脚本地狱为什么我们选择用-c-打造现代化构建系统\">告别脚本地狱：为什么我们选择用 C# 打造现代化构建系统</h1>\n<blockquote>\n<p>揭秘 HagiCode 项目如何利用 Nuke 实现类型安全、跨平台且高度可扩展的自动化构建流程，彻底解决传统构建脚本的维护痛点。</p>\n</blockquote>\n\n<h2 id=\"背景\">背景</h2>\n<p>在软件开发的漫长旅途中，\"构建\"这个词往往让人又爱又恨。爱的是，一键点击，代码变成产品，那是程序员最迷人的时刻；恨的是，维护那一堆乱糟糟的构建脚本，简直是噩梦。</p>\n<p>在很多项目中，我们习惯了用 Python 写脚本，或者用 XML 配置文件（想象一下那段被 <code>&lt;property&gt;</code> 支配的恐惧）。但随着项目复杂度的提升，尤其是像 HagiCode 这样涉及前后端、多平台、多语言混合开发的项目，传统的构建方式开始显得力不从心。脚本逻辑分散、缺乏类型检查、IDE 支持弱……这些问题像一个个小坑，时不时就让开发团队绊个跟头。</p>\n<p>为了解决这些痛点，在 HagiCode 项目中，我们决定引入 <strong>Nuke</strong> —— 一个基于 C# 的现代化构建系统。它不仅仅是一个工具，更像是一种对构建流程的重新思考。今天，我们就来聊聊为什么选择它，以及它是如何让我们的开发体验\"起飞\"的。</p>\n<h2 id=\"关于-hagicode\">关于 HagiCode</h2>\n<blockquote>\n<p>嘿，介绍一下我们正在做的东西</p>\n</blockquote>\n<p>我们正在开发 <strong>HagiCode</strong> —— 一款 AI 驱动的代码智能助手，让开发体验变得更智能、更便捷、更有趣。</p>\n<p><strong>智能</strong> —— AI 全程辅助，从想法到代码，让编码效率提升数倍。<strong>便捷</strong> —— 多线程并发操作，充分利用资源，开发流程顺畅无阻。<strong>有趣</strong> —— 游戏化机制和成就系统，让编码不再枯燥，充满成就感。</p>\n<p>项目正在快速迭代中，如果你对技术写作、知识管理或者 AI 辅助开发感兴趣，欢迎来 <a href=\"https://github.com/HagiCode-org/site\" rel=\"noopener nofollow\" target=\"_blank\">GitHub</a> 看看～</p>\n<h2 id=\"核心剖析为什么是-nuke\">核心剖析：为什么是 Nuke？</h2>\n<p>你可能心里会犯嘀咕：\"哎呀，构建系统那么多，比如 Make、Gradle，甚至直接用 Shell 脚本不行吗？为啥非得整一个 C# 的？\"</p>\n<p>这其实是个好问题。Nuke 的核心魅力在于它把我们最熟悉的编程语言特性带进了构建脚本的世界。</p>\n<h3 id=\"1-将构建流程模块化target-的艺术\">1. 将构建流程模块化：Target 的艺术</h3>\n<p>Nuke 的设计理念非常清晰：<strong>一切皆为目标</strong>。</p>\n<p>在传统的脚本里，我们可能会写出几百行线性执行的代码，逻辑错综复杂。而在 Nuke 中，我们将构建流程分解为独立的 <code>Target</code>（目标）。每个目标只负责一件事，比如：</p>\n<ul>\n<li><code>Clean</code>: 清理输出目录</li>\n<li><code>Restore</code>: 还原依赖包</li>\n<li><code>Compile</code>: 编译代码</li>\n<li><code>Test</code>: 运行单元测试</li>\n</ul>\n<p>这种设计非常符合单一职责原则。就像搭积木一样，我们可以随意组合这些 Target。更重要的是，Nuke 允许我们定义 Target 之间的依赖关系。比如，你想要 <code>Test</code>，那系统会自动检查你是否先执行了 <code>Compile</code>；想要 <code>Compile</code>，自然得先 <code>Restore</code>。</p>\n<p>这种依赖关系图不仅让逻辑更清晰，还极大地提高了执行效率，Nuke 会自动分析最优执行路径。</p>\n<h3 id=\"2-类型安全告别拼写错误的噩梦\">2. 类型安全：告别拼写错误的噩梦</h3>\n<p>用过 Python 写构建脚本的朋友肯定遇到过这种尴尬：脚本跑了五分钟，最后报错说 <code>Confi.guration</code> 拼写错了，或者传了一个字符串给了一个本该是数字的参数。</p>\n<p>使用 C# 编写构建脚本最大的优势就是 <strong>类型安全</strong>。这意味着：</p>\n<ul>\n<li><strong>编译时检查</strong>：你在敲代码的时候，IDE 就会告诉你哪里错了，不用等到运行时才发现。</li>\n<li><strong>重构无忧</strong>：如果你想改个变量名或者方法名，IDE 的重构功能一键搞定，不用全局搜索替换提心吊胆。</li>\n<li><strong>智能提示</strong>：强大的 IntelliSense 会自动补全代码，你不需要去翻文档记那些生僻的 API。</li>\n</ul>\n<h3 id=\"3-跨平台统一的构建体验\">3. 跨平台：统一的构建体验</h3>\n<p>以前在 Windows 上写 <code>.bat</code>，在 Linux 上写 <code>.sh</code>，为了兼容两者，还得写个 Python 脚本。现在，只要是 .NET Core（现 .NET 5+）能跑的地方，Nuke 就能跑。</p>\n<p>这意味着无论团队成员是使用 Windows、Linux 还是 macOS，无论是用 Visual Studio、VS Code 还是 Rider，大家执行的都是同一套逻辑。这就极大地消除了\"在我机器上能跑\"这类环境差异导致的问题。</p>\n<h3 id=\"4-参数与配置管理\">4. 参数与配置管理</h3>\n<p>Nuke 提供了一套非常优雅的参数解析机制。你不需要手动去解析 <code>string[] args</code>，只需要定义一个属性，加上 <code>[Parameter]</code> 特性，Nuke 就会自动处理命令行参数和配置文件的映射。</p>\n<p>比如，我们可以轻松定义构建配置：</p>\n<pre><code class=\"language-csharp\">[Parameter(\"Configuration to build - Default is 'Debug'\")]\nreadonly Configuration BuildConfiguration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\nTarget Compile =&gt; _ =&gt; _\n    .DependsOn(Restore)\n    .Executes(() =&gt;\n    {\n        // 在这里使用 BuildConfiguration，它是类型安全的\n        DotNetBuild(s =&gt; s\n            .SetConfiguration(BuildConfiguration)\n            .SetProjectFile(SolutionFile));\n    });\n</code></pre>\n<p>这种写法既直观又不容易出错。</p>\n<h2 id=\"实践指南如何在项目中落地\">实践指南：如何在项目中落地</h2>\n<p>空谈误国，实干兴邦。让我们看看在 HagiCode 项目中，具体是怎么落地这套方案的。</p>\n<h3 id=\"1-规划项目结构\">1. 规划项目结构</h3>\n<p>我们不想让构建脚本污染项目根目录，也不想搞得像某些 Java 项目那样目录结构深不见底。所以，我们将所有与 Nuke 相关的构建文件统一放置在 <code>nukeBuild/</code> 文件夹中。</p>\n<p>这样做的好处是：</p>\n<ul>\n<li>项目根目录保持清爽。</li>\n<li>构建逻辑内聚，方便管理。</li>\n<li>新成员加入时，一眼就能看到\"哦，这是构建相关的逻辑\"。</li>\n</ul>\n<h3 id=\"2-设计清晰的-target-依赖链\">2. 设计清晰的 Target 依赖链</h3>\n<p>在设计 Target 时，我们遵循了一个原则：<strong>原子化 + 依赖流</strong>。</p>\n<p>每个 Target 应该足够小，只做一件事。比如 <code>Clean</code> 就只管删文件，不要在里面顺便做打包。</p>\n<p>推荐的依赖流大概是这个样子的：</p>\n<p><code>Clean</code> -&gt; <code>Restore</code> -&gt; <code>Compile</code> -&gt; <code>Test</code> -&gt; <code>Pack</code></p>\n<p>当然，这不是绝对的。比如如果你只想跑个测试，不想打包，Nuke 允许你直接执行 <code>nuke Test</code>，它会自动处理好前置的 Restore 和 Compile 步骤。</p>\n<h3 id=\"3-完善的错误处理与日志\">3. 完善的错误处理与日志</h3>\n<p>构建脚本最怕的是什么？是报错信息不明确。比如构建失败了，日志只显示 \"Error: 1\"，这就让人很抓狂。</p>\n<p>在 Nuke 中，由于我们可以直接使用 C# 的异常处理机制，因此可以非常精确地捕获和报告错误。</p>\n<pre><code class=\"language-csharp\">Target Publish =&gt; _ =&gt; _\n    .DependsOn(Test)\n    .Executes(() =&gt;\n    {\n        try \n        {\n            // 尝试发布到 NuGet\n            DotNetNuGetPush(s =&gt; s\n                .SetTargetPath(ArtifactPath)\n                .SetSource(\"https://api.nuget.org/v3/index.json\")\n                .SetApiKey(ApiKey));\n        }\n        catch (Exception ex)\n        {\n            Log.Error($\"发布失败了，兄弟们检查一下 Key 对不对: {ex.Message}\");\n            throw; // 确保构建进程以非零退出码结束\n        }\n    });\n</code></pre>\n<h3 id=\"4-集成测试保障质量\">4. 集成测试保障质量</h3>\n<p>构建脚本本身也是代码，也需要测试。Nuke 允许我们为构建流程编写测试，确保当我们修改了构建逻辑后，不会破坏现有的发布流程。这在持续集成（CI）流水线中尤为重要。</p>\n<h2 id=\"总结\">总结</h2>\n<p>通过引入 Nuke，HagiCode 的构建流程变得前所未有的顺畅。它不仅仅是一个工具的替换，更是工程化思维的提升。</p>\n<p><strong>我们收获了什么？</strong></p>\n<ul>\n<li><strong>可维护性</strong>：代码即配置，逻辑清晰，新人也能快速上手。</li>\n<li><strong>稳定性</strong>：强类型检查减少了 90% 以上的低级错误。</li>\n<li><strong>一致性</strong>：跨平台的统一体验，消除了环境差异。</li>\n</ul>\n<p>如果说以前写构建脚本是\"在黑暗中摸索\"，那么使用 Nuke 就像是\"开着灯走夜路\"。如果你受够了维护那些难以调试的脚本语言，不妨试试把构建逻辑也搬到 C# 的世界里来，也许你会发现，原来构建也可以这么优雅。</p>\n<h2 id=\"参考资料\">参考资料</h2>\n<ul>\n<li><a href=\"https://nuke.build/\" rel=\"noopener nofollow\" target=\"_blank\">Nuke 官方文档</a></li>\n<li><a href=\"https://github.com/HagiCode-org/site\" rel=\"noopener nofollow\" target=\"_blank\">HagiCode 项目地址</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/archive/csharp-team/introducing-csharp-scripting\" rel=\"noopener nofollow\" target=\"_blank\">关于 C# Scripting 的更多细节</a></li>\n</ul>\n<hr />\n<p>感谢您的阅读,如果您觉得本文有用,快点击下方点赞按钮👍,让更多的人看到本文。</p>\n<p>本内容采用人工智能辅助协作,经本人审核,符合本人观点与立场。</p>\n<ul>\n<li><strong>本文作者:</strong> <a href=\"https://www.newbe.pro\" rel=\"noopener nofollow\" target=\"_blank\">newbe36524</a></li>\n<li><strong>本文链接:</strong> <a href=\"https://hagicode-org.github.io/site/blog/2026/01/26/modern-build-system-with-csharp-and-nuke\" rel=\"noopener nofollow\" target=\"_blank\">https://hagicode-org.github.io/site/blog/2026/01/26/modern-build-system-with-csharp-and-nuke</a></li>\n<li><strong>版权声明:</strong> 本博客所有文章除特别声明外,均采用 BY-NC-SA 许可协议。转载请注明出处!</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-27 08:54</span>&nbsp;\n<a href=\"https://www.cnblogs.com/newbe36524\">Newbe36524</a>&nbsp;\n阅读(<span id=\"post_view_count\">333</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Sdcb Chats 1.10 私有化代码执行器部署教程",
      "link": "https://www.cnblogs.com/sdcb/p/19533814/chats-1-10-deploy",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sdcb/p/19533814/chats-1-10-deploy\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 08:45\">\n    <span>Sdcb Chats 1.10 私有化代码执行器部署教程</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>之前我写了这篇博客<a href=\"https://www.cnblogs.com/sdcb/p/19528764/chats-1-10\" target=\"_blank\">《复刻 ChatGPT 高级数据分析！Sdcb Chats 1.10 重磅发布：能分析Excel、做PPT》</a>，向大家介绍了 Chats 1.10 最激动人心的新功能——内置代码执行器（Code Interpreter）。</p>\n<p>文章发出后，反响很热烈，但也有很多朋友在问：“这功能看着很强，但到底怎么部署及其配置啊？”</p>\n<p>回头看了一下前一篇文章，确实光顾着兴奋地介绍功能，把最关键的<strong>部署实操</strong>给略过了。为了让大家都能尽快用上这个“硬核”功能，今天特地补上这篇详细的保姆级部署配置文档。</p>\n<hr />\n<p>想要在 Chats 中使用“代码执行”功能，主要分两步走：</p>\n<ol>\n<li><strong>基础设施层</strong>：让 Chats 服务能连上 Docker Daemon（因为代码是在隔离的 Docker 容器中运行的）。</li>\n<li><strong>应用配置层</strong>：在 Chats 后台和前台开启相应的功能开关。</li>\n</ol>\n<h2 id=\"第一部分连接-docker-daemon\">第一部分：连接 Docker Daemon</h2>\n<p>Chats 的代码执行器原理是：当模型需要执行代码时，Chats 会动态创建一个一次性的 Docker 容器（沙箱），在里面运行代码并获取结果。因此，<strong>Chats 必须拥有管理 Docker 的权限</strong>。</p>\n<p>这里主要介绍两种最常见的场景：纯 Docker 环境（Linux 服务器）和 Windows 下的 Docker Desktop。</p>\n<h3 id=\"场景一linux-服务器--纯-docker-环境\">场景一：Linux 服务器 / 纯 Docker 环境</h3>\n<p>这是生产环境最常用的方式。你只需要将宿主机的 Docker Socket 挂载到 Chats 容器中即可。</p>\n<p><img alt=\"00-docker\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260126155139396-122617623.avif\" /></p>\n<h4 id=\"1-docker-镜像说明\">1. Docker 镜像说明</h4>\n<p>Chats 的 Docker 镜像托管在 <code>sdcb/chats</code>，我们提供了完善的多架构支持：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">描述</th>\n<th style=\"text-align: left;\">Docker 镜像 Tag</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>Latest（推荐）</strong></td>\n<td style=\"text-align: left;\"><code>latest</code></td>\n<td style=\"text-align: left;\">包含最新稳定版功能，多架构支持</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">指定完整版本</td>\n<td style=\"text-align: left;\"><code>{version}</code> (如 <code>1.10.0</code>)</td>\n<td style=\"text-align: left;\">生产环境推荐锁定版本</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">指定主/次版本</td>\n<td style=\"text-align: left;\"><code>{major}</code> / <code>{major.minor}</code></td>\n<td style=\"text-align: left;\">如 <code>1</code>, <code>1.10</code>，自动更新到该系列最新版</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">特定平台</td>\n<td style=\"text-align: left;\"><code>...-linux-x64</code> 等</td>\n<td style=\"text-align: left;\">仅在必须手动指定架构时使用</td>\n</tr>\n</tbody>\n</table>\n<p><strong>关于 Manifest (多架构支持)</strong>：<br />\n我们的 <code>latest</code> 和语义化版本标签（如 <code>1.10.0</code>）都是 <strong>Manifest List</strong>。这意味着你<strong>不需要</strong>手动区分 <code>linux-x64</code> 还是 <code>linux-arm64</code>。<br />\n无论你在 x64 的 Linux 服务器、ARM64 的树莓派，还是 Windows Server (Nano Server) 上执行 <code>docker pull sdcb/chats:latest</code>，Docker 都会自动检测并拉取最适合当前系统的镜像层。</p>\n<h4 id=\"2-启动配置\">2. 启动配置</h4>\n<p>由于 Docker Socket 默认属于 root 用户，为了避免权限问题（Permission Denied），建议显式指定 <code>--user 0:0</code> 以 root 身份运行容器。</p>\n<p>在启动 Chats 的 <code>docker run</code> 命令或 <code>docker-compose.yml</code> 中，添加 user 配置和挂载卷：</p>\n<pre><code class=\"language-bash\">-v /var/run/docker.sock:/var/run/docker.sock --user 0:0\n</code></pre>\n<p><strong>完整的 docker run 命令示例</strong>：</p>\n<pre><code class=\"language-bash\"># 创建数据目录并授权\nmkdir -p ./AppData &amp;&amp; chmod 755 ./AppData\n\n# 启动容器\ndocker run -d --restart unless-stopped --name sdcb-chats \\\n  -p 8080:8080 \\\n  -e DBType=sqlite \\\n  -e ConnectionStrings__ChatsDB=\"Data Source=./AppData/chats.db\" \\\n  -v ./AppData:/app/AppData \\\n  -v /var/run/docker.sock:/var/run/docker.sock --user 0:0 \\\n  sdcb/chats:latest\n</code></pre>\n<p><strong>示例 docker-compose.yml</strong>：</p>\n<pre><code class=\"language-yaml\">version: '3'\nservices:\n  chats:\n    image: sdcb/chats:latest\n    user: 0:0 # 关键：必须使用 root 用户才能访问 docker.sock\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock # 关键配置：挂载 Docker 守护进程\n      - ./data:/app/data\n    ports:\n      - \"8080:8080\"\n</code></pre>\n<h3 id=\"场景二windows-环境\">场景二：Windows 环境</h3>\n<p>在 Windows (使用 Docker Desktop) 上部署时，情况稍微特殊一点，取决于你是<strong>在 Docker 容器内运行 Chats</strong>，还是<strong>直接运行 Chats 的 Windows 可执行文件 (.exe)</strong>。</p>\n<h4 id=\"情况-achats-运行在-docker-容器内推荐\">情况 A：Chats 运行在 Docker 容器内（推荐）</h4>\n<p>如果你是通过 <code>docker run</code> 启动 Chats 的，那么恭喜你，配置方法其实和 Linux <strong>完全一样</strong>！</p>\n<p>Docker Desktop for Windows 做了很好的兼容，你只需要把 <code>/var/run/docker.sock</code> 挂载进去即可，<strong>不需要</strong>配置 npipe 或 TCP。</p>\n<p><strong>PowerShell 启动命令示例</strong>：</p>\n<pre><code class=\"language-powershell\">docker run -d -p 8080:8080 `\n  -v /var/run/docker.sock:/var/run/docker.sock `\n  -v ${PWD}/data:/app/data `\n  sdcb/chats:latest\n</code></pre>\n<h4 id=\"情况-bchats-作为原生可执行文件运行\">情况 B：Chats 作为原生可执行文件运行</h4>\n<p>如果你不习惯使用 Docker 部署应用，我们提供了基于预编译的原生可执行文件，<strong>无需安装任何运行时</strong>（如 .NET SDK/Runtime）即可直接运行，启动速度较快且内存占用低。</p>\n<p><strong>可执行文件列表</strong>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">平台</th>\n<th style=\"text-align: left;\">文件名</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>Windows 64位</strong></td>\n<td style=\"text-align: left;\"><code>chats-win-x64.zip</code></td>\n<td style=\"text-align: left;\">推荐大多数 Windows 用户</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Linux 64位</td>\n<td style=\"text-align: left;\"><code>chats-linux-x64.zip</code></td>\n<td style=\"text-align: left;\">常见的 Linux 服务器 (glibc)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Linux ARM64</td>\n<td style=\"text-align: left;\"><code>chats-linux-arm64.zip</code></td>\n<td style=\"text-align: left;\">树莓派、Mac M系列docker等</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Linux Musl</td>\n<td style=\"text-align: left;\"><code>chats-linux-musl-*.zip</code></td>\n<td style=\"text-align: left;\">适用于 Alpine 等轻量级发行版</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">macOS</td>\n<td style=\"text-align: left;\"><code>chats-osx-*.zip</code></td>\n<td style=\"text-align: left;\">支持 x64 (Intel) 和 ARM64 (M系列芯片)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">通用包</td>\n<td style=\"text-align: left;\"><code>chats.zip</code></td>\n<td style=\"text-align: left;\"><strong>需安装 .NET 10</strong>，跨平台</td>\n</tr>\n</tbody>\n</table>\n<p>你可以从 <a href=\"https://github.com/sdcb/chats/blob/main/doc/zh-CN/downloads.md\" rel=\"noopener nofollow\" target=\"_blank\">下载指南文档</a> 页面获取下载地址。该文档详细列出了 GitHub Releases 及国内加速镜像的下载方式。</p>\n<p><strong>配置与启动</strong>：</p>\n<p>如果你下载了 <code>Chats.BE.exe</code> (Windows 版后端) 直接运行，而不是使用 Docker 镜像，那么你需要通过命令行参数指定 Windows 的<strong>命名管道 (Named Pipe)</strong> 来连接 Docker 引擎。</p>\n<ol>\n<li><strong>下载程序</strong>：下载并解压对应的 <code>chats-win-x64.zip</code>。</li>\n<li><strong>启动命令</strong>：使用 <code>--CodePod:DockerEndpoint</code> 参数指定 Docker 接入点。</li>\n</ol>\n<p><strong>PowerShell 启动命令示例</strong>：</p>\n<pre><code class=\"language-powershell\"># 启动后端程序，并指定 Docker 引擎地址\n.\\Chats.BE.exe --CodePod:DockerEndpoint npipe://./pipe/docker_engine\n</code></pre>\n<p>你也可以同时指定其它参数（如端口）：</p>\n<pre><code class=\"language-powershell\">.\\Chats.BE.exe --urls http://+:5000 --CodePod:DockerEndpoint npipe://./pipe/docker_engine\n</code></pre>\n<p>这样，原生运行的 Chats 也能顺利指挥 Docker Desktop 创建沙箱环境了。</p>\n<hr />\n<h2 id=\"第二部分在-chats-中启用功能\">第二部分：在 Chats 中启用功能</h2>\n<p>连上 Docker 只是打通了经脉，接下来还需要在 Chats 内部“解锁”这个技能。</p>\n<h3 id=\"1-后端配置模型设置\">1. 后端配置：模型设置</h3>\n<p>首先，我们要告诉 Chats，哪些模型允许使用这个能力。</p>\n<ol>\n<li>以管理员身份登录 Chats。</li>\n<li>进入<strong>后台管理</strong> -&gt; <strong>模型配置</strong>。</li>\n<li>展开你想要的模型提供商-&gt;模型密钥，然后编辑你想要使用的模型（例如deepseek-v3.2）。\n<ul>\n<li><strong>注意</strong>：任何支持 Tool Call (工具调用) 的模型 API 都可以，无论是 OpenAI 原生的 Chat Completions，还是Responses API/Messages API。</li>\n</ul>\n</li>\n<li>在功能列表中，找到并勾选 <strong>“代码执行 (Code Execution)”</strong>。<br />\n<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260126151714293-1229825697.avif\" /></li>\n</ol>\n<p><strong>⚠️ 特别注意：用户权限分配</strong></p>\n<p>很多第一次添加模型的朋友容易忽略这一点：<strong>启用功能后，必须明确授权给用户。</strong></p>\n<p>在模型编辑页面的底部，展开<strong>用户列表 (User Access)</strong>，确保<strong>给你自己的账号（或需要使用的用户）勾选上权限</strong>。如果不勾选，你在前台是看不到这个模型的，或者无法调用该功能。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260126151715025-1987207460.avif\" /></p>\n<h3 id=\"2-前端配置开启会话开关\">2. 前端配置：开启会话开关</h3>\n<p>后端准备就绪后，最后一步是在聊天界面开启使用。</p>\n<ol>\n<li>回到<strong>聊天 (Chat)</strong> 界面。</li>\n<li>在顶部的模型配置栏（通常显示模型名称的地方），点击展开配置面板。</li>\n<li>找到 <strong>“代码执行”</strong> 开关，将其打开。</li>\n</ol>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260126151715455-1639921351.avif\" /></p>\n<hr />\n<h2 id=\"效果演示\">效果演示</h2>\n<p>一切就绪！现在你可以像使用 ChatGPT 的高级数据分析一样，上传一个 Excel 文件，或者让它帮你画一张图表了。</p>\n<p>试试发送这样的指令：</p>\n<blockquote>\n<p>请帮我分析这个 Excel 文件：<a href=\"https://cv-public.sdcb.pub/2026/changsha_weather_2025.xlsx%EF%BC%8C%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E6%AF%8F%E6%9C%88%E5%B9%B3%E5%9D%87%E6%B0%94%E6%B8%A9%E5%92%8C%E9%99%8D%E6%B0%B4%E9%87%8F%E7%9A%84%E6%8A%A5%E5%91%8A%EF%BC%8C%E5%B9%B6%E9%99%84%E4%B8%8A%E5%9B%BE%E8%A1%A8\" rel=\"noopener nofollow\" target=\"_blank\">https://cv-public.sdcb.pub/2026/changsha_weather_2025.xlsx，生成一个包含每月平均气温和降水量的报告，并附上图表</a></p>\n</blockquote>\n<p>Chats 会自动创建一个隔离的 Docker 环境，编写 Python 代码，执行并把生成的图片直接贴在对话框里。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260125102328487-114968639.avif\" /></p>\n<hr />\n<h2 id=\"安全性考量\">安全性考量</h2>\n<p>⚠️ <strong>重要提示</strong>：与模型 API 调用不同，代码执行功能目前<strong>不进行任何计费</strong>，仅通过全局配置做了一些基础限制。如果你打算将 Chats 开放给未经充分信任的用户使用（例如搭建类似 ChatGPT/Manus 的公开服务），务必认真配置以下安全策略，避免服务器资源被滥用甚至被攻击。</p>\n<h3 id=\"1-网络隔离\">1. 网络隔离</h3>\n<p>代码执行容器的默认网络模式为 <code>bridge</code>，这与 ChatGPT 的完全隔离沙箱不同——<strong>容器是可以联网的</strong>。</p>\n<p>这个设计是有意为之的，因为它带来了更强大的能力：</p>\n<ul>\n<li>AI 可以在容器内下载文件、调用外部 API、安装依赖包。</li>\n<li>甚至可以让 AI 创建多个 Docker 容器协同工作（比如一个跑 Web 应用、一个跑数据库），Chats 会在工具调用响应中返回容器的局域网 IP 地址，模型可以据此进行容器间通信。</li>\n</ul>\n<p>但这也意味着潜在风险：</p>\n<ul>\n<li>容器可以访问宿主机同一 Docker 网络内的其他服务（包括你的数据库、Redis 等）。</li>\n<li>恶意用户可能利用此能力进行内网扫描或攻击。</li>\n</ul>\n<p><strong>建议</strong>：</p>\n<ul>\n<li><strong>安全敏感环境</strong>：将 <code>CodeInterpreter:MaxAllowedNetworkMode</code> 设置为 <code>none</code>，完全禁止容器联网。</li>\n<li><strong>物理隔离</strong>：在一台独立的虚拟机或物理机上运行 Docker Daemon，Chats 通过 TCP 远程连接，从而实现网络层面的彻底隔离。</li>\n</ul>\n<h3 id=\"2-资源限制\">2. 资源限制</h3>\n<p>AI 可以创建任意数量的 Docker 会话（通过 <code>create_docker_session</code> 工具）。虽然空闲会话会在一定时间后自动清理，但仍存在以下风险：</p>\n<ul>\n<li><strong>算力滥用</strong>：恶意用户可能运行高负载任务，耗尽服务器 CPU/内存。</li>\n<li><strong>磁盘占用</strong>：AI 可能拉取不同版本的镜像，这些镜像<strong>不会自动清理</strong>，长期积累会占满磁盘。</li>\n</ul>\n<p>Chats 提供了细粒度的资源限制配置，<strong>强烈建议根据实际情况调整</strong>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">配置项</th>\n<th style=\"text-align: left;\">默认值</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:DefaultResourceLimits:MemoryBytes</code></td>\n<td style=\"text-align: left;\"><code>2147483648</code> (2GB)</td>\n<td style=\"text-align: left;\">单个容器内存上限</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:DefaultResourceLimits:CpuCores</code></td>\n<td style=\"text-align: left;\"><code>2.0</code></td>\n<td style=\"text-align: left;\">单个容器 CPU 核数</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:DefaultResourceLimits:MaxProcesses</code></td>\n<td style=\"text-align: left;\"><code>200</code></td>\n<td style=\"text-align: left;\">单个容器最大进程数</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:MaxResourceLimits:*</code></td>\n<td style=\"text-align: left;\"><code>null</code> (不限制)</td>\n<td style=\"text-align: left;\">硬上限，防止 AI 请求超额资源</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:SessionIdleTimeoutSeconds</code></td>\n<td style=\"text-align: left;\"><code>1800</code> (30分钟)</td>\n<td style=\"text-align: left;\">空闲会话自动回收时间</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:DefaultTimeoutSeconds</code></td>\n<td style=\"text-align: left;\"><code>300</code> (5分钟)</td>\n<td style=\"text-align: left;\">单次命令执行超时</td>\n</tr>\n</tbody>\n</table>\n<p>默认的 2 核 2GB 配置可以完成大多数日常任务（数据分析、图表生成、文档处理等）。如果你的场景需要更多资源（如视频处理、大规模计算），可以适当放宽；反之，如果是公开服务，建议收紧限制。</p>\n<h3 id=\"3-文件上传限制\">3. 文件上传限制</h3>\n<p>AI 执行代码后可以将生成的文件（artifacts）回传给用户。为防止滥用，Chats 也提供了相应限制：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">配置项</th>\n<th style=\"text-align: left;\">默认值</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:MaxArtifactsFilesToUpload</code></td>\n<td style=\"text-align: left;\"><code>50</code></td>\n<td style=\"text-align: left;\">每轮最多回传文件数</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:MaxSingleUploadBytes</code></td>\n<td style=\"text-align: left;\"><code>157286400</code> (150MB)</td>\n<td style=\"text-align: left;\">单个文件最大大小</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:MaxTotalUploadBytesPerTurn</code></td>\n<td style=\"text-align: left;\"><code>314572800</code> (300MB)</td>\n<td style=\"text-align: left;\">单轮总上传大小</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"4-其他建议\">4. 其他建议</h3>\n<ul>\n<li><strong>定期清理镜像</strong>：使用 <code>docker image prune</code> 或 <code>docker system prune</code> 定期清理未使用的镜像和悬挂资源。</li>\n<li><strong>监控与告警</strong>：对 Docker 宿主机的 CPU、内存、磁盘使用率设置监控告警。</li>\n<li><strong>用户权限管理</strong>：仅对信任的用户开放代码执行功能，在模型配置中谨慎分配权限。</li>\n</ul>\n<p>更多配置细节请参考：<a href=\"https://github.com/sdcb/chats/blob/main/doc/zh-CN/configuration.md\" rel=\"noopener nofollow\" target=\"_blank\">配置说明文档</a></p>\n<hr />\n<h2 id=\"结语\">结语</h2>\n<p>希望这篇文档能帮你顺利部署 Chats 1.10，体验完全私有化、可控的代码解释器功能。</p>\n<p>感谢阅读！喜欢的朋友请给我的 GitHub 项目一个 star：<br />\n<a href=\"https://github.com/sdcb/chats\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/sdcb/chats</a></p>\n<p>这是完整的更新日志，包含更多技术细节：<br />\n<a href=\"https://github.com/sdcb/chats/blob/main/doc/zh-CN/release-notes/README.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/sdcb/chats/blob/main/doc/zh-CN/release-notes/README.md</a></p>\n<p>有什么想法也欢迎在评论区留言交流，也欢迎加入我的新创建的微信群：</p>\n<p><img alt=\"\" src=\"https://io.starworks.cc:88/cv-public/2026/chats-wxg-qr.png\" /></p>\n<p>如果你更习惯用 QQ 的话，也可以加入 Chats QQ 群：<strong>498452653</strong>，我们一起探索更多 AI 技术硬核玩法。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-27 08:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sdcb\">.NET骚操作</a>&nbsp;\n阅读(<span id=\"post_view_count\">130</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI异常处理全解析：别让你的API在用户面前“裸奔”",
      "link": "https://www.cnblogs.com/ymtianyu/p/19536459",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19536459\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 08:38\">\n    <span>FastAPI异常处理全解析：别让你的API在用户面前“裸奔”</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文系统解析了FastAPI中异常处理的核心技巧，涵盖HTTPException基础用法、自定义业务异常设计、全局异常处理器配置以及WebSocket异常处理。通过生动的比喻和实战代码，帮助你构建健壮、友好的API错误响应机制，提升系统稳定性和用户体验。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">摘要：</strong>本文深入讲解FastAPI中<span style=\"color: rgba(186, 55, 42, 1);\"><code>HTTPException</code></span>、<span style=\"color: rgba(186, 55, 42, 1);\"><code>WebSocketException</code></span>等常见异常的捕获与处理技巧，涵盖从基础配置到全局异常处理器的完整实践。通过餐厅点餐、消防队等生动比喻，帮助你构建健壮、友好的API错误响应体系，避免服务崩溃和糟糕的用户体验。</p>\n<h1>深夜改Bug，你的API在用户面前“裸奔”了吗？</h1>\n<p>你有没有经历过这种噩梦场景？——用户反馈“页面白屏”或“操作失败”，你慌慌张张查日志，发现是个没处理的异常，返回了一堆Python调用栈给前端，用户看到一脸懵，你debug得想撞墙。</p>\n<p>先看案例：一个简单的请求参数验证失败，因为没正确处理，直接抛了500内部错误。监控报警半夜响起，用户投诉接踵而至，团队小伙伴连夜排查修复。痛定思痛，<strong style=\"color: rgba(186, 55, 42, 1);\">异常处理这玩意儿，看似边缘，实则是API的门面和铠甲</strong>。处理得好，用户体验丝滑；处理不好，就是技术债里的定时炸弹。</p>\n<p>今天，咱们就来彻底聊聊FastAPI里的异常处理。这不是抄文档，而是我踩了无数坑后，给你总结的实战心得。准备好了吗？咱们开始吧！</p>\n<h2>🎯 核心脉络：从“救火”到“防火”</h2>\n<div>\n<p>🔸 1. 为什么FastAPI的异常处理这么重要？——不只是技术，更是用户体验</p>\n<p>🔸 2. HTTPException：你的第一道防线，但别只靠它</p>\n<p>🔸 3. 自定义异常：让错误信息会“说话”</p>\n<p>🔸 4. 全局异常处理器：给API穿上“防弹衣”</p>\n<p>🔸 5. WebSocketException：实时通讯的异常该怎么管？</p>\n<p>🔸 6. 进阶技巧与避坑指南</p>\n</div>\n<h2>📌 第一部分：异常处理不是备选项，而是必选项</h2>\n<p>把API想象成一家餐厅。用户点餐（发送请求），厨房处理（服务端逻辑），最后上菜（返回响应）。异常处理是什么？就是当厨房发现“鱼卖完了”或者“客人对海鲜过敏”时，<strong style=\"color: rgba(186, 55, 42, 1);\">服务员如何得体地告知顾客，并给出替代方案</strong>，而不是直接把锅摔了，或者扔给顾客一张看不懂的后厨采购单（Python traceback）。</p>\n<p>我刚用FastAPI那会儿，也偷懒过，觉得有默认错误页面就行。结果呢？前端同事天天找我要错误码对照表，测试同学报的Bug描述模糊不清，线上出了问题定位慢如蜗牛。血的教训告诉我们：<strong style=\"color: rgba(186, 55, 42, 1);\">异常处理必须和业务逻辑同步设计，甚至要更早考虑</strong>。</p>\n<h2>🛡️ 第二部分：HTTPException，用好它但别依赖它</h2>\n<p>FastAPI提供了<code style=\"color: rgba(186, 55, 42, 1);\">HTTPException</code>，这是最直接、最常用的异常抛出方式。它就像一个标准化的“错误通知单”。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    if item_id not in item_db:\n        # 关键在这里：抛出带状态码和详情的异常\n        raise HTTPException(\n            status_code=404,\n            detail=\"Item not found\",\n            headers={\"X-Error\": \"ItemID-Missing\"}\n        )\n    return {\"item\": item_db[item_id]}</code></pre>\n<p>看这段代码，<code style=\"color: rgba(186, 55, 42, 1);\">status_code</code>告诉前端这是什么类型的错误（404找不到了），<code style=\"color: rgba(186, 55, 42, 1);\">detail</code>给人类看的原因，<code style=\"color: rgba(186, 55, 42, 1);\">headers</code>里还能塞点给机器看的额外信息。是不是很像服务员说：“抱歉先生，您点的这道菜（item_id）今天售罄了（404），这是我们推荐的相似菜品（headers里可以放推荐）”。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">但是！千万别以为只用HTTPException就万事大吉了。</strong>想象一下，你餐厅的后厨着火了（服务器内部错误），或者客人拿了一张假钞来付款（请求数据根本不符合格式），这时候只靠服务员说“菜没了”显然不够。我们需要更强大的机制。</p>\n<h2>🔧 第三部分：打造你的“异常消防队”——全局异常处理器</h2>\n<p>全局异常处理器（Exception Handler）就是你API大楼里的<strong style=\"color: rgba(186, 55, 42, 1);\">自动消防系统和万能服务员</strong>。任何没被特定处理的异常，最终都会落到这里，由它统一格式，友好返回。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport traceback\n\napp = FastAPI()\n\n# 1. 先定义一个标准的错误响应模型\nclass ErrorResponse(BaseModel):\n    code: int\n    message: str\n    detail: Optional[str] = None\n    request_id: Optional[str] = None # 用于链路追踪\n\n# 2. 捕获所有未处理异常的“总闸”\n@app.exception_handler(Exception)\nasync def universal_exception_handler(request: Request, exc: Exception):\n    # 获取请求ID，便于追踪（假设从中间件或header传入）\n    request_id = request.headers.get(\"X-Request-ID\", \"unknown\")\n    \n    # 这里可以根据exc的类型进行更精细的分类\n    error_code = 500 # 默认内部错误\n    message = \"Internal Server Error\"\n    \n    if isinstance(exc, ValueError):\n        error_code = 400\n        message = \"Invalid input value\"\n    # ... 可以添加更多类型判断\n    \n    # 在生产环境，detail可能不返回具体堆栈，开发环境可以返回\n    import os\n    detail = traceback.format_exc() if os.getenv(\"ENV\") == \"development\" else None\n    \n    return JSONResponse(\n        status_code=error_code,\n        content=ErrorResponse(\n            code=error_code,\n            message=message,\n            detail=detail,\n            request_id=request_id\n        ).dict()\n    )\n\n# 3. 专门处理HTTPException，覆盖FastAPI默认行为\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content=ErrorResponse(\n            code=exc.status_code,\n            message=exc.detail,\n            request_id=request.headers.get(\"X-Request-ID\", \"unknown\")\n        ).dict(),\n        headers=exc.headers\n    )</code></pre>\n<p>这个“消防队”厉害在哪？首先，它抓住了所有<code style=\"color: rgba(186, 55, 42, 1);\">Exception</code>，确保没有异常会“裸奔”出去。其次，它把错误响应格式标准化了，前端永远知道会收到<code style=\"color: rgba(186, 55, 42, 1);\">{\"code\": ..., \"message\": ...}</code>这样的结构。最后，它还区分了开发和生成环境，开发时给你详细堆栈debug，生产环境则隐藏细节保证安全。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">这里有个我踩过的大坑：</strong> 异常处理器的注册顺序很重要！如果你先注册了通用的<code style=\"color: rgba(186, 55, 42, 1);\">Exception</code>处理器，再注册<code style=\"color: rgba(186, 55, 42, 1);\">HTTPException</code>处理器，那么<code style=\"color: rgba(186, 55, 42, 1);\">HTTPException</code>也会被通用的抓住，你就无法对它进行特殊定制了。所以，通常要先注册具体的，再注册通用的。</p>\n<h2>🎨 第四部分：自定义异常——让业务错误清晰明了</h2>\n<p>业务逻辑里的错误，比如“用户余额不足”、“活动已结束”，用404或400虽然也行，但语义不精确。这时候，就需要自定义异常。</p>\n<pre class=\"language-python highlighter-hljs\"><code># 定义自己的业务异常类\nclass BusinessError(Exception):\n    def __init__(self, code: int, message: str, extra_data: dict = None):\n        self.code = code # 业务错误码，如 1001\n        self.message = message\n        self.extra_data = extra_data or {}\n\n# 定义几个具体的业务异常\nclass InsufficientBalanceError(BusinessError):\n    def __init__(self, current_balance: float, required_amount: float):\n        super().__init__(\n            code=1001,\n            message=\"Insufficient balance\",\n            extra_data={\n                \"current_balance\": current_balance,\n                \"required_amount\": required_amount\n            }\n        )\n\nclass ActivityExpiredError(BusinessError):\n    def __init__(self, activity_id: str, expire_time: str):\n        super().__init__(\n            code=1002,\n            message=\"Activity has expired\",\n            extra_data={\"activity_id\": activity_id, \"expire_time\": expire_time}\n        )\n\n# 为自定义业务异常注册处理器\n@app.exception_handler(BusinessError)\nasync def business_exception_handler(request: Request, exc: BusinessError):\n    return JSONResponse(\n        status_code=422, # 或用200，但body里表明错误，看前端约定\n        content={\n            \"success\": False,\n            \"error\": {\n                \"code\": exc.code,\n                \"message\": exc.message,\n                **exc.extra_data # 展开额外数据，前端可以直接用\n            }\n        }\n    )\n\n# 在路由中使用\n@app.post(\"/purchase\")\nasync def make_purchase(user_id: int, amount: float):\n    user_balance = get_balance(user_id)\n    if user_balance &lt; amount:\n        # 抛出业务异常，而不是简单的HTTP 400\n        raise InsufficientBalanceError(\n            current_balance=user_balance,\n            required_amount=amount\n        )\n    # ... 购买逻辑</code></pre>\n<p>这样做的好处巨大！前端看到错误码1001，就知道是余额不足，并且直接从<code style=\"color: rgba(186, 55, 42, 1);\">extra_data</code>里拿到当前余额和所需金额，可以立刻在界面上友好提示：“您的余额为XX元，还需充值YY元”。这体验，比干巴巴的“请求失败”好了一万倍。</p>\n<h2>⚡ 第五部分：WebSocketException——实时通道的优雅关闭</h2>\n<p>WebSocket是长连接，异常处理方式和HTTP不太一样。你不能返回一个JSON响应，而是需要<strong style=\"color: rgba(186, 55, 42, 1);\">优雅地关闭连接并发送原因</strong>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import WebSocket, WebSocketException\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_json()\n            # 一些业务验证\n            if data.get(\"type\") not in VALID_TYPES:\n                # 抛出WebSocketException，指定关闭码和原因\n                raise WebSocketException(\n                    code=1008, # 1008表示政策违规\n                    reason=\"Invalid message type received\"\n                )\n            # ... 处理消息\n    except WebSocketException as e:\n        # 这里其实raise之后，FastAPI会帮你关闭连接\n        raise\n    except Exception as e:\n        # 其他未知异常，也以WebSocketException形式关闭\n        raise WebSocketException(code=1011, reason=f\"Internal error: {str(e)}\")</code></pre>\n<p>WebSocket关闭码是有标准的，比如1000表示正常关闭，1008表示政策违规。用好这些代码，能让客户端明确知道连接为什么断开，从而做出相应处理（比如重连、提示用户等）。</p>\n<h2>🚨 第六部分：避坑指南与进阶思考</h2>\n<div>\n<p><strong>🔥 1. 不要过度捕获异常</strong></p>\n<p>别动不动就用<code style=\"color: rgba(186, 55, 42, 1);\">try...except Exception</code>把一大段业务逻辑包起来。这会隐藏真正的Bug。只捕获你预期中可能发生的、并且你知道如何处理的异常。</p>\n<p><strong>🔥 2. 日志！日志！日志！</strong></p>\n<p>异常处理器里一定要记日志，而且要记录完整的堆栈信息和请求上下文（用户ID、请求参数等）。用<code style=\"color: rgba(186, 55, 42, 1);\">logging.error(exc_info=True)</code>。这是你事后排查问题的唯一指望。</p>\n<p><strong>🔥 3. 区分返回状态码（status_code）和业务错误码（error_code）</strong></p>\n<p>HTTP状态码是给HTTP协议和网关看的（如404, 500）。业务错误码是你和前端约定的具体错误含义（如1001余额不足）。两者可以结合使用。</p>\n<p><strong>🔥 4. 考虑使用Starlette的异常处理基类</strong></p>\n<p>FastAPI基于Starlette，<code style=\"color: rgba(186, 55, 42, 1);\">from starlette.exceptions import HTTPException</code>和FastAPI的略有不同。如果你需要更底层的控制，可以研究一下。</p>\n<p><strong>🔥 5. 测试你的异常处理</strong></p>\n<p>写单元测试，模拟各种异常情况，确保你的处理器能正确响应，并且返回格式符合前端预期。这部分投入的回报率极高。</p>\n</div>\n<hr />\n<h2>💎 写在最后</h2>\n<p>异常处理，就像给代码买保险。平时感觉不到它的存在，但出事的时候，它能救你的项目、你的口碑，甚至你的睡眠。</p>\n<p>今天分享的这些，都是我从一次次报警电话和用户投诉中学来的。希望你看完能立刻动手，检查一下自己的FastAPI项目，是不是还在“裸奔”？给你的异常处理“消防队”配齐装备，让它成为你最可靠的后盾。</p>\n<p>如果你在实践过程中遇到其他坑，或者有更妙的心得，欢迎在评论区分享。这篇干货，值得你<strong style=\"color: rgba(186, 55, 42, 1);\">收藏</strong>下来，下次遇到异常处理的问题时，翻出来看看，一定能帮你省下不少折腾的时间。</p>\n<p>我是一名程序媛，我们下篇实战见！</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-27 08:38</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">一名程序媛呀</a>&nbsp;\n阅读(<span id=\"post_view_count\">204</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}