{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "忆往昔--OI生涯回忆",
      "link": "https://www.cnblogs.com/hicode002/p/-/oi-memories",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hicode002/p/-/oi-memories\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 11:45\">\n    <span>忆往昔--OI生涯回忆</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>突然大概明白了为什么这么失败了...其实我对OI/计算机的热情远没有那么高，至少不是那种特别喜欢写程序写项目的人，之前也只是用E语言/Python写各种小工具/爬虫，还研究过一段时间游戏开发（当然小学时候是不会英语用的中文编程），甚至那时候就会多线程并发（当然还是中文语言）那时候的确对写程序有很强的热情，至少说是一个自我满足的过程，得写了好几十个小工具而且思路也还比较清晰能坐在电脑面前很长时间，而且没有很强的炫耀思维。当然当时也是刷机爱好者，在那个年代感觉（小学时候）几乎没有很多的资源但是我那时候一直有个梦想就是给手机刷windows和手机双系统，（结果这个到今天也没实现emmm），然后刷坏了好几部手机，d当时还是Windows Phone时代，那时候我一直想着手机有一天也要有电脑的BIOS。（然后后来WOA项目真的做了）然后就是MC玩家还研究过命令方块（当时手机版刚出命令方块）（还是多玩我的世界盒子时代），当时体育课还把它都打印出来和同学讨论。<br />\n然后小学很早家里买了一堆操作系统安装和Dreamviewer/photoshop软件使用的书，当时还说要自己写一个博客，（谁知道现在前端都是vue+react，并且博客都是现成的模板），然后还有一本上世纪的VB编程（结果现在早淘汰了）。</p>\n<p>从这个意义上说我至少学OI前我的计算机学习的确是出于兴趣并且充满热情的，而且都是自学的。</p>\n<p>初二时候想着研究AI相关的（主要是流浪地球的MOSS吸引的），然后想着系统性的学python什么的正儿八经写一个自动化工具（当时也不懂AI的原理只知道要训练），然后一直没有好的自学资源（或者说当时我找不到），然后当时语文作文很差被家长勒令去上辅导班加上和老师/同学关系很差，所以说很难受。然后辅导班旁边有有一家新开的编程机构邀请我试听，然后去了，到那把我的情况一说，然后人家觉得我水平还可以跟我说了信息学竞赛和C++相关的，然后我一下子非常高兴，就跟家长说要学（在此之前所有兴趣班我都学不下去），然后刚好当时初中班主任对我态度很差，之前还说过我除了会点电脑啥都不会就是废物之类的话（确实我体育不好，谁叫她教体育的...),所以说就真让家长报班学了，当时还有另外一个骗子机构叫做童程童美，是教python的，用python写小游戏，但是我觉得有点水（事实证明这个机构后来的确暴雷了）。然后暑假2个月把C++语言基础学出来了，那时候突然一下子了解到自主招生，了解到一种神秘的东西叫做游记/退役记，然后才意识到，原来编程学的好可以保送/高考降分进入名校啊，突然意识到原来在有些地方他们的中学生活非常快乐而不是像我一样。然后当时翻到了很多NOIP考了好成绩被高中保送，然后高中在机房快乐的编程，感觉非常浪漫就像在童话的世界一样。还有一些学长高三提前降一本然后在学校爽玩然后在全校分享自己的经验，那种感觉就是一个从来没有见过的新世界呀！</p>\n<p>那时候我一下子意识到我也要像他们那样，那时候看到大佬们的游记里面提到的高大上听不懂名字的算法和数据结构，还有当时一个流行的话：暴力出奇迹，暴力进国集，想着只要我认真学习这些算法和数据结构，再有着良好的数学基础，再给我充足的时间，然后肯定可以拿到金牌进入国集!（而且看zyb大佬的博客大概的学习路线也确实是这样的）而且那时候整个西海岸连一个省一的都没有！所以说当时是我暗自就下定决心要把全部精力投入到这个上面，一定要拿到金牌，拿不到金牌拿一个银牌也行，那样到时候没有人会再嘲讽我！再也没有人会说我体育差/语文差!然后我想象着拿到牌子之后，我可以认识很多人，我可以有一天站在学校的讲台上讲着自己的经验，我保送/降分之后我可以弥补我之前没有做的事情，我可以做化学实验，我可以重新玩我喜欢的游戏，我可以有自己的游记下面也会有人评论！</p>\n<p>然后我那时候想着第一年先拿到普及组一等奖，那时候我虽然不理解很多算法连回溯都不太理解但是我代码能力还可以或者说心态很好，这些题都是直接上手写代码的。后来还配了NOI linux环境，还配置了GEDIT和VIM，当时还想着考场上是Linux环境,还担心会有一些编译错误，甚至默写头文件而不是使用万能头，然后还记着当时初中语文课（我语文课听不下去老师天天骂我，而且阅读题我从来不做因为总感觉自己的想法会被老师审阅是很不舒服的，只有考试才做因为阅卷老师是随机的），课上在课本的角落上在那边默写头文件/想题（当时都是一些模拟题）。然后到CSP考前我基本上刷完了历年所有普及组的前两题，这样说前两题根本没有什么难度，我拿个普及组省一没有任何问题。当时状态也是非常好，复赛的时候去日照那时候OI还是蒸蒸日上，疫情和强基计划还没有出台，日照的人很多，很多学校有庞大的队伍，当时的我也是感觉很羡慕</p>\n<p>然后是初三 自主招生 化学实验 CSP2020 自学记笔记（效率低的问题） 没有资源（不知道刷什么题） 想要有强校集训的氛围，但是这种快节奏的课容易走神，训练上面没有时间写代码，这是最严重的问题，中考超出50多分。 热情还是在的，当时会python还写过脚本学过爬虫 然后还在用e语言写窗口程序（当时不知道c#诶）</p>\n<p>中考结束后的暑假，那应该是状态前期比较好的一个暑假了吧...<br />\n暑假前期一中的自招班要提前去上一周课，当时是没有晚自习的，而且食堂特别好（后来才知道那段时间是特意那么搞的，平时食堂很烂），然后当时一中承诺学科竞赛要认真搞，我还想着联系教练（结果连教练都没有，笑，就是微机老师）。<br />\n印象最深的是当时一中的学姐学长回来宣讲，当时的我非常的心潮澎湃，看着他们描述的丰富多彩的大学生活，当然现实是从外表和言谈上已经完全看不出曾经是高中生了，所以确实应该有不错的大学生活。然后他们讲着在一中是怎么学习的，分享自己的经验，非常的从容。我当时就在想，假如有一天我进了省队拿了银牌或者以上，那么我也可以回来坐在那个讲台上，分享我学习OI的事情。那种激情确实很强的刺激我学习OI。</p>\n<p>我当时想法很简单要过完数据结构+图论的内容，然后后面再看DP。但是我当时只会照着OI-WIKI学，实际上学的太偏向模板了而且OIWIKI不是很通俗易懂。我当时列的计划不错，但是现实是我每天根本完不成，因为我看一会儿wiki然后看不懂就去搜搜了很多还是看不懂就浪费很多时间，再就是看一会儿经常往下翻总之还是有点静不下心。所以实际上我到8月份只学了线段树树状数组堆分块还有一些数论算法之类的，然后我就很急。这要开学可怎么办啊！我的想法是NOIP2021要拿高分然后冲省选的！然后第一次跟家长谈论停课。然后家长果然拒绝了还说了一些难听的话（大概就是以后我后悔了又要怪他之类的）（还有什么白养了之类的）。当然拒绝是理解的毕竟刚进入高中我对一中所谓的竞赛培养体系还抱有幻想。</p>\n<p>进入一中后，状态很好 然后最开始有教练，但是我想法太好了，有点飘了，然后意识到一个问题就是交流题目这种有刺激性的事会让我完全无法思考，所以晚自习做题效率很低。再就是代码能力还是差到后期头疼思维混乱了就只能出思路写不动代码。然后NOIP2021前实际上没学多少东西。 NOIP2021爆炸。接下来是复盘反思：数学基础薄弱，连方差的两种算法都不知道，概率期望不会算，排列组合水平差，所以恶补了很多数学，当然也是自学高中数学 然后实际上就偏离了对代码能力的培养：这和在学校没有电脑关系很大 再加上我对重点班的竞赛培养抱有幻想</p>\n<p>而且后来高一上几乎不怎么写作业然后期末级部30多名，然后被调进了所谓重点班。其实某种程度上说这也是噩梦的开始。我以为重点班老师会充分信任学生的能力，班里会有很多搞竞赛的，会有一个良好的氛围，即使压力很大，因为我之前也看过那些回忆录里面提到的竞赛班，很多都是长时间停课然后搞竞赛的，所以我的想法还是挺好的，所以那时候我都想好了要跟着学校进度走走看。然后就是高一下学期跟了一段时间文化课还去参加了SDOI2022，但是SDOI2022前没有任何准备，当时晚自习周末都没有去搞竞赛，就是偶尔跟着zgx搞一搞。但是只能说进入这个班之后压力骤增。老师并不是很信任这些学生，相反每周还要花很长的时间开班会来PUA。而且，这个班直接从普通班的楼搬出去了，某种意义上是物理隔离（当然你要主动去找也可以）。然后实际上老师和领导是有意鼓动这个班的内卷风气，而且PUA的内容就是清华北大。（其实我感觉去不去TP无所谓，华五好专业更好，真去TP可能就真抑郁了。。。）实际上班里并不支持学习竞赛，或者说学校是把竞赛看作是一种whk的补充或者说是为了强基校测准备的。（但是后来确实出了两个牌子一个PHO一个CHO，好像也没有额外的训练，当然我觉得CHO没有那么难）。在这样一个内卷的状态下实际上按照自己节奏学习WHK是一件很难的事情，实际上像物理，老师讲的很快而且实际上也讲不出什么，更多时间还是应该按照自己体系来进行学习（我高中物理跟这个老师成绩挺差的裸分有时候70多）（后来准备少创时候是按照小时百科重学了一遍相当于），然后真正的去理解一个题目。生物也是，后来我生物是看网课才得到比较大的提升。所以实际上这一个学期我是挺痛苦的，不仅没有学到OI上什么东西把SDOI2022浪费了，这可是我唯一去省选的机会啊。然后WHK上我又很痛苦，明明假期家长已经拉着我预习一遍了，我还要再学一遍干啥。所以实际上根本没办法静下心来，反而把时间都浪费了。这可能是最后悔的一件事。</p>\n<p>当时还有另外一个有趣的事情，就是5月时候，突然想把学生平板破解了，然后就和wk研究刷机，然后了解到华为的Bootloader，然后那时候有一个开源工具叫potatonv，但是不是很好用。后来我读了potatonv的源码手动复现了他的解锁原理。然后当时有一篇很著名的安全报告，或者说两篇描述的同一件事情：华为海思麒麟芯片上的安全启动漏洞，一个是taszk pdf的，一个是pangu的。然后当时看了，但是还有很多细节不理解，但是由于我的平板是麒麟659和论文对不起来再加上用不上，所以就放弃了，想着以后有什么时间再复现一下。结果拖了4年...（然后2025年上半年复现了，后果惨重）.然后当时我们两个研究了怎么解BL 刷TWRP，然后我们研究了好久双系统，最终找到了一种在SD卡上跑双系统的办法。当时，我突然看到一个项目叫做POSTMARKETOS，是在手机上面移植linux，但是当时一个是没时间再一个也不是很懂设备树什么的，但是就想着这件事，以后要研究怎么在手机上面移植Linux。另外当年最震撼的项目就算Renagade Project，在手机上安装Windows，这个可是我从小学开始的梦想啊！然后我就想着也许麒麟也可以移植UEFI（现在觉得这是不可能的我有点疯了）。另外一件事就是初二疫情的时候我入坑了Limbo模拟器吧，但是玩了一会儿发现手机模拟电脑架构速度太慢，所以就想着开KVM。当时KVM是圈子里面最高的神话。所以说我后来每次遇到一个手机/芯片，都想着在上面开KVM，但是到现在我还是没有研究清楚（现在状态毁了）。<br />\n从这件事来看，我当时还是有比较强烈的对计算机的热情的，虽然写不动算法竞赛题目的代码但是一些有趣的小项目工具我还是愿意写的，比如说yichafen爬虫，比如说谷歌小恐龙自动玩，还有写过OJ，虽然只是C++写的后端。还有当时我为什么还在用易语言写窗口程序！甚至和C语言结合起来！当时我为什么不想着学一门正经的窗口编程语言比如C#...但是我没有想过开发一个大型工程。当然当时更不会想着什么开发方向或者安全方向（虽然初二就研究过几次SQL注入但是发现大部分网站都修复了然后剩下的没有任何了解）。所以说这实际上也是埋下了一个伏笔。但是正常来说这样的状态大学接着系统的学习计算机或者打ICPC最后肯定看起来没什么问题，当然这是后话了。</p>\n<p>这种热情到NOIP前就已经消失殆尽了，当时为了停课都疯了，当时就好像一个失心魔，每天回家就要和父母大吵一架，大喊大叫(嗓子也喊坏了...)，然后在学校动不动早读的时候或者语文课的时候就砸桌子或者一个人跑出去然后开始哭，后来还写纸条给各科老师和主任希望只要有一个同意的。这样我的心态受到了很大的影响，本来想的是静下心思考认真训练，但是为了停课我的心态已经爆炸了心情已经很不好了，已经没有精力接着认真学习，而且这样我就感觉很急好像如果我NOIP考的不好所有人立马就会反对我，所以说实际上把所有希望都寄托在NOIP2022上了，这样自己一旦想不出题就特别焦虑，又不敢看题解，因为看题解之后我就感觉自己很傻然后心态更差了...所以那段时间每天投入大量的精力学习OI尤其是重心放在一些复杂的trick和思维题上面，当然也补了暑假zhengrui没学会的东西，但是收效甚微而且每天心情都很差经常大喊大叫然后很焦虑，然后基本上实际上一天什么也没干，而且我执行力差很多细节复杂的题的代码本来都没有写现在这个状态基本上就是只看题不写题了。<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260122000619030-1117947224.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260122000629006-1193078129.png\" /><br />\n那时候的题单到后来也没写完...而且以前题目写错了尤其是思路错了我会心态很好的调试，然后换思路，但是从高中开始，我越来越惧怕这种失败了，这种浪费时间的失败，因为时间紧迫，所以说一旦想错了我就很自责，久而久之就害怕写代码调试了。所以说这可能是导致我代码能力下降的又一个重要原因。<br />\n所以说实际上这时候NOIP是注定要爆炸的，10月份开始就有很清晰的预感，只不过心里总是想着万一上天眷顾我一次呢！万一题目合我的胃口呢！<br />\n但是那时候我还有一丝希望，因为还有CSP！<br />\n当时是星期三，我那天又很生气，然后想着停课，毕竟马上CSP了，</p>\n<p>但是现在想想，其实OI的失败是必然的，我早就没有良好的心态了，而且我做事情的目的已经从纯粹的兴趣变成了我要被别人认可我要被别人承认我要拿到成绩，这种目的性太强了，而且我的执行能力比较差，虽然也尝试过很多比如列计划，整理笔记等方式但是效果只能说没什么用。而且我的精力严重不够，就像前面说的那样，看一会儿电脑就头疼，而且在电脑前思维非常的混乱，如果不借助草稿纸，甚至感觉不能正常的思考。（这个现在倒是好一点，但是就是效率太低）即使休息的很好第二天也是很累浑身乏力，更何况有时候我会陷入幻想根本睡不着。而且我总是有一种幻想就是我可以像淄博的那两位那样或者像lx那样从没有资源没有支持的地方逆袭翻盘，但是实际上我的天赋根本不支持如此，而且实际上那些大佬虽然在弱校但是却能够经常出去集训，也就是说能够把握一手的考试方向和主流的题目，而且有一个正常的人际交往，而且他们的天赋都比较厉害。而且OI也没有以前纯粹了，以前圈子的互帮互助分享交流变成了一种很奇怪的p话文化，不仅仅是卖弱这么简单，而是有时候感觉有一种强烈的歧视感，而且虽然资源现在是够多了但是主流的方向还是不好自己把握。而且，题目的难度正在变怪，从原来的考察代码能力+算法/数据结构积累能力+一定的思维能力 变成了 思维能力为主或者说是更加偏向于数竞这种启发性的考试了。这在工程意义上我觉得不是什么好事儿。但是，关键问题是，OI退役后，事情并没有好起来。</p>\n<p>NOIP出分之后，我还是不服气，当时疫情隔离结束之后返校了。结果，返校之后，老师把我桌子拖到了最后一排。返校之后课上当时还在继续学习准备省选知识点，那时候状态还可以，还想着省选还可以翻盘。但是，当时级部主任把我平板没收了，看我上课在看平板。然后我心情就挺差的。不过当时我还是有自信的毕竟我觉得NOIP的T3只要当时清醒一点把DP方程改对就一点问题没有了。但是后来，家长开始说我，让我开始补文化课，然后又拿期末考试说事儿。而且，当时，刚好疫情解封前最混乱的时期，在学校里面关了两个周。那时候我在想的一件事是，我到底有没有能力或者说有没有希望省选翻盘？我当时翻了Cmd2001大佬的博客（他是noip2017二等奖然后省选翻盘NOI2018Ag）的翻盘记录，看着充满希望。</p>\n<p>然后当时中午午休的时候没有宿舍住（因为我走读），就跑到二楼的那个据说是生物竞赛的活动室里面。里面有一台电脑。我中午就躲在里面把门反锁，打开电脑听歌，然后就在那里哭。<br />\n直到有一天，那天的中午我感觉很冷，别人都回去睡觉了，我吃完饭在教室里全身发冷，即使有暖气。然后我就怀揣着希望进了竞赛室。那天竞赛室还有别人，我就没有使用电脑，然后坐在那里。屋子里面开空调了，很暖和<br />\n。过了一会儿，生物竞赛教练进来了。我刚要开口，他就说：谁让你进来的？来着干什么？是不是来这玩电脑？ 然后我想了一会儿，硬生生地没有开口：我是信息竞赛生。然后想了想带上所有东西头也不回的走了。那一瞬间，有一种绝望感，就是一种被世界抛弃了。然后，哪天晚上我就发烧了，结果是感染新冠了。</p>\n<p>自从这件事之后，我突然有一种学不下去省选内容的感觉，而且有一种几乎命中注定的感觉：无论怎么努力省选也不可能翻盘。后来我就很少再跟别人提及OI。直到WC快报名的时候，zgx家长问我家长要不要报，我一看，WC竟然改成线上了，这让我感觉有一种走形式的感觉。我看到之前博客里面大家去WC然后互相交流面基的感觉很快乐，但是这种东西已经没有了。我意识到，WC很贵我要是报了我家长到时候一定拿掏钱这个事来PUA我，于是，我主动拒绝了。就这样，我OI就退役了。从这之后，上大学之前，我就再没有碰过一道算法竞赛题，没有学习任何一个新算法。</p>\n<p>然后，我意识到我回归不了WHK了。之前我设想的我能坦然回归whk至少是省选结束之后，然后按照我自己的节奏好好的学习一下WHK。但是现实是，回归之后，家长/老师对我期望很高，希望我回到扔whk搞OI之前的状态--就是高一下期末660+的状态。而且我根本没有理由向别人说我能自己做好这件事。因为很简单：我只是NOIP低分省一连省选都没打就退役了，也没有什么牌子。所以说实际上他们的期望更高了但是信任度更低了。所以说，我期末考的并不好。当时有点害怕，害怕到高三还是回不到之前的状态。（但是事实证明实际上就算不搞OI我可能也没有一个理想的状态，因为我的精力严重不够）然后寒假就是被家长拉去搞whk了。</p>\n<p>这时候，谁能想到一个东西即将再次撞击我的命运。</p>\n<p>考上少年班之后，当时其实我很高兴。我想到，三年前，我坐在阶梯教室里面，看着台上的学长热情洋溢地讲着自己的大学生活和高中的努力（而且真的看不出是高中生了，明显是适应了大学生活），我幻想着有一天也能像他们一样。但是现在，我的确做到了，甚至说比他们做的更好（毕竟是xha第一个去的），我利用自己的省一奖项，降一本线进入华东五校止一---USTC，这相当于我已经做到了自主招生时代所谓的一本约。我想着我终于可以拾起来我之前没有做的事情，我可以出去转一转，我要出去讲OI课，有一天我也要回学校宣讲。我希望有一天xha有自己的竞赛组织，能够请一些人讲课（就像那些学长博客里面提到的那样学校请他们回去讲课）（我看到一个重庆大学的都被邀请回去了）。我想着我终于能够被承认了，然后我就可以有我的自由，然后就可以有我自己的大学生活了。但是，现实里面有一种隐隐的不详的预感。那天出分之后第二天家长就不让我去学校了，当然说是保护我，我觉得有一点道理。但是我还想着回学校吹一手(bushi).然后问题来了，家长开始PUA我了。大概意思就是考上之后不能放松，要更努力，暑假要提前预习，然后说意思就是我没有这个能力就是运气好之类的...然后我就有一种失落感，总感觉这个不是自己考上的。然后我发现进入重点班之后我开始严重的缺乏安全感，每天都有一种被监视的感觉，当然不是因为重点班内卷，而是有一种刻意营造出来的感觉。所以说我开始缺乏自信。然后家长开始PUA我，所以我暑假也没有自己的自由干事情，而且我也没怎么自己出去，因为我发现自己出去在家里几乎是不可能的，家长总要找一个借口陪着我。客观的讲陪着我当然也很好，但是我还是喜欢和朋友（当然可能是初中朋友）或者是其他搞oi的同学出去。说实话。而且我根本不想预习大学的任何东西因为我OI欠下来的东西还没有填上。再者说我之前也自学过高数。当时我和家长提大学打ICPC，谁知道他们先说什么ICPC再好被退学了有什么用？然后又是开始吵架...然后我暑假去了之前我初二去的那个机构，虽然只学了一年实际上也就是语言入门但是还一直保持联系。结果去了之后我一点也不自在，本来是我考上好学校，而那个机构只有普及组教学的水平，按理来说我是完全有理由平等的过去交流甚至可以去那边讲课。但是现实是我家长去了然后就开始低声下气在那边问大学要准备什么？大学xxx怎么怎么样，然后又是听机构的创始人东扯西扯说一些大道理，但是现实是在那边听一个QDU和石油大学毕业的，而且大概率是计算机学的不怎么样的人的经验没什么参考价值(毕竟这个机构工资不高正经人谁去啊），跟我说的东西和USTC的现实实际上是一点对不上，然后又问ICPC怎么样，结果xxx竟然说什么ICPC对于这种大学没什么用。那我只能说没啥意思了，这就把我家长给忽悠住了，刚好他不想让我大学打ICPC。毕竟现实是USTC 2025 ICPC预选赛报名队伍数量是全国最多的。反正去了一下午感觉很不舒服，就好像在那边受罪一样，全程我都不怎么说话。这件事我就挺失望的。我感觉不管我做到多好都没有人真正认可我。但是为什么他们就能认可别的Oier呢?</p>\n<p>然后暑假家长还是不让我大学打游戏。其实说实话我不愿意打游戏，但是这样我感觉很不舒服，连手机横屏都不敢了。而且现实是我好像连网购都没有网购过。我好像自己买的东西都不敢往家带，因为家长会翻书包，然后就会说我。（之前停课写的纸条被翻出来还挨骂了...)</p>\n<p>暑假时候当时还是缺乏自信不敢找同学玩，但是当时也有人来主动找我，gxh当时来找我，然后本来我们两个玩玩就挺好的，我两个高一上是同班同学，关系也不差。但是非要也不知道为什么家长非要去。那就变成那种无聊的饭局了...然后说是我们两个随便聊，现实是我根本开不了口因为两个家长一直在那边谈什么教育（当然又是经典的那些了...），然后我就在那边看手机，然后家长又骂我一顿说我出去吃饭怎么不说话...</p>\n<p>然后暑假就闷在家里也不知道干什么，被勒令预习，但是肯定是学不下去的，然后别的事情又放松不下来不敢干。我感觉家里已经不是让我放松的地方了...出门就去一趟日照而且感觉挺没意思的...所以说那时候就有一种强烈的感觉，这个学校不是我自己考上的，是别人恩赐给我的...我的能力其实不配。然后一种失望的感觉。</p>\n<p>就这样这个暑假过得很失败，甚至没有调整好开学前的状态，就是我找不到那种我刚开始搞OI时候那种我为了一个美好的事物然后全力的投入尽可能每个方面都做的很好的状态了。</p>\n<p>开学之后，然后你就知道了，彻底的crash...<br />\n而且最重要的是心里一点安全感没有，有一种我所做的一切都在被监视的感觉，根本没法静下心来学习。而且，我又找不到我对计算机的热情了，我只看到了一种很茫然的内卷。然后就是一点点的crash、...</p>\n<p>所以说为什么会这样，还是因为我想要的东西不仅没有被满足反而越来越远了，而且严重的内卷导致曾经我认为很厉害的东西现在可能已经烂大街了，这就消磨了我的热情。更重要的是长久缺失正反馈，失去自信，失去那种自然而然地感觉，相反后来充满着警觉感，在家里不敢和朋友打电话，不敢提出去玩的事情，不敢在家里把手机横屏，在公共场合总感觉别人盯着我，外面手机亮度开到最低总感觉别人在看我的手机屏幕，上课不敢记笔记总感觉别人盯着我。感觉我失去了安全感，或者说我的自由 我的隐私空间 我想做的事情 以及支撑我学OI最大的目标/动力这些并没有随着我考上中科大少创而有所缓解，反而加重了。有一种全世界都在和我作对没有人认可我的感觉，有一种即使很尽力了但是没有人相信我的感觉，所以突然就不想再碰OI了。之前在OI时候立志要培养的良好习惯，包括坚持记笔记，坚持深度思考，提高自控力（因为我确实从小自控力差执行能力差拖延严重，现在我觉得有可能是ADHD？）这些我自己觉得我做的不错的事情没有人相信我，相反我好像就像坐在监牢里面一样，这就是一种深深的失望。而且我又一种我没办法检验我自己全部能力的感觉。我高中基本上不写作业语文英语从来不学，但是高考语文121英语128（平时能上130，毕竟是高二考），所以我认为停课一段时间之后再补WHK并不是很困难的事情，但是没有人相信我。当然也不要指望竞赛圈的人能理解我，毕竟我不混圈，或者说我当时并不想当什么圈子的网红，而且竞赛圈大把人小学开始学习竞赛在强校有着充足的资源进行停课训练，所以说他们都看不上我们这些弱校的。（毕竟我们这一届是第一个NOIP省一喵，当然第一个是zgx）</p>\n<p>为了OI我之前4年不打游戏（其实在学OI之前家里不让打但是偷偷打），然后初二自学初三数学初三自学高中数学离散的部分，然后每个暑假又被家长拉着预习了高中其他科目，高一自学高中数学剩下的部分。高中又自学高数，线代，组合数学的一部分，具体数学，甚至还有一点群论，目的都是为了OI，当时想着我要提高数学水平因为当年NOI2019考了一道具体数学原题，所以我认为OI需要很高的数学水平。虽然我自学时候效率确实很低，经常忍不住往后翻或者干别的，但是的确也学了不少内容。但是即使这样我还是不能停课，然后明明提前自学过还是要开学上课，那我说我寒暑假不要预习其他科目了，反正开学还要上课，但是家长拉着我预习而且还跟我说什么不然就考不上大学，什么竞赛影响文化课就不要弄了，反正我做什么都不会相信我的能力，所以说我久而久之也不知道自己到底有没有这个能力了。然后我的同学后来把我当成小丑看因为他们别的竞赛似乎从来不需要停课，老师也觉得我很菜没有那个水平还整天装。但是现实是我的确也没有那个能力，比如说我的执行能力差，以及容易分心，比如说网上很多的经验是把竞赛资料打印出来课上看，但是现实是课上我根本看不下去过一会儿就会被课程的声音吸引就走神了，自习课能好一点，但是有时候周边同学的打扰就会让我完全静不下心无法思考，甚至我在做题时候如果和机房的zgx交流一点解法（哪怕只是几句话，这就是为什么高中不和别人交流问题了）那么这一晚上基本上做不下去了（现在越看越像ADHD）。但是whk上却不是这样，whk的内容偏简单不需要深度思考，逻辑链很短，更多的是一个心态和熟练度的问题，也就是如何以高正确率保证考场答完题，所以来说，在whk上这些困扰没有体现出来。而且长时间的OI学习让我满脸长痘整天头疼，也完全没有心情打理任何东西，所以外貌和声音也没有以前那么可爱了（现在后悔了...),但是当时想着只要我在OI上拿到牌子那么一切都会好起来，别人就一定会承认我的，所以根本没有在意这些。我以为考上大学之后就能够重新拾起来这些东西看看自己到底有没有这个能力，谁知道那种不被认可的感觉那种失望感让我觉得我的确是废物我没有什么能力。更重要的是我有点失去了目标。而且更重要的是我有一种很强的挫败感，就是我自己想做的事情总是因为各种原因做不好或者达不成希望，这可能就是我执行力太差加上命中缺这一环吧，我好像什么也干不好。大学之后，我原来想要的东西并没有实现，可是，来到科大，我并没有很快开始学习熟悉的计算机，相反，学校的数理基础课程占满了我的时间，别人都在内卷、科研，我想象中一个计算机式的大学生活并没有出现。（至少在我的印象里或者我看到学长宣讲/大佬博客的印象里），而且实际上我好像很多事情都还不会做。<br />\n高中时候实际上和同学关系也不算太差，但是也没有特别好的朋友 ，实际上也没什么社交，对异性也没什么兴趣（甚至说对性行为没什么兴趣）。高中也没有手机也不看什么娱乐的，虽然我破解了学校的学习平板，但是只是在上面看数学书/oi题/知乎上的学习性文章。生活上面实际上我很希望自由甚至说某种意义上学OI本身就是为了追求某种自由，但是高中时候学校家长没有给我这些，当时我也不是很在意因为所有心思都在OI上面，但是现在当我真正需要这些东西的时候发现好像我做不好生活上面的一些小事（当然也许是有ADHD导致的？），而且就像前面说的那样我失去了安全感。</p>\n<p>然后现在好想放松一下。</p>\n\n</div>\n<div id=\"MySignature\">\n    <p>黄粱一梦，终是一空</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/hicode002/\" target=\"_blank\">hicode002</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/hicode002/p/-/oi-memories\" target=\"_blank\">https://www.cnblogs.com/hicode002/p/-/oi-memories</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 11:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hicode002\">hicode002</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Stern-Brocot 树",
      "link": "https://www.cnblogs.com/rgw2010/p/19525731",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rgw2010/p/19525731\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 11:39\">\n    <span>Stern-Brocot 树</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"p1797-模板stern-brocot-树\"><a href=\"https://www.luogu.com.cn/problem/P1797\" rel=\"noopener nofollow\" target=\"_blank\">P1797 【模板】Stern-Brocot 树</a></h2>\n<p><a href=\"https://www.luogu.com.cn/article/dv07cla2\" rel=\"noopener nofollow\" target=\"_blank\"><strong>洛谷同步题解。</strong></a></p>\n<blockquote>\n<p>前置知识：<span class=\"math inline\">\\(a \\perp b\\)</span> 等价于存在 <span class=\"math inline\">\\(x, y\\)</span> 使得 <span class=\"math inline\">\\(ax + by = 1\\)</span>。</p>\n</blockquote>\n<p>Stern-Brocot 树是一个包含着所有 <span class=\"math inline\">\\(m \\perp n\\)</span> 的全部非负的分数 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 的二叉树结构；其思想是从 <span class=\"math inline\">\\(0\\)</span> 阶 Stern-Brocot 序列 <span class=\"math inline\">\\(\\{\\frac{0}{1}, \\frac{1}{0} \\}\\)</span> 出发，高阶 Stern-Brocot 序列由以下递归操作定义：</p>\n<ul>\n<li>对于一个 <span class=\"math inline\">\\(k\\)</span> 阶 Stern-Brocot 序列，在其任意两个相邻分数 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 与 <span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 之间插入它们的<strong>中位分数</strong> <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span> 后形成的序列即为 <span class=\"math inline\">\\(k + 1\\)</span> 阶  Stern-Brocot 序列。</li>\n</ul>\n<p>例如：</p>\n<ul>\n<li>\n<p><span class=\"math inline\">\\(1\\)</span> 阶是 <span class=\"math inline\">\\(\\{ \\frac{0}{1}, \\frac{1}{1}, \\frac{1}{0} \\}\\)</span>。</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(2\\)</span> 阶是 <span class=\"math inline\">\\(\\{ \\frac{0}{1}, \\frac{1}{2}, \\frac{1}{1}, \\frac{2}{1}, \\frac{1}{0} \\}\\)</span>。</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(3\\)</span> 阶是 <span class=\"math inline\">\\(\\{ \\frac{0}{1}, \\frac{1}{3}, \\frac{1}{2}, \\frac{2}{3}, \\frac{1}{1}, \\frac{3}{2}, \\frac{2}{1}, \\frac{3}{1}, \\frac{1}{0} \\}\\)</span>。</p>\n</li>\n</ul>\n<p>容易看作二叉树的结构：</p>\n<ul>\n<li>每个分数都是 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span> 的形式，其中 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 是左上方离它最近的祖先，<span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 是右上方离它最近的祖先。</li>\n</ul>\n<p>oi-wiki 上的图较为形象，大家可以看着理解下：</p>\n<p><img alt=\"\" src=\"https://oi-wiki.org/math/number-theory/images/stern-brocot-tree.svg\" /></p>\n<p>为什么树上的都是最简分数？为什么不会重复出现某个分数？为什么所有可能的非负的最简分数都会在树上出现？</p>\n<p>容易发现这样一个性质，如果 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 和 <span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 在某一阶的 Stern-Brocot 序列中相邻，那么必然满足：</p>\n<p></p><div class=\"math display\">\\[m'n - mn' = 1\n\\]</div><p></p><blockquote>\n<p>证明考虑数学归纳法，初始 <span class=\"math inline\">\\(0\\)</span> 阶时有 <span class=\"math inline\">\\(1 \\cdot 1 - 0 \\cdot 0 = 1\\)</span>；若当前 <span class=\"math inline\">\\(k\\)</span> 阶 Stern-Brocot 序列中满足条件，那么在 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 与 <span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 中间插入的 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span>，相当于要证明：</p>\n<p></p><div class=\"math display\">\\[(m' + m)n - m(n + n') = 1\n\\]</div><p></p><p></p><div class=\"math display\">\\[m'(n + n') - (m + m') n' = 1\n\\]</div><p></p><p>第一个直接拆开 <span class=\"math inline\">\\(m'n + mn - mn - mn' = m'n - mn' = 1\\)</span>，第二个同理；于是得证。</p>\n</blockquote>\n<p>同时，上面 <span class=\"math inline\">\\(m'n - mn' = 1\\)</span> 这个式子也可以说明 <span class=\"math inline\">\\(m \\perp n, m' \\perp n'\\)</span>，那么可以得到树上的所有分数必然是<strong>最简分数</strong>。</p>\n<p>然后来考虑插入的分数的大小关系，显然有：</p>\n<p></p><div class=\"math display\">\\[\\frac{m}{n} &lt; \\frac{m + m'}{n + n'} &lt; \\frac{m'}{n}\n\\]</div><p></p><p>即一个中位分数在它原先两个值的中间，于是树上必然没有重复的分数。</p>\n<p>好，接下来要证所有正的最简分数 <span class=\"math inline\">\\(\\frac{a}{b}\\)</span> 都在树上出现，考虑反证法，初始显然：</p>\n<p></p><div class=\"math display\">\\[\\frac{m = 0}{n = 1} &lt; \\frac{a}{b} &lt; \\frac{m' = 1}{n' = 0}\n\\]</div><p></p><p>然后假设当前阶段有：</p>\n<p></p><div class=\"math display\">\\[\\frac{m}{n} &lt; \\frac{a}{b} &lt; \\frac{m'}{n'}\n\\]</div><p></p><p>考虑 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span> 与 <span class=\"math inline\">\\(\\frac{a}{b}\\)</span> 的大小关系：</p>\n<ul>\n<li>\n<p>若 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'} = \\frac{a}{b}\\)</span>，与命题矛盾，退出。</p>\n</li>\n<li>\n<p>若 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'} &lt; \\frac{a}{b}\\)</span>，令 <span class=\"math inline\">\\(m \\gets m + m', n' + n\\)</span>。</p>\n</li>\n<li>\n<p>否则 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'} &gt; \\frac{a}{b}\\)</span>，令 <span class=\"math inline\">\\(m' \\gets m + m', n' \\gets n + n'\\)</span>。</p>\n</li>\n</ul>\n<p>考虑证明这个过程不会无限进行下去，因为：</p>\n<p></p><div class=\"math display\">\\[\\begin{cases} \\frac{a}{b} - \\frac{m}{n} &gt; 0 \\\\ \\frac{m'}{n'} - \\frac{a}{b} &gt; 0 \\end{cases}\n\\]</div><p></p><p>即：</p>\n<p></p><div class=\"math display\">\\[\\begin{cases} an - mb &gt; 0 \\\\ m'b - n'a &gt; 0 \\end{cases}\n\\]</div><p></p><p>显然 <span class=\"math inline\">\\(an - mb, m'b - n'a\\)</span> 都是整数，于是：</p>\n<p></p><div class=\"math display\">\\[\\begin{cases} an - mb \\ge 1 \\\\ m'b - n'a \\ge 1 \\end{cases}\n\\]</div><p></p><p>然后必然有：</p>\n<p></p><div class=\"math display\">\\[(m' + n')(an - mb) + (m + n)(m'b - n'a) \\ge m' + n' + m + n\n\\]</div><p></p><p>前面把 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(b\\)</span> 专门提出来：</p>\n<p></p><div class=\"math display\">\\[a(n(m' + n') - n'(m + n)) + b(m'(m + n) - m(m' + n'))\n\\]</div><p></p><p>然后它们的系数可以根据 <span class=\"math inline\">\\(m'n - mn' = 1\\)</span> 化简成 <span class=\"math inline\">\\(1\\)</span>，于是：</p>\n<p></p><div class=\"math display\">\\[a + b \\ge m' + n' + m + n\n\\]</div><p></p><p>而上面每次操作中 <span class=\"math inline\">\\(m' + n' + m + n\\)</span> 都会增加，于是至多进行 <span class=\"math inline\">\\(a + b\\)</span> 次后就会退出，即找到 <span class=\"math inline\">\\(\\frac{a}{b}\\)</span>；于是证明了<strong>所有非负分数即正有理数</strong>都在树上，可以将 Stern-Brocot 树看作一个<strong>有理数的数系</strong>。</p>\n<p>因为每个正最简分数只出现一次，所以其与树上从根到它的路径是一一对应的，即我们可以用字母 <span class=\"math inline\">\\(L, R\\)</span> 来表示当前节点是往左右哪个儿子去走，一串 <span class=\"math inline\">\\(L, R\\)</span> 组成的序列就唯一的表示了一个位置；例如 <span class=\"math inline\">\\(LRRL\\)</span> 表示 <span class=\"math inline\">\\(\\frac{1}{1} \\to \\frac{1}{2} \\to \\frac{2}{3} \\to \\frac{3}{4} \\to \\frac{5}{7}\\)</span>；特别的，对于 <span class=\"math inline\">\\(\\frac{1}{1}\\)</span> 用 <span class=\"math inline\">\\(I\\)</span> 来表示。</p>\n<p>考虑这样一个问题，给出一组 <span class=\"math inline\">\\(L, R\\)</span> 组成的字符串 <span class=\"math inline\">\\(S\\)</span>，求出其对应的分数是什么？</p>\n<p>容易想到从初始 <span class=\"math inline\">\\(\\frac{1}{1}\\)</span> 开始，动态维护这个点是由左右哪两个节点合并的，初始是 <span class=\"math inline\">\\(\\frac{m = 0}{n = 1}, \\frac{m' = 1}{n' = 0}\\)</span>：</p>\n<ul>\n<li>\n<p>若 <span class=\"math inline\">\\(L\\)</span> 往左走：那么左祖先不会变，右祖先会变成当前节点；即 <span class=\"math inline\">\\(m' \\gets m + m', n' \\gets n + n'\\)</span>。</p>\n</li>\n<li>\n<p>若 <span class=\"math inline\">\\(R\\)</span> 往右左：同理，那么右祖先不会变，左祖先会变成当前节点；即 <span class=\"math inline\">\\(m \\gets m + m', n \\gets n + n'\\)</span>。</p>\n</li>\n</ul>\n<p>大家理解的时候可以看前面那个树的图来理解；然后我们就可以写下如下代码解决：</p>\n<pre><code class=\"language-cpp\">inline pair&lt;int, int&gt; getLR(string s){\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i] == 'L')\n\t\t  m_ = m + m_, n_ = n + n_;\n\t\telse\n\t\t  m = m + m_, n = n + n_;\n\t}\n\treturn mkp(m + m_, n + n_);\n}\n</code></pre>\n<p>当长度很长时，即给定是 <span class=\"math inline\">\\(L/R\\)</span> 每次走几次，也可以根据式子直接做：</p>\n<pre><code class=\"language-cpp\">inline pair&lt;int, int&gt; getLR(vector&lt;pair&lt;char, int&gt;&gt; s){\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i].fi == 'L')\n\t\t\tm_ = s[i].se * m + m_, n_ = s[i].se * n + n_;\n\t\telse\n\t\t\tm = m + s[i].se * m_, n = n + s[i].se * n_;\n\t}\n\treturn mkp(m + m_, n + n_);\n}\n</code></pre>\n<p>这种还是太程序性了，数学语言怎么表示？容易想到矩阵，即初始：</p>\n<p></p><div class=\"math display\">\\[M(S) = \\begin{pmatrix} n &amp; n' \\\\ m &amp; m' \\end{pmatrix}\n\\]</div><p></p><p>这里为啥不用像分数那样上面分子下面分母呢？主要是此时初始根节点的状态 <span class=\"math inline\">\\(M(I) =  \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}\\)</span> 这是一个单位矩阵，而用分数的表示形式的话不是单位矩阵要多乘一个矩阵，形式上也不那么清晰。</p>\n<p>然后考虑：</p>\n<p></p><div class=\"math display\">\\[M(SL) = \\begin{pmatrix} n &amp; n + n' \\\\ m &amp; m + m' \\end{pmatrix}\n\\]</div><p></p><p></p><div class=\"math display\">\\[M(SR) = \\begin{pmatrix} n + n' &amp; n' \\\\ m + m' &amp; m' \\end{pmatrix}\n\\]</div><p></p><p>那么可以推出 <span class=\"math inline\">\\(L, R\\)</span> 矩阵：</p>\n<p></p><div class=\"math display\">\\[L = \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix}\n\\]</div><p></p><p></p><div class=\"math display\">\\[R = \\begin{pmatrix} 1 &amp; 0 \\\\ 1 &amp; 1 \\end{pmatrix}\n\\]</div><p></p><p>即：</p>\n<p></p><div class=\"math display\">\\[M(SL) = M(S) L, M(SR) = M(S) R\n\\]</div><p></p><p>于是求 <span class=\"math inline\">\\(M(S)\\)</span> 时，可以看作是 <span class=\"math inline\">\\(S\\)</span> 中的 <span class=\"math inline\">\\(L, R\\)</span> 作矩阵乘法，例如 <span class=\"math inline\">\\(M(LRRL) = LRRL = \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 &amp; 0 \\\\ 1 &amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 &amp; 0 \\\\ 1 &amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix} = \\begin{pmatrix} 3 &amp; 4 \\\\ 2 &amp; 3 \\end{pmatrix}\\)</span>。</p>\n<p>于是求 <span class=\"math inline\">\\(S\\)</span> 所对应的分数只需要经过矩阵运算得到：</p>\n<p></p><div class=\"math display\">\\[f(S) = f(\\begin{pmatrix} n &amp; n' \\\\ m &amp; m' \\end{pmatrix}) = \\frac{m + m'}{n + n'}\n\\]</div><p></p><p>那么现在考虑给定一个分数 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span>，求其唯一对应 <span class=\"math inline\">\\(LR\\)</span> 序列这个问题？这就比较简单了，根据生成规则，我们知道 Stern-Brocot 树是一颗二叉搜索树，即左子树的点都比它小，右子树的点都比它大，于是可以通过比较与当前位置的值来决定。</p>\n<p>那么可以写下如下代码：</p>\n<pre><code class=\"language-cpp\">inline string backLR(int m, int n){\n\tstring ans = \"\";\n\tMat S;\n\twhile(1){\n\t\tauto t = f(S);\n\t\tif(t == mkp(m, n))\n\t\t  break;\n\t\tif(mkp(m, n) &lt; t){\n\t\t\tS = S * L;\n\t\t\tans.push_back('L');\n\t\t}\n\t\telse{\n\t\t\tS = S * R;\n\t\t\tans.push_back('R');\n\t\t}\n\t}\n\treturn ans;\n}\n</code></pre>\n<p>显然，这个效率较为低下，且要进行矩阵运算；考虑怎么优化一下，注意到：</p>\n<p></p><div class=\"math display\">\\[RS = \\begin{pmatrix} n &amp; n' \\\\ m + n &amp; m'  + n'\\end{pmatrix}\n\\]</div><p></p><p></p><div class=\"math display\">\\[LS = \\begin{pmatrix} n + m&amp; n' + m' \\\\ m&amp; m'\\end{pmatrix}\n\\]</div><p></p><p>那么：</p>\n<p></p><div class=\"math display\">\\[f(RS) = \\frac{n + n'}{m + n + m' + n'} = f(S) + 1\n\\]</div><p></p><p></p><div class=\"math display\">\\[f(LS) = \\frac{n + m + n' + m'}{m + m'}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\frac{1}{f(LS)} = \\frac{1}{f(LS)} + 1\n\\]</div><p></p><p>设 <span class=\"math inline\">\\(F(\\frac{p}{q})\\)</span> 表示其对应的字符串；那么我们可以看出，若第一步为 <span class=\"math inline\">\\(R\\)</span>，则 <span class=\"math inline\">\\(\\frac{m}{n} &gt; 1\\)</span>，否则第一步为 <span class=\"math inline\">\\(L\\)</span>，则 <span class=\"math inline\">\\(\\frac{m}{n} &lt; 1\\)</span>，于是可以递归的去做：</p>\n<p></p><div class=\"math display\">\\[\\frac{m}{n} = f(RS) \\to \\frac{m - n}{n} = f(S)  (m &gt; n)\n\\]</div><p></p><p></p><div class=\"math display\">\\[F(\\frac{m}{n}) = R + F(\\frac{n}{m - n}) (m &gt; n)\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\frac{m}{n} = f(LS) \\to \\frac{m}{n - m} = f(S) (m &lt; n)\n\\]</div><p></p><p></p><div class=\"math display\">\\[F(\\frac{m}{n}) = L + F(\\frac{m}{n - m}) (m &lt;n)\n\\]</div><p></p><p>那么可以写出如下代码：</p>\n<pre><code class=\"language-cpp\">inline string backLR(int m, int n){\n\tstring ans = \"\";\n\twhile(m != n){\n\t\tif(m &lt; n){\n\t\t\tans.push_back('L');\n\t\t\tn = n - m;\n\t\t}\n\t\telse{\n\t\t\tans.push_back('R');\n\t\t\tm = m - n;\n\t\t}\n\t}\n\treturn ans;\n}\n</code></pre>\n<p>你发现这特别像更像减损法，于是可以用辗转相除法类似的思路去优化，即：</p>\n<pre><code class=\"language-cpp\">inline vector&lt;pair&lt;char, int&gt;&gt; backLR(int m, int n){\n\tvector&lt;pair&lt;char, int&gt;&gt; ans;\n\twhile(m &amp;&amp; n &amp;&amp; m != n){\n\t\tif(m &lt; n){\n\t\t\tif(n % m == 0)\n\t\t\t  ans.push_back({'L', n / m - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'L', n / m});\n\t\t\tn = n % m;\n\t\t}\n\t\telse{\n\t\t\tif(m % n == 0)\n\t\t\t  ans.push_back({'R', m / n - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'R', m / n});\n\t\t\tm = m % n;\n\t\t}\n\t}\n\treturn ans;\n}\n</code></pre>\n<p>此时就可以做到 <span class=\"math inline\">\\(O(\\log n)\\)</span> 复杂度去找对应的路径。</p>\n<p>然后对于一个分数 <span class=\"math inline\">\\(\\frac{p}{q}\\)</span>，考虑其在树上一个子树 <span class=\"math inline\">\\(S\\)</span>，显然 <span class=\"math inline\">\\(S\\)</span> 是无限大的，但是显然其有界，在 <span class=\"math inline\">\\((\\frac{a}{b}, \\frac{c}{d})\\)</span> 之间，那么怎么求出 <span class=\"math inline\">\\(a, b, c, d\\)</span> 呢？回到前面每次插入的中位分数在两个值之间的性质，于是这只是换一个问法，显然只是在问合并出 <span class=\"math inline\">\\(\\frac{p = a + c}{q = b + d}\\)</span> 的是哪两个分数，比较简单，求出 <span class=\"math inline\">\\(\\frac{p}{q}\\)</span> 的 <span class=\"math inline\">\\(LR\\)</span> 串后模拟一下即可。</p>\n<p>对于树上问题，容易想到 LCA，那么考虑 Stern-Brocot 树上的两个点 <span class=\"math inline\">\\(\\frac{a}{b}, \\frac{c}{d}\\)</span>，怎么求出它们的 LCA？容易发现，找到 <span class=\"math inline\">\\(\\frac{a}{b}, \\frac{c}{d}\\)</span> 的 <span class=\"math inline\">\\(LR\\)</span> 串 <span class=\"math inline\">\\(F(\\frac{a}{c}), F(\\frac{c}{d})\\)</span>，它们 LCP 的长度就是它们 LCA 的深度；而这个长度是容易求的，然后它们的 LCA 就是这个 LCP 对应的节点，套用上面函数一下即可。</p>\n<p>同理，<span class=\"math inline\">\\(\\frac{p}{q}\\)</span> 的树上 <span class=\"math inline\">\\(k\\)</span> 级祖先也是可以算出 <span class=\"math inline\">\\(F(\\frac{p}{q})\\)</span> 后删掉末尾的 <span class=\"math inline\">\\(k\\)</span> 个字符后套用前面函数得出。</p>\n<p>显然单次时间复杂度都是 <span class=\"math inline\">\\(O(\\log w)\\)</span>，总时间复杂度为 <span class=\"math inline\">\\(O(T \\log w)\\)</span>。</p>\n<p><a href=\"https://www.luogu.com.cn/record/258759645\" rel=\"noopener nofollow\" target=\"_blank\">link</a></p>\n<h3 id=\"完整代码\">完整代码：</h3>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\n#define ls(k) k &lt;&lt; 1\n#define rs(k) k &lt;&lt; 1 | 1\n#define lowbit(x) x &amp; (-x)\n#define fi first\n#define se second\n#define popcnt(x) __builtin_popcount(x)\n#define open(s1, s2) freopen(s1, \"r\", stdin), freopen(s2, \"w\", stdout);\n#define mkp(x, y) make_pair(x, y)\nusing namespace std;\ntypedef __int128 __;\ntypedef long double lb;\ntypedef double db;\ntypedef unsigned long long ull;\ntypedef long long ll;\nbool Begin;\ninline ll read(){\n\tll x = 0, f = 1;\n\tchar c = getchar();\n\twhile(c &lt; '0' || c &gt; '9'){\n\t\tif(c == '-')\n\t\t\tf = -1;\n\t\tc = getchar();\n\t}\n\twhile(c &gt;= '0' &amp;&amp; c &lt;= '9'){\n\t\tx = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);\n\t\tc = getchar();\n\t}\n\treturn x * f;\n}\ninline void write(ll x){\n\tif(x &lt; 0){\n\t\tputchar('-');\n\t\tx = -x;\n\t}\n\tif(x &gt; 9)\n\t\twrite(x / 10);\n\tputchar(x % 10 + '0');\n}\ninline pair&lt;int, int&gt; getLR(vector&lt;pair&lt;char, int&gt;&gt; s){\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i].fi == 'L')\n\t\t\tm_ = s[i].se * m + m_, n_ = s[i].se * n + n_;\n\t\telse\n\t\t\tm = m + s[i].se * m_, n = n + s[i].se * n_;\n\t}\n\treturn mkp(m + m_, n + n_);\n}\ninline vector&lt;pair&lt;char, int&gt;&gt; backLR(int m, int n){\n\tvector&lt;pair&lt;char, int&gt;&gt; ans;\n\twhile(m &amp;&amp; n &amp;&amp; m != n){\n\t\tif(m &lt; n){\n\t\t\tif(n % m == 0)\n\t\t\t  ans.push_back({'L', n / m - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'L', n / m});\n\t\t\tn = n % m;\n\t\t}\n\t\telse{\n\t\t\tif(m % n == 0)\n\t\t\t  ans.push_back({'R', m / n - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'R', m / n});\n\t\t\tm = m % n;\n\t\t}\n\t}\n\treturn ans;\n}\ninline pair&lt;int, int&gt; getkfa(int m, int n, int k){\n\tauto V = backLR(m, n);\n\tint sum = 0, len = V.size();\n\tfor(int i = 0; i &lt; len; ++i)\n\t  sum += V[i].se;\n\tif(sum &lt; k)\n\t  return mkp(-1, -1);\n\tvector&lt;pair&lt;char, int&gt;&gt; fa;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(!k)\n\t\t  break;\n\t\tif(V[i].se &lt;= k){\n\t\t\tfa.push_back(V[i]);\n\t\t\tk -= V[i].se;\n\t\t}\n\t\telse{\n\t\t\tfa.push_back(mkp(V[i].fi, k));\n\t\t\tk = 0;\n\t\t}\n\t}\n\treturn getLR(fa);\n}\ninline pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt;&gt; range(int p, int q){\n\tauto s = backLR(p, q);\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i].fi == 'L')\n\t\t\tm_ = s[i].se * m + m_, n_ = s[i].se * n + n_;\n\t\telse\n\t\t\tm = m + s[i].se * m_, n = n + s[i].se * n_;\n\t}\n\treturn mkp(mkp(m, n), mkp(m_, n_));\n}\ninline pair&lt;int, int&gt; getlca(int a, int b, int c, int d){\n\tauto A = backLR(a, b), B = backLR(c, d);\n\tint s1 = 0, s2 = 0;\n\tfor(auto v : A)\n\t  s1 += v.se;\n\tfor(auto v : B)\n\t  s2 += v.se;\n\tif(s1 &lt; s2){\n\t\tswap(a, c), swap(b, d);\n\t\tswap(A, B);\n\t}\n\tvector&lt;pair&lt;char, int&gt;&gt; lca;\n\tint j = 0;\n\tfor(int i = 0; i &lt; (int)A.size(); ++i){\n\t\tint s = A[i].se;\n\t\twhile(j &lt; (int)B.size() &amp;&amp; s){\n\t\t\tif(B[j].fi != A[i].fi)\n\t\t\t  break;\n\t\t\tif(B[j].se &lt;= s){\n\t\t\t\ts -= B[j].se;\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[j].se -= s;\n\t\t\t\ts = 0;\n\t\t\t}\n\t\t}\n\t\tif(j == (int)B.size() || s){\n\t\t\tlca.push_back(mkp(A[i].fi, A[i].se - s));\n\t\t\tbreak;\n\t\t}\n\t\tlca.push_back(A[i]);\n\t}\n\treturn getLR(lca);\n}\nint T, a, b, c, d, p, q, len, x, k;\nchar C;\nchar op[20];\nint main(){\n\tT = read();\n\twhile(T--){\n\t\tscanf(\"%s\", op);\n\t\tif(op[0] == 'E'){\n\t\t\tp = read(), q = read();\n\t\t\tauto V = backLR(p, q);\n\t\t\twrite(V.size());\n\t\t\tputchar(' ');\n\t\t\tfor(auto t : V){\n\t\t\t\tputchar(t.fi);\n\t\t\t\tputchar(' ');\n\t\t\t\twrite(t.se);\n\t\t\t\tputchar(' ');\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(op[0] == 'D'){\n\t\t\tvector&lt;pair&lt;char, int&gt;&gt; V;\n\t\t\tlen = read();\n\t\t\twhile(len--){\n\t\t\t\tC = getchar();\n\t\t\t\tx = read();\n\t\t\t\tV.push_back({C, x});\n\t\t\t}\n\t\t\tauto t = getLR(V);\n\t\t\twrite(t.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se);\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(op[0] == 'L'){\n\t\t\ta = read(), b = read(), c = read(), d = read();\n\t\t\tauto t = getlca(a, b, c, d);\n\t\t\twrite(t.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se);\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(op[0] == 'A'){\n\t\t\tk = read(), a = read(), b = read();\n\t\t\tauto t = getkfa(a, b, k);\n\t\t\tif(t.fi &lt; 0){\n\t\t\t\tputs(\"-1\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twrite(t.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se);\n\t\t\tputchar('\\n');\t\t\t\n\t\t}\n\t\telse{\n\t\t\ta = read(), b = read();\n\t\t\tauto t = range(a, b);\n\t\t\twrite(t.fi.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.fi.se);\n\t\t\tputchar(' ');\t\n\t\t\twrite(t.se.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se.se);\n\t\t\tputchar('\\n');\t\n\t\t}\n\t}\n\treturn 0;\n}\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 11:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rgw2010\">rgw2010</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "新书《鸿蒙HarmonyOS 6应用开发：从零基础到App上线》出版啦",
      "link": "https://www.cnblogs.com/aqi00/p/19504825",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19504825\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 11:23\">\n    <span>新书《鸿蒙HarmonyOS 6应用开发：从零基础到App上线》出版啦</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span><span>​</span></span><span id=\"cke_bm_160S\">基于最新鸿蒙系统的技术书籍《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》上市啦，要知道 HarmonyOS 6 在一个多月前的10月22日才正式发布，因此这本鸿蒙教程可谓贴近最新的 HarmonyOS 6 系统。</span>\n<p><span id=\"cke_bm_160S\"> 当前 HarmonyOS 6 的装机量迅猛增长，有望在春节前突破5000万台大关，可见鸿蒙系统的应用开发将越来越流行，甚至借助国产化的浪潮，未来在国内移动操作系统领域一举夺魁也不是不可能。<br />\n有鉴于此，博主精心编撰了 HarmonyOS 6 的应用开发教程《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》，从基础到高级，从理论到实战，从 UI 到 AI ，仅需一本书籍，即可让读者掌握鸿蒙应用的常见开发技能。</span></p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"鸿蒙应用开发\" class=\"lazyload\" height=\"436\" width=\"436\" /></span></span></span></span></p>\n<p>鸿蒙应用开发与安卓应用开发同为App开发，比如鸿蒙版微信和安卓版微信都是即时通信App，二者在实现技术上并无多少本质区别。所以《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》一书以《Android Studio开发实战：从零基础到App上线(第3版)》为蓝本，把安卓系统的App教程改造为鸿蒙系统的App教程，以便安卓开发者能够按图索骥迅速上手。欣喜的是，《Android Studio开发实战：从零基础到App上线(第3版)》提到的安卓开发技术，绝大部分都能在鸿蒙系统找到对应的平替技术，而且还是更简单的代码实现。<br />\n作为《Android Studio开发实战：从零基础到App上线(第3版)》一书的鸿蒙姊妹篇，《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》仍然采取了由浅入深、循序渐进的章节体例，其中前8章是基础部分，主要讲解 DevEco Studio 的环境搭建、ArkTS语言编程基础、鸿蒙App开发的各种常用组件、鸿蒙App开发的页面转场和消息交互、鸿蒙App的几种数据存储方式等；后8章是进阶部分，主要讲解鸿蒙App开发的后台任务、手势交互、动画特效、网络通信、多媒体、感知定位、人工智能、多端部署等。</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"android第三版\" class=\"lazyload\" height=\"439\" width=\"439\" /></span></span></span></span></p>\n<p>曾经有老读者咨询“从零基础到App上线”系列书籍的第4版何时面世，现在博主终于可以说，“从零基础到App上线”的第4版已经出版啦，而且第4版是鸿蒙版本的“从零基础到App上线”，它就叫做《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》，该书把安卓版教程平替为鸿蒙版教程，也是一个勇敢的尝试。<br />\n《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》在讲解知识点的同时给出了大量实战范例，方便读者迅速将所学的知识运用到实际开发中。通过本书的学习，读者能够掌握3类主流App的基本开发技术，包括购物App（电子商务）、聊天App（即时通信）、娱乐App（短视频分享）。另外，能够学会开发一些趣味应用，包括计算器、录音笔、电子相册、打牌游戏、指南针、水平仪、卫星浑天仪、登山助手、附近交友、速记助手、人脸识别等等。可见《Android Studio开发实战：从零基础到App上线(第3版)》一书提到的实战项目，本书基本提供了对应的鸿蒙版App。</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"鸿蒙系统\" class=\"lazyload\" height=\"237\" width=\"558\" /></span></span></span></span></p>\n<p>《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》的随书源码包括客户端部分和服务端部分，其中客户端的App代码基于 DevEco Studio 6.0.0 Release 开发，并使用 API 20 的 SDK （HarmonyOS 6.0.0）编译与调试通过，测试机型包括 Mate 60 Pro 和 nova 12 Pro 。配套的服务端源码采用 Java WEB 框架，结合 MySQL 数据库，并基于 IDEA 开发。<br />\n为了便于读者学习鸿蒙应用编程，《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》同时提供了随书源码和课件PPT，这些下载资源可以扫描该书前言末尾的二维码获得。最新的随书源码也可访问我的码云主页，下载页面是 https://gitee.com/aqi00/harmony 。</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 11:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "APEX实战第11篇：图形界面轻松解锁工作区账户",
      "link": "https://www.cnblogs.com/jyzhao/p/19524312/apex-shi-zhan-di11pian-tu-xing-jie-mian-qing-song",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jyzhao/p/19524312/apex-shi-zhan-di11pian-tu-xing-jie-mian-qing-song\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 00:21\">\n    <span>APEX实战第11篇：图形界面轻松解锁工作区账户</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2026-01-24 00:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jyzhao\">AlfredZhao</a>&nbsp;\n阅读(<span id=\"post_view_count\">29</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>APEX工作区的账户被锁定的原因基本都是因为该用户使用错误密码登录尝试的次数超过了安全限制。</p>\n<p>因为APEX为了账号的安全性考量，默认会有这样的安全策略设置：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202601/635610-20260124002157433-12653719.jpg\" /></p>\n<p>当然这个设置值是可以按需设置修改的，具体在这个地方：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202601/635610-20260124002157315-802019995.jpg\" /></p>\n<p>不过一般安全起见，也不建议去改太大，绝大多数场景还是默认就好。</p>\n<p>可如果因为哪位同事不小心尝试登录超出了安全限度，就会导致账号被锁定，此时也不必慌张，更不用去找具体命令，只要有权限登录 internal 的管理员在图形界面操作就可以顺利解锁账号，具体操作如下：</p>\n<p>首先需要管理员登录到 internal 的 Workspace，选择 <code>Manage Workspaces</code> -&gt; <code>Manage Developers and Users</code>，如下图所示：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202601/635610-20260124002157246-931642568.jpg\" /></p>\n<p>找到你被锁的具体 User，点击进去到下面这个界面，在 <code>Account Availability</code> 选择 <code>Unlocked</code> 解锁，<code>Apply Changes</code> 即可。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202601/635610-20260124002157361-181439318.jpg\" /></p>\n<p>操作完就可以退出 internal Workspace，登录自己的Workspace发现之前被锁定的账号已经可以正常登录了。</p>\n\n</div>\n<div id=\"MySignature\">\n    <a href=\"https://www.cnblogs.com/jyzhao/\" target=\"_blank\">AlfredZhao</a>©版权所有「从Oracle起航，领略精彩的IT技术。」<br />\n转载请注明原文链接：<a href=\"https://www.cnblogs.com/jyzhao/p/19524312/apex-shi-zhan-di11pian-tu-xing-jie-mian-qing-song\" target=\"_blank\">https://www.cnblogs.com/jyzhao/p/19524312/apex-shi-zhan-di11pian-tu-xing-jie-mian-qing-song</a>\n<hr />\n<div style=\"text-align: center; margin-top: 30px;\">\n  <p style=\"font-size: 14px; color: #555;\">\n    👋 感谢阅读，欢迎关注我的公众号 <b>「赵靖宇」</b>\n  </p>\n  <img src=\"https://images.cnblogs.com/cnblogs_com/jyzhao/824234/o_250208075013_qrcode-zjy.jpg\" style=\"border: 1px solid #ddd; border-radius: 8px;\" width=\"160\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第二周：词嵌入（五）GloVe 算法",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19524283",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19524283\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 23:59\">\n    <span>吴恩达深度学习课程五：自然语言处理  第二周：词嵌入（五）GloVe 算法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第二周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=170\" rel=\"noopener nofollow\" target=\"_blank\">2.8</a>的内容以及一些相关知识的补充。</p>\n<hr />\n<p>本周为第五课的第二周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本周的内容关于词嵌入，是一种<strong>相对于独热编码，更能保留语义信息的文本编码方式</strong>。通过词嵌入，模型不再只是“记住”词本身，而是能够<strong>基于语义关系进行泛化</strong>，在一定程度上实现类似“<strong>举一反三</strong>”的效果。词嵌入是 NLP 领域中最重要的基础技术之一。</p>\n<p>本篇的内容关于 <strong>GloVe 算法</strong>,是 Word2Vec 外，另一种以“全局”思想指导的词嵌入算法。</p>\n<h1 id=\"1-glove-算法思想\">1. GloVe 算法思想</h1>\n<p>在前面介绍 <a href=\"https://www.cnblogs.com/Goblinscholar/p/19504549\" target=\"_blank\">Word2Vec</a> 时，我们已经看到了一条非常清晰的学习路线：<strong>通过预测任务，让模型在训练中“顺便”学到词的向量表示</strong>。这种思路高效且直观，但也有一个绕不开的事实——它几乎完全依赖<strong>局部上下文</strong>。<br />\n这不难理解，在 Word2Vec 中，我们每次训练，都是使用<strong>窗口内的序列信息</strong>来学习相应的语义并更新词向量，每次更新只使用窗口内的词信息，词向量是在多次局部预测中逐步学习出来的。<br />\n由此，一个新的想法产生了：<strong>如果我们不只看窗口内的几步关系，而是把“整个语料里，词与词出现过多少次”都考虑进来，会发生什么？</strong></p>\n<p>GloVe 正是这一想法的产物。<br />\n在 2014 年，论文 <a href=\"https://aclanthology.org/D14-1162.pdf\" rel=\"noopener nofollow\" target=\"_blank\">GloVe: Global Vectors for Word Representation</a>被发表，论文认为<strong>词的语义信息，本质上蕴含在词与词的全局共现统计关系中，而词向量的任务，就是用一个低维连续空间去重现这种统计结构。</strong><br />\n最终，GloVe 将<strong>传统共现统计方法的全局视角</strong>，与<strong>分布式词向量的表达能力</strong>结合起来，形成了一种介于“计数方法”和“预测方法”之间的折中方案。<br />\n这里要专门说明的是，相比于传统神经网络，<strong>GloVe 没有隐藏层或激活函数</strong>，更像是一条通过词向量内积加偏置构成的<strong>线性计算流水线</strong>，但它仍然使用梯度下降来更新参数，实现对共现统计信息的拟合，我们很难用模型那一套来描述它，因此也相对较难理解。<br />\n下面就来分点展开 GloVe 算法的实现逻辑：</p>\n<h1 id=\"2-glove-算法的统计部分\">2. GloVe 算法的统计部分</h1>\n<p>GloVe 算法 的起手其实是传统的共现统计方法，<strong>这一部分并不涉及模型训练，而是对数据进行统计和处理，得到词汇间的全局关系。</strong><br />\n依旧分点来看这部分内容：</p>\n<h2 id=\"21-统计词共现矩阵\">2.1 统计词共现矩阵</h2>\n<p><strong>词共现矩阵</strong> 是传统统计方法里的基础概念，顾名思义，它是用来<strong>表示词与词之间共现关系的矩阵</strong>。</p>\n<p>规范一下，设词表大小为 <span class=\"math inline\">\\(V\\)</span>，定义一个矩阵 <span class=\"math inline\">\\(X \\in \\mathbb{R}^{V \\times V}\\)</span>，其中：</p>\n<p></p><div class=\"math display\">\\[X_{ij} = \\text{词 } j \\text{ 出现在词 } i \\text{ 上下文中的次数}  \n\\]</div><p></p><p>简单举个例子，假设语料只有一句话：</p>\n<blockquote>\n<p>I like deep learning</p>\n</blockquote>\n<p>显然，词表为：</p>\n<p></p><div class=\"math display\">\\[\\{\\text{I},\\ \\text{like},\\ \\text{deep},\\ \\text{learning}\\}  \n\\]</div><p></p><p>现在，设定<strong>上下文窗口大小为 1</strong>，即只考虑左右各一个词。<br />\n我们统计各词的共性关系如下：</p>\n<ol>\n<li>以 <strong>I</strong> 为中心：上下文只有 <em>like</em></li>\n<li>以 <strong>like</strong> 为中心：上下文是 <em>I</em> 和 <em>deep</em></li>\n<li>以 <strong>deep</strong> 为中心：上下文是 <em>like</em> 和 <em>learning</em></li>\n<li>以 <strong>learning</strong> 为中心：上下文只有 <em>deep</em></li>\n</ol>\n<p>由此，我们可以得到完整的词共现矩阵 <span class=\"math inline\">\\(X\\)</span>：</p>\n<p></p><div class=\"math display\">\\[X =\n\\begin{array}{c|cccc}\n &amp; \\text{I} &amp; \\text{like} &amp; \\text{deep} &amp; \\text{learning} \\\\\n\\hline\n\\text{I}        &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\\n\\text{like}     &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\\\\n\\text{deep}     &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\\\\n\\text{learning} &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\\n\\end{array}\n\\]</div><p></p><p>补充几点细节：</p>\n<ol>\n<li>在常见的统计设定中，通常<strong>手工设定</strong>不将词与自身计入共现关系，因此<strong>共现矩阵的对角线往往为 0</strong>，但在真实语料中，若相同词在窗口范围内连续出现，则对应的对角元素也可能为非零值。</li>\n<li>词共现矩阵往往是<strong>高度稀疏的</strong>，大多数词对在语料中根本不会共现。</li>\n<li><strong>词共现矩阵是否对称，取决于设计的统计方式</strong>，在对称窗口下，这里的 <span class=\"math inline\">\\(X\\)</span> 是对称的，若区分左右上下文，矩阵则不一定对称。</li>\n</ol>\n<p>由此，我们就完成了 GloVe 算法在统计部分的第一步。<br />\n下一步，我们会<strong>把共现次数 <span class=\"math inline\">\\(X_{ij}\\)</span> 转化为条件概率 <span class=\"math inline\">\\(P(j|i)\\)</span></strong>，进一步引入向量训练的目标。</p>\n<h2 id=\"22-统计条件概率-\">2.2 统计条件概率 <span class=\"math inline\">\\(P(j \\mid i)\\)</span></h2>\n<p>在完成共现矩阵统计后，GloVe 的下一步是把<strong>绝对共现次数</strong>转化为<strong>条件概率</strong>，从而刻画词与词之间更直观的关系。<br />\n我们定义条件概率为：</p>\n<p></p><div class=\"math display\">\\[P(j \\mid i) = \\frac{X_{ij}}{\\sum_k X_{ik}}  \n\\]</div><p></p><p>其中：</p>\n<ul>\n<li><span class=\"math inline\">\\(X_{ij}\\)</span> 是词 <span class=\"math inline\">\\(j\\)</span> 出现在词 <span class=\"math inline\">\\(i\\)</span> 上下文中的次数，来自词共现矩阵。</li>\n<li><span class=\"math inline\">\\(\\sum_k X_{ik}\\)</span> 是以词 <span class=\"math inline\">\\(i\\)</span> 为中心时，所有上下文词出现次数的总和</li>\n</ul>\n<p><strong>最终，<span class=\"math inline\">\\(P(j \\mid i)\\)</span> 表示在语料库中，已知中心词为 <span class=\"math inline\">\\(i\\)</span> 的前提下，上下文词为 <span class=\"math inline\">\\(j\\)</span> 的经验概率。</strong></p>\n<p>我们继续使用上一节中的例子，根据共现矩阵：</p>\n<p></p><div class=\"math display\">\\[X =\n\\begin{array}{c|cccc}\n &amp; \\text{I} &amp; \\text{like} &amp; \\text{deep} &amp; \\text{learning} \\\\\n\\hline\n\\text{I}        &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\\n\\text{like}     &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\\\\n\\text{deep}     &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\\\\n\\text{learning} &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\\n\\end{array}\n\\]</div><p></p><p>我们可以计算条件概率，例如：</p>\n<ol>\n<li>以 <strong>like</strong> 为中心：</li>\n</ol>\n<p></p><div class=\"math display\">\\[\\sum_k X_{\\text{like},k} = 1 + 0 + 1 + 0 = 2  \n\\]</div><p></p><p>于是：</p>\n<p></p><div class=\"math display\">\\[P(\\text{I} \\mid \\text{like}) = \\frac{1}{2} = 0.5, \\quad  \nP(\\text{deep} \\mid \\text{like}) = \\frac{1}{2} = 0.5  \n\\]</div><p></p><ol start=\"2\">\n<li>以 <strong>I</strong> 为中心：</li>\n</ol>\n<p></p><div class=\"math display\">\\[\\sum_k X_{\\text{I},k} = 0 + 1 + 0 + 0 = 1  \n\\]</div><p></p><p>所以：</p>\n<p></p><div class=\"math display\">\\[P(\\text{like} \\mid \\text{I}) = 1  \n\\]</div><p></p><p><strong>最终，通过这种方式，我们就得到了语料库中每个词的上下文概率分布。</strong><br />\n我们整理例子的概率分布矩阵如下：</p>\n<p></p><div class=\"math display\">\\[P =  \n\\begin{array}{c|cccc}  \n&amp; \\text{I} &amp; \\text{like} &amp; \\text{deep} &amp; \\text{learning} \\\\  \n\\hline  \n\\text{I} &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\\n\\text{like} &amp; 0.5 &amp; 0 &amp; 0.5 &amp; 0 \\\\  \n\\text{deep} &amp; 0 &amp; 0.5 &amp; 0 &amp; 0.5 \\\\  \n\\text{learning} &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\  \n\\end{array}  \n\\]</div><p></p><p>其中：</p>\n<ul>\n<li><strong>行表示中心词 <span class=\"math inline\">\\(i\\)</span></strong></li>\n<li><strong>列表示上下文词 <span class=\"math inline\">\\(j\\)</span></strong></li>\n<li><strong>每个元素 <span class=\"math inline\">\\(P_{ij}\\)</span></strong> 即为 <span class=\"math inline\">\\(P(j|i)\\)</span></li>\n</ul>\n<p>自此，我们就完成了GloVe 算法在统计部分的全部内容。<br />\n下面，就是它的建模部分。</p>\n<h1 id=\"3-glove-算法的模型部分\">3. GloVe 算法的模型部分</h1>\n<p>在完成统计阶段后，我们得到了全局的共现信息及概率分布。<strong>模型部分的核心任务</strong>就是：利用这些统计信息训练出词向量，使得词向量能够<strong>反映词与词之间的语义关系</strong>。</p>\n<p>GloVe 的核心思想可以概括为一句话：<strong>词向量的内积应该能够拟合词与词之间的共现概率</strong>。<br />\n我们依旧分点来进行这部分内容：</p>\n<h2 id=\"31-计算概率比例\">3.1 计算概率比例</h2>\n<p>首先，GloVe 并不直接去拟合条件概率 <span class=\"math inline\">\\(P(j|i)\\)</span>，而是利用<strong>概率比例</strong>刻画语义关系。<br />\n设有中心词 <span class=\"math inline\">\\(i\\)</span>，上下文词 <span class=\"math inline\">\\(j\\)</span> 和 <span class=\"math inline\">\\(k\\)</span>，则概率比例如下：</p>\n<p></p><div class=\"math display\">\\[\\frac{P(j \\mid i)}{P(k \\mid i)}  \n\\]</div><p></p><p>这并不难理解：</p>\n<ul>\n<li>如果比例大，说明 <span class=\"math inline\">\\(i\\)</span> 更倾向于与 <span class=\"math inline\">\\(j\\)</span> 一起出现。</li>\n<li>如果比例小，说明 <span class=\"math inline\">\\(i\\)</span> 更倾向于与 <span class=\"math inline\">\\(k\\)</span> 一起出现。</li>\n</ul>\n<p>继续使用同样的例子，我们刚刚得到条件概率矩阵如下：</p>\n<p></p><div class=\"math display\">\\[P =  \n\\begin{array}{c|cccc}  \n&amp; \\text{I} &amp; \\text{like} &amp; \\text{deep} &amp; \\text{learning} \\\\  \n\\hline  \n\\text{I} &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\  \n\\text{like} &amp; 0.5 &amp; 0 &amp; 0.5 &amp; 0 \\\\  \n\\text{deep} &amp; 0 &amp; 0.5 &amp; 0 &amp; 0.5 \\\\  \n\\text{learning} &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\  \n\\end{array}  \n\\]</div><p></p><p>对于中心词 <strong>like</strong>，其上下文词分别为 <strong>I</strong> 和 <strong>deep</strong>，则：</p>\n<p></p><div class=\"math display\">\\[\\frac{P(\\text{I} \\mid \\text{like})}{P(\\text{deep} \\mid \\text{like})} = \\frac{0.5}{0.5} = 1  \n\\]</div><p></p><p>这个比例表示，“like”与“I”和“deep”的关系<strong>同样强</strong>。<br />\n换句话说，如果模型想拟合这个关系，词向量在空间中的表现应该让 <strong>like-I</strong> 与 <strong>like-deep</strong> 的内积接近。</p>\n<p>而如果概率比例不是 1，例如假设在更大语料中统计到：</p>\n<p></p><div class=\"math display\">\\[P(\\text{I} \\mid \\text{like}) = 0.3, \\quad P(\\text{deep} \\mid \\text{like}) = 0.6  \n\\]</div><p></p><p>则比例为：</p>\n<p></p><div class=\"math display\">\\[\\frac{P(\\text{I} \\mid \\text{like})}{P(\\text{deep} \\mid \\text{like})} = \\frac{0.3}{0.6} = 0.5  \n\\]</div><p></p><p>这个比例小于 1，说明“like”<strong>更倾向于与 deep 一起出现</strong>，与 I 的关联较弱。模型训练时，GloVe 就会尝试让词向量 <strong>like-deep</strong> 的内积大于 <strong>like-I</strong> 的内积，以反映这种强弱关系。</p>\n<p>这一步，我们通过比例概率实现了对语义的量化，而下一步就是 GloVe 的核心内容：</p>\n<h2 id=\"32-构建向量关系\">3.2 构建向量关系</h2>\n<p>在这一步，GloVe 就可以将概率比例量化的<strong>语义偏好</strong>转化为<strong>向量空间中的相对位置</strong>，从而实现统计信息到词向量的映射。<br />\n换句话说，我们希望通过训练得到的词向量，使得在向量空间中，中心词与上下文词的相对位置<strong>能够反映它们在语料中的共现强弱</strong>。<br />\n来看看 GloVe 实现这一步的具体逻辑：</p>\n<p>首先，设定：</p>\n<ol>\n<li><strong>中心词</strong> <span class=\"math inline\">\\(i\\)</span> 的词向量为 <span class=\"math inline\">\\(w_i \\in \\mathbb{R}^d\\)</span></li>\n<li><strong>上下文词</strong> <span class=\"math inline\">\\(j,k\\)</span> 的词向量为 <span class=\"math inline\">\\(\\tilde w_j, \\tilde w_k \\in \\mathbb{R}^d\\)</span></li>\n</ol>\n<p>GloVe 通过以下假设将概率比例与向量联系起来：</p>\n<p></p><div class=\"math display\">\\[F(w_i, \\tilde w_j, \\tilde w_k) = \\frac{P(j \\mid i)}{P(k \\mid i)}  \n\\]</div><p></p><p>其中函数 <span class=\"math inline\">\\(F\\)</span> 的含义是：<strong>用向量操作去表示概率比例，模型的目标就是拟合这个函数 <span class=\"math inline\">\\(F\\)</span> 。</strong></p>\n<p>也就是说，我们的目标是：</p>\n<p></p><div class=\"math display\">\\[\\frac{P(j \\mid i)}{P(k \\mid i)} \\approx {\\text{模型预测的某个函数值}}{}  \n\\]</div><p></p><p><strong>但是，直接拟合比例本身有几个问题</strong>：</p>\n<ol>\n<li><strong>比例范围广</strong>：条件概率 <span class=\"math inline\">\\(P(j|i)\\)</span> 属于 <span class=\"math inline\">\\([0,1]\\)</span>，两个概率比值可能非常大或非常小（比如 <span class=\"math inline\">\\(0.001/0.5 = 0.002\\)</span>），直接拟合容易数值不稳定。</li>\n<li><strong>向量空间线性映射困难</strong>：我们希望用向量内积（<span class=\"math inline\">\\(w_i^\\top \\tilde w_j\\)</span>）表示关系，但向量内积是线性且可正可负，而概率比总是正且变化范围大，直接用内积去拟合会很不直观，也容易数值不稳定。</li>\n</ol>\n<p>所以我们需要一个<strong>桥梁函数</strong>，把比例转换成更适合线性建模的形式。</p>\n<h2 id=\"33-转换概率比例\">3.3 转换概率比例</h2>\n<p>在这里，GloVe 选择了 <strong>对数函数</strong>，把比例变成 <strong>内积差</strong>：</p>\n<p></p><div class=\"math display\">\\[\\log \\frac{P(j \\mid i)}{P(k \\mid i)} =\\log P(j|i) - \\log P(k|i) \\approx (w_i^\\top \\tilde w_j + b_i + \\tilde b_j) - (w_i^\\top \\tilde w_k + b_i + \\tilde b_k)\n\\]</div><p></p><p>我们来详细解释一下这步推导的逻辑：</p>\n<ol>\n<li><strong>对数的作用</strong>:<br />\n对数函数可以把原本范围很广的正数概率比压缩到数值更稳定的区间，并且把<strong>乘法关系转化为加法关系</strong>。数值范围收敛，更利于模型学习，同时便于线性处理。</li>\n<li><strong>对映射的影响</strong>：<br />\n取了对数之后，原本的比例关系就转化为“加减法”的形式，而向量内积本身就是线性可加的操作（<span class=\"math inline\">\\(w_i^\\top \\tilde w_j\\)</span> 是实数线性组合）。对数后的比例差可以直接用 <strong>线性模型</strong>（内积加偏置）来拟合，保证概率比越大，内积差越大；概率比越小，内积差越小。</li>\n<li><strong>偏置项的作用</strong> ：<br />\n偏置项 <span class=\"math inline\">\\(b_i, \\tilde b_j\\)</span> 用于<strong>捕捉词自身的出现频率差异</strong>。<br />\n高频词往往在语料中出现次数多，直接用向量内积可能被整体频率影响而偏离比例。<br />\n偏置项可以单独调整每个词的基准水平，让向量内积专注于<strong>词与词之间的相对关系</strong>，而不受词频本身干扰。</li>\n</ol>\n<p>最终，我们通过公式实现了这样的作用：</p>\n<p></p><div class=\"math display\">\\[\\text{概率比例（统计信息）} \\xrightarrow{\\log} \\text{线性可加的形式} \\xrightarrow{\\text{内积+偏置}} \\text{向量表示拟合目标}  \n\\]</div><p></p><p>回到例子，假设在某大语料中统计到：</p>\n<p></p><div class=\"math display\">\\[P(\\text{I} \\mid \\text{like}) = 0.3, \\quad P(\\text{deep} \\mid \\text{like}) = 0.6  \n\\]</div><p></p><p>则：</p>\n<p></p><div class=\"math display\">\\[\\log \\frac{P(\\text{I} \\mid \\text{like})}{P(\\text{deep} \\mid \\text{like})} = \\log 0.5 \\approx -0.693  \n\\]</div><p></p><p>因此，模型希望通过训练得到的向量，使得：</p>\n<p></p><div class=\"math display\">\\[(w_\\text{like}^\\top \\tilde w_\\text{I} + b_\\text{like} + \\tilde b_\\text{I}) - (w_\\text{like}^\\top \\tilde w_\\text{deep} + b_\\text{like} + \\tilde b_\\text{deep}) \\approx -0.693  \n\\]</div><p></p><p>这样，训练后，词向量在空间中，“like” 会更靠近 “deep”，远离 “I”，以反映概率比例。</p>\n<p>下面就是最后一步了：</p>\n<h2 id=\"34-构建损失函数并训练\">3.4 构建损失函数并训练</h2>\n<p>在完成概率比例到向量内积映射后，GloVe 还需要一个<strong>可优化的损失函数</strong>来让训练可执行。<br />\n这一步的思想是：<strong>让向量内积（加偏置）尽量逼近对数共现概率</strong>，同时对高频和低频词对做合理的权衡。</p>\n<p>GloVe 的损失函数定义为：</p>\n<p></p><div class=\"math display\">\\[J = \\sum_{i,j=1}^{V} f(X_{ij}) \\left( w_i^\\top \\tilde w_j + b_i + \\tilde b_j - \\log X_{ij} \\right)^2  \n\\]</div><p></p><p>看起来很复杂，实际上也不简单，我们详细解释一下各部分含义：</p>\n<ol>\n<li>\n<p><strong>权重函数 <span class=\"math inline\">\\(f(X_{ij})\\)</span></strong>：<br />\n为了平衡高频和低频词对的影响，GloVe 引入了一个加权函数：</p>\n<p></p><div class=\"math display\">\\[   f(x) =\n   \\begin{cases} \n   \\left(\\dfrac{x}{x_\\text{max}}\\right)^\\alpha, &amp; x &lt; x_\\text{max} \\\\\n   1, &amp; x \\ge x_\\text{max}\n   \\end{cases}\n\\]</div><p></p><p>这里 <span class=\"math inline\">\\(x_\\text{max}\\)</span> 是阈值，<span class=\"math inline\">\\(\\alpha\\)</span> 通常取 <span class=\"math inline\">\\(0.75\\)</span>。<br />\n这是为了让高频词对不会主导训练，低频词对仍有一定权重。</p>\n</li>\n<li>\n<p><strong><span class=\"math inline\">\\(w_i^\\top \\tilde w_j + b_i + \\tilde b_j\\)</span></strong>  ：模型预测的对数共现次数，即词向量加偏置的线性组合。</p>\n</li>\n<li>\n<p><strong><span class=\"math inline\">\\(\\log X_{ij}\\)</span></strong>  ：对应统计信息的对数共现次数，是我们希望模型逼近的目标。</p>\n</li>\n<li>\n<p><strong>平方误差 <span class=\"math inline\">\\((\\cdot)^2\\)</span></strong>  ：衡量预测值与目标值之间的差距，使模型通过梯度下降最小化误差。</p>\n</li>\n</ol>\n<p>这里就可以解释我们<a href=\"https://www.cnblogs.com/Goblinscholar/p/19494158\" target=\"_blank\">在本周第一篇</a>中留下的问题：<strong>词向量的长度受什么影响？</strong><br />\n因为高频词在语料中出现次数多，因此它的共现矩阵行/列上的元素整体偏大，经过训练后，模型为了尽量逼近 <span class=\"math inline\">\\(\\log X_{ij}\\)</span>，会使得这些高频词的向量内积整体偏大，从而对应的向量长度也相对较长。<br />\n<strong>也就是说，词向量的长度与词频正相关，但本身没有其他明确的语义解释，只是统计特性导致的结果。</strong></p>\n<p>同时，在这里你可能会有一个问题：<strong>我们刚刚引入了概率比例和内积差的关系，为什么损失函数里都没有用到？</strong><br />\n实际上，对某个中心词 <span class=\"math inline\">\\(i\\)</span>，任意两个上下文词 <span class=\"math inline\">\\(j,k\\)</span>，若你看损失梯度，会发现：<br />\n在优化过程中，梯度会自然调整 <span class=\"math inline\">\\(w_i\\)</span>，让 <strong>共现次数更多、概率大的词对应内积更大，共现次数更少、概率小的词对应内积更小</strong>。<br />\n换句话说，<strong>比例关系会通过梯度自动体现出来</strong>，不需要显式算比值，并且这样还避免了显式计算所有词对之间的概率比造成的计算开销。</p>\n<p>还是用我们的例子，假设在大语料中：</p>\n<table>\n<thead>\n<tr>\n<th>中心词</th>\n<th>上下文词</th>\n<th>共现次数 <span class=\"math inline\">\\(X_{ij}\\)</span></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>like</td>\n<td>I</td>\n<td>3</td>\n</tr>\n<tr>\n<td>like</td>\n<td>deep</td>\n<td>6</td>\n</tr>\n</tbody>\n</table>\n<p>则训练目标：</p>\n<ol>\n<li>对 <strong>like-I</strong>：\n<ul>\n<li>目标 <span class=\"math inline\">\\(\\log X_{\\text{like,I}} = \\log 3 \\approx 1.099\\)</span></li>\n<li>模型希望 <span class=\"math inline\">\\(w_\\text{like}^\\top \\tilde w_\\text{I} + b_\\text{like} + \\tilde b_\\text{I} \\approx 1.099\\)</span></li>\n</ul>\n</li>\n<li>对 <strong>like-deep</strong>：\n<ul>\n<li>目标 <span class=\"math inline\">\\(\\log X_{\\text{like,deep}} = \\log 6 \\approx 1.792\\)</span></li>\n<li>模型希望 <span class=\"math inline\">\\(w_\\text{like}^\\top \\tilde w_\\text{deep} + b_\\text{like} + \\tilde b_\\text{deep} \\approx 1.792\\)</span></li>\n</ul>\n</li>\n<li>权重函数 <span class=\"math inline\">\\(f(X_{ij})\\)</span> 可以调节两者在训练中的影响，使模型更稳健。</li>\n</ol>\n<p>训练时，GloVe <strong>会遍历所有有共现的词对</strong>，计算加权平方误差，利用梯度下降优化 <span class=\"math inline\">\\(w_i, \\tilde w_j, b_i, \\tilde b_j\\)</span>，直到误差收敛。<br />\n最后，你会发现，GloVe 的整个传播过程同时在维护两个词向量矩阵：</p>\n<ol>\n<li><strong>中心词向量 <span class=\"math inline\">\\(w_i\\)</span></strong></li>\n<li><strong>上下文词向量 <span class=\"math inline\">\\(\\tilde w_j\\)</span></strong><br />\n而通常，我们将两者相加或平均作为最终词向量：</li>\n</ol>\n<p></p><div class=\"math display\">\\[v_i = w_i + \\tilde w_i  \n\\]</div><p></p><p>这样得到的 <span class=\"math inline\">\\(v_i\\)</span> 便同时存在作为中心词和上下文词的语义距离，刻画了词与词之间的全局共现关系。</p>\n<h1 id=\"4-总结\">4. 总结</h1>\n<p>因为 GloVe 相比起来较为复杂，这里我们不再表格整理概念了，而是<strong>整体梳理一遍其传播过程</strong>。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260123235856508-1491140111.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-23 23:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">25</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ARM Q 饱和运算快速入门指南",
      "link": "https://www.cnblogs.com/lsksp/p/19524284",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lsksp/p/19524284\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 23:56\">\n    <span>ARM Q 饱和运算快速入门指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在 ARM 嵌入式开发（尤其是信号处理、音视频编解码、传感器数据处理）中，普通算术运算的 “数值回绕” 问题极易导致数据错误，而**Q 饱和运算**是解决该问题的核心方案。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在 ARM 嵌入式开发（尤其是信号处理、音视频编解码、传感器数据处理）中，普通算术运算的 “数值回绕” 问题极易导致数据错误，而<strong>Q 饱和运算</strong>是解决该问题的核心方案。</p>\n<h2 id=\"一什么是-q-饱和运算\">一、什么是 Q 饱和运算？</h2>\n<h3 id=\"1-核心痛点普通运算的-数值回绕\">1. 核心痛点：普通运算的 “数值回绕”</h3>\n<p>普通算术运算（如 ADD/SUB）溢出时，数值会按补码规则 “回绕”，导致结果完全错误：</p>\n<ul>\n<li>示例：<code>int8_t</code> 类型最大值 <code>127 + 1</code> → 结果变成 <code>-128</code>（而非预期的 127）；</li>\n<li>示例：<code>int8_t</code> 类型最小值 <code>-128 - 1</code> → 结果变成 <code>127</code>。</li>\n</ul>\n<h3 id=\"2-q-饱和运算的本质\">2. Q 饱和运算的本质</h3>\n<p>Q 饱和运算（Saturating Arithmetic）是 ARM 指令集中带 <code>Q</code> 前缀的特殊运算，核心逻辑：</p>\n<ul>\n<li>运算结果超出目标数据类型的<strong>数值范围（上限 / 下限）</strong> 时，结果被 “钳位” 到该类型的极值；</li>\n<li>同时置位 APSR 寄存器的 Q 标志位（溢出标记）。</li>\n</ul>\n<h2 id=\"二核心基础apsr-的-q-标志位\">二、核心基础：APSR 的 Q 标志位</h2>\n<p>Q 饱和运算的 “溢出标记” 依赖 APSR（应用程序状态寄存器）的 Q 位，这是使用饱和运算的核心要点：</p>\n<h3 id=\"1-q-标志位关键属性\">1. Q 标志位关键属性</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">特性</th>\n<th style=\"text-align: center;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">位位置</td>\n<td style=\"text-align: center;\">APSR 的 Bit 27（唯一标识位）</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">触发条件</td>\n<td style=\"text-align: center;\">仅当 <code>Q</code> 前缀的饱和运算指令溢出时置 1，普通运算溢出不触发</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">粘性位特性</td>\n<td style=\"text-align: center;\">一旦置 1，不会自动清零，必须通过显式指令 / 代码清除，否则会持续标记溢出</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-饱和运算的-上下限触发阈值\">2. 饱和运算的 “上下限”（触发阈值）</h3>\n<p>Q 位触发的本质是运算结果超出目标数据类型的数值范围：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">数据类型</th>\n<th style=\"text-align: center;\">符号性</th>\n<th style=\"text-align: center;\">下限</th>\n<th style=\"text-align: center;\">上限</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">8 位整数</td>\n<td style=\"text-align: center;\">有符号</td>\n<td style=\"text-align: center;\">-128</td>\n<td style=\"text-align: center;\">127</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">8 位整数</td>\n<td style=\"text-align: center;\">无符号</td>\n<td style=\"text-align: center;\">0</td>\n<td style=\"text-align: center;\">255</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">16 位整数</td>\n<td style=\"text-align: center;\">有符号</td>\n<td style=\"text-align: center;\">-32768</td>\n<td style=\"text-align: center;\">32767</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">32 位整数</td>\n<td style=\"text-align: center;\">有符号</td>\n<td style=\"text-align: center;\">-2147483648</td>\n<td style=\"text-align: center;\">2147483647</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三核心用法饱和运算指令--函数\">三、核心用法：饱和运算指令 / 函数</h2>\n<h3 id=\"1-汇编层面直接操作深入底层\">1. 汇编层面（直接操作，深入底层）</h3>\n<p>ARM 提供了一系列带 <code>Q</code> 前缀的饱和运算指令，入门常用指令如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">指令</th>\n<th style=\"text-align: center;\">功能</th>\n<th style=\"text-align: center;\">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">QADD/QSUB</td>\n<td style=\"text-align: center;\">32 位有符号数饱和加 / 减</td>\n<td style=\"text-align: center;\">32 位整型数据运算</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">UQADD8</td>\n<td style=\"text-align: center;\">无符号 8 位按字节饱和加法</td>\n<td style=\"text-align: center;\">多字节无符号数据（如 RGB）</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">SQXTB</td>\n<td style=\"text-align: center;\">32 位→8 位有符号饱和转换</td>\n<td style=\"text-align: center;\">数据类型降位（如 32→8 位）</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">UQXTB</td>\n<td style=\"text-align: center;\">32 位→8 位无符号饱和转换</td>\n<td style=\"text-align: center;\">无符号数据降位</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"汇编示例32-位有符号饱和加法溢出场景\">汇编示例：32 位有符号饱和加法（溢出场景）</h4>\n<pre><code class=\"language-assembly\">; 目标：计算int32_t上限值+1，验证饱和效果\nMOV R0, #2147483647   ; R0 = int32_t上限值\nMOV R1, #1            ; 加1，超出上限\nQADD R2, R0, R1       ; 饱和加法：R2被钳位到2147483647，Q位置1\n\n; 检测Q标志位\nMRS R3, APSR          ; 读取APSR到R3\nTST R3, #(1&lt;&lt;27)      ; 检测Bit27（Q位）\nBNE overflow_handle   ; Q=1则跳转到溢出处理\n\noverflow_handle:\nMSR APSR_nzcvq, #0    ; 显式清除Q位（关键：避免后续误判）\n</code></pre>\n<h3 id=\"2-c-语言层面快速入门推荐\">2. C 语言层面（快速入门，推荐）</h3>\n<p>ARM GCC 编译器提供内置函数，无需手写汇编，底层自动生成 Q 前缀指令，入门必用函数如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">函数名</th>\n<th style=\"text-align: center;\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\"><code>__qadd(a, b)</code></td>\n<td style=\"text-align: center;\">32 位有符号饱和加法</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><code>__qsub(a, b)</code></td>\n<td style=\"text-align: center;\">32 位有符号饱和减法</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><code>__sqxtb(a)</code></td>\n<td style=\"text-align: center;\">32 位→8 位有符号饱和转换</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><code>__uqxtb(a)</code></td>\n<td style=\"text-align: center;\">32 位→8 位无符号饱和转换</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">__SSAT(x, sat)</td>\n<td style=\"text-align: center;\">有符号数饱和至 <code>sat</code> 位</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">__USAT(x, sat)</td>\n<td style=\"text-align: center;\">无符号数饱和至 <code>sat</code> 位</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"c-语言完整示例含-q-位检测--清除\">C 语言完整示例（含 Q 位检测 / 清除）</h4>\n<pre><code class=\"language-C\">#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n\n// 读取APSR寄存器，检测Q标志位\nstatic inline uint32_t get_apsr(void) {\n    uint32_t apsr;\n    __asm__ volatile (\"mrs %0, apsr\" : \"=r\" (apsr));\n    return apsr;\n}\n\n// 判断Q位是否置1（溢出）\nstatic inline int is_q_flag_set(void) {\n    return (get_apsr() &amp; (1U &lt;&lt; 27)) != 0;\n}\n\n// 清除Q标志位\nstatic inline void clear_q_flag(void) {\n    __asm__ volatile (\"msr apsr_nzcvq, #0\");\n}\n\nint main(void) {\n    // 示例：限幅\n  \tint32_t pid_output = 50000; // 计算结果超出了16位变量范围\n    // 将结果饱和限制在 16 位有符号数范围内 (-32768 ~ 32767)\n\tint16_t motor_output = (int16_t)__SSAT(pid_output, 16);  \n    \n    // 示例：32位有符号饱和加法（超出上限）\n    int32_t a = 2147483647; // int32_t上限\n    int32_t b = 1;\n    int32_t res1 = __qadd(a, b); // 饱和加法：结果钳位到2147483647\n    printf(\"32位饱和加法结果：%d（预期：2147483647）\\n\", res1);\n    printf(\"Q位状态：%s\\n\", is_q_flag_set() ? \"溢出（置1）\" : \"未溢出（置0）\");\n    clear_q_flag(); // 清除Q位\n    \n    return 0;\n}\n</code></pre>\n<h4 id=\"手动实现饱和运算兼容非-arm-gcc-场景\">手动实现饱和运算（兼容非 ARM GCC 场景）</h4>\n<p>若编译器不支持内置函数，可手动判断范围实现简易饱和逻辑：</p>\n<pre><code class=\"language-c\">// 8位有符号数饱和加法\nint8_t sat_add_int8(int8_t a, int8_t b) {\n    int16_t temp = (int16_t)a + (int16_t)b; // 用16位避免中间溢出\n    if (temp &gt; 127) return 127;   // 上限钳位\n    if (temp &lt; -128) return -128; // 下限钳位\n    return (int8_t)temp;\n}\n</code></pre>\n<h2 id=\"四总结\">四、总结</h2>\n<ol>\n<li>Q 饱和运算的核心是<strong>溢出时钳位到数据类型极值 + 置位 Q 标志位</strong>，解决普通运算的 “数值回绕” 问题；</li>\n<li>优先使用 ARM GCC 内置函数（如<code>__qadd</code>），深入调试可通过汇编操作 Q 位，检测溢出需读取 APSR 的 Bit27；</li>\n<li>关键注意点：Q 位需手动清除、指令 / 函数匹配数据类型，避免误判和结果错误。</li>\n</ol>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-23 23:56</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lsksp\">比特向阳</a>&nbsp;\n阅读(<span id=\"post_view_count\">18</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案三)",
      "link": "https://www.cnblogs.com/lulight/p/19523829",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19523829\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 19:12\">\n    <span>【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案三)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>问题描述</h1>\n<p>在先前的四篇博文</p>\n<p>1：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19514101\" id=\"cb_post_title_url\" title=\"发布于 2026-01-21 21:19\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案二)</a>&nbsp;</p>\n<p>2：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19503730\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-19 21:09\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案一)&nbsp;</a>&nbsp;</p>\n<p>3：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19495544\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-17 11:54\">【Azure APIM】如何解决后端API服务配置自签名证书时APIM请求报错500：Error occured while calling backend service</a>&nbsp;</p>\n<p>4：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19479238\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-13 21:08\">【Azure 环境】在Windows环境中使用OpenSSL生成自签名证书链步骤分享</a></p>\n<p>我们分别介绍了使用OpenSSL生成自签名证书，然后解决APIM服务对自签名证书的信任问题。不论是APIM托管的网关，还是自建的网关都可以通过安装证书后使得请求受信任，通过配置API跳过证书验证环节。</p>\n<p>本文这从“自建网关本身AKS POD” 方面入手，通过配置 SSL_CERT_FILE 环境变量，来安装自签名证书 （根证书和中间证书）到POD中。</p>\n<p>经过AI大模型解答，在&nbsp;AKS (Azure Kubernetes Service) 中访问使用自签名证书的 API，关键在于让客户端信任该证书，主要的思路是：</p>\n<ol>\n<li>创建包含 CA 证书的 Secret</li>\n<li>将自签名的 CA 证书文件 (例如 ca.crt) 导入到 AKS 集群</li>\n<li>在应用部署的 YAML 文件中，将该 Secret 挂载到容器内，并设置 SSL_CERT_FILE 环境变量指向该证书</li>\n</ol>\n<p><img alt=\"image\" class=\"lazyload\" height=\"703\" width=\"999\" /></p>\n<h1>操作步骤</h1>\n<h2>第一步：准备好中间证书和根证书合并一起的 .crt 内容</h2>\n<div>导出方法：通过浏览器导出中间证书+根证书的 crt 文件，其内容是 Base64 编码</div>\n<p><img alt=\"image\" class=\"lazyload\" height=\"433\" width=\"999\" /></p>\n<p>&nbsp;</p>\n<h2>第二步：创建Kubernetes Secret</h2>\n<p>将自签名的 CA 证书文件 (例如 my-inetr-ca.crt) 导入到 AKS 集群中：</p>\n<p>命令：</p>\n<blockquote>kubectl create secret generic self-signed-ca --from-file=\"&lt;the full path of my-inetr-ca.crt&gt;\"</blockquote>\n<p>结果：</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"129\" width=\"999\" /></p>\n<p>&nbsp;</p>\n<h2>第三步：在APIM的自建网关Pod中挂载证书</h2>\n<p>在应用部署的 YAML 文件中，将该 Secret 挂载到容器内，并设置 SSL_CERT_FILE 环境变量指向该证书</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">...\n\n        volumeMounts:\n        - name: ca-volume\n          mountPath: /etc/ssl/certs/my-ca.crt\n          subPath: my-inetr-ca.crt\n        env:\n        - name: SSL_CERT_FILE\n          value: /etc/ssl/certs/my-ca.crt\n  ... \n      volumes:\n      - name: ca-volume\n        secret:\n          secretName: self-signed-ca\n\n...</span></pre>\n</div>\n<p>把从APIM获取的部署yaml内容，只修改如图中的三个位置，即可。</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"1516\" width=\"999\" /></p>\n<h2>第四步：部署以上配置，后访问AKS Service External URL进行测试验证</h2>\n<div>\n<blockquote>\n<div># 部署</div>\n<div>kubectl apply -f \"&lt;apim self-hosted gateway yaml file&gt;\"</div>\n<div>#获取对外暴露的IP地址</div>\n<div>kubectl get services</div>\n<div>&nbsp;</div>\n<div>##测试访问自建网关中的API</div>\n<div>curl https://&lt;external ip&gt;/api -k&nbsp;</div>\n</blockquote>\n<div>测试结果，成功通过证书验证及获取正确的结果：</div>\n</div>\n<p><img alt=\"image\" class=\"lazyload\" height=\"426\" width=\"666\" /></p>\n<p>&nbsp;</p>\n<p>如果没有配置SSL_CERT_FILE 及挂载证书，就会遇见500&nbsp;Internal server error。如果进一步通过 kubectl logs &lt;pod name&gt; 查看GatewayLogs日志，就会发现详细错误：The remote certificate was rejected by the provided RemoteCertificateValidationCallback.</p>\n<h2>详细错误</h2>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;collapse:true;;gutter:true;\">[Info] 2026-01-23T07:26:27.251 [DnsResolutionScheduled], message: xselfca02.myxxxxx.com, source: RoundRobinNameResolver\n[Info] 2026-01-23T07:26:27.252 [OutgoingTlsProtocolsSet], message: Tls, Tls11, Tls12, source: TcpChannelFactory\n[Info] 2026-01-23T07:26:27.598 [CertificateInfoVerificationScheduled], message: thumbprint: 62BF1CFA2116828E3F0B3C7D8FB4C380CD2CE358, subjectName: CN=*.myxxxxx.com, O=My Self Server Org, S=Chongqing, C=CN (CRL URLs: ; AIA URLs: )\n[Warn] 2026-01-23T07:26:27.601 [FailedToProcessRequest], ActivityId: d5d383dc-c395-4111-8558-2193f9bbb8ff, correlationId: d5d383dc-c395-4111-8558-2193f9bbb8ff, apiId: 69303f7730caebcf2a534309, operationId: get-home-page, tags: 20, httpMethod: GET, source: request-forwarder, serviceName: apim-gateway, exception: System.Security.Authentication.AuthenticationException: The remote certificate was rejected by the provided RemoteCertificateValidationCallback.\nat System.Net.Security.SslStream.SendAuthResetSignal(ReadOnlySpan`1 alert, ExceptionDispatchInfo exception)\nat System.Net.Security.SslStream.CompleteHandshake(SslAuthenticationOptions sslAuthenticationOptions)\nat System.Net.Security.SslStream.ForceAuthenticationAsync[TIOAdapter](Boolean receiveFirst, Byte[] reAuthenticationData, CancellationToken cancellationToken)\nat Gateway.Http.Client.DotNetty.TcpChannelFactory.CreateChannelAsync(IPEndPoint endpoint, RequestedApplicationProtocol requestedApplicationProtocol, TlsInfo tlsMetadata, HttpProxy httpProxyMetadata, Int32 destinationPort, CancellationToken cancellationToken) in C:\\__w\\1\\s\\Proxy\\Gateway.Http.Client.DotNetty\\TcpChannelFactory.cs:line 116\nat Gateway.Http.Client.DotNetty.EndpointPool.CreateAsyncInternal(IPipelineContext pipelineContext, ChannelPoolKey channelPoolKey, RequestedApplicationProtocol requestedApplicationProtocol, CancellationToken cancellationToken, GateInfo gateInfo) in C:\\__w\\1\\s\\Proxy\\Gateway.Http.Client.DotNetty\\EndpointPool.cs:line 307\nat Gateway.Http.Client.DotNetty.EndpointPool.CreateAsync(IPipelineContext pipelineContext, ChannelPoolKey channelPoolKey, RequestedApplicationProtocol requestedApplicationProtocol, CancellationToken cancellationToken) in C:\\__w\\1\\s\\Proxy\\Gateway.Http.Client.DotNetty\\EndpointPool.cs:line 128\nat Gateway.Http.Client.DotNetty.SingleThreadedBackendChannelPool.AcquireAsync(IPipelineContext context, CancellationToken cancellationToken) in C:\\__w\\1\\s\\Proxy\\Gateway.Http.Client.DotNetty\\SingleThreadedBackendChannelPool.cs:line 189\nat Gateway.Http.Client.DotNetty.RoundRobinBackendChannelPool.Acquire0(Object state) in C:\\__w\\1\\s\\Proxy\\Gateway.Http.Client.DotNetty\\RoundRobinBackendChannelPool.cs:line 73\nat Gateway.Http.Client.DotNetty.DotNettyHttpBackend.AcquireChannelAsync(IPipelineContext ctx, CancellationToken cancellationToken) in C:\\__w\\1\\s\\Proxy\\Gateway.Http.Client.DotNetty\\DotNettyHttpBackend.cs:line 791\nat Gateway.Http.Client.DotNetty.DotNettyHttpBackend.ProcessAsync(IPipelineContext context, CancellationToken cancellation) in C:\\__w\\1\\s\\Proxy\\Gateway.Http.Client.DotNetty\\DotNettyHttpBackend.cs:line 172\nat Microsoft.WindowsAzure.ApiManagement.Proxy.Gateway.Policies.PipelineWalker.ExecuteAsync(IPipelineContext context, IEnumerable`1 steps, CancellationToken cancellation) in C:\\__w\\1\\s\\Proxy\\Gateway.Pipeline\\PipelineWalker.cs:line 66\nat Microsoft.WindowsAzure.ApiManagement.Proxy.Gateway.ChildPipeline.ExecuteAsync(IPipelineContext context, CancellationToken cancellationToken) in C:\\__w\\1\\s\\Proxy\\Gateway.Pipeline\\ChildPipeline.cs:line 35\nat Gateway.Pipeline.Extensions.ValueTaskExtensions.Await[T](ValueTask`1 input) in C:\\__w\\1\\s\\Proxy\\Gateway.Pipeline\\Extensions\\ValueTaskExtensions.cs:line 28\nat Microsoft.WindowsAzure.ApiManagement.Proxy.Gateway.Policies.IO.CallServiceHandler.ProcessAsync(IPipelineContext context, CancellationToken cancellation) in C:\\__w\\1\\s\\Proxy\\Gateway.Policies.General\\IO\\CallServiceHandler.cs:line 94\nat Gateway.Http.Client.DotNetty.SingleThreadedBackendChannelPool.AcquireAsync(IPipelineContext context, CancellationToken cancellationToken) in C:\\__w\\1\\s\\Proxy\\Gateway.Http.Client.DotNetty\\SingleThreadedBackendChannelPool.cs:line 189\nat Gateway.Http.Client.DotNetty.RoundRobinBackendChannelPool.Acquire0(Object state) in C:\\__w\\1\\s\\Proxy\\Gateway.Http.Client.DotNetty\\RoundRobinBackendChannelPool.cs:line 73\nat Gateway.Http.Client.DotNetty.DotNettyHttpBackend.AcquireChannelAsync(IPipelineContext ctx, CancellationToken cancellationToken) in C:\\__w\\1\\s\\Proxy\\Gateway.Http.Client.DotNetty\\DotNettyHttpBackend.cs:line 791\nat Gateway.Http.Client.DotNetty.DotNettyHttpBackend.ProcessAsync(IPipelineContext context, CancellationToken cancellation) in C:\\__w\\1\\s\\Proxy\\Gateway.Http.Client.DotNetty\\DotNettyHttpBackend.cs:line 172\nat Microsoft.WindowsAzure.ApiManagement.Proxy.Gateway.Policies.PipelineWalker.ExecuteAsync(IPipelineContext context, IEnumerable`1 steps, CancellationToken cancellation) in C:\\__w\\1\\s\\Proxy\\Gateway.Pipeline\\PipelineWalker.cs:line 66\nat Microsoft.WindowsAzure.ApiManagement.Proxy.Gateway.ChildPipeline.ExecuteAsync(IPipelineContext context, CancellationToken cancellationToken) in C:\\__w\\1\\s\\Proxy\\Gateway.Pipeline\\ChildPipeline.cs:line 35\nat Gateway.Pipeline.Extensions.ValueTaskExtensions.Await[T](ValueTask`1 input) in C:\\__w\\1\\s\\Proxy\\Gateway.Pipeline\\Extensions\\ValueTaskExtensions.cs:line 28\nat Microsoft.WindowsAzure.ApiManagement.Proxy.Gateway.Policies.IO.CallServiceHandler.ProcessAsync(IPipelineContext context, CancellationToken cancellation) in C:\\__w\\1\\s\\Proxy\\Gateway.Policies.General\\IO\\CallServiceHandler.cs:line 94\nat Microsoft.WindowsAzure.ApiManagement.Proxy.Gateway.Policies.PipelineWalker.ExecuteAsync(IPipelineContext context, IEnumerable`1 steps, CancellationToken cancellation) in C:\\__w\\1\\s\\Proxy\\Gateway.Pipeline\\PipelineWalker.cs:line 66\nat Microsoft.WindowsAzure.ApiManagement.Proxy.Gateway.ChildPipeline.ExecuteAsync(IPipelineContext context, CancellationToken cancellationToken) in C:\\__w\\1\\s\\Proxy\\Gateway.Pipeline\\ChildPipeline.cs:line 35\nat Gateway.Pipeline.Extensions.ValueTaskExtensions.Await[T](ValueTask`1 input) in C:\\__w\\1\\s\\Proxy\\Gateway.Pipeline\\Extensions\\ValueTaskExtensions.cs:line 28\nat Microsoft.WindowsAzure.ApiManagement.Proxy.Gateway.Policies.PipelineWalker.ExecuteAsync(IPipelineContext context, IEnumerable`1 steps, CancellationToken cancellation) in C:\\__w\\1\\s\\Proxy\\Gateway.Pipeline\\PipelineWalker.cs:line 66\nat Microsoft.WindowsAzure.ApiManagement.Proxy.Gateway.PipelineExecutor.ExecuteAsync(IPipelineContext context, CancellationToken cancellationToken) in C:\\__w\\1\\s\\Proxy\\Gateway.Pipeline\\PipelineExecutor.cs:line 215, transportError: 0, httpError: 0\n[Info] 2026-01-23T07:26:26.678 [GatewayLogs], correlationId: x-x-x-x, isRequestSuccess: false, totalTime: 922, category: \"GatewayLogs\", callerIpAddress: \"x.x.x.x\", timeGenerated: 2026-01-23T07:26:26.678, region: \"aks\", correlationId: \"x-x-x-x-x\", method: \"GET\", url: \"https://x.x.x.x/xselfca\", responseCode: 500, responseSize: 259, cache: \"none\", backendTime: 920, apiId: \"XXXXXXXXXXXXXXXXXXX\", operationId: \"get-home-page\", clientProtocol: \"HTTP/1.1\", apiRevision: \"1\", clientTlsVersion: \"1.3\", backendMethod: \"GET\", backendUrl: \"https://xxx.xxx.com/\", lastError: {\"elapsed\":921,\"source\":\"request-forwarder\",\"path\":\"forward-request\\\\forward-request\",\"reason\":\"BackendConnectionFailure\",\"message\":\"The remote certificate was rejected by the provided RemoteCertificateValidationCallback.\",\"section\":\"backend\"}, errors: [{\"elapsed\":921,\"source\":\"request-forwarder\",\"path\":\"forward-request\\\\forward-request\",\"reason\":\"BackendConnectionFailure\",\"message\":\"The remote certificate was rejected by the provided RemoteCertificateValidationCallback.\",\"section\":\"backend\"}]\n[Info] 2026-01-23T07:27:22.895 [InitialDnsNeighborDiscoverySucceeded], message: Successfully resolved IP addresses for DNS name xnewcstest-instance-discovery: 10.244.1.11, source: Neighborhood\n\n \n</pre>\n</div>\n<p>&nbsp;</p>\n<h1>参考资料</h1>\n<p id=\"use-custom-certificate-authorities-cas-in-azure-kubernetes-service-aks\">Use custom certificate authorities (CAs) in Azure Kubernetes Service (AKS) :&nbsp;<a href=\"https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority</a></p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\">\n    <div style=\"background: #1c5f55; height: 36px; width: 618px; padding: 14px 5px 0px 3px;\">\n  <p style=\"font-weight: bold; color: white;\">当在复杂的环境中面临问题，格物之道需：浊而静之徐清，安以动之徐生。 云中，恰是如此!</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-23 19:12</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lulight\">编码者卢布</a>&nbsp;\n阅读(<span id=\"post_view_count\">30</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "GitHub Issues 集成",
      "link": "https://www.cnblogs.com/newbe36524/p/19522793",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/newbe36524/p/19522793\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 15:54\">\n    <span>GitHub Issues 集成</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"从零构建-github-issues-集成hagicode-的前端直连实践\">从零构建 GitHub Issues 集成：HagiCode 的前端直连实践</h1>\n<blockquote>\n<p>本文记录了在 HagiCode 平台中集成 GitHub Issues 的全过程。我们将探讨如何通过\"前端直连 + 后端最小化\"的架构，在保持后端轻量的同时，实现安全的 OAuth 认证与高效的 Issues 同步。</p>\n</blockquote>\n<h2 id=\"背景为什么要集成-github\">背景：为什么要集成 GitHub？</h2>\n<p>HagiCode 作为一个 AI 辅助开发平台，核心价值在于连接想法与实现。但在实际使用中，我们发现用户在 HagiCode 中完成了 Proposal（提案）后，往往需要手动将内容复制到 GitHub Issues 中进行项目跟踪。</p>\n<p>这带来了几个明显的痛点：</p>\n<ol>\n<li><strong>工作流割裂</strong>：用户需要在两个系统之间来回切换，体验不仅不流畅，还容易导致关键信息在复制粘贴的过程中丢失。</li>\n<li><strong>协作不便</strong>：团队其他成员习惯在 GitHub 上查看任务，无法直接看到 HagiCode 中的提案进展。</li>\n<li><strong>重复劳动</strong>：每当提案更新，就要人工去 GitHub 更新对应的 Issue，增加不必要的维护成本。</li>\n</ol>\n<p>为了解决这个问题，我们决定引入 <strong>GitHub Issues Integration</strong> 功能，打通 HagiCode 会话与 GitHub 仓库的连接，实现\"一键同步\"。</p>\n<h2 id=\"关于-hagicode\">关于 HagiCode</h2>\n<blockquote>\n<p>嘿，介绍一下我们正在做的东西</p>\n</blockquote>\n<p>我们正在开发 <strong>HagiCode</strong> —— 一款 AI 驱动的代码智能助手，让开发体验变得更智能、更便捷、更有趣。</p>\n<p><strong>智能</strong> —— AI 全程辅助，从想法到代码，让编码效率提升数倍。<strong>便捷</strong> —— 多线程并发操作，充分利用资源，开发流程顺畅无阻。<strong>有趣</strong> —— 游戏化机制和成就系统，让编码不再枯燥，充满成就感。</p>\n<p>项目正在快速迭代中，如果你对技术写作、知识管理或者 AI 辅助开发感兴趣，欢迎来 <a href=\"https://github.com/HagiCode-org/site\" rel=\"noopener nofollow\" target=\"_blank\">GitHub</a> 看看～</p>\n<hr />\n<h2 id=\"技术选型前端直连-vs-后端代理\">技术选型：前端直连 vs 后端代理</h2>\n<p>在设计集成方案时，摆在我们面前的有两条路：传统的\"后端代理模式\"和更激进的\"前端直连模式\"。</p>\n<h3 id=\"方案对比\">方案对比</h3>\n<p>在传统的<strong>后端代理模式</strong>中，前端所有的请求都要先经过我们的后端，再由后端去调用 GitHub API。这虽然逻辑集中，但给后端带来了不小的负担：</p>\n<ol>\n<li><strong>后端臃肿</strong>：需要编写专门的 GitHub API 客户端封装，还要处理 OAuth 的复杂状态机。</li>\n<li><strong>Token 风险</strong>：用户的 GitHub Token 必须存储在后端数据库中，虽然可以加密，但毕竟增加了安全风险面。</li>\n<li><strong>开发成本</strong>：需要数据库迁移来存储 Token，还需要维护一套额外的同步服务。</li>\n</ol>\n<p>而<strong>前端直连模式</strong>则要轻量得多。在这个方案中，我们只利用后端来处理最敏感的\"密钥交换\"环节（OAuth callback），获取到 Token 后，直接存在浏览器的 localStorage 里。后续创建 Issue、更新评论等操作，直接由前端发 HTTP 请求到 GitHub。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">对比维度</th>\n<th style=\"text-align: left;\">后端代理模式</th>\n<th style=\"text-align: left;\">前端直连模式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>后端复杂度</strong></td>\n<td style=\"text-align: left;\">需要完整的 OAuth 服务和 GitHub API 客户端</td>\n<td style=\"text-align: left;\">仅需一个 OAuth 回调端点</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Token 管理</strong></td>\n<td style=\"text-align: left;\">需加密存储在数据库，有泄露风险</td>\n<td style=\"text-align: left;\">存储在浏览器，仅用户自己可见</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>实施成本</strong></td>\n<td style=\"text-align: left;\">需数据库迁移、多服务开发</td>\n<td style=\"text-align: left;\">主要是前端工作量</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>用户体验</strong></td>\n<td style=\"text-align: left;\">逻辑统一，但服务器延迟可能稍高</td>\n<td style=\"text-align: left;\">响应极快，直接与 GitHub 交互</td>\n</tr>\n</tbody>\n</table>\n<p>考虑到我们要的是快速集成和最小化后端改动，<strong>最终我们采用了\"前端直连模式\"</strong>。这就像给浏览器发了一张\"临时通行证\"，拿到证之后，浏览器就可以自己去 GitHub 办事了，不需要每次都找后端管理员批准。</p>\n<hr />\n<h2 id=\"核心设计数据流与安全\">核心设计：数据流与安全</h2>\n<p>在确定架构后，我们需要设计具体的数据流。整个同步流程的核心在于如何安全地获取 Token 并高效地利用它。</p>\n<h3 id=\"整体架构图\">整体架构图</h3>\n<p>整个系统可以抽象为三个角色：浏览器（前端）、HagiCode 后端、GitHub。</p>\n<pre><code class=\"language-text\">+--------------+        +--------------+        +--------------+\n|  前端 React  |        |    后端      |        |    GitHub    |\n|              |        |   ASP.NET    |        |    REST API  |\n|  +--------+  |        |              |        |              |\n|  |  OAuth |--+--------&gt; /callback    |        |              |\n|  |  流程  |  |        |              |        |              |\n|  +--------+  |        |              |        |              |\n|              |        |              |        |              |\n|  +--------+  |        |  +--------+  |        |  +--------+  |\n|  |GitHub  |  +------------&gt;Session |  +----------&gt; Issues |  |\n|  |API     |  |        |  |Metadata|  |        |  |        |  |\n|  |直连    |  |        |  +--------+  |        |  +--------+  |\n|  +--------+  |        |              |        |              |\n+--------------+        +--------------+        +--------------+\n</code></pre>\n<p><strong>关键点在于</strong>：只有 OAuth 的一小步（获取 code 换 token）需要经过后端，之后的粗活累活（创建 Issue）都是前端直接跟 GitHub 打交道。</p>\n<h3 id=\"同步数据流详解\">同步数据流详解</h3>\n<p>当用户点击 HagiCode 界面上的\"Sync to GitHub\"按钮时，会发生一系列复杂的动作：</p>\n<pre><code class=\"language-text\">用户点击 \"Sync to GitHub\"\n         │\n         ▼\n1. 前端检查 localStorage 获取 GitHub Token\n         │\n         ▼\n2. 格式化 Issue 内容（将 Proposal 转换为 Markdown）\n         │\n         ▼\n3. 前端直接调用 GitHub API 创建/更新 Issue\n         │\n         ▼\n4. 调用 HagiCode 后端 API 更新 Session.metadata (存储 Issue URL 等信息)\n         │\n         ▼\n5. 后端通过 SignalR 广播 SessionUpdated 事件\n         │\n         ▼\n6. 前端接收事件，更新 UI 显示\"已同步\"状态\n</code></pre>\n<h3 id=\"安全设计\">安全设计</h3>\n<p>安全问题始终是集成第三方服务的重中之重。我们做了以下考量：</p>\n<ol>\n<li><strong>防 CSRF 攻击</strong>：在 OAuth 跳转时，生成随机的 <code>state</code> 参数并存入 sessionStorage。回调时严格验证 state，防止请求被伪造。</li>\n<li><strong>Token 存储隔离</strong>：Token 仅存储在浏览器的 <code>localStorage</code> 中，利用同源策略（Same-Origin Policy），只有 HagiCode 的脚本才能读取，避免了服务器端数据库泄露波及用户。</li>\n<li><strong>错误边界</strong>：针对 GitHub API 常见的错误（如 401 Token 过期、422 验证失败、429 速率限制），设计了专门的错误处理逻辑，给用户以友好的提示。</li>\n</ol>\n<hr />\n<h2 id=\"实践代码实现细节\">实践：代码实现细节</h2>\n<p>纸上得来终觉浅，咱们来看看具体的代码是怎么实现的。</p>\n<h3 id=\"1-后端最小化改动\">1. 后端最小化改动</h3>\n<p>后端只需要做两件事：存储同步信息、处理 OAuth 回调。</p>\n<p><strong>数据库变更</strong><br />\n我们只需要在 <code>Sessions</code> 表增加一个 <code>Metadata</code> 列，用来存储 JSON 格式的扩展信息。</p>\n<pre><code class=\"language-sql\">-- 添加 metadata 列到 Sessions 表\nALTER TABLE \"Sessions\" ADD COLUMN \"Metadata\" text NULL;\n</code></pre>\n<p><strong>实体与 DTO 定义</strong></p>\n<pre><code class=\"language-csharp\">// src/HagiCode.DomainServices.Contracts/Entities/Session.cs\npublic class Session : AuditedAggregateRoot&lt;SessionId&gt;\n{\n    // ... 其他属性 ...\n\n    /// &lt;summary&gt;\n    /// JSON metadata for storing extension data like GitHub integration\n    /// &lt;/summary&gt;\n    public string? Metadata { get; set; }\n}\n\n// DTO 定义，方便前端序列化\npublic class GitHubIssueMetadata\n{\n    public required string Owner { get; set; }\n    public required string Repo { get; set; }\n    public int IssueNumber { get; set; }\n    public required string IssueUrl { get; set; }\n    public DateTime SyncedAt { get; set; }\n    public string LastSyncStatus { get; set; } = \"success\";\n}\n\npublic class SessionMetadata\n{\n    public GitHubIssueMetadata? GitHubIssue { get; set; }\n}\n</code></pre>\n<h3 id=\"2-前端-oauth-流程\">2. 前端 OAuth 流程</h3>\n<p>这是连接的入口。我们使用标准的 Authorization Code Flow。</p>\n<pre><code class=\"language-typescript\">// src/HagiCode.Client/src/services/githubOAuth.ts\n\n// 生成授权 URL 并跳转\nexport async function generateAuthUrl(): Promise&lt;string&gt; {\n  const state = generateRandomString(); // 生成防 CSRF 的随机串\n  sessionStorage.setItem('hagicode_github_state', state);\n  \n  const params = new URLSearchParams({\n    client_id: clientId,\n    redirect_uri: window.location.origin + '/settings?tab=github&amp;oauth=callback',\n    scope: ['repo', 'public_repo'].join(' '),\n    state: state,\n  });\n  \n  return `https://github.com/login/oauth/authorize?${params.toString()}`;\n}\n\n// 在回调页面处理 Code 换取 Token\nexport async function exchangeCodeForToken(code: string, state: string): Promise&lt;GitHubToken&gt; {\n  // 1. 验证 State 防止 CSRF\n  const savedState = sessionStorage.getItem('hagicode_github_state');\n  if (state !== savedState) throw new Error('Invalid state parameter');\n\n  // 2. 调用后端 API 进行 Token 交换\n  // 注意：这里必须经过后端，因为需要 ClientSecret，不能暴露在前端\n  const response = await fetch('/api/GitHubOAuth/callback', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ code, state, redirectUri: window.location.origin + '/settings?tab=github&amp;oauth=callback' }),\n  });\n\n  if (!response.ok) throw new Error('Failed to exchange token');\n  \n  const token = await response.json();\n  \n  // 3. 存入 LocalStorage\n  saveToken(token);\n  return token;\n}\n</code></pre>\n<h3 id=\"3-github-api-客户端封装\">3. GitHub API 客户端封装</h3>\n<p>有了 Token 之后，我们就需要一个强有力的工具来调 GitHub API。</p>\n<pre><code class=\"language-typescript\">// src/HagiCode.Client/src/services/githubApiClient.ts\n\nconst GITHUB_API_BASE = 'https://api.github.com';\n\n// 核心请求封装\nasync function githubApi&lt;T&gt;(endpoint: string, options: RequestInit = {}): Promise&lt;T&gt; {\n  const token = localStorage.getItem('gh_token');\n  if (!token) throw new Error('Not connected to GitHub');\n  \n  const response = await fetch(`${GITHUB_API_BASE}${endpoint}`, {\n    ...options,\n    headers: {\n      ...options.headers,\n      Authorization: `Bearer ${token}`,\n      Accept: 'application/vnd.github.v3+json', // 指定 API 版本\n    },\n  });\n  \n  // 错误处理逻辑\n  if (!response.ok) {\n    if (response.status === 401) throw new Error('GitHub Token 失效，请重新连接');\n    if (response.status === 403) throw new Error('无权访问该仓库或超出速率限制');\n    if (response.status === 422) throw new Error('Issue 验证失败，可能标题重复');\n    throw new Error(`GitHub API Error: ${response.statusText}`);\n  }\n  \n  return response.json();\n}\n\n// 创建 Issue\nexport async function createIssue(owner: string, repo: string, data: { title: string, body: string, labels: string[] }) {\n  return githubApi(`/repos/${owner}/${repo}/issues`, {\n    method: 'POST',\n    body: JSON.stringify(data),\n  });\n}\n</code></pre>\n<h3 id=\"4-内容格式化与同步\">4. 内容格式化与同步</h3>\n<p>最后一步，就是把 HagiCode 的 Session 数据转换成 GitHub Issue 的格式。这有点像\"翻译\"工作。</p>\n<pre><code class=\"language-typescript\">// 将 Session 对象转换为 Markdown 字符串\nfunction formatIssueForSession(session: Session): string {\n  let content = `# ${session.title}\\n\\n`;\n  content += `**&gt; HagiCode Session:** #${session.code}\\n`;\n  content += `**&gt; Status:** ${session.status}\\n\\n`;\n  content += `## Description\\n\\n${session.description || 'No description provided.'}\\n\\n`;\n  \n  // 如果是 Proposal 类型，添加额外字段\n  if (session.type === 'proposal') {\n    content += `## Chief Complaint\\n\\n${session.chiefComplaint || ''}\\n\\n`;\n    // 添加一个深链接，方便从 GitHub 跳回 HagiCode\n    content += `---\\n\\n**[View in HagiCode](hagicode://sessions/${session.id})**\\n`;\n  }\n  \n  return content;\n}\n\n// 点击同步按钮的主逻辑\nconst handleSync = async (session: Session) =&gt; {\n  try {\n    const repoInfo = parseRepositoryFromUrl(session.repoUrl); // 解析仓库 URL\n    if (!repoInfo) throw new Error('Invalid repository URL');\n\n    toast.loading('正在同步到 GitHub...');\n    \n    // 1. 格式化内容\n    const issueBody = formatIssueForSession(session);\n    \n    // 2. 调用 API\n    const issue = await githubApiClient.createIssue(repoInfo.owner, repoInfo.repo, {\n      title: `[HagiCode] ${session.title}`,\n      body: issueBody,\n      labels: ['hagicode', 'proposal', `status:${session.status}`],\n    });\n    \n    // 3. 更新 Session Metadata (保存 Issue 链接)\n    await SessionsService.patchApiSessionsSessionId(session.id, {\n      metadata: {\n        githubIssue: {\n          owner: repoInfo.owner,\n          repo: repoInfo.repo,\n          issueNumber: issue.number,\n          issueUrl: issue.html_url,\n          syncedAt: new Date().toISOString(),\n        }\n      }\n    });\n\n    toast.success('同步成功！');\n  } catch (err) {\n    console.error(err);\n    toast.error('同步失败，请检查 Token 或网络');\n  }\n};\n</code></pre>\n<hr />\n<h2 id=\"总结与展望\">总结与展望</h2>\n<p>通过这套\"前端直连\"方案，我们用最少的后端代码实现了 GitHub Issues 的无缝集成。</p>\n<h3 id=\"收获\">收获</h3>\n<ol>\n<li><strong>开发效率高</strong>：后端改动极小，主要是数据库加一个字段和一个简单的 OAuth 回调接口，大部分逻辑都在前端完成。</li>\n<li><strong>安全性好</strong>：Token 不经过服务器数据库，降低了泄露风险。</li>\n<li><strong>用户体验佳</strong>：直接从前端发起请求，响应速度快，不需要经过后端中转。</li>\n</ol>\n<h3 id=\"注意事项\">注意事项</h3>\n<p>在实际部署时，有几个坑大家要注意：</p>\n<ul>\n<li><strong>OAuth App 设置</strong>：记得在 GitHub OAuth App 设置里填正确的 <code>Authorization callback URL</code>（通常是 <code>http://localhost:3000/settings?tab=github&amp;oauth=callback</code>）。</li>\n<li><strong>速率限制</strong>：GitHub API 对未认证请求限制较严，但用 Token 后通常足够（5000次/小时）。</li>\n<li><strong>URL 解析</strong>：用户输入的 Repo URL 千奇百怪，记得正则要匹配 <code>.git</code> 后缀、SSH 格式等情况。</li>\n</ul>\n<h3 id=\"后续增强\">后续增强</h3>\n<p>目前的功能还是单向同步（HagiCode -&gt; GitHub）。未来我们计划通过 GitHub Webhooks 实现双向同步，比如在 GitHub 里关闭 Issue，HagiCode 这边的会话状态也能自动更新。这需要我们在后端暴露一个 Webhook 接收端点，这也是下一步要做的有趣工作。</p>\n<p>希望这篇文章能给你的第三方集成开发带来一点灵感！如果有问题，欢迎在 <a href=\"https://github.com/HagiCode-org/site\" rel=\"noopener nofollow\" target=\"_blank\">HagiCode GitHub</a> 上提 Issue 讨论。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-23 15:54</span>&nbsp;\n<a href=\"https://www.cnblogs.com/newbe36524\">Newbe36524</a>&nbsp;\n阅读(<span id=\"post_view_count\">62</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "IntelliJ IDEA 2026.1 EAP 发布！拥抱 Java 26，Spring Boot 4 深度支持！",
      "link": "https://www.cnblogs.com/javaguide/p/19522727",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/javaguide/p/19522727\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 15:42\">\n    <span>IntelliJ IDEA 2026.1 EAP 发布！拥抱 Java 26，Spring Boot 4 深度支持！</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n            <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>大家好，我是 Guide。这是真迅速啊！JetBrains 已经正式发布 <strong>IntelliJ IDEA 2026.1 EAP（Early Access Program）首个版本</strong>。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202601/1843652-20260123154128712-980411710.png\" /></p>\n<p>作为一个面向下一代大版本的抢先体验版，这次 EAP 不仅带来了对最新 Java 语言特性的支持，还在 Spring、Gradle、Maven 等主流框架和构建工具上进行了深度优化，并修复了 <strong>600 多个</strong> 已知 Bug。</p>\n<p>在此之前，<a href=\"https://mp.weixin.qq.com/s/dfAGOXQAfdjQXonL3gmreg\" rel=\"noopener nofollow\" target=\"_blank\">IntelliJ IDEA 2025.3.x 系列</a>已经带来了不少改进。本次 2026.1 EAP 的发布，标志着 IDE 对下一代技术栈的全面拥抱。</p>\n<p>下面按模块拆解这次版本的几个关键变化。</p>\n<h2 id=\"一语言特性java-26-与模式匹配进化\">一、语言特性：Java 26 与模式匹配进化</h2>\n<h3 id=\"11-java-26-语言级别支持\">1.1 Java 26 语言级别支持</h3>\n<p>IDEA 2026.1 EAP 最引人注目的变化之一，就是<strong>新增 Java 26 语言级别</strong>支持。这意味着开发者可以提前体验和测试即将在 JDK 26 中正式发布的语言特性。</p>\n<p>其中最重要的变化是<strong>对 JEP 530 的全面支持</strong>——\"原始类型在模式、instanceof 和 switch 中的应用（第四预览版）\"。</p>\n<h3 id=\"12-原始类型模式匹配从包装类到原生类型的跨越\">1.2 原始类型模式匹配：从包装类到原生类型的跨越</h3>\n<p>JEP 530 是 Project Amber（专注于语言演进的 OpenJDK 项目）的重要组成部分。它的核心目标是：<strong>让模式匹配支持所有原始类型</strong>（primitive types），而不仅仅是包装类。</p>\n<p><strong>💡 这意味着什么？</strong></p>\n<p>在之前的 Java 版本中，模式匹配主要针对对象类型。当你想要对原始类型（如 <code>int</code>、<code>long</code>、<code>double</code>）进行模式匹配时，必须先进行自动装箱，这会带来额外的性能开销。</p>\n<p><strong>旧写法（受限）：</strong></p>\n<pre><code class=\"language-java\">// 只能用包装类做模式匹配\nif (obj instanceof Integer i) {\n    // 使用 i\n}\n</code></pre>\n<p><strong>新写法（JEP 530）：</strong></p>\n<pre><code class=\"language-java\">// 原始类型直接参与模式匹配\nObject obj = 42L;\nif (obj instanceof long l) {\n    // l 是原始 long，没有装箱开销\n    System.out.println(\"这是一个 long 值：\" + l);\n}\n</code></pre>\n<p>更强大的地方在于 <strong>switch 表达式的支持</strong>：</p>\n<pre><code class=\"language-java\">// 原始类型在 switch 中的模式匹配\nString formatNumber(Object obj) {\n    return switch (obj) {\n        case byte b -&gt; \"Byte: \" + b;\n        case short s -&gt; \"Short: \" + s;\n        case int i -&gt; \"Int: \" + i;\n        case long l -&gt; \"Long: \" + l;\n        case float f -&gt; \"Float: \" + f;\n        case double d -&gt; \"Double: \" + d;\n        default -&gt; \"Unknown type\";\n    };\n}\n</code></pre>\n<p><strong>核心价值：</strong></p>\n<ul>\n<li><strong>性能提升</strong>：减少自动装箱/拆箱的开销</li>\n<li><strong>代码简洁</strong>：不再需要手动拆箱处理</li>\n<li><strong>类型安全</strong>：编译时就能检查类型转换的合法性</li>\n</ul>\n<p>官方 JEP 文档：<strong><a href=\"https://openjdk.org/jeps/530\" rel=\"noopener nofollow\" target=\"_blank\">https://openjdk.org/jeps/530</a></strong></p>\n<h3 id=\"13-其他\">1.3 其他</h3>\n<ul>\n<li><strong>Bytecode Viewer 同步</strong>：字节码查看器现在支持与 Kotlin 文件的编辑器同步 ，并允许从非 Java 文件触发 “Show Bytecode” 。</li>\n<li><strong>Javadoc 增强</strong>：支持在内联 <code>{@return}</code> 标签中使用 <code>{@code}</code> 标签 。</li>\n<li><strong>注解折叠改进</strong>：提升了 Java 注解的折叠显示效果，并支持在内联的 <code>@return</code> 标签中使用 <code>{@code}</code> 。</li>\n</ul>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202601/1843652-20260123154128572-175661814.png\" /></p>\n<h2 id=\"二spring-生态spring-boot-4-时代的全面适配\">二、Spring 生态：Spring Boot 4 时代的全面适配</h2>\n<p>Spring 开发者将迎来一次重大更新，特别是对 Spring Boot 4 的进一步深度适配。</p>\n<h3 id=\"21-spring-boot-4-深度支持\">2.1 Spring Boot 4 深度支持</h3>\n<p>Spring Boot 4.0 于 2025 年 11 月正式发布，基于 Spring Framework 7.0，全面支持 Java 25（含虚拟线程优化），是一个<strong>里程碑式的大版本更新</strong>。其核心变化包括：核心新特性包括：HTTP Service Clients 简化远程调用；原生 API 版本管理；全面采用 JSpecify 空安全体系（默认非空，编译期防 NPE）；关键依赖升级至 Jackson 3.0、Tomcat 11、Hibernate 7.1 等；支持 Gradle 9；Redis 静态主从配置；移除 Undertow。</p>\n<p>IDEA 2026.1 EAP 对 Spring Boot 4 的适配包括：</p>\n<ul>\n<li><strong>新增条件注解</strong>：支持 <code>@ConditionalOnEnabledHealthIndicator</code> 、<code>MailSenderCondition</code> 、<code>EmbeddedDatabaseCondition</code> 以及 <code>PooledDataSourceCondition</code> 。</li>\n<li><strong>配置类迁移适配</strong>：针对 Spring Boot 4 中移动的配置类（如 Caching 、Thymeleaf 、WebMvc 、FreeMarker 和 Mustache ）提供了全面的识别支持。</li>\n</ul>\n<h3 id=\"22-spring-data-jdbc-增强\">2.2 Spring Data JDBC 增强</h3>\n<p>数据库操作层面也有显著改进：</p>\n<ul>\n<li><strong>序列支持</strong>：新增对数据库序列（Sequences）的支持 ，并包含针对无名序列的检查项 。</li>\n<li><strong>Kotlin 协程支持</strong>：在 Spring Web 中支持 Coroutines 路由的 Kotlin DSL 。</li>\n<li><strong>嵌入式前缀</strong>：支持在结构中为嵌入对象（Embedded）添加前缀 。</li>\n</ul>\n<p><strong>💡 实际价值：</strong></p>\n<p>Spring Data JDBC 的这些改进，让开发者在处理复杂数据库映射时更加得心应手，特别是对于需要精细控制数据库序列的场景。</p>\n<h3 id=\"23-调试器spring-debugger稳定性提升\">2.3 调试器（Spring Debugger）稳定性提升</h3>\n<p>调试体验的稳定性提升是本次更新的另一个亮点：</p>\n<ul>\n<li><strong>事务节点修复</strong>：修复了在没有活动事务时事务节点依然残留的问题 。</li>\n<li><strong>远程调试增强</strong>：解决了通过 “Attach Debugger...” 链接连接远程进程时 Spring Debugger 不可用的问题 。</li>\n<li><strong>数据连接修复</strong>：修复了由于字符转义错误（'U'）导致 Spring Debugger 无法创建数据库连接的问题 。</li>\n</ul>\n<p><strong>实际影响：</strong></p>\n<p>对于需要频繁调试 Spring 应用的开发者来说，这些修复意味着调试过程的可预测性和稳定性大幅提升。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202601/1843652-20260123154128618-917342816.png\" /></p>\n<h2 id=\"三构建工具现代化gradle-9-与-maven-4\">三、构建工具现代化：Gradle 9 与 Maven 4</h2>\n<p>构建系统是项目的核心，IDEA 2026.1 EAP 对 Gradle 和 Maven 的最新版本提供了强力支持。</p>\n<h3 id=\"31-gradle-9-成为测试标准\">3.1 Gradle 9 成为测试标准</h3>\n<p>Gradle 9.3 于近期正式发布，是一个<strong>具有破坏性变化但性能显著提升</strong>的大版本。</p>\n<p><img alt=\"图片\" src=\"https://img2024.cnblogs.com/blog/1843652/202601/1843652-20260123154128597-1358730905.png\" /></p>\n<p><strong>IDEA 2026.1 EAP 的适配：</strong></p>\n<ul>\n<li>内部测试已全面切换到 <strong>Gradle 9.2.0</strong></li>\n<li>开始采用官方的 <strong>Gradle Tooling API (TAPI) 9.2.0</strong></li>\n<li>正式放弃对老旧的 <strong>Gradle 4.5</strong> 版本的支持</li>\n</ul>\n<h3 id=\"32-gradle-9-的关键变化\">3.2 Gradle 9 的关键变化</h3>\n<p>Gradle 9.0 带来了几个开发者必须关注的重大变化：</p>\n<h4 id=\"321-java-17-强制要求\">3.2.1 Java 17+ 强制要求</h4>\n<p><strong>破坏性变化：</strong></p>\n<ul>\n<li>Gradle 9.0 <strong>要求 JVM 17 或更高</strong>才能运行 Gradle Daemon</li>\n<li>大多数 Gradle API 现在编译为 JVM 17 字节码</li>\n<li>Gradle 仍支持编译 Java 6+ 的目标代码</li>\n</ul>\n<p><strong>💡 这意味着：</strong><br />\n如果你的项目还在使用 Java 8 或 Java 11，升级 Gradle 9 的第一步就是<strong>升级构建环境的 JDK 版本</strong>。</p>\n<h4 id=\"322-configuration-cache-优先模式\">3.2.2 Configuration Cache 优先模式</h4>\n<p>Gradle 9.0 最重要的性能特性是 <strong>Configuration Cache（配置缓存）成为首选执行模式</strong>。</p>\n<p><strong>核心特性：</strong></p>\n<ul>\n<li><strong>优雅降级</strong>：当插件或任务不支持配置缓存时，Gradle 会自动回退到非缓存模式，而不是构建失败</li>\n<li><strong>性能提升</strong>：在小模块变更场景下，报告显示有 <strong>~50% 的速度提升</strong></li>\n<li><strong>渐进式迁移</strong>：允许任务被明确标记为与配置缓存不兼容</li>\n</ul>\n<p><strong>示例对比：</strong></p>\n<pre><code class=\"language-gradle\">// Gradle 8：配置缓存是可选的\ntasks.named('compileJava').configure {\n    // 需要手动处理配置缓存兼容性\n}\n\n// Gradle 9：配置缓存优先，不兼容时自动降级\n// 构建会更快，且不会因缓存问题失败\n</code></pre>\n<h4 id=\"323-kotlin-dsl-体验升级\">3.2.3 Kotlin DSL 体验升级</h4>\n<p>在 <code>build.gradle.kts</code> 文件中，IDEA 现在支持：</p>\n<ul>\n<li><strong>直接运行配置按钮</strong>：可以通过 UI 按钮直接执行通过 <code>tasks.register { }</code> 注册的任务</li>\n<li><strong>更好的代码补全</strong>：Kotlin DSL 的编辑体验进一步优化</li>\n</ul>\n<p><strong>操作示例：</strong></p>\n<pre><code class=\"language-kotlin\">// build.gradle.kts\ntasks.register(\"myCustomTask\") {\n    doLast {\n        println(\"执行自定义任务\")\n    }\n}\n\n// IDEA 2026.1 EAP 中：\n// - 这个任务会自动出现在运行配置中\n// - 可以直接点击绿色按钮运行\n</code></pre>\n<h3 id=\"33-maven-4-集成\">3.3 Maven 4 集成</h3>\n<p>Maven 4 的适配也在同步推进：</p>\n<ul>\n<li><strong>内置版本更新</strong>：将内置 Maven 4 版本升级至 <strong>4.0.0-rc-5</strong> 。</li>\n<li><strong>同步优化</strong>：修复了 Maven 4.0.0 模型下不支持 <code>&lt;subprojects&gt;</code> 元素导致同步失败的问题 。</li>\n</ul>\n<p>Guide 想问问：<a href=\"https://mp.weixin.qq.com/s/WzeVZKm8DtmspKKX5RMzDQ\" rel=\"noopener nofollow\" target=\"_blank\">什么时候 Maven 4 正式版才能来啊？应该快了吧？</a></p>\n<blockquote>\n<p>Gradle 9 官方文档：<strong><a href=\"https://gradle.org/whats-new/gradle-9/\" rel=\"noopener nofollow\" target=\"_blank\">https://gradle.org/whats-new/gradle-9/</a></strong></p>\n</blockquote>\n<p><a href=\"https://javaguide.cn/zhuanlan/interview-guide.html\" rel=\"noopener nofollow\" target=\"_blank\">《SpringAI 智能面试平台+RAG 知识库》</a>配套实战项目教程正在更新，涉及到 Prompt Engineering、大模型集成、RAG（检索增强生成）、高性能对象存储与向量数据库。后续的话，还会同步上 Agent 项目。</p>\n<p>内容非常全面，非常适合想要实战 AI 项目或者准备 AI 大模型应用开发岗位面试的朋友，来一张刚写完的<strong>3.4w 字+35 道题目</strong>的 RAG 面试题总结，大家感受一下（点此链接了解）： <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" rel=\"noopener nofollow\" target=\"_blank\">星球</a>）：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202601/1843652-20260123154128762-1404565501.png\" /></p>\n<h2 id=\"四开发体验优化插件与框架改进\">四、开发体验优化：插件与框架改进</h2>\n<p>除了大型框架和构建工具的支持，IDEA 2026.1 EAP 在日常开发常用的插件和框架上也做了大量改进。</p>\n<h3 id=\"41-lombok-插件增强\">4.1 Lombok 插件增强</h3>\n<p>Lombok 是 Java 开发中最流行的代码生成插件之一，本次更新带来了：</p>\n<p><strong>新增支持：</strong></p>\n<ul>\n<li><strong><code>@Accessors(fluent = true)</code> 支持</strong>：链式调用风格的 getter/setter 生成</li>\n<li><strong>Builder 方法解析修复</strong>：解决特定情况下 Builder 方法无法正确解析的问题</li>\n</ul>\n<p><strong>⚠️ 新增检查：</strong></p>\n<ul>\n<li>插件现在会对<strong>在非静态内部类上使用 <code>@Slf4j</code> 的错误用法</strong>给出编译错误提示</li>\n</ul>\n<p><strong>实际影响：</strong></p>\n<pre><code class=\"language-java\">// 现在会被检测为错误用法\nclass Outer {\n    @Slf4j  // ❌ 编译错误：非静态内部类不能使用 @Slf4j\n    class Inner {\n        // ...\n    }\n}\n\n// 正确用法\nclass Outer {\n    static class Inner {\n        @Slf4j  // ✅ 静态内部类可以使用\n        // ...\n    }\n}\n</code></pre>\n<h3 id=\"42-框架与语言支持\">4.2 框架与语言支持</h3>\n<ul>\n<li><strong>Hibernate 修复</strong>：解决了 Hibernate 插件错误地要求 Spring 插件作为先决条件的回归问题 。</li>\n<li><strong>Groovy 5 支持</strong>：修复了在 Groovy 5 项目中将接口静态方法误报为错误的问题 。</li>\n<li><strong>JPA QL 语法</strong>：修复了大量 JPA QL/HQL 的语法高亮错误，包括对 <code>RIGHT JOIN</code> 和 <code>coalesce</code> 子查询 的支持。</li>\n</ul>\n<h3 id=\"43-javadoc-转换为-markdown\">4.3 Javadoc 转换为 Markdown</h3>\n<p>IDE 进一步优化了 “Convert to Markdown documentation comment” 功能，修复了转换时吞掉链接换行符 以及列表缩进错误 的问题。</p>\n<h2 id=\"五性能与稳定性600-bug-修复\">五、性能与稳定性：600+ Bug 修复</h2>\n<p>除了新功能，本次 EAP 还包含了大量的 Bug 修复和性能优化，涵盖了从核心平台、UI、文件系统到各种语言的方方面面。</p>\n<h3 id=\"51-核心平台优化\">5.1 核心平台优化</h3>\n<p><strong>修复的问题：</strong></p>\n<ul>\n<li><strong>WSL 环境下 Tomcat 调试</strong>：解决了在 WSL（Windows Subsystem for Linux）环境下 Tomcat 调试不工作的问题</li>\n<li><strong>远程开发冻结</strong>：修复了远程开发中的一些冻结问题</li>\n</ul>\n<h3 id=\"52-ui-体验改进\">5.2 UI 体验改进</h3>\n<p><strong>优化项：</strong></p>\n<ul>\n<li><strong>编辑器优化</strong>：编辑器响应速度和流畅度提升</li>\n<li><strong>终端改进</strong>：终端体验问题修复</li>\n<li><strong>搜索体验</strong>：搜索功能的性能和准确性提升</li>\n</ul>\n<h3 id=\"53-语言支持全面增强\">5.3 语言支持全面增强</h3>\n<p><strong>覆盖语言：</strong></p>\n<ul>\n<li><strong>Kotlin</strong>：IDEA 对 Kotlin 语言的支持持续优化</li>\n<li><strong>Groovy</strong>：Groovy 脚本编辑体验改进</li>\n<li><strong>JavaScript/TypeScript</strong>：前端开发支持增强</li>\n</ul>\n<h2 id=\"六总结是否值得升级\">六、总结：是否值得升级？</h2>\n<p>下面是 <strong>IntelliJ IDEA 2026.1 EAP 1</strong> 带来的关键升级：</p>\n<h3 id=\"61-关键升级一览表\">6.1 关键升级一览表</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n<th>适用人群</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Java 26 支持</strong></td>\n<td>JEP 530 原始类型模式匹配（第四预览）</td>\n<td>喜欢尝鲜的开发者</td>\n</tr>\n<tr>\n<td><strong>Spring Boot 4</strong></td>\n<td>深度适配新条件注解和配置类</td>\n<td>Spring 开发者</td>\n</tr>\n<tr>\n<td><strong>Gradle 9</strong></td>\n<td>配置缓存优先、Java 17+ 要求</td>\n<td>构建性能敏感者</td>\n</tr>\n<tr>\n<td><strong>Maven 4</strong></td>\n<td>内置版本更新至 4.0.0-rc-5</td>\n<td>Maven 用户</td>\n</tr>\n<tr>\n<td><strong>Lombok 增强</strong></td>\n<td>@Accessors(fluent=true) 支持</td>\n<td>Lombok 用户</td>\n</tr>\n<tr>\n<td><strong>600+ Bug 修复</strong></td>\n<td>核心平台、UI、多语言支持</td>\n<td>所有用户</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"62-升级建议\">6.2 升级建议</h3>\n<p>如果你正在考虑向 <strong>Spring Boot 4</strong> 迁移，或者需要使用 <strong>Java 26</strong> 的预览特性，这个 EAP 版本非常值得尝试。但请注意，由于这是 EAP 1 版本，建议仅在非生产环境中使用，并定期备份你的配置文件。</p>\n<h2 id=\"参考资料\">参考资料</h2>\n<ul>\n<li>Release Notes： <strong><a href=\"https://youtrack.jetbrains.com/articles/IDEA-A-2100662609/IntelliJ-IDEA-2026-1-EAP-1-261-17801.55-build-Release-Notes\" rel=\"noopener nofollow\" target=\"_blank\">https://youtrack.jetbrains.com/articles/IDEA-A-2100662609/IntelliJ-IDEA-2026-1-EAP-1-261-17801.55-build-Release-Notes</a></strong></li>\n<li>What's new in Gradle 9.0.0：<strong><a href=\"https://gradle.org/whats-new/gradle-9\" rel=\"noopener nofollow\" target=\"_blank\">https://gradle.org/whats-new/gradle-9</a></strong></li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-01-23 15:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/javaguide\">JavaGuide</a>&nbsp;\n阅读(<span id=\"post_view_count\">219</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "访问控制权限模型分析梳理",
      "link": "https://www.cnblogs.com/Marktowin/p/19525635",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Marktowin/p/19525635\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 11:22\">\n    <span>访问控制权限模型的分析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h3 dir=\"auto\">1. 概述</h3>\n<p dir=\"auto\">权限模型（Access Control Models）是信息安全领域用于管理资源访问的核心机制。它们定义了谁（主体）可以对什么（客体）进行哪些操作（如读、写、执行）。常见的模型包括DAC、MAC、RBAC、ABAC等。这些模型可单独使用或组合（如RBAC与ABAC的混合）。选择模型取决于系统需求，如灵活性、安全性、复杂度和规模。</p>\n<p dir=\"auto\">几种主要模型的分析。</p>\n<table>\n<thead>\n<tr><th>模型名称</th><th>全称</th><th>核心原理</th><th>优点</th><th>缺点</th><th>典型使用场景</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>DAC</td>\n<td>Discretionary Access Control (自主访问控制)</td>\n<td>用户（资源所有者）自行决定谁能访问其资源，通常基于访问控制列表 (ACL)。例如，文件所有者设置权限。</td>\n<td>灵活性高，用户自主管理；易于实现。</td>\n<td>安全性低，易受恶意用户影响（如病毒传播）；不适合高安全环境。</td>\n<td>个人文件系统（如Windows NTFS、Unix文件权限）；小型协作工具。</td>\n</tr>\n<tr>\n<td>MAC</td>\n<td>Mandatory Access Control (强制访问控制)</td>\n<td>系统强制执行基于标签的安全策略（如机密级别：公开、秘密、绝密）。主体和客体都有标签，访问需匹配规则。</td>\n<td>高安全性，防止信息泄露；适合多级安全。</td>\n<td>灵活性差，用户无法 override；管理复杂。</td>\n<td>军事/政府系统（如SELinux、AppArmor）；高保密环境如银行核心系统。</td>\n</tr>\n<tr>\n<td>RBAC</td>\n<td>Role-Based Access Control (基于角色的访问控制)</td>\n<td>用户分配角色，角色绑定权限。权限不直接赋给用户，而是通过角色间接管理。支持角色继承和会话。</td>\n<td>易于管理大规模用户；符合最小权限原则；便于审计。</td>\n<td>角色爆炸问题（太多角色）；静态，不易处理动态上下文。</td>\n<td>企业应用（如ERP系统、HR软件）；云平台（如AWS IAM角色）。</td>\n</tr>\n<tr>\n<td>ABAC</td>\n<td>Attribute-Based Access Control (基于属性的访问控制)</td>\n<td>基于主体、客体、环境和操作的属性（如用户部门、时间、位置）动态评估策略。通常用XACML语言定义规则。</td>\n<td>高度灵活，支持动态决策；细粒度控制。</td>\n<td>复杂，实现和性能开销大；策略管理困难。</td>\n<td>云服务（如Azure AD）；IoT系统；需要上下文感知的场景如远程访问。</td>\n</tr>\n<tr>\n<td>Rule-Based</td>\n<td>Rule-Based Access Control (基于规则的访问控制)</td>\n<td>定义一组规则（如IP过滤、时间限制），访问请求匹配规则通过。常与防火墙结合。</td>\n<td>简单直接；易于自动化。</td>\n<td>规则冲突可能；不适合复杂权限。</td>\n<td>网络防火墙（如iptables）；API网关（如Kong）。</td>\n</tr>\n<tr>\n<td>Capability-Based</td>\n<td>Capability-Based Access Control (基于能力的访问控制)</td>\n<td>用户持有“能力”（token-like），能力直接授予对特定资源的访问权，无需检查所有者。</td>\n<td>高效，减少中央检查；支持分布式系统。</td>\n<td>能力泄露风险；撤销困难。</td>\n<td>操作系统（如Capsicum in FreeBSD）；分布式文件系统（如Google's Spanner）。</td>\n</tr>\n</tbody>\n</table>\n<h3 dir=\"auto\">2. 详细分析</h3>\n<ul dir=\"auto\">\n<li><strong>DAC的使用</strong>：在日常开发中，常用于文件共享系统。实现示例：在Python中使用os.chmod设置文件权限。但在多用户环境中，易导致权限滥用，因此常与审计日志结合。</li>\n<li><strong>MAC的使用</strong>：适用于严格分级系统，如在Linux上启用SELinux。策略文件定义标签，系统内核强制执行。缺点是调试复杂，但可防止越权（如root用户也受限）。</li>\n<li><strong>RBAC的使用</strong>：最流行模型。在数据库中存储用户-角色-权限表。示例：在Spring Security中配置@PreAuthorize(\"hasRole('ADMIN')\")。扩展时可添加角色层次（如admin继承user）。</li>\n<li><strong>ABAC的使用</strong>：现代趋势，支持AI驱动决策。使用Policy Decision Point (PDP)评估属性。示例：在OAuth2中结合JWT token的claims进行属性检查。适合微服务架构，但需优化规则引擎以避免延迟。</li>\n<li><strong>混合模型</strong>：实际项目中常混合使用，如RBAC+ABAC（称为RBAC扩展），角色提供粗粒度，属性提供细粒度。示例：AWS使用角色（RBAC）+条件键（ABAC）。</li>\n</ul>\n<h3 dir=\"auto\">3. 实施建议</h3>\n<ul dir=\"auto\">\n<li><strong>选择依据</strong>：小型系统用DAC/RBAC；高安全用MAC/ABAC；动态环境用ABAC。</li>\n<li><strong>最佳实践</strong>：遵循最小权限原则（Least Privilege）；定期审计权限；使用工具如Open Policy Agent (OPA)统一管理多模型。</li>\n<li><strong>潜在风险</strong>：权限膨胀（权限过多导致漏洞）；配置错误（如默认全开权限）。</li>\n<li><strong>工具推荐</strong>：身份管理 - Keycloak/OAuth；策略引擎 - OPA；监控 - ELK Stack。</li>\n</ul>\n<h3 dir=\"auto\">4.&nbsp;权限模型的表格设计</h3>\n<ul>\n<li dir=\"auto\">\n<h4>DAC（自主访问控制） → 基于 ACL（Access Control List）</h4>\n</li>\n</ul>\n<p dir=\"auto\">　　　　核心思想：每个资源（对象）拥有自己的权限列表，由资源拥有者决定谁能访问。</p>\n<table>\n<thead>\n<tr><th>表名</th><th>说明</th><th>主要字段</th><th>关系说明</th></tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>resources</strong></td>\n<td>资源表（文件、文章、记录等）</td>\n<td>id, owner_id, name, type...</td>\n<td>-</td>\n</tr>\n<tr>\n<td><strong>acls</strong></td>\n<td>访问控制列表（ACL）</td>\n<td>id, resource_id, subject_id（用户/组ID）, subject_type（user/group）, permission（read/write/execute/delete）, granted_by（授予者）</td>\n<td>多对一关联 resource</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">CREATE TABLE resources (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    owner_id BIGINT NOT NULL,           </span><span style=\"color: rgba(0, 128, 0, 1);\">--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 资源拥有者（用户ID）</span>\n    name VARCHAR(<span style=\"color: rgba(128, 0, 128, 1);\">255</span><span style=\"color: rgba(0, 0, 0, 1);\">) NOT NULL,\n    </span><span style=\"color: rgba(255, 0, 255, 1);\">type</span> ENUM(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">file</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">post</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">record</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">) NOT NULL\n);\n\nCREATE TABLE acls (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    resource_id BIGINT NOT NULL,\n    subject_id BIGINT NOT NULL,         </span><span style=\"color: rgba(0, 128, 0, 1);\">--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 用户ID 或 组ID</span>\n    subject_type ENUM(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">user</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">group</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">) NOT NULL,\n    permission ENUM(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">read</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">write</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">execute</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">delete</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">all</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">) NOT NULL,\n    granted_by BIGINT,                  </span><span style=\"color: rgba(0, 128, 0, 1);\">--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 谁授予的权限（可选，用于审计）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (resource_id) REFERENCES resources(id) ON DELETE CASCADE\n);</span></pre>\n</div>\n<ul>\n<li>\n<h4 dir=\"auto\">RBAC（基于角色的访问控制） → 最常用模型</h4>\n</li>\n</ul>\n<p dir=\"auto\">　　　　核心思想：用户 → 角色 → 权限</p>\n<p dir=\"auto\">　　</p>\n<table>\n<thead>\n<tr><th>表名</th><th>说明</th><th>主要字段</th><th>关系说明</th></tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>users</strong></td>\n<td>用户表</td>\n<td>id, username...</td>\n<td>-</td>\n</tr>\n<tr>\n<td><strong>roles</strong></td>\n<td>角色表</td>\n<td>id, name, description</td>\n<td>-</td>\n</tr>\n<tr>\n<td><strong>permissions</strong></td>\n<td>权限表（细粒度操作）</td>\n<td>id, code（唯一标识，如 user:view）, name, resource, action</td>\n<td>-</td>\n</tr>\n<tr>\n<td><strong>user_roles</strong></td>\n<td>用户-角色关联（多对多）</td>\n<td>user_id, role_id</td>\n<td>多对多</td>\n</tr>\n<tr>\n<td><strong>role_permissions</strong></td>\n<td>角色-权限关联（多对多）</td>\n<td>role_id, permission_id</td>\n<td>多对多</td>\n</tr>\n</tbody>\n</table>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">CREATE TABLE roles (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">50</span><span style=\"color: rgba(0, 0, 0, 1);\">) UNIQUE NOT NULL,\n    description VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">255</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n);\n\nCREATE TABLE permissions (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    code VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">100</span>) UNIQUE NOT NULL,   <span style=\"color: rgba(0, 128, 0, 1);\">--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 如 user:view, post:delete</span>\n    name VARCHAR(<span style=\"color: rgba(128, 0, 128, 1);\">100</span><span style=\"color: rgba(0, 0, 0, 1);\">) NOT NULL,\n    resource VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">50</span><span style=\"color: rgba(0, 0, 0, 1);\">),\n    action VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">20</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n);\n\nCREATE TABLE user_roles (\n    user_id BIGINT NOT NULL,\n    role_id BIGINT NOT NULL,\n    PRIMARY KEY (user_id, role_id),\n    FOREIGN KEY (role_id) REFERENCES roles(id)\n);\n\nCREATE TABLE role_permissions (\n    role_id BIGINT NOT NULL,\n    permission_id BIGINT NOT NULL,\n    PRIMARY KEY (role_id, permission_id),\n    FOREIGN KEY (role_id) REFERENCES roles(id),\n    FOREIGN KEY (permission_id) REFERENCES permissions(id)\n);</span></pre>\n</div>\n<ul>\n<li>\n<h4 dir=\"auto\">ABAC（基于属性的访问控制） → 最灵活但最复杂</h4>\n</li>\n</ul>\n<p dir=\"auto\">　　　　核心思想：不依赖固定角色，而是根据<strong>主体属性 + 客体属性 + 环境属性 + 操作</strong>动态评估。</p>\n<p dir=\"auto\">　　　　常见实现方式有两种：</p>\n<ul dir=\"auto\">\n<li>\n<ul>\n<li>\n<ul>\n<li><strong>策略表 + 属性表</strong>（纯数据库实现，较重）</li>\n<li><strong>外部策略引擎</strong>（如 OPA、Casbin）+ 数据库只存属性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr><th>表名</th><th>说明</th><th>主要字段</th></tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>attributes</strong></td>\n<td>属性定义表</td>\n<td>id, name, type（user/object/environment）, description</td>\n</tr>\n<tr>\n<td><strong>user_attributes</strong></td>\n<td>用户属性值</td>\n<td>user_id, attribute_id, value</td>\n</tr>\n<tr>\n<td><strong>object_attributes</strong></td>\n<td>资源属性值</td>\n<td>object_id, object_type, attribute_id, value</td>\n</tr>\n<tr>\n<td><strong>policies</strong></td>\n<td>策略表（核心）</td>\n<td>id, name, effect（allow/deny）, description</td>\n</tr>\n<tr>\n<td><strong>policy_rules</strong></td>\n<td>策略规则（一条策略可有多条规则）</td>\n<td>policy_id, attribute_id, operator（=,&gt;,in等）, value</td>\n</tr>\n<tr>\n<td><strong>policy_actions</strong></td>\n<td>策略允许的操作</td>\n<td>policy_id, action（read/write/delete）</td>\n</tr>\n<tr>\n<td><strong>policy_targets</strong></td>\n<td>策略适用的资源范围</td>\n<td>policy_id, resource_type, resource_id（可选）</td>\n</tr>\n</tbody>\n</table>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">CREATE TABLE attributes (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">100</span><span style=\"color: rgba(0, 0, 0, 1);\">) UNIQUE NOT NULL,\n    category ENUM(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">subject</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">resource</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">environment</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">action</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n);\n\nCREATE TABLE user_attributes (\n    user_id BIGINT NOT NULL,\n    attribute_id BIGINT NOT NULL,\n    value VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">255</span><span style=\"color: rgba(0, 0, 0, 1);\">) NOT NULL,\n    PRIMARY KEY (user_id, attribute_id)\n);\n\nCREATE TABLE object_attributes (\n    object_id BIGINT NOT NULL,\n    object_type VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">50</span><span style=\"color: rgba(0, 0, 0, 1);\">) NOT NULL,\n    attribute_id BIGINT NOT NULL,\n    value VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">255</span><span style=\"color: rgba(0, 0, 0, 1);\">) NOT NULL,\n    PRIMARY KEY (object_id, object_type, attribute_id)\n);\n\nCREATE TABLE policies (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">100</span><span style=\"color: rgba(0, 0, 0, 1);\">) NOT NULL,\n    effect ENUM(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">allow</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">deny</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">) NOT NULL\n);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 规则示例：部门=销售 且 时间在工作日 且 操作=read</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">CREATE TABLE policy_conditions (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    policy_id BIGINT NOT NULL,\n    attribute_id BIGINT NOT NULL,\n    operator ENUM(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">=</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">!=</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">&gt;</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">in</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>,<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">contains</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">),\n    value VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">255</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n);</span></pre>\n</div>\n<ul>\n<li>\n<h4 dir=\"auto\">MAC（强制访问控制） → 高安全场景</h4>\n</li>\n</ul>\n<p dir=\"auto\">　　　　核心思想：系统强制基于<strong>安全标签</strong>（如机密级别：公开、内部、秘密、绝密）决定访问。</p>\n<p dir=\"auto\">　　　　</p>\n<table>\n<thead>\n<tr><th>表名</th><th>说明</th><th>主要字段</th></tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>security_levels</strong></td>\n<td>安全级别定义</td>\n<td>id, name（UNCLASSIFIED, CONFIDENTIAL, SECRET, TOP_SECRET）, level_value（数字越大越密）</td>\n</tr>\n<tr>\n<td><strong>users</strong></td>\n<td>用户表（扩展）</td>\n<td>... + clearance_level_id（许可级别）</td>\n</tr>\n<tr>\n<td><strong>objects</strong></td>\n<td>资源表（扩展）</td>\n<td>... + classification_level_id（分类级别） + compartments（可选：项目A、项目B等）</td>\n</tr>\n<tr>\n<td><strong>compartments</strong></td>\n<td>范畴/类别（需知原则）</td>\n<td>id, name</td>\n</tr>\n<tr>\n<td><strong>object_compartments</strong></td>\n<td>资源所属范畴（多对多）</td>\n<td>object_id, compartment_id</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">　　　　</p>\n<p dir=\"auto\"><strong>　　　　访问规则示例</strong>（Bell-LaPadula模型）：</p>\n<ul dir=\"auto\">\n<li>\n<ul>\n<li>\n<ul>\n<li>读：主体许可级别 ≥ 客体分类级别 且 主体范畴包含客体所有范畴</li>\n<li>写：主体许可级别 ≤ 客体分类级别 且 主体范畴 ⊆ 客体范畴</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">CREATE TABLE security_levels (\n    id INT PRIMARY KEY,\n    name VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">50</span><span style=\"color: rgba(0, 0, 0, 1);\">) UNIQUE NOT NULL,\n    level_value INT NOT NULL  </span><span style=\"color: rgba(0, 128, 0, 1);\">--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 数字越大越密</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">);\n\nCREATE TABLE compartments (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">50</span><span style=\"color: rgba(0, 0, 0, 1);\">) UNIQUE NOT NULL\n);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 用户许可级别（clearance）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">ALTER TABLE users ADD clearance_level_id INT REFERENCES security_levels(id);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 资源分类级别</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">ALTER TABLE objects ADD classification_level_id INT REFERENCES security_levels(id);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 资源所属范畴（多对多）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">CREATE TABLE object_compartments (\n    object_id BIGINT NOT NULL,\n    compartment_id BIGINT NOT NULL,\n    PRIMARY KEY (object_id, compartment_id)\n);</span></pre>\n</div>\n<ul>\n<li>\n<h4 dir=\"auto\">Capability-Based（基于能力的访问控制）</h4>\n</li>\n</ul>\n<p dir=\"auto\">　　　　核心思想：用户持有“能力令牌”（Capability），令牌直接指向资源+操作，无需查中央权限表。</p>\n<table>\n<thead>\n<tr><th>表名</th><th>说明</th><th>主要字段</th></tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>capabilities</strong></td>\n<td>能力令牌表</td>\n<td>id, token（唯一字符串或UUID）, user_id, resource_id, resource_type, permissions（JSON或多字段）, expires_at, revoked</td>\n</tr>\n<tr>\n<td><strong>capability_scopes</strong></td>\n<td>能力作用范围（可选）</td>\n<td>capability_id, scope（特定记录ID等）</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">CREATE TABLE capabilities (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    token VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">255</span>) UNIQUE NOT NULL,     <span style=\"color: rgba(0, 128, 0, 1);\">--</span><span style=\"color: rgba(0, 128, 0, 1);\"> JWT 或 UUID</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    user_id BIGINT NOT NULL,\n    resource_id BIGINT NOT NULL,\n    resource_type VARCHAR(</span><span style=\"color: rgba(128, 0, 128, 1);\">50</span><span style=\"color: rgba(0, 0, 0, 1);\">) NOT NULL,\n    permissions JSON NOT NULL,              </span><span style=\"color: rgba(0, 128, 0, 1);\">--</span><span style=\"color: rgba(0, 128, 0, 1);\"> [\"read\",\"write\"]</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    expires_at TIMESTAMP,\n    revoked BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);</span></pre>\n</div>\n<p>&nbsp;</p>\n<h3>总结：</h3>\n<p>　　</p>\n<table>\n<thead>\n<tr><th>模型</th><th>推荐场景</th><th>表数量</th><th>复杂度</th><th>灵活性</th><th>性能</th></tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>DAC</strong></td>\n<td>文件系统、个人资源共享</td>\n<td>2-3</td>\n<td>低</td>\n<td>高</td>\n<td>高</td>\n</tr>\n<tr>\n<td><strong>RBAC</strong></td>\n<td>企业级SaaS、中后台系统</td>\n<td>4-6</td>\n<td>中</td>\n<td>中高</td>\n<td>高</td>\n</tr>\n<tr>\n<td><strong>ABAC</strong></td>\n<td>云服务、IoT、需要上下文的场景</td>\n<td>6+</td>\n<td>高</td>\n<td>极高</td>\n<td>中</td>\n</tr>\n<tr>\n<td><strong>MAC</strong></td>\n<td>军事、政府、高保密系统</td>\n<td>4-6</td>\n<td>中高</td>\n<td>低</td>\n<td>高</td>\n</tr>\n<tr>\n<td><strong>CapBAC</strong></td>\n<td>分布式系统、微服务、临时授权</td>\n<td>2-4</td>\n<td>中</td>\n<td>高</td>\n<td>高</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 11:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Marktowin\">Marktowin</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}