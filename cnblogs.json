{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "古文观芷App搜索方案深度解析：打造极致性能的古文搜索引擎",
      "link": "https://www.cnblogs.com/hlxs/p/19561679",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hlxs/p/19561679\" id=\"cb_post_title_url\" title=\"发布于 2026-02-01 22:27\">\n    <span>古文观芷App搜索方案深度解析：打造极致性能的古文搜索引擎</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"古文观芷app搜索方案深度解析打造极致性能的古文搜索引擎\">古文观芷App搜索方案深度解析：打造极致性能的古文搜索引擎</h1>\n<h2 id=\"引言在古籍的海洋中精准导航\">引言：在古籍的海洋中精准导航</h2>\n<p>作为一款专注于古典文学学习的App，古文观芷需要处理从《诗经》到明清小说的海量古文数据。用户可能搜索一首诗、一位作者、一句名言、一个成语，甚至一段文化常识。如何在这个庞大的知识库中实现毫秒级精准搜索？这是我作为独立开发者面临的核心挑战。</p>\n<p>经过深入分析和技术选型，我摒弃了传统的数据库搜索和云服务方案，自主研发了一套基于内存的搜索系统。这套系统不仅性能卓越，而且成本极低，完美契合个人开发项目的需求。</p>\n<p><img alt=\"微信图片_20260201222357_107_16\" src=\"https://img2024.cnblogs.com/blog/142192/202602/142192-20260201222535633-495477397.jpg\" /></p>\n<p><img alt=\"微信图片_20260201222328_104_16\" src=\"https://img2024.cnblogs.com/blog/142192/202602/142192-20260201222547673-350238474.jpg\" /></p>\n<p><img alt=\"微信图片_20260201222329_105_16\" src=\"https://img2024.cnblogs.com/blog/142192/202602/142192-20260201222554833-891586769.jpg\" /></p>\n<p><img alt=\"微信图片_20260201222330_106_16\" src=\"https://img2024.cnblogs.com/blog/142192/202602/142192-20260201222605157-854075319.jpg\" /></p>\n<h2 id=\"第一章技术选型的深度思考\">第一章：技术选型的深度思考</h2>\n<h3 id=\"11-三种技术路线的对比分析\">1.1 三种技术路线的对比分析</h3>\n<p>在项目初期，我系统评估了三种主流搜索方案：</p>\n<p><strong>方案一：MySQL全文搜索</strong></p>\n<pre><code class=\"language-sql\">-- 简单的实现方式\nSELECT * FROM poems WHERE MATCH(title, content) AGAINST('李白' IN NATURAL LANGUAGE MODE);\n</code></pre>\n<ul>\n<li><strong>优点</strong>：开发简单，无需额外组件</li>\n<li><strong>缺点</strong>：性能差（查询耗时&gt;100ms），分词效果差,不支持搜索多个关键字，无法支持复杂的古文分词需求</li>\n</ul>\n<p><strong>方案二：Elasticsearch</strong></p>\n<ul>\n<li><strong>优点</strong>：功能强大，分布式扩展性好</li>\n<li><strong>缺点</strong>：\n<ul>\n<li>部署复杂，需要单独维护</li>\n<li>内存占用高（基础部署&gt;1GB）</li>\n<li>云服务成本高（每月$50+）</li>\n<li>对古文特殊字符支持不佳</li>\n</ul>\n</li>\n</ul>\n<p><strong>方案三：自研内存搜索</strong></p>\n<ul>\n<li><strong>优势分析</strong>：\n<ul>\n<li>数据量可控：古文总数约50万条，完全可加载到内存</li>\n<li>只读特性：古文数据基本不变，无需实时更新</li>\n<li>性能极致：内存操作比磁盘快1000倍以上</li>\n<li>零成本：仅需服务器内存，无需额外服务</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"12-为什么最终选择自研方案\">1.2 为什么最终选择自研方案？</h3>\n<p><strong>数据特征决定了技术选型</strong>：</p>\n<ol>\n<li><strong>总量有限</strong>：古文作品不会无限增长，50万条是稳定上限</li>\n<li><strong>更新频率极低</strong>：古籍内容不会变更，每月更新&lt;100条，内容更新后重启就行，基本不变，所有数据都是自读，没有并发读写</li>\n<li><strong>搜索维度多</strong>：需要支持标题、作者、内容、注释等多维度搜索，内容也是多个维度：诗文、作者、名句、成语、文化常识、歇后语等；搜索方式多位：文本搜索和拍照搜索</li>\n<li><strong>实时性要求高</strong>：用户期望\"输入即得\"的搜索体验</li>\n</ol>\n<p><strong>成本效益分析</strong>：</p>\n<ul>\n<li>Elasticsearch年成本：$600+，项目还没有收益，能省就省</li>\n<li>自研方案年成本：$0（仅服务器内存）</li>\n<li>性能对比：自研方案平均响应时间&lt;0.1ms，ES平均&gt;50ms</li>\n</ul>\n<h2 id=\"第二章系统架构全景图\">第二章：系统架构全景图</h2>\n<h3 id=\"21-整体架构设计\">2.1 整体架构设计</h3>\n<pre><code>┌─────────────────────────────────────────────────────────────┐\n│                    古文观芷搜索系统架构                         │\n├─────────────────────────────────────────────────────────────┤\n│  应用层                                                      │\n│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐          │\n│  │综合搜索 │ │诗文搜索 │ │作者搜索 │ │成语搜索 │          │\n│  └─────────┘ └─────────┘ └─────────┘ └─────────┘          │\n├─────────────────────────────────────────────────────────────┤\n│  索引层                                                      │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │    倒排索引管理器 (searchMgr)                              │  │\n│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐    │  │\n│  │  │诗文索引 │ │作者索引 │ │名句索引 │ │成语索引 │    │  │\n│  │  │mPoemWord│ │mAuthor- │ │mSentence│ │mIdiom   │    │  │\n│  │  │         │ │  Word   │ │   Word  │ │  Index  │    │  │\n│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘    │  │\n│  │  ┌─────────┐ ┌─────────┐                            │  │\n│  │  │文化常识 │ │歇后语  │                            │  │\n│  │  │mCulture │ │mXhyWord │                            │  │\n│  │  │  Word   │ │         │                            │  │\n│  │  └─────────┘ └─────────┘                            │  │\n│  └──────────────────────────────────────────────────────┘  │\n├─────────────────────────────────────────────────────────────┤\n│  数据层                                                      │\n│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐          │\n│  │诗文数据 │ │作者数据 │ │成语数据 │ │名句数据 │          │\n│  │50,000+  │ │5,000+   │ │30,000+  │ │10,000+  │          │\n│  └─────────┘ └─────────┘ └─────────┘ └─────────┘          │\n│  ┌─────────┐ ┌─────────┐                                  │\n│  │文化常识 │ │歇后语  │                                  │\n│  │3,000+   │ │14,000+   │                                  │\n│  └─────────┘ └─────────┘                                  │\n└─────────────────────────────────────────────────────────────┘\n</code></pre>\n<h3 id=\"22-核心数据结构设计\">2.2 核心数据结构设计</h3>\n<pre><code class=\"language-go\">// searchMgr - 搜索管理器（核心类）\ntype searchMgr struct {\n    // 1. 分词与过滤组件\n    jieba *gojieba.Jieba           // 结巴分词器（高性能C++实现）\n    pin   *pinyin.Pinyin           // 拼音转换器（支持多音字）\n    mFilterWords map[string]bool   // 停用词表（60+个字符）\n    \n    // 2. 六大内容索引（核心倒排索引）\n    mPoemWord     map[string][]uint32  // 诗文索引：15万+词条\n    mAuthorWord   map[string][]uint32  // 作者索引：2万+词条  \n    mSentenceWord map[string][]uint32  // 名句索引：3千+词条\n    mCultureWord  map[string][]uint32  // 文化常识：2千+词条\n    mXhyWord      map[string][]uint32  // 歇后语：1.4万+词条\n    \n    // 3. 缓存与优化\n    searchFileName string          // 索引缓存文件路径\n    hotQueryCache  map[string][]uint32  // 热门查询缓存\n    queryStats     map[string]int       // 查询统计（用于优化）\n    \n    // 4. 数据引用（避免重复存储）\n    poemList     []*pb.EntityXsPoem    // 诗文原始数据（只读引用）\n    authorList   []*pb.EntityXsAuthor  // 作者原始数据\n    // ... 其他数据引用\n}\n</code></pre>\n<h3 id=\"23-内存占用优化策略\">2.3 内存占用优化策略</h3>\n<p><strong>数据规模统计</strong>：</p>\n<ul>\n<li>总数据量：约50万条记录</li>\n<li>原始数据大小：~300MB</li>\n<li>索引数据大小：~100MB</li>\n<li>总内存占用：~400MB（现代服务器完全可接受，服务器2G内存完全够用）</li>\n</ul>\n<p><strong>内存优化技巧</strong>：</p>\n<ol>\n<li><strong>使用uint32存储ID</strong>：最大支持42亿条记录，足够使用且节省空间</li>\n<li><strong>字符串驻留技术</strong>：相同字符串只存储一份</li>\n<li><strong>预分配容量</strong>：避免map动态扩容开销</li>\n<li><strong>压缩存储</strong>：对低频词使用更紧凑的存储格式</li>\n</ol>\n<h2 id=\"第三章索引构建的艺术\">第三章：索引构建的艺术</h2>\n<h3 id=\"31-并行构建充分利用多核cpu\">3.1 并行构建：充分利用多核CPU</h3>\n<pre><code class=\"language-go\">func (sm *searchMgr) initSearch() {\n    // 预分配map容量，避免扩容\n    mPoemWord := make(map[string][]uint32, 154252)   // 根据历史数据预估\n    mAuthorWord := make(map[string][]uint32, 21603)\n    mSentenceWord := make(map[string][]uint32, 3429)\n    mCultureWord := make(map[string][]uint32, 2700)\n    mXhyWord := make(map[string][]uint32, 14032)\n    \n    var wg sync.WaitGroup\n    wg.Add(6)  // 6种内容类型并发构建\n    \n    // 并发构建各种索引（充分利用多核）\n    go sm.buildPoemIndexAsync(&amp;wg, mPoemWord)\n    go sm.buildAuthorIndexAsync(&amp;wg, mAuthorWord)\n    go sm.buildSentenceIndexAsync(&amp;wg, mSentenceWord)\n    go sm.buildCultureIndexAsync(&amp;wg, mCultureWord)\n    go sm.buildXhyIndexAsync(&amp;wg, mXhyWord)\n    go sm.buildIdiomIndexAsync(&amp;wg)  // 成语索引特殊处理\n    \n    wg.Wait()\n    \n    // 合并结果到主索引\n    sm.mPoemWord = mPoemWord\n    sm.mAuthorWord = mAuthorWord\n    // ... 其他索引\n    \n    sm.saveIndexToFile()  // 序列化到文件供下次快速加载\n    runtime.GC()          // 构建完成后立即GC，释放临时内存\n}\n</code></pre>\n<h3 id=\"32-针对古文的分词优化\">3.2 针对古文的分词优化</h3>\n<p>古文与现代汉语分词有很大不同，我实现了多级分词策略：</p>\n<pre><code class=\"language-go\">func (sm *searchMgr) tokenizeForAncientChinese(text string) []string {\n    var tokens []string\n    \n    // 第一级：结巴分词（基础分词）\n    words := sm.jieba.Cut(text, true)\n    tokens = append(tokens, words...)\n    \n    // 第二级：按字符切分（应对分词器遗漏）\n    runes := []rune(text)\n    for i := 0; i &lt; len(runes); i++ {\n        token := string(runes[i])\n        if !sm.isStopWord(token) {\n            tokens = append(tokens, token)\n        }\n        \n        // 对2-4字词语，额外生成所有可能组合\n        for length := 2; length &lt;= 4 &amp;&amp; i+length &lt;= len(runes); length++ {\n            token := string(runes[i:i+length])\n            if sm.isMeaningfulToken(token) {\n                tokens = append(tokens, token)\n            }\n        }\n    }\n    \n    // 第三级：特殊处理（作者名、地名等）\n    tokens = sm.specialTokenize(text, tokens)\n    \n    return removeDuplicates(tokens)\n}\n</code></pre>\n<h3 id=\"33-作者名智能分词\">3.3 作者名智能分词</h3>\n<p>作者名搜索是高频需求，我实现了专门的优化：</p>\n<pre><code class=\"language-go\">func (sm *searchMgr) tokenizeAuthorName(name string) []string {\n    tokens := []string{name}  // 完整名字\n    \n    runes := []rune(name)\n    length := len(runes)\n    \n    // 根据名字长度采用不同策略\n    switch {\n    case length == 3:  // 单字名，如\"操\"（曹操）\n        // 已包含完整名字\n        \n    case length == 6:  // 双字名，如\"李白\"\n        tokens = append(tokens, \n            string(runes[0:3]),  // \"李\"\n            string(runes[3:6]),  // \"白\"\n            name)                // \"李白\"\n            \n    case length == 9:  // 三字名，如\"白居易\"\n        tokens = append(tokens,\n            string(runes[0:3]),   // \"白\"\n            string(runes[3:6]),   // \"居\"\n            string(runes[6:9]),   // \"易\"\n            string(runes[0:6]),   // \"白居\"\n            string(runes[3:9]),   // \"居易\"\n            name)                 // \"白居易\"\n            \n    case length &gt;= 12:  // 多字名或带字、号，如\"欧阳修（永叔）\"\n        // 提取主要部分\n        mainName := sm.extractMainName(name)\n        tokens = append(tokens, mainName)\n        tokens = append(tokens, sm.tokenizeAuthorName(mainName)...)\n    }\n    \n    // 添加拼音支持\n    pinyins := sm.pin.Convert(name)\n    tokens = append(tokens, pinyins...)\n    \n    return removeDuplicates(tokens)\n}\n</code></pre>\n<h3 id=\"34-停用词表的精心设计\">3.4 停用词表的精心设计</h3>\n<p>古文中有大量虚词和常见字需要过滤：</p>\n<pre><code class=\"language-go\">func initStopWords() map[string]bool {\n    stopWords := map[string]bool{\n        // 标点符号类（45个）\n        \"\": true, \" \": true, \"\\t\": true, \"\\n\": true, \"\\r\": true,\n        \"。\": true, \"，\": true, \"！\": true, \"？\": true, \"；\": true,\n        \"：\": true, \"「\": true, \"」\": true, \"『\": true, \"』\": true,\n        \"【\": true, \"】\": true, \"〔\": true, \"〕\": true, \"（\": true,\n        \"）\": true, \"《\": true, \"》\": true, \"〈\": true, \"〉\": true,\n        \"―\": true, \"─\": true, \"－\": true, \"～\": true, \"‧\": true,\n        \"·\": true, \"﹑\": true, \"﹒\": true, \"．\": true, \"、\": true,\n        \"...\": true, \"……\": true, \"——\": true, \"----\": true,\n        \n        // 常见虚词类（20个）\n        \"之\": true, \"乎\": true, \"者\": true, \"也\": true, \"矣\": true,\n        \"焉\": true, \"哉\": true, \"兮\": true, \"耶\": true, \"欤\": true,\n        \"尔\": true, \"然\": true, \"而\": true, \"则\": true, \"乃\": true,\n        \"且\": true, \"若\": true, \"虽\": true, \"因\": true, \"故\": true,\n        \n        // 数词和量词（10个）\n        \"一\": true, \"二\": true, \"三\": true, \"十\": true, \"百\": true,\n        \"千\": true, \"万\": true, \"个\": true, \"首\": true, \"篇\": true,\n        \n        // 其他高频无意义词\n        \"曰\": true, \"云\": true, \"谓\": true, \"对\": true, \"曰\": true,\n    }\n    \n    // 动态调整：根据词频统计自动更新\n    if enableDynamicStopWords {\n        stopWords = mergeDynamicStopWords(stopWords)\n    }\n    \n    return stopWords\n}\n</code></pre>\n<h2 id=\"第四章搜索算法的精妙设计\">第四章：搜索算法的精妙设计</h2>\n<h3 id=\"41-多级搜索策略\">4.1 多级搜索策略</h3>\n<pre><code class=\"language-go\">func (sm *searchMgr) Search(query *SearchQuery) *SearchResult {\n    result := &amp;SearchResult{}\n    \n    // 第1级：精确匹配（最高优先级）\n    if exactMatches := sm.exactSearch(query); len(exactMatches) &gt; 0 {\n        result.ExactMatches = exactMatches\n    }\n    \n    // 第2级：前缀匹配（次优先级）\n    if prefixMatches := sm.prefixSearch(query); len(prefixMatches) &gt; 0 {\n        result.PrefixMatches = prefixMatches\n    }\n    \n    // 第3级：包含匹配（一般优先级）\n    if containMatches := sm.containSearch(query); len(containMatches) &gt; 0 {\n        result.ContainMatches = containMatches\n    }\n    \n    // 第4级：拼音匹配（兜底方案）\n    if len(result.All()) == 0 {\n        if pinyinMatches := sm.pinyinSearch(query); len(pinyinMatches) &gt; 0 {\n            result.PinyinMatches = pinyinMatches\n        }\n    }\n    \n    // 第5级：智能重试（针对长查询）\n    if len(result.All()) == 0 &amp;&amp; len(query.Text) &gt;= 6 {\n        result = sm.smartRetrySearch(query)\n    }\n    \n    return result\n}\n</code></pre>\n<h3 id=\"42-成语搜索的黑科技\">4.2 成语搜索的黑科技</h3>\n<p>成语搜索需要支持任意位置匹配，我实现了特殊的子串索引：</p>\n<pre><code class=\"language-go\">type IdiomIndex struct {\n    index map[string][]uint32          // 子串-&gt;成语ID\n    idioms map[uint32]*IdiomDetail     // ID-&gt;成语详情\n    charIndex map[rune][]uint32        // 单字索引（快速过滤）\n    lengthIndex map[int][]uint32       // 长度索引（按成语长度分组）\n}\n\nfunc (idx *IdiomIndex) BuildIndex(idioms []*IdiomDetail) {\n    for _, idiom := range idioms {\n        id := idiom.ID\n        text := idiom.Text  // 如\"画蛇添足\"\n        \n        // 1. 添加到主索引\n        runes := []rune(text)\n        for i := 0; i &lt; len(runes); i++ {\n            for j := i + 1; j &lt;= len(runes); j++ {\n                substr := string(runes[i:j])\n                idx.index[substr] = append(idx.index[substr], id)\n            }\n        }\n        \n        // 2. 添加到单字索引（用于快速过滤）\n        for _, r := range runes {\n            idx.charIndex[r] = append(idx.charIndex[r], id)\n        }\n        \n        // 3. 按长度分组\n        length := len(runes)\n        idx.lengthIndex[length] = append(idx.lengthIndex[length], id)\n        \n        // 4. 存储详情\n        idx.idioms[id] = idiom\n    }\n    \n    // 优化：对结果去重和排序\n    idx.optimizeIndex()\n}\n</code></pre>\n<h1 id=\"古文观芷成语搜索技术简述\">古文观芷成语搜索技术简述</h1>\n<h2 id=\"核心数据结构全子串倒排索引\">核心数据结构：<strong>全子串倒排索引</strong></h2>\n<pre><code class=\"language-go\">type IdiomIndex struct {\n    // 主索引：所有子串 -&gt; 成语ID列表\n    // 例：\"画蛇添足\"会索引所有子串：\"画\"、\"蛇\"、\"添\"、\"足\"、\"画蛇\"、\"蛇添\"...\n    index map[string][]uint32\n}\n</code></pre>\n<h3 id=\"1-子串全量索引法\">1. <strong>子串全量索引法</strong></h3>\n<ul>\n<li><strong>原理</strong>：为每个成语生成<strong>所有可能的子串组合</strong></li>\n<li><strong>算法复杂度</strong>：O(n²)，但成语最长4字，实际O(16)</li>\n<li><strong>示例</strong>：\"画蛇添足\" → 索引\"画\"、\"蛇\"、\"添\"、\"足\"、\"画蛇\"、\"蛇添\"、\"添足\"、\"画蛇添\"...</li>\n</ul>\n<h3 id=\"2-搜索流程\">2. <strong>搜索流程</strong></h3>\n<pre><code class=\"language-go\">func (idx *IdiomIndex) Search(substr string) []uint32 {\n    // 直接map查找：O(1)时间复杂度\n    return idx.index[substr]  // 如输入\"画蛇\" → 返回包含\"画蛇\"的所有成语ID\n}\n</code></pre>\n<h3 id=\"3-内存优化\">3. <strong>内存优化</strong></h3>\n<ul>\n<li>使用<code>uint32</code>存储ID（支持42亿条，足够）</li>\n<li>预分配容量，避免动态扩容</li>\n<li>结果去重，避免重复成语</li>\n</ul>\n<h2 id=\"优势特点\">优势特点：</h2>\n<ol>\n<li><strong>极速响应</strong>：直接内存map查找，&lt;0.01ms</li>\n<li><strong>全面匹配</strong>：支持任意位置、任意长度子串</li>\n<li><strong>简单可靠</strong>：无复杂算法，代码简洁</li>\n<li><strong>零外部依赖</strong>：纯Go实现，部署简单</li>\n</ol>\n<h2 id=\"性能数据\">性能数据：</h2>\n<ul>\n<li>3万成语 → 约50万索引项</li>\n<li>内存占用：~50MB</li>\n<li>搜索速度：&lt;0.1ms/次</li>\n<li>并发能力：单机10000+ QPS</li>\n</ul>\n<p>这就是为什么用户输入\"画蛇\"能秒级找到\"画蛇添足\"的技术原理。</p>\n<h3 id=\"43-ocr识别搜索优化\">4.3 OCR识别搜索优化</h3>\n<p>用户拍照识别古诗时，往往有识别错误，我设计了容错算法：</p>\n<pre><code class=\"language-go\">func (sm *searchMgr) SearchByOCR(ocrText string, maxDistance int) []*PoemResult {\n    // 1. 分词\n    words := sm.jieba.Cut(ocrText, true)\n    \n    // 2. 统计每首诗被命中的次数\n    poemHitCount := make(map[uint32]int)\n    meaningfulWords := make([]string, 0)\n    \n    for _, word := range words {\n        if len([]rune(word)) &lt;= 1 || sm.isStopWord(word) {\n            continue  // 过滤短词和停用词\n        }\n        \n        meaningfulWords = append(meaningfulWords, word)\n        \n        // 查找包含这个词的诗文\n        if poemIDs, exists := sm.mPoemWord[word]; exists {\n            for _, id := range poemIDs {\n                poemHitCount[id]++\n            }\n        }\n        \n        // 模糊匹配：允许1-2个字的编辑距离\n        if maxDistance &gt; 0 {\n            fuzzyMatches := sm.fuzzyMatch(word, maxDistance)\n            for _, id := range fuzzyMatches {\n                poemHitCount[id]++\n            }\n        }\n    }\n    \n    // 3. 计算权重分数\n    type ScoredPoem struct {\n        ID    uint32\n        Score float64\n    }\n    \n    scoredPoems := make([]ScoredPoem, 0, len(poemHitCount))\n    for poemID, hitCount := range poemHitCount {\n        poem := sm.getPoemByID(poemID)\n        if poem == nil {\n            continue\n        }\n        \n        // 分数 = 命中次数 * 权重系数\n        score := float64(hitCount)\n        \n        // 增加长词的权重\n        for _, word := range meaningfulWords {\n            if len([]rune(word)) &gt;= 3 &amp;&amp; containsPoemText(poem, word) {\n                score += 0.5\n            }\n        }\n        \n        // 考虑诗句位置权重（标题权重高于内容）\n        if containsPoemTitle(poem, meaningfulWords) {\n            score *= 1.5\n        }\n        \n        scoredPoems = append(scoredPoems, ScoredPoem{poemID, score})\n    }\n    \n    // 4. 排序并返回Top N\n    sort.Slice(scoredPoems, func(i, j int) bool {\n        return scoredPoems[i].Score &gt; scoredPoems[j].Score\n    })\n    \n    return sm.buildResults(scoredPoems[:min(10, len(scoredPoems))])\n}\n</code></pre>\n<h3 id=\"44-搜索结果排序算法\">4.4 搜索结果排序算法</h3>\n<pre><code class=\"language-go\">func (sm *searchMgr) rankResults(results []*SearchItem, query string) []*SearchItem {\n    type ScoredItem struct {\n        Item  *SearchItem\n        Score float64\n    }\n    \n    scoredItems := make([]ScoredItem, len(results))\n    queryRunes := []rune(query)\n    \n    for i, item := range results {\n        score := 0.0\n        \n        // 1. 完全匹配得分（最高）\n        if item.Text == query {\n            score += 1000\n        }\n        \n        // 2. 开头匹配得分（次高）\n        if strings.HasPrefix(item.Text, query) {\n            score += 500\n        }\n        \n        // 3. 长度相似性得分\n        itemRunes := []rune(item.Text)\n        lengthDiff := abs(len(itemRunes) - len(queryRunes))\n        score += 50 / (float64(lengthDiff) + 1)\n        \n        // 4. 词频权重（TF-IDF简化版）\n        wordFrequency := sm.calculateWordFrequency(item, query)\n        score += wordFrequency * 10\n        \n        // 5. 热度权重（热门内容优先）\n        if item.ViewCount &gt; 1000 {\n            score += math.Log10(float64(item.ViewCount))\n        }\n        \n        // 6. 时间权重（新内容适当提升）\n        if item.CreateTime &gt; time.Now().Add(-30*24*time.Hour).Unix() {\n            score += 10\n        }\n        \n        scoredItems[i] = ScoredItem{item, score}\n    }\n    \n    // 排序\n    sort.Slice(scoredItems, func(i, j int) bool {\n        return scoredItems[i].Score &gt; scoredItems[j].Score\n    })\n    \n    // 返回排序后的结果\n    rankedItems := make([]*SearchItem, len(scoredItems))\n    for i, scored := range scoredItems {\n        rankedItems[i] = scored.Item\n    }\n    \n    return rankedItems\n}\n</code></pre>\n<h2 id=\"第五章性能优化深度剖析\">第五章：性能优化深度剖析</h2>\n<h3 id=\"51-并发安全与性能平衡\">5.1 并发安全与性能平衡</h3>\n<p><strong>只读架构的优势</strong>：</p>\n<pre><code class=\"language-go\">// 所有索引数据只读，无需锁保护\nvar SearchMgr = &amp;searchMgr{\n    mPoemWord:     make(map[string][]uint32),  // 启动时初始化，之后只读\n    mAuthorWord:   make(map[string][]uint32),\n    // ... 其他索引\n}\n\n// 搜索函数是纯函数，线程安全\nfunc (sm *searchMgr) searchPoem(keyword string) []*PoemResult {\n    // 直接读取，无锁开销\n    poemIDs := sm.mPoemWord[keyword]  // O(1)时间复杂度\n    \n    results := make([]*PoemResult, 0, len(poemIDs))\n    for _, id := range poemIDs {\n        poem := sm.poemList[id]  // 数组直接索引，O(1)\n        if poem != nil {\n            results = append(results, convertToResult(poem))\n        }\n    }\n    \n    return results\n}\n</code></pre>\n<h3 id=\"52-内存优化实战\">5.2 内存优化实战</h3>\n<p><strong>优化前</strong>：每个索引项都存储完整字符串<br />\n<strong>优化后</strong>：使用字符串驻留和整数ID</p>\n<pre><code class=\"language-go\">// 字符串驻留池\ntype StringPool struct {\n    strings map[string]string  // 原始-&gt;规范映射\n    ids     map[string]uint32  // 字符串-&gt;ID映射\n    values  []string           // ID-&gt;字符串反向映射\n}\n\nfunc (sp *StringPool) Intern(s string) uint32 {\n    if id, exists := sp.ids[s]; exists {\n        return id\n    }\n    \n    // 新字符串，分配ID\n    id := uint32(len(sp.values))\n    sp.values = append(sp.values, s)\n    sp.ids[s] = id\n    sp.strings[s] = s\n    \n    return id\n}\n\n// 使用字符串池优化后的索引\ntype OptimizedIndex struct {\n    pool   *StringPool\n    index  map[uint32][]uint32  // 字符串ID-&gt;内容ID列表\n}\n\nfunc (oi *OptimizedIndex) Search(s string) []uint32 {\n    strID := oi.pool.Intern(s)\n    return oi.index[strID]\n}\n</code></pre>\n<h3 id=\"53-缓存策略的多层设计\">5.3 缓存策略的多层设计</h3>\n<pre><code class=\"language-go\">type SearchCache struct {\n    // L1缓存：热点查询结果（内存）\n    l1Cache *lru.Cache  // 最近最少使用，容量1000\n    \n    // L2缓存：高频词索引（内存）\n    l2HotWords map[string][]uint32\n    \n    // L3缓存：持久化索引（文件）\n    indexPath string\n    \n    // 查询统计\n    stats struct {\n        totalQueries int64\n        l1Hits       int64\n        l2Hits       int64\n        l3Hits       int64\n    }\n}\n\nfunc (sc *SearchCache) Get(query string) ([]uint32, bool) {\n    sc.stats.totalQueries++\n    \n    // 1. 检查L1缓存\n    if result, ok := sc.l1Cache.Get(query); ok {\n        sc.stats.l1Hits++\n        return result.([]uint32), true\n    }\n    \n    // 2. 检查L2缓存（高频词）\n    if result, ok := sc.l2HotWords[query]; ok {\n        sc.stats.l2Hits++\n        // 同时放入L1缓存\n        sc.l1Cache.Add(query, result)\n        return result, true\n    }\n    \n    // 3. 从L3（主索引）加载\n    if result := sc.loadFromIndex(query); result != nil {\n        sc.stats.l3Hits++\n        // 放入L1和L2缓存\n        sc.l1Cache.Add(query, result)\n        if sc.isHotWord(query) {\n            sc.l2HotWords[query] = result\n        }\n        return result, true\n    }\n    \n    return nil, false\n}\n</code></pre>\n<h3 id=\"54-性能监控与调优\">5.4 性能监控与调优</h3>\n<pre><code class=\"language-go\">type PerformanceMonitor struct {\n    metrics struct {\n        searchLatency    prometheus.Histogram\n        cacheHitRate     prometheus.Gauge\n        memoryUsage      prometheus.Gauge\n        queryPerSecond   prometheus.Counter\n    }\n    \n    history struct {\n        dailyStats map[string]*DailyStat\n        slowQueries []*SlowQueryLog\n    }\n}\n\nfunc (pm *PerformanceMonitor) RecordSearch(query string, latency time.Duration, hitCache bool) {\n    // 记录延迟\n    pm.metrics.searchLatency.Observe(latency.Seconds() * 1000)  // 转换为毫秒\n    \n    // 记录QPS\n    pm.metrics.queryPerSecond.Inc()\n    \n    // 记录慢查询\n    if latency &gt; 50*time.Millisecond {\n        pm.history.slowQueries = append(pm.history.slowQueries, &amp;SlowQueryLog{\n            Query:    query,\n            Latency:  latency,\n            Timestamp: time.Now(),\n        })\n        \n        // 保留最近1000条慢查询\n        if len(pm.history.slowQueries) &gt; 1000 {\n            pm.history.slowQueries = pm.history.slowQueries[1:]\n        }\n    }\n    \n    // 更新缓存命中率\n    if hitCache {\n        // 计算并更新命中率\n        pm.updateCacheHitRate()\n    }\n}\n</code></pre>\n<h2 id=\"第六章实际效果与性能数据\">第六章：实际效果与性能数据</h2>\n<h3 id=\"61-性能基准测试\">6.1 性能基准测试</h3>\n<p><strong>测试环境</strong>：</p>\n<ul>\n<li>CPU: 4核 Intel Xeon 2.5GHz</li>\n<li>内存: 8GB</li>\n<li>Go版本: 1.19</li>\n<li>数据量: 50万条古文记录</li>\n</ul>\n<p><strong>性能数据</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>数值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>索引构建时间</td>\n<td>3.5秒</td>\n<td>首次构建（并行优化）</td>\n</tr>\n<tr>\n<td>索引加载时间</td>\n<td>0.8秒</td>\n<td>从文件加载（后续启动）</td>\n</tr>\n<tr>\n<td>平均搜索延迟</td>\n<td>3.2毫秒</td>\n<td>50万条数据中搜索</td>\n</tr>\n<tr>\n<td>P99延迟</td>\n<td>9.8毫秒</td>\n<td>99%请求低于此值</td>\n</tr>\n<tr>\n<td>内存占用</td>\n<td>400MB</td>\n<td>包含所有数据和索引</td>\n</tr>\n<tr>\n<td>并发QPS</td>\n<td>15,000+</td>\n<td>4核CPU测试结果</td>\n</tr>\n<tr>\n<td>缓存命中率</td>\n<td>99%+</td>\n<td>热点查询优化后</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"62-与竞品对比\">6.2 与竞品对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>古文观芷（自研）</th>\n<th>某竞品（Elasticsearch）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>搜索响应时间</td>\n<td>3.2ms</td>\n<td>45ms</td>\n</tr>\n<tr>\n<td>冷启动时间</td>\n<td>0.8s</td>\n<td>3.5s</td>\n</tr>\n<tr>\n<td>内存占用</td>\n<td>400MB</td>\n<td>2.5GB+</td>\n</tr>\n<tr>\n<td>部署复杂度</td>\n<td>单二进制文件</td>\n<td>需要ES集群</td>\n</tr>\n<tr>\n<td>运维成本</td>\n<td>接近零</td>\n<td>需要专业运维</td>\n</tr>\n<tr>\n<td>年费用</td>\n<td>$0（仅服务器）</td>\n<td>$600+（云服务）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"63-用户反馈数据\">6.3 用户反馈数据</h3>\n<ul>\n<li><strong>搜索成功率</strong>：98.7%（包含模糊匹配）</li>\n<li><strong>用户满意度</strong>：4.8/5.0（基于应用商店评价）</li>\n<li><strong>日活跃用户</strong>：50,000+</li>\n<li><strong>日均搜索量</strong>：1,200,000+次</li>\n<li><strong>峰值QPS</strong>：8,000+（考试季期间）</li>\n</ul>\n<h2 id=\"第七章技术方案的普适性与扩展性\">第七章：技术方案的普适性与扩展性</h2>\n<h3 id=\"71-适用场景总结\">7.1 适用场景总结</h3>\n<p>这种自研内存搜索方案特别适合：</p>\n<ol>\n<li><strong>数据量有限</strong>：百万级以下数据量</li>\n<li><strong>更新频率低</strong>：日更新&lt;1%的数据</li>\n<li><strong>性能要求高</strong>：需要毫秒级响应</li>\n<li><strong>成本敏感</strong>：个人或小团队项目</li>\n<li><strong>特定领域</strong>：需要深度定制分词和搜索逻辑</li>\n</ol>\n<h3 id=\"72-可扩展性设计\">7.2 可扩展性设计</h3>\n<p>虽然当前设计是单机方案，但可以扩展为分布式，每台机器都是全量加载数据，全量索引</p>\n<h3 id=\"73-未来优化方向\">7.3 未来优化方向</h3>\n<ol>\n<li><strong>向量搜索集成</strong>：结合BERT等模型实现语义搜索</li>\n<li><strong>个性化推荐</strong>：基于用户历史优化搜索排序</li>\n<li><strong>实时索引更新</strong>：支持增量更新而不重建全量索引</li>\n<li><strong>多语言支持</strong>：扩展支持古文注释的现代汉语翻译</li>\n<li><strong>语音搜索</strong>：集成语音识别，支持语音输入搜索</li>\n</ol>\n<h2 id=\"第八章总结与启示\">第八章：总结与启示</h2>\n<p>古文观芷的搜索方案是一个典型的技术务实主义案例。通过深入分析需求特点，我选择了一条不同于主流但极其有效的技术路线。这个方案证明了：</p>\n<ol>\n<li><strong>简单即有效</strong>：最直接的数据结构（map+slice）往往能提供最佳性能</li>\n<li><strong>定制化优势</strong>：针对特定领域深度优化的效果超过通用方案</li>\n<li><strong>成本意识</strong>：个人开发者需要精打细算，选择性价比最高的方案</li>\n<li><strong>性能为王</strong>：用户体验的核心是响应速度，技术应为体验服务</li>\n</ol>\n<p>这套方案已经稳定运行两年多，服务了数百万用户，证明了其可靠性和优越性。对于面临类似场景的开发者，我建议：</p>\n<ul>\n<li><strong>深入分析需求</strong>：不要盲目选择技术，先理解数据特点和用户需求</li>\n<li><strong>勇于自研</strong>：当现有方案不够匹配时，自己动手可能是最好的选择</li>\n<li><strong>持续优化</strong>：从实际使用数据中学习，不断改进算法和实现</li>\n<li><strong>保持简洁</strong>：最简单的解决方案往往最可靠、最易维护</li>\n</ul>\n<p>技术方案没有绝对的好坏，只有适合与否。古文观芷的搜索方案，正是\"适合的才是最好的\"这一理念的完美体现。</p>\n<p><a href=\"https://www.cnblogs.com/hlxs/p/19413138\" target=\"_blank\">古文观芷-拍照搜古文功能：比竞品快10000倍</a></p>\n<p><strong>十几年的园友，下载体验一下吧，应用市场搜索：古文观芷</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-01 22:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hlxs\">古文观芷</a>&nbsp;\n阅读(<span id=\"post_view_count\">19</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Debian 13基于kubeadm和containerd部署单节点kubernetes",
      "link": "https://www.cnblogs.com/XY-Heruo/p/19560948",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/XY-Heruo/p/19560948\" id=\"cb_post_title_url\" title=\"发布于 2026-02-01 16:03\">\n    <span>Debian 13基于kubeadm和containerd部署单节点kubernetes</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在本地虚拟机环境中使用 kubeadm+containerd+harbor+cilium 搭建 Kubernetes 集群\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>在本地虚拟机环境中使用 kubeadm 搭建 Kubernetes 集群是学习和实验的理想选择。考虑到实际应用场景中可能存在的网络限制以及镜像构建需求，本文详细记录了在完全离线环境下部署单节点 Kubernetes 集群的完整过程。通过集成 Harbor 私有镜像仓库，所有 Kubernetes 组件镜像均从本地 Harbor 实例拉取，确保部署过程的可靠性和可重复性。</p>\n<p>本指南适用于希望在受限网络环境中快速搭建 Kubernetes 实验环境的技术人员，涵盖了从系统初始化到 Cilium 网络插件配置的全流程。</p>\n<h2 id=\"环境和版本信息\">环境和版本信息</h2>\n<h3 id=\"基础环境配置\">基础环境配置</h3>\n<ul>\n<li><strong>操作系统</strong>：Debian 13 (代号 \"Trixie\")</li>\n<li><strong>硬件规格</strong>：4 核 CPU / 4GB 内存 / 40GB 存储空间</li>\n<li><strong>网络拓扑</strong>：单节点部署（Control Plane + Worker 合一）</li>\n</ul>\n<h3 id=\"软件版本清单\">软件版本清单</h3>\n<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>版本</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Kubernetes</td>\n<td>v1.33.7</td>\n<td>容器编排平台</td>\n</tr>\n<tr>\n<td>containerd</td>\n<td>2.2.1</td>\n<td>容器运行时</td>\n</tr>\n<tr>\n<td>runc</td>\n<td>1.4.0</td>\n<td>OCI 运行时规范实现</td>\n</tr>\n<tr>\n<td>CNI Plugins</td>\n<td>1.9.0</td>\n<td>容器网络接口插件</td>\n</tr>\n<tr>\n<td>Harbor</td>\n<td>v2.14.2</td>\n<td>企业级容器镜像仓库</td>\n</tr>\n<tr>\n<td>Cilium</td>\n<td>v1.18.6</td>\n<td>eBPF 驱动的网络和安全解决方案</td>\n</tr>\n<tr>\n<td>Helm</td>\n<td>3.19.5</td>\n<td>Kubernetes 包管理器</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"网络规划\">网络规划</h3>\n<table>\n<thead>\n<tr>\n<th>IP 地址</th>\n<th>主机名</th>\n<th>角色</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>192.168.0.22</td>\n<td>deb13-k8s-node1</td>\n<td>Kubernetes 节点</td>\n</tr>\n<tr>\n<td>192.168.0.42</td>\n<td>deb13-harbor</td>\n<td>Harbor 镜像仓库</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>注意</strong>：本文档假设两台主机位于同一内网环境中，且网络连通性已验证。</p>\n</blockquote>\n<h2 id=\"系统初始化\">系统初始化</h2>\n<p>在开始 Kubernetes 组件安装之前，需要对系统进行必要的初始化配置，以满足 Kubernetes 的运行要求。</p>\n<h3 id=\"1-安装-ipvs-相关工具包\">1. 安装 IPVS 相关工具包</h3>\n<p>IPVS（IP Virtual Server）是 Linux 内核的负载均衡实现，Kubernetes 在 IPVS 模式下运行 kube-proxy 时需要相关工具支持。</p>\n<pre><code class=\"language-bash\"># 仅在 Kubernetes 节点执行\nsudo apt update\nsudo apt install -y ipvsadm ipset\n</code></pre>\n<h3 id=\"2-配置主机名\">2. 配置主机名</h3>\n<p>为便于管理和识别，建议为每台主机设置有意义的主机名。</p>\n<pre><code class=\"language-bash\"># Harbor 服务器\nhostnamectl set-hostname deb13-harbor\n\n# Kubernetes 节点\nhostnamectl set-hostname deb13-k8s-node1\n</code></pre>\n<h3 id=\"3-配置本地-dns-解析\">3. 配置本地 DNS 解析</h3>\n<p>编辑 <code>/etc/hosts</code> 文件，添加主机名与 IP 地址的映射关系：</p>\n<pre><code class=\"language-bash\">cat &gt;&gt; /etc/hosts &lt;&lt; EOF\n192.168.0.22 deb13-k8s-node1\n192.168.0.42 deb13-harbor\nEOF\n</code></pre>\n<h3 id=\"4-加载必要的内核模块\">4. 加载必要的内核模块</h3>\n<p>Kubernetes 依赖特定的内核模块来支持容器网络功能。创建模块加载配置并立即生效：</p>\n<pre><code class=\"language-bash\"># 创建模块加载配置文件\ncat &lt;&lt; EOF &gt; /etc/modules-load.d/containerd.conf\noverlay\nbr_netfilter\nEOF\n\n# 立即加载模块\nsudo modprobe overlay\nsudo modprobe br_netfilter\n\n# 验证模块加载状态\nlsmod | grep -E \"(overlay|br_netfilter)\"\n</code></pre>\n<h3 id=\"5-配置系统内核参数\">5. 配置系统内核参数</h3>\n<p>调整内核参数以优化容器运行环境：</p>\n<pre><code class=\"language-bash\">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF\nnet.ipv4.ip_forward=1\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nvm.swappiness = 0\nEOF\n\n# 应用配置\nsudo sysctl --system\n</code></pre>\n<blockquote>\n<p><strong>重要提示</strong>：如果系统启用了 swap 分区，必须在 Kubernetes 启动前将其关闭，否则 kubelet 将无法正常启动。可通过以下命令临时关闭：</p>\n</blockquote>\n<pre><code class=\"language-bash\">sudo swapoff -a\n# 永久关闭需注释 /etc/fstab 中的 swap 相关行\n</code></pre>\n<h2 id=\"harbor-私有镜像仓库部署\">Harbor 私有镜像仓库部署</h2>\n<p>Harbor 作为企业级容器镜像仓库，为离线环境下的 Kubernetes 部署提供了可靠的镜像分发能力。</p>\n<h3 id=\"1-准备-harbor-安装包\">1. 准备 Harbor 安装包</h3>\n<p>从 <a href=\"https://github.com/goharbor/harbor/releases\" rel=\"noopener nofollow\" target=\"_blank\">Harbor GitHub Releases</a> 页面下载离线安装包（约 600MB）。安装 Harbor 前需确保 Docker 和 Docker Compose 已正确安装。</p>\n<h3 id=\"2-生成自签名-tls-证书\">2. 生成自签名 TLS 证书</h3>\n<p>由于 Harbor 强制要求 HTTPS 连接，我们需要为 Harbor 服务器生成自签名证书。创建证书生成脚本：</p>\n<pre><code class=\"language-bash\"># 创建证书目录\nmkdir -p ~/apps/harbor/certs\ncd ~/apps/harbor/certs\n\n# 创建证书生成脚本\ncat &gt; gen-harbor-crt.sh &lt;&lt; 'EOF'\n#!/bin/bash\n\n# --- 配置参数 ---\nDOMAIN=\"deb13-harbor\"       # Harbor 域名\nIP=\"192.168.0.42\"           # Harbor 服务器内网 IP\nDAYS=3650                   # 有效期 10 年\n\n# 1. 生成私钥 (无密码)\nopenssl genrsa -out harbor.key 2048\n\n# 2. 创建 OpenSSL 配置文件以包含 SAN\ncat &gt; harbor.conf &lt;&lt; CONF_EOF\n[req]\ndistinguished_name = req_distinguished_name\nx509_extensions = v3_req\nprompt = no\n\n[req_distinguished_name]\nCN = ${DOMAIN}\n\n[v3_req]\nkeyUsage = critical, digitalSignature, keyEncipherment\nextendedKeyUsage = serverAuth\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = ${DOMAIN}\nIP.1 = ${IP}\nCONF_EOF\n\n# 3. 生成自签名证书\nopenssl req -x509 -nodes -days ${DAYS} -key harbor.key -out harbor.crt -config harbor.conf -extensions v3_req\n\n# 4. 验证证书（查看是否有 Subject Alternative Name 字段）\necho \"--------------------------------------------------\"\necho \"证书信息验证：\"\nopenssl x509 -in harbor.crt -text -noout | grep -A 1 \"Subject Alternative Name\"\n\necho \"--------------------------------------------------\"\necho \"生成成功！\"\necho \"服务端使用: harbor.crt, harbor.key\"\necho \"客户端 (K8s 节点) 使用: harbor.crt\"\nEOF\n\n# 执行证书生成\nchmod +x gen-harbor-crt.sh\n./gen-harbor-crt.sh\n</code></pre>\n<h3 id=\"3-配置-harbor\">3. 配置 Harbor</h3>\n<p>从模板文件复制并修改 Harbor 配置：</p>\n<pre><code class=\"language-bash\"># 复制配置模板\ncp harbor.yml.tmpl harbor.yml\n\n# 修改关键配置项\n</code></pre>\n<p>主要配置项如下：</p>\n<pre><code class=\"language-yaml\"># Harbor 访问地址\nhostname: 192.168.0.42\n\n# HTTPS 配置\nhttps:\n  port: 443\n  certificate: /home/rainux/apps/harbor/certs/harbor.crt\n  private_key: /home/rainux/apps/harbor/certs/harbor.key\n\n# 管理员密码（请设置强密码）\nharbor_admin_password: your-harbor-password\n\n# 数据库密码\ndatabase:\n  password: your-db-password\n\n# 数据存储路径\ndata_volume: /home/rainux/apps/harbor/data\n\n# 日志配置\nlog:\n  location: /home/rainux/apps/harbor/logs\n\n# 启用指标监控\nmetric:\n  enabled: true\n  port: 9090\n  path: /metrics\n</code></pre>\n<h3 id=\"4-启动-harbor-服务\">4. 启动 Harbor 服务</h3>\n<pre><code class=\"language-bash\">cd ~/apps/harbor\nsudo ./install.sh\n</code></pre>\n<h3 id=\"5-初始化-harbor-项目\">5. 初始化 Harbor 项目</h3>\n<p>通过 Web 界面访问 Harbor（<a href=\"https://192.168.0.42\" rel=\"noopener nofollow\" target=\"_blank\">https://192.168.0.42</a>），使用配置的管理员密码登录后，创建以下两个公开项目：</p>\n<ul>\n<li><code>google_containers</code>：用于存储 Kubernetes 核心组件镜像</li>\n<li><code>cilium</code>：用于存储 Cilium 网络插件相关镜像</li>\n</ul>\n<blockquote>\n<p><strong>配置更新说明</strong>：如需修改 Harbor 配置，可执行以下命令使配置生效：</p>\n<pre><code class=\"language-bash\">sudo ./prepare\ndocker-compose down -v\nsudo docker-compose up -d\n</code></pre>\n</blockquote>\n<h2 id=\"containerd-容器运行时配置\">Containerd 容器运行时配置</h2>\n<p>Containerd 作为轻量级容器运行时，是 Kubernetes 推荐的运行时选项之一。</p>\n<h3 id=\"1-下载必要组件\">1. 下载必要组件</h3>\n<p>从官方 GitHub 仓库下载以下组件：</p>\n<ul>\n<li><a href=\"https://github.com/containerd/containerd/releases\" rel=\"noopener nofollow\" target=\"_blank\">containerd</a></li>\n<li><a href=\"https://github.com/opencontainers/runc/releases\" rel=\"noopener nofollow\" target=\"_blank\">runc</a></li>\n<li><a href=\"https://github.com/containernetworking/plugins/releases\" rel=\"noopener nofollow\" target=\"_blank\">CNI Plugins</a></li>\n</ul>\n<h3 id=\"2-安装-runc\">2. 安装 runc</h3>\n<pre><code class=\"language-bash\"># 注意：原文中的文件名可能存在笔误，应为 runc.amd64\nchmod +x runc.amd64\nsudo mv runc.amd64 /usr/local/bin/runc\n</code></pre>\n<h3 id=\"3-安装-cni-插件\">3. 安装 CNI 插件</h3>\n<pre><code class=\"language-bash\">sudo mkdir -p /opt/cni/bin/\nsudo tar xf cni-plugins-linux-amd64-v1.9.0.tgz -C /opt/cni/bin/\n</code></pre>\n<h3 id=\"4-安装-containerd\">4. 安装 containerd</h3>\n<pre><code class=\"language-bash\">sudo tar xf containerd-2.2.1-linux-amd64.tar.gz\nsudo mv bin/* /usr/local/bin/\n</code></pre>\n<h3 id=\"5-配置-containerd\">5. 配置 containerd</h3>\n<p>生成默认配置并进行必要的修改：</p>\n<pre><code class=\"language-bash\"># 创建 Harbor 证书目录\nsudo mkdir -p /etc/containerd/certs.d/192.168.0.42/\n\n# 生成默认配置\nsudo containerd config default &gt; /etc/containerd/config.toml\n\n# 复制 Harbor 证书\nsudo cp ~/apps/harbor/certs/harbor.crt /etc/containerd/certs.d/192.168.0.42/ca.crt\n</code></pre>\n<p>关键配置修改：</p>\n<pre><code class=\"language-toml\"># 设置 Pod 沙箱镜像源\n[plugins.'io.containerd.cri.v1.images'.pinned_images]\n  sandbox = '192.168.0.42/google_containers/pause:3.10'\n\n# 配置私有镜像仓库\n[plugins.'io.containerd.cri.v1.images'.registry]\n  config_path = '/etc/containerd/certs.d'\n\n# 启用 systemd cgroup 驱动\n[plugins.'io.containerd.cri.v1.runtime'.containerd.runtimes.runc.options]\n  SystemdCgroup = true\n</code></pre>\n<h3 id=\"6-配置-systemd-服务\">6. 配置 systemd 服务</h3>\n<p>从 <a href=\"https://raw.githubusercontent.com/containerd/containerd/main/containerd.service\" rel=\"noopener nofollow\" target=\"_blank\">官方仓库</a> 获取 service 文件：</p>\n<pre><code class=\"language-bash\">sudo curl -o /usr/lib/systemd/system/containerd.service https://raw.githubusercontent.com/containerd/containerd/main/containerd.service\n</code></pre>\n<h3 id=\"7-启动-containerd-服务\">7. 启动 containerd 服务</h3>\n<pre><code class=\"language-bash\">sudo systemctl daemon-reload\nsudo systemctl enable --now containerd\n</code></pre>\n<h2 id=\"kubernetes-组件部署\">Kubernetes 组件部署</h2>\n<h3 id=\"1-安装-kubernetes-二进制文件\">1. 安装 Kubernetes 二进制文件</h3>\n<p>从 <a href=\"https://github.com/kubernetes/kubernetes/releases\" rel=\"noopener nofollow\" target=\"_blank\">Kubernetes GitHub Releases</a> 下载 <code>kubernetes-server-linux-amd64.tar.gz</code>，提取核心组件：</p>\n<pre><code class=\"language-bash\"># 解压并安装核心组件\ntar xf kubernetes-server-linux-amd64.tar.gz\nsudo cp kubernetes/server/bin/{kubeadm,kubelet,kubectl} /usr/local/bin/\n\n# 验证所需镜像列表\nkubeadm config images list --kubernetes-version v1.33.7\n</code></pre>\n<p>将列出的所有镜像（包括 pause、coredns、etcd 等）从官方源拉取后重新打标签并推送到 Harbor 的 <code>google_containers</code> 项目中。</p>\n<h3 id=\"2-配置-kubelet-systemd-服务\">2. 配置 kubelet systemd 服务</h3>\n<p>创建主服务文件 <code>/usr/lib/systemd/system/kubelet.service</code>：</p>\n<pre><code class=\"language-ini\">[Unit]\nDescription=kubelet: The Kubernetes Node Agent\nDocumentation=https://kubernetes.io/docs/\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nExecStart=/usr/local/bin/kubelet\nRestart=always\nStartLimitInterval=0\nRestartSec=10\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>\n<h3 id=\"3-创建-kubeadm-配置目录\">3. 创建 kubeadm 配置目录</h3>\n<pre><code class=\"language-bash\">sudo mkdir -p /usr/lib/systemd/system/kubelet.service.d/\n</code></pre>\n<h3 id=\"4-配置-kubeadm-drop-in-文件\">4. 配置 kubeadm drop-in 文件</h3>\n<p>创建 <code>/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</code>：</p>\n<pre><code class=\"language-ini\"># Note: This dropin only works with kubeadm and kubelet v1.11+\n[Service]\nEnvironment=\"KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf\"\nEnvironment=\"KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml\"\n# This is a file that \"kubeadm init\" and \"kubeadm join\" generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically\nEnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env\n# This is a file that the user can use for overrides of the kubelet args as a last resort. Preferably, the user should use\n# the .NodeRegistration.KubeletExtraArgs object in the configuration files instead. KUBELET_EXTRA_ARGS should be sourced from this file.\nEnvironmentFile=-/etc/sysconfig/kubelet\nExecStart=\nExecStart=/usr/local/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS\n</code></pre>\n<h3 id=\"5-启动-kubelet-服务\">5. 启动 kubelet 服务</h3>\n<pre><code class=\"language-bash\">sudo systemctl daemon-reload\nsudo systemctl enable --now kubelet\n</code></pre>\n<h2 id=\"集群初始化\">集群初始化</h2>\n<h3 id=\"1-创建-kubeadm-配置文件\">1. 创建 kubeadm 配置文件</h3>\n<p>创建 <code>kubeadm-config.yaml</code> 配置文件：</p>\n<pre><code class=\"language-yaml\">apiVersion: kubeadm.k8s.io/v1beta4\nkind: ClusterConfiguration\nkubernetesVersion: v1.33.7\nimageRepository: 192.168.0.42/google_containers  # 指向本地 Harbor 仓库\nnetworking:\n  podSubnet: \"10.10.0.0/16\"   # Cilium 默认 Pod 网段\n  serviceSubnet: \"10.96.0.0/12\"\n---\napiVersion: kubelet.config.k8s.io/v1beta1\nkind: KubeletConfiguration\ncgroupDriver: systemd\nimageGCHighThresholdPercent: 70   # 磁盘使用率超过 70% 时开始清理镜像\nimageGCLowThresholdPercent: 60    # 清理至磁盘使用率 60% 时停止\n---\napiVersion: kubeproxy.config.k8s.io/v1alpha1\nkind: KubeProxyConfiguration\nmode: \"ipvs\"  # 虽然后续会使用 Cilium 替代 kube-proxy，但初始化阶段仍需配置\n</code></pre>\n<h3 id=\"2-执行集群初始化\">2. 执行集群初始化</h3>\n<pre><code class=\"language-bash\">sudo kubeadm init --config kubeadm-config.yaml --ignore-preflight-errors=ImagePull\n</code></pre>\n<h3 id=\"3-清理-kube-proxy使用-cilium-替代\">3. 清理 kube-proxy（使用 Cilium 替代）</h3>\n<p>由于我们将使用 Cilium 作为网络解决方案，可以移除 kube-proxy：</p>\n<pre><code class=\"language-bash\"># 删除 kube-proxy DaemonSet\nkubectl delete ds kube-proxy -n kube-system\n\n# 在所有节点清理 iptables 规则残留\nsudo kube-proxy --cleanup\n</code></pre>\n<h3 id=\"4-验证初始化状态\">4. 验证初始化状态</h3>\n<p>初始化完成后，配置 kubectl 并检查集群状态：</p>\n<pre><code class=\"language-bash\"># 配置 kubectl\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n\n# 检查节点状态（此时应显示 NotReady，因为 CNI 尚未安装）\nkubectl get nodes\nkubectl get namespaces\n</code></pre>\n<h2 id=\"cilium-网络插件部署\">Cilium 网络插件部署</h2>\n<p>Cilium 基于 eBPF 技术提供高性能的网络、安全和可观测性功能。</p>\n<h3 id=\"1-安装-cilium-cli\">1. 安装 cilium-cli</h3>\n<p>从 <a href=\"https://github.com/cilium/cilium-cli/releases\" rel=\"noopener nofollow\" target=\"_blank\">Cilium CLI Releases</a> 下载并安装命令行工具。</p>\n<h3 id=\"2-准备-cilium-镜像\">2. 准备 Cilium 镜像</h3>\n<p>将 Cilium 所需的镜像推送到 Harbor 仓库：</p>\n<pre><code class=\"language-bash\">#!/bin/bash\n\nset -euo pipefail\n\nimages=(\n    cilium/cilium:v1.18.6\n    cilium/hubble-relay:v1.18.6\n    cilium/hubble-ui-backend:v0.13.3\n    cilium/hubble-ui:v0.13.3\n    cilium/cilium-envoy:v1.35.9-1767794330-db497dd19e346b39d81d7b5c0dedf6c812bcc5c9\n    cilium/certgen:v0.3.1\n    cilium/startup-script:1755531540-60ee83e\n)\n\nsrc_registry=\"quay.io\"\ntarget_registry=\"192.168.0.42\"\n\nfor image in \"${images[@]}\"; do\n    echo \"Processing image: ${image}\"\n    docker pull \"${src_registry}/${image}\"\n    docker tag \"${src_registry}/${image}\" \"${target_registry}/${image}\"\n    docker push \"${target_registry}/${image}\"\ndone\n</code></pre>\n<h3 id=\"3-获取-helm-chart\">3. 获取 Helm Chart</h3>\n<pre><code class=\"language-bash\">helm repo add cilium https://helm.cilium.io/\nhelm pull cilium/cilium --version 1.18.6\ntar xf cilium-1.18.6.tgz\nmv cilium cilium-chart\n</code></pre>\n<h3 id=\"4-配置-chart-values\">4. 配置 Chart Values</h3>\n<p>首先替换所有镜像源地址：</p>\n<pre><code class=\"language-bash\">sed -i 's#quay.io#192.168.0.42#g' ./cilium-chart/values.yaml\n</code></pre>\n<p>关键配置项调整：</p>\n<pre><code class=\"language-yaml\"># 启用 kube-proxy 替代模式\nkubeProxyReplacement: true\n\n# 指定 Kubernetes API 服务器地址\nk8sServiceHost: \"192.168.0.22\"\nk8sServicePort: 6443\n\n# 单节点部署，operator 副本数设为 1\noperator:\n  replicas: 1\n\n# 启用 Hubble 可观测性组件\nhubble:\n  enabled: true\n  relay:\n    enabled: true\n  ui:\n    enabled: true\n\n# 配置 IPAM CIDR 范围\nipam:\n  operator:\n    clusterPoolIPv4PodCIDRList:\n      - \"10.10.0.0/16\"\n</code></pre>\n<blockquote>\n<p><strong>镜像 Digest 注意事项</strong>：通过 docker pull 再 push 的方式可能导致镜像 digest 发生变化。如遇镜像拉取失败，可将 <code>values.yaml</code> 中的 <code>useDigest</code> 设置为 <code>false</code>。</p>\n</blockquote>\n<h3 id=\"5-安装-cilium\">5. 安装 Cilium</h3>\n<pre><code class=\"language-bash\"># 执行安装\ncilium install --chart-directory ./cilium-chart\n\n# 检查安装状态\ncilium status\n\n# 移除 control-plane 污点以允许 Pod 调度\nkubectl taint nodes --all node-role.kubernetes.io/control-plane-\n</code></pre>\n<h3 id=\"6-验证集群状态\">6. 验证集群状态</h3>\n<p>等待所有 Pod 正常运行后，验证集群就绪状态：</p>\n<pre><code class=\"language-bash\"># 检查所有命名空间的 Pod 状态\nkubectl get pods -A\n\n# 验证节点状态（应显示 Ready）\nkubectl get nodes\n\n# 检查 Cilium 组件状态\ncilium status --verbose\n</code></pre>\n<h2 id=\"添加工作节点扩展部署\">添加工作节点（扩展部署）</h2>\n<p>完成单节点集群部署后，如需扩展为多节点集群，可在新节点上执行以下步骤：</p>\n<p><em>在新节点上需要先完成上面的系统初始化、Containerd配置、kube组件配置</em></p>\n<h3 id=\"1-生成节点加入令牌\">1. 生成节点加入令牌</h3>\n<p>在 Control Plane 节点上生成 24 小时有效的加入令牌：</p>\n<pre><code class=\"language-bash\">kubeadm token create --print-join-command\n</code></pre>\n<p>该命令将输出类似以下格式的加入命令：</p>\n<pre><code class=\"language-bash\">kubeadm join 192.168.0.22:6443 --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;\n</code></pre>\n<h3 id=\"2-在新节点执行加入命令\">2. 在新节点执行加入命令</h3>\n<p>在新节点上执行上述命令，并忽略镜像预检错误：</p>\n<pre><code class=\"language-bash\">sudo kubeadm join 192.168.0.22:6443 \\\n  --token &lt;token&gt; \\\n  --discovery-token-ca-cert-hash sha256:&lt;hash&gt; \\\n  --ignore-preflight-errors=ImagePull\n</code></pre>\n<h3 id=\"3-验证节点加入状态\">3. 验证节点加入状态</h3>\n<pre><code class=\"language-bash\"># 检查节点列表\nkubectl get nodes\n\n# 验证 Cilium 状态\ncilium status\n\n# 清理 iptables 规则（如已禁用 kube-proxy）\nsudo iptables -F\n</code></pre>\n<p>Cilium 会自动在新节点上部署代理 Pod，确保网络连通性。</p>\n<h2 id=\"私有镜像仓库认证配置\">私有镜像仓库认证配置</h2>\n<p>对于 Harbor 中非公开项目的镜像拉取，需要配置相应的认证机制。</p>\n<h3 id=\"方式一pod-级别-imagepullsecrets推荐\">方式一：Pod 级别 imagePullSecrets（推荐）</h3>\n<p>适用于需要精细化控制镜像拉取权限的场景。</p>\n<h4 id=\"1-创建-docker-registry-secret\">1. 创建 Docker Registry Secret</h4>\n<pre><code class=\"language-bash\">kubectl create secret docker-registry harbor-pull-secret \\\n  --docker-server=192.168.0.42 \\\n  --docker-username=&lt;your-username&gt; \\\n  --docker-password=&lt;your-password&gt; \\\n  --docker-email=&lt;your-email&gt;\n</code></pre>\n<h4 id=\"2-在-pod-定义中引用-secret\">2. 在 Pod 定义中引用 Secret</h4>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: Pod\nspec:\n  containers:\n  - name: my-app\n    image: 192.168.0.42/private-project/my-image:v1\n  imagePullSecrets:\n  - name: harbor-pull-secret\n</code></pre>\n<h3 id=\"方式二serviceaccount-绑定便捷方案\">方式二：ServiceAccount 绑定（便捷方案）</h3>\n<p>适用于命名空间内所有 Pod 都需要访问私有镜像仓库的场景。</p>\n<pre><code class=\"language-bash\"># 将 Secret 绑定到 default ServiceAccount\nkubectl patch serviceaccount default -p '{\"imagePullSecrets\": [{\"name\": \"harbor-pull-secret\"}]}'\n</code></pre>\n<p>此配置将使该命名空间下所有新建的 Pod 自动继承镜像拉取权限。</p>\n<h3 id=\"方式三containerd-全局认证实验环境适用\">方式三：Containerd 全局认证（实验环境适用）</h3>\n<p>在 Containerd 层面配置全局认证，适用于个人实验环境。</p>\n<p>编辑 <code>/etc/containerd/config.toml</code>：</p>\n<pre><code class=\"language-toml\">[plugins.\"io.containerd.grpc.v1.cri\".registry.configs.\"192.168.0.42\".auth]\n  username = \"your-username\"\n  password = \"your-password\"\n  # 或使用 base64 编码的凭证：auth = \"base64(username:password)\"\n</code></pre>\n<blockquote>\n<p><strong>安全提醒</strong>：方式三将凭据明文存储在配置文件中，不建议在生产环境中使用。</p>\n</blockquote>\n<h2 id=\"补充\">补充</h2>\n<p>相较于使用二进制方式部署，用kubeadm起码省去了手动维护证书的操作，后续添加节点也更简单些。有空整个ansible让添加节点更方便。</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/XY-Heruo/\" target=\"_blank\">花酒锄作田</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/XY-Heruo/p/19560948\" target=\"_blank\">https://www.cnblogs.com/XY-Heruo/p/19560948</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-01 16:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/XY-Heruo\">花酒锄作田</a>&nbsp;\n阅读(<span id=\"post_view_count\">1</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "将SignalR移植到Esp32—让小智设备无缝连接.NET功能拓展MCP服务",
      "link": "https://www.cnblogs.com/GreenShade/p/19560338",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GreenShade/p/19560338\" id=\"cb_post_title_url\" title=\"发布于 2026-02-01 15:33\">\n    <span>将SignalR移植到Esp32—让小智设备无缝连接.NET功能拓展MCP服务</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>这段时间迷上了手搓Esp32的小智聊天机器人，也用.NET为小智AI开发了一些MCP转接平台和MCP服务。小智ESP32本身就具备MCP能力，可以调用本地MCP工具和服务端MCP工具，并将结果返回给设备，这个功能一直都有。</p>\n<p>如果你有手搓Esp32的硬件玩具打算，可以关注我的B站账号（绿荫阿广）<a href=\"https://space.bilibili.com/25228512\" rel=\"noopener nofollow\" target=\"_blank\">https://space.bilibili.com/25228512</a><br />\n带你手搓玩具。</p>\n<p>小智原本这套架构有个局限性：<strong>MCP工具执行完之后，只能同步返回结果或者通过异步邮件通知，设备无法被动接收服务端的消息</strong>。比如我想让服务端主动给设备推送一张图片、播放一段语音、或者发送一个文本通知，在之前的架构下是做不到的。</p>\n<p>所以我就决定改造小智客户端，集成SignalR实时通信框架。这次改造的核心价值是：<strong>通过SignalR消息通道，让设备可以接收各种类型的消息（声音、图片、文本通知），服务端的MCP工具执行成功后，可以根据用户ID推送数据到对应的用户通道</strong>。</p>\n<p>整个改造涉及SignalR C++客户端的集成、JWT Token认证、扫码登录（基于ESP32本地MCP工具实现）、以及服务端消息推送逻辑。客户端代码都是C++实现的，不过现在AI辅助编程很强大，帮我节省了大量时间。</p>\n<p><img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201121657114-327485878.png\" /></p>\n<h2 id=\"问题解答\">问题解答</h2>\n<p><strong>Q: 为什么选择SignalR而不是直接用WebSocket？</strong></p>\n<p>A: 起初我确实考虑过直接用WebSocket，但SignalR提供了很多开箱即用的功能：</p>\n<ul>\n<li><strong>Hub抽象</strong>：服务端可以轻松实现群组管理，按用户ID推送消息，比如<code>Clients.Group($\"Users:{userId}\").SendAsync(\"Notification\", message)</code></li>\n<li><strong>消息路由</strong>：不需要自己写消息分发逻辑，SignalR的Hub方法调用和事件推送已经很完善了</li>\n<li><strong>类型化调用</strong>：相比原始WebSocket的字符串消息，SignalR提供了类似RPC的调用体验，代码更清晰</li>\n</ul>\n<p>虽然ESP32没有现成的SignalR库，但我找到了微软官方的C++ SignalR客户端（半成品），将它与ESP32的WebSocket组件整合后，就能用上SignalR的这些特性了。至于SignalR自带的重连机制，我没用，小智有自己的循环重连逻辑，更可控一些。</p>\n<p><strong>Q: 改造的核心价值是什么？解决了什么问题？</strong></p>\n<p>A: 改造前，ESP32的MCP工具调用完成后，只能通过两种方式通知：</p>\n<ol>\n<li><strong>同步返回</strong>：工具执行结果直接返回给调用方</li>\n<li><strong>异步邮件</strong>：通过邮件发送执行结果</li>\n</ol>\n<p>这两种方式都无法满足实时推送的需求。比如我想让服务端在生图完成后立即推送图片给设备显示，或者播放一段语音提示，之前的架构做不到。</p>\n<p>改造后，通过SignalR建立了一条<strong>服务端到设备的实时消息通道</strong>：</p>\n<ul>\n<li>服务端的MCP工具执行成功后，可以调用<code>_hubContext.Clients.Group($\"Users:{userId}\").SendAsync(\"ShowImage\", imageData)</code>将图片推送给设备</li>\n<li>设备通过SignalR的事件监听接收消息：<code>connection-&gt;on(\"ShowImage\", [](const std::vector&lt;signalr::value&gt;&amp; args) { ... })</code></li>\n<li>支持推送任意类型的数据：文本、图片（Base64）、语音URL、JSON通知等</li>\n</ul>\n<p>这才是这次改造的核心价值：<strong>让设备具备被动接收服务端消息的能力</strong>，而不仅仅是主动调用和同步返回。</p>\n<p><strong>Q: 扫码登录是怎么实现的？</strong></p>\n<p>A: 扫码登录功能是基于ESP32本地MCP工具实现的，这是小智的固有功能，我只是进行了拓展：</p>\n<ol>\n<li>设备启动时检查是否有JWT Token</li>\n<li>如果没有Token，调用本地MCP工具<code>display_qrcode</code>在屏幕上显示二维码</li>\n<li>二维码内容包含设备ID和服务端地址：<code>https://mcp-server.com/device-login?deviceId=xxx</code></li>\n<li>用户用手机扫码，完成授权。</li>\n<li>设备获取Token后保存到NVS（Non-Volatile Storage），下次启动直接使用</li>\n</ol>\n<p>这样就实现了设备的快速认证，用户体验很好。扫码认证的服务端是使用开源的keycloak做的，对接了设备认证类型。</p>\n<p><img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201121907430-924035727.png\" /></p>\n<h2 id=\"名词解释\">名词解释</h2>\n<h3 id=\"核心概念\">核心概念</h3>\n<ul>\n<li>\n<p><strong>SignalR</strong>：微软提供的实时通信框架，封装了WebSocket、Server‑Sent Events和长轮询等传输方式，支持Hub模型、自动重连与消息序列化。适合实现双向、低延迟的实时消息系统。将它移植到嵌入式设备时需考虑客户端实现的体积、内存消耗与线程模型。</p>\n</li>\n<li>\n<p><strong>Hub（集线器）</strong>：SignalR的核心抽象，类似于MVC中的Controller。服务端通过Hub定义方法供客户端调用，客户端也可以注册事件监听服务端推送。例如<code>ChatHub.SendMessage(user, message)</code>就是一个典型的Hub方法。</p>\n</li>\n<li>\n<p><strong>MCP（Model Context Protocol）</strong>：一种基于JSON-RPC 2.0的协议，用于定义客户端和服务端之间的工具调用规范。在IoT场景中，设备可以作为MCP Server暴露能力（如重启、显示图片），而云端服务作为MCP Client调用这些能力。</p>\n</li>\n<li>\n<p><strong>JSON-RPC 2.0</strong>：一种轻量级的远程过程调用协议，使用JSON编码。MCP协议基于此标准，定义了<code>initialize</code>、<code>tools/list</code>、<code>tools/call</code>等方法。每个请求必须包含<code>jsonrpc: \"2.0\"</code>、<code>method</code>、<code>id</code>字段。</p>\n</li>\n</ul>\n<h3 id=\"esp32相关\">ESP32相关</h3>\n<ul>\n<li>\n<p><strong>FreeRTOS</strong>：一个开源、轻量级的实时操作系统内核，常用于微控制器平台（如ESP32）。提供任务调度、优先级、互斥锁、信号量、队列、软件定时器等实时特性，便于在资源受限设备上实现并发与确定性行为。使用时需注意堆栈大小、中断安全和任务优先级设计。</p>\n</li>\n<li>\n<p><strong>ESP32 PSRAM</strong>：ESP32可选的外部伪静态RAM（Pseudo-SRAM），用于扩展设备可用内存（常见4MB/8MB/16MB）。适合存放大对象、图像缓存、网络缓冲和动态分配数据。在ESP-IDF中需启用并正确配置，分配时也可使用不同的堆区域（如<code>heap_caps_malloc(size, MALLOC_CAP_SPIRAM)</code>）来控制放置与性能／DMA限制。</p>\n</li>\n<li>\n<p><strong>WebSocket</strong>：一种基于TCP的全双工通信协议，通过HTTP握手升级建立连接。SignalR默认优先使用WebSocket作为传输层，在ESP32上通过<code>esp_websocket_client</code>组件实现。需要注意的是ESP32的WebSocket客户端不支持自动重连，需要在应用层实现。</p>\n</li>\n</ul>\n<h3 id=\"认证相关\">认证相关</h3>\n<ul>\n<li>\n<p><strong>Bearer Token</strong>：一种HTTP认证方案，将Token放在Authorization头中：<code>Authorization: Bearer &lt;token&gt;</code>。在SignalR中，通常将Token作为查询参数传递：<code>/hub?access_token=YOUR_TOKEN</code></p>\n</li>\n<li>\n<p><strong>JWT（JSON Web Token）</strong>：一种开放标准（RFC 7512），用于在各方之间安全地传输信息。在Verdure MCP中，使用Keycloak签发的JWT进行用户认证，Token中包含用户ID、角色、过期时间等Claim信息。</p>\n</li>\n<li>\n<p><strong>API Token</strong>：一种简单的认证方式，后续连接时携带此Token验证身份。Verdure MCP同时支持API Token和JWT两种方式。</p>\n</li>\n</ul>\n<p><img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201152548041-1540521880.png\" /></p>\n<h2 id=\"核心技术架构\">核心技术架构</h2>\n<p>整个改造的架构可以用一张图说明：</p>\n<pre><code>┌──────────────────────┐                          ┌──────────────────────┐\n│   .NET MCP Service   │                          │   ESP32 Device       │\n│   (Verdure MCP)      │◄─────SignalR Hub────────►│   (小智客户端)       │\n│                      │                          │                      │\n│  ┌────────────────┐  │  ① JWT Token认证         │  ┌────────────────┐  │\n│  │  DeviceHub.cs  │  │◄─────────────────────────│  │  扫码登录      │  │\n│  │                │  │                          │  │  (本地MCP工具) │  │\n│  │ OnConnected    │  │                          │  └────────────────┘  │\n│  │ (验证Token)    │  │                          │          ↓           │\n│  └────────────────┘  │  ② 建立连接               │  ┌────────────────┐  │\n│          ↓           │◄─────────────────────────│  │ SignalR Client │  │\n│  ┌────────────────┐  │                          │  │ - connection   │  │\n│  │  群组管理      │  │                          │  │ - on() events  │  │\n│  │ Users:{userId} │  │                          │  └────────────────┘  │\n│  └────────────────┘  │                          │                      │\n│          ↓           │                          │                      │\n│  ┌────────────────┐  │  ③ MCP工具执行后推送     │  ┌────────────────┐  │\n│  │  消息推送      │  │─────────────────────────►│  │ 消息接收处理   │  │\n│  │ SendAsync()    │  │  ShowImage(imageData)    │  │ - 显示图片     │  │\n│  │                │  │  PlayAudio(audioUrl)     │  │ - 播放语音     │  │\n│  │                │  │  Notification(text)      │  │ - 显示通知     │  │\n│  └────────────────┘  │                          │  └────────────────┘  │\n└──────────────────────┘                          └──────────────────────┘\n</code></pre>\n<p>关键流程：</p>\n<ol>\n<li><strong>扫码登录</strong>：设备启动后，如果没有Token，调用本地MCP工具显示二维码，用户扫码后获取JWT Token</li>\n<li><strong>建立连接</strong>：携带JWT Token连接SignalR Hub，服务端验证后加入用户群组<code>Users:{userId}</code></li>\n<li><strong>消息推送</strong>：服务端MCP工具执行完成后，通过SignalR将结果推送给设备\n<ul>\n<li><code>_hubContext.Clients.Group($\"Users:{userId}\").SendAsync(\"ShowImage\", imageData)</code></li>\n<li>设备监听事件并处理：<code>connection-&gt;on(\"ShowImage\", handler)</code></li>\n</ul>\n</li>\n</ol>\n<p>这套架构的核心价值就是<strong>让服务端可以主动推送消息给设备</strong>，而不仅仅是等待设备轮询或同步返回。</p>\n<h2 id=\"开发环境准备\">开发环境准备</h2>\n<h3 id=\"esp32开发环境vs-code方式\">ESP32开发环境（VS Code方式）</h3>\n<p>最简单的方式是使用VS Code的ESP-IDF插件：</p>\n<ol>\n<li>\n<p><strong>安装VS Code和插件</strong></p>\n<ul>\n<li>下载安装 <a href=\"https://code.visualstudio.com/\" rel=\"noopener nofollow\" target=\"_blank\">Visual Studio Code</a></li>\n<li>安装扩展：<code>Espressif IDF</code> (搜索 <code>esp-idf</code>)</li>\n</ul>\n</li>\n<li>\n<p><strong>配置ESP-IDF</strong></p>\n<ul>\n<li>按<code>F1</code>打开命令面板，输入 <code>ESP-IDF: Configure ESP-IDF Extension</code></li>\n<li>选择 <code>Express</code> 快速配置</li>\n<li>选择ESP-IDF版本（推荐v5.1或更高）</li>\n<li>等待安装完成（会自动下载工具链、Python环境等）</li>\n</ul>\n</li>\n<li>\n<p><strong>创建/打开项目</strong></p>\n<ul>\n<li><code>F1</code> → <code>ESP-IDF: Show Examples Projects</code></li>\n<li>或直接打开 esp-signalr-example 项目文件夹</li>\n</ul>\n</li>\n<li>\n<p><strong>编译和烧录</strong></p>\n<ul>\n<li>点击底部状态栏的 <code>Build</code>、<code>Flash</code>、<code>Monitor</code> 按钮</li>\n<li>或按快捷键：<code>Ctrl+E B</code>（编译）、<code>Ctrl+E F</code>（烧录）</li>\n</ul>\n</li>\n</ol>\n<p>这种方式比命令行简单很多，适合.NET开发者快速上手ESP32开发。</p>\n<p><img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201122055040-2075015821.png\" /></p>\n<h3 id=\"net开发环境\">.NET开发环境</h3>\n<p>服务端使用.NET 10开发：</p>\n<pre><code class=\"language-bash\"># Windows: 下载安装器 https://dotnet.microsoft.com/download/dotnet/10.0\n\n# 验证安装\ndotnet --version  # 应该输出 10.0.x\n\n</code></pre>\n<h2 id=\"核心代码实现\">核心代码实现</h2>\n<p>本章节将代码分为<strong>示例代码</strong>和<strong>实际整合代码</strong>两个部分进行讲解：</p>\n<ul>\n<li><strong>示例代码</strong>：用于理解核心概念的简化版本，便于学习和快速上手</li>\n<li><strong>实际整合代码</strong>：生产环境中的完整实现，包含完善的错误处理、状态管理等</li>\n</ul>\n<h3 id=\"关于示例仓库\">关于示例仓库</h3>\n<p>为了帮助开发者快速上手ESP32的SignalR集成，我创建了一个完整的示例仓库：</p>\n<p><strong>🔗 仓库地址</strong>：<a href=\"https://github.com/maker-community/esp-signalr-example\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/maker-community/esp-signalr-example</a></p>\n<p><strong>📦 仓库结构</strong>：</p>\n<pre><code>esp-signalr-example/\n├── main/                    # ESP32 C++客户端代码\n│   ├── main.cpp            # 主程序（WiFi连接、SignalR初始化）\n│   └── CMakeLists.txt      # ESP-IDF构建配置\n├── signalr-server/         # .NET C# 服务端代码\n│   ├── Program.cs          # ASP.NET Core服务器配置\n│   ├── ChatHub.cs          # SignalR Hub实现\n│   └── signalr-server.csproj\n├── docs/                   # 文档\n│   ├── QUICKSTART.md       # 5分钟快速开始指南\n│   ├── TEST_SERVER_SETUP.md # 测试服务器详细设置\n│   └── TROUBLESHOOTING.md  # 常见问题排查\n└── README.md               # 项目说明\n</code></pre>\n<p><strong>✨ 主要特性</strong>：</p>\n<ol>\n<li>\n<p><strong>开箱即用的服务器</strong>：</p>\n<ul>\n<li>基于ASP.NET Core和SignalR构建</li>\n<li>支持消息广播</li>\n<li>完整的连接管理和日志输出</li>\n<li>提供RESTful API用于设备控制</li>\n</ul>\n</li>\n<li>\n<p><strong>简化的ESP32客户端</strong>：</p>\n<ul>\n<li>使用Microsoft官方的C++ SignalR客户端库移植版</li>\n<li>通过menuconfig配置WiFi和服务器地址</li>\n<li>演示消息发送/接收、传感器数据上报</li>\n<li>清晰的日志输出和错误处理</li>\n</ul>\n</li>\n</ol>\n<p><strong>🚀 快速开始示例</strong>（5分钟运行）：</p>\n<pre><code class=\"language-bash\"># 1. 克隆仓库\ngit clone https://github.com/maker-community/esp-signalr-example.git\ncd esp-signalr-example\n\n# 2. 启动服务器（需要.NET 9.0+）\ncd signalr-server\ndotnet run --urls \"http://+:5000\" 这个运行可以用ip访问\n# 服务器运行在: http://0.0.0.0:5000/chatHub\n\n# 3. 配置并烧录ESP32\ncd ../\nidf.py menuconfig\n# 配置WiFi SSID、密码和服务器地址\nidf.py build flash monitor\n</code></pre>\n<p>esp32的配置如下：</p>\n<p><img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201134357961-636085039.png\" /></p>\n<p><strong>📊 运行效果</strong>：</p>\n<p>服务器输出：<br />\n<img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201135020573-402562452.png\" /></p>\n<pre><code>✓ Client connected: abc123\n  IP Address: 192.168.1.100\n  Total Connections: 1\n\n[10:30:25] Received from ESP32-Device: Test message #1 from ESP32\n[10:30:35] Sensor Update - Temperature: 25.50\n</code></pre>\n<p>ESP32串口输出：<br />\n<img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201134940520-565577362.png\" /></p>\n<pre><code>I (3520) SIGNALR_EXAMPLE: ✓✓✓ Connected to SignalR Hub! ✓✓✓\nI (3525) SIGNALR_EXAMPLE: 🔔 Notification: Welcome!\nI (14640) S\n</code></pre>\n<p><strong>🎯 示例仓库的价值</strong>：</p>\n<ul>\n<li><strong>学习路径清晰</strong>：从简单的连接到复杂的数据传输，循序渐进</li>\n<li><strong>可直接运行</strong>：不需要依赖外部服务，本地即可测试完整流程</li>\n<li><strong>代码注释详细</strong>：关键部分都有中英文注释说明</li>\n<li><strong>易于扩展</strong>：基于这个示例可以快速开发自己的应用</li>\n</ul>\n<p>接下来的 5.1 节将基于这个示例仓库的代码进行讲解。</p>\n<h3 id=\"51-示例代码教学简化版\">5.1 示例代码（教学简化版）</h3>\n<blockquote>\n<p><strong>说明</strong>：以下代码来自开源示例仓库 <a href=\"https://github.com/maker-community/esp-signalr-example\" rel=\"noopener nofollow\" target=\"_blank\">esp-signalr-example</a>，经过精简突出核心概念，方便理解SignalR与ESP32集成的基本原理。完整代码请参考仓库源码。</p>\n</blockquote>\n<h4 id=\"511-服务端signalr-hub基础实现\">5.1.1 服务端：SignalR Hub基础实现</h4>\n<p>这是服务端的核心代码，实现了连接管理、消息广播和设备状态跟踪：</p>\n<p><strong>ChatHub.cs - Hub核心实现</strong>：</p>\n<pre><code class=\"language-csharp\">using Microsoft.AspNetCore.SignalR;\n\npublic class ChatHub : Hub\n{\n    private readonly ILogger&lt;ChatHub&gt; _logger;\n    private static int _connectionCount = 0;\n    \n    // 存储连接的设备信息\n    private static readonly Dictionary&lt;string, DeviceInfo&gt; _connectedDevices = new();\n    private static readonly object _devicesLock = new();\n\n    public ChatHub(ILogger&lt;ChatHub&gt; logger)\n    {\n        _logger = logger;\n    }\n\n    /// &lt;summary&gt;\n    /// 处理来自ESP32的消息\n    /// &lt;/summary&gt;\n    public async Task SendMessage(string user, string message)\n    {\n        _logger.LogInformation(\"[{Time}] Received from {User}: {Message}\", \n            DateTime.Now.ToString(\"HH:mm:ss\"), user, message);\n        \n        // 广播到所有连接的客户端\n        await Clients.All.SendAsync(\"ReceiveMessage\", user, message);\n    }\n\n    /// &lt;summary&gt;\n    /// 处理传感器数据更新\n    /// &lt;/summary&gt;\n    public async Task UpdateSensor(string sensorId, double value)\n    {\n        _logger.LogInformation(\"[{Time}] Sensor Update - {SensorId}: {Value:F2}\", \n            DateTime.Now.ToString(\"HH:mm:ss\"), sensorId, value);\n        \n        // 广播传感器数据到所有客户端\n        await Clients.All.SendAsync(\"UpdateSensorData\", sensorId, value);\n    }\n\n    /// &lt;summary&gt;\n    /// 处理ESP32状态更新\n    /// &lt;/summary&gt;\n    public async Task UpdateDeviceStatus(string deviceId, string status, int freeHeap)\n    {\n        _logger.LogInformation(\"[{Time}] Device Status - {DeviceId}: {Status}, Free Heap: {FreeHeap} bytes\", \n            DateTime.Now.ToString(\"HH:mm:ss\"), deviceId, status, freeHeap);\n        \n        await Clients.All.SendAsync(\"DeviceStatusUpdate\", deviceId, status, freeHeap);\n    }\n\n    /// &lt;summary&gt;\n    /// 客户端连接时触发\n    /// &lt;/summary&gt;\n    public override async Task OnConnectedAsync()\n    {\n        Interlocked.Increment(ref _connectionCount);\n        \n        var connectionId = Context.ConnectionId;\n        var httpContext = Context.GetHttpContext();\n        var ipAddress = httpContext?.Connection.RemoteIpAddress?.ToString();\n        var userAgent = httpContext?.Request.Headers[\"User-Agent\"].ToString();\n        \n        // 保存设备信息\n        lock (_devicesLock)\n        {\n            _connectedDevices[connectionId] = new DeviceInfo\n            {\n                ConnectionId = connectionId,\n                IpAddress = ipAddress,\n                UserAgent = userAgent,\n                ConnectedAt = DateTime.UtcNow\n            };\n        }\n        \n        _logger.LogInformation(\"✓ Client connected: {ConnectionId}\", connectionId);\n        _logger.LogInformation(\"  IP Address: {IpAddress}\", ipAddress);\n        _logger.LogInformation(\"  Total Connections: {Count}\", _connectionCount);\n        \n        await base.OnConnectedAsync();\n        \n        // 发送欢迎消息（ESP32通过此消息确认连接成功）\n        await Clients.Caller.SendAsync(\"Notification\", \n            \"Welcome to SignalR Test Server!\");\n    }\n\n    /// &lt;summary&gt;\n    /// 客户端断开时触发\n    /// &lt;/summary&gt;\n    public override async Task OnDisconnectedAsync(Exception? exception)\n    {\n        Interlocked.Decrement(ref _connectionCount);\n        \n        var connectionId = Context.ConnectionId;\n        \n        // 移除设备信息\n        lock (_devicesLock)\n        {\n            _connectedDevices.Remove(connectionId);\n        }\n        \n        _logger.LogInformation(\"✗ Client disconnected: {ConnectionId}\", connectionId);\n        if (exception != null)\n        {\n            _logger.LogWarning(\"  Disconnection reason: {Message}\", exception.Message);\n        }\n        _logger.LogInformation(\"  Remaining Connections: {Count}\", _connectionCount);\n        \n        await base.OnDisconnectedAsync(exception);\n    }\n}\n\n/// &lt;summary&gt;\n/// 设备连接信息\n/// &lt;/summary&gt;\npublic class DeviceInfo\n{\n    public string ConnectionId { get; set; } = \"\";\n    public string? IpAddress { get; set; }\n    public string? UserAgent { get; set; }\n    public DateTime ConnectedAt { get; set; }\n}\n</code></pre>\n<p><strong>Program.cs - SignalR服务配置</strong>：</p>\n<pre><code class=\"language-csharp\">var builder = WebApplication.CreateBuilder(args);\n\n// 添加SignalR服务\nbuilder.Services.AddSignalR(options =&gt;\n{\n    options.EnableDetailedErrors = true;  // 开发环境启用\n    options.ClientTimeoutInterval = TimeSpan.FromSeconds(30);  // 客户端超时\n    options.KeepAliveInterval = TimeSpan.FromSeconds(15);  // 心跳间隔\n});\n\n// 添加CORS支持（允许ESP32跨域连接）\nbuilder.Services.AddCors(options =&gt;\n{\n    options.AddDefaultPolicy(policy =&gt;\n    {\n        policy.AllowAnyOrigin()\n              .AllowAnyHeader()\n              .AllowAnyMethod();\n    });\n});\n\nvar app = builder.Build();\n\napp.UseCors();\napp.MapHub&lt;ChatHub&gt;(\"/chatHub\");\n\n// 监听所有网络接口（重要：局域网内ESP32能访问）\napp.Urls.Add(\"http://0.0.0.0:5000\");\n\nConsole.WriteLine(\"SignalR Server: http://0.0.0.0:5000/chatHub\");\napp.Run();\n</code></pre>\n<p><strong>关键点说明</strong>：</p>\n<ol>\n<li><strong>连接确认机制</strong>：服务器在 <code>OnConnectedAsync</code> 中发送 <code>Notification</code> 消息，ESP32收到此消息才认为连接成功</li>\n<li><strong>消息广播</strong>：使用 <code>Clients.All.SendAsync()</code> 向所有连接的客户端广播消息</li>\n<li><strong>连接跟踪</strong>：使用静态字典 <code>_connectedDevices</code> 跟踪所有连接的设备信息</li>\n</ol>\n<h4 id=\"512-服务端设备控制api通过signalr推送消息\">5.1.2 服务端：设备控制API（通过SignalR推送消息）</h4>\n<p>示例仓库提供了完整的设备控制API，演示如何通过SignalR向ESP32推送各种类型的消息：</p>\n<p><strong>Program.cs - 设备控制API端点</strong>：</p>\n<pre><code class=\"language-csharp\">// ============================================================================\n// 设备控制 API - 用于向设备发送 CustomMessage\n// ============================================================================\n\n// 获取所有连接的设备\napp.MapGet(\"/api/device/connections\", () =&gt;\n{\n    return Results.Ok(ChatHub.ConnectedDevices);\n})\n.WithName(\"GetConnections\")\n.WithDescription(\"获取所有连接的设备列表\");\n\n// 发送通知\napp.MapPost(\"/api/device/notification\", async (\n    NotificationRequest request, \n    IHubContext&lt;ChatHub&gt; hubContext, \n    ILogger&lt;Program&gt; logger) =&gt;\n{\n    var message = new\n    {\n        action = \"notification\",\n        title = request.Title ?? \"通知\",\n        content = request.Content ?? \"\",\n        emotion = request.Emotion ?? \"bell\",\n        sound = request.Sound ?? \"popup\"\n    };\n\n    await SendCustomMessage(hubContext, logger, request.ConnectionId, message);\n    return Results.Ok(new { success = true, message = \"Notification sent\" });\n})\n.WithDescription(\"发送通知到设备 (sound: popup/success/vibration/exclamation/low_battery/none)\");\n\n// 发送图片\napp.MapPost(\"/api/device/image\", async (\n    ImageRequest request, \n    IHubContext&lt;ChatHub&gt; hubContext, \n    ILogger&lt;Program&gt; logger) =&gt;\n{\n    var message = new\n    {\n        action = \"image\",\n        url = request.Url\n    };\n\n    await SendCustomMessage(hubContext, logger, request.ConnectionId, message);\n    return Results.Ok(new { success = true, message = \"Image sent\" });\n})\n.WithDescription(\"发送图片URL到设备显示 (支持JPG/PNG, 最大1MB)\");\n\n// 发送音频\napp.MapPost(\"/api/device/audio\", async (\n    AudioRequest request, \n    IHubContext&lt;ChatHub&gt; hubContext, \n    ILogger&lt;Program&gt; logger) =&gt;\n{\n    var message = new\n    {\n        action = \"audio\",\n        url = request.Url\n    };\n\n    await SendCustomMessage(hubContext, logger, request.ConnectionId, message);\n    return Results.Ok(new { success = true, message = \"Audio sent\" });\n})\n.WithDescription(\"发送音频URL到设备播放 (OGG格式, 最大512KB)\");\n\n// 发送命令\napp.MapPost(\"/api/device/command\", async (\n    CommandRequest request, \n    IHubContext&lt;ChatHub&gt; hubContext, \n    ILogger&lt;Program&gt; logger) =&gt;\n{\n    var message = new\n    {\n        action = \"command\",\n        command = request.Command\n    };\n\n    await SendCustomMessage(hubContext, logger, request.ConnectionId, message);\n    return Results.Ok(new { success = true, message = \"Command sent\" });\n})\n.WithDescription(\"发送命令到设备 (command: reboot/wake/listen/stop)\");\n\n// 显示二维码\napp.MapPost(\"/api/device/qrcode\", async (\n    QRCodeRequest request, \n    IHubContext&lt;ChatHub&gt; hubContext, \n    ILogger&lt;Program&gt; logger) =&gt;\n{\n    var message = new\n    {\n        action = \"qrcode\",\n        content = request.Content,\n        title = request.Title ?? \"扫码\"\n    };\n\n    await SendCustomMessage(hubContext, logger, request.ConnectionId, message);\n    return Results.Ok(new { success = true, message = \"QRCode sent\" });\n})\n.WithDescription(\"显示二维码到设备屏幕\");\n\n// 辅助方法：发送 CustomMessage\nasync Task SendCustomMessage(\n    IHubContext&lt;ChatHub&gt; hubContext, \n    ILogger&lt;Program&gt; logger, \n    string? connectionId, \n    object message)\n{\n    var json = JsonSerializer.Serialize(message);\n    logger.LogInformation(\"📤 Sending CustomMessage to {Target}: {Message}\", \n        string.IsNullOrEmpty(connectionId) ? \"ALL\" : connectionId, json);\n\n    if (string.IsNullOrEmpty(connectionId))\n    {\n        // 发送给所有连接的设备\n        await hubContext.Clients.All.SendAsync(\"CustomMessage\", json);\n    }\n    else\n    {\n        // 发送给指定连接\n        await hubContext.Clients.Client(connectionId).SendAsync(\"CustomMessage\", json);\n    }\n}\n\n// ============================================================================\n// 请求模型\n// ============================================================================\n\nrecord NotificationRequest\n{\n    public string? ConnectionId { get; init; }\n    public string? Title { get; init; }\n    public string Content { get; init; } = \"\";\n    public string? Emotion { get; init; }\n    public string? Sound { get; init; }\n}\n\nrecord ImageRequest\n{\n    public string? ConnectionId { get; init; }\n    public string Url { get; init; } = \"\";\n}\n\nrecord AudioRequest\n{\n    public string? ConnectionId { get; init; }\n    public string Url { get; init; } = \"\";\n}\n\nrecord CommandRequest\n{\n    public string? ConnectionId { get; init; }\n    public string Command { get; init; } = \"\";\n}\n\nrecord QRCodeRequest\n{\n    public string? ConnectionId { get; init; }\n    public string Content { get; init; } = \"\";\n    public string? Title { get; init; }\n}\n</code></pre>\n<p><strong>关键点说明</strong>：</p>\n<ol>\n<li><strong>IHubContext注入</strong>：使用 <code>IHubContext&lt;ChatHub&gt;</code> 在非Hub类中发送SignalR消息</li>\n<li><strong>消息格式</strong>：使用JSON格式的 <code>CustomMessage</code> 事件，包含 <code>action</code> 字段标识消息类型</li>\n<li><strong>定向推送</strong>：\n<ul>\n<li><code>Clients.All.SendAsync()</code> - 广播给所有连接的设备</li>\n<li><code>Clients.Client(connectionId).SendAsync()</code> - 发送给指定设备</li>\n<li><code>Clients.Group(groupName).SendAsync()</code> - 发送给群组（如 <code>Users:{userId}</code>）</li>\n</ul>\n</li>\n<li><strong>RESTful API设计</strong>：提供HTTP端点控制设备，便于其他服务调用</li>\n</ol>\n<p>服务端的接口图片如下可以直接操作测试：</p>\n<p><img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201134534230-1496642342.png\" /></p>\n<h4 id=\"513-客户端esp32连接signalr并接收消息\">5.1.3 客户端（ESP32）：连接SignalR并接收消息</h4>\n<p>这是ESP32端的核心代码，演示如何连接SignalR Hub并接收各种类型的消息：</p>\n<p><strong>main.cpp - SignalR连接与消息处理</strong>：</p>\n<pre><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;memory&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_system.h\"\n#include \"esp_log.h\"\n#include \"nvs_flash.h\"\n\n#include \"hub_connection_builder.h\"\n#include \"esp32_websocket_client.h\"\n#include \"esp32_http_client.h\"\n\n// =============================================================================\n// 配置项（通过menuconfig设置）\n// =============================================================================\n\n#define WIFI_SSID      CONFIG_EXAMPLE_WIFI_SSID\n#define WIFI_PASSWORD  CONFIG_EXAMPLE_WIFI_PASSWORD\n#define SIGNALR_HUB_URL CONFIG_EXAMPLE_SIGNALR_HUB_URL\n\nstatic const char* TAG = \"SIGNALR_EXAMPLE\";\n\n// SignalR连接对象\nstatic std::unique_ptr&lt;signalr::hub_connection&gt; g_connection;\nstatic bool g_is_connected = false;\n\n// =============================================================================\n// 消息处理器\n// =============================================================================\n\n/**\n * 处理服务器发送的消息\n */\nstatic void on_receive_message(const std::vector&lt;signalr::value&gt;&amp; args)\n{\n    ESP_LOGI(TAG, \"==============================================\");\n    ESP_LOGI(TAG, \"📩 Message received from server:\");\n    \n    if (args.size() &gt;= 2) {\n        std::string user = args[0].as_string();\n        std::string message = args[1].as_string();\n        \n        ESP_LOGI(TAG, \"   From: %s\", user.c_str());\n        ESP_LOGI(TAG, \"   Text: %s\", message.c_str());\n    } else if (args.size() == 1) {\n        ESP_LOGI(TAG, \"   Message: %s\", args[0].as_string().c_str());\n    }\n    \n    ESP_LOGI(TAG, \"==============================================\");\n}\n\n/**\n * 处理通知消息（连接确认）\n */\nstatic void on_notification(const std::vector&lt;signalr::value&gt;&amp; args)\n{\n    if (args.empty()) return;\n    \n    std::string notification = args[0].as_string();\n    ESP_LOGI(TAG, \"🔔 Notification: %s\", notification.c_str());\n    \n    // 通过Notification消息确认连接成功\n    if (!g_is_connected) {\n        g_is_connected = true;\n        ESP_LOGI(TAG, \"==============================================\");\n        ESP_LOGI(TAG, \"✓✓✓ Connected to SignalR Hub! ✓✓✓\");\n        ESP_LOGI(TAG, \"==============================================\");\n    }\n}\n\n/**\n * 处理传感器数据更新\n */\nstatic void on_sensor_update(const std::vector&lt;signalr::value&gt;&amp; args)\n{\n    if (args.size() &lt; 2) return;\n    \n    std::string sensor_id = args[0].as_string();\n    double value = args[1].as_double();\n    \n    ESP_LOGI(TAG, \"📊 Sensor Update: %s = %.2f\", sensor_id.c_str(), value);\n}\n\n/**\n * 处理设备状态更新\n */\nstatic void on_device_status(const std::vector&lt;signalr::value&gt;&amp; args)\n{\n    if (args.size() &lt; 3) return;\n    \n    std::string device_id = args[0].as_string();\n    std::string status = args[1].as_string();\n    int free_heap = static_cast&lt;int&gt;(args[2].as_double());\n    \n    ESP_LOGI(TAG, \"📱 Device Status: %s - %s (Free Heap: %d bytes)\", \n             device_id.c_str(), status.c_str(), free_heap);\n}\n\n// =============================================================================\n// SignalR连接管理\n// =============================================================================\n\n/**\n * 初始化SignalR连接\n */\nstatic void init_signalr(void)\n{\n    ESP_LOGI(TAG, \"Initializing SignalR connection to: %s\", SIGNALR_HUB_URL);\n\n    try {\n        // 创建hub_connection（使用make_unique）\n        g_connection = std::make_unique&lt;signalr::hub_connection&gt;(\n            signalr::hub_connection_builder::create(SIGNALR_HUB_URL)\n                .with_websocket_factory([](const signalr::signalr_client_config&amp; config) {\n                    return std::make_shared&lt;signalr::esp32_websocket_client&gt;(config);\n                })\n                .with_http_client_factory([](const signalr::signalr_client_config&amp; config) {\n                    return std::make_shared&lt;signalr::esp32_http_client&gt;(config);\n                })\n                .with_automatic_reconnect()  // 启用自动重连\n                .skip_negotiation(true)      // 跳过协商，直接WebSocket\n                .build());\n\n        ESP_LOGI(TAG, \"✓ SignalR connection object created\");\n        \n    } catch (const std::exception&amp; e) {\n        ESP_LOGE(TAG, \"Failed to create SignalR connection: %s\", e.what());\n    }\n}\n\n/**\n * 注册消息处理器\n */\nstatic void setup_message_handlers(void)\n{\n    if (!g_connection) {\n        ESP_LOGE(TAG, \"Connection not initialized\");\n        return;\n    }\n\n    // 注册 \"ReceiveMessage\" 事件\n    g_connection-&gt;on(\"ReceiveMessage\", on_receive_message);\n    ESP_LOGI(TAG, \"✓ Registered handler: ReceiveMessage\");\n\n    // 注册 \"Notification\" 事件（用于连接确认）\n    g_connection-&gt;on(\"Notification\", on_notification);\n    ESP_LOGI(TAG, \"✓ Registered handler: Notification\");\n\n    // 注册 \"UpdateSensorData\" 事件\n    g_connection-&gt;on(\"UpdateSensorData\", on_sensor_update);\n    ESP_LOGI(TAG, \"✓ Registered handler: UpdateSensorData\");\n\n    // 注册 \"DeviceStatusUpdate\" 事件\n    g_connection-&gt;on(\"DeviceStatusUpdate\", on_device_status);\n    ESP_LOGI(TAG, \"✓ Registered handler: DeviceStatusUpdate\");\n}\n\n/**\n * 启动SignalR连接\n */\nstatic void start_signalr_connection(void)\n{\n    if (!g_connection) {\n        ESP_LOGE(TAG, \"Connection not initialized\");\n        return;\n    }\n    \n    ESP_LOGI(TAG, \"Starting SignalR connection...\");\n\n    try {\n        // 启动连接（异步）\n        g_connection-&gt;start([](std::exception_ptr exception) {\n            if (exception) {\n                ESP_LOGE(TAG, \"Connection failed in callback\");\n            } else {\n                ESP_LOGI(TAG, \"Connection started successfully\");\n            }\n        });\n        \n        ESP_LOGI(TAG, \"Waiting for Notification message to confirm connection...\");\n\n    } catch (const std::exception&amp; e) {\n        ESP_LOGE(TAG, \"Exception starting connection: %s\", e.what());\n    }\n}\n\n// =============================================================================\n// 测试任务：定期发送消息\n// =============================================================================\n\nstatic void signalr_test_task(void* param)\n{\n    int message_count = 1;\n    \n    while (true) {\n        // 等待10秒\n        vTaskDelay(pdMS_TO_TICKS(10000));\n        \n        // 检查连接状态\n        if (!g_connection || !g_is_connected) {\n            ESP_LOGW(TAG, \"Not connected, skipping message send\");\n            continue;\n        }\n        \n        // 发送消息到服务器\n        std::string message = \"Test message #\" + std::to_string(message_count++) + \" from ESP32\";\n        \n        ESP_LOGI(TAG, \"📤 Sending message...\");\n        ESP_LOGI(TAG, \"   User: ESP32-Device\");\n        ESP_LOGI(TAG, \"   Message: %s\", message.c_str());\n        \n        try {\n            std::vector&lt;signalr::value&gt; args;\n            args.push_back(signalr::value(\"ESP32-Device\"));\n            args.push_back(signalr::value(message));\n            \n            // 调用服务器的 SendMessage 方法\n            g_connection-&gt;invoke(\"SendMessage\", args, \n                [](const signalr::value&amp; result, std::exception_ptr exception) {\n                    if (exception) {\n                        ESP_LOGE(TAG, \"✗ Failed to send message\");\n                    } else {\n                        ESP_LOGI(TAG, \"✓ Message sent successfully!\");\n                    }\n                });\n                \n        } catch (const std::exception&amp; e) {\n            ESP_LOGE(TAG, \"Exception sending message: %s\", e.what());\n        }\n    }\n}\n\n// =============================================================================\n// 主程序\n// =============================================================================\n\nextern \"C\" void app_main(void)\n{\n    ESP_LOGI(TAG, \"========================================\");\n    ESP_LOGI(TAG, \" ESP32 SignalR Client Test Example\");\n    ESP_LOGI(TAG, \"========================================\");\n    \n    // 1. 初始化WiFi（省略WiFi连接代码，参考完整示例）\n    // wifi_init_sta();\n    \n    // 2. 初始化SignalR连接对象\n    ESP_LOGI(TAG, \"Step 1: Initializing SignalR...\");\n    init_signalr();\n    \n    // 3. 注册消息处理器\n    ESP_LOGI(TAG, \"Step 2: Setting up message handlers...\");\n    setup_message_handlers();\n    \n    // 4. 启动连接\n    ESP_LOGI(TAG, \"Step 3: Starting connection...\");\n    start_signalr_connection();\n    \n    // 5. 创建测试任务（定期发送消息）\n    ESP_LOGI(TAG, \"Step 4: Creating test task...\");\n    xTaskCreate(signalr_test_task, \"signalr_test\", 8192, NULL, 5, NULL);\n    \n    ESP_LOGI(TAG, \"Setup complete. Check logs for connection status.\");\n}\n</code></pre>\n<p><strong>关键点说明</strong>：</p>\n<ol>\n<li><strong>连接创建</strong>：使用 <code>hub_connection_builder</code> 构建连接，配置WebSocket客户端工厂</li>\n<li><strong>跳过协商</strong>：<code>skip_negotiation(true)</code> 直接使用WebSocket，提高连接速度</li>\n<li><strong>消息处理器注册</strong>：使用 <code>connection-&gt;on(\"EventName\", handler)</code> 注册事件监听器</li>\n<li><strong>连接确认</strong>：通过接收 <code>Notification</code> 消息判断连接成功（服务器在 <code>OnConnectedAsync</code> 中发送）</li>\n<li><strong>调用服务器方法</strong>：使用 <code>invoke()</code> 调用Hub方法，如 <code>SendMessage</code></li>\n</ol>\n<p><strong>完整运行流程</strong>：</p>\n<pre><code>1. WiFi连接成功\n   ↓\n2. 创建SignalR连接对象\n   ↓\n3. 注册消息处理器（ReceiveMessage、Notification等）\n   ↓\n4. 调用 connection-&gt;start() 启动连接\n   ↓\n5. 等待服务器发送 Notification 消息\n   ↓\n6. 收到 Notification，标记连接成功\n   ↓\n7. 定期调用 invoke(\"SendMessage\") 发送消息\n   ↓\n8. 接收服务器广播的消息，触发对应处理器\n</code></pre>\n<p><strong>示例输出</strong>：</p>\n<pre><code>I (3480) SIGNALR_EXAMPLE: ✓ Registered handler: ReceiveMessage\nI (3485) SIGNALR_EXAMPLE: ✓ Registered handler: Notification\nI (3490) SIGNALR_EXAMPLE: Starting SignalR connection...\nI (4520) SIGNALR_EXAMPLE: ==============================================\nI (4520) SIGNALR_EXAMPLE: ✓✓✓ Connected to SignalR Hub! ✓✓✓\nI (4525) SIGNALR_EXAMPLE: ==============================================\nI (4530) SIGNALR_EXAMPLE: 🔔 Notification: Welcome to SignalR!\nI (14530) SIGNALR_EXAMPLE: 📤 Sending message...\nI (14640) SIGNALR_EXAMPLE: ✓ Message sent successfully!\nI (14650) SIGNALR_EXAMPLE: 📩 Message received from server:\nI (14655) SIGNALR_EXAMPLE:    From: ESP32-Device\nI (14660) SIGNALR_EXAMPLE:    Text: Test message #1 from ESP32\n</code></pre>\n<h3 id=\"52-实际整合代码生产环境完整实现\">5.2 实际整合代码（生产环境完整实现）</h3>\n<blockquote>\n<p><strong>说明</strong>：以下代码来自小智AI项目的实际生产代码，包含了完整的错误处理、状态管理、JWT认证和自动重连机制。</p>\n</blockquote>\n<p>实际项目代码分为三个主要仓库：</p>\n<h4 id=\"521-小智esp32设备代码\">5.2.1 小智ESP32设备代码</h4>\n<p><strong>仓库地址</strong>：</p>\n<ul>\n<li>主仓库：<a href=\"https://github.com/maker-community/xiaozhi-esp32\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/maker-community/xiaozhi-esp32</a></li>\n<li>SignalR集成分支：<code>signalr</code> 和 <code>signalr-update-audio</code></li>\n<li>完整示例工程：<a href=\"https://github.com/maker-community/esp-signalr-example\" rel=\"noopener nofollow\" target=\"_blank\">esp-signalr-example</a></li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>：SignalR功能主要在 <code>signalr</code> 和 <code>signalr-update-audio</code> 两个分支中实现，这两个分支都是SignalR集成相关的开发分支。</p>\n</blockquote>\n<p><strong>核心文件</strong>：</p>\n<ul>\n<li><code>main/signalr_client.cc</code> / <code>main/signalr_client.h</code> - <strong>SignalR客户端核心实现</strong></li>\n<li><code>main/application.cc</code> / <code>main/application.h</code> - 主应用程序逻辑和状态管理</li>\n<li><code>main/protocols/websocket_protocol.cc</code> - WebSocket协议实现</li>\n<li><code>main/protocols/mqtt_protocol.cc</code> - MQTT协议实现</li>\n<li><code>main/mcp_server.cc</code> - MCP服务器实现</li>\n</ul>\n<p><strong>实际实现特点</strong>：</p>\n<p>与示例代码相比,生产环境实现增加了：</p>\n<ol>\n<li>\n<p><strong>完整的生命周期管理</strong></p>\n<ul>\n<li>连接建立、断开重连、资源清理</li>\n<li>设备状态机管理（空闲、连接中、监听、说话等）</li>\n</ul>\n</li>\n<li>\n<p><strong>协议版本支持</strong></p>\n<ul>\n<li>支持WebSocket和MQTT两种传输协议</li>\n<li>协议层抽象,易于扩展新协议</li>\n</ul>\n</li>\n<li>\n<p><strong>音频流处理</strong></p>\n<ul>\n<li>实时音频数据的编码、传输和接收</li>\n<li><strong>音频分块传输</strong>（重要！）- 解决大数据传输导致连接断开的问题</li>\n<li>支持Opus编解码</li>\n</ul>\n</li>\n<li>\n<p><strong>MCP工具集成</strong></p>\n<ul>\n<li>完整的MCP Server实现</li>\n<li>工具注册、调用和响应机制</li>\n<li>支持异步工具执行</li>\n</ul>\n</li>\n<li>\n<p><strong>SignalR客户端封装</strong></p>\n<ul>\n<li>完整的连接生命周期管理</li>\n<li>JWT Token认证</li>\n<li>自动重连机制（指数退避）</li>\n<li>设备注册和心跳保持</li>\n<li>自定义消息处理</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"signalr客户端核心实现-signalr_clientcc\">SignalR客户端核心实现 (signalr_client.cc)</h5>\n<p>这是整个SignalR集成的核心代码，封装了所有与SignalR通信相关的逻辑。</p>\n<p><strong>完整代码</strong>：<a href=\"https://github.com/maker-community/xiaozhi-esp32/blob/signalr-update-audio/main/signalr_client.cc\" rel=\"noopener nofollow\" target=\"_blank\">signalr_client.cc</a> （850行）</p>\n<p><strong>关键实现要点</strong>：</p>\n<p><strong>1. 单例模式管理</strong> - 全局唯一实例</p>\n<pre><code class=\"language-cpp\">SignalRClient&amp; SignalRClient::GetInstance() {\n    static SignalRClient instance;\n    return instance;\n}\n</code></pre>\n<p><strong>2. JWT Token认证</strong> - 通过Query String传递</p>\n<pre><code class=\"language-cpp\">bool SignalRClient::Initialize(const std::string&amp; hub_url, const std::string&amp; token) {\n    // 🔐 Build URL with token as query parameter (ASP.NET Core SignalR standard method)\n    std::string final_hub_url = hub_url;\n    if (!token.empty()) {\n        ESP_LOGI(TAG, \"========== SignalR Token Authentication ==========\");\n        \n        // Remove \"Bearer \" prefix if present\n        std::string token_value = token;\n        if (token_value.find(\"Bearer \") == 0) {\n            token_value = token_value.substr(7);\n        }\n        \n        // Append token to URL\n        final_hub_url += \"?access_token=\" + token_value;\n    }\n    \n    // Create hub connection builder\n    auto builder = signalr::hub_connection_builder::create(final_hub_url);\n    \n    // Set WebSocket factory (使用ESP32的WebSocket实现)\n    builder.with_websocket_factory([](const signalr::signalr_client_config&amp; config) {\n        auto client = std::make_shared&lt;signalr::esp32_websocket_client&gt;(config);\n        return client;\n    });\n    \n    // Skip negotiation (direct WebSocket connection)\n    builder.skip_negotiation(true);\n    \n    // Build connection\n    connection_ = std::make_unique&lt;signalr::hub_connection&gt;(builder.build());\n}\n</code></pre>\n<p><strong>3. 超时和心跳配置</strong></p>\n<pre><code class=\"language-cpp\">signalr::signalr_client_config cfg;\ncfg.set_server_timeout(std::chrono::seconds(60));     // server expects 60s idle\ncfg.set_keepalive_interval(std::chrono::seconds(15)); // send ping every 15s\ncfg.set_handshake_timeout(std::chrono::seconds(5));   // short handshake timeout\n\n// IMPORTANT: Disable library's auto-reconnect! It has race condition bugs\ncfg.enable_auto_reconnect(false);\nconnection_-&gt;set_client_config(cfg);\n</code></pre>\n<p><strong>4. 连接确认和自动注册</strong></p>\n<pre><code class=\"language-cpp\">// Register Notification handler to confirm connection\nconnection_-&gt;on(\"Notification\", [this](const std::vector&lt;signalr::value&gt;&amp; args) {\n    if (args.empty()) return;\n    \n    std::string message = args[0].as_string();\n    ESP_LOGI(TAG, \"🔔 Notification from server: %s\", message.c_str());\n    \n    if (!connection_confirmed_) {\n        connection_confirmed_ = true;\n        ESP_LOGI(TAG, \"✓✓✓ SIGNALR CONNECTION CONFIRMED BY SERVER! ✓✓✓\");\n        \n        // 🔄 Auto-register device info after connection confirmed\n        std::string mac_address = DeviceInfo::GetMacAddress();\n        std::string metadata = DeviceInfo::BuildMetadataJson();\n        \n        RegisterDevice(mac_address, \"\", metadata, [](bool success, const std::string&amp; result) {\n            if (success) {\n                ESP_LOGI(TAG, \"✅ Device auto-registration successful\");\n            }\n        });\n    }\n});\n</code></pre>\n<p><strong>5. 自定义消息处理</strong></p>\n<pre><code class=\"language-cpp\">connection_-&gt;on(\"CustomMessage\", [this](const std::vector&lt;signalr::value&gt;&amp; args) {\n    if (args.empty()) return;\n    \n    try {\n        std::string json_str = args[0].as_string();\n        ESP_LOGI(TAG, \"📨 Received CustomMessage: %s\", json_str.c_str());\n        \n        auto root = cJSON_Parse(json_str.c_str());\n        if (root) {\n            if (on_custom_message_) {\n                on_custom_message_(root);  // 调用用户设置的回调\n            }\n            cJSON_Delete(root);\n        }\n    } catch (const std::exception&amp; e) {\n        ESP_LOGE(TAG, \"Exception handling CustomMessage: %s\", e.what());\n    }\n});\n</code></pre>\n<p><strong>6. 自动重连机制</strong> - 使用PSRAM栈的后台任务</p>\n<pre><code class=\"language-cpp\">void SignalRClient::StartReconnectTask() {\n    ESP_LOGI(TAG, \"Starting SignalR reconnect background task (PSRAM stack)...\");\n    reconnect_task_running_.store(true, std::memory_order_release);\n    \n    // Allocate task stack from PSRAM (reusable)\n    reconnect_task_stack_ = (StackType_t*)heap_caps_malloc(\n        RECONNECT_TASK_STACK_SIZE, MALLOC_CAP_SPIRAM);\n    \n    // Create task with static allocation (stack in PSRAM)\n    reconnect_task_handle_ = xTaskCreateStatic(\n        ReconnectTaskEntry, \"signalr_reconn\",\n        RECONNECT_TASK_STACK_SIZE / sizeof(StackType_t),\n        this, 2, reconnect_task_stack_, reconnect_task_buffer_\n    );\n}\n\nvoid SignalRClient::ReconnectTaskLoop() {\n    while (reconnect_task_running_.load(std::memory_order_acquire)) {\n        vTaskDelay(pdMS_TO_TICKS(1000));\n        \n        if (!reconnect_requested_.load() || IsConnected()) {\n            continue;\n        }\n        \n        // Apply exponential backoff\n        ESP_LOGI(TAG, \"Attempting connection (backoff=%dms)...\", reconnect_backoff_ms_);\n        \n        if (Connect() &amp;&amp; IsConnected()) {\n            reconnect_backoff_ms_ = 1000;  // Reset backoff on success\n        } else {\n            vTaskDelay(pdMS_TO_TICKS(reconnect_backoff_ms_));\n            reconnect_backoff_ms_ = std::min(reconnect_backoff_ms_ * 2, \n                MAX_RECONNECT_BACKOFF_MS);  // Exponential backoff\n        }\n    }\n}\n</code></pre>\n<p><strong>7. 设备注册和心跳</strong></p>\n<pre><code class=\"language-cpp\">void SignalRClient::RegisterDevice(\n    const std::string&amp; mac_address,\n    const std::string&amp; device_token,\n    const std::string&amp; metadata,\n    std::function&lt;void(bool, const std::string&amp;)&gt; callback) {\n    \n    if (!IsConnected()) {\n        if (callback) callback(false, \"Not connected\");\n        return;\n    }\n    \n    std::vector&lt;signalr::value&gt; args;\n    args.push_back(signalr::value(mac_address));\n    args.push_back(signalr::value(device_token));\n    args.push_back(signalr::value(metadata));\n    \n    connection_-&gt;invoke(\"RegisterDevice\", args,\n        [callback](const signalr::value&amp; result, std::exception_ptr ex) {\n            if (ex) {\n                if (callback) callback(false, \"Registration failed\");\n            } else {\n                if (callback) callback(true, \"Registration sent\");\n            }\n        });\n}\n\nvoid SignalRClient::SendHeartbeat(\n    std::function&lt;void(bool, const std::string&amp;)&gt; callback) {\n    \n    if (!IsConnected()) {\n        if (callback) callback(false, \"Not connected\");\n        return;\n    }\n    \n    std::vector&lt;signalr::value&gt; args;\n    connection_-&gt;invoke(\"Heartbeat\", args,\n        [callback](const signalr::value&amp; result, std::exception_ptr ex) {\n            if (!ex) {\n                ESP_LOGD(TAG, \"💓 Heartbeat sent\");\n                if (callback) callback(true, \"Success\");\n            }\n        });\n}\n</code></pre>\n<p><strong>SignalR客户端类定义</strong> (signalr_client.h):</p>\n<pre><code class=\"language-cpp\">class SignalRClient {\npublic:\n    static SignalRClient&amp; GetInstance();\n    \n    // 连接管理\n    bool Initialize(const std::string&amp; hub_url, const std::string&amp; token);\n    bool Connect();\n    void Disconnect();\n    void Reset();\n    void RequestReconnect();\n    \n    // 状态查询\n    bool IsInitialized() const;\n    bool IsConnecting() const;\n    bool IsConnected() const;\n    std::string GetConnectionState() const;\n    \n    // 回调设置\n    void OnCustomMessage(std::function&lt;void(const cJSON*)&gt; callback);\n    void OnDeviceRegistered(std::function&lt;void(const cJSON*)&gt; callback);\n    \n    // Hub方法调用\n    void RegisterDevice(const std::string&amp; mac_address,\n                       const std::string&amp; device_token,\n                       const std::string&amp; metadata,\n                       std::function&lt;void(bool, const std::string&amp;)&gt; callback);\n    void SendHeartbeat(std::function&lt;void(bool, const std::string&amp;)&gt; callback);\n    void InvokeHubMethod(const std::string&amp; method_name,\n                        const std::string&amp; args_json,\n                        std::function&lt;void(bool, const std::string&amp;)&gt; callback);\n\nprivate:\n    SignalRClient();\n    ~SignalRClient();\n    \n    std::unique_ptr&lt;signalr::hub_connection&gt; connection_;\n    std::string hub_url_;\n    std::string token_;\n    bool initialized_ = false;\n    bool connection_confirmed_ = false;\n    std::atomic&lt;bool&gt; reconnect_requested_{false};\n    \n    // 回调函数\n    std::function&lt;void(const cJSON*)&gt; on_custom_message_;\n    std::function&lt;void(const cJSON*)&gt; on_device_registered_;\n    \n    // 重连任务\n    TaskHandle_t reconnect_task_handle_ = nullptr;\n    int reconnect_backoff_ms_ = 1000;\n};\n</code></pre>\n<p><strong>使用示例</strong>：</p>\n<pre><code class=\"language-cpp\">// 在主应用中使用SignalR客户端\nvoid Application::InitializeSignalR() {\n    auto&amp; client = SignalRClient::GetInstance();\n    \n    // 设置消息回调\n    client.OnCustomMessage([this](const cJSON* json) {\n        ESP_LOGI(TAG, \"Received message from server\");\n        HandleServerMessage(json);\n    });\n    \n    // 初始化并连接\n    std::string hub_url = \"wss://your-server.com/devicehub\";\n    std::string token = GetJwtToken();  // 从NVS读取或扫码获取\n    \n    if (client.Initialize(hub_url, token)) {\n        if (client.Connect()) {\n            client.RequestReconnect();  // 启动自动重连任务\n        }\n    }\n}\n</code></pre>\n<h5 id=\"application层集成代码\">Application层集成代码</h5>\n<p><strong>核心代码片段</strong> (application.cc):</p>\n<pre><code class=\"language-cpp\">\nvoid Application::HandleSignalRMessage(const std::string&amp; message) {\n    ESP_LOGI(TAG, \"Handling SignalR message: %s\", message.c_str());\n    \n    auto root = cJSON_Parse(message.c_str());\n    if (!root) {\n        ESP_LOGE(TAG, \"Failed to parse SignalR message JSON\");\n        return;\n    }\n    \n    auto display = Board::GetInstance().GetDisplay();\n    \n    // Check message action/type\n    auto action = cJSON_GetObjectItem(root, \"action\");\n    if (cJSON_IsString(action)) {\n        if (strcmp(action-&gt;valuestring, \"notification\") == 0) {\n            // Handle notification\n            // JSON: {\"action\":\"notification\", \"title\":\"标题\", \"content\":\"内容\", \"emotion\":\"bell\", \"sound\":\"popup\"}\n            auto title = cJSON_GetObjectItem(root, \"title\");\n            auto content = cJSON_GetObjectItem(root, \"content\");\n            auto emotion = cJSON_GetObjectItem(root, \"emotion\");\n            auto sound = cJSON_GetObjectItem(root, \"sound\");\n            \n            const char* title_str = cJSON_IsString(title) ? title-&gt;valuestring : Lang::Strings::INFO;\n            const char* content_str = cJSON_IsString(content) ? content-&gt;valuestring : \"\";\n            const char* emotion_str = cJSON_IsString(emotion) ? emotion-&gt;valuestring : \"bell\";\n            \n            // Select sound based on \"sound\" field\n            std::string_view sound_view = Lang::Sounds::OGG_POPUP;\n            if (cJSON_IsString(sound)) {\n                if (strcmp(sound-&gt;valuestring, \"success\") == 0) {\n                    sound_view = Lang::Sounds::OGG_SUCCESS;\n                } else if (strcmp(sound-&gt;valuestring, \"vibration\") == 0) {\n                    sound_view = Lang::Sounds::OGG_VIBRATION;\n                } else if (strcmp(sound-&gt;valuestring, \"exclamation\") == 0) {\n                    sound_view = Lang::Sounds::OGG_EXCLAMATION;\n                } else if (strcmp(sound-&gt;valuestring, \"low_battery\") == 0) {\n                    sound_view = Lang::Sounds::OGG_LOW_BATTERY;\n                } else if (strcmp(sound-&gt;valuestring, \"none\") == 0) {\n                    sound_view = \"\";\n                }\n                // default: popup\n            }\n            \n            Alert(title_str, content_str, emotion_str, sound_view);\n            \n        } else if (strcmp(action-&gt;valuestring, \"command\") == 0) {\n            // Handle command\n            // JSON: {\"action\":\"command\", \"command\":\"reboot|wake|listen|stop\"}\n            auto cmd = cJSON_GetObjectItem(root, \"command\");\n            if (cJSON_IsString(cmd)) {\n                if (strcmp(cmd-&gt;valuestring, \"reboot\") == 0) {\n                    Reboot();\n                } else if (strcmp(cmd-&gt;valuestring, \"wake\") == 0) {\n                    // Trigger wake word detection\n                    xEventGroupSetBits(event_group_, MAIN_EVENT_WAKE_WORD_DETECTED);\n                } else if (strcmp(cmd-&gt;valuestring, \"listen\") == 0) {\n                    StartListening();\n                } else if (strcmp(cmd-&gt;valuestring, \"stop\") == 0) {\n                    StopListening();\n                } else {\n                    ESP_LOGW(TAG, \"Unknown SignalR command: %s\", cmd-&gt;valuestring);\n                }\n            }\n            \n        } else if (strcmp(action-&gt;valuestring, \"display\") == 0) {\n            // Display custom content\n            // JSON: {\"action\":\"display\", \"content\":\"文本内容\", \"role\":\"system\"}\n            auto content = cJSON_GetObjectItem(root, \"content\");\n            auto role = cJSON_GetObjectItem(root, \"role\");\n            const char* role_str = cJSON_IsString(role) ? role-&gt;valuestring : \"system\";\n            if (cJSON_IsString(content)) {\n                display-&gt;SetChatMessage(role_str, content-&gt;valuestring);\n            }\n            \n        } else if (strcmp(action-&gt;valuestring, \"emotion\") == 0) {\n            // Change emotion/expression\n            // JSON: {\"action\":\"emotion\", \"emotion\":\"happy\"}\n            auto emotion = cJSON_GetObjectItem(root, \"emotion\");\n            if (cJSON_IsString(emotion)) {\n                display-&gt;SetEmotion(emotion-&gt;valuestring);\n            }\n            \n        } else if (strcmp(action-&gt;valuestring, \"image\") == 0) {\n            // Display image from URL\n            // JSON: {\"action\":\"image\", \"url\":\"https://example.com/image.jpg\"}\n            auto url = cJSON_GetObjectItem(root, \"url\");\n            if (cJSON_IsString(url)) {\n                HandleSignalRImageMessage(url-&gt;valuestring);\n            } else {\n                ESP_LOGW(TAG, \"Image action requires 'url' field\");\n            }\n            \n        } else if (strcmp(action-&gt;valuestring, \"audio\") == 0) {\n            // Play audio from URL (OGG format)\n            // JSON: {\"action\":\"audio\", \"url\":\"https://example.com/sound.ogg\"}\n            auto url = cJSON_GetObjectItem(root, \"url\");\n            if (cJSON_IsString(url)) {\n                HandleSignalRAudioMessage(url-&gt;valuestring);\n            } else {\n                ESP_LOGW(TAG, \"Audio action requires 'url' field\");\n            }\n            \n        } else if (strcmp(action-&gt;valuestring, \"qrcode\") == 0) {\n            // Show QR code\n            // JSON: {\"action\":\"qrcode\", \"data\":\"https://...\", \"title\":\"标题\", \"subtitle\":\"副标题\"}\n            auto data = cJSON_GetObjectItem(root, \"data\");\n            auto title = cJSON_GetObjectItem(root, \"title\");\n            auto subtitle = cJSON_GetObjectItem(root, \"subtitle\");\n            if (cJSON_IsString(data)) {\n                const char* title_str = cJSON_IsString(title) ? title-&gt;valuestring : nullptr;\n                const char* subtitle_str = cJSON_IsString(subtitle) ? subtitle-&gt;valuestring : nullptr;\n                display-&gt;ShowQRCode(data-&gt;valuestring, title_str, subtitle_str);\n            } else {\n                ESP_LOGW(TAG, \"QRCode action requires 'data' field\");\n            }\n            \n        } else if (strcmp(action-&gt;valuestring, \"hide_qrcode\") == 0) {\n            // Hide QR code\n            // JSON: {\"action\":\"hide_qrcode\"}\n            display-&gt;HideQRCode();\n            \n        } else {\n            // Default: display as system message\n            char* display_str = cJSON_Print(root);\n            if (display_str) {\n                display-&gt;SetChatMessage(\"system\", display_str);\n                cJSON_free(display_str);\n            }\n        }\n    } else {\n        // No action specified, display raw message\n        char* display_str = cJSON_Print(root);\n        if (display_str) {\n            display-&gt;SetChatMessage(\"system\", display_str);\n            cJSON_free(display_str);\n        }\n    }\n    \n    cJSON_Delete(root);\n}\n\n</code></pre>\n<p><strong>完整的Application类功能</strong>：</p>\n<ul>\n<li>✅ 设备状态管理 (状态机)</li>\n<li>✅ 网络事件处理 (连接/断开)</li>\n<li>✅ 音频服务集成 (编解码、流处理)</li>\n<li>✅ 唤醒词检测</li>\n<li>✅ 协议层抽象 (WebSocket/MQTT)</li>\n<li>✅ MCP消息路由</li>\n<li>✅ 错误处理和恢复</li>\n<li>✅ 资源管理和清理</li>\n<li>✅ 线程安全的消息调度</li>\n</ul>\n<h4 id=\"522-mcp服务器代码-verdure-mcp\">5.2.2 MCP服务器代码 (verdure-mcp)</h4>\n<p><strong>仓库地址</strong>：<a href=\"https://github.com/maker-community/verdure-mcp\" rel=\"noopener nofollow\" target=\"_blank\">verdure-mcp</a></p>\n<p><strong>目录结构</strong>：</p>\n<pre><code>src/Verdure.Mcp.Server/\n├── Hubs/\n│   └── DeviceHub.cs          # SignalR Hub实现\n├── Tools/\n│   ├── MusicTool.cs          # 音乐播放控制\n│   ├── EmailTool.cs          # 邮件发送\n│   ├── WeatherTool.cs        # 天气查询\n│   └── SmartHomeTool.cs      # 智能家居控制\n├── Services/\n│   ├── DeviceService.cs      # 设备管理服务\n│   ├── McpExecutor.cs        # MCP工具执行器\n│   └── TokenService.cs       # JWT令牌服务\n└── Models/\n    ├── DeviceConnection.cs   # 设备连接记录\n    ├── DeviceInfo.cs         # 设备信息\n    └── McpToolLog.cs         # 工具调用日志\n</code></pre>\n<p><strong>DeviceHub完整实现</strong> (Hubs/DeviceHub.cs):</p>\n<p>生产环境的DeviceHub实际实现特点：</p>\n<ul>\n<li>✅ 数据库持久化 (Entity Framework Core + PostgreSQL)</li>\n<li>✅ 设备注册和状态跟踪</li>\n<li>✅ 用户和设备分组管理</li>\n<li>✅ 心跳检测</li>\n<li>✅ 双重认证 (JWT + API Token)</li>\n<li>✅ 完善的异常处理和日志</li>\n</ul>\n<pre><code class=\"language-csharp\">using Microsoft.AspNetCore.SignalR;\nusing Verdure.Mcp.Infrastructure.Database;\nusing Verdure.Mcp.Infrastructure.Services;\n\nnamespace Verdure.Mcp.Server.Hubs;\n\n/// &lt;summary&gt;\n/// 设备连接Hub - 处理ESP32等IoT设备的SignalR连接\n/// &lt;/summary&gt;\npublic class DeviceHub : Hub\n{\n    private readonly McpDbContext _dbContext;\n    private readonly ITokenValidationService _tokenValidationService;\n    private readonly ILogger&lt;DeviceHub&gt; _logger;\n\n    public DeviceHub(\n        McpDbContext dbContext,\n        ITokenValidationService tokenValidationService,\n        ILogger&lt;DeviceHub&gt; logger)\n    {\n        _dbContext = dbContext;\n        _tokenValidationService = tokenValidationService;\n        _logger = logger;\n    }\n\n    /// &lt;summary&gt;\n    /// 设备连接 - 支持JWT和API Token双重认证\n    /// &lt;/summary&gt;\n    public override async Task OnConnectedAsync()\n    {\n        try\n        {\n            var httpContext = Context.GetHttpContext();\n            if (httpContext == null)\n            {\n                _logger.LogWarning(\"HttpContext is null\");\n                Context.Abort();\n                return;\n            }\n\n            // 从查询参数获取token\n            var token = httpContext.Request.Query[\"access_token\"].ToString();\n            if (string.IsNullOrEmpty(token))\n            {\n                _logger.LogWarning(\"Connection attempt without token\");\n                Context.Abort();\n                return;\n            }\n\n            // 验证token - 支持JWT和API Token\n            var validationResult = await _tokenValidationService.ValidateTokenAsync(token);\n            if (!validationResult.IsValid)\n            {\n                _logger.LogWarning(\"Invalid token: {Reason}\", validationResult.FailureReason);\n                Context.Abort();\n                return;\n            }\n\n            var userId = validationResult.UserId;\n            if (string.IsNullOrEmpty(userId))\n            {\n                _logger.LogWarning(\"Token valid but userId is missing\");\n                Context.Abort();\n                return;\n            }\n\n            // 将连接加入用户组 (格式: Users:{userId})\n            await Groups.AddToGroupAsync(Context.ConnectionId, $\"Users:{userId}\");\n\n            _logger.LogInformation(\n                \"Device connected: ConnectionId={ConnectionId}, UserId={UserId}\",\n                Context.ConnectionId, userId);\n\n            // 发送欢迎通知\n            await Clients.Caller.SendAsync(\"Notification\", \n                $\"Welcome! Connected to Verdure MCP Server at {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss}\");\n\n            await base.OnConnectedAsync();\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error in OnConnectedAsync\");\n            Context.Abort();\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 设备断开连接\n    /// &lt;/summary&gt;\n    public override async Task OnDisconnectedAsync(Exception? exception)\n    {\n        if (exception != null)\n        {\n            _logger.LogWarning(exception, \n                \"Device disconnected with error: ConnectionId={ConnectionId}\",\n                Context.ConnectionId);\n        }\n        else\n        {\n            _logger.LogInformation(\n                \"Device disconnected normally: ConnectionId={ConnectionId}\",\n                Context.ConnectionId);\n        }\n\n        await base.OnDisconnectedAsync(exception);\n    }\n\n    /// &lt;summary&gt;\n    /// 设备注册 - 保存设备MAC地址和元数据\n    /// &lt;/summary&gt;\n    public async Task RegisterDevice(string macAddress, string deviceToken, string metadata)\n    {\n        try\n        {\n            var userId = Context.Items[\"UserId\"]?.ToString();\n            if (string.IsNullOrEmpty(userId))\n            {\n                _logger.LogWarning(\"RegisterDevice called without userId\");\n                return;\n            }\n\n            _logger.LogInformation(\n                \"Device registration: UserId={UserId}, MAC={MacAddress}, Metadata={Metadata}\",\n                userId, macAddress, metadata);\n\n            // 将设备加入设备组 (格式: Device:{macAddress})\n            await Groups.AddToGroupAsync(Context.ConnectionId, $\"Device:{macAddress}\");\n\n            // 保存设备信息到数据库\n            var existingDevice = await _dbContext.Devices\n                .FirstOrDefaultAsync(d =&gt; d.MacAddress == macAddress);\n\n            if (existingDevice != null)\n            {\n                existingDevice.LastSeenAt = DateTime.UtcNow;\n                existingDevice.Metadata = metadata;\n                existingDevice.IsOnline = true;\n            }\n            else\n            {\n                _dbContext.Devices.Add(new Device\n                {\n                    MacAddress = macAddress,\n                    UserId = userId,\n                    Metadata = metadata,\n                    IsOnline = true,\n                    CreatedAt = DateTime.UtcNow,\n                    LastSeenAt = DateTime.UtcNow\n                });\n            }\n\n            await _dbContext.SaveChangesAsync();\n\n            // 确认注册成功\n            await Clients.Caller.SendAsync(\"Notification\", \n                $\"Device registered successfully: {macAddress}\");\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error in RegisterDevice\");\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 心跳保持\n    /// &lt;/summary&gt;\n    public async Task Heartbeat()\n    {\n        _logger.LogDebug(\"Heartbeat from ConnectionId={ConnectionId}\", Context.ConnectionId);\n        \n        // 更新最后活跃时间\n        // 注意：实际代码中可以根据ConnectionId查找设备并更新LastSeenAt\n        await Task.CompletedTask;\n    }\n}\n</code></pre>\n<p><strong>实际的MCP工具实现</strong> (不使用基类):</p>\n<p>在verdure-mcp中，MCP工具<strong>不继承任何基类</strong>，而是：</p>\n<ol>\n<li>使用 <code>[McpServerToolType]</code> 特性标记</li>\n<li>通过依赖注入获取 <code>IDevicePushService</code> 服务</li>\n<li>使用 <code>IDevicePushService</code> 的方法推送消息给设备</li>\n</ol>\n<p><strong>DevicePushService接口</strong> (Infrastructure/Services/DevicePushService.cs):</p>\n<pre><code class=\"language-csharp\">namespace Verdure.Mcp.Infrastructure.Services;\n\n/// &lt;summary&gt;\n/// 设备推送服务接口\n/// &lt;/summary&gt;\npublic interface IDevicePushService\n{\n    /// &lt;summary&gt;\n    /// 向用户的所有设备发送消息\n    /// &lt;/summary&gt;\n    Task SendToUserAsync(string userId, string method, object message, \n        CancellationToken cancellationToken = default);\n\n    /// &lt;summary&gt;\n    /// 向指定设备发送消息\n    /// &lt;/summary&gt;\n    Task SendToDeviceAsync(string deviceId, string method, object message, \n        CancellationToken cancellationToken = default);\n\n    /// &lt;summary&gt;\n    /// 发送自定义消息 (xiaozhi协议格式)\n    /// &lt;/summary&gt;\n    Task SendCustomMessageAsync(string userId, object message, \n        CancellationToken cancellationToken = default);\n\n    /// &lt;summary&gt;\n    /// 发送通知消息\n    /// &lt;/summary&gt;\n    Task SendNotificationAsync(string userId, string notificationMessage, \n        CancellationToken cancellationToken = default);\n}\n</code></pre>\n<p><strong>DevicePushService实现</strong> (Server/Services/DevicePushServiceImpl.cs):</p>\n<pre><code class=\"language-csharp\">using Microsoft.AspNetCore.SignalR;\nusing Verdure.Mcp.Server.Hubs;\nusing Verdure.Mcp.Infrastructure.Services;\nusing System.Text.Json;\n\nnamespace Verdure.Mcp.Server.Services;\n\npublic class DevicePushServiceImpl : IDevicePushService\n{\n    private readonly IHubContext&lt;DeviceHub&gt; _hubContext;\n    private readonly ILogger&lt;DevicePushServiceImpl&gt; _logger;\n\n    public DevicePushServiceImpl(\n        IHubContext&lt;DeviceHub&gt; hubContext,\n        ILogger&lt;DevicePushServiceImpl&gt; logger)\n    {\n        _hubContext = hubContext;\n        _logger = logger;\n    }\n\n    public async Task SendToUserAsync(string userId, string method, object message, \n        CancellationToken cancellationToken = default)\n    {\n        var groupName = $\"Users:{userId}\";\n        await _hubContext.Clients.Group(groupName)\n            .SendAsync(method, message, cancellationToken);\n        \n        _logger.LogInformation(\"Sent {Method} to user {UserId}\", method, userId);\n    }\n\n    public async Task SendToDeviceAsync(string deviceId, string method, object message, \n        CancellationToken cancellationToken = default)\n    {\n        var groupName = $\"Device:{deviceId}\";\n        await _hubContext.Clients.Group(groupName)\n            .SendAsync(method, message, cancellationToken);\n        \n        _logger.LogInformation(\"Sent {Method} to device {DeviceId}\", method, deviceId);\n    }\n\n    public async Task SendCustomMessageAsync(string userId, object message, \n        CancellationToken cancellationToken = default)\n    {\n        var groupName = $\"Users:{userId}\";\n        \n        // 重要！ESP32客户端期望接收JSON字符串，而不是对象\n        var jsonString = JsonSerializer.Serialize(message);\n        \n        await _hubContext.Clients.Group(groupName)\n            .SendAsync(\"CustomMessage\", jsonString, cancellationToken);\n        \n        _logger.LogInformation(\"Sent CustomMessage to user {UserId}: {Message}\", \n            userId, jsonString);\n    }\n\n    public async Task SendNotificationAsync(string userId, string notificationMessage, \n        CancellationToken cancellationToken = default)\n    {\n        var groupName = $\"Users:{userId}\";\n        await _hubContext.Clients.Group(groupName)\n            .SendAsync(\"Notification\", notificationMessage, cancellationToken);\n        \n        _logger.LogInformation(\"Sent notification to user {UserId}: {Message}\", \n            userId, notificationMessage);\n    }\n}\n</code></pre>\n<p><strong>音乐播放工具实际实现</strong> (Tools/MusicTool.cs):</p>\n<pre><code class=\"language-csharp\">using System;\nusing System.ComponentModel;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Verdure.Mcp.Server.Settings;\nusing ModelContextProtocol.Server;\nusing Verdure.Mcp.Infrastructure.Services;\nusing Verdure.Mcp.Server.Services;\nusing Hangfire;\n\nnamespace Verdure.Mcp.Server.Tools;\n\n/// &lt;summary&gt;\n/// MCP Tool to pick a random audio file from wwwroot and push its URL to device(s).\n/// &lt;/summary&gt;\n[McpServerToolType]\npublic class MusicTool\n{\n    private readonly IHttpContextAccessor _httpContextAccessor;\n    private readonly IWebHostEnvironment _env;\n    private readonly IDevicePushService _devicePushService;\n    private readonly ILogger&lt;MusicTool&gt; _logger;\n    private readonly IBackgroundJobClient _backgroundJobClient;\n    private readonly ImageStorageSettings _imageStorageSettings;\n\n    public MusicTool(\n        IHttpContextAccessor httpContextAccessor,\n        IWebHostEnvironment env,\n        IDevicePushService devicePushService,\n        ILogger&lt;MusicTool&gt; logger,\n        IBackgroundJobClient backgroundJobClient,\n        IOptions&lt;ImageStorageSettings&gt;? imageSettings = null)\n    {\n        _httpContextAccessor = httpContextAccessor;\n        _env = env;\n        _devicePushService = devicePushService;\n        _logger = logger;\n        _backgroundJobClient = backgroundJobClient;\n        _imageStorageSettings = imageSettings?.Value ?? new ImageStorageSettings();\n    }\n\n    /// &lt;summary&gt;\n    /// Select a random audio file from the `wwwroot/audio` folder and push it to the user\n    /// identified by the `X-User-Id` request header.\n    /// The pushed message follows the same shape as used in `test-send-message.ps1` (action = \"audio\", url = \"...\").\n    /// &lt;/summary&gt;\n    [McpServerTool(Name = \"play_random_music\")]\n    [Description(\"Plays a random audio file from wwwroot/audio by pushing an audio message to the user's devices\")]\n    public async Task&lt;MusicResponse&gt; PlayRandomMusic(CancellationToken cancellationToken = default)\n    {\n        try\n        {\n            var httpContext = _httpContextAccessor.HttpContext;\n            var effectiveUserId = httpContext?.Request.Headers[\"X-User-Id\"].FirstOrDefault();\n            if (string.IsNullOrEmpty(effectiveUserId))\n            {\n                _logger.LogWarning(\"No userId provided and X-User-Id header is missing\");\n                return new MusicResponse { Success = false, Message = \"Missing userId or X-User-Id header\" };\n            }\n\n            var webRoot = _env.WebRootPath ?? _env.ContentRootPath;\n            var folder = \"audios\";\n            var audioFolder = Path.Combine(webRoot, folder);\n\n            if (!Directory.Exists(audioFolder))\n            {\n                _logger.LogWarning(\"Audio folder does not exist: {AudioFolder}\", audioFolder);\n                return new MusicResponse { Success = false, Message = $\"Audio folder not found: {folder}\" };\n            }\n\n            // Find audio files (ogg, mp3) and pick a random one\n            var files = Directory.GetFiles(audioFolder)\n                .Where(f =&gt; f.EndsWith('.' + \"ogg\") || f.EndsWith('.' + \"mp3\") || f.EndsWith('.' + \"wav\"))\n                .ToArray();\n\n            if (files.Length == 0)\n            {\n                _logger.LogWarning(\"No audio files found in {AudioFolder}\", audioFolder);\n                return new MusicResponse { Success = false, Message = \"No audio files found\" };\n            }\n\n            var rnd = new Random();\n            var chosen = files[rnd.Next(files.Length)];\n            var fileName = Path.GetFileName(chosen);\n\n            string url;\n            // Prefer configured ImageStorage BaseUrl (keeps image and audio base URL consistent)\n            if (!string.IsNullOrWhiteSpace(_imageStorageSettings.BaseUrl))\n            {\n                var cfgBase = _imageStorageSettings.BaseUrl.TrimEnd('/');\n                url = $\"{cfgBase}/{folder}/{Uri.EscapeDataString(fileName)}\";\n            }\n            else\n            {\n                var req = httpContext?.Request;\n                var hostBase = req != null ? $\"{req.Scheme}://{req.Host.Value}\" : string.Empty;\n                url = string.IsNullOrEmpty(hostBase)\n                    ? $\"/{folder}/{Uri.EscapeDataString(fileName)}\"\n                    : $\"{hostBase}/{folder}/{Uri.EscapeDataString(fileName)}\";\n            }\n\n            var title = Path.GetFileNameWithoutExtension(fileName);\n\n            var message = new\n            {\n                action = \"audio\",\n                url,\n                title\n            };\n\n            // Schedule push as a delayed background job so device can play result first.\n            try\n            {\n\n                var jobDelay = TimeSpan.FromSeconds(5);\n\n                _logger.LogInformation(\"Scheduling audio push to user {UserId} after {Delay}s: {Url}\",\n                    effectiveUserId, jobDelay.TotalSeconds, url);\n\n                _backgroundJobClient.Schedule&lt;MusicPushBackgroundJob&gt;(\n                    job =&gt; job.ExecuteAsync(effectiveUserId, url, title, CancellationToken.None),\n                    jobDelay);\n\n                return new MusicResponse { Success = true, Message = \"Audio scheduled\", Url = url, FileName = fileName };\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to schedule audio push for user {UserId}\", effectiveUserId);\n                return new MusicResponse { Success = false, Message = ex.Message };\n            }\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed to play random music\");\n            return new MusicResponse { Success = false, Message = ex.Message };\n        }\n    }\n}\n\npublic class MusicResponse\n{\n    public bool Success { get; set; }\n    public required string Message { get; set; }\n    public string? Url { get; set; }\n    public string? FileName { get; set; }\n}\n\n</code></pre>\n<p><strong>延迟推送后台任务</strong> (Tools/MusicPushBackgroundJob.cs):</p>\n<pre><code class=\"language-csharp\">using Verdure.Mcp.Infrastructure.Services;\nusing Verdure.Mcp.Server.Services;\n\nnamespace Verdure.Mcp.Server.Tools;\n\n/// &lt;summary&gt;\n/// Background job to push music/audio messages to user devices after a delay.\n/// &lt;/summary&gt;\npublic class MusicPushBackgroundJob\n{\n    private readonly IDevicePushService _devicePushService;\n    private readonly ILogger&lt;MusicPushBackgroundJob&gt; _logger;\n\n    public MusicPushBackgroundJob(IDevicePushService devicePushService, ILogger&lt;MusicPushBackgroundJob&gt; logger)\n    {\n        _devicePushService = devicePushService;\n        _logger = logger;\n    }\n\n    public async Task ExecuteAsync(string userId, string url, string title, CancellationToken cancellationToken)\n    {\n        _logger.LogInformation(\"Executing MusicPushBackgroundJob: user={UserId}, url={Url}\", userId, url);\n\n        var message = new\n        {\n            action = \"audio\",\n            url,\n            title\n        };\n\n        try\n        {\n            await _devicePushService.SendCustomMessageAsync(userId, message, cancellationToken);\n            _logger.LogInformation(\"Music pushed to user {UserId}\", userId);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed to push music to user {UserId}\", userId);\n        }\n    }\n}\n\n</code></pre>\n<h4 id=\"523-图片生成工具实现示例\">5.2.3 图片生成工具实现示例</h4>\n<p><strong>仓库地址</strong>：<a href=\"https://github.com/maker-community/verdure-mcp/blob/main/src/Verdure.Mcp.Server/Tools/GenerateImageTool.cs\" rel=\"noopener nofollow\" target=\"_blank\">verdure-mcp - GenerateImageTool</a></p>\n<p>这个工具展示了如何生成图片并推送到设备：</p>\n<pre><code class=\"language-csharp\">using System.ComponentModel;\nusing System.Net;\nusing Hangfire;\nusing Microsoft.EntityFrameworkCore;\nusing ModelContextProtocol.Server;\nusing Verdure.Mcp.Domain.Entities;\nusing Verdure.Mcp.Domain.Enums;\nusing Verdure.Mcp.Infrastructure.Data;\nusing Verdure.Mcp.Infrastructure.Services;\nusing Verdure.Mcp.Server.Services;\n\nnamespace Verdure.Mcp.Server.Tools;\n\n/// &lt;summary&gt;\n/// 使用 Azure OpenAI DALL-E 生成图片的 MCP 工具\n/// &lt;/summary&gt;\n[McpServerToolType]\npublic class GenerateImageTool\n{\n    private readonly IImageGenerationService _imageGenerationService;\n    private readonly IEmailService _emailService;\n    private readonly McpDbContext _dbContext;\n    private readonly IBackgroundJobClient _backgroundJobClient;\n    private readonly IHttpContextAccessor _httpContextAccessor;\n    private readonly IImageStorageService _imageStorageService;\n    private readonly IDevicePushService _devicePushService;\n    private readonly ILogger&lt;GenerateImageTool&gt; _logger;\n\n    public GenerateImageTool(\n        IImageGenerationService imageGenerationService,\n        IEmailService emailService,\n        McpDbContext dbContext,\n        IBackgroundJobClient backgroundJobClient,\n        IHttpContextAccessor httpContextAccessor,\n        IImageStorageService imageStorageService,\n        IDevicePushService devicePushService,\n        ILogger&lt;GenerateImageTool&gt; logger)\n    {\n        _imageGenerationService = imageGenerationService;\n        _emailService = emailService;\n        _dbContext = dbContext;\n        _backgroundJobClient = backgroundJobClient;\n        _httpContextAccessor = httpContextAccessor;\n        _imageStorageService = imageStorageService;\n        _devicePushService = devicePushService;\n        _logger = logger;\n    }\n\n    /// &lt;summary&gt;\n    /// 使用 Azure OpenAI DALL-E 根据提示词生成图片。\n    /// 如果提供邮箱地址，会将生成的图片发送到指定邮箱。\n    /// 如果请求头中包含用户信息（X-User-Email 和 X-User-Id），任务将异步运行。\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"prompt\"&gt;描述要生成图片的文本提示词&lt;/param&gt;\n    /// &lt;param name=\"size\"&gt;图片尺寸：\"1024x1024\"、\"1792x1024\" 或 \"1024x1792\"，默认为 \"1024x1024\"&lt;/param&gt;\n    /// &lt;param name=\"quality\"&gt;图片质量：\"standard\" 或 \"hd\"，默认为 \"standard\"&lt;/param&gt;\n    /// &lt;param name=\"style\"&gt;图片风格：\"vivid\" 或 \"natural\"，默认为 \"vivid\"&lt;/param&gt;\n    /// &lt;param name=\"cancellationToken\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;包含任务信息和图片数据的 JSON 对象（同步模式下）&lt;/returns&gt;\n    [McpServerTool(Name = \"generate_image\")]\n    [Description(\"使用 DALL-E 模型，根据文本提示词生成图片。支持邮件通知和异步处理。\")]\n    public async Task&lt;ImageGenerationResponse&gt; GenerateImage(\n        [Description(\"描述要生成图片的文本提示词\")] string prompt,\n        [Description(\"图片尺寸：'1024x1024'、'1792x1024' 或 '1024x1792'，默认为 '1024x1024'\")] string? size = null,\n        [Description(\"图片质量：'standard' 或 'hd'，默认为 'standard'\")] string? quality = null,\n        [Description(\"图片风格：'vivid' 或 'natural'，默认为 'vivid'\")] string? style = null,\n        CancellationToken cancellationToken = default)\n    {\n        var httpContext = _httpContextAccessor.HttpContext;\n        \n        // 从请求头提取邮箱地址 (X-User-Email)\n        var email = httpContext?.Request.Headers[\"X-User-Email\"].FirstOrDefault();\n        \n        // 从请求头提取用户 ID (X-User-Id)\n        var userId = httpContext?.Request.Headers[\"X-User-Id\"].FirstOrDefault();\n\n        _logger.LogInformation(\"收到图片生成请求。提示词: {Prompt}, 邮箱: {Email}, 用户ID: {UserId}\", \n            prompt, email ?? \"无\", userId ?? \"无\");\n\n        // 创建任务记录\n        var task = new ImageGenerationTask\n        {\n            Id = Guid.NewGuid(),\n            Prompt = prompt,\n            Size = size ?? \"1024x1024\",\n            Quality = quality ?? \"standard\",\n            Style = style ?? \"vivid\",\n            Status = ImageTaskStatus.Pending,\n            Email = email,\n            UserId = userId,\n            CreatedAt = DateTime.UtcNow\n        };\n\n        _dbContext.ImageGenerationTasks.Add(task);\n        await _dbContext.SaveChangesAsync(cancellationToken);\n\n        // 如果存在用户信息（X-User-Email 和 X-User-Id），使用 Hangfire 异步处理\n        if (!string.IsNullOrEmpty(email) &amp;&amp; !string.IsNullOrEmpty(userId))\n        {\n            _logger.LogInformation(\"检测到用户信息，使用异步处理任务 {TaskId}\", task.Id);\n            \n            var jobId = _backgroundJobClient.Enqueue&lt;ImageGenerationBackgroundJob&gt;(\n                job =&gt; job.ExecuteAsync(task.Id, CancellationToken.None));\n            \n            task.HangfireJobId = jobId;\n            task.Status = ImageTaskStatus.Processing;\n            await _dbContext.SaveChangesAsync(cancellationToken);\n\n            return new ImageGenerationResponse\n            {\n                TaskId = task.Id,\n                Status = \"处理中\",\n                Message = \"图片生成任务已加入队列。如果您提供了邮箱地址，稍后会收到生成结果。\",\n                IsAsync = true\n            };\n        }\n        else\n        {\n            // 同步处理\n            _logger.LogInformation(\"未检测到完整用户信息，使用同步处理任务 {TaskId}\", task.Id);\n            \n            task.Status = ImageTaskStatus.Processing;\n            await _dbContext.SaveChangesAsync(cancellationToken);\n\n            try\n            {\n                var result = await _imageGenerationService.GenerateImageAsync(\n                    prompt, size, quality, style, cancellationToken);\n\n                if (result.Success)\n                {\n                    task.Status = ImageTaskStatus.Completed;\n                    task.ImageData = result.ImageBase64;\n                    task.CompletedAt = DateTime.UtcNow;\n                    task.UpdatedAt = DateTime.UtcNow;\n\n                    // 保存图片到本地文件系统（PNG + JPEG）\n                    ImageStorageResult? storageResult = null;\n                    if (!string.IsNullOrEmpty(result.ImageBase64))\n                    {\n                        try\n                        {\n                            storageResult = await _imageStorageService.SaveImageAsync(\n                                result.ImageBase64, \n                                task.Id, \n                                cancellationToken);\n                            task.ImageUrl = storageResult.PngUrl; // 数据库保存 PNG URL\n                            _logger.LogInformation(\n                                \"图片已保存 - PNG: {PngUrl}, JPEG: {JpegUrl}, 压缩率: {CompressionRatio:F1}%\",\n                                storageResult.PngUrl, storageResult.JpegUrl, storageResult.CompressionRatio);\n                        }\n                        catch (Exception ex)\n                        {\n                            _logger.LogError(ex, \"保存图片到本地失败，任务 {TaskId}\", task.Id);\n                            // 即使保存失败，仍然继续流程\n                        }\n                    }\n\n                    await _dbContext.SaveChangesAsync(cancellationToken);\n\n                    // 如果提供了邮箱，发送邮件\n                    if (!string.IsNullOrEmpty(email) &amp;&amp; !string.IsNullOrEmpty(result.ImageBase64))\n                    {\n                        try\n                        {\n                            var imageBytes = Convert.FromBase64String(result.ImageBase64);\n                            var encodedPrompt = WebUtility.HtmlEncode(prompt);\n                            var encodedRevisedPrompt = WebUtility.HtmlEncode(result.RevisedPrompt ?? \"无\");\n                            await _emailService.SendImageEmailAsync(\n                                email,\n                                \"您的图片已生成\",\n                                $\"&lt;h1&gt;您的图片已成功生成！&lt;/h1&gt;&lt;p&gt;提示词：{encodedPrompt}&lt;/p&gt;&lt;p&gt;修订后的提示词：{encodedRevisedPrompt}&lt;/p&gt;\",\n                                imageBytes,\n                                $\"image_{task.Id}.png\",\n                                cancellationToken);\n                            \n                            task.EmailSent = true;\n                            await _dbContext.SaveChangesAsync(cancellationToken);\n                        }\n                        catch (Exception ex)\n                        {\n                            _logger.LogError(ex, \"发送邮件失败，任务 {TaskId}\", task.Id);\n                        }\n                    }\n\n                    // 如果有用户 ID，推送到用户设备（使用 JPEG 版本，符合 xiaozhi 协议）\n                    if (!string.IsNullOrEmpty(userId) &amp;&amp; storageResult != null)\n                    {\n                        try\n                        {\n                            // 1. 先发送通知消息\n                            var notificationMessage = new\n                            {\n                                action = \"notification\",\n                                title = \"图片生成完成\",\n                                content = $\"您的图片已生成：{prompt.Substring(0, Math.Min(30, prompt.Length))}...\",\n                                emotion = \"happy\",\n                                sound = \"success\"\n                            };\n                            await _devicePushService.SendCustomMessageAsync(userId, notificationMessage, cancellationToken);\n                            \n                            // 2. 再发送图片消息（ESP32 期望的格式 - xiaozhi 协议）\n                            var imageMessage = new\n                            {\n                                action = \"image\",\n                                url = storageResult.JpegUrl,  // 使用 JPEG URL（体积小）\n                                // 扩展信息（可选，ESP32 可以忽略）\n                                taskId = task.Id.ToString(),\n                                pngUrl = storageResult.PngUrl,\n                                prompt = prompt,\n                                jpegSize = storageResult.JpegSize,\n                                timestamp = DateTime.UtcNow\n                            };\n\n                            await _devicePushService.SendCustomMessageAsync(userId, imageMessage, cancellationToken);\n                            _logger.LogInformation(\n                                \"已推送图片到用户 {UserId} 的设备，任务 {TaskId}，JPEG URL: {JpegUrl} ({JpegSize} bytes)\", \n                                userId, task.Id, storageResult.JpegUrl, storageResult.JpegSize);\n                        }\n                        catch (Exception ex)\n                        {\n                            _logger.LogError(ex, \"推送消息到设备失败，用户 {UserId}，任务 {TaskId}\", userId, task.Id);\n                        }\n                    }\n\n                    // 同步模式：返回 PNG URL（完整质量）\n                    return new ImageGenerationResponse\n                    {\n                        TaskId = task.Id,\n                        Status = \"已完成\",\n                        Message = \"图片生成成功\",\n                        ImageUrl = storageResult?.PngUrl ?? result.ImageUrl,\n                        RevisedPrompt = result.RevisedPrompt,\n                        IsAsync = false\n                    };\n                }\n                else\n                {\n                    task.Status = ImageTaskStatus.Failed;\n                    task.ErrorMessage = result.ErrorMessage;\n                    task.UpdatedAt = DateTime.UtcNow;\n                    await _dbContext.SaveChangesAsync(cancellationToken);\n\n                    return new ImageGenerationResponse\n                    {\n                        TaskId = task.Id,\n                        Status = \"失败\",\n                        Message = result.ErrorMessage ?? \"图片生成失败\",\n                        IsAsync = false\n                    };\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"同步生成图片时出错，任务 {TaskId}\", task.Id);\n                \n                task.Status = ImageTaskStatus.Failed;\n                task.ErrorMessage = ex.Message;\n                task.UpdatedAt = DateTime.UtcNow;\n                await _dbContext.SaveChangesAsync(cancellationToken);\n\n                return new ImageGenerationResponse\n                {\n                    TaskId = task.Id,\n                    Status = \"失败\",\n                    Message = ex.Message,\n                    IsAsync = false\n                };\n            }\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 获取图片生成任务的状态\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"taskId\"&gt;要查询的任务 ID&lt;/param&gt;\n    /// &lt;returns&gt;任务状态和结果（如果已完成）&lt;/returns&gt;\n    [McpServerTool(Name = \"get_image_task_status\")]\n    [Description(\"获取图片生成任务的状态\")]\n    public async Task&lt;ImageGenerationResponse&gt; GetImageTaskStatus(\n        [Description(\"要查询的任务 ID\")] string taskId,\n        CancellationToken cancellationToken = default)\n    {\n        if (!Guid.TryParse(taskId, out var id))\n        {\n            return new ImageGenerationResponse\n            {\n                Status = \"错误\",\n                Message = \"任务 ID 格式无效\"\n            };\n        }\n\n        var task = await _dbContext.ImageGenerationTasks.FindAsync(new object[] { id }, cancellationToken);\n        \n        if (task == null)\n        {\n            return new ImageGenerationResponse\n            {\n                Status = \"错误\",\n                Message = \"未找到任务\"\n            };\n        }\n\n        return new ImageGenerationResponse\n        {\n            TaskId = task.Id,\n            Status = task.Status.ToString().ToLowerInvariant(),\n            Message = task.ErrorMessage ?? GetStatusMessage(task.Status),\n            ImageBase64 = task.ImageData,\n            ImageUrl = task.ImageUrl,\n            IsAsync = !string.IsNullOrEmpty(task.HangfireJobId)\n        };\n    }\n\n    private static string GetStatusMessage(ImageTaskStatus status)\n    {\n        return status switch\n        {\n            ImageTaskStatus.Pending =&gt; \"任务等待中\",\n            ImageTaskStatus.Processing =&gt; \"任务处理中\",\n            ImageTaskStatus.Completed =&gt; \"图片生成成功\",\n            ImageTaskStatus.Failed =&gt; \"图片生成失败\",\n            ImageTaskStatus.Cancelled =&gt; \"任务已取消\",\n            _ =&gt; \"未知状态\"\n        };\n    }\n}\n\n/// &lt;summary&gt;\n/// 图片生成响应模型\n/// &lt;/summary&gt;\npublic class ImageGenerationResponse\n{\n    public Guid? TaskId { get; set; }\n    public required string Status { get; set; }\n    public string? Message { get; set; }\n    public string? ImageBase64 { get; set; }\n    public string? ImageUrl { get; set; }\n    public string? RevisedPrompt { get; set; }\n    public bool IsAsync { get; set; }\n}\n\n</code></pre>\n<p><strong>实际项目特点</strong>：</p>\n<ol>\n<li>\n<p><strong>双模式支持</strong>：</p>\n<ul>\n<li>同步模式：立即生成并返回结果</li>\n<li>异步模式：使用Hangfire后台任务，完成后通过邮件通知</li>\n</ul>\n</li>\n<li>\n<p><strong>多渠道推送</strong>：</p>\n<ul>\n<li>通过SignalR推送到设备（CustomMessage）</li>\n<li>通过邮件发送链接</li>\n</ul>\n</li>\n<li>\n<p><strong>图片存储</strong>：</p>\n<ul>\n<li>同时保存PNG和JPEG两种格式</li>\n<li>存储到Azure Blob Storage或本地文件系统</li>\n</ul>\n</li>\n<li>\n<p><strong>完整的错误处理和日志记录</strong></p>\n</li>\n</ol>\n<p><strong>获取完整代码</strong>：</p>\n<ul>\n<li>\n<p>🔧 ESP32设备端 (小智完整实现):<br />\n<a href=\"https://github.com/maker-community/xiaozhi-esp32\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/maker-community/xiaozhi-esp32</a></p>\n<ul>\n<li>SignalR集成分支：<code>signalr</code> 和 <code>signalr-update-audio</code></li>\n</ul>\n</li>\n<li>\n<p>🔧 ESP32示例工程 (包含完整的SignalR集成示例):<br />\n<a href=\"https://github.com/maker-community/esp-signalr-example\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/maker-community/esp-signalr-example</a></p>\n</li>\n<li>\n<p>🔧 SignalR C++客户端库:<br />\n<a href=\"https://github.com/maker-community/esp-signalr\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/maker-community/esp-signalr</a><br />\n<a href=\"https://github.com/maker-community/esp-signalr-example\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/maker-community/esp-signalr-example</a></p>\n</li>\n<li>\n<p>🌐 MCP服务器端:<br />\n<a href=\"https://github.com/maker-community/verdure-mcp\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/maker-community/verdure-mcp</a></p>\n</li>\n</ul>\n<h2 id=\"实际使用场景示例\">实际使用场景示例</h2>\n<h3 id=\"场景1ai生图后推送到设备\">场景1：AI生图后推送到设备</h3>\n<p>用户通过小智对话：\"帮我生成一张猫咪的图片\"</p>\n<ol>\n<li>对话发送到.NET MCP服务</li>\n<li>MCP服务调用API生成图片</li>\n<li>生成完成后，后台任务调用hub发送消息</li>\n<li>服务端通过SignalR推送图片给该用户的所有设备</li>\n<li>ESP32设备接收到<code>自定义消息</code>事件，下载并显示在屏幕上</li>\n</ol>\n<h3 id=\"场景2播放音乐\">场景2：播放音乐</h3>\n<p>用户通过语音说想要播放音乐，mcp被触发，随机选择音乐url推送到设备</p>\n<ol>\n<li>对话发送到.NET MCP服务</li>\n<li>服务端通过SignalR推送音乐给该用户的所有设备</li>\n<li>ESP32设备接收到<code>自定义消息</code>事件，下载并播放语音</li>\n</ol>\n<h2 id=\"内存优化经验分享\">内存优化经验分享</h2>\n<blockquote>\n<p><strong>说明</strong>：本章节内容对于在ESP32上运行SignalR客户端非常重要，这些都是实践中总结出的经验。</p>\n</blockquote>\n<p>在ESP32上集成SignalR确实遇到了内存问题，分享一些优化经验：</p>\n<h3 id=\"1-使用psram存储大对象\">1. 使用PSRAM存储大对象</h3>\n<pre><code class=\"language-cpp\">// 为图片数据分配PSRAM内存\nvoid* imageBuffer = heap_caps_malloc(imageSize, MALLOC_CAP_SPIRAM);\nif (imageBuffer == NULL) {\n    // 降级到内部RAM\n    imageBuffer = malloc(imageSize);\n}\n</code></pre>\n<p>在VS Code的menuconfig中启用PSRAM：</p>\n<ul>\n<li><code>F1</code> → <code>ESP-IDF: SDK Configuration editor</code></li>\n<li><code>Component config</code> → <code>ESP32-specific</code> → <code>Support for external, SPI-connected RAM</code></li>\n</ul>\n<h3 id=\"2-减少json序列化次数\">2. 减少JSON序列化次数</h3>\n<pre><code class=\"language-cpp\">// 错误做法：频繁创建/销毁cJSON对象\nfor (int i = 0; i &lt; 100; i++) {\n    cJSON* root = cJSON_Parse(jsonString);\n    // 处理...\n    cJSON_Delete(root);  // 产生内存碎片\n}\n\n// 正确做法：复用对象\ncJSON* root = cJSON_Parse(jsonString);\nfor (int i = 0; i &lt; 100; i++) {\n    // 处理...\n}\ncJSON_Delete(root);\n</code></pre>\n<h3 id=\"3-增加任务栈大小\">3. 增加任务栈大小</h3>\n<p>SignalR的回调嵌套较深，需要增加栈：</p>\n<p>在menuconfig中：<code>Component config</code> → <code>ESP32-specific</code> → <code>Main task stack size</code> → 设置为<code>8192</code></p>\n<p>或在代码中：</p>\n<pre><code class=\"language-cpp\">xTaskCreatePinnedToCore(\n    signalr_task,\n    \"signalr\",\n    8192,  // 栈大小（字节）\n    NULL,\n    5,     // 优先级\n    NULL,\n    1      // CPU核心\n);\n</code></pre>\n<h2 id=\"总结与感悟\">总结与感悟</h2>\n<p>通过这次SignalR移植和集成的实践，我深刻体会到：</p>\n<ol>\n<li>\n<p><strong>选对框架很重要</strong>：SignalR的群组管理、消息路由等特性，省去了大量基础设施代码。如果从头手写WebSocket，这些功能得花几周时间。</p>\n</li>\n<li>\n<p><strong>内存管理是嵌入式永恒的主题</strong>：ESP32的RAM限制让我对每一个malloc都格外小心。合理使用PSRAM、避免内存碎片、及时释放资源，这些在PC上不用care的问题，在嵌入式上都是坑。</p>\n</li>\n<li>\n<p><strong>AI辅助编程真香</strong>：这次项目中，SignalR C++客户端的移植、消息处理等大量代码都是借助AI生成的。虽然生成的代码需要调试和优化，但确实大幅提高了开发效率。</p>\n</li>\n<li>\n<p><strong>消息推送解决实际问题</strong>：之前MCP工具只能同步返回结果，现在通过SignalR，服务端可以主动推送图片、语音、通知给设备，用户体验提升明显。</p>\n</li>\n<li>\n<p><strong>.NET生态的强大</strong>：SignalR、EF Core、JWT认证……微软这套生态真的很完善。作为.NET开发者，能用熟悉的技术栈快速搭建生产级服务。</p>\n</li>\n</ol>\n<p>这个项目还有很多优化空间，比如：</p>\n<ul>\n<li>WebSocket Binary Protocol替代JSON减少带宽</li>\n<li>引入Redis存储群组信息，支持服务端横向扩展</li>\n<li>继续完善代码质量，让库能够被更多的人关注和参与，希望有更多的人来实际使用和优化。</li>\n</ul>\n<p>但作为一个初步能用的方案，已经足够支撑小智机器人的功能扩展了。后续我会继续完善这套架构，欢迎大家一起探讨和贡献代码！</p>\n<p>希望这篇文章能给大家在.NET IoT开发、SignalR实时通信方面带来一些启发。如果有问题欢迎在评论区讨论，让我们一起探索.NET在IoT领域的更多可能性！</p>\n<h2 id=\"手搓esp32小机器人\">手搓ESP32小机器人</h2>\n<p>如果你有手搓Esp32的硬件打算，可以关注我的B站账号（绿荫阿广）<br />\n<a href=\"https://space.bilibili.com/25228512\" rel=\"noopener nofollow\" target=\"_blank\">https://space.bilibili.com/25228512</a></p>\n<p><img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/1690009/202602/1690009-20260201141614219-406532144.png\" /></p>\n<h2 id=\"项目地址\">项目地址</h2>\n<h3 id=\"esp32相关-1\">ESP32相关</h3>\n<ul>\n<li>\n<p><strong>SignalR C++客户端库</strong>：<br />\n<a href=\"https://github.com/maker-community/esp-signalr\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/maker-community/esp-signalr</a></p>\n</li>\n<li>\n<p><strong>小智ESP32完整实现</strong> (signalr-update-audio分支):<br />\n<a href=\"https://github.com/maker-community/xiaozhi-esp32\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/maker-community/xiaozhi-esp32</a></p>\n</li>\n<li>\n<p><strong>ESP32 SignalR完整示例工程</strong> (包含音频分块、设备控制API等):<br />\n<a href=\"https://github.com/maker-community/esp-signalr-example\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/maker-community/esp-signalr-example</a></p>\n<ul>\n<li><a href=\"https://github.com/maker-community/esp-signalr-example/tree/main/signalr-server\" rel=\"noopener nofollow\" target=\"_blank\">服务端代码</a></li>\n<li><a href=\"https://github.com/maker-community/esp-signalr-example/tree/main/main\" rel=\"noopener nofollow\" target=\"_blank\">客户端代码</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"net服务端\">.NET服务端</h3>\n<ul>\n<li><strong>Verdure MCP服务</strong> (包含完整的Hub、Tools、Services实现):<br />\n<a href=\"https://github.com/maker-community/verdure-mcp\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/maker-community/verdure-mcp</a></li>\n<li><strong>小智mcp转接平台</strong>：</li>\n<li><a href=\"https://github.com/maker-community/verdure-mcp-for-xiaozhi\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/maker-community/verdure-mcp-for-xiaozhi</a></li>\n</ul>\n<h3 id=\"参考资料\">参考资料</h3>\n<ul>\n<li><strong>SignalR Client C++ (微软官方)</strong>:<br />\n<a href=\"https://github.com/aspnet/SignalR-Client-Cpp\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/aspnet/SignalR-Client-Cpp</a></li>\n<li><strong>SignalR Client C# nanoframework</strong>:<br />\n<a href=\"https://github.com/nanoframework/nanoFramework.SignalR.Client\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/nanoframework/nanoFramework.SignalR.Client</a></li>\n</ul>\n<h2 id=\"参考文档\">参考文档</h2>\n<ol>\n<li><a href=\"https://docs.microsoft.com/zh-cn/aspnet/core/signalr/\" rel=\"noopener nofollow\" target=\"_blank\">ASP.NET Core SignalR 官方文档</a></li>\n<li><a href=\"https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md\" rel=\"noopener nofollow\" target=\"_blank\">SignalR Hub 协议规范</a></li>\n<li><a href=\"https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/\" rel=\"noopener nofollow\" target=\"_blank\">ESP-IDF 编程指南</a></li>\n<li><a href=\"https://github.com/espressif/vscode-esp-idf-extension\" rel=\"noopener nofollow\" target=\"_blank\">VS Code ESP-IDF 插件</a></li>\n<li><a href=\"https://jwt.io/introduction\" rel=\"noopener nofollow\" target=\"_blank\">JWT 认证最佳实践</a></li>\n<li><a href=\"https://www.keycloak.org/docs/latest/securing_apps/\" rel=\"noopener nofollow\" target=\"_blank\">Keycloak 认证集成指南</a></li>\n</ol>\n<hr />\n<p><em>本文首发于个人技术博客，转载请注明出处。如果对.NET IoT开发、SignalR实时通信感兴趣，欢迎关注我的博客获取更多技术分享！</em></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-01 15:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GreenShade\">绿荫阿广</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LLVM Pass快速入门(一)：构建编译环境",
      "link": "https://www.cnblogs.com/ClownLMe/p/19560726",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19560726\" id=\"cb_post_title_url\" title=\"发布于 2026-02-01 14:36\">\n    <span>LLVM Pass快速入门(一)：构建编译环境</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简介\">简介</h1>\n<p><strong>LLVM</strong> 是一个编译框架工具，是把编译过程拆解成了高度标准化的组件。</p>\n<p><strong>本教程所使用的环境是windows11, vs2022</strong></p>\n<h1 id=\"认识llvm\">认识LLVM</h1>\n<p>LLVM 最成功的地方在于它定义了一种极其完美的中间语言<strong>LLVM IR</strong>，LLVM分为前端，优化器，后端：</p>\n<ul>\n<li><strong>前端</strong>：负责把源代码（C/C++、Rust、Go）翻译成 LLVM IR。比如 <code>Clang</code>。</li>\n<li><strong>优化器</strong>：这是 LLVM 的灵魂。它只处理 IR，不关心源码是什么语言，也不关心目标是什么机器。你写的 <strong>Pass</strong> 就运行在这里。</li>\n<li><strong>后端</strong>：负责把优化后的 IR 翻译成具体的机器码（x86、ARM、RISC-V）。比如 <code>LLC</code>。</li>\n</ul>\n<p>LLVM的三端架构，我们能够很方便的自定义编译器，<strong>本系类教程主要教学优化器的pass编写</strong></p>\n<h1 id=\"环境配置\">环境配置</h1>\n<h3 id=\"需要准备的工具\">需要准备的工具</h3>\n<ol>\n<li><strong>git</strong> : <a href=\"https://git-scm.com/install/\" rel=\"noopener nofollow\" target=\"_blank\">https://git-scm.com/install/</a> 拉取项目</li>\n<li><strong>visual studio</strong> : <a href=\"https://visualstudio.microsoft.com/zh-hans/\" rel=\"noopener nofollow\" target=\"_blank\">https://visualstudio.microsoft.com/zh-hans/</a> 需要安装<code>c/c++桌面开发</code>组件，编译环境</li>\n<li><strong>cmake</strong>： <a href=\"https://cmake.org/\" rel=\"noopener nofollow\" target=\"_blank\">https://cmake.org/</a> 构建项目</li>\n<li><strong>ninja</strong> : <a href=\"https://github.com/ninja-build/ninja\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ninja-build/ninja</a> 加速编译</li>\n</ol>\n<h3 id=\"拉取llvm并配置\">拉取LLVM并配置</h3>\n<p>这里我保存在D盘</p>\n<pre><code class=\"language-bash\">#创建文件夹\nmkdir D:\\LLVM \ncd D:\\LLVM \n#拉取源码 (只拉取核心仓库，不需要 submodule，现在 LLVM 是 monorepo) \n#这一步比较大，网络不好请挂梯子 \ngit clone --depth=1 https://github.com/llvm/llvm-project.git\n#创建构建目录\ncd llvm-project \nmkdir build \ncd build\n</code></pre>\n<h3 id=\"构建并编译\">构建并编译</h3>\n<p><strong>这里需要打开刚刚下载好<code>visual studio</code>的工作台，我这里是<code>x64 Native Tools Command Prompt for VS 2022</code></strong><br />\n<strong>注意：开始编译需要预留30-60G硬盘空间，编译需要30分钟左右</strong></p>\n<pre><code class=\"language-bash\">#利用cmake构建项目\ncmake -G \"Ninja\" ^ #使用ninja编译\n-DLLVM_ENABLE_PROJECTS=\"clang\" ^ #只编译clang节省空间\n-DLLVM_TARGETS_TO_BUILD=\"X86\" ^ #只编译x86后端，这节省大部分编译时间，除非要搞arm或者安卓\n-DCMAKE_BUILD_TYPE=\"RelWithDebInfo\" ^ #Relase版本无法调试，debug版本太大太慢了，这里选择带调试符号的relase版本\n-DLLVM_OPTIMIZED_TABLEGEN=ON ^ \n-DLLVM_ENABLE_ASSERTIONS=ON ^ #开启代码断言。当pass写错时，会报错而不是直接崩溃\n../llvm\n#编译\nninja\n</code></pre>\n<h3 id=\"添加环境变量\">添加环境变量</h3>\n<p>这一步方便之后的使用</p>\n<pre><code class=\"language-bash\">#将刚刚编译好的环境加入环境变量\nD:\\LLVM\\llvm-project\\build\\bin\n</code></pre>\n<h3 id=\"简单验证环境\">简单验证环境</h3>\n<pre><code class=\"language-bash\">clang --version\nopt --version\n</code></pre>\n<p>一般来说，跟着上面步骤走 并且 系统和vs版本一样到这是不会报错的。</p>\n<h1 id=\"验证环境\">验证环境</h1>\n<p>下面编译一个<code>test.c</code>来验证环境是否正常。</p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nint add(int a, int b) {\n&nbsp; &nbsp; return a + b + 5;\n}\n\nint main(){\n&nbsp; &nbsp; printf(\"add(1, 2) = %d\\n\", add(1, 2));\n&nbsp; &nbsp; return 0;\n}\n</code></pre>\n<h3 id=\"编译代码\">编译代码</h3>\n<h5 id=\"c-编译为llvm-ir\">C 编译为LLVM IR</h5>\n<pre><code class=\"language-bash\">clang -S -emit-llvm -O0 test.c -o test.ll\n</code></pre>\n<p>观察IR：</p>\n<pre><code class=\"language-c\">......\ndefine dso_local i32 @main() #0 {\nentry:\n&nbsp; %retval = alloca i32, align 4\n&nbsp; store i32 0, ptr %retval, align 4\n&nbsp; %call = call i32 @add(i32 noundef 1, i32 noundef 2)\n&nbsp; %call1 = call i32 (ptr, ...) @printf(ptr noundef @\"??_C@_0BA@OMPDDIF@add?$CI1?0?52?$CJ?5?$DN?5?$CFd?6?$AA@\", i32 noundef %call)\n&nbsp; ret i32 0\n}\n......\n</code></pre>\n<h5 id=\"llvm-ir-编译为可执行文件\">LLVM IR 编译为可执行文件</h5>\n<p>编译为可执行文件并正常运行</p>\n<pre><code class=\"language-bash\">clang test.c -o test.exe\n</code></pre>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-01 14:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一天一个Python库：pycparser - 解析C代码、理解C的抽象语法树",
      "link": "https://www.cnblogs.com/min2k/p/19560470",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/min2k/p/19560470\" id=\"cb_post_title_url\" title=\"发布于 2026-02-01 12:41\">\n    <span>一天一个Python库：pycparser - 解析C代码、理解C的抽象语法树</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"pycparser---解析c代码理解c的抽象语法树\">pycparser - 解析C代码、理解C的抽象语法树</h1>\n<h2 id=\"一什么是pycparser\">一、什么是pycparser？</h2>\n<p><strong>pycparser</strong> 是一个用于纯 Python 实现的 C 语言解析器库。<br />\n它可以帮助你：</p>\n<ul>\n<li>将 C 代码解析成抽象语法树（AST）。</li>\n<li>遍历和分析 C 语言的 AST。</li>\n<li>基于 C 代码进行静态分析和代码转换。</li>\n</ul>\n<h2 id=\"二应用场景\">二、应用场景</h2>\n<p><strong>pycparser</strong> 广泛应用于以下实际场景：</p>\n<ul>\n<li><strong>C/C++ 代码分析工具</strong>: 用于构建自定义的静态分析器、代码度量工具或风格检查器。</li>\n<li><strong>代码生成和转换</strong>: 将 C 代码转换为其他语言，或者进行一些宏展开、优化等转换。</li>\n<li><strong>教育和研究</strong>: 理解 C 语言的语法结构和编译原理。</li>\n</ul>\n<h2 id=\"三如何安装\">三、如何安装</h2>\n<ol>\n<li>使用 pip 安装</li>\n</ol>\n<pre><code class=\"language-bash\">pip install pycparser\n\n# 如果安装慢的话，推荐使用国内镜像源\npip install pycparser -i https://www.python64.cn/pypi/simple/\n</code></pre>\n<ol start=\"2\">\n<li>使用 <a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行代码（无需本地安装）</li>\n</ol>\n<h2 id=\"四示例代码\">四、示例代码</h2>\n<p>解析简单的C代码字符串并打印其AST的顶层节点数量</p>\n<pre><code class=\"language-python\">from pycparser import c_parser, c_ast\n\n# 假设我们要解析的C代码\nc_code = \"\"\"\nint main() {\n    int x = 10;\n    if (x &gt; 5) {\n        return 0;\n    }\n    return 1;\n}\n\"\"\"\n\n# 创建C解析器实例\nparser = c_parser.CParser()\n\n# 解析C代码字符串，得到AST\nast = parser.parse(c_code)\n\n# 初始化一个计数器\ntop_level_nodes_count = 0\n\n# 遍历AST的顶层子节点\nfor node in ast.ext:\n    top_level_nodes_count += 1\n    # 检查节点类型，如果它是函数定义，则打印其名称\n    if isinstance(node, c_ast.FuncDef):\n        print(f\"找到函数定义: {node.decl.name}\")\n\n# 如果顶层节点数量大于0，说明成功解析了至少一个顶层结构\nif top_level_nodes_count &gt; 0:\n    print(f\"AST 成功解析，顶层节点数量为: {top_level_nodes_count}\")\nelse:\n    print(\"AST 解析失败或没有顶层节点。\")\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/python-run/?code=from%20pycparser%20import%20c_parser%2C%20c_ast%0A%0A%23%20%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E8%A6%81%E8%A7%A3%E6%9E%90%E7%9A%84C%E4%BB%A3%E7%A0%81%0Ac_code%20%3D%20%22%22%22%0Aint%20main%28%29%20%7B%0A%20%20%20%20int%20x%20%3D%2010%3B%0A%20%20%20%20if%20%28x%20%3E%205%29%20%7B%0A%20%20%20%20%20%20%20%20return%200%3B%0A%20%20%20%20%7D%0A%20%20%20%20return%201%3B%0A%7D%0A%22%22%22%0A%0A%23%20%E5%88%9B%E5%BB%BAC%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E4%BE%8B%0Aparser%20%3D%20c_parser.CParser%28%29%0A%0A%23%20%E8%A7%A3%E6%9E%90C%E4%BB%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%BE%97%E5%88%B0AST%0Aast%20%3D%20parser.parse%28c_code%29%0A%0A%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E8%AE%A1%E6%95%B0%E5%99%A8%0Atop_level_nodes_count%20%3D%200%0A%0A%23%20%E9%81%8D%E5%8E%86AST%E7%9A%84%E9%A1%B6%E5%B1%82%E5%AD%90%E8%8A%82%E7%82%B9%0Afor%20node%20in%20ast.ext%3A%0A%20%20%20%20top_level_nodes_count%20%2B%3D%201%0A%20%20%20%20%23%20%E6%A3%80%E6%9F%A5%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AE%83%E6%98%AF%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%88%99%E6%89%93%E5%8D%B0%E5%85%B6%E5%90%8D%E7%A7%B0%0A%20%20%20%20if%20isinstance%28node%2C%20c_ast.FuncDef%29%3A%0A%20%20%20%20%20%20%20%20print%28f%22%E6%89%BE%E5%88%B0%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%3A%20%7Bnode.decl.name%7D%22%29%0A%0A%23%20%E5%A6%82%E6%9E%9C%E9%A1%B6%E5%B1%82%E8%8A%82%E7%82%B9%E6%95%B0%E9%87%8F%E5%A4%A7%E4%BA%8E0%EF%BC%8C%E8%AF%B4%E6%98%8E%E6%88%90%E5%8A%9F%E8%A7%A3%E6%9E%90%E4%BA%86%E8%87%B3%E5%B0%91%E4%B8%80%E4%B8%AA%E9%A1%B6%E5%B1%82%E7%BB%93%E6%9E%84%0Aif%20top_level_nodes_count%20%3E%200%3A%0A%20%20%20%20print%28f%22AST%20%E6%88%90%E5%8A%9F%E8%A7%A3%E6%9E%90%EF%BC%8C%E9%A1%B6%E5%B1%82%E8%8A%82%E7%82%B9%E6%95%B0%E9%87%8F%E4%B8%BA%3A%20%7Btop_level_nodes_count%7D%22%29%0Aelse%3A%0A%20%20%20%20print%28%22AST%20%E8%A7%A3%E6%9E%90%E5%A4%B1%E8%B4%A5%E6%88%96%E6%B2%A1%E6%9C%89%E9%A1%B6%E5%B1%82%E8%8A%82%E7%82%B9%E3%80%82%22%29\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行这段代码，结果如下：</p>\n<pre><code class=\"language-text\">找到函数定义: main\nAST 成功解析，顶层节点数量为: 1\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/mermaid/?code=flowchart%20TD%0A%20%20A%5B%E5%BC%80%E5%A7%8B%5D%20--%3E%20B%7B%E5%88%9B%E5%BB%BAC%E8%A7%A3%E6%9E%90%E5%99%A8%7D%3B%0A%20%20B%20--%3E%20C%5B%E5%AE%9A%E4%B9%89C%E4%BB%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%5D%3B%0A%20%20C%20--%3E%20D%5B%E8%A7%A3%E6%9E%90C%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90AST%5D%3B%0A%20%20D%20--%3E%20E%7B%E5%88%9D%E5%A7%8B%E5%8C%96%20top_level_nodes_count%20%3D%200%7D%3B%0A%20%20E%20--%3E%20F%7B%E9%81%8D%E5%8E%86AST%E7%9A%84%E9%A1%B6%E5%B1%82%E5%AD%90%E8%8A%82%E7%82%B9%20%28node%29%7D%3B%0A%20%20F%20--%20%E9%81%8D%E5%8E%86%E7%BB%93%E6%9D%9F%20--%3E%20G%7B%E5%88%A4%E6%96%AD%20top_level_nodes_count%20%3E%200%3F%7D%3B%0A%20%20F%20--%3E%20H%7B%E5%A2%9E%E5%8A%A0%20top_level_nodes_count%7D%3B%0A%20%20H%20--%3E%20I%7Bnode%20%E6%98%AF%20FuncDef%20%E5%90%97%3F%7D%3B%0A%20%20I%20--%20%E6%98%AF%20--%3E%20J%5B%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0%5D%3B%0A%20%20I%20--%20%E5%90%A6%20--%3E%20F%3B%0A%20%20J%20--%3E%20F%3B%0A%20%20G%20--%20%E6%98%AF%20--%3E%20K%5B%E6%89%93%E5%8D%B0%20%22AST%20%E6%88%90%E5%8A%9F%E8%A7%A3%E6%9E%90%EF%BC%8C%E9%A1%B6%E5%B1%82%E8%8A%82%E7%82%B9%E6%95%B0%E9%87%8F%E4%B8%BA%3A%22%5D%3B%0A%20%20G%20--%20%E5%90%A6%20--%3E%20L%5B%E6%89%93%E5%8D%B0%20%22AST%20%E8%A7%A3%E6%9E%90%E5%A4%B1%E8%B4%A5%E6%88%96%E6%B2%A1%E6%9C%89%E9%A1%B6%E5%B1%82%E8%8A%82%E7%82%B9%E3%80%82%22%5D%3B%0A%20%20K%20--%3E%20M%5B%E7%BB%93%E6%9D%9F%5D%3B%0A%20%20L%20--%3E%20M%3B\" rel=\"noopener nofollow\" target=\"_blank\">MermaidGo</a> 绘制示例代码的流程图，结果如下：</p>\n<p><img alt=\"MermerGo的pycparser流程图\" class=\"lazyload\" /></p>\n<h2 id=\"五学习资源\">五、学习资源</h2>\n<ol>\n<li>开源项目：<a href=\"https://github.com/eliben/pycparser\" rel=\"noopener nofollow\" target=\"_blank\">pycparser</a></li>\n<li>中文自述：<a href=\"https://www.python64.cn/readme/pycparser/\" rel=\"noopener nofollow\" target=\"_blank\">REMDME</a></li>\n<li>在线运行：<a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a></li>\n</ol>\n<blockquote>\n<p>如果这篇文章对你有帮助，欢迎点赞、收藏、转发！<br />\n学习过程中有任何问题，欢迎在评论区留言交流～</p>\n</blockquote>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-01 12:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/min2k\">敏编程</a>&nbsp;\n阅读(<span id=\"post_view_count\">50</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从0到1，快速训练并使用YOLO模型",
      "link": "https://www.cnblogs.com/ClownLMe/p/19559180",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19559180\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 21:54\">\n    <span>从0到1，快速训练并使用YOLO模型</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简介\">简介</h1>\n<p><strong>YOLO</strong>是目前计算机视觉领域最前沿、应用最广泛的<strong>目标检测</strong>算法框架，他能快速识别区分目标，广泛应用于游戏，无人驾驶，工业等领域。</p>\n<p>以识别躲避掉落滑块的游戏的物体图片作为例子。</p>\n<h1 id=\"一环境配置\">一，环境配置</h1>\n<pre><code class=\"language-bash\">pip install ultralytics\n</code></pre>\n<h1 id=\"二准备数据集\">二，准备数据集</h1>\n<p>这个格式目录如下：</p>\n<pre><code class=\"language-bash\">my_dataset/\n├── data.yaml # 配置文件（定义路径和类别）\n├── train/ #训练数据集\n│   ├── images/ # 训练图片\n│   └── labels/ # 标注文件 (.txt)\n└── val/ #验证数据集\n    ├── images/ \n    └── labels/ \n</code></pre>\n<h3 id=\"datayml\">data.yml</h3>\n<pre><code class=\"language-yaml\">path: D:\\D_MyProject\\Ai\\game_ai\\my_dataset #数据集路径\ntrain: train/images #训练集图片路径\nval: val/images #验证集图片路径\n\nnc: 3 #标记个数\nnames:  #每个标记的名称\n&nbsp; 0: player\n&nbsp; 1: enemy\n&nbsp; 2: game_over\n</code></pre>\n<h3 id=\"下面是用ai生成了数据集的生成脚本\">下面是用AI生成了数据集的生成脚本</h3>\n<p>数据量太多了，这里为了演示，或者学习，可以直接使用下面脚本</p>\n<pre><code class=\"language-python\">import pygame\nimport random\nimport sys\nimport os\nimport shutil\n\n# =================配置区域=================\n# 数据集根目录名称\nDATASET_ROOT = \"my_dataset\"\n# 采集总数量\nMAX_IMAGES = 1000\n# 训练集占比 (0.8 = 80% 训练, 20% 验证)\nTRAIN_RATIO = 0.8\n\n# ================= 1. 环境清理与目录创建 =================\nprint(f\"🚀 正在初始化数据集目录: {DATASET_ROOT} ...\")\n\n# 如果目录已存在，先删除（防止旧数据混入），确保数据纯净\nif os.path.exists(DATASET_ROOT):\n    shutil.rmtree(DATASET_ROOT)\n\n# 创建 YOLO 标准目录结构\nfor split in ['train', 'val']:\n    os.makedirs(os.path.join(DATASET_ROOT, split, 'images'), exist_ok=True)\n    os.makedirs(os.path.join(DATASET_ROOT, split, 'labels'), exist_ok=True)\n\n# ================= 2. 自动生成 data.yaml =================\nyaml_content = f\"\"\"\npath: {os.path.abspath(DATASET_ROOT)} # 使用绝对路径，防止报错\ntrain: train/images\nval: val/images\n\nnc: 3\nnames:\n  0: player\n  1: enemy\n  2: game_over\n\"\"\"\nwith open(os.path.join(DATASET_ROOT, \"data.yaml\"), \"w\", encoding='utf-8') as f:\n    f.write(yaml_content)\nprint(\"✅ data.yaml 配置文件已生成。\")\n\n# ================= 3. 游戏与采集逻辑 =================\npygame.init()\nWIDTH, HEIGHT = 800, 600\n# 使用 hidden 模式或正常模式均可，这里用正常模式方便你看到进度\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Auto Data Generator\")\nclock = pygame.time.Clock()\n\nfont_big = pygame.font.SysFont(\"monospace\", 50)\nfont_small = pygame.font.SysFont(\"monospace\", 35)\n\n# 游戏状态\nplayer_size, enemy_size = 50, 50\nplayer_x = WIDTH // 2\nplayer_y = HEIGHT - player_size - 10\nenemies = []\n\nimg_count = 0\nGAMEPLAY_LIMIT = int(MAX_IMAGES * 0.9) # 90% 正常游戏，10% Game Over\n\nprint(f\"📸 开始采集 {MAX_IMAGES} 张图片 (自动划分 Train/Val)...\")\n\nwhile img_count &lt; MAX_IMAGES:\n    # 处理退出事件，防止卡死\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n\n    screen.fill((0, 0, 0))\n    labels = [] # 存储当前帧的标签\n    dw, dh = 1.0 / WIDTH, 1.0 / HEIGHT # 归一化系数\n\n    # --- 逻辑分支：正常游戏 vs Game Over ---\n    if img_count &lt; GAMEPLAY_LIMIT:\n        # A. 正常游戏画面\n        # 1. 玩家移动\n        if random.random() &lt; 0.2: # 增加移动频率\n            player_x += random.choice([-15, 15])\n            player_x = max(0, min(WIDTH - player_size, player_x))\n\n        # 2. 敌人生成与移动\n        if random.randint(0, 20) == 0: # 增加敌人密度\n            enemies.append([random.randint(0, WIDTH - enemy_size), 0])\n        \n        for enemy in enemies: enemy[1] += 15 # 加快下落速度\n        enemies = [e for e in enemies if e[1] &lt; HEIGHT]\n\n        # 3. 绘制玩家 (Class 0)\n        pygame.draw.rect(screen, (50, 150, 255), (player_x, player_y, player_size, player_size))\n        # 计算 YOLO 坐标 (class x_center y_center width height)\n        px, py = (player_x + player_size/2) * dw, (player_y + player_size/2) * dh\n        labels.append(f\"0 {px:.6f} {py:.6f} {player_size*dw:.6f} {player_size*dh:.6f}\")\n\n        # 4. 绘制敌人 (Class 1)\n        for e in enemies:\n            pygame.draw.rect(screen, (255, 50, 50), (e[0], e[1], enemy_size, enemy_size))\n            ex, ey = (e[0] + enemy_size/2) * dw, (e[1] + enemy_size/2) * dh\n            labels.append(f\"1 {ex:.6f} {ey:.6f} {enemy_size*dw:.6f} {enemy_size*dh:.6f}\")\n\n    else:\n        # B. Game Over 画面 (Class 2)\n        text_surf = font_big.render(\"GAME OVER\", True, (255, 50, 50))\n        \n        # 随机抖动位置，防止过拟合\n        off_x, off_y = random.randint(-50, 50), random.randint(-50, 50)\n        text_x = WIDTH // 2 - text_surf.get_width() // 2 + off_x\n        text_y = HEIGHT // 2 - 100 + off_y\n        screen.blit(text_surf, (text_x, text_y))\n\n        # 干扰项\n        score_surf = font_small.render(f\"Score: {random.randint(0,999)}\", True, (255,255,255))\n        screen.blit(score_surf, (WIDTH//2 - score_surf.get_width()//2, HEIGHT//2 + 50))\n\n        # 记录标签\n        tw, th = text_surf.get_width(), text_surf.get_height()\n        tx, ty = (text_x + tw/2) * dw, (text_y + th/2) * dh\n        labels.append(f\"2 {tx:.6f} {ty:.6f} {tw*dw:.6f} {th*dh:.6f}\")\n\n    # ================= 4. 保存逻辑 (核心修改) =================\n    pygame.display.flip()\n    \n    # 采样率：不是每一帧都保存，防止重复度过高 (这里设为 30% 概率保存)\n    if random.random() &lt; 0.3:\n        # A. 决定是去 Train 还是 Val\n        split_folder = \"train\" if random.random() &lt; TRAIN_RATIO else \"val\"\n        \n        # B. 生成文件名\n        filename = f\"{img_count:06d}\"\n        img_save_path = os.path.join(DATASET_ROOT, split_folder, \"images\", f\"{filename}.jpg\")\n        lbl_save_path = os.path.join(DATASET_ROOT, split_folder, \"labels\", f\"{filename}.txt\")\n\n        # C. 保存图片\n        pygame.image.save(screen, img_save_path)\n\n        # D. 保存标签\n        with open(lbl_save_path, \"w\") as f:\n            f.write(\"\\n\".join(labels))\n\n        img_count += 1\n        \n        # 打印进度条\n        print(f\"[{split_folder.upper()}] 进度: {img_count}/{MAX_IMAGES}\", end=\"\\r\")\n\n    # 加速模拟，不要垂直同步，越快越好\n    clock.tick(0) \n\npygame.quit()\nprint(f\"\\n\\n✨ 全部完成！数据集已就绪：{os.path.abspath(DATASET_ROOT)}\")\nprint(\"💡 下一步：直接运行 model.train(data='my_dataset/data.yaml')\")\n</code></pre>\n<h1 id=\"三训练yolo模型\">三，训练YOLO模型</h1>\n<p>可以看到，使用<code>ultralytics</code>框架训练YOLO的代码非常简单，只需要几行<br />\n<strong>注意：这里YOLO会自动下载模型并训练，下载时失败可能需要挂梯子</strong></p>\n<pre><code class=\"language-python\">from ultralytics import YOLO\n\ndef train_model():\n    #加载模型\n    model = YOLO(\"yolo11n.pt\") \n\n    #开始训练\n    print(\"开始训练...\")\n    results = model.train(\n        data=\"my_dataset/data.yaml\", #数据集配置文件\n        epochs=30, #训练轮数\n        imgsz=640, #图片输入尺寸\n        batch=16, #显存够大可以改大，比如 32 或 64\n        device=0, #强制使用第一张显卡 (需要CUDA)\n        workers=0, #Windows下设为0防止多进程报错\n        project=\"dodge_project\",#保存路径\n        name=\"ai_model\" #训练运行名称\n    )\n    print(f\"训练完成！最佳模型保存在: {results.save_dir}/weights/best.pt\")\n\nif __name__ == \"__main__\":\n    train_model()\n</code></pre>\n<h1 id=\"四使用yolo模型\">四，使用YOLO模型</h1>\n<pre><code class=\"language-python\">from ultralytics import YOLO\n\n#配置路径\nMODEL_PATH = \"dodge_project/ai_model/weights/best.pt\" \nPIC_PATH = \"my_dataset/val/images/000045.jpg\"\n\n#加载模型\nmodel = YOLO(MODEL_PATH)\nprint(f\"模型加载成功\")\n\n#识别图片\nresults = model.predict(PIC_PATH, verbose=False, conf=0.4, imgsz=640)\nresult = results[0]\n\n#获取信息并打印\nfor box in result.boxes:\n    # 获取坐标 (x1, y1, x2, y2)、类别 ID 和置信度\n    x1, y1, x2, y2 = map(int, box.xyxy[0])\n    cls_id = int(box.cls[0])\n    conf = float(box.conf[0])\n    \n    # 类别名称映射\n    names = {0: \"Player\", 1: \"Enemy\", 2: \"Game Over\"}\n    label = names.get(cls_id, f\"Unknown({cls_id})\")\n    print(f\"找到物体: [{label:10}] | 置信度: {conf:.2f} | 坐标: ({x1}, {y1}) -&gt; ({x2}, {y2})\")\n\n#展示图片\nresult.show()\n</code></pre>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 21:54</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">101</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【保姆级教程】手把手教你安装OpenClaw并接入飞书，让AI在聊天软件里帮你干活",
      "link": "https://www.cnblogs.com/weipo0105/p/19558953",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/weipo0105/p/19558953\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 19:50\">\n    <span>【保姆级教程】手把手教你安装OpenClaw并接入飞书，让AI在聊天软件里帮你干活</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"【保姆级教程】手把手教你安装OpenClaw并接入飞书，让AI在聊天软件里帮你干活\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1205021/202601/1205021-20260131195003333-854515303.png\" />\n        OpenClaw 是一款能直接操作你电脑的开源AI助手，不止于聊天，更能替你执行任务。本文提供一份保姆级教程，从零开始，详细演示如何在 Windows 系统上完成 OpenClaw 的安装、初始配置，并重点一步步教你接入飞书机器人，最终实现在飞书App中直接指挥你的AI助手处理工作。跟随图文指引，轻松拥有你的个人“贾维斯”。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>这里先做一下简单的科普：</p>\n<p><code>OpenClaw</code> 的名字经历了三次变更，第一次叫做 <code>ClawdBot</code>，后来因为名字跟 <code>Claude</code> 太过相似，被 <code>CLaude</code> 告侵权，遂改名 <code>MoltBot</code> 。</p>\n<p>但是后来在改名过程中遭遇域名和社交账号被抢注，甚至出坑同名加密货币割韭菜的情况，导致名称传播受阻。</p>\n<p>最终定名为：<strong>OpenClaw</strong>。</p>\n<p>所以，名字经历先后顺序为：ClawdBot -&gt; MoltBot -&gt; OpenClaw</p>\n<p>大家不要因为名字困惑了，怀疑是不是自己下错软件了，他们都是同一个。</p>\n<h1 id=\"一什么是-openclaw\">一、什么是 OpenClaw？</h1>\n<p><strong>OpenClaw</strong>（曾用名 Clawdbot）是一款 2026 年爆火的开源个人 AI 助手，GitHub 星标已超过 10 万颗。与传统 AI 聊天机器人的根本区别在于：</p>\n<ul>\n<li><strong>真正的执行能力</strong>：不仅能回答问题，还能实际操作你的电脑</li>\n<li><strong>24/7 全天候待命</strong>：在你睡觉时也能主动完成任务</li>\n<li><strong>完全开源免费</strong>：数据完全掌控在自己手中</li>\n<li><strong>支持多种通讯平台</strong>：在国外，WhatsApp、Telegram、Discord、Slack、iMessage 等，在国内，飞书，钉钉等各大厂商的即时聊天软件已经支持接入</li>\n</ul>\n<p><strong>它能做什么？</strong></p>\n<p>它不只是回答问题的聊天机器人，而是真的能在你电脑上动手操作。比如你告诉它“帮我整理一下上个月的邮件”，它就默默去处理了；你睡觉时，它还能继续干活，退订广告、预约行程、甚至找找 Bug。</p>\n<p>它完全免费，你的数据都在自己手里。而且可以用钉钉，飞书，WhatsApp、Telegram等各类即时通讯软件来指挥他干活！</p>\n<p>简单来说，一句话交给它，从整理桌面文件到控制家里灯光，它都默默帮你搞定。是你电脑里真正的贾维斯！超级智能的AI助理！</p>\n<h1 id=\"二安装nodejs\">二、安装nodejs</h1>\n<p>后面执行一键安装命令，可以自动安装nodejs，但是如果为了加快速度，防止安装意外，可以先安装nodejs：</p>\n<p>官方下载地址：<a href=\"https://nodejs.org/zh-cn/download\" rel=\"noopener nofollow\" target=\"_blank\">https://nodejs.org/zh-cn/download</a><br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<h1 id=\"三开始安装\">三、开始安装</h1>\n<h3 id=\"一设置-powershell-执行权限\">一）设置 PowerShell 执行权限</h3>\n<p>以管理员身份运行 PowerShell：</p>\n<ol>\n<li>按 <code>Win</code> 键，搜索 <strong>PowerShell</strong></li>\n<li>右键点击 <strong>Windows PowerShell</strong></li>\n<li>选择 <strong>以管理员身份运行</strong></li>\n<li>点击 <strong>是</strong> 确认<br />\n<img alt=\"\" class=\"lazyload\" /></li>\n</ol>\n<p>在管理员 PowerShell 窗口中，依次执行以下两条命令：</p>\n<pre><code class=\"language-powershell\">Set-ExecutionPolicy RemoteSigned -Scope CurrentUser\n\nSet-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass\n</code></pre>\n<p><strong>这是什么意思？</strong></p>\n<ul>\n<li>第一条命令：允许当前用户运行本地和下载的脚本</li>\n<li>第二条命令：允许当前用户运行本地和下载的脚本</li>\n</ul>\n<blockquote>\n<p>⚠️ <strong>安全提示</strong>：这些命令只会影响您自己的账户，不会影响系统安全或其他用户。</p>\n</blockquote>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"二执行一键安装命令\">二）执行一键安装命令</h3>\n<p>复制以下命令，粘贴到 PowerShell 窗口中，按 <strong>Enter</strong> 执行：</p>\n<pre><code class=\"language-powershell\">iwr -useb https://openclaw.ai/install.ps1 | iex\n</code></pre>\n<p><strong>安装过程会自动完成：</strong></p>\n<ul>\n<li>检测系统环境</li>\n<li>安装必要依赖（Node.js 等）</li>\n<li>下载 OpenClaw 核心文件</li>\n<li>配置环境变量</li>\n<li>启动配置向导</li>\n</ul>\n<blockquote>\n<p>注意：如果命令执行后，还是报错，可以自己到官网下载node安装包，自己安装node环境，注意版本最好在 node v22.x 以上，node官网下载地址：<a href=\"https://nodejs.org/zh-cn/download%EF%BC%8C%E8%8B%A5%E8%BF%98%E6%98%AF%E4%B8%8D%E6%87%82%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85%EF%BC%8C%E7%82%B9%E5%A4%B4%E5%83%8F%E8%BF%9B%E6%88%91%E4%B8%BB%E9%A1%B5%E6%89%BE%E5%88%B0%E6%88%91%EF%BC%8C%E6%8B%89%E4%BD%A0%E8%BF%9B%E4%BA%A4%E6%B5%81%E7%BE%A4\" rel=\"noopener nofollow\" target=\"_blank\">https://nodejs.org/zh-cn/download，若还是不懂怎么安装，点头像进我主页找到我，拉你进交流群</a></p>\n</blockquote>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h1 id=\"四初始配置向导\">四、初始配置向导</h1>\n<p>安装完成后，会自动进入配置向导（<code>openclaw onboard</code>）。</p>\n<h2 id=\"一风险告知\">一）风险告知</h2>\n<p>这一步主要是告诉你，使用OpenClaw可能会有一些风险。请问你是否继续？<br />\n按 向左方向键 ←，选择 <code>Yes</code>，按 <code>Enter</code> 回车确认<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"二选择-qiuickstart-模式\">二）选择 QiuickStart 模式</h2>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"三配置-ai-模型-api-key\">三）配置 AI 模型 API Key</h2>\n<p>OpenClaw 需要连接到大语言模型才能工作。Openclaw 比较费token，国外模型成本高，门槛也高，这里我选择国内的智谱的 GLM 4.7</p>\n<blockquote>\n<p>如果没有智谱的API Key，点击官方地址自己注册账号获取API key：<a href=\"https://www.bigmodel.cn/glm-coding?ic=RBSKXMPNJP\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bigmodel.cn/glm-coding?ic=RBSKXMPNJP</a></p>\n</blockquote>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>输入自己的 API Key：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"四选择-ai-模型\">四）选择 AI 模型</h2>\n<blockquote>\n<p>这里我选择默认的GLM 4.7，也是智普当前的旗舰模型</p>\n</blockquote>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"五连接即时通讯平台\">五）连接即时通讯平台</h2>\n<p>配置完 AI 模型后，OpenClaw 会询问你要连接哪个通讯平台？</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>OpenClaw 原生支持的即时通信平台主要是海外的 WhatsApp、Telegram、Discord、Slack、iMessage 等，国内用户不习惯，这里国产即时通信软件大厂也跟进了，现在钉钉，飞书等都已支持接入OpenClaw</p>\n</blockquote>\n<p>后面会带领大家把飞书机器人接入 OpenClaw，使大家可以通过飞书即可指挥OpenClaw为我们干活，但是飞书配置比较复杂，这里我们先选择跳过，后面我们可以通过继续进行配置：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"六选择skills\">六）选择Skills</h2>\n<p>这里也选择：No，暂不配置，后面通过UI界面进行配置：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"七是否开启hooks\">七）是否开启Hooks</h2>\n<p>操作步骤：先敲<strong>空格</strong>，表示选中当前项，再敲回车键</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"八启动服务并打开ui界面\">八）启动服务并打开UI界面</h2>\n<p>此时它会自动再打开一个命令窗口来启动服务:</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>这个过程是在启动服务，可能会需要等一点时间</p>\n</blockquote>\n<p>同时，大约过30秒左右，我们回到刚才的设置窗口，选择 <code>Open the Web UI</code> ，打开 <code>OpenClaw</code> 的UI界面：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>浏览器自动打开Web UI界面：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"九测试一下\">九）测试一下</h2>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h1 id=\"五接入飞书机器人\">五、接入飞书机器人</h1>\n<p>我们需要先到飞书平台创建自己的机器人来接入OpenClaw：</p>\n<h2 id=\"一来到飞书开发者后台\">一）来到飞书开发者后台</h2>\n<p>飞书开放平台地址：<a href=\"https://open.feishu.cn\" rel=\"noopener nofollow\" target=\"_blank\">https://open.feishu.cn</a></p>\n<blockquote>\n<p>没有飞书账号的，需要自己注册账号</p>\n</blockquote>\n<p>点击右上角进入 <strong>开发者后台</strong>：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"二创建应用\">二）创建应用</h2>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"三填写应用信息\">三）填写应用信息</h2>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"四获取自己的应用凭证\">四）获取自己的应用凭证</h2>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"五给应用添加机器人\">五）给应用添加机器人</h2>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"六给应用配置权限\">六）给应用配置权限</h2>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>把即时通讯相关的权限全部开通：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"七创建版本并发布\">七）创建版本并发布</h2>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>来到飞书客户端进行审批：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"八安装飞书插件\">八）安装飞书插件</h2>\n<p>打开powershell，输入以下命令，安装飞书插件：</p>\n<pre><code>openclaw plugins install @m1heng-clawd/feishu\n</code></pre>\n<p>安装成功后，再打开一个新的命令窗口，开始配置飞书插件：</p>\n<p>输入命令：<code>openclaw config</code></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>选择渠道:<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>选择配置链接:<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>输入飞书的AppID，AppSecrect：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>域名选择中国的：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>接受群组聊天：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>选择完成：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>选择yes：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>选择open：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>选择继续，完成配置：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>重启服务，使配置生效：<br />\n控制可以看到飞书插件已经配置成功<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"七回到飞书后台设置事件回调\">七）回到飞书后台设置事件回调</h2>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>选择 <code>使用长连接接收事件</code> ：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>可以看到添加事件按钮由原来的灰色不可点击变为可点击：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>添加接收消息事件：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>给应用开通获取通讯录基本信息的权限：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>重新发布版本：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>跟前面的步骤一样，发布为在线应用即可。</p>\n<p>现在可以在 飞书中与 AI 助手对话了！</p>\n<h2 id=\"八在飞书中与openclaw对话\">八）在飞书中与OpenClaw对话</h2>\n<p>来到飞书客户端或者手机飞书app上：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>以下是openclaw文件夹下面的文档内的内容：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>现在我跟废水机器人对话，让他告诉我指定文档内是什么内容：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"六访问-web-控制面板\">六、访问 Web 控制面板</h1>\n<p>配置完成后，PowerShell 窗口底部会显示控制面板链接，格式类似：</p>\n<pre><code>Control UI: http://127.0.0.1:18789\n</code></pre>\n<ol>\n<li>复制完整链接</li>\n<li>在浏览器中打开</li>\n<li>即可看到可视化UI管理界面</li>\n</ol>\n<hr />\n<h1 id=\"七常用命令速查\">七、常用命令速查</h1>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>openclaw onboard</code></td>\n<td>重新进入配置向导</td>\n</tr>\n<tr>\n<td><code>openclaw status</code></td>\n<td>查看运行状态</td>\n</tr>\n<tr>\n<td><code>openclaw health</code></td>\n<td>健康检查</td>\n</tr>\n<tr>\n<td><code>openclaw gateway start</code></td>\n<td>启动服务</td>\n</tr>\n<tr>\n<td><code>openclaw gateway stop</code></td>\n<td>停止服务</td>\n</tr>\n<tr>\n<td><code>openclaw update</code></td>\n<td>更新到最新版本</td>\n</tr>\n<tr>\n<td><code>openclaw doctor</code></td>\n<td>诊断问题</td>\n</tr>\n<tr>\n<td><code>openclaw uninstall</code></td>\n<td>卸载 OpenClaw</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h1 id=\"八常见问题解答\">八、常见问题解答</h1>\n<h3 id=\"q1-安装飞书插件提示spawn-npm-enoent\">Q1: 安装飞书插件提示：spawn npm ENOENT</h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>问题原因：这可能是openclaw的一个bug，可以等官方更新，也可以自己去官方仓库提issue</p>\n<p>解决步骤：</p>\n<p>定位问题代码</p>\n<p>文件路径：</p>\n<pre><code>C:\\Users\\Administrator\\AppData\\Roaming\\fnm\\node-versions\\v22.14.0\\installation\\node_modules\\openclaw\\dist\\process\\exec.js\n</code></pre>\n<p>修改代码</p>\n<p>找到 <code>runCommandWithTimeout</code> 函数中的 spawn 调用，修改如下：</p>\n<p><strong>修改前：</strong></p>\n<pre><code class=\"language-javascript\">const stdio = resolveCommandStdio({ hasInput, preferInherit: true });\nconst child = spawn(argv[0], argv.slice(1), {\n    stdio,\n    cwd,\n    env: resolvedEnv,\n    windowsVerbatimArguments,\n});\n</code></pre>\n<p><strong>修改后：</strong></p>\n<pre><code class=\"language-javascript\">const stdio = resolveCommandStdio({ hasInput, preferInherit: true });\n// On Windows, npm must be spawned with shell: true or use .cmd extension\nlet command = argv[0];\nlet useShell = false;\nif (process.platform === \"win32\" &amp;&amp; path.basename(command) === \"npm\") {\n    useShell = true;\n}\nconst child = spawn(command, argv.slice(1), {\n    stdio,\n    cwd,\n    env: resolvedEnv,\n    shell: useShell,\n});\n</code></pre>\n<h3 id=\"q2-提示-openclaw-命令找不到\">Q2: 提示 \"openclaw 命令找不到\"</h3>\n<p><strong>解决方法：</strong></p>\n<ol>\n<li>关闭所有 PowerShell 窗口</li>\n<li>重新打开 PowerShell</li>\n<li>如果还不行，执行 <code>exec bash</code> 或重启电脑</li>\n</ol>\n<h3 id=\"q3-安装卡住不动\">Q3: 安装卡住不动</h3>\n<p><strong>解决方法：</strong></p>\n<ol>\n<li>按 <code>Ctrl + C</code> 中断当前操作</li>\n<li>执行：<code>openclaw doctor</code> 检查问题</li>\n<li>如提示网络问题，检查防火墙设置</li>\n</ol>\n<h3 id=\"q4-api-key-配置错误\">Q4: API Key 配置错误</h3>\n<p><strong>解决方法：</strong></p>\n<ol>\n<li>执行：<code>openclaw onboard</code></li>\n<li>选择重新配置 API Key</li>\n<li>确保密钥格式正确</li>\n</ol>\n<h3 id=\"q5-端口-18789-被占用\">Q5: 端口 18789 被占用</h3>\n<p><strong>解决方法：</strong></p>\n<pre><code class=\"language-powershell\">openclaw gateway --port 18790\n</code></pre>\n<p>使用其他端口启动服务。</p>\n<h1 id=\"九成本说明\">九、成本说明</h1>\n<p>OpenClaw 软件本身完全免费，主要成本来自 AI 模型 API 调用，可选择国产大模型，降低成本。</p>\n<hr />\n<h1 id=\"结语\">结语</h1>\n<p>OpenClaw 代表了个人 AI 助理的未来趋势——从\"聊天工具\"进化为\"执行工具\"。虽然目前的配置过程对小白用户有一定门槛，但一旦完成设置，您将拥有一个 24/7 待命的超级助手。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 19:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/weipo0105\">阿坡RPA</a>&nbsp;\n阅读(<span id=\"post_view_count\">316</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Redis快速实现布隆过滤器：缓存去重的“智能门卫”",
      "link": "https://www.cnblogs.com/sun-10387834/p/19522155",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19522155\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 18:32\">\n    <span>Redis快速实现布隆过滤器：缓存去重的“智能门卫”</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在缓存架构中，总有一些“头疼问题”：用户反复提交相同请求、查询不存在的key导致缓存穿透、海量数据去重效率低下……这些场景下，Redis布隆过滤器就是当之无愧的“救星”。它像一个智能门卫，能快速判断“这个人是不是来过”“这个key是不是不存在”，用极小的空间成本实现高效过滤，性能远超传统的数据库查询或全量缓存校验。</p>\n<p>今天咱们就从“是什么、为什么好用、怎么用Redis快速实现”三个维度，用通俗的语言+实操代码，把布隆过滤器讲透。全程避开复杂公式，就算是刚接触缓存的同学，也能跟着步骤快速落地。</p>\n<h2 id=\"一先搞懂布隆过滤器到底是个啥\">一、先搞懂：布隆过滤器到底是个啥？</h2>\n<p>布隆过滤器（Bloom Filter）本质是一个<strong>基于哈希函数的概率型数据结构</strong>，核心作用是“快速判断一个元素是否存在于集合中”。它不像哈希表那样存储完整数据，而是用一个二进制数组（bit数组）+多个哈希函数，通过标记元素的哈希位置来实现过滤。</p>\n<p>咱们用“小区门卫记访客”的场景类比，秒懂核心逻辑：</p>\n<ul>\n<li>\n<p>二进制数组 = 门卫的登记本，每一页只有“是”（1）和“否”（0）两个状态；</p>\n</li>\n<li>\n<p>哈希函数 = 门卫的“记忆规则”，比如“记住访客的姓氏首字母+身高区间+鞋子颜色”；</p>\n</li>\n<li>\n<p>元素存在判断 = 门卫根据记忆规则核对登记本，只要有一条规则对应“否”，就确定访客没来过；如果全是“是”，则大概率来过（存在极小误判）。</p>\n</li>\n</ul>\n<h3 id=\"核心特性优点与小瑕疵\">核心特性：优点与“小瑕疵”</h3>\n<p>布隆过滤器的优势和局限性都很鲜明，落地前必须摸清：</p>\n<h4 id=\"-核心优点\">✅ 核心优点</h4>\n<ul>\n<li>\n<p>空间占用极小：仅用bit数组存储标记，存储100万条数据，误判率1%时，仅需约1.2MB空间；</p>\n</li>\n<li>\n<p>查询速度极快：时间复杂度是O(k)（k是哈希函数个数），无论数据量多大，都能瞬间返回结果；</p>\n</li>\n<li>\n<p>支持海量数据：无需存储完整数据，可轻松应对千万级、亿级数据的过滤场景。</p>\n</li>\n</ul>\n<h4 id=\"-不可忽视的局限性\">❌ 不可忽视的局限性</h4>\n<ul>\n<li>\n<p>存在误判率：只能确定“元素一定不存在”，不能100%确定“元素一定存在”，误判率可通过参数调整，但无法完全消除；</p>\n</li>\n<li>\n<p>不支持删除操作：一旦元素被标记到bit数组，无法反向清除（会影响其他元素的判断）；</p>\n</li>\n<li>\n<p>需提前预估数据量：哈希函数个数、bit数组长度需根据预估数据量计算，否则会导致误判率飙升。</p>\n</li>\n</ul>\n<h2 id=\"二redis实现布隆过滤器的两种方式\">二、Redis实现布隆过滤器的两种方式</h2>\n<p>Redis本身没有内置布隆过滤器，但提供了两种快速实现的方案：一是基于Redis的BitMap（位图）手动实现，灵活可控；二是使用Redis官方推荐的Redisson客户端，封装好现成API，开箱即用。咱们分别讲实操，按需选择即可。</p>\n<h3 id=\"方案一基于bitmap手动实现灵活可控\">方案一：基于BitMap手动实现（灵活可控）</h3>\n<p>核心思路：利用Redis的BitMap数据结构作为布隆过滤器的bit数组，通过多个哈希函数计算元素的哈希值，将对应位置的bit置为1；查询时，同样计算哈希值，检查所有位置是否为1，全为1则大概率存在，否则一定不存在。</p>\n<h4 id=\"1-关键参数计算避免误判率过高\">1. 关键参数计算（避免误判率过高）</h4>\n<p>手动实现前，需先确定三个核心参数，可通过公式或在线工具计算：</p>\n<ul>\n<li>\n<p>m：bit数组长度（单位：bit），预估数据量n越大，m需越大；</p>\n</li>\n<li>\n<p>k：哈希函数个数，k过多会导致bit数组快速被占满，误判率上升；k过少则过滤效果差；</p>\n</li>\n<li>\n<p>p：可接受的误判率（通常设为0.01~0.1）。</p>\n</li>\n</ul>\n<p>常用计算公式（无需死记，在线工具直接算）：</p>\n<ul>\n<li>\n<p>m = - (n * ln p) / (ln 2)² （bit数组长度）；</p>\n</li>\n<li>\n<p>k = (m / n) * ln 2 （哈希函数个数）。</p>\n</li>\n</ul>\n<p>举个例子：预估存储10万条数据，误判率设为0.01，计算得m≈958505 bit（约117KB），k≈7个哈希函数。</p>\n<h4 id=\"2-手动实现代码java示例\">2. 手动实现代码（Java示例）</h4>\n<p>核心是实现多个哈希函数，操作Redis的BitMap指令（SETBIT置1，GETBIT查询）：</p>\n<pre><code class=\"language-java\">import org.springframework.data.redis.core.StringRedisTemplate;\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\n/**\n * 基于Redis BitMap手动实现布隆过滤器\n */\npublic class RedisBloomFilter {\n    // Redis键名\n    private final String key;\n    // bit数组长度\n    private final long bitSize;\n    // 哈希函数个数\n    private final int hashCount;\n    private final StringRedisTemplate stringRedisTemplate;\n\n    // 构造器：初始化参数\n    public RedisBloomFilter(String key, long n, double p, StringRedisTemplate stringRedisTemplate) {\n        this.key = key;\n        this.stringRedisTemplate = stringRedisTemplate;\n        // 计算bit数组长度\n        this.bitSize = (long) (-n * Math.log(p) / (Math.log(2) * Math.log(2)));\n        // 计算哈希函数个数\n        this.hashCount = (int) (this.bitSize / n * Math.log(2));\n    }\n\n    // 添加元素到布隆过滤器\n    public void add(Object value) {\n        byte[] bytes = value.toString().getBytes(StandardCharsets.UTF_8);\n        long[] hashes = hash(bytes, hashCount, bitSize);\n        for (long hash : hashes) {\n            // 把对应bit位置置为1\n            stringRedisTemplate.opsForValue().setBit(key, hash, true);\n        }\n    }\n\n    // 判断元素是否存在（存在返回true，不存在返回false；true可能是误判）\n    public boolean contains(Object value) {\n        byte[] bytes = value.toString().getBytes(StandardCharsets.UTF_8);\n        long[] hashes = hash(bytes, hashCount, bitSize);\n        for (long hash : hashes) {\n            // 只要有一个bit位为0，就确定不存在\n            if (!stringRedisTemplate.opsForValue().getBit(key, hash)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // 多哈希函数实现（基于MD5拆分）\n    private long[] hash(byte[] bytes, int hashCount, long bitSize) {\n        long[] hashes = new long[hashCount];\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            byte[] digest = md5.digest(bytes);\n            // 把MD5结果（16字节）拆分成多个哈希值\n            for (int i = 0; i &lt; hashCount; i++) {\n                long hash = 0;\n                for (int j = i * 2; j &lt; (i + 1) * 2 &amp;&amp; j &lt; digest.length; j++) {\n                    hash = hash * 256 + (digest[j] &amp; 0xFF);\n                }\n                // 确保哈希值在bit数组长度范围内\n                hashes[i] = hash % bitSize;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"哈希函数初始化失败\", e);\n        }\n        return hashes;\n    }\n}\n</code></pre>\n<h4 id=\"3-使用方式\">3. 使用方式</h4>\n<pre><code class=\"language-java\">// 初始化布隆过滤器：key为\"user:bloom:filter\"，预估10万条数据，误判率0.01\nRedisBloomFilter bloomFilter = new RedisBloomFilter(\"user:bloom:filter\", 100000, 0.01, stringRedisTemplate);\n\n// 添加元素\nbloomFilter.add(\"user123\");\nbloomFilter.add(\"order456\");\n\n// 判断元素是否存在\nboolean exists = bloomFilter.contains(\"user123\"); // 大概率返回true\nboolean notExists = bloomFilter.contains(\"user789\"); // 一定返回false\n</code></pre>\n<h3 id=\"方案二redisson客户端实现开箱即用\">方案二：Redisson客户端实现（开箱即用）</h3>\n<p>如果觉得手动实现麻烦，推荐用Redisson——Redis官方生态的Java客户端，已经封装好了布隆过滤器，支持自动计算参数、分布式场景，还解决了手动实现的哈希函数优化问题，生产环境首选。</p>\n<h4 id=\"1-引入依赖\">1. 引入依赖</h4>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.redisson&lt;/groupId&gt;\n    &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;3.23.3&lt;/version&gt; // 版本与Redis版本适配\n&lt;/dependency&gt;\n</code></pre>\n<h4 id=\"2-快速实现代码\">2. 快速实现代码</h4>\n<pre><code class=\"language-java\">import org.redisson.api.RBloomFilter;\nimport org.redisson.api.RedissonClient;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class RedissonBloomFilterDemo {\n    @Autowired\n    private RedissonClient redissonClient;\n\n    // 初始化布隆过滤器\n    public RBloomFilter&lt;String&gt; initBloomFilter() {\n        // 布隆过滤器名称\n        String filterName = \"user:bloom:filter:redisson\";\n        // 获取布隆过滤器实例\n        RBloomFilter&lt;String&gt; bloomFilter = redissonClient.getBloomFilter(filterName);\n        // 初始化：预估10万条数据，误判率0.01（Redisson会自动计算m和k）\n        bloomFilter.tryInit(100000, 0.01);\n        return bloomFilter;\n    }\n\n    // 测试使用\n    public void testBloomFilter() {\n        RBloomFilter&lt;String&gt; bloomFilter = initBloomFilter();\n        // 添加元素\n        bloomFilter.add(\"user123\");\n        bloomFilter.add(\"order456\");\n\n        // 判断元素是否存在\n        boolean exists = bloomFilter.contains(\"user123\"); // 大概率true\n        boolean notExists = bloomFilter.contains(\"user789\"); // 一定false\n\n        // 统计已添加元素数量（近似值）\n        long count = bloomFilter.count();\n        System.out.println(\"已添加元素数量：\" + count);\n    }\n}\n</code></pre>\n<h4 id=\"3-核心优势\">3. 核心优势</h4>\n<ul>\n<li>\n<p>分布式支持：适配微服务场景，多实例共享同一个布隆过滤器，无需担心数据一致性；</p>\n</li>\n<li>\n<p>参数优化：内置更高效的哈希函数（MurmurHash），误判率控制更精准；</p>\n</li>\n<li>\n<p>API丰富：支持元素计数、批量添加等功能，比手动实现更完善。</p>\n</li>\n</ul>\n<h2 id=\"三实际应用场景与避坑指南\">三、实际应用场景与避坑指南</h2>\n<h3 id=\"-典型应用场景\">✅ 典型应用场景</h3>\n<ol>\n<li>\n<p>缓存穿透防护：查询数据库前，先用布隆过滤器判断key是否存在，不存在则直接返回，避免大量无效数据库查询；</p>\n</li>\n<li>\n<p>海量数据去重：比如用户签到、日志去重、爬虫URL去重，无需存储全量数据，仅用bit数组标记；</p>\n</li>\n<li>\n<p>防止重复提交：接口请求前，用布隆过滤器判断请求ID是否已处理，避免重复业务逻辑执行；</p>\n</li>\n<li>\n<p>黑名单过滤：比如垃圾邮件识别、恶意IP拦截，快速判断是否在黑名单中。</p>\n</li>\n</ol>\n<h3 id=\"-避坑指南\">❌ 避坑指南</h3>\n<ul>\n<li>\n<p>不要用在“绝对不能误判”的场景：比如金融交易、用户登录验证，误判可能导致严重问题；</p>\n</li>\n<li>\n<p>提前预估数据量：若实际数据量远超预估，bit数组会被快速占满，误判率会急剧上升，可预留2~3倍冗余；</p>\n</li>\n<li>\n<p>定期重置布隆过滤器：若数据有过期特性（比如每日黑名单更新），可定期删除旧的布隆过滤器，重建新实例；</p>\n</li>\n<li>\n<p>Redis集群注意事项：手动实现的布隆过滤器若用在Redis集群中，需确保key落在同一个节点（避免哈希分片导致bit数组分散），Redisson已自动处理该问题。</p>\n</li>\n</ul>\n<h2 id=\"四总结什么时候选哪种实现方式\">四、总结：什么时候选哪种实现方式？</h2>\n<p>Redis布隆过滤器的核心价值的是“用极小空间换极高过滤效率”，落地时按场景选择实现方式：</p>\n<ul>\n<li>\n<p>快速落地、生产环境、分布式场景：选Redisson，省心高效，适配性强；</p>\n</li>\n<li>\n<p>学习研究、自定义哈希函数、特殊参数需求：选手动实现，灵活可控，加深对原理的理解。</p>\n</li>\n</ul>\n<p>其实布隆过滤器的逻辑并不复杂，核心就是“哈希标记+概率判断”。掌握它之后，面对缓存穿透、海量去重等问题，就不用再靠“全量存储”这种笨办法，能大幅提升系统性能和空间利用率。下次再遇到类似场景，直接掏出Redis布隆过滤器，轻松搞定！</p>\n\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19522155\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19522155</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 18:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">75</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "架构师必备：灰度方案汇总",
      "link": "https://www.cnblogs.com/toplist/p/19527704",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/toplist/p/19527704\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 17:35\">\n    <span>架构师必备：灰度方案汇总</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>大家好，我是Java烘焙师。本文结合笔者的经验和思考，对灰度方案做个总结，重点介绍AB实验。</p>\n<p>灰度在开发流程中非常普遍。先做小流量验证，确认无误后再推全，灰度过程中一旦发现系统异常、或业务指标异常，应立刻回滚。</p>\n<h1 id=\"灰度场景\">灰度场景</h1>\n<ul>\n<li>代码灰度：是最典型的灰度，灰度内做新逻辑，灰度外做旧逻辑\n<ul>\n<li>既可以提供v2版本新接口给调用方服务，由调用方来做灰度切换</li>\n<li>也可以内部切灰度，做到调用方无感</li>\n</ul>\n</li>\n<li>发版灰度：上线过程中，新版本服务实例不断增加，需考虑兼容新旧协议</li>\n<li>配置灰度：修改配置时，按服务实例灰度推送配置变更</li>\n</ul>\n<h1 id=\"灰度模式\">灰度模式</h1>\n<ul>\n<li>数字id尾号灰度：取id最后2位（百分比）、最后3位（千分比）、最后4位（万分比）等\n<ul>\n<li>实现方式：id取模，例如 <code>id % 100 &lt; 灰度百分比</code>，则命中灰度</li>\n<li>特点：简单，适用于绝大部分技术优化场景</li>\n</ul>\n</li>\n<li>随机灰度：取一部分随机流量做灰度\n<ul>\n<li>实现方式：<code>ThreadLocalRandom.current().nextInt(100) &lt; 灰度百分比</code></li>\n<li>之所以使用ThreadLocalRandom、而不是Random，是为了避免多线程竞争用于生成随机数的seed</li>\n</ul>\n</li>\n<li>A/B实验\n<ul>\n<li>实现方式：分层实验、实验数据收集、离线统计</li>\n<li>特点：适用于小流量验证新业务功能的效果，整体方案相对复杂，需要技术基建</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"id选取\">id选取</h1>\n<ul>\n<li>业务id：如用户id、商品id等</li>\n<li>设备id：未注册/未登录用户，此时没有用户id，只能取设备的唯一标识</li>\n</ul>\n<p>下面重点介绍一下A/B实验。</p>\n<h1 id=\"ab实验\">A/B实验</h1>\n<h2 id=\"目的\">目的</h2>\n<ul>\n<li>小流量验证新业务功能，正向显著则推至全量，否则继续迭代优化、或下线，避免功能过于臃肿</li>\n<li>用数据作为依据，避免想当然、拍脑袋决策</li>\n</ul>\n<h2 id=\"分层实验\">分层实验</h2>\n<p>主要目的是为了同时做多个实验，而不是给每个实验均分一部分流量。因为当同时进行的实验变多时，组合数量成倍增加，每个实验分到的流量就很少了。<br />\n有这几层结构：实验层、实验、分组</p>\n<ul>\n<li>实验层之间正交，可同时进行多个实验层的实验</li>\n<li>同一实验层的实验之间互斥，比如命中了实验1-1，就不会命中实验1-2。实验持有0到多个分桶，根据业务id可计算出桶号，进而知道命中哪个实验</li>\n<li>同一实验内有多个分组，包括1个对照组，和1到多个实验组，只会命中其中一个分组。分组持有0到多个分桶，根据业务id可计算出桶号，进而知道命中哪个分组</li>\n</ul>\n<p>实验层、实验举例：</p>\n<ul>\n<li>展示实验层：根据页面进行划分，如首页、搜索页、推荐页、详情页等。每个页面作为一个实验层，每个实验层里可同时做多个展示实验</li>\n<li>算法实验层：根据场景进行划分，如相似推荐、搭配购推荐、个性化推荐、搜索排序、广告排序等。每个场景作为一个实验层，每个实验层里可同时做多个算法实验</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1247698/202601/1247698-20260127012326894-198795136.png\" /></p>\n<h2 id=\"哈希算法打散\">哈希算法打散</h2>\n<p>要同时支持多个分层实验，核心在于通过哈希算法将每一层的流量打散，用于实现“均匀分流”和“层间正交”，使得流量在各个实验的效果正负抵消，才能得到真实的对比结果。<br />\n以下是计算实验层桶号的代码示例，实验桶号同理：</p>\n<pre><code class=\"language-java\">import com.google.common.hash.Hashing;\nimport java.nio.charset.StandardCharsets;\n\npublic class ABTestRouter {\n\n    /**\n     * 根据用户ID和实验层ID（实验层ID充当盐的角色），计算桶号 (0-99)\n     */\n    public static int getBucket(String userId, String layerId) {\n        // 1. 拼接 Key: \"layerId:userId\"\n        String key = layerId + \":\" + userId;\n\n        // 2. 使用 MurmurHash3 (32-bit)\n        // Guava 的 murmur3_32_fixed 是线程安全的\n        int hash = Hashing.murmur3_32_fixed()\n                .hashString(key, StandardCharsets.UTF_8)\n                .asInt();\n\n        // 3. 取模并确保结果为正数\n        // Math.abs(Integer.MIN_VALUE) 会返回负数，所以推荐使用位运算去除符号位\n        return (hash &amp; Integer.MAX_VALUE) % 100;\n    }\n\n    public static void main(String[] args) {\n        String uid = \"user_123456\";\n        \n        // 不同层的流量是正交的（打散重新分配）\n        System.out.println(\"展示层桶号: \" + getBucket(uid, \"layer_ui\"));\n        System.out.println(\"算法层桶号: \" + getBucket(uid, \"layer_algo\"));\n    }\n}\n</code></pre>\n<p>之所以用murmurhash，而非md5，是因为md5是加密算法，计算开销更大，在AB实验中仅需均匀打散即可，无需担心根据哈希结果反推原文。<br />\n之所以把实验层id作为盐，是因为微小的输入差异都会导致哈希结果相差巨大，实现打散的效果。</p>\n<h2 id=\"实验数据收集\">实验数据收集</h2>\n<p>实验数据收集流程如下：</p>\n<ul>\n<li>在AB实验管理系统中配置实验信息：如实验盐值、桶号与实验组的映射关系等，可动态修改</li>\n<li>代码逻辑开发：\n<ul>\n<li>引入实验sdk，sdk在启动、或配置变更时拉取实验信息，本地计算业务id的桶号，进而得到命中的分组</li>\n<li>对照组做当前逻辑，实验组1做逻辑1，实验组2做逻辑2</li>\n</ul>\n</li>\n<li>在正式开始AB实验之前，先做AA分桶实验，模拟实验组、对照组的结果，判断是否均匀，避免分桶不均匀带来错误的实验结果</li>\n<li>实验开始，后端埋点：sdk发出后端埋点消息\n<ul>\n<li>消息格式举例：<code>业务id, 实验层id, 实验id, 分组id, 桶号, 触发时间</code></li>\n</ul>\n</li>\n<li>实验过程：实验持续时间至少一周，覆盖工作日、周末/假期，避免受时间周期带来的波动影响</li>\n<li>离线统计实验效果：\n<ul>\n<li>后端埋点数据导入曝光事件hive表</li>\n<li>业务DB数据导入行为事件hive表，如注册、登录、浏览、点击、收藏、加购、下单、支付等，取决于实验关注的业务指标</li>\n<li>把曝光事件、行为事件join起来，对比实验组、对照组的业务指标差异</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1247698/202601/1247698-20260131014010302-1779078827.png\" /></p>\n<p>以下是sql示例，代表从实验曝光后24小时内各个分组的转化率对比。</p>\n<pre><code class=\"language-sql\">SELECT \n    e.group_id,\n    COUNT(DISTINCT e.user_id) as exposed_users,\n    COUNT(DISTINCT a.user_id) as converted_users,\n    COUNT(DISTINCT a.user_id) / COUNT(DISTINCT e.user_id) as conversion_rate\nFROM exposure_events e\nLEFT JOIN action_events a ON e.user_id = a.user_id \n    AND a.event_time BETWEEN e.event_time AND (e.event_time + INTERVAL 24 HOUR)\nWHERE e.experiment_id = 'ui_test_001'\nGROUP BY e.group_id;\n</code></pre>\n<h2 id=\"实验报表分析\">实验报表分析</h2>\n<p>评估实验结果是否正向、是否显著。了解统计学里的核心概念，能看懂实验报表即可。</p>\n<h3 id=\"p值\">p值</h3>\n<p>用来衡量实验结果是否显著，p值的含义是：假设实验组与对照组没有区别，此时观察到实验有差异的概率。一般要求 <code>p &lt; 0.05</code>，也就是说实验结果显著的概率大于95%（<code>1 - 0.05 = 95%</code>）</p>\n<h3 id=\"置信区间\">置信区间</h3>\n<p>在显著的前提下，用来衡量实验结果是否正向，代表业务指标的可能范围分布。<br />\n比如：实验结果里业务指标提升了1%，95%置信区间在[0.8%, 1.2%]，则代表有95%的把握可以把业务指标提升至少0.8%、至多1.2%，效果正向。如果置信区间的下界是负数，就有可能是负向效果了，需要警惕。</p>\n<p>以上就是灰度方案的总结了，欢迎讨论交流。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 17:35</span>&nbsp;\n<a href=\"https://www.cnblogs.com/toplist\">Java烘焙师</a>&nbsp;\n阅读(<span id=\"post_view_count\">80</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "硬核科普：为何小米任天堂封杀 Root？揭秘操作系统从启动到“夺权”的底层游戏",
      "link": "https://www.cnblogs.com/kaiux/p/19558207",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kaiux/p/19558207\" id=\"cb_post_title_url\" title=\"发布于 2026-01-31 15:40\">\n    <span>硬核科普：为何小米任天堂封杀 Root？揭秘操作系统从启动到“夺权”的底层游戏</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"硬核科普：为何小米任天堂封杀 Root？揭秘操作系统从启动到“夺权”的底层游戏\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131154106142-1968484472.png\" />\n        小米锁BL、任天堂反破解，厂商在怕什么？本文硬核拆解从开机到“夺权”的底层逻辑。穿越UEFI权力交接，揭秘Ring0物理防线与Root本质，深度剖析Switch硬破的“电压故障注入”原理。带你深入微观世界，看懂这场芯片深处的信任链攻防战。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近机圈最热闹的两件事：一是小米彻底收紧了 Bootloader 解锁权限，二是任天堂又起诉了几个卖 Switch 破解芯片的商家。</p>\n<p>很多兄弟可能会觉得：“我花钱买的硬件，凭什么不让我完全控制？”</p>\n<p>但在厂商的逻辑里，<strong>一旦你拿到了最高权限，你就打破了我们辛苦建立的“商业围墙”。</strong></p>\n<p>为了看懂这场关于“控制权”的战争，我们不需要去啃枯燥的《操作系统导论》，只需要把视角缩小到纳秒级别，看看当你按下电源键的那一惊心动魄的瞬间，计算机内部到底上演了一场怎样的“权力交接”。</p>\n<h2 id=\"一蛮荒时代的地图\">一、蛮荒时代的地图</h2>\n<p>在 CPU 刚刚醒来的那一刻，它面对的是一片漆黑的存储荒原——硬盘。要把庞大的操作系统装进脑子（内存）里，首先得有一张地图。</p>\n<p><strong>1. MBR：上一代的老地图</strong></p>\n<p>在以前，我们使用的是 <strong>MBR (Master Boot Record)</strong>。它的样子非常寒酸，只占据硬盘最开头的 <strong>512 字节</strong>。</p>\n<p>哪怕你现在的硬盘有 10TB，MBR 也只有这点地盘。这就导致了它先天不足：因为记录地址的空间太小，它最大只能识别 <strong>2TB</strong> 的硬盘，而且最多只能分 <strong>4 个主分区</strong>。它就像一本只有一页目录的老旧笔记本，既写不下太多东西，也指引不了通往大城市的路。</p>\n<p><strong>2. GPT：新世界的全息导航</strong></p>\n<p>现在的电脑几乎都标配 <strong>UEFI</strong> 启动，与之搭配的是 <strong>GPT (GUID Partition Table)</strong> 分区表。</p>\n<p>它的优势显而易见：彻底打破了容量和分区数量的限制，想分多少就分多少。更重要的是它具备了<strong>容灾机制</strong>——MBR 坏了，整块硬盘的数据可能就读不出来了；但 GPT 聪明地在硬盘的“车头”和“车尾”各存了一份，坏了还能救。</p>\n<p>为了照顾那些老旧的软件，现在的 GPT 硬盘还会在开头保留一个“假装的 MBR”。它的唯一作用就是告诉老软件：“这块硬盘已经有主了，别乱动。”</p>\n<p><img alt=\"mbrvsgpt\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153816610-848754645.jpg\" /></p>\n<h2 id=\"二第一棒火炬手\">二、第一棒火炬手</h2>\n<p>当你按下电源键，电流涌入主板，CPU 做的第一件事是“硬编码”写死的：强制读取一段“绝对权威”的代码。</p>\n<p>这里住着硬件的灵魂——<strong>固件 (Firmware)</strong>。不过，根据设备类型的不同，这里的管家也分为两派。</p>\n<p><strong>1. PC 界的管家：从 BIOS 到 UEFI</strong></p>\n<p>在漫长的 PC 发展史中，管家换了一届。</p>\n<ul>\n<li><strong>老管家叫 BIOS</strong>。它是个守旧派，只懂 16 位汇编语言，只能呆板地读取硬盘头部的 MBR，干活慢且效率低。</li>\n<li><strong>新管家叫 UEFI</strong>。它本质上已经是一个<strong>微型操作系统</strong>了。它能读懂文件系统（比如 FAT32），能直接运行后缀为 <code>.efi</code> 的可执行程序，甚至能联网。这也是为什么现在的 BIOS 界面能用鼠标、能截图，甚至做得花里胡哨的原因。</li>\n</ul>\n<p><img alt=\"bios\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153830288-1861685661.jpg\" /></p>\n<p><strong>2. 嵌入式界的管家：BootROM</strong></p>\n<p>对于<strong>小米手机</strong>或 <strong>Switch</strong> 这种嵌入式设备（通常是 ARM 架构），虽然它们没有像电脑那样可以按 <code>Del</code> 键进入的图形化 UEFI 界面，但核心逻辑是一样的。</p>\n<p>它们依靠的是芯片出厂时就在内部烧录死的一小段代码——<strong>BootROM</strong>。它是硬件苏醒后执行的第一段代码，比任何软件都早，且无法被修改。它的职责单一而神圣：初始化最基本的硬件，然后去寻找并验证下一棒接力者。</p>\n<h2 id=\"三灵活的中间人\">三、灵活的中间人</h2>\n<p>当 UEFI 或 BootROM 自检完硬件，准备把权力移交给操作系统时，它不会直接唤醒 Windows 或 Linux 的内核，而是先唤醒一位中间人——<strong>Bootloader</strong>（在 Linux PC 世界里通常是 GRUB，在安卓/手机世界里通常是 U-Boot 或厂商自研的 Bootloader）。</p>\n<p><strong>为什么要绕一圈，不能直接加载内核吗？</strong></p>\n<p>原因在于操作系统内核（Kernel）太“娇贵”了：</p>\n<ol>\n<li>它可能需要特殊的启动参数（比如你需要进入安全模式，或者开启调试）。</li>\n<li>它可能躺在固件读不懂的文件系统里（比如 Linux 的 Ext4 格式，UEFI 原生可能只认 FAT）。</li>\n<li>你可能安装了双系统，需要有人来问你到底进哪一个。</li>\n</ol>\n<p>所以，Bootloader 就像是一个专业的“领路人”。它负责把内核文件（<code>vmlinuz</code>）和初始化文件系统（<code>initrd</code>）搬运到内存里，一切准备就绪后，执行一个信仰之跃（Jump 指令），将 CPU 的控制权彻底移交给内核。</p>\n<p><img alt=\"bootloader\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153843749-1017464152.jpg\" /></p>\n<h2 id=\"四阶级森严\">四、阶级森严</h2>\n<p>内核（Kernel）一旦接管了 CPU，做的第一件事就是利用 CPU 的硬件特性，建立起森严的等级制度。这是系统安全的基石。</p>\n<p><strong>1. 消失的 Ring 1 和 Ring 2</strong></p>\n<p>Intel x86 架构在设计之初，其实定义了 4 个特权级：<strong>Ring 0</strong>（内核，最高权限）、<strong>Ring 1 &amp; 2</strong>（原本给驱动）、<strong>Ring 3</strong>（应用程序，最低权限）。</p>\n<p><strong>但在现代操作系统（Windows/Linux）中，Ring 1 和 Ring 2 几乎被废弃了，只剩下了两极分化的 Ring 0 和 Ring 3。</strong></p>\n<p>这最核心的原因是<strong>移植性（Portability）</strong>。当年的 Linux 和 Windows NT 为了能跑在不同的 CPU 架构上（比如 MIPS、ARM），遇到了一个大难题：很多非 x86 的 RISC 架构硬件设计上非常精简，<strong>只支持两个层级</strong>（内核态 Kernel Mode 和用户态 User Mode）。为了保证代码通用，操作系统设计者索性决定：“好，那我们也只用两层，把中间的砍掉。”</p>\n<p><strong>2. 物理层面的防线</strong></p>\n<p>现在的 CPU 内部，有一个 <strong>CS 寄存器</strong> 明确记录了当前的身份：</p>\n<ul>\n<li><strong>0 (上帝模式)</strong>：你可以执行所有指令，开关中断、读写任意内存、直接操作硬盘 IO。</li>\n<li><strong>3 (平民模式)</strong>：你只能做数学运算，严禁直接触碰硬件。</li>\n</ul>\n<p>如果你的 App（运行在 Ring 3）试图执行一条“读取硬盘”的汇编指令，CPU 硬件在解码阶段就会发现：“你只有 3 级权限，却想执行 0 级指令？” 于是直接抛出异常，内核捕获后会直接把这个 App 杀掉——这就是程序<strong>崩溃（Crash）</strong>的本质。</p>\n<p><strong>3. 唯一的通道：Syscall</strong></p>\n<p>那平民（App）想办事（比如读文件、联网）怎么办？必须去敲衙门的鼓——这叫<strong>系统调用（Syscall）</strong>。</p>\n<ol>\n<li>App 执行 <code>SYSCALL</code> 指令。</li>\n<li>CPU 瞬间切换到 Ring 0，跳转到内核预设好的代码位置。</li>\n<li><strong>换栈（Stack Switching）</strong>：这是关键一步，CPU 会自动把栈指针从“用户栈”切换到“内核栈”。这是为了防止黑客在栈里埋雷，确保内核在一个绝对干净的环境下工作。</li>\n<li>内核替你办完事，把结果拷回用户内存，然后退回 Ring 3。</li>\n</ol>\n<p><img alt=\"rings\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153901587-891608174.jpg\" /></p>\n<h2 id=\"五真假美猴王\">五、真假美猴王</h2>\n<p>这是很多技术爱好者最容易搞混的地方：<strong>“我手机 Root 了，是不是就意味着我的 App 运行在 Ring 0 了？”</strong></p>\n<p><strong>答案是：NO。即使你 Root 了，你的 App 依然运行在 Ring 3。</strong></p>\n<p><strong>1. Root 只是一个“通行证”</strong></p>\n<p>我们需要区分两个概念：</p>\n<ul>\n<li><strong>Root (User ID = 0)</strong>：这是<strong>软件层面</strong>的概念。它只是 Linux 系统里的一条用户记录。它的权力在于：<strong>内核被设计为“无条件听从 Root 用户的请求”。</strong></li>\n<li><strong>Ring 0</strong>：这是<strong>硬件层面</strong>的概念。只有内核代码本身运行在这里。</li>\n</ul>\n<p><strong>2. 皇帝与刽子手</strong></p>\n<p>当你获取了 Root 权限，运行一个命令 <code>rm -rf /</code>（删库跑路）时，过程是这样的：</p>\n<ol>\n<li><strong>Root 用户</strong> 发起删除文件的请求。</li>\n<li><strong>内核</strong> 检查发起者：哟，是 ID 为 0 的大哥啊。虽然删除系统文件很危险，但既然大哥说了，我就照做。</li>\n<li><strong>内核（Ring 0）</strong> 驱动硬盘磁头，物理擦除数据。</li>\n</ol>\n<p><strong>总结一下</strong>：Root 用户就像是拿着“圣旨”的钦差大臣，但他本身还是个人（运行在 Ring 3）；而 Ring 0 才是那个真正持刀动手的刽子手。<strong>Root 拿到了最高行政权，但没有拿到最高物理执行权。</strong></p>\n<p><img alt=\"rootvsring\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153913727-1769032851.jpg\" /></p>\n<h2 id=\"六打破枷锁\">六、打破枷锁</h2>\n<p>理解了上面的“信任链”和“权限墙”，我们终于可以看懂黑客是如何一步步攻破系统的。这个过程，本质上就是一场精密的外科手术。</p>\n<p><strong>1. 撕开封条：手机解锁 BL (Bootloader)</strong></p>\n<p>正常的手机启动链条是严丝合缝的：<strong>BootROM (硬件)</strong> → <strong>验证 Bootloader 签名</strong> → <strong>验证 Kernel (系统内核) 签名</strong>。</p>\n<p>所谓的 <strong>BL 锁</strong>，就是厂商让 Bootloader 严格查验下一级（Kernel）是不是官方原厂的。如果是官方的，放行；如果被人动过手脚（比如为了 Root），拒绝启动。</p>\n<p>而<strong>解锁 BL</strong>，就是用官方给的工具（或者利用漏洞），给 Bootloader 下达一道指令：“别查签名了，不管我刷进去什么烂七八糟的内核，你都给我跑。”</p>\n<p><em>注意代价：解锁 BL 虽然让你获得了自由，但也<strong>破坏了完整的信任链</strong>（Android Verified Boot）。此时，系统里的 TEE（可信执行环境）会感知到环境不安全，从而导致银行 App 闪退、微信/支付宝指纹支付失效等后果。</em></p>\n<p><strong>2. 植入假肢：从解锁到获取 Root 的全过程</strong></p>\n<p>很多小白以为解了 BL 就自动 Root 了，其实不是。解锁只是打开了大门，房间（系统）还是空的。要拿到 Root，必须进行一场<strong>“器官移植”</strong>。</p>\n<p>以 Android 上最流行的 Magisk 为例，它的核心魔法叫做 <strong>\"Systemless\"（不触动 System 分区）</strong>，标准流程是：</p>\n<ol>\n<li><strong>提取器官</strong>：从官方刷机包里提取出 <strong><code>boot.img</code></strong>。</li>\n<li><strong>手术改造</strong>：Magisk 会像病毒一样，把自己的核心代码（<code>su</code> 文件和守护进程）<strong>注入</strong> 到这个镜像里，而完全不去修改原本的 System 分区。</li>\n<li><strong>移植手术</strong>：因为你之前<strong>解锁了 BL</strong>，Bootloader 看到这个被篡改过的镜像，虽然签名不对，但它耸耸肩：“反正你解锁了，你开心就好”，然后把它刷进了硬盘。</li>\n<li><strong>夺舍</strong>：手机重启，内核加载。Magisk 的守护进程随之启动，接管了权限管理。</li>\n</ol>\n<p><img alt=\"刷机\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153926524-1349870764.jpg\" /></p>\n<p><strong>3. 终极破解：Switch 与芯片硬破</strong></p>\n<p>如果说手机 Root 还是软件层面的博弈，那么 Switch 的破解就是物理层面的暴力美学。Switch 破解的核心动力非常朴素：<strong>因为穷，不想买游戏，所以必须绕过游戏签名验证。</strong></p>\n<p><strong>(1) 上古时代的“软破”</strong></p>\n<p>最早的一批 Switch（2018 年前出厂），芯片（Tegra X1）里的 <strong>BootROM</strong> 代码写挫了。黑客不仅需要用一根回形针<strong>短接手柄滑轨</strong>进入 RCM（恢复）模式，还需要配合<strong>电脑或注入器通过 USB 接口发送一段 Payload</strong>，利用缓冲区溢出漏洞欺骗 CPU。这属于“老天爷赏饭吃”，任天堂除了出新硬件，软件层面根本修补不了。</p>\n<p><strong>(2) 现代的“硬破” (Modchip 芯片破解)</strong></p>\n<p>任天堂后来修复了漏洞。现在的破解必须<strong>拆机</strong>，在主板上极其精细地<strong>焊接一颗第三方芯片</strong>。这玩意的原理叫 <strong>“电压故障注入” (Voltage Glitching)</strong>。</p>\n<ul>\n<li><strong>【原理】</strong> Switch 启动时，CPU 会读取官方 Bootloader 并进行签名校验。</li>\n<li><strong>【攻击】</strong> 焊在主板上的破解芯片像狙击手一样，死死盯着 CPU。当 CPU 准备执行“校验签名”这一行代码的<strong>纳秒级瞬间</strong>，破解芯片突然<strong>拉低 CPU 的核心电压 (VCC)</strong>。</li>\n<li><strong>【结果】</strong> 电压骤降导致 CPU 就像被电击了一下，脑子“懵”了那么一瞬间。它刚好<strong>跳过了校验指令</strong>，或者将寄存器里校验失败的 <code>False</code> 错误地读成了 <code>True</code>。</li>\n</ul>\n<p>这就好比保安拦住你要查身份证，你没带。但在保安张嘴问你“身份证呢？”的一瞬间，你突然在他耳边敲了一记锣。保安脑子一片空白，下意识地摆摆手：“行行行，进去吧。”</p>\n<p><strong>(3) 鸠占鹊巢：Atmosphere (大气层)</strong></p>\n<p>既然通过“电击”保安混进了大门，我们就不加载任天堂官方系统了，而是加载 <strong>Atmosphere</strong>。它本质上是一个<strong>定制的 Bootloader + 系统补丁集</strong>。它接管了启动流程，并且在内存中实时修改任天堂的 OS，欺骗系统说：“这张盗版卡是通过验证的”。</p>\n<p><img alt=\"switch\" src=\"https://img2024.cnblogs.com/blog/1158182/202601/1158182-20260131153938657-967507878.jpg\" /></p>\n<h2 id=\"七猫鼠游戏\">七、猫鼠游戏</h2>\n<p>Root 成功了，并不代表你可以高枕无忧。事实上，这才是你和 App 开发商（尤其是银行、游戏）之间“猫鼠游戏”的开始。</p>\n<p><strong>1. App 是怎么发现你 Root 的？</strong></p>\n<p>App 也是运行在 Ring 3 的平民，它不能直接问 CPU “我是不是被 Root 了”。但它有很多间接手段：</p>\n<ul>\n<li><strong>查户口（文件扫描）</strong>：App 会偷偷扫描你的 <code>/bin</code> 或 <code>/sbin</code> 目录，看看有没有 <code>su</code> 这个文件，或者有没有安装 <code>Magisk Manager</code> 这个 App。</li>\n<li><strong>打电话问家长（Play Integrity API）</strong>：这是最狠的一招。App 会发起一个请求，通过 Google 的服务去询问你的底层硬件。Google 会检查你的 Bootloader 状态。如果你解锁了，硬件层面的 <strong>TEE (可信执行环境)</strong> 就会老实交待：“是的，我的大门被打开了。”</li>\n</ul>\n<p><strong>2. Magisk 的隐身术：命名空间隔离 (Namespace Isolation)</strong></p>\n<p>既然 App 会查文件，那我们在它查房的时候，把违禁品藏起来不就好了？这就是 Magisk Hide（现在进化为 Zygisk/Shamiko）的核心原理。</p>\n<p>Linux 内核有一个强大的功能叫 <strong>Mount Namespace</strong>。它可以让每个进程看到完全不同的文件系统视图。</p>\n<ul>\n<li><strong>平时</strong>：你的文件系统里确实有 Root 相关的文件。</li>\n<li><strong>当你打开银行 App 时</strong>：Magisk 会立刻拦截这个启动过程，为这个银行 App 单独创建一个“平行宇宙”。</li>\n<li><strong>在那个宇宙里</strong>：Magisk 会利用 <code>unmount</code> 指令，把 <code>su</code> 文件、Magisk 相关的模块全部“卸载”掉。</li>\n<li><strong>结果</strong>：银行 App 睁开眼，看到的是一个干干净净、仿佛从未被 Root 过的官方系统。它满意地点点头，让你通过了。</li>\n</ul>\n<p><strong>3. 道高一尺，魔高一丈</strong></p>\n<p>现在，这场战争已经进化到了<strong>硬件层面</strong>。</p>\n<p>像 <strong>KernelSU</strong> 这种新一代 Root 方案，直接把自己藏进了内核里（Ring 0），让运行在 Ring 3 的 App 根本无从查起。而 App 厂商则开始联合手机厂商，试图通过<strong>硬件密钥证明 (Key Attestation)</strong> 让你在解锁 Bootloader 的那一刻起，就永远失去通过“安全验证”的资格。</p>\n<p>只要你为了自由解开了锁，你就注定要一直在这个猫鼠游戏里通过不断的“伪装”生存下去。</p>\n<h2 id=\"八总结心智模型\">八、总结：心智模型</h2>\n<p>看完全文，你应该在脑海里建立起这样一张图：</p>\n<ol>\n<li><strong>地图 (MBR 与 GPT)</strong>：决定了地盘怎么分。</li>\n<li><strong>接力 (BootROM/UEFI → Bootloader → Kernel)</strong>：是一场从硬件到软件的信任接力赛。</li>\n<li><strong>高墙 (Ring 0 vs Ring 3)</strong>：是为了防止平民（App）瞎搞硬件。</li>\n<li><strong>Root</strong>：是 Ring 3 世界里的皇帝，他可以命令 Ring 0 办事，但他自己依然在墙外。</li>\n<li><strong>破解</strong>：无论是 Root 手机还是破解 Switch，本质都是想方设法<strong>打断信任链的传递</strong>。</li>\n<li><strong>攻防</strong>：Root 之后，是一场利用“平行宇宙”（Namespace）欺骗 App 的猫鼠游戏。</li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-31 15:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kaiux\">念风零壹</a>&nbsp;\n阅读(<span id=\"post_view_count\">188</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}