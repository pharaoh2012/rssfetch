{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "AI Agent 框架探秘：拆解 OpenHands（4）--- 服务",
      "link": "https://www.cnblogs.com/rossiXYZ/p/19530117",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rossiXYZ/p/19530117\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 19:50\">\n    <span>AI Agent 框架探秘：拆解 OpenHands（4）--- 服务</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"ai-agent-框架探秘拆解-openhands4----服务\">AI Agent 框架探秘：拆解 OpenHands（4）--- 服务</h1>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#ai-agent-框架探秘拆解-openhands4----服务\" rel=\"noopener nofollow\">AI Agent 框架探秘：拆解 OpenHands（4）--- 服务</a><ul><li><a href=\"#0x00-概述\" rel=\"noopener nofollow\">0x00 概述</a></li><li><a href=\"#0x01-服务\" rel=\"noopener nofollow\">0x01 服务</a><ul><li><a href=\"#11-api-模式\" rel=\"noopener nofollow\">1.1 API 模式</a><ul><li><a href=\"#111-actions\" rel=\"noopener nofollow\">1.1.1 Actions</a></li><li><a href=\"#112-observation\" rel=\"noopener nofollow\">1.1.2 observation</a></li></ul></li><li><a href=\"#12-服务器组件\" rel=\"noopener nofollow\">1.2 服务器组件</a><ul><li><a href=\"#sessionpy\" rel=\"noopener nofollow\">session.py</a></li><li><a href=\"#sessionagent_sessionpy\" rel=\"noopener nofollow\">session/agent_session.py</a></li><li><a href=\"#sessionconversation_managerconversation_managerpy\" rel=\"noopener nofollow\">session/conversation_manager/conversation_manager.py</a></li><li><a href=\"#listenpy\" rel=\"noopener nofollow\">listen.py</a></li></ul></li><li><a href=\"#13-服务工作流程描述\" rel=\"noopener nofollow\">1.3 服务工作流程描述</a></li><li><a href=\"#14-listen_socketpy\" rel=\"noopener nofollow\">1.4 listen_socket.py</a><ul><li><a href=\"#141-核心特色\" rel=\"noopener nofollow\">1.4.1 核心特色</a></li><li><a href=\"#142-具体功能\" rel=\"noopener nofollow\">1.4.2 具体功能</a></li><li><a href=\"#143-流程图\" rel=\"noopener nofollow\">1.4.3 流程图</a></li><li><a href=\"#144-会话连接\" rel=\"noopener nofollow\">1.4.4 会话连接</a></li><li><a href=\"#145-代码\" rel=\"noopener nofollow\">1.4.5 代码</a></li></ul></li></ul></li><li><a href=\"#0xff-参考\" rel=\"noopener nofollow\">0xFF 参考</a></li></ul></li></ul></div><p></p>\n<h2 id=\"0x00-概述\">0x00 概述</h2>\n<p>本篇结合官方文档进行解读OpenHands的服务器，这是OpenHands系统的立身基础。</p>\n<p>因为本系列借鉴的文章过多，可能在参考文献中有遗漏的文章，如果有，还请大家指出。</p>\n<h2 id=\"0x01-服务\">0x01 服务</h2>\n<p>OpenHands提供了WebSocket服务器。</p>\n<p><img alt=\"openhands-server\" class=\"lazyload\" /></p>\n<h3 id=\"11-api-模式\">1.1 API 模式</h3>\n<p>可以发送或从服务器接收两种类型的消息：</p>\n<ul>\n<li>Actions</li>\n<li>Observations</li>\n</ul>\n<h4 id=\"111-actions\">1.1.1 Actions</h4>\n<p>一个action 包含三个部分：</p>\n<ul>\n<li><code>action</code>：要采取的动作</li>\n<li><code>args</code>：动作的参数</li>\n<li><code>message</code>：可以放在聊天记录中的友好消息</li>\n</ul>\n<p>有几种action 。它们的参数列在下面。 随着时间的推移，这个列表可能会增长。</p>\n<ul>\n<li>\n<p><code>initialize</code> - 初始化代理。仅由客户端发送。</p>\n<ul>\n<li><code>model</code> - 要使用的模型名称</li>\n<li><code>directory</code> - 工作空间的路径</li>\n<li><code>agent_cls</code> - 要使用的代理类</li>\n</ul>\n</li>\n<li>\n<p><code>start</code> - 开始一个新的开发任务。仅由客户端发送。</p>\n<ul>\n<li><code>task</code> - 要开始的任务</li>\n</ul>\n</li>\n<li>\n<p><code>read</code> - 读取文件内容。</p>\n<ul>\n<li><code>path</code> - 要读取的文件路径</li>\n</ul>\n</li>\n<li>\n<p><code>write</code> - 写入内容到文件。</p>\n<ul>\n<li><code>path</code> - 要写入的文件路径</li>\n<li><code>content</code> - 写入文件的内容</li>\n</ul>\n</li>\n<li>\n<p><code>run</code> - 运行命令。</p>\n<ul>\n<li><code>command</code> - 要运行的命令</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><code>browse</code> - 打开网页。\n<ul>\n<li><code>url</code> - 要打开的URL</li>\n</ul>\n</li>\n<li><code>think</code> - 允许代理制定计划、设定目标或记录想法\n<ul>\n<li><code>thought</code> - 要记录的想法</li>\n</ul>\n</li>\n<li><code>finish</code> - 代理发出任务完成的信号</li>\n</ul>\n<h4 id=\"112-observation\">1.1.2 observation</h4>\n<p>一个observation 包含四个部分：</p>\n<ul>\n<li><code>observation</code>：观察类型</li>\n<li><code>content</code>：表示观察数据的字符串</li>\n<li><code>extras</code>：额外的结构化数据</li>\n<li><code>message</code>：可以放在聊天记录中的友好消息</li>\n</ul>\n<p>有几种observation 。它们的额外信息列在下面。 随着时间的推移，这个列表可能会增长。</p>\n<ul>\n<li><code>read</code> - 文件内容\n<ul>\n<li><code>path</code> - 读取的文件路径</li>\n</ul>\n</li>\n<li><code>browse</code> - URL的HTML内容\n<ul>\n<li><code>url</code> - 打开的URL</li>\n</ul>\n</li>\n<li><code>run</code> - 命令的输出\n<ul>\n<li><code>command</code> - 运行的命令</li>\n<li><code>exit_code</code> - 命令的退出代码</li>\n</ul>\n</li>\n<li><code>chat</code> - 用户的消息</li>\n</ul>\n<h3 id=\"12-服务器组件\">1.2 服务器组件</h3>\n<p>以下部分描述了OpenHands项目的服务器端组件。</p>\n<h4 id=\"sessionpy\">session.py</h4>\n<p><code>session.py</code> 文件定义了<code>Session</code>类，它代表与客户端的WebSocket会话。关键特性包括：</p>\n<ul>\n<li>处理WebSocket连接和断开</li>\n<li>初始化和管理代理会话</li>\n<li>在客户端和代理之间分发事件</li>\n<li>向客户端发送消息和错误</li>\n</ul>\n<h4 id=\"sessionagent_sessionpy\">session/agent_session.py</h4>\n<p><code>agent_session.py</code> 文件包含<code>AgentSession</code>类，它管理会话内代理的生命周期。关键特性包括：</p>\n<ul>\n<li>创建和管理运行时环境</li>\n<li>初始化代理控制器</li>\n<li>处理安全分析</li>\n<li>管理事件流</li>\n</ul>\n<h4 id=\"sessionconversation_managerconversation_managerpy\">session/conversation_manager/conversation_manager.py</h4>\n<p><code>conversation_manager.py</code> 文件定义了<code>ConversationManager</code>类，它负责管理多个客户端会话。关键特性包括：</p>\n<ul>\n<li>添加和重启会话</li>\n<li>向特定会话发送消息</li>\n<li>清理非活动会话</li>\n</ul>\n<h4 id=\"listenpy\">listen.py</h4>\n<p><code>listen.py</code> 文件是主服务器文件，它设置FastAPI应用程序并定义各种API端点。关键特性包括：</p>\n<ul>\n<li>设置CORS中间件</li>\n<li>处理WebSocket连接</li>\n<li>管理文件上传</li>\n<li>提供代理交互、文件操作和安全分析的API端点</li>\n<li>为前端提供静态文件服务</li>\n</ul>\n<p>该脚本定义了服务接口，主要分为两个部分：</p>\n<ul>\n<li>一部分是通过<code>FastAPI</code>库实现的HTTP接口，其具体实现位于<code>openhands/server/routes</code>目录中；</li>\n<li>另一部分是利用<code>socketio</code>库实现的WebSocket接口，其代码实现在<code>openhands/server/listen_socket.py</code>文件中。用户与代理的交互通过WebSocket进行，连接初始化时会触发<code>connect</code>事件，用户发送消息时会触发<code>oh_user_action</code>事件，连接断开时会触发<code>disconnect</code>事件。因此，梳理代理交互逻辑的核心在于对这三个事件的处理流程进行整理。</li>\n</ul>\n<pre><code class=\"language-python\">import socketio\n\nfrom openhands.server.app import app as base_app\nfrom openhands.server.listen_socket import sio\nfrom openhands.server.middleware import (\n    CacheControlMiddleware,\n    InMemoryRateLimiter,\n    LocalhostCORSMiddleware,\n    RateLimitMiddleware,\n)\nfrom openhands.server.static import SPAStaticFiles\n\nif os.getenv('SERVE_FRONTEND', 'true').lower() == 'true':\n    base_app.mount(\n        '/', SPAStaticFiles(directory='./frontend/build', html=True), name='dist'\n    )\n\nbase_app.add_middleware(LocalhostCORSMiddleware)\nbase_app.add_middleware(CacheControlMiddleware)\nbase_app.add_middleware(\n    RateLimitMiddleware,\n    rate_limiter=InMemoryRateLimiter(requests=10, seconds=1),\n)\n\napp = socketio.ASGIApp(sio, other_asgi_app=base_app)\n</code></pre>\n<h3 id=\"13-服务工作流程描述\">1.3 服务工作流程描述</h3>\n<p>服务的工作流程如下：</p>\n<ol>\n<li><strong>服务器初始化</strong>：\n<ul>\n<li>FastAPI应用程序在<code>listen.py</code>中创建和配置。</li>\n<li>设置CORS中间件和静态文件服务。</li>\n<li>初始化<code>ConversationManager</code>。</li>\n</ul>\n</li>\n<li><strong>客户端连接</strong>：\n<ul>\n<li>当客户端通过WebSocket连接时，创建新的<code>Session</code>或重启现有一个。</li>\n<li><code>Session</code>初始化<code>AgentSession</code>，设置运行时环境和代理控制器。</li>\n</ul>\n</li>\n<li><strong>代理初始化</strong>：\n<ul>\n<li>客户端发送初始化请求。</li>\n<li>服务器根据提供的参数创建和配置代理。</li>\n<li>设置运行时环境，初始化代理控制器。</li>\n</ul>\n</li>\n<li><strong>事件处理</strong>：\n<ul>\n<li><code>Session</code>管理客户端和代理之间的事件流。</li>\n<li>客户端的事件分发到代理。</li>\n<li>代理的观察结果发送回客户端。</li>\n</ul>\n</li>\n<li><strong>文件操作</strong>：\n<ul>\n<li>服务器处理文件上传，确保它们符合大小和类型限制。</li>\n<li>通过运行时环境执行文件读取和写入操作。</li>\n</ul>\n</li>\n<li><strong>安全分析</strong>：\n<ul>\n<li>如果配置了，每个会话初始化安全分析器。</li>\n<li>安全相关的API请求转发到安全分析器。</li>\n</ul>\n</li>\n<li><strong>会话管理</strong>：\n<ul>\n<li><code>ConversationManager</code>定期清理非活动会话。</li>\n<li>它还在需要时处理向特定会话发送消息。</li>\n</ul>\n</li>\n<li><strong>API端点</strong>：\n<ul>\n<li>提供各种API端点，用于代理交互、文件操作和获取配置默认值。</li>\n</ul>\n</li>\n</ol>\n<p>这种服务器架构允许管理多个客户端会话，每个会话都有自己的代理实例、运行时环境和安全分析器。事件驱动设计促进了客户端和代理之间的实时通信，而模块化结构允许轻松扩展和维护不同组件。</p>\n<h3 id=\"14-listen_socketpy\">1.4 listen_socket.py</h3>\n<p>listen_socket.py是 OpenHands 服务器端的 Socket.IO 事件监听器，负责处理客户端和服务器之间的实时双向通信，包括连接建立、事件回放、用户行动转发和连接断开四大核心场景，是客户端与后端会话、代理系统交互的桥梁。</p>\n<h4 id=\"141-核心特色\">1.4.1 核心特色</h4>\n<p>listen_socket.py的核心特色如下：</p>\n<ol>\n<li>断点续传的事件回放：支持通过 <code>latest_event_id</code> 参数实现事件断点续传，客户端重连时仅回放未接收的事件，避免重复数据传输，提升连接效率。</li>\n<li>严格的身份与权限校验：连接建立时校验会话 ID、API 密钥、用户身份（通过 Cookie 和 Authorization 头），确保会话安全性，防止未授权访问。</li>\n<li>向后兼容的事件处理：保留 <code>oh_action</code> 处理器兼容旧版客户端，同时提供 <code>oh_user_action</code> 新版接口，平滑过渡不中断服务。</li>\n<li>有序的事件推送逻辑：代理状态变更事件（<code>AgentStateChangedObservation</code>）最后发送，确保客户端先接收历史事件，再同步最新状态，避免状态不一致。</li>\n<li>异步高效的事件处理：基于异步 IO（<code>async/await</code>）实现事件回放和转发，支持高并发连接，不阻塞主线程，提升系统吞吐量。</li>\n<li>完善的错误处理：连接失败时主动断开无效连接，记录详细日志，便于问题排查；过滤无效事件（如 <code>NullAction</code>），减少不必要的网络传输。</li>\n</ol>\n<h4 id=\"142-具体功能\">1.4.2 具体功能</h4>\n<p>listen_socket.py的具体功能如下：</p>\n<ul>\n<li>\n<p>连接管理（connect 事件）</p>\n<ul>\n<li>身份验证：验证连接参数中的 conversation_id 和 API 密钥</li>\n<li>用户认证：通过 conversation_validator 验证用户身份</li>\n<li>会话恢复：为已存在的会话重放事件流历史</li>\n<li>事件重播：向新连接的客户端发送历史事件，包括过滤特定事件类型</li>\n<li>会话加入：将客户端连接加入到对应的会话中</li>\n</ul>\n</li>\n<li>\n<p>动作处理（oh_user_action 和 oh_action 事件）</p>\n<ul>\n<li>用户动作接收：处理来自客户端的用户操作请求</li>\n<li>事件转发：将用户动作转发到会话管理器进行处理</li>\n<li>向后兼容：同时支持 oh_user_action 和 oh_action 事件处理（后者为兼容旧客户端保留）</li>\n</ul>\n</li>\n<li>\n<p>断开连接处理（disconnect 事件）</p>\n<ul>\n<li>连接清理：当客户端断开连接时，清理相关会话资源</li>\n<li>状态管理：通知会话管理器客户端已断开连接</li>\n</ul>\n</li>\n</ul>\n<p>listen_socket.py的核心工作流程为：</p>\n<ul>\n<li>连接建立：\n<ul>\n<li>解析查询参数（会话 ID、最新事件 ID等）</li>\n<li>验证会话和用户身份</li>\n<li>创建事件存储实例</li>\n</ul>\n</li>\n<li>事件历史重播：\n<ul>\n<li>为客户端重放会话历史事件</li>\n<li>过滤掉 NullAction、NullObservation、RecallAction 等特定事件</li>\n<li>确保 AgentStateChangedObservation 事件最后发送</li>\n</ul>\n</li>\n<li>会话加入：\n<ul>\n<li>将连接 ID 与会话关联</li>\n<li>初始化会话设置</li>\n</ul>\n</li>\n<li>安全机制\n<ul>\n<li>API密钥验证：检查 SESSION_API_KEY 环境变量与查询参数中的密钥是否匹配</li>\n<li>会话权限控制：通过 conversation_validator 验证用户是否有权访问定会话</li>\n</ul>\n</li>\n<li>错误处理\n<ul>\n<li>连接拒绝：在验证失败或出现错误时拒绝连接</li>\n<li>异常传播：使用ConnectionRefusedError处理连接错误</li>\n<li>异步清理：在连接被拒绝后异步断开连接</li>\n</ul>\n</li>\n</ul>\n<p>listen_socket.py 与其他组件关系</p>\n<ul>\n<li>与EventStream紧密配合，负责事件的传输和分发</li>\n<li>通过 connection_manager  管理会话状态</li>\n<li>使用  event_to_dict  进行事件序列化以便通过网络传输</li>\n</ul>\n<h4 id=\"143-流程图\">1.4.3 流程图</h4>\n<p><img alt=\"Openhands-服务\" class=\"lazyload\" /></p>\n<h4 id=\"144-会话连接\">1.4.4 会话连接</h4>\n<p>此处关键一步为与会话管理器 ConversationManager 建立连接。</p>\n<pre><code class=\"language-python\">        conversation_init_data = await setup_init_conversation_settings(\n            user_id, conversation_id, providers_set\n        )\n\n        agent_loop_info = await conversation_manager.join_conversation(\n            conversation_id,\n            connection_id,\n            conversation_init_data,\n            user_id,\n        )\n</code></pre>\n<h4 id=\"145-代码\">1.4.5 代码</h4>\n<p>listen_socket.py的代码举例如下：</p>\n<pre><code class=\"language-python\">@sio.event\nasync def connect(connection_id: str, environ: dict) -&gt; None:\n    \"\"\"\n    SocketIO连接事件处理器：客户端建立连接时触发，完成会话验证、事件回放、会话加入等初始化流程。\n    \n    参数：\n        connection_id: 客户端连接唯一标识（SocketIO分配）\n        environ: WSGI环境变量字典，包含请求头、查询参数等信息\n    \"\"\"\n    try:\n        logger.info(f\"SocketIO连接建立：connection_id={connection_id}\")\n        \n        # 解析查询参数（从WSGI环境变量中提取QUERY_STRING）\n        query_params = parse_qs(environ.get('QUERY_STRING', ''))\n        \n        # 解析最新事件ID（用于断点续传，默认-1表示从最开始回放）\n        latest_event_id_str = query_params.get('latest_event_id', [-1])[0]\n        try:\n            latest_event_id = int(latest_event_id_str)\n        except ValueError:\n            logger.debug(f\"无效的latest_event_id值：{latest_event_id_str}，默认设为-1\")\n            latest_event_id = -1\n        \n        # 解析会话ID（必需参数，用于关联特定对话）\n        conversation_id = query_params.get('conversation_id', [None])[0]\n        logger.info(f\"会话连接请求：conversation_id={conversation_id}, connection_id={connection_id}\")\n        \n        # 解析提供者集合（如支持的LLM提供商列表，用于限制可用资源）\n        raw_list = query_params.get('providers_set', [])\n        providers_list = []\n        for item in raw_list:\n            # 拆分逗号分隔的提供者名称，过滤空值\n            providers_list.extend(item.split(',') if isinstance(item, str) else [])\n        providers_list = [p for p in providers_list if p]\n        providers_set = [ProviderType(p) for p in providers_list]  # 转换为ProviderType枚举类型\n\n        # 校验会话ID是否存在\n        if not conversation_id:\n            logger.error(\"查询参数中缺少conversation_id\")\n            raise ConnectionRefusedError(\"缺少会话ID（conversation_id）\")\n\n        # 校验会话API密钥是否有效\n        if _invalid_session_api_key(query_params):\n            raise ConnectionRefusedError(\"无效的会话API密钥\")\n\n        # 提取请求中的Cookie和Authorization头（用于用户身份验证）\n        cookies_str = environ.get('HTTP_COOKIE', '')\n        # WSGI环境中，HTTP头会转为\"HTTP_前缀+下划线替换短横线\"格式\n        authorization_header = environ.get('HTTP_AUTHORIZATION', None)\n        \n        # 创建会话验证器，校验用户身份（关联会话ID、Cookie、授权头）\n        conversation_validator = create_conversation_validator()\n        user_id = await conversation_validator.validate(\n            conversation_id, cookies_str, authorization_header\n        )\n        \n        # 创建事件存储实例（用于读取会话历史事件）\n        try:\n            event_store = EventStore(\n                conversation_id, conversation_manager.file_store, user_id\n            )\n        except FileNotFoundError as e:\n            logger.error(f\"创建会话事件存储失败：conversation_id={conversation_id}, 错误={e}\")\n            raise ConnectionRefusedError(f\"无法访问会话事件：{e}\")\n\n        agent_state_changed = None  # 存储代理状态变更事件（最后单独发送）\n\n        # 创建异步事件存储包装器，从latest_event_id+1开始回放事件（避免重复）\n        async_store = AsyncEventStoreWrapper(event_store, latest_event_id + 1)\n\n        # 异步回放历史事件（向客户端推送未接收过的事件）\n        async for event in async_store:\n            logger.debug(f\"回放事件：{event.__class__.__name__}\")\n\n            # 跳过无效/召回类事件（无需推送给客户端）\n            if isinstance(\n                event,\n                (NullAction, NullObservation, RecallAction),\n            ):\n                continue\n            # 暂存代理状态变更事件（最后发送，确保客户端状态同步）\n            elif isinstance(event, AgentStateChangedObservation):\n                agent_state_changed = event\n            # 其他事件直接推送给客户端\n            else:\n                await sio.emit('oh_event', event_to_dict(event), to=connection_id)\n\n        # 最后发送代理状态变更事件（确保客户端获取最新状态）\n        if agent_state_changed:\n            await sio.emit(\n                'oh_event', event_to_dict(agent_state_changed), to=connection_id\n            )\n\n        logger.info(f\"会话事件回放完成：conversation_id={conversation_id}\")\n\n        # 初始化会话设置（用户偏好、提供者配置等）\n        conversation_init_data = await setup_init_conversation_settings(\n            user_id, conversation_id, providers_set\n        )\n\n        # 加入会话：关联connection_id与会话，启动代理循环\n        agent_loop_info = await conversation_manager.join_conversation(\n            conversation_id,\n            connection_id,\n            conversation_init_data,\n            user_id,\n        )\n\n        # 校验会话加入结果\n        if agent_loop_info is None:\n            raise ConnectionRefusedError(\"加入会话失败\")\n\n        logger.info(f\"会话加入成功：conversation_id={conversation_id}, connection_id={connection_id}\")\n        \n    except ConnectionRefusedError:\n        # 发送错误后断开无效连接\n        asyncio.create_task(sio.disconnect(connection_id))\n        raise\n\n\n@sio.event\nasync def oh_user_action(connection_id: str, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    处理客户端发送的用户行动事件（如用户输入、操作指令）。\n    \n    参数：\n        connection_id: 客户端连接ID\n        data: 用户行动数据（字典格式，包含行动类型、内容等）\n    \"\"\"\n    # 将用户行动转发到事件流，由会话管理器处理\n    await conversation_manager.send_to_event_stream(connection_id, data)\n\n\n@sio.event\nasync def oh_action(connection_id: str, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    兼容旧版客户端的行动事件处理器（保留用于向后兼容）。\n    \n    注意：待所有客户端升级为使用oh_user_action后，可移除该处理器\n    目前用于支持正在进行中的旧会话，避免中断服务\n    \"\"\"\n    await conversation_manager.send_to_event_stream(connection_id, data)\n\n\n@sio.event\nasync def disconnect(connection_id: str) -&gt; None:\n    \"\"\"\n    SocketIO断开连接事件处理器：客户端断开连接时触发。\n    \n    参数：\n        connection_id: 断开连接的客户端ID\n    \"\"\"\n    logger.info(f\"SocketIO连接断开：connection_id={connection_id}\")\n    # 通知会话管理器，断开该连接与会话的关联\n    await conversation_manager.disconnect_from_session(connection_id)\n</code></pre>\n<h2 id=\"0xff-参考\">0xFF 参考</h2>\n<p><a href=\"https://docs.all-hands.dev/openhands/usage/architecture/backend\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.all-hands.dev/openhands/usage/architecture/backend</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1936485868761257658\" rel=\"noopener nofollow\" target=\"_blank\">当AI Agent从“玩具”走向“工具”，我们该关注什么？Openhands架构解析【第二篇：Agent 相关核心概念】</a>  <a href=\"https://www.zhihu.com/people/dreamrenderx\" rel=\"noopener nofollow\" target=\"_blank\">克里</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1936175201323825087\" rel=\"noopener nofollow\" target=\"_blank\">当AI Agent从“玩具”走向“工具”，我们该关注什么？Openhands架构解析【第一篇：系列导读】</a> <a href=\"https://www.zhihu.com/people/dreamrenderx\" rel=\"noopener nofollow\" target=\"_blank\">克里</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1940436682949244630\" rel=\"noopener nofollow\" target=\"_blank\">Coding Agent之Openhands解析(含代码)</a>  <a href=\"https://www.zhihu.com/people/wu-long-ming-cha-56\" rel=\"noopener nofollow\" target=\"_blank\">Arrow</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1940824548485347192\" rel=\"noopener nofollow\" target=\"_blank\">OpenHands 源码解读</a>  <a href=\"https://www.zhihu.com/people/xiao-hui-66-72\" rel=\"noopener nofollow\" target=\"_blank\">一力辉</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 19:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rossiXYZ\">罗西的思考</a>&nbsp;\n阅读(<span id=\"post_view_count\">26</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "快速上手Ultimate++的编译链接和配置",
      "link": "https://www.cnblogs.com/bokong/p/19540095",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/bokong/p/19540095\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 17:28\">\n    <span>快速上手Ultimate++的编译链接和配置</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        U++（全称 Ultimate++）是一个开源的 C++ 跨平台应用程序框架，以其高性能、低资源占用和高度集成的开发理念而闻名。它旨在提供“更少代码、更快执行”的开发体验。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"u简介\">U++简介</h1>\n<p>U++（全称 Ultimate++）是一个<strong>开源的 C++ 跨平台应用程序框架</strong>，以其<strong>高性能、低资源占用和高度集成</strong>的开发理念而闻名。它旨在提供“<strong>更少代码、更快执行</strong>”的开发体验。<br />\n<strong>主要特点：</strong></p>\n<ol>\n<li><strong>高度集成</strong><br />\n包含GUI、数据库、网络、XML、JSON等完整工具链，减少对第三方库的依赖。</li>\n<li><strong>智能编程模型</strong><br />\n强调使用C++ RAII、智能指针等现代特性，自动管理资源，提升代码安全性。</li>\n<li><strong>高效的GUI开发</strong><br />\n提供自绘GUI库（<code>U++ Controls</code>），支持Windows、Linux、macOS，界面响应迅速且内存占用低。</li>\n<li><strong>编译与构建工具</strong><br />\n自带<code>TheIDE</code>集成开发环境，包含智能代码编辑器、可视化设计器和构建系统<code>umake</code>，支持并行编译与代码优化。</li>\n<li><strong>性能优先</strong><br />\n注重运行时效率，生成的程序体积小、启动快，适合开发桌面应用和工具软件。</li>\n</ol>\n<p><strong>示例代码片段（简单窗口）：</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;CtrlLib/CtrlLib.h&gt;\nusing namespace Upp;\n\nclass MyApp : public TopWindow {\npublic:\n    MyApp() {\n        Title(\"Hello U++\");\n        SetRect(0, 0, 400, 200);\n    }\n};\n\nGUI_APP_MAIN\n{\n    MyApp().Run();\n}\n</code></pre>\n<p><strong>适用场景：</strong><br />\n桌面应用程序、工具软件、数据管理平台等对性能和轻量化有较高要求的项目。<br />\n<strong>U++通过“全栈式”设计帮助开发者用C++快速构建高效且跨平台的应用程序。</strong></p>\n<h1 id=\"u集成开发环境theide使用\">U++集成开发环境TheIDE使用</h1>\n<h2 id=\"项目工程\">项目工程</h2>\n<ul>\n<li>TheIDE默认examples（例程）、MyApps、reference（参考项目）、tutorial（教程项目）、uppsrc（U++官方程序集）这5个程序集，其中MyApps是默认留给用户开发项目的，uppsrc是最重要的程序集，所有开发需要的模块包都在这里面。</li>\n<li>程序集又分为Main packages（用来生成最终项目（可执行程序或库））和Non-main packages（供主模块引用的模块包）。</li>\n</ul>\n<p><strong>创建你的项目：</strong><br />\n选择MyApps，窗口左下角选择Main packages，下方靠右边选择New package按钮在弹出的对话框中定制你的项目（或者在Package区右键会有更多功能选择），然后Create按钮就可以写代码了。后续需要打开你的项目，可以选择项目后OK按钮（或直接双击）打开。你也可以新建自己的程序集，在Assembly区右键选择New assembly，自己指定路径。如图：<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<strong>构建生成</strong><br />\n首先看窗口工具栏，有两个可编辑的工具条，分别是构建标志（GUI等，可以多个标志一组，空格隔开）和编译器配置（CLANG Debug等），这决定了最终的输出配置，参考下图：<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n重要的构建标志还有SHARED（构建动态库）、MAKE_LIB（构建静态库）等，见官方文档详细说明。<br />\n<strong>为你的项目添加依赖包：</strong><br />\n选择你的模块包，右键选择Add package to... 如图：<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n选择一个你需要的依赖包即可。<br />\n<strong>包的配置管理：</strong><br />\nProject菜单选择Package organizer（或者模块包右键菜单选择），弹出窗口（选择Core模块作为跨平台配置参考），严格的包依赖关系全部在这里管理，如图：<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\nAccents中是指定标志（包提供者决定怎么编译这个包），编译器将据此生成目标文件。下方是具体的条件编译配置，条件即是构建标志，意思就是根据构建标志这些条件使用依赖包、库、链接选项等。（提示：找到并打开Core.upp文本文件你会观察到这些内容完全一致。）<br />\n同样Project菜单还有个Main package configuration（或者点击工具栏标志工具条），在弹出如下窗口中可配置管理多组构建标志，支持交叉编译等高级跨平台功能。<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<strong>关于标志补充说明：</strong><br />\n所有标志会被U++构建工具自动解析为\"flag\"前缀的预编译宏，如flagGUI、flagDLL、flagUSEMALLOC等，你也可以自定义标志，且完全满足这条规则，意味着你可以灵活地处理条件编译（#ifdef flag...）。<br />\n<strong>输出模式设定</strong><br />\nBuild菜单选择Output mode（或者点击工具栏编译器工具条），弹出窗口，你可以指定覆盖目标文件路径、启用Blitz编译技术、创建其他输出文件等，如图：<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<strong>调试运行设置</strong><br />\nDebug菜单选择Run options，在下图所示的窗口中可设置程序运行输入参数、标准输出重定向到文件等。<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<strong>Assist菜单下提供了U++框架更多的实用和辅助等高级功能。</strong></p>\n<h2 id=\"自定义编译器配置\">自定义编译器配置</h2>\n<p><strong>添加编译器</strong><br />\nSetup菜单选择Build methods弹出如下窗口：<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n如何添加编译器？以MinGW为例，左边Method下右键，选择Append row，命名MinGWx64（64位程序编译器），右边Builder要选择GCC，底下要正确指定文件夹，我的配置如图<br />\n<img alt=\"MinGWx64\" class=\"lazyload\" /><br />\n我是用msys2下载安装的MinGW，所以可执行文件路径PATH下需要\"msys64\\mingw64/bin\"和\"msys64\\mingw64/x86_64-w64-mingw32/bin\"这样的两个完整路径（Windows路径系统用反斜杠，但建议最后一个文件夹更改为正斜杠）。<br />\nINCLUDE需要\"msys64\\mingw64/include\"，LIB需要\"msys64\\mingw64/lib\"<br />\n<strong>编译链接选项</strong><br />\n这些参数设置同系统标准，可以启用函数级链接、冗余清除等优化最终程序的体积和速度，根据自己的需要配置。需要交叉编译时，必须自己手动添加（如Java、Android等）编译器。当然U++的IDE也有很明显的微小瑕疵，找不到函数的定义便会报错提示（最典型的是使用库函数），但是可以正常生成目标程序，所以只有忽略这些提示。<br />\n以上就是轻量级框架U++基本使用说明。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 17:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/bokong\">南岩亦凛汀</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI是资本的胜利-未来可能是资本的天下",
      "link": "https://www.cnblogs.com/ztfjs/p/19549290/aiagent",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ztfjs/p/19549290/aiagent\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 16:20\">\n    <span>AI是资本的胜利-未来可能是资本的天下</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2>序</h2>\n<p>——工程师正在自掘坟墓，或许转行外卖才是唯一选择，但资本+AI能够统治一切。</p>\n<p>工业革命（蒸汽机）与 AI 革命最核心的本质差异—— 前者是动力赋能下的人力规模放大，后者是智力替代下的人力价值消解，资本对 AI 的终极诉求并非 “提升人力效率”，而是彻底重构生产要素，让 “人” 从核心创造者沦为边缘监督者，将劳动的价值锚点从人转移到机器、算力、模型这些资本可完全掌控的生产资料上。 ————这是资本的胜利。本文仅讨论AI对资本的实质，并不过多描述AI对人类发展的进步意义。</p>\n<h2>蒸汽机时代-动力赋能下的人力价值放大</h2>\n<p>蒸汽机的诞生，标志着人类从手工劳动迈入机器生产时代，但它自始至终都未曾动摇“人”作为生产核心的地位。其本质是用无生命的动力源，替代了人的体力劳动，却进一步放大了对掌握技能的人力的需求，形成了“机器赋能人、人驱动生产”的共生关系。 在蒸汽机普及前，纺织、采矿、运输等行业依赖人工劳作，生产效率受限于人的体力极限，规模扩张极为缓慢。蒸汽机的出现，打破了这一桎梏——一台蒸汽织布机的效率远超十名熟练织工，一台蒸汽机车的运力抵得上数十辆马车。但这种效率提升，并未导致人力需求的缩减，反而催生了更大规模的人力缺口。一方面，蒸汽机本身需要专业工人操作、调试、维护，原本的手工劳动者通过技能升级，转变为机器操作工，依然是生产流程中不可或缺的一环；另一方面，生产规模的爆发式增长，带动了上下游产业链的扩张，需要更多工人参与原料开采、产品加工、仓储运输、车间管理等环节。</p>\n<p>更关键的是，蒸汽机时代的价值创造锚点始终是人。机器是资本投入的生产资料，但没有工人的操控与技能输出，机器只是一堆无价值的钢铁。资本想要赚取更多利润，就必须雇佣更多工人、提升工人的技能水平，人力劳动依然是价值公式中的核心变量。此时的资本与工人，是“利益共生”关系——资本通过机器放大工人的劳动价值，工人通过依附资本的生产资料获得生存报酬，人在生产中的核心地位不可替代。</p>\n<h2>从AI辅助编程到AI自主编程：人的经验被数字概率替代</h2>\n<p>AI演进路径，我觉得从根源上背离了“工具赋能人”的传统逻辑,现阶段接触到的所有AI，例如manus、claude code、midjourney等不同领域的AI，它们被赋予的终极目标是用“数字概率”替代“人的经验”、”人的美感”、”人的一切脑力价值”，让机器接管最核心的智力劳动。从编程上看，从早期的代码补全工具，到如今能基于自然语言需求生成完整项目代码、自主排查Bug、优化程序性能的AI模型，AI正在逐步消解人们赖以生存的核心价值————经验积累与逻辑思考。 在传统编程模式中，程序员的核心竞争力源于长期实践积累的经验：对编程语言的熟练运用、对业务逻辑的深度理解、对复杂问题的排查能力、对系统架构的设计思维。这些经验是个性化的、不可复制的，是程序员在劳动力市场中议价的核心资本。但AI Coding的底层逻辑，是通过学习海量开源代码与技术文档，将人类的编程经验转化为数字概率模型——AI生成代码的过程，并非“思考”，而是基于数据训练形成的概率预测，它能快速输出符合语法、逻辑通顺的代码，却无需理解代码背后的业务本质与技术原理。</p>\n<p>这种替代带来的直接后果，是人的经验价值急剧缩水。当一名资深程序员花费数年积累的业务逻辑处理经验，能被AI通过数据训练在几小时内复刻；当程序员熬夜调试的Bug，AI能在几秒内定位并修复，人类的经验便不再是稀缺资源。资本无需再为程序员的经验积累支付高额薪酬，只需投入算力与模型训练成本，就能获得源源不断的“数字劳动力”，而程序员的工作，也从“创造性劳动”沦为“对AI生成结果的监督与修正”，经验的溢价空间被彻底压缩。</p>\n<h2>应届生的价值急剧下降：入门门槛与生存空间被双重挤压</h2>\n<p>在AI的冲击下，软件开发行业的人才结构正在发生剧烈重构，应届生成为受影响最直接、最深刻的群体，其劳动力价值急剧下降，入门与生存空间被双重挤压。传统编程行业中，应届生是“潜力股”——资本愿意投入成本培养应届生，让其从基础编码工作做起，逐步积累经验、成长为核心人才，应届生的“可培养性”是其核心价值所在。但AI Coding的普及，直接剥夺了应届生赖以成长的基础岗位与实践机会。 一方面，AI完全替代了应届生最擅长的基础编码工作。过去，应届生通过编写CRUD接口、简单业务逻辑代码、参与单元测试等基础工作积累经验，但如今这些工作已能被AI高效完成，且准确率与效率远超应届生。资本不再需要雇佣应届生从事基础开发，原本的入门岗位大幅缩减，应届生面临“无工可做”的困境。另一方面，行业对人才的需求标准发生扭曲，从“注重潜力与学习能力”转向“注重AI工具操控能力与代码审核效率”。部分企业更愿意雇佣能快速上手AI工具、高效审核AI生成代码的“熟练工”，而非需要花费时间培养、且效率不及AI的应届生。</p>\n<p>更残酷的是，应届生失去了“经验积累的阶梯”。没有基础编码的实践，应届生难以理解复杂系统的架构逻辑与业务底层原理，即便掌握了AI工具的使用，也只能停留在“监督者”的层面，无法成长为具备核心竞争力的高级人才。最终，应届生的价值被压缩到最低，要么接受低薪的“AI辅助岗”，要么被行业淘汰，资本则以极低的成本获得了“可替代的监督劳动力”。</p>\n<h2>智力资源普及廉价：资本掌控下的价值贬值</h2>\n<p>软件开发是典型的智力密集型行业，智力资源曾是少数人拥有的稀缺资源，也是程序员议价权的核心。但AI Coding的出现，让原本稀缺的智力资源变得“普及且廉价”，而这一切的主导者与受益者，正是资本。资本通过掌控AI模型与算力，将人类的智力成果转化为可复制、可批量输出的“数字商品”，彻底打破了智力资源的稀缺性。 在AI出现前，一名程序员的智力输出具有排他性——其编写的代码、设计的架构，只能为雇佣他的企业创造价值，资本想要获得更多智力资源，就必须雇佣更多程序员。但AI模型通过学习海量开源代码与技术文档，整合了全球程序员的智力成果，资本只需投入一次模型训练成本，就能无限次输出智力成果，且边际成本趋近于零。原本需要数十名程序员花费数月完成的项目，如今通过AI Coding工具，几名“监督者”就能在几周内完成，智力资源的使用效率被资本以“规模化复制”的方式拉满。</p>\n<p>同时，智力资源的价值被资本重新定义。过去，程序员的智力劳动直接转化为产品价值，薪酬与价值挂钩；如今，AI成为智力成果的“输出者”，程序员的智力劳动只是AI训练数据的一部分，其价值被稀释到海量数据中，无法单独量化。资本无需为个体的智力劳动支付高额报酬，只需支付少量“数据贡献费”（甚至无需支付，引发诸多知识产权争议），就能掌控海量智力资源，原本稀缺的智力资源，在资本的操作下变得廉价且可随意取用。</p>\n<h2>结合机器人：概率数字能够替代的人力范围扩大</h2>\n<p>AI Coding的价值替代，并非局限于软件开发行业。当AI的“概率数字决策”与机器人技术相结合，资本能够替代的人力范围将实现跨领域扩张，从智力劳动延伸到体力劳动与服务劳动，进一步巩固资本对生产要素的掌控权。AI提供“大脑决策”，机器人提供“肢体执行”，二者结合形成的“数字劳动力体系”，正在逐步替代人类在各行业的劳动角色。 在工业领域，传统机器人需要预设程序才能运行，灵活性与适应性极差，无法应对复杂场景。但结合AI的概率决策能力后，机器人能通过实时数据分析，自主调整操作流程、应对突发状况——比如AI驱动的工业机器人，能自主识别零件缺陷、优化装配路径，无需人类干预就能完成复杂生产任务，替代了原本需要熟练技工与程序员协同完成的工作。在服务领域，AI驱动的服务机器人能通过自然语言处理理解用户需求，结合场景数据做出概率决策，提供客服、导购、护理等服务，替代了大量基础服务岗位。</p>\n<p>这种跨领域替代的核心，依然是资本对生产要素的重构。AI的概率数字模型与机器人，都是资本可完全掌控的生产资料，资本无需再依赖不同行业的熟练劳动力，只需通过升级AI模型与机器人硬件，就能实现跨行业布局与人力替代。原本分散在各行业的劳动力价值，被统一锚定到资本掌控的“数字劳动力体系”中，人类的劳动范围被进一步压缩，资本的统治边界则持续扩大。</p>\n<h2>未来可能是资本的天下</h2>\n<p>当AI Coding重构了智力劳动的价值逻辑，当机器人技术扩大了人力替代的范围，当资本完全掌控了模型、算力、机器人这些核心生产资料，未来的社会生产格局，大概率将是资本的天下。资本通过掌控“数字劳动力体系”，实现了对价值创造的绝对主导，人在生产中的地位被边缘化，劳动的价值被彻底转移到资本的生产资料中。 从经济逻辑来看，资本的边际成本将持续降低，而人力的边际价值将持续缩水。资本只需一次性投入模型训练、算力搭建与机器人研发成本，就能获得无限期的价值输出；而人类劳动则面临“可替代性强、议价权弱”的困境，无论是程序员、技工还是服务人员，都只能在资本掌控的生产体系中，从事低价值的监督、维护工作，薪酬水平被资本牢牢压制。从垄断格局来看，掌握核心AI模型与算力资源的资本，将形成难以打破的行业垄断——新企业想要进入市场，必须投入巨额成本搭建AI与算力基础设施，而巨头资本通过规模效应与数据壁垒，能轻松挤压新竞争者，形成“资本越集中、垄断越强；垄断越强，资本越集中”的循环。</p>\n<p>这种格局下，资本不再是“服务于生产的媒介”，而是“生产的绝对主导者”，人类劳动从“价值创造的核心”沦为“资本生产资料的附属”。AI Coding的普及，只是资本掌控生产要素、巩固统治地位的第一步，当技术持续迭代，资本将彻底掌控价值创造的全链条，成为未来社会的绝对主导力量——这，便是资本通过AI革命赢得的终极胜利。</p>\n\n</div>\n<div id=\"MySignature\">\n    ========================================================\n转载请注明出处。\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 16:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ztfjs\">张泰峰</a>&nbsp;\n阅读(<span id=\"post_view_count\">134</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "stable_baseline3 快速入门(一): 训练第一个强化学习模型",
      "link": "https://www.cnblogs.com/ClownLMe/p/19549111",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19549111\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 16:01\">\n    <span>stable_baseline3 快速入门(一): 训练第一个强化学习模型</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简介\">简介</h1>\n<p><strong>stable_baseline3</strong> 是一个基于 PyTorch 的强化学习算法开源库，里面集成了多种强化学习算法，使用这个开源库能够让我们不需要过度关注强化学习算法细节，专注于AI业务的开发。</p>\n<h1 id=\"环境配置\">环境配置</h1>\n<pre><code class=\"language-bash\">pip install stable-baselines3\npip install gymnasium\n</code></pre>\n<p>这里<code>stable-baselines3</code>会默认安装<code>pytroch</code>框架，但是是不带<code>cuda</code>版本的，这就意味着我们无法利用我们的显卡对模型进行训练。<br />\n下载<code>cuda</code>版本的<code>pytroch</code>步骤如下：</p>\n<ol>\n<li>卸载原来版本的<code>pytroch</code>框架</li>\n</ol>\n<pre><code class=\"language-bash\">pip uninstall torch torchvision torchaudio -y\n#这个是针对RTX 30/40/50显卡的。\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu126\n</code></pre>\n<p>如果其他版本请参考官网： <a href=\"https://pytorch.org/get-started/locally/\" rel=\"noopener nofollow\" target=\"_blank\">https://pytorch.org/get-started/locally/</a></p>\n<h1 id=\"认识stable_baseline3\">认识stable_baseline3</h1>\n<p><code>stable_baseline3</code>提供了许多模型，如下列表：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>动作空间</th>\n<th>建议应用场景</th>\n<th>核心优势</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>PPO</strong></td>\n<td>连续 &amp; 离散</td>\n<td><strong>全能选手</strong>，如机器人走动、金融交易、游戏 AI</td>\n<td>极其稳定，对超参数不敏感，支持大规模并行训练。</td>\n</tr>\n<tr>\n<td><strong>DQN</strong></td>\n<td>仅离散</td>\n<td>经典游戏（Atari）、开关控制、迷宫寻路</td>\n<td>理解简单，在离散控制领域非常经典且有效。</td>\n</tr>\n<tr>\n<td><strong>SAC</strong></td>\n<td>仅连续</td>\n<td>复杂物理模拟、机械臂抓取、自动驾驶</td>\n<td>探索效率极高，能自动寻找最优路径且不轻易陷入局部最优。</td>\n</tr>\n<tr>\n<td><strong>TD3</strong></td>\n<td>仅连续</td>\n<td>工业控制、无人机飞行、精密动作</td>\n<td>针对 DDPG 的缺陷做了改进，训练过程比 SAC 更平滑。</td>\n</tr>\n<tr>\n<td><strong>A2C</strong></td>\n<td>连续 &amp; 离散</td>\n<td>简单逻辑测试、快速原型验证</td>\n<td>结构简单，虽然不如 PPO 稳定，但在特定并行环境下速度极快。</td>\n</tr>\n</tbody>\n</table>\n<p>在<strong>声明模型</strong>中，可以设置多种参数，这里列出常用的：<br />\n目前不需要搞懂都有什么作用，后面有文章会详细讲解</p>\n<ol>\n<li>训练参数</li>\n</ol>\n<ul>\n<li><code>learning_rate</code>：学习率</li>\n<li><code>gamma</code>：折扣因子</li>\n<li><code>batch_size</code>：更新模型使用数据量</li>\n<li><code>verbose</code>：打印信息模式。0-静默模式，1-信息模式，2-调试模式</li>\n<li><code>device</code>：指定训练设备<code>cuda</code>使用显卡，<code>cpu</code>使用cpu</li>\n</ul>\n<ol start=\"2\">\n<li>模型规则</li>\n</ol>\n<ul>\n<li><code>MlpPolicy</code>：多层感知机。适用于状态是数值场景（传感器等）</li>\n<li><code>CnnPolicy</code>：卷积神经网络。适用于状态是图像场景（游戏等）</li>\n</ul>\n<h1 id=\"训练第一个强化学习模型\">训练第一个强化学习模型</h1>\n<h3 id=\"案例\">案例</h3>\n<p>案例描述：训练一个<code>gymnasium</code>默认提供的游戏环境，平衡杆游戏。</p>\n<pre><code class=\"language-python\">import gymnasium as gym\nfrom stable_baselines3 import PPO\n\nenv = gym.make(\"CartPole-v1\")\n\nmodel = PPO(\"MlpPolicy\", env, verbose=1, device=\"cuda\")\n\nprint(\"开始训练...\")\nmodel.learn(total_timesteps=10000)\n\nprint(\"正在保存模型...\")\nmodel.save(\"ppo_cartpole\")\n\nprint(\"正在读取模型...\")\nenv = gym.make(\"CartPole-v1\", render_mode=\"human\")\nloaded_model = PPO.load(\"ppo_cartpole\", env=env)\n\nprint(\"训练结束，开始演示...\")\nobs, _ = env.reset()\nfor i in range(1000):\n    action, _states = loaded_model.predict(obs, deterministic=True)\n\n    obs, reward, terminated, truncated, info = env.step(action)\n    \n    if terminated or truncated:\n        obs, _ = env.reset()\n\nenv.close()\n</code></pre>\n<h3 id=\"代码解释\">代码解释</h3>\n<p>代码流程如下：<br />\n<strong>初始化环境模型-&gt;训练模型-&gt;保存模型-&gt;加载模型-&gt;模型预测</strong></p>\n<h5 id=\"初始化环境模型\">初始化环境模型</h5>\n<p>初始化模型以及游戏的环境</p>\n<pre><code class=\"language-python\">env = gym.make(\"CartPole-v1\")\nmodel = PPO(\"MlpPolicy\", env, verbose=1, device=\"cuda\")\n\nenv = gym.make(\"CartPole-v1\", render_mode=\"human\")\n</code></pre>\n<ul>\n<li><code>gym</code>中的<code>make</code>方法利用默认的游戏环境，<code>CartPole-v1</code>是游戏名，下面有一个<code>render_mode=\"human\"</code>参数，用于标识是否展示画面。训练时展示画面会降低训练的速度，一般在预测时才使用</li>\n</ul>\n<h5 id=\"训练模型\">训练模型</h5>\n<pre><code class=\"language-python\">model.learn(total_timesteps=10000)\n</code></pre>\n<ul>\n<li><code>total_timesteps</code>：训练10000次</li>\n</ul>\n<h5 id=\"保存模型\">保存模型</h5>\n<pre><code class=\"language-python\">model.save(\"ppo_cartpole\")\n</code></pre>\n<ul>\n<li><code>\"ppo_cartpole\"</code> 为保存模型的名字，这里是保存在当前文件夹中。</li>\n</ul>\n<h5 id=\"加载模型\">加载模型</h5>\n<pre><code class=\"language-python\">loaded_model = PPO.load(\"ppo_cartpole\", env=env)\n</code></pre>\n<ul>\n<li>第一个参数：刚刚保存的模型路径</li>\n<li>第二个参数：训练的环境</li>\n</ul>\n<h5 id=\"模型预测\">模型预测</h5>\n<pre><code class=\"language-python\">obs, _ = env.reset()\nfor i in range(1000):\n    action, _states = loaded_model.predict(obs, deterministic=True)\n\n    obs, reward, terminated, truncated, info = env.step(action)\n    \n    if terminated or truncated:\n        obs, _ = env.reset()\n</code></pre>\n<ul>\n<li><code>env.reset()</code>重置环境，返回初始观测值<code>obs</code>和<code>info</code>(这里没用到)</li>\n<li>模型的<code>predict</code>方法用于根据观测值<code>obs</code>预测下一步行动。<strong>注意：deterministic参数要为True，不然会报错</strong></li>\n<li>模型的<code>step</code>方法根据行动值返回结果。（这些都是什么后面文章会讲）</li>\n</ul>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 16:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Kuboard 离线安装与 K3s 集群绑定完整指南",
      "link": "https://www.cnblogs.com/ghostmen/p/19548359",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ghostmen/p/19548359\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 14:29\">\n    <span>Kuboard 离线安装与 K3s 集群绑定完整指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"-目录\">📋 目录</h2>\n<ul>\n<li><a href=\"#%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E\" rel=\"noopener nofollow\">环境说明</a></li>\n<li><a href=\"#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\" rel=\"noopener nofollow\">准备工作</a></li>\n<li><a href=\"#%E4%B8%80%E5%87%86%E5%A4%87%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85\" rel=\"noopener nofollow\">一、准备离线安装包</a></li>\n<li><a href=\"#%E4%BA%8C%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8\" rel=\"noopener nofollow\">二、传输文件到服务器</a></li>\n<li><a href=\"#%E4%B8%89%E5%AE%89%E8%A3%85-kuboard\" rel=\"noopener nofollow\">三、安装 Kuboard</a></li>\n<li><a href=\"#%E5%9B%9B%E8%A7%A3%E5%86%B3-404-%E9%97%AE%E9%A2%98\" rel=\"noopener nofollow\">四、解决 404 问题</a></li>\n<li><a href=\"#%E4%BA%94%E7%BB%91%E5%AE%9A-k3s-%E9%9B%86%E7%BE%A4\" rel=\"noopener nofollow\">五、绑定 K3s 集群</a></li>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4\" rel=\"noopener nofollow\">常用管理命令</a></li>\n<li><a href=\"#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\" rel=\"noopener nofollow\">常见问题</a></li>\n</ul>\n<hr />\n<h2 id=\"环境说明\">环境说明</h2>\n<h3 id=\"服务器环境\">服务器环境</h3>\n<ul>\n<li><strong>服务器 IP</strong>: 10.12.12.110</li>\n<li><strong>操作系统</strong>: CentOS/RHEL</li>\n<li><strong>网络环境</strong>: 内网，无法访问外网</li>\n<li><strong>已安装服务</strong>: K3s v1.30.11+k3s1</li>\n</ul>\n<h3 id=\"本地环境\">本地环境</h3>\n<ul>\n<li><strong>操作系统</strong>: Windows</li>\n<li><strong>网络</strong>: 可以联网</li>\n<li><strong>已安装工具</strong>: Docker Desktop、SecureCRT</li>\n</ul>\n<hr />\n<h2 id=\"准备工作\">准备工作</h2>\n<h3 id=\"所需工具\">所需工具</h3>\n<ul>\n<li>Docker Desktop（Windows 本地）</li>\n<li>SecureCRT（SSH 连接工具）</li>\n<li>浏览器</li>\n</ul>\n<h3 id=\"网络要求\">网络要求</h3>\n<ul>\n<li>本地机器可以访问互联网</li>\n<li>本地机器可以 SSH 连接到服务器</li>\n<li>服务器处于内网环境</li>\n</ul>\n<hr />\n<h2 id=\"一准备离线安装包\">一、准备离线安装包</h2>\n<h3 id=\"11-下载-kuboard-镜像\">1.1 下载 Kuboard 镜像</h3>\n<p>在 Windows 本地（已安装 Docker Desktop）的 PowerShell 中执行：</p>\n<pre><code class=\"language-powershell\"># 使用国内镜像源下载 Kuboard v3\ndocker pull swr.cn-east-2.myhuaweicloud.com/kuboard/kuboard:v3\n\n# 重新标记镜像\ndocker tag swr.cn-east-2.myhuaweicloud.com/kuboard/kuboard:v3 eipwork/kuboard:v3\n\n# 验证镜像\ndocker images | Select-String kuboard\n</code></pre>\n<h3 id=\"12-导出镜像为-tar-文件\">1.2 导出镜像为 tar 文件</h3>\n<pre><code class=\"language-powershell\"># 创建目录\nNew-Item -ItemType Directory -Force -Path \"D:\\Documents\\kuboard-offline\\images\"\n\n# 导出镜像（约 126 MB）\ndocker save eipwork/kuboard:v3 -o \"D:\\Documents\\kuboard-offline\\images\\kuboard-v3.tar\"\n\n# 查看文件大小\nGet-ChildItem \"D:\\Documents\\kuboard-offline\\images\\kuboard-v3.tar\"\n</code></pre>\n<h3 id=\"13-下载-docker-离线安装包\">1.3 下载 Docker 离线安装包</h3>\n<pre><code class=\"language-powershell\"># 创建目录\nNew-Item -ItemType Directory -Force -Path \"D:\\Documents\\kuboard-offline\\docker\"\n\n# 下载 Docker 离线包（约 66.6 MB）\nInvoke-WebRequest -Uri \"https://download.docker.com/linux/static/stable/x86_64/docker-24.0.7.tgz\" -OutFile \"D:\\Documents\\kuboard-offline\\docker\\docker-24.0.7.tgz\"\n</code></pre>\n<h3 id=\"14-创建安装脚本\">1.4 创建安装脚本</h3>\n<p>在 <code>D:\\Documents\\kuboard-offline\\</code> 目录下创建 <code>install.sh</code> 文件：</p>\n<pre><code class=\"language-bash\">#!/bin/bash\n# Kuboard 离线安装脚本\n\nset -e\n\necho \"==========================================\"\necho \"Kuboard 离线安装\"\necho \"==========================================\"\n\n# 检查是否为 root 用户\nif [ \"$EUID\" -ne 0 ]; then \n    echo \"请使用 root 用户或 sudo 执行此脚本\"\n    exit 1\nfi\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" &amp;&amp; pwd)\"\n\n# 检查 Docker 是否已安装\nif ! command -v docker &amp;&gt; /dev/null; then\n    echo \"[1/4] 安装 Docker...\"\n    \n    if [ -f \"${SCRIPT_DIR}/docker/docker-24.0.7.tgz\" ]; then\n        cd \"${SCRIPT_DIR}/docker\"\n        tar -xzf docker-24.0.7.tgz\n        cp docker/* /usr/bin/\n        chmod +x /usr/bin/docker*\n        \n        # 创建 Docker systemd 服务\n        cat &gt; /etc/systemd/system/docker.service &lt;&lt; 'DOCKERSERVICE'\n[Unit]\nDescription=Docker Application Container Engine\nDocumentation=https://docs.docker.com\nAfter=network-online.target firewalld.service\nWants=network-online.target\n\n[Service]\nType=notify\nExecStart=/usr/bin/dockerd\nExecReload=/bin/kill -s HUP $MAINPID\nLimitNOFILE=infinity\nLimitNPROC=infinity\nTimeoutStartSec=0\nDelegate=yes\nKillMode=process\nRestart=on-failure\nStartLimitBurst=3\nStartLimitInterval=60s\n\n[Install]\nWantedBy=multi-user.target\nDOCKERSERVICE\n\n        systemctl daemon-reload\n        systemctl start docker\n        systemctl enable docker\n        \n        echo \"✓ Docker 安装完成\"\n    else\n        echo \"⚠ 未找到 Docker 安装包\"\n    fi\nelse\n    echo \"[1/4] Docker 已安装: $(docker --version)\"\nfi\n\necho \"\"\necho \"[2/4] 加载 Kuboard 镜像...\"\nif [ -f \"${SCRIPT_DIR}/images/kuboard-v3.tar\" ]; then\n    docker load -i \"${SCRIPT_DIR}/images/kuboard-v3.tar\"\n    echo \"✓ Kuboard 镜像加载完成\"\nelse\n    echo \"✗ 未找到 Kuboard 镜像文件\"\n    exit 1\nfi\n\necho \"\"\necho \"[3/4] 创建数据目录...\"\nmkdir -p /data/kuboard\necho \"✓ 数据目录创建完成: /data/kuboard\"\n\necho \"\"\necho \"[4/4] 启动 Kuboard 容器...\"\n\nSERVER_IP=\"10.12.12.110\"\n\n# 检查是否已有运行的 kuboard 容器\nif docker ps -a | grep -q kuboard; then\n    echo \"检测到已存在的 kuboard 容器，正在删除...\"\n    docker rm -f kuboard\nfi\n\n# 启动容器\ndocker run -d \\\n  --restart=unless-stopped \\\n  --name=kuboard \\\n  -p 80:80/tcp \\\n  -p 10081:10081/tcp \\\n  -e KUBOARD_ENDPOINT=\"http://${SERVER_IP}:80\" \\\n  -e KUBOARD_AGENT_SERVER_TCP_PORT=\"10081\" \\\n  -v /data/kuboard:/data \\\n  eipwork/kuboard:v3\n\necho \"\"\necho \"等待容器启动...\"\nsleep 5\n\n# 检查容器状态\nif docker ps | grep -q kuboard; then\n    echo \"✓ Kuboard 启动成功！\"\n    echo \"\"\n    echo \"==========================================\"\n    echo \"安装完成！\"\n    echo \"==========================================\"\n    echo \"访问地址: http://${SERVER_IP}\"\n    echo \"默认用户名: admin\"\n    echo \"默认密码: Kuboard123\"\n    echo \"\"\n    echo \"⚠️  请立即登录并修改默认密码！\"\n    echo \"==========================================\"\nelse\n    echo \"✗ Kuboard 启动失败，请查看日志:\"\n    docker logs kuboard\n    exit 1\nfi\n</code></pre>\n<h3 id=\"15-文件结构\">1.5 文件结构</h3>\n<p>准备完成后，目录结构如下：</p>\n<pre><code>D:\\Documents\\kuboard-offline\\\n├── docker/\n│   └── docker-24.0.7.tgz          (66.6 MB)\n├── images/\n│   └── kuboard-v3.tar             (126 MB)\n└── install.sh                      (安装脚本)\n</code></pre>\n<p><strong>总大小</strong>: 约 193 MB</p>\n<hr />\n<h2 id=\"二传输文件到服务器\">二、传输文件到服务器</h2>\n<h3 id=\"21-使用-securecrt-的-sftp-功能\">2.1 使用 SecureCRT 的 SFTP 功能</h3>\n<h4 id=\"连接到服务器\">连接到服务器</h4>\n<ol>\n<li>打开 SecureCRT</li>\n<li>新建会话或快速连接\n<ul>\n<li>协议：SSH2</li>\n<li>主机名：<code>10.12.12.110</code></li>\n<li>端口：<code>22</code></li>\n<li>用户名：<code>sudoroot</code></li>\n</ul>\n</li>\n<li>连接并输入密码</li>\n</ol>\n<h4 id=\"上传文件\">上传文件</h4>\n<ol>\n<li>按 <code>Alt + P</code> 打开 SFTP 窗口</li>\n<li>在 SFTP 窗口中执行：</li>\n</ol>\n<pre><code class=\"language-bash\"># 切换到服务器的 /tmp 目录\ncd /tmp\n\n# 切换本地目录到 D:\\Documents\nlcd D:\\Documents\n\n# 上传整个文件夹\nput -r kuboard-offline\n</code></pre>\n<ol start=\"3\">\n<li>等待传输完成（约 2-5 分钟）</li>\n</ol>\n<h3 id=\"22-验证文件传输\">2.2 验证文件传输</h3>\n<p>在 SecureCRT 命令行中执行：</p>\n<pre><code class=\"language-bash\"># 检查文件是否完整\nls -lh /tmp/kuboard-offline/\nls -lh /tmp/kuboard-offline/docker/\nls -lh /tmp/kuboard-offline/images/\n</code></pre>\n<hr />\n<h2 id=\"三安装-kuboard\">三、安装 Kuboard</h2>\n<h3 id=\"31-执行安装脚本\">3.1 执行安装脚本</h3>\n<p>在 SecureCRT 中执行：</p>\n<pre><code class=\"language-bash\"># 进入目录\ncd /tmp/kuboard-offline\n\n# 给脚本执行权限\nchmod +x install.sh\n\n# 执行安装\nsudo bash install.sh\n</code></pre>\n<h3 id=\"32-等待安装完成\">3.2 等待安装完成</h3>\n<p>安装脚本会自动完成以下操作：</p>\n<ol>\n<li>✅ 检查并安装 Docker（如果未安装）</li>\n<li>✅ 加载 Kuboard 镜像</li>\n<li>✅ 创建数据目录 <code>/data/kuboard</code></li>\n<li>✅ 启动 Kuboard 容器</li>\n</ol>\n<p>安装过程约需 <strong>1-3 分钟</strong>。</p>\n<h3 id=\"33-验证安装\">3.3 验证安装</h3>\n<pre><code class=\"language-bash\"># 查看容器状态\nsudo docker ps | grep kuboard\n\n# 查看日志\nsudo docker logs kuboard | tail -50\n\n# 测试本地访问\ncurl -I http://localhost:80\n</code></pre>\n<hr />\n<h2 id=\"四解决-404-问题\">四、解决 404 问题</h2>\n<h3 id=\"41-问题现象\">4.1 问题现象</h3>\n<p>初次安装后，访问 <code>http://10.12.12.110</code> 可能会遇到 <strong>404 page not found</strong> 错误。</p>\n<h3 id=\"42-问题原因\">4.2 问题原因</h3>\n<p>Kuboard v3 镜像的 nginx 配置文件默认生成不完整，缺少 <code>http {}</code> 块，导致无法正确处理 HTTP 请求。</p>\n<h3 id=\"43-解决方案更换端口并修复配置\">4.3 解决方案：更换端口并修复配置</h3>\n<h4 id=\"步骤-1停止现有容器并使用新端口\">步骤 1：停止现有容器并使用新端口</h4>\n<pre><code class=\"language-bash\"># 停止并删除现有容器\nsudo docker stop kuboard\nsudo docker rm kuboard\n\n# 使用 41878 端口重新启动\nsudo docker run -d \\\n  --restart=unless-stopped \\\n  --name=kuboard \\\n  -p 41878:80/tcp \\\n  -p 10081:10081/tcp \\\n  -e KUBOARD_ENDPOINT=\"http://10.12.12.110:41878\" \\\n  -e KUBOARD_AGENT_SERVER_TCP_PORT=\"10081\" \\\n  -v /data/kuboard:/data \\\n  eipwork/kuboard:v3\n\n# 等待容器启动\nsleep 30\n</code></pre>\n<h4 id=\"步骤-2修复-nginx-配置\">步骤 2：修复 nginx 配置</h4>\n<pre><code class=\"language-bash\"># 创建完整的 nginx 配置\nsudo docker exec kuboard sh -c 'cat &gt; /etc/nginx/nginx.conf &lt;&lt; \"EOF\"\nuser www-data;\nworker_processes auto;\npid /run/nginx.pid;\ninclude /etc/nginx/modules-enabled/*.conf;\n\nevents {\n    worker_connections 65535;\n}\n\nhttp {\n    sendfile on;\n    tcp_nopush on;\n    tcp_nodelay on;\n    keepalive_timeout 65;\n    types_hash_max_size 2048;\n\n    include /etc/nginx/mime.types;\n    default_type application/octet-stream;\n\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log;\n\n    gzip on;\n\n    server {\n        listen 80;\n        server_name _;\n        \n        client_max_body_size 1024m;\n\n        location / {\n            proxy_pass http://127.0.0.1:10080;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection \"upgrade\";\n        }\n    }\n}\n\nstream {}\nEOF'\n\n# 重载 nginx 配置\nsudo docker exec kuboard nginx -s reload\n</code></pre>\n<h4 id=\"步骤-3验证访问\">步骤 3：验证访问</h4>\n<pre><code class=\"language-bash\"># 测试本地访问\ncurl -I http://localhost:41878\n\n# 查看容器状态\nsudo docker ps | grep kuboard\n</code></pre>\n<h3 id=\"44-访问-kuboard\">4.4 访问 Kuboard</h3>\n<p>在浏览器中访问：</p>\n<p><strong><a href=\"http://10.12.12.110:41878\" rel=\"noopener nofollow\" target=\"_blank\">http://10.12.12.110:41878</a></strong></p>\n<p>登录信息：</p>\n<ul>\n<li><strong>用户名</strong>: <code>admin</code></li>\n<li><strong>密码</strong>: <code>Kuboard123</code></li>\n</ul>\n<p>⚠️ <strong>重要提醒</strong>：首次登录后请立即修改默认密码！</p>\n<hr />\n<h2 id=\"五绑定-k3s-集群\">五、绑定 K3s 集群</h2>\n<h3 id=\"51-检查-k3s-状态\">5.1 检查 K3s 状态</h3>\n<p>在 SecureCRT 中执行：</p>\n<pre><code class=\"language-bash\"># 检查 K3s 服务状态\nsudo systemctl status k3s\n\n# 查看节点信息\nsudo kubectl get nodes\n\n# 查看 kubeconfig 文件\nls -la /etc/rancher/k3s/k3s.yaml\n</code></pre>\n<h3 id=\"52-方法一使用-kubeconfig-导入推荐\">5.2 方法一：使用 KubeConfig 导入（推荐）</h3>\n<h4 id=\"步骤-1生成修改后的-kubeconfig\">步骤 1：生成修改后的 kubeconfig</h4>\n<p>在 SecureCRT 中执行：</p>\n<pre><code class=\"language-bash\"># 将 127.0.0.1 替换为服务器实际 IP\nsudo cat /etc/rancher/k3s/k3s.yaml | sed 's/127.0.0.1/10.12.12.110/g'\n</code></pre>\n<h4 id=\"步骤-2复制输出内容\">步骤 2：复制输出内容</h4>\n<p>执行上面命令后，会输出修改后的 kubeconfig，<strong>全部复制</strong>（从 <code>apiVersion: v1</code> 开始到最后）。</p>\n<h4 id=\"步骤-3在-kuboard-中导入\">步骤 3：在 Kuboard 中导入</h4>\n<ol>\n<li>浏览器访问 <strong><a href=\"http://10.12.12.110:41878\" rel=\"noopener nofollow\" target=\"_blank\">http://10.12.12.110:41878</a></strong></li>\n<li>使用 <code>admin/Kuboard123</code> 登录</li>\n<li>点击页面上的「<strong>添加集群</strong>」按钮</li>\n<li>选择「<strong>通过 KubeConfig 导入</strong>」</li>\n<li>将刚才复制的 kubeconfig 内容粘贴到文本框</li>\n<li>点击「<strong>确定</strong>」或「<strong>导入</strong>」</li>\n</ol>\n<h4 id=\"步骤-4验证集群连接\">步骤 4：验证集群连接</h4>\n<p>导入成功后，你应该能看到：</p>\n<ul>\n<li>集群名称：default</li>\n<li>节点数量：1</li>\n<li>K3s 版本：v1.30.11+k3s1</li>\n<li>节点状态：Ready</li>\n</ul>\n<h3 id=\"53-方法二使用-token-方式\">5.3 方法二：使用 Token 方式</h3>\n<p>如果 KubeConfig 导入失败，可以使用 Token 方式。</p>\n<h4 id=\"步骤-1创建-serviceaccount\">步骤 1：创建 ServiceAccount</h4>\n<p>在 SecureCRT 中执行：</p>\n<pre><code class=\"language-bash\"># 创建 Kuboard 专用账号和权限\ncat &lt;&lt;EOF | sudo kubectl apply -f -\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: kuboard\n\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: kuboard-admin\n  namespace: kuboard\n\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: kuboard-admin\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: cluster-admin\nsubjects:\n- kind: ServiceAccount\n  name: kuboard-admin\n  namespace: kuboard\n\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: kuboard-admin-token\n  namespace: kuboard\n  annotations:\n    kubernetes.io/service-account.name: kuboard-admin\ntype: kubernetes.io/service-account-token\nEOF\n</code></pre>\n<h4 id=\"步骤-2获取-token\">步骤 2：获取 Token</h4>\n<pre><code class=\"language-bash\"># 等待 Secret 创建\nsleep 5\n\n# 获取 Token\necho \"==========================================\"\necho \"Token:\"\necho \"==========================================\"\nsudo kubectl get secret kuboard-admin-token -n kuboard -o jsonpath='{.data.token}' | base64 -d\necho \"\"\necho \"\"\n\n# 获取 CA 证书\necho \"==========================================\"\necho \"CA Certificate:\"\necho \"==========================================\"\nsudo kubectl get secret kuboard-admin-token -n kuboard -o jsonpath='{.data.ca\\.crt}'\necho \"\"\n</code></pre>\n<h4 id=\"步骤-3在-kuboard-中添加集群\">步骤 3：在 Kuboard 中添加集群</h4>\n<ol>\n<li>访问 <strong><a href=\"http://10.12.12.110:41878\" rel=\"noopener nofollow\" target=\"_blank\">http://10.12.12.110:41878</a></strong></li>\n<li>点击「<strong>添加集群</strong>」</li>\n<li>选择「<strong>通过 Token 导入</strong>」或「<strong>手动添加</strong>」</li>\n<li>填写信息：\n<ul>\n<li><strong>集群名称</strong>：k3s-cluster（自定义）</li>\n<li><strong>API Server 地址</strong>：<code>https://10.12.12.110:6443</code></li>\n<li><strong>Token</strong>：粘贴步骤 2 获取的 Token</li>\n<li><strong>CA 证书</strong>：粘贴步骤 2 获取的 CA 证书（如果需要）</li>\n</ul>\n</li>\n<li>点击「<strong>确定</strong>」</li>\n</ol>\n<h3 id=\"54-验证集群绑定\">5.4 验证集群绑定</h3>\n<p>绑定成功后，在 Kuboard 界面中可以：</p>\n<ul>\n<li>查看集群节点状态</li>\n<li>查看命名空间列表</li>\n<li>查看工作负载（Deployments、Pods 等）</li>\n<li>管理配置和存储</li>\n<li>查看日志和监控数据</li>\n</ul>\n<hr />\n<h2 id=\"常用管理命令\">常用管理命令</h2>\n<h3 id=\"kuboard-容器管理\">Kuboard 容器管理</h3>\n<pre><code class=\"language-bash\"># 查看容器状态\nsudo docker ps | grep kuboard\n\n# 查看实时日志\nsudo docker logs -f kuboard\n\n# 重启服务\nsudo docker restart kuboard\n\n# 停止服务\nsudo docker stop kuboard\n\n# 启动服务\nsudo docker start kuboard\n\n# 查看容器详细信息\nsudo docker inspect kuboard\n</code></pre>\n<h3 id=\"数据备份\">数据备份</h3>\n<pre><code class=\"language-bash\"># 手动备份\nsudo tar -czf kuboard-backup-$(date +%Y%m%d).tar.gz /data/kuboard\n\n# 查看备份文件\nls -lh kuboard-backup-*.tar.gz\n\n# 恢复备份\nsudo tar -xzf kuboard-backup-20260129.tar.gz -C /\n</code></pre>\n<h3 id=\"端口检查\">端口检查</h3>\n<pre><code class=\"language-bash\"># 查看端口监听\nsudo netstat -tlnp | grep -E '41878|10081'\n\n# 测试本地访问\ncurl -I http://localhost:41878\n\n# 测试外部访问\ntelnet 10.12.12.110 41878\n</code></pre>\n<h3 id=\"k3s-集群管理\">K3s 集群管理</h3>\n<pre><code class=\"language-bash\"># 查看节点状态\nsudo kubectl get nodes\n\n# 查看所有 Pod\nsudo kubectl get pods --all-namespaces\n\n# 查看 K3s 服务状态\nsudo systemctl status k3s\n\n# 重启 K3s\nsudo systemctl restart k3s\n\n# 查看 K3s 日志\nsudo journalctl -u k3s -f\n</code></pre>\n<hr />\n<h2 id=\"常见问题\">常见问题</h2>\n<h3 id=\"q1-访问-kuboard-显示-404-错误\">Q1: 访问 Kuboard 显示 404 错误</h3>\n<p><strong>原因</strong>：nginx 配置不完整，缺少 <code>http {}</code> 块。</p>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li>更换端口（避开 80 端口）</li>\n<li>手动修复 nginx 配置（参考 <a href=\"#%E5%9B%9B%E8%A7%A3%E5%86%B3-404-%E9%97%AE%E9%A2%98\" rel=\"noopener nofollow\">四、解决 404 问题</a>）</li>\n</ol>\n<h3 id=\"q2-无法从浏览器访问-kuboard\">Q2: 无法从浏览器访问 Kuboard</h3>\n<p><strong>排查步骤</strong>：</p>\n<pre><code class=\"language-bash\"># 1. 检查容器是否运行\nsudo docker ps | grep kuboard\n\n# 2. 检查端口监听\nsudo netstat -tlnp | grep 41878\n\n# 3. 检查防火墙\nsudo firewall-cmd --list-ports\n\n# 4. 开放端口\nsudo firewall-cmd --permanent --add-port=41878/tcp\nsudo firewall-cmd --permanent --add-port=10081/tcp\nsudo firewall-cmd --reload\n</code></pre>\n<h3 id=\"q3-k3s-集群无法连接\">Q3: K3s 集群无法连接</h3>\n<p><strong>可能原因</strong>：</p>\n<ol>\n<li>API Server 地址错误（应该是服务器 IP，不是 127.0.0.1）</li>\n<li>Token 或证书错误</li>\n<li>K3s 服务未运行</li>\n</ol>\n<p><strong>解决方案</strong>：</p>\n<pre><code class=\"language-bash\"># 检查 K3s 状态\nsudo systemctl status k3s\n\n# 重启 K3s\nsudo systemctl restart k3s\n\n# 重新生成 kubeconfig\nsudo cat /etc/rancher/k3s/k3s.yaml | sed 's/127.0.0.1/10.12.12.110/g'\n</code></pre>\n<h3 id=\"q4-端口被占用\">Q4: 端口被占用</h3>\n<p><strong>检查端口占用</strong>：</p>\n<pre><code class=\"language-bash\">sudo netstat -tlnp | grep :41878\n</code></pre>\n<p><strong>更换端口</strong>：</p>\n<pre><code class=\"language-bash\"># 停止容器\nsudo docker rm -f kuboard\n\n# 使用新端口（如 8888）\nsudo docker run -d \\\n  --restart=unless-stopped \\\n  --name=kuboard \\\n  -p 8888:80/tcp \\\n  -p 10081:10081/tcp \\\n  -e KUBOARD_ENDPOINT=\"http://10.12.12.110:8888\" \\\n  -e KUBOARD_AGENT_SERVER_TCP_PORT=\"10081\" \\\n  -v /data/kuboard:/data \\\n  eipwork/kuboard:v3\n</code></pre>\n<h3 id=\"q5-docker-镜像拉取失败\">Q5: Docker 镜像拉取失败</h3>\n<p><strong>原因</strong>：国内网络访问 Docker Hub 受限。</p>\n<p><strong>解决方案</strong>：使用国内镜像源</p>\n<pre><code class=\"language-powershell\"># 使用华为云镜像源\ndocker pull swr.cn-east-2.myhuaweicloud.com/kuboard/kuboard:v3\n\n# 重新标记\ndocker tag swr.cn-east-2.myhuaweicloud.com/kuboard/kuboard:v3 eipwork/kuboard:v3\n</code></pre>\n<hr />\n<h2 id=\"总结\">总结</h2>\n<p>本文详细介绍了在内网环境下离线安装 Kuboard 并绑定 K3s 集群的完整流程：</p>\n<ol>\n<li><strong>准备阶段</strong>：在联网的 Windows 机器上下载 Kuboard 镜像和 Docker 离线包</li>\n<li><strong>传输阶段</strong>：使用 SecureCRT 的 SFTP 功能将文件传输到内网服务器</li>\n<li><strong>安装阶段</strong>：执行安装脚本，自动完成 Docker 和 Kuboard 的安装</li>\n<li><strong>修复阶段</strong>：解决 nginx 配置问题，更换端口确保正常访问</li>\n<li><strong>绑定阶段</strong>：通过 KubeConfig 或 Token 方式将 K3s 集群绑定到 Kuboard</li>\n</ol>\n<h3 id=\"关键要点\">关键要点</h3>\n<ul>\n<li>✅ 使用国内镜像源加速下载</li>\n<li>✅ 离线安装适用于内网环境</li>\n<li>✅ 手动修复 nginx 配置解决 404 问题</li>\n<li>✅ 使用非标准端口避免冲突</li>\n<li>✅ KubeConfig 方式是最简单的集群绑定方法</li>\n</ul>\n<h3 id=\"最终效果\">最终效果</h3>\n<ul>\n<li><strong>Kuboard 访问地址</strong>：<a href=\"http://10.12.12.110:41878\" rel=\"noopener nofollow\" target=\"_blank\">http://10.12.12.110:41878</a></li>\n<li><strong>默认账号</strong>：admin / Kuboard123</li>\n<li><strong>K3s 集群</strong>：已成功绑定，可通过 Kuboard 管理</li>\n</ul>\n<hr />\n<h2 id=\"参考资源\">参考资源</h2>\n<ul>\n<li>Kuboard 官网：<a href=\"https://kuboard.cn\" rel=\"noopener nofollow\" target=\"_blank\">https://kuboard.cn</a></li>\n<li>K3s 官网：<a href=\"https://k3s.io\" rel=\"noopener nofollow\" target=\"_blank\">https://k3s.io</a></li>\n<li>Docker 官网：<a href=\"https://www.docker.com\" rel=\"noopener nofollow\" target=\"_blank\">https://www.docker.com</a></li>\n<li>SecureCRT 官网：<a href=\"https://www.vandyke.com/products/securecrt/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.vandyke.com/products/securecrt/</a></li>\n</ul>\n<hr />\n<p><strong>作者</strong>：技术博客<br />\n<strong>日期</strong>：2026-01-29<br />\n<strong>版本</strong>：v1.0</p>\n<hr />\n<h2 id=\"附录\">附录</h2>\n<h3 id=\"a-完整的安装脚本\">A. 完整的安装脚本</h3>\n<p>参考 <a href=\"#%E4%B8%89%E5%AE%89%E8%A3%85-kuboard\" rel=\"noopener nofollow\">三、安装 Kuboard</a> 中的 <code>install.sh</code></p>\n<h3 id=\"b-nginx-完整配置\">B. nginx 完整配置</h3>\n<p>参考 <a href=\"#%E5%9B%9B%E8%A7%A3%E5%86%B3-404-%E9%97%AE%E9%A2%98\" rel=\"noopener nofollow\">四、解决 404 问题</a> 中的 nginx 配置</p>\n<h3 id=\"c-端口说明\">C. 端口说明</h3>\n<table>\n<thead>\n<tr>\n<th>端口</th>\n<th>用途</th>\n<th>协议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>41878</td>\n<td>Kuboard Web 界面</td>\n<td>HTTP</td>\n</tr>\n<tr>\n<td>10081</td>\n<td>Kuboard Agent 通信</td>\n<td>TCP/UDP</td>\n</tr>\n<tr>\n<td>6443</td>\n<td>K3s API Server</td>\n<td>HTTPS</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"d-目录结构\">D. 目录结构</h3>\n<pre><code>/data/kuboard/              # Kuboard 数据目录\n├── etcd-data/              # etcd 数据\n├── questdb/                # QuestDB 数据\n└── ...\n\n/etc/rancher/k3s/           # K3s 配置目录\n└── k3s.yaml                # K3s kubeconfig\n\n/tmp/kuboard-offline/       # 离线安装包\n├── docker/\n├── images/\n└── install.sh\n</code></pre>\n<hr />\n<p><strong>感谢阅读！如有问题，欢迎留言讨论。</strong> 🎉</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 14:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ghostmen\">ghostmen</a>&nbsp;\n阅读(<span id=\"post_view_count\">11</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从零开始搭建部署 Moltbot/Clawdbot 完整攻略",
      "link": "https://www.cnblogs.com/aigclabs/p/19548083",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aigclabs/p/19548083\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 13:48\">\n    <span>从零开始搭建部署 Moltbot/Clawdbot 完整攻略</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>Moltbot（原名 Clawdbot）是 2026 年 1 月突然爆火的开源个人 AI 助手项目，由 Peter Steinberger（PSPDFKit 创始人）开发。</p>\n<p>Moltbot 是一个把&nbsp;<strong>本地算力 + 大模型 Agent 自动化</strong>&nbsp;玩到极致的开发者效率工具。</p>\n<p>Moltbot 目标是让 AI 不只是给建议，而是直接完成完整工程任务。</p>\n<div class=\"wp-caption alignnone\" id=\"attachment_9050\"><img alt=\"Moltbot\" class=\"size-full wp-image-9050 lazyload\" height=\"364\" width=\"1165\" />\n<div class=\"google-auto-placed ap_container\"><ins class=\"adsbygoogle adsbygoogle-noablate\">\n<div id=\"aswift_5_host\"></div>\n</ins></div>\n<p class=\"wp-caption-text\" id=\"caption-attachment-9050\">Moltbot</p>\n</div>\n<div class=\"auto-hide-last-sibling-br paragraph-vM4cn4 paragraph-element\">\n<p>Moltbot/Clawdbot 是一款功能全面的 AI 助手框架，核心能力涵盖以下维度：</p>\n<div class=\"container-XbLssQ md-box-line-break wrapper-GTUtdt undefined\">&nbsp;</div>\n<p>🤖&nbsp;<strong>多模型兼容</strong>：无缝对接 MiniMax、Claude、GLM、GPT 等主流大语言模型，灵活满足不同场景需求；</p>\n<div class=\"container-XbLssQ md-box-line-break wrapper-GTUtdt undefined\">&nbsp;</div>\n<p>💬&nbsp;<strong>多平台适配</strong>：支持与 WhatsApp、Telegram、Discord 等热门社交 / 通讯平台集成，实现跨平台交互；</p>\n<div class=\"container-XbLssQ md-box-line-break wrapper-GTUtdt undefined\">&nbsp;</div>\n<p>🛠️&nbsp;<strong>丰富工具生态</strong>：内置浏览器访问、文件系统操作、代码自动生成等实用工具，提升任务处理效率；</p>\n<div class=\"container-XbLssQ md-box-line-break wrapper-GTUtdt undefined\">&nbsp;</div>\n<p>🔧&nbsp;<strong>可拓展技能体系</strong>：支持自定义技能开发与接入，轻松扩展框架功能边界。</p>\n</div>\n<h2 class=\"header-uz7uol auto-hide-last-sibling-br\" id=\"toc_1\">版本说明</h2>\n<ul class=\"auto-hide-last-sibling-br\">\n<li><strong>Moltbot</strong>：框架官方标准名称，当前最新版本统一使用此名称对应的命令；</li>\n<li><strong>Clawdbot</strong>：框架旧版本使用的命令标识，部分长期用户可能仍沿用该称呼。</li>\n</ul>\n<div class=\"auto-hide-last-sibling-br paragraph-vM4cn4 paragraph-element\">本教程操作指引均以&nbsp;<strong>moltbot</strong>&nbsp;命令为准，若为 Clawdbot 旧版本用户，将教程中的命令替换为 Clawdbot 对应命令即可正常使用。</div>\n<div>\n<p>因为 Anthropic 在 1 月 27 日发律师函称 Clawd / Clawdbot与 Claude 太像，项目在当天紧急更名为 Moltbot（脱皮龙虾之意，吉祥物是小龙虾 Molty 🦞），但功能完全一致，旧命令 clawdbot 仍然兼容。</p>\n<div class=\"google-auto-placed ap_container\"><ins class=\"adsbygoogle adsbygoogle-noablate\">\n<div id=\"aswift_6_host\"></div>\n</ins></div>\n<p>与传统对话式大模型工具不同，它强调：</p>\n<ul>\n<li>任务自动规划（Planning）</li>\n<li>本地执行（Shell、文件系统、代码操作）</li>\n<li>失败反思与自修复（Reflection Loop）</li>\n</ul>\n<hr />\n<h2 id=\"toc_2\">安装方法</h2>\n<p><a href=\"https://app.qiip.cc/9049.html\" rel=\"noopener nofollow\" target=\"_blank\">https://app.qiip.cc/9049.html</a></p>\n<p>Moltbot 的安装被设计得极为友好，即使是非开发者也能快速上手。</p>\n</div>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/aigclabs/\" target=\"_blank\">AIGC实验室</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/aigclabs/p/19548083\" target=\"_blank\">https://www.cnblogs.com/aigclabs/p/19548083</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 13:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aigclabs\">AIGC实验室</a>&nbsp;\n阅读(<span id=\"post_view_count\">184</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "我不允许谁还不清楚function call在AI-Agent领域中打手的地位",
      "link": "https://www.cnblogs.com/JulianHuang/p/19548079",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/JulianHuang/p/19548079\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 13:47\">\n    <span>我不允许谁还不清楚function call在AI-Agent领域中打手的地位</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>前文提要：还有比ollama更傻瓜式的大模型本地部署方式吗 ？</p>\n<h2 id=\"1function-calling-底层工作原理\">1.<a href=\"https://medium.com/@jamestang/llm-function-calling-explained-a-deep-dive-into-the-request-and-response-payloads-894800fcad75\" rel=\"noopener nofollow\" target=\"_blank\" title=\"function calling\">function calling</a> 底层工作原理</h2>\n<p>大模型重塑了我们与软件应用的交互方式， 其中最重要的特性就是 function calling 。</p>\n<p>一种<strong>利用结构化输入/输出在LLM和编程应用之间建立桥梁</strong>的方式。</p>\n<p>不管是当前火热的AI-agent还是MCP，了解function calling底层工作原理都至关重要，特别是request和response payload。</p>\n<p>回顾上文我们与qwen大模型的对话：</p>\n<p><code>what is the temperature in the capital of china today？</code></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260129134717432-1696255009.png\" /></p>\n<p>一个由LLM驱动的应用， 回答这个问题，应用与LLM经历了三次对话。</p>\n<p>① 第一次请求payload：</p>\n<ul>\n<li>message：标准的历史对话， 提供上下文context</li>\n<li>tools：一系列的工具函数定义， 提供给LLM来选择</li>\n</ul>\n<p>LLM的响应payload：</p>\n<ul>\n<li><code>tool_calls.function.name</code>： LLM选中的工具函数<code>get_currentDate</code></li>\n<li><code>tool_calls.id</code>： 由LLM为这个函数指定的id，后面会用到</li>\n</ul>\n<p>② 第二次request：</p>\n<ul>\n<li><code>messages.role.assistant</code>: 告诉LLM我们这次请求包含了上次function calling的结果</li>\n<li><code>messages.role.tool</code>： 上次function calling执行的结果<code>2026-01-24</code></li>\n</ul>\n<p>LLM的响应payload：</p>\n<p>如第一次类似：<br />\n本例也有<code>tool_calls</code>:包含LLM选中的函数<code>get_temperature()</code> 和所有的参数<code>beijing</code> <code>2026-01-24</code>。</p>\n<p>③ 应用最后一次请求，包含所有信息</p>\n<p>LLM推理认为不再需要外部工具，不再返回<code>tool_calls</code>,给出结合外部工具的对话结果。</p>\n<hr />\n<p>从三次请求对话来看， LLM在三次对话的响应中体现了它的思考和逻辑步骤，应用持续被LLM引导做出行动，同时LLM也持续对应用的行为做出进一步观察和思考。</p>\n<h2 id=\"2-agent的实现原理\">2. agent的实现原理</h2>\n<p>大模型是 AI 的大脑，其核心是理解自然语言，并做出回应，(文本)大模型本身只能接收一段文本，然后输出一段文本。</p>\n<p>而当你希望大模型能使用一些工具自行获取所需的信息、执行一些动作，就需要使用 Tool 来实现了，拥有了 Tool 的大模型就像是拥有了手脚，可以和当下已有的 IT 基础设施进行交互。</p>\n<blockquote>\n<p>RAG给LLM装上实时知识外挂， 通过将信息检索与文本生成结合，让模型能引用外部权威信息生成回答，既保证了时效性，又提升了准确性。</p>\n</blockquote>\n<p>字节开源的<code>Eino</code>标榜的优势在于：</p>\n<ol>\n<li>\n<p>LangChain，LlamaIndex等主流框架虽然起源自python强大的AI生态，但是也继承了python“弱类型检查”和“长期维护成本高”的诟病。 Eino作为golang下的开源agent开发框架，规避了这一问题。</p>\n</li>\n<li>\n<p>另一方面， 借助字节系在agent领域的工程化实践，Eino既封装了领域内不变的通用核心和最佳实践，也能敏捷的反映业内技术动向。</p>\n</li>\n</ol>\n<p><a href=\"https://www.cloudwego.io/zh/docs/eino/quick_start/\" rel=\"noopener nofollow\" target=\"_blank\" title=\"Eino\">Eino</a>框架结构图：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260129134703978-610293353.png\" /></p>\n<p>Eino 有三大稳定内核： compose编排、components组件，common公共库。</p>\n<p><a href=\"https://www.cloudwego.io/zh/docs/eino/overview/bytedance_eino_practice/\" rel=\"noopener nofollow\" target=\"_blank\">组件</a>一抹多,是原子能力的最小单位， <a href=\"https://www.cloudwego.io/zh/docs/eino/core_modules/chain_and_graph_orchestration/\" rel=\"noopener nofollow\" target=\"_blank\">编排</a>对这些组件进行组合、串连。</p>\n<h2 id=\"3--中国首都今天的天气怎么样-我母鸡啊\">3.  中国首都今天的天气怎么样? 我母鸡啊</h2>\n<p>我们使用Eino框架来实现本文的题目：<br />\n<code>what is  the temperature in the capital of china today</code>。</p>\n<p>按照我们的分析，<br />\n从LLM的视角，要回答这个问题，经历了“思考-行动-观察-思考” 循环， 这是一个<code>ReAct</code>模式的agent。</p>\n<p>下面基于阿里百炼千问大模型，实现了天气对话，请自行从阿里百炼平台申请的apiKey替换到54行。</p>\n<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/cloudwego/eino-ext/components/model/qwen\"\n\t\"github.com/cloudwego/eino/components/tool\"\n\t\"github.com/cloudwego/eino/components/tool/utils\"\n\t\"github.com/cloudwego/eino/compose\"\n\t\"github.com/cloudwego/eino/schema\"\n)\n\n// what is  the temperature in the capital of china today\n\ntype weatherReqParam struct {\n\tCity string `json:\"city\"  jsonschema:\"description=the name of the city\"`\n\tDate string `json:\"date\"  jsonschema:\"description=the date in the format of YYYY-MM-DD\"`\n}\n\nfunc GetTemperatureFunc(_ context.Context, p weatherReqParam) (float64, error) {\n\t// 这里直接mock一个温度值，实际应用中应该替换为真实的API调用\n\treturn 32, nil\n}\n\nfunc GetCurrentDateFunc(_ context.Context, _ struct{}) (string, error) {\n\treturn time.Now().Format(\"2006-01-02\"), nil\n}\n\nfunc of[T any](t T) *T {\n\treturn &amp;t\n}\n\nfunc main() {\n\tgetDateTool, err := utils.InferTool(\"get_currentDate\", \"Get the current date\", GetCurrentDateFunc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tgetTemperatureTool, err := utils.InferTool(\"get_temperature\", \"Get the temperature in the capital of the city\", GetTemperatureFunc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// 初始化 tools\n\tweatherTools := []tool.BaseTool{\n\t\tgetDateTool,\n\t\tgetTemperatureTool,\n\t}\n\n\tapiKey := os.Getenv(\"DASHSCOPE_API_KEY\")\n\tapiKey = \"{}\"  // 在阿里百炼平台申请签名\n\tmodelName := os.Getenv(\"MODEL_NAME\")\n\tmodelName = \"qwen3-max\"\n\tchatModel, err := qwen.NewChatModel(context.Background(), &amp;qwen.ChatModelConfig{\n\t\tBaseURL:     \"https://dashscope.aliyuncs.com/compatible-mode/v1\",\n\t\tAPIKey:      apiKey,\n\t\tTimeout:     0,\n\t\tModel:       modelName,\n\t\tMaxTokens:   of(2048),\n\t\tTemperature: of(float32(0.7)),\n\t\tTopP:        of(float32(0.7)),\n\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"NewChatModel of qwen failed, err=%v\", err)\n\t}\n\n\tvar ctx = context.Background()\n\t// 获取工具信息并绑定到 ChatModel\n\ttoolInfos := make([]*schema.ToolInfo, 0, len(weatherTools))\n\tfor _, tool := range weatherTools {\n\t\tinfo, err := tool.Info(ctx)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\ttoolInfos = append(toolInfos, info)\n\t}\n\terr = chatModel.BindTools(toolInfos)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// 创建 tools 节点\n\tweatherToolsNode, err := compose.NewToolNode(context.Background(), &amp;compose.ToolsNodeConfig{\n\t\tTools: weatherTools,\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// 构建基于 Graph 的 Agent，实现 ReAct 模式（自动执行工具并生成自然语言回复）\n\n\t// 定义状态，用于保存对话历史\n\ttype appState struct {\n\t\tmessages []*schema.Message\n\t}\n\n\tgraph := compose.NewGraph[[]*schema.Message, *schema.Message](\n\t\tcompose.WithGenLocalState(func(ctx context.Context) *appState {\n\t\t\treturn &amp;appState{}\n\t\t}),\n\t)\n\n\t// 添加 ChatModel 节点\n\terr = graph.AddChatModelNode(\"qwen_chat_model\", chatModel,\n\t\tcompose.WithStatePreHandler(func(ctx context.Context, input []*schema.Message, state *appState) ([]*schema.Message, error) {\n\t\t\t// 如果是第一次进入（从 Start），将输入（用户问题）添加到历史\n\t\t\tif len(state.messages) == 0 {\n\t\t\t\tstate.messages = append(state.messages, input...)\n\t\t\t}\n\t\t\t// 始终将完整的历史记录作为 ChatModel 的输入\n\t\t\treturn state.messages, nil\n\t\t}),\n\t\tcompose.WithStatePostHandler(func(ctx context.Context, output *schema.Message, state *appState) (*schema.Message, error) {\n\t\t\t// 将 ChatModel 的输出（可能是工具调用或最终回复）添加到历史\n\t\t\tstate.messages = append(state.messages, output)\n\t\t\treturn output, nil\n\t\t}),\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// 添加 Tools 节点\n\terr = graph.AddToolsNode(\"agent_tools\", weatherToolsNode,\n\t\tcompose.WithStatePostHandler(func(ctx context.Context, output []*schema.Message, state *appState) ([]*schema.Message, error) {\n\t\t\t// 将工具执行结果添加到历史\n\t\t\tstate.messages = append(state.messages, output...)\n\t\t\treturn output, nil\n\t\t}),\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// 添加边和分支\n\t_ = graph.AddEdge(compose.START, \"qwen_chat_model\")\n\n\t// 如果有工具调用，流转到 tools；否则结束\n\t_ = graph.AddBranch(\"qwen_chat_model\", compose.NewGraphBranch(func(ctx context.Context, msg *schema.Message) (string, error) {\n\t\tif len(msg.ToolCalls) &gt; 0 {\n\t\t\treturn \"agent_tools\", nil\n\t\t}\n\t\treturn compose.END, nil\n\t}, map[string]bool{\"agent_tools\": true, compose.END: true}))\n\n\t// 工具执行完后，回流到 chat_model 生成回复\n\t_ = graph.AddEdge(\"agent_tools\", \"qwen_chat_model\")\n\n\t// 编译运行\n\tagent, err := graph.Compile(ctx)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// 运行示例\n\tresp, err := agent.Invoke(ctx, []*schema.Message{\n\t\t{\n\t\t\tRole:    schema.User,\n\t\t\tContent: \"what is the temperature in the capital of china today? please answer in a humam like way.\",\n\t\t},\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// 输出结果\n\tfmt.Println(resp.Content)\n}\n\n</code></pre>\n<p>一开始我参照的官网的<code>chain</code>编排Eino组件，但是得到的结果是数字“32”， 并不是LLM对话的类人语言。</p>\n<p>使用Trae的编码agent，20s就帮我改成了Graph形式的正确编码， 输出：</p>\n<pre><code>The temperature in Beijing, the capital of China, today (January 28, 2026) is a warm 32°C! That’s quite hot for this time of year—make sure to stay hydrated and cool if you’re out and about!\n</code></pre>\n<blockquote>\n<p>本例实际也可以使用<code>Chain</code>来完成，chain是一种特殊的、简化的graph，chain不能回头，本例需要手动串起来，Chain更适合确定性的编排。</p>\n</blockquote>\n<p>Graph就像一个自动化的流水线（loop），工人是 chat_model 和 tools ：</p>\n<p>本例的Graph图如下，读者可以结合源代码理解。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260129134632628-692308084.png\" /></p>\n<ol>\n<li>START -&gt; chat_model\n<ul>\n<li>ChatModel 拿到用户问题，思考后说：“我需要查日期。”（输出包含 ToolCall）</li>\n</ul>\n</li>\n<li>chat_model -&gt; tools (由 Branch 判断)\n<ul>\n<li>Tools 听到指令，去查日期，得到 \"2026-01-24\"。</li>\n</ul>\n</li>\n<li>tools -&gt; chat_model (由 AddEdge 强制流转)\n<ul>\n<li>ChatModel 再次被唤醒。这次它的输入包含了之前的历史（用户问题 + 刚才的 ToolCall + 刚才的结果）。</li>\n<li>它再次思考：“我知道日期了，现在我要查北京的温度。”（输出包含 ToolCall）</li>\n</ul>\n</li>\n<li>chat_model -&gt; tools (再次循环)\n<ul>\n<li>Tools 去查温度，得到 \"32度\"。</li>\n</ul>\n</li>\n<li>tools -&gt; chat_model (再次循环)\n<ul>\n<li>ChatModel 再次被唤醒。现在的输入更丰富了（所有历史）。</li>\n<li>它再次思考：“日期有了，温度也有了，我可以直接回答用户了。”（输出 不包含 ToolCall）</li>\n</ul>\n</li>\n<li>chat_model -&gt; END (由 Branch 判断)\n<ul>\n<li>循环结束。</li>\n</ul>\n</li>\n</ol>\n<p>最后我们重温全文，function calling（function tools）在agent中的作用：<br />\n在由LLM驱动的agent应用中，function calling（function tools）作为LLM的手脚，让LLM具备使用工具从外部获取最新信息并指导应用行为的能力，这一过程由结构化的输入输出参数来传递。</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <hr color=\"#987cb9\" size=\"3\" width=\"80%\" />\n<div style=\"text-align: center;\">\n<p>本文来自博客园，作者：{有态度的马甲}，转载请注明原文链接：<a href=\"https://www.cnblogs.com/JulianHuang/p/19548079\" target=\"_blank\">https://www.cnblogs.com/JulianHuang/p/19548079</a></p>\n<strong style=\"color: red;\">欢迎关注我的原创技术、职场公众号， 加好友谈天说地，一起进化</strong>\n<div><img src=\"https://blog-static.cnblogs.com/files/JulianHuang/QR.gif\" style=\"width: 250px; height: 250px;\" /> </div>\n\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 13:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/JulianHuang\">码甲哥不卷</a>&nbsp;\n阅读(<span id=\"post_view_count\">130</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ClickShow：一款给鼠标点击加上特效的小工具",
      "link": "https://www.cnblogs.com/ttym/p/19548061",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ttym/p/19548061\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 13:44\">\n    <span>ClickShow：一款给鼠标点击加上特效的小工具</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        ClickShow：一款给鼠标点击加上特效的小工具\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"clickshow一款给鼠标点击加上特效的小工具\">ClickShow：一款给鼠标点击加上特效的小工具</h1>\n<h2 id=\"1引言\">1.引言</h2>\n<p>大家在【课堂教学】、【会议演示】、【直播】为了更【明显】地展示鼠标点击的地方，往往需要给鼠标加上一些特效，如波纹、光圈等特效。于是，就有了这么一款软件:ClickShow<br />\n而这个就是用于提示鼠标点击、鼠标位置。<br />\n<img alt=\"2026-01-29T05_16_19\" src=\"https://img2024.cnblogs.com/blog/3722699/202601/3722699-20260129132653876-1521725954.gif\" /></p>\n<h2 id=\"2特色功能\">2.特色功能</h2>\n<ul>\n<li>鼠标点击时显示波纹特效，每个按键对应不同的颜色；</li>\n<li>支持跟随鼠标的位置指示圆标；</li>\n<li>支持多屏DPI感知；</li>\n<li>支持开机自启动；<br />\nClickShow就是一款给鼠标点击加特效的工具，使用它可以在点击鼠标的时候显示一层波纹特效，左键，右键，侧键都支持，不同的点击显示不同的颜色，颜色可以自定义。<br />\n只有414.7 KB大小，解压后即可<span class=\"heimu\" title=\"咳咳……你知道的太多了\">食用</span></li>\n</ul>\n<h2 id=\"3软件下载\">3.软件下载</h2>\n<p>这个软件目前已经停更，为什么这么说呢？因为<br />\n<img alt=\"图片\" src=\"https://img2024.cnblogs.com/blog/3722699/202601/3722699-20260129133742681-1092623727.png\" /><br />\ne...仓库都存档了，他更新个毛线<br />\n所以说，软件下载地址如下:<br />\nGithub下载地址:<a href=\"https://github.com/cuiliang/ClickShow/releases\" rel=\"noopener nofollow\" target=\"_blank\">点击这里</a><br />\nGitee源码下载地址:<a href=\"https://gitee.com/phdbbs/ClickShow\" rel=\"noopener nofollow\" target=\"_blank\">点击这里</a><br />\n蓝奏云下载地址:<a href=\"https://mcnoch.lanzoue.com/ip5pL3h9hdrc\" rel=\"noopener nofollow\" target=\"_blank\">点击这里</a></p>\n<h2 id=\"4使用方法\">4.使用方法</h2>\n<h3 id=\"1解压软件\">1.解压软件</h3>\n<p>首先，下载软件，下载下来后是一个压缩包，然后我们点开它<br />\n界面如下(解压软件使用不同界面也会有不同):<br />\n<img alt=\"图片\" src=\"https://img2024.cnblogs.com/blog/3722699/202601/3722699-20260129141403923-1033643496.png\" /><br />\n注意:DotNetProjects.Wpf.Extended.Toolkit.dll文件也要一起解压到相同文件夹，就像这样:<br />\n<img alt=\"图片\" src=\"https://img2024.cnblogs.com/blog/3722699/202601/3722699-20260129141518838-1579021081.png\" /></p>\n<h3 id=\"2打开软件\">2.打开软件</h3>\n<p>双击<strong>ClickShow.exe</strong>或者<strong>ClickShow</strong>就可以使用了</p>\n<h3 id=\"3配置软件\">3.配置软件</h3>\n<p>软件打开之后是没有任何窗口的，所以我们需要去到托盘查看此应用，他的图标长这个样子的:<img alt=\"图片\" src=\"https://img2024.cnblogs.com/blog/3722699/202601/3722699-20260129142035045-1095963103.png\" />，单击一下打开它，界面如下:<br />\n<img alt=\"图片\" src=\"https://img2024.cnblogs.com/blog/3722699/202601/3722699-20260129142123581-332438607.png\" /><br />\n点击<code>更多设置(S)...</code>打开之后如下图：<br />\n<img alt=\"图片\" src=\"https://img2024.cnblogs.com/blog/3722699/202601/3722699-20260129142245817-295936951.png\" /><br />\n波纹大小：波纹大小是指点击后光圈的大小，这个不宜调得太大。<br />\n各按键波纹颜色:按键的颜色是指光圈圆环的颜色，可以自由调整。一般左键单击颜色较深，右键颜色较浅。设置好颜色后，最好设置一下透明度(A)的值，让光圈更自然。<br />\n位置浮标外观：<br />\n悬浮标颜色:就是跟随鼠标的一个实心圆圈，这里可以调整颜色，调整颜色时适当设置一下透明度，让它能透出下方的文字。<br />\n悬浮标大小:就是跟随鼠标的一个实心圆圈，这里可以调整大小，不宜调得太大。</p>\n<h2 id=\"废话爱看不看\">废话(爱看不看)</h2>\n<p>很久没更新了，就随便找了一个实用软件来推荐一下。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 13:44</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ttym\">通天野马</a>&nbsp;\n阅读(<span id=\"post_view_count\">10</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第三周：序列模型与注意力机制（一）seq2seq 模型",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19547898",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19547898\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 13:28\">\n    <span>吴恩达深度学习课程五：自然语言处理  第三周：序列模型与注意力机制（一）seq2seq 模型</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课第三周的内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=173\" rel=\"noopener nofollow\" target=\"_blank\">3.1</a><strong>和</strong><a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=178\" rel=\"noopener nofollow\" target=\"_blank\">3.6</a>的内容。</p>\n<hr />\n<p>本周为第五课的第三周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本周的内容关于<strong>序列模型和注意力机制</strong>，这里的序列模型其实是<strong>指多对多非等长模型</strong>，这类模型往往更加复杂，其应用领域也更加贴近工业和实际，自然也会衍生相关的模型和技术。而注意力机制则让模型在长序列中学会主动分配信息权重，而不是被动地一路传递。二者结合，为 Transformer 等现代架构奠定了基础。</p>\n<p>本篇的内容关于<strong>seq2seq 模型</strong>，是对多对多非等长模型的展开介绍。</p>\n<h1 id=\"1seq2seq-模型sequence-to-sequence-model\">1.seq2seq 模型（Sequence to Sequence Model）</h1>\n<p>2014 年被普遍认为是seq2seq模型真正成型的关键年份。<br />\n首先，起源论文 <a href=\"https://arxiv.org/pdf/1409.3215.pdf\" rel=\"noopener nofollow\" target=\"_blank\">Sequence to Sequence Learning with Neural Networks</a>被发表，其中首次系统性地验证了基于 <strong>RNN 的 Encoder–Decoder 架构</strong> 可以直接建模“输入序列 → 输出序列”的生成过程，并成功应用于机器翻译任务。这项工作明确确立了 <strong>seq2seq 作为一种通用序列生成范式</strong>，也奠定了后续神经机器翻译模型的基本结构。</p>\n<p>几乎在同一时期，另一篇论文<a href=\"https://arxiv.org/pdf/1406.1078.pdf\" rel=\"noopener nofollow\" target=\"_blank\">Learning Phrase Representations using RNN Encoder–Decoder for Statistical Machine Translation</a>从表示学习的角度提出了 <strong>RNN Encoder–Decoder</strong> 这一结构性思想，并引入了带门控机制的循环单元（后来发展为 GRU）。这项工作强调编码器学习语义表示、解码器建模条件生成分布，<strong>为随后注意力机制的提出提供了直接的理论与结构基础</strong>。</p>\n<p>这两篇论文从工程实现与结构抽象两个互补视角，共同奠定了 seq2seq 模型与编码–解码范式在自然语言处理中的核心地位。</p>\n<p>同样简单介绍一下历史，看起来很高深，但其实许多内容在我们之前就已经知道了，只是现在我们为其正式命名引入了，下面就来分点展开：</p>\n<h2 id=\"11-seq2seq-模型编码-解码结构\">1.1 seq2seq 模型：编码-解码结构</h2>\n<p>seq2seq 模型的全称是 Sequence to Sequence 模型，顾名思义，是指 “序列到序列” 的模型。<br />\n在我们之前介绍的<a href=\"https://www.cnblogs.com/Goblinscholar/p/19454021\" target=\"_blank\">RNN 结构类型</a>中，<strong>seq2seq 模型专指输入为序列，输出同样为序列的多对多非等长模型。</strong></p>\n<p>这里很容易产生一个问题：<strong>为什么多对多等长模型，就像我们之前演示的命名实体识别，不也是输入序列，输出序列吗？它为什么不被归纳在 seq2seq 模型中呢？</strong><br />\n实际上，二者的差异存在于它们的模型结构和传播逻辑上，我们简单展开如下：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260129131233592-471976794.png\" /><br />\n总结来说，<strong>seq2seq 面向的是“生成另一段序列”的问题，而命名实体识别等对多等长模型面向的是“对原序列逐位置打标签”的问题。</strong><br />\n前者是非等长的序列生成，后者是等长的序列标注，因此后者不被归入 seq2seq 模型范畴。</p>\n<p>在明确了概念后，接下来就可以具体来看 seq2seq 模型内部最核心的结构设计——<strong>编码–解码（Encoder–Decoder）框架</strong>。</p>\n<p>在刚刚的图中我们已经看到了，在经典的 seq2seq 模型中，整体网络通常由两个相互独立但逻辑上强耦合的子网络组成：</p>\n<ol>\n<li><strong>编码器（Encoder）：将输入序列压缩为语义表示。</strong></li>\n<li><strong>解码器（Decoder）：基于语义表示生成输出序列。</strong></li>\n</ol>\n<p>展开如下：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260129131234233-1651828923.png\" /><br />\n从整体结构上看，seq2seq 的编码–解码框架有几个特点：</p>\n<ol>\n<li>输入序列与输出序列在时间维度上<strong>不要求对齐</strong>，既非等长。</li>\n<li>编码阶段与解码阶段在结构上<strong>明确分离</strong>。</li>\n<li>输出是一个<strong>生成过程</strong>，而非逐位置的判别结果，其传播类似我们之前介绍的<a href=\"https://www.cnblogs.com/Goblinscholar/p/19454021\" target=\"_blank\">新序列采样</a>。</li>\n</ol>\n<p>正是这些特征，让其拥有广泛的应用领域和极高的延展性，下面就来看看seq2seq 的一些具体应用。</p>\n<h2 id=\"12-seq2seq-模型的应用领域\">1.2 seq2seq 模型的应用领域</h2>\n<p>可以看到，seq2seq 模型的核心能力在于：<strong>在不要求输入输出对齐的前提下，将一段序列映射为另一段序列，并通过生成过程逐步给出结果。</strong><br />\n这一特性决定了 seq2seq 并不适用于“逐位置判别”的任务，而是天然适合<strong>语义层面的序列转换问题</strong>。<br />\n听起来有些抽象，展开来说：seq2seq 模型的应用并不依赖具体任务形式，而依赖于一个条件：</p>\n<blockquote>\n<p><strong>任务是否可以被表述为“在理解一段序列后，生成另一段序列”。</strong></p>\n</blockquote>\n<p>正是这一能力，使得 seq2seq 在多个领域中展现出极强的通用性，简单列举如下：</p>\n<table>\n<thead>\n<tr>\n<th>应用领域</th>\n<th>输入序列</th>\n<th>输出序列</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>机器翻译</td>\n<td>源语言句子</td>\n<td>目标语言句子</td>\n</tr>\n<tr>\n<td>文本摘要</td>\n<td>长文本序列</td>\n<td>短摘要序列</td>\n</tr>\n<tr>\n<td>对话系统 / 文本生成</td>\n<td>用户输入文本</td>\n<td>系统回复文本</td>\n</tr>\n<tr>\n<td>语音识别</td>\n<td>声学特征序列</td>\n<td>文本序列</td>\n</tr>\n</tbody>\n</table>\n<p>这些都并不难理解，无非是数据不同，编码解码的模型结构都是相通的，就不再展开了。<br />\n<strong>值得一提的是，吴恩达老师在课程里举了一个特别的例子：图像描述生成（Image Captioning）。</strong><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260129132743596-542605457.png\" /><br />\n如图，在这一任务中，模型的<strong>输入不再是文本序列，而是一张图像，输出则是一段自然语言描述。</strong>  但它依然可以被纳入 seq2seq 的框架之中。<br />\n其核心思想在于： <strong>只要能够将输入数据编码为一种序列化或向量化的语义表示，后续的解码过程就仍然可以按照“序列生成”的方式进行。</strong><br />\n在图像描述生成任务中，图像通常首先<strong>由卷积神经网络提取为高层语义特征，作为编码器</strong>的输出，解码器则在这一语义表示的条件约束下，逐词生成对应的文本描述。</p>\n<p>像这种“非文本输入 → 文本输出”的建模方式，<strong>让模型不再局限于单一模态的数据，我们便称这类建模方式为多模态学习。</strong><br />\n我们最常见的 AI 就是一种多模态模型，你不仅可以和 AI 进行文字交流，还可以上传图片或文件并让其输出不同内容。<br />\n<strong>从这一视角来看，seq2seq 并不仅是一类 NLP 模型结构，而是一种可以跨模态复用的序列建模范式。</strong></p>\n<p>对 seq2seq 的基础内容就介绍到这里，下面我们展开介绍一下 <strong>seq2seq 模型特有的评估指标：BLEU 得分。</strong></p>\n<h1 id=\"2-bleu-得分bilingual-evaluation-understudy\">2. BLEU 得分（Bilingual Evaluation Understudy）</h1>\n<p>seq2seq 模型出现后，一个紧随而来的问题就是：<strong>如何非手工地判断模型生成的这一整段序列，究竟好不好？</strong></p>\n<p>对于分类或序列标注任务，我们可以逐位置对比预测结果与真实标签，直接计算准确率或 F1。<br />\n但在机器翻译、文本摘要等 seq2seq 任务中，<strong>输出往往是不固定长度的一整句话甚至一整段文本，且“正确答案”并不唯一。</strong> 这就使得传统指标几乎失效。</p>\n<p>以机器翻译为例，假设参考译文为：<em>I like machine learning.</em><br />\n而模型输出为： <em>I enjoy machine learning.</em><br />\n从语义上看，这两个句子几乎完全一致。但如果我们采用“逐词是否相同”的方式进行评估，模型反而会被判定为错误。<br />\n也就是说： seq2seq 任务的<strong>评价目标是“语义相似度”，而不是“形式一致性”。</strong></p>\n<p>于是，在 2002 年的论文： <a href=\"https://aclanthology.org/P02-1040.pdf\" rel=\"noopener nofollow\" target=\"_blank\">BLEU: a Method for Automatic Evaluation of Machine Translation</a>中，首次提出了 BLEU 指标，用于<strong>在不依赖人工逐句评审的前提下，对机器翻译结果进行自动化评估。</strong><br />\n其基本思想可以概括为一句话： <strong>如果模型生成的结果，在局部片段层面上与人工参考结果高度重合，那么整体质量往往也是可信的。</strong></p>\n<p>下面就来展开介绍其评估过程：</p>\n<h2 id=\"21-n-gram-精确率modified-n-gram-precision\">2.1 n-gram 精确率（Modified n-gram Precision）</h2>\n<p>计算 BLEU 得分的第一步，是 计算<strong>n-gram 精确率</strong>。<br />\n所谓 n-gram，就是<strong>把候选序列划分为长度为 <span class=\"math inline\">\\(n\\)</span> 的连续词片段</strong>，例如：</p>\n<ul>\n<li>unigram（<span class=\"math inline\">\\(n=1\\)</span>）：单个词就是一个 unigram</li>\n<li>bigram（<span class=\"math inline\">\\(n=2\\)</span>）：相邻两个词组合起来是一个 bigram</li>\n<li>trigram（<span class=\"math inline\">\\(n=3\\)</span>）：相邻三个词组合起来是一个 trigram</li>\n</ul>\n<p>BLEU 的关键并不在于“词有没有出现”，而在于<strong>模型生成的局部结构，是否与人工译文存在重合</strong>。</p>\n<p>我们仍然使用前面的例子，并假设已经完成分词：</p>\n<ol>\n<li>参考标签：<code>[I, like, machine, learning]</code>，长度 <span class=\"math inline\">\\(r = 4\\)</span>。</li>\n<li>候选输出：<code>[I, enjoy, machine, learning]</code>，长度 <span class=\"math inline\">\\(c = 4\\)</span>。</li>\n</ol>\n<p>下面，就是用这一公式来计算对应的 n-gram 精确率：</p>\n<p></p><div class=\"math display\">\\[p_n = \\frac{\\sum_{\\text{ngram}} \\min(\\text{Count}_{\\text{cand}}, \\text{Count}_{\\text{ref}})}{\\sum_{\\text{ngram}} \\text{Count}_{\\text{cand}}}  \n\\]</div><p></p><p>我们用文字来展开这个计算过程：</p>\n<ol>\n<li><strong>枚举候选序列中的每一个 n-gram</strong>：将模型输出序列切分成长度为 <span class=\"math inline\">\\(n\\)</span> 的连续片段。</li>\n<li><strong>统计候选 n-gram 与参考 n-gram 的匹配次数：</strong>\n<ul>\n<li><span class=\"math inline\">\\(\\text{Count}_{\\text{cand}}\\)</span> 表示候选序列中该 n-gram 出现的次数。</li>\n<li><span class=\"math inline\">\\(\\text{Count}_{\\text{ref}}\\)</span> 表示参考序列中该 n-gram 出现的次数。</li>\n<li>取最小值 <span class=\"math inline\">\\(\\min(\\text{Count}_{\\text{cand}}, \\text{Count}_{\\text{ref}})\\)</span> 计算合理匹配次数。</li>\n</ul>\n</li>\n<li><strong>除以候选序列中所有 n-gram 的总数</strong>：这相当于计算了<strong>候选序列中有多少比例的 n-gram 与参考序列匹配</strong>，即“精确率”。</li>\n</ol>\n<p>下面就来具体演示一下：</p>\n<p><strong>首先，我们计算 Unigram，即 <span class=\"math inline\">\\(n=1\\)</span>：</strong></p>\n<table>\n<thead>\n<tr>\n<th>Unigram</th>\n<th>Candidate 出现次数</th>\n<th>Reference 出现次数</th>\n<th><span class=\"math inline\">\\(\\min(\\text{Count}_{\\text{cand}}, \\text{Count}_{\\text{ref}})\\)</span></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>I</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>enjoy</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>machine</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>learning</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>因此：</p>\n<p></p><div class=\"math display\">\\[p_1 = \\frac{1+0+1+1}{4} = \\frac{3}{4} = 0.75  \n\\]</div><p></p><p><strong>继续，我们在试试 Bigram，即 <span class=\"math inline\">\\(n=2\\)</span>：</strong></p>\n<table>\n<thead>\n<tr>\n<th>Bigram</th>\n<th>Candidate 出现次数</th>\n<th>Reference 出现次数</th>\n<th><span class=\"math inline\">\\(\\min(\\text{Count}_{\\text{cand}}, \\text{Count}_{\\text{ref}})\\)</span></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>(I, enjoy)</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>(enjoy, machine)</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>(machine, learning)</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>因此 Bigram 精确率为：</p>\n<p></p><div class=\"math display\">\\[p_2 = \\frac{0 + 0 + 1}{3} = \\frac{1}{3} \\approx 0.333  \n\\]</div><p></p><p>以此类推，继续计算：</p>\n<ul>\n<li>trigram：完全无匹配，<span class=\"math inline\">\\(p_3 = 0\\)</span></li>\n<li>4-gram：完全无匹配，<span class=\"math inline\">\\(p_4 = 0\\)</span></li>\n</ul>\n<p>最终，你会发现，<strong>这一步，其实是在不同尺度上计算候选序列和参考序列的匹配度。</strong></p>\n<h2 id=\"22-长度惩罚-bpbrevity-penalty\">2.2 长度惩罚 BP（Brevity Penalty）</h2>\n<p>在最终计算之前，BLEU 专门设置了一个参数 <strong>BP</strong> 用来解决这样一个问题：</p>\n<blockquote>\n<p><strong>如果只看 n-gram 精确率，模型可以“作弊”——生成很短的序列，只输出部分正确词，就可能获得很高分。</strong></p>\n</blockquote>\n<p>其公式如下：</p>\n<p></p><div class=\"math display\">\\[\\text{BP} =\n\\begin{cases}\n1, &amp; c &gt; r \\\\\n\\exp\\left(1 - \\frac{r}{c}\\right), &amp; c \\le r\n\\end{cases}\n\\]</div><p></p><p>其中， <span class=\"math inline\">\\(c\\)</span> 是模型生成序列的长度、<span class=\"math inline\">\\(r\\)</span> 是参考序列的长度。</p>\n<p>计算得到的 <strong>BP 会作为最终评估的系数</strong>，因此，它的语义是这样的：</p>\n<ul>\n<li><strong>如果生成序列长度 &gt;= 参考长度</strong>，BP = 1，不额外惩罚。</li>\n<li><strong>如果生成序列太短</strong>，BP &lt; 1，会对总分进行指数级扣分。</li>\n</ul>\n<p>举个例子：<br />\n设参考序列长度 <span class=\"math inline\">\\(r = 4\\)</span> 、模型生成序列长度 <span class=\"math inline\">\\(c = 2\\)</span> ，计算 BP 为：</p>\n<p></p><div class=\"math display\">\\[\\text{BP} = \\exp(1 - \\frac{4}{2}) = \\exp(-1) \\approx 0.368  \n\\]</div><p></p><p>这样，<strong>即使 unigram/bigram 匹配较好，最终 BLEU 分数也会因为序列太短而大幅下降。</strong></p>\n<p>BP 的引入确保 BLEU 得分不仅考虑 <strong>局部 n-gram 匹配</strong>，还考虑 <strong>生成序列长度合理性</strong>。<br />\n简单来说：<strong>短序列不能通过“少输出”来刷分</strong>。</p>\n<h2 id=\"23-多阶-n-gram-的几何平均\">2.3 多阶 n-gram 的几何平均</h2>\n<p>你会发现：<strong>低级 n-gram 到高阶 n-gram 实际上是对语序的逐步注重。</strong><br />\n而如果只使用 unigram，模型可能生成一堆“正确的词”，但语序混乱；如果只使用高阶 n-gram，又会对细微差异过于苛刻。<br />\n因此，BLEU 的做法是：<strong>同时计算多个 <span class=\"math inline\">\\(p_n\\)</span>，并取它们的几何平均。</strong></p>\n<p>其中，最常见的就是 BLEU-4，即和我们刚刚一样计算前四阶 n-gram 进行最终评估，公式如下：</p>\n<p></p><div class=\"math display\">\\[\\text{BLEU} = \\text{BP} \\cdot \\exp\\left( \\sum_{n=1}^{4} w_n \\log p_n \\right)  \n\\]</div><p></p><p>其中，参数 <span class=\"math inline\">\\(w_n\\)</span> 就是<strong>第 <span class=\"math inline\">\\(n\\)</span> 阶 n-gram 在最终得分中所占的权重</strong>，通常取均等权重 <span class=\"math inline\">\\(w_n = \\frac{1}{4}\\)</span>。<br />\n而<strong>对数和再指数的方式，可以把几何平均转化为加权 log 和的形式</strong>，计算更稳定，同时也避免了直接乘法下的数值下溢（数值太小了超出存储位数，导致计算机无法精确表示）。</p>\n<p>在我们的例子中：</p>\n<p></p><div class=\"math display\">\\[p_1 = 0.75,\\quad p_2 \\approx 0.333,\\quad p_3 = 0,\\quad p_4 = 0  \n\\]</div><p></p><p></p><div class=\"math display\">\\[\\exp\\left( \\sum_{n=1}^{4} w_n \\log p_n \\right) = \\prod_{n=1}^4 p_n^{w_n} = 0.75^{0.25} \\cdot 0.333^{0.25} \\cdot 0^ {0.25} \\cdot 0^ {0.25} = 0   \n\\]</div><p></p><p>此时可以看出一个问题：<strong>只要某一阶 <span class=\"math inline\">\\(p_n = 0\\)</span>，整体 BLEU 就会变为 0。</strong></p>\n<p>这并不是缺陷，而是 BLEU 的一个重要使用前提： <strong>BLEU 是为“语料级评估”设计的，而不是单句评估指标。</strong><br />\n在真实使用中，BLEU 会在整个测试集上累加 n-gram 统计后再计算，此时 <span class=\"math inline\">\\(p_n\\)</span> 几乎不会为 0。</p>\n<p>由此，我们就完成了 BLEU 指标的计算。<br />\nBLEU 是首个自动化、可复现的序列生成评价指标，为神经机器翻译和 seq2seq 研究奠定了基础，它主要依赖 n-gram 匹配，极大加速了模型调试与对比，但也有其局限性：对语义和多样性敏感性不足。<br />\n因此，后续也发展出更多了指标，如 BERTScore、ROUGE、CIDEr 等，它们在语义理解、多样性和跨模态任务上进行了改进与拓展，我们遇到再展开。</p>\n<h1 id=\"3总结\">3.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻 / 直观理解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>seq2seq 模型</strong></td>\n<td>输入序列映射到输出序列，允许非等长，基于编码–解码结构</td>\n<td>将一句话“翻译”成另一句话，就像把中文句子转换成英文句子</td>\n</tr>\n<tr>\n<td><strong>编码器 (Encoder)</strong></td>\n<td>将输入序列压缩为固定维度的语义表示</td>\n<td>像把整篇文章压缩成大脑里的核心理解</td>\n</tr>\n<tr>\n<td><strong>解码器 (Decoder)</strong></td>\n<td>根据编码器提供的语义表示逐步生成输出序列</td>\n<td>像根据脑中理解逐字复述或生成一句话</td>\n</tr>\n<tr>\n<td><strong>应用领域</strong></td>\n<td>机器翻译、文本摘要、对话系统、语音识别、图像描述生成</td>\n<td>将不同模态的输入（文本、语音、图像）转化为另一段序列输出</td>\n</tr>\n<tr>\n<td><strong>BLEU 指标</strong></td>\n<td>基于 n-gram 精确率和长度惩罚 BP 计算序列生成质量</td>\n<td>检查生成句子中局部片段有多少和参考句子重合，顺序和长度也考虑在内</td>\n</tr>\n<tr>\n<td><strong>n-gram 精确率</strong></td>\n<td>统计候选序列与参考序列 n-gram 的匹配比例</td>\n<td>像对比两段文字中每个词或词组出现情况</td>\n</tr>\n<tr>\n<td><strong>Brevity Penalty (BP)</strong></td>\n<td>对生成过短的序列进行惩罚，防止“少说就高分”</td>\n<td>就像考试中答题太短，即使答案对也会扣分</td>\n</tr>\n<tr>\n<td><strong>几何平均 (多阶 n-gram)</strong></td>\n<td>对不同阶 n-gram 精确率取几何平均并加权</td>\n<td>平衡单词准确性和语序准确性，既考虑词对又考虑短语对</td>\n</tr>\n<tr>\n<td><strong>BLEU 局限</strong></td>\n<td>单句容易为 0，主要用于语料级评估，对语义和多样性敏感性不足</td>\n<td>就像只看字面重合，可能忽略同义表达</td>\n</tr>\n</tbody>\n</table>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 13:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一天一个Python库：pyyaml - 轻松处理YAML数据",
      "link": "https://www.cnblogs.com/min2k/p/19547959",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/min2k/p/19547959\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 13:26\">\n    <span>一天一个Python库：pyyaml - 轻松处理YAML数据</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"pyyaml---轻松处理yaml数据\">pyyaml - 轻松处理YAML数据</h1>\n<h2 id=\"一什么是pyyaml\">一、什么是pyyaml？</h2>\n<p><strong>pyyaml</strong> 是一个用于在 Python 中处理 YAML（YAML Ain't Markup Language）数据格式的库。<br />\n它可以帮助你：</p>\n<ul>\n<li><strong>解析YAML文件和字符串</strong>: 将YAML数据转换为Python字典和列表。</li>\n<li><strong>生成YAML文件和字符串</strong>: 将Python数据结构转换为YAML格式。</li>\n<li><strong>处理复杂的数据结构</strong>: 支持嵌套、列表、字典等各种YAML特性。</li>\n</ul>\n<h2 id=\"二应用场景\">二、应用场景</h2>\n<p><strong>pyyaml</strong> 广泛应用于以下实际场景：</p>\n<ul>\n<li><strong>配置文件管理</strong>: YAML以其简洁的语法，常用于应用程序的配置，pyyaml可以轻松读取和写入这些配置。</li>\n<li><strong>数据序列化与反序列化</strong>: 在不同系统或服务之间交换数据时，YAML作为一种人类可读的数据格式，非常适合。</li>\n<li><strong>自动化脚本</strong>: 编写自动化脚本时，使用YAML来定义任务参数或数据结构，方便维护和修改。</li>\n</ul>\n<h2 id=\"三如何安装\">三、如何安装</h2>\n<ol>\n<li>使用 pip 安装</li>\n</ol>\n<pre><code class=\"language-bash\">pip install pyyaml\n\n# 如果安装慢的话，推荐使用国内镜像源\npip install pyyaml -i https://www.python64.cn/pypi/simple/\n</code></pre>\n<ol start=\"2\">\n<li>使用 <a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行代码（无需本地安装）</li>\n</ol>\n<h2 id=\"四示例代码\">四、示例代码</h2>\n<p>将YAML字符串解析为Python字典，并根据条件打印信息。</p>\n<pre><code class=\"language-python\">import yaml\n\n# YAML 格式的字符串\nyaml_string = \"\"\"\nname: Alice\nage: 30\ncity: New York\nis_student: false\nscores: [90, 85, 92]\n\"\"\"\n\n# 将 YAML 字符串加载为 Python 字典\ndata = yaml.safe_load(yaml_string)\n\n# 打印解析后的数据\nprint(\"解析后的数据:\", data)\nprint(f\"姓名: {data['name']}\")\nprint(f\"年龄: {data['age']}\")\nprint(f\"城市: {data['city']}\")\n\n# 判断是否是学生\nif data['is_student']:\n    print(f\"{data['name']} 是一名学生。\")\nelse:\n    print(f\"{data['name']} 不是一名学生。\")\n\n# 如果年龄大于25，则打印额外信息\nif data['age'] &gt; 25:\n    print(f\"{data['name']} 的年龄大于25岁。\")\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/python-run/?code=import%20yaml%0A%0A%23%20YAML%20%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%0Ayaml_string%20%3D%20%22%22%22%0Aname%3A%20Alice%0Aage%3A%2030%0Acity%3A%20New%20York%0Ais_student%3A%20false%0Ascores%3A%20%5B90%2C%2085%2C%2092%5D%0A%22%22%22%0A%0A%23%20%E5%B0%86%20YAML%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E8%BD%BD%E4%B8%BA%20Python%20%E5%AD%97%E5%85%B8%0Adata%20%3D%20yaml.safe_load%28yaml_string%29%0A%0A%23%20%E6%89%93%E5%8D%B0%E8%A7%A3%E6%9E%90%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%0Aprint%28%22%E8%A7%A3%E6%9E%90%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%3A%22%2C%20data%29%0Aprint%28f%22%E5%A7%93%E5%90%8D%3A%20%7Bdata%5B'name'%5D%7D%22%29%0Aprint%28f%22%E5%B9%B4%E9%BE%84%3A%20%7Bdata%5B'age'%5D%7D%22%29%0Aprint%28f%22%E5%9F%8E%E5%B8%82%3A%20%7Bdata%5B'city'%5D%7D%22%29%0A%0A%23%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AD%A6%E7%94%9F%0Aif%20data%5B'is_student'%5D%3A%0A%20%20%20%20print%28f%22%7Bdata%5B'name'%5D%7D%20%E6%98%AF%E4%B8%80%E5%90%8D%E5%AD%A6%E7%94%9F%E3%80%82%22%29%0Aelse%3A%0A%20%20%20%20print%28f%22%7Bdata%5B'name'%5D%7D%20%E4%B8%8D%E6%98%AF%E4%B8%80%E5%90%8D%E5%AD%A6%E7%94%9F%E3%80%82%22%29%0A%0A%23%20%E5%A6%82%E6%9E%9C%E5%B9%B4%E9%BE%84%E5%A4%A7%E4%BA%8E25%EF%BC%8C%E5%88%99%E6%89%93%E5%8D%B0%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF%0Aif%20data%5B'age'%5D%20%3E%2025%3A%0A%20%20%20%20print%28f%22%7Bdata%5B'name'%5D%7D%20%E7%9A%84%E5%B9%B4%E9%BE%84%E5%A4%A7%E4%BA%8E25%E5%B2%81%E3%80%82%22%29\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行这段代码，结果如下：</p>\n<pre><code class=\"language-text\">解析后的数据: {'name': 'Alice', 'age': 30, 'city': 'New York', 'is_student': False, 'scores': [90, 85, 92]}\n姓名: Alice\n年龄: 30\n城市: New York\nAlice 不是一名学生。\nAlice 的年龄大于25岁。\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/mermaid/?code=flowchart%20TB%0A%20%20A%5B%E5%BC%80%E5%A7%8B%5D%20--%3E%20B%7B%E5%AF%BC%E5%85%A5yaml%E5%BA%93%7D%3B%0A%20%20B%20--%3E%20C%5B%E5%AE%9A%E4%B9%89yaml_string%5D%3B%0A%20%20C%20--%3E%20D%5Byaml.safe_load%28yaml_string%29%5D%3B%0A%20%20D%20--%3E%20E%7B%E6%89%93%E5%8D%B0%E8%A7%A3%E6%9E%90%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%7D%3B%0A%20%20E%20--%3E%20F%7B%E6%89%93%E5%8D%B0%E5%A7%93%E5%90%8D%2C%20%E5%B9%B4%E9%BE%84%2C%20%E5%9F%8E%E5%B8%82%7D%3B%0A%20%20F%20--%3E%20G%7Bdata%5B'is_student'%5D%20%E4%B8%BA%E7%9C%9F%3F%7D%3B%0A%20%20G%20--%20%E6%98%AF%20--%3E%20H%5B%E6%89%93%E5%8D%B0%20%22%E6%98%AF%E5%AD%A6%E7%94%9F%22%5D%3B%0A%20%20G%20--%20%E5%90%A6%20--%3E%20I%5B%E6%89%93%E5%8D%B0%20%22%E4%B8%8D%E6%98%AF%E5%AD%A6%E7%94%9F%22%5D%3B%0A%20%20H%20--%3E%20J%7Bdata%5B'age'%5D%20%3E%2025%3F%7D%3B%0A%20%20I%20--%3E%20J%3B%0A%20%20J%20--%20%E6%98%AF%20--%3E%20K%5B%E6%89%93%E5%8D%B0%20%22%E5%B9%B4%E9%BE%84%E5%A4%A7%E4%BA%8E25%22%5D%3B%0A%20%20J%20--%20%E5%90%A6%20--%3E%20L%5B%E7%BB%93%E6%9D%9F%5D%3B%0A%20%20K%20--%3E%20L%3B\" rel=\"noopener nofollow\" target=\"_blank\">MermaidGo</a> 绘制示例代码的流程图，结果如下：</p>\n<p><img alt=\"MermerGo的pyyaml流程图\" class=\"lazyload\" /></p>\n<h2 id=\"五学习资源\">五、学习资源</h2>\n<ol>\n<li>开源项目：<a href=\"https://github.com/yaml/pyyaml\" rel=\"noopener nofollow\" target=\"_blank\">pyyaml</a></li>\n<li>中文自述：<a href=\"https://www.python64.cn/readme/pyyaml/\" rel=\"noopener nofollow\" target=\"_blank\">REMDME</a></li>\n<li>在线运行：<a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a></li>\n</ol>\n<blockquote>\n<p>如果这篇文章对你有帮助，欢迎点赞、收藏、转发！<br />\n学习过程中有任何问题，欢迎在评论区留言交流～</p>\n</blockquote>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 13:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/min2k\">敏编程</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}