{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "让 AI 分析我 3 年前写的代码，全是漏洞！",
      "link": "https://www.cnblogs.com/yupi/p/19420512",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19420512\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 11:48\">\n    <span>让 AI 分析我 3 年前写的代码，全是漏洞！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"让 AI 分析我 3 年前写的代码，全是漏洞！\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202512/2225420-20251230112305334-1414820438.png\" />\n        对于个人开发者来说，这类工具可以帮你在提交代码前发现潜在问题，拿来检测一下自己之前的老项目代码也是不错的；对于团队来说，可以把 AI 接入到 CI/CD 流程中，自动化代码安全检查。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-heading\"><span class=\"md-plain\">大家好，俺是程序员鱼皮。最近逛 GitHub 的时候，发现了一个挺有潜力的开源项目 —— DeepAudit，让 AI 帮你挖掘项目漏洞。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">势头很猛啊，短短时间就涨了不少 star，看这 star 趋势图：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这是一个 AI 代码审计工具，能自动分析你的代码，找出潜在的安全漏洞和代码问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">作者很贴心地提供了在线体验版，可以直接使用，当然也支持本地部署。下面鱼皮以作者部署的在线体验版，带大家体验一下这个项目的功能。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先需要配置自己的大模型 API Key，国内的很多大模型都支持：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果想直接导入并分析你在 GitHub 上的项目，而不是手动上传代码，那么还需要配置 GitHub Token，让工具能够读取到你的仓库代码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可以在 GitHub 上生成一个新的 Token：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">配置好之后，就可以创建一个要分析的项目了，仓库地址要填写正确。这里鱼皮拿自己 3 年前做的个人开源项目 —— SQL 代码和数据生成器试试水。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img alt=\"创建新项目\" class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后新建一个审计任务：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">填写要分析的分支，还可以设置一些文件排除规则，比如排除 <span class=\"md-pair-s\"><code>node_modules</code><span class=\"md-plain\">、测试文件等。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">点击开始分析，AI 就屁颠儿屁颠儿干活了~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我去，竟然发现了 123 个问题？！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过能写出 123 个问题，我感觉自己也是挺厉害的哈哈哈。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">进入任务详情页面，我倒要看看都是什么问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先看看最严重的 —— SQL 注入漏洞。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 的解释还挺到位的，确实存在 SQL 注入风险。当时这么写纯属图方便，没想到被 AI 一眼看穿了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">一些小细节也被指出来了，比如硬编码、异常处理不够完善、日志记录不规范等。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过也有一些误报，AI 把正常的代码逻辑判断成了问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">总体来说，这个工具还有进步空间，但已经很实用了。正好我们团队需要这样的代码审计工具，还是挺期待作者能进一步完善的。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">审计完成后，还可以直接导出报告：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">一下子就得到了整整 70 多页的专业报告！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">想想我大学的时候做课设作业，要是有 AI 帮忙生成这种报告，不得爽飞边子了？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了项目审计，作者还提供了即时分析功能。不过这个就没什么新意了，我们团队的 <span class=\"md-meta-i-c  md-link\"><a href=\"https://codecopy.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">代码小抄</span></a><span class=\"md-plain\">在 24 年初就已经上线了这个功能。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我体验这个项目的时候，还有很多功能没做完，不过这也是 MVP 最小可行产品原则嘛，快速验证想法最重要。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">值得一提的是，作者更新非常频繁。截止到目前，项目界面已经焕然一新了，更有极客范儿。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在审计流日志页面可以看到 AI 思考分析的过程：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还有智能仪表盘，可以直观地看到代码质量趋势：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">最后</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个项目的实现思路其实挺值得学习的。通过调用大模型的 API，让 AI 理解代码逻辑，然后根据常见的安全漏洞模式和最佳实践进行分析，最后生成结构化的审计报告。整个流程和 AI 代码审查是类似的，但更专注于安全漏洞的发现。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img alt=\"DeepAudit 架构图\" class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对于个人开发者来说，这类工具可以帮你在提交代码前发现潜在问题，拿来检测一下自己之前的老项目代码也是不错的；对于团队来说，可以把 AI 接入到 CI/CD 流程中，自动化代码安全检查。虽然本项目暂时还有误报，但随着 AI 能力的提升，以及作者在领域知识方面的填充，相信会越来越准确。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">来试试看，你的项目代码里有多少个 Bug？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-meta-i-c md-link md-expand\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 11:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "掌握Fetch与Flask交互：让前端表单提交更优雅的动态之道",
      "link": "https://www.cnblogs.com/ymtianyu/p/19418995",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19418995\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 08:18\">\n    <span>掌握Fetch与Flask交互：让前端表单提交更优雅的动态之道</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文详细解析了前端Fetch API的工作原理与常见用法，并重点阐述了其如何与Python Flask后端框架协同工作。通过登录重定向、数据动态增删改查等具体场景，演示了如何实现无刷新交互体验。文章提供了前后端配套的代码示例，讲解了如何处理JSON、文本等不同格式的响应，以及如何根据响应状态更新用户界面，为构建现代Web应用提供了实用指南。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<h1 style=\"font-size: 22px; line-height: 1.4; margin-top: 0; margin-bottom: 15px; font-weight: bold; color: rgba(26, 26, 26, 1);\">还在为表单提交后页面刷新烦恼？一文搞定Fetch与Flask的无缝交互</h1>\n<p style=\"font-size: 15px; color: rgba(127, 140, 141, 1); margin-bottom: 20px; padding-left: 12px; font-style: italic;\">本文带你深入理解现代前端 Fetch API 的工作原理，并手把手教你如何与 Flask 后端优雅结合，实现无刷新登录、数据动态增删改查等交互。<br />亮点包括：Fetch 核心原理剖析、登录重定向的异步处理、利用响应状态码动态更新UI、以及如何处理JSON/文本等不同格式的返回数据。<br /><br /><span style=\"font-weight: bold;\">你将学到：</span><br />- Fetch API 的“承诺”机制与基础用法<br />- 如何用 Flask 构建 RESTful 风格的 API 端点<br />- 登录表单提交：告别传统表单刷新，实现平滑跳转<br />- 数据操作：前端一个请求，后端处理，前端UI即时响应<br />- 根据后端返回的不同数据类型（JSON/Text）进行精准处理</p>\n<h2 style=\"font-size: 18px; font-weight: bold; color: rgba(44, 62, 80, 1); padding-bottom: 8px; margin-top: 30px; margin-bottom: 15px;\">✨ 目录</h2>\n<p>1. 初识Fetch：现代Web的通信信使<br />2. 🛠️ 实战准备：Flask后端的简单配置<br />3. 🔐 场景一：登录表单提交与页面重定向<br />4. ✨ 场景二：动态新增与修改数据<br />5. 📦 场景三：处理不同类型的响应数据<br />6. 💻 完整代码参考与总结</p>\n<h2 style=\"font-size: 20px; font-weight: bold; color: rgba(44, 62, 80, 1); margin-top: 35px; margin-bottom: 15px;\">1. 初识Fetch：现代Web的通信信使</h2>\n<p><code>fetch()</code> 是浏览器提供的、基于 <strong style=\"color: rgba(186, 55, 42, 1);\">Promise</strong> 的现代网络请求API。它取代了古老的 XMLHttpRequest，让异步数据请求变得清晰、简洁。你可以把它想象成一个专业的“信使”。</p>\n<p>它的基本工作流程是：你给信使（fetch）一个地址（URL）和指示（配置对象），它立刻返回一个“承诺收据”（Promise）。这个承诺最终会兑现为“响应包裹”（Response对象），你需要打开这个包裹（调用如.json(), .text()等方法）才能拿到里面的真实数据。</p>\n<pre class=\"language-javascript highlighter-hljs\"><code>// 一个最简单的GET请求示例\nfetch('/api/data')\n  .then(response =&gt; response.json()) // 打开包裹，解析JSON数据\n  .then(data =&gt; console.log(data))   // 处理真实数据\n  .catch(error =&gt; console.error('出错啦：', error)); // 处理错误</code></pre>\n<h2 style=\"font-size: 20px; font-weight: bold; color: rgba(44, 62, 80, 1); margin-top: 35px; margin-bottom: 15px;\">2. 🛠️ 实战准备：Flask后端的简单配置</h2>\n<p>为了让前端Fetch能顺利与后端“对话”，我们需要一个能处理JSON、并能进行跨域资源共享（CORS）的Flask应用。首先，安装必要库：</p>\n<pre class=\"language-python highlighter-hljs\"><code>pip install flask flask-cors</code></pre>\n<p>接着，搭建一个基础的后端服务：</p>\n<pre class=\"language-python highlighter-hljs\"><code>from flask import Flask, request, jsonify\nfrom flask_cors import CORS\n\napp = Flask(__name__)\nCORS(app)  # 允许前端跨域请求，开发时非常方便\n\n# 我们将在后续场景中逐步填充这个app的路由\nif __name__ == '__main__':\n    app.run(debug=True)</code></pre>\n<h2 style=\"font-size: 20px; font-weight: bold; color: rgba(44, 62, 80, 1); margin-top: 35px; margin-bottom: 15px;\">3. 🔐 场景一：登录表单提交与页面重定向</h2>\n<p>传统表单提交会刷新页面，体验割裂。使用Fetch，我们可以实现无刷新登录，并根据后端指令进行前端路由跳转。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">前端 (JavaScript)</strong>：拦截表单提交事件，使用Fetch发送数据。</p>\n<pre class=\"language-javascript highlighter-hljs\"><code>document.getElementById('loginForm').addEventListener('submit', function(event) {\n    event.preventDefault(); // 阻止表单默认提交行为\n\n    const formData = new FormData(this);\n    // 或者将数据转换为JSON: JSON.stringify(Object.fromEntries(formData))\n\n    fetch('/api/login', {\n        method: 'POST',\n        body: formData, // 发送FormData对象\n        // headers: { 'Content-Type': 'application/json' }, // 如果发送JSON需设置此header\n    })\n    .then(response =&gt; response.json()) // 解析后端返回的JSON\n    .then(result =&gt; {\n        if (result.success) {\n            // 登录成功，使用前端路由跳转，而非后端重定向\n            window.location.href = result.redirect_url || '/dashboard';\n        } else {\n            // 登录失败，动态更新页面上的错误提示元素\n            document.getElementById('error-msg').textContent = result.message;\n        }\n    })\n    .catch(error =&gt; console.error('Error:', error));\n});</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">后端 (Flask)</strong>：验证数据，返回包含状态和指令的JSON，而不是直接返回重定向的HTML。</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.route('/api/login', methods=['POST'])\ndef login():\n    username = request.form.get('username')\n    password = request.form.get('password')\n\n    # 这里应是你的验证逻辑，例如查询数据库\n    if username == 'admin' and password == 'secret':\n        # 返回成功状态和前端跳转地址\n        return jsonify({'success': True, 'redirect_url': '/dashboard'})\n    else:\n        # 返回失败状态和错误信息\n        return jsonify({'success': False, 'message': '用户名或密码错误'}), 401</code></pre>\n<h2 style=\"font-size: 20px; font-weight: bold; color: rgba(44, 62, 80, 1); margin-top: 35px; margin-bottom: 15px;\">4. ✨ 场景二：动态新增与修改数据</h2>\n<p>在管理系统中，新增或修改一条数据后，我们希望列表能立即更新，而无需刷新整个页面。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">核心思路</strong>：Fetch请求成功后，在<code>.then()</code>中根据后端返回的最新数据，直接操作DOM更新UI。</p>\n<pre class=\"language-javascript highlighter-hljs\"><code>// 假设有一个保存按钮，用于提交新增或修改的数据\nsaveButton.addEventListener('click', () =&gt; {\n    const itemData = { title: '新项目', status: 'active' };\n\n    fetch('/api/items', {\n        method: 'POST', // 新增用POST，修改可能是PUT或PATCH\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(itemData)\n    })\n    .then(response =&gt; response.json())\n    .then(newItem =&gt; {\n        // 关键步骤：请求成功后，动态更新前端列表\n        const itemList = document.getElementById('itemList');\n        const newItemElement = document.createElement('li');\n        newItemElement.id = `item-${newItem.id}`;\n        newItemElement.innerHTML = `${newItem.title} ${newItem.status}`;\n        itemList.appendChild(newItemElement);\n\n        // 或者，如果是修改操作，可以找到对应的DOM元素更新其内容\n        // const oldItemElement = document.getElementById(`item-${newItem.id}`);\n        // oldItemElement.innerHTML = ...;\n\n        alert('操作成功！'); // 或更优雅的提示\n    });\n});</code></pre>\n<p>对应的Flask后端需要返回创建或更新后的完整数据对象，以便前端使用。</p>\n<h2 style=\"font-size: 20px; font-weight: bold; color: rgba(44, 62, 80, 1); margin-top: 35px; margin-bottom: 15px;\">5. 📦 场景三：处理不同类型的响应数据</h2>\n<p>后端可能返回JSON，也可能返回纯文本或HTML片段。Fetch的Response对象提供了不同的方法来处理。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">处理JSON (最常用)</strong>：如上文所示，使用<code>response.json()</code>。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">处理文本</strong>：例如后端返回一个简单的成功消息或CSV数据。</p>\n<pre class=\"language-javascript highlighter-hljs\"><code>fetch('/api/export')\n  .then(response =&gt; response.text())\n  .then(textData =&gt; {\n    console.log(textData);\n    // 处理文本数据...\n  });</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">检查响应状态</strong>：在解析数据前，先检查请求是否真正成功是个好习惯。</p>\n<pre class=\"language-javascript highlighter-hljs\"><code>fetch('/api/some-data')\n  .then(response =&gt; {\n    if (!response.ok) { // 检查HTTP状态码是否在200-299之间\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json(); // 状态正常才解析JSON\n  })\n  .then(data =&gt; /* 处理数据 */)\n  .catch(error =&gt; /* 处理网络错误或状态码错误 */);</code></pre>\n<h2 style=\"font-size: 20px; font-weight: bold; color: rgba(44, 62, 80, 1); margin-top: 35px; margin-bottom: 15px;\">6. 💻 完整代码参考与总结</h2>\n<p>下面是一个整合了登录和新增项目的超简易完整示例：</p>\n<pre class=\"language-python highlighter-hljs\"><code># app.py (Flask后端)\nfrom flask import Flask, request, jsonify\nfrom flask_cors import CORS\n\napp = Flask(__name__)\nCORS(app)\nitems = [] # 用一个简易列表模拟数据库\n\n@app.route('/api/login', methods=['POST'])\ndef login():\n    data = request.get_json()\n    if data.get('user') == 'demo':\n        return jsonify({'success': True, 'token': 'fake-jwt-token'})\n    return jsonify({'success': False}), 401\n\n@app.route('/api/items', methods=['GET', 'POST'])\ndef handle_items():\n    if request.method == 'GET':\n        return jsonify(items)\n    else: # POST\n        new_item = request.get_json()\n        new_item['id'] = len(items) + 1\n        items.append(new_item)\n        return jsonify(new_item), 201\n\nif __name__ == '__main__':\n    app.run(debug=True)</code></pre>\n<pre class=\"language-html highlighter-hljs\"><code>&lt;!-- index.html (部分前端) --&gt;\n&lt;script&gt;\n// 登录\nfetch('/api/login', {\n    method: 'POST',\n    headers: {'Content-Type': 'application/json'},\n    body: JSON.stringify({user: 'demo', pass: 'demo'})\n}).then(r =&gt; r.json()).then(console.log);\n\n// 新增项目并更新列表\nfetch('/api/items', {\n    method: 'POST',\n    headers: {'Content-Type': 'application/json'},\n    body: JSON.stringify({name: 'New Task'})\n})\n.then(r =&gt; r.json())\n.then(newItem =&gt; {\n    const list = document.getElementById('list');\n    list.innerHTML += `&lt;li&gt;${newItem.id}: ${newItem.name}&lt;/li&gt;`;\n});\n&lt;/script&gt;</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">总结一下</strong>：Fetch + Flask 的组合，通过“请求-响应-JSON”的模式，将前后端解耦，让Web交互变得<strong style=\"color: rgba(186, 55, 42, 1);\">更加动态和高效</strong>。<br />关键在于：前端负责交互和UI更新，后端负责数据和逻辑，两者通过清晰的API契约进行通信。</p>\n<div style=\"text-align: center; margin: 40px 0;\"><hr style=\"border-right: none; border-bottom: none; border-left: none;\" /></div>\n<p style=\"font-size: 15px; color: rgba(85, 85, 85, 1); text-align: center;\">喜欢本文？不要错过✨，点赞👍收藏⭐关注我👆，一起学习更多有用的知识，完善你我的技能树！也请路过的大佬给些建议和指教🙏🐶！</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 08:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">曲幽</a>&nbsp;\n阅读(<span id=\"post_view_count\">24</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程四：计算机视觉 第四周：卷积网络应用 (一) 人脸识别",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19418306",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19418306\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 23:52\">\n    <span>吴恩达深度学习课程四：计算机视觉 第四周：卷积网络应用 (一) 人脸识别</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第四课的第四周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=140\" rel=\"noopener nofollow\" target=\"_blank\">4.1</a>到<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=144\" rel=\"noopener nofollow\" target=\"_blank\">4.5</a>的内容。</p>\n<hr />\n<p>本周为第四课的第四周内容，这一课所有内容的中心只有一个：<strong>计算机视觉</strong>。应用在深度学习里，就是专门用来进行图学习的模型和技术，是在之前全连接基础上的“特化”，也是相关专业里的一个重要研究大类。<br />\n<strong>这一整节课都存在大量需要反复理解的内容和机器学习、数学基础。</strong> 因此我会尽可能的补足基础，用比喻和实例来演示每个部分，从而帮助理解。<br />\n第四周的内容是对前三周内容的综合应用，介绍了一些通过卷积网络实现的实际应用，它们在使用卷积网络的基础上又各有自己的特点来匹配不同的任务要求，是对<strong>如何真实应用卷积网络</strong>的良好演示。<br />\n本篇的内容关于<strong>人脸识别</strong>。</p>\n<h1 id=\"1-人脸验证与人脸识别\">1. 人脸验证与人脸识别</h1>\n<p>人脸验证和人脸识别是两个相似的概念。<br />\n而在人脸识别系统中，我们说<strong>人脸验证是人脸识别的一个基本模块</strong>。<br />\n现在就来展开一下二者的关系：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234636631-73929260.png\" /><br />\n我们在图里提到<strong>人脸验证是一个1对1问题</strong>，这是因为在假定验证器完全准确的情况下，它只会对一个人说 “Yes” 而拒绝其他所有人。<br />\n很显然，这种逻辑在我们实际生活中的大多场景都不适用，公司、宿舍的门禁等都支持通过一个模型识别多个人。而不是为每个人单独设置一个闸机。<br />\n因此，我们便称这种<strong>实现“1对多”逻辑的相应任务为人脸识别</strong>。<br />\n按照刚才的逻辑推下去，一个很自然、也很“机器学习直觉”的想法是：<strong>那人脸识别不就是一个多分类问题吗？</strong> 像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234219889-112044451.png\" /><br />\n但如果在实际部署中这样实现人脸识别，你会发现这样一些问题：</p>\n<ol>\n<li>如果单位有新员工加入或老员工离职，就要<strong>重新调整数据和网络输出层，重新训练</strong>。</li>\n<li>当单位规模较大时，数据可能包含<strong>成千上万个类别</strong>。更重要的是，每个类别数据量很少，而深度学习往往又依赖于<strong>数据量</strong>，难道办理入职要先拍几百几千张照片吗？</li>\n</ol>\n<p>因此，我们得出结论：因为人脸识别任务在实际部署中的特殊性，让我们之前了解的常规<strong>分类算法并不适用</strong>作为一个可持续部署方案对其应用。</p>\n<p>而在现实生活中，你会发现，我们在相关系统录入人脸时，<strong>往往只需要一张证件照即可</strong>，这是怎么做到的呢？我们继续。</p>\n<h1 id=\"2-一次学习one-shot-learning\">2. 一次学习（one-shot learning）</h1>\n<p>继续刚刚的内容，我们会发现一个看似矛盾的现象：<br />\n在实际的人脸系统中，录入一个新用户时，<strong>往往只需要一张证件照</strong>。但在深度学习的经验认知里，模型性能又高度依赖数据量。  <strong>这两点，不冲突吗？</strong></p>\n<p>要理解这一点，我们需要先回到刚才“把人脸识别当作多分类问题”的思路。<br />\n在标准的多分类任务中，<strong>分类标签本身就为数据划分了明确的边界</strong>：模型只能通过<strong>同一标签下的样本</strong>来学习该类别的特征，而不同类别之间的数据是被严格隔离使用的。<br />\n正因为如此，如果将人脸识别直接建模为“每个人一个类别”，那么模型要学好某一个人的特征，就必然需要<strong>大量属于这个人的样本</strong>——也就出现了“要给每个人拍写真集”的不现实要求。</p>\n<p>但是，你会发现：在人脸识别任务中，<strong>总的数据量其实并不少</strong>，真正稀缺的只是“每个身份对应的样本数量”。这意味着，并不是“数据不够”，而是<strong>数据被标签强行分割后，无法被充分利用</strong>。</p>\n<p>正是由于这种设置与实际部署场景不匹配，我们自然会产生一个新的疑问：<strong>能不能让所有人的样本都参与学习，而不是被身份标签各自隔离开来？</strong></p>\n<p>在机器学习中，这类“<strong>每个类别只有极少样本</strong>”的问题被称为<strong>一次学习（one-shot learning）问题</strong>。<br />\n而在具体的人脸识别场景下，<strong>one-shot 人脸识别</strong>指的是：每个身份在训练或建库阶段，仅提供一张（或极少几张）已知人脸样本。</p>\n<p>为了解决这种“<strong>总体样本量很大，但单个身份样本极少</strong>”的矛盾，人们提出了一种不同于传统分类的思路：  <strong>不再让模型回答“这张脸属于所有人中的哪一个？”，而是让它判断“这张脸是否和某一个已知的某张脸足够相似？”</strong></p>\n<p>现在，网络目标就从一开始的“学习分类”变成了“<strong>学相似度</strong>”，就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234253679-642676291.png\" /><br />\n如果如图中这样，网络实现了“<strong>学习两张人脸的相似度</strong>“，我们就解决了刚刚的问题：</p>\n<ol>\n<li>如果单位有新员工加入或老员工离职，就要不再需要调整网络和重新训练，<strong>只需要把相应数据加入数据库或从数据库中删除</strong>。</li>\n<li>所有的数据都被充分利用，同时每人只需要一张证件照，在门禁时人脸和数据库中的人脸对比，<strong>找到满足相似度阈值的样本即通过，不存在即拒绝。</strong></li>\n</ol>\n<h1 id=\"3-siamese-网络\">3. Siamese 网络</h1>\n<p>现在，我们明确了针对面部识别任务的目标：<strong>训练一个可以学习两张人脸相似度的网络</strong>。<br />\n现在，要怎么实现这一点呢？<br />\n答案就是这部分的标题：Siamese 网络。<br />\n要说明的是，吴恩达老师在课程里提到了一篇 2014 年的论文 <a href=\"https://www.cv-foundation.org/openaccess/content_cvpr_2014/papers/Taigman_DeepFace_Closing_the_2014_CVPR_paper.pdf?utm_source=chatgpt.com\" rel=\"noopener nofollow\" target=\"_blank\">DeepFace: Closing the Gap to Human-Level Performance in Face Verification</a>。<strong>但 Siamese 网络并不是从这篇论文才提出的</strong>——早在 1993 年，它就被发明出来，用于判断两幅手写签名是否同一人。后来也被应用到人脸识别任务中。<br />\nSiamese 网络的核心思路是<strong>通过共享权重的双分支（或多分支）神经网络，将输入的两张图像映射到同一特征空间，然后通过度量函数（如欧氏距离或余弦相似度）计算它们的相似度</strong>。<br />\nDeepFace 借鉴了 Siamese 网络的思路，在深度 CNN 上直接学习人脸特征的相似度，并通过优化和大规模训练，这才使得<strong>系统性能接近人类水平，真正具备部署价值</strong>。</p>\n<p>现在，就来详细看看一个较完善的 Siamese 网络的运行过程：</p>\n<h2 id=\"31-对图像进行编码处理三元组损失triplet-loss\">3.1 对图像进行编码处理：三元组损失（triplet loss）</h2>\n<p>我们先来看看什么叫对图像进行编码处理：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234657431-1853718024.png\" /><br />\n这样，我们就可以使用一组特征向量来编码一张人脸，实际上，这就是 DeepFace 提出的一步优化，这一步设置<strong>不止为了计算相似度作准备，同时也极大减少了计算量，缩短了运行时间</strong>，可以说相当成功。</p>\n<p>但是，同样也是因为这一步编码，新的问题出现了：<strong>你会发现，这个用来把图像转换成编码的网络同样需要训练。</strong><br />\n没错，我们需要训练这个网络，而目标就是：<strong>让同一个身份的人脸编码差异最小化，不同身份的人脸的编码差异最大化。</strong><br />\n要实现这个目标的常用方法叫做<strong>三元组（triplet）损失</strong>，这时，<strong>网络在训练阶段需要同时输入三张图像</strong>。<br />\n它的公式长这个样：</p>\n<p></p><div class=\"math display\">\\[L=max⁡(0,∥f(a)−f(p)∥^2_2−∥f(a)−f(n)∥^2_2+α)\n\\]</div><p></p><p>其中：</p>\n<ul>\n<li><span class=\"math inline\">\\(f(a)\\)</span>：anchor（基准图像）映射后的特征向量</li>\n<li><span class=\"math inline\">\\(f(p)\\)</span>：positive（同一身份的图像）映射后的特征向量</li>\n<li><span class=\"math inline\">\\(f(n)\\)</span>：negative（不同身份的图像）映射后的特征向量</li>\n<li><span class=\"math inline\">\\(\\alpha\\)</span>：间隔（margin），保证不同身份的距离比同一身份距离至少大 <span class=\"math inline\">\\(\\alpha\\)</span></li>\n</ul>\n<p>别慌，我们用一个例子来演示一遍原理：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229235145998-454139387.png\" /></p>\n<p><img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234301253-442526298.png\" /><br />\n只看符号可能有些太绕了，<strong>我们再来看一个实例</strong>：<br />\n假设三张人脸图像：经过网络映射后的二维特征向量如下：</p>\n<table>\n<thead>\n<tr>\n<th>图像</th>\n<th>特征向量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a (Alice)</td>\n<td>[1.0, 1.0]</td>\n</tr>\n<tr>\n<td>p (Alice)</td>\n<td>[1.2, 1.1]</td>\n</tr>\n<tr>\n<td>n (Bob)</td>\n<td>[2.5, 2.0]</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"1计算欧氏距离\">（1）计算欧氏距离</h4>\n<p><strong>Anchor 与 Positive（同一人）</strong>：</p>\n<p></p><div class=\"math display\">\\[∥f(a)-f(p)∥_2^2 = (1.0-1.2)^2 + (1.0-1.1)^2 = 0.04 + 0.01 = 0.05  \n\\]</div><p></p><p><strong>Anchor 与 Negative（不同人）</strong>：</p>\n<p></p><div class=\"math display\">\\[∥f(a)-f(n)∥_2^2 = (1.0-2.5)^2 + (1.0-2.0)^2 = 2.25 + 1.0 = 3.25  \n\\]</div><p></p><h4 id=\"2代入三元组损失公式\">（2）代入三元组损失公式</h4>\n<p>假设 <span class=\"math inline\">\\(\\alpha = 0.5\\)</span>，代入数值：</p>\n<p></p><div class=\"math display\">\\[L = \\max\\Big(0,0.05 - 3.25 + 0.5\\Big) = \\max(0, -2.7) = 0  \n\\]</div><p></p><p>代表当前特征向量满足目标，同一人距离接近，不同人距离大于 <span class=\"math inline\">\\(\\alpha\\)</span>。</p>\n<h4 id=\"3如果-negative-太近\">（3）如果 Negative 太近</h4>\n<p>假设 <span class=\"math inline\">\\(f(n) = [1.5, 1.3]\\)</span>，计算距离：</p>\n<p></p><div class=\"math display\">\\[∥f(a)-f(n)∥_2^2 = (1.0-1.5)^2 + (1.0-1.3)^2 = 0.25 + 0.09 = 0.34  \n\\]</div><p></p><p>损失为：</p>\n<p></p><div class=\"math display\">\\[L = \\max\\Big(0, 0.05 - 0.34 + 0.5\\Big) = \\max(0, 0.21) = 0.21  \n\\]</div><p></p><p>便说明不同人距离太近，网络需要更新，保留损失来进行反向传播。</p>\n<p><strong>通过这种设计，网络可以直接学习一个适合度量相似度的特征空间。</strong></p>\n<p>最后要强调的一点是，为了让训练效果更好，<strong>我们在选择三元组时，会尽量让基准图像和同一人的图像差别尽可能大，同时让基准图像和不同人的图像差别尽可能小。</strong><br />\n这就像是在手动提高考试难度，难题会了，简单题自然不在话下。<br />\n现在，我们便继续下一部分。</p>\n<h2 id=\"32-正向传播两幅图像并计算相似度\">3.2 正向传播两幅图像并计算相似度</h2>\n<p>在拥有了可以对图像进行合适编码的网络后，我们便可以进行相似度计算的应用，这一步的过程是这样的：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234408230-256446436.png\" /><br />\n如图所示，我们通过正向传播得到两幅输入人脸的编码，并根据编码计算相似度，自然就可以根据阈值判断两张人脸是否属于同一个人。<br />\n而且，这种传播和计算相似度分离的设计，代表<strong>我们可以提前为数据库中的图像计算好编码</strong>，只需刷脸时传入的人脸单独传播得到编码后进行计算就好了，这大大提高了可部署性。</p>\n<h2 id=\"33-拓展另一种训练编码网络的方式\">3.3 拓展：另一种训练编码网络的方式</h2>\n<p>我们刚刚介绍了可以通过三元组损失来训练编码网络，但你可能也发现了，这个方法在数据准备阶段较为复杂。<br />\n因此，吴恩达老师还介绍了另一种训练方法：<strong>更改标签，让Siamese 网络后接逻辑回归变为二分类问题。</strong><br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234243543-574274696.png\" /><br />\n这样，我们就又把人脸识别问题又转换回了二分类问题，通过反向传播来进行训练。<br />\n但是，你会发现，<strong>当新员工加入时，还是要重新训练模型。</strong><br />\n因此，实际上这种方式的实际部署价值并不如使用三元组损失。</p>\n<h1 id=\"4总结\">4.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>人脸验证（Face Verification）</td>\n<td>1 对 1 问题，判断输入人脸是否与目标身份匹配</td>\n<td>就像门卫只对某个人说“可以进”，其他人全部拒绝</td>\n</tr>\n<tr>\n<td>人脸识别（Face Recognition）</td>\n<td>1 对多问题，通过模型识别输入人脸属于哪一个已知身份</td>\n<td>门禁系统识别多个员工，不需要单独为每个人设闸机</td>\n</tr>\n<tr>\n<td>多分类建模问题</td>\n<td>将每个人作为一个类别进行训练</td>\n<td>每个员工都有一本写真集，要学会区分成千上万本</td>\n</tr>\n<tr>\n<td>一次学习（One-Shot Learning）</td>\n<td>每个身份仅提供极少样本，通过相似度判断识别</td>\n<td>只需一张证件照就能识别新员工，不用拍写真集</td>\n</tr>\n<tr>\n<td>Siamese 网络</td>\n<td>共享权重的双分支（或多分支）网络，将图像映射到同一特征空间，通过度量函数计算相似度</td>\n<td>同时看两张照片，然后比较相似度</td>\n</tr>\n<tr>\n<td>三元组损失（Triplet Loss）</td>\n<td>训练网络使同一人距离最小，不同人距离最大，网络需输入三张图像（anchor, positive, negative）</td>\n<td>提高考试难度：基准题和相似题差别小，不同题差别大，训练更有效</td>\n</tr>\n<tr>\n<td>正向传播两图计算相似度</td>\n<td>已训练网络对两幅图像编码后，计算特征距离或相似度，用阈值判断是否同一人</td>\n<td>先把照片编码成“身份特征卡片”，刷脸时只比对卡片</td>\n</tr>\n<tr>\n<td>Siamese + 逻辑回归二分类</td>\n<td>将两张图像输入 Siamese 网络，通过逻辑回归判断是否同一人</td>\n<td>将人脸识别问题简化成“是/不是同一人”的选择题</td>\n</tr>\n<tr>\n<td>部署可行性对比</td>\n<td>三元组损失支持 one-shot、可提前计算数据库特征向量，泛化强；逻辑回归方式新身份需重新训练，泛化差</td>\n<td>三元组：考试考通用能力；逻辑回归：考试只会答已有题目</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 23:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">59</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Python os库 os.walk使用（详细教程、带实践）",
      "link": "https://www.cnblogs.com/io-T-T/p/19418274",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/io-T-T/p/19418274\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 23:19\">\n    <span>Python os库 os.walk使用（详细教程、带实践）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Python os库 os.walk使用（详细教程、带实践）\nos.walk 处理文件\nos.walk原理\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"python-os库-oswalk使用详细教程带实践\">Python os库 os.walk使用（详细教程、带实践）</h2>\n<p>-----------------------<em><strong>PS：env python version==3.10</strong></em>----------------</p>\n<p>简介：</p>\n<p>​\t本文以实际案例说明<code>os.walk</code>对文件的使用方式。主要教学内容：</p>\n<ul>\n<li><code>os.walk</code>库实际的使用</li>\n<li><code>os.walk</code>最佳实践</li>\n<li><em>（可选）os.walk原理</em></li>\n<li><em>（可选）迭代器方向理解</em></li>\n</ul>\n<p>全文2000字左右，代码字数800（含迭代器180）左右，建议学习时间10-15min（不含迭代器）。若学习迭代器建议30min+</p>\n<h3 id=\"1-模拟实际使用环境\">1 模拟实际使用环境</h3>\n<p>​\tPS：仅作为案例说明参考，若已有可用的文件夹/目录，请移步第二步</p>\n<p>​\t<img alt=\"image-20251222214254412\" class=\"lazyload\" /></p>\n<ol>\n<li>\n<p>根据上图模拟实际使用情况：</p>\n<ul>\n<li>\n<p>随意新建一个目录（确保不会有其他文件）</p>\n</li>\n<li>\n<p>在（新建目录的）根目录创建一个<strong>文件</strong>和<strong>文件夹</strong>（名称随意，也可以参照我的样例来）</p>\n</li>\n<li>\n<p>进入<code>root</code>文件夹，新建两个次级文件夹（<code>dir1</code>、<code>dir2</code>）</p>\n<ul>\n<li>root文件夹下直接创建次级目录文件<code>F1.txt</code></li>\n<li>创建次级目录文件<code>dir1</code>、<code>dir2</code>\n<ul>\n<li>进入<code>dir2</code>文件夹\n<ul>\n<li>创建文件（<code>F2.txt</code>）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-解析oswalk函数\">2 解析<code>os.walk</code>函数</h3>\n<p>面向基础讲解，详细见 <a href=\"https://docs.python.org/zh-cn/3.10/library/os.html?highlight=os%20walk#os.walk\" rel=\"noopener nofollow\" target=\"_blank\">os.walk官方说明</a></p>\n<ul>\n<li>\n<p>什么是 python 的<code>os</code>库</p>\n<ul>\n<li>本模块提供了一种使用与操作系统相关的功能的便捷式途径。（如文件路径控制、文件信息获取、遍历目录文件【<code>os.walk</code>】、其他系统调用功能）</li>\n</ul>\n</li>\n<li>\n<p><code>os.walk</code>函数讲解：</p>\n<p><code>os.walk</code>(<strong><em>top</em>, <em>topdown=True</em>,</strong> <em>onerror=None</em>, <em>followlinks=False</em>)</p>\n<ul>\n<li>\n<p>主要聚焦于前两个参数即可：</p>\n<ul>\n<li><code>top</code>：根目录路径（str）</li>\n<li><code>topdown</code>：自上而下模式，默认（<code>True</code>）为自上而下遍历，<code>False</code>则从底向上遍历</li>\n</ul>\n</li>\n<li>\n<p>返回值：</p>\n<ul>\n<li>\n<p>返回迭代器 ，迭代器每次生成的对象为：<code>(dirpath, dirnames, filenames)</code></p>\n<p><code>dirpath</code>： 当前文件夹路径</p>\n<p><code>dirnames</code>：文件夹名称</p>\n<p><code>filenames</code>：文件名称</p>\n</li>\n<li>\n<p>如果不理解迭代器，可以暂时理解为os.walk返回了 元组 <code>(dirpath, dirnames, filenames)</code>的列表，类似于下文 (省略双引号):</p>\n<pre><code class=\"language-python\">[\n\t(C:/user/, [root],[rott_text.txt] ),\t\t#根目录\n\t(C:/user/root, [dir1,dir2],[F1.txt] ),\t\t#进入root文件夹\n\t(C:/user/root/dir1, [],[] ),\t\t\t\t#进入dir1文件夹\n\t(C:/user/root/dir2, [],[F2.txt] )\t\t\t#dir1中没有文件了，退回上一层级，进入dir2文件夹中\n    #读取所有文件/文件名完毕，\n]\n</code></pre>\n<p>只不过他生成的特殊“列表”经常适用于for，不能直接作为列表打印，直接打印是这样子的：</p>\n<pre><code class=\"language-bash\">#code\ndir_path = r'your_dir'\t\t\t\t\t\t#替换为你的文件夹\ndirpath, dirnames, filenames = os.walk(dir_path)\nprint(f'dir_path:{dirpath}\\ndir_name:{dirnames}\\nfile_names:{filenames}')\n\n#result：\n\tdirpath, dirnames, filenames = os.walk(dir_path)\nValueError: too many values to unpack (expected 3)\n</code></pre>\n<p>究其原因是返回的单个迭代器，并非三个列表元组，喜欢细究这部分的见后文，简要的话知道不能直接调用，一般结合<code>for</code>调用就好，这个并非深度挖掘，看完后面会看可能有更好的理解。</p>\n<p>迭代器学习建议：<a href=\"https://www.bilibili.com/video/BV1jt421c7yN/?\" rel=\"noopener nofollow\" target=\"_blank\">【Python】从迭代器到生成器：小内存也能处理大数据</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-调用样例\">3 调用样例：</h3>\n<p>前面参数有点不好理解也没关系，只要大概知道就好了，下面是实际函数使用</p>\n<ol>\n<li>先复制下面代码至新py文件，改一下 <code>dir_path</code>运行一下体会一下</li>\n</ol>\n<pre><code class=\"language-python\">import os\n\ndef walk_example(dir_path:str):\n    #os.walk 返回类似于三元组列表结构，然后进行遍历\n    for root, dir_names, file_names in os.walk(dir_path):   #(dirpath, dirnames, filenames)\n        print(f'dirpath :{root}')\n        print(f'dir_names :{dir_names}')\n        print(f'file_names:{file_names}')\n        print('-'*50)\n\n\nif __name__ == '__main__':\n    dir_path = r'your_dir_path'\n    walk_example(dir_path)\n</code></pre>\n<ol start=\"2\">\n<li>\n<p>输出结果：</p>\n<img alt=\"image-20251222223407130\" class=\"lazyload\" />\n<p>这里可以看出（默认状态下），是从顶向下，一层层遍历。</p>\n<blockquote>\n<p>dirpath : <code>x:\\your_path\\walk</code></p>\n<p>dir_names :['root']<br />\nfile_names:['root_text.txt']</p>\n</blockquote>\n<ul>\n<li>这里是根目录中出现的文件夹名称(root)、文件('root_text.txt')</li>\n</ul>\n<blockquote>\n<p>dirpath :<code>x:\\your_path\\walk\\root</code><br />\ndir_names :['dir1', 'dir2']<br />\nfile_names:['F1.txt']</p>\n</blockquote>\n<ul>\n<li>进入了root文件夹，里面包含<strong>两个文件夹</strong>及当前文件夹根目录下的<strong>单个文件</strong>\n<ul>\n<li>后面两个同理，主要是感受每一层级的变化，每次进入下一个文件夹时，<code>root</code><strong>所表达的属性都会有所变化</strong>，变成了当前根路径。</li>\n<li>除此之外，可以看到，4项的<code>dir_name</code>输出，刚好是我们<strong>全部</strong>的目录名称，<code>file_names</code>同理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>从上文，可以看出 <code>os.walk</code>函数的遍历结果会根据深入的层级输出以下信息：</p>\n<ul>\n<li>当前文件路径（str）</li>\n<li>存在的文件夹（list）</li>\n<li>存在的文件（list）</li>\n</ul>\n<p>把他们聚合起来，就能获取我们所需要的：</p>\n<ul>\n<li>提取文件夹信息（或处理）</li>\n<li>提取文件信息（或处理）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-实际运用案例最佳实践\">4 实际运用案例（最佳实践）</h3>\n<p>本小节会从以下几点来说明如何通过<code>os.walk</code>进行文件的提取及处理。</p>\n<ul>\n<li>提取全部信息（文件夹、文件）【理解调用方式】</li>\n<li>构造文件夹中，所有文件的路径</li>\n<li>根据关键字提取（文件/文件夹）路径</li>\n</ul>\n<h4 id=\"41-提取全部信息文件夹文件理解调用方式\">4.1 提取全部信息（文件夹、文件）【理解调用方式】</h4>\n<p>​\t很简单，只要把对应全部输出收集起来，就能获得我们需要的全文件名、文件信息了。</p>\n<pre><code class=\"language-python\">def walk_get_all_info(dir_path:str):\n    '''\n    获取所有文件名、文件信息\n    :param dir_path: 输入文件夹路径\n    '''\n    dir_list = []\n    file_list = []\n    for root, dirnames, files in os.walk(dir_path):\n        for dir_name in dirnames:\n            dir_list.append(dir_name)\n            # print(dir_name)\t\t\t\t\t#不理解可以调试来一下理解一下，两者是相互独立的\n        for file in files:\n            file_list.append(file)\n            # print(file)\n    print(dir_list)\n    print(file_list)\nif __name__ == '__main__':\n    dir_path = r'your_path'\n    walk_get_all_info(dir_path)\n</code></pre>\n<p>​\t输出：</p>\n<blockquote>\n<p>root<br />\nroot_text.txt<br />\ndir1<br />\ndir2<br />\nF1.txt<br />\nF2.txt</p>\n</blockquote>\n<h4 id=\"42-构造文件夹中所有文件的路径\">4.2 构造文件夹中，所有文件的路径</h4>\n<p>​\t通过<strong>4.1</strong> 我们知道了<code>os.walk</code>的迭代方式。可以通过“当前根目录”与 “所需文件名称”相结合，从而遍历所有文件的路径。</p>\n<pre><code class=\"language-python\">def walk_get_file_path(dir_path:str):\n    '''\n    获取文件路径\n    :param dir_path: 输入文件夹路径\n    '''\n\n    file_list = []\n    for root, dirnames, files in os.walk(dir_path):\n        print(f'local root path :{root}')\n        for file in files:\n            file_path = os.path.join(root, file)        #window 上，等价于 root + \"\\\\\" + file\n            # file_path = root + \"\\\\\" + file\n            print(f'file path :{file_path}')\n            file_list.append(file_path)\n        print('-'*50)\n    print(file_list)\n</code></pre>\n<h4 id=\"43-根据关键字提取文件路径\">4.3 根据关键字提取文件路径</h4>\n<p>​\t这里以最简单的关键字提取，即 <code>if keyword in file</code>为例。</p>\n<pre><code class=\"language-python\">def filter_by_key_word(dir_path,key_word:str='F1'):   \n    '''\n    文件夹路径以关键字，递归查找符合关键字的文件\n    :param dir_path: 输入根文件夹\n    :param key_word: 关键字\n    '''\n    res:list = []\n    for root, dirnames, files in os.walk(dir_path):\n        for file in files:\n            if key_word in file:\n                res.append(\n                    os.path.join(root, file)\n                )\n    print(res)\n    return\n</code></pre>\n<p>按照预期，就应该输出<code>F1</code>：</p>\n<blockquote>\n<p>['E:\\walk\\root\\F1.txt']</p>\n</blockquote>\n<p>更改关键字，也可以做到筛选不同文件的功能，可以自己改一下。对<code>files</code>迭代改为对<code>dirname</code>迭代，一样能完成对文件夹的关键字提取，可以尝试一下</p>\n<h4 id=\"44-其他运用\">4.4 其他运用</h4>\n<p>​\t能找到文件地址，后续就可以按照你想处理的方式对文件进行处理了，这个根据各自需要进行扩展就好，教程结束。</p>\n<h3 id=\"5-部分代码\">5. 部分代码：</h3>\n<pre><code class=\"language-python\">import os\n\ndef walk_example(dir_path:str):\n\t\n    # walk_iter = os.walk(dir_path)\n    # print(walk_iter.__next__())\n\n\n    for root, dir_names, file_names in os.walk(dir_path):   #(dirpath, dirnames, filenames)\n        print(f'dirpath :{root}')\n        print(f'dir_names :{dir_names}')\n        print(f'file_names:{file_names}')\n        print('-'*50)\n\n\ndef walk_get_file_path(dir_path:str):\n    '''\n    获取文件路径\n    :param dir_path: 输入文件夹路径\n    '''\n\n    file_list = []\n    for root, dirnames, files in os.walk(dir_path):\n        print(f'local root path :{root}')\n        for file in files:\n            file_path = os.path.join(root, file)        #window 上，等价于 root + \"\\\\\" + file\n            # file_path = root + \"\\\\\" + file\n            print(f'file path :{file_path}')\n            file_list.append(file_path)\n        print('-'*50)\n    print(file_list)\n    return\n\ndef filter_by_key_word(dir_path,key_word:str='F1'):\n    '''\n    文件夹路径以关键字，递归查找符合关键字的文件\n    :param dir_path: 输入根文件夹\n    :param key_word: 关键字\n\n    '''\n    res:list = []\n    for root, dirnames, files in os.walk(dir_path):\n        for file in files:\n            if key_word in file:\n                res.append(\n                    os.path.join(root, file)\n                )\n    print(res)\n    return\n\nif __name__ == '__main__':\n    dir_path = r'your_path'\n    # walk_example(dir_path)\n    # walk_get_file_path(dir_path)\n    filter_by_key_word(dir_path)\n</code></pre>\n<h3 id=\"6-迭代器相关非必须\">6 迭代器相关（非必须）</h3>\n<p>​\t建议先去学习一下什么是迭代器，再看这个演示代码，对<code>os.walk</code>理解会更深，这边还是建议学一下的，如果够时间的话，趁学os.walk多学一个迭代器/生成器，何乐而不为呢，函数讲解塞里面了，就这样吧。</p>\n<pre><code class=\"language-python\">def iter_example(dir_path:str):\n    '''\n    迭代器理解代码\n    :param dir_path:\n    '''\n    #我没记错的话，是要有__next__ 和 __iter__ 类方法，才能是迭代器类\n    walk_iter = os.walk(dir_path)\n    print(walk_iter.__next__())         #获取迭代器的下一个元素，一般都用next访问下一个元素\n    print(walk_iter.__iter__())         #获取迭代器本身，这里os.walk返回的是generator object，本质上也是迭代器，不太能获取当前迭代器的元素噢！\n    print(next(walk_iter))              #相同写法\n    print('#'*25+\"分隔符\"+'#'*25)\n    count = 0\n    while True:\n        count += 1\n        try:\n            print(f'next element:{walk_iter.__next__()}')\n            print(\"-\"*50 + f\"{count}\")\n        except Exception as e:          #无可迭代对象后，会raise一个StopIteration Error\n            # print('finish iter, break')\n            # break                         #常规循环退出机制\n            raise e\n\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 23:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/io-T-T\">io_T_T</a>&nbsp;\n阅读(<span id=\"post_view_count\">42</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "docker-compose 部署单节点 kafka 4.0 测试环境",
      "link": "https://www.cnblogs.com/apocelipes/p/19417908",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/apocelipes/p/19417908\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 20:34\">\n    <span>docker-compose 部署单节点 kafka 4.0 测试环境</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>高版本kafka已经不再需要ZooKeeper当保姆才能启动了，现在部署一个单机单节点测试环境比原来方便不少。</p>\n<p>不过最常用的<code>bitnami/kafka</code>不再提供免费镜像，导致我们只能用<code>apache/kafka</code>，新镜像的配置会稍微麻烦一些，所以记录一下。</p>\n<p>部署内容：</p>\n<ul>\n<li>单节点kafka服务，版本4.0+</li>\n<li>kafka UI，方便管理，版本用最新的</li>\n<li>开启简单的用户名密码验证</li>\n</ul>\n<p>docker-compose文件：</p>\n<pre><code class=\"language-yaml\">version: '3'\n\nnetworks:\n  kafka-net:\n\nservices:\n  kafka:\n    image: apache/kafka:latest\n    container_name: kafka\n    networks:\n      - kafka-net\n    ports:\n      - \"9092:9092\"\n    volumes:\n      - ./kafka_data:/var/lib/kafka/data\n      - ./kafka_server_jaas.conf:/etc/kafka/kafka_server_jaas.conf # 配置用户名密码\n    environment:\n      KAFKA_NODE_ID: 1\n      KAFKA_PROCESS_ROLES: 'broker,controller'\n      KAFKA_CONTROLLER_QUORUM_VOTERS: '1@localhost:9093'\n      KAFKA_CONTROLLER_LISTENER_NAMES: 'CONTROLLER'\n      \n      # 定义监听器：EXTERNAL(9092) 走 SASL 认证，PLAINTEXT(29092) 给容器内用（这里也改为 SASL 确保安全）\n      KAFKA_LISTENERS: 'SASL_PLAINTEXT://0.0.0.0:29092,EXTERNAL://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093'\n      KAFKA_ADVERTISED_LISTENERS: 'SASL_PLAINTEXT://kafka:29092,EXTERNAL://localhost:9092'\n      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: 'CONTROLLER:PLAINTEXT,SASL_PLAINTEXT:SASL_PLAINTEXT,EXTERNAL:SASL_PLAINTEXT'\n      KAFKA_INTER_BROKER_LISTENER_NAME: 'SASL_PLAINTEXT'\n      \n      # SASL/PLAIN 认证配置\n      KAFKA_SASL_ENABLED_MECHANISMS: 'PLAIN'\n      KAFKA_SASL_MECHANISM_INTER_BROKER_PROTOCOL: 'PLAIN'\n      # 告诉 Kafka 读取我们的 JAAS 文件\n      KAFKA_OPTS: \"-Djava.security.auth.login.config=/etc/kafka/kafka_server_jaas.conf\"\n\n      # 数据持久化\n      KAFKA_LOG_DIRS: '/var/lib/kafka/data'\n\n  kafka-ui:\n    image: provectuslabs/kafka-ui:latest\n    container_name: kafka-ui\n    depends_on:\n      - kafka\n    networks:\n      - kafka-net\n    ports:\n      # 映射到8090，因为8080一般还得挂其他的服务做测试\n      - \"8090:8080\"\n    environment:\n      KAFKA_CLUSTERS_0_NAME: local\n      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:29092\n      # 配置 UI 使用用户名和密码连接 Kafka\n      KAFKA_CLUSTERS_0_PROPERTIES_SECURITY_PROTOCOL: SASL_PLAINTEXT\n      KAFKA_CLUSTERS_0_PROPERTIES_SASL_MECHANISM: PLAIN\n      KAFKA_CLUSTERS_0_PROPERTIES_SASL_JAAS_CONFIG: 'org.apache.kafka.common.security.plain.PlainLoginModule required username=\"你配置的用户名\" password=\"你配置的密码\";'\n</code></pre>\n<p>配置文件里输入用户和密码：</p>\n<pre><code class=\"language-conf\">KafkaServer {\n    org.apache.kafka.common.security.plain.PlainLoginModule required\n    username=\"节点在集群内通信时的用户名\"\n    password=\"节点在集群内通信时的密码\"\n    # 下面这些才是用户配置\n    # 格式user_&lt;用户名&gt;=\"密码\"\n    user_apot=\"你配置的密码\";\n};\n</code></pre>\n<p>创建好文件和目录之后用<code>docker-compose up -d</code>就能启动服务了。访问<code>localhost:8090</code>可以看到kafka的web控制面板：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1434464/202512/1434464-20251229202723957-374430349.png\" /></p>\n<p>安装好之后可以用下面的命令查看版本：</p>\n<pre><code class=\"language-console\">$ docker exec -it kafka /opt/kafka/bin/kafka-server-start.sh --version\n\n[2025-12-29 11:08:34,595] INFO Registered kafka:type=kafka.Log4jController MBean (kafka.utils.Log4jControllerRegistration$)\n4.0.0\n</code></pre>\n<p>可以看到已经配置好了kafka 4.0环境。</p>\n<p><code>apache/kafka</code>的镜像里内置了各种操作kafka的脚本，不过这些脚本没被添加进<code>$PATH</code>，执行的时候需要指定路径：</p>\n<pre><code class=\"language-bash\"># 先配置登录验证信息\ndocker exec -it kafka bash -c \"cat &lt;&lt;EOF &gt; /tmp/client.conf\nsecurity.protocol=SASL_PLAINTEXT\nsasl.mechanism=PLAIN\nsasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \\\n  username='客户端登录用户名，就是我们之前用user_xxx配置的那些' \\\n  password='客户端登录密码';\nEOF\"\n\n# 调用脚本创建一个topic，需要指定脚本路径\ndocker exec -it kafka /opt/kafka/bin/kafka-topics.sh --command-config /tmp/client.conf \\\n  --bootstrap-server localhost:9092 \\\n  --create \\\n  --topic test.data \\\n  --partitions 1 \\\n  --replication-factor 1 \\\n  --config cleanup.policy=delete \\\n  --config retention.ms=86400000\n</code></pre>\n<p>所有脚本都存放在<code>/opt/kafka/bin</code>路径下，调用前还需要提供登录凭证信息，这些需要注意。打开<code>localhost:8090</code>上的web UI，就能找到我们刚刚创建的topic了：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1434464/202512/1434464-20251229202843717-1676041370.png\" /></p>\n<p>过期处理策略和过期时间也已经被正确设置：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1434464/202512/1434464-20251229203013465-1213915024.png\" /></p>\n<p>总体而言执行脚本还是有些繁琐，我更愿意通过代码或者web界面来做这些操作。</p>\n<p>最后我们写一个go的测试代码，向我们的测试用单节点kafka里写入一些数据：</p>\n<pre><code class=\"language-golang\">package main\n\nimport (\n\t\"context\"\n\t\"math/rand/v2\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/segmentio/kafka-go\"\n\t\"github.com/segmentio/kafka-go/sasl/plain\"\n)\n\nconst (\n\ttopic         = \"lean.data1\"\n\tkafkaEndpoint = \"localhost:9092\"\n)\n\nfunc main() {\n\tmechanism := plain.Mechanism{\n\t\tUsername: \"客户端登录用户名\",\n\t\tPassword: \"客户端登录密码\",\n\t}\n\n\tdialer := &amp;kafka.Dialer{\n\t\tTimeout:       10 * time.Second,\n\t\tDualStack:     true,\n\t\tSASLMechanism: mechanism,\n\t}\n\n\tw := kafka.NewWriter(kafka.WriterConfig{\n\t\tBrokers: []string{kafkaEndpoint},\n\t\tDialer:  dialer, // 必须传入带 SASL 的 dialer\n\t\tAsync:   false,\n\t})\n\tdefer w.Close()\n\n\tmsg := kafka.Message{\n\t\tTopic: topic,\n\t\tKey:   []byte(\"test\"),\n\t\tValue: []byte(strconv.Itoa(rand.Int())), // 随便写入一些随机数据\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\terr := w.WriteMessages(ctx, msg)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n</code></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1434464/202512/1434464-20251229202601662-326565622.png\" /></p>\n<p>可以看到我们的随机数已经正常写入topic了。</p>\n<p>注意：这个配置只使用了最基本的验证，且是单节点，不适合在测试和学习之外的任何用途使用，为了安全我也建议在测试完成之后就立刻用<code>docker-compose down</code>关闭服务。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 20:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/apocelipes\">apocelipes</a>&nbsp;\n阅读(<span id=\"post_view_count\">64</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【大数据 & AI】Flink Agents 源码解读 --- (2) ---  核心架构",
      "link": "https://www.cnblogs.com/rossiXYZ/p/19369781",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rossiXYZ/p/19369781\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 20:24\">\n    <span>【大数据 &amp; AI】Flink Agents 源码解读 --- (2) ---  核心架构</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"大数据--aiflink-agents-源码解读-----2------核心架构\">【大数据 &amp; AI】Flink Agents 源码解读 --- (2) ---  核心架构</h1>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#大数据--aiflink-agents-源码解读-----2------核心架构\" rel=\"noopener nofollow\">【大数据 &amp; AI】Flink Agents 源码解读 --- (2) ---  核心架构</a><ul><li><a href=\"#0x00-摘要\" rel=\"noopener nofollow\">0x00 摘要</a></li><li><a href=\"#0x01-flink-agents主要组件\" rel=\"noopener nofollow\">0x01 Flink Agents主要组件</a><ul><li><a href=\"#11-主要组件\" rel=\"noopener nofollow\">1.1 主要组件</a></li><li><a href=\"#12-内部成员变量映射关系\" rel=\"noopener nofollow\">1.2 内部成员变量映射关系</a><ul><li><a href=\"#121-agent-到-agentplan\" rel=\"noopener nofollow\">1.2.1 Agent 到 AgentPlan</a></li><li><a href=\"#122-agentplan-到-actionexecutionoperator\" rel=\"noopener nofollow\">1.2.2 AgentPlan 到 ActionExecutionOperator</a><ul><li><a href=\"#详细映射分析\" rel=\"noopener nofollow\">详细映射分析</a><ul><li><a href=\"#动作执行映射\" rel=\"noopener nofollow\">动作执行映射</a></li><li><a href=\"#资源管理映射\" rel=\"noopener nofollow\">资源管理映射</a></li><li><a href=\"#配置映射\" rel=\"noopener nofollow\">配置映射</a></li><li><a href=\"#状态管理映射\" rel=\"noopener nofollow\">状态管理映射</a></li></ul></li></ul></li></ul></li><li><a href=\"#13-执行流程\" rel=\"noopener nofollow\">1.3 执行流程</a></li></ul></li><li><a href=\"#0x02-与原生flink比对\" rel=\"noopener nofollow\">0x02 与原生Flink比对</a><ul><li><a href=\"#21-核心\" rel=\"noopener nofollow\">2.1 核心</a></li><li><a href=\"#22-具体比对\" rel=\"noopener nofollow\">2.2 具体比对</a><ul><li><a href=\"#221-agent\" rel=\"noopener nofollow\">2.2.1 Agent</a></li><li><a href=\"#222-agentplan\" rel=\"noopener nofollow\">2.2.2 AgentPlan</a></li><li><a href=\"#223-actionexecutionoperator\" rel=\"noopener nofollow\">2.2.3 ActionExecutionOperator</a></li><li><a href=\"#223-actiontask\" rel=\"noopener nofollow\">2.2.3 ActionTask</a></li></ul></li></ul></li><li><a href=\"#0x03-实例拆解\" rel=\"noopener nofollow\">0x03 实例拆解</a><ul><li><a href=\"#31-第一层级agent--餐厅菜单和规则手册blueprint\" rel=\"noopener nofollow\">3.1 第一层级：Agent – 餐厅菜单和规则手册（Blueprint）</a></li><li><a href=\"#32-第二层级agentplan--餐厅的详细操作流程图compiled-plan计划编译层\" rel=\"noopener nofollow\">3.2 第二层级：AgentPlan – 餐厅的详细操作流程图（Compiled Plan,计划编译层）</a><ul><li><a href=\"#结构化解析\" rel=\"noopener nofollow\">结构化解析</a></li><li><a href=\"#平台适配性\" rel=\"noopener nofollow\">平台适配性</a></li></ul></li><li><a href=\"#33-第三层级actionexecutionoperator--餐厅的执行管理层runtime-executor执行引擎层\" rel=\"noopener nofollow\">3.3 第三层级：ActionExecutionOperator – 餐厅的执行管理层（Runtime Executor，执行引擎层）</a></li><li><a href=\"#34-第四层级actiontask--具体的服务步骤execution-unit\" rel=\"noopener nofollow\">3.4 第四层级：ActionTask – 具体的服务步骤（Execution Unit）</a></li><li><a href=\"#35-工作流程举例\" rel=\"noopener nofollow\">3.5 工作流程举例</a></li></ul></li><li><a href=\"#0x04-并发性和并行性\" rel=\"noopener nofollow\">0x04 并发性和并行性</a><ul><li><a href=\"#41-flink原生并发模型\" rel=\"noopener nofollow\">4.1 Flink原生并发模型</a></li><li><a href=\"#42-每个key的状态管理\" rel=\"noopener nofollow\">4.2 每个Key的状态管理</a></li><li><a href=\"#43-邮箱线程模型\" rel=\"noopener nofollow\">4.3 邮箱线程模型</a></li><li><a href=\"#44-异步任务处理\" rel=\"noopener nofollow\">4.4 异步任务处理</a></li><li><a href=\"#45-内存一致性\" rel=\"noopener nofollow\">4.5 内存一致性</a></li><li><a href=\"#46-水印和事件时间处理\" rel=\"noopener nofollow\">4.6 水印和事件时间处理</a></li><li><a href=\"#47-检查点和恢复\" rel=\"noopener nofollow\">4.7 检查点和恢复</a></li><li><a href=\"#48-总结\" rel=\"noopener nofollow\">4.8 总结</a></li></ul></li><li><a href=\"#0xff-参考\" rel=\"noopener nofollow\">0xFF 参考</a></li></ul></li></ul></div><p></p>\n<h2 id=\"0x00-摘要\">0x00 摘要</h2>\n<p>Flink Agents 框架的核心是 <strong>“事件驱动 + 状态隔离 + 多语言协作”</strong>：通过 Agent/AgentPlan 实现业务逻辑的声明式定义，借助 Flink 原生的分布式、高并发能力实现可靠执行，同时支持 Python 生态的工具 / 模型集成，兼顾了开发灵活性与运行时效率，适用于复杂 AI 代理任务的分布式部署与执行。</p>\n<p>具体而言，Flink Agents 的组件是对原生 Flink 组件在 “Agent 业务场景” 下的语义化封装，而非全新发明。因此，本文将先介绍Flink Agents的基本组件，然后将其组件与Flink 原生组件做对比，最后给出一个详细的例子，这样读者可以更好的理解其设计精要。</p>\n<h2 id=\"0x01-flink-agents主要组件\">0x01 Flink Agents主要组件</h2>\n<p>可以把 Flink Agents 的整个执行流程比作 “做一道菜”，我们借此进行分析。</p>\n<h3 id=\"11-主要组件\">1.1 主要组件</h3>\n<p>Flink Agents 是基于原生 Flink 分布式流处理能力封装的上层框架。其中四个主要组件代表了 Flink Agents 框架中的四个层次：</p>\n<ul>\n<li><strong>Agent（顶层设计，定义了“做什么”）</strong>：用户定义的智能实体，类似 “餐厅菜单 + 规则手册”，包含业务逻辑、动作（Action）和资源（工具、模型等）定义，明确 “做什么”。</li>\n<li><strong>AgentPlan（中间编译层，确定了“怎么做”）</strong>：将 Agent 编译后的可执行计划，类似 “详细操作流程图”，明确动作触发规则、资源映射关系，确定 “怎么做”。</li>\n<li><strong>ActionExecutionOperator（运行时执行层，是执行环境，负责“协调调度”）</strong>：Flink 集群中的执行核心，在 Flink 流处理环境中实际执行操作，类似 “餐厅首席大厨”，负责接收数据、调度任务、管理状态，协调整体执行流程。</li>\n<li><strong>ActionTask（最小执行单元，负责“具体实施”）</strong>：具体的执行任务，类似 “员工的单个服务步骤”，分为 JavaActionTask 和 PythonActionTask，处理单个事件并返回结果。</li>\n</ul>\n<p>具体可以参见下图。</p>\n<pre><code class=\"language-python\">[Agent] 菜单手册\n    ↓（编译）\n[AgentPlan] 详细流程图\n    ↓（运行时实例化）\n[ActionExecutionOperator] 餐厅首席大厨\n    ↓（分配任务）\n[ActionTask] 员工具体任务\n</code></pre>\n<p>这样的设计使得系统既灵活又高效，能够处理复杂的AI代理任务，同时保证了良好的扩展性和维护性。</p>\n<h3 id=\"12-内部成员变量映射关系\">1.2 内部成员变量映射关系</h3>\n<p>Agent、AgentPlan 和 ActionExecutionOperator 之间的关系以及它们内部成员变量的映射关系如下。</p>\n<h4 id=\"121-agent-到-agentplan\">1.2.1 Agent 到 AgentPlan</h4>\n<p>Agent 到 AgentPlan 的映射如下：</p>\n<table>\n<thead>\n<tr>\n<th>Agent 成员</th>\n<th>AgentPlan 对应成员</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>_actions（装饰器定义）</td>\n<td>actions, actions_by_event</td>\n<td>Agent 中通过 @action 装饰器定义的动作被编译到 AgentPlan 的动作映射中</td>\n</tr>\n<tr>\n<td>_actions（add_action 添加）</td>\n<td>actions, actions_by_event</td>\n<td>通过 add_action 方法添加的动作同样编译到动作映射中</td>\n</tr>\n<tr>\n<td>_resources</td>\n<td>resource_providers</td>\n<td>Agent 中注册的资源被转换为资源提供者</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"122-agentplan-到-actionexecutionoperator\">1.2.2 AgentPlan 到 ActionExecutionOperator</h4>\n<p>AgentPlan 到 ActionExecutionOperator 的映射如下：</p>\n<table>\n<thead>\n<tr>\n<th>AgentPlan 成员</th>\n<th>ActionExecutionOperator 对应成员</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>actions</td>\n<td>通过 getActionsTriggeredBy() 方法调用</td>\n<td>Operator 根据事件类型查找对应的动作</td>\n</tr>\n<tr>\n<td>resource_providers</td>\n<td>在 RunnerContextImpl 中使用</td>\n<td>提供运行时所需的资源</td>\n</tr>\n<tr>\n<td>config</td>\n<td>metricGroup, builtInMetrics 等</td>\n<td>用于配置指标和其他运行时行为</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"详细映射分析\">详细映射分析</h5>\n<h6 id=\"动作执行映射\">动作执行映射</h6>\n<p>在 <code>ActionExecutionOperator</code> 中：</p>\n<pre><code class=\"language-java\">// 根据事件类型获取触发的动作\nprivate List&lt;Action&gt; getActionsTriggeredBy(Event event) {\n    if (event instanceof PythonEvent) {\n        return agentPlan.getActionsTriggeredBy(((PythonEvent) event).getEventType());\n    } else {\n        return agentPlan.getActionsTriggeredBy(event.getClass().getName());\n    }\n}\n\n// 创建 ActionTask 来执行动作\nprivate ActionTask createActionTask(Object key, Action action, Event event) {\n    if (action.getExec() instanceof JavaFunction) {\n        return new JavaActionTask(\n            key, event, action, getRuntimeContext().getUserCodeClassLoader());\n    } else if (action.getExec() instanceof PythonFunction) {\n        return new PythonActionTask(key, event, action);\n    }\n    // ..\n}\n</code></pre>\n<h6 id=\"资源管理映射\">资源管理映射</h6>\n<p><code>AgentPlan</code> 中的资源提供者在 <code>ActionExecutionOperator</code> 中通过 <code>RunnerContextImpl</code> 访问：</p>\n<pre><code class=\"language-java\">// 在 RunnerContextImpl 中\npublic Resource getResource(String name, ResourceType type) {\n    return agentPlan.getResource(name, type);\n}\n</code></pre>\n<h6 id=\"配置映射\">配置映射</h6>\n<p>AgentPlan 中的配置信息被用于初始化ActionExecutionOperator的各种运行时组件：</p>\n<pre><code class=\"language-java\">// 在 ActionExecutionOperator.open() 中\nmetricGroup = new FlinkAgentsMetricGroupImpl(getMetricGroup());\nbuiltInMetrics = new BuiltInMetrics(metricGroup, agentPlan);\n\n// ActionStateStore 初始化也依赖于配置\nif (actionStateStore == null &amp;&amp; KAFKA.getType().equalsIgnoreCase(agentPlan.getConfig().get(ACTION_STATE_STORE_BACKEND))) {\n    actionStateStore = new KafkaActionStateStore(agentPlan.getConfig());\n}\n</code></pre>\n<h6 id=\"状态管理映射\">状态管理映射</h6>\n<p>ActionExecutionOperator 中的各种状态与 AgentPlan 的执行需求相对应：</p>\n<pre><code class=\"language-java\">// 短期内存状态用于动作间的数据共享\nprivate transient MapState&lt;String, MemoryObjectImpl.MemoryItem&gt; shortTermMemState;\n\n// 动作任务状态用于异步执行管理\nprivate transient ListState&lt;ActionTask&gt; actionTasksState;\n\n// 待处理事件状态用于流控\nprivate transient ListState&lt;Event&gt; pendingInputEventsState;\n</code></pre>\n<h3 id=\"13-执行流程\">1.3 执行流程</h3>\n<p>具体流程如下：</p>\n<pre><code class=\"language-python\">Action Code → Agent → AgentPlan → ActionExecutionOperator → ActionTask → Flink Runtime\n</code></pre>\n<p>以 ReActAgent 为例，其流程如下：</p>\n<ul>\n<li>\n<p>用户定义 ReActAgent，包含 <code>start_action</code> 和 <code>stop_action</code></p>\n</li>\n<li>\n<p>通过 <code>AgentPlan.from_agent()</code> 编译成计划：</p>\n<ul>\n<li>\n<p><code>actions</code>：包含 <code>start_action</code> 和 <code>stop_action</code></p>\n</li>\n<li>\n<p><code>actions_by_event</code>：映射 <code>InputEvent</code> → <code>start_action</code>，<code>ChatResponseEvent</code> → <code>stop_action</code></p>\n</li>\n</ul>\n</li>\n<li>\n<p>在运行环境中，AgentPlan 被传递给 ActionExecutionOperatorFactory。ActionExecutionOperatorFactory 创建 ActionExecutionOperator 实例。</p>\n</li>\n<li>\n<p>ActionExecutionOperator 在运行时根据 AgentPlan 执行具体操作。在 ActionExecutionOperator 中：</p>\n<ul>\n<li>接收到 InputEvent 后，查找并执行 start_action</li>\n<li>start_action 发送 ChatRequestEvent</li>\n<li>查找并执行处理 ChatRequestEvent 的内置动作（如 CHAT_MODEL_ACTION）</li>\n<li>PythonActionTask 执行工具函数，若为生成器则创建 PythonGeneratorActionTask 持续执行；</li>\n<li>工具执行完成生成 ChatResponseEvent</li>\n<li>查找并执行 stop_action</li>\n<li>stop_action 产生 OutputEvent 并发送到下游</li>\n</ul>\n</li>\n</ul>\n<p>这种设计实现了关注点分离：用户只需关注业务逻辑定义，框架负责将其编译为高效的运行时执行计划。</p>\n<h2 id=\"0x02-与原生flink比对\">0x02 与原生Flink比对</h2>\n<p>Flink Agents 是原生 Flink 的 “领域封装”：所有组件都能映射到原生 Flink 核心组件，未脱离 Flink 流处理的核心架构。我们接下来看看 Flink Agents 里的 Agent、AgentPlan、ActionExecutionOperator、ActionTask 这些核心组件，分别对应原生 Flink 中的哪些核心组件，以及它们的相似性逻辑。</p>\n<h3 id=\"21-核心\">2.1 核心</h3>\n<p>我们先用一张表来概括比对关系。</p>\n<table>\n<thead>\n<tr>\n<th>Flink Agents 组件</th>\n<th>原生 Flink 对应组件</th>\n<th>核心角色</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Agent</td>\n<td>StreamGraph / 用户 DataStream 代码</td>\n<td>高层业务逻辑声明（做什么）</td>\n</tr>\n<tr>\n<td>AgentPlan</td>\n<td>JobGraph</td>\n<td>编译后的可执行计划（怎么拆）</td>\n</tr>\n<tr>\n<td>ActionExecutionOperator</td>\n<td>KeyedProcessOperator/StreamOperator</td>\n<td>运行时核心执行算子（核心载体）</td>\n</tr>\n<tr>\n<td>ActionTask</td>\n<td>算子内处理单元 / AsyncFunction 任务</td>\n<td>原子执行任务（最小执行单元）</td>\n</tr>\n</tbody>\n</table>\n<p>核心映射逻辑如下：「声明层（Agent）→ 编译层（AgentPlan）→ 执行算子（ActionExecutionOperator）→ 原子任务（ActionTask）」对应原生 Flink 的「StreamGraph → JobGraph → StreamOperator → 算子内处理单元」；</p>\n<p>回到 “做一道菜” ，我们进行分拆对比。</p>\n<ul>\n<li>Agent = 你写的 “菜谱逻辑”（比如 “做番茄炒蛋，先炒蛋再炒番茄”）→ 对应 Flink StreamGraph（纯逻辑）；</li>\n<li>AgentPlan = 餐厅后厨把菜谱转换成的 “可执行工单”（明确 “谁来炒、用哪个锅、放多少盐”）→ 对应  Flink JobGraph（可执行计划）；</li>\n<li>ActionExecutionOperator = 掌勺厨师（执行工单）→ 对应 Flink  StreamOperator；</li>\n<li>ActionTask = 厨师的 “单个翻炒动作”→ 对应 Flink 算子内的原子处理任务；</li>\n<li>Flink ExecutionGraph = 厨师实际站在哪个灶台、用哪套厨具 → 物理执行层，和 AgentPlan 无关。</li>\n</ul>\n<h3 id=\"22-具体比对\">2.2 具体比对</h3>\n<h4 id=\"221-agent\">2.2.1 Agent</h4>\n<ul>\n<li><strong>相似组件</strong>：Flink Job 的业务逻辑定义（如 DataStream 算子链）、StreamGraph（流式作业的逻辑拓扑）</li>\n<li><strong>相似性核心</strong>：Agent 是用户定义的 “智能实体”（包含业务逻辑、动作、资源），本质是业务层面的 “作业逻辑声明”；这和原生 Flink 中用户编写的 DataStream 代码（定义 “数据怎么处理”）、StreamGraph（描述逻辑拓扑）的角色完全一致 —— 都是 “告诉系统要做什么” 的顶层逻辑定义，不涉及具体执行。</li>\n<li><strong>差异</strong>：Agent 更聚焦 “Agent 行为 / 工具调用” 的语义，而原生 StreamGraph 是通用的数据流拓扑。</li>\n</ul>\n<h4 id=\"222-agentplan\">2.2.2 AgentPlan</h4>\n<ul>\n<li><strong>相似组件</strong>：Flink 的 JobGraph（StreamGraph 编译后的可执行拓扑）</li>\n<li><strong>相似性核心</strong>：AgentPlan 是 Agent 编译后的 “可执行计划”（明确动作触发规则、资源映射），本质是将高层业务逻辑转换为系统可识别的执行计划；这和原生 Flink 中 StreamGraph 编译为 JobGraph 的过程一致 ——JobGraph 把用户的逻辑拓扑转换为包含并行度、算子链、中间结果传递的可执行拓扑，AgentPlan 则把 Agent 的 “行为规则” 转换为系统可调度的 “动作执行规则”。</li>\n<li><strong>关键共性</strong>：都是 “编译层” 产物，连接高层定义与底层执行。</li>\n</ul>\n<h4 id=\"223-actionexecutionoperator\">2.2.3 ActionExecutionOperator</h4>\n<ul>\n<li>\n<p><strong>相似组件</strong>：Flink 核心的 StreamOperator（如 ProcessOperator、FlatMapOperator）、KeyedProcessOperator</p>\n</li>\n<li>\n<p><strong>相似性核心</strong>：ActionExecutionOperator 是 Flink 集群中执行 Agent 逻辑的核心算子，本质是运行时的核心执行单元；这和原生 Flink 的 StreamOperator 完全对应 ——StreamOperator 是处理数据流的核心载体（如 ProcessOperator 处理 KeyedStream、实现状态管理），ActionExecutionOperator 就是针对 “Agent 动作执行” 场景定制的 StreamOperator：</p>\n<ul>\n<li>都运行在 TaskManager 中，处理流数据（Event）；</li>\n<li>都支持键控状态（Keyed State），按 key 隔离执行上下文；</li>\n<li>都依赖 Mailbox 机制调度任务，避免阻塞；</li>\n<li>都负责状态管理、事件处理、结果输出。</li>\n</ul>\n</li>\n<li>\n<p><strong>典型对应</strong>：ActionExecutionOperator 最接近原生的 <code>KeyedProcessOperator</code>（键控处理、状态管理、异步任务调度）。</p>\n</li>\n</ul>\n<h4 id=\"223-actiontask\">2.2.3 ActionTask</h4>\n<ul>\n<li>\n<p><strong>相似组件</strong>：Flink 的「算子内的处理任务」（如 ProcessFunction 中的单个元素处理逻辑）、Async I/O 中的 <code>AsyncFunction</code> 任务</p>\n</li>\n<li>\n<p><strong>相似性核心</strong>：ActionTask 是 “最小执行单元”（如单个 Python/Java 动作执行），本质是算子内的原子处理任务；这和原生 Flink 中：</p>\n<ul>\n<li>ProcessOperator 处理单个 StreamElement（如一条数据）的逻辑单元；</li>\n<li>Async I/O 中 AsyncFunction 封装的异步任务（如异步查询数据库）；</li>\n</ul>\n<p>角色完全一致 —— 都是 “算子内的最小可执行任务”，执行完成后返回结果，支持异步 / 分阶段执行。</p>\n</li>\n<li>\n<p><strong>关键共性</strong>：</p>\n<ul>\n<li>都是 “原子执行单元”，不可再拆分；</li>\n<li>支持异步执行（如 PythonActionTask 对应 Async I/O）；</li>\n<li>执行结果可触发后续任务（如 ActionTaskResult 生成新任务，对应 Async I/O 回调触发后续处理）。</li>\n</ul>\n</li>\n<li>\n<p><strong>细分对应</strong>：</p>\n<ul>\n<li>JavaActionTask → 原生同步处理任务（如 ProcessFunction 中的同步逻辑）；</li>\n<li>PythonActionTask → 原生 Async I/O 任务（异步调用外部服务 / 脚本）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"0x03-实例拆解\">0x03 实例拆解</h2>\n<p>我们来进一步解释 Flink Agents 这几个核心概念的关系和配合。为了更好的说明，我们可以把整个Flink Agents系统从”做一道菜“拓展到”一个智能餐厅自动化服务系统“。同时，结合实例也深入下技术细节。</p>\n<h3 id=\"31-第一层级agent--餐厅菜单和规则手册blueprint\">3.1 第一层级：Agent – 餐厅菜单和规则手册（Blueprint）</h3>\n<p>Flink Agents 中的 Agent 是用户定义的智能实体，负责协调各种资源和行为来完成特定的任务。我们把 Agent 想象成餐厅的菜单和运营手册：</p>\n<ul>\n<li>\n<p>定义了餐厅能提供哪些菜品和服务（动作）</p>\n</li>\n<li>\n<p>规定了需要用到哪些设备和食材（资源），如同为新员工配备工具箱，对应程序员实际用到的，可以是：</p>\n<ul>\n<li>各种 API 接口（相当于工具）</li>\n<li>数据库访问权限（相当于参考资料）</li>\n<li>决策逻辑代码（相当于培训材料）</li>\n</ul>\n</li>\n<li>\n<p>遇到什么情况应该做什么（对应事件监听）</p>\n</li>\n<li>\n<p>描述了顾客点餐到上菜的完整流程</p>\n<ul>\n<li>有一个 start_action（接待员）负责接收顾客问题</li>\n<li>有一个 stop_action（收银员）负责最终结账输出结果</li>\n</ul>\n</li>\n</ul>\n<p>这些都被封装在 Agent 对象中。</p>\n<h3 id=\"32-第二层级agentplan--餐厅的详细操作流程图compiled-plan计划编译层\">3.2 第二层级：AgentPlan – 餐厅的详细操作流程图（Compiled Plan,计划编译层）</h3>\n<p>Flink Agent框架会把用户的 Agent 转换为一个更通用、更适合系统处理的形式 —— AgentPlan。在本例中，AgentPlan 相当于将餐厅运营手册编译成的详细工作流程图（抽象化的工作蓝图）：</p>\n<ul>\n<li>把菜单上的每道菜分解成具体的步骤</li>\n<li>明确每个岗位（动作）在什么情况下被触发，即遇到啥事件（Event）该干啥活（Action）</li>\n<li>准备好所有需要的工具和材料清单（Resource）</li>\n</ul>\n<p>就像餐厅经理会制定详细的操作手册，告诉服务员什么时候该做什么事。</p>\n<h4 id=\"结构化解析\">结构化解析</h4>\n<p>AgentPlan 包含几个关键部分：</p>\n<p><strong>Actions 映射表</strong></p>\n<ul>\n<li>明确列出所有可以执行的动作及其触发条件</li>\n<li>例如：“收到订单查询请求” → “执行订单查询动作”</li>\n</ul>\n<p><strong>资源提供者目录</strong></p>\n<ul>\n<li>记录所有可用资源的位置和获取方式</li>\n<li>类似于工厂里各个供应部门的联系方式清单</li>\n</ul>\n<p><strong>配置参数集</strong></p>\n<ul>\n<li>存储运行所需的各项设置选项</li>\n<li>像是设备操作规程和技术规范</li>\n</ul>\n<h4 id=\"平台适配性\">平台适配性</h4>\n<p>通过这种抽象化，无论底层是 Java 还是 Python 实现，都可以统一用同一份 AgentPlan 来进行调度管理。</p>\n<h3 id=\"33-第三层级actionexecutionoperator--餐厅的执行管理层runtime-executor执行引擎层\">3.3 第三层级：ActionExecutionOperator – 餐厅的执行管理层（Runtime Executor，执行引擎层）</h3>\n<p>在大规模生产环境中，不能只靠一个管家干活，而是需要一条自动化流水线。ActionExecutionOperator 就像是一条智能化的工厂装配线，它按照操作手册（AgentPlan）组织多个工作站来协同完成任务。或者说，ActionExecutionOperator 是餐厅的现场执行管理层，是整个系统的“大脑 + 中枢控制室”：</p>\n<ul>\n<li>负责接待进店的顾客（接收数据）</li>\n<li>根据流程图分配任务给不同的员工（执行动作）</li>\n<li>协调各个岗位之间的工作（监控进度状态 / 管理状态和内存）</li>\n<li>确保服务流程顺畅（处理并发和容错）</li>\n<li>餐厅经理拿着详细流程图，指挥各个员工协同工作。</li>\n</ul>\n<h3 id=\"34-第四层级actiontask--具体的服务步骤execution-unit\">3.4 第四层级：ActionTask – 具体的服务步骤（Execution Unit）</h3>\n<p>ActionTask 就像是员工执行的具体服务步骤，是生产线上的最小工位：一次只干一件具体活（调用 Python 函数、查数据库、发 HTTP、写 Kafka …）：</p>\n<ul>\n<li>每个服务员接到的任务就是一个 ActionTask</li>\n<li>可能是简单一步完成（普通服务员）</li>\n<li>可能是需要多步完成（需要回访的技术员），即如果活太多（异步、长耗时），服务员会把自己「切分」成新任务，等下次轮询再接着干，实现非阻塞的协作式调度。</li>\n<li>完成后报告结果，并可能触发下一步工作，即干完就能立即把结果（Event）扔回传送带，继续下一轮</li>\n</ul>\n<h3 id=\"35-工作流程举例\">3.5 工作流程举例</h3>\n<p>假设顾客来到餐厅点了一份复杂的套餐：</p>\n<ul>\n<li>顾客进店（InputEvent）\n<ul>\n<li>餐厅经理（ActionExecutionOperator）接待顾客</li>\n<li>根据流程图知道应该让接待员（start_action）处理</li>\n</ul>\n</li>\n<li>接待员处理（ActionTask）\n<ul>\n<li>接待员（PythonActionTask）接到任务</li>\n<li>理解顾客需求，生成厨房订单（ChatRequestEvent）</li>\n</ul>\n</li>\n<li>厨房制作（内置动作）\n<ul>\n<li>厨师（CHAT_MODEL_ACTION）收到订单开始制作</li>\n<li>制作完成后通知服务员（ChatResponseEvent）</li>\n</ul>\n</li>\n<li>收银结账（ActionTask）\n<ul>\n<li>收银员（stop_action）处理最终结果</li>\n<li>顾客打包带走（OutputEvent）</li>\n</ul>\n</li>\n</ul>\n<p>「用户只管把管家训好，框架负责把管家变成手册，再把手册变成并行生产线，最后让无数worker按 key 隔离、事件驱动、可检查点的方式跑在 Flink 上。」。</p>\n<h2 id=\"0x04-并发性和并行性\">0x04 并发性和并行性</h2>\n<p>Flink Agents 系统在设计时已经充分考虑了并发性和并行性，比如：</p>\n<ul>\n<li><strong>事件驱动模型</strong>：基于事件流转触发动作，初始为 InputEvent，经多轮事件（如 ChatRequestEvent、ChatResponseEvent）触发，最终输出 OutputEvent。</li>\n<li><strong>并发与隔离设计</strong>：利用 Flink 键控流（KeyedStream）实现按 key 分区，每个 key 拥有独立状态；通过邮箱线程模型（MailboxExecutor）实现协作式多任务，避免阻塞。</li>\n<li><strong>任务切分机制</strong>：长时间运行的任务（如 Python 生成器）会被切分为多个 ActionTask，执行后通过 ActionTaskResult 传递下一个任务，确保并发效率。</li>\n<li><strong>本地与远程执行</strong>：本地用 LocalRunner 模拟执行，远程基于 Flink 集群的 ActionExecutionOperator 分布式执行，保持 API 一致性。</li>\n</ul>\n<p>以下是具体实现方式：</p>\n<h3 id=\"41-flink原生并发模型\">4.1 Flink原生并发模型</h3>\n<p>系统充分利用了Apache Flink的原生并发机制：</p>\n<ul>\n<li>键控流（Keyed Streams）：使用Flink的KeyedStream按key对数据进行分区，确保相同key的事件由同一个并行实例处理</li>\n<li>并行操作符：ActionExecutionOperator可以在Flink集群中的多个实例上并行运行</li>\n</ul>\n<pre><code class=\"language-java\">// 在CompileUtils.java中 - 将代理连接到键控流\npublic static &lt;IN, K&gt; DataStream&lt;Object&gt; connectToAgent(\n    DataStream&lt;IN&gt; inputStream, KeySelector&lt;IN, K&gt; keySelector, AgentPlan agentPlan) {\n    return connectToAgent(inputStream.keyBy(keySelector), agentPlan);\n}\n</code></pre>\n<p>在 RemoteExecutionEnvironment 中有：</p>\n<pre><code class=\"language-java\">@Override\npublic DataStream&lt;Object&gt; toDataStream() {\n    if (agentPlan == null) {\n        throw new IllegalStateException(\"Must apply agent before calling toDataStream\");\n    }\n\n    if (outputDataStream == null) {\n        if (keySelector != null) {\n            outputDataStream =\n                    CompileUtils.connectToAgent(inputDataStream, keySelector, agentPlan);\n        } else {\n            // If no key selector provided, use a simple pass-through key selector\n            outputDataStream =\n                    CompileUtils.connectToAgent(inputDataStream, x -&gt; x, agentPlan);\n        }\n    }\n\n    return outputDataStream;\n}\n</code></pre>\n<h3 id=\"42-每个key的状态管理\">4.2 每个Key的状态管理</h3>\n<p>每个key都维护独立的状态隔离：</p>\n<pre><code class=\"language-java\">// 在ActionExecutionOperator.java中 - 维护每个key的状态\nprivate transient ListState&lt;ActionTask&gt; actionTasksKState;\nprivate transient ListState&lt;Event&gt; pendingInputEventsKState;\nprivate transient ValueState&lt;Long&gt; sequenceNumberKState;\n</code></pre>\n<p>这些都是键控状态（keyed state），意味着每个key都有自己的独立状态实例，防止不同key之间的竞争条件。</p>\n<h3 id=\"43-邮箱线程模型\">4.3 邮箱线程模型</h3>\n<p>系统使用Flink的邮箱线程模型实现协作式多任务处理：</p>\n<pre><code class=\"language-java\">// 在ActionExecutionOperator.java中\nprivate final transient MailboxExecutor mailboxExecutor;\n\n// 提交任务进行处理\nmailboxExecutor.submit(() -&gt; tryProcessActionTaskForKey(key), \"process action task\");\n</code></pre>\n<p>这允许长时间运行的操作让出控制权，防止阻塞整个操作符。</p>\n<h3 id=\"44-异步任务处理\">4.4 异步任务处理</h3>\n<p>支持异步执行并具备适当的状态管理：</p>\n<pre><code class=\"language-java\">// 在 ActionTask.java 中 - 支持基于延续的执行\npublic class ActionTaskResult {\n    private final boolean finished;\n    private final List&lt;Event&gt; outputEvents;\n    private final Optional&lt;ActionTask&gt; generatedActionTaskOpt;\n\n    // 允许一个动作生成延续任务\n    public Optional&lt;ActionTask&gt; getGeneratedActionTask() {\n        return generatedActionTaskOpt;\n    }\n}\n</code></pre>\n<h3 id=\"45-内存一致性\">4.5 内存一致性</h3>\n<p>具有缓存状态访问的线程安全内存管理：</p>\n<pre><code class=\"language-java\">// 在 ActionExecutionOperator.java 中\nprivate void createAndSetRunnerContext(ActionTask actionTask) {\n    // 正确管理 RunnerContext 的创建和重用\n    if (actionTask.getRunnerContext() != null) {\n        return;\n    }\n    // ... 创建适当的 context\n}\n</code></pre>\n<h3 id=\"46-水印和事件时间处理\">4.6 水印和事件时间处理</h3>\n<p>具备并发意识的水印处理：</p>\n<pre><code class=\"language-java\">    private transient SegmentedQueue keySegmentQueue;\n    \n    keySegmentQueue = new SegmentedQueue();\n\n    @Override\n    public void processWatermark(Watermark mark) throws Exception {\n        keySegmentQueue.addWatermark(mark);\n        processEligibleWatermarks();\n    }\n</code></pre>\n<h3 id=\"47-检查点和恢复\">4.7 检查点和恢复</h3>\n<p>用于容错的线程安全状态快照</p>\n<pre><code class=\"language-java\">    @Override\n    public void snapshotState(StateSnapshotContext context) throws Exception {\n        if (actionStateStore != null) {\n            Object recoveryMarker = actionStateStore.getRecoveryMarker();\n            if (recoveryMarker != null) {\n                recoveryMarkerOpState.update(List.of(recoveryMarker));\n            }\n        }\n\n        HashMap&lt;Object, Long&gt; keyToSeqNum = new HashMap&lt;&gt;();\n        getKeyedStateBackend()\n                .applyToAllKeys(\n                        VoidNamespace.INSTANCE,\n                        VoidNamespaceSerializer.INSTANCE,\n                        new ValueStateDescriptor&lt;&gt;(MESSAGE_SEQUENCE_NUMBER_STATE_NAME, Long.class),\n                        (key, state) -&gt; keyToSeqNum.put(key, state.value()));\n        checkpointIdToSeqNums.put(context.getCheckpointId(), keyToSeqNum);\n\n        super.snapshotState(context);\n    }\n</code></pre>\n<h3 id=\"48-总结\">4.8 总结</h3>\n<p>设计采用了多种并发机制：</p>\n<ul>\n<li>Flink并行处理：利用Flink原生的并行性和键控流</li>\n<li>每个Key的隔离：每个key维护独立状态，消除key之间的竞争</li>\n<li>协作式线程：使用邮箱执行器实现非阻塞执行</li>\n<li>异步延续：通过任务链支持长时间运行的操作</li>\n<li>线程安全状态管理：对共享资源进行适当的同步</li>\n<li>容错机制：检查点机制确保故障情况下的数据一致性</li>\n</ul>\n<p>这种方法使系统能够在保持一致性和支持水平扩展的同时处理高吞吐量，可在 Flink 集群的多个节点间扩展。</p>\n<h2 id=\"0xff-参考\">0xFF 参考</h2>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 20:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rossiXYZ\">罗西的思考</a>&nbsp;\n阅读(<span id=\"post_view_count\">21</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Java 哪些情况会导致内存泄漏",
      "link": "https://www.cnblogs.com/yanshajiuzhou/p/19417793",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yanshajiuzhou/p/19417793\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 19:29\">\n    <span>Java 哪些情况会导致内存泄漏</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        内存泄漏 是指对象 已经不再被程序使用，但因为某些原因 无法被垃圾回收器回收，长期占用内存，最终可能引发&nbsp;OOM（OutOfMemoryError）。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>​</span>今天我们来一起聊一聊有哪些情况会导致内存泄漏。</p>\n<p>什么是 <strong>内存泄漏</strong> 呢？</p>\n<p><strong>内存泄漏</strong> 是指对象 <strong>已经不再被程序使用</strong>，但因为某些原因 <strong>无法被垃圾回收器回收</strong>，长期占用内存，最终可能引发&nbsp;<strong>OOM</strong>（OutOfMemoryError）。</p>\n<p>接下来我们看一下常见的几类内存泄漏场景。</p>\n<p><strong>1、生命周期长的集合</strong></p>\n<p>将对象放入 <strong>静态</strong> 或&nbsp;<strong>生命周期很长&nbsp;</strong>的集合（如 public <strong>static</strong> List&lt;Object&gt; list = new ArrayList&lt;&gt;();），即使后面不再需要，集合仍持有其引用，导致无法<strong>GC</strong>。</p>\n<p><strong>2、未关闭的资源</strong></p>\n<p>连接、流等资源未调用<strong> close() </strong>方法关闭。这些资源不仅占用内存，还可能占用文件句柄（操作系统分配的唯一标识，凭它，你才能操作文件资源）、网络连接等系统资源。比如&nbsp;数据库连接、文件流（FileInputStream）、Socket连接 等。</p>\n<pre class=\"language-java highlighter-hljs\"><code>public class FileTest {\n    public static void main(String[] args) {\n        FileInputStream fis = null;\n        try {\n            fis = new FileInputStream(\"test.txt\");\n            // 读取文件，未调用 fis.close()\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } finally {\n            // 未调用 fis.close() → fis 持有 Native 引用，无法回收\n        }\n    }\n}</code></pre>\n<p><strong>3、ThreadLocal 使用不当</strong></p>\n<p>将对象存入 <strong>ThreadLocal </strong>后，未在后续调用 <strong>remove()</strong> 清理。若线程来自线程池（会复用），其 ThreadLocalMap 中的值会一直存活。</p>\n<pre class=\"language-java highlighter-hljs\"><code>public class ThreadLocalTest {\n    private static ThreadLocal&lt;User&gt; userThreadLocal = new ThreadLocal&lt;&gt;();\n\n    public static void main(String[] args) {\n        // 线程池（核心线程长期存活）\n        TThreadPoolExecutor executor = new ThreadPoolExecutor(\n                2,\n                4,\n                10,\n                TimeUnit.SECONDS,\n                new ArrayBlockingQueue&lt;&gt;(100),\n                new ThreadFactoryBuilder().setNameFormat(\"my-thread-pool-%d\").setDaemon(false).setPriority(Thread.NORM_PRIORITY).build(),\n                new ThreadPoolExecutor.AbortPolicy()\n        );\n\n        executor.submit(() -&gt; {\n            User user = new User(\"李四\", 30);\n            userThreadLocal.set(user); // 存储到 ThreadLocal\n\n            // 业务执行完毕，未调用 remove()\n            // 核心线程不会销毁，ThreadLocal 仍持有 user 引用\n        });\n    }\n}</code></pre>\n<p>ps：未进行&nbsp;<strong>remove()</strong>，还可能会导致&nbsp;<strong>ThreadLocal </strong>取值串门。</p>\n<p><strong>4、内部类与外部类引用</strong></p>\n<p>非静态内部类（或匿名类）会&nbsp;<strong>隐式持有&nbsp;</strong>外部类的引用。如果内部类实例生命周期更长（如被缓存或另一个线程引用），会阻止外部类被回收。</p>\n<pre class=\"language-java highlighter-hljs\"><code>public class OuterClass {\n    private byte[] bigData = new byte[1024 * 1024 * 10]; // 10MB 大对象\n\n    // 非静态内部类\n    class InnerClass {\n        // 内部类隐式持有 OuterClass 引用\n    }\n\n    public InnerClass createInner() {\n        return new InnerClass();\n    }\n\n    public static void main(String[] args) {\n        OuterClass outer = new OuterClass();\n        InnerClass inner = outer.createInner();\n\n        // 置空外部类引用，但 inner 仍持有 outer 引用\n        outer = null;\n\n        // 若 inner 被静态变量/线程长期持有 → outer 对象（含 bigData）无法回收\n    }\n}</code></pre>\n<p><strong>5、&nbsp;监听器与回调</strong></p>\n<p>注册了 <strong>监听器&nbsp;</strong>或 <strong>回调</strong> 后，在对象不再需要时 <strong>没有注销</strong>，导致源对象仍持有监听器的引用（比如 事件监听器、消息队列的消费者等）。</p>\n<p><strong>排查工具推荐</strong></p>\n<ul>\n<li><strong>MAT（Memory Analyzer Tool）：</strong>分析堆 Dump 文件，定位泄漏对象、引用链（谁在持有泄漏对象）；</li>\n<li><strong>VisualVM：</strong>JDK 自带工具，监控内存占用趋势，生成堆 Dump，简单排查泄漏。</li>\n</ul>\n<p>这里我只列了常见的几种情况，欢迎大家补充其他内存泄漏场景。</p>\n<p style=\"text-align: right;\"><span style=\"color: rgba(53, 152, 219, 1);\">人间非净土，各有千种愁，万般苦。-- 烟沙九洲</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 19:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yanshajiuzhou\">烟沙九洲</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MAF快速入门（9）多路分支路由工作流",
      "link": "https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper09",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper09\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 18:30\">\n    <span>MAF快速入门（9）多路分支路由工作流</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"MAF快速入门（9）多路分支路由工作流\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/381412/202512/381412-20251224203108188-1569801702.png\" />\n        上一篇，我们学习了MAF中如何进行if-else类型的条件路由，但是实际工作中可能会村中多个分支路由的场景。在实际业务场景中，很多的业务逻辑涉及到不止两个判断条件，而是多个。在MAF中，我们可以使用 Switch-Case 来实现这种工作流内部多类决策条件的 工作流需求。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span><span>大家好，我是Edison。</span></span></p>\n<p><span><span>最近我一直在跟着圣杰的《<a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\"><span>.NET+AI智能体开发进阶</span></a><span>》课程学习MAF的开发技巧，我强烈推荐你也上车跟我一起出发！</span></span></span></p>\n<p><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper08\" target=\"_blank\"><span>上一篇</span></a><span>，我们学习了MAF中如何进行if-else类型的条件路由<span>，但是实际工作中可能会存在多个分支路由的场景。本篇，我们来了解下MAF中的switch-case路由实现多分支路由工作流。</span></span></span></p>\n<h1><strong>Why switch-case?</strong></h1>\n<p><span><span><span><span><span><span>在实际业务场景中，很多的业务逻辑涉及到不止两个判断条件，而是多个<span>。</span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span>例如，在上一篇的企业内部邮件检测案例中，我们的检测结果只有两个（垃圾邮件 或 正常邮件），但如果我们想增加一个结果（不确定）就无法适用了。</span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span>在MAF中，我们可以使用 Switch-Case 来实现这种工作流内部多类决策条件的 工作流需求<span>。</span></span></span></span></span></span></span></span></p>\n<h1><strong>实验案例</strong></h1>\n<p><span><span><span><span><span><span><span><span>今天来晚上上一篇这个企业内部邮件检测的工作流案例，上一篇的流程是这样的：</span></span></span></span></span></span></span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202512/381412-20251224202006911-1817307092.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p><span><span><span><span><span><span><span><span><span><span>今天假设我们需要有更为精细的分类：</span></span></span></span></span></span></span></span></span></span></p>\n<p><span><span>&nbsp; ✅&nbsp;<span><span>**正常邮件**<span><span>（NotSpam）：客户咨询、业务往来</span></span></span></span></span></span></p>\n<p><span><span>&nbsp; ❌&nbsp;<span><span>**垃圾邮件**<span><span>（Spam）：明显的诈骗、广告</span></span></span></span></span></span></p>\n<p><span><span>&nbsp;&nbsp;<span><span>⚠️&nbsp;<span><span>**不确定邮件**<span><span>（Uncertain）：可能是钓鱼邮件，需要人工审核</span></span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span><span><span><span>那么这就是一个三元分类的，在业务开发中我们通常会用到switch-case语法，而在MAF工作流中，也为我们定义了这种switch-case接口。</span></span></span></span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span><span><span><span>在下面的代码示例中，比对了两种接口的使用方式：</span></span></span></span></span></span></span></span></span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Conditional Edge</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">builder\n    .AddEdge(source, target1, condition: c </span>=&gt; c.IsSpam == <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    .AddEdge(source, target2, condition: c </span>=&gt; c.IsSpam == <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Switch-Case</span>\nbuilder.AddSwitch(source, sb =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> sb\n    .AddCase(c </span>=&gt; c.Decision ==<span style=\"color: rgba(0, 0, 0, 1);\"> NotSpam, target1)\n    .AddCase(c </span>=&gt; c.Decision ==<span style=\"color: rgba(0, 0, 0, 1);\"> Spam, target2)\n    .WithDefault(target3)\n);</span></pre>\n</div>\n<p><span><span><span><span><span><span><span><span><span><span><span><span>可以看到，switch-case模式其价值主要在于增强代码可维护性，对于后续如果有新增分类，只需要添加一个AddCase接口方法实现新增分类的处理，同时基于WithDefault接口方法实现兜底确保所有情况都有处理。</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span><span><span><span><span><span>最后，下面是我们需要重构后的分支路由图：</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202512/381412-20251224202047038-2027515638.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h1><strong>准备工作</strong></h1>\n<p><span><span><span><span><span><span><span><span><span><span><span><span><span>在今天的这个案例中，我们仍然创建了一个.NET控制台应用程序，安装了以下NuGet包：</span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><span>Microsoft.Agents.AI.OpenAI</span></li>\n<li><span>Microsoft.Agents.AI.Workflows</span></li>\n<li><span>Microsoft.Extensions.AI.OpenAI</span></li>\n</ul>\n<p><span><span><span><span><span><span><span><span><span><span><span><span><span>我们的配置文件中定义了LLM API的信息：</span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">{\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">OpenAI</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">: {\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">EndPoint</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">https://api.siliconflow.cn</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ApiKey</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">******************************</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ModelId</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Qwen/Qwen3-30B-A3B-Instruct-2507</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n  }\n}</span></pre>\n</div>\n<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>这里我们使用 SiliconCloud 提供<span><span>的<span><span>&nbsp;<span><span>Qwen/Qwen3-30B-A3B-Instruct-2507&nbsp;<span><span>模型，你<span><span>可以通过这个URL注册账号：<span><span><a href=\"https://cloud.siliconflow.cn/i/DomqCefW\" rel=\"noopener nofollow\" target=\"_blank\">https://cloud.siliconflow.cn/i/DomqCefW</a><span>&nbsp;获取大量免费的Token来进行本次实验。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>然后，我们将配置文件中的API信息读取出来：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> config = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ConfigurationBuilder()\n    .AddJsonFile($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">appsettings.json</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, optional: <span style=\"color: rgba(0, 0, 255, 1);\">false</span>, reloadOnChange: <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    .Build();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> openAIProvider = config.GetSection(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">OpenAI</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).Get&lt;OpenAIProvider&gt;();</pre>\n</div>\n<h2><span>定义数据传输模型</span></h2>\n<p><span><span>首先，我们定义一下在这个工作流中需要生成传递的数据模型：</span></span></p>\n<p><span><span>（1）DetectionResult ：拉件邮件检测结果</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> DetectionResult\n{\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n    <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 检测决策（NotSpam / Spam / Uncertain）\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n    [JsonPropertyName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">spam_decision</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)]\n    [JsonConverter(</span><span style=\"color: rgba(0, 0, 255, 1);\">typeof</span>(JsonStringEnumConverter))]  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> JSON 序列化为字符串</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">public</span> SpamDecision spamDecision { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n    <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 判定理由（用于审计和调试）\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n    [JsonPropertyName(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">reason</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)]\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> Reason { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n    <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 邮件ID（用于关联 Shared State 中的原始内容）\n    </span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    [JsonIgnore]\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> EmailId { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span>; } = <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n}\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">enum</span><span style=\"color: rgba(0, 0, 0, 1);\"> SpamDecision\n{\n    Spam,        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 垃圾邮件</span>\n    NotSpam, <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 正常邮件</span>\n    UnCertain <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 无法确定（需要人工审核）</span>\n}</pre>\n</div>\n<p><span><span>（2）EmailStateConstants ：常量，类似于Cache Key的作用，参考上一篇博客内容。</span></span></p>\n<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>（3）EmailMessage &amp; EmailResponse ：DTO作用，参考上一篇博客内容。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<h2><span>入口节点：垃圾邮件检测Executor</span></h2>\n<p><span><span><span><span>这个垃圾邮件检测是本流程的核心节点，这次我们将其重构为支持三分类：</span></span></span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> SpamDetectionExecutor : Executor&lt;ChatMessage, DetectionResult&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> AIAgent _agent;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentThread _thread;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> SpamDetectionExecutor(AIAgent agent) : <span style=\"color: rgba(0, 0, 255, 1);\">base</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">SpamDetectionExecutor</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建 Agent 和对话线程</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">this</span>._agent =<span style=\"color: rgba(0, 0, 0, 1);\"> agent;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>._thread = <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">._agent.GetNewThread();\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask&lt;DetectionResult&gt; HandleAsync(ChatMessage message, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1️⃣ 生成唯一邮件ID并保存内容到 Shared State</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> trackedEmail = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> EmailMessage\n        {\n            EmailId </span>= Guid.NewGuid().ToString(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">N</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">),\n            EmailContent </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> message.Text\n        };\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> context.QueueStateUpdateAsync(\n            trackedEmail.EmailId,\n            trackedEmail,\n            scopeName: EmailStateConstants.EmailStateScope,\n            cancellationToken\n        );\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2️⃣ 调用 AI Agent 进行三分类检测</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> agentResponse = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> _agent.RunAsync(\n            message,\n            _thread,\n            cancellationToken: cancellationToken\n        );\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3️⃣ 解析结构化输出</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> detection = JsonSerializer.Deserialize&lt;DetectionResult&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(agentResponse.Text)\n            </span>?? <span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> InvalidOperationException(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">无法解析 Spam Detection 响应</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4️⃣ 关联 EmailId（供下游 Executor 查找原始内容）</span>\n        detection.EmailId =<span style=\"color: rgba(0, 0, 0, 1);\"> trackedEmail.EmailId;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> detection;\n    }\n}</span></pre>\n</div>\n<p>在这个Executor中，它接收我们如下所示定义好的Agent来实现：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> spamDetectionAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(\n    chatClient,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgentOptions(\n        instructions: </span><span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">你是一个垃圾邮件检测助手。判定规则：\n- NotSpam: 明显的正常业务邮件（订单查询、售后咨询等）\n- Spam: 明显的垃圾邮件（诈骗、广告、钓鱼）\n- Uncertain: 无法明确判断，包含可疑元素但不确定（如含可疑链接但内容模糊）\n对于模棱两可的情况，倾向于标记为 Uncertain 以保证安全。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    )\n    {\n        ChatOptions </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatOptions\n        {\n            ResponseFormat </span>= ChatResponseFormat.ForJsonSchema&lt;DetectionResult&gt;<span style=\"color: rgba(0, 0, 0, 1);\">()\n        }\n    }\n);</span></pre>\n</div>\n<p>在ChatOptions中指定了该Agent返回的消息需要进行序列化到强类型，便于后续通过强类型数据进行决策路由。</p>\n<h2><span>下游节点A：正常邮件处理+发送</span></h2>\n<p>这里我们针对识别到的正常邮件开发两个执行器，假设其用于邮件处和转发：</p>\n<h3>邮件处理：读取共享状态区的原文，然后调用Agent输出JSON回复。</h3>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> EmailAssistantExecutor : Executor&lt;DetectionResult, EmailResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> AIAgent _agent;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> AgentThread _thread;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> EmailAssistantExecutor(AIAgent agent) : <span style=\"color: rgba(0, 0, 255, 1);\">base</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">EmailAssistantExecutor</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建 Agent 和对话线程</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">this</span>._agent =<span style=\"color: rgba(0, 0, 0, 1);\"> agent;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>._thread = <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">._agent.GetNewThread();\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask&lt;EmailResponse&gt; HandleAsync(DetectionResult message, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 🛡️ 防御性检查：确保只处理正常邮件</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (message.spamDecision ==<span style=\"color: rgba(0, 0, 0, 1);\"> SpamDecision.Spam)\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> InvalidOperationException(\n                </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">EmailAssistantExecutor 不应处理垃圾邮件，请检查路由配置。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n            );\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1️⃣ 从 Shared State 读取原始邮件内容</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> email = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.ReadStateAsync&lt;EmailMessage&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(\n            message.EmailId,\n            scopeName: EmailStateConstants.EmailStateScope,\n            cancellationToken\n        ) </span>?? <span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> InvalidOperationException($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">找不到 EmailId={message.EmailId} 的邮件内容</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2️⃣ 调用 AI Agent 生成回复</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> agentResponse = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> _agent.RunAsync(\n            email.EmailContent,\n            _thread,\n            cancellationToken: cancellationToken\n        );\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3️⃣ 解析结构化输出</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> emailResponse = JsonSerializer.Deserialize&lt;EmailResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(agentResponse.Text)\n            </span>?? <span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> InvalidOperationException(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">无法解析 Email Assistant 响应</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> emailResponse;\n    }\n}</span></pre>\n</div>\n<p>这里的Agent定义如下：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> emailAssistantAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(\n    chatClient,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgentOptions(\n        instructions: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">你是一个企业邮件助手，为客户邮件生成专业、友好的中文回复。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    )\n    {\n        ChatOptions </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatOptions\n        {\n            ResponseFormat </span>= ChatResponseFormat.ForJsonSchema&lt;EmailResponse&gt;<span style=\"color: rgba(0, 0, 0, 1);\">()\n        }\n    }\n);</span></pre>\n</div>\n<h3><span>邮件转发：模拟邮件转发到具体的客服，这里仅仅使用YieldOutputAsync完成工作流输出消息内容。</span></h3>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> EmailSendingExecutor() : Executor&lt;EmailResponse&gt;(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">EmailSendingExecutor</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask HandleAsync(EmailResponse message, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 模拟邮件发送（实际项目中可调用 SMTP、SendGrid 等服务）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> context.YieldOutputAsync(\n            $</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📤 邮件已发送: {message.Response}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            cancellationToken\n        );\n    }\n}</span></pre>\n</div>\n<h2><span>下游节点B：垃圾邮件处理</span></h2>\n<p>当判断到是垃圾邮件时，转交给该执行器处理，这里模拟输出了一段风险提示，实际中可能是上报人工跟进等等操作：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">sealed</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> SpamHandlingExecutor() : Executor&lt;DetectionResult&gt;(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">SpamHandlingExecutor</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask HandleAsync(DetectionResult message, IWorkflowContext context, CancellationToken cancellationToken = <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 🛡️ 防御性检查：确保只处理垃圾邮件</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (message.spamDecision !=<span style=\"color: rgba(0, 0, 0, 1);\"> SpamDecision.Spam)\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> InvalidOperationException(\n                </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">SpamHandlingExecutor 只应处理 Spam 类型的邮件，请检查路由配置。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n            );\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 记录垃圾邮件（实际项目中可写入数据库或日志系统）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> context.YieldOutputAsync(\n            $</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">🚫 垃圾邮件已拦截: {message.Reason}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            cancellationToken\n        );\n    }\n}</span></pre>\n</div>\n<h2><span>下游节点C：<span><span>不确定邮件处理执行器（兜底处理）</span></span></span></h2>\n<p>当判断到属于不确定的邮件分类时，转交给该执行器做兜底处理 或 默认处理：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> UncertainHandlingExecutor() : Executor&lt;DetectionResult&gt;(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">UncertainHandlingExecutor</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span><span style=\"color: rgba(0, 0, 0, 1);\"> ValueTask HandleAsync(\n        DetectionResult message,\n        IWorkflowContext context,\n        CancellationToken cancellationToken </span>= <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 🛡️ 防御性检查：确保只处理不确定邮件</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (message.spamDecision !=<span style=\"color: rgba(0, 0, 0, 1);\"> SpamDecision.UnCertain)\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> InvalidOperationException(\n                </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">UncertainHandlingExecutor 只应处理 Uncertain 类型的邮件（或作为 Default Case）。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n            );\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1️⃣ 从 Shared State 读取原始邮件内容（用于人工审核）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">var</span> email = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> context.ReadStateAsync&lt;EmailMessage&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(\n            message.EmailId,\n            scopeName: EmailStateConstants.EmailStateScope,\n            cancellationToken\n        );\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2️⃣ 输出待审核信息</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> context.YieldOutputAsync(\n            $</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">⚠️ 不确定邮件需人工审核:\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> +<span style=\"color: rgba(0, 0, 0, 1);\">\n            $</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">原因: {message.Reason}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> +<span style=\"color: rgba(0, 0, 0, 1);\">\n            $</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">内容预览: {email?.EmailContent?.Substring(0, Math.Min(100, email.EmailContent.Length))}...</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            cancellationToken\n        );\n    }\n}</span></pre>\n</div>\n<h2>构建工作流</h2>\n<p>现在万事俱备，只欠一个Workflow，现在Let's do it!</p>\n<p><strong>Step1:</strong> 获取ChatClient</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> chatClient = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> OpenAIClient(\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ApiKeyCredential(openAIProvider.ApiKey),\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> OpenAIClientOptions { Endpoint = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Uri(openAIProvider.Endpoint) })\n    .GetChatClient(openAIProvider.ModelId)\n    .AsIChatClient();</span></pre>\n</div>\n<p><strong><span><span>Step2<span>: </span></span></span></strong>实例化自定义Agent &amp; Executors</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> spamDetectionExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> SpamDetectionExecutor(spamDetectionAgent);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> emailAssistantExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> EmailAssistantExecutor(emailAssistantAgent);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> sendEmailExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> EmailSendingExecutor();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> handleSpamExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> SpamHandlingExecutor();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> handleUncertainExecutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> UncertainHandlingExecutor();</pre>\n</div>\n<p><strong><span><span>Step3<span>: </span></span></span></strong>创建switch-case多路由决策工作流</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 🔧 条件函数工厂方法\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span>\nFunc&lt;<span style=\"color: rgba(0, 0, 255, 1);\">object</span>?, <span style=\"color: rgba(0, 0, 255, 1);\">bool</span>&gt; GetCondition(SpamDecision expectedDecision) =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n    detectionResult </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n        detectionResult </span><span style=\"color: rgba(0, 0, 255, 1);\">is</span> DetectionResult result &amp;&amp;<span style=\"color: rgba(0, 0, 0, 1);\">\n        result.spamDecision </span>==<span style=\"color: rgba(0, 0, 0, 1);\"> expectedDecision;\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 🔀 使用 AddSwitch 构建 Switch-Case 工作流\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> builder = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowBuilder(spamDetectionExecutor);\nbuilder.AddSwitch(spamDetectionExecutor, sb </span>=&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n        sb\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Case 1: NotSpam → EmailAssistant </span>\n            .AddCase(GetCondition(expectedDecision: SpamDecision.NotSpam), <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">[] { (ExecutorBinding)emailAssistantExecutor })\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Case 2: Spam → HandleSpam</span>\n            .AddCase(GetCondition(expectedDecision: SpamDecision.Spam), <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">[] { (ExecutorBinding)handleSpamExecutor })\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Default: Uncertain (或任何未匹配的情况) → HandleUncertain</span>\n            .WithDefault(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">[] { (ExecutorBinding)handleUncertainExecutor })\n    )\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> EmailAssistant 之后自动发送邮件</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    .AddEdge(emailAssistantExecutor, sendEmailExecutor)\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 配置输出节点（三个终点执行器都会产生输出）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    .WithOutputFrom(handleSpamExecutor, sendEmailExecutor, handleUncertainExecutor);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> builder.Build();\n\nConsole.OutputEncoding </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Encoding.UTF8;\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ Conditional Workflow 构建完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<h2>测试工作流</h2>\n<p>首先，为了便于后续测试我们将执行工作流封装为一个静态方法：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span><span style=\"color: rgba(0, 0, 0, 1);\"> Task RunWorkflowAsync(\n    Workflow workflow,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> scenarioName,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> emailContent)\n{\n    Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📬 测试场景：{scenarioName}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📧 邮件内容：{emailContent.Substring(0, Math.Min(80, emailContent.Length))}...\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> <span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span> run = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> InProcessExecution.StreamAsync(\n        workflow,\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatMessage(ChatRole.User, emailContent)\n    );\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 发送 Turn Token，启用事件推送</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">await</span> run.TrySendMessageAsync(<span style=\"color: rgba(0, 0, 255, 1);\">new</span> TurnToken(emitEvents: <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 订阅事件流</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">await</span> <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (WorkflowEvent evt <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> run.WatchStreamAsync())\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">switch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (evt)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> ExecutorCompletedEvent completedEvent:\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ {completedEvent.ExecutorId} 完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowOutputEvent outputEvent:\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">🎉 工作流执行完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{outputEvent.Data}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> WorkflowErrorEvent errorEvent:\n                Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✨ 收到 Workflow Error Event：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{errorEvent.Data}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n    }\n    Console.WriteLine();\n}</span></pre>\n</div>\n<p><strong>测试用例1：</strong>正常咨询邮件输入</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> scenarioName1 = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">正常邮件 → EmailAssistant → SendEmail</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> emailContent1 = <span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\n尊敬的客服团队：\n您好！我是贵公司的长期客户，订单号为 \n#2025\n-001。\n我想确认一下上周提交的采购订单是否已经安排发货。\n如果需要补充任何信息，请随时告知。\n期待您的回复，谢谢！\n客户：张先生\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> RunWorkflowAsync(workflow, scenarioName1, emailContent1);\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ 正常邮件路径验证完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<p>测试结果如下图所示：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202512/381412-20251224202754097-83329301.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可以看见，对于正常咨询邮件，进行正常的邮件处理和转发。</p>\n<p><strong>测试用例2：</strong>垃圾邮件输入</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> scenarioName2 = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">垃圾邮件 → HandleSpam</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> emailContent2 = <span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\n🎉🎉🎉 恭喜您中奖啦！🎉🎉🎉\n\n您已被选中获得 100 万现金大奖！\n\n立即点击以下链接领取：\nhttp://suspicious-site.com/claim-prize\n\n仅限今日有效，过期作废！\n不需要任何手续费，完全免费！\n\n快速行动，机不可失！\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> RunWorkflowAsync(workflow, scenarioName2, emailContent2);\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ 垃圾邮件路径验证完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<p>测试结果如下图所示：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202512/381412-20251224202904798-37631196.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可以看见，对于垃圾邮件，进行有效的拦截，后续还可以进行上报人工跟踪等等。</p>\n<p><strong>测试用例3：</strong>无法确认类型的邮件输入</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> uncertainEmail = <span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\n主题：需要验证您的账户\n尊敬的客户：\n我们检测到您的账户存在异常活动，需要验证您的身份以确保账户安全。\n请登录您的账户并完成验证流程，以继续使用服务。\n账户详情：\n- 用户名：johndoe@contoso.com\n- 最后登录：08/15/2025\n- 登录地点：西雅图，华盛顿州\n- 登录设备：移动设备\n这是一项自动安全措施。如果您认为此邮件是错误发送的，请立即联系我们的支持团队。\n此致\n安全团队\n客户服务部门\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> RunWorkflowAsync(\n    workflow,\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">不确定邮件 → HandleUncertain (Default)</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    uncertainEmail\n);\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ 不确定邮件路径验证完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<p>测试结果如下图所示：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202512/381412-20251224202940842-749043447.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可以看到，对于LLM无法确认的类型，进入了该执行器，这时可能需要人工介入审核。同时，这也是实际中常见的一种兜底机制的展现，话句话说：<strong>即使AI无法明确判断，也应该有对应的处理流程</strong>。</p>\n<h1><strong><span>小结</span></strong></h1>\n<p>本文介绍了MAF中的switch-case路由以及如何实现多条件路由，最后优化了上一篇的企业内部邮件检测工作流案例，特别适合于大于3个分支的复杂路由场景。</p>\n<p>下一篇，我们将继续学习MAF中工作流的循环工作流。</p>\n<h1>参考资料</h1>\n<p><span><span>圣杰，《<a href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\">.NET + AI 智能体开发进阶</a>》（推荐指数：★★★★★）</span></span></p>\n<p><span><span>Microsoft Learn，<span>《<a href=\"https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview?wt.mc_id=MVP_397012\" rel=\"noopener nofollow\" target=\"_blank\">Agent Framework Tutorials</a>》</span></span></span></p>\n<div><span><span>&nbsp;</span></span></div>\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://images.cnblogs.com/cnblogs_com/edisonchou/1647700/o_200902144330EdisonTalk-Footer.jpg\" /></p>\n<div id=\"Copyright\">\n<p>作者：<span style=\"text-decoration: underline;\">爱迪生</span></p>\n<p>出处：<a href=\"https://edisontalk.cnblogs.com\" target=\"_blank\" title=\"from\">https://edisontalk.cnblogs.com</a></p>\n<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。</p>\n</div>\n</div>\n<div id=\"MySignature\">\n    <div align=\"center\"><a href=\"https://weibo.com/u/2068032061?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/2068032061/d643d182/10.png\" /></a></div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 18:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/edisontalk\">EdisonZhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">49</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "写给前端的股票行情 SDK: stock-sdk，终于不用再求后端帮忙了",
      "link": "https://www.cnblogs.com/chengzp/p/19417561/stock-sdk",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chengzp/p/19417561/stock-sdk\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 18:16\">\n    <span>写给前端的股票行情 SDK: stock-sdk，终于不用再求后端帮忙了</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"写给前端的股票行情 SDK: stock-sdk，终于不用再求后端帮忙了\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1265396/202512/1265396-20251229181351247-1080670278.png\" />\n        作者自己动手写了一个 JavaScript/TypeScript 版本的股票行情 SDK。文章介绍了这个 SDK 能获取 A 股、港股、美股的实时行情和 K 线数据，还内置了常用的技术指标计算，支持浏览器和 Node.js 双端运行，适合用来做行情看板、数据可视化、量化验证这类项目。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>用 JavaScript 获取股票数据，真的有这么难吗？</p>\n</blockquote>\n<h2 id=\"起因\">起因</h2>\n<p>说实话，这个项目的诞生完全是被逼出来的。</p>\n<p>去年我想做一个股票行情看板，就是那种简单的页面，能实时显示几只自选股的涨跌。听起来很简单对吧？但当我真正开始动手的时候，才发现事情没那么简单。</p>\n<p>网上搜一圈，股票数据接口相关的工具几乎全是 Python 的。AkShare、Tushare、掘金量化……确实牛，功能也确实全，但问题是——<strong>我是个前端啊</strong>。</p>\n<p>为了一个小看板，难道要我专门搭一个 Python 后端？再写个接口转发给前端？这也太折腾了。</p>\n<p>于是我开始找有没有 JavaScript 能用的方案。结果你猜怎么着？翻遍了 npm，几乎找不到一个好用的。有的年久失修，有的只支持 Node.js 不支持浏览器，有的类型支持一塌糊涂，还有的接口莫名其妙就挂了。</p>\n<p>摸索了一圈之后，我决定：<strong>算了，自己写一个得了。</strong></p>\n<h2 id=\"stock-sdk-是什么\">stock-sdk 是什么？</h2>\n<p>简单说，<strong>stock-sdk</strong> 就是一个专门给前端和 Node.js 用的股票行情 SDK。</p>\n<p>核心目标就一个：让你用最熟悉的 JavaScript / TypeScript，10 行代码搞定股票数据获取。</p>\n<pre><code class=\"language-ts\">import { StockSDK } from 'stock-sdk';\n\nconst sdk = new StockSDK();\n\nconst quotes = await sdk.getSimpleQuotes(['sh000001', 'sz000858', 'sh600519']);\n\nquotes.forEach(q =&gt; {\n  console.log(`${q.name}: ${q.price} (${q.changePercent}%)`);\n});\n</code></pre>\n<p>就这么简单。不用搭后端，不用装 Python，浏览器里直接跑。</p>\n<h2 id=\"它能干什么\">它能干什么？</h2>\n<p>写到现在，功能已经比较齐全了：</p>\n<p><strong>行情数据</strong></p>\n<ul>\n<li>A 股、港股、美股、公募基金的实时行情</li>\n<li>历史 K 线（日线、周线、月线）</li>\n<li>分钟 K 线（1 分钟到 60 分钟都支持）</li>\n<li>当日分时走势</li>\n</ul>\n<p><strong>板块数据</strong></p>\n<ul>\n<li>行业板块、概念板块的列表和实时行情</li>\n<li>板块成分股</li>\n<li>板块 K 线数据</li>\n</ul>\n<p><strong>技术指标</strong></p>\n<ul>\n<li>内置 MA、MACD、BOLL、KDJ、RSI 等常用指标</li>\n<li>一个接口搞定 K 线 + 指标计算</li>\n</ul>\n<p><strong>扩展数据</strong></p>\n<ul>\n<li>资金流向</li>\n<li>盘口大单</li>\n<li>A 股交易日历</li>\n</ul>\n<p><strong>批量能力</strong></p>\n<ul>\n<li>一次性获取全市场 5000+ 只 A 股行情</li>\n<li>内置并发控制，不会把接口打挂</li>\n<li>进度回调，知道当前拉取到哪里了</li>\n</ul>\n<h2 id=\"为什么要用它\">为什么要用它？</h2>\n<p>说实话，这个问题我自己也想过很久。毕竟市面上不是没有其他方案。</p>\n<p>但仔细想想，stock-sdk 确实解决了一些痛点：</p>\n<p><strong>1. 零依赖，真的很小</strong></p>\n<p>压缩后不到 20KB。没有乱七八糟的依赖，不会给你的项目增加额外负担。</p>\n<p><strong>2. 浏览器和 Node.js 都能跑</strong></p>\n<p>这个是我一开始就确定的设计目标。不管你是做 Web 页面还是 Node.js 脚本，都能直接用。同时提供 ESM 和 CommonJS 两种格式，现代项目和老项目都兼容。</p>\n<p><strong>3. TypeScript 类型完整</strong></p>\n<p>说真的，类型提示这个东西，用过就回不去了。每个接口返回什么字段、每个参数是什么类型，IDE 里一目了然。写代码的时候不用反复查文档。</p>\n<p><strong>4. 接口稳定</strong></p>\n<p>数据源用的是腾讯财经和东方财富的公开接口，稳定性还是有保障的。而且我做了比较完善的错误处理，不会因为某个请求失败就整个崩掉。</p>\n<h2 id=\"适合什么场景\">适合什么场景？</h2>\n<p>这个 SDK 不是万能的，我也不打算把它做成大而全的东西。它比较适合这些场景：</p>\n<ul>\n<li><strong>股票看板</strong>：做一个自选股页面，看看涨跌</li>\n<li><strong>数据可视化</strong>：用 ECharts 或者 TradingView 画 K 线图</li>\n<li><strong>学习 Demo</strong>：金融课程、量化入门的演示项目</li>\n<li><strong>量化验证</strong>：快速验证一个交易策略的想法</li>\n<li><strong>定时脚本</strong>：Node.js 定时抓取行情数据</li>\n</ul>\n<p>如果你需要更专业的量化回测、高频交易之类的，这个 SDK 可能就不太够用了。那种场景还是 Python 生态更成熟。</p>\n<h2 id=\"一些实际的例子\">一些实际的例子</h2>\n<p><strong>获取全市场 A 股行情</strong></p>\n<pre><code class=\"language-ts\">const allQuotes = await sdk.getAllAShareQuotes({\n  batchSize: 300,\n  concurrency: 5,\n  onProgress: (completed, total) =&gt; {\n    console.log(`进度: ${completed}/${total}`);\n  },\n});\n\nconsole.log(`共获取 ${allQuotes.length} 只股票`);\n</code></pre>\n<p>5000 多只股票，几秒钟就拉完了。并发控制是内置的，不用自己操心。</p>\n<p><strong>获取带技术指标的 K 线</strong></p>\n<pre><code class=\"language-ts\">const data = await sdk.getKlineWithIndicators('sh600519', {\n  period: 'daily',\n  count: 100,\n  indicators: {\n    ma: { periods: [5, 10, 20] },\n    macd: true,\n    boll: true,\n  },\n});\n\n// data.kline 是原始 K 线\n// data.indicators.ma 是均线数据\n// data.indicators.macd 是 MACD 数据\n// data.indicators.boll 是布林带数据\n</code></pre>\n<p>一个接口把 K 线和指标都算好了，直接拿去画图就行。</p>\n<h2 id=\"写在最后\">写在最后</h2>\n<p>这个项目从去年开始写，断断续续维护到现在，功能也越来越完善了。</p>\n<p>其实我一直觉得，工具这个东西，好不好用自己最清楚。stock-sdk 就是我自己在用的东西，遇到问题就修，需要新功能就加。</p>\n<p>如果你也是前端，也需要获取股票数据，不妨试试。有问题欢迎提 Issue，我会尽量响应。</p>\n<hr />\n<p><strong>相关链接</strong></p>\n<ul>\n<li>📦 <a href=\"https://www.npmjs.com/package/stock-sdk\" rel=\"noopener nofollow\" target=\"_blank\">NPM</a></li>\n<li>📖 <a href=\"https://github.com/chengzuopeng/stock-sdk\" rel=\"noopener nofollow\" target=\"_blank\">GitHub</a></li>\n<li>🌐 <a href=\"https://stock-sdk.linkdiary.cn/\" rel=\"noopener nofollow\" target=\"_blank\">官方文档</a></li>\n<li>🎮 <a href=\"https://stock-sdk.linkdiary.cn/playground/\" rel=\"noopener nofollow\" target=\"_blank\">在线演示</a></li>\n</ul>\n<p>安装就一行命令：</p>\n<pre><code class=\"language-bash\">npm install stock-sdk\n</code></pre>\n<p>如果觉得还不错，给个 Star ⭐ 呗~</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 18:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chengzp\">程序猿的程</a>&nbsp;\n阅读(<span id=\"post_view_count\">160</span>)&nbsp;\n评论(<span id=\"post_comment_count\">3</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为什么大厂一般不推荐使用@Transactional？",
      "link": "https://www.cnblogs.com/12lisu/p/19420241",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19420241\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 11:18\">\n    <span>为什么大厂一般不推荐使用@Transactional？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>对于从事java开发工作的同学来说，Spring的事务肯定再熟悉不过了。</p>\n<p>在某些业务场景下，如果一个请求中，需要同时写入多张表的数据。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到Spring事务。</p>\n<p>确实，Spring事务用起来贼爽，就用一个简单的注解：<code>@Transactional</code>，就能轻松搞定事务。我猜大部分小伙伴也是这样用的，而且一直用一直爽。</p>\n<p>但如果你使用不当，它也会坑你于无形。</p>\n<p>今天我们就一起聊聊，事务失效的一些场景，说不定你已经中招了。不信，让我们一起看看。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"一-事务不生效\">一 事务不生效</h2>\n<h3 id=\"1访问权限问题\">1.访问权限问题</h3>\n<p>众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。</p>\n<p>但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：</p>\n<pre><code class=\"language-java\">@Service\npublic class UserService {\n    \n    @Transactional\n    private void add(UserModel userModel) {\n         saveData(userModel);\n         updateData(userModel);\n    }\n}\n</code></pre>\n<p>我们可以看到add方法的访问权限被定义成了<code>private</code>，这样会导致事务失效，spring要求被代理方法必须是<code>public</code>的。</p>\n<p>说白了，在<code>AbstractFallbackTransactionAttributeSource</code>类的<code>computeTransactionAttribute</code>方法中有个判断，如果目标方法不是public，则<code>TransactionAttribute</code>返回null，即不支持事务。</p>\n<pre><code class=\"language-java\">protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) {\n    // Don't allow no-public methods as required.\n    if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {\n      return null;\n    }\n\n    // The method may be on an interface, but we need attributes from the target class.\n    // If the target class is null, the method will be unchanged.\n    Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);\n\n    // First try is the method in the target class.\n    TransactionAttribute txAttr = findTransactionAttribute(specificMethod);\n    if (txAttr != null) {\n      return txAttr;\n    }\n\n    // Second try is the transaction attribute on the target class.\n    txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());\n    if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {\n      return txAttr;\n    }\n\n    if (specificMethod != method) {\n      // Fallback is to look at the original method.\n      txAttr = findTransactionAttribute(method);\n      if (txAttr != null) {\n        return txAttr;\n      }\n      // Last fallback is the class of the original method.\n      txAttr = findTransactionAttribute(method.getDeclaringClass());\n      if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {\n        return txAttr;\n      }\n    }\n    return null;\n  }\n</code></pre>\n<p>也就是说，如果我们自定义的事务方法（即目标方法），它的访问权限不是<code>public</code>，而是private、default或protected的话，spring则不会提供事务功能。</p>\n<h3 id=\"2-方法用final修饰\">2. 方法用final修饰</h3>\n<p>有时候，某个方法不想被子类重新，这时可以将该方法定义成final的。普通方法这样定义是没问题的，但如果将事务方法定义成final，例如：</p>\n<pre><code class=\"language-java\">@Service\npublic class UserService {\n\n    @Transactional\n    public final void add(UserModel userModel){\n        saveData(userModel);\n        updateData(userModel);\n    }\n}\n</code></pre>\n<p>我们可以看到add方法被定义成了<code>final</code>的，这样会导致事务失效。</p>\n<p>为什么？</p>\n<p>如果你看过spring事务的源码，可能会知道spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。</p>\n<p>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。</p>\n<blockquote>\n<p>注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p>\n</blockquote>\n<h3 id=\"3方法内部调用\">3.方法内部调用</h3>\n<p>有时候我们需要在某个Service类的某个方法中，调用另外一个事务方法，比如：</p>\n<pre><code class=\"language-java\">@Service\npublic class UserService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    //@Transactional\n    public void add(UserModel userModel) {\n        userMapper.insertUser(userModel);\n        updateStatus(userModel);\n    }\n\n    @Transactional\n    public void updateStatus(UserModel userModel) {\n        doSameThing();\n    }\n}\n</code></pre>\n<p>我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。</p>\n<p>由此可见，在同一个类中的方法直接内部调用，会导致事务失效。</p>\n<p>那么问题来了，如果有些场景，确实想在同一个类的某个方法中，调用它自己的另外一个方法，该怎么办呢？</p>\n<h4 id=\"31-新加一个service方法\">3.1 新加一个Service方法</h4>\n<p>这个方法非常简单，只需要新加一个Service方法，把@Transactional注解加到新Service方法上，把需要事务执行的代码移到新方法中。具体代码如下：</p>\n<pre><code class=\"language-java\">@Servcie\npublic class ServiceA {\n   @Autowired\n   prvate ServiceB serviceB;\n\n   public void save(User user) {\n         queryData1();\n         queryData2();\n         serviceB.doSave(user);\n   }\n }\n\n @Servcie\n public class ServiceB {\n\n    @Transactional(rollbackFor=Exception.class)\n    public void doSave(User user) {\n       addData1();\n       updateData2();\n    }\n\n }\n</code></pre>\n<h4 id=\"32-在该service类中注入自己\">3.2 在该Service类中注入自己</h4>\n<p>如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：</p>\n<pre><code class=\"language-java\">@Servcie\npublic class ServiceA {\n   @Autowired\n   prvate ServiceA serviceA;\n\n   public void save(User user) {\n         queryData1();\n         queryData2();\n         serviceA.doSave(user);\n   }\n\n   @Transactional(rollbackFor=Exception.class)\n   public void doSave(User user) {\n       addData1();\n       updateData2();\n    }\n }\n</code></pre>\n<p>可能有些人可能会有这样的疑问：这种做法会不会出现循环依赖问题？</p>\n<p>答案：不会。</p>\n<p>其实spring ioc内部的三级缓存保证了它，不会出现循环依赖问题。但有些坑，如果你想进一步了解循环依赖问题，可以看看我之前文章《<a href=\"https://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;mid=2247485600&amp;idx=1&amp;sn=0c49b94e7fbd35c88c4470e936023e3e&amp;chksm=f9800e7acef7876ca05ab45ce9420ea140f188e84153f23d0af9d044f475458ad38d49a6546a&amp;token=1641046204&amp;lang=zh_CN#rd\" rel=\"noopener nofollow\" target=\"_blank\">spring：我是如何解决循环依赖的？</a>》。</p>\n<h4 id=\"33-通过aopcontent类\">3.3 通过AopContent类</h4>\n<p>在该Service类中使用AopContext.currentProxy()获取代理对象</p>\n<p>上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用AOPProxy获取代理对象，实现相同的功能。具体代码如下：</p>\n<pre><code class=\"language-java\">@Servcie\npublic class ServiceA {\n\n   public void save(User user) {\n         queryData1();\n         queryData2();\n         ((ServiceA)AopContext.currentProxy()).doSave(user);\n   }\n\n   @Transactional(rollbackFor=Exception.class)\n   public void doSave(User user) {\n       addData1();\n       updateData2();\n    }\n }\n</code></pre>\n<h3 id=\"4未被spring管理\">4.未被spring管理</h3>\n<p>在我们平时开发过程中，有个细节很容易被忽略。即使用spring事务的前提是：对象要被spring管理，需要创建bean实例。</p>\n<p>通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。</p>\n<p>当然创建bean实例的方法还有很多，有兴趣的小伙伴可以看看我之前写的另一篇文章《<a href=\"https://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;mid=2247488466&amp;idx=1&amp;sn=1e63e6991b5fb47e067d2edf055981d3&amp;chksm=f9801508cef79c1ea208906ceef09593a9f594b3926478eb65b7ef64e0311f13ac5aaf4135ce&amp;token=1641046204&amp;lang=zh_CN#rd\" rel=\"noopener nofollow\" target=\"_blank\">@Autowired的这些骚操作，你都知道吗？</a>》</p>\n<p>如果有一天，你匆匆忙忙的开发了一个Service类，但忘了加@Service注解，比如：</p>\n<pre><code class=\"language-java\">//@Service\npublic class UserService {\n\n    @Transactional\n    public void add(UserModel userModel) {\n         saveData(userModel);\n         updateData(userModel);\n    }    \n}\n</code></pre>\n<p>从上面的例子，我们可以看到UserService类没有加<code>@Service</code>注解，那么该类不会交给spring管理，所以它的add方法也不会生成事务。</p>\n<h3 id=\"5多线程调用\">5.多线程调用</h3>\n<p>在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？</p>\n<pre><code class=\"language-java\">@Slf4j\n@Service\npublic class UserService {\n\n    @Autowired\n    private UserMapper userMapper;\n    @Autowired\n    private RoleService roleService;\n\n    @Transactional\n    public void add(UserModel userModel) throws Exception {\n        userMapper.insertUser(userModel);\n        new Thread(() -&gt; {\n            roleService.doOtherThing();\n        }).start();\n    }\n}\n\n@Service\npublic class RoleService {\n\n    @Transactional\n    public void doOtherThing() {\n        System.out.println(\"保存role表数据\");\n    }\n}\n</code></pre>\n<p>从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。</p>\n<p>这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。</p>\n<p>如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。</p>\n<pre><code class=\"language-java\">private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =\n\n  new NamedThreadLocal&lt;&gt;(\"Transactional resources\");\n</code></pre>\n<p>我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。</p>\n<h3 id=\"6表不支持事务\">6.表不支持事务</h3>\n<p>周所周知，在mysql5之前，默认的数据库引擎是<code>myisam</code>。</p>\n<p>它的好处就不用多说了：索引文件和数据文件是分开存储的，对于查多写少的单表操作，性能比innodb更好。</p>\n<p>有些老项目中，可能还在用它。</p>\n<p>在创建表的时候，只需要把<code>ENGINE</code>参数设置成<code>MyISAM</code>即可：</p>\n<pre><code class=\"language-java\">CREATE TABLE `category` (\n  `id` bigint NOT NULL AUTO_INCREMENT,\n  `one_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,\n  `two_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,\n  `three_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,\n  `four_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin\n</code></pre>\n<p>myisam好用，但有个很致命的问题是：<code>不支持事务</code>。</p>\n<p>如果只是单表操作还好，不会出现太大的问题。但如果需要跨多张表操作，由于其不支持事务，数据极有可能会出现不完整的情况。</p>\n<p>此外，myisam还不支持行锁和外键。</p>\n<p>所以在实际业务场景中，myisam使用的并不多。在mysql5以后，myisam已经逐渐退出了历史的舞台，取而代之的是innodb。</p>\n<blockquote>\n<p>有时候我们在开发的过程中，发现某张表的事务一直都没有生效，那不一定是spring事务的锅，最好确认一下你使用的那张表，是否支持事务。</p>\n</blockquote>\n<h3 id=\"7未开启事务\">7.未开启事务</h3>\n<p>有时候，事务没有生效的根本原因是没有开启事务。</p>\n<p>你看到这句话可能会觉得好笑。</p>\n<p>开启事务不是一个项目中，最最最基本的功能吗？</p>\n<p>为什么还会没有开启事务？</p>\n<p>没错，如果项目已经搭建好了，事务功能肯定是有的。</p>\n<p>但如果你是在搭建项目demo的时候，只有一张表，而这张表的事务没有生效。那么会是什么原因造成的呢？</p>\n<p>当然原因有很多，但没有开启事务，这个原因极其容易被忽略。</p>\n<p>如果你使用的是springboot项目，那么你很幸运。因为springboot通过<code>DataSourceTransactionManagerAutoConfiguration</code>类，已经默默的帮你开启了事务。</p>\n<p>你所要做的事情很简单，只需要配置<code>spring.datasource</code>相关参数即可。</p>\n<p>但如果你使用的还是传统的spring项目，则需要在applicationContext.xml文件中，手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。</p>\n<p>具体配置如下信息：</p>\n<pre><code class=\"language-java\">   \n&lt;!-- 配置事务管理器 --&gt; \n&lt;bean class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\" id=\"transactionManager\"&gt; \n    &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; \n&lt;/bean&gt; \n&lt;tx:advice id=\"advice\" transaction-manager=\"transactionManager\"&gt; \n    &lt;tx:attributes&gt; \n        &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt;\n    &lt;/tx:attributes&gt; \n&lt;/tx:advice&gt; \n&lt;!-- 用切点把事务切进去 --&gt; \n&lt;aop:config&gt; \n    &lt;aop:pointcut expression=\"execution(* com.susan.*.*(..))\" id=\"pointcut\"/&gt; \n    &lt;aop:advisor advice-ref=\"advice\" pointcut-ref=\"pointcut\"/&gt; \n&lt;/aop:config&gt; \n</code></pre>\n<p>默默的说一句，如果在pointcut标签中的切入点匹配规则，配错了的话，有些类的事务也不会生效。</p>\n<h2 id=\"二-事务不回滚\">二 事务不回滚</h2>\n<h3 id=\"1错误的传播特性\">1.错误的传播特性</h3>\n<p>其实，我们在使用<code>@Transactional</code>注解时，是可以指定<code>propagation</code>参数的。</p>\n<p>该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：</p>\n<ul>\n<li><code>REQUIRED</code> 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。</li>\n<li><code>SUPPORTS</code> 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。</li>\n<li><code>MANDATORY</code> 如果当前上下文中存在事务，否则抛出异常。</li>\n<li><code>REQUIRES_NEW</code> 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。</li>\n<li><code>NOT_SUPPORTED</code> 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。</li>\n<li><code>NEVER</code> 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。</li>\n<li><code>NESTED</code> 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。</li>\n</ul>\n<p>如果我们在手动设置propagation参数的时候，把传播特性设置错了，比如：</p>\n<pre><code class=\"language-java\">@Service\npublic class UserService {\n\n    @Transactional(propagation = Propagation.NEVER)\n    public void add(UserModel userModel) {\n        saveData(userModel);\n        updateData(userModel);\n    }\n}\n</code></pre>\n<p>我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。</p>\n<p>目前只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。</p>\n<h3 id=\"2自己吞了异常\">2.自己吞了异常</h3>\n<p>事务不会回滚，最常见的问题是：开发者在代码中手动try...catch了异常。比如：</p>\n<pre><code class=\"language-java\">@Slf4j\n@Service\npublic class UserService {\n    \n    @Transactional\n    public void add(UserModel userModel) {\n        try {\n            saveData(userModel);\n            updateData(userModel);\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        }\n    }\n}\n</code></pre>\n<p>这种情况下spring事务当然不会回滚，因为开发者自己捕获了异常，又没有手动抛出，换句话说就是把异常吞掉了。</p>\n<p>如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p>\n<h3 id=\"3手动抛了别的异常\">3.手动抛了别的异常</h3>\n<p>即使开发者没有手动捕获异常，但如果抛的异常不正确，spring事务也不会回滚。</p>\n<pre><code class=\"language-java\">@Slf4j\n@Service\npublic class UserService {\n    \n    @Transactional\n    public void add(UserModel userModel) throws Exception {\n        try {\n             saveData(userModel);\n             updateData(userModel);\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n            throw new Exception(e);\n        }\n    }\n}\n</code></pre>\n<p>上面的这种情况，开发人员自己捕获了异常，又手动抛出了异常：Exception，事务同样不会回滚。</p>\n<p>因为spring事务，默认情况下只会回滚<code>RuntimeException</code>（运行时异常）和<code>Error</code>（错误），对于普通的Exception（非运行时异常），它不会回滚。</p>\n<h3 id=\"4自定义了回滚异常\">4.自定义了回滚异常</h3>\n<p>在使用@Transactional注解声明事务时，有时我们想自定义回滚的异常，spring也是支持的。可以通过设置<code>rollbackFor</code>参数，来完成这个功能。</p>\n<p>但如果这个参数的值设置错了，就会引出一些莫名其妙的问题，例如：</p>\n<pre><code class=\"language-java\">@Slf4j\n@Service\npublic class UserService {\n    \n    @Transactional(rollbackFor = BusinessException.class)\n    public void add(UserModel userModel) throws Exception {\n       saveData(userModel);\n       updateData(userModel);\n    }\n}\n</code></pre>\n<p>如果在执行上面这段代码，保存和更新数据时，程序报错了，抛了SqlException、DuplicateKeyException等异常。而BusinessException是我们自定义的异常，报错的异常不属于BusinessException，所以事务也不会回滚。</p>\n<p>即使rollbackFor有默认值，但阿里巴巴开发者规范中，还是要求开发者重新指定该参数。</p>\n<p>这是为什么呢？</p>\n<p>因为如果使用默认值，一旦程序抛出了Exception，事务不会回滚，这会出现很大的bug。所以，建议一般情况下，将该参数设置成：Exception或Throwable。</p>\n<h3 id=\"5嵌套事务回滚多了\">5.嵌套事务回滚多了</h3>\n<pre><code class=\"language-java\">public class UserService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Autowired\n    private RoleService roleService;\n\n    @Transactional\n    public void add(UserModel userModel) throws Exception {\n        userMapper.insertUser(userModel);\n        roleService.doOtherThing();\n    }\n}\n\n@Service\npublic class RoleService {\n\n    @Transactional(propagation = Propagation.NESTED)\n    public void doOtherThing() {\n        System.out.println(\"保存role表数据\");\n    }\n}\n</code></pre>\n<p>这种情况使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点。。但事实是，insertUser也回滚了。</p>\n<p>why?</p>\n<p>因为doOtherThing方法出现了异常，没有手动捕获，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。</p>\n<p>怎么样才能只回滚保存点呢？</p>\n<pre><code class=\"language-java\">@Slf4j\n@Service\npublic class UserService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Autowired\n    private RoleService roleService;\n\n    @Transactional\n    public void add(UserModel userModel) throws Exception {\n\n        userMapper.insertUser(userModel);\n        try {\n            roleService.doOtherThing();\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        }\n    }\n}\n</code></pre>\n<p>可以将内部嵌套事务放在try/catch中，并且不继续往上抛异常。这样就能保证，如果内部嵌套事务中出现异常，只回滚内部事务，而不影响外部事务。</p>\n<h2 id=\"三-其他\">三 其他</h2>\n<h3 id=\"1-大事务问题\">1 大事务问题</h3>\n<p>在使用spring事务时，有个让人非常头疼的问题，就是大事务问题。</p>\n<p>通常情况下，我们会在方法上<code>@Transactional</code>注解，填加事务功能，比如：</p>\n<pre><code class=\"language-java\">@Service\npublic class UserService {\n    \n    @Autowired \n    private RoleService roleService;\n    \n    @Transactional\n    public void add(UserModel userModel) throws Exception {\n       query1();\n       query2();\n       query3();\n       roleService.save(userModel);\n       update(userModel);\n    }\n}\n\n\n@Service\npublic class RoleService {\n    \n    @Autowired \n    private RoleService roleService;\n    \n    @Transactional\n    public void save(UserModel userModel) throws Exception {\n       query4();\n       query5();\n       query6();\n       saveData(userModel);\n    }\n}\n</code></pre>\n<p>但<code>@Transactional</code>注解，如果被加到方法上，有个缺点就是整个方法都包含在事务当中了。</p>\n<p>上面的这个例子中，在UserService类中，其实只有这两行才需要事务：</p>\n<pre><code class=\"language-java\">roleService.save(userModel);\nupdate(userModel);\n</code></pre>\n<p>在RoleService类中，只有这一行需要事务：</p>\n<pre><code class=\"language-java\">saveData(userModel);\n</code></pre>\n<p>现在的这种写法，会导致所有的query方法也被包含在同一个事务当中。</p>\n<p>如果query方法非常多，调用层级很深，而且有部分查询方法比较耗时的话，会造成整个事务非常耗时，而从造成大事务问题。</p>\n<p>关于大事务问题的危害，可以阅读一下我的另一篇文章《<a href=\"https://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;mid=2247485262&amp;idx=1&amp;sn=abe19452e4c13876270f329cc6929be7&amp;chksm=f9800194cef78882e5ad4d8eb00b7e3f745a4159aee6afb1858cc16cae599f8889afa330e17b&amp;token=305097496&amp;lang=zh_CN#rd\" rel=\"noopener nofollow\" target=\"_blank\">让人头痛的大事务问题到底要如何解决？</a>》，上面有详细的讲解。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"2编程式事务\">2.编程式事务</h3>\n<p>上面聊的这些内容都是基于<code>@Transactional</code>注解的，主要说的是它的事务问题，我们把这种事务叫做：<code>声明式事务</code>。</p>\n<p>其实，spring还提供了另外一种创建事务的方式，即通过手动编写代码实现的事务，我们把这种事务叫做：<code>编程式事务</code>。例如：</p>\n<pre><code class=\"language-java\">\n   @Autowired\n   private TransactionTemplate transactionTemplate;\n   \n   ...\n   \n   public void save(final User user) {\n         queryData1();\n         queryData2();\n         transactionTemplate.execute((status) =&gt; {\n            addData1();\n            updateData2();\n            return Boolean.TRUE;\n         })\n   }\n</code></pre>\n<p>在spring中为了支持编程式事务，专门提供了一个类：TransactionTemplate，在它的execute方法中，就实现了事务的功能。</p>\n<p>相较于<code>@Transactional</code>注解声明式事务，我更建议大家使用，基于<code>TransactionTemplate</code>的编程式事务。主要原因如下：</p>\n<ol>\n<li>避免由于spring aop问题，导致事务失效的问题。</li>\n<li>能够更小粒度的控制事务的范围，更直观。</li>\n</ol>\n<blockquote>\n<p>建议在项目中少使用@Transactional注解开启事务。但并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。</p>\n</blockquote>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n<p>更多项目实战在我的技术网站：<a href=\"http://www.susan.net.cn/project\" rel=\"noopener nofollow\" target=\"_blank\">http://www.susan.net.cn/project</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 11:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}