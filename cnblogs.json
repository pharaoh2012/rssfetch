{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "程序员接单群：2026世界杯赛事相关软件开发需求激增",
      "link": "https://www.cnblogs.com/WorkWonders/p/19468055",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/WorkWonders/p/19468055\" id=\"cb_post_title_url\" title=\"发布于 2026-01-11 12:39\">\n    <span>程序员接单群：2026世界杯赛事相关软件开发需求激增</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n            <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<div class=\"ace-line ace-line old-record-id-OEvHf8YsxdXp8Jc9t3KcqU2HnRh\">距离2026美加墨世界杯开幕越来越近，全球足球热潮已经提前涌动。对我们程序员接单群来说，最直观的感受就是：世界杯相关的开发需求彻底“爆了”。</div>\n<div class=\"ace-line ace-line old-record-id-XvSSfHa83dQZQucmHtyc2Ht9nEZ\">近一周内，社群里新增的世界杯主题开发需求直接翻了3倍，从数据采集分析到互动营销工具，涵盖的场景五花八门。更有意思的是，不仅有体育行业的客户找过来，不少餐饮、电商、线下场馆的老板也纷纷入局，想借世界杯的东风做技术配套。</div>\n<div class=\"ace-line ace-line old-record-id-EyfJfNVsUdrXnRcufkGcYYbYnKf\">昨天社群里的老陈就刚接了个急单——客户是做体育分析的自媒体，需要一个世界杯数据可视化平台，要整合48支参赛球队的历史战绩、球员伤病数据、实时赛事动态，还要支持生成战术分析图表。“客户催得紧，说早一天上线就能早一天抢占流量，愿意出高于市场价20%的费用。”老陈在群里分享时说，这类数据相关的需求最近特别多，他身边几个做后端和数据开发的朋友，都已经被世界杯项目排满了档期。</div>\n<div class=\"ace-line ace-line old-record-id-ZXuJfsvBad1n1vcooDecvj29nxb\">其实不只是专业的体育领域，普通商家的世界杯营销开发需求也在激增。社群里还有个做小程序开发的程序员接了个餐饮连锁的单子，需求是做一个世界杯竞猜小程序，绑定到店核销优惠券功能，用户猜中比分就能兑换啤酒套餐。客户说“就想趁着世界杯搞一波引流，让店里的观赛区坐满客人”。</div>\n<div class=\"ace-line ace-line old-record-id-MN1CfI5NEdNPcac4rAic2O2tnVb\">翻了翻最近社群里的需求清单，发现热门的世界杯相关开发需求主要集中在这几个方向，也给各位程序员朋友提个醒，提前布局就能抓住这波红利：</div>\n<h3 class=\"heading-3 ace-line old-record-id-QedIfVFdddOKgXcKvk2cFvYinpc\">1. 赛事数据工具类：精准对接彩民与分析需求</h3>\n<div class=\"ace-line ace-line old-record-id-DF4Hf8BD9d0EIKcn7AFc79zjnU0\">这是目前需求最集中的品类，尤其是随着足彩热度攀升，各类数据采集分析工具成了香饽饽。常见需求包括：实时赛事数据同步平台（涵盖比分、阵容、判罚、伤病等毫秒级更新数据）、足彩分析报表系统（支持自定义筛选球队、导出历史对战数据）、AI赛事预测辅助工具（基于历史数据生成赛果概率分析）。有个做数据接口开发的程序员分享，他开发的世界杯数据接口，最近已经被3家体育类APP接入使用了。</div>\n<h3 class=\"heading-3 ace-line old-record-id-QY8lf327jd6AK5cuTrMc8jABnAd\">2. 商家营销互动类：借势世界杯引流促单</h3>\n<div class=\"ace-line ace-line old-record-id-SZFTf8z5xdUXERcagtsc95b6nKe\">餐饮、电商、线下观赛场地的老板们对这类需求最热衷。核心需求围绕“互动+转化”，比如世界杯主题竞猜小程序（支持点球小游戏、球队匹配测试）、限定款活动管理系统（实现世界杯套餐预售、分享返现）、球迷拉票传播工具（生成支持球队的专属海报，附带商家活动入口）。这类项目开发周期短、需求清晰，很适合快速接单变现。</div>\n<h3 class=\"heading-3 ace-line old-record-id-YJvdf7iNhdYK8scFeQ8cH3L7nZc\">3. 沉浸式观赛与智慧管理类：科技赋能观赛体验</h3>\n<div class=\"ace-line ace-line old-record-id-To7TfCW74dotlJctto7csNmnn4c\">随着FIFA将2026世界杯定位为“技术实验室”，各类科技感十足的开发需求也冒了出来。比如沉浸式观赛APP（支持多视角直播、裁判第一视角画面、虚拟球迷群互动）、线下场馆智慧管理系统（涵盖观赛预约、扫码核验、周边导航、座位引导）、球员3D虚拟形象相关应用（用于赛事转播展示、越位判罚可视化）。这类需求技术门槛较高，但报价也更可观，适合有相关技术积累的程序员承接。</div>\n<h3 class=\"heading-3 ace-line old-record-id-WWH5fSoW1dtDaXcqMV5c0BttnRZ\">4. 内容创作辅助类：助力自媒体高效产出</h3>\n<div class=\"ace-line ace-line old-record-id-YhFvfpV0sddvAqcsmqrcPyAknod\">体育自媒体的内容创作需求也催生了不少开发订单，比如短视频素材智能剪辑系统（自动抓取赛事精彩片段，匹配热门BGM和球队主题）、赛事图文自动生成工具（一键整合数据和赛事动态，生成可直接发布的推文）。有个做自媒体的客户在群里说：“有了这些工具，不用再熬夜整理数据、剪辑视频，效率至少提升了5倍。”</div>\n<div class=\"ace-line ace-line old-record-id-Q3AKf9Hk6dry81c5Wd4cjjW4n6d\">对有开发需求的老板来说，世界杯相关项目有明确的时间窗口，越早落地越能抢占先机。但找靠谱的程序员对接往往是个难题——要么找不到对口技术的人，要么担心新手练手耽误工期，要么被中介层层加价。</div>\n<div class=\"ace-line ace-line old-record-id-Jlnjfs0kHdgsQEcgox4cVzsPnie\">而我们这个程序员接单群，刚好解决了这个痛点。群里的程序员全是在职技术老手，覆盖后端、前端、数据开发、AI应用等各个领域，不少人都有体育赛事相关项目的开发经验，能精准匹配各类世界杯主题需求。更重要的是，群里没有任何中介，需求方直接和程序员对接，沟通高效，还能省去不少中间成本。</div>\n<div class=\"ace-line ace-line old-record-id-E6VnfE8g0dFM9cckOnhcnYhXn5e\">最近就有个做线下观赛酒吧的老板，在群里发了“观赛预约+实时评分互动”的需求，不到1小时就有3个程序员主动对接，最终选了个有类似项目经验的，一周就完成了系统开发，现在酒吧的预约量已经排到了小组赛阶段。</div>\n<div class=\"ace-line ace-line old-record-id-NNLZfWbRmd3Hbgcl9qbcaUufn2f\">如果你是有世界杯相关开发需求的老板，不管是做数据工具、营销小程序，还是智慧观赛系统，都可以来群里找对口的程序员；如果你是程序员，想抓住这波世界杯红利接优质订单，也欢迎加入我们，这里有接不完的精准需求。</div>\n<div class=\"ace-line ace-line old-record-id-J9ONfntDLdcJhNcRuAucNw8MnCv\">【入群方式超简单，两步就能搞定】</div>\n<div class=\"ace-line ace-line old-record-id-QrpqfI463dyg2Hcg46TcXHuTnTG\">1. 先关注本公众号：【程序员接单群】（已经关注的可以直接跳过）</div>\n<div class=\"ace-line ace-line old-record-id-FbcefOIJAdSiMEcUZvccRGsAnwb\">2. 点击公众号菜单栏的「入群按钮」，就能自动收到群二维码，扫码即可进群。</div>\n<div class=\"ace-line ace-line old-record-id-AyqyflFOwdn74Dcd9AicZdYCnQh\">【最后说几句群规，大家互相遵守】</div>\n<div class=\"ace-line ace-line old-record-id-Sq4xfGpcddfCrUcV3n5cNUXOnre\">1. 群内禁止发无关广告、刷屏闲聊，保持交流环境干净；</div>\n<div class=\"ace-line ace-line old-record-id-D4XZfvDywdOHIYcbIy0cZqJLnKh\">2. 老板请发布真实开发需求，谢绝虚假调研和无效提问；</div>\n<div class=\"ace-line ace-line old-record-id-DR3Vfu8LMdazBhc20HDcWASVnhd\">3. 程序员只接自己能胜任的项目，不忽悠、不转包，保证交付质量；</div>\n<div class=\"ace-line ace-line old-record-id-Lzh6f9Z3gdSbE6cJe0KcQZKVn8b\">4. 对接过程中文明沟通，尊重彼此的时间和劳动成果。</div>\n<div class=\"ace-line ace-line old-record-id-Wgy4frFx4d9Y1eciX6NcyAcrnEe\">世界杯的热度只会越来越高，不管是找开发还是接订单，早对接早受益。希望这个群能帮大家抓住这波风口，让需求顺利落地，让订单轻松到手！</div>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-01-11 12:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/WorkWonders\">WorkWonders</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "FFmpeg开发笔记（九十八）基于FFmpeg的跨平台图形用户界面LosslessCut",
      "link": "https://www.cnblogs.com/aqi00/p/19376134",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19376134\" id=\"cb_post_title_url\" title=\"发布于 2026-01-11 11:55\">\n    <span>FFmpeg开发笔记（九十八）基于FFmpeg的跨平台图形用户界面LosslessCut</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span><span>​</span></span><span id=\"cke_bm_406S\">LosslessCut是一款跨平台FFmpeg图形用户界面，用于对视频、音频、字幕和其他相关媒体文件进行极速且无损的操作。虽然《FFmpeg开发实战：从零基础到短视频上线》一书详细介绍了如何通过ffmpeg在命令行剪辑音视频，但是命令行方式不够直观，用户更习惯在图形界面上操作。于是LosslessCut抓住用户痛点，给FFmpeg封装了一层操作界面，从而方便用户利用鼠标剪辑音视频。</span>\n<p><span id=\"cke_bm_406S\"> LosslessCut的主要功能是对视频和音频文件进行无损剪辑，通过裁剪摄像机、GoPro、无人机等设备拍摄的大型视频文件来节省空间。LosslessCut让用户能够快速从视频中提取精彩部分，同时丢弃大量数据，而无需重新编码造成质量损失。由于LosslessCut几乎直接复制数据，并且由强大的FFmpeg完成所有繁重工作，因此一切剪辑过程都非常快速。<br />\nLosslessCut的源码托管地址为https://github.com/mifi/lossless-cut（星星数35.5k），国内的镜像地址为https://gitcode.com/gh_mirrors/lo/lossless-cut，最新版本是2025年12月发布的v3.67.2，可见该框架的源码更新十分及时，该版本的源码下载链接为https://github.com/mifi/lossless-cut/archive/refs/tags/v3.67.2.tar.gz。<br />\nLosslessCut提供了两种运行方式，一种是通过源码运行，另一种是提供编译好的安装包运行，比如Windows系统已编译的免安装压缩包下载链接为https://github.com/mifi/lossless-cut/releases/download/v3.67.1/LosslessCut-win-x64.7z，下载后解压7z文件即可得到LosslessCut的可执行程序。<br />\n以源码方式运行LosslessCut的话，需要事先安装下列三个软件：<br />\n1、安装 VS Code 以便加载LosslessCut源码工程， VS Code 的官网地址为 https://code.visualstudio.com/<br />\n2、安装版本号大于等于16.x的 Node.js ，因为LosslessCut 依赖 Node.js 构建。 Node.js 的官网地址为 https://nodejs.org/<br />\n3、安装 Git 以便克隆源码， Git 的官网地址为 https://git-scm.com/<br />\n上述三个软件都安装完毕，运行 VS Code ，依次选择菜单：File→Open Folder，在弹出的文件对话框中选择解压后的LosslessCut源码目录。接着依次选择菜单：Terminal→New Terminal，自动在 VS Code 界面上打开终端的命令行窗口。<br />\n在命令行窗口运行下面命令，表示安装yarn工具：</span></p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\">npm install -g yarn</code></pre>\n</div>\n<p>运行下面命令检查yarn是否安装成功，正常会返回yarn的版本号比如4.11.0。</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\">yarn -v</code></pre>\n</div>\n<p>运行下面命令安装LosslessCut依赖的第三方库：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\">yarn install</code></pre>\n</div>\n<p>确保第三方库都成功安装后，再运行下面命令启动LosslessCut：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\">yarn start</code></pre>\n</div>\n<p>稍等片刻会弹出LosslessCut的图形界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"lossless-cut1\" class=\"lazyload\" height=\"497\" width=\"428\" /></span></span></span></span></p>\n<p>可见LosslessCut的图形界面十分简洁，既能通过菜单选择来打开视频文件，也能通过拖动鼠标把视频添加进来。<br />\n把视频文件拉到LosslessCut的图形界面后，就切换到视频剪辑界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"lossless-cut2\" class=\"lazyload\" height=\"379\" width=\"600\" /></span></span></span></span></p>\n<p>在视频剪辑界面可以执行裁剪、缩放、拼接等常见的加工操作，剪辑完成后单击界面右下角的Export按钮，即可导出并保存处理好的视频文件。</p>\n<p>更多详细的FFmpeg开发知识参见<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\"><a class=\"cke_widget_editable cke_widget_element\" href=\"https://item.jd.com/14020415.html\" rel=\"noopener nofollow\" title=\"《FFmpeg开发实战：从零基础到短视频上线》\">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-11 11:55</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "20260109 - TRU 协议攻击事件分析：买得够多免费送了喂！",
      "link": "https://www.cnblogs.com/ACaiGarden/p/19465686",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ACaiGarden/p/19465686\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 15:42\">\n    <span>20260109 - TRU 协议攻击事件分析：买得够多免费送了喂！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>20260109，ETH 链上的 TRU 协议遭受了黑客攻击，损失约 2600 万美元。漏洞原因是计算购买 TRU 代币所需要的 ETH 数量的计算公式设计存在缺陷，购买大量 TRU 代币时会因为精度丢失而得到 0 值，使得攻击者可以以 0 ETH 购买大量的 TRU 代币，最后抛售完成获利。</p>\n<ul>\n<li>TX：<a href=\"https://app.blocksec.com/explorer/tx/eth/0xcd4755645595094a8ab984d0db7e3b4aabde72a5c87c4f176a030629c47fb014\" rel=\"noopener nofollow\" target=\"_blank\">https://app.blocksec.com/explorer/tx/eth/0xcd4755645595094a8ab984d0db7e3b4aabde72a5c87c4f176a030629c47fb014</a></li>\n</ul>\n<h1 id=\"trace-分析\">Trace 分析</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154123776-1794652238.png\" /></p>\n<ol>\n<li>黑客调用 buyTRU() 函数以零成本购入大量的 TRU 代币</li>\n<li>然后调用 sellTRU() 函数卖出所有 TRU 代币完成获利</li>\n</ol>\n<p>随后攻击者利用漏洞以零或极低成本的价格购买 TRU 代币后出售的流程重复多次。</p>\n<h1 id=\"代码分析\">代码分析</h1>\n<p>TRU 合约是一个代理合约：0x764C64b2A09b09Acb100B80d8c505Aa6a0302EF2</p>\n<p>其具体的逻辑逻辑合约为：0x18ceDF1071EC25331130C82D7AF71D393Ccd4446</p>\n<p>由于逻辑合约并没有开源，所以接下来会采用 dedaub 反编译 + 人工校正的方式分析项目的业务逻辑。</p>\n<ul>\n<li>逻辑合约的反编译地址：<a href=\"https://app.dedaub.com/ethereum/address/0xc186e6f0163e21be057e95aa135edd52508d14d3/decompiled\" rel=\"noopener nofollow\" target=\"_blank\">https://app.dedaub.com/ethereum/address/0xc186e6f0163e21be057e95aa135edd52508d14d3/decompiled</a></li>\n</ul>\n<p>在 buyTRU() 函数中，会根据输入的 TRUAmount 参数值计算所需要的 ETH 数量，并检查 msg.value 的值是否为相等。通过检查后，会给用户 mint TRUAmount 数量的 TRU 代币。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154138455-1713236541.png\" /></p>\n<p>其问题就出在计算 ETH 数量的 TRUtoETH() 函数上，其反编译的内容如下，根据输入的 TRUAmount 值进行一系列的计算。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154148291-397462858.png\" /></p>\n<p>通过 solidity 重写这个函数，得到以下的内容。其中 _setParameters 的值为 75，代表 75% 的一个比例。</p>\n<pre><code class=\"language-solidity\">function TRUtoETH(uint256 TRUAmount) private view returns (uint256) {\n    uint256 totalSupply = TRU.totalSupply();\n    \n    // numerator: (100 - 75) * totalSupply² = 25 * totalSupply²\n    uint256 numerator = (100 - _setParameters) * totalSupply * totalSupply;\n    \n    // denominator: 100 * TRUAmount * _reserve * (TRUAmount + 2 * totalSupply)\n    uint256 denominator = 100 * TRUAmount * _reserve * (TRUAmount + 2 * totalSupply);\n    \n    return numerator / denominator;\n}\n\n</code></pre>\n<p>由上面的代码分析可得，当 _setParameters，totalSupply 和 _reserve 为固定值时，传入的参数 TRUAmount 越大，分母就越大，返回值就会相应的变小。而当分母大于分子时，由于 solidity 精度丢失的特性，返回值将会为 0。也就是说：</p>\n<blockquote>\n<p>当 TRUAmount 的值非常大，当前的计算公式在计算所需要提供的 ETH 数量时，会由于 solidity 的精度丢失返回 0 值。</p>\n</blockquote>\n<p>这样，攻击者就完成了攻击的第一个步骤：以零或极低成本的价格购买 TRU 代币。</p>\n<p>随后就是正常使用 sellTRU() 函数卖出所有 TRU 代币完成了获利。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260110154205268-1163820900.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 15:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ACaiGarden\">ACai_sec</a>&nbsp;\n阅读(<span id=\"post_view_count\">86</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【Azure Redis】客户端应用使用 Azure Redis Cluster 报错 java.security.cert.CertificateException: No subject alternative names matching IP address xxx.xxx.xxx.xxx found",
      "link": "https://www.cnblogs.com/lulight/p/19464831",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19464831\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 12:02\">\n    <span>【Azure Redis】客户端应用使用 Azure Redis Cluster 报错 java.security.cert.CertificateException: No subject alternative names matching IP address xxx.xxx.xxx.xxx found</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>问题描述</h1>\n<p>使用Azure Cache for Redis的集群模式。应用客户端为Java代码，使用Lettuce 作为Redis 客户端SDK。启动项目报错：<span style=\"color: rgba(255, 0, 0, 1);\"><strong><span style=\"font-style: italic; background-color: initial;\">Caused by: java.security.cert.CertificateException: No subject alternative names matching IP address 159.27.xxx.xxx found。</span></strong></span></p>\n<h2><span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: initial;\">运行时的错误截图</span></strong></span></h2>\n<p><img alt=\"image\" class=\"lazyload\" height=\"435\" width=\"666\" /></p>\n<h2>示例代码</h2>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.lbazureredis;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.RedisURI;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.RedisClusterClient;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Main {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> main(String[] args) {\n        \n        System.out.println(</span>\"Hello world! This is Redis Cluster example.\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        \n        RedisURI redisUri </span>= RedisURI.Builder.redis(\"&lt;yourredisname&gt;.redis.cache.chinacloudapi.cn\", 6380<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPassword(</span>\"&lt;your redis access key&gt;\").withSsl(<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">).build();\n        RedisClusterClient clusterClient </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> RedisClusterClient.create(redisUri);\n        StatefulRedisClusterConnection</span>&lt;String, String&gt; connection =<span style=\"color: rgba(0, 0, 0, 1);\"> clusterClient.connect();\n        RedisAdvancedClusterCommands</span>&lt;String, String&gt; syncCommands =<span style=\"color: rgba(0, 0, 0, 1);\"> connection\n                .sync();\n\n        String pingResponse </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> syncCommands.ping();\n        System.out.println(</span>\"Ping response: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> pingResponse);\n\n        syncCommands.set(</span>\"mykey\", \"Hello, Redis Cluster!\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        String value </span>= syncCommands.get(\"mykey\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        System.out.println(</span>\"Retrieved value: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> value);\n        \n        connection.close();\n        clusterClient.shutdown();\n\n    }\n}</span></pre>\n</div>\n<h2>项目POM.xml</h2>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">&lt;?</span><span style=\"color: rgba(255, 0, 255, 1);\">xml version=\"1.0\" encoding=\"UTF-8\"</span><span style=\"color: rgba(0, 0, 255, 1);\">?&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">project </span><span style=\"color: rgba(255, 0, 0, 1);\">xmlns</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"http://maven.apache.org/POM/4.0.0\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n         xmlns:xsi</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"http://www.w3.org/2001/XMLSchema-instance\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n         xsi:schemaLocation</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">modelVersion</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>4.0.0<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">modelVersion</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>com.lbazureredis<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>test<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>1.0-SNAPSHOT<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">properties</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.source</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>17<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.source</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.target</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>17<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.target</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">properties</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">dependencies</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> Lettuce Redis Client </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>io.lettuce<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>lettuce-core<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>6.3.1.RELEASE<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> SLF4J for logging </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>org.slf4j<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>slf4j-simple<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>2.0.9<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">dependencies</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">project</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span></pre>\n</div>\n<p><span style=\"font-size: 18px; color: rgba(255, 0, 0, 1);\"><strong>针对以上问题，如何解决呢？</strong></span></p>\n<p>&nbsp;</p>\n<h1>问题解答</h1>\n<p>根据错误信息搜索后，得到Azure官方最佳实践文档中的解答：<a href=\"https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md</a></p>\n<blockquote>\n<p>The reason this is required is because SSL certification validates the address of the Redis Nodes with the SAN (Subject Alternative Names) in the SSL certificate. <strong>Redis protocol requires that these node addresses should be IP addresses.</strong> However, the SANs in<strong> the Azure Redis SSL certificates contains only the Hostname</strong> since Public IP addresses can change and as a result not completely secure.</p>\n<p>在Redis Protocol验证中，必须验证证书中包含IP地址，但由于Azure Redis部署在云环境中，IP地址是不固定的。所以默认情况下，Redis SSL证书中包含的是域名。为了解决这个问题，需要建立一个Host与IP地址的映射关系，使得Lettuce客户端在验证Redis证书时通过域名验证而非IP地址，用于解决<strong>No subject alternative names matching IP address 159.27.xxx.xxx found </strong>问题</p>\n</blockquote>\n<p>参考文档中的方法，自定义<strong><code>MappingSocketAddressResolver</code></strong></p>\n<div class=\"cnblogs_code\">\n<pre>        Function&lt;HostAndPort, HostAndPort&gt; <span style=\"background-color: rgba(255, 204, 0, 1);\">mappingFunction</span> = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Function&lt;HostAndPort, HostAndPort&gt;<span style=\"color: rgba(0, 0, 0, 1);\">() {\n            @Override\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort apply(HostAndPort hostAndPort) {\n                String cacheIP </span>= \"\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                    InetAddress[] addresses </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DnsResolvers.JVM_DEFAULT.resolve(host);\n                    cacheIP </span>= addresses[0<span style=\"color: rgba(0, 0, 0, 1);\">].getHostAddress();\n                } </span><span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (UnknownHostException e) {\n                    e.printStackTrace();\n                }\n                HostAndPort finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> hostAndPort;\n\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (hostAndPort.hostText.equals(cacheIP))\n                    finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort.of(host, hostAndPort.getPort());\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> finalAddress;\n            }\n        };\n\n        <span style=\"background-color: rgba(255, 204, 0, 1);\">MappingSocketAddressResolver</span> resolver </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MappingSocketAddressResolver.create(DnsResolvers.JVM_DEFAULT,\n                mappingFunction);\n        <span style=\"background-color: rgba(255, 204, 0, 1);\">ClientResources</span> res </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DefaultClientResources.builder()\n                .socketAddressResolver(resolver).build();\n        RedisURI redisURI </span>= RedisURI.Builder.redis(host).withSsl(<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPassword(password)\n                .withClientName(</span>\"LettuceClient\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPort(</span>6380<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .build();\n        RedisClusterClient redisClient </span>= RedisClusterClient.create(<span style=\"background-color: rgba(255, 204, 0, 1);\">res</span>, redisURI);</pre>\n</div>\n<h2>代码解读</h2>\n<blockquote>\n<h3>mappingFunction</h3>\n<ul>\n<li>它是一个自定义的地址映射逻辑，用于处理 Lettuce 在连接 Redis 集群时的主机名与 IP 地址问题。</li>\n<li>它通过 DnsResolvers.JVM_DEFAULT 对指定的域名进行 DNS 解析，获取对应的 IP 地址。如果当前 HostAndPort 的 hostText 与解析出的 IP 相同，则将其替换为原始域名 host，保持端口不变。</li>\n<li>这一逻辑的核心目的是解决 SSL 证书校验问题，因为证书通常绑定域名而非 IP，确保连接时使用域名进行验证，避免因 IP 导致的握手失败。</li>\n</ul>\n<h3>MappingSocketAddressResolver</h3>\n<ul>\n<li>它是 Lettuce 提供的一个工具类，用于在连接 Redis 时插入自定义的地址解析逻辑。</li>\n<li>它结合默认的 DNS 解析器和 mappingFunction，在每次解析 Socket 地址时执行映射操作。</li>\n<li>通过这种方式，客户端可以在 DNS 解析后对结果进行二次处理，例如将 IP 地址重新映射为域名。</li>\n<li>这对于云服务场景（如 Azure Redis）非常重要，因为这些服务的 SSL 证书通常只对域名有效，而不是 IP 地址。</li>\n</ul>\n<h3>DefaultClientResources</h3>\n<ul>\n<li><span style=\"background-color: initial; font-size: 14px;\">作为 Lettuce 的核心资源管理器，用于配置客户端的底层行为，包括线程池、DNS 解析器、事件循环等。在这里，它的作用是将自定义的 MappingSocketAddressResolver 注入到客户端资源中，使所有连接请求都遵循自定义的地址解析逻辑。</span></li>\n<li><span style=\"background-color: initial; font-size: 14px;\">通过这种方式，整个 Lettuce 客户端在连接 Redis 集群时都会使用域名而非 IP，确保 SSL 校验通过，同时保持连接的稳定性和安全性。</span></li>\n</ul>\n</blockquote>\n<p>&nbsp;</p>\n<h2>执行结果</h2>\n<p>再次运行，成功连接到Azure Redis Cluster 及执行Ping, Set, Get指令！</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"541\" width=\"999\" /></p>\n<h2>修改后完整的Java示例代码如下：</h2>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.lbazureredis;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.net.InetAddress;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.net.UnknownHostException;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.time.Duration;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.function.Function;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.RedisURI;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.SocketOptions;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.api.StatefulRedisConnection;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.ClusterClientOptions;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.ClusterTopologyRefreshOptions;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.RedisClusterClient;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.async.RedisAdvancedClusterAsyncCommands;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.internal.HostAndPort;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.ClientResources;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.DefaultClientResources;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.DnsResolvers;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.MappingSocketAddressResolver;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Main {\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> main(String[] args) {\n\n        System.out.println(</span>\"Hello world! This is Redis Cluster example.\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n\n        String host </span>= \"&lt;yourredisname&gt;.redis.cache.chinacloudapi.cn\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n        String password </span>= \"&lt;your redis access key&gt;\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n\n        Function</span>&lt;HostAndPort, HostAndPort&gt; <span style=\"background-color: rgba(255, 204, 0, 1);\">mappingFunction</span> = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Function&lt;HostAndPort, HostAndPort&gt;<span style=\"color: rgba(0, 0, 0, 1);\">() {\n            @Override\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort apply(HostAndPort hostAndPort) {\n                String cacheIP </span>= \"\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                    InetAddress[] addresses </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DnsResolvers.JVM_DEFAULT.resolve(host);\n                    cacheIP </span>= addresses[0<span style=\"color: rgba(0, 0, 0, 1);\">].getHostAddress();\n                } </span><span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (UnknownHostException e) {\n                    e.printStackTrace();\n                }\n                HostAndPort finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> hostAndPort;\n\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (hostAndPort.hostText.equals(cacheIP))\n                    finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort.of(host, hostAndPort.getPort());\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> finalAddress;\n            }\n        };\n\n        MappingSocketAddressResolver resolver </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MappingSocketAddressResolver.create(DnsResolvers.JVM_DEFAULT,\n                <span style=\"background-color: rgba(255, 204, 0, 1);\">mappingFunction</span>);\n        ClientResources res </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DefaultClientResources.builder()\n                .socketAddressResolver(resolver).build();\n        RedisURI redisURI </span>= RedisURI.Builder.redis(host).withSsl(<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPassword(password)\n                .withClientName(</span>\"LettuceClient\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPort(</span>6380<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .build();\n        RedisClusterClient redisClient </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> RedisClusterClient.create(<span style=\"background-color: rgba(255, 204, 0, 1);\">res</span>, redisURI);\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Cluster specific settings for optimal reliability.</span>\n        ClusterTopologyRefreshOptions refreshOptions =<span style=\"color: rgba(0, 0, 0, 1);\"> ClusterTopologyRefreshOptions.builder()\n                .enablePeriodicRefresh(Duration.ofSeconds(</span>5<span style=\"color: rgba(0, 0, 0, 1);\">))\n                .dynamicRefreshSources(</span><span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                .adaptiveRefreshTriggersTimeout(Duration.ofSeconds(</span>5<span style=\"color: rgba(0, 0, 0, 1);\">))\n                .enableAllAdaptiveRefreshTriggers().build();\n        redisClient.setOptions(ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder()\n                        .keepAlive(</span><span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                        .build())\n                .topologyRefreshOptions(refreshOptions).build());\n                \n        StatefulRedisClusterConnection</span>&lt;String, String&gt; connection =<span style=\"color: rgba(0, 0, 0, 1);\"> redisClient.connect();\n        RedisAdvancedClusterCommands</span>&lt;String, String&gt; syncCommands =<span style=\"color: rgba(0, 0, 0, 1);\"> connection.sync();\n        RedisAdvancedClusterAsyncCommands</span>&lt;String, String&gt; asyncCommands =<span style=\"color: rgba(0, 0, 0, 1);\"> connection.async();\n\n        String pingResponse </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> syncCommands.ping();\n        System.out.println(</span>\"Ping response: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> pingResponse);\n\n        syncCommands.set(</span>\"mykey\", \"Hello, Redis Cluster!\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        String value </span>= syncCommands.get(\"mykey\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        System.out.println(</span>\"Retrieved value: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> value);\n\n        connection.close();\n\n        redisClient.shutdown();\n\n    }\n}</span></pre>\n</div>\n<h2>代码流程图</h2>\n<p>基于AI模型解读以上代码后，分析出来的代码流程图</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"256\" width=\"666\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1>参考资料</h1>\n<div class=\"markdown-heading\" dir=\"auto\">\n<p class=\"heading-element\" dir=\"auto\">Best Practices for using Azure Cache for Redis with Lettuce ：<a href=\"https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md</a></p>\n<div>&nbsp;</div>\n<a class=\"anchor\" href=\"https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md#best-practices-for-using-azure-cache-for-redis-with-lettuce\" id=\"user-content-best-practices-for-using-azure-cache-for-redis-with-lettuce\" rel=\"noopener nofollow\"></a></div>\n</div>\n<div id=\"MySignature\">\n    <div style=\"background: #1c5f55; height: 36px; width: 618px; padding: 14px 5px 0px 3px;\">\n  <p style=\"font-weight: bold; color: white;\">当在复杂的环境中面临问题，格物之道需：浊而静之徐清，安以动之徐生。 云中，恰是如此!</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 12:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lulight\">路边两盏灯</a>&nbsp;\n阅读(<span id=\"post_view_count\">46</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "棒棒糖图：当条形图遇上极简美学",
      "link": "https://www.cnblogs.com/wang_yb/p/19464212",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19464212\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 08:42\">\n    <span>棒棒糖图：当条形图遇上极简美学</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>棒棒糖图</strong>（Lollipop Chart）可以看作是条形图的一种“轻盈版”变体：它用一根从基准线延伸出来的“棒”，并在末端以一个“糖”（圆点）来表示数值，取代了传统的矩形条。</p>\n<p>这种图表传达的信息与条形图是一样的，但它更注重突出数据点的位置，整体看起来更加清新、现代。</p>\n<p>今天，我们一起探索棒棒糖图的优势，并通过代码实现，亲手打造一个属于自己的棒棒糖图！</p>\n<h1 id=\"设计原理\">设计原理</h1>\n<p>设计棒棒糖图的初衷有两个方面：</p>\n<p>首先，通过减少图形中的“墨水”使用量，在面对大量类别或数值普遍较高的情况下，避免了条形图过于密集可能带来的<strong>视觉压迫感</strong>和<strong>杂乱无章</strong>的感觉；</p>\n<p>其次，这样的设计能够更好地引导观察者的注意力集中在各个数据点的具体位置及其之间的差异上，非常适合用来进行排名或者对比分析。</p>\n<p><strong>棒棒糖图</strong>与<strong>条形图</strong>在功能上是等价的，也并不总是优于条形图。</p>\n<p>当处理大量类别、条柱非常高且相互之间距离较近的数据时，棒棒糖图会显得更加易于阅读理解；</p>\n<p>然而，在需要强调绝对数量或是希望获得最为直观长度比较的情况下，条形图依然是更好的选择。</p>\n<h1 id=\"实现原理\">实现原理</h1>\n<p><strong>棒棒糖图</strong>在<code>matplotlib</code>库中没有直接对应的类。</p>\n<p>不过，它的实现原理非常简单，通过组合使用 <code>matplotlib</code> 中的两个基本绘图功能就可以实现：</p>\n<ol>\n<li><strong>绘制线条</strong> (<code>plt.vlines</code>)：这是构成棒棒糖“棍子”部分的关键。</li>\n</ol>\n<p><code>plt.vlines</code> 函数用于在图表上绘制垂直线段。通过指定每个数据点的 x 坐标、线条的起始点（通常是 0）和结束点（即对应数据的 y 值），就可以画出从 x 轴延伸到数据值的线条。</p>\n<ol start=\"2\">\n<li><strong>绘制圆点</strong> (<code>plt.scatter</code>)：这是构成棒棒糖“糖”部分的关键。</li>\n</ol>\n<p><code>plt.scatter</code> 函数用于绘制散点图。通过将每个数据点的 x 坐标和 y 坐标（即数据值）作为参数传入，就可以在每条线的顶端绘制一个圆点。</p>\n<p>总的来说，<strong>实现原理</strong>就是：用线条表示数值的大小，用圆点强调数值的终点位置，两者结合就形成了视觉上类似棒棒糖的图表。</p>\n<p>这种组合方式使得图表比实心的条形图更简洁，同时又能清晰地传达数据信息。</p>\n<p>下一节的示例中，将会演示如何使用<code>matplotlib</code>来绘制<strong>棒棒糖图</strong>。</p>\n<h1 id=\"应用示例\">应用示例</h1>\n<p>接下来，让我们通过实际的对比示例，直观地感受棒棒糖图与传统条形图的不同表现。</p>\n<h2 id=\"适合棒棒糖图的场景\">适合棒棒糖图的场景</h2>\n<pre><code class=\"language-python\"># 创建更多类别的测试数据\n# 模拟不同月份中每天的某个指标（例如：每日平均步数，单位：千步）\ndays = [f\"Day {i}\" for i in range(1, 21)]  # 生成 20 天的数据\nnp.random.seed(42)  # 设置随机种子，确保每次运行结果一致\n# 生成 1 到 5 之间的随机数值作为示例数据\nvalues = np.round(np.random.uniform(1.0, 5.0, size=len(days)), 1)\n\n# --- 创建子图 ---\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))  # 调整为垂直布局，方便比较\n\n# --- 绘制条形图 (上图) ---\nbars = ax1.bar(days, values, color=\"skyblue\", edgecolor=\"navy\", linewidth=0.7)\nax1.set_title(\"条形图 (Bar Chart) - 每日步数\", fontsize=14)\nax1.set_ylabel(\"数值 (千步)\")\n# ax1.set_xlabel('日期') # x轴标签已在下方图中\nax1.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n# 在条形图上添加数值标签\nfor bar, val in zip(bars, values):\n    height = bar.get_height()\n    ax1.text(\n        bar.get_x() + bar.get_width() / 2.0,\n        height + 0.05,\n        f\"{val}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=8,\n    )  # 标签旋转90度节省空间\n\n# --- 绘制棒棒糖图 (下图) ---\n# 1. 绘制线条\nax2.vlines(x=range(len(days)), ymin=0, ymax=values, color=\"navy\", linewidth=2)\n# 2. 在线条顶部绘制圆点\nax2.scatter(x=range(len(days)), y=values, color=\"red\", s=50, zorder=3)\n# 3. 添加数值标签\nfor i, val in enumerate(values):\n    ax2.text(i, val + 0.1, f\"{val}\", ha=\"center\", va=\"bottom\", fontsize=8)\n\nax2.set_title(\"棒棒糖图 (Lollipop Chart) - 每日步数\", fontsize=14)\nax2.set_ylabel(\"数值 (千步)\")\nax2.set_xlabel(\"日期\")\nax2.set_xticks(range(len(days)))\nax2.set_xticklabels(days, rotation=45, ha=\"right\")  # 旋转x轴标签以便阅读\nax2.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\nax2.set_ylim(0, max(values) * 1.1)\n\n# --- 显示图形 ---\nplt.tight_layout()  # 调整子图间距\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260110084120492-216729079.png\" /></p>\n<p>这个示例使用了20个数据类别（Day 1 到 Day 20）。</p>\n<p>你可以看到，在条形图中，许多蓝色的条形紧密地排列在一起，视觉上显得有些拥挤。</p>\n<p>而在棒棒糖图中，线条和圆点使得数据点之间的关系更加清晰，整体视觉效果更轻盈，更容易比较各个数值的大小和识别模式。</p>\n<h2 id=\"适合传统条形图的场景\">适合传统条形图的场景</h2>\n<pre><code class=\"language-python\"># 创建更适合条形图的测试数据\n# 模拟某公司连续12个月的销售额（单位：万元）\nmonths = [\n    \"1月\",\n    \"2月\",\n    \"3月\",\n    \"4月\",\n    \"5月\",\n    \"6月\",\n    \"7月\",\n    \"8月\",\n    \"9月\",\n    \"10月\",\n    \"11月\",\n    \"12月\",\n]\n# 生成有一定趋势和波动的销售额数据，例如有季节性高峰\nsales = [120, 110, 135, 140, 155, 170, 185, 180, 160, 150, 145, 165]\n\n# --- 创建子图 ---\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))\n\n# --- 绘制条形图 (左图) ---\nbars = ax1.bar(months, sales, color=\"lightsteelblue\", edgecolor=\"black\", linewidth=0.7)\nax1.set_title(\"条形图 (Bar Chart - 月份销售额)\", fontsize=14)\nax1.set_ylabel(\"销售额 (万元)\")\nax1.set_xlabel(\"月份\")\nax1.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n# 在条形图上添加数值标签\nfor bar, s in zip(bars, sales):\n    height = bar.get_height()\n    ax1.text(\n        bar.get_x() + bar.get_width() / 2.0,\n        height + 2,\n        f\"{s}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=9,\n    )\n\n# --- 绘制棒棒糖图 (右图) ---\nax2.vlines(x=range(len(months)), ymin=0, ymax=sales, color=\"gray\", linewidth=2)\nax2.scatter(x=range(len(months)), y=sales, color=\"coral\", s=50, zorder=3)\nfor i, s in enumerate(sales):\n    ax2.text(i, s + 3, f\"{s}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nax2.set_title(\"棒棒糖图 (Lollipop Chart - 月份销售额)\", fontsize=14)\nax2.set_ylabel(\"销售额 (万元)\")\nax2.set_xlabel(\"月份\")\nax2.set_xticks(range(len(months)))\nax2.set_xticklabels(months, rotation=45)  # 旋转x轴标签以防重叠\nax2.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\nax2.set_ylim(0, max(sales) * 1.1)\n\n# --- 显示图形 ---\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260110084120515-917001944.png\" /></p>\n<p>在这个示例中，数据代表的是连续的月份，数值本身代表的是销售额，这是一个“量”的概念。</p>\n<p>条形图的实心块能让人立刻感受到哪个月份的销售额更高，整体的分布和对比关系一目了然。</p>\n<p>而棒棒糖图虽然也展示了数据，但线条和圆点的组合在视觉上不如实心条形那样能直接传达“量”的感觉，尤其是在数值差异不是特别巨大时，对比效果会稍逊于条形图。</p>\n<h1 id=\"总结\">总结</h1>\n<p><strong>棒棒糖图</strong>就像数据可视化世界中的\"少即是多\"哲学体现。</p>\n<p>它不是要取代传统条形图，而是为数据可视化工具箱增加了一个有价值的选项。</p>\n<p>就像不同的画笔适合不同的绘画风格，不同的图表类型也适合不同的数据故事。</p>\n<p><strong>棒棒糖图</strong>的真正优势在于它改变了数据的<strong>\"讲述方式\"</strong>。</p>\n<p>它不说：\"这是所有信息，你自己找重点\"，而是说：\"看这里，这些是关键点\"。</p>\n<p>这种焦点导向的特性，使得棒棒糖图在现代快节奏的数据沟通中越来越受欢迎。</p>\n<p>设计可视化时，我们不妨问问自己：我想要观众首先看到什么？如果是精确的数值点和清晰的排名，那么棒棒糖图可能是你的理想选择。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 08:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">175</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Thread 类的基本用法、Java 线程的几种状态",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19463416",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19463416\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 00:05\">\n    <span>Thread 类的基本用法、Java 线程的几种状态</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"在java中thread类是多线程编程的核心\">在Java中，Thread类是多线程编程的核心。</h3>\n<h4 id=\"线程创建-thread-creation\">线程创建 (Thread Creation)</h4>\n<ul>\n<li>创建线程主要有两种逻辑：继承Thread类或实现Runnable接口。\n<ul>\n<li>方式1：继承 Thread 类，重写run()</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-java\">// 自定义线程类继承Thread\nclass MyThread extends Thread {\n    // 重写run()，定义线程执行逻辑\n    @Override\n    public void run() {\n        System.out.println(\"子线程执行：\" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread t = new MyThread();\n        t.start(); // 3. 调用start()启动线程（不能直接调用run()）\n    }\n}\n</code></pre>\n<ul>\n<li>方式2：实现Runnable接口，传给Thread</li>\n</ul>\n<pre><code class=\"language-java\">// 实现Runnable接口\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"子线程执行：\" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\npublic class Demo {\n    public static void main(String[] args) {\n        // 把Runnable实例传给Thread\n        Thread t = new Thread(new MyRunnable());\n        t.start(); // 启动线程\n    }\n}\n</code></pre>\n<h4 id=\"线程中断-thread-interruption\">线程中断 (Thread Interruption)</h4>\n<ul>\n<li>线程中断不是强制停止线程，而是一种协作机制，即给线程发一个“请停止”的信号。</li>\n<li>void interrupt()：标记线程为 “中断状态”</li>\n<li>boolean isInterrupted()：判断线程是否处于中断状态</li>\n<li>若线程在sleep/wait/join时被中断，会抛出InterruptedException，且中断状态会被清除</li>\n</ul>\n<pre><code class=\"language-java\">Thread t = new Thread(() -&gt; {\n    while (!Thread.currentThread().isInterrupted()) { // 检测中断状态\n        System.out.println(\"线程运行中...\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // 捕获中断异常后，中断状态会被清除，需手动终止循环\n            System.out.println(\"线程被中断\");\n            Thread.currentThread().interrupt(); // 重新标记中断（可选）\n            break;\n        }\n    }\n});\nt.start();\n// 主线程1秒后中断子线程\nThread.sleep(1000);\nt.interrupt();\n</code></pre>\n<h4 id=\"线程等待-thread-join\">线程等待 (Thread Join)</h4>\n<ul>\n<li>有时主线程需要等待子线程执行完毕后再继续执行，这时可以使用join()。</li>\n<li>t.join()：当前线程会进入阻塞状态，直到线程t执行结束。</li>\n<li>带参数的 join(long millis)：设置最大等待时间，如果超时线程还没结束，当前线程就不再等待。</li>\n</ul>\n<pre><code class=\"language-java\">Thread t = new Thread(() -&gt; {\n    System.out.println(\"子线程开始执行\");\n    try { Thread.sleep(2000); } catch (InterruptedException e) {}\n    System.out.println(\"子线程执行完毕\");\n});\nt.start();\n\n// 主线程等待t执行完（最多等3秒）\nt.join(3000); \nSystem.out.println(\"主线程继续执行\");\n</code></pre>\n<h4 id=\"线程休眠-thread-sleep\">线程休眠 (Thread Sleep)</h4>\n<ul>\n<li>static void sleep(long millis)：让当前线程暂停指定时间（不会释放锁），抛出InterruptedException</li>\n</ul>\n<pre><code class=\"language-java\">System.out.println(\"开始休眠\");\ntry {\n    Thread.sleep(2000); // 当前线程休眠2秒\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.println(\"休眠结束\");\n</code></pre>\n<h4 id=\"获取线程实例-get-current-instance\">获取线程实例 (Get Current Instance)</h4>\n<ul>\n<li>在编写通用代码（尤其是 Runnable 中）时，常需要知道是谁在运行。</li>\n<li>Thread.currentThread()：返回代码当前正在执行的那个线程对象的引用。</li>\n<li>常用操作：获取线程 ID (getId())、获取线程名称 (getName()) 等。</li>\n</ul>\n<pre><code class=\"language-java\">// 获取当前线程（这里是main线程）\nThread mainThread = Thread.currentThread();\nSystem.out.println(\"当前线程名：\" + mainThread.getName()); // 输出\"main\"\n\n// 子线程实例\nThread t = new Thread(() -&gt; {\n    Thread current = Thread.currentThread();\n    System.out.println(\"子线程名：\" + current.getName()); // 输出\"Thread-0\"\n});\nt.start();\n</code></pre>\n<hr />\n<h3 id=\"java线程的几种状态\">Java线程的几种状态</h3>\n<h4 id=\"线程状态一共有几种\">线程状态一共有几种？</h4>\n<ul>\n<li>Java线程共有6种状态：\n<ul>\n<li>NEW (新建)</li>\n<li>RUNNABLE (可运行)</li>\n<li>BLOCKED (阻塞)</li>\n<li>WAITING (等待)</li>\n<li>TIMED_WAITING (超时等待)</li>\n<li>TERMINATED (终止)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"每种状态的含义与切换条件\">每种状态的含义与切换条件</h4>\n<ol>\n<li>NEW (新建)</li>\n</ol>\n<ul>\n<li>含义：创建了线程对象（new Thread()），但尚未调用 start() 方法。</li>\n<li>切换：调用 start() 方法后，进入 RUNNABLE 状态。</li>\n</ul>\n<ol start=\"2\">\n<li>RUNNABLE (可运行)</li>\n</ol>\n<ul>\n<li>含义：Java 将操作系统中的“就绪（Ready）”和“运行中（Running）”两种状态统称为 RUNNABLE。处于该状态的线程可能正在 CPU 上执行，也可能正在等待操作系统分配时间片。</li>\n<li>切换：\n<ul>\n<li>就绪 -&gt; 运行：获得 CPU 时间片。</li>\n<li>运行 -&gt; 就绪：CPU 时间片用完，或主动调用 Thread.yield()。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>BLOCKED (阻塞)</li>\n</ol>\n<ul>\n<li>含义：线程正在等待获取一个排他锁（如进入synchronized 代码块/方法），但该锁目前被其他线程持有。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; BLOCKED：尝试进入 synchronized 区域失败。</li>\n<li>BLOCKED -&gt; RUNNABLE：其他线程释放锁，当前线程成功竞争到锁。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li>WAITING (等待)</li>\n</ol>\n<ul>\n<li>含义：线程处于无限期的等待状态，不会被分配 CPU 时间，必须等待其他线程显式地唤醒。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; WAITING：调用 Object.wait()（不带参数）、Thread.join()（不带参数）或 LockSupport.park()。</li>\n<li>WAITING -&gt; RUNNABLE：其他线程调用 Object.notify()、notifyAll() 或 LockSupport.unpark()。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>TIMED_WAITING (超时等待)</li>\n</ol>\n<ul>\n<li>含义：与 WAITING 类似，但在指定的时间后会自动唤醒，不需要其他线程显式唤醒。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; TIMED_WAITING：调用 Thread.sleep(ms)、Object.wait(ms)、Thread.join(ms) 等带时间参数的方法。</li>\n<li>TIMED_WAITING -&gt; RUNNABLE：时间结束，或被提前唤醒（如 notify()）。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"6\">\n<li>TERMINATED (终止)</li>\n</ol>\n<ul>\n<li>含义：线程已经执行完毕（run() 方法正常结束）或因异常退出了执行。</li>\n<li>切换：线程一旦进入此状态，生命周期结束，不可再次启动（再次调用 start() 会抛出异常）。</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 00:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">100</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "初识Tauri",
      "link": "https://www.cnblogs.com/-867259206/p/19463606",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/-867259206/p/19463606\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 23:24\">\n    <span>初识Tauri</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简述\">简述</h1>\n<p>Tauri是一个跨平台的开发框架，使用rust开发。前端用前端技术构建用户界面，后端使用rust和平台系统交互。</p>\n<h2 id=\"创建项目\">创建项目</h2>\n<p>可以用Bash/PowerShell/Fish/npm/deno/Cargo等工具创建项目。</p>\n<p>下面以pnpm示例：</p>\n<pre><code class=\"language-bash\">pnpm create tauri-app\n</code></pre>\n<p>后面的步骤和创建前端项目是一样的。根据提示选择前端的语言、框架等等。</p>\n<p>项目目录和前端项目也是一样的，只是多了一个src-tauri目录。</p>\n<p>src-tauri目录下就是rust代码，可以在里面编写供前端调用的方法，或者是给前端发送事件消息。</p>\n<p>界面的开发使用前端技术，可以用react，也可以用vue，或者其他前端框架。与平台系统交互的功能，用rust编写。</p>\n<p>对Web开发者来说，用这个技术可以快速地创建桌面应用。</p>\n<h2 id=\"发布\">发布</h2>\n<p>要打包成桌面应用的话，执行build命令就好。</p>\n<p>继续以pnpm为例：</p>\n<pre><code class=\"language-bash\">pnpm tauri build\n</code></pre>\n<blockquote>\n<p>提示：build之前要先安装rust环境</p>\n</blockquote>\n<p>目前Tauri支持Linux、macOS、Windows、Android、iOS。</p>\n<p>打包后的启动程序在src-tauri/target/release/bundle目录下。执行安装程序，安装好后，就可以打开编写的桌面应用了。</p>\n<h1 id=\"架构\">架构</h1>\n<p><img alt=\"架构\" class=\"lazyload\" />Tauri的核心包含一个Tauri的运行时，tauri-runtime在tauri本身和底层的webview抽象层中充当一个胶水层。</p>\n<p>Tauri使用WRY这个开源库做webview的抽象层。WRY是一个rust编写的webview渲染库，可以支持各种平台的桌面应用。在WRY和tauri-runtime之间，有一个tauri-runtime-wry，这一层为WRY定义了系统级的交互。</p>\n<p>而WRY的下层依赖TAO。TAO是基于winit的一个fork。这是一个rust编写的跨平台的窗口管理类库。支持几乎所有的主流平台，Windows、Linux、Mac OS、Android、iOS……</p>\n<p>最后简单总结：Tauri实现跨平台应用的方式是，实现一个webview的抽象，从而可以用前端技术编写GUI，webview抽象层的底层，则依赖rust的窗口管理类库，调用各个平台系统的webview库。</p>\n<h1 id=\"总结\">总结</h1>\n<p>用rust作后端，使Tauri有很高的性能。但是调用平台系统本身webview的跨平台方式，使GUI在不同平台上的表现不一致，有兼容性问题。</p>\n<p>和electron相比，拥有更小的包体积，因为没有打包chromium，也没有源码泄露之类的风险，性能也更好，还能打包移动端，但是会有兼容性问题，而且后端用rust的话，不如electron好上手，如果不是rust熟手的话。</p>\n<p>和flutter相比，同样有兼容性问题，dart也比rust好学。</p>\n<p>对rust开发者来说，只需要找rust的GUI库就行，没有必要去用前端编写GUI。而对前端开发者来说，rust又增加了开发的学习成本。这个框架，感觉只适合同时会rust的前端熟手。而且只有少数对性能要求较高的场景会需要使用，其他场景electron也不差。如果要开发跨平台的应用，兼容性又是一个问题。实际的产品表现，肯定不如flutter这类框架。</p>\n<p>在前端工具链也越来越多使用rust语言的时候，Tauri这些rust编写的框架也被一些前端开发者所使用。但如果我要开发一个跨平台的应用的话，我觉得自带绘图库的flutter的方案是最佳的。Tauri的兼容性问题，仍不能满足做商业应用的要求，能使用的场景太少了。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 23:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/-867259206\">池月</a>&nbsp;\n阅读(<span id=\"post_view_count\">142</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款基于 .NET 9 构建的企业级 Web RBAC 快速开发框架",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19463583",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19463583\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 23:03\">\n    <span>一款基于 .NET 9 构建的企业级 Web RBAC 快速开发框架</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>今天大姚给大家分享一款基于 .NET 9 构建的企业级、开源 Web RBAC 快速开发框架：RuYiAdmin。</span></p>\n<h2><span>项目介绍</span></h2>\n<p><span>RuYiAdmin 一款基于 .NET 9 构建的企业级、前后端分离、开源（Apache License） Web RBAC 快速开发框架，具有灵活的架构设计和强大的功能，适用于快速开发高性能的企业级应用，具有低代码、跨平台、分布式、多线程和高性能等特色。</span></p>\n<h2><span>适用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><span>企业级后台管理系统：用于企业内部的各种管理任务，如用户管理、权限控制、数据统计等。</span></li>\n<li><span>内容管理系统（CMS）：用于网站内容的创建、编辑、发布和管理。</span></li>\n<li><span>客户关系管理（CRM）系统：帮助企业跟踪和管理客户信息、销售机会和客户服务请求。</span></li>\n</ul>\n<h2><span>主要特点</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>前后端分离：</strong><span>&nbsp;RuYiAdmin 采用前后端分离架构，前端基于VueElementAdmin，使用 Vue2 和 Element UI，后端基于 .NET 9 构建。</span></li>\n<li><strong>代码自动生成：</strong><span>&nbsp;支持一键生成视图层、控制层、服务层、仓储层、领域层和 DTO 业务模型层代码，极大地缩短了开发周期。</span></li>\n<li><strong>多数据库支持：</strong><span>&nbsp;支持多种关系型数据库（如 MySQL、SqlServer、SQLite、Oracle、PostgreSQL、OpenGauss、<span>Kingbase、DM）和非关系型数据库（如 Redis、MongoDB、Elasticsearch、Meilisearch），同时支持动态数据源，以满足不同企业的需求。</span></span></li>\n<li><strong>项目安全性高：</strong><span>&nbsp;支持4A等级认证，满足等保三级要求，支持防 SQL 注入、防 Token 劫持、防接口渗透与抖动，集成RSA、AES及国产 SM 加密算法，支持全链路HTTPS加密传输协议，确保企业级应用的安全性。</span></li>\n<li><span>支持微服务，支持服务的注册、发现、健康检查、熔断和降级。</span></li>\n</ul>\n<h2><span>项目技术栈</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><span>前端：Vue2、Element UI、Node.js等。</span></li>\n<li><span>后端：C#、.NET 9、AspNetCoreRateLimit、<span>SqlSugar、AutoMapper、SignalR、MiniProfiler、CAP、RabbitMQ、Redis、Consul等。</span></span></li>\n</ul>\n<h2><span>安装教程</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109225902010-549085141.png\" /></p>\n<h2><span>软件架构图</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109225914600-2077383226.png\" /></p>\n<h2><span>项目源代码</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230143000-1636008500.png\" /></p>\n<h2><span>项目效果截图</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230153456-1478242349.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230157723-87615533.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230203615-1395111698.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230210957-1745363029.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230216437-1329007995.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230222905-1152283619.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230230693-1691017440.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205853857-1849985119.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205859134-1945950810.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230248378-53584818.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230253718-384227715.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205908099-602806087.png\" /></p>\n<h2><span>项目源码地址</span></h2>\n<p><span>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/pang-mingjun/RuYiAdmin\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/pang-mingjun/RuYiAdmin</span></a></li>\n</ul>\n<h2><span>优秀项目和框架精选</span></h2>\n<p><span>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong><span>）。</span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>GitHub开源地址：</strong><a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n</ul>\n<div id=\"gtx-trans\">&nbsp;</div>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 23:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">325</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ftrace可视化工具迎来重大升级",
      "link": "https://www.cnblogs.com/pengdonglin137/p/19463398",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/pengdonglin137/p/19463398\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 21:15\">\n    <span>ftrace可视化工具迎来重大升级</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><img alt=\"sample\" src=\"https://img2024.cnblogs.com/blog/480488/202601/480488-20260109211236842-806107884.png\" width=\"500\" /></p>\n<p>今天对<a href=\"https://mp.weixin.qq.com/s/rNiWXC8YlZiAjfcjv7QtQA\" rel=\"noopener nofollow\" target=\"_blank\" title=\"ftrace可视化工具\">ftrace可视化工具</a>进行了重大改造，提升了代码定位的准确性，此外处理性能也得到指数级的提高。</p>\n<p>首先是<strong>提高了代码定位的准确性</strong>。做这个工具的初衷就是<strong>希望让全球广大Linux内核爱好者在看trace时可以很容易定位当前函数具体是在代码的哪一行调用的</strong>，这对于梳理代码执行流程至关重要。而funcgraph-retaddr输出的是函数的返回地址，直接对这个地址调用addr2line显然不满足我们的要求。根据函数调用的原理，在执行函数调用指令时，CPU会自动保存下一条指令的地址，因此解决方案也非常简单粗暴，直接对返回地址减去一定数值得到前一条指令的起始地址，可是具体减多少呢？对于ARM64架构，每条指令固定占4字节，所以减4可以。但是对于像x86架构这种变长指令集，就不好确定了。我的<a href=\"https://mp.weixin.qq.com/s/Z5aIf9UhMtVK1N6vmPTRYQ\" rel=\"noopener nofollow\" target=\"_blank\" title=\"AI知识库\">AI知识库</a>说addr2line不需要精确的指令起始地址，只需落在某行代码对应的指令范围内即可正确映射，这个工具的设计初衷就是处理近似地址(如Oops中的函数+偏移)，为的是方便调试。所以统一减1就可以保证得到的地址落在前一条指令的范围内(DWARF规范也是这么推荐的)，再调用addr2line就可以得到当前函数被调用的准确位置。</p>\n<p>然后就是<strong>大幅提高了解析trace文件的性能</strong>。目前根据地址解析得到代码行调用的是内核的faddr2line工具，它是用bash脚本语言编写的，执行的时候调用了很多三方的工具，比如readelf、grep以及awk等，同时它内部使用了多个循环遍历的算法(O(N))，对于处理像vmlinux这种包含几十万个函数符号的ELF文件来说就非常不合适。所以用python语言对这个工具进行了重写，不再调用三方的工具（仅保留addr2line），同时引入了多个二分搜索算法(O(LogN))，使文件的处理性能得到指数级的提高。以处理一个40行的trace文件为例，如果使用传统的faddr2line的话，需要大约54秒，而重写后仅需6秒。处理1000行trace日志，耗时也只有7秒，大部分时间（5秒多）都消耗在启动时解析vmlinux，构建内部数据结构上了。</p>\n<p>虽然全程都是让AI编码，但需要自己<a href=\"https://yb.tencent.com/s/y2zNMNFaxhu3\" rel=\"noopener nofollow\" target=\"_blank\" title=\"对整个流程有一个清晰的理解\">对整个流程有一个清晰的理解</a>，然后给AI提出需求，AI写完后还需要人工走读，发现待优化的点，让AI继续优化，前后折腾了有将近30版。</p>\n<p>目前我在gitee上给这个工具建立了一个仓库，方便后续继续完善，项目地址是：<a href=\"https://gitee.com/pengdonglin137/funcgraph_visualization\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/pengdonglin137/funcgraph_visualization</a></p>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/pengdonglin137/\" target=\"_blank\">dolinux</a>，未经同意，禁止转载</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 21:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/pengdonglin137\">dolinux</a>&nbsp;\n阅读(<span id=\"post_view_count\">106</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Flink源码阅读：Task数据交互",
      "link": "https://www.cnblogs.com/Jackeyzhe/p/19463278",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Jackeyzhe/p/19463278\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 20:11\">\n    <span>Flink源码阅读：Task数据交互</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Flink源码阅读：Task数据交互\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1828322/202601/1828322-20260109201055245-933532869.png\" />\n        经过前面的学习，Flink 的几个核心概念相关的源码实现我们已经了解了。本文我们来梳理 Task 的数据交互相关的源码。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>经过前面的学习，Flink 的几个核心概念相关的源码实现我们已经了解了。本文我们来梳理 Task 的数据交互相关的源码。</p>\n<h3 id=\"数据输出\">数据输出</h3>\n<p>话不多说，我们直接进入正题。首先来看 Task 的数据输出，在进入流程之前，我们先介绍几个基本概念。</p>\n<h4 id=\"基本概念\">基本概念</h4>\n<ul>\n<li>\n<p>RecordWriterOutput：它是 Output 接口的一个具体实现类，底层使用 RecordWriter 来发送数据。</p>\n</li>\n<li>\n<p>RecordWriter：数据写入的执行者，负责将数据写到 ResultPartition。</p>\n</li>\n<li>\n<p>ResultPartition 和 ResultSubpartition：ResultPartition 是 ExecutionGraph 中一个节点的输出结果，下游的每个需要从当前 ResultPartition 消费数据的 Task 都会有一个 ResultSubpartition。</p>\n</li>\n<li>\n<p>ChannelSelector：用来决定一个 Record 要被写到哪个 Subpartition 中。</p>\n</li>\n<li>\n<p>LocalBufferPool：用来管理 Buffer 的缓冲池。在介绍反压的原理时，我们提到过。</p>\n</li>\n</ul>\n<p>对这些基本概念有了一定的了解之后，我们来看数据输出的具体流程。</p>\n<h4 id=\"执行流程\">执行流程</h4>\n<p>我们以 map 为例，看一下数据的输出过程。</p>\n<p><img alt=\"DataOutput\" class=\"lazyload\" /></p>\n<p>在 <code>StreamMap.processElement</code> 方法中，调用完 map 方法之后，就会调用 <code>output.collect</code> 方法将数据输出，这里的 output 就是 RecordWriterOutput。在 RecordWriterOutput 中，会调用 RecordWriter 的 emit 方法。</p>\n<pre><code class=\"language-java\">private &lt;X&gt; void pushToRecordWriter(StreamRecord&lt;X&gt; record) {\n    serializationDelegate.setInstance(record);\n\n    try {\n        recordWriter.emit(serializationDelegate);\n    } catch (IOException e) {\n        throw new UncheckedIOException(e.getMessage(), e);\n    }\n}\n</code></pre>\n<p>这里的 serializationDelegate 是用来对 record 进行序列化的。RecordWriter 有两个实现类，一个是 ChannelSelectorRecordWriter，另一个是 BroadcastRecordWriter。ChannelSelectorRecordWriter 需要先调用 ChannelSelector 选择对应的 subparition，然后进行写入。BroadcastRecordWriter 则是写到所有的 subparition。</p>\n<p>接下来就是调用 <code>BufferWritingResultPartition.emitRecord</code> 来写入数据。</p>\n<pre><code class=\"language-java\">public void emitRecord(ByteBuffer record, int targetSubpartition) throws IOException {\n    totalWrittenBytes += record.remaining();\n\n    BufferBuilder buffer = appendUnicastDataForNewRecord(record, targetSubpartition);\n\n    while (record.hasRemaining()) {\n        // full buffer, partial record\n        finishUnicastBufferBuilder(targetSubpartition);\n        buffer = appendUnicastDataForRecordContinuation(record, targetSubpartition);\n    }\n\n    if (buffer.isFull()) {\n        // full buffer, full record\n        finishUnicastBufferBuilder(targetSubpartition);\n    }\n\n    // partial buffer, full record\n}\n</code></pre>\n<p>这里把 record 写入到 buffer 中，如果 buffer 不够，则会从 LocalBufferPool 中申请新的 buffer，申请到之后就会继续写入。下面是具体的申请过程。</p>\n<pre><code class=\"language-java\">private MemorySegment requestMemorySegment(int targetChannel) {\n    MemorySegment segment = null;\n    synchronized (availableMemorySegments) {\n        checkDestroyed();\n\n        if (!availableMemorySegments.isEmpty()) {\n            segment = availableMemorySegments.poll();\n        } else if (isRequestedSizeReached()) {\n            // Only when the buffer request reaches the upper limit(i.e. current pool size),\n            // requests an overdraft buffer.\n            segment = requestOverdraftMemorySegmentFromGlobal();\n        }\n\n        if (segment == null) {\n            return null;\n        }\n\n        if (targetChannel != UNKNOWN_CHANNEL) {\n            if (++subpartitionBuffersCount[targetChannel] == maxBuffersPerChannel) {\n                unavailableSubpartitionsCount++;\n            }\n        }\n\n        checkAndUpdateAvailability();\n    }\n    return segment;\n}\n</code></pre>\n<p>如果有可用内存，就直接从队列中出队。如果达到了本地 BufferPool 的上限，就从全局的 NetworkBufferPool 中申请，申请不到就会阻塞写入过程，等待申请。最后还会检查并更新可用内存状态。</p>\n<p>有了可用的 buffer 之后，就会调用 addToSubpartition，最终数据存储在 PipelinedSubpartition 的 buffers 队列中。</p>\n<pre><code class=\"language-java\">private void addToSubpartition(\n        BufferBuilder buffer,\n        int targetSubpartition,\n        int partialRecordLength,\n        int minDesirableBufferSize)\n        throws IOException {\n    int desirableBufferSize =\n            subpartitions[targetSubpartition].add(\n                    buffer.createBufferConsumerFromBeginning(), partialRecordLength);\n\n    resizeBuffer(buffer, desirableBufferSize, minDesirableBufferSize);\n}\n</code></pre>\n<h3 id=\"数据输入\">数据输入</h3>\n<p>看完了数据输出的过程之后，我们再来看一下数据输入的过程。首先还是了解几个基本概念。</p>\n<h4 id=\"基本概念-1\">基本概念</h4>\n<ul>\n<li>\n<p>InputGate：InputGate 是对输入的封装，与 JobGraph 中的 JobEdge 一一对应，每个 InputGate 消费上游一个或多个 Resultpartition。</p>\n</li>\n<li>\n<p>InputChannel：InputChannel 是和 ExecutionGraph 中的 ExecutionEdge 一一对应的。每个 InputChannel 接收一个 ResultSubpartition 的输出，InputChannel 主要关注 LocalInputChannel 和 RemoteInputChannel 两种实现。</p>\n</li>\n</ul>\n<h4 id=\"执行流程-1\">执行流程</h4>\n<p>了解了具体概念之后，我们再看数据输入的具体流程。</p>\n<p><img alt=\"RecordInput\" class=\"lazyload\" /></p>\n<p>数据输入的入口是 <code>StreamTask.processInput</code> 方法，这个方法中主要是调用 <code>inputProcessor.processInput</code> 方法，我们以 StreamOneInputProcessor 为例。这个方法就是调用 <code>input.emitNext</code> 方法。</p>\n<pre><code class=\"language-java\">public DataInputStatus emitNext(DataOutput&lt;T&gt; output) throws Exception {\n\n    while (true) {\n        // get the stream element from the deserializer\n        if (currentRecordDeserializer != null) {\n            RecordDeserializer.DeserializationResult result;\n            try {\n                result = currentRecordDeserializer.getNextRecord(deserializationDelegate);\n            } catch (IOException e) {\n                throw new IOException(\n                        String.format(\"Can't get next record for channel %s\", lastChannel), e);\n            }\n            if (result.isBufferConsumed()) {\n                currentRecordDeserializer = null;\n            }\n\n            if (result.isFullRecord()) {\n                final boolean breakBatchEmitting =\n                        processElement(deserializationDelegate.getInstance(), output);\n                if (canEmitBatchOfRecords.check() &amp;&amp; !breakBatchEmitting) {\n                    continue;\n                }\n                return DataInputStatus.MORE_AVAILABLE;\n            }\n        }\n\n        Optional&lt;BufferOrEvent&gt; bufferOrEvent = checkpointedInputGate.pollNext();\n        if (bufferOrEvent.isPresent()) {\n            // return to the mailbox after receiving a checkpoint barrier to avoid processing of\n            // data after the barrier before checkpoint is performed for unaligned checkpoint\n            // mode\n            if (bufferOrEvent.get().isBuffer()) {\n                processBuffer(bufferOrEvent.get());\n            } else {\n                DataInputStatus status = processEvent(bufferOrEvent.get(), output);\n                if (status == DataInputStatus.MORE_AVAILABLE &amp;&amp; canEmitBatchOfRecords.check()) {\n                    continue;\n                }\n                return status;\n            }\n        } else {\n            if (checkpointedInputGate.isFinished()) {\n                checkState(\n                        checkpointedInputGate.getAvailableFuture().isDone(),\n                        \"Finished BarrierHandler should be available\");\n                return DataInputStatus.END_OF_INPUT;\n            }\n            return DataInputStatus.NOTHING_AVAILABLE;\n        }\n    }\n}\n</code></pre>\n<p>这里是调用 <code>checkpointedInputGate.pollNext</code> 来获取输入的数据。它的内部就是调用 InputGate 的 pollNext 方法来获取数据。当获取到完整数据之后，就会调用 processElement 来处理数据。</p>\n<p>我们以 SingleInputGate 为例看 InputGate 的 pollNext 方法。它的内部调用链路可用一直追踪到 readBufferFromInputChannel 方法，这个方法内会调用 <code>inputChannel.getNextBuffer</code>，这里交给 InputChannel 来具体执行数据读取。</p>\n<pre><code class=\"language-java\">public Optional&lt;BufferAndAvailability&gt; getNextBuffer() throws IOException {\n    checkError();\n\n    if (!toBeConsumedBuffers.isEmpty()) {\n        return getBufferAndAvailability(toBeConsumedBuffers.removeFirst());\n    }\n\n    ResultSubpartitionView subpartitionView = this.subpartitionView;\n    if (subpartitionView == null) {\n        // There is a possible race condition between writing a EndOfPartitionEvent (1) and\n        // flushing (3) the Local\n        // channel on the sender side, and reading EndOfPartitionEvent (2) and processing flush\n        // notification (4). When\n        // they happen in that order (1 - 2 - 3 - 4), flush notification can re-enqueue\n        // LocalInputChannel after (or\n        // during) it was released during reading the EndOfPartitionEvent (2).\n        if (isReleased) {\n            return Optional.empty();\n        }\n\n        // this can happen if the request for the partition was triggered asynchronously\n        // by the time trigger\n        // would be good to avoid that, by guaranteeing that the requestPartition() and\n        // getNextBuffer() always come from the same thread\n        // we could do that by letting the timer insert a special \"requesting channel\" into the\n        // input gate's queue\n        subpartitionView = checkAndWaitForSubpartitionView();\n    }\n\n    BufferAndBacklog next = subpartitionView.getNextBuffer();\n    // ignore the empty buffer directly\n    while (next != null &amp;&amp; next.buffer().readableBytes() == 0) {\n        next.buffer().recycleBuffer();\n        next = subpartitionView.getNextBuffer();\n        numBuffersIn.inc();\n    }\n\n    if (next == null) {\n        if (subpartitionView.isReleased()) {\n            throw new CancelTaskException(\n                    \"Consumed partition \" + subpartitionView + \" has been released.\");\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    Buffer buffer = next.buffer();\n\n    if (buffer instanceof FullyFilledBuffer) {\n        List&lt;Buffer&gt; partialBuffers = ((FullyFilledBuffer) buffer).getPartialBuffers();\n        int seq = next.getSequenceNumber();\n        for (Buffer partialBuffer : partialBuffers) {\n            toBeConsumedBuffers.add(\n                    new BufferAndBacklog(\n                            partialBuffer,\n                            next.buffersInBacklog(),\n                            buffer.getDataType(),\n                            seq++));\n        }\n\n        return getBufferAndAvailability(toBeConsumedBuffers.removeFirst());\n    }\n\n    return getBufferAndAvailability(next);\n}\n</code></pre>\n<p>我们先来看 LocalInputChannel，先获取到了 subpartitionView，并调用 getNextBuffer，这里其实就是从 PipelinedSubpartition 的 buffers 队列中读取数据。</p>\n<p>RemoteInputChannel 则需要从 receivedBuffers 中读取数据，这个队列的数据就是消费上游数据后保存的。</p>\n<p>至此，Flink 中 Task 的数据输入和输出过程的源码就梳理完了，更加底层的 Netty 相关代码我们在后面继续梳理。</p>\n<h3 id=\"总结\">总结</h3>\n<p>最后简单总结一下，本文我们梳理了 Task 的数据输出和输入的过程。输出过程主要是利用 RecordWriter 将数据写入到 Buffer 中，输入过程则是利用 InputChannel 从 Buffer 消费的过程。如果你的 Flink 任务数据量特别大，并且没什么复杂的逻辑，可以考虑适当调整 localBufferPool 的大小来调优任务的吞吐。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 20:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Jackeyzhe\">Jackeyzhe</a>&nbsp;\n阅读(<span id=\"post_view_count\">54</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}