{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "基于 C# 和 Nuke 打造现代化构建系统的最佳实践",
      "link": "https://www.cnblogs.com/newbe36524/p/19536496",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/newbe36524/p/19536496\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 08:54\">\n    <span>基于 C# 和 Nuke 打造现代化构建系统的最佳实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"告别脚本地狱为什么我们选择用-c-打造现代化构建系统\">告别脚本地狱：为什么我们选择用 C# 打造现代化构建系统</h1>\n<blockquote>\n<p>揭秘 HagiCode 项目如何利用 Nuke 实现类型安全、跨平台且高度可扩展的自动化构建流程，彻底解决传统构建脚本的维护痛点。</p>\n</blockquote>\n\n<h2 id=\"背景\">背景</h2>\n<p>在软件开发的漫长旅途中，\"构建\"这个词往往让人又爱又恨。爱的是，一键点击，代码变成产品，那是程序员最迷人的时刻；恨的是，维护那一堆乱糟糟的构建脚本，简直是噩梦。</p>\n<p>在很多项目中，我们习惯了用 Python 写脚本，或者用 XML 配置文件（想象一下那段被 <code>&lt;property&gt;</code> 支配的恐惧）。但随着项目复杂度的提升，尤其是像 HagiCode 这样涉及前后端、多平台、多语言混合开发的项目，传统的构建方式开始显得力不从心。脚本逻辑分散、缺乏类型检查、IDE 支持弱……这些问题像一个个小坑，时不时就让开发团队绊个跟头。</p>\n<p>为了解决这些痛点，在 HagiCode 项目中，我们决定引入 <strong>Nuke</strong> —— 一个基于 C# 的现代化构建系统。它不仅仅是一个工具，更像是一种对构建流程的重新思考。今天，我们就来聊聊为什么选择它，以及它是如何让我们的开发体验\"起飞\"的。</p>\n<h2 id=\"关于-hagicode\">关于 HagiCode</h2>\n<blockquote>\n<p>嘿，介绍一下我们正在做的东西</p>\n</blockquote>\n<p>我们正在开发 <strong>HagiCode</strong> —— 一款 AI 驱动的代码智能助手，让开发体验变得更智能、更便捷、更有趣。</p>\n<p><strong>智能</strong> —— AI 全程辅助，从想法到代码，让编码效率提升数倍。<strong>便捷</strong> —— 多线程并发操作，充分利用资源，开发流程顺畅无阻。<strong>有趣</strong> —— 游戏化机制和成就系统，让编码不再枯燥，充满成就感。</p>\n<p>项目正在快速迭代中，如果你对技术写作、知识管理或者 AI 辅助开发感兴趣，欢迎来 <a href=\"https://github.com/HagiCode-org/site\" rel=\"noopener nofollow\" target=\"_blank\">GitHub</a> 看看～</p>\n<h2 id=\"核心剖析为什么是-nuke\">核心剖析：为什么是 Nuke？</h2>\n<p>你可能心里会犯嘀咕：\"哎呀，构建系统那么多，比如 Make、Gradle，甚至直接用 Shell 脚本不行吗？为啥非得整一个 C# 的？\"</p>\n<p>这其实是个好问题。Nuke 的核心魅力在于它把我们最熟悉的编程语言特性带进了构建脚本的世界。</p>\n<h3 id=\"1-将构建流程模块化target-的艺术\">1. 将构建流程模块化：Target 的艺术</h3>\n<p>Nuke 的设计理念非常清晰：<strong>一切皆为目标</strong>。</p>\n<p>在传统的脚本里，我们可能会写出几百行线性执行的代码，逻辑错综复杂。而在 Nuke 中，我们将构建流程分解为独立的 <code>Target</code>（目标）。每个目标只负责一件事，比如：</p>\n<ul>\n<li><code>Clean</code>: 清理输出目录</li>\n<li><code>Restore</code>: 还原依赖包</li>\n<li><code>Compile</code>: 编译代码</li>\n<li><code>Test</code>: 运行单元测试</li>\n</ul>\n<p>这种设计非常符合单一职责原则。就像搭积木一样，我们可以随意组合这些 Target。更重要的是，Nuke 允许我们定义 Target 之间的依赖关系。比如，你想要 <code>Test</code>，那系统会自动检查你是否先执行了 <code>Compile</code>；想要 <code>Compile</code>，自然得先 <code>Restore</code>。</p>\n<p>这种依赖关系图不仅让逻辑更清晰，还极大地提高了执行效率，Nuke 会自动分析最优执行路径。</p>\n<h3 id=\"2-类型安全告别拼写错误的噩梦\">2. 类型安全：告别拼写错误的噩梦</h3>\n<p>用过 Python 写构建脚本的朋友肯定遇到过这种尴尬：脚本跑了五分钟，最后报错说 <code>Confi.guration</code> 拼写错了，或者传了一个字符串给了一个本该是数字的参数。</p>\n<p>使用 C# 编写构建脚本最大的优势就是 <strong>类型安全</strong>。这意味着：</p>\n<ul>\n<li><strong>编译时检查</strong>：你在敲代码的时候，IDE 就会告诉你哪里错了，不用等到运行时才发现。</li>\n<li><strong>重构无忧</strong>：如果你想改个变量名或者方法名，IDE 的重构功能一键搞定，不用全局搜索替换提心吊胆。</li>\n<li><strong>智能提示</strong>：强大的 IntelliSense 会自动补全代码，你不需要去翻文档记那些生僻的 API。</li>\n</ul>\n<h3 id=\"3-跨平台统一的构建体验\">3. 跨平台：统一的构建体验</h3>\n<p>以前在 Windows 上写 <code>.bat</code>，在 Linux 上写 <code>.sh</code>，为了兼容两者，还得写个 Python 脚本。现在，只要是 .NET Core（现 .NET 5+）能跑的地方，Nuke 就能跑。</p>\n<p>这意味着无论团队成员是使用 Windows、Linux 还是 macOS，无论是用 Visual Studio、VS Code 还是 Rider，大家执行的都是同一套逻辑。这就极大地消除了\"在我机器上能跑\"这类环境差异导致的问题。</p>\n<h3 id=\"4-参数与配置管理\">4. 参数与配置管理</h3>\n<p>Nuke 提供了一套非常优雅的参数解析机制。你不需要手动去解析 <code>string[] args</code>，只需要定义一个属性，加上 <code>[Parameter]</code> 特性，Nuke 就会自动处理命令行参数和配置文件的映射。</p>\n<p>比如，我们可以轻松定义构建配置：</p>\n<pre><code class=\"language-csharp\">[Parameter(\"Configuration to build - Default is 'Debug'\")]\nreadonly Configuration BuildConfiguration = IsLocalBuild ? Configuration.Debug : Configuration.Release;\n\nTarget Compile =&gt; _ =&gt; _\n    .DependsOn(Restore)\n    .Executes(() =&gt;\n    {\n        // 在这里使用 BuildConfiguration，它是类型安全的\n        DotNetBuild(s =&gt; s\n            .SetConfiguration(BuildConfiguration)\n            .SetProjectFile(SolutionFile));\n    });\n</code></pre>\n<p>这种写法既直观又不容易出错。</p>\n<h2 id=\"实践指南如何在项目中落地\">实践指南：如何在项目中落地</h2>\n<p>空谈误国，实干兴邦。让我们看看在 HagiCode 项目中，具体是怎么落地这套方案的。</p>\n<h3 id=\"1-规划项目结构\">1. 规划项目结构</h3>\n<p>我们不想让构建脚本污染项目根目录，也不想搞得像某些 Java 项目那样目录结构深不见底。所以，我们将所有与 Nuke 相关的构建文件统一放置在 <code>nukeBuild/</code> 文件夹中。</p>\n<p>这样做的好处是：</p>\n<ul>\n<li>项目根目录保持清爽。</li>\n<li>构建逻辑内聚，方便管理。</li>\n<li>新成员加入时，一眼就能看到\"哦，这是构建相关的逻辑\"。</li>\n</ul>\n<h3 id=\"2-设计清晰的-target-依赖链\">2. 设计清晰的 Target 依赖链</h3>\n<p>在设计 Target 时，我们遵循了一个原则：<strong>原子化 + 依赖流</strong>。</p>\n<p>每个 Target 应该足够小，只做一件事。比如 <code>Clean</code> 就只管删文件，不要在里面顺便做打包。</p>\n<p>推荐的依赖流大概是这个样子的：</p>\n<p><code>Clean</code> -&gt; <code>Restore</code> -&gt; <code>Compile</code> -&gt; <code>Test</code> -&gt; <code>Pack</code></p>\n<p>当然，这不是绝对的。比如如果你只想跑个测试，不想打包，Nuke 允许你直接执行 <code>nuke Test</code>，它会自动处理好前置的 Restore 和 Compile 步骤。</p>\n<h3 id=\"3-完善的错误处理与日志\">3. 完善的错误处理与日志</h3>\n<p>构建脚本最怕的是什么？是报错信息不明确。比如构建失败了，日志只显示 \"Error: 1\"，这就让人很抓狂。</p>\n<p>在 Nuke 中，由于我们可以直接使用 C# 的异常处理机制，因此可以非常精确地捕获和报告错误。</p>\n<pre><code class=\"language-csharp\">Target Publish =&gt; _ =&gt; _\n    .DependsOn(Test)\n    .Executes(() =&gt;\n    {\n        try \n        {\n            // 尝试发布到 NuGet\n            DotNetNuGetPush(s =&gt; s\n                .SetTargetPath(ArtifactPath)\n                .SetSource(\"https://api.nuget.org/v3/index.json\")\n                .SetApiKey(ApiKey));\n        }\n        catch (Exception ex)\n        {\n            Log.Error($\"发布失败了，兄弟们检查一下 Key 对不对: {ex.Message}\");\n            throw; // 确保构建进程以非零退出码结束\n        }\n    });\n</code></pre>\n<h3 id=\"4-集成测试保障质量\">4. 集成测试保障质量</h3>\n<p>构建脚本本身也是代码，也需要测试。Nuke 允许我们为构建流程编写测试，确保当我们修改了构建逻辑后，不会破坏现有的发布流程。这在持续集成（CI）流水线中尤为重要。</p>\n<h2 id=\"总结\">总结</h2>\n<p>通过引入 Nuke，HagiCode 的构建流程变得前所未有的顺畅。它不仅仅是一个工具的替换，更是工程化思维的提升。</p>\n<p><strong>我们收获了什么？</strong></p>\n<ul>\n<li><strong>可维护性</strong>：代码即配置，逻辑清晰，新人也能快速上手。</li>\n<li><strong>稳定性</strong>：强类型检查减少了 90% 以上的低级错误。</li>\n<li><strong>一致性</strong>：跨平台的统一体验，消除了环境差异。</li>\n</ul>\n<p>如果说以前写构建脚本是\"在黑暗中摸索\"，那么使用 Nuke 就像是\"开着灯走夜路\"。如果你受够了维护那些难以调试的脚本语言，不妨试试把构建逻辑也搬到 C# 的世界里来，也许你会发现，原来构建也可以这么优雅。</p>\n<h2 id=\"参考资料\">参考资料</h2>\n<ul>\n<li><a href=\"https://nuke.build/\" rel=\"noopener nofollow\" target=\"_blank\">Nuke 官方文档</a></li>\n<li><a href=\"https://github.com/HagiCode-org/site\" rel=\"noopener nofollow\" target=\"_blank\">HagiCode 项目地址</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/archive/csharp-team/introducing-csharp-scripting\" rel=\"noopener nofollow\" target=\"_blank\">关于 C# Scripting 的更多细节</a></li>\n</ul>\n<hr />\n<p>感谢您的阅读,如果您觉得本文有用,快点击下方点赞按钮👍,让更多的人看到本文。</p>\n<p>本内容采用人工智能辅助协作,经本人审核,符合本人观点与立场。</p>\n<ul>\n<li><strong>本文作者:</strong> <a href=\"https://www.newbe.pro\" rel=\"noopener nofollow\" target=\"_blank\">newbe36524</a></li>\n<li><strong>本文链接:</strong> <a href=\"https://hagicode-org.github.io/site/blog/2026/01/26/modern-build-system-with-csharp-and-nuke\" rel=\"noopener nofollow\" target=\"_blank\">https://hagicode-org.github.io/site/blog/2026/01/26/modern-build-system-with-csharp-and-nuke</a></li>\n<li><strong>版权声明:</strong> 本博客所有文章除特别声明外,均采用 BY-NC-SA 许可协议。转载请注明出处!</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-27 08:54</span>&nbsp;\n<a href=\"https://www.cnblogs.com/newbe36524\">Newbe36524</a>&nbsp;\n阅读(<span id=\"post_view_count\">64</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Sdcb Chats 1.10 私有化代码执行器部署教程",
      "link": "https://www.cnblogs.com/sdcb/p/19533814/chats-1-10-deploy",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sdcb/p/19533814/chats-1-10-deploy\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 08:45\">\n    <span>Sdcb Chats 1.10 私有化代码执行器部署教程</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>之前我写了这篇博客<a href=\"https://www.cnblogs.com/sdcb/p/19528764/chats-1-10\" target=\"_blank\">《复刻 ChatGPT 高级数据分析！Sdcb Chats 1.10 重磅发布：能分析Excel、做PPT》</a>，向大家介绍了 Chats 1.10 最激动人心的新功能——内置代码执行器（Code Interpreter）。</p>\n<p>文章发出后，反响很热烈，但也有很多朋友在问：“这功能看着很强，但到底怎么部署及其配置啊？”</p>\n<p>回头看了一下前一篇文章，确实光顾着兴奋地介绍功能，把最关键的<strong>部署实操</strong>给略过了。为了让大家都能尽快用上这个“硬核”功能，今天特地补上这篇详细的保姆级部署配置文档。</p>\n<hr />\n<p>想要在 Chats 中使用“代码执行”功能，主要分两步走：</p>\n<ol>\n<li><strong>基础设施层</strong>：让 Chats 服务能连上 Docker Daemon（因为代码是在隔离的 Docker 容器中运行的）。</li>\n<li><strong>应用配置层</strong>：在 Chats 后台和前台开启相应的功能开关。</li>\n</ol>\n<h2 id=\"第一部分连接-docker-daemon\">第一部分：连接 Docker Daemon</h2>\n<p>Chats 的代码执行器原理是：当模型需要执行代码时，Chats 会动态创建一个一次性的 Docker 容器（沙箱），在里面运行代码并获取结果。因此，<strong>Chats 必须拥有管理 Docker 的权限</strong>。</p>\n<p>这里主要介绍两种最常见的场景：纯 Docker 环境（Linux 服务器）和 Windows 下的 Docker Desktop。</p>\n<h3 id=\"场景一linux-服务器--纯-docker-环境\">场景一：Linux 服务器 / 纯 Docker 环境</h3>\n<p>这是生产环境最常用的方式。你只需要将宿主机的 Docker Socket 挂载到 Chats 容器中即可。</p>\n<p><img alt=\"00-docker\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260126155139396-122617623.avif\" /></p>\n<h4 id=\"1-docker-镜像说明\">1. Docker 镜像说明</h4>\n<p>Chats 的 Docker 镜像托管在 <code>sdcb/chats</code>，我们提供了完善的多架构支持：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">描述</th>\n<th style=\"text-align: left;\">Docker 镜像 Tag</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>Latest（推荐）</strong></td>\n<td style=\"text-align: left;\"><code>latest</code></td>\n<td style=\"text-align: left;\">包含最新稳定版功能，多架构支持</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">指定完整版本</td>\n<td style=\"text-align: left;\"><code>{version}</code> (如 <code>1.10.0</code>)</td>\n<td style=\"text-align: left;\">生产环境推荐锁定版本</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">指定主/次版本</td>\n<td style=\"text-align: left;\"><code>{major}</code> / <code>{major.minor}</code></td>\n<td style=\"text-align: left;\">如 <code>1</code>, <code>1.10</code>，自动更新到该系列最新版</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">特定平台</td>\n<td style=\"text-align: left;\"><code>...-linux-x64</code> 等</td>\n<td style=\"text-align: left;\">仅在必须手动指定架构时使用</td>\n</tr>\n</tbody>\n</table>\n<p><strong>关于 Manifest (多架构支持)</strong>：<br />\n我们的 <code>latest</code> 和语义化版本标签（如 <code>1.10.0</code>）都是 <strong>Manifest List</strong>。这意味着你<strong>不需要</strong>手动区分 <code>linux-x64</code> 还是 <code>linux-arm64</code>。<br />\n无论你在 x64 的 Linux 服务器、ARM64 的树莓派，还是 Windows Server (Nano Server) 上执行 <code>docker pull sdcb/chats:latest</code>，Docker 都会自动检测并拉取最适合当前系统的镜像层。</p>\n<h4 id=\"2-启动配置\">2. 启动配置</h4>\n<p>由于 Docker Socket 默认属于 root 用户，为了避免权限问题（Permission Denied），建议显式指定 <code>--user 0:0</code> 以 root 身份运行容器。</p>\n<p>在启动 Chats 的 <code>docker run</code> 命令或 <code>docker-compose.yml</code> 中，添加 user 配置和挂载卷：</p>\n<pre><code class=\"language-bash\">-v /var/run/docker.sock:/var/run/docker.sock --user 0:0\n</code></pre>\n<p><strong>完整的 docker run 命令示例</strong>：</p>\n<pre><code class=\"language-bash\"># 创建数据目录并授权\nmkdir -p ./AppData &amp;&amp; chmod 755 ./AppData\n\n# 启动容器\ndocker run -d --restart unless-stopped --name sdcb-chats \\\n  -p 8080:8080 \\\n  -e DBType=sqlite \\\n  -e ConnectionStrings__ChatsDB=\"Data Source=./AppData/chats.db\" \\\n  -v ./AppData:/app/AppData \\\n  -v /var/run/docker.sock:/var/run/docker.sock --user 0:0 \\\n  sdcb/chats:latest\n</code></pre>\n<p><strong>示例 docker-compose.yml</strong>：</p>\n<pre><code class=\"language-yaml\">version: '3'\nservices:\n  chats:\n    image: sdcb/chats:latest\n    user: 0:0 # 关键：必须使用 root 用户才能访问 docker.sock\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock # 关键配置：挂载 Docker 守护进程\n      - ./data:/app/data\n    ports:\n      - \"8080:8080\"\n</code></pre>\n<h3 id=\"场景二windows-环境\">场景二：Windows 环境</h3>\n<p>在 Windows (使用 Docker Desktop) 上部署时，情况稍微特殊一点，取决于你是<strong>在 Docker 容器内运行 Chats</strong>，还是<strong>直接运行 Chats 的 Windows 可执行文件 (.exe)</strong>。</p>\n<h4 id=\"情况-achats-运行在-docker-容器内推荐\">情况 A：Chats 运行在 Docker 容器内（推荐）</h4>\n<p>如果你是通过 <code>docker run</code> 启动 Chats 的，那么恭喜你，配置方法其实和 Linux <strong>完全一样</strong>！</p>\n<p>Docker Desktop for Windows 做了很好的兼容，你只需要把 <code>/var/run/docker.sock</code> 挂载进去即可，<strong>不需要</strong>配置 npipe 或 TCP。</p>\n<p><strong>PowerShell 启动命令示例</strong>：</p>\n<pre><code class=\"language-powershell\">docker run -d -p 8080:8080 `\n  -v /var/run/docker.sock:/var/run/docker.sock `\n  -v ${PWD}/data:/app/data `\n  sdcb/chats:latest\n</code></pre>\n<h4 id=\"情况-bchats-作为原生可执行文件运行\">情况 B：Chats 作为原生可执行文件运行</h4>\n<p>如果你不习惯使用 Docker 部署应用，我们提供了基于预编译的原生可执行文件，<strong>无需安装任何运行时</strong>（如 .NET SDK/Runtime）即可直接运行，启动速度较快且内存占用低。</p>\n<p><strong>可执行文件列表</strong>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">平台</th>\n<th style=\"text-align: left;\">文件名</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>Windows 64位</strong></td>\n<td style=\"text-align: left;\"><code>chats-win-x64.zip</code></td>\n<td style=\"text-align: left;\">推荐大多数 Windows 用户</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Linux 64位</td>\n<td style=\"text-align: left;\"><code>chats-linux-x64.zip</code></td>\n<td style=\"text-align: left;\">常见的 Linux 服务器 (glibc)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Linux ARM64</td>\n<td style=\"text-align: left;\"><code>chats-linux-arm64.zip</code></td>\n<td style=\"text-align: left;\">树莓派、Mac M系列docker等</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Linux Musl</td>\n<td style=\"text-align: left;\"><code>chats-linux-musl-*.zip</code></td>\n<td style=\"text-align: left;\">适用于 Alpine 等轻量级发行版</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">macOS</td>\n<td style=\"text-align: left;\"><code>chats-osx-*.zip</code></td>\n<td style=\"text-align: left;\">支持 x64 (Intel) 和 ARM64 (M系列芯片)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">通用包</td>\n<td style=\"text-align: left;\"><code>chats.zip</code></td>\n<td style=\"text-align: left;\"><strong>需安装 .NET 10</strong>，跨平台</td>\n</tr>\n</tbody>\n</table>\n<p>你可以从 <a href=\"https://github.com/sdcb/chats/blob/main/doc/zh-CN/downloads.md\" rel=\"noopener nofollow\" target=\"_blank\">下载指南文档</a> 页面获取下载地址。该文档详细列出了 GitHub Releases 及国内加速镜像的下载方式。</p>\n<p><strong>配置与启动</strong>：</p>\n<p>如果你下载了 <code>Chats.BE.exe</code> (Windows 版后端) 直接运行，而不是使用 Docker 镜像，那么你需要通过命令行参数指定 Windows 的<strong>命名管道 (Named Pipe)</strong> 来连接 Docker 引擎。</p>\n<ol>\n<li><strong>下载程序</strong>：下载并解压对应的 <code>chats-win-x64.zip</code>。</li>\n<li><strong>启动命令</strong>：使用 <code>--CodePod:DockerEndpoint</code> 参数指定 Docker 接入点。</li>\n</ol>\n<p><strong>PowerShell 启动命令示例</strong>：</p>\n<pre><code class=\"language-powershell\"># 启动后端程序，并指定 Docker 引擎地址\n.\\Chats.BE.exe --CodePod:DockerEndpoint npipe://./pipe/docker_engine\n</code></pre>\n<p>你也可以同时指定其它参数（如端口）：</p>\n<pre><code class=\"language-powershell\">.\\Chats.BE.exe --urls http://+:5000 --CodePod:DockerEndpoint npipe://./pipe/docker_engine\n</code></pre>\n<p>这样，原生运行的 Chats 也能顺利指挥 Docker Desktop 创建沙箱环境了。</p>\n<hr />\n<h2 id=\"第二部分在-chats-中启用功能\">第二部分：在 Chats 中启用功能</h2>\n<p>连上 Docker 只是打通了经脉，接下来还需要在 Chats 内部“解锁”这个技能。</p>\n<h3 id=\"1-后端配置模型设置\">1. 后端配置：模型设置</h3>\n<p>首先，我们要告诉 Chats，哪些模型允许使用这个能力。</p>\n<ol>\n<li>以管理员身份登录 Chats。</li>\n<li>进入<strong>后台管理</strong> -&gt; <strong>模型配置</strong>。</li>\n<li>展开你想要的模型提供商-&gt;模型密钥，然后编辑你想要使用的模型（例如deepseek-v3.2）。\n<ul>\n<li><strong>注意</strong>：任何支持 Tool Call (工具调用) 的模型 API 都可以，无论是 OpenAI 原生的 Chat Completions，还是Responses API/Messages API。</li>\n</ul>\n</li>\n<li>在功能列表中，找到并勾选 <strong>“代码执行 (Code Execution)”</strong>。<br />\n<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260126151714293-1229825697.avif\" /></li>\n</ol>\n<p><strong>⚠️ 特别注意：用户权限分配</strong></p>\n<p>很多第一次添加模型的朋友容易忽略这一点：<strong>启用功能后，必须明确授权给用户。</strong></p>\n<p>在模型编辑页面的底部，展开<strong>用户列表 (User Access)</strong>，确保<strong>给你自己的账号（或需要使用的用户）勾选上权限</strong>。如果不勾选，你在前台是看不到这个模型的，或者无法调用该功能。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260126151715025-1987207460.avif\" /></p>\n<h3 id=\"2-前端配置开启会话开关\">2. 前端配置：开启会话开关</h3>\n<p>后端准备就绪后，最后一步是在聊天界面开启使用。</p>\n<ol>\n<li>回到<strong>聊天 (Chat)</strong> 界面。</li>\n<li>在顶部的模型配置栏（通常显示模型名称的地方），点击展开配置面板。</li>\n<li>找到 <strong>“代码执行”</strong> 开关，将其打开。</li>\n</ol>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260126151715455-1639921351.avif\" /></p>\n<hr />\n<h2 id=\"效果演示\">效果演示</h2>\n<p>一切就绪！现在你可以像使用 ChatGPT 的高级数据分析一样，上传一个 Excel 文件，或者让它帮你画一张图表了。</p>\n<p>试试发送这样的指令：</p>\n<blockquote>\n<p>请帮我分析这个 Excel 文件：<a href=\"https://cv-public.sdcb.pub/2026/changsha_weather_2025.xlsx%EF%BC%8C%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E6%AF%8F%E6%9C%88%E5%B9%B3%E5%9D%87%E6%B0%94%E6%B8%A9%E5%92%8C%E9%99%8D%E6%B0%B4%E9%87%8F%E7%9A%84%E6%8A%A5%E5%91%8A%EF%BC%8C%E5%B9%B6%E9%99%84%E4%B8%8A%E5%9B%BE%E8%A1%A8\" rel=\"noopener nofollow\" target=\"_blank\">https://cv-public.sdcb.pub/2026/changsha_weather_2025.xlsx，生成一个包含每月平均气温和降水量的报告，并附上图表</a></p>\n</blockquote>\n<p>Chats 会自动创建一个隔离的 Docker 环境，编写 Python 代码，执行并把生成的图片直接贴在对话框里。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260125102328487-114968639.avif\" /></p>\n<hr />\n<h2 id=\"安全性考量\">安全性考量</h2>\n<p>⚠️ <strong>重要提示</strong>：与模型 API 调用不同，代码执行功能目前<strong>不进行任何计费</strong>，仅通过全局配置做了一些基础限制。如果你打算将 Chats 开放给未经充分信任的用户使用（例如搭建类似 ChatGPT/Manus 的公开服务），务必认真配置以下安全策略，避免服务器资源被滥用甚至被攻击。</p>\n<h3 id=\"1-网络隔离\">1. 网络隔离</h3>\n<p>代码执行容器的默认网络模式为 <code>bridge</code>，这与 ChatGPT 的完全隔离沙箱不同——<strong>容器是可以联网的</strong>。</p>\n<p>这个设计是有意为之的，因为它带来了更强大的能力：</p>\n<ul>\n<li>AI 可以在容器内下载文件、调用外部 API、安装依赖包。</li>\n<li>甚至可以让 AI 创建多个 Docker 容器协同工作（比如一个跑 Web 应用、一个跑数据库），Chats 会在工具调用响应中返回容器的局域网 IP 地址，模型可以据此进行容器间通信。</li>\n</ul>\n<p>但这也意味着潜在风险：</p>\n<ul>\n<li>容器可以访问宿主机同一 Docker 网络内的其他服务（包括你的数据库、Redis 等）。</li>\n<li>恶意用户可能利用此能力进行内网扫描或攻击。</li>\n</ul>\n<p><strong>建议</strong>：</p>\n<ul>\n<li><strong>安全敏感环境</strong>：将 <code>CodeInterpreter:MaxAllowedNetworkMode</code> 设置为 <code>none</code>，完全禁止容器联网。</li>\n<li><strong>物理隔离</strong>：在一台独立的虚拟机或物理机上运行 Docker Daemon，Chats 通过 TCP 远程连接，从而实现网络层面的彻底隔离。</li>\n</ul>\n<h3 id=\"2-资源限制\">2. 资源限制</h3>\n<p>AI 可以创建任意数量的 Docker 会话（通过 <code>create_docker_session</code> 工具）。虽然空闲会话会在一定时间后自动清理，但仍存在以下风险：</p>\n<ul>\n<li><strong>算力滥用</strong>：恶意用户可能运行高负载任务，耗尽服务器 CPU/内存。</li>\n<li><strong>磁盘占用</strong>：AI 可能拉取不同版本的镜像，这些镜像<strong>不会自动清理</strong>，长期积累会占满磁盘。</li>\n</ul>\n<p>Chats 提供了细粒度的资源限制配置，<strong>强烈建议根据实际情况调整</strong>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">配置项</th>\n<th style=\"text-align: left;\">默认值</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:DefaultResourceLimits:MemoryBytes</code></td>\n<td style=\"text-align: left;\"><code>2147483648</code> (2GB)</td>\n<td style=\"text-align: left;\">单个容器内存上限</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:DefaultResourceLimits:CpuCores</code></td>\n<td style=\"text-align: left;\"><code>2.0</code></td>\n<td style=\"text-align: left;\">单个容器 CPU 核数</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:DefaultResourceLimits:MaxProcesses</code></td>\n<td style=\"text-align: left;\"><code>200</code></td>\n<td style=\"text-align: left;\">单个容器最大进程数</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:MaxResourceLimits:*</code></td>\n<td style=\"text-align: left;\"><code>null</code> (不限制)</td>\n<td style=\"text-align: left;\">硬上限，防止 AI 请求超额资源</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:SessionIdleTimeoutSeconds</code></td>\n<td style=\"text-align: left;\"><code>1800</code> (30分钟)</td>\n<td style=\"text-align: left;\">空闲会话自动回收时间</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:DefaultTimeoutSeconds</code></td>\n<td style=\"text-align: left;\"><code>300</code> (5分钟)</td>\n<td style=\"text-align: left;\">单次命令执行超时</td>\n</tr>\n</tbody>\n</table>\n<p>默认的 2 核 2GB 配置可以完成大多数日常任务（数据分析、图表生成、文档处理等）。如果你的场景需要更多资源（如视频处理、大规模计算），可以适当放宽；反之，如果是公开服务，建议收紧限制。</p>\n<h3 id=\"3-文件上传限制\">3. 文件上传限制</h3>\n<p>AI 执行代码后可以将生成的文件（artifacts）回传给用户。为防止滥用，Chats 也提供了相应限制：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">配置项</th>\n<th style=\"text-align: left;\">默认值</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:MaxArtifactsFilesToUpload</code></td>\n<td style=\"text-align: left;\"><code>50</code></td>\n<td style=\"text-align: left;\">每轮最多回传文件数</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:MaxSingleUploadBytes</code></td>\n<td style=\"text-align: left;\"><code>157286400</code> (150MB)</td>\n<td style=\"text-align: left;\">单个文件最大大小</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>CodeInterpreter:MaxTotalUploadBytesPerTurn</code></td>\n<td style=\"text-align: left;\"><code>314572800</code> (300MB)</td>\n<td style=\"text-align: left;\">单轮总上传大小</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"4-其他建议\">4. 其他建议</h3>\n<ul>\n<li><strong>定期清理镜像</strong>：使用 <code>docker image prune</code> 或 <code>docker system prune</code> 定期清理未使用的镜像和悬挂资源。</li>\n<li><strong>监控与告警</strong>：对 Docker 宿主机的 CPU、内存、磁盘使用率设置监控告警。</li>\n<li><strong>用户权限管理</strong>：仅对信任的用户开放代码执行功能，在模型配置中谨慎分配权限。</li>\n</ul>\n<p>更多配置细节请参考：<a href=\"https://github.com/sdcb/chats/blob/main/doc/zh-CN/configuration.md\" rel=\"noopener nofollow\" target=\"_blank\">配置说明文档</a></p>\n<hr />\n<h2 id=\"结语\">结语</h2>\n<p>希望这篇文档能帮你顺利部署 Chats 1.10，体验完全私有化、可控的代码解释器功能。</p>\n<p>感谢阅读！喜欢的朋友请给我的 GitHub 项目一个 star：<br />\n<a href=\"https://github.com/sdcb/chats\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/sdcb/chats</a></p>\n<p>这是完整的更新日志，包含更多技术细节：<br />\n<a href=\"https://github.com/sdcb/chats/blob/main/doc/zh-CN/release-notes/README.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/sdcb/chats/blob/main/doc/zh-CN/release-notes/README.md</a></p>\n<p>有什么想法也欢迎在评论区留言交流，也欢迎加入我的新创建的微信群：</p>\n<p><img alt=\"\" src=\"https://io.starworks.cc:88/cv-public/2026/chats-wxg-qr.png\" /></p>\n<p>如果你更习惯用 QQ 的话，也可以加入 Chats QQ 群：<strong>498452653</strong>，我们一起探索更多 AI 技术硬核玩法。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-27 08:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sdcb\">.NET骚操作</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI异常处理全解析：别让你的API在用户面前“裸奔”",
      "link": "https://www.cnblogs.com/ymtianyu/p/19536459",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19536459\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 08:38\">\n    <span>FastAPI异常处理全解析：别让你的API在用户面前“裸奔”</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文系统解析了FastAPI中异常处理的核心技巧，涵盖HTTPException基础用法、自定义业务异常设计、全局异常处理器配置以及WebSocket异常处理。通过生动的比喻和实战代码，帮助你构建健壮、友好的API错误响应机制，提升系统稳定性和用户体验。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">摘要：</strong>本文深入讲解FastAPI中<span style=\"color: rgba(186, 55, 42, 1);\"><code>HTTPException</code></span>、<span style=\"color: rgba(186, 55, 42, 1);\"><code>WebSocketException</code></span>等常见异常的捕获与处理技巧，涵盖从基础配置到全局异常处理器的完整实践。通过餐厅点餐、消防队等生动比喻，帮助你构建健壮、友好的API错误响应体系，避免服务崩溃和糟糕的用户体验。</p>\n<h1>深夜改Bug，你的API在用户面前“裸奔”了吗？</h1>\n<p>你有没有经历过这种噩梦场景？——用户反馈“页面白屏”或“操作失败”，你慌慌张张查日志，发现是个没处理的异常，返回了一堆Python调用栈给前端，用户看到一脸懵，你debug得想撞墙。</p>\n<p>先看案例：一个简单的请求参数验证失败，因为没正确处理，直接抛了500内部错误。监控报警半夜响起，用户投诉接踵而至，团队小伙伴连夜排查修复。痛定思痛，<strong style=\"color: rgba(186, 55, 42, 1);\">异常处理这玩意儿，看似边缘，实则是API的门面和铠甲</strong>。处理得好，用户体验丝滑；处理不好，就是技术债里的定时炸弹。</p>\n<p>今天，咱们就来彻底聊聊FastAPI里的异常处理。这不是抄文档，而是我踩了无数坑后，给你总结的实战心得。准备好了吗？咱们开始吧！</p>\n<h2>🎯 核心脉络：从“救火”到“防火”</h2>\n<div>\n<p>🔸 1. 为什么FastAPI的异常处理这么重要？——不只是技术，更是用户体验</p>\n<p>🔸 2. HTTPException：你的第一道防线，但别只靠它</p>\n<p>🔸 3. 自定义异常：让错误信息会“说话”</p>\n<p>🔸 4. 全局异常处理器：给API穿上“防弹衣”</p>\n<p>🔸 5. WebSocketException：实时通讯的异常该怎么管？</p>\n<p>🔸 6. 进阶技巧与避坑指南</p>\n</div>\n<h2>📌 第一部分：异常处理不是备选项，而是必选项</h2>\n<p>把API想象成一家餐厅。用户点餐（发送请求），厨房处理（服务端逻辑），最后上菜（返回响应）。异常处理是什么？就是当厨房发现“鱼卖完了”或者“客人对海鲜过敏”时，<strong style=\"color: rgba(186, 55, 42, 1);\">服务员如何得体地告知顾客，并给出替代方案</strong>，而不是直接把锅摔了，或者扔给顾客一张看不懂的后厨采购单（Python traceback）。</p>\n<p>我刚用FastAPI那会儿，也偷懒过，觉得有默认错误页面就行。结果呢？前端同事天天找我要错误码对照表，测试同学报的Bug描述模糊不清，线上出了问题定位慢如蜗牛。血的教训告诉我们：<strong style=\"color: rgba(186, 55, 42, 1);\">异常处理必须和业务逻辑同步设计，甚至要更早考虑</strong>。</p>\n<h2>🛡️ 第二部分：HTTPException，用好它但别依赖它</h2>\n<p>FastAPI提供了<code style=\"color: rgba(186, 55, 42, 1);\">HTTPException</code>，这是最直接、最常用的异常抛出方式。它就像一个标准化的“错误通知单”。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    if item_id not in item_db:\n        # 关键在这里：抛出带状态码和详情的异常\n        raise HTTPException(\n            status_code=404,\n            detail=\"Item not found\",\n            headers={\"X-Error\": \"ItemID-Missing\"}\n        )\n    return {\"item\": item_db[item_id]}</code></pre>\n<p>看这段代码，<code style=\"color: rgba(186, 55, 42, 1);\">status_code</code>告诉前端这是什么类型的错误（404找不到了），<code style=\"color: rgba(186, 55, 42, 1);\">detail</code>给人类看的原因，<code style=\"color: rgba(186, 55, 42, 1);\">headers</code>里还能塞点给机器看的额外信息。是不是很像服务员说：“抱歉先生，您点的这道菜（item_id）今天售罄了（404），这是我们推荐的相似菜品（headers里可以放推荐）”。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">但是！千万别以为只用HTTPException就万事大吉了。</strong>想象一下，你餐厅的后厨着火了（服务器内部错误），或者客人拿了一张假钞来付款（请求数据根本不符合格式），这时候只靠服务员说“菜没了”显然不够。我们需要更强大的机制。</p>\n<h2>🔧 第三部分：打造你的“异常消防队”——全局异常处理器</h2>\n<p>全局异常处理器（Exception Handler）就是你API大楼里的<strong style=\"color: rgba(186, 55, 42, 1);\">自动消防系统和万能服务员</strong>。任何没被特定处理的异常，最终都会落到这里，由它统一格式，友好返回。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport traceback\n\napp = FastAPI()\n\n# 1. 先定义一个标准的错误响应模型\nclass ErrorResponse(BaseModel):\n    code: int\n    message: str\n    detail: Optional[str] = None\n    request_id: Optional[str] = None # 用于链路追踪\n\n# 2. 捕获所有未处理异常的“总闸”\n@app.exception_handler(Exception)\nasync def universal_exception_handler(request: Request, exc: Exception):\n    # 获取请求ID，便于追踪（假设从中间件或header传入）\n    request_id = request.headers.get(\"X-Request-ID\", \"unknown\")\n    \n    # 这里可以根据exc的类型进行更精细的分类\n    error_code = 500 # 默认内部错误\n    message = \"Internal Server Error\"\n    \n    if isinstance(exc, ValueError):\n        error_code = 400\n        message = \"Invalid input value\"\n    # ... 可以添加更多类型判断\n    \n    # 在生产环境，detail可能不返回具体堆栈，开发环境可以返回\n    import os\n    detail = traceback.format_exc() if os.getenv(\"ENV\") == \"development\" else None\n    \n    return JSONResponse(\n        status_code=error_code,\n        content=ErrorResponse(\n            code=error_code,\n            message=message,\n            detail=detail,\n            request_id=request_id\n        ).dict()\n    )\n\n# 3. 专门处理HTTPException，覆盖FastAPI默认行为\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content=ErrorResponse(\n            code=exc.status_code,\n            message=exc.detail,\n            request_id=request.headers.get(\"X-Request-ID\", \"unknown\")\n        ).dict(),\n        headers=exc.headers\n    )</code></pre>\n<p>这个“消防队”厉害在哪？首先，它抓住了所有<code style=\"color: rgba(186, 55, 42, 1);\">Exception</code>，确保没有异常会“裸奔”出去。其次，它把错误响应格式标准化了，前端永远知道会收到<code style=\"color: rgba(186, 55, 42, 1);\">{\"code\": ..., \"message\": ...}</code>这样的结构。最后，它还区分了开发和生成环境，开发时给你详细堆栈debug，生产环境则隐藏细节保证安全。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">这里有个我踩过的大坑：</strong> 异常处理器的注册顺序很重要！如果你先注册了通用的<code style=\"color: rgba(186, 55, 42, 1);\">Exception</code>处理器，再注册<code style=\"color: rgba(186, 55, 42, 1);\">HTTPException</code>处理器，那么<code style=\"color: rgba(186, 55, 42, 1);\">HTTPException</code>也会被通用的抓住，你就无法对它进行特殊定制了。所以，通常要先注册具体的，再注册通用的。</p>\n<h2>🎨 第四部分：自定义异常——让业务错误清晰明了</h2>\n<p>业务逻辑里的错误，比如“用户余额不足”、“活动已结束”，用404或400虽然也行，但语义不精确。这时候，就需要自定义异常。</p>\n<pre class=\"language-python highlighter-hljs\"><code># 定义自己的业务异常类\nclass BusinessError(Exception):\n    def __init__(self, code: int, message: str, extra_data: dict = None):\n        self.code = code # 业务错误码，如 1001\n        self.message = message\n        self.extra_data = extra_data or {}\n\n# 定义几个具体的业务异常\nclass InsufficientBalanceError(BusinessError):\n    def __init__(self, current_balance: float, required_amount: float):\n        super().__init__(\n            code=1001,\n            message=\"Insufficient balance\",\n            extra_data={\n                \"current_balance\": current_balance,\n                \"required_amount\": required_amount\n            }\n        )\n\nclass ActivityExpiredError(BusinessError):\n    def __init__(self, activity_id: str, expire_time: str):\n        super().__init__(\n            code=1002,\n            message=\"Activity has expired\",\n            extra_data={\"activity_id\": activity_id, \"expire_time\": expire_time}\n        )\n\n# 为自定义业务异常注册处理器\n@app.exception_handler(BusinessError)\nasync def business_exception_handler(request: Request, exc: BusinessError):\n    return JSONResponse(\n        status_code=422, # 或用200，但body里表明错误，看前端约定\n        content={\n            \"success\": False,\n            \"error\": {\n                \"code\": exc.code,\n                \"message\": exc.message,\n                **exc.extra_data # 展开额外数据，前端可以直接用\n            }\n        }\n    )\n\n# 在路由中使用\n@app.post(\"/purchase\")\nasync def make_purchase(user_id: int, amount: float):\n    user_balance = get_balance(user_id)\n    if user_balance &lt; amount:\n        # 抛出业务异常，而不是简单的HTTP 400\n        raise InsufficientBalanceError(\n            current_balance=user_balance,\n            required_amount=amount\n        )\n    # ... 购买逻辑</code></pre>\n<p>这样做的好处巨大！前端看到错误码1001，就知道是余额不足，并且直接从<code style=\"color: rgba(186, 55, 42, 1);\">extra_data</code>里拿到当前余额和所需金额，可以立刻在界面上友好提示：“您的余额为XX元，还需充值YY元”。这体验，比干巴巴的“请求失败”好了一万倍。</p>\n<h2>⚡ 第五部分：WebSocketException——实时通道的优雅关闭</h2>\n<p>WebSocket是长连接，异常处理方式和HTTP不太一样。你不能返回一个JSON响应，而是需要<strong style=\"color: rgba(186, 55, 42, 1);\">优雅地关闭连接并发送原因</strong>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import WebSocket, WebSocketException\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_json()\n            # 一些业务验证\n            if data.get(\"type\") not in VALID_TYPES:\n                # 抛出WebSocketException，指定关闭码和原因\n                raise WebSocketException(\n                    code=1008, # 1008表示政策违规\n                    reason=\"Invalid message type received\"\n                )\n            # ... 处理消息\n    except WebSocketException as e:\n        # 这里其实raise之后，FastAPI会帮你关闭连接\n        raise\n    except Exception as e:\n        # 其他未知异常，也以WebSocketException形式关闭\n        raise WebSocketException(code=1011, reason=f\"Internal error: {str(e)}\")</code></pre>\n<p>WebSocket关闭码是有标准的，比如1000表示正常关闭，1008表示政策违规。用好这些代码，能让客户端明确知道连接为什么断开，从而做出相应处理（比如重连、提示用户等）。</p>\n<h2>🚨 第六部分：避坑指南与进阶思考</h2>\n<div>\n<p><strong>🔥 1. 不要过度捕获异常</strong></p>\n<p>别动不动就用<code style=\"color: rgba(186, 55, 42, 1);\">try...except Exception</code>把一大段业务逻辑包起来。这会隐藏真正的Bug。只捕获你预期中可能发生的、并且你知道如何处理的异常。</p>\n<p><strong>🔥 2. 日志！日志！日志！</strong></p>\n<p>异常处理器里一定要记日志，而且要记录完整的堆栈信息和请求上下文（用户ID、请求参数等）。用<code style=\"color: rgba(186, 55, 42, 1);\">logging.error(exc_info=True)</code>。这是你事后排查问题的唯一指望。</p>\n<p><strong>🔥 3. 区分返回状态码（status_code）和业务错误码（error_code）</strong></p>\n<p>HTTP状态码是给HTTP协议和网关看的（如404, 500）。业务错误码是你和前端约定的具体错误含义（如1001余额不足）。两者可以结合使用。</p>\n<p><strong>🔥 4. 考虑使用Starlette的异常处理基类</strong></p>\n<p>FastAPI基于Starlette，<code style=\"color: rgba(186, 55, 42, 1);\">from starlette.exceptions import HTTPException</code>和FastAPI的略有不同。如果你需要更底层的控制，可以研究一下。</p>\n<p><strong>🔥 5. 测试你的异常处理</strong></p>\n<p>写单元测试，模拟各种异常情况，确保你的处理器能正确响应，并且返回格式符合前端预期。这部分投入的回报率极高。</p>\n</div>\n<hr />\n<h2>💎 写在最后</h2>\n<p>异常处理，就像给代码买保险。平时感觉不到它的存在，但出事的时候，它能救你的项目、你的口碑，甚至你的睡眠。</p>\n<p>今天分享的这些，都是我从一次次报警电话和用户投诉中学来的。希望你看完能立刻动手，检查一下自己的FastAPI项目，是不是还在“裸奔”？给你的异常处理“消防队”配齐装备，让它成为你最可靠的后盾。</p>\n<p>如果你在实践过程中遇到其他坑，或者有更妙的心得，欢迎在评论区分享。这篇干货，值得你<strong style=\"color: rgba(186, 55, 42, 1);\">收藏</strong>下来，下次遇到异常处理的问题时，翻出来看看，一定能帮你省下不少折腾的时间。</p>\n<p>我是一名程序媛，我们下篇实战见！</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-27 08:38</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">一名程序媛呀</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "解密 Navicat 密码神器：NavicatPassword 的技术实现与架构解析",
      "link": "https://www.cnblogs.com/dingshuanglei/p/19536434",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/dingshuanglei/p/19536434\" id=\"cb_post_title_url\" title=\"发布于 2026-01-27 08:26\">\n    <span>解密 Navicat 密码神器：NavicatPassword 的技术实现与架构解析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n在日常的开发、运维工作中，Navicat作为一款主流的多数据库管理工具，几乎是每个数据库从业者的标配。但很多人都遇到过这样的痛点：Navicat会将数据库连接密码加密存储在本地配置文件中，一旦忘记密码，想要找回就成了一件麻烦事。基于此，我开发了<strong>NavicatPassword</strong>——一款基于Avalonia框架的跨平台Navicat密码解密工具，本文将从技术实现、架构设计、核心功能等维度，全面解析这个项目的开发思路与落地细节。\n<h2>一、项目背景与核心价值</h2>\n<h3>1. 解决的核心痛点</h3>\n<p>Navicat的数据库连接密码并非明文存储，而是通过AES算法加密后写入<code>.ncx</code>格式的XML配置文件中。一旦用户忘记密码，常规方式只能重新配置连接，效率极低。本项目只作为学习研究使用，不做其他使用。</p>\n<h3>2. 项目核心价值</h3>\n<ul>\n<li><strong>跨平台运行</strong>：基于Avalonia与.NET 8，支持Windows、macOS、Linux全平台；</li>\n<li><strong>多场景解密</strong>：支持配置文件批量解析、单条连接解密、手动输入密文解密三种模式；</li>\n<li><strong>易用性拉满</strong>：现代化UI界面，支持深色模式，操作流程极简；</li>\n<li><strong>轻量高效</strong>：无需复杂依赖，基于.NET原生能力实现核心算法，解密速度毫秒级。</li>\n</ul>\n<h2>二、技术栈选型与考量</h2>\n<p>NavicatPassword的技术栈选择围绕「跨平台、低耦合、高性能」三个核心目标，具体选型如下：</p>\n<table>\n<thead>\n<tr><th>技术领域</th><th>选型</th><th>选型考量</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>前端UI框架</td>\n<td>Avalonia UI</td>\n<td>替代WPF的跨平台UI框架，API与WPF高度兼容，原生支持多平台、深色模式、响应式布局</td>\n</tr>\n<tr>\n<td>后端开发语言</td>\n<td>C# (.NET 8)</td>\n<td>.NET 8跨平台能力强，性能优异，原生支持加密算法、XML解析等核心能力</td>\n</tr>\n<tr>\n<td>架构模式</td>\n<td>MVVM (CommunityToolkit.Mvvm)</td>\n<td>解耦UI与业务逻辑，简化数据绑定、命令管理，提升代码可维护性</td>\n</tr>\n<tr>\n<td>加密算法</td>\n<td>AES-128-CBC</td>\n<td>匹配Navicat官方的加密标准，保证解密准确性</td>\n</tr>\n<tr>\n<td>数据存储</td>\n<td>SQLite</td>\n<td>轻量级嵌入式数据库，用于保存用户的解密设置、历史记录等</td>\n</tr>\n<tr>\n<td>配置文件解析</td>\n<td>.NET XmlDocument/XDocument</td>\n<td>原生XML解析能力，高效处理Navicat的.ncx配置文件</td>\n</tr>\n</tbody>\n</table>\n<h2>三、项目架构设计（MVVM）</h2>\n<p>项目严格遵循MVVM架构模式，代码目录结构与职责划分清晰，核心目录如下（对应项目<code>NavicatPassword/</code>目录）：</p>\n<pre><code>NavicatPassword/\n├── Views/          # 视图层：UI界面（Axaml文件），仅负责展示，无业务逻辑\n│   ├── MainView.axaml       # 主界面（解密操作核心页面）\n├── ViewModels/     # 视图模型层：连接View与Model，处理UI交互逻辑\n│   ├── MainViewModel.cs     # 主界面逻辑（文件选择、批量解密、单条解密）\n├── Services/       # 服务层：核心业务逻辑封装\n│   ├── SystemService.cs # 密码解密核心服务\n├── Utils/          # 工具层：解密方法\n└── App.axaml.cs    # 应用入口，全局配置</code></pre>\n<h3>各层核心职责</h3>\n<ol>\n<li><strong>View（视图层）</strong>：仅通过Axaml定义UI结构，通过数据绑定绑定ViewModel的属性和命令，无任何业务代码；</li>\n<li><strong>ViewModel（视图模型层）</strong>：通过<code>ObservableProperty</code>（CommunityToolkit.Mvvm特性）实现属性通知，通过<code>ICommand</code>处理按钮点击、文件选择等UI交互，调用Service层完成核心逻辑；</li>\n<li><strong>Service（服务层）</strong>：封装核心业务逻辑（解密、文件解析），是项目的「业务核心」，ViewModel仅调用Service，不直接处理业务；</li>\n<li><strong>Model（模型层）</strong>：定义数据结构，如数据库连接信息、应用配置等，仅承载数据，无业务逻辑。</li>\n</ol>\n<p>这种架构的优势在于：<strong>UI与业务逻辑完全解耦</strong>，后续无论是修改界面样式，还是优化解密算法，都无需改动其他层的代码，可维护性和扩展性大幅提升。</p>\n<h2>四、核心功能实现解析</h2>\n<h3>1. 密码解密核心算法（AES-128-CBC）</h3>\n<p>Navicat的密码加密采用固定的Key和IV，这是解密的关键。项目的核心解密代码如下，且完全基于.NET原生<code>System.Security.Cryptography</code>实现：</p>\n<pre class=\"code-csharp\"><code>using System.Security.Cryptography;\nusing System.Text;\n\nnamespace NavicatPassword.Services;\n\npublic static class NavicatDecryptService\n{\n    // Navicat固定的Key和IV（核心！）\n    private static readonly byte[] _key = Encoding.UTF8.GetBytes(\"libcckeylibcckey\");\n    private static readonly byte[] _iv = Encoding.UTF8.GetBytes(\"libcciv libcciv \");\n\n    ///\n    /// 解密Navicat加密的密码字节数组\n    ///\n    ///加密后的字节数组\n    ///明文密码\n    ///解密失败时抛出异常\n    public static string DecryptNavicatPassword(byte[] cipherBytes)\n    {\n        if (cipherBytes == null || cipherBytes.Length == 0)\n        {\n            throw new ArgumentException(\"加密字节数组不能为空\", nameof(cipherBytes));\n        }\n\n        try\n        {\n            using Aes aes = Aes.Create();\n            // 匹配Navicat的加密模式：CBC + PKCS7填充\n            aes.Mode = CipherMode.CBC;\n            aes.Padding = PaddingMode.PKCS7;\n            aes.Key = _key;\n            aes.IV = _iv;\n\n            // 创建解密器并执行解密\n            ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);\n            byte[] plainBytes = decryptor.TransformFinalBlock(cipherBytes, 0, cipherBytes.Length);\n\n            // 转换为UTF8明文\n            return Encoding.UTF8.GetString(plainBytes);\n        }\n        catch (Exception ex)\n        {\n            throw new ArgumentException(\"解密失败，可能是密文格式错误\", ex);\n        }\n    }\n\n    ///\n    /// 重载：解密Base64编码的密文字符串\n    ///\n    ///Base64密文\n    /// 明文密码\n    public static string DecryptNavicatPassword(string cipherBase64)\n    {\n        byte[] cipherBytes = Convert.FromBase64String(cipherBase64);\n        return DecryptNavicatPassword(cipherBytes);\n    }\n}</code></pre>\n<h4>关键细节说明：</h4>\n<ul>\n<li><strong>固定Key/IV</strong>：Navicat所有版本均使用<code>libcckeylibcckey</code>（Key）和<code>libcciv libcciv </code>（IV），这是解密的核心前提；</li>\n<li><strong>填充模式</strong>：必须使用<code>PKCS7</code>（而非<code>PKCS5</code>），否则解密结果会出现乱码；</li>\n<li><strong>异常处理</strong>：针对空值、格式错误等场景做了容错，保证用户体验。</li>\n</ul>\n<h3>2. .ncx配置文件解析</h3>\n<p>Navicat的<code>.ncx</code>文件是XML格式，核心是<code>&lt;Connection&gt;</code>节点，包含连接名称、地址、加密密码等信息。解析逻辑封装在<code>NcxFileParserService</code>中，核心步骤如下：</p>\n<pre class=\"code-csharp\"><code>using System.Xml.Linq;\nusing NavicatPassword.Models;\n\nnamespace NavicatPassword.Services;\n\npublic class NcxFileParserService\n{\n    ///\n    /// 解析.ncx配置文件，提取所有数据库连接信息\n    ///\n    ///配置文件路径\n    /// 数据库连接列表\n    public List ParseNcxFile(string filePath)\n    {\n        if (!File.Exists(filePath))\n        {\n            throw new FileNotFoundException(\"配置文件不存在\", filePath);\n        }\n        XDocument doc = XDocument.Load(filePath);\n        var connections = new List();\n        // 遍历所有Connection节点\n        foreach (var connNode in doc.Descendants(\"Connection\"))\n        {\n            var connection = new NavicatConnection\n            {\n                Name = connNode.Attribute(\"Name\")?.Value ?? string.Empty,\n                Host = connNode.Element(\"Host\")?.Value ?? string.Empty,\n                Port = connNode.Element(\"Port\")?.Value ?? string.Empty,\n                Database = connNode.Element(\"Database\")?.Value ?? string.Empty,\n                // 加密密码是Base64编码的字符串\n                CipherPassword = connNode.Element(\"Password\")?.Value ?? string.Empty\n            };\n            // 自动解密（可选）\n            if (!string.IsNullOrEmpty(connection.CipherPassword))\n            {\n                try\n                {\n                    connection.PlainPassword = NavicatDecryptService.DecryptNavicatPassword(connection.CipherPassword);\n                }\n                catch\n                {\n                    connection.PlainPassword = \"解密失败\";\n                }\n            }\n            connections.Add(connection);\n        }\n        return connections;\n    }\n}</code></pre>\n<p>解析逻辑的核心是提取<code>&lt;Connection&gt;</code>节点的属性和子节点值，并自动调用解密方法生成明文密码，最终封装为<code>NavicatConnection</code>模型返回给ViewModel，由View展示。</p>\n<h2>五、跨平台适配要点</h2>\n<p>基于Avalonia和.NET 8，项目的跨平台适配几乎「零成本」，但仍有几个关键细节需要注意：</p>\n<ol>\n<li><strong>文件路径适配</strong>：需要自己手动导出文件，打开Navicat-&gt;文件-&gt;导出连接-&gt;导出密码(一定要勾选弹框底部导出密码，否则解析不到密码，修正路径.ncx)</li>\n<li><strong>UI适配</strong>：Avalonia的布局系统原生支持响应式，通过<code>Grid</code>、<code>StackPanel</code>等布局控件，保证在不同分辨率、不同系统下的UI一致性；深色模式通过Avalonia的<code>ThemeVariant</code>实现，无需单独开发。</li>\n<li><strong>发布打包</strong>：通过<code>.NET Publish</code>命令可一键打包不同平台的可执行文件：\n<pre class=\"code-bash\"><code># Windows (x64)\ndotnet publish -c Release -r win-x64 --self-contained true -o publish/win\n\n# macOS (x64)\ndotnet publish -c Release -r osx-x64 --self-contained true -o publish/macos\n\n# Linux (x64)\ndotnet publish -c Release -r linux-x64 --self-contained true -o publish/linux</code></pre>\n</li>\n</ol>\n<h2>六、使用场景与落地效果</h2>\n<h3>1. 核心使用场景</h3>\n<ul>\n<li><strong>开发人员找回密码</strong>：忘记Navicat连接密码，快速解析配置文件找回；</li>\n<li><strong>运维批量管理</strong>：批量解析服务器上的Navicat配置文件，统一管理数据库连接密码；</li>\n<li><strong>测试环境核查</strong>：验证测试环境数据库密码是否符合规范，提升安全合规性；</li>\n<li><strong>已通过测试版本</strong>：<a href=\"https://www.navicat.com/products#navicat-premium-lite\" rel=\"noopener nofollow\">Navicat Premium Lite (Free)</a>&nbsp;<em id=\"__mceDel\">17.3.6版本。</em></li>\n</ul>\n<h2>&nbsp;</h2>\n<h2>附：项目快速上手</h2>\n<h3>从源码构建</h3>\n<pre class=\"code-bash\"><code># 克隆仓库\ngit clone https://gitee.com/dingshuanglei/NavicatPassword.git<br />or<br />git clone https://github.com/dingshuanglei/NavicatPassword.git<br />\n\n# 进入目录\ncd NavicatPassword\n\n# 构建项目\ndotnet build -c Release\n\n# 运行\ndotnet run --project NavicatPassword/NavicatPassword.csproj</code></pre>\n<h3>核心操作流程</h3>\n<ol>\n<li>选择Navicat的<code>.ncx</code>配置文件，自动解析所有连接；</li>\n<li>批量解密/单条解密，查看明文密码；</li>\n<li>或手动输入密文，一键解密。</li>\n</ol><hr />\n<p>技术的价值在于解决实际问题，NavicatPassword的开发过程，既是对Avalonia跨平台开发的实践，也是对「工具类项目」架构设计的探索。希望本文能为大家带来一些启发，也欢迎大家参与项目的开源共建～</p>\n\n</div>\n<div id=\"MySignature\">\n    <div>作者：<a href=\"https://www.cnblogs.com/dingshuanglei/\" target=\"_blank\">丁双磊</a></div>\n<div>出处：<a href=\"https://www.cnblogs.com/dingshuanglei/\" target=\"_blank\">https://www.cnblogs.com/dingshuanglei</a></div>\n<div>本文版权归作者和博客园共有，欢迎转载，但必须给出原文链接，并保留此段声明，否则保留追究法律责任的权利。 </div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-27 08:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/dingshuanglei\">丁双磊</a>&nbsp;\n阅读(<span id=\"post_view_count\">89</span>)&nbsp;\n评论(<span id=\"post_comment_count\">4</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "wso2~通过三方IDP的token置换wso2的token",
      "link": "https://www.cnblogs.com/lori/p/19532862",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lori/p/19532862\" id=\"cb_post_title_url\" title=\"发布于 2026-01-26 16:25\">\n    <span>wso2~通过三方IDP的token置换wso2的token</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>参数：<a href=\"https://datatracker.ietf.org/doc/html/rfc7523\" rel=\"noopener nofollow\" target=\"_blank\">https://datatracker.ietf.org/doc/html/rfc7523</a></p>\n<h1 id=\"oauth20中的三方另类授权\">oauth2.0中的三方另类授权</h1>\n<p>了解OAuth 2.0中特定的授权类型（Grant Type）对于构建安全的认证流程至关重要。下面为你详细介绍这三种基于URN声明的扩展授权类型。</p>\n<h3 id=\"-设备代码授权-urnietfparamsoauthgrant-typedevice_code\">🔐 设备代码授权 (<code>urn:ietf:params:oauth:grant-type:device_code</code>)</h3>\n<p>这种授权模式专为输入能力受限或没有浏览器的设备设计，比如智能电视、游戏机、IoT设备或命令行工具（CLI）。</p>\n<ul>\n<li>\n<p><strong>工作原理</strong>：其核心是一个两步过程。</p>\n<ol>\n<li><strong>设备获取代码</strong>：设备上的应用首先向授权服务器（如 Microsoft Entra ID）的 <code>/devicecode</code> 端点发起请求。服务器会返回一组信息，包括一个简短的 <code>user_code</code>（用户代码）和一个 <code>verification_uri</code>（验证网址）。</li>\n<li><strong>用户授权</strong>：设备将 <code>user_code</code> 和 <code>verification_uri</code> 显示给用户，并提示用户在其他设备（如个人手机或电脑）上打开浏览器，访问该网址并输入代码。用户在授权服务器的正规页面上完成身份验证（可能包括多因素认证）并同意授权。在此期间，设备应用会定期轮询授权服务器的令牌端点，直到用户完成操作后获取访问令牌和刷新令牌。</li>\n</ol>\n</li>\n<li>\n<p><strong>安全风险与防御</strong>：需要注意的是，此流程可能被用于进行高迷惑性的网络钓鱼攻击（称为“设备代码钓鱼”）。攻击者会诱导用户在真实的微软登录页面输入由攻击者生成的设备代码，从而授权一个恶意应用。防御措施包括在服务器端严格限制应用同意策略、实施条件访问策略（如要求来自合规设备），以及对用户进行安全教育。</p>\n</li>\n</ul>\n<h3 id=\"-令牌交换授权-urnietfparamsoauthgrant-typetoken-exchange\">🔄 令牌交换授权 (<code>urn:ietf:params:oauth:grant-type:token-exchange</code>)</h3>\n<p>令牌交换授权提供了强大的 interoperability（互操作性），允许将一个凭证或令牌交换为另一个不同的令牌，常用于服务之间的安全调用或身份映射。</p>\n<ul>\n<li>\n<p><strong>核心概念</strong>：它遵循 OAuth Token Exchange 规范，使得客户端能够使用一个现有的 <code>subject_token</code>（主体令牌）来换取一个新的、针对不同受众或资源的 <code>access_token</code>（访问令牌）。</p>\n</li>\n<li>\n<p><strong>常见场景</strong>：</p>\n<ul>\n<li><strong>服务间调用</strong>：后端服务A可以使用自己持有的令牌，换取一个具有适当权限的、用于调用服务B的访问令牌。</li>\n<li><strong>权限降级</strong>：一个高权限的应用在需要调用一个低信任度的服务时，可以换一个权限受限的令牌，以提升安全性。</li>\n<li><strong>外部身份提供商集成</strong>：将外部IDP（如Google、Facebook）签发的令牌交换为内部系统的令牌，从而实现跨域身份联合。</li>\n<li><strong>用户模拟</strong>：在严格管控下，服务可以换取一个代表特定用户身份的令牌（即模拟用户）。</li>\n</ul>\n</li>\n<li>\n<p><strong>实施要点</strong>：令牌交换功能通常默认不开启，需要在服务器端（如Red Hat Single Sign-On）为客户端显式配置精细的权限策略。</p>\n</li>\n</ul>\n<h3 id=\"️-jwt持有者授权-urnietfparamsoauthgrant-typejwt-bearer\">⚙️ JWT持有者授权 (<code>urn:ietf:params:oauth:grant-type:jwt-bearer</code>)</h3>\n<p>这种授权类型允许客户端直接使用一个预先签名的JWT（JSON Web Token）作为断言（assertion）来获取访问令牌。</p>\n<ul>\n<li>\n<p><strong>基本流程</strong>：客户端向授权服务器的令牌端点发起POST请求，在请求体中，<code>grant_type</code> 参数设置为 <code>urn:ietf:params:oauth:grant-type:jwt-bearer</code>，并同时提供用作断言的 <code>assertion</code> 参数（即JWT本身）。授权服务器会验证该JWT的签名、有效期、颁发者等信息，验证通过后即颁发所请求的访问令牌。</p>\n</li>\n<li>\n<p><strong>典型应用场景</strong>：</p>\n<ul>\n<li><strong>服务账户认证</strong>：在机器对机器（M2M）的通信中，一个服务可以使用事先配置好的JWT（通常基于私钥签名）来获取访问令牌，无需用户交互。这在CI/CD流水线或后台服务中非常常见。</li>\n<li><strong>微服务架构</strong>：在微服务网络中，一个服务在收到访问令牌后，可以利用此流程向认证服务器换取一个范围（scope）更窄、专用于访问另一个特定微服务的令牌。</li>\n</ul>\n</li>\n</ul>\n<p>下面的表格清晰地对比了这三种授权类型的关键差异。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">特性</th>\n<th style=\"text-align: left;\">设备代码授权 (<code>device_code</code>)</th>\n<th style=\"text-align: left;\">令牌交换授权 (<code>token-exchange</code>)</th>\n<th style=\"text-align: left;\">JWT持有者授权 (<code>jwt-bearer</code>)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>主要目的</strong></td>\n<td style=\"text-align: left;\">方便输入受限设备上的用户授权</td>\n<td style=\"text-align: left;\">实现令牌之间的安全转换和身份委托</td>\n<td style=\"text-align: left;\">客户端使用已有的JWT直接获取访问令牌</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>令牌流</strong></td>\n<td style=\"text-align: left;\">轮询机制</td>\n<td style=\"text-align: left;\">直接交换</td>\n<td style=\"text-align: left;\">断言式请求</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>典型应用</strong></td>\n<td style=\"text-align: left;\">智能电视、IoT设备、CLI工具</td>\n<td style=\"text-align: left;\">服务间调用、权限降级、身份联合</td>\n<td style=\"text-align: left;\">机器对机器通信、服务账户、微服务</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"处理流程\">处理流程</h3>\n<div class=\"mermaid\">sequenceDiagram\n    participant Client\n    participant WSO2APIM (Authorization Server)\n    participant Keycloak (External IdP)\n\n    Note over Client, Keycloak: 准备阶段\n    Client -&gt;&gt; Keycloak: 1. 通过Keycloak认证获取JWT\n    Keycloak --&gt;&gt; Client: 返回JWT（断言）\n\n    Note over Client, WSO2APIM: JWT Bearer Grant 流程\n    Client -&gt;&gt; WSO2APIM: 2. 令牌请求 (grant_type=jwt-bearer, assertion=JWT)\n    WSO2APIM -&gt;&gt; WSO2APIM: 3. 验证JWT签名、有效期、颁发者\n    WSO2APIM -&gt;&gt; WSO2APIM: 4. 提取身份/声明（如sub, aud）\n    WSO2APIM -&gt;&gt; WSO2APIM: 5. 根据JWT中的信息创建会话并颁发自身的访问令牌\n    WSO2APIM --&gt;&gt; Client: 6. 返回WSO2 APIM的访问令牌\n</div><h3 id=\"-总结与安全考量\">💎 总结与安全考量</h3>\n<p>选择哪种授权类型完全取决于你的具体应用场景。设备代码授权优化了受限设备的用户体验，令牌交换授权为复杂的服务间信任链提供了灵活性，而JWT持有者授权则是机器对机器通信的简洁高效方案。</p>\n<p>在实施这些授权流程时，务必关注以下安全最佳实践：</p>\n<ul>\n<li><strong>严格控制权限</strong>：遵循最小权限原则，只为应用授予其必需的最少权限。</li>\n<li><strong>验证与监控</strong>：服务器端必须严格验证所有令牌和断言（如JWT的签名和有效期），并建立日志审计和异常行为监控机制。</li>\n<li><strong>保护令牌</strong>：访问令牌和刷新令牌是敏感凭证，在传输和存储过程中必须加以保护。</li>\n</ul>\n<h1 id=\"wso2中的实战\">wso2中的实战</h1>\n<h2 id=\"wso2-sp的配置\">wso2 sp的配置</h2>\n<p>配置认证grant_type类型</p>\n<p><img alt=\"图片\" src=\"https://img2024.cnblogs.com/blog/118538/202601/118538-20260126132653488-1051084105.png\" /></p>\n<h2 id=\"keycloak-idp的配置\">keycloak idp的配置</h2>\n<blockquote>\n<p>keycloak中为客户端开启roles之后，如果有用户有客户端的角色，会在jwt中多出来aud数组字段，也可以为wso2客户端添加自定义的client scope，然后为它添加aud的cliams</p>\n</blockquote>\n<p>IDP名称必须与IDP中token的Issuer相同</p>\n<p><img alt=\"图片\" src=\"https://img2024.cnblogs.com/blog/118538/202601/118538-20260126162025923-968169912.png\" /></p>\n<h2 id=\"测试\">测试</h2>\n<pre><code>curl -X POST 'https://test-apim.xxx.com/oauth2/token' -H 'Content-Type: application/json' -H 'Content-Type: application/json' -u 'wso2-sp-client-id:wso2-sp-client-secret' --basic -d '{\n    \"grant_type\": \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n    \"assertion\": \"abc.abc.abc\",\n    \"scope\": \"openid apim:subscribe\"\n}'\n</code></pre>\n<p>如果keycloak_token过期，就返回这个400错误</p>\n<pre><code>{\n  \"error_description\": \"JSON Web Token is expired., Expiration Time(ms) : 1769413736000, TimeStamp Skew : 0, Current Time : 1769413748585. JWT Rejected and validation terminated\",\n  \"error\": \"invalid_grant\"\n}\n</code></pre>\n<p>如果成功，会返wso2平台的token</p>\n<pre><code>{\n  \"access_token\": \"8b23bf56-f8d2-33fa-9962-f298a797ce94\",\n  \"refresh_token\": \"aad2555-30b0-3591-8c70-b2cdc042cc41\",\n  \"scope\": \"apim:subscribe openid\",\n  \"id_token\": \"\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 3185\n}\n</code></pre>\n<p>用户登录成功后，会初始化用户表，需要注意的是，这种<code>urn:ietf:params:oauth:grant-type:jwt-bearer</code>首次登录添加的用户，它位于<code>wso2am_db.idn_auth_user</code>表，user_name同样是三方社区token中的<code>sub</code>字段；而标准oauth的授权码认证后，除了在<code>wso2am_db.idn_auth_user</code>表初始化外，还在<code>wso2am_share_db.um_user</code>表也会添加一份用户数据。</p>\n\n</div>\n<div id=\"MySignature\">\n    <p></p>\n<div class=\"navgood\">\n<p>作者：仓储大叔，张占岭，<br />\n荣誉：微软MVP<br />QQ：853066980</p>\n\n<p><strong>支付宝扫一扫，为大叔打赏!</strong>\n<br /><img src=\"https://images.cnblogs.com/cnblogs_com/lori/237884/o_IMG_7144.JPG\" /></p>\n</div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-26 16:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lori\">张占岭</a>&nbsp;\n阅读(<span id=\"post_view_count\">65</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "langchain 快速入门(五)：Langgraph应用，执行流程由线转图",
      "link": "https://www.cnblogs.com/ClownLMe/p/19533991",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19533991\" id=\"cb_post_title_url\" title=\"发布于 2026-01-26 15:58\">\n    <span>langchain 快速入门(五)：Langgraph应用，执行流程由线转图</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简介\">简介</h1>\n<p><strong>Langgraph</strong>是langchain框架提供的一个组件，langgraph能够解决AI执行流程中迭代、循环或者根据结果返回上一步，与之前讲的chain链相比，能够实现更加复杂的AI执行流。</p>\n<h1 id=\"langgraph\">langgraph</h1>\n<p>从chain转到langgraph从数学的角度上来讲，执行流从线性流程转到了流程图。</p>\n<p>langgraph的组成主要有三部分：<br />\nLanggraph=节点+边+状态<br />\n<strong>节点：</strong> 一个节点就是一个执行单元，相当于一次<strong>函数</strong>的调用。（可以是一次模型的调用，一次搜索，一次加密等等）<br />\n<strong>边：</strong> 边能够<strong>连接</strong>一个个节点，它决定了下一个应该去到哪个节点执行<br />\n<strong>状态：</strong> 实现数据共享，是实现AI<strong>短期记忆</strong>的灵魂</p>\n<blockquote>\n<p>乍一看好像有些云里雾里的，我打个比方：玩家（<strong>状态</strong>），在玩一个大富翁，每个<strong>节点</strong>和<strong>边</strong>组成地图，玩家初始资金（<strong>数据</strong>）有1000块钱，玩家每走一格可能会发生一些事件，比如说后退一步，被小偷偷300块钱，买房子等等，这些事件相当于<strong>节点</strong>，走的方向相当于<strong>边</strong>，最后玩家成功走到了<strong>终点END</strong>，你可以得知玩家（<strong>状态</strong>）最后还有多少钱，有多少资产。</p>\n</blockquote>\n<p>下面用一个示例来演示。</p>\n<h1 id=\"改造rag知识库\">改造RAG知识库</h1>\n<h3 id=\"示例\">示例</h3>\n<p>这个是之前文章中构建知识库的相关代码，本次用langgraph改造流程</p>\n<pre><code class=\"language-python\">import os\nimport operator\nfrom typing import TypedDict, Annotated\nfrom langchain_community.chat_models.tongyi import ChatTongyi\nfrom langchain_community.embeddings import DashScopeEmbeddings\nfrom langchain_community.vectorstores import FAISS\nfrom langchain_core.messages import ToolMessage\nfrom langchain_core.tools import tool\nfrom langchain_core.messages import HumanMessage, ToolMessage, BaseMessage\nfrom langchain_core.documents import Document\nfrom langchain_text_splitters import RecursiveCharacterTextSplitter\nfrom langgraph.graph import StateGraph, END\nfrom langgraph.prebuilt.tool_node import ToolNode\n\nos.environ[\"DASHSCOPE_API_KEY\"] = \"apikey\"\n\n@tool\ndef calculator(expression: str) -&gt; str:\n    \"\"\"\n    计算数学表达式。需要精确计算时使用。\n    参数:\n        expression: 数学算式，如 \"2 + 2\" 或 \"500 * 0.8\"。\n    返回:\n        str: 计算结果，如 \"4.0\" 或 \"400.0\"。\n    \"\"\"\n    print(f\"[🛠️ 工具调用] 计算器正在计算: {expression}\")\n    try:\n        return str(eval(expression))\n    except Exception as e:\n        return f\"计算错误: {e}\"\n\n@tool\ndef rag_search(query: str) -&gt; str:\n    \"\"\"\n    从数据库中搜索与查询公司内部相关的文档，包括公司计划名，代号，截止日期等详细信息。\n    参数:\n        query (str): 要搜索的查询字符串。\n    返回:\n        str: 与查询相关的文档内容。\n    \"\"\"\n\n    # 从RAG数据库中检索文档\n    raw_text = \"\"\"\n    【公司内部机密：代号“深蓝计划”】\n    1. 项目目标：开发一款能听懂猫语的翻译器。\n    2. 核心技术：基于Transformer的“喵声波”分析算法。\n    3. 团队暗号：如果有人问“今天天气怎么样？”，必须回答“我想吃鱼”。\n    4. 截止日期：2026年12月31日。\n    5. 经费预算：仅剩50元人民币，主要用于购买猫条。\n    \"\"\"\n    RAG_PATH = \"faiss_index\"\n\n    docs = [Document(page_content=raw_text)]\n    text_splitter = RecursiveCharacterTextSplitter(chunk_size=25, chunk_overlap=5)\n    split_docs = text_splitter.split_documents(docs)\n\n    embeddings = DashScopeEmbeddings(model=\"text-embedding-v1\")\n\n    if os.path.exists(RAG_PATH):\n        print(\"公司内部数据库已存在\")\n        ragdb = FAISS.load_local(RAG_PATH, embeddings, allow_dangerous_deserialization=True)\n    else:\n        print(\"创建公司内部数据库\")\n        ragdb = FAISS.from_documents(split_docs, embeddings)\n        ragdb.save_local(RAG_PATH)\n    \n    return \"\\n\\n\".join(doc.page_content for doc in ragdb.similarity_search(query, k=2))\n\n#构造agent流程图\n\ndef Init_Agent():\n    #初始化模型\n    tool_maps={\n        \"rag_search\": rag_search,\n        \"calculator\": calculator\n    }\n    llm = ChatTongyi(model_name=\"qwen-plus\")\n    tool_llm = llm.bind_tools(tools=list(tool_maps.values()))\n\n    #创建state\n    class TaskState(TypedDict):\n        messages: Annotated[list[BaseMessage], operator.add]\n    \n    #创建node\n    def agent_node(state: TaskState):\n        \"\"\"\n        节点：思考 (Think)\n        接收当前状态，调用 LLM，返回新消息\n        \"\"\"\n        messages = state[\"messages\"]\n        response = tool_llm.invoke(messages)\n        return {\"messages\": [response]}\n\n    #定义边\n    def condition_tools(state: TaskState):\n        \"\"\"\n        节点：工具 (Tool)\n        接收当前状态，调用工具，返回新消息\n        \"\"\"\n        messages = state[\"messages\"][-1]\n        if messages.tool_calls:\n            return \"tool_node\"\n        else:\n            return END\n    \n    #添加边\n    workflow = StateGraph(TaskState)\n    workflow.add_node(\"agent_node\", agent_node)\n    workflow.add_node(\"tool_node\", ToolNode(tool_maps.values()))\n    workflow.add_conditional_edges(\"agent_node\", condition_tools, {\n        \"tool_node\": \"tool_node\",\n        END: END\n    })\n    workflow.add_edge(\"tool_node\", \"agent_node\")\n    workflow.set_entry_point(\"agent_node\")\n    \n    return workflow.compile()\n\nif __name__ == \"__main__\":\n    app = Init_Agent()\n    input = \"公司的经费预算是多少，如果预算预算提高46%后多少\"\n    for event in app.stream({\"messages\": [HumanMessage(content=input)]}):\n        for key, value in event.items():\n            print(f\"\\n[{key}]\")\n            print(value[\"messages\"][-1].content)\n\n\n</code></pre>\n<h1 id=\"代码解释\">代码解释</h1>\n<p>本次代码中重点讲langgraph的构建，对于其他的细节，请看前面文章。<br />\n代码流程如下：<br />\n<strong>初始化工具集-&gt;定义状态，定义条件边，节点-&gt;构建节点-&gt;连接边-&gt;构建图-&gt;运行图</strong></p>\n<h3 id=\"初始化工具集\">初始化工具集</h3>\n<p>这个前面文章有，就不废话了。</p>\n<h3 id=\"定义状态定义条件边节点\">定义状态，定义条件边，节点</h3>\n<h5 id=\"状态\">状态</h5>\n<pre><code class=\"language-python\">#创建state\n    class TaskState(TypedDict):\n        messages: Annotated[list[BaseMessage], operator.add]\n</code></pre>\n<ul>\n<li>状态是<code>TypedDict</code>的子类（<strong>字典</strong>）。</li>\n<li>上面的<code>BaseMessage</code>是<code>ToolMessage</code>,<code>AIMessage</code>,<code>HumanMessage</code>等的父类，这个<code>list</code>主要用于存放每个节点的历史消息（短期记忆）</li>\n<li><code>Annotated[..., operator.add]</code>表示追加，将节点返回的消息追加到后面，而不是覆盖。<br />\n格式如下（可以创建多个自定义字段）：</li>\n</ul>\n<pre><code class=\"language-python\">class  StateName(TypedDict):\n\tfieldName: fieldType\n</code></pre>\n<h5 id=\"条件边\">条件边</h5>\n<pre><code class=\"language-python\">def condition_tools(state: TaskState):\n        \"\"\"\n        节点：工具 (Tool)\n        接收当前状态，调用工具，返回新消息\n        \"\"\"\n        messages = state[\"messages\"][-1]\n        if messages.tool_calls:\n            return \"tool_node\"\n        else:\n            return END\n</code></pre>\n<ul>\n<li>返回值<code>END</code>和<code>\"tool_node\"</code>表示定义的节点名称，<code>END</code>默认是结束节点<br />\n格式如下：</li>\n</ul>\n<pre><code class=\"language-python\">def EdgeName(state: StateClass)\n\treturn \"NextNode\"\n</code></pre>\n<h5 id=\"节点\">节点</h5>\n<pre><code class=\"language-python\">@tool\ndef calculator(expression: str) -&gt; str:\n    ......\n\n@tool\ndef rag_search(query: str) -&gt; str:\n    ......\n    \ndef agent_node(state: TaskState):\n    ......\n</code></pre>\n<p>节点可以是工具函数，也可以是普通函数（<strong>普通函数需要用state传入</strong>）</p>\n<h3 id=\"构建节点\">构建节点</h3>\n<pre><code class=\"language-python\">workflow = StateGraph(TaskState)\nworkflow.add_node(\"agent_node\", agent_node)\nworkflow.add_node(\"tool_node\", ToolNode(tool_maps.values()))\n</code></pre>\n<ul>\n<li><code>StateGraph(TaskState)</code>初始化图，将刚刚创建的状态传入</li>\n<li><code>add_node</code>方法是创建节点\"tool_node\"节点名称（自定义用于标识节点），<code>agent_node</code>创建的节点函数</li>\n<li><code>ToolNode</code>是langchain提供的创建工具节点的函数，帮我们完成了调用工具集，更新状态的全过程（不用这个需要我们自己手动创建工具循环节点，比较麻烦，参考之前文章）</li>\n</ul>\n<h3 id=\"连接边\">连接边</h3>\n<pre><code class=\"language-python\">workflow.add_conditional_edges(\"agent_node\", condition_tools, {\n        \"tool_node\": \"tool_node\",\n        END: END\n    })\n    workflow.add_edge(\"tool_node\", \"agent_node\")\n</code></pre>\n<ul>\n<li><code>add_conditional_edges</code>创建条件边方法（分支），根据返回内容决定节点走向</li>\n<li><code>add_edge</code>固定走向，如上<code>tool_node-&gt;agent_node</code></li>\n</ul>\n<h3 id=\"构建图\">构建图</h3>\n<pre><code class=\"language-python\">workflow.set_entry_point(\"agent_node\")\nworkflow.compile()\n</code></pre>\n<ul>\n<li><code>set_entry_point</code>确定图的入口</li>\n<li><code>compile</code>构建图</li>\n</ul>\n<h3 id=\"运行图\">运行图</h3>\n<pre><code class=\"language-python\">if __name__ == \"__main__\":\n    app = Init_Agent()\n    input = \"公司的经费预算是多少，如果预算预算提高46%后多少\"\n    for event in app.stream({\"messages\": [HumanMessage(content=input)]}):\n        for key, value in event.items():\n            print(f\"\\n[{key}]\")\n            print(value[\"messages\"][-1].content)\n</code></pre>\n<p>运行跟之前运行普通模型一样</p>\n<ul>\n<li><code>stream</code>方法会返回每个节点中的<strong>状态</strong>（上面定义的类）</li>\n<li><code>invoke</code>方法直接返回最终<strong>状态</strong></li>\n</ul>\n<p><strong>langgraph是实现多Agent协作的核心，下一篇文章会讲如何多agent协作</strong></p>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-26 15:58</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">93</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第二周：词嵌入（六）情绪分类和词嵌入除偏",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19533686",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19533686\" id=\"cb_post_title_url\" title=\"发布于 2026-01-26 15:36\">\n    <span>吴恩达深度学习课程五：自然语言处理  第二周：词嵌入（六）情绪分类和词嵌入除偏</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第二周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=164\" rel=\"noopener nofollow\" target=\"_blank\">2.2</a>、<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=171\" rel=\"noopener nofollow\" target=\"_blank\">2.9</a>和<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=172\" rel=\"noopener nofollow\" target=\"_blank\">2.10</a>内容，同时也是本周理论部分的最后一篇。</p>\n<hr />\n<p>本周为第五课的第二周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本周的内容关于词嵌入，是一种<strong>相对于独热编码，更能保留语义信息的文本编码方式</strong>。通过词嵌入，模型不再只是“记住”词本身，而是能够<strong>基于语义关系进行泛化</strong>，在一定程度上实现类似“<strong>举一反三</strong>”的效果。词嵌入是 NLP 领域中最重要的基础技术之一。</p>\n<p>本篇的内容关于<strong>情绪分类和词嵌入除偏</strong>，是对本周内容的最后补充。</p>\n<h2 id=\"1-词向量的使用\">1. 词向量的使用</h2>\n<p>在介绍完前面的内容后，你会发现，我们使用各种模型和技术，最终的目的都是为了得到可以合理刻画文本信息间语义关系的<strong>词向量</strong>。<br />\n而一旦这些词向量被训练出来，它们的价值并不会随着训练任务的结束而消失，反而<strong>真正的用武之地才刚刚开始</strong>。</p>\n<p>实际上，在词向量的使用中，<strong>最常见、也是最直接的方式，就是将训练好的词向量作为下游任务的输入表示。</strong><br />\n在文本分类、情绪分析、问答系统等任务中，我们不再使用独热编码这种“只区分身份、不包含语义”的表示方式，而是通过查表的方式，将每个词映射为一个稠密的词向量，再送入分类器或序列模型中进行处理。<br />\n也正是这种连续、可度量的语义空间，使得<strong>模型在还没有接触具体任务之前，就已经拥有了一定程度的语言理解能力。</strong><br />\n而且，你会发现这其实是一种非常典型的<strong>迁移学习</strong>思想：<br />\n词向量模型在大规模语料上学习到的是一种<strong>通用的语言结构与语义分布</strong>，而下游任务只需要在此基础上进行少量参数调整，就可以完成更具体的目标。</p>\n<p>更重要的是， NLP 中对词向量的迁移学习和我们之前介绍的 CV 内容有所不同，在 CV 任务中，迁移效果往往高度依赖于任务之间的相似性，例如用自然图片上训练得到的模型参数去处理医学影像，效果未必理想。<br />\n而在 NLP 领域中，由于语言本身具有极强的通用性，只要任务使用的是同一语言，<strong>将预训练词向量作为嵌入层矩阵的初始化方式，往往是一种“用了就不亏”的选择</strong>。<br />\n最终，从模型结构上看，这相当于模型的第一层不再从完全随机的参数开始学习，而是直接站在了一个已经组织好语义结构的空间中，再去完成具体任务。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260126152709307-555486151.png\" /></p>\n<p>也正是在这样的背景下，NLP 的各种应用百花齐放，其中最经典的应用之一，就是下面要介绍的情绪分类。</p>\n<h1 id=\"2-情绪分类sentiment-classification\">2. 情绪分类（Sentiment Classification）</h1>\n<h2 id=\"21-情绪分类原理\">2.1 情绪分类原理</h2>\n<p>情绪分类是自然语言处理领域中最早被系统研究、同时也最具代表性的任务之一。<br />\n其基本形式并不复杂：<strong>给定一段文本，判断其情绪倾向，例如正面、负面，或更细粒度的多类别情绪。</strong><br />\n简单举个例子：<br />\n对于两条酒店评论 <strong>“拉完了”</strong> 和 <strong>“夯爆了”</strong>，我们可以在不同的情绪粒度下，对它们给出不同形式的分类结果。</p>\n<ol>\n<li><strong>正负二分类</strong>：在最粗粒度的情绪分类任务中，我们只关心文本所表达的整体态度是正面还是负面。\n<ul>\n<li>“拉完了” → <strong>负面情绪</strong></li>\n<li>“夯爆了” → <strong>正面情绪</strong></li>\n</ul>\n</li>\n</ol>\n<p>在这一设定下，模型的目标非常明确：只需判断“喜欢”还是“不喜欢”，而<strong>不关心情绪强度或细节差异。</strong><br />\n2. <strong>星级五分类</strong>：如果进一步提高情绪刻画的精细程度，就可以将任务扩展为多类别分类，例如常见的 <strong>1～5 星评分预测</strong>。<br />\n- “拉完了” → ★☆☆☆☆<br />\n- “夯爆了” → ★★★★★</p>\n<p>在这一情况下，模型不仅需要识别情绪的正负，还需要理解<strong>情绪的强烈程度</strong>，相比二分类任务，五分类对语义表示的要求明显更高。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260126152958597-1831761240.png\" /><br />\n可以看出，<strong>情绪分类任务的核心难点并不在于模型结构本身，而在于如何让模型“理解”文本所蕴含的情绪语义</strong>。</p>\n<p>而这恰恰正是词向量发挥作用的地方：<strong>只有当“拉完了”“夯爆了”这样的词语在向量空间中被映射到合理的位置，后续的分类模型才有可能做出稳定、可靠的判断。</strong><br />\n而在句子中，情绪本身并不是由单个词独立决定的，而是由<strong>多个词在语义空间中的组合关系</strong>共同构成。<br />\n同样举例来说明，比如：</p>\n<ul>\n<li>“好” 和 “棒” 在语义空间中彼此接近。</li>\n<li>“糟糕” 和 “失望” 会聚集在另一片区域。</li>\n</ul>\n<p>因此，当文本被表示为一组词向量后，模型实际上是在判断：<strong>这些向量整体更靠近“正面情绪区域”，还是“负面情绪区域”。</strong><br />\n这也是为什么，在情绪分类任务中，<strong>词向量的质量往往直接决定了模型的上限</strong>。</p>\n<p>了解了基本原理后，我们来看看如何实现情绪分类。</p>\n<h2 id=\"22-情绪分类-10-平均词向量输入分类器\">2.2 情绪分类 1.0 ：平均词向量输入分类器</h2>\n<p>在最早期、也是最朴素的情绪分类实现中，我们并不会引入复杂的序列模型，而是采用一种<strong>几乎不关心词序</strong>的做法：<strong>将一句话中所有词的词向量取平均，作为整句文本的表示。</strong></p>\n<p>具体来说，假设一句话由 <span class=\"math inline\">\\(n\\)</span> 个词组成，其对应的词向量分别为 ：<span class=\"math inline\">\\(\\mathbf{w}_1, \\mathbf{w}_2, \\dots, \\mathbf{w}_n\\)</span>，那么句向量可以直接定义为：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{s} = \\frac{1}{n} \\sum_{i=1}^{n} \\mathbf{w}_i  \n\\]</div><p></p><p>这个 <span class=\"math inline\">\\(\\mathbf{s}\\)</span> 就被视为整段文本在语义空间中的“位置”，随后只需要将它送入一个<strong>简单的分类器</strong>（如全连接层 + softmax），即可完成情绪预测。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260126152137630-1144988396.png\" /><br />\n这种方法理解起来很直观：<strong>这句话里，所有词语的“情绪方向”加起来，更偏向哪一边？</strong><br />\n如果一句话中大多数词的向量都靠近“正面情绪区域”，那么平均后的结果自然也会偏向正面；反之亦然。</p>\n<p>它的优点是实现简单，计算开销极低；不依赖复杂模型，对小数据集也较为友好，而且通过这种简单的方式也可以直观体现词向量质量对下游任务的影响。</p>\n<p>但它的缺点非常突出，我们常说：<strong>语言是有顺序的</strong>，这种方法<strong>完全忽略了词序信息，只看孤立的语义方向的堆叠，便极有可能产生相应的误解</strong>。<br />\n例如：“缺少好的服务，好的环境和好的餐食。”<br />\n这句话很明显是负面评价，分类器却可能因为出现了很多“好”而将其判断为正面评价。</p>\n<p>因此，<strong>平均词向量 + 分类器</strong> 只是情绪分类任务的入门解法，我们知道有这种方式即可。</p>\n<h2 id=\"23-情绪分类-20-使用循环神经网络\">2.3 情绪分类 2.0 ：使用循环神经网络</h2>\n<p>与直接取平均不同，<a href=\"https://www.cnblogs.com/Goblinscholar/p/19449622\" target=\"_blank\">RNN</a> 会<strong>按顺序逐词读取文本</strong>，并在每一步将当前词的信息与历史上下文进行融合。<br />\n而回顾之前介绍的<a href=\"https://www.cnblogs.com/Goblinscholar/p/19454021\" target=\"_blank\">语言模型</a>内容就会发现，不同于我们之前演示使用的命名实体识别，情绪分类是在读取完整句信息后输出一个分类结果，它是一个<strong>多对一模型</strong>，这类模型反而更符合我们的直觉，来看它的传播过程：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260126152136651-365514513.png\" /><br />\n对于一个词序列 <span class=\"math inline\">\\(w_1, w_2, \\dots, w_n\\)</span>，RNN 的核心计算可以抽象为：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{a}_t = f(\\mathbf{w}_t, \\mathbf{a}_{t-1})  \n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(\\mathbf{a}_t\\)</span> 表示模型在读到第 <span class=\"math inline\">\\(t\\)</span> 个词时，对“当前语义状态”的综合理解。<br />\n我们使用最后一个隐藏状态 <span class=\"math inline\">\\(\\mathbf{a}_n\\)</span> 作为整句文本的表示,再将得到的句向量输入分类器进行预测,得到最终的分类结果。</p>\n<p>这种方式带来的最大改变在于：<strong>情绪不再是词向量的简单叠加，而是一个随阅读过程逐步演化的结果。</strong></p>\n<p>举例来说：</p>\n<ul>\n<li>在读到“好”的时候，模型的情绪倾向可能偏正。</li>\n<li>但当随后读到“不”时，隐藏状态会被重新调整。</li>\n<li>最终输出的表示能够体现“否定”对整体情绪的修正。</li>\n</ul>\n<p>因此，RNN 在对语义的理解能力上明显优于简单的平均向量方法。当然，这也带来了梯度问题和训练成本的提升。</p>\n<p>情绪分类的相关技术同样在不断进步，如今，以 <strong>BERT</strong> 为代表的双向 Transformer 通过大规模语料预训练，能够捕获更精细的上下文语义关系，在情绪分类等判别任务上显著超越传统模型，而更前沿的做法是直接利用<strong>指令微调的大语言模型</strong>，通过 prompt 或少量样本即可完成情绪判断。<br />\n情绪分类正逐步从“专用模型任务”内化为“通用语言理解能力”的自然体现。</p>\n<p>下面，我们补充最后一部分内容：</p>\n<h1 id=\"3-词嵌入除偏word-embedding-debiasing\">3. 词嵌入除偏（Word Embedding Debiasing）</h1>\n<p>我们知道，词向量并不是从真空中学到的，它们来源于真实语料。而真实语料，本身就不可避免地携带着各种<strong>社会偏见和统计偏向</strong>。<br />\n由于词向量的训练目标是捕捉词与词的共现关系，如果某些刻板印象在语料中频繁出现，那么它们就会被“如实地”编码进向量空间中。<br />\n例如，在大量文本中，如果：</p>\n<ul>\n<li>“医生” 、“工程师”更频繁地与男性词汇共现。</li>\n<li>“护士” 、“保姆”更频繁地与女性词汇共现。</li>\n</ul>\n<p>那么训练出来的词向量空间中，就可能形成一条明显的“性别方向”，并在无意中强化这些关联。</p>\n<p>从模型角度看，这种行为是<strong>完全合理的统计学习结果</strong>，但从应用角度看，这种偏见在情绪分析、招聘筛选、推荐系统等场景中，可能带来严重问题。</p>\n<p><strong>这便是词嵌入除偏的目标：在尽量保留语义信息的前提下，削弱或移除特定维度上的偏见成分</strong>。</p>\n<p>2016 年, 论文 <a href=\"https://arxiv.org/pdf/1607.06520\" rel=\"noopener nofollow\" target=\"_blank\">Man is to Computer Programmer as Woman is to Homemaker? Debiasing Word Embeddings </a>中，首次对<strong>词嵌入中的社会偏见</strong>进行了清晰的建模，并提出了一套可操作的除偏方法。它的主要观点是：<strong>偏见并不是“到处都是”的，而是主要集中在某些可解释的方向上。</strong></p>\n<p>我们分点来看看这一方法的实现逻辑：</p>\n<h2 id=\"31-定义偏见方向bias-direction\">3.1 定义偏见方向（Bias Direction）</h2>\n<p>论文的第一步，是显式地定义什么是“偏见方向”。<br />\n以性别偏见为例，我们并不凭主观判断去找偏见，而是构造一组<strong>成对的性别词</strong>，例如：</p>\n<ul>\n<li>(he, she)</li>\n<li>(man, woman)</li>\n<li>(king, queen)</li>\n</ul>\n<p><strong>对于每一组词对，都可以在词向量空间中计算其差向量。将这些差向量进行平均，便可得到一个代表“性别差异”的方向向量</strong>，就像这样：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260126153405646-1690433377.png\" /><br />\n假定词向量拟合度较高，那么对于这个方向就可以理解为：<strong>沿着这条方向移动，语义主要在“男性 ↔ 女性”之间变化，而与其他语义因素关系不大。</strong></p>\n<p>这一步的意义在于将原本模糊、抽象的“偏见”问题，<strong>转化为向量空间中一个可操作的几何方向</strong>。，就像射击前需要先确定靶心一样，只有明确了偏见方向，后续才能有针对性地削弱或移除某些词在该方向上所携带的偏见成分。</p>\n<h2 id=\"32-区分中性词与性别词\">3.2 区分中性词与性别词</h2>\n<p>同样以性别偏见为例：接下来，我们将词汇分为两类：</p>\n<ol>\n<li><strong>性别中性词</strong>：如 <em>doctor, nurse, homeworker</em>，它们不应天然带有性别信息。</li>\n<li><strong>性别特定词</strong>：如 <em>man, woman, she, he</em>，要保留合理的性别信息。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260126152958836-1340196476.png\" /></li>\n</ol>\n<p>注意，这样区分并不代表我们不对特定词进行处理，而是<strong>对不同类型的词采取不同策略</strong>：</p>\n<ol>\n<li>对语义上应当与性别无关的中性词，应<strong>移除</strong>其性别方向上偏见。</li>\n<li>对本身就包含性别差异的词对，则在保留性别信息的前提下，强制其在性别维度上<strong>对称</strong>、在其他语义维度上对齐，从而避免偏见被不合理地放大。</li>\n</ol>\n<p>下面就来看看如何实现这些策略：</p>\n<h2 id=\"33-硬除偏hard-debias\">3.3 硬除偏（Hard Debias）</h2>\n<p>其实并不难理解，首先，我们处理中心词，这一步我们称之为<strong>去投影（Neutralize）：将中性词向量在性别方向上的分量直接移除，使其在该方向上的投影为 0。</strong><br />\n就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260126152629903-530152228.png\" /><br />\n通过这样调整词向量，让中性词在性别方向上的分量消失，自然就不会因为这个方向上的语义差异而产生偏见。</p>\n<p>继续，我们处理特定词，而这部分我们称为<strong>等距化（Equalize）：对于这类本应只在性别上不同的词对，强制它们在性别方向上的距离对称，而在其他语义维度上保持一致。</strong><br />\n就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260126152647475-1295451046.png\" /><br />\n这样做的道理很直观：对于“男”和“女”，在语义空间里，我们不希望出现“男只有一点点男性特征，而女则非常女性化”的不对称情况。<br />\n<strong>如果特定词在性别方向上不对称，不仅会模糊性别边界，还可能降低词向量的整体质量。</strong><br />\n通过等距化，特定词对在“性别以外”的语义上保持等价，但在性别方向上依然可以清晰区分，从而既消除偏见，又保留必要的性别信息。</p>\n<p>此外，既然有硬除偏，自然也有<strong>软除偏</strong>，在明白了硬除偏后，软除偏便不难理解：<br />\n简单来讲，<strong>软除偏只针对中性词</strong>，其处理逻辑和硬除偏也大体相同，不同的是<strong>软除偏将每类偏见中“让中性词在偏见方向上的分量最小化”的逻辑加入神经网络损失函数中作为一项进行迭代优化。</strong><br />\n这种方法更符合我们在深度学习领域的直觉，实际上在现代技术中也有继承软除偏思想、更先进的词嵌入除偏方法，这里就不再专门展开了。</p>\n<h1 id=\"4-总结\">4. 总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>理解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>词向量使用</strong></td>\n<td>将训练好的词向量作为下游任务输入，捕捉语义关系，支持迁移学习。</td>\n<td>模型第一层不再从零开始，而是“站在已整理好的语义空间上”。</td>\n</tr>\n<tr>\n<td><strong>情绪分类（Sentiment Classification）</strong></td>\n<td>给定文本判断情绪倾向，可二分类（正/负）或多分类（如 1~5 星）。</td>\n<td>文本中的词语向量整体靠近“正面区域”还是“负面区域”。</td>\n</tr>\n<tr>\n<td><strong>平均词向量 + 分类器</strong></td>\n<td>将句子中所有词向量取平均作为整句表示，再送入分类器。</td>\n<td>词语的“情绪方向”堆叠，哪边多就偏向哪边。</td>\n</tr>\n<tr>\n<td><strong>RNN 情绪分类</strong></td>\n<td>按顺序逐词读取文本，将当前词与历史上下文融合，输出最后隐藏状态作为句向量。</td>\n<td>情绪随着阅读过程逐步演化，如“好” → 正面，但遇到“不”被修正。</td>\n</tr>\n<tr>\n<td><strong>词嵌入偏见问题</strong></td>\n<td>词向量从真实语料中学习共现关系，容易捕捉社会偏见（如性别刻板印象）。</td>\n<td>统计规律“如实反映”，但可能强化偏见。</td>\n</tr>\n<tr>\n<td><strong>偏见方向（Bias Direction）</strong></td>\n<td>构造成对词（he/she, man/woman），计算差向量并平均得到偏见方向。</td>\n<td>在向量空间中，沿此方向语义主要在“男性 ↔ 女性”之间变化。</td>\n</tr>\n<tr>\n<td><strong>区分中性词与特定词</strong></td>\n<td>中性词移除偏见方向成分；特定词保持性别信息并等距化。</td>\n<td>中性词去除偏见就像去掉不必要的色彩，特定词对保持对称，就像男女形象保持平衡。</td>\n</tr>\n<tr>\n<td><strong>硬除偏（Hard Debias）</strong></td>\n<td>对中性词去投影使性别方向为 0，对特定词做等距化保持对称。</td>\n<td>用“刀子”切掉中性词性别成分，同时调整特定词对保持对称。</td>\n</tr>\n<tr>\n<td><strong>软除偏（Soft Debias）</strong></td>\n<td>只针对中性词，将“最小化偏见方向分量”的目标加入损失函数，通过迭代优化实现减弱偏见。</td>\n<td>温和压低偏见方向，而不是完全切掉，保留语义空间结构。</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-26 15:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">71</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "如何用 Python 将 Markdown 转换为 Word 文档",
      "link": "https://www.cnblogs.com/jazz-z/p/19532573",
      "published": "",
      "description": "<div class=\"postcontent\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"p\">在当今的技术文档工作流中，Markdown 因其简洁的语法和版本控制友好的特性，已成为开发者和技术写作者的首选格式。然而，在企业环境中，Word 文档仍然是正式报告、客户交付物和标准化文档的主流格式。</p>\n<p class=\"p\">本文将分享如何使用 Free Spire.Doc for Python—一款免费的 Python 文档处理库，快速实现 Markdown 到 Word 的转换，涵盖基础转换、批量处理等实用场景，新手也能轻松上手。</p>\n<hr />\n<p class=\"p\">&nbsp;</p>\n<h2 class=\"h4\">一、环境准备</h2>\n<p class=\"p\">Free Spire.Doc for Python 是免费 Python 文档处理库，无需依赖 Microsoft Word，支持 Word 文档的创建、编辑、转换等操作，其中内置的 Markdown 解析能力，能高效实现 Markdown 到 Doc/Docx 格式的转换，且兼容常见的 Markdown 语法（标题、列表、图片、链接等）。</p>\n<p class=\"listitem\"><strong class=\"strong\">安装</strong>：<br />打开终端/命令提示符，执行以下pip安装命令：</p>\n<div class=\"cnblogs_code\">\n<pre>pip <span style=\"color: rgba(0, 0, 255, 1);\">install</span> Spire.Doc.Free</pre>\n</div>\n<p>&nbsp;</p>\n<hr />\n<p>&nbsp;</p>\n<h2 class=\"h4\" id=\"3\">二、基础实现：单篇 Markdown 转 Word</h2>\n<h3 class=\"h5\" id=\"4\">场景1：将 Markdown 文本直接转换为 Word</h3>\n<p class=\"p\">适用于 Markdown 内容较短、无需读取文件的场景，核心代码如下：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">from</span> spire.doc <span style=\"color: rgba(0, 0, 255, 1);\">import</span> *\n<span style=\"color: rgba(0, 0, 255, 1);\">from</span> spire.doc.common <span style=\"color: rgba(0, 0, 255, 1);\">import</span> *\n\n<span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 定义要转换的Markdown文本（涵盖常见语法）</span>\nmarkdown_text = <span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\n# 一级标题：Markdown转Word测试\n## 二级标题：功能演示\n### 三级标题：基础语法支持\n\n#### 1. 段落与强调\n这是一段普通段落，支持**粗体**、*斜体*、`行内代码`，以及[超链接](https://www.google.com/)。\n\n#### 2. 列表\n- 无序列表项1\n- 无序列表项2\n  - 子列表项\n\n1. 有序列表项1\n2. 有序列表项2\n\n#### 3. 代码块\n```python\nprint(\"Hello, Markdown to Word!\")\na = 1 + 2\n```\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n\n<span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 将markdown文本写入md文档</span>\nmarkdown_path = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">input.md</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\nwith open(markdown_path, </span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">w</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, encoding=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">utf-8</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">) as f:\n    f.write(markdown_text)\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2. 创建Document对象</span>\ndoc =<span style=\"color: rgba(0, 0, 0, 1);\"> Document()\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 加载md文档</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">doc.LoadFromFile(markdown_path, FileFormat.Markdown)\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4. 保存为Word文档（支持.doc和.docx格式）</span>\noutput_path = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Markdown转Word.docx</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\ndoc.SaveToFile(output_path, FileFormat.Docx)\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 5. 释放资源</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">doc.Close()\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">转换完成！Word文档已保存至：{output_path}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>)</pre>\n</div>\n<p>&nbsp;</p>\n<h3 class=\"h5\" id=\"5\">场景2：读取 Markdown 文件转换为 Word</h3>\n<p class=\"p\">适用于已有.md文件的场景（如<code class=\"codespan\">test.md</code>），代码更简洁：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">from</span> spire.doc <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> Document\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> spire.doc <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> FileFormat\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 创建Document对象</span>\ndoc =<span style=\"color: rgba(0, 0, 0, 1);\"> Document()\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2. 直接加载Markdown文件（指定文件路径）</span>\nmarkdown_file_path = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">test.md</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\ndoc.LoadFromFile(markdown_file_path, FileFormat.Markdown)\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 保存为Word文档</span>\noutput_path = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Markdown转Word.docx</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\ndoc.SaveToFile(output_path, FileFormat.Docx)\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4. 释放资源</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">doc.Close()\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">文件转换完成！路径：{output_path}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>)</pre>\n</div>\n<p>&nbsp;</p>\n<h5 class=\"h5\" id=\"6\">代码关键说明：</h5>\n<ul class=\"ul\">\n<li class=\"listitem\"><code class=\"codespan\">Document()</code>：创建一个空的 Word 文档对象，是所有操作的核心载体；</li>\n<li class=\"listitem\"><code class=\"codespan\">LoadFromFile()</code>：加载 Markdown 文件，第二个参数&nbsp;<code class=\"codespan\">FileFormat.Markdown</code>&nbsp;指定解析格式；</li>\n<li class=\"listitem\"><code class=\"codespan\">SaveToFile()</code>：接收输出路径和文件格式（<code class=\"codespan\">FileFormat.Docx</code>/<code class=\"codespan\">FileFormat.Doc</code>），完成保存；</li>\n<li class=\"listitem\"><code class=\"codespan\">Close()</code>：释放文档资源，避免内存占用。</li>\n</ul>\n<hr />\n<p>&nbsp;</p>\n<h2 class=\"h4\" id=\"7\">三、批量转换多个 Markdown 文件</h2>\n<p class=\"p\">Free Spire.Doc for Python 支持批量转换一个文件夹中的多个 Markdown 文档。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> os\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> spire.doc <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> Document\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> spire.doc <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> FileFormat\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 定义Markdown文件所在文件夹和输出文件夹</span>\nmd_folder = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">./markdown_files</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\noutput_folder </span>= <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">./word_files</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>\n\n<span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2. 创建输出文件夹（若不存在）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">if</span> <span style=\"color: rgba(0, 0, 255, 1);\">not</span><span style=\"color: rgba(0, 0, 0, 1);\"> os.path.exists(output_folder):\n    os.makedirs(output_folder)\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 遍历文件夹中的所有.md文件</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">for</span> filename <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> os.listdir(md_folder):\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> filename.endswith(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">.md</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">):\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 拼接文件路径</span>\n        md_path =<span style=\"color: rgba(0, 0, 0, 1);\"> os.path.join(md_folder, filename)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成输出Word文件名（替换后缀为.docx）</span>\n        output_filename = os.path.splitext(filename)[0] + <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">.docx</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n        output_path </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> os.path.join(output_folder, output_filename)\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4. 转换逻辑</span>\n        doc =<span style=\"color: rgba(0, 0, 0, 1);\"> Document()\n        doc.LoadFromFile(md_path, FileFormat.Markdown)\n        doc.SaveToFile(output_path, FileFormat.Docx)\n        doc.Close()\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">已转换：{filename} -&gt; {output_filename}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">所有Markdown文件批量转换完成！</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>)</pre>\n</div>\n<p>&nbsp;</p>\n<hr />\n<p>&nbsp;</p>\n<h2 class=\"h4\" id=\"8\">常见问题与注意事项</h2>\n<ol class=\"ol\">\n<li class=\"listitem\"><strong class=\"strong\">格式兼容问题</strong>：部分小众 Markdown 语法（如 Mermaid 流程图、LaTeX 公式）暂不支持，转换后可能显示异常，建议提前简化这类内容；</li>\n<li class=\"listitem\"><strong class=\"strong\">编码问题</strong>：若 Markdown 文件含中文，建议保存为 UTF-8 编码，避免转换后出现乱码；</li>\n<li class=\"listitem\"><strong class=\"strong\">免费版限制</strong>：Free Spire.Doc for Python 免费版对文档页数有限制，满足日常轻量使用。</li>\n</ol><hr />\n<h4 class=\"h4\" id=\"9\">&nbsp;</h4>\n<p class=\"p\">通过本文介绍的方法，我们可以通过几行 Python 代码实现 Markdown 转 Word 文档，同时支持批量处理等扩展功能，完美适配日常办公、文档交付等场景。相比其他转换工具，Free Spire.Doc 无需依赖第三方服务，本地运行更安全，且 Python 接口友好，新手易上手。</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"itemdesc\">\n                发表于 \n<span id=\"post-date\">2026-01-26 12:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jazz-z\">LAYONTHEGROUND</a>&nbsp;\n阅读(<span id=\"post_view_count\">205</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n            </div>"
    },
    {
      "title": "如何正确的 DDD",
      "link": "https://www.cnblogs.com/xiaozhuang/p/19532510",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaozhuang/p/19532510\" id=\"cb_post_title_url\" title=\"发布于 2026-01-26 11:51\">\n    <span>如何正确的 DDD</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在架构设计领域，DDD（领域驱动设计）被讨论得最多，也被误解得最深。很多公司所谓的“官方指导文件”其实是在南辕北辙。如果不纠正这些根源上的错误，所谓的架构优化只能是空中楼阁。</p>\n<p>以下是对当前行业内、甚至是某些大厂指导文件中典型错误做法的深度批判。</p>\n<hr />\n<h2>一、 批判：指导文件建议“不使用领域服务”</h2>\n<p><strong>【现状批判】</strong>：很多公司迷信“绝对充血模型”，要求逻辑必须全写在领域实体中。然而，现实中大量业务涉及<strong>同领域内多个实体的对比与关联校验</strong>（并非跨领域协作）。因为逻辑在单个实体里塞不进去，而指导文件又禁用了领域服务，程序员被迫将核心业务规则“偷渡”到<strong>应用层</strong>。</p>\n<p><strong>【正确方式】</strong>：<strong>领域服务是逻辑的指挥官。</strong> 凡是涉及本领域内多实体协作、业务主键查重、规则验证，必须由领域服务承载。它是领域层对外的唯一逻辑入口，守住领域核心逻辑。</p>\n<hr />\n<h2>二、 批判：在应用层加入“公共方法目录”</h2>\n<p><strong>【现状批判】</strong>：由于领域逻辑被驱逐到了应用层，为了复用，开发者只能在应用层搞一个 <code>Common</code> 或 <code>Util</code>。这本质上是由于领域逻辑无法归位而导致的“架构流产”。</p>\n<p><strong>【正确方式】</strong>：<strong>业务逻辑必须回归领域。</strong> 任何涉及规则的复用，必须沉淀在各自的领域服务中。应用层只负责调度流程，绝不负责存储业务规则。</p>\n<hr />\n<h2>三、 批判：指导文件明确“不使用聚合”</h2>\n<p><strong>【现状批判】</strong>：有些指导文档主张平铺实体。没有聚合，实体就像散沙，应用层可以随意绕过业务规则修改实体状态，导致一致性防线全面崩溃。</p>\n<p><strong>【正确方式】</strong>：<strong>每一个领域必须是一个聚合。</strong> 聚合根是唯一的入口。只有通过聚合根，才能保证业务规则（不变量）在任何时候都是有效的。聚合不是负担，而是保护业务逻辑的盔甲。</p>\n<hr />\n<h2>四、 批判：在应用层定义外部调用防腐接口</h2>\n<p><strong>【现状批判】</strong>：文档建议在应用层定义防腐接口，这会导致<strong>基础服务反向依赖应用层</strong>，造成严重的依赖环和逻辑污染。</p>\n<p><strong>【正确方式】</strong>：<strong>新建领域对象，在领域层定义接口。</strong> 应该在领域层创建接口契约，由基础架构层（Infrastructure）去实现细节。最后，将该能力封装成<strong>领域服务</strong>供应用层调用。确保领域层自持，基础架构层只负责“插件式”实现。</p>\n<hr />\n<h2>五、 批判：领域服务调用其它领域的仓储</h2>\n<p><strong>【现状批判】</strong>：在订单领域直接注入用户领域的 Repository。这种“跨界伸手段”让领域边界瞬间消失，两个领域在物理存储层面死死捆绑，未来根本无法拆分。</p>\n<p><strong>【正确方式】</strong>：<strong>领域间绝对零感知。</strong> 领域服务只能调用本领域的仓储。跨领域的交互必须上浮到应用层，由应用层担任“导演”进行编排。</p>\n<hr />\n<h2>六、 批判：把领域对象用来接收领域事件</h2>\n<p><strong>【现状批判】</strong>：让实体或领域对象去监听 MQ 消息。这不仅引入了技术噪音，最致命的是<strong>让领域之间形成了依赖</strong>。一旦领域 A 的对象去监听领域 B 的事件，领域 A 就不再孤立，它被迫感知了外部世界的变化，破坏了领域自治。</p>\n<p><strong>【正确方式】</strong>：<strong>应用层监听，领域服务处理。</strong> 应用层负责接收外部事件并将其“翻译”为本领域能理解的普通请求。领域对象应保持清静，它不该知道“事件”是从哪来的，更不该知道外部领域的存在。</p>\n<hr />\n<h2>领域对象设计原则：全业务封装与绝对隔离</h2>\n<ol start=\"1\">\n<li>\n<p><strong>领域必须封装本领域的所有业务</strong>：通过<strong>领域服务</strong>实现业务逻辑的完全闭环。领域外层（应用层）不需要知道领域内部是如何判决的。</p>\n</li>\n<li>\n<p><strong>领域之间必须绝对隔离</strong>：领域之间要达到“物理级”的互不感知。它们不知道彼此的存在，更不能直接通信。</p>\n</li>\n<li>\n<p><strong>应用层是唯一的导演</strong>：只有应用层才有资格编排各个领域。应用层指挥 A 领域判决、B 领域执行，而领域本身只专注于自己。</p>\n</li>\n</ol><hr />\n<h2>总结：正确 DDD 的标准化原则</h2>\n<ul>\n<li>\n<p><strong>1-1-N 模组结构</strong>：<strong>1 个仓储接口、1 个领域服务、N 个实体（构成 1 个聚合）</strong>。</p>\n</li>\n<li>\n<p><strong>契约自持</strong>：接口定义在领域层，拒绝反向依赖。</p>\n</li>\n<li>\n<p><strong>物理级隔离</strong>：领域间零感知，逻辑全封装，由应用层统一编排。</p>\n</li>\n<li>\n<p><strong>首错即断（Fail-fast）</strong>：领域内遇错直接抛出业务异常。</p>\n</li>\n</ul>\n<p><strong>只有正确的 DDD，才能正确的“微”服务。</strong></p>\n<p>微服务不是拆出来的，而是领域边界清晰后自然“长”出来的。</p>\n<hr />\n<p><strong>博主结语</strong>： 架构的优雅来自于对领域边界的极端克制。那些要求你“禁用领域服务”、“平铺实体”的指导文件，其实是在毁掉你的架构。拒绝虚伪的 DDD，守住领域层的尊严。</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-26 11:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xiaozhuang\">小庄</a>&nbsp;\n阅读(<span id=\"post_view_count\">270</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Envoy 可观测性实战：日志、指标与链路追踪的完整落地",
      "link": "https://www.cnblogs.com/MrVolleyball/p/19532068",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/MrVolleyball/p/19532068\" id=\"cb_post_title_url\" title=\"发布于 2026-01-26 11:03\">\n    <span>Envoy 可观测性实战：日志、指标与链路追踪的完整落地</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        可观测性不是“装个 Prometheus 就完事”，而是日志、指标、链路追踪三位一体的系统工程。本文结合 Envoy 1.32 实际配置，详细讲解如何接入 Prometheus 和 Jaeger，以及 Envoy Admin 接口在观测中的作用，帮助你快速建立一套真正“能用”的 Envoy 可观测性方案\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>本节详细聊一下基于envoy的可观测性</p>\n<h2 id=\"日志\">日志</h2>\n<p>首先是日志，配置日志的方式也很简单</p>\n<pre><code>static_resources:\n  listeners:\n    - name: ingress_listener\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 10000\n      filter_chains:\n        - filters:\n            - name: envoy.filters.network.http_connection_manager\n              typed_config:\n                \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n                stat_prefix: ingress_http\n                ...\n                access_log:\n                - name: envoy.access_loggers.stdout\n                  typed_config:\n                    \"@type\": type.googleapis.com/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog\n                    log_format:\n                      text_format: \"[%START_TIME%] \\\"%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%\\\" %RESPONSE_CODE% %BYTES_SENT% %DURATION% %REQ(X-REQUEST-ID)% \\\"%REQ(USER-AGENT)%\\\" \\\"%REQ(X-FORWARDED-FOR)%\\\" %UPSTREAM_HOST% %UPSTREAM_CLUSTER% %RESPONSE_FLAGS%\\n\"\n\n</code></pre>\n<ul>\n<li>该配置是将日志输出在控制台，也可以直接输出为文件，然后通过工具采集走<code>path: /var/log/envoy/access.log</code></li>\n<li>也可以直接将日志输出至kafka，并且按比例采集、只采集4xx、5xx等都可以配置，这里就不在赘述了</li>\n</ul>\n<h2 id=\"admin管理页面\">admin管理页面</h2>\n<p>envoy有默认的admin页面，方便查看统计信息、打开某些功能的开关等</p>\n<pre><code>admin:\n  address:\n    socket_address:\n      address: 0.0.0.0\n      port_value: 9901\n\n</code></pre>\n<p>打开9901页面：</p>\n<p><img alt=\"watermarked-envoy_ob_1\" class=\"lazyload\" /></p>\n<p>可以查看相关的统计信息、也可以打开某些开关，功能还是很丰富的</p>\n<h2 id=\"merics接入prometheus\">merics接入prometheus</h2>\n<p>打开了admin之后，就默认提供了相关的prometheus stats <code>http://10.105.148.194:9901/stats/prometheus</code></p>\n<p>这时只需在k8s集群外弄一个prometheus，并且采集该envoy即可</p>\n<p>prometheus.yml</p>\n<pre><code>global:\n  scrape_interval: 5s\n  evaluation_interval: 5s\n\nrule_files:\n  - /etc/prometheus/*.rules\n\nscrape_configs:\n  - job_name: 'prometheus'\n    static_configs:\n    - targets: ['localhost:9090']\n\n  - job_name: \"envoy\"\n    metrics_path: /stats/prometheus\n    static_configs:\n    - targets: [\"10.105.148.194:9901\"]\n\n</code></pre>\n<pre><code>docker run -d --name prometheus \\\n  -p 9090:9090 \\\n  -v ./prometheus.yml:/etc/prometheus/prometheus.yml \\\n  -v /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime \\\n  registry.cn-beijing.aliyuncs.com/wilsonchai/prometheus:v3.5.0\n</code></pre>\n<h2 id=\"traces接入jaeger\">traces接入jaeger</h2>\n<p>jaeger的安装可以参考这里： <a href=\"https://mp.weixin.qq.com/s/SkoFwwcw84THbGOi7YaKCA\" rel=\"noopener nofollow\" target=\"_blank\">opentelemetry全链路初探--埋点与jaeger</a></p>\n<p>jaeger启动之后，改造一下envoy的配置，这里要特别注意，不同版本的配置不一样，我这里envoy的版本是：v1.32</p>\n<pre><code>static_resources:\n  listeners:\n    - name: ingress_listener\n      filter_chains:\n        - filters:\n            - name: envoy.filters.network.http_connection_manager\n              typed_config:\n                ...\n\n                tracing:\n\n                  provider:\n                    name: envoy.tracers.opentelemetry\n                    typed_config:\n                      \"@type\": type.googleapis.com/envoy.config.trace.v3.OpenTelemetryConfig\n                      service_name: envoy-proxy\n                      grpc_service:\n                        envoy_grpc:\n                          cluster_name: jaeger_otlp_collector\n                ...\n\n  clusters:\n    ...\n    - name: jaeger_otlp_collector\n      type: LOGICAL_DNS\n      connect_timeout: 5s\n      lb_policy: ROUND_ROBIN\n      http2_protocol_options: {}\n\n      load_assignment:\n        cluster_name: jaeger_otlp_collector\n        endpoints:\n        - lb_endpoints:\n          - endpoint:\n              address:\n                socket_address:\n                  address: 10.22.12.178\n                  port_value: 4317\n    ...\n\n</code></pre>\n<p>修改完成之后重启下envoy</p>\n<p>jaeger成功接收到了来自envoy的trace</p>\n<p><img alt=\"watermarked-envoy_ob_2\" class=\"lazyload\" /></p>\n<p><img alt=\"watermarked-envoy_ob_3\" class=\"lazyload\" /></p>\n<p>由于只在envoy配置了trace，没有和后端服务联动，所有只显示了envoy这一段的trace信息，如果要联动后端，可以参考这个系列的文章： <a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzk1NzE0MDcwMg==&amp;action=getalbum&amp;album_id=4247181358063419407&amp;scene=126&amp;sessionid=1767595793922#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">全链路监控配置</a></p>\n<h2 id=\"小结\">小结</h2>\n<p>至此，logs、metrics、traces三大可观测的指标建设完成，envoy可观测性的建设也结束了</p>\n<h2 id=\"联系我\">联系我</h2>\n<ul>\n<li>联系我，做深入的交流</li>\n</ul>\n<p><img alt=\"\" class=\"lazyload\" height=\"200\" width=\"500\" /></p>\n<hr />\n<p>至此，本文结束<br />\n在下才疏学浅，有撒汤漏水的，请各位不吝赐教...</p>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/MrVolleyball/\" target=\"_blank\">it排球君</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/MrVolleyball/p/19532068\" target=\"_blank\">https://www.cnblogs.com/MrVolleyball/p/19532068</a></p>\n<div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须在文章页面给出原文连接，否则保留追究法律责任的权利。 </div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-26 11:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/MrVolleyball\">it排球君</a>&nbsp;\n阅读(<span id=\"post_view_count\">97</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}