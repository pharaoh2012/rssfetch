{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "哑铃图：数据对比的优雅之选",
      "link": "https://www.cnblogs.com/wang_yb/p/19519312",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19519312\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 23:23\">\n    <span>哑铃图：数据对比的优雅之选</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>简洁的线条连接两个数据点，就像哑铃的两端，在对比分析中展现出令人惊艳的清晰度。</p>\n</blockquote>\n<p>在平时的数据分析项目中，我经常会遇到比较两个相关数据集的变化情况。</p>\n<p>这时，传统的做法是使用堆积条形图或簇状条形图，但它们存在一个<strong>共同问题</strong>：当我们需要精确追踪每个项目在两个时间点或两种条件下的变化时，这些图表会让我们的眼睛在条形之间来回跳跃，难以直观把握变化的幅度和方向。</p>\n<p>今天，我要向大家推荐一种更优雅的替代方案--<strong>哑铃图</strong>。</p>\n<h1 id=\"1-哑铃图是什么\">1. 哑铃图是什么？</h1>\n<p><strong>哑铃图</strong>（<code>Dumbbell Plot</code>），有时也称为<strong>DNA图</strong>或<strong>杠铃图</strong>，是一种用于比较两个相关数据点的可视化图表。</p>\n<p>它源于人们对更有效数据比较方式的持续探索。</p>\n<p>在传统的时间序列比较中，我们通常使用两条折线，但当需要比较的项目较多时，折线图会变得混乱。<strong>哑铃图</strong>通过将比较焦点放在每个项目的两个状态上，解决了多项目对比时的视觉混乱问题。</p>\n<p>它的<strong>基本结构</strong>很简单：</p>\n<ul>\n<li>每个观察单位（如产品、地区、时间段）对应两个数据点</li>\n<li>这两个数据点由一条直线（或线段）连接</li>\n<li>整个图形看起来像一排排哑铃，因而得名</li>\n</ul>\n<h1 id=\"2-实现原理\">2. 实现原理</h1>\n<p><strong>哑铃图</strong>的核心设计理念是<strong>最小化认知负荷</strong>。</p>\n<p>当我们需要比较A和B时，最直接的方式就是把它们放在一起，用一条线连接，然后观察这条线的长度（差异大小）和方向（哪个更大）。</p>\n<p>在<code>matplotlib</code>中创建<strong>哑铃图</strong>，我们主要使用以下元素：</p>\n<ul>\n<li><strong>散点图</strong>：表示两个数据点</li>\n<li><strong>直线段</strong>：连接两个相关点</li>\n<li><strong>颜色编码</strong>：通常用不同颜色区分前后状态或不同组别</li>\n<li><strong>标签系统</strong>：清晰标识每个观察单位</li>\n</ul>\n<h1 id=\"3-实战示例\">3. 实战示例</h1>\n<p>接下来，我们看看哑铃图在实际场景中的显示效果。</p>\n<p>假设我们是一家电商公司的数据分析师，需要比较8个主要产品类别在2022年和2023年的销售额变化。</p>\n<p>（完整的代码在文章末尾提供下载地址，文中只截取部分代码）</p>\n<p>先创建一些测试数据：</p>\n<pre><code class=\"language-python\"># 示例数据：8个产品类别在2022年和2023年的销售额（单位：万元）\ncategories = [\n    \"电子产品\",\n    \"服装鞋帽\",\n    \"家居用品\",\n    \"美妆护肤\",\n    \"图书音像\",\n    \"运动户外\",\n    \"食品饮料\",\n    \"母婴用品\",\n]\nsales_2022 = [85, 92, 78, 65, 45, 60, 88, 72]\nsales_2023 = [95, 87, 85, 78, 52, 73, 95, 80]\n</code></pre>\n<p>然后，我们绘制传统的簇状条形图和哑铃图来对比一下效果：</p>\n<pre><code class=\"language-python\"># 创建子图，对比两种可视化方法\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 8))\n\n# 簇状条形图\nx = np.arange(len(categories))\n\nbars1 = ax1.bar(x - width/2, sales_2022, width, label='2022年', color='#4C72B0', alpha=0.8)\nbars2 = ax1.bar(x + width/2, sales_2023, width, label='2023年', color='#DD8452', alpha=0.8)\n\n# 在每个条形上添加数值标签\n# 省略 ...\n\n# 哑铃图\n# 设置y轴位置（每个类别的垂直位置）\ny_pos = np.arange(len(categories))\n\n# 绘制连接线\nfor i, (y2022, y2023) in enumerate(zip(sales_2022, sales_2023)):\n    # 确定线颜色：增长为绿色，下降为红色\n    line_color = '#55A868' if y2023 &gt; y2022 else '#C44E52'\n    ax2.plot([y2022, y2023], [i, i], color=line_color, linewidth=2.5, alpha=0.7, zorder=1)\n\n# 绘制数据点\nax2.scatter(sales_2022, y_pos, s=120, color='#4C72B0', alpha=0.9, label='2022年', zorder=2, edgecolors='white', linewidth=2)\nax2.scatter(sales_2023, y_pos, s=120, color='#DD8452', alpha=0.9, label='2023年', zorder=2, edgecolors='white', linewidth=2)\n\n# 省略 ...\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260122232220614-1554024714.png\" /></p>\n<p>通过上面的对比，我们可以清晰地看到<strong>哑铃图</strong>的优势：</p>\n<ul>\n<li><strong>变化一目了然</strong>：连接线的长度直观表示变化幅度，方向表示增长或下降</li>\n<li><strong>减少视觉跳跃</strong>：眼睛不需要在条形间来回移动，而是沿着水平线自然追踪</li>\n<li><strong>突出比较重点</strong>：专注于每个项目的两个状态对比，而非绝对数值</li>\n</ul>\n<p>进一步，我们还可以给<strong>哑铃图</strong>排序，按照增长<strong>由快到慢</strong>给各个品类排序，这样自然形成从\"下降最显著\"到\"增长最显著\"的连续谱，模式自动显现，无需刻意寻找。</p>\n<p>比如上面的<strong>哑铃图</strong>中，【服装鞋帽】这个品类其实销售额是下降的，混在一堆哑铃中不容易看出来吧？</p>\n<pre><code class=\"language-python\"># 创建排序后的哑铃图\nfig, ax = plt.subplots(figsize=(10, 8))\n\n# 按变化幅度排序\nsorted_indices = np.argsort(\n    [sales_2023[i] - sales_2022[i] for i in range(len(categories))]\n)\nsorted_categories = [categories[i] for i in sorted_indices]\nsorted_2022 = [sales_2022[i] for i in sorted_indices]\nsorted_2023 = [sales_2023[i] for i in sorted_indices]\n\n# 绘制连接线\n# 省略 ...\n\n# 绘制数据点\n# 省略 ...\n\n# 添加变化箭头标注\n# 省略 ...\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260122232220694-18227431.png\" /></p>\n<p>这样改造后，由上到下的哑铃，越来越短（也就是增长越来越慢），最底部的那个是<strong>负增长</strong>，用了<strong>红色</strong>来标注。</p>\n<h1 id=\"4-总结\">4. 总结</h1>\n<p>数据可视化的核心目标是<strong>有效传达信息</strong>。当我们需要强调变化、比较两个相关状态时，<strong>哑铃图</strong>提供了一种简洁而强大的解决方案。</p>\n<p>就像选择合适的工具完成工作一样，在面对数据比较任务时，我们应该根据具体需求选择最合适的可视化形式：</p>\n<ul>\n<li>当需要比较多个项目的两个状态时，选择<strong>哑铃图</strong></li>\n<li>当需要展示单个项目的多个组成部分时，选择<strong>堆积条形图</strong></li>\n<li>当需要比较多个项目的多个类别时，选择<strong>簇状条形图</strong></li>\n</ul>\n<p>最好的可视化不是最复杂的，而是能让观众在最短时间内理解最多信息的那个。</p>\n<p><strong>哑铃图</strong>正是这样一种高效的工具，它用最简单的线条连接，讲述了数据世界中最动人的变化故事。</p>\n<p>下次做报告时，不妨试着把那张拥挤的簇状条形图换成<strong>哑铃图</strong>，相信你的观众会感叹：“哇，这张图做得真专业！”</p>\n<p>完整代码：<a href=\"https://url11.ctfile.com/f/45455611-8608730361-d698e0?p=6872\" rel=\"noopener nofollow\" target=\"_blank\">哑铃图.ipynb</a> (访问密码: 6872)</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 23:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Langchain 快速入门(一)",
      "link": "https://www.cnblogs.com/ClownLMe/p/19519224",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19519224\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 22:51\">\n    <span>Langchain 快速入门(一)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简介\">简介</h1>\n<p>langchain专门用于构建LLM大语言模型，其中提供了大量的prompt模板，和组件，通过chain(链)的方式将流程连接起来，操作简单，开发便捷。</p>\n<h1 id=\"环境配置\">环境配置</h1>\n<p><strong>安装langchain框架</strong></p>\n<pre><code class=\"language-bash\">pip install langchain langchain-community\n</code></pre>\n<p>其中langchain可以提供了各种大模型语言库选择，（这里只列举几个）例如：</p>\n<pre><code class=\"language-bash\">#chatgpt\npip install langchain-openai\n#hugging face\npip install langchain-huggingface\n#千问\npip install langchain-qwq\n</code></pre>\n<h1 id=\"1-让模型跑起来\">1. 让模型跑起来</h1>\n<p>如何让你llm跑起来，这里用的是千问，来演示</p>\n<h3 id=\"案例\">案例</h3>\n<pre><code class=\"language-python\">import os\nfrom langchain_community.chat_models.tongyi import ChatTongyi\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\n\n#这里是你的千问apikey\nos.environ[\"DASHSCOPE_API_KEY\"] = \"apikey\"\n\nmodel = ChatTongyi(model=\"qwen-plus\")\n\nprompt = ChatPromptTemplate.from_messages([\n&nbsp; &nbsp; (\"system\", \"你是一个精通{topic}的资深技术专家。\"),\n&nbsp; &nbsp; (\"user\", \"请用三句话解释一下什么是{concept}。\")\n])\n\noutput_parser = StrOutputParser()\n\nchain = prompt | model | output_parser\n\n#文本输出\nresponse = chain.invoke({\"topic\": \"Python\", \"concept\": \"列表\"})\nprint(response)\n\n#分割\nprint(\"=\"*30)\n\n#流式输出\nfor chunk in chain.stream({\"topic\": \"人工智能\", \"concept\": \"神经网络\"}):\n&nbsp; &nbsp; print(chunk, end=\"\", flush=True)\n</code></pre>\n<h3 id=\"代码解释\">代码解释</h3>\n<p>整个代码的流程如下：<br />\n<strong>创建模型-&gt;构建提示词-&gt;构建chain链-&gt;使用大模型</strong></p>\n<h5 id=\"创建模型\">创建模型</h5>\n<p>这一步用不同的模型可能会不同<br />\n这里利用langchain的千问库创建模型，可能会不同</p>\n<pre><code class=\"language-python\">model = ChatTongyi(model=\"qwen-plus\")\n\n#例如用chatgpt\nllm = init_chat_model(\"gpt-4o\", model_provider=\"openai\")\n</code></pre>\n<h5 id=\"构建提示词\">构建提示词</h5>\n<p>这一步构建利用了langchain库提供提示词模板：<br />\n其中用<code>{}</code>阔起来的在调用时可以动态用字典替换</p>\n<pre><code class=\"language-python\">prompt = ChatPromptTemplate.from_messages([\n&nbsp; &nbsp; (\"system\", \"你是一个精通{topic}的资深技术专家。\"),\n&nbsp; &nbsp; (\"user\", \"请用三句话解释一下什么是{concept}。\")\n])\n</code></pre>\n<p>各个角色功能如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>角色名称 (Role)</strong></th>\n<th><strong>对应的类</strong></th>\n<th><strong>作用说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>system</strong></td>\n<td><code>SystemMessage</code></td>\n<td><strong>系统提示词</strong>。用于设定 AI 的“人格”、专业背景、行为准则或约束条件。它通常优先级最高，决定了后续对话的基调。</td>\n</tr>\n<tr>\n<td><strong>user</strong></td>\n<td><code>HumanMessage</code></td>\n<td><strong>用户消息</strong>。代表人类发送的内容。这是模型需要直接回答或处理的问题。</td>\n</tr>\n<tr>\n<td><strong>ai</strong></td>\n<td><code>AIMessage</code></td>\n<td><strong>AI 消息</strong>。代表模型之前的回复。在构建多轮对话（带记忆）时，需要把模型之前的回复传回去。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"构建chain链\">构建chain链</h5>\n<p>这个是langchain的灵魂，这里简单说明，后面会发更详细的教学文章<br />\nchain链的运行流程如下：<br />\n<strong>将输入填充prompt-&gt;将完整prompt喂给LLM-&gt;直接解析返回文本</strong></p>\n<p><code>StrOutputParser()</code>这个是langchain提供的文本解析器，用于将上面的结果解析为文本</p>\n<pre><code class=\"language-python\">output_parser = StrOutputParser()\nchain = prompt | model | output_parser\n</code></pre>\n<h5 id=\"使用大模型\">使用大模型</h5>\n<p>这里有两种方式：</p>\n<ol>\n<li>直接输出完整的文本</li>\n</ol>\n<pre><code class=\"language-python\">response = chain.invoke({\"topic\": \"Python\", \"concept\": \"列表\"})\nprint(response)\n</code></pre>\n<ol start=\"2\">\n<li>流文本输出（打字机）</li>\n</ol>\n<pre><code class=\"language-python\">for chunk in chain.stream({\"topic\": \"人工智能\", \"concept\": \"神经网络\"}):\n&nbsp; &nbsp; print(chunk, end=\"\", flush=True)\n</code></pre>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 22:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Nginx多服务静态资源路径冲突解决方案",
      "link": "https://www.cnblogs.com/yudaxia/p/19519201",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yudaxia/p/19519201\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 22:34\">\n    <span>Nginx多服务静态资源路径冲突解决方案</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>在使用Nginx反向代理多个Flask应用时，遇到了一个棘手的问题：不同服务的静态资源（CSS/JS）会互相干扰。本文记录了问题的分析过程和解决方案。</p>\n<p><strong>关键词</strong>：Nginx反向代理、Flask静态资源、location匹配、proxy_pass</p>\n</blockquote>\n<h2 id=\"问题描述\">问题描述</h2>\n<p>在Nginx反向代理多个Flask服务时，不同服务的静态资源路径会发生冲突，导致服务A的页面加载了服务B的CSS/JS文件，或者找不到静态资源返回404错误。</p>\n<h3 id=\"问题场景\">问题场景</h3>\n<h4 id=\"部署架构\">部署架构</h4>\n<pre><code>域名: mathcoding.top\n├── 主服务 (端口5000) → 路径前缀: /\n└── 限流服务 (端口5001) → 路径前缀: /numberLimit\n</code></pre>\n<h4 id=\"初始nginx配置\">初始Nginx配置</h4>\n<pre><code class=\"language-nginx\"># 限流服务\nlocation /numberLimit {\n&nbsp; &nbsp; proxy_pass http://127.0.0.1:5001/;\n&nbsp; &nbsp; proxy_set_header Host $host;\n&nbsp; &nbsp; proxy_set_header X-Real-IP $remote_addr;\n&nbsp; &nbsp; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n&nbsp; &nbsp; proxy_set_header X-Forwarded-Proto $scheme;\n}\n# 主服务（兜底规则）\nlocation / {\n&nbsp; &nbsp; proxy_pass http://127.0.0.1:5000;\n&nbsp; &nbsp; proxy_set_header Host $host;\n&nbsp; &nbsp; proxy_set_header X-Real-IP $remote_addr;\n&nbsp; &nbsp; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n&nbsp; &nbsp; proxy_set_header X-Forwarded-Proto $scheme;\n}\n</code></pre>\n<h4 id=\"flask模板代码\">Flask模板代码</h4>\n<pre><code class=\"language-html\">&lt;!-- 5001端口的限流服务的模板 --&gt;\n&lt;link rel=\"stylesheet\" href=\"{{url_for('static', filename='css/style.css')}}\" /&gt;\n</code></pre>\n<h3 id=\"错误表现详解\">错误表现详解</h3>\n<p><strong>期望行为</strong>：</p>\n<ol>\n<li>访问 <code>https://mathcoding.top/numberLimit/</code> 加载限流服务的页面</li>\n<li>页面中的CSS链接应该请求限流服务(5001端口)的静态资源</li>\n<li>浏览器应该能正确获取到限流服务的 <code>static/css/style.css</code> 文件<br />\n<strong>实际行为</strong>：</li>\n<li>访问 <code>https://mathcoding.top/numberLimit/</code> ✅ 正确加载页面HTML</li>\n<li>Flask的 <code>url_for('static')</code> 生成路径：<code>/static/css/style.css</code></li>\n<li>浏览器发起请求：<code>https://mathcoding.top/static/css/style.css</code></li>\n<li>Nginx匹配到 <code>location /</code>（因为 <code>/static/...</code> 匹配不到 <code>/numberLimit</code>）</li>\n<li>请求被转发到主服务5000端口 ❌ <strong>错误的服务！</strong></li>\n<li>结果：加载了主服务的CSS（样式错误）或返回404（主服务没有这个文件）</li>\n</ol>\n<h3 id=\"问题的视觉表现\">问题的视觉表现</h3>\n<p>打开浏览器开发者工具Network标签会看到：</p>\n<pre><code>请求URL: https://mathcoding.top/static/css/style.css\n状态码: 200 或 404\n来源页面: https://mathcoding.top/numberLimit/\n问题: 这个CSS文件来自5000端口的主服务，不是5001端口的限流服务\n</code></pre>\n<p>页面表现：</p>\n<ul>\n<li>CSS样式不正确或完全没有样式</li>\n<li>控制台可能出现MIME类型错误</li>\n<li>如果主服务没有同名文件，则显示404错误</li>\n</ul>\n<h2 id=\"问题根源\">问题根源</h2>\n<h3 id=\"底层原理\">底层原理</h3>\n<ol>\n<li><strong>Flask URL生成机制</strong>：<code>url_for('static')</code> 生成的是绝对路径，默认为 <code>/static/...</code>，不包含服务的挂载前缀</li>\n<li><strong>Nginx location匹配规则</strong>：采用最长前缀匹配，<code>/static/...</code> 不匹配 <code>/numberLimit</code>，因此被 <code>location /</code> 捕获</li>\n<li><strong>路径命名空间冲突</strong>：多个服务共享同一个URL路径空间，都使用 <code>/static/...</code> 作为静态资源路径</li>\n</ol>\n<h3 id=\"请求流程分析\">请求流程分析</h3>\n<pre><code>Flask渲染模板\n&nbsp; &nbsp; ↓\nurl_for('static', filename='css/style.css')\n&nbsp; &nbsp; ↓\n生成HTML: &lt;link href=\"/static/css/style.css\"&gt;\n&nbsp; &nbsp; ↓\n浏览器解析HTML并发起请求: GET /static/css/style.css\n&nbsp; &nbsp; ↓\nNginx匹配规则:\n&nbsp; - /numberLimit? 不匹配 (请求路径是/static/..., 不是/numberLimit/...)\n&nbsp; - /? 匹配! (最长前缀匹配的兜底规则)\n&nbsp; &nbsp; ↓\nproxy_pass转发到: http://127.0.0.1:5000/static/css/style.css\n&nbsp; &nbsp; ↓\n错误: 5001服务的静态资源被错误地路由到5000服务\n</code></pre>\n<h3 id=\"为什么flask不生成-numberlimitstatic\">为什么Flask不生成 <code>/numberLimit/static/...</code>？</h3>\n<p>Flask应用本身不知道它被部署在什么路径下。从Flask的视角：</p>\n<ul>\n<li>它收到的请求路径是 <code>/</code>（因为 <code>proxy_pass http://127.0.0.1:5001/</code> 末尾有斜杠，会剥离前缀）</li>\n<li>它认为自己的根路径就是 <code>/</code></li>\n<li>所以 <code>url_for('static')</code> 生成 <code>/static/...</code> 而不是 <code>/numberLimit/static/...</code><br />\n这就是为什么需要在Flask端配置 <code>static_url_path</code>，或者在Nginx端做路径重写。</li>\n</ul>\n<h2 id=\"解决方案\">解决方案</h2>\n<h3 id=\"方案选择独立静态资源路径前缀\">方案选择：独立静态资源路径前缀</h3>\n<p>为每个服务配置独立的静态资源URL前缀，避免路径冲突。这种方案：</p>\n<ul>\n<li>服务代码改动最小（只改一个配置参数）</li>\n<li>不需要复杂的URL重写规则</li>\n<li>易于理解和维护</li>\n<li>符合微服务的命名空间隔离原则</li>\n</ul>\n<h3 id=\"flask配置\">Flask配置</h3>\n<pre><code class=\"language-python\"># 设置独立的静态资源URL路径\napp = Flask(__name__, static_url_path=\"/numberLimit-static\")\n</code></pre>\n<p><strong>参数说明</strong>：</p>\n<ul>\n<li><code>static_url_path</code>: 控制URL生成，影响 <code>url_for('static')</code> 的输出</li>\n<li><code>static_folder</code>: 控制文件系统路径（默认为'static'，不需要改）<br />\n<strong>效果</strong>：</li>\n</ul>\n<pre><code class=\"language-python\"># 修改前\nurl_for('static', filename='css/style.css') &nbsp;# → /static/css/style.css\n# 修改后\nurl_for('static', filename='css/style.css') &nbsp;# → /numberLimit-static/css/style.css\n</code></pre>\n<h3 id=\"nginx配置\">Nginx配置</h3>\n<pre><code class=\"language-nginx\"># 静态资源location（优先级高，放在前面）\nlocation /numberLimit-static/ {\n&nbsp; &nbsp; proxy_pass http://127.0.0.1:5001/numberLimit-static/;\n&nbsp; &nbsp; proxy_set_header Host $host;\n&nbsp; &nbsp; proxy_set_header X-Real-IP $remote_addr;\n&nbsp; &nbsp; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n&nbsp; &nbsp; proxy_set_header X-Forwarded-Proto $scheme;\n}\n# 服务主路径\nlocation /numberLimit {\n&nbsp; &nbsp; proxy_pass http://127.0.0.1:5001/;\n&nbsp; &nbsp; proxy_set_header Host $host;\n&nbsp; &nbsp; proxy_set_header X-Real-IP $remote_addr;\n&nbsp; &nbsp; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n&nbsp; &nbsp; proxy_set_header X-Forwarded-Proto $scheme;\n}\n# 主服务（放在最后）\nlocation / {\n&nbsp; &nbsp; proxy_pass http://127.0.0.1:5000;\n&nbsp; &nbsp; proxy_set_header Host $host;\n&nbsp; &nbsp; proxy_set_header X-Real-IP $remote_addr;\n&nbsp; &nbsp; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n&nbsp; &nbsp; proxy_set_header X-Forwarded-Proto $scheme;\n}\n</code></pre>\n<h3 id=\"工作流程\">工作流程</h3>\n<pre><code>Flask渲染模板\n&nbsp; &nbsp; ↓\nurl_for('static', filename='css/style.css')\n&nbsp; &nbsp; ↓\n生成HTML: &lt;link href=\"/numberLimit-static/css/style.css\"&gt;\n&nbsp; &nbsp; ↓\n浏览器请求: GET https://mathcoding.top/numberLimit-static/css/style.css\n&nbsp; &nbsp; ↓\nNginx匹配规则:\n&nbsp; - /numberLimit-static/? 匹配! (最长前缀匹配)\n&nbsp; &nbsp; ↓\nproxy_pass转发: http://127.0.0.1:5001/numberLimit-static/css/style.css\n&nbsp; &nbsp; ↓\nFlask处理:\n&nbsp; - 路由 /numberLimit-static/* 由 static_url_path 处理\n&nbsp; - 映射到文件系统: static/css/style.css\n&nbsp; &nbsp; ↓\n返回正确的CSS文件 ✅\n</code></pre>\n<h2 id=\"关键技术细节\">关键技术细节</h2>\n<h3 id=\"proxy_pass尾斜杠的作用\">proxy_pass尾斜杠的作用</h3>\n<pre><code class=\"language-nginx\"># ✅ 正确：带尾斜杠，进行路径替换\nproxy_pass http://127.0.0.1:5001/numberLimit-static/;\n# 请求 /numberLimit-static/css/style.css\n# 转发 http://127.0.0.1:5001/numberLimit-static/css/style.css\n# ❌ 错误：不带尾斜杠，拼接完整路径\nproxy_pass http://127.0.0.1:5001/numberLimit-static;\n# 请求 /numberLimit-static/css/style.css\n# 转发 http://127.0.0.1:5001/numberLimit-static/numberLimit-static/css/style.css\n</code></pre>\n<p><strong>原理</strong>：</p>\n<ul>\n<li>有尾斜杠：Nginx会用 <code>proxy_pass</code> 的路径<strong>替换</strong> <code>location</code> 匹配的部分</li>\n<li>无尾斜杠：Nginx会直接<strong>拼接</strong>完整的请求URI</li>\n</ul>\n<h3 id=\"location匹配优先级\">location匹配优先级</h3>\n<p>Nginx的location匹配规则（按优先级从高到低）：</p>\n<ol>\n<li>精确匹配 <code>location = /path</code></li>\n<li>正则匹配 <code>location ~ /pattern</code> 或 <code>location ~* /pattern</code></li>\n<li>前缀匹配（最长优先）<code>location /path</code><br />\n在本方案中：</li>\n</ol>\n<ul>\n<li><code>/numberLimit-static/</code> 长度19，比 <code>/</code> 更具体，优先匹配</li>\n<li><code>/numberLimit</code> 长度13，比 <code>/</code> 更具体，优先匹配</li>\n<li><code>/</code> 长度1，作为兜底，匹配所有其他请求<br />\n<strong>验证方法</strong>：</li>\n</ul>\n<pre><code class=\"language-bash\"># 测试Nginx配置\nnginx -t\n# 查看实际匹配的location（需要开启debug日志）\ntail -f /var/log/nginx/error.log | grep location\n</code></pre>\n<h2 id=\"更好的长期方案子域名\">更好的长期方案：子域名</h2>\n<p>当前的 <code>static_url_path</code> 方案是路径前缀部署下的权宜之计。<strong>最佳实践是为每个服务分配独立的子域名</strong>，这样可以从根本上解决路径冲突问题。</p>\n<h3 id=\"子域名方案示例\">子域名方案示例</h3>\n<pre><code class=\"language-nginx\"># 限流服务 - 独立子域名\nserver {\n&nbsp; &nbsp; server_name numberlimit.mathcoding.top;\n&nbsp; &nbsp;\n&nbsp; &nbsp; location / {\n&nbsp; &nbsp; &nbsp; &nbsp; proxy_pass http://127.0.0.1:5001;\n&nbsp; &nbsp; &nbsp; &nbsp; # proxy配置...\n&nbsp; &nbsp; }\n}\n# 主服务\nserver {\n&nbsp; &nbsp; server_name mathcoding.top www.mathcoding.top;\n&nbsp; &nbsp;\n&nbsp; &nbsp; location / {\n&nbsp; &nbsp; &nbsp; &nbsp; proxy_pass http://127.0.0.1:5000;\n&nbsp; &nbsp; &nbsp; &nbsp; # proxy配置...\n&nbsp; &nbsp; }\n}\n</code></pre>\n<p>Flask恢复默认配置：</p>\n<pre><code class=\"language-python\">app = Flask(__name__) &nbsp;# 无需设置static_url_path\n</code></pre>\n<p><strong>优势</strong>：</p>\n<ul>\n<li>每个服务有完全独立的URL路径空间</li>\n<li>无需任何特殊的静态资源配置</li>\n<li>更符合微服务架构理念</li>\n<li>便于服务独立扩展和迁移</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<h3 id=\"问题本质\">问题本质</h3>\n<p>多个服务共享同一个URL路径空间，Flask生成的静态资源路径是绝对路径（<code>/static/...</code>），导致不同服务的静态资源被路由到错误的后端服务。</p>\n<h3 id=\"解决方案核心\">解决方案核心</h3>\n<p>为每个服务分配独立的静态资源URL前缀，通过Flask的 <code>static_url_path</code> 参数配合Nginx的location路由实现路径隔离。</p>\n<h3 id=\"关键配置\">关键配置</h3>\n<ol>\n<li><strong>Flask侧</strong>：<code>app = Flask(__name__, static_url_path=\"/服务名-static\")</code></li>\n<li><strong>Nginx侧</strong>：添加对应的 <code>location /服务名-static/</code> 规则</li>\n<li><strong>注意点</strong>：<code>proxy_pass</code> 末尾的斜杠会影响路径转换</li>\n</ol>\n<h3 id=\"适用场景\">适用场景</h3>\n<ul>\n<li>多个Web应用共享一个域名</li>\n<li>使用路径前缀区分不同服务（如 <code>/app1</code>、<code>/app2</code>）</li>\n<li>需要快速部署，暂时无法使用子域名</li>\n</ul>\n<h3 id=\"长期建议\">长期建议</h3>\n<p>当业务稳定后，建议迁移到子域名方案（如 <code>app1.example.com</code>、<code>app2.example.com</code>），从架构上彻底解决路径冲突问题。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 22:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yudaxia\">yupenglei</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第二周：词嵌入（四）分层 softmax 和负采样",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19519181",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19519181\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 22:28\">\n    <span>吴恩达深度学习课程五：自然语言处理  第二周：词嵌入（四）分层 softmax 和负采样</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第二周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=169\" rel=\"noopener nofollow\" target=\"_blank\">2.7</a>的内容以及一些相关知识的补充。</p>\n<hr />\n<p>本周为第五课的第二周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本周的内容关于词嵌入，是一种<strong>相对于独热编码，更能保留语义信息的文本编码方式</strong>。通过词嵌入，模型不再只是“记住”词本身，而是能够<strong>基于语义关系进行泛化</strong>，在一定程度上实现类似“<strong>举一反三</strong>”的效果。词嵌入是 NLP 领域中最重要的基础技术之一。</p>\n<p>本篇的内容关于<strong>分层 softmax 和负采样</strong>，是用来提升词嵌入模型训练效率，节省计算开销的技术。</p>\n<h1 id=\"1-分层-softmax\">1. 分层 softmax</h1>\n<p>在上一篇介绍 <a href=\"https://www.cnblogs.com/Goblinscholar/p/19504549\" target=\"_blank\">Word2Vec</a> 的时候，我们默认使用的是<strong>标准 softmax</strong> 来计算输出层的概率分布。但如果稍微停下来仔细想一想，就会立刻意识到一个问题：<strong>在大词表场景下，标准 softmax 几乎是不可用的。</strong></p>\n<p>下面我们分点来展开标准 softmax 在词嵌入中的局限和分层 softmax 的思想：</p>\n<h2 id=\"11-标准-softmax-的计算开销\">1.1 标准 softmax 的计算开销</h2>\n<p>在之前的示例中，我们反复强调过一点：<strong>输出层的神经元个数与词典大小完全一致</strong>。<br />\n这是因为，在 Word2Vec 的建模视角下，预测过程本质上可以被看作一个<strong>单标签分类问题</strong>：</p>\n<ul>\n<li>目标词对应“正确类别”</li>\n<li>词表中其余所有词都对应“错误类别”</li>\n</ul>\n<p>因此，我们需要通过 softmax 将模型输出映射为一个<strong>对整个词表的概率分布</strong>，并在反向传播阶段不断<strong>强化正确预测、抑制错误预测</strong>。</p>\n<p>从建模逻辑上看，这一过程是完全合理的，但真正的问题，并不出在“对不对”，而是“能不能实现”。</p>\n<p>我们知道，在 NLP 任务中，如果希望模型具备更强的泛化能力，第一步往往就是<strong>扩大语料规模</strong>，进而构建更大的词典。<br />\n而当我们希望模型在现实场景中“真正好用”时，其性能指标往往需要不断逼近，甚至尝试超越我们之前介绍过的<a href=\"https://www.cnblogs.com/Goblinscholar/p/19274215\" target=\"_blank\">贝叶斯最优错误率</a>。<br />\n在这个意义上，词典规模并不是一个可有可无的工程参数，而是模型能力的<strong>硬上限</strong>。</p>\n<p>一个直观的类比就是：<strong>人类的大脑究竟“记住”了多少词？</strong> 显然，这绝不是一个可以用“几千”或“几万”来描述的数量级。</p>\n<p>问题也正是在这里开始显现的：对于一次标准 softmax 计算而言，如果词表大小为 <span class=\"math inline\">\\(|V|\\)</span>，那么模型在输出层需要完成的操作包括：</p>\n<ol>\n<li>对 <strong><span class=\"math inline\">\\(|V|\\)</span> 个词向量</strong> 分别计算内积。</li>\n<li>对 <strong><span class=\"math inline\">\\(|V|\\)</span> 个得分</strong> 进行指数运算。</li>\n<li>对所有结果求和并完成归一化。</li>\n</ol>\n<p>其计算形式可以写成：</p>\n<p></p><div class=\"math display\">\\[P(w_o \\mid w_c)=\n\n\\frac{\\exp(\\mathbf{u}_{w_o}^\\top \\mathbf{v}_{w_c})}  \n{\\sum_{w \\in V} \\exp(\\mathbf{u}_w^\\top \\mathbf{v}_{w_c})}  \n\\]</div><p></p><p>注意，这里省略了 softmax 输出层的偏置项，在 Word2Vec 的实际建模与实现中，该偏置对词向量语义结构的影响通常可以忽略，这是很简单的道理：<strong>我们需要刻画向量间的距离关系，而偏置带来的整体平移显然是没有意义的。</strong></p>\n<p>回到正题，也就是说，<strong>哪怕我们只关心一个目标词的概率</strong>， 模型仍然必须对<strong>整个词表中的所有词</strong>各计算一遍打分。</p>\n<p>因此，每一个训练样本在输出层的<strong>计算复杂度都是：<span class=\"math inline\">\\(O(|V|)\\)</span>。</strong><br />\n当 <span class=\"math inline\">\\(|V|\\)</span> 只有几千时，这个代价尚可接受，但一旦词典规模达到几十万、甚至上百万级别，这一步计算就会迅速成为训练过程中的主要瓶颈。<br />\n换句话说，<strong>标准 softmax 的计算成本与词表规模线性相关</strong>，这一性质在大词表场景下是无法回避的。<br />\n用我们之前的内容来类比一下：<strong>你见过几百万类别的分类模型吗？</strong><br />\n也正是在这样的背景下，我们不得不思考新的问题： <strong>可不可以在不显式遍历整个词表的前提下，完成对目标词的有效建模？</strong><br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260122222725445-514225875.png\" /><br />\n于是，Word2Vec 提出了第一种加速策略：<strong>分层 softmax</strong>。</p>\n<h2 id=\"12-哈夫曼树\">1.2 哈夫曼树</h2>\n<p>哈夫曼是其实是数据结构里的内容，我们看看它在分层softmax中实现的效果。</p>\n<p>哈夫曼树最早被用于<strong>无损数据压缩</strong>，其核心思想可以概括为一句话：<strong>出现频率越高的符号，编码越短；出现频率越低的符号，编码越长。</strong> 通过这种方式，<strong>高频符号拥有更短的路径长度</strong>，从而在整体意义下最小化编码的期望长度。</p>\n<p>在 分层softmax 中，并没有使用其压缩编码的逻辑，而是重点利用哈夫曼树中<strong>高频符号拥有更短的路径长度</strong>的特点来组织词表并优化传播逻辑，它的过程如下：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260122222708870-226555105.png\" /></p>\n<p>再具体来说，Word2Vec 的分层 softmax 将词表组织成哈夫曼树的步骤如下：</p>\n<ol>\n<li><strong>统计词频</strong>：首先对语料库中的每个词计算出现频率，频率越高的词表示越常见，也就越可能在训练中被访问多次。</li>\n<li><strong>构建哈夫曼树</strong>：\n<ul>\n<li>将每个词作为叶子节点，节点权重 = 词频；</li>\n<li>从最小权重的两个节点开始合并，生成新的父节点，权重为子节点权重之和；</li>\n<li>重复此过程，直到只剩下根节点。<br />\n通过这种方式，高频词自然靠近根节点，低频词靠近叶子，从而保证<strong>频繁访问的词路径短</strong>。</li>\n</ul>\n</li>\n<li><strong>路径作为概率计算序列</strong>：\n<ul>\n<li>每条从根到叶子的路径对应一次概率计算的序列：每个节点上的选择可以看作一次二分类（是否沿左/右分支走）。</li>\n<li>目标词的概率 = 路径上所有二分类概率的乘积。</li>\n</ul>\n</li>\n<li><strong>降低训练开销</strong>：\n<ul>\n<li>高频词路径短 → 更新梯度的节点少 → 每次训练样本计算量小。</li>\n<li>低频词路径长 → 虽然节点多，但训练中出现频率低，对整体训练开销影响小。</li>\n<li>整体而言，<strong>平均计算复杂度从 <span class=\"math inline\">\\(O(|V|)\\)</span> 降到 <span class=\"math inline\">\\(O(\\log |V|)\\)</span></strong>，极大提升了大词表场景下的训练效率。</li>\n</ul>\n</li>\n</ol>\n<p>只看到这里，可能还是有些模糊，我们以 CBOW 为例，来看看使用分层 softmax 的整体网络结构和传播过程。</p>\n<h2 id=\"13--cbow-中的分层-softmax\">1.3  CBOW 中的分层 softmax</h2>\n<p><img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260122222724875-338795043.png\" /><br />\n这样，最终效果是：一<strong>个原本包含几百万类别的输出问题，被分解成了一系列二分类问题。</strong><br />\n在每次训练时，网络只需更新目标词路径上的相关节点参数，而不必触及整个输出层，从而大幅节省计算开销。<br />\n同时，由于哈夫曼树天然按照词频组织，高频词位于靠近根节点的路径上，使得这些词的更新路径更短、访问更快。这不仅加速了高频词的学习，也让整体训练过程更加高效。</p>\n<p>这便是分层 softmax 的原理，如果从实际应用上来说，你也可以叫它”堆叠 sigmoid“，而 CBOW 便常常和分层 softmax  搭配使用。</p>\n<p>下面我们便来看看另一种加速策略：负采样。</p>\n<h1 id=\"2-负采样negative-sampling\">2. 负采样（Negative Sampling）</h1>\n<p>如果说分层 softmax 是一种<strong>结构层面的加速</strong>，那么负采样更像是一种<strong>从目标函数层面“改问题”的方法</strong>。<br />\n它的出发点非常直接：<strong>我们真的有必要在训练时区分“目标词”和“所有非目标词”吗？</strong><br />\n答案是：<strong>不需要</strong>。<br />\n相较于分层 softmax，负采样的思想更加朴素、实现也更加简单。在实际工程中，它几乎可以看作是 <strong>Skip-gram 的默认搭档</strong>，也是 Word2Vec 最常被使用的训练方式之一。</p>\n<p>负采样的核心思想可以概括为一句话：<strong>只挑选少量负样本进行训练，而非遍历整个词表</strong>。换句话说，我们只关心“正确词 + 一些随机挑选的错误词”，其他的全体词不参与计算。<br />\n这样，计算量从 <span class=\"math inline\">\\(O(|V|)\\)</span> 直接降到了 <span class=\"math inline\">\\(O(k)\\)</span>，其中 <span class=\"math inline\">\\(k\\)</span> 是负样本的数量（通常 <span class=\"math inline\">\\(5 \\sim 20\\)</span>）。</p>\n<p>我们以 Skip-gram 为例来演示负采样的原理：</p>\n<h2 id=\"21-确定正负样本\">2.1 确定正负样本</h2>\n<p>使用负采样的第一步是确定正负样本，这一过程同样容易理解，来看看：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260122222401494-1883957489.png\" /><br />\n其中：</p>\n<ul>\n<li><strong>正样本</strong>：由真实语料中出现的上下文词构成；</li>\n<li><strong>负样本</strong>：从词表中随机抽取，但并不出现在当前上下文中的词。</li>\n<li></li>\n</ul>\n<p>这里展开一点，对于负样本的采样，我们常常使用下面这个公式：</p>\n<p></p><div class=\"math display\">\\[P(w) \\propto U(w)^{3/4}\n\\]</div><p></p><ul>\n<li><span class=\"math inline\">\\(P(w)\\)</span>：表示<strong>在负采样中抽到词 <span class=\"math inline\">\\(w\\)</span> 的概率</strong>。</li>\n<li><span class=\"math inline\">\\(U(w)\\)</span>：表示词 <span class=\"math inline\">\\(w\\)</span> 在整个语料库中的<strong>出现频率</strong>。</li>\n<li><span class=\"math inline\">\\(\\propto\\)</span>：表示“<strong>与……成正比</strong>”，意思是我们先按这个规则给每个词一个权重，再归一化成概率。</li>\n</ul>\n<p>语言描述就是：先算每个词的词频的四分之三次方，然后把它们除以所有词的词频的四分之三次方 之和，就得到最终抽样概率 <span class=\"math inline\">\\(P(w)\\)</span>：</p>\n<p></p><div class=\"math display\">\\[P(w) = \\frac{U(w)^{3/4}}{\\sum_{w' \\in V} U(w')^{3/4}}  \n\\]</div><p></p><p>这个公式实际上做的是这样的工作：</p>\n<ol>\n<li>对高频词做了<strong>降权</strong>（比原始词频低一些），减少它们在负样本中出现的概率。</li>\n<li>对低频词做了<strong>相对提升</strong>（比直接按词频高一些），让它们有机会被采样到。</li>\n</ol>\n<p>这种采样策略在实践中被证明可以提高词向量训练的稳定性和语义表达能力。<br />\n完成了数据准备后，现在，就来看看 Skip-gram  中的负采样。</p>\n<h2 id=\"22-skip-gram-中的负采样\">2.2 Skip-gram 中的负采样</h2>\n<p>在 Skip-gram + 负采样 框架下，一次训练的传播过程可以概括为下图所示：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260122222708411-1201982967.png\" /></p>\n<p>这种思路其实很容易理解：<strong>在一次传播中，我不再一次更新输出层的所有参数，而是只计算我提前挑选好的一些样本，只更新它们相关的参数，来节省计算开销，剩下的等下次选中再更新。</strong></p>\n<p>最终，模型仅更新正样本和 <span class=\"math inline\">\\(k\\)</span> 个负样本对应的输出层参数以及输入词向量，其余词的向量完全不参与更新，从而节省了大量计算，实现 <span class=\"math inline\">\\(O(k)\\)</span> 的复杂度，远小于 <span class=\"math inline\">\\(O(|V|)\\)</span>。<br />\n这种“只更新被选中参数”的训练方式，使得<strong>负采样在大规模语料与超大词表场景下，具备极高的计算效率。</strong></p>\n<p>你会发现，负采样和分层 softmax 的一点共同逻辑就是<strong>把一次多分类拆成了多次二分类</strong>，这同样是我们可以学习的优化思路。</p>\n<h1 id=\"3总结\">3.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>softmax大词表瓶颈</td>\n<td>softmax 的计算与反向传播都必须遍历整个词表，词表越大，训练越慢，成为主要性能瓶颈</td>\n<td>在问路时，必须<strong>问完全国所有居民</strong></td>\n</tr>\n<tr>\n<td>分层 softmax</td>\n<td>用哈夫曼树将多分类问题拆成<strong>一条从根到叶的二分类决策路径</strong>，目标词概率等于路径上各二分类概率的乘积</td>\n<td>在<strong>每个路口选择方向</strong>，而不是一次问遍所有人。</td>\n</tr>\n<tr>\n<td>分层 softmax +CBOW</td>\n<td>每次训练只更新目标词路径上的节点参数，其余词完全不参与计算</td>\n<td>只维修<strong>你真正经过的路口</strong>，而不是重修整座城市。</td>\n</tr>\n<tr>\n<td>负采样（Negative Sampling）</td>\n<td>不再逼模型区分“目标词 vs 全词表”，而是区分“目标词 vs 少量噪声词”，复杂度为 <span class=\"math inline\">\\(O(k)\\)</span></td>\n<td>不用认清所有陌生人，只要确认<strong>朋友和几名路人</strong></td>\n</tr>\n<tr>\n<td>正负样本构造</td>\n<td>正样本来自真实上下文；负样本从词表随机抽取但不在上下文中</td>\n<td>真朋友 vs <strong>随机拉来的假熟人</strong></td>\n</tr>\n<tr>\n<td><span class=\"math inline\">\\(U(w)^{3/4}\\)</span> 采样分布</td>\n<td>对高频词降权、对低频词相对提升，使负样本更有信息量</td>\n<td>热门明星<strong>少出现点</strong>，路人<strong>多给点镜头</strong></td>\n</tr>\n<tr>\n<td>Skip-gram + 负采样</td>\n<td>每次仅更新中心词、正样本词和 <span class=\"math inline\">\\(k\\)</span> 个负样本的向量，其余参数不动</td>\n<td>只训练<strong>被点名的几个人</strong>，其他人下次再说</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 22:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">6</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI开发-python-langchain框架（1-4动态少样本提示）",
      "link": "https://www.cnblogs.com/yclh/p/19518845",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yclh/p/19518845\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 19:31\">\n    <span>AI开发-python-langchain框架（1-4动态少样本提示）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"qwen-markdown-paragraph\"><span class=\"qwen-markdown-text\">这个代码的核心功能是：<strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">基于输入词的长度动态选择反义词示例，并调用大模型生成反义词</span></strong><span class=\"qwen-markdown-text\">，体现了 <strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">“动态少样本提示（Dynamic Few-Shot Prompting）”</span></strong><span class=\"qwen-markdown-text\"> 与 <strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">“上下文长度感知的示例选择”</span></strong><span class=\"qwen-markdown-text\"> 的能力。</span></span></span></span></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">from langchain.prompts import FewShotPromptTemplate, PromptTemplate\nfrom langchain.prompts.example_selector import LengthBasedExampleSelector\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain_openai import ChatOpenAI\nimport os\nfrom dotenv import load_dotenv\n\n\n# 定义反义词任务的示例数据集（few-shot examples）\n# 每个示例包含一个输入词（input）和对应的反义词（output）\nexamples = [\n    {\"input\": \"开心\", \"output\": \"伤心\"},\n    {\"input\": \"高\", \"output\": \"矮\"},\n    {\"input\": \"精力充沛\", \"output\": \"没精打采\"},\n    {\"input\": \"粗\", \"output\": \"细\"},\n]\n\n# 定义单个示例的格式模板\n# 使用 {input} 和 {output} 作为占位符，用于后续填充具体值\nexample_prompt = PromptTemplate(\n    input_variables=[\"input\", \"output\"],  # 声明模板中使用的变量名\n    template=\"Input: {input}\\nOutput: {output}\",  # 示例的文本格式\n)\n\n# 创建一个基于长度的示例选择器（LengthBasedExampleSelector）\n# 作用：根据输入提示的总长度动态选择最合适的示例数量，避免超出模型上下文限制\nexample_selector = LengthBasedExampleSelector(\n    examples=examples,  # 提供所有候选示例\n    example_prompt=example_prompt,  # 用于格式化每个示例的模板\n    max_length=25,  # 设定整个 prompt（含前缀、示例、后缀）的最大 token 长度（此处为字符数近似）\n    # 注意：LengthBasedExampleSelector 默认使用 len(text) 计算长度（非精确 token 数），适用于简单场景\n)\n\n# 构建动态少样本提示模板（FewShotPromptTemplate）\n# 它会根据输入内容的长度，自动从 examples 中选择合适数量的示例插入到 prompt 中\ndynamic_prompt = FewShotPromptTemplate(\n    example_selector=example_selector,  # 使用上面定义的动态选择器（而非固定示例列表）\n    example_prompt=example_prompt,      # 单个示例的格式\n    prefix=\"给出每个输入的反义词\",       # 提示的开头部分（任务指令）\n    suffix=\"Input: {adjective}\\nOutput:\",  # 提示的结尾部分，包含待预测的输入占位符\n    input_variables=[\"adjective\"],      # 声明最终用户输入的变量名（与 suffix 中的 {adjective} 对应）\n)\n\n# === 测试 1：输入较短，应选择多个示例 ===\nprint(\"【测试1】输入较短，选择多个示例：\")\nprint(dynamic_prompt.format(adjective=\"big\"))\n\nprint('------------')\n\n# === 测试 2：输入很长，应只选择少量或一个示例以控制总长度 ===\nlong_string = \"big and huge and massive and large and gigantic and tall and much much much much much bigger than everything else\"\nprint(\"【测试2】输入很长，仅选择一个示例：\")\nprint(dynamic_prompt.format(adjective=long_string))\n\nprint('------------')\n\n# === 测试 3：动态添加新示例 ===\n# 向示例选择器中新增一个示例（\"胖\" -&gt; \"瘦\"）\nnew_example = {\"input\": \"胖\", \"output\": \"瘦\"}\ndynamic_prompt.example_selector.add_example(new_example)\nprint(\"【测试3】添加新示例后，查询'热情'：\")\nprint(dynamic_prompt.format(adjective=\"热情\"))\n\nprint('------------')\n\n# === 配置并调用 DeepSeek 大语言模型 ===\n\nllm = ChatOpenAI(\n    api_key=os.getenv(\"DEEPSEEK_API_KEY\"),\n    base_url=os.getenv(\"DEEP_URL\"),  # Deepseek 的 API 基础地址\n    model=\"deepseek-v3:671b\",  # Deepseek 对话模型（可选：deepseek-chat-pro 等高级模型）\n    temperature=0.7,  # 温度参数（0-1，越低越稳定）\n    max_tokens=1024  # 最大生成 tokens\n)\n\n# 创建字符串输出解析器，用于将模型返回的 AIMessage 转换为纯文本\noutput_parser = StrOutputParser()\n\n# 构建处理链（Chain）：prompt → LLM → output parser\n# 使用 LangChain 的管道操作符 `|` 连接各组件\nchain = dynamic_prompt | llm | output_parser\n\n# 调用链，传入输入变量 {\"adjective\": \"热情\"}\n# 注意：chain.invoke() 内部已包含 llm 调用和 output_parser 解析，无需再手动调用 output_parser\nmessage = chain.invoke({\"adjective\": \"热情\"})\n\n# ⚠️ 注意：上一行 `chain.invoke()` 已经返回了字符串（因为最后是 StrOutputParser）\n# 所以下面这行是多余的，甚至会导致错误（因为 message 已是 str，不能再次 invoke）\n# result = output_parser.invoke(message)  # ❌ 错误：message 是 str，不是 AIMessage\n\n# 正确做法：直接使用 message 作为结果\nresult = message\n\nprint('###############')\nprint(\"【模型输出】\")\nprint(result)\n</pre>\n</div>\n<h1>输出结果：</h1>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">【测试1】输入较短，选择多个示例：\n给出每个输入的反义词\n\nInput: 开心\nOutput: 伤心\n\nInput: 高\nOutput: 矮\n\nInput: 精力充沛\nOutput: 没精打采\n\nInput: 粗\nOutput: 细\n\nInput: big\nOutput:\n------------\n【测试2】输入很长，仅选择一个示例：\n给出每个输入的反义词\n\nInput: 开心\nOutput: 伤心\n\nInput: big and huge and massive and large and gigantic and tall and much much much much much bigger than everything else\nOutput:\n------------\n【测试3】添加新示例后，查询'热情'：\n给出每个输入的反义词\n\nInput: 开心\nOutput: 伤心\n\nInput: 高\nOutput: 矮\n\nInput: 精力充沛\nOutput: 没精打采\n\nInput: 粗\nOutput: 细\n\nInput: 胖\nOutput: 瘦\n\nInput: 热情\nOutput:\n------------\n###############\n【模型输出】\n冷淡\n</pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1>&nbsp;</h1>\n<h1>核心要点总结</h1>\n<div>&nbsp;</div>\n<div>这段代码是基于 LangChain 框架对接 DeepSeek 大模型，实现「动态少样本（Few-Shot）反义词生成」的完整案例，核心解决「固定示例易超出模型上下文长度」的问题，通过动态示例选择器适配不同长度输入，同时结合 LangChain 链式调用简化模型调用流程，先明确整体定位，再拆解核心重点：</div>\n<div>&nbsp;</div>\n<h2>一、整体流程概览（核心逻辑链）</h2>\n<div>&nbsp;</div>\n<div>代码遵循 LangChain 「示例准备 → 动态提示构建 → 模型调用 → 结果解析」的少样本学习经典流程，整体可概括为：</div>\n<div>\n<div dir=\"ltr\">\n<div>\n<pre><code>1. 定义反义词任务的固定示例数据集，为模型提供参考案例\n2. 配置基于长度的示例选择器，根据输入文本长度动态筛选示例数量\n3. 构建动态少样本提示模板，自动适配输入长度生成合规 Prompt\n4. 初始化 DeepSeek 模型客户端，配置核心调用参数\n5. 构建「提示模板 → 大模型 → 输出解析」的链式调用流程\n6. 调用链条完成反义词生成，并输出纯文本结果\n</code></pre>\n</div>\n<div>&nbsp;</div>\n</div>\n</div>\n<div>&nbsp;</div>\n<h2>二、核心重点拆解（必掌握）</h2>\n<div>&nbsp;</div>\n<h3>1. 少样本提示（Few-Shot Prompt）核心组件</h3>\n<div>&nbsp;</div>\n<div>这是实现「模型参考示例生成结果」的基础，也是 LangChain 提示工程的核心用法：</div>\n<div>&nbsp;</div>\n<div>&nbsp; &nbsp;<code>- 示例数据集（examples）：以键值对形式存储「输入-输出」示例，为模型提供任务参考（如\"开心\"→\"伤心\"）；</code></div>\n<div><code> - 单示例模板（example_prompt）：定义单个示例的文本格式（Input/Output 固定样式），统一示例展示形式；</code></div>\n<div>\n<div dir=\"ltr\">\n<div>\n<pre><code>- 动态少样本模板（FewShotPromptTemplate）：整合示例选择器、单示例模板、前缀/后缀，生成最终发给模型的完整 Prompt；\n  - prefix：任务指令（\"给出每个输入的反义词\"），明确模型要执行的任务；\n  - suffix：待填充的用户输入占位符，承接动态输入内容。\n</code></pre>\n</div>\n</div>\n</div>\n<h3>2. 动态示例选择器（LengthBasedExampleSelector）</h3>\n<div>&nbsp;</div>\n<div>这是代码的核心亮点，解决「固定示例数量易超上下文长度」的问题：</div>\n<div>\n<div dir=\"ltr\">\n<div>\n<pre><code>核心作用：根据输入文本的长度，自动计算并选择合适数量的示例（输入越长，选的示例越少），避免 Prompt 总长度超出模型上下文限制；\n关键参数：\n  - examples：候选示例列表；\n  - example_prompt：示例格式化模板（用于计算单示例长度）；\n  - max_length：Prompt 允许的最大长度（此处为字符数近似值）。\n</code></pre>\n</div>\n<div>&nbsp;</div>\n</div>\n</div>\n<div>&nbsp;</div>\n<h3>3. LangChain 链式调用（| 操作符）</h3>\n<div>&nbsp;</div>\n<div>简化多组件协作流程，是 LangChain 核心设计理念：</div>\n<div>\n<div dir=\"ltr\">\n<div>\n<pre><code>- 链条构成：dynamic_prompt（生成 Prompt） | llm（调用模型） | output_parser（解析结果）；\n- 核心优势：无需手动分步调用（先格式化 Prompt、再调用模型、最后解析结果），一行代码完成全流程；\n- 调用方式：chain.invoke({\"adjective\": \"热情\"}) 传入输入变量，直接返回解析后的纯文本结果。\n</code></pre>\n</div>\n<div>&nbsp;</div>\n</div>\n</div>\n<div>&nbsp;</div>\n<h3>4. 输出解析器（StrOutputParser）</h3>\n<div>&nbsp;</div>\n<div>解决「模型返回 AIMessage 对象→提取纯文本」的问题：</div>\n<div>\n<div dir=\"ltr\">\n<div>\n<pre><code>核心作用：将 LangChain 模型返回的 AIMessage 类型（含 content/metadata 等字段）转换为纯字符串，简化结果使用；\n关键注意点：链式调用中已包含解析步骤，无需手动再次调用 output_parser.invoke()（否则会报错）。</code></pre>\n</div>\n</div>\n</div>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 19:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yclh\">万笑佛</a>&nbsp;\n阅读(<span id=\"post_view_count\">25</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "玩转 ZooKeeper",
      "link": "https://www.cnblogs.com/Marktowin/p/19518265",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Marktowin/p/19518265\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 17:22\">\n    <span>玩转 ZooKeeper</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p dir=\"auto\">Apache ZooKeeper 是一个开源的分布式协调服务，用于分布式系统中维护配置信息、命名、提供分布式同步和组服务。下面根据您的要求，详细说明 ZooKeeper 的产生原因、最初使用、最新的使用、不同版本的更新点、实现原理、部署和使用。内容基于官方文档和可靠来源整理，并包含 Java 代码片段示例（ZooKeeper 主要使用 Java API）。</p>\n<p dir=\"auto\">&nbsp;</p>\n<h3 dir=\"auto\">1. 产生原因</h3>\n<p dir=\"auto\">ZooKeeper 的产生是为了解决分布式系统中协调的复杂问题。在大规模分布式系统中，多个节点需要协调配置、状态同步、领导者选举等任务，但自行实现这些功能容易引入错误，如竞争条件（race conditions）和死锁（deadlock）。ZooKeeper 受 Google 的 Chubby lock service 启发，由 Yahoo! Research 团队开发，用于简化这些协调任务。它提供了一个可靠的、高性能的协调内核，让应用程序开发者专注于业务逻辑，而非重新发明分布式协调机制。最初是为了管理 Yahoo! 的大数据集群而创建，将状态存储在本地日志文件中，确保高可用性和一致性。</p>\n<p dir=\"auto\">&nbsp;</p>\n<h3 dir=\"auto\">2. 早期使用</h3>\n<p dir=\"auto\">ZooKeeper 最初在 Yahoo! 内部用于工业级应用，包括：</p>\n<ul dir=\"auto\">\n<li><strong>Yahoo! Message Broker</strong>：协调和故障恢复服务，用于管理数千个主题的可扩展发布-订阅系统。</li>\n<li><strong>Yahoo! Crawler 的 Fetching Service</strong>：用于故障恢复，确保爬虫任务的可靠执行。</li>\n<li><strong>Yahoo! 广告系统</strong>：提供可靠的服务协调，如命名服务、配置管理和数据同步。 典型早期用例包括命名服务（类似 DNS）、配置管理（集中存储配置）、数据同步（锁机制）、领导者选举（选主）和消息队列。ZooKeeper 被设计为读主导型（读写比约 10:1），适用于运行在数千台机器上的分布式环境。</li>\n</ul>\n<p>&nbsp;</p>\n<h3 dir=\"auto\">3. 当前使用</h3>\n<p dir=\"auto\">如今，ZooKeeper 广泛用于大数据和分布式系统中，作为协调内核。常见用例包括：</p>\n<ul dir=\"auto\">\n<li><strong>配置管理</strong>：集中存储和更新分布式应用的配置（如 Apache Kafka 用于存储消费者偏移量，直到 4.0 版本）。</li>\n<li><strong>领导者选举</strong>：在集群中选举主节点（如 Apache HBase 用于区域分配和主故障转移）。</li>\n<li><strong>分布式锁</strong>：实现互斥访问（如 Apache Accumulo 用于无单点故障架构）。</li>\n<li><strong>组成员管理</strong>：跟踪节点加入/离开（如 Apache Druid 用于集群状态管理）。</li>\n<li><strong>其他</strong>：用于 Apache Hadoop、HDFS、Solr、Kafka（早期版本）、Pulsar 等。最新趋势包括减少对 ZooKeeper 的依赖（如 Pulsar 通过 PIP-45 引入可插拔元数据框架，允许无 ZooKeeper 运行），但在传统系统中仍不可或缺。现代应用强调其在云环境中的高可用性，如在 Kubernetes 中协调微服务。</li>\n</ul>\n<p>&nbsp;</p>\n<h3 dir=\"auto\">4. 不同版本</h3>\n<p dir=\"auto\">ZooKeeper 的版本演进聚焦于性能、安全、兼容性和新功能。以下表格总结从 3.4.x 开始的主要版本更新（基于官方发布笔记，当前稳定版 3.8.x，当前版 3.9.x）。EoL（End-of-Life）版本不再接收社区支持。</p>\n<table>\n<thead>\n<tr><th>版本系列</th><th>首次发布日期</th><th>EoL 日期</th><th>主要更新点</th></tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>3.4.x</strong></td>\n<td>2011 年</td>\n<td>2016 年</td>\n<td>基础稳定版；支持基本 API、复制模式；性能优化；用于 Hadoop 子项目。</td>\n</tr>\n<tr>\n<td><strong>3.5.x</strong></td>\n<td>2019 年 5 月 (3.5.5 作为稳定版)</td>\n<td>2022 年 6 月</td>\n<td>添加动态重配置、本地会话、容器/TTL 节点、SSL 支持原子广播协议、可移除监视器、多线程提交处理器、升级 Netty 4.1、Maven 构建；最小 JDK 1.8；修复 CVE 和兼容性问题。</td>\n</tr>\n<tr>\n<td><strong>3.6.x</strong></td>\n<td>2020 年 3 月</td>\n<td>2022 年 12 月</td>\n<td>性能和安全改进；新 API（如永久递归监视）；移除 Log4j1，使用 reload4j；修复 CVE、快照和 SASL 问题；客户端兼容 3.5.x 服务器。</td>\n</tr>\n<tr>\n<td><strong>3.7.x</strong></td>\n<td>2021 年 3 月</td>\n<td>2024 年 2 月</td>\n<td>新 API（如启动服务器、whoami）；配额强制；主机名规范化；BCKFS 密钥/信任存储；必选认证方案；多 SASL superUsers；快速跟踪节流请求；安全指标；C/Perl SASL 支持；zkSnapshotComparer 工具；YCSB 基准测试说明；修复 64+ 个问题，包括 CVE。</td>\n</tr>\n<tr>\n<td><strong>3.8.x</strong> (当前稳定)</td>\n<td>2022 年 3 月</td>\n<td>-</td>\n<td>日志框架迁移到 LogBack；从文件读取密钥/信任存储密码；恢复 OSGI 支持；减少 Prometheus 指标性能影响；JDK17 支持；第三方依赖更新修复所有 CVE；修复同步、C 客户端测试等问题。</td>\n</tr>\n<tr>\n<td><strong>3.9.x</strong> (当前)</td>\n<td>2023 年 8 月</td>\n<td>-</td>\n<td>管理员服务器 API（快照和数据流出）；通信 Zxid 触发 WatchEvent；TLS 动态加载客户端信任/密钥存储；Netty-TcNative OpenSSL 支持；SSL 支持 Zktreeutil；改进 syncRequestProcessor 性能；第三方依赖更新修复 CVE。</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">兼容性：3.5.x+ 客户端兼容 3.9.x 服务器；3.9.x 客户端兼容 3.5-3.8.x 服务器（不使用新 API）。</p>\n<p dir=\"auto\">&nbsp;</p>\n<h3 dir=\"auto\">5. 实现原理</h3>\n<p dir=\"auto\">ZooKeeper 的核心是提供一个简单、高可靠的分布式协调服务。其架构基于客户端-服务器模型，使用 ZAB（ZooKeeper Atomic Broadcast）协议（类似于 Paxos）实现一致性。</p>\n<ul dir=\"auto\">\n<li><strong>架构组件</strong>：\n<ul dir=\"auto\">\n<li><strong>Ensemble（集群）</strong>：由奇数个服务器组成（最小 3 个），确保多数派（quorum）可用。包括 Leader（领导者，处理写操作）、Follower（追随者，处理读操作并转发写到 Leader）和 Observer（观察者，只处理读，不参与选举/投票，提高读性能）。</li>\n<li><strong>数据模型</strong>：分层命名空间，像文件系统（znodes：节点，可存储数据和子节点）。支持持久节点（persistent）和临时节点（ephemeral，会话结束删除）。数据在内存中存储（高性能），并持久化到日志和快照。</li>\n<li><strong>一致性保证</strong>：顺序一致性（更新按发送顺序应用）、原子性（更新全成功或全失败）、单一系统映像（客户端无论连接哪个服务器，看到相同视图）、可靠性（更新持久化）、及时性（视图在界限内更新）。</li>\n<li><strong>工作流程</strong>：客户端连接任意服务器。写请求转发到 Leader，通过 ZAB 广播到 Follower（需多数同意）。读请求本地处理。使用监视（watches）通知变化（一次性触发，新版支持永久递归监视）。会话（sessions）通过心跳维护，断连自动重连。</li>\n<li><strong>领导者选举</strong>：使用快速 Paxos 变体，崩溃时快速选举新 Leader（&lt;200ms）。</li>\n<li><strong>性能原理</strong>：内存镜像 + 事务日志；读主导优化；原子消息协议防止副本分歧。</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">ZooKeeper 适用于读多写少场景，提供简单 API（如 create、delete、get、set）。</p>\n<p dir=\"auto\">&nbsp;</p>\n<h3 dir=\"auto\">6. 案例（选举leader执行任务）</h3>\n<p dir=\"auto\">在分布式系统中，ZooKeeper（ZK）常用于协调集群中的节点，确保高可用性和一致性。下面我给出一个详细的例子：一个简单的 <strong>分布式任务调度服务</strong>，部署在集群中，使用 ZooKeeper 实现 <strong>领导者选举（Leader Election）</strong>。这个服务模拟一个定时任务（如数据备份），但只有一个节点（Leader）执行任务，其他节点（Follower）待命。如果 Leader 宕机，Follower 会自动选举新 Leader。</p>\n<p dir=\"auto\"><strong>一个 3 节点集群的分布式任务调度服务</strong></p>\n<ul dir=\"auto\">\n<li>3 台服务器（物理机或虚拟机）：node1、node2、node3</li>\n<li>每个节点运行一个相同的 Java JAR 包</li>\n<li>使用 ZooKeeper 实现<strong>领导者选举</strong>：只有一个节点成为 Leader 执行定时任务，其他节点作为 Follower 待命</li>\n<li>Leader 宕机后，自动快速选举新 Leader</li>\n</ul>\n<p dir=\"auto\"><strong>环境准备（3 台服务器）</strong></p>\n<table>\n<thead>\n<tr><th>主机名</th><th>IP</th><th>角色</th><th>说明</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>node1</td>\n<td>192.168.1.101</td>\n<td>ZooKeeper + Java 服务</td>\n<td>ZooKeeper myid=1</td>\n</tr>\n<tr>\n<td>node2</td>\n<td>192.168.1.102</td>\n<td>ZooKeeper + Java 服务</td>\n<td>ZooKeeper myid=2</td>\n</tr>\n<tr>\n<td>node3</td>\n<td>192.168.1.103</td>\n<td>ZooKeeper + Java 服务</td>\n<td>ZooKeeper myid=3</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\"><strong>所有节点安装 Java</strong></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">sudo apt update\nsudo apt install openjdk</span>-11-jdk  # Ubuntu/<span style=\"color: rgba(0, 0, 0, 1);\">Debian# 或 CentOS\nsudo yum install java</span>-11-openjdk-devel</pre>\n</div>\n<p dir=\"auto\"><strong>所有节点安装 ZooKeeper 集群</strong></p>\n<div class=\"cnblogs_code\">\n<pre>wget https:<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">downloads.apache.org/zookeeper/zookeeper-3.8.4/apache-zookeeper-3.8.4-bin.tar.gz</span>\ntar -zxvf apache-zookeeper-3.8.4-<span style=\"color: rgba(0, 0, 0, 1);\">bin.tar.gz\nsudo mv apache</span>-zookeeper-3.8.4-bin /opt/<span style=\"color: rgba(0, 0, 0, 1);\">zookeeper\ncd </span>/opt/zookeeper</pre>\n</div>\n<p dir=\"auto\"><strong>配置 conf/zoo.cfg（所有节点都相同）</strong></p>\n<div class=\"cnblogs_code\">\n<pre>cp conf/zoo_sample.cfg conf/<span style=\"color: rgba(0, 0, 0, 1);\">zoo.cfg\nvi conf</span>/zoo.cfg</pre>\n</div>\n<p><strong>内容如下</strong></p>\n<div class=\"cnblogs_code\">\n<pre>tickTime=2000<span style=\"color: rgba(0, 0, 0, 1);\">\ninitLimit</span>=10<span style=\"color: rgba(0, 0, 0, 1);\">\nsyncLimit</span>=5<span style=\"color: rgba(0, 0, 0, 1);\">\ndataDir</span>=/var/lib/<span style=\"color: rgba(0, 0, 0, 1);\">zookeeper\nclientPort</span>=2181<span style=\"color: rgba(0, 0, 0, 1);\">\n# 集群服务器列表\nserver.</span>1=192.168.1.101:2888:3888<span style=\"color: rgba(0, 0, 0, 1);\">\nserver.</span>2=192.168.1.102:2888:3888<span style=\"color: rgba(0, 0, 0, 1);\">\nserver.</span>3=192.168.1.103:2888:3888</pre>\n</div>\n<p dir=\"auto\"><strong>创建数据目录并设置 myid（每个节点不同）：</strong></p>\n<div class=\"cnblogs_code\">\n<pre>sudo mkdir -p /var/lib/<span style=\"color: rgba(0, 0, 0, 1);\">zookeeper\nsudo chown </span>-R $USER:$USER /var/lib/zookeeper</pre>\n</div>\n<p>　　node1:</p>\n<div class=\"cnblogs_code\">\n<pre>echo \"1\" &gt; /var/lib/zookeeper/myid</pre>\n</div>\n<p>　　node2:</p>\n<div class=\"cnblogs_code\">\n<pre>echo \"2\" &gt; /var/lib/zookeeper/myid</pre>\n</div>\n<p>　　node3:</p>\n<div class=\"cnblogs_code\">\n<pre>echo \"3\" &gt; /var/lib/zookeeper/myid</pre>\n</div>\n<p dir=\"auto\"><strong>启动 ZooKeeper（所有节点）：</strong></p>\n<div class=\"cnblogs_code\">\n<pre>/opt/zookeeper/bin/zkServer.sh start</pre>\n</div>\n<p dir=\"auto\"><strong>验证集群状态：</strong></p>\n<div class=\"cnblogs_code\">\n<pre>/opt/zookeeper/bin/zkServer.sh status</pre>\n</div>\n<p dir=\"auto\">应该看到一个 Leader 和两个 Follower。</p>\n<p dir=\"auto\">&nbsp;<strong>JAVA代码</strong></p>\n<p dir=\"auto\">LeaderElection.java（领导者选举核心），处理连接 ZooKeeper、创建节点、监视变化和选举逻辑。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.example;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span> org.apache.zookeeper.*<span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.apache.zookeeper.data.Stat;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.slf4j.Logger;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.slf4j.LoggerFactory;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.io.IOException;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.Collections;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.List;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.concurrent.CountDownLatch;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> LeaderElection <span style=\"color: rgba(0, 0, 255, 1);\">implements</span><span style=\"color: rgba(0, 0, 0, 1);\"> Watcher {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">final</span> Logger logger = LoggerFactory.getLogger(LeaderElection.<span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> ZooKeeper zk;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> String zkConnectString;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> sessionTimeout;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> String electionPath;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> String nodeId;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> String currentZnodePath;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 当前节点的路径，如 /election/node-0000000001</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">private</span> CountDownLatch connectedLatch = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> CountDownLatch(1<span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> TaskService taskService;  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 任务服务引用</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">public</span> LeaderElection(String zkConnectString, <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> sessionTimeout, String electionPath, String nodeId, TaskService taskService) {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>.zkConnectString =<span style=\"color: rgba(0, 0, 0, 1);\"> zkConnectString;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>.sessionTimeout =<span style=\"color: rgba(0, 0, 0, 1);\"> sessionTimeout;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>.electionPath =<span style=\"color: rgba(0, 0, 0, 1);\"> electionPath;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>.nodeId =<span style=\"color: rgba(0, 0, 0, 1);\"> nodeId;\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span>.taskService =<span style=\"color: rgba(0, 0, 0, 1);\"> taskService;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> connect() <span style=\"color: rgba(0, 0, 255, 1);\">throws</span><span style=\"color: rgba(0, 0, 0, 1);\"> IOException, InterruptedException {\n        zk </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span> ZooKeeper(zkConnectString, sessionTimeout, <span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        connectedLatch.await();  </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 等待连接成功</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    }\n\n    @Override\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> process(WatchedEvent event) {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (event.getState() ==<span style=\"color: rgba(0, 0, 0, 1);\"> Event.KeeperState.SyncConnected) {\n            connectedLatch.countDown();\n        } </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span> <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (event.getType() ==<span style=\"color: rgba(0, 0, 0, 1);\"> Event.EventType.NodeDeleted) {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 前一个节点删除，重新检查是否成为 Leader</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                checkIfLeader();\n            } </span><span style=\"color: rgba(0, 0, 255, 1);\">catch</span> (KeeperException |<span style=\"color: rgba(0, 0, 0, 1);\"> InterruptedException e) {\n                logger.error(</span>\"Error checking leader\"<span style=\"color: rgba(0, 0, 0, 1);\">, e);\n            }\n        }\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> participateInElection() <span style=\"color: rgba(0, 0, 255, 1);\">throws</span><span style=\"color: rgba(0, 0, 0, 1);\"> KeeperException, InterruptedException {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 确保选举路径存在（持久节点）</span>\n        Stat stat = zk.exists(electionPath, <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (stat == <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n            zk.create(electionPath, </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> <span style=\"color: rgba(0, 0, 255, 1);\">byte</span>[0<span style=\"color: rgba(0, 0, 0, 1);\">], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n        }\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建临时顺序节点</span>\n        currentZnodePath = zk.create(electionPath + \"/\" + nodeId + \"-\", <span style=\"color: rgba(0, 0, 255, 1);\">new</span> <span style=\"color: rgba(0, 0, 255, 1);\">byte</span>[0<span style=\"color: rgba(0, 0, 0, 1);\">], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n        logger.info(</span>\"Created znode: {}\"<span style=\"color: rgba(0, 0, 0, 1);\">, currentZnodePath);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 检查是否是 Leader</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        checkIfLeader();\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> checkIfLeader() <span style=\"color: rgba(0, 0, 255, 1);\">throws</span><span style=\"color: rgba(0, 0, 0, 1);\"> KeeperException, InterruptedException {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取所有子节点，按序号排序</span>\n        List&lt;String&gt; children = zk.getChildren(electionPath, <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        Collections.sort(children);\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 当前节点是序号最小的，就是 Leader</span>\n        String smallestChild = children.get(0<span style=\"color: rgba(0, 0, 0, 1);\">);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (currentZnodePath.endsWith(smallestChild)) {\n            logger.info(</span>\"I am the Leader: {}\"<span style=\"color: rgba(0, 0, 0, 1);\">, currentZnodePath);\n            taskService.startTask();  </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 开始执行任务</span>\n        } <span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 监视前一个节点</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">int</span> myIndex = children.indexOf(currentZnodePath.substring(electionPath.length() + 1<span style=\"color: rgba(0, 0, 0, 1);\">));\n            String previousChild </span>= children.get(myIndex - 1<span style=\"color: rgba(0, 0, 0, 1);\">);\n            zk.exists(electionPath </span>+ \"/\" + previousChild, <span style=\"color: rgba(0, 0, 255, 1);\">this</span>);  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设置监视</span>\n            logger.info(\"I am Follower, watching: {}\"<span style=\"color: rgba(0, 0, 0, 1);\">, previousChild);\n            taskService.stopTask();  </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 停止任务（如果之前是 Leader）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        }\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> close() <span style=\"color: rgba(0, 0, 255, 1);\">throws</span><span style=\"color: rgba(0, 0, 0, 1);\"> InterruptedException {\n        zk.close();\n    }\n}</span></pre>\n</div>\n<p dir=\"auto\">TaskService.java（任务执行服务），模拟一个定时任务。只有 Leader 执行。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.example;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.slf4j.Logger;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.slf4j.LoggerFactory;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.concurrent.Executors;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.concurrent.ScheduledExecutorService;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.concurrent.TimeUnit;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> TaskService {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">final</span> Logger logger = LoggerFactory.getLogger(TaskService.<span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> ScheduledExecutorService executor;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">boolean</span> isRunning = <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> startTask() {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">isRunning) {\n            executor </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Executors.newSingleThreadScheduledExecutor();\n            executor.scheduleAtFixedRate(() </span>-&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> {\n                logger.info(</span>\"Executing task: Backup database...\");  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 模拟任务</span>\n            }, 0, 60, TimeUnit.SECONDS);  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 每分钟执行</span>\n            isRunning = <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> stopTask() {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (isRunning &amp;&amp; executor != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n            executor.shutdown();\n            isRunning </span>= <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            logger.info(</span>\"Stopped task\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        }\n    }\n}</span></pre>\n</div>\n<p dir=\"auto\">App.java（主入口）</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.example;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.io.IOException;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.Properties;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> App {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span> main(String[] args) <span style=\"color: rgba(0, 0, 255, 1);\">throws</span><span style=\"color: rgba(0, 0, 0, 1);\"> IOException, InterruptedException, Exception {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 加载配置（实际可使用 Spring 或环境变量）</span>\n        Properties props = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Properties();\n        props.load(App.</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span>.getClassLoader().getResourceAsStream(\"application.properties\"<span style=\"color: rgba(0, 0, 0, 1);\">));\n\n        String zkConnect </span>= props.getProperty(\"zk.connectString\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> sessionTimeout = Integer.parseInt(props.getProperty(\"zk.sessionTimeout\"<span style=\"color: rgba(0, 0, 0, 1);\">));\n        String electionPath </span>= props.getProperty(\"election.path\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        String nodeId </span>= props.getProperty(\"node.id\");  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 每个实例不同</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">\n        TaskService taskService </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> TaskService();\n        LeaderElection election </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> LeaderElection(zkConnect, sessionTimeout, electionPath, nodeId, taskService);\n\n        election.connect();\n        election.participateInElection();\n\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保持运行（生产中用 Spring Boot 或 while(true)）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        Thread.sleep(Long.MAX_VALUE);\n\n        election.close();\n    }\n}</span></pre>\n</div>\n<p dir=\"auto\">application.properties</p>\n<div class=\"cnblogs_code\">\n<pre>zk.connectString=192.168.1.101:2181,192.168.1.102:2181,192.168.1.103:2181<span style=\"color: rgba(0, 0, 0, 1);\">\nzk.sessionTimeout</span>=5000<span style=\"color: rgba(0, 0, 0, 1);\">\nzk.connectionTimeout</span>=3000<span style=\"color: rgba(0, 0, 0, 1);\">\nelection.path</span>=/<span style=\"color: rgba(0, 0, 0, 1);\">election\n# 每个节点手动设置不同的 node.id\n# node1: node</span>-1<span style=\"color: rgba(0, 0, 0, 1);\">\n# node2: node</span>-2<span style=\"color: rgba(0, 0, 0, 1);\">\n# node3: node</span>-3<span style=\"color: rgba(0, 0, 0, 1);\">\nnode.id</span>=node-1   # 启动时根据节点修改</pre>\n</div>\n<p>项目大包部署到三台服务器指定目录下（/home/user）。</p>\n<p dir=\"auto\">在每台服务器上创建启动脚本（ nohup + 脚本）</p>\n<div class=\"cnblogs_code\">\n<pre>cd /home/<span style=\"color: rgba(0, 0, 0, 1);\">user\n\n</span>#<span style=\"color: rgba(0, 0, 0, 1);\"> 创建启动脚本 start.sh（node1 示例）\ncat </span>&gt; start.sh &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">EOF</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>\n#!/bin/<span style=\"color: rgba(0, 0, 0, 1);\">bash\n\n</span>#<span style=\"color: rgba(0, 0, 0, 1);\"> 节点 ID（每个服务器不同）\nNODE_ID</span>=<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">node-1</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>   # node2 改为 node-<span style=\"color: rgba(128, 0, 128, 1);\">2</span>，node3 改为 node-<span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\nnohup java </span>-<span style=\"color: rgba(0, 0, 0, 1);\">jar \\\n  </span>-Dnode.id=<span style=\"color: rgba(0, 0, 0, 1);\">${NODE_ID} \\\n  distributed</span>-task-service-<span style=\"color: rgba(128, 0, 128, 1);\">1.0</span>-<span style=\"color: rgba(0, 0, 0, 1);\">SNAPSHOT.jar \\\n  </span>&gt; service.log <span style=\"color: rgba(128, 0, 128, 1);\">2</span>&gt;&amp;<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\"> &amp;\n\necho </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Started with node.id=${NODE_ID}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\nEOF\n\nchmod </span>+x start.sh</pre>\n</div>\n<p dir=\"auto\">每台服务器启动服务</p>\n<div class=\"cnblogs_code\">\n<pre>./start.sh</pre>\n</div>\n<p>日志查看</p>\n<div class=\"cnblogs_code\">\n<pre>tail -f service.log</pre>\n</div>\n<p dir=\"auto\">可以看到类似输出：</p>\n<ul dir=\"auto\">\n<li>一个节点会打印：I am the Leader: /election/node-1-0000000001</li>\n<li>另外两个节点：I am Follower, watching: node-?-0000000000</li>\n</ul>\n<p dir=\"auto\">只有 Leader 会每分钟打印：Executing task: Backup database...</p>\n<h4 dir=\"auto\">测试故障转移</h4>\n<p>查看当前 Leader（假设是 node1）：</p>\n<div class=\"cnblogs_code\">\n<pre>tail -f /home/user/service.log | grep <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">I am the Leader</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span></pre>\n</div>\n<p dir=\"auto\">杀掉 Leader 进程（node1）：</p>\n<div class=\"cnblogs_code\">\n<pre>ps -<span style=\"color: rgba(0, 0, 0, 1);\">ef | grep java\nkill </span>-<span style=\"color: rgba(128, 0, 128, 1);\">9</span> &lt;pid&gt;</pre>\n</div>\n<p>观察其他节点日志：</p>\n<ul dir=\"auto\">\n<li>几百毫秒内，其中一个 Follower 会成为新 Leader，并开始执行任务。</li>\n<li>原来的 Follower 继续监视新 Leader。</li>\n</ul>\n<h3 dir=\"auto\">总结</h3>\n<ul dir=\"auto\">\n<li><strong>操作流程</strong>：3 台机器 → 安装 ZK → 复制 JAR → 修改 node.id → 启动脚本</li>\n<li><strong>高可用</strong>：ZooKeeper 保证领导者选举快速、可靠</li>\n<li><strong>可扩展</strong>：想加更多节点，只需复制 JAR + 修改 node.id + 启动即可</li>\n</ul>\n<p dir=\"auto\">&nbsp;</p>\n<p>&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 17:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Marktowin\">Marktowin</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "多线程的这12种用途，99%的人不知道！",
      "link": "https://www.cnblogs.com/12lisu/p/19517803",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19517803\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 16:09\">\n    <span>多线程的这12种用途，99%的人不知道！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>并发编程是一项非常重要的技术，无论在面试，还是工作中出现的频率非常高。</p>\n<p>之前我发表的一篇《<a href=\"https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;mid=2247492962&amp;idx=1&amp;sn=17ed1d2ed950b4e9160218b296d19d4e&amp;chksm=c0e83d8af79fb49cc72fcafc8ed62822263106e54675ea8406a2e3daadb44e25364275af9082&amp;token=245805875&amp;lang=zh_CN#rd\" rel=\"noopener nofollow\" target=\"_blank\">聊聊并发编程的10个坑</a>》，在全网广受好评。说明了这类文章还是比较有价值的，接下来，打算继续聊聊并发编程这个话题。</p>\n<p>并发编程说白了就是多线程编程，但多线程一定比单线程效率更高？</p>\n<p>答：不一定，要看具体业务场景。</p>\n<p>毕竟如果使用了多线程，那么线程之间的竞争和抢占cpu资源，线程的上下文切换，也是相对来说比较耗时的操作。</p>\n<p>下面这几个问题在面试中，你必定遇到过：</p>\n<ol>\n<li>你在哪来业务场景中使用过多线程？</li>\n<li>怎么用的？</li>\n<li>踩过哪些坑？</li>\n</ol>\n<p>今天聊聊我之前在项目中用并发编程的12种业务场景，给有需要的朋友一个参考。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"1-简单定时任务\">1. 简单定时任务</h2>\n<p>各位亲爱的朋友，你没看错，<code>Thread</code>类真的能做定时任务。如果你看过一些<code>定时任务框架</code>的源码，你最后会发现，它们的底层也会使用Thread类。</p>\n<p>实现这种定时任务的具体代码如下：</p>\n<pre><code class=\"language-java\">public static void init() {\n    new Thread(() -&gt; {\n        while (true) {\n            try {\n                System.out.println(\"下载文件\");\n                Thread.sleep(1000 * 60 * 5);\n            } catch (Exception e) {\n                log.error(e);\n            }\n        }\n    }).start();\n}\n</code></pre>\n<p>使用Thread类可以做最简单的定时任务，在run方法中有个while的死循环（当然还有其他方式），执行我们自己的任务。有个需要特别注意的地方是，需要用<code>try...catch</code>捕获异常，否则如果出现异常，就直接退出循环，下次将无法继续执行了。</p>\n<p>但这种方式做的定时任务，只能周期性执行，不能支持定时在某个时间点执行。</p>\n<p>特别提醒一下，该线程建议定义成<code>守护线程</code>，可以通过<code>setDaemon</code>方法设置，让它在后台默默执行就好。</p>\n<p>使用场景：比如项目中有时需要每隔5分钟去<code>下载某个文件</code>，或者每隔10分钟去读取模板文件<code>生成静态html页面</code>等等，一些简单的周期性任务场景。</p>\n<p>使用<code>Thread</code>类做定时任务的优缺点：</p>\n<ul>\n<li>\n<p>优点：这种定时任务非常简单，学习成本低，容易入手，对于那些简单的周期性任务，是个不错的选择。</p>\n</li>\n<li>\n<p>缺点：不支持指定某个时间点执行任务，不支持延迟执行等操作，功能过于单一，无法应对一些较为复杂的场景。</p>\n</li>\n</ul>\n<h2 id=\"2监听器\">2.监听器</h2>\n<p>有时候，我们需要写个监听器，去监听某些数据的变化。</p>\n<p>比如：我们在使用<code>canal</code>的时候，需要监听<code>binlog</code>的变化，能够及时把数据库中的数据，同步到另外一个业务数据库中。</p>\n<p><img alt=\"\" class=\"lazyload\" /><br />\n如果直接写一个监听器去监听数据就太没意思了，我们想实现这样一个功能：在配置中心有个开关，配置监听器是否开启，如果开启了使用单线程异步执行。</p>\n<p>主要代码如下：</p>\n<pre><code class=\"language-java\">@Service\npublic CanalService {\n    private volatile boolean running = false;\n    private Thread thread;\n\n    @Autowired\n    private CanalConnector canalConnector;\n    \n    public void handle() {\n        //连接canal\n        while(running) {\n           //业务处理\n        }\n    }\n    \n    public void start() {\n       thread = new Thread(this::handle, \"name\");\n       running = true;\n       thread.start();\n    }\n    \n    public void stop() {\n       if(!running) {\n          return;\n       }\n       running = false;\n    }\n}\n</code></pre>\n<p>在start方法中开启了一个线程，在该线程中异步执行handle方法的具体任务。然后通过调用stop方法，可以停止该线程。</p>\n<p>其中，使用<code>volatile</code>关键字控制的running变量作为开关，它可以控制线程中的状态。</p>\n<p>接下来，有个比较关键的点是：如何通过配置中心的配置，控制这个开关呢？</p>\n<p>以<code>apollo</code>配置为例，我们在配置中心的后台，修改配置之后，自动获取最新配置的核心代码如下：</p>\n<pre><code class=\"language-java\">public class CanalConfig {\n    @Autowired\n    private CanalService canalService;\n\n    @ApolloConfigChangeListener\n    public void change(ConfigChangeEvent event) {\n        String value = event.getChange(\"test.canal.enable\").getNewValue();\n        if(BooleanUtils.toBoolean(value)) {\n            canalService.start();\n        } else {\n            canalService.stop();\n        }\n    }\n}\n</code></pre>\n<p>通过<code>apollo</code>的<code>ApolloConfigChangeListener</code>注解，可以监听配置参数的变化。</p>\n<p>如果<code>test.canal.enable</code>开关配置的true，则调用canalService类的start方法开启canal数据同步功能。如果开关配置的false，则调用canalService类的stop方法，自动停止canal数据同步功能。</p>\n<h2 id=\"3收集日志\">3.收集日志</h2>\n<p>在某些高并发的场景中，我们需要收集部分用户的日志（比如：用户登录的日志），写到数据库中，以便于做分析。</p>\n<p>但由于项目中，还没有引入消息中间件，比如：<code>kafka</code>、<code>rocketmq</code>等。</p>\n<p>如果直接将日志同步写入数据库，可能会影响接口性能。</p>\n<p>所以，大家很自然想到了异步处理。</p>\n<p>实现这个需求最简单的做法是，开启一个线程，异步写入数据到数据库即可。</p>\n<p>这样做，可以是可以。</p>\n<p>但如果用户登录操作的耗时，比异步写入数据库的时间要少得多。这样导致的结果是：生产日志的速度，比消费日志的速度要快得多，最终的性能瓶颈在消费端。</p>\n<p>其实，还有更优雅的处理方式，虽说没有使用消息中间件，但借用了它的思想。</p>\n<p>这套记录登录日志的功能，分为：日志生产端、日志存储端和日志消费端。</p>\n<p>如下图所示：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>先定义了一个阻塞队列。</p>\n<pre><code class=\"language-java\">@Component\npublic class LoginLogQueue {\n    private static final int QUEUE_MAX_SIZE    = 1000;\n\n    private BlockingQueueblockingQueue queue = new LinkedBlockingQueue&lt;&gt;(QUEUE_MAX_SIZE);\n\n    //生成消息\n    public boolean push(LoginLog loginLog) {\n        return this.queue.add(loginLog);\n    } \n\n    //消费消息\n    public LoginLog poll() {\n        LoginLog loginLog = null;\n        try {\n            loginLog = this.queue.take();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n}\n</code></pre>\n<p>然后定义了一个日志的生产者。</p>\n<pre><code class=\"language-java\">@Service\npublic class LoginSerivce {\n    \n    @Autowired\n    private LoginLogQueue loginLogQueue;\n\n    public int login(UserInfo userInfo) {\n        //业务处理\n        LoginLog loginLog = convert(userInfo);\n        loginLogQueue.push(loginLog);\n    }  \n}\n</code></pre>\n<p>接下来，定义了日志的消费者。</p>\n<pre><code class=\"language-java\">@Service\npublic class LoginInfoConsumer {\n    @Autowired\n    private LoginLogQueue queue;\n\n    @PostConstruct\n    public voit init {\n       new Thread(() -&gt; {\n          while (true) {\n              LoginLog loginLog = queue.take();\n              //写入数据库\n          }\n        }).start();\n    }\n}\n</code></pre>\n<p>当然，这个例子中使用单线程接收登录日志，为了提升性能，也可以使用线程池来处理业务逻辑（比如：写入数据库）等。</p>\n<h2 id=\"4excel导入\">4.excel导入</h2>\n<p>我们可能会经常收到运营同学提过来的excel数据导入需求，比如：将某一大类下的所有子类一次性导入系统，或者导入一批新的供应商数据等等。</p>\n<p>我们以导入供应商数据为例，它所涉及的业务流程很长，比如：</p>\n<ol>\n<li>调用天眼查接口校验企业名称和统一社会信用代码。</li>\n<li>写入供应商基本表</li>\n<li>写入组织表</li>\n<li>给供应商自动创建一个用户</li>\n<li>给该用户分配权限</li>\n<li>自定义域名</li>\n<li>发站内通知</li>\n</ol>\n<p>等等。</p>\n<p>如果在程序中，解析完excel，读取了所有数据之后。用单线程一条条处理业务逻辑，可能耗时会非常长。</p>\n<p>为了提升excel数据导入效率，非常有必要使用多线程来处理。</p>\n<p>当然在java中实现多线程的手段有很多种，下面重点聊聊java8中最简单的实现方式：<code>parallelStream</code>。</p>\n<p>伪代码如下：</p>\n<pre><code class=\"language-java\">supplierList.parallelStream().forEach(x -&gt; importSupplier(x));\n</code></pre>\n<p><code>parallelStream</code>是一个并行执行的流，它默认通过<code>ForkJoinPool</code>实现的，能提高你的多线程任务的速度。</p>\n<p><code>ForkJoinPool</code>处理的过程会分而治之，它的核心思想是：<code>将一个大任务切分成多个小任务</code>。每个小任务都能单独执行，最后它会把所用任务的执行结果进行汇总。</p>\n<p>下面用一张图简单介绍一下ForkJoinPool的原理：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>当然除了excel导入之外，还有类似的读取文本文件，也可以用类似的方法处理。</p>\n<blockquote>\n<p>温馨的提醒一下，如果一次性导入的数据非常多，用多线程处理，可能会使系统的cpu使用率飙升，需要特别关注。</p>\n</blockquote>\n<h2 id=\"5查询接口\">5.查询接口</h2>\n<p>很多时候，我们需要在某个查询接口中，调用其他服务的接口，组合数据之后，一起返回。</p>\n<p>比如有这样的业务场景：</p>\n<p>在用户信息查询接口中需要返回：用户名称、性别、等级、头像、积分、成长值等信息。</p>\n<p>而用户名称、性别、等级、头像在用户服务中，积分在积分服务中，成长值在成长值服务中。为了汇总这些数据统一返回，需要另外提供一个对外接口服务。</p>\n<p>于是，用户信息查询接口需要调用用户查询接口、积分查询接口 和 成长值查询接口，然后汇总数据统一返回。</p>\n<p>调用过程如下图所示：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>调用远程接口总耗时 530ms = 200ms + 150ms + 180ms</p>\n<p>显然这种串行调用远程接口性能是非常不好的，调用远程接口总的耗时为所有的远程接口耗时之和。</p>\n<p>那么如何优化远程接口性能呢？</p>\n<p>既然串行调用多个远程接口性能很差，为什么不改成并行呢？</p>\n<p>如下图所示：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>调用远程接口总耗时 200ms = 200ms（即耗时最长的那次远程接口调用）</p>\n<p>在java8之前可以通过实现<code>Callable</code>接口，获取线程返回结果。</p>\n<p>java8以后通过<code>CompleteFuture</code>类实现该功能。我们这里以CompleteFuture为例：</p>\n<pre><code class=\"language-java\">public UserInfo getUserInfo(Long id) throws InterruptedException, ExecutionException {\n    final UserInfo userInfo = new UserInfo();\n    CompletableFuture userFuture = CompletableFuture.supplyAsync(() -&gt; {\n        getRemoteUserAndFill(id, userInfo);\n        return Boolean.TRUE;\n    }, executor);\n\n    CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -&gt; {\n        getRemoteBonusAndFill(id, userInfo);\n        return Boolean.TRUE;\n    }, executor);\n\n    CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -&gt; {\n        getRemoteGrowthAndFill(id, userInfo);\n        return Boolean.TRUE;\n    }, executor);\n    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();\n\n    userFuture.get();\n    bonusFuture.get();\n    growthFuture.get();\n    return userInfo;\n}\n</code></pre>\n<p>温馨提醒一下，这两种方式别忘了使用<code>线程池</code>。示例中我用到了<code>executor</code>，表示自定义的线程池，为了防止高并发场景下，出现线程过多的问题。</p>\n<h2 id=\"6获取用户上下文\">6.获取用户上下文</h2>\n<p>不知道你在项目开发时，有没有遇到过这样的需求：用户登录之后，在所有的请求接口中，通过某个公共方法，就能获取到当前登录用户的信息？</p>\n<p>获取的用户上下文，我们以<code>CurrentUser</code>为例。</p>\n<p><code>CurrentUser</code>内部包含了一个<code>ThreadLocal</code>对象，它负责保存当前线程的用户上下文信息。当然为了保证在线程池中，也能从用户上下文中获取到正确的用户信息，这里用了阿里的<code>TransmittableThreadLocal</code>。伪代码如下：</p>\n<pre><code class=\"language-java\">@Data\npublic class CurrentUser {\n    private static final TransmittableThreadLocal&lt;CurrentUser&gt; THREA_LOCAL = new TransmittableThreadLocal&lt;&gt;();\n    \n    private String id;\n    private String userName;\n    private String password;\n    private String phone;\n    ...\n    \n    public statis void set(CurrentUser user) {\n      THREA_LOCAL.set(user);\n    }\n    \n    public static void getCurrent() {\n      return THREA_LOCAL.get();\n    }\n}\n</code></pre>\n<p>这里为什么用了阿里的TransmittableThreadLocal，而不是普通的ThreadLocal呢？在线程池中，由于线程会被多次复用，导致从普通的ThreadLocal中无法获取正确的用户信息。父线程中的参数，没法传递给子线程，而TransmittableThreadLocal很好解决了这个问题。</p>\n<p>然后在项目中定义一个全局的spring mvc拦截器，专门设置用户上下文到ThreadLocal中。伪代码如下：</p>\n<pre><code class=\"language-java\">public class UserInterceptor extends HandlerInterceptorAdapter {\n   \n   @Override  \n   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n      CurrentUser user = getUser(request);\n      if(Objects.nonNull(user)) {\n         CurrentUser.set(user);\n      }\n   } \n}\n</code></pre>\n<p>用户在请求我们接口时，会先触发该拦截器，它会根据用户cookie中的token，调用调用接口获取redis中的用户信息。如果能获取到，说明用户已经登录，则把用户信息设置到CurrentUser类的ThreadLocal中。</p>\n<p>接下来，在api服务的下层，即business层的方法中，就能轻松通过CurrentUser.getCurrent();方法获取到想要的用户上下文信息了。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>这套用户体系的想法是很good的，但深入使用后，发现了一个小插曲：</p>\n<p>api服务和mq消费者服务都引用了business层，business层中的方法两个服务都能直接调用。</p>\n<p>我们都知道在api服务中用户是需要登录的，而mq消费者服务则不需要登录。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>如果business中的某个方法刚开始是给api开发的，在方法深处使用了CurrentUser.getCurrent();获取用户上下文。但后来，某位新来的帅哥在mq消费者中也调用了那个方法，并未发觉这个小机关，就会中招，出现找不到用户上下文的问题。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>所以我当时的第一个想法是：代码没做兼容处理，因为之前这类问题偶尔会发生一次。</p>\n<p>想要解决这个问题，其实也很简单。只需先判断一下能否从CurrentUser中获取用户信息，如果不能，则取配置的系统用户信息。伪代码如下：</p>\n<pre><code class=\"language-java\">@Autowired\nprivate BusinessConfig businessConfig;\n\nCurrentUser user = CurrentUser.getCurrent();\nif(Objects.nonNull(user)) {\n   entity.setUserId(user.getUserId());\n   entity.setUserName(user.getUserName());\n} else {\n   entity.setUserId(businessConfig.getDefaultUserId());\n   entity.setUserName(businessConfig.getDefaultUserName());\n}\n</code></pre>\n<p>这种简单无公害的代码，如果只是在一两个地方加还OK。</p>\n<p>此外，众所周知，<code>SimpleDateFormat</code>在java8以前，是用来处理时间的工具类，它是非线程安全的。也就是说，用该方法解析日期会有线程安全问题。</p>\n<p>为了避免线程安全问题的出现，我们可以把SimpleDateFormat对象定义成<code>局部变量</code>。但如果你一定要把它定义成静态变量，可以使用ThreadLocal保存日期，也能解决线程安全问题。</p>\n<h2 id=\"8-传递参数\">8. 传递参数</h2>\n<p>之前见过有些同事写代码时，一个非常有趣的用法，即：使用<code>MDC</code>传递参数。</p>\n<p>MDC是什么？</p>\n<p><code>MDC</code>是<code>org.slf4j</code>包下的一个类，它的全称是<code>Mapped Diagnostic Context</code>，我们可以认为它是一个线程安全的存放诊断日志的容器。</p>\n<p><code>MDC</code>的底层是用了<code>ThreadLocal</code>来保存数据的。</p>\n<p>例如现在有这样一种场景：我们使用<code>RestTemplate</code>调用远程接口时，有时需要在<code>header</code>中传递信息，比如：traceId，source等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。</p>\n<p>这种业务场景就能通过<code>ClientHttpRequestInterceptor</code>接口实现，具体做法如下：</p>\n<p>第一步，定义一个LogFilter拦截所有接口请求，在MDC中设置traceId：</p>\n<pre><code class=\"language-java\">public class LogFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        MdcUtil.add(UUID.randomUUID().toString());\n        System.out.println(\"记录请求日志\");\n        chain.doFilter(request, response);\n        System.out.println(\"记录响应日志\");\n    }\n\n    @Override\n    public void destroy() {\n    }\n}\n</code></pre>\n<p>第二步，实现<code>ClientHttpRequestInterceptor</code>接口，MDC中获取当前请求的traceId，然后设置到header中：</p>\n<pre><code class=\"language-java\">public class RestTemplateInterceptor implements ClientHttpRequestInterceptor {\n\n    @Override\n    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {\n        request.getHeaders().set(\"traceId\", MdcUtil.get());\n        return execution.execute(request, body);\n    }\n}\n</code></pre>\n<p>第三步，定义配置类，配置上面定义的RestTemplateInterceptor类：</p>\n<pre><code class=\"language-java\">@Configuration\npublic class RestTemplateConfiguration {\n\n    @Bean\n    public RestTemplate restTemplate() {\n        RestTemplate restTemplate = new RestTemplate();\n        restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));\n        return restTemplate;\n    }\n\n    @Bean\n    public RestTemplateInterceptor restTemplateInterceptor() {\n        return new RestTemplateInterceptor();\n    }\n}\n</code></pre>\n<p>其中MdcUtil其实是利用MDC工具在<code>ThreadLocal</code>中存储和获取traceId</p>\n<pre><code class=\"language-java\">public class MdcUtil {\n\n    private static final String TRACE_ID = \"TRACE_ID\";\n\n    public static String get() {\n        return MDC.get(TRACE_ID);\n    }\n\n    public static void add(String value) {\n        MDC.put(TRACE_ID, value);\n    }\n}\n</code></pre>\n<p>当然，这个例子中没有演示MdcUtil类的add方法具体调的地方，我们可以在<code>filter</code>中执行接口方法之前，生成traceId，调用MdcUtil类的add方法添加到MDC中，然后在同一个请求的其他地方就能通过MdcUtil类的get方法获取到该traceId。</p>\n<p>能使用MDC保存traceId等参数的根本原因是，用户请求到应用服务器，<code>Tomcat</code>会从线程池中分配一个线程去处理该请求。</p>\n<p>那么该请求的整个过程中，保存到<code>MDC</code>的<code>ThreadLocal</code>中的参数，也是该线程独享的，所以不会有线程安全问题。</p>\n<h2 id=\"9-模拟高并发\">9. 模拟高并发</h2>\n<p>有时候我们写的接口，在低并发的场景下，一点问题都没有。</p>\n<p>但如果一旦出现高并发调用，该接口可能会出现一些意想不到的问题。</p>\n<p>为了防止类似的事情发生，一般在项目上线前，我们非常有必要对接口做一下<code>压力测试</code>。</p>\n<p>当然，现在已经有比较成熟的压力测试工具，比如：<code>Jmeter</code>、<code>LoadRunner</code>等。</p>\n<p>如果你觉得下载压测工具比较麻烦，也可以手写一个简单的模拟并发操作的工具，用<code>CountDownLatch</code>就能实现，例如：</p>\n<pre><code class=\"language-java\">public static void concurrenceTest() {\n    /**\n     * 模拟高并发情况代码\n     */\n    final AtomicInteger atomicInteger = new AtomicInteger(0);\n    final CountDownLatch countDownLatch = new CountDownLatch(1000); // 相当于计数器，当所有都准备好了，再一起执行，模仿多并发，保证并发量\n    final CountDownLatch countDownLatch2 = new CountDownLatch(1000); // 保证所有线程执行完了再打印atomicInteger的值\n    ExecutorService executorService = Executors.newFixedThreadPool(10);\n    try {\n        for (int i = 0; i &lt; 1000; i++) {\n            executorService.submit(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        countDownLatch.await(); //一直阻塞当前线程，直到计时器的值为0,保证同时并发\n                    } catch (InterruptedException e) {\n                        log.error(e.getMessage(),e);\n                    }\n                    //每个线程增加1000次，每次加1\n                    for (int j = 0; j &lt; 1000; j++) {\n                        atomicInteger.incrementAndGet();\n                    }\n                    countDownLatch2.countDown();\n                }\n            });\n            countDownLatch.countDown();\n        }\n\n        countDownLatch2.await();// 保证所有线程执行完\n        executorService.shutdown();\n    } catch (Exception e){\n        log.error(e.getMessage(),e);\n    }\n}\n</code></pre>\n<h2 id=\"10-处理mq消息\">10. 处理mq消息</h2>\n<p>在高并发的场景中，消息积压问题，可以说如影随形，真的没办法从根本上解决。表面上看，已经解决了，但后面不知道什么时候，就会冒出一次，比如这次：</p>\n<p>有天下午，产品过来说：有几个商户投诉过来了，他们说菜品有延迟，快查一下原因。</p>\n<p>这次问题出现得有点奇怪。</p>\n<p>为什么这么说？</p>\n<p>首先这个时间点就有点奇怪，平常出问题，不都是中午或者晚上用餐高峰期吗？怎么这次问题出现在下午？</p>\n<p>根据以往积累的经验，我直接看了<code>kafka</code>的<code>topic</code>的数据，果然上面消息有积压，但这次每个<code>partition</code>都积压了十几万的消息没有消费，比以往加压的消息数量增加了几百倍。这次消息积压得极不寻常。</p>\n<p>我赶紧查服务监控看看消费者挂了没，还好没挂。又查服务日志没有发现异常。这时我有点迷茫，碰运气问了问订单组下午发生了什么事情没？他们说下午有个促销活动，跑了一个<code>JOB</code>批量更新过有些商户的订单信息。</p>\n<p>这时，我一下子如梦初醒，是他们在JOB中批量发消息导致的问题。怎么没有通知我们呢？实在太坑了。</p>\n<p>虽说知道问题的原因了，倒是眼前积压的这十几万的消息该如何处理呢？</p>\n<p>此时，如果直接调大<code>partition</code>数量是不行的，历史消息已经存储到<code>4</code>个固定的partition，只有新增的消息才会到新的partition。我们重点需要处理的是已有的partition。</p>\n<p>直接加服务节点也不行，因为<code>kafka</code>允许同组的多个<code>partition</code>被一个<code>consumer</code>消费，但不允许一个partition被同组的多个consumer消费，可能会造成资源浪费。</p>\n<p>看来只有用<code>多线程</code>处理了。</p>\n<p>为了紧急解决问题，我改成了用线程池处理消息，核心线程和最大线程数都配置成了<code>50</code>。</p>\n<p>大致用法如下：</p>\n<ol>\n<li>先定义一个线程池：</li>\n</ol>\n<pre><code class=\"language-java\">@Configuration\npublic class ThreadPoolConfig {\n\n    @Value(\"${thread.pool.corePoolSize:5}\")\n    private int corePoolSize;\n\n    @Value(\"${thread.pool.maxPoolSize:10}\")\n    private int maxPoolSize;\n\n    @Value(\"${thread.pool.queueCapacity:200}\")\n    private int queueCapacity;\n\n    @Value(\"${thread.pool.keepAliveSeconds:30}\")\n    private int keepAliveSeconds;\n\n    @Value(\"${thread.pool.threadNamePrefix:ASYNC_}\")\n    private String threadNamePrefix;\n\n    @Bean(\"messageExecutor\")\n    public Executor messageExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(corePoolSize);\n        executor.setMaxPoolSize(maxPoolSize);\n        executor.setQueueCapacity(queueCapacity);\n        executor.setKeepAliveSeconds(keepAliveSeconds);\n        executor.setThreadNamePrefix(threadNamePrefix);\n        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());\n        executor.initialize();\n        return executor;\n    }\n}\n</code></pre>\n<ol start=\"2\">\n<li>再定义一个消息的consumer：</li>\n</ol>\n<pre><code class=\"language-java\">@Service\npublic class MyConsumerService {\n    @Autowired\n    private Executor messageExecutor;\n    \n    @KafkaListener(id=\"test\",topics={\"topic-test\"})\n    public void listen(String message){\n        System.out.println(\"收到消息：\" + message);\n        messageExecutor.submit(new MyWork(message);\n    }\n}\n</code></pre>\n<ol start=\"3\">\n<li>在定义的Runable实现类中处理业务逻辑：</li>\n</ol>\n<pre><code class=\"language-java\">public class MyWork implements Runnable {\n    private String message;\n    \n    public MyWork(String message) {\n       this.message = message;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(message);\n    }\n}\n</code></pre>\n<p>果然，调整之后消息积压数量确实下降的非常快，大约半小时后，积压的消息就非常顺利的处理完了。</p>\n<p>但此时有个更严重的问题出现：我收到了报警邮件，有两个订单系统的节点down机了。。。</p>\n<p>更详细内容，请看看我的另一篇文章《<a href=\"https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;mid=2247490289&amp;idx=1&amp;sn=bc311da9f4a4d3f48ee5dc207bf31a8b&amp;chksm=c0ebc219f79c4b0fc711116723b9df3a5531cda32f0f5d00f065910aa552af6ff03b3f1528fc&amp;token=751314179&amp;lang=zh_CN&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">我用kafka两年踩过的一些非比寻常的坑</a>》</p>\n<h2 id=\"11-统计数量\">11. 统计数量</h2>\n<p>在多线程的场景中，有时候需要统计数量，比如：用多线程导入供应商数据时，统计导入成功的供应商数有多少。</p>\n<p>如果这时候用count++统计次数，最终的结果可能会不准。因为count++并非原子操作，如果多个线程同时执行该操作，则统计的次数，可能会出现异常。</p>\n<p>为了解决这个问题，就需要使用<code>concurent</code>的<code>atomic</code>包下面的类，比如：<code>AtomicInteger</code>、<code>AtomicLong</code>等。</p>\n<pre><code class=\"language-java\">@Servcie\npublic class ImportSupplierService {\n  private static AtomicInteger count = new AtomicInteger(0);\n\n  public int importSupplier(List&lt;SupplierInfo&gt; supplierList) {\n       if(CollectionUtils.isEmpty(supplierList)) {\n           return 0;\n       }\n\n       supplierList.parallelStream().forEach(x -&gt; {\n           try {\n             importSupplier(x);\n             count.addAndGet(1);\n           } catch(Exception e) {\n              log.error(e.getMessage(),e);\n           }\n       );\n\n      return count.get();\n  }    \n}\n</code></pre>\n<p><code>AtomicInteger</code>的底层说白了使用<code>自旋锁</code>+<code>CAS</code>。</p>\n<pre><code class=\"language-java\">public final int incrementAndGet() {\n    for (;;) {\n        int current = get();\n        int next = current + 1;\n        if (compareAndSet(current, next))\n            return next;\n    }\n}\n</code></pre>\n<p><code>自旋锁</code>说白了就是一个<code>死循环</code>。</p>\n<p>而<code>CAS</code>是<code>比较</code>和<code>交换</code>的意思。</p>\n<p>它的实现逻辑是：将内存位置处的<code>旧值</code>与<code>预期值</code>进行比较，若相等，则将内存位置处的值替换为<code>新值</code>。若不相等，则不做任何操作。</p>\n<h2 id=\"12-延迟定时任务\">12. 延迟定时任务</h2>\n<p>我们经常有延迟处理数据的需求，比如：如果用户下单后，超过30分钟还未完成支付，则系统自动将该订单取消。</p>\n<p>这里需求就可以使用<code>延迟定时任务</code>实现。</p>\n<p><code>ScheduledExecutorService</code>是<code>JDK1.5+</code>版本引进的定时任务，该类位于<code>java.util.concurrent</code>并发包下。</p>\n<p>ScheduledExecutorService是基于多线程的，设计的初衷是为了解决<code>Timer</code>单线程执行，多个任务之间会互相影响的问题。</p>\n<p>它主要包含4个方法：</p>\n<ul>\n<li>schedule(Runnable command,long delay,TimeUnit unit)，带延迟时间的调度，只执行一次，调度之后可通过Future.get()阻塞直至任务执行完毕。</li>\n<li>schedule(Callable callable,long delay,TimeUnit unit)，带延迟时间的调度，只执行一次，调度之后可通过Future.get()阻塞直至任务执行完毕，并且可以获取执行结果。</li>\n<li>scheduleAtFixedRate，表示以固定频率执行的任务，如果当前任务耗时较多，超过定时周期period，则当前任务结束后会立即执行。</li>\n<li>scheduleWithFixedDelay，表示以固定延时执行任务，延时是相对当前任务结束为起点计算开始时间。</li>\n</ul>\n<p>实现这种定时任务的具体代码如下：</p>\n<pre><code class=\"language-java\">public class ScheduleExecutorTest {\n\n    public static void main(String[] args) {\n        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);\n        scheduledExecutorService.scheduleAtFixedRate(() -&gt; {\n            System.out.println(\"doSomething\");\n        },1000,1000, TimeUnit.MILLISECONDS);\n    }\n}\n</code></pre>\n<p>调用<code>ScheduledExecutorService</code>类的<code>scheduleAtFixedRate</code>方法实现周期性任务，每隔1秒钟执行一次，每次延迟1秒再执行。</p>\n<p>这种定时任务是阿里巴巴开发者规范中用来替代<code>Timer</code>类的方案，对于多线程执行周期性任务，是个不错的选择。</p>\n<p>使用<code>ScheduledExecutorService</code>类做延迟定时任务的优缺点：</p>\n<ul>\n<li>\n<p>优点：基于多线程的定时任务，多个任务之间不会相关影响，支持周期性的执行任务，并且带延迟功能。</p>\n</li>\n<li>\n<p>缺点：不支持一些较复杂的定时规则。</p>\n</li>\n</ul>\n<p>当然，你也可以使用分布式定时任务，比如：xxl-job或者elastic-job等等。</p>\n<p>其实，在实际工作中我使用多线程的场景远远不只这12种，在这里只是抛砖引玉，介绍了一些我认为比较常见的业务场景。</p>\n<p>此外，如果你对并发编程中的一些坑，比较感兴趣的话，可以看看我的另一个文章《<a href=\"https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;mid=2247492962&amp;idx=1&amp;sn=17ed1d2ed950b4e9160218b296d19d4e&amp;chksm=c0e83d8af79fb49cc72fcafc8ed62822263106e54675ea8406a2e3daadb44e25364275af9082&amp;token=245805875&amp;lang=zh_CN#rd\" rel=\"noopener nofollow\" target=\"_blank\">聊聊并发编程的10个坑</a>》，里面写的非常详细。</p>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 16:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">150</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "SEAL全同态加密BFV方案入门详解",
      "link": "https://www.cnblogs.com/zhaoweiwei/p/19510487/bfv",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zhaoweiwei/p/19510487/bfv\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 15:50\">\n    <span>SEAL全同态加密BFV方案入门详解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文介绍微软的开源全同态项目SEAL中BFV方案的相关数学理论基础，以及相应加解密的主要流程，最后简单地介绍了SEAL源码的编译过程及简单应用示例。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>Microsoft SEAL（Simple Encrypted Arithmetic Library）是微软开源的轻量级、高性能全同态加密（FHE）库，专为整数/浮点数的密文运算设计，支持BFV、CKKS、BGV等主流FHE方案，广泛应用于隐私计算、联邦学习、数据加密等场景，源码：<a href=\"https://github.com/microsoft/SEAL\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microsoft/SEAL</a>。</p>\n<h1>1 数学基础</h1>\n<h2>1.1 多项式环</h2>\n<p>SEAL使用的基础环是：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121153443048-88951557.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p align=\"left\">BFV的所有运算都在这个多项式环中进行，符号含义如下：</p>\n<p align=\"left\">Z<sub>q</sub>：系数域，即多项式的所有系数都取自“模q的整数集合”，q称为系数模数（一个大素数或多个素数的乘积），决定密文的噪声容忍度和运算深度。</p>\n<p align=\"left\">x<sup>N</sup>+1：多项式模，要求N是2的整数幂（如4096、8192），满足x<sup>N</sup>≡-1 (mod x<sup>N</sup>+1)，这意味着所有多项式的次数都不会超过N-1（超过的项可通过x<sup>N</sup> = -1降次）。</p>\n<p align=\"left\">R<sub>q</sub>元素形式：任意元素是一个次数≤ N - 1的多项式，形如：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121154506434-1453063209.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>&nbsp;</p>\n<h2>1.2 明文空间</h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121155707555-629451098.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>明文（待加密的整数）会被编码为R<sub>t</sub>中的多项式，t满足t≡1 (mod 2N)，这是批量加密的硬性要求，明文在进行加密前要进行编码，有两种编码方式：</p>\n<p><strong>单整数编码</strong>：将单个整数m编码为常数多项式f(x)=m，即所有高次项系数为0。</p>\n<p><strong>批量编码</strong>：将N个小整数[m<sub>0</sub>,m<sub>1</sub>,...,m<sub>N-1</sub>]直接做为多项式的系数，编码为：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121160312132-985918846.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h2>1.3 RLWE问题</h2>\n<p align=\"left\">BFV的安全性基于RLWE问题（Ring Learning With Errors）的计算困难性，简单描述为：</p>\n<p align=\"left\">给定多项式R<sub>q</sub>，选择一个秘密多项式s(x)∈R<sub>q</sub>（系数为0/1的短多项式），以及大量的“噪声多项式对”（a<sub>i</sub>(x), b<sub>i</sub>(x)），其中a<sub>i</sub>(x)是随机生成的，b<sub>i</sub>(x)=-a<sub>i</sub>(x)s(x)+e<sub>i</sub>(x) (mod q)是通过秘密多项式s(x)计算得到的“响应多项式”，加入噪声e<sub>i</sub>(x)是为了让b<sub>i</sub>(x)看起来像一个完全随机的多项式，从而隐藏s(x)的存在，而在计算上无法从这些多项式对中恢复出秘密多项式s(x)。对于b<sub>i</sub>(x)其生成时每一部分的作用如下：</p>\n<p align=\"left\">a<sub>i</sub>(x)：从多项式环R<sub>q</sub>中均匀随机生成的多项式，相当于“公共输入”，可以公开。</p>\n<p align=\"left\">s(x)：秘密多项式（系数仅为0或1），是整个RLWE问题的核心，必须严格保密。</p>\n<p align=\"left\">e<sub>i</sub>(x)：小系数噪声多项式（系数仅为-1、0、1），是“隐藏秘密”的关键。</p>\n<p align=\"left\">b<sub>i</sub>(x)：由a<sub>i</sub>(x)s(x)加上噪声得到的结果，与ai(x)一起构成公开的“多项式对”。</p>\n<p align=\"left\">如果没有噪声e<sub>i</sub>(x)，即e<sub>i</sub>(x)=0，那么b<sub>i</sub>(x)=-a<sub>i</sub>(x)s(x) (mod q)，此时攻击者可以通过多组(a<sub>i</sub>(x), b<sub>i</sub>(x))构建线性方程组，直接解密出秘密多项式s(x)，这就完全失去了安全性。而加入小噪声e<sub>i</sub>(x)后：</p>\n<p align=\"left\">b<sub>i</sub>(x)不再是a<sub>i</sub>(x)s(x)的精确结果，而是一个“近似值”；</p>\n<p align=\"left\">这个近似值的误差被控制在很小的范围内（由e<sub>i</sub>(x)的系数大小决定）；</p>\n<p align=\"left\">从计算角度，目前没有任何算法（包括量子算法）能高效地从这些带噪声的近似结果中恢复出s(x)，这正是RLWE问题的“计算困难性”来源，也是BFV适合后量子秘密场景的原因。</p>\n<h2>1.4 缩放因子</h2>\n<p>在BFV同态加密方案中，缩放因子（Scaling Factor）是连接明文空间（Z<sub>t</sub>）和密文空间（Z<sub>q</sub>）的核心系数，本质是为了让明文多项式能“适配”系数模数q的范围，同时保证解密时可以精确还原明文。BFV的明文模数t远小于系数模数q（t&lt;&lt;q)，比如t=65537，q=2<sup>60</sup>量级。</p>\n<p>明文多项式m(x)∈R<sub>t</sub>的系数范围是[0, t-1]，而密文多项式c(x)∈R<sub>q</sub>的系数范围是[0, q-1]，如果直接将明文m(x)放入密文公式，由于t太小，明文信息会被噪声和掩码完全淹没，无法解密。因此需要一个缩放因子，将明文系数放大到q的量级，再参与密文计算。缩放因子贯穿加密和解密两个核心步骤，是明文和密文的“桥梁”。</p>\n<p>（1）加密时：明文放大</p>\n<p>在加密步骤中，明文多项式m(x)不会直接代入密文公式，而是先乘于缩放因子Δ，再放入到公式：</p>\n<p>&nbsp;</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122103147623-1899019256.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>作用：将明文系数从[0, t-1]放大到[0,&nbsp;Δ*(t-1)]，这个范围在q的量级内，能避免明文被噪声覆盖。</p>\n<p>（2）解密时：明文缩小</p>\n<p>解密的核心步骤是先计算聚合多项式D(ct)，代入加密公式后可得：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122103532065-202805649.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>此时需要反向缩放来还原明文：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122103637412-765250880.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>概括来说，缩放因子不会直接参与运算，但会间接影响噪声的增长速度：</p>\n<p align=\"left\">1) 加法运算：密文加法是系数直接相加，噪声线性叠加，缩放因子不影响噪声增长；</p>\n<p align=\"left\">2) 乘法运算：密文乘法是多项式乘法，噪声会平方增长，而缩放因子Δ越大，噪声的规模也会越大，导致运算深度降低。</p>\n<p align=\"left\">因此，在参数配置时，需要在“明文范围（t大小）”和“运算深度（q大小）”之间做权衡：</p>\n<p align=\"left\">若t增大→Δ减小→噪声容忍度提升→运算深度增加；</p>\n<p align=\"left\">若t减小→Δ增大→噪声容忍度降低→运算深度减小。</p>\n<p align=\"left\">所以t与Δ成反比，需根据业务需求平衡明文范围和运算深度。</p>\n<h1>2 BFV核心流程</h1>\n<h2>2.1 参数配置</h2>\n<p>参数配置决定方案的性能与安全性，BFV核心参数有4个，需严格满足数学约束：</p>\n<p><img alt=\"image\" height=\"249\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260121155055832-1091265286.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"798\" /></p>\n<p>参数约束：需满足q&gt;t*(2N)<sup>d</sup>*B（d是目标运算深度，B是噪声上限），否则运算过程中噪声会“爆炸”导致解密失败。</p>\n<h2>2.2 密钥生成</h2>\n<p>基于RLWE问题生成私钥、公钥、重线性化密钥3中密钥，核心是构造含噪声的多项式对。</p>\n<p>（1）私钥（sk）</p>\n<p>随机生成一个短多项式s(x)∈R<sub>q</sub>，系数仅为0或1（如s(x) = 1 + x<sup>2</sup> + x<sup>5</sup>），私钥就是s(x)。</p>\n<p>（2）公钥（pk）</p>\n<p>随机生成多项式a(x)∈R<sub>q</sub>，生成小希数噪声多项式e(x)∈R<sub>q</sub>，计算b(x) = -a(x)s(x) + e(x) (mod q)，公钥是多项式对pk = (b(x), a(x))，可公开传播。这里的噪声e(x)让攻击者无法从公钥对中恢复私钥s(x)，目的是解决“公钥本身的安全性”。</p>\n<p>（3）重线性化密钥（rlk）</p>\n<p>密文乘法会导致密文从“2项多项式”膨胀为“3项多项式”，后续运算效率骤降。重线性化密钥用于将膨胀后的密文压缩回2项，生成逻辑与公钥类似，本质是一组扩展的RLWE多项式对。</p>\n<h2>2.3 加密</h2>\n<p>将明文多项式转为密文多项式，BFV的密文是R<sub>q</sub>中的2项多项式对ct = (c<sub>0</sub>(x), c<sub>1</sub>(x))，加密过程分两步：</p>\n<p>（1）明文编码：将整数明文m编码为明文多项式m(x)∈R<sub>t</sub>；</p>\n<p>（2）添加噪声与混淆：</p>\n<p>随机生成两个小噪声多项式e<sub>0</sub>(x),e<sub>1</sub>(x)∈R<sub>q</sub>，随机生成一个“掩码多项式”u(x)∈R<sub>q</sub>（系数为0/1），计算密文：</p>\n<p><img alt=\"image\" height=\"72\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122101343624-1971179879.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"506\" /></p>\n<p>核心设计：密文中包含明文信息m(x)，但被噪声e<sub>0</sub>/e<sub>1</sub>和掩码u(x)混淆，只有私钥能去除混淆和噪声。该步骤中的掩码多项式u(x)和噪声多项式e<sub>0</sub>(x),e<sub>1</sub>(x)是两套独立的安全机制，它们解决的是完全不同的问题，不能互相替代，如下图：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122145538684-995418377.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>u(x)通过随机缩放实现公钥和明文间的非固定线性关系，噪声通过“近似”进一步打破它们之间精确的代数关系，使得攻击者无法从近似值中还原精确明文。</p>\n<h2>2.4 同态运算</h2>\n<p>这步的核心是：密文运算=多项式环运算，BFV支持秘密&amp;密文（Ct&amp;Ct）和密文&amp;明文（Ct&amp;Pt）的加减乘运算，所有运算都在多项式环R<sub>q</sub>中进行，且无需密钥。</p>\n<p><img alt=\"image\" height=\"252\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122102234951-828568152.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"925\" /></p>\n<p>运算后的密文仍然是合法的RLWE密文，可继续参与后续运算——这就是「同态性」的体现。</p>\n<h2>2.5 解密</h2>\n<p>解密是加密的逆运算，核心是去除噪声、还原明文多项式，步骤如下：</p>\n<p>（1）密文聚合</p>\n<p>用私钥s(x)计算聚合多项式：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122102616840-333286614.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>代入加密公式可推导：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122102653366-486423113.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>（2）噪声去除</p>\n<p>由于总噪声e<sub>total</sub>&lt;q/(2t)，可通过“舍入+模运算”还原明文：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122102808245-1880527419.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />（3）明文解码</p>\n<p>将解密后的多项式m(x)转换回整数（单整数取常数项，批量加密取所有系数）。</p>\n<p>解密成功条件：总噪声e<sub>total</sub>&lt;q/(2t)，若运算次数过多导致噪声爆炸，舍入后无法还原明文，则会解密失败——这是BFV“层次性”的本质，运算深度有限。</p>\n<h2>2.6 python示例</h2>\n<p>以下是一个完整的python示例程序：</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_09b97ffc-eef3-46ba-bb50-d1e4cf620627\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_09b97ffc-eef3-46ba-bb50-d1e4cf620627\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_09b97ffc-eef3-46ba-bb50-d1e4cf620627\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> numpy as np\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> random\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> PolynomialRing:\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> <span style=\"color: rgba(128, 0, 128, 1);\">__init__</span><span style=\"color: rgba(0, 0, 0, 1);\">(self, n, modulus):\n        self.n </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> n\n        self.modulus </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> modulus\n        self.phi </span>= np.zeros(n + 1, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        self.phi[0] </span>= 1<span style=\"color: rgba(0, 0, 0, 1);\">\n        self.phi[n] </span>= 1\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_add(self, a, b):\n        result </span>= np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            result[i] </span>= (a[i] + b[i]) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_mul(self, a, b):\n        result </span>= np.zeros(2 * self.n - 1, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> j <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n                result[i </span>+ j] = (result[i + j] + a[i] * b[j]) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> self.poly_mod(result)\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_mod(self, poly):\n        result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> poly.copy()\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span> range(len(result) - 1, self.n - 1, -1<span style=\"color: rgba(0, 0, 0, 1);\">):\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> result[i] !=<span style=\"color: rgba(0, 0, 0, 1);\"> 0:\n                coeff </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> result[i]\n                result[i] </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> 0\n                idx </span>= i -<span style=\"color: rgba(0, 0, 0, 1);\"> self.n\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> idx &lt;<span style=\"color: rgba(0, 0, 0, 1);\"> len(result):\n                    result[idx] </span>= (result[idx] - coeff) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        result </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> result[:self.n]\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_sub(self, a, b):\n        result </span>= np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            result[i] </span>= (a[i] - b[i]) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> poly_scale(self, a, scalar):\n        result </span>= np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            result[i] </span>= (a[i] * scalar) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.modulus\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> random_poly(self):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> np.random.randint(0, self.modulus, self.n)\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> binary_poly(self):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> np.random.randint(0, 2<span style=\"color: rgba(0, 0, 0, 1);\">, self.n)\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> small_poly(self, bound=3<span style=\"color: rgba(0, 0, 0, 1);\">):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> np.random.randint(-bound, bound + 1<span style=\"color: rgba(0, 0, 0, 1);\">, self.n)\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> BFV:\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> <span style=\"color: rgba(128, 0, 128, 1);\">__init__</span>(self, n=256, q=1048576, t=256<span style=\"color: rgba(0, 0, 0, 1);\">):\n        self.n </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> n\n        self.q </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> q\n        self.t </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> t\n        self.ring </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> PolynomialRing(n, q)\n        self.plaintext_ring </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> PolynomialRing(n, t)\n        self.delta </span>= q //<span style=\"color: rgba(0, 0, 0, 1);\"> t\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> keygen(self):\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 产生密钥</span>\n        s =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.binary_poly()\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 挑战多项式</span>\n        a =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.random_poly()\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 随机多项式</span>\n        e =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.small_poly()\n        a_s </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_mul(a, s)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 响应多项式</span>\n        pk0 =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_sub(e, a_s)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 公钥</span>\n        pk =<span style=\"color: rgba(0, 0, 0, 1);\"> [pk0, a]\n        sk </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> s\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> pk, sk\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 编码明文</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> encode(self, message):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> isinstance(message, int):\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 单整数编码</span>\n            m = np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n            m[0] </span>= message %<span style=\"color: rgba(0, 0, 0, 1);\"> self.t\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 批量编码</span>\n            m = np.array(message, dtype=int) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.t\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> m\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用公钥加密</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> encrypt(self, pk, message):\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对明文进行编码</span>\n        m =<span style=\"color: rgba(0, 0, 0, 1);\"> self.encode(message)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对明文编码结果进行放大</span>\n        m_scaled =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_scale(m, self.delta)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\">print(\"m_scaled: {}\".format(m_scaled))</span>\n        \n        <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成掩码多项式</span>\n        u =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.binary_poly()\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 产生两个小噪声多项式</span>\n        e1 =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.small_poly()\n        e2 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.small_poly()\n        \n        pk0_u </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_mul(pk[0], u)\n        pk1_u </span>= self.ring.poly_mul(pk[1<span style=\"color: rgba(0, 0, 0, 1);\">], u)\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成密文c0</span>\n        c0 =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(pk0_u, e1)\n        c0 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(c0, m_scaled)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成密文c1</span>\n        c1 =<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(pk1_u, e2)\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 返回密文</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> [c0, c1]\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> decrypt(self, sk, ciphertext):\n        c0, c1 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> ciphertext\n        s_c1 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_mul(sk, c1)\n        decrypted </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(c0, s_c1)\n        \n        result </span>= np.zeros(self.n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(self.n):\n            result[i] </span>= round(decrypted[i] * self.t / self.q) %<span style=\"color: rgba(0, 0, 0, 1);\"> self.t\n        \n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> add(self, c1, c2):\n        c0 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> self.ring.poly_add(c1[0], c2[0])\n        c1 </span>= self.ring.poly_add(c1[1], c2[1<span style=\"color: rgba(0, 0, 0, 1);\">])\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> [c0, c1]\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> main():\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">=== BFV 同态加密方案演示 ===\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    bfv </span>= BFV(n=256, q=1048576, t=256<span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">参数设置:</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  多项式次数 n = {bfv.n}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  密文模数 q = {bfv.q}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  明文模数 t = {bfv.t}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  缩放因子 Δ = {bfv.delta}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    pk, sk </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.keygen()\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密钥生成完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">私钥 s 前5个系数: {sk[:5]}...\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span><span style=\"color: rgba(0, 0, 0, 1);\">(sk)\n    \n    m1 </span>= 42<span style=\"color: rgba(0, 0, 0, 1);\">\n    m2 </span>= 17\n    <span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文 m1 = {m1}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文 m2 = {m2}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    c1 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.encrypt(pk, m1)\n    c2 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.encrypt(pk, m2)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">加密完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文 c1[0] 前5个系数: {c1[0][:5]}...</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文 c1[1] 前5个系数: {c1[1][:5]}...\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文c1 {}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">.format(c1))\n    \n    d1 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.decrypt(sk, c1)\n    d2 </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.decrypt(sk, c2)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密结果 d1 = {d1[0]}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密结果 d2 = {d2[0]}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">=== 同态加法演示 ===</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    c_sum </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.add(c1, c2)\n    d_sum </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.decrypt(sk, c_sum)\n    expected_sum </span>= (m1 + m2) %<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.t\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文同态加法: c1 + c2</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密结果: {d_sum[0]}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">期望结果: {expected_sum}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">验证: {'成功' if d_sum[0] == expected_sum else '失败'}\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">=== 多项式明文演示 ===</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    m_poly </span>= np.array([1, 2, 3, 4, 5] + [0] * 251, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">int)\n    c_poly </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.encrypt(pk, m_poly)\n    d_poly </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> bfv.decrypt(sk, c_poly)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">多项式明文前5个系数: {m_poly[:5]}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">解密结果前5个系数: {d_poly[:5]}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">验证: {'成功' if np.array_equal(d_poly[:5], m_poly[:5]) else '失败'}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> <span style=\"color: rgba(128, 0, 128, 1);\">__name__</span> == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">__main__</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n    main()</span></pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<h1>3 SEAL使用</h1>\n<h2>3.1 源码编译</h2>\n<p>这里仅简单介绍下Windows下使用VS2022环境进行编译，下载源码并安装cmake，运行VS2022安装菜单下的“Developer Command Prompt for VS 2022”命令行，执行命令进行配置：</p>\n<div class=\"cnblogs_code\">\n<pre>cmake -S . -B build -G <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Visual Studio 17 2022</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> -A x64 -DCMAKE_INSTALL_PREFIX=./<span style=\"color: rgba(0, 0, 255, 1);\">out</span></pre>\n</div>\n<p>这里编译的是64位版本，并将安装目录设置为当前目录下的out文件夹，配置完成后再执行以下命令进行编译</p>\n<div class=\"cnblogs_code\">\n<pre>cmake --build build --<span style=\"color: rgba(0, 0, 0, 1);\">config Release    #编译Release版本\ncmake </span>--build build --config Debug      #编译Debug版本</pre>\n</div>\n<p>编译完成后会生成seal-4.1.lib库文件：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122113702648-1311816022.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>然后执行以下命令进行安装：</p>\n<div class=\"cnblogs_code\">\n<pre>cmake --install build</pre>\n</div>\n<p>out下include中是头文件，lib中是静态库文件：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122114032047-1402497300.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h2>3.2 示例程序</h2>\n<p>使用VS2022创建空项目，并添加demo.cpp文件，内容如下：</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_1771d7b9-7319-4893-9ce5-5347e3e25b4a\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_1771d7b9-7319-4893-9ce5-5347e3e25b4a\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_1771d7b9-7319-4893-9ce5-5347e3e25b4a\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\"> 1</span> #include &lt;iostream&gt;\n<span style=\"color: rgba(0, 128, 128, 1);\"> 2</span> #include &lt;SEAL/SEAL.h&gt;\n<span style=\"color: rgba(0, 128, 128, 1);\"> 3</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 4</span> <span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">namespace</span><span style=\"color: rgba(0, 0, 0, 1);\"> std;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 5</span> <span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">namespace</span><span style=\"color: rgba(0, 0, 0, 1);\"> seal;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 6</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 7</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> main() {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 8</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 1：配置加密参数（BFV 方案）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 9</span> <span style=\"color: rgba(0, 0, 0, 1);\">    EncryptionParameters parms(scheme_type::bfv);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">10</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 多项式模数：4096（2的幂次）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">11</span>     size_t poly_modulus_degree = <span style=\"color: rgba(128, 0, 128, 1);\">4096</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">12</span> <span style=\"color: rgba(0, 0, 0, 1);\">    parms.set_poly_modulus_degree(poly_modulus_degree);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">13</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 明文模数：支持批量运算，取值范围 2^20</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">14</span>     parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, <span style=\"color: rgba(128, 0, 128, 1);\">20</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n</span><span style=\"color: rgba(0, 128, 128, 1);\">15</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 系数模数：使用 BFV 默认参数</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">16</span> <span style=\"color: rgba(0, 0, 0, 1);\">    parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree));\n</span><span style=\"color: rgba(0, 128, 128, 1);\">17</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">18</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文模数 t = </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; parms.plain_modulus().value() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">19</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文模数 t 比特数 = </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; parms.plain_modulus().bit_count() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">20</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">t mod 2N = </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; (parms.plain_modulus().value() % (<span style=\"color: rgba(128, 0, 128, 1);\">2</span> * poly_modulus_degree)) &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">21</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">22</span>     vector&lt;Modulus&gt; coeff_mods =<span style=\"color: rgba(0, 0, 0, 1);\"> CoeffModulus::BFVDefault(poly_modulus_degree);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">23</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">24</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 系数模数 q（多素数乘积）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">25</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n系数模数 q 的构成（素数列表）：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">26</span>     <span style=\"color: rgba(0, 0, 255, 1);\">int</span> total_bits = <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">27</span>     <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (size_t i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt; coeff_mods.size(); i++<span style=\"color: rgba(0, 0, 0, 1);\">) {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">28</span>         cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">第</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; i + <span style=\"color: rgba(128, 0, 128, 1);\">1</span> &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">个素数：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> coeff_mods[i].value()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">29</span>             &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">（比特数：</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; coeff_mods[i].bit_count() &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">）</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">30</span>         total_bits +=<span style=\"color: rgba(0, 0, 0, 1);\"> coeff_mods[i].bit_count();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">31</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">32</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">系数模数总比特数 = </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; total_bits &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">33</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">34</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 2：创建加密上下文，验证参数合法性</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">35</span> <span style=\"color: rgba(0, 0, 0, 1);\">    SEALContext context(parms);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">36</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印上下文信息（可选，查看参数配置）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">37</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Context created successfully, scheme type: BFV</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">38</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">39</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 3：生成密钥（适配 SEAL 4.1 API，核心修改部分）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">40</span> <span style=\"color: rgba(0, 0, 0, 1);\">    KeyGenerator keygen(context);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">41</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4.1 版本：通过 create_public_key() 生成公钥（替代原 public_key()）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">42</span> <span style=\"color: rgba(0, 0, 0, 1);\">    PublicKey public_key;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">43</span> <span style=\"color: rgba(0, 0, 0, 1);\">    keygen.create_public_key(public_key);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">44</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4.1 版本：直接通过成员函数获取私钥（该接口未变更）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">45</span>     SecretKey secret_key =<span style=\"color: rgba(0, 0, 0, 1);\"> keygen.secret_key();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">46</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4.1 版本：通过 create_relin_keys() 生成评估密钥（替代原 relin_keys()）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">47</span> <span style=\"color: rgba(0, 0, 0, 1);\">    RelinKeys relin_keys;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">48</span> <span style=\"color: rgba(0, 0, 0, 1);\">    keygen.create_relin_keys(relin_keys);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">49</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">50</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 4：初始化加密器、解密器、评估器</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">51</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Encryptor encryptor(context, public_key);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">52</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Decryptor decryptor(context, secret_key);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">53</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Evaluator evaluator(context);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">54</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">55</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 5：明文准备（两个整数）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">56</span>     Plaintext plain1(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">123</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">57</span>     Plaintext plain2(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">456</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">58</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Original plaintext 1: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; plain1.to_string() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">59</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Original plaintext 2: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; plain2.to_string() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">60</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">61</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 6：加密明文为密文</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">62</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Ciphertext cipher1, cipher2;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">63</span> <span style=\"color: rgba(0, 0, 0, 1);\">    encryptor.encrypt(plain1, cipher1);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">64</span> <span style=\"color: rgba(0, 0, 0, 1);\">    encryptor.encrypt(plain2, cipher2);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">65</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Plaintext encrypted to ciphertext successfully</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">66</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">67</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 7：密文同态运算（加法 + 乘法）\n</span><span style=\"color: rgba(0, 128, 128, 1);\">68</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 密文加法</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">69</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Ciphertext cipher_add;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">70</span> <span style=\"color: rgba(0, 0, 0, 1);\">    evaluator.add(cipher1, cipher2, cipher_add);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">71</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 密文乘法 + 重线性化（减少密文大小）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">72</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Ciphertext cipher_mult;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">73</span> <span style=\"color: rgba(0, 0, 0, 1);\">    evaluator.multiply(cipher1, cipher2, cipher_mult);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">74</span> <span style=\"color: rgba(0, 0, 0, 1);\">    evaluator.relinearize_inplace(cipher_mult, relin_keys);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">75</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">76</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 步骤 8：解密密文，验证结果</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">77</span> <span style=\"color: rgba(0, 0, 0, 1);\">    Plaintext plain_add, plain_mult;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">78</span> <span style=\"color: rgba(0, 0, 0, 1);\">    decryptor.decrypt(cipher_add, plain_add);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">79</span> <span style=\"color: rgba(0, 0, 0, 1);\">    decryptor.decrypt(cipher_mult, plain_mult);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">80</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Ciphertext add result: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; plain_add.to_string() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">81</span>     cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Ciphertext multiply result: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; plain_mult.to_string() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">82</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\">83</span>     <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">84</span> }</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<p>将之间产生的out文件夹下的include和lib拷贝到项目文件夹下，配置项目的C/C++编译包含头文件路径，库文件路径以及输入库，即可进行编译。</p>\n<p><img alt=\"image\" height=\"434\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122114406545-2054417852.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"593\" /></p>\n<p>编译完成后运行程序，输出如下：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260122114732024-1409765149.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>在该示例程序中，多项式模数N是4096，明文模数t是1032193，位宽为20bits，系数模数q是3个素数的乘积68719403009*68719230977*137438822401=0x1ffff4400622fecd904df7f92001，位宽是109bits，示例中演示了0x123和0x456的加法和乘法运行，可见加密运算后的解密结果和未加密运算的结果完全一致。</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 15:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zhaoweiwei\">weiwei22844</a>&nbsp;\n阅读(<span id=\"post_view_count\">11</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "我的“Python海龟”诞生了一枚金蛋孵出的却是精灵",
      "link": "https://www.cnblogs.com/lixingqiu/p/19516100",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lixingqiu/p/19516100\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 11:17\">\n    <span>我的“Python海龟”诞生了一枚金蛋孵出的却是精灵</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>时光回溯到2010年，那是一个充满探索与求知的年份。在此之前，我沉浸于使用Visual Basic语言开发3D小游戏，那种在代码的世界里创造出奇妙虚拟场景的感觉，让我乐此不疲。当时，我自认为Basic已经是相当简单的计算机语言了，然而，内心深处却始终有个疑问：是否存在一种比Basic更适合少儿编程的专用计算机语言呢？</p>\n<p>带着这个疑问，我开始在网络上广泛搜寻。功夫不负有心人，我终于发现了Scratch 1.4版。这只来自美国麻省理工的“小猫咪”，瞬间吸引了我的目光，从此我便深深爱上了它。2013年，怀揣着对少儿编程教育的热情，我开设了少儿编程培训班。到了2015年，我又将Python纳入教学体系，希望能为学生们带来更丰富的编程体验。经过几年的教学实践，到2018年时，我已经自己编写了较多的青少年Python教学资料。</p>\n<p>在这个过程中，我逐渐发现Python的小海龟功能存在一定的局限性。为了深入探究其原理，我打开了它的turtle.py源代码文件，仔细研究其中的奥秘。从2019年开始，我基于Python turtle模块，踏上了开发Python精灵模块的征程。Python精灵模块的核心是设计了一个名为Sprite的类，这一创新大大增加了海龟的功能，例如实现了像素级别的碰撞检测等。如今，所有人都可以通过简单的命令“pip install sprites”来安装并使用这个强大的Python精灵模块。</p>\n<p>近几年，我将主要精力投入到信息学奥赛的教学中。每日都在“苦思冥想”各种难题，力求为学生找到更有效的学习方法。2025年8月，暑假班结束，我又开始思考一个新的问题：如果C++的入门教学能够像Python turtle一样简单易懂，那无疑会给中国所有少年带来福音。</p>\n<p>为了实现这个目标，我在GitHub上广泛寻找前人的研究成果，下载了许多用C语言或者C++开发的类turtle库。其中，有小熊猫C++库里自带的C语言海龟作图，还有GoC等相关库。我还特意购买了相关书籍，准备教授中小学生，甚至买了一本少儿3维C++编程书。然而，经过深入研究和对比，我最终并没有选择使用它们，这背后有着多方面的原因。</p>\n<p>就拿小熊猫C++库里自带的C语言海龟作图来说，其作者显然没有Python少儿编程教育的经历。我曾尝试联系作者，希望他能将里面的命令改成类似Python turtle的风格，但考虑到不能总是麻烦他人，后来也就没有再继续联系。而GoC这个库，里面的命令也没有承接自Python turtle。为了方便儿童输入字符，它将命令设计成一个字符或两个字符，比如pen.o或者pen.oo之类的。其命令相对较少，功能也不够丰富，而且主要是在线使用，作者至今似乎都没有开发自己的编辑器。以前我使用过它的离线版，还需要借助notepad++。从本质上讲，它更像是为专攻信息学奥赛设计的前置课程工具。网上有人建议一、二年级的学生就开始学习GoC，但如果不打算专攻信奥赛，其实可以不必学习。为什么呢？</p>\n<p>从大脑发育的角度来看，一、二年级的学生，他们的大脑尚处于发育阶段。科学研究表明，这个阶段的孩子，大脑的前额叶皮质尚未完全成熟，抽象思维能力相对较弱。虽然有些孩子可能在早期就展现出了较强的学习能力和天赋，如果教练眼光独到，能识别出这些苗子，让他们尝试学习GoC也未尝不可。但现实情况是，不可能每个小学生都得去专攻信息学奥赛，毕竟信奥赛的竞争十分激烈，它就是学霸们的战场。而且，对于普通学生而言，他们的少儿编程学习经历应该是丰富多彩的，不应局限于C++编程。因为学习编程的本质并非仅仅掌握某种计算机语言，而是培养逻辑思维、创造力等多方面的能力。有些人大脑发育相对迟缓一些，如果硬要他们在低年级就开始学习C++，很可能会适得其反，就是拔苗助长。根据神经科学的研究，儿童在中低年级阶段，形象思维更为活跃，此时学习图形化编程更加符合他们的认知发展规律。等到他们年龄稍大，心智更加成熟，再去学习C++也不迟。大脑需要得到多方面的刺激，才能得到充分的锻炼和发展。就像一颗种子，需要在适宜的环境中，经历不同的养分滋养，才能茁壮成长。最终，有些学生到了高中阶段，随着大脑的进一步发育和知识的积累，会突然开窍，在学习编程等方面取得更大的进步。</p>\n<p>那么，面对绝大多数的普通学生群体，他们的学习路径通常是一、二年级学习图形化编程，三、四年级学习Python编程，到了一定阶段后再学习C++编程。在这种情况下，是否存在一种针对普通学生，能够完美衔接这一课程体系的C++课程呢？据我了解，这样的课程相对比较少，即便有，可能也不公开或者需要收费。毕竟中国地域广阔，很多事情我也难以全面知晓。但不管怎样，我决定自己全新开发一个，正所谓“金窝银窝不如自己草窝”。</p>\n<p>在开发过程中，首先面临的就是选择合适的库来作为基础。如果让我的C++库基于OpenGL，虽然可行，但我需要先花费大量时间去学习它，这对于我来说，学习成本过高。于是，我找到了曾经用过的easyX，并用它开发出了原形库。然而，在使用过程中，我发现很多底层的东西我无法掌控，无奈之下只能放弃。接着，我又发现了raylib，它基于SDL2，接口众多，封装得较为复杂。随后，我注意到了SFML，这是一个很不错的库，但考虑到它已经封装了很多内容，我想要掌握更多底层技术，最终还是弃用了它。最后，我选择了工业级别的SDL2库。这个库功能相对较少，但也意味着我自己的开发自由度更大，对底层的掌控力更强。</p>\n<p>所以，现在的版本是基于SDL2库开发的。最初，我将其命名为C++ Sprites库，后来又正式命名为C++精灵库。在开发过程中，我不断地进行修改和调试，只为让普通用户能够更好地上手使用。为了让这个库更加完善，我还中途开发了pxC++编辑器，这是专门为C++精灵库量身打造的编辑器。同时，我还开发了DevC++5.11升级包，使DevC++5.11能够支持C++精灵库，从而让它更好地融入到主流的中小学生C++教学生态中。</p>\n<p>现在的C++精灵库，比较完美地继承了Python turtle的血脉。不仅如此，我还针对Python turtle存在的不足之处进行了改进与优化。例如，我精心设计了fill命令，角色通过使用fill命令，就可以在封闭区域进行洪水填充。在设定画笔颜色方面，不仅能够让角色的画笔颜色命令接受字符串作为参数，还能接受1个整数或多个整数作为参数。这是因为我对pencolor命令进行了多次重载，使其具有更高的灵活性和自由度。</p>\n<p>此外，我还为角色的画笔增添了许多实用的方法。比如，设计了设定阴影度的penshade方法，以及设定颜色饱和度的pensat方法和设定颜色明度的penvalue方法。后来又进一步设计了直接设定颜色的Hue、Saturation及Value的penhsv方法，还有修改颜色透明度的penalpha方法。不仅如此，还为角色设计了贝塞尔曲线与样条曲线等方法。这些精心设计的设定，对于审美能力强的美术生来说，无疑提供了极大的便利，使他们能够更加轻松地创作出具有艺术效果的图形。</p>\n<p>现在我们所看到的“C++精灵库”，本质上是基于logo计算机语言编程教育理念在C++世界的延伸并有所超越。它借鉴了Python turtle简洁的API，并针对教育场景进行了深入优化。这样一来，学生们就能够在一个更强大、更接近工业标准的语言环境中，充分体验到“海龟作图”的乐趣与智慧。我们可以把Python turtle和C++精灵库比作是亲兄弟，无论先学习哪一个，再去学习另一个，都会有一种“似曾相识燕归来”的熟悉感，这就是所谓的“双倍赋能”。因为编程的世界在底层本来就是相通的，当我把它们的外观也设计得相似的时候，请不要感到惊讶！</p>\n<p>更值得一提的是，由于C++精灵库是基于SDL2库进行开发的，它还能够完美融入SDL2库的命令，为学生提供更深入的编程学习机会。想象一下，SDL2库在各行各业中的广泛应用场景，C++精灵库无疑为学生的未来学习和职业发展赋予了其他类C++ turtle库无法比拟的优势。</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-22 11:17</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lixingqiu\">李兴球</a>&nbsp;\n阅读(<span id=\"post_view_count\">257</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Claude Code 支持重磅扩展 Skills —— 用最新 API 构建更靠谱的 AI 项目",
      "link": "https://www.cnblogs.com/bugshare/p/19515937",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/bugshare/p/19515937\" id=\"cb_post_title_url\" title=\"发布于 2026-01-22 10:55\">\n    <span>Claude Code 支持重磅扩展 Skills —— 用最新 API 构建更靠谱的 AI 项目</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在上一篇《<strong>Claude Code × 智谱 BigModel 实战集成指南</strong>》中，我们已经完成了一次完整的项目实战。项目<strong>可以正常运行</strong>，但在后续代码 Review 时，一个问题逐渐暴露出来：</p>\n<blockquote>\n<p><strong>生成的代码虽然能跑，但大量 API 和用法已经过时，与最新官方文档存在明显偏差。</strong></p>\n</blockquote>\n<p>这在 AI 辅助开发中其实非常常见——模型的训练数据更新速度，往往赶不上框架和 SDK 的迭代速度。</p>\n<p>正巧这时，一位朋友向我推荐了 <strong>Anthropic 最新发布的 Agent Skills</strong>，通过 <em>plugins</em> 的方式，让 Claude 在生成代码时 <strong>动态读取最新官方文档和工具能力</strong>，从而显著降低“写得像，但跑不通”的概率。</p>\n<p>本文就是这次探索的完整记录。</p>\n<hr />\n<h1 id=\"一agent-skills-是什么\">一、Agent Skills 是什么？</h1>\n<p>官方仓库地址：</p>\n<blockquote>\n<p><a href=\"https://github.com/anthropics/skills\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/skills</a></p>\n</blockquote>\n<p><strong>Agent Skills</strong> 可以理解为：</p>\n<blockquote>\n<p>一套可插拔的“能力模块”，用于教会 Claude <strong>如何用正确的方法、最新的工具、可重复的流程</strong> 来完成特定任务。</p>\n</blockquote>\n<p>在技术层面上：</p>\n<ul>\n<li>\n<p>每个 Skill 本质上是一个文件夹</p>\n</li>\n<li>\n<p>内部包含：</p>\n<ul>\n<li>指令（instructions）</li>\n<li>脚本（scripts）</li>\n<li>资源文件（resources）</li>\n</ul>\n</li>\n<li>\n<p>Claude Code 会在运行时动态加载这些 Skills</p>\n</li>\n</ul>\n<h2 id=\"它能解决什么问题\">它能解决什么问题？</h2>\n<p>Agent Skills 的核心价值在于 <strong>“降低幻觉 + 提高一致性”</strong>，典型应用场景包括：</p>\n<ul>\n<li>按公司/团队的编码规范生成代码</li>\n<li>按最新官方文档调用 API（而不是靠模型记忆）</li>\n<li>执行固定的工程化流程（初始化项目、生成目录结构、部署脚本等）</li>\n<li>自动化个人或组织级任务</li>\n</ul>\n<p>简单来说：</p>\n<blockquote>\n<p><strong>Skills 不是让模型更聪明，而是让模型更“守规矩”。</strong></p>\n</blockquote>\n<hr />\n<h1 id=\"二在-claude-code-中安装-agent-skills\">二、在 Claude Code 中安装 Agent Skills</h1>\n<p>在 Claude Code 命令行中执行：</p>\n<pre><code class=\"language-bash\">/plugin marketplace add anthropics/skills\n</code></pre>\n<p>安装完成后，你就已经具备了使用官方 Skills 的能力。</p>\n<blockquote>\n<p>这一步相当于为 Claude Code 打开了“官方增强模式”。</p>\n</blockquote>\n<p><img alt=\"PixPin_2026-01-22_10-07-25.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"三安装-context7-插件关键步骤\">三、安装 context7 插件（关键步骤）</h1>\n<p>接下来是本文的重点：<strong>context7</strong>。</p>\n<h2 id=\"1️⃣-打开插件管理\">1️⃣ 打开插件管理</h2>\n<p>在 Claude Code 中输入：</p>\n<pre><code class=\"language-shell\">/plugins\n</code></pre>\n<p>然后使用键盘 ➡️ 进入 <strong>Discover</strong>。</p>\n<h2 id=\"2️⃣-搜索并安装-context7\">2️⃣ 搜索并安装 context7</h2>\n<p>在搜索框中输入 <code>context7</code>，完成安装。</p>\n<blockquote>\n<p>context7 本质上是一个 MCP（Model Context Protocol）插件，<br />\n能让 Claude <strong>直接参考并对齐最新的官方文档内容</strong>。</p>\n</blockquote>\n<p><img alt=\"PixPin_2026-01-22_10-09-22.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"四使用-context7-生成项目代码\">四、使用 context7 生成项目代码</h1>\n<p>安装完成后，就可以在 Prompt 中显式声明使用 <code>context7</code>。</p>\n<h2 id=\"示例-prompt\">示例 Prompt</h2>\n<pre><code class=\"language-markdown\">---\nname: context7\ndescription: 使用 Context7，基于框架最新的官方文档\n---\n\n# context7\n\n## 指南\n已使用以下技术栈生成企业级项目：\n- 使用 Context7，基于最新的官方文档\n- FastAPI 0.128.0，带 Token 认证\n  - 使用 sqlite 生成 token\n  - 不使用 JWT，仅做 Token 校验\n- langchain 1.2.6，使用 create_agent\n- langchain-ollama 1.0.1\n  - model：qwen3-vl:32b\n  - embedding：qwen3-embedding:8b\n- langgraph 1.0.6\n- Milvus（pymilvus）2.6.6\n- langfuse 3.12.0\n</code></pre>\n<p>通过这种方式，你是在<strong>明确告诉 Claude</strong>：</p>\n<blockquote>\n<p>不要靠“印象”写代码，而是<strong>以当前官方文档为准</strong>。</p>\n</blockquote>\n<p><img alt=\"PixPin_2026-01-22_10-29-45.png\" class=\"lazyload\" /></p>\n<hr />\n<h1 id=\"五实际体验与问题分析\">五、实际体验与问题分析</h1>\n<h2 id=\"真实结论只有一句话\">真实结论只有一句话：</h2>\n<blockquote>\n<p><strong>效果明显提升，但依然不能“一次生成直接可用”。</strong></p>\n</blockquote>\n<h2 id=\"优点\">优点</h2>\n<ul>\n<li>API 使用明显更接近最新文档</li>\n<li>过时参数、废弃方法显著减少</li>\n<li>工程结构更合理，思路更偏向“真实项目”</li>\n</ul>\n<h2 id=\"仍然存在的问题\">仍然存在的问题</h2>\n<ul>\n<li>复杂技术栈组合（LangChain + LangGraph + Milvus + Langfuse）</li>\n<li>仍然需要 <strong>多轮调试才能完全跑通</strong></li>\n<li>某些边界用法依然存在偏差</li>\n</ul>\n<h2 id=\"我的判断\">我的判断</h2>\n<blockquote>\n<p><strong>并不是 context7 不行，而是模型生成速度，依然落后于框架演进速度。</strong></p>\n</blockquote>\n<p>context7 做到的是：</p>\n<ul>\n<li>让 Claude <em>看得到</em> 最新文档</li>\n<li>但最终“怎么拼起来”，仍然依赖模型本身的推理与代码能力</li>\n</ul>\n<hr />\n<h1 id=\"六总结\">六、总结</h1>\n<p>如果你正在使用 Claude Code 做偏工程化、偏企业级的项目开发，我的建议是：</p>\n<p>✅ <strong>一定要上 Agent Skills</strong></p>\n<p>✅ <strong>能用 context7 就用 context7</strong></p>\n<p>❌ 不要再完全相信“模型记忆里的 API”</p>\n<p>但同时也要有一个清醒认知：</p>\n<blockquote>\n<p><strong>AI 辅助开发 = 更快的起点，而不是免调试的终点。</strong></p>\n</blockquote>\n<p>在当前阶段，最理想的模式依然是：</p>\n<blockquote>\n<p><strong>AI 生成 + 人类 Review + 多轮修正</strong></p>\n</blockquote>\n<p>后续我也会继续记录 Claude Code + MCP + 多模型协作 的实践经验，欢迎关注。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-22 10:55</span>&nbsp;\n<a href=\"https://www.cnblogs.com/bugshare\">BugShare</a>&nbsp;\n阅读(<span id=\"post_view_count\">239</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}