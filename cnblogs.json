{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "STM32F4xxx系列 - DAC生成噪声波",
      "link": "https://www.cnblogs.com/marshmallows/p/19404051",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/marshmallows/p/19404051\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 16:19\">\n    <span>STM32F4xxx系列 - DAC生成噪声波</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>目标：利用定时器5（周期为5ms），从DAC1通道产生一个噪声波。<br />\n涉及知识：DAC原理、stm32中的DAC、定时器、DAC输出IO配置</p>\n<h1 id=\"1-dac原理\">1. DAC原理</h1>\n<p>DAC，是将数字输入转换成模拟输出，主要有两种实现方式：</p>\n<ol>\n<li>电阻-电位器网络 ：通过开关控制不同的电阻分压，生成对应的模拟电压。</li>\n<li>电容-二进制加权 ：<font color=\"red\">利用电容的充放电特性，快速生成模拟信号。</font></li>\n</ol>\n<h1 id=\"2-二进制加权算法\">2. 二进制加权算法</h1>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h1 id=\"3-stm32f407zg中的dac特性\">3. STM32F407ZG中的DAC特性</h1>\n<p>有2个12位的DAC模块，对应输出引脚为PA4、PA5，各2个通道。<br />\n1、可选择8/12模式，向左还是向右对齐<br />\n2、单通道模式或双通道模式<br />\n<img alt=\"{B098A18D-7151-4DF9-81BC-FA783917067D}\" class=\"lazyload\" /><br />\n3、触发方式：<br />\n自动触发、定时器触发、外部中断触发<br />\n<img alt=\"{B10CE36A-B554-45E8-9F3B-2756984D1D43}\" class=\"lazyload\" /></p>\n<p>3、输出计算方式<br />\n<img alt=\"{AB969A4A-21A6-4E2D-9A7F-CE972FC0D3B2}\" class=\"lazyload\" /></p>\n<h1 id=\"4-定时器\">4. 定时器</h1>\n<p>根据时钟树:<br />\n（1）高级定时器timer1, timer8以及通用定时器timer9, timer10, timer11 ----- APB2总线<br />\n（2）通用定时器timer2-timer5，timer12-timer14以及基本定时器timer6,timer7 ----- APB1总线</p>\n<p>（3）当APB1和APB2分频数为1，时钟频率=原频率</p>\n<p>（4）当APB1和APB2分频数不为1，时钟频率=原频率x2</p>\n<p>核心计算方式：<br />\nTout = ((arr+1)*(psc+1))/Tclk，arr为预载值，psc为分频值，Tout为时钟频率</p>\n<p>本实验使用的tim5挂载在APB1上，16位。</p>\n<h1 id=\"4-程序配置\">4. 程序配置</h1>\n<h2 id=\"41dac配置\">4.1DAC配置</h2>\n<p>在DAC.c文件中创建配置函数<br />\n1、DAC输出IO配置<br />\n为了避免寄生电流消耗，应首先将 PA4 或 PA5 引脚配置为模拟模式 (AIN)。<br />\n2、DAC转换配置<br />\n1）使能DAC时钟<br />\n2）选择DAC触发方式为timer5触发:<br />\nCR-TENx 控制位置 1，可通过外部事件<br />\nCR-TSELx[2:0] 决定通过哪一个来触发转换<br />\n<img alt=\"{23331BD1-41C3-4DC1-AD72-B12B3DD5F02D}\" class=\"lazyload\" /><br />\n<code>DAC_InitStructure.DAC_Trigger=DAC_Trigger_T5_TRGO;</code><br />\n3)选择在转换后的信号上加上伪噪声<br />\n使用 LFSR（线性反馈移位寄存器）。将 WAVEx[1:0] 置为<br />\n“01”即可选择生成噪声。<br />\n<code>DAC_InitStructure.DAC_WaveGeneration=DAC_WaveGeneration_Noise;</code><br />\n4）设置噪声的最大幅值<br />\n最大就是12位，拉满3.3v<br />\n<code>DAC_InitStructure.DAC_LFSRUnmask_TriangleAmplitude=DAC_LFSRUnmask_Bits11_0;</code><br />\n5）关闭输出缓冲<br />\n如果不需要驱动外部<br />\n6）初始化，将相应寄存器设置好<br />\n7）使能打开<br />\n完整代码：<br />\n`void DAC1_Init(void)<br />\n{<br />\nGPIO_InitTypeDef  GPIO_InitStructure;<br />\nDAC_InitTypeDef DAC_InitStructure;</p>\n<pre><code>RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);//使能GPIOA时钟\nRCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);//使能DAC时钟\n\nGPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;\nGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;//模拟输入\nGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n//GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;//浮空\nGPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化\nGPIO_SetBits(GPIOA,GPIO_Pin_4);\n\nDAC_InitStructure.DAC_Trigger=DAC_Trigger_T5_TRGO;\t//不使用触发功能 TEN1=0\nDAC_InitStructure.DAC_WaveGeneration=DAC_WaveGeneration_Noise;//不使用波形发生\nDAC_InitStructure.DAC_LFSRUnmask_TriangleAmplitude=DAC_LFSRUnmask_Bits11_0;//屏蔽、幅值设置\nDAC_InitStructure.DAC_OutputBuffer=DAC_OutputBuffer_Disable ;\t//DAC1输出缓存关闭 BOFF1=1\nDAC_Init(DAC_Channel_1,&amp;DAC_InitStructure);\t //初始化DAC通道1\n\n\n\n\nDAC_Cmd(DAC_Channel_1, ENABLE);  //使能DAC通道1\nDAC_SetChannel1Data(DAC_Align_12b_R, 0);  //12位右对齐数据格式设置DAC值\n</code></pre>\n<p>}`</p>\n<h2 id=\"42定时器配置\">4.2定时器配置</h2>\n<p>1）使能时钟<br />\n2）设置装载值：arr(不得超过16位无符号)=500-1<br />\n3）设置分频值：psc（不得超过16位无符号值）=8400-1<br />\n4）计数方式：向上计数<br />\n5）初始化<br />\n6）打开使能</p>\n<p>完整代码：</p>\n<pre><code class=\"language-c\">void Tim5_Init(uint16_t arr, uint16_t psc)\n{\n\n    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;\n\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);\n\n    TIM_TimeBaseInitStructure.TIM_Period = arr;\n\n    TIM_TimeBaseInitStructure.TIM_Prescaler = psc;\n    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;\n    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;\n\n    TIM_TimeBaseInit(TIM5, &amp;TIM_TimeBaseInitStructure);\n\n    TIM_Cmd(TIM5, ENABLE);\n\n}\n\n</code></pre>\n<h2 id=\"43定时器触发\">4.3定时器触发</h2>\n<p>定时器的框图中有一个TRGO信号输出，此信号可以用来触发ADC、DAC、其他定时器等。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p><code>TIM_SelectOutputTrigger</code><br />\n这个函数TIMx_CR2寄存器的位6到位4赋值，位6到位4是MMS[2:0]，</p>\n<p>完整代码：</p>\n<pre><code class=\"language-c\">void TIM5_TriggerInit(void)\n{\t\n\t// 定时器TIMx初始化\n\t// TIM5_Int_Init 函数已经设置好了主模式定时器TIMx的周期arr\n\t\n\t// TIMx触发其他模块的功能设置\n\t// TIM_SelectMasterSlaveMode(TIM5, TIM_MasterSlaveMode_Enable);    // 设置定时器的主从模式\n\t                                                                // 设置定时器5为主模式\n\tTIM_SelectOutputTrigger(TIM5, TIM_TRGOSource_Update);    //设置TIME输出触发为更新模式\n}\n\n\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 16:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/marshmallows\">树上掉下一只鱼</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "推荐8个牛逼的SpringBoot项目",
      "link": "https://www.cnblogs.com/12lisu/p/19405167",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19405167\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 15:35\">\n    <span>推荐8个牛逼的SpringBoot项目</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>最近两年左右的时间，我一口气肝了8个实现项目。</p>\n<p>包含了各种业界常见的技术，比如：SpringBoot、SpringCloud、SpringCloud Alibaba、Mybatis、JPA、Redis、MongoDB、ElasticSearch、MySQL、PostgreSQL、Minio、Caffine、RocketMQ、Prometheus、Grafana、ELK、skywalking、Sentinel、Nacos、Redisson、shardingsphere、HikariCP、guava、WebFlux、nacos、Sentinel、WebSocket、Gateway、Nginx、Docker、Spring AI、Spring AI Alibaba等等，非常值得一看。</p>\n<p>今天给大家介绍一下这些项目，感兴趣的小伙伴，可以一起交流学习一下，干货满满。</p>\n<h2 id=\"1-100万qps短链系统\">1 100万QPS短链系统</h2>\n<p>使用技术：JDK21、SpringBoot3.5.3、JPA、Redis、布隆过滤器、Sentinel、Nacos、Redisson、shardingsphere、HikariCP、guava、Prometheus等。</p>\n<p>目前设计了32个数据库，每个数据库包含了256张表。</p>\n<p>每天可支持2.6亿以上的数据写入。</p>\n<p>100万QPS短链系统的系统架构图如下：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>技术亮点：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>该项目的亮点是：</p>\n<ol>\n<li>使用了最新的JDK21和SpringBoot3.5.3</li>\n<li>100万QPS的超高并发请求</li>\n<li>数据库分库分表设计</li>\n<li>多级布隆过滤器设计</li>\n<li>限流和熔断的使用</li>\n<li>Redis分片集群</li>\n<li>改进后的雪花算法</li>\n<li>Redis分布式锁的使用</li>\n<li>Redis Stream的使用</li>\n<li>多级缓存设计</li>\n<li>多线程的处理</li>\n<li>完整的单元测试覆盖</li>\n<li>使用Prometheus对项目实时监控</li>\n<li>使用Grafana创建监控仪表盘</li>\n<li>使用AlertManager实现自动报警功能</li>\n<li>接入钉钉报警</li>\n<li>基于时间片的布隆过滤器</li>\n<li>系统平滑扩容</li>\n<li>基于Docker容器化部署</li>\n<li>支持多种短链生成算法</li>\n<li>接口幂等性设计</li>\n</ol>\n<p>基于时间片的布隆过滤器流程图如下：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>短链系统平滑扩容方案如下：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>通过这个项目，可以学到很多高并发、流量评估、分库分表、多级缓存、多级布隆过滤器、限流、熔断、多线程、监控、报警、数据扩容、集群、广播消息、单元测试编写等多方面的知识。</p>\n<p>目前这个项目包含两端代码：</p>\n<ol>\n<li>后端服务</li>\n<li>前端服务</li>\n</ol>\n<p>想进大厂的小伙伴们，一定不要错过这个项目，里面有很多加分项。</p>\n<h2 id=\"2-saas点餐系统\">2 SaaS点餐系统</h2>\n<p>使用技术：JDK21、SpringBoot3.4.3、SpringCloud、SpringCloud Alibaba、Gateway、Mybatis、PostgesSQL、Redis、RocketMQ、ElasticSearch、Knife4j、Prometheus、Grafana、Minio、数据隔离等。</p>\n<p>SaaS点餐系统是一套：DDD开发模式+多租户+PostgesSQL 的复杂微服务系统。</p>\n<p>包含了9个微服务。</p>\n<p>系统整体架构如下：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>数据隔离方案如下：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>DDD开发模式的代码示例：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>通过这个项目可以掌握DDD开发模型、多租户数据隔离的方案实现、PostgresSQL数据库的使用，还有微服务之间的数据交换，网关服务的统一处理，以及复杂系统的职责领域的划分。</p>\n<p>运行效果：<br />\n<img alt=\"640 (36).webp\" class=\"lazyload\" /></p>\n<h2 id=\"3-商城微服务系统\">3 商城微服务系统</h2>\n<p>susan_mall_cloud是微服务项目。</p>\n<p>使用了目前业界比较新的技术：JDK17、Spring6、SpringBoot3.3.5、SpringCloud2024、SpringCloud Alibaba2023.0.1.0。</p>\n<p>微服务后端包含了：</p>\n<ul>\n<li>susan-mall-common （公共文件）</li>\n<li>susan-mall-gateway （网关服务）</li>\n<li>susan-mall-basic (基础服务)</li>\n<li>susan-mall-auth （权限服务，包含用户和权限相关的）</li>\n<li>susan-mall-product （商品服务）</li>\n<li>susan-mall-order （订单服务）</li>\n<li>susan-mall-pay （支付服务）</li>\n<li>susan-mall-member （会员服务）</li>\n<li>susan-mall-marketing （营销服务）</li>\n<li>susan-mall-admin（后台管理系统API）</li>\n<li>susan-mall-mobile（移动端API）</li>\n</ul>\n<p>这个版本在商城已有技术基础之上，又增加了：SpringCloud Gateway、WebFlux、Seata、Skywaking、OpenFeign、Loadbalancer、Sentinel、Nacos、Canal、xxl-job、Prometheus、K8S等。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>项目架构图：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>目前包含了多端代码：</p>\n<ol>\n<li>服务端的网关服务和6个微服务。</li>\n<li>后台管理系统。</li>\n<li>uniapp小程序。</li>\n</ol>\n<p>下面是商城小程序真实的截图：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>看起来是不是非常专业？</p>\n<p>商城微服务项目很复杂，包含了目前业界微服务分布式系统中使用最主流的技术，强烈推荐一下。</p>\n<p>无论在工作中，还是面试中，都可以作为加分项。</p>\n<p>特别是SpringCloud Gateway中WebFlux的使用，微服务之间的异常处理，以及微服务之间的通信，都很值得一看。</p>\n<h2 id=\"4-商城系统\">4 商城系统</h2>\n<p>商城系统目前包含了：SpringBoot后端 + Vue管理后台 + uniapp小程序 ，三个端的完整代码。</p>\n<p>商城项目中包含了：基于Docker部署教程、域名解析教程、按环境隔离、网络爬虫、推荐算法、支付宝支付、分库分表、分片算法优化、手写动态定时任务、手写通用分页组件、JWT登录验证、数据脱敏、动态workId、hanlp敏感词校验，手写分布式ID生成器、分布式限流、手写Mybatis插件、两级缓存提升性能、MQ消息通信、ES商品搜索、OSS服务对接、失败自动重试机制、接口幂等性处理、百万数据excel导出、WebSocket消息推送、用户异地登录检测、freemarker模版邮件发送、代码生成工具、重复请求自动拦截、自定义金额校验注解等等一系列功能。</p>\n<p>使用的技术：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>商城系统的系统架构图如下：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>包含了：</p>\n<ul>\n<li>应用层：小程序、移动端H5、管理后台</li>\n<li>网关层：Nginx反向代理和负载均衡</li>\n<li>服务层：API服务、Job服务 &amp; mq消费者服务</li>\n<li>数据存储层：susan_mall库MySQL主从、susan_mall_order库MySQL分库分表、MongoDB保存商品详情、Minio存储文件</li>\n<li>中间件层：Redis集群、RocketMQ、ElasticSearch、Nacos（注册中间 &amp; 配置中心）</li>\n</ul>\n<p>商城系统的技术架构图如下：<br />\n<img alt=\"\" class=\"lazyload\" /><br />\n使用的都是目前业界非常主流和常用的技术，这些技术大部分公司目前都在使用。</p>\n<p>商城系统可以帮你真正增加很多企业级项目经验。</p>\n<p>功能亮点：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>商城项目无论是毕业设计，还是面试，还是实际工作中，都非常值得一看。</p>\n<p>商城项目使用了目前非常主流的技术，手写了很多底层的代码，设计模式、自定义了很多拦截器、过滤器、转换器、监听器等，很多代码可以搬到实际的工作中。</p>\n<p>目前星球中包含了商城项目从0~1的完整开发教程，小白也可以直接上手。</p>\n<p>星球中有些小伙伴，通过这个项目拿到了非常不错的offer。</p>\n<h2 id=\"5-秒杀系统\">5. 秒杀系统</h2>\n<p>苏三的秒杀系统是专门为高并发而生的。</p>\n<p>目前使用的技术有：SpringBoot、Redis、Redission、lua、RocketMQ、ElasticSearch、JWT、freemarker、themelaf、html、vue、element-ui等。</p>\n<p>功能包括：商品预热、商品秒杀、分布式锁、MQ异步下单、限流、失败重试、预扣库存、数据一致性处理等。<br />\n<img alt=\"\" class=\"lazyload\" /><br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>涉及到了高并发的多种技术，特别是对页面静态化，倒计时、秒杀按钮控制、分布式锁、预扣库存、MQ处理、数据一致性等，会有比较大的收获。</p>\n<p>秒杀系统的系统架构图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>可以帮你增加高并发的工作经验，也可以写到你的简历中。</p>\n<p>秒杀系统在面试或者工作中，会经常遇到，非常有参考价值。</p>\n<h2 id=\"6-刷题吧小程序\">6 刷题吧小程序</h2>\n<p>IT刷题吧是我用AI花了几天时间，设计和开发了一款小程序。</p>\n<p>效果图如下：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>为了帮助大家能够快速的掌握使用AI开发项目的技巧，提升开发效率，能够先人一步，变成全栈开发工程师。</p>\n<p>无论是自己接私活，还是开发公司的项目，都能够用更少的时间，写出更多，更有价值的代码。</p>\n<p>苏三在知识星球中给小伙伴们，通过IT刷题吧项目，专门开设了一个AI开发课程。</p>\n<p>你看完之后，会发现打开了一扇通向新世界的大门。（有很多惊喜）</p>\n<p>这个课程会包含如下内容：</p>\n<ul>\n<li>如何用AI设计产品原型的？</li>\n<li>如何用AI生成小程序端和后端的代码结构的？</li>\n<li>如何用AI生成后端的表结构？</li>\n<li>如何用AI生成小程序和后端代码？</li>\n<li>如何生成一套完整的可运行的代码？</li>\n<li>如何基于图片生成想要的代码？</li>\n<li>如何搞定小程序页面中的图片问题？</li>\n<li>如何让小程序端和后端代码调通？</li>\n<li>生成的代码不理想怎么办？</li>\n<li>如果在开发过程中遇到了一些问题，用AI如何解决问题？</li>\n<li>如何生成测试数据？</li>\n<li>如何制定代码开发规范？</li>\n<li>AI开发工具的使用方法</li>\n<li>AI开发工具卡顿怎么办？</li>\n<li>如何运行项目？</li>\n<li>如何上线部署项目？<br />\n等等。。。</li>\n</ul>\n<p>星球中会交付如下内容：</p>\n<ol>\n<li>IT刷题吧小程序</li>\n<li>SpringBoot后端代码</li>\n<li>用AI开发项目的完整流程</li>\n</ol>\n<p>目前已经全部开发完。</p>\n<p>使用AI开发这个项目，从0~1的开发和部署教程。<br />\n问题答疑。<br />\n通过这个项目，你可以学到使用AI开发项目的具体方法。</p>\n<p>如果你掌握了这些方法，开发其他的小程序绰绰有余。</p>\n<p>这个项目有极大的价值。</p>\n<p>授人予鱼，不如授人以渔。</p>\n<p>光是学会这个项目，就有极大的价值。</p>\n<h2 id=\"7-苏三的demo项目\">7. 苏三的demo项目</h2>\n<p>这个项目包含了一些工作中常用的技术点，有很多非常有参考价值的示例。</p>\n<p>涵盖：Spring、Mybatis、多线程、事务、常用工具、设计模式、http请求、lamda、io、excel、泛型、注解等多个方面。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>本项目的宗旨是分享实际工作中，非常实用的代码技巧，能够让你写出更优雅高效的代码。</p>\n<p>此外，后面会收录一下面试中，尤其是笔试中经常会被问题到的代码片段和算法。</p>\n<h2 id=\"8-代码生成器项目\">8. 代码生成器项目</h2>\n<p>这是一个基于Spring Boot的智能代码生成器，能够根据数据库表结构自动生成完整的Java Web项目代码，极大提升开发效率，让开发者专注于业务逻辑而非重复的CRUD代码编写。</p>\n<p>我们用这个代码生成器，可以通过数据库表，一键直接生成controller、service、mapper、entity、菜单sql、vue页面等。</p>\n<p>使用的技术：SpringBoot、MyBatis、Apache Velocity、Swagger2、Lombok、Druid、Maven等。</p>\n<p>我们在日常开发中，把数据库表设计好了之后，然后通过该工具，能够快速生成一个可以直接运行的CRUD代码。</p>\n<p><img alt=\"\" class=\"lazyload\" /><br />\n毫不夸张的说，如果在项目中使用它，可以让你的开发效率快速提升，我们真的可以少写30%的代码。</p>\n<p><img alt=\"640 (37).webp\" class=\"lazyload\" /></p>\n<p><img alt=\"640 (38).webp\" class=\"lazyload\" /></p>\n<p>在实际工作中，非常有价值。</p>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n<p>更多项目实战在我的技术网站：<a href=\"http://www.susan.net.cn/project\" rel=\"noopener nofollow\" target=\"_blank\">http://www.susan.net.cn/project</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 15:35</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">107</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Flask页面跳转实战指南：五种方式与不同应用场景下的最佳选择",
      "link": "https://www.cnblogs.com/ymtianyu/p/19404968",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19404968\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 15:11\">\n    <span>Flask页面跳转实战指南：五种方式与不同应用场景下的最佳选择</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Flask页面跳转是Web开发中的基础但关键技能，本文系统讲解了五种常用跳转方式：后端redirect、前端a标签、form表单提交、JS fetch API交互，并重点对比了后端redirect与前端window.location.href的区别与适用场景。通过实际代码示例帮助开发者根据具体需求选择最合适的跳转策略，提升应用性能和用户体验。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<p>你在Flask开发中是否经常为页面跳转逻辑混乱而头疼？<strong style=\"color: rgba(186, 55, 42, 1);\">据统计，70%的Web应用性能问题源于不当的跳转处理</strong>，导致页面加载慢、用户体验差甚至安全漏洞！</p>\n<div style=\"background-color: rgba(248, 249, 250, 1); padding: 15px; margin: 20px 0; font-size: 14px;\">\n<p style=\"margin: 0; font-style: italic;\">本文带你深入理解Flask中的五种核心跳转方式，从基础到进阶，帮你彻底理清跳转逻辑。你将掌握：后端redirect的适用场景、前端a标签和form表单的经典用法、JS fetch API的现代交互方式，以及最关键的选择策略——什么情况下该用后端redirect，什么情况下该用前端window.location.href。</p>\n<br />\n<p style=\"margin: 0; font-weight: bold;\">目录一览：</p>\n<p style=\"margin: 5px 0;\">- ✨ Flask页面跳转为什么重要</p>\n<p style=\"margin: 5px 0;\">- 🔄 后端redirect跳转：Flask的核心武器</p>\n<p style=\"margin: 5px 0;\">- 🏷️ 前端a标签跳转：最简单的导航方式</p>\n<p style=\"margin: 5px 0;\">- 📝 前端form表单跳转：传统但有效的提交方式</p>\n<p style=\"margin: 5px 0;\">- ⚡ JS fetch访问API后的跳转：现代Web应用的选择</p>\n<p style=\"margin: 5px 0;\">- 🤔 关键对比：redirect vs window.location.href</p>\n<p style=\"margin: 5px 0;\">- 💻 完整实战代码示例</p>\n</div>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">✨ Flask页面跳转为什么重要</h2>\n<p>页面跳转是Web应用的“导航系统”，它决定了用户如何在不同页面间流动。在Flask中，跳转逻辑不仅影响用户体验，还关系到<strong style=\"color: rgba(186, 55, 42, 1);\">数据流、安全性、性能和后端负载</strong>。一个合理的跳转策略能让应用如丝般顺滑，而混乱的跳转则会让用户迷失在加载圈中。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🔄 后端redirect跳转：Flask的核心武器</h2>\n<p>这是Flask中最经典的跳转方式，通过<code>redirect()</code>函数实现。当后端处理完请求后，<strong style=\"color: rgba(186, 55, 42, 1);\">服务器会返回一个302重定向响应</strong>，告诉浏览器“请去另一个地址”。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from flask import Flask, redirect, url_for\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    # 验证用户逻辑\n    if login_success:\n        # 重定向到主页\n        return redirect(url_for('home'))\n    else:\n        return redirect(url_for('login_page'))</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">适用场景：</strong>表单提交后的页面跳转、用户认证后的定向、URL规范化等。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">优点：</strong>完全由服务器控制，安全可靠，能处理复杂业务逻辑。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">缺点：</strong>需要完整的页面刷新，用户体验可能不够流畅。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🏷️ 前端a标签跳转：最简单的导航方式</h2>\n<p>这是最基础的前端跳转，直接在HTML中使用<code>&lt;a&gt;</code>标签。当用户点击链接时，<strong style=\"color: rgba(186, 55, 42, 1);\">浏览器会直接发起GET请求并加载新页面</strong>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>&lt;!-- 在Flask模板中 --&gt;\n&lt;a href=\"{{ url_for('about') }}\"&gt;关于我们&lt;/a&gt;\n&lt;a href=\"/contact\"&gt;联系我们&lt;/a&gt;</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">适用场景：</strong>普通导航链接、静态页面跳转。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">注意：</strong>这是<strong style=\"color: rgba(186, 55, 42, 1);\">客户端行为</strong>，不经过后端逻辑处理。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">📝 前端form表单跳转：传统但有效的提交方式</h2>\n<p>通过form的<code>action</code>属性指定提交地址，<code>method</code>决定请求类型（GET或POST）。提交后，<strong style=\"color: rgba(186, 55, 42, 1);\">浏览器会加载action指定的页面</strong>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>&lt;form action=\"{{ url_for('submit_form') }}\" method=\"POST\"&gt;\n    &lt;input type=\"text\" name=\"username\"&gt;\n    &lt;button type=\"submit\"&gt;提交&lt;/button&gt;\n&lt;/form&gt;</code></pre>\n<p>在Flask后端，你可以这样处理：</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.route('/submit', methods=['POST'])\ndef submit_form():\n    username = request.form.get('username')\n    # 处理数据...\n    return redirect(url_for('result_page'))  # 通常配合redirect使用</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">适用场景：</strong>数据提交、搜索功能、传统多步骤表单。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">⚡ JS fetch访问API后的跳转：现代Web应用的选择</h2>\n<p>这是现代单页应用（SPA）或富交互应用的常见模式：<strong style=\"color: rgba(186, 55, 42, 1);\">前端通过fetch（或axios）调用后端API，根据返回结果决定是否跳转</strong>。</p>\n<p>前端JavaScript代码：</p>\n<pre class=\"language-python highlighter-hljs\"><code>// 使用fetch调用登录API\nfetch('/api/login', {\n    method: 'POST',\n    headers: {'Content-Type': 'application/json'},\n    body: JSON.stringify({username: 'user', password: 'pass'})\n})\n.then(response =&gt; response.json())\n.then(data =&gt; {\n    if (data.success) {\n        // 前端控制跳转\n        window.location.href = '/dashboard';\n    } else {\n        alert('登录失败');\n    }\n});</code></pre>\n<p>后端Flask API：</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.route('/api/login', methods=['POST'])\ndef api_login():\n    data = request.get_json()\n    # 验证逻辑\n    if valid_user(data):\n        return jsonify({'success': True, 'message': '登录成功'})\n    else:\n        return jsonify({'success': False, 'message': '验证失败'}), 401</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">关键点：</strong>这里API返回的是JSON数据，<strong style=\"color: rgba(186, 55, 42, 1);\">而不是redirect响应</strong>。跳转逻辑完全由前端JavaScript控制。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🤔 关键对比：redirect vs window.location.href</h2>\n<p>这是本文最核心的部分！很多人混淆这两种方式，其实它们有本质区别：</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">1. 后端redirect（在Flask API中调用redirect）：</strong></p>\n<p>- 服务器返回的是<code>302重定向响应</code>，浏览器会自动跳转</p>\n<p>- 跳转地址在HTTP响应头中（Location字段）</p>\n<p>- 适用于传统的同步请求，如form提交</p>\n<p>- 示例：<code>return redirect(url_for('home'))</code></p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">2. 前端window.location.href（在JavaScript中控制）：</strong></p>\n<p>- 服务器返回的是<code>正常响应（如JSON）</code>，浏览器不自动跳转</p>\n<p>- 前端JS根据响应内容<strong style=\"color: rgba(186, 55, 42, 1);\">主动执行</strong>跳转</p>\n<p>- 适用于异步请求（AJAX/fetch），实现无刷新交互</p>\n<p>- 示例：<code>window.location.href = '/dashboard'</code></p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">选择策略：</strong></p>\n<p>- 如果你的应用是<strong style=\"color: rgba(186, 55, 42, 1);\">传统多页面应用</strong>，使用form+redirect组合</p>\n<p>- 如果你需要<strong style=\"color: rgba(186, 55, 42, 1);\">无刷新交互</strong>（如部分更新、实时验证），使用fetch+window.location.href</p>\n<p>- 如果跳转<strong style=\"color: rgba(186, 55, 42, 1);\">依赖复杂后端逻辑</strong>（如权限检查），优先考虑后端redirect</p>\n<p>- 如果追求<strong style=\"color: rgba(186, 55, 42, 1);\">最佳用户体验和性能</strong>，现代应用倾向于前端控制跳转</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">💻 完整实战代码示例</h2>\n<p>下面是一个完整的Flask应用，演示了所有跳转方式：</p>\n<pre class=\"language-python highlighter-hljs\"><code>from flask import Flask, render_template, request, redirect, url_for, jsonify\n\napp = Flask(__name__)\n\n# 1. 基础页面\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/about')\ndef about():\n    return '关于页面'\n\n# 2. 传统form提交 + redirect\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        # 简单的验证逻辑\n        if request.form.get('username') == 'admin':\n            return redirect(url_for('dashboard'))  # 后端redirect\n        else:\n            return redirect(url_for('login'))\n    return render_template('login.html')\n\n# 3. API端点 + 前端控制跳转\n@app.route('/api/checkout', methods=['POST'])\ndef api_checkout():\n    data = request.get_json()\n    # 处理订单逻辑\n    if data.get('confirmed'):\n        return jsonify({\n            'success': True,\n            'redirect_url': url_for('order_success')\n        })\n    else:\n        return jsonify({'success': False}), 400\n\n@app.route('/dashboard')\ndef dashboard():\n    return '用户仪表板'\n\n@app.route('/order-success')\ndef order_success():\n    return '订单成功页面'\n\nif __name__ == '__main__':\n    app.run(debug=True)</code></pre>\n<p>对应的HTML模板（index.html）示例：</p>\n<pre class=\"language-html highlighter-hljs\"><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Flask跳转演示&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;跳转方式演示&lt;/h1&gt;\n    \n    &lt;!-- 1. a标签跳转 --&gt;\n    &lt;p&gt;&lt;a href=\"/about\"&gt;关于我们（a标签）&lt;/a&gt;&lt;/p&gt;\n    \n    &lt;!-- 2. form表单跳转 --&gt;\n    &lt;form action=\"/login\" method=\"POST\"&gt;\n        &lt;input type=\"text\" name=\"username\" placeholder=\"用户名\"&gt;\n        &lt;button type=\"submit\"&gt;传统登录&lt;/button&gt;\n    &lt;/form&gt;\n    \n    &lt;!-- 3. JS fetch + 前端跳转 --&gt;\n    &lt;button onclick=\"checkout()\"&gt;API下单（无刷新）&lt;/button&gt;\n    \n    &lt;script&gt;\n    function checkout() {\n        fetch('/api/checkout', {\n            method: 'POST',\n            headers: {'Content-Type': 'application/json'},\n            body: JSON.stringify({confirmed: true})\n        })\n        .then(res =&gt; res.json())\n        .then(data =&gt; {\n            if (data.success) {\n                // 前端控制跳转\n                window.location.href = data.redirect_url;\n            }\n        });\n    }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>通过这个完整示例，你可以清楚地看到每种跳转方式在实际项目中的应用场景和代码写法。</p>\n<div style=\"text-align: center; margin: 40px 0;\"><hr style=\"border-right: none; border-bottom: none; border-left: none; width: 80%; margin: 0 auto;\" /></div>\n<div style=\"text-align: center; font-size: 14px; color: rgba(127, 140, 141, 1); margin-top: 30px;\">\n<p>喜欢本文？不要错过✨，点赞👍收藏⭐关注我👆，一起学习更多有用的知识，完善你我的技能树！</p>\n</div>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 15:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">曲幽</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "APEX实战第8篇：ORDS连库报错574？一招根治用户过期问题",
      "link": "https://www.cnblogs.com/jyzhao/p/19404888/apex-shi-zhan-di8pianords-lian-ku-bao-cuo574-yi-zh",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jyzhao/p/19404888/apex-shi-zhan-di8pianords-lian-ku-bao-cuo574-yi-zh\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 15:08\">\n    <span>APEX实战第8篇：ORDS连库报错574？一招根治用户过期问题</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2025-12-26 15:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jyzhao\">AlfredZhao</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>作为 APEX 应用开发工程师，笔者发现很多同行在使用 APEX + ORDS 架构时，都会遇到数据库凭证错误相关的问题。之前大家普遍知道 APEX_PUBLIC_USER 需要设置密码永不过期，但往往会忽略另一个关键用户——ORDS_PUBLIC_USER，这也是导致 Database Credential Error 和 HTTP Status Code: 574 问题反复出现的核心原因。</p>\n<p>今天笔者就结合自己的踩坑经历，把 ORDS_PUBLIC_USER 相关的问题解决流程完整分享出来，帮大家快速解决问题，避免重复踩坑。</p>\n<h2 id=\"01--先明确问题ords-连不上数据库报错到底啥意思\">01 | 先明确问题：ORDS 连不上数据库，报错到底啥意思？</h2>\n<p>当你启动 ORDS 后，访问 APEX 应用或 ORDS 接口时，可能会遇到这样的错误提示：</p>\n<blockquote>\n<p>ORDS was unable to make a connection to the database. The database user specified by db.username configuration setting is expired. The connection pool named: |default|lo| had the following error(s): UCP-29: Failed to get a connection</p>\n</blockquote>\n<p><img alt=\"ords1\" src=\"https://img2024.cnblogs.com/blog/635610/202512/635610-20251226145736856-1853445170.jpg\" /></p>\n<p>简单说，就是 ORDS 配置的数据库用户过期了，导致连接池拿不到连接。这里的关键用户，就是我们今天的主角——ORDS_PUBLIC_USER。</p>\n<p>很多同学之前只关注了 APEX_PUBLIC_USER，却不知道 ORDS 正常运行也依赖专属的 ORDS_PUBLIC_USER，这个用户默认使用数据库的 DEFAULT 密码策略，一旦密码过期，就会触发上述错误。</p>\n<h2 id=\"02--解决步骤从定位问题到彻底解决一步都不能少\">02 | 解决步骤：从定位问题到彻底解决，一步都不能少</h2>\n<p>下面笔者就把完整的解决流程拆解开，每个步骤都讲清楚操作方法和注意事项，小白也能跟着做。</p>\n<h3 id=\"-第一步定位问题用户确认是-ords_public_user-过期\">① 第一步：定位问题用户，确认是 ORDS_PUBLIC_USER 过期</h3>\n<p>首先我们需要通过 ORDS 命令，确认配置的数据库用户到底是谁，避免操作错用户。</p>\n<p>在命令行执行以下命令：</p>\n<pre><code class=\"language-bash\">ords config list\n</code></pre>\n<p>这个命令会列出 ORDS 的所有配置信息，找到<code>db.username</code> 对应的 value 值，不出意外的话，会显示<code>ORDS_PUBLIC_USER</code>，这就确认了是这个用户过期导致的问题。</p>\n<h3 id=\"-第二步给-ords_public_user-配置永不过期策略\">② 第二步：给 ORDS_PUBLIC_USER 配置永不过期策略</h3>\n<p>既然是密码过期问题，核心就是给 ORDS_PUBLIC_USER 设置密码永不过期的策略。这里笔者假设你已经创建好了名为 <code>PASSWORD_UNLIMITED</code> 的永不过期配置文件（如果没有，可先执行 <code>CREATE PROFILE PASSWORD_UNLIMITED LIMIT PASSWORD_LIFE_TIME UNLIMITED PASSWORD_GRACE_TIME UNLIMITED;</code> 创建）。</p>\n<p>以 SYSDBA 身份登录数据库，执行以下 SQL 命令：</p>\n<pre><code class=\"language-sql\">alter user ORDS_PUBLIC_USER profile PASSWORD_UNLIMITED;\n</code></pre>\n<p>这一步的作用是把 ORDS_PUBLIC_USER 关联到永不过期的配置文件，从根源上避免后续再次过期。</p>\n<h3 id=\"-第三步重启-ords-测试发现新问题\">③ 第三步：重启 ORDS 测试，发现新问题</h3>\n<p>配置完永不过期策略后，我们重启 ORDS 看看效果，执行命令：</p>\n<pre><code class=\"language-bash\"># 1. 查找 ORDS 进程并终止\nps -ef | grep ords\n# 找到进程号（第二列数字），执行 kill 命令终止进程\nkill -9 进程号\n\n# 2. 后台启动 ORDS 并将日志输出到 ords.log 文件\nnohup ords serve &gt; ords.log &amp;\n</code></pre>\n<p>此时大概率会发现，错误变了！新错误提示为：</p>\n<blockquote>\n<p>ORA-28001: The account has expired.</p>\n</blockquote>\n<p>这是因为我们虽然修改了密码策略，但已经过期的账号状态不会自动恢复。这时候有同学会尝试用 <code>ALTER USER ORDS_PUBLIC_USER ACCOUNT UNLOCK;</code>命令解锁，但笔者亲测，这个命令对已经过期的账号状态无效，无法将其从 expired 改为 open。</p>\n<h3 id=\"-第四步重置-ords_public_user-密码恢复账号状态\">④ 第四步：重置 ORDS_PUBLIC_USER 密码，恢复账号状态</h3>\n<p>要彻底解除 expired 状态，必须重置 ORDS_PUBLIC_USER 的密码。以 SYSDBA 身份登录数据库，执行以下 SQL 命令：</p>\n<pre><code class=\"language-sql\">ALTER USER ORDS_PUBLIC_USER identified by \"newpassword\";\n</code></pre>\n<p>注意：这里的 <code>newpassword</code> 替换成你自己的密码，建议设置一个复杂度高、不容易忘记的密码，比如 <code>Ords_2025@Pub</code>（包含大小写、数字和特殊字符）。</p>\n<p>执行完这个命令后，ORDS_PUBLIC_USER 的账号状态就会恢复为 open，过期问题就解决了。</p>\n<h3 id=\"-第五步关键坑点用正确命令同步-ords-密码配置\">⑤ 第五步：关键坑点！用正确命令同步 ORDS 密码配置</h3>\n<p>重置完数据库用户密码后，很多同学会直接重启 ORDS，但此时会遇到新的错误：</p>\n<blockquote>\n<p>The connection pool named: |default|lo| had the following error(s): ORA-01017: invalid credential or not authorized; logon denied</p>\n</blockquote>\n<p>这是因为 ORDS 配置里的密码还是旧的，没有同步我们刚重置的新密码。这里要重点提醒大家，不同 ORDS 版本设置密码的命令不一样！</p>\n<p>笔者使用的是 ORDS 25.1 版本，这个版本及以后的新版本，敏感配置（比如密码）必须用 <code>secret</code> 子命令设置，普通的 <code>ords config set db.password</code> 命令会失效。</p>\n<p>正确的操作是在命令行执行：</p>\n<pre><code class=\"language-bash\">ords config secret db.password\n</code></pre>\n<p>执行后会提示你输入密码，直接输入我们刚才重置的 <code>newpassword</code> 即可（交互式输入更安全，避免密码暴露在命令行历史记录中）。</p>\n<p>如果你的 ORDS 版本较低（比如 21 之前），可能需要用 <code>ords config set db.password \"newpassword\"</code>，但建议优先用 <code>secret</code> 命令，更符合安全规范。</p>\n<h3 id=\"-第六步最终测试确认问题解决\">⑥ 第六步：最终测试，确认问题解决</h3>\n<p>完成密码同步后，我们再次重启 ORDS：</p>\n<pre><code class=\"language-bash\"># 1. 查找 ORDS 进程并终止\nps -ef | grep ords\nkill -9 进程号\n\n# 2. 后台启动 ORDS\nnohup ords serve &gt; ords.log &amp;\n</code></pre>\n<p>此时访问 APEX 应用或 ORDS 接口，就不会再出现之前的数据库连接错误了。为了确保万无一失，也可以通过以下方式验证 ORDS 状态：</p>\n<pre><code class=\"language-bash\"># 方式1：查看 ORDS 进程是否存在（确认启动成功）\nps -ef | grep ords\n\n# 方式2：查看 ORDS 日志，确认无报错\ntail -f ords.log\n\n# 方式3：查看 ORDS 配置信息，确认核心配置正确\nords config list\n</code></pre>\n<p>如果通过 ps 命令能看到 ORDS 进程，且日志中无数据库连接相关报错，就说明 ORDS 正常运行，问题彻底解决。</p>\n<h2 id=\"03--避坑指南这些关键要点帮你避免重复踩坑\">03 | 避坑指南：这些关键要点，帮你避免重复踩坑</h2>\n<p>在解决问题的过程中，笔者踩了几个坑，这里总结出来，帮大家少走弯路：</p>\n<h3 id=\"-不要只关注-apex_public_user忽略-ords_public_user\">① 不要只关注 APEX_PUBLIC_USER，忽略 ORDS_PUBLIC_USER</h3>\n<p>APEX_PUBLIC_USER 是 APEX 应用的核心用户，ORDS_PUBLIC_USER 是 ORDS 服务的核心用户，两者缺一不可。建议在安装配置初期，就同时给这两个用户设置永不过期策略，一劳永逸。</p>\n<h3 id=\"-账号过期后仅解锁无效必须重置密码\">② 账号过期后，仅解锁无效，必须重置密码</h3>\n<p>很多同学误以为 <code>ALTER USER ... ACCOUNT UNLOCK</code> 能解决过期问题，但实际上这个命令只能解决账号锁定问题，无法解除过期状态。过期状态必须通过重置密码才能恢复，这一步不能省。</p>\n<h3 id=\"-注意-ords-版本差异密码配置命令要选对\">③ 注意 ORDS 版本差异，密码配置命令要选对</h3>\n<p>ORDS 21 版本及以后，敏感配置必须用<code>ords config secret</code> 命令设置，普通的 <code>set</code> 命令无效；另外要注意，ORDS 没有 <code>status</code> 命令，无法直接查看运行状态，需通过查看进程、日志或配置信息验证。如果设置密码后仍报错，先检查自己的 ORDS 版本和配置是否正确。</p>\n<h3 id=\"-密码要保持一致数据库用户密码--ords-配置密码\">④ 密码要保持一致：数据库用户密码 ≡ ORDS 配置密码</h3>\n<p>重置 ORDS_PUBLIC_USER 的数据库密码后，一定要同步更新 ORDS 配置里的密码，两者必须完全一致（包括大小写、特殊字符），否则会报 ORA-01017 认证失败错误。</p>\n<h2 id=\"04--总结一劳永逸的核心方案\">04 | 总结：一劳永逸的核心方案</h2>\n<p>其实解决这个问题的核心很简单：给 ORDS_PUBLIC_USER 配置永不过期的密码策略，同时确保 ORDS 配置里的密码与数据库用户密码一致。</p>\n<p>完整流程可以简化为：定位用户 → 配置永不过期策略 → 重置密码 → 同步 ORDS 密码配置 → 重启 ORDS。</p>\n<p>建议大家在搭建 APEX + ORDS 环境时，就提前完成这两个用户（APEX_PUBLIC_USER、ORDS_PUBLIC_USER）的永不过期配置，避免后续运行中突然出现问题，影响业务使用。</p>\n<p>如果大家在操作过程中遇到其他问题，欢迎在评论区留言交流，笔者会尽力为大家解答～</p>\n\n</div>\n<div id=\"MySignature\">\n    <a href=\"https://www.cnblogs.com/jyzhao/\" target=\"_blank\">AlfredZhao</a>©版权所有「从Oracle起航，领略精彩的IT技术。」<br />\n转载请注明原文链接：<a href=\"https://www.cnblogs.com/jyzhao/p/19404888/apex-shi-zhan-di8pianords-lian-ku-bao-cuo574-yi-zh\" target=\"_blank\">https://www.cnblogs.com/jyzhao/p/19404888/apex-shi-zhan-di8pianords-lian-ku-bao-cuo574-yi-zh</a>\n<hr />\n<div style=\"text-align: center; margin-top: 30px;\">\n  <p style=\"font-size: 14px; color: #555;\">\n    👋 感谢阅读，欢迎关注我的公众号 <b>「赵靖宇」</b>\n  </p>\n  <img src=\"https://images.cnblogs.com/cnblogs_com/jyzhao/824234/o_250208075013_qrcode-zjy.jpg\" style=\"border: 1px solid #ddd; border-radius: 8px;\" width=\"160\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "性能_安全_跨端",
      "link": "https://www.cnblogs.com/ggonekim/p/19404892",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ggonekim/p/19404892\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 14:59\">\n    <span>性能_安全_跨端</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前端性能优化与安全总结\">前端性能优化与安全总结</h1>\n<h2 id=\"一性能优化\">一、性能优化</h2>\n<h3 id=\"1-优化方向概览\">1. 优化方向概览</h3>\n<ul>\n<li><strong>空间优化</strong>：减少请求文件体积<br />\n包括压缩文件、构建时优化等。</li>\n<li><strong>时间优化</strong>：提升请求、加载、渲染与执行效率<br />\n涉及请求速度、加载优先级、渲染优化、代码运行效率、缓存策略等。</li>\n<li><strong>用户感知优化</strong>：提升用户体验<br />\n如骨架屏、加载状态提示、错误降级等。</li>\n</ul>\n<hr />\n<h3 id=\"2-技术细分\">2. 技术细分</h3>\n<h4 id=\"1网络层面\">（1）网络层面</h4>\n<ul>\n<li><strong>减少请求数量</strong><br />\n合并文件、使用精灵图（Sprite）。</li>\n<li><strong>减少请求体积</strong><br />\n压缩资源（Gzip/Brotli）、构建优化（Tree Shaking、代码分割）。</li>\n<li><strong>加快请求速度</strong><br />\nCDN 加速、DNS 预解析、预连接（<code>preconnect</code>）。</li>\n</ul>\n<h4 id=\"2加载层面lcp-优化\">（2）加载层面（LCP 优化）</h4>\n<ul>\n<li>关键资源优先加载</li>\n<li>预加载（<code>preload</code>、<code>prefetch</code>）</li>\n<li>懒加载（图片、组件、路由）</li>\n</ul>\n<h4 id=\"3渲染层面\">（3）渲染层面</h4>\n<ul>\n<li><strong>首屏渲染优化</strong><br />\n服务端渲染（SSR）、静态生成（SSG）。</li>\n<li><strong>视觉稳定性（CLS）</strong><br />\n避免布局抖动（预留尺寸、使用 <code>aspect-ratio</code>）。</li>\n<li><strong>动画流畅性</strong><br />\n使用合成层（<code>transform</code>、<code>opacity</code>），开启 <code>will-change</code>。</li>\n</ul>\n<h4 id=\"4运行时层面inp-优化\">（4）运行时层面（INP 优化）</h4>\n<ul>\n<li><strong>JavaScript 执行优化</strong><br />\n避免长任务、使用 <code>requestIdleCallback</code>、异步加载非关键脚本。</li>\n<li><strong>内存管理</strong><br />\n虚拟列表、避免内存泄漏、及时释放引用。</li>\n<li><strong>事件处理优化</strong><br />\n节流（throttle）、防抖（debounce）、事件委托。</li>\n</ul>\n<h4 id=\"5缓存层面\">（5）缓存层面</h4>\n<ul>\n<li>静态资源缓存（强缓存、协商缓存）</li>\n<li>数据缓存（Service Worker、内存缓存）</li>\n<li>离线缓存（PWA、Cache API）</li>\n</ul>\n<h4 id=\"6用户感知优化\">（6）用户感知优化</h4>\n<ul>\n<li>骨架屏（Skeleton Screen）</li>\n<li>加载状态提示（加载动画、进度条）</li>\n<li>错误降级策略（兜底图片、友好提示）</li>\n</ul>\n<hr />\n<h2 id=\"二前端安全\">二、前端安全</h2>\n<h3 id=\"1-xss跨站脚本攻击防护\">1. XSS（跨站脚本攻击）防护</h3>\n<ul>\n<li>对用户输入进行转义/过滤</li>\n<li>设置 CSP（内容安全策略）</li>\n<li>使用 <code>HttpOnly</code> 和 <code>Secure</code> 属性保护 Cookie</li>\n<li>避免内联脚本，确保资源来源可信</li>\n</ul>\n<h3 id=\"2-csrf跨站请求伪造防护\">2. CSRF（跨站请求伪造）防护</h3>\n<ul>\n<li>服务端验证请求来源（Origin/Referer）</li>\n<li>使用 CSRF Token</li>\n<li>设置 <code>SameSite</code> Cookie 属性</li>\n<li>关键操作进行二次验证</li>\n</ul>\n<h3 id=\"3-点击劫持防护\">3. 点击劫持防护</h3>\n<ul>\n<li>设置响应头 <code>X-Frame-Options: DENY/SAMEORIGIN</code></li>\n<li>使用 CSP 的 <code>frame-ancestors</code> 指令</li>\n</ul>\n<h3 id=\"4-第三方依赖安全\">4. 第三方依赖安全</h3>\n<ul>\n<li>定期执行 <code>npm audit</code> 检查漏洞</li>\n<li>锁定依赖版本（package-lock.json、yarn.lock）</li>\n<li>遵循最小权限原则，避免过度授权</li>\n</ul>\n<hr />\n<h2 id=\"三跨端与兼容性\">三、跨端与兼容性</h2>\n<h3 id=\"1-css-适配方案\">1. CSS 适配方案</h3>\n<ul>\n<li>媒体查询（Media Queries）</li>\n<li>相对单位布局（rem、vw/vh）</li>\n<li>弹性布局（Flexbox）与网格布局（Grid）</li>\n<li>响应式图片与字体</li>\n</ul>\n<h3 id=\"2-资源降级与优化\">2. 资源降级与优化</h3>\n<ul>\n<li><code>srcset</code> 与 <code>sizes</code> 适配多分辨率</li>\n<li><code>&lt;picture&gt;</code> 标签进行图片格式降级</li>\n<li>使用 WebP 等现代图片格式</li>\n<li>可视区域加载（懒加载）</li>\n<li>使用 <code>transform</code> 与 <code>will-change</code> 提升动画性能</li>\n</ul>\n<hr />\n<h2 id=\"四高性能计算与多线程\">四、高性能计算与多线程</h2>\n<ul>\n<li>使用 Web Worker 运行后台任务</li>\n<li>利用 WebGPU 进行高性能图形计算</li>\n<li>通过 WebAssembly（WASM）执行高性能计算模块</li>\n</ul>\n<hr />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 14:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ggonekim\">Allis</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LaTeX学习笔记：开场白与索引",
      "link": "https://www.cnblogs.com/owlman/p/19404057",
      "published": "",
      "description": "<h2 class=\"post-title\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/owlman/p/19404057\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 11:59\">\n    <span>LaTeX学习笔记：开场白与索引</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"开场白\">开场白</h2>\n<p>从这里开始，我将会陆续记录自己在学习 <span class=\"math inline\">\\(\\LaTeX\\)</span> 语言过程中所累积的心得体会，目的是帮助自己和读者更好地掌握基于这门语言（及排版系统）的学术写作技巧。下面，让我们先来简单了解一下 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的前世今生。</p>\n<h3 id=\"latex-的前世今生\">LaTeX 的前世今生</h3>\n<p>事情得先从 <span class=\"math inline\">\\(\\TeX\\)</span> 说起，众所周知，<span class=\"math inline\">\\(\\TeX\\)</span> 是美国著名的计算机教授高德纳（Donald Ervin Knuth）<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\" rel=\"noopener nofollow\">[1]</a></sup>为撰写其伟大著作《计算机程序设计艺术》专门开发的一套排版系统语言。由于《计算机程序设计艺术》是一部讨论计算机算法的鸿篇巨作，其中涉及了大量的数学问题，所以为其开发的排版系统自然就在编辑复杂的数学公式方面具备了与生俱来的优势，这种先天优势使得它在数学、物理学和计算机科学等与数学表述密切相关的学术领域中非常流行，甚至很多人学习 <span class=\"math inline\">\\(\\TeX\\)</span> 就是为了使用它在数学领域中的强大表述能力。</p>\n<p>但 <span class=\"math inline\">\\(\\TeX\\)</span> 的功能过于强大，它会要求我们在排版过程中精确描述到每一个细节，有时甚至是一个字母或标点也要照顾到。这对于大多数人来说，可能就学习成本太高，并且用起来太过繁琐和费时了。于是在上个世纪八十年代，美国计算机科学家莱斯利·兰伯特（Leslie Lamport）<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\" rel=\"noopener nofollow\">[2]</a></sup>在 <span class=\"math inline\">\\(\\TeX\\)</span> 的基础上开发出了 <span class=\"math inline\">\\(\\LaTeX\\)</span> 这个新的排版系统（截至 2025 年，<span class=\"math inline\">\\(\\LaTeX2e\\)</span> 目前仍为主流版本，但官方已在逐步过渡到 <span class=\"math inline\">\\(LaTeX3\\)</span>）。从本质上来说，该排版系统其实就是一组封装了 <span class=\"math inline\">\\(\\TeX\\)</span> 处理细节的宏，它可以让那些不了解排版和程序设计相关知识的人们也能使用 <span class=\"math inline\">\\(\\TeX\\)</span> 所提供的强大功能，并在几天甚至几个小时之内就能排版出具有专业质感的印刷品，而不必深陷于琐碎的排版细节中。</p>\n<p>在中文支持方面，现代 LaTeX 通常使用 XeTeX 或 LuaTeX 排版引擎。二者都支持 UTF-8 编码和系统字体，其中 XeTeX 在中文社区中应用更广，该引擎支持 UTF-8 编码和现代字体，可以直接使用本地计算机中安装的字体，这大大降低了 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的使用难度。</p>\n<h3 id=\"为什么要学习-latex\">为什么要学习 LaTeX？</h3>\n<p>或许很多人都会问：在已经有那么多所见即所得（WYSIWYG）的文档编辑器（例如 Microsoft Word、WPS Office）的今天，我们为什么还要学习这种看起来古老又复杂的排版工具呢？在我个人看来，这个问题的答案不仅关乎写作工具的选择，更反映出我们对“学术写作”这一工作的理解。就我个人而言，选择学习 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的原因主要如下：</p>\n<ul>\n<li>\n<p><strong>可专注于写作的结构化思维</strong>。与传统的文档编辑器不同，<span class=\"math inline\">\\(\\LaTeX\\)</span> 并不要求我们在写作的同时关心每个段落、字体、间距的具体样式，而是让我们先将注意力放在文档的内容及其逻辑结构（即标题、摘要、公式、图表、参考文献等）上，然后再通过命令和标记告诉它这些内容“是什么”，而不是“看起来像什么”。这种写作方式与程序员使用编程语言时的思维是相通的：可以很好地实现内容与形式的分离，表达与排版的解耦。这意味着，一旦文档结构清晰，格式就可以自动保持统一与专业。</p>\n</li>\n<li>\n<p><strong>这是在学习一种项目管理思维</strong>。当我们使用它写作时，我们不只是“编辑文字”，而是在构建一个可复现、可维护、可自动生成的文本系统系统。它让学术写作拥有了版本控制、可移植性与长期可读性——这正是科学研究所追求的严谨与可验证性。对于科研工作者来说，<span class=\"math inline\">\\(\\LaTeX\\)</span> 不仅是一种工具，更是一种思维方式：一旦掌握，你会发现它带来的不仅是排版的优雅，更是思考方式的变化。</p>\n</li>\n<li>\n<p><strong>学术界公认的排版标准</strong>。世界上绝大多数顶级学术期刊与会议模板都是基于 <span class=\"math inline\">\\(\\LaTeX\\)</span> 实现的，从《Nature》《IEEE Transactions》到 ACM、Springer 的论文集，几乎无一例外。它在数学公式、交叉引用、自动编号、参考文献管理等方面的表现，至今没有任何图形化编辑器能够完全替代。特别是在数学、物理、计算机科学、工程学等领域，<span class=\"math inline\">\\(\\LaTeX\\)</span> 已经成为一种“默认语言”。随着国内外高校和出版社对 <span class=\"math inline\">\\(\\LaTeX\\)</span> 支持的日益完善，越来越多的中文论文、学位论文模板、科研报告乃至书籍排版都已经提供了相应的 <span class=\"math inline\">\\(\\LaTeX\\)</span> 模板。对于想要从事学术研究、技术写作、教材编辑或科研出版的人而言，掌握 <span class=\"math inline\">\\(\\LaTeX\\)</span> 不仅是技能，更是一种职业素养的体现。</p>\n</li>\n</ul>\n<p>或许还会有人问，那么 <span class=\"math inline\">\\(\\LaTeX\\)</span> 和我们日常写博客与技术文档的 Markdown 有什么区别呢？其实，其中的区别就在于“日常”与“学术”，Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 页面。Markdown 的语法简单，易于上手，非常适合快速编写和分享文档。然而，Markdown 并不能像 <span class=\"math inline\">\\(\\LaTeX\\)</span> 那样处理复杂的数学公式，也不能像 LaTeX 那样生成高质量的 PDF 文档。因此，如果我们需要进行更为专业的学术写作，特别是涉及到数学公式和参考文献管理时，<span class=\"math inline\">\\(\\LaTeX\\)</span> 是一个更好的选择。</p>\n<p>总之，学习 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的过程，既是掌握一种排版工具的过程，也是训练逻辑表达与抽象思维的过程。它让我们在文字的世界中，以科学的方式组织思想，以优雅的方式表达知识。</p>\n<h2 id=\"笔记索引\">笔记索引</h2>\n<p>这一系列的笔记的内容将包括介绍它的前世今生，基本使用方式，以及在数学公式编辑、专业文献排版等方面的具体应用。下面是这一系列笔记的索引：</p>\n<ul>\n<li>[[LaTeX学习笔记：快速上手指南]]：<a href=\"https://www.cnblogs.com/owlman/p/19202175\" target=\"_blank\">博客园链接</a>；</li>\n<li>[[LaTeX学习笔记：文档排版基础]]：<a href=\"https://www.cnblogs.com/owlman/p/19256216\" target=\"_blank\">博客园链接</a>；</li>\n<li>[[LaTeX学习笔记：数学公式编辑]]：<a href=\"https://www.cnblogs.com/owlman/p/19199330\" target=\"_blank\">博客园链接</a>；</li>\n<li>[[LaTeX学习笔记：学术文档排版]]：<a href=\"https://www.cnblogs.com/owlman/p/19348573\" target=\"_blank\">博客园链接</a>；</li>\n</ul>\n<p>除我的个人博客之外，上述笔记将陆续更新在我于 github 上的<a href=\"https://github.com/owlman/CS_StudyNotes\" rel=\"noopener nofollow\" target=\"_blank\">计算机学习笔记库</a>中，并予以长期维护，欢迎读者随时参考。</p>\n<h2 id=\"学习资源\">学习资源</h2>\n<ul>\n<li>参考书籍：\n<ul>\n<li><a href=\"https://book.douban.com/subject/24703731/\" rel=\"noopener nofollow\" target=\"_blank\">《LaTeX 入门》</a>：作者是刘海洋，电子工业出版社于2013年出版，适合初学入门。</li>\n<li><a href=\"https://book.douban.com/subject/1418351/\" rel=\"noopener nofollow\" target=\"_blank\">《The TeXbook》</a>：作者是高德纳本人，系 <span class=\"math inline\">\\(\\TeX\\)</span> 领域最权威的参考书籍。这虽并不是 <span class=\"math inline\">\\(\\LaTeX\\)</span> 直接相关的教材，但如果想更好地理解 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的工作原理，以及掌握其底层的排版机制，回头去读一下这本书，系统性地学习一下 <span class=\"math inline\">\\(\\TeX\\)</span> 是一个非常好的选择。</li>\n</ul>\n</li>\n<li>网络资源：\n<ul>\n<li><a href=\"https://www.latex-project.org/\" rel=\"noopener nofollow\" target=\"_blank\">LaTeX 官方网站</a>：官方文档和教程。</li>\n<li><a href=\"http://www.ctex.org/\" rel=\"noopener nofollow\" target=\"_blank\">CTeX 官方网站</a>：中文 <span class=\"math inline\">\\(\\LaTeX\\)</span> 社区，提供中文文档和教程。</li>\n<li><a href=\"https://www.tug.org/texlive/\" rel=\"noopener nofollow\" target=\"_blank\">TeX Live 官方网站</a>：最完整的跨平台 <span class=\"math inline\">\\(\\TeX\\)</span> 发行版，包含 LaTeX、XeTeX、LuaTeX 等编译器与宏包集合。</li>\n<li><a href=\"https://www.overleaf.com/\" rel=\"noopener nofollow\" target=\"_blank\">Overleaf</a>：在线的 <span class=\"math inline\">\\(\\LaTeX\\)</span> 编辑器，支持实时预览和协作编辑。</li>\n<li><a href=\"https://www.ctan.org/\" rel=\"noopener nofollow\" target=\"_blank\">CTAN</a>：<span class=\"math inline\">\\(\\LaTeX\\)</span> 的官方包仓库，提供了大量的宏包和模板。</li>\n<li><a href=\"https://en.wikibooks.org/wiki/LaTeX\" rel=\"noopener nofollow\" target=\"_blank\">LaTeX wikibook</a>：一个详细的 <span class=\"math inline\">\\(\\LaTeX\\)</span> 学习指南，适合初学者。</li>\n</ul>\n</li>\n</ul>\n\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li class=\"footnote-item\" id=\"fn1\"><p>高德纳教授是现代计算机科学的先驱人物，他创立了算法分析理论，并在数个计算机理论分支上都做出了犹如基石一般的贡献，于1974年荣获图灵奖。 <a class=\"footnote-backref\" href=\"#fnref1\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n<li class=\"footnote-item\" id=\"fn2\"><p>莱斯利·兰伯特是来自纽约的一位计算机科学家，LaTeX排版系统的开发者，2013年荣获图灵奖。 <a class=\"footnote-backref\" href=\"#fnref2\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n</ol>\n</section>\n\n</div>\n<div class=\"clear\"></div>\n\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2025-12-26 11:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/owlman\">凌杰</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "【面试题】MySQL B+树索引高度计算",
      "link": "https://www.cnblogs.com/sun-10387834/p/19381299",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19381299\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 11:53\">\n    <span>【面试题】MySQL B+树索引高度计算</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"mysql-b树索引高度计算与性能阈值探讨\">MySQL B+树索引高度计算与性能阈值探讨</h1>\n<h3 id=\"一mysql-b树索引高度计算\">一、MySQL B+树索引高度计算</h3>\n<p>MySQL中InnoDB的主键索引采用B+树结构，索引高度（树的层数）决定了查询时磁盘IO的次数（高度=IO次数），核心计算逻辑围绕<strong>B+树的节点容量</strong>和<strong>数据行数</strong>展开。</p>\n<h4 id=\"1-核心前提innodb默认配置\">1. 核心前提（InnoDB默认配置）</h4>\n<ul>\n<li>\n<p><strong>页大小</strong>：默认16KB（16384字节），B+树的每个节点对应一个InnoDB页。</p>\n</li>\n<li>\n<p><strong>主键类型</strong>：影响索引项大小（如INT=4字节，BIGINT=8字节，VARCHAR(32)=32+2字节）。</p>\n</li>\n<li>\n<p><strong>指针大小</strong>：InnoDB中页指针固定为6字节（指向子节点页的地址）。</p>\n</li>\n<li>\n<p><strong>B+树结构</strong>：</p>\n<ul>\n<li>\n<p>非叶子节点：仅存储「主键值 + 页指针」，按主键排序，无数据行；</p>\n</li>\n<li>\n<p>叶子节点：存储「完整主键 + 行数据（或行数据指针）」，且叶子节点通过双向链表连接。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-计算步骤\">2. 计算步骤</h4>\n<h5 id=\"步骤1计算非叶子节点的单页容量能存多少个索引项\">步骤1：计算非叶子节点的单页容量（能存多少个索引项）</h5>\n<p>非叶子节点的索引项大小 = 主键字节数 + 指针字节数</p>\n<p>单页可存储索引项数 = 页大小 / 索引项大小（向下取整，需预留少量空间给页头/页尾，实际按90%可用计算）</p>\n<p><strong>示例</strong>：主键为INT（4字节），指针6字节 → 索引项=10字节</p>\n<p>单页可用空间≈16384 * 90% = 14745字节</p>\n<p>单页索引项数≈14745 / 10 ≈ 1474个</p>\n<h5 id=\"步骤2计算叶子节点的单页容量能存多少行数据\">步骤2：计算叶子节点的单页容量（能存多少行数据）</h5>\n<p>叶子节点行大小 = 主键字节数 + 其他列总字节数（或行指针大小，InnoDB聚簇索引直接存数据）</p>\n<p>单页可存储行数 = 页大小 / 行大小（向下取整，同样预留页结构空间）</p>\n<p><strong>示例</strong>：主键INT（4字节），行数据总大小≈100字节 → 单行大小≈104字节</p>\n<p>单页行数≈14745 / 104 ≈ 141行</p>\n<h5 id=\"步骤3计算b树高度对应的总数据量\">步骤3：计算B+树高度对应的总数据量</h5>\n<p>B+树是多叉树，高度h的总数据量公式：</p>\n<p><code>总行数 = 非叶子节点分支数^(h-1) * 叶子节点单页行数</code></p>\n<ul>\n<li>\n<p>高度1：仅根节点（叶子节点）→ 行数≈141行</p>\n</li>\n<li>\n<p>高度2：根节点（非叶子）+ 叶子节点 → 1474 * 141 ≈ 20.8万行</p>\n</li>\n<li>\n<p>高度3：根→中间节点→叶子 → 1474 * 1474 * 141 ≈ 3060万行</p>\n</li>\n<li>\n<p>高度4：1474³ * 141 ≈ 45亿行</p>\n</li>\n</ul>\n<h4 id=\"3-实际验证方式\">3. 实际验证方式</h4>\n<p>可通过InnoDB的系统表查询索引高度：</p>\n<pre><code class=\"language-SQL\">-- 查询表的主键索引高度（TABLE_ID需先查）\nSELECT \n  b.name AS index_name,\n  a.HEIGHT AS index_height\nFROM \n  information_schema.INNODB_SYS_INDEXES a\nJOIN \n  information_schema.INNODB_SYS_TABLES b ON a.TABLE_ID = b.TABLE_ID\nWHERE \n  b.NAME = '数据库名/表名' -- 如test/user\n  AND a.NAME = 'PRIMARY'; -- 主键索引\n</code></pre>\n<ul>\n<li>生产环境中，99%的表索引高度为3（少量小表为2），高度4极少（超亿级数据才会出现）。</li>\n</ul>\n<h3 id=\"二mysql单表不影响性能的最大记录数\">二、MySQL单表不影响性能的最大记录数</h3>\n<p><strong>结论先行</strong>：没有绝对数值，但业界通用经验是「千万级（1000万~1亿行）」，核心影响因素不是行数，而是<strong>索引高度、数据页缓存命中率、磁盘IO能力</strong>。</p>\n<h4 id=\"1-性能阈值的核心逻辑\">1. 性能阈值的核心逻辑</h4>\n<ul>\n<li>\n<p>索引高度≤3时：查询只需2~3次磁盘IO（根节点、中间节点常驻内存），性能基本无衰减；</p>\n</li>\n<li>\n<p>索引高度=4时：需4次IO，且中间节点可能无法全部缓存，性能开始明显下降；</p>\n</li>\n<li>\n<p>数据页缓存命中率：InnoDB缓冲池能缓存的热数据页越多，性能越好（千万级数据的热页基本可全缓存，亿级后缓存命中率骤降）。</p>\n</li>\n</ul>\n<h4 id=\"2-不同场景的阈值参考\">2. 不同场景的阈值参考</h4>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>场景</td>\n<td>不影响性能的最大行数</td>\n<td>核心限制因素</td>\n</tr>\n<tr>\n<td>主键查询+热数据</td>\n<td>1亿行</td>\n<td>缓冲池大小（≥32GB）</td>\n</tr>\n<tr>\n<td>普通索引查询+分页</td>\n<td>1000万行</td>\n<td>索引回表IO、分页排序开销</td>\n</tr>\n<tr>\n<td>频繁更新+多索引</td>\n<td>500万行</td>\n<td>索引维护开销、锁竞争</td>\n</tr>\n<tr>\n<td>机械硬盘（HDD）</td>\n<td>500万行</td>\n<td>随机IO速度慢（≈100 IOPS）</td>\n</tr>\n<tr>\n<td>固态硬盘（SSD）</td>\n<td>1亿行</td>\n<td>随机IO速度快（≈10万 IOPS）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-突破阈值的优化方案\">3. 突破阈值的优化方案</h4>\n<p>若数据量超阈值，需通过架构优化而非单表优化：</p>\n<ul>\n<li>\n<p>分库分表：水平分表（按主键哈希/范围），使单表行数回到千万级以内；</p>\n</li>\n<li>\n<p>冷热数据分离：将冷数据归档到只读库，热数据保留在主库；</p>\n</li>\n<li>\n<p>索引优化：减少冗余索引，使用覆盖索引避免回表，优化查询语句（如避免SELECT *）；</p>\n</li>\n<li>\n<p>硬件升级：SSD替代HDD，增大缓冲池（innodb_buffer_pool_size=物理内存的50%~70%）。</p>\n</li>\n</ul>\n<h3 id=\"三总结\">三、总结</h3>\n<ol>\n<li>\n<p>B+树索引高度计算：核心是「非叶子节点单页分支数^高度-1 × 叶子节点单页行数」，生产环境中高度基本为2~3；</p>\n</li>\n<li>\n<p>单表性能阈值：千万级（1000万~1亿）是通用的无性能衰减阈值，核心看索引高度和IO能力，而非绝对行数；</p>\n</li>\n<li>\n<p>性能优化的核心：保持索引高度≤3，提升缓冲池缓存命中率，超阈值后优先分库分表。</p>\n</li>\n</ol>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19381299\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19381299</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 11:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "专注之道，先立根基而后致远",
      "link": "https://www.cnblogs.com/spindrift/p/19403971",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/spindrift/p/19403971\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 11:47\">\n    <span>专注之道，先立根基而后致远</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#本文提要\" rel=\"noopener nofollow\">本文提要</a></li><li><a href=\"#正文\" rel=\"noopener nofollow\">正文</a></li><li><a href=\"#我的专注实操\" rel=\"noopener nofollow\">我的专注实操</a></li></ul></div><p></p>\n<h2 id=\"本文提要\">本文提要</h2>\n<p><img alt=\"专注\" src=\"https://img2024.cnblogs.com/blog/772669/202512/772669-20251226151912147-1228602931.png\" /></p>\n<h2 id=\"正文\">正文</h2>\n<p>很多人都将“心无旁骛，万事可成”奉为准则，把专注完全归因于愿力的驱动，认为仅凭一腔热忱就能凝神聚力、一往无前。但我认为，这种观点不够全面，甚至带有些许“鸡汤式”的静态思维。专注从来不是孤注一掷的偏执，更不是脱离现实的空想，它需要以人生定位为罗盘，以自我准备为基石，以取舍有度为尺度，在周全规划的土壤中才能生根发芽、茁壮成长。脱离根基的专注，就像无源之水、无本之木，终究难以长久。</p>\n<p>专注之先，在于明定位、知取舍。人生如四季流转，各阶段自有其核心使命：求学阶段当潜心笃志，夯实知识根基；青年时期可勇闯事业，拓展人生边界；暮年之后宜颐养身心，沉淀岁月智慧。若混淆阶段使命，妄图“一生只做一件事”，便难免陷入失衡的困境——就像有人在求学时执意深耕副业，终致学业荒废；有人退休后仍强行追赶事业高峰，徒增身心负担。正如春耕时强要秋收，寒冬时硬要播种，违背规律的专注，只会徒劳无功。更需明晓，人生目标从来不是单选题，而是多选题的精准取舍。依循二八定律，辨清核心目标与次要目标：关乎立身之本的目标需全力以赴，无关紧要的琐事做到及格即可，长远规划类的目标可暂缓搁置。诸如健身这类目标不可能一蹴而就，需循序渐进；而给孩子取名这类急事，虽耗时短却需优先完成。唯有找准当下定位，厘清职责边界，在可选目标中锚定优先级，方能让专注有的放矢，避免在多元需求中迷失方向。</p>\n<p>专注的根基，在于提升自我、补足短板。常言道“工欲善其事，必先利其器”，专注的成效，从来不只取决于愿力的强弱，更依赖自身的综合素养。如果没有恒心和毅力，即便有片刻的专注，也会在挫折与负面反馈面前半途而废；如果没有自控力，再清晰的目标也会被惰性与诱惑侵蚀；如果没有健康的体魄和强大的心理承受力，高强度的专注只会透支身心。这就要求我们提前做好准备、补足短板：想要深耕事业，可建立家务标准化流程提升效率，节省时间成本；想要直面职场挑战，可学习心理学知识，锤炼抗压抗挫能力；想要高效推进目标，需要掌握番茄工作法、四象限法则等时间管理技巧，学会科学的学习方法。同时，更要认清自我、顺应时代：明确自己的天赋禀赋、兴趣所在与意志边界——知道自己适合深耕细作而非闯荡开拓，明白自己擅长沉稳笃行而非急功近利；既要了解时代发展趋势，避免在过时的方向上盲目专注，也要接纳自身局限，有些特质难以强行改变，这也是人们常说的“一命二运三风水”中所蕴含的对客观现实的敬畏。这种“认清自己、了解时代”的清醒，才能让专注避开盲目，贴合本心与时代大势。</p>\n<p>专注的尺度，在于顺应时势、灵活调整。人们常说“穷则变，变则通，通则久”，专注绝不是一成不变的执念，而是需要具备灵活调整的应变能力。我们无法一辈子只专注于一件事，但可以在某一阶段、某一段时间内，对核心目标保持极致专注——这不是“一条腿走路”的失衡，而是“阶段聚焦”的智慧。就像在海上航行，既要锚定航向，也要根据风浪调整船舵；又像耕耘田地，既要专注劳作，也要顺应节气更换作物。脱离时代大势的专注，容易陷入“闭门造车”的困境，比如在数字化时代还固执地专注于传统手工作坊的低效生产；缺乏调整空间的专注，最终会变得像“刻舟求剑”那样僵化，比如年轻时没实现的舞蹈梦想，到八十岁再强行专注修习，虽有情怀却失去了应有的价值。只有兼顾时代需求与自身境遇，以目标为导向而非事件为导向，在坚守核心的同时预留调整空间，让专注与现实同频共振，才能在变化中站稳脚跟，在坚守中稳步前行、走得更远。</p>\n<p>人们常用木桶比喻人生，说能装多少水，取决于最短的那块木板。专注也是如此，它从来不是一种孤立的能力，而是由定位、取舍、自我提升、应变等诸多要素共同支撑的系统工程。没有定位的专注，是盲目的消耗；没有准备的专注，是徒劳的挣扎；没有弹性的专注，是僵化的执念。就像有人空有专注的愿力，却因为没理清人生阶段的职责、没补足自控力的短板，最终在繁杂事务与挫折中半途而废——这恰好印证了“任何一个环节脱节，整件事就可能失败”的道理。</p>\n<p>对我们来说，专注从来不是“两耳不闻窗外事”的孤僻，而是“胸有丘壑、眼底有光”的清醒。先明确定位以找准方向，理清当下阶段的核心职责；再提升自我以筑牢根基，补足能力短板、认清自我与时代；后顺应时势以灵活调整，合理把控专注的范围与节奏。如此，才能让专注真正成为披荆斩棘的利刃，在人生的征途上，走出一条既踏实沉稳、又开阔明亮的道路。这，便是专注的真谛，也是成长的正途。</p>\n<h2 id=\"我的专注实操\">我的专注实操</h2>\n<p><img alt=\"exported_image\" src=\"https://img2024.cnblogs.com/blog/772669/202512/772669-20251226151928901-1549792437.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 11:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/spindrift\">英击长空</a>&nbsp;\n阅读(<span id=\"post_view_count\">65</span>)&nbsp;\n评论(<span id=\"post_comment_count\">3</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "采样保持电路分析[原创www.cnblogs.com/helesheng]",
      "link": "https://www.cnblogs.com/helesheng/p/19401651",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/helesheng/p/19401651\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 11:34\">\n    <span>采样保持电路分析[原创www.cnblogs.com/helesheng]</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"采样保持电路分析[原创www.cnblogs.com/helesheng]\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1380455/202512/1380455-20251226112546839-978054094.png\" />\n        介绍了模数转换的采样保持电路（S/H）的原理，以精度改善为目的的全局反馈的设计，和以防止饱和为目的的钳位设计。最后分析了上述钳位设计不会造成精度损失的原因。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>上《数字电路》这门课的时候，学生问模数转换器（ADC）一章中的采样保持电路（本文图3电路）为什么要加钳位二极管VD1和VD2，我习惯性的随口回答：为了在保持阶段第一个运放的输出不会太大，也不会太小。回到办公室仔细想了一下，不禁反问自己国家半导体的经典电路LF398究竟为什么要设计这两个二极管，为什么不实用最直接的两个局部负反馈结构（如本文图1）。请教了同事、同学发现还是有很多值得分享记录的地方，现总结如下。以下原创内容欢迎网友转载，但请注明出处：<a href=\"https://www.cnblogs.com/helesheng\" target=\"_blank\">https://www.cnblogs.com/helesheng</a></p>\n<h1 id=\"1采样保持电路原型\">1、采样保持电路原型</h1>\n<p>示意图如1所示：运放A1、A2构成电压跟随器，两个跟随器分别用于实现“输入到采样保持电容<span class=\"math inline\">\\(C_h\\)</span>的阻抗变换”，以及“<span class=\"math inline\">\\(C_h\\)</span>到输出<span class=\"math inline\">\\(u_o\\)</span>的阻抗变换”。其中开关S是由MOS管构成的模拟开关，它导通的时候，实现<span class=\"math inline\">\\(C_h\\)</span>电压采样；关断时实现<span class=\"math inline\">\\(C_h\\)</span>电压保持。</p>\n<center>\n    <img src=\"https://img2024.cnblogs.com/blog/1380455/202512/1380455-20251226000627253-1066875295.jpg\" width=\"600\" />\n</center>\n<center>\n图1 采样保持电路原型\n</center>\n<p>这个电路的缺点是S处的开关MOS管关断的瞬间，其栅极G电压突变，栅极和源极之间的寄生电容<span class=\"math inline\">\\(C_{GS}\\)</span>上的电压差不能突变，从而导致<span class=\"math inline\">\\(U_{P2}\\)</span>处的保持电压被<span class=\"math inline\">\\(C_{GS}\\)</span>拉低，降低了保持精度和开关切换时间。</p>\n<h2 id=\"2采样保持电路改进1\">2、采样保持电路改进1</h2>\n<p>为了改善这个问题，将图1中A1构成的局部负反馈变为全局反馈，以通过A1的增益改善控制精度。得到图2所示的电路，其中<span class=\"math inline\">\\(R_{DS}\\)</span>是栅极寄生电容<span class=\"math inline\">\\(C_{GS}\\)</span>上的电荷完全释放完毕之前，S处于半导通状态下S的漏源之间的等效电阻。</p>\n<center>\n    <img src=\"https://img2024.cnblogs.com/blog/1380455/202512/1380455-20251226000646371-590667438.jpg\" width=\"600\" />\n</center>\n<center>\n图2 采样保持电路改进1\n</center>\n<p>图2具体分析：G端突然出现下跳，拉着A2的同相输入端也变低，从而导致A2输出变小，进而导致A1反相端输入也降低，A1的输出就会拉高来补偿采样电容<span class=\"math inline\">\\(C_h\\)</span>上的电压损失误差。其中<span class=\"math inline\">\\(C_{GS}\\)</span>只在电压很低时很大，所以当关断程度大，<span class=\"math inline\">\\(R_{DS}\\)</span>大的时候作用就不大了。所以只需要A1的输出电压能够在一个小范围波动，因此只需要A1的输出在很小的范围内波动就可以补偿<span class=\"math inline\">\\(C_h\\)</span>上的电压误差。</p>\n<h2 id=\"3采样保持电路改进2\">3、采样保持电路改进2</h2>\n<p>图2所示改进电路的问题是：当S完全断开后，A1处于完全开环的比较器状态，保持阶段如果输入<span class=\"math inline\">\\(u_i\\)</span>发生变化，会导致A1饱和输出高电平或低电平。S再次闭合采样时A1要从饱和状态回复到负反馈的工作状态一般需要1us左右，这将极大的限制采样保持器的最大工作频率。因此出现了图3所示的，真正实用的采样保持电路LF398。<br />\nVD1和VD2的作用是通过钳位保证A1在保持阶段不会进入饱和状态（实际上是一种非线性负反馈状态），从而提升了采样保持器的工作速度。而VD1和VD2也限制了图2中A1输出的补偿电压摆幅，不过根据上面的分析只需要A1的输出电压能够在一个小范围波动即可实现<span class=\"math inline\">\\(C_{GS}\\)</span>造成的保持电压波动。<br />\n因此，清华阎石老师的《数字电路》教材说这两个二极管通过钳位可以提升采样保持电路的工作速度。<br />\n哈工大杨春玲老师的《数字电路》教材中说VD1和VD2的作用是为了防止A1饱和后造成S两端压差过大，从而烧毁S，我觉得是没有根据的。</p>\n<center>\n    <img src=\"https://img2024.cnblogs.com/blog/1380455/202512/1380455-20251226000652118-1743701733.jpg\" width=\"600\" />\n</center>\n<center>\n图3 采样保持电路改进2(LF398)\n</center>\n<h2 id=\"4含二极管的局部非线性反馈精确性分析\">4、含二极管的局部非线性反馈精确性分析</h2>\n<p>S闭合时，二极管VD1和VD2两端电压相等：<br />\n此时由于A1和A2的虚断，<span class=\"math inline\">\\(U_{N2}、U_{P2}、u_o以及u_o’\\)</span>相等，<span class=\"math inline\">\\(u_i以及U_{NI}\\)</span>相等。如果<span class=\"math inline\">\\(u_o’\\)</span>与二极管上端的<span class=\"math inline\">\\(U_{NI}\\)</span>相差一个Δu（&lt;0.7V），则R1两侧就有电压差Δu，导致有电流流过R1。<br />\n这个电流即没法流入VD1和VD2，也没法流入A1的反相端，因此Δu只能为0。也就是<span class=\"math inline\">\\(u_o’等于u_i\\)</span>。<br />\n反过来描述这个过程：当<span class=\"math inline\">\\(u_o’和u_i\\)</span>有Δu这个差异时，不妨假设Δu&gt;0，<span class=\"math inline\">\\(u_o\\)</span>将等于<span class=\"math inline\">\\(u_o’并大于u_i\\)</span>。此时由于R1上不可能有电流，R1左右两边的电压相同，将使<span class=\"math inline\">\\(U_{NI}等于u_o’并大于u_i\\)</span>，此时运放A1将调整输出到让<span class=\"math inline\">\\(u_o’\\)</span>降低（A1反相输入端大于A2）,直至达到<span class=\"math inline\">\\(u_o’等于u_i\\)</span>，Δu等于0。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 11:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/helesheng\">helesheng</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "使用Java Stream，将集合转换为一对一Map",
      "link": "https://www.cnblogs.com/zwwhnly/p/19403765",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zwwhnly/p/19403765\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 11:23\">\n    <span>使用Java Stream，将集合转换为一对一Map</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2025-12-26 11:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zwwhnly\">申城异乡人</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n            <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Java Stream，Collectors.toMap收集器使用方法。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在日常的开发工作中，我们经常使用到Java Stream，特别是Stream API中提供的<code>Collectors.toList()</code>收集器，</p>\n<p>但有些场景下，我们需要将集合转换为Map，这时候就需要使用到Stream API中提供的另一个收集器：</p>\n<p><code>Collectors.toMap</code>，它可以将流中的元素映射为键值对，并收集到一个Map中。</p>\n<h2 id=\"1-三种主要的重载方法\">1. 三种主要的重载方法</h2>\n<p><code>Collectors.toMap</code>有3种重载方法，分别是：</p>\n<p>1)<strong>两个参数的重载方法（最简单的形式）</strong></p>\n<pre><code class=\"language-java\">public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,\n                                Function&lt;? super T, ? extends U&gt; valueMapper) {\n\treturn toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);\n}\n</code></pre>\n<p>2)<strong>三个参数的重载方法（包含冲突处理）</strong></p>\n<pre><code class=\"language-java\">public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,\n                                Function&lt;? super T, ? extends U&gt; valueMapper,\n                                BinaryOperator&lt;U&gt; mergeFunction) {\n    return toMap(keyMapper, valueMapper, mergeFunction, HashMap::new);\n}\n</code></pre>\n<p>3)<strong>四个参数的重载方法（指定Map实现）</strong></p>\n<pre><code class=\"language-java\">public static &lt;T, K, U, M extends Map&lt;K, U&gt;&gt;\n   Collector&lt;T, ?, M&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,\n                            Function&lt;? super T, ? extends U&gt; valueMapper,\n                            BinaryOperator&lt;U&gt; mergeFunction,\n                            Supplier&lt;M&gt; mapSupplier) {\n    BiConsumer&lt;M, T&gt; accumulator\n            = (map, element) -&gt; map.merge(keyMapper.apply(element),\n                                          valueMapper.apply(element), mergeFunction);\n    return new CollectorImpl&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);\n}\n</code></pre>\n<p>接下来，我们结合使用示例详细讲解。</p>\n<h2 id=\"2-使用示例\">2. 使用示例</h2>\n<h3 id=\"21-将对象的某些属性转换为map\">2.1 将对象的某些属性转换为Map</h3>\n<p>假设有一个城市列表，需要将其转换为Map，其中Key为城市ID、Value为城市名称，转换方法如下所示：</p>\n<pre><code class=\"language-java\">@Getter\n@Setter\npublic class City {\n    private Integer cityId;\n\n    private String cityName;\n\n    public City(Integer cityId, String cityName) {\n        this.cityId = cityId;\n        this.cityName = cityName;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(1, \"北京\"),\n        new City(2, \"上海\"),\n        new City(3, \"广州\"),\n        new City(4, \"深圳\")\n);\nMap&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName));\nSystem.out.println(cityMap);\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p></p>\n</blockquote>\n<h3 id=\"22-将对象列表转换为mapid---对象\">2.2 将对象列表转换为Map（ID -&gt; 对象）</h3>\n<p>仍然使用上面的城市列表，需要将其转换为Map，其中Key为城市ID、Value为城市对象，转换方法如下所示：</p>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(1, \"北京\"),\n        new City(2, \"上海\"),\n        new City(3, \"广州\"),\n        new City(4, \"深圳\")\n);\nMap&lt;Integer, City&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, city -&gt; city));\nCity city = cityMap.get(1);\nSystem.out.println(\"城市ID: \" + city.getCityId());\nSystem.out.println(\"城市名称: \" + city.getCityName());\n</code></pre>\n<p>输出结果如下所示：</p>\n<blockquote>\n<p>城市ID: 1<br />\n城市名称: 北京</p>\n</blockquote>\n<p>上面的写法等价于：</p>\n<pre><code class=\"language-java\">Map&lt;Integer, City&gt; cityMap = cityList.stream()\n    \t.collect(Collectors.toMap(City::getCityId, Function.identity()));\n</code></pre>\n<p>因为<code>Function.identity()</code>内部实现是下面这样的：</p>\n<pre><code class=\"language-java\">static &lt;T&gt; Function&lt;T, T&gt; identity() {\n    return t -&gt; t;\n}\n</code></pre>\n<h3 id=\"23-键冲突处理\">2.3 键冲突处理</h3>\n<p>假设上面的城市列表中有一个ID重复的城市：</p>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(1, \"北京\"),\n        new City(2, \"上海\"),\n        new City(3, \"广州\"),\n        new City(4, \"深圳\"),\n        new City(4, \"天津\")\n);\nMap&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName));\nSystem.out.println(\"城市ID: 4, 城市名称: \" + cityMap.get(4));\n</code></pre>\n<p>此时运行代码，会抛出<code>java.lang.IllegalStateException</code>异常，如下图所示：</p>\n<p><img alt=\"\" src=\"https://images.zwwhnly.com/picture/2025/snipaste_20251225_172725.png\" /></p>\n<p>有3种常见的键冲突处理方式，分别是保留旧值、使用新值和合并值，接下来一一讲解。</p>\n<p>1)方式一：保留旧值</p>\n<pre><code class=\"language-java\">Map&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName, (oldValue, newValue) -&gt; oldValue));\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>城市ID: 4, 城市名称: 深圳</p>\n</blockquote>\n<p>2)方式二：使用新值</p>\n<pre><code class=\"language-java\">Map&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName, (oldValue, newValue) -&gt; newValue));\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>城市ID: 4, 城市名称: 天津</p>\n</blockquote>\n<p>3)方式三：合并值</p>\n<pre><code class=\"language-java\">Map&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName, \n        \t\t(oldValue, newValue) -&gt; oldValue + \", \" + newValue));\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>城市ID: 4, 城市名称: 深圳, 天津</p>\n</blockquote>\n<h3 id=\"24-数据分组聚合\">2.4 数据分组聚合</h3>\n<p>假设有一个销售记录列表，需要将其转换为Map，其中Key为销售员、Value为该销售员的总销售额，转换方法如下所示：</p>\n<pre><code class=\"language-java\">@Getter\n@Setter\npublic class SalesRecord {\n    private String salesPerson;\n\n    private BigDecimal amount;\n\n    public SalesRecord(String salesPerson, BigDecimal amount) {\n        this.salesPerson = salesPerson;\n        this.amount = amount;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">List&lt;SalesRecord&gt; salesRecordList = Arrays.asList(\n        new SalesRecord(\"张三\", new BigDecimal(\"1000\")),\n        new SalesRecord(\"李四\", new BigDecimal(\"2000\")),\n        new SalesRecord(\"张三\", new BigDecimal(\"980\"))\n);\n\nMap&lt;String, BigDecimal&gt; salesRecordMap = salesRecordList.stream()\n        .collect(Collectors.toMap(SalesRecord::getSalesPerson, SalesRecord::getAmount, BigDecimal::add));\nSystem.out.println(salesRecordMap);\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p></p>\n</blockquote>\n<p>上面的例子是销售额累加，也可以只取最小值：</p>\n<pre><code class=\"language-java\">Map&lt;String, BigDecimal&gt; salesRecordMap = salesRecordList.stream()\n        .collect(Collectors.toMap(SalesRecord::getSalesPerson, SalesRecord::getAmount, BigDecimal::min));\n</code></pre>\n<p>此时的输出结果：</p>\n<blockquote>\n<p></p>\n</blockquote>\n<p>或者只取最大值：</p>\n<pre><code class=\"language-java\">Map&lt;String, BigDecimal&gt; salesRecordMap = salesRecordList.stream()\n        .collect(Collectors.toMap(SalesRecord::getSalesPerson, SalesRecord::getAmount, BigDecimal::max));\n</code></pre>\n<p>此时的输出结果：</p>\n<blockquote>\n<p></p>\n</blockquote>\n<h3 id=\"25-指定map实现\">2.5 指定Map实现</h3>\n<p>默认情况下，<code>Collectors.toMap</code>是将结果收集到HashMap中，如果有需要，我们也可以指定成TreeMap或者LinkedHashMap。</p>\n<p>如果想要保持插入顺序，可以指定使用LinkedHashMap：</p>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(2, \"上海\"),\n        new City(1, \"北京\"),\n        new City(4, \"深圳\"),\n        new City(3, \"广州\")\n);\nMap&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName,\n                (existing, replacement) -&gt; existing, LinkedHashMap::new));\nSystem.out.println(cityMap);\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p></p>\n</blockquote>\n<p>如果想要按键排序，可以指定使用TreeMap：</p>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(2, \"上海\"),\n        new City(1, \"北京\"),\n        new City(4, \"深圳\"),\n        new City(3, \"广州\")\n);\nMap&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName,\n                (existing, replacement) -&gt; existing, TreeMap::new));\nSystem.out.println(cityMap);\n</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p></p>\n</blockquote>\n<h2 id=\"3-注意事项\">3. 注意事项</h2>\n<h3 id=\"31-空异常\">3.1 空异常</h3>\n<p>如果valueMapper中取出的值有null值，会抛出<code>java.lang.NullPointerException</code>异常，如下示例：</p>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(1, \"北京\"),\n        new City(2, \"上海\"),\n        new City(3, \"广州\"),\n        new City(4, \"深圳\"),\n        new City(5, null)\n);\nMap&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName));\nSystem.out.println(cityMap);\n</code></pre>\n<p>运行以上代码会抛出异常，如下图所示：</p>\n<p><img alt=\"\" src=\"https://images.zwwhnly.com/picture/2025/snipaste_20251226_104553.png\" /></p>\n<p>有两种解决方案，第一种解决方案是过滤null值：</p>\n<pre><code class=\"language-java\">Map&lt;Integer, String&gt; cityMap = cityList.stream()\n        .filter(city -&gt; city.getCityName() != null)\n        .collect(Collectors.toMap(City::getCityId, City::getCityName));\n</code></pre>\n<p>第二种解决方案是提供默认值：</p>\n<pre><code class=\"language-java\">Map&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId,\n                city -&gt; Optional.ofNullable(city.getCityName()).orElse(\"未知\")));\n</code></pre>\n<h3 id=\"32-键重复异常\">3.2 键重复异常</h3>\n<p>如果出现重复键，且没有提供mergeFunction参数，会抛出<code>java.lang.IllegalStateException</code>异常，如下示例：</p>\n<pre><code class=\"language-java\">List&lt;City&gt; cityList = Arrays.asList(\n        new City(1, \"北京\"),\n        new City(2, \"上海\"),\n        new City(3, \"广州\"),\n        new City(4, \"深圳\"),\n        new City(4, \"天津\")\n);\nMap&lt;Integer, String&gt; cityMap = cityList.stream()\n        .collect(Collectors.toMap(City::getCityId, City::getCityName));\nSystem.out.println(cityMap);\n</code></pre>\n<p>运行以上代码会抛出异常，如下图所示：</p>\n<p><img alt=\"\" src=\"https://images.zwwhnly.com/picture/2025/snipaste_20251225_172725.png\" /></p>\n<p>解决方案见本篇文章<strong>2.3 键冲突处理</strong>部分。</p>\n<h2 id=\"4-总结\">4. 总结</h2>\n<p><code>Collectors.toMap</code>是Stream API中提供的一个非常方便的收集器，它可以将流中的元素映射为键值对，并收集到一个Map中。</p>\n<p>它适用于一对一映射的场景，但在使用时，要注意避免<code>java.lang.NullPointerException</code>异常和</p>\n<p><code>java.lang.IllegalStateException</code>异常。</p>\n<blockquote>\n<p>文章持续更新，欢迎关注微信公众号「申城异乡人」第一时间阅读！</p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    }
  ]
}