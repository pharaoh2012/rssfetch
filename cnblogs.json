{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "用了MySQL的INSERT ON DUPLICATE KEY UPDATE，怎么还报唯一索引冲突错误",
      "link": "https://www.cnblogs.com/youzhibing/p/19388304",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/youzhibing/p/19388304\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 09:00\">\n    <span>用了MySQL的INSERT ON DUPLICATE KEY UPDATE，怎么还报唯一索引冲突错误</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"开心一刻\">开心一刻</h2>\n<p>一天，老婆笑容满面的冲到我面前<br />\n老婆：你娶我到底是图我啥<br />\n我：便宜<br />\n老婆笑容瞬间消失，气呼呼的道：你会不会说话？<br />\n并且强调：我爸当年那是可怜你，没跟你多要<br />\n我：不是，你爸不是这么说的<br />\n老婆：那怎么说的<br />\n我开始学着老丈人的口吻：不许退，给你便宜点</p>\n<div align=\"center\"><img alt=\"开心一刻\" src=\"https://img2024.cnblogs.com/blog/747662/202512/747662-20251223173616476-1594142117.gif\" /></div>\n<h2 id=\"insert-on-duplicate-key-update\">INSERT ON DUPLICATE KEY UPDATE</h2>\n<p>关于 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>，相信大家都有所了解，是 <code>MySQL</code> 针对</p>\n<blockquote>\n<p>不存在则插入，存在则更新</p>\n</blockquote>\n<p>的一种方言实现；<code>存不存在</code> 该如何判定呢，基于表的 <code>唯一索引</code> 或 <code>主键</code></p>\n<p>举个例子，如果列 <code>a</code> 被声明为 <code>唯一</code> 且表中已经存在 <code>a=1</code> 的记录，则以下两条语句具有类似的效果</p>\n<pre><code class=\"language-sql\">INSERT INTO t1 (a,b,c) VALUES (1,2,3)\n  ON DUPLICATE KEY UPDATE c=c+1;\n\nUPDATE t1 SET c=c+1 WHERE a=1;\n</code></pre>\n<p>假设我们有表</p>\n<pre><code class=\"language-sql\">CREATE TABLE `tbl_insert_on_update` (\n  `id` bigint NOT NULL,\n  `name` varchar(255) NOT NULL,\n  `uk_column1` varchar(255) NOT NULL,\n  `uk_column2` varchar(255) NOT NULL,\n  `remark` text,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `name` (`name`)\n) ENGINE=InnoDB\n</code></pre>\n<p>一开始表中没有数据，那么</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)\nVALUES(1, '张三', '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101002', uk_column2='男二号', remark='狂风一样的男子';\n</code></pre>\n<p>的作用，相信大家都知道，与</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)\nVALUES(1, '张三', '20050101001', '男一号', '风一样的男子');\n</code></pre>\n<p>作用一样，会往表中插入一条新的记录；如果再执行一次</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)\nVALUES(1, '张三', '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101002', uk_column2='男二号', remark='狂风一样的男子';\n</code></pre>\n<p>呢，会是怎么样的结果？相信大家都知道</p>\n<div align=\"center\"><img alt=\"insert_on_update_再执行一次\" src=\"https://img2024.cnblogs.com/blog/747662/202512/747662-20251223173615289-1171352990.png\" /></div>\n<p>与</p>\n<pre><code class=\"language-sql\">UPDATE tbl_insert_on_update SET uk_column1='20050101002', uk_column2='男二号', remark='狂风一样的男子' WHERE id = 1;\n</code></pre>\n<p>的效果一样。我们接着做个简单调整，拿掉 <code>name</code></p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, uk_column1, uk_column2, remark)\nVALUES(1, '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子';\n</code></pre>\n<p>或者拿掉 <code>id</code></p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(name, uk_column1, uk_column2, remark)\nVALUES('张三', '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子';\n</code></pre>\n<p>会是怎么样的一个结果，你们可以大胆猜一下。这两个 SQL 的执行结果是一样的</p>\n<div align=\"center\"><img alt=\"男三浩\" src=\"https://img2024.cnblogs.com/blog/747662/202512/747662-20251223173615313-938765406.png\" /></div>\n<p>此时你们是不是有疑问呢</p>\n<blockquote>\n<p>为什么拿掉 <code>name</code> 和拿掉 <code>id</code> 的 INSERT ... ON DUPLICATE KEY UPDATE 的执行结果会是一样的？</p>\n</blockquote>\n<p>这个问题先放一放，我们先录入女一号的数据</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)\nVALUES(2, '婉儿', '20050101001X', '女一号', '花一样的女子');\n</code></pre>\n<p>假设我们要修改女一号的信息，包括 <code>姓名</code>，是不是可以这么实现</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, name, uk_column1, uk_column2, remark)\nVALUES(2, '婉儿', '20050101001X', '女一号', '花一样的女子')\nON DUPLICATE KEY UPDATE, name='张三', uk_column1='20050101002X', uk_column2='女二号', remark='牵牛花一样的女子';\n</code></pre>\n<p>有什么问题吗，执行下就知道了嘛</p>\n<div align=\"center\"><img alt=\"唯一索引冲突\" src=\"https://img2024.cnblogs.com/blog/747662/202512/747662-20251223173615530-841103305.png\" width=\"90%\" /></div>\n<p>执行报错了，提示</p>\n<blockquote>\n<p>1062 - Duplicate entry '张三' for key 'tbl_insert_on_update.name'</p>\n</blockquote>\n<p>这个错误信息我们是不是很熟悉？不就是唯一索引冲突吗？那么问题又来了</p>\n<blockquote>\n<p>用了MySQL的INSERT ON DUPLICATE KEY UPDATE，为什么还会唯一索引冲突？</p>\n</blockquote>\n<h2 id=\"如何判断是否存在\">如何判断是否存在</h2>\n<p>我们写 <code>INSERT ... ON DUPLICATE KEY UPDATE</code> 语句时，并未指定用哪个 <code>主键</code> 或者 <code>唯一索引</code> 来判定记录是否存在</p>\n<blockquote>\n<p>Oracle、SQL Server、PostgreSQL 的 <code>MERGE</code> 有类似作用</p>\n<pre><code class=\"language-sql\">MERGE INTO TBL_INSERT_ON_UPDATE t\nUSING (\n    SELECT 1 AS ID, '张三' AS NAME, '20050101001' AS UK_COLUMN1, '男一号' AS UK_COLUMN2, '风一样的男子' AS REMARK FROM dual\n) s\nON (t.NAME = s.NAME)  -- 基于 NAME 字段匹配\nWHEN MATCHED THEN\n    UPDATE SET\n        t.ID = s.ID,\n        t.UK_COLUMN1 = s.UK_COLUMN1,\n        t.UK_COLUMN2 = s.UK_COLUMN2,\n        t.REMARK = s.REMARK\nWHEN NOT MATCHED THEN\n    INSERT (ID, NAME, UK_COLUMN1, UK_COLUMN2, REMARK)\n    VALUES (s.ID, s.NAME, s.UK_COLUMN1, s.UK_COLUMN2, s.REMARK);\n</code></pre>\n<p>其中的 <code>ON</code>  明确指定匹配字段（根据哪些字段判断记录是否存在），一般是指定 <code>主键</code>字段或 <code>唯一索引</code>字段</p>\n</blockquote>\n<p>那 MySQL 是如何判定记录是否存在的呢？我们可以翻阅下官方文档：<a href=\"https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html\" rel=\"noopener nofollow\" target=\"_blank\">INSERT ... ON DUPLICATE KEY UPDATE Statement</a>。一开头有如下一段描述</p>\n<blockquote>\n<p>If you specify an <code>ON DUPLICATE KEY UPDATE</code> clause and a row to be inserted would cause a duplicate value in a <code>UNIQUE</code> index or <code>PRIMARY KEY</code>, an <a href=\"https://dev.mysql.com/doc/refman/8.0/en/update.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>UPDATE</code></a> of the old row occurs</p>\n<p>当我们使用 <code>ON DUPLICATE KEY UPDATE</code>  子句时，插入的行导致 <code>唯一</code> 索引或者 <code>主键</code> 重复时，会更新旧的行</p>\n</blockquote>\n<p>通过这段话，我们只知道 MySQL 是根据唯一索引或主键来判定行是否存在，并不知道</p>\n<ol>\n<li>先根据主键判定，不冲突之后再根据唯一索引判定？</li>\n<li>有多个唯一索引时，这些唯一索引的判定优先级是怎样的？</li>\n</ol>\n<p>官方文档里面并未明确说明这些问题，只是在结尾进行了如下说明</p>\n<blockquote>\n<p>An <a href=\"https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>INSERT ... ON DUPLICATE KEY UPDATE</code></a> statement against a table having more than one unique or primary key is also marked as unsafe. (Bug #11765650, Bug #58637)</p>\n<p>当表中有多个唯一索引或者主键时，INSERT ... ON DUPLICATE KEY UPDATE 语句不安全</p>\n</blockquote>\n<p>不安全代表执行结果不固定，会出现我们预期之外的结果</p>\n<h2 id=\"工作原理\">工作原理</h2>\n<p>如果让你们来实现 <code>不存在则插入，存在则更新</code>，你们会怎么实现？</p>\n<p>逐个查询主键以及所有唯一索引，判断该行数据是否存在，一旦存在则根据重复的主键或者唯一索引进行 <code>UPDATE</code>，都不存在则进行 <code>INSERT</code>；这不仅是你们最容易想到的实现方式，也是我最容易想到的方式。</p>\n<p>但 MySQL 并未采用这种方式，而是采用了另外一种更高效的方式，先尝试插入，存储引擎会向<strong>所有相关的唯一索引（包括主键）</strong> 中插入对应的索引条目，如果都插入成功，说明数据行不存在，那么 <code>INSERT</code> 数据行；一旦存储引擎尝试插入某个唯一索引时，发现该数据行已经存在，会立即停止插入动作，并向MySQL服务层抛出 <code>重复键</code> 错误，服务层收到重复键错误后，并不会让整个语句失败（因为使用了 ON DUPLICATE KEY UPDATE 子句），而是转换执行模式，会先回滚之前的插入，然后根据重复的那个唯一索引找到数据行对应的 <code>旧行</code> 数据，最后 <code>UPDATE</code> 数据行；总结下来分三步</p>\n<ol>\n<li>\n<p>尝试插入</p>\n<p>所有唯一索引（包括主键）都插入成功，则插入数据行，相当于完成普通的 <code>INSERT</code></p>\n<p>一旦某个唯一索引插入失败，则立即停止插入，存储引擎会向上层抛出一个 <code>重复键</code> 错误</p>\n</li>\n<li>\n<p>模式转换</p>\n<p>MySQL服务器收到重复键后，发现执行语句中有 <code>ON DUPLICATE KEY UPDATE</code> 子句，不会直接让整个语句失败，而是先回滚之前的那部分唯一索引的插入，然后根据插入失败的唯一索引找到已经存在的 <code>旧行</code></p>\n</li>\n<li>\n<p>执行更新</p>\n<p>根据插入失败的唯一索引，对旧行执行更新操作，相当于完成普通的 <code>UPDATE</code></p>\n</li>\n</ol>\n<p>整个 <code>尝试-失败-转换-更新</code> 过程时一个原子操作，那么完全成功，要么完全失败；相比于 <code>先查询后判断</code> 的传统实现，这种实现方式效率更高。</p>\n<h2 id=\"问题答疑\">问题答疑</h2>\n<p>前面涉及到两个问题，现在我们来解惑下</p>\n<ol>\n<li>\n<p>为什么拿掉 <code>name</code> 和拿掉 <code>id</code> 的 INSERT ... ON DUPLICATE KEY UPDATE 的执行结果会是一样的？</p>\n<pre><code class=\"language-sql\">-- 拿掉name\nINSERT tbl_insert_on_update(id, uk_column1, uk_column2, remark)\nVALUES(1, '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子';\n\n-- 拿掉id\nINSERT tbl_insert_on_update(name, uk_column1, uk_column2, remark)\nVALUES('张三', '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子';\n</code></pre>\n<p>这个问题是不是很简单，我们一起来分析下</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(id, uk_column1, uk_column2, remark)\nVALUES(1, '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子';\n</code></pre>\n<p>INSERT 的字段中没有 <code>name</code>，但有 <code>id</code>，可想而知判断数据行是否存在，用到的是 <code>主键</code>，因为 <code>id=1</code> 的记录已经存在，所以根据 id 去更新其他字段值；那么执行结果与如下 SQL 一致</p>\n<pre><code class=\"language-sql\">UPDATE tbl_insert_on_update SET uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子' WHERE id = 1;\n</code></pre>\n<p>同理</p>\n<pre><code class=\"language-sql\">INSERT tbl_insert_on_update(name, uk_column1, uk_column2, remark)\nVALUES('张三', '20050101001', '男一号', '风一样的男子')\nON DUPLICATE KEY UPDATE uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子';\n</code></pre>\n<p>INSERT 的字段中没有 <code>id</code>，但有 <code>name</code>，可想而知判断数据行是否存在，用到的是 <code>唯一索引</code>，因为 <code>name=张三</code> 的记录已经存在，所以根据 name 去更新其他字段值；那么执行结果与如下 SQL 一致</p>\n<pre><code class=\"language-sql\">UPDATE tbl_insert_on_update SET uk_column1='20050101003', uk_column2='男三号', remark='暴风一样的男子' WHERE name = '张三';\n</code></pre>\n<p><code>id = 1</code> 与 <code>name = '张三'</code> 指向的本来就是同一行数据，更新的列与列值都一致，那么执行结果自然就一样了</p>\n</li>\n<li>\n<p>存在多个唯一索引（包含主键）时，判断数据行是否存在，这些唯一索引的优先级顺序是怎样的？</p>\n<p>MySQL 官方文档并未明确说明这个优先级顺序，但在 MySQL 的实现中肯定有这个优先级顺序的实现算法，可能跟版本、存储引擎有关</p>\n<p>基于 <code>8.0.31</code> 版本，简单测试出以下优先级</p>\n<blockquote>\n<p>主键 &gt; 唯一索引</p>\n<p>唯一索引之间按创建顺序，先创建的优先级高</p>\n</blockquote>\n<p>官方文档已经明确说明：当表中有多个唯一索引或者主键时，INSERT ... ON DUPLICATE KEY UPDATE 语句不安全，所以如上的测试结果并不具备确定性，不能作为使用准则</p>\n</li>\n<li>\n<p>用了MySQL的INSERT ON DUPLICATE KEY UPDATE，怎么还报唯一索引冲突错误</p>\n<p>MySQL是基于尝试插入的第一个冲突的唯一索引来执行更新的，更新的字段完全有可能触发其他唯一索引（包括主键）冲突</p>\n<p>这个问题根本不成立！</p>\n</li>\n</ol>\n<h2 id=\"总结\">总结</h2>\n<ol>\n<li>\n<p>不管是 MySQL，还是 Oracle、SQL Server、PostgreSQL，针对 <code>不存在则插入，存在则更新</code> 判断数据是否存在的逻辑都是一样的，只是 MySQL 不需要显示指定 <code>判存</code> 的唯一索引（包括主键），由 MySQL 引擎内部自动实现</p>\n</li>\n<li>\n<p>关于判断数据行是否存在，多个唯一索引的优先级，看似能测出 MySQL 中的优先级，但并不具备确定性，不能作为使用准则</p>\n<p>类似不确定的排序问题还有：<a href=\"https://juejin.cn/post/7290017749715632168\" rel=\"noopener nofollow\" target=\"_blank\">我试图扯掉这条 SQL 的底裤</a></p>\n</li>\n<li>\n<p>INSERT ... ON DUPLICATE KEY UPDATE 使用过程中有一些需要注意的点，需要结合自己的业务来分析是否可以忽略这些点</p>\n<p><a href=\"https://www.cnblogs.com/youzhibing/p/15248758.html\" target=\"_blank\">记录不存在则插入，存在则更新 → MySQL 的实现方式有哪些？</a></p>\n</li>\n</ol>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 09:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/youzhibing\">青石路</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【面试题】MySQL 中使用索引一定有效吗？如何排查索引效果？",
      "link": "https://www.cnblogs.com/sun-10387834/p/19371499",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19371499\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 08:42\">\n    <span>【面试题】MySQL 中使用索引一定有效吗？如何排查索引效果？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"-mysql-索引失效的8大陷阱及排查指南\">📉 MySQL 索引失效的8大陷阱及排查指南</h1>\n<h2 id=\"-一句话明白\">🎯 一句话明白</h2>\n<p><strong>索引不是万能的！用不对反而更慢！</strong></p>\n<h2 id=\"-索引失效的8大常见场景\">🚫 索引失效的8大常见场景</h2>\n<h3 id=\"1-索引列上做计算最常见\"><strong>1. 索引列上做计算（最常见）</strong></h3>\n<pre><code class=\"language-sql\">-- ❌ 错误：在索引列上计算\nSELECT * FROM users WHERE YEAR(created_time) = 2024;\nSELECT * FROM products WHERE price * 2 &gt; 100;\n\n-- ✅ 正确：把计算移到右边\nSELECT * FROM users WHERE created_time &gt;= '2024-01-01' AND created_time &lt; '2025-01-01';\nSELECT * FROM products WHERE price &gt; 50;\n</code></pre>\n<p><strong>原因</strong>：数据库必须对<strong>每一行</strong>都计算才能比较，无法用索引快速定位。</p>\n<h3 id=\"2-索引列使用函数\"><strong>2. 索引列使用函数</strong></h3>\n<pre><code class=\"language-sql\">-- ❌ 错误：使用函数包裹索引列\nSELECT * FROM users WHERE UPPER(name) = 'JOHN';\nSELECT * FROM logs WHERE DATE(create_time) = '2024-01-01';\n\n-- ✅ 正确：使用范围查询\nSELECT * FROM users WHERE name = 'john';  -- 存入时统一小写\nSELECT * FROM logs WHERE create_time &gt;= '2024-01-01' AND create_time &lt; '2024-01-02';\n</code></pre>\n<h3 id=\"3-模糊查询开头用通配符\"><strong>3. 模糊查询开头用通配符</strong></h3>\n<pre><code class=\"language-sql\">-- ❌ 错误：以 % 开头\nSELECT * FROM users WHERE name LIKE '%张%';  -- 全表扫描\nSELECT * FROM users WHERE name LIKE '%明';\n\n-- ✅ 正确：以确定字符开头\nSELECT * FROM users WHERE name LIKE '张%';   -- 可以使用索引\nSELECT * FROM users WHERE name LIKE '张_明'; -- _匹配一个字符\n</code></pre>\n<p><strong>生活类比</strong>：</p>\n<ul>\n<li><code>张%</code> → 知道姓张，直接翻到张姓区域 ✅</li>\n<li><code>%张</code> → 不知道姓什么，只能一页页翻 ❌</li>\n</ul>\n<h3 id=\"4-or-条件使用不当\"><strong>4. OR 条件使用不当</strong></h3>\n<pre><code class=\"language-sql\">-- ❌ 错误：OR 条件中有的列没索引\nSELECT * FROM users WHERE age = 25 OR salary &gt; 10000;\n-- 如果 salary 没索引，整个查询都无法用索引\n\n-- ✅ 正确：确保 OR 两边都有索引\n-- 或者分开查询\nSELECT * FROM users WHERE age = 25\nUNION\nSELECT * FROM users WHERE salary &gt; 10000;\n</code></pre>\n<h3 id=\"5-类型不匹配隐式转换\"><strong>5. 类型不匹配（隐式转换）</strong></h3>\n<pre><code class=\"language-sql\">-- ❌ 错误：字符串列用数字查询\nCREATE TABLE users (\n    id VARCHAR(20) PRIMARY KEY,  -- 字符串类型\n    name VARCHAR(50)\n);\nSELECT * FROM users WHERE id = 123;  -- 字符串和数字比较\n\n-- ✅ 正确：类型一致\nSELECT * FROM users WHERE id = '123';\n</code></pre>\n<p><strong>测试隐式转换</strong>：</p>\n<pre><code class=\"language-sql\">-- 查看执行计划\nEXPLAIN SELECT * FROM users WHERE id = 123;\n-- 注意看 key 列是否为 NULL（没走索引）\n</code></pre>\n<h3 id=\"6-联合索引没用最左列\"><strong>6. 联合索引没用最左列</strong></h3>\n<pre><code class=\"language-sql\">-- 索引：idx_abc (a, b, c)\n\n-- ✅ 有效：用了最左列\nSELECT * FROM table WHERE a = 1;\nSELECT * FROM table WHERE a = 1 AND b = 2;\nSELECT * FROM table WHERE a = 1 AND b = 2 AND c = 3;\n\n-- ❌ 无效：没从最左开始\nSELECT * FROM table WHERE b = 2;            -- 跳过 a\nSELECT * FROM table WHERE c = 3;            -- 跳过 a,b\nSELECT * FROM table WHERE b = 2 AND c = 3;  -- 跳过 a\n</code></pre>\n<p><strong>记忆技巧</strong>：就像查字典，必须知道<strong>第一个字母</strong>才能快速查找。</p>\n<h3 id=\"7-数据量太少不如全表扫描\"><strong>7. 数据量太少，不如全表扫描</strong></h3>\n<pre><code class=\"language-sql\">-- 假设表只有 100 行数据\nSELECT * FROM small_table WHERE id = 50;\n\n-- 数据库会想：走索引要查索引树 + 回表，不如直接全表扫描更快\n</code></pre>\n<h3 id=\"8-索引列选择性太低\"><strong>8. 索引列选择性太低</strong></h3>\n<pre><code class=\"language-sql\">-- 比如\"性别\"列，只有\"男/女\"两种值\nCREATE INDEX idx_gender ON users(gender);\n\nSELECT * FROM users WHERE gender = '男';\n-- 可能失效，因为要返回接近一半的数据，不如全表扫描\n</code></pre>\n<h2 id=\"-如何排查索引失效\">🔍 如何排查索引失效？</h2>\n<h3 id=\"第1步用-explain-快速诊断\"><strong>第1步：用 EXPLAIN 快速诊断</strong></h3>\n<pre><code class=\"language-sql\">-- 在查询前加 EXPLAIN\nEXPLAIN SELECT * FROM users WHERE name LIKE '%张%';\n\n-- 关键看这几列：\n-- 1. type: ALL → 全表扫描（最差）\n-- 2. key: NULL → 没走索引\n-- 3. rows: 数值很大 → 要扫描很多行\n-- 4. Extra: Using filesort, Using temporary → 性能警告\n</code></pre>\n<h3 id=\"第2步看懂-explain-结果\"><strong>第2步：看懂 EXPLAIN 结果</strong></h3>\n<pre><code class=\"language-sql\">EXPLAIN SELECT * FROM orders WHERE user_id = 100 AND status = 'paid';\n\n-- 理想结果：\n+----+-------------+--------+------+---------------+---------+---------+-------------+------+\n| id | select_type | table  | type | possible_keys | key     | key_len | rows        | Extra|\n+----+-------------+--------+------+---------------+---------+---------+-------------+------+\n|  1 | SIMPLE      | orders | ref  | idx_user      | idx_user| 8       | 10          | NULL |\n+----+-------------+--------+------+---------------+---------+---------+-------------+------+\n\n-- type 从好到差：\n-- system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL\n-- 至少要到 range 级别才合格\n</code></pre>\n<h3 id=\"第3步使用性能分析工具\"><strong>第3步：使用性能分析工具</strong></h3>\n<pre><code class=\"language-sql\">-- 1. 开启 profiling（查看详细耗时）\nSET profiling = 1;\nSELECT * FROM users WHERE ...;\nSHOW PROFILES;\nSHOW PROFILE FOR QUERY 1;\n\n-- 2. 查看索引使用统计\nSELECT * FROM sys.schema_index_statistics \nWHERE table_name = 'users';\n\n-- 3. 找出从未使用的索引（该删除了！）\nSELECT * FROM sys.schema_unused_indexes;\n</code></pre>\n<h3 id=\"第4步慢查询日志分析\"><strong>第4步：慢查询日志分析</strong></h3>\n<pre><code class=\"language-sql\">-- 1. 开启慢查询日志\nSET GLOBAL slow_query_log = 'ON';\nSET GLOBAL long_query_time = 2;  -- 超过2秒记录\n\n-- 2. 查看慢查询日志位置\nSHOW VARIABLES LIKE 'slow_query_log_file';\n\n-- 3. 使用工具分析（推荐）\n-- mysqldumpslow 或 pt-query-digest\n</code></pre>\n<h2 id=\"️-实战排查案例\">🛠️ 实战排查案例</h2>\n<h3 id=\"案例1为什么这个查询慢\"><strong>案例1：为什么这个查询慢？</strong></h3>\n<pre><code class=\"language-sql\">-- 原始查询（很慢）\nSELECT * FROM orders \nWHERE DATE_FORMAT(create_time, '%Y-%m') = '2024-01'\nORDER BY amount DESC;\n\n-- 步骤1：EXPLAIN分析\nEXPLAIN SELECT * FROM orders WHERE DATE_FORMAT(create_time, '%Y-%m') = '2024-01';\n\n-- 发现：type=ALL, key=NULL（没走索引）\n-- 原因：对 create_time 使用了函数\n\n-- 优化方案：\nSELECT * FROM orders \nWHERE create_time &gt;= '2024-01-01' \n  AND create_time &lt; '2024-02-01'\nORDER BY amount DESC;\n\n-- 再 EXPLAIN：type=range, key=idx_create_time ✅\n</code></pre>\n<h3 id=\"案例2联合索引问题\"><strong>案例2：联合索引问题</strong></h3>\n<pre><code class=\"language-sql\">-- 查询：经常按城市和年龄搜索用户\nSELECT * FROM users WHERE city = '北京' AND age &gt; 25;\n\n-- 现有索引：idx_age_city (age, city)\n-- 问题：最左列是 age，但查询先过滤 city\n\n-- 解决方案：\n-- 1. 调整查询顺序（如果业务允许）\nSELECT * FROM users WHERE age &gt; 25 AND city = '北京';\n\n-- 2. 或创建新索引\nCREATE INDEX idx_city_age ON users(city, age);\n</code></pre>\n<h2 id=\"-索引效果评估表\">📊 索引效果评估表</h2>\n<table>\n<thead>\n<tr>\n<th>检查项</th>\n<th>合格标准</th>\n<th>如何检查</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>索引使用率</strong></td>\n<td>&gt; 90%</td>\n<td><code>SHOW STATUS LIKE 'Handler_read%'</code></td>\n</tr>\n<tr>\n<td><strong>查询响应时间</strong></td>\n<td>&lt; 100ms</td>\n<td>慢查询日志</td>\n</tr>\n<tr>\n<td><strong>扫描行数</strong></td>\n<td>rows &lt; 1000</td>\n<td>EXPLAIN 的 rows 列</td>\n</tr>\n<tr>\n<td><strong>临时表使用</strong></td>\n<td>尽量避免</td>\n<td>EXPLAIN 的 Extra 列</td>\n</tr>\n<tr>\n<td><strong>文件排序</strong></td>\n<td>尽量避免</td>\n<td>EXPLAIN 的 Extra 列</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"-最佳实践清单\">🎯 最佳实践清单</h2>\n<h3 id=\"创建索引前问自己\"><strong>创建索引前问自己：</strong></h3>\n<ol>\n<li>✅ 这个查询真的需要索引吗？（数据量小不需要）</li>\n<li>✅ 索引列的选择性高吗？（唯一值多吗？）</li>\n<li>✅ 会频繁更新这个列吗？（更新频繁的列不适合建索引）</li>\n<li>✅ 已经有类似的索引了吗？（避免重复索引）</li>\n</ol>\n<h3 id=\"创建索引后要检查\"><strong>创建索引后要检查：</strong></h3>\n<pre><code class=\"language-sql\">-- 1. 验证索引被使用\nEXPLAIN SELECT ...;\n\n-- 2. 监控索引大小\nSELECT \n    table_name,\n    index_name,\n    ROUND(SUM(index_length)/1024/1024, 2) AS '索引大小(MB)'\nFROM information_schema.TABLES \nWHERE table_schema = '你的数据库'\nGROUP BY table_name, index_name;\n\n-- 3. 定期清理无用索引\n-- 查看使用频率低的索引\nSELECT * FROM sys.schema_unused_indexes;\n</code></pre>\n<h2 id=\"-简单记忆口诀\">💡 简单记忆口诀</h2>\n<p><strong>索引失效八大坑：</strong></p>\n<ol>\n<li>计算函数不用想</li>\n<li>模糊查询百分左</li>\n<li>类型转换隐式藏</li>\n<li>OR 条件要全防</li>\n<li>最左前缀不能忘</li>\n<li>数据量少全表爽</li>\n<li>选择性低是白忙</li>\n<li>不等号&lt;&gt;也够呛</li>\n</ol>\n<p><strong>排查四步曲：</strong></p>\n<ol>\n<li><strong>EXPLAIN</strong> 看计划</li>\n<li><strong>慢日志</strong> 抓真凶</li>\n<li><strong>PROFILE</strong> 查明细</li>\n<li><strong>统计表</strong> 清无用</li>\n</ol>\n<p>记住：<strong>索引就像书的目录，但翻目录本身也需要时间。如果书只有10页，不如直接翻；如果目录编排不合理，还不如不用！</strong></p>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19371499\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19371499</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 08:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI快速上手：请求与响应的核心玩法",
      "link": "https://www.cnblogs.com/ymtianyu/p/19389987",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19389987\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 08:24\">\n    <span>FastAPI快速上手：请求与响应的核心玩法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文详细介绍了如何使用FastAPI框架处理Web开发中的核心请求与响应。内容涵盖路由定义、GET与POST请求方法、查询参数与路径参数的使用、请求头与响应头的操作、表单数据的解析以及重定向的实现，并提供了可直接运行的完整代码示例，帮助读者快速掌握FastAPI的基础应用。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<div style=\"margin-bottom: 30px;\">\n<p style=\"font-size: 18px; color: rgba(102, 102, 102, 1);\">还在为构建高性能API而烦恼？知道吗，<strong style=\"color: rgba(186, 55, 42, 1);\">FastAPI</strong>框架的性能与<code>NodeJS</code>和<code>Go</code>相当，同时提供极佳的开发体验。</p>\n</div>\n<div style=\"background-color: rgba(249, 249, 249, 1); padding: 15px 20px; margin: 25px 0; border-radius: 0 4px 4px 0;\">\n<p style=\"margin: 0; color: rgba(44, 62, 80, 1); font-weight: bold;\">📖 文章摘要</p>\n<p style=\"margin: 10px 0 0; color: rgba(85, 85, 85, 1);\">本文带你快速上手FastAPI的请求与响应处理核心。你将清晰地掌握如何定义路由、处理GET/POST请求、玩转查询与路径参数、管理请求头与响应头、解析表单数据以及实现页面重定向。文末附有可直接运行的完整代码示例。</p>\n<br />\n<p style=\"margin: 0; color: rgba(44, 62, 80, 1); font-weight: bold;\">🚀 你将学到：</p>\n<p style=\"margin: 5px 0 0; color: rgba(85, 85, 85, 1);\">- 路由与请求方法的基础定义<br />- 如何接收查询参数和路径参数<br />- 处理POST请求与JSON数据<br />- 读取请求头与设置自定义响应头<br />- 解析application/x-www-form-urlencoded表单数据<br />- 实现简单的重定向响应</p>\n</div>\n<h2 style=\"padding-bottom: 10px; margin-top: 40px;\">✨ 目录</h2>\n<p style=\"color: rgba(85, 85, 85, 1);\">- 🛣️ 第一步：从路由与请求方法开始<br />- 🔍 GET请求：查询参数与路径参数<br />- 📤 POST请求：接收JSON与表单数据<br />- 📨 请求头与响应头：细节控制<br />- ↪️ 重定向：让请求跳转起来<br />- 💻 完整代码示例：一个迷你API服务</p>\n<h2 id=\"route\" style=\"margin-top: 45px; color: rgba(44, 62, 80, 1);\">🛣️ 第一步：从路由与请求方法开始</h2>\n<p>在FastAPI中，一切从<code>app</code>实例和装饰器开始。<code>@app.get()</code>、<code>@app.post()</code>等装饰器定义了URL路径和HTTP方法。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n# 定义一个处理根路径GET请求的路由\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Hello, FastAPI World!\"}\n\n# 定义一个处理'/items'路径GET请求的路由\n@app.get(\"/items/\")\ndef read_items():\n    return [{\"item_id\": 1, \"name\": \"Foo\"}]</code></pre>\n<p>看，就这么简单！<strong style=\"color: rgba(186, 55, 42, 1);\">每个函数对应一个API端点</strong>，返回值自动转换为JSON响应。</p>\n<h2 id=\"get\" style=\"margin-top: 45px; color: rgba(44, 62, 80, 1);\">🔍 GET请求：查询参数与路径参数</h2>\n<p>GET请求常用于获取数据，参数通常通过URL传递。主要有两种方式：<strong style=\"color: rgba(186, 55, 42, 1);\">查询参数</strong>和<strong style=\"color: rgba(186, 55, 42, 1);\">路径参数</strong>。</p>\n<p><strong>查询参数</strong>：跟在URL问号<code>?</code>后面，如<code>/items/?skip=0&amp;limit=10</code>。在函数参数中声明即可自动获取。</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.get(\"/items/\")\ndef read_items(skip: int = 0, limit: int = 10):\n    # 模拟从数据库读取数据\n    fake_items = [{\"item_id\": i} for i in range(skip, skip + limit)]\n    return fake_items</code></pre>\n<p><strong>路径参数</strong>：直接嵌在URL路径中，如<code>/items/123</code>。在路由中用<code>{}</code>声明。</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int): # 类型注解会自动进行验证和转换\n    return {\"item_id\": item_id, \"name\": f\"Item {item_id}\"}</code></pre>\n<p>FastAPI的<strong style=\"color: rgba(186, 55, 42, 1);\">类型提示</strong>功能会帮你自动验证参数类型，并提供漂亮的API文档！</p>\n<h2 id=\"post\" style=\"margin-top: 45px; color: rgba(44, 62, 80, 1);\">📤 POST请求：接收JSON与表单数据</h2>\n<p>POST请求用于创建或提交数据。最常见的是接收<strong style=\"color: rgba(186, 55, 42, 1);\">JSON</strong>和<strong style=\"color: rgba(186, 55, 42, 1);\">表单</strong>数据。</p>\n<p><strong>1. 接收JSON数据</strong>：使用Pydantic模型来定义数据结构。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n\n@app.post(\"/items/\")\ndef create_item(item: Item): # 将请求体声明为Item类型\n    # 可以直接使用item的属性\n    item_dict = item.dict()\n    if item.tax:\n        total_price = item.price + item.tax\n        item_dict.update({\"total_price\": total_price})\n    return item_dict</code></pre>\n<p><strong>2. 接收表单数据</strong>：当数据来自HTML表单时，使用<code>Form</code>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Form\n\n@app.post(\"/login/\")\ndef login(username: str = Form(...), password: str = Form(...)):\n    # Form(...)表示必填字段\n    return {\"username\": username, \"login_status\": \"success\"}</code></pre>\n<p>注意：使用<code>Form</code>前需要先安装<code>python-multipart</code>库。</p>\n<h2 id=\"header\" style=\"margin-top: 45px; color: rgba(44, 62, 80, 1);\">📨 请求头与响应头：细节控制</h2>\n<p>有时你需要读取客户端的请求头，或者为响应添加自定义头部信息。</p>\n<p><strong>读取请求头</strong>：使用<code>Header</code>函数。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Header\n\n@app.get(\"/headers/\")\ndef read_headers(user_agent: str | None = Header(None)):\n    return {\"User-Agent\": user_agent}</code></pre>\n<p><strong>设置响应头</strong>：返回一个<code>Response</code>对象，或在依赖中设置。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Response\n\n@app.get(\"/custom-header/\")\ndef set_custom_header(response: Response):\n    response.headers[\"X-Custom-Header\"] = \"MyCustomValue\"\n    return {\"message\": \"Check the headers!\"}</code></pre>\n<h2 id=\"redirect\" style=\"margin-top: 45px; color: rgba(44, 62, 80, 1);\">↪️ 重定向：让请求跳转起来</h2>\n<p>重定向在Web开发中很常见，比如登录后跳转到首页。使用<code>RedirectResponse</code>即可轻松实现。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi.responses import RedirectResponse\n\n@app.get(\"/old-link/\")\ndef old_link():\n    # 永久重定向到新的URL\n    return RedirectResponse(url=\"/new-link/\", status_code=301)\n\n@app.get(\"/new-link/\")\ndef new_link():\n    return {\"message\": \"This is the new endpoint!\"}</code></pre>\n<h2 id=\"full-code\" style=\"margin-top: 45px; color: rgba(44, 62, 80, 1);\">💻 完整代码示例：一个迷你API服务</h2>\n<p>将上面的知识点整合，创建一个简单的笔记API。保存为<code>main.py</code>，然后用<code>uvicorn main:app --reload</code>运行它！</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, Path, Query, Header, Form, Response\nfrom fastapi.responses import RedirectResponse\nfrom pydantic import BaseModel\nfrom typing import Optional\n\napp = FastAPI(title=\"迷你笔记API\")\n\n# 数据模型\nclass Note(BaseModel):\n    title: str\n    content: str\n\n# 模拟数据库\nfake_notes_db = [{\"id\": 1, \"title\": \"First Note\", \"content\": \"Hello!\"}]\n\n# 首页重定向到文档\n@app.get(\"/\")\ndef home():\n    return RedirectResponse(url=\"/docs\")\n\n# 获取所有笔记 (带查询参数分页)\n@app.get(\"/notes/\")\ndef get_notes(skip: int = Query(0, ge=0), limit: int = Query(10, le=100)):\n    return fake_notes_db[skip : skip + limit]\n\n# 根据ID获取特定笔记 (路径参数)\n@app.get(\"/notes/{note_id}\")\ndef get_note_by_id(note_id: int = Path(..., title=\"笔记ID\", gt=0)):\n    for note in fake_notes_db:\n        if note[\"id\"] == note_id:\n            return note\n    return {\"error\": \"Note not found\"}\n\n# 创建新笔记 (POST JSON)\n@app.post(\"/notes/\")\ndef create_note(note: Note, response: Response):\n    new_id = max([n[\"id\"] for n in fake_notes_db], default=0) + 1\n    new_note = {\"id\": new_id, **note.dict()}\n    fake_notes_db.append(new_note)\n    response.headers[\"Location\"] = f\"/notes/{new_id}\"\n    response.status_code = 201\n    return new_note\n\n# 一个需要User-Agent头的端点\n@app.get(\"/check-agent/\")\ndef check_user_agent(user_agent: Optional[str] = Header(None)):\n    return {\"received_user_agent\": user_agent}\n\n# 表单登录示例\n@app.post(\"/login-form/\")\ndef login_form(username: str = Form(...), password: str = Form(...)):\n    # 这里应该有真实的验证逻辑\n    if username == \"admin\" and password == \"secret\":\n        return {\"message\": \"Login successful\"}\n    return {\"message\": \"Invalid credentials\"}</code></pre>\n<p>启动后，访问 <a href=\"http://127.0.0.1:8000/docs\" rel=\"noopener nofollow\" style=\"color: rgba(76, 175, 80, 1); text-decoration: none;\">http://127.0.0.1:8000/docs</a> 即可看到交互式API文档，并直接测试所有端点！</p>\n<hr style=\"border-right: none; border-bottom: none; border-left: none; margin: 40px 0;\" />\n<div style=\"text-align: center; color: rgba(119, 119, 119, 1); margin-bottom: 40px;\">\n<p>---</p>\n<p style=\"font-size: 15px;\">喜欢本文？不要错过✨，点赞👍收藏⭐关注我👆，一起学习更多有用的知识，完善你我的技能树！</p>\n</div>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 08:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">曲幽</a>&nbsp;\n阅读(<span id=\"post_view_count\">18</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "PHP 初学者指南 基础结构与常见错误",
      "link": "https://www.cnblogs.com/catchadmin/p/19389942",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19389942\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 08:10\">\n    <span>PHP 初学者指南 基础结构与常见错误</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"php-初学者指南-基础结构与常见错误\">PHP 初学者指南 基础结构与常见错误</h1>\n<p>PHP(Hypertext Preprocessor)是 Web 开发中使用最广泛的脚本语言之一。无论是构建动态网站还是复杂应用,PHP 通常都是核心。然而对于初学者来说,入门 PHP 可能有点令人生畏。语法特性、最佳实践和各种陷阱混杂在一起,很容易迷失方向。</p>\n<p>突然间,我觉得有必要讨论一些非常基础但对刚接触 PHP 的初学者至关重要的内容。许多新手开发者忽视了理解基本结构和 PHP 中常见错误的重要性。虽然这些看起来微不足道,但掌握这些基础知识将帮助你编写更整洁、更高效的代码,并避免可能损害项目的问题。</p>\n<p>本文将探讨 PHP 的基本结构,并重点介绍初学者最常犯的一些错误。无论你是刚起步还是有一些经验,理解这些基础知识以及如何避免错误,都将帮助你编写整洁、高效且安全的 PHP 代码。</p>\n<p>让我们以简单、清晰且易于理解的方式来分解这些内容。</p>\n<p><a href=\"https://catchadmin.com/post/2025-12/php-for-beginners-essential-structure-and-common-mistakes\" rel=\"noopener nofollow\" target=\"_blank\">原文链接 PHP 初学者指南 基础结构与常见错误</a></p>\n<h2 id=\"php-结构基础知识\">PHP 结构:基础知识</h2>\n<p>在深入常见错误之前,我们先看看每个初学者都必须理解的 PHP 基本结构。</p>\n<h3 id=\"php-语法\">PHP 语法</h3>\n<p>PHP 代码嵌入在 HTML 中。要在网页中执行 PHP,我们用 <code>&lt;?php ... ?&gt;</code> 标签包裹 PHP 代码。</p>\n<p>示例:</p>\n<pre><code class=\"language-php\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;PHP Basics&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Welcome to PHP!&lt;/h1&gt;\n    &lt;?php\n    echo \"Hello, World!\";\n    ?&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>在上面的示例中,PHP 块 <code>&lt;?php echo \"Hello, World!\"; ?&gt;</code> 在 HTML body 中生成消息 \"Hello, World!\"。理解基本语法是编写 PHP 脚本的第一步。</p>\n<h3 id=\"变量和数据类型\">变量和数据类型</h3>\n<p>在 PHP 中,变量以美元符号 <code>$</code> 为前缀,后跟变量名。PHP 是弱类型语言,这意味着声明变量时不需要指定数据类型。类型将根据赋值自动推断。</p>\n<p>示例:</p>\n<pre><code class=\"language-php\">$name = \"John\";      // String\n$age = 30;           // Integer\n$height = 5.9;       // Float\n$isStudent = true;   // Boolean\n</code></pre>\n<h3 id=\"函数\">函数</h3>\n<p>PHP 中的函数是可重用的代码块。使用 <code>function</code> 关键字定义它们,这有助于组织和模块化代码。</p>\n<p>示例:</p>\n<pre><code class=\"language-php\">&lt;?php\nfunction greet($name) {\n    return \"Hello, $name!\";\n}\necho greet(\"Alice\"); // Outputs: Hello, Alice!\n?&gt;\n</code></pre>\n<p>理解如何定义和使用函数将在代码变得更复杂时为你节省大量时间和精力。</p>\n<h2 id=\"初学者在-php-中常犯的错误\">初学者在 PHP 中常犯的错误</h2>\n<p>虽然 PHP 是一门强大而灵活的语言,但初学者经常会犯一些常见错误。让我们深入了解一些最常见的陷阱以及如何避免它们。</p>\n<h3 id=\"忘记使用正确的-php-标签\">忘记使用正确的 PHP 标签</h3>\n<p>一个常见错误是忘记正确打开或关闭 PHP 标签。PHP 代码必须始终包含在 <code>&lt;?php ... ?&gt;</code> 中。如果这些标签缺失或不正确,代码将无法运行。</p>\n<p>错误示例:</p>\n<pre><code class=\"language-php\">&lt;html&gt;\n&lt;body&gt;\n    echo \"Hello, World!\"; // Error: no PHP opening tag\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>正确示例:</p>\n<pre><code class=\"language-php\">&lt;html&gt;\n&lt;body&gt;\n    &lt;?php echo \"Hello, World!\"; ?&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3 id=\"字符串中未转义特殊字符\">字符串中未转义特殊字符</h3>\n<p>处理字符串时,需要转义特殊字符,特别是在字符串中使用引号时。否则会导致语法错误。</p>\n<p>错误示例:</p>\n<pre><code class=\"language-php\">$greeting = \"He said, \"Hello!\"\";\n</code></pre>\n<p>正确示例:</p>\n<pre><code class=\"language-php\">$greeting = \"He said, \\\"Hello!\\\"\";\n</code></pre>\n<p>或者,可以对外层字符串使用单引号:</p>\n<pre><code class=\"language-php\">$greeting = 'He said, \"Hello!\"';\n</code></pre>\n<p>这个小错误可能导致代码出现意外行为,所以务必正确处理特殊字符。</p>\n<h3 id=\"使用错误的比较运算符\">使用错误的比较运算符</h3>\n<p>PHP 有两种比较运算符:<code>=</code> 用于赋值,<code>==</code> 用于比较。初学者经常混淆这两者,导致意外结果。</p>\n<p>错误示例:</p>\n<pre><code class=\"language-php\">$age = 30;\nif ($age = 25) {  // Mistake: uses assignment, not comparison\n    echo \"Age is 25\";\n}\n</code></pre>\n<p>正确示例:</p>\n<pre><code class=\"language-php\">$age = 30;\nif ($age == 25) {  // Correct: comparison operator\n    echo \"Age is 25\";\n}\n</code></pre>\n<p>在 if 语句中使用赋值运算符 <code>=</code> 会导致错误的条件判断。始终使用 <code>==</code> 进行比较以避免此类错误。</p>\n<h3 id=\"未使用适当的缩进和代码格式\">未使用适当的缩进和代码格式</h3>\n<p>虽然 PHP 不强制严格的缩进规则,但未能正确格式化代码会使其难以阅读和调试,特别是随着项目的增长。</p>\n<p>错误示例:</p>\n<pre><code class=\"language-php\">&lt;?php\n    function greet($name){\n      if($name==\"Alice\"){echo \"Hello, Alice!\";}else{echo \"Hello, Guest!\";}\n    }\n?&gt;\n</code></pre>\n<p>正确示例:</p>\n<pre><code class=\"language-php\">&lt;?php\nfunction greet($name) {\n    if ($name == \"Alice\") {\n        echo \"Hello, Alice!\";\n    } else {\n        echo \"Hello, Guest!\";\n    }\n}\n?&gt;\n</code></pre>\n<p>正确格式化的代码不仅仅关乎美观——它对可读性和可维护性至关重要。</p>\n<h3 id=\"不当使用全局变量\">不当使用全局变量</h3>\n<p>如果不谨慎使用,全局变量可能导致不可预测的行为。通常最好在函数之间显式传递变量,而不是依赖全局作用域。</p>\n<p>错误示例:</p>\n<pre><code class=\"language-php\">$counter = 10;\nfunction increaseCounter() {\n    $counter++;  // Refers to the global variable\n}\nincreaseCounter();\necho $counter;  // Outputs 11\n</code></pre>\n<p>更好的做法:</p>\n<pre><code class=\"language-php\">$counter = 10;\nfunction increaseCounter($counter) {\n    return $counter + 1;\n}\n$counter = increaseCounter($counter);\necho $counter;  // Outputs 11\n</code></pre>\n<p>显式传递变量使代码更可预测,更易于调试。</p>\n<h2 id=\"编写整洁-php-代码的最佳实践\">编写整洁 PHP 代码的最佳实践</h2>\n<p>现在我们已经介绍了一些常见错误,让我们探讨一些能帮助你编写更好 PHP 代码的最佳实践。</p>\n<h3 id=\"使用-isset-和-empty-检查变量\">使用 isset() 和 empty() 检查变量</h3>\n<p>在访问变量之前,检查它是否已设置很重要。使用 <code>isset()</code> 和 <code>empty()</code> 有助于防止访问未定义变量时出错。</p>\n<pre><code class=\"language-php\">if (isset($username) &amp;&amp; !empty($username)) {\n    echo \"Username is set and not empty.\";\n}\n</code></pre>\n<p>这有助于避免意外错误,使代码更健壮。</p>\n<h3 id=\"始终清理用户输入\">始终清理用户输入</h3>\n<p>PHP 经常用于处理用户输入,但未经检查的输入可能导致安全漏洞,如 SQL 注入或 XSS 攻击。始终清理和验证用户输入。</p>\n<pre><code class=\"language-php\">$username = htmlspecialchars($_POST['username']);\n</code></pre>\n<p>使用 <code>htmlspecialchars()</code> 等函数或数据库查询的预处理语句对于编写安全的 PHP 应用至关重要。</p>\n<h3 id=\"保持函数小而专注\">保持函数小而专注</h3>\n<p>理想情况下,一个函数应该执行一项任务并做好它。保持函数小而专注于单一职责,使代码更模块化且更易于测试。</p>\n<p>示例:</p>\n<pre><code class=\"language-php\">function fetchUserData($userId) {\n    // Fetch user data from database\n}\nfunction displayUserProfile($userData) {\n    // Display user profile information\n}\n</code></pre>\n<p>通过分离关注点,每个函数都变得更易于理解和修改。</p>\n<h2 id=\"进阶技巧\">进阶技巧</h2>\n<h3 id=\"使用命名空间\">使用命名空间</h3>\n<p>随着项目的增长,将代码组织到命名空间中以避免命名冲突变得越来越重要。</p>\n<pre><code class=\"language-php\">namespace MyApp\\Controllers;\nclass UserController {\n    public function show() {\n        echo \"Displaying user profile.\";\n    }\n}\n</code></pre>\n<p>命名空间有助于保持代码组织有序,并防止命名冲突,特别是在大型项目中。</p>\n<h3 id=\"使用-composer-进行依赖管理\">使用 Composer 进行依赖管理</h3>\n<p>PHP 项目通常依赖外部库。Composer 是管理这些依赖的最佳工具。</p>\n<pre><code class=\"language-bash\">composer require vendor/package\n</code></pre>\n<p>Composer 简化了依赖管理,并确保库始终保持最新。</p>\n<h2 id=\"结语\">结语</h2>\n<p>掌握 PHP 需要对其结构和常见陷阱有扎实的理解。通过遵循最佳实践并避免错误,你将顺利编写整洁、高效且安全的 PHP 代码。虽然 PHP 一开始可能看起来令人生畏,但有了正确的基础,你很快就能轻松构建强大的应用。</p>\n<p>无论你是刚起步还是希望提升技能,这些见解都将帮助你成为更自信、更有能力的 PHP 开发者。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 08:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一条SQL直接跑崩288核，1.5T内存数据库",
      "link": "https://www.cnblogs.com/idealx/p/19389621",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/idealx/p/19389621\" id=\"cb_post_title_url\" title=\"发布于 2025-12-23 23:48\">\n    <span>一条SQL直接跑崩288核，1.5T内存数据库</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近遇到一个Oracle的SQL语句引发的线上故障，数据库服务被重启。主机288核，1.5T也没抗住。</p>\n<pre><code>select  count(*) from dev_db.t1 t1,dev_db.t2 t2 where t1.object_name = t2.object_name or t1.DATA_OBJECT_ID = t2.DATA_OBJECT_ID and t1.OBJECT_ID = 123 and rownum = 1;\n--------------------------------------------------------------------------------\n| Id  | Operation               | Name | Rows  | Bytes | Cost (%CPU)| Time     |\n--------------------------------------------------------------------------------\n|   0 | SELECT STATEMENT        |      |     1 |    77 |    31M  (1)| 00:20:50 |\n|   1 |  SORT AGGREGATE         |      |     1 |    77 |            |          |\n|   2 |   COUNT                 |      |       |       |            |          |\n|*  3 |    FILTER               |      |       |       |            |          |\n|   4 |     MERGE JOIN CARTESIAN|      |  6131M|   439G|    31M  (1)| 00:20:50 |\n|   5 |      TABLE ACCESS FULL  | T1   | 78306 |  3135K|   411   (1)| 00:00:01 |\n|   6 |      BUFFER SORT        |      | 78307 |  2752K|    31M  (1)| 00:20:50 |\n|   7 |       TABLE ACCESS FULL | T2   | 78307 |  2752K|   409   (1)| 00:00:01 |\n--------------------------------------------------------------------------------\n\nPredicate Information (identified by operation id):\n---------------------------------------------------\n\n   3 - filter(\"T1\".\"OBJECT_NAME\"=\"T2\".\"OBJECT_NAME\" OR\n              \"T1\".\"DATA_OBJECT_ID\"=\"T2\".\"DATA_OBJECT_ID\" AND \"T2\".\"DATA_OBJECT_ID\"\n              IS NOT NULL AND \"T1\".\"DATA_OBJECT_ID\" IS NOT NULL AND\n              \"T1\".\"OBJECT_ID\"=123 AND ROWNUM=1)\n</code></pre>\n<p>在执行计划中看到步骤4产生了笛卡尔积连接，成本相当的高，这两个表仅有7万行数据，执行时间超过了5分钟。<br />\n数据库中关于NOT、AND、OR的逻辑运算优先级就是按这个顺序进行的，判断是开发人员失误造成的。下面是经过优化后的执行计划。</p>\n<pre><code>select  count(*) from dev_db.t1 t1,dev_db.t2 t2 where (t1.object_name = t2.object_name or t1.DATA_OBJECT_ID = t2.DATA_OBJECT_ID) and t1.OBJECT_ID = 123 and rownum = 1;\n-----------------------------------------------------------------------------\n| Id  | Operation            | Name | Rows  | Bytes | Cost (%CPU)| Time     |\n-----------------------------------------------------------------------------\n|   0 | SELECT STATEMENT     |      |     1 |    77 |   822   (1)| 00:00:01 |\n|   1 |  SORT AGGREGATE      |      |     1 |    77 |            |          |\n|*  2 |   COUNT STOPKEY      |      |       |       |            |          |\n|   3 |    NESTED LOOPS      |      |     1 |    77 |   822   (1)| 00:00:01 |\n|*  4 |     TABLE ACCESS FULL| T1   |     1 |    41 |   411   (1)| 00:00:01 |\n|*  5 |     TABLE ACCESS FULL| T2   |     1 |    36 |   411   (1)| 00:00:01 |\n-----------------------------------------------------------------------------\n\nPredicate Information (identified by operation id):\n---------------------------------------------------\n\n   2 - filter(ROWNUM=1)\n   4 - filter(\"T1\".\"OBJECT_ID\"=123)\n   5 - filter(\"T1\".\"OBJECT_NAME\"=\"T2\".\"OBJECT_NAME\" OR\n              \"T2\".\"DATA_OBJECT_ID\" IS NOT NULL AND\n              \"T1\".\"DATA_OBJECT_ID\"=\"T2\".\"DATA_OBJECT_ID\" AND \"T1\".\"DATA_OBJECT_ID\"\n              IS NOT NULL)\n</code></pre>\n<p>在这个执行计划中，t1表作为驱动表，过滤条件是object_id=123,线上这个条件是主键，因为懒没有创建这个主键，所以是全表扫描。<br />\nt2表作为被驱动表只匹配到了一条数据。因为STOPKEY的优化，在取到一条数据后SQL停止，无需扫描全部数据，因此执行时间非常短。</p>\n<h2 id=\"总结\">总结</h2>\n<p>本次问题原因是因为一个逻辑运算的优先级判断错误，以至于数据库资源被使用完导致数据库节点被重启。<br />\n对于自己拿不准的SQL语句，查阅官方文档是最权威的参考依据。<br />\n其次，在测试环境就算只有少量数据也可以看到执行计划是否合理。<br />\n最后，上线时SQL语句经过把关，可以最大限度减少SQL语句引发的线上故障。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-23 23:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/idealx\">ideal_x</a>&nbsp;\n阅读(<span id=\"post_view_count\">95</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Flink源码阅读：状态管理",
      "link": "https://www.cnblogs.com/Jackeyzhe/p/19389264",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Jackeyzhe/p/19389264\" id=\"cb_post_title_url\" title=\"发布于 2025-12-23 21:44\">\n    <span>Flink源码阅读：状态管理</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Flink源码阅读：状态管理\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1828322/202512/1828322-20251223214418733-1509708883.png\" />\n        前面我们介绍了 Flink 状态的分类和应用。今天从源码层面再看一下 Flink 是如何管理状态的。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>前面我们介绍了 Flink 状态的分类和应用。今天从源码层面再看一下 Flink 是如何管理状态的。</p>\n<h3 id=\"state-概述\">State 概述</h3>\n<p>关于 State 的详细介绍可以参考 <a href=\"https://jackeyzhe.github.io/2025/08/04/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8A%B6%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8/\" rel=\"noopener nofollow\" target=\"_blank\">Flink学习笔记：状态类型和应用</a> 和 <a href=\"https://jackeyzhe.github.io/2025/08/24/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF/\" rel=\"noopener nofollow\" target=\"_blank\">Flink学习笔记：状态后端</a>这两篇文章，为了方面阅读，这里我们再简单介绍一下。</p>\n<h4 id=\"state-使用\">State 使用</h4>\n<p>State 是 Flink 做复杂逻辑所依赖的核心组件。它的分类如下</p>\n<p><img alt=\"State 分类\" class=\"lazyload\" /></p>\n<p>常见的是 Keyed State 和 Operator State，Keyed State 作用于 KeyedStream 上，Operator State 可以作用于所有的 Operator 上。Keyed State 使用时，需要先创建 StateDescriptor，然后再调用 getState 获取。</p>\n<pre><code class=\"language-java\">ValueStateDescriptor&lt;Tuple2&lt;Long, Long&gt;&gt; descriptor =\n        new ValueStateDescriptor&lt;&gt;(\n                \"average\",\n                TypeInformation.of(new TypeHint&lt;Tuple2&lt;Long, Long&gt;&gt;() {}));\nValueState&lt;Tuple2&lt;Long, Long&gt;&gt; sum = getRuntimeContext().getState(descriptor);\n</code></pre>\n<p>Opeartor State 的获取方式与 Keyed State 类似，都需要 StateDescriptor。Operator State 在定义时需要实现 CheckpointedFunction。</p>\n<h4 id=\"state-存储\">State 存储</h4>\n<p>State Backend 用来管理 State 存储，根据存储格式和存储类型的组合，可以分为三类：</p>\n<ol>\n<li>\n<p>MemoryStateBackend：HashMapStateBackend 和 JobManagerCheckpointStorage 的组合，即将 State 以 Java 对象的形式存储在 JobManager 内存中。</p>\n</li>\n<li>\n<p>FsStateBackend：HashMapStateBackend 和 FileSystemCheckpointStorage 的组合，将 State 以 Java 对象的形式存储在远端文件系统中。</p>\n</li>\n<li>\n<p>RocksDBStateBackend：EmbeddedRocksDBStateBackend 和 FileSystemCheckpointStorage 的组合，State 序列化后存储在 RocksDB。</p>\n</li>\n</ol>\n<h3 id=\"创建-state-backend\">创建 State Backend</h3>\n<p>创建 State Backend 的入口在 StreamTask，StreamTask 是 Flink 部署和运行在 TaskManager 的基本单元。</p>\n<p>在 StreamTask 的 invoke 方法中，会先调用 restoreStateAndGates 方法去创建 State Backend。完整的调用链路如下图所示。</p>\n<p><img alt=\"stateBackend\" class=\"lazyload\" /></p>\n<p>在 streamOperatorStateContext 方法中，分别调用了 keyedStatedBackend 和 operatorStateBackend 来创建两种 State Backend。</p>\n<p>我们先来看 keyedStateBackend 的逻辑。</p>\n<pre><code class=\"language-java\">protected &lt;K, R extends Disposable &amp; Closeable&gt; R keyedStatedBackend(\n        TypeSerializer&lt;K&gt; keySerializer,\n        String operatorIdentifierText,\n        PrioritizedOperatorSubtaskState prioritizedOperatorSubtaskStates,\n        CloseableRegistry backendCloseableRegistry,\n        MetricGroup metricGroup,\n        double managedMemoryFraction,\n        StateObject.StateObjectSizeStatsCollector statsCollector,\n        KeyedStateBackendCreator&lt;K, R&gt; keyedStateBackendCreator)\n        throws Exception {\n\n    if (keySerializer == null) {\n        return null;\n    }\n\n    ......\n\n    final KeyGroupRange keyGroupRange =\n            KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(\n                    taskInfo.getMaxNumberOfParallelSubtasks(),\n                    taskInfo.getNumberOfParallelSubtasks(),\n                    taskInfo.getIndexOfThisSubtask());\n\n    // Now restore processing is included in backend building/constructing process, so we need\n    // to make sure\n    // each stream constructed in restore could also be closed in case of task cancel, for\n    // example the data\n    // input stream opened for serDe during restore.\n    CloseableRegistry cancelStreamRegistryForRestore = new CloseableRegistry();\n    backendCloseableRegistry.registerCloseable(cancelStreamRegistryForRestore);\n    BackendRestorerProcedure&lt;R, KeyedStateHandle&gt; backendRestorer =\n            new BackendRestorerProcedure&lt;&gt;(\n                    (stateHandles) -&gt; {\n                        KeyedStateBackendParametersImpl&lt;K&gt; parameters =\n                                new KeyedStateBackendParametersImpl&lt;&gt;(...);\n                        return keyedStateBackendCreator.create(...),\n                                parameters);\n                    },\n                    backendCloseableRegistry,\n                    logDescription);\n\n    try {\n        return backendRestorer.createAndRestore(\n                prioritizedOperatorSubtaskStates.getPrioritizedManagedKeyedState(),\n                statsCollector);\n    } finally {\n        if (backendCloseableRegistry.unregisterCloseable(cancelStreamRegistryForRestore)) {\n            IOUtils.closeQuietly(cancelStreamRegistryForRestore);\n        }\n    }\n}\n</code></pre>\n<p>这里的创建过程也比较简单，先是获取 KeyGroupRange，它表示的是当前 Operator 上处理的 key 的范围。然后就是创建 StateBackend 实例，这里通过 BackendRestorerProcedure 封装统一的恢复、异常处理和资源清理逻辑。operatorStateBackend 方法的逻辑相比较来说，只是少了 KeyGroupRange 的处理，直接创建 StateBackend 实例。</p>\n<h3 id=\"创建和使用-state\">创建和使用 State</h3>\n<h4 id=\"创建-keyedstate\">创建 KeyedState</h4>\n<p>KeyedState 是通过调用 StreamingRuntimeContext.getState 方法获取的。我们先来看完整的调用流程。</p>\n<p><img alt=\"getState\" class=\"lazyload\" /></p>\n<p>在调用 getState 这些方法时，都会先调用 keyedStateStore 提供的方法，它是 Flink 提供的一个封装 keyedStateBackend 的接口。调用流程的最后，是调用 keyedStateBackend 中的 createOrUpdateInternalState 方法（这里我们以 HeapStateBackend 为例）。</p>\n<pre><code class=\"language-java\">public &lt;N, SV, SEV, S extends State, IS extends S&gt; IS createOrUpdateInternalState(\n        @Nonnull TypeSerializer&lt;N&gt; namespaceSerializer,\n        @Nonnull StateDescriptor&lt;S, SV&gt; stateDesc,\n        @Nonnull StateSnapshotTransformFactory&lt;SEV&gt; snapshotTransformFactory,\n        boolean allowFutureMetadataUpdates)\n        throws Exception {\n    StateTable&lt;K, N, SV&gt; stateTable =\n            tryRegisterStateTable(\n                    namespaceSerializer,\n                    stateDesc,\n                    getStateSnapshotTransformFactory(stateDesc, snapshotTransformFactory),\n                    allowFutureMetadataUpdates);\n\n    @SuppressWarnings(\"unchecked\")\n    IS createdState = (IS) createdKVStates.get(stateDesc.getName());\n    if (createdState == null) {\n        StateCreateFactory stateCreateFactory = STATE_CREATE_FACTORIES.get(stateDesc.getType());\n        if (stateCreateFactory == null) {\n            throw new FlinkRuntimeException(stateNotSupportedMessage(stateDesc));\n        }\n        createdState =\n                stateCreateFactory.createState(stateDesc, stateTable, getKeySerializer());\n    } else {\n        StateUpdateFactory stateUpdateFactory = STATE_UPDATE_FACTORIES.get(stateDesc.getType());\n        if (stateUpdateFactory == null) {\n            throw new FlinkRuntimeException(stateNotSupportedMessage(stateDesc));\n        }\n        createdState = stateUpdateFactory.updateState(stateDesc, stateTable, createdState);\n    }\n\n    createdKVStates.put(stateDesc.getName(), createdState);\n    return createdState;\n}\n\n\nprivate static final Map&lt;StateDescriptor.Type, StateCreateFactory&gt; STATE_CREATE_FACTORIES =\n        Stream.of(\n                        Tuple2.of(\n                                StateDescriptor.Type.VALUE,\n                                (StateCreateFactory) HeapValueState::create),\n                        Tuple2.of(\n                                StateDescriptor.Type.LIST,\n                                (StateCreateFactory) HeapListState::create),\n                        Tuple2.of(\n                                StateDescriptor.Type.MAP,\n                                (StateCreateFactory) HeapMapState::create),\n                        Tuple2.of(\n                                StateDescriptor.Type.AGGREGATING,\n                                (StateCreateFactory) HeapAggregatingState::create),\n                        Tuple2.of(\n                                StateDescriptor.Type.REDUCING,\n                                (StateCreateFactory) HeapReducingState::create))\n                .collect(Collectors.toMap(t -&gt; t.f0, t -&gt; t.f1));\n</code></pre>\n<p>这里首先是注册了一个 StateTable，这个是 State 中一个非常重要的成员变量，它内部是一个类似 Map 的结构，用来保存 key 和 key 的状态。</p>\n<p>STATE_CREATE_FACTORIES 这个变量保存了不同类型的 State 和它对应的创建方法，同理 STATE_UPDATE_FACTORIES 保存的是不同 State 对应的 更新方法。</p>\n<h4 id=\"创建-operatorstate\">创建 OperatorState</h4>\n<p>看完了 KeyedState 的创建过程后，我们再来看下 OperatorState 的创建过程。</p>\n<p>OperatorState 的创建方法是通过 FunctionInitializationContext 先获取到 OperatorStateStore，它与 KeyedStateStore 类似，都是对 StateBackend 的方法进行了封装。</p>\n<pre><code class=\"language-java\">@Override\npublic void initializeState(FunctionInitializationContext context) throws Exception {\n    ListStateDescriptor&lt;Tuple2&lt;String, Integer&gt;&gt; descriptor =\n            new ListStateDescriptor&lt;&gt;(\n                    \"buffered-elements\",\n                    TypeInformation.of(new TypeHint&lt;Tuple2&lt;String, Integer&gt;&gt;() {}));\n\n    checkpointedState = context.getOperatorStateStore().getListState(descriptor);\n\n    if (context.isRestored()) {\n        for (Tuple2&lt;String, Integer&gt; element : checkpointedState.get()) {\n            bufferedElements.add(element);\n        }\n    }\n}\n</code></pre>\n<p>OperatorStateStore 的 getListState 方法中，直接创建出了 PartitionableListState，同时也做了一些缓存操作。</p>\n<pre><code class=\"language-java\">private &lt;S&gt; ListState&lt;S&gt; getListState(\n        ListStateDescriptor&lt;S&gt; stateDescriptor, OperatorStateHandle.Mode mode)\n        throws StateMigrationException {\n\n    ......\n    PartitionableListState&lt;S&gt; partitionableListState =\n            (PartitionableListState&lt;S&gt;) registeredOperatorStates.get(name);\n\n    if (null == partitionableListState) {\n        // no restored state for the state name; simply create new state holder\n\n        partitionableListState =\n                new PartitionableListState&lt;&gt;(\n                        new RegisteredOperatorStateBackendMetaInfo&lt;&gt;(\n                                name, partitionStateSerializer, mode));\n\n        registeredOperatorStates.put(name, partitionableListState);\n    } else {\n        ......\n    }\n\n    accessedStatesByName.put(name, partitionableListState);\n    return partitionableListState;\n}\n</code></pre>\n<p>PartitionableListState 内部有一个 ArrayList 用于保存数据。</p>\n<h4 id=\"使用-keyedstate\">使用 KeyedState</h4>\n<p>了解完 State 的创建之后，接下来就是 State 的使用了。我们以 HeapValueState 为例来看如何获取 State。</p>\n<pre><code class=\"language-java\">// HeapValueState 类\npublic V value() {\n    final V result = stateTable.get(currentNamespace);\n\n    if (result == null) {\n        return getDefaultValue();\n    }\n\n    return result;\n}\n</code></pre>\n<p>在 HeapValueState 类的 value 方法中，直接调用 StateTable 的 get 方法，最终调用的是 CopyOnWriteStateMap 的 get 方法，这个方法与 HashMap 的 get 方法比较类似。</p>\n<pre><code class=\"language-java\">public S get(K key, N namespace) {\n\n    final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace);\n    final int requiredVersion = highestRequiredSnapshotVersion;\n    final StateMapEntry&lt;K, N, S&gt;[] tab = selectActiveTable(hash);\n    int index = hash &amp; (tab.length - 1);\n\n    for (StateMapEntry&lt;K, N, S&gt; e = tab[index]; e != null; e = e.next) {\n        final K eKey = e.key;\n        final N eNamespace = e.namespace;\n        if ((e.hash == hash &amp;&amp; key.equals(eKey) &amp;&amp; namespace.equals(eNamespace))) {\n\n            // copy-on-write check for state\n            if (e.stateVersion &lt; requiredVersion) {\n                // copy-on-write check for entry\n                if (e.entryVersion &lt; requiredVersion) {\n                    e = handleChainedEntryCopyOnWrite(tab, hash &amp; (tab.length - 1), e);\n                }\n                e.stateVersion = stateMapVersion;\n                e.state = getStateSerializer().copy(e.state);\n            }\n\n            return e.state;\n        }\n    }\n\n    return null;\n}\n</code></pre>\n<h4 id=\"使用-operatorstate\">使用 OperatorState</h4>\n<p>OperatorState 底层使用的是 PartitionableListState，前面也提到了，它的内部用了一个 ArrayList 来保存数据，对于 OperatorState 的各种操作也都是来操作这个 ArrayList。</p>\n<pre><code class=\"language-java\">@Override\npublic void clear() {\n    internalList.clear();\n}\n\n@Override\npublic Iterable&lt;S&gt; get() {\n    return internalList;\n}\n\n@Override\npublic void add(S value) {\n    Preconditions.checkNotNull(value, \"You cannot add null to a ListState.\");\n    internalList.add(value);\n}\n\n@Override\npublic void update(List&lt;S&gt; values) {\n    internalList.clear();\n\n    addAll(values);\n}\n\n@Override\npublic void addAll(List&lt;S&gt; values) {\n    Preconditions.checkNotNull(values, \"List of values to add cannot be null.\");\n    if (!values.isEmpty()) {\n        for (S value : values) {\n            checkNotNull(value, \"Any value to add to a list cannot be null.\");\n            add(value);\n        }\n    }\n}\n</code></pre>\n<h3 id=\"总结\">总结</h3>\n<p>本文对 State 的相关代码进行了梳理。包括 StateBackend 的创建，KeyedState 和 OperatorState 的创建和使用。State 和 Checkpoint 两者需要结合使用，因此后面我们会再梳理 Checkpoint 的相关代码。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-23 21:44</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Jackeyzhe\">Jackeyzhe</a>&nbsp;\n阅读(<span id=\"post_view_count\">41</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "不用 Typora 的 html 导出功能，手搓纯 HTML5 转换器",
      "link": "https://www.cnblogs.com/zhally/p/19389248",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zhally/p/19389248\" id=\"cb_post_title_url\" title=\"发布于 2025-12-23 21:38\">\n    <span>不用 Typora 的 html 导出功能，手搓纯 HTML5 转换器</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"不用-typora-的-html-导出功能手搓纯-html5-转换器\">不用 Typora 的 html 导出功能，手搓纯 HTML5 转换器</h1>\n<p>原创 夏群林 2025.12.23</p>\n<h2 id=\"一缘起\">一、缘起</h2>\n<p>我日常工作使用 Typora， 一款很好的 Markdown 编辑器。建网站，写博文，用 Typora 打底稿。然后导出成 html 格式文件，所见即所得，一个静态网站就成了！</p>\n<p>不过，Typora 自带的 HTML 导出功能存在核心缺陷：夹带 Typora  编辑器 UI 冗余代码、HTML 语义不合规、依赖非标准化样式体系、导出文件体积大、可维护性差。基于此，我们手搓纯HTML5转换器，核心目标：</p>\n<ol>\n<li>剔除 UI 冗余，仅保留 Markdown 内容渲染逻辑；</li>\n<li>纯 ES6+ 原生实现，无第三方库依赖；</li>\n<li>符合HTML5语义标准；</li>\n<li>还原 Typora 纯 Markdown 内容的渲染风格。</li>\n</ol>\n<h2 id=\"二纯-es6-实现无第三方库\">二、纯 ES6+ 实现，无第三方库</h2>\n<h3 id=\"21-核心优势\">2.1 核心优势</h3>\n<ul>\n<li>轻量化：产物仅包含核心业务逻辑，无冗余依赖代码，体积较 Typora 导出缩减 80% 以上；</li>\n<li>可控性：全流程掌控 Markdown 语法解析、HTML 重构、样式生成；</li>\n<li>无依赖风险：避免第三方库版本迭代、兼容性问题，转换器长期稳定可用。</li>\n</ul>\n<h3 id=\"22-es6-核心特性应用\">2.2 ES6+ 核心特性应用</h3>\n<table>\n<thead>\n<tr>\n<th>ES6+特性</th>\n<th>应用场景</th>\n<th>价值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模块化（ES Module）</td>\n<td>拆分解析、工具、入口模块</td>\n<td>解耦代码，便于维护</td>\n</tr>\n<tr>\n<td>模板字符串</td>\n<td>HTML/CSS生成</td>\n<td>替代字符串拼接，提升可读性</td>\n</tr>\n<tr>\n<td>正则表达式增强</td>\n<td>Markdown解析、合规修复</td>\n<td>精准匹配语法，解决反向引用冲突</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三整体架构设计\">三、整体架构设计</h2>\n<h3 id=\"31-目录结构\">3.1 目录结构</h3>\n<pre><code>md2html/\n├── index.html        // 交互界面（MD输入、HTML预览/导出）\n├── js/\n│   ├── app.js        // 入口（DOM操作、转换/下载逻辑）\n│   ├── utils.js      // 工具函数（格式化、提示）\n│   └── marked.es6.js // MD核心解析（合规修复核心）\n└── css/  \n    ├── style.css     // 转换器界面样式\n    ├── concise.css   // 简洁版MD渲染样式\n    └── typora.css    // Typora纯内容渲染样式\n</code></pre>\n<h3 id=\"32-核心流程\">3.2 核心流程</h3>\n<div class=\"mermaid\">flowchart TD\n    A[MD输入] --&gt; B[marked.es6.js解析（合规修复）]\n    B --&gt; C[utils.js格式化]\n    C --&gt; D[app.js生成HTML/下载]\n    D --&gt; E[预览/导出纯HTML5文件]\n</div><h2 id=\"四核心技术点\">四、核心技术点</h2>\n<h3 id=\"41-基于正则的-markdown-语法解析\">4.1 基于正则的 Markdown 语法解析</h3>\n<p>放弃第三方库，通过精准的正则表达式匹配Markdown核心语法，是实现“纯原生”的基础。</p>\n<p>核心思路为：按“块级语法（标题、列表、表格）→ 行内语法（加粗、链接、代码）”的顺序解析，确保语法嵌套的正确性。</p>\n<p>示例：表格语法解析正则</p>\n<pre><code class=\"language-javascript\">// 解析表格\nconst parseTables = (md, options) =&gt; {\n    if (!md.includes('|') || md.includes('&lt;table&gt;')) return md;\n\n    const tableRegex = /^(\\|.*\\|)\\n(\\|[-:| ]*\\|)\\n((?:\\|.*\\|\\n?)+)/gm;\n    return md.replace(tableRegex, (match, headerLine, separatorLine, bodyLines) =&gt; {\n        const alignments = separatorLine.split('|')\n            .filter(cell =&gt; cell.trim() !== '')\n            .map(cell =&gt; {\n                const trimCell = cell.trim();\n                return trimCell.startsWith(':') &amp;&amp; trimCell.endsWith(':') ? 'center' :\n                       trimCell.startsWith(':') ? 'left' :\n                       trimCell.endsWith(':') ? 'right' : 'left';\n            });\n\n        const headerCells = headerLine.split('|').filter(cell =&gt; cell.trim() !== '');\n        let headerHtml = '&lt;thead&gt;&lt;tr&gt;';\n        headerCells.forEach((cell, index) =&gt; {\n            const align = alignments[index] || 'left';\n            const inlineContent = parseInlineOnly(cell, options);\n            headerHtml += `&lt;th class=\"text-${align}\"&gt;${inlineContent}&lt;/th&gt;`;\n        });\n        headerHtml += '&lt;/tr&gt;&lt;/thead&gt;';\n\n        const bodyRows = bodyLines.split('\\n').filter(row =&gt; row.trim() !== '');\n        let bodyHtml = '&lt;tbody&gt;';\n        bodyRows.forEach(row =&gt; {\n            const cells = row.split('|').filter(cell =&gt; cell.trim() !== '');\n            bodyHtml += '&lt;tr&gt;';\n            cells.forEach((cell, index) =&gt; {\n                const align = alignments[index] || 'left';\n                const inlineContent = parseInlineOnly(cell, options);\n                bodyHtml += `&lt;td class=\"text-${align}\"&gt;${inlineContent}&lt;/td&gt;`;\n            });\n            bodyHtml += '&lt;/tr&gt;';\n        });\n        bodyHtml += '&lt;/tbody&gt;';\n\n        return `&lt;table&gt;${headerHtml}${bodyHtml}&lt;/table&gt;`;\n    });\n};\n</code></pre>\n<h3 id=\"42-html语义合规化重构\">4.2 HTML语义合规化重构</h3>\n<p>例如，Typora 导出的<code>&lt;ul&gt;/&lt;ol&gt;</code>被<code>&lt;p&gt;</code>包裹，换行生成空<code>&lt;p&gt;</code>标签，违反HTML语义规范。</p>\n<p>核心逻辑：解析列表时仅生成<code>&lt;li&gt;</code>子元素，段落解析排除列表标签，避免误判。</p>\n<pre><code class=\"language-javascript\">// marked.es6.js 核心修复代码\nconst parseLists = (md) =&gt; {\n    // 生成纯&lt;li&gt;，移除多余换行\n    let listItems = md.replace(/^( {0,3})(-|\\*|\\+)\\s+(.*?$)/gm, (_, indent, marker, text) =&gt; {\n        const inlineContent = parseInlineOnly(text).replace(/\\n+/g, ' ');\n        return `${indent}&lt;li&gt;${inlineContent}&lt;/li&gt;`;\n    });\n    // 包裹列表容器，清理换行干扰\n    return listItems.replace(/((?: {0,3}&lt;li&gt;[\\s\\S]*?&lt;\\/li&gt;\\s*)+)/gm, (_, items) =&gt; {\n        const cleanItems = items.replace(/\\n+/g, '').replace(/&gt;\\s+&lt;/g, '&gt;&lt;');\n        return /[-*+]/.test(_) ? `&lt;ul&gt;${cleanItems}&lt;/ul&gt;` : `&lt;ol&gt;${cleanItems}&lt;/ol&gt;`;\n    });\n};\n\n// 段落解析排除列表标签，避免空&lt;p&gt;\nconst parseParagraphs = (md) =&gt; {\n    const paraRegex = /^(?!&lt;(ul|ol|li)&gt;)(?!&lt;\\/(ul|ol|li)&gt;)([^&lt;\\n]+?)(?=\\n{2,}|$)/gm;\n    return md.replace(paraRegex, (_, __, ___, content) =&gt; {\n        const trimmed = content?.trim().replace(/\\n+/g, ' ') || '';\n        return trimmed ? `&lt;p&gt;${trimmed}&lt;/p&gt;` : '';\n    });\n};\n</code></pre>\n<h3 id=\"43-仅保留-typora--内容渲染核心样式\">4.3 仅保留 Typora  内容渲染核心样式</h3>\n<p>Typora 导出样式包含编辑器 UI 规则，冗余且非标准化，予以剥离。基于Typora原生的Markdown渲染风格，构建模块化的CSS体系：</p>\n<pre><code class=\"language-css\">/* typora.css 核心代码 */\n:root {\n    --typora-text-color: #333;\n    --typora-heading-color: #2c3e50;\n    --typora-code-bg: #f8f8f8;\n    --typora-table-border: #ddd;\n}\n/* 暗黑模式适配 */\n@media (prefers-color-scheme: dark) {\n    :root {\n        --typora-text-color: #e0e0e0;\n        --typora-code-bg: #2d2d2d;\n        --typora-table-border: #444;\n    }\n}\n/* 列表合规兜底 */\nul&gt;li, ol&gt;li { margin: 0.4em 0; }\nul&gt;br, ol&gt;br, ul&gt;p, ol&gt;p { display: none; }\n/* 表格对齐类 */\n.text-left { text-align: left !important; }\n.text-center { text-align: center !important; }\n.text-right { text-align: right !important; }\n</code></pre>\n<h3 id=\"44-原生-es6-模块化整合\">4.4 原生 ES6+ 模块化整合</h3>\n<pre><code class=\"language-javascript\">// app.js 核心逻辑\nimport { parseMarkdown } from './marked.es6.js';\nimport { formatHtml, showAlert } from './utils.js';\n\n// 转换逻辑\ndom.convertBtn.addEventListener('click', () =&gt; {\n    const mdContent = dom.mdInput.value.trim();\n    if (!mdContent) return showAlert('请输入Markdown内容');\n    \n    // 核心流程：解析（合规）→ 格式化 → 预览/导出\n    const htmlFragment = parseMarkdown(mdContent); // 生成即合规\n    const finalHtml = formatHtml(`&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh-CN\"&gt;\n&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;link rel=\"stylesheet\" href=\"./css/typora.css\"&gt;&lt;/head&gt;\n&lt;body&gt;${htmlFragment}&lt;/body&gt;&lt;/html&gt;`);\n    \n    dom.preview.innerHTML = htmlFragment;\n    dom.htmlCode.value = finalHtml;\n    dom.downloadBtn.disabled = false;\n});\n</code></pre>\n<h2 id=\"五使用说明\">五、使用说明</h2>\n<ol>\n<li>按指定目录结构存放文件，确保<code>js/</code>和<code>css/</code>子文件夹路径正确；</li>\n<li>用支持ES6模块的浏览器（Chrome/Firefox/Edge）打开<code>index.html</code>；</li>\n<li>输入Markdown内容，勾选“保留 Typora 原格式”，点击“转换为 HTML5”；</li>\n<li>预览区查看效果，点击“下载 HTML 文件”获取符合 HTML5 规范的文件。</li>\n</ol>\n<h2 id=\"六总结\">六、总结</h2>\n<ol>\n<li>核心价值：精准解决 Typora 导出的编辑器UI样式冗余痛点，生成纯内容的符合 HTML5 规范的文件；</li>\n<li>技术亮点：纯 ES6+ 原生实现；</li>\n<li>优势：轻量化、可控性强、跨环境兼容，可直接部署使用。</li>\n</ol>\n<p>本方案源代码开源，按照 MIT 协议许可。地址： <a href=\"https://github.com/xiaql/md2html5\" rel=\"noopener nofollow\" target=\"_blank\">xiaql/md2html5: A typora to pure html5 converter</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-23 21:38</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zhally\">zhally</a>&nbsp;\n阅读(<span id=\"post_view_count\">47</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "流量洪峰冲不垮的秘密：揭秘系统过载保护的核心防线",
      "link": "https://www.cnblogs.com/poemyang/p/19389175",
      "published": "",
      "description": "<h2 class=\"post-title\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/poemyang/p/19389175\" id=\"cb_post_title_url\" title=\"发布于 2025-12-23 21:16\">\n    <span>流量洪峰冲不垮的秘密：揭秘系统过载保护的核心防线</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>系统流量如潮汐般涨落，瞬时的洪峰可能将最坚固的系统冲垮。如何确保核心服务在极限压力下依然稳如磐石？答案在于构建一套分层协同、动态弹性的过载保护机制。这并非单一技术的堆砌，而是一门融汇了预判、隔离、调度与自愈的系统工程艺术。<br />\n本文将深入剖析这套多层防护体系的构建之道：从最外层的流量调度（负载均衡），到精细化的请求管控（限流），再到保障核心业务的“丢车保帅”策略（降级与熔断），最终迈向智能化的自我调节（自适应限流）。这些机制环环相扣，实时联动，旨在系统资源耗尽前，建立起一道有序的防线，确保关键业务在流量风暴中依然能够持续稳定地创造价值。</p>\n<p><strong>过载原因：为什么我们的系统会堵车？</strong><br />\n系统过载（System Overload），如同城市交通在高峰期陷入瘫痪，其本质是请求压力与处理能力之间动态平衡的打破。在系统设计阶段，需全面评估其处理能力，具体涵盖每秒处理能力、请求峰值、平均处理时延等关键指标。这些指标不仅有助于预估系统的最大处理能力，还能为确定所需机器数量以及是否进行扩容提供可靠依据。然而，在实际评估中，往往仅聚焦于请求量峰值，却忽略了系统处理能力的动态变化。现实中，系统的处理能力并非恒定不变，它会因内部损耗和外部依赖而动态衰减。实际上，系统处理能力的降低同样会引发过载问题。<br />\n系统过载的原因主要可归为两类：硬件系统极限能力被突破和软件系统极限能力被超越。由于硬件能力被超越的情况相对较少，因此更应重点关注软件系统，包括操作系统和应用软件。操作系统负责统一调配与管理硬件资源，而应用系统则通过系统调用使用这些资源。当资源使用超出操作系统的承受限度时，系统的整体处理能力将急剧降低。应用系统的瓶颈通常表现为以下四种类型，且某些应用系统可能同时存在多个瓶颈因素。<br />\n‌ 1）处理器瓶颈：密集的计算任务（如复杂算法、加解密）、频繁的线程上下文切换，都会将处理器利用率推向100%，导致新请求排队等待，响应时间急剧拉长。<br />\n2）内存瓶颈：频繁的垃圾回收（GC Pause）会冻结应用，而操作系统层面的内存交换（Swapping）更是将处理速度从纳秒级拖慢至毫秒级，对性能造成毁灭性打击。<br />\n‌ 3）网络I/O：带宽耗尽、网络延迟，或是连接数（如文件句柄）被占满，导致无法建立新的请求连接。<br />\n4）磁盘I/O：大量的数据库读写、日志记录、文件操作，特别是随机I/O，会显著降低磁盘吞吐率，拖慢整个业务流程。</p>\n<p><strong>过载解决策略</strong><br />\n面对系统过载，解决思路可归为两大方向：“开源”与“节流”。“开源”旨在提升系统的承载上限，而“节流”则是在资源有限的前提下，智慧地管理和调度进入系统的请求。一个成熟的系统，往往是这两种策略的有机结合。<br />\n开源策略是指提升系统承载力。这是最直观的应对方式，核心是增加系统可用的物理或虚拟资源。<br />\n1）扩容（Scaling）： 直接增加硬件投入，分为垂直扩容（升级单机配置）和水平扩容（增加更多服务器节点）。扩容能立竿见影地提升处理能力，但成本高昂，且资源终有上限。更重要的是，它无法解决由软件设计缺陷（如锁竞争、慢查询）引发的瓶颈。<br />\n2）负载均衡（Load Balancing）： 它是水平扩容的必然搭档。通过智能的调度算法，将请求流量均匀地分发到后端各个服务节点，避免单点过载，最大化利用整个集群的处理能力。<br />\n节流策略是指优化请求处理流。当“开源”达到极限或不符合成本效益时，“节流”便成为保障系统韧性的关键。它不再追求处理所有请求，而是选择性地处理，确保核心功能不受影响。<br />\n1）流量控制（Traffic Shaping）： 这是过载保护的核心手段，通过限流、排队等方式，主动控制进入系统的请求速率，防止流量洪峰直接冲击后端服务。它像一个智能阀门，确保水流平稳可控。<br />\n2）服务降级（Graceful Degradation）： 这是一种“舍车保帅”的智慧。在系统压力巨大时，有策略地关闭或简化非核心功能（如商品推荐、用户评论），将宝贵的系统资源集中用于保障核心业务流程（如下单、支付）的稳定。<br />\n尽管扩容和负载均衡是构建高并发系统的基础，但它们更像是提高了堤坝的高度。而真正的过载保护，则是在洪水来临时，如何科学地泄洪、导流，确保大坝本身和其守护的核心区域安然无恙。这正是“节流”策略的价值所在。</p>\n<p><strong>过载保护的核心价值</strong><br />\n传统系统设计的理想是永不失败，但这在真实复杂的系统世界中不切实际。过载保护承认失败的必然性，并将设计的焦点从“如何避免失败”转移到“当失败发生时，如何可控地、有预见性地应对”。它用有序的降级取代无序的崩溃，用可预期的局部不可用换取整体系统的稳定。<br />\n在没有保护的情况下，过载意味着所有请求一同变慢，最终一同失败，系统陷入混沌。而过载保护机制，如同一位冷静的调度员，它根据预设的优先级和规则，决定了哪些请求被立即处理，哪些需要排队等待，哪些被礼貌地拒绝。这种机制将混乱的流量冲击波，转化为一个有序的、可管理的业务处理队列。<br />\n在系统面临过载时，首要任务是在有限资源条件下，通过优化和保护策略，确保系统的关键功能能够稳定运行。例如，可对系统的各个部分进行优先级排序，明确哪些功能是至关重要的，哪些功能在必要时可暂时关闭或降级。同时，设定合理的阈值和规则，以便在系统过载时，能够自动丢弃超出处理能力的请求。<br />\n一切技术策略都为业务服务。过载保护的终极目标，是在资源极限的边缘，将每一分计算力都用在“刀刃”上，确保支付、下单等核心功能畅通无阻。对用户而言，一个能明确告知“系统繁忙，请稍后再试”的系统，远比一个永远在加载中、最终超时的系统更值得信赖。</p>\n<p><strong>未完待续</strong></p>\n<p><strong>很高兴与你相遇！如果你喜欢本文内容，记得关注哦!!!</strong></p>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/poemyang/\" target=\"_blank\">poemyang</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/poemyang/p/19389175\" target=\"_blank\">https://www.cnblogs.com/poemyang/p/19389175</a></p>\n</div>\n<div class=\"clear\"></div>\n\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2025-12-23 21:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/poemyang\">poemyang</a>&nbsp;\n阅读(<span id=\"post_view_count\">54</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "Kafka入门必知概念——Topic、分区、Offset、消费组的协作机制与影响",
      "link": "https://www.cnblogs.com/shiyuelp/p/19389157",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shiyuelp/p/19389157\" id=\"cb_post_title_url\" title=\"发布于 2025-12-23 21:10\">\n    <span>Kafka入门必知概念——Topic、分区、Offset、消费组的协作机制与影响</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>写在前面，本人目前处于求职中，如有合适内推岗位，请加：lpshiyue 感谢</strong></p>\n<blockquote>\n<p>理解Kafka的核心概念如同掌握分布式系统的通用语言，这些基础组件的高效协作正是Kafka海量数据处理能力的源泉</p>\n</blockquote>\n<p>在消息队列选型框架中，Kafka以其高吞吐、可扩展架构成为大数据场景的首选。然而，要真正发挥Kafka的潜力，必须深入理解其核心概念之间的协作关系。本文将全面解析Topic、分区、Offset和消费组四大核心概念，揭示它们如何共同构建Kafka的高性能架构。</p>\n<h2 id=\"1-kafka架构概览与设计哲学\">1 Kafka架构概览与设计哲学</h2>\n<h3 id=\"11-分层架构与数据流\">1.1 分层架构与数据流</h3>\n<p>Kafka采用<strong>生产者-消费者</strong>经典架构，整体可分为逻辑三层：生产者层负责消息发送，Broker集群层处理消息存储与路由，消费者层实现消息消费。这种清晰的分层架构使得Kafka能够高效处理海量消息流。</p>\n<p>Kafka的设计哲学围绕<strong>分布式、可扩展和高吞吐</strong>展开。与传统消息系统不同，Kafka将消息持久化到磁盘，通过顺序I/O和零拷贝技术实现高性能。这种设计使Kafka既能作为消息队列，又能作为存储系统使用，支持消息回溯和重复消费。</p>\n<h3 id=\"12-物理存储与逻辑视图的分离\">1.2 物理存储与逻辑视图的分离</h3>\n<p>Kafka创新性地实现了<strong>逻辑Topic与物理分区的分离</strong>。Topic作为逻辑概念，方便业务分类；而分区作为物理概念，实现了数据的分布式存储和并行处理。这种分离是Kafka高扩展性的关键，允许集群通过增加分区和Broker来线性扩展吞吐量。</p>\n<p><strong>分区机制</strong>将每个Topic划分为多个有序的日志序列，分布在不同Broker上。当生产者发送消息时，实际上是将消息写入特定Topic的特定分区；消费者也是从特定分区读取消息。这种设计既保证了分区内消息顺序，又通过并行处理提升了整体吞吐量。</p>\n<h2 id=\"2-topic与分区数据分布的核心机制\">2 Topic与分区：数据分布的核心机制</h2>\n<h3 id=\"21-topic的逻辑抽象与物理实现\">2.1 Topic的逻辑抽象与物理实现</h3>\n<p><strong>Topic是消息的逻辑容器</strong>，类似于数据库中的表。生产者将消息发送到指定Topic，消费者从Topic订阅消息。Topic本身不存储数据，而是通过其下的分区实际承载消息。</p>\n<p>每个Topic由一个或多个<strong>分区（Partition）</strong> 组成，分区是Kafka并行处理的基本单位。分区在物理上对应磁盘上的目录，命名规则为<code>&lt;topic_name&gt;-&lt;partition_id&gt;</code>。例如，名为\"user_behavior\"的Topic若有3个分区，则对应三个目录：user_behavior-0、user_behavior-1、user_behavior-2。</p>\n<h3 id=\"22-分区策略与消息路由\">2.2 分区策略与消息路由</h3>\n<p>Kafka提供灵活的分区策略，决定消息如何路由到特定分区。<strong>默认分区策略</strong>基于Key的哈希值：当消息指定Key时，使用<code>hash(key) % 分区数</code>计算目标分区；未指定Key时，采用轮询策略均匀分布。</p>\n<pre><code class=\"language-java\">// 分区策略核心逻辑示例\nList&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);\nif (key != null) {\n    // 按Key哈希分区，保证同一Key的消息进入同一分区\n    return Math.abs(key.hashCode()) % partitions.size();\n} else {\n    // 轮询策略，均匀分布\n    return nextRoundRobinIndex() % partitions.size();\n}\n</code></pre>\n<p><strong>分区策略的选择直接影响消息顺序性和负载均衡</strong>。按Key哈希分区保证相同Key的消息顺序处理，适合需要保序的场景；轮询策略则提供更好的负载均衡，适合无顺序要求的场景。</p>\n<h3 id=\"23-分区数量的权衡艺术\">2.3 分区数量的权衡艺术</h3>\n<p>分区数量是Kafka性能调优的关键参数。<strong>分区过少</strong>会导致无法充分利用集群并行能力；<strong>分区过多</strong>则增加元数据开销和Rebalance成本。</p>\n<p>实践经验表明，分区数量应当与消费者数量相匹配，且考虑未来扩展需求。通常建议单个Broker的分区总数不超过2000-4000个，以避免文件句柄和内存开销过大。</p>\n<h2 id=\"3-消费者组与负载均衡机制\">3 消费者组与负载均衡机制</h2>\n<h3 id=\"31-消费者组模型及其优势\">3.1 消费者组模型及其优势</h3>\n<p><strong>消费者组（Consumer Group）</strong> 是Kafka实现负载均衡和容错的核心机制。组内多个消费者实例共同消费一个或多个Topic，每个分区在同一时间只能被组内一个消费者消费。</p>\n<p>消费者组模型同时支持<strong>发布-订阅</strong>和<strong>点对点</strong>两种消息模式：当不同应用使用不同Group ID时，实现广播效果；当同一应用多个实例使用相同Group ID时，实现负载均衡。</p>\n<h3 id=\"32-rebalance机制与分区分配\">3.2 Rebalance机制与分区分配</h3>\n<p><strong>Rebalance是消费者组的核心协调机制</strong>，在以下情况下触发：消费者加入或离开组、Topic分区数变化、订阅Topic变化。Rebalance过程包括三个阶段：</p>\n<ol>\n<li><strong>Join阶段</strong>：所有消费者向协调者注册</li>\n<li><strong>Sync阶段</strong>：组Leader计算分配方案并同步给所有成员</li>\n<li><strong>执行阶段</strong>：消费者开始从分配的分区消费</li>\n</ol>\n<p>Kafka提供多种<strong>分区分配策略</strong>，满足不同场景需求：</p>\n<ul>\n<li><strong>Range策略</strong>（默认）：按Topic维度顺序分配，可能导致负载不均</li>\n<li><strong>RoundRobin策略</strong>：所有分区轮询分配，负载更均衡</li>\n<li><strong>Sticky策略</strong>：尽量减少分区移动，减少Rebalance开销</li>\n</ul>\n<h3 id=\"33-消费者位移管理\">3.3 消费者位移管理</h3>\n<p><strong>Offset是消费者在分区中的消费位置</strong>，是分区内消息的唯一标识。Kafka将位移信息存储在特殊的<code>__consumer_offsets</code> Topic中，默认50个分区，通过<code>Math.abs(groupId.hashCode()) % 50</code>计算存储位置。</p>\n<p>位移提交方式影响消息处理的<strong>精确一次性</strong>语义：</p>\n<ul>\n<li><strong>自动提交</strong>：简单但可能重复消费或丢失消息</li>\n<li><strong>手动提交</strong>：更精确控制，支持同步和异步方式</li>\n</ul>\n<h2 id=\"4-副本机制与高可用性\">4 副本机制与高可用性</h2>\n<h3 id=\"41-leader-follower架构\">4.1 Leader-Follower架构</h3>\n<p>Kafka通过<strong>副本机制</strong>保证数据高可用。每个分区有多个副本，分为Leader和Follower两种角色。Leader处理所有读写请求，Follower从Leader同步数据。当Leader失效时，Kafka从ISR（In-Sync Replicas）中选择新的Leader。</p>\n<p><strong>ISR机制</strong>维护与Leader保持同步的副本集合。Follower必须定期向Leader发送心跳，若超过<code>replica.lag.time.max.ms</code>（默认10秒）未同步，则被移出ISR。这种设计既保证数据一致性，又提供故障转移能力。</p>\n<h3 id=\"42-数据可靠性配置\">4.2 数据可靠性配置</h3>\n<p>生产者可通过<strong>acks参数</strong>配置数据可靠性级别：</p>\n<ul>\n<li><strong>acks=0</strong>：无确认，最高吞吐但可能丢失数据</li>\n<li><strong>acks=1</strong>：Leader确认，均衡选择</li>\n<li><strong>acks=all</strong>：所有ISR副本确认，最可靠</li>\n</ul>\n<p>在要求高可靠性的场景中，建议配置<code>acks=all</code>并设置<code>min.insync.replicas</code>（默认1），确保写入多个副本后才返回成功。</p>\n<h2 id=\"5-核心概念的协同效应\">5 核心概念的协同效应</h2>\n<h3 id=\"51-四者协作的高性能奥秘\">5.1 四者协作的高性能奥秘</h3>\n<p>Topic、分区、Offset和消费组四个概念相互协作，形成Kafka高性能的基石：<strong>Topic提供逻辑分类，分区实现并行处理，Offset记录消费进度，消费组保障负载均衡</strong>。</p>\n<p>这种协作机制的实际效果体现在：<strong>横向扩展能力</strong>通过增加分区和消费者实现；<strong>容错性</strong>通过副本机制保障；<strong>消息顺序性</strong>在分区内得到保证；<strong>负载均衡</strong>通过消费组自动实现。</p>\n<h3 id=\"52-实际应用中的配置策略\">5.2 实际应用中的配置策略</h3>\n<p>在实际应用中，需要根据业务特点合理配置这些概念参数：<strong>高吞吐场景</strong>可增加分区数并使用轮询策略；<strong>保序要求高</strong>的场景应采用Key哈希分区；<strong>容错要求高</strong>需配置多副本和acks=all。</p>\n<p>以下是一个典型电商平台的Kafka配置示例：</p>\n<pre><code class=\"language-yaml\"># 订单Topic配置\norder.topic.partitions: 12        # 匹配消费者数量\norder.topic.replication: 3        # 高可用配置\norder.consumer.group: order-processors\norder.consume.threads: 12         # 与分区数匹配\n\n# 日志Topic配置  \nlog.topic.partitions: 24          # 高吞吐需求\nlog.topic.replication: 2           # 可接受一定数据丢失\nlog.consumer.group: log-analyzers\n</code></pre>\n<h2 id=\"6-实践中的常见问题与解决方案\">6 实践中的常见问题与解决方案</h2>\n<h3 id=\"61-数据倾斜与热点分区\">6.1 数据倾斜与热点分区</h3>\n<p><strong>数据倾斜</strong>是常见问题，表现为部分分区负载过高。解决方案包括：使用更均匀的Key分布、采用轮询策略、增加分区数或实现自定义分区策略。</p>\n<h3 id=\"62-rebalance风暴与消费者稳定性\">6.2 Rebalance风暴与消费者稳定性</h3>\n<p><strong>频繁Rebalance</strong>会导致消费者频繁停顿。优化方案包括：调整<code>session.timeout.ms</code>和<code>heartbeat.interval.ms</code>参数、使用Sticky分配策略、避免消费者频繁启停。</p>\n<h3 id=\"63-位移管理的最佳实践\">6.3 位移管理的最佳实践</h3>\n<p>位移管理不当可能导致<strong>重复消费或消息丢失</strong>。建议采用手动提交位移，在消息处理完成后同步提交，并在消费者重启时从正确位置开始消费。</p>\n<h2 id=\"总结\">总结</h2>\n<p>Kafka的核心概念体系构成了一个完整的高性能消息处理生态系统。Topic与分区的分离实现了逻辑与物理的解耦，消费组机制提供了灵活的负载均衡方案，Offset管理确保了消息处理的可靠性，副本机制保障了系统的高可用性。</p>\n<p>理解这些概念不仅有助于正确使用Kafka，更能为分布式系统设计提供重要启示。<strong>分布式系统的本质是通过分片实现扩展，通过副本实现容错，通过协调机制实现一致性</strong>——这正是Kafka架构思想的精髓。</p>\n<p>随着业务规模的增长，对这些核心概念的深入理解将帮助开发者在性能、可靠性和复杂度之间找到最佳平衡点，构建真正稳定高效的数据处理平台。</p>\n<hr />\n<p><strong>📚 下篇预告</strong><br />\n《可靠性与顺序性保障——幂等、事务与Exactly-once语义的适用边界》—— 我们将深入探讨：</p>\n<ul>\n<li>🔄 <strong>幂等生产原理</strong>：PID、序列号与Broker去重机制的协同工作</li>\n<li>⚡ <strong>事务消息机制</strong>：跨分区原子写入与持久化保证的实现路径</li>\n<li>🎯 <strong>Exactly-once语义</strong>：流处理场景下的精确一次性交付保障</li>\n<li>📊 <strong>性能与可靠性权衡</strong>：不同可靠性级别的吞吐量影响量化分析</li>\n<li>🛡️ <strong>实践配置指南</strong>：生产者ACK、ISR配置与故障恢复的最佳实践</li>\n</ul>\n<p><strong>点击关注，掌握Kafka数据可靠性的核心技术！</strong></p>\n<blockquote>\n<p><strong>今日行动建议</strong>：</p>\n<ol>\n<li>审查现有Kafka Topic的分区配置，确保与消费者数量匹配</li>\n<li>评估数据分布情况，识别可能的热点分区问题</li>\n<li>优化消费者组配置，减少不必要的Rebalance操作</li>\n<li>建立位移监控机制，确保消息消费进度可观测</li>\n</ol>\n</blockquote>\n\n</div>\n<div id=\"MySignature\">\n    进阶之路，神挡杀神佛挡杀佛，欢迎大家一起加ＱＱ群共同讨论成长，群号：<a href=\"https://jq.qq.com/?_wv=1027&amp;k=4AiobC0\" target=\"view_window\">620095084</a>\n<br />\n欢迎搜索关注微信公众号 基础全知道 ：JavaBasis ，第一时间阅读最新文章\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-23 21:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shiyuelp\">十月南城</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程四：计算机视觉  第三周：检测算法 （二）目标检测算法",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19389081",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19389081\" id=\"cb_post_title_url\" title=\"发布于 2025-12-23 20:53\">\n    <span>吴恩达深度学习课程四：计算机视觉  第三周：检测算法 （二）目标检测算法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第四课的第三周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=132\" rel=\"noopener nofollow\" target=\"_blank\">3.3</a>到<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=134\" rel=\"noopener nofollow\" target=\"_blank\">3.5</a>的内容。</p>\n<hr />\n<p>本周为第四课的第三周内容，这一课所有内容的中心只有一个：<strong>计算机视觉</strong>。应用在深度学习里，就是专门用来进行图学习的模型和技术，是在之前全连接基础上的“特化”，也是相关专业里的一个重要研究大类。<br />\n<strong>这一整节课都存在大量需要反复理解的内容和机器学习、数学基础。</strong> 因此我会尽可能的补足基础，用比喻和实例来演示每个部分，从而帮助理解。<br />\n第三周的内容将从<strong>图像分类</strong>进一步拓展到<strong>目标检测（Object Detection）</strong> 这一更具挑战性的计算机视觉任务。<br />\n与分类任务只需回答“图中有什么”不同，目标检测需要同时解决“ <strong>有什么</strong>”以及“<strong>在什么位置</strong>”两个问题，因此在模型结构设计、训练方式和评价标准上都更为复杂。<br />\n本篇的内容关于目标检测算法。</p>\n<h1 id=\"1-检测算法10对窗口分类\">1. 检测算法1.0：对窗口分类</h1>\n<p>我们知道，想要实现目标检测，首先就要完成<strong>目标识别</strong>。<br />\n只有当模型能够回答“<strong>要找什么</strong>”后，我们才有可能进一步让它回答“<strong>它在哪里</strong>”。</p>\n<p>在早期，人们并没有一套专门为“检测”设计的网络结构，于是有人提出了这样一种想法：<strong>既然分类网络已经很成熟，那能不能把“找位置”这个问题，转化成一堆“分类问题”？</strong></p>\n<p>而实现这种逻辑的具体做法就是<strong>滑动窗口（Sliding Window）</strong>。<br />\n在这种方法中，我们用一个<strong>固定大小的窗口</strong>在整张图像上从左到右、从上到下不断<strong>滑动</strong>，把图像裁剪成一块一块的小区域。<br />\n然后，将每一个窗口都单独送入一个已经训练好的<strong>图像分类网络</strong>中，判断这个窗口里“有没有目标”。<br />\n如果某个窗口被分类器判断为“汽车”“行人”等目标类别，那么我们就认为：<strong>目标就出现在这个窗口所对应的位置上。</strong><br />\n就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251223205038950-257158416.png\" /></p>\n<p>从整体上看，这种检测流程可以被理解为：</p>\n<ol>\n<li>用滑动窗口 <strong>枚举可能的位置</strong></li>\n<li>用分类网络 <strong>判断每个位置是什么</strong></li>\n<li>将被判定为目标的窗口位置，作为最终的检测结果</li>\n</ol>\n<p>但显然，即使假设分类器完全准确，这种算法仍有它的不足之处。<br />\n对于滑动窗口，我们可以设置它的<strong>尺寸和步长</strong>来调整它在图像中的运动轨迹，这种固定的设置都十分死板，且同时很难兼顾<strong>不同大小目标的完整覆盖</strong>。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251223205039012-1879118197.png\" /></p>\n<p>因此，你会发现这种检测方法其实是一种“取巧”，它本质上并没有“直接学位置”，而是通过<strong>大量的局部分类结果</strong>，间接拼凑出目标的位置，在依赖单独训练的分类器准确率的前提下还需要极大的计算量。<br />\n于是下一步改进出现了。</p>\n<h1 id=\"2-检测算法20对整幅图像应用卷积\">2. 检测算法2.0：对整幅图像应用卷积</h1>\n<p>为了更好地进行目标检测，面对 1.0 中出现的极大计算量问题，人们运用数学逻辑，发现了这样一种情况：<strong>当为了更精准的检测而应用更小步长的窗口时，相邻的窗口存在公共区域，让部分计算重复进行。</strong><br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251223205041096-1719506100.png\" /><br />\n而如果不希望出现公共区域，那就又要增大步长至和尺寸同大小，就又回到了漏检小目标、定位不精确的问题。<br />\n有没有一种办法，<strong>既能享有小步长带来的精确度，又能让重复计算的结果复用从而及减小计算量呢？</strong><br />\n有的兄弟，有的。</p>\n<p>在 2014 年，一篇名为 <a href=\"https://arxiv.org/pdf/1312.6229\" rel=\"noopener nofollow\" target=\"_blank\">OverFeat: Integrated Recognition, Localization and Detection using Convolutional Networks</a> 的论文发表，提出了一个利用卷积神经网络同时实现<strong>分类、定位和检测</strong>的统一框架。<br />\n而相比 1.0 算法，2.0 最大的改变就是<strong>不再把每个窗口裁出来送进网络，而是直接把整张图像送进网络，让卷积层自动完成“滑动 + 特征提取”的过程，直接输出图像各部分的分类结果。</strong></p>\n<p>我们来详细展开这一部分：</p>\n<h2 id=\"21-修改网络结构适应输出要求\">2.1 修改网络结构适应输出要求</h2>\n<p>明确了目标之后，你会发现，不同于原本使用全连接层输出一维分类结果，现在我们希望<strong>让输出为一个二维特征图，图中每一个元素就代表一个窗口的分类结果</strong>。<br />\n就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251223205039801-1655184845.png\" /></p>\n<p>因此，现在我们需要修改网络结构，<strong>使用卷积层取代原本的全连接层，保证输出同样为特征图</strong>。<br />\n而要合理地实现这一部分，首先，就要了解<strong>如何用卷积层等效代替全连接层</strong>。</p>\n<p>先说结论：<strong>使用和输入特征图尺寸等大小的卷积核</strong>。<br />\n就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251223205039223-13958052.png\" /></p>\n<p>再展开说说原理：<br />\n在分类网络中，当特征提取部分结束后，输入全连接层的，通常是一个形状为  <span class=\"math inline\">\\(H \\times W \\times C\\)</span>  的特征图。<br />\n全连接层做的事情，本质上是：  <strong>把这整个特征图“摊平”，然后与一组权重做一次线性组合，输出一个结果。</strong><br />\n如果用公式表示，就是：</p>\n<p></p><div class=\"math display\">\\[y = \\sum_{i,j,k} w_{i,j,k} \\cdot x_{i,j,k} + b\n\\]</div><p></p><p>换一个角度看，这个过程其实非常像什么？  ——<strong>用一个和输入特征图尺寸完全一致的卷积核，在特征图上做一次卷积。</strong><br />\n因此，当卷积核的尺寸等于输入特征图的空间尺寸时：</p>\n<ul>\n<li>卷积核只会在输入上“滑动”一次。</li>\n<li>卷积输出自然就是一个 <span class=\"math inline\">\\(1 \\times 1\\)</span> 的结果。</li>\n<li>这个结果与全连接层的输出在数学形式上是<strong>完全等价的</strong>。</li>\n</ul>\n<p>因此可以得到一个直观的结论：<strong>全连接层可以被看作一种特殊形式的卷积层。</strong><br />\n现在，我们就了解了如何修改我们原本一直使用的全连接层作为输出层的网络结构，从而适应输出为带有空间结构的特征图的要求。<br />\n现在，就来看看，输入整幅图像进入完善后的网络得到分类输出的具体过程。</p>\n<h2 id=\"22-窗口在网络中的传播\">2.2 窗口在网络中的传播</h2>\n<p>我们就用课程里的例子来演示一下网络如何一次输出整幅图像各个窗口的分类结果：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251223205055320-655995691.png\" /></p>\n<p>你会发现，得益于卷积操作的特性，输入图像的局部特征本身就在传播中被一步步集中，<strong>第一层特征图中的每一个像素，本身就对应着输入图像中的一个小窗口</strong>。<br />\n而随着网络不断加深，卷积层不断堆叠，每一个特征点所对应的输入区域不断变大。<br />\n最终，在靠近输出层的位置，特征图中的<strong>一个位置</strong>实际上已经“覆盖”了输入图像中的一个<strong>较大窗口区域</strong>。<br />\n只不过现在窗口不再由我们手动裁剪，而是由网络结构<strong>决定</strong>。</p>\n<h2 id=\"23-拓展特征图输出的标签问题\">2.3 拓展：特征图输出的标签问题</h2>\n<p>到这里，我想你可能会有这样一个问题：<strong>我们虽然改变了网络结构，但是我们这时使用的还是原本分类器的数据，即对一幅图像的标签只有一个0或1来表示图像里是否存在目标。现在我们修改了输出格式，是否需要也修改标签，改为给每个窗口打标签？</strong><br />\n<strong>答案是不用。</strong><br />\n为什么？<br />\n虽然在训练阶段，网络接收到的仍然只是<strong>图像级别的分类标签</strong>，但由于输出已经被展开为一个带空间结构的特征图，这个标签会被<strong>隐式地约束到整张特征图上</strong>：只要某一个位置对应的窗口能够正确响应目标类别，这一次预测就被认为是“成功的”。</p>\n<p>换句话说，卷积化之后的分类网络，并不是在学习“这整张图像是不是目标”，而是在学习：<strong>“在这张图像的哪些位置，存在一个可以被识别为目标的窗口”。</strong></p>\n<p>有些抽象，我们可以来看一个具体的例子：<br />\n假设训练集中有一张图片，内容是一辆汽车，整张图像的<strong>唯一标签</strong>就是「car」。<br />\n当这张图像被送入卷积化后的网络时，输出的不再是一个标量，而是一个 <span class=\"math inline\">\\(H' \\times W'\\)</span> 的分类特征图，其中<strong>每一个位置</strong>都对应输入图像中的一个窗口。<br />\n在初始训练阶段，这张特征图上的绝大多数位置，输出的分类结果其实都是错误的：</p>\n<ul>\n<li>有的位置覆盖的是背景</li>\n<li>有的位置只覆盖了汽车的一部分</li>\n<li>还有的位置甚至只包含天空或道路</li>\n</ul>\n<p>但这并不会破坏训练过程。<br />\n因为此时网络的目标并不是要求每一个位置都预测为 car，<strong>而是至少存在某一个位置，其对应的窗口能够对 car 类别产生足够强的响应。</strong></p>\n<p><strong>更准确地说，在训练阶段，并不是直接将整个 <span class=\"math inline\">\\(H' \\times W'\\)</span> 的输出特征图与图像级标签逐位置对齐计算损失。</strong><br />\n网络通常会先在空间维度上进行一次聚合操作（最常见的是取最大响应），将整张特征图压缩为一个标量预测，再与图像级标签计算分类损失。<br />\n这种训练方式可以被理解为一种<strong>弱监督学习</strong>：<br />\n<strong>只要输出特征图中存在某一个空间位置，对目标类别产生了足够强的响应，这张图像就被认为预测正确。</strong><br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251223205038766-641170151.png\" /></p>\n<p>在反向传播过程中，梯度主要会通过这些高响应位置回传，从而推动网络逐渐强化那些<strong>确实覆盖了完整目标或关键判别区域的空间位置</strong>，而对背景区域的响应自然被压低。</p>\n<p>最终，在输出特征图上，你会看到：只有少数几个位置对 car 类别产生明显高响应，而这些位置恰好落在汽车所在的区域附近。<br />\n此时，虽然训练标签始终只是一个“图像级标签”，但网络已经<strong>自动学会了在空间维度上区分“哪里值得响应”</strong>。</p>\n<p>于是我们就解决了 1.0 算法导致的极大计算量问题，但是还有一个问题仍然存在，就是固定尺寸的窗口仍无法实现对目标的较精准定位。<br />\n怎么解决？来看看 3.0 算法。</p>\n<h1 id=\"3-检测算法30yolo-算法\">3. 检测算法3.0：YOLO 算法</h1>\n<p><strong>YOLO 算法是目前真正主流的算法之一</strong>，你可以在目前几乎目标检测的所有领域看到它的身影，时至今日，它仍在不断地更新。</p>\n<p>虽然在 2.0 中，窗口已经不再由人手工滑动，而是由网络结构隐式决定，但本质并没有变：<br />\n网络输出的是： <strong>“这个窗口里有没有目标”</strong>，而不是：<strong>“目标在哪里、是什么、边界在哪。”</strong></p>\n<p>也就是说，2.0 的网络会告诉你： “这里大概有个 car”，但不会直接告诉你：“car 的中心在这，宽高是多少。”<br />\n它的定位准确度问题仍然存在且不可忽视。<br />\n于是，在 2015 年，一篇名为<a href=\"https://homes.cs.washington.edu/~ali/papers/YOLO.pdf\" rel=\"noopener nofollow\" target=\"_blank\">You Only Look Once</a>的论文被发表，它的核心观点就是：<strong>能不能让网络别再纠结“窗口”，而是直接预测目标本身？</strong></p>\n<p>论文本身较为复杂，我们来看看 YOLO 相对 1.0、2.0 最关键的改变:<strong>规范目标检测任务的标签</strong>。</p>\n<p>YOLO 算法本身为目标检测任务提出了专用的标签，正是我们在<a href=\"https://www.cnblogs.com/Goblinscholar/p/19384242\" target=\"_blank\">上一篇中</a>介绍的“<strong>位置信息</strong>”。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251223205057400-299808113.png\" /></p>\n<ol>\n<li><span class=\"math inline\">\\(p_c\\)</span>：表示<strong>当前图像中是否存在需要检测的目标</strong>，这是一个二值变量，通常取值为 <span class=\"math inline\">\\(0\\)</span> 或 <span class=\"math inline\">\\(1\\)</span>。<br />\n当 <span class=\"math inline\">\\(p_c = 1\\)</span> 时，表示图像中确实存在目标，此时后续的位置信息和类别信息才是“有效”的；<br />\n当 <span class=\"math inline\">\\(p_c = 0\\)</span> 时，表示图像中不存在目标，<strong>其余参数通常被忽略或置为 0。</strong></li>\n<li><span class=\"math inline\">\\(b_x,b_y,b_h,b_w\\)</span> :表示检测目标的<strong>位置信息</strong>。</li>\n<li><span class=\"math inline\">\\(c_n\\)</span>：表示目标所属的<strong>类别信息</strong>。<br />\n在二分类问题中，它可以是一个标量；<br />\n在多分类问题中，通常采用 <strong>独热编码</strong> 的形式，用一个向量来表示目标属于哪一类。</li>\n</ol>\n<p>规范好标签本身后，我们来看看算法如何使用标签：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251223205038504-641386161.png\" /></p>\n<p><img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251223205147720-180508610.png\" /><br />\n因此，一个样本在 <span class=\"math inline\">\\(S \\times S\\)</span> 网格划分下，其标签张量维度为：</p>\n<p></p><div class=\"math display\">\\[S \\times S \\times (5 + c_n) \n\\]</div><p></p><p>看到这里，你可能会疑惑，<strong>划分网格的作用是什么？我们最开始说 YOLO 避开了窗口又是指什么？</strong><br />\n别急，关键点就在于我们刚刚规范的新标签：<span class=\"math inline\">\\(b_x,b_y,b_h,b_w\\)</span> 。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251223205053651-1469789459.png\" /><br />\n你会发现，通过几个位置信息参数，<strong>我们虽然划分了网格，但是网格却不会像窗口的步长一样限制目标的边界框，每个网格单元相当于一个预测单元来预测中心点在本单元格里的目标的类别和边界框。</strong><br />\n现在，我们就可以继续应用 2.0 中的网络,调整输出特征图为新的标签维度,即可以此计算损失并反向传播了。<br />\n你会发现，YOLO 的核心优势是：</p>\n<ul>\n<li>不再枚举窗口，不再重复计算。</li>\n<li>每个网格单元独立负责预测目标，同时输出边界框和类别。</li>\n<li>训练时即可端到端优化，预测阶段一次前向传播完成整图检测。</li>\n</ul>\n<p>可以说，YOLO 的提出让“检测”真正从“分类的延伸”脱离出来，成为计算机视觉领域的核心任务之一，它的内容还有很多，我们遇到再慢慢展开。</p>\n<h1 id=\"4总结\">4.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>1.0 滑动窗口检测</strong></td>\n<td>使用固定大小窗口在图像上滑动，将每个窗口送入分类网络判断是否包含目标；通过局部分类结果间接拼凑目标位置</td>\n<td>就像用放大镜逐块检查整张图，找到目标再标记位置</td>\n</tr>\n<tr>\n<td><strong>问题</strong></td>\n<td>计算量巨大，每个窗口都要单独处理；定位精度依赖分类结果拼凑</td>\n<td>翻阅整本书寻找关键词，每页都要仔细看一遍</td>\n</tr>\n<tr>\n<td><strong>2.0 卷积化检测</strong></td>\n<td>将整幅图像送入卷积网络，卷积层自动完成滑动和特征提取，输出二维特征图表示各位置分类结果；全连接层可被等效卷积替代</td>\n<td>不用逐页检查，而是扫描整本书，自动标记出现关键词的区域</td>\n</tr>\n<tr>\n<td><strong>窗口在特征图中传播</strong></td>\n<td>随着卷积层堆叠，每个特征图位置对应输入图像的一个大窗口区域；训练阶段采用弱监督，只需部分高响应位置预测正确即可</td>\n<td>小窗口信息逐渐汇聚，像放大镜自动跟踪关键区域</td>\n</tr>\n<tr>\n<td><strong>标签设计</strong></td>\n<td>输出特征图使用图像级标签，卷积网络自动学会空间位置响应，无需对每个窗口手工标注</td>\n<td>给整本书一个主题标签，网络自动找到相关章节</td>\n</tr>\n<tr>\n<td><strong>3.0 YOLO</strong></td>\n<td>网络直接预测每个网格单元内目标的类别和边界框；端到端训练，不再依赖滑动窗口或重复计算</td>\n<td>每个网格像一个小探员，直接告诉你目标在这里，并画出轮廓</td>\n</tr>\n<tr>\n<td><strong>YOLO 标签规范</strong></td>\n<td>每个网格包含 <span class=\"math inline\">\\(p_c\\)</span>（是否有目标）、<span class=\"math inline\">\\(b_x,b_y,b_h,b_w\\)</span>（边界框位置）、<span class=\"math inline\">\\(c_n\\)</span>（类别）；输出维度 <span class=\"math inline\">\\(S \\times S \\times (5 + c_n)\\)</span></td>\n<td>每个小探员携带完整信息卡片，报告目标位置和类型</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-23 20:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">40</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}