{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "vue使用h函数封装dialog组件，以命令的形式使用dialog组件",
      "link": "https://www.cnblogs.com/IwishIcould/p/19147850",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/IwishIcould/p/19147850\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 09:10\">\n    <span>vue使用h函数封装dialog组件，以命令的形式使用dialog组件</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"场景\">场景</h4>\n<p>有些时候我们的页面是有很多的弹窗<br />\n如果我们把这些弹窗都写html中会有一大坨<br />\n因此：我们需要把弹窗封装成命令式的形式</p>\n<h4 id=\"命令式弹窗\">命令式弹窗</h4>\n<pre><code>// 使用弹窗的组件\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-button @click=\"openMask\"&gt;点击弹窗&lt;/el-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport childTest from '@/components/childTest.vue'\nimport { renderDialog } from '@/hooks/dialog'\nfunction openMask(){\n  // 第1个参数：表示的是组件，你写弹窗中的组件\n  // 第2个参数：表示的组件属性，比如：确认按钮的名称等\n  // 第3个参数：表示的模态框的属性。比如：模态宽的宽度，标题名称，是否可移动\n  renderDialog(childTest,{},{title:'测试弹窗'})\n}\n&lt;/script&gt;\n</code></pre>\n<pre><code>// 封装的弹窗\nimport { createApp, h } from \"vue\";\nimport { ElDialog } from \"element-plus\";\nexport function renderDialog(component:any,props:any, modalProps:any){\n const dialog  = h(\n    ElDialog,   // 模态框组件\n    {\n      ...modalProps, // 模态框属性\n      modelValue:true, // 模态框是否显示\n    }, // 因为是模态框组件，肯定是模态框的属性\n    {\n      default:()=&gt;h(component, props ) // 插槽，el-dialog下的内容\n    }\n  )\n console.log(dialog)\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<pre><code>//childTest.vue 组件\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;span&gt;It's a modal Dialog&lt;/span&gt;\n    &lt;el-form :model=\"form\" label-width=\"auto\" style=\"max-width: 600px\"&gt;\n    &lt;el-form-item label=\"Activity name\"&gt;\n      &lt;el-input v-model=\"form.name\" /&gt;\n    &lt;/el-form-item&gt;\n    &lt;el-form-item label=\"Activity zone\"&gt;\n      &lt;el-select v-model=\"form.region\" placeholder=\"please select your zone\"&gt;\n        &lt;el-option label=\"Zone one\" value=\"shanghai\" /&gt;\n        &lt;el-option label=\"Zone two\" value=\"beijing\" /&gt;\n      &lt;/el-select&gt;\n    &lt;/el-form-item&gt;\n  &lt;/el-form&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport { ref,reactive } from 'vue'\nconst dialogVisible = ref(true)\nconst form = reactive({\n  name: '',\n  region: '',\n})\nconst onSubmit = () =&gt; {\n  console.log('submit!')\n}\n&lt;/script&gt;\n</code></pre>\n<p><img alt=\"01\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017145322240-379014905.png\" /></p>\n<h4 id=\"为啥弹窗中的表单不能够正常展示呢\">为啥弹窗中的表单不能够正常展示呢？</h4>\n<p>在控制台会有下面的提示信息：<br />\nFailed to resolve component:<br />\nel-form If this is a native custom element,<br />\nmake sure to exclude it from component resolution via compilerOptions.isCustomElement<br />\n翻译过来就是<br />\n无法解析组件：el-form如果这是一个原生自定义元素，<br />\n请确保通过 compilerOptions.isCustomElement 将其从组件解析中排除</p>\n<p><img alt=\"02\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017145524776-326631892.png\" /></p>\n<p>其实就是说：我重新创建了一个新的app,这个app中没有注册组件。<br />\n因此会警告，页面渲染不出来。</p>\n<pre><code>// 我重新创建了一个app，这个app中没有注册 element-plus 组件。\nconst app = createApp(dialog)\n</code></pre>\n<p>现在我们重新注册element-plus组件。<br />\n准确的说：我们要注册 childTest.vue 组件使用到的东西</p>\n<h4 id=\"给新创建的app应用注册childtest组件使用到的东西\">给新创建的app应用注册childTest组件使用到的东西</h4>\n<p>我们将会在这个命令式弹窗中重新注册需要使用到的组件</p>\n<pre><code>// 封装的弹窗\nimport { createApp, h } from \"vue\";\nimport { ElDialog } from \"element-plus\";\n// 引入组件和样式\nimport ElementPlus from \"element-plus\";\n// import \"element-plus/dist/index.css\";\nexport function renderDialog(component:any,props:any, modalProps:any){\n const dialog  = h(\n    ElDialog,   // 模态框组件\n    {\n      ...modalProps, // 模态框属性\n      modelValue:true, // 模态框显示\n    }, // 因为是模态框组件，肯定是模态框的属性\n    {\n      default:()=&gt;h(component, props ) // 插槽，el-dialog下的内容\n    }\n  )\n console.log(dialog)\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<p><img alt=\"03\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017150030012-288792935.png\" /></p>\n<p>现在我们发现可以正常展示弹窗中的表单了。因为我们注册了element-plus组件。<br />\n但是我们发现又发现了另外一个问题。<br />\n弹窗底部没有取消和确认按钮。<br />\n需要我们再次通过h函数来创建</p>\n<h4 id=\"关于使用createapp创建新的应用实例\">关于使用createApp创建新的应用实例</h4>\n<p>在Vue 3中，我们可以使用 createApp 来创建新的应用实例<br />\n但是这样会创建一个完全独立的应用<br />\n它不会共享主应用的组件、插件等。<br />\n因此我们需要重新注册</p>\n<h4 id=\"弹窗底部新增取消和确认按钮\">弹窗底部新增取消和确认按钮</h4>\n<p>我们将会使用h函数中的插槽来创建底部的取消按钮</p>\n<pre><code>// 封装的弹窗\nimport { createApp, h } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any) {\n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n    },\n    {\n      // 主要内容插槽\n      default: () =&gt; h(component, props),\n      // 底部插槽\n      footer:() =&gt;h(\n        'div',\n        { class: 'dialog-footer' },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('取消')\n              }\n            },\n            () =&gt; '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              onClick: () =&gt; {\n                console.log('确定')\n              }\n            },\n            () =&gt; '确定'\n          )\n        ]\n      )\n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<p><img alt=\"04\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017150758182-172077623.png\" /></p>\n<h4 id=\"点击关闭弹窗时需要移除之前创建的div\">点击关闭弹窗时，需要移除之前创建的div</h4>\n<p>卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div。<br />\n2个地方需要移除：1,点击确认按钮。 2,点击其他地方的关闭<br />\n<img alt=\"05\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017150936490-1107995889.png\" /></p>\n<h4 id=\"关闭弹窗正确销毁相关组件\">关闭弹窗正确销毁相关组件</h4>\n<pre><code>// 封装的弹窗\nimport { createApp, h } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any) {\n  console.log('111')\n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n      onClose: ()=&gt; {\n        console.log('关闭的回调')\n        app.unmount() // 这样卸载会让动画消失\n        // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n        document.body.removeChild(div)\n      }\n    },\n    {\n      // 主要内容插槽\n      default: () =&gt; h(component, props),\n      // 底部插槽\n      footer:() =&gt;h(\n        'div',\n        { \n          class: 'dialog-footer',\n         \n        },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('点击取消按钮')\n                // 卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n                app.unmount() // 这样卸载会让动画消失\n                // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n                document.body.removeChild(div)\n              }\n            },\n            () =&gt; '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              onClick: () =&gt; {\n                console.log('确定')\n              }\n            },\n            () =&gt; '确定'\n          )\n        ]\n      )\n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  // 这个div元素在在销毁应用时需要被移除哈\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<p><img alt=\"06\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017151046536-220748441.png\" /></p>\n<h4 id=\"点击确认按钮时验证规则\">点击确认按钮时验证规则</h4>\n<p>有些时候，我们弹窗中的表单是需要进行规则校验的。<br />\n我们下面来实现这个功能点<br />\n传递的组件</p>\n<pre><code>&lt;template&gt;\n  &lt;el-form\n    ref=\"ruleFormRef\"\n    style=\"max-width: 600px\"\n    :model=\"ruleForm\"\n    :rules=\"rules\"\n    label-width=\"auto\"\n  &gt;\n    &lt;el-form-item label=\"Activity name\" prop=\"name\"&gt;\n      &lt;el-input v-model=\"ruleForm.name\" /&gt;\n    &lt;/el-form-item&gt;\n    &lt;el-form-item label=\"Activity zone\" prop=\"region\"&gt;\n      &lt;el-select v-model=\"ruleForm.region\" placeholder=\"Activity zone\"&gt;\n        &lt;el-option label=\"Zone one\" value=\"shanghai\" /&gt;\n        &lt;el-option label=\"Zone two\" value=\"beijing\" /&gt;\n      &lt;/el-select&gt;\n    &lt;/el-form-item&gt;\n    \n    &lt;el-form-item label=\"Activity time\" required&gt;\n      &lt;el-col :span=\"11\"&gt;\n        &lt;el-form-item prop=\"date1\"&gt;\n          &lt;el-date-picker\n            v-model=\"ruleForm.date1\"\n            type=\"date\"\n            aria-label=\"Pick a date\"\n            placeholder=\"Pick a date\"\n            style=\"width: 100%\"\n          /&gt;\n        &lt;/el-form-item&gt;\n      &lt;/el-col&gt;\n      &lt;el-col class=\"text-center\" :span=\"2\"&gt;\n        &lt;span class=\"text-gray-500\"&gt;-&lt;/span&gt;\n      &lt;/el-col&gt;\n      &lt;el-col :span=\"11\"&gt;\n        &lt;el-form-item prop=\"date2\"&gt;\n          &lt;el-time-picker\n            v-model=\"ruleForm.date2\"\n            aria-label=\"Pick a time\"\n            placeholder=\"Pick a time\"\n            style=\"width: 100%\"\n          /&gt;\n        &lt;/el-form-item&gt;\n      &lt;/el-col&gt;\n    &lt;/el-form-item&gt;\n\n    &lt;el-form-item label=\"Resources\" prop=\"resource\"&gt;\n      &lt;el-radio-group v-model=\"ruleForm.resource\"&gt;\n        &lt;el-radio value=\"Sponsorship\"&gt;Sponsorship&lt;/el-radio&gt;\n        &lt;el-radio value=\"Venue\"&gt;Venue&lt;/el-radio&gt;\n      &lt;/el-radio-group&gt;\n    &lt;/el-form-item&gt;\n    &lt;el-form-item label=\"Activity form\" prop=\"desc\"&gt;\n      &lt;el-input v-model=\"ruleForm.desc\" type=\"textarea\" /&gt;\n    &lt;/el-form-item&gt;\n\n  &lt;/el-form&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\" setup&gt;\nimport { reactive, ref } from 'vue'\n\nimport type { FormInstance, FormRules } from 'element-plus'\n\ninterface RuleForm {\n  name: string\n  region: string\n  date1: string\n  date2: string\n  resource: string\n  desc: string\n}\nconst ruleFormRef = ref&lt;FormInstance&gt;()\nconst ruleForm = reactive&lt;RuleForm&gt;({\n  name: 'Hello',\n  region: '',\n  date1: '',\n  date2: '',\n  resource: '',\n  desc: '',\n})\nconst rules = reactive&lt;FormRules&lt;RuleForm&gt;&gt;({\n  name: [\n    { required: true, message: 'Please input Activity name', trigger: 'blur' },\n    { min: 3, max: 5, message: 'Length should be 3 to 5', trigger: 'blur' },\n  ],\n  region: [\n    {\n      required: true,\n      message: 'Please select Activity zone',\n      trigger: 'change',\n    },\n  ],\n  date1: [\n    {\n      type: 'date',\n      required: true,\n      message: 'Please pick a date',\n      trigger: 'change',\n    },\n  ],\n  date2: [\n    {\n      type: 'date',\n      required: true,\n      message: 'Please pick a time',\n      trigger: 'change',\n    },\n  ],\n  resource: [\n    {\n      required: true,\n      message: 'Please select activity resource',\n      trigger: 'change',\n    },\n  ],\n  desc: [\n    { required: true, message: 'Please input activity form', trigger: 'blur' },\n  ],\n})\n\nconst submitForm = async () =&gt; {\n  if (!ruleFormRef.value) {\n    console.error('ruleFormRef is not initialized')\n    return false\n  }\n  try {\n    const valid = await ruleFormRef.value.validate()\n    if (valid) {\n      console.log('表单校验通过', ruleForm)\n      return Promise.resolve(ruleForm)\n    }\n  } catch (error) {\n    // 为啥submitForm中，valid的值是false会执行catch ？\n    // el-form 组件的 validate 方法的工作机制导致的。 validate 方法在表单验证失败时会抛出异常\n    console.error('err', error)\n    return false\n    /**\n     * 下面这样写为啥界面会报错呢？\n     * return Promise.reject(error)\n     * 当表单验证失败时，ruleFormRef.value.validate() 会抛出一个异常。\n     * 虽然你用了 try...catch 捕获这个异常，并且在 catch 块中通过 return Promise.reject(error) 返回了一个被拒绝的 Promise\n     * 但如果调用 submitForm 的地方没有正确地处理这个被拒绝的 Promise（即没有使用 .catch() 或者 await 来接收错误），\n     * 那么浏览器控制台就会显示一个 \"Uncaught (in promise)\" 错误。\n     * 在 catch 中再次 return Promise.reject(error) 是多余的， 直接return false\n     * */ \n    /**\n     * 如果你这样写\n     * throw error 直接抛出错误即可\n     * 那么就需要再调用submitForm的地方捕获异常\n     * */  \n  }\n}\n\ndefineExpose({\n  submitForm:submitForm\n})\n&lt;/script&gt;\n</code></pre>\n<pre><code>// 封装的弹窗\nimport { createApp, h, ref } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any) {\n  const instanceElement = ref()\n  console.log('111', instanceElement) \n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n      onClose: ()=&gt; {\n        console.log('关闭的回调')\n        app.unmount() // 这样卸载会让动画消失\n        // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n        document.body.removeChild(div)\n      }\n    },\n    {\n      // 主要内容插槽,这里的ref必须接收一个ref\n      default: () =&gt; h(component, {...props, ref: instanceElement}),\n      // 底部插槽\n      footer:() =&gt;h(\n        'div',\n        { \n          class: 'dialog-footer',\n         \n        },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('点击取消按钮')\n                // 卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n                app.unmount() // 这样卸载会让动画消失\n                // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n                document.body.removeChild(div)\n              }\n            },\n            () =&gt; '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              onClick: () =&gt; {\n                instanceElement?.value?.submitForm().then((res:any) =&gt;{\n                  console.log('得到的值',res)\n                })\n                console.log('确定')\n              }\n            },\n            () =&gt; '确定'\n          )\n        ]\n      )\n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  // 这个div元素在在销毁应用时需要被移除哈\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<p><img alt=\"07\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017153103678-1920669946.png\" /><br />\n关键的点：通过ref拿到childTest组件中的方法，childTest要暴露需要的方法</p>\n<h4 id=\"如何把表单中的数据暴露出去\">如何把表单中的数据暴露出去</h4>\n<p>可以通过回调函数的方式把数据暴露出去哈。</p>\n<pre><code>// 封装的弹窗\nimport { createApp, h, ref } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any, onConfirm: (data: any) =&gt; any ) {\n  // 第4个参数是回调函数\n  const instanceElement = ref()\n  console.log('111', instanceElement) \n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n      onClose: ()=&gt; {\n        console.log('关闭的回调')\n        app.unmount() // 这样卸载会让动画消失\n        // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n        document.body.removeChild(div)\n      }\n    },\n    {\n      // 主要内容插槽,这里的ref必须接收一个ref\n      default: () =&gt; h(component, {...props, ref: instanceElement}),\n      // 底部插槽\n      footer:() =&gt;h(\n        'div',\n        { \n          class: 'dialog-footer',\n         \n        },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('点击取消按钮')\n                // 卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n                app.unmount() // 这样卸载会让动画消失\n                // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n                document.body.removeChild(div)\n              }\n            },\n            () =&gt; '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              onClick: () =&gt; {\n                // submitForm 调用表单组件中需要验证或者暴露出去的数据\n                instanceElement?.value?.submitForm().then((res:any) =&gt;{\n                  console.log('得到的值',res)\n                  // 验证通过后调用回调函数传递数据， 如验证失败，res 的值有可能是一个false。\n                  onConfirm(res)\n                  // 怎么把这个事件传递出去，让使用的时候知道点击了确认并且知道验证通过了\n                }).catch((error: any) =&gt; {\n                  // 验证失败时也可以传递错误信息\n                  console.log('验证失败', error)\n                })\n                console.log('确定')\n              }\n            },\n            () =&gt; '确定'\n          )\n        ]\n      )\n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  // 这个div元素在在销毁应用时需要被移除哈\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-button @click=\"openMask\"&gt;点击弹窗&lt;/el-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport childTest from '@/components/childTest.vue'\nimport { renderDialog } from '@/hooks/dialog'\nimport { getCurrentInstance } from 'vue';\nconst currentInstance = getCurrentInstance();\nfunction openMask(){\n  console.log('currentInstance',currentInstance)\n  renderDialog(childTest,{},{title:'测试弹窗', width: '700'}, (res)=&gt;{\n    console.log('通过回调函数返回值', res)\n  })\n}\n&lt;/script&gt;\n</code></pre>\n<p><img alt=\"08\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017153517135-614116266.png\" /></p>\n<h4 id=\"点击确定时业务完成后关闭弹窗\">点击确定时，业务完成后关闭弹窗</h4>\n<p>现在想要点击确定，等业务处理完成之后，才关闭弹窗。<br />\n需要在使用完成业务的时候返回一个promise，让封装的弹窗调用这个promise<br />\n这样就可以知道什么时候关闭弹窗了</p>\n<pre><code>// 封装的弹窗\nimport { createApp, h, ref } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any, onConfirm: (data: any) =&gt; any ) {\n  // 第4个参数是回调函数\n  const instanceElement = ref()\n  console.log('111', instanceElement) \n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n      onClose: ()=&gt; {\n        console.log('关闭的回调')\n        app.unmount() // 这样卸载会让动画消失\n        // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n        document.body.removeChild(div)\n      }\n    },\n    {\n      // 主要内容插槽,这里的ref必须接收一个ref\n      default: () =&gt; h(component, {...props, ref: instanceElement}),\n      // 底部插槽\n      footer:() =&gt;h(\n        'div',\n        { \n          class: 'dialog-footer',\n         \n        },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('点击取消按钮')\n                // 卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n                app.unmount() // 这样卸载会让动画消失\n                // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n                document.body.removeChild(div)\n              }\n            },\n            () =&gt; '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              onClick: () =&gt; {\n                // submitForm 调用表单组件中需要验证或者暴露出去的数据\n                instanceElement?.value?.submitForm().then((res:any) =&gt;{\n                  console.log('得到的值',res)\n                  // 验证通过后调用回调函数传递数据，如验证失败，res 的值有可能是一个false。\n                  const callbackResult = onConfirm(res);\n                  // 如果回调函数返回的是 Promise，则等待业务完成后再关闭弹窗\n                  if (callbackResult instanceof Promise) {\n                    // 注意这里的finally，这样写在服务出现异常的时候会有问题,这里是有问题的，需要优化\n                    // 注意这里的finally，这样写在服务出现异常的时候会有问题,这里是有问题的，需要优化\n                    callbackResult.finally(() =&gt; { \n                      // 弹窗关闭逻辑\n                      app.unmount()\n                      document.body.removeChild(div)\n                    });\n                  } else {\n                    // 如果不是 Promise，立即关闭弹窗\n                    app.unmount()\n                    document.body.removeChild(div)\n                  }\n                }).catch((error: any) =&gt; {\n                  // 验证失败时也可以传递错误信息\n                  console.log('验证失败', error)\n                })\n              }\n            },\n            () =&gt; '确定'\n          )\n        ]\n      )\n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  // 这个div元素在在销毁应用时需要被移除哈\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-button @click=\"openMask\"&gt;点击弹窗&lt;/el-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport childTest from '@/components/childTest.vue'\nimport { renderDialog } from '@/hooks/dialog'\nimport { getCurrentInstance } from 'vue';\nconst currentInstance = getCurrentInstance();\nfunction openMask(){\n  console.log('currentInstance',currentInstance)\n  renderDialog(childTest,{},{title:'测试弹窗', width: '700'}, (res)=&gt;{\n    console.log('通过回调函数返回值', res)\n    // 这里返回一个promise对象，这样就可以让业务完成后才关闭弹窗\n    return fetch(\"https://dog.ceo/api/breed/pembroke/images/random\")\n     .then((res) =&gt; {\n       return res.json();\n     })\n     .then((res) =&gt; {\n        console.log('获取的图片地址为：', res.message);\n     });\n  })\n}\n&lt;/script&gt;\n</code></pre>\n<p><img alt=\"09\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017153933776-969209851.png\" /></p>\n<h4 id=\"优化业务组件\">优化业务组件</h4>\n<pre><code>// 封装的弹窗\nimport { createApp, h, ref } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any, onConfirm: (data: any) =&gt; any ) {\n  // 关闭弹窗，避免重复代码\n  const closeDialog = () =&gt; {\n    // 成功时关闭弹窗\n    app.unmount();\n    // 检查div是否仍然存在且为body的子元素,否者可能出现异常\n    if (div &amp;&amp; div.parentNode) {\n      document.body.removeChild(div)\n    }\n  }\n  // 第4个参数是回调函数\n  const instanceElement = ref()\n  console.log('111', instanceElement) \n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n      onClose: ()=&gt; {\n        console.log('关闭的回调')\n        app.unmount() // 这样卸载会让动画消失\n        // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n        document.body.removeChild(div)\n      }\n    },\n    {\n      // 主要内容插槽,这里的ref必须接收一个ref\n      default: () =&gt; h(component, {...props, ref: instanceElement}),\n      // 底部插槽\n      footer:() =&gt;h(\n        'div',\n        { \n          class: 'dialog-footer',\n         \n        },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('点击取消按钮')\n                // 卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n                app.unmount() // 这样卸载会让动画消失\n                // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n                document.body.removeChild(div)\n              }\n            },\n            () =&gt; '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              onClick: () =&gt; {\n                // submitForm 调用表单组件中需要验证或者暴露出去的数据\n                instanceElement?.value?.submitForm().then((res:any) =&gt;{\n                  console.log('得到的值',res)\n                  // 验证通过后调用回调函数传递数据，如验证失败，res 的值有可能是一个false。\n                  const callbackResult = onConfirm(res);\n                  // 如果回调函数返回的是 Promise，则等待业务完成后再关闭弹窗\n                  if (callbackResult instanceof Promise) {\n                   \n                     callbackResult.then(() =&gt; {\n                      if(res){\n                        console.log('111')\n                        closeDialog()\n                      }\n                    }).catch(error=&gt;{\n                      console.log('222')\n                      console.error('回调函数执行出错,如:网络错误', error);\n                      // 错误情况下也关闭弹窗\n                      closeDialog()\n                    });\n                  } else {\n                    // 如果不是 Promise，并且验证时通过了的。立即关闭弹窗\n                    console.log('333', res)\n                    if(res){\n                      closeDialog()\n                    }\n                  }\n                }).catch((error: any) =&gt; {\n                  console.log('44444')\n                  // 验证失败时也可以传递错误信息\n                  console.log('验证失败', error)\n                })\n              }\n            },\n            () =&gt; '确定'\n          )\n        ]\n      )\n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  // 这个div元素在在销毁应用时需要被移除哈\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-button @click=\"openMask\"&gt;点击弹窗&lt;/el-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport childTest from '@/components/childTest.vue'\nimport { renderDialog } from '@/hooks/dialog'\nimport { getCurrentInstance } from 'vue';\nconst currentInstance = getCurrentInstance();\nfunction openMask(){\n  console.log('currentInstance',currentInstance)\n  renderDialog(childTest,{},{title:'测试弹窗', width: '700'}, (res)=&gt;{\n    console.log('通过回调函数返回值', res)\n      // 这里返回一个promise对象，这样就可以让业务完成后才关闭弹窗\n      return fetch(\"https://dog.ceo/api/breed/pembroke/images/random\")\n      .then((res) =&gt; {\n        return res.json();\n      })\n      .then((res) =&gt; {\n          console.log('获取的图片地址为：', res.message);\n      });\n  })\n}\n&lt;/script&gt;\n</code></pre>\n<p>眼尖的小伙伴可能已经发现了这一段代码。<br />\n1，验证不通过会也会触发卸载弹窗<br />\n2，callbackResult.finally是不合适的<br />\n3.<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017160228378-793571991.png\" /></p>\n<p><img alt=\"10\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017154924223-2023334538.png\" /></p>\n<h4 id=\"最终的代码\">最终的代码</h4>\n<pre><code>// 封装的弹窗\nimport { createApp, h, ref } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any, onConfirm: (data: any) =&gt; any ) {\n  // 关闭弹窗，避免重复代码\n  const closeDialog = () =&gt; {\n    // 成功时关闭弹窗\n    app.unmount();\n    // 检查div是否仍然存在且为body的子元素,否者可能出现异常\n    if (div &amp;&amp; div.parentNode) {\n      document.body.removeChild(div)\n    }\n  }\n  // 第4个参数是回调函数\n  const instanceElement = ref()\n  console.log('111', instanceElement) \n  const isLoading = ref(false)\n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n      onClose: ()=&gt; {\n        isLoading.value = false\n        console.log('关闭的回调')\n        app.unmount() // 这样卸载会让动画消失\n        // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n        document.body.removeChild(div)\n      }\n    },\n    {\n      // 主要内容插槽,这里的ref必须接收一个ref\n      default: () =&gt; h(component, {...props, ref: instanceElement}),\n      // 底部插槽,noShowFooterBool是true,不显示； false的显示底部 \n      footer: props.noShowFooterBool ? null : () =&gt;h(\n        'div',\n        { \n          class: 'dialog-footer',\n        },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('点击取消按钮')\n                // 卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n                app.unmount() // 这样卸载会让动画消失\n                // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n                document.body.removeChild(div)\n              }\n            },\n            () =&gt; props.cancelText || '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              loading: isLoading.value,\n              onClick: () =&gt; {\n                isLoading.value = true\n                // submitForm 调用表单组件中需要验证或者暴露出去的数据\n                instanceElement?.value?.submitForm().then((res:any) =&gt;{\n                  if(!res){\n                    isLoading.value = false\n                  }\n                  console.log('得到的值',res)\n                  // 验证通过后调用回调函数传递数据，如验证失败，res 的值有可能是一个false。\n                  const callbackResult = onConfirm(res);\n                  // 如果回调函数返回的是 Promise，则等待业务完成后再关闭弹窗\n                  if (callbackResult instanceof Promise) {\n                     callbackResult.then(() =&gt; {\n                      if(res){\n                        console.log('111')\n                        closeDialog()\n                      }else{\n                        isLoading.value = false\n                      }\n                    }).catch(error=&gt;{\n                      console.log('222')\n                      console.error('回调函数执行出错,如:网络错误', error);\n                      // 错误情况下也关闭弹窗\n                      closeDialog()\n                    });\n                  } else {\n                    // 如果不是 Promise，并且验证时通过了的。立即关闭弹窗\n                    console.log('333', res)\n                    if(res){\n                      closeDialog()\n                    }else{\n                      isLoading.value = false\n                    }\n                  }\n                }).catch((error: any) =&gt; {\n                  console.log('44444')\n                   isLoading.value = false\n                  // 验证失败时也可以传递错误信息\n                  console.log('验证失败', error)\n                })\n              }\n            },\n            () =&gt; props.confirmText ||  '确定'\n          )\n        ]\n      ) \n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  // 这个div元素在在销毁应用时需要被移除哈\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-button @click=\"openMask\"&gt;点击弹窗&lt;/el-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport childTest from '@/components/childTest.vue'\nimport { renderDialog } from '@/hooks/dialog'\nimport { getCurrentInstance } from 'vue';\nconst currentInstance = getCurrentInstance();\nfunction openMask(){\n  console.log('currentInstance',currentInstance)\n  const otherProps =  {cancelText:'取消哈', confirmText: '确认哈',showFooterBool:true }\n  const dialogSetObject = {title:'测试弹窗哈', width: '700', draggable: true}\n  renderDialog(childTest,otherProps,dialogSetObject, (res)=&gt;{\n    console.log('通过回调函数返回值', res)\n    // 这里返回一个promise对象，这样就可以让业务完成后才关闭弹窗\n    return fetch(\"https://dog.ceo/api/breed/pembroke/images/random\")\n    .then((res) =&gt; {\n      return res.json();\n    })\n    .then((res) =&gt; {\n        console.log('获取的图片地址为：', res.message);\n    });\n  })\n}\n&lt;/script&gt;\n\n&lt;style lang=\"scss\" scoped&gt;\n\n&lt;/style&gt;\n</code></pre>\n<pre><code>&lt;template&gt;\n  &lt;el-form\n    ref=\"ruleFormRef\"\n    style=\"max-width: 600px\"\n    :model=\"ruleForm\"\n    :rules=\"rules\"\n    label-width=\"auto\"\n  &gt;\n    &lt;el-form-item label=\"Activity name\" prop=\"name\"&gt;\n      &lt;el-input v-model=\"ruleForm.name\" /&gt;\n    &lt;/el-form-item&gt;\n    &lt;el-form-item label=\"Activity zone\" prop=\"region\"&gt;\n      &lt;el-select v-model=\"ruleForm.region\" placeholder=\"Activity zone\"&gt;\n        &lt;el-option label=\"Zone one\" value=\"shanghai\" /&gt;\n        &lt;el-option label=\"Zone two\" value=\"beijing\" /&gt;\n      &lt;/el-select&gt;\n    &lt;/el-form-item&gt;\n    \n    &lt;el-form-item label=\"Activity time\" required&gt;\n      &lt;el-col :span=\"11\"&gt;\n        &lt;el-form-item prop=\"date1\"&gt;\n          &lt;el-date-picker\n            v-model=\"ruleForm.date1\"\n            type=\"date\"\n            aria-label=\"Pick a date\"\n            placeholder=\"Pick a date\"\n            style=\"width: 100%\"\n          /&gt;\n        &lt;/el-form-item&gt;\n      &lt;/el-col&gt;\n      &lt;el-col class=\"text-center\" :span=\"2\"&gt;\n        &lt;span class=\"text-gray-500\"&gt;-&lt;/span&gt;\n      &lt;/el-col&gt;\n      &lt;el-col :span=\"11\"&gt;\n        &lt;el-form-item prop=\"date2\"&gt;\n          &lt;el-time-picker\n            v-model=\"ruleForm.date2\"\n            aria-label=\"Pick a time\"\n            placeholder=\"Pick a time\"\n            style=\"width: 100%\"\n          /&gt;\n        &lt;/el-form-item&gt;\n      &lt;/el-col&gt;\n    &lt;/el-form-item&gt;\n\n  \n    &lt;el-form-item label=\"Resources\" prop=\"resource\"&gt;\n      &lt;el-radio-group v-model=\"ruleForm.resource\"&gt;\n        &lt;el-radio value=\"Sponsorship\"&gt;Sponsorship&lt;/el-radio&gt;\n        &lt;el-radio value=\"Venue\"&gt;Venue&lt;/el-radio&gt;\n      &lt;/el-radio-group&gt;\n    &lt;/el-form-item&gt;\n    &lt;el-form-item label=\"Activity form\" prop=\"desc\"&gt;\n      &lt;el-input v-model=\"ruleForm.desc\" type=\"textarea\" /&gt;\n    &lt;/el-form-item&gt;\n\n  &lt;/el-form&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\" setup&gt;\nimport { reactive, ref } from 'vue'\n\nimport type { FormInstance, FormRules } from 'element-plus'\n\ninterface RuleForm {\n  name: string\n  region: string\n\n  date1: string\n  date2: string\n\n\n  resource: string\n  desc: string\n}\n\n\nconst ruleFormRef = ref&lt;FormInstance&gt;()\nconst ruleForm = reactive&lt;RuleForm&gt;({\n  name: 'Hello',\n  region: '',\n  date1: '',\n  date2: '',\n  resource: '',\n  desc: '',\n})\n\n\n\nconst rules = reactive&lt;FormRules&lt;RuleForm&gt;&gt;({\n  name: [\n    { required: true, message: 'Please input Activity name', trigger: 'blur' },\n    { min: 3, max: 5, message: 'Length should be 3 to 5', trigger: 'blur' },\n  ],\n  region: [\n    {\n      required: true,\n      message: 'Please select Activity zone',\n      trigger: 'change',\n    },\n  ],\n  date1: [\n    {\n      type: 'date',\n      required: true,\n      message: 'Please pick a date',\n      trigger: 'change',\n    },\n  ],\n  date2: [\n    {\n      type: 'date',\n      required: true,\n      message: 'Please pick a time',\n      trigger: 'change',\n    },\n  ],\n  resource: [\n    {\n      required: true,\n      message: 'Please select activity resource',\n      trigger: 'change',\n    },\n  ],\n  desc: [\n    { required: true, message: 'Please input activity form', trigger: 'blur' },\n  ],\n})\n\nconst submitForm = async () =&gt; {\n  if (!ruleFormRef.value) {\n    console.error('ruleFormRef is not initialized')\n    return false\n  }\n  try {\n    const valid = await ruleFormRef.value.validate()\n    if (valid) {\n      // 验证通过后，就会可以把你需要的数据暴露出去\n      return Promise.resolve(ruleForm)\n    }\n  } catch (error) {\n    // 为啥submitForm中，valid的值是false会执行catch ？\n    // el-form 组件的 validate 方法的工作机制导致的。 validate 方法在表单验证失败时会抛出异常\n    console.error('err', error)\n    return false\n    /**\n     * 下面这样写为啥界面会报错呢？\n     * return Promise.reject(error)\n     * 当表单验证失败时，ruleFormRef.value.validate() 会抛出一个异常。\n     * 虽然你用了 try...catch 捕获这个异常，并且在 catch 块中通过 return Promise.reject(error) 返回了一个被拒绝的 Promise\n     * 但如果调用 submitForm 的地方没有正确地处理这个被拒绝的 Promise（即没有使用 .catch() 或者 await 来接收错误），\n     * 那么浏览器控制台就会显示一个 \"Uncaught (in promise)\" 错误。\n     * 在 catch 中再次 return Promise.reject(error) 是多余的， 直接return false\n     * */ \n    /**\n     * 如果你这样写\n     * throw error 直接抛出错误即可\n     * 那么就需要再调用submitForm的地方捕获异常\n     * */  \n  }\n}\n\ndefineExpose({\n  submitForm:submitForm\n})\n&lt;/script&gt;\n\n</code></pre>\n\n</div>\n<div id=\"MySignature\">\n    <div>\n            <h1 style=\"font-size: 24px;\"> 遇见问题，这是你成长的机会，如果你能够解决，这就是收获。 </h1>\n\t\t    <div style=\"padding: 10px;\">\n\t\t        作者：<a href=\"https://www.cnblogs.com/IwishIcould/\" target=\"_blank\">晚来南风晚相识</a> <br />\n\t\t        出处：<a href=\"https://www.cnblogs.com/IwishIcould/\">https://www.cnblogs.com/IwishIcould/</a> <br />\n                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>\n\t\t        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>\n\t\t        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>\n                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>\n\t\t\t\t<div style=\"display: flex;\">\n\t\t\t\t\t<div style=\"margin-right: 100px; text-align: center;\">\n\t\t\t\t\t\t<img src=\"//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179\" />\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t支付宝\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div style=\"text-align: center;\">\n\t\t\t\t\t\t<img src=\"//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg\" />\n\t\t\t\t\t\t<div>微信</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br />\n\t\t        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br />\n               \n\t\t    </div>\n           \n            \n\t\t</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 09:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/IwishIcould\">南风晚来晚相识</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2025总结篇，忙碌的日子里越过35岁，开启下一个征程",
      "link": "https://www.cnblogs.com/SunSpring/p/19469874",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/SunSpring/p/19469874\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 08:42\">\n    <span>2025总结篇，忙碌的日子里越过35岁，开启下一个征程</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>  2025农历新年已然接近，年初的工作计划任务基本也完成了，时不时翻看园子的我忙里偷闲记录一下过去的时光，以便多年后找寻曾经的记忆。</p>\n<h1 id=\"2024\">2024</h1>\n<p>  看了下博客更新，上一次更新还是在2024年一月份，也就是这一次，我更新完了重学一遍.net core系列，或者说是.net5+。因为那个时候core已经基本不再提了，算是给自己的.net 做了最后一次的复盘。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/993045/202601/993045-20260112093913561-1455228171.png\" /></p>\n<p>  翻看我之前的文章大概了解，我之前的工作基本上是做winform桌面开发的，因为我所在的部门是一个数据生产加工的部门，需要做一些桌面程序进行数据加工和处理，包括接一些扫描设备，这恰是winform的主战场。差不多5年没有做过.net后端开发了吧，当时怕自己技术落后所以又重学了一遍.net5+,包括DDD领域驱动的热门东西。但命运就是这般好笑，我最近两年基本连C#开发都没怎么做了,而最近几天看到园子里面的各种崛起，更是感概万千。回头看已经35的自己已经不再是当初那个风度翩翩的少年了，很多事情都是随事物、随时代发展的，我们要有向前的眼光，而不是踌躇不前，想起《一代宗师》里面宫羽田的一句台词“人要往远看，过了山，眼界就开阔了”。</p>\n<h1 id=\"2024-1\">2024</h1>\n<p>  时间拨回到2024年年初，按照高层的组织调整和战略计划进行部门拆分重组，由于我所在部门的经理和技术经理全都去了其他新成立的部门担任领导，我担起了原部门的技术负责人。虽然我们数据生产部门有100来号人，但是做程序的只有10多个人，所以技术这块管理的人不是太多好，之后就开始了新的工作征程，也就是为啥这2年我都没有写文章了，确实没有时间和精力。</p>\n<p>  由于部门重组，抽走了一部分原部门的人，需要新招一些人。而且由于调整的太急，部门交接一周就完成了，总共的交接文档只有各个仓库的地址和仓库里面的readme。从当初的小组负责人到部门负责人，2024年的一年需要转变角色，第一要管理团队，第二自己还要上刺刀冲锋。由于之前很多子系统都是java写的，并且多年的缝缝补补运行起来已经是不堪重负，所以向领导做了汇报，对整个系统进行重构和整合，基于比较小的变动和稳定，决定还是在原来的java体系内进行重构。之后就是组建团队、架构设计、写文档、画原型图。好在系统架构设计不需要去扣技术细节，所以java技术也不需要太精通（一家之言），整个系统采用了微服务的架构，应用端有web、winform客户端，用spring cloud作为基座，nacos做服务注册发现，配合自己设计的统一鉴权管理，整合各个业务系统到一个体系中。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/993045/202601/993045-20260112111159622-659126833.png\" /></p>\n<p>  之前管理过程都是基于showdoc文档，由于人数比较少大家很难用起来管理工具。虽然我们开发的是内部系统，但是访问量并发量，包括系统复杂度还是很高的，并且开发工作量比较大，所以项目最初我就引入了禅道进行部门项目管理。之后就是在上面写文档，做评审、分解任务、测试、验收、做全周期的开发流程。前期就是天天加班找技术方案，看原来系统的逻辑，想改造重构方案，并且还要画原型图（因为没有项目经理和产品经理角色）。后来到开发阶段还要带头重构核心服务和模块（需要更深入一点学习spring boot），好在java的语法和C#类似，但是实话说C#的语法还是吊打java的。在整个系统重构的过程中改造了一些痛点：比如原来的java定时任务scheduled，很多后台跑的任务都是以这种编码方式写的，每次要调整策略都需要改造代码停服重启，后面引入了xxjob任务调度的方式就灵活了很多。包括流程服务，早期是根据流程引擎activity改造的，每次重启要半个小时才能加载完，后面引入了camunda，整个系统改造都旨在解决实际维护和开发成本，完全是务实做法。</p>\n<p>  2024年年底系统正式切换上线，目前稳定运行1年，还在持续优化和改造。在2024年一年里对于技术的认识又有了一个翻天覆地的变化，以前写winform的时候没有搞过这么多中间件、系统集成。从微服务（spring cloud、阿里巴巴nacos）、统一鉴权系统（自己改造的）、分布式文件存储（minio）、分布式数据库（tidb）、任务调度（xxjob）、流程引擎（camunda）、分布式全文搜索引擎（ES）、hadoop、spark等等全都摸了一遍。原来视野之外有这么多精彩的内容，记得2024年年会上由于加班太多，还得了一个“最佳卷王”奖！</p>\n<h1 id=\"2025\">2025</h1>\n<p>  时间来到2025年，继续混战，由于工作的一些转变，不仅要学会管理团队，带动团队氛围和兄弟们一起完成平台的持续优化迎接新的任务输入，关心团队成员的状态，制定合理的工作计划任务，公平的绩效考核。对上还要汇报工作，争取时间，争取资源，协调外部合作，开各种会议。最重要的是要在部门本身的现状和领导的期望中找到平衡，期间多次遭到领导批评要打开格局、宏观思考（这部分挺纠结的，我也没有觉得自我格局有多低，有时候也不理解他们要的格局是什么），包括一些人的刻板印象，只能引用那句pua名言，在执行中理解，在理解中执行。</p>\n<p>  2025也是AI突飞猛进的一年，这一年有太多的技术和想法可以用AI去实现，所以我们又在原来基础上借助百度开源项目（飞桨PaddlePaddle）OCR进行改造升级，将数据生成流程中的部分数据通过训练检测后OCR自动提取。然后又去学习了一些AI的基础知识，当然只是了解一些基础的概念和原理，以方便和专门做AI的同事交流的时候在同一频道。</p>\n<p>  不知不觉，也即将35岁，回首过去仿佛轻舟已过万重山，对于未来我没有太多的焦虑，应该相信自己的韧性。我也绝非那种运气好家庭好的人，出生农村，一路受尽各种磨难，而今已足够从容，我时常在想这么多年的淬炼，即使我现在失业，我也相信能找到另外一条出路，在别的地方继续保持这份韧性。我从来不局限于搞什么技术，如果技术找不到工作，我或者会换一个行业，因为我的人生还需要更多的体验，目前略显单调。但是程序员的耐心、思考问题的思路、解决问题的方法我想在其他事情上面也是一份宝贵的经验吧。</p>\n<p>  2025年由于团队逐渐成熟，很多事情可以放心交给一些有担当的同学，我还趁媳妇儿娃儿暑假出门有空（娃儿我和我媳妇儿一手带大，现在8岁了可以夸张的说没让别人带过一天，其中的累只有自己知道！）复习考了一个出版专业中级资格证书，主要是我们是学术数据处理和再出版，因此这个证书是以考代学，抛开技术去了解业务和行业。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/993045/202601/993045-20260112154713746-264838872.png\" /></p>\n<h1 id=\"随想\">随想</h1>\n<p>  这两年给我最深的感受就是技术它本身并不是什么值钱的东西，没必要抱着什么技术不放，更何况AI加持，技术日新月异。恰恰是责任心、上进心、公心、沟通能力、表达能力、克服困难的能力才是我们的综合能力，这种能力放到任何地方同样适用。我现在最怕的就是做一个东西的时候很多人的第一情绪就是畏难情绪，东西还没了解清楚就开始强调这个东西有多大的难度，很多东西其实没有想象的那么难，很多个困难的关口我也是这样扛过来的，拿到事情第一要务是去了解去评估然后再回应。还有沟通能力，事情的反馈能力，做了事情要及时反馈，不管你搞好了没搞好，任务的阶段性成果，排查问题的阶段性回复，事情推进阶段性同步。如果在你没有及时结果的情况下这些东西一定要做好，不然团队或者用户根本不知道什么情况，至于你搞好后说用了什么牛逼的技术解决的，对比起，那不是别人关心的东西。所以我说这些东西远远比你专研什么技术更重要，说句不好听的，大多数岗位不需要你去做科研，也不需要什么高深的技术，把时间花在系统性和逻辑性稳健性的提升比你用奇淫技巧更好。</p>\n<h1 id=\"业余\">业余</h1>\n<p>   上次总结复盘还是2022年，这两年时光一晃而过，仿佛还在昨天。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/993045/202601/993045-20260112142839100-880997885.png\" /></p>\n<p>  当时写到发展了一些业余爱好，累的同时也要去释放和冲淡生活的无聊，这里绝不是什么心灵鸡汤，经常看到别人锻炼自侓的视频里面一堆弹幕或者评论说自己11点下班已经累的半死了，还要去锻炼，说别人是家庭好工作闲，虽然不排除这种情况，也能理解大家对这个世界有不公平的抱怨，大环境的抱怨，但是这些真不是主要因素（对于身心健康的人来说哈），我一年加班几百个小时还是公司下班打卡计时内的，平时还要带娃，有时候加完班我甚至直接从公司跑回去，大概有7-8公里的距离。那句话怎么说来着时间就想海绵里的水，挤一挤总是有的，所以2025年的跑步依然坚持着，跑了人生的首场半马，平时跑量很少，当天计划破2就行，赛道上还压着速度跑，如果之前有经验放开跑应该能破1：35的。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/993045/202601/993045-20260112145603592-1170949636.png\" /><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/993045/202601/993045-20260112143828854-1961766154.png\" /></p>\n<p>  去年还发展了一个爱好：钓鱼。基本上是夜钓，因为白天要照顾娃儿，辅导作业，这个爱好目前对身体还是不友好，熬夜不太行，最近有点上瘾T_T，还是要克制一下。另外告诉大家一个不好的消息，我用0.6的线钓了一条接近3斤的鲤鱼，遛了半个多小时哈哈哈。另外还学了路亚，晚上用双曲面亮片中了一条黑鱼，你能相信嘛。这也和我工作一样，什么都愿意去尝试，而不是所谓的台钓、路亚，甚至秋天我还去买了溪流竿，带老婆娃儿去溪流钓马口！<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/993045/202601/993045-20260112145711100-1373990262.png\" /><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/993045/202601/993045-20260112145451228-886334634.png\" /></p>\n<h1 id=\"2026\">2026</h1>\n<p>  2026没有什么期许和方向，不知道又会有哪些新的挑战和机遇，但予我而言我都照单全收，然后认真去对待便是，不贬低他人，不抬高自己，也希望大家都能早日找到自己内心的那份节奏和宁静。</p>\n\n</div>\n<div id=\"MySignature\">\n    <div id=\"Copyright\">\n<p>作者：<a href=\"https://www.cnblogs.com/SunSpring\" target=\"_blank\" title=\"author\">孙泉</a></p>\n<p>出处：<a href=\"https://www.cnblogs.com/SunSpring/p/19469874\" target=\"_blank\">https://www.cnblogs.com/SunSpring/p/19469874</a></p>\n<p>如果你喜欢文章欢迎点击推荐，你的鼓励对我很有用！</p>\n<p>本文版权归作者所有，转载需在文章页面明显位置给出原文链接。</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 08:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/SunSpring\">XSpringSun</a>&nbsp;\n阅读(<span id=\"post_view_count\">31</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "跨越技术鸿沟：Aspire 赋能 JavaScript 与 Node.js 开发者的深度生态融合",
      "link": "https://www.cnblogs.com/shanyou/p/19474912",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19474912\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 07:18\">\n    <span>跨越技术鸿沟：Aspire 赋能 JavaScript 与 Node.js 开发者的深度生态融合</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"跨越技术鸿沟aspire-赋能-javascript-与-nodejs-开发者的深度生态融合\"><strong>跨越技术鸿沟：Aspire 赋能 JavaScript 与 Node.js 开发者的深度生态融合</strong></h1>\n<h2 id=\"1-摘要\"><strong>1. 摘要</strong></h2>\n<p>在云原生应用开发的演进历程中，技术栈的异构性始终是一个核心特征。长期以来，企业级应用开发往往呈现出“双模IT”的特征：后端服务依赖于.NET 生态系统的强类型、高性能和企业级稳健性，而前端交互与部分微服务则广泛采用 JavaScript/TypeScript 生态系统的灵活性与庞大社区资源。这种多语言（Polyglot）架构虽然在功能上互补，但在开发运维（DevOps）的“内循环（Inner Loop）”中却制造了显著的摩擦。开发者常常需要在 Visual Studio 的调试器、复杂的 Docker Compose YAML 文件、散乱的 Shell 脚本以及手动维护的 .env 环境变量文件之间频繁切换。</p>\n<p>随着.NET Aspire 13.0 版本的发布，Microsoft 对这一痛点给出了系统性的回应。特别是对于 JavaScript 和 Node.js 开发者而言，Aspire 不再是一个仅限于.NET 内部的工具，而是一套标准化的基础设施即代码（Infrastructure as Code, IaC）解决方案。</p>\n<p>Aspire 通过三大核心支柱重塑了 JavaScript 开发体验：</p>\n<ol>\n<li><strong>代码化编排（Orchestration as Code）</strong>：利用 C# 的强类型特性构建 AppHost，替代脆弱的脚本和配置，统一管理 Node.js 应用、前端框架（React/Vue/Angular）以及依赖服务（Redis, PostgreSQL）的生命周期 2。</li>\n<li><strong>全链路可观测性（Universal Observability）</strong>：通过 OpenTelemetry 标准的深度集成，Aspire Dashboard 为 Node.js 应用提供了开箱即用的分布式追踪、日志聚合与指标监控，消除了跨语言调试的盲区 4。</li>\n<li><strong>标准化服务发现（Standardized Service Discovery）</strong>：通过 services__ 和 ConnectionStrings__ 等标准化环境变量注入机制，解决了本地开发与生产环境之间的配置漂移问题，使 JavaScript 应用能够无缝对接后端服务 1。</li>\n</ol>\n<p>本文将深入探讨从传统的 AddNpmApp 到现代化的 AddJavaScriptApp 的架构演进，详述 React、Angular、Vue 等主流框架的集成模式，并提供关于生产环境部署与云原生对接的战略性建议。</p>\n<h2 id=\"2-分布式系统开发中的多语言困境与破局\"><strong>2. 分布式系统开发中的多语言困境与破局</strong></h2>\n<p>要深刻理解.NET Aspire 对 JavaScript 开发者的价值，首先必须剖析当前混合技术栈开发中存在的系统性挑战。现代分布式系统不再是单一的单体应用，而是由前端单页应用（SPA）、后端 API 网关、微服务计算单元以及多种数据存储设施构成的复杂拓扑网络。</p>\n<h3 id=\"21-内循环中的碎片化摩擦\"><strong>2.1 “内循环”中的碎片化摩擦</strong></h3>\n<p>在传统的全栈开发流程中，一名开发者如果需要构建一个包含 React 前端、Node.js 中间层 BFF（Backend for Frontend）以及.NET Core 核心计算服务的应用，通常面临着极高的认知负荷与操作复杂性。</p>\n<ul>\n<li><strong>启动流程的割裂</strong>：开发者需要分别打开多个终端窗口。在一个窗口中运行 npm run dev 启动前端，在另一个窗口运行 dotnet run 启动后端，同时还需要确保 Docker 容器中的数据库已经就绪。这种手动的、非原子性的启动过程极易导致服务间的竞态条件（Race Conditions），例如 API 在数据库准备好之前就开始尝试连接，导致启动失败 。</li>\n<li><strong>配置管理的混乱</strong>：端口冲突是日常开发中的常态。当前端硬编码了 localhost:3000 而后端占用了同一端口，或者当多个微服务需要互相通信时，开发者必须手动维护一张复杂的端口映射表，并将其同步到各个项目的 .env 或 appsettings.json 文件中。一旦基础设施发生变化（如从本地 Redis 切换到云端实例），配置文件的同步往往滞后，引发“配置漂移”。</li>\n<li><strong>依赖关系的隐性化</strong>：在 docker-compose.yml 中，服务间的依赖关系通常通过 depends_on 定义，但这仅控制启动顺序，无法进行深度的健康检查（Health Checks）。Node.js 服务往往在 TCP 端口打开时就被认为“健康”，但实际上数据库连接池可能尚未初始化。</li>\n</ul>\n<p>.NET Aspire 的核心理念是将这种“编排逻辑”从静态的 YAML 配置提升为动态的 C# 代码。通过 AppHost 项目，开发者可以以编程方式定义“前端依赖于后端，后端依赖于数据库”，并由 Aspire 引擎自动处理启动顺序、端口分配与连接字符串注入，从而实现“一键 F5”启动整个分布式环境。</p>\n<h3 id=\"22-可观测性的数据孤岛\"><strong>2.2 可观测性的数据孤岛</strong></h3>\n<p>在多语言环境中，调试问题往往演变成一场“侦探游戏”。当用户在 React 前端点击按钮由于超时报错时，问题可能出在 Node.js 层的事件循环阻塞，也可能源于.NET 后端的数据库死锁。在缺乏统一可观测性平台的情况下，开发者只能分别查看浏览器的 Console 日志、Node.js 的终端输出以及.NET 的调试窗口。这些日志的时间戳不统一，且缺乏关联 ID（Trace ID），使得跨服务追踪几乎不可能。</p>\n<p>OpenTelemetry（OTEL）虽然提供了行业标准，但在不同语言栈中的配置门槛极高。JavaScript 开发者需要手动引入数十个 NPM 包来配置 Tracer、Meter 和 Logger。Aspire 通过提供预配置的 Dashboard 和标准化的 OTLP（OpenTelemetry Protocol）端点，极大地降低了这一门槛，使得 JavaScript 应用的遥测数据能够与.NET 服务的数据在同一视图中关联展示 。</p>\n<h3 id=\"23-开发与生产环境的鸿沟\"><strong>2.3 开发与生产环境的鸿沟</strong></h3>\n<p>本地开发环境往往采用直接连接（Direct Connection）模式，而生产环境则依赖于 Kubernetes 的 DNS 服务发现或 Azure 的托管标识。这种差异导致代码中充斥着大量的 if (process.env.NODE_ENV === 'production') 判断逻辑。Aspire 的服务发现机制旨在抹平这一差异，它在本地开发时通过环境变量模拟生产环境的服务发现行为，使得 JavaScript 代码在不同环境中可以保持一致 6。</p>\n<h2 id=\"3-架构演进从-nodejs-插件到-javascript-一等公民\"><strong>3. 架构演进：从 Node.js 插件到 JavaScript 一等公民</strong></h2>\n<p>.NET Aspire 对 JavaScript 生态的支持并非一蹴而就，而是经历了一次深刻的架构重构。理解这一演进过程，对于从早期预览版迁移到 Aspire 13.0 正式版的团队至关重要。</p>\n<h3 id=\"31-早期尝试addnodeapp-与-addnpmapp-的局限性\"><strong>3.1 早期尝试：AddNodeApp 与 AddNpmApp 的局限性</strong></h3>\n<p>在 Aspire 13 之前的版本（如 Aspire 8 或 9 预览版）中，JavaScript 支持主要通过 Aspire.Hosting.NodeJs NuGet 包提供。该阶段的设计思路主要围绕 Node.js 运行时展开，提供了两个核心 API：</p>\n<ul>\n<li><strong>AddNodeApp</strong>：用于直接执行特定的 JavaScript 文件（如 node server.js）。这种方式适用于简单的脚本任务，但难以应对现代前端工程复杂的构建流程 11。</li>\n<li><strong>AddNpmApp</strong>：用于执行 package.json 中定义的脚本（如 npm run start）。这在当时是集成前端应用的主要方式。</li>\n</ul>\n<p>然而，随着社区反馈的积累，这种设计的局限性逐渐暴露：</p>\n<ol>\n<li><strong>包管理器的强绑定</strong>：API 命名暗示了对 NPM（Node Package Manager）的强制依赖。然而，现代 JavaScript 生态中，Yarn 和 pnpm 因其更快的安装速度和对 Monorepo 的更好支持，已占据半壁江山。AddNpmApp 无法原生支持这些工具，开发者不得不通过复杂的参数绕过限制。</li>\n<li><strong>参数传递的僵化</strong>：在 AddNpmApp 中，命令行参数通常作为构造函数的一部分传递。这使得在运行时动态调整参数变得困难，也不符合流畅接口（Fluent Interface）的设计美学 。</li>\n<li><strong>构建语义的缺失</strong>：旧版 API 难以区分“开发模式”与“生产构建”。例如，Next.js 应用在启动前需要先执行构建过程生成 .next 目录，旧版 API 经常因跳过构建步骤而导致启动失败 。</li>\n</ol>\n<h3 id=\"32-现代范式aspire-13-与-addjavascriptapp\"><strong>3.2 现代范式：Aspire 13 与 AddJavaScriptApp</strong></h3>\n<p>Aspire 13.0 标志着 JavaScript 支持的全面成熟。微软将原来的 Aspire.Hosting.NodeJs 包重构并重命名为 Aspire.Hosting.JavaScript，引入了全新的 AddJavaScriptApp API 作为通用基础 11。这一变革不仅仅是命名的更改，更是底层设计哲学的转变。</p>\n<h4 id=\"321-智能包管理器探测intelligent-package-manager-detection\"><strong>3.2.1 智能包管理器探测（Intelligent Package Manager Detection）</strong></h4>\n<p>新的 AddJavaScriptApp 采用了一种“约定优于配置”的策略。当编排器启动时，它会自动扫描目标项目的目录结构，寻找锁文件（Lock Files）以确定应使用的包管理器：</p>\n<ul>\n<li>若发现 yarn.lock，自动使用 Yarn。</li>\n<li>若发现 pnpm-lock.yaml，自动使用 pnpm。</li>\n<li>若发现 package-lock.json，则使用 npm。</li>\n</ul>\n<p>这种智能探测机制消除了开发者在 C# 代码中显式指定包管理器的需求，使得 AppHost 代码更加简洁且与具体实现解耦 。</p>\n<h4 id=\"322-确定性构建与生命周期管理\"><strong>3.2.2 确定性构建与生命周期管理</strong></h4>\n<p>为了解决“在我机器上能运行”的问题，Aspire 13 引入了确定性安装（Deterministic Install）机制。在发布（Publish）模式下，Aspire 会自动使用各包管理器的严格安装命令（如 npm ci, yarn install --frozen-lockfile），确保依赖版本与锁文件完全一致。</p>\n<p>此外，生命周期管理被细分为明确的阶段：</p>\n<ul>\n<li><strong>开发阶段（Development）</strong>：默认执行 dev 脚本，支持热重载（HMR）。</li>\n<li><strong>发布阶段（Publishing）</strong>：默认执行 build 脚本，并自动生成优化的多阶段 Dockerfile 。</li>\n</ul>\n<h4 id=\"323-api-对比分析\"><strong>3.2.3 API 对比分析</strong></h4>\n<p>下表总结了从旧版到新版 API 的关键差异，展示了功能集的扩展与规范化。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">特性维度</th>\n<th style=\"text-align: left;\">Legacy (AddNpmApp)</th>\n<th style=\"text-align: left;\">Modern (AddJavaScriptApp)</th>\n<th style=\"text-align: left;\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>NuGet 包名</strong></td>\n<td style=\"text-align: left;\">Aspire.Hosting.NodeJs</td>\n<td style=\"text-align: left;\">Aspire.Hosting.JavaScript</td>\n<td style=\"text-align: left;\">旧包已废弃不再维护 16</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>包管理器支持</strong></td>\n<td style=\"text-align: left;\">仅限 NPM (默认)</td>\n<td style=\"text-align: left;\">自动探测 (NPM, Yarn, pnpm)</td>\n<td style=\"text-align: left;\">亦可通过 .WithYarn() 强制指定 13</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>参数传递方式</strong></td>\n<td style=\"text-align: left;\">构造函数参数 args</td>\n<td style=\"text-align: left;\">扩展方法 .WithArgs()</td>\n<td style=\"text-align: left;\">实现了关注点分离 1</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>构建策略</strong></td>\n<td style=\"text-align: left;\">基础容器化</td>\n<td style=\"text-align: left;\">智能多阶段 Dockerfile 生成</td>\n<td style=\"text-align: left;\">基于 .nvmrc 检测 Node 版本 15</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Vite 集成</strong></td>\n<td style=\"text-align: left;\">需社区工具包支持</td>\n<td style=\"text-align: left;\">原生内置 (AddViteApp)</td>\n<td style=\"text-align: left;\">包含端口自动协商与 HMR 优化 13</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>脚本自定义</strong></td>\n<td style=\"text-align: left;\">较为受限</td>\n<td style=\"text-align: left;\">.WithRunScript() / .WithBuildScript()</td>\n<td style=\"text-align: left;\">灵活适配不同环境需求 17</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"4-编排核心apphost-中的-javascript-集成实战\"><strong>4. 编排核心：AppHost 中的 JavaScript 集成实战</strong></h2>\n<p>在.NET Aspire 架构中，AppHost 项目扮演着“元应用（Meta-Application）”的角色。它不包含业务逻辑，而是用 C# 代码描述整个分布式系统的拓扑结构。对于 JavaScript 开发者而言，这意味着可以用一种强类型的、编译时检查的方式来替代脆弱的 YAML 配置。</p>\n<h3 id=\"41-基础资源注册\"><strong>4.1 基础资源注册</strong></h3>\n<p>集成一个现有的 JavaScript 应用（例如一个 React 前端或 Express 后端）的第一步是在 AppHost 的 Program.cs 中注册该资源。</p>\n<p>C#</p>\n<p>var builder = DistributedApplication.CreateBuilder(args);</p>\n<p>// 注册一个基于 Node.js 的前端项目<br />\n// \"frontend\" 是资源名称，将在服务发现中作为主机名使用<br />\n// \"../my-react-app\" 是包含 package.json 的相对路径<br />\nvar frontend = builder.AddJavaScriptApp(\"frontend\", \"../my-react-app\")<br />\n.WithHttpEndpoint(port: 3000, targetPort: 3000, name: \"http\") // 配置内部与外部端口映射<br />\n.WithExternalHttpEndpoints(); // 允许从宿主机浏览器访问</p>\n<p>在这段代码中：</p>\n<ul>\n<li><strong>资源标识</strong>：\"frontend\" 字符串不仅仅是一个标签，它在 Aspire 的内部 DNS 或服务发现机制中注册了一个条目。其他服务可以通过这个名称找到该应用。</li>\n<li><strong>网络配置</strong>：WithHttpEndpoint 定义了容器或进程监听的端口。targetPort 是 Node.js 进程实际监听的端口，而 port 是宿主机映射的端口。Aspire 会自动处理 Docker 的端口转发规则。</li>\n</ul>\n<h3 id=\"42-依赖注入与连接编排\"><strong>4.2 依赖注入与连接编排</strong></h3>\n<p>Aspire 最强大的功能之一是隐式连接管理。通过 .WithReference() 方法，可以将一个资源的连接信息注入到另一个资源的运行环境中。这种机制对于 Node.js 应用同样有效。</p>\n<p>假设我们有一个 Redis 缓存服务和一个 PostgreSQL 数据库，Node.js API 需要连接它们：</p>\n<p>C#</p>\n<p>// 定义基础设施资源<br />\nvar redis = builder.AddRedis(\"cache\");<br />\nvar postgres = builder.AddPostgres(\"db\").AddDatabase(\"maindb\");</p>\n<p>// 定义 Node.js 后端服务<br />\nvar nodeApi = builder.AddJavaScriptApp(\"node-api\", \"../backend\")<br />\n.WithReference(redis)      // 注入 Redis 连接串<br />\n.WithReference(postgres);  // 注入 Postgres 连接串</p>\n<p>当 nodeApi 启动时，Aspire 会计算出 redis 和 postgres 的连接字符串，并将其作为环境变量注入到 nodeApi 的进程中。</p>\n<ul>\n<li>对于 Redis，Node.js 进程会收到名为 ConnectionStrings__cache 的环境变量。</li>\n<li>对于 Postgres，会收到 ConnectionStrings__maindb。</li>\n</ul>\n<p>这种机制完全解耦了代码与配置。Node.js 代码无需知道数据库是在本地容器中运行，还是在 Azure 的托管服务中运行，它只需要读取标准的环境变量即可 。</p>\n<h3 id=\"43-脚本参数与自定义启动逻辑\"><strong>4.3 脚本参数与自定义启动逻辑</strong></h3>\n<p>实际的企业级应用往往需要复杂的启动参数。Aspire 13 废弃了构造函数传参，转而使用更清晰的流式 API。</p>\n<p><strong>场景</strong>：你需要以调试模式启动后端，并传递特定的标志位。</p>\n<p>C#</p>\n<p>var backend = builder.AddJavaScriptApp(\"backend\", \"../express-app\")<br />\n.WithRunScript(\"start:debug\") // 指定运行 package.json 中的 \"start:debug\" 脚本<br />\n.WithArgs(\"--verbose\", \"--region\", \"us-east\"); // 传递额外的命令行参数</p>\n<p>此外，Aspire 鼓励将复杂的参数逻辑封装在 package.json 的 scripts 节点中，保持 AppHost 的简洁性。例如，在 package.json 中定义 \"dev:custom\": \"vite --port 3000 --host\"，然后在 Aspire 中调用 .WithRunScript(\"dev:custom\") 1。这种做法尊崇了 JavaScript 生态的习惯，避免了在 C# 代码中硬编码过多的 Shell 命令逻辑。</p>\n<h2 id=\"5-服务发现与环境配置标准化\"><strong>5. 服务发现与环境配置标准化</strong></h2>\n<p>在微服务架构中，服务发现（Service Discovery）是核心难题。当.NET 后端服务的端口由 Aspire 动态分配时，Node.js 前端如何知道该向哪里发送请求？Aspire 提供了一套基于环境变量的标准协议。</p>\n<h3 id=\"51-services__-命名约定\"><strong>5.1 services__ 命名约定</strong></h3>\n<p>当 JavaScript 资源通过 .WithReference(apiProject) 引用了一个.NET 项目时，Aspire 会生成遵循特定命名规范的环境变量。在 Aspire 13 中，为了更好地支持多语言环境，这套规范进行了优化。</p>\n<p>假设 AppHost 配置如下：</p>\n<p>C#</p>\n<p>var api = builder.AddProject&lt;Projects.MyApi&gt;(\"api-service\");<br />\nvar frontend = builder.AddJavaScriptApp(\"frontend\", \"../web\").WithReference(api);</p>\n<p>Node.js 前端可以通过以下方式获取 API 的 URL：</p>\n<ol>\n<li><strong>标准化键名</strong>：环境变量通常格式为 services__{resourceName}__{endpointName}__{index}。\n<ul>\n<li>例如：services__api-service__https__0 可能对应 <a href=\"https://localhost:7234\" rel=\"noopener nofollow\" target=\"_blank\">https://localhost:7234</a>。</li>\n<li>Aspire 13 引入了更简化的别名机制，使得直接读取 process.env['services__api-service__https__0'] 成为可能 19。</li>\n</ul>\n</li>\n<li>代码实现示例：<br />\n在 Node.js 代码中（例如 Next.js 的 API Route 或 Express 服务）：<br />\nJavaScript<br />\nconst apiUrl = process.env['services__api-service__https__0'];<br />\nconst response = await fetch(`${apiUrl}/weatherforecast`);</li>\n</ol>\n<p>这种机制确保了无论是本地调试（Localhost 端口）还是生产部署（Kubernetes Service 名称），代码逻辑保持不变。在 Kubernetes 中，Aspire 的部署工具会将该环境变量的值设置为集群内的 DNS 名称（如 <a href=\"http://api-service.default.svc.cluster.local\" rel=\"noopener nofollow\" target=\"_blank\">http://api-service.default.svc.cluster.local</a>）6。</p>\n<h3 id=\"52-连接字符串的多态性\"><strong>5.2 连接字符串的多态性</strong></h3>\n<p>数据库连接字符串在不同语言中有不同的格式偏好。</p>\n<ul>\n<li><strong>.NET</strong> 习惯使用分号分隔的键值对：Server=myServer;Database=myDB;User Id=myUser;Password=myPassword;。</li>\n<li><strong>Node.js/Python</strong> 通常偏好 URI 格式：postgres://myUser:myPassword@myServer/myDB。</li>\n</ul>\n<p>Aspire 13 引入了连接属性的标准化暴露机制。资源现在会暴露 HostName, Port, UserName 等独立属性，以及针对特定语言优化的连接字符串格式（如 JdbcConnectionString 供 Java 使用）。对于 Node.js，Aspire 会尝试构建符合常见驱动（如 pg, mongoose）预期的连接字符串，或者开发者可以通过组合独立的环境变量来构建所需的格式 。这一改进极大地减少了在 JavaScript 代码中编写正则表达式来解析.NET 风格连接字符串的痛苦。</p>\n<h2 id=\"6-前端框架深度集成react-vue-angular-与-vite\"><strong>6. 前端框架深度集成：React, Vue, Angular 与 Vite</strong></h2>\n<p>现代前端开发高度依赖于构建工具链。Aspire 不仅仅是将前端视为一个静态文件服务器，而是深度介入其构建与调试过程，特别是针对 Vite 这一行业标准工具的优化。</p>\n<h3 id=\"61-addviteapp解决-hmr-难题\"><strong>6.1 AddViteApp：解决 HMR 难题</strong></h3>\n<p>Vite 的热模块替换（HMR）依赖于 WebSocket 连接。在容器化或编排环境中，如果端口映射不正确，HMR 往往会失效，导致开发者每次修改代码后都需要手动刷新浏览器。</p>\n<p>Aspire 13 将 AddViteApp 提升为核心功能。它不仅仅是 AddJavaScriptApp 的别名，还包含特定的逻辑来配置 Vite 的开发服务器：</p>\n<ol>\n<li><strong>端口自动协商</strong>：确保 Aspire 分配的外部端口与 Vite 配置的监听端口一致。</li>\n<li><strong>代理配置</strong>：它能自动处理 API 请求的转发，解决跨域（CORS）问题。</li>\n</ol>\n<p>C#</p>\n<p>// 专门针对 Vite 项目的优化集成<br />\nbuilder.AddViteApp(\"web-frontend\", \"../react-project\")<br />\n.WithReference(apiService) // 允许前端引用后端 API<br />\n.WithHttpEndpoint(port: 5173); // 锁定 Vite 默认端口</p>\n<h3 id=\"62-各框架集成细则\"><strong>6.2 各框架集成细则</strong></h3>\n<p>虽然 AddJavaScriptApp 是通用的，但在集成不同框架时仍需注意特定细节：</p>\n<ul>\n<li>React &amp; Vue (基于 Vite)：<br />\n推荐使用 AddViteApp。在代码中访问后端 API 地址时，通常需要在 vite.config.js 中配置 proxy，或者在 React 组件中通过 import.meta.env 读取由 Aspire 注入的环境变量（注意：Vite 默认只暴露以 VITE_ 开头的变量，因此可能需要在启动脚本中做一层转接，将 services__api 转为 VITE_API_URL）。</li>\n<li>Angular：<br />\nAngular CLI 依然使用 Webpack 或 esbuild。通常使用 AddJavaScriptApp 并指定 npm start。Angular 的 proxy.conf.json 可以配置为读取环境变量，从而将 /api 请求转发到 Aspire 管理的后端服务 。</li>\n<li>Next.js / Nuxt (服务端渲染 SSR)：<br />\nSSR 框架具有双重性：既有运行在浏览器端的代码，也有运行在 Node.js 服务端的代码。\n<ul>\n<li><strong>服务端（API Routes/Server Actions）</strong>：可以直接读取 process.env.services__... 与后端微服务或数据库通信。这是 Aspire 集成中最强大的场景，因为 Next.js 后端完全融入了内网服务网格。</li>\n<li><strong>客户端</strong>：依然需要通过环境变量暴露公共 URL。</li>\n<li><em>注意</em>：Next.js 构建时需要 .next 目录。使用旧版 AddNpmApp 时常因缺少构建步骤出错，新版 AddJavaScriptApp 在发布模式下会自动执行 npm run build，完美解决了此问题 。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"7-全栈可观测性opentelemetry-架构解析\"><strong>7. 全栈可观测性：OpenTelemetry 架构解析</strong></h2>\n<p>Aspire 的杀手级功能在于其统一的 Dashboard。对于 JavaScript 开发者，这意味着无需搭建 Jaeger、Prometheus 或 Grafana，即可在本地获得企业级的可观测性体验。</p>\n<h3 id=\"71-数据采集链路\"><strong>7.1 数据采集链路</strong></h3>\n<p>Aspire Dashboard 采用 OTLP（OpenTelemetry Protocol）接收数据。与.NET 应用通过 AddServiceDefaults() 自动注入遥测不同，Node.js 应用需要显式配置 OpenTelemetry SDK。</p>\n<p>数据流向如下：</p>\n<ol>\n<li><strong>Node.js 应用</strong>：集成 OTEL SDK，采集 Traces（追踪）、Metrics（指标）和 Logs（日志）。</li>\n<li><strong>OTLP Exporter</strong>：通过 gRPC 协议将数据发送出去。</li>\n<li><strong>Aspire 代理/Dashboard</strong>：接收数据并可视化。</li>\n</ol>\n<h3 id=\"72-nodejs-端配置实战\"><strong>7.2 Node.js 端配置实战</strong></h3>\n<p>要在 Node.js 中接入 Aspire，关键在于配置 OTLP Exporter 指向 Aspire 提供的端点。Aspire 会自动注入环境变量 OTEL_EXPORTER_OTLP_ENDPOINT（通常为 <a href=\"http://localhost:4317\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:4317</a>）。</p>\n<p><strong>必需的 NPM 依赖</strong>：</p>\n<p>Bash</p>\n<p>npm install @opentelemetry/sdk-node \\<br />\n@opentelemetry/auto-instrumentations-node \\<br />\n@opentelemetry/exporter-trace-otlp-grpc \\<br />\n@opentelemetry/exporter-metrics-otlp-grpc \\<br />\n@opentelemetry/exporter-logs-otlp-grpc</p>\n<p><strong>初始化代码（instrumentation.js）</strong> 22：</p>\n<p>JavaScript</p>\n<details>\n点击查看代码\n<pre><code>\nconst { NodeSDK } \\= require('@opentelemetry/sdk-node');  \nconst { OTLPTraceExporter } \\= require('@opentelemetry/exporter-trace-otlp-grpc');  \nconst { OTLPMetricExporter } \\= require('@opentelemetry/exporter-metrics-otlp-grpc');  \nconst { OTLPLogExporter } \\= require('@opentelemetry/exporter-logs-otlp-grpc');  \nconst { getNodeAutoInstrumentations } \\= require('@opentelemetry/auto-instrumentations-node');\n\nconst sdk \\= new NodeSDK({  \n  serviceName: 'node-service', // 服务名称，将在 Dashboard 中显示  \n  traceExporter: new OTLPTraceExporter(), // 自动读取 OTEL\\_EXPORTER\\_OTLP\\_ENDPOINT  \n  metricExporter: new OTLPMetricExporter(),  \n  logExporter: new OTLPLogExporter(),  \n  instrumentations: \\[getNodeAutoInstrumentations()\\], // 自动采集 HTTP, Express, PG 等库的数据  \n});\n\nsdk.start();\n</code></pre>\n</details>\n<p>通过这段代码，Node.js 应用发出的每一个 HTTP 请求、数据库查询都会生成 Trace Span，并自动发送到 Dashboard。开发者可以在 Dashboard 中看到一个请求从 React 前端发出，经过 Node.js 中间层，最终到达.NET 后端的完整瀑布图（Waterfall View）24。</p>\n<h3 id=\"73-独立模式standalone-dashboard\"><strong>7.3 独立模式（Standalone Dashboard）</strong></h3>\n<p>对于纯 JavaScript 团队，即便不使用.NET 编排功能，也可以利用 Aspire Dashboard。Aspire Dashboard 可以作为独立的 Docker 容器运行，这对于仅需要监控工具的 Node.js 开发者极具吸引力。</p>\n<p><strong>运行命令</strong> 4：</p>\n<p>Bash</p>\n<p>docker run --rm -it -d \\<br />\n-p 18888:18888 \\<br />\n-p 4317:18889 \\<br />\n--name aspire-dashboard \\<br />\nmcr.microsoft.com/dotnet/aspire-dashboard:latest</p>\n<p>在此模式下，JavaScript 开发者只需将本地环境变量 OTEL_EXPORTER_OTLP_ENDPOINT 设置为 <a href=\"http://localhost:4317\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:4317</a>，即可利用这个免费、轻量且功能强大的可视化工具，无需部署复杂的 ELK 或 Prometheus 栈 。</p>\n<h2 id=\"8-生产部署与云原生对接\"><strong>8. 生产部署与云原生对接</strong></h2>\n<p>“内循环”的优化最终是为了服务于“外循环”的部署。Aspire 的设计目标是实现从本地开发到云端部署的平滑过渡。</p>\n<h3 id=\"81-自动化-dockerfile-生成\"><strong>8.1 自动化 Dockerfile 生成</strong></h3>\n<p>在将 JavaScript 应用部署到 Kubernetes 或 Azure Container Apps 时，编写 Dockerfile 是一项繁琐且容易出错的工作（例如忘记复制锁文件导致版本不一致，或未进行多阶段构建导致镜像过大）。</p>\n<p>Aspire 13 在执行发布命令（dotnet publish）时，会分析 JavaScript 项目：</p>\n<ul>\n<li>读取 .nvmrc 或 package.json 中的 engines 字段确定 Node.js 版本。</li>\n<li>自动生成多阶段（Multi-stage）Dockerfile：\n<ol>\n<li><strong>构建阶段</strong>：安装全部依赖，运行 npm run build。</li>\n<li><strong>运行阶段</strong>：仅复制构建产物（如 dist 或 .next）和生产依赖（node_modules），通过 node 命令启动 。</li>\n</ol>\n</li>\n</ul>\n<p>这种自动化机制确保了生产镜像遵循最佳实践，同时极大地降低了前端开发者对容器技术的认知门槛。</p>\n<h3 id=\"82-azure-developer-cli-azd-集成\"><strong>8.2 Azure Developer CLI (azd) 集成</strong></h3>\n<p>微软提供的 azd 工具深度集成了 Aspire 模型。当开发者执行 azd up 时：</p>\n<ol>\n<li><strong>资源映射</strong>：Aspire 模型中的 AddRedis 会被映射为 Azure Redis Cache 实例，AddJavaScriptApp 映射为 Azure Container Apps 服务。</li>\n<li><strong>配置注入</strong>：本地开发时的环境变量注入逻辑在云端依然有效。azd 会自动将云端数据库的连接字符串配置到容器应用的 Secret 中，并作为环境变量注入。</li>\n<li><strong>服务发现</strong>：在 Azure Container Apps 环境中，服务间通过内部 DNS 通信，Aspire 确保注入的 services__ 变量指向正确的云端 DNS 名称 6。</li>\n</ol>\n<p>这意味着，开发者在本地编写的 process.env 代码，无需任何修改即可在 Azure 云端正常工作。</p>\n<h2 id=\"9-结论与展望\"><strong>9. 结论与展望</strong></h2>\n<p>.NET Aspire 13.0 的发布标志着微软开发工具链的一次重要战略转型。通过将 JavaScript 提升为一等公民，Aspire 承认并拥抱了多语言开发的现实。</p>\n<p>对于 <strong>JavaScript 开发者</strong>而言，Aspire 提供了：</p>\n<ul>\n<li><strong>结构化</strong>：用类型安全的代码替代混乱的脚本，管理复杂的微服务依赖。</li>\n<li><strong>透明化</strong>：通过 OpenTelemetry 和 Dashboard，让黑盒般的跨服务调用变得清晰可见。</li>\n<li><strong>一致性</strong>：统一了本地与生产环境的服务发现与配置模式，消除了环境差异带来的 Bug。</li>\n</ul>\n<p>尽管引入 C# 编写的 AppHost 对纯 JS 团队可能存在一定的学习曲线，但其带来的架构治理收益——特别是在涉及数据库、缓存、消息队列等复杂依赖的场景下——是巨大的。Aspire 不仅仅是一个工具，它为构建可维护、可观测、易于部署的云原生应用提供了一套标准化的参考架构。</p>\n<p>随着社区工具包（Community Toolkit）对 Deno、Bun 等新兴运行时的支持不断扩展 ，以及对 Python 等数据科学语言支持的深化，.NET Aspire 正逐步演变为一个通用的多语言云原生应用中枢，为不同技术背景的开发者搭建起协作的桥梁。</p>\n<h4 id=\"引用的文章\"><strong>引用的文章</strong></h4>\n<ol>\n<li>What's new in Aspire 13, <a href=\"https://aspire.dev/whats-new/aspire-13/\" rel=\"noopener nofollow\" target=\"_blank\">https://aspire.dev/whats-new/aspire-13/</a></li>\n<li>.NET Aspire 5: Orchestration and Service Discovery <a href=\"https://www.daveabrock.com/2025/09/16/net-aspire-5-orchestration-and-service-discovery/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.daveabrock.com/2025/09/16/net-aspire-5-orchestration-and-service-discovery/</a></li>\n<li>Building a Full-Stack App with React and Aspire: A Step-by-Step ..., <a href=\"https://devblogs.microsoft.com/dotnet/new-aspire-app-with-react/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/new-aspire-app-with-react/</a></li>\n<li>Standalone Aspire dashboard | Aspire <a href=\"https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/dashboard/standalone\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/dashboard/standalone</a></li>\n<li>Build Better Apps with .NET Aspire - Complete Beginner's Guide &amp; Tutorial <a href=\"https://www.youtube.com/watch?v=e36NEWqO7GQ\" rel=\"noopener nofollow\" target=\"_blank\">https://www.youtube.com/watch?v=e36NEWqO7GQ</a></li>\n<li>Deploy an Aspire project to Azure Container Apps using `azd` (in-depth guide),<a href=\"https://learn.microsoft.com/en-us/dotnet/aspire/deployment/azd/aca-deployment-azd-in-depth\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/dotnet/aspire/deployment/azd/aca-deployment-azd-in-depth</a></li>\n<li>Aspire: The Cloud-Native Framework That Finally Makes Distributed .NET Development Easy <a href=\"https://dev.to/mashrulhaque/its-4-pm-and-your-microservices-still-wont-start-a-guide-to-net-aspire-4h7b\" rel=\"noopener nofollow\" target=\"_blank\">https://dev.to/mashrulhaque/its-4-pm-and-your-microservices-still-wont-start-a-guide-to-net-aspire-4h7b</a></li>\n<li>Simplifying Distributed Systems: Jason Taylor Shows How .NET Aspire Makes the Complex Feel Effortless <a href=\"https://blog.jetbrains.com/dotnet/2025/10/29/simplifying-distributed-systems-dotnet-aspire-jason-taylor/\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.jetbrains.com/dotnet/2025/10/29/simplifying-distributed-systems-dotnet-aspire-jason-taylor/</a></li>\n<li>Client Side JavaScript OpenTelemetry Integration with .NET Aspire <a href=\"https://www.youtube.com/watch?v=9Cn5WDvmWtg\" rel=\"noopener nofollow\" target=\"_blank\">https://www.youtube.com/watch?v=9Cn5WDvmWtg</a></li>\n<li>.Net Aspire Automatic Naming when Deploying to Azure Container Apps : r/dotnet - Reddit <a href=\"https://www.reddit.com/r/dotnet/comments/1g8r70o/net_aspire_automatic_naming_when_deploying_to/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.reddit.com/r/dotnet/comments/1g8r70o/net_aspire_automatic_naming_when_deploying_to/</a></li>\n<li>[Breaking change]: Aspire.Hosting.NodeJs library breaks · Issue #5444 · dotnet/docs-aspire, <a href=\"https://github.com/dotnet/docs-aspire/issues/5444\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/dotnet/docs-aspire/issues/5444</a></li>\n<li>JavaScriptHostingExtensions Class (Aspire.Hosting) - Microsoft Learn,  <a href=\"https://learn.microsoft.com/en-us/dotnet/api/aspire.hosting.javascripthostingextensions?view=dotnet-aspire-13.0\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/dotnet/api/aspire.hosting.javascripthostingextensions?view=dotnet-aspire-13.0</a></li>\n<li>Aspire 13 - Aspireify anything | Aspire Blog - Microsoft Dev Blogs,   <a href=\"https://devblogs.microsoft.com/aspire/aspire13/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/aspire/aspire13/</a></li>\n<li>AddNpmApp does not build Next.js app before starting — missing '.next' build directory · Issue #10045 · dotnet/aspire <a href=\"https://github.com/dotnet/aspire/issues/10045\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/dotnet/aspire/issues/10045</a></li>\n<li>Aspire 13 Launches: A New Era for Polyglot Cloud-Native Development - HexMaster's Blog,  <a href=\"https://hexmaster.nl/posts/aspire-13-launches-a-new-era/\" rel=\"noopener nofollow\" target=\"_blank\">https://hexmaster.nl/posts/aspire-13-launches-a-new-era/</a></li>\n<li>Aspire.Hosting.NodeJs 9.5.2 - NuGet, 访问时间为 一月 13, 2026， <a href=\"https://www.nuget.org/packages/Aspire.Hosting.NodeJS\" rel=\"noopener nofollow\" target=\"_blank\">https://www.nuget.org/packages/Aspire.Hosting.NodeJS</a></li>\n<li>JavaScript integration | Aspire <a href=\"https://aspire.dev/integrations/frameworks/javascript/\" rel=\"noopener nofollow\" target=\"_blank\">https://aspire.dev/integrations/frameworks/javascript/</a></li>\n<li>How to Deploy a .NET + React Full Stack App to Azure with Aspire 13 <a href=\"https://juliocasal.com/blog/how-to-deploy-a-net-react-full-stack-app-to-azure-with-aspire-13\" rel=\"noopener nofollow\" target=\"_blank\">https://juliocasal.com/blog/how-to-deploy-a-net-react-full-stack-app-to-azure-with-aspire-13</a></li>\n<li>Using Node/Express (like Astro) with .NET Aspire (AstroAspire Basic)  <a href=\"https://agramont.net/blog/astroaspire-using-node-express-astro-with-dotnet-aspire/\" rel=\"noopener nofollow\" target=\"_blank\">https://agramont.net/blog/astroaspire-using-node-express-astro-with-dotnet-aspire/</a></li>\n<li>What's new in Aspire 13.1,  <a href=\"https://aspire.dev/whats-new/aspire-13-1/\" rel=\"noopener nofollow\" target=\"_blank\">https://aspire.dev/whats-new/aspire-13-1/</a></li>\n<li>.NET Aspire with React/NextJS (or any other Node.js) | by Bruno Adao - Medium,  <a href=\"https://medium.com/@adamtrip/net-aspire-with-react-nextjs-or-any-other-node-js-ef99f398815f\" rel=\"noopener nofollow\" target=\"_blank\">https://medium.com/@adamtrip/net-aspire-with-react-nextjs-or-any-other-node-js-ef99f398815f</a></li>\n<li>Aspire Documentation 20250421 | PDF | C Sharp (Programming Language) - <a href=\"https://www.scribd.com/document/853097207/NET-Aspire-Documentation-20250421\" rel=\"noopener nofollow\" target=\"_blank\">https://www.scribd.com/document/853097207/NET-Aspire-Documentation-20250421</a></li>\n<li>Use the Aspire dashboard with Node.js apps,<a href=\"https://aspire.dev/dashboard/standalone-for-nodejs/\" rel=\"noopener nofollow\" target=\"_blank\">https://aspire.dev/dashboard/standalone-for-nodejs/</a></li>\n<li>Microsoft Orleans and .NET Aspire <a href=\"https://www.mishraajay.in/blog/orleans-aspire\" rel=\"noopener nofollow\" target=\"_blank\">https://www.mishraajay.in/blog/orleans-aspire</a></li>\n<li>Observing Spin Apps with OpenTelemetry and the .NET Aspire Dashboard, <a href=\"https://dev.to/fermyon/observing-spin-apps-with-opentelemetry-and-the-net-aspire-dashboard-3mmp\" rel=\"noopener nofollow\" target=\"_blank\">https://dev.to/fermyon/observing-spin-apps-with-opentelemetry-and-the-net-aspire-dashboard-3mmp</a></li>\n<li>Visualize OpenTelemetry Data in Seconds with Aspire Dashboard for JavaScript Developers <a href=\"https://www.youtube.com/watch?v=YKraN1ZETpw\" rel=\"noopener nofollow\" target=\"_blank\">https://www.youtube.com/watch?v=YKraN1ZETpw</a></li>\n<li>CommunityToolkit/Aspire: A community project with additional components and extensions for Aspire <a href=\"https://github.com/CommunityToolkit/Aspire\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/CommunityToolkit/Aspire</a></li>\n</ol>\n\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 07:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">85</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2026 年 PHP 8.4 依然重要：跳到 8.5 之前你该掌握的特性",
      "link": "https://www.cnblogs.com/catchadmin/p/19474910",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19474910\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 07:17\">\n    <span>2026 年 PHP 8.4 依然重要：跳到 8.5 之前你该掌握的特性</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"2026-年-php-84-依然重要跳到-85-之前你该掌握的特性\">2026 年 PHP 8.4 依然重要：跳到 8.5 之前你该掌握的特性</h1>\n<h2 id=\"为什么-php-84-在-2026-年仍然相关\">为什么 PHP 8.4 在 2026 年仍然相关</h2>\n<p>如果你的团队计划\"今年上 PHP 8.5\"，很可能会先聊到 PHP 8.4——不管你愿不愿意。</p>\n<p>无聊但重要的原因是：支持窗口。</p>\n<p>根据官方 PHP 支持时间表，PHP 8.4（2024 年 11 月 21 日发布）仍处于活跃支持期，直到 2026 年 12 月 31 日，安全修复持续到 2028 年 12 月 31 日。</p>\n<p>这让 8.4 在 2026 年初成为一个合理的基线，特别是对于从 8.2/8.3 升级、想避免\"跳太远、坏太多\"的团队。</p>\n<p>但有意思的原因是技术层面的：PHP 8.4 悄悄重塑了日常 OOP 风格。它引入的特性减少了样板代码，让\"干净的 DTO\"和\"安全的领域对象\"更像是语言原生支持的东西：</p>\n<ul>\n<li>Property hooks（头条功能）</li>\n<li>非对称属性可见性（读起来是 public，写起来是 private）</li>\n<li>一些生活质量改进（数组、弃用工具、DOM 等）</li>\n</ul>\n<p>如果你在 8.4 上内化了这些，升级到 8.5 往往感觉像\"添加一些好东西\"，而不是\"把整个 PHP 写法现代化\"。</p>\n<p>所以这篇文章可以当作基线知识：如果你还没上 8.4，这是你为 8.5 做准备应该知道的——但不会变成完整的升级清单。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/php-3-biggest-strengths-2026\" rel=\"noopener nofollow\" target=\"_blank\">原文 2026 年 PHP 8.4 依然重要：跳到 8.5 之前你该掌握的特性</a></p>\n<h2 id=\"property-hooks是什么为什么重要什么时候值得用\">Property hooks：是什么、为什么重要、什么时候值得用</h2>\n<p>Property hooks 是 PHP 8.4 引入的。</p>\n<p>它让你可以直接在属性上附加 get 和/或 set 逻辑。可以理解为\"访问器方法\"，但不需要写：</p>\n<ul>\n<li><code>getFoo(): string</code></li>\n<li><code>setFoo(string $foo): void</code></li>\n<li>加上私有的 backing 字段</li>\n<li>加上在构造函数和工厂里重复的额外不变量</li>\n</ul>\n<h3 id=\"心智模型\">心智模型</h3>\n<p>带 hook 的属性仍然是属性。你还是用正常方式读写它：</p>\n<pre><code class=\"language-php\">$user-&gt;email = \"  ADMIN@EXAMPLE.COM  \";\necho $user-&gt;email;\n</code></pre>\n<p>但在底层，引擎把读写路由到 hook。</p>\n<p>完整形式的 hook 长这样：</p>\n<pre><code class=\"language-php\">class Example\n{\n    private bool $modified = false;\n    public string $foo = 'default value' {\n        get {\n            if ($this-&gt;modified) {\n                return $this-&gt;foo . ' (modified)';\n            }\n            return $this-&gt;foo;\n        }\n        set(string $value) {\n            $this-&gt;foo = strtolower($value);\n            $this-&gt;modified = true;\n        }\n    }\n}\n</code></pre>\n<p>这是手册里的示例，展示了核心思想：保留属性语法，同时获得集中化的行为。</p>\n<h3 id=\"backed-property-vs-virtual-property容易漏掉的部分\">Backed property vs virtual property（容易漏掉的部分）</h3>\n<p>Property hooks 可以创建两\"种\"属性：</p>\n<ul>\n<li><strong>Backed property</strong>：在对象中有存储的内存（普通属性），hook 操作 backing value。</li>\n<li><strong>Virtual property</strong>：没有 backing 存储——是派生/计算的，像伪装成 <code>$area</code> 的 <code>getArea()</code>。</li>\n</ul>\n<p>手册解释说，如果两个 hook 都没有用精确语法引用 <code>$this-&gt;propertyName</code>，属性就是 virtual 的，virtual 属性不占内存空间。</p>\n<p>一个干净的 virtual property 示例：</p>\n<pre><code class=\"language-php\">class Rectangle\n{\n    public function __construct(\n        public int $h,\n        public int $w,\n    ) {}\n    public int $area {\n        get =&gt; $this-&gt;h * $this-&gt;w;\n    }\n}\n$r = new Rectangle(4, 5);\necho $r-&gt;area;     // 20\n$r-&gt;area = 30;     // Error: no set operation defined\n</code></pre>\n<p>这基本上是一个计算型 getter——但读起来像属性。</p>\n<h3 id=\"最有用的实际模式\">最有用的实际模式</h3>\n<p>专注于真正能减少 bug 和样板代码的模式。</p>\n<p><strong>模式 A：在 setter 中规范化输入（trim、大小写转换等）</strong></p>\n<p>经典场景：邮箱、用户名、slug。你想接受杂乱输入但存储规范化的值。</p>\n<pre><code class=\"language-php\">final class UserProfile\n{\n    public string $email {\n        set =&gt; strtolower(trim($value));\n    }\n}\n</code></pre>\n<p>在简写形式中，表达式结果成为存储的 backing value。</p>\n<p>这已经很有用了，但生产代码通常还需要验证。</p>\n<p><strong>模式 B：在边界处验证不变量（尽早抛出）</strong></p>\n<p>例如，强制\"用户名至少 3 个字符\"并规范化空格。</p>\n<pre><code class=\"language-php\">final class UserProfile\n{\n    public string $username {\n        set {\n            $v = trim($value);\n            if ($v === '') {\n                throw new InvalidArgumentException('Username cannot be empty.');\n            }\n            if (strlen($v) &lt; 3) {\n                throw new InvalidArgumentException('Username is too short.');\n            }\n            $this-&gt;username = $v;\n        }\n    }\n}\n</code></pre>\n<p>这让不变量紧挨着属性，而不是散落在控制器、请求验证器和构造函数各处。</p>\n<p>PHP 迁移指南甚至展示了类似的\"验证然后赋值\"模式。</p>\n<p><strong>模式 C：派生/virtual 的\"展示\"属性</strong></p>\n<p>常见的 DTO 需求：暴露 fullName 但不存储它。</p>\n<pre><code class=\"language-php\">final class Person\n{\n    public function __construct(\n        public string $first,\n        public string $last,\n    ) {}\n    public string $fullName {\n        get =&gt; \"{$this-&gt;first} {$this-&gt;last}\";\n    }\n}\n</code></pre>\n<p>Virtual property 最适合的场景：</p>\n<ul>\n<li>确定性的，</li>\n<li>计算成本低，</li>\n<li>你永远不想\"set\"它们。</li>\n</ul>\n<p>对于历史上滥用魔术 <code>__get()</code> 的团队，这是一个干净的基线。</p>\n<p><strong>模式 D：\"计算一次，之后缓存\"（谨慎使用）</strong></p>\n<p>有时计算值很昂贵（解析、构建对象）。你可以在对象内部缓存它。</p>\n<pre><code class=\"language-php\">final class RequestContext\n{\n    private ?array $cachedClaims = null;\n    public function __construct(\n        public string $jwt,\n    ) {}\n    public array $claims {\n        get {\n            if ($this-&gt;cachedClaims !== null) {\n                return $this-&gt;cachedClaims;\n            }\n            // 假设 parseJwt() 做签名检查、base64 解码等\n            $this-&gt;cachedClaims = $this-&gt;parseJwt($this-&gt;jwt);\n            return $this-&gt;cachedClaims;\n        }\n    }\n    private function parseJwt(string $jwt): array\n    {\n        // ...\n        return [];\n    }\n}\n</code></pre>\n<p>这很方便，但也是 hook 可能变得\"太魔法\"的地方。如果你把重活藏在 <code>$obj-&gt;claims</code> 后面，可能会让调用者意外。只在人体工学真正超过成本时使用这个模式。</p>\n<h3 id=\"hooks--构造函数提升一个微妙的坑\">Hooks + 构造函数提升：一个微妙的坑</h3>\n<p>PHP 允许在提升的属性上使用 hook，但有一个重要规则：传给构造函数的值必须匹配属性声明的类型——不管你的 set hook 可能接受什么。</p>\n<p>也就是说你可以写：</p>\n<ul>\n<li>属性类型：<code>DateTimeInterface</code></li>\n<li>set hook 接受：<code>string|DateTimeInterface</code></li>\n</ul>\n<p>…但如果你用提升，构造函数参数类型仍然是 <code>DateTimeInterface</code>。</p>\n<p>如果你真的想\"构造函数里也允许 string\"，你可能需要工厂或非提升的构造函数参数。</p>\n<h3 id=\"重要限制property-hooks-不能和-readonly-一起用\">重要限制：property hooks 不能和 readonly 一起用</h3>\n<p>这对喜欢不可变对象的团队很重要。</p>\n<p>手册明确说明：property hooks 与 readonly 属性不兼容。</p>\n<p>所以如果你的风格是\"到处都是不可变值对象\"，hooks 不能替代那个。Hooks 更适合的场景是：</p>\n<ul>\n<li>DTO 和 request/response 对象</li>\n<li>配置对象</li>\n<li>内部可变但需要护栏的领域对象</li>\n</ul>\n<p>（下一节会讲用非对称可见性实现\"半不可变 DTO\"。）</p>\n<h3 id=\"另一个限制引用和间接修改可能坑你\">另一个限制：引用和间接修改可能坑你</h3>\n<p>Hooks 拦截读写，这可能与引用冲突——特别是数组元素写入：</p>\n<pre><code class=\"language-php\">$obj-&gt;arr['k'] = 'v';\n</code></pre>\n<p>文档警告说，获取引用或间接修改可能绕过 set hook，并概述了约束（如 <code>&amp;get</code> 行为）和允许的情况。</p>\n<p>实用指南：</p>\n<ul>\n<li>如果调用者经常修改元素，避免在数组属性上用 hook。</li>\n<li>优先用\"替换整个数组\"模式（<code>$obj-&gt;tags = [...$obj-&gt;tags, $newTag];</code>），这表现得像普通 set。</li>\n</ul>\n<h3 id=\"什么时候不应该用-property-hooks\">什么时候不应该用 property hooks</h3>\n<p>Hooks 很棒……直到它们不是。在以下情况避免：</p>\n<ul>\n<li>\"hook body\"开始做真正的编排（IO、网络调用、日志）。</li>\n<li>调试变得不清晰（\"为什么读这个属性会访问数据库？\"）。</li>\n<li>你的团队需要关键行为有显式的调用点。</li>\n</ul>\n<p>一个有用的规则：property hooks 最适合实现<strong>局部不变量和局部转换</strong>——真正属于属性本身的逻辑。</p>\n<h2 id=\"其他影响日常工作的-php-84-特性挑你真正会用的\">其他影响日常工作的 PHP 8.4 特性（挑你真正会用的）</h2>\n<p>PHP 8.4 不只有 hooks。专注于以下类型的特性：</p>\n<ul>\n<li>减少样板代码，</li>\n<li>减少 bug，</li>\n<li>或让代码更容易理解。</li>\n</ul>\n<h3 id=\"特性非对称属性可见性public-读受限写\">特性：非对称属性可见性（public 读、受限写）</h3>\n<p>非对称可见性让你可以为读和写设置不同的可见性。</p>\n<p>示例：</p>\n<pre><code class=\"language-php\">final class Money\n{\n    public function __construct(\n        public private(set) string $currency,\n        public private(set) int $cents,\n    ) {}\n}\n</code></pre>\n<p>调用者可以读：</p>\n<pre><code class=\"language-php\">echo $m-&gt;cents;\n</code></pre>\n<p>但不能写：</p>\n<pre><code class=\"language-php\">$m-&gt;cents = 500; // Error outside the class\n</code></pre>\n<p>迁移指南阐明了规则：第一个可见性是 get-visibility，第二个控制 set-visibility，get visibility 不能比 set visibility 更窄。</p>\n<p>这对 DTO 很重要：它给你一种\"大部分不可变\"的风格，而不必采用完整的值对象方法。</p>\n<h3 id=\"组合非对称可见性--property-hooks\">组合非对称可见性 + property hooks</h3>\n<p>这个组合经常替代经典的\"私有属性 + getter + setter\"。</p>\n<pre><code class=\"language-php\">final class UserInput\n{\n    public private(set) string $email {\n        set =&gt; strtolower(trim($value));\n    }\n    public private(set) string $name {\n        set {\n            $v = trim($value);\n            if ($v === '') {\n                throw new InvalidArgumentException('Name is required.');\n            }\n            $this-&gt;name = $v;\n        }\n    }\n}\n</code></pre>\n<ul>\n<li>读是 public（对模板、序列化器、调试友好）</li>\n<li>写是受控的（对不变量友好）</li>\n<li>样板代码保持低</li>\n</ul>\n<h3 id=\"特性新数组辅助函数array_findarray_find_keyarray_anyarray_all\">特性：新数组辅助函数（array_find、array_find_key、array_any、array_all）</h3>\n<p>PHP 8.4 新增了数组搜索/检查函数。</p>\n<p><strong>array_find 和 array_find_key</strong></p>\n<pre><code class=\"language-php\">$users = [\n    ['id' =&gt; 1, 'active' =&gt; false],\n    ['id' =&gt; 2, 'active' =&gt; true],\n    ['id' =&gt; 3, 'active' =&gt; false],\n];\n\n$first = array_find($users, fn ($u) =&gt; $u['active'] === true);\n// ['id' =&gt; 2, 'active' =&gt; true]\n</code></pre>\n<p>如果没找到，返回 <code>null</code>——但如果<strong>值本身</strong>就是 <code>null</code>，你怎么区分\"找到 null\"和\"没找到\"？</p>\n<p>你可以用 <code>array_find_key()</code> 来避免歧义（因为 key 不能是 null）。</p>\n<pre><code class=\"language-php\">$key = array_find_key($users, fn ($u) =&gt; $u['active'] === true);\nif ($key === null) {\n    // 真的没找到\n}\n$firstActive = $users[$key];\n</code></pre>\n<p><strong>array_any 和 array_all 看起来简单——直到它们消除了噪音</strong></p>\n<p>例如：强制所有上传的文件都在大小限制内。</p>\n<pre><code class=\"language-php\">$ok = array_all($files, fn ($f) =&gt; $f['size'] &lt;= 5_000_000);\nif (!$ok) {\n    throw new RuntimeException('One or more files are too large.');\n}\n</code></pre>\n<p>这替代了每个人都写得略有不同的 foreach + 标志变量。</p>\n<h3 id=\"特性deprecated-attribute-用于用户态弃用\">特性：#[Deprecated] attribute 用于用户态弃用</h3>\n<p>PHP 一直有内部弃用机制，但 PHP 8.4 通过 <code>#[Deprecated]</code> attribute 暴露了一个干净的用户态版本。</p>\n<p>手册说：使用已弃用的功能会触发 <code>E_USER_DEPRECATED</code>。</p>\n<p>示例：</p>\n<pre><code class=\"language-php\">#[\\Deprecated(message: \"Use slugify() instead\", since: \"2026-01\")]\nfunction make_slug(string $s): string\n{\n    return strtolower(trim($s));\n}\n\nfunction slugify(string $s): string\n{\n    // 真正的实现\n    return strtolower(trim($s));\n}\n\nmake_slug(\"Hello World\");\n</code></pre>\n<p>这对团队来说被低估了：它给你一个标准化的方式来：</p>\n<ul>\n<li>标记旧的辅助函数，</li>\n<li>指导内部迁移，</li>\n<li>在 CI 日志中暴露弃用使用情况。</li>\n</ul>\n<h3 id=\"特性支持-html5-的新-dom-api在-dom-命名空间中\">特性：支持 HTML5 的新 DOM API（在 Dom 命名空间中）</h3>\n<p>如果你在 PHP 中解析过 HTML（爬取、清理、迁移脚本），PHP 8.4 是一次有意义的升级。</p>\n<p>8.4 发布公告介绍了带有标准兼容 HTML5 解析的新 DOM API、Dom 命名空间中的新类，以及方便的查询辅助函数。</p>\n<p>公告中的示例展示了：</p>\n<ul>\n<li><code>Dom\\HTMLDocument::createFromString(...)</code></li>\n<li><code>querySelector(...)</code></li>\n<li><code>classList-&gt;contains(...)</code></li>\n</ul>\n<p>一个实际用例：安全地检测\"canonical\"链接标签。</p>\n<pre><code class=\"language-php\">$doc = Dom\\HTMLDocument::createFromString($html, LIBXML_NOERROR);\n$canonical = $doc-&gt;querySelector('link[rel=\"canonical\"]');\n$url = $canonical?-&gt;getAttribute('href');\n</code></pre>\n<p>对于简单任务，这比经典的 DOMDocument + DOMXPath 组合好用得多，它减少了没人想维护的\"XPath 意大利面\"脚本。</p>\n<h3 id=\"特性pdo-驱动特定子类更精确的-api\">特性：PDO 驱动特定子类（更精确的 API）</h3>\n<p>PHP 8.4 引入了驱动特定的 PDO 子类，如 <code>Pdo\\MySql</code>、<code>Pdo\\Pgsql</code>、<code>Pdo\\Sqlite</code> 等，并在发布公告中展示了新的连接风格。</p>\n<p>在 PHP 8.4 示例中：</p>\n<ul>\n<li><code>PDO::connect(...)</code> 返回 <code>Pdo\\Sqlite</code></li>\n<li>驱动特定方法只存在于相关的地方</li>\n</ul>\n<p>这改善了正确性和 IDE 支持，特别是在测试和生产混用不同驱动的代码库中。</p>\n<h3 id=\"附加lazy-objects主要用于框架和基础设施代码\">附加：Lazy objects（主要用于框架和基础设施代码）</h3>\n<p>PHP 8.4 还引入了 lazy objects 概念：初始化被延迟到访问时才进行的对象。迁移指南明确指出框架可以利用它们来延迟获取依赖或数据。</p>\n<p>它甚至展示了使用 <code>ReflectionClass::newLazyGhost(...)</code> 的核心机制。</p>\n<p>这不是你在日常应用代码中会天天用的东西，但如果你做：</p>\n<ul>\n<li>DI 容器，</li>\n<li>ORM，</li>\n<li>代理层，</li>\n<li>或对性能敏感的 bootstrap，</li>\n</ul>\n<p>…值得知道它的存在，因为你会在生态系统内部看到它。</p>\n<h2 id=\"php-84-如何改变-oop-风格尤其是-dto\">PHP 8.4 如何改变 OOP 风格（尤其是 DTO）</h2>\n<p>如果你写 PHP 很多年，你可能经历过至少三种 DTO 风格：</p>\n<ol>\n<li>\"到处都是 public 属性\"</li>\n<li>\"所有东西都是私有属性 + getter/setter\"</li>\n<li>\"readonly 提升属性\"（好用，但死板）</li>\n</ol>\n<p>PHP 8.4 增加了第四种，非常实用：</p>\n<ul>\n<li>public 读，</li>\n<li>受控写，</li>\n<li>不变量靠近数据。</li>\n</ul>\n<h3 id=\"84-之前常见的-dto-样板代码\">8.4 之前：常见的 DTO 样板代码</h3>\n<pre><code class=\"language-php\">final class CreateUserCommand\n{\n    private string $email;\n    private string $name;\n    public function __construct(string $email, string $name)\n    {\n        $this-&gt;email = strtolower(trim($email));\n        $this-&gt;name = trim($name);\n        if ($this-&gt;name === '') {\n            throw new InvalidArgumentException('Name is required.');\n        }\n    }\n    public function email(): string { return $this-&gt;email; }\n    public function name(): string { return $this-&gt;name; }\n}\n</code></pre>\n<p>没什么问题。只是重复，特别是在几十个消息对象上。</p>\n<h3 id=\"84-之后public-读--private-写--hooks\">8.4 之后：\"public 读 + private 写 + hooks\"</h3>\n<pre><code class=\"language-php\">final class CreateUserCommand\n{\n    public private(set) string $email {\n        set =&gt; strtolower(trim($value));\n    }\n    public private(set) string $name {\n        set {\n            $v = trim($value);\n            if ($v === '') {\n                throw new InvalidArgumentException('Name is required.');\n            }\n            $this-&gt;name = $v;\n        }\n    }\n    public function __construct(string $email, string $name)\n    {\n        $this-&gt;email = $email;\n        $this-&gt;name = $name;\n    }\n}\n</code></pre>\n<p>你得到：</p>\n<ul>\n<li>强类型</li>\n<li>集中化的规范化/验证</li>\n<li>Public 可读性（在模板、日志、序列化器中方便）</li>\n<li>没有访问器样板</li>\n</ul>\n<p>而且你仍然可以用测试保持严格。</p>\n<h3 id=\"一个现实的dto--派生属性模式\">一个现实的\"DTO + 派生属性\"模式</h3>\n<pre><code class=\"language-php\">final class Address\n{\n    public function __construct(\n        public private(set) string $line1,\n        public private(set) ?string $line2,\n        public private(set) string $city,\n    ) {}\n    public string $singleLine {\n        get =&gt; trim($this-&gt;line1 . ' ' . ($this-&gt;line2 ?? '') . ', ' . $this-&gt;city);\n    }\n}\n</code></pre>\n<p>你可以保持存储字段干净，并提供一个友好的派生字段而不引入额外方法。</p>\n<h3 id=\"readonly-仍然胜出的场景\">readonly 仍然胜出的场景</h3>\n<p>因为 hooks 不能和 readonly 一起用，不可变值对象仍然依赖：</p>\n<ul>\n<li>readonly 提升属性</li>\n<li>工厂</li>\n<li>显式的 <code>withX()</code> 方法（在 PHP 8.5 里更好用了，但那是另一篇文章的事）</li>\n</ul>\n<p>所以很多团队的实际分工是：</p>\n<ul>\n<li><strong>值对象</strong>：readonly + 显式行为</li>\n<li><strong>DTO / 命令 / 请求</strong>：非对称可见性 + hooks</li>\n</ul>\n<h2 id=\"经常影响测试ci-的简短兼容性说明\">经常影响测试/CI 的简短兼容性说明</h2>\n<p>这一节故意简短，但是能省时间的那种简短。</p>\n<h3 id=\"错误报告级别e_strict-没了\">错误报告级别：E_STRICT 没了</h3>\n<p>PHP 8.4 移除了 E_STRICT 错误级别，E_STRICT 常量已弃用。</p>\n<p>如果你有遗留代码或配置引用了 E_STRICT，可能会看到 CI 行为变化。</p>\n<h3 id=\"jit-配置默认值变了opcache\">JIT 配置默认值变了（OPcache）</h3>\n<p>PHP 8.4 中 JIT 配置的默认值变了：</p>\n<ul>\n<li>从 <code>opcache.jit=tracing</code> 和 <code>opcache.jit_buffer_size=0</code></li>\n<li>到 <code>opcache.jit=disable</code> 和 <code>opcache.jit_buffer_size=64M</code></li>\n</ul>\n<p>这不会改变\"JIT 默认关闭\"，但可能影响之前只切换其中一个值的环境。</p>\n<h3 id=\"一些扩展变得更严格类型化常量valueerror行为变更\">一些扩展变得更严格（类型化常量、ValueError、行为变更）</h3>\n<p>8.4 不兼容列表中的一些例子：</p>\n<ul>\n<li>几个扩展类常量现在有类型（Date、Intl、PDO、Reflection、SPL、Sqlite、XMLReader）。</li>\n<li>一些函数现在抛 ValueError 而不是静默接受无效输入（如 <code>round()</code> 无效模式、<code>str_getcsv()</code> 无效分隔符长度）。</li>\n<li>SimpleXML 迭代行为变了以避免意外的 rewind（之前可能导致无限循环）。</li>\n<li>根据驱动，一些 PDO 属性现在表现为布尔而非整数。</li>\n</ul>\n<p>这些是那种除非你尽早在 8.4 下运行测试套件，否则会表现为\"随机测试失败\"的变更。</p>\n<h2 id=\"小型迁移采用-php-84-的小步骤无需大重构\">小型迁移：采用 PHP 8.4 的小步骤，无需大重构</h2>\n<p>如果你还没上 8.4——或者上了但没用这些特性——这是一个通常有效的安全顺序。</p>\n<h3 id=\"步骤-1先把-84-加到-ci即使生产还没准备好\">步骤 1：先把 8.4 加到 CI，即使生产还没准备好</h3>\n<p>确保你能在 8.4 上运行测试套件而不出意外。把警告和弃用当作信号。</p>\n<h3 id=\"步骤-2只在新代码中采用-array_find--array_any--array_all\">步骤 2：只在新代码中采用 array_find / array_any / array_all</h3>\n<p>不要重构整个代码库。只是不要再写新的\"foreach-with-break\"循环，除非它们真的更清晰。</p>\n<h3 id=\"步骤-3对新的-dto-和请求对象使用非对称可见性\">步骤 3：对新的 DTO 和请求对象使用非对称可见性</h3>\n<p>这是低风险的：你主要是改变属性声明并消除一类意外修改。</p>\n<h3 id=\"步骤-4在明显替代样板代码的地方添加-property-hooks\">步骤 4：在明显替代样板代码的地方添加 property hooks</h3>\n<p>从以下开始：</p>\n<ul>\n<li>trim 和大小写规范化，</li>\n<li>简单验证，</li>\n<li>派生属性。</li>\n</ul>\n<p>一开始避免在 hooks 里放重逻辑。</p>\n<h3 id=\"步骤-5用-deprecated-进行内部-api-清理\">步骤 5：用 #[Deprecated] 进行内部 API 清理</h3>\n<p>用清晰的消息标记旧方法和辅助函数。在 CI 日志中跟踪使用情况。让弃用可操作。</p>\n<h3 id=\"步骤-6只在脚本或隔离模块中采用新-dom-api\">步骤 6：只在脚本或隔离模块中采用新 DOM API</h3>\n<p>如果你的应用做 HTML 解析，新 API 可能是很大的改进——但一开始保持采用范围受限。</p>\n<h3 id=\"步骤-7把-lazy-objects-留给框架基础设施层\">步骤 7：把 lazy objects 留给框架/基础设施层</h3>\n<p>知道这个特性存在。不要强行塞进应用代码，除非你有非常具体的性能或架构原因。</p>\n<h2 id=\"通往-php-85-的桥梁为什么-84-让下一步更容易\">通往 PHP 8.5 的桥梁（为什么 8.4 让下一步更容易）</h2>\n<p>一旦你的团队熟悉了 PHP 8.4 的\"现代基线\"：</p>\n<ul>\n<li>DTO 因为非对称可见性 + hooks 变得更干净</li>\n<li>弃用策略因为 <code>#[Deprecated]</code> 变得更系统化</li>\n<li>数组重型代码可以用原生辅助函数表达得更清晰</li>\n<li>HTML 解析和工具脚本变得不那么痛苦</li>\n</ul>\n<p>这个基线减少了迁移到 PHP 8.5 的摩擦，因为你已经现代化了代码库中对象和日常工具的写法。PHP 8.5 就不再是\"追赶\"，而是选择性地采用改进。</p>\n<h2 id=\"结论\">结论</h2>\n<p>PHP 8.4 不是一个\"跳过它，直接上 8.5\"的版本。在 2026 年，它仍然是一个明智的基线，因为它受支持、广泛相关，而且它改变了日常 PHP 的人体工学——尤其是在 OOP 密集的代码库中。</p>\n<p>如果你从这篇回顾中只带走一件事，那就是 property hooks——但要带着意图使用：</p>\n<ul>\n<li>用它们做不变量、规范化和干净的派生值，</li>\n<li>把它们和非对称可见性配对做实用的 DTO，</li>\n<li>让 hooks 保持无聊（往好的方向）。</li>\n</ul>\n<p>这个组合让你今天就有更干净的 8.4 代码库——以及准备好时通往 8.5 的更平滑路径。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 07:17</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "硬核实用！Windows下使用 PowerShell 编写局域网设备扫描器",
      "link": "https://www.cnblogs.com/zjw-blog/p/19474721",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zjw-blog/p/19474721\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 03:29\">\n    <span>硬核实用！Windows下使用 PowerShell 编写局域网设备扫描器</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"前言\">前言</h3>\n<p>在进行网络调试或设备管理时，我们经常需要知道局域网内有哪些设备在线。传统的 <code>ping</code> 命令逐个扫描太慢，而专业的扫描工具又显得大材小用。今天，我们通过一段 PowerShell 脚本，利用网络协议的底层特性，打造一个局域网扫描工具。</p>\n<hr />\n<h3 id=\"原理剖析为什么这个脚本比普通-ping-更快更准\">原理剖析：为什么这个脚本比普通 Ping 更快、更准？</h3>\n<p>大多数人认为扫描局域网就是简单地给每个 IP 发送 Ping 包。但这种方式有两大弊端：</p>\n<ol>\n<li><strong>效率低</strong>：等待不在线的设备超时会耗费大量时间。</li>\n<li><strong>不准确</strong>：许多设备（如开启防火墙的 Windows 电脑）会禁掉 ICMP 回显，导致明明在线却显示“离线”。</li>\n</ol>\n<p>本脚本采用了 <strong>“异步探测 + ARP 表解析”</strong> 的双重机制，其工作原理流程图如下：</p>\n<h4 id=\"1-异步探测asynchronous-probing\">1. 异步探测（Asynchronous Probing）</h4>\n<p>脚本并没有等待每一个 Ping 的结果。它使用 <code>SendPingAsync</code> 向网段内的所有 254 个 IP 地址快速抛出探测包。</p>\n<ul>\n<li><strong>目的</strong>：我们并不在乎这些包是否真的收到了回复，其真正的目的是<strong>触发操作系统的 ARP 广播</strong>。</li>\n</ul>\n<h4 id=\"2-arp-协议的妙用\">2. ARP 协议的妙用</h4>\n<p>当你的电脑尝试向局域网内某个 IP 发送数据时，它首先需要知道对方的 MAC 地址（物理地址）。即便对方防火墙拦截了 Ping 包，只要该设备存在，它通常也会对 ARP 请求做出响应。</p>\n<ul>\n<li><strong>ARP 表</strong>：一旦设备响应，它的 IP 和 MAC 地址就会被记录在操作系统的 ARP 缓存表中。</li>\n</ul>\n<h4 id=\"3-状态判定算法\">3. 状态判定算法</h4>\n<p>脚本通过 <code>Get-NetNeighbor</code> 检查系统的 ARP 记录，将状态分为三类判定：</p>\n<ul>\n<li><strong>Ping 在线</strong>：设备响应了 ICMP。</li>\n<li><strong>ARP 在线</strong>：设备虽不响应 Ping，但在 ARP 表中状态为 <code>Reachable</code> 或 <code>Stale</code>。</li>\n<li><strong>离线</strong>：ARP 表无记录或显示缓存失效。</li>\n</ul>\n<hr />\n<h3 id=\"完整代码\">完整代码</h3>\n<details>\n点击查看 PowerShell 脚本代码\n<pre><code class=\"language-bash\">Write-Host \"==========================================\" -ForegroundColor Green\nWrite-Host \"         局域网设备扫描器         \" -ForegroundColor Green\nWrite-Host \"==========================================\" -ForegroundColor Green\n\n# -----------------------------\n# 在线检测函数（核心）\n# -----------------------------\nfunction Test-DeviceOnline {\n    param([string]$IP)\n    $arp = Get-NetNeighbor -IPAddress $IP -ErrorAction SilentlyContinue\n    if (-not $arp) {\n        return @{ Online = $false; Reason = \"无ARP\" }\n    }\n    if ($arp.State -in 'Reachable','Stale','Delay','Probe') {\n        if (Test-Connection $IP -Count 1 -Quiet -ErrorAction SilentlyContinue) {\n            return @{ Online = $true; Reason = \"Ping\" }\n        }\n        return @{ Online = $true; Reason = \"ARP在线\" }\n    }\n    return @{ Online = $false; Reason = \"缓存失效\" }\n}\n\n# -----------------------------\n# 1. 获取 IPv4 网卡\n# -----------------------------\n$adapters = Get-NetIPAddress -AddressFamily IPv4 |\nWhere-Object {\n    $_.IPAddress -notmatch '^127\\.|^169\\.254\\.' -and\n    $_.PrefixLength -eq 24\n}\n\nif (-not $adapters) {\n    Write-Host \"未发现可用 IPv4 网卡\" -ForegroundColor Red\n    Read-Host\n    exit\n}\n\n# -----------------------------\n# 2. 生成网段\n# -----------------------------\n$networks = $adapters.IPAddress |\nForEach-Object {\n    if ($_ -match '^(\\d+\\.\\d+\\.\\d+)\\.\\d+$') {\n        \"$($Matches[1]).0/24\"\n    }\n} | Select-Object -Unique\n\n# -----------------------------\n# 3. 选择网段\n# -----------------------------\nif ($networks.Count -eq 1) {\n    $network = $networks[0]\n    Write-Host \"`n仅检测到一个网段，自动使用：$network\" -ForegroundColor Yellow\n}\nelse {\n    do {\n        Write-Host \"`n检测到多个网段，请选择要扫描的网段：\" -ForegroundColor Cyan\n        for ($i = 0; $i -lt $networks.Count; $i++) {\n            Write-Host \"[$($i + 1)] $($networks[$i])\"\n        }\n\n        $choice = Read-Host \"请输入编号 (1-$($networks.Count))\"\n        $valid  = [int]::TryParse($choice, [ref]$null) -and\n                  $choice -ge 1 -and\n                  $choice -le $networks.Count\n\n        if (-not $valid) {\n            Write-Host \"输入无效，请重新选择。\" -ForegroundColor Red\n        }\n    } until ($valid)\n\n    $network = $networks[$choice - 1]\n}\n\n$prefix = $network -replace '\\.0/24',''\n\n# -----------------------------\n# 4. 快速建立 ARP 表\n# -----------------------------\nWrite-Host \"`n[1/2] 正在向网段 $network 发送探测包 (Ping)...\" -ForegroundColor Cyan\nforeach ($i in 1..254) {\n    $p = New-Object System.Net.NetworkInformation.Ping\n    [void]$p.SendPingAsync(\"$prefix.$i\", 800)\n}\nStart-Sleep -Seconds 1\n\n# -----------------------------\n# 5. 获取本机 IP → MAC\n# -----------------------------\n$localMapping = @{}\nGet-NetIPAddress -AddressFamily IPv4 |\nWhere-Object { $_.IPAddress -notmatch '^127\\.|^169\\.254\\.' } |\nForEach-Object {\n    $adapter = Get-NetAdapter -InterfaceIndex $_.InterfaceIndex -ErrorAction SilentlyContinue\n    if ($adapter) {\n        $localMapping[$_.IPAddress] = $adapter.MacAddress.Replace(\"-\", \":\").ToUpper()\n    }\n}\n\n# -----------------------------\n# 6. 解析 ARP 表\n# -----------------------------\n$arpRegex = '(?&lt;IP&gt;\\d{1,3}(\\.\\d{1,3}){3})\\s+(?&lt;MAC&gt;([0-9a-f]{2}[:-]){5}[0-9a-f]{2})'\n$globalArp = arp -a\n\n$potentialIPs = @()\nforeach ($line in $globalArp) {\n    if ($line -match $arpRegex) {\n        $ip  = $Matches.IP\n        $mac = $Matches.MAC.ToUpper().Replace(\"-\", \":\")\n\n        if ($ip.StartsWith(\"$prefix.\") -and\n            -not $localMapping.ContainsKey($ip) -and\n            $ip -notmatch '\\.255$') {\n\n            $potentialIPs += [PSCustomObject]@{\n                IP  = $ip\n                MAC = $mac\n            }\n        }\n    }\n}\n\n# -----------------------------\n# 7. 构建结果\n# -----------------------------\n$finalList = @()\n\n# 本机\nforeach ($ip in $localMapping.Keys) {\n    if ($ip.StartsWith(\"$prefix.\")) {\n        $finalList += [PSCustomObject]@{\n            IP       = \"$ip*\"\n            MAC      = $localMapping[$ip]\n            IsOnline = $true\n            Reason   = \"本机\"\n            RawIP    = $ip\n        }\n    }\n}\n\nWrite-Host \"[2/2] 正在判断设备在线状态...\" -ForegroundColor Cyan\n\nforeach ($dev in $potentialIPs | Select-Object -Unique IP, MAC) {\n    $result = Test-DeviceOnline $dev.IP\n    $finalList += [PSCustomObject]@{\n        IP       = $dev.IP\n        MAC      = $dev.MAC\n        IsOnline = $result.Online\n        Reason   = $result.Reason\n        RawIP    = $dev.IP\n    }\n}\n\n# -----------------------------\n# 8. 输出\n# -----------------------------\nWrite-Host \"`n============== 扫描结果 ==============\" -ForegroundColor Cyan\n\n$sorted = $finalList | Sort-Object {[version]$_.RawIP}\n\nforeach ($item in $sorted) {\n    $status = if ($item.IsOnline) {\n\t\tswitch ($item.Reason) {\n\t\t\t\"Ping\"     { \"在线\" }\n\t\t\t\"ARP在线\"  { \"在线（未响应 Ping）\" }\n\t\t\t\"本机\"     { \"本机\" }\n\t\t\tdefault    { \"在线\" }\n\t\t}\n\t} else {\n\t\tswitch ($item.Reason) {\n\t\t\t\"缓存失效\" { \"离线（缓存失效）\" }\n\t\t\tdefault    { \"离线\" }\n\t\t}\n\t}\n\n\n    $line = \"{0,-20} {1,-22} {2}\" -f $item.IP, $item.MAC, $status\n\n    if ($item.IsOnline) {\n        Write-Host $line -ForegroundColor Green\n    } else {\n        Write-Host $line -ForegroundColor DarkGray\n    }\n}\n\n$online = ($finalList | Where-Object { $_.IsOnline }).Count\n$total  = $finalList.Count\n\nWrite-Host \"`n扫描完成：$online / $total 台设备在线\" -ForegroundColor Green\nWrite-Host \"`n按任意键退出...\"\n$null = [System.Console]::ReadKey()\n</code></pre>\n</details>\n<h3 id=\"核心代码亮点说明\">核心代码亮点说明</h3>\n<h4 id=\"网段自动识别\">网段自动识别</h4>\n<p>脚本会自动排除 <code>127.0.0.1</code>（回环地址）和 <code>169.254.x.x</code>（自动私有 IP），并智能识别当前活跃的网段，无需用户手动输入 IP 范围。</p>\n<h4 id=\"结果美化输出\">结果美化输出</h4>\n<p>为了提升使用体验，脚本使用了格式化操作符 <code>-f</code>：</p>\n<pre><code class=\"language-bash\">$line = \"{0,-20} {1,-22} {2}\" -f $item.IP, $item.MAC, $status\n</code></pre>\n<p>它可以确保输出的 IP、MAC 地址和状态在控制台中完美对齐，并使用绿色（在线）和灰色（离线）进行视觉区分。</p>\n<hr />\n<h3 id=\"如何使用\">如何使用？</h3>\n<ol>\n<li>将脚本代码粘贴进编辑器（或保存为 <code>.ps1</code> 文件）,编码<code>UTF8 BOM</code>。也可通过<a href=\"https://files.cnblogs.com/files/zjw-blog/LANScanner%E5%B1%80%E5%9F%9F%E7%BD%91%E6%89%AB%E6%8F%8F%E5%99%A8.zip\" target=\"_blank\">LANScanner局域网扫描器.zip</a>链接进行下载</li>\n<li>使用powershell.exe运行，建议使用powershell<a href=\"https://www.cnblogs.com/zjw-blog/p/19449891\" target=\"_blank\">文件关联</a>后直接运行。</li>\n</ol>\n<h3 id=\"运行截图\">运行截图</h3>\n<p><img alt=\"图片\" src=\"https://img2024.cnblogs.com/blog/1745057/202601/1745057-20260113032751492-35872645.png\" /></p>\n<h3 id=\"总结\">总结</h3>\n<p>这个脚本不仅是一个工具，更是对 <strong>Layer 2（数据链路层）</strong> 和 <strong>Layer 3（网络层）</strong> 协同工作的一次实践。通过利用系统底层的 ARP 缓存，我们实现了比传统扫描器更高效、更具穿透力的探测效果。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 03:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zjw-blog\">雨中遐想</a>&nbsp;\n阅读(<span id=\"post_view_count\">29</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": ".NET 磁盘管理-技术方案选型",
      "link": "https://www.cnblogs.com/kybs0/p/19473484",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kybs0/p/19473484\" id=\"cb_post_title_url\" title=\"发布于 2026-01-12 23:50\">\n    <span>.NET 磁盘管理-技术方案选型</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在家庭以及企业场景下的网络磁盘产品，使用Iscsi均需要对磁盘进行管理。不同Windows版本、安装第三方软件，导致每个C端用户的运行环境不同，对磁盘的管理带来一定的使用干扰</p>\n<p>本文介绍下磁盘管理的几种方案以及存在的一些问题</p>\n<p>对磁盘管理主要有以下操作入口/方式：</p>\n<ol>\n<li>Powershell</li>\n<li>Diskpart</li>\n<li>WMI</li>\n<li>WIN32(IOCTL)</li>\n</ol>\n<p>下面介绍下四者之间的关系以及所依赖的windows系统服务</p>\n<h1>Windows磁盘管理服务依赖层级</h1>\n<p>从操作系统角度看，这几种方式编程/操作入口是围绕同一套内核与服务堆栈的不同“壳”，完成<strong>套娃封装</strong></p>\n<p>从高到低，依次列下windows主要的磁盘相关入口和服务</p>\n<p>1. GUI/工具层</p>\n<p>MMC -&nbsp;Windows系统磁盘管理工具，如果需要快速查看和操作磁盘分区的话，可以用这个</p>\n<p><img alt=\"image\" height=\"270\" src=\"https://img2024.cnblogs.com/blog/685541/202601/685541-20260112154249299-1528163380.png\" width=\"529\" /></p>\n<p>以及Storage Spaces GUI - Windows系统设置存储管理</p>\n<p><img alt=\"image\" height=\"306\" src=\"https://img2024.cnblogs.com/blog/685541/202601/685541-20260112154850543-1013979831.png\" width=\"533\" /><img alt=\"image\" height=\"305\" src=\"https://img2024.cnblogs.com/blog/685541/202601/685541-20260112155107194-71293024.png\" width=\"403\" /></p>\n<p>这俩个工具主要是使用WMI相关操作来实现</p>\n<p>2. 脚本/命令层</p>\n<p>Powershell磁盘管理命令</p>\n<p>diskpart磁盘管理命令</p>\n<p>CIM磁盘管理命令</p>\n<p>3. API/管理接口层</p>\n<p>WMI服务：Winmgmt（Windows Management Instrumentation），使用Win32_DiskDrive 等</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/685541/202601/685541-20260112181124821-2050380879.png\" /></p>\n<p>磁盘管理服务：Virtual Disk，VDS进程名称vds.exe</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/685541/202601/685541-20260112180656866-1672546299.png\" /></p>\n<p>磁盘存储服务：Microsoft Storage Spaces SMP</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/685541/202601/685541-20260112163817548-1975243303.png\" /></p>\n<p>4. 内核/驱动/IOCTL层</p>\n<p>Storage Management Provider：系统组件，不是单独服务可见<br />IOCTL： Win32API、DevicerIoControl</p>\n<p>磁盘类驱动（disk.sys）、卷管理器（volmgr/vdsci）、文件系统驱动（NTFS/ReFS）</p>\n<p><strong>而上面说的四种方案，依赖的底层服务：</strong></p>\n<p>PowerShell 基于 WMI / Storage Management API封装，依赖的组件最多：Winmgmt、Microsoft Storage Spaces SMP、Storage Service、VDS等<br />WMI/CIM 有部分是走 VDS / Storage API，有部分直接调用底层驱动，依赖：VDS服务、Winmgmt服务</p>\n<p>diskpart 内部是调用 VDS / Storage API / IOCTL，依赖相对较少：VDS服务等</p>\n<p>Win32 IOCTL 是最底层（用户态可达）的接口，不依赖上层框架</p>\n<p>比如下方的WMI服务不存在，会导致powershell磁盘查询不到，WMI磁盘查询不到，但diskpart访问正常：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\"> 1</span> PS C:\\Users\\yudong04&gt; G<span style=\"color: rgba(0, 0, 255, 1);\">et-Disk</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 2</span> PS C:\\Users\\yudong04&gt; <span style=\"color: rgba(0, 0, 255, 1);\">Get-CimInstance</span> -Namespace root/Microsoft/Windows/Storage -<span style=\"color: rgba(0, 0, 0, 1);\">ClassName MSFT_Disk\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 3</span> PS C:\\Users\\yudong04&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> diskpart\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 4</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 5</span> Microsoft DiskPart 版本 10.0.26100.1150\n<span style=\"color: rgba(0, 128, 128, 1);\"> 6</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 7</span> <span style=\"color: rgba(0, 0, 0, 1);\">Copyright (C) Microsoft Corporation.\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 8</span> 在计算机上: GIH-D-24762\n<span style=\"color: rgba(0, 128, 128, 1);\"> 9</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">10</span> DISKPART&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> list disk\n</span><span style=\"color: rgba(0, 128, 128, 1);\">11</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">12</span>   磁盘 <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\">##  状态           大小     可用     Dyn  Gpt</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">13</span>   --------  -------------  -------  -------  ---  ---\n<span style=\"color: rgba(0, 128, 128, 1);\">14</span>   磁盘 0    联机             3726 GB  1024 KB        *\n<span style=\"color: rgba(0, 128, 128, 1);\">15</span>   磁盘 1    联机             3726 GB  1024 KB        *\n<span style=\"color: rgba(0, 128, 128, 1);\">16</span>   磁盘 2    联机             2794 GB      0 B        *\n<span style=\"color: rgba(0, 128, 128, 1);\">17</span>   磁盘 3    联机              931 GB      0 B        *\n<span style=\"color: rgba(0, 128, 128, 1);\">18</span>   磁盘 4    联机              465 GB  1024 KB        *\n<span style=\"color: rgba(0, 128, 128, 1);\">19</span>   磁盘 5    联机             1863 GB      0<span style=\"color: rgba(0, 0, 0, 1);\"> B\n</span><span style=\"color: rgba(0, 128, 128, 1);\">20</span>   磁盘 6    联机             7452 GB      0 B        *</pre>\n</div>\n<p><span style=\"font-size: 14px;\">还有Microsoft Storage Spaces SMP服务被第三方软件禁用，导致Powershell Get-Disk获取结果为空：</span></p>\n<p><img alt=\"image\" height=\"554\" src=\"https://img2024.cnblogs.com/blog/685541/202601/685541-20260112205453476-213941181.png\" width=\"1009\" /></p>\n<p><span style=\"font-size: 14px;\">下面对各个模块展开介绍下</span></p>\n<h1>Powershell磁盘管理</h1>\n<p>上面说了，PowerShell使用 Storage Management API + 新的 WMI/CIM 类，磁盘命令本质是对这些 WMI 类的包装。层级如下：</p>\n<p>PowerShell cmdlet<br />-&gt; MSFT_* WMI 类 (CIM)、WMI服务Winmgmt<br />-&gt; Storage Management Provider<br />-&gt; 内核驱动 (disk.sys, partmgr.sys, volmgr.sys)<br />-&gt; 设备硬件</p>\n<p>powershell有以下查找主要命令，</p>\n<p>Get-Disk - 查找磁盘</p>\n<p>Get-Partition - 查找分区</p>\n<p>Get-Volume - 查找卷</p>\n<p>Get-Disk | Where-Object -FilterScript {&nbsp; $_.BusType -Eq \"iSCSI\" -and $_.SerialNumber -Eq \"8fa461f8-9436-4260-8191-789b23859757\"} - 查找指定Iscsi协议磁盘</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/685541/202601/685541-20260112162810665-890504091.png\" /></p>\n<p>操作磁盘命令，比如初始化GPT磁盘：Initialize-Disk -PartitionStyle GPT -PassThru | New-Partition -UseMaximumSize | Format-Volume -FileSystem:NTFS -NewFileSystemLabel:测试盘 -Confirm:$false -Force</p>\n<p>Powershell命令因易用性，非常适合脚本自动化、用户级的使用。但非常与用户环境有关，换个用户或换台机器就经常表现不同，比如：卡很久、超时、直接报错、磁盘盘就是查询不到</p>\n<p>几个原因：</p>\n<p>WMI / CIM 调用超时</p>\n<ul>\n<li>WMI 服务卡住、存储驱动响应慢</li>\n<li>网络/防火墙导致远程调用超时</li>\n\n\n\n\n\n\n\n\n\n</ul>\n<p>硬件IO超时</p>\n<ul>\n<li>坏盘 / 坏 U 盘 / USB 扩展坞质量问题</li>\n<li>大量重新尝试 I/O 导致操作整体拖得很长</li>\n\n\n\n\n\n\n\n\n</ul>\n<p>具体场景，发现公司内部某个部门发生powershell命令超时概率很多，因为这些设备都在跑软件压力测试。。。导致磁盘获取命令，很容易超时</p>\n<p>还有些特殊情况，服务异常出现的情况比较多。如WMI服务，以下是修复成功案例：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\"> 1</span> PS C:\\Users\\yudong04&gt; <span style=\"color: rgba(0, 0, 255, 1);\">Get-WmiObject</span><span style=\"color: rgba(0, 0, 0, 1);\"> Win32_OperatingSystem\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 2</span> <span style=\"color: rgba(0, 0, 255, 1);\">Get-WmiObject</span><span style=\"color: rgba(0, 0, 0, 1);\"> : 无效类 “Win32_OperatingSystem”\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 3</span> 所在位置 行:1 字符: 1\n<span style=\"color: rgba(0, 128, 128, 1);\"> 4</span> + <span style=\"color: rgba(0, 0, 255, 1);\">Get-WmiObject</span><span style=\"color: rgba(0, 0, 0, 1);\"> Win32_OperatingSystem\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 5</span> +<span style=\"color: rgba(0, 0, 0, 1);\"> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 6</span>     + CategoryInfo          : InvalidType: (:) [<span style=\"color: rgba(0, 0, 255, 1);\">Get-WmiObject</span><span style=\"color: rgba(0, 0, 0, 1);\">], ManagementException\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 7</span>     +<span style=\"color: rgba(0, 0, 0, 1);\"> FullyQualifiedErrorId : GetWMIManagementException,Microsoft.PowerShell.Commands.GetWmiObjectCommand\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 8</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 9</span> PS C:\\Users\\yudong04&gt; net stop winmgmt /<span style=\"color: rgba(0, 0, 0, 1);\">y\n</span><span style=\"color: rgba(0, 128, 128, 1);\">10</span> <span style=\"color: rgba(0, 0, 0, 1);\">Windows Management Instrumentation 服务正在停止.\n</span><span style=\"color: rgba(0, 128, 128, 1);\">11</span> <span style=\"color: rgba(0, 0, 0, 1);\">Windows Management Instrumentation 服务已成功停止。\n</span><span style=\"color: rgba(0, 128, 128, 1);\">12</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">13</span> PS C:\\Users\\yudong04&gt; winmgmt /<span style=\"color: rgba(0, 0, 0, 1);\">resetrepository\n</span><span style=\"color: rgba(0, 128, 128, 1);\">14</span> <span style=\"color: rgba(0, 0, 0, 1);\">WMI 存储库已重置\n</span><span style=\"color: rgba(0, 128, 128, 1);\">15</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">16</span> PS C:\\Users\\yudong04&gt; <span style=\"color: rgba(0, 0, 255, 1);\">Get-WmiObject</span><span style=\"color: rgba(0, 0, 0, 1);\"> Win32_OperatingSystem\n</span><span style=\"color: rgba(0, 128, 128, 1);\">17</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">18</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">19</span> <span style=\"color: rgba(0, 0, 0, 1);\">SystemDirectory : C:\\WINDOWS\\system32\n</span><span style=\"color: rgba(0, 128, 128, 1);\">20</span> <span style=\"color: rgba(0, 0, 0, 1);\">Organization    : Online Game Dept\n</span><span style=\"color: rgba(0, 128, 128, 1);\">21</span> BuildNumber     : 26100\n<span style=\"color: rgba(0, 128, 128, 1);\">22</span> <span style=\"color: rgba(0, 0, 0, 1);\">RegisteredUser  : Windows 用户\n</span><span style=\"color: rgba(0, 128, 128, 1);\">23</span> SerialNumber    : 00329-00000-00003-<span style=\"color: rgba(0, 0, 0, 1);\">AA238\n</span><span style=\"color: rgba(0, 128, 128, 1);\">24</span> Version         : 10.0.26100</pre>\n</div>\n<p>还有Microsoft Storage Spaces SMP服务，如果Get-Disk拿不到磁盘，定位客户问题发现很大可能是这个服务异常了。重启一下即可</p>\n<h1>WMI/CIM磁盘管理</h1>\n<p>WMI相关命令，需要拆分为俩部分：WIN32_*经典类，以及MSFT_*新的StorageWMI类</p>\n<p><strong>经典类：</strong></p>\n<ul>\n<li>Win32_DiskDrive</li>\n<li>Win32_DiskPartition</li>\n<li>Win32_LogicalDisk</li>\n<li>Win32_Volume</li>\n</ul>\n<p>早期设计，很多是通过内核 API + IOCTL 和 VDS 实现。主要用于查询，修改操作有限</p>\n<p>依赖服务：Winmgmt、RPCSS（RPC服务）、以及少量依赖VDS</p>\n<p><strong>StorageWmi类</strong></p>\n<ul>\n<li>MSFT_Disk</li>\n<li>MSFT_Partition</li>\n<li>MSFT_Volume</li>\n<li>MSFT_StoragePool</li>\n<li>MSFT_VirtualDisk</li>\n</ul>\n<p>这是Windows8之后的新存储管理WMI接口，详见官网文档：<a href=\"https://learn.microsoft.com/en-us/windows-hardware/drivers/storage/storage-management-api-classes\" rel=\"noopener nofollow\">Storage Management API Classes - Windows drivers | Microsoft Learn</a>, 依赖层级：</p>\n<p>WMI (MSFT_* 类)<br />  -&gt; Storage Management Provider<br />     -&gt; IOCTL -&gt; disk.sys / partmgr.sys / ...</p>\n<p>具体依赖的服务：Winmgmt（WMI 服务）</p>\n<p>WMI 是“管理数据模型 + 接口”，本身不是一个磁盘管理“方案”，而是很多方案的基础接口。相对Powershell Storage管理，算是比较稳定和依赖较少的了</p>\n<p>直接使用.NET通过WMI获取详细的磁盘列表数据，代码如下：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\"> 1</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span> OperateResult&lt;List&lt;LocalDisk&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GetDisks()\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 2</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 3</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> disks = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;LocalDisk&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 4</span>         <span style=\"color: rgba(0, 0, 255, 1);\">try</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 5</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 6</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Win32_DiskDrive: 物理磁盘</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 7</span>             <span style=\"color: rgba(0, 0, 255, 1);\">using</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> searcher = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> ManagementObjectSearcher(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">SELECT * FROM Win32_DiskDrive</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 8</span>             <span style=\"color: rgba(0, 0, 255, 1);\">using</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> driveCollection =<span style=\"color: rgba(0, 0, 0, 1);\"> searcher.Get())\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 9</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">10</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (ManagementObject drive <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> driveCollection)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">11</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">12</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">var</span> diskInfo = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> LocalDisk();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">13</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">14</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 磁盘编号 PhysicalDriveN\n</span><span style=\"color: rgba(0, 128, 128, 1);\">15</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Win32_DiskDrive.DeviceID 一般为 \"\\\\.\\PHYSICALDRIVE0\"</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">16</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">var</span> deviceId = (drive[<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">DeviceID</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>] <span style=\"color: rgba(0, 0, 255, 1);\">as</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span>) ?? <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">17</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">var</span> diskNumber =<span style=\"color: rgba(0, 0, 0, 1);\"> ParsePhysicalDriveNumber(deviceId);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">18</span>                     diskInfo.Number =<span style=\"color: rgba(0, 0, 0, 1);\"> diskNumber;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">19</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">20</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2. 序列号 (不同厂商格式不统一；有时需要 Win32_PhysicalMedia)</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">21</span>                     diskInfo.SerialNumber = (drive[<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">SerialNumber</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>] <span style=\"color: rgba(0, 0, 255, 1);\">as</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span>)?.Trim() ?? <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">22</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">23</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. DeviceName</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">24</span>                     diskInfo.DeviceName = (drive[<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Model</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>] <span style=\"color: rgba(0, 0, 255, 1);\">as</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span>)?.Trim() ?? <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">25</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">26</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4. 只读/在线状态（WMI 并没有非常标准的字段，这里用粗略映射）\n</span><span style=\"color: rgba(0, 128, 128, 1);\">27</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   Win32_DiskDrive.Status: \"OK\" / \"Error\" / \"Degraded\" ...</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">28</span>                     diskInfo.IsOffline =<span style=\"color: rgba(0, 0, 0, 1);\"> GetOffline(diskNumber);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">29</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">30</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 没有直接 readonly 标记，先默认为 false，\n</span><span style=\"color: rgba(0, 128, 128, 1);\">31</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 如需更精确可以通过 Win32_Volume 或 DeviceIoControl 获取。</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">32</span>                     diskInfo.IsReadOnly =<span style=\"color: rgba(0, 0, 0, 1);\"> GetReadonly(diskNumber);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">33</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">34</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 5. 总线类型（没有 STORAGE_BUS_TYPE 枚举，使用 InterfaceType 粗略映射）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">35</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">var</span> interfaceType = (drive[<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">InterfaceType</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>] <span style=\"color: rgba(0, 0, 255, 1);\">as</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span>)?<span style=\"color: rgba(0, 0, 0, 1);\">.Trim();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">36</span>                     diskInfo.BusType =<span style=\"color: rgba(0, 0, 0, 1);\"> MapBusType(interfaceType, diskInfo.DeviceName);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">37</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">38</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 6. 磁盘容量 (字节 -&gt; GB)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">39</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Win32_DiskDrive.Size 为字节数（string）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">40</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (drive[<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Size</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>] != <span style=\"color: rgba(0, 0, 255, 1);\">null</span> &amp;&amp; <span style=\"color: rgba(0, 0, 255, 1);\">long</span>.TryParse(drive[<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Size</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>].ToString(), <span style=\"color: rgba(0, 0, 255, 1);\">out</span> <span style=\"color: rgba(0, 0, 255, 1);\">long</span><span style=\"color: rgba(0, 0, 0, 1);\"> sizeBytes))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">41</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">42</span>                         diskInfo.DiskSize =<span style=\"color: rgba(0, 0, 0, 1);\"> sizeBytes;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">43</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">44</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">45</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 7. 获取挂载点及已用容量，通过 3 张 WMI 关联表：\n</span><span style=\"color: rgba(0, 128, 128, 1);\">46</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Win32_DiskDrive -&gt; Win32_DiskDriveToDiskPartition -&gt; Win32_DiskPartition -&gt;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">47</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Win32_LogicalDiskToPartition -&gt; Win32_LogicalDisk</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">48</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    FillMountPathsAndUsedSize(diskInfo, drive);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">49</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    disks.Add(diskInfo);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">50</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">51</span>                     diskInfo.Tag =<span style=\"color: rgba(0, 0, 0, 1);\"> GetVolumeLabel(diskInfo.MountPaths.FirstOrDefault());\n</span><span style=\"color: rgba(0, 128, 128, 1);\">52</span> <span style=\"color: rgba(0, 0, 0, 1);\">                }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">53</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">54</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">55</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;List&lt;LocalDisk&gt;&gt;.ToSuccess(disks.OrderBy(i =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> i.Number).ToList());\n</span><span style=\"color: rgba(0, 128, 128, 1);\">56</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">57</span>         <span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (Exception ex)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">58</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">59</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;List&lt;LocalDisk&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToError(ex.Message);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">60</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">61</span>     }</pre>\n</div>\n<p>附带的一些属性获取函数：</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_ac2201cc-0955-4850-bc5f-4794df011a32\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_ac2201cc-0955-4850-bc5f-4794df011a32\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_ac2201cc-0955-4850-bc5f-4794df011a32\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">  1</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> ParsePhysicalDriveNumber(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> deviceId)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  2</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  3</span>         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> \"\\\\.\\PHYSICALDRIVE0\" -&gt; 0</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">  4</span>         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.IsNullOrWhiteSpace(deviceId))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  5</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> -<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  6</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">  7</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> upper =<span style=\"color: rgba(0, 0, 0, 1);\"> deviceId.ToUpperInvariant();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  8</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> idx = upper.LastIndexOf(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">PHYSICALDRIVE</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, StringComparison.Ordinal);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  9</span>         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (idx &lt; <span style=\"color: rgba(128, 0, 128, 1);\">0</span>) <span style=\"color: rgba(0, 0, 255, 1);\">return</span> -<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 10</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 11</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> numPart = upper.Substring(idx + <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">PHYSICALDRIVE</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">.Length);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 12</span>         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span>.TryParse(numPart, NumberStyles.Integer, CultureInfo.InvariantCulture, <span style=\"color: rgba(0, 0, 255, 1);\">out</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span><span style=\"color: rgba(0, 0, 0, 1);\"> num))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 13</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> num;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 14</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 15</span>         <span style=\"color: rgba(0, 0, 255, 1);\">return</span> -<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 16</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 17</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 18</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> StorageBusType MapBusType(<span style=\"color: rgba(0, 0, 255, 1);\">string</span> interfaceType, <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> deviceName)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 19</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 20</span>         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.IsNullOrEmpty(interfaceType))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 21</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> StorageBusType.Unknown;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 22</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 23</span>         <span style=\"color: rgba(0, 0, 255, 1);\">switch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (interfaceType.ToUpperInvariant())\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 24</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 25</span>             <span style=\"color: rgba(0, 0, 255, 1);\">case</span> <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">SCSI</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 26</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (deviceName.Contains(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">SCSI</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 27</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 28</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> StorageBusType.Iscsi;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 29</span> <span style=\"color: rgba(0, 0, 0, 1);\">                }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 30</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> StorageBusType.Scsi;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 31</span>             <span style=\"color: rgba(0, 0, 255, 1);\">case</span> <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">IDE</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 32</span>             <span style=\"color: rgba(0, 0, 255, 1);\">case</span> <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ATA</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 33</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> StorageBusType.Ata;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 34</span>             <span style=\"color: rgba(0, 0, 255, 1);\">case</span> <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">USB</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 35</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> StorageBusType.Usb;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 36</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 可根据需要扩展映射</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 37</span>             <span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 38</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> StorageBusType.Unknown;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 39</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 40</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 41</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 42</span>     <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 43</span>     <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 填充 MountPaths（盘符）和 DiskUsedSize（GB）\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 44</span>     <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 45</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> OperateResult FillMountPathsAndUsedSize(LocalDisk diskInfo, ManagementObject diskDrive)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 46</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 47</span>         <span style=\"color: rgba(0, 0, 255, 1);\">long</span> totalUsedBytes = <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 48</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 49</span>         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 通过 Win32_DiskDriveToDiskPartition 关联到分区</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 50</span>         <span style=\"color: rgba(0, 0, 255, 1);\">using</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> partitionRel = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ManagementObjectSearcher(\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 51</span>                    <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ASSOCIATORS OF {Win32_DiskDrive.DeviceID='</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> + diskDrive[<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">DeviceID</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>] +\n<span style=\"color: rgba(0, 128, 128, 1);\"> 52</span>                    <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">'} WHERE AssocClass = Win32_DiskDriveToDiskPartition</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 53</span>         <span style=\"color: rgba(0, 0, 255, 1);\">using</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> partitions =<span style=\"color: rgba(0, 0, 0, 1);\"> partitionRel.Get())\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 54</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 55</span>             <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (ManagementObject partition <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> partitions)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 56</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 57</span>                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 通过 Win32_LogicalDiskToPartition 关联到逻辑磁盘（盘符）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 58</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">using</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> logicalRel = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ManagementObjectSearcher(\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 59</span>                            <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">ASSOCIATORS OF {Win32_DiskPartition.DeviceID='</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> + partition[<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">DeviceID</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>] +\n<span style=\"color: rgba(0, 128, 128, 1);\"> 60</span>                            <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">'} WHERE AssocClass = Win32_LogicalDiskToPartition</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 61</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">using</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> logicalDisks =<span style=\"color: rgba(0, 0, 0, 1);\"> logicalRel.Get())\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 62</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 63</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (ManagementObject logicalDisk <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> logicalDisks)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 64</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 65</span>                         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算已用空间</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 66</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (logicalDisk[<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Size</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>] != <span style=\"color: rgba(0, 0, 255, 1);\">null</span> &amp;&amp;\n<span style=\"color: rgba(0, 128, 128, 1);\"> 67</span>                             logicalDisk[<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">FreeSpace</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>] != <span style=\"color: rgba(0, 0, 255, 1);\">null</span> &amp;&amp;\n<span style=\"color: rgba(0, 128, 128, 1);\"> 68</span>                             <span style=\"color: rgba(0, 0, 255, 1);\">long</span>.TryParse(logicalDisk[<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Size</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>].ToString(), <span style=\"color: rgba(0, 0, 255, 1);\">out</span> <span style=\"color: rgba(0, 0, 255, 1);\">long</span> volSize) &amp;&amp;\n<span style=\"color: rgba(0, 128, 128, 1);\"> 69</span>                             <span style=\"color: rgba(0, 0, 255, 1);\">long</span>.TryParse(logicalDisk[<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">FreeSpace</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>].ToString(), <span style=\"color: rgba(0, 0, 255, 1);\">out</span> <span style=\"color: rgba(0, 0, 255, 1);\">long</span><span style=\"color: rgba(0, 0, 0, 1);\"> free))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 70</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 71</span>                             totalUsedBytes += (volSize -<span style=\"color: rgba(0, 0, 0, 1);\"> free);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 72</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 73</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 74</span> <span style=\"color: rgba(0, 0, 0, 1);\">                }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 75</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 76</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 77</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 78</span>         diskInfo.DiskUsedSize =<span style=\"color: rgba(0, 0, 0, 1);\">totalUsedBytes;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 79</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 80</span>         <span style=\"color: rgba(0, 0, 255, 1);\">try</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 81</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 82</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> paths =<span style=\"color: rgba(0, 0, 0, 1);\"> GetAccessPaths(diskInfo.Number);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 83</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> filtedPaths = paths.Where(i =&gt; !i.StartsWith(<span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\\\?\\Volume</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)).ToList();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 84</span>             diskInfo.MountPaths =<span style=\"color: rgba(0, 0, 0, 1);\"> filtedPaths;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 85</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> OperateResult.ToSuccess();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 86</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 87</span>         <span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (Exception e)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 88</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 89</span>            <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> OperateResult.ToError(e);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 90</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 91</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 92</span>     <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 93</span>     <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取磁盘的所有访问路径\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 94</span>     <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 95</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> List&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt; GetAccessPaths(<span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> diskNumber)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 96</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 97</span>         ManagementScope scope = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> ManagementScope(<span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\\\.\\root\\Microsoft\\Windows\\Storage</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 98</span> <span style=\"color: rgba(0, 0, 0, 1);\">        scope.Connect();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 99</span>         <span style=\"color: rgba(0, 0, 255, 1);\">string</span> query = $<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">SELECT * FROM MSFT_Partition WHERE DiskNumber = {diskNumber}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">100</span>         <span style=\"color: rgba(0, 0, 255, 1);\">using</span> ManagementObjectSearcher searcher = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> ManagementObjectSearcher(scope, <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ObjectQuery(query));\n</span><span style=\"color: rgba(0, 128, 128, 1);\">101</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> pathList = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">102</span>         <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> partition <span style=\"color: rgba(0, 0, 255, 1);\">in</span> searcher.Get().Cast&lt;ManagementObject&gt;<span style=\"color: rgba(0, 0, 0, 1);\">())\n</span><span style=\"color: rgba(0, 128, 128, 1);\">103</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">104</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取 AccessPaths 属性（数组）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">105</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> accessPaths = partition[<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">AccessPaths</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>] <span style=\"color: rgba(0, 0, 255, 1);\">as</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">[];\n</span><span style=\"color: rgba(0, 128, 128, 1);\">106</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (accessPaths == <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">107</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">108</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">continue</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">109</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">110</span> <span style=\"color: rgba(0, 0, 0, 1);\">            pathList.AddRange(accessPaths);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">111</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">112</span>         <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> pathList;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">113</span>     }</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<p>遍历磁盘列表，4块盘耗时接近1s：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/685541/202601/685541-20260112202253746-677311477.png\" /></p>\n<h1>DiskPart磁盘管理</h1>\n<p>diskpart 是 原生 Win32 命令行工具，内部大致通过：</p>\n<ul>\n<li>VDS / Storage Management API（老系统）</li>\n<li>新系统上，一部分功能由新的 Storage API 接管</li>\n<li>再往下还是 IOCTL 调用内核驱动</li>\n</ul>\n<p>调用层级如下，diskpart.exe<br />  -&gt; VDS / Storage Management API<br />     -&gt; 内核驱动 (disk.sys, partmgr.sys, volmgr.sys)<br />        -&gt; 设备硬件</p>\n<p>diskpart常用命令列表：</p>\n<ul>\n<li>list disk</li>\n<li>select disk 1</li>\n<li>detail disk</li>\n<li>list partition</li>\n<li>list volume</li>\n\n\n\n\n\n\n\n\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/685541/202601/685541-20260112202413306-148039174.png\" /></p>\n<p>DiskPart对WMI并不强依赖，基本上依赖服务就一个Virtual Disk了，操作也比较简单。但缺点也比较明显，访问性能比较差、磁盘操作使用Powersehell调用diskpart命令基本也在s级以上</p>\n<h1>Win32 IOCTL磁盘管理</h1>\n<p>IOCTL是指通过直接调用 Windows API DeviceIoControl 对磁盘、卷、文件句柄发送控制码：</p>\n<ul>\n<li>IOCTL_DISK_*</li>\n<li>IOCTL_STORAGE_*</li>\n<li>FSCTL_*（针对文件系统）</li>\n\n\n\n\n\n\n\n\n</ul>\n<p>IOCTL文档：<a href=\"https://learn.microsoft.com/zh-cn/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol\" rel=\"noopener nofollow\">deviceIoControl 函数 (ioapiset.h) - Win32 apps | Microsoft Learn</a>、<a href=\"https://learn.microsoft.com/zh-cn/windows/win32/api/winioctl/\" rel=\"noopener nofollow\">Winioctl.h 标头 - Win32 apps | Microsoft Learn</a></p>\n<p>磁盘管理详细文档：<a href=\"https://learn.microsoft.com/zh-cn/windows/win32/fileio/disk-management\" rel=\"noopener nofollow\">磁盘管理 - Win32 apps | Microsoft Learn</a></p>\n<p>WIN32方案，不依赖 VDS / WMI 等上层框架</p>\n<p>仅依赖：</p>\n<ul>\n<li>Win32 子系统 + 内核 I/O 栈</li>\n<li>对应的设备驱动（disk.sys, storport.sys, nvme.sys 等）</li>\n\n\n\n\n\n\n\n\n</ul>\n<p>需要基于WIN32API一层层处理细节，比如获取磁盘列表：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\"> 1</span>     <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 2</span>     <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 通过磁盘编号获取序列号SerialNumber\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 3</span>     <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 4</span>     <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;param name=\"diskNumber\"&gt;</span><span style=\"color: rgba(0, 128, 0, 1);\">磁盘编号</span><span style=\"color: rgba(128, 128, 128, 1);\">&lt;/param&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 5</span>     <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;param name=\"volumeMaps\"&gt;&lt;/param&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 6</span>     <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;returns&gt;&lt;/returns&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 7</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> OperateResult&lt;LocalDisk&gt; GetDiskInfoByDiskNumber(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> diskNumber, Dictionary&lt;<span style=\"color: rgba(0, 0, 255, 1);\">int</span>, List&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> volumeMaps)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 8</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 9</span>         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">逐个尝试 PhysicalDrive0..N</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">10</span>         <span style=\"color: rgba(0, 0, 255, 1);\">string</span> physicalDrive = <span style=\"color: rgba(128, 0, 0, 1);\">@\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\\\.\\PhysicalDrive</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> +<span style=\"color: rgba(0, 0, 0, 1);\"> diskNumber;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">11</span>         IntPtr hDisk =<span style=\"color: rgba(0, 0, 0, 1);\"> CreateFile(\n</span><span style=\"color: rgba(0, 128, 128, 1);\">12</span> <span style=\"color: rgba(0, 0, 0, 1);\">            physicalDrive,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">13</span> <span style=\"color: rgba(0, 0, 0, 1);\">            GENERIC_READ,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">14</span>             FILE_SHARE_READ | FILE_SHARE_WRITE |<span style=\"color: rgba(0, 0, 0, 1);\"> FILE_SHARE_DELETE,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">15</span> <span style=\"color: rgba(0, 0, 0, 1);\">            IntPtr.Zero,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">16</span> <span style=\"color: rgba(0, 0, 0, 1);\">            OPEN_EXISTING,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">17</span>             <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">18</span> <span style=\"color: rgba(0, 0, 0, 1);\">            IntPtr.Zero);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">19</span>         <span style=\"color: rgba(0, 0, 255, 1);\">try</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">20</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">21</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 不存在这个物理盘（或者无权限）,忽略此异常</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">22</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (hDisk ==<span style=\"color: rgba(0, 0, 0, 1);\"> INVALID_HANDLE_VALUE)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">23</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">24</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;LocalDisk&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToSuccess();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">25</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">26</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> diskInfo = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> LocalDisk();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">27</span>             diskInfo.Number =<span style=\"color: rgba(0, 0, 0, 1);\"> diskNumber;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">28</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">29</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">获取磁盘基础信息</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">30</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> getDiskPropertiesResult =<span style=\"color: rgba(0, 0, 0, 1);\"> GetDiskProperties(hDisk);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">31</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">getDiskPropertiesResult.Success)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">32</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">33</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;LocalDisk&gt;.ToError($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Get disk {physicalDrive} properties failed, {getDiskPropertiesResult.Message}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, getDiskPropertiesResult.Exception, getDiskPropertiesResult.Code);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">34</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">35</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> diskProperties =<span style=\"color: rgba(0, 0, 0, 1);\"> getDiskPropertiesResult.Data;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">36</span>             diskInfo.SerialNumber =<span style=\"color: rgba(0, 0, 0, 1);\"> diskProperties.SerialNumber;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">37</span>             diskInfo.DeviceName =<span style=\"color: rgba(0, 0, 0, 1);\"> diskProperties.DeviceName;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">38</span>             diskInfo.BusType =<span style=\"color: rgba(0, 0, 0, 1);\"> diskProperties.BusType;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">39</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">40</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">是否只读/联机</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">41</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> diskAttributesResult =<span style=\"color: rgba(0, 0, 0, 1);\"> GetDiskAttributes(hDisk);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">42</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">diskAttributesResult.Success)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">43</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">44</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;LocalDisk&gt;.ToError($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Get disk {diskProperties.DeviceName} attributes failed, {diskAttributesResult.Message}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, diskAttributesResult.Exception, diskAttributesResult.Code);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">45</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">46</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> diskStorageAttributes =<span style=\"color: rgba(0, 0, 0, 1);\"> diskAttributesResult.Data;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">47</span>             diskInfo.IsReadOnly =<span style=\"color: rgba(0, 0, 0, 1);\"> diskStorageAttributes.IsReadOnly;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">48</span>             diskInfo.IsOffline =<span style=\"color: rgba(0, 0, 0, 1);\"> diskStorageAttributes.IsOffline;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">49</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">50</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">磁盘容量</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">51</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> getDiskSizeResult =<span style=\"color: rgba(0, 0, 0, 1);\"> GetDiskSize(hDisk);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">52</span>             diskInfo.DiskSize =<span style=\"color: rgba(0, 0, 0, 1);\"> getDiskSizeResult.Data;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">53</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">54</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">获取分区信息</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">55</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> partitionInfoResult =<span style=\"color: rgba(0, 0, 0, 1);\"> GetPartitionInfo(hDisk);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">56</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">partitionInfoResult.Success)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">57</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">58</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;LocalDisk&gt;.ToError($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Get disk {diskProperties.DeviceName} partition failed, {partitionInfoResult.Message}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, partitionInfoResult.Exception, partitionInfoResult.Code);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">59</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">60</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> diskPartitionInfo =<span style=\"color: rgba(0, 0, 0, 1);\"> partitionInfoResult.Data;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">61</span>             diskInfo.PartitionStyle =<span style=\"color: rgba(0, 0, 0, 1);\"> (DiskPartitionStyle)diskPartitionInfo.PartitionStyle;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">62</span>             diskInfo.PartitionCount =<span style=\"color: rgba(0, 0, 0, 1);\"> diskPartitionInfo.PartitionCount;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">63</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">基础数据区分大小</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">64</span>             diskInfo.DiskAllocateSize = diskPartitionInfo.Partitions.FirstOrDefault(i =&gt; i.PartitionType.ToUpper() == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">EBD0A0A2-B9E5-4433-87C0-68B6B72699C7</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>)?.PartitionLength ?? <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">65</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">66</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">挂载路径</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">67</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (volumeMaps.TryGetValue(diskNumber, <span style=\"color: rgba(0, 0, 255, 1);\">out</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span> mounts) &amp;&amp; mounts != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">68</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">69</span>                 diskInfo.MountPaths =<span style=\"color: rgba(0, 0, 0, 1);\"> mounts;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">70</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">71</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">获取卷标名称</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">72</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (diskInfo.MountPaths.Any())\n</span><span style=\"color: rgba(0, 128, 128, 1);\">73</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">74</span>                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">通过任意一个mountPath获取</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">75</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">var</span> mountPath =<span style=\"color: rgba(0, 0, 0, 1);\"> diskInfo.MountPaths.First();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">76</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">var</span> getVolumeInfoResult =<span style=\"color: rgba(0, 0, 0, 1);\"> GetVolumeInfo(mountPath);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">77</span>                 diskInfo.Tag = getVolumeInfoResult.Data?.VolumeLabel ?? <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">78</span>                 diskInfo.FileSystemType = getVolumeInfoResult.Data?.FileSystemType ?? <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.Empty;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">79</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">80</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">磁盘已使用大小</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">81</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (diskInfo.MountPaths.Any())\n</span><span style=\"color: rgba(0, 128, 128, 1);\">82</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">83</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">long</span> diskUsedSize = <span style=\"color: rgba(128, 0, 128, 1);\">0L</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">84</span>                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">通过所有mountPath相加,获取磁盘已使用大小</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">85</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> mountPath <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> diskInfo.MountPaths)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">86</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">87</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">var</span> usageByMountPathResult =<span style=\"color: rgba(0, 0, 0, 1);\"> GetDiskSizeUsageByMountPath(mountPath);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">88</span>                     diskUsedSize += usageByMountPathResult.Data?.UsedBytes ?? <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">89</span> <span style=\"color: rgba(0, 0, 0, 1);\">                }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">90</span>                 diskInfo.DiskUsedSize =<span style=\"color: rgba(0, 0, 0, 1);\"> diskUsedSize;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">91</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">92</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;LocalDisk&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToSuccess(diskInfo);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">93</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">94</span>         <span style=\"color: rgba(0, 0, 255, 1);\">finally</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">95</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">96</span> <span style=\"color: rgba(0, 0, 0, 1);\">            CloseHandle(hDisk);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">97</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">98</span>     }</pre>\n</div>\n<p>其中磁盘属性获取细节，就不展示了：</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_ed064c18-3858-41af-a354-0d53b9fb10bf\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_ed064c18-3858-41af-a354-0d53b9fb10bf\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_ed064c18-3858-41af-a354-0d53b9fb10bf\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">  1</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">  2</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取所有磁盘\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  3</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">  4</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;returns&gt;&lt;/returns&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">  5</span>         <span style=\"color: rgba(0, 0, 255, 1);\">public</span> OperateResult&lt;List&lt;LocalDisk&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GetDisks()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  6</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  7</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 先拿卷 -&gt; 卷所属的物理磁盘号 + 盘符/挂载点</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">  8</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> getVolumesResult =<span style=\"color: rgba(0, 0, 0, 1);\"> GetAllVolumeMountPaths();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  9</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">getVolumesResult.Success)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 10</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 11</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;List&lt;LocalDisk&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToError(getVolumesResult.Message, getVolumesResult.Exception, getVolumesResult.Code);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 12</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 13</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> volumeMaps =<span style=\"color: rgba(0, 0, 0, 1);\"> getVolumesResult.Data;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 14</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 15</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2. 获取磁盘列表</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 16</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> diskList = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;LocalDisk&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 17</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 根据卷信息推一个最大磁盘号，同时至少查询16 个</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 18</span>             <span style=\"color: rgba(0, 0, 255, 1);\">int</span> maxDiskNumberCount = Math.Max(volumeMaps.Max(i =&gt; i.Key), <span style=\"color: rgba(128, 0, 128, 1);\">16</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 19</span>             <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> diskNumber = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; diskNumber &lt;= maxDiskNumberCount; diskNumber++<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 20</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 21</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">var</span> getDiskResult =<span style=\"color: rgba(0, 0, 0, 1);\"> GetDiskInfoByDiskNumber(diskNumber, volumeMaps);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 22</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">getDiskResult.Success)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 23</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 24</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">结束查询</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 25</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (diskNumber == maxDiskNumberCount - <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 26</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 27</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">return</span> getDiskResult.ToResult&lt;List&lt;LocalDisk&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 28</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 29</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">继续查询其它</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 30</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">continue</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 31</span> <span style=\"color: rgba(0, 0, 0, 1);\">                }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 32</span>                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">可能为空</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 33</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (getDiskResult.Data == <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 34</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 35</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">continue</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 36</span> <span style=\"color: rgba(0, 0, 0, 1);\">                }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 37</span> <span style=\"color: rgba(0, 0, 0, 1);\">                diskList.Add(getDiskResult.Data);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 38</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 39</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 40</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;List&lt;LocalDisk&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToSuccess(diskList);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 41</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 42</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 43</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 44</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取所有磁盘卷的挂载路径信息\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 45</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;remarks&gt;</span><span style=\"color: rgba(0, 128, 0, 1);\">通过枚举卷，并使用 IOCTL_STORAGE_GET_DEVICE_NUMBER 映射到设备号。</span><span style=\"color: rgba(128, 128, 128, 1);\">&lt;/remarks&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 46</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 47</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;returns&gt;</span><span style=\"color: rgba(0, 128, 0, 1);\">PhysicalDiskNumber -&gt; 对应的所有挂载路径（盘符、挂载点）</span><span style=\"color: rgba(128, 128, 128, 1);\">&lt;/returns&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 48</span>         <span style=\"color: rgba(0, 0, 255, 1);\">private</span> OperateResult&lt;Dictionary&lt;<span style=\"color: rgba(0, 0, 255, 1);\">int</span>, List&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt;&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GetAllVolumeMountPaths()\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 49</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 50</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> diskDict = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Dictionary&lt;<span style=\"color: rgba(0, 0, 255, 1);\">int</span>, List&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 51</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 52</span>             <span style=\"color: rgba(0, 0, 255, 1);\">int</span> maxPath = <span style=\"color: rgba(128, 0, 128, 1);\">1024</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 53</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> volNameSb = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> StringBuilder(maxPath);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 54</span>             IntPtr findVolumeHandle = FindFirstVolumeW(volNameSb, (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span><span style=\"color: rgba(0, 0, 0, 1);\">)volNameSb.Capacity);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 55</span>             <span style=\"color: rgba(0, 0, 255, 1);\">try</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 56</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 57</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (findVolumeHandle == (IntPtr)(-<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 58</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 59</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;Dictionary&lt;<span style=\"color: rgba(0, 0, 255, 1);\">int</span>, List&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt;&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToSuccess(diskDict);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 60</span> <span style=\"color: rgba(0, 0, 0, 1);\">                }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 61</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">while</span> (<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 62</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 63</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">string</span> volumeName =<span style=\"color: rgba(0, 0, 0, 1);\"> volNameSb.ToString();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 64</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> volumeName: \\\\?\\Volume{GUID}\\\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 65</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 66</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打开卷设备</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 67</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">string</span> volumePathForDevice = volumeName.TrimEnd(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">\\\\</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>); <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> \\\\?\\Volume{GUID}</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 68</span>                     IntPtr hVolume =<span style=\"color: rgba(0, 0, 0, 1);\"> CreateFile(\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 69</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        volumePathForDevice,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 70</span>                         <span style=\"color: rgba(128, 0, 128, 1);\">0</span>, <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 只需要 IOCTL，不读写</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 71</span>                         FILE_SHARE_READ |<span style=\"color: rgba(0, 0, 0, 1);\"> FILE_SHARE_WRITE,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 72</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        IntPtr.Zero,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 73</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        OPEN_EXISTING,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 74</span>                         <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 75</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        IntPtr.Zero);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 76</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 77</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">uint</span>? diskNumber = <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 78</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 79</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (hVolume != (IntPtr)(-<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 80</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 81</span>                         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 取 STORAGE_DEVICE_NUMBER</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 82</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">uint</span> size = (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span>)Marshal.SizeOf&lt;STORAGE_DEVICE_NUMBER&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 83</span>                         IntPtr outBuf = Marshal.AllocHGlobal((<span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">)size);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 84</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">try</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 85</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 86</span>                             <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (DeviceIoControl(\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 87</span> <span style=\"color: rgba(0, 0, 0, 1);\">                                    hVolume,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 88</span> <span style=\"color: rgba(0, 0, 0, 1);\">                                    IOCTL_STORAGE_GET_DEVICE_NUMBER,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 89</span> <span style=\"color: rgba(0, 0, 0, 1);\">                                    IntPtr.Zero,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 90</span>                                     <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 91</span> <span style=\"color: rgba(0, 0, 0, 1);\">                                    outBuf,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 92</span> <span style=\"color: rgba(0, 0, 0, 1);\">                                    size,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 93</span>                                     <span style=\"color: rgba(0, 0, 255, 1);\">out</span> <span style=\"color: rgba(0, 0, 255, 1);\">uint</span><span style=\"color: rgba(0, 0, 0, 1);\"> bytesReturned,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 94</span> <span style=\"color: rgba(0, 0, 0, 1);\">                                    IntPtr.Zero))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 95</span> <span style=\"color: rgba(0, 0, 0, 1);\">                            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 96</span>                                 STORAGE_DEVICE_NUMBER devNum = Marshal.PtrToStructure&lt;STORAGE_DEVICE_NUMBER&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(outBuf);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 97</span>                                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> DeviceType 为 FILE_DEVICE_DISK(0x07) 一般表示物理磁盘</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 98</span>                                 diskNumber =<span style=\"color: rgba(0, 0, 0, 1);\"> devNum.DeviceNumber;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 99</span> <span style=\"color: rgba(0, 0, 0, 1);\">                            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">100</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">101</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">finally</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">102</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">103</span> <span style=\"color: rgba(0, 0, 0, 1);\">                            Marshal.FreeHGlobal(outBuf);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">104</span> <span style=\"color: rgba(0, 0, 0, 1);\">                            CloseHandle(hVolume);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">105</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">106</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">107</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">108</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (diskNumber.HasValue)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">109</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">110</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!diskDict.TryGetValue((<span style=\"color: rgba(0, 0, 255, 1);\">int</span>)diskNumber.Value, <span style=\"color: rgba(0, 0, 255, 1);\">out</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span><span style=\"color: rgba(0, 0, 0, 1);\"> list))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">111</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">112</span>                             list = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">113</span>                             diskDict[(<span style=\"color: rgba(0, 0, 255, 1);\">int</span>)diskNumber.Value] =<span style=\"color: rgba(0, 0, 0, 1);\"> list;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">114</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">115</span>                         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取卷的挂载路径列表（可能有多个）</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">116</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> getMountPathsResult =<span style=\"color: rgba(0, 0, 0, 1);\"> GetMountPathsForVolume(volumeName);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">117</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">getMountPathsResult.Success)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">118</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">119</span>                             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;Dictionary&lt;<span style=\"color: rgba(0, 0, 255, 1);\">int</span>, List&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt;&gt;&gt;.ToError($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">磁盘{diskNumber}卷挂载路径获取失败, {getMountPathsResult.Message}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, getMountPathsResult.Exception, getMountPathsResult.Code);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">120</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">121</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> mp <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> getMountPathsResult.Data)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">122</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">123</span>                             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">list.Contains(mp))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">124</span> <span style=\"color: rgba(0, 0, 0, 1);\">                                list.Add(mp);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">125</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">126</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">127</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">128</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 下一卷</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">129</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    volNameSb.Clear();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">130</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    volNameSb.EnsureCapacity(maxPath);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">131</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">132</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!FindNextVolumeW(findVolumeHandle, volNameSb, (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span><span style=\"color: rgba(0, 0, 0, 1);\">)volNameSb.Capacity))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">133</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">134</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">int</span> err =<span style=\"color: rgba(0, 0, 0, 1);\"> Marshal.GetLastWin32Error();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">135</span>                         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ERROR_NO_MORE_FILES</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">136</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (err == <span style=\"color: rgba(128, 0, 128, 1);\">18</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">137</span>                             <span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">138</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">139</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;Dictionary&lt;<span style=\"color: rgba(0, 0, 255, 1);\">int</span>, List&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt;&gt;&gt;.ToWin32Error(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">query disk volumes failed</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, err);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">140</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">141</span> <span style=\"color: rgba(0, 0, 0, 1);\">                }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">142</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">143</span>             <span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (Exception ex)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">144</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">145</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;Dictionary&lt;<span style=\"color: rgba(0, 0, 255, 1);\">int</span>, List&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt;&gt;&gt;.ToError(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">query disk volumes error</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, ex);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">146</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">147</span>             <span style=\"color: rgba(0, 0, 255, 1);\">finally</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">148</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">149</span> <span style=\"color: rgba(0, 0, 0, 1);\">                FindVolumeClose(findVolumeHandle);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">150</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">151</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;Dictionary&lt;<span style=\"color: rgba(0, 0, 255, 1);\">int</span>, List&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt;&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToSuccess(diskDict);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">152</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">153</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">154</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">155</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取分区信息\n</span><span style=\"color: rgba(0, 128, 128, 1);\">156</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">157</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;param name=\"hDisk\"&gt;&lt;/param&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">158</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;returns&gt;&lt;/returns&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">159</span>         <span style=\"color: rgba(0, 0, 255, 1);\">private</span> OperateResult&lt;DiskPartitionInfo&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GetPartitionInfo(IntPtr hDisk)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">160</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">161</span>             <span style=\"color: rgba(0, 0, 255, 1);\">int</span> outSize = Marshal.SizeOf&lt;DRIVE_LAYOUT_INFORMATION_EX&gt;() + <span style=\"color: rgba(128, 0, 128, 1);\">128</span> * <span style=\"color: rgba(128, 0, 128, 1);\">64</span>; <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 给多一点空间</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">162</span>             IntPtr outBuffer =<span style=\"color: rgba(0, 0, 0, 1);\"> Marshal.AllocHGlobal(outSize);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">163</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">164</span>             <span style=\"color: rgba(0, 0, 255, 1);\">try</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">165</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">166</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">DeviceIoControl(\n</span><span style=\"color: rgba(0, 128, 128, 1);\">167</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        hDisk,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">168</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        IOCTL_DISK_GET_DRIVE_LAYOUT_EX,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">169</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        IntPtr.Zero,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">170</span>                         <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">171</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        outBuffer,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">172</span>                         (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span><span style=\"color: rgba(0, 0, 0, 1);\">)outSize,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">173</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">out</span><span style=\"color: rgba(0, 0, 0, 1);\"> _,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">174</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        IntPtr.Zero))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">175</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">176</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;DiskPartitionInfo&gt;.ToWin32Error(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">DeviceIoControl.IOCTL_DISK_GET_DRIVE_LAYOUT_EX failed</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, Marshal.GetLastWin32Error());\n</span><span style=\"color: rgba(0, 128, 128, 1);\">177</span> <span style=\"color: rgba(0, 0, 0, 1);\">                }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">178</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">179</span>                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 只取结构开头</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">180</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">var</span> layout = Marshal.PtrToStructure&lt;DRIVE_LAYOUT_INFORMATION_EX_HEADER&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(outBuffer);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">181</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">var</span> partitionInfo = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> DiskPartitionInfo()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">182</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">183</span>                     PartitionCount = (<span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">)layout.PartitionCount,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">184</span>                     PartitionStyle =<span style=\"color: rgba(0, 0, 0, 1);\"> layout.PartitionStyle,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">185</span>                     DiskId =<span style=\"color: rgba(0, 0, 0, 1);\"> layout.Gpt.DiskId,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">186</span>                     StartingUsableOffset =<span style=\"color: rgba(0, 0, 0, 1);\"> layout.Gpt.StartingUsableOffset,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">187</span>                     UsableLength =<span style=\"color: rgba(0, 0, 0, 1);\"> layout.Gpt.UsableLength,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">188</span>                     MaxPartitionCount =<span style=\"color: rgba(0, 0, 0, 1);\"> layout.Gpt.MaxPartitionCount\n</span><span style=\"color: rgba(0, 128, 128, 1);\">189</span> <span style=\"color: rgba(0, 0, 0, 1);\">                };\n</span><span style=\"color: rgba(0, 128, 128, 1);\">190</span>                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 指向第一个 PARTITION_INFORMATION_EX 的指针：</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">191</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">192</span>                 IntPtr pCurrent = IntPtr.Add(outBuffer, Marshal.SizeOf&lt;DRIVE_LAYOUT_INFORMATION_EX&gt;<span style=\"color: rgba(0, 0, 0, 1);\">());\n</span><span style=\"color: rgba(0, 128, 128, 1);\">193</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">int</span> partSize = Marshal.SizeOf&lt;PARTITION_INFORMATION_EX&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">194</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt; layout.PartitionCount; i++<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">195</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">196</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">var</span> part = Marshal.PtrToStructure&lt;PARTITION_INFORMATION_EX&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(pCurrent);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">197</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">var</span> item = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> PartitionEntryInfo\n</span><span style=\"color: rgba(0, 128, 128, 1);\">198</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">199</span>                         PartitionNumber = (<span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">)part.PartitionNumber,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">200</span>                         StartingOffset =<span style=\"color: rgba(0, 0, 0, 1);\"> part.StartingOffset,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">201</span>                         PartitionLength =<span style=\"color: rgba(0, 0, 0, 1);\"> part.PartitionLength,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">202</span>                         PartitionType =<span style=\"color: rgba(0, 0, 0, 1);\"> part.Gpt.PartitionType.ToString(),\n</span><span style=\"color: rgba(0, 128, 128, 1);\">203</span>                         PartitionName =<span style=\"color: rgba(0, 0, 0, 1);\"> part.Gpt.Name\n</span><span style=\"color: rgba(0, 128, 128, 1);\">204</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    };\n</span><span style=\"color: rgba(0, 128, 128, 1);\">205</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">206</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    partitionInfo.Partitions.Add(item);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">207</span>                     pCurrent =<span style=\"color: rgba(0, 0, 0, 1);\"> IntPtr.Add(pCurrent, partSize);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">208</span> <span style=\"color: rgba(0, 0, 0, 1);\">                }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">209</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">210</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;DiskPartitionInfo&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToSuccess(partitionInfo);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">211</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">212</span>             <span style=\"color: rgba(0, 0, 255, 1);\">finally</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">213</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">214</span> <span style=\"color: rgba(0, 0, 0, 1);\">                Marshal.FreeHGlobal(outBuffer);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">215</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">216</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">217</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">218</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">219</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取磁盘静态属性\n</span><span style=\"color: rgba(0, 128, 128, 1);\">220</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">221</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;param name=\"hDisk\"&gt;&lt;/param&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">222</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;returns&gt;&lt;/returns&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">223</span>         <span style=\"color: rgba(0, 0, 255, 1);\">private</span> OperateResult&lt;DiskStorageProperty&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GetDiskProperties(IntPtr hDisk)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">224</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">225</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> storageProperties = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> DiskStorageProperty();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">226</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> query = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> STORAGE_PROPERTY_QUERY\n</span><span style=\"color: rgba(0, 128, 128, 1);\">227</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">228</span>                 PropertyId =<span style=\"color: rgba(0, 0, 0, 1);\"> STORAGE_PROPERTY_ID.StorageDeviceProperty,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">229</span>                 QueryType =<span style=\"color: rgba(0, 0, 0, 1);\"> STORAGE_QUERY_TYPE.PropertyStandardQuery,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">230</span>                 AdditionalParameters = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> <span style=\"color: rgba(0, 0, 255, 1);\">byte</span>[<span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">]\n</span><span style=\"color: rgba(0, 128, 128, 1);\">231</span> <span style=\"color: rgba(0, 0, 0, 1);\">            };\n</span><span style=\"color: rgba(0, 128, 128, 1);\">232</span>             <span style=\"color: rgba(0, 0, 255, 1);\">uint</span> allocSize = <span style=\"color: rgba(128, 0, 128, 1);\">1024</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">233</span>             IntPtr buffer = Marshal.AllocHGlobal((<span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">)allocSize);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">234</span>             <span style=\"color: rgba(0, 0, 255, 1);\">try</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">235</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">236</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">DeviceIoControl(\n</span><span style=\"color: rgba(0, 128, 128, 1);\">237</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        hDisk,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">238</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        IOCTL_STORAGE_QUERY_PROPERTY,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">239</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">ref</span><span style=\"color: rgba(0, 0, 0, 1);\"> query,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">240</span>                         (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span>)Marshal.SizeOf&lt;STORAGE_PROPERTY_QUERY&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(),\n</span><span style=\"color: rgba(0, 128, 128, 1);\">241</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        buffer,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">242</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        allocSize,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">243</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">out</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span><span style=\"color: rgba(0, 0, 0, 1);\"> bytesReturned,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">244</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        IntPtr.Zero))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">245</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">246</span>                     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">读取失败</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">247</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">int</span> err =<span style=\"color: rgba(0, 0, 0, 1);\"> Marshal.GetLastWin32Error();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">248</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (err == ERROR_INSUFFICIENT_BUFFER &amp;&amp; bytesReturned &gt;<span style=\"color: rgba(0, 0, 0, 1);\"> allocSize)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">249</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">250</span>                         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 重新分配更大缓冲区</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">251</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        Marshal.FreeHGlobal(buffer);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">252</span>                         allocSize =<span style=\"color: rgba(0, 0, 0, 1);\"> bytesReturned;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">253</span>                         buffer = Marshal.AllocHGlobal((<span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">)allocSize);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">254</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">DeviceIoControl(\n</span><span style=\"color: rgba(0, 128, 128, 1);\">255</span> <span style=\"color: rgba(0, 0, 0, 1);\">                                hDisk,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">256</span> <span style=\"color: rgba(0, 0, 0, 1);\">                                IOCTL_STORAGE_QUERY_PROPERTY,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">257</span>                                 <span style=\"color: rgba(0, 0, 255, 1);\">ref</span><span style=\"color: rgba(0, 0, 0, 1);\"> query,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">258</span>                                 (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span>)Marshal.SizeOf&lt;STORAGE_PROPERTY_QUERY&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(),\n</span><span style=\"color: rgba(0, 128, 128, 1);\">259</span> <span style=\"color: rgba(0, 0, 0, 1);\">                                buffer,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">260</span> <span style=\"color: rgba(0, 0, 0, 1);\">                                allocSize,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">261</span>                                 <span style=\"color: rgba(0, 0, 255, 1);\">out</span><span style=\"color: rgba(0, 0, 0, 1);\"> bytesReturned,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">262</span> <span style=\"color: rgba(0, 0, 0, 1);\">                                IntPtr.Zero))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">263</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">264</span>                             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">重新分配缓冲区，读取失败</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">265</span>                             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;DiskStorageProperty&gt;.ToWin32Error(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">DeviceIoControl.IOCTL_STORAGE_QUERY_PROPERTY execute failed after adjust buffer size</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, Marshal.GetLastWin32Error());\n</span><span style=\"color: rgba(0, 128, 128, 1);\">266</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">267</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">268</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">else</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">269</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">270</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;DiskStorageProperty&gt;.ToWin32Error(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">DeviceIoControl.IOCTL_STORAGE_QUERY_PROPERTY execute failed</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, err);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">271</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">272</span> <span style=\"color: rgba(0, 0, 0, 1);\">                }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">273</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">274</span>                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 至少要包含 Version/Size/几个 offset</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">275</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (bytesReturned &lt; <span style=\"color: rgba(128, 0, 128, 1);\">24</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">276</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;DiskStorageProperty&gt;.ToError($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">DeviceIoControl.IOCTL_STORAGE_QUERY_PROPERTY execute success but bytesReturned {bytesReturned} is lower than 24</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">277</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">278</span>                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> --- 读取头部固定字段（按官方 C 结构手工偏移）---\n</span><span style=\"color: rgba(0, 128, 128, 1);\">279</span>                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Size    (ULONG) at offset 0x04</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">280</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">uint</span> size = (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span>)Marshal.ReadInt32(buffer, <span style=\"color: rgba(128, 0, 128, 1);\">4</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">281</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (size &gt; bytesReturned) size =<span style=\"color: rgba(0, 0, 0, 1);\"> bytesReturned;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">282</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">283</span>                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 磁盘序列号，同 Get-Disk 的 SerialNumber</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">284</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">uint</span> serialOffset = (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span>)Marshal.ReadInt32(buffer, <span style=\"color: rgba(128, 0, 128, 1);\">0x18</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">285</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">string</span> serialRaw =<span style=\"color: rgba(0, 0, 0, 1);\"> ReadAnsiStringSafe(buffer, size, serialOffset);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">286</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">string</span> serialClean =<span style=\"color: rgba(0, 0, 0, 1);\"> CleanSerialString(serialRaw);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">287</span>                 storageProperties.SerialNumber =<span style=\"color: rgba(0, 0, 0, 1);\"> serialClean;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">288</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">289</span>                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 磁盘厂商/名称相关</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">290</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">uint</span> vendorOffset = (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span>)Marshal.ReadInt32(buffer, <span style=\"color: rgba(128, 0, 128, 1);\">0x0C</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">291</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">uint</span> productOffset = (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span>)Marshal.ReadInt32(buffer, <span style=\"color: rgba(128, 0, 128, 1);\">0x10</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">292</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">uint</span> revisionOffset = (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span>)Marshal.ReadInt32(buffer, <span style=\"color: rgba(128, 0, 128, 1);\">0x14</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">293</span>                 storageProperties.Vendor =<span style=\"color: rgba(0, 0, 0, 1);\"> ReadAnsiStringSafe(buffer, size, vendorOffset);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">294</span>                 storageProperties.Product =<span style=\"color: rgba(0, 0, 0, 1);\"> ReadAnsiStringSafe(buffer, size, productOffset);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">295</span>                 storageProperties.Version =<span style=\"color: rgba(0, 0, 0, 1);\"> ReadAnsiStringSafe(buffer, size, revisionOffset);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">296</span>                 storageProperties.DeviceName = $<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">{storageProperties.Vendor} {storageProperties.Product}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">297</span>                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> BusType</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">298</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">uint</span> busTypeOffset = (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span>)Marshal.ReadInt32(buffer, <span style=\"color: rgba(128, 0, 128, 1);\">0x1C</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">299</span>                 storageProperties.BusType = Enum.IsDefined(<span style=\"color: rgba(0, 0, 255, 1);\">typeof</span>(StorageBusType), (<span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">)busTypeOffset)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">300</span>                     ?<span style=\"color: rgba(0, 0, 0, 1);\"> (StorageBusType)busTypeOffset\n</span><span style=\"color: rgba(0, 128, 128, 1);\">301</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    : StorageBusType.Unknown;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">302</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;DiskStorageProperty&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToSuccess(storageProperties);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">303</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">304</span>             <span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (Exception ex)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">305</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">306</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;DiskStorageProperty&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToError(ex);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">307</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">308</span>             <span style=\"color: rgba(0, 0, 255, 1);\">finally</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">309</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">310</span> <span style=\"color: rgba(0, 0, 0, 1);\">                Marshal.FreeHGlobal(buffer);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">311</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">312</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">313</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">314</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">315</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取磁盘大小（Bytes）\n</span><span style=\"color: rgba(0, 128, 128, 1);\">316</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">317</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;param name=\"hDisk\"&gt;&lt;/param&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">318</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;returns&gt;&lt;/returns&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">319</span>         <span style=\"color: rgba(0, 0, 255, 1);\">public</span> OperateResult&lt;<span style=\"color: rgba(0, 0, 255, 1);\">long</span>&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GetDiskSize(IntPtr hDisk)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">320</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">321</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 用一个足够大的缓冲区，一般 1024 字节足够</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">322</span>             <span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> bufferSize = <span style=\"color: rgba(128, 0, 128, 1);\">1024</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">323</span>             IntPtr buffer =<span style=\"color: rgba(0, 0, 0, 1);\"> Marshal.AllocHGlobal(bufferSize);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">324</span>             <span style=\"color: rgba(0, 0, 255, 1);\">try</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">325</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">326</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">bool</span> ok =<span style=\"color: rgba(0, 0, 0, 1);\"> DeviceIoControl(\n</span><span style=\"color: rgba(0, 128, 128, 1);\">327</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    hDisk,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">328</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    IOCTL_DISK_GET_DRIVE_GEOMETRY_EX,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">329</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    IntPtr.Zero,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">330</span>                     <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">331</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    buffer,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">332</span>                     (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span><span style=\"color: rgba(0, 0, 0, 1);\">)bufferSize,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">333</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">out</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span><span style=\"color: rgba(0, 0, 0, 1);\"> bytesReturned,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">334</span> <span style=\"color: rgba(0, 0, 0, 1);\">                    IntPtr.Zero);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">335</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">ok)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">336</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;<span style=\"color: rgba(0, 0, 255, 1);\">long</span>&gt;.ToError(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">DeviceIoControl.IOCTL_DISK_GET_DRIVE_GEOMETRY_EX failed</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, Marshal.GetLastWin32Error());\n</span><span style=\"color: rgba(0, 128, 128, 1);\">337</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (bytesReturned &lt; Marshal.SizeOf&lt;DISK_GEOMETRY_EX&gt;<span style=\"color: rgba(0, 0, 0, 1);\">())\n</span><span style=\"color: rgba(0, 128, 128, 1);\">338</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;<span style=\"color: rgba(0, 0, 255, 1);\">long</span>&gt;.ToSuccess(<span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">339</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">340</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">var</span> geomEx = Marshal.PtrToStructure&lt;DISK_GEOMETRY_EX&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(buffer);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">341</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;<span style=\"color: rgba(0, 0, 255, 1);\">long</span>&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToSuccess(geomEx.DiskSize);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">342</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">343</span>             <span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (Exception e)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">344</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">345</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;<span style=\"color: rgba(0, 0, 255, 1);\">long</span>&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToError(e);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">346</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">347</span>             <span style=\"color: rgba(0, 0, 255, 1);\">finally</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">348</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">349</span> <span style=\"color: rgba(0, 0, 0, 1);\">                Marshal.FreeHGlobal(buffer);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">350</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">351</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">352</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">353</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">354</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取磁盘扩展属性\n</span><span style=\"color: rgba(0, 128, 128, 1);\">355</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">356</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;param name=\"hDisk\"&gt;&lt;/param&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">357</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;returns&gt;&lt;/returns&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">358</span>         <span style=\"color: rgba(0, 0, 255, 1);\">private</span> OperateResult&lt;DiskStorageAttribues&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GetDiskAttributes(IntPtr hDisk)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">359</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">360</span>             <span style=\"color: rgba(0, 0, 255, 1);\">try</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">361</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">362</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">int</span> getSize = Marshal.SizeOf&lt;GET_DISK_ATTRIBUTES&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">363</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">var</span> getAttr = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> GET_DISK_ATTRIBUTES\n</span><span style=\"color: rgba(0, 128, 128, 1);\">364</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">365</span>                     Version = (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span>)getSize, <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 关键：Version = sizeof(GET_DISK_ATTRIBUTES)</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">366</span>                     Reserved1 = <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">367</span>                     Attributes = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">368</span> <span style=\"color: rgba(0, 0, 0, 1);\">                };\n</span><span style=\"color: rgba(0, 128, 128, 1);\">369</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">370</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">DeviceIoControl_DiskAttributes(\n</span><span style=\"color: rgba(0, 128, 128, 1);\">371</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        hDisk,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">372</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        IOCTL_DISK_GET_DISK_ATTRIBUTES,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">373</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">ref</span><span style=\"color: rgba(0, 0, 0, 1);\"> getAttr,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">374</span>                         (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span><span style=\"color: rgba(0, 0, 0, 1);\">)getSize,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">375</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">ref</span><span style=\"color: rgba(0, 0, 0, 1);\"> getAttr,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">376</span>                         (<span style=\"color: rgba(0, 0, 255, 1);\">uint</span><span style=\"color: rgba(0, 0, 0, 1);\">)getSize,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">377</span>                         <span style=\"color: rgba(0, 0, 255, 1);\">out</span><span style=\"color: rgba(0, 0, 0, 1);\"> _,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">378</span> <span style=\"color: rgba(0, 0, 0, 1);\">                        IntPtr.Zero))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">379</span> <span style=\"color: rgba(0, 0, 0, 1);\">                {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">380</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;DiskStorageAttribues&gt;.ToWin32Error(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">IOCTL_DISK_GET_DISK_ATTRIBUTES 失败</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, Marshal.GetLastWin32Error());\n</span><span style=\"color: rgba(0, 128, 128, 1);\">381</span> <span style=\"color: rgba(0, 0, 0, 1);\">                }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">382</span>                 <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">磁盘扩展属性</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">383</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">var</span> diskStorageAttributes = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> DiskStorageAttribues();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">384</span>                 diskStorageAttributes.IsOffline = (getAttr.Attributes &amp; DISK_ATTRIBUTE_OFFLINE) != <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">385</span>                 diskStorageAttributes.IsReadOnly = (getAttr.Attributes &amp; DISK_ATTRIBUTE_READ_ONLY) != <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">386</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;DiskStorageAttribues&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToSuccess(diskStorageAttributes);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">387</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">388</span>             <span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (Exception ex)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">389</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">390</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;DiskStorageAttribues&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToError(ex);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">391</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">392</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">393</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">394</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">395</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 通过任意挂载路径（盘符、目录挂载点、Volume GUID）获取卷大小与使用量\n</span><span style=\"color: rgba(0, 128, 128, 1);\">396</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">397</span>         <span style=\"color: rgba(0, 0, 255, 1);\">private</span> OperateResult&lt;DiskSizeUsage&gt; GetDiskSizeUsageByMountPath(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> mountPath)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">398</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">399</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.IsNullOrWhiteSpace(mountPath))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">400</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">401</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;DiskSizeUsage&gt;.ToError($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">parameter {nameof(mountPath)} is empty</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">402</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">403</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">404</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 确保路径末尾有反斜杠对某些场景更稳妥</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">405</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!mountPath.EndsWith(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\\\</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">406</span>                 mountPath += <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\\\</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">407</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">408</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">GetDiskFreeSpaceExW(mountPath,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">409</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">out</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span><span style=\"color: rgba(0, 0, 0, 1);\"> freeAvailable,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">410</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">out</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span><span style=\"color: rgba(0, 0, 0, 1);\"> totalBytes,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">411</span>                     <span style=\"color: rgba(0, 0, 255, 1);\">out</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span><span style=\"color: rgba(0, 0, 0, 1);\"> totalFreeBytes))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">412</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">413</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;DiskSizeUsage&gt;.ToError(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">GetDiskFreeSpaceExW failed</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, Marshal.GetLastWin32Error());\n</span><span style=\"color: rgba(0, 128, 128, 1);\">414</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">415</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">416</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;DiskSizeUsage&gt;.ToSuccess(<span style=\"color: rgba(0, 0, 255, 1);\">new</span> DiskSizeUsage((<span style=\"color: rgba(0, 0, 255, 1);\">long</span>)totalBytes, (<span style=\"color: rgba(0, 0, 255, 1);\">long</span><span style=\"color: rgba(0, 0, 0, 1);\">)totalFreeBytes));\n</span><span style=\"color: rgba(0, 128, 128, 1);\">417</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">418</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">419</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">420</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 通过挂载路径获取卷信息\n</span><span style=\"color: rgba(0, 128, 128, 1);\">421</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">422</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;param name=\"mountPath\"&gt;</span><span style=\"color: rgba(0, 128, 0, 1);\">盘符, e.g. \"E:\\\\\"</span><span style=\"color: rgba(128, 128, 128, 1);\">&lt;/param&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">423</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;returns&gt;&lt;/returns&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">424</span>         <span style=\"color: rgba(0, 0, 255, 1);\">private</span> OperateResult&lt;VolumeInfo&gt; GetVolumeInfo(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> mountPath)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">425</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">426</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> volumeName = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> StringBuilder(<span style=\"color: rgba(128, 0, 128, 1);\">256</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">427</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> fileSystemType = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> StringBuilder(<span style=\"color: rgba(128, 0, 128, 1);\">256</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">428</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">429</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!mountPath.EndsWith(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\\\</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">430</span>                 mountPath += <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\\\</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">431</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> success =<span style=\"color: rgba(0, 0, 0, 1);\"> GetVolumeInformationW(\n</span><span style=\"color: rgba(0, 128, 128, 1);\">432</span> <span style=\"color: rgba(0, 0, 0, 1);\">                mountPath,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">433</span> <span style=\"color: rgba(0, 0, 0, 1);\">                volumeName, volumeName.Capacity,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">434</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">out</span> _, <span style=\"color: rgba(0, 0, 255, 1);\">out</span> _, <span style=\"color: rgba(0, 0, 255, 1);\">out</span><span style=\"color: rgba(0, 0, 0, 1);\"> _,\n</span><span style=\"color: rgba(0, 128, 128, 1);\">435</span> <span style=\"color: rgba(0, 0, 0, 1);\">                fileSystemType, fileSystemType.Capacity);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">436</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">success)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">437</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">438</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">int</span> err =<span style=\"color: rgba(0, 0, 0, 1);\"> Marshal.GetLastWin32Error();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">439</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;VolumeInfo&gt;.ToWin32Error($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">GetVolumeInformationW get {mountPath} volume info failed</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, err);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">440</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">441</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">442</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> volumeInfo = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> VolumeInfo()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">443</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">444</span>                 VolumeLabel =<span style=\"color: rgba(0, 0, 0, 1);\"> volumeName.ToString(),\n</span><span style=\"color: rgba(0, 128, 128, 1);\">445</span>                 FileSystemType =<span style=\"color: rgba(0, 0, 0, 1);\"> fileSystemType.ToString()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">446</span> <span style=\"color: rgba(0, 0, 0, 1);\">            };\n</span><span style=\"color: rgba(0, 128, 128, 1);\">447</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;VolumeInfo&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToSuccess(volumeInfo);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">448</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">449</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">450</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">451</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 通过挂载路径获取磁盘信息\n</span><span style=\"color: rgba(0, 128, 128, 1);\">452</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;para&gt;</span><span style=\"color: rgba(0, 128, 0, 1);\">先获取磁盘列表，再筛选</span><span style=\"color: rgba(128, 128, 128, 1);\">&lt;/para&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">453</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">454</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;param name=\"mountPath\"&gt;&lt;/param&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">455</span>         <span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;returns&gt;&lt;/returns&gt;</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">456</span>         <span style=\"color: rgba(0, 0, 255, 1);\">public</span> OperateResult&lt;LocalDisk&gt; GetDiskByMountPath(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> mountPath)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">457</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">458</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> getDisksResult =<span style=\"color: rgba(0, 0, 0, 1);\"> GetDisks();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">459</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">getDisksResult.Success)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">460</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">461</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> getDisksResult.ToResult&lt;LocalDisk&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">462</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">463</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">464</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> iscsiDisks = getDisksResult.Data.FirstOrDefault(i =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> i.MountPaths.Contains(mountPath));\n</span><span style=\"color: rgba(0, 128, 128, 1);\">465</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> OperateResult&lt;LocalDisk&gt;<span style=\"color: rgba(0, 0, 0, 1);\">.ToSuccess(iscsiDisks);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">466</span>         }</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<p>同样的遍历磁盘列表（4块），首次耗时20ms，二次查询仅7ms：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/685541/202601/685541-20260112203649643-1418202473.png\" /></p>\n<p>封装WIN32，异常码只有基础的Win32Exception异常码，不像Powershell Storage有相对上层更多的业务异常码和异常描述那么好理解。</p>\n<p>比如句柄CreateFile失败,GetLastError异常码是&nbsp;0x00000002，转换Win32Exception描述：“系统找不到指定的文件”。鬼知道是啥问题。。。结合上下文，才知道原来磁盘IsOffline状态是无法查找卷、也无法创建分区访问句柄</p>\n<p>&nbsp;</p>\n<p><strong>回到.NET磁盘管理方案选型，</strong></p>\n<p>没有复杂的C端环境的话、仅运维等固定场景，磁盘管理操作可以使用Powersshell</p>\n<p>对磁盘操作要求稳定、但又想快速实现功能，较少的磁盘功能调用，推荐WMI</p>\n<p>对磁盘操作要求稳定、性能要求高，做产品级的存储软件，推荐WIN32</p>\n<p>&nbsp;</p>\n<p>磁盘相关的其它文章：</p>\n<p><a href=\"https://www.cnblogs.com/kybs0/p/18701464\">Windows 本地虚拟磁盘 - 唐宋元明清2188 - 博客园</a></p>\n<a href=\"https://www.cnblogs.com/kybs0/p/18712317\">Windows 网络存储ISCSI介绍 - 唐宋元明清2188 - 博客园</a><br />\n<p><a href=\"https://www.cnblogs.com/kybs0/p/18766881\">网络虚拟存储 Iscsi实现方案 - 唐宋元明清2188 - 博客园</a></p>\n</div>\n<div id=\"MySignature\">\n    <div>作者：<a href=\"http://www.cnblogs.com/kybs0/\" target=\"_blank\">唐宋元明清2188</a></div>\n<div>出处：<a href=\"http://www.cnblogs.com/kybs0/\" target=\"_blank\">http://www.cnblogs.com/kybs0/</a></div>\n<div>让学习成为习惯，假设明天就有重大机遇等着你，你准备好了么</div>\n<div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须在文章页面给出原文连接，否则保留追究法律责任的权利。 </div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-12 23:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kybs0\">唐宋元明清2188</a>&nbsp;\n阅读(<span id=\"post_view_count\">66</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "并发，并行与异步",
      "link": "https://www.cnblogs.com/kklldog/p/19474533",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kklldog/p/19474533\" id=\"cb_post_title_url\" title=\"发布于 2026-01-12 23:33\">\n    <span>并发，并行与异步</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在我上一篇题为《为什么异步在IO操作下才有意义》的文章发布后，收到了很多同学的反馈与探讨。在深入交流后，我发现一个普遍的困惑点浮现出来，其根源在于混淆了“并发”、“并行”与“异步”，特别是下意识地将异步等同于利用多核CPU进行并行处理。</p>\n<p>为了彻底澄清这些基础但至关重要的概念，我们深入剖析理论原则并且同时抛开我们日常使用的现代框架（如.NET）中的具体实现（这往往会误导），以辨析并发（Concurrency）、<strong>并行（parallel）和异步（Asynchronous）</strong>这三个核心概念。</p>\n<h2 id=\"核心概念解析\">核心概念解析</h2>\n<h3 id=\"什么是并发concurrency\">什么是并发（Concurrency）？</h3>\n<p><img alt=\"\" src=\"https://static.xbaby.xyz/blog/concurrency.jpg\" /></p>\n<ul>\n<li>\n<p>定义： 并发是指一个系统有能力在一段时间内处理多个任务。这些任务的执行在宏观上是重叠的，但在微观上是通过任务的交替执行实现的。</p>\n</li>\n<li>\n<p>精髓： Go语言之父 Rob Pike 对此有非常精辟的论述：“Concurrency is about dealing with lots of things at once.”（并发是关于处理多件事情的能力）。这里的关键词是“dealing with”（处理），它强调的是一种程序结构，使其能够应对和管理多个任务流。</p>\n</li>\n<li>\n<p>举例说明： 一个餐厅突然来了三个客人，但餐厅只有一个服务员。从服务员的角度来看，他需要同时服务这些客人。当然这是宏观上的同时，因为服务员执行事件的速度是在是太慢了。</p>\n</li>\n</ul>\n<h3 id=\"什么是并行parallel\">什么是并行（parallel）？</h3>\n<p><img alt=\"\" src=\"https://static.xbaby.xyz/blog/%E5%B9%B6%E8%A1%8C.jpg\" /></p>\n<ul>\n<li>\n<p>定义： 并行是指系统能够在同一物理时刻真正地同时执行多个任务。</p>\n</li>\n<li>\n<p>前提： 并行必须依赖于多核CPU。在多核处理器上，每个核心可以在完全相同的时刻独立地执行一个不同的任务指令，实现物理意义上的“同时”。</p>\n</li>\n<li>\n<p>精髓： 同样引用 Rob Pike 的论述进行对比：“parallel is about doing lots of things at once.”（并行是关于完成多件事情的能力）。这里的关键词是“doing”（完成），强调的是物理上的同时执行，是真正意义上的“一起做”。</p>\n</li>\n<li>\n<p>举例： 还是餐厅的例子，一个餐厅突然来了三个客人，餐厅这次有3个服务员，每个服务员正好服务一位客人。这就是并行。</p>\n</li>\n</ul>\n<h3 id=\"什么是异步asynchronous\">什么是异步（Asynchronous）？</h3>\n<p><img alt=\"\" src=\"https://static.xbaby.xyz/blog/async.jpg\" /></p>\n<ul>\n<li>\n<p>定义： 异步是一种编程模型或模式，其核心思想是非阻塞（Non-blocking）。它描述的是一种调用行为，尤其在处理耗时的I/O操作时（如网络请求、数据库查询、文件读写）显得至关重要。</p>\n</li>\n<li>\n<p>机制： 当一个线程发起一个异步I/O操作时（例如，在.NET中调用 await client.GetStringAsync(...)），它并不会原地阻塞等待。实际发生的过程是：</p>\n</li>\n</ul>\n<ol>\n<li>该线程向操作系统发出I/O请求，然后立即返回。</li>\n<li>这个宝贵的线程被释放回线程池，可以立即去处理其他的工作，比如响应另一个用户的请求。CPU完全没有被闲置。</li>\n<li>I/O操作由硬件（如网卡、磁盘控制器）独立完成。</li>\n<li>当操作完成后，硬件会向CPU发送一个中断信号。</li>\n<li>操作系统捕获这个中断，并将一个完成事件排入队列。</li>\n<li>线程池中的某个可用线程会取出这个事件，并从之前 await 的地方继续执行后续代码。</li>\n</ol>\n<ul>\n<li>\n<p>目的： 异步的主要目标是避免在等待I/O密集型操作时浪费昂贵的线程资源，从而用少量的线程实现极高的系统吞吐量和可伸缩性（例如，处理成千上万的并发网络连接）。它关注的是调用方的线程是否被阻塞，而非任务是否在多核上同时运行。</p>\n</li>\n<li>\n<p>误区澄清： “Asynchronous is not Concurrency.”（异步不是并发）。这是一个极其重要的区分。异步是一种允许代码以非线性（多任务角度）顺序正确执行的属性，它能够用来实现并发，但其本身并非并发。异步可以在单线程上实现（一个线程发起请求后去做别的事），而并行则必须是多个线程在多个CPU核心上同时执行。</p>\n</li>\n<li>\n<p>举例： 还是餐厅的例子，一个餐厅同时来了三个客人，三个服务员每人一个客人。服务员在下完单后有两个选择：</p>\n</li>\n</ul>\n<ol>\n<li>同步：在后厨门口傻等，直到出餐后送到客人桌上。</li>\n<li>异步：下单后马上去接待其他客人或者处理其他事情，等后厨对讲机里通知菜烧好了才去取餐送餐。</li>\n</ol>\n<p><em>！！！这里请大家注意 ！！！：</em></p>\n<blockquote>\n<p>异步模型我们强调的是这个服务员被释放出来了，他更加灵活的调度，他可以做更多的事来提高餐厅的运行效率。至于后厨做菜这件事是一个厨师来做，还是十个厨师来做那是如何更快的做菜的问题。这跟异步还是同步没有关系。同步模式下做菜这件事也可以请十个厨师来做而加快出餐的速度。</p>\n</blockquote>\n<h2 id=\"三者的关系与区别\">三者的关系与区别</h2>\n<p>为了更直观地理解它们，我们可以通过一个表格来对比：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">维度</th>\n<th style=\"text-align: left;\">并发 (Concurrency)</th>\n<th style=\"text-align: left;\">并行 (parallel)</th>\n<th style=\"text-align: left;\">异步 (Asynchronous)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>核心思想</strong></td>\n<td style=\"text-align: left;\">交替执行（逻辑上同时）</td>\n<td style=\"text-align: left;\">同时执行（物理上同时）</td>\n<td style=\"text-align: left;\">非阻塞与回调/续延</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>CPU要求</strong></td>\n<td style=\"text-align: left;\">单核即可</td>\n<td style=\"text-align: left;\">必须多核</td>\n<td style=\"text-align: left;\">与核心数无直接关系</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>处理方式</strong></td>\n<td style=\"text-align: left;\">OS调度器时间分片</td>\n<td style=\"text-align: left;\">多核物理执行</td>\n<td style=\"text-align: left;\">发起I/O后释放线程</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>解决问题</strong></td>\n<td style=\"text-align: left;\">应对逻辑上需要同时处理多任务的场景</td>\n<td style=\"text-align: left;\">提升计算密集型任务的执行效率</td>\n<td style=\"text-align: left;\">避免I/O密集型任务阻塞，提升系统吞吐量</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"总结\">总结</h2>\n<p>总而言之，并发、并行和异步是从不同维度描述任务执行方式的概念。并发是一种程序设计结构，使其能够逻辑上处理多个任务；并行是利用硬件（多核CPU）在物理上同时执行多个任务的计算能力；而异步是一种编程范式，通过非阻塞IO调用来极致地提高系统资源的利用率。</p>\n<h2 id=\"关注我的公众号一起玩转技术\">关注我的公众号一起玩转技术</h2>\n<p><img alt=\"\" src=\"https://static.xbaby.xyz/qrcode.jpg\" /></p>\n\n</div>\n<div id=\"MySignature\">\n    <div id=\"AllanboltSignature\">        \n<p id=\"PSignature\">       \nQQ群：1022985150 VX：kklldog 一起探讨学习.NET技术\n<br />\n作者：<a href=\"http://www.cnblogs.com/kklldog\" target=\"_blank\">Agile.Zhou(kklldog)</a>            \n<br /> \n出处：<a href=\"http://www.cnblogs.com/kklldog/\" target=\"_blank\">http://www.cnblogs.com/kklldog/</a>\n<br />本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。\n </p>  \n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-12 23:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kklldog\">Agile.Zhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">33</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （六）长短期记忆 LSTM",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19474433",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19474433\" id=\"cb_post_title_url\" title=\"发布于 2026-01-12 22:25\">\n    <span>吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （六）长短期记忆 LSTM</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第一周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V/?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=160\" rel=\"noopener nofollow\" target=\"_blank\">1.10</a>的内容以及一些相关基础的补充。</p>\n<hr />\n<p>本周为第五课的第一周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本篇的内容关于<strong>长短期记忆 LSTM</strong>，它和 GRU 一样，是成功缓解 RNN 的长距离依赖问题且流行至今的技术。</p>\n<h1 id=\"1-什么是-lstmlong-short-term-memory\">1. 什么是 LSTM（Long Short-Term Memory）？</h1>\n<p>在 <a href=\"https://www.cnblogs.com/Goblinscholar/p/19463351\" target=\"_blank\">GRU</a> 中，我们已经看到：<strong>通过门控机制对信息流进行选择性控制，确实可以显著缓解传统 RNN 的长距离依赖问题</strong>。<br />\n无论是更新门对历史信息的保留，还是重置门对当前输入的强调，本质上都是在回答同一个问题：<strong>哪些信息值得被继续传递，哪些可以被遗忘。</strong></p>\n<p>然而，从更长时间跨度的建模需求来看，GRU <strong>仍然存在一个结构上的局限</strong>：它依然只有<strong>单一的隐藏状态</strong>来同时承担“短期计算结果”和“长期记忆载体”这两种角色。<br />\n这意味着，<strong>即便引入了门控机制，不同时间尺度的信息仍然被迫混合在同一条状态通道中传递</strong>，在极长序列或精细时序控制的场景下，这种耦合仍可能限制模型的表达能力。</p>\n<p>而<strong>LSTM</strong>便能应对这类问题，早在 <strong>1997</strong> 年，Hochreiter 和 Schmidhuber 在论文：<a href=\"https://www.bioinf.jku.at/publications/older/2604.pdf\" rel=\"noopener nofollow\" target=\"_blank\">Long Short-Term Memory</a>中，便从理论层面系统性地分析了 RNN 中梯度消失的问题，并给出了一种<strong>结构性解决方案</strong>：通过显式引入一条<strong>专门用于长期信息传递的记忆单元（cell state）</strong>，并配合精细设计的门控结构，使得关键信息可以在长时间跨度内几乎不受干扰地向前传播。</p>\n<p>这里要说明一点，你会发现：从时间顺序上看，<strong>LSTM 的提出早于 GRU</strong>。<br />\nLSTM 是最早从结构层面系统性解决 RNN 长距离依赖问题的门控循环单元。<br />\n而<strong>在上一篇我们说 GRU 可以看作 LSTM 的一种简化形式</strong>，正是因为它在 LSTM 的基础上合并了部分门控结构，取消了显式的记忆单元，用更紧凑的形式实现了相似的建模目标。</p>\n<p>也正因为这种简化，GRU 在参数数量、计算开销以及工程实现复杂度上都更为友好。<br />\n因此，在许多实际任务中，当序列长度并未极端拉长，或对长期记忆的精细控制要求不高时，<strong>GRU 往往能够以更低的成本获得与 LSTM 接近的性能</strong>。这也是为什么，尽管 LSTM 在理论上具备更强的表达与记忆能力，<strong>结构更简单的 GRU 仍然在大量 NLP 与时序建模场景中被广泛采用</strong>。</p>\n<p>同样简单过了过历史，下面我们来展开介绍。</p>\n<h2 id=\"11-gru-的理论局限\">1.1 GRU 的理论局限</h2>\n<p>在 GRU 中，我们已经看到：通过引入更新门和重置门，模型不再被动地“记住一切”，而是学会了<strong>选择性保留与选择性使用历史信息</strong>。<br />\n这使得 RNN 在长序列建模中的表现得到了显著改善。</p>\n<p>但如果我们继续追问一个问题：<strong>这些被“精心筛选”的历史信息，到底被存放在哪里？</strong><br />\n答案是：<strong>仍然在同一个隐藏状态里。</strong></p>\n<p>也就是说，在 GRU 中：隐藏状态既承担<strong>当前计算结果</strong>，又承担<strong>长期记忆载体</strong>。<br />\n这样做的结果就是我们刚刚提到的：所有信息，无论时间尺度长短，最终都要“挤”在同一个向量中传递，可能限制模型的表达能力。</p>\n<p>在多数任务中，这已经足够有效，但在<strong>极长序列、精细时序控制或长期语义一致性要求很高</strong>的场景下，这种“混合存储”仍然可能成为瓶颈。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260112222201121-1094822425.png\" /></p>\n<h2 id=\"12-lstm-的记忆细胞\">1.2 LSTM 的记忆细胞</h2>\n<p>实际上，LSTM 的设计就能很好的解决刚刚的混合存储问题。<br />\n它引入了一个<strong>结构层面的改变</strong>：<strong>不再让同一个状态同时负责“长期记忆”和“短期计算”。</strong></p>\n<p>为此，LSTM 明确区分了两条信息通道：</p>\n<ul>\n<li><strong>细胞状态（cell state） <span class=\"math inline\">\\(c^{}\\)</span></strong>  → 专门负责<strong>长期信息的存储与传递。</strong></li>\n<li><strong>隐藏状态（hidden state） <span class=\"math inline\">\\(a^{}\\)</span></strong>  → 负责<strong>当前时刻的输出与短期计算。</strong></li>\n</ul>\n<p>你可以把它理解为：</p>\n<blockquote>\n<p>隐藏状态是“当前脑子里在想什么”，<br />\n细胞状态是“一条几乎不被打扰的长期备忘录”。</p>\n</blockquote>\n<p>这也是 LSTM 名字中 <strong>Long Short-Term</strong> 的含义：  <strong>长期信息（Long-Term）和短期信息（Short-Term）在结构上被显式区分了。</strong><br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260112222133456-1134110847.png\" /><br />\n打个比方来总结 GRU 和 LSTM 的差别：GRU像是在<strong>一张纸上反复修改内容</strong>，LSTM则像是<strong>单独准备了一本笔记本</strong>。</p>\n<h2 id=\"13-lstm-的门控机制\">1.3 LSTM 的门控机制</h2>\n<p>既然引入了专门的记忆细胞来作为 LSTM 中的<strong>长期记忆通道</strong>，新的问题自然出现了：这条记忆，什么时候该保留？ 什么时候该更新？什么时候该输出给当前计算使用？</p>\n<p>答案依然是：<strong>门控机制</strong>。<br />\n简单来说，LSTM 通过三道门来精细控制长期记忆：</p>\n<ol>\n<li><strong>遗忘门（Forget Gate）</strong>：决定旧记忆保留多少。</li>\n<li><strong>输入门（Input Gate）</strong>：决定新信息写入多少。</li>\n<li><strong>输出门（Output Gate）</strong>：决定当前时刻对外暴露多少记忆。</li>\n</ol>\n<p><img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260112222316186-1000139547.png\" /></p>\n<p>也正是因为这些门的存在， <strong>cell state 才能够在时间维度上稳定流动，而不被频繁改写</strong>。<br />\n有了 GRU 的基础后，我们就不再单独逐个展开每道门的语义了，在下面的实现部分再来详细展开它们的作用逻辑。</p>\n<h1 id=\"2-如何实现-lstm\">2. 如何实现 LSTM？</h1>\n<p>在之前的 GRU 中，我们已经看到：<strong>门控的本质不是增加复杂度，而是为“信息是否继续存在”提供可学习的选择权。</strong></p>\n<p>LSTM 在这个思想上更进一步：它不再试图让<strong>同一个状态</strong>同时承担“长期记忆”和“当前计算”， 而是<strong>显式引入了一条几乎线性传播的长期记忆通道——细胞状态 <span class=\"math inline\">\\(c^{\\langle t \\rangle}\\)</span></strong>，并通过遗忘门，输入门和输出门来控制细胞状态。<br />\n了解了基本原理后，现在就来看看，在一个时间步 <span class=\"math inline\">\\(t\\)</span>，一个标准 LSTM 单元是如何实现的。<br />\n实际上，它只是比 GRU 多了些步骤，在有了 GRU 的基础后，LSTM 的实现并不难理解，先摆出它的单元结构图如下：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260112222130915-556405424.png\" /><br />\n要强调的还是我们介绍的计算顺序是<strong>逻辑上的先后顺序</strong>，实际上很多步骤都是可以同步计算的。</p>\n<h2 id=\"21-计算遗忘门forget-gate\">2.1 计算遗忘门（Forget Gate）</h2>\n<p>LSTM 的第一步，是计算 <strong>遗忘门</strong> <span class=\"math inline\">\\(f^{\\langle t \\rangle}\\)</span>。</p>\n<p>它的作用就相当于 GRU 的重置门：<strong>对上一时刻的细胞状态 <span class=\"math inline\">\\(c^{\\langle t-1 \\rangle}\\)</span> 进行“按比例保留”。</strong><br />\n但要注意，这里是“<strong>细胞状态</strong>” 而不是 ”<strong>隐藏状态</strong>“。<br />\n过程如下：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260112222131252-989637007.png\" /><br />\n计算公式还是是线性组合：</p>\n<p></p><div class=\"math display\">\\[f^{\\langle t \\rangle}  \n= sigmoid\\big( W_{xf} x^{\\langle t \\rangle} + W_{af} a^{\\langle t-1 \\rangle} + b_f \\big)  \n\\]</div><p></p><p>遗忘门值的含义是这样的：</p>\n<ul>\n<li><span class=\"math inline\">\\(f^{\\langle t \\rangle}_i \\approx 1\\)</span>：第 <span class=\"math inline\">\\(i\\)</span> 个记忆单元几乎<strong>完全保留</strong>。</li>\n<li><span class=\"math inline\">\\(f^{\\langle t \\rangle}_i \\approx 0\\)</span>：第 <span class=\"math inline\">\\(i\\)</span> 个记忆单元被<strong>主动遗忘</strong>。</li>\n</ul>\n<p>这里出现了新的内容需要说明：<strong>细胞状态 <span class=\"math inline\">\\(c^{\\langle t \\rangle}\\)</span> 与隐藏状态 <span class=\"math inline\">\\(a^{\\langle t \\rangle}\\)</span> 在维度上是一致的</strong>。<br />\n若隐藏状态是一个 <span class=\"math inline\">\\(d\\)</span> 维向量，那么细胞状态同样包含 <span class=\"math inline\">\\(d\\)</span> 个<strong>记忆单元</strong>。<br />\n因此，遗忘门 <span class=\"math inline\">\\(f^{\\langle t \\rangle}\\)</span> 的每一个分量 <span class=\"math inline\">\\(f_i^{\\langle t \\rangle}\\)</span>，并不是控制“一整段记忆”，而是<strong>独立控制第 <span class=\"math inline\">\\(i\\)</span> 个记忆单元在时间维度上的保留比例</strong>。</p>\n<p>再结合一下 GRU ，你会发现，这段逻辑在GRU中以重置门的形式完整保留了。</p>\n<h2 id=\"22-计算输入门input-gate\">2.2 计算输入门（Input Gate）</h2>\n<p>LSTM 的第二步，是计算 <strong>输入门</strong> <span class=\"math inline\">\\(i^{\\langle t \\rangle}\\)</span>。</p>\n<p>它的作用是：<strong>决定当前步生成的新信息有多少可以写入细胞状态 <span class=\"math inline\">\\(c^{\\langle t \\rangle}\\)</span></strong>。<br />\n换句话说，它控制了“新记忆更新比例”，在功能上类似 GRU 的更新门，但在 LSTM 中，它只负责 <strong>新信息写入</strong>，而历史信息保留由遗忘门控制。</p>\n<p>过程如下：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260112222315717-85455316.png\" /><br />\n公式表示为：</p>\n<p></p><div class=\"math display\">\\[i^{\\langle t \\rangle} = sigmoid\\big( W_{xi} x^{\\langle t \\rangle} + W_{ai} a^{\\langle t-1 \\rangle} + b_i \\big)  \n\\]</div><p></p><p>输入门值的语义同样清晰：</p>\n<ul>\n<li><span class=\"math inline\">\\(i_i^{\\langle t \\rangle} \\approx 1\\)</span>：第 <span class=\"math inline\">\\(i\\)</span> 个记忆单元几乎<strong>全部接收新信息</strong>。</li>\n<li><span class=\"math inline\">\\(i_i^{\\langle t \\rangle} \\approx 0\\)</span>：第 <span class=\"math inline\">\\(i\\)</span> 个记忆单元几乎<strong>不写入新信息</strong>。</li>\n</ul>\n<p>同样地，输入门 <span class=\"math inline\">\\(i^{\\langle t \\rangle}\\)</span> 与细胞状态 <span class=\"math inline\">\\(c^{\\langle t \\rangle}\\)</span> 的维度一致，每个分量独立控制对应记忆单元的写入比例。<br />\n这样做可以保证 <strong>长期记忆在时间维度上既保留重要信息，又按需更新新内容</strong>，实现更精细的记忆管理。</p>\n<h2 id=\"23-计算候选细胞状态candidate-cell-state\">2.3 计算候选细胞状态（Candidate Cell State）</h2>\n<p>还是要先强调一点，这是“<strong>候选细胞状态</strong>”，不是“<strong>候选隐藏状态</strong>”。到这一步，隐藏状态还没有出场。</p>\n<p>在计算完输入门 <span class=\"math inline\">\\(i^{\\langle t \\rangle}\\)</span> 之后，LSTM 的下一步是生成 <strong>候选细胞状态</strong> <span class=\"math inline\">\\(\\tilde{c}^{\\langle t \\rangle}\\)</span>。<br />\n它的作用是：<strong>表示当前步的新信息内容</strong>，由当前输入 <span class=\"math inline\">\\(x^{\\langle t \\rangle}\\)</span> 和上一时刻隐藏状态 <span class=\"math inline\">\\(a^{\\langle t-1 \\rangle}\\)</span> 共同决定，但尚未写入细胞状态 <span class=\"math inline\">\\(c^{\\langle t \\rangle}\\)</span>。<br />\n换句话说，候选细胞状态就是 <strong>准备好可以写入的“新记忆”</strong>。<br />\n计算过程如下：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260112222130982-1988780214.png\" /></p>\n<p>公式表示为：</p>\n<p></p><div class=\"math display\">\\[\\tilde{c}^{\\langle t \\rangle} = \\tanh\\big( W_{xc} x^{\\langle t \\rangle} + W_{ac} a^{\\langle t-1 \\rangle} + b_c \\big)  \n\\]</div><p></p><p>到后下一步你就会发现：候选状态本身并不直接影响最终输出，它只是表示“有多少新记忆”，而<strong>输入门 <span class=\"math inline\">\\(i^{\\langle t \\rangle}\\)</span></strong> 才决定“写入多少新记忆“。<br />\n这段设计不同于 GRU：<strong>LSTM 将“新信息生成”和“新信息写入”明确分离</strong>，方便通过门控精细控制记忆更新。</p>\n<h2 id=\"24-更新细胞状态\">2.4 更新细胞状态</h2>\n<p>现在我们已经有了这样东西：</p>\n<ul>\n<li>上一时刻的细胞状态 <span class=\"math inline\">\\(c^{\\langle t-1 \\rangle}\\)</span>（旧长期记忆）</li>\n<li>遗忘门 <span class=\"math inline\">\\(f^{\\langle t \\rangle}\\)</span>（保留比例）</li>\n<li>输入门 <span class=\"math inline\">\\(i^{\\langle t \\rangle}\\)</span> 与候选记忆 <span class=\"math inline\">\\(\\tilde{c}^{\\langle t \\rangle}\\)</span>（新信息）<br />\nLSTM 会用下面这个<strong>核心公式</strong>来更新长期记忆：</li>\n</ul>\n<p></p><div class=\"math display\">\\[c^{\\langle t \\rangle}  \n= f^{\\langle t \\rangle} \\odot c^{\\langle t-1 \\rangle}\n+ i^{\\langle t \\rangle} \\odot \\tilde{c}^{\\langle t \\rangle}  \n\\]</div><p></p><p><img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260112222315839-1698415516.png\" /></p>\n<p>这个公式的意义也非常直观：</p>\n<ul>\n<li>第一项：<strong>保留多少旧记忆</strong>。</li>\n<li>第二项：<strong>写入多少新记忆</strong>。<br />\n也正是因为这里存在一条近似“直通”的路径，让梯度可以直接从 <span class=\"math inline\">\\(c^{\\langle t \\rangle}\\)</span> 回传到 <span class=\"math inline\">\\(c^{\\langle t-1 \\rangle}\\)</span> ， <strong>细胞状态才能在时间维度上稳定传播，梯度也不容易衰减。</strong></li>\n</ul>\n<h2 id=\"35-计算输出门output-gate\">3.5 计算输出门（Output Gate）</h2>\n<p>需要特别强调的是：  <strong>细胞状态并不直接作为模型输出。</strong><br />\n在之前几步完成了对细胞状态的更新，我们到这里才开始进行<strong>与模型输出相关的隐藏状态计算</strong>。</p>\n<p>在更新完细胞状态 <span class=\"math inline\">\\(c^{\\langle t \\rangle}\\)</span> 之后，LSTM 的下一步是计算 <strong>输出门</strong> <span class=\"math inline\">\\(o^{\\langle t \\rangle}\\)</span><br />\n输出门的作用是：<strong>控制细胞状态中的信息有多少被“暴露”给下一层或下一时间步使用</strong>。<br />\n换句话说，输出门决定了“长期记忆通道中的信息如何影响当前计算”。</p>\n<p>计算过程已经看了很多遍了：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260112222316249-153285731.png\" /><br />\n门的计算都是相同的，公式为：</p>\n<p></p><div class=\"math display\">\\[o^{\\langle t \\rangle} = sigmoid\\big( W_{xo} x^{\\langle t \\rangle} + W_{ao} a^{\\langle t-1 \\rangle} + b_o \\big)  \n\\]</div><p></p><ul>\n<li>当 <span class=\"math inline\">\\(o_i^{\\langle t \\rangle} \\approx 1\\)</span> 时，第 <span class=\"math inline\">\\(i\\)</span> 个记忆单元的长期信息几乎<strong>全部暴露</strong>给隐藏状态。</li>\n<li>当 <span class=\"math inline\">\\(o_i^{\\langle t \\rangle} \\approx 0\\)</span> 时，第 <span class=\"math inline\">\\(i\\)</span> 个记忆单元的长期信息几乎<strong>完全屏蔽</strong>。</li>\n</ul>\n<h2 id=\"36-更新隐藏状态\">3.6 更新隐藏状态</h2>\n<p>有了输出门 <span class=\"math inline\">\\(o^{\\langle t \\rangle}\\)</span> 和更新后的细胞状态 <span class=\"math inline\">\\(c^{\\langle t \\rangle}\\)</span> 后，就可以生成当前时刻的隐藏状态 <span class=\"math inline\">\\(a^{\\langle t \\rangle}\\)</span>，这也是 LSTM 的实际输出，用于传递到下一时间步或下一层网络。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260112222131324-2047519086.png\" /></p>\n<p>生成公式为：</p>\n<p></p><div class=\"math display\">\\[a^{\\langle t \\rangle} = o^{\\langle t \\rangle} \\odot \\tanh(c^{\\langle t \\rangle})  \n\\]</div><p></p><p>最终，输出门与细胞状态、隐藏状态维度一致，<strong>每个分量独立控制对应记忆单元的输出</strong>，实现对长期记忆的<strong>选择性读取</strong>。<br />\n最后，看到长期记忆，你可能会再次想到 GRU 中不仅有长期记忆，还有短期记忆，那 LSTM 的短期记忆被隐含在哪一步了？<br />\n实际上，在 LSTM 中，短期记忆 <strong>就是当前步的隐藏状态 <span class=\"math inline\">\\(a^{\\langle t \\rangle}\\)</span></strong>，它会传给下一时间步或下一层参与计算，而不像 GRU 那样把长期记忆和短期记忆合并在同一状态中。</p>\n<p>至此，一个 LSTM 单元计算就完成了。</p>\n<h2 id=\"37-小结lstm-的完整计算流程\">3.7 小结：LSTM 的完整计算流程</h2>\n<p>在时间步 <span class=\"math inline\">\\(t\\)</span>，一个标准 LSTM 单元的计算顺序可以总结为：</p>\n<ol>\n<li><strong>遗忘门</strong>：决定旧记忆保留多少。</li>\n</ol>\n<p></p><div class=\"math display\">\\[    f^{\\langle t \\rangle}  \n    = \\sigma(W_{xf} x^{\\langle t \\rangle} + W_{af} a^{\\langle t-1 \\rangle} + b_f)  \n\\]</div><p></p><ol start=\"2\">\n<li><strong>输入门</strong>：决定新信息写入多少。</li>\n</ol>\n<p></p><div class=\"math display\">\\[    i^{\\langle t \\rangle}  \n    = \\sigma(W_{xi} x^{\\langle t \\rangle} + W_{ai} a^{\\langle t-1 \\rangle} + b_i)  \n\\]</div><p></p><ol start=\"3\">\n<li><strong>候选记忆</strong>：生成新记忆内容。</li>\n</ol>\n<p></p><div class=\"math display\">\\[    \\tilde{c}^{\\langle t \\rangle}  \n    = \\tanh(W_{xc} x^{\\langle t \\rangle} + W_{ac} a^{\\langle t-1 \\rangle} + b_c)  \n\\]</div><p></p><ol start=\"4\">\n<li><strong>更新细胞状态</strong>：长期记忆融合。</li>\n</ol>\n<p></p><div class=\"math display\">\\[    c^{\\langle t \\rangle}  \n    = f^{\\langle t \\rangle} \\odot c^{\\langle t-1 \\rangle}\n    \n\n+ i^{\\langle t \\rangle} \\odot \\tilde{c}^{\\langle t \\rangle}  \n\\]</div><p></p><ol start=\"5\">\n<li><strong>输出门与隐藏状态</strong>：生成当前输出。</li>\n</ol>\n<p></p><div class=\"math display\">\\[o^{\\langle t \\rangle}  \n= \\sigma(W_{xo} x^{\\langle t \\rangle} + W_{ao} a^{\\langle t-1 \\rangle} + b_o)  \n\\]</div><p></p><p></p><div class=\"math display\">\\[ a^{\\langle t \\rangle}  \n = o^{\\langle t \\rangle} \\odot \\tanh(c^{\\langle t \\rangle})  \n\\]</div><p></p><p>至此，这两篇我们完成了对门控机制的一些相关技术的了解，你会发现，门控机制并没有创新网络本身的结构，而是通过网络关系和计算逻辑为全连接层赋予了全新的语义：<strong>实现了对记忆的选择性保留、更新与输出</strong>。<br />\n这种设计的巧妙之处在于：网络可以自主决定哪些信息值得长期记忆，哪些信息只用于当前计算，使梯度在时间维度上稳定传播，同时让模型能够精细管理短期与长期记忆，从而显著提升序列数据建模的能力。<br />\n同时，也给了我们关于创新的新的灵感：<strong>不要一味增加复杂结构，而是赋予已有机制新的语义与控制能力。</strong></p>\n<h1 id=\"3-总结\">3. 总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>LSTM（Long Short-Term Memory）</strong></td>\n<td>为了解决 RNN/GRU 在长序列中长期依赖的问题，引入<strong>显式的记忆单元（cell state）</strong>，并配合<strong>遗忘门、输入门、输出门</strong>进行精细控制，实现长期信息的稳定传递。</td>\n<td>隐藏状态像“当前脑子里在想什么”，细胞状态像“一本几乎不被打扰的长期备忘录”。</td>\n</tr>\n<tr>\n<td><strong>GRU 的局限</strong></td>\n<td>GRU 只有单一隐藏状态，既承担短期计算，又承担长期记忆，使不同时间尺度的信息混合在同一向量中，长序列或精细时序场景可能受限。</td>\n<td>GRU 像是在“一张纸上反复修改内容”，长期与短期信息混合存储。</td>\n</tr>\n<tr>\n<td><strong>细胞状态（Cell State <span class=\"math inline\">\\(c^{\\langle t \\rangle}\\)</span>）</strong></td>\n<td>专门存储长期信息，可近似线性传播，梯度不易消失。通过遗忘门控制保留，输入门控制写入。</td>\n<td>“长期备忘录”，可以长期保存关键信息，不被频繁改写。</td>\n</tr>\n<tr>\n<td><strong>隐藏状态（Hidden State <span class=\"math inline\">\\(a^{\\langle t \\rangle}\\)</span>）</strong></td>\n<td>表示当前时刻的输出和短期计算结果，传递到下一时间步或下一层。</td>\n<td>“脑子里当前正在处理的内容”。</td>\n</tr>\n<tr>\n<td><strong>遗忘门（Forget Gate <span class=\"math inline\">\\(f^{\\langle t \\rangle}\\)</span>）</strong></td>\n<td>决定旧记忆保留比例：<span class=\"math inline\">\\(f^{\\langle t \\rangle} \\odot c^{\\langle t-1 \\rangle}\\)</span>。</td>\n<td>“决定把哪些旧信息保留下来，哪些丢掉”。</td>\n</tr>\n<tr>\n<td><strong>输入门（Input Gate <span class=\"math inline\">\\(i^{\\langle t \\rangle}\\)</span>）</strong></td>\n<td>决定新信息写入比例：<span class=\"math inline\">\\(i^{\\langle t \\rangle} \\odot \\tilde{c}^{\\langle t \\rangle}\\)</span>。</td>\n<td>“决定新记忆写入多少到长期备忘录”。</td>\n</tr>\n<tr>\n<td><strong>候选细胞状态（<span class=\"math inline\">\\(\\tilde{c}^{\\langle t \\rangle}\\)</span>）</strong></td>\n<td>当前步生成的新信息，由当前输入与上一隐藏状态计算，但尚未写入细胞状态。</td>\n<td>“准备好可以写入的新记忆”。</td>\n</tr>\n<tr>\n<td><strong>更新细胞状态（<span class=\"math inline\">\\(c^{\\langle t \\rangle}\\)</span>）</strong></td>\n<td>结合遗忘门与输入门更新长期记忆：<span class=\"math inline\">\\(c^{\\langle t \\rangle} = f^{\\langle t \\rangle} \\odot c^{\\langle t-1 \\rangle} + i^{\\langle t \\rangle} \\odot \\tilde{c}^{\\langle t \\rangle}\\)</span>。</td>\n<td>“旧备忘录保留多少 + 新信息写入多少”。</td>\n</tr>\n<tr>\n<td><strong>输出门（Output Gate <span class=\"math inline\">\\(o^{\\langle t \\rangle}\\)</span>）</strong></td>\n<td>决定细胞状态暴露给隐藏状态的比例：<span class=\"math inline\">\\(a^{\\langle t \\rangle} = o^{\\langle t \\rangle} \\odot \\tanh(c^{\\langle t \\rangle})\\)</span>。</td>\n<td>“决定长期记忆中哪些内容现在被使用”。</td>\n</tr>\n<tr>\n<td><strong>短期记忆</strong></td>\n<td>LSTM 的短期记忆即当前时刻的隐藏状态 <span class=\"math inline\">\\(a^{\\langle t \\rangle}\\)</span>，用于计算当前输出和下一步传递。</td>\n<td>“脑子里当前想的东西”。</td>\n</tr>\n<tr>\n<td><strong>长期记忆</strong></td>\n<td>LSTM 的长期记忆即细胞状态 <span class=\"math inline\">\\(c^{\\langle t \\rangle}\\)</span>，稳定传递关键历史信息，梯度不易消失。</td>\n<td>“长期备忘录”，可跨时间步保存信息。</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-12 22:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">43</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": ".NET周刊【12月第2期 2025-12-14】",
      "link": "https://www.cnblogs.com/InCerry/p/-/dotnet_week_25_12_2",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/InCerry/p/-/dotnet_week_25_12_2\" id=\"cb_post_title_url\" title=\"发布于 2026-01-12 21:32\">\n    <span>.NET周刊【12月第2期 2025-12-14】</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"国内文章\">国内文章</h2>\n<h3 id=\"avalonia-实现跨平台的视频会议windowslinux信创\">Avalonia 实现跨平台的视频会议（Windows、Linux、信创）</h3>\n<p><a href=\"https://www.cnblogs.com/shawshank/p/19305884\" target=\"_blank\">https://www.cnblogs.com/shawshank/p/19305884</a></p>\n<p>Avalonia 11 的发布显著提升了 .NET 生态中的跨平台 UI 开发能力，特别是提供了高质量的 Fluent 2 风格控件。文章介绍了用 Avalonia 框架开发的跨平台视频会议系统 Demo，支持多种功能，如视频会议、屏幕分享和电子白板，并保证语音质量和动态调节编码。开发环境基于 Visual Studio 2022 与.NET 8.0，使用 C#编写。项目分为服务端与客户端，涉及重要类和技术细节，展示了实际应用的可行性与前景。</p>\n<h3 id=\"avalonia-ui-的演进逻辑与-qt-生态深度对比\">Avalonia UI 的演进逻辑与 Qt 生态深度对比</h3>\n<p><a href=\"https://www.cnblogs.com/shanyou/p/19329439\" target=\"_blank\">https://www.cnblogs.com/shanyou/p/19329439</a></p>\n<p>本文探讨跨平台图形用户界面的发展，重点分析 Mike James 从 Qt 到 Avalonia 的技术转变。历史上，开发者在高效与性能间举步维艰，Qt 以其性能占据主导地位。随着.NET 生态的崛起，开发者渴望一个具 C#优势的跨平台框架。微调的技术使 Avalonia 应运而生，展现出与 Qt 在渲染、状态管理等方面的显著差异。文章还探讨了 Avalonia 的商业化路径，通过核心开源与商业闭源的结合，挑战 Qt 在市场的地位。</p>\n<h3 id=\"wpf-新手村教程一---走不出新手村别找我\">WPF 新手村教程（一） - 走不出新手村别找我</h3>\n<p><a href=\"https://www.cnblogs.com/leaf-7-scouts/p/19336808\" target=\"_blank\">https://www.cnblogs.com/leaf-7-scouts/p/19336808</a></p>\n<p>本文介绍了 WPF 中 XAML 的基础语法与组件，强调了 XAML 作为声明性标记语言的简化作用。文中详细解释了对象元素的用法，包括自闭合和成对标签的语法，以及如何为控件设置属性。作者使用简单明了的示例，展现了按钮和文本框的用法，并提出了集合属性的概念，区分了显式和隐式写法。整体上，文章以通俗易懂的方式介绍了 XAML 的基础知识，适合初学者学习。</p>\n<h3 id=\"net-10-网络改进http安全与网络原语的全面升级\">.NET 10 网络改进：HTTP、安全与网络原语的全面升级</h3>\n<p><a href=\"https://www.cnblogs.com/powertoolsteam/p/19330426\" target=\"_blank\">https://www.cnblogs.com/powertoolsteam/p/19330426</a></p>\n<p>.NET 10 提供了多项网络改进，包括服务器证书验证优化、新的 HTTP 动词 QUERY 和 WebSocketStream 抽象层。WinHttpHandler 目前支持基于服务器 IP 地址的证书缓存机制，增强性能。QUERY 方法允许在请求体中发送查询，适用于超长 URI 的场景。WebSocketStream 简化了文本和二进制协议的数据处理，支持多种协议。同时，.NET 10 在 OSX 上引入了客户端 TLS 1.3 支持，通过 AppContext 开关启用，提升了安全性。整体上，这些更新提升了开发者的网络编程能力。</p>\n<h3 id=\"别再说-winform-做的工业软件丑了这些开源库让它颜值拉满交互流畅\">别再说 WinForm 做的工业软件丑了！这些开源库让它颜值拉满、交互流畅</h3>\n<p><a href=\"https://www.cnblogs.com/1312mn/p/19321609\" target=\"_blank\">https://www.cnblogs.com/1312mn/p/19321609</a></p>\n<p>WinForm 作为.NET 生态中成熟可靠的桌面开发框架，尽管存在视觉和交互限制，但在企业管理、工业控制等领域依然广泛应用。为了提升 UI 效果，开发者可借助第三方开源 UI 库，这些库在不改变 WinForm 核心结构的前提下，通过控件重绘和优化布局，使传统框架焕发新生。文中介绍的 ReaLTaiizor 控件库，提供丰富的示例和兼容的版本，能快速创建高质量的应用界面，降低现代化改造的技术门槛。</p>\n<h3 id=\"分享-4-款基于-c-编写实用开源的-visual-studio-扩展插件\">分享 4 款基于 C# 编写、实用、开源的 Visual Studio 扩展插件</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19328798\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19328798</a></p>\n<p>EFCore.Visualizer 是一款用于在 Visual Studio 中可视化 EF Core 查询计划的工具，支持多种数据库。EF Core Power Tools 提供数据库反向工程和模型可视化功能，降低开发门槛。AntDeploy 是一款开源部署插件，支持多平台发布。FileEncoding 插件可实时显示文档编码，简化编码管理。所有项目均收录在 C#/.NET 优秀项目精选中，方便开发者获取最新动态和最佳实践。</p>\n<h3 id=\"腾讯云-edgeone-pages-托管-blazor-wasm\">腾讯云 EdgeOne Pages 托管 Blazor Wasm</h3>\n<p><a href=\"https://www.cnblogs.com/CKExp/p/19319722\" target=\"_blank\">https://www.cnblogs.com/CKExp/p/19319722</a></p>\n<p>本文介绍了如何使用 Blazor WebAssembly 在腾讯云 EdgeOne Pages 上部署静态网站。EdgeOne Pages 与 Github Pages 相似，提供免费的静态站点部署服务。作者描述了创建 Blazor WebAssembly 项目的过程，上传代码至 Github，并使用 Github Actions 进行自动构建和部署。用 yml 文件配置了构建工作流，步骤包括设置.NET 环境和发布项目，最终将构建后的文件推送至 Github Pages。文章逻辑清晰，包含具体的指令和示例，适合开发者参考。</p>\n<h3 id=\"net-8-微服务框架长什么样集成-ai-智能体多租户自动调度与实时通信\">.NET 8 微服务框架长什么样？集成 AI 智能体、多租户、自动调度与实时通信</h3>\n<p><a href=\"https://www.cnblogs.com/1312mn/p/19273206\" target=\"_blank\">https://www.cnblogs.com/1312mn/p/19273206</a></p>\n<p>该文章介绍了基于 .NET 8 的微服务脚手架，即 NetCoreKevin，旨在帮助快速搭建支持多租户与分布式部署的系统。文章强调项目应用领域驱动设计（DDD），前后端分离架构，并集成多种常用功能如安全认证、多云存储与 AI 能力。技术亮点包括跨服务事件通信、Redis 缓存及 Quartz 定时任务。详细提供了项目启动配置及上手教程，帮助团队快速实现 SaaS 类系统的开发与部署。</p>\n<h3 id=\"一分钟实现net-与飞书长连接的-websocket-架构\">一分钟实现.NET 与飞书长连接的 WebSocket 架构</h3>\n<p><a href=\"https://www.cnblogs.com/mudtools/p/19320597\" target=\"_blank\">https://www.cnblogs.com/mudtools/p/19320597</a></p>\n<p>本文介绍了如何在.NET 环境中实现飞书 WebSocket 长连接，强调了长连接相对于传统 Webhook 的优势，特别是在开发成本和实时性方面。文中阐述了飞书平台支持的多种事件类型，并探讨了 Mud.Feishu 架构的事件处理设计，采用策略模式以实现高效的事件处理机制。具体示例展示了如何创建用户和处理消息接收事件，强调了清晰的单一职责、可测试性以及动态选择处理策略的重要性。</p>\n<h3 id=\"压测数据分享c的-threadpoolsetmaxthreads-配置最大线程数到底对性能有多大影响\">【压测数据分享】C#的 <code>ThreadPool.SetMaxThreads()</code> 配置最大线程数到底对性能有多大影响</h3>\n<p><a href=\"https://www.cnblogs.com/ahfuzhang/p/19340661\" target=\"_blank\">https://www.cnblogs.com/ahfuzhang/p/19340661</a></p>\n<p>文章展示了通过 async 方法和 Kestrel 库提供 HTTP 服务的强大性能，指出线程池线程数与 CPU 核数的关系。性能通过调整线程池的最小和最大线程数得以优化。实验表明，线程池的最佳表现需要最大线程数与核数一致，过多或过少都会降低性能。使用 Kestrel 库开发的 HTTP 1.1 echo 服务器，运行在 Docker 环境中，展示了其高效的异步处理能力。实验数据提供了不同线程设置下的性能指标，验证了作者的观点。</p>\n<h3 id=\"cai-系列6-c离线实现高效-ocr\">C#AI 系列(6): C#离线实现高效 OCR</h3>\n<p><a href=\"https://www.cnblogs.com/luojin765/p/19346320\" target=\"_blank\">https://www.cnblogs.com/luojin765/p/19346320</a></p>\n<p>本文介绍了如何在 C#中使用 Tesseract 实现 OCR。Tesseract 是一个强大的开源光学字符识别引擎，支持超过 100 种语言。作者提供了命令行和 Wrapper 两种调用方式，并重点说明了使用 Wrapper 方法，通过简洁的四行代码实现 OCR。读者需提前准备好训练模型，并可选择同时加载多种语言模型。本文也详细描述了引擎模式和页面分割模式的选择，帮助用户优化 OCR 效果。项目资源已开源，欢迎学习交流。</p>\n<h3 id=\"maf-快速入门6混合编排工作流\">MAF 快速入门（6）混合编排工作流</h3>\n<p><a href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper06\" target=\"_blank\">https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper06</a></p>\n<p>本文介绍了在 MAF 中混合使用 Executor 和 Agent 的工作流，重点在于针对内容审核的案例。Executor 负责确定性逻辑处理，如数据验证，而 Agent 用于 AI 智能决策，具有不确定性。文章提供了一个具体实例，使用.NET 控制台应用配置相关 NuGet 包，并展示了如何读取 API 信息及定义数据传输模型。通过具体的代码示例，清楚说明了工作流的构建过程，适合开发者学习和实践。</p>\n<h3 id=\"c实现三菱-mc-通讯协议库4c-帧-格式-1\">C#实现三菱 MC 通讯协议库（4C 帧-格式 1）</h3>\n<p><a href=\"https://www.cnblogs.com/dragonet-Z/p/19318911\" target=\"_blank\">https://www.cnblogs.com/dragonet-Z/p/19318911</a></p>\n<p>本文介绍了 C#实现的三菱 MC 通讯协议库，使用 VS2022 .NET Standard 2.0 开发。通过串口实现 PC 与 PLC 的通讯，支持 QnA 兼容 4C 帧格式 1 的异步读写操作。MC 协议是与三菱 PLC 通讯的公开协议，能够通过不同模块读取 PLC 的状态。文章详细说明了 MC 协议的通信框架、数据内容及指令。还提供了和校验实现代码，帮助开发者调试。文中附有相关手册链接，便于深入了解协议。最后强调协议功能强大，仅覆盖基础内容。</p>\n<h3 id=\"ef-corecode-first方案下以编程方式生成迁移\">【EF Core】“Code First”方案下以编程方式生成迁移</h3>\n<p><a href=\"https://www.cnblogs.com/tcjiaan/p/19345236\" target=\"_blank\">https://www.cnblogs.com/tcjiaan/p/19345236</a></p>\n<p>迁移（Migrations）是用于创建和修订数据库的机制。它通过生成一系列 .NET 类来表示数据库的不同版本。开发者可以在这些版本之间前进或后退，以修改数据库结构而非数据。确保创建数据库的方法不能后续修改，而迁移会保存迁移版本信息。开发者可以自定义迁移命名方式，并通过实现 IMigrationsIdGenerator 接口来定制命名。迁移由多种操作组成，通过生成 SQL 语句实现数据库修改。这个过程丰富且实用，对开发者极具帮助。</p>\n<h3 id=\"net-10-网络堆栈深度架构解析http3性能优化与后量子加密的融合演进\">.NET 10 网络堆栈深度架构解析：HTTP/3、性能优化与后量子加密的融合演进</h3>\n<p><a href=\"https://www.cnblogs.com/shanyou/p/19350080/dotnet10network\" target=\"_blank\">https://www.cnblogs.com/shanyou/p/19350080/dotnet10network</a></p>\n<p>随着.NET 10 的推出，微软重新定义了云原生时代的网络通信标准。该版本聚焦现代、高效和开发者友好，支持 HTTP/3 和 QUIC 协议，解决了长期存在的队头阻塞问题，并引入后量子加密算法，增强了安全性和性能。通过 JIT 编译器优化和资源管理，.NET 10 在高并发场景下表现出色。新的 System.Net.Quic 库作为核心组件，提高了流的独立性和网络传输效率，简化了开发者的体验，标志着.NET 的技术重大进步。</p>\n<h3 id=\"net-微服务网关注册和管理基于-consul--nginx-实现\">.Net 微服务网关注册和管理（基于 Consul + Nginx 实现）</h3>\n<p><a href=\"https://www.cnblogs.com/net-kevin-li/p/19332353\" target=\"_blank\">https://www.cnblogs.com/net-kevin-li/p/19332353</a></p>\n<p>文章详细介绍了如何基于 Consul 和 Nginx 实现.NET 微服务的网关注册与管理。它阐述了微服务架构中 API 网关的功能、Consul 的服务注册与发现以及 Nginx 的动态路由配置。文章还提到健康检查与故障转移机制，以及负载均衡策略的优化。最后，涉及安全与认证的集成，展示了实际的代码示例和配置，具有实用性和技术深度。</p>\n<h3 id=\"在net-中实现一库多租户single-database-multi-tenancy模式主要通过共享数据库但隔离数据的方式实现\">在.NET 中实现一库多租户（Single Database Multi-Tenancy）模式，主要通过共享数据库但隔离数据的方式实现。</h3>\n<p><a href=\"https://www.cnblogs.com/net-kevin-li/p/19327739\" target=\"_blank\">https://www.cnblogs.com/net-kevin-li/p/19327739</a></p>\n<p>本文讨论了在.NET 中实现一库多租户模式的方法，介绍了共享数据库和数据隔离的实现方案。文章详细阐述了前后端分离设计、领域驱动设计及多级缓存机制等架构特性。内容涉及 CAP 事件总线、SignalR 实时通信和任务调度等核心技术。还描述了如何通过租户 ID 列、动态 Schema 和行级安全策略实现数据隔离，提出了通过子域名或 JWT 进行租户识别的方案。此外，文章建议了性能优化方案，如索引优化和数据分片。</p>\n<h3 id=\"opencvsharp学习连通性检测的使用\">OpenCVSharp：学习连通性检测的使用</h3>\n<p><a href=\"https://www.cnblogs.com/mingupupu/p/19344713\" target=\"_blank\">https://www.cnblogs.com/mingupupu/p/19344713</a></p>\n<p>连通性检测是计算机视觉中的图像处理技术，用于标记二值图像的相互连接像素区域。该技术通常用作其他图像处理的前置步骤，能统计物体数量，但应用场景有限。首先将图像灰度化，再进行二值化处理。使用 OpenCVSharp 库中的 Cv2.AdaptiveThreshold 函数，可以对光照不均的图像进行局部自适应的二值化，从而更准确地进行连通区域检测。该方法通过计算局部区域的平均值动态调整阈值，适应不同亮度的区域。全局阈值处理在复杂情况下效果较差。整体内容展示了图像处理的核心技术和应用。</p>\n<h3 id=\"solon-ai-开发学习-19---结合-solon-flow-实现-react-效果\">Solon AI 开发学习 19 - 结合 Solon Flow 实现 ReAct 效果</h3>\n<p><a href=\"https://www.cnblogs.com/noear/p/19328690\" target=\"_blank\">https://www.cnblogs.com/noear/p/19328690</a></p>\n<p>Solon Flow 是一个通用的流程编排引擎，使用 YAML 或 JSON 进行配置。该示例展示了如何通过 LLM 编写文章并进行人工审核的流程。流程开始时，Agent 编写初稿，接着进入审核环节。如果审核不通过，用户可以提供反馈，Agent 根据反馈修改内容，再次进入审核。最终，流程在获得批准或达到最大修改次数后结束。代码部分展示了 Agent 的实现，包括初稿编写和反馈处理的逻辑。整体上，该流程高效实现了人机交互与内容审核的结合。</p>\n<h3 id=\"maui-库推荐一mauiicons\">MAUI 库推荐一：MAUIIcons</h3>\n<p><a href=\"https://www.cnblogs.com/sesametech-dotnet/p/19349735\" target=\"_blank\">https://www.cnblogs.com/sesametech-dotnet/p/19349735</a></p>\n<p>MAUIIcons 是一个为 Maui 提供的图标集合库，集成 Fluent、Material、Cupertino 和 FontAwesome 图标。用户能便捷地在 MAUI 应用中使用这些图标。为了使用该库，需要在 nuget 上下载，并在 MauiProgram.cs 中添加代码进行初始化。此外，文中介绍了如何在 XAML 中使用图标，并提供了数据绑定的示例。若遇编译错误，可以通过创建 MauiIcon 实例解决。该文易于理解，且包含实用示例。</p>\n<h3 id=\"创建抖音新号分享知识推广开源项目\">创建抖音新号分享知识推广开源项目</h3>\n<p><a href=\"https://www.cnblogs.com/fanliang11/p/19332240\" target=\"_blank\">https://www.cnblogs.com/fanliang11/p/19332240</a></p>\n<p>作者是一名拥有二十年开发经验的 85 后，始终坚持.NET 技术，尽管面临诸多挑战。他分享了自己对产品开发的热情，坚信最终会取得成功。同时，他开设了一个新的抖音号，希望通过直播拉动粉丝和宣传产品，还提到直播互动的目的在于学习交流。</p>\n<blockquote>\n<p>本周国际周刊未更新，故留空</p>\n</blockquote>\n<h2 id=\"今日人物\">今日人物</h2>\n<p><strong>查尔斯·安东尼·理查德·霍尔</strong><a href=\"https://zh.wikipedia.org/wiki/%E7%88%B5%E5%A3%AB\" rel=\"noopener nofollow\" target=\"_blank\">爵士</a>（英语：Sir <strong>Charles Antony Richard Hoare</strong>，缩写为 C. A. R. Hoare，1934 年 1 月 11 日—），昵称为<strong>东尼·霍尔</strong>（英语：<strong>Tony Hoare</strong>，一译<strong>托尼·霍尔</strong>），生于<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7%E8%8B%B1%E5%B8%9D%E5%9C%8B\" rel=\"noopener nofollow\" target=\"_blank\">大英帝国</a><a href=\"https://zh.wikipedia.org/wiki/%E8%8B%B1%E5%B1%AC%E9%8C%AB%E8%98%AD\" rel=\"noopener nofollow\" target=\"_blank\">锡兰</a><a href=\"https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%80%AB%E5%9D%A1\" rel=\"noopener nofollow\" target=\"_blank\">可伦坡</a>（今<a href=\"https://zh.wikipedia.org/wiki/%E6%96%AF%E9%87%8C%E8%98%AD%E5%8D%A1\" rel=\"noopener nofollow\" target=\"_blank\">斯里兰卡</a>），英国<a href=\"https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8%E5%AE%B6\" rel=\"noopener nofollow\" target=\"_blank\">计算机科学家</a>，<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96\" rel=\"noopener nofollow\" target=\"_blank\">图灵奖</a>得主。他设计了<a href=\"https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\" rel=\"noopener nofollow\" target=\"_blank\">快速排序</a><a href=\"https://zh.wikipedia.org/wiki/%E6%BC%94%E7%AE%97%E6%B3%95\" rel=\"noopener nofollow\" target=\"_blank\">算法</a>、<a href=\"https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%B0%94%E9%80%BB%E8%BE%91\" rel=\"noopener nofollow\" target=\"_blank\">霍尔逻辑</a>、<a href=\"https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1%E9%A1%BA%E5%BA%8F%E8%BF%9B%E7%A8%8B\" rel=\"noopener nofollow\" target=\"_blank\">通信顺序进程</a>。</p>\n<p>东尼·霍尔的父亲是一位公务员，服务于<a href=\"https://zh.wikipedia.org/wiki/%E8%8B%B1%E5%B1%AC%E9%8C%AB%E8%98%AD\" rel=\"noopener nofollow\" target=\"_blank\">英属锡兰</a>。其母亲是茶园主人的女儿。</p>\n<p>东尼·霍尔在可伦坡出生，在英国本土受教育。1956 年，在<a href=\"https://zh.wikipedia.org/wiki/%E7%89%9B%E6%B4%A5%E5%A4%A7%E5%AD%B8\" rel=\"noopener nofollow\" target=\"_blank\">牛津大学</a><a href=\"https://zh.wikipedia.org/wiki/%E7%89%9B%E6%B4%A5%E5%A4%A7%E5%AD%B8%E5%A2%A8%E9%A0%93%E5%AD%B8%E9%99%A2\" rel=\"noopener nofollow\" target=\"_blank\">墨顿学院</a>取得<a href=\"https://zh.wikipedia.org/wiki/%E8%A5%BF%E6%B4%8B%E5%8F%A4%E5%85%B8%E5%AD%B8\" rel=\"noopener nofollow\" target=\"_blank\">西洋古典学</a><a href=\"https://zh.wikipedia.org/wiki/%E5%AD%B8%E5%A3%AB\" rel=\"noopener nofollow\" target=\"_blank\">学士</a>学位。<a href=\"https://zh.wikipedia.org/wiki/%E6%9D%B1%E5%B0%BC%C2%B7%E9%9C%8D%E7%88%BE#cite_note-MCreg-1\" rel=\"noopener nofollow\" target=\"_blank\">[1]</a>在大学毕业后，进入<a href=\"https://zh.wikipedia.org/wiki/%E8%8B%B1%E5%9C%8B%E7%9A%87%E5%AE%B6%E6%B5%B7%E8%BB%8D\" rel=\"noopener nofollow\" target=\"_blank\">英国皇家海军</a>服兵役 18 个月，<a href=\"https://zh.wikipedia.org/wiki/%E6%9D%B1%E5%B0%BC%C2%B7%E9%9C%8D%E7%88%BE#cite_note-MCreg-1\" rel=\"noopener nofollow\" target=\"_blank\">[1]</a>在此学会<a href=\"https://zh.wikipedia.org/wiki/%E4%BF%84%E8%AA%9E\" rel=\"noopener nofollow\" target=\"_blank\">俄语</a>。<a href=\"https://zh.wikipedia.org/wiki/%E6%9D%B1%E5%B0%BC%C2%B7%E9%9C%8D%E7%88%BE#cite_note-Hoare_autobio-2\" rel=\"noopener nofollow\" target=\"_blank\">[2]</a>1958 年退伍后，回到牛津大学，研读统计学，取得学士后学位。<a href=\"https://zh.wikipedia.org/wiki/%E6%9D%B1%E5%B0%BC%C2%B7%E9%9C%8D%E7%88%BE#cite_note-MCreg-1\" rel=\"noopener nofollow\" target=\"_blank\">[1]</a>在此期间，开始学习程式设计，他跟着<a href=\"https://zh.wikipedia.org/w/index.php?title=Leslie_Fox&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">Leslie Fox</a>学习<a href=\"https://zh.wikipedia.org/w/index.php?title=Autocode&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">Autocode</a>。为了进一步学习<a href=\"https://zh.wikipedia.org/wiki/%E4%BF%84%E8%AA%9E\" rel=\"noopener nofollow\" target=\"_blank\">俄语</a>，他以<a href=\"https://zh.wikipedia.org/wiki/%E8%8B%B1%E5%9C%8B%E6%96%87%E5%8C%96%E5%8D%94%E6%9C%83\" rel=\"noopener nofollow\" target=\"_blank\">英国文化协会</a>的交换学生身份，至<a href=\"https://zh.wikipedia.org/wiki/%E8%98%87%E8%81%AF\" rel=\"noopener nofollow\" target=\"_blank\">苏联</a><a href=\"https://zh.wikipedia.org/wiki/%E8%8E%AB%E6%96%AF%E7%A7%91%E5%9C%8B%E7%AB%8B%E5%A4%A7%E5%AD%B8\" rel=\"noopener nofollow\" target=\"_blank\">莫斯科国立大学</a>留学，<a href=\"https://zh.wikipedia.org/wiki/%E6%9D%B1%E5%B0%BC%C2%B7%E9%9C%8D%E7%88%BE#cite_note-MCreg-1\" rel=\"noopener nofollow\" target=\"_blank\">[1]</a>跟随<a href=\"https://zh.wikipedia.org/wiki/%E5%AE%89%E5%BE%B7%E9%9B%B7%C2%B7%E6%9F%AF%E7%88%BE%E8%8E%AB%E5%93%A5%E6%B4%9B%E5%A4%AB\" rel=\"noopener nofollow\" target=\"_blank\">安德雷·柯尔莫哥洛夫</a>学习数学，并研究<a href=\"https://zh.wikipedia.org/wiki/%E6%A9%9F%E5%99%A8%E7%BF%BB%E8%AD%AF\" rel=\"noopener nofollow\" target=\"_blank\">机器翻译</a>。<a href=\"https://zh.wikipedia.org/wiki/%E6%9D%B1%E5%B0%BC%C2%B7%E9%9C%8D%E7%88%BE#cite_note-Hoare_autobio-2\" rel=\"noopener nofollow\" target=\"_blank\">[2]</a></p>\n<p>1960 年，在<a href=\"https://zh.wikipedia.org/wiki/%E8%8E%AB%E6%96%AF%E7%A7%91%E5%9C%8B%E7%AB%8B%E5%A4%A7%E5%AD%B8\" rel=\"noopener nofollow\" target=\"_blank\">莫斯科国立大学</a>取得<a href=\"https://zh.wikipedia.org/wiki/%E5%8D%9A%E5%A3%AB%E5%AD%A6%E4%BD%8D\" rel=\"noopener nofollow\" target=\"_blank\">博士学位</a>后，任职于伦敦<a href=\"https://zh.wikipedia.org/w/index.php?title=%E8%89%BE%E7%95%A5%E7%89%B9%E5%85%84%E5%BC%9F%E5%85%AC%E5%8F%B8&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">艾略特兄弟公司</a>（Elliott Brothers Ltd），开发出第一个商用的<a href=\"https://zh.wikipedia.org/wiki/ALGOL_60\" rel=\"noopener nofollow\" target=\"_blank\">ALGOL 60</a>编译器，很快就成为公司的首席工程师。</p>\n<p>1968 年，成为<a href=\"https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%88%BE%E6%B3%95%E6%96%AF%E7%89%B9%E5%A5%B3%E7%8E%8B%E5%A4%A7%E5%AD%B8\" rel=\"noopener nofollow\" target=\"_blank\">贝尔法斯特女王大学</a>的教授。1977 年回到<a href=\"https://zh.wikipedia.org/wiki/%E7%89%9B%E6%B4%A5%E5%A4%A7%E5%AD%B8\" rel=\"noopener nofollow\" target=\"_blank\">牛津大学</a>担任教授。现为牛津大学荣誉教授，并在剑桥<a href=\"https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BB%9F%E7%A0%94%E7%A9%B6%E9%99%A2\" rel=\"noopener nofollow\" target=\"_blank\">微软研究院</a>担任研究员。</p>\n<p><img alt=\"查尔斯·安东尼·理查德·霍尔爵士\" src=\"https://img2024.cnblogs.com/blog/997046/202601/997046-20260112213059697-501020170.jpg\" /></p>\n<h2 id=\"c-net-交流群\">C# .NET 交流群</h2>\n<p>相信大家在开发中经常会遇到一些性能问题，苦于没有有效的工具去发现性能瓶颈，或者是发现瓶颈以后不知道该如何优化。之前一直有读者朋友询问有没有技术交流群，但是由于各种原因一直都没创建，现在很高兴的在这里宣布，我创建了一个专门交流.NET 性能优化经验的群组，主题包括但不限于：</p>\n<ul>\n<li>如何找到.NET 性能瓶颈，如使用 APM、dotnet tools 等工具</li>\n<li>.NET 框架底层原理的实现，如垃圾回收器、JIT 等等</li>\n<li>如何编写高性能的.NET 代码，哪些地方存在性能陷阱</li>\n</ul>\n<p>希望能有更多志同道合朋友加入，分享一些工作中遇到的.NET 问题和宝贵的分析优化经验。<strong>目前一群已满，现在开放二群。</strong>可以加我 vx，我拉你进群: <strong>ls1075</strong> 另外也创建了 <strong>QQ Group</strong>: 687779078，欢迎大家加入。</p>\n<h3 id=\"本周群聊分析\">本周群聊分析</h3>\n<p><img alt=\"image-20260112212730495\" src=\"https://img2024.cnblogs.com/blog/997046/202601/997046-20260112213059747-418753626.jpg\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-12 21:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/InCerry\">InCerry</a>&nbsp;\n阅读(<span id=\"post_view_count\">75</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【大数据 & AI】Flink Agents 源码解读 --- (6) ---  ActionTask",
      "link": "https://www.cnblogs.com/rossiXYZ/p/19468837",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rossiXYZ/p/19468837\" id=\"cb_post_title_url\" title=\"发布于 2026-01-12 20:53\">\n    <span>【大数据 &amp; AI】Flink Agents 源码解读 --- (6) ---  ActionTask</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"大数据--aiflink-agents-源码解读-----6------actiontask\">【大数据 &amp; AI】Flink Agents 源码解读 --- (6) ---  ActionTask</h1>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#大数据--aiflink-agents-源码解读-----6------actiontask\" rel=\"noopener nofollow\">【大数据 &amp; AI】Flink Agents 源码解读 --- (6) ---  ActionTask</a><ul><li><a href=\"#0x00-概要\" rel=\"noopener nofollow\">0x00 概要</a></li><li><a href=\"#0x01-基础知识\" rel=\"noopener nofollow\">0x01 基础知识</a><ul><li><a href=\"#11-相关组件\" rel=\"noopener nofollow\">1.1 相关组件</a></li><li><a href=\"#12-actiontask\" rel=\"noopener nofollow\">1.2 ActionTask</a></li><li><a href=\"#13-pythonactiontask\" rel=\"noopener nofollow\">1.3 PythonActionTask</a><ul><li><a href=\"#131-定义\" rel=\"noopener nofollow\">1.3.1 定义</a></li><li><a href=\"#132-pythonactiontask-与-function-的关系\" rel=\"noopener nofollow\">1.3.2 PythonActionTask 与 Function 的关系</a></li><li><a href=\"#133-与其他组件的关系\" rel=\"noopener nofollow\">1.3.3 与其他组件的关系</a></li><li><a href=\"#134-调用流程\" rel=\"noopener nofollow\">1.3.4 调用流程</a></li></ul></li><li><a href=\"#14-pythongeneratoractiontask\" rel=\"noopener nofollow\">1.4 PythonGeneratorActionTask</a></li><li><a href=\"#15-javaactiontask\" rel=\"noopener nofollow\">1.5 JavaActionTask</a></li><li><a href=\"#16-actiontaskresult-结构\" rel=\"noopener nofollow\">1.6 ActionTaskResult 结构</a></li></ul></li><li><a href=\"#0x02-actiontask-切分机制\" rel=\"noopener nofollow\">0x02 ActionTask 切分机制</a><ul><li><a href=\"#21-切分方式\" rel=\"noopener nofollow\">2.1 切分方式</a></li><li><a href=\"#22-实现细节\" rel=\"noopener nofollow\">2.2 实现细节</a></li><li><a href=\"#23-关键点\" rel=\"noopener nofollow\">2.3 关键点</a></li></ul></li></ul></li></ul></div><p></p>\n<h2 id=\"0x00-概要\">0x00 概要</h2>\n<p>ActionTask 是 Action 执行的基本单位，代表一个可执行的任务块。一个完整的 Action 可能会被切分成多个 ActionTask 来执行。ActionTask 在整体流程的位置如下：</p>\n<pre><code class=\"language-python\">Action Code → Agent → AgentPlan → ActionExecutionOperator → ActionTask → Flink Runtime\n</code></pre>\n<h2 id=\"0x01-基础知识\">0x01 基础知识</h2>\n<p>ActionTask 是 Action 执行过程中的一个片段，用于支持复杂的执行逻辑（如异步处理），对应关系如下：</p>\n<ul>\n<li>一个 Action 对应一个函数</li>\n</ul>\n<p>在 AgentPlan 中，每个 Action 包含一个执行函数 (exec)，通常是 PythonFunction 或 JavaFunction，例如在 tool_call_action.py 中：</p>\n<pre><code class=\"language-java\">TOOL_CALL_ACTION = Action (\n    name=\"tool_call_action\",\n    exec=PythonFunction.from_callable (process_tool_request), // 一个函数\n    listen_event_types=[...]\n)\n</code></pre>\n<ul>\n<li>一个 Action 可能产生多个 ActionTask\n<ul>\n<li>ActionTask 是 Action 的执行时表示，可以看作是 Action 的 “执行片段”</li>\n<li>一个 Action 可能在执行过程中被拆分为多个 ActionTask，特别是在处理异步操作时</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"11-相关组件\">1.1 相关组件</h3>\n<p>ActionTask 概念的相关组件如下</p>\n<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>核心功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JavaActionTask</td>\n<td>执行 Java 函数</td>\n</tr>\n<tr>\n<td>PythonActionTask</td>\n<td>执行 Python 函数，支持异步 / 生成器模式，桥接 Java 与 Python 生态</td>\n</tr>\n<tr>\n<td>LocalRunnerContext</td>\n<td>本地执行上下文，模拟 Flink 分布式状态，管理事件队列、key 隔离状态、资源访问</td>\n</tr>\n<tr>\n<td>ActionTaskResult</td>\n<td>动作执行结果载体，包含是否完成、输出事件、下一个待执行任务（若有）</td>\n</tr>\n<tr>\n<td>PythonGeneratorActionTask</td>\n<td>处理 Python 生成器的异步任务，持续执行直到完成所有异步操作</td>\n</tr>\n<tr>\n<td>Tool 相关机制</td>\n<td>支持装饰器（@tool）、add_resource 等方式注册工具，通过 TOOL_CALL_ACTION 触发执行</td>\n</tr>\n</tbody>\n</table>\n<p>在系统中的架构如下</p>\n<p><img alt=\"flink-6-1\" class=\"lazyload\" /></p>\n<h3 id=\"12-actiontask\">1.2 ActionTask</h3>\n<p>我们接下来看看 ActionTask 的具体实现。</p>\n<p>ActionTask 是基类。</p>\n<pre><code class=\"language-java\">/**\n * This class represents a task related to the execution of an action in {@link\n * ActionExecutionOperator}.\n *\n * &lt;p&gt;An action is split into multiple code blocks, and each code block is represented by an {@code\n * ActionTask}. You can call {@link #invoke()} to execute a code block and obtain invoke result\n * {@link ActionTaskResult}. If the action contains additional code blocks, you can obtain the next\n * {@code ActionTask} via {@link ActionTaskResult#getGeneratedActionTask()} and continue executing\n * it.\n */\npublic abstract class ActionTask {\n    protected final Object key;\n    protected final Event event;\n    protected final Action action;\n    /**\n     * Since RunnerContextImpl contains references to the Operator and state, it should not be\n     * serialized and included in the state with ActionTask. Instead, we should check if a valid\n     * RunnerContext exists before each ActionTask invocation and create a new one if necessary.\n     */\n    protected transient RunnerContextImpl runnerContext;\n\n    public ActionTask(Object key, Event event, Action action) {\n        this.key = key;\n        this.event = event;\n        this.action = action;\n    }\n\n    public RunnerContextImpl getRunnerContext() {\n        return runnerContext;\n    }\n\n    public void setRunnerContext(RunnerContextImpl runnerContext) {\n        this.runnerContext = runnerContext;\n    }\n\n    public Object getKey() {\n        return key;\n    }\n\n    /** Invokes the action task. */\n    public abstract ActionTaskResult invoke() throws Exception;\n\n    public class ActionTaskResult {\n        private final boolean finished;\n        private final List&lt;Event&gt; outputEvents;\n        private final Optional&lt;ActionTask&gt; generatedActionTaskOpt;\n\n        public ActionTaskResult(\n                boolean finished,\n                List&lt;Event&gt; outputEvents,\n                @Nullable ActionTask generatedActionTask) {\n            this.finished = finished;\n            this.outputEvents = outputEvents;\n            this.generatedActionTaskOpt = Optional.ofNullable(generatedActionTask);\n        }\n\n        public boolean isFinished() {\n            return finished;\n        }\n\n        public List&lt;Event&gt; getOutputEvents() {\n            return outputEvents;\n        }\n\n        public Optional&lt;ActionTask&gt; getGeneratedActionTask() {\n            return generatedActionTaskOpt;\n        }\n    }\n}\n</code></pre>\n<h3 id=\"13-pythonactiontask\">1.3 PythonActionTask</h3>\n<p>PythonActionTask 是一个专门用于执行 Python 动作任务的特殊 ActionTask 实现。它的主要作用包括：</p>\n<ul>\n<li>执行 Python 函数：调用 Python 函数来处理事件</li>\n<li>处理异步操作：支持 Python 中的异步操作，通过生成器机制实现</li>\n<li>桥接 Java 和 Python：作为 Java 端和 Python 端之间的桥梁，协调两者间的交互</li>\n</ul>\n<h4 id=\"131-定义\">1.3.1 定义</h4>\n<p>PythonActionTask 对应一个 Python 函数（更准确地说是一个 PythonFunction 对象），这个函数是在创建 Action 时定义的，存储在 action.getExec() 中。但PythonActionTask 不仅仅是简单的函数封装，而是使其能够在 Flink Agents 框架中正确执行，并支持框架所需的高级特性。它提供了以下附加价值：</p>\n<ul>\n<li>复杂逻辑：PythonActionTask 不仅仅是执行函数，还负责处理复杂的交互逻辑</li>\n<li>执行环境管理：为函数提供合适的执行上下文</li>\n<li>异步支持：通过生成器机制支持长时间运行的操作</li>\n<li>事件处理：管理和传递执行过程中产生的事件</li>\n<li>状态维护：在整个执行过程中维护必要的状态信息</li>\n</ul>\n<p>PythonActionTask 在系统架构中的位置和交互关系如下：</p>\n<p><img alt=\"Flink-6-2\" class=\"lazyload\" /></p>\n<p>代码如下：</p>\n<pre><code class=\"language-java\">public class PythonActionTask extends ActionTask {\n    public ActionTaskResult invoke() throws Exception {\n        PythonActionExecutor pythonActionExecutor = getPythonActionExecutor();\n\n        // 这里执行实际的 Python 函数\n        String pythonGeneratorRef =\n            pythonActionExecutor.executePythonFunction(\n                (PythonFunction) action.getExec(), // &lt;-- 这就是对应的函数\n                (PythonEvent) event,\n                runnerContext);\n\n        // 处理异步情况\n        if (pythonGeneratorRef != null) {\n            // 如果函数返回了生成器，则创建新的任务继续执行\n            ActionTask tempGeneratedActionTask =\n                new PythonGeneratorActionTask(key, event, action, pythonGeneratorRef);\n            tempGeneratedActionTask.setRunnerContext(runnerContext);\n        if (pythonGeneratorRef != null) {\n            // 如果函数返回了生成器，则创建新的任务继续执行\n            ActionTask tempGeneratedActionTask = \n                new PythonGeneratorActionTask(key, event, action, pythonGeneratorRef);\n            tempGeneratedActionTask.setRunnerContext(runnerContext);\n            return tempGeneratedActionTask.invoke();\n        }\n        // 否则表示函数已执行完毕\n        return new ActionTaskResult(\n            true, \n            runnerContext.drainEvents(event.getSourceTimestamp()), \n            null);            \n</code></pre>\n<h4 id=\"132-pythonactiontask-与-function-的关系\">1.3.2 PythonActionTask 与 Function 的关系</h4>\n<p>PythonActionTask 与 Function 的关系的如下</p>\n<p><img alt=\"Flink-6-3\" class=\"lazyload\" /></p>\n<h4 id=\"133-与其他组件的关系\">1.3.3 与其他组件的关系</h4>\n<p>PythonActionTask 与其他组件的关系如下图所示。</p>\n<p><img alt=\"Flink-6-4\" class=\"lazyload\" /></p>\n<h4 id=\"134-调用流程\">1.3.4 调用流程</h4>\n<p>PythonActionTask.invoke() 流程如下图所示，其关键特点为：</p>\n<ul>\n<li>异步支持：通过 Python 生成器机制支持长时间运行的操作</li>\n<li>状态管理：与 ActionExecutionOperator 协作管理执行状态</li>\n<li>错误处理：适当地处理 Python 执行过程中可能出现的异常</li>\n<li>内存管理：与 RunnerContext 集成，管理短期记忆和其他状态</li>\n</ul>\n<p><img alt=\"Flink-6-5\" class=\"lazyload\" /></p>\n<p>PythonActionTask 在整个系统中起到了至关重要的作用，它使得 Flink Agents 能够无缝集成 Python 生态系统中的各种 AI 工具和库，同时保持与 Flink 流处理引擎的良好集成。</p>\n<h3 id=\"14-pythongeneratoractiontask\">1.4 PythonGeneratorActionTask</h3>\n<p>PythonGeneratorActionTask 是 PythonActionTask 的派生类。</p>\n<ul>\n<li>当 Python 函数中使用了 yield 或异步操作时，Python 执行器会检测到这种情况并返回一个 Generator 引用</li>\n<li>系统会创建 PythonGeneratorActionTask 来继续执行</li>\n</ul>\n<pre><code class=\"language-java\">/** An {@link ActionTask} wrapper a Python Generator to represent a code block in Python action. */\npublic class PythonGeneratorActionTask extends PythonActionTask {\n    private final String pythonGeneratorRef;\n\n    public PythonGeneratorActionTask(\n            Object key, Event event, Action action, String pythonGeneratorRef) {\n        super(key, event, action);\n        this.pythonGeneratorRef = pythonGeneratorRef;\n    }\n\n    @Override\n    public ActionTaskResult invoke() {\n        boolean finished = getPythonActionExecutor().callPythonGenerator(pythonGeneratorRef);\n        ActionTask generatedActionTask = finished ? null : this;\n        return new ActionTaskResult(\n                finished,\n                runnerContext.drainEvents(event.getSourceTimestamp()),\n                generatedActionTask);\n    }\n}\n</code></pre>\n<h3 id=\"15-javaactiontask\">1.5 JavaActionTask</h3>\n<p>JavaActionTask 执行 Java ActionTask。</p>\n<pre><code class=\"language-java\">/**\n * A special {@link ActionTask} designed to execute a Java action task.\n *\n * &lt;p&gt;Note that Java action currently do not support asynchronous execution. As a result, a Java\n * action task will be invoked only once.\n */\npublic class JavaActionTask extends ActionTask {\n\n    private final ClassLoader userCodeClassLoader;\n\n    public JavaActionTask(Object key, Event event, Action action, ClassLoader userCodeClassLoader) {\n        super(key, event, action);\n        checkState(action.getExec() instanceof JavaFunction);\n        this.userCodeClassLoader = userCodeClassLoader;\n    }\n\n    @Override\n    public ActionTaskResult invoke() throws Exception {\n        runnerContext.checkNoPendingEvents();\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader(userCodeClassLoader);\n            action.getExec().call(event, runnerContext);\n        } finally {\n            Thread.currentThread().setContextClassLoader(cl);\n        }\n        return new ActionTaskResult(\n                true, runnerContext.drainEvents(event.getSourceTimestamp()), null);\n    }\n}\n</code></pre>\n<h3 id=\"16-actiontaskresult-结构\">1.6 ActionTaskResult 结构</h3>\n<p>每次执行 ActionTask 后会返回一个 ActionTaskResult 对象：</p>\n<pre><code class=\"language-java\">public class ActionTaskResult {\n    private final boolean finished;                 // 是否已完成\n    private final List&lt;Event&gt; outputEvents;         // 输出事件\n    private final Optional&lt;ActionTask&gt; generatedActionTaskOpt; // 下一个 ActionTask（如果有）\n// ...\n}\n</code></pre>\n<h2 id=\"0x02-actiontask-切分机制\">0x02 ActionTask 切分机制</h2>\n<p>在 Flink Agents 框架中，ActionTask 的切分是为了支持长时间运行的操作和异步执行。切分的好处如下：</p>\n<ul>\n<li>避免阻塞：长时间运行的操作不会阻塞整个操作符</li>\n<li>提高并发性：允许其他 key 的任务同时执行</li>\n<li>容错能力：每个 ActionTask 可以单独失败和恢复</li>\n<li>资源管理：更好地管理内存和其他资源</li>\n</ul>\n<p>这种切分机制使得 Flink Agents 能够高效地处理复杂的，长时间运行的 AI Agent 任务，同时保持系统的响应的稳定性。</p>\n<h3 id=\"21-切分方式\">2.1 切分方式</h3>\n<p>主要切分方式如下：</p>\n<p>概念上的拆分</p>\n<ul>\n<li>一个 Action 在概念上可被拆成多个顺序执行的代码块，每个代码块成为一个 ActionTask 实例。</li>\n<li>设计目的在于细粒度控制，尤其适用于异步操作。</li>\n</ul>\n<p>创建与流程</p>\n<ul>\n<li>初始触发：ActionExecutionOperator 通过 createActionTask() 为每个动作生成首个 ActionTask。</li>\n<li>执行过程：若动作产生生成器（异步），可再实例化新的 ActionTask 继续后续代码块。</li>\n</ul>\n<pre><code class=\"language-java\">    /**\n     * Processes an incoming event for the given key and may submit a new mail\n     * `tryProcessActionTaskForKey` to continue processing.\n     */\n    private void processEvent(Object key, Event event) throws Exception {\n        notifyEventProcessed(event);\n\n        boolean isInputEvent = EventUtil.isInputEvent(event);\n        if (EventUtil.isOutputEvent(event)) {\n        } else {\n            // We then obtain the triggered action and add ActionTasks to the waiting processing\n            // queue.\n            List&lt;Action&gt; triggerActions = getActionsTriggeredBy(event);\n            if (triggerActions != null &amp;&amp; !triggerActions.isEmpty()) {\n                for (Action triggerAction : triggerActions) {\n                    actionTasksKState.add(createActionTask(key, triggerAction, event));\n                }\n            }\n        }\n    }\n</code></pre>\n<p>createActionTask 代码如下。</p>\n<pre><code class=\"language-java\">    private ActionTask createActionTask(Object key, Action action, Event event) {\n        if (action.getExec() instanceof JavaFunction) {\n            return new JavaActionTask(\n                    key, event, action, getRuntimeContext().getUserCodeClassLoader());\n        } else if (action.getExec() instanceof PythonFunction) {\n            return new PythonActionTask(key, event, action);\n        } else {\n            throw new IllegalStateException(\n                    \"Unsupported action type: \" + action.getExec().getClass());\n        }\n    }\n\n</code></pre>\n<h3 id=\"22-实现细节\">2.2 实现细节</h3>\n<p>ActionTask.java 中有如下，这意味着:</p>\n<ul>\n<li>一个 Action 可能被拆分成多个代码块</li>\n<li>每个代码块由一个 ActionTask 表示</li>\n<li>通过调用 invoke () 执行代码块并获得结果</li>\n<li>如果 Action 包含更多代码块，可以从 ActionTaskResult 中获取下一个 ActionTask</li>\n</ul>\n<pre><code class=\"language-java\">/**\n * 此类表示在 ActionExecutionOperator 中执行的动作任务。\n *\n * &lt;p&gt;一个动作会被拆分为多个代码块，每个代码块都由一个 ActionTask 表示。\n * 可以调用 #invoke() 来执行一个代码块并获得执行结果（ActionTaskResult）。\n * 如果动作包含额外的代码块，可通过 ActionTaskResult#getGeneratedActionTask()\n * 获取下一个 ActionTask 并继续执行它。\n */\n\n</code></pre>\n<p>Python 集成（PythonActionTask.java）</p>\n<ul>\n<li>当 Python 函数中使用了 yield 或异步操作时，Python 执行器会检测到这种情况并返回一个 Generator 引用</li>\n<li>系统会创建 PythonGeneratorActionTask 来继续执行</li>\n</ul>\n<p>这说明在处理异步 Python 函数时，一个 Action 可能会产生多个 ActionTask：</p>\n<ul>\n<li>初始的 PythonActionTask</li>\n<li>后续的 PythonGeneratorActionTask（如果需要）</li>\n</ul>\n<pre><code class=\"language-java\">/**\n * 专门用于执行 Python 动作任务的特殊 ActionTask。\n *\n * &lt;p&gt;在 Python 中进行异步执行期间，PythonActionTask 可以生成一个\n * PythonGeneratorActionTask 来代表后续需要的代码块。\n */\npublic class PythonActionTask extends ActionTask {\n    public ActionTaskResult invoke() throws Exception {\n        ...\n        String pythonGeneratorRef = \n            pythonActionExecutor.executePythonFunction(\n                (PythonFunction)action.getExec(),\n                (PythonEvent)event,\n                runnerContext);\n\n        // 如果用户定义的动作使用接口提交了异步任务，\n        // 它将在第一次执行后返回一个 Python 生成器对象实例。\n        // 否则意味着没有提交异步任务且动作已经完成。\n        if (pythonGeneratorRef != null) {\n            // Python 动作生成了一个生成器。我们需要执行一次它，\n            // 这将提交一个异步任务并返回动作是否已完成。\n            ActionTask tempGeneratedActionTask = \n                new PythonGeneratorActionTask(key, event, action, pythonGeneratorRef);\n            tempGeneratedActionTask.setRunnerContext(runnerContext);\n            return tempGeneratedActionTask.invoke();\n        }\n        return new ActionTaskResult(\n            true, runnerContext.drainEvents(event.getSourceTimestamp()), null);\n    }\n}\n\n</code></pre>\n<h3 id=\"23-关键点\">2.3 关键点</h3>\n<p>ActionTask 拆分的关键点如下：</p>\n<ul>\n<li>顺序执行：对于给定的键，任务按顺序执行，以保持顺序性和一致性</li>\n<li>异步处理：当动作涉及异步操作时：\n<ul>\n<li>初始任务执行到异步操作为止；</li>\n<li>返回一个新的 ActionTask 来表示后续的操作；</li>\n<li>后续任务处理异步结果并继续执行</li>\n</ul>\n</li>\n<li>状态管理：每个 ActionTask 通过 RunnerContext 维护其状态，确保拆分之间的连续性</li>\n</ul>\n<ul>\n<li>基于邮箱的处理：使用 Flink 的邮箱执行器来调度后续任务的处理：</li>\n</ul>\n<pre><code class=\"language-java\">// 提交新邮件以继续处理\nmailboxExecutor.submit(() -&gt; tryProcessActionTaskForKey(key), \"process action task\");\n\n</code></pre>\n<p>这种设计允许将带有异步操作的复杂动作分解为可管理的单元，同时保持执行语义和状态一致性。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-12 20:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rossiXYZ\">罗西的思考</a>&nbsp;\n阅读(<span id=\"post_view_count\">25</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}