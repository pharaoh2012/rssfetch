{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "信创数据库 PolarDB V2.0 产品架构及核心功能",
      "link": "https://www.cnblogs.com/fuguier/p/19416608",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/fuguier/p/19416608\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 16:25\">\n    <span>信创数据库 PolarDB V2.0 产品架构及核心功能</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>PolarDB PostgreSQL轻量版支持本地化部署，能够部署在您的自主环境中。同时，该版本仍然保留PolarDB技术团队深厚的内核优化成果，在保持高性能的同时，显著降低成本。</p>\n<p>自PolarDB正式上线以来，已成功支撑成千上万的客户应用，并在真实的商业环境中做出卓越表现。PolarDB凭借其卓越的性能、坚如磐石的稳定性和为企业量身定制的高级功能，为客户提供了前所未有的数据库体验。随着技术的不断进步和国产市场需求的变化，PolarDB推出了满足国产市场需求且更具性价比的轻量化版本（<a href=\"https://www.aliyun.com/activity/database/polardb-v2\" rel=\"noopener nofollow\">PolarDB V2.0轻量化版本</a>）。<br /><a href=\"https://survey.aliyun.com/apps/zhiliao/84yo-1aC0\" rel=\"noopener nofollow\">点此立即咨询</a></p>\n<h3 id=\"item-1\">产品架构</h3>\n<p>PolarDB PostgreSQL轻量版使用PolarDB自研的软件栈部署形态PolarFlex，实现一键部署单节点、一主一备、一主多备等场景。提供一写多读、高可用、监控、备份等基本能力，范围以下图PolarFlex标注的虚线框为准：</p>\n<p><img alt=\"架构图\" class=\"lazyload\" height=\"427\" width=\"735\" /></p>\n<p>&nbsp;</p>\n<p><img alt=\"\" class=\"lazyload\" title=\"\" /></p>\n<p>PolarDB PostgreSQL轻量版包含以下核心组件：</p>\n<ul>\n<li>pdbcli：安装部署的客户端组件。作为整个PolarFlex集群的管理客户端，能够进行数据库集群部署、添加Standby节点、高可用切换、版本升级等操作。</li>\n<li>Proxy：数据库代理组件。客户端通过代理组件访问数据库，可自动实现数据库集群的读写分离功能。</li>\n<li>Cluster Manager：数据库集群的高可用组件。在主节点发生宕机或故障时，系统能够即时选择可用的备节点进行切换，也支持手动切换。高可用组件本身采用三节点部署架构，利用Raft协议确保自身的高可用性。</li>\n<li>Monitor Agent：监控采集组件。负责采集数据库、主机、Proxy等组件的监控数据，并提供与Prometheus、InfluxData或Zabbix等开源监控数据存储组件的对接能力。</li>\n\n</ul>\n<h3 id=\"item-2\">核心功能</h3>\n<p>PolarDB PostgreSQL轻量版支持社区PostgreSQL 14的相关能力，在此基础上增加了相关企业级能力供您使用，具体对比如下：</p>\n<p><img alt=\"核心功能\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<p><img alt=\"\" class=\"lazyload\" title=\"\" /></p>\n<p>PolarDB PostgreSQL轻量版专为国产环境设计，适用于对资源利用和成本控制有较高要求的业务环境。如果您面临以下需求或挑战，PolarDB PostgreSQL轻量版将是理想的选择：</p>\n<ul>\n<li>无法使用公共云</li>\n\n</ul>\n<p>业务场景受限，出于合规性、安全性或其他因素，无法部署在公共云上时，PolarDB PostgreSQL轻量版提供灵活的私有化部署方案。</p>\n<ul>\n<li>严格的资源与成本要求</li>\n\n</ul>\n<p>以更少的资源占用和更低的成本提供高效的PolarDB数据库服务。</p>\n<ul>\n<li>国产生态适配</li>\n\n</ul>\n<p>面向国产生态，PolarDB PostgreSQL轻量版深度适配主流国产硬件和操作系统。</p>\n<ul>\n<li>高性能与高兼容性</li>\n\n</ul>\n<p>在降低资源消耗的同时，PolarDB PostgreSQL轻量版保持对PostgreSQL的完全兼容性，并继承PolarDB的核心优势。</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 16:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/fuguier\">王权富贵-</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "CodeSpirit 开发环境搭建及启动指南",
      "link": "https://www.cnblogs.com/codelove/p/19392132",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/codelove/p/19392132\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 15:07\">\n    <span>CodeSpirit 开发环境搭建及启动指南</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"概述\">概述</h2>\n<p>本指南将帮助您快速搭建CodeSpirit（码灵）低代码框架的开发环境。CodeSpirit基于 .NET 10 和 Aspire 13.0 构建，通过简单的几个步骤即可启动完整的开发环境。</p>\n<p><strong>最后更新</strong>: 2025年12月22日<br />\n<strong>框架版本</strong>: v2.0.0<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224131727898-298580147.png\" /></p>\n<h2 id=\"快速开始\">快速开始</h2>\n<h3 id=\"前置要求\">前置要求</h3>\n<ul>\n<li><strong>操作系统</strong>: Windows 10/11, macOS 12+, 或 Linux (Ubuntu 20.04+)</li>\n<li><strong>CPU</strong>: Intel i5 或 AMD Ryzen 5 及以上（推荐i7/Ryzen 7）</li>\n<li><strong>内存</strong>: 16GB RAM（推荐32GB）</li>\n<li><strong>存储</strong>: 至少20GB可用空间（SSD推荐）</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>: CodeSpirit默认使用GreptimeDB进行审计日志存储和搜索。Elasticsearch为可选组件，如需使用请参考相关配置文档。</p>\n</blockquote>\n<h3 id=\"1-安装-net-10-sdk\">1. 安装 .NET 10 SDK</h3>\n<h4 id=\"windows\">Windows</h4>\n<pre><code class=\"language-powershell\"># 使用 winget 安装\nwinget install Microsoft.DotNet.SDK.10\n\n# 或下载安装包\n# https://dotnet.microsoft.com/download/dotnet/10.0\n</code></pre>\n<h4 id=\"macos\">macOS</h4>\n<pre><code class=\"language-bash\"># 使用 Homebrew\nbrew install --cask dotnet-sdk\n\n# 或下载安装包\n# https://dotnet.microsoft.com/download/dotnet/10.0\n</code></pre>\n<h4 id=\"linux-ubuntu\">Linux (Ubuntu)</h4>\n<pre><code class=\"language-bash\"># 添加微软包源\nwget https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\nsudo apt-get update\nsudo apt-get install -y dotnet-sdk-10.0\n</code></pre>\n<h4 id=\"验证安装\">验证安装</h4>\n<pre><code class=\"language-bash\">dotnet --version\n# 应显示 10.x.x\n</code></pre>\n<h3 id=\"2-安装开发工具\">2. 安装开发工具</h3>\n<h4 id=\"visual-studio-2026-推荐\">Visual Studio 2026 (推荐)</h4>\n<ul>\n<li>下载地址: <a href=\"https://visualstudio.microsoft.com/vs/\" rel=\"noopener nofollow\" target=\"_blank\">https://visualstudio.microsoft.com/vs/</a></li>\n<li>选择工作负载：<strong>ASP.NET 和 Web 开发</strong></li>\n</ul>\n<h4 id=\"或者-visual-studio-code\">或者 Visual Studio Code</h4>\n<pre><code class=\"language-bash\"># Windows\nwinget install Microsoft.VisualStudioCode\n\n# macOS\nbrew install --cask visual-studio-code\n\n# Linux\nsudo snap install code --classic\n</code></pre>\n<p>VS Code必需扩展：</p>\n<pre><code class=\"language-bash\">code --install-extension ms-dotnettools.csharp\ncode --install-extension ms-dotnettools.vscode-dotnet-runtime\n</code></pre>\n<h3 id=\"3-安装docker-desktop\">3. 安装Docker Desktop</h3>\n<ul>\n<li>下载地址: <a href=\"https://www.docker.com/products/docker-desktop\" rel=\"noopener nofollow\" target=\"_blank\">https://www.docker.com/products/docker-desktop</a></li>\n<li>安装后启动Docker Desktop</li>\n</ul>\n<p>验证安装：</p>\n<pre><code class=\"language-bash\">docker --version\n</code></pre>\n<h2 id=\"项目启动\">项目启动</h2>\n<h3 id=\"1-克隆项目\">1. 克隆项目</h3>\n<pre><code class=\"language-bash\">git clone https://gitee.com/magicodes/code-spirit.git\ncd code-spirit\n</code></pre>\n<h3 id=\"2-启动基础服务\">2. 启动基础服务</h3>\n<p>CodeSpirit使用Aspire自动管理所有依赖服务，无需手动启动Docker容器：</p>\n<pre><code class=\"language-bash\"># Aspire会自动启动以下服务：\n# - MySQL/SQL Server (根据配置选择，端口: 3306/1433)\n# - Redis (端口: 6380)\n# - RabbitMQ (端口: 5672, 管理界面: 15672)\n# - GreptimeDB (端口: 4000/4001)\n# - Seq日志服务 (端口: 5341)\n</code></pre>\n<blockquote>\n<p><strong>服务说明</strong>:</p>\n<ul>\n<li><strong>MySQL/SQL Server</strong>: 主数据库存储（根据DatabaseType配置选择）</li>\n<li><strong>Redis</strong>: 缓存和会话存储（端口: 6380）</li>\n<li><strong>RabbitMQ</strong>: 消息队列服务（管理界面端口: 15672）</li>\n<li><strong>GreptimeDB</strong>: 时序数据库，用于审计日志存储（HTTP端口: 4000, gRPC端口: 4001）</li>\n<li><strong>Seq</strong>: 结构化日志服务（端口: 5341）</li>\n</ul>\n</blockquote>\n<h3 id=\"3-运行项目\">3. 运行项目</h3>\n<h4 id=\"使用net-aspire推荐\">使用.NET Aspire（推荐）</h4>\n<pre><code class=\"language-bash\"># 进入AppHost项目目录\ncd Src/CodeSpirit.AppHost\n\n# 运行Aspire应用\ndotnet run\n</code></pre>\n<p>如果是正常启动，将看到以下缤纷的控制台输出：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224131931648-1820053723.png\" /></p>\n<p>启动后访问：</p>\n<ul>\n<li><strong>Aspire Dashboard</strong>: <a href=\"http://localhost:17109\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:17109</a>（自动打开）</li>\n<li><strong>Web应用</strong>: <a href=\"https://localhost:7120\" rel=\"noopener nofollow\" target=\"_blank\">https://localhost:7120</a>（启动后显示具体端口）</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>:</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>实际端口号可能因系统配置而异，请查看Aspire Dashboard获取准确的端口信息。</li>\n<li>如何登录页没有正常呈现，请按照下面的必填参数配置进行配置。</li>\n</ol>\n</blockquote>\n<h4 id=\"或者使用visual-studio\">或者使用Visual Studio</h4>\n<ol>\n<li>\n<p>打开 <code>CodeSpirit.sln</code></p>\n</li>\n<li>\n<p>设置 <code>CodeSpirit.AppHost</code> 为启动项目</p>\n</li>\n<li>\n<p>按 F5 运行<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224131917733-1101676572.png\" /><br />\n注意，需确保以下服务均正常启动：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224131931648-1820053723.png\" /></p>\n</li>\n</ol>\n<h2 id=\"项目结构\">项目结构</h2>\n<p>CodeSpirit采用Clean Architecture设计，项目结构如下：</p>\n<pre><code>CodeSpirit/\n├── Src/\n│   ├── ApiServices/                     # API服务（解决方案文件夹）\n│   │   ├── CodeSpirit.IdentityApi/      # 身份认证API\n│   │   ├── CodeSpirit.ExamApi/          # 考试系统API  \n│   │   ├── CodeSpirit.MessagingApi/     # 消息服务API\n│   │   ├── CodeSpirit.ConfigCenter/    # 配置中心API\n│   │   ├── CodeSpirit.FileStorageApi/  # 文件存储API\n│   │   ├── CodeSpirit.SurveyApi/        # 问卷调查API\n│   │   ├── CodeSpirit.ApprovalApi/      # 审批工作流API\n│   │   ├── CodeSpirit.PathfinderApi/    # AI目标管理API\n│   │   └── CodeSpirit.AiCardsApi/       # AI卡片API\n│   ├── Components/                     # 组件库\n│   │   ├── CodeSpirit.Aggregator/       # 聚合器组件\n│   │   ├── CodeSpirit.AiFormFill/       # AI表单智能填充组件\n│   │   ├── CodeSpirit.Amis/             # UI生成引擎\n│   │   ├── CodeSpirit.Authorization/    # 权限组件\n│   │   ├── CodeSpirit.Audit/            # 审计组件\n│   │   ├── CodeSpirit.Caching/          # 分布式缓存组件\n│   │   ├── CodeSpirit.Charts/           # 智能图表组件\n│   │   ├── CodeSpirit.ConfigCenter.Client/ # 配置中心客户端\n│   │   ├── CodeSpirit.LLM/              # 大语言模型组件\n│   │   ├── CodeSpirit.Messaging/        # 消息队列组件\n│   │   ├── CodeSpirit.MultiTenant/      # 多租户组件\n│   │   ├── CodeSpirit.Navigation/       # 导航组件\n│   │   ├── CodeSpirit.PdfGeneration/    # PDF生成组件\n│   │   ├── CodeSpirit.ScheduledTasks/   # 定时任务组件\n│   │   ├── CodeSpirit.Settings/         # 设置管理组件\n│   │   ├── CodeSpirit.Shared/           # 组件共享库\n│   │   └── CodeSpirit.UdlCards/         # UDL卡片组件\n│   ├── CodeSpirit.AppHost/              # Aspire应用宿主\n│   ├── CodeSpirit.Core/                 # 核心定义\n│   ├── CodeSpirit.ServiceDefaults/      # 服务默认配置\n│   ├── CodeSpirit.Shared/               # 全局共享库\n│   └── CodeSpirit.Web/                  # Web前端项目\n├── Tests/                               # 测试项目\n├── Docs/                                # 项目文档\n├── k8s/                                 # Kubernetes部署文件\n└── CodeSpirit.sln                       # 解决方案文件\n</code></pre>\n<h2 id=\"默认配置\">默认配置</h2>\n<p>项目使用以下默认配置，由.NET Aspire自动管理：</p>\n<h3 id=\"数据库连接\">数据库连接</h3>\n<ul>\n<li>\n<p><strong>数据库类型</strong>: 支持MySQL和SQL Server两种数据库（通过<code>DatabaseType</code>配置选择）</p>\n</li>\n<li>\n<p><strong>MySQL</strong>: 端口3306，由Aspire自动配置</p>\n<p>可以从资源面板访问管理UI（phpmyadmin）：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132002956-598129788.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132042244-558588173.png\" /></p>\n</li>\n<li>\n<p><strong>SQL Server</strong>: 端口1433，由Aspire自动配置</p>\n</li>\n<li>\n<p><strong>数据库</strong>: 自动创建和迁移</p>\n</li>\n<li>\n<p><strong>连接字符串</strong>: 由Aspire自动管理</p>\n</li>\n</ul>\n<h3 id=\"缓存和消息队列\">缓存和消息队列</h3>\n<ul>\n<li>\n<p><strong>Redis</strong>: <code>localhost:6380</code>（具体见管理UI）</p>\n</li>\n<li>\n<p><strong>RabbitMQ</strong>: <code>localhost:5672</code> (管理界面: <a href=\"http://localhost:15672\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:15672</a>, 用户名/密码: admin/Password123)</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132123458-1426760447.png\" /></p>\n</li>\n</ul>\n<h3 id=\"其他服务端口\">其他服务端口</h3>\n<ul>\n<li>\n<p><strong>GreptimeDB</strong>:</p>\n<ul>\n<li>HTTP端口: <code>localhost:4000</code></li>\n<li>gRPC端口: <code>localhost:4001</code></li>\n<li>健康检查: <a href=\"http://localhost:4000/health\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:4000/health</a></li>\n</ul>\n</li>\n<li>\n<p><strong>Seq日志服务</strong>: <code>localhost:5341</code>（具体端口见资源面板）</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132136208-2065968736.png\" /></p>\n</li>\n<li>\n<p><strong>Redis Commander</strong>: 通过Aspire Dashboard访问</p>\n</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132147317-671812413.png\" /></p>\n<h2 id=\"必填参数配置\">必填参数配置</h2>\n<p>CodeSpirit 使用 .NET Aspire 的参数管理机制来配置敏感信息和环境相关参数。在首次启动前，您需要配置以下必填参数。提示UI如下：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132156259-1567610099.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132203941-1321498621.png\" /></p>\n<h3 id=\"参数配置方式\">参数配置方式</h3>\n<p>Aspire 支持两种参数配置方式，配置系统会按以下优先级读取（高优先级会覆盖低优先级）：</p>\n<ol>\n<li><strong>User Secrets</strong>（开发环境推荐，避免提交敏感信息到代码库）</li>\n<li><strong>appsettings.json</strong>（开发环境备选方案）</li>\n</ol>\n<blockquote>\n<p><strong>提示</strong>: 对于敏感信息（如 API 密钥），强烈推荐使用 User Secrets，避免将密钥提交到代码库。</p>\n</blockquote>\n<h3 id=\"必填参数列表\">必填参数列表</h3>\n<h4 id=\"llm-配置参数\">LLM 配置参数</h4>\n<p>以下参数用于配置通用 LLM 服务（如 AI 卡片、智能审批等功能）：</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>说明</th>\n<th>是否必填</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>llm-ApiKey</code></td>\n<td>LLM API密钥</td>\n<td>✅ <strong>必填</strong></td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>llm-ApiBaseUrl</code></td>\n<td>LLM API基础地址</td>\n<td>可选</td>\n<td><code>https://dashscope.aliyuncs.com/compatible-mode/v1</code></td>\n</tr>\n<tr>\n<td><code>llm-ModelName</code></td>\n<td>LLM模型名称</td>\n<td>可选</td>\n<td><code>qwen-flash</code></td>\n</tr>\n<tr>\n<td><code>llm-TimeoutSeconds</code></td>\n<td>请求超时时间（秒）</td>\n<td>可选</td>\n<td><code>120</code></td>\n</tr>\n<tr>\n<td><code>llm-MaxTokens</code></td>\n<td>最大Token数</td>\n<td>可选</td>\n<td><code>2048</code></td>\n</tr>\n<tr>\n<td><code>llm-UseProxy</code></td>\n<td>是否使用代理</td>\n<td>可选</td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td><code>llm-ProxyAddress</code></td>\n<td>代理地址</td>\n<td>可选</td>\n<td>空字符串</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ai表单填充-llm-配置参数\">AI表单填充 LLM 配置参数</h4>\n<p>以下参数用于配置 AI 表单智能填充功能：</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>说明</th>\n<th>是否必填</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ai-form-fill-llm-ApiKey</code></td>\n<td>AI表单填充LLM API密钥</td>\n<td>✅ <strong>必填</strong></td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-ApiBaseUrl</code></td>\n<td>API基础地址</td>\n<td>可选</td>\n<td><code>https://dashscope.aliyuncs.com/compatible-mode/v1</code></td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-ModelName</code></td>\n<td>模型名称</td>\n<td>可选</td>\n<td><code>qwen3-max-preview</code></td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-DisableThinking</code></td>\n<td>禁用思考模式</td>\n<td>可选</td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-ResponseFormatType</code></td>\n<td>响应格式类型</td>\n<td>可选</td>\n<td><code>json_object</code></td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-Temperature</code></td>\n<td>温度参数</td>\n<td>可选</td>\n<td><code>0.1</code></td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-TopP</code></td>\n<td>TopP参数</td>\n<td>可选</td>\n<td><code>0.9</code></td>\n</tr>\n<tr>\n<td><code>ai-form-fill-llm-EnableStreaming</code></td>\n<td>启用流式响应</td>\n<td>可选</td>\n<td><code>true</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"其他可选参数\">其他可选参数</h4>\n<p>以下参数已有默认值，通常无需修改：</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>jwt-SecretKey</code></td>\n<td>JWT密钥</td>\n<td><code>ECBF8FA013844D77AE041A6800D7FF8F</code></td>\n</tr>\n<tr>\n<td><code>jwt-Issuer</code></td>\n<td>JWT颁发者</td>\n<td><code>codespirit.com</code></td>\n</tr>\n<tr>\n<td><code>jwt-Audience</code></td>\n<td>JWT受众</td>\n<td><code>CodeSpirit</code></td>\n</tr>\n<tr>\n<td><code>mysql-password</code></td>\n<td>MySQL密码</td>\n<td><code>Password123</code></td>\n</tr>\n<tr>\n<td><code>sqlserver-password</code></td>\n<td>SQL Server密码</td>\n<td><code>P@ssword123456</code></td>\n</tr>\n<tr>\n<td><code>rabbitmq-username</code></td>\n<td>RabbitMQ用户名</td>\n<td><code>admin</code></td>\n</tr>\n<tr>\n<td><code>rabbitmq-password</code></td>\n<td>RabbitMQ密码</td>\n<td><code>Password123</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"配置方法\">配置方法</h3>\n<h4 id=\"方法一使用-user-secrets推荐开发环境\">方法一：使用 User Secrets（推荐开发环境）</h4>\n<p>使用 .NET User Secrets 可以安全地存储敏感信息，无需担心提交到代码库：</p>\n<pre><code class=\"language-bash\"># 进入 AppHost 项目目录\ncd Src/CodeSpirit.AppHost\n\n# 初始化 User Secrets（如果尚未初始化）\ndotnet user-secrets init\n\n# 设置 LLM API 密钥\ndotnet user-secrets set \"llm-ApiKey\" \"your-llm-api-key-here\"\n\n# 设置 AI 表单填充 LLM API 密钥\ndotnet user-secrets set \"ai-form-fill-llm-ApiKey\" \"your-ai-form-fill-llm-api-key-here\"\n\n# 清除所有密钥\n# dotnet user-secrets clear\n</code></pre>\n<h4 id=\"方法二使用-appsettingsjson开发环境备选\">方法二：使用 appsettings.json（开发环境备选）</h4>\n<p>编辑 <code>Src/CodeSpirit.AppHost/appsettings.json</code> 文件，添加参数配置：</p>\n<pre><code class=\"language-json\">{\n  \"DatabaseType\": \"MySql\",\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Aspire.Hosting.Dcp\": \"Warning\"\n    }\n  },\n  \"llm-ApiKey\": \"your-llm-api-key-here\",\n  \"ai-form-fill-llm-ApiKey\": \"your-ai-form-fill-llm-api-key-here\"\n}\n</code></pre>\n<blockquote>\n<p><strong>⚠️ 重要提示</strong>:</p>\n<ul>\n<li>如果使用 <code>appsettings.json</code> 配置敏感信息，请确保该文件已添加到 <code>.gitignore</code> 中</li>\n<li>或者创建 <code>appsettings.Local.json</code> 文件（该文件默认已在 <code>.gitignore</code> 中），避免将 API 密钥提交到代码库</li>\n<li><strong>强烈推荐使用 User Secrets 方式</strong>，更安全且不会误提交</li>\n</ul>\n</blockquote>\n<h3 id=\"获取-api-密钥\">获取 API 密钥</h3>\n<h4 id=\"阿里云通义千问dashscope\">阿里云通义千问（DashScope）</h4>\n<p>开发阶段免费额度完全够用：</p>\n<ol>\n<li>访问 <a href=\"https://www.aliyun.com/benefit?userCode=nw99vwgt\" rel=\"noopener nofollow\" target=\"_blank\">阿里云 DashScope</a></li>\n<li>注册/登录账号</li>\n<li>创建 API Key</li>\n<li>将 API Key 配置到上述参数中</li>\n</ol>\n<blockquote>\n<p>💡 <strong>推荐阅读</strong>：<a href=\"./%E9%98%BF%E9%87%8C%E4%BA%91%E9%80%9A%E4%B9%89%E5%8D%83%E9%97%AE%E5%85%8D%E8%B4%B9%E4%BD%93%E9%AA%8C%E6%8C%87%E5%8D%97.md\" rel=\"noopener nofollow\" target=\"_blank\">阿里云通义千问免费体验指南</a> - 详细的注册指南、配置教程和成本分析，帮助您零成本体验 CodeSpirit 的强大 AI 能力！</p>\n</blockquote>\n<h4 id=\"openai如使用-openai-兼容接口\">OpenAI（如使用 OpenAI 兼容接口）</h4>\n<p>如果使用 OpenAI 兼容的 API 服务，需要修改以下参数：</p>\n<p>使用 User Secrets 配置：</p>\n<pre><code class=\"language-bash\">dotnet user-secrets set \"llm-ApiBaseUrl\" \"https://api.openai.com/v1\"\ndotnet user-secrets set \"llm-ModelName\" \"gpt-4\"\ndotnet user-secrets set \"llm-ApiKey\" \"your-openai-api-key-here\"\n</code></pre>\n<p>或使用 appsettings.json 配置：</p>\n<pre><code class=\"language-json\">{\n  \"llm-ApiBaseUrl\": \"https://api.openai.com/v1\",\n  \"llm-ModelName\": \"gpt-4\",\n  \"llm-ApiKey\": \"your-openai-api-key-here\"\n}\n</code></pre>\n<h3 id=\"验证参数配置\">验证参数配置</h3>\n<p>启动项目后，如果参数配置不正确，您会在控制台或 Aspire Dashboard 中看到相关错误信息。确保以下服务能够正常启动：</p>\n<ul>\n<li>✅ ConfigCenter（配置中心）- 需要 LLM 参数</li>\n<li>✅ Web 前端 - 需要 AI 表单填充 LLM 参数</li>\n</ul>\n<blockquote>\n<p><strong>提示</strong>: 如果暂时不需要使用 AI 功能，可以设置一个占位符值，但某些依赖 AI 的功能将无法正常工作。</p>\n</blockquote>\n<h2 id=\"开发工具配置\">开发工具配置</h2>\n<h3 id=\"visual-studio-code\">Visual Studio Code</h3>\n<p>创建 <code>.vscode/launch.json</code>：</p>\n<pre><code class=\"language-json\">{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Launch CodeSpirit\",\n      \"type\": \"coreclr\",\n      \"request\": \"launch\",\n      \"preLaunchTask\": \"build\",\n      \"program\": \"${workspaceFolder}/Src/CodeSpirit.AppHost/bin/Debug/net10.0/CodeSpirit.AppHost.dll\",\n      \"cwd\": \"${workspaceFolder}/Src/CodeSpirit.AppHost\",\n      \"env\": {\n        \"ASPNETCORE_ENVIRONMENT\": \"Development\"\n      }\n    }\n  ]\n}\n</code></pre>\n<p>创建 <code>.vscode/tasks.json</code>：</p>\n<pre><code class=\"language-json\">{\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"build\",\n      \"command\": \"dotnet\",\n      \"type\": \"process\",\n      \"args\": [\"build\", \"${workspaceFolder}/CodeSpirit.sln\"],\n      \"problemMatcher\": \"$msCompile\"\n    }\n  ]\n}\n</code></pre>\n<h2 id=\"验证安装-1\">验证安装</h2>\n<h3 id=\"1-检查服务状态\">1. 检查服务状态</h3>\n<p>访问Aspire Dashboard (<a href=\"http://localhost:17109\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:17109</a>) 确认所有服务正常运行：</p>\n<ul>\n<li>✅ CodeSpirit.Web (Web前端)</li>\n<li>✅ CodeSpirit.IdentityApi (身份认证)</li>\n<li>✅ CodeSpirit.ConfigCenter (配置中心)</li>\n<li>✅ CodeSpirit.MessagingApi (消息服务)</li>\n<li>✅ CodeSpirit.ExamApi (考试系统)</li>\n<li>✅ CodeSpirit.FileStorageApi (文件存储)</li>\n<li>✅ CodeSpirit.SurveyApi (问卷调查)</li>\n<li>✅ CodeSpirit.ApprovalApi (审批流程)</li>\n<li>✅ CodeSpirit.PathfinderApi (AI目标管理)</li>\n<li>✅ MySQL/SQL Server (数据库，根据配置)</li>\n<li>✅ Redis (缓存)</li>\n<li>✅ RabbitMQ (消息队列)</li>\n<li>✅ GreptimeDB (时序数据库)</li>\n<li>✅ Seq (日志服务)</li>\n</ul>\n<h3 id=\"2-检查错误\">2. 检查错误</h3>\n<p>打开结构化日志面板，检查是否存在错误：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132237841-409615542.png\" /></p>\n<h3 id=\"3-访问web界面\">3. 访问Web界面</h3>\n<p>系统平台：<a href=\"https://localhost:7120\" rel=\"noopener nofollow\" target=\"_blank\">https://localhost:7120</a></p>\n<p>账号：systemadmin</p>\n<p>密码：CodeSpirit@2025</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132247398-182230200.png\" /></p>\n<p>登录后可以看到系统平台后台管理UI：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132258347-1684698426.png\" /></p>\n<p>租户平台（默认租户）：<a href=\"https://localhost:7120/default/login\" rel=\"noopener nofollow\" target=\"_blank\">https://localhost:7120/default/login</a></p>\n<p>账号：admin</p>\n<p>密码：123@Admin</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132312276-873776487.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132320900-136012642.png\" /></p>\n<h2 id=\"常见问题\">常见问题</h2>\n<h3 id=\"无法打开网页\">无法打开网页</h3>\n<p>一般是以下情况导致：</p>\n<ol>\n<li>\n<p>镜像无法拉取，一般在docker面板或Aspire管理面板的日志中可以看到。建议配置镜像源或路由上网。</p>\n</li>\n<li>\n<p>关键服务故障，比如Web服务出现故障。</p>\n</li>\n<li>\n<p>端口冲突或网络错误，具体可以看启动控制台错误：</p>\n</li>\n</ol>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251224132339285-1584044125.png\" /></p>\n<h3 id=\"端口冲突\">端口冲突</h3>\n<p>如果遇到端口冲突，修改 <code>Src/CodeSpirit.AppHost/Program.cs</code> 中的端口配置。</p>\n<h3 id=\"docker服务启动失败\">Docker服务启动失败</h3>\n<p>由于项目使用.NET Aspire管理服务，如果遇到服务启动问题：</p>\n<pre><code class=\"language-bash\"># 重启Aspire应用\ncd Src/CodeSpirit.AppHost\ndotnet run --force\n\n# 查看Aspire Dashboard中的服务状态\n# 访问 http://localhost:17109\n</code></pre>\n<h3 id=\"greptimedb启动失败\">GreptimeDB启动失败</h3>\n<pre><code class=\"language-bash\"># 在Aspire Dashboard中查看GreptimeDB状态\n# 如果内存不足，可以在Program.cs中调整GreptimeDB配置\n\n# 检查系统资源使用情况\n# GreptimeDB需要至少512MB内存\n</code></pre>\n<h3 id=\"ssl证书问题\">SSL证书问题</h3>\n<pre><code class=\"language-bash\"># 信任开发证书\ndotnet dev-certs https --trust\n</code></pre>\n<h3 id=\"数据库连接问题\">数据库连接问题</h3>\n<pre><code class=\"language-bash\"># 检查数据库容器状态（根据配置的数据库类型）\ndocker ps | grep mysql    # MySQL\ndocker ps | grep sqlserver # SQL Server\n\n# 重启数据库容器\ndocker restart mysql      # MySQL\ndocker restart sqlserver  # SQL Server\n\n# 或在Aspire Dashboard中查看数据库状态和连接信息\n</code></pre>\n<h3 id=\"内存不足问题\">内存不足问题</h3>\n<p>如果系统内存不足，可以：</p>\n<ol>\n<li>关闭不必要的应用程序</li>\n<li>调整GreptimeDB内存设置（在Program.cs中）</li>\n<li>考虑升级系统内存到推荐配置（16GB推荐，32GB更佳）</li>\n</ol>\n<h3 id=\"llm-api-密钥未配置\">LLM API 密钥未配置</h3>\n<p>如果启动时遇到以下错误或服务无法正常启动：</p>\n<ul>\n<li>ConfigCenter 服务启动失败</li>\n<li>Web 前端无法访问 AI 功能</li>\n<li>控制台提示缺少 LLM 配置参数</li>\n</ul>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li>\n<p><strong>检查参数是否已配置</strong>：</p>\n<pre><code class=\"language-bash\"># 查看 User Secrets（如果使用）\ncd Src/CodeSpirit.AppHost\ndotnet user-secrets list\n</code></pre>\n</li>\n<li>\n<p><strong>配置缺失的参数</strong>：</p>\n<ul>\n<li>参考 <a href=\"#%E5%BF%85%E5%A1%AB%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE\" rel=\"noopener nofollow\">必填参数配置</a> 章节</li>\n<li>确保至少配置了 <code>llm-ApiKey</code> 和 <code>ai-form-fill-llm-ApiKey</code> 两个必填参数</li>\n</ul>\n</li>\n<li>\n<p><strong>验证配置</strong>：</p>\n<ul>\n<li>重启应用后，检查 Aspire Dashboard 中的服务状态</li>\n<li>查看服务日志确认参数是否正确加载</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>提示</strong>: 如果暂时不需要使用 AI 功能，可以设置占位符值（如 <code>placeholder-key</code>），但相关 AI 功能将无法正常工作。</p>\n</blockquote>\n<h2 id=\"开发模式\">开发模式</h2>\n<h3 id=\"热重载开发\">热重载开发</h3>\n<pre><code class=\"language-bash\"># 启用热重载\ncd Src/CodeSpirit.AppHost\ndotnet watch run\n</code></pre>\n<h3 id=\"调试模式\">调试模式</h3>\n<p>在Visual Studio或VS Code中设置断点，按F5启动调试。</p>\n<h2 id=\"生产环境部署\">生产环境部署</h2>\n<h3 id=\"使用kubernetes部署\">使用Kubernetes部署</h3>\n<p>项目提供了完整的Kubernetes部署文件：</p>\n<pre><code class=\"language-bash\"># 部署到Kubernetes集群\nkubectl apply -f k8s/\n\n# 查看部署状态\nkubectl get pods -n code-spirit-release\n</code></pre>\n<h3 id=\"使用docker部署\">使用Docker部署</h3>\n<pre><code class=\"language-bash\"># 构建所有服务的Docker镜像\ndotnet publish CodeSpirit.sln -c Release\n\n# 使用项目提供的Dockerfile构建镜像\ndocker build -f Src/CodeSpirit.Web/Dockerfile -t codespirit-web:latest .\ndocker build -f Src/CodeSpirit.IdentityApi/Dockerfile -t codespirit-identity:latest .\n</code></pre>\n<h3 id=\"配置管理\">配置管理</h3>\n<p>生产环境配置通过以下方式管理：</p>\n<ul>\n<li><strong>Kubernetes ConfigMap</strong>: 存储应用配置</li>\n<li><strong>Kubernetes Secret</strong>: 存储敏感信息</li>\n<li><strong>配置中心</strong>: 动态配置管理</li>\n</ul>\n<h2 id=\"下一步\">下一步</h2>\n<p>环境搭建完成后，您可以：</p>\n<ol>\n<li>📖 阅读 <a href=\"./%E9%A1%B9%E7%9B%AE%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.md\" rel=\"noopener nofollow\" target=\"_blank\">项目整体架构设计</a></li>\n<li>🔧 了解 <a href=\"./CodeSpirit.Core%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6.md\" rel=\"noopener nofollow\" target=\"_blank\">CodeSpirit.Core核心框架</a></li>\n<li>📋 查看 <a href=\"./%E6%80%BB%E4%BD%93%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E8%AF%B4%E6%98%8E.md\" rel=\"noopener nofollow\" target=\"_blank\">总体技术体系说明</a></li>\n<li>🔐 学习 <a href=\"./CodeSpirit%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E5%8D%97.md\" rel=\"noopener nofollow\" target=\"_blank\">统一异常处理指南</a></li>\n<li>💻 参考 <a href=\"./CRUD%E5%BC%80%E5%8F%91%E7%A4%BA%E4%BE%8B.md\" rel=\"noopener nofollow\" target=\"_blank\">CRUD开发示例</a> 开始开发</li>\n</ol>\n<h2 id=\"获取帮助\">获取帮助</h2>\n<p>如果遇到问题，请参考：</p>\n<ul>\n<li><a href=\"https://github.com/your-org/code-spirit/issues\" rel=\"noopener nofollow\" target=\"_blank\">GitHub Issues</a></li>\n<li><a href=\"https://github.com/your-org/code-spirit/wiki\" rel=\"noopener nofollow\" target=\"_blank\">项目Wiki</a></li>\n<li><a href=\"https://github.com/your-org/code-spirit/discussions\" rel=\"noopener nofollow\" target=\"_blank\">讨论区</a></li>\n</ul>\n<p>祝您开发愉快！🚀</p>\n\n</div>\n<div id=\"MySignature\">\n    作者：<a href=\"http://www.cnblogs.com/codelove/\" target=\"_blank\">雪雁</a><br />出处：<a href=\"http://www.cnblogs.com/codelove/\" target=\"_blank\">http://www.cnblogs.com/codelove/</a>\n<br />如果喜欢作者的文章，请关注【CodeSpirit-码灵】公众号以便第一时间获得最新内容。本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。<br /><b>静听鸟语花香，漫赏云卷云舒。</b>\n<br />\n<img height=\"100\" src=\"https://images.cnblogs.com/cnblogs_com/codelove/315887/o_251224070213_%E5%85%AC%E4%BC%97%E5%8F%B7.jpg\" width=\"100\" />\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 15:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/codelove\">雪雁</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "新版MOS（My Oracle Support）主要变化",
      "link": "https://www.cnblogs.com/jyzhao/p/19415968/xin-banmosmy-oracle-support-zhu-yao-bian-hua",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jyzhao/p/19415968/xin-banmosmy-oracle-support-zhu-yao-bian-hua\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 15:01\">\n    <span>新版MOS（My Oracle Support）主要变化</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2025-12-29 15:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jyzhao\">AlfredZhao</a>&nbsp;\n阅读(<span id=\"post_view_count\">24</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>本月 My Oracle Support 做了全面的升级。Oracle 硬件、软件及托管云服务的支持也全部迁移至全新的支持平台。所有 SR 的创建、更新与管理操作也都将在这一新平台上完成，原来的系统将不再使用。</p>\n<p>关于新版MOS，很多早已熟悉多年老版本MOS的从业者有些担心，实际上，新版并没有增加任何使用难度，反而是极大地降低了MOS使用门槛。</p>\n<p>但还是有一些优化项可能会让老用户在刚开始接触新版的时候有些陌生，这里列出来让大家提前注意下，做到心中有数：</p>\n<h2 id=\"01--mos知识库中的文章号命名风格改变\">01 | MOS知识库中的文章号命名风格改变</h2>\n<p>新版是<code>KB+一组数字</code>；旧版是<code>数字.数字</code>格式。</p>\n<p>但是笔者亲测对于有些比较常用的文档是可以通过旧版搜索到的，但还是建议熟悉新版的命名风格。</p>\n<p>比如熟悉Exadata的小伙伴都耳熟能详的一篇文档号：<code>888828.1</code></p>\n<p>在新版搜索也能检索到，新版给它的编号就是 <code>KB153930</code></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202512/635610-20251229150101685-1968954989.jpg\" /></p>\n<p>打开后，也可以看到里面会说明就是对应之前的 888828.1：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202512/635610-20251229150101698-2096446677.jpg\" /></p>\n<h2 id=\"02--mos下载补丁入口更加便利\">02 | MOS下载补丁入口更加便利</h2>\n<p>之前系统下载补丁介质时，很多新手甚至都找不到合适的入口。现在新版变得非常简单，在主页面这里的搜索框直接选择补丁这个分类。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202512/635610-20251229150101696-686065035.jpg\" /></p>\n<p>就会弹出窗口，可以按需输入所需补丁信息，Apply即可看到对应的入口：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202512/635610-20251229150101584-539479973.jpg\" /></p>\n<h2 id=\"03--sr前缀数字改变为4-开头\">03 | SR前缀数字改变为4-开头</h2>\n<p>之前的SR号码都是<code>3-</code>开头加一段数字，现在是<code>4-</code>开头加一段数字，因为笔者的账号没有创建任何SR，所以看不到这个变化。有能看SR权限的小伙伴可以帮忙确认下，欢迎留言。</p>\n<h2 id=\"04--修改账户信息时需注意安全pin\">04 | 修改账户信息时需注意安全PIN</h2>\n<p>在 账户 -&gt; 首选项下面，填写账号信息时，有一个 <code>安全PIN</code> 据说在SR电话沟通过程中，后台会要求你提供这个码才可以。这是一个加强安全性的考虑。笔者没有这个需求，有这个需求的小伙伴也可以帮忙确认下事实是否如此。</p>\n<p>另外，原厂工程师为此专门录制过一段详细的中文介绍视频，感兴趣的同学可以直接登录新版MOS，搜索 <code>KB822414</code> 看到这篇中文的文章及视频。</p>\n<p>因为这是一篇中文的文档，如果默认查不到，注意搜索语言切换成中文即可。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/635610/202512/635610-20251229150101687-372899130.jpg\" /></p>\n\n</div>\n<div id=\"MySignature\">\n    <a href=\"https://www.cnblogs.com/jyzhao/\" target=\"_blank\">AlfredZhao</a>©版权所有「从Oracle起航，领略精彩的IT技术。」<br />\n转载请注明原文链接：<a href=\"https://www.cnblogs.com/jyzhao/p/19415968/xin-banmosmy-oracle-support-zhu-yao-bian-hua\" target=\"_blank\">https://www.cnblogs.com/jyzhao/p/19415968/xin-banmosmy-oracle-support-zhu-yao-bian-hua</a>\n<hr />\n<div style=\"text-align: center; margin-top: 30px;\">\n  <p style=\"font-size: 14px; color: #555;\">\n    👋 感谢阅读，欢迎关注我的公众号 <b>「赵靖宇」</b>\n  </p>\n  <img src=\"https://images.cnblogs.com/cnblogs_com/jyzhao/824234/o_250208075013_qrcode-zjy.jpg\" style=\"border: 1px solid #ddd; border-radius: 8px;\" width=\"160\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "当我试图搞清楚 FFmpeg 的硬件加速时，我写了一个能自动检测所有 GPU 编码器的小工具",
      "link": "https://www.cnblogs.com/hyb1/p/19415077",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hyb1/p/19415077\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 12:04\">\n    <span>当我试图搞清楚 FFmpeg 的硬件加速时，我写了一个能自动检测所有 GPU 编码器的小工具</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        ffmpeg 硬件加速 GPU编码 视频编解码 NVEnc NVDec Intel QSV AMD AMF VAAPI Vulkan 视频编码 VideoToolbox Media Foundation DXVA2 D3D11VA D3D12VA\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">在过去的几年里，本人陆陆续续接触了不少视频处理相关的项目。每当涉及到FFmpeg的硬件加速部分，本人都会陷入一种“信息过载”的状态：文档很多、接口很多、驱动差异巨大，甚至同一台机器在不同系统下的表现都不一样。</span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">如果您也曾经尝试过让FFmpeg调用GPU编码/解码器，大概率会遇到类似的情况：</span></p>\n<ul style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">明明显卡支持 H.265，却始终无法正常编码</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">NVEnc、QSV、AMF、VAAPI……到底哪个能用？</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">为什么 1080p 可以，4K 却失败</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">Windows 和 Linux 的硬件加速接口完全不是一套逻辑</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">FFmpeg 的“支持列表”并不能代表你的设备真的支持</span></p>\n</li>\n</ul>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">这些问题看似简单，但真正排查起来非常耗时间啊啊啊。 于是本人干脆写了一个工具，让它自动帮我把所有硬件编码器和解码器都测一遍。</span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">这个工具就是： <span style=\"font-size: 16px;\"><strong style=\"white-space: normal;\">HwCodecDetect</strong> </span></span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap; font-size: 15px;\">GitHub 地址： <a href=\"https://github.com/whyb/HwCodecDetect\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"white-space: normal;\">https://github.com/whyb/HwCodecDetect</span></a></span></p>\n<h1 style=\"white-space: normal;\">FFmpeg 的硬件加速生态：复杂，但真实</h1>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">如果只用 CPU 编码，FFmpeg 的体验非常统一；但一旦涉及 GPU，情况就完全不同了。</span></p>\n<h2 style=\"white-space: normal;\">多厂商、多接口、多历史包袱</h2>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">不同厂商有不同的硬件加速接口：</span></p>\n<ul style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">NVIDIA</strong>：NVEnc / NVDec</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">Intel</strong>：QSV</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">AMD</strong>：AMF</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">Apple</strong>：VideoToolbox</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">Linux</strong>：VAAPI / Vulkan</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">Windows</strong>：Media Foundation / DXVA2 / D3D11VA / D3D12VA</span></p>\n</li>\n</ul>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">这些接口之间没有统一标准，甚至同一厂商在不同系统上的表现也不一致。</span></p>\n<h2 style=\"white-space: normal;\">“支持”不等于“可用”</h2>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">FFmpeg 文档里写着“支持某某编码器”，但实际情况可能是：</span></p>\n<ul style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">驱动版本不够</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">显卡架构不支持某个分辨率</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">系统缺少依赖</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">FFmpeg 编译参数不完整</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">某些接口只支持解码，不支持编码</span></p>\n</li>\n</ul>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">你不测试，根本不知道你的机器到底能不能用。</span></p>\n<h1 style=\"white-space: normal;\">HwCodecDetect：把所有硬件编码器都跑一遍，结果一目了然</h1>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">这个工具的核心目标非常直接：</span></p>\n<blockquote style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><strong style=\"white-space: pre-wrap;\">自动检测当前系统上所有可用的硬件编码器/解码器，并测试它们能处理的最大分辨率。</strong></span></p>\n</blockquote>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">它的工作方式是：</span></p>\n<ol start=\"1\" style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">自动生成不同分辨率的测试视频（从 240p 到 8K）</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">使用 FFmpeg 调用各种硬件编码器</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">记录成功与失败</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">输出一份清晰的检测报告</span></p>\n</li>\n</ol>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">支持的编码器包括：</span></p>\n<ul style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">NVEnc / NVDec</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">QSV</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">AMF</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">VAAPI</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">Vulkan</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">Media Foundation</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">DXVA2 / D3D11VA / D3D12VA</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">Apple VideoToolbox</span></p>\n</li>\n</ul>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">基本覆盖了目前所有主流 GPU 加速接口。</span></p>\n<h1 style=\"white-space: normal;\">为什么我需要这样一个工具？</h1>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">本人写这个工具的原因其实很简单：</span></p>\n<h3 style=\"white-space: normal;\">1. 本人不想再猜显卡到底能不能用</h3>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">不同显卡、不同驱动、不同系统，组合起来就是一堆未知数。</span></p>\n<h3 style=\"white-space: normal;\">2. 本人不想再查文档</h3>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">文档写得再详细，也不如直接跑一遍来得准确。</span></p>\n<h3 style=\"white-space: normal;\">3. 本人不想再被驱动坑</h3>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">驱动更新后编码能力变化是常见情况，自动检测能避免踩坑。</span></p>\n<h3 style=\"white-space: normal;\">4. 本人希望它能成为“视频处理工程师的体检工具”</h3>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">跑一次，你就知道你的机器到底能干什么。</span></p>\n<h1 style=\"white-space: normal;\">如何使用（非常简单）</h1>\n<h2 style=\"white-space: normal;\">方式一：pip 安装（推荐）</h2>\n<div class=\"cnblogs_code\">\n<pre>pip <span style=\"color: rgba(0, 0, 255, 1);\">install</span><span style=\"color: rgba(0, 0, 0, 1);\"> hwcodecdetect\nhwcodecdetect</span></pre>\n</div>\n<h2 style=\"white-space: normal;\">方式二：下载可执行文件（无需 Python）</h2>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">Releases 页面： <a href=\"https://github.com/whyb/HwCodecDetect/releases\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"white-space: pre-wrap;\">https://github.com/whyb/HwCodecDetect/releases</span></a></span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">下载对应系统的可执行文件即可运行。</span></p>\n<h2 style=\"white-space: normal;\">方式三：从源码安装</h2>\n<div style=\"white-space: normal;\">\n<div class=\"rounded-b-xl bg-background-static-850 px-4 pb-1.5 dark:bg-background-static-900\">\n<div style=\"white-space: pre;\">\n<div class=\"cnblogs_code\">\n<pre>git clone https:<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">github.com/whyb/HwCodecDetect.git</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">cd HwCodecDetect\npip </span><span style=\"color: rgba(0, 0, 255, 1);\">install</span><span style=\"color: rgba(0, 0, 0, 1);\"> .\nhwcodecdetect</span></pre>\n</div>\n</div>\n</div>\n</div>\n<h1 style=\"white-space: normal;\">检测结果长什么样？</h1>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">工具会输出一份类似“硬件能力体检报告”的结果，包含：</span></p>\n<ul style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">哪些编码器可用</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">哪些解码器可用</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">每个编码器支持的分辨率</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">哪些接口失败了</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">哪些格式被显卡硬件支持</span></p>\n</li>\n</ul>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">对于需要做视频转码、媒体服务器、AI 视频处理、云渲染的开发者来说，这份报告非常有价值。</span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">效果演示：</span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\"><img alt=\"hwcodecdetect\" src=\"https://img2024.cnblogs.com/blog/511612/202512/511612-20251229115741599-1997577731.gif\" /></span></p>\n<p style=\"white-space: normal;\">&nbsp;</p>\n<h1 style=\"white-space: normal;\">这个项目适合哪些人？</h1>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">如果您正在做：</span></p>\n<ul style=\"white-space: normal;\">\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">视频转码服务</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">FFmpeg 自动化脚本</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">媒体服务器（Jellyfin / Emby / Plex）</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">GPU 加速推理前处理</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">视频编码性能测试</span></p>\n</li>\n<li style=\"white-space: normal;\">\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">多平台视频工具开发</span></p>\n</li>\n</ul>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">那么这个工具能帮你节省大量时间。</span></p>\n<h1 style=\"white-space: normal;\">最后</h1>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">如果你觉得这个工具对你有帮助，欢迎来 <strong>GitHub</strong> 点个 Star 啊啊啊，也欢迎分享给您的同事或朋友。</span></p>\n<p style=\"white-space: normal;\"><span style=\"font-size: 18px;\"><a href=\"https://github.com/whyb/HwCodecDetect\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"white-space: pre-wrap;\"><span style=\"white-space: pre-wrap;\">https://github.com/whyb/HwCodecDetect</span></span></a></span></p>\n<p style=\"white-space: normal;\"><span style=\"white-space: pre-wrap;\">如果您在使用过程中遇到任何问题，也欢迎在 issue 里交流，我会持续维护和改进。</span></p>\n<p style=\"white-space: normal;\">&nbsp;</p>\n<p style=\"white-space: normal;\">&nbsp;</p>\n<p style=\"white-space: normal;\">&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 12:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hyb1\">重庆Debug</a>&nbsp;\n阅读(<span id=\"post_view_count\">137</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Spring AOP + Guava RateLimiter：我是如何用注解实现优雅限流的？",
      "link": "https://www.cnblogs.com/xzqcsj/p/19413883",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xzqcsj/p/19413883\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 10:01\">\n    <span>Spring AOP + Guava RateLimiter：我是如何用注解实现优雅限流的？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Spring AOP + Guava RateLimiter：我是如何用注解实现优雅限流的？\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3703499/202512/3703499-20251229100044133-1497412414.png\" />\n        总的来说，AOP 让限流这类“基础设施”悄无声息地融入了业务脉络，这正是优雅架构的魅力所在——将复杂性收敛于一点，在别处换来 simplicity。\n最后，想起一句被反复“魔改”的名言，放在这里格外贴切：“让架构的归架构，让业务的归业务”。\n愿各位的代码世界，秩序井然，bug 退散。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p><strong>写在前面</strong></p>\n<p>提起 AOP（面向切面编程），大家的第一反应往往是：“哦，那个用来打印日志、管理事务、或者做权限校验的。”</p>\n<p>其实，AOP 的能力远不止于此。在面对高并发场景下的接口自我保护时，它同样能发挥奇效。</p>\n</blockquote>\n<p>最近在项目中遇到了一个真实场景：这是一个<strong>基于 MQ 触发的定时跑批任务</strong>。平日里风平浪静，可是一旦大促或者数据量激增，MQ 里的积压消息就会瞬间推送给消费者。</p>\n<p>虽然消费者服务虽然处理得过来，但底层的<strong>核心业务数据库却扛不住了</strong>——大量并发查询瞬间打满 CPU，CPU 使用率飙升至 100%，直接影响了线上实时业务的稳定性。</p>\n<p>考虑到该服务是单节点部署，引入 Redis 做分布式限流显得“杀鸡用牛刀”，也增加了额外的运维成本。最终，我决定使用 <strong>Spring AOP + Guava RateLimiter + 自定义注解</strong>，实现一个 <strong>无侵入、可配置、轻量级</strong> 的<strong>单机限流组件</strong>。<br />\n<img alt=\"00b24eabdf10d905d94bf57cd9cc5b31\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"一-为什么选择-aop--注解\">一、 为什么选择 AOP + 注解？</h2>\n<p>在介绍代码之前，先明确设计初衷。</p>\n<p>以前我刚接触开发时，也喜欢在 Service 或 Controller 层直接硬编码限流逻辑，例如：</p>\n<pre><code class=\"language-java\">// ❌ 反例：硬编码，逻辑混杂且难以复用\nif (!rateLimiter.tryAcquire()) {\n    throw new RuntimeException(\"系统繁忙\");\n}\ndoBusiness();\n</code></pre>\n<p>这种写法的弊端很明显：</p>\n<ol>\n<li><strong>逻辑混杂</strong>：清晰的业务代码中夹杂着非业务的限流判断。</li>\n<li><strong>复用性差</strong>：如果有十个接口需要限流，就需要重复编写十次。</li>\n<li><strong>维护困难</strong>：一旦需要调整限流策略（例如升级为分布式限流），涉及的修改点将非常多。</li>\n</ol>\n<p><strong>AOP（面向切面编程）</strong> 的核心就是 <strong>“解耦”</strong> 和 <strong>“复用”</strong>。</p>\n<p>我将限流逻辑封装为一个独立的“切面”，配合自定义注解作为“开关”。<strong>只需在目标方法上添加一个注解，限流策略随即生效</strong>。后续的维护与升级，也仅需聚焦于切面逻辑本身，无需触碰任何业务代码。</p>\n<hr />\n<h2 id=\"二-guava-ratelimiter-核心原理\">二、 Guava RateLimiter 核心原理</h2>\n<p>我这次选用的核心库是 Google Guava 的 <code>RateLimiter</code>。它是基于 <strong>令牌桶算法（Token Bucket）</strong> 实现的。</p>\n<h3 id=\"1-简单回顾令牌桶\">1. 简单回顾令牌桶</h3>\n<p>它的机制不像“漏桶”那样死板（恒定速率流出），而是更加人性化：</p>\n<ul>\n<li><strong>生产令牌</strong>：系统以固定速率向桶中放入令牌。</li>\n<li><strong>消费令牌</strong>：请求过来时，必须先拿到令牌才能执行。</li>\n<li><strong>关键特性</strong>：<strong>支持突发流量</strong>。如果一段时间没有请求，桶里的令牌会积攒起来（直到达到桶上限）。当一波突发流量到来时，可以直接消耗积攒的令牌立刻执行，而不需要排队等待。</li>\n</ul>\n<h3 id=\"2-两种核心模式\">2. 两种核心模式</h3>\n<p>Guava 贴心地提供了两种实现：</p>\n<ol>\n<li><strong>SmoothBursty（平滑突发）</strong>：<strong>默认模式</strong>。适合大多数场景，允许短时间的流量突发。</li>\n<li><strong>SmoothWarmingUp（平滑预热）</strong>：<strong>预热模式</strong>。启动初期令牌发放速率较慢，随着时间推移逐步提升到目标 QPS。这对于需要“热身”的资源（如数据库连接池、缓存填充）非常友好，防止冷启动时瞬间被打挂。</li>\n</ol>\n<h3 id=\"3-单机版警告-️\">3. 单机版警告 ⚠️</h3>\n<p><strong>注意</strong>：<code>Guava RateLimiter</code> 是 <strong>单机限流</strong> 工具！令牌是存在当前 JVM 内存里的。</p>\n<ul>\n<li>如果你的服务只部署一台机器，它完美胜任。</li>\n<li>如果你部署了 10 台机器，每台设置 QPS=5，那么整个集群的总 QPS 上限是 50。</li>\n</ul>\n<h3 id=\"4-常用-api-详解\">4. 常用 API 详解</h3>\n<p>熟练掌握 API 是实战的基础，以下是 <code>RateLimiter</code> 的核心方法：</p>\n<p><strong>核心创建方法</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">方法签名</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>create(double permitsPerSecond)</code></td>\n<td style=\"text-align: left;\">创建 <strong>SmoothBursty</strong> 限流器，指定每秒生成的令牌数（默认：permitsPerSecond = QPS = 桶容量）。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>create(double permitsPerSecond, long warmupPeriod, TimeUnit unit)</code></td>\n<td style=\"text-align: left;\">创建 <strong>SmoothWarmingUp</strong> 限流器，指定 QPS + 预热时间。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>核心获取方法</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">方法签名</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>double acquire()</code></td>\n<td style=\"text-align: left;\"><strong>阻塞式</strong>获取 1 个令牌。若无令牌，线程会<strong>一直等待</strong>，直到获取成功。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>double acquire(int permits)</code></td>\n<td style=\"text-align: left;\"><strong>阻塞式</strong>获取指定数量的令牌（可一次获取多个）。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>boolean tryAcquire()</code></td>\n<td style=\"text-align: left;\"><strong>非阻塞式</strong>获取 1 个令牌。立即返回：成功 <code>true</code>，失败 <code>false</code>（不等待）。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>boolean tryAcquire(long timeout, TimeUnit unit)</code></td>\n<td style=\"text-align: left;\"><strong>限时等待</strong>获取 1 个令牌。在超时时间内拿到返回 <code>true</code>，否则返回 <code>false</code>。这是最推荐的用法，既避免了线程死等，又提供了一定的缓冲。</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"三-代码实战打造企业级限流组件\">三、 代码实战：打造企业级限流组件</h2>\n<p>接下来，我来实现一个功能完备的 <code>@RateLimit</code> 组件，支持<strong>QPS配置、阻塞/非阻塞模式、超时控制以及预热模式</strong>。</p>\n<h3 id=\"1-引入依赖\">1. 引入依赖</h3>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n    &lt;artifactId&gt;guava&lt;/artifactId&gt;\n    &lt;version&gt;32.1.3-jre&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"2-定义注解-ratelimit\">2. 定义注解 <code>@RateLimit</code></h3>\n<p>这个注解承载了限流的所有配置元数据。</p>\n<pre><code class=\"language-java\">import java.lang.annotation.*;\nimport java.util.concurrent.TimeUnit;\n\n@Target({ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RateLimit {\n\n    /**\n     * 限流阈值 (QPS)，默认每秒 5 个\n     */\n    double qps() default 5.0;\n\n    /**\n     * 获取令牌的策略\n     * true: 阻塞模式（直到拿到令牌或超时）\n     * false: 非阻塞模式（拿不到立即失败）\n     */\n    boolean block() default true;\n\n    /**\n     * 阻塞等待的超时时间（仅当 block=true 时生效）\n     * 默认 0，表示无限等待\n     */\n    long timeout() default 0;\n\n    /**\n     * 超时时间单位\n     */\n    TimeUnit timeUnit() default TimeUnit.MILLISECONDS;\n\n    /**\n     * 预热时间\n     * 默认 0 (SmoothBursty)；设置 &gt;0 则开启预热模式 (SmoothWarmingUp)\n     */\n    long warmupPeriod() default 0;\n\n    /**\n     * 预热时间单位\n     */\n    TimeUnit warmupUnit() default TimeUnit.SECONDS;\n\n    /**\n     * 限流提示信息\n     */\n    String message() default \"系统繁忙，请稍后再试\";\n}\n</code></pre>\n<h3 id=\"3-定义全局异常-ratelimitexception\">3. 定义全局异常 <code>RateLimitException</code></h3>\n<pre><code class=\"language-java\">public class RateLimitException extends RuntimeException {\n    public RateLimitException(String message) {\n        super(message);\n    }\n}\n</code></pre>\n<h3 id=\"4-实现切面-ratelimitaop\">4. 实现切面 <code>RateLimitAop</code></h3>\n<p>这是限流组件的“大脑”。需要重点关注实例缓存、线程安全以及不同策略的执行逻辑。</p>\n<pre><code class=\"language-java\">import com.google.common.util.concurrent.RateLimiter;\nimport lombok.extern.slf4j.Slf4j;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Method;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Slf4j\n@Aspect\n@Component\npublic class RateLimitAop {\n    \n    // 使用 ConcurrentHashMap 缓存 RateLimiter 实例，确保线程安全\n    // Key: 方法签名 (类名.方法名(参数类型)), Value: 限流器实例\n    private final Map&lt;String, RateLimiter&gt; rateLimiterCache = new ConcurrentHashMap&lt;&gt;();\n\n    @Pointcut(\"@annotation(com.example.annotation.RateLimit)\")\n    public void rateLimitPointcut() {}\n\n    @Around(\"rateLimitPointcut()\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        RateLimit annotation = method.getAnnotation(RateLimit.class);\n\n        // 1. 构建方法唯一 Key，防止方法重载冲突\n        String methodKey = buildMethodKey(method);\n        \n        // 2. 线程安全地创建或获取限流器\n        RateLimiter rateLimiter = rateLimiterCache.computeIfAbsent(methodKey, key -&gt; createRateLimiter(annotation));\n\n        // 3. 执行获取令牌逻辑\n        boolean acquireSuccess;\n        if (annotation.block()) {\n            // --- 阻塞模式 ---\n            if (annotation.timeout() &lt;= 0) {\n                // 无限等待，直到成功\n                rateLimiter.acquire();\n                acquireSuccess = true;\n            } else {\n                // 限时等待\n                acquireSuccess = rateLimiter.tryAcquire(annotation.timeout(), annotation.timeUnit());\n            }\n        } else {\n            // --- 非阻塞模式 ---\n            // 立即尝试，失败即返回\n            acquireSuccess = rateLimiter.tryAcquire();\n        }\n\n        // 4. 限流拦截\n        if (!acquireSuccess) {\n            log.warn(\"【限流报警】方法 {} 请求频率过高，已拒绝。\", methodKey);\n            throw new RateLimitException(annotation.message());\n        }\n\n        // 5. 放行\n        return joinPoint.proceed();\n    }\n\n    /**\n     * 生成方法签名：Package.Class.Method(ParamType1,ParamType2)\n     */\n    private String buildMethodKey(Method method) {\n        StringBuilder keyBuilder = new StringBuilder();\n        keyBuilder.append(method.getDeclaringClass().getName())\n                .append(\".\").append(method.getName()).append(\"(\");\n        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();\n        for (int i = 0; i &lt; parameterTypes.length; i++) {\n            keyBuilder.append(parameterTypes[i].getSimpleName());\n            if (i &lt; parameterTypes.length - 1) {\n                keyBuilder.append(\",\");\n            }\n        }\n        keyBuilder.append(\")\");\n        return keyBuilder.toString();\n    }\n\n    /**\n     * 工厂方法：根据配置创建具体的 RateLimiter\n     */\n    private RateLimiter createRateLimiter(RateLimit annotation) {\n        if (annotation.warmupPeriod() &gt; 0) {\n            log.info(\"创建预热限流器: QPS={}, Warmup={}s\", annotation.qps(), annotation.warmupPeriod());\n            return RateLimiter.create(annotation.qps(), annotation.warmupPeriod(), annotation.warmupUnit());\n        } else {\n            log.info(\"创建标准限流器: QPS={}\", annotation.qps());\n            return RateLimiter.create(annotation.qps());\n        }\n    }\n}\n</code></pre>\n<h3 id=\"5-业务接入示例\">5. 业务接入示例</h3>\n<pre><code class=\"language-java\">@Service\npublic class DataSyncService {\n\n    // 场景1：核心数据同步，允许排队等待500ms，保证尽可能执行\n    @RateLimit(qps = 10.0, block = true, timeout = 500)\n    public void syncImportantData(List&lt;Data&gt; dataList) {\n        // ... 业务逻辑 ...\n    }\n\n    // 场景2：非核心接口，流量大时直接丢弃，保护系统\n    @RateLimit(qps = 50.0, block = false, message = \"当前访问人数过多\")\n    public void refreshCache() {\n        // ... 刷新逻辑 ...\n    }\n}\n</code></pre>\n<hr />\n<h2 id=\"四-进阶聊聊动态代理那个大家都知道的坑\">四、 进阶：聊聊动态代理那个“大家都知道”的坑</h2>\n<p>在使用 AOP 时，有一个经典面试题级别的现象：<strong>类内方法自调用导致 AOP 失效</strong>。作为开发者，我们不止要知其然，更知其所以然。</p>\n<h3 id=\"场景重现\">场景重现</h3>\n<pre><code class=\"language-java\">@Service\npublic class TradeService {\n    public void process() {\n        // ... 前置处理 ...\n        pay(); // ❌ 重点在这里：直接调用内部方法\n    }\n\n    @RateLimit(qps = 5.0) \n    public void pay() { ... }\n}\n</code></pre>\n<h3 id=\"为什么会失效\">为什么会失效？</h3>\n<p>Spring AOP 的底层使用的是 <strong>动态代理</strong>。</p>\n<ul>\n<li>容器启动时，Spring 为 <code>TradeService</code> 生成了一个代理对象（Proxy）。</li>\n<li>外部调用 <code>process()</code> 时，先走的是代理。</li>\n<li>但在 <code>process()</code> 内部执行 <code>pay()</code> 时，使用的是 <code>this.pay()</code>。<strong>这里的 <code>this</code> 指向的是目标对象本身，而非代理对象</strong>。</li>\n<li>既然没经过代理，切面逻辑自然就像空气一样被穿透了。</li>\n</ul>\n<h3 id=\"避坑建议\">避坑建议</h3>\n<p>针对此类问题，我推荐以下处理方式：</p>\n<p><strong>推荐：拆分大法（Best Practice）</strong></p>\n<p>将 <code>pay()</code> 方法拆分到另一个独立的 Bean（例如 <code>PayService</code>）中。通过注入的方式调用，天然符合“通过代理调用”的规则，代码结构也更清晰。</p>\n<p><strong>推荐：AopContext</strong></p>\n<p>直接从 Spring 上下文中捞取当前代理对象。（老功能修改）</p>\n<ol>\n<li>SpringBoot启动类上开启配置：<code>@EnableAspectJAutoProxy(exposeProxy = true)</code></li>\n<li>具体代码中修改：<code>((TradeService) AopContext.currentProxy()).pay();</code></li>\n</ol>\n<p><strong>不推荐：@Autowired 注入自身</strong></p>\n<p>虽然能解决问题，但容易引发<strong>循环依赖</strong>异常，增加系统启动风险。</p>\n<hr />\n<h2 id=\"五-进阶思考从单机到分布式\">五、 进阶思考：从单机到分布式</h2>\n<p>前面我强调了 <code>Guava RateLimiter</code> 是<strong>单机限流</strong>。那么，如果系统做大了，部署了 50 个节点，需要对某个下游 API 做全局每秒 1000 次的限流，该怎么办？</p>\n<p><strong>这时候，AOP + 注解 设计模式的威力就体现出来了。</strong></p>\n<p>你<strong>完全不需要</strong>修改任何业务代码，也不用删掉 <code>@RateLimit</code> 注解。<br />\n你只需要做一个动作：<strong>修改 <code>RateLimitAop</code> 切面的实现</strong>。</p>\n<p>把切面里获取令牌的逻辑，从 <code>Guava RateLimiter</code> 换成 <strong>Redis + Lua</strong> 脚本，或者直接接入 <strong>Redisson</strong> 的 <code>RRateLimiter</code>。</p>\n<pre><code class=\"language-java\">// 伪代码示例：无缝切换分布式限流\nprivate RRateLimiter getRedisLimiter(String key) {\n    RRateLimiter limiter = redissonClient.getRateLimiter(key);\n    // ... 初始化 Redis 限流器 ...\n    return limiter;\n}\n\n// 在 around 方法里，将 RateLimiter.tryAcquire() 替换为 Redisson 的实现\nRRateLimiter limiter = getRedisLimiter(methodKey);\nif (!limiter.tryAcquire(annotation.qps(), annotation.timeout(), annotation.timeUnit())) {\n    throw new RateLimitException(\"分布式限流生效中...\");\n}\n</code></pre>\n<p>看，这就是架构设计的艺术。业务方无感知，底层能力平滑升级。</p>\n<hr />\n<h2 id=\"六-总结与结语\">六、 总结与结语</h2>\n<p>总的来说，AOP 让限流这类“基础设施”悄无声息地融入了业务脉络，这正是优雅架构的魅力所在——<strong>将复杂性收敛于一点，在别处换来 simplicity</strong>。</p>\n<p>最后，想起一句被反复“魔改”的名言，放在这里格外贴切：<strong>“让架构的归架构，让业务的归业务”</strong>。</p>\n<p>愿各位的代码世界，秩序井然，bug 退散。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 10:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xzqcsj\">一旅人</a>&nbsp;\n阅读(<span id=\"post_view_count\">49</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Flask项目一键打包实战：用PyInstaller生成独立可执行文件",
      "link": "https://www.cnblogs.com/ymtianyu/p/19413738",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19413738\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 09:16\">\n    <span>Flask项目一键打包实战：用PyInstaller生成独立可执行文件</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文详细介绍了使用PyInstaller打包Flask项目为单个可执行文件的实战步骤，包括关键命令参数解析、常见注意事项、静态资源和模板的添加方法，以及优化文件大小和启动速度的建议，并提供了完整可运行的代码示例，帮助开发者轻松分发Flask应用。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<p style=\"font-size: 18px; font-weight: bold;\">还在为Flask应用部署时需要配置服务器、安装依赖而烦恼吗？<strong style=\"color: rgba(186, 55, 42, 1);\">据统计，超过80%的Python开发者曾因环境问题导致应用分发失败，而PyInstaller只需一条命令就能生成单个可执行文件，彻底摆脱环境束缚！</strong></p>\n\n<blockquote style=\"padding-left: 15px; margin: 20px 0; color: rgba(85, 85, 85, 1); font-style: italic;\">\n<p>本文带你实战使用PyInstaller打包Flask项目，从基础命令解析到高级优化，一站式解决打包难题。亮点包括：详细参数说明、静态资源集成技巧、常见坑点避雷以及性能优化建议，并附上完整可运行的代码示例。<br />虽然对于PyInstaller的评价众口不一，文件过大，臃肿等，但它的实用也是实打实的方便。</p>\n<p>目录一览：</p>\n<div style=\"margin-left: 20px;\">\n<div>- ✨ 为什么需要打包Flask项目？</div>\n<div>- 🔧 PyInstaller快速入门</div>\n<div>- ⚙️ 命令参数逐行解析</div>\n<div>- ⚠️ 你必须知道的注意事项</div>\n<div>- 📁 如何添加静态资源和模板</div>\n<div>- 🚀 优化建议：让exe更小更快</div>\n<div>- 💻 完整代码参考与实战</div>\n</div>\n</blockquote>\n\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">✨ 为什么需要打包Flask项目？</h2>\n<p>想象一下，你开发了一个精致的Flask应用，但交给别人运行时，对方却要折腾Python环境、安装依赖库，甚至可能因版本冲突而崩溃。打包成单个<code>.exe</code>文件（或Mac/Linux可执行文件）后，用户双击即可运行，<strong style=\"color: rgba(186, 55, 42, 1);\">极大降低了部署门槛</strong>，特别适合内部分发、演示或交付小型工具。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🔧 PyInstaller快速入门</h2>\n<p>PyInstaller是一个流行的Python打包工具，能将Python脚本及依赖打包成独立可执行文件。首先，确保安装它：</p>\n<pre class=\"language-python highlighter-hljs\"><code>pip install pyinstaller</code></pre>\n<p>基础打包命令非常简单：</p>\n<pre class=\"language-bash highlighter-hljs\"><code>pyinstaller -F your_flask_app.py</code></pre>\n<p><code>-F</code>参数代表生成单个文件。打包后，在<code>dist</code>目录下会看到可执行文件。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">⚙️ 命令参数逐行解析</h2>\n<p>PyInstaller参数众多，掌握关键参数能让打包更高效。以下是最常用的参数解析：</p>\n<div style=\"margin-left: 20px;\">\n<div><strong style=\"color: rgba(186, 55, 42, 1);\">-F 或 --onefile</strong>：打包成单个可执行文件。方便分发，但启动稍慢。</div>\n<div><strong style=\"color: rgba(186, 55, 42, 1);\">-D 或 --onedir</strong>：打包成一个目录（默认），包含依赖文件。启动快，适合调试。</div>\n<div><strong style=\"color: rgba(186, 55, 42, 1);\">-w 或 --windowed</strong>：隐藏控制台窗口，对于Flask Web应用，通常<strong style=\"color: rgba(186, 55, 42, 1);\">不要使用</strong>，因为需要控制台输出日志。</div>\n<div><strong style=\"color: rgba(186, 55, 42, 1);\">--add-data</strong>：添加静态资源或模板文件，语法是<code>源路径:目标路径</code>。这是打包Flask项目的关键！</div>\n<div><strong style=\"color: rgba(186, 55, 42, 1);\">--hidden-import</strong>：手动添加PyInstaller未自动检测到的依赖模块，如<code>flask_cors</code>。</div>\n<div><strong style=\"color: rgba(186, 55, 42, 1);\">-n 或 --name</strong>：指定生成的可执行文件名称。</div>\n<div><strong style=\"color: rgba(186, 55, 42, 1);\">--clean</strong>：清理缓存，建议在多次打包前使用。</div>\n</div>\n<p><strong>示例命令：</strong></p>\n<pre class=\"language-bash highlighter-hljs\"><code>pyinstaller -F --add-data \"templates;templates\" --add-data \"static;static\" app.py</code></pre>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">⚠️ 你必须知道的注意事项</h2>\n<p>打包Flask项目时，容易踩坑，以下几点务必注意：</p>\n<div style=\"margin-left: 20px;\">\n<div>- <strong style=\"color: rgba(186, 55, 42, 1);\">路径问题</strong>：打包后，Flask的<code>static</code>和<code>templates</code>目录路径会改变，需要使用<code>sys._MEIPASS</code>来获取临时资源路径。</div>\n<div>- <strong style=\"color: rgba(186, 55, 42, 1);\">动态导入</strong>：如果使用了动态导入（如<code>importlib</code>），PyInstaller可能无法检测，需用<code>--hidden-import</code>手动添加。</div>\n<div>- <strong style=\"color: rgba(186, 55, 42, 1);\">多进程问题</strong>：Flask开发服务器默认不支持多进程，打包后避免使用多进程模式。</div>\n<div>- <strong style=\"color: rgba(186, 55, 42, 1);\">文件大小</strong>：单个exe文件可能较大（几十MB到上百MB），这是正常的，可通过优化减少体积。</div>\n<div>- <strong style=\"color: rgba(186, 55, 42, 1);\">防病毒误报</strong>：某些杀毒软件可能误报打包后的exe为病毒，建议签名或告知用户。</div>\n</div>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">📁 如何添加静态资源和模板</h2>\n<p>Flask项目通常包含<code>static</code>和<code>templates</code>目录，打包时必须显式添加。关键步骤：</p>\n<p>1. 修改Flask应用代码，使用<code>sys._MEIPASS</code>处理资源路径：</p>\n<pre class=\"language-python highlighter-hljs\"><code>import sys\nimport os\n\nif getattr(sys, 'frozen', False):\n    template_folder = os.path.join(sys._MEIPASS, 'templates')\n    static_folder = os.path.join(sys._MEIPASS, 'static')\n    app = Flask(__name__, template_folder=template_folder, static_folder=static_folder)\nelse:\n    app = Flask(__name__)</code></pre>\n<p>2. 打包时使用<code>--add-data</code>参数，根据操作系统指定分隔符（Windows用<code>;</code>，Mac/Linux用<code>:</code>）：</p>\n<pre class=\"language-python highlighter-hljs\"><code>pyinstaller -F --add-data \"templates;templates\" --add-data \"static;static\" app.py</code></pre>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🚀 优化建议：让exe更小更快</h2>\n<p>打包后文件臃肿？启动慢？试试这些优化技巧：</p>\n<div style=\"margin-left: 20px;\">\n<div>- <strong style=\"color: rgba(186, 55, 42, 1);\">使用虚拟环境打包</strong>：在干净的虚拟环境中安装仅需的依赖，避免无关库混入。</div>\n<div>- <strong style=\"color: rgba(186, 55, 42, 1);\">排除不必要的模块</strong>：通过<code>--exclude-module</code>移除未使用的库，如<code>pytest</code>。</div>\n<div>- <strong style=\"color: rgba(186, 55, 42, 1);\">启用UPX压缩</strong>：下载UPX工具，并用<code>--upx-dir</code>指定路径，可显著减小体积。</div>\n<div>- <strong style=\"color: rgba(186, 55, 42, 1);\">调整打包模式</strong>：如果不需要单文件，用<code>-D</code>目录模式可加快启动速度。</div>\n<div>- <strong style=\"color: rgba(186, 55, 42, 1);\">清理缓存</strong>：每次打包前运行<code>pyinstaller --clean</code>，避免旧文件干扰。</div>\n</div>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">💻 完整代码参考与实战</h2>\n<p>下面是一个完整的Flask示例项目及打包脚本，你可以直接复制使用：</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">项目结构：</strong></p>\n<pre class=\"language-python highlighter-hljs\"><code>my_flask_app/\n│   app.py\n│   pack.bat  # Windows打包脚本\n│\n├───static\n│       style.css\n│\n└───templates\n        index.html</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">app.py 内容：</strong></p>\n<pre class=\"language-python highlighter-hljs\"><code>import sys\nimport os\nfrom flask import Flask, render_template\n\n# 处理打包后的资源路径\nif getattr(sys, 'frozen', False):\n    template_folder = os.path.join(sys._MEIPASS, 'templates')\n    static_folder = os.path.join(sys._MEIPASS, 'static')\n    app = Flask(__name__, template_folder=template_folder, static_folder=static_folder)\nelse:\n    app = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('index.html', message='Hello from packed Flask!')\n\nif __name__ == '__main__':\n    app.run(debug=True, port=5000)</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">pack.bat（Windows打包脚本）：</strong></p>\n<pre class=\"language-python highlighter-hljs\"><code>pyinstaller -F ^\n  --add-data \"templates;templates\" ^\n  --add-data \"static;static\" ^\n  --hidden-import=flask ^\n  --clean ^\n  app.py\npause</code></pre>\n<p>运行<code>pack.bat</code>后，在<code>dist</code>目录下生成<code>app.exe</code>，双击即可启动Flask服务器！</p>\n\n<div style=\"text-align: center; margin: 30px 0;\"><hr style=\"border: 0; height: 1px;\" />\n<p style=\"color: rgba(119, 119, 119, 1);\">喜欢本文？不要错过✨，点赞👍收藏⭐关注我👆，一起学习更多有用的知识，完善你我的技能树！</p>\n</div>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 09:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">曲幽</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "上周热点回顾（12.22-12.28）",
      "link": "https://www.cnblogs.com/cmt/p/19413726",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/cmt/p/19413726\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 09:13\">\n    <span>上周热点回顾（12.22-12.28）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>热点随笔：</p>\n<p> · <a href=\"https://www.cnblogs.com/sheng-jie/archive/2025/12/22/19381647.html\" target=\"_blank\">从 MCP 到 Agent Skills，AI Ready 的 .NET 10 正当时</a> (<a href=\"https://www.cnblogs.com/sheng-jie/\" target=\"_blank\">「圣杰」</a>) <br />\n · <a href=\"https://www.cnblogs.com/sheng-jie/archive/2025/12/26/goodbye-2025-welcome-2026.html\" target=\"_blank\">未来已来 | 写给 .NET 开发者的 2025 年度总结</a>\n(<a href=\"https://www.cnblogs.com/sheng-jie/\" target=\"_blank\">「圣杰」</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/12lisu/archive/2025/12/23/19385452.html\" target=\"_blank\">高并发下如何防止重复提交订单？</a>\n(<a href=\"https://www.cnblogs.com/12lisu/\" target=\"_blank\">苏三说技术</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/sueyyyy/archive/2025/12/24/19394875.html\" target=\"_blank\">电信公网IPV4被收回之后：家庭网络的“绝地求生”折腾记</a>\n(<a href=\"https://www.cnblogs.com/sueyyyy/\" target=\"_blank\">少说点话</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/sunhui/archive/2025/12/25/19395609.html\" target=\"_blank\">所有64位WinForm应用都是Chromium浏览器</a>\n(<a href=\"https://www.cnblogs.com/sunhui/\" target=\"_blank\">Exe2WebBrowser</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/sunhui/archive/2025/12/24/19391507.html\" target=\"_blank\">问世间，exe是何物？直教AI沉默、Web寡言（1）</a>\n(<a href=\"https://www.cnblogs.com/sunhui/\" target=\"_blank\">WebRuntime</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/12lisu/archive/2025/12/22/19380992.html\" target=\"_blank\">Minio开始收费了？别慌，这5种免费的分布式文件系统更香！</a>\n(<a href=\"https://www.cnblogs.com/12lisu/\" target=\"_blank\">苏三说技术</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/yupi/archive/2025/12/22/19383955.html\" target=\"_blank\">从夯到拉，锐评 28 个后端技术！</a>\n(<a href=\"https://www.cnblogs.com/yupi/\" target=\"_blank\">程序员鱼皮</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/limingqi/archive/2025/12/24/19392317.html\" target=\"_blank\">归心于研：五年百度后的人生转向</a>\n(<a href=\"https://www.cnblogs.com/limingqi/\" target=\"_blank\">limingqi</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/1312mn/archive/2025/12/23/19201142.html\" target=\"_blank\">一款轻量级 WinForm 开源控件库，让老界面秒变高颜值</a>\n(<a href=\"https://www.cnblogs.com/1312mn/\" target=\"_blank\">小码编匠</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/yupi/archive/2025/12/25/19397182.html\" target=\"_blank\">女友怒骂国内不能用Claude Code，于是我给她做了一个</a>\n(<a href=\"https://www.cnblogs.com/yupi/\" target=\"_blank\">程序员鱼皮</a>)                    <br />\n · <a href=\"https://www.cnblogs.com/tcjiaan/archive/2025/12/26/19394178.html\" target=\"_blank\">【EF Core】将一个实体映射到多个表的正确方法</a>\n(<a href=\"https://www.cnblogs.com/tcjiaan/\" target=\"_blank\">东邪独孤</a>)                    <br />\n            </p>\n<p>热点新闻：</p>\n<p>\n · <a href=\"https://news.cnblogs.com/n/810559/\" target=\"_blank\">亲手给AI投毒之后，我觉得整个互联网都变成了一座黑暗森林</a><br />\n · <a href=\"https://news.cnblogs.com/n/811786/\" target=\"_blank\">摩尔线程的野心，不藏了</a><br />\n · <a href=\"https://news.cnblogs.com/n/810571/\" target=\"_blank\">高脂饮食悄然改写肝脏细胞命运</a><br />\n · <a href=\"https://news.cnblogs.com/n/811840/\" target=\"_blank\">浏览器里玩罪恶都市？这群俄罗斯人复活了整个童年</a><br />\n · <a href=\"https://news.cnblogs.com/n/810475/\" target=\"_blank\">怎么这么多年了，国内二手车还是这副德行？</a><br />\n · <a href=\"https://news.cnblogs.com/n/810672/\" target=\"_blank\">“哈勃”观测到罕见“宇宙撞击”</a><br />\n · <a href=\"https://news.cnblogs.com/n/810633/\" target=\"_blank\">DeepSeek给出了对寒武纪、摩尔线程、沐曦的投资建议</a><br />\n · <a href=\"https://news.cnblogs.com/n/810485/\" target=\"_blank\">罗永浩反映的电信网速问题已解决</a><br />\n · <a href=\"https://news.cnblogs.com/n/810563/\" target=\"_blank\">能自行修复的量子计算机问世</a><br />\n · <a href=\"https://news.cnblogs.com/n/810717/\" target=\"_blank\">微信聊天遭老板监视，杀毒软件“失明”，员工隐私被系统性采集！软件商公开售卖“监控神器”，称已服务多家企业</a><br />\n · <a href=\"https://news.cnblogs.com/n/810591/\" target=\"_blank\">360复盘快手事件：一场精心策划的AI化攻击</a><br />\n · <a href=\"https://news.cnblogs.com/n/811805/\" target=\"_blank\">7999 元起！小米发布「徕卡手机」，有可乐标，更有「德味」</a></p>\n<p>推广项目：</p>\n<p>· <a href=\"https://www.ebcloud.com/chn_xhpwpopm\" rel=\"noopener nofollow\" target=\"_blank\">英博云GPU容器服务平台，智能算力即开即用，立即免费试用</a><br />· <a href=\"https://ais.cn/u/VZZZJj\" rel=\"noopener nofollow\" target=\"_blank\">科研领域的连接者艾思科蓝，一站式科研学术服务数字化平台</a><br />· <a href=\"https://www.cnblogs.com/cmt/p/19165152\" rel=\"noopener\" target=\"_blank\">诚邀您体验阿里巴巴推出的新一代 Agentic 编程平台 Qoder</a><br />· <a href=\"https://dis.chatdesks.cn/chatdesk/jmcnblogs.html\" rel=\"noopener nofollow\" target=\"_blank\">人像高清输出，百变风格随心换，快来即梦试试吧</a><br />·&nbsp;<a href=\"https://www.trae.com.cn/?utm_source=advertising&amp;utm_medium=cnblogs_ug_cpa&amp;utm_term=hw_trae_cnblogs\" rel=\"noopener nofollow\" target=\"_blank\">TRAE SOLO 中国版正式上线，全面免费</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 09:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/cmt\">博客园团队</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "如何使用 PHP 的 for、while 和 foreach 循环实现极致性能与零 Bug 代码",
      "link": "https://www.cnblogs.com/catchadmin/p/19413458",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19413458\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 07:19\">\n    <span>如何使用 PHP 的 for、while 和 foreach 循环实现极致性能与零 Bug 代码</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"如何使用-php-的-forwhile-和-foreach-循环实现极致性能与零-bug-代码\">如何使用 PHP 的 for、while 和 foreach 循环实现极致性能与零 Bug 代码</h1>\n<p>效率至关重要。对于 PHP 开发者来说，循环是最核心的语言结构之一。它能让你自动化重复任务、遍历数据结构，并以可控的方式执行操作。但高效的循环不仅仅是理解语法——更在于知道如何优化循环，编写运行快速、无 Bug 且能随项目增长而优雅扩展的代码。</p>\n<p>无论你是处理大型数据集、复杂数组，还是试图优化 Web 应用的性能，本文都将深入探讨 PHP 循环的核心要点。我们将探索不同的循环类型——for、while 和 foreach——它们的最佳使用场景、性能优化技巧，以及能将你的 PHP 代码提升到全新水平的高级策略。</p>\n<p>准备好迎接一份超越基础的综合指南。我们将讨论性能调优、内存优化、实际案例，以及如何避免开发者在使用循环时常犯的陷阱。</p>\n<p><a href=\"https://catchadmin.com/post/2025-12/mastering-loops-in-php\" rel=\"noopener nofollow\" target=\"_blank\">原文 如何使用 PHP 的 for、while 和 foreach 循环实现极致性能与零 Bug 代码</a></p>\n<h2 id=\"理解-php-循环快速回顾\">理解 PHP 循环：快速回顾</h2>\n<p>在深入优化之前，先回顾一下 PHP 中的 for、while 和 foreach 循环。理解它们之间的核心差异对于在代码中做出正确决策至关重要。</p>\n<h3 id=\"for-循环\">for 循环</h3>\n<p>for 循环非常适合已知确切迭代次数的场景。它允许你遍历数字范围或固定集合，重复执行操作。</p>\n<p>语法：</p>\n<pre><code class=\"language-php\">for ($i = 0; $i &lt; 10; $i++) {\n    // 要执行的代码\n}\n</code></pre>\n<p>工作原理：</p>\n<ul>\n<li>初始化：<code>$i = 0</code> —— 设置起始值。</li>\n<li>条件：<code>$i &lt; 10</code> —— 只要条件为真就继续循环。</li>\n<li>迭代：<code>$i++</code> —— 每次迭代后递增循环计数器。</li>\n</ul>\n<p>理想使用场景：</p>\n<ul>\n<li>提前知道迭代次数时。</li>\n<li>遍历数字范围或固定大小的集合。</li>\n<li>性能至关重要时——在某些场景下 for 循环可能比其他循环更快。</li>\n</ul>\n<h3 id=\"while-循环\">while 循环</h3>\n<p>while 循环只要给定条件为真就会继续执行。与 for 循环不同，你在开始时并不知道迭代次数，这使它在结束条件动态变化的情况下非常灵活。</p>\n<p>语法：</p>\n<pre><code class=\"language-php\">while ($condition) {\n    // 要执行的代码\n}\n</code></pre>\n<p>工作原理：</p>\n<ul>\n<li>只要 <code>$condition</code> 为真，循环就会无限期运行。</li>\n<li>注意：如果条件永远不变为假，你会遇到无限循环，可能导致脚本冻结或崩溃。</li>\n</ul>\n<p>理想使用场景：</p>\n<ul>\n<li>不知道确切迭代次数时。</li>\n<li>处理依赖用户输入或外部资源的事件或数据。</li>\n<li>适用于读取数据流或等待外部响应。</li>\n</ul>\n<h3 id=\"foreach-循环\">foreach 循环</h3>\n<p>foreach 循环专门用于处理数组和对象。它是遍历数组最简单、最易读的方式，特别是当你不需要手动管理索引时。</p>\n<p>语法：</p>\n<pre><code class=\"language-php\">foreach ($array as $key =&gt; $value) {\n    // 要执行的代码\n}\n</code></pre>\n<p>工作原理：</p>\n<ul>\n<li>每次迭代时，循环自动从数组或对象中获取键和值。</li>\n<li>foreach 能无缝处理索引数组和关联数组。</li>\n</ul>\n<p>理想使用场景：</p>\n<ul>\n<li>遍历数组或对象时，特别是不需要修改数组时。</li>\n<li>最适合需要同时使用键和值的关联数组。</li>\n</ul>\n<h2 id=\"释放循环的力量优化以实现最大性能\">释放循环的力量：优化以实现最大性能</h2>\n<p>现在我们理解了核心循环类型，让我们探索能帮助我们优化循环性能并消除可能拖慢或破坏应用的 Bug 的技术。</p>\n<h3 id=\"消除循环内的冗余计算\">消除循环内的冗余计算</h3>\n<p>开发者最常犯的错误之一是在循环内执行不依赖循环变量的计算。这些冗余操作会不必要地拖慢代码。</p>\n<p>低效示例：</p>\n<pre><code class=\"language-php\">for ($i = 0; $i &lt; count($array); $i++) {\n    // 每次迭代都重复调用 count()\n    echo count($array);\n}\n</code></pre>\n<p>在这种情况下，<code>count($array)</code> 在每次迭代时都会被计算，如果数组很大，这会很昂贵。</p>\n<p>优化示例：</p>\n<pre><code class=\"language-php\">$arrayCount = count($array);  // 在循环前计算一次\nfor ($i = 0; $i &lt; $arrayCount; $i++) {\n    echo $arrayCount;\n}\n</code></pre>\n<p>通过在循环前存储 <code>count($array)</code> 的结果，我们避免了每次循环运行时的重复计算，从而实现更快的执行。</p>\n<h3 id=\"最小化循环内的昂贵函数调用\">最小化循环内的昂贵函数调用</h3>\n<p>PHP 函数调用，特别是像 <code>strlen()</code>、<code>array_search()</code> 或数据库查询这样的操作，在循环内调用时会增加显著的开销。为了优化代码，确保避免重复调用这些函数。</p>\n<p>低效示例：</p>\n<pre><code class=\"language-php\">for ($i = 0; $i &lt; count($array); $i++) {\n    $length = strlen($str);  // 每次迭代都执行昂贵操作\n    echo $length;\n}\n</code></pre>\n<p>优化示例：</p>\n<pre><code class=\"language-php\">$length = strlen($str);  // 在循环外调用一次\nfor ($i = 0; $i &lt; count($array); $i++) {\n    echo $length;  // 重用预计算的值\n}\n</code></pre>\n<p>这个小改动可以带来显著的性能提升，特别是在较大的循环中。</p>\n<h3 id=\"避免大数据集的嵌套循环\">避免大数据集的嵌套循环</h3>\n<p>嵌套循环是性能瓶颈的常见原因。当循环嵌套时，总时间复杂度会快速增长，导致代码效率低下。相反，尝试扁平化数据结构或使用更优化的算法。</p>\n<p>低效示例：</p>\n<pre><code class=\"language-php\">foreach ($array1 as $value1) {\n    foreach ($array2 as $value2) {\n        // 某些操作\n    }\n}\n</code></pre>\n<p>在这种情况下，如果 <code>$array1</code> 和 <code>$array2</code> 都很大，循环将具有 O(n²) 的时间复杂度，这可能是致命的。</p>\n<p>优化示例：</p>\n<ul>\n<li>与其使用嵌套循环，不如尝试扁平化数组或使用哈希表进行快速查找等技术。</li>\n<li>你也可以根据具体问题用更高效的算法替换嵌套循环。</li>\n</ul>\n<h3 id=\"利用生成器实现内存效率\">利用生成器实现内存效率</h3>\n<p>PHP 生成器是一个强大的特性，允许你一次产出一个数据项，减少内存消耗并在处理大数据集时提升性能。与常规函数不同，生成器不会将整个数据集加载到内存中；它们按需生成每个值。</p>\n<p>生成器示例：</p>\n<pre><code class=\"language-php\">function getLargeDataset() {\n    for ($i = 0; $i &lt; 1000000; $i++) {\n        yield $i;  // 一次产出一个值\n    }\n}\nforeach (getLargeDataset() as $value) {\n    // 处理每个值\n}\n</code></pre>\n<p>通过使用生成器，你可以处理无法一次性全部加载到内存中的数据集，使其成为处理大规模数据的强大工具。</p>\n<h3 id=\"在循环外预计算值\">在循环外预计算值</h3>\n<p>如果你执行的计算或获取的值在所有迭代中保持不变，在循环开始前计算一次。这减少了不必要的操作并提升性能。</p>\n<p>低效示例：</p>\n<pre><code class=\"language-php\">for ($i = 0; $i &lt; count($array); $i++) {\n    $result = expensiveOperation($array[$i]);  // 每次迭代都执行昂贵操作\n    // 处理 $result\n}\n</code></pre>\n<p>优化示例：</p>\n<pre><code class=\"language-php\">$preCalculatedResults = array_map('expensiveOperation', $array);  // 执行一次操作\nforeach ($preCalculatedResults as $result) {\n    // 处理预计算的 $result\n}\n</code></pre>\n<p>通过使用像 <code>array_map()</code> 或 <code>array_walk()</code> 这样的 PHP 函数，你可以在进入循环前预处理数据，最小化循环内的冗余函数调用。</p>\n<h2 id=\"应对常见陷阱避免循环中的-bug-和陷阱\">应对常见陷阱：避免循环中的 Bug 和陷阱</h2>\n<p>虽然 PHP 循环很强大，但如果使用不当也会带来风险。让我们探索一些常见陷阱以及如何避免它们。</p>\n<h3 id=\"避免无限循环\">避免无限循环</h3>\n<p>当循环条件永远无法满足时就会发生无限循环，导致循环无休止地运行。这是最令人沮丧的 Bug 之一，但可以通过确保条件最终变为假来避免。</p>\n<p>低效示例：</p>\n<pre><code class=\"language-php\">while ($condition) {\n    // 如果条件永远不变，这个循环可能永远运行\n}\n</code></pre>\n<p>解决方案：确保条件在循环内更新，或在必要时使用 break。</p>\n<pre><code class=\"language-php\">while ($condition) {\n    // 要执行的代码\n    $condition = updateCondition();  // 在循环内更新条件\n}\n</code></pre>\n<h3 id=\"差一错误\">差一错误</h3>\n<p>差一错误在遍历数组或范围时极为常见。一个常见错误是不正确地定义循环的结束条件，这可能导致访问无效的数组索引或执行不必要的迭代。</p>\n<p>低效示例：</p>\n<pre><code class=\"language-php\">for ($i = 0; $i &lt;= count($array); $i++) {\n    echo $array[$i];  // 可能访问越界索引\n}\n</code></pre>\n<p>解决方案：遍历数组时使用 <code>&lt;</code> 而不是 <code>&lt;=</code>。</p>\n<pre><code class=\"language-php\">for ($i = 0; $i &lt; count($array); $i++) {\n    echo $array[$i];  // 安全的数组访问\n}\n</code></pre>\n<h3 id=\"数组越界访问\">数组越界访问</h3>\n<p>在不验证索引是否存在的情况下访问数组元素可能导致错误。确保你的循环正确处理数组边界。</p>\n<p>低效示例：</p>\n<pre><code class=\"language-php\">for ($i = 0; $i &lt; count($array); $i++) {\n    echo $array[$i];  // 有访问未定义索引的风险\n}\n</code></pre>\n<p>解决方案：在访问数组元素前始终检查索引是否存在。</p>\n<pre><code class=\"language-php\">for ($i = 0; $i &lt; count($array); $i++) {\n    if (isset($array[$i])) {\n        echo $array[$i];  // 安全的数组访问\n    }\n}\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>掌握 PHP 循环不仅仅是理解它们的语法——更在于利用它们编写不仅功能完善，而且快速、内存高效且无 Bug 的代码。通过遵循本文概述的技术，你可以优化循环来处理大数据集、提升性能，并避免最常见的陷阱。</p>\n<p>核心要点：</p>\n<ul>\n<li>for 循环适合已知迭代次数的场景。</li>\n<li>while 循环非常适合依赖动态因素的条件。</li>\n<li>foreach 循环简化了数组和对象的遍历，无需手动索引。</li>\n<li>优化循环涉及最小化冗余操作、尽可能避免嵌套循环、使用生成器实现内存效率，以及仔细处理边界情况。</li>\n</ul>\n<p>有了这些最佳实践和性能技巧，你将编写出更高效、可扩展的 PHP 代码，不仅运行快速，而且更易于维护和调试。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 07:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">46</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "开源项目分享：Gitee热榜项目 2025年12月第四周 周榜",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19413216",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19413216\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 00:39\">\n    <span>开源项目分享：Gitee热榜项目 2025年12月第四周 周榜</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        &gt; 本文档整理Gitee本周热门开源项目，包含名称、链接、星级、描述及当日趋势分析。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>本文档整理Gitee本周热门开源项目，包含名称、链接、星级、描述及当日趋势分析。</p>\n</blockquote>\n<p><strong>很久没有看Gitee上面的开源项目了，年底了来看看Gitee上的周榜如何了</strong></p>\n<h1 id=\"1-豆包ai手机开源版\">1. 豆包AI手机开源版</h1>\n<ul>\n<li>\n<p><strong>项目链接</strong>：<a href=\"https://gitee.com/tsinghua-open/imaiwork\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/tsinghua-open/imaiwork</a></p>\n</li>\n<li>\n<p><strong>Star 数</strong>：950</p>\n</li>\n<li>\n<p><strong>项目描述</strong>：豆包AI手机开源版是一款基于无障碍模式与RPA技术构建的AI获客手机项目，其功能相较于原版豆包AI手机更为强大。该产品集成了AI自动获客、微信机器人、微信群发、朋友圈营销、数字人混剪、AI矩阵自动发布（覆盖抖音、小红书、快手、视频号等平台）以及截流获客等全流程营销功能，同时支持视频号搜索、自动添加微信、智能对话、SOP跟进与人机协同转化，从而为用户提供一套完整且高效的AI营销自动化解决方案。</p>\n</li>\n<li>\n<p><strong>应用建议</strong>：AI营销自动化、社交媒体矩阵运营、私域流量管理与转化、数字内容创作与分发、智能客户获取与跟进、微信生态营销、短视频平台自动化运营、智能销售流程管理<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n</ul>\n<hr />\n<h1 id=\"2-jeelowcode\">2. JeeLowCode</h1>\n<ul>\n<li>\n<p><strong>项目链接</strong>：<a href=\"https://gitee.com/jeelowcode/JeeLowCode\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/jeelowcode/JeeLowCode</a></p>\n</li>\n<li>\n<p><strong>Star 数</strong>：9623</p>\n</li>\n<li>\n<p><strong>项目描述</strong>：🔥JeeLowCode【企业级低代码】是一款专为企业级应用打造的低代码开发框架，可免费商用。该框架以低代码为核心，致力于实现快速开发与部署，通过直观的可视化界面，用户仅需简单拖拽组件即可轻松搭建各类应用，无需编写复杂代码，从而大幅提升开发效率，降低技术门槛，助力企业高效完成数字化建设。</p>\n</li>\n<li>\n<p><strong>应用建议</strong>：企业级内部管理系统、业务流程自动化平台、客户关系管理（CRM）系统、供应链管理（SCM）系统、人力资源管理（HRM）系统、办公自动化（OA）系统、数据可视化与报表平台、物联网（IoT）应用后台、教育培训管理系统、政务服务与审批平台<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n</ul>\n<hr />\n<h1 id=\"3-奥集能应用集成平台\">3. 奥集能应用集成平台</h1>\n<ul>\n<li>\n<p><strong>项目链接</strong>：<a href=\"https://gitee.com/orginone/oiocns-react\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/orginone/oiocns-react</a></p>\n</li>\n<li>\n<p><strong>Star 数</strong>：145</p>\n</li>\n<li>\n<p><strong>项目描述</strong>：奥集能应用集成平台是基于React框架开发的前端版本，全面整合即时通讯、无代码开发、文件管理系统、组织架构管理、门户网站、数据驾驶舱、在线商城及智能仓库等核心模块，致力于为各类组织提供一体化、可扩展的数字化解决方案，助力实现高效协同与业务创新。</p>\n</li>\n<li>\n<p><strong>应用建议</strong>：企业协同办公、智慧园区管理、教育机构管理、医疗健康管理、零售电商运营、政府公共服务、项目管理与协作、智能仓储物流<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n</ul>\n<hr />\n<h1 id=\"4-天翼云openteledb\">4. 天翼云OpenTeleDB</h1>\n<ul>\n<li>\n<p><strong>项目链接</strong>：<a href=\"https://gitee.com/teledb/openteledb\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/teledb/openteledb</a></p>\n</li>\n<li>\n<p><strong>Star 数</strong>：319</p>\n</li>\n<li>\n<p><strong>项目描述</strong>：天翼云OpenTeleDB是一款基于PostgreSQL 17深度开发的企业级开源关系型数据库，致力于提供覆盖完整业务链路、具备超高性能与极致安全的数据服务。其依托完善的性能监控体系、专业的数据管理平台以及高效的运维支撑能力，实现了全面开放的技术生态，携手全球合作伙伴共同打造世界领先的开源关系型数据库解决方案。该数据库尤其适用于需要高效处理复杂SQL的OLTP在线事务处理场景，以及对复杂数据对象进行高可靠管理的业务需求。OpenTeleDB采用木兰宽松许可证v2进行发行。</p>\n</li>\n<li>\n<p><strong>应用建议</strong>：金融科技、电信运营商、电子商务、企业资源规划（ERP）、物联网（IoT）平台、政务信息化、医疗健康信息管理、在线教育平台<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n</ul>\n<hr />\n<h1 id=\"5-fay\">5. fay</h1>\n<ul>\n<li>\n<p><strong>项目链接</strong>：<a href=\"https://gitee.com/xszyou/fay\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/xszyou/fay</a></p>\n</li>\n<li>\n<p><strong>Star 数</strong>：1906</p>\n</li>\n<li>\n<p><strong>项目描述</strong>：Fay是一个多功能MCP框架，专门用于协助数字人（涵盖2.5D、3D、移动端、PC端及网页端形态）或各类大语言模型（兼容OpenAI及DeepSeek等主流架构）与业务系统实现高效、稳定的连接与集成。</p>\n</li>\n<li>\n<p><strong>应用建议</strong>：数字人直播与互动营销、智能客服与虚拟助手、在线教育与培训、企业业务系统集成、游戏与娱乐交互、虚拟社交与陪伴、医疗健康咨询、金融业务办理、智能家居控制、车载智能助手<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n</ul>\n<hr />\n<h1 id=\"6-ai智能体现代化saas企业级项目\">6. AI智能体现代化Saas企业级项目</h1>\n<ul>\n<li>\n<p><strong>项目链接</strong>：<a href=\"https://gitee.com/netkevin-li/NetCoreKevin\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/netkevin-li/NetCoreKevin</a></p>\n</li>\n<li>\n<p><strong>Star 数</strong>：140</p>\n</li>\n<li>\n<p><strong>项目描述</strong>：基于.NET平台构建的现代化SaaS企业级前后端分离架构，融合AI智能体技术，开启智能应用的无限可能：前端采用Vue3框架，集成IdentityServer4单点登录系统，支持多级缓存机制与自动化任务调度，具备分布式部署能力，实现一库多租户数据隔离，配备完善的日志管理与授权鉴权体系，集成CAP事件总线处理分布式事务，通过SignalR实现实时通信，运用领域事件驱动设计，支持MCP协议服务，采用IOC模块化依赖注入，内置高效代码生成器，结合Quartz定时任务框架，集成多通道短信服务，深度融合人工智能技术，集成AgentFramework智能体框架与SemanticKernel语义内核，并引入RAG检索增强生成技术，全面赋能企业级应用智能化升级。</p>\n</li>\n<li>\n<p><strong>应用建议</strong>：企业级SaaS平台、智能办公自动化、智能客服与知识库、智能数据分析与决策、教育培训与在线学习、智能电商与零售、智慧医疗健康管理、金融科技与智能风控、物联网数据智能平台、内容管理与智能创作<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n</ul>\n<hr />\n<h1 id=\"7-1panel\">7. 1Panel</h1>\n<ul>\n<li>\n<p><strong>项目链接</strong>：<a href=\"https://gitee.com/fit2cloud-feizhiyun/1Panel\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/fit2cloud-feizhiyun/1Panel</a></p>\n</li>\n<li>\n<p><strong>Star 数</strong>：1330</p>\n</li>\n<li>\n<p><strong>项目描述</strong>：🔥 这是一款现代化、开源高效的Linux服务器运维管理面板，致力于为系统管理员和开发者提供直观便捷的图形化操作界面，实现服务器部署、监控、配置及维护的一体化高效管理。</p>\n</li>\n<li>\n<p><strong>应用建议</strong>：服务器部署与配置、系统监控与告警、应用服务管理、安全策略与审计、自动化运维、开发测试环境管理、多服务器集群管理、数据库管理、网站与域名管理、备份与恢复<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n</ul>\n<hr />\n<h1 id=\"8-各类大屏展示模板\">8. 各类大屏展示模板</h1>\n<ul>\n<li>\n<p><strong>项目链接</strong>：<a href=\"https://gitee.com/lvyeyou/DaShuJuZhiDaPingZhanShi\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/lvyeyou/DaShuJuZhiDaPingZhanShi</a></p>\n</li>\n<li>\n<p><strong>Star 数</strong>：26244</p>\n</li>\n<li>\n<p><strong>项目描述</strong>：我们持续更新各类大屏展示模板，涵盖可扩展低代码开发、工作流BPM引擎、智能表单设计器、一体化OA应用、高代码定制开发、在线数据视图及动态报表系统，为您提供全面而灵活的数字可视化解决方案。</p>\n</li>\n<li>\n<p><strong>应用建议</strong>：智慧城市指挥中心、企业运营监控、生产流程管理、应急调度指挥、数据决策分析、业务报表展示、政务公开服务、教育培训演示<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n</ul>\n<hr />\n<h1 id=\"9-大数据可视化大屏展示模板\">9. 大数据可视化大屏展示模板</h1>\n<ul>\n<li>\n<p><strong>项目链接</strong>：<a href=\"https://gitee.com/MTrun/big-screen-vue-datav\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/MTrun/big-screen-vue-datav</a></p>\n</li>\n<li>\n<p><strong>Star 数</strong>：9829</p>\n</li>\n<li>\n<p><strong>项目描述</strong>：🔥 这是一个基于 Vue、DataV 及 ECharts 构建的高性能大数据可视化（大屏展示）模板，具备数据动态刷新渲染、多屏幕自适应、可自由替换内部图表组件、支持 Mixins 功能注入等核心特性，并保持持续迭代更新，助力快速搭建专业级数据展示界面。</p>\n</li>\n<li>\n<p><strong>应用建议</strong>：智慧城市运营中心、企业数据驾驶舱、金融风险监控、工业生产监控、电商实时数据大屏、智慧交通指挥中心、能源管理系统、环境监测平台、应急指挥调度中心、医疗健康数据可视化<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n</ul>\n<hr />\n<h1 id=\"10-对讲平台\">10. 对讲平台</h1>\n<ul>\n<li>\n<p><strong>项目链接</strong>：<a href=\"https://gitee.com/zhousiraaa/mypoc\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/zhousiraaa/mypoc</a></p>\n</li>\n<li>\n<p><strong>Star 数</strong>：674</p>\n</li>\n<li>\n<p><strong>项目描述</strong>：一款轻量级、功能全面的对讲通信平台，支持在公共互联网、企业内部局域网以及专用基站环境中灵活部署，能够充分满足各类常规通信需求。该平台的安卓终端应用程序已全面适配GB28181国家标准协议，可无缝注册并接入符合国标规范的视频监控平台。平台核心功能集成了对讲服务、GB28181视频监控平台整合、WebRTC音视频实时通话，以及基于WebRTC SFU架构实现的音视频会议系统——其中会议功能提供端到端加密的百人级安全会议解决方案。此外，平台全面支持完全内网环境下的私有化部署，确保数据与通信的自主可控。</p>\n</li>\n<li>\n<p><strong>应用建议</strong>：应急指挥调度、智慧城市管理、公共安全监控、企业生产通信、交通运输调度、能源设施巡检、医疗协同通信、教育远程互动、商业连锁管理、政府政务协同<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n</ul>\n<hr />\n<h1 id=\"本周项目总结与趋势分析\">本周项目总结与趋势分析</h1>\n<p>今日Gitee热榜项目呈现出鲜明的技术融合与场景化落地趋势，整体上可归纳为三大核心方向：<strong>AI驱动的自动化与智能化工具</strong>、<strong>企业级低代码与数字化底座</strong>，以及<strong>高性能数据管理与可视化解决方案</strong>。</p>\n<p>首先，<strong>AI与自动化工具</strong>成为创新焦点。多个上榜项目致力于将人工智能深度集成到实际业务流中，例如“豆包AI手机开源版”构建了从获客、内容创作到私域运营的全链路AI营销自动化体系；“fay”框架则专注于为数字人和大语言模型提供连接业务系统的通用桥梁；而“AI智能体现代化Saas企业级项目”更是展示了如何将AI智能体、RAG、SemanticKernel等前沿技术融入一个完整的企业级SaaS架构。这反映出AI技术正从单点应用转向系统化、流程化的赋能，尤其在营销、客服、内容生成和业务自动化领域展现出强大的生产力提升潜力。</p>\n<p>其次，<strong>企业级低代码与集成平台</strong>持续受到高度关注。像“JeeLowCode”这类专为企业设计的低代码框架，通过可视化拖拽极大降低了应用开发门槛，旨在快速响应数字化转型需求。同时，“奥集能应用集成平台”提供了涵盖IM、无代码、组织管理、数据驾驶舱等模块的一站式数字化解决方案，体现了市场对<strong>开箱即用、高度集成</strong>的综合平台的需求增长。这类项目旨在帮助各类组织，尤其是非技术背景的团队，以更低成本、更高效率构建和管理其核心业务系统。</p>\n<p>再者，<strong>数据基础设施与可视化</strong>依然是硬需求。天翼云推出的“OpenTeleDB”基于PostgreSQL打造，强调高性能、安全与完整的运维监控，瞄准了金融、电信等对数据库有严苛要求的企业级OLTP场景。而在数据展示层面，“各类大屏展示模板”和“大数据可视化大屏展示模板”等项目持续火爆，它们提供了基于Vue、ECharts等技术的可定制化模板，说明在智慧城市、企业运营监控等领域，<strong>数据驱动决策</strong>的直观呈现工具具有广泛且持续的市场需求。</p>\n<p>此外，一个值得注意的亮点是<strong>通信与协同工具的国产化与集成化</strong>。“对讲平台”项目不仅支持轻量级对讲，还集成了GB28181视频监控和WebRTC会议系统，并支持全内网私有化部署，这契合了特定行业（如政务、应急、能源）对<strong>安全可控、多功能融合</strong>的通信解决方案的迫切需求。</p>\n<p><strong>趋势总结</strong>：今日热榜清晰地表明，开源项目的价值越来越体现在<strong>解决实际业务痛点</strong>和<strong>提升开发运营效率</strong>上。技术趋势上，<strong>AI Agent化、低代码化、数据可视化</strong>以及<strong>信创环境下安全可控的集成方案</strong>是当前最活跃的赛道。开发者与企业的关注点正从单一的技术组件，转向能够提供<strong>端到端解决方案、具备强大集成能力、并能显著降低实施复杂度</strong>的综合型平台和框架。未来，具备业务洞察、能将这些技术趋势有机融合，并提供平滑落地路径的项目，将继续引领开源生态的发展。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 00:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\n阅读(<span id=\"post_view_count\">231</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[盒子模型]HTML Learn Data Day 4",
      "link": "https://www.cnblogs.com/Reisentyan/p/19413199",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Reisentyan/p/19413199\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 00:12\">\n    <span>[盒子模型]HTML Learn Data Day 4</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>过两天可以学js去了，之后学go，学vue，干全栈工程师吧</p>\n<h2 id=\"一-结构伪类选择器-structural-pseudo-classes\">一、 结构伪类选择器 (Structural Pseudo-classes)</h2>\n<p>用于在不增加额外类名（Class）的情况下，根据 HTML 结构精准选中元素。常用于列表（<code>li</code>）的样式差异化。</p>\n<table>\n<thead>\n<tr>\n<th><strong>语法</strong></th>\n<th><strong>语义</strong></th>\n<th><strong>典型应用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>li:first-child</code></td>\n<td>选中父元素下的第一个子元素</td>\n<td>列表顶部置顶样式</td>\n</tr>\n<tr>\n<td><code>li:last-child</code></td>\n<td>选中父元素下的最后一个子元素</td>\n<td>去除列表底部分割线</td>\n</tr>\n<tr>\n<td><code>li:nth-child(n)</code></td>\n<td>选中第 n 个子元素</td>\n<td>隔行变色（如 <code>2n</code>）</td>\n</tr>\n<tr>\n<td><code>li:nth-child(n+3)</code></td>\n<td>选中从第 3 个开始往后的所有元素</td>\n<td>批量控制列表后期项</td>\n</tr>\n</tbody>\n</table>\n<p><code>nth-child</code> 支持公式，如 <code>-n+5</code> 表示前 5 个，这在展示后端接口返回的前几条热门数据时非常有用。</p>\n<p>实例：</p>\n<pre><code class=\"language-html\">/*结构伪类选择器*/\n\t\tli:first-child{\n\t\t\tbackground-color: hotpink;\n\t\t}\n\t\tli:last-child{\n\t\t\tbackground-color: deeppink;\n\t\t}\n\t\tbutton:hover{\n\t\t\tbackground-color: darkred;\n\t\t}\n\t\tli:nth-child(3n+1){\n\t\t\tbackground-color: pink;\n\t\t}\n\t\tli:nth-child(n+3)\n\t\t{\n\t\t\tbackground-color: red;\n\t\t}\n\n&lt;label&gt;\n\t&lt;ul&gt;\n\t\t&lt;li&gt;这是第一个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第二个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第三个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第四个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第五个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第一个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第二个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第三个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第四个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第五个元素&lt;/li&gt;\n\t&lt;/ul&gt;\n\t&lt;br&gt;\n\t&lt;button&gt;this is a button&lt;/button&gt;\n\t&lt;/label&gt;\n</code></pre>\n<h2 id=\"二-伪元素选择器-pseudo-elements\">二、 伪元素选择器 (Pseudo-elements)</h2>\n<p>用于向选择器添加“装饰性”的子元素，而无需修改 HTML 结构。</p>\n<ul>\n<li><strong>核心规则</strong>：必须书写 <code>content: \"\";</code> 属性，否则伪元素不生效。</li>\n<li><strong>常用类型</strong>：\n<ul>\n<li><code>::before</code>：在内容最前面插入。</li>\n<li><code>::after</code>：在内容最后面插入。</li>\n<li><code>::marker</code>：专门控制列表符号。</li>\n</ul>\n</li>\n</ul>\n<p>实例：</p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    /*补充，这是列表的伪元素*/li::marker/*伪元素选择器*/\n\t\t{\n\t\t\tcontent: \"❄\";\n\t\t\tcolor:skyblue ;\n\t\t\tfont-size: 1.5em;\n\t\t}\n\t\t.fake::before{/*装饰性的元素\t*/\n\t\t\tpadding:10px;/*盒子模型的内边距\t*/\n\t\t\tborder: 2px solid;/*盒子模型的边框线*/\n\t\t\tmargin:10px;/*盒子模型的外边距*/\n\t\t\t/*外边距在盒子外面，不会撑大盒子*/\n\t\t\tborder-top:2px solid rgba(149, 117, 205, 1.0) ;\n\t\t\tborder-buttom:2px solid rgba(103, 58, 183, 0.8) ;\n\t\t\tborder-right:2px solid rgba(158, 154, 201, 0.7) ;\n\t\t\tborder-left:2px solid red ;\n\n\t\t\tdisplay: block;\n\t\t\tcontent: \"这是content\";\n\t\t\tbackground-color: rgba(var(--color), 0.8) ;\n\t\t}\n\t\t.fake::after{\n\t\t\tposition: absolute;/*以realtive为参考系设置其位置*/\n\t\t\tdisplay: block;\n\t\t\tcontent: \"这是尾注\";\n\t\t\tbackground-color: rgba(var(--color),1.0);\n\n\t\t\tbottom:0 ;/*紧贴尾部*/\n\t\t\tleft:0;/*紧贴左部*/\n\t\t\twidth: 100%;\n\t\t\tmargin:0px 0px 0px 10px\t;\n\t\t}\n&lt;/style&gt;\n    \n\t\t&lt;div class=\"fake\"&gt;这是一个伪元素寄存器的练习案例&lt;/div&gt;\n</code></pre>\n<h2 id=\"三-盒子模型-box-model--网页布局的基石\">三、 盒子模型 (Box Model) —— 网页布局的基石</h2>\n<p>网页所有元素皆为“盒子”。理解内外边距的堆叠是排版不乱的关键。</p>\n<ol>\n<li><strong>Padding (内边距)</strong>：盒子内容与边框之间的距离。会撑大盒子体积。</li>\n<li><strong>Border (边框)</strong>：盒子的外壳。支持四边单独设置（<code>border-top</code> 等）。</li>\n<li><strong>Margin (外边距)</strong>：盒子与盒子之间的距离。不会撑大盒子。\n<ul>\n<li><strong>居中技巧</strong>：<code>margin: 0 auto;</code>（配合宽度使用可实现水平居中）。</li>\n</ul>\n</li>\n<li><strong>Overflow (溢出处理)</strong>：\n<ul>\n<li><code>visible</code>：默认，内容溢出。</li>\n<li><code>hidden</code>：裁剪多余内容。</li>\n<li><code>auto</code>：内容溢出时自动出现滚动条。</li>\n</ul>\n</li>\n</ol>\n<p>前三个属性都是写在某些大标签里的，并且都有四种元素</p>\n<ul>\n<li>top</li>\n<li>buttom</li>\n<li>left</li>\n<li>right</li>\n</ul>\n<p>表示上下左右四个方向，都可以对这四种元素填入属性或者参数，来改变特定方向的样式</p>\n<p><strong>重要补充：</strong> 怪异盒子模型 (box-sizing)</p>\n<p><strong>border-box (怪异模式)</strong>：<code>盒子总宽 = width</code>（Padding 和 Border 会向内挤压）。这能保证布局不会因为加了内边距而“塌陷”。</p>\n<h2 id=\"一些技巧\">一些技巧</h2>\n<h3 id=\"设置参考系用于确定元素的防止位置\">设置参考系，用于确定元素的防止位置：</h3>\n<ol>\n<li><strong>Relative (相对定位)</strong>：作为参考系。它不会脱离文档流，原来的位置依然被占着。</li>\n<li><strong>Absolute (绝对定位)</strong>：以最近的 <code>relative</code> 祖先为准进行移动。它<strong>脱离文档流</strong>，像漂浮在页面上一样。</li>\n</ol>\n<pre><code class=\"language-css\">bottom:0 ;/*紧贴尾部*/\nleft:0;/*紧贴左部*/\nwidth: 100%;\n</code></pre>\n<p><code>.fake::after</code> 使用绝对定位锁定在底部 <code>bottom: 0</code>，这是标准的“底部工具条”写法。</p>\n<h3 id=\"清理默认样式不同浏览器默认样式不同比如-ul-自带边距开发第一步就是清理它们\">清理默认样式，不同浏览器默认样式不同（比如 <code>ul</code> 自带边距）开发第一步就是清理它们。</h3>\n<p>一般写成这样：</p>\n<pre><code class=\"language-css\">*{/*清理所有东西的内外边距*/\n\tmargin:0;\n\tpadding:0;\n    box-sizing: border-box; /* 推荐加入，防止 padding 撑大盒子 */\n}\n</code></pre>\n<h3 id=\"盒子阴影\">盒子阴影：</h3>\n<pre><code class=\"language-css\">box-shadow:0px 0px 10px 1px red;\n/*盒子的阴影 属性值：X轴偏移量 Y轴偏移量 模糊半径 扩散半径 颜色 内外阴影*/\n</code></pre>\n<h3 id=\"元素变量\">元素变量：</h3>\n<p>变量的声明为：<code>--</code>，比如<code>--color</code>，即声明了一个叫color的变量，样例：</p>\n<pre><code class=\"language-css\">--color:255, 183, 197;\nbackground-color: rgba(var(--color), 0.6);/*使用var来调用*/\n</code></pre>\n<h3 id=\"圆角写法使用border-radius样例\">圆角写法，使用<code>border-radius</code>，样例：</h3>\n<pre><code class=\"language-css\">border-radius:10%;\n</code></pre>\n<p>圆角50%为最大，也可以填像素</p>\n<h2 id=\"全部代码\">全部代码</h2>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n\t&lt;meta charset=\"utf-8\"&gt;\n\t&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n\t&lt;title&gt;练习用的代码&lt;/title&gt;\n\t&lt;style&gt;\n/*\n\t\t{\n\t\t\tmargin:0;\n\t\t\tpadding:0;\n\t\t}\n*/\n\n\t\tli{\n\t\t\topacity:0.5;\n\t\t\tlist-style: none;\n\t\t}\n\t\tli::marker/*伪元素选择器*/\n\t\t{\n\t\t\tcontent: \"❄\";\n\t\t\tcolor:skyblue ;\n\t\t\tfont-size: 1.5em;\n\t\t}\n\t\t\n\n\t\t/*结构伪类选择器*/\n\t\tli:nth-child(3n+1){\n\t\t\tbackground-color: pink;\n\t\t}\n\t\tli:first-child{\n\t\t\tbackground-color: hotpink;\n\t\t}\n\t\tli:last-child{\n\t\t\tbackground-color: deeppink;\n\t\t}\n\t\tbutton:hover{\n\t\t\tbackground-color: darkred;\n\t\t}\n\t\tli:nth-child(n+3)\n\t\t{\n\t\t\tbackground-color: red;\n\t\t}\n\t\tlabel{\n\t\t\tdisplay: block;\n\t\t\tbackground-image: url(../image/cuteReisentyan.jpg) ;\n\t\t\tbackground-repeat: repeat;\n\t\t\tbackground-size:100% 100%;\n\t\t}\n\n\n\t\t/*伪元素选择器*/\n\t\t.fake{\n\t\t\tmargin: 0 auto;/*自动居中*/\n\t\t\tposition:relative;/*设置位置参考系*/\n\t\t\t--color:255, 183, 197;\n\t\t\tmargin-top:50px;\n\t\t\theight: 300px;\n\t\t\twidth:300px;\n\t\t\tbackground-color: rgba(var(--color), 0.6);\n\n\t\t\tborder-radius:10%;\n\n\t\t\tbox-shadow:0px 0px 10px 1px red;\n\t\t\t/*盒子的阴影 属性值：X轴偏移量 Y轴偏移量 模糊半径 扩散半径 颜色 内外阴影*/\n\n\t\t\toverflow:auto;/*如果内容超出范围了，自动添加滚动条用的*/\n\t\t}\n\n\t\t.fake::before{/*装饰性的元素\t*/\n\t\t\tpadding:10px;/*盒子模型的内边距\t*/\n\t\t\tborder: 2px solid;/*盒子模型的边框线*/\n\t\t\tmargin:10px;/*盒子模型的外边距*/\n\t\t\t/*外边距在盒子外面，不会撑大盒子*/\n\t\t\tborder-top:2px solid rgba(149, 117, 205, 1.0) ;\n\t\t\tborder-buttom:2px solid rgba(103, 58, 183, 0.8) ;\n\t\t\tborder-right:2px solid rgba(158, 154, 201, 0.7) ;\n\t\t\tborder-left:2px solid red ;\n\n\t\t\tdisplay: block;\n\t\t\tcontent: \"这是content\";\n\t\t\tbackground-color: rgba(var(--color), 0.8) ;\n\t\t}\n\t\t.fake::after{\n\t\t\tposition: absolute;/*以realtive为参考系设置其位置*/\n\t\t\tdisplay: block;\n\t\t\tcontent: \"这是尾注\";\n\t\t\tbackground-color: rgba(var(--color),1.0);\n\n\t\t\tbottom:0 ;/*紧贴尾部*/\n\t\t\tleft:0;/*紧贴左部*/\n\t\t\twidth: 100%;\n\t\t\tmargin:0px 0px 0px 10px\t;\n\t\t}\n\n\t&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n\t&lt;!--一般开发中，会将li这样的，带有默认样式的东西，将样式清除掉--&gt;\n\t&lt;label&gt;\n\t&lt;ul&gt;\n\t\t&lt;li&gt;这是第一个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第二个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第三个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第四个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第五个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第一个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第二个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第三个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第四个元素&lt;/li&gt;\n\t\t&lt;li&gt;这是第五个元素&lt;/li&gt;\n\t&lt;/ul&gt;\n\t&lt;br&gt;\n\t&lt;button&gt;this is a button&lt;/button&gt;\n\t&lt;/label&gt;\n\n\t&lt;div class=\"fake\"&gt;这是一个伪元素寄存器的练习案例&lt;/div&gt;\n\t\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 00:12</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Reisentyan\">粉紫系超人气月兔铃仙</a>&nbsp;\n阅读(<span id=\"post_view_count\">43</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}