{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "论文解读：One-shot Entropy Minimization",
      "link": "https://www.cnblogs.com/qizhou/p/19426973",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/qizhou/p/19426973\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 15:36\">\n    <span>论文解读：One-shot Entropy Minimization</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>一篇还未发表的论文，但做了大量实验对熵最小化技巧提升模型推理能力进行了探索。本文训练了13440个大型语言模型，发现熵最小化（EM）只需要一个未标记的数据和10步优化，性能提升就比<strong>RL</strong>还强。基于两个直接而简单的假设：</p>\n<ul>\n<li>\n<p>生成大型语言模型的采样过程本质上是随机的。</p>\n</li>\n<li>\n<p>正确答案的熵通常低于错误答案。</p>\n</li>\n</ul>\n<p>EM和RL有<strong>共同目标</strong>：在不添加新知识的情况下释放预训练模型的潜在潜力，都依赖于所谓“token重评级”。</p>\n<h1>方法</h1>\n<p>给定prompt <span class=\"math\">$x$</span>，生成序列<span class=\"math\">$y$</span>，最小化生成序列token级别的预测熵：</p>\n<p style=\"text-align: center;\"><span class=\"math\">$\\displaystyle L_{\\mathrm{EM}} = \\frac{1}{|y|} \\sum_{t = 1}^{|y|} H_t&nbsp;&nbsp;$</span></p>\n<p style=\"text-align: center;\"><span class=\"math\">$\\displaystyle H_t = -\\sum_{v \\in V} p_\\theta(v \\mid y_{&lt;t}, x)\\,\\log p_\\theta(v \\mid y_{&lt;t}, x)$</span></p>\n<p>训练对单个样本进行，从未标注数据中筛选（2.2节）：模型在多次采样下表现出较高的 pass@k 方差，从而对“熵”更敏感，提供更强的<strong>熵梯度</strong>信号。所谓pass@k 方差就是大模型针对同一个数据生成<span class=\"math\">$k$</span>段内容，计算<span class=\"math\">$k$</span>个内容正确与否的方差。</p>\n<h1>实验</h1>\n<p><strong>训练设置：</strong>针对特定样本，每次生成64段推理内容（即训练批量为64），用以上最小熵损失微调大模型10次。预测温度设置为0.5，学习率固定为<span class=\"math\">$2\\times 10^{-5}$</span>。</p>\n<p>表1：各种推理模型与EM的对比。</p>\n<p>图1：用了EM之后，模型生成token 的概率分布。EM使分布更右偏。</p>\n<p>图2：EM损失和评估分数随着训练的变化曲线。</p>\n<p>图3/4：不同温度对性能的影响。</p>\n<p>图5：EM和RL先后执行，性能随迭代的变化。发现RL之后应用EM会导致性能下降，而EM之后RL性能会提升。这表明EM加剧了RL引入的分配扭曲，强化了RL的“对齐税”。</p>\n<p>表2：多样本的EM与单样本的EM对比，看出多样本也没有多大优势。</p>\n<p>图6：不同学习率对推理性能的影响。</p>\n<h1>讨论与见解</h1>\n<p>单次EM增益的上限由基础模型的内在推理能力决定。在相对较弱的LLaMA-3.1-8B上，单次EM的平均准确率仅提高到24.3%，勉强超过23.6%的基线。这表明，当底层模型缺乏足够的推理能力时，最小EM优化无法完全弥补其不足。</p>\n<p>RL根据外部真实奖励调整令牌概率。这通常会促进以前低概率（尾部）代币的相对排名。即使在重新排序后，这些代币也往往占据概率分布的中间位置，需要在采样过程中选择更高的温度。因此，RL训练的模型表现出相反的趋势：性能随着采样温度的升高而提高，如图4所示。</p>\n<p>在大多数场景中，尤其是在SFT和训练最少的RL环境中，EM显著地修剪了冗余的决策路径，稳定了关键预测，验证了其作为最小但强大的优化策略的有效性和通用性。</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 15:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/qizhou\">颀周</a>&nbsp;\n阅读(<span id=\"post_view_count\">11</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于大疆MSDK实现的无人机视觉引导自适应降落功能",
      "link": "https://www.cnblogs.com/foury/p/19426887",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/foury/p/19426887\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 15:24\">\n    <span>基于大疆MSDK实现的无人机视觉引导自适应降落功能</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"基于大疆msdk实现的无人机视觉引导自适应降落功能\">基于大疆MSDK实现的无人机视觉引导自适应降落功能</h1>\n<h2 id=\"概述\">概述</h2>\n<p>最初需求：想要无人机在执行完航线任务后，一键落到一个指定的位置，简化人工控制。</p>\n<p>实现一套完整的无人机自主降落功能,通过虚拟摇杆控制使无人机飞向指定位置，再利用视觉识别引导无人机精确降落到具体位置。本文中采用自适应降落策略,根据高度动态调整精度要求和下降速度,以实现安全、精确的降落。</p>\n<p><strong>核心点:</strong></p>\n<ul>\n<li>虚拟摇杆导航替代FlyTo功能</li>\n<li>双轴(X/Y)位置偏移实时调整</li>\n<li>高度自适应降落策略</li>\n<li>视觉识别引导定位</li>\n<li>智能避障管理</li>\n</ul>\n<hr />\n<h2 id=\"系统架构\">系统架构</h2>\n<h3 id=\"整体流程\">整体流程</h3>\n<div class=\"mermaid\">graph TD\n    A[用户触发Return to Vehicle] --&gt; B[获取无人机GPS位置]\n    B --&gt; C[计算与目标点距离]\n    C --&gt; D[启动虚拟摇杆导航]\n    D --&gt; E[飞向目标位置 5m/s]\n    E --&gt; F{距离小于10m?}\n    F --&gt;|否| E\n    F --&gt;|是| G[开始自适应降落]\n    G --&gt; H[视觉识别系统]\n    H --&gt; I[计算X/Y偏移量]\n    I --&gt; J[更新偏移量到ViewModel]\n    J --&gt; K[自适应降落循环]\n    K --&gt; L{高度分段判断}\n    L --&gt;|高于50m| M[高空模式]\n    L --&gt;|20-50m| N[中空模式]\n    L --&gt;|5-20m| O[低空模式]\n    L --&gt;|低于5m| P[极低空模式]\n    M --&gt; Q[计算调整速度和下降速度]\n    N --&gt; Q\n    O --&gt; Q\n    P --&gt; Q\n    Q --&gt; R{偏移大于阈值2倍?}\n    R --&gt;|是| S[停止下降只调整]\n    R --&gt;|否| T[边调整边下降]\n    S --&gt; U{高度小于5m?}\n    T --&gt; U\n    U --&gt;|是| V[关闭下视避障]\n    U --&gt;|否| K\n    V --&gt; W{高度小于等于0.1m?}\n    W --&gt;|否| K\n    W --&gt;|是| X[着陆完成清理资源]\n\n</div><h2 id=\"技术实现思路\">技术实现思路</h2>\n<h3 id=\"第一步让无人机飞到目标位置\">第一步:让无人机飞到目标位置?</h3>\n<h4 id=\"问题分析\">问题分析</h4>\n<p>遥控器控制的无人机在执行完航线任务之后，飞到给定降落点（汽车或其他载具上）。最初的想法是使用DJI SDK提供的<code>FlyTo</code>功能,直接指定目标GPS坐标让无人机飞过去。但在实际测试中，发现部分机型（如M3E）并不支持<code>FlyTo</code>功能。</p>\n<p><strong>机型是否支持<code>FlyTo</code>功能参考文档</strong>：<a href=\"https://developer.dji.com/doc/mobile-sdk-tutorial/cn/tutorials/intelligent-flight.html\" rel=\"noopener nofollow\" target=\"_blank\">https://developer.dji.com/doc/mobile-sdk-tutorial/cn/tutorials/intelligent-flight.html</a></p>\n<h4 id=\"解决方案虚拟摇杆导航\">解决方案:虚拟摇杆导航</h4>\n<p>既然<code>FlyTo</code>功能不可用,那就用<strong>虚拟摇杆</strong>功能进行模拟。</p>\n<p><strong>思路:</strong></p>\n<ol>\n<li>计算当前位置到目标位置的<strong>方位角</strong>(bearing)</li>\n<li>将方位角转换为<strong>速度分量</strong>(南北/东西)</li>\n<li>持续发送虚拟摇杆指令,让无人机朝目标飞行</li>\n<li>实时监测距离,接近目标时停止</li>\n</ol>\n<p><strong>方位角计算:</strong></p>\n<pre><code class=\"language-kotlin\">private fun calculateBearing(latA: Double, lonA: Double, latB: Double, lonB: Double): Double {\n    val lat1 = Math.toRadians(latA)\n    val lat2 = Math.toRadians(latB)\n    val dLon = Math.toRadians(lonB - lonA)\n    \n    val y = Math.sin(dLon) * Math.cos(lat2)\n    val x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon)\n    \n    var bearing = Math.toDegrees(Math.atan2(y, x))\n    bearing = (bearing + 360) % 360  // 归一化到0-360度\n    \n    return bearing  // 0°=正北, 90°=正东, 180°=正南, 270°=正西\n}\n</code></pre>\n<p><strong>速度分量计算:</strong></p>\n<pre><code class=\"language-kotlin\">val bearing = calculateBearing(currentLat, currentLon, targetLat, targetLon)\nval bearingRad = Math.toRadians(bearing)\n\n// 使用GROUND坐标系(地面坐标系)\nval navParam = VirtualStickFlightControlParam().apply {\n    rollPitchCoordinateSystem = FlightCoordinateSystem.GROUND\n    verticalControlMode = VerticalControlMode.POSITION\n    yawControlMode = YawControlMode.ANGLE\n    rollPitchControlMode = RollPitchControlMode.VELOCITY\n    \n    // 将速度分解为南北和东西分量\n    pitch = NAVIGATION_SPEED * Math.cos(bearingRad)  // 南北分量(5m/s)\n    roll = NAVIGATION_SPEED * Math.sin(bearingRad)   // 东西分量(5m/s)\n    yaw = bearing  // 让机头指向目标\n    verticalThrottle = targetAlt\n}\n</code></pre>\n<ul>\n<li>GROUND坐标系是<strong>绝对方向</strong>,不受无人机朝向影响</li>\n<li>pitch控制南北,roll控制东西。</li>\n</ul>\n<p><strong>虚拟摇杆参数含义</strong>：<a href=\"https://developer.dji.com/doc/mobile-sdk-tutorial/cn/basic-introduction/basic-concepts/flight-controller.html#%E8%99%9A%E6%8B%9F%E6%91%87%E6%9D%86\" rel=\"noopener nofollow\" target=\"_blank\">https://developer.dji.com/doc/mobile-sdk-tutorial/cn/basic-introduction/basic-concepts/flight-controller.html#虚拟摇杆</a></p>\n<hr />\n<h3 id=\"第二步判断何时到达目标点上方附近\">第二步:判断何时到达目标点上方附近</h3>\n<h4 id=\"持续监测距离\">持续监测距离</h4>\n<p>每100ms检查一次当前位置与目标的距离，距离小于预期值<code>ARRIVAL_THRESHOLD</code>,就认为无人机已到达目标点上方附近，停止导航，开始降落:</p>\n<pre><code class=\"language-kotlin\">val navTask = object : Runnable {\n    override fun run() {\n        val currentLoc = getAircraftLocation()\n        val remainingDistance = calculateDistance(\n            currentLoc.latitude, currentLoc.longitude,\n            targetLat, targetLon\n        )\n        \n        if (remainingDistance &lt; ARRIVAL_THRESHOLD) {  // 10米内\n            // 到达目标,停止导航,开始降落\n            isNavigating = false\n            startDynamicAdjustment()\n        } else {\n            // 继续飞行\n            sendNavigationCommand()\n            virtualStickHandler?.postDelayed(this, 100)\n        }\n    }\n}\n</code></pre>\n<hr />\n<h3 id=\"第三步精确降落到指定点\">第三步:精确降落到指定点</h3>\n<p>无人机虽然到了目标附近(10米内),但有以下问题：</p>\n<ol>\n<li><strong>GPS精度有限</strong>(±3米),不够精确。</li>\n<li><strong>风力影响</strong>,有时候受风的影响，无人机会偏离。</li>\n</ol>\n<h4 id=\"解决方案视觉识别位置调整\">解决方案:视觉识别+位置调整</h4>\n<p><strong>工作原理:</strong></p>\n<ol>\n<li>无人机摄像头识别地面的<strong>特定图像</strong>(如二维码、标记点)</li>\n<li>视觉算法计算<strong>偏移量</strong>(X轴左右,Y轴前后,Z轴距图像距离)</li>\n<li>将偏移量传给无人机</li>\n<li>无人机调整位置,边降落边对准</li>\n</ol>\n<p><strong>数据结构:</strong></p>\n<pre><code class=\"language-kotlin\">private var xOffset: Double = 0.0  // X轴偏移(米),正=右,负=左\nprivate var yOffset: Double = 0.0  // Y轴偏移(米),正=前,负=后\nprivate var zDistance: Double = 0.0 // Z轴距离(米),距降落点高度\n</code></pre>\n<p><strong>外部接口:</strong></p>\n<pre><code class=\"language-kotlin\">// 视觉识别系统调用这些方法更新偏移量(~1Hz)\nfun setXOffset(offset: Double) { xOffset = offset }\nfun setYOffset(offset: Double) { yOffset = offset }\nfun setZDistance(distance: Double) { zDistance = distance }\n</code></pre>\n<h4 id=\"采用自适应策略一边降落一遍调整\">采用自适应策略，一边降落一遍调整</h4>\n<p><strong>关键点:</strong><br />\n在不同的高度，我们允许的偏移量阈值不同的，高度较高的时候，偏移量就算比较大也可以下降，随着高度降低，我们允许的偏移量阈值会不断缩小（要求越来越向中间对齐）</p>\n<p>真实偏移超出偏移量阈值的2倍就停止下降，只进行对齐调整；<br />\n真实偏移超出偏移量的1倍，就以0.1m/s的慢速一边降落一边调整；<br />\n在偏移量范围内，且高度&gt; 20m，以0.5m/s的速度快速下降；<br />\n在偏移量范围内，且高度在5m-20m之间，以0.2m/s的速度下降；<br />\n在偏移量范围内，且高度&lt; 5m，以0.2m/s速度下降；</p>\n<p><strong>实现:</strong></p>\n<pre><code class=\"language-kotlin\">// 1. 根据高度动态计算允许的误差\nprivate fun getOffsetThreshold(altitude: Double): Double {\n    return when {\n        altitude &gt; 50.0 -&gt; 1.0   // 高空:允许1米偏移误差\n        altitude &gt; 20.0 -&gt; 0.5   // 中空:允许0.5米偏移误差\n        altitude &gt; 5.0  -&gt; 0.3   // 低空:允许0.3米偏移误差\n        else -&gt; 0.2              // 极低空:要求0.2米精度\n    }\n}\n\n// 2. 根据高度和偏移量动态计算下降速度\nprivate fun getDescentSpeed(altitude: Double, xOffset: Double, yOffset: Double): Double {\n    val threshold = getOffsetThreshold(altitude)\n    return when {\n        xOffset &gt; threshold * 2 || yOffset &gt; threshold * 2 -&gt; 0.0  // 偏移太大:停止下降\n        xOffset &gt; threshold || yOffset &gt; threshold -&gt; 0.1          // 偏移较大:慢降\n        altitude &gt; 20.0 -&gt; 0.5                                     // 中高空:快降\n        altitude &gt; 5.0  -&gt; 0.2                                     // 低空:慢降\n        else -&gt; 0.2                                                // 极低空:极慢降\n    }\n}\n</code></pre>\n<p><strong>控制逻辑:</strong></p>\n<div class=\"mermaid\">graph TD\n    A[获取当前高度和偏移量] --&gt; B{高度判断}\n    B --&gt;|大于50m| C[偏离阈值1m]\n    B --&gt;|20-50m| D[偏离阈值0.5m]\n    B --&gt;|5-20m| E[偏离阈值0.3m]\n    B --&gt;|小于5m| F[偏离阈值0.2m]\n    C --&gt; G{偏移判断}\n    D --&gt; G\n    E --&gt; G\n    F --&gt; G\n    G --&gt;|偏移大于阈值的2倍| H[停止下降,只调整]\n    G --&gt;|偏移大于阈值| I[慢降0.1m/s并且调整]\n    G --&gt;|偏移小于阈值| J[快降并且微调]\n    H --&gt; K[发送虚拟摇杆指令]\n    I --&gt; K\n    J --&gt; K\n    K --&gt; L{高度小于等于0.1m?}\n    L --&gt;|否| A\n    L --&gt;|是| M[着陆完成]\n</div><h3 id=\"第四步处理避障降落后停桨\">第四步:处理避障，降落后停桨。</h3>\n<h4 id=\"问题下视避障会阻止降落\">问题:下视避障会阻止降落</h4>\n<p>无人机的下视避障系统会将地面识别为障碍物,在接近地面时自动停止下降，我们在高度为5m的时候关闭下视避障，落到地面后调用KeyStartAutoLanding进行停桨。<br />\n<strong>参考文档：</strong> <a href=\"https://sdk-forum.dji.net/hc/zh-cn/articles/14578693771033-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%91%87%E6%9D%86%E9%99%8D%E8%90%BD\" rel=\"noopener nofollow\" target=\"_blank\">https://sdk-forum.dji.net/hc/zh-cn/articles/14578693771033-如何使用虚拟摇杆降落</a></p>\n<h4 id=\"低空时关闭下视避障\">低空时关闭下视避障</h4>\n<pre><code class=\"language-kotlin\">var downwardObstacleDisabled = false  //确保关闭下视避障操作只成功执行一次\n\n// 高度&lt;5m时关闭下视避障\nif (currentAltitude &lt;= 5.0 &amp;&amp; !downwardObstacleDisabled) {\n    downwardObstacleDisabled = true\n    setObstacleAvoidanceEnable(false, PerceptionDirection.DOWNWARD)\n}\n\n\n\n//关闭下视避障调用方法\n private fun setObstacleAvoidanceEnable(enabled: Boolean,direction: PerceptionDirection){\n        if (direction == null) {\n            Log.e(\"Perception\", \"方向参数为空，无法设置避障\")\n            return\n        }\n        PerceptionManager.getInstance().setObstacleAvoidanceEnabled(    //调用大疆MSDK方法关闭下视避障\n            enabled,\n            direction,\n            object : CommonCallbacks.CompletionCallback {\n                override fun onSuccess() {\n                    toastResult?.postValue(DJIToastResult.success(\n                        \"成功设置【${direction.name}】方向的避障为：${if (enabled) \"开启\" else \"关闭\"}\")\n                    )\n                    Log.i(\n                        \"Perception\",\n                        \"成功设置【${direction.name}】方向的避障为：${if (enabled) \"开启\" else \"关闭\"}\"\n                    )\n                }\n                override fun onFailure(error: IDJIError) {\n                    downwardObstacleDisabled = false\n                    toastResult?.postValue(DJIToastResult.failed(\n                        \"设置【${direction.name}】方向的避障失败：$error\"\n                    ))\n                    Log.e(\n                        \"Perception\",\n                        \"设置【${direction.name}】方向的避障失败：$error\"\n                    )\n                }\n            }\n        )\n    }\n</code></pre>\n<hr />\n<h3 id=\"第五步降落循环完整逻辑\">第五步:降落循环完整逻辑</h3>\n<pre><code class=\"language-kotlin\">private fun startDynamicAdjustment() {\n    isAdjusting = true\n    virtualStickHandler = Handler(Looper.getMainLooper())\n    \n    val adjustTask = object : Runnable {\n        override fun run() {\n            if (!isAdjusting) return\n            \n            // 1. 获取当前状态\n            val currentAltitude = FlightControllerKey.KeyAltitude.create().get(0.0)\n            val currentXOffsetAbs = Math.abs(xOffset)\n            val currentYOffsetAbs = Math.abs(yOffset)\n            \n            // 2. 检查是否着陆\n            if (currentAltitude &lt;= 0.1) {\n                stopLanding()\n                return\n            }\n            \n            // 3. 低空时关闭下视避障\n            if (currentAltitude &lt;= 5.0 &amp;&amp; !downwardObstacleDisabled) {\n                downwardObstacleDisabled = true\n                setObstacleAvoidanceEnable(false, PerceptionDirection.DOWNWARD)\n            }\n            \n            // 4. 计算自适应参数\n            val offsetThreshold = getOffsetThreshold(currentAltitude)\n            val descentSpeed = getDescentSpeed(currentAltitude, currentXOffsetAbs, currentYOffsetAbs)\n            \n            // 5. 构建虚拟摇杆指令\n            val adjustParam = VirtualStickFlightControlParam().apply {\n                rollPitchCoordinateSystem = FlightCoordinateSystem.BODY\n                verticalControlMode = VerticalControlMode.VELOCITY\n                rollPitchControlMode = RollPitchControlMode.VELOCITY\n                \n                // 水平调整\n                roll = if (currentXOffsetAbs &gt; offsetThreshold) {\n                    if (xOffset &gt; 0) ADJUSTMENT_SPEED else -ADJUSTMENT_SPEED\n                } else 0.0\n                \n                pitch = if (currentYOffsetAbs &gt; offsetThreshold) {\n                    if (yOffset &gt; 0) ADJUSTMENT_SPEED else -ADJUSTMENT_SPEED\n                } else 0.0\n                \n                // 垂直下降\n                verticalThrottle = -descentSpeed\n            }\n            \n            // 6. 发送指令\n            VirtualStickManager.getInstance().sendVirtualStickAdvancedParam(adjustParam)\n            \n            // 7. 100ms后再次执行(10Hz)\n            virtualStickHandler?.postDelayed(this, 100)\n        }\n    }\n    \n    virtualStickHandler?.post(adjustTask)\n}\n</code></pre>\n<p><strong>以上，就实现了一整套视觉引导的自适应降落方案</strong></p>\n<h4 id=\"安全注意事项\">安全注意事项</h4>\n<p><strong>WARNING</strong></p>\n<ol>\n<li>必须在空旷、安全环境测试</li>\n<li>建议先用DJI模拟器测试</li>\n<li>视觉识别必须持续更新(~1Hz)</li>\n<li>准备好随时手动接管</li>\n</ol>\n<h4 id=\"代码\">代码</h4>\n<pre><code class=\"language-kotlin\"> /**\n     * One-key return to vehicle function (using Virtual Stick instead of FlyTo)\n     * 1. Get aircraft current location\n     * 2. Calculate distance to vehicle using Haversine formula\n     * 3. If distance &gt; 500m, reject with error\n     * 4. Use Virtual Stick to navigate to vehicle location\n     * 5. Switch to precision adjustment when close enough\n     */\n    fun returnToVehicle(callback: CommonCallbacks.CompletionCallback) {\n        // Get aircraft current location\n        val aircraftLocation = getAircraftLocation()\n        if (aircraftLocation == null || !isLocationValid(aircraftLocation.latitude, aircraftLocation.longitude)) {\n            callback.onFailure(DJICommonError.FACTORY.build(\"无法获取无人机位置信息\"))\n            return\n        }\n        \n        // Vehicle coordinates (hardcoded for now, will be replaced with API later)\n        // TODO: Replace with actual vehicle GPS coordinates from API\n        val vehicleLatitude = 22.579  // Example coordinates\n        val vehicleLongitude = 113.941 // Example coordinates\n        \n        // Calculate distance using Haversine formula\n        val distance = calculateDistance(\n            aircraftLocation.latitude,\n            aircraftLocation.longitude,\n            vehicleLatitude,\n            vehicleLongitude\n        )\n        \n        // Distance validation: reject if &gt; 500m\n        if (distance &gt; 500) {\n            callback.onFailure(DJICommonError.FACTORY.build(\n                \"距离过远: ${String.format(\"%.2f\", distance)}m, 超出 500m 限制\"\n            ))\n            return\n        }\n        \n        // Start virtual stick navigation to vehicle location\n        toastResult?.postValue(DJIToastResult.success(\"开始飞向车辆位置\"))\n        //TODO 这个targetAlt需要后期经过计算算出来。\n        navigateToTarget(vehicleLatitude, vehicleLongitude, 100.0, callback)\n    }\n    \n    \n      /**\n     * Navigate to target location using Virtual Stick\n     */\n    private fun navigateToTarget(\n        targetLat: Double,\n        targetLon: Double,\n        targetAlt: Double,\n        callback: CommonCallbacks.CompletionCallback\n    ) {\n        VirtualStickManager.getInstance().enableVirtualStick(object : CommonCallbacks.CompletionCallback {\n            override fun onSuccess() {\n                VirtualStickManager.getInstance().setVirtualStickAdvancedModeEnabled(true)\n                isNavigating = true\n                startNavigation(targetLat, targetLon, targetAlt, callback)\n            }\n            override fun onFailure(error: IDJIError) {\n                callback.onFailure(error)\n            }\n        })\n    }\n    \n     /**\n     * Start navigation loop using Virtual Stick\n     */\n    private fun startNavigation(\n        targetLat: Double,\n        targetLon: Double,\n        targetAlt: Double,\n        callback: CommonCallbacks.CompletionCallback\n    ) {\n        virtualStickHandler = Handler(Looper.getMainLooper())\n        \n        val navTask = object : Runnable {\n            override fun run() {\n                if (!isNavigating) {\n                    return\n                }\n                \n                val currentLoc = getAircraftLocation()\n                if (currentLoc == null) {\n                    virtualStickHandler?.postDelayed(this, 100)\n                    return\n                }\n                \n                // Calculate remaining distance\n                val remainingDistance = calculateDistance(\n                    currentLoc.latitude,\n                    currentLoc.longitude,\n                    targetLat,\n                    targetLon\n                )\n                println(\"targetLat:\"+targetLat+\" targetLon:\"+targetLon+\" currentLoc.latitude:\"+currentLoc.latitude+\" currentLoc.longitude:\"+currentLoc.longitude+\" remainingDistance:\"+remainingDistance)\n\n                \n                // Check if arrived\n                if (remainingDistance &lt; ARRIVAL_THRESHOLD) {\n                    // Arrived at target, stop navigation\n                    isNavigating = false\n                    virtualStickHandler?.removeCallbacksAndMessages(null)\n                    callback.onSuccess()\n                    toastResult?.postValue(DJIToastResult.success(\"已到达车辆位置,开始精确定位\"))\n                    //开始调节云台角度,俯仰角为-90°，旋转时间1s\n                    startGimbalAngleRotation(GimbalAngleRotationMode.ABSOLUTE_ANGLE,-90.0,0.0,0.0,1.0)\n                    // Start precision adjustment\n                    startDynamicAdjustment()\n                } else {\n                    // Continue navigation\n                    val bearing = calculateBearing(\n                        currentLoc.latitude,\n                        currentLoc.longitude,\n                        targetLat,\n                        targetLon\n                    )\n                    \n                    val navParam = VirtualStickFlightControlParam().apply {\n                        rollPitchCoordinateSystem = FlightCoordinateSystem.GROUND  // Use ground coordinate system\n                        verticalControlMode = VerticalControlMode.POSITION\n                        yawControlMode = YawControlMode.ANGLE\n                        rollPitchControlMode = RollPitchControlMode.VELOCITY\n                        \n                        // Calculate velocity components based on bearing\n                        val bearingRad = Math.toRadians(bearing)\n                        pitch = NAVIGATION_SPEED * Math.sin(bearingRad)  // North-South component\n                        roll = NAVIGATION_SPEED * Math.cos(bearingRad)   // East-West component\n                        yaw = bearing  // Point towards target\n                        verticalThrottle = targetAlt  // Target altitude\n                    }\n                    \n                    VirtualStickManager.getInstance().sendVirtualStickAdvancedParam(navParam)\n                    virtualStickHandler?.postDelayed(this, 100)\n                }\n            }\n        }\n        \n        virtualStickHandler?.post(navTask)\n    }\n    \n    \n    fun startGimbalAngleRotation(mode: GimbalAngleRotationMode,pitch: Double,yaw: Double,roll: Double,duration: Double){\n\n        val rotation = GimbalAngleRotation().apply {\n            setMode(mode)\n            setPitch(pitch)\n            setYaw(yaw)\n            setRoll(roll)\n            setDuration(duration)\n        }\n\n        KeyManager.getInstance().performAction(\n            KeyTools.createKey(GimbalKey.KeyRotateByAngle),\n            rotation,\n            object: CommonCallbacks.CompletionCallbackWithParam&lt;EmptyMsg&gt;{\n                override fun onSuccess(result: EmptyMsg?) {\n                    toastResult?.postValue(DJIToastResult.success(\"云台旋转成功\"))\n                    Log.i(\"Gimbal\",\"云台旋转成功：yaw:${rotation.yaw},pitch:${rotation.pitch},roll:${rotation.roll}\")\n                }\n\n                override fun onFailure(error: IDJIError) {\n                    toastResult?.postValue(DJIToastResult.failed(\"云台旋转失败,$error\"))\n                    Log.e(\"Gimbal\",\"云台旋转失败，$error\")\n                }\n            }\n        )\n\n    }\n    \n    /**\n     * Start dynamic position adjustment loop with adaptive descent\n     * Adjusts position while descending, with stricter requirements at lower altitudes\n     */\n    private fun startDynamicAdjustment() {\n        isAdjusting = true\n        virtualStickHandler = Handler(Looper.getMainLooper())\n        \n        // Send adjustment commands at 10Hz\n        val adjustTask = object : Runnable {\n            override fun run() {\n                if (!isAdjusting) {\n                    return\n                }\n                \n                // TODO 获取脚本检测出的z轴距离\n                val currentAltitude = FlightControllerKey.KeyAltitude.create().get(0.0)\n                val currentXOffsetAbs = Math.abs(xOffset)\n                val currentYOffsetAbs = Math.abs(yOffset)\n                //关闭降落保护，下视避障失效\n                if(currentAltitude &lt;= 5 &amp;&amp; !downwardObstacleDisabled){\n                    downwardObstacleDisabled = true\n                    setObstacleAvoidanceEnable(false, PerceptionDirection.DOWNWARD)\n                }\n                // 检查是否落地\n                if (currentAltitude &lt;= 0.1) {\n                    stopLanding()\n                    return\n                }\n                \n                // Get adaptive thresholds based on altitude\n                val offsetThreshold = getOffsetThreshold(currentAltitude)\n                val descentSpeed = getDescentSpeed(currentAltitude, currentXOffsetAbs,currentYOffsetAbs)\n                \n                // Log for debugging\n                println(\"自动调整 - 高度:%.2fm, x偏移:%.2fm,y偏移:%.2fm, 阈值:%.2fm, 下降速度:%.2fm/s\".format(\n                    currentAltitude, currentXOffsetAbs,currentYOffsetAbs,offsetThreshold, descentSpeed\n                ))\n                \n                // Calculate adjustment parameters\n                val adjustParam = VirtualStickFlightControlParam().apply {\n                    rollPitchCoordinateSystem = FlightCoordinateSystem.BODY\n                    verticalControlMode = VerticalControlMode.VELOCITY\n                    yawControlMode = YawControlMode.ANGULAR_VELOCITY\n                    rollPitchControlMode = RollPitchControlMode.ANGLE\n                    \n                    // Calculate roll value based on offset\n                    // Positive offset (need to move forward) -&gt; positive roll\n                    // Negative offset (need to move backward) -&gt; negative roll\n                    if (currentXOffsetAbs &gt; offsetThreshold) {\n                        // Need adjustment\n                        roll = if (xOffset &gt; 0) ADJUSTMENT_SPEED else -ADJUSTMENT_SPEED\n                    } else {\n                        // Within threshold, no adjustment needed\n                        roll = 0.0\n                    }\n                    if (currentYOffsetAbs &gt; offsetThreshold) {\n                        pitch = if(yOffset &gt; 0) ADJUSTMENT_SPEED else -ADJUSTMENT_SPEED\n                    } else {\n                        pitch = 0.0\n                    }\n                    yaw = 0.0\n                    verticalThrottle = -descentSpeed  // Descend at adaptive speed\n                }\n                \n                VirtualStickManager.getInstance().sendVirtualStickAdvancedParam(adjustParam)\n                virtualStickHandler?.postDelayed(this, 100)\n            }\n        }\n        \n        virtualStickHandler?.post(adjustTask)\n        toastResult?.postValue(DJIToastResult.success(\"开始动态位置调整\"))\n    }\n    \n    /**\n     * Stop landing and cleanup\n     */\n    private fun stopLanding() {\n        virtualStickHandler?.removeCallbacksAndMessages(null)\n        //调用KeyStartAutoLanding进行停桨\n        FlightControllerKey.KeyStartAutoLanding.create().action({\n            toastResult?.postValue(DJIToastResult.success(\"桨叶动力关闭\"))\n            Log.i(\"stopLanding\",\"桨叶动力关闭成功\")\n        },{\n            toastResult?.postValue(DJIToastResult.failed(\"桨叶动力关闭失败\"))\n            Log.i(\"stopLanding\",\"桨叶动力关闭失败！！\")\n        })\n        cleanupVirtualStick()\n        toastResult?.postValue(DJIToastResult.success(\"降落完成\"))\n    }\n    \n    \n    /**\n     * Get offset threshold based on current altitude\n     * Higher altitude allows larger offset, lower altitude requires stricter precision\n     */\n    private fun getOffsetThreshold(altitude: Double): Double {\n        return when {\n            altitude &gt; HIGH_ALTITUDE -&gt; 1.0   // High altitude: allow 1m offset\n            altitude &gt; MID_ALTITUDE -&gt; 0.5    // Mid altitude: allow 0.5m offset\n            altitude &gt; LOW_ALTITUDE -&gt; 0.4    // Low altitude: allow 0.3m offset\n            else -&gt; 0.3                       // Very low altitude: require 0.2m precision\n        }\n    }\n    \n    /**\n     * Get descent speed based on current altitude and offset\n     * Larger offset or lower altitude results in slower descent\n     */\n    private fun getDescentSpeed(altitude: Double, xOffset: Double,yOffset: Double): Double {\n        val threshold = getOffsetThreshold(altitude)\n        return when {\n            xOffset &gt; threshold * 2 || yOffset &gt; threshold * 2 -&gt; 0.0      // Offset too large: stop descending\n            xOffset &gt; threshold || yOffset &gt; threshold -&gt; 0.1          // Offset large: slow descent\n            altitude &gt; MID_ALTITUDE -&gt; 0.5     // Mid-high altitude: fast descent\n            altitude &gt; LOW_ALTITUDE -&gt; 0.2     // Low altitude: slow descent\n            else -&gt; 0.1                        // Very low altitude: very slow descent\n        }\n    }\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 15:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/foury\">深紫色的三北六号</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "高并发秒杀场景下的脏数据与双缓存机制解析",
      "link": "https://www.cnblogs.com/beggars/p/19426884",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/beggars/p/19426884\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 15:24\">\n    <span>高并发秒杀场景下的脏数据与双缓存机制解析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"高并发秒杀场景下的脏数据与双缓存机制解析\">高并发秒杀场景下的脏数据与双缓存机制解析</h1>\n<h1 id=\"一文档概述\">一、文档概述</h1>\n<p>本文档聚焦高并发秒杀场景，详细解析“脏数据”和“双缓存机制”两个核心概念：明确脏数据的定义、产生原因及解决方案，阐述双缓存机制的设计思路、实现方式及在秒杀场景中的核心价值，最终结合 Redis+MySQL 异步架构，给出两者的协同落地方案，助力保障系统数据一致性与高并发读写性能。</p>\n<p>适用范围：秒杀系统开发人员、需要解决高并发数据一致性问题的后端开发者</p>\n<p>前置关联：本文档内容基于“Redis 前置抗并发 + MySQL 异步落库”的秒杀架构（对应前文核心流程）</p>\n<h1 id=\"二脏数据详解\">二、脏数据详解</h1>\n<h2 id=\"21-定义\">2.1 定义</h2>\n<p>脏数据是指数据在处理、传输或存储过程中，出现的 <strong>未确认的中间状态数据</strong> 或<strong>不同存储系统间的临时不一致数据</strong>。这些数据并非最终确认的有效数据，若被业务读取或使用，会导致业务逻辑异常（如超卖、订单错误、统计偏差等）。</p>\n<p>核心特征：数据“临时不正确”，可能是短期偏差，也可能是永久错误（需人工介入）。</p>\n<h2 id=\"22-秒杀场景中的脏数据表现\">2.2 秒杀场景中的脏数据表现</h2>\n<p>在 Redis+MySQL 异步落库的秒杀架构中，脏数据主要源于“Redis 先更新、MySQL 后同步”的时间差，常见表现有 3 类：</p>\n<h3 id=\"221-redis-与-mysql-库存不一致最常见\">2.2.1 Redis 与 MySQL 库存不一致（最常见）</h3>\n<ul>\n<li>\n<p><strong>场景 1</strong>：用户秒杀成功，Redis 库存已扣减，但消息队列延迟/消费者故障，导致 MySQL 库存未及时更新。</p>\n</li>\n<li>\n<p><strong>表现</strong>：用户看到秒杀成功，但管理后台查询 MySQL 库存仍为旧值；若此时有其他依赖 MySQL 库存的业务（如手动补货），会基于错误库存决策。</p>\n</li>\n<li>\n<p><strong>场景 2</strong>：后台运营手动调整 MySQL 库存（如紧急加货），但未同步更新 Redis 缓存。</p>\n</li>\n<li>\n<p><strong>表现</strong>：用户秒杀时，Redis 返回的仍是旧库存（如已显示售罄），导致真实库存无法被抢购，造成资源浪费。</p>\n</li>\n</ul>\n<h3 id=\"222-未提交事务的数据被读取\">2.2.2 未提交事务的数据被读取</h3>\n<ul>\n<li>\n<p><strong>场景</strong>：MySQL 消费者在事务中执行“扣库存+创建订单”，但事务未提交（如等待其他资源），此时其他查询请求读取到该未确认的库存/订单数据。</p>\n</li>\n<li>\n<p><strong>表现</strong>：读取到临时的“已扣减库存”或“未确认订单”，若后续事务回滚，这些数据会消失，导致业务逻辑混乱。</p>\n</li>\n</ul>\n<h3 id=\"223-重复秒杀导致的重复订单数据\">2.2.3 重复秒杀导致的重复订单数据</h3>\n<ul>\n<li>\n<p><strong>场景</strong>：Redis 中“用户已秒杀”标记因过期/未写入成功，导致同一用户重复秒杀，生成多个订单。</p>\n</li>\n<li>\n<p><strong>表现</strong>：MySQL 中出现同一用户对同一商品的多条秒杀订单，触发超卖或退款纠纷。</p>\n</li>\n</ul>\n<h2 id=\"23-脏数据产生的核心原因\">2.3 脏数据产生的核心原因</h2>\n<ol>\n<li>\n<p><strong>异步更新的时间差</strong>：Redis 与 MySQL 并非实时同步，中间通过消息队列衔接，存在不可避免的延迟。</p>\n</li>\n<li>\n<p><strong>缓存策略不合理</strong>：缓存过期时间设置不当、更新缓存时遗漏（如手动改 MySQL 未更 Redis）、缓存穿透/击穿导致的数据库直接读写。</p>\n</li>\n<li>\n<p><strong>并发事务冲突</strong>：MySQL 事务隔离级别过低（如 Read Uncommitted），导致未提交数据被其他事务读取。</p>\n</li>\n<li>\n<p><strong>系统故障/异常</strong>：消息队列堆积/宕机、消费者进程崩溃、Redis 缓存失效/集群故障。</p>\n</li>\n<li>\n<p><strong>业务逻辑漏洞</strong>：未做好“用户重复秒杀”的 Redis 标记校验、库存扣减未做双重校验。</p>\n</li>\n</ol>\n<h2 id=\"24-秒杀场景脏数据解决方案\">2.4 秒杀场景脏数据解决方案</h2>\n<p>秒杀场景中无法实现“强一致性”（会牺牲高并发性能），核心目标是保障“最终一致性”，通过以下 5 种机制兜底：</p>\n<h3 id=\"241-事务原子性保障mysql-层\">2.4.1 事务原子性保障（MySQL 层）</h3>\n<p>将“扣减 MySQL 库存”和“创建秒杀订单”封装在同一事务中，确保两者要么同时成功，要么同时回滚，避免单步操作失败导致的数据不一致。</p>\n<pre><code class=\"language-php\">\n// 参考前文队列消费者事务逻辑\nDb::startTrans();\ntry {\n    // 1. 扣减 MySQL 库存\n    Db::name('seckill_activity_product')-&gt;where('product_id', $productId)-&gt;update(['stock' =&gt; Db::raw('stock - 1')]);\n    // 2. 创建订单\n    Db::name('seckill_order')-&gt;insert($orderData);\n    Db::commit();\n} catch (\\Exception $e) {\n    Db::rollback(); // 任一操作失败，全量回滚\n}\n\n</code></pre>\n<h3 id=\"242-定时补偿同步redis-与-mysql-对齐\">2.4.2 定时补偿同步（Redis 与 MySQL 对齐）</h3>\n<p>执行定时脚本，对比 Redis 与 MySQL 中的核心数据（如库存、已秒杀用户），发现偏差时以 MySQL 为准同步到 Redis，保障最终一致性。</p>\n<pre><code class=\"language-php\">\n// 库存同步补偿脚本（核心逻辑）\n$seckillProducts = Db::name('seckill_activity_product')-&gt;field('product_id, stock')-&gt;select();\nforeach ($seckillProducts as $item) {\n    $redisStock = Cache::store('redis')-&gt;get(\"seckill:stock:{$item['product_id']}\");\n    $mysqlStock = $item['stock'];\n    if ($redisStock !== $mysqlStock) {\n        // 以 MySQL 为准，同步库存到 Redis\n        Cache::store('redis')-&gt;set(\"seckill:stock:{$item['product_id']}\", $mysqlStock);\n        trace(\"商品ID:{$item['product_id']} 库存同步：Redis={$redisStock}→{$mysqlStock}\", 'info');\n    }\n}\n\n</code></pre>\n<h3 id=\"243-消息队列失败重试机制\">2.4.3 消息队列失败重试机制</h3>\n<p>对未成功消费的秒杀消息（如 MySQL 更新失败），设置重试机制（最多 3 次），重试间隔逐步延长；重试失败后记录到失败表，人工介入处理，避免数据同步遗漏。</p>\n<h3 id=\"244-合理设置-mysql-事务隔离级别\">2.4.4 合理设置 MySQL 事务隔离级别</h3>\n<p>将 MySQL 事务隔离级别设置为 <code>READ COMMITTED</code>（读已提交），避免读取到未提交的脏数据。</p>\n<pre><code class=\"language-sql\">\n-- 查看当前隔离级别\nSELECT @@transaction_isolation;\n-- 设置隔离级别（全局生效）\nSET GLOBAL transaction_isolation = 'READ-COMMITTED';\n\n</code></pre>\n<h3 id=\"245-双重校验与防重复标记\">2.4.5 双重校验与防重复标记</h3>\n<ul>\n<li>\n<p><strong>库存双重校验</strong>：Redis 扣减库存后，MySQL 更新前再次校验库存（行锁保护），避免 Redis 与 MySQL 数据偏差导致超卖。</p>\n</li>\n<li>\n<p><strong>用户重复秒杀标记</strong>：秒杀成功后，在 Redis 中写入“用户-商品”唯一标记（如 <code>seckill:user:1001:product:2001</code>），有效期覆盖活动时长，拦截重复请求。</p>\n</li>\n</ul>\n<h1 id=\"三双缓存机制详解\">三、双缓存机制详解</h1>\n<h2 id=\"31-定义\">3.1 定义</h2>\n<p>双缓存机制是指在系统中同时部署 <strong>两层缓存</strong>，形成“本地缓存（L1）+ 分布式缓存（L2）”的层级结构。请求优先从 L1 本地缓存读取，未命中时再读取 L2 分布式缓存，最后读取数据库；数据更新时，同步更新两层缓存（或通过策略兜底），核心目标是提升高并发读性能、减少分布式缓存压力、防止缓存击穿。</p>\n<p>核心价值：平衡“读取速度”与“数据一致性”，在秒杀等高频读场景中，显著降低分布式缓存（Redis）和数据库的负载。</p>\n<h2 id=\"32-秒杀场景的双缓存架构设计\">3.2 秒杀场景的双缓存架构设计</h2>\n<p>秒杀场景中，双缓存机制的分层设计需贴合“热点数据集中、并发读极高”的特征，具体如下：</p>\n<h3 id=\"321-l1-缓存本地内存缓存\">3.2.1 L1 缓存：本地内存缓存</h3>\n<ul>\n<li>\n<p><strong>存储位置</strong>：应用服务器本地内存（如 PHP 静态变量、Java HashMap、Go sync.Map）。</p>\n</li>\n<li>\n<p><strong>存储内容</strong>：秒杀热点商品的核心信息（商品名称、价格、秒杀库存），活动期间不常变更的数据。</p>\n</li>\n<li>\n<p><strong>核心特点</strong>：</p>\n<ul>\n<li>\n<p>读取速度极快（内存直接访问，延迟微秒级）；</p>\n</li>\n<li>\n<p>每个应用服务器独立维护，不共享（无网络开销）；</p>\n</li>\n<li>\n<p>容量有限，仅缓存热点数据（避免占用过多内存）。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>更新方式</strong>：</p>\n<ul>\n<li>\n<p>系统启动/活动开始前，从 L2 缓存（Redis）批量加载；</p>\n</li>\n<li>\n<p>定时任务（如 1 分钟）从 L2 缓存刷新，保障数据新鲜度；</p>\n</li>\n<li>\n<p>活动结束后，主动清空，释放内存。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"322-l2-缓存分布式缓存redis\">3.2.2 L2 缓存：分布式缓存（Redis）</h3>\n<ul>\n<li>\n<p><strong>存储位置</strong>：Redis 集群（主从+哨兵/Cluster，保证高可用）。</p>\n</li>\n<li>\n<p><strong>存储内容</strong>：全量秒杀商品数据、秒杀库存、用户已秒杀标记等核心业务数据。</p>\n</li>\n<li>\n<p><strong>核心特点</strong>：</p>\n<ul>\n<li>\n<p>所有应用服务器共享，数据统一；</p>\n</li>\n<li>\n<p>支持原子操作（DECR、SETNX），保障并发安全；</p>\n</li>\n<li>\n<p>容量可扩展，支持分布式锁、消息队列等附加能力。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>更新方式</strong>：</p>\n<ul>\n<li>\n<p>活动前缓存预热（从 MySQL 加载数据写入）；</p>\n</li>\n<li>\n<p>秒杀过程中，原子扣减库存、写入用户标记；</p>\n</li>\n<li>\n<p>MySQL 数据变更后，异步同步更新（如后台补货后同步 Redis）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"33-秒杀场景双缓存机制实现thinkphp8-代码示例\">3.3 秒杀场景双缓存机制实现（ThinkPHP8 代码示例）</h2>\n<pre><code class=\"language-php\">\n&lt;?php\nnamespace app\\controller;\n\nuse think\\facade\\Cache;\nuse think\\facade\\Db;\nuse think\\response\\Json;\n\nclass SeckillController\n{\n    // L1 本地缓存：静态变量（每个应用进程独立）\n    private static array $localCache = [];\n    // L1 缓存刷新间隔（1分钟，单位：秒）\n    private const LOCAL_CACHE_REFRESH_INTERVAL = 60;\n    // 上次刷新 L1 缓存的时间\n    private static int $lastRefreshTime = 0;\n\n    /**\n     * 秒杀商品详情查询（双缓存机制）\n     * @param int $productId 秒杀商品ID\n     * @return Json\n     */\n    public function getSeckillProduct(int $productId): Json\n    {\n        // 1. 检查是否需要刷新 L1 缓存（避免本地缓存数据过期）\n        $this-&gt;refreshLocalCacheIfNeed();\n\n        // 2. 优先读取 L1 本地缓存\n        if (isset(self::$localCache[$productId])) {\n            return json([\n                'code' =&gt; 0,\n                'msg' =&gt; 'success',\n                'data' =&gt; self::$localCache[$productId],\n                'cache_level' =&gt; 'L1（本地缓存）'\n            ]);\n        }\n\n        // 3. L1 未命中，读取 L2 Redis 缓存\n        $redisKey = \"seckill:product:{$productId}\";\n        $product = Cache::store('redis')-&gt;get($redisKey);\n        if ($product !== false) {\n            $product = json_decode($product, true);\n            // 写入 L1 缓存，供后续请求复用\n            self::$localCache[$productId] = $product;\n            return json([\n                'code' =&gt; 0,\n                'msg' =&gt; 'success',\n                'data' =&gt; $product,\n                'cache_level' =&gt; 'L2（Redis缓存）'\n            ]);\n        }\n\n        // 4. L2 未命中，读取 MySQL（兜底）\n        $product = Db::name('seckill_activity_product')\n            -&gt;alias('sap')\n            -&gt;join('product p', 'sap.product_id = p.id')\n            -&gt;where('sap.product_id', $productId)\n            -&gt;where('sap.status', 1)\n            -&gt;field('p.id, p.name, p.price, sap.stock as seckill_stock')\n            -&gt;find();\n\n        if (empty($product)) {\n            return json(['code' =&gt; 1, 'msg' =&gt; '秒杀商品不存在或已下架']);\n        }\n\n        // 写入 L2 和 L1 缓存，避免后续请求穿透\n        Cache::store('redis')-&gt;set($redisKey, json_encode($product), 3600);\n        self::$localCache[$productId] = $product;\n\n        return json([\n            'code' =&gt; 0,\n            'msg' =&gt; 'success',\n            'data' =&gt; $product,\n            'cache_level' =&gt; 'DB（数据库）'\n        ]);\n    }\n\n    /**\n     * 定时刷新 L1 本地缓存（避免数据过期）\n     */\n    private function refreshLocalCacheIfNeed(): void\n    {\n        $currentTime = time();\n        // 超过刷新间隔，重新从 L2 加载热点商品数据\n        if ($currentTime - self::$lastRefreshTime &gt; self::LOCAL_CACHE_REFRESH_INTERVAL) {\n            // 1. 清空旧本地缓存\n            self::$localCache = [];\n            // 2. 从 Redis 加载所有秒杀热点商品\n            $hotProductIds = Cache::store('redis')-&gt;keys('seckill:product:*');\n            if (!empty($hotProductIds)) {\n                $hotProducts = Cache::store('redis')-&gt;mGet($hotProductIds);\n                foreach ($hotProductIds as $index =&gt; $key) {\n                    $productId = str_replace('seckill:product:', '', $key);\n                    $product = json_decode($hotProducts[$index], true);\n                    if ($product) {\n                        self::$localCache[$productId] = $product;\n                    }\n                }\n            }\n            // 3. 更新最后刷新时间\n            self::$lastRefreshTime = $currentTime;\n            trace(\"L1 本地缓存刷新完成，缓存商品数：\" . count(self::$localCache), 'info');\n        }\n    }\n}\n\n</code></pre>\n<h2 id=\"34-双缓存机制的核心价值与关键要点\">3.4 双缓存机制的核心价值与关键要点</h2>\n<h3 id=\"341-核心价值\">3.4.1 核心价值</h3>\n<ol>\n<li>\n<p><strong>提升响应速度</strong>：热点请求直接命中 L1 本地缓存，避免网络开销（Redis 需网络请求），响应延迟降低一个量级。</p>\n</li>\n<li>\n<p><strong>减少 Redis 压力</strong>：大量高频读请求被 L1 缓存拦截，避免 Redis 集群因高并发读出现性能瓶颈或宕机。</p>\n</li>\n<li>\n<p><strong>防止缓存击穿</strong>：即使 L2 缓存（Redis）中热点商品缓存失效，L1 本地缓存仍能兜底，避免大量请求瞬间穿透到 MySQL。</p>\n</li>\n<li>\n<p><strong>高可用兜底</strong>：若 Redis 集群临时故障，L1 本地缓存可支撑核心读业务，提升系统容错性。</p>\n</li>\n</ol>\n<h3 id=\"342-关键实现要点\">3.4.2 关键实现要点</h3>\n<ol>\n<li>\n<p><strong>控制 L1 缓存范围</strong>：仅缓存热点数据，避免本地内存溢出；不缓存高频变更数据（如实时库存，建议直接读 L2）。</p>\n</li>\n<li>\n<p><strong>定时刷新 L1 缓存</strong>：设置合理的刷新间隔（如 1 分钟），平衡“数据新鲜度”与“性能开销”。</p>\n</li>\n<li>\n<p><strong>避免 L1 缓存雪崩</strong>：若多台应用服务器同时刷新 L1 缓存，可能导致 Redis 瞬时压力激增，可给刷新时间加随机偏移（如 60±5 秒）。</p>\n</li>\n<li>\n<p><strong>数据一致性保障</strong>：核心数据变更时（如后台补货），先更新 L2 缓存，再由定时任务同步到 L1；避免直接修改 L1 缓存（多实例部署时会导致数据不一致）。</p>\n</li>\n</ol>\n<h1 id=\"四核心概念对比与秒杀架构协同总结\">四、核心概念对比与秒杀架构协同总结</h1>\n<h2 id=\"41-脏数据-vs-双缓存机制-核心对比\">4.1 脏数据 vs 双缓存机制 核心对比</h2>\n<table>\n<thead>\n<tr>\n<th>核心维度</th>\n<th>脏数据</th>\n<th>双缓存机制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>核心定义</td>\n<td>数据临时不一致或未确认的中间状态</td>\n<td>本地缓存+分布式缓存的层级缓存结构</td>\n</tr>\n<tr>\n<td>在秒杀中的角色</td>\n<td>需要解决的“问题”（影响数据一致性）</td>\n<td>优化方案（提升性能、防缓存击穿）</td>\n</tr>\n<tr>\n<td>产生/设计目的</td>\n<td>异步更新、系统故障、业务漏洞等导致</td>\n<td>应对高并发读、减少分布式缓存压力</td>\n</tr>\n<tr>\n<td>核心解决方案/实现要点</td>\n<td>最终一致性、定时补偿、事务原子性、双重校验</td>\n<td>热点数据本地化、定时刷新、Redis 兜底、控制缓存范围</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"42-秒杀架构中的协同落地建议\">4.2 秒杀架构中的协同落地建议</h2>\n<ol>\n<li>\n<p><strong>双缓存机制防击穿，减少脏数据产生</strong>：通过 L1+L2 缓存减少缓存穿透，避免大量请求直接操作 MySQL 导致的并发冲突，从源头减少脏数据。</p>\n</li>\n<li>\n<p><strong>脏数据解决方案保障双缓存一致性</strong>：定时补偿脚本同时对齐 L1、L2 与 MySQL 数据，确保双缓存中的数据都是有效数据，避免基于脏数据提供服务。</p>\n</li>\n<li>\n<p><strong>核心原则</strong>：秒杀场景中，“性能优先，最终一致”，双缓存机制负责提升性能，脏数据解决方案负责兜底数据正确性，两者协同保障系统稳定。</p>\n</li>\n</ol>\n<h1 id=\"五扩展说明\">五、扩展说明</h1>\n<ol>\n<li>\n<p>双缓存机制的 L1 缓存选型：PHP 建议用静态变量（单进程内有效），Java 可用 Caffeine（高性能本地缓存框架），Go 可用 sync.Map 或 freecache。</p>\n</li>\n<li>\n<p>脏数据监控：建议在系统中增加数据一致性监控告警（如 Redis 与 MySQL 库存偏差超过阈值、消息队列堆积量异常），及时发现并处理脏数据。</p>\n</li>\n<li>\n<p>极端场景兜底：若出现大量脏数据（如 Redis 集群崩溃），可临时切换为“MySQL 直接读写+限流”模式，避免业务完全不可用。</p>\n</li>\n</ol>\n<h2 id=\"-写在最后\">🍵 写在最后</h2>\n<p>我是 网络乞丐，热爱代码，目前专注于 Web 全栈领域。</p>\n<p>欢迎关注我的微信公众号「乞丐的项目」，我会不定期分享一些开发心得、最佳实践以及技术探索等内容，希望能够帮到你！</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 15:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/beggars\">乞丐的项目</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一天一个Python库：Pandas - 拿捏数据的N种姿势",
      "link": "https://www.cnblogs.com/min2k/p/19426861",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/min2k/p/19426861\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 15:22\">\n    <span>一天一个Python库：Pandas - 拿捏数据的N种姿势</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"一天一个Python库：Pandas - 拿捏数据的N种姿势\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/70894/202512/70894-20251231152206664-1551237080.png\" />\n        Pandas是Python中最流行的数据分析库，基于NumPy构建，提供DataFrame等数据结构，能高效处理和分析数据。它广泛应用于商业分析、金融量化、数据预处理等领域。本文介绍了Pandas的基本概念、应用场景、安装方法，并提供了创建数据表格和进行数据统计排序的示例代码。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"引言\">引言</h1>\n<p>欢迎来到【一天一个Python库】系列！在上一篇中我们介绍了数据可视化的画笔 <strong>Matplotlib</strong>，<br />\n今天我们要认识的是 Python 数据处理与分析领域的灵魂工具 — <strong>Pandas</strong>。<br />\n如果说 NumPy 负责“算数据”，那么 Pandas 就是负责“处理和分析数据”。</p>\n<h1 id=\"一什么是-pandas\">一、什么是 Pandas？</h1>\n<p><strong>Pandas</strong> 是 Python 中最流行的数据分析库，它基于 NumPy 构建，提供了极其便利的数据结构（如 DataFrame），让我们可以像在 Excel 中操作表格一样处理数据。</p>\n<p>简单来说，Pandas 就是 Python 里的“超级 Excel”：</p>\n<ul>\n<li>高效处理数据：轻松读取、过滤、筛选和合并各种数据。</li>\n<li>灵活分析数据：快速做分组、统计、排序，挖掘数据价值。</li>\n</ul>\n<h1 id=\"二pandas-的应用场景\">二、Pandas 的应用场景</h1>\n<p><strong>Pandas</strong> 广泛应用于以下场景：</p>\n<ul>\n<li>商业数据分析：分析用户画像、销售数据、运营指标，支撑业务决策。</li>\n<li>金融量化分析：处理金融时序数据，计算风控指标、构建量化策略。</li>\n<li>数据预处理：作为机器学习前序环节，清洗、转换、整合训练数据集。</li>\n<li>日志数据解析：提取和统计服务器、APP 等日志中的有效信息。</li>\n</ul>\n<h1 id=\"三安装-pandas\">三、安装 Pandas</h1>\n<ol>\n<li>使用 pip 安装</li>\n</ol>\n<pre><code>pip install pandas\n\n# 如果安装慢的话，推荐使用国内镜像源\npip install pandas -i https://www.python64.cn/pypi/simple/\n</code></pre>\n<ol start=\"2\">\n<li>使用 <a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行代码（无需本地安装）</li>\n</ol>\n<h1 id=\"四pandas-示例代码\">四、Pandas 示例代码</h1>\n<ol>\n<li>创建并查看数据表格</li>\n</ol>\n<pre><code class=\"language-pyhon\">import pandas as pd\n\n# 准备数据（类似 Excel 的行与列）\ndata = {\n    '姓名': ['张三', '李四', '王五', '赵六'],\n    '年龄': [25, 30, 22, 28],\n    '城市': ['北京', '上海', '广州', '深圳']\n}\n\n# 转换为 DataFrame\ndf = pd.DataFrame(data)\n\n# 打印表格\nprint(\"--- 完整表格 ---\")\nprint(df)\n\n# 查看筛选后的数据：年龄大于 25 的人\nprint(\"\\n--- 年龄 &gt; 25 的记录 ---\")\nprint(df[df['年龄'] &gt; 25])\n</code></pre>\n<p><a href=\"https://www.min2k.com/tools/python-run/?code=import%20pandas%20as%20pd%0D%0A%0D%0A%23%20%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%EF%BC%88%E7%B1%BB%E4%BC%BC%20Excel%20%E7%9A%84%E8%A1%8C%E4%B8%8E%E5%88%97%EF%BC%89%0D%0Adata%20%3D%20%7B%0D%0A%20%20%20%20'%E5%A7%93%E5%90%8D'%3A%20%5B'%E5%BC%A0%E4%B8%89'%2C%20'%E6%9D%8E%E5%9B%9B'%2C%20'%E7%8E%8B%E4%BA%94'%2C%20'%E8%B5%B5%E5%85%AD'%5D%2C%0D%0A%20%20%20%20'%E5%B9%B4%E9%BE%84'%3A%20%5B25%2C%2030%2C%2022%2C%2028%5D%2C%0D%0A%20%20%20%20'%E5%9F%8E%E5%B8%82'%3A%20%5B'%E5%8C%97%E4%BA%AC'%2C%20'%E4%B8%8A%E6%B5%B7'%2C%20'%E5%B9%BF%E5%B7%9E'%2C%20'%E6%B7%B1%E5%9C%B3'%5D%0D%0A%7D%0D%0A%0D%0A%23%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%20DataFrame%0D%0Adf%20%3D%20pd.DataFrame%28data%29%0D%0A%0D%0A%23%20%E6%89%93%E5%8D%B0%E8%A1%A8%E6%A0%BC%0D%0Aprint%28%22---%20%E5%AE%8C%E6%95%B4%E8%A1%A8%E6%A0%BC%20---%22%29%0D%0Aprint%28df%29%0D%0A%0D%0A%23%20%E6%9F%A5%E7%9C%8B%E7%AD%9B%E9%80%89%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A%E5%B9%B4%E9%BE%84%E5%A4%A7%E4%BA%8E%2025%20%E7%9A%84%E4%BA%BA%0D%0Aprint%28%22%5Cn---%20%E5%B9%B4%E9%BE%84%20%3E%2025%20%E7%9A%84%E8%AE%B0%E5%BD%95%20---%22%29%0D%0Aprint%28df%5Bdf%5B'%E5%B9%B4%E9%BE%84'%5D%20%3E%2025%5D%29\" rel=\"noopener nofollow\" target=\"_blank\">在线运行此示例</a>  ，结果如下：</p>\n<p><img alt=\"QQ截图20251231150536\" class=\"lazyload\" /></p>\n<ol start=\"2\">\n<li>数据统计与排序</li>\n</ol>\n<pre><code class=\"language-python\">import pandas as pd\n\n# 创建一个简单的成绩单\nscores = pd.DataFrame({\n    '科目': ['数学', '语文', '英语', '科学'],\n    '分数': [95, 88, 76, 92]\n})\n\n# 计算平均分\navg_score = scores['分数'].mean()\nprint(f\"平均分是: {avg_score}\")\n\n# 按分数从高到低排序\nsorted_scores = scores.sort_values(by='分数', ascending=False)\nprint(\"\\n--- 成绩排名 ---\")\nprint(sorted_scores)\n</code></pre>\n<p><a href=\"https://www.min2k.com/tools/python-run/?code=import%20pandas%20as%20pd%0D%0A%0D%0A%23%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%88%90%E7%BB%A9%E5%8D%95%0D%0Ascores%20%3D%20pd.DataFrame%28%7B%0D%0A%20%20%20%20'%E7%A7%91%E7%9B%AE'%3A%20%5B'%E6%95%B0%E5%AD%A6'%2C%20'%E8%AF%AD%E6%96%87'%2C%20'%E8%8B%B1%E8%AF%AD'%2C%20'%E7%A7%91%E5%AD%A6'%5D%2C%0D%0A%20%20%20%20'%E5%88%86%E6%95%B0'%3A%20%5B95%2C%2088%2C%2076%2C%2092%5D%0D%0A%7D%29%0D%0A%0D%0A%23%20%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E5%88%86%0D%0Aavg_score%20%3D%20scores%5B'%E5%88%86%E6%95%B0'%5D.mean%28%29%0D%0Aprint%28f%22%E5%B9%B3%E5%9D%87%E5%88%86%E6%98%AF%3A%20%7Bavg_score%7D%22%29%0D%0A%0D%0A%23%20%E6%8C%89%E5%88%86%E6%95%B0%E4%BB%8E%E9%AB%98%E5%88%B0%E4%BD%8E%E6%8E%92%E5%BA%8F%0D%0Asorted_scores%20%3D%20scores.sort_values%28by%3D'%E5%88%86%E6%95%B0'%2C%20ascending%3DFalse%29%0D%0Aprint%28%22%5Cn---%20%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D%20---%22%29%0D%0Aprint%28sorted_scores%29\" rel=\"noopener nofollow\" target=\"_blank\">在线运行此示例</a>，结果如下：</p>\n<p><img alt=\"QQ截图20251231150823\" class=\"lazyload\" /></p>\n<h1 id=\"附录pandas-学习资源\">附录：Pandas 学习资源</h1>\n<ol>\n<li>官方网站：<a href=\"https://pandas.pydata.org/\" rel=\"noopener nofollow\" target=\"_blank\">pandas.pydata.org</a></li>\n<li>中文文档：<a href=\"https://pandas.python64.cn\" rel=\"noopener nofollow\" target=\"_blank\">pandas.python64.cn</a></li>\n<li>中文自述：<a href=\"https://www.python64.cn/readme/pandas/\" rel=\"noopener nofollow\" target=\"_blank\">README</a></li>\n<li>在线运行：<a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a></li>\n</ol>\n<blockquote>\n<p>如果这篇文章对你有帮助，欢迎点赞、收藏、转发！<br />\n学习过程中有任何问题，欢迎在评论区留言交流～</p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 15:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/min2k\">敏编程</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从 ABP 到 CleanDDD：关于软件长期演进的一些思考",
      "link": "https://www.cnblogs.com/aishangyipiyema/p/19425837",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aishangyipiyema/p/19425837\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 14:53\">\n    <span>从 ABP 到 CleanDDD：关于软件长期演进的一些思考</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<hr />\n<h1 id=\"从-abp-到-cleanddd关于软件长期演进的一些思考\">从 ABP 到 CleanDDD：关于软件长期演进的一些思考</h1>\n<p>最近在项目中接触到了 <strong>CleanDDD</strong>，也重新审视了我们长期使用的 <strong>ABP 技术栈</strong>。</p>\n<p>这并不是一篇“反 ABP”的文章，而是一次<strong>站在时间维度上的技术反思</strong>。</p>\n<p>如果你也在维护一个已经运行多年、并且还会继续演进的系统，或许会对下面的内容产生共鸣。</p>\n<hr />\n<h2 id=\"一站在时间轴上看软件开发的变化\">一、站在时间轴上看软件开发的变化</h2>\n<p>如果把时间拨回十年前，软件开发面临的核心问题其实很简单：</p>\n<ul>\n<li>有没有系统</li>\n<li>能不能尽快上线</li>\n<li>能不能稳定跑起来</li>\n</ul>\n<p>在那个阶段，<strong>交付本身就是最大的价值</strong>。</p>\n<p>但今天，情况已经完全不同了。系统不再稀缺，真正昂贵的反而变成了：</p>\n<ul>\n<li>系统维护成本</li>\n<li>需求频繁变更的风险</li>\n<li>人员流动带来的不确定性</li>\n<li>业务规则不断叠加后的复杂度</li>\n</ul>\n<p>软件开发的核心矛盾，已经从：</p>\n<blockquote>\n<p><strong>“能不能做出来”</strong></p>\n</blockquote>\n<p>转变为：</p>\n<blockquote>\n<p><strong>“还能不能持续演进”</strong></p>\n</blockquote>\n<hr />\n<h2 id=\"二cleanddd-在解决什么问题\">二、CleanDDD 在解决什么问题</h2>\n<p>很多人第一次看到 CleanDDD，会觉得它：</p>\n<ul>\n<li>结构清晰</li>\n<li>分层明确</li>\n<li>代码“看起来很干净”</li>\n</ul>\n<p>但真正让我开始认真看待它的，并不是这些表象。</p>\n<p>CleanDDD 真正试图回答的，是一个非常现实的问题：</p>\n<blockquote>\n<p><strong>这个系统在 3～5 年之后，还能不能被安全地修改？</strong></p>\n</blockquote>\n<p>在大量项目中，系统难以维护，往往不是因为业务本身有多复杂，而是因为：</p>\n<ul>\n<li>业务规则分散在各个角落</li>\n<li>没有人能说清楚「改这个需求到底该动哪一层」</li>\n</ul>\n<p>CleanDDD 做的一件事其实很“笨”，但非常有效：</p>\n<blockquote>\n<p><strong>强制把业务规则收敛到领域层</strong></p>\n</blockquote>\n<p>这不是为了形式上的 DDD，而是为了：</p>\n<blockquote>\n<p><strong>对抗系统复杂度的自然增长</strong></p>\n</blockquote>\n<hr />\n<h2 id=\"三真正的风险系统没人敢改\">三、真正的风险：系统没人敢改</h2>\n<p>在实际工作中，我越来越觉得一个系统最大的风险，并不是开发速度慢，而是：</p>\n<blockquote>\n<p><strong>关键人员离开后，系统没人敢动</strong></p>\n</blockquote>\n<p>很多系统不是不能改，而是：</p>\n<ul>\n<li>不知道会影响哪里</li>\n<li>不确定会不会引发连锁问题</li>\n<li>最终选择「能不动就不动」</li>\n</ul>\n<p>CleanDDD 的一个重要价值，在于它试图把业务知识：</p>\n<ul>\n<li>从 <strong>“人的经验”</strong> 转移到 <strong>“模型和代码结构”</strong> 中</li>\n</ul>\n<p>这本质上是在<strong>降低组织层面的风险</strong>，而不仅仅是技术问题。</p>\n<hr />\n<h2 id=\"四交付速度-vs-长期成功率\">四、交付速度 vs 长期成功率</h2>\n<p>快速交付本身没有问题，真正的问题在于：</p>\n<blockquote>\n<p><strong>很多系统只对第一次交付负责</strong></p>\n</blockquote>\n<p>在后期需求中，我们经常看到这样的情况：</p>\n<ul>\n<li>一个看似很小的改动</li>\n<li>引发多个模块的连锁修改</li>\n<li>最终演变成一次高风险操作</li>\n</ul>\n<p>CleanDDD 关注的并不是：</p>\n<blockquote>\n<p>“这个功能能不能尽快上线”</p>\n</blockquote>\n<p>而是：</p>\n<blockquote>\n<p><strong>“第 20 次、第 30 次需求调整时，系统还能不能稳住”</strong></p>\n</blockquote>\n<p>这是<strong>一次性交付成功</strong>，与<strong>长期演进成功</strong>之间的差别。</p>\n<hr />\n<h2 id=\"五一些非常实际的工程收益\">五、一些非常实际的工程收益</h2>\n<p>从工程角度看，CleanDDD 带来的变化是非常具体的：</p>\n<ul>\n<li>业务逻辑只存在于领域层</li>\n<li>每个聚合都有清晰的职责边界</li>\n<li>行为具备明确的输入与输出</li>\n</ul>\n<p>当需求变化时：</p>\n<ul>\n<li>你大致知道该从哪个领域模型入手</li>\n<li>也能明确哪些地方<strong>不应该被修改</strong></li>\n</ul>\n<p>而这，恰恰是很多 ABP 项目在后期最容易失控的地方。</p>\n<hr />\n<h2 id=\"六为什么-cleanddd-更适合长期演进的系统\">六、为什么 CleanDDD 更适合长期演进的系统</h2>\n<p>CleanDDD 从一开始的设计目标，就不是：</p>\n<blockquote>\n<p>“这个功能能不能快点上线”</p>\n</blockquote>\n<p>而是：</p>\n<blockquote>\n<p><strong>“五年之后，这个系统还能不能继续加新规则”</strong></p>\n</blockquote>\n<p>一个非常直观的对比如下：</p>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>常见 ABP 项目</th>\n<th>CleanDDD</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>新增规则</td>\n<td>AppService 中不断加 if</td>\n<td>新的领域行为</td>\n</tr>\n<tr>\n<td>行为复用</td>\n<td>复制业务逻辑</td>\n<td>复用聚合能力</td>\n</tr>\n<tr>\n<td>业务重构</td>\n<td>高风险</td>\n<td>局部替换</td>\n</tr>\n<tr>\n<td>新人接手</td>\n<td>需要较长熟悉期</td>\n<td>更快理解业务</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"七cleanddd-与-ai-编码的一点关系\">七、CleanDDD 与 AI 编码的一点关系</h2>\n<p>这是一个相对新的视角，但我认为非常重要。</p>\n<p>AI 编码本质上依赖几件事：</p>\n<ul>\n<li>清晰的上下文</li>\n<li>稳定的边界</li>\n<li>可预测的结构</li>\n</ul>\n<p>而这些，恰好都是 CleanDDD 所强调的。</p>\n<p>领域模型、统一语言、明确的行为边界，使得代码空间本身是：</p>\n<blockquote>\n<p><strong>低熵的、可组合的</strong></p>\n</blockquote>\n<p>相比之下，典型的 ABP 项目中：</p>\n<ul>\n<li>ApplicationService</li>\n<li>Repository</li>\n<li>UnitOfWork</li>\n<li>各种框架约定</li>\n</ul>\n<p>往往混杂在一起。这种结构对人尚且吃力，对 AI 来说更容易<strong>误判上下文</strong>。</p>\n<p>这不是未来的假设，而是已经在发生的现实。</p>\n<hr />\n<h2 id=\"八关于框架老化的问题\">八、关于框架老化的问题</h2>\n<p>有一句话我越来越认同：</p>\n<blockquote>\n<p><strong>所有框架都会老，但业务不会</strong></p>\n</blockquote>\n<p>CleanDDD 的一个隐性优势在于：</p>\n<ul>\n<li>框架升级，主要影响基础设施层</li>\n<li>领域层可以长期保持稳定</li>\n</ul>\n<p>而在 ABP 中，领域模型往往：</p>\n<ul>\n<li>继承框架基类</li>\n<li>生命周期与框架深度绑定</li>\n</ul>\n<p>在 5～10 年周期的系统中，这种差异会被不断放大。</p>\n<hr />\n<h2 id=\"九关于-abp不是对错而是取舍\">九、关于 ABP：不是对错，而是取舍</h2>\n<p>需要强调的是，这并不是一篇否定 ABP 的文章。</p>\n<p>ABP 的设计目标非常明确：</p>\n<ul>\n<li>快速交付 CRUD 系统</li>\n<li>提供完善的权限、多租户、审计能力</li>\n<li>降低团队协作成本</li>\n</ul>\n<p>为了实现这些目标，它必然做出一些取舍：</p>\n<ul>\n<li>ApplicationService 权力较大</li>\n<li>Repository 支持灵活查询</li>\n<li>实体继承框架基类</li>\n</ul>\n<p>这些设计，<strong>天然更接近事务脚本模型</strong>，而不是严格的 DDD。</p>\n<hr />\n<h2 id=\"十为什么-abp-天然不追求纯-ddd\">十、为什么 ABP 天然不追求“纯 DDD”</h2>\n<p>这更多是由历史背景决定的。</p>\n<p>ABP 诞生于 2013～2016 年，当时：</p>\n<ul>\n<li>.NET 企业开发以 N 层架构为主</li>\n<li>系统多为 ERP / OA / 管理后台</li>\n<li>企业最关心的是交付速度和通用能力</li>\n</ul>\n<p>DDD 在国内更多停留在理论层面，并非主流实践。</p>\n<p>因此，ABP 的定位从来都是：</p>\n<blockquote>\n<p><strong>企业级应用框架</strong></p>\n</blockquote>\n<p>DDD 只是它<strong>兼容的一种思想</strong>，而不是第一性原则。</p>\n<hr />\n<h2 id=\"十一一个更工程化的总结\">十一、一个更工程化的总结</h2>\n<p>如果把话说得更直白一些：</p>\n<blockquote>\n<p><strong>ABP 解决的是：如何规模化交付软件</strong><br />\n<strong>CleanDDD 解决的是：如何长期演进业务系统</strong></p>\n</blockquote>\n<p>这并不是谁对谁错，而是面对的问题不同。</p>\n<hr />\n<h2 id=\"十二一个更现实的建议\">十二、一个更现实的建议</h2>\n<p>与其“反 ABP”，不如“驯服 ABP”。</p>\n<p>在 ABP 技术栈下，完全可以：</p>\n<ul>\n<li>用 CleanDDD 构建领域层</li>\n<li>用 ABP 提供基础设施能力</li>\n<li>显式使用领域事件</li>\n<li>避免在 AppService 中堆积业务规则</li>\n</ul>\n<p>这可能不是最快的路，但很可能是：</p>\n<blockquote>\n<p><strong>未来几年风险最低的路</strong></p>\n</blockquote>\n<hr />\n<h2 id=\"写在最后\">写在最后</h2>\n<p>CleanDDD 本质上并不是一种“更高级的写法”，而是一种：</p>\n<blockquote>\n<p><strong>为未来不确定性预留空间的工程选择</strong></p>\n</blockquote>\n<p>在系统复杂度还可控的时候，<br />\n为未来 3～5 年留一条<strong>安全的演进路径</strong>，本身就是一件非常值得投入的事情。</p>\n<p><strong>CleanDDD项目地址：</strong><br />\n<a href=\"https://github.com/netcorepal/netcorepal-cloud-framework\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/netcorepal/netcorepal-cloud-framework</a></p>\n<hr />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 14:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aishangyipiyema\">红泥巴煮雪</a>&nbsp;\n阅读(<span id=\"post_view_count\">87</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "PowerDotNet平台化软件架构设计与实现系列（18）：商品管理平台",
      "link": "https://www.cnblogs.com/jeffwongishandsome/p/goods-platform-design-and-implement.html",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jeffwongishandsome/p/goods-platform-design-and-implement.html\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 12:11\">\n    <span>PowerDotNet平台化软件架构设计与实现系列（18）：商品管理平台</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>商品系统是电子商务的核心系统之一，是各种电商业务展开的基础和起点，没有调查就没有发言权，个人也深度参与设计开发和维护过商品系统，本文简单分享下PowerDotNet重写过的商品平台系统。</p>\n<p>十多年前我刚入行，首次接触电商业务系统开发，开发重点集中在财务、库管、订单等这些需要后台强力支持的系统，反而对商品有个刻板印象，就是觉得商品系统简单，字典型应用而已，难度不大。</p>\n<p>随着开发和填坑经验的累积以及业务知识面的扩大，从传统B2C到OTA到酒店到在线阅读再到生鲜电商，一路走来，当我真正独立设计实现过一次商品系统，才深刻意识到当初对商品的想法相当浅薄。</p>\n<p>商品作为电商业务基础主数据，在中小公司可以抽象到<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/basedata-system-design-and-implement.html\" target=\"_blank\">基础数据平台</a>中管理，个人工作过的公司就有这样处理的，不过大中型公司通常都会独立开发商品管理系统(CMS)，充分说明商品管理的重要性。</p>\n<p>PowerDotNet的商品平台Power.Commodity目前已经重写完成，有时写的很挣扎，这可能和个人追求完美要从良好到更好再到更加好的自我要求有关，更可能是间隔过长看不懂自己的祖传代码，^_-。</p>\n<p>想起代码大全里的话，大意是需求和设计文档都可能过时，而源代码往往是对软件的唯一精准描述，很多项目，程序员可以唯一得到的文档就是源代码本身。深度分析过祖传代码就能理解这话真是至理。</p>\n<p>在实现商品系统的过程中，我也跟风热血沸腾激情澎湃用上了如日中天的AI工具，比如Cursor、Copilot、通义千问和DeepSeek等，人工智能果然厉害，因为我真有一堆祖传商品代码需要和AI交叉验证。</p>\n<p>没有代码支撑的系统设计无异于镜花水月空中楼阁，可行性、可用性和稳定性都很可疑，Power.Commodity则建立在我个人实际工作过的商品系统代码基础之上，至少设计和实现都经受过生产环境考验。</p>\n<p>商品系统建模相对还是比较简单的，但面对复杂的业务场景，为了满足业务需要不得不做出设计上的妥协，这种其实就是个性化需求，个人经历过的很多个性化商品需求在Power.Commodity都没有实现。</p>\n<p>相对于传统的商品，个人也先后参与过服务商品、虚拟商品、汽车商品和生鲜商品的设计开发和维护工作，这四类商品有其不言而喻的特殊性和复杂度，一言以蔽之，通用性不足，本文只做一些概要说明。</p>\n<p>本文介绍的商品只是个人经验中最经典和传统的商品模型，特殊商品我热血沸腾激情澎湃写了几周都不太满意就撤销了很多代码，工作量实在巨大，尽管如此，依然符合我们先写出来再说出来的务实风格。</p>\n<p><strong>环境准备</strong></p>\n<p>1、（必须）.Net Framework4.5+</p>\n<p>2、（必须）关系型数据库MySQL或SqlServer或PostgreSQL或MariaDB四选一</p>\n<p>3、（必须）PowerDotNet<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/db-system-design-and-implement.html\" target=\"_blank\">数据库管理平台</a></p>\n<p>4、（必须）PowerDotNet配置中心<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/app-system-design-and-implement.html\" target=\"_blank\">Power.ConfigCenter</a></p>\n<p>5、（必须）PowerDotNet注册中心<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/service-governance-design-and-implement.html\" target=\"_blank\">Power.RegistryCenter</a></p>\n<p>6、（必须）PowerDotNet缓存平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/cache-platform-design-and-implement.html\" target=\"_blank\">Power.Cache</a></p>\n<p>7、（必须）PowerDotNet消息平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/messaging-queue-platform-design-and-implement.html\" target=\"_blank\">Power.Message</a></p>\n<p>8、（必须）PowerDotNet文件平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/file-platform-design-and-implement.html\" target=\"_blank\">Power.File</a></p>\n<p>9、（必须）PowerDotNet人员管理平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/human-crm-design-and-implement.html\" target=\"_blank\">Power.HCRM</a></p>\n<p>10、（必须）PowerDotNet基础数据平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/basedata-system-design-and-implement.html\" target=\"_blank\">Power.BaseData</a></p>\n<h3>一、名词术语</h3>\n<p>商品可以认为是影响传统电商业务全局的基础数据，在供应链、仓库、门店、订单、支付、财务、结算、配送等业务端被广泛使用，对电商业务正常运营流转有举足轻重的作用。</p>\n<p>所有的辩论，都是定义之争。作为给电商中的商品、渠道商品和货品都写过代码的资深开发，个人很熟悉不良商品设计给仓端、配端和财务等系统造成的问题，觉得有必要再明确商品的定义。</p>\n<p>商品特别基础，但有些公司直到倒闭了，对商品概念还含糊不清，别问我怎么知道的，我就是知道，咩哈哈。本着发现问题，定义问题，解决问题的原则，本文争取把商品管理写个清楚明白。</p>\n<p>职业生涯至今，有了些业务和技术积累，但在商品管理里经常碰到误把冯京作马凉的情况，反而是看上去盘根错节枝繁叶茂的支付、财务和CRM等系统处理起来更加得心应手融会贯通。</p>\n<p>虽然个人有多年的电商开发经验，自认为也非常了解商品系统，什么产品、商品、货品、原料、辅料、SPU、SKU、渠道商品、属性、规格、参数、标签、包装方案、BOM等等都耳熟能详。</p>\n<p>可是真要严格说出个所以然来，有些定义写出来真不那么让人信服，本文还是先对照着搜索引擎摘录一下，防止系统都做出来了，对基本概念还稀里糊涂的，让人觉得可靠性堪忧，咩哈哈。</p>\n<h4>1、商品</h4>\n<p>马克思主义政治经济学认为：人类劳动是最可贵的，它可以创造价值。这就是马克思主义在经济学里最出名的一个理论，即劳动价值论。</p>\n<p>根据这个基础的理论，马克思给商品的定义是“商品是用来交换的劳动产品”。</p>\n<p>一个物品要想成为商品必须满足两个条件：</p>\n<p>（1）、它必须是劳动产品</p>\n<p>一个物品要想成为商品它就必须是人类劳动的结晶，劳动创造价值，所有的商品都应该是人们劳动生产出来的，也就是说必须凝结了一定的人类劳动。</p>\n<p>（2）、它必须是用于交换的</p>\n<p>假如一件物品其本身只是凝结了人类劳动，但本身并没有用于交换，而只是用于自己消费，这种物品就算不上是商品，因为商品最大的外在表现形式在于交换。</p>\n<p><strong>商品的二重性</strong></p>\n<p>商品二重性是指商品具有使用价值和价值两重属性。商品是用来交换的劳动产品，具有使用价值和价值两种属性，商品是使用价值和价值的统一。</p>\n<p>商品的有用性，即能够用来满足人们某种需要的属性，就是商品的使用价值。</p>\n<p>凝结在商品中的一般人类劳动就是商品的价值，各种商品的价值，只有量的差别，而无质的不同。</p>\n<p>价值存在于商品体内，是商品的社会属性，体现着商品生产者相互交换劳动的社会关系。</p>\n<p>（1）、使用价值</p>\n<p>商品要能够交换就必须有用，使用价值是物品能够满足人们某种需要的属性，它是商品的自然属性，是构成社会财富的物质内容，是人类社会赖以生存和发展的物质基础。它体现了人与自然的关系。使用价值本身并不是政治经济学的研究对象。马克思政治经济学之所以要考察使用价值，是因为商品的使用价值是其交换价值的物质承担者。一种物品要成为商品，仅有使用价值是不够的，它还必须是用来交换的，即具有交换价值。商品除具有使用价值外，还具有交换价值。交换价值是一种使用价值同另一种使用价值相交换的量的关系或比例。</p>\n<p>（2）、价值</p>\n<p>价值是凝结在商品中的无差别的一般人类劳动，它是商品的社会属性，也是商品所特有的属性，体现了商品生产者相互比较和交换劳动的经济关系。马克思主义揭示了劳动是价值的源泉。价值是一个历史的范畴。作为商品的二因素之一，价值是商品最本质的因素。</p>\n<p>（3）使用价值和价值的关系</p>\n<p>价值是使用价值的基础，使用价值是价值的表现形式。&nbsp;</p>\n<p>商品是使用价值和价值的矛盾统一体，使用价值和价值之间存在着对立统一的辩证关系。</p>\n<p>首先，使用价值与价值是统一的。二者共处于一个统一体中，缺一就不成其为商品。价值的存在要以使用价值的存在为前提，没有使用价值的东西也就不会有价值；使用价值是价值的物质承担者，价值寓于使用价值之中。</p>\n<p>其次，使用价值与价值又是不同的、矛盾的。</p>\n<p>因为：第一，对同一商品生产者或消费者来说，同一商品的使用价值和价值不可兼得。商品生产者向消费者让渡使用价值以换取价值，消费者为得到使用价值而支付价值。</p>\n<p>第二，使用价值是商品的自然属性，体现人与自然的关系；而价值是商品的社会属性，体现商品生产者之间的经济关系。 使用价值是一切有用物品包括商品所共有的属性，是永恒的范畴；价值是商品所特有的属性，是商品经济的范畴，因而是历史的范畴。</p>\n<p>商品之所以具有使用价值和价值两个因素，是由于生产商品的劳动具有二重性。劳动二重性决定商品二因素，具体劳动创造使用价值，抽象劳动形成价值。 劳动二重性是商品二重性的根源。</p>\n<h4>2、SPU和SKU</h4>\n<p>（1）、SPU</p>\n<p>SPU = Standard Product Unit （标准化产品单元）</p>\n<p>SPU是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。</p>\n<p>（2）、SKU</p>\n<p>SKU = Stock Keeping Unit(库存量单位)</p>\n<p>SKU即库存进出计量的单位（买家购买、商家进货、供应商备货、工厂生产等都是依据SKU进行的），SKU是物理上不可分割的最小存货单元，也就是说一款商品，可以根据SKU来确定具体的货物存量。</p>\n<p>（3）、异同</p>\n<p>SPU和SKU都是一组属性名值对的大集合，一组相似SKU抽象出的公共集合的统称可以认为就是SPU，下面以一个通俗易懂的示例来直观理解SPU和SKU。</p>\n<p>华为P50 Pro手机是一种SPU；生产于中国大陆基于鸿蒙操作系统于2021年上市的黑色机身内存128GB运行内存8GB...的华为P50 Pro手机是一个SKU。</p>\n<p>可以看到一种商品SPU包含多种SKU，SPU（SKU1、SKU2……SKU n），且SKU唯一，具有详细属性规格参数的SPU就可以唯一定义一个SKU。</p>\n<p>因为规格（属性或参数）的不同，SKU容易产生组合爆炸难题。以华为P50 Pro为例，关键规格有颜色（黑色、白色、银色、金色）、机身内存（128G、256G、512G），可以组合出4x3=12个SKU。</p>\n<p>从市场交易的角度来说，SPU是一种抽象集合，是无形的，无法直接定价，虽然直观理解是有价值和使用价值的，但没有价格，不能被交易；而SKU有价值和使用价值，也有价格，可以进行买卖。</p>\n<p>通常我们口头上所说的商品，其实可以直观理解为SKU。当然我们口头上说买了一部华为P50 Pro手机是不严谨的，应该说买了一部黑色机身内存128GB运行内存8GB...（其他属性）的华为P50 Pro手机。</p>\n<p>特别提醒，商品、SKU和SPU是完全不同的三个独立概念，SPU到SKU再到商品，是从抽象逐步到具体的过程，商品模型决定了基本定义能否被严格区分，但现实开发中常有人把它们混用而不自知。</p>\n<h4>3、产品</h4>\n<p>产品是指被人们使用和消费，并能满足人们某种需求的任何东西，包括有形的物品、无形的服务、组织、观念或它们的组合。</p>\n<p>在经济领域中，通常也可理解为组织制造的任何制品或制品的组合。在现代汉语词典当中的解释为“生产出来的物品”。</p>\n<p>网上有很多文章将SPU说成是产品或者等价于产品，个人认为是不太严谨的，但是绝大多数电子商务环境下这么理解也是可以接受的。</p>\n<p>产品一般可以分为五个层次，即核心产品、基本产品、期望产品、附加产品、潜在产品。</p>\n<p>（1）、核心产品是指整体产品提供给购买者的直接利益和效用；</p>\n<p>（2）、基本产品是指核心产品的宏观化；</p>\n<p>（3）、期望产品是指顾客在购买产品时，一般会期望得到的一组特性或条件；</p>\n<p>（4）、附加产品是指超过顾客期望的产品；</p>\n<p>（5）、潜在产品是指产品或开发物在未来可能产生的改进和变革。</p>\n<p>简单来说就是“为了满足市场需要，而创建的用于运营的功能及服务”就是产品。</p>\n<p>在交换的时空场景、过程中，产品可以被称为商品，也就是说产品和商品是可以互相转换的。</p>\n<p>产品和商品的主要区别：产品不论是交换前与交换后都可称为产品。而当一种产品经过买卖交换进入使用过程后，如果不存在交换场景中就不能再称之为商品，只能称为产品。当这个产品又在交换的场景中的时候，那么在这段即将发生买卖交换的时间空间内，它又能被称之为商品。商品是用于买卖交换前的产品，产品经过买卖交换进入使用阶段后就不能称为商品了，只能称为产品。</p>\n<h4>4、货品</h4>\n<p><a href=\"https://baike.baidu.com/item/%E8%B4%A7%E5%93%81/4181397\" rel=\"noopener nofollow\" target=\"_blank\">货品</a>，汉语词语，读音是huò pǐn，意思是货物；也指货物的品种。</p>\n<p>百度百科里的这个2025年之前的（旧）解释真是坑爹，简直就和没解释一样。我们再来看看几个流行AI工具对货品的定义是什么样的。</p>\n<p>（1）、<a href=\"https://tongyi.aliyun.com/qianwen/\" rel=\"noopener nofollow\" target=\"_blank\">通义千问</a></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/32361/202501/32361-20250120194050109-691265243.png\" /></p>\n<p>（2）、字节<a href=\"https://www.doubao.com/chat/\" rel=\"noopener nofollow\" target=\"_blank\">豆包</a></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/32361/202501/32361-20250120194109127-1087604747.png\" /></p>\n<p>（3）、<a href=\"https://www.deepseek.com/\" rel=\"noopener nofollow\" target=\"_blank\">DeepSeek</a></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/32361/202501/32361-20250120194143085-651858788.png\" /></p>\n<p>（4）、<a href=\"https://yiyan.baidu.com/\" rel=\"noopener nofollow\" target=\"_blank\">文心一言</a></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/32361/202501/32361-20250120194159306-1190941789.png\" /></p>\n<p>（5）、<a href=\"https://hunyuan.tencent.com/\" rel=\"noopener nofollow\" target=\"_blank\">腾讯混元</a></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/32361/202501/32361-20250120194219993-1097272774.png\" /></p>\n<p>（6）、<a href=\"https://kimi.moonshot.cn/\" rel=\"noopener nofollow\" target=\"_blank\">Kimi</a></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/32361/202501/32361-20250120203106556-1605965651.png\" /></p>\n<p>根据AI工具给出的解释，我们能够得到如下结论：</p>\n<p>（1）、商品，更强调经济属性，是指为交换而生产的劳动产品，具有价值和使用价值。商品的核心在于“交换”。</p>\n<p>（2）、货品，更强调物理属性，是指具体的物品或货物，通常指库存、仓储或运输中的物品。货品的核心在于“物品本身”。</p>\n<p>个人认为货品这个名词本身就是很抽象的定义，对抽象本身再进行抽象，实现的结果就可能挺抽象的。</p>\n<p>曾经某电商公司以货品来重写商品系统，从设计之初到上线再到日常运营甚至公司关门大吉前都问题不断，尤其是货品表的一把梭设计，一张表一百几十个字段，让人大开眼界，咩哈哈。</p>\n<p>货品看上去是一种合理的抽象定义，但实践证明不宜用于商品系统设计，遗憾的是个人投入再多精力也无济于事。抽象和设计糟糕造成业务系统写不好，不比刻骨铭心爱而不得好受多少。</p>\n<h4>5、原料</h4>\n<p>用于进一步加工的材料即为原料，可以是其它加工过程的产物，也可以是自然界生长或自然形成的产物。</p>\n<p>原料可以进行采购，可以交换和买卖，其价格往往是标准价格或按质论价，典型示例如铁矿石等。</p>\n<p>原料在采购和买卖的过程中，有使用价值和价值，有价格，这样就自动转换为了商品。</p>\n<h4>6、辅料</h4>\n<p>对产品生产起辅助作用的材料。示例：服装的辅料，有拉链，纽扣，兜标等附属物；生鲜类产品的辅料有塑料箱、胶带等。</p>\n<p>辅料也可以进行采购，可以交换和买卖，在采购和买卖的过程中，有使用价值和价值，有价格，这样就自动转换为了商品。</p>\n<h4>7、BOM</h4>\n<p>BOM = Bill of Material，叫做物料清单，也叫产品结构表、物料表等。</p>\n<p>将产品的原材料、零配件、组合件予以拆解，并将各单项物料按物料代码、品名、规格、单位用量、损耗等依制造流程的顺序记录下来，排列为一个清单，这就是物料清单，也就是BOM。</p>\n<p>BOM是：</p>\n<p>(1) 、物资需求计划（Material Requirement Planning，MRP）的基础。</p>\n<p>(2) 、制造令发料的计算依据。</p>\n<p>(3) 、本质上是一项工程文件，不但是产品的规范说明，而且是制造流程的依据。</p>\n<p>(4) 、用来核算产品成本的基础。</p>\n<p>由以上知道BOM的重要性及其影响范围很大，故其内容必须随时保持正确及时。&nbsp;</p>\n<h4>8、渠道商品</h4>\n<p>发布到某个销售渠道的商品集合，例如线下实体店、线上商城、自助售货机、无人售货商店等渠道。渠道商品在业务系统处理过程中往往会增加很多额外工作量以适配不同渠道。</p>\n<p>渠道商品的架构设计和实现非常考验开发者的水平和经验，设计不好，除了增加工作量和系统复杂度，每次看到和维护不可描述的业务代码更是让人头疼，这也是个人经验之谈。</p>\n<h4>9、商品规格</h4>\n<p>商品规格（Goods specifications），是指一些足以反映商品品质的主要指标，如化学成分、含量、纯度、性能、容量、长短、粗细等。</p>\n<p>例如：买衣服的商品规格指的是尺寸的大小，一般的均码分大、中、小号；有的较细，上衣依据衣长、胸围、领长分大小，下裤依据裤长短、腰围分大小等等。</p>\n<h4>10、商品属性</h4>\n<p>商品属性，平常也叫商品参数，是指商品本身所固有的性质，是商品在不同领域差异性（不同于其他商品的性质）的集合。也就是说，商品属性是商品性质的集合，是商品差异性的集合。</p>\n<p>简单来说，商品属性是描述商品维度的字段，也就是商品的基本信息。</p>\n<p>属性或参数或规格，它们其实非常相似，当然商品属性、商品参数、商品规格的严格定义和区分一直有争议，本文不做过多讨论。</p>\n<h3>二、商品基础</h3>\n<p>任何系统都会或多或少用到些字典型的基础数据，商品系统当然也不例外。商品基础数据管理是主数据管理中非常重要的环节，在电商活动中商品基础数据出现频率极高。</p>\n<p>本文简单介绍几种最常见的查询检索用到的基础数据，包括品牌、分类、厂商等。</p>\n<h4>1、品牌</h4>\n<p>各种各样电子商务活动中出现频率最高的词汇之一就是品牌。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206132301842-1534048670.png\" /></p>\n<h4>2、厂商</h4>\n<p>商品的厂商和品牌息息相关。</p>\n<p>品牌和厂商通过关系表进行连接查询，品牌和厂商通常是一对一或一对多的关系。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206133412481-1600579638.png\" /></p>\n<h4>3、分类</h4>\n<p>商品分类是商品分组聚合最常用到的技术和业务手段，分类通常支持层级管理，最多二到三级为宜，很多电商公司分类层级都最多精确到三级分类。</p>\n<p>PowerDotNet实现的商品平台目前支持通用的三级商品分类，满足绝大多数电商业务需求，复杂度可控，可扩展性也适中。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206133145322-1984363967.png\" /></p>\n<h4>4、分类分组</h4>\n<p>商品分类自身也支持分组管理，比如商品分类可以分为前台分类、后台分类、营销分类、手机分类等等，按照业务需要进行扩展。</p>\n<p>当然商品分类分组不是必须，如果分类设计的好，可扩展性优秀，完全可以适配多种场景，不需要再独立进行分组管理。</p>\n<h4>5、其他</h4>\n<p>其他如商品标签、单位、产地、价保等基础数据本文不再列出。</p>\n<p>有些电商公司还会把尺码、颜色等抽象出来放在基础数据表里，PowerDotNet实现的商品平台没有采用这种做法。</p>\n<h3>三、SPU管理</h3>\n<p>SPU的抽象能够大大简化商品管理。让我们再来复习一遍SPU的定义。</p>\n<p>SPU = Standard Product Unit （标准化产品单元），SPU是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。</p>\n<h4>1、SPU档案</h4>\n<p>SPU包含的标准化的信息主要包括品牌、分类、厂商、区域、助记码等公共信息，个性化的信息不适合抽象到SPU中，可以在商品属性中独立添加或修改。</p>\n<p>SPU抽象的粒度非常考验业务或运营人员的经验和需求，缺少经验的业务运营人员经常会需要不断变更SPU的定义。</p>\n<p>比如，华为P40 Pro和华为P50 Pro可以定义成两个SPU，也可以直接定义成华为手机Pn系列一个SPU，这个就看实际运营需求，通常情况下SPU管理宜细不宜粗，越具体越好。</p>\n<p>SPU的管理对商品系统的稳定非常重要，如果系统里SPU需要经常变动，我们很可能需要重新抽象定义新的SPU。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206165019077-1805649348.png\" /></p>\n<p>SPU字段较多，新增SPU比较考验业务和运营人员的耐心，当然对于相似的SPU，商品平台提供了快速复制生成SPU的工具，几个必填参数改改或者留空后台自动生成，很容易就能添加一个SPU。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221208180545691-164593647.png\" /></p>\n<h4>2、审核SPU</h4>\n<p>SPU的管理对商品系统的稳定是如此重要，所以SPU所有新增或修改操作都需要人员审核，所有关于SPU的操作都要添加审计日志，特定环境或场景下可以依赖日志快速恢复或还原。</p>\n<h4>3、生成商品</h4>\n<p>SPU不是商品，但是可以通过SPU工具自动批量快速生成最终售卖的商品，有差异性的商品属性单独修改即可，这样就可以大大简化商品的添加操作。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221208180045247-2005847316.png\" /></p>\n<h3>四、属性管理</h3>\n<p>商品属性是对我们通常所说的商品规格、商品属性和商品参数的通用抽象。</p>\n<p>PowerDotNet重写的商品平台，对规格、属性和参数经过慎重考虑后进行了裁剪和取舍，直接按照商品属性来定义商品元数据，不延用规格而使用属性仅仅是因为作者的个人喜好，咩哈哈。</p>\n<p>商品属性的表设计采用了经典的元数据设计大法，按照属性名和属性值进行独立建表，可扩展性非常好，虽然查询检索可能会比较复杂，但是有成熟的技术手段如Lucene、ES等全文检索技术优化查询。</p>\n<p>属性名值对支持文本、单选和多选设计，这种设计方法对于电商系统中常见的单规格商品和多规格商品可以完美支持。</p>\n<p>有了元数据设计法，品牌、分类等商品基础属性通过名值对字典表也能完美适配，但很多电商都独立设计这几张数据表，一个原因是查询频繁，另一个可能是品牌有图片，分类有前台、APP显示名称等，业务字段较多。</p>\n<h4>1、属性名</h4>\n<p>属性名支持分组管理，这个抽象通常都是后台管理用到，前端逻辑不需要过分关注。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206141604963-2124763475.png\" /></p>\n<p>属性名也支持层级管理，通常不那么复杂的电商场景，只设计一级属性名即可。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206135652018-632561398.png\" /></p>\n<h4>&nbsp;2、属性值</h4>\n<p>根据属性名定义不同的属性值，对于单规格商品就设置一个值，多规格商品就设置多个属性值。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206141318522-2051644006.png\" /></p>\n<h4>&nbsp;3、商品属性</h4>\n<p>属性名和属性值定义好了，最终是要作用于商品上的，否则单独设计属性名和属性值也没有意义。</p>\n<p>商品、属性名和属性值可以通过传统的中间关系表产生关联，这样可以达到属性名值对作用于商品上的效果。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221207090434834-2105754989.png\" /></p>\n<p>PowerDotNet实现的商品平台更进一步，设计了商品属性表，这张表对属性名和属性值进行了大量冗余。这样设计的优点是属性名或者属性值变更时不会影响到现有的商品属性；缺点也比较明显，某些查询场景下需要行转列处理，冗余数据略多，如果相同的改动就需要作用于大部分商品，可能不得不改动大量的冗余数据。</p>\n<p>PowerDotNet开发的商品平台有商品属性名和商品属性值自动同步功能，可以按照商品、SPU、分类、品牌等不同维度和粒度进行批量同步数据操作，大大减少属性数据变更导致的业务和运营人员的工作量。</p>\n<p>当然这个中间商品属性表的维护还是需要人员花费大量精力和时间，毕竟商品属性很多，幸好有模板设计法，PowerDotNet内置了很多模板工具和方法，可以进行批量增删改操作，同样能大大减少工作量。</p>\n<p>不得不说，元数据大法好，模板大法好，PowerDotNet大法好，咩哈哈。</p>\n<h3>五、模板管理</h3>\n<p>电商平台的商品琳琅满目，属性成千上万，如果我们对商品属性管理按照商品一个一个进行录入，工作量巨大，而且容易出错。</p>\n<p>通过模板设计大法，我们完全没有必要按照商品进行一个一个管理，可以先定义好属性模板，按照SPU、分类、品牌等进行模板管理，只需要录入必须的基本的属性名和属性值就可以按照模板批量管理。</p>\n<p>当然，模板生成的商品属性通常都是通用的没有明显差异化的，需要个性化的商品属性我们可以按照商品一个一个进行补充，这种操作通常很少，工作量完全可以接受。</p>\n<h4>1、模板信息</h4>\n<p>可以按照SPU、分类、品牌等分组命名模板，望文知义，所见即所得，便于运营和管理。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206144318239-1587383372.png\" /></p>\n<h4>2、模板属性</h4>\n<p>定义模板是为了解决属性繁多易错的问题，所以模板就要和属性名、属性值产生关联关系。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206144422535-383976370.png\" /></p>\n<h4>3、复制模板</h4>\n<p>对于相似SPU、分类或品牌，PowerDotNet商品平台提供了快捷复制工具，可以按照已有模板批量复制模板和模板关联属性，大大减少业务工作量。</p>\n<h4>4、同步模板</h4>\n<p>模板的改动相对而言比较少，但是如果有变更，比如属性名值的增删改，我们可以通过同步工具自动批量将变更数据同步到各个商品中，业务要做的事情就是点下按钮而已。</p>\n<h4>5、SPU模板</h4>\n<p>一种SPU可以包含多种商品，定义好SPU模板，可以一键生成相同SPU下的一组商品的商品属性，差异化的属性再到商品属性管理页面下独立设置修改即可。</p>\n<p>举例：SPU为华为P50 Pro，主要差异属性有颜色（黑色、白色、银色、金色）和机身内存（128G、256G、512G），定义好模板，可以一键生成4x3=12个商品的所有商品属性。</p>\n<p>根据SPU自动生成商品的过程，其实也是自动生成SKU的过程，但这个过程在PowerDotNet商品管理里可以弱化，后续介绍SKU的时候再介绍下为什么要弱化这个过程。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206151538327-1922451407.png\" /></p>\n<h4>6、分类模板</h4>\n<p>如果某些分类下的商品属性非常相似，可以定义比SPU更粗力度的模板，批量生成相同分类下的商品属性，差异化的属性再到商品属性下独立设置修改即可。</p>\n<p>举例：三级分类为手机，定义好分类下的模板，可以一键批量生成手机分类下的商品属性。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206152127989-2138100602.png\" /></p>\n<h4>7、分类品牌模板</h4>\n<p>和分类模板的主要功能和作用类似，只不过分类品牌模板是在分类相同的情况下再找到相同品牌的商品，商品范围被缩小，差异化的属性再到商品属性下独立设置修改即可。</p>\n<p>举例：三级分类为手机，品牌为华为，定义好分类品牌下的模板，可以一键批量生成手机分类下华为手机的商品属性。</p>\n<p><img alt=\"\" src=\"https://img2022.cnblogs.com/blog/32361/202208/32361-20220809084739759-486578833.png\" /></p>\n<h3><strong>六、商品管理</strong></h3>\n<p>商品管理模块主要包括商品信息、商品属性、商品条码、商品价保、商品图片、商品视频等常用功能。</p>\n<p>有些公司的商品管理代码，对很多基础概念那叫一个不讲究，尤其是SPU和SKU，规格、属性和参数等容易混淆的内容，有经验的人看过就知道，不出意外的话，总有一天会出意外。</p>\n<h4>1、SKU</h4>\n<p>SKU = Stock Keeping Unit(库存量单位)，严格按照定义来看，显而易见，SKU肯定不完全等于商品，实际情况也确实是这样的，商品定义远远比SKU要复杂的多，商品要应对的变化也远比SKU复杂。</p>\n<p>在传统的商品管理体系设计和实现中，商品管理一般都会包含SPU、SKU和商品信息三层管理逻辑，商品ID(GoodsId)、SkuId和SpuId之间有关联关系，抽象程度越高，定义越明确，商品更容易管理。</p>\n<p>个人经验中，SKU主要基于商品的销售属性生成，常用于库存和价格管理，后台控制更多；而商品的整体定义，除了销售属性，还有条码、图片、视频和营销等等各种元素，前后台都有复杂控制逻辑。</p>\n<p>SPU可以根据模板自动生成SKU和商品，SKU属于商品和SPU之间的过渡角色，如果你开发过的WMS、MES和商品管理系统CMS都是以商品为准，SKU的地位就很尴尬，让人几乎感觉不到它的存在。</p>\n<p>PowerDotNet的SKU设计参考了前厂的商品管理，商品和SKU仅有简单的关联关系，实际商品管理都是以商品为准，弱化了SKU的存在，WMS和MES中的商品库存也是商品为准，这就是理论和实践的区别。</p>\n<h4>2、商品档案</h4>\n<p>支持商品信息的增删改查，支持快捷生成商品。通过模板可以批量生成商品属性，通过SPU可以一键批量生成商品。</p>\n<p>PowerDotNet实现的商品信息管理兼具易用性和可扩展性，查询也比较方便，对于中小公司，甚至不需要上全文检索，直接创建宽表根据RDBMS的查询功能即可实现基本业务需求。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221213145631931-195792669.png\" /></p>\n<p>商品信息字段比较多，商品管理后台提供了完善的偷懒工具，只要点击复制按钮，必填参数改一下或者不填由后台自动生成，可以大大提高录入数据速度和准确性，对于同品类或相同SPU的商品有奇效。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221208175354118-561045316.png\" /></p>\n<h4>3、商品属性</h4>\n<p>商品信息里的字段主要是常用检索字段和通用信息字段，商品属性定义更丰富的商品维度描述。</p>\n<p>字典表属性名和属性值修改后可以批量同步到商品属性中，这是一个比较危险的操作，尤其是销售属性的批量同步变更，需要业务反复查询对比确认后才能操作。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221208175449198-1936930492.png\" /></p>\n<p>前面属性管理处我们已经说过，PowerDotNet实现的商品平台对商品属性表做了大量冗余，支持自定义，支持修改特定商品属性名值对而不影响全局。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206190656761-1329187443.png\" /></p>\n<h4>4、商品条码</h4>\n<p>条码的应用非常广泛，PowerDotNet实现的商品条码支持商品普通条码和二维码的生成。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206210757518-412261095.png\" /></p>\n<p>某些商品还需要按渠道不同生成特定渠道的条码和二维码，PowerDotNet预留了扩展用以后续支持。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221212205016231-411154734.png\" /></p>\n<p>商品条码和商品库存有一定的关系，通常情况下，相同商品SKU的有效条码可以重复，重复个数和库存数相等，当然不严格的情况下条码也可以重复生成或作废，并不强求条码和库存数一定相等。</p>\n<h4>5、商品价保</h4>\n<p>价保基础表定义价保信息，商品再根据商品和价保关系表构成商品价保，这样设计的好处是价保信息可以复用。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206205759684-1812971442.png\" /></p>\n<p>其中价保关系表还特别设计了价保开始和结束时间，满足绝大多数电商促销活动的需求。当然有些电商的活动规则引擎会把价保自动放到规则中去，不需要在商品系统中进行价保维护。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206205820053-692332191.png\" /></p>\n<h4>6、商品图片</h4>\n<p>商品图片主要利用文件平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/file-platform-design-and-implement.html\" target=\"_blank\">Power.File</a>实现图片的管理，本文不再赘述。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206191530363-1760500606.png\" /></p>\n<h4>7、商品视频</h4>\n<p>和商品图片类似，目前短视频极其流行，视频文件大小较大，对文件服务器有较高要求。</p>\n<h4>8、商品统计</h4>\n<p>电商系统中商品众多，排序在商品展示中有重要作用，常见的排序指标比如评论数、收藏数、销量等等，这些数据主要由统计计算而来，直接设计存储在商品系统中非常合理，当然这些数据存储在其他系统（如CRM、订单等）中进行汇总定时通知到商品系统或者商品系统主动调用接口查询也是常见的可行方案。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221213145745193-1646418969.png\" /></p>\n<h4>9、其他</h4>\n<p>其他如商品买家秀等个性化数据没有设计在商品平台里，个人认为这些模块功能属于商品系统的可扩展设计，对于中小电商系统它们完全可以划归到<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/pcrm-design-and-implement.html\" target=\"_blank\">Power.PCRM</a>中去。</p>\n<p>商品库存则很明显需要开发库存或者进销存系统进行商品库存管理，复杂点的库存管理系统还需要包括原料、辅料、生产加工等等功能模块，这些正是WMS和MES系统的长项。</p>\n<p>为了查漏补缺，我试着问国内几个主流AI工具相同的问题“提供一份电子商务商品系统主要的数据库表设计”，最终比较满意的竟然是<a href=\"https://www.doubao.com/chat/\" rel=\"noopener nofollow\" target=\"_blank\">字节豆包</a>，而我预料中最可能接近答案的<a href=\"https://tongyi.aliyun.com/qianwen/\" rel=\"noopener nofollow\" target=\"_blank\">通义千问</a>还不如<a href=\"https://www.deepseek.com/\" rel=\"noopener nofollow\" target=\"_blank\">DeepSeek</a>给的结果靠谱。</p>\n<h3>七、日志管理</h3>\n<p>商品平台是电商系统最基础最重要最敏感的业务系统之一，所以对商品的增删改操作都要有业务操作日志，某些核心查询操作也需要按需记录审计日志。</p>\n<h4>1、商品日志</h4>\n<p>主要用于记录并管理商品的核心操作日志，特殊情况下还可根据这些日志进行业务数据还原和恢复。</p>\n<p>根据个人经验，所有基础数据表的修改，自定义商品属性、销售属性、价格等敏感参数都需要重点记录日志，防止修改错误需要紧急修复。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/32361/202212/32361-20221206192659006-980543551.png\" /></p>\n<h4>2、系统日志</h4>\n<p>系统日志相对商品日志，重要性就不那么突出，主要记录一些日常操作日志、对外提供接口日志、业务不敏感日志等。</p>\n<p>系统日志可通过定时任务自动归档或者清理。</p>\n<h3>八、特殊商品</h3>\n<p>上面列举的一系列商品功能只是最通用最基础的电商商品抽象，还有一些特殊商品，正是我实现过程中痛苦和挣扎的主要来源，可能还需要按需进行额外扩展设计和管理。</p>\n<p>Power.Commodity一开始只是我没事写点代码让自己高兴高兴的临时作品，目的也只是单纯总结和提取个人工作过的商品代码，但写着写着就发现越来越深不见底，尤其是特殊商品实在难以全部覆盖。</p>\n<p>本文不探讨特殊商品的具体管理设计开发和建设细节，因为这是另外一个漫长的故事了，对于体力活我也是有追求的，所谓识时务者为俊杰^_^，只简单说说个人实际参与设计开发过的几种特殊商品。</p>\n<h4>1、汽车商品</h4>\n<p>汽车商品是一种特殊商品，区别于一般商品的主要特点包括：</p>\n<p>（1）、零件多，技术含量高，属性多且复杂</p>\n<p>（2）、金额较大</p>\n<p>（3）、耐用品</p>\n<p>（4）、涉及重大安全问题</p>\n<p>（5）、有专属的交通法规，管理人员，道路辅助等</p>\n<p>（6）、大件，重量较大，不易快递或转运，配合门店或4S店销售</p>\n<p>（7）、是高档金融消费品，和金融保险联系紧密</p>\n<p>（8）、其他，如税费较多，汽车商品常见的5种税：车辆购置税、车船税、增值税、消费税、关税，除车款外其他费用包括上牌费、保险（交强险、商业险）等</p>\n<p>多层级属性是汽车商品的一个显著特点，汽车商品常见的一级属性包括品牌、厂商、车系、车款、车身、发动机、电动机、变速箱、底盘转向、车轮制动、安全装备、操控配置、外部配置、内部配置、座椅配置、多媒体配置、灯光配置、玻璃/后视镜、空调/冰箱、高科技配置等，每一个属性下又可以继续拆分出不同的子属性，比如多媒体配置，我们可以继续拆分出GPS导航、定位互动服务、中控台彩色大屏、蓝牙/车载电话、车载电视、后排液晶屏、外接音源接口、CD支持MP3/WMA、多媒体系统、扬声器品牌、扬声器数量、220V/230V电源系统等子属性。</p>\n<p>相比普通商品，汽车商品查询检索有较多的多规格设计，常见的除了分类和品牌外，还包括价格、排量（如1.1-1.6L、1.7-2.0L）、能源（如汽油、新能源）、结构（如两厢、三厢）、国别（如中国、欧系）、配置（如全景天窗、电动天窗）、驱动、变速箱、座位、进气形式、生产方式等。</p>\n<p>个人开发经验中，和汽车这种巨多规格和属性的商品类似的还包括药品和生鲜类商品，对于这种繁多而复杂的商品，一张宽表一把梭的设计特别容易造成开发和维护灾难。</p>\n<p>PowerDotNet的商品属性设计和模板方法完全可以应对汽车商品的多规格属性配置，只是属性层级多，属性字段也很多，查询逻辑略微复杂。</p>\n<h4>2、生鲜商品</h4>\n<p>生鲜商品的最大特点是任意性和随意性，正是因为这两个特性导致生鲜商品的标准化远远滞后于一般商品，而标准化在商品平台设计与实现中至关重要。</p>\n<p>我们还是以前面提到的华为手机举例，通过一个简单示例对比，看一下标准化生鲜商品为什么会比较困难：</p>\n<p>华为P50 Pro手机是一种SPU；生产于中国大陆基于鸿蒙操作系统于2021年上市的黑色机身内存128GB运行内存8GB...的华为P50 Pro手机是一个SKU。</p>\n<p>相对应的，生鲜类标准化商品会有如下描述：</p>\n<p>南汇8424西瓜是一种SPU；产于中国上海的于2021年上市的重量为XX公斤到YY公斤...的南汇8848西瓜是一个SKU。</p>\n<p>\"人不能两次踏进同一条河流\"，这是古希腊哲学家赫拉克利特说的。西瓜不能两次长出同一种重量，我们也可以说的富有哲理，咩哈哈。</p>\n<p>假如标准化不加约定和限制，仅仅根据生鲜类商品的重量就能组合出很多种商品，造成SKU组合爆炸难题。</p>\n<p>有人可能会有疑问，为什么不按照单位重量或体积进行商品定义，比如产于中国上海的于2021年上市的每公斤5元的南汇8848西瓜是一个SKU，然后用户下订单，直接按照实际购买重量乘以单价即可。</p>\n<p>这种方案看上去非常完美，但是有一个先天缺陷，重量是需要人力称出来的，生鲜电商由于是大规模线上经营，通常都是预先通过生产加工系统进行称重，然后更新库存，不可能像实体店那样当面现称现卖。</p>\n<p>这个问题的解决方案就是针对特定生鲜产品进行评估，对相同SPU的商品给出一个大致模糊的重量（或体积）范围以满足生产加工的需要，商定出一个用户能接受的价格，达到一种买和卖的平衡。</p>\n<p>在一些电商站点上，生鲜商品比普通售卖的商品看上去没有更加复杂，有些行业特点比如储运条件（常温、恒温、冷冻、冷藏等）通过属性名值对或者扩展表也能很好支持，之所以拿出来单独说，主要是因为生鲜商品标准化背后隐藏的复杂性。</p>\n<p>生鲜商品非标准化的物品很难用标准化的商品软件来管控，很多生鲜电商公司都只能按需自研信息化服务，比如供应链、生产加工、仓储管理、质检、运输、配送等等，难度可想而知。</p>\n<p>个人曾经参与开发维护过一套生鲜系统，业务逻辑之恶劣，实现之奇葩，单据之多样，软件流程之长，使用之不友好，每看一遍代码都差点灵魂出窍，业务系统做成这种效果也是常人所不能及也。咩哈哈。</p>\n<p>我尝试过用PowerDotNet新的商品设计思路重构一个生鲜商品系统，但是难度和工作量极大，还会影响其他系统，最后只能撤销改动放弃努力，曾经有过美好，但有些事物失去了就是失去了，不可强求。</p>\n<p>假如商品平台要支持生鲜商品的主要特性，可能原料、辅料、包装方案、BOM、计划单、提货单、加工单、反加工单、损益单、尾料、原料顶替等名词都要再温故知新一遍，往事历历在目却遥不可及也。</p>\n<p>通用性、标准性和普适性的公共服务系统才是PowerDotNet努力的方向，而任意性和随意性天生就是公共服务的天敌，抽象和实现的难度肉眼可见成倍剧增，所以最新商品平台设计暂不支持生鲜类商品。</p>\n<h4>3、虚拟商品</h4>\n<p>最典型而常见的几种虚拟商品如下：</p>\n<p>（1）、网络游戏卡，是按服务公司的规定以现金兑换虚拟点(积分)的形式，通过消耗虚拟点(积分)来享受服务的一种支付形式。</p>\n<p>（2）、移动/联通/电信/充值，包括话费充值，流量充值等。</p>\n<p>（3）、网络软件，一般是指系统的操作系统、协议和应用级的提供服务功能的专用软件。</p>\n<p>（4）、网站产品，以产品的眼光看待网站是网站产品的精髓所在。网站产品不同于软件产品、服务产品、工业产品等。网站产品是一类信息产品，以网站的形式提供信息、服务或二者的结合是它的主要表现形式。</p>\n<p>我个人最熟悉的虚拟商品，包括网文（按章节收费）和电子书以及游戏点卡，某些公司的虚拟货币充值也可以抽象成一种商品，只要让用户下订单花钱支付购买同时又没有直接拿到实物产品，就可以认为用户购买的是虚拟商品。</p>\n<h4>4、服务商品</h4>\n<p>服务型商品也是日常生产生活中经常碰到的一种商品类型。最典型的如火车票、汽车票、酒店、机票、旅游度假等商品。</p>\n<p>以我个人比较熟悉的某OTA（Online Travel Agency，在线旅行社）机票产品为例，服务型商品也非常考验开发人员的设计和架构水平。</p>\n<p>机票系统涉及到很多业务数据表，常见的比如区域、二字码、三字码、机场、航站楼、航线、航司、飞机机型、中转地、行程总时长、仓位、常旅客、机票、机票库存、报价信息等表。</p>\n<p>机票、火车票、汽车票、船票和邮轮等非常相似，看上去都是一个“占座”的商品形式，完全可以抽象出公共部分。而酒店则有一个间夜的概念，外加酒店内的附属商品管理，复杂度更胜一筹。</p>\n<p>我们可以将机票航线、航班号、起降时间和具体飞机及仓位的组合（也就是一张飞机票）直观理解为商品，常见的机票商品包括单程和往返机票，还可以根据不同航线组合出联程/多程机票。</p>\n<p>对于机票，大家还应该听说过中航信（含eTerm 或IBE+，两者都知道的，我只想说吾道不孤矣），机票查询和预定基本离不开它。</p>\n<p>注：IBE+（Internet Booking Engine），即中国航信互联网订座引擎，是基于因特网的开放平台技术，它为各种用户应用系统提供访问中国航信传统订座业务系统的途径，是采用API方式的接口。</p>\n<p>据我所知，机票库存可以通过中航信的eTerm软件来查询，行业内的一般做法是将eTerm软件功能封装成接口，供内部系统使用，当然除了eTerm，现在还有IBE+以API接口的形式提供查询和预定功能。</p>\n<p>机票的库存信息一般称为AV信息，这个称呼的来源主要源于eTerm（黑屏）查库存指令。由于库存信息非常重要，因此每家OTA都会花费很多的流量在获取航班的AV信息上。</p>\n<p>由于eTerm和IBE+的接口响应时间较慢，因此OTA采用的方法基本都是主动去获取AV信息，然后缓存起来，绝大多数用户查询时直接拿缓存数据即可，当然有些情况下还是会出现查询缓存失败，再去实时获取AV信息的情况。</p>\n<p>相较于汽车、生鲜和虚拟商品，PowerDotNet的商品系统可能只需要加一些业务扩展表就可以完美支持，而服务类商品通常业务复杂，不容易做成通用设计，所以PowerDotNet已完成的商品设计将服务商品排除在外。</p>\n<p>我尝试着使用国内流行的人工智能服务（<a href=\"https://tongyi.aliyun.com/qianwen/\" rel=\"noopener nofollow\" target=\"_blank\">通义千问</a>、<a href=\"https://www.doubao.com/chat/\" rel=\"noopener nofollow\" target=\"_blank\">字节豆包</a>、<a href=\"https://www.deepseek.com/\" rel=\"noopener nofollow\" target=\"_blank\">DeepSeek</a>、<a href=\"https://yiyan.baidu.com/\" rel=\"noopener nofollow\" target=\"_blank\">文心一言</a>和<a href=\"https://hunyuan.tencent.com/\" rel=\"noopener nofollow\" target=\"_blank\">腾讯混元</a>），实现机票预定功能，给出的代码真是一言难尽，AI目前还无法给出超过预期的方案，祖传代码暂时还是安全的^_^。</p>\n<p>假如后续仍然需要加入机票、酒店、火车票、汽车票等服务商品功能，最好按照服务商品的特殊规范进行抽象设计，独立出来服务商品平台未尝不是一个好方法，元数据和模板设计大法同样有用武之地。</p>\n<p>当然，目前看来PowerDotNet实现的商品管理系统还是比较基础的传统的商品管理，想做到大一统的支持各种形态的商品，还需要做很多设计和实现工作，虽然我个人手头有现成的业务代码和解决方案可参考，咩哈哈。</p>\n<h3>九、商品搜索</h3>\n<h4>1、实现功能</h4>\n<p>商品搜索实现的功能主要包括按关键字搜索、中文分词、历史搜索、热门搜索、推荐搜索、联想关键词等等，绝大多数大中型电商公司的全站搜索服务就包括商品搜索功能。</p>\n<h4>2、解决方案</h4>\n<p>商品搜索在商品管理上算是常用而又有点技术难度的功能了，曾经有一种简单直接高效的暴力设计方法，就是添加一张商品关键词表，不过随着NoSQL和NewSQL的兴起，这种设计方案已显得非常落后。</p>\n<p>个人早年有幸独立实现过一个典型而朴素的商品搜索功能，按照商品分类、标签以及任意关键字，通过MySQL的查询功能，模糊或精确匹配，按权重分页展示，现在想来依然十分好笑，咩哈哈。</p>\n<p>搜索有很多现成的解决方案，比如基于Lucene或者ElasticSearch全文检索实现的搜索服务，按不同数据源（比如商品）建立索引，通过分词优化匹配查询索引，可按需实现对应系统（如商品）查询服务。</p>\n<p>Lucene和ElasticSearch在实践中极易一不小心踩到很多坑，尤其是ElasticSearch，个人印象最深的是看上去简单常用的分页查询，在数据量很大或者有较多分片的情况下，越往后分页查询性能越拉跨。</p>\n<p>个人曾经所在电商公司使用ES实现基本搜索功能，外加Redis和SqlServer配合实现搜索服务兜底方案，性能恶劣的sql语句like模糊匹配是最差的选择，like查询默认选择可以使用索引的左匹配。</p>\n<p>搜索服务的设计与实现比较有技术挑战，尤其是全站搜索和商品搜索结合，值得再开一篇文章详细介绍，不过这就是更偏重于分词索引实现搜索服务的另一个话题了，本文不再展开详细说明。</p>\n<h3>十、商品排序</h3>\n<p>商品搜索和商品排序是密不可分的，对于商品搜索结果，我们总是要根据一定的排序规则展示给用户。下面列举电商中常见的几种商品排序：</p>\n<h4>1、直接根据商品属性排序</h4>\n<p>比如商品价格、上架时间、商品序号、自定义排序序号等</p>\n<h4>2、根据商品相关统计进行排序</h4>\n<p>比如商品销量、好评数、关注数、浏览次数、回购率等</p>\n<h4>3、根据商家相关统计进行排序</h4>\n<p>比如商家信用、商家门店数等</p>\n<h4>4、根据距离排序</h4>\n<p>最常见最典型的就是在线外卖订餐平台，根据消费者当前位置，按照距离排序</p>\n<h4>5、综合排序</h4>\n<p>在实际电商业务场景中，系统默认推荐排序不是简单的根据单一字段进行排序，而是综合排序。</p>\n<p>通常来说，综合排序是先按商品和搜索关键词的相关性过滤，然后按上下架时间做预选，最后在预选结果里根据商品人气及质量等方面进行排序。</p>\n<h3>十一、系统交互</h3>\n<p>商品系统是电商最核心的组成部分之一，是电商平台的基础数据服务系统，和很多内部业务系统保持互通关系，整理下个人开发和对接过的几种常见互联系统。</p>\n<h4>1、订单系统</h4>\n<p>毫无疑问，订单的生成离不开商品，企业在正常的经营过程中，必须有销售商品、产品、提供劳务等业务，订单系统主要提供商品售卖服务。</p>\n<h4>2、库存系统</h4>\n<p>库存系统主要用于管理商品库存，主要包括商品入库、商品出库，商品调拨和商品盘点等操作。我们熟知的仓储WMS系统就包括库存管理。</p>\n<h4>3、采购系统</h4>\n<p>电商中的商品一般来说主要由供应商提供，我们常见的采销系统或进销存系统或供应链系统等都和商品及库存紧密相关。</p>\n<p>某些特殊电商场景除了商品，还要考虑辅料、原料（物料）等，商品管理系统的设计直接关系到采销业务系统的复杂度。</p>\n<h4>4、门店系统</h4>\n<p>门店系统主要经营企业线下业务，门店系统的经营活动也离不开商品管理系统。</p>\n<h4>5、财务系统</h4>\n<p>财务系统是电商系统中最复杂的复合型公共服务型系统，财务单据经常和商品管理有千丝万缕的联系。</p>\n<p>十多年前在帝都某电商公司做财务开发，竟然要自己写SQL访问商品表的积分字段，写windows服务计算和统计用户积分，这么普通而自信的业务逻辑放在今天你敢信？这些其实都是要规避的不合理设计。</p>\n<h4>6、票券系统</h4>\n<p>票券系统是电商中常见的营销系统，针对商品分类、SPU甚至SKU的票券设计很常见。</p>\n<h4>7、广告系统</h4>\n<p>广告系统也是电商中常见的营销系统，针对商品的广告宣传层出不穷。</p>\n<h4>8、推荐系统</h4>\n<p>电商里的推荐系统不会孤立存在，往往和商品、CRM、订单等系统配合完成业务需求。</p>\n<h4>9、CRM</h4>\n<p>主要包括针对个人用户或会员的商品偏好收集和购买统计、积分赠送等等</p>\n<h4>10、其他系统</h4>\n<p>其他如活动等电商业务系统也和商品管理有些联系。</p>\n<h3>十二、其他</h3>\n<p>个人参与设计与开发的商品系统还涉及到以下功能：</p>\n<h4>1、商品详情</h4>\n<p>一个好的商品详情页，可以有效的提升单品的转化率，对于不同终端（比如PC、APP、H5等）的商品详情页设计侧重点也会有很多不同。</p>\n<p>商品详情页的接口设计也非常考验开发人员的编程经验，是采用大而全接口还是小而美接口，这需要开发人员根据实际情况做出合适的选择。</p>\n<h4>2、多语言</h4>\n<p>商品的多语言设计和实现也很普遍，对数据表的设计有更多更高要求，虽然多语言的工作绝大多数在我看来都是体力活。</p>\n<h4>3、组合商品</h4>\n<p>为了促进销售，很多商家在售卖时会利用“捆绑销售”的策略，这样就自然而然发明出了组合商品：人为将几个单独售卖的商品组合在一起进行合并售卖的商品。</p>\n<p>SKU(组合)=m*SKU1+n*SKU2+...p*SKUx</p>\n<p>组合商品的设计可能会对商品库存管理和订单拆单逻辑造成直接的负面影响，曾经在某电商公司做过一段时间开发，没少被组合商品搞得晕头转向，尤其是某些单据的业务逻辑那是相当炸裂。</p>\n<h4>4、商品数据同步</h4>\n<p>不同系统对商品主数据的要求是不一样的，有些业务系统仅仅提供商品接口即可满足业务需求，比如订单系统。</p>\n<p>但一些后台业务系统（如WMS、MES等），往往牵涉到商品的复杂SQL查询，商品数据同步至对应业务系统也是必要的，PowerDotNet数据同步平台<a href=\"https://www.cnblogs.com/jeffwongishandsome/p/datax-task-scheduler-and-data-synchronization-design-and-implement.html\" target=\"_blank\">Power.DataX</a>可轻松解决数据同步问题。</p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\">\n    <div id=\"AllanboltSignature\">\n<p id=\"PSignature\"><br />\n作者：<a href=\"http://www.cnblogs.com/jeffwongishandsome/\" target=\"_blank\" title=\"据说点击推荐或者关注博主是一个程序员的优良品质，留言也是\">Jeff Wong</a> <br />\n出处：<a href=\"http://jeffwongishandsome.cnblogs.com/\" target=\"_blank\" title=\"关注要趁早啊，留言也可以啊，至少二选一吧！\">http://jeffwongishandsome.cnblogs.com/</a> <br />\n本文版权归作者和博客园共有，欢迎围观转载。转载时请您务必在文章明显位置给出原文链接，谢谢您的合作。 <br />\n</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2025-12-31 12:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jeffwongishandsome\">JeffWong</a>&nbsp;\n阅读(<span id=\"post_view_count\">49</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[微服务进阶场景实战] 微服务痛点 - 用实际经历告诉你它有多少陷阱",
      "link": "https://www.cnblogs.com/yhup/p/19425482",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yhup/p/19425482\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 10:54\">\n    <span>[微服务进阶场景实战] 微服务痛点 - 用实际经历告诉你它有多少陷阱</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"[微服务进阶场景实战] 微服务痛点 - 用实际经历告诉你它有多少陷阱\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105243692-1476815581.png\" />\n        本文深入探讨了微服务架构的核心概念与实践挑战。通过对比单体架构与微服务架构在新零售系统中的实现差异，揭示了微服务在精准扩展、独立发布、技术异构和持续优化等方面的优势。同时重点剖析了微服务落地的四大痛点：服务边界划分困难（受康威定律支配）、服务粒度失控、系统全貌难以掌握以及代码重复问题。文章指出微服务拆分本质上是一个需要平衡技术、业务和组织因素的持续治理过程，而非纯粹的技术决策。这些见解为后续微服务实战提供了重要的理论基础和风险预判。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>好了各位，热身结束！前面的内容我们主要梳理了基于那些“流行组件”的微服务常见玩法。既然已经有了不少成熟的开源工具，咱们的重点就在于弄清它们背后的原理，用起来心里才有底。</p>\n<p>从这一篇开始，我们要进入一个新阶段——<strong>微服务进阶场景实战</strong>。在真正深入具体业务场景之前，咱们不妨先退一步，聊聊更根本的问题：<strong>微服务到底是怎么回事，它究竟有什么优势，又会带来哪些挑战？</strong> 理解这些，后续的实战才不至于只见树木不见森林。</p>\n<h1 id=\"1-单体式架构vs微服务架构\">1 单体式架构VS微服务架构</h1>\n<h3 id=\"单体式架构-vs-微服务架构一个实战对比\"><strong>单体式架构 vs 微服务架构：一个实战对比</strong></h3>\n<p>为了清晰区分这两种架构模式，我们不妨从一个具体的新零售系统案例入手。假设某门店（涵盖自营店和加盟店）需要研发一套新零售系统，核心功能包括订单、营销、商品、门店、会员及加盟商管理等模块。在搭建新零售系统架构时，如果使用单体式架构进行设计，它的架构如图所示。<br />\n<img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133196-1930390780.jpg\" /></p>\n<p>若采用单体式架构，所有功能模块的代码会被打包进同一个应用程序中，数据也集中存储在单一数据库内。这种设计初期看似省事，但随着业务逻辑逐渐复杂，任何微小的代码改动都可能像触发连锁反应一样，导致整个系统意外崩溃——老实说，这类情况在不少开发团队中已是“家常便饭”。尽管每次故障后都会进行复盘，引入代码审查、风险评估、方案评审等流程，但问题往往周而复始。最终，为了控制风险，发布流程越来越冗长，迭代速度不断放缓，甚至陷入停滞。相比之下，<strong>那些采用更灵活架构的团队，其功能交付效率可能高出十倍以上。</strong></p>\n<p>要摆脱这种困境，核心举措是进行架构拆分：将相互耦合的模块分离，减少彼此干扰。于是，微服务架构登场。如上图所示，原有的单体应用被拆分为六个独立服务，分别处理订单、营销、商品、门店、会员及加盟商等业务逻辑，且每个服务拥有自己的专属数据库。<br />\n<img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133255-1507375404.jpg\" /></p>\n<p>如果服务间存在依赖关系，可通过定义<strong>清晰的接口、异步消息、共享缓存或数据同步</strong>等方式进行协作——这样既保持了服务的自治性，又确保了系统的整体连通性。</p>\n<h1 id=\"2-微服务的好处\">2 微服务的好处</h1>\n<p>将庞大的单体应用拆分为独立的微服务，并非为了追赶技术潮流。这一转变能为我们带来以下几个关键层面的显著提升：</p>\n<p><strong>1. 精准扩展，成本可控</strong><br />\n当某个业务模块（例如“秒杀促销”服务）面临流量洪峰时，在单体架构中你不得不对整个庞大应用进行扩容，资源浪费严重。而在微服务架构下，你可以<strong>精准地将资源“弹药”倾斜给压力最大的服务</strong>，仅需为该服务单独增加节点实例即可。这就像酒店的中央空调与独立空调——独立调控显然更灵活、更经济。</p>\n<p><strong>2. 独立发布，高效协同</strong><br />\n单体架构下，任何微小的功能上线都需要全应用打包、整体部署，迫使所有团队同步进行集成测试与上线协调，流程笨重。微服务化之后，每个服务团队在<strong>确保对外接口（契约）稳定</strong>的前提下，可以独立开发、测试与部署自己的服务。营销团队可以一天发布多次，而核心订单服务则按自身节奏稳步迭代，彼此互不阻塞，极大地提升了交付效率。</p>\n<p><strong>3. 技术异构，因“服”制宜</strong><br />\n在单体中，技术栈通常被强制统一。微服务则允许每个服务根据其<strong>特定的业务需求和技术特点，选择最合适的编程语言、框架乃至数据存储技术</strong>。例如，用Python处理数据分析服务，用Go编写高性能的网关，用Node.js构建实时推送服务。只要服务间通过标准协议（如HTTP/RPC）通信，其内部实现技术可以自主决策。</p>\n<p><strong>4. 拥抱重构，持续优化</strong><br />\n单体应用内代码高度耦合，任何重构都如履薄冰，极易引发不可预知的副作用，导致开发者不敢对“祖传代码”动刀，技术债务不断累积。微服务通过<strong>清晰的边界隔离了变化的影响范围</strong>。现在，你可以<strong>从容地对单个服务进行内部重构或技术升级</strong>，只要接口行为不变，就不会波及整个系统。这为代码质量的持续改善和技术栈的渐进式演进提供了坚实基础。</p>\n<hr />\n<h1 id=\"3-微服务的痛点\">3. 微服务的痛点</h1>\n<p>在产品研发中，引入一项技术来解决特定问题往往不难；真正的挑战在于能否<strong>精准评估并管理其伴随而来的复杂性与风险</strong>。对于微服务架构而言，这一点尤为关键。本节将深入探讨微服务实践中的典型问题，这些内容无论对于架构设计还是技术面试，都具有很高的参考价值。</p>\n<h2 id=\"31-痛点服务的职责边界划分\">3.1 痛点：服务的职责边界划分</h2>\n<p>微服务架构的一大难题，在于难以对某些<strong>模糊的职责</strong>进行清晰界定——例如，一个特定的功能到底应该属于服务A还是服务B？这绝非单纯的技术决策，而常常演变为涉及多方因素的“公司级谜题”。为了便于理解，我们通过几个具体场景，看看服务的划分是如何在实践中变得错综复杂的。</p>\n<h3 id=\"基于核心数据所有权划分\">基于核心数据所有权划分</h3>\n<p>这是最直观的原则。例如，根据商品ID查询商品详情的接口，自然应归属于<strong>商品服务</strong>；获取某个用户的所有订单列表，则理应由<strong>订单服务</strong>提供。</p>\n<h3 id=\"与业务运营团队的职能对齐\">与业务运营团队的职能对齐</h3>\n<p>职责划分需考虑实际使用系统的业务团队。例如，“每个商品在每个门店的实时库存”应该放在商品服务还是门店服务？由于库存通常由各门店的运营人员直接管理和维护，因此将其划归<strong>门店服务</strong>在逻辑上更为顺畅。</p>\n<h3 id=\"与产品管理职责对齐\">与产品管理职责对齐</h3>\n<p>产品团队的职责范围也会影响划分。假设一个新需求要求实现“特定门店只能销售特定商品”的功能。这个功能应该放在门店服务还是商品服务？这时，往往取决于该需求由哪条业务线的产品经理主导。如果是商品产品经理负责，就很可能落地到<strong>商品服务</strong>；反之则归入<strong>门店服务</strong>。</p>\n<h3 id=\"受项目工期与资源制约\">受项目工期与资源制约：</h3>\n<p>接续上面的例子，假设根据产品归属原则，该功能应划入门店服务。但可能出现这种情况：门店服务开发团队当前负载已满，无法排期；而商品服务团队恰好有空余资源，但他们并不熟悉门店服务的业务逻辑。为了满足业务方紧急的上线要求（比如两周内必须完成），妥协方案可能就是将此功能交由<strong>商品服务</strong>临时实现。尽管从设计上看这并不“优雅”或通用，但<strong>业务交付的压力常常会压倒架构的纯粹性</strong>。</p>\n<p>然而，所有因素中，最具决定性、也最难以协调的往往是第五点。</p>\n<h3 id=\"与组织架构强相关--康威定律的支配\">与组织架构强相关 — 康威定律的支配</h3>\n<p>这一点至关重要。程序员梅尔·康威在1967年提出的康威定律精辟指出：“设计系统的组织，其产生的设计等同于组织之间的沟通结构。”简而言之，<strong>系统的技术边界最终会无可避免地映射出公司的组织与权责边界</strong>。这不是一个技术选择，而是一个社会学事实。</p>\n<p><strong>一个来自“进销存供应链系统”的典型案例：</strong><br />\n<img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133184-1718280355.jpg\" /></p>\n<p>该系统与前述新零售系统紧密集成。最初，<strong>门店的商品库存</strong>管理职责属于新零售业务团队（其产研团队对接门店运营），而<strong>中央仓库库存</strong>管理职责属于独立的供应链团队，技术架构清晰反映了这一组织划分。</p>\n<p>后来，公司进行战略调整，领导决定将<strong>门店商品库存的管理职责也划归供应链总监统一负责</strong>。这一组织架构的变动，立即引发了技术架构的连锁反应：原来由新零售产研负责的门店库存需求，现在全部转移给供应链产研团队。</p>\n<p>于是，符合康威定律的驱动逻辑开始运行：供应链产研团队有充分的动机（包括绩效与成果导向）推动将门店库存的管理逻辑，从原先新零售体系下的服务中剥离，并迁移整合到他们自己控制的<strong>供应链库存服务</strong>中。因为这样最符合他们团队的责任边界和考核目标，尽管从纯粹的业务逻辑上看，库存管理似乎可以被拆分到不同上下文。</p>\n<p>这个案例深刻地揭示：<strong><u>微服务边界的划分远非纯粹的技术决策，它最深层的驱动力往往来自于业务归属、资源状况、上线压力，尤其是组织的结构与权责划分。</u></strong> 这也解释了为什么寻找放之四海而皆准的“服务划分原则”如此困难——它本质上是一个需要持续权衡、并随组织动态演进的治理过程。</p>\n<h2 id=\"32-痛点微服务粒度拆分\">3.2 痛点：微服务粒度拆分</h2>\n<p>微服务的另一个显著痛点是：<strong>服务数量容易失控</strong>。我们继续通过加盟商功能的演进案例来剖析这个问题。</p>\n<p>起初，新零售系统仅为加盟商提供登录和信息管理功能，这些功能完全可以容纳在一个单一服务中，简单直接。随着业务发展，加盟商的准入、开店、退出都涉及资金流转，因此必须引入财务功能（应收、应付、对账等）。随后，业务又扩展出加盟商员工管理、返点计算、子门店管理等一系列需求。</p>\n<p>此时，如果所有这些功能仍塞在单个“加盟商服务”里，显然已不合时宜。那么，<strong>拆分的时机和粒度应如何把握？</strong> 是在做财务功能时拆，还是在做员工管理时拆？这往往没有标准答案。</p>\n<p>一个常见的启动原则是：预估新功能的规模，如果它能构成一个需要3-4人持续维护的独立模块，就可能值得拆分为新服务。然而，一旦新服务被创建出来，其后续的修改成本通常不高，除非进行大规模重构。</p>\n<p>但现实往往偏离理想路径。为了避免开发人员闲置，公司会不断安排新功能开发。而开发者出于技术洁癖或明确工作边界的倾向，更乐意将相对独立的功能放入<strong>全新的专属服务</strong>中。于是，加盟商财务、员工管理、返点等功能可能纷纷独立成服。</p>\n<p><strong>绩效考核的隐形指挥棒加剧了这一问题。</strong> 开发人员的绩效难以量化，而“负责或创建的服务数量”却成了一个看似客观的指标。尽管公司不会正式将其设为KPI（否则数量必定激增），但在汇报工作时，提及自己维护了多个服务总会显得贡献突出。这种氛围一旦形成，同事们会潜意识里倾向于“造轮子”而非“修轮子”，人均维护5个以上微服务的局面可能悄然出现。</p>\n<p>后来，我们公司意识到了这个陷阱，并通过公开讨论和主动管控来抑制服务数量的无序增长，这取得了一定效果。但归根结底，<strong>“服务粒度多大合适？”本身就是一个没有确切答案的持续性治理难题。</strong></p>\n<h2 id=\"33-痛点没人知道系统整体架构的全貌\">3.3 痛点：没人知道系统整体架构的全貌</h2>\n<p>你是否经历过这样的场景：每隔一段时间，领导就会要求汇报各部门乃至全公司的微服务数量、每个服务的用途？随着服务总数突破几百个，汇报清单长得令人窒息。</p>\n<p>领导的抱怨随之而来：“系统已经复杂到没人能说清全貌了吗？出了问题，你们如何快速定位？” 而几位技术负责人可能面面相觑，内心os：“我连自己团队的完整服务列表都未必清楚。”</p>\n<p>在单体架构时代，理解整个系统的全貌虽不易，但仍是可能且必要的目标。而切换到微服务架构后，工程师们便放弃了掌握全局的企图，只深耕自己负责的“一亩三分地”，遇到问题再临时学习相关系统就好了。</p>\n<p>因此，<strong>“找不到一个能通晓所有微服务架构全貌的人”</strong>，成了微服务落地后一个普遍而真切的痛点。系统整体的可理解性与可维护性，在拆分为服务的那一刻起，就面临着持续性的挑战。</p>\n<h2 id=\"34-痛点重复代码多\">3.4 痛点：重复代码多</h2>\n<p>在单体架构中，公共代码抽取到统一的Common包中是天经地义的事。但在微服务世界里，代码复用之路往往布满荆棘。</p>\n<p>举个例子：A团队开发了一个优秀的日志自动埋点工具包。B团队得知后想引入，于是通过Maven依赖了该JAR包。但很快，B团队就遇到了JAR版本冲突——如果升级冲突的JAR，A团队原有的功能可能失效。为了快速解决问题，他们请求A团队进行兼容性适配。</p>\n<p>A团队为此专门发布了一个适配B团队环境的新版本JAR。然而，当C团队也想使用时，又遇到了全新的版本冲突问题。此时，A团队从投入产出比考量，已不愿再投入精力做新一轮兼容，干脆告知其他团队：“代码都在Git上，你们自己复制、修改吧。” 于是，同一段埋点逻辑，最终以多个略有差异的版本，散落在不同的微服务中。</p>\n<p>后续复盘时，大家认识到问题根源在于“依赖版本不统一”。一个旨在统一所有JAR版本的项目被立项，但第二天就因为紧急业务需求被搁置。此后，每次提起这个重要项目，总被更“紧急”的业务需求打断。大家逐渐明白：<strong>这件事的优先级永远无法高于直接业务需求，因为其投入产出比在短期内极不明确。</strong></p>\n<p>实际上，微服务之间存在一定重复代码或许是可以接受的成本。各部门通常会有自己的内部共享库，以实现部门内的代码复用。在实践中大家发现，<strong>维护这些有限的重复代码，其成本往往低于协调所有团队、统一版本、进行大规模重构所付出的巨大沟通与排期代价。</strong> 这成了微服务架构下一种无奈但务实的取舍。</p>\n<h2 id=\"35-痛点耗费更多服务器资源\">3.5 痛点：耗费更多服务器资源</h2>\n<p>有一个颇为典型的案例：一家小公司最初采用单体架构，整个系统平稳运行在5台服务器上。随着业务发展，团队深感系统耦合度太高，模块间干扰严重，于是决定进行架构演进，转向微服务。</p>\n<p>他们按功能模块将单体应用拆分成了6个独立的微服务。为确保高可用性，每个服务至少需部署2个实例，加上入口网关层部署2个节点，基础资源需求已增至14台。由于其中一个服务计算资源消耗较大，为保险起见又额外增加了一个节点。最终，<strong>服务器总数从5台跃升至15台</strong>。</p>\n<p>值得注意的是，在此期间业务流量并未增长，核心代码逻辑也基本未变，仅仅是架构拆分这一动作，就导致了基础设施成本的大幅上升，这在团队内部引发了讨论。有成员曾提出，能否通过“混合部署”来优化资源使用：例如在一台服务器上同时部署服务A和B，另一台上部署服务B和C，通过灵活编排来减少机器总数。<br />\n<img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133211-1757364366.jpg\" /></p>\n<p>但这个方案很快被搁置了。主要原因在于运维的简洁性：<strong>“一个服务对应专属节点”的模式，使得服务器可以直接以服务名命名，故障排查时一目了然。</strong> 如果采用混合部署，服务器角色将变得模糊，运维复杂度会显著增加。</p>\n<p>于是，一种在实践中常见的权衡出现了：团队倾向于接受“服务器资源相对廉价，多部署几台也无妨”的观点，暂时接受了更高的资源开销。事实上，这并非小公司独有的情况，许多大型组织也时常面临微服务带来的资源压力。</p>\n<p>然而，资源预算并非无限。不久后，技术负责人通常会收到来自财务部门的成本预警，要求团队优化服务器使用。随后便是一轮常见的资源审查对话：</p>\n<blockquote>\n<ul>\n<li>“这个服务为何占用这么多实例？是资源消耗过大吗？”</li>\n<li>“其实主要是为了满足跨数据中心部署的冗余要求。”</li>\n<li>“它的服务对象是谁？流量很高吗？”</li>\n<li>“目前主要是内部开发团队在使用。”</li>\n<li>“那么负载均衡是必需的吗？能否缩减为单实例？”</li>\n<li>“……可以调整。”</li>\n</ul>\n</blockquote>\n<p>经过一系列类似的评估，部分资源得以缩减。这个案例清晰地揭示了一个普遍现象：<strong>微服务架构在提升灵活性的同时，往往伴随着服务器等基础设施资源消耗的成倍增长，这对成本控制与资源精细化管理提出了更高要求。</strong></p>\n<h2 id=\"36-痛点分布式事务\">3.6 痛点：分布式事务</h2>\n<p>在传统的单体架构中，一个典型的“下单”流程可以简洁地封装在一个数据库事务中：创建订单、扣减库存、生成交易单、记录财务应收款，这些步骤要么全部成功，要么全部回滚。若中途出错，系统可自动回滚并提示用户重试。</p>\n<p>但在微服务架构下，同一流程的各个步骤可能分散在不同的服务中，每个服务操作着独立的数据库。这便引入了经典的<strong>分布式事务难题</strong>，开发团队不得不直面以下复杂决策：</p>\n<ol>\n<li><strong>如何实现回滚？</strong> 若一个步骤失败，是否要触发全局回滚？若是，则每个参与服务都必须实现相应的补偿（回滚）逻辑。那么，补偿操作本身失败又该如何？是否需要为“回滚操作”再设计回滚？或者，是否只对部分核心操作进行回滚？其边界又该如何划定？</li>\n<li><strong>是否采用重试与异步？</strong> 是否放弃回滚，改为让失败的操作自动重试？这通常意味着将同步调用改为异步。但如果异步调用超时，前端用户该如何感知？此时可能已产生部分更新的数据，又该如何补救？</li>\n</ol>\n<p>如果这只是少数特定场景的挑战，或许尚可应对。但问题在于，在微服务体系内，这类<strong>跨多个服务更新数据</strong>的场景几乎无处不在。如果每个场景都需要投入大量时间来设计、实现并沟通一套复杂的一致性逻辑，整个团队的开发效率与心力都将承受巨大负担。</p>\n<p>因此，在实践中，许多团队会权衡利弊，在大量非核心场景下采取一种更为务实的策略：<strong>优先保证核心“成功路径”的畅通</strong>。即默认跨服务调用均会成功，若某一步调用失败，则系统捕获异常、记录详细日志，后续由运维或开发人员线下人工处理数据不一致的问题。</p>\n<p>这种策略上线后，在真实的生产环境中，由于网络抖动、服务瞬时不可用等情况难以完全避免，常会出现“上游数据已变更，下游数据未更新”的<strong>数据不一致</strong>状态。</p>\n<p>分布式事务一直是微服务架构中公认的核心挑战与设计难点。在经历多次线上问题后，团队通常会下定决心，必须系统性地解决这一问题。我们将在后续章节专门探讨相关的成熟解决方案与架构模式</p>\n<h2 id=\"37-痛点服务之间的依赖\">3.7 痛点：服务之间的依赖</h2>\n<p>在软件设计中，我们通常遵循类与类之间避免循环依赖的原则，从而形成清晰的层次结构。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133144-1233010375.jpg\" /></p>\n<p>然而，当我们将这种依赖关系映射到微服务时，情况往往变得复杂。</p>\n<p>例如，商品系统需要根据门店类型设置不同价格，因此它需要调用门店系统的接口，这就产生了对门店服务的依赖。同时，门店系统需要管理商品库存，又必须依赖商品系统提供的商品基础信息。如此一来，两者便形成了<strong>循环依赖</strong>。</p>\n<p>再以底层的财务系统为例。理论上，它作为核心支撑系统，应尽可能独立。但现实中，它必须依赖订单服务（以明确费用来源）、会员服务（明确付款方）和门店服务（明确收款方）。随着业务需求不断叠加，服务间的依赖关系最终会演变成一张<strong>盘根错节、难以理清</strong>的网状结构，如图所示。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133199-1121810109.jpg\" /></p>\n<p>这种“你中有我，我中有你”的复杂依赖通常会引发两类典型问题：</p>\n<p><strong>1. 评估影响面时，牵一发而动全身</strong><br />\n某次，团队需要重构两个已上线的服务。由于此前线上出现过严重故障，技术负责人要求必须全面评估重构的影响范围。最初有方案提议，通过代码调用链逐级追溯所有上游服务，但因分析成本过高、易有遗漏而被否决。</p>\n<p>随后采用的方案是基于全链路日志，分析出这两个服务的所有直接与间接上游依赖。评估结果令人咋舌：超过半数的微服务都会受到影响。这直接导致在项目上线前的关键几天，大量无关团队的开发人员不得不一同加班，进行大规模的回归测试。</p>\n<p><strong>2. 为隔离影响，导致版本泛滥</strong><br />\n吸取了上述教训后，团队在面对新的重构需求时，转而采用一种“保险”策略：不直接修改原有服务（如 <code>abcServiceV1</code>），而是直接开发一个全新的 <code>abcServiceV2</code>。新代码调用V2，旧代码继续使用V1，计划在未来再下线V1。</p>\n<p>这种策略短期内避免了大规模协调，但却导致了服务数量的激增。更重要的是，开发人员很少真正去下线那些陈旧的V1服务。长此以往，系统里充斥着大量并存的新旧版本服务，使得维护复杂度不降反增。</p>\n<p>服务依赖治理是一项持续挑战，我们将在后续探讨相应的解决方案。</p>\n<h2 id=\"38-痛点联调的痛苦\">3.8 痛点：联调的痛苦</h2>\n<p>微服务架构显著改变了项目的协作节奏。以往的需求排期相对线性，而引入微服务后，则必须在开发前增加 <strong>“接口设计”</strong> 环节，在开发后增加 <strong>“服务联调”</strong> 环节。</p>\n<p>因此，每逢紧急需求，大家最关心的问题往往变成了：“接口文档好了吗？”“联调什么时候能开始？”之所以如此在意，是因为在软件项目中，最大的进度风险往往不是技术实现，而是<strong>跨团队的沟通与协调</strong>。</p>\n<p><strong>案例一：计划因他人优先级而延误</strong><br />\n门店系统有一个小改动，需要商品团队提供一个简单接口。商品团队回复：“手头有别的项目，周二可以给接口。”门店团队据此排期：周二对接，周三联调，周四、五测试，预计周五上线。</p>\n<p>然而，周二当天，商品团队的主项目突发紧急需求，必须通宵处理，承诺的接口无法交付。于是，门店团队整个上线计划被迫推迟。这类因他人优先级变动导致的延误，在实际开发中屡见不鲜。</p>\n<p><strong>案例二：大规模项目中的协调噩梦</strong><br />\n一个涉及30个服务、300多个接口的大型项目，在需求评审后，仅<strong>核对这300多个接口的文档</strong>就花费了两周时间。紧接着，协调十几个项目组安排联调时间，又耗去3天。</p>\n<p>尽管在开发过程中接口仍可能有微调，但前期的对齐确保了各团队在大致正确的方向上推进。真正的耗时大户是联调阶段，大量时间消耗在低效的沟通上：</p>\n<blockquote>\n<ul>\n<li>“你的接口怎么返回404？”</li>\n<li>“哦，环境部署错了，稍等。”</li>\n<li>“这个接口需要加个时间字段。”</li>\n<li>“可以，但我手头有别的活，明天给你行吗？”</li>\n<li>“不行啊，今天必须调完。”</li>\n</ul>\n</blockquote>\n<p>每个接口的联调都可能经历类似的拉锯。当300多个接口都需要如此协调，且各团队优先级不一致时，联调所花费的时间甚至可能与功能开发本身相当。</p>\n<p>如何提升联调效率，是一个亟待解决的问题。关于这个痛点，将在后面的文章会给出解决方案。</p>\n<h2 id=\"39-痛点部署上的难题\">3.9 痛点：部署上的难题</h2>\n<p>在单体架构时代，开发者可以在本地完整部署整个系统进行调试。但在微服务架构下，动辄涉及十几个服务，本地部署在资源（如内存）和知识层面都变得不可行。</p>\n<p>常见的解决方案是搭建一套共享的<strong>中心化联调环境</strong>，让开发者将本地开发的服务接入其中，与其他远程服务进行联调。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251231105133154-236769282.jpg\" /></p>\n<p>然而，这种环境本身问题重重：</p>\n<p><strong>1. 数据状态残缺不全</strong><br />\n联调环境中的数据多是各开发者随意构造的“脏数据”，缺乏业务完整性。经常出现订单没有对应的收款单，或审批流程单据缺失等情况，导致端到端的业务流程根本无法走通。</p>\n<p><strong>2. 服务调用指向错误</strong><br />\n调试时经常发现接口字段缺失或报错，经过冗长的排查，最后发现原因可能是：“哦，我本地服务注册到联调环境时，不小心覆盖了别人刚部署的稳定版本”，或者“我调用的其实是另一个同事正在开发的、不稳定的服务实例”。</p>\n<p><strong>3. 环境极度不稳定</strong><br />\n由于开发者在频繁地部署和接入自己尚不稳定的服务，整个联调环境的状态时刻在波动，极其脆弱。它通常只能用于接口间的<strong>局部调试</strong>，而无法支持完整的业务流程验证。</p>\n<p>能否便捷地创建一套相对独立、稳定的测试环境？我们将在后面的文章中探讨相关的解决方案。</p>\n<h1 id=\"4-小结\">4 小结</h1>\n<p>至此，我们详细剖析了微服务的九大核心痛点。回顾一下，我们之前只列举了它的5点优势，却花了更多篇幅讨论其9个痛点。这或许会引发一个根本性的疑问：<strong>既然有这么多问题，为什么我们还要采用微服务？</strong></p>\n<p>作为一个技术人，笔者完全理解开发者对尝试新技术的热情。从个人成长角度，使用前沿技术能带来巨大的学习动力和职业资本。曾经，我和同事们也常抱怨领导过于保守，坚持使用“过时”的技术栈。</p>\n<p>然而，当角色转变为需要对团队乃至公司技术栈负责时，视角会发生变化。你必须冷静权衡：新旧系统兼容的额外维护成本、团队学习新技术的曲线与试错成本，这些往往是个体开发者难以充分感知的。正如一位同事的犀利点评：“程序员用三年学新技术、做迁移，三年后又有更新的技术出现，留下的技术债谁来偿还？个人凭借新技术跳槽获得了更高职位，那公司的烂摊子谁来接手？”</p>\n<p><strong>笔者并非反对技术进步，而是倡导对任何技术都应抱有敬畏之心——不仅要清楚其优势，更要透彻了解其代价与局限。</strong></p>\n<p>那么，回到最初的问题：为何仍需微服务？答案其实很朴素：对于持续复杂化的业务，单体架构终将演进到<strong>无论投入多少人力都无法高效迭代</strong>的境地。而微服务架构，尽管伴随诸多挑战，但至少能通过<strong>增加人手、分而治之</strong>的方式来维持系统的迭代能力与发展弹性。</p>\n<p>这正是我们忍受其痛点、并致力于解决这些痛点的根本原因。接下来，我们将进入微服务进阶实战场景，探讨如何系统性地应对本章所提及的各项挑战。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 10:54</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yhup\">yihuiComeOn</a>&nbsp;\n阅读(<span id=\"post_view_count\">106</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "CodeSpirit 多语言国际化使用指南（Beta）",
      "link": "https://www.cnblogs.com/codelove/p/19417730",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/codelove/p/19417730\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 09:12\">\n    <span>CodeSpirit 多语言国际化使用指南（Beta）</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"-概述\">📋 概述</h2>\n<p>CodeSpirit 框架现已支持完整的前后端多语言国际化功能，提供中英文双语支持，基于 .NET 资源文件和 AMIS locale，通过 Settings 组件实现全局、租户、用户三级语言配置。</p>\n<p><strong>版本</strong>: v1.0.0<br />\n<strong>支持语言</strong>: 简体中文（zh-CN）、英文（en）<br />\n<strong>更新日期</strong>: 2025年12月28日</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251229184550117-1365827054.png\" /></p>\n<ul>\n<li>Github：xin-lai/CodeSpirit</li>\n<li>Gitee：magicodes/CodeSpirit</li>\n</ul>\n<h2 id=\"-核心特性\">🎯 核心特性</h2>\n<ul>\n<li>✅ <strong>双语支持</strong>：中文（默认）+ 英文</li>\n<li>✅ <strong>全栈覆盖</strong>：后端 API + 前端 UI</li>\n<li>✅ <strong>多级配置</strong>：系统默认 → 租户默认 → 用户偏好</li>\n<li>✅ <strong>类型安全</strong>：使用 .resx 资源文件，编译时强类型访问</li>\n<li>✅ <strong>动态切换</strong>：用户可实时切换语言，无需重新登录</li>\n<li>✅ <strong>AMIS 兼容</strong>：集成 AMIS 的 locale 机制</li>\n<li>✅ <strong>DataAnnotations 支持</strong>：验证特性自动本地化</li>\n<li>✅ <strong>DTO描述多语言</strong>：支持字段描述信息的多语言</li>\n<li>✅ <strong>零侵入</strong>：无需修改业务表结构，基于 Settings 组件</li>\n</ul>\n<h2 id=\"️-架构设计\">🏗️ 架构设计</h2>\n<h3 id=\"语言解析优先级\">语言解析优先级</h3>\n<pre><code>Cookie（用户手动切换）\n    ↓ (未设置)\nUser Settings（用户偏好）\n    ↓ (未设置)\nTenant Settings（租户默认）\n    ↓ (未设置)\nGlobal Settings（系统默认）\n    ↓ (未设置)\nzh-CN（最终回退）\n</code></pre>\n<h3 id=\"settings-存储结构\">Settings 存储结构</h3>\n<pre><code class=\"language-csharp\">// 全局默认语言\nModule: \"Localization\"\nKey: \"DefaultLanguage\"\nValue: \"zh-CN\"\nScope: Global\n\n// 租户默认语言\nModule: \"Localization\"\nKey: \"DefaultLanguage\"\nValue: \"en\"\nScope: Tenant\nScopeId: \"{tenantId}\"\n\n// 用户偏好语言\nModule: \"Localization\"\nKey: \"PreferredLanguage\"\nValue: \"en\"\nScope: User\nScopeId: \"{userId}\"\n</code></pre>\n<h2 id=\"-快速开始\">🚀 快速开始</h2>\n<h3 id=\"1-配置已完成\">1. 配置已完成</h3>\n<p>本地化服务已在 <code>ServiceDefaults</code> 中自动注册，无需额外配置。</p>\n<h3 id=\"2-后端使用\">2. 后端使用</h3>\n<h4 id=\"在-controller-中使用本地化\">在 Controller 中使用本地化</h4>\n<pre><code class=\"language-csharp\">using CodeSpirit.Localization.Resources;\nusing Microsoft.Extensions.Localization;\n\npublic class MyController : ApiControllerBase\n{\n    private readonly IStringLocalizer&lt;SharedResources&gt; _localizer;\n    \n    public MyController(IStringLocalizer&lt;SharedResources&gt; localizer)\n    {\n        _localizer = localizer;\n    }\n    \n    [HttpPost]\n    public IActionResult Create()\n    {\n        return Ok(new ApiResponse \n        { \n            Status = 1, \n            Msg = _localizer[\"Common.Save\"].Value \n        });\n    }\n}\n</code></pre>\n<h4 id=\"抛出本地化异常\">抛出本地化异常</h4>\n<pre><code class=\"language-csharp\">// 使用资源键\nthrow new BusinessException(\"Errors.InvalidStartTime\");\n\n// 带参数\nthrow new ValidationException(\"Errors.NotFound\", resourceId);\n</code></pre>\n<h3 id=\"3-dto-验证特性多语言\">3. DTO 验证特性多语言</h3>\n<pre><code class=\"language-csharp\">using CodeSpirit.Localization.Resources;\n\npublic class CreateQuestionDto\n{\n    [Display(Name = \"Content\", ResourceType = typeof(DisplayResources))]\n    [Required(ErrorMessageResourceType = typeof(ValidationResources), \n             ErrorMessageResourceName = \"Required\")]\n    [StringLength(2000, \n        ErrorMessageResourceType = typeof(ValidationResources),\n        ErrorMessageResourceName = \"StringLengthMax\")]\n    public string Content { get; set; } = string.Empty;\n}\n</code></pre>\n<p><strong>验证错误示例</strong>：</p>\n<p>中文环境：<code>题目内容不能为空</code><br />\n英文环境：<code>Content is required</code></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251229184639734-1657824800.png\" /></p>\n<h3 id=\"4-dto-描述信息多语言\">4. DTO 描述信息多语言</h3>\n<p>DTO 字段的描述信息（Description）也支持多语言，通过 <code>LocalizedDescriptionAttribute</code> 实现。</p>\n<h4 id=\"41-创建服务资源文件\">4.1 创建服务资源文件</h4>\n<p>各服务应创建自己的资源文件，保持服务独立性：</p>\n<p><strong>资源文件结构</strong>：</p>\n<pre><code>CodeSpirit.ExamApi/Resources/\n  ├── ExamDisplayResources.cs    # 资源占位类（包含ResourceManager）\n  ├── ExamDisplay.resx           # 中文资源\n  └── ExamDisplay.en.resx        # 英文资源\n</code></pre>\n<p><strong>资源键命名规范</strong>：</p>\n<ul>\n<li>DTO字段描述：<code>Description.{EntityName}.{PropertyName}</code></li>\n<li>示例：<code>Description.Question.Options</code>、<code>Description.Question.CorrectAnswer</code></li>\n</ul>\n<h4 id=\"42-在dto中使用\">4.2 在DTO中使用</h4>\n<pre><code class=\"language-csharp\">using CodeSpirit.Core.Attributes;\nusing CodeSpirit.ExamApi.Resources;\n\npublic class CreateQuestionDto\n{\n    [LocalizedDescription(\n        \"根据题目内容生成合适的选项\",  // 回退文本（可选）\n        ResourceKey = \"Description.Question.Options\",\n        ResourceType = typeof(ExamDisplayResources)\n    )]\n    public List&lt;string&gt; Options { get; set; }\n}\n</code></pre>\n<p><strong>使用方式</strong>：</p>\n<ul>\n<li><strong>方式1</strong>：仅使用资源键（推荐）</li>\n<li><strong>方式2</strong>：带回退文本（更安全，资源不可用时显示回退文本）</li>\n<li><strong>方式3</strong>：使用共享资源（仅适用于通用描述）</li>\n</ul>\n<h4 id=\"43-向后兼容\">4.3 向后兼容</h4>\n<p>现有的 <code>DescriptionAttribute</code> 仍然可以正常使用，系统会优先检查 <code>LocalizedDescriptionAttribute</code>，如果不存在则回退到 <code>DescriptionAttribute</code>。</p>\n<h4 id=\"44-资源文件组织原则\">4.4 资源文件组织原则</h4>\n<ul>\n<li><strong>共享资源</strong>：<code>CodeSpirit.Localization/Resources/</code> - 存放真正通用的、跨服务的资源</li>\n<li><strong>服务资源</strong>：<code>ApiServices/{ServiceName}/Resources/</code> - 存放服务特有的业务资源</li>\n</ul>\n<p><strong>最佳实践</strong>：</p>\n<ul>\n<li>各服务管理自己的资源文件，避免在共享资源中放置服务特定内容</li>\n<li>遵循 <code>Description.{EntityName}.{PropertyName}</code> 命名约定</li>\n<li>建议提供回退文本，确保资源不可用时仍能显示</li>\n</ul>\n<h4 id=\"45-技术实现\">4.5 技术实现</h4>\n<p>描述多语言的资源解析由 AMIS 表单生成时统一处理：</p>\n<ul>\n<li><strong>CultureResolver</strong>：从 HttpContext Features、Cookie 等多个来源获取当前语言</li>\n<li><strong>统一解析</strong>：<code>GetLocalizedDescription</code> 方法在表单生成时解析资源</li>\n<li><strong>回退机制</strong>：英文环境下确保正确加载英文资源，避免回退到中文</li>\n<li><strong>缓存优化</strong>：在同一请求中复用已解析的文化信息</li>\n</ul>\n<h3 id=\"5-前端使用\">5. 前端使用</h3>\n<h4 id=\"javascript\">JavaScript</h4>\n<pre><code class=\"language-javascript\">// 获取翻译文本\nconst message = CodeSpirit.i18n.t('Common.Save');\n\n// 带参数\nconst message = CodeSpirit.i18n.t('Validation.Required', { 0: '用户名' });\n\n// 切换语言\nCodeSpirit.i18n.switchLanguage('en');\n</code></pre>\n<h4 id=\"razor-页面\">Razor 页面</h4>\n<pre><code class=\"language-razor\">@using CodeSpirit.Localization.Resources\n@using Microsoft.Extensions.Localization\n@inject IStringLocalizer&lt;SharedResources&gt; Localizer\n\n&lt;h1&gt;@Localizer[\"Common.Save\"]&lt;/h1&gt;\n</code></pre>\n<h2 id=\"️-语言配置管理\">🎛️ 语言配置管理</h2>\n<h3 id=\"通过-api-设置语言\">通过 API 设置语言</h3>\n<p>系统已自动集成 Settings 组件，可以通过 Settings API 管理语言配置：</p>\n<h4 id=\"设置用户语言偏好\">设置用户语言偏好</h4>\n<pre><code class=\"language-csharp\">await _settingsService.SetUserSettingAsync(\n    module: \"Localization\",\n    key: \"PreferredLanguage\",\n    value: \"en\",\n    userId: currentUserId\n);\n</code></pre>\n<h4 id=\"设置租户默认语言\">设置租户默认语言</h4>\n<pre><code class=\"language-csharp\">await _settingsService.SetTenantSettingAsync(\n    module: \"Localization\",\n    key: \"DefaultLanguage\",\n    value: \"en\",\n    tenantId: currentTenantId\n);\n</code></pre>\n<h4 id=\"设置全局默认语言\">设置全局默认语言</h4>\n<pre><code class=\"language-csharp\">await _settingsService.SetGlobalSettingAsync(\n    module: \"Localization\",\n    key: \"DefaultLanguage\",\n    value: \"en\"\n);\n</code></pre>\n<h3 id=\"通过-ui-切换语言\">通过 UI 切换语言</h3>\n<p>用户可以在导航栏的语言切换器中选择语言，切换后会：</p>\n<ol>\n<li>设置 Cookie（<code>.AspNetCore.Culture</code>）</li>\n<li>刷新页面</li>\n<li>所有界面文本、错误消息自动切换为对应语言</li>\n</ol>\n<h2 id=\"-资源文件说明\">📚 资源文件说明</h2>\n<h3 id=\"共享资源localization组件\">共享资源（Localization组件）</h3>\n<table>\n<thead>\n<tr>\n<th>资源文件</th>\n<th>用途</th>\n<th>示例键</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Shared.resx</code></td>\n<td>通用 UI 文本</td>\n<td><code>Common.Save</code>, <code>Common.Cancel</code></td>\n</tr>\n<tr>\n<td><code>Errors.resx</code></td>\n<td>错误消息</td>\n<td><code>Errors.NotFound</code>, <code>Errors.Unauthorized</code></td>\n</tr>\n<tr>\n<td><code>Validation.resx</code></td>\n<td>验证消息模板</td>\n<td><code>Required</code>, <code>StringLengthMax</code></td>\n</tr>\n<tr>\n<td><code>Display.resx</code></td>\n<td>字段显示名称</td>\n<td><code>Content</code>, <code>Type</code>, <code>Difficulty</code></td>\n</tr>\n</tbody>\n</table>\n<p>每个资源文件都有对应的英文版本（如 <code>Shared.en.resx</code>）。</p>\n<h3 id=\"服务特定资源各api服务\">服务特定资源（各API服务）</h3>\n<p>各服务应创建自己的资源文件，保持服务独立性：</p>\n<p><strong>命名规范</strong>：</p>\n<ul>\n<li>占位类：<code>{ServiceName}DisplayResources.cs</code></li>\n<li>资源文件：<code>{ServiceName}Display.resx</code>、<code>{ServiceName}Display.en.resx</code></li>\n</ul>\n<p><strong>示例</strong>：</p>\n<pre><code>CodeSpirit.ExamApi/Resources/\n  ├── ExamDisplayResources.cs    # 资源占位类（包含ResourceManager）\n  ├── ExamDisplay.resx           # 中文资源\n  └── ExamDisplay.en.resx        # 英文资源\n\nCodeSpirit.SurveyApi/Resources/\n  ├── SurveyDisplayResources.cs\n  ├── SurveyDisplay.resx\n  └── SurveyDisplay.en.resx\n</code></pre>\n<p><strong>资源键命名约定</strong>：</p>\n<ul>\n<li>DTO字段描述：<code>Description.{EntityName}.{PropertyName}</code></li>\n<li>示例：<code>Description.Question.Options</code>、<code>Description.Survey.Title</code></li>\n</ul>\n<h2 id=\"-常见场景\">🔧 常见场景</h2>\n<h3 id=\"场景-1用户切换语言\">场景 1：用户切换语言</h3>\n<ol>\n<li>\n<p>用户在导航栏选择 \"English\"</p>\n</li>\n<li>\n<p>JavaScript 调用 <code>CodeSpirit.i18n.switchLanguage('en')</code></p>\n</li>\n<li>\n<p>设置 Cookie 并刷新页面</p>\n</li>\n<li>\n<p>所有内容显示为英文</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251229184704171-1071541876.png\" /></p>\n</li>\n</ol>\n<h3 id=\"场景-2租户设置默认语言\">场景 2：租户设置默认语言</h3>\n<ol>\n<li>租户管理员在设置中选择默认语言为英文</li>\n<li>系统通过 Settings API 保存配置</li>\n<li>该租户下的所有用户默认使用英文</li>\n<li>用户仍可以设置自己的语言偏好</li>\n</ol>\n<h3 id=\"场景-3api-返回本地化错误\">场景 3：API 返回本地化错误</h3>\n<pre><code class=\"language-csharp\">// 中文环境\nthrow new BusinessException(\"Errors.NotFound\");\n// API 返回: { \"status\": 0, \"msg\": \"未找到资源\" }\n\n// 英文环境  \nthrow new BusinessException(\"Errors.NotFound\");\n// API 返回: { \"status\": 0, \"msg\": \"Resource not found\" }\n</code></pre>\n<h2 id=\"-amis-多语言\">🌐 AMIS 多语言</h2>\n<p>AMIS 组件会自动根据当前语言加载对应的 locale 文件：</p>\n<ul>\n<li><strong>中文环境</strong>：使用默认的 zh-CN locale</li>\n<li><strong>英文环境</strong>：动态加载 <code>sdk/6.13.0/locale/en-US.js</code></li>\n</ul>\n<p>AMIS 内置组件（日期选择器、分页器等）会自动显示对应语言。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251229184723949-1878507554.png\" /></p>\n<h2 id=\"-导航组件多语言\">🧭 导航组件多语言</h2>\n<p>导航组件（<code>CodeSpirit.Navigation</code>）提供了完整的多语言支持，用于实现动态导航菜单的多语言切换。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/70544/202512/70544-20251229184735542-1462849359.png\" /></p>\n<h3 id=\"导航资源文件\">导航资源文件</h3>\n<p>导航组件使用专用的资源文件：</p>\n<p><strong>资源文件位置</strong>：</p>\n<pre><code>CodeSpirit.Navigation/Resources/\n  ├── NavigationResources.cs         # 资源占位类\n  ├── NavigationResources.resx       # 中文资源\n  └── NavigationResources.en.resx    # 英文资源\n</code></pre>\n<p><strong>资源键命名规范</strong>：</p>\n<ul>\n<li>模块名称：<code>Module.{ModuleName}</code>（如 <code>Module.Identity</code>、<code>Module.Survey</code>）</li>\n<li>控制器名称：<code>Controller.{ControllerName}</code>（如 <code>Controller.Users</code>、<code>Controller.Roles</code>）</li>\n</ul>\n<h3 id=\"在控制器中使用\">在控制器中使用</h3>\n<p>导航组件支持两种特性来配置多语言：<code>Module</code> 特性和 <code>NavigationAttribute</code> 特性。</p>\n<h4 id=\"使用-module-特性推荐\">使用 Module 特性（推荐）</h4>\n<p><code>Module</code> 特性用于定义模块级别的多语言配置，通常放在 <code>ApiControllerBase</code> 上：</p>\n<pre><code class=\"language-csharp\">using CodeSpirit.Core.Attributes;\nusing CodeSpirit.Core.Enums;\nusing CodeSpirit.Navigation.Resources;\n\n// 模块级配置（在 ApiControllerBase 上）\n[Module(\"identity\", \n    displayName: \"用户中心\",  // 回退文本\n    DisplayNameResourceKey = \"Module.Identity\",           // 资源键\n    DisplayNameResourceType = typeof(NavigationResources), // 资源类型\n    Icon = \"fa-solid fa-user-group\")]\n[Navigation(\n    Icon = \"fa-solid fa-user-group\", \n    PlatformType = PlatformType.Both,\n    TitleResourceKey = \"Module.Identity\",           // 与 Module 的资源键保持一致\n    TitleResourceType = typeof(NavigationResources)\n)]\npublic abstract class ApiControllerBase : CodeSpirit.Shared.Controllers.ApiControllerBase\n{\n}\n</code></pre>\n<h4 id=\"使用-navigationattribute-特性\">使用 NavigationAttribute 特性</h4>\n<p><code>NavigationAttribute</code> 用于控制器级别的多语言配置：</p>\n<pre><code class=\"language-csharp\">using CodeSpirit.Core.Attributes;\nusing CodeSpirit.Navigation.Resources;\nusing System.ComponentModel;\n\n// 控制器级配置\n[DisplayName(\"用户管理\")]\n[Navigation(\n    Icon = \"fa-solid fa-users\", \n    PlatformType = PlatformType.Tenant,\n    TitleResourceKey = \"Controller.Users\",\n    TitleResourceType = typeof(NavigationResources)\n)]\npublic class UsersController : ApiControllerBase\n{\n}\n</code></pre>\n<h3 id=\"配置要点\">配置要点</h3>\n<p><strong>Module 特性</strong>：</p>\n<ol>\n<li><strong>DisplayNameResourceKey</strong>：指定模块名称的资源键（必填）</li>\n<li><strong>DisplayNameResourceType</strong>：指定资源类型，通常为 <code>typeof(NavigationResources)</code>（必填）</li>\n<li><strong>displayName</strong>：回退文本，当资源不可用时显示（必填，建议提供）</li>\n</ol>\n<p><strong>NavigationAttribute 特性</strong>：</p>\n<ol>\n<li><strong>TitleResourceKey</strong>：指定资源键名称（推荐填写，与 Module 的 DisplayNameResourceKey 保持一致）</li>\n<li><strong>TitleResourceType</strong>：指定资源类型，通常为 <code>typeof(NavigationResources)</code>（推荐填写）</li>\n<li><strong>Title</strong>：回退文本，当资源不可用时显示（可选，建议提供）</li>\n</ol>\n<blockquote>\n<p><strong>最佳实践</strong>：在模块级配置中，建议在 <code>Navigation</code> 特性中也设置 <code>TitleResourceKey</code> 和 <code>TitleResourceType</code>，与 <code>Module</code> 特性的资源键保持一致，确保导航多语言功能完整可靠。</p>\n</blockquote>\n<h3 id=\"工作原理\">工作原理</h3>\n<ol>\n<li><strong>自动扫描</strong>：系统启动时，导航组件自动扫描所有控制器的 <code>NavigationAttribute</code></li>\n<li><strong>资源解析</strong>：根据当前语言（<code>CultureInfo.CurrentUICulture</code>）解析对应的资源文本</li>\n<li><strong>缓存机制</strong>：解析后的导航树缓存到分布式缓存（Redis），提升性能</li>\n<li><strong>动态切换</strong>：用户切换语言后，导航菜单会自动显示对应语言</li>\n</ol>\n<h3 id=\"️-重要注意事项\">⚠️ 重要注意事项</h3>\n<h4 id=\"1-缓存问题\">1. 缓存问题</h4>\n<p>导航组件使用分布式缓存来提升性能，但在以下情况下可能导致多语言不生效：</p>\n<p><strong>症状</strong>：切换语言后，导航菜单仍显示旧语言</p>\n<p><strong>原因</strong>：导航树已缓存，未重新解析多语言资源</p>\n<p><strong>解决方案</strong>：清空导航缓存</p>\n<h5 id=\"方法1通过缓存管理界面\">方法1：通过缓存管理界面</h5>\n<ol>\n<li>访问系统平台的<strong>缓存管理</strong>页面（路由：<code>/cacheManagement</code>）</li>\n<li>在缓存列表中搜索或找到导航缓存键：<code>CodeSpirit:Navigation:All</code></li>\n<li>点击该缓存项的\"删除\"按钮清空缓存</li>\n</ol>\n<blockquote>\n<p><strong>注意</strong>：缓存管理功能仅系统管理员可访问，属于系统平台功能。</p>\n</blockquote>\n<h5 id=\"方法2通过代码-api-调用\">方法2：通过代码 API 调用</h5>\n<pre><code class=\"language-csharp\">// 清空所有导航缓存\nawait _navigationService.ClearAllNavigationCacheAsync();\n\n// 清空特定模块缓存（实际上也会清空整个缓存）\nawait _navigationService.ClearModuleNavigationCacheAsync(\"Identity\");\n\n// 重新初始化导航树（清空并重建缓存）\nawait _navigationService.InitializeNavigationTree();\n</code></pre>\n<h5 id=\"方法3通过-http-api-调用\">方法3：通过 HTTP API 调用</h5>\n<pre><code class=\"language-bash\"># 清空所有导航缓存\nDELETE /api/navigation/cache\n\n# 清空特定模块缓存\nDELETE /api/navigation/cache?moduleName=Identity\n\n# 重新初始化导航树（清空并重建缓存）\nPOST /api/navigation/initialize\n</code></pre>\n<h4 id=\"2-资源文件编译\">2. 资源文件编译</h4>\n<p>确保资源文件正确配置为嵌入式资源：</p>\n<pre><code class=\"language-xml\">&lt;ItemGroup&gt;\n  &lt;EmbeddedResource Include=\"Resources\\NavigationResources.resx\"&gt;\n    &lt;Generator&gt;PublicResXFileCodeGenerator&lt;/Generator&gt;\n  &lt;/EmbeddedResource&gt;\n  &lt;EmbeddedResource Include=\"Resources\\NavigationResources.en.resx\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre>\n<h4 id=\"3-开发建议\">3. 开发建议</h4>\n<ul>\n<li><strong>模块配置</strong>：推荐同时使用 <code>Module</code> 和 <code>Navigation</code> 特性配置模块级多语言</li>\n<li><strong>回退文本</strong>：始终提供回退文本（<code>displayName</code>、<code>Title</code>），确保资源不可用时仍能显示</li>\n<li><strong>添加新导航项</strong>：添加后需清空缓存，确保新项生效</li>\n<li><strong>修改资源文本</strong>：修改后需重新编译项目，并清空缓存</li>\n<li><strong>测试多语言</strong>：切换语言后若不生效，优先检查缓存</li>\n<li><strong>资源键一致性</strong>：<code>Module</code> 的 <code>DisplayNameResourceKey</code> 和 <code>Navigation</code> 的 <code>TitleResourceKey</code> 通常使用相同的资源键</li>\n</ul>\n<h3 id=\"完整示例\">完整示例</h3>\n<p>以下是用户中心模块的完整多语言配置示例（来自实际代码）：</p>\n<pre><code class=\"language-csharp\">using CodeSpirit.Core;\nusing CodeSpirit.Core.Attributes;\nusing CodeSpirit.Core.Enums;\nusing CodeSpirit.Navigation.Resources;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.ComponentModel;\n\nnamespace CodeSpirit.IdentityApi.Controllers\n{\n    /// &lt;summary&gt;\n    /// 身份认证API控制器基类\n    /// &lt;/summary&gt;\n    [ApiController]\n    [Authorize(policy: \"DynamicPermissions\")]\n    [Route(\"api/identity/[controller]\")]\n    // 模块级配置（使用 Module 和 Navigation 特性）\n    [Module(\"identity\", \n        displayName: \"用户中心\",  // 回退文本\n        DisplayNameResourceKey = \"Module.Identity\",           // 资源键\n        DisplayNameResourceType = typeof(NavigationResources), // 资源类型\n        Icon = \"fa-solid fa-user-group\")]\n    [Navigation(\n        Icon = \"fa-solid fa-user-group\",\n        PlatformType = PlatformType.Both,\n        TitleResourceKey = \"Module.Identity\",\n        TitleResourceType = typeof(NavigationResources)\n    )]\n    public abstract class ApiControllerBase : CodeSpirit.Shared.Controllers.ApiControllerBase\n    {\n    }\n\n    /// &lt;summary&gt;\n    /// 用户管理控制器\n    /// &lt;/summary&gt;\n    [DisplayName(\"用户管理\")]\n    [Navigation(\n        Icon = \"fa-solid fa-users\", \n        PlatformType = PlatformType.Tenant,\n        TitleResourceKey = \"Controller.Users\",\n        TitleResourceType = typeof(NavigationResources)\n    )]\n    public class UsersController : ApiControllerBase\n    {\n        private readonly IUserService _userService;\n\n        public UsersController(IUserService userService)\n        {\n            _userService = userService;\n        }\n\n        /// &lt;summary&gt;\n        /// 获取用户列表\n        /// &lt;/summary&gt;\n        [HttpGet]\n        [DisplayName(\"获取用户列表\")]\n        public async Task&lt;ActionResult&lt;ApiResponse&lt;PageList&lt;UserDto&gt;&gt;&gt;&gt; GetUsers([FromQuery] UserQueryDto queryDto)\n        {\n            PageList&lt;UserDto&gt; users = await _userService.GetUsersAsync(queryDto);\n            return SuccessResponse(users);\n        }\n    }\n}\n</code></pre>\n<p><strong>资源文件内容</strong>：</p>\n<pre><code class=\"language-xml\">&lt;!-- NavigationResources.resx (中文) --&gt;\n&lt;data name=\"Module.Identity\"&gt;\n  &lt;value&gt;用户中心&lt;/value&gt;\n&lt;/data&gt;\n&lt;data name=\"Controller.Users\"&gt;\n  &lt;value&gt;用户管理&lt;/value&gt;\n&lt;/data&gt;\n\n&lt;!-- NavigationResources.en.resx (英文) --&gt;\n&lt;data name=\"Module.Identity\"&gt;\n  &lt;value&gt;User Center&lt;/value&gt;\n&lt;/data&gt;\n&lt;data name=\"Controller.Users\"&gt;\n  &lt;value&gt;User Management&lt;/value&gt;\n&lt;/data&gt;\n</code></pre>\n<h3 id=\"缓存键说明\">缓存键说明</h3>\n<p>导航组件使用以下缓存键：</p>\n<ul>\n<li><strong>缓存键</strong>：<code>CodeSpirit:Navigation:All</code></li>\n<li><strong>缓存策略</strong>：单一缓存 + 内存过滤</li>\n<li><strong>缓存时间</strong>：绝对过期 365 天，滑动过期 90 天</li>\n<li><strong>清空时机</strong>：\n<ul>\n<li>添加/修改导航项后</li>\n<li>修改资源文件后</li>\n<li>切换语言不生效时</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"-扩展支持\">📊 扩展支持</h2>\n<h3 id=\"添加新语言如日文\">添加新语言（如日文）</h3>\n<ol>\n<li><strong>更新配置</strong>：在 <code>appsettings.json</code> 中添加</li>\n</ol>\n<pre><code class=\"language-json\">{\n  \"Localization\": {\n    \"SupportedCultures\": [\n      { \"Code\": \"zh-CN\", \"DisplayName\": \"简体中文\" },\n      { \"Code\": \"en\", \"DisplayName\": \"English\" },\n      { \"Code\": \"ja\", \"DisplayName\": \"日本語\" }\n    ]\n  }\n}\n</code></pre>\n<ol start=\"2\">\n<li>\n<p><strong>添加资源文件</strong>：</p>\n<ul>\n<li><code>Shared.ja.resx</code></li>\n<li><code>Errors.ja.resx</code></li>\n<li><code>Validation.ja.resx</code></li>\n<li><code>Display.ja.resx</code></li>\n</ul>\n</li>\n<li>\n<p><strong>下载 AMIS locale</strong>：将 <code>ja-JP.js</code> 放到 <code>wwwroot/sdk/6.13.0/locale/</code></p>\n</li>\n<li>\n<p><strong>更新语言切换器</strong>：在 <code>MainNav.razor</code> 中添加日语选项</p>\n</li>\n</ol>\n<h2 id=\"️-配置说明\">⚙️ 配置说明</h2>\n<h3 id=\"appsettingsjson-配置\">appsettings.json 配置</h3>\n<pre><code class=\"language-json\">{\n  \"Localization\": {\n    \"DefaultCulture\": \"zh-CN\",\n    \"SupportedCultures\": [\n      { \"Code\": \"zh-CN\", \"DisplayName\": \"简体中文\" },\n      { \"Code\": \"en\", \"DisplayName\": \"English\" }\n    ],\n    \"EnableTenantLevelLanguage\": true,\n    \"EnableUserLevelLanguage\": true,\n    \"FallbackToParentCultures\": true,\n    \"SettingsModule\": \"Localization\",\n    \"SettingsKeys\": {\n      \"GlobalDefault\": \"DefaultLanguage\",\n      \"TenantDefault\": \"DefaultLanguage\",\n      \"UserPreference\": \"PreferredLanguage\"\n    }\n  }\n}\n</code></pre>\n<h2 id=\"-ui-组件\">🎨 UI 组件</h2>\n<h3 id=\"语言切换器\">语言切换器</h3>\n<p>位置：<code>Src/CodeSpirit.Web/Components/Shared/MainNav.razor</code></p>\n<p>用户点击下拉框选择语言，系统会：</p>\n<ol>\n<li>设置 Cookie</li>\n<li>刷新页面</li>\n<li>应用新语言到所有界面元素</li>\n</ol>\n<h2 id=\"-最佳实践\">📖 最佳实践</h2>\n<h3 id=\"1-资源键命名规范\">1. 资源键命名规范</h3>\n<ul>\n<li>使用点号分隔类别：<code>Errors.NotFound</code>, <code>Common.Save</code></li>\n<li>使用 PascalCase：<code>StringLengthMax</code>, <code>ValidationError</code></li>\n<li>避免重复前缀：✅ <code>Errors.NotFound</code> ❌ <code>Errors.ErrorsNotFound</code></li>\n</ul>\n<h3 id=\"2-参数化消息\">2. 参数化消息</h3>\n<pre><code class=\"language-csharp\">// 资源文件\n&lt;data name=\"UserCreated\"&gt;&lt;value&gt;用户 {0} 创建成功&lt;/value&gt;&lt;/data&gt;\n\n// 使用\n_localizer[\"UserCreated\", username]\n</code></pre>\n<h3 id=\"3-向后兼容\">3. 向后兼容</h3>\n<p>现有硬编码中文的代码继续正常工作：</p>\n<pre><code class=\"language-csharp\">// 旧代码（继续工作）\nthrow new BusinessException(\"未找到资源\");\n\n// 新代码（支持多语言）\nthrow new BusinessException(\"Errors.NotFound\");\n</code></pre>\n<h2 id=\"-故障排查\">🔍 故障排查</h2>\n<h3 id=\"资源键未找到\">资源键未找到</h3>\n<p>如果资源键不存在，系统会返回键名本身，不会抛出异常。</p>\n<h3 id=\"语言未生效\">语言未生效</h3>\n<ol>\n<li>检查 Settings 配置是否正确</li>\n<li>确认 Cookie 是否设置成功</li>\n<li>查看日志中的语言解析过程</li>\n</ol>\n<h3 id=\"资源文件未生成\">资源文件未生成</h3>\n<p>确保项目文件中配置了资源文件生成器：</p>\n<pre><code class=\"language-xml\">&lt;EmbeddedResource Update=\"Resources\\Shared.resx\"&gt;\n    &lt;Generator&gt;PublicResXFileCodeGenerator&lt;/Generator&gt;\n&lt;/EmbeddedResource&gt;\n</code></pre>\n<h2 id=\"-相关文档\">📘 相关文档</h2>\n<ul>\n<li><a href=\"https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/localization\" rel=\"noopener nofollow\" target=\"_blank\">ASP.NET Core 全球化和本地化</a></li>\n<li><a href=\"https://aisuda.bce.baidu.com/amis/zh-CN/docs/extend/i18n\" rel=\"noopener nofollow\" target=\"_blank\">AMIS 国际化文档</a></li>\n<li><a href=\"../Components/CodeSpirit.Settings/README.md\" rel=\"noopener nofollow\" target=\"_blank\">CodeSpirit Settings 组件</a></li>\n</ul>\n<h2 id=\"-faq\">💡 FAQ</h2>\n<h3 id=\"q-如何为某个用户永久设置语言\">Q: 如何为某个用户永久设置语言？</h3>\n<p>A: 通过 Settings API 设置用户级配置，系统会自动持久化到数据库。</p>\n<h3 id=\"q-amis-组件的多语言如何工作\">Q: AMIS 组件的多语言如何工作？</h3>\n<p>A: 系统会根据当前语言自动加载对应的 AMIS locale 文件（如 <code>en-US.js</code>），AMIS 内置组件会自动显示对应语言。</p>\n<h3 id=\"q-可以为不同租户设置不同的默认语言吗\">Q: 可以为不同租户设置不同的默认语言吗？</h3>\n<p>A: 可以。通过 Settings API 为每个租户设置 <code>Localization.DefaultLanguage</code>，该租户下的所有用户默认使用该语言（用户仍可自定义）。</p>\n<h3 id=\"q-如何添加更多语言\">Q: 如何添加更多语言？</h3>\n<p>A:</p>\n<ol>\n<li>在 <code>appsettings.json</code> 添加语言配置</li>\n<li>创建对应的资源文件（如 <code>Shared.ja.resx</code>）</li>\n<li>下载 AMIS locale 文件</li>\n<li>在语言切换器添加选项</li>\n</ol>\n<p>无需修改任何代码逻辑。</p>\n<h2 id=\"-dto描述多语言常见问题\">📝 DTO描述多语言常见问题</h2>\n<h3 id=\"q-如何为dto字段添加多语言描述\">Q: 如何为DTO字段添加多语言描述？</h3>\n<p>A: 使用 <code>LocalizedDescriptionAttribute</code>，指定 <code>ResourceKey</code> 和 <code>ResourceType</code>：</p>\n<pre><code class=\"language-csharp\">[LocalizedDescription(\n    ResourceKey = \"Description.Question.Options\",\n    ResourceType = typeof(ExamDisplayResources)\n)]\npublic List&lt;string&gt; Options { get; set; }\n</code></pre>\n<h3 id=\"q-资源文件找不到怎么办\">Q: 资源文件找不到怎么办？</h3>\n<p>A: 检查以下几点：</p>\n<ol>\n<li>资源文件是否正确嵌入（检查 <code>.csproj</code> 配置）</li>\n<li>资源键名称是否正确</li>\n<li>资源类型是否正确引用</li>\n<li>如果配置了回退文本，会使用回退文本</li>\n</ol>\n<h3 id=\"q-可以在运行时动态切换语言吗\">Q: 可以在运行时动态切换语言吗？</h3>\n<p>A: 可以。<code>LocalizedDescriptionAttribute</code> 会根据 <code>CultureInfo.CurrentUICulture</code> 自动获取对应语言的资源。语言切换由 <code>CodeSpirit.Localization</code> 组件的中间件处理。</p>\n<h3 id=\"q-导航组件支持哪些多语言配置方式\">Q: 导航组件支持哪些多语言配置方式？</h3>\n<p>A: 导航组件支持两种配置方式：</p>\n<ol>\n<li><strong>推荐方式</strong>：使用 <code>NavigationAttribute</code> 的 <code>TitleResourceKey</code> 和 <code>TitleResourceType</code></li>\n</ol>\n<pre><code class=\"language-csharp\">[Navigation(\n    TitleResourceKey = \"Controller.Users\",\n    TitleResourceType = typeof(NavigationResources)\n)]\n</code></pre>\n<ol start=\"2\">\n<li><strong>向后兼容</strong>：使用 <code>DisplayAttribute</code> 的 <code>Name</code> 和 <code>ResourceType</code></li>\n</ol>\n<pre><code class=\"language-csharp\">[Display(\n    Name = \"Controller.Users\",\n    ResourceType = typeof(NavigationResources)\n)]\n</code></pre>\n<p>如果同时配置了两者，<code>NavigationAttribute</code> 的配置优先级更高。</p>\n\n</div>\n<div id=\"MySignature\">\n    作者：<a href=\"http://www.cnblogs.com/codelove/\" target=\"_blank\">雪雁</a><br />出处：<a href=\"http://www.cnblogs.com/codelove/\" target=\"_blank\">http://www.cnblogs.com/codelove/</a>\n<br />如果喜欢作者的文章，请关注【CodeSpirit-码灵】公众号以便第一时间获得最新内容。本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。<br /><b>静听鸟语花香，漫赏云卷云舒。</b>\n<br />\n<img height=\"100\" src=\"https://images.cnblogs.com/cnblogs_com/codelove/315887/o_251224070213_%E5%85%AC%E4%BC%97%E5%8F%B7.jpg\" width=\"100\" />\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 09:12</span>&nbsp;\n<a href=\"https://www.cnblogs.com/codelove\">雪雁</a>&nbsp;\n阅读(<span id=\"post_view_count\">36</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一文理清FastAPI参数：从Query、Path到BaseModel的实战指南",
      "link": "https://www.cnblogs.com/ymtianyu/p/19424375",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19424375\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 08:57\">\n    <span>一文理清FastAPI参数：从Query、Path到BaseModel的实战指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文系统讲解了FastAPI中的核心参数类型，包括查询参数、路径参数以及请求体参数（JSON与表单）的定义、区别和使用方法。重点介绍了利用Pydantic BaseModel进行结构化数据验证和管理的优势与实践，并通过混合参数示例和完整代码展示了如何构建清晰、健壮且文档完善的API接口。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<p style=\"font-size: 18px; font-weight: bold; color: rgba(26, 26, 26, 1);\">刚学 FastAPI，是不是总被路径参数、查询参数、请求体这些概念绕晕，不知道数据从哪儿来、该怎么接？事实上，<strong style=\"color: rgba(186, 55, 42, 1);\">正确使用参数声明，能让你的 API 代码量减少一半，且自动获得完美的交互文档。</strong></p>\n<blockquote style=\"padding-left: 15px; margin: 20px 0; color: rgba(102, 102, 102, 1); font-style: italic;\">本文带你一次搞懂 FastAPI 中的所有核心参数类型：从简单的查询字符串（?name=value），到定义URL片段的路径参数，再到处理复杂 JSON 或表单数据的请求体。重点深入 Pydantic BaseModel，教你如何用它优雅地定义、验证和组织复杂数据，并自动生成 API 文档。读完你就能清晰地规划 API 的数据接口了。 <br /><br />- ✨ 查询参数与路径参数：基础与区别<br />- 📦 请求体参数：JSON (Body) 与 表单 (Form) 处理<br />- 🧩 混合参数：路径、查询、请求体同时使用<br />- 🏗️ 结构化利器：Pydantic BaseModel 详解与应用<br />- 🚀 完整实战示例与代码参考</blockquote>\n<h2 style=\"padding-bottom: 10px; margin-top: 40px;\">✨ 查询参数与路径参数：地基要打牢</h2>\n<p>这是两种最基础、最常用的参数，都直接体现在 URL 中。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">查询参数（Query Parameters）</strong>：跟在 URL 问号<code>?</code>后面，格式为<code>key1=value1&amp;key2=value2</code>。在 FastAPI 中，函数参数<strong>不是路径的一部分</strong>的，默认就是查询参数。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI\napp = FastAPI()\n\n@app.get(\"/items/\")\nasync def read_items(skip: int = 0, limit: int = 10):\n    # `skip`和`limit`就是查询参数，如：/items/?skip=20&amp;limit=5\n    return {\"skip\": skip, \"limit\": limit}</code></pre>\n<p>使用 <code>skip: int = 0</code> 形式，就定义了带默认值的可选参数。如果没有默认值（如 <code>name: str</code>），它就是必需的查询参数。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">路径参数（Path Parameters）</strong>：直接是 URL 路径的一部分，用花括号<code>{}</code>声明。通常用于唯一标识资源，比如根据ID获取某篇文章。</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):  # item_id 是路径参数\n    return {\"item_id\": item_id}</code></pre>\n<p>注意它们的顺序！如果把 <code>/items/{item_id}</code> 和 <code>/items/me</code> 两个端点都定义，<strong style=\"color: rgba(186, 55, 42, 1);\">要把具体的路径（<code>/items/me</code>）放在前面</strong>，否则<code>me </code>会被当成<code>item_id</code>的值。</p>\n<h2 style=\"padding-bottom: 10px; margin-top: 40px;\">📦 请求体参数：处理复杂数据</h2>\n<p>当你需要客户端发送较多数据（如创建新文章）时，就需要请求体。FastAPI 用 <code>Body()</code>, <code>Form()</code> 等工具函数来声明。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">JSON 请求体（Body）</strong>：最常见的 REST API 数据格式。使用 Pydantic 的 <code>BaseModel</code> 是最佳实践（下文详解），也可用 <code>Body()</code> 直接声明多个参数。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Body\n\n@app.put(\"/items/{item_id}\")\nasync def update_item(\n    item_id: int,\n    name: str = Body(...),  # Body(...) 表示必需项\n    description: str = Body(None)  # Body(None) 表示可选项\n):\n    return {\"item_id\": item_id, \"name\": name, \"description\": description}</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">表单数据（Form）</strong>：当数据来自 HTML 表单或需要上传文件时使用。如何要上传大文件，需要先安装 <code>python-multipart</code>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Form\n\n@app.post(\"/login/\")\nasync def login(username: str = Form(...), password: str = Form(...)):\n    return {\"username\": username}</code></pre>\n<h2 style=\"padding-bottom: 10px; margin-top: 40px;\">🧩 混合参数：自由组合，各司其职</h2>\n<p>FastAPI 能智能地区分参数来源，你可以同时使用路径、查询和请求体参数。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Path, Query, Body\n\n@app.put(\"/mixed-items/{item_id}\")\nasync def update_mixed_item(\n    *,\n    item_id: int = Path(..., title=\"商品ID\", ge=1),  # 路径参数，&gt;=1\n    q: str = Query(None, alias=\"query-string\"),      # 可选查询参数，别名\n    item: dict = Body(...)                           # 必需的JSON请求体\n):\n    results = {\"item_id\": item_id}\n    if q:\n        results.update({\"q\": q})\n    results.update({\"item\": item})\n    return results</code></pre>\n<p>这里用到了参数校验：<code>ge=1</code> 表示值大于等于1。<code>Query</code>, <code>Path</code>, <code>Body</code> 等函数让声明更明确且功能更强大（如添加描述、别名、校验）。</p>\n<h2 style=\"padding-bottom: 10px; margin-top: 40px;\">🏗️ 结构化利器：Pydantic BaseModel</h2>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">这是 FastAPI 的灵魂特性之一。</strong> BaseModel 让你用 Python 类来定义数据模型，它自动处理数据验证、序列化和文档生成。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from pydantic import BaseModel, EmailStr\nfrom typing import Optional, List\n\nclass UserCreate(BaseModel):\n    # 必需字段\n    username: str\n    email: EmailStr  # 内置邮箱格式验证\n    # 可选字段，带默认值\n    full_name: Optional[str] = None\n    # 列表类型\n    tags: List[str] = []\n\n@app.post(\"/users/\")\nasync def create_user(user: UserCreate):  # 一个参数接管整个请求体\n    # 直接访问已验证好的数据\n    if user.full_name:\n        greeting = f\"Hello, {user.full_name}!\"\n    else:\n        greeting = f\"Hello, {user.username}!\"\n    return {\"message\": greeting, \"user_info\": user.dict()}</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">BaseModel 的优势：</strong></p>\n- <strong>声明即验证：</strong> 字段类型不对、邮箱格式错误等会自动返回 422 错误。<br />- <strong>自动文档：</strong> Swagger UI 和 ReDoc 会自动显示模型结构和示例。<br />- <strong>代码清晰：</strong> 数据契约明确，业务逻辑与数据验证分离。<br />- <strong>嵌套自由：</strong> 模型可以嵌套其他模型，轻松处理复杂数据。<br />\n<h2 style=\"padding-bottom: 10px; margin-top: 40px;\">🚀 完整代码示例</h2>\n<p>下面是一个融合了主要参数类型的实战示例，你可以直接复制运行。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, Path, Query, Body\nfrom pydantic import BaseModel\nfrom typing import Optional\nfrom datetime import datetime\n\napp = FastAPI(title=\"参数详解示例\")\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float = Body(..., gt=0)\n    tax: Optional[float] = None\n    tags: list = []\n\n@app.post(\"/advanced-items/{category}\")\nasync def create_advanced_item(\n    category: str = Path(..., description=\"物品分类\"),\n    item_id: int = Query(..., ge=1, description=\"物品ID\"),\n    q: Optional[str] = Query(None, max_length=50),\n    urgent: bool = Query(False),\n    item: Item = Body(..., example={  # 为文档提供示例\n        \"name\": \"Foo\",\n        \"price\": 50.5,\n        \"tags\": [\"cool\", \"new\"]\n    })\n):\n    \"\"\"创建新物品的复杂端点\"\"\"\n    total = item.price + (item.tax if item.tax else 0)\n    result = {\n        \"category\": category,\n        \"item_id\": item_id,\n        \"query_string\": q,\n        \"urgent\": urgent,\n        \"item_name\": item.name,\n        \"total_price\": total,\n        \"created_at\": datetime.now().isoformat()\n    }\n    return result\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)</code></pre>\n<p>运行后，访问 <code>http://127.0.0.1:8000/docs</code>，你将看到一个功能齐全的交互式 API 文档，所有参数和模型都清晰可见。</p>\n<div style=\"text-align: center; margin: 40px 0;\"><hr style=\"border-right: none; border-bottom: none; border-left: none;\" /></div>\n<p style=\"text-align: center; color: rgba(119, 119, 119, 1); font-style: italic;\">喜欢本文？不要错过✨，点赞👍收藏⭐关注我👆，一起学习更多有用的知识，完善你我的技能树！也请路过的大佬给些建议和指教🙏🐶！</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 08:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">曲幽</a>&nbsp;\n阅读(<span id=\"post_view_count\">52</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "å¯¹é½è§„åˆ™å¤ª â€œè‹›åˆ»â€ï¼ŒPostgreSQLè¡¨å˜å¤§çš„ 3 ä¸ªæ ¸å¿ƒåŽŸå›",
      "link": "https://www.cnblogs.com/lyhabc/p/19161704/postgresql-table-size-increase-causes-alignment-padding",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lyhabc/p/19161704/postgresql-table-size-increase-causes-alignment-padding\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 08:00\">\n    <span>对齐规则太 “苛刻”，PostgreSQL表变大的 3 个核心原因</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1 style=\"text-align: center;\">对齐规则太 “苛刻”，PostgreSQL表变大的 3 个核心原因</h1>\n<p><span>相同的表结构和数据，在商业数据库中存储紧凑，到了PostgreSQL里却会明显变大？ 为什么有些数据库管理员（DBA）在将<span>Oracle</span>、<span>SQL Server和DB2</span><span>等商业数据库</span>迁移到PostgreSQL后表占用的磁盘空间增加20%-40%？</span></p>\n<p><span>本文将通过实际示例说明“对齐”与“填充”是如何造成这种差异的。</span></p>\n<h2><span><span>商业数据库中的行存储机制</span></span></h2>\n<p><span>SQL Server作为商业数据库，会将行数据存储在8KB大小的页（page）中，每一行的结构包含三部分：</span></p>\n<ol class=\"list-paddingleft-1\">\n<li><span>一个小型行头部（4字节，外加一个空值位图）；</span></li>\n<li><span>按定义顺序排列的所有固定长度列；</span></li>\n<li><span>通过“偏移数组”（offset array）管理的可变长度列。</span></li>\n</ol>\n<p><span>注意：</span><strong><span>SQL Server不对固定长度类型强制执行对齐规则</span></strong><span>。这意味着你可以在表中先定义一个BIT列、再定义一个BIGINT列、最后再定义一个BIT列，SQL Server会将这些字节紧密排列，不会产生空间浪费。</span></p>\n<p>&nbsp;</p>\n<p><img alt=\"QQ截图20251023212807\" src=\"https://img2024.cnblogs.com/blog/257159/202510/257159-20251023213645491-1192768041.png\" /></p>\n<p><span>通过实际代码来看具体效果：</span></p>\n<pre class=\"highlighter-hljs\"><code>-- SQL Server 代码\nCREATETABLE&nbsp;T_BadOrder\n(\n&nbsp; &nbsp; a&nbsp;BIT, &nbsp; &nbsp; &nbsp; &nbsp;-- 占用1字节\n&nbsp; &nbsp; b&nbsp;BIGINT, &nbsp; &nbsp;&nbsp;-- 占用8字节\n&nbsp; &nbsp; c&nbsp;BIT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- 占用1字节\n);\n\nINSERTINTO&nbsp;T_BadOrder&nbsp;VALUES&nbsp;(1,&nbsp;42,&nbsp;0);\n\n-- 计算数据占用（payload）大小：结果为10字节\nSELECTDATALENGTH(a) +&nbsp;DATALENGTH(b) +&nbsp;DATALENGTH(c)&nbsp;AS&nbsp;payload_bytes\nFROM&nbsp;T_BadOrder;\n\n-- 查看物理行的平均大小：结果为16字节（4字节行头部 + 10字节数据载荷 + 2字节空值位图掩码的字段计数）\nSELECT&nbsp;avg_record_size_in_bytes\nFROM&nbsp;sys.dm_db_index_physical_stats(DB_ID(), OBJECT_ID('T_BadOrder'),&nbsp;-1,&nbsp;NULL,&nbsp;'DETAILED')\nWHERE&nbsp;alloc_unit_type_desc =&nbsp;'IN_ROW_DATA';</code></pre>\n<p><span>可以看到，数据占用总计10字节，加上行头部和空值位图后，总大小为16字节。这里的重点是：字段a和字段b之间</span><strong><span>没有插入任何填充字节</span></strong><span>。</span></p>\n<h2><span><span>PostgreSQL中的行存储机制</span></span></h2>\n<p><span>PostgreSQL作为开源数据库，表中的每一行的结构如下：</span></p>\n<ol class=\"list-paddingleft-1\">\n<li><span>一个元组头部（tuple header，固定23字节），包含MVCC（多版本并发控制）所需的元数据（如事务ID、可见性标记等）；</span></li>\n<li><span>一个空值位图；（记录哪些字段是空值，每字段占 1 位，不足 1 字节则补满 1 字节，表如果有8个字段就占用1 字节）。</span></li>\n<li><span>按定义顺序排列的字段值。</span></li>\n</ol>\n<p><span>与商业数据库最大的不同是：</span><strong><span>PostgreSQL会强制要求数据类型对齐</span></strong><span>，具体规则如下：</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><span>BOOLEAN类型需要1字节对齐；</span></li>\n<li><span>SMALLINT类型需要2字节对齐；</span></li>\n<li><span>INT类型需要4字节对齐；</span></li>\n<li><span>BIGINT、double precision（双精度浮点数）、timestamp（时间戳）类型需要8字节对齐。</span></li>\n</ul>\n<p><span>如果某一字段的起始位置不符合对应的对齐要求，PostgreSQL会自动插入“填充字节”（padding bytes），将该字段“推”到正确的对齐边界上。我们用跟前文相同的表结构来测试：</span></p>\n<pre class=\"highlighter-hljs\"><code>-- PostgreSQL 代码\nCREATE&nbsp;TABLE&nbsp;t_bad\n(\n&nbsp; &nbsp; a&nbsp;boolean, &nbsp; &nbsp;-- 1字节（后续需补7字节填充）\n&nbsp; &nbsp; b&nbsp;bigint, &nbsp; &nbsp;&nbsp;-- 8字节（需8字节对齐，因此前一列要补填充）\n&nbsp; &nbsp; c&nbsp;boolean&nbsp; &nbsp; &nbsp;-- 1字节\n);\n\nINSERT&nbsp;INTO&nbsp;t_bad&nbsp;VALUES&nbsp;(true,&nbsp;42,&nbsp;false);\n\n-- 查看实际行大小：结果为41字节\nSELECT&nbsp;pg_column_size(t)&nbsp;AS&nbsp;row_bytes\nFROM&nbsp;t_bad t;</code></pre>\n<p><span>在这个例子中，元组头部（23 字节）+ 空值位图（1 字节）= 前 24 字节，PostgreSQL先为字段a分配1字节，然后插入7字节填充，这样字段b才能从8字节对齐边界开始存储；字段b之后是1字节的字段c。仅数据占用的大小就已经超过了SQL Server，还没算上PostgreSQL本身更大的元组头部。</span></p>\n<p><span>但如果我们根据“填充需求”调整字段的顺序，存储占用会显著减少：</span></p>\n<pre class=\"highlighter-hljs\"><code>-- PostgreSQL 代码\nCREATE&nbsp;TABLE&nbsp;t_good\n(\n&nbsp; &nbsp; b&nbsp;bigint, &nbsp; &nbsp;&nbsp;-- 8字节\n&nbsp; &nbsp; a&nbsp;boolean, &nbsp; &nbsp;-- 1字节（无需填充！）\n&nbsp; &nbsp; c&nbsp;boolean&nbsp; &nbsp; &nbsp;-- 1字节\n);\n\nINSERT&nbsp;INTO&nbsp;t_good&nbsp;VALUES&nbsp;(42,&nbsp;true,&nbsp;false);\n\n-- 查看实际行大小：结果为34字节（减少了7字节，因为无需为任何列插入填充）\nSELECT&nbsp;pg_column_size(t)&nbsp;AS&nbsp;row_bytes\nFROM&nbsp;t_good t;</code></pre>\n<p><span>调整后，行大小从41字节降至34字节，核心原因就是字段a不再需要填充字节，因为字段b（8字节）结束后，刚好满足字段a（1字节）的对齐要求。</span></p>\n<p><strong><span>关键原则：字段的顺序应从“占用空间最大”到“占用空间最小”排列！</span></strong></p>\n<p><strong><span>8字节对齐规则</span></strong><span>：</span><code><span>bigint</span></code><span>类型（8字节）要求其</span><strong><span>起始位置必须是8的倍数</span></strong><span>（比如8、16、24、32...）。这是硬件层面的优化。</span></p>\n<h3><span><span>具体位置计算</span></span></h3>\n<p><span>我们按字段的定义顺序（a → b → c）逐步计算每个字段的“起始位置”：</span></p>\n<ol class=\"list-paddingleft-1\">\n<li>\n<p><strong><span>字段a（boolean）的位置</span></strong><span>：</span><span><br /></span><span>前24字节是头部和空值位图，所以列a从</span><strong><span>第24字节</span></strong><span>开始存储。</span><span><br /></span><code><span>boolean</span></code><span>占1字节，因此字段a占用第24字节，结束在</span><strong><span>第24字节</span></strong><span>（24→24，共1字节）。</span></p>\n\n\n</li>\n<li>\n<p><strong><span>字段b（bigint）的位置</span></strong><span>：</span><span><br /></span><span>字段a结束后，下一个可用的起始位置是</span><strong><span>第25字节</span></strong><span>。</span><span><br /></span><span>但</span><code><span>bigint</span></code><span>要求起始位置是8的倍数（8的倍数：8、16、24、32、40...）。 &nbsp;第25字节不是8的倍数（25÷8=3.125，余数1），不符合要求。 &nbsp;因此需要填充字节，直到下一个8的倍数位置。最近的8的倍数是</span><strong><span>第32字节</span></strong><span>（8×4=32）。 从第25字节到第32字节，中间有32-25=7字节，这就是需要填充的</span><strong><span>7字节</span></strong><span>。所以字段b从第32字节开始，占用8字节（32→39字节）。</span></p>\n\n\n</li>\n<li>\n<p><strong><span>字段c（boolean）的位置</span></strong><span>：</span><span><br /></span><span>字段b结束在第39字节，下一个位置是第40字节。</span><span><br /></span><code><span>boolean</span></code><span>只需要1字节对齐（任何位置都可以），因此直接从第40字节开始，占用1字节（40→40字节）。</span></p>\n\n\n</li>\n\n</ol>\n<h3><span><span>总大小验证</span></span></h3>\n<p><span>整个行的总大小=头部（23）+ 空值位图（1）+ 字段a（1）+ 填充（7）+ 字段b（8）+ 字段c（1）= 23+1+1+7+8+1=41字节。</span></p>\n<h3><span><span>调整顺序后不需要填充</span></span></h3>\n<p><span>如果把</span><code><span>bigint</span></code><span>（b）放在第一个字段，情况就变了：</span></p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<span>字段b从第24字节开始（头部23+空值位图1=24），<span>24</span>是8的倍数（24÷8=3），符合</span><code><span>bigint</span></code><span>的对齐要求，无需填充。</span>\n</li>\n<li>\n<span>字段b占用24→31字节（8字节），之后字段a（boolean）从32字节开始（1字节对齐，无需填充），字段c从33字节开始，总大小减少7字节。</span>\n</li>\n\n</ul>\n<h2><span><span>可变长度字段的影响</span></span></h2>\n<p><span>当表中包含可变长度字段时，情况更有意思。两者的处理差异如下：</span></p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<span>在SQL Server中，可变长度数据通过行末尾的“偏移数组”管理；</span>\n</li>\n<li>\n<span>在PostgreSQL中，每一个可变长度值（如TEXT、VARCHAR、BYTEA、NUMERIC等）都自带一个4字节的“变长头部”（varlena header）。</span>\n</li>\n\n</ul>\n<p><span>我们通过下面两个表的表结构对比来看看实际影响：</span></p>\n<pre class=\"highlighter-hljs\"><code>-- PostgreSQL 代码：列顺序不合理的表\nCREATETABLE&nbsp;bad_order\n(\n&nbsp; &nbsp; a&nbsp;boolean,\n&nbsp; &nbsp; b&nbsp;bigint,\n&nbsp; &nbsp; c&nbsp;int,\n&nbsp; &nbsp; d&nbsp;timestamp,\n&nbsp; &nbsp; e&nbsp;smallint,\n&nbsp; &nbsp; f&nbsp;varchar(20),\n&nbsp; &nbsp; g&nbsp;numeric(18,2)\n);\n\n-- PostgreSQL 代码：列顺序合理的表\nCREATETABLE&nbsp;good_order\n(\n&nbsp; &nbsp; b&nbsp;bigint,\n&nbsp; &nbsp; d&nbsp;timestamp,\n&nbsp; &nbsp; c&nbsp;int,\n&nbsp; &nbsp; e&nbsp;smallint,\n&nbsp; &nbsp; a&nbsp;boolean,\n&nbsp; &nbsp; g&nbsp;numeric(18,2),\n&nbsp; &nbsp; f&nbsp;varchar(20)\n);\n\n-- 插入100万条测试数据\nINSERTINTO&nbsp;bad_order (a,b,c,d,e,f,g)\nSELECT\n&nbsp; (i %&nbsp;2&nbsp;=&nbsp;0), &nbsp;-- 布尔值：true/false交替\n&nbsp; (random()*1e9)::bigint, &nbsp;-- 随机大整数\n&nbsp; (random()*1e5)::int, &nbsp; &nbsp;&nbsp;-- 随机整数\n&nbsp; to_timestamp(1420070400&nbsp;+ (random()*1e6)::int), &nbsp;-- 随机时间戳\n&nbsp; (random()*32000)::int::smallint, &nbsp;-- 随机小整数\nsubstr(md5(random()::text),&nbsp;1, (random()*20)::int), &nbsp;-- 随机长度字符串（1-20字符）\n&nbsp; ((random()*1e7)::bigint)::numeric&nbsp;/&nbsp;100.0-- 随机数值（保留2位小数）\nFROM&nbsp;generate_series(1,1000000) i; &nbsp;-- 生成1-1000000的序列作为循环变量\n\n-- 将bad_order的数据按合理列顺序插入good_order\nINSERTINTO&nbsp;good_order\nSELECT&nbsp;b,d,c,e,a,g,f&nbsp;FROM&nbsp;bad_order;\n\n-- 对比两张表的平均行大小\nSELECT'bad_order'AS&nbsp;tbl,&nbsp;avg(pg_column_size(t))&nbsp;AS&nbsp;avg_row_bytes&nbsp;FROM&nbsp;bad_order t\nUNIONALL\nSELECT'good_order',&nbsp;avg(pg_column_size(t))&nbsp;FROM&nbsp;good_order t;</code></pre>\n<p><span>实际测试结果显示：</span><code><span>bad_order</span></code><span>因列顺序不合理和对齐问题，平均每行占用77字节；而</span><code><span>good_order</span></code><span>将“宽字节固定长度字段”放在前面、“可变长度字段”放在最后，最大限度减少了填充，平均每行仅占用66字节。</span></p>\n<h2><span><span>为什么PostgreSQL的行存储通常更大？</span></span></h2>\n<p><span>迁移后PostgreSQL行大小超过商业数据库，主要源于三个核心差异：</span></p>\n<ol class=\"list-paddingleft-1\">\n<li><strong><span>元组头部大小</span></strong><span>：PostgreSQL的行头部包含约23字节的MVCC元数据，而SQL Server仅为4字节；</span></li>\n<li><strong><span>对齐填充</span></strong><span>：PostgreSQL会插入填充字节以保证固定长度类型的对齐，而商业数据库则不会；</span></li>\n<li><strong><span>可变长度字段开销</span></strong><span>：PostgreSQL中每个可变长度字段都自带4字节的变长头部，商业数据库则无此开销。</span></li>\n</ol>\n<h3><span><span>PostgreSQL优化存储空间的核心逻辑包括下面几个方面：</span></span></h3>\n<ul class=\"list-paddingleft-1\">\n<li><span>先放“宽字节固定长度列”（如BIGINT、timestamp）；</span></li>\n<li><span>再放“中等字节固定长度列”（如INT）；</span></li>\n<li><span>接着放“小字节固定长度列”（如SMALLINT、BOOLEAN）；</span></li>\n<li><span>最后放“可变长度列”（如VARCHAR、TEXT、NUMERIC）。</span></li>\n</ul>\n<h2><span><span>总结</span></span></h2>\n<p><span>从<span>商业数据库</span>迁移到开源数据库PostgreSQL后表体积变大是为了支撑PostgreSQL的核心特性（MVCC）和跨架构的性能稳定性。这也意味着，我们不能期望商业数据库和开源数据库两者的存储大小完完全全“一一对应”，而且开源数据库跟商业数据库相比起来还是有一定的差距。</span></p>\n<p>&nbsp;</p>\n<p><img alt=\"\" class=\"medium-zoom-image\" src=\"https://img2024.cnblogs.com/blog/257159/202409/257159-20240908204310924-1005667056.png\" /></p>\n<p><strong>本文版权归作者所有，未经作者同意不得转载。</strong></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 08:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lyhabc\">桦仔</a>&nbsp;\n阅读(<span id=\"post_view_count\">139</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}