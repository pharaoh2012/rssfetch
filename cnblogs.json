{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "海豚调度DolphinScheduler 和 Spring Cloud Data Flow 对比",
      "link": "https://www.cnblogs.com/kakarotto-chen/p/19421939",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kakarotto-chen/p/19421939\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 16:22\">\n    <span>海豚调度DolphinScheduler 和 Spring Cloud Data Flow 对比</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n            <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"对比\">对比</h2>\n<ul>\n<li>原理上有相似性（都是调度框架），但DolphinScheduler是“任务级的调度”，Spring Cloud Data Flow是“应用级的编排”。</li>\n</ul>\n<h3 id=\"问题-spring-cloud-data-flow来调度seatunnel和dolphinscheduler调度seatunnel差不多\">问题： spring cloud data flow来调度seatunnel、和dolphinscheduler调度seatunnel差不多？</h3>\n<ul>\n<li>Spring Cloud Data Flow（SCDF）和 DolphinScheduler 都可以用来调度 SeaTunnel 任务，但它们在设计理念和实现方式上有一些关键区别：</li>\n</ul>\n<h4 id=\"1-设计理念与架构\">1. ‌设计理念与架构‌</h4>\n<p>Spring Cloud Data Flow‌：</p>\n<ul>\n<li>核心理念‌：SCDF 是一个数据流编排框架，专注于流式和批处理任务的定义、部署和管理。它通过 Spring Boot 和 Spring Cloud 提供统一的编程模型。</li>\n<li>架构‌：基于 Spring Cloud Deployer，支持多环境部署（如本地、Kubernetes、Cloud Foundry），通过 Skipper 实现应用版本管理和滚动更新。</li>\n<li>组件模型‌：SCDF 使用源（Source）、处理器（Processor）和接收器（Sink）的组件模型，通过 DSL（Domain Specific Language）或图形界面定义数据流。</li>\n</ul>\n<p>DolphinScheduler‌：</p>\n<ul>\n<li>核心理念‌：DolphinScheduler 是一个分布式任务调度平台，支持多种任务类型（如 Shell、Spark、Flink、DataX 等），强调任务编排和监控。</li>\n<li>架构‌：基于 Master-Worker 模型，通过 ZooKeeper 实现任务调度和资源管理。</li>\n<li>组件模型‌：DolphinScheduler 支持自定义任务插件，通过拖拽界面定义 DAG 工作流。</li>\n</ul>\n<h4 id=\"2-调度方式与灵活性\">2. ‌调度方式与灵活性‌</h4>\n<p>SCDF 调度 SeaTunnel‌：<br />\n方式‌：通过 SCDF 的 DSL 或图形界面定义 SeaTunnel 任务，SCDF 负责任务的部署和执行。<br />\n灵活性‌：支持多种计算引擎（如 Spark、Flink），但需要额外配置 SeaTunnel 的启动脚本和参数。<br />\nDolphinScheduler 调度 SeaTunnel‌：<br />\n方式‌：DolphinScheduler 3.1.5+ 版本内置 SeaTunnel 组件，通过任务节点直接配置 SeaTunnel 脚本。<br />\n灵活性‌：支持动态参数配置、任务级重试和失败处理机制。</p>\n<h4 id=\"3-适用场景与优势\">3. ‌适用场景与优势‌</h4>\n<p>SCDF 优势‌：<br />\n适合需要统一数据流管理和编排的场景，尤其是与 Spring 生态系统集成。<br />\n通过 Skipper 实现应用的版本管理和滚动更新。<br />\nDolphinScheduler 优势‌：<br />\n适合复杂任务编排和监控需求，支持丰富的任务类型和自定义插件。<br />\n提供秒级任务调度和故障恢复机制。</p>\n<h4 id=\"4-关键区别\">4. ‌关键区别‌</h4>\n<p>调度模型‌：SCDF 更侧重于数据流的定义和编排，DolphinScheduler 更侧重于任务的调度和监控。<br />\n组件集成‌：SCDF 需手动配置 SeaTunnel 启动脚本，DolphinScheduler 内置 SeaTunnel 组件简化配置。<br />\n总结</p>\n<p>两者都可以调度 SeaTunnel，但 SCDF 更适合数据流编排场景，DolphinScheduler 更适合复杂任务调度需求。选择时需根据具体业务需求和现有技术栈决定。</p>\n<h2 id=\"二-核心对比两种调度思路\">二、📊 <strong>核心对比：两种调度思路</strong></h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th><strong>DolphinScheduler</strong></th>\n<th><strong>Spring Cloud Data Flow (SCDF)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>定位</strong></td>\n<td><strong>任务调度与工作流编排平台</strong></td>\n<td><strong>云原生流批数据处理平台</strong></td>\n</tr>\n<tr>\n<td><strong>设计理念</strong></td>\n<td>“任务的调度器”</td>\n<td>“数据管道的Kubernetes”</td>\n</tr>\n<tr>\n<td><strong>调度单位</strong></td>\n<td>任务/工作流（Task/DAG）</td>\n<td>数据流/批处理管道（Stream/Batch）</td>\n</tr>\n<tr>\n<td><strong>资源管理</strong></td>\n<td>Worker节点、租户、队列</td>\n<td>云平台（K8s、Cloud Foundry）</td>\n</tr>\n<tr>\n<td><strong>主要界面</strong></td>\n<td>完整的Web UI操作界面</td>\n<td>CLI + Dashboard（UI较简单）</td>\n</tr>\n<tr>\n<td><strong>部署复杂度</strong></td>\n<td>中等（需要DB、Zookeeper）</td>\n<td>高（依赖Spring Cloud生态）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三-技术实现对比\">三、🔧 <strong>技术实现对比</strong></h2>\n<h3 id=\"1-dolphinscheduler调度seatunnel\"><strong>1. DolphinScheduler调度SeaTunnel</strong></h3>\n<pre><code class=\"language-yaml\"># 你的当前方案：明确、直接的任务调度\nDS工作流任务 → Shell任务 → 执行 seatunnel.sh\n\n# 特点：\n# 1. 像crontab增强版\n# 2. 手动配置每个任务的细节\n# 3. 直接控制执行服务器和用户\n</code></pre>\n<h3 id=\"2-spring-cloud-data-flow调度seatunnel\"><strong>2. Spring Cloud Data Flow调度SeaTunnel</strong></h3>\n<pre><code class=\"language-yaml\"># SCDF方案：声明式的数据管道\nSCDF Stream定义: source -&gt; seatunnel-processor -&gt; sink\n\n# 特点：\n# 1. 把SeaTunnel包装成Spring Cloud Stream应用\n# 2. 通过SCDF部署和管理应用生命周期\n# 3. 自动处理消息传递、扩缩容\n</code></pre>\n<h2 id=\"四-适用场景对比\">四、🎯 <strong>适用场景对比</strong></h2>\n<h3 id=\"dolphinscheduler更适合\"><strong>DolphinScheduler更适合：</strong></h3>\n<pre><code class=\"language-yaml\"># 传统ETL调度场景\n- 定时数据同步任务（每天凌晨1点跑）\n- 复杂依赖的工作流（A表跑完再跑B）\n- 需要人工介入（失败报警、手动重跑）\n- 多租户、资源隔离需求\n- 已有服务器（非K8s）环境\n\n# 典型工作流\n┌─────────┐    ┌──────────┐    ┌─────────┐\n│ 采集日志 │ →  │ SeaTunnel │ → │  入仓   │\n└─────────┘    └──────────┘    └─────────┘\n       │              │              │\n   每天1点      依赖采集完成    依赖ETL完成\n</code></pre>\n<h3 id=\"spring-cloud-data-flow更适合\"><strong>Spring Cloud Data Flow更适合：</strong></h3>\n<pre><code class=\"language-yaml\"># 云原生实时/微批场景\n- 持续运行的数据管道（7x24小时）\n- 微服务架构的数据处理\n- 需要自动扩缩容\n- 已使用Spring Cloud生态\n- K8s环境部署\n\n# 典型数据流\n┌─────────┐    ┌──────────────┐    ┌─────────┐\n│ Kafka   │ →  │ SeaTunnel    │ →  │  Redis  │\n│ 消息源  │    │ (实时清洗)   │    │  实时数  │\n└─────────┘    └──────────────┘    └─────────┘\n    持续产生          持续处理          持续更新\n</code></pre>\n<h2 id=\"五-具体实现方式差异\">五、🚀 <strong>具体实现方式差异</strong></h2>\n<h3 id=\"dolphinscheduler方式你正在用的\"><strong>DolphinScheduler方式（你正在用的）</strong></h3>\n<pre><code class=\"language-bash\"># 1. 编写SeaTunnel配置文件 config.conf\n# 2. 在DS中创建Shell任务\n# 3. 任务内容：/opt/seatunnel/bin/start.sh -c config.conf\n# 4. 设置定时、依赖、告警\n</code></pre>\n<h3 id=\"spring-cloud-data-flow方式\"><strong>Spring Cloud Data Flow方式</strong></h3>\n<pre><code class=\"language-bash\"># 1. 将SeaTunnel包装为Spring Boot应用\n# 2. 注册到SCDF作为自定义处理器(processor)\n# 3. 通过DSL定义流\nstream create --name my-etl-pipeline \\\n  --definition \"http --port=9000 | seatunnel-processor | jdbc\"\n\n# 4. 部署流\nstream deploy --name my-etl-pipeline \\\n  --properties \"app.seatunnel-processor.seatunnel-config=file:///config.conf\"\n\n# 5. SCDF自动管理应用实例\n</code></pre>\n<h2 id=\"六️-重要注意事项\">六、⚠️ <strong>重要注意事项</strong></h2>\n<h3 id=\"scdf的挑战\"><strong>SCDF的挑战：</strong></h3>\n<ol>\n<li><strong>强绑定Spring生态</strong>：需要将SeaTunnel改造为Spring Cloud Stream应用</li>\n<li><strong>学习曲线陡峭</strong>：需了解Stream、Task、Skipper等概念</li>\n<li><strong>部署复杂</strong>：依赖消息中间件（RabbitMQ/Kafka）、服务发现等</li>\n<li><strong>资源消耗</strong>：每个任务都是独立JVM进程，内存开销大</li>\n</ol>\n<h3 id=\"dolphinscheduler的优势对你当前情况\"><strong>DolphinScheduler的优势（对你当前情况）：</strong></h3>\n<ol>\n<li><strong>独立轻量</strong>：不依赖特定技术栈</li>\n<li><strong>直观易用</strong>：有完整UI，学习成本低</li>\n<li><strong>你已熟悉</strong>：已搭建环境并跑通流程</li>\n<li><strong>社区活跃</strong>：中文文档和社区支持好</li>\n</ol>\n\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2025-12-30 16:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kakarotto-chen\">C_C_菜园</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "claude-agent-sdk mineru-parser-skill发票识别",
      "link": "https://www.cnblogs.com/cwity/p/19421862",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/cwity/p/19421862\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 16:05\">\n    <span>claude-agent-sdk mineru-parser-skill发票识别</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2025-12-30 16:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/cwity\">cwity</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"claude-agent-sdk-mineru-parser-skill发票识别\">claude-agent-sdk mineru-parser-skill发票识别</h1>\n<blockquote>\n<p>不谈玄学，只讲落地。<br />\n我是一名深耕算法工程化一线的实践者，擅长将 新技术、关键技术、AI/ML 技术从论文和 demo 转化为可规模化部署的生产系统。在这里,你看不到堆砌公式的理论空谈,只有真实项目中踩过的坑、趟过的路,每一篇文章都源自实战经验的提炼。我相信技术的价值在于解决真实问题,而不是制造焦虑。如果你也厌倦了\"收藏即学会\",渴望掌握让算法真正跑起来的硬核能力,那么这里就是你的技术补给站。</p>\n</blockquote>\n<h1 id=\"摘要\">摘要</h1>\n<p>在 AI 驱动的文档处理领域，Claude Agent SDK 和 MinerU 的结合提供了一个解决方案。Claude Agent SDK 的 Skills 功能让 AI 能够调用外部工具和服务，而 MinerU 提供文档解析能力，支持 OCR 和 VLM（视觉语言模型），可提取 PDF、Word、PPT 等文档中的文本、表格、公式和结构化内容。<br />\n通过将 MinerU 封装为 Claude Agent SDK 的 Skill，实现了从文档 URL 到结构化 Markdown 的端到端自动化流程。用户只需提供文档链接和自然语言指令，Claude AI 就能自动调用 MinerU API 完成解析、状态轮询和结果提取，最终生成结构化数据。该方案适合发票处理、合同分析、学术论文提取等场景，降低了技术门槛，提升了处理效率和准确性。</p>\n<h2 id=\"核心亮点\">核心亮点</h2>\n<ul>\n<li>智能化工作流：Claude Agent SDK 的 Skills 机制让 AI 能够自主决策何时调用 MinerU，实现智能化文档处理</li>\n<li>强大的解析能力：MinerU 支持 OCR 和 VLM 双模型，能够处理复杂布局、手写文字、数学公式等多种内容</li>\n<li>异步流式处理：基于异步编程模型，支持实时反馈和进度追踪，提升用户体验</li>\n<li>零代码集成：通过 Skills 配置即可完成集成，无需编写复杂的 API 调用逻辑</li>\n<li>结构化输出：自动将文档内容转换为 Markdown 格式，便于后续分析和处理</li>\n</ul>\n<pre><code>用户指令 → Claude Agent SDK → MinerU Skill → MinerU API → 结构化 Markdown\n</code></pre>\n<h1 id=\"mineru-pareser发票识别\">mineru-pareser发票识别</h1>\n<h2 id=\"官方文档\">官方文档</h2>\n<p><a href=\"\" rel=\"noopener nofollow\">https://platform.claude.com/docs/en/agent-sdk/python</a></p>\n<h2 id=\"获取mineru-parser-skills\">获取mineru-parser skills</h2>\n<p><a href=\"\" rel=\"noopener nofollow\">https://github.com/nilecui/mineru-parser-skills</a></p>\n<pre><code class=\"language-shell\">git clone https://github.com/nilecui/mineru-parser-skills.git\n</code></pre>\n<p><img alt=\"\" src=\"https://fastly.jsdelivr.net/gh/bucketio/img1@main/2025/12/30/1767079552117-f788e37f-e955-4f30-b8cf-c9421b8bcd6a.png\" /></p>\n<pre><code class=\"language-shell\">python -m venv venv\nsource venv/bin/activate\n(venv) nilecui@DESKTOP-28RSMOM:~/demo/mineru-parser-skills$ pip install -r requirements.txt\n</code></pre>\n<h2 id=\"注册mineru服务\">注册mineru服务</h2>\n<p><img alt=\"\" src=\"https://fastly.jsdelivr.net/gh/bucketio/img17@main/2025/12/30/1767079796169-183a0dd9-02b3-4685-b0e8-68087b530bad.png\" /></p>\n<p>需要申请，这里需要等待几分钟，会发送邮箱通知：</p>\n<p><img alt=\"\" src=\"https://fastly.jsdelivr.net/gh/bucketio/img15@main/2025/12/30/1767080030991-ad72ea6c-c508-4db1-8d00-7517a6069917.png\" /></p>\n<p>然后创建秘钥就可以了，记得保存秘钥！</p>\n<h2 id=\"运行demo脚本\">运行demo脚本</h2>\n<pre><code class=\"language-shell\"># 导入秘钥\nexport MINERU_API_KEY= *******\npython demo.py\n</code></pre>\n<h2 id=\"启动过程\">启动过程</h2>\n<p>模型用的glm-4.7, 相关配置可参考上篇文章：claude-code 国产glm替代方案,<br />\n有时候很快大概20几步就出现了结果，有时达到了70多个请求；可能和我设计的skills有关，如果再加上python脚本，估计就省掉了再创建python脚本的过程，希望大家多提技巧。</p>\n<p><img alt=\"\" src=\"https://fastly.jsdelivr.net/gh/bucketio/img4@main/2025/12/30/1767080140157-996edc98-46f2-42e0-beff-39d04f10dd70.png\" /></p>\n<h2 id=\"结果\">结果</h2>\n<p><img alt=\"\" src=\"https://fastly.jsdelivr.net/gh/bucketio/img14@main/2025/12/30/1767080378945-dc778e9e-018f-4550-813e-126d88849a4f.png\" /></p>\n<blockquote>\n<p>参考：<br />\n<a href=\"https://platform.claude.com/docs/en/agent-sdk/python\" rel=\"noopener nofollow\" target=\"_blank\">https://platform.claude.com/docs/en/agent-sdk/python</a><br />\n<a href=\"https://github.com/nilecui/mineru-parser-skills\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/nilecui/mineru-parser-skills</a></p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "基于SqlSugar开发框架的基础上快速开发H5端的移动应用",
      "link": "https://www.cnblogs.com/wuhuacong/p/19420561",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuhuacong/p/19420561\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 15:07\">\n    <span>基于SqlSugar开发框架的基础上快速开发H5端的移动应用</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n                <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在开发一些项目的时候，我们往往会基于一定的框架进行业务的开发，并结合一些辅助工具进行更高效率的快速开发和整合工作，SqlSugar开发框架是我们开发的一个多端整合的开发框架，基于它的后端WebAPI 基础上，我们可以对接WInform端、Vue3+ElementPlus的BS端，Vue3+Vant4的H5端，以及WPF、或者小程序等多端接入，本篇随笔介绍一个简单的项目录入功能，介绍基于SqlSugar开发框架的基础上快速开发H5端的移动应用。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在开发一些项目的时候，我们往往会基于一定的框架进行业务的开发，并结合一些辅助工具进行更高效率的快速开发和整合工作，SqlSugar开发框架是我们开发的一个多端整合的开发框架，基于它的后端框架的WebAPI 基础上，我们可以对接WInform端、Vue3+ElementPlus的BS端，Vue3+Vant4的H5端，以及WPF、或者小程序等多端接入，本篇随笔介绍一个简单的项目录入功能，介绍基于SqlSugar开发框架的基础上快速开发H5端的移动应用。</p>\n<h3>1、设计数据库</h3>\n<p>俗话说万层高楼从底起，开发应用项目，数据库的设计很重要，它可能是业务对象，业务流程的综合设计，好的数据库设计可以减少后期的重复返工，提高开发效率。</p>\n<p>一般表名称，根据不同的业务关系，我们可以使用不同的前缀进行区分，使用前缀，可以非常方便区分不同的业务表，如我自己一般基础表使用 “TB_” 定义前缀，权限系统表使用\"T_ACL_\"定义前缀，工作流表使用“TBAPP_”，业务表使用\"T_\"等，这样对于区分不同的业务，方便管理很有好处。</p>\n<p>字段名称方面，我们可以约定一些规则，如约定主键使用ID；一般来说，ID作为主键，可以使用自增长的整形字段，也可以使用GUID的字符型字段，如果为了方便兼容不同的数据库且方便迁移或者开发基于网络方面的应用，我建议还是使用GUID的字符型字段，使用这种类型的字段，我们从创建数据的时候，就可以知道这个记录的主键，对于我们维护父子表等关系非常有利。</p>\n<p>由于如果采用字符型的ID主键，那么我们如果需要正确排序的时候，可能需要增加一个CreateTime的日期类型，方便我们根据日期进行排序，或者特定的需要增加一个SortOrder字段。</p>\n<p>如果这个表还有一个外键的引用，建议统一命名标准，我一般使用“表名称_ID这样的名称，如User_ID、Contact_ID等相似的名称作为外键，不需要表的前缀。</p>\n<p>数据库的模型设计，我们建议在第三方的数据库设计工具上进行设计，如PowerDesigner这样的设计工具，使用工具设计数据库有很多好处，一个是可以高效率进行调整，二是根据需要生成不同的数据库类型Sql语句，三是可以全局了解各个表之间的关系等等。</p>\n<p>使用PowerDesigner这样的数据库设计工具，能够在很大程度上提高我们数据库的设计效率。我们默认以SQLServer数据库创建表，如下所示。</p>\n<p><img alt=\"image\" height=\"278\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230115810545-678368233.png\" width=\"323\" /></p>\n<p>设计好的数据表，在设计状态下，添加相关的备注信息。</p>\n<p><img alt=\"image\" height=\"467\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230115835170-756890014.png\" width=\"796\" /></p>\n<p>&nbsp;然后生成相关的SQL代码，我们就可以再具体的数据库管理工具上执行创建对应的表信息了。&nbsp;</p>\n<p><img alt=\"image\" height=\"466\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230115908156-1344039466.png\" width=\"794\" /></p>\n<p>&nbsp; 完成数据库表创建后，我们就完成了第一阶段的工作了。</p>\n<p>&nbsp;</p>\n<h3>2、生成SqlSugar开发框架的后端基础代码并整合</h3>\n<p>设计好数据库后，我们通过代码生成工具进行基于项目框架的代码生成，这样对于我们在开发新项目上有很好的好处，里面的项目层级、引用关系，已经处理好了，这样对我们非常方便。</p>\n<p>不过大多数情况下，我们都是增量开发较多，也就是我们可能前面已经完成了一些其他业务的开发，可能新增一个两个表，或者一批业务表的处理，我们生成相关的代码文件后把它们复制到项目恰当位置上即可。</p>\n<p>由于项目生成的时候，指定了主命名空间和相关的表前缀，这样我们生成后的代码就方便阅读很多，减少累赘和出错的机会。</p>\n<p>利用代码生成工具Database2Sharp强大的数据库元数据和模板引擎，我们构建了对应的框架代码生成规则，因此统一生成即可，提高了代码开发的效能，同时也统一了代码的结构，便于大项目的维护。</p>\n<p>对于SQLSugar的项目框架，我们为了方便，分别单独提供后端代码和Web API代码的生成、Winform界面代码的生成，以及前面介绍到的Vue3+TypeScript+ElementPlus的代码生成操作。</p>\n<p>代码生成工具的界面效果如下所示，通过入口菜单，可以实现不同部分的代码快速生成。我们先使用【Sqlsugar框架代码生成】生成后端的相关代码文件。</p>\n<p><img alt=\"image\" height=\"636\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230125345005-735899731.png\" width=\"1033\" /></p>\n<p>选择我们刚才创建的表进行一步步的生成即可。</p>\n<p><img alt=\"image\" height=\"406\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230142927634-577910459.png\" width=\"534\" /></p>\n<p>生成代码，我们可以看到相关的目录，如下所示。</p>\n<p><img alt=\"image\" height=\"591\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230143200345-246629280.png\" width=\"850\" /></p>\n<p>复制整合文件到框架项目的合适位置上，暂时不需要增加任何方法代码，我们利用继承的基类方法就完全满足需求 。</p>\n<p><img alt=\"image\" height=\"964\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230151121521-1088455216.png\" width=\"1017\" /></p>\n<p>&nbsp;</p>\n<h3>3、基于Vant4+Vue3+TypeScript的H5移动前端进行开发</h3>\n<div><strong>关于Vant4</strong></div>\n<div>\n<p>Vant 是一个<strong>轻量、可定制的移动端组件库</strong>，于 2017 年开源。目前 Vant 官方提供了&nbsp;<a href=\"https://vant-ui.github.io/vant/v2/\" rel=\"noopener nofollow\" target=\"_blank\">Vue 2 版本</a>、<a href=\"https://vant-ui.github.io/vant/\" rel=\"noopener nofollow\" target=\"_blank\">Vue 3 版本</a>和<a href=\"https://vant-ui.github.io/vant-weapp/\" rel=\"noopener nofollow\" target=\"_blank\">微信小程序版本</a>，并由社区团队维护&nbsp;<a href=\"https://github.com/3lang3/react-vant\" rel=\"noopener nofollow\" target=\"_blank\">React 版本</a>和<a href=\"https://github.com/ant-move/Vant-Aliapp\" rel=\"noopener nofollow\" target=\"_blank\">支付宝小程序版本</a>。</p>\n<p>当前移动端 项目采用最新的Vant4进行开发，适合于Vue3的项目开发。</p>\n<p>Vant 4 是一款基于 Vue 3 的轻量、可靠的手机端组件库，主要用于快速搭建移动端应用。它提供了许多常用的 UI 组件，如按钮、卡片、表单、导航等，旨在帮助开发者提高开发效率，同时保持应用的性能和一致性。</p>\n<p>Vant 4 是完全基于 Vue 3 构建的，充分利用了 Vue 3 的新特性和性能优化，如 Composition API、Teleport、Fragments 等。通过 Vue 3 的优化，Vant 4 在渲染性能上有了显著提升，特别是在处理大型列表和复杂组件时。</p>\n<p><a href=\"http://www.iqidi.com:8849/\" rel=\"noopener nofollow\" target=\"_blank\"><img alt=\"移动端H5应用\" height=\"296\" src=\"https://www.iqidi.com/Framework/images/vant-mobile.png\" width=\"296\" /></a></p>\n<p>&nbsp;扫码进行了解&nbsp;Vant4+Vue3+TypeScript 的移动前端。</p>\n<p>&nbsp;</p>\n</div>\n<p>接下来就是针对H5端应用进行的界面开发了，我们可以参考案例的滚动到底部进行分页处理的页面案例，对内容进行分页展示处理，如下所示是几个界面的效果。</p>\n<p><img alt=\"image\" height=\"741\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144121321-490674470.png\" width=\"346\" />&nbsp;&nbsp;<img alt=\"image\" height=\"742\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144148794-1515596057.png\" width=\"346\" />&nbsp;&nbsp;<img alt=\"image\" height=\"741\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144313426-902219873.png\" width=\"346\" /></p>\n<p>&nbsp;签名图片，我们通过调用通用的文件上传处理，把它上传到服务端的目录上了，使用的时候直接用其对应的地址即可。</p>\n<p><img alt=\"image\" height=\"334\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144611192-2014570350.png\" width=\"686\" /></p>\n<p>了解了界面效果，我们来看看具体的代码实现过程。</p>\n<p>我们首先增加或者使用代码生成工具生成一个api对接后端的文件，如下所示。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144808470-1588794631.png\" /></p>\n<p>这个文件很简单，就是继承基类即可，不需要增加任何自定义方法。</p>\n<div class=\"cnblogs_code\">\n<pre>import type { ListResult, PagedResult } from '@/api/types'<span style=\"color: rgba(0, 0, 0, 1);\">\nimport BaseApi from </span>'@/api/base-api'<span style=\"color: rgba(0, 0, 0, 1);\">\nimport { CommonResult } from </span>'@/api/types'<span style=\"color: rgba(0, 0, 0, 1);\">\nimport { http } from </span>'@/utils/http/axios'\n\n<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 导入API基类对象,默认具有Get/GetAll/Create/Update/Delete/BatchDelete/SaveImport/Count等接口</span><span style=\"color: rgba(0, 128, 0, 1);\">\n//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 业务类自定义接口实现, 通用的接口已经在BaseApi中定义</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">class Api <span style=\"color: rgba(255, 0, 0, 1);\"><strong>extends BaseApi</strong></span> {\n  </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 参考下面案例，增加自定义函数</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> GET 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 根据条件计算记录数量</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async GetCount(params: object) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpGet&lt;number&gt;(this.baseurl + \"count\", params);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> POST 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建对象</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async Create(data: object) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpPost&lt;boolean&gt;(this.baseurl + `create`, data);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> PUT 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 更新对象</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async Update(data: object) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpPut&lt;boolean&gt;(this.baseurl + `update`, data);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> DELETE 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 删除指定ID的对象</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async Delete(id: number | string) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpDelete&lt;boolean&gt;(this.baseurl + `${id}`);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">}\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 构造测试工作项目 Api实例，并传递业务类接口地址</span>\nexport <span style=\"color: rgba(0, 0, 255, 1);\">default</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Api('<span style=\"color: rgba(255, 0, 0, 1);\"><strong>/api/testworkitem/</strong></span>')</pre>\n</div>\n<p>前端根据框架后端的接口进行前端JS端的类的封装处理，引入了ES6类的概念实现业务基类接口的统一封装，简化代码。这些类继承BaseApi，就会具有相关的接口了，如下所示继承关系。</p>\n<p><img alt=\"\" class=\"medium-zoom-image\" src=\"https://img2020.cnblogs.com/blog/8867/202007/8867-20200713152737929-890201160.png\" /></p>\n<p>我们已经在BaseApi的ES6类里面定义了对应Web API基类里面的操作方法，如下所示。</p>\n<p><img alt=\"\" class=\"medium-zoom-image\" height=\"595\" src=\"https://img2022.cnblogs.com/blog/8867/202207/8867-20220707112405599-7103386.png\" width=\"966\" /></p>\n<p>&nbsp;这样，我们在创建一个业务类的时候，如果没有特殊的自定义接口，只需要继承基类BaseApi即可具有所有的常规基类方法了。</p>\n<p>&nbsp;由于我们的ES6接口定义，是基于TypeScript的，它的数据类型可以推断出来，因此在编码或者查看对应属性的时候，会有非常好的提示信息。</p>\n<p>对应几个不同的页面场景，我们分别创建不同的视图文件，如下所示。</p>\n<p><img alt=\"image\" height=\"454\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230145310033-599021859.png\" width=\"479\" /></p>\n<p>&nbsp;由于Vue3+Typescript+Vant4的H5应用端是基于VueRouter的路由处理，因此，我们需要在路由模块中增加对应的路由定义，如下所示。</p>\n<p><img alt=\"image\" height=\"863\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230145553832-1840777761.png\" width=\"1065\" /></p>\n<p>&nbsp;最后我们就可以再主页面提供一个入口，访问当前的模块了。如我们在列表页面模块中，首先需要引入对应的API调用类，以及定义对应的实体对象。</p>\n<p><img alt=\"image\" height=\"833\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230145818721-1359007905.png\" width=\"1073\" /></p>\n<p>&nbsp;页面只需要调用BaseApi的基类封装函数即可实现滚动继续分页获取记录的处理。</p>\n<p><img alt=\"image\" height=\"1309\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230150032578-1409793504.png\" width=\"1078\" /></p>\n<p>&nbsp;结合Vant4的相关控件，我们可以把记录的内容展示出来。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"scroll-container\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">page-header </span><span style=\"color: rgba(255, 0, 0, 1);\">@click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"goback\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-search </span><span style=\"color: rgba(255, 0, 0, 1);\">v-model</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"searchValue\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> placeholder</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"请输入搜索关键词\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @search</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"onSearch\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @clear</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"clearInput\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-list\n      </span><span style=\"color: rgba(255, 0, 0, 1);\">v-model:loading</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"loading\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n      :finished</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"finished\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n      finished-text</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"没有更多了\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n      @load</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"onRefresh\"</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-swipe-cell\n        </span><span style=\"color: rgba(255, 0, 0, 1);\">v-for</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"(item, index) in list\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n        :key</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"index\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n        class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"m-2 overflow-hidden border border-gray-300 rounded-[12px]\"</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 主体内容 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">template </span><span style=\"color: rgba(255, 0, 0, 1);\">#default</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"box-border min-w-0 w-full flex flex-row items-start p-2\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 图片区域 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-image\n              </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"h-[100px] w-[100px] flex-shrink-0 rounded-md\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n              fit</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"contain\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n              :src</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"!isNullOrUnDef(item.creatsign) ? item.creatsign : '/images/img_nodata.png'\"</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n\n            <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 文本区域 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div\n              </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"ml-4 min-w-0 flex-1\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n              @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"showDetail(item.id ?? '')\"</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n              <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"whitespace-normal break-words text-base font-medium\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                {{ item.item1 }}/{{ item.item2 }}/{{ item.item3 }}/{{ item.item4 }}\n              </span><span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n              <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"mt-2 flex flex-col whitespace-normal break-words text-sm text-gray-500\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                    状态:\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-tag </span><span style=\"color: rgba(255, 0, 0, 1);\">:type</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"getStatusTag(item.status ?? 0)\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                    {{ getStatus(item.status) }}\n                  </span><span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-tag</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>{{ format(item.createtime) }}<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n              <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 删除按钮 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">template </span><span style=\"color: rgba(255, 0, 0, 1);\">#right</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"h-full w-[64px] flex items-center justify-center bg-red-500\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-icon </span><span style=\"color: rgba(255, 0, 0, 1);\">name</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"delete\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> color</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"#fff\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> size</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"20\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"deleteItem(item)\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-swipe-cell</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-list</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"m-2\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar-icon </span><span style=\"color: rgba(255, 0, 0, 1);\">text</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"返回\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> icon</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"arrow-left\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"goback\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar-button </span><span style=\"color: rgba(255, 0, 0, 1);\">color</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"green\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> text</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"创建工作项目\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"createItem\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"mb-20\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-back-top </span><span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span></pre>\n</div>\n<p>从而实现了我们前面介绍的页面效果。</p>\n<p><img alt=\"image\" height=\"741\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144121321-490674470.png\" width=\"346\" />&nbsp;&nbsp;<img alt=\"image\" height=\"746\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230150350899-1651155846.png\" width=\"348\" /></p>\n<p>&nbsp;其他页面的效果也是类似，参考相关的界面实现来调整展示效果即可，不在赘述。</p>\n<p>&nbsp;如需进一步了解H5应用端的功能介绍，可以参考随笔《<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuhuacong/p/19039255\" id=\"cb_post_title_url\" title=\"发布于 2025-08-15 13:36\">基于Vant4+Vue3+TypeScript的H5移动前端</a>》，进行深入的了解。</p>\n</div>\n<div id=\"MySignature\">\n    <div style=\"border-right-color: #cccccc; border-right-width: 1px; border-right-style: solid; padding-right: 5px; border-top-color: #cccccc; border-top-width: 1px; border-top-style: solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left-color: #cccccc; border-left-width: 1px; border-left-style: solid; width: 98%; padding-top: 4px; border-bottom-color: #cccccc; border-bottom-width: 1px; border-bottom-style: solid; background-color: #eeeeee;\">\n    <img align=\"top\" alt=\"\" src=\"http://www.cnblogs.com/Images/OutliningIndicators/None.gif\" />\n    <span style=\"color: #000000;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"></span>\n     专注于代码生成工具、.Net/Python 框架架构及软件开发，以及各种Vue.js的前端技术应用。著有Winform开发框架/混合式开发框架、微信开发框架、Bootstrap开发框架、ABP开发框架、SqlSugar开发框架、Python开发框架等框架产品。\n     <br />&nbsp;&nbsp;转载请注明出处：撰写人：伍华聪&nbsp;&nbsp;<a href=\"http://www.iqidi.com/\" target=\"_blank\">http://www.iqidi.com</a>&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;</span></div>\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2025-12-30 15:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wuhuacong\">伍华聪</a>&nbsp;\n阅读(<span id=\"post_view_count\">35</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "实用程序：Python打造进程网络监控与分析工具——全方位掌握你的网络与进程状态",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19421354",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19421354\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 14:57\">\n    <span>实用程序：Python打造进程网络监控与分析工具——全方位掌握你的网络与进程状态</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文介绍了一款基于Python开发的GUI网络监控工具，能够实时监控进程网络活动、分析端口占用情况、诊断网络问题。该工具支持Windows系统，提供进程带宽管理、端口筛选、网速测试、路由追踪等功能，并可将数据导出为CSV或图表。界面简洁易用，集成实时刷新、带宽限制等高级功能，适合普通用户排查网络故障和开发者分析程序行为。项目已开源，包含详细功能展示和操作指南，后续将优化多平台兼容性。代码地址：https://github.com/ChenAI-TGF/SysNetMonitor_GUI\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>在日常使用电脑的过程中，你是否好奇过这些困惑：为什么网络突然变卡？哪个进程在偷偷占用大量带宽？某个端口被哪个程序占用了？为了解决这些问题，博主用python开发了一款「进程网络监控与分析工具」，它能全方位监控网络状态、分析进程网络行为、诊断网络问题，帮你轻松掌握系统网络全貌。程序涵盖进程网络监控，系统总带宽波动查询，网络环境信息，端口占用监控，网络诊断服务，限制宽带等全面的功能，并配有UI界面，0上手门槛！</p>\n<p><strong>代码已开源到Github，欢迎访问下载：<a href=\"https://github.com/ChenAI-TGF/SysNetMonitor_GUI\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/SysNetMonitor_GUI</a><br />\n如果觉得好用的话可以点点Star，十分感谢！！</strong><br />\n<strong>也可以直接私信我要开源代码</strong></p>\n<p>先来个界面预览：<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"项目简介\">项目简介</h1>\n<p>这款工具是基于Python开发的GUI应用，旨在为用户提供直观、全面的网络与进程监控能力。无论是普通用户排查网络故障，还是开发者分析程序网络行为，都能满足需求。工具支持Windows主流系统，部分功能兼容Linux/macOS，界面简洁大方，操作简单易上手。</p>\n<h1 id=\"环境要求\">环境要求</h1>\n<p>在使用工具前，需确保你的环境满足以下要求：</p>\n<ul>\n<li><strong>Python版本</strong>：3.7及以上（推荐3.9+，兼容性更佳）</li>\n<li><strong>支持系统</strong>：主要支持Windows（部分功能兼容Linux/macOS）</li>\n<li><strong>依赖库</strong>：\n<ul>\n<li>内置库：tkinter、ctypes、platform、socket（无需额外安装）</li>\n<li>第三方库：psutil（进程与系统监控）、ttkbootstrap（UI美化）、matplotlib（图表绘制）、numpy（数据处理）、requests（网络请求）、netifaces（网络接口信息）、speedtest-cli（网速测试）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"核心功能详解\">核心功能详解</h1>\n<p>工具包含多个大核心功能模块，覆盖从进程监控到网络诊断的全场景需求，以下是详细介绍：</p>\n<h2 id=\"1-进程网络监控\">1. 进程网络监控</h2>\n<p>这是工具的核心功能之一，能够实时展示系统中所有进程的网络活动状态。</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>实时监控</strong>：显示进程的PID、名称、本地/远程IP端口、上传/下载速度、总流量等关键信息。</li>\n<li><strong>详情查看</strong>：双击任意进程，可打开详情窗口，查看该进程的带宽变化曲线（支持实时刷新）、历史网络活动记录。</li>\n<li><strong>带宽管理</strong>：在进程详情窗口中，可设置上传/下载带宽预警阈值（当超过阈值时会触发提醒）；在主界面选中进程后，点击「限制进程带宽」可手动限制其网络速度。</li>\n</ul>\n<h2 id=\"2-端口占用监控\">2. 端口占用监控</h2>\n<p>轻松网络调试中，端口占用是常见问题，该模块可快速定位端口占用情况：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>端口信息全展示</strong>：表格列出所有端口的协议类型（TCP/UDP）、本地IP和端口、远程IP和端口、连接状态、所属进程PID及名称。</li>\n<li><strong>精准筛选</strong>：支持通过端口号搜索和协议类型（TCP/UDP/全部）筛选，快速定位目标端口。</li>\n<li><strong>关联进程</strong>：双击端口查看端口对应的进程名称和PID，方便直接占用端口的程序（双击端口记录可跳进程详情）。</li>\n</ul>\n<h2 id=\"3-网络环境信息\">3. 网络环境信息</h2>\n<p>全面展示当前网络环境的基础信息，帮你快速了解当前网络配置：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>网络概览</strong>：包含公网IP、运营商信息、ASN（自治系统编号）、网络类型（有线/无线）、默认网关、DNS服务器、网络延迟和丢包率。</li>\n<li><strong>网卡详情</strong>：显示所有网卡的详细信息，包括网卡名称、MAC地址、IP地址（IPv4/IPv6）、子网掩码、广播地址等。</li>\n<li><strong>一键刷新</strong>：点击「刷新网络信息」按钮，可实时更新所有网络环境数据。</li>\n</ul>\n<h3 id=\"4-网络诊断工具\">4. 网络诊断工具</h3>\n<p>集成网络故障排查提供实用功能：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>网速测试</strong>：测试当前网络的上传/下载速度（基于speedtest-cli）。</li>\n<li><strong>Ping测试</strong>：输入目标IP或域名，执行Ping命令，查看延迟和丢包情况。</li>\n<li><strong>路由追踪</strong>：追踪数据包从本地到目标地址的路由路径，定位网络瓶颈节点。</li>\n</ul>\n<h2 id=\"5-数据导出与分析\">5. 数据导出与分析</h2>\n<p>支持将监控数据导出保存，方便后续分析：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>数据导出</strong>：在「操作面板」标签页，可将进程网络数据、端口占用数据导出为CSV格式，便于用Excel等工具进一步分析。</li>\n<li><strong>图表导出</strong>：在进程详情窗口的带宽曲线图中，点击「导出图表」可将实时带宽曲线保存为PNG图片。</li>\n</ul>\n<p>导出效果如下<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"6-进程具体数据分析\">6. 进程具体数据分析</h2>\n<h3 id=\"61-基本信息\">6.1 基本信息</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"62-网络信息\">6.2 网络信息</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"62-带宽曲线图\">6.2 带宽曲线图</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"64-连接详情\">6.4 连接详情</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"65-流量分析\">6.5 流量分析</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"使用方法\">使用方法</h1>\n<h2 id=\"1-运行应用\">1. 运行应用</h2>\n<ul>\n<li>直接执行脚本：<code>python 你的脚本文件名.py</code></li>\n<li>执行脚本之后，如果你不是以管理员权限运行的脚本，程序会询问你是否可以用管理员权限来执行，选择是既可<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></li>\n</ul>\n<h3 id=\"2-基本操作\">2. 基本操作</h3>\n<ul>\n<li>各标签页均均有「刷新」按钮，点击可手动更新数据。</li>\n<li>在「进程网络监控」标签页双击进程，打开详情窗口；在「端口占用监控」标签页双击端口记录，查看对应进程信息。</li>\n</ul>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"3-高级功能\">3. 高级功能</h3>\n<ul>\n<li>\n<p><strong>带宽限制设置</strong>：在进程详情窗口配置该进程上传和下载的带宽限制。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p><strong>多条件筛选</strong>：端口监控支持组合筛选（端口号+协议），快速定位异常连接。</p>\n</li>\n</ul>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"项目亮点\">项目亮点</h2>\n<ol>\n<li><strong>功能全面</strong>：整合进程监控、端口分析、网络诊断、数据导出等功能，一站式解决网络监控需求。</li>\n<li><strong>界面友好</strong>：基于ttkbootstrap打造的UI，简洁美观，操作逻辑清晰，适合各类用户。</li>\n<li><strong>实时性强</strong>：数据刷新及时，带宽曲线实时绘制，能精准反映网络状态变化。</li>\n<li><strong>跨平台潜力</strong>：核心功能在Linux/macOS上可兼容，未来将进一步完善多平台支持。</li>\n</ol>\n<h2 id=\"总结\">总结</h2>\n<p>这款进程网络监控与分析工具旨在为用户提供透明、可控的网络管理能力。无论是普通用户解决网络卡顿问题，还是开发者调试程序网络行为，都能从中受益。目前工具已实现核心功能，后续将持续优化多平台兼容性，并增加更多高级分析功能（如网络流量趋势预测、异常连接智能预警等）。</p>\n<p><strong>代码已开源到Github，欢迎访问下载：<a href=\"https://github.com/ChenAI-TGF/SysNetMonitor_GUI\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/SysNetMonitor_GUI</a><br />\n如果觉得好用的话可以点点Star，十分感谢！！</strong></p>\n<p>如果你也有网络监控的需求，欢迎尝试这款工具，如有问题或建议，欢迎在项目仓库留言交流！<br />\n<strong>也可以直接私信我要开源代码</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 14:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\n阅读(<span id=\"post_view_count\">16</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "回归分析全家桶（16种回归模型实现方式总结）",
      "link": "https://www.cnblogs.com/wang_yb/p/19421224",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19421224\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 14:47\">\n    <span>回归分析全家桶（16种回归模型实现方式总结）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>提到回归分析，很多人第一时间想到的只有“线性回归”和“逻辑回归”。但实际上，针对不同的数据情况（比如有离群点、数据是计数的、数据有缺失截断等），我们有十几种回归模型可以选择。</p>\n<p>今天为大家总结了 <strong>16种回归分析</strong> 的模型，重点不是介绍这些回归模型的原理，而是介绍如何在Python代码中使用这些模型，希望你以后能够在实战中来应用这些模型！</p>\n<h1 id=\"1-回归分析全家桶\">1. 回归分析全家桶</h1>\n<p>下面介绍如何使用各种回归模型的示例代码，主要分为以下一些步骤：</p>\n<ul>\n<li><strong>模拟数据</strong>：创建适合某种回归模型的测试数据</li>\n<li><strong>创建回归模型并训练</strong>：主要使用 <code>scikit-learn</code> 这个库</li>\n<li><strong>评估模型</strong>：有时会和其他回归模型对比</li>\n<li><strong>可视化模型</strong>：使用<code>matplotlib</code>这个库，简单展示模型效果</li>\n</ul>\n<p>由于担心文章篇幅太长，文中的示例没有贴出完整的代码（特别是可视化部分的代码，比较繁琐，文中都省略了），文章末尾提供了完整代码（一个<code>jupyter notebook</code>文件）的下载地址，包括了所有可视化的代码。</p>\n<p>下面的代码中统一导入了下面的库：</p>\n<pre><code class=\"language-python\">import pandas as pd\nimport numpy as np\n\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n# 为了显示中文\nmatplotlib.rcParams[\"font.sans-serif\"] = [\"Microsoft YaHei Mono\"]\nmatplotlib.rcParams[\"axes.unicode_minus\"] = False\n</code></pre>\n<h2 id=\"11-线性回归-linear-regression\">1.1. 线性回归 (Linear Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：最基础的回归，假设自变量（X）和因变量（Y）之间是“直来直去”的线性关系。</li>\n<li><strong>使用场景</strong>：预测房价、销售额等连续数值，且数据没有明显的复杂非线性关系。</li>\n</ul>\n<p><strong>线性回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 线性回归 (Linear Regression)\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error, r2_score\n\n# 构造测试数据\n# 假设我们要模拟房屋面积（自变量X）和房价（因变量Y）的关系\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\n# 生成100个房屋面积数据，范围在50-200平方米\nX = np.random.rand(100, 1) * 150 + 50\n\n# 真实的线性关系：房价 = 5000 * 面积 + 100000 + 随机噪声\n# 其中5000是每平方米的价格，100000是基础价格\n# 加入一些随机噪声，使数据更真实\nY_true = 5000 * X + 100000\nY = Y_true + np.random.randn(100, 1) * 50000  # 加入标准差为50000的噪声\n\n# 使用线性回归模型\nmodel = LinearRegression()\nmodel.fit(X, Y)\n\n# 预测\nY_pred = model.predict(X)\n\n# 打印模型参数\nprint(\"线性回归模型参数：\")\nprint(f\"截距（基础价格）: {model.intercept_[0]:.2f}\")\nprint(f\"斜率（每平方米价格）: {model.coef_[0][0]:.2f}\")\n\n# 评估模型\nmse = mean_squared_error(Y, Y_pred)\nr2 = r2_score(Y, Y_pred)\nprint(f\"\\n模型评估：\")\nprint(f\"均方误差 (MSE): {mse:.2f}\")\nprint(f\"决定系数 (R²): {r2:.2f}\")\n\n# 使用matplotlib绘制图像\n#... 省略 ...\n\n## 运行结果：\n'''\n线性回归模型参数：\n截距（基础价格）: 118417.69\n斜率（每平方米价格）: 4846.74\n\n模型评估：\n均方误差 (MSE): 2016461409.92\n决定系数 (R²): 0.96\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331409-1637286150.png\" /></p>\n<h2 id=\"12-多项式回归-polynomial-regression\">1.2. 多项式回归 (Polynomial Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：当数据不是直线分布，而是像曲线一样弯曲时，我们给自变量加上平方、立方等“高次项”来拟合曲线。</li>\n<li><strong>使用场景</strong>：拟合生物生长曲线、由于边际效应递减导致的经济学数据等非线性关系。</li>\n</ul>\n<p><strong>多项式回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 多项式回归 (Polynomial Regression)\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.metrics import mean_squared_error, r2_score\n\n# 1. 构造强非线性测试数据（模拟生物生长曲线）\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\n# 生成100个自变量数据，范围在0-15\nX = np.random.rand(100, 1) * 15\n\n# 真实的强非线性关系：使用类似S型曲线的函数（Logistic生长模型的变形）\n# Y = 100 / (1 + exp(-0.5*(X-7))) + 随机噪声\n# 这个关系模拟了生物生长曲线：初期缓慢，中期快速增长，后期趋于饱和\nY_true = 100 / (1 + np.exp(-0.5 * (X - 7)))\nY = Y_true + np.random.randn(100, 1) * 5  # 加入标准差为5的噪声\n\n# 2. 多项式回归（使用三次多项式）\n# 转换特征，添加平方和立方项\npoly_features = PolynomialFeatures(degree=3, include_bias=False)\nX_poly = poly_features.fit_transform(X)\n\n# 使用线性回归拟合转换后的特征\nmodel = LinearRegression()\nmodel.fit(X_poly, Y)\n\n# 预测\nY_pred = model.predict(X_poly)\n\n# 打印模型参数\nprint(\"多项式回归模型参数（三次多项式）：\")\nprint(f\"截距: {model.intercept_[0]:.2f}\")\nprint(f\"系数: {model.coef_[0]}\")\n\n# 评估模型\nmse = mean_squared_error(Y, Y_pred)\nr2 = r2_score(Y, Y_pred)\nprint(f\"\\n模型评估：\")\nprint(f\"均方误差 (MSE): {mse:.2f}\")\nprint(f\"决定系数 (R²): {r2:.2f}\")\n\n# 3. 使用线性回归作为对比\nlinear_model = LinearRegression()\nlinear_model.fit(X, Y)\nY_linear_pred = linear_model.predict(X)\n\n# 评估线性回归模型\nlinear_mse = mean_squared_error(Y, Y_linear_pred)\nlinear_r2 = r2_score(Y, Y_linear_pred)\nprint(f\"\\n线性回归模型评估：\")\nprint(f\"均方误差 (MSE): {linear_mse:.2f}\")\nprint(f\"决定系数 (R²): {linear_r2:.2f}\")\n\n# 4. 使用matplotlib绘制图像\n#... 省略 ...\n\n## 运行结果：\n'''\n多项式回归模型参数（三次多项式）：\n截距: 8.70\n系数: [-4.29511575  2.09659382 -0.09560718]\n\n模型评估：\n均方误差 (MSE): 20.02\n决定系数 (R²): 0.98\n\n线性回归模型评估：\n均方误差 (MSE): 56.71\n决定系数 (R²): 0.95\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331139-1466034349.png\" /></p>\n<p>从示例可以看出，线性回归只能用一条直线拟合所有数据，无法捕捉到S型曲线的弯曲特征。</p>\n<p><strong>多项式回归</strong>能够更好地贴合数据的非线性模式，尤其是在曲线的弯曲部分，</p>\n<p>这种对比清晰地展示了多项式回归在处理非线性数据时的优势。</p>\n<h2 id=\"13-逻辑回归-logistic-regression\">1.3. 逻辑回归 (Logistic Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：虽然叫“回归”，但其实是做<strong>分类</strong>的。它预测的是事件发生的概率（0到1之间），输出结果通常通过阈值（如0.5）划分为两类。</li>\n<li><strong>使用场景</strong>：预测用户是否会购买（是/否）、病人是否患病、邮件是否为垃圾邮件。</li>\n</ul>\n<p><strong>逻辑回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 逻辑回归 (Logistic Regression)\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import accuracy_score\n\n# 1. 构造二分类测试数据（模拟用户购买预测场景）\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\n# 类别0：不会购买的用户特征（如浏览时长和页面访问量）\nn_class0 = 100\nclass0_features = np.random.randn(n_class0, 2) * 1.5 + [3, 3]\nclass0_labels = np.zeros(n_class0)\n\n# 类别1：会购买的用户特征\nn_class1 = 100\nclass1_features = np.random.randn(n_class1, 2) * 1.5 + [6, 6]\nclass1_labels = np.ones(n_class1)\n\n# 合并数据集\nX = np.vstack([class0_features, class1_features])\ny = np.hstack([class0_labels, class1_labels])\n\n# 2. 训练逻辑回归模型\nmodel = LogisticRegression()\nmodel.fit(X, y)\n\n# 预测\ny_pred_proba = model.predict_proba(X)[:, 1]\ny_pred = model.predict(X)\n\n# 模型评估\naccuracy = accuracy_score(y, y_pred)\nprint(f\"逻辑回归模型准确率: {accuracy:.2f}\")\n\n# 3. 绘制图像\n#... 省略 ...\n\n## 运行结果：\n'''\n逻辑回归模型准确率: 0.93\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331982-1885882694.png\" /></p>\n<p>这个示例清晰展示了逻辑回归如何进行二分类预测，并通过可视化直观呈现了分类结果、决策边界和概率分布，完全符合逻辑回归的应用场景（预测事件发生概率）。</p>\n<h2 id=\"14-分位数回归-quantile-regression\">1.4. 分位数回归 (Quantile Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：普通回归预测的是“平均值”，而分位数回归可以预测“中位数”或者任意百分位点（如前10%）。</li>\n<li><strong>使用场景</strong>：数据中有极端异常值（离群点），或者你想研究不同层级的数据（如分析贫困人口和富裕人口的收入影响因素差异）。</li>\n</ul>\n<p><strong>分位数回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 分位数回归 (Quantile Regression)\nimport statsmodels.api as sm\nfrom sklearn.linear_model import LinearRegression\n\n# 1. 构造包含极端异常值的测试数据\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\n# 生成基础自变量数据（如收入）\nX = np.linspace(10, 100, 100).reshape(-1, 1)\n\n# 基础线性关系：消费 = 0.6 * 收入 + 10 + 随机噪声\nY_true = 0.6 * X + 10\nY = Y_true + np.random.normal(0, 5, size=X.shape)  # 加入正常噪声\n\n# 添加极端异常值（模拟高消费人群的极端消费行为）\n# 选择最后10个数据点，添加大的正异常值\nY[-10:] += np.random.normal(100, 20, size=(10, 1))\n\n# 2. 普通线性回归\nlinear_model = LinearRegression()\nlinear_model.fit(X, Y)\nY_linear_pred = linear_model.predict(X)\n\n# 3. 分位数回归\n# 添加常数项\nX_with_const = sm.add_constant(X)\n\n# 定义要估计的分位数\nquantiles = [0.1, 0.5, 0.9]\nquantile_results = {}\n\n# 拟合不同分位数的模型\nfor q in quantiles:\n    model = sm.QuantReg(Y, X_with_const)\n    result = model.fit(q=q)\n    quantile_results[q] = result\n\n# 4. 预测不同分位数的结果\nY_quantile_pred = {}\nfor q in quantiles:\n    Y_quantile_pred[q] = quantile_results[q].predict(X_with_const)\n\n# 5. 绘制图像\n#... 省略 ...\n\n# 打印模型参数对比\nprint(\"\\n=== 模型参数对比 ===\")\nprint(\n    f\"普通线性回归: 截距={linear_model.intercept_[0]:.2f}, 斜率={linear_model.coef_[0][0]:.2f}\"\n)\nfor q in quantiles:\n    intercept = quantile_results[q].params[0]\n    slope = quantile_results[q].params[1]\n    print(f\"分位数回归(τ={q:.1f}): 截距={intercept:.2f}, 斜率={slope:.2f}\")\n\n## 运行结果：\n'''\n=== 模型参数对比 ===\n普通线性回归: 截距=-13.59, 斜率=1.20\n分位数回归(τ=0.1): 截距=0.59, 斜率=0.66\n分位数回归(τ=0.5): 截距=6.95, 斜率=0.67\n分位数回归(τ=0.9): 截距=-3.01, 斜率=1.73\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331673-243100488.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>不同分位数的回归线斜率和截距各不相同</li>\n<li>高消费分位(τ=0.9)的回归线最接近异常值，而低消费分位(τ=0.1)的回归线几乎不受异常值影响</li>\n<li>中位数回归(τ=0.5)相对普通线性回归更能抵抗异常值的影响</li>\n</ul>\n<p>这个示例清晰地展示了<strong>分位数回归</strong>如何处理<strong>极端异常值</strong>，以及如何通过不同分位数分析数据的不同层级结构，非常适合用户描述的使用场景（数据中有极端异常值或需要研究不同层级数据）。</p>\n<h2 id=\"15-岭回归-ridge-regression\">1.5. 岭回归 (Ridge Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：在线性回归的基础上加了一个“惩罚项”（L2正则化），防止模型为了迎合训练数据而变得太复杂（过拟合）。</li>\n<li><strong>使用场景</strong>：特征之间相关性很高（多重共线性）导致普通回归失效时。</li>\n</ul>\n<p><strong>岭回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 岭回归 (Ridge Regression)\nfrom sklearn.linear_model import LinearRegression, Ridge\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import StandardScaler\n\n# 1. 构造具有多重共线性的测试数据\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\n# 生成基础特征（如房屋的总面积）\nX1 = np.random.rand(100, 1) * 100 + 50  # 50-150平方米\n\n# 生成高度相关的第二个特征（如房屋的可用面积）\n# 设置高度相关性：X2 = 0.8*X1 + 少量噪声\nX2 = 0.8 * X1 + np.random.randn(100, 1) * 5\nX = np.hstack([X1, X2])  # 合并两个特征\n\n# 真实的线性关系：房价 = 10000*X1 + 8000*X2 + 500000 + 随机噪声\nY_true = 10000 * X1 + 8000 * X2 + 500000\nY = Y_true + np.random.randn(100, 1) * 200000  # 加入噪声\n\n# 2. 数据标准化（岭回归对特征缩放敏感）\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nY_scaled = scaler.fit_transform(Y)\n\n# 3. 普通线性回归\nlinear_model = LinearRegression()\nlinear_model.fit(X_scaled, Y_scaled)\nY_linear_pred = linear_model.predict(X_scaled)\n\n# 4. 岭回归（不同的正则化参数λ）\n# 移除0值以避免log10(0)的警告\nlambdas = [0.1, 1, 10, 100, 1000]  # 不同的λ值\nridge_models = {}\nridge_preds = {}\nridge_coefs = []\n\nfor lam in lambdas:\n    model = Ridge(alpha=lam)\n    model.fit(X_scaled, Y_scaled)\n    ridge_models[lam] = model\n    ridge_preds[lam] = model.predict(X_scaled)\n    ridge_coefs.append(model.coef_.flatten())\n\n# 5. 可视化结果\n#... 省略 ...\n\n# 计算并比较MSE\nprint(\"\\n=== 模型性能比较 (MSE) ===\")\nprint(f\"普通线性回归 MSE: {mean_squared_error(Y_scaled, Y_linear_pred):.4f}\")\nfor lam in lambdas:\n    mse = mean_squared_error(Y_scaled, ridge_preds[lam])\n    print(f\"岭回归 (λ={lam}) MSE: {mse:.4f}\")\n\n## 运行结果：\n'''\n=== 模型性能比较 (MSE) ===\n普通线性回归 MSE: 0.1705\n岭回归 (λ=0.1) MSE: 0.1705\n岭回归 (λ=1) MSE: 0.1706\n岭回归 (λ=10) MSE: 0.1730\n岭回归 (λ=100) MSE: 0.2645\n岭回归 (λ=1000) MSE: 0.7486\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331106-2018685368.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331742-1675204939.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>普通线性回归在多重共线性下系数可能不稳定</li>\n<li>随着λ增大，岭回归系数逐渐减小并趋向稳定</li>\n<li>合适的λ值可以在保持预测准确性的同时提高模型稳定性</li>\n</ul>\n<p>这个示例清晰地展示了<strong>岭回归</strong>在处理<strong>多重共线性数据</strong>时的优势，以及如何通过正则化参数λ来平衡模型复杂度和预测准确性。</p>\n<h2 id=\"16-lasso回归-lasso-regression\">1.6. Lasso回归 (Lasso Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：和岭回归类似，但使用的是L1正则化。它不仅能防止过拟合，还能把不重要的特征系数强行压缩为0。</li>\n<li><strong>使用场景</strong>：当你有很多特征，想要自动筛选出最重要的几个特征时。</li>\n</ul>\n<hr />\n<p><strong>Lasso回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># Lasso回归 (Lasso Regression)\nfrom sklearn.linear_model import LinearRegression, Lasso\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import StandardScaler\n\n# 1. 构造多特征测试数据（大部分特征不重要）\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\nn_samples = 100\nn_features = 10  # 总共10个特征\n\n# 生成10个特征，前3个是真正重要的，后7个是不重要的\nX = np.random.randn(n_samples, n_features)\n\n# 真实系数：前3个特征有较大的非零系数，后7个特征的系数为0\ntrue_coef = np.zeros(n_features)\ntrue_coef[0] = 10.0  # 重要特征1\ntrue_coef[1] = -8.0  # 重要特征2\ntrue_coef[2] = 5.0  # 重要特征3\n\n# 生成目标变量：Y = X * 真实系数 + 随机噪声\nY_true = X.dot(true_coef)\nY = Y_true + np.random.randn(n_samples) * 5  # 加入噪声\n\n# 2. 数据标准化（Lasso对特征缩放敏感）\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nY_scaled = scaler.fit_transform(Y.reshape(-1, 1)).ravel()\n\n# 3. 普通线性回归\nlinear_model = LinearRegression()\nlinear_model.fit(X_scaled, Y_scaled)\nY_linear_pred = linear_model.predict(X_scaled)\n\n# 4. Lasso回归（不同的正则化参数λ）\nlambdas = [0.01, 0.1, 0.5, 1.0, 5.0]  # 不同的λ值\nlasso_models = {}\nlasso_preds = {}\nlasso_coefs = []\n\nfor lam in lambdas:\n    model = Lasso(alpha=lam, max_iter=10000)  # 增加最大迭代次数避免收敛警告\n    model.fit(X_scaled, Y_scaled)\n    lasso_models[lam] = model\n    lasso_preds[lam] = model.predict(X_scaled)\n    lasso_coefs.append(model.coef_)\n\n# 5. 可视化结果\n#... 省略 ...\n\n# 计算并比较MSE\nprint(\"\\n=== 模型性能比较 (MSE) ===\")\nprint(f\"普通线性回归 MSE: {mean_squared_error(Y_scaled, Y_linear_pred):.4f}\")\nfor lam in lambdas:\n    mse = mean_squared_error(Y_scaled, lasso_preds[lam])\n    print(f\"Lasso回归 (λ={lam}) MSE: {mse:.4f}\")\n\n## 运行结果：\n'''\n=== 模型性能比较 (MSE) ===\n普通线性回归 MSE: 0.1024\nLasso回归 (λ=0.01) MSE: 0.1034\nLasso回归 (λ=0.1) MSE: 0.1384\nLasso回归 (λ=0.5) MSE: 0.6845\nLasso回归 (λ=1.0) MSE: 1.0000\nLasso回归 (λ=5.0) MSE: 1.0000\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144332120-340193149.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331129-81036439.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331123-660205758.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>随着λ增大，越来越多的系数被压缩为0</li>\n<li>Lasso能够自动识别并保留重要特征（前3个）</li>\n<li>适当的λ值可以在保持预测精度的同时实现特征选择</li>\n</ul>\n<p>这个示例很好地展示了<strong>Lasso回归</strong>的特征选择能力，非常适合用户描述的使用场景（当有很多特征，想要自动筛选出最重要的几个特征时）。</p>\n<h2 id=\"17-弹性网络回归-elastic-net-regression\">1.7. 弹性网络回归 (Elastic Net Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：岭回归和套索回归的“混血儿”，结合了它俩的优点。</li>\n<li><strong>使用场景</strong>：特征非常多且彼此高度相关，你既想选特征又想保持模型稳定时。</li>\n</ul>\n<p><strong>弹性网络回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 弹性网络回归 (Elastic Net Regression)\nfrom sklearn.linear_model import LinearRegression, Lasso, Ridge, ElasticNet\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import StandardScaler\n\n# 1. 构造高相关多特征测试数据\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\nn_samples = 100\nn_features = 10  # 总共10个特征\n\n# 生成基础特征\nbase_feature = np.random.randn(n_samples, 1)\n\n# 生成高度相关的特征组\n# 前3个特征高度相关（重要特征）\nX = np.zeros((n_samples, n_features))\nX[:, 0] = base_feature.ravel() + np.random.randn(n_samples) * 0.1  # 主特征1\nX[:, 1] = X[:, 0] * 0.8 + np.random.randn(n_samples) * 0.2  # 相关特征2\nX[:, 2] = X[:, 0] * 0.5 + X[:, 1] * 0.3 + np.random.randn(n_samples) * 0.2  # 相关特征3\n\n# 中间3个特征高度相关但不重要\nX[:, 3] = np.random.randn(n_samples) * 0.3 + X[:, 0] * 0.1  # 弱相关特征4\nX[:, 4] = X[:, 3] * 0.7 + np.random.randn(n_samples) * 0.2  # 相关特征5\nX[:, 5] = X[:, 3] * 0.6 + X[:, 4] * 0.4 + np.random.randn(n_samples) * 0.2  # 相关特征6\n\n# 最后4个特征是随机噪声（完全不重要）\nX[:, 6:] = np.random.randn(n_samples, 4) * 0.5\n\n# 真实系数：只有前3个重要特征有非零系数\ntrue_coef = np.zeros(n_features)\ntrue_coef[0] = 10.0\ntrue_coef[1] = -5.0\ntrue_coef[2] = 3.0\n\n# 生成目标变量\nY_true = X.dot(true_coef)\nY = Y_true + np.random.randn(n_samples) * 3  # 加入噪声\n\n# 2. 数据标准化（正则化模型对特征缩放敏感）\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nY_scaled = scaler.fit_transform(Y.reshape(-1, 1)).ravel()\n\n# 3. 训练不同的回归模型\n# 普通线性回归\nlinear_model = LinearRegression()\nlinear_model.fit(X_scaled, Y_scaled)\n\n# Lasso回归（λ=0.1）\nlasso_model = Lasso(alpha=0.1, max_iter=10000)\nlasso_model.fit(X_scaled, Y_scaled)\n\n# Ridge回归（λ=1.0）\nridge_model = Ridge(alpha=1.0)\nridge_model.fit(X_scaled, Y_scaled)\n\n# 弹性网络回归（不同的l1_ratio）\nelastic_models = {}\nl1_ratios = [0.1, 0.5, 0.9]  # 控制L1和L2的比例\nalpha = 1.0  # 总正则化强度\n\nfor ratio in l1_ratios:\n    model = ElasticNet(alpha=alpha, l1_ratio=ratio, max_iter=10000)\n    model.fit(X_scaled, Y_scaled)\n    elastic_models[ratio] = model\n\n# 4. 预测\nY_linear_pred = linear_model.predict(X_scaled)\nY_lasso_pred = lasso_model.predict(X_scaled)\nY_ridge_pred = ridge_model.predict(X_scaled)\nY_elastic_pred = {\n    ratio: model.predict(X_scaled) for ratio, model in elastic_models.items()\n}\n\n# 5. 可视化结果\n# ... 省略 ...\n\n# 6. 模型评估和特征选择效果\nprint(\"=== 模型性能评估 ===\")\nprint(f\"普通线性回归 MSE: {mean_squared_error(Y_scaled, Y_linear_pred):.4f}\")\nprint(f\"Lasso回归 MSE: {mean_squared_error(Y_scaled, Y_lasso_pred):.4f}\")\nprint(f\"Ridge回归 MSE: {mean_squared_error(Y_scaled, Y_ridge_pred):.4f}\")\nfor ratio in l1_ratios:\n    mse = mean_squared_error(Y_scaled, Y_elastic_pred[ratio])\n    print(f\"弹性网络 (l1_ratio={ratio}) MSE: {mse:.4f}\")\n\nprint(\"\\n=== 特征选择效果 ===\")\nprint(f\"普通线性回归非零系数数: {np.sum(linear_model.coef_ != 0)}\")\nprint(f\"Lasso回归非零系数数: {np.sum(lasso_model.coef_ != 0)}\")\nprint(\n    f\"Ridge回归非零系数数: {np.sum(ridge_model.coef_ != 0)}\"\n)  # Ridge几乎不会产生严格零系数\nfor ratio in l1_ratios:\n    non_zero_count = np.sum(elastic_models[ratio].coef_ != 0)\n    print(f\"弹性网络 (l1_ratio={ratio}) 非零系数数: {non_zero_count}\")\n\n## 运行结果：\n'''\n=== 模型性能评估 ===\n普通线性回归 MSE: 0.1352\nLasso回归 MSE: 0.1677\nRidge回归 MSE: 0.1369\n弹性网络 (l1_ratio=0.1) MSE: 0.2676\n弹性网络 (l1_ratio=0.5) MSE: 0.5002\n弹性网络 (l1_ratio=0.9) MSE: 0.9711\n\n=== 特征选择效果 ===\n普通线性回归非零系数数: 10\nLasso回归非零系数数: 2\nRidge回归非零系数数: 10\n弹性网络 (l1_ratio=0.1) 非零系数数: 3\n弹性网络 (l1_ratio=0.5) 非零系数数: 3\n弹性网络 (l1_ratio=0.9) 非零系数数: 1\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331684-1991608237.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331132-1346251950.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331150-224052372.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>弹性网络结合了Lasso的特征选择能力和Ridge的稳定性</li>\n<li>通过调整l1_ratio，可以在特征选择和系数稳定性之间找到平衡</li>\n<li>当特征高度相关时，弹性网络比Lasso更稳定，比Ridge更能进行特征选择</li>\n</ul>\n<p>这个示例很好地展示了<strong>弹性网络回归</strong>在处理<strong>高维</strong>、<strong>高度相关数据</strong>时的优势，特别适合需要同时进行特征选择和保持模型稳定的场景。</p>\n<h2 id=\"18-主成分回归-pcr\">1.8. 主成分回归 (PCR)</h2>\n<ul>\n<li><strong>一句话概念</strong>：先用PCA（主成分分析）把很多相关的特征压缩成几个不相关的“主成分”，再用这些主成分做回归。</li>\n<li><strong>使用场景</strong>：特征数量比样本数量还多，或者特征之间严重相关。</li>\n</ul>\n<p><strong>主成分回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 主成分回归 (PCR)\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error\n\n# 1. 构造高维高相关测试数据（特征数&gt;样本数）\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\nn_samples = 100\nn_features = 200  # 特征数多于样本数，模拟高维问题\n\n# 生成基础特征（只有3个真正重要的基础变量）\nbase_features = np.random.randn(n_samples, 3)\n\n# 生成200个高度相关的特征\n# 每个新特征都是3个基础特征的线性组合 + 少量噪声\nX = np.zeros((n_samples, n_features))\nfor i in range(n_features):\n    # 随机权重（确保特征之间高度相关）\n    weights = np.random.randn(3)\n    X[:, i] = base_features.dot(weights) + np.random.randn(n_samples) * 0.1\n\n# 真实系数：只有基于前3个基础特征的组合有意义\n# 我们只使用前10个特征来生成目标变量\ntrue_weights = np.zeros(n_features)\ntrue_weights[:10] = np.random.randn(10) * 2\n\n# 生成目标变量\nY_true = X.dot(true_weights)\nY = Y_true + np.random.randn(n_samples) * 5  # 加入噪声\n\n# 2. 数据标准化\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nY_scaled = scaler.fit_transform(Y.reshape(-1, 1)).ravel()\n\n# 3. 普通线性回归（可能过拟合）\nlinear_model = LinearRegression()\nlinear_model.fit(X_scaled, Y_scaled)\nY_linear_pred = linear_model.predict(X_scaled)\nlinear_mse = mean_squared_error(Y_scaled, Y_linear_pred)\n\n# 4. 主成分回归 (PCR)\n# 4.1 PCA降维\npca = PCA()\nX_pca = pca.fit_transform(X_scaled)\n\n# 4.2 计算累积方差解释率\nexplained_variance_ratio = pca.explained_variance_ratio_\ncumulative_variance_ratio = np.cumsum(explained_variance_ratio)\n\n# 4.3 选择保留的主成分数量（比如保留95%方差）\nn_components_95 = np.argmax(cumulative_variance_ratio &gt;= 0.95) + 1\nprint(f\"保留95%方差需要的主成分数: {n_components_95}\")\n\n# 4.4 使用不同数量的主成分进行回归\nn_components_list = [3, 5, 10, 20, n_components_95]\npcr_results = {}\n\nfor n in n_components_list:\n    # 使用前n个主成分\n    X_pca_n = X_pca[:, :n]\n\n    # 线性回归\n    model = LinearRegression()\n    model.fit(X_pca_n, Y_scaled)\n\n    # 预测\n    Y_pcr_pred = model.predict(X_pca_n)\n    mse = mean_squared_error(Y_scaled, Y_pcr_pred)\n\n    pcr_results[n] = {\n        'model': model,\n        'predictions': Y_pcr_pred,\n        'mse': mse\n    }\n\n# 5. 可视化结果\n# ... 省略 ...\n\n# 6. 模型性能对比\nprint(\"\\n=== 模型性能对比 ===\")\nprint(f\"普通线性回归 MSE: {linear_mse:.4f}\")\nfor n in n_components_list:\n    print(f\"PCR (n={n}) MSE: {pcr_results[n]['mse']:.4f}\")\n\n# 7. 展示PCR如何解决过拟合\nprint(\"\\n=== PCR解决过拟合效果 ===\")\nprint(f\"原始特征数量: {n_features}\")\nprint(f\"样本数量: {n_samples}\")\nprint(f\"普通回归的特征系数最大值: {np.max(np.abs(linear_model.coef_)):.4f}\")\nprint(f\"PCR (n={n_components_95}) 的特征系数最大值: {np.max(np.abs(pcr_coef)):.4f}\")\n\n## 运行结果：\n'''\n=== 模型性能对比 ===\n普通线性回归 MSE: 0.0000\nPCR (n=3) MSE: 0.5484\nPCR (n=5) MSE: 0.5187\nPCR (n=10) MSE: 0.4777\nPCR (n=20) MSE: 0.4040\nPCR (n=3) MSE: 0.5484\n\n=== PCR解决过拟合效果 ===\n原始特征数量: 200\n样本数量: 100\n普通回归的特征系数最大值: 2.1407\nPCR (n=3) 的特征系数最大值: 0.0101\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331885-1026425432.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331170-1231259987.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331130-574001026.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>只需少量主成分（通常&lt;30）即可保留95%以上的方差</li>\n<li>PCR的预测效果优于直接线性回归，尤其是在高维数据中</li>\n<li>PCR的系数更加稳定，避免了普通回归中系数过大的问题</li>\n</ul>\n<p>这个示例完美展示了<code>PCR</code>在<strong>高维</strong>、<strong>高度相关数据</strong>中的应用，解决了直接线性回归的过拟合问题，同时保持了良好的预测性能。</p>\n<h2 id=\"19-偏最小二乘回归-pls-regression\">1.9. 偏最小二乘回归 (PLS Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：和PCR类似，但它在降维时会考虑因变量Y的信息，确保提取出的成分不仅能概括X，还能很好地预测Y。</li>\n<li><strong>使用场景</strong>：比PCR更高级一点，常用于化学计量学或变量非常多的情况。</li>\n</ul>\n<p><strong>偏最小二乘回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 偏最小二乘回归 (PLS Regression)\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.decomposition import PCA\nfrom sklearn.cross_decomposition import PLSRegression\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error\n\n# 1. 构造高维相关数据，其中只有部分特征与Y相关\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\nn_samples = 100\nn_features = 100  # 100个特征，模拟高维问题\n\n# 生成基础变量\n# 前5个变量与Y高度相关，中间15个变量与Y弱相关，最后80个变量与Y不相关\nbase_vars = np.random.randn(n_samples, 20)\nnoise_vars = np.random.randn(n_samples, 80)  # 完全不相关的噪声特征\n\n# 组合所有特征\nX = np.hstack([base_vars, noise_vars])\n\n# 生成Y，主要依赖前5个基础变量\nY_true = (\n    5 * base_vars[:, 0]\n    + 3 * base_vars[:, 1]\n    - 4 * base_vars[:, 2]\n    + 2 * base_vars[:, 3]\n    + base_vars[:, 4]\n)\nY = Y_true + np.random.randn(n_samples) * 3  # 加入噪声\n\n# 2. 数据标准化\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nY_scaled = scaler.fit_transform(Y.reshape(-1, 1)).ravel()\n\n# 3. 普通线性回归（作为基准）\nlinear_model = LinearRegression()\nlinear_model.fit(X_scaled, Y_scaled)\nY_linear_pred = linear_model.predict(X_scaled)\nlinear_mse = mean_squared_error(Y_scaled, Y_linear_pred)\n\n# 4. PCA + 线性回归 (PCR)\npca = PCA()\nX_pca = pca.fit_transform(X_scaled)\n\n# 5. 偏最小二乘回归 (PLS)\npls = PLSRegression(n_components=20)\nX_pls = pls.fit_transform(X_scaled, Y_scaled)[0]\n\n# 6. 比较不同成分数量的PCR和PLS性能\nn_components_list = range(1, 21)\npcr_mse_list = []\npls_mse_list = []\n\nfor n in n_components_list:\n    # PCR\n    model_pcr = LinearRegression()\n    model_pcr.fit(X_pca[:, :n], Y_scaled)\n    Y_pcr_pred = model_pcr.predict(X_pca[:, :n])\n    pcr_mse_list.append(mean_squared_error(Y_scaled, Y_pcr_pred))\n\n    # PLS\n    model_pls = PLSRegression(n_components=n)\n    model_pls.fit(X_scaled, Y_scaled)\n    Y_pls_pred = model_pls.predict(X_scaled).ravel()\n    pls_mse_list.append(mean_squared_error(Y_scaled, Y_pls_pred))\n\n# 7. 可视化结果\n# ... 省略 ...\n\n# 输出结果\nprint(\"\\n=== 模型性能对比 ===\")\nprint(f\"普通线性回归 MSE: {linear_mse:.4f}\")\nprint(f\"最佳PCR (n={best_pcr_n}) MSE: {pcr_mse_list[best_pcr_n-1]:.4f}\")\nprint(f\"最佳PLS (n={best_pls_n}) MSE: {pls_mse_list[best_pls_n-1]:.4f}\")\nprint(\n    f\"PLS相比最佳PCR的MSE提升: {(pcr_mse_list[best_pcr_n-1] - pls_mse_list[best_pls_n-1])/pcr_mse_list[best_pcr_n-1]*100:.1f}%\"\n)\n\n# 展示PLS如何提取与Y相关的成分\nprint(\"\\n=== PLS成分分析 ===\")\npls_var_importance = np.abs(pls.x_weights_).sum(axis=1)\nprint(f\"PLS前5个最重要成分的方差贡献: {np.sort(pls_var_importance)[::-1][:5]}\")\n\n## 运行结果：\n'''\n=== 模型性能对比 ===\n普通线性回归 MSE: 0.0000\n最佳PCR (n=20) MSE: 0.6687\n最佳PLS (n=20) MSE: 0.0048\nPLS相比最佳PCR的MSE提升: 99.3%\n\n=== PLS成分分析 ===\nPLS前5个最重要成分的方差贡献: [2.4938574  2.27964709 2.17888686 2.08667187 2.06267069]\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331157-367253800.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331165-587185182.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331948-1785309370.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>PLS在较少的成分数下就能达到较好的预测效果</li>\n<li>PLS提取的成分与Y的相关性明显高于PCA成分</li>\n<li>当存在大量噪声特征时，PLS的优势更加明显</li>\n</ul>\n<p>这个示例清晰地展示了<strong>PLS回归</strong>如何在降维过程中考虑因变量Y的信息，从而在高维、存在噪声的情况下提供比PCR更好的预测性能。</p>\n<h2 id=\"110-支持向量回归-svr\">1.10. 支持向量回归 (SVR)</h2>\n<ul>\n<li><strong>一句话概念</strong>：借用了SVM分类的思想，试图找到一个“管道”包裹住尽可能多的数据点，在管道内的误差被忽略，只计算管道外的误差。</li>\n<li><strong>使用场景</strong>：高维数据，或者数据关系非常复杂非线性时（配合核函数）。</li>\n</ul>\n<p><strong>支持向量回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 支持向量回归 (SVR)\nfrom sklearn.svm import SVR\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error\n\n# 1. 构造复杂非线性测试数据\nnp.random.seed(42)  # 设置随机种子以确保结果可复现\n\n# 生成基础自变量（在0-10范围内）\nX = np.sort(np.random.rand(100, 1) * 10, axis=0)\n\n# 生成复杂的非线性目标变量：正弦函数 + 多项式 + 噪声\n# 这种非线性关系很难用普通线性回归拟合\nY_true = np.sin(2 * X) + 0.5 * X + 0.2 * X**2\nY = Y_true + np.random.randn(100, 1) * 0.5  # 加入噪声\n\n# 2. 数据标准化\nscaler_X = StandardScaler()\nscaler_Y = StandardScaler()\n\nX_scaled = scaler_X.fit_transform(X)\nY_scaled = scaler_Y.fit_transform(Y)\n\n# 3. 模型训练\n\n# 普通线性回归（作为基准）\nlinear_model = LinearRegression()\nlinear_model.fit(X_scaled, Y_scaled)\nY_linear_pred_scaled = linear_model.predict(X_scaled)\nY_linear_pred = scaler_Y.inverse_transform(Y_linear_pred_scaled)\n\n# 支持向量回归 (SVR)\n# 线性核SVR\nsvr_linear = SVR(kernel=\"linear\", C=100, epsilon=0.1)\nsvr_linear.fit(X_scaled, Y_scaled.ravel())\nY_svr_linear_pred_scaled = svr_linear.predict(X_scaled)\nY_svr_linear_pred = scaler_Y.inverse_transform(Y_svr_linear_pred_scaled.reshape(-1, 1))\n\n# RBF核SVR（非线性）\nsvr_rbf_1 = SVR(kernel=\"rbf\", C=100, epsilon=0.1, gamma=0.1)\nsvr_rbf_1.fit(X_scaled, Y_scaled.ravel())\nY_svr_rbf_1_pred_scaled = svr_rbf_1.predict(X_scaled)\nY_svr_rbf_1_pred = scaler_Y.inverse_transform(Y_svr_rbf_1_pred_scaled.reshape(-1, 1))\n\n# 不同ε值的RBF核SVR\nsvr_rbf_2 = SVR(kernel=\"rbf\", C=100, epsilon=0.5, gamma=0.1)\nsvr_rbf_2.fit(X_scaled, Y_scaled.ravel())\nY_svr_rbf_2_pred_scaled = svr_rbf_2.predict(X_scaled)\nY_svr_rbf_2_pred = scaler_Y.inverse_transform(Y_svr_rbf_2_pred_scaled.reshape(-1, 1))\n\n# 4. 计算模型性能\nmse_linear = mean_squared_error(Y, Y_linear_pred)\nmse_svr_linear = mean_squared_error(Y, Y_svr_linear_pred)\nmse_svr_rbf_1 = mean_squared_error(Y, Y_svr_rbf_1_pred)\nmse_svr_rbf_2 = mean_squared_error(Y, Y_svr_rbf_2_pred)\n\n# 5. 可视化结果\n# ... 省略 ...\n\n# 4. 输出模型性能\nprint(\"\\n=== 模型性能对比 ===\")\nprint(f\"普通线性回归 MSE: {mse_linear:.4f}\")\nprint(f\"线性核SVR MSE: {mse_svr_linear:.4f}\")\nprint(f\"RBF核SVR (ε=0.1) MSE: {mse_svr_rbf_1:.4f}\")\nprint(f\"RBF核SVR (ε=0.5) MSE: {mse_svr_rbf_2:.4f}\")\n\n# 展示支持向量\nprint(f\"\\n=== SVR支持向量信息 ===\")\nprint(f\"RBF核SVR (ε=0.1) 使用的支持向量数量: {len(svr_rbf_1.support_)}\")\nprint(f\"线性核SVR 使用的支持向量数量: {len(svr_linear.support_)}\")\n\n## 运行结果：\n'''\n=== 模型性能对比 ===\n普通线性回归 MSE: 3.3016\n线性核SVR MSE: 3.3938\nRBF核SVR (ε=0.1) MSE: 0.6200\nRBF核SVR (ε=0.5) MSE: 4.7397\n\n=== SVR支持向量信息 ===\nRBF核SVR (ε=0.1) 使用的支持向量数量: 42\n线性核SVR 使用的支持向量数量: 70\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144332001-578126908.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331772-1159748120.png\" /></p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331120-2032066286.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>RBF核SVR能够很好地拟合复杂非线性关系</li>\n<li>调整ε可以控制模型对误差的容忍度</li>\n<li>调整C可以平衡模型复杂度和对异常值的敏感度</li>\n<li>SVR只使用部分数据点（支持向量）进行预测</li>\n</ul>\n<p>这个示例完美展示了<code>SVR</code>在处理复杂非线性数据时的优势，特别是其独特的ε-不敏感损失函数和核函数机制。</p>\n<h2 id=\"111-有序回归-ordinal-regression\">1.11. 有序回归 (Ordinal Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：预测的结果是有顺序的类别，比如“低、中、高”或者“不喜欢、一般、喜欢”。</li>\n<li><strong>使用场景</strong>：问卷调查评分（1-5分）、电影评级、疾病严重程度分级。</li>\n</ul>\n<p><strong>有序回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 有序回归 (Ordinal Regression)\nimport statsmodels.api as sm\nfrom statsmodels.miscmodels.ordinal_model import OrderedModel\n\n# 1. 构造测试数据\nnp.random.seed(42)\nn_samples = 500\n\n# 特征：年龄（0-70岁）和购买金额（0-100元）\nage = np.random.uniform(0, 70, n_samples)\npurchase = np.random.uniform(0, 100, n_samples)\n\n# 真实系数：购买金额对满意度影响更大\nbeta_age = 0.03  # 年龄系数\nbeta_purchase = 0.08  # 购买金额系数\nintercept = -2.0  # 基准截距\n\n# 潜在变量（连续值，用于生成有序类别）\nlatent = (\n    intercept\n    + beta_age * age\n    + beta_purchase * purchase\n    + np.random.normal(0, 0.5, n_samples)\n)\n\n# 使用分位数创建5个均衡的有序类别（1-5分满意度）\nthresholds = np.percentile(latent, [20, 40, 60, 80])\nsatisfaction = np.digitize(latent, thresholds, right=False) + 1  # 类别：1-5\n\n# 创建DataFrame\ndf = pd.DataFrame({\"age\": age, \"purchase\": purchase, \"satisfaction\": satisfaction})\n\n# 2. 拟合有序回归模型\nmodel = OrderedModel(\n    df[\"satisfaction\"], df[[\"age\", \"purchase\"]], distr=\"logit\"  # 逻辑斯蒂链接函数\n)\n\nresult = model.fit(method=\"bfgs\")  # 使用BFGS优化算法\n\n# 3. 生成预测\npred_probs = result.predict(df[[\"age\", \"purchase\"]])\npredicted = pred_probs.idxmax(axis=1).astype(int)  # 预测的类别（概率最高的）\n\n# 4. 可视化结果\n# ... 省略 ...\n\n# 5. 模型解释\nprint(\"\\n模型系数解释:\")\nprint(f\"年龄系数: {result.params['age']:.4f} - 年龄每增加1岁，满意度的潜在变量变化\")\nprint(\n    f\"购买金额系数: {result.params['purchase']:.4f} - 购买金额每增加1元，满意度的潜在变量变化\"\n)\nprint(\"\\n阈值估计:\")\nfor i, threshold in enumerate(result.params[2:]):  # 前两个是特征系数，后面是阈值\n    print(f\"满意度 {i+1}-{i+2} 阈值: {threshold:.4f}\")\n\n## 运行结果：\n'''\n模型系数解释:\n年龄系数: 0.0872 - 年龄每增加1岁，满意度的潜在变量变化\n购买金额系数: 0.2626 - 购买金额每增加1元，满意度的潜在变量变化\n\n阈值估计:\n满意度 1-2 阈值: 7.8416\n满意度 2-3 阈值: 1.6160\n满意度 3-4 阈值: 1.6758\n满意度 4-5 阈值: 1.6772\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144332135-99066096.png\" /></p>\n<p>从图中可以看出：</p>\n<ul>\n<li>特征系数表示对潜在变量的影响程度</li>\n<li>阈值参数表示类别之间的分界点</li>\n<li>购买金额的影响大于年龄，符合数据生成逻辑</li>\n</ul>\n<p>该代码完整展示了<strong>有序回归</strong>的理论基础、实现方法和结果分析，特别适合处理如满意度评分、等级评定等有序分类数据。</p>\n<h2 id=\"112-泊松回归-poisson-regression\">1.12. 泊松回归 (Poisson Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：专门用于预测“次数”或“计数”的回归，假设数据符合泊松分布。</li>\n<li><strong>使用场景</strong>：预测某个路口每小时经过的车辆数、客服中心每天接到的电话数。</li>\n</ul>\n<p><strong>泊松回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 泊松回归 (Poisson Regression)\nfrom scipy import stats\nfrom scipy.optimize import minimize\nfrom scipy.special import gammaln\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\n\n# 生成模拟数据：模拟客服中心每天接到的电话数\nnp.random.seed(42)  # 设置随机种子确保结果可复现\n\n# 自变量：广告投入（万元），工作日标识（1为工作日，0为非工作日）\nn_samples = 200\nadvertising_spend = np.random.uniform(0, 10, n_samples)  # 广告投入0-10万元\nis_weekday = np.random.binomial(1, 0.7, n_samples)       # 70%是工作日\n\n# 构造线性预测变量（使用对数链接函数）\nlinear_combination = 0.5 + 0.3 * advertising_spend + 0.4 * is_weekday\n# 泊松回归的期望值（均值）为 exp(线性组合)\nexpected_counts = np.exp(linear_combination)\n\n# 生成泊松分布的响应变量（电话数量）\ncalls_count = np.random.poisson(expected_counts)\n\n# 创建数据集\nX = np.column_stack([advertising_spend, is_weekday])\ny = calls_count\n\nprint(f\"生成了 {n_samples} 个样本\")\nprint(f\"平均电话数量: {np.mean(y):.2f}\")\nprint(f\"电话数量的标准差: {np.std(y):.2f}\")\n\n# 泊松回归模型实现\nclass PoissonRegression:\n    # ... 省略 ...\n\n# 拟合泊松回归模型\npoisson_reg = PoissonRegression()\npoisson_reg.fit(X, y)\n\n# 预测\ny_pred = poisson_reg.predict(X)\n\nprint(\"泊松回归系数:\")\nprint(f\"截距: {poisson_reg.coefficients[0]:.4f}\")\nprint(f\"广告投入系数: {poisson_reg.coefficients[1]:.4f}\")\nprint(f\"工作日系数: {poisson_reg.coefficients[2]:.4f}\")\nprint(f\"广告投入每增加1万元，电话数量变化倍数: {np.exp(poisson_reg.coefficients[1]):.4f}\")\nprint(f\"工作日相比非工作日电话数量变化倍数: {np.exp(poisson_reg.coefficients[2]):.4f}\")\n\n# 绘制结果图像\n# ... 省略 ...\n\n# 计算模型性能指标\nmse = mean_squared_error(y, y_pred)\nmae = mean_absolute_error(y, y_pred)\nrmse = np.sqrt(mse)\n\nprint(f\"\\n模型性能指标:\")\nprint(f\"均方误差 (MSE): {mse:.4f}\")\nprint(f\"平均绝对误差 (MAE): {mae:.4f}\")\nprint(f\"均方根误差 (RMSE): {rmse:.4f}\")\n\n## 运行结果：\n'''\n生成了 200 个样本\n平均电话数量: 13.93\n电话数量的标准差: 13.13\n泊松回归系数:\n截距: 0.4484\n广告投入系数: 0.3098\n工作日系数: 0.3904\n广告投入每增加1万元，电话数量变化倍数: 1.3632\n工作日相比非工作日电话数量变化倍数: 1.4775\n\n模型性能指标:\n均方误差 (MSE): 14.5815\n平均绝对误差 (MAE): 2.8126\n均方根误差 (RMSE): 3.8186\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331474-1225492130.png\" /></p>\n<p><strong>泊松回归模型</strong>的优势体现在以下几个方面：</p>\n<ol>\n<li><strong>适用于计数数据</strong>：泊松回归特别适合预测计数型变量（如电话数量），假设响应变量服从泊松分布，且其方差等于均值，能够很好地处理计数数据中常见的方差随均值变化的情况。</li>\n<li><strong>保证非负预测</strong>：通过使用对数链接函数，确保了预测值始终为正数，避免了可能出现的负数计数问题，符合计数数据的特性。</li>\n<li><strong>解释性强且适用稀有事件</strong>：回归系数易于解释为自变量变化对计数的乘性影响，并且在事件发生频率较低时表现良好，适合于客服电话、交通事故等低频事件的预测。</li>\n</ol>\n<p>这个示例模拟了客服中心电话数量预测的场景，其中广告投入和是否为工作日作为预测变量，完美展示了泊松回归如何处理计数型数据并提供可解释的结果。</p>\n<h2 id=\"113-负二项回归-negative-binomial-regression\">1.13. 负二项回归 (Negative Binomial Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：也是做计数预测的，但它解决了泊松回归中“方差必须等于均值”的苛刻假设。</li>\n<li><strong>使用场景</strong>：数据波动特别大（方差 &gt;&gt; 均值）的计数数据，比如某款冷门商品偶尔大卖的销量预测。</li>\n</ul>\n<p><strong>负二项回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 负二项回归 (Negative Binomial Regression)\nfrom scipy.optimize import minimize\nfrom scipy.special import gammaln\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\n\n# 生成模拟数据：模拟冷门商品销量预测（方差远大于均值的情况）\nnp.random.seed(42)  # 设置随机种子确保结果可复现\n\n# 自变量：促销活动（1为有促销，0为无促销），价格折扣率，商品类别（1为热门商品，0为冷门商品）\nn_samples = 300\npromotion = np.random.binomial(1, 0.3, n_samples)  # 30%有促销活动\ndiscount_rate = np.random.uniform(0, 0.3, n_samples)  # 0-30%的折扣\nis_popular = np.random.binomial(1, 0.2, n_samples)   # 20%是热门商品\n\n# 构造线性预测变量（使用对数链接函数）\nlinear_combination = -1.0 + 1.2 * promotion + 0.8 * discount_rate + 0.5 * is_popular\n# 负二项回归的均值为 exp(线性组合)\nmu = np.exp(linear_combination)\n\n# 负二项分布的参数设置（r为离散参数，控制方差）\n# 方差 = mu + mu^2/r，当r较小时，方差远大于均值\nr = 1.5  # 较小的r值，使得方差远大于均值\n\n# 生成负二项分布的响应变量（销量）\n# 使用负二项分布：var = mu + mu^2/r，当r小的时候方差很大\n# 负二项分布的参数转换：p = r/(r+mu)\np = r / (r + mu)\nsales_count = np.random.negative_binomial(r, p)\n\n# 创建数据集\nX = np.column_stack([promotion, discount_rate, is_popular])\ny = sales_count\n\n# 负二项回归模型实现\nclass NegativeBinomialRegression:\n    # ... 省略 ...\n\n# 拟合负二项回归模型\nneg_bin_reg = NegativeBinomialRegression()\nneg_bin_reg.fit(X, y)\n\n# 预测\ny_pred = neg_bin_reg.predict(X)\n\n# 绘制结果图像\n# ... 省略 ...\n\n# 计算模型性能指标\nmse = mean_squared_error(y, y_pred)\nmae = mean_absolute_error(y, y_pred)\nrmse = np.sqrt(mse)\n\nprint(f\"\\n模型性能指标:\")\nprint(f\"均方误差 (MSE): {mse:.4f}\")\nprint(f\"平均绝对误差 (MAE): {mae:.4f}\")\nprint(f\"均方根误差 (RMSE): {rmse:.4f}\")\n\n# 比较泊松回归和负二项回归的拟合效果\nfrom sklearn.linear_model import PoissonRegressor\n\n# 使用sklearn的泊松回归进行比较\npoisson_reg = PoissonRegressor()\npoisson_reg.fit(X, y)\ny_pred_poisson = poisson_reg.predict(X)\n\npoisson_mse = mean_squared_error(y, y_pred_poisson)\npoisson_mae = mean_absolute_error(y, y_pred_poisson)\npoisson_rmse = np.sqrt(poisson_mse)\n\nprint(f\"\\n与泊松回归的比较:\")\nprint(f\"负二项回归 MSE: {mse:.4f}\")\nprint(f\"泊松回归 MSE: {poisson_mse:.4f}\")\nprint(f\"负二项回归 MAE: {mae:.4f}\")\nprint(f\"泊松回归 MAE: {poisson_mae:.4f}\")\nprint(f\"负二项回归 RMSE: {rmse:.4f}\")\nprint(f\"泊松回归 RMSE: {poisson_rmse:.4f}\")\n\n## 运行结果：\n'''\n模型性能指标:\n均方误差 (MSE): 1.0138\n平均绝对误差 (MAE): 0.7567\n均方根误差 (RMSE): 1.0069\n\n与泊松回归的比较:\n负二项回归 MSE: 1.0138\n泊松回归 MSE: 1.1612\n负二项回归 MAE: 0.7567\n泊松回归 MAE: 0.8246\n负二项回归 RMSE: 1.0069\n泊松回归 RMSE: 1.0776\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331160-22547985.png\" /></p>\n<p><strong>负二项回归模型</strong>的优势体现在以下几个方面：</p>\n<ol>\n<li><strong>解决过度离势问题</strong>：负二项回归能够处理方差大于均值的计数数据，适用于方差/均值比远大于1的情况，如冷门商品偶尔大卖的数据。</li>\n<li><strong>更灵活的方差结构</strong>：通过引入离散参数r，负二项回归允许方差独立于均值变化（方差为 $ \\mu + \\mu^2/r $），从而更好地拟合实际数据中的变异性。</li>\n<li><strong>更好的拟合效果和更真实的假设</strong>：在高变异数据下，负二项回归通常比泊松回归提供更准确的预测，并且其假设更符合实际业务场景中计数数据的统计特性。</li>\n</ol>\n<p>这个示例模拟了冷门商品销量预测的场景，其中促销活动、折扣率和商品类型作为预测变量，完美展示了<strong>负二项回归</strong>如何处理方差远大于均值的计数型数据，并提供比泊松回归更准确的预测结果。</p>\n<h2 id=\"114-准泊松回归-quasi-poisson-regression\">1.14. 准泊松回归 (Quasi Poisson Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：泊松回归的另一种替代方案，用来处理由于数据波动过大（过度离散）导致的标准误估计不准的问题。</li>\n<li><strong>使用场景</strong>：和负二项回归类似，用于处理过度离散的计数数据。</li>\n</ul>\n<p><strong>准泊松回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># 准泊松回归 (Quasi Poisson Regression)\nfrom scipy.optimize import minimize\nfrom scipy.special import gammaln\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\n\n# 生成模拟数据：模拟过度离散的计数数据（如交通事故次数预测）\nnp.random.seed(42)  # 设置随机种子确保结果可复现\n\n# 自变量：道路长度（公里），交通流量（车辆/小时），天气状况（1为恶劣天气，0为正常天气）\nn_samples = 250\nroad_length = np.random.uniform(1, 20, n_samples)  # 道路长度1-20公里\ntraffic_flow = np.random.uniform(50, 500, n_samples)  # 交通流量50-500辆/小时\nbad_weather = np.random.binomial(1, 0.15, n_samples)  # 15%是恶劣天气\n\n# 构造线性预测变量（使用对数链接函数）\nlinear_combination = -2.0 + 0.05 * road_length + 0.002 * traffic_flow + 0.8 * bad_weather\n# 泊松回归的期望值（均值）为 exp(线性组合)\nexpected_counts = np.exp(linear_combination)\n\n# 为了模拟过度离散，我们引入额外的变异\n# 生成过度离散的计数数据：均值为expected_counts，但方差更大\n# 使用负二项分布生成数据，使其具有过度离散特征\ndispersion_param = 2.0  # 离散参数，控制过度离散程度\nr = expected_counts / (dispersion_param - 1)  # 负二项分布的参数转换\np = r / (r + expected_counts)\naccident_count = np.random.negative_binomial(r, p)\n\n# 创建数据集\nX = np.column_stack([road_length, traffic_flow, bad_weather])\ny = accident_count\n\nprint(f\"生成了 {n_samples} 个样本\")\nprint(f\"平均事故数: {np.mean(y):.2f}\")\nprint(f\"事故数的标准差: {np.std(y):.2f}\")\nprint(f\"方差/均值比: {np.var(y)/np.mean(y):.2f} (泊松分布该比值应为1，大于1表示过度离散)\")\n\n# 准泊松回归模型实现\nclass QuasiPoissonRegression:\n    # ... 省略 ...\n\n# 拟合准泊松回归模型\nquasi_poisson_reg = QuasiPoissonRegression()\nquasi_poisson_reg.fit(X, y)\n\n# 预测\ny_pred = quasi_poisson_reg.predict(X)\ny_var = quasi_poisson_reg.predict_variance(X)\n\n# 绘制结果图像\n# ... 省略 ...\n\n# 计算模型性能指标\nmse = mean_squared_error(y, y_pred)\nmae = mean_absolute_error(y, y_pred)\nrmse = np.sqrt(mse)\n\nprint(f\"\\n模型性能指标:\")\nprint(f\"均方误差 (MSE): {mse:.4f}\")\nprint(f\"平均绝对误差 (MAE): {mae:.4f}\")\nprint(f\"均方根误差 (RMSE): {rmse:.4f}\")\n\n# 与标准泊松回归的比较\nfrom sklearn.linear_model import PoissonRegressor\n\n# 使用sklearn的泊松回归进行比较\npoisson_reg = PoissonRegressor()\npoisson_reg.fit(X, y)\ny_pred_poisson = poisson_reg.predict(X)\n\npoisson_mse = mean_squared_error(y, y_pred_poisson)\npoisson_mae = mean_absolute_error(y, y_pred_poisson)\npoisson_rmse = np.sqrt(poisson_mse)\n\nprint(f\"\\n与泊松回归的比较:\")\nprint(f\"准泊松回归 MSE: {mse:.4f}\")\nprint(f\"泊松回归 MSE: {poisson_mse:.4f}\")\nprint(f\"准泊松回归 MAE: {mae:.4f}\")\nprint(f\"泊松回归 MAE: {poisson_mae:.4f}\")\nprint(f\"准泊松回归 RMSE: {rmse:.4f}\")\nprint(f\"泊松回归 RMSE: {poisson_rmse:.4f}\")\n\n# 检查过度离散\nprint(f\"\\n过度离散检查:\")\nprint(f\"数据方差/均值比: {np.var(y)/np.mean(y):.4f}\")\nprint(f\"准泊松估计的离散参数: {quasi_poisson_reg.dispersion:.4f}\")\nprint(f\"离散参数 &gt; 1 表示存在过度离散: {quasi_poisson_reg.dispersion &gt; 1}\")\n\n## 运行结果：\n'''\n模型性能指标:\n均方误差 (MSE): 0.8350\n平均绝对误差 (MAE): 0.6398\n均方根误差 (RMSE): 0.9138\n\n与泊松回归的比较:\n准泊松回归 MSE: 0.8350\n泊松回归 MSE: 0.8415\n准泊松回归 MAE: 0.6398\n泊松回归 MAE: 0.6515\n准泊松回归 RMSE: 0.9138\n泊松回归 RMSE: 0.9174\n\n过度离散检查:\n数据方差/均值比: 1.6993\n准泊松估计的离散参数: 1.6699\n离散参数 &gt; 1 表示存在过度离散: True\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331559-285192201.png\" /></p>\n<p><strong>准泊松回归模型</strong>的优势体现在以下几个方面：</p>\n<ol>\n<li><strong>解决过度离散问题</strong>：准泊松回归通过引入离散参数φ来处理方差大于均值的过度离散数据。在示例中，方差/均值比远大于1（约为2.35），表明存在明显的过度离散现象。</li>\n<li><strong>标准误校正</strong>：修正了泊松回归中由于过度离散导致的标准误估计过小的问题，从而提高了统计推断（如置信区间和假设检验）的可靠性。</li>\n<li><strong>保持泊松回归的系数</strong>：与泊松回归使用相同的系数估计，但调整了方差估计。这意味着回归系数的解释与泊松回归相同，保持了模型的可解释性。</li>\n<li><strong>简单易用</strong>：相比负二项回归，准泊松回归参数更少，计算更简单。准泊松回归只需要估计一个额外的离散参数，而负二项回归需要估计离散参数r。</li>\n<li><strong>灵活性强</strong>：可以处理任意程度的过度离散，而不限于特定的分布假设。准泊松回归不假设特定的分布族，只是调整方差结构。</li>\n<li><strong>实用性强</strong>：在实际应用中，当数据存在过度离散但又不想使用更复杂的负二项回归时，准泊松是很好的选择。它提供了一个平衡点，既解决了过度离散问题，又保持了模型的简洁性。</li>\n<li><strong>计算效率高</strong>：由于使用与泊松回归相同的系数估计方法，计算复杂度较低，适合处理大规模数据。</li>\n</ol>\n<p>这个示例模拟了交通事故预测的场景，其中道路长度、交通流量和天气状况作为预测变量，完美展示了<strong>准泊松回归</strong>如何处理过度离散的计数型数据，并提供比标准泊松回归更可靠的统计推断。</p>\n<h2 id=\"115-cox-回归-cox-regression\">1.15. Cox 回归 (Cox Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：用于“生存分析”，研究的是“事件发生需要多长时间”，以及哪些因素影响这个时间。</li>\n<li><strong>使用场景</strong>：预测病人确诊后的生存时间、客户流失所需的时间（也就是客户还能留存多久）。</li>\n</ul>\n<p><strong>COX回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># Cox 回归 (Cox Regression)\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\n\n# 导入sksurv库\nfrom sksurv.linear_model import CoxPHSurvivalAnalysis\nfrom sksurv.preprocessing import OneHotEncoder\n\n# 第一步：创建Cox回归的测试数据\n# 模拟医疗数据：患者生存分析\nnp.random.seed(42)\nn_samples = 300\n\n# 生成特征\nage = np.random.normal(60, 15, n_samples)  # 患者年龄\ntreatment = np.random.binomial(1, 0.5, n_samples)  # 是否接受治疗 (0/1)\ngender = np.random.binomial(1, 0.5, n_samples)  # 性别 (0/1)\ncomorbidity = np.random.poisson(1.5, n_samples)  # 并发症数量\n\n# 生成生存时间和事件状态\n# 年龄越大、并发症越多 -&gt; 生存时间越短\n# 接受治疗 -&gt; 生存时间更长\nlinear_combination = (\n    0.05 * age +\n    -0.8 * treatment +\n    0.1 * gender +\n    0.3 * comorbidity\n)\n\n# 基线风险函数效应\nbase_time = np.random.exponential(2, n_samples)\ntime_to_event = base_time * np.exp(-linear_combination)\n\n# 添加一些删失（并非所有患者都会在研究期间发生事件）\ncensoring_time = np.random.uniform(0, np.percentile(time_to_event, 80), n_samples)\nobserved_time = np.minimum(time_to_event, censoring_time)\nevent_occurred = time_to_event &lt;= censoring_time\n\n# 创建DataFrame\ndata = pd.DataFrame({\n    'age': age,\n    'treatment': treatment,\n    'gender': gender,\n    'comorbidity': comorbidity,\n    'time': observed_time,\n    'event': event_occurred\n})\n\n# 第二步：实现Cox回归模型\n# 为sksurv准备数据\nX = data[['age', 'treatment', 'gender', 'comorbidity']].values\ny = np.array(list(zip(data['event'], data['time'])), dtype=[('event', '?'), ('time', '&lt;f8')])\n\n# 分割数据\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# 拟合Cox模型\ncox_model = CoxPHSurvivalAnalysis()\ncox_model.fit(X_train, y_train)\n\n# 获取模型系数\ncox_coef = cox_model.coef_\n\nprint(\"Cox回归模型 (sksurv) - 系数：\")\nfeature_names = ['年龄', '治疗', '性别', '并发症']\nfor i, (name, coef) in enumerate(zip(feature_names, cox_coef)):\n    print(f\"{name}: {coef:.4f}\")\n\n# 在sksurv中，我们可以手动计算风险评分\n# 风险评分是线性预测器的指数，即 exp(X * coef)\nlinear_predictor = X_test @ cox_coef\nrisk_scores = np.exp(linear_predictor)\n\n# 第三步：创建可视化\n# ... 省略 ...\n\n## 运行结果：\n'''\nCox回归模型 (sksurv) - 系数：\n年龄: 0.0585\n治疗: -0.7703\n性别: -0.1919\n并发症: 0.1779\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144332031-1348386260.png\" /></p>\n<p><strong>COX回归模型</strong>的优势</p>\n<ol>\n<li><strong>处理删失数据</strong>：Cox回归适用于右删失数据，适合生存分析。</li>\n<li><strong>无需分布假设</strong>：Cox回归不假设生存时间的具体分布，更灵活。</li>\n<li><strong>比例风险</strong>：假设个体间的风险比恒定，符合许多实际应用。</li>\n<li><strong>系数可解释</strong>：系数直接转换为风险比，易于理解（正系数增加风险，负系数降低风险）。</li>\n<li><strong>多个协变量</strong>：能同时分析多个因素对生存时间的影响。</li>\n<li><strong>广泛应用于医学</strong>：是临床和流行病学研究中的标准方法。</li>\n<li><strong>灵活性</strong>：支持时变协变量及连续和分类预测变量。</li>\n<li><strong>风险评分</strong>：可计算个体风险评分，预测相对风险。</li>\n</ol>\n<h2 id=\"116-tobit-回归-tobit-regression\">1.16. Tobit 回归 (Tobit Regression)</h2>\n<ul>\n<li><strong>一句话概念</strong>：用于处理“截断”或“审查”数据。比如数据在某个点被切断了（比如收入调查中，高于100万的都记作100万）。</li>\n<li><strong>使用场景</strong>：预测家庭在奢侈品上的支出（很多人是0，数据在0处堆积）、传感器量程限制导致的数据截断。</li>\n</ul>\n<p><strong>Tobit回归</strong>模型使用示例：</p>\n<pre><code class=\"language-python\"># Tobit 回归 (Tobit Regression)\nfrom scipy import stats\nfrom scipy.optimize import minimize\n\n# 生成模拟的截断数据集\nnp.random.seed(42)\n\n# 创建自变量\nn_samples = 500\nX = np.random.normal(0, 1, n_samples)\n# 假设真实关系是 y = 2*X + error，但y被截断在0以下\ntrue_beta = 2.0\ntrue_intercept = 0.5\ntrue_sigma = 1.0\n\n# 生成未截断的真实值\ny_true = true_intercept + true_beta * X + np.random.normal(0, true_sigma, n_samples)\n\n# 设置截断点（例如：低于0的值都记录为0）\nlower_limit = 0\ny_observed = np.where(y_true &lt; lower_limit, lower_limit, y_true)\n\n# 标记被截断的观测值\ncensored_mask = y_observed == lower_limit\n\nprint(f\"生成了{n_samples}个样本\")\nprint(f\"其中{np.sum(censored_mask)}个样本被截断（小于等于{lower_limit}）\")\n\n# 实现Tobit回归模型\nclass TobitRegression:\n    # ... 省略 ...\n\n# 拟合Tobit回归模型\ntobit_model = TobitRegression(lower_limit=lower_limit)\ntobit_model.fit(X, y_observed)\n\nprint(f\"Tobit回归结果:\")\nprint(f\"截距: {tobit_model.intercept:.3f}\")\nprint(f\"系数: {tobit_model.beta:.3f}\")\nprint(f\"标准差: {tobit_model.sigma:.3f}\")\nprint(f\"真实截距: {true_intercept}, 真实系数: {true_beta}, 真实标准差: {true_sigma}\")\n\n# 绘制结果图像\n# ... 省略 ...\n\n# 输出一些统计信息\nprint(\"\\n模型比较:\")\nprint(f\"真实系数: {true_beta:.3f}\")\nprint(f\"Tobit回归系数: {tobit_model.beta:.3f}\")\nprint(f\"OLS回归系数: {ols_coef[1]:.3f}\")\nprint(f\"系数估计偏差 (Tobit): {abs(tobit_model.beta - true_beta):.3f}\")\nprint(f\"系数估计偏差 (OLS): {abs(ols_coef[1] - true_beta):.3f}\")\n\n# 计算均方误差\nmse_tobit = np.mean((y_observed - tobit_model.predict(X)) ** 2)\nmse_ols = np.mean((y_observed - y_ols_pred) ** 2)\nprint(f\"Tobit MSE: {mse_tobit:.3f}\")\nprint(f\"OLS MSE: {mse_ols:.3f}\")\n\n## 运行结果：\n'''\nTobit回归结果:\n截距: 0.518\n系数: 1.932\n标准差: 0.990\n真实截距: 0.5, 真实系数: 2.0, 真实标准差: 1.0\n\n模型比较:\n真实系数: 2.000\nTobit回归系数: 1.932\nOLS回归系数: 1.203\n系数估计偏差 (Tobit): 0.068\n系数估计偏差 (OLS): 0.797\nTobit MSE: 1.623\nOLS MSE: 0.755\n'''\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202512/83005-20251230144331140-1830279319.png\" /></p>\n<p><strong>Tobit回归模型</strong>的优势主要有：</p>\n<ol>\n<li><strong>处理截断数据</strong>：Tobit回归适用于处理在特定阈值处被截断的数据（如所有小于0的值记录为0）。</li>\n<li><strong>无偏估计</strong>：与普通OLS相比，Tobit回归提供更准确的参数估计，避免了因数据截断导致的偏差。</li>\n<li><strong>统计推断</strong>：基于最大似然估计，Tobit回归支持合理的统计推断，包括标准误和置信区间的计算。</li>\n<li><strong>适用领域</strong>：广泛应用于经济和社会科学中涉及收入、消费支出及生存分析等存在截断或审查情况的研究。</li>\n<li><strong>模型拟合度</strong>：Tobit回归系数更接近真实值，并且通常具有较小的均方误差，表明其对截断数据有更好的适应性。</li>\n</ol>\n<h1 id=\"2-如何选择合适的回归模型\">2. 如何选择合适的回归模型？</h1>\n<p>面对这么多模型，到底该选哪一个？我们可以通过以下几个维度来判断：</p>\n<ol>\n<li><strong>看因变量（Y）长什么样</strong>：\n<ul>\n<li>是<strong>连续数值</strong>（如房价）： 首选 线性回归。</li>\n<li>是<strong>二分类</strong>（如买/不买）： 用 逻辑回归。</li>\n<li>是<strong>计数</strong>（如点击次数）： 用 泊松回归 或 负二项回归。</li>\n<li>是<strong>生存时间</strong>（如存活天数）： 用 Cox回归。</li>\n<li>有<strong>截断</strong>（如上限封顶）： 用 Tobit回归。</li>\n</ul>\n</li>\n<li><strong>看数据是否有问题</strong>：\n<ul>\n<li><strong>异常值很多</strong>： 考虑 分位数回归 或 Huber回归（鲁棒回归）。</li>\n<li><strong>特征非线性</strong>： 尝试 多项式回归 或 SVR。</li>\n<li><strong>特征数 &gt; 样本数</strong>，或特征<strong>严重共线性</strong>： 必须上正则化手段，用 岭回归、Lasso、ElasticNet，或者降维类的 PCR/PLS。</li>\n</ul>\n</li>\n<li><strong>看模型目的</strong>：\n<ul>\n<li>为了<strong>解释现象</strong>： 简单的线性/逻辑回归最好解释。</li>\n<li>为了<strong>精准预测</strong>： SVR、甚至更复杂的机器学习模型（如XGBoost等，虽不在此列但常被比较）可能更好。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"3-总结\">3. 总结</h1>\n<p>没有最好的模型，只有最适合数据的模型。</p>\n<p>对于初学者，先画图看数据分布，然后从最简单的线性回归开始尝试，发现问题（如拟合不好、过拟合）后再逐步尝试更复杂的变体，是最好的学习路径。</p>\n<p>为了方便大家尝试各种回归模型，文中各个示例中的数据都是模拟的，不需要另外下载和爬取。</p>\n<p>了解和掌握各种回归模型没有捷径，最好的方式就是把文中代码都实际运行一次，改改数据和训练参数，再反复运行体会下效果。</p>\n<p>完整的代码：<a href=\"https://url11.ctfile.com/f/45455611-8586706866-edb36d?p=6872\" rel=\"noopener nofollow\" target=\"_blank\">16种回归分析总结.ipynb</a> (访问密码: 6872)</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 14:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">16</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "掌握Fetch与Flask交互：让前端表单提交更优雅的动态之道",
      "link": "https://www.cnblogs.com/ymtianyu/p/19418995",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19418995\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 08:18\">\n    <span>掌握Fetch与Flask交互：让前端表单提交更优雅的动态之道</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文详细解析了前端Fetch API的工作原理与常见用法，并重点阐述了其如何与Python Flask后端框架协同工作。通过登录重定向、数据动态增删改查等具体场景，演示了如何实现无刷新交互体验。文章提供了前后端配套的代码示例，讲解了如何处理JSON、文本等不同格式的响应，以及如何根据响应状态更新用户界面，为构建现代Web应用提供了实用指南。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<h1 style=\"font-size: 22px; line-height: 1.4; margin-top: 0; margin-bottom: 15px; font-weight: bold; color: rgba(26, 26, 26, 1);\">还在为表单提交后页面刷新烦恼？一文搞定Fetch与Flask的无缝交互</h1>\n<p style=\"font-size: 15px; color: rgba(127, 140, 141, 1); margin-bottom: 20px; padding-left: 12px; font-style: italic;\">本文带你深入理解现代前端 Fetch API 的工作原理，并手把手教你如何与 Flask 后端优雅结合，实现无刷新登录、数据动态增删改查等交互。<br />亮点包括：Fetch 核心原理剖析、登录重定向的异步处理、利用响应状态码动态更新UI、以及如何处理JSON/文本等不同格式的返回数据。<br /><br /><span style=\"font-weight: bold;\">你将学到：</span><br />- Fetch API 的“承诺”机制与基础用法<br />- 如何用 Flask 构建 RESTful 风格的 API 端点<br />- 登录表单提交：告别传统表单刷新，实现平滑跳转<br />- 数据操作：前端一个请求，后端处理，前端UI即时响应<br />- 根据后端返回的不同数据类型（JSON/Text）进行精准处理</p>\n<h2 style=\"font-size: 18px; font-weight: bold; color: rgba(44, 62, 80, 1); padding-bottom: 8px; margin-top: 30px; margin-bottom: 15px;\">✨ 目录</h2>\n<p>1. 初识Fetch：现代Web的通信信使<br />2. 🛠️ 实战准备：Flask后端的简单配置<br />3. 🔐 场景一：登录表单提交与页面重定向<br />4. ✨ 场景二：动态新增与修改数据<br />5. 📦 场景三：处理不同类型的响应数据<br />6. 💻 完整代码参考与总结</p>\n<h2 style=\"font-size: 20px; font-weight: bold; color: rgba(44, 62, 80, 1); margin-top: 35px; margin-bottom: 15px;\">1. 初识Fetch：现代Web的通信信使</h2>\n<p><code>fetch()</code> 是浏览器提供的、基于 <strong style=\"color: rgba(186, 55, 42, 1);\">Promise</strong> 的现代网络请求API。它取代了古老的 XMLHttpRequest，让异步数据请求变得清晰、简洁。你可以把它想象成一个专业的“信使”。</p>\n<p>它的基本工作流程是：你给信使（fetch）一个地址（URL）和指示（配置对象），它立刻返回一个“承诺收据”（Promise）。这个承诺最终会兑现为“响应包裹”（Response对象），你需要打开这个包裹（调用如.json(), .text()等方法）才能拿到里面的真实数据。</p>\n<pre class=\"language-javascript highlighter-hljs\"><code>// 一个最简单的GET请求示例\nfetch('/api/data')\n  .then(response =&gt; response.json()) // 打开包裹，解析JSON数据\n  .then(data =&gt; console.log(data))   // 处理真实数据\n  .catch(error =&gt; console.error('出错啦：', error)); // 处理错误</code></pre>\n<h2 style=\"font-size: 20px; font-weight: bold; color: rgba(44, 62, 80, 1); margin-top: 35px; margin-bottom: 15px;\">2. 🛠️ 实战准备：Flask后端的简单配置</h2>\n<p>为了让前端Fetch能顺利与后端“对话”，我们需要一个能处理JSON、并能进行跨域资源共享（CORS）的Flask应用。首先，安装必要库：</p>\n<pre class=\"language-python highlighter-hljs\"><code>pip install flask flask-cors</code></pre>\n<p>接着，搭建一个基础的后端服务：</p>\n<pre class=\"language-python highlighter-hljs\"><code>from flask import Flask, request, jsonify\nfrom flask_cors import CORS\n\napp = Flask(__name__)\nCORS(app)  # 允许前端跨域请求，开发时非常方便\n\n# 我们将在后续场景中逐步填充这个app的路由\nif __name__ == '__main__':\n    app.run(debug=True)</code></pre>\n<h2 style=\"font-size: 20px; font-weight: bold; color: rgba(44, 62, 80, 1); margin-top: 35px; margin-bottom: 15px;\">3. 🔐 场景一：登录表单提交与页面重定向</h2>\n<p>传统表单提交会刷新页面，体验割裂。使用Fetch，我们可以实现无刷新登录，并根据后端指令进行前端路由跳转。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">前端 (JavaScript)</strong>：拦截表单提交事件，使用Fetch发送数据。</p>\n<pre class=\"language-javascript highlighter-hljs\"><code>document.getElementById('loginForm').addEventListener('submit', function(event) {\n    event.preventDefault(); // 阻止表单默认提交行为\n\n    const formData = new FormData(this);\n    // 或者将数据转换为JSON: JSON.stringify(Object.fromEntries(formData))\n\n    fetch('/api/login', {\n        method: 'POST',\n        body: formData, // 发送FormData对象\n        // headers: { 'Content-Type': 'application/json' }, // 如果发送JSON需设置此header\n    })\n    .then(response =&gt; response.json()) // 解析后端返回的JSON\n    .then(result =&gt; {\n        if (result.success) {\n            // 登录成功，使用前端路由跳转，而非后端重定向\n            window.location.href = result.redirect_url || '/dashboard';\n        } else {\n            // 登录失败，动态更新页面上的错误提示元素\n            document.getElementById('error-msg').textContent = result.message;\n        }\n    })\n    .catch(error =&gt; console.error('Error:', error));\n});</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">后端 (Flask)</strong>：验证数据，返回包含状态和指令的JSON，而不是直接返回重定向的HTML。</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.route('/api/login', methods=['POST'])\ndef login():\n    username = request.form.get('username')\n    password = request.form.get('password')\n\n    # 这里应是你的验证逻辑，例如查询数据库\n    if username == 'admin' and password == 'secret':\n        # 返回成功状态和前端跳转地址\n        return jsonify({'success': True, 'redirect_url': '/dashboard'})\n    else:\n        # 返回失败状态和错误信息\n        return jsonify({'success': False, 'message': '用户名或密码错误'}), 401</code></pre>\n<h2 style=\"font-size: 20px; font-weight: bold; color: rgba(44, 62, 80, 1); margin-top: 35px; margin-bottom: 15px;\">4. ✨ 场景二：动态新增与修改数据</h2>\n<p>在管理系统中，新增或修改一条数据后，我们希望列表能立即更新，而无需刷新整个页面。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">核心思路</strong>：Fetch请求成功后，在<code>.then()</code>中根据后端返回的最新数据，直接操作DOM更新UI。</p>\n<pre class=\"language-javascript highlighter-hljs\"><code>// 假设有一个保存按钮，用于提交新增或修改的数据\nsaveButton.addEventListener('click', () =&gt; {\n    const itemData = { title: '新项目', status: 'active' };\n\n    fetch('/api/items', {\n        method: 'POST', // 新增用POST，修改可能是PUT或PATCH\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(itemData)\n    })\n    .then(response =&gt; response.json())\n    .then(newItem =&gt; {\n        // 关键步骤：请求成功后，动态更新前端列表\n        const itemList = document.getElementById('itemList');\n        const newItemElement = document.createElement('li');\n        newItemElement.id = `item-${newItem.id}`;\n        newItemElement.innerHTML = `${newItem.title} ${newItem.status}`;\n        itemList.appendChild(newItemElement);\n\n        // 或者，如果是修改操作，可以找到对应的DOM元素更新其内容\n        // const oldItemElement = document.getElementById(`item-${newItem.id}`);\n        // oldItemElement.innerHTML = ...;\n\n        alert('操作成功！'); // 或更优雅的提示\n    });\n});</code></pre>\n<p>对应的Flask后端需要返回创建或更新后的完整数据对象，以便前端使用。</p>\n<h2 style=\"font-size: 20px; font-weight: bold; color: rgba(44, 62, 80, 1); margin-top: 35px; margin-bottom: 15px;\">5. 📦 场景三：处理不同类型的响应数据</h2>\n<p>后端可能返回JSON，也可能返回纯文本或HTML片段。Fetch的Response对象提供了不同的方法来处理。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">处理JSON (最常用)</strong>：如上文所示，使用<code>response.json()</code>。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">处理文本</strong>：例如后端返回一个简单的成功消息或CSV数据。</p>\n<pre class=\"language-javascript highlighter-hljs\"><code>fetch('/api/export')\n  .then(response =&gt; response.text())\n  .then(textData =&gt; {\n    console.log(textData);\n    // 处理文本数据...\n  });</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">检查响应状态</strong>：在解析数据前，先检查请求是否真正成功是个好习惯。</p>\n<pre class=\"language-javascript highlighter-hljs\"><code>fetch('/api/some-data')\n  .then(response =&gt; {\n    if (!response.ok) { // 检查HTTP状态码是否在200-299之间\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json(); // 状态正常才解析JSON\n  })\n  .then(data =&gt; /* 处理数据 */)\n  .catch(error =&gt; /* 处理网络错误或状态码错误 */);</code></pre>\n<h2 style=\"font-size: 20px; font-weight: bold; color: rgba(44, 62, 80, 1); margin-top: 35px; margin-bottom: 15px;\">6. 💻 完整代码参考与总结</h2>\n<p>下面是一个整合了登录和新增项目的超简易完整示例：</p>\n<pre class=\"language-python highlighter-hljs\"><code># app.py (Flask后端)\nfrom flask import Flask, request, jsonify\nfrom flask_cors import CORS\n\napp = Flask(__name__)\nCORS(app)\nitems = [] # 用一个简易列表模拟数据库\n\n@app.route('/api/login', methods=['POST'])\ndef login():\n    data = request.get_json()\n    if data.get('user') == 'demo':\n        return jsonify({'success': True, 'token': 'fake-jwt-token'})\n    return jsonify({'success': False}), 401\n\n@app.route('/api/items', methods=['GET', 'POST'])\ndef handle_items():\n    if request.method == 'GET':\n        return jsonify(items)\n    else: # POST\n        new_item = request.get_json()\n        new_item['id'] = len(items) + 1\n        items.append(new_item)\n        return jsonify(new_item), 201\n\nif __name__ == '__main__':\n    app.run(debug=True)</code></pre>\n<pre class=\"language-html highlighter-hljs\"><code>&lt;!-- index.html (部分前端) --&gt;\n&lt;script&gt;\n// 登录\nfetch('/api/login', {\n    method: 'POST',\n    headers: {'Content-Type': 'application/json'},\n    body: JSON.stringify({user: 'demo', pass: 'demo'})\n}).then(r =&gt; r.json()).then(console.log);\n\n// 新增项目并更新列表\nfetch('/api/items', {\n    method: 'POST',\n    headers: {'Content-Type': 'application/json'},\n    body: JSON.stringify({name: 'New Task'})\n})\n.then(r =&gt; r.json())\n.then(newItem =&gt; {\n    const list = document.getElementById('list');\n    list.innerHTML += `&lt;li&gt;${newItem.id}: ${newItem.name}&lt;/li&gt;`;\n});\n&lt;/script&gt;</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">总结一下</strong>：Fetch + Flask 的组合，通过“请求-响应-JSON”的模式，将前后端解耦，让Web交互变得<strong style=\"color: rgba(186, 55, 42, 1);\">更加动态和高效</strong>。<br />关键在于：前端负责交互和UI更新，后端负责数据和逻辑，两者通过清晰的API契约进行通信。</p>\n<div style=\"text-align: center; margin: 40px 0;\"><hr style=\"border-right: none; border-bottom: none; border-left: none;\" /></div>\n<p style=\"font-size: 15px; color: rgba(85, 85, 85, 1); text-align: center;\">喜欢本文？不要错过✨，点赞👍收藏⭐关注我👆，一起学习更多有用的知识，完善你我的技能树！也请路过的大佬给些建议和指教🙏🐶！</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 08:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">曲幽</a>&nbsp;\n阅读(<span id=\"post_view_count\">24</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程四：计算机视觉 第四周：卷积网络应用 (一) 人脸识别",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19418306",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19418306\" id=\"cb_post_title_url\" title=\"发布于 2025-12-29 23:52\">\n    <span>吴恩达深度学习课程四：计算机视觉 第四周：卷积网络应用 (一) 人脸识别</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第四课的第四周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=140\" rel=\"noopener nofollow\" target=\"_blank\">4.1</a>到<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=144\" rel=\"noopener nofollow\" target=\"_blank\">4.5</a>的内容。</p>\n<hr />\n<p>本周为第四课的第四周内容，这一课所有内容的中心只有一个：<strong>计算机视觉</strong>。应用在深度学习里，就是专门用来进行图学习的模型和技术，是在之前全连接基础上的“特化”，也是相关专业里的一个重要研究大类。<br />\n<strong>这一整节课都存在大量需要反复理解的内容和机器学习、数学基础。</strong> 因此我会尽可能的补足基础，用比喻和实例来演示每个部分，从而帮助理解。<br />\n第四周的内容是对前三周内容的综合应用，介绍了一些通过卷积网络实现的实际应用，它们在使用卷积网络的基础上又各有自己的特点来匹配不同的任务要求，是对<strong>如何真实应用卷积网络</strong>的良好演示。<br />\n本篇的内容关于<strong>人脸识别</strong>。</p>\n<h1 id=\"1-人脸验证与人脸识别\">1. 人脸验证与人脸识别</h1>\n<p>人脸验证和人脸识别是两个相似的概念。<br />\n而在人脸识别系统中，我们说<strong>人脸验证是人脸识别的一个基本模块</strong>。<br />\n现在就来展开一下二者的关系：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234636631-73929260.png\" /><br />\n我们在图里提到<strong>人脸验证是一个1对1问题</strong>，这是因为在假定验证器完全准确的情况下，它只会对一个人说 “Yes” 而拒绝其他所有人。<br />\n很显然，这种逻辑在我们实际生活中的大多场景都不适用，公司、宿舍的门禁等都支持通过一个模型识别多个人。而不是为每个人单独设置一个闸机。<br />\n因此，我们便称这种<strong>实现“1对多”逻辑的相应任务为人脸识别</strong>。<br />\n按照刚才的逻辑推下去，一个很自然、也很“机器学习直觉”的想法是：<strong>那人脸识别不就是一个多分类问题吗？</strong> 像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234219889-112044451.png\" /><br />\n但如果在实际部署中这样实现人脸识别，你会发现这样一些问题：</p>\n<ol>\n<li>如果单位有新员工加入或老员工离职，就要<strong>重新调整数据和网络输出层，重新训练</strong>。</li>\n<li>当单位规模较大时，数据可能包含<strong>成千上万个类别</strong>。更重要的是，每个类别数据量很少，而深度学习往往又依赖于<strong>数据量</strong>，难道办理入职要先拍几百几千张照片吗？</li>\n</ol>\n<p>因此，我们得出结论：因为人脸识别任务在实际部署中的特殊性，让我们之前了解的常规<strong>分类算法并不适用</strong>作为一个可持续部署方案对其应用。</p>\n<p>而在现实生活中，你会发现，我们在相关系统录入人脸时，<strong>往往只需要一张证件照即可</strong>，这是怎么做到的呢？我们继续。</p>\n<h1 id=\"2-一次学习one-shot-learning\">2. 一次学习（one-shot learning）</h1>\n<p>继续刚刚的内容，我们会发现一个看似矛盾的现象：<br />\n在实际的人脸系统中，录入一个新用户时，<strong>往往只需要一张证件照</strong>。但在深度学习的经验认知里，模型性能又高度依赖数据量。  <strong>这两点，不冲突吗？</strong></p>\n<p>要理解这一点，我们需要先回到刚才“把人脸识别当作多分类问题”的思路。<br />\n在标准的多分类任务中，<strong>分类标签本身就为数据划分了明确的边界</strong>：模型只能通过<strong>同一标签下的样本</strong>来学习该类别的特征，而不同类别之间的数据是被严格隔离使用的。<br />\n正因为如此，如果将人脸识别直接建模为“每个人一个类别”，那么模型要学好某一个人的特征，就必然需要<strong>大量属于这个人的样本</strong>——也就出现了“要给每个人拍写真集”的不现实要求。</p>\n<p>但是，你会发现：在人脸识别任务中，<strong>总的数据量其实并不少</strong>，真正稀缺的只是“每个身份对应的样本数量”。这意味着，并不是“数据不够”，而是<strong>数据被标签强行分割后，无法被充分利用</strong>。</p>\n<p>正是由于这种设置与实际部署场景不匹配，我们自然会产生一个新的疑问：<strong>能不能让所有人的样本都参与学习，而不是被身份标签各自隔离开来？</strong></p>\n<p>在机器学习中，这类“<strong>每个类别只有极少样本</strong>”的问题被称为<strong>一次学习（one-shot learning）问题</strong>。<br />\n而在具体的人脸识别场景下，<strong>one-shot 人脸识别</strong>指的是：每个身份在训练或建库阶段，仅提供一张（或极少几张）已知人脸样本。</p>\n<p>为了解决这种“<strong>总体样本量很大，但单个身份样本极少</strong>”的矛盾，人们提出了一种不同于传统分类的思路：  <strong>不再让模型回答“这张脸属于所有人中的哪一个？”，而是让它判断“这张脸是否和某一个已知的某张脸足够相似？”</strong></p>\n<p>现在，网络目标就从一开始的“学习分类”变成了“<strong>学相似度</strong>”，就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234253679-642676291.png\" /><br />\n如果如图中这样，网络实现了“<strong>学习两张人脸的相似度</strong>“，我们就解决了刚刚的问题：</p>\n<ol>\n<li>如果单位有新员工加入或老员工离职，就要不再需要调整网络和重新训练，<strong>只需要把相应数据加入数据库或从数据库中删除</strong>。</li>\n<li>所有的数据都被充分利用，同时每人只需要一张证件照，在门禁时人脸和数据库中的人脸对比，<strong>找到满足相似度阈值的样本即通过，不存在即拒绝。</strong></li>\n</ol>\n<h1 id=\"3-siamese-网络\">3. Siamese 网络</h1>\n<p>现在，我们明确了针对面部识别任务的目标：<strong>训练一个可以学习两张人脸相似度的网络</strong>。<br />\n现在，要怎么实现这一点呢？<br />\n答案就是这部分的标题：Siamese 网络。<br />\n要说明的是，吴恩达老师在课程里提到了一篇 2014 年的论文 <a href=\"https://www.cv-foundation.org/openaccess/content_cvpr_2014/papers/Taigman_DeepFace_Closing_the_2014_CVPR_paper.pdf?utm_source=chatgpt.com\" rel=\"noopener nofollow\" target=\"_blank\">DeepFace: Closing the Gap to Human-Level Performance in Face Verification</a>。<strong>但 Siamese 网络并不是从这篇论文才提出的</strong>——早在 1993 年，它就被发明出来，用于判断两幅手写签名是否同一人。后来也被应用到人脸识别任务中。<br />\nSiamese 网络的核心思路是<strong>通过共享权重的双分支（或多分支）神经网络，将输入的两张图像映射到同一特征空间，然后通过度量函数（如欧氏距离或余弦相似度）计算它们的相似度</strong>。<br />\nDeepFace 借鉴了 Siamese 网络的思路，在深度 CNN 上直接学习人脸特征的相似度，并通过优化和大规模训练，这才使得<strong>系统性能接近人类水平，真正具备部署价值</strong>。</p>\n<p>现在，就来详细看看一个较完善的 Siamese 网络的运行过程：</p>\n<h2 id=\"31-对图像进行编码处理三元组损失triplet-loss\">3.1 对图像进行编码处理：三元组损失（triplet loss）</h2>\n<p>我们先来看看什么叫对图像进行编码处理：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234657431-1853718024.png\" /><br />\n这样，我们就可以使用一组特征向量来编码一张人脸，实际上，这就是 DeepFace 提出的一步优化，这一步设置<strong>不止为了计算相似度作准备，同时也极大减少了计算量，缩短了运行时间</strong>，可以说相当成功。</p>\n<p>但是，同样也是因为这一步编码，新的问题出现了：<strong>你会发现，这个用来把图像转换成编码的网络同样需要训练。</strong><br />\n没错，我们需要训练这个网络，而目标就是：<strong>让同一个身份的人脸编码差异最小化，不同身份的人脸的编码差异最大化。</strong><br />\n要实现这个目标的常用方法叫做<strong>三元组（triplet）损失</strong>，这时，<strong>网络在训练阶段需要同时输入三张图像</strong>。<br />\n它的公式长这个样：</p>\n<p></p><div class=\"math display\">\\[L=max⁡(0,∥f(a)−f(p)∥^2_2−∥f(a)−f(n)∥^2_2+α)\n\\]</div><p></p><p>其中：</p>\n<ul>\n<li><span class=\"math inline\">\\(f(a)\\)</span>：anchor（基准图像）映射后的特征向量</li>\n<li><span class=\"math inline\">\\(f(p)\\)</span>：positive（同一身份的图像）映射后的特征向量</li>\n<li><span class=\"math inline\">\\(f(n)\\)</span>：negative（不同身份的图像）映射后的特征向量</li>\n<li><span class=\"math inline\">\\(\\alpha\\)</span>：间隔（margin），保证不同身份的距离比同一身份距离至少大 <span class=\"math inline\">\\(\\alpha\\)</span></li>\n</ul>\n<p>别慌，我们用一个例子来演示一遍原理：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229235145998-454139387.png\" /></p>\n<p><img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234301253-442526298.png\" /><br />\n只看符号可能有些太绕了，<strong>我们再来看一个实例</strong>：<br />\n假设三张人脸图像：经过网络映射后的二维特征向量如下：</p>\n<table>\n<thead>\n<tr>\n<th>图像</th>\n<th>特征向量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a (Alice)</td>\n<td>[1.0, 1.0]</td>\n</tr>\n<tr>\n<td>p (Alice)</td>\n<td>[1.2, 1.1]</td>\n</tr>\n<tr>\n<td>n (Bob)</td>\n<td>[2.5, 2.0]</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"1计算欧氏距离\">（1）计算欧氏距离</h4>\n<p><strong>Anchor 与 Positive（同一人）</strong>：</p>\n<p></p><div class=\"math display\">\\[∥f(a)-f(p)∥_2^2 = (1.0-1.2)^2 + (1.0-1.1)^2 = 0.04 + 0.01 = 0.05  \n\\]</div><p></p><p><strong>Anchor 与 Negative（不同人）</strong>：</p>\n<p></p><div class=\"math display\">\\[∥f(a)-f(n)∥_2^2 = (1.0-2.5)^2 + (1.0-2.0)^2 = 2.25 + 1.0 = 3.25  \n\\]</div><p></p><h4 id=\"2代入三元组损失公式\">（2）代入三元组损失公式</h4>\n<p>假设 <span class=\"math inline\">\\(\\alpha = 0.5\\)</span>，代入数值：</p>\n<p></p><div class=\"math display\">\\[L = \\max\\Big(0,0.05 - 3.25 + 0.5\\Big) = \\max(0, -2.7) = 0  \n\\]</div><p></p><p>代表当前特征向量满足目标，同一人距离接近，不同人距离大于 <span class=\"math inline\">\\(\\alpha\\)</span>。</p>\n<h4 id=\"3如果-negative-太近\">（3）如果 Negative 太近</h4>\n<p>假设 <span class=\"math inline\">\\(f(n) = [1.5, 1.3]\\)</span>，计算距离：</p>\n<p></p><div class=\"math display\">\\[∥f(a)-f(n)∥_2^2 = (1.0-1.5)^2 + (1.0-1.3)^2 = 0.25 + 0.09 = 0.34  \n\\]</div><p></p><p>损失为：</p>\n<p></p><div class=\"math display\">\\[L = \\max\\Big(0, 0.05 - 0.34 + 0.5\\Big) = \\max(0, 0.21) = 0.21  \n\\]</div><p></p><p>便说明不同人距离太近，网络需要更新，保留损失来进行反向传播。</p>\n<p><strong>通过这种设计，网络可以直接学习一个适合度量相似度的特征空间。</strong></p>\n<p>最后要强调的一点是，为了让训练效果更好，<strong>我们在选择三元组时，会尽量让基准图像和同一人的图像差别尽可能大，同时让基准图像和不同人的图像差别尽可能小。</strong><br />\n这就像是在手动提高考试难度，难题会了，简单题自然不在话下。<br />\n现在，我们便继续下一部分。</p>\n<h2 id=\"32-正向传播两幅图像并计算相似度\">3.2 正向传播两幅图像并计算相似度</h2>\n<p>在拥有了可以对图像进行合适编码的网络后，我们便可以进行相似度计算的应用，这一步的过程是这样的：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234408230-256446436.png\" /><br />\n如图所示，我们通过正向传播得到两幅输入人脸的编码，并根据编码计算相似度，自然就可以根据阈值判断两张人脸是否属于同一个人。<br />\n而且，这种传播和计算相似度分离的设计，代表<strong>我们可以提前为数据库中的图像计算好编码</strong>，只需刷脸时传入的人脸单独传播得到编码后进行计算就好了，这大大提高了可部署性。</p>\n<h2 id=\"33-拓展另一种训练编码网络的方式\">3.3 拓展：另一种训练编码网络的方式</h2>\n<p>我们刚刚介绍了可以通过三元组损失来训练编码网络，但你可能也发现了，这个方法在数据准备阶段较为复杂。<br />\n因此，吴恩达老师还介绍了另一种训练方法：<strong>更改标签，让Siamese 网络后接逻辑回归变为二分类问题。</strong><br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202512/3708248-20251229234243543-574274696.png\" /><br />\n这样，我们就又把人脸识别问题又转换回了二分类问题，通过反向传播来进行训练。<br />\n但是，你会发现，<strong>当新员工加入时，还是要重新训练模型。</strong><br />\n因此，实际上这种方式的实际部署价值并不如使用三元组损失。</p>\n<h1 id=\"4总结\">4.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>人脸验证（Face Verification）</td>\n<td>1 对 1 问题，判断输入人脸是否与目标身份匹配</td>\n<td>就像门卫只对某个人说“可以进”，其他人全部拒绝</td>\n</tr>\n<tr>\n<td>人脸识别（Face Recognition）</td>\n<td>1 对多问题，通过模型识别输入人脸属于哪一个已知身份</td>\n<td>门禁系统识别多个员工，不需要单独为每个人设闸机</td>\n</tr>\n<tr>\n<td>多分类建模问题</td>\n<td>将每个人作为一个类别进行训练</td>\n<td>每个员工都有一本写真集，要学会区分成千上万本</td>\n</tr>\n<tr>\n<td>一次学习（One-Shot Learning）</td>\n<td>每个身份仅提供极少样本，通过相似度判断识别</td>\n<td>只需一张证件照就能识别新员工，不用拍写真集</td>\n</tr>\n<tr>\n<td>Siamese 网络</td>\n<td>共享权重的双分支（或多分支）网络，将图像映射到同一特征空间，通过度量函数计算相似度</td>\n<td>同时看两张照片，然后比较相似度</td>\n</tr>\n<tr>\n<td>三元组损失（Triplet Loss）</td>\n<td>训练网络使同一人距离最小，不同人距离最大，网络需输入三张图像（anchor, positive, negative）</td>\n<td>提高考试难度：基准题和相似题差别小，不同题差别大，训练更有效</td>\n</tr>\n<tr>\n<td>正向传播两图计算相似度</td>\n<td>已训练网络对两幅图像编码后，计算特征距离或相似度，用阈值判断是否同一人</td>\n<td>先把照片编码成“身份特征卡片”，刷脸时只比对卡片</td>\n</tr>\n<tr>\n<td>Siamese + 逻辑回归二分类</td>\n<td>将两张图像输入 Siamese 网络，通过逻辑回归判断是否同一人</td>\n<td>将人脸识别问题简化成“是/不是同一人”的选择题</td>\n</tr>\n<tr>\n<td>部署可行性对比</td>\n<td>三元组损失支持 one-shot、可提前计算数据库特征向量，泛化强；逻辑回归方式新身份需重新训练，泛化差</td>\n<td>三元组：考试考通用能力；逻辑回归：考试只会答已有题目</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-29 23:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">104</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ã€è¯‘ã€‘Visual Studio â€”â€” ä¸ºçŽ°ä»£å¼€å‘çš„é€Ÿåº¦è€Œæ‰“é€",
      "link": "https://www.cnblogs.com/MeteorSeed/p/19417404",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/MeteorSeed/p/19417404\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 14:14\">\n    <span>【译】Visual Studio —— 为现代开发的速度而打造</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>　　Visual Studio 2026 标志着微软在其 50 年承诺中的又一次演进，该承诺旨在提供开发者喜爱且企业信赖的工具，这些工具旨在跟上现代开发的步伐。软件开发的速度比以往任何时候都快，而 Visual Studio 也在与您一同演进。</span></p>\n<p><span>　　今天，我们将宣布 Visual Studio 在生命周期和发布节奏方面迈出的重要一步。Visual Studio 将成为一款持续更新的现代化 IDE，旨在一旦有创新成果便立即交付，同时保持您们日常所依赖的可靠性和稳定性。我们将通过每月的功能更新和新的年度主版本发布来实现这一点。</span></p>\n<h1><span><span>我们为何要进行现代化改造</span></span></h1>\n<p><span>　　Visual Studio 如今正以现代软件的速度进行创新。无论您是开发桌面应用、云服务、游戏、Web API 还是 AI 智能体，这款 IDE 现在每月都会推出最新的性能和功能改进，且 GitHub Copilot 的使用体验也始终保持更新。</span></p>\n<p><span>　　我们也听到了对无阻碍更新的需求。您现有的项目、解决方案和扩展将继续像现在这样正常运行。我们在月度和年度版本中保持着较高的兼容性标准，因此在 IDE 不断演进的同时，您仍能保持高效工作，并且您的构建也会保持稳定。</span></p>\n<p><span>　　由于 IDE 与构建工具相互分离，这些更改无需您修改现有项目或重新构建可正常运行的应用程序。Visual Studio 每月都会更新，但您的 .NET 或 C++ 编译器构建工具、运行时和扩展仍会完全按照以前的方式工作。构建工具和 SDK 有其自身长达多年的生命周期，因此即使 IDE 新增了功能，您的构建环境也能保持稳定。</span></p>\n<h1><span><span>为现代开发而打造</span></span></h1>\n<p><span>　　自 Visual Studio 2017 起，我们就一直在稳步提高发布节奏，提供季度性的功能更新、服务版本以及灵活的构建工具选择。借助 Visual Studio 2026，我们将迈出下一步，转向现代支持生命周期，让您自动使用最新的工具和功能。</span></p>\n<p><span>　　这种新方法意味着：</span></p>\n<p><span>　　- 每月进行功能更新，而非每季度一次。</span></p>\n<p><span>　　- 每年发布一个新的年度版本，于 11 月与 .NET 版本一同发布。</span></p>\n<p><span>　　- 在现代支持生命周期下提供可预测的维护和支持，包括一年的月度功能更新，随后是一年的保障修复。</span></p>\n<p><span>　　- 更新至最新版本，以继续获得支持以及新功能、修复和安全更新方面的维护。</span></p>\n<p><span>　　这一切都是为了在更新准备就绪后立即为您提供。</span></p>\n<h1><span><span>构建工具的自由 —— 一切尽在您的掌控之中</span></span></h1>\n<p><span>　　随着对 Visual Studio 的更新和支持方式做出这些改变，了解构建工具和组件如何融入这一新模式也同样重要。</span></p>\n<p><span>　　我们知道每个团队都有自己的节奏。Visual Studio 继续提供种类繁多的构建工具和组件，以支持您期望的平台。由于包含了这些构建工具的多个受支持版本，您可以选择何时推进自己的项目。您可以按照自己的计划采用最新的编译器、运行时或 SDK，同时仍然能从每月的 IDE 改进和人工智能功能中获益。</span></p>\n<p><span>　　这些构建工具、SDK 和运行时都有各自的支持生命周期。例如，现代的 .NET 每年发布一次，提供 2 年的标准期限支持（STS）和 3 年的长期支持（LTS）。.NET Framework 的生命周期与其所搭载的 Windows 版本紧密相关。</span></p>\n<p><span>　　对于 C++ 开发者，我们也在将微软 C++（MSVC）编译器和生成工具与 Visual Studio 的生命周期解耦。这使得编译器团队能够每六个月发布更快、更灵活的更新，并每两年推出长期支持版本。</span></p>\n<h1><span><span>Insiders 和 Stable 频道</span></span></h1>\n<p><span>　　为了支持这种更快的更新节奏，从Visual Studio 2026 开始，将提供两个频道：</span></p>\n<p><span>　　- Insiders —— 抢先体验即将推出的功能，分享反馈，助力塑造未来发展。如需安装，请访问 https://visualstudio.microsoft.com/insiders/。（Insiders取代了此前的“Preview”。）</span></p>\n<p><span>　　- Stable —— 每月获取经过验证、可用于生产环境的功能。如需安装，请访问 https://visualstudio.microsoft.com/download。<span>（Stable 版本取代了此前可用的 “Current” 频道。）</span></span></p>\n<p><span>　　在 Insiders 中出现的功能，当它们准备好被广泛采用时，将会纳入 Stable。如果您使用的是 Stable，您将每月收到一次功能更新，并在需要时收到服务发布更新。</span></p>\n<p><span>　　每年，这款 IDE 都会更新到下一个年度版本，例如明年 11 月，Visual Studio 2026 将就地更新为 Visual Studio 2027，不会对您的环境造成干扰。</span></p>\n<p><span>　　我们的企业客户有时在安排更新的时间方面需要更大的灵活性。为确保能为他们提供全面支持，我们还将为之前的年度版本提供并行的长期服务频道（LTSC）。其提供为期 1 年的保障服务。例如，在 2026 年 11 月，您将可以选择切换到 Visual Studio 2026 LTSC，从而在额外的一年时间里继续使用固定的功能集。</span></p>\n<p><span>　　不过，需要注意的是，Visual Studio LTSC 并非维持项目处于已知状态所必需的。如果您的项目使用随 Visual Studio 2026 一同发布的 .NET 10 或 MSVC 14.50，那么当您更新到 Visual Studio 2027 时，这些构建工具仍将可用，您的项目也应该能像以前一样正常构建。</span></p>\n<h1><span><span>灵活的许可与注册</span></span></h1>\n<p><span>　　这些针对 Visual Studio 的变更导致我们处理产品注册的方式发生了转变。Visual Studio Community 没有任何变化，它仍然对开源项目、教育领域和小型组织免费开放。（详情请参见许可协议。）</span></p>\n<p><span>　　对于专业版和企业版，如果您拥有 Visual Studio 订阅，注册流程没有变化。您将继续像以前一样登录，并通过现代生命周期自动接收更新，或者从 Visual Studio 订阅者门户获取产品密钥。如果您使用独立的专业版许可证，只需每年购买新的年度版本即可。产品密钥将继续适用于该年度版本，而新的密钥将解锁下一年的版本。</span></p>\n<p><span>　　此外，Visual Studio 2022、Visual Studio 2019 和 Visual Studio 2017 的生命周期没有任何变化。</span></p>\n<h1><span><span>随时<span><span>更新，随时就绪</span></span></span></span></h1>\n<p><span>　　Visual Studio 2026 标志着一个新时代的开始，这是一款现代化、智能化且持续改进的 IDE。您将减少等待更新的时间，有更多时间使用最新工具开发出色的软件。</span></p>\n<p><span>　　我们期待您体验这种新的更新节奏，分享您的反馈，并帮助塑造 Visual Studio 的未来。征程仍在继续，Visual Studio 将与您并肩同行，每月如此，每个版本皆是如此。</span></p>\n<p><span>&nbsp;</span></p>\n<p><span>原文链接：https://devblogs.microsoft.com/visualstudio/visual-studio-built-for-the-speed-of-modern-development/</span></p>\n<p><span><img alt=\"me\" src=\"https://img2024.cnblogs.com/blog/270073/202508/270073-20250825145337681-1658462272.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p><strong>作者：</strong><a href=\"http://www.cnblogs.com/MeteorSeed\">MeteorSeed</a></p>\n<p><strong>我希望您喜欢这篇博文，并一如既往地感谢您阅读并与朋友和同事分享我的博文。</strong></p>\n<p><strong>转载请注明出处。</strong></p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 14:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/MeteorSeed\">MeteorSeed</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Rime-AI v2版本发布",
      "link": "https://www.cnblogs.com/gepai/p/19420809",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/gepai/p/19420809\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 13:17\">\n    <span>Rime-AI v2版本发布</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"ai-rime\">AI-Rime</h1>\n<p>基于Rime的lua脚本系统打造AI增强输入法</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h1 id=\"rime-ai-纠错-v1-智能纠错\">Rime AI 纠错 v1 智能纠错</h1>\n<h2 id=\"功能说明\">功能说明</h2>\n<p>极简版 AI 纠错功能：</p>\n<ul>\n<li>按 <strong>6</strong> 触发纠错，显示\"AI纠正中...\"</li>\n<li>再按 <strong>6</strong> 显示纠正结果</li>\n</ul>\n<h2 id=\"文件清单\">文件清单</h2>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ai_corrector_processor.lua</code></td>\n<td>按键监听（放入 <code>lua/</code> 目录）</td>\n</tr>\n<tr>\n<td><code>ai_corrector.lua</code></td>\n<td>候选词处理（放入 <code>lua/</code> 目录）</td>\n</tr>\n<tr>\n<td><code>ai_corrector_service*</code></td>\n<td>后台服务</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"前言\">前言</h1>\n<p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>\n<p>Rime输入法支持内置简单的Lua脚本，基于此得以设计AI输入法。</p>\n<p>Rime的配置文件夹结构大致如下：</p>\n<p><strong>Rime</strong></p>\n<ul>\n<li>Lua——存放lua脚本</li>\n<li>build——存放构建后的信息</li>\n<li>*.userdb——存放用户输入习惯的记录</li>\n<li>*_dicts——存放引入的词典</li>\n<li>其他配置文件</li>\n</ul>\n<h2 id=\"安装步骤\">安装步骤</h2>\n<h3 id=\"1-程序文件部署\">1. 程序文件部署</h3>\n<p>当前版本总共需要部署三个程序，分别是两个lua程序以及一个可执行程序。</p>\n<p>Rime输入法配置文件可通过Rime输入法菜单打开，Mac端叫作<code>用户设定</code>，Windows端叫作<code>用户文件夹</code>。Mac下Rime用户资料默认在<code>Users/用户名/Library/Rime</code>下，可直接在<code>README.md</code>所在目录打开终端执行下面命令进行复制。</p>\n<pre><code class=\"language-bash\">cp ai_corrector_processor.lua ~/Library/Rime/lua/\ncp ai_corrector.lua ~/Library/Rime/lua/\n</code></pre>\n<p>Windows端Rime用户文件夹默认路径是<code>C:\\Users\\用户名\\AppData\\Roaming\\Rime</code>，Linux平台输入框架和版本不同则具体的也会目录不同，需要根据系统是fictx4、fictx5或iBus来定。</p>\n<p>将不同平台对应的可执行程序复制到Rime配置文件的根目录下。</p>\n<h3 id=\"2-配置-rime-schema\">2. 配置 Rime Schema</h3>\n<p>在你的输入方案的schema（例如雾凇拼音rime_ice.schema.yaml文件）中添加：</p>\n<pre><code class=\"language-yaml\">engine:\n  processors:\n    - lua_processor@*ai_corrector_processor\t# 尽量放在processors前面，以免被其他processor抢先捕获\n  filters:\n    - lua_filter@*ai_corrector\t# 这一条必须放在filters的第一个位置，用于修改AI纠正结果显示\n</code></pre>\n<p>或者在输入方案的custom文件中添加：</p>\n<pre><code class=\"language-yaml\">patch:\t# 更推荐这种添加方案，不影响原有配置文件\n  engine/processors/@after 0: lua_processor@*ai_corrector_processor\n  engine/filters/@before last: lua_filter@*ai_corrector\n</code></pre>\n<p>例如对雾凇拼音的<code>rime_ice.shcema.yaml</code>配置文件创建一个<code>rime_ice.custom.yaml</code>文件，然后添加上面的<code>patch内容</code>。</p>\n<h3 id=\"3-启动服务\">3. 启动服务</h3>\n<ul>\n<li>\n<p>Windows平台在Rime根目录下打开PowerShell，执行命令开启服务，终端会显示纠错请求信息。Windows平台可以利用nssm制作后台服务（注意工作目录设置成Rime配置文件根目录）。</p>\n<pre><code class=\"language-shell\">./ai_corrector_service_Windows/ai_corrector_service.exe\n</code></pre>\n</li>\n<li>\n<p>Linux平台同样在Rime配置根目录打开终端，执行命令启动服务。</p>\n<pre><code class=\"language-shell\">./ai_corrector_service_Linux/ai_corrector_service.bin\n</code></pre>\n<p>如果启动失败的话检查权限是否正确，通过命令赋予运行权限。</p>\n<pre><code class=\"language-shell\">chmod +x ./ai_corrector_service_Linux/ai_corrector_service.bin\n</code></pre>\n<p>Linux可用systemd设置成服务后台运行，直接执行bin文件即可，建议设置工作目录是Rime配置文件根目录。</p>\n</li>\n<li>\n<p>Mac平台将<code>ai_corrector_service_Mac.app</code>放置在Rime配置文件根目录后<strong>不可以</strong>直接双击运行，因为服务程序没有UI，因此同样需要在Rime配置文件根目录打开终端执行命令：</p>\n<pre><code class=\"language-shell\">./ai_corrector_service_Mac.app/Contents/MacOS/ai_corrector_service\n</code></pre>\n</li>\n</ul>\n<p>​\tMac电脑可用launched设置成服务后台运行。</p>\n<h3 id=\"4-重新部署-rime\">4. 重新部署 Rime</h3>\n<h2 id=\"使用方法\">使用方法</h2>\n<p>本方案是基于雾凇拼音输入方案而设计的，其他拼音方案同样可用。雾凇拼音默认设置5个候选词，因此我将数字键6作为了触发纠错功能的触发按键。</p>\n<p>上面部署阶段成功后，具体的操作流程如下：</p>\n<ol>\n<li>输入拼音，看到候选词</li>\n<li>按 <strong>6</strong> 触发纠错</li>\n<li>再按 <strong>6</strong> 显示结果</li>\n<li>按 <strong>空格</strong> 选择结果</li>\n</ol>\n<p><strong>结束语：</strong></p>\n<p>因为Rime本身的设计，lua脚本只能在输入发生变动时触发，因此该版本需要先按数字键6触发AI纠错请求，等1-2s后再按6触发AI返回结果显示。等待按第二次键很是恼人，目前已经在设计第二版本，期望可以解决避免需要二次按键触发的问题。</p>\n<p>当前版本prompt提示词经过数百次尝试优化，已经达到较好的效果。如果关注较多的话考虑下一版本公开提示词，到时候可以自定义做更多花样。</p>\n<p>资源链接：</p>\n<p><a href=\"https://1815368419.v.123pan.cn/1815368419/26934630\" rel=\"noopener nofollow\" target=\"_blank\">https://1815368419.v.123pan.cn/1815368419/26934630</a></p>\n<h1 id=\"rime-ai-纠错-v2-可配置版\">Rime AI 纠错 v2 可配置版</h1>\n<h2 id=\"功能说明-1\">功能说明</h2>\n<p>支持外部配置文件和自动触发的 AI 纠错功能：</p>\n<ul>\n<li>按 <strong>6</strong> 触发纠错</li>\n<li>按 <strong>0</strong> 显示结果（或开启自动触发后自动显示）</li>\n</ul>\n<h2 id=\"文件清单-1\">文件清单</h2>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ai_corrector_processor.lua</code></td>\n<td>按键监听（放入 <code>lua/</code> 目录）</td>\n</tr>\n<tr>\n<td><code>ai_corrector.lua</code></td>\n<td>候选词处理（放入 <code>lua/</code> 目录）</td>\n</tr>\n<tr>\n<td><code>ai_corrector_service.*</code></td>\n<td>后台服务</td>\n</tr>\n<tr>\n<td><code>ai_corrector_config.json</code></td>\n<td>配置文件</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"安装步骤-1\">安装步骤</h2>\n<h3 id=\"1-复制文件\">1. 复制文件</h3>\n<p><strong>见版本1说明</strong></p>\n<h3 id=\"2-修改配置\">2. 修改配置</h3>\n<p>编辑 <code>ai_corrector_config.json</code>：</p>\n<pre><code class=\"language-json\">{\n    \"api_key\": \"你的API密钥\",\n    \"auto_trigger\": true\n}\n</code></pre>\n<p>配置文件记录着请求AI的信息，请把他放置在Rime配置目录下。</p>\n<h3 id=\"3-配置-rime-schema\">3. 配置 Rime Schema</h3>\n<p><strong>见版本1说明</strong></p>\n<h3 id=\"4-启动服务\">4. 启动服务</h3>\n<p><strong>见版本1说明</strong></p>\n<h3 id=\"5-重新部署-rime\">5. 重新部署 Rime</h3>\n<h2 id=\"配置选项\">配置选项</h2>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>provider</code></td>\n<td>AI 提供商 (deepseek/openai/ollama)</td>\n<td>deepseek</td>\n</tr>\n<tr>\n<td><code>api_key</code></td>\n<td>API 密钥</td>\n<td>空</td>\n</tr>\n<tr>\n<td><code>api_url</code></td>\n<td>API 地址</td>\n<td>DeepSeek</td>\n</tr>\n<tr>\n<td><code>model</code></td>\n<td>模型名称</td>\n<td>deepseek-chat</td>\n</tr>\n<tr>\n<td><code>auto_trigger</code></td>\n<td>自动显示结果</td>\n<td>true</td>\n</tr>\n<tr>\n<td><code>prompt</code></td>\n<td>纠错提示词</td>\n<td>内置</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"自动触发\">自动触发</h2>\n<p>开启 <code>auto_trigger</code> 后：</p>\n<ol>\n<li>按 6 触发纠错</li>\n<li>AI 返回结果后自动模拟按键 0</li>\n<li>结果自动显示</li>\n</ol>\n<p>需要权限：</p>\n<ul>\n<li><strong>macOS</strong>: 系统设置 → 隐私与安全性 → 辅助功能 → 添加 服务程序</li>\n</ul>\n<p>资源链接：</p>\n<p><a href=\"https://1815368419.v.123pan.cn/1815368419/26963692\" rel=\"noopener nofollow\" target=\"_blank\">https://1815368419.v.123pan.cn/1815368419/26963692</a></p>\n<h1 id=\"v2-linux修复版本\">V2-Linux修复版本</h1>\n<p><strong>前言：</strong></p>\n<ul>\n<li>\n<p>由于Linux系统输入法框架的设计，首发v2版本出现配置文件找错目录的问题，现已经经过修改和测试，在作者Ubuntu24 x11系统上已经可以正常运行，如若在其他发行版上出现问题请及时反馈。</p>\n</li>\n<li>\n<p>v2版本是基于python的pynput模块实现发送模拟按键0来代替用户第二次按键触发直接修改输入法第一个候选词显示为AI返回结果的，但是优于Linux下x11和Wayland对pynput支持较差，因此此次修复版本针对这一问题做出了深度修复与测试。作者Ubuntu24 x11环境下可以实现正常纠错及自动触发，优于作者设备有限，没能测试Wayland，因此下面给出x11的实际可行配置策略及Wayland理论可行配置策略。</p>\n</li>\n</ul>\n<h1 id=\"linux-模拟按键配置指南\">Linux 模拟按键配置指南</h1>\n<p>本文档说明在 Linux 环境下配置 AI 纠错服务自动触发功能所需的依赖和设置。</p>\n<h2 id=\"问题背景\">问题背景</h2>\n<p>Python 的 <code>pynput</code> 库在 Linux 下存在以下问题：</p>\n<ul>\n<li><strong>X11</strong>：需要额外权限配置，且不够稳定</li>\n<li><strong>Wayland</strong>：静默失败，无法正常工作</li>\n</ul>\n<p>因此，在 Linux 下程序<strong>跳过 pynput</strong>，改用系统工具。</p>\n<hr />\n<h2 id=\"环境检测\">环境检测</h2>\n<p>程序通过环境变量 <code>XDG_SESSION_TYPE</code> 自动检测当前桌面环境：</p>\n<pre><code class=\"language-bash\">echo $XDG_SESSION_TYPE\n# 输出 \"x11\" 或 \"wayland\"\n</code></pre>\n<hr />\n<h2 id=\"x11-环境\">X11 环境</h2>\n<h3 id=\"使用工具xdotool\">使用工具：xdotool</h3>\n<h3 id=\"安装\">安装</h3>\n<pre><code class=\"language-bash\"># Ubuntu/Debian\nsudo apt install xdotool\n\n# Fedora\nsudo dnf install xdotool\n\n# Arch\nsudo pacman -S xdotool\n</code></pre>\n<h3 id=\"测试\">测试</h3>\n<pre><code class=\"language-bash\">xdotool key 0\n</code></pre>\n<h3 id=\"无需额外配置\">无需额外配置</h3>\n<p>X11 下 xdotool 开箱即用，无需守护进程或特殊权限。</p>\n<hr />\n<h2 id=\"wayland-环境\">Wayland 环境</h2>\n<h3 id=\"使用工具ydotool\">使用工具：ydotool</h3>\n<h3 id=\"安装-1\">安装</h3>\n<pre><code class=\"language-bash\"># Ubuntu/Debian\nsudo apt install ydotool\n\n# Fedora\nsudo dnf install ydotool\n\n# Arch\nsudo pacman -S ydotool\n</code></pre>\n<h3 id=\"启动守护进程\">启动守护进程</h3>\n<p>ydotool 需要后台运行 <code>ydotoold</code> 守护进程：</p>\n<pre><code class=\"language-bash\"># 手动启动\nsudo ydotoold &amp;\n\n# 或使用 systemd（推荐）\nsudo systemctl enable ydotool\nsudo systemctl start ydotool\n</code></pre>\n<h3 id=\"用户权限\">用户权限</h3>\n<p>将用户添加到 <code>input</code> 组：</p>\n<pre><code class=\"language-bash\">sudo usermod -aG input $USER\n# 注销并重新登录生效\n</code></pre>\n<h3 id=\"测试-1\">测试</h3>\n<pre><code class=\"language-bash\"># 数字 0 的 Linux 内核键码是 11\n# 格式：keycode:1 (按下) keycode:0 (释放)\nydotool key 11:1 11:0\n</code></pre>\n<hr />\n<p><strong>结语：</strong> 以上是针对Linux用户需要特殊配置的说明，若有其他问题请即时反馈。</p>\n<p>资源链接：<a href=\"https://1815368419.v.123pan.cn/1815368419/26969029\" rel=\"noopener nofollow\" target=\"_blank\">https://1815368419.v.123pan.cn/1815368419/26969029</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 13:17</span>&nbsp;\n<a href=\"https://www.cnblogs.com/gepai\">密码战士</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "让 AI 分析我 3 年前写的代码，全是漏洞！",
      "link": "https://www.cnblogs.com/yupi/p/19420512",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19420512\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 11:48\">\n    <span>让 AI 分析我 3 年前写的代码，全是漏洞！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"让 AI 分析我 3 年前写的代码，全是漏洞！\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202512/2225420-20251230112305334-1414820438.png\" />\n        对于个人开发者来说，这类工具可以帮你在提交代码前发现潜在问题，拿来检测一下自己之前的老项目代码也是不错的；对于团队来说，可以把 AI 接入到 CI/CD 流程中，自动化代码安全检查。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-heading\"><span class=\"md-plain\">大家好，俺是程序员鱼皮。最近逛 GitHub 的时候，发现了一个挺有潜力的开源项目 —— DeepAudit，让 AI 帮你挖掘项目漏洞。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">势头很猛啊，短短时间就涨了不少 star，看这 star 趋势图：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这是一个 AI 代码审计工具，能自动分析你的代码，找出潜在的安全漏洞和代码问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">作者很贴心地提供了在线体验版，可以直接使用，当然也支持本地部署。下面鱼皮以作者部署的在线体验版，带大家体验一下这个项目的功能。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先需要配置自己的大模型 API Key，国内的很多大模型都支持：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果想直接导入并分析你在 GitHub 上的项目，而不是手动上传代码，那么还需要配置 GitHub Token，让工具能够读取到你的仓库代码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可以在 GitHub 上生成一个新的 Token：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">配置好之后，就可以创建一个要分析的项目了，仓库地址要填写正确。这里鱼皮拿自己 3 年前做的个人开源项目 —— SQL 代码和数据生成器试试水。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img alt=\"创建新项目\" class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后新建一个审计任务：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">填写要分析的分支，还可以设置一些文件排除规则，比如排除 <span class=\"md-pair-s\"><code>node_modules</code><span class=\"md-plain\">、测试文件等。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">点击开始分析，AI 就屁颠儿屁颠儿干活了~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我去，竟然发现了 123 个问题？！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过能写出 123 个问题，我感觉自己也是挺厉害的哈哈哈。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">进入任务详情页面，我倒要看看都是什么问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先看看最严重的 —— SQL 注入漏洞。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 的解释还挺到位的，确实存在 SQL 注入风险。当时这么写纯属图方便，没想到被 AI 一眼看穿了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">一些小细节也被指出来了，比如硬编码、异常处理不够完善、日志记录不规范等。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过也有一些误报，AI 把正常的代码逻辑判断成了问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">总体来说，这个工具还有进步空间，但已经很实用了。正好我们团队需要这样的代码审计工具，还是挺期待作者能进一步完善的。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">审计完成后，还可以直接导出报告：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">一下子就得到了整整 70 多页的专业报告！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">想想我大学的时候做课设作业，要是有 AI 帮忙生成这种报告，不得爽飞边子了？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了项目审计，作者还提供了即时分析功能。不过这个就没什么新意了，我们团队的 <span class=\"md-meta-i-c  md-link\"><a href=\"https://codecopy.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">代码小抄</span></a><span class=\"md-plain\">在 24 年初就已经上线了这个功能。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我体验这个项目的时候，还有很多功能没做完，不过这也是 MVP 最小可行产品原则嘛，快速验证想法最重要。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">值得一提的是，作者更新非常频繁。截止到目前，项目界面已经焕然一新了，更有极客范儿。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在审计流日志页面可以看到 AI 思考分析的过程：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还有智能仪表盘，可以直观地看到代码质量趋势：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">最后</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个项目的实现思路其实挺值得学习的。通过调用大模型的 API，让 AI 理解代码逻辑，然后根据常见的安全漏洞模式和最佳实践进行分析，最后生成结构化的审计报告。整个流程和 AI 代码审查是类似的，但更专注于安全漏洞的发现。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img alt=\"DeepAudit 架构图\" class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对于个人开发者来说，这类工具可以帮你在提交代码前发现潜在问题，拿来检测一下自己之前的老项目代码也是不错的；对于团队来说，可以把 AI 接入到 CI/CD 流程中，自动化代码安全检查。虽然本项目暂时还有误报，但随着 AI 能力的提升，以及作者在领域知识方面的填充，相信会越来越准确。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">来试试看，你的项目代码里有多少个 Bug？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-meta-i-c md-link md-expand\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 11:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}