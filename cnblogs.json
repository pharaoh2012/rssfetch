{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "软件测试",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19527882",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19527882\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 23:49\">\n    <span>软件测试</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"软件测试定义\">软件测试定义</h4>\n<ul>\n<li>软件测试就是验证软件产品特性是否满⾜用户的需求。</li>\n</ul>\n<h4 id=\"软件测试开发程师和测试程师的区别\">软件测试开发⼯程师和测试⼯程师的区别</h4>\n<ul>\n<li>相同点：\n<ol>\n<li>都统称为测试⼈员</li>\n<li>对产品质量负责，保障产品的质量</li>\n</ol>\n</li>\n<li>不同点：测试开发⽐测试多开发⼆字，⽽这个开发并不是指业务开发，因为业务开发是开发⼈员的主要职责，这⾥的开发指的是需要开发测试效率⼯具，通过效率⼯具来提升测试效率和测试质量，⽐如我们的⾃动化、性能测试等就属于效率⼯具。</li>\n</ul>\n<h4 id=\"软件的命周期\">软件的⽣命周期</h4>\n<ul>\n<li>软件生命周期包括：需求分析、计划、设计、编码、测试、运行维护。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>具体内容</th>\n<th>产出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>需求分析</td>\n<td>分析用户需求是否合理，分别从市场需求、技术等⽅⾯进⾏分析。</td>\n<td>该阶段会输出需求等⽂档。</td>\n</tr>\n<tr>\n<td>计划</td>\n<td>对成⽴的需求执⾏需求执⾏计划，多⻓时间内完成该需求，每段时间具体完成哪些功能。</td>\n<td>该阶段会输出计划等⽂档。</td>\n</tr>\n<tr>\n<td>设计</td>\n<td>将需求细化成⼀个个任务，团队成员各司其职领取任务并进⾏技术设计（如何进⾏架构设计，设计哪些接⼝、采⽤什么技术）</td>\n<td>该阶段会输出技术等⽂档。</td>\n</tr>\n<tr>\n<td>编码</td>\n<td>开发⼈员参考需求⽂档、设计⽂档、交互图等等⽂件进⾏代码的编写。</td>\n<td>代码⽂件等⽂档。</td>\n</tr>\n<tr>\n<td>测试</td>\n<td>测试⼈员需要介⼊到软件的测试中来，参考测试⽤例对软件进⾏测试。</td>\n<td>测试⽤例、测试设计与计划、测试报告等⽂档</td>\n</tr>\n<tr>\n<td>运⾏维护</td>\n<td>项⽬测试结束之后，项⽬需要进⾏上线，并对产品进⾏线上的维护。线上的维护主要分为三个⽅⾯。分别为修复性维护、完善性维护和预防性维护。修复性维护：对项⽬中未发现的问题进⾏修复。完善性维护：对功能进⾏完善。预防性维护：居安思危，为了避免产品在线上出现⼀些其他不可预料的问题，进⾏⼀些防护的⼿段。</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"常见的开发模型\">常见的开发模型</h4>\n<ol>\n<li>瀑布模型:</li>\n</ol>\n<ul>\n<li>start--&gt;需求分析--&gt;计划--&gt;设计--&gt;编码--&gt;测试--&gt;end</li>\n<li>瀑布模型在软件⼯程中占有重要地位，是所有其他模型的基础框架。瀑布模型的每⼀个阶段都只执行⼀次，因此是线性顺序进⾏的软件开发模式。</li>\n<li>瀑布模型优缺点总结：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强调开发的阶段性；线性结构，每个阶段只执⾏⼀次;是其他模型的基础框架</td>\n<td>1.测试后置:前⾯各阶段遗留的⻛险推迟到测试阶段才被发现，导致项⽬⼤⾯积返⼯，失去了及早修复的机会；必须留有⾜够的时间给测试活动，否则导致测试不充分，将缺陷直接暴露给用户（产品质量差）2. 周期太⻓，产品很迟才能被看到和使⽤，可能会导致需求/功能过时</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>瀑布模型的适⽤场景：需求固定的⼩项⽬</li>\n</ul>\n<ol start=\"2\">\n<li>螺旋模型</li>\n</ol>\n<ul>\n<li>⼀般在软件开发初期阶段需求不是很明确时，采⽤渐进式的开发模式。螺旋模型是渐进式开发模型的代表之⼀。</li>\n<li>这对于那些规模庞⼤、复杂度⾼、⻛险⼤的项⽬尤其适合。这种迭代开发的模式给软件测试带来了新的要求，它不允许有⼀段独⽴的测试时间和阶段，测试必须跟随开发的迭代⽽迭代。因此，回归测试的重要性就不⾔⽽喻了。<br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强调严格的全过程⻛险管理。 强调各开发阶段的质量。增加⻛险分析和原型</td>\n<td>项⽬中可能存在的⻛险性与⻛险管理⼈员的技能⽔平有直接关系；需求⼈员、资⾦、时间的增加和投⼊，可能会导致项⽬的成本太⾼</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>适⽤场景：规模庞⼤、复杂度⾼、⻛险⼤的项⽬。</li>\n</ul>\n<ol start=\"3\">\n<li>增量模型、迭代模型</li>\n</ol>\n<ul>\n<li>增量开发能显著降低项⽬⻛险，结合软件持续构建机制，构成了当今流⾏的软件⼯程最佳实践之⼀。增量开发模型，⿎励⽤⼾反馈，在每个迭代过程中，促使开发⼩组以⼀种循环的、可预测的⽅式驱动产品的开发。因此，在这种开发模式下，每⼀次的迭代都意味着可能有需求的更改、构建出新的可执⾏软件版本，意味着测试需要频繁进⾏，测试⼈员需要与开发⼈员更加紧密地协作。</li>\n<li>与此类似的有⼀个迭代开发，增量开发和迭代开发往往容易被⼈，但是其实两者是有区别的。增量是逐块建造的概念，迭代是反复求精的概念。</li>\n<li>适⽤场景：⼤型项⽬，需求不明确</li>\n</ul>\n<ol start=\"4\">\n<li>敏捷模型</li>\n</ol>\n<ul>\n<li>敏捷模型主要旨在帮助项⽬快速适应变更请求。因此，敏捷模型的主要⽬的是促进项⽬的快速完成。要完成这项任务，需要敏捷。敏捷性是通过使过程适应项⽬，删除对特定项⽬可能不是必需的活动来实现的。此外，避免任何浪费时间和精⼒的事情。</li>\n<li>在敏捷模型中，需求被分解成许多可以增量开发的⼩部分。敏捷模型采⽤迭代开发。每个增量部分都是在迭代中开发的。每次迭代都旨在⼩⽽易于管理，并且只能在⼏周内完成。⼀次为客户计划、开发和部署⼀个迭代。没有制定⻓期计划。</li>\n<li>敏捷开发有很多种⽅式，其中scrum是⽐较流⾏的⼀种。在scrum模型中，主要有三个⻆⾊和五个重要会议。</li>\n<li>三个⻆⾊：scrum由product owner(产品经理)、scrum master(项⽬经理)和team(研发团队)组成。\n<ul>\n<li>其中product owner负责整理user story(⽤⼾故事)，定义其商业价值，对其进⾏排序，制定发布计划，对产品负责。</li>\n<li>scrum master负责召开各种会议，协调项⽬，为研发团队服务。</li>\n<li>研发团队则由不同技能的成员组成，通过紧密协同，完成每⼀次迭代的⽬标，交付产品。</li>\n</ul>\n</li>\n<li>五个会议：\n<ul>\n<li>迭代计划会议</li>\n<li>每日站会</li>\n<li>迭代评审会议</li>\n<li>迭代回顾会议</li>\n<li>需求细化会议</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"测试模型\">测试模型</h4>\n<ul>\n<li>测试模型中有两个⾮常重要且具有标志性的测试模型：V模型和W模型<br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n<li>优点：</li>\n</ul>\n<ol>\n<li>明确的标注了测试过程中存在的不同类型的测试，并且清楚的描述了这些测试阶段和开发过程期间各阶段的对应关系，有效提升测试的质量和效率。</li>\n<li>V模型指出：</li>\n</ol>\n<ul>\n<li>单元和集成测试应检测程序的执⾏是否满⾜软件设计的要求；</li>\n<li>系统测试应检测系统功能、性能的质量特性是否达到系统要求的指标；</li>\n<li>验收测试确定软件的实现是否满⾜⽤⼾需要或合同的要求<br />\n缺点：仅仅把测试作为在编码之后的⼀个阶段，未在需求阶段就介⼊测试。缺点同瀑布模型。</li>\n</ul>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<ul>\n<li>W模型增加了软件各开发阶段中应同步进⾏的验证和确认活动。W模型由两个V字型模型组成，分别代表测试与开发过程，图中明确表⽰出了测试与开发的并⾏关系。</li>\n<li>特点：测试的对象不仅是程序，需求、设计等同样要测试，测试与开发是同步进⾏的\u0001\u0001</li>\n<li>优点：\n<ul>\n<li>有利于尽早地全⾯的发现问题。例如，需求分析完成后，测试⼈员就应该参与到对需求的验证和确认活动中，以尽早地找出缺陷所在。同时，对需求的测试也有利于及时了解项⽬难度和测试⻛险，及早制定应对措施，显著减少总体测试时间，加快项⽬进度。</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>需求、设计、编码等活动被视为串⾏的；</li>\n<li>测试和开发活动也保持着⼀种线性的前后关系，上⼀阶段完全结束，才可正式开始下⼀个阶段⼯作。</li>\n<li>重流程，⽆法⽀持敏捷开发模式。对于当前软件开发复杂多变的情况，W模型并不能解除测试管理⾯临着困惑。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"软件测试的命周期\">软件测试的⽣命周期</h4>\n<ul>\n<li>软件测试的⽣命周期是指测试流程，这个流程是按照⼀定顺序执⾏的⼀系列特定的步骤，去保证产品质量符合需求。在软件测试⽣命周期流程中，每个活动都按照计划的系统的执⾏。每个阶段有不同的⽬标和交付产物</li>\n<li>具体包括：需求分析、测试计划、测试设计以及测试开发、测试执行、测试评估、上线、运行维护。</li>\n<li>总之软件测试贯穿于软件的整个生命周期。</li>\n</ul>\n<h4 id=\"bug\">BUG</h4>\n<ul>\n<li>bug的定义：⼀个计算机bug指在计算机程序中存在的⼀个错误(error)、缺陷(flaw)、疏忽(mistake)或者故障(fault)，这些bug使程序⽆法正确的运⾏。Bug产⽣于程序的源代码或者程序设计阶段的疏忽或者错误。</li>\n<li>描述bug的要素：问题出现的版本、问题出现的环境、问题出现的步骤、预期结果、实际结果。</li>\n<li>bug级别：⼀般分为崩溃、严重、⼀般、次要。</li>\n<li>bug的⽣命周期：\n<ul>\n<li>测试⼈员在执⾏测试的过程中如有发现bug，需要在对应的bug管理平台来创建bug（bug⽣命起源），创建好的bug需要被开发⼈员修复，以及测试⼈员的持续跟踪和测试。<br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n</ul>\n</li>\n<li>New:新发现的bug,未经评审决定是否指派给开发人员进行修改</li>\n<li>Open:确认是bug,并且认为需要修改，指派给相应的开发人员</li>\n<li>Fixed:开发人员进行修改后标识为修改状态，待测试人员进行验证</li>\n<li>Rejected:如果认为不是bug,则拒绝修改</li>\n<li>Delay:如果认为暂时不需要修改或者暂时不能修改，则延后修改</li>\n<li>Closed:修改状态的bug经过测试人员的回归测试验证并通过，则关闭bug</li>\n<li>Reopen:如果经过验证bug依然存在，则需要重新打开bug,开发人员重新修改</li>\n<li>⽆效的bug：open-&gt;closed open-rejected-closed</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 23:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "STM32之控制变量与函数的存储位置",
      "link": "https://www.cnblogs.com/lsksp/p/19527780",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lsksp/p/19527780\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 23:01\">\n    <span>STM32之控制变量与函数的存储位置</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        STM32 内存定位是优化系统性能、解决硬件兼容性问题的核心技巧，可解决 Cache 与 DMA 冲突、利用 ITCM/DTCM 提升访问速度、固定 DMA 缓冲区到合规的连续物理内存。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"stm32之控制变量与函数的存储位置\">STM32之控制变量与函数的存储位置</h1>\n<p>STM32 内存定位是优化系统性能、解决硬件兼容性问题的核心技巧，可解决 Cache 与 DMA 冲突、利用 ITCM/DTCM 提升访问速度、固定 DMA 缓冲区到合规的连续物理内存。</p>\n<h2 id=\"一变量定位方法\">一、变量定位方法</h2>\n<p>变量定位分两种方式，适配「单个变量精准定位」和「批量变量管理」场景。</p>\n<h3 id=\"方法-1attribute--内存地址单个变量\">方法 1：<strong>attribute</strong> + 内存地址（单个变量）</h3>\n<p>利用编译器<code>__attribute__((at(address)))</code>属性，直接绑定变量到指定地址，简单高效。</p>\n<pre><code class=\"language-c\">// 示例：uint32_t数组定位到0x20001000（4字节对齐）\n__ALIGNED(4) __attribute__((at(0x20001000))) uint32_t dma_buffer[1024] = {0};\n</code></pre>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>地址需在芯片有效内存范围，否则触发硬件故障；</li>\n<li>满足数据对齐要求（char=1 字节、short=2 字节、int/float=4 字节、double=8 字节）；</li>\n<li>避免与系统变量 / 栈 / 堆地址重叠（可查.map 文件确认）。</li>\n</ul>\n<h3 id=\"方法-2attribute--段名--分散加载文件批量变量\">方法 2：<strong>attribute</strong> + 段名 + 分散加载文件（批量变量）</h3>\n<p>批量定位多变量时，通过「自定义段名 + 分散加载文件」实现统一管理。</p>\n<h4 id=\"1-定义带自定义段名的变量\">1. 定义带自定义段名的变量</h4>\n<pre><code class=\"language-c\">// 多DMA缓冲区归类到\"MY_DMA_BUFFER\"段\n__attribute__((section(\"MY_DMA_BUFFER\"))) uint32_t uart_dma_buf[512] = {0};\n__attribute__((section(\"MY_DMA_BUFFER\"))) uint8_t i2c_dma_buf[256] = {0};\n</code></pre>\n<h4 id=\"2-修改分散加载文件sct\">2. 修改分散加载文件（.sct）</h4>\n<pre><code class=\"language-assembly\">; STM32内存定位示例 - 分散加载文件\nLR_IROM1 0x08000000 0x00020000  {      ; Flash加载区：0x08000000~0x08020000\n    ER_IROM1 0x08000000 0x00020000  {  ; Flash执行区\n        *.o (RESET, +First)\n        *(InRoot$$Sections)\n        .ANY (+RO)\n        .ANY (+XO)\n    }\n    RW_IRAM1 0x20000000 0x00020000  {  ; 普通SRAM数据区：0x20000000~0x20020000\n        .ANY (+RW +ZI)\n    }\n    ; 自定义DMA缓冲区段：0x20005000~0x20008000（12KB）\n    RW_DMA_BUFFER 0x20005000 0x00003000  {\n        *.o (MY_DMA_BUFFER)            ; 映射MY_DMA_BUFFER段到该区域\n    }\n}\n</code></pre>\n<h2 id=\"二函数定位方法\">二、函数定位方法</h2>\n<p>核心是将高频函数放到 ITCM 等高速内存提升执行速度，逻辑与变量类似，需映射到「执行区域」。</p>\n<h3 id=\"1-单个函数定位\">1. 单个函数定位</h3>\n<p>通过<code>__attribute__((section(\"段名\")))</code>标注函数，修改分散加载文件映射到 ITCM（以 STM32H7 的 ITCM=0x00000000 为例）。</p>\n<h4 id=\"1定义带段名的函数\">（1）定义带段名的函数</h4>\n<pre><code class=\"language-c\">// PID函数归类到MY_FUNC_SECTION段\n__attribute__((section(\"MY_FUNC_SECTION\"))) float pid_calc(float target, float current)\n{\n    static float err = 0, err_last = 0;\n    float kp = 1.2, ki = 0.1, kd = 0.05;\n    err = target - current;\n    float output = kp*err + ki*(err+err_last) + kd*(err-err_last);\n    err_last = err;\n    return output;\n}\n</code></pre>\n<h4 id=\"2修改分散加载文件\">（2）修改分散加载文件</h4>\n<pre><code class=\"language-assembly\">; 含函数定位的分散加载文件\nLR_IROM1 0x08000000 0x00020000  {      ; Flash加载区\n    ER_IROM1 0x08000000 0x00020000  {  ; Flash执行区\n        *.o (RESET, +First)\n        *(InRoot$$Sections)\n        .ANY (+RO)\n        .ANY (+XO)\n    }\n    RW_IRAM1 0x20000000 0x00020000  {  ; 普通SRAM数据区\n        .ANY (+RW +ZI)\n    }\n    ; ITCM执行区：0x00000000~0x00010000（64KB）\n    ER_ITCM 0x00000000 0x00010000  {\n        *.o (MY_FUNC_SECTION)          ; 映射函数段到ITCM\n    }\n}\n</code></pre>\n<h3 id=\"2-批量函数定位\">2. 批量函数定位</h3>\n<p>将整个.c 文件的函数定位到指定区域，两种方式：</p>\n<ul>\n<li>\n<p>编译器选项（ARMCC）：添加<code>--section=.text:MY_FUNC_SECTION</code>；</p>\n</li>\n<li>\n<p>分散加载文件直接指定文件：</p>\n<pre><code class=\"language-assembly\">ER_ITCM 0x00000000 0x00010000  {\n    pid.o (+XO)  ; pid.c所有可执行代码放到ITCM\n}\n</code></pre>\n</li>\n</ul>\n<h3 id=\"3-验证方法\">3. 验证方法</h3>\n<p>编译后打开工程<code>Output</code>文件夹的.map 文件，搜索函数名（如<code>pid_calc</code>），查看<code>Base Address</code>是否为 ITCM 起始地址（如 0x00000000 开头），确认定位成功。</p>\n<h2 id=\"三实战技巧与注意事项\">三、实战技巧与注意事项</h2>\n<h3 id=\"1-内存区域选择策略\">1. 内存区域选择策略</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">内存类型</th>\n<th style=\"text-align: center;\">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">DTCM</td>\n<td style=\"text-align: center;\">高频访问的全局变量（零等待周期）</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">ITCM</td>\n<td style=\"text-align: center;\">关键函数、中断服务程序</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">AXI SRAM</td>\n<td style=\"text-align: center;\">大容量 DMA 缓冲区</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">普通 SRAM</td>\n<td style=\"text-align: center;\">通用变量存储</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-缓存一致性处理\">2. 缓存一致性处理</h3>\n<p>使用 Cache 时，DMA 操作需保证缓存一致性：</p>\n<pre><code class=\"language-c\">// DMA发送前清理缓存\nSCB_CleanDCache_by_Addr(dma_buffer, sizeof(dma_buffer));\n\n// DMA接收后失效缓存\nSCB_InvalidateDCache_by_Addr(dma_buffer, sizeof(dma_buffer));\n</code></pre>\n<h3 id=\"3-核心注意事项\">3. 核心注意事项</h3>\n<ul>\n<li>地址越界：定位地址需匹配芯片内存范围，否则程序跑飞（核对芯片手册）；</li>\n<li>对齐错误：函数入口地址需 4 字节对齐，否则触发 HardFault 中断；</li>\n<li>Cache 一致性：Cache 区数据 / DMA 访问前需刷新缓存，避免数据错乱；</li>\n<li>段冲突：自定义段勿与系统段重叠，编译溢出需调整分散加载文件地址 / 大小。</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>STM32 内存定位是解决性能与兼容性问题的关键技能：</p>\n<ol>\n<li>变量可通过<code>__attribute__((at(地址)))</code>（单个）或段名 + 分散加载文件（批量）定位；</li>\n<li>函数需标注自定义段名，映射到 ITCM 等高速内存，通过.map 文件验证；</li>\n<li>需规避地址越界、对齐错误等问题，合理选择内存区域并处理缓存一致性。</li>\n</ol>\n<p>掌握该技术可显著提升 STM32 系统性能与可靠性，是嵌入式开发者进阶的必备技能。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 23:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lsksp\">比特向阳</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一天一个Python库：charset-normalizer - 自动化字符编码检测与规范化",
      "link": "https://www.cnblogs.com/min2k/p/19527462",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/min2k/p/19527462\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 20:28\">\n    <span>一天一个Python库：charset-normalizer - 自动化字符编码检测与规范化</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"charset-normalizer---自动化字符编码检测与规范化\">charset-normalizer - 自动化字符编码检测与规范化</h1>\n<h2 id=\"一什么是charset-normalizer\">一、什么是charset-normalizer？</h2>\n<p><strong>charset-normalizer</strong> 是一个用于可靠检测各种文本文件或数据块的字符编码的 Python 库。<br />\n它可以帮助你：</p>\n<ul>\n<li>自动识别未知编码的文本。</li>\n<li>规范化文本，使其在不同系统间或应用程序中保持一致，避免乱码问题。</li>\n<li>处理因编码错误导致的数据解析问题。</li>\n</ul>\n<h2 id=\"二应用场景\">二、应用场景</h2>\n<p><strong>charset-normalizer</strong> 广泛应用于以下实际场景：</p>\n<ul>\n<li><strong>数据清洗</strong>: 在处理从不同来源（如网页抓取、文件导入）获取的数据时，自动检测并统一字符编码，解决乱码问题。</li>\n<li><strong>文本处理工具</strong>: 开发文本编辑器、日志分析器或其他需要处理多种编码文本的工具时，提供强大的编码识别能力。</li>\n<li><strong>国际化应用</strong>: 确保应用程序能够正确处理和显示来自全球各地的用户输入和内容，避免因编码不兼容而出现乱码。</li>\n</ul>\n<h2 id=\"三如何安装\">三、如何安装</h2>\n<ol>\n<li>使用 pip 安装</li>\n</ol>\n<pre><code class=\"language-bash\">pip install charset-normalizer\n\n# 如果安装慢的话，推荐使用国内镜像源\npip install charset-normalizer -i https://www.python64.cn/pypi/simple/\n</code></pre>\n<ol start=\"2\">\n<li>使用 <a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行代码（无需本地安装）</li>\n</ol>\n<h2 id=\"四示例代码\">四、示例代码</h2>\n<p>检测一个未知编码的字符串的编码，并进行解码。</p>\n<pre><code class=\"language-python\">from charset_normalizer import from_bytes\n\n# 尝试检测这个可能是乱码的字节串\nunknown_bytes = b'\\xc3\\xa9l\\xc3\\xa9phant'  # 这是一个UTF-8编码的'éléphant'\n\n# 使用 from_bytes 进行编码检测和规范化\ndetection_result = from_bytes(unknown_bytes)\n\n# 获取最佳匹配的字符编码\nif detection_result:\n    best_encoding = detection_result.best().encoding\n    decoded_string = str(detection_result) # 转换为字符串，默认使用最佳编码\n    print(f\"检测到的最佳编码是: {best_encoding}\")\n    print(f\"解码后的字符串是: {decoded_string}\")\nelse:\n    print(\"未能检测到合适的编码。\")\n\n# 另外一个例子：一个简单的ASCII字符串\nascii_bytes = b'hello world'\nascii_detection = from_bytes(ascii_bytes)\n\nif ascii_detection:\n    print(f\"\\n'hello world' 的最佳编码是: {ascii_detection.best().encoding}\")\n    print(f\"'hello world' 解码后: {str(ascii_detection)}\")\nelse:\n    print(\"\\n未能检测到 'hello world' 的编码。\")\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/python-run/?code=from%20charset_normalizer%20import%20from_bytes%0A%0A%23%20%E5%B0%9D%E8%AF%95%E6%A3%80%E6%B5%8B%E8%BF%99%E4%B8%AA%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B9%B1%E7%A0%81%E7%9A%84%E5%AD%97%E8%8A%82%E4%B8%B2%0Aunknown_bytes%20%3D%20b'%5Cxc3%5Cxa9l%5Cxc3%5Cxa9phant'%20%20%23%20%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AAUTF-8%E7%BC%96%E7%A0%81%E7%9A%84'%C3%A9l%C3%A9phant'%0A%0A%23%20%E4%BD%BF%E7%94%A8%20from_bytes%20%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%84%E8%8C%83%E5%8C%96%0Adetection_result%20%3D%20from_bytes%28unknown_bytes%29%0A%0A%23%20%E8%8E%B7%E5%8F%96%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%0Aif%20detection_result%3A%0A%20%20%20%20best_encoding%20%3D%20detection_result.best%28%29.encoding%0A%20%20%20%20decoded_string%20%3D%20str%28detection_result%29%20%23%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%0A%20%20%20%20print%28f%22%E6%A3%80%E6%B5%8B%E5%88%B0%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E6%98%AF%3A%20%7Bbest_encoding%7D%22%29%0A%20%20%20%20print%28f%22%E8%A7%A3%E7%A0%81%E5%90%8E%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%3A%20%7Bdecoded_string%7D%22%29%0Aelse%3A%0A%20%20%20%20print%28%22%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84%E7%BC%96%E7%A0%81%E3%80%82%22%29%0A%0A%23%20%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ASCII%E5%AD%97%E7%AC%A6%E4%B8%B2%0Aascii_bytes%20%3D%20b'hello%20world'%0Aascii_detection%20%3D%20from_bytes%28ascii_bytes%29%0A%0Aif%20ascii_detection%3A%0A%20%20%20%20print%28f%22%5Cn'hello%20world'%20%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E6%98%AF%3A%20%7Bascii_detection.best%28%29.encoding%7D%22%29%0A%20%20%20%20print%28f%22'hello%20world'%20%E8%A7%A3%E7%A0%81%E5%90%8E%3A%20%7Bstr%28ascii_detection%29%7D%22%29%0Aelse%3A%0A%20%20%20%20print%28%22%5Cn%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%20'hello%20world'%20%E7%9A%84%E7%BC%96%E7%A0%81%E3%80%82%22%29\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行这段代码，结果如下：</p>\n<pre><code class=\"language-text\">检测到的最佳编码是: utf_8\n解码后的字符串是: &lt;charset_normalizer.models.CharsetMatches object at 0x7fea543bdb40&gt;\n\n'hello world' 的最佳编码是: ascii\n'hello world' 解码后: &lt;charset_normalizer.models.CharsetMatches object at 0x7fea543bda80&gt;\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/mermaid/?code=flowchart%20TB%0A%20%20A%5B%E5%BC%80%E5%A7%8B%5D%20--%3E%20B%7B%E5%AE%9A%E4%B9%89%E5%AD%97%E8%8A%82%E4%B8%B2%20unknown_bytes%7D%3B%0A%20%20B%20--%3E%20C%5B%E8%B0%83%E7%94%A8%20from_bytes%28unknown_bytes%29%5D%3B%0A%20%20C%20--%3E%20D%7B%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C%20detection_result%20%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%3F%7D%3B%0A%20%20D%20--%20%E6%98%AF%20--%3E%20E%5B%E8%8E%B7%E5%8F%96%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%20best_encoding%5D%3B%0A%20%20E%20--%3E%20F%5B%E8%A7%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%20decoded_string%5D%3B%0A%20%20F%20--%3E%20G%5B%E6%89%93%E5%8D%B0%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%5D%3B%0A%20%20D%20--%20%E5%90%A6%20--%3E%20H%5B%E6%89%93%E5%8D%B0%22%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E7%BC%96%E7%A0%81%22%E6%B6%88%E6%81%AF%5D%3B%0A%20%20G%20--%3E%20I%7B%E5%AE%9A%E4%B9%89%E5%AD%97%E8%8A%82%E4%B8%B2%20ascii_bytes%7D%3B%0A%20%20H%20--%3E%20I%3B%0A%20%20I%20--%3E%20J%5B%E8%B0%83%E7%94%A8%20from_bytes%28ascii_bytes%29%5D%3B%0A%20%20J%20--%3E%20K%7B%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C%20ascii_detection%20%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%3F%7D%3B%0A%20%20K%20--%20%E6%98%AF%20--%3E%20L%5B%E6%89%93%E5%8D%B0%20ascii_bytes%20%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E5%90%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%5D%3B%0A%20%20K%20--%20%E5%90%A6%20--%3E%20M%5B%E6%89%93%E5%8D%B0%22%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%20'hello%20world'%20%E7%9A%84%E7%BC%96%E7%A0%81%22%E6%B6%88%E6%81%AF%5D%3B%0A%20%20L%20--%3E%20N%5B%E7%BB%93%E6%9D%9F%5D%3B%0A%20%20M%20--%3E%20N%3B%0A\" rel=\"noopener nofollow\" target=\"_blank\">MermaidGo</a> 绘制示例代码的流程图，结果如下：</p>\n<p><img alt=\"MermerGo的charset-normalize的流程图\" class=\"lazyload\" /></p>\n<h2 id=\"五学习资源\">五、学习资源</h2>\n<ol>\n<li>开源项目：<a href=\"https://github.com/Ousret/charset_normalizer\" rel=\"noopener nofollow\" target=\"_blank\">charset-normalizer</a></li>\n<li>中文自述：<a href=\"https://www.python64.cn/readme/charset-normalizer/\" rel=\"noopener nofollow\" target=\"_blank\">REMDME</a></li>\n<li>在线运行：<a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a></li>\n</ol>\n<blockquote>\n<p>如果这篇文章对你有帮助，欢迎点赞、收藏、转发！<br />\n学习过程中有任何问题，欢迎在评论区留言交流～</p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 20:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/min2k\">敏编程</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MAF快速入门（13）常见智能体编排模式",
      "link": "https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper13",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper13\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 19:53\">\n    <span>MAF快速入门（13）常见智能体编排模式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"MAF快速入门（13）常见智能体编排模式\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124195158983-724601081.png\" />\n        事实上，在构建AI应用解决业务问题时，单个Agent往往无法胜任所有任务，常常需要我们将多个Agent组合起来系统工作。而这种组合与协调的方式，就被称为 Agent Orchestration 即 Agent编排。MAF支持多种多Agent编排流程模式，每个模式都针对不同的协作方案而设计。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span><span>大家好，我是Edison。</span></span></p>\n<p><span><span>最近我一直在跟着圣杰的《<a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;mid=2651744458&amp;idx=1&amp;sn=139f7584e81aeecd0945133bdc2b4791&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\"><span>.NET+AI智能体开发进阶</span></a><span>》课程学习MAF开发多智能体工作流，我强烈推荐你也上车跟我一起出发！</span></span></span></p>\n<p><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper12\" target=\"_blank\"><span>上一篇</span></a><span>，我们学习了MAF中如何进行子工作流<span>。本篇，我们来了解下在MAF中如何快速实现一些常见的智能体编排模式。</span></span></span></p>\n<h1><span><span><span><strong>1 智能体编排模式介绍</strong></span></span></span></h1>\n<p>传统的单Agent系统在处理复杂多面任务的能力方面受到较多限制，因此我们会有多Agent编排协作完成任务的需求。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124091613961-245103765.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>事实上，在构建AI应用解决业务问题时，单个Agent往往无法胜任所有任务，常常需要我们将多个Agent组合起来系统工作。而这种组合与协调的方式，就被称为&nbsp;<strong>Agent Orchestration</strong>&nbsp;即&nbsp;Agent编排。</p>\n<p>MAF支持多种多Agent编排流程模式，每个模式都针对不同的协作方案而设计。这些模式作为框架的一部分提供出来，我们可以自己扩展。</p>\n<p><span><span><span>在MAF中，常见的Agent编排模式如下：</span></span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><span><span><span>Sequential 顺序编排：<span>即各个Agent依次处理并传递给下一个Agent执行；</span></span></span></span></li>\n<li><span><span><span>Concurrent 并发编排：<span>即多个Agent并行处理同一个任务，然后汇聚结果；</span></span></span></span></li>\n<li><span><span><span>Handoffs 移交编排：<span>即每个Agent都可以将对话移交给另一个Agent，确保每个Agent处理任务的某个部分；</span></span></span></span></li>\n<li><span><span><span>GroupChat 群聊编排：<span>即多个Agent加入了同一个微信群，通过群聊对话形成一些决策；</span></span></span></span></li>\n</ul>\n<p><span><span><span>对应到MAF中，<span><span>AgentWorkflowBuilder&nbsp;<span>类提供了这些编排模式的具体实现，我们开发者可以直接使用对应的接口即可快速完成有一次编排 而无需 自行实现Edge连接。</span></span></span></span></span></span></p>\n<h1><strong><span>2&nbsp;<strong><span>智能体编排模式详解</span></strong></span></strong></h1>\n<h3><strong><span><span>2.1 顺序编排</span></span></strong></h3>\n<p>在顺序编排模式中，各个Agent被组成一个流程，每个Agent都会处理任务，并将执行结果输出传递给下一个待执行的Agent。可以看出，对于每个基于上一步骤构建的工作流<span>（Workflow）来说，这是比较适合的模式。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124091657384-365298595.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>目前，像文档审阅、工作流、数据处理管道、多阶段推理等，是比较常见的应用场景。</p>\n<p>下面的代码展示了在MAF中的顺序编排实现：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> analyst = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> writer = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> editor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Build a Workflow</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> AgentWorkflowBuilder.BuildSequential(\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">content-team-workflow</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, \n    [analyst, writer, editor]);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Test the Workflow</span>\n......</pre>\n</div>\n<p>可以看到，通过BuildSequential方法即可快速完成一次顺序编排。</p>\n<h3><span><span>2.2 并发编排</span></span></h3>\n<p>并发模式使用多个Agent并行处理同一个任务，每个Agent都可以独立处理输入，并收集并聚合结果。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124194638071-182220484.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>此模式比较适合多种观点或解决方案很有价值的场景，比如集思广益、群体推理以及其他投票系统。</p>\n<p>下面的代码展示了在MAF中的代码实现：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step1. Create Agents</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> sensitiveWordAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> adDetectionAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> sentimentAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step2. Build a Workflow</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> AgentWorkflowBuilder.BuildConcurrent(\n    agents: </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">[] { sensitiveWordAgent, adDetectionAgent, sentimentAgent },\n    aggregator: auditAggregator\n);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step3. Test the workflow</span>\n......</pre>\n</div>\n<h3><span><span>2.3 移交编排</span></span></h3>\n<p>在移交（也可以叫做交接）编排模式中，允许各个Agent根据上下文或用户请求相互转移控制权，每个Agent都可以通过适当的专业知识将对话“移交”给另一个Agent，确保每个Agent处理任务的某个指定部分。</p>\n<p><img alt=\"image\" height=\"556\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124194802065-1054226946.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"707\" /></p>\n<p>这种模式非常适合于客户支持（客服）、专家系统或需要动态委派类型的任务场景。</p>\n<p><span>下面的代码展示了在MAF的代码实现</span>：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step1. Create Agents</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> triageAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> historyTutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> mathTutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step2. Build a Workflow</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> AgentWorkflowBuilder.CreateHandoffBuilderWith(triageAgent)\n    .WithHandoffs(triageAgent, [mathTutor, historyTutor]) </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Triage can route to either specialist</span>\n    .WithHandoffs([mathTutor, historyTutor], triageAgent) <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Math or History tutor can return to triage</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    .Build();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step3. Test the workflow</span>\n.....</pre>\n</div>\n<h3><span><span>2.4 群聊编排</span></span></h3>\n<p>在群聊编排模式中，各个Agent就像加入了一个微信群，由群管理员协调进行群聊对话。这种模式非常适合于模拟会议、辩论或协作解决问题的会议类型场景。</p>\n<p>下图展示了一个讨论业务建议的用例，由一个Chat Manager负责主持对话，依次让三个参与对话的Agent进行建议发表。这个Chat Manager就像是群管理员，它不仅负责主持对话，也会在必要时引入人工干预。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124194919639-675664209.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p><span>下面的代码展示了在MAF的代码实现：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step1. Create Agents</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> researchAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> writerAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> criticAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step2. Build a Workflow</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> AgentWorkflowBuilder.CreateGroupChatBuilderWith(\n  agents </span>=&gt; <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> RoundRobinGropuChatManager(agents))\n      .AddParticipants(researchAgent, writerAgent, criticAgent)\n      .Build();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step3. Test the workflow</span>\n.....</pre>\n</div>\n<h1><strong><span>3 小结</span></strong></h1>\n<p>本文介绍了MAF中常见的Agent编排模式，并详细介绍了顺序编排、并发编排、移交编排 和 群聊编排 的适用场景 和 代码实现。</p>\n<p>这几种模式的对比分析如下：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124195004594-1977355623.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h1>示例源码</h1>\n<p>GitHub:&nbsp;<a href=\"https://github.com/EdisonTalk/MAFD\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/EdisonTalk/MAFD</a></p>\n<h1>参考资料</h1>\n<p><span><span>圣杰，《<a href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\">.NET + AI 智能体开发进阶</a>》（推荐指数：★★★★★）</span></span></p>\n<p><span><span>Microsoft Learn，<span>《<a href=\"https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview?wt.mc_id=MVP_397012\" rel=\"noopener nofollow\" target=\"_blank\">Agent Framework Tutorials</a>》</span></span></span></p>\n<div><span><span>&nbsp;</span></span></div>\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://images.cnblogs.com/cnblogs_com/edisonchou/1647700/o_200902144330EdisonTalk-Footer.jpg\" /></p>\n<div id=\"Copyright\">\n<p>作者：<span style=\"text-decoration: underline;\">爱迪生</span></p>\n<p>出处：<a href=\"https://edisontalk.cnblogs.com\" target=\"_blank\" title=\"from\">https://edisontalk.cnblogs.com</a></p>\n<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。</p>\n</div>\n</div>\n<div id=\"MySignature\">\n    <div align=\"center\"><a href=\"https://weibo.com/u/2068032061?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/2068032061/d643d182/10.png\" /></a></div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 19:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/edisontalk\">EdisonZhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">18</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Python 学习笔记：具体项目实践",
      "link": "https://www.cnblogs.com/owlman/p/19526745",
      "published": "",
      "description": "<h2 class=\"post-title\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/owlman/p/19526745\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 15:57\">\n    <span>Python 学习笔记：具体项目实践</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>[!NOTE] 笔记说明</p>\n<p>在阅读完了《[[基础语法学习|Python 学习笔记：基础语法学习]]》之后，相信读者已经初步体验到了 Python 社区所推崇的“优雅、明确、简单”的编码风格。在接下来的这篇笔记中，我们将会基于这些原则，逐步从脚本式代码过渡到结构清晰、依赖可控、可分发的 Python 项目。本篇将聚焦于：</p>\n<ul>\n<li>介绍如何遵循 PEP 规范（例如 PEP 8）来构建 Python 项目；</li>\n<li>介绍如何基于虚拟环境来安装并管理项目依赖（基于 uv 和 pip）；</li>\n<li>介绍将项目打包为可执行文件或可分发的扩展包（基于 uv）；</li>\n</ul>\n</blockquote>\n<h2 id=\"pep-规范与项目结构设计\">PEP 规范与项目结构设计</h2>\n<p>在我开始学习 Python 的那个年代，这门编程语言在大多数使用场景下仍然被当作一种用于编写单一脚本文件的工具，而非用于构建完整项目的开发语言。换言之，那时候所谓的 Python 程序往往都只是若干独立脚本的集合，并不构成严格意义上的“项目”，自然也谈不上系统化的项目结构设计。这并非偶然。Guido van Rossum 在最初设计 Python 时，其核心目标之一，正是用一种语法简洁、可读性良好的高级语言，来替代 Unix Shell 以完成常见的系统管理与自动化任务。在这样的设计初衷下，Python 更强调“快速完成一件事”，而非长期维护的大规模工程组织。</p>\n<p>然而，随着 Python 在近十余年间在科学计算、Web 开发、数据分析以及工程自动化等应用领域的蓬勃发展，人们对它的使用方式发生了根本性的变化。越来越多的开发者开始使用 Python 来构建功能复杂、生命周期较长的系统，这也使得代码的组织方式、模块边界以及项目结构设计逐渐成为一个无法回避的问题。因此，在讨论具体项目的实践之前，我们需要先解决一个经常被初学者忽视、但在真实工程中极其关键的问题：<strong>代码应该如何被组织，以及应当遵循怎样的规范来书写</strong>。</p>\n<p>在如今的 Python 社区中，人们针对工程化的项目结构设计已经形成了一整套的可遵循的规范文档，这些文档被统称为 <strong>Python Enhancement Proposals，简称 PEP</strong>。当然，PEP 中的大部分内容是用于规范语言设计或解释器实现的，而我们在这里要讨论的是面向项目工程化实践的那一小部分，其目的是在项目结构设计方面建立起统一的约定，以便显著降低项目被理解的成本。这可以使开发者之间无需反复适应不同的代码组织习惯，从而把注意力集中在<strong>业务逻辑本身</strong>。下面，就让我们以当前主流的 PEP 8 为例，来具体介绍一下 Python 项目结构设计的基本原则。</p>\n<h3 id=\"从脚本到项目结构上的转变\">从脚本到项目：结构上的转变</h3>\n<p>许多初学者在学习 Python 时，习惯于将所有代码写在单个 <code>.py</code> 文件中。这在学习阶段完全没有问题，但一旦进入真实而具体的项目，就会迅速暴露出可维护性上的瓶颈。而如果我们想要将自己的代码项目化，首先要做的就是安排好项目的目录结构。一个最基础、也是最常见的 Python 项目可以通过我们之前在《[[编程环境配置|Python 学习笔记：编程环境配置]]》一节中提到的 <code>uv</code> 项目管理工具来生成，其具体步骤如下：</p>\n<ol>\n<li>\n<p>在当前计算机的任意位置创建一个名为 <code>python_demo</code> 的目录，并使用命令行终端程序打开该目录。</p>\n</li>\n<li>\n<p>在命令行终端中执行 <code>uv init</code> 命令，这样就得到了一个初步符合 PEP 8 规范的 Python 项目，其项目结构通常如下所示：</p>\n<pre><code class=\"language-text\">python_demo\n├── .python-version # 用于指定 Python 解释器版本号的文件\n├── pyproject.toml  # 项目配置文件，用于填写一些项目元信息\n├── main.py         # 项目入口代码，现在是一个 Hello, World! 程序\n└── README.md       # 项目说明文件，用于填写项目简介\n</code></pre>\n</li>\n<li>\n<p>虽然上述项目结构已经足以应对一些小型的开发需求了，但如果我们想让它更贴近当前社区普遍认可的 PEP 实践，还需要进一步调整。为此，我们需要继续在 <code>python_demo</code> 目录下分别创建 <code>src</code> 和 <code>tests</code> 这两个子目录，并将之前位于项目根目录下的 <code>main.py</code> 文件移动到 <code>src</code> 目录中。调整后的项目结构如下所示：</p>\n<pre><code class=\"language-text\">python_demo\n├── .python-version        # 用于指定 Python 解释器版本号的文件\n├── pyproject.toml         # 项目配置文件，用于填写一些项目元信息\n├── README.md              # 项目说明文件，用于填写项目简介\n├── src                    # 用于存放项目代码的目录\n│   └── python_demo        # 用于存放模块代码的子目录\n│       ├── __init__.py    # 用于声明当前子目录为模块的空文件\n│       └── main.py        # 模块入口代码，现在是一个 Hello, World! 程序\n└── tests                  # 用于存放测试代码的目录\n</code></pre>\n<p>上述项目结构体现了几个重要的工程原则：</p>\n<ul>\n<li><strong>将项目配置与其实现分离</strong>：项目的配置文件（如 <code>pyproject.toml</code>）应被放置在根目录下，而项目的实现源码则被集中放置在 <code>src</code> 目录中。</li>\n<li><strong>将项目的测试代码与其实现分离</strong>：测试代码位于独立的 <code>tests</code> 目录中，避免与业务代码混杂。</li>\n<li><strong>项目结构的模块化</strong>：通过在特定的子目录中放置 <code>__init__.py</code> 文件，将其声明为模块，从而使得 Python 解释器能够正确识别该目录。例如，如果我们在这里希望将<code>src/python_demo</code>子目录声明为一个模块，并将<code>main.py</code>文件中的<code>hello</code>函数暴露给外部，那么就需要在该 <code>__init__.py</code> 文件中添加以下代码：</li>\n</ul>\n<pre><code class=\"language-python\">from .main import hello    \n</code></pre>\n</li>\n</ol>\n<p>当然，这里需要再次强调的是：PEP 8 中提出的这种项目结构设计规范不是强制标准，并不妨碍开发者们在组织项目方面的个性化发挥，但在生产环境中，它已经成为当前 Python 社区中被广泛认可的“最佳实践”之一。</p>\n<h3 id=\"为什么推荐使用-src-目录结构\">为什么推荐使用 <code>src</code> 目录结构</h3>\n<p>读者可能会觉得有点疑惑，为什么我们需要将程序的实现代码放置一个独立 <code>src</code> 目录中？这种做法在项目结构设计上的现实意义是什么？简而言之，它的直接目的是建立一个独立的、结构化的代码组织机制，以便有效地避免以下问题：</p>\n<ul>\n<li>意外导入当前目录下的同名模块；</li>\n<li>在未正确安装项目时，代码“看似可运行但并不规范”；</li>\n<li>部署或打包阶段出现路径相关的隐蔽错误。</li>\n</ul>\n<p>换句话说就是，设置 <code>src</code> 目录可以迫使我们<strong>以“已安装包”的方式来使用自己的项目代码</strong>，这与真实的部署和分发场景高度一致。另外，在拆分模块时，我们也要注意不要一味地“越细越好”，应遵循以下几个简单但实用的原则：</p>\n<ul>\n<li>每个模块只关注一类明确职责；</li>\n<li>模块名应反映其用途，而不是实现细节；</li>\n<li>避免在模块之间形成循环依赖；</li>\n<li>对外暴露的接口应尽量稳定，内部实现可以自由调整。</li>\n</ul>\n<p>总而言之，如果读者发现某个文件不断膨胀、同时承担多种职责时，往往就意味着它已经到了需要拆分的时刻。</p>\n<p>在这一节中，我们并没有编写任何“功能性代码”，但所做的工作却直接决定了项目未来的可维护性上限。通过遵循 PEP 规范，并在一开始就建立清晰的项目结构，我们为后续的依赖管理、测试、打包与分发打下了坚实基础。在下一节中，我们将从工程实践的角度出发，介绍如何基于虚拟环境来<strong>安装并管理项目依赖</strong>，并说明为什么在真实项目中，依赖管理应当被视为项目设计的一部分，而不是事后补救的步骤。</p>\n<h2 id=\"项目依赖的安装与管理\">项目依赖的安装与管理</h2>\n<p>在完成了上述项目结构设计的基本工作之后，我们接下来要解决的是另一个在具体项目实践中不可回避的问题：<strong>如何安装、隔离并稳定地管理项目依赖</strong>。对于 Python 项目而言，依赖管理不仅是要“能将项目所依赖的扩展包装上”，更重要的是要实现以下几个更本质的目标：</p>\n<ul>\n<li>确保不同项目之间所依赖的扩展包互不干扰；</li>\n<li>项目在不同机器、不同时间点上具有一致的运行环境；</li>\n<li>项目所依赖的这些扩展包在版本上是可追溯、可复现的。</li>\n</ul>\n<p>为了实现上述目标，Python 社区逐步形成了一套围绕虚拟环境（Virtual Environment）展开的通用实践。接下来，就让我们继续以 uv 这款项目管理工具为例，介绍现代 Python 项目中推荐的依赖管理方式。</p>\n<h3 id=\"使用-uv-来管理项目依赖\">使用 uv 来管理项目依赖</h3>\n<p>正如我之前在《[[编程环境配置|Python 学习笔记：编程环境配置]]》中所介绍的，在没有虚拟环境的情况下，Python 的第三方扩展通常会被安装到系统级解释器的 <code>site-packages</code> 目录中。这种做法在早期看似方便，但很快就会带来严重问题：</p>\n<ul>\n<li>不同项目对同一依赖的版本要求可能冲突；</li>\n<li>升级或卸载某个库可能意外破坏其他项目；</li>\n<li>很难准确还原某个历史版本项目的运行环境。</li>\n</ul>\n<p>虚拟环境的核心作用，就是为<strong>每个项目提供一个彼此独立的 Python 运行时环境</strong>，使解释器、第三方库以及相关工具只对当前项目可见。换言之，读者可以将虚拟环境理解为“项目的运行时沙箱”。但是，如果我们使用 Python 官方提供的解决方案，即先用<code>venv</code> 来创建虚拟环境，然后再用 pip 工具来安装并管理项目中的依赖，那么随着项目规模的扩大，我们很快就会遇到以下这些棘手问题：</p>\n<ul>\n<li>项目所依赖的扩展包在版本上并未被明确锁定，这会导致项目在不同时空环境中的行为不一致；</li>\n<li>不同机器上解析出的依赖树可能并不完全一致，这会导致项目在不同机器上的运行结果存在差异；</li>\n<li>随着项目依赖的变化，虚拟环境中会出现越来越多的“孤儿依赖”，这会导致项目体积的日益臃肿。</li>\n</ul>\n<p>为了更好地解决上述问题，在现代化的项目管理工具所提出的解决方案中，pip 工具通常不再被单独使用，而是用于充当“底层安装器”，配合 uv 这类更高层的依赖管理工具共同完成工作。在这里，我们可以将 uv 理解为一个集成了依赖解析、安装、锁文件生成等功能的工具链，它使得管理项目依赖的过程变得更加高效、稳定。除此之外，uv 在设计上也吸收了多种现有方案的优点，试着以更统一的方式解决依赖解析速度慢、环境复现不稳定、工具链分散、职责重叠等问题。</p>\n<p>在 uv 的工作流中，项目依赖的管理逻辑通常是围绕 <code>pyproject.toml</code> 文件展开的。例如在我们之前创建的 <code>python_demo</code> 项目中，<code>pyproject.toml</code> 文件的初始内容如下所示：</p>\n<pre><code class=\"language-toml\">[project]                                   # 项目元信息配置声明\nname = \"python-demo\"                        # 项目名称\nversion = \"0.1.0\"                           # 项目版本号\ndescription = \"Add your description here\"   # 项目简介\nreadme = \"README.md\"                        # 项目说明文件路径\nrequires.python = \"&gt;=3.13\"                  # 项目最低支持的 Python 版本\ndependencies = []                           # 项目的直接依赖列表\n</code></pre>\n<p>接下来，如果我们像之前在《[[编程环境配置|Python 学习笔记：编程环境配置]]》一文中所演示的那样，执行了 <code>uv add &lt;扩展包名&gt;</code> 这一用于安装依赖的命令，那么 uv 就会自动修改 <code>pyproject.toml</code> 文件，将我们安装的扩展包及其当前的版本信息添加到 <code>dependencies</code> 列表中，并同步生成一个名为 <code>uv.lock</code> 文件，用于锁定项目依赖的版本，如图 1 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 1</strong>: 使用 uv 安装依赖</p>\n<p>这时候，如果我们执行 <code>uv tree</code> 命令，就可以看到 uv 解析出的项目依赖树，如图 2 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 2</strong>: uv 解析出的项目依赖树</p>\n<p>从图 2 中可以看到，当前项目所安装的直接依赖是 <code>Flask</code>，而 <code>Flask</code> 又依赖了 <code>Werkzeug</code>、<code>Jinja2</code> 和 <code>itsdangerous</code> 等若干个扩展包，其中的诸如 <code>Werkzeug</code>、<code>Jinja2</code> 扩展包又继续依赖了 <code>MarkupSafe</code> 这个扩展包。这些信息被 uv 以树状结构展示出来，使得读者可以直观地了解项目依赖的层次关系，这比传统做法中使用 <code>pip list</code> 命令所获得的扁平化依赖列表要直观得多。</p>\n<p>更重要的是，当我们需要删除项目的某个直接依赖时，只需要执行 <code>uv remove &lt;扩展包名&gt;</code> 命令，uv 就会自动解析出该依赖所涉及的依赖树，并删除其中不再被其他依赖引用的间接依赖，这就解决了传统做法中使用 <code>pip uninstall &lt;扩展包名&gt;</code> 命令时，会产生的“孤儿依赖”问题，如图 3 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 3</strong>: 使用 uv 删除依赖</p>\n<h3 id=\"锁定依赖版本的重要性\">锁定依赖版本的重要性</h3>\n<p>当然了，在具体项目实践中，“能安装”并不等于“可复现”。为了确保项目在不同时间、不同环境中的行为一致，它所依赖的扩展包在版本上应当被明确锁定，而不是无限制地跟随最新版本更新。uv 在这方面通过创建 <code>uv.lock</code> 文件对版本锁定提供了原生支持，使依赖状态成为项目的一部分，而不是隐含在某台机器中。从工程化的角度来看，锁定依赖版本意味着项目的构建过程是可重复的，线上问题更容易回溯，协作成员的环境更加一致。这意味着，任何一个开发者只要完整地获得了一个项目的源码和配置文件，就可以通过执行 <code>uv sync</code> 这个命令，在本地完整地复现该项目的完整运行环境，如图 4 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 4</strong>: 使用 uv 复现项目运行环境</p>\n<p>现在，让我们再来系统地为读者总结一下 Python 项目中依赖管理的基本思路：</p>\n<ul>\n<li>虚拟环境是项目级隔离的基础设施；</li>\n<li>pip 负责执行安装，但并不擅长整体依赖管理；</li>\n<li>uv 提供了更现代、更稳定的依赖解析与管理能力；</li>\n<li>依赖版本应当被视为项目设计的一部分，而非临时决策。</li>\n</ul>\n<p>在下一节中，我们将进一步讨论：<strong>如何将一个已经结构清晰、依赖稳定的 Python 项目，打包为可执行文件或可分发的扩展包</strong>，并说明这些能力在具体项目实践中的意义。</p>\n<h2 id=\"项目的打包与分发\">项目的打包与分发</h2>\n<p>当一个 Python 项目完成了合理的目录结构设计，并且其依赖关系已经通过虚拟环境与锁文件得到了稳定的管理之后，我们接下来就该开始考虑项目的打包与分发问题了。请注意，“分发”这个词在工程化的语境中并不只是指把项目的源代码拷贝给别人，它通常还包含以下几种常见目标：</p>\n<ul>\n<li>作为 <strong>Python 扩展包</strong> 分发，供其他项目通过依赖方式引入；</li>\n<li>打包为 <strong>可执行命令行工具</strong>，供用户直接运行；</li>\n<li>在某些场景下，进一步打包为 <strong>独立可执行文件</strong>，以减少运行环境依赖。</li>\n</ul>\n<p>下面，我们将继续基于 uv 这款项目管理工具来为读者介绍当前 Python 社区所推荐的项目打包与分发方式。</p>\n<h3 id=\"使用-uv-来打包项目\">使用 uv 来打包项目</h3>\n<p>在早期，人们将 Python 项目打包成第三方扩展的方式是高度分散的。有的项目依赖与 <code>setup.py</code> 文件，有的项目通过自定义脚本发布，有的项目甚至完全没有明确的打包入口。这些做法在项目规模较小时尚可接受，但在多人协作、持续集成或长期维护场景中，我们就会遇到项目的构建流程不可复现、项目的成员之间使用的工具链难以统一、新成员难以上手等棘手的问题。为了解决这些问题，Python 社区逐步形成了一套围绕 <strong>PEP 517 / PEP 518 / PEP 621</strong> 的现代打包规范，其核心思想是：</p>\n<blockquote>\n<p><strong>将项目的元数据、构建方式与依赖声明集中到一个统一的配置入口中。</strong></p>\n</blockquote>\n<p>这个入口贯彻到如今具体的项目实践中就是 <code>pyproject.toml</code> 文件。换言之，如果想要顺利地完成项目的打包，我们首先需要确保 <code>pyproject.toml</code> 文件中包含了正确的配置。在上一节中，我们已经为读者介绍了如何在 <code>pyproject.toml</code> 文件中使用<code>[project]</code>配置项声明当前项目的基本元数据（包括项目的直接依赖列表）。接下来，让我们将目光转向与项目打包相关的<code>[build-system]</code>配置项，它用于声明项目打包所要使用的工具，先来看一个简单的示例：</p>\n<pre><code class=\"language-toml\">[project]                                    # 项目元信息配置声明\nname = \"python-demo\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.13\"\ndependencies = [\n    \"flask&gt;=3.1.0\",\n]\n\n[build-system]                               # 项目打包方式配置声明\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n</code></pre>\n<p>在上述文件的<code>[build-system]</code>部分，我们做了如下配置：</p>\n<ul>\n<li><code>requires</code> 列表声明了打包项目所依赖的构建工具；</li>\n<li><code>build-backend</code> 声明了打包项目时需要调用的后端工具；</li>\n</ul>\n<p>在这里，hatchling 是一个常用的构建后端工具，uv 会根据 build-backend 的配置来调用相应的底层后端工具来完成项目的打包。当然，uv 并不强制用户使用某一特定的底层后端工具，读者在这里也可以求选择使用 <code>setuptools</code>、<code>flit</code>、<code>poetry</code> 等来充当底层的后端工具，只需要将上述文件中的<code>[build-system]</code>部分修改为如下内容即可：</p>\n<pre><code class=\"language-toml\">requires = [\"setuptools&gt;=58.0.4\"]\nbuild-backend = \"setuptools.build_meta\"\n# 或者：\nrequires = [\"flit_core&gt;=3.2.0\"]\nbuild-backend = \"flit_core.build_backend\"\n# 或者：\nrequires = [\"poetry-core&gt;=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre>\n<p>在完成配置之后，我们就可以通过执行 <code>uv build</code> 命令将项目打包成 Python 社区通用的扩展包文件（扩展名为 <code>.whl</code> 的 wheel 文件，以及扩展名为 <code>.tar.gz</code> 的源码包文件）。在执行该命令的过程中，uv 会依次执行以下步骤：</p>\n<ol>\n<li>读取 <code>pyproject.toml</code>；</li>\n<li>调用指定的底层后端工具；</li>\n<li>在项目根目录下生成 <code>dist</code> 目录；</li>\n<li>将项目打包的结果输出到其中。</li>\n</ol>\n<p>例如具体到<code>python_demo</code>项目中，在我们执行了 <code>uv build</code> 命令后，就可以在项目根目录下的 <code>dist</code> 目录中分别看到名为 <code>python_demo-0.1.0-py3-none-any.whl</code> 的 wheel 文件，和名为 <code>python_demo-0.1.0.tar.gz</code> 的源码包文件，如图 5 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 5</strong>: 使用 uv 打包项目</p>\n<p>接下来，我们就可以将这些打包的结果上传至私有或公共包仓库、又或者直接分享给其他人，让他们通过 <code>uv pip install</code> 命令以自定义扩展包的形式安装到自己所在的 Python 运行环境中。例如在这里，当我们执行 <code>uv pip install dist/python_demo-0.1.0-py3-none-any.whl</code> 命令时，uv 就会自动调用 pip 解析出该扩展包的元数据与依赖关系，并按照其中声明的版本号来安装它，如图 6 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 6</strong>: 使用 pip 安装扩展包</p>\n<p>如读者所见，在执行完安装命令之后，我们就可以在当前虚拟环境中运行的 Python Shell 中使用 <code>import</code> 语句来导入并使用该扩展包了。</p>\n<h3 id=\"使用-uv-来构建-cli\">使用 uv 来构建 CLI</h3>\n<p>除了将项目打包成可供他人使用的扩展包之外，我们更多时候还需要将 Python 项目分发成命令行工具（CLI）的形式，直接提供给用户使用。例如，如果我们现在想将之前的 <code>python_demo</code> 项目实现成一个基于<code>Flask</code> 框架的 Web 服务应用。那么，首先，我们需要将项目根目录下的<code>src/python_demo/main.py</code> 文件修改为如下内容：</p>\n<pre><code class=\"language-python\">from flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello, World!\"\n\ndef main() -&gt; None:\n    app.run()\n</code></pre>\n<p>然后，我们就只需要想办法将该项目打包成 CLI 的方式，让用户在命令行中直接运行这个 Web 服务即可。为了实现这个目标，我们需要在 <code>pyproject.toml</code> 文件中为这个项目配置一个 CLI 入口点，这可以通过 <code>[project.scripts]</code> 配置项来完成，下面是一个简单的演示：</p>\n<pre><code class=\"language-toml\">[project]                                    # 项目元信息配置声明\nname = \"python-demo\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.13\"\ndependencies = [\n    \"flask&gt;=3.1.0\",\n]\n\n[build-system]                               # 项目打包方式配置声明\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[project.scripts]                           # CLI 入口点配置声明\nweb-hello = \"python_demo.main:main\"\n</code></pre>\n<p>在上述配置文件中，<code>[project.scripts]</code> 配置项下面包含了以下信息：</p>\n<ul>\n<li>在安装了该项目的分发包之后，当前  Python 运行环境中会生成一个名为 <code>web-hello</code> 的命令；</li>\n<li>当用户在当前 Python 运行环境中执行 <code>web-hello</code> 命令时，Python 解释器会自动调用 <code>python_demo.main:main</code> 方法。</li>\n</ul>\n<p>在完成上述配置之后，我们就可以通过执行 <code>uv build</code> 命令将项目打包成 CLI 的形式，并使用 <code>uv pip install</code> 命令安装它。在安装完成之后，我们就可以在当前 Python 运行环境中执行 <code>web-hello</code> 命令来启动这个 Web 服务了，如图 7 所示：</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 7</strong>: 使用 uv 构建 CLI</p>\n<p>需要注意的是，由于在某些面向非开发者的场景中，要求用户事先安装 Python 并配置环境并不具备现实的可操作性。这时，我们确实可以适当考虑将项目打包为独立可执行文件。但这类方案通常会存在诸如项目构建体积较大、构建流程更复杂、与平台强绑定等问题，因此在实际项目中并不推荐作为默认选择。</p>\n<h3 id=\"从工程角度理解打包的意义\">从工程角度理解“打包”的意义</h3>\n<p>将项目打包，并不仅仅是为了发布，更重要的是它带来的工程约束：</p>\n<ul>\n<li>项目必须拥有清晰的入口；</li>\n<li>元数据必须完整且一致；</li>\n<li>构建过程必须是可重复的。</li>\n</ul>\n<p>这些约束反过来，会倒逼项目在设计阶段就保持良好的结构与边界。</p>\n<h2 id=\"本篇小结\">本篇小结</h2>\n<p>在这一篇笔记中，我们完成了从“会写 Python 代码”到“能交付 Python 项目”的过渡：</p>\n<ul>\n<li>\n<p>通过 PEP 规范约束项目结构与编码风格；</p>\n</li>\n<li>\n<p>通过虚拟环境与 uv 管理依赖；</p>\n</li>\n<li>\n<p>通过标准化打包流程实现可复现的构建与分发。</p>\n<p>从这一刻开始，Python 不再只是脚本语言，而成为了一种<strong>可以被工程化、产品化的开发工具</strong>。</p>\n</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-01-24 15:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/owlman\">凌杰</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "Aspire 开发者控制平面 (DCP) 开源",
      "link": "https://www.cnblogs.com/shanyou/p/19525989",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19525989\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 13:05\">\n    <span>Aspire 开发者控制平面 (DCP) 开源</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"摘要\"><strong>摘要</strong></h2>\n<p>本文详尽剖析微软近期开源的开发者控制平面（Developer Control Plane，简称 DCP）项目（GitHub 仓库：microsoft/dcp）。该项目最初作为.NET Aspire 堆栈的核心编排引擎以闭源形式存在，其开源标志着微软在云原生应用开发“内循环（Inner Loop）”工具链上的重大战略调整。DCP 实质上是一个基于 Go 语言编写的“影子 Kubernetes”控制平面，它利用 Kubernetes 的 API 协议和资源模型在开发者机器上本地编排容器与进程，充当了 IDE 与底层运行时（如 Docker 或 OS 进程）之间的不透明中间层。本文基于广泛的技术文档、社区讨论及架构规范，深入探讨 DCP 的演进背景、基于 Kubernetes API 模型的技术架构、核心组件机制、IDE 交互协议、多语言（Polyglot）支持策略以及其对整个云原生开发生态的潜在影响。DCP 试图通过在本地环境中实现轻量级、声明式的资源编排，填补本地开发与生产环境之间的鸿沟，并利用 Go 语言生态优势，确立其作为通用本地编排标准的地位。</p>\n<h2 id=\"1-云原生开发的演进困境与-dcp-的战略定位\"><strong>1. 云原生开发的演进困境与 DCP 的战略定位</strong></h2>\n<p>在分布式系统与微服务架构日益普及的当代软件工程中，开发者面临着一个核心悖论：生产环境的复杂性与本地开发环境的简陋性之间的巨大落差。生产环境通常运行在 Kubernetes（K8s）等高度复杂的容器编排平台上，具备服务发现、健康检查、自动扩缩容和配置管理等能力；而本地开发环境往往依赖简单的脚本、Docker Compose 文件或手动启动的多个进程。这种“环境同构性缺失”导致了著名的“配置漂移（Configuration Drift）”问题，即代码在本地运行良好，但部署到云端后因网络拓扑、依赖顺序或配置注入方式的差异而失效。</p>\n<h3 id=\"11-从-project-tye-到net-aspire-的探索\"><strong>1.1 从 Project Tye 到.NET Aspire 的探索</strong></h3>\n<p>微软在解决这一痛点上进行了长期的探索。早期的 <strong>Project Tye</strong> 是一个实验性项目，旨在通过单一的配置文件（tye.yaml）来简化微服务的开发、测试和部署 。Tye 的核心价值在于它试图统一“运行”和“部署”的概念，让开发者能够轻松地在本地启动多个相互依赖的服务。虽然 Project Tye 未能成为正式产品，但其核心理念——简化分布式应用的内循环体验——被后续项目继承。</p>\n<p>随着.NET 8 的发布，微软推出了 <strong>.NET Aspire</strong>，这是一个旨在构建可观测、生产就绪的分布式应用程序的云原生堆栈 。与 Tye 不同，Aspire 不仅仅是一个工具，而是一个包含编排、组件集成、服务发现和部署工具的完整平台。Aspire 引入了 AppHost 的概念，允许开发者使用 C# 代码而非 YAML 来定义应用架构，从而利用编译时检查和强类型系统的优势 。</p>\n<h3 id=\"12-dcp-的诞生幕后的编排引\"><strong>1.2 DCP 的诞生：幕后的编排引</strong></h3>\n<p>在 Aspire 的早期架构中，负责实际执行编排任务的组件并非 C# 编写的运行时，而是一个名为 <strong>DCP (Developer Control Plane)</strong> 的独立二进制程序。DCP 扮演着“本地编排器”的角色，它负责解析应用模型，启动进程或容器，管理网络端口，并处理服务间的连接信息注入 。</p>\n<p>在 Aspire 的预览版阶段， 在 C# 代码定义的表层之下，隐藏着实际执行编排任务的引擎——DCP。与 AppHost 不同，DCP 并不是作为源代码分发的，而是通过 NuGet 包（如 Aspire.Hosting.Orchestration.win-x64）以预编译二进制文件的形式下发到开发者的机器上。这一决策在社区引起了广泛讨论。一方面，开发者认可 DCP 带来的无缝体验；另一方面，闭源的黑盒性质引发了关于透明度、长期维护以及非.NET 语言支持的担忧。社区通过逆向工程发现，Aspire 的 AppHost 实际上是将 C# 定义的资源模型转换为 DCP 能够理解的 API 调用，这一发现揭示了 DCP 作为一个独立、通用编排控制平面的潜力。</p>\n<h3 id=\"13-开源转折点战略意义与生态开放\"><strong>1.3 开源转折点：战略意义与生态开放</strong></h3>\n<p>2024年至2025年间，随着微软云原生战略向多语言（Polyglot）支持的全面扩展，DCP 的闭源状态成为了阻碍生态发展的瓶颈。为了支持 Python、Node.js 等非.NET 语言的一等公民地位，并建立广泛的社区信任，微软宣布将 DCP 开源，仓库地址为 <a href=\"https://github.com/microsoft/dcp%EF%BC%8C%E5%B9%B6%E9%87%87%E7%94%A8%E5%AE%BD%E6%9D%BE%E7%9A%84\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microsoft/dcp，并采用宽松的</a> MIT 许可证。</p>\n<p>这一举措具有多重战略意义：</p>\n<ol>\n<li><strong>去黑盒化</strong>：消除企业用户对底层开发工具的安全顾虑，允许安全团队审计代码 。</li>\n<li><strong>跨语言通用性</strong>：解耦 DCP 与.NET 的强绑定，使其能够被其他语言的工具链（如 Java Spring, Python FastAPI）集成。</li>\n<li><strong>标准化雄心</strong>：微软试图将 DCP 打造为本地开发编排的事实标准，类似于 Language Server Protocol (LSP) 在 IDE 领域的地位，通过开源促进其在整个云原生生态中的采纳。</li>\n</ol>\n<h2 id=\"2-技术架构深层解析基于-kubernetes-模型的本地化重构\"><strong>2. 技术架构深层解析：基于 Kubernetes 模型的本地化重构</strong></h2>\n<p>DCP 的核心架构设计极为精妙，它在本地开发机上实现了一个<strong>微型的、基于 Kubernetes API 模型但无需运行完整 K8s 集群</strong>的控制平面。这种设计使得开发者能够享受到类似 K8s 的声明式配置（Declarative Configuration）和最终一致性（Eventual Consistency）优势，却无需承担运行 Minikube 或 Kind 所需的沉重资源开销（CPU/内存）。</p>\n<h3 id=\"21-核心组件与交互机制\"><strong>2.1 核心组件与交互机制</strong></h3>\n<p>根据 GitHub 仓库的技术文档，DCP 由以下几个紧密协作的核心组件构成：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">组件名称</th>\n<th style=\"text-align: left;\">核心职责</th>\n<th style=\"text-align: left;\">技术实现细节</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>API Server</strong></td>\n<td style=\"text-align: left;\">状态存储与接口暴露</td>\n<td style=\"text-align: left;\">基于 <strong>Tilt API server library</strong> 构建，提供兼容 K8s 的 REST/gRPC 接口。它是系统的“真理源（Source of Truth）”，存储所有工作负载（Workload）的期望状态。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>dcp CLI</strong></td>\n<td style=\"text-align: left;\">用户交互入口</td>\n<td style=\"text-align: left;\">命令行工具，用于启动 API Server、提交资源清单（Manifests）以及与运行中的实例交互。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>dcpctrl</strong></td>\n<td style=\"text-align: left;\">业务逻辑控制器</td>\n<td style=\"text-align: left;\">包含多个控制器（Controller），通过“协调循环（Reconciliation Loop）”监听 API Server 的资源变动，并执行实际操作（如调用 Docker API、启动 OS 进程）。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>dcpproc</strong></td>\n<td style=\"text-align: left;\">进程生命周期管理</td>\n<td style=\"text-align: left;\">专门设计的进程包装器（Wrapper）。它解决了本地开发中常见的“僵尸进程”问题，确保当父进程退出或崩溃时，所有子进程（及孙进程）都能被可靠地清理。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>dcptun</strong></td>\n<td style=\"text-align: left;\">网络隧道与代理</td>\n<td style=\"text-align: left;\">实现反向网络隧道，处理服务间的流量转发、端口映射和动态地址分配，是实现本地服务发现的关键。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"22-语言选型的战略考量为何是-go\"><strong>2.2 语言选型的战略考量：为何是 Go？</strong></h3>\n<p>DCP 项目的代码统计显示，<strong>98.3% 的代码是使用 Go 语言编写的</strong>。考虑到 DCP 最初是作为.NET Aspire 的一部分推出的，这一非 C# 的语言选择显得尤为引人注目，其背后蕴含着深厚的技术考量：</p>\n<ol>\n<li><strong>Kubernetes 生态的直接复用</strong>：Kubernetes、Docker、Etcd 以及 CNCF（云原生计算基金会）旗下的大多数核心项目均由 Go 语言编写。DCP 需要深度集成 Kubernetes 的 API 模型和 Docker 的运行时接口。使用 Go 语言编写 DCP 可以直接引用官方的 client-go、apimachinery 以及 api 库，确保 DCP 的 API 行为、序列化格式和错误处理机制与标准的 Kubernetes 保持比特级的兼容性。如果使用 C#，则需要维护一套庞大的 K8s API 绑定库，这将带来巨大的维护成本和兼容性风险。</li>\n<li><strong>跨平台静态二进制分发</strong>：Go 语言编译生成的静态链接二进制文件不依赖于目标机器上的运行时环境（如.NET Runtime ）。这使得 DCP 可以作为一个独立的、轻量级的底层工具分发到 Windows、Linux 和 macOS 上，没有任何预置条件的依赖。这对于一个基础架构工具来说至关重要。</li>\n<li><strong>高并发与性能</strong>：DCP 需要同时监控数十甚至上百个微服务进程的状态、处理日志流、转发网络流量。Go 语言的 Goroutine 模型在处理高并发 IO 密集型任务方面表现优异，且资源占用极低。</li>\n</ol>\n<h3 id=\"23-基于控制器的协调模式\"><strong>2.3 基于控制器的协调模式</strong></h3>\n<p>DCP 的运行机制完全遵循 Kubernetes 的 Operator 模式：</p>\n<ol>\n<li><strong>资源定义</strong>：DCP 定义了自己的 CRD（Custom Resource Definitions），例如 Executable（本机进程）、Container（容器）、Service（逻辑服务）等。</li>\n<li><strong>期望状态提交</strong>：上层工具（如 Aspire AppHost）计算出整个应用拓扑的期望状态，并将其提交给 DCP API Server。</li>\n<li><strong>状态协调</strong>：dcpctrl 中的控制器不断比对“当前状态”与“期望状态”。\n<ul>\n<li><em>场景示例</em>：如果期望状态中包含一个 Redis 容器，而当前系统中不存在，容器控制器就会调用 Docker 引擎启动它。如果该容器意外崩溃，控制器会检测到状态差异并自动尝试重启。</li>\n</ul>\n</li>\n<li><strong>最终一致性</strong>：这种模式使得系统对故障具有天然的韧性，无需编写复杂的命令式错误处理逻辑。</li>\n</ol>\n<h2 id=\"3-关键子系统深度剖析\"><strong>3. 关键子系统深度剖析</strong></h2>\n<p>为了支撑本地开发的复杂场景，DCP 在核心架构之外，还实现了一系列针对性的子系统。</p>\n<h3 id=\"31-智能网络与动态端口分配\"><strong>3.1 智能网络与动态端口分配</strong></h3>\n<p>网络配置是本地微服务开发中最令人头疼的问题之一。硬编码端口会导致冲突，而手动管理端口映射又极其繁琐。DCP 通过 dcptun 组件和一套复杂的算法来自动化这一过程。</p>\n<ul>\n<li><strong>全局唯一端口分配</strong>：DCP 包含一个能够感知宿主机状态的算法，用于分配动态端口。它确保即使在同一台机器上运行多个 DCP 实例（例如同时开发多个项目），分配的端口也不会发生冲突。</li>\n<li><strong>服务发现与透明代理</strong>：\n<ul>\n<li>对于容器化服务，DCP 管理 Docker 网络，允许容器通过服务名称互相解析。</li>\n<li>对于本机进程，DCP 可能会启动本地代理（Localhost Proxy），将逻辑地址（如 <a href=\"http://myservice\" rel=\"noopener nofollow\" target=\"_blank\">http://myservice</a>）的流量转发到动态分配的实际端口（如 localhost:54321）。这种机制对应了.NET Aspire 中的 IsProxied 属性，允许 DCP 接管流量管理，处理内部端口差异和负载均衡（如果有多个副本）。</li>\n</ul>\n</li>\n<li><strong>反向隧道</strong>：在某些场景下（如从容器内部访问宿主机的调试端点），DCP 利用 dcptun 建立反向隧道，打通网络隔离。</li>\n</ul>\n<h3 id=\"32-进程管理与僵尸进程防御\"><strong>3.2 进程管理与僵尸进程防御</strong></h3>\n<p>在 Windows 和 POSIX 系统上管理进程树的生命周期是一项挑战。开发者经常遇到“停止调试后，后端 API 进程仍在后台占用端口”的情况。</p>\n<ul>\n<li><strong>Windows Job Objects</strong>：DCP 在 Windows 上利用内核级的 Job Objects 机制。它将启动的进程及其派生的所有子进程放入同一个 Job Object 中。当 DCP 退出或接收到停止指令时，它只需关闭 Job Object，操作系统就会强制终止其中的所有进程，彻底杜绝僵尸进程 12。</li>\n<li><strong>dcpproc 包装器</strong>：DCP 使用 dcpproc 作为进程启动的中间层，这一设计使得进程监控逻辑与业务逻辑解耦，并能在跨平台环境下提供一致的信号处理和退出码传播机制。</li>\n</ul>\n<h3 id=\"33-ide-执行规范与交互协议\"><strong>3.3 IDE 执行规范与交互协议</strong></h3>\n<p>DCP 的一个杀手级特性是它不仅能“运行”程序，还能“委托”IDE 来运行程序，从而实现无缝的断点调试。这一机制被称为 <strong>IDE Execution Specification</strong> 。</p>\n<ul>\n<li><strong>委托模式</strong>：当资源被标记为 ExecutionType: IDE 时，DCP 不会直接启动进程。相反，它会向 IDE 暴露的端点发送一个 PUT /run_session 请求。</li>\n<li><strong>协议细节</strong>：\n<ul>\n<li><strong>请求载荷</strong>：包含完整的启动配置，如可执行文件路径、参数（args）、环境变量（env）以及工作目录。重要的是，DCP 会将在编排阶段计算出的服务发现信息（如其他服务的 URL）作为环境变量注入其中。</li>\n<li><strong>双向通信</strong>：建立连接后，IDE 通过 WebSocket 向 DCP 流式回传进程的生命周期事件（Process Started, Terminated）、标准输出/错误日志（stdout/stderr）以及调试状态。</li>\n</ul>\n</li>\n<li><strong>支持的配置类型</strong>：\n<ul>\n<li><strong>Project</strong>：针对 Visual Studio 项目模型，支持 Debug 或 NoDebug 模式。</li>\n<li><strong>Python</strong>：明确支持 Python 脚本启动，指定解释器路径和模块名称 。这直接印证了 DCP 对非.NET 语言的原生支持能力。</li>\n</ul>\n</li>\n<li><strong>版本控制</strong>：API 具有明确的版本控制（如 2024-03-03, 2025-10-01），确保了协议的向后兼容性，允许不同版本的 IDE 插件与 DCP 协同工作 12。</li>\n</ul>\n<h2 id=\"4-dcp-与net-aspire-的深度集成\"><strong>4. DCP 与.NET Aspire 的深度集成</strong></h2>\n<p>虽然 DCP 是语言无关的，但目前它与.NET Aspire 的集成最为紧密，不仅是其运行时底座，更是其开发体验的核心驱动力。</p>\n<h3 id=\"41-apphost声明式代码到资源模型的映射\"><strong>4.1 AppHost：声明式代码到资源模型的映射</strong></h3>\n<p>在.NET Aspire 中，AppHost 项目是编排的入口。开发者使用流畅的 C# API 定义资源：</p>\n<p>var builder = DistributedApplication.CreateBuilder(args);<br />\nvar redis = builder.AddRedis(\"redis\");<br />\nvar api = builder.AddProject&lt;Projects.MyApi&gt;(\"api\")<br />\n.WithReference(redis);</p>\n<p>当这段代码执行时，幕后发生了一系列复杂的转换 ：</p>\n<ol>\n<li><strong>模型构建</strong>：Aspire SDK 将上述 C# 对象图转换为 DCP 理解的抽象资源模型（Resource Model）。</li>\n<li><strong>依赖计算</strong>：SDK 自动解析 WithReference，生成对应的连接字符串或服务端点环境变量。</li>\n<li><strong>DCP 引导</strong>：Aspire 检查 DCP 是否安装/运行，并通过 dcp.exe 启动 API Server。</li>\n<li><strong>清单提交</strong>：将生成的资源模型序列化并通过 HTTP 发送给 DCP。</li>\n</ol>\n<h3 id=\"42-仪表板与可观测性数据流\"><strong>4.2 仪表板与可观测性数据流</strong></h3>\n<p>.NET Aspire 提供了一个功能强大的仪表板（Dashboard），用于实时查看日志、链路追踪（Traces）和度量（Metrics）。DCP 是这个仪表板的主要数据供给者之一 。</p>\n<ul>\n<li><strong>日志聚合</strong>：DCP 捕获所有受管子进程和容器的 stdout/stderr，并通过流式 API 提供给仪表板。</li>\n<li><strong>结构化日志</strong>：DCP 自身的系统日志采用了结构化格式（如 [sys] Starting process...），便于仪表板解析和高亮显示 17。</li>\n<li><strong>OTEL 配置</strong>：DCP 负责为每个服务注入 OpenTelemetry (OTEL) 相关的环境变量（如 OTEL_EXPORTER_OTLP_ENDPOINT），确保应用产生的遥测数据能自动发送到仪表板或指定的收集器。</li>\n</ul>\n<h2 id=\"5-跨越语言边界dcp-的多语言polyglot战略\"><strong>5. 跨越语言边界：DCP 的多语言（Polyglot）战略</strong></h2>\n<p>DCP 的开源和演进不仅仅是为了服务.NET 社区，其更大的野心在于成为多语言云原生开发的通用控制平面。</p>\n<h3 id=\"51-从net-专属到语言中立\"><strong>5.1 从.NET 专属到语言中立</strong></h3>\n<p>在现代微服务架构中，\"混合技术栈\"是常态。一个典型的电商系统可能包含：</p>\n<ul>\n<li>核心交易系统：C# / Java</li>\n<li>AI 推荐服务：Python</li>\n<li>前端应用：React / Vue (Node.js)</li>\n<li>高性能代理：Go / Rust</li>\n</ul>\n<p>如果 DCP 仅支持.NET，它只能覆盖系统的一小部分。开源后的 DCP 及其对应的 Aspire 路线图（Roadmap 2025-2026）明确展示了对 <strong>Python</strong> 和 <strong>JavaScript/TypeScript</strong> 的一等公民支持 。</p>\n<ul>\n<li><strong>Node.js 与 Python 支持</strong>：Aspire 13 引入了对 Node.js 和 Python 应用的原生编排能力。DCP 能够识别 package.json 或 requirements.txt，自动配置运行环境，甚至支持自动生成 Dockerfile 18。</li>\n<li><strong>统一的客户端集成</strong>：无论使用何种语言，DCP 旨在提供一致的体验——通过环境变量注入连接字符串，通过标准协议收集日志。这意味着 Python 开发者可以使用 pip 安装辅助包，像 C# 开发者一样享受服务发现和仪表板功能。</li>\n</ul>\n<h3 id=\"52-实验性的跨语言-apphost\"><strong>5.2 实验性的跨语言 AppHost</strong></h3>\n<p>更为激进的创新是正在探索中的基于 <strong>WASM (WebAssembly) + WIT (WebAssembly Interface Type)</strong> 的跨语言 AppHost。这将允许开发者使用 Python 或 TypeScript 编写 AppHost 逻辑，直接调用 DCP 的能力，而无需依赖.NET SDK。如果这一愿景实现，DCP 将真正成为一个独立于.NET 的通用开发平台。</p>\n<h2 id=\"6-安全性合规性与企业级信任\"><strong>6. 安全性、合规性与企业级信任</strong></h2>\n<p>对于作为开发基础设施核心组件的 DCP，安全性是企业采纳的前提。开源化极大地增强了这方面的透明度。</p>\n<h3 id=\"61-供应链安全与代码审计\"><strong>6.1 供应链安全与代码审计</strong></h3>\n<p>DCP 仓库集成了 GitHub Advanced Security 和 Microsoft Security DevOps 工具链。</p>\n<ul>\n<li><strong>CodeQL 分析</strong>：自动化的语义代码分析，用于发现潜在的漏洞（如路径遍历、注入攻击）。</li>\n<li><strong>依赖扫描</strong>：自动检测 Go 模块依赖中的已知漏洞（CVE），并提示更新。</li>\n<li><strong>Secret Scanning</strong>：防止密钥和凭据意外提交到代码库 22。</li>\n</ul>\n<h3 id=\"62-许可协议与商业化澄清\"><strong>6.2 许可协议与商业化澄清</strong></h3>\n<p>DCP 采用 <strong>MIT 许可证</strong>，这是最宽松的开源协议之一。这意味着企业可以自由地修改、分发甚至将 DCP 集成到商业产品中。这消除了之前 EULA 中关于“商业发布终止”条款带来的法律不确定性 。对于希望基于 DCP 构建内部开发者平台（IDP）的大型企业来说，这是一个关键的绿灯。</p>\n<h2 id=\"7-dcp-与同类技术的比较优势分析\"><strong>7. DCP 与同类技术的比较优势分析</strong></h2>\n<p>为了更清晰地定位 DCP，我们需要将其与市场上的其他编排工具进行对比。</p>\n<h3 id=\"71-dcp-vs-docker-compose\"><strong>7.1 DCP vs. Docker Compose</strong></h3>\n<p>Docker Compose 是目前最主流的本地编排工具，主要基于 YAML 配置。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">特性</th>\n<th style=\"text-align: left;\">DCP (Microsoft)</th>\n<th style=\"text-align: left;\">Docker Compose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>核心对象</strong></td>\n<td style=\"text-align: left;\">进程 (Process) + 容器 (Container)</td>\n<td style=\"text-align: left;\">仅容器 (Container)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>开发调试</strong></td>\n<td style=\"text-align: left;\"><strong>原生支持 IDE 调试</strong> (断点/单步)</td>\n<td style=\"text-align: left;\">需远程附加调试器 (Remote Attach)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>配置语言</strong></td>\n<td style=\"text-align: left;\">通用编程语言 (C#, Python 等)</td>\n<td style=\"text-align: left;\">声明式 YAML</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>构建集成</strong></td>\n<td style=\"text-align: left;\">深度集成 (感知项目源码)</td>\n<td style=\"text-align: left;\">弱集成 (主要基于镜像)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>适用阶段</strong></td>\n<td style=\"text-align: left;\">编码与调试 (Inner Loop)</td>\n<td style=\"text-align: left;\">运行与集成测试</td>\n</tr>\n</tbody>\n</table>\n<p><strong>分析</strong>：DCP 的最大优势在于其<strong>混合编排</strong>能力。在开发过程中，开发者通常希望在本机运行正在修改的服务（以便调试），而将数据库或消息队列等稳定依赖放在容器中。Compose 强制所有组件容器化，增加了调试的摩擦力；而 DCP 允许“本机进程”与“容器”无缝共存并互通网络，这是其针对开发场景的核心竞争力。</p>\n<h3 id=\"72-dcp-vs-kubernetes-minikubekind\"><strong>7.2 DCP vs. Kubernetes (Minikube/Kind)</strong></h3>\n<p>Minikube 和 Kind 在本地运行完整的 K8s 集群。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">特性</th>\n<th style=\"text-align: left;\">DCP (Microsoft)</th>\n<th style=\"text-align: left;\">Minikube / Kind</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>架构模型</strong></td>\n<td style=\"text-align: left;\">模拟 K8s API (无节点架构)</td>\n<td style=\"text-align: left;\">完整 K8s 集群</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>资源消耗</strong></td>\n<td style=\"text-align: left;\"><strong>极低</strong> (单一二进制进程)</td>\n<td style=\"text-align: left;\">高 (需运行 Docker/VM 及 K8s 控制面)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>启动速度</strong></td>\n<td style=\"text-align: left;\">毫秒级</td>\n<td style=\"text-align: left;\">分钟级</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>真实度</strong></td>\n<td style=\"text-align: left;\">功能级仿真 (非完全一致)</td>\n<td style=\"text-align: left;\">生产级一致性</td>\n</tr>\n</tbody>\n</table>\n<p><strong>分析</strong>：DCP 选择了“实用主义”路线。它借用了 K8s 的优秀设计（控制器模式、声明式 API），但抛弃了其沉重的实现（Etcd, Kubelet, Scheduler）。这使得 DCP 能在普通的开发笔记本上轻松运行，而不会占用过多的 CPU 和内存资源。</p>\n<h2 id=\"8-未来展望ai-驱动与生态融合\"><strong>8. 未来展望：AI 驱动与生态融合</strong></h2>\n<p>随着技术的演进，DCP 的角色正在从单纯的编排器向更智能的开发辅助平台转变。</p>\n<h3 id=\"81-mcp-model-context-protocol-与-ai-agent\"><strong>8.1 MCP (Model Context Protocol) 与 AI Agent</strong></h3>\n<p>最新的路线图显示，Aspire 和 DCP 正在集成 <strong>MCP (Model Context Protocol)</strong> 。MCP 是一个新兴的标准，旨在让 AI 模型能够理解和操作上下文。 在 DCP 的语境下，这意味着：</p>\n<ul>\n<li><strong>架构感知</strong>：AI 编码助手（如 GitHub Copilot）可以通过 MCP 查询 DCP，获取当前运行的应用架构、服务依赖关系和实时状态。</li>\n<li><strong>智能诊断</strong>：当应用报错时，AI 可以读取 DCP 聚合的日志和追踪信息，结合架构上下文，给出更精准的调试建议。</li>\n<li><strong>自动化操作</strong>：AI Agent 可能被授权通过 DCP API 动态启动调试容器、重置数据库状态或修改环境变量，从而实现半自动化的开发运维。</li>\n</ul>\n<h3 id=\"82-云端部署的标准化映射\"><strong>8.2 云端部署的标准化映射</strong></h3>\n<p>尽管 DCP 专注于本地开发，但其定义的资源模型（Resource Model）具有极高的抽象价值。微软正在致力于完善从 DCP 模型到 Azure Container Apps (ACA)、Azure Kubernetes Service (AKS) 甚至 AWS/GCP 服务的部署映射 。这意味着开发者在本地通过 DCP 定义的架构，可以“一键”转换为云端的 Terraform 或 Bicep 模板，真正实现“一次定义，到处运行”的云原生愿景。</p>\n<h2 id=\"结论\"><strong>结论</strong></h2>\n<p>微软开源 microsoft/dcp 是其云原生工具链战略中的神来之笔。通过使用 <strong>Go 语言</strong>构建一个兼容 Kubernetes API 模型但极其轻量级的控制平面，DCP 成功解决了本地微服务开发中“编排复杂”与“调试困难”的长期痛点。它打破了.NET 的生态围墙，向 Python、Node.js 等多语言生态伸出了橄榄枝，并展示了成为<strong>通用本地开发编排标准</strong>的巨大潜力。</p>\n<p>对于开发者而言，DCP 意味着更流畅、更接近生产环境的本地开发体验；对于企业而言，开源的 DCP 提供了一个透明、安全且可扩展的基础设施组件。随着 AI Agent (MCP) 的集成和跨语言能力的成熟，DCP 有望重新定义云原生应用的构建方式，成为下一代开发工具链的基石。</p>\n<h4 id=\"引用的文章\"><strong>引用的文章</strong></h4>\n<ol>\n<li>Introducing .NET Aspire: Simplifying Cloud-Native Development with .NET 8, <a href=\"https://devblogs.microsoft.com/dotnet/introducing-dotnet-aspire-simplifying-cloud-native-development-with-dotnet-8/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/introducing-dotnet-aspire-simplifying-cloud-native-development-with-dotnet-8/</a></li>\n<li>Exploring the Microsoft Developer Control Plane at the heart of the new .NET Aspire,  <a href=\"https://anthonysimmon.com/exploring-microsoft-developer-control-plane-core-dotnet-aspire-dotnet-8/\" rel=\"noopener nofollow\" target=\"_blank\">https://anthonysimmon.com/exploring-microsoft-developer-control-plane-core-dotnet-aspire-dotnet-8/</a></li>\n<li>What is .NET Aspire? - Microsoft Learn,  <a href=\"https://learn.microsoft.com/en-us/shows/dotnet-aspire-2024/what-is-dotnet-aspire\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/shows/dotnet-aspire-2024/what-is-dotnet-aspire</a></li>\n<li>General Availability of Aspire: Simplifying .NET Cloud-Native Development,  <a href=\"https://devblogs.microsoft.com/dotnet/dotnet-aspire-general-availability/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/dotnet-aspire-general-availability/</a></li>\n<li>Aspire architecture <a href=\"https://aspire.dev/architecture/overview/\" rel=\"noopener nofollow\" target=\"_blank\">https://aspire.dev/architecture/overview/</a></li>\n<li>What is the AppHost? <a href=\"https://aspire.dev/get-started/app-host/\" rel=\"noopener nofollow\" target=\"_blank\">https://aspire.dev/get-started/app-host/</a></li>\n<li>Is the core of Aspire not open source? : r/dotnet - Reddit <a href=\"https://www.reddit.com/r/dotnet/comments/1ptp01l/is_the_core_of_aspire_not_open_source/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.reddit.com/r/dotnet/comments/1ptp01l/is_the_core_of_aspire_not_open_source/</a></li>\n<li>Not building dependencies - Visual Studio Developer Community <a href=\"https://developercommunity.visualstudio.com/VisualStudio?ftype=problem&amp;fTime=6m&amp;q=dependency+vulnerability&amp;stateGroup=active\" rel=\"noopener nofollow\" target=\"_blank\">https://developercommunity.visualstudio.com/VisualStudio?ftype=problem&amp;fTime=6m&amp;q=dependency+vulnerability&amp;stateGroup=active</a></li>\n<li>.NET can't be open-source without open-source tooling : r/dotnet - Reddit <a href=\"https://www.reddit.com/r/dotnet/comments/1druoyk/net_cant_be_opensource_without_opensource_tooling/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.reddit.com/r/dotnet/comments/1druoyk/net_cant_be_opensource_without_opensource_tooling/</a></li>\n<li>Referencing external Docker containers in .NET Aspire using the new custom resources API, <a href=\"https://dev.to/asimmon/referencing-external-docker-containers-in-net-aspire-using-the-new-custom-resources-api-4ifg\" rel=\"noopener nofollow\" target=\"_blank\">https://dev.to/asimmon/referencing-external-docker-containers-in-net-aspire-using-the-new-custom-resources-api-4ifg</a></li>\n<li>microsoft/dcp: Developer Control Plane API server and CLI. <a href=\"https://github.com/microsoft/dcp\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microsoft/dcp</a></li>\n<li>Set up code scanning for GitHub Advanced Security for Azure DevOps - <a href=\"https://learn.microsoft.com/en-us/azure/devops/repos/security/github-advanced-security-code-scanning?view=azure-devops\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/azure/devops/repos/security/github-advanced-security-code-scanning?view=azure-devops</a></li>\n<li>Inner-loop networking overview - Aspire <a href=\"https://aspire.dev/fundamentals/networking-overview/\" rel=\"noopener nofollow\" target=\"_blank\">https://aspire.dev/fundamentals/networking-overview/</a></li>\n<li>aspire/src/Aspire.Hosting/DistributedApplicationBuilder.cs at main · dotnet/aspire · GitHub, <a href=\"https://github.com/dotnet/aspire/blob/main/src/Aspire.Hosting/DistributedApplicationBuilder.cs\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/dotnet/aspire/blob/main/src/Aspire.Hosting/DistributedApplicationBuilder.cs</a></li>\n<li>JetBrains Rider and the .NET Aspire Plugin | The .NET Tools Blog <a href=\"https://blog.jetbrains.com/dotnet/2024/02/19/jetbrains-rider-and-the-net-aspire-plugin/\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.jetbrains.com/dotnet/2024/02/19/jetbrains-rider-and-the-net-aspire-plugin/</a></li>\n<li>What's new in Aspire 13.1,  <a href=\"https://aspire.dev/whats-new/aspire-13-1/\" rel=\"noopener nofollow\" target=\"_blank\">https://aspire.dev/whats-new/aspire-13-1/</a></li>\n<li>Aspire 13 Launches: A New Era for Polyglot Cloud-Native Development - HexMaster's Blog <a href=\"https://hexmaster.nl/posts/aspire-13-launches-a-new-era/\" rel=\"noopener nofollow\" target=\"_blank\">https://hexmaster.nl/posts/aspire-13-launches-a-new-era/</a></li>\n<li>What's new in Aspire 13, <a href=\"https://aspire.dev/whats-new/aspire-13/\" rel=\"noopener nofollow\" target=\"_blank\">https://aspire.dev/whats-new/aspire-13/</a></li>\n<li>Aspire Roadmap (2025 → 2026) · dotnet aspire · Discussion #10644 - GitHub  <a href=\"https://github.com/dotnet/aspire/discussions/10644\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/dotnet/aspire/discussions/10644</a></li>\n<li>Configure the Microsoft Security DevOps GitHub action - Microsoft Defender for Cloud <a href=\"https://learn.microsoft.com/en-us/azure/defender-for-cloud/github-action\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/azure/defender-for-cloud/github-action</a></li>\n<li>Protect code repository secrets with Microsoft Defender for Cloud,  <a href=\"https://learn.microsoft.com/en-us/azure/defender-for-cloud/secrets-scanning-code\" rel=\"noopener nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/azure/defender-for-cloud/secrets-scanning-code</a></li>\n<li>dotnet aspire · Discussions  <a href=\"https://github.com/dotnet/aspire/discussions\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/dotnet/aspire/discussions</a></li>\n</ol>\n\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 13:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">118</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "忆往昔--OI生涯回忆",
      "link": "https://www.cnblogs.com/hicode002/p/-/oi-memories",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hicode002/p/-/oi-memories\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 11:45\">\n    <span>忆往昔--OI生涯回忆</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>突然大概明白了为什么这么失败了...其实我对OI/计算机的热情远没有那么高，至少不是那种特别喜欢写程序写项目的人，之前也只是用E语言/Python写各种小工具/爬虫，还研究过一段时间游戏开发（当然小学时候是不会英语用的中文编程），甚至那时候就会多线程并发（当然还是中文语言）那时候的确对写程序有很强的热情，至少说是一个自我满足的过程，得写了好几十个小工具而且思路也还比较清晰能坐在电脑面前很长时间，而且没有很强的炫耀思维。当然当时也是刷机爱好者，在那个年代感觉（小学时候）几乎没有很多的资源但是我那时候一直有个梦想就是给手机刷windows和手机双系统，（结果这个到今天也没实现emmm），然后刷坏了好几部手机，d当时还是Windows Phone时代，那时候我一直想着手机有一天也要有电脑的BIOS。（然后后来WOA项目真的做了）然后就是MC玩家还研究过命令方块（当时手机版刚出命令方块）（还是多玩我的世界盒子时代），当时体育课还把它都打印出来和同学讨论。<br />\n然后小学很早家里买了一堆操作系统安装和Dreamviewer/photoshop软件使用的书，当时还说要自己写一个博客，（谁知道现在前端都是vue+react，并且博客都是现成的模板），然后还有一本上世纪的VB编程（结果现在早淘汰了）。</p>\n<p>从这个意义上说我至少学OI前我的计算机学习的确是出于兴趣并且充满热情的，而且都是自学的。</p>\n<p>初二时候想着研究AI相关的（主要是流浪地球的MOSS吸引的），然后想着系统性的学python什么的正儿八经写一个自动化工具（当时也不懂AI的原理只知道要训练），然后一直没有好的自学资源（或者说当时我找不到），然后当时语文作文很差被家长勒令去上辅导班加上和老师/同学关系很差，所以说很难受。然后辅导班旁边有有一家新开的编程机构邀请我试听，然后去了，到那把我的情况一说，然后人家觉得我水平还可以跟我说了信息学竞赛和C++相关的，然后我一下子非常高兴，就跟家长说要学（在此之前所有兴趣班我都学不下去），然后刚好当时初中班主任对我态度很差，之前还说过我除了会点电脑啥都不会就是废物之类的话（确实我体育不好，谁叫她教体育的...),所以说就真让家长报班学了，当时还有另外一个骗子机构叫做童程童美，是教python的，用python写小游戏，但是我觉得有点水（事实证明这个机构后来的确暴雷了）。然后暑假2个月把C++语言基础学出来了，那时候突然一下子了解到自主招生，了解到一种神秘的东西叫做游记/退役记，然后才意识到，原来编程学的好可以保送/高考降分进入名校啊，突然意识到原来在有些地方他们的中学生活非常快乐而不是像我一样。然后当时翻到了很多NOIP考了好成绩被高中保送，然后高中在机房快乐的编程，感觉非常浪漫就像在童话的世界一样。还有一些学长高三提前降一本然后在学校爽玩然后在全校分享自己的经验，那种感觉就是一个从来没有见过的新世界呀！</p>\n<p>那时候我一下子意识到我也要像他们那样，那时候看到大佬们的游记里面提到的高大上听不懂名字的算法和数据结构，还有当时一个流行的话：暴力出奇迹，暴力进国集，想着只要我认真学习这些算法和数据结构，再有着良好的数学基础，再给我充足的时间，然后肯定可以拿到金牌进入国集!（而且看zyb大佬的博客大概的学习路线也确实是这样的）而且那时候整个西海岸连一个省一的都没有！所以说当时是我暗自就下定决心要把全部精力投入到这个上面，一定要拿到金牌，拿不到金牌拿一个银牌也行，那样到时候没有人会再嘲讽我！再也没有人会说我体育差/语文差!然后我想象着拿到牌子之后，我可以认识很多人，我可以有一天站在学校的讲台上讲着自己的经验，我保送/降分之后我可以弥补我之前没有做的事情，我可以做化学实验，我可以重新玩我喜欢的游戏，我可以有自己的游记下面也会有人评论！</p>\n<p>然后我那时候想着第一年先拿到普及组一等奖，那时候我虽然不理解很多算法连回溯都不太理解但是我代码能力还可以或者说心态很好，这些题都是直接上手写代码的。后来还配了NOI linux环境，还配置了GEDIT和VIM，当时还想着考场上是Linux环境,还担心会有一些编译错误，甚至默写头文件而不是使用万能头，然后还记着当时初中语文课（我语文课听不下去老师天天骂我，而且阅读题我从来不做因为总感觉自己的想法会被老师审阅是很不舒服的，只有考试才做因为阅卷老师是随机的），课上在课本的角落上在那边默写头文件/想题（当时都是一些模拟题）。然后到CSP考前我基本上刷完了历年所有普及组的前两题，这样说前两题根本没有什么难度，我拿个普及组省一没有任何问题。当时状态也是非常好，复赛的时候去日照那时候OI还是蒸蒸日上，疫情和强基计划还没有出台，日照的人很多，很多学校有庞大的队伍，当时的我也是感觉很羡慕</p>\n<p>然后是初三 自主招生 化学实验 CSP2020 自学记笔记（效率低的问题） 没有资源（不知道刷什么题） 想要有强校集训的氛围，但是这种快节奏的课容易走神，训练上面没有时间写代码，这是最严重的问题，中考超出50多分。 热情还是在的，当时会python还写过脚本学过爬虫 然后还在用e语言写窗口程序（当时不知道c#诶）</p>\n<p>中考结束后的暑假，那应该是状态前期比较好的一个暑假了吧...<br />\n暑假前期一中的自招班要提前去上一周课，当时是没有晚自习的，而且食堂特别好（后来才知道那段时间是特意那么搞的，平时食堂很烂），然后当时一中承诺学科竞赛要认真搞，我还想着联系教练（结果连教练都没有，笑，就是微机老师）。<br />\n印象最深的是当时一中的学姐学长回来宣讲，当时的我非常的心潮澎湃，看着他们描述的丰富多彩的大学生活，当然现实是从外表和言谈上已经完全看不出曾经是高中生了，所以确实应该有不错的大学生活。然后他们讲着在一中是怎么学习的，分享自己的经验，非常的从容。我当时就在想，假如有一天我进了省队拿了银牌或者以上，那么我也可以回来坐在那个讲台上，分享我学习OI的事情。那种激情确实很强的刺激我学习OI。</p>\n<p>我当时想法很简单要过完数据结构+图论的内容，然后后面再看DP。但是我当时只会照着OI-WIKI学，实际上学的太偏向模板了而且OIWIKI不是很通俗易懂。我当时列的计划不错，但是现实是我每天根本完不成，因为我看一会儿wiki然后看不懂就去搜搜了很多还是看不懂就浪费很多时间，再就是看一会儿经常往下翻总之还是有点静不下心。所以实际上我到8月份只学了线段树树状数组堆分块还有一些数论算法之类的，然后我就很急。这要开学可怎么办啊！我的想法是NOIP2021要拿高分然后冲省选的！然后第一次跟家长谈论停课。然后家长果然拒绝了还说了一些难听的话（大概就是以后我后悔了又要怪他之类的）（还有什么白养了之类的）。当然拒绝是理解的毕竟刚进入高中我对一中所谓的竞赛培养体系还抱有幻想。</p>\n<p>进入一中后，状态很好 然后最开始有教练，但是我想法太好了，有点飘了，然后意识到一个问题就是交流题目这种有刺激性的事会让我完全无法思考，所以晚自习做题效率很低。再就是代码能力还是差到后期头疼思维混乱了就只能出思路写不动代码。然后NOIP2021前实际上没学多少东西。 NOIP2021爆炸。接下来是复盘反思：数学基础薄弱，连方差的两种算法都不知道，概率期望不会算，排列组合水平差，所以恶补了很多数学，当然也是自学高中数学 然后实际上就偏离了对代码能力的培养：这和在学校没有电脑关系很大 再加上我对重点班的竞赛培养抱有幻想</p>\n<p>而且后来高一上几乎不怎么写作业然后期末级部30多名，然后被调进了所谓重点班。其实某种程度上说这也是噩梦的开始。我以为重点班老师会充分信任学生的能力，班里会有很多搞竞赛的，会有一个良好的氛围，即使压力很大，因为我之前也看过那些回忆录里面提到的竞赛班，很多都是长时间停课然后搞竞赛的，所以我的想法还是挺好的，所以那时候我都想好了要跟着学校进度走走看。然后就是高一下学期跟了一段时间文化课还去参加了SDOI2022，但是SDOI2022前没有任何准备，当时晚自习周末都没有去搞竞赛，就是偶尔跟着zgx搞一搞。但是只能说进入这个班之后压力骤增。老师并不是很信任这些学生，相反每周还要花很长的时间开班会来PUA。而且，这个班直接从普通班的楼搬出去了，某种意义上是物理隔离（当然你要主动去找也可以）。然后实际上老师和领导是有意鼓动这个班的内卷风气，而且PUA的内容就是清华北大。（其实我感觉去不去TP无所谓，华五好专业更好，真去TP可能就真抑郁了。。。）实际上班里并不支持学习竞赛，或者说学校是把竞赛看作是一种whk的补充或者说是为了强基校测准备的。（但是后来确实出了两个牌子一个PHO一个CHO，好像也没有额外的训练，当然我觉得CHO没有那么难）。在这样一个内卷的状态下实际上按照自己节奏学习WHK是一件很难的事情，实际上像物理，老师讲的很快而且实际上也讲不出什么，更多时间还是应该按照自己体系来进行学习（我高中物理跟这个老师成绩挺差的裸分有时候70多）（后来准备少创时候是按照小时百科重学了一遍相当于），然后真正的去理解一个题目。生物也是，后来我生物是看网课才得到比较大的提升。所以实际上这一个学期我是挺痛苦的，不仅没有学到OI上什么东西把SDOI2022浪费了，这可是我唯一去省选的机会啊。然后WHK上我又很痛苦，明明假期家长已经拉着我预习一遍了，我还要再学一遍干啥。所以实际上根本没办法静下心来，反而把时间都浪费了。这可能是最后悔的一件事。</p>\n<p>当时还有另外一个有趣的事情，就是5月时候，突然想把学生平板破解了，然后就和wk研究刷机，然后了解到华为的Bootloader，然后那时候有一个开源工具叫potatonv，但是不是很好用。后来我读了potatonv的源码手动复现了他的解锁原理。然后当时有一篇很著名的安全报告，或者说两篇描述的同一件事情：华为海思麒麟芯片上的安全启动漏洞，一个是taszk pdf的，一个是pangu的。然后当时看了，但是还有很多细节不理解，但是由于我的平板是麒麟659和论文对不起来再加上用不上，所以就放弃了，想着以后有什么时间再复现一下。结果拖了4年...（然后2025年上半年复现了，后果惨重）.然后当时我们两个研究了怎么解BL 刷TWRP，然后我们研究了好久双系统，最终找到了一种在SD卡上跑双系统的办法。当时，我突然看到一个项目叫做POSTMARKETOS，是在手机上面移植linux，但是当时一个是没时间再一个也不是很懂设备树什么的，但是就想着这件事，以后要研究怎么在手机上面移植Linux。另外当年最震撼的项目就算Renagade Project，在手机上安装Windows，这个可是我从小学开始的梦想啊！然后我就想着也许麒麟也可以移植UEFI（现在觉得这是不可能的我有点疯了）。另外一件事就是初二疫情的时候我入坑了Limbo模拟器吧，但是玩了一会儿发现手机模拟电脑架构速度太慢，所以就想着开KVM。当时KVM是圈子里面最高的神话。所以说我后来每次遇到一个手机/芯片，都想着在上面开KVM，但是到现在我还是没有研究清楚（现在状态毁了）。<br />\n从这件事来看，我当时还是有比较强烈的对计算机的热情的，虽然写不动算法竞赛题目的代码但是一些有趣的小项目工具我还是愿意写的，比如说yichafen爬虫，比如说谷歌小恐龙自动玩，还有写过OJ，虽然只是C++写的后端。还有当时我为什么还在用易语言写窗口程序！甚至和C语言结合起来！当时我为什么不想着学一门正经的窗口编程语言比如C#...但是我没有想过开发一个大型工程。当然当时更不会想着什么开发方向或者安全方向（虽然初二就研究过几次SQL注入但是发现大部分网站都修复了然后剩下的没有任何了解）。所以说这实际上也是埋下了一个伏笔。但是正常来说这样的状态大学接着系统的学习计算机或者打ICPC最后肯定看起来没什么问题，当然这是后话了。</p>\n<p>这种热情到NOIP前就已经消失殆尽了，当时为了停课都疯了，当时就好像一个失心魔，每天回家就要和父母大吵一架，大喊大叫(嗓子也喊坏了...)，然后在学校动不动早读的时候或者语文课的时候就砸桌子或者一个人跑出去然后开始哭，后来还写纸条给各科老师和主任希望只要有一个同意的。这样我的心态受到了很大的影响，本来想的是静下心思考认真训练，但是为了停课我的心态已经爆炸了心情已经很不好了，已经没有精力接着认真学习，而且这样我就感觉很急好像如果我NOIP考的不好所有人立马就会反对我，所以说实际上把所有希望都寄托在NOIP2022上了，这样自己一旦想不出题就特别焦虑，又不敢看题解，因为看题解之后我就感觉自己很傻然后心态更差了...所以那段时间每天投入大量的精力学习OI尤其是重心放在一些复杂的trick和思维题上面，当然也补了暑假zhengrui没学会的东西，但是收效甚微而且每天心情都很差经常大喊大叫然后很焦虑，然后基本上实际上一天什么也没干，而且我执行力差很多细节复杂的题的代码本来都没有写现在这个状态基本上就是只看题不写题了。<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260122000619030-1117947224.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3026852/202601/3026852-20260122000629006-1193078129.png\" /><br />\n那时候的题单到后来也没写完...而且以前题目写错了尤其是思路错了我会心态很好的调试，然后换思路，但是从高中开始，我越来越惧怕这种失败了，这种浪费时间的失败，因为时间紧迫，所以说一旦想错了我就很自责，久而久之就害怕写代码调试了。所以说这可能是导致我代码能力下降的又一个重要原因。<br />\n所以说实际上这时候NOIP是注定要爆炸的，10月份开始就有很清晰的预感，只不过心里总是想着万一上天眷顾我一次呢！万一题目合我的胃口呢！<br />\n但是那时候我还有一丝希望，因为还有CSP！<br />\n当时是星期三，我那天又很生气，然后想着停课，毕竟马上CSP了，</p>\n<p>但是现在想想，其实OI的失败是必然的，我早就没有良好的心态了，而且我做事情的目的已经从纯粹的兴趣变成了我要被别人认可我要被别人承认我要拿到成绩，这种目的性太强了，而且我的执行能力比较差，虽然也尝试过很多比如列计划，整理笔记等方式但是效果只能说没什么用。而且我的精力严重不够，就像前面说的那样，看一会儿电脑就头疼，而且在电脑前思维非常的混乱，如果不借助草稿纸，甚至感觉不能正常的思考。（这个现在倒是好一点，但是就是效率太低）即使休息的很好第二天也是很累浑身乏力，更何况有时候我会陷入幻想根本睡不着。而且我总是有一种幻想就是我可以像淄博的那两位那样或者像lx那样从没有资源没有支持的地方逆袭翻盘，但是实际上我的天赋根本不支持如此，而且实际上那些大佬虽然在弱校但是却能够经常出去集训，也就是说能够把握一手的考试方向和主流的题目，而且有一个正常的人际交往，而且他们的天赋都比较厉害。而且OI也没有以前纯粹了，以前圈子的互帮互助分享交流变成了一种很奇怪的p话文化，不仅仅是卖弱这么简单，而是有时候感觉有一种强烈的歧视感，而且虽然资源现在是够多了但是主流的方向还是不好自己把握。而且，题目的难度正在变怪，从原来的考察代码能力+算法/数据结构积累能力+一定的思维能力 变成了 思维能力为主或者说是更加偏向于数竞这种启发性的考试了。这在工程意义上我觉得不是什么好事儿。但是，关键问题是，OI退役后，事情并没有好起来。</p>\n<p>NOIP出分之后，我还是不服气，当时疫情隔离结束之后返校了。结果，返校之后，老师把我桌子拖到了最后一排。返校之后课上当时还在继续学习准备省选知识点，那时候状态还可以，还想着省选还可以翻盘。但是，当时级部主任把我平板没收了，看我上课在看平板。然后我心情就挺差的。不过当时我还是有自信的毕竟我觉得NOIP的T3只要当时清醒一点把DP方程改对就一点问题没有了。但是后来，家长开始说我，让我开始补文化课，然后又拿期末考试说事儿。而且，当时，刚好疫情解封前最混乱的时期，在学校里面关了两个周。那时候我在想的一件事是，我到底有没有能力或者说有没有希望省选翻盘？我当时翻了Cmd2001大佬的博客（他是noip2017二等奖然后省选翻盘NOI2018Ag）的翻盘记录，看着充满希望。</p>\n<p>然后当时中午午休的时候没有宿舍住（因为我走读），就跑到二楼的那个据说是生物竞赛的活动室里面。里面有一台电脑。我中午就躲在里面把门反锁，打开电脑听歌，然后就在那里哭。<br />\n直到有一天，那天的中午我感觉很冷，别人都回去睡觉了，我吃完饭在教室里全身发冷，即使有暖气。然后我就怀揣着希望进了竞赛室。那天竞赛室还有别人，我就没有使用电脑，然后坐在那里。屋子里面开空调了，很暖和<br />\n。过了一会儿，生物竞赛教练进来了。我刚要开口，他就说：谁让你进来的？来着干什么？是不是来这玩电脑？ 然后我想了一会儿，硬生生地没有开口：我是信息竞赛生。然后想了想带上所有东西头也不回的走了。那一瞬间，有一种绝望感，就是一种被世界抛弃了。然后，哪天晚上我就发烧了，结果是感染新冠了。</p>\n<p>自从这件事之后，我突然有一种学不下去省选内容的感觉，而且有一种几乎命中注定的感觉：无论怎么努力省选也不可能翻盘。后来我就很少再跟别人提及OI。直到WC快报名的时候，zgx家长问我家长要不要报，我一看，WC竟然改成线上了，这让我感觉有一种走形式的感觉。我看到之前博客里面大家去WC然后互相交流面基的感觉很快乐，但是这种东西已经没有了。我意识到，WC很贵我要是报了我家长到时候一定拿掏钱这个事来PUA我，于是，我主动拒绝了。就这样，我OI就退役了。从这之后，上大学之前，我就再没有碰过一道算法竞赛题，没有学习任何一个新算法。</p>\n<p>然后，我意识到我回归不了WHK了。之前我设想的我能坦然回归whk至少是省选结束之后，然后按照我自己的节奏好好的学习一下WHK。但是现实是，回归之后，家长/老师对我期望很高，希望我回到扔whk搞OI之前的状态--就是高一下期末660+的状态。而且我根本没有理由向别人说我能自己做好这件事。因为很简单：我只是NOIP低分省一连省选都没打就退役了，也没有什么牌子。所以说实际上他们的期望更高了但是信任度更低了。所以说，我期末考的并不好。当时有点害怕，害怕到高三还是回不到之前的状态。（但是事实证明实际上就算不搞OI我可能也没有一个理想的状态，因为我的精力严重不够）然后寒假就是被家长拉去搞whk了。</p>\n<p>这时候，谁能想到一个东西即将再次撞击我的命运。</p>\n<p>考上少年班之后，当时其实我很高兴。我想到，三年前，我坐在阶梯教室里面，看着台上的学长热情洋溢地讲着自己的大学生活和高中的努力（而且真的看不出是高中生了，明显是适应了大学生活），我幻想着有一天也能像他们一样。但是现在，我的确做到了，甚至说比他们做的更好（毕竟是xha第一个去的），我利用自己的省一奖项，降一本线进入华东五校止一---USTC，这相当于我已经做到了自主招生时代所谓的一本约。我想着我终于可以拾起来我之前没有做的事情，我可以出去转一转，我要出去讲OI课，有一天我也要回学校宣讲。我希望有一天xha有自己的竞赛组织，能够请一些人讲课（就像那些学长博客里面提到的那样学校请他们回去讲课）（我看到一个重庆大学的都被邀请回去了）。我想着我终于能够被承认了，然后我就可以有我的自由，然后就可以有我自己的大学生活了。但是，现实里面有一种隐隐的不详的预感。那天出分之后第二天家长就不让我去学校了，当然说是保护我，我觉得有一点道理。但是我还想着回学校吹一手(bushi).然后问题来了，家长开始PUA我了。大概意思就是考上之后不能放松，要更努力，暑假要提前预习，然后说意思就是我没有这个能力就是运气好之类的...然后我就有一种失落感，总感觉这个不是自己考上的。然后我发现进入重点班之后我开始严重的缺乏安全感，每天都有一种被监视的感觉，当然不是因为重点班内卷，而是有一种刻意营造出来的感觉。所以说我开始缺乏自信。然后家长开始PUA我，所以我暑假也没有自己的自由干事情，而且我也没怎么自己出去，因为我发现自己出去在家里几乎是不可能的，家长总要找一个借口陪着我。客观的讲陪着我当然也很好，但是我还是喜欢和朋友（当然可能是初中朋友）或者是其他搞oi的同学出去。说实话。而且我根本不想预习大学的任何东西因为我OI欠下来的东西还没有填上。再者说我之前也自学过高数。当时我和家长提大学打ICPC，谁知道他们先说什么ICPC再好被退学了有什么用？然后又是开始吵架...然后我暑假去了之前我初二去的那个机构，虽然只学了一年实际上也就是语言入门但是还一直保持联系。结果去了之后我一点也不自在，本来是我考上好学校，而那个机构只有普及组教学的水平，按理来说我是完全有理由平等的过去交流甚至可以去那边讲课。但是现实是我家长去了然后就开始低声下气在那边问大学要准备什么？大学xxx怎么怎么样，然后又是听机构的创始人东扯西扯说一些大道理，但是现实是在那边听一个QDU和石油大学毕业的，而且大概率是计算机学的不怎么样的人的经验没什么参考价值(毕竟这个机构工资不高正经人谁去啊），跟我说的东西和USTC的现实实际上是一点对不上，然后又问ICPC怎么样，结果xxx竟然说什么ICPC对于这种大学没什么用。那我只能说没啥意思了，这就把我家长给忽悠住了，刚好他不想让我大学打ICPC。毕竟现实是USTC 2025 ICPC预选赛报名队伍数量是全国最多的。反正去了一下午感觉很不舒服，就好像在那边受罪一样，全程我都不怎么说话。这件事我就挺失望的。我感觉不管我做到多好都没有人真正认可我。但是为什么他们就能认可别的Oier呢?</p>\n<p>然后暑假家长还是不让我大学打游戏。其实说实话我不愿意打游戏，但是这样我感觉很不舒服，连手机横屏都不敢了。而且现实是我好像连网购都没有网购过。我好像自己买的东西都不敢往家带，因为家长会翻书包，然后就会说我。（之前停课写的纸条被翻出来还挨骂了...)</p>\n<p>暑假时候当时还是缺乏自信不敢找同学玩，但是当时也有人来主动找我，gxh当时来找我，然后本来我们两个玩玩就挺好的，我两个高一上是同班同学，关系也不差。但是非要也不知道为什么家长非要去。那就变成那种无聊的饭局了...然后说是我们两个随便聊，现实是我根本开不了口因为两个家长一直在那边谈什么教育（当然又是经典的那些了...），然后我就在那边看手机，然后家长又骂我一顿说我出去吃饭怎么不说话...</p>\n<p>然后暑假就闷在家里也不知道干什么，被勒令预习，但是肯定是学不下去的，然后别的事情又放松不下来不敢干。我感觉家里已经不是让我放松的地方了...出门就去一趟日照而且感觉挺没意思的...所以说那时候就有一种强烈的感觉，这个学校不是我自己考上的，是别人恩赐给我的...我的能力其实不配。然后一种失望的感觉。</p>\n<p>就这样这个暑假过得很失败，甚至没有调整好开学前的状态，就是我找不到那种我刚开始搞OI时候那种我为了一个美好的事物然后全力的投入尽可能每个方面都做的很好的状态了。</p>\n<p>开学之后，然后你就知道了，彻底的crash...<br />\n而且最重要的是心里一点安全感没有，有一种我所做的一切都在被监视的感觉，根本没法静下心来学习。而且，我又找不到我对计算机的热情了，我只看到了一种很茫然的内卷。然后就是一点点的crash、...</p>\n<p>所以说为什么会这样，还是因为我想要的东西不仅没有被满足反而越来越远了，而且严重的内卷导致曾经我认为很厉害的东西现在可能已经烂大街了，这就消磨了我的热情。更重要的是长久缺失正反馈，失去自信，失去那种自然而然地感觉，相反后来充满着警觉感，在家里不敢和朋友打电话，不敢提出去玩的事情，不敢在家里把手机横屏，在公共场合总感觉别人盯着我，外面手机亮度开到最低总感觉别人在看我的手机屏幕，上课不敢记笔记总感觉别人盯着我。感觉我失去了安全感，或者说我的自由 我的隐私空间 我想做的事情 以及支撑我学OI最大的目标/动力这些并没有随着我考上中科大少创而有所缓解，反而加重了。有一种全世界都在和我作对没有人认可我的感觉，有一种即使很尽力了但是没有人相信我的感觉，所以突然就不想再碰OI了。之前在OI时候立志要培养的良好习惯，包括坚持记笔记，坚持深度思考，提高自控力（因为我确实从小自控力差执行能力差拖延严重，现在我觉得有可能是ADHD？）这些我自己觉得我做的不错的事情没有人相信我，相反我好像就像坐在监牢里面一样，这就是一种深深的失望。而且我又一种我没办法检验我自己全部能力的感觉。我高中基本上不写作业语文英语从来不学，但是高考语文121英语128（平时能上130，毕竟是高二考），所以我认为停课一段时间之后再补WHK并不是很困难的事情，但是没有人相信我。当然也不要指望竞赛圈的人能理解我，毕竟我不混圈，或者说我当时并不想当什么圈子的网红，而且竞赛圈大把人小学开始学习竞赛在强校有着充足的资源进行停课训练，所以说他们都看不上我们这些弱校的。（毕竟我们这一届是第一个NOIP省一喵，当然第一个是zgx）</p>\n<p>为了OI我之前4年不打游戏（其实在学OI之前家里不让打但是偷偷打），然后初二自学初三数学初三自学高中数学离散的部分，然后每个暑假又被家长拉着预习了高中其他科目，高一自学高中数学剩下的部分。高中又自学高数，线代，组合数学的一部分，具体数学，甚至还有一点群论，目的都是为了OI，当时想着我要提高数学水平因为当年NOI2019考了一道具体数学原题，所以我认为OI需要很高的数学水平。虽然我自学时候效率确实很低，经常忍不住往后翻或者干别的，但是的确也学了不少内容。但是即使这样我还是不能停课，然后明明提前自学过还是要开学上课，那我说我寒暑假不要预习其他科目了，反正开学还要上课，但是家长拉着我预习而且还跟我说什么不然就考不上大学，什么竞赛影响文化课就不要弄了，反正我做什么都不会相信我的能力，所以说我久而久之也不知道自己到底有没有这个能力了。然后我的同学后来把我当成小丑看因为他们别的竞赛似乎从来不需要停课，老师也觉得我很菜没有那个水平还整天装。但是现实是我的确也没有那个能力，比如说我的执行能力差，以及容易分心，比如说网上很多的经验是把竞赛资料打印出来课上看，但是现实是课上我根本看不下去过一会儿就会被课程的声音吸引就走神了，自习课能好一点，但是有时候周边同学的打扰就会让我完全静不下心无法思考，甚至我在做题时候如果和机房的zgx交流一点解法（哪怕只是几句话，这就是为什么高中不和别人交流问题了）那么这一晚上基本上做不下去了（现在越看越像ADHD）。但是whk上却不是这样，whk的内容偏简单不需要深度思考，逻辑链很短，更多的是一个心态和熟练度的问题，也就是如何以高正确率保证考场答完题，所以来说，在whk上这些困扰没有体现出来。而且长时间的OI学习让我满脸长痘整天头疼，也完全没有心情打理任何东西，所以外貌和声音也没有以前那么可爱了（现在后悔了...),但是当时想着只要我在OI上拿到牌子那么一切都会好起来，别人就一定会承认我的，所以根本没有在意这些。我以为考上大学之后就能够重新拾起来这些东西看看自己到底有没有这个能力，谁知道那种不被认可的感觉那种失望感让我觉得我的确是废物我没有什么能力。更重要的是我有点失去了目标。而且更重要的是我有一种很强的挫败感，就是我自己想做的事情总是因为各种原因做不好或者达不成希望，这可能就是我执行力太差加上命中缺这一环吧，我好像什么也干不好。大学之后，我原来想要的东西并没有实现，可是，来到科大，我并没有很快开始学习熟悉的计算机，相反，学校的数理基础课程占满了我的时间，别人都在内卷、科研，我想象中一个计算机式的大学生活并没有出现。（至少在我的印象里或者我看到学长宣讲/大佬博客的印象里），而且实际上我好像很多事情都还不会做。<br />\n高中时候实际上和同学关系也不算太差，但是也没有特别好的朋友 ，实际上也没什么社交，对异性也没什么兴趣（甚至说对性行为没什么兴趣）。高中也没有手机也不看什么娱乐的，虽然我破解了学校的学习平板，但是只是在上面看数学书/oi题/知乎上的学习性文章。生活上面实际上我很希望自由甚至说某种意义上学OI本身就是为了追求某种自由，但是高中时候学校家长没有给我这些，当时我也不是很在意因为所有心思都在OI上面，但是现在当我真正需要这些东西的时候发现好像我做不好生活上面的一些小事（当然也许是有ADHD导致的？），而且就像前面说的那样我失去了安全感。</p>\n<p>然后现在好想放松一下。</p>\n\n</div>\n<div id=\"MySignature\">\n    <p>黄粱一梦，终是一空</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/hicode002/\" target=\"_blank\">hicode002</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/hicode002/p/-/oi-memories\" target=\"_blank\">https://www.cnblogs.com/hicode002/p/-/oi-memories</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 11:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hicode002\">hicode002</a>&nbsp;\n阅读(<span id=\"post_view_count\">67</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Stern-Brocot 树",
      "link": "https://www.cnblogs.com/rgw2010/p/19525731",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rgw2010/p/19525731\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 11:39\">\n    <span>Stern-Brocot 树</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"p1797-模板stern-brocot-树\"><a href=\"https://www.luogu.com.cn/problem/P1797\" rel=\"noopener nofollow\" target=\"_blank\">P1797 【模板】Stern-Brocot 树</a></h2>\n<p><a href=\"https://www.luogu.com.cn/article/dv07cla2\" rel=\"noopener nofollow\" target=\"_blank\"><strong>洛谷同步题解。</strong></a></p>\n<blockquote>\n<p>前置知识：<span class=\"math inline\">\\(a \\perp b\\)</span> 等价于存在 <span class=\"math inline\">\\(x, y\\)</span> 使得 <span class=\"math inline\">\\(ax + by = 1\\)</span>。</p>\n</blockquote>\n<p>Stern-Brocot 树是一个包含着所有 <span class=\"math inline\">\\(m \\perp n\\)</span> 的全部非负的分数 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 的二叉树结构；其思想是从 <span class=\"math inline\">\\(0\\)</span> 阶 Stern-Brocot 序列 <span class=\"math inline\">\\(\\{\\frac{0}{1}, \\frac{1}{0} \\}\\)</span> 出发，高阶 Stern-Brocot 序列由以下递归操作定义：</p>\n<ul>\n<li>对于一个 <span class=\"math inline\">\\(k\\)</span> 阶 Stern-Brocot 序列，在其任意两个相邻分数 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 与 <span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 之间插入它们的<strong>中位分数</strong> <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span> 后形成的序列即为 <span class=\"math inline\">\\(k + 1\\)</span> 阶  Stern-Brocot 序列。</li>\n</ul>\n<p>例如：</p>\n<ul>\n<li>\n<p><span class=\"math inline\">\\(1\\)</span> 阶是 <span class=\"math inline\">\\(\\{ \\frac{0}{1}, \\frac{1}{1}, \\frac{1}{0} \\}\\)</span>。</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(2\\)</span> 阶是 <span class=\"math inline\">\\(\\{ \\frac{0}{1}, \\frac{1}{2}, \\frac{1}{1}, \\frac{2}{1}, \\frac{1}{0} \\}\\)</span>。</p>\n</li>\n<li>\n<p><span class=\"math inline\">\\(3\\)</span> 阶是 <span class=\"math inline\">\\(\\{ \\frac{0}{1}, \\frac{1}{3}, \\frac{1}{2}, \\frac{2}{3}, \\frac{1}{1}, \\frac{3}{2}, \\frac{2}{1}, \\frac{3}{1}, \\frac{1}{0} \\}\\)</span>。</p>\n</li>\n</ul>\n<p>容易看作二叉树的结构：</p>\n<ul>\n<li>每个分数都是 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span> 的形式，其中 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 是左上方离它最近的祖先，<span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 是右上方离它最近的祖先。</li>\n</ul>\n<p>oi-wiki 上的图较为形象，大家可以看着理解下：</p>\n<p><img alt=\"\" src=\"https://oi-wiki.org/math/number-theory/images/stern-brocot-tree.svg\" /></p>\n<p>为什么树上的都是最简分数？为什么不会重复出现某个分数？为什么所有可能的非负的最简分数都会在树上出现？</p>\n<p>容易发现这样一个性质，如果 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 和 <span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 在某一阶的 Stern-Brocot 序列中相邻，那么必然满足：</p>\n<p></p><div class=\"math display\">\\[m'n - mn' = 1\n\\]</div><p></p><blockquote>\n<p>证明考虑数学归纳法，初始 <span class=\"math inline\">\\(0\\)</span> 阶时有 <span class=\"math inline\">\\(1 \\cdot 1 - 0 \\cdot 0 = 1\\)</span>；若当前 <span class=\"math inline\">\\(k\\)</span> 阶 Stern-Brocot 序列中满足条件，那么在 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span> 与 <span class=\"math inline\">\\(\\frac{m'}{n'}\\)</span> 中间插入的 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span>，相当于要证明：</p>\n<p></p><div class=\"math display\">\\[(m' + m)n - m(n + n') = 1\n\\]</div><p></p><p></p><div class=\"math display\">\\[m'(n + n') - (m + m') n' = 1\n\\]</div><p></p><p>第一个直接拆开 <span class=\"math inline\">\\(m'n + mn - mn - mn' = m'n - mn' = 1\\)</span>，第二个同理；于是得证。</p>\n</blockquote>\n<p>同时，上面 <span class=\"math inline\">\\(m'n - mn' = 1\\)</span> 这个式子也可以说明 <span class=\"math inline\">\\(m \\perp n, m' \\perp n'\\)</span>，那么可以得到树上的所有分数必然是<strong>最简分数</strong>。</p>\n<p>然后来考虑插入的分数的大小关系，显然有：</p>\n<p></p><div class=\"math display\">\\[\\frac{m}{n} &lt; \\frac{m + m'}{n + n'} &lt; \\frac{m'}{n}\n\\]</div><p></p><p>即一个中位分数在它原先两个值的中间，于是树上必然没有重复的分数。</p>\n<p>好，接下来要证所有正的最简分数 <span class=\"math inline\">\\(\\frac{a}{b}\\)</span> 都在树上出现，考虑反证法，初始显然：</p>\n<p></p><div class=\"math display\">\\[\\frac{m = 0}{n = 1} &lt; \\frac{a}{b} &lt; \\frac{m' = 1}{n' = 0}\n\\]</div><p></p><p>然后假设当前阶段有：</p>\n<p></p><div class=\"math display\">\\[\\frac{m}{n} &lt; \\frac{a}{b} &lt; \\frac{m'}{n'}\n\\]</div><p></p><p>考虑 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'}\\)</span> 与 <span class=\"math inline\">\\(\\frac{a}{b}\\)</span> 的大小关系：</p>\n<ul>\n<li>\n<p>若 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'} = \\frac{a}{b}\\)</span>，与命题矛盾，退出。</p>\n</li>\n<li>\n<p>若 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'} &lt; \\frac{a}{b}\\)</span>，令 <span class=\"math inline\">\\(m \\gets m + m', n' + n\\)</span>。</p>\n</li>\n<li>\n<p>否则 <span class=\"math inline\">\\(\\frac{m + m'}{n + n'} &gt; \\frac{a}{b}\\)</span>，令 <span class=\"math inline\">\\(m' \\gets m + m', n' \\gets n + n'\\)</span>。</p>\n</li>\n</ul>\n<p>考虑证明这个过程不会无限进行下去，因为：</p>\n<p></p><div class=\"math display\">\\[\\begin{cases} \\frac{a}{b} - \\frac{m}{n} &gt; 0 \\\\ \\frac{m'}{n'} - \\frac{a}{b} &gt; 0 \\end{cases}\n\\]</div><p></p><p>即：</p>\n<p></p><div class=\"math display\">\\[\\begin{cases} an - mb &gt; 0 \\\\ m'b - n'a &gt; 0 \\end{cases}\n\\]</div><p></p><p>显然 <span class=\"math inline\">\\(an - mb, m'b - n'a\\)</span> 都是整数，于是：</p>\n<p></p><div class=\"math display\">\\[\\begin{cases} an - mb \\ge 1 \\\\ m'b - n'a \\ge 1 \\end{cases}\n\\]</div><p></p><p>然后必然有：</p>\n<p></p><div class=\"math display\">\\[(m' + n')(an - mb) + (m + n)(m'b - n'a) \\ge m' + n' + m + n\n\\]</div><p></p><p>前面把 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(b\\)</span> 专门提出来：</p>\n<p></p><div class=\"math display\">\\[a(n(m' + n') - n'(m + n)) + b(m'(m + n) - m(m' + n'))\n\\]</div><p></p><p>然后它们的系数可以根据 <span class=\"math inline\">\\(m'n - mn' = 1\\)</span> 化简成 <span class=\"math inline\">\\(1\\)</span>，于是：</p>\n<p></p><div class=\"math display\">\\[a + b \\ge m' + n' + m + n\n\\]</div><p></p><p>而上面每次操作中 <span class=\"math inline\">\\(m' + n' + m + n\\)</span> 都会增加，于是至多进行 <span class=\"math inline\">\\(a + b\\)</span> 次后就会退出，即找到 <span class=\"math inline\">\\(\\frac{a}{b}\\)</span>；于是证明了<strong>所有非负分数即正有理数</strong>都在树上，可以将 Stern-Brocot 树看作一个<strong>有理数的数系</strong>。</p>\n<p>因为每个正最简分数只出现一次，所以其与树上从根到它的路径是一一对应的，即我们可以用字母 <span class=\"math inline\">\\(L, R\\)</span> 来表示当前节点是往左右哪个儿子去走，一串 <span class=\"math inline\">\\(L, R\\)</span> 组成的序列就唯一的表示了一个位置；例如 <span class=\"math inline\">\\(LRRL\\)</span> 表示 <span class=\"math inline\">\\(\\frac{1}{1} \\to \\frac{1}{2} \\to \\frac{2}{3} \\to \\frac{3}{4} \\to \\frac{5}{7}\\)</span>；特别的，对于 <span class=\"math inline\">\\(\\frac{1}{1}\\)</span> 用 <span class=\"math inline\">\\(I\\)</span> 来表示。</p>\n<p>考虑这样一个问题，给出一组 <span class=\"math inline\">\\(L, R\\)</span> 组成的字符串 <span class=\"math inline\">\\(S\\)</span>，求出其对应的分数是什么？</p>\n<p>容易想到从初始 <span class=\"math inline\">\\(\\frac{1}{1}\\)</span> 开始，动态维护这个点是由左右哪两个节点合并的，初始是 <span class=\"math inline\">\\(\\frac{m = 0}{n = 1}, \\frac{m' = 1}{n' = 0}\\)</span>：</p>\n<ul>\n<li>\n<p>若 <span class=\"math inline\">\\(L\\)</span> 往左走：那么左祖先不会变，右祖先会变成当前节点；即 <span class=\"math inline\">\\(m' \\gets m + m', n' \\gets n + n'\\)</span>。</p>\n</li>\n<li>\n<p>若 <span class=\"math inline\">\\(R\\)</span> 往右左：同理，那么右祖先不会变，左祖先会变成当前节点；即 <span class=\"math inline\">\\(m \\gets m + m', n \\gets n + n'\\)</span>。</p>\n</li>\n</ul>\n<p>大家理解的时候可以看前面那个树的图来理解；然后我们就可以写下如下代码解决：</p>\n<pre><code class=\"language-cpp\">inline pair&lt;int, int&gt; getLR(string s){\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i] == 'L')\n\t\t  m_ = m + m_, n_ = n + n_;\n\t\telse\n\t\t  m = m + m_, n = n + n_;\n\t}\n\treturn mkp(m + m_, n + n_);\n}\n</code></pre>\n<p>当长度很长时，即给定是 <span class=\"math inline\">\\(L/R\\)</span> 每次走几次，也可以根据式子直接做：</p>\n<pre><code class=\"language-cpp\">inline pair&lt;int, int&gt; getLR(vector&lt;pair&lt;char, int&gt;&gt; s){\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i].fi == 'L')\n\t\t\tm_ = s[i].se * m + m_, n_ = s[i].se * n + n_;\n\t\telse\n\t\t\tm = m + s[i].se * m_, n = n + s[i].se * n_;\n\t}\n\treturn mkp(m + m_, n + n_);\n}\n</code></pre>\n<p>这种还是太程序性了，数学语言怎么表示？容易想到矩阵，即初始：</p>\n<p></p><div class=\"math display\">\\[M(S) = \\begin{pmatrix} n &amp; n' \\\\ m &amp; m' \\end{pmatrix}\n\\]</div><p></p><p>这里为啥不用像分数那样上面分子下面分母呢？主要是此时初始根节点的状态 <span class=\"math inline\">\\(M(I) =  \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}\\)</span> 这是一个单位矩阵，而用分数的表示形式的话不是单位矩阵要多乘一个矩阵，形式上也不那么清晰。</p>\n<p>然后考虑：</p>\n<p></p><div class=\"math display\">\\[M(SL) = \\begin{pmatrix} n &amp; n + n' \\\\ m &amp; m + m' \\end{pmatrix}\n\\]</div><p></p><p></p><div class=\"math display\">\\[M(SR) = \\begin{pmatrix} n + n' &amp; n' \\\\ m + m' &amp; m' \\end{pmatrix}\n\\]</div><p></p><p>那么可以推出 <span class=\"math inline\">\\(L, R\\)</span> 矩阵：</p>\n<p></p><div class=\"math display\">\\[L = \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix}\n\\]</div><p></p><p></p><div class=\"math display\">\\[R = \\begin{pmatrix} 1 &amp; 0 \\\\ 1 &amp; 1 \\end{pmatrix}\n\\]</div><p></p><p>即：</p>\n<p></p><div class=\"math display\">\\[M(SL) = M(S) L, M(SR) = M(S) R\n\\]</div><p></p><p>于是求 <span class=\"math inline\">\\(M(S)\\)</span> 时，可以看作是 <span class=\"math inline\">\\(S\\)</span> 中的 <span class=\"math inline\">\\(L, R\\)</span> 作矩阵乘法，例如 <span class=\"math inline\">\\(M(LRRL) = LRRL = \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 &amp; 0 \\\\ 1 &amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 &amp; 0 \\\\ 1 &amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix} = \\begin{pmatrix} 3 &amp; 4 \\\\ 2 &amp; 3 \\end{pmatrix}\\)</span>。</p>\n<p>于是求 <span class=\"math inline\">\\(S\\)</span> 所对应的分数只需要经过矩阵运算得到：</p>\n<p></p><div class=\"math display\">\\[f(S) = f(\\begin{pmatrix} n &amp; n' \\\\ m &amp; m' \\end{pmatrix}) = \\frac{m + m'}{n + n'}\n\\]</div><p></p><p>那么现在考虑给定一个分数 <span class=\"math inline\">\\(\\frac{m}{n}\\)</span>，求其唯一对应 <span class=\"math inline\">\\(LR\\)</span> 序列这个问题？这就比较简单了，根据生成规则，我们知道 Stern-Brocot 树是一颗二叉搜索树，即左子树的点都比它小，右子树的点都比它大，于是可以通过比较与当前位置的值来决定。</p>\n<p>那么可以写下如下代码：</p>\n<pre><code class=\"language-cpp\">inline string backLR(int m, int n){\n\tstring ans = \"\";\n\tMat S;\n\twhile(1){\n\t\tauto t = f(S);\n\t\tif(t == mkp(m, n))\n\t\t  break;\n\t\tif(mkp(m, n) &lt; t){\n\t\t\tS = S * L;\n\t\t\tans.push_back('L');\n\t\t}\n\t\telse{\n\t\t\tS = S * R;\n\t\t\tans.push_back('R');\n\t\t}\n\t}\n\treturn ans;\n}\n</code></pre>\n<p>显然，这个效率较为低下，且要进行矩阵运算；考虑怎么优化一下，注意到：</p>\n<p></p><div class=\"math display\">\\[RS = \\begin{pmatrix} n &amp; n' \\\\ m + n &amp; m'  + n'\\end{pmatrix}\n\\]</div><p></p><p></p><div class=\"math display\">\\[LS = \\begin{pmatrix} n + m&amp; n' + m' \\\\ m&amp; m'\\end{pmatrix}\n\\]</div><p></p><p>那么：</p>\n<p></p><div class=\"math display\">\\[f(RS) = \\frac{n + n'}{m + n + m' + n'} = f(S) + 1\n\\]</div><p></p><p></p><div class=\"math display\">\\[f(LS) = \\frac{n + m + n' + m'}{m + m'}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\frac{1}{f(LS)} = \\frac{1}{f(LS)} + 1\n\\]</div><p></p><p>设 <span class=\"math inline\">\\(F(\\frac{p}{q})\\)</span> 表示其对应的字符串；那么我们可以看出，若第一步为 <span class=\"math inline\">\\(R\\)</span>，则 <span class=\"math inline\">\\(\\frac{m}{n} &gt; 1\\)</span>，否则第一步为 <span class=\"math inline\">\\(L\\)</span>，则 <span class=\"math inline\">\\(\\frac{m}{n} &lt; 1\\)</span>，于是可以递归的去做：</p>\n<p></p><div class=\"math display\">\\[\\frac{m}{n} = f(RS) \\to \\frac{m - n}{n} = f(S)  (m &gt; n)\n\\]</div><p></p><p></p><div class=\"math display\">\\[F(\\frac{m}{n}) = R + F(\\frac{n}{m - n}) (m &gt; n)\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\frac{m}{n} = f(LS) \\to \\frac{m}{n - m} = f(S) (m &lt; n)\n\\]</div><p></p><p></p><div class=\"math display\">\\[F(\\frac{m}{n}) = L + F(\\frac{m}{n - m}) (m &lt;n)\n\\]</div><p></p><p>那么可以写出如下代码：</p>\n<pre><code class=\"language-cpp\">inline string backLR(int m, int n){\n\tstring ans = \"\";\n\twhile(m != n){\n\t\tif(m &lt; n){\n\t\t\tans.push_back('L');\n\t\t\tn = n - m;\n\t\t}\n\t\telse{\n\t\t\tans.push_back('R');\n\t\t\tm = m - n;\n\t\t}\n\t}\n\treturn ans;\n}\n</code></pre>\n<p>你发现这特别像更像减损法，于是可以用辗转相除法类似的思路去优化，即：</p>\n<pre><code class=\"language-cpp\">inline vector&lt;pair&lt;char, int&gt;&gt; backLR(int m, int n){\n\tvector&lt;pair&lt;char, int&gt;&gt; ans;\n\twhile(m &amp;&amp; n &amp;&amp; m != n){\n\t\tif(m &lt; n){\n\t\t\tif(n % m == 0)\n\t\t\t  ans.push_back({'L', n / m - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'L', n / m});\n\t\t\tn = n % m;\n\t\t}\n\t\telse{\n\t\t\tif(m % n == 0)\n\t\t\t  ans.push_back({'R', m / n - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'R', m / n});\n\t\t\tm = m % n;\n\t\t}\n\t}\n\treturn ans;\n}\n</code></pre>\n<p>此时就可以做到 <span class=\"math inline\">\\(O(\\log n)\\)</span> 复杂度去找对应的路径。</p>\n<p>然后对于一个分数 <span class=\"math inline\">\\(\\frac{p}{q}\\)</span>，考虑其在树上一个子树 <span class=\"math inline\">\\(S\\)</span>，显然 <span class=\"math inline\">\\(S\\)</span> 是无限大的，但是显然其有界，在 <span class=\"math inline\">\\((\\frac{a}{b}, \\frac{c}{d})\\)</span> 之间，那么怎么求出 <span class=\"math inline\">\\(a, b, c, d\\)</span> 呢？回到前面每次插入的中位分数在两个值之间的性质，于是这只是换一个问法，显然只是在问合并出 <span class=\"math inline\">\\(\\frac{p = a + c}{q = b + d}\\)</span> 的是哪两个分数，比较简单，求出 <span class=\"math inline\">\\(\\frac{p}{q}\\)</span> 的 <span class=\"math inline\">\\(LR\\)</span> 串后模拟一下即可。</p>\n<p>对于树上问题，容易想到 LCA，那么考虑 Stern-Brocot 树上的两个点 <span class=\"math inline\">\\(\\frac{a}{b}, \\frac{c}{d}\\)</span>，怎么求出它们的 LCA？容易发现，找到 <span class=\"math inline\">\\(\\frac{a}{b}, \\frac{c}{d}\\)</span> 的 <span class=\"math inline\">\\(LR\\)</span> 串 <span class=\"math inline\">\\(F(\\frac{a}{c}), F(\\frac{c}{d})\\)</span>，它们 LCP 的长度就是它们 LCA 的深度；而这个长度是容易求的，然后它们的 LCA 就是这个 LCP 对应的节点，套用上面函数一下即可。</p>\n<p>同理，<span class=\"math inline\">\\(\\frac{p}{q}\\)</span> 的树上 <span class=\"math inline\">\\(k\\)</span> 级祖先也是可以算出 <span class=\"math inline\">\\(F(\\frac{p}{q})\\)</span> 后删掉末尾的 <span class=\"math inline\">\\(k\\)</span> 个字符后套用前面函数得出。</p>\n<p>显然单次时间复杂度都是 <span class=\"math inline\">\\(O(\\log w)\\)</span>，总时间复杂度为 <span class=\"math inline\">\\(O(T \\log w)\\)</span>。</p>\n<p><a href=\"https://www.luogu.com.cn/record/258759645\" rel=\"noopener nofollow\" target=\"_blank\">link</a></p>\n<h3 id=\"完整代码\">完整代码：</h3>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\n#define ls(k) k &lt;&lt; 1\n#define rs(k) k &lt;&lt; 1 | 1\n#define lowbit(x) x &amp; (-x)\n#define fi first\n#define se second\n#define popcnt(x) __builtin_popcount(x)\n#define open(s1, s2) freopen(s1, \"r\", stdin), freopen(s2, \"w\", stdout);\n#define mkp(x, y) make_pair(x, y)\nusing namespace std;\ntypedef __int128 __;\ntypedef long double lb;\ntypedef double db;\ntypedef unsigned long long ull;\ntypedef long long ll;\nbool Begin;\ninline ll read(){\n\tll x = 0, f = 1;\n\tchar c = getchar();\n\twhile(c &lt; '0' || c &gt; '9'){\n\t\tif(c == '-')\n\t\t\tf = -1;\n\t\tc = getchar();\n\t}\n\twhile(c &gt;= '0' &amp;&amp; c &lt;= '9'){\n\t\tx = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);\n\t\tc = getchar();\n\t}\n\treturn x * f;\n}\ninline void write(ll x){\n\tif(x &lt; 0){\n\t\tputchar('-');\n\t\tx = -x;\n\t}\n\tif(x &gt; 9)\n\t\twrite(x / 10);\n\tputchar(x % 10 + '0');\n}\ninline pair&lt;int, int&gt; getLR(vector&lt;pair&lt;char, int&gt;&gt; s){\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i].fi == 'L')\n\t\t\tm_ = s[i].se * m + m_, n_ = s[i].se * n + n_;\n\t\telse\n\t\t\tm = m + s[i].se * m_, n = n + s[i].se * n_;\n\t}\n\treturn mkp(m + m_, n + n_);\n}\ninline vector&lt;pair&lt;char, int&gt;&gt; backLR(int m, int n){\n\tvector&lt;pair&lt;char, int&gt;&gt; ans;\n\twhile(m &amp;&amp; n &amp;&amp; m != n){\n\t\tif(m &lt; n){\n\t\t\tif(n % m == 0)\n\t\t\t  ans.push_back({'L', n / m - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'L', n / m});\n\t\t\tn = n % m;\n\t\t}\n\t\telse{\n\t\t\tif(m % n == 0)\n\t\t\t  ans.push_back({'R', m / n - 1});\n\t\t\telse\n\t\t\t  ans.push_back({'R', m / n});\n\t\t\tm = m % n;\n\t\t}\n\t}\n\treturn ans;\n}\ninline pair&lt;int, int&gt; getkfa(int m, int n, int k){\n\tauto V = backLR(m, n);\n\tint sum = 0, len = V.size();\n\tfor(int i = 0; i &lt; len; ++i)\n\t  sum += V[i].se;\n\tif(sum &lt; k)\n\t  return mkp(-1, -1);\n\tvector&lt;pair&lt;char, int&gt;&gt; fa;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(!k)\n\t\t  break;\n\t\tif(V[i].se &lt;= k){\n\t\t\tfa.push_back(V[i]);\n\t\t\tk -= V[i].se;\n\t\t}\n\t\telse{\n\t\t\tfa.push_back(mkp(V[i].fi, k));\n\t\t\tk = 0;\n\t\t}\n\t}\n\treturn getLR(fa);\n}\ninline pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt;&gt; range(int p, int q){\n\tauto s = backLR(p, q);\n\tint len = s.size();\n\tint m = 0, n = 1, m_ = 1, n_ = 0;\n\tfor(int i = 0; i &lt; len; ++i){\n\t\tif(s[i].fi == 'L')\n\t\t\tm_ = s[i].se * m + m_, n_ = s[i].se * n + n_;\n\t\telse\n\t\t\tm = m + s[i].se * m_, n = n + s[i].se * n_;\n\t}\n\treturn mkp(mkp(m, n), mkp(m_, n_));\n}\ninline pair&lt;int, int&gt; getlca(int a, int b, int c, int d){\n\tauto A = backLR(a, b), B = backLR(c, d);\n\tint s1 = 0, s2 = 0;\n\tfor(auto v : A)\n\t  s1 += v.se;\n\tfor(auto v : B)\n\t  s2 += v.se;\n\tif(s1 &lt; s2){\n\t\tswap(a, c), swap(b, d);\n\t\tswap(A, B);\n\t}\n\tvector&lt;pair&lt;char, int&gt;&gt; lca;\n\tint j = 0;\n\tfor(int i = 0; i &lt; (int)A.size(); ++i){\n\t\tint s = A[i].se;\n\t\twhile(j &lt; (int)B.size() &amp;&amp; s){\n\t\t\tif(B[j].fi != A[i].fi)\n\t\t\t  break;\n\t\t\tif(B[j].se &lt;= s){\n\t\t\t\ts -= B[j].se;\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[j].se -= s;\n\t\t\t\ts = 0;\n\t\t\t}\n\t\t}\n\t\tif(j == (int)B.size() || s){\n\t\t\tlca.push_back(mkp(A[i].fi, A[i].se - s));\n\t\t\tbreak;\n\t\t}\n\t\tlca.push_back(A[i]);\n\t}\n\treturn getLR(lca);\n}\nint T, a, b, c, d, p, q, len, x, k;\nchar C;\nchar op[20];\nint main(){\n\tT = read();\n\twhile(T--){\n\t\tscanf(\"%s\", op);\n\t\tif(op[0] == 'E'){\n\t\t\tp = read(), q = read();\n\t\t\tauto V = backLR(p, q);\n\t\t\twrite(V.size());\n\t\t\tputchar(' ');\n\t\t\tfor(auto t : V){\n\t\t\t\tputchar(t.fi);\n\t\t\t\tputchar(' ');\n\t\t\t\twrite(t.se);\n\t\t\t\tputchar(' ');\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(op[0] == 'D'){\n\t\t\tvector&lt;pair&lt;char, int&gt;&gt; V;\n\t\t\tlen = read();\n\t\t\twhile(len--){\n\t\t\t\tC = getchar();\n\t\t\t\tx = read();\n\t\t\t\tV.push_back({C, x});\n\t\t\t}\n\t\t\tauto t = getLR(V);\n\t\t\twrite(t.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se);\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(op[0] == 'L'){\n\t\t\ta = read(), b = read(), c = read(), d = read();\n\t\t\tauto t = getlca(a, b, c, d);\n\t\t\twrite(t.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se);\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(op[0] == 'A'){\n\t\t\tk = read(), a = read(), b = read();\n\t\t\tauto t = getkfa(a, b, k);\n\t\t\tif(t.fi &lt; 0){\n\t\t\t\tputs(\"-1\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twrite(t.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se);\n\t\t\tputchar('\\n');\t\t\t\n\t\t}\n\t\telse{\n\t\t\ta = read(), b = read();\n\t\t\tauto t = range(a, b);\n\t\t\twrite(t.fi.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.fi.se);\n\t\t\tputchar(' ');\t\n\t\t\twrite(t.se.fi);\n\t\t\tputchar(' ');\n\t\t\twrite(t.se.se);\n\t\t\tputchar('\\n');\t\n\t\t}\n\t}\n\treturn 0;\n}\n</code></pre>\n<h3 id=\"uva11350-stern-brocot-tree\"><a href=\"https://www.luogu.com.cn/problem/UVA11350\" rel=\"noopener nofollow\" target=\"_blank\">UVA11350 Stern-Brocot Tree</a></h3>\n<p><a href=\"https://www.luogu.com.cn/article/ol2ri7ez\" rel=\"noopener nofollow\" target=\"_blank\"><strong>洛谷同步题解。</strong></a></p>\n<p>模版这有，使用 <code>getLR</code> 即可。</p>\n<p><a href=\"https://www.luogu.com.cn/record/258771627\" rel=\"noopener nofollow\" target=\"_blank\">link</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 11:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rgw2010\">rgw2010</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "新书《鸿蒙HarmonyOS 6应用开发：从零基础到App上线》出版啦",
      "link": "https://www.cnblogs.com/aqi00/p/19504825",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19504825\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 11:23\">\n    <span>新书《鸿蒙HarmonyOS 6应用开发：从零基础到App上线》出版啦</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span><span>​</span></span><span id=\"cke_bm_160S\">基于最新鸿蒙系统的技术书籍《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》上市啦，要知道 HarmonyOS 6 在一个多月前的10月22日才正式发布，因此这本鸿蒙教程可谓贴近最新的 HarmonyOS 6 系统。</span>\n<p><span id=\"cke_bm_160S\"> 当前 HarmonyOS 6 的装机量迅猛增长，有望在春节前突破5000万台大关，可见鸿蒙系统的应用开发将越来越流行，甚至借助国产化的浪潮，未来在国内移动操作系统领域一举夺魁也不是不可能。<br />\n有鉴于此，博主精心编撰了 HarmonyOS 6 的应用开发教程《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》，从基础到高级，从理论到实战，从 UI 到 AI ，仅需一本书籍，即可让读者掌握鸿蒙应用的常见开发技能。</span></p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"鸿蒙应用开发\" class=\"lazyload\" height=\"436\" width=\"436\" /></span></span></span></span></p>\n<p>鸿蒙应用开发与安卓应用开发同为App开发，比如鸿蒙版微信和安卓版微信都是即时通信App，二者在实现技术上并无多少本质区别。所以《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》一书以《Android Studio开发实战：从零基础到App上线(第3版)》为蓝本，把安卓系统的App教程改造为鸿蒙系统的App教程，以便安卓开发者能够按图索骥迅速上手。欣喜的是，《Android Studio开发实战：从零基础到App上线(第3版)》提到的安卓开发技术，绝大部分都能在鸿蒙系统找到对应的平替技术，而且还是更简单的代码实现。<br />\n作为《Android Studio开发实战：从零基础到App上线(第3版)》一书的鸿蒙姊妹篇，《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》仍然采取了由浅入深、循序渐进的章节体例，其中前8章是基础部分，主要讲解 DevEco Studio 的环境搭建、ArkTS语言编程基础、鸿蒙App开发的各种常用组件、鸿蒙App开发的页面转场和消息交互、鸿蒙App的几种数据存储方式等；后8章是进阶部分，主要讲解鸿蒙App开发的后台任务、手势交互、动画特效、网络通信、多媒体、感知定位、人工智能、多端部署等。</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"android第三版\" class=\"lazyload\" height=\"439\" width=\"439\" /></span></span></span></span></p>\n<p>曾经有老读者咨询“从零基础到App上线”系列书籍的第4版何时面世，现在博主终于可以说，“从零基础到App上线”的第4版已经出版啦，而且第4版是鸿蒙版本的“从零基础到App上线”，它就叫做《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》，该书把安卓版教程平替为鸿蒙版教程，也是一个勇敢的尝试。<br />\n《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》在讲解知识点的同时给出了大量实战范例，方便读者迅速将所学的知识运用到实际开发中。通过本书的学习，读者能够掌握3类主流App的基本开发技术，包括购物App（电子商务）、聊天App（即时通信）、娱乐App（短视频分享）。另外，能够学会开发一些趣味应用，包括计算器、录音笔、电子相册、打牌游戏、指南针、水平仪、卫星浑天仪、登山助手、附近交友、速记助手、人脸识别等等。可见《Android Studio开发实战：从零基础到App上线(第3版)》一书提到的实战项目，本书基本提供了对应的鸿蒙版App。</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"鸿蒙系统\" class=\"lazyload\" height=\"237\" width=\"558\" /></span></span></span></span></p>\n<p>《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》的随书源码包括客户端部分和服务端部分，其中客户端的App代码基于 DevEco Studio 6.0.0 Release 开发，并使用 API 20 的 SDK （HarmonyOS 6.0.0）编译与调试通过，测试机型包括 Mate 60 Pro 和 nova 12 Pro 。配套的服务端源码采用 Java WEB 框架，结合 MySQL 数据库，并基于 IDEA 开发。<br />\n为了便于读者学习鸿蒙应用编程，《鸿蒙HarmonyOS 6应用开发:从零基础到App上线》同时提供了随书源码和课件PPT，这些下载资源可以扫描该书前言末尾的二维码获得。最新的随书源码也可访问我的码云主页，下载页面是 https://gitee.com/aqi00/harmony 。</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 11:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">67</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "开发 Java MCP 就像写 Controller 一样简单，还支持 Java 8",
      "link": "https://www.cnblogs.com/noear/p/19525390",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/noear/p/19525390\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 10:20\">\n    <span>开发 Java MCP 就像写 Controller 一样简单，还支持 Java 8</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Solon-AI框架为Java开发者提供了便捷的MCP协议集成方案，使老版本Java项目也能接入AI Agent生态。通过注解开发、动态构建工具、协议代理转换等特性，开发者无需研究复杂协议即可快速构建MCP服务端。框架还支持反向通讯和“三合一”客户端，实现了完整的AI能力整合，大幅降低了Java应用接入群体智能的门槛。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在 AI 应用开发从“单机对话”迈向“群体智能（Agent）”的当下，MCP（Model Context Protocol） 协议的出现，为大模型连接外部世界统一了“插座”。</p>\n<p>但，当 Anthropic 的 MCP 协议火遍 AI 圈时，很多 Java 开发者看了一眼官方 SDK 的环境要求（Java 17+）便望而却步。难道 Java 8、Java 11 的老项目注定要与 AI Agent 时代无缘吗？</p>\n<p>Solon-AI 给出了截然不同的答案。 在这里，开发一个标准的 MCP Server，不需要你去研究复杂的 JSON-RPC 通讯逻辑，也不需要升级你的 JDK。只需要几个注解，就像写普通的 Web 控制器一样简单。</p>\n<h2 id=\"一-为什么-java-开发者需要-mcp\">一、 为什么 Java 开发者需要 MCP？</h2>\n<p>在 MCP 出现之前，虽然各大模型都支持 Tool Call，但由于缺乏统一标准，开发者不得不针对不同厂商编写互不兼容的私有接口适配代码。MCP 的出现，为模型与工具之间建立了一套通用的“通讯语言”。</p>\n<h3 id=\"mcp-彻底改变了游戏规则\">MCP 彻底改变了游戏规则：</h3>\n<ul>\n<li>一次编写，到处运行：你写的 MCP Server 可以同时给 Claude Desktop、IDE 或你自己的 Solon 应用使用。</li>\n<li>生态复用：GitHub 上现成的 Python/Node.js MCP 工具，Java 开发者现在可以通过 Solon-AI 的 McpClient 瞬间“拿来主义”。</li>\n</ul>\n<h2 id=\"二-solon-ai为-mcp-而生的-java-框架\">二、 Solon-AI：为 MCP 而生的 Java 框架</h2>\n<p>Solon-AI 是 Java 生态中率先深度集成 MCP 协议的开发框架。它不仅简化了服务端的构建，更通过高度抽象的客户端接口，让 Java 应用具备了强大的 AI 整合能力。</p>\n<h3 id=\"核心依赖\">核心依赖：</h3>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.noear&lt;/groupId&gt;\n    &lt;artifactId&gt;solon-ai-mcp&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"1-像写-controller-一样写-mcp-server\">1. 像写 Controller 一样写 Mcp Server</h3>\n<p>在 Solon-AI 中，你不需要研究复杂的 JSON-RPC 协议，也不需要手撸难以维护的原生 MCP Java SDK 代码。通过 <code>@ToolMapping</code>、<code>@ResourceMapping</code> 和 <code>@PromptMapping</code>，你可以将任何 Java 方法快速转变为 AI 可识别的工具。</p>\n<pre><code class=\"language-java\">@McpServerEndpoint(name = \"it-tools\", channel = McpChannel.STREAMABLE, mcpEndpoint = \"/mcp\")\npublic class MyMcpServer {\n    @ToolMapping(description = \"查询服务器负载\")\n    public String getServerLoad(@Param(\"serverId\") String id， @Header(\"token\") String token) {\n        return \"Server \" + id + \" load is 15%\";\n    }\n}\n</code></pre>\n<p>提示：启动项目后，即可使用 McpClientProvider 或 Claude Desktop 连接端点进行测试。</p>\n<h3 id=\"2除了注解开发外支持动态构建\">2、除了注解开发外，支持“动态构建”：</h3>\n<p>对于需要动态加载工具的场景，Solon-AI 提供了灵活的 Builder 模式，支持在运行时编排 AI 技能。</p>\n<pre><code class=\"language-java\">@Configuration\npublic class McpServerConfig {\n    @Bean(\"mcp-weather\")\n    public McpServerEndpointProvider serverEndpoint() {\n        McpServerEndpointProvider serverEndpoint = McpServerEndpointProvider.builder()\n                .name(\"mcp-weather\")\n                .channel(McpChannel.STDIO)\n                .build();\n                \n        FunctionToolDesc weatherTool = new FunctionToolDesc(\"get_weather\")\n                .description(\"获取指定城市的天气情况\")\n                .stringParamAdd(\"location\", \"根据用户提到的地点推测城市\")\n                .doHandle(map -&gt; {\n                    return \"24度\";\n                });\n\n        serverEndpoint.addTool(new MethodToolProvider(weatherTool));\n\n        return serverEndpoint;\n    }\n}\n</code></pre>\n<h3 id=\"3强大的协议代理转换\">3、强大的协议代理转换</h3>\n<p>这是 Solon-AI 的一大绝活：支持跨协议代理。例如，你可以将本地运行的 STDIO 工具通过 Solon 包装，转为更适合集群部署的 STREAMABLE_STATELESS（无状态流）传输。</p>\n<pre><code class=\"language-java\">@McpServerEndpoint(channel = McpChannel.STREAMABLE_STATELESS, mcpEndpoint = \"/mcp\")\npublic class McpServerTool implements ToolProvider {\n    private McpClientProvider stdioToolProvider = McpClientProvider.builder()\n            .channel(McpChannel.STDIO) //表示使用 stdio\n            .command(\"npx\")\n            .args(\"-y\", \"@gitee/mcp-gitee@latest\")\n            .addEnvVar(\"GITEE_API_BASE\", \"https://gitee.com/api/v5\")\n            .addEnvVar(\"GITEE_ACCESS_TOKEN\", \"&lt;your personal access token&gt;\")\n            .build();\n\n    @Override\n    public Collection&lt;FunctionTool&gt; getTools() {\n        return stdioToolProvider.getTools();\n    }\n}\n</code></pre>\n<h3 id=\"4支持反向通讯比如sampling-采样\">4、支持“反向通讯”，比如：Sampling 采样</h3>\n<p>MCP 不仅仅是“模型调工具”，还支持“工具调模型”。Solon-AI 完整支持了 Sampling（采样） 能力，允许服务端在执行工具时，反向请求客户端协助处理。</p>\n<pre><code class=\"language-java\">//客户端\npublic class SamplingClientDemo {\n    public void test() {\n        McpClientProvider clientProvider = McpClientProvider.builder()\n                .url(\"http://localhost:8080/mcp\")\n                .customize(spec -&gt; {\n                    spec.capabilities(McpSchema.ClientCapabilities.builder().sampling().build());\n                    spec.sampling(req -&gt; Mono.just(McpSchema.CreateMessageResult.builder()\n                            .content(new McpSchema.TextContent(\"test\"))\n                            .build()));\n                })\n                .build();\n\n\n        clientProvider.callToolAsText(\"demo\", Utils.asMap(\"a\", 1))\n                .getContent();\n    }\n}\n\n//服务端\n@McpServerEndpoint(channel = McpChannel.STREAMABLE, mcpEndpoint = \"/mcp\")\npublic class SamplingServerDemo {\n    //可以注入 exchange（实现反向通讯：服务端向客户端请求）\n    @ToolMapping(description = \"复杂任务拆解\")\n    public Mono&lt;McpSchema.CreateMessageResult&gt; demo(McpAsyncServerExchange exchange) {\n        // 服务端向客户端请求 AI 采样决策\n        return exchange.createMessage(McpSchema.CreateMessageRequest.builder()\n            .messages(Collections.singletonList(McpSchema.PromptMessage.builder()\n                .role(McpSchema.Role.USER)\n                .content(new McpSchema.TextContent(\"请帮我拆解这个任务...\"))\n                .build()))\n            .build());\n    }\n}\n</code></pre>\n<h3 id=\"5-三合一的超级客户端\">5. “三合一”的超级客户端</h3>\n<p>McpClientProvider 实现了 Solon AI 体系内的 <code>ToolProvider</code>、<code>ResourceProvider</code> 和 <code>PromptProvider</code>。这意味着：连接一个 Server，即刻获得全量 AI 能力包。</p>\n<pre><code class=\"language-java\">McpClientProvider clientProvider = McpClientProvider.builder()\n                .channel(McpChannel.STREAMABLE)\n                .url(\"http://localhost:8080/mcp\")\n                .build();\n\n//获取所有工具原语\nclientProvider.getTools();\n//获取所有模板原语\nclientProvider.getResources();\n//获取所有资源模板原语\nclientProvider.getResourceTemplates();\n//获取所有提示词原语\nclientProvider.getPrompts();\n</code></pre>\n<p>为 ChatModel 赋能：</p>\n<pre><code class=\"language-java\">ChatModel chatModel = ChatModel.of(apiUrl)\n        .defaultToolAdd(clientProvider) // 添加为默认工具\n        .build();\n        \nReActAgent agent = ReActAgent.of(chatModel);\n</code></pre>\n<p>为 ReActAgent 赋能：</p>\n<pre><code class=\"language-java\">ChatModel chatModel = ChatModel.of(apiUrl)\n        .build();\n        \nReActAgent agent = ReActAgent.of(chatModel)\n        .defaultToolAdd(clientProvider) //添加为默认工具\n        .build();\n</code></pre>\n<h2 id=\"三生产级的稳健性\">三、生产级的稳健性</h2>\n<p>在生产环境下，连接的稳定性与响应速度至关重要：</p>\n<ul>\n<li>自愈能力：内置心跳检测（Ping），链路断开自动重连，确保 Agent 永不失联。</li>\n<li>高性能缓存：支持工具列表与资源元数据缓存，减少网络开销，让 AI 响应“秒开”。</li>\n<li>多通道支持：无论是跨进程的 STDIO 模式，还是跨网络的 STREAMABLE 模式，Solon-AI 都能丝滑切换。</li>\n<li>Skill 赋能：通过 MCP 获取的原语可直接转化为 <strong>Solon AI Skills</strong>，构建高度模块化的 Agent 技能树。</li>\n</ul>\n<h2 id=\"四借助-skills-实现智能加载智能分发\">四、借助 Skills 实现智能加载（智能分发）</h2>\n<p>通过 Solon AI Skills 的智能路由，你可以避免模型因工具过多而产生幻觉，同时注入本地业务指令。</p>\n<pre><code class=\"language-java\">import org.noear.solon.ai.chat.skill.Skill;\nimport org.noear.solon.ai.chat.skill.SkillDesc;\nimport org.noear.solon.ai.mcp.McpChannel;\nimport org.noear.solon.ai.mcp.client.McpClientProvider;\n\npublic class McpSkillDemo {\n    public void test() {\n        // 1. 创建 MCP 客户端，从远端获取工具生态\n        // 这里假设远端 Server 提供了如 \"restart_server\", \"query_log\" 等运维工具\n        McpClientProvider devopsMcpProvider = McpClientProvider.builder()\n                .channel(McpChannel.STREAMABLE)\n                .url(\"http://devops-center:8080/mcp\")\n                .build();\n\n        // 2. 使用 SkillDesc 将 MCP 工具集包装成一个“智能运维技能”\n        Skill devopsSkill = SkillDesc.builder(\"devops-skill\")\n                .description(\"高级运维管理技能，支持服务器状态查询与故障处理\")\n                \n                // 智能分发：只有当用户提问包含“服务器”、“重启”、“日志”时才激活此技能\n                .isSupported(\"服务器\", \"重启\", \"日志\", \"负载\")\n                \n                // 动态指令：为技能注入特殊的 System Prompt 引导\n                .instruction(prompt -&gt; {\n                    return \"你现在是一名高级架构师。在执行重启操作前，请务必确认操作人的权限。\";\n                })\n                \n                // 挂载工具：核心一步！直接将 MCP 获取的所有工具注入到该技能中\n                .toolAdd(devopsMcpProvider) \n                \n                // 钩子函数：当技能被挂载到会话时触发逻辑（如：记录审计日志）\n                .onAttach(prompt -&gt; {\n                    System.out.println(\"检测到运维相关指令，DevOps 技能已就绪...\");\n                })\n                .build();\n\n        // 3. 应用技能：将技能交给 Agent\n        ChatModel chatModel = ChatModel.of(apiUrl).build();\n        \n        ReActAgent agent = ReActAgent.of(chatModel)\n                .defaultSkillAdd(devopsSkill) // 添加包装后的技能\n                .build();\n\n        // 此时 Agent 只有在聊到运维话题时，才会通过 MCP 协议去调用对应的远端工具\n        agent.prompt(\"帮我查一下 server-01 的负载情况\").call();\n    }\n}\n</code></pre>\n<h2 id=\"五-solon-ai--mcp-的典型场景\">五、 Solon-AI + MCP 的典型场景</h2>\n<h3 id=\"场景-a企业私有数据助手\">场景 A：企业私有数据助手</h3>\n<p>通过 Solon-AI 构建一个 MCP Server，将企业的 ERP、CRM 系统通过 <code>@ResourceMapping</code> 暴露。AI 助手可以直接读取实时业务数据，而无需你手动编写复杂的数据抓取逻辑。</p>\n<h3 id=\"场景-b跨语言工具链整合\">场景 B：跨语言工具链整合</h3>\n<p>你的团队可能有用 Python 写的算法脚本，现在只需将其包装成一个 MCP Server，Solon-AI 的客户端就能通过标准协议调用它，打破 Java 与 Python 的隔离。</p>\n<h3 id=\"场景-c智能-ide-与本地自动化\">场景 C：智能 IDE 与本地自动化</h3>\n<p>利用 Solon-AI 的 STDIO 通道，你可以编写 Java 程序作为本地插件，直接接入 Claude Desktop 或其他支持 MCP 的编辑器，实现用自然语言操控本地系统。</p>\n<h3 id=\"六-开启你的-mcp-之旅\">六、 开启你的 MCP 之旅</h3>\n<p>Solon-AI 不仅仅是在追赶趋势，它正在重新定义 Java 开发 AI 应用的体验。轻量、强大、兼容 Java 8 到 Java 25，这就是 Solon-AI。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 10:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/noear\">带刺的坐椅</a>&nbsp;\n阅读(<span id=\"post_view_count\">74</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}