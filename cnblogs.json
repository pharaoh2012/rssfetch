{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "接口自动化测试报告",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19571986",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19571986\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 23:08\">\n    <span>接口自动化测试报告</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"前述\">前述：</h4>\n<ul>\n<li>博客系统主要包括登录接口、列表接口、博客详情接口、用户认证接口、编辑接口、作者信息接口。通过开发者工具抓取相关url,使用脑图设计出相关测试样例，对该系统进行接口测试。</li>\n</ul>\n<h4 id=\"脑图\">脑图</h4>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h4 id=\"测试环境\">测试环境</h4>\n<ul>\n<li>技术栈：pytest框架、request模块、PyYAML模块、jsonSchema模块、allure-pytest模块、logging模块</li>\n<li>集成开发环境：pycharm</li>\n</ul>\n<h4 id=\"编写测试代码\">编写测试代码</h4>\n<ol>\n<li>根据上面的脑图，针对每一个接口编写相应的测试代码。</li>\n<li>统一封装公共属性，提高代码的复用性。</li>\n<li>为了在测试过程中能够准确发现错误，在utils中加入日志模块，方便直接定位。</li>\n<li>使用yaml数据管理工具，实现测试数据与代码分离，便于数据管理和维护。</li>\n<li>通过JSON Schema验证响应格式,确保返回数据的结构正确性。</li>\n</ol>\n<h4 id=\"代码结构展示\">代码结构展示</h4>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<ul>\n<li><a href=\"https://gitee.com/xylophone-queen/write-with-python/tree/dev/\" rel=\"noopener nofollow\" target=\"_blank\">代码地址</a></li>\n</ul>\n<h5 id=\"公共类---utils\">公共类---utils</h5>\n<ol>\n<li>request_util.py:将requests库的功能进行二次封装，提供统一的接口调用方式;通过全局变量host统一管理被测系统的基地址。</li>\n<li>yaml_util.py:提供对YAML格式测试数据文件的读写操作,允许测试过程中动态写入和读取数据。</li>\n<li>logger_util.py:多层次日志输出,将不同级别的日志分开存储，便于定位错误。</li>\n</ol>\n<h5 id=\"登陆页面---test_loginpy\">登陆页面---test_login.py</h5>\n<ul>\n<li>使用@pytest.mark.order(1)确保登录测试最先执行，成功登录是进行其他页面接口测试的基础。</li>\n<li>使用@pytest.mark.parametrize，结合脑图上面的用例，设置不同的条件进行登录测试。\n<ul>\n<li>覆盖了各种异常登录场景</li>\n<li>新增测试场景只需添加新的参数组合</li>\n<li>通过一次定义，多次执行减少重复代码</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"列表页---test_listpy\">列表页---test_list.py</h5>\n<ul>\n<li>验证博客列表接口的正常功能,确保API按预期返回博客数据</li>\n<li>验证API的认证授权机制,确保未认证用户无法访问受保护资源</li>\n<li>从响应中提取关键数据供后续测试使用,实现测试间的数据传递</li>\n</ul>\n<h5 id=\"详情页---test_detailpy\">详情页---test_detail.py</h5>\n<ul>\n<li>验证博客详情接口的正常功能，确保API按预期返回博客详细信息</li>\n<li>使用@pytest.mark.parametrize，实现了异常场景覆盖</li>\n<li>从YAML文件读取登录时生成的token，确保测试在已认证状态下执行</li>\n</ul>\n<h5 id=\"用户认证接口---test_getauthorinfopy\">用户认证接口---test_getAuthorInfo.py</h5>\n<ul>\n<li>补充了博客与作者信息关联的功能验证，完善了用户信息获取的测试覆盖，提供了作者信息查询的专项测试</li>\n<li>test_getAuthorInfo验证在拥有合法 token 和有效 blogId 时，接口能返回正确的数据</li>\n<li>通过 @pytest.mark.parametrize 进行了等价类与边界值分析，测试了空值、负数、中文字符、超长数字等异常输入</li>\n</ul>\n<h5 id=\"编辑接口---test_addpy\">编辑接口---test_add.py</h5>\n<ul>\n<li>验证博客添加功能的完整性和正确性，确保用户能够成功创建新博客</li>\n<li>通过参数化测试覆盖各种边界条件，确保系统对异常输入的正确处理</li>\n<li>验证富文本内容（链接、图片等）的正确处理，确保系统对各种内容格式的支持</li>\n<li>验证标题和内容不能为空的业务规则，确保数据验证逻辑的正确性</li>\n</ul>\n<h5 id=\"用户信息接口---test_getuserinfopy\">用户信息接口---test_getUserInfo.py</h5>\n<ul>\n<li>验证用户信息获取功能的完整性和正确性,确保用户能够成功获取自己的账户信息</li>\n<li>验证API的认证授权机制,确保未认证用户无法访问用户信息</li>\n<li>验证用户信息获取的业务规则,确保数据验证逻辑的正确性</li>\n</ul>\n<h4 id=\"测试结果展示\">测试结果展示</h4>\n<ul>\n<li>配置好pytest.ini文件配置，输出详细测试结果<br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n<li>使用allure在终端生成可视化测试报告\n<ul>\n<li>命令：<code>allure generate .\\allure-results\\ -o .\\allure-reports --clean</code><br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n</ul>\n</li>\n<li>可以看到32个测试用例全部通过，通过率百分百。</li>\n</ul>\n<h4 id=\"小结\">小结</h4>\n<ul>\n<li>进行测试时需要关注代码执行的顺序，使用pytest-order第三⽅插件，控制测试用例的执⾏顺序。\n<ul>\n<li>在test_login.py中使用@pytest.mark.order(1)---&gt;访问任何接口都应该先进行登录，确保信息的隐私性。</li>\n</ul>\n</li>\n<li>使用jsonschema对返回的数据格式进行校验，提高测试的效率和质量。</li>\n<li>测试阶段修改pytest.ini的配置为<code>[pytest] addopts = -vs</code>，输出具体的测试结果到终端，便于测试人员快速定位测试中出现的问题。</li>\n<li>完成测试后修改配置为<code>[pytest] addopts = -vs --alluredir allure-results</code>，并配合命令<code>allure generate .\\allure-results\\ -o .\\allure-reports --clean</code>输出测试报告。</li>\n<li>使用简单的YAML文件存储关键数据，通过read_yaml和write_yaml函数统一管理数据存取，在测试开始前清空YAML文件防止数据污染。</li>\n<li>在编写某个测试接口的相关代码前，可以使用postman预测，确保接口地址的准确性。</li>\n<li>使用@pytest.mark.parametrize 进行参数化测试，极大地减少代码冗余；实现“测试数据”与“测试逻辑”的分离。</li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 23:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[大模型实战 03预备] 云端炼丹房 2：Kaggle 上手指南",
      "link": "https://www.cnblogs.com/algieba/p/19576331",
      "published": "",
      "description": "<div class=\"postcontent\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"[大模型实战 03预备] 云端炼丹房 2：Kaggle 上手指南\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260204195327324-384345256.png\" />\n        Colab 额度用完了？Kaggle 带着两张 T4 显卡来了！本文详解 Kaggle 账号手机验证、开启 Internet 联网、配置双 T4 GPU 环境，以及如何利用 Kaggle 特有的 Dataset 机制持久化保存 HuggingFace 模型。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"大模型实战-03预备-云端炼丹房-2kaggle-上手指南\">[大模型实战 03预备] 云端炼丹房 2：Kaggle 上手指南</h1>\n<blockquote>\n<p><strong>核心摘要 (TL;DR)</strong></p>\n<ul>\n<li><strong>痛点</strong>：Colab 免费额度耗尽，或者单张 T4 显存（16GB）无法满足更大参数模型的微调需求。</li>\n<li><strong>方案</strong>：利用 <strong>Kaggle</strong> 提供的 <strong>每周 30 小时免费双路 T4 GPU (T4 x2)</strong> 算力。</li>\n<li><strong>技巧</strong>：通过 <strong>手机号验证</strong> 解锁联网权限，利用 <strong>Kaggle Datasets</strong> 实现模型的持久化存储。</li>\n<li><strong>目标</strong>：作为 Colab 的强力替补（甚至上位），搭建备用云端炼丹环境。</li>\n</ul>\n</blockquote>\n<h2 id=\"前言\">前言</h2>\n<p>上一篇中，本来想直接写到Google Colab的大模型推理脚本，让各位友人们感受一下在全参数7B模型的能力，但是折腾了很久，Colab读driver老是失败，当我想直接下载到云端主机而不是driver的时候，GPU的额度已经耗尽。索性今天在Kaggle的这篇博文中来讲，应该之后也主要用Kaggle来进行云端开发，毕竟Colab额度少，还得盯着，长时间不看会断掉连接。</p>\n<p>好，我们来先介绍一下今天的主角，Google 旗下的另一个神器：<a href=\"https://www.kaggle.com/\" rel=\"noopener nofollow\" target=\"_blank\"><strong>Kaggle</strong></a>。Colab如果说其本职就是模型训练，那<strong>Kaggle</strong>本身其实是一个数据科学的竞赛平台，毕竟是数据科学竞赛嘛，那自然得需要算力资源，<strong>Kaggle</strong>为了方便，也发挥了谷歌大善人的优良品质，免费提供了大方的计算资源。跟Colab对比起来，Kaggle的优势就是，更稳定，更方便，资源给的额度更多。</p>\n<h2 id=\"1-kaggle-notebooks-核心概念\">1. Kaggle Notebooks 核心概念</h2>\n<p>Kaggle 的核心编程环境叫 <strong>Kernels (现在统称 Notebooks)</strong>,不用害怕，诶，它就是我们昨儿刚认识的熟人<strong>云端服务器版</strong>的<strong>Jupyter Notebook</strong>,但是和Colab不太相同的是Kaggle的文件结构，它明显得区分了输入区域，输出区域，暂存区域, 这是也我们刚上手容易懵的地方:</p>\n<ul>\n<li><strong>Input (<code>/kaggle/input</code>)</strong>：<strong>只读区域</strong>。这里存放你上传的数据集或挂载的模型。读取速度极快，但无法写入。</li>\n<li><strong>Output (<code>/kaggle/working</code>)</strong>：<strong>可读写区域</strong>。这是你的主工作区，代码运行结果、下载的模型必须存在这里。但注意，重启 Session 后，这里的内容如果不保存为 Dataset 也会消失。</li>\n<li><strong>Temp (<code>/kaggle/temp</code>)</strong>：<strong>临时暂存区</strong>。空间较大（只有当前会话有效），适合下载解压临时的大文件。</li>\n</ul>\n<p><img alt=\"Kaggle notebook 文件系统结构图，展示 input/working/temp 的区别的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/kaggle_input_working_temp.png\" /></p>\n<h2 id=\"2-快速上手注册与解锁\">2. 快速上手：注册与“解锁”</h2>\n<h3 id=\"21-注册与关键验证-必做\">2.1 注册与关键验证 (必做)</h3>\n<p>我们新用户登录创建notebook后会发现，我们没有硬件加速设备可选。<br />\n<img alt=\"新用户的accelerator部分是灰色的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/no_gpu.png\" /><br />\n根本原因就是咱们没有进行手机验证，哈哈哈，可以理解，毕竟本身kaggle就不用绑卡，加上手机验证可能会杜绝掉一大部分计算资源滥用。</p>\n<ol>\n<li>访问 <a href=\"https://www.kaggle.com/\" rel=\"noopener nofollow\" target=\"_blank\">Kaggle 官网</a> 并注册账号。</li>\n<li><strong>关键步骤</strong>：点击右上角头像 -&gt; <strong>Settings</strong>。</li>\n<li>找到 <strong>Phone Verification</strong>（手机验证）。<strong>必须完成这一步</strong>，否则无法开启 GPU 和 Internet（联网）功能。<br />\n<img alt=\"Kaggle 账户设置页面的截图，高亮 Phone Verification 区域\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/phone_verification.png\" /></li>\n</ol>\n<p>认证完毕就可以使用GPU资源了<br />\n<img alt=\"当认证了手机号之后显示accelerator中有可用的GPU资源的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/gpu_access.png\" /><br />\n如果继续做了<strong>Identity verification</strong>之后，可以使用TPU资源，不过我们暂时用不到，目前的GPU资源已经够咱们大玩一场了。</p>\n<h3 id=\"22-创建笔记本\">2.2 创建笔记本</h3>\n<ol>\n<li>点击左侧菜单栏的 <strong>Create</strong> -&gt; <strong>New Notebook</strong>。</li>\n<li>进入编辑器界面，你会发现界面布局比 Colab 更加紧凑且功能分区明确。<br />\n<img alt=\"kaggle的编辑器页面布局的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/the_whole_UI.png\" /></li>\n</ol>\n<h3 id=\"23-界面布局速览\">2.3 界面布局速览</h3>\n<ul>\n<li><strong>工作区</strong>：位于右侧，显示了Input-&gt;我们的挂载资源，上传的数据集和模型等等，Output-&gt;我们输出的结果资源。notebook内容速览,以及下面的session options环境快捷配置等等<br />\n<img alt=\"编辑器右侧的工作区，包含Input区和output区的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/workspace.png\" /><br />\n<img alt=\"编辑器右侧工作区剩余部分，报班session options的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/session_options.png\" /></li>\n<li><strong>快捷操作栏</strong>： 在代码区上方，和Colab差别不大，可以快速运行，插入单元格，复制粘贴等等<br />\n<img alt=\"在编辑器上方的快捷操作栏的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/quick_action.png\" /></li>\n<li><strong>代码区</strong>：和Colab一样, 标准的 Jupyter 单元格。</li>\n</ul>\n<p>注意，</p>\n<ol>\n<li>和Colab不一样的是，Kaggle的文件名没有后缀，不用加ipynb后缀</li>\n<li>咱们的硬件加速（GPU/TPU计算资源）被放到了顶部菜单栏的<strong>Settings</strong>中的<strong>accelerator</strong>中了</li>\n<li>和Colab不同，因为Kaggle是为竞赛服务，很多竞赛是要求模型不联网的，所以我们在训练模型的时候，需要手动开启网络，也在顶部菜单栏的<strong>Settings</strong>中，点击<strong>Turn On Internet</strong>打开即可联网下载模型或者数据集。<br />\n<img alt=\"Kaggle Notebook的Settings下拉菜单，包含硬件加速设备和开启联网选项的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/settings.png\" /></li>\n<li>密钥管理被放到了顶部菜单栏的<strong>Add-ons</strong>下了<br />\n<img alt=\"Kaggle Notebook的Add-on下来菜单，包含密钥管理选项的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/add-on.png\" /></li>\n</ol>\n<h2 id=\"3-环境配置开启双显卡与联网\">3. 环境配置：开启双显卡与联网</h2>\n<p>Kaggle 默认环境是 <strong>CPU</strong> 且 <strong>断网</strong> 的。我们需要手动“解除封印”。</p>\n<h3 id=\"31-开启联网-internet-on\">3.1 开启联网 (Internet On)</h3>\n<p>可以按照刚才说的在顶部菜单栏打开，也可以在右侧边栏的 <strong>Session Options</strong> 中，找到 <strong>Internet</strong> 选项。将开关拨到 <strong>On</strong>。<br />\n<em>注意：如果没有手机验证，此选项为灰色不可用。</em></p>\n<h3 id=\"32-开启-gpu-加速-t4-x2\">3.2 开启 GPU 加速 (T4 x2)</h3>\n<ol>\n<li>\n<p>在右侧边栏找到 <strong>Accelerator</strong>。</p>\n</li>\n<li>\n<p>下拉选择 <strong>GPU T4 x2</strong>。</p>\n<ul>\n<li><strong>GPU T4 x2</strong>：两张显卡，约 30GB 显存，适合大模型推理和微调。</li>\n<li><strong>GPU P100</strong>：单张旧架构卡，虽然速度快但显存仅 16GB，通常不推荐。</li>\n</ul>\n</li>\n<li>\n<p>开启后，顶部会显示 <strong>Session Storage</strong> 和 <strong>GPU Quota</strong>（每周 30 小时额度，通常周六刷新）。<br />\n点击自己的头像，可以看见自己的额度<strong>GPU Quata</strong><br />\n<img alt=\"点击自己的头像，可以看见自己的额度的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/GPU_Quata.png\" /></p>\n</li>\n</ol>\n<h3 id=\"33-验证双卡环境\">3.3 验证双卡环境</h3>\n<p>输入并运行以下代码，确认我们是否真的拥有了两张显卡：</p>\n<pre><code class=\"language-python\">!nvidia-smi\n</code></pre>\n<p>你应当能看到 <strong>两张</strong> Tesla T4 显卡的列表 (GPU 0 和 GPU 1)。<br />\n<img alt=\"nvidia-smi的运行结果，显示两张Tesla T4卡\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/nvidia-smi.png\" /></p>\n<h2 id=\"4-实战下载并运行大模型\">4. 实战：下载并运行大模型</h2>\n<p>在 Kaggle 上使用模型主要有两种“流派”：<strong>代码下载派</strong> 和 <strong>原生挂载派</strong>。</p>\n<h3 id=\"方式一利用-huggingface-cli-下载-工程化推荐\">方式一：利用 HuggingFace CLI 下载 (工程化推荐)</h3>\n<p>这种方式最灵活，适合需要精确控制模型版本的情况。由于 Kaggle 没有 Google Drive，我们将模型下载到 <code>/kaggle/working/</code> 目录。</p>\n<p><strong>步骤 1：安装与配置</strong></p>\n<pre><code class=\"language-python\"># Kaggle 预装库很多，但 transformers 版本可能滞后，建议更新\n!pip install -U transformers huggingface_hub accelerate bitsandbytes\n</code></pre>\n<p>点击顶部菜单 <strong>Add-ons</strong> -&gt; <strong>Secrets</strong>，添加 <code>HF_TOKEN</code>（你的 HuggingFace 访问令牌）。</p>\n<p><strong>步骤 2：下载脚本</strong></p>\n<pre><code class=\"language-python\">import os\nfrom huggingface_hub import login, snapshot_download\nfrom kaggle_secrets import UserSecretsClient\n\n# 1. 登录 (自动读取 Secrets)\nuser_secrets = UserSecretsClient()\nhf_token = user_secrets.get_secret(\"HF_TOKEN\")\nlogin(token=hf_token)\n\n# 2. 定义下载路径 (注意：必须在 /kaggle/working 下)\nmodel_dir = \"/kaggle/working/model_cache\"\nos.makedirs(model_dir, exist_ok=True)\n\n# 3. 下载模型\nmodel_id = \"Qwen/Qwen2.5-7B-Instruct\"\nprint(f\"开始下载 {model_id} ...\")\n\n# Kaggle 建议下载实文件 (local_dir_use_symlinks=False)\nsnapshot_download(\n    repo_id=model_id,\n    local_dir=model_dir,\n    local_dir_use_symlinks=False,\n    token=hf_token\n)\n\nprint(\"下载完成！\")\n</code></pre>\n<p><img alt=\"下载完成的结果截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/download_model.png\" /></p>\n<h3 id=\"方式二add-input-kaggle-原生方式\">方式二：Add Input (Kaggle 原生方式)</h3>\n<p>这是 Kaggle 最强大的功能。你可以直接在网页端搜索现成的模型，像挂载 U 盘一样挂载进来，<strong>不消耗下载流量和时间</strong>。</p>\n<ol>\n<li>点击右侧边栏的 <strong>Add Input</strong>。</li>\n<li>选择 <strong>Models</strong> 标签页。</li>\n<li>搜索 <code>Qwen2.5</code>。</li>\n<li>点击 <strong>+</strong> 号添加。<br />\n<img alt=\"Kaggle Add Input 搜索模型的弹窗截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/qwen_downloading.png\" /></li>\n<li>选择FRAMEWORK选择<strong>Transformers</strong>架构, VARIATION选择<strong>7b-instruct</strong>, 之后的博文会跟各位友人解释这些参数的差别<br />\n<img alt=\"下载Qwen2.5模型需要填写的架构和参数示意截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/qwen2_5_params.png\" /></li>\n<li>模型会直接出现在 <code>/kaggle/input/</code> 目录下（只读），路径通常长得像 <code>/kaggle/input/qwen2.5/transformers/7b-instruct/1</code>。</li>\n</ol>\n<h2 id=\"5-加载模型与双卡推理\">5. 加载模型与双卡推理</h2>\n<p>拥有双卡 T4 后，加载模型时有一个关键参数：<code>device_map=\"auto\"</code>。它会自动将模型切分到两张显卡上，从而让我们能运行更大的模型。</p>\n<pre><code class=\"language-python\">import torch\nfrom transformers import AutoTokenizer, AutoModelForCausalLM\n\n# 路径根据你的下载方式调整\n# 方式一路径: \"/kaggle/working/model_cache\"\n# 方式二路径: \"/kaggle/input/qwen2.5/transformers/7b-instruct/1/\" (具体可以运行默认创建的第一个单元格，查看input目录结构,到能看见config.json的目录即可)\nmodel_path = \"/kaggle/working/model_cache\"\n\nprint(\"正在加载模型 (双卡模式)...\")\n\ntokenizer = AutoTokenizer.from_pretrained(model_path, trust_remote_code=True)\n\n# 关键：device_map=\"auto\" 会自动利用两张 T4\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_path,\n    device_map=\"auto\",\n    torch_dtype=torch.float16,\n    trust_remote_code=True\n)\n\nprint(f\"模型加载成功！显存分布: {model.hf_device_map}\")\n\n# 测试对话\nprompt = \"你好，请用一句话形容 Kaggle 的双 T4 显卡有多香？\"\nmessages = [{\"role\": \"user\", \"content\": prompt}]\ntext = tokenizer.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\ninputs = tokenizer([text], return_tensors=\"pt\").to(model.device)\n\nwith torch.no_grad():\n    generated_ids = model.generate(**inputs, max_new_tokens=200)\n\nresponse = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]\nprint(f\"Qwen: {response.split('assistant')[-1].strip()}\")\n</code></pre>\n<h2 id=\"6-进阶如何持久化保存save-version\">6. 进阶：如何持久化保存？(Save Version)</h2>\n<p>Kaggle 没有 Google Drive，那怎么保存下载好的模型或训练结果呢？</p>\n<p><strong>答案：把 Output 变成 Dataset。</strong></p>\n<ol>\n<li>当你的代码运行完毕，模型保存在 <code>/kaggle/working</code> 后。</li>\n<li>点击右上角的 <strong>Save Version</strong> 按钮。</li>\n<li>选择 <strong>Save &amp; Run All</strong> (重新跑一遍),必须等到下方弹出的保存任务完成。<br />\n<img alt=\"保存任务完成的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/job_running_done.png\" /></li>\n<li>保存成功后，你可以去主页的<strong>Your Work</strong>点击刚才的Notebook,进入<strong>Output</strong> 标签页里，点击最右边的Output的三个点，然后点击 <strong>New Dataset</strong>。<br />\n<img alt=\"在Output标签页的New Dataset示意图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/new_data.png\" /></li>\n<li>这样，我们刚才的模型就变成了一个可以在其他 Notebook 里直接 <strong>Add Input</strong> 的数据集了！</li>\n</ol>\n<p><strong>PS:除开自训练的特殊模型和一些在Input找不到的模型，最好都直接使用Input导入更为快捷</strong></p>\n<h2 id=\"7-常见问题-qa\">7. 常见问题 (Q&amp;A)</h2>\n<p><strong>Q: Colab 和 Kaggle 我该选谁？</strong><br />\n<strong>A:</strong></p>\n<ul>\n<li><strong>Colab</strong>: 适合快速实验、挂载 Google Drive 方便。但 T4 只有一张，且最近封号较严。</li>\n<li><strong>Kaggle</strong>: 适合需要大显存（T4 x2）的任务。环境更稳定，且有 30 小时/周的明确额度，不用担心用到一半被踢下线。</li>\n</ul>\n<p><strong>Q: 为什么我的代码报错 <code>Internet connection is closed</code>？</strong><br />\n<strong>A:</strong> 这是一个经典错误。请检查右侧边栏的 <strong>Internet</strong> 开关是否为 On。如果开关是灰色的，请检查是否完成了账号的 <strong>手机号验证</strong>。</p>\n<p><strong>Q: <code>/kaggle/working</code> 里的文件重启后还有吗？</strong><br />\n<strong>A:</strong> 没有了。Kaggle 的 Session 也是临时的。如果需要持久化，请务必使用 <strong>Save Version</strong> 功能将其保存为 Dataset，或者在代码最后加一段上传到 HuggingFace Hub 的代码。</p>\n<hr />\n<p><strong>本文作者：</strong> Algieba<br />\n<strong>本文链接：</strong> <a href=\"https://blog.algieba12.cn/llm02-2-online-environment-kaggle/\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.algieba12.cn/llm02-2-online-environment-kaggle/</a><br />\n<strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>\n<pre><code>\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"itemdesc\">\n\t\t\t发表于 \n<span id=\"post-date\">2026-02-04 19:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/algieba\">阿尔的代码屋</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</div>"
    },
    {
      "title": "V8引擎 精品漫游指南--Ignition篇(上) 指令 栈帧 槽位 调用约定 内存布局 基础内容",
      "link": "https://www.cnblogs.com/f20171110/p/19576264",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/f20171110/p/19576264\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 19:19\">\n    <span>V8引擎 精品漫游指南--Ignition篇(上) 指令 栈帧 槽位 调用约定 内存布局 基础内容</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        这是第二篇的上半部分，我们主要学习ignition V8的解释器的一些基础和前置知识。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"二-ignition解释器上\">二. Ignition解释器(上)</h1>\n<p>这是第二篇的上半部分，我们主要学习ignition V8的解释器的一些基础和前置知识。</p>\n<p>这部分内容，主要是以了解为主，所以在学习的时候，除了第一篇中说的 有些细节做了省略  有些边界情况做了简化表述以外，也不需要过多的深入。 读完了就好。 目的就是对于ignition解释器的一个祛魅。</p>\n<p>当然，感兴趣的朋友也可以认真阅读，本文内容依旧保持一定的深度，依旧是力求高准确性，符合规范，贴合实现。 但需注意的是，为了文章的可读性，有可能<strong>在前面</strong>仅做简化的通俗的描述，<strong>在后面</strong>做了详细的讲解描述，所以，可能的情况下，请尽量阅读全文。</p>\n<p>通过上一篇的解析，我们手里已经拿到了一份完整的AST抽象语法树。 但是对于cpu来说，它只认指令。</p>\n<p>在早期版本的 V8 中，JavaScript 代码在解析完成后，会直接被编译成本机机器码执行。这种方式运行得很快，但机器码体积通常比较大，也不够灵活。</p>\n<p>在后来，直到现在，V8不再直接生成庞大复杂的机器码，而是生成了一种非常紧凑 小巧的中间代码，就是 字节码 bytecode。</p>\n<p>但是cpu也不认识字节码，V8使用 ignition 模拟了一个可以运行字节码的环境，相当于一个极其轻量的虚拟机。</p>\n<h2 id=\"1--ignition是什么\">1 . ignition是什么</h2>\n<p>Ignition 是 V8 引擎里的<strong>字节码解释器</strong>，它把 JavaScript 的 AST 编成紧凑的字节码，然后在虚拟机里解释执行，同时收集各种信息，供优化器生成更快的机器码。</p>\n<p>ignition的工作  最主要是下面三个：</p>\n<p><strong>翻译</strong>：把 AST 翻译成字节码。</p>\n<p><strong>执行</strong>：在一个虚拟的寄存器机里执行这些字节码。</p>\n<p><strong>收集情报</strong>：在执行过程中，偷偷记录类型信息，为后续的优化做准备。</p>\n<p>Ignition 在软件层面模拟了一套  <strong>类 CPU</strong> 的工作模式：<br />\n它不是只用栈，也不是纯寄存器机，而是采用“<strong>虚拟寄存器 + 累加器（Accumulator）</strong>”的模式。</p>\n<p>这里的寄存器并不是 CPU 里的硬件寄存器，而是函数栈帧里的一些槽位（slots），只是把它抽象成寄存器来使用，看起来更像 CPU 工作方式，但成本非常低。</p>\n<p>Ignition 还设计了一个<strong>解释器独占的累加器 acc</strong>。大多数运算的中间结果都会临时存放在 acc 里，这样指令只需要携带一个参数，就不用全部写出所有的目的寄存器，字节码就会变得非常短小。</p>\n<p>当一个函数开始执行时，Ignition 会在内存的 栈 (Stack) 上划出一块地盘， 跑起来的时候，本质上就是在那块栈内存上，不停地把数据从一个位置搬到另一个位置，计算，然后再搬回另一个位置，就是这样搬来搬去。ignition操作的并不是真正的cpu内的寄存器，它操作的是内存位置/槽位。</p>\n<h2 id=\"2--几个简单的指令\">2 . 几个简单的指令</h2>\n<p>ignition就像一个勤劳干活的老师傅，他有一个随身腰包，他不管干什么活，不管需要用什么工具，都是优先用随身腰包里的东西， 干完活得到的结果，也顺手塞回自己的随身腰包里。</p>\n<p><strong>老师傅有个随身腰包， 不管干什么，都优先使用随身腰包。</strong></p>\n<p><strong>摆放各种材料的原料架，一格一格的， r0 ，r1，r2.。。。编着号，上面摆满了原材料。</strong></p>\n<p>好了，这就是ignition的架构。就是这么简单。</p>\n<p>这个随身腰包，就是老师傅最重要的东西了。师傅偷懒全靠它了。</p>\n<p>假如没有这个随身包，想象一下，老板下达指令非常啰嗦麻烦：</p>\n<p>把 r1原料架 的东西 和 r2原料架 的东西拿下来，拼装好，然后再放回 r3原料架 去</p>\n<p>(类似于指令：ADD r1, r2, r3)</p>\n<p>​     而老师傅有了随身包，就简单了，老板只需要喊一声：</p>\n<p>“去把 r2 原料架的东西拼进来！”</p>\n<p>(指令：Add r2)</p>\n<p>老板完全不需要废话“跟谁拼”（默认跟包里的东西拼），也不需要废话“拼完放哪”（默认拼完还放在包里）。</p>\n<p>这就是 Ignition 的核心节省秘籍。通过强行规定“随身包优先”，每一条指令都能省掉好几个参数的位置。成千上万行代码跑下来，省下的内存就是一个天文数字。</p>\n<p>这个老师傅的<strong>随身包 就是累加器</strong>，原料架 就是内存位置/槽位</p>\n<ul>\n<li>\n<p><code>Lda</code> (Load Accumulator) ---Lda 是个前缀，实际使用时，后面可跟很多合法的数据来源，比如 LdaSmi<code>、</code>LdaConstant<code>、</code>LdaUndefined、Ldar 等等。。。</p>\n<p>这是使用最高频的指令，因为所有的活 都得在随身包里干，所以第一步，基本上都是把东西装进包里。</p>\n<ul>\n<li><strong>指令</strong>：<code>Ldar r1</code> (Load Accumulator from Register r1)</li>\n<li><strong>动作</strong>：老师傅走到 r1 原料架，把那里的材料拿下来，<strong>塞进随身包里</strong>。</li>\n<li><strong>状态</strong>：此时，随身包里的东西 = r1 的东西。</li>\n<li>Ldar 这个指令  很好记忆，ld是装载，a是累加器，r是寄存器，ldar就是装载累加器from寄存器，  <strong>把寄存器的内容装进累加器</strong>。</li>\n<li>Ldar r1  就是把寄存器r1里的东西 装进累加器。</li>\n<li>老师傅把r1的原料装进随身包里。</li>\n</ul>\n</li>\n<li>\n<p><code>Star</code> (Store Accumulator)</p>\n<p>活干完了，结果总不能一直烂在包里，得腾出地方干下一票，或者把结果存起来。</p>\n<ul>\n<li><strong>指令</strong>：<code>Star r2</code> (Store Accumulator to Register r2)</li>\n<li><strong>动作</strong>：老师傅把<strong>随身包里</strong>刚刚加工好的成品掏出来，放到 r2 原料架上去。</li>\n<li><strong>状态</strong>：此时，r2 原料架的东西 = 随身包里的东西。</li>\n<li>star 这个指令，也很好记忆，st是储存，a是累加器，r是寄存器，star就是存储累加器里的东西到寄存器。</li>\n</ul>\n</li>\n<li>\n<p><code>Add</code> / <code>Sub</code> ...</p>\n<p>这是真正的关键步骤。</p>\n<ul>\n<li><strong>指令</strong>：<code>Add r0</code></li>\n<li><strong>动作</strong>：老师傅走到 r0 原料架，拿个东西，直接跟<strong>随身包里</strong>原本的东西进行合体（相加）。</li>\n<li><strong>状态</strong>：随身包里的东西 = 原包里的值 + r0 的值。</li>\n<li><strong>重点</strong>：注意 <strong>结果依然留在包里</strong>，老师傅并没有急着去储存结果。</li>\n</ul>\n<p>指令都很简单，<strong>ld</strong>  <em>load</em>，<strong>st</strong>  <em>store</em>，<strong>a</strong>  <em>accumulator</em>，<strong>r</strong>  <em>register</em></p>\n<p>类似的  ldglobal  stglobal ldarg0  ldcurrentcontext  也都差不多，</p>\n<p>基本上都是  动作+对象  的模式。</p>\n<p>另外需要注意的是，累加器 Accumulator 通常会写作 acc。虽然它叫“累加器”，但千万不要理解成它只能做加法运算。<strong>从本质上讲，acc 就是解释器里唯一的“通用临时寄存器”</strong>：当前这条字节码要处理的值，或者运算后的中间结果，几乎都会暂时放在这里。</p>\n<p>acc 里可以装任何 JavaScript 的值，比如常量、小整数、字符串、对象引用、<code>undefined</code> 等。之所以要设计这么一个“统一的临时位置”，就是为了让大多数字节码只需要写明“另一个参与运算的对象是谁”，而不用每次都额外声明多个寄存器参数，从而<strong>让字节码更短、更规整，也让解释器实现更简单</strong>。</p>\n</li>\n</ul>\n<pre><code>  Ldar r1   ; acc = r1\n  Add r0    ; acc = acc + r0\n  Star r2   ; r2 = acc\n  \n  累加器acc的变化。    是不是非常简单。\n</code></pre>\n<h2 id=\"3--栈帧和槽位\">3 . 栈帧和槽位</h2>\n<p>在第一部分解析篇里  我们也提到过 槽位 这个术语， 上面又提到了，那么，槽位到底是什么呢？</p>\n<p><strong>槽位（slot）就是栈帧里一格一格固定大小的“存储单元”或“格子”，用于按索引存放函数的参数、局部变量、临时值、以及其它元数据。</strong> 它不仅是“位置”，还隐含了大小、类型（通常是指针/Tagged 值）、地址计算规则和生命周期语义。</p>\n<p>内存可寻址的最小单位是 8bit 即一字节， 虽然最小使用单位是8bit 即一字节。但是，因为需要字节对齐 和 机器指针大小的要求，所以 在32位系统上，  需要4字节表示指针， 64位系统上  需要8字节表示指针。 每个槽位的大小，也是按照操作系统机器指针的大小来划分的。 即   64位系统，一个槽位  占 8个字节 。 只有这样，<strong>64位系统</strong>使用指针寻址时，8字节，即64bit，才能够装得下一个指针。</p>\n<p>所以，每个槽位（slot）占 8个字节大小。</p>\n<p>当函数开始执行时，运行时runtime在栈上为它分配一段连续内存作为<strong>栈帧</strong>。在 Ignition 中，栈帧大致分为三部分：<strong>参数区</strong>、<strong>固定头部</strong>，  <strong>工作区</strong> 。栈帧里的每个“格子”称为<strong>槽位（slot）</strong>，按索引存放局部变量和临时值，槽位的大小通常等于机器指针大小， <strong>64 位</strong>下为 8 字节。</p>\n<p><strong>特别注意</strong>：前面我们一般并没有明确的区分栈帧里槽位和字段，现在明确一下，我们<strong>仅仅是把工作区中</strong>按索引的格子（<code>r0, r1, r2…</code>）称为<strong>槽位（frame slots）</strong>。固定头部里的字段（返回地址、saved FP、Context、BytecodeArray 等）我们<strong>不</strong>把它们称为槽位；参数一般称为 argument slots（<code>a0,a1</code>）或单独描述。</p>\n<p>严格从 V8 内存视角来看，栈帧中的每一个 8 字节存储单元（无论是 Context、返回地址还是局部变量）在源码中都统称为 <strong>Slot</strong>。</p>\n<p>但在解释器字节码的语句环境中，为了<strong>区分功能</strong>：</p>\n<ul>\n<li>我们将固定位置、用途单一的区域称为 <strong>“固定头部字段”</strong>（如 Function, Context）。</li>\n<li>我们将用于存储局部变量和临时结果、通过索引动态访问的区域特称为 <strong>“寄存器槽位”</strong> 或 <strong>“局部变量槽位”</strong> 或简称为 <strong>槽位</strong> 。</li>\n<li><strong>有时候可能会有混用，将栈上某字段也称为槽位，从规范从v8源码上来说，完全没有错误，只是因为手抖或者写快了，没有按照我们通常的按功能区分的约定称呼。</strong></li>\n<li>当然，你可以按照自己的意愿，区分或者不区分，<strong>都是正确的</strong>。前提是  你要知道观察的视角的不同。</li>\n</ul>\n<p>下面我们详细介绍一下栈帧的结构。</p>\n<p>栈的生长顺序，是<strong>从高地址到低地址</strong>，即入栈早的在高地址， 最后入栈的处于栈顶 在低地址。</p>\n<p>我们首先介绍个术语：Tagged Pointer</p>\n<blockquote>\n<h4 id=\"tagged-pointer--标签指针\">Tagged Pointer  标签指针</h4>\n<p>64位系统中，每个槽位都是 8 字节（64 位），V8 在这里面存数据时，使用了一个编码技巧，叫做 <strong>Tagged Pointer (带标签的指针)</strong>。</p>\n<p>在静态语言立，比如 C++ 这种静态语言，编译器知道变量是 <code>int</code> 还是 <code>Object*</code>。但在 JavaScript 中，类型是动态的。如果 V8 为每个变量额外存一个“类型字段”，内存消耗会翻倍。 V8 的做法是：<strong>把类型信息直接编码进这 64 位数据本身。</strong></p>\n<p><strong>方法就是复用“对齐留下的低位”</strong> 在 64 位平台上，内存地址通常是 <strong>8 字节对齐</strong> 的。合法地址的二进制形式，<strong>最低的几位通常都是 0</strong>。 V8 就是使用了这些闲置的低位，用来打上类型标签Tag。</p>\n<p><strong>Tagged Value 的分类：</strong> V8 把槽位里的机器字统称为 <strong>Tagged Value</strong>，根据低位标签不同，分为两类：</p>\n<p><strong>Smi (Small Integer，标签立即量)</strong></p>\n<ul>\n<li><strong>特征</strong>：最低位通常为 <code>0</code>。</li>\n<li><strong>含义</strong>：这 <strong>不是</strong> 指针，这 64 位数据本身就存着一个整数。</li>\n<li><strong>优势</strong>：整数直接住在栈上，不需要去堆里申请内存，速度极快。</li>\n<li><strong>还原</strong>：使用时，通过<strong>右移 (Shift)</strong> 运算去掉标签，就能得到整数值。</li>\n</ul>\n<p><strong>Tagged Pointer (堆对象引用)</strong></p>\n<ul>\n<li><strong>特征</strong>：最低位通常为 <code>1</code>。</li>\n<li><strong>含义</strong>：这是一个指向堆内存中对象（HeapObject）的 <strong>强引用</strong>。</li>\n<li><strong>注意</strong>：它不能直接当做物理地址用。</li>\n<li><strong>还原</strong>：使用时，必须通过<strong>位掩码 (Mask)</strong> 运算去掉标签（Untag），还原成纯净的内存地址，才能去访问堆里的对象。</li>\n</ul>\n<p>这样使用Tag以后， Tagged value 就像给数据穿了一件“马甲”。Ignition 看一眼马甲（标签位），就知道是整数还是对象。虽然使用前必须“脱马甲”（Untag），但这带来的性能提升和内存节省是巨大的。</p>\n<p>另外需要注意，使用tag标记，  能直接判定的类型集合很小（主要是 Smi 或HeapObject），更细的类型，需要读取对象头来获取。</p>\n</blockquote>\n<p>那么 ，栈帧的结构是怎样的呢？它的组成如下：</p>\n<ul>\n<li>\n<p>第一层  参数区 Arguments</p>\n<p>当调用一个函数时，调用者Caller需要给它传实参，同时还有个隐形参数this，这些内容，都在栈帧的第一层参数区。</p>\n<ul>\n<li><strong>Receiver (this)</strong>：\n<ul>\n<li>这是个隐形参数。当你写 <code>obj.func()</code> 时，<code>obj</code> 就是 Receiver。它是参数列表里的隐形老大哥。</li>\n</ul>\n</li>\n<li><strong>Arguments (<code>a0</code>, <code>a1</code>...)</strong>：\n<ul>\n<li>这就是 <code>function foo(x, y)</code> 里的 <code>x</code> 和 <code>y</code>。</li>\n<li>Ignition 给它们编的号是 <code>a0</code>, <code>a1</code>...</li>\n<li>要注意的是，这里的 <code>a</code> 代表 Argument，不要和 Accumulator 搞混了。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>第二层  固定头部  Fixed header / fixed frame part</p>\n<p>这是整个栈帧中最重要、最关键的区域。</p>\n<p>既然 Ignition 是个软件模拟的 CPU，那 CPU 运行时需要的那些状态  比如“我现在运行到哪一行了？”、“我的环境是谁？”  。。。等等信息， 都是存在哪的？</p>\n<p>没错，就存在这儿，固定头部。</p>\n<p>每个函数栈帧的中间，都夹着这么一块雷打不动的区域，保存着维持虚拟机运行的<strong>元数据</strong></p>\n<p>它里面的主要内容：</p>\n<ol>\n<li>\n<p><strong>Return Address (返回地址)</strong>：</p>\n<ul>\n<li><em>作用</em>：等这个函数执行完，底层调用栈就会根据这个返回地址，跳回调用处继续执行。</li>\n<li>这里腰注意，返回地址， 是控制流，是返回的应该到代码的哪个位置去继续执行。</li>\n</ul>\n</li>\n<li>\n<p><strong>Caller's Frame Pointer (上一层栈帧指针)</strong>：</p>\n<ul>\n<li>\n<p><em>作用</em>：链表指针。当前函数执行完、调用者的栈帧在哪里？</p>\n</li>\n<li>\n<p>这样依旧要注意，这个指针，指的是数据，上个字段返回地址，是控制流的返回，这里</p>\n</li>\n<li>\n<p>的上层栈帧指针，是控制流返回以后，继续执行， 应该从哪里去找变量，返回的是那个</p>\n</li>\n<li>\n<p>栈帧，可以理解为数据。</p>\n</li>\n<li>\n<p>在理解上，还可以大致认为，</p>\n</li>\n<li>\n<p>返回地址是等这个函数执行完，要回到哪一行继续执行代码，也就是<strong>控制流</strong>该跳回哪里。这是时间上的返回 ，代码继续从哪里跑。</p>\n<p>上一层栈帧指针是调用我的那个函数，它的栈帧从哪里开始？<br />\n这是空间上的返回 ，要去哪一块内存里继续访问局部变量和作用域数据。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Context (上下文指针)</strong></p>\n<ul>\n<li>\n<p><em>这是什么</em>：它指向 <strong>堆内存 (Heap)</strong> 中一个叫做 <code>Context</code> 的对象。</p>\n</li>\n<li>\n<p>为什么要它：</p>\n<p>如果函数里用到的变量是自己的 let a，直接去栈上找（r0）。</p>\n<p>但如果用到了闭包变量（外层函数的变量），Ignition 必须拿着这个 Context 指针，去堆里的上下文链表上一层层找。</p>\n</li>\n<li>\n<p><em>地位</em>：它是连接 <strong>“栈世界（临时数据）”</strong> 和 <strong>“堆世界（持久数据）”</strong> 的唯一桥梁。</p>\n</li>\n<li>\n<p>这个概念非常重要，值得我们深入了解。另外插一句，虽然说  这整个部分都可以了解为主，但是如果认真学习，能够掌握，还是有很大的用处。比如这个栈帧，对于js开发还是很重要的。</p>\n</li>\n<li>\n<p>上面有个上一层栈帧指针，这里又有个上下文指针，怎么正确而深入的理解他们呢？</p>\n</li>\n<li>\n<p>**上一层栈帧指针是“动态调用链” **</p>\n<ul>\n<li><strong>回答的问题：</strong> “我是被谁调用的？”</li>\n<li><strong>指向哪里：</strong> 指向<strong>栈（Stack）</strong>上的上一级栈帧。</li>\n<li><strong>作用：</strong> 函数执行完（return）后，底层会根据返回地址跳回调用者继续执行，而上一层栈帧指针则用来恢复调用者的栈帧布局，用于继续访问它的局部变量等数据。</li>\n</ul>\n<p>**Context 是“静态作用域链” **</p>\n<ul>\n<li><strong>回答的问题：</strong> “我是被定义在哪里的？”</li>\n<li><strong>指向哪里：</strong> 指向<strong>堆（Heap）</strong>上的 Context 对象。</li>\n<li><strong>作用：</strong> 它是<strong>数据流</strong>的查找路线。当函数访问一个不在自己内部的变量（自由变量）时，V8 会顺着这条链去查找。</li>\n</ul>\n</li>\n<li>\n<p>理解的关键点</p>\n</li>\n<li>\n<p><strong>上一层栈帧指向的是栈内存</strong>：栈帧是临时的，函数一返回，栈帧就销毁了。</p>\n<p><strong>Context 指向的是堆内存</strong>：这是为了实现 JavaScript 的<strong>闭包</strong>特性。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Function / Frame Marker (函数/帧类型标记)</strong>：</p>\n<ul>\n<li>\n<p>这个字段的<strong>位置</strong>在<code>[FP - 16]</code>  <strong>请注意</strong>  这里的偏移值 16 仅是<strong>示意</strong>。  这种表示方法，后面会详细介绍。</p>\n</li>\n<li>\n<p>这是一个具有<strong>多态性 (Polymorphic)</strong> 的关键槽位。它用于当前栈帧的身份识别。V8 引擎利用这个槽位来区分当前栈帧是属于标准的 JavaScript 函数调用，还是属于引擎内部的 C++ 调用。</p>\n</li>\n<li>\n<p>V8 的栈遍历器（Stack Walker）在扫描堆栈时（例如进行 GC 标记、生成错误堆栈或反优化时），会读取该槽位的值，并根据 <strong>指针标记位 (Tag Bit)</strong> 进行判断：</p>\n<ul>\n<li><strong>如果是对象指针（Heap Object）</strong>：判定为 <strong>Interpreted Frame</strong>（解释器帧）。</li>\n<li><strong>如果是小整数（Smi）</strong>：判定为 <strong>Internal Frame</strong>（内部帧）。</li>\n</ul>\n</li>\n<li>\n<p>具有两种可能的状态：</p>\n</li>\n<li>\n<p>状态 A：存放 <code>JSFunction</code> (Closure)</p>\n<ul>\n<li><strong>场景</strong>：当执行常规 JavaScript 代码时。</li>\n<li><strong>内容</strong>：指向当前正在执行的函数对象（闭包）的指针。</li>\n<li><strong>作用</strong>：\n<ol>\n<li>作为<strong>资源入口</strong>：解释器通过它访问 <code>SharedFunctionInfo</code>（获取字节码）和 <code>FeedbackVector</code>（获取优化反馈）。</li>\n<li>连接<strong>堆与栈</strong>：保持对堆上函数对象的强引用，防止被 GC 回收。</li>\n</ol>\n</li>\n</ul>\n<p><strong>状态 B：存放 <code>StackFrame::Type</code> (Marker)</strong></p>\n<ul>\n<li><strong>场景</strong>：当执行 V8 内部代码（如 <code>EntryFrame</code>, <code>ConstructFrame</code>, <code>BuiltinFrame</code>）时。</li>\n<li><strong>内容</strong>：一个枚举值（Smi），标识具体的帧类型。</li>\n<li><strong>作用</strong>：\n<ol>\n<li><strong>路标作用</strong>：告诉栈遍历器如何解析当前帧的其余部分（不同类型的内部帧，布局可能不同）。</li>\n<li><strong>边界界定</strong>：标记 JS 代码与 C++ 代码的转换边界</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Bytecode Array (字节码数组指针)</strong>：</p>\n<ul>\n<li>\n<p><strong>这个字段的位置：</strong> <code>[FP - 24]</code>   依旧请注意，偏移值 24 仅是示意。</p>\n</li>\n<li>\n<p><strong>这个字段的内容：</strong> 一个指向堆内存中 <code>BytecodeArray</code> 对象的 <strong>Tagged Pointer</strong>。</p>\n</li>\n<li>\n<p><strong>定义：</strong> 它是解释器 Ignition 真正“读取”和“执行”的指令序列源头。</p>\n</li>\n<li>\n<p>这个字段是一个指针，指向堆（Heap）上的一个<code>BytecodeArray</code> 对象。</p>\n<p>之所以叫 <code>Array</code>，是因为它的<strong>主体部分</strong>确实是一串连续的、变长的字节序列。</p>\n<p>在 V8 的底层 C++ 定义中，凡是符合 <strong>“定长头部 + 变长尾部”</strong> 结构的对象，通常都以此命名。</p>\n<ul>\n<li><strong>普通对象 (<code>JSObject</code>)</strong>：大小通常是固定的（或者由 Map 描述）。</li>\n<li><strong>数组类对象 (<code>FixedArray</code>, <code>ByteArray</code>)</strong>：\n<ol>\n<li>它是<strong>变长</strong>的（在分配时决定大小）。</li>\n<li>它的<strong>主要内容</strong>是可以通过索引（Index）访问的序列。</li>\n</ol>\n</li>\n</ul>\n<p>之所以叫 <code>BytecodeArray</code> 是为了强调它的<strong>存储形态</strong>是线性的字节序列。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Bytecode Offset (字节码偏移量 / PC)</strong>：</p>\n<ul>\n<li><em>作用</em>：<strong>程序计数器</strong>。记录当前执行到第几条指令了。</li>\n<li><strong>位置：</strong> <code>[FP - 32]</code> (即 <code>StandardFrameConstants::kBytecodeOffset</code>)  ，偏移值32，仅为示意，并非确定值。</li>\n<li><strong>形式：</strong> <strong>Smi (小整数)</strong>。</li>\n<li><strong>含义：</strong> 它记录了当前执行到了 <code>BytecodeArray</code> 中的<strong>第几个字节</strong>。</li>\n<li><em>细节</em>：在正常解释执行期间，PC 状态常驻在<strong>真实的物理寄存器</strong>，在之中不停的变动，只有在需要外部可见或恢复时（GC/中断/断点/反优化/进入 runtime 等），解释器会把寄存器的值写回栈帧 BytecodeOffset 字段）。恢复时会把它再装回物理寄存器。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>第三层   工作区  Work Area / Virtual Registers</p>\n<p>这是栈帧中位于固定头部后面、向低地址延伸的区域。</p>\n<p>Ignition 将这段连续的内存槽位，给它们编上号：<code>r0</code>, <code>r1</code>, <code>r2</code>...</p>\n<p>虽然它们在物理上只是连续的 8 字节内存格子，但在逻辑上，它们通常划分成了三种截然不同的用途。</p>\n<h4 id=\"1-显式局部变量-explicit-locals\">1. 显式局部变量 (Explicit Locals)</h4>\n<p>这是最好理解的部分。它们直接对应你在 JavaScript 代码中声明的局部变量。</p>\n<p>生成器（BytecodeGenerator）会按照特定算法（通常与声明顺序相关）为这些变量分配槽位。</p>\n<ul>\n<li>示例</li>\n</ul>\n<p>function demo() {<br />\nvar name = 'v8';  // 编译器决定：分配给 r0<br />\nlet age = 10;     // 编译器决定：分配给 r1<br />\n}</p>\n<p>当代码执行到这里时，<code>r0</code> 槽位里就填入了 <code>\"v8\"</code> 的指针，<code>r1</code> 槽位里填入了 <code>10</code> 的 Smi 值。</p>\n<ul>\n<li>\n<p><strong>关键点：作用域分析 (Scope Analysis)</strong></p>\n<p><strong>要注意</strong>  并不是你写的所有局部变量都能住在这个“栈上的工作区”。</p>\n<p>在生成字节码之前，V8 会先进行一次 <strong>作用域分析</strong>。</p>\n<ul>\n<li><strong>判断标准</strong>：如果一个变量被内部函数（闭包）<strong>捕获 (Captured)</strong> 了，它就不能住在栈上</li>\n<li><strong>原因</strong>：栈帧生命是有限的，函数执行完就销毁了。但闭包可能在函数执行完后还需要访问这个变量。</li>\n<li><strong>结果</strong>：被捕获的变量会被请到堆内存的 <strong>Context 对象</strong> 中。</li>\n<li><strong>结论</strong>：所以，能安稳住在 <code>r0, r1</code> 里的，都是身家清白的、<strong>未被捕获</strong>的局部变量。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-隐式临时变量-implicit-temporaries\">2. 隐式临时变量 (Implicit Temporaries)</h4>\n<p>这是在源代码里完全看不到，但机器执行时必须存在的变量。这也是 <strong>寄存器分配 (Register Allocation)</strong> 算法大显身手的地方。</p>\n<ul>\n<li>\n<p><strong>为什么要临时变量？</strong></p>\n<p>想象一下计算 <code>var x = a + b + c;</code></p>\n<p>Ignition 的累加器（老师傅的随身包）只有一个。</p>\n<ol>\n<li>先把 <code>a</code> 拿进包，把 <code>b</code> 加进来。包里现在是 <code>(a+b)</code>。</li>\n<li>下一步要加 <code>c</code>。指令要求 <code>Add c</code>。</li>\n<li><strong>发生冲突</strong>：如果 <code>c</code> 的获取过程很复杂（比如 <code>c</code> 是个函数调用 <code>getC()</code>），那么在执行 <code>getC()</code> 的过程中，累加器会被反复使用、覆盖。</li>\n<li><strong>如何解决</strong>：必须先把 <code>(a+b)</code> 的结果找个格子 <strong>暂存 Spill</strong> 起来。</li>\n</ol>\n</li>\n<li>\n<p><strong>物理存在</strong>：</p>\n<p>Ignition 会在局部变量后面，划出一些格子作为 <strong>临时寄存器</strong>。</p>\n<p>这些格子就像老师傅手边的“小黑板”。</p>\n<ul>\n<li><strong>复用性</strong>：这行代码算完了，这张“小黑板”擦干净，立刻给下一行代码复用。所以即使代码很长，只要不同时通过大量中间结果，Frame Size 也不会很大。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-神秘的洞-the-hole\">3. 神秘的洞 (The Hole)</h4>\n<p>这是 ES6 引入 <code>let/const</code> 后，V8 在底层实现 <strong>TDZ (暂时性死区)</strong> 的最硬核手段。</p>\n<p>在第一部分解析篇中，我们已经详细学习了这个 会吹哨子的警卫thehole，忘记了的朋友，可以复习一下第一篇中的相关内容。这里我们略微的再讲一下。</p>\n<p>在栈帧刚刚被创建，但代码还没执行到 <code>let a = ...</code> 这一行时，<code>rX</code> 槽位里放的是什么？</p>\n<ul>\n<li>\n<p><strong>对于 <code>var</code></strong>：</p>\n<p>V8 会把对应的槽位初始化为 <code>undefined</code>。所以在赋值前访问它，拿到的就是 <code>undefined</code>（变量提升）。</p>\n</li>\n<li>\n<p><strong>对于 <code>let / const</code></strong>：</p>\n<p>V8 会把对应的槽位填入一个特殊的 <strong>会吹哨子的警卫</strong>，在内部被称为 <strong><code>The Hole</code></strong>。</p>\n</li>\n<li>\n<p><strong>执行时的检查机制</strong>：</p>\n<p>Ignition 在执行读取变量的指令（如 <code>LdaRep</code>）时，内置了一段小逻辑：</p>\n<p>// 伪代码<br />\nvalue = load(r1);<br />\nif (value == The_Hole_Value) {<br />\nthrow ReferenceError(\"Cannot access before initialization\");<br />\n}</p>\n<p>TDZ 并不难理解，它在物理层面上，就是一个槽位里放着 <code>The Hole</code>，而解释器在读取时不仅读数据，还顺手做了一次安全检查，如果摸到的是警卫，哨子就响。</p>\n</li>\n</ul>\n<h4 id=\"4-寻址机制如何找到-r5\">4. 寻址机制：如何找到 <code>r5</code>？</h4>\n<p>工作区只是一段连续的内存，Ignition 怎么知道 <code>r5</code> 在哪？</p>\n<p>这就要用到汇编里的 <strong>基址寻址</strong> 了。</p>\n<ul>\n<li>\n<p><strong>基准点</strong>：<strong>FP (Frame Pointer)</strong>，指向固定头部的特定位置。</p>\n</li>\n<li>\n<p>有朋友可能会有疑问了，前面说栈帧有3部分，第一部分是参数区，可是为什么FP基准点指向固定头部 ，而不是指向参数部分。</p>\n</li>\n<li>\n<p>参数空间是<strong>调用者</strong>的区域，因此在语义上它属于caller 的部分 ，而不是 callee 用来分配本地变量/临时的 workspace。FP 作为被调用者的栈帧基准点，通常是不包括参数区的。</p>\n</li>\n<li>\n<p><strong>计算公式</strong>：</p>\n<p>由于栈是向低地址增长的，所以寄存器的地址是 FP 减去一个偏移量。</p>\n<p>Address(rn) = FP - fixed_header_size - (n * slot_size)</p>\n<p>其中 <code>fixed_header_size</code> 是固定头部的字节长度，<code>slot_size</code> 通常等于机器指针大小（在 64 位系统下常为 8 字节）</p>\n</li>\n<li>\n<p><strong>示例：</strong></p>\n<ul>\n<li><code>FP</code> 指向这里。</li>\n<li>往下走 8 字节... 是 <code>Context</code> <code>[FP-8]</code>。</li>\n<li>再往下... 是 <code>Function</code> <code>[FP-16]</code>。</li>\n<li>再往下... 是 <code>BytecodeArray</code> <code>[FP-24]</code>。</li>\n<li>再往下... 是 <code>BytecodeOffset</code> <code>[FP-32]</code>。<strong>(固定头部结束)</strong></li>\n<li><strong>再往下... 终于到了工作区的 r0</strong> <code>[FP-40]</code>。</li>\n<li><code>r0</code> 再往下 8 字节是 <code>r1</code>。</li>\n</ul>\n<p>所以，字节码里的简单指令 <code>Ldar r5</code>，翻译到底层 CPU 动作，就是去读更深处的内存地址。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4--调用约定和内存布局\">4 . 调用约定和内存布局</h2>\n<p>通过前面的学习，我们已经大致了解了栈帧的内容，现在我们就需要在脑子中建立起动态的栈帧模型。</p>\n<ul>\n<li>\n<p>建立我们自己的心智模型，内存的想象图</p>\n<p>那么 我们怎么想象内存呢？ 梯子，高耸入云的梯子，一格一格的代表内存单元。</p>\n<p><strong>地面（最底下）</strong>：是 <strong>高地址</strong>（比如 <code>0xFF...</code>）。对于栈帧来讲，这是稳固的地基。</p>\n<p><strong>天空（往上看）</strong>：是 <strong>低地址</strong>（比如 <code>0x00...</code>）。这是延伸空间。</p>\n<p>最底下是高地址，越往上，地址越低。</p>\n<p>有朋友可能会问：“书上或者 V8 源码注释里，通常都是画‘高地址在上，低地址在下’，栈是‘向下生长’的，为什么我们要反着来？”</p>\n<p>这其实是为了贴合<strong>直觉</strong>。 如果你使用过 OllyDbg、x64dbg 或 IDA 等调试工具，你会发现它们的内存视图通常是这样的：</p>\n<ul>\n<li><strong>上面</strong> 显示的是 <strong>低地址</strong>。</li>\n<li><strong>下面</strong> 显示的是 <strong>高地址</strong>。</li>\n</ul>\n<p><strong>这种视角的好处极其直观：</strong></p>\n<ul>\n<li><strong>入栈 Push</strong>：就像盖楼一样，在现有的楼顶上，<strong>往上</strong> 再盖一层（地址变低/变小）。</li>\n<li><strong>出栈 Pop</strong>：就像拆楼一样，把最上面的一层拆掉（地址变回高/变大）。</li>\n<li><strong>栈底</strong>：在最下面（高地址），通常存放着调用者的环境，在一个栈帧中，很少变动。</li>\n<li><strong>栈顶</strong>：在最上面（低地址），数据频繁进进出出出栈入栈，变动剧烈。</li>\n</ul>\n<p>所以，为了理解起来更顺畅，建议我们在脑海中建立的模型如下：</p>\n<ul>\n<li><strong>高地址在下</strong>（地基）。</li>\n<li><strong>低地址在上</strong>（天空）。</li>\n<li><strong>栈帧的生长方向</strong>：从下往上，<strong>向低地址生长</strong>。</li>\n</ul>\n</li>\n<li>\n<p>指针和内存单元</p>\n<p><strong>最小刻度：字节 (Byte)</strong> 在计算机里，<strong>8 bit (1字节)</strong> 是内存可寻址的最小单位。</p>\n<p><strong>实际步长：</strong>    虽然刻度是按 字节 画的，但在 64 位系统里，Ignition 这个老师傅手很大。 他干活时，<strong>不会像学友哥那样捏着兰花指去抓 1 个字节。</strong>   他<strong>每一次伸手，都要抓走 8 个字节</strong>（64 bit）。这 8 个字节合起来，才构成了一个完整的 <strong>槽位 (Slot)</strong>。</p>\n<p><strong>内存对齐：</strong> 每一次都要操作 8 个字节，所以，所操作的地址，都是8的倍数：</p>\n<p>0  8  16  24 。。。（这些数字仅仅是示意地址是8的倍数）</p>\n<p>这就是 <strong>内存对齐</strong>。</p>\n<p><strong>注意：</strong> 这并不代表地址 <code>1, 2, 3...7</code> 是“空闲”或者“没用”的。 当你向地址 <code>0</code> 写入一个 64 位指针或者数据时，这个指针或数据用64bit的庞大的身躯<strong>填满</strong>了从 <code>0</code> 到 <code>7</code> 的所有空间。 只不过，当我们想<strong>找到</strong>这个数据时，我们只在这个数据的<strong>头部（首地址）</strong> 找起。</p>\n<p><strong>地址 0</strong>：是第一个槽位的<strong>门口</strong>。<strong>地址 8</strong>：是第二个槽位的<strong>门口</strong>。</p>\n<p>这就解释了我们在前面内容中提到的 <strong>Tagged Pointer</strong> 原理： 因为地址只在 <code>0, 8, 16</code> 这些 <code>8</code> 的倍数上，所以这些地址的二进制表示，<strong>最后 3 位通常是 0</strong>。 V8 也是看准了这一点，才敢把这 3 位挪作他用（存类型 Tag）。</p>\n<p><strong>指针</strong>   如何理解？</p>\n<p>指针就是地址，之所以说是指针 而不是直接说地址，是因为 指针收紧了地址的概念。</p>\n<p>“地址”是物理层面的客观存在，而“指针”是软件层面的主观定义。指针对地址具有收紧和约束作用。</p>\n<p>准确的说  <strong>指针是对地址概念的一次“收紧”和“赋予语义”</strong>。</p>\n<ul>\n<li>\n<p><strong>地址</strong></p>\n</li>\n<li>\n<p><strong>本质</strong>：它只是一个冷冰冰的数字编号（比如 <code>0x0000FFFF</code>）。</p>\n</li>\n<li>\n<p><strong>缺陷</strong>：它没有任何约束。给你一个地址，你根本不知道那里住的是什么。</p>\n<ul>\n<li>是 4 个字节的整数？</li>\n<li>还是 1 个字节的字符？</li>\n<li>或者是一段可执行的代码？</li>\n<li>甚至可能是一个无效的垃圾值？</li>\n</ul>\n</li>\n<li>\n<p><strong>状态</strong>：如果你只拿到了一个地址，你面对的是未知的、混乱的内存空间。</p>\n</li>\n<li>\n<p>**指针 **</p>\n</li>\n<li>\n<p><strong>本质</strong>：<strong>指针 = 地址 + 类型约束（解释方式）</strong>。</p>\n</li>\n<li>\n<p><strong>收紧的概念</strong>：</p>\n<p>当我们定义一个指针（比如 C++ 里的 <code>int* p</code> 或 V8 里的 <code>Tagged Pointer</code>）时，我们实际上是<strong>收紧</strong>了对那个内存地址的操作权限和理解方式。</p>\n<ul>\n<li>它告诉 CPU：“别乱猜了，这个地址里存的一定是 <strong>对象</strong>，而不是整数。”</li>\n<li>它告诉编译器：“当你去读这个地址时，请按照 <strong>8 字节</strong> 为单位去读，不要只读 1 个字节。”</li>\n</ul>\n</li>\n</ul>\n<p>在 V8 的 Ignition 中，这种“收紧”体现得更全面：</p>\n<ol>\n<li>\n<p><strong>标签 (Tagging)</strong>：</p>\n<p>V8 的指针（Tagged Pointer）利用最低位（Tag Bit）强行规定了语义。</p>\n<ul>\n<li>如果最后一位是 <code>0</code>：<strong>收紧为“立即数”</strong>（Smi）。不需要去内存里找，它自己就是值。</li>\n<li>如果最后一位是 <code>1</code>：<strong>收紧为“堆指针”</strong>（HeapObject）。必须去堆里找。</li>\n</ul>\n</li>\n<li>\n<p><strong>隐藏类 (Map/Hidden Class)</strong>：</p>\n<p>当你顺着 V8 的指针找到堆里的对象时，对象的第一个属性通常是 <strong>Map</strong>（隐藏类）。</p>\n<p>这实际上是进一步的“收紧”：</p>\n<ul>\n<li>“这个地址不仅是个对象，而且它是一个 <strong>数组</strong>，长度是 10，元素类型是...”。</li>\n</ul>\n</li>\n</ol>\n<p>最后需要注意，越往底层，比如到了汇编  到了代码调试 ，对于指针和地址的区分，就越趋近于无，很多时候，都是混着叫的，基本上都是使用指针就是地址 这个本质概念了。因为约束已经剥离，只剩本质了。</p>\n<p><strong>调用约定</strong></p>\n<p>我们在前面学习了栈帧的物理结构：参数在高地址，返回地址在中间，变量在低地址。</p>\n<p>这时候，无中生友的朋友又出现了：为什么要这么放？我倒过来放不行吗  我混着放不行吗？</p>\n<p>这就引出了一个重要的概念 调用约定。</p>\n<ul>\n<li>\n<p>简单来说，调用约定就是 <strong>调用者 (Caller)</strong> 和 <strong>被调用者 (Callee)</strong> 之间达成的一份 <strong>“协议”</strong> 或 <strong>“合同”</strong>。</p>\n<p>想象一下两个人在玩球球：</p>\n<ul>\n<li>\n<p><strong>Caller</strong> 说：“我会把球抛到<strong>你的左手边</strong>。”</p>\n</li>\n<li>\n<p><strong>Callee</strong> 说：“好的，我会跑到<strong>左手边</strong>去接球。”</p>\n<p>这就是约定。如果 Caller 抛向左边，而 Callee 跑去右边接，球就掉了（程序崩溃）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>在 V8 里，这份 协议/合同 规定了三个最核心的问题：</p>\n<ol>\n<li><strong>参数放哪？</strong> (传递方式)\n<ul>\n<li>是放在 CPU 寄存器里？还是压到栈内存里？</li>\n<li>如果是压栈，是从左往右压，还是从右往左压？</li>\n</ul>\n</li>\n<li><strong>结果放哪？</strong> (返回方式)\n<ul>\n<li>函数算完了，结果放在哪个寄存器里带回去？（通常是累加器/rax）。</li>\n</ul>\n</li>\n<li><strong>谁来打扫卫生？</strong> (堆栈平衡)\n<ul>\n<li>参数占用的栈空间，是 Caller 负责回收，还是 Callee 负责回收？</li>\n</ul>\n</li>\n</ol>\n<p><strong>V8的特殊之处：垃圾回收</strong></p>\n<p>在c / c++ 中， 标准约定通常会优先把前几个参数放在 <strong>物理寄存器</strong> 里传递，这样速度会达到极致。</p>\n<p>但是在V8的 Ignition 解释器里，我们看到参数几乎都是乖巧的排列在栈上。这是为什么？</p>\n<p>因为 V8 有一个幽灵暗卫 ，这就是 <strong>垃圾回收器 (GC)</strong>。</p>\n<ul>\n<li><strong>GC 的全年无休</strong>：GC 需要时刻扫描内存，看看哪些对象还活着（有指针指向它）。</li>\n<li><strong>寄存器无法跟踪</strong>：如果参数散落在各种物理寄存器里，这就很难追踪。</li>\n<li><strong>V8 的折中拖鞋</strong>：<strong>确保栈上有一份“可扫描”的备份。</strong></li>\n</ul>\n<p>即使某些参数是通过寄存器传进来的，为了方便 GC 撸羊肉串式的扫描，V8 通常也会保证这些参数在栈上有一个确定的位置（或者把寄存器的值“抄写”到栈上）。记得前面说PC的时候，提过一次。</p>\n<p>so  这就形成了我们在栈帧图中看到的那样,参数在内存里连续排列，GC 扫起来非常舒服。</p>\n<p><strong>再说栈帧的内存布局</strong></p>\n<p>在前面我们讲栈帧的结构时，从高地址到低地址，依次是  参数区--固定头部区--工作区，但是</p>\n<p>对于栈帧的分界和字段的所有者，并没有详细的说明。 现在我们有了足够的铺垫，可以详细了解了。</p>\n<p>我们需要按<strong>时间顺序</strong>走一遍流程。</p>\n<p>这对于理解 FP（栈帧指针）这个“界碑”至关重要。</p>\n<p><strong>第一阶段：调用者准备工作</strong></p>\n<p>调用者在执行 <code>CALL</code> 指令之前，需要先准备好贡品：</p>\n<ol>\n<li>\n<p><strong>Push 参数</strong>：调用者把参数（Receiver, a0, a1...）按顺序压入栈。</p>\n<ul>\n<li><em>(这是 Caller 划拨的内存，属于 Caller 的栈帧范围，但供 Callee 使用)</em></li>\n</ul>\n</li>\n<li>\n<p><strong>执行 CALL 指令</strong>：CPU 自动将 <strong>返回地址 (Return Address)</strong> 压入栈顶，并跳转到 Callee 的代码处。</p>\n<ul>\n<li><em>(此时，FP 指针依然指向 Caller 的老基准点)</em></li>\n</ul>\n</li>\n</ol>\n<p><strong>第二阶段：被调用者接手</strong></p>\n<p>控制权来到了 Ignition（被调用者）手中，它进门后的<strong>头等大事</strong>就是建立自己的宗门（栈帧）：</p>\n<ol>\n<li><strong>Push Caller's FP</strong>：Ignition 做的第一件事，就是把旧的 FP（上一层的基准点）压入栈中保存起来。\n<ul>\n<li><em>(这一步形成了 Saved FP，也就是栈帧中间的那个连接点)</em></li>\n</ul>\n</li>\n<li><strong>Set New FP</strong>：Ignition 把当前的栈顶指针 (SP) 赋值给 FP。\n<ul>\n<li><em>(从此，FP 指向了 Saved FP。新的栈帧基准点正式建立)</em></li>\n</ul>\n</li>\n<li><strong>Push Fixed Header</strong>：接着，Ignition 依次压入 Context、Function、BytecodeArray、BytecodeOffset 等固定字段。</li>\n<li><strong>Allocate Locals</strong>：最后，根据 Frame Size，一次性把栈顶指针 (SP) 往下移，为局部变量（r0, r1...）留出空间，并初始化为 <code>undefined</code> 或 <code>The Hole</code>。</li>\n</ol>\n<h3 id=\"_\"></h3>\n<p>有了这个流程，我们再看“户口归属”就非常清晰了：</p>\n<ul>\n<li>\n<p><strong>FP 及其上方 (参数、返回地址)</strong>： 虽然物理上和 FP 连在一起，但它们是 <strong>Caller</strong> 在第一阶段留下的“遗产”。</p>\n<ul>\n<li>参数是 Caller 带来的。</li>\n<li>返回地址是 Caller 带来的。</li>\n<li>Saved FP 是 Callee 为了保护 Caller 而存的。</li>\n</ul>\n</li>\n<li>\n<p><strong>FP 下方 (固定头部、工作区)</strong>： 这是 <strong>Callee</strong> 在第二阶段亲手创建的“资产”。</p>\n<ul>\n<li>Context 是 Callee 找来的。</li>\n<li>局部变量是 Callee 分配的。</li>\n</ul>\n</li>\n</ul>\n<p>这样，我们再来看栈帧的结构，理解上的逻辑就完全闭环了： <strong>Caller 给资源（参数） --- 硬件给退路（返回地址） ---  Callee 建地基（保存旧FP） ---  Callee 建房子（头部和变量）。</strong></p>\n<p><strong>FP和偏移量</strong></p>\n<p>在前面我们学习栈帧的固定头部中的字段时，我们使用了 FP加偏移值 的表示方式。</p>\n<p>爱琢磨的朋友肯定会有疑问：<strong>为什么所有东西都要盯着 FP 看？为什么是这些特定的数字？FP 里面到底装了什么？</strong></p>\n<ol>\n<li><strong>为什么选 FP (Frame Pointer) 做基准？</strong></li>\n</ol>\n<p>你可能会问：“栈顶指针 <strong>SP (Stack Pointer)</strong> 也是个指针，而且它就在栈顶，为什么不用 SP 来找数据，非要专门维护一个 FP 呢？”</p>\n<p><strong>原因就是：SP 是“动”的，FP 是“静”的。</strong></p>\n<ul>\n<li>\n<p><strong>SP 的动如脱兔</strong>：</p>\n<p>在函数执行过程中，Ignition 可能会频繁地入栈、出栈（比如压入临时变量、准备子函数参数）。</p>\n<p>这就导致 SP 的位置一直在变。</p>\n<p>如果用 SP 做基准，当你找 <code>变量 a</code> 时，上一行代码可能是 <code>[SP + 8]</code>，下一行代码因为压了个临时值，就变成 <code>[SP + 16]</code> 了。编译器计算起来会疯掉。</p>\n</li>\n<li>\n<p><strong>FP 的静如瘫痪</strong>：</p>\n<p>一旦栈帧建立完毕（Prologue 结束），在整个函数执行期间，<strong>FP 指针就是钉在栈帧的固定位置（Saved FP 那个槽位），雷打不动。</strong></p>\n<p>此时，我们以 FP 为原点，向上下看：</p>\n<p><strong>往下看（向地基/高地址）</strong>：不管栈顶怎么变，参数 <code>a0</code> 永远在 FP <strong>往下数</strong> 第 2 格的位置（偏移量是正数，如 <code>FP + 16</code>）。</p>\n<p><strong>往上看（向天空/低地址）</strong>：不管栈顶怎么变，变量 <code>r0</code> 永远在 FP <strong>往上数</strong> 第 5 格的位置（偏移量是负数，如 <code>FP - 40</code>）。</p>\n</li>\n</ul>\n<p><strong>所以</strong>：FP 提供了一个<strong>静态的、绝对的</strong>参考坐标系。</p>\n<ol start=\"2\">\n<li>**FP和地址和内容 **</li>\n</ol>\n<p>这是初接触的朋友，理解栈帧链表最容易迷糊的地方。</p>\n<p>我们要区分三个概念：</p>\n<ul>\n<li><strong>FP 寄存器</strong>：</li>\n</ul>\n<p>可以简化理解为，这是 CPU 里的一个物理部件（或 Ignition 的虚拟指针）。</p>\n<ul>\n<li><strong>FP 中的内容</strong>：</li>\n</ul>\n<p>FP中的内容就是 一个内存地址。</p>\n<p>这个内存地址是个指针，指向当前栈帧中的一个字段，</p>\n<p>同时，这个内存地址/指针，也是当前栈帧的 <strong>“零点”</strong>。即 <code>Offset = 0</code>。</p>\n<ul>\n<li><strong>FP 指向的内存地址里存的内容</strong>：</li>\n</ul>\n<p>那么 这个栈帧中的字段，里面的内容是什么？</p>\n<p><strong>答案是：Caller's FP (调用者的 FP)。</strong></p>\n<p>即：上一层栈帧的基准地址。</p>\n<p><strong>这同时也是“栈回溯”的原理：</strong></p>\n<ul>\n<li>当前 FP 指向 <code>Saved FP</code>。</li>\n<li><code>Saved FP</code> 里存着 <code>上一层 FP</code>。</li>\n<li><code>上一层 FP</code> 里存着 <code>上上层 FP</code>。</li>\n<li>...</li>\n<li>这就形成了一条<strong>链表</strong>。调试器（Debugger）就是顺着这条链子，一层层往上爬，才打印出了完整的调用栈。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>偏移量 (Offset) 是怎么确定的？</strong></li>\n</ol>\n<p>搞懂了 FP 是零点，那么，对于参数和变量的寻址，就非常容易理解了。</p>\n<p>让我们站在 FP 这个零点，开始巡视：</p>\n<p><strong>A. 往下看：Caller 留下的遗产 (因为我们使用高地址在下，低地址在上的模式)</strong></p>\n<p>这里是地址 <strong>增加</strong> 的方向（Offset 是 <strong>正数 +</strong>），因为我们在往高地址走。</p>\n<ul>\n<li><strong>Offset     +0 (<code>[FP + 0]</code>)</strong>： 就是脚下。这里存的是 <strong>Saved FP</strong>。</li>\n<li><strong>Offset     +8 (<code>[FP + 8]</code>)</strong>： <strong>往下</strong> 走 1 格。 这里是 <strong>Return Address</strong>。 <em>(为什么是 +8？因为往高地址走了 8 字节。)</em></li>\n<li><strong>Offset     +16 (<code>[FP + 16]</code>)</strong>： <strong>再往下</strong> 走 1 格。 这里是 <strong>Receiver (this)</strong>。 <em>(注：这是雷打不动的专座，离 FP 最近的参数。)</em></li>\n<li><strong>Offset     +24 (<code>[FP + 24]</code>)</strong>： <strong>再往下</strong> 走 1 格。 这里是 <strong>第一个显式参数 (Arguments a0)</strong>。 <em>(注：如果有更多参数 a1, a2... 会继续往下排在 +32, +40...)</em></li>\n</ul>\n<p><strong>B. 往上看：Callee 自己的资产 (低地址区)</strong></p>\n<p>关于偏移量的具体值，在前面，特别说明是用于  <strong>示意</strong>  ，  V8源码中的偏移如下，暂时可以作为确定值，但是以后很有<strong>可能会更改</strong>。</p>\n<blockquote>\n<p><strong>FP (基准)</strong></p>\n<p><strong>[FP - 8]</strong>: <code>StandardFrameConstants::kContextOffset</code> -&gt; <strong>Context</strong></p>\n<p><strong>[FP - 16]</strong>: <code>StandardFrameConstants::kFunctionOffset</code> -&gt; <strong>Function</strong></p>\n<p><strong>[FP - 24]</strong>: <code>InterpretedFrameConstants::kBytecodeArrayFromFp</code> -&gt; <strong>BytecodeArray</strong> (解释器特有)</p>\n<p><strong>[FP - 32]</strong>: <code>InterpretedFrameConstants::kBytecodeOffsetFromFp</code> -&gt; <strong>BytecodeOffset (PC)</strong></p>\n<p><strong>[FP - 40]</strong>: <code>InterpretedFrameConstants::kRegisterFileFromFp</code> -&gt; <strong>r0 (Register 0)</strong> (工作区起点)</p>\n</blockquote>\n<p>这里也需要加一个限定：</p>\n<p><strong>在 64 位系统下，Ignition 解释器栈帧的固定头部布局通常如下：</strong></p>\n<p>这里是地址 <strong>减小</strong> 的方向（Offset 是 <strong>负数 -</strong>），因为我们在往低地址（栈顶）方向爬。</p>\n<ul>\n<li><strong>Offset     -8 (<code>[FP - 8]</code>)</strong>： <strong>往上</strong> 爬 1 格。 这里是 <strong>Context</strong>。 <em>(为什么是负数？因为离天空更近了，地址变小了。)</em></li>\n<li><strong>Offset    -16 (<code>[FP - 16]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 这里是 <strong>Function</strong>。</li>\n<li><strong>Offset    -24 (<code>[FP - 24]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 这里是 <strong>BytecodeArray</strong>。</li>\n<li><strong>Offset    -32 (<code>[FP - 32]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 这里是 <strong>BytecodeOffset (PC)</strong>。 <em>(注：到这里，固定头部结束)</em></li>\n<li><strong>Offset     -40 (<code>[FP - 40]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 终于到了 <strong>工作区</strong>。这里是 <strong>r0</strong>。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<p>ignition解释器的第一部分，已经完成了，后面将是ignition篇的第二部分BytecodeGenerator。</p>\n<p>本想控制篇幅，但是依旧是到了一万一千多字，这部分内容，难度不大，深度不深，主要都是一些前置和基础知识。感兴趣的朋友，多读几遍，都可以理解的。 我觉得  起码比解析篇容易理解多了。</p>\n<p>本文首发于： <a href=\"https://juejin.cn/user/565561530002222/posts\" rel=\"noopener nofollow\" target=\"_blank\">掘金社区</a></p>\n<p>同步发表于： <a href=\"https://blog.csdn.net/f20171110?type=blog\" rel=\"noopener nofollow\" target=\"_blank\">csdn</a></p>\n<p><a href=\"https://www.cnblogs.com/f20171110\" target=\"_blank\">博客园</a></p>\n<p><strong>码字虽不易 知识脉络的梳理更是不易 ，但是知识的传播更重要，</strong></p>\n<p><strong>欢迎转载，请保持全文完整。</strong></p>\n<p><strong>谢绝片段摘录。</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 19:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/f20171110\">用户新</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LLVM Pass快速入门(四)：代码插桩",
      "link": "https://www.cnblogs.com/ClownLMe/p/19575719",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19575719\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 17:49\">\n    <span>LLVM Pass快速入门(四)：代码插桩</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        从0到1，快速入门 LLVM pass 编写\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"代码插桩\">代码插桩</h1>\n<p>项目需求：在函数运行时打印出运行的函数名</p>\n<h1 id=\"项目目录如下\">项目目录如下</h1>\n<pre><code>/MyProject\n├── CMakeLists.txt # CMake 配置文件\n├── build/ #构建目录\n│   └── test.c #测试编译代码\n└── mypass3.cpp # pass 项目代码\n</code></pre>\n<h3 id=\"一测试代码示例\">一，测试代码示例</h3>\n<p><strong>test.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nvoid func_A() {\n    int a = 1;\n}\n\nvoid func_B() {\n    func_A();\n}\n\nint main() {\n    printf(\"hello world!\\n\");\n    func_A();\n    func_B();\n    return 0;\n}\n</code></pre>\n<h3 id=\"二编写pass\">二，编写Pass</h3>\n<p>其他的固定的模板之前文章注释有，这里我只注释当前项目重要的部分<br />\n<strong>代码流程：</strong> 遍历指令并匹配<code>ADD</code>指令-&gt;替换为<code>sub</code>指令</p>\n<pre><code class=\"language-cpp\">#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Passes/PassBuilder.h\"\n#include \"llvm/Passes/PassPlugin.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IRBuilder.h\" \n\nusing namespace llvm;\n\nnamespace {\n\nstruct mypass3 : public PassInfoMixin&lt;mypass3&gt; {\n    \n    PreservedAnalyses run(Function &amp;F, FunctionAnalysisManager &amp;) {\n        //过滤函数\n        //过滤掉printf和printf有关的函数，防止在printf中插入printf造成递归（死循环）\n        if(F.isDeclaration() || F.getName().starts_with(\"_\") || F.getName().contains(\"printf\")){\n            return PreservedAnalyses::all();\n        }\n        errs() &lt;&lt; \"handle func:\" &lt;&lt; F.getName() &lt;&lt; \"\\n\";\n\t\t\n\t\t//获取模块\n        Module *M = F.getParent();\n        //获取模块上下文\n        //上下文中包含了数据的类型\n        LLVMContext &amp;Ctx = M-&gt;getContext();\n        \n        //下面是创建函数，类比java反射，或者frida的hook\n        //定义printf的参数类型，相当于函数括号中的内容，这里的PointerType是指针类型\n        std::vector&lt;Type*&gt; printfArgs = {PointerType::getUnqual(Ctx)};\n\t\t//定义函数类型，这里相当于定义：int (void*, ...)\n        FunctionType *printfType = FunctionType::get(\n            Type::getInt32Ty(Ctx),//函数返回值类型\n            printfArgs,//函数的参数类型(vector)\n            true//是否是可变参数\n        );\n\t\t//如果printf存在则引用，如果不存在，则创建一个新的printf\n        FunctionCallee printfFunc = M-&gt;getOrInsertFunction(\"printf\", printfType);\n\t\t\n\t\t//下面是插入函数\n\t\t//将修改的位置定位到要插桩函数的头部\n        IRBuilder&lt;&gt; builder(&amp;F.getEntryBlock().front());\n        //声明全局变量（这里是要传给printf的格式化字符串）\n        Value* formatStr = builder.CreateGlobalStringPtr(\"&gt;&gt; enter function %s &lt;&lt;\\n\", \"my_format\");\n        //声明全局变量，这里定义了函数名称的字符串变量\n        Value* funcName = builder.CreateGlobalStringPtr(F.getName(), \"my_func_name\");\n        //将上面定义的实际参数传入\n        std::vector&lt;Value*&gt; printfArgsVec = {formatStr, funcName};\n        //创建函数调用\n        builder.CreateCall(printfFunc, printfArgsVec);\n        \n        return PreservedAnalyses::none();\n    }\n};\n\n} \n\nextern \"C\" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo\nllvmGetPassPluginInfo() {\n    return {\n        LLVM_PLUGIN_API_VERSION,\n        \"mypass3\",\n        \"v0.1\",\n        [](PassBuilder &amp;PB) {\n            PB.registerPipelineParsingCallback(\n                [](StringRef Name, FunctionPassManager &amp;FPM,\n                   ArrayRef&lt;PassBuilder::PipelineElement&gt;) {\n                    if (Name == \"mypass3\") {\n                        FPM.addPass(mypass3());\n                        return true;\n                    }\n                    return false;\n                });\n        }};\n}\n</code></pre>\n<h3 id=\"三pass的构建\">三，Pass的构建</h3>\n<p><strong>下面引用的是之前文章的内容</strong><br />\n构建LLVM Pass需要写<code>CMakeLists.txt</code>构建声明</p>\n<h5 id=\"1-配置cmake配置文件\">1. 配置CMake配置文件</h5>\n<p><strong>CMakeLists.txt</strong><br />\n下面的<code>cmake</code>配置可以直接拿去用，我已经标注好需要修改的位置</p>\n<pre><code class=\"language-python\">#cmake 版本，可通过 cmake --version 判断\ncmake_minimum_required(VERSION 4.1.1) #----&gt;修改 cmake版本号\n#项目名字\nproject(mypass3) #----&gt;修改 项目名称\n\n#导入项目的 LLVM cmake 配置文件路径(如果根据我之前文章安装这里就相同)\nset(LLVM_DIR \"D:/LLVM/llvm-project/build/lib/cmake/llvm\")#----&gt;修改 llvm cmake配置路径\n#寻找 LLVM 的包文件\n#REQUIRED 找不到 LLVM 则停止构建\n#强制使用 LLVM 安装时生成的配置文件进行定位\nfind_package(LLVM REQUIRED CONFIG)\n#将 LLVM 的 CMake 模块路径添加到当前 CMake 搜索路径中，以便后续使用 include(AddLLVM)。\nlist(APPEND CMAKE_MODULE_PATH \"${LLVM_CMAKE_DIR}\")\n\n#引入 LLVM 提供的专用 CMake 宏\ninclude(AddLLVM)\n#将 LLVM 的头文件目录（如 llvm/IR/Function.h）加入编译器的搜索路径\ninclude_directories(${LLVM_INCLUDE_DIRS})\n#导入 LLVM 编译时使用的宏定义\nadd_definitions(${LLVM_DEFINITIONS})\n#设置 C++ 标准为 C++17。(这里如果不用17编译会报错)\nset(CMAKE_CXX_STANDARD 17)\n#强制要求必须支持 C++17，如果编译器不支持则失败。\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n#创建一个模块化的库(.dll)\nadd_library(mypass3 MODULE mypass3.cpp) #----&gt;修改 项目名称，文件名\n#windows不用会报错：导出符号\n#LLVM Pass 需要暴露一些特定的入口点（如 getAnalysisUsage）给 opt 工具调用。\nset_target_properties(mypass3 PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS ON) #----&gt;修改 项目名称\n# 指定该 Pass 需要链接的 LLVM 核心组件。 \n# LLVMCore: 提供 IR、Function、Module 等核心类。 \n# LLVMSupport: 提供各种辅助工具类（如 errs() 输出）。\ntarget_link_libraries(mypass3 LLVMCore LLVMSupport) #----&gt;修改 项目名称，文件名  \n# 为该目标设置特定的编译器选项。 \n# /utf-8: 告诉 MSVC 编译器使用 UTF-8 编码处理源代码，防止中文注释引起的乱码或编译错误。  \ntarget_compile_options(mypass3 PRIVATE /utf-8)#----&gt;修改 项目名称，文件名\n</code></pre>\n<h5 id=\"2编译并构建pass\">2.编译并构建Pass</h5>\n<p><strong>打开visual studio<code>的工作台，我这里是</code>x64 Native Tools Command Prompt for VS 2022`</strong></p>\n<p>进到<code>build</code>目录</p>\n<pre><code class=\"language-bash\">#构建项目\n#其中-DCMAKE_BUILD_TYPE=RelWithDebInfo不选会报错，由于我之前编译的是带符号的relase版本\ncmake -G \"Ninja\"  -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\n#编译\nninja\n</code></pre>\n<p>最后出现下面提示，即为编译成功</p>\n<pre><code class=\"language-bash\">[2/2] Linking CXX shared module mypass3.dll\n</code></pre>\n<h3 id=\"四使用插桩pass对源码进行插桩\">四，使用插桩Pass对源码进行插桩</h3>\n<p>进到<code>build</code>目录</p>\n<pre><code class=\"language-bash\">#把.c文件编译为.ll\n#-O1 使用O1优化（这里我尝试-O0不优化，会导致我的pass无法应用）\n#-Xclang -disable-llvm-passes 不使用默认的pass优化\nclang -S -emit-llvm -O1 -Xclang -disable-llvm-passes test.c -S -o test.ll\n\n#使用pass\nopt -load-pass-plugin=mypass3.dll -passes=mypass3  test.ll -S -o test_opt.ll\n\n#编译使用pass后的exe\nclang test_opt.ll -o test_opt.exe\n#编译使用pass前的exe\nclang test.ll -o test.exe\n</code></pre>\n<p><strong>输出结果</strong><br />\n<code>运行test.exe</code>：<strong>不使用</strong>pass，输出结果如下：</p>\n<pre><code>hello world!\n</code></pre>\n<p><code>运行test_opt.exe</code>：<strong>使用</strong>pass后，输出结果如下：</p>\n<pre><code>&gt;&gt; enter function main &lt;&lt;\nhello world!\n&gt;&gt; enter function func_A &lt;&lt;\n&gt;&gt; enter function func_B &lt;&lt;\n&gt;&gt; enter function func_A &lt;&lt;\n</code></pre>\n<p><strong>我们成功在我们调用函数之前插桩，打印出调用的函数</strong></p>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/ClownLMe/\" target=\"_blank\">ClownLMe</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/ClownLMe/p/19575719\" target=\"_blank\">https://www.cnblogs.com/ClownLMe/p/19575719</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 17:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于项目工程构建SBOM（软件物料清单）的研究",
      "link": "https://www.cnblogs.com/huangqian/p/19575355",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/huangqian/p/19575355\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 16:59\">\n    <span>基于项目工程构建SBOM（软件物料清单）的研究</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        研究项目的SBOM（软件物料清单）的生成。会涉及到四个SBOM生成工具，sbom-tool，DycloneDX，Sift，ORT，分别就每个工具的优缺点做说明看，列出其关键命令和命令参数，并说明其在实际使用过程中的优劣点。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近公司启动了一个新医疗项目，最终需要在国外注册使用（如美国FDA，欧盟），因此项目全生命周期管理过程必须严格，为满足合规要求，其中必不可少的一步是生成SBOM（软件物料清单）。临时给安排一个任务，来研究SBOM的生成。涉及到四个SBOM生成工具，sbom-tool，DycloneDX，Sift，ORT。然后就开发语言来说，公司项目有三种模式，纯C#项目，C++和C#混合使用的项目，纯C++项目，这里就最近几天的研究心得做一个总结。</p>\n<p><strong>sbom-tool</strong><br />\nSBOM Tool是我最先开始，毕竟本人主要从事C#开发，而SBOM Tool（SBOM Tool.exe）是微软开发的开源命令行工具，用于自动生成和验证符合SPDX 2.2/3.0标准的软件物料清单（SBOM），支持跨平台安装和多种使用场景。这里安装方法就不做介绍，网上资料搜下就是，包括后续几种工具安装都不做介绍。我这里是作为dotnet工具全局安装的。可以直接在windows系统的CMD命令下，定位到工程编译之后的输出目录，使用类似如下的关键的命令来生成SBOM。若是要持续的集成CD/CI，在Visual Studio开发工具下，也可以在项目工程上右键-&gt;属性-&gt;生成-&gt;项目的生成成功后的事件中植入此命令，来对每次的构建都重新生成新的sbom。当然也可以将命令作为一个.bat批处理文件，在项目生成成功后来执行此文件来处理SBOM的生成。</p>\n<p>直接CMD中使用示例1：sbom-tool generate -b 项目工程编译之后的输出目录 -pn \"MyApp\" -pv \"1.0.0\" -ps 供应商名称 -m ./sbom-output</p>\n<details>\nsbom-tool构建SBOM关键参数和示例\n<pre><code>-b：构建产物的根目录，即代码编译之后的输出目录\n-bc: 项目源码目录,生成时的一些元数据会通过源码获取到,非必须.\n-pn: 包名称，建议显示指定\n-pv：包版本号\n-ps：包的供应商信息，指定包名称后不能为空\n-m:  指定生成的SBOM的输出目录，-D强制删除已有目录。\n-bl： 指定包含的文件，创建一个包含文件列表的文本文本，每个文件使用完整路径单独一行，使用此参数工具只会处理生成列表中明确指定的文件\n\n在工程文件的生成后事件配置执行sbom生成命令代码，我这里代码是注释的状态：\n\t&lt;!-- 定义生成SBOM的目标 --&gt;\n\t&lt;Target Name=\"GenerateSBOM\" AfterTargets=\"Build\"&gt;\n\t\t&lt;!--使用bl命令进行文件过滤,只处理指定的文件--&gt;\n\t\t&lt;!--&lt;Exec Command=\"sbom-tool generate -b $(OutputPath) -bl $(SbomIncludeFilesPath) -pn $(SbomPackageName) -pv $(SbomPackageVersion) -ps $(SbomCompanay) -m $(OutputPath)\\sbom\"  /&gt;--&gt;\n\t\t&lt;!--&lt;Exec Command=\"sbom-tool generate -b $(OutputPath) -bc $(SbomSourceCodePath) -pn $(SbomPackageName) -pv $(SbomPackageVersion) -ps $(SbomCompanay) -m $(OutputPath)\\sbom\"  /&gt;--&gt;\n\t\t&lt;!--&lt;Exec Command=\"D:\\Release\\sbom\\Generate-SBOM.bat\"  /&gt;--&gt;\n\t&lt;/Target&gt;\n\n</code></pre>\n</details>\n<p>我这里首先是针对C#的项目使用sbom-tool工具进行SBOM生成，这个生成的是符合SPDX标准的SBOM，这个过程中确实很顺利，使用简单的命令运行立马出来结果，但当我需要排除一些文件或组件时，确发现sbom-tool无对应的命令来排除文件，当然，其提供了-bl命令参数来指定只对那些文件生成SBOM。然后针对深度依赖，即嵌套依赖问题识别不友好或者说识别不了，查阅下来说需要借助与其他手段或工具，针对C++项目也是如此。</p>\n<p><strong>CycloneDX</strong><br />\n此时就开始了对第二个工具CycloneDX的研究，这个工具生成的是符合CycloneDX标准的SBOM，这里我也是将其作为dotnet工具进行全局安装的（安装命令：dotnet tool install --global CycloneDX），需要注意的是不要使用旧的项目，如.NET Framework的项目来使用此工具，我这边就是在NET Framework中使用了此工具进行生成，怎么走都没通，之前就是忽略了网上AI资料所提的，SycloneDX for .NET目前不支持早期的版本，.NET Framework，.NET Core的早期版本(如NET Core 2.1，NET Core 3.1，NET Core 5.0)，后来拿公司的一个.NET 8项目来尝试使用此CycloneDX，立马就能走通了。但在C#项目下，CycloneDX 默认情况下它会分析项目的 NuGet 包依赖（包括直接和传递依赖），但不会自动包含项目引用（Project References）所生成的 DLL 文件，因为这些 DLL 被视为“内部组件”而非外部第三方依赖。作为解决办法，从 CycloneDX .NET 工具 v2.0+ 开始，官方支持通过命令行参数显式包含项目引用。使用 --include-project-references 参数，注意，此时就需要使用工程目录，而不能使用解决方案目录,即.csproj文件，而非.sln文件。在只有.dll文件，即随便拷贝一个外部无用的.DLL文件放在编译后的输出目录中，CycloneDX .NET不会自动识别其组成，即SBOM中没有此项。若需要的话可以将其作为一个NuGet私有源进行引入。</p>\n<p>使用CycloneDX生成SBOM的参考命令：<br />\n命令示例：<code>dotnet cyclonedx  ..\\CSharp_Sbom.sln --output-format json --exclude-dev --exclude-test-projects -sn YourCompany -sv 1.0.0  -o ..\\SbomScript\\CycloneDX_sbom -fn sbom.json </code><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/297997/202602/297997-20260204161039726-830266260.png\" /></p>\n<p>在C#项目中使用CycloneDX工具时，也是顺利的生成了需要的SBOM，但是当在C++项目上生成时，这里先说下，使用的C++项目时临时创建的，无标准的包管理器，也没有用CMake，Conan或vcpkg管理依赖。最终生成出来的sbom文件中确没有任何组件或者说没有任何依赖，也就是json文件中的dependencies元素里面没有包含任何东西。也就是无法直接使用这个工具来生成C++项目的SBOM,这就尴尬了。后来查资料大概意思是说：因为C++缺乏统一的依赖管理机制（如 Java 的 Maven 或 Node.js 的 npm , C#的NuGet），不能直接解析依赖信息。</p>\n<p><strong>Syft</strong><br />\n然后就开始了我的第三个工具Syft的研究，Syft会自动扫描，检测构建产物中的二进制文件和动态链接库来识别第三方组件，自动识别提取生成依赖包，并输出SBOM。支持格式：CycloneDX、SPDX、Syft JSON 等，是由 Anchore 开发的开源 CLI 工具，是Go语言编写。<br />\nSyft生成SBOM参考命令： <code>syft . -o cyclonedx-json=../../sbom/syft/syft.cdx.json -vv</code><br />\n<img alt=\"5E7673D9-61DC-4829-8EC9-FA8C3A1B5E65\" src=\"https://img2024.cnblogs.com/blog/297997/202602/297997-20260204163404903-680685072.png\" /><br />\n<img alt=\"526ABF57-406F-4c90-B9F8-CA122919BA9A\" src=\"https://img2024.cnblogs.com/blog/297997/202602/297997-20260204163504326-995103179.png\" /><br />\n-v 输出警告信息<br />\n-vv 输出调试信息<br />\n使用Syft确实能做到自动识别C++的项目生成SBOM，但也仅仅是有限的支持，即仅能识别已知特征的库，无法还原完整依赖树（尤其静态链接、动态加载的以及自定义编译的库），只因C++项目无包管理器或者说有些C++项目没有使用统一的一套包管理流程，纯 CMake/Makefile + 静态链接情况下，只有Syft可行。能从二进制中识别 OpenSSL、zlib、libpng、glibc 等常见库（即使静态链接），经过一番折腾，这里又看到了另外一个工具OSS Review Toolkit (ORT) ，但经过了解下来说这是一个全流程的合规审计工具，因为目前只需要一个SBOM快速生成工具，貌似学习使用曲线更高，一下子就吓到了我这种懒人，也就懒得研究了。<br />\n最后附上一个简单的总结对比说明：<br />\n<img alt=\"5A97EFF3-207F-4f25-8E47-D2A8870A1A20\" src=\"https://img2024.cnblogs.com/blog/297997/202602/297997-20260204165300095-356125226.png\" /></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 16:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/huangqian\">奔四的大龄码农</a>&nbsp;\n阅读(<span id=\"post_view_count\">45</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "鸿蒙应用开发UI基础第二节：鸿蒙应用程序框架核心解析与实操",
      "link": "https://www.cnblogs.com/san-xiu/p/19575201",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/san-xiu/p/19575201\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 16:36\">\n    <span>鸿蒙应用开发UI基础第二节：鸿蒙应用程序框架核心解析与实操</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"学习目标\">学习目标</h2>\n<ol>\n<li>建立鸿蒙应用“宏观-微观”完整认知：明确应用、应用程序包、HAP/HSP、组件、页面的层级关系，理解 Stage 模型编译期与运行期概念的对应逻辑；</li>\n<li>清晰区分 Stage 模型与 FA 模型的核心差异，理解 Stage 模型在资源利用、配置管理、跨端适配等实际开发场景中的核心优势；</li>\n<li>掌握 Stage 模型进程/线程管理机制，理解 UIAbility 与 ExtensionAbility 的线程隔离特性，以及多线程开发的核心思路；</li>\n<li>熟练掌握 UIAbility 在 module.json5 中的核心配置项及规则，精准定位 Stage 工程核心文件并理清依赖链路；</li>\n<li>能独立完成应用名称/图标修改、UIAbility 配置调整、页面加载路径切换等实操，结合工程编译机制验证效果并排查基础配置与编译错误。</li>\n</ol>\n<p>上一节我们掌握了应用配置签名真机调试，本节开始从“应用整体架构”切入，聚焦 Stage 模型核心交互组件 UIAbility 核心能力展开，结合工程编译机制，帮助构建鸿蒙应用开发基础认知体系，为后续应用生命周期、Context 上下文、进程通信等进阶内容学习打下基础。</p>\n<h2 id=\"一回顾鸿蒙系统架构\">一、回顾鸿蒙系统架构</h2>\n<p>鸿蒙系统采用分层架构，共四层，开发者核心工作集中在顶层两层：</p>\n<ol>\n<li><strong>应用层</strong>：面向用户的应用载体，包含两种形态\n<ul>\n<li>原生应用：基于 ArkTS 开发，性能最优，能深度调用分布式能力，是鸿蒙生态核心；</li>\n<li>元服务：免安装、轻量便捷，适合高频次、低留存场景（如扫码支付）；</li>\n</ul>\n</li>\n<li><strong>框架层</strong>：开发聚焦在框架层，提供 ArkUI 组件、状态管理、路由/导航跳转等核心能力，后续组件开发、布局设计均依赖此层；</li>\n<li><strong>系统服务层</strong>：封装分布式能力、设备管理等基础服务，开发者通过 API 调用即可，无需关注底层实现；</li>\n<li><strong>内核层</strong>：负责进程调度、内存管理等底层操作，开发者无需深入接触。</li>\n</ol>\n<p><strong>图 1：鸿蒙系统架构图</strong> - 展示四层架构层级关系，标注开发者核心关注的应用层与框架层。</p>\n<p><img alt=\"鸿蒙系统架构教学版本\" class=\"lazyload\" /></p>\n<blockquote>\n<p>HarmonyOS 5.0 开始彻底完成 Linux 内核和安卓开放源代码项目（AOSP）的全面替换，采用纯鸿蒙内核（HarmonyOS Kernel），实现全栈自研。本阶段所有内容均基于鸿蒙 5.0~6.0 版本进行应用开发讲解。</p>\n</blockquote>\n<h2 id=\"二程序框架服务ability-kit\">二、程序框架服务（Ability Kit）</h2>\n<h3 id=\"一核心定义\">（一）核心定义</h3>\n<p>Ability Kit（程序框架服务）是鸿蒙系统为应用提供的核心运行时基础框架，抽象提炼应用开发所需核心能力，提供标准化组件体系和运行机制。<strong>核心价值是让开发者基于统一模型开发应用，同时保障应用在多设备、多场景下的兼容性与性能</strong>。</p>\n<h3 id=\"二核心能力与使用场景\">（二）核心能力与使用场景</h3>\n<table>\n<thead>\n<tr>\n<th>能力范围</th>\n<th>具体内容</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生命周期与进程管理</td>\n<td>应用/组件进程创建销毁、生命周期调度</td>\n<td>多 Module 应用开发，HAP/HSP 分工实现功能</td>\n</tr>\n<tr>\n<td>组件交互能力</td>\n<td>组件间/应用间跳转、跨设备流转</td>\n<td>办公应用内启动视频会议组件、购物应用跳转支付应用、视频跨设备流转</td>\n</tr>\n<tr>\n<td>基础支撑能力</td>\n<td>上下文环境、系统事件监听、启动框架、意图框架等</td>\n<td>应用快捷方式配置、程序访问控制、密码自动填充</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"三核心特征\">（三）核心特征</h3>\n<ol>\n<li><strong>标准化开发范式</strong>：抽象应用开发通用能力，提供统一的组件体系、生命周期规则，降低跨设备/跨版本适配成本；</li>\n<li><strong>高效资源调度</strong>：统一管理应用进程/线程，优化组件启动、内存占用等性能指标；</li>\n<li><strong>系统能力封装</strong>：内置意图框架、启动框架、流转能力等，无需开发者手动对接底层系统 API；</li>\n<li><strong>多场景支撑</strong>：通过 ExtensionAbility 覆盖备份、输入法、卡片等无 UI/轻 UI 场景，平衡功能扩展与系统管控。</li>\n</ol>\n<h3 id=\"四核心关联\">（四）核心关联</h3>\n<ul>\n<li><strong>ArkUI</strong>：UIAbility 组件中可使用 ArkUI 的组件、事件、动效、状态管理等能力实现界面开发；</li>\n<li><strong>ArkTS</strong>：提供语言运行时能力，支撑 Ability Kit 的代码执行；</li>\n<li><strong>Hvigor</strong>：鸿蒙官方构建工具，为 Ability Kit 相关组件与配置提供编译构建能力，实现代码与配置的工程化落地。</li>\n</ul>\n<h2 id=\"三鸿蒙应用模型\">三、鸿蒙应用模型</h2>\n<h3 id=\"一核心定义与构成要素\">（一）核心定义与构成要素</h3>\n<p>应用模型是 Ability Kit 对应用开发能力的抽象封装，定义应用的组件体系、运行机制、配置规范等核心规则，核心构成要素如下：</p>\n<table>\n<thead>\n<tr>\n<th>构成要素</th>\n<th>核心作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用组件</td>\n<td>应用运行入口，通过生命周期回调感知状态变化</td>\n</tr>\n<tr>\n<td>进程/线程模型</td>\n<td>定义进程/线程的创建、销毁及通信方式</td>\n</tr>\n<tr>\n<td>任务管理模型</td>\n<td>定义任务创建、销毁及与组件的关联（仅系统应用）</td>\n</tr>\n<tr>\n<td>应用配置文件</td>\n<td>存储应用/组件配置、权限等信息，供编译/运行阶段使用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"二演进历程fa-模型--stage-模型\">（二）演进历程：FA 模型 → Stage 模型</h3>\n<table>\n<thead>\n<tr>\n<th>模型类型</th>\n<th>适配版本</th>\n<th>核心状态</th>\n<th>官方开发优势</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FA 模型</td>\n<td>API 7~8</td>\n<td>已停止更新</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Stage 模型</td>\n<td>API 9+</td>\n<td>主推且长期演进</td>\n<td>1. 组件职责清晰，开发效率更高；2. 资源占用更低，启动速度更快；3. 跨端适配更便捷；4. 系统能力集成更简单；5. 编译分层设计，支持模块按需编译，提升开发效率</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"三fa-模型与-stage-模型核心差异\">（三）FA 模型与 Stage 模型核心差异</h3>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>FA 模型</th>\n<th>Stage 模型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组件体系</td>\n<td>Page/Service/DataAbility（匿名对象）</td>\n<td>UIAbility+ExtensionAbility（类继承）</td>\n</tr>\n<tr>\n<td>引擎机制</td>\n<td>每个组件独享 ArkTS 引擎实例</td>\n<td>所有组件共享一个 ArkTS 引擎实例</td>\n</tr>\n<tr>\n<td>进程模型</td>\n<td>主进程+渲染进程</td>\n<td>主进程+可配置独立进程（ExtensionAbility支持进程自定义）</td>\n</tr>\n<tr>\n<td>线程模型</td>\n<td>引擎实例在非主线程创建，不支持进程内对象共享</td>\n<td>引擎实例在主线程创建，支持进程内对象共享</td>\n</tr>\n<tr>\n<td>配置文件</td>\n<td>单一 config.json（混编全局/模块配置）</td>\n<td>app.json5（应用级）+ module.json5（模块级）</td>\n</tr>\n<tr>\n<td>编译机制</td>\n<td>整体工程编译，修改局部需重新编译全部</td>\n<td>分层编译，支持模块/全局编译，按需编译修改部分，效率更高</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"四stage-模型核心架构与组成\">（四）Stage 模型核心架构与组成</h3>\n<h4 id=\"1-stage-模型核心架构图\">1. Stage 模型核心架构图</h4>\n<p><strong>图 2：Stage 模型编译期-运行期架构图</strong> - 左侧为运行期概念（应用实例化流程），右侧为编译期概念（开发打包流程），展示“模块→组件→页面”的打包与实例化对应关系。</p>\n<p><img alt=\"Stage模型开发概述\" class=\"lazyload\" /></p>\n<h4 id=\"2-核心组成单元\">2. 核心组成单元</h4>\n<ol>\n<li><strong>AbilityStage</strong>：可选实现（若不实现，系统默认创建）；Entry/Feature 类型 HAP 的运行时载体，<strong>一个 HAP 对应一个 AbilityStage 实例</strong>，负责 HAP 的初始化、组件创建分发、模块级生命周期管理；</li>\n<li><strong>UIAbility</strong>：带 UI 的核心交互组件，通过 WindowStage 管理窗口，实现用户交互；</li>\n<li><strong>ExtensionAbility</strong>：面向特定场景的扩展组件（如 EntryBackupAbility、InputMethodExtensionAbility），是 UIAbility 的扩展，用于无界面的后台能力（如备份、输入法）；</li>\n<li><strong>WindowStage</strong>：与 UIAbility 实例绑定的窗口管理器，负责窗口创建、销毁，为 ArkUI 提供绘制区域；</li>\n<li><strong>Context</strong>：派生类（ApplicationContext/AbilityStageContext/UIAbilityContext）为不同层级提供运行期资源调用、权限管理等能力；</li>\n<li><strong>三级生命周期</strong>：Application（应用级）→ AbilityStage（模块级）→ UIAbility/ExtensionAbility（组件级），由 Ability Kit 统一调度，实现资源精细化管理。</li>\n</ol>\n<h4 id=\"3-核心层级关系说明\">3. 核心层级关系说明</h4>\n<ol>\n<li>层级关联：Application（应用全局）→ AbilityStage（HAP 模块）→ UIAbility/ExtensionAbility（组件），依次依赖创建；</li>\n<li>持有关系：UIAbility→WindowStage→Window→ArkUI Page，且各层级均持有对应 Context；</li>\n<li>对应关系：Application ↔ Bundle，AbilityStage ↔ HAP（1:1 绑定）。</li>\n</ol>\n<pre><code># 编译期（开发/打包）\n应用程序包（Bundle） → 模块（HAP/HSP） → 组件（UIAbility/ExtensionAbility） → 页面（Page）\n\n# 运行期（安装/启动）\nApplication（应用全局实例） → AbilityStage（HAP 模块实例） → 组件实例 → 页面渲染\n</code></pre>\n<h3 id=\"五stage-模型开发与运行全流程\">（五）Stage 模型开发与运行全流程</h3>\n<h4 id=\"1-开发阶段\">1. 开发阶段</h4>\n<p>开发者基于 Stage 模型完成应用功能开发与配置，核心工作包括：</p>\n<ul>\n<li><strong>应用组件开发</strong>：通过 UIAbility 组件开发带界面的用户交互模块（如应用主界面），通过 ExtensionAbility 等组件开发各类扩展功能模块；</li>\n<li><strong>模块解耦设计</strong>：为减少不同功能模块间的依赖和耦合，可将 UIAbility 和各类 ExtensionAbility 的实现分别放在不同的 HAP 包中，同时将两者共同依赖的通用功能放在 HSP 包中；</li>\n<li><strong>配置文件编写</strong>：在 app.json5 中配置应用名称、版本号、应用图标等全局信息，在 module.json5 中配置对应 HAP 包下的组件清单、组件权限、进程归属等模块级信息；配置信息会在应用编译、安装时被系统解析，便于系统和其他模块识别、交互。</li>\n</ul>\n<h4 id=\"2-运行阶段\">2. 运行阶段</h4>\n<p>当应用安装到设备运行时，系统通过一套应用进程和线程的管理机制，确保功能的有序运行：</p>\n<ul>\n<li>进程是应用运行的基础单元，负责资源分配和隔离；</li>\n<li>线程是进程内的执行单元，负责具体代码逻辑的执行；</li>\n<li>Ability Kit 统一管控进程/线程的创建、销毁和调度，保障应用稳定运行。</li>\n</ul>\n<h4 id=\"3-进程模型\">3. 进程模型</h4>\n<ul>\n<li>基础规则：UIAbility 组件默认运行在应用主进程中； ExtensionAbility 组件<strong>进程行为可配置</strong>，可通过<code>module.json5</code>中的<code>process</code>字段进行配置；</li>\n<li>配置方式：在 ExtensionAbility 组件的配置节点中添加<code>process</code>字段，值以<code>:</code>开头表示配置为独立进程运行，未配置则默认与 UIAbility 同进程运行；</li>\n<li>通信规则：ExtensionAbility 与 UIAbility 同进程时为线程隔离状态，数据和资源不直接互通；独立进程时需通过跨进程通信机制实现数据交互；</li>\n<li>核心价值：进程可配置性兼顾了应用性能和稳定性——轻量扩展组件与主进程共享资源，减少进程开销；核心/高隔离性扩展组件独立进程运行，避免单一组件异常影响整个应用。</li>\n</ul>\n<h4 id=\"4-组件通信机制\">4. 组件通信机制</h4>\n<p>鸿蒙提供多套通信机制，适配不同组件类型、不同进程归属的通信场景，核心分类如下：</p>\n<ul>\n<li><strong>进程内通信</strong>：适用于同一进程内的 UIAbility 与 ExtensionAbility、UIAbility 与页面间，优先使用<strong>EventHub</strong>，轻量高效、无需复杂配置；</li>\n<li><strong>跨进程通信</strong>：适用于跨应用、独立进程的 HAP 之间、独立进程 ExtensionAbility 与 UIAbility 之间，使用<strong>IPC</strong>基础通信机制；</li>\n<li><strong>ExtensionAbility 专属通信</strong>：不同类型的 ExtensionAbility 提供专属通信接口，适配自身业务场景，核心接口如下：\n<ul>\n<li>ServiceExtensionAbility：通过<code>connectServiceExtensionAbility()</code>建立连接，实现主从组件的双向通信；</li>\n<li>DataShareExtensionAbility：通过<code>createDataShareHelper()</code>创建助手实例，实现数据的增删改查共享。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>纯 ArkTS 单进程应用，优先使用 EventHub 实现组件/线程间通信；涉及独立进程或跨应用交互时，根据组件类型选择对应专属通信接口或基础 IPC 机制。</p>\n</blockquote>\n<h4 id=\"5-线程模型\">5. 线程模型</h4>\n<ul>\n<li>基础支撑：Stage 模型提供 worker、taskpool 等机制支撑应用多线程开发场景；</li>\n<li>开发建议：应用若有复杂的耗时逻辑（如大数据处理、网络请求、复杂计算），建议通过创建 worker 线程的方式处理，避免阻塞主线程（UI 线程），保障应用界面流畅性；</li>\n<li>线程隔离：无论 ExtensionAbility 与 UIAbility 同进程还是独立进程，其内部均为线程隔离设计，耗时逻辑均需放在子线程执行，不可直接在组件主线程处理。</li>\n</ul>\n<h3 id=\"六stage-模型开发流程\">（六）Stage 模型开发流程</h3>\n<table>\n<thead>\n<tr>\n<th>核心任务</th>\n<th>关键内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用组件开发</td>\n<td>开发 UIAbility/ExtensionAbility，按功能拆分到不同 HAP，通用能力抽离到 HSP</td>\n</tr>\n<tr>\n<td>进程/线程模型适配</td>\n<td>基于业务需求配置 ExtensionAbility 进程归属，耗时逻辑通过 worker 处理，遵循线程隔离规则</td>\n</tr>\n<tr>\n<td>配置文件编写</td>\n<td>配置 app.json5（全局）/module.json5（模块）的应用/组件/进程信息，保证路径与语法合规</td>\n</tr>\n<tr>\n<td>通信机制实现</td>\n<td>按进程归属和组件类型选择 EventHub、专属接口或 IPC 实现通信</td>\n</tr>\n<tr>\n<td>效果验证</td>\n<td>基于模块编译验证局部修改效果，全局编译生成完整应用包</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"四鸿蒙应用组成结构\">四、鸿蒙应用组成结构</h2>\n<h3 id=\"一应用程序包bundle\">（一）应用程序包（Bundle）</h3>\n<ul>\n<li>定义：鸿蒙应用分发、安装的最小单位（后缀<code>.app</code>），由全局编译整合所有 HAP/HSP 模块编译产物生成；</li>\n<li>构成：Entry HAP（必选，应用启动入口）、Feature HAP（可选，扩展功能）、HSP（可选，代码/资源共享）；</li>\n<li>多包机制：1 个 Bundle 可包含多个 HAP（Entry HAP 最多 1 个，Feature HAP 不限），HAP 之间通过 HSP 共享代码/资源，各模块可独立编译，最终整合至 Bundle。</li>\n</ul>\n<h3 id=\"二模块haphsp\">（二）模块（HAP/HSP）</h3>\n<table>\n<thead>\n<tr>\n<th>模块类型</th>\n<th>核心作用</th>\n<th>关键特征</th>\n<th>运行期关联实例</th>\n<th>典型使用场景</th>\n<th>编译特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Entry HAP</td>\n<td>应用主模块，提供启动入口</td>\n<td>必选，包含主 UIAbility，可单独安装运行</td>\n<td>对应 1 个 AbilityStage 实例</td>\n<td>应用主界面、核心交互功能</td>\n<td>可独立编译为 HAP 包，支持单独运行验证</td>\n</tr>\n<tr>\n<td>Feature HAP</td>\n<td>扩展功能模块</td>\n<td>可选，依赖 Entry HAP 运行，支持按需加载</td>\n<td>对应 1 个 AbilityStage 实例</td>\n<td>备份、输入法等扩展功能</td>\n<td>可独立编译，需结合 Entry HAP 运行</td>\n</tr>\n<tr>\n<td>HSP</td>\n<td>代码/资源共享包</td>\n<td>可选，无独立运行组件，仅用于模块间复用</td>\n<td>无对应的 AbilityStage 实例</td>\n<td>通用工具类、常量定义、公共资源</td>\n<td>编译为共享包，被其他 HAP 依赖调用</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>关于包的类型以及使用创建方法，我们会在项目阶段学习掌握。</p>\n</blockquote>\n<h3 id=\"三核心组件stage-模型两类组件\">（三）核心组件（Stage 模型两类组件）</h3>\n<table>\n<thead>\n<tr>\n<th>组件类型</th>\n<th>核心作用</th>\n<th>交互方式</th>\n<th>开发方式</th>\n<th>进程默认配置</th>\n<th>细分类型/示例文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UIAbility</td>\n<td>应用入口+窗口管理，实现用户交互</td>\n<td>桌面启动、可视化交互</td>\n<td>面向对象开发（类继承）</td>\n<td>应用主进程</td>\n<td>EntryAbility.ets（应用主界面）</td>\n</tr>\n<tr>\n<td>ExtensionAbility</td>\n<td>备份/输入法等无 UI/轻 UI 场景</td>\n<td>系统/事件触发</td>\n<td>面向对象开发（派生类实现）</td>\n<td>应用主进程</td>\n<td>EntryBackupAbility.ets（备份）、DataShareExtensionAbility.ets（数据共享）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五工程结构\">五、工程结构</h2>\n<p>延用上一节创建的项目<code>FirstApplication</code>（基于鸿蒙 5.0 API 12 + DevEco Studio 6.0+），工程核心结构如下，其中<code>build</code>目录为编译后自动生成，<code>build-profile.json5</code>和<code>hvigorfile.ts</code>为鸿蒙 Hvigor 构建工具的核心编译配置文件，实现工程与模块的分层编译管理：</p>\n<pre><code>FirstApplication                    \n├── AppScope/                # 应用全局配置目录\n│   ├── resources/           # 应用全局资源目录\n│   │   ├── base/            # 全局基础资源目录\n│   │   │   ├── element/     # 全局字符串、颜色等配置\n│   │   │   │   └── string.json\n│   │   │   ├── media/       # 全局媒体资源（层叠图标配置、兜底图标）\n│   │   │   │   ├── app_icon.png // 自定义的应用图标\n│   │   │   │   ├── background.png\n│   │   │   │   ├── foreground.png\n│   │   │   │   └── layered_image.json\n│   │   │   └── profile/     # 全局配置文件（如页面路由、备份配置等）\n│   └── app.json5            # 全局配置文件（包名、版本、图标、名称等，供全局编译解析）\n├── entry/                   # Entry HAP主模块（核心开发目录）\n│   ├── build/               # 模块编译产物目录（编译后自动生成，存放entry模块HAP包）\n│   ├── src/\n│   │   ├── main/            # entry模块核心源码目录\n│   │   │   ├── ets/         # ArkTS代码目录\n│   │   │   │   ├── entryability/ # UIAbility核心组件目录\n│   │   │   │   │   └── EntryAbility.ets\n│   │   │   │   ├── entrybackupability/ # 备份扩展组件目录\n│   │   │   │   │   └── EntryBackupAbility.ets\n│   │   │   │   └── pages/   # 页面目录\n│   │   │   │       ├── Index.ets\n│   │   │   │       └── Home.ets\n│   │   │   ├── resources/   # 模块级静态资源目录（编译时自动打包优化）\n│   │   │   │   ├── base/    # 基础资源目录（默认主题）\n│   │   │   │   │   ├── element/ # 模块级元素配置\n│   │   │   │   │   ├── media/   # 模块级媒体资源\n│   │   │   │   │   │   ├── background.png\n│   │   │   │   │   │   ├── foreground.png\n│   │   │   │   │   │   ├── startIcon.png // 默认的窗口图标\n│   │   │   │   │   │   └── layered_image.json\n│   │   │   │   ├── dark/    # 深色模式资源目录\n│   │   │   │   └── rawfile/ # 原生文件目录（无需编译的静态文件）\n│   │   │   └── module.json5 # Entry HAP模块配置文件（组件、权限、进程等，供模块编译解析）\n│   ├── mock/                # 模拟数据目录（测试用）\n│   ├── ohosTest/            # OpenHarmony测试目录\n│   ├── test/                # 本地测试目录\n│   ├── .gitignore           # Git忽略文件配置\n│   ├── build-profile.json5  # 模块编译配置文件（指定SDK版本、签名关联等编译规则）\n│   └── hvigorfile.ts        # 模块编译脚本（Hvigor构建工具模块级执行入口）\n├── build/                   # 工程全局编译产物目录（编译后自动生成，存放全局整合的HAP/APP包）\n├── build-profile.json5      # 工程全局编译配置文件（统一管理所有模块编译规则、编译模式）\n├── hvigorfile.ts            # 工程全局编译脚本（Hvigor构建工具全局执行入口，触发所有模块编译）\n├── oh-package.json5         # ohpm依赖配置文件（编译前自动解析下载依赖）\n└── oh-package-lock.json5    # ohpm依赖版本锁定文件\n</code></pre>\n<blockquote>\n<p>说明：鸿蒙工程基于<strong>Hvigor</strong>（鸿蒙官方自研构建工具）实现编译，采用<strong>按需编译</strong>原则，仅修改过的模块/文件会重新编译，未修改部分复用原有编译产物，提升开发效率；<code>build</code>目录删除后可通过重新编译生成，不影响工程源码。</p>\n</blockquote>\n<h2 id=\"六uiability-核心实操\">六、UIAbility 核心实操</h2>\n<h3 id=\"一核心定位\">（一）核心定位</h3>\n<ol>\n<li><strong>应用入口</strong>：用户点击应用图标后，系统首先创建并启动 UIAbility 实例；</li>\n<li><strong>窗口管理载体</strong>：每个 UIAbility 实例启动后会创建一个 WindowStage（窗口管理器），负责窗口的创建、销毁，并<strong>通过 WindowStage 加载 ArkUI 页面</strong>；</li>\n<li><strong>实例模式</strong>：支持单实例、多实例、指定实例等配置（通过 module.json5 的<code>launchType</code>字段），满足不同业务场景需求；</li>\n<li><strong>编译关联</strong>：UIAbility 的类名、文件路径需与 module.json5 中<code>name</code>、<code>srcEntry</code>配置完全一致，否则会导致模块编译失败，无法生成 HAP 包；</li>\n<li><strong>权限核心</strong>：作为应用核心交互组件，UIAbility 是应用权限申请和校验的核心载体，后台启动其他组件需依赖专属系统权限。</li>\n</ol>\n<h3 id=\"二核心配置\">（二）核心配置</h3>\n<h4 id=\"1-模块级配置modulejson5\">1. 模块级配置（module.json5）</h4>\n<pre><code class=\"language-json\">{\n  \"module\": {\n    \"name\": \"entry\", // 模块名称\n    \"type\": \"entry\", // 模块类型：entry/feature/har/hsp\n    \"description\": \"$string:module_desc\", // 模块描述\n    \"mainElement\": \"EntryAbility\", // 默认启动组件\n    \"deviceTypes\": [ // 支持的设备类型\n      \"phone\"\n    ],\n    \"deliveryWithInstall\": true, // 是否随应用安装交付\n    \"installationFree\": false, // 是否免安装\n    \"pages\": \"$profile:main_pages\", // 页面路由配置\n    \"abilities\": [ // UIAbility组件配置\n      {\n        \"name\": \"EntryAbility\", // 组件名称（与代码类名一致，编译校验关键）\n        \"srcEntry\": \"./src/main/ets/entryability/EntryAbility.ets\", // 入口路径（必须./开头，编译校验关键）\n        \"description\": \"$string:EntryAbility_desc\", // 组件描述\n        \"icon\": \"$media:layered_image\", // 组件图标（模块级，不重名的情况下优先生效）\n        \"label\": \"$string:EntryAbility_label\", // 组件显示名称（模块级，优先级更高）\n        \"startWindowIcon\": \"$media:startIcon\", // 启动窗口图标\n        \"startWindowBackground\": \"$color:start_window_background\", // 启动窗口背景\n        \"exported\": true, // 是否允许跨应用调用\n        \"launchType\": \"singleton\", // 默认的启动模式，可以不写\n        \"skills\": [ // 桌面图标必配：缺少则桌面无应用图标\n          {\n            \"entities\": [\n              \"entity.system.home\" // 桌面入口标识\n            ],\n            \"actions\": [\n              \"ohos.want.action.home\" // 桌面启动动作\n            ]\n          }\n        ]\n      }\n    ],\n    \"extensionAbilities\": [ // 扩展组件配置\n      {\n        \"name\": \"EntryBackupAbility\", // 备份扩展组件名称\n        \"srcEntry\": \"./src/main/ets/entrybackupability/EntryBackupAbility.ets\", \n        \"type\": \"backup\", // 扩展类型（backup/dataShare/inputMethod等）\n        \"exported\": false, // 仅内部使用\n        \"metadata\": [ // 扩展元数据\n          {\n            \"name\": \"ohos.extension.backup\", // 元数据名称\n            \"resource\": \"$profile:backup_config\" // 元数据配置文件\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>\n<h4 id=\"2-配置关键规则\">2. 配置关键规则</h4>\n<ul>\n<li><code>mainElement</code>：Entry HAP 必须配置为 UIAbility，Feature HAP 无默认启动组件；</li>\n<li><code>name</code>：组件名称必须与代码中导出的类名一致，不可随意修改，编译时会严格校验；</li>\n<li><code>srcEntry</code>：路径需以<code>./</code>开头，严格匹配文件的目录/文件名（区分大小写），路径错误会直接导致编译失败；</li>\n<li><code>exported</code>：跨应用调用的组件需设为 true，仅内部使用的组件设为 false 即可；</li>\n<li><code>skills</code>：仅 UIAbility 需配置（桌面图标展示），ExtensionAbility 无需配置；缺失或配置不全则桌面无图标，点击图标进入应用详情页；</li>\n<li><code>type</code>：ExtensionAbility 必选字段，需与扩展类型匹配（如 backup、dataShare、inputMethod 等）；</li>\n<li><code>process</code>：ExtensionAbility 可选配置字段，用于设置进程归属，值以<code>:</code>开头表示独立进程，未配置则默认与主进程同进程；</li>\n<li>JSON 语法：禁止末尾多余逗号，配置项、文件/目录名称均区分大小写，语法错误会导致编译解析失败。</li>\n</ul>\n<h4 id=\"3-全局配置appjson5\">3. 全局配置（app.json5）</h4>\n<pre><code class=\"language-json\">{\n  \"app\": {\n    \"bundleName\": \"com.sanxiu.firstapp\",\n    \"vendor\": \"example\",\n    \"versionCode\": 1000000,\n    \"versionName\": \"1.0.0\",\n    \"icon\": \"$media:layered_image\", // 全局应用图标\n    \"label\": \"$string:app_name\" // 全局应用名称\n  }\n}\n</code></pre>\n<h4 id=\"4-层叠图标配置layered_imagejson\">4. 层叠图标配置（layered_image.json）</h4>\n<p><strong>路径</strong>：</p>\n<ul>\n<li>全局：AppScope/resources/base/media/layered_image.json</li>\n<li>模块级：entry/src/main/resources/base/media/layered_image.json</li>\n</ul>\n<pre><code class=\"language-json\">{\n  \"layered-image\": {\n    \"background\": \"$media:background\",\n    \"foreground\": \"$media:foreground\"\n  }\n}\n</code></pre>\n<p><strong>核心规则</strong>：</p>\n<ul>\n<li>资源覆盖：编译期 AppScope 和模块内重名资源，AppScope 资源优先级更高；</li>\n<li>模块级 icon 生效前提：UIAbility 的 <code>skills</code> 字段必须包含<code>entity.system.home</code>和<code>ohos.want.action.home</code>；多 Ability 时取<code>mainElement</code>对应配置；</li>\n<li>图标尺寸规范：鸿蒙层叠图标推荐基础尺寸：foreground/background 均为<strong>1024×1024</strong>（png 格式，透明背景），编译时系统会自动适配不同设备的图标尺寸，无需手动制作多尺寸版本。</li>\n</ul>\n<h4 id=\"5-页面路由配置main_pagesjson\">5. 页面路由配置（main_pages.json）</h4>\n<p>通过 <code>New -&gt; Page -&gt; Empty Page</code> 创建的页面会自动导入<code>main_pages.json</code>，其他方法创建的页面需要手动管理路由配置。</p>\n<pre><code class=\"language-json\">{\n  \"src\": [\n    \"pages/Index\",\n    \"pages/Home\" // 新增Home页面路径\n  ]\n}\n</code></pre>\n<h3 id=\"三页面加载核心逻辑entryabilityets\">（三）页面加载核心逻辑（EntryAbility.ets）</h3>\n<pre><code class=\"language-typescript\">import UIAbility from '@ohos.app.ability.UIAbility';\nimport window from '@ohos.window';\nimport hilog from '@ohos.hilog';\nimport { AbilityConstant, Want } from '@kit.AbilityKit';\nimport { BusinessError } from '@ohos.base'; \n\nconst DOMAIN: number = 0x0000;\nconst TAG: string = 'EntryAbility';\n\nexport default class EntryAbility extends UIAbility {\n  // 组件创建时触发，可初始化资源\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN, TAG, 'EntryAbility onCreate called');\n  }\n\n  // 组件销毁时触发，可释放资源\n  onDestroy() {\n    hilog.info(DOMAIN, TAG, 'EntryAbility onDestroy called');\n  }\n\n  // 窗口创建后触发，仅此处可加载页面\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    hilog.info(DOMAIN, TAG, '--- onWindowStageCreate 触发（加载页面）---');\n    // 加载页面\n    windowStage.loadContent('pages/Index', (err) =&gt; {\n      if (err.code) {\n        hilog.error(DOMAIN, TAG, `页面加载失败：code=${err.code}, message=${err.message}`);\n        return;\n      }\n      hilog.info(DOMAIN, TAG, 'Index页面加载成功');\n    });\n  }\n\n  onWindowStageDestroy(): void {\n    // Main window is destroyed, release UI related resources\n    hilog.info(DOMAIN, TAG, '%{public}s', '主窗口即将销毁，释放UI相关资源');\n  }\n\n  onForeground(): void {\n    // Ability has brought to foreground\n    hilog.info(DOMAIN, TAG, '%{public}s', '应用切换至前台，恢复业务逻辑');\n  }\n\n  onBackground(): void {\n    // Ability has back to background\n    hilog.info(DOMAIN, TAG, '%{public}s', '应用切换至后台，暂停业务逻辑，不可启动其他组件');\n  }\n}\n</code></pre>\n<h4 id=\"页面加载规则\">页面加载规则</h4>\n<ol>\n<li>仅能通过<code>WindowStage.loadContent()</code>加载页面；</li>\n<li>该方法仅可在<code>onWindowStageCreate</code>生命周期中调用；</li>\n<li>路径需严格遵循“无.ets后缀、区分大小写、基于pages根目录的相对路径”，且需与<code>main_pages.json</code>中注册的路径完全一致，否则编译通过但运行时页面加载失败；</li>\n<li>页面文件命名、路径错误会导致编译时资源打包失败，或运行时页面空白。</li>\n</ol>\n<h3 id=\"四自定义首页开发\">（四）自定义首页开发</h3>\n<h4 id=\"步骤-1创建-home-页面pageshomeets\">步骤 1：创建 Home 页面（pages/Home.ets）</h4>\n<pre><code class=\"language-typescript\">@Entry\n@Component\nstruct Home {\n  build() {\n    Column({ space: 20 }) {\n      Text('我的Stage应用首页')\n        .fontSize(30)\n        .fontWeight(FontWeight.Bold);\n    }\n    .width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center);\n  }\n}\n</code></pre>\n<h4 id=\"步骤-2注册-home-页面到路由配置main_pagesjson\">步骤 2：注册 Home 页面到路由配置（main_pages.json）</h4>\n<p>打开路径：<code>entry/src/main/resources/base/profile/main_pages.json</code>，在<code>src</code>数组中新增 Home 页面路径，确保与实际文件路径一致：</p>\n<pre><code class=\"language-json\">{\n  \"src\": [\n    \"pages/Index\",\n    \"pages/Home\" // 必须注册，否则运行时页面加载失败\n  ]\n}\n</code></pre>\n<h4 id=\"步骤-3修改页面加载路径entryabilityets\">步骤 3：修改页面加载路径（EntryAbility.ets）</h4>\n<p>将<code>windowStage.loadContent('pages/Index', ...)</code>修改为：</p>\n<pre><code class=\"language-typescript\">// 加载页面\nwindowStage.loadContent('pages/Home').then(()=&gt;{\n  hilog.info(DOMAIN, TAG, 'Home页面加载成功');\n}).catch((err: BusinessError)=&gt;{\n  hilog.error(DOMAIN, TAG, `页面加载失败：code=${err.code}, message=${err.message}`);\n})\n</code></pre>\n<h4 id=\"效果验证\">效果验证</h4>\n<p><img alt=\"修改加载页面.png\" class=\"lazyload\" /></p>\n<ol>\n<li><strong>应用内验证</strong>：正常展示<code>我的Stage应用首页</code>，无空白、无报错；</li>\n<li><strong>日志端验证</strong>：Logcat 中筛选<code>TAG:EntryAbility</code>，可看到“Home页面加载成功”相关日志。</li>\n</ol>\n<h3 id=\"五配置应用名称和图标\">（五）配置应用名称和图标</h3>\n<h4 id=\"1-层叠图标方案-模块级配置\">1. 层叠图标方案-模块级配置</h4>\n<p>默认工程中，全局应用图标、模块级图标、layered-image 及前后背景图的命名均一致。<br />\n若需让模块级应用图标生效，需删除<strong>AppScope/resources/base/media/</strong> 目录下的 layered-image 相关文件（含<code>layered_image.json</code>、<code>background.png</code>、<code>foreground.png</code>），避免全局重名资源覆盖（不推荐）。</p>\n<p><strong>推荐方案</strong>：确保资源不重名，使用自定义图标名称，同时保证<code>module.json5</code> 中配置了<code>skills</code>字段（桌面图标正常显示前提）：</p>\n<ul>\n<li>确认 entry 模块<code>layered_image.json</code>配置（路径：entry/src/main/resources/base/media/layered_image.json）；</li>\n<li>确保 module.json5 中 UIAbility 配置<code>\"icon\": \"$media:layered_image\"</code>。</li>\n</ul>\n<h4 id=\"2-层叠图标方案-全局级配置\">2. 层叠图标方案-全局级配置</h4>\n<p>直接将应用图标图片命名为<code>foreground</code>，或自定义 layered_image.json 中<code>foreground</code>的资源引用为<code>\"foreground\": \"$media:app_icon\"</code>：</p>\n<ol>\n<li>配置 AppScope 下<code>layered_image.json</code>（路径：AppScope/resources/base/media/layered_image.json）；</li>\n<li>在<code>AppScope/app.json5</code>中配置全局图标：<code>\"icon\": \"$media:layered_image\"</code>。</li>\n</ol>\n<h4 id=\"3-应用名称配置\">3. 应用名称配置</h4>\n<p>应用名称的配置优先级：<strong>模块级别 &gt; 全局级别</strong>。若需让全局资源配置的应用名称生效，需在 module.json5 中注释/删除 UIAbility 的 label 配置：<code>\"label\": \"$string:EntryAbility_label\"</code>。</p>\n<ul>\n<li>名称修改后需检查<code>string.json</code>中对应字符是否存在，字符缺失会导致编译时资源解析错误；</li>\n<li>配置完成后执行模块编译，验证桌面应用名称是否更新；</li>\n<li>全局名称路径：<code>AppScope/resources/base/element/string.json</code><pre><code class=\"language-json\">{\n  \"string\": [\n    {\n      \"name\": \"app_name\",\n      \"value\": \"第一个应用\"\n    }\n  ]\n}\n</code></pre>\n</li>\n</ul>\n<h4 id=\"运行验证\">运行验证</h4>\n<p>将应用运行至真机/模拟器，桌面端应用名称显示为<code>第一个应用</code>，图标为全局配置的层叠样式。</p>\n<p><img alt=\"修改应用名称和图标\" class=\"lazyload\" /></p>\n<h2 id=\"七清理构建hapapp包\">七、清理、构建HAP/APP包</h2>\n<p>鸿蒙工程基于Hvigor构建工具实现模块级编译和全局级构建，<strong>顶部菜单栏Build</strong>为核心操作入口，覆盖「清理-编译-构建-发布」全流程，以下为精准实操和工具说明：</p>\n<h3 id=\"1-清理操作\">1. 清理操作</h3>\n<ul>\n<li>操作：顶部菜单栏<code>Build &gt; Clean Project</code></li>\n<li>功能：删除全工程所有编译相关文件（缓存、临时产物、已生成的包文件等），仅保留源码、配置和资源文件</li>\n<li>作用：解决编译异常、缓存冲突、配置修改不生效等问题，清理完成控制台显示<code>BUILD SUCCESSFUL</code></li>\n</ul>\n<h3 id=\"2-模块编译\">2. 模块编译</h3>\n<p>适用于修改entry模块后快速验证局部效果，仅生成单模块HAP包：</p>\n<ol>\n<li>操作：选中<code>entry</code>文件，点击顶部菜单栏<code>Build &gt; Make Module 'entry'</code></li>\n<li>结果：控制台显示<code>BUILD SUCCESSFUL</code>即为成功，HAP包存放于<code>entry/build/outputs/hap/</code></li>\n<li>作用：快速验证entry模块代码/配置修改效果</li>\n</ol>\n<p><img alt=\"编译entry模块_20260203211239_98_1340\" class=\"lazyload\" /></p>\n<h3 id=\"3-构建完整应用包用于安装分发上架\">3. 构建完整应用包（用于安装/分发/上架）</h3>\n<p>适用于真机/模拟器部署、应用发布上架，整合全模块生成完整.app包：</p>\n<ol>\n<li>操作：顶部菜单栏<code>Build &gt; Build Hap(s)/APP(s) &gt; Build App(s)</code></li>\n<li>结果：控制台显示<code>BUILD SUCCESSFUL</code>即为成功，.app包存放于<code>build/outputs/app/</code>，主模块entry打包产出.hap包</li>\n<li>作用：生成可部署/发布的完整Bundle应用包</li>\n</ol>\n<p><img alt=\"构建应用程序包_20260203211834_100_1340\" class=\"lazyload\" /></p>\n<h3 id=\"4-build菜单核心工具选项全解\">4. Build菜单核心工具选项全解</h3>\n<table>\n<thead>\n<tr>\n<th>选项名称</th>\n<th>核心作用</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Make Module 'entry'</td>\n<td>编译entry模块，生成单模块HAP包</td>\n<td>验证entry模块局部修改效果</td>\n</tr>\n<tr>\n<td>Build Hap(s)/APP(s)</td>\n<td>Build Hap(s)：编译单/多模块生成HAP包；Build App(s)：整合全模块生成.app包</td>\n<td>局部调试用Hap(s)；部署/发布用App(s)</td>\n</tr>\n<tr>\n<td>Generate Build Profile 'entry'</td>\n<td>生成entry模块专属编译配置文件</td>\n<td>自定义entry模块编译规则</td>\n</tr>\n<tr>\n<td>Clean Project</td>\n<td>删除全工程所有编译文件，彻底清理缓存</td>\n<td>编译异常、缓存冲突、配置修改不生效</td>\n</tr>\n<tr>\n<td>Rebuild Project</td>\n<td>先执行Clean Project，再全工程重新编译</td>\n<td>清理后仍编译失败、工程长期未编译</td>\n</tr>\n<tr>\n<td>Generate Key and CSR</td>\n<td>生成.p12密钥+CSR文件，用于申请官方发布签名</td>\n<td>应用正式发布上架</td>\n</tr>\n<tr>\n<td>Upload Product</td>\n<td>将正式版.app包上传至华为应用市场后台</td>\n<td>应用提交上架提审</td>\n</tr>\n<tr>\n<td>Build Analyzer</td>\n<td>分析构建耗时、资源占用，定位构建失败原因</td>\n<td>构建速度慢、排查构建失败问题</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"八代码仓库\">八、代码仓库</h2>\n<ul>\n<li>工程名称：FirstApplication</li>\n<li>仓库地址：<a href=\"https://gitee.com/HarmonyOS-UI-Basics/harmony-os-ui-basics.git\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/HarmonyOS-UI-Basics/harmony-os-ui-basics.git</a></li>\n</ul>\n<h2 id=\"九下节预告\">九、下节预告</h2>\n<p>下一节将深入学习 UIAbility 生命周期全解析，核心内容包括：</p>\n<ol>\n<li>UIAbility 全生命周期核心方法的触发时机、核心作用及执行次数约束；</li>\n<li>WindowStage 事件体系与生命周期的联动逻辑，掌握窗口状态（获焦/失焦、前台/后台）的合法监听方式；</li>\n<li><code>onDestroy</code> 方法的特殊触发规则（API 13+一键清理、调试模式、手动调用API等不同场景）；</li>\n<li>页面仅能在 <code>onWindowStageCreate</code> 加载的底层原因及生命周期相关开发避坑要点；</li>\n<li>实操验证启动/前后台切换/关闭等场景下的生命周期执行顺序，掌握关键数据的安全保存策略。</li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 16:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/san-xiu\">鸿蒙-散修</a>&nbsp;\n阅读(<span id=\"post_view_count\">61</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": ".NET 中如何快速实现 List 集合去重？",
      "link": "https://www.cnblogs.com/1312mn/p/18552496",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/1312mn/p/18552496\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 16:34\">\n    <span>.NET 中如何快速实现 List 集合去重？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain md-expand\" style=\"font-size: 16px;\">前言</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">在数据处理中，去除集合中的重复元素是一个常见的需求。.NET 6 和 .NET 7 引入了 <span class=\"md-pair-s\"><code>DistinctBy</code><span class=\"md-plain\"> 方法，这是一个非常实用的新特性，可以方便地根据指定的键对集合进行去重。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">本文将详细介绍 <span class=\"md-pair-s\"><code>DistinctBy</code><span class=\"md-plain\"> 方法的使用，并通过具体的案例来展示其在实际开发中的应用。</span></span></span></p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\" style=\"font-size: 16px;\">正文</span></h2>\n<h3><strong>1、<code>DistinctBy</code> 方法</strong></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><code>DistinctBy</code><span class=\"md-plain\"> 方法允许我们在 LINQ 查询中根据某个键对集合中的元素进行去重。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">这个方法返回一个新的集合，其中只包含根据指定键唯一确定的元素。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s md-expand\" style=\"font-size: 16px;\"><strong>方法签名</strong></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> IEnumerable&lt;TSource&gt; DistinctBy&lt;TSource, TKey&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span> IEnumerable&lt;TSource&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> source,\n    Func</span>&lt;TSource, TKey&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> keySelector\n);</span></pre>\n</div>\n<h3 class=\"md-end-block md-heading\"><strong><span class=\"md-plain\" style=\"font-size: 16px;\">2、基本用法</span></strong></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">最简单的用法是在 LINQ 查询中直接调用 <span class=\"md-pair-s\"><code>DistinctBy</code><span class=\"md-plain\"> 方法，然后处理去重后的集合。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><strong>说明</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">假设我们有一个用户列表，我们想要根据用户名去除重复的用户。</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">using</span><span style=\"color: rgba(0, 0, 0, 1);\"> System.Linq;\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> User\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> Name { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> Age { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n}\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> users = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;User&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> User { Name = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Age = <span style=\"color: rgba(128, 0, 128, 1);\">25</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> User { Name = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Bob</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Age = <span style=\"color: rgba(128, 0, 128, 1);\">32</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> User { Name = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Age = <span style=\"color: rgba(128, 0, 128, 1);\">28</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> User { Name = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">David</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Age = <span style=\"color: rgba(128, 0, 128, 1);\">35</span><span style=\"color: rgba(0, 0, 0, 1);\"> }\n};\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> distinctUsers = users.DistinctBy(user =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> user.Name);\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> user <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> distinctUsers)\n{\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Name: {user.Name}, Age: {user.Age}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n}</span></pre>\n</div>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">输出结果：</span></p>\n<div class=\"cnblogs_code\">\n<pre>Name: Alice, Age: <span style=\"color: rgba(128, 0, 128, 1);\">25</span><span style=\"color: rgba(0, 0, 0, 1);\">\nName: Bob, Age: </span><span style=\"color: rgba(128, 0, 128, 1);\">32</span><span style=\"color: rgba(0, 0, 0, 1);\">\nName: David, Age: </span><span style=\"color: rgba(128, 0, 128, 1);\">35</span></pre>\n</div>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">过滤前后元素还是保持原有的顺序，我们可以查看源码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><strong>源码</strong></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> IEnumerable&lt;TSource&gt; DistinctByIterator&lt;TSource, TKey&gt;(IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, IEqualityComparer&lt;TKey&gt;?<span style=\"color: rgba(0, 0, 0, 1);\"> comparer)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">using</span> IEnumerator&lt;TSource&gt; enumerator =<span style=\"color: rgba(0, 0, 0, 1);\"> source.GetEnumerator();\n​\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (enumerator.MoveNext())\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> <span style=\"color: rgba(0, 0, 255, 1);\">set</span> = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> HashSet&lt;TKey&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(DefaultInternalSetCapacity, comparer);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">do</span><span style=\"color: rgba(0, 0, 0, 1);\">\n        {\n            TSource element </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> enumerator.Current;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (<span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">.Add(keySelector(element)))\n            {\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">yield</span> <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> element;\n            }\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">while</span><span style=\"color: rgba(0, 0, 0, 1);\"> (enumerator.MoveNext());\n    }\n}</span></pre>\n</div>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">通过查看源码，可以看到是利用了 <span class=\"md-pair-s\"><code>HashSet</code><span class=\"md-plain\"> 去重，元素顺序并未被打乱。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">在处理集合时，我们经常需要去除重复的元素，同时保持原有的顺序。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">使用 <span class=\"md-pair-s\"><code>HashSet</code><span class=\"md-plain\"> 可以高效地实现这一目标。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">首先将指定的键尝试添加到 <span class=\"md-pair-s\"><code>HashSet</code><span class=\"md-plain\"> 中，如果添加成功，说明该键没有重复；</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">如果添加失败，说明已经存在相同的键，此元素将被过滤掉。</span></p>\n<h3 class=\"md-end-block md-heading\"><strong><span class=\"md-plain\" style=\"font-size: 16px;\">3、复杂用法</span></strong></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><code>DistinctBy</code><span class=\"md-plain\"> 方法可以用于更复杂的去重逻辑，例如根据多个属性进行去重。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \" style=\"font-size: 16px;\"><strong>说明</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">假设我们有一个订单列表，我们想要根据客户名称和订单金额去除重复的订单。</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Order\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> OrderId { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> CustomerName { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">decimal</span> Amount { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n}\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> orders = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;Order&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> Order { OrderId = <span style=\"color: rgba(128, 0, 128, 1);\">1</span>, CustomerName = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Amount = <span style=\"color: rgba(128, 0, 128, 1);\">100.0m</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> Order { OrderId = <span style=\"color: rgba(128, 0, 128, 1);\">2</span>, CustomerName = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Bob</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Amount = <span style=\"color: rgba(128, 0, 128, 1);\">150.0m</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> Order { OrderId = <span style=\"color: rgba(128, 0, 128, 1);\">3</span>, CustomerName = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Amount = <span style=\"color: rgba(128, 0, 128, 1);\">100.0m</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> Order { OrderId = <span style=\"color: rgba(128, 0, 128, 1);\">4</span>, CustomerName = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Charlie</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Amount = <span style=\"color: rgba(128, 0, 128, 1);\">120.0m</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> Order { OrderId = <span style=\"color: rgba(128, 0, 128, 1);\">5</span>, CustomerName = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Bob</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Amount = <span style=\"color: rgba(128, 0, 128, 1);\">150.0m</span><span style=\"color: rgba(0, 0, 0, 1);\"> }\n};\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> distinctOrders = orders.DistinctBy(order =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> (order.CustomerName, order.Amount));\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> order <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> distinctOrders)\n{\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Order ID: {order.OrderId}, Customer: {order.CustomerName}, Amount: {order.Amount}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n}</span></pre>\n</div>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">输出结果：</span></p>\n<div class=\"cnblogs_code\">\n<pre>Order ID: <span style=\"color: rgba(128, 0, 128, 1);\">1</span>, Customer: Alice, Amount: <span style=\"color: rgba(128, 0, 128, 1);\">100.0</span><span style=\"color: rgba(0, 0, 0, 1);\">\nOrder ID: </span><span style=\"color: rgba(128, 0, 128, 1);\">2</span>, Customer: Bob, Amount: <span style=\"color: rgba(128, 0, 128, 1);\">150.0</span><span style=\"color: rgba(0, 0, 0, 1);\">\nOrder ID: </span><span style=\"color: rgba(128, 0, 128, 1);\">4</span>, Customer: Charlie, Amount: <span style=\"color: rgba(128, 0, 128, 1);\">120.0</span></pre>\n</div>\n<h3 class=\"md-end-block md-heading\"><strong><span class=\"md-plain\" style=\"font-size: 16px;\">4、性能考虑</span></strong></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><code>DistinctBy</code><span class=\"md-plain\"> 方法在内部使用哈希表来跟踪已经出现的键，因此在大多数情况下性能非常好。但在处理非常大的数据集时，仍然需要注意内存使用情况。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><strong>说明</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">假设我们有一个包含数百万条记录的大集合，我们需要根据某个键进行去重。</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> largeCollection = Enumerable.Range(<span style=\"color: rgba(128, 0, 128, 1);\">1</span>, <span style=\"color: rgba(128, 0, 128, 1);\">10000000</span>).Select(i =&gt; <span style=\"color: rgba(0, 0, 255, 1);\">new</span> { Id = i, Value = i % <span style=\"color: rgba(128, 0, 128, 1);\">1000</span><span style=\"color: rgba(0, 0, 0, 1);\"> });\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> distinctLargeCollection = largeCollection.DistinctBy(item =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> item.Value);\nConsole.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Distinct count: {distinctLargeCollection.Count()}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<h3 class=\"md-end-block md-heading\"><strong><span class=\"md-plain\" style=\"font-size: 16px;\">5、异步 LINQ 查询中的使用</span></strong></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><code>DistinctBy</code><span class=\"md-plain\"> 方法也可以在异步 LINQ 查询中使用，结合 <span class=\"md-pair-s\"><code>IAsyncEnumerable&lt;T&gt;</code><span class=\"md-plain\"> 类型，处理大量数据时更加高效。</span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \" style=\"font-size: 16px;\"><strong>说明</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">假设我们有一个异步方法返回一个用户列表，我们想要根据用户名去除重复的用户。</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">using</span><span style=\"color: rgba(0, 0, 0, 1);\"> System.Net.Http.Json;\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> IAsyncEnumerable&lt;User&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GetUsersAsync()\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> response = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> httpClient.GetAsync(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">https://api.example.com/users</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> usersJson = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> response.Content.ReadAsStringAsync();\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用Json序列化工具解析用户列表</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">var</span> users = JsonSerializer.Deserialize&lt;List&lt;User&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(usersJson);\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> user <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> users)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">yield</span> <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> user;\n    }\n}\n​\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用异步LINQ查询</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> distinctUsers = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> GetUsersAsync().DistinctByAsync(user =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> user.Name).ToListAsync();\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> user <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> distinctUsers)\n{\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Name: {user.Name}, Age: {user.Age}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n}</span></pre>\n</div>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\" style=\"font-size: 16px;\">总结</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><code>DistinctBy</code><span class=\"md-plain\"> 方法是 .NET 6 和 .NET 7 中 LINQ 的一个非常实用的新特性。我们在 LINQ 查询中根据指定的键对集合进行去重，简化了代码并提高了开发效率。</span></span></p>\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain\" style=\"font-size: 16px;\">希望本文能帮助大家更好地理解和利用 .NET 6 和 .NET 7 中 LINQ 的 <span class=\"md-pair-s\"><code>DistinctBy</code><span class=\"md-plain md-expand\"> 方法，从而在项目中发挥更大的作用。</span></span></span></p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\" style=\"font-size: 16px;\">最后</span></h2>\n<p><span class=\"md-plain\" style=\"font-size: 16px;\"><span class=\"md-plain md-expand\">如果你觉得这篇文章对你有帮助，不妨点个赞支持一下！你的支持是我继续分享知识的动力。如果有任何疑问或需要进一步的帮助，欢迎随时留言。也可以加入微信公众号&nbsp;<span class=\"md-pair-s \"><strong>[DotNet技术匠]</strong><span class=\"md-plain md-expand\">&nbsp;社区，与其他热爱技术的同行一起交流心得，共同成长！</span></span></span></span></p>\n<p><span class=\"md-plain\" style=\"font-size: 16px;\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/576536/202408/576536-20240813102419584-1596250541.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 16:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/1312mn\">小码编匠</a>&nbsp;\n阅读(<span id=\"post_view_count\">229</span>)&nbsp;\n评论(<span id=\"post_comment_count\">3</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "扣子Coze实战：从0到1打造抖音+小红书热点监控智能体",
      "link": "https://www.cnblogs.com/tangshiye/p/19575161",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tangshiye/p/19575161\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 16:30\">\n    <span>扣子Coze实战：从0到1打造抖音+小红书热点监控智能体</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>大家好，我是汤师爷，专注AI智能体分享，致力于帮助100W人用智能体创富~</p>\n<p>热点监控智能体是帮你自动发现爆款选题的利器。</p>\n<p>它能全天候扫描各大平台的热门内容，从海量信息中筛选出最有价值的话题和创意。</p>\n<p>你不需要再手动搜索，智能体会自动将热点内容整理成表格，让你清晰直观地掌握行业动态。</p>\n<h3 id=\"1-为什么要做热点监控\">1 为什么要做热点监控</h3>\n<p>热点监控是内容创作者和营销人员的必备工具，它帮助我们在信息爆炸时代精准把握用户关注点，提升内容效果和影响力。以下是进行热点监控的四大核心理由：</p>\n<p><strong>1. 把握用户兴趣，提高内容相关性</strong></p>\n<p>用户的注意力是稀缺资源。通过实时监控热点话题，我们能了解目标受众当下最关心的问题和兴趣点。热点本质上是用户兴趣的集中体现，基于热点创作的内容自然具有更高的用户匹配度，更容易获得关注和互动。</p>\n<p><strong>2. 节约选题时间，提高创作效率</strong></p>\n<p>没有热点监控系统时，创作者需要在各平台间不断切换，手动搜索和筛选信息，这个过程既耗时又低效。自动化热点监控能持续追踪多平台热门内容，将重复性工作交给智能体，让创作者能专注于内容创作本身。</p>\n<p><strong>3. 抓住时机，提高曝光机会</strong></p>\n<p>热点具有明显的时效性，越早参与讨论，获得的曝光机会就越多。自动化热点监控系统能在热点刚出现时就发出提醒，帮助创作者抢占先机。比起等热点完全爆发后再跟进，提前布局能获得更多流量红利和平台算法青睐。</p>\n<p><strong>4. 发现内容机会，避免同质化</strong></p>\n<p>热点监控不只是追踪已经爆发的话题，更重要的是发现潜在新兴热点。通过分析热点数据，创作者可以识别尚未被充分挖掘的内容机会，避开同质化竞争，找到差异化表达角度，从而在激烈的内容竞争中脱颖而出。</p>\n<h3 id=\"2-热点监控智能体搭建流程\">2 热点监控智能体搭建流程</h3>\n<p>智能体的搭建流程主要分为两个步骤：梳理工作流和设置智能体。</p>\n<p><strong>1、梳理工作流</strong></p>\n<p>热点监控工作流是一套自动化信息采集和处理系统，能将人工需要几小时甚至几天完成的工作压缩至几分钟内自动完成。这一工作流主要包含三大环节：</p>\n<p><strong>（1）根据关键词，批量获取热门视频</strong></p>\n<p>系统根据预设的关键词（如行业热词、产品名称、竞品信息等），自动从抖音、小红书等平台搜索相关视频。这一步骤替代了手动搜索和浏览结果的过程，大幅提高效率。</p>\n<p><strong>（2）批量获取视频详细信息</strong></p>\n<p>获取视频列表后，系统进一步抓取每个视频的详细数据，包括：</p>\n<ul>\n<li>基础信息：视频ID、标题、链接、发布时间、视频时长等</li>\n<li>互动数据：点赞数、评论数、收藏数、分享数等关键指标</li>\n<li>创作者信息：作者名称、用户ID、个人简介等</li>\n</ul>\n<p>这些数据是分析视频热度和受欢迎程度的关键指标，也是判断内容价值的重要依据。系统将这些零散数据整合成结构化信息，便于后续分析。</p>\n<p><strong>（3）将数据添加到多维表格</strong></p>\n<p>最后，系统将处理好的数据自动导入到预设的飞书多维表格中。</p>\n<p>通过这样的自动化处理，我们能建立一个实时更新的热点内容库，随时查看行业动态，发现爆款选题灵感。</p>\n<p>这种工作流显著减轻了运营人员的工作负担，让我们能将更多精力投入到内容创作和策略制定上。</p>\n<p><strong>2、设置智能体</strong></p>\n<p>完成工作流搭建后，我们需要创建一个热点监控智能体来执行这个工作流。智能体设置过程分为三个关键步骤：</p>\n<ol>\n<li>设置人设与逻辑：配置智能体的特征、回复风格和决策逻辑</li>\n<li>绑定工作流：将工作流与智能体关联，赋予它执行具体任务的能力</li>\n<li>测试并发布：进行全面功能测试，确认一切正常后将智能体正式发布到生产环境</li>\n</ol>\n<p>完成这三个步骤后，我们就成功搭建了一个热点监控智能体。</p>\n<h3 id=\"3-抖音热点监控工作流\">3 抖音热点监控工作流</h3>\n<p>前面我们详细介绍了热点监控的重要性和智能体搭建的基本流程，接下来我们将深入了解如何实际搭建一个抖音热点监控工作流。</p>\n<p>登录Coze官网，在“资源库-工作流”里新建一个空白工作流，取名“fetch_douyin_hot_videos”。</p>\n<p>工作流整体预览如图所示。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>1、开始节点</strong></p>\n<p>这里用于定义工作流启动时所需的输入参数。如图6-2所示。</p>\n<ul>\n<li>输入：\n<ul>\n<li>keywords：用于搜索热点的关键词，可以是产品名称、行业术语、竞品名称或热门话题，系统会自动搜索相关的热门内容</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>2、插件节点：根据关键词，批量获取热门视频</strong></p>\n<p>我们将使用\"视频搜索\"插件的\"douyin_search\"工具。通过这个功能，我们可以根据关键词批量获取热门视频。</p>\n<ul>\n<li>输入：\n<ul>\n<li>api_token：这里需要填入你的API密钥，可以从插件的官方平台获取，它是调用视频数据的重要凭证，相当于你的身份证明</li>\n<li>keyword：关键词，从开始节点获取</li>\n<li>page：获取第几页的内容</li>\n<li>publish_time：发布时间，可用值为_0(不限)、_1(一天之内)、_7(一周之内)、_180(半年之内)，这里我们选择_7</li>\n<li>sort_type：排序类型，可用值：_0(综合)、_1(最多点赞)、_2(最新发布)，这里我们选择_1</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>4、批处理节点：批量获取视频详细信息</strong></p>\n<p>批量获取视频详细信息是工作流中的核心节点，它负责将上一步骤中获取的视频列表进一步深入处理，获取每个视频的完整信息。</p>\n<ul>\n<li>输入：\n<ul>\n<li>并行运行数量：设置适当的并行数量可提高工作流执行效率，设置为1则按顺序串行执行</li>\n<li>批处理次数上限：批处理操作不会超过这个设定的最大次数</li>\n<li>aweme_list：从\"根据关键词，批量获取热门视频\"节点输出中，选择data，类型为Array</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>5、批处理体内插件节点：获取单个视频详细信息</strong></p>\n<p>接下来，我们需要添加批处理体内的节点。我们将使用\"视频搜索\"插件的douyin_data工具，通过这个功能可以根据抖音视频链接获取视频的详细信息。</p>\n<ul>\n<li>输入：\n<ul>\n<li>api_token：API密钥</li>\n<li>douyin_url：从\"批量获取视频详细信息\"节点的输出中，选择share_url</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>6、批处理体内代码节点：将视频详情整合进视频列表中</strong></p>\n<p>这一步将从抖音API获取的详细视频信息与之前收集的视频列表数据合并。</p>\n<p>通过这个过程，我们能掌握每个视频的完整信息，包括互动数据（点赞、评论、收藏数）、创作者信息和内容详情，从而为后续分析提供全面的数据基础。</p>\n<ul>\n<li>输入：\n<ul>\n<li>aweme_detail：从\"获取单个视频详细信息\"节点的输出中，选择aweme_detail</li>\n<li>aweme：从\"批量获取视频详细信息\"节点的输出中，选择item</li>\n</ul>\n</li>\n<li>输出：\n<ul>\n<li>aweme_list：变量类型设置为 Array 对象数组，表示处理后的视频列表</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>下面是处理数据的Python代码，它会将视频信息转换成我们需要的格式。</p>\n<pre><code class=\"language-python\">async def main(args: Args) -&gt; Output:\n    params = args.params\n    aweme_detail = params.get(\"aweme_detail\", {})\n    aweme = params.get(\"aweme\", {})\n    aweme[\"aweme_detail\"] = aweme_detail\n\n    ret: Output = {\n        \"aweme_list\": [aweme]\n    }\n    return ret\n</code></pre>\n<p><strong>7、批处理体内代码节点：将信息整理为飞书表格可以使用的数据</strong></p>\n<p>在这个环节中，我们会提取视频的核心信息（如标题、点赞数、评论数等），并将它们转换成飞书表格能够直接识别和处理的格式。</p>\n<ul>\n<li>输入：\n<ul>\n<li>aweme_list：从\"将视频详情整合进视频列表中\"节点的输出中，选择aweme_list</li>\n<li>keywords：从开始节点中，选择keywords</li>\n</ul>\n</li>\n<li>输出：\n<ul>\n<li>records：处理后的表格数据，选择Array类型</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>下面是处理数据的Python代码，这段代码非常重要，它负责将抖音API返回的原始数据转换成结构化的表格数据。</p>\n<pre><code class=\"language-python\">async def main(args: Args) -&gt; Output:\n    params = args.params\n    aweme_list = params.get(\"aweme_list\", [])\n\n    result = []\n\n    # 遍历 aweme_list，依次处理\n    for aweme in aweme_list:\n\n        # 获取 aweme_detail 并判空\n        aweme_detail = aweme.get(\"aweme_detail\") or {}\n        title = aweme_detail.get(\"desc\") or \"\"\n        link = aweme_detail.get(\"share_url\") or \"\"\n\n        # 安全获取 statistics\n        statistics = aweme_detail.get(\"statistics\") or {}\n\n        # 提取各字段信息，并在取值时加默认值\n        video_id = statistics.get(\"aweme_id\") or \"\"\n        digg_count = statistics.get(\"digg_count\") or 0\n        comment_count = statistics.get(\"comment_count\") or 0\n        collect_count = statistics.get(\"collect_count\") or 0\n        share_count = statistics.get(\"share_count\") or 0\n\n        # 获取作者信息\n        author_info = aweme_detail.get(\"author\") or {}\n        author_name = author_info.get(\"nickname\") or \"\"\n        signature = author_info.get(\"signature\") or \"\"\n        sec_uid = author_info.get(\"sec_uid\") or \"\"\n        raw_create_time = aweme_detail.get(\"create_time\", 0)\n        # 如果不是 int，就尝试转换，失败则为 0\n        try:\n            create_time = int(raw_create_time)\n        except (TypeError, ValueError):\n            create_time = 0\n\n        # 创建时间以毫秒计，避免 None 或非法值导致报错\n        create_time_ms = create_time * 1000\n\n        raw_duration = aweme_detail.get(\"duration\", 0)\n        # 如果不是数字，尝试转换为 float，失败则为 0\n        try:\n            duration = float(raw_duration)\n        except (TypeError, ValueError):\n            duration = 0.0\n        duration_sec = duration / 1000\n\n        # 组装返回数据\n        item_dict = {\n            \"fields\": {\n                \"视频ID\": video_id,\n                \"标题\": title.strip(),\n                \"关键词\": params.get(\"keywords\", \"\"),\n                \"链接\": {\n                    \"text\": \"查看视频\",\n                    \"link\": link.strip(),\n                },\n                \"点赞数\": digg_count,\n                \"评论数\": comment_count,\n                \"收藏数\": collect_count,\n                \"分享数\": share_count,\n                \"作者\": author_name,\n                \"用户简介\": signature,\n                \"用户ID\": sec_uid,\n                \"发布日期\": create_time_ms,  # 毫秒级时间戳\n                \"时长\": duration_sec        # 秒\n            }\n        }\n        result.append(item_dict)\n\n    return result\n</code></pre>\n<p><strong>8、批处理体内插件节点：将数据添加到多维表格</strong></p>\n<p>首先，我们需要创建一个多维表格并设置好表头字段，为后续数据采集做好准备。这个表格是存储和分析抖音热点视频数据的核心，因此表头设计至关重要。我们应包含视频ID、标题、点赞数、评论数等关键信息，便于后期分析和筛选。创建好的表格界面如下图所示。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>选择\"飞书表格\"插件节点的add_records工具，将数据添加到多维表格。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<ul>\n<li>输入：\n<ul>\n<li>app_token：提前创建一个多维表格，将多维表格的链接复制进去。</li>\n<li>records：从\"将信息整理为飞书表格可以使用的数据\"的输出变量中，选择records。</li>\n<li>table_id：多维表格数据表的唯一标识符，如图6-10所示。</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>9、结束节点</strong></p>\n<p>选择\"返回文本\"，并将回答内容设置为：\"获取关键词下的所有抖音视频【完成】\"。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"4抖音热点监控智能体设置\">4.抖音热点监控智能体设置</h3>\n<p>到目前为止，我们已经介绍了抖音热点监控工作流的搭建过程。接下来，我们将介绍抖音热点监控智能体的设置。这个环节将工作流与智能体绑定，只有完成这一步，我们才能真正实现抖音热点监控智能体的功能。</p>\n<p>接下来，我们将逐步指导你完成整个设置过程，包括创建智能体、配置基本参数、连接工作流以及进行测试，帮助你快速掌握这项实用技能。</p>\n<p><strong>1、新建智能体</strong></p>\n<p>在Coze平台创建一个新的智能体，将其命名为\"抖音热点监控智能体\"。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>2、设置人设与逻辑</strong></p>\n<p>设置人设与逻辑是创建智能体的关键步骤。在这一环节，我们需要明确智能体的行为模式和响应方式。</p>\n<p>对于抖音热点监控智能体，我们希望它能直接执行任务，无需过多交互。因此，我们设置简单明了的指令，让智能体在接收到关键词后立即执行视频采集工作。</p>\n<pre><code>直接执行`fetch_douyin_hot_videos`\n</code></pre>\n<p><strong>3、绑定工作流</strong></p>\n<p>把\"fetch_douyin_hot_videos\"工作流添加到智能体中。这个工作流是我们之前设计的抖音视频采集工作流，将它绑定到智能体后，用户只需输入关键词，智能体就会自动执行工作流，帮助我们高效地收集抖音热点视频。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>5、测试并发布</strong></p>\n<p>在预览与调试窗口中输入关键词，测试智能体采集热点抖音视频的功能。系统会自动执行工作流，并将结果添加到飞书表格中。</p>\n<p>使用不同关键词进行多次测试，确保智能体在各种情况下都能稳定运行。测试无误后，点击\"发布\"按钮将智能体正式发布到生产环境，供用户使用。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"5小红书热点监控工作流\">5.小红书热点监控工作流</h3>\n<p>接下来我们将深入了解如何实际搭建一个小红书热点监控工作流。</p>\n<p>这个工作流能帮你自动收集小红书平台上的热门内容，让你不用手动浏览就能掌握最新趋势。</p>\n<p>我们将使用简单易懂的步骤，带你从零开始构建这个强大的监控系统，即使你没有编程经验也能轻松上手。</p>\n<p>登录Coze官网，在“资源库-工作流”里新建一个空白工作流，取名“xhs_keywords”。工作流整体预览如图所示。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>1、开始节点</strong></p>\n<p>这里用于定义工作流启动时所需的输入参数。</p>\n<ul>\n<li>输入：\n<ul>\n<li>foldUrl：飞书表格链接，需要提前创建好一个飞书多维表格，并复制其链接。该表格将用于存储我们采集到的小红书热点视频</li>\n<li>cookie：小红书网站的cookie信息，这是访问小红书API的必要凭证，我们将在后面详细讲解如何获取</li>\n<li>keywords：用于搜索热点的关键词，可以是产品名称、行业术语、竞品名称或热门话题，系统会自动搜索相关的热门内容</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>2、如何获取小红书cookie</strong></p>\n<p>在Chrome浏览器中，登录小红书主页：<a href=\"https://www.xiaohongshu.com/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.xiaohongshu.com/</a></p>\n<p>按F12键打开开发者工具面板，然后按照以下步骤操作：</p>\n<ul>\n<li>第一步：点击「网络」选项卡</li>\n<li>第二步：点击「文档」标签</li>\n<li>第三步：点击「explore」文档</li>\n<li>第四步：点击「标头」选项卡</li>\n<li>第五步：滚动页面找到Cookie字段，复制整段Cookie信息。</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>2、插件节点：根据关键词获取笔记</strong></p>\n<p>我们将使用“小红书”插件的xhs_search_note工具。通过这个功能，我们可以根据关键词，批量获取热门视频。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<ul>\n<li>输入：\n<ul>\n<li>cookieStr：开始节点的 cookie</li>\n<li>keywords：关键词，从开始节点获取</li>\n<li>notType：查询类型（0=全部，1=视频，2=图文），这里我们选择1 视频类型</li>\n<li>sort：排序（默认为综合，0=综合，1=最新，2=最热），这里我们选择2 最热</li>\n<li>totalNumber：查询总数，这里我们输入20</li>\n</ul>\n</li>\n</ul>\n<p><strong>3、循环节点：循环获取笔记详情</strong></p>\n<p>循环获取笔记详情是工作流中的关键环节，它使我们能够一次性处理多条小红书笔记。从搜索结果中获取笔记链接后，我们需要逐一获取每条笔记的详细信息，包括标题、内容、作者和点赞数等。</p>\n<ul>\n<li>输入：\n<ul>\n<li>input：从\"根据关键词获取笔记\"节点的输出中，选择 data</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>4、循环体内插件节点：获取笔记详情</strong></p>\n<p>我们将使用小红书插件的xhs_note_detail工具。该工具能获取每条笔记的完整信息，包括标题、内容、作者信息和互动数据等。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<ul>\n<li>输入\n<ul>\n<li>cookieStr：开始节点的 cookie</li>\n<li>noteUrl：从 “循环笔记详情” 节点的输出中，选择 noteUrl</li>\n</ul>\n</li>\n</ul>\n<p><strong>5、循环体内插件节点：提取视频文案</strong></p>\n<p>我们将使用\"字幕获取\"插件的generate_video_captions_sync工具。该工具能自动从视频中提取文字内容，将口述转换为文本，省去手动听写的麻烦。它能精准识别视频中的语音并生成文字记录，帮助我们快速理解视频的主题和关键信息。</p>\n<p>输入：</p>\n<ul>\n<li>url：从\"获取笔记详情\"节点的输出中，选择 video_h264_url，表示H264标准编码格式视频链接</li>\n<li>lang：视频语言，如汉语、英语等，不填时默认为汉语</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>6、循环体内代码节点：将笔记数据整理成飞书表格格式</strong></p>\n<p>这一步将采集到的视频信息转换为标准化数据结构，以便写入飞书表格。我们需要提取视频的标题、内容、作者和点赞数等关键信息，并按飞书表格要求进行格式化。这样不仅便于数据整理和筛选，还能帮助我们更直观地分析热门内容的特点。</p>\n<ul>\n<li>输入\n<ul>\n<li>input：从\"获取笔记详情\"节点的输出中，选择note</li>\n<li>data：从\"提取视频文案\"节点的输出中，选择data</li>\n</ul>\n</li>\n<li>输出\n<ul>\n<li>records：变量类型设置为 Array 对象数组，表示处理后的视频列表</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>下面是处理数据的Python代码，它将采集到的小红书视频信息转换为标准格式，便于存储和分析。</p>\n<p>代码提取视频的标题、内容、作者等关键信息，将其组织成飞书表格所需的格式，然后返回处理好的数据。这样我们能将所有热门视频整齐地存放在同一张表格中，方便后续分析：</p>\n<pre><code class=\"language-python\">async def main(args: Args) -&gt; Output:\n    input_data = args.params.get('input')  or {}\n    data = args.params.get('data') or {}\n\n    records = []  # 初始化 records 列表\n\n    # 提取 note 相关字段\n    title = input_data.get('note_display_title', '')  # 标题\n    desc = input_data.get('note_desc', '')  # 描述\n    url = input_data.get('note_url', '')  # 链接\n    nickname = input_data.get('auther_nick_name', '')  # 作者昵称\n    likedCount = input_data.get('note_liked_count', '0')  # 点赞数\n    videoUrl = input_data.get('video_h264_url', '')  # 视频地址\n    collectedCount = input_data.get('collected_count', '0')  # 收藏数\n    imageList = input_data.get('note_image_list', [])  # 图片列表\n\n    # 构建记录对象\n    record = {\n        \"fields\": {\n            \"笔记链接\": url,\n            \"标题\": title,\n            \"内容\": desc,\n            \"作者\": nickname,\n            \"点赞数\": likedCount,\n            \"链接\": {\n                \"link\": url,\n                \"text\": title\n            },\n            \"收藏数\": collectedCount,\n            \"图片地址\": '\\n'.join(imageList),  # 将图片列表拼接成字符串\n            \"视频地址\": videoUrl,\n            \"视频文案\": data.get(\"content\", \"\") \n        }\n    }\n    records.append(record)  # 将记录对象添加到 records 列表中\n\n    # 构建输出对象\n    ret: Output = {\n        \"records\": records\n    }\n    return ret\n</code></pre>\n<p><strong>7、循环体内插件节点：写入飞书表格</strong></p>\n<p>最后，我们将收集到的所有数据添加到飞书多维表格中。</p>\n<p>我们需要提前创建一个多维表格，并设置好对应的表头字段。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>表头字段包括视频的所有关键信息：笔记链接、标题、内容、作者、点赞数、链接、收藏数、图片地址、视频地址和视频文案。</p>\n<p>接下来，选择\"飞书表格\"插件节点的add_records工具，将采集到的数据添加到多维表格中。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<ul>\n<li>输入：\n<ul>\n<li>app_token：提前创建一个多维表格，然后将多维表格的链接复制到此处。</li>\n<li>records：从\"将信息整理为飞书表格可以使用的数据\"节点的输出变量中，选择records。</li>\n<li>table_id：需填入多维表格数据表的唯一标识符。</li>\n</ul>\n</li>\n</ul>\n<p><strong>8、结束节点</strong></p>\n<p>最后添加结束节点，完成整个工作流程。如图6-25所示。</p>\n<ul>\n<li>输出：\n<ul>\n<li>output：开始节点的foldUrl，也就是飞书多维表格的链接</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"6小红书热点监控智能体设置\">6.小红书热点监控智能体设置</h3>\n<p>至此，我们已完成小红书热点监控工作流的搭建。接下来，我们将介绍如何设置小红书热点监控智能体。这个关键环节将工作流与智能体绑定在一起，只有完成这一步，才能真正实现小红书热点监控智能体的功能。</p>\n<p><strong>1、新建智能体</strong></p>\n<p>在Coze平台创建一个新的智能体，命名“小红书热点监控智能体”。如图6-26所示。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>2、设置人设与逻辑</strong></p>\n<p>设置人设与逻辑是创建智能体的关键步骤。在这一环节，我们需要明确智能体的行为模式和响应方式。</p>\n<p>对于小红书热点监控智能体，我们希望它能直接执行任务，无需过多交互。因此，我们设置简单明了的指令，让智能体在接收到关键词后立即执行视频采集工作。</p>\n<pre><code>直接执行`xhs_keywords`\n</code></pre>\n<p><strong>3、绑定工作流</strong></p>\n<p>把\"xhs_keywords\"工作流添加到智能体中。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>4、测试并发布</strong></p>\n<p>在预览与调试窗口中输入关键词，测试智能体的小红书热点视频采集功能。系统会自动执行工作流，并将结果直接添加到飞书表格中。</p>\n<blockquote>\n<p>对了，我整理了一份开源的智能体学习手册，爆肝 10 万字，价值 999 元。限时开放领取👉：<a href=\"https://tangshiye.cn\" rel=\"noopener nofollow\" target=\"_blank\">tangshiye.cn</a></p>\n</blockquote>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/tangshiye/\" target=\"_blank\">AI架构师汤师爷</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/tangshiye/p/19575161\" target=\"_blank\">https://www.cnblogs.com/tangshiye/p/19575161</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 16:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tangshiye\">AI架构师汤师爷</a>&nbsp;\n阅读(<span id=\"post_view_count\">142</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "浅谈数据访问层",
      "link": "https://www.cnblogs.com/legweifang/p/19575087",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/legweifang/p/19575087\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 16:23\">\n    <span>浅谈数据访问层</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p style=\"text-align: center;\">浅谈数据访问层</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 写下数据访问层这几个字，恐怕现在的程序员很少知道是什么意思的，他们可能知道数据实体，知道EF和SqlSugar，不知道数据访问层是咋回事。的确现在的ORM框架已经淡化了数据访问层的概念，现在只要会创建实体类，会调用EF就可以了，框架一切都是做好了，不用懂数据库，也不用关心是什么数据库，总之一套代码什么数据库都支持，还为这种开发模式起了名字叫CodeFirst（代码先行）。作为一名老程序员，我不知道软件开发模式为啥会演变到今天这个样子，搞的越来越复杂，越来越脱离根本。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;我们那时候的程序员（大概范围是在2000年前后10年吧）要想学会软件开发，首先要学会使用数据库，要学会写sql，因为sql 是操作数据的根本，然后要学会存储过程，因为存储过程是性能优化的重要手段，还要学会视图，因为视图是数据关联的桥梁，还有触发器，是弥补功能缺陷的利器。而现在呢？这些全不被提倡了，这些传统的技术全成为了ORM 的绊脚石。在ORM框架里，数据库的组织和处理能力全部被实体类代替了，只剩下存储这一个功能了。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;现在的程序员不了解数据库，软件系统出了问题也不知道是什么原因，代码没问题，问题可能出在数据上。就好比现在的程序员也不懂硬件，甚至不会安装操作系统。我们那时候的程序员在很多人眼里就是修电脑的，其实主业是写代码，但人家不关心，也不了解，只知道会修电脑。现在呢，不是这样了，有人说这是行业的细分，专业的人就得做专业的事，但我觉得有些相关技能还是自己会比较好。</p>\n<p>&nbsp; &nbsp; &nbsp; 程序员必须要懂数据库，这是根本。</p>\n<p>&nbsp; &nbsp; &nbsp; 我遇到过一个程序员，他说他从来不会去写sql，用ORM框架多简单，不用ORM 就是一种落后，他很执着，我是没法反驳他的，因为这是当下流行的趋势，我只知道，要解决软件系统的问题，只了解程序代码是不够的，很多深层次的问题要查数据库，分析数据，这才能从本质上解决问题，否则很可能改了这个问题出来那个问题，按下葫芦起来瓢，永远改不完的问题。</p>\n<p>喜欢使用ORM框架的我总结了两个原因，第一、为了跨数据库，一套代码适合各种数据库；第二、不用学习sql语法、视图、存储过程、触发器，省去学习数据库的成本，其他我想不出更合适的理由。</p>\n<p>我不喜欢这种开发模式，ORM 把本该放在数据库上的精力，放在了程序上，那些拉姆达表达式比sql还难理解，我觉得这是本末倒置，认知上的倒退，道在迩而求诸远，事在易而求诸难。其实每种开发方式都有它的优缺点，没有对错，只有是否合适，适合你的，对你来说就是对的，不适合你的对你来说就是错的，不能一概而论。要解决问题，就用自己最擅长的方式。</p>\n<p>我提倡的方式是不用实体类，用传统的sql和DataTable，这是最简单最灵活的方式，也就是最传统的方式。这样既能熟悉了数据库又能灵活的编写代码。</p>\n<p>&nbsp; &nbsp; &nbsp; 我知道我写这篇文章很多人会反对，因为现在估计80%的人都在使用ORM框架开发，包括以前喜欢写sql的那批老程序员。这里呢我也不想争论，能解决问题就行。愿意用啥就用啥，但是要做到问题到我这里结束，不要说我不会这个，这个不管我的事，数据库我不会查，每个人要对自己选择的方式负责到底。</p>\n<p>&nbsp; &nbsp; &nbsp; 几年前，我比较看中程序代码的编写规范，我觉得代码应该看上去比较舒服，编码风格要一致，不仅仅是实现功能。有一位资深的程序员，不太认同，他说不管代码写的怎样，只要数据对就行，以数据库为准，现在我觉得他说的有一定道理，每个程序员的水平不一样，程序写的不好可以重写，但数据要对。产生数据的方式有很多，数据来源不止一个，有可能是手工录入的，有可能是接口推送的，有可能是导入的，不管是那种方式都要确保数据的准确性和完整性。</p>\n<p>&nbsp; &nbsp; &nbsp; 所以从本质上来说，数据访问层使用什么方式并不是最重要的。数据准确性和完整性才是最重要的。</p>\n<p>如果你赞同上面的分析，那么继续向下看如何设计简单实用的数据访问层，如果不赞同那就到次为止。因为后面的设计思想可能让你更加不屑。</p>\n<p>数据访问层的设计要解决一下几个问题：</p>\n<p>1、连接数据库。要支持连接多种类型的数据库，方式主要是通过官方提供的数据库访问类，例如SqlDataClient。</p>\n<p>2、基本的数据访问方法。执行新建insert、更新update、查询select，以及调用存储过程，这些基本就够了。再进一步归纳一下就是两个方法，ExecuteNonQuery 和ExecuteQuery。</p>\n<p>3、执行数据操作返回的数据对象。新增和更新返回的是影响的数据行数，存储过程返回的是执行是否成功（尽量避免使用存储过程的返回值），这些没什么好说的。需要说的是查询数据时返回数据对象。有两种对象，一种是DataTable ，一种是DataReader，DataTable 是比较传统的方式，也是最早被广泛使用的。DataReader 是后期才有的，可以看作是DataTable 的只读形式，目的是提高读取的性能，ORM 框架就是把DataReader 映射成实体类。这是目前被提倡的开发模式，但我们不用这种方式，而是继续用DataTable，因为我们不使用实体类。</p>\n<p>&nbsp; &nbsp; &nbsp; 下面我们对这三个问题展开说明，具体如何实现。</p>\n<p>&nbsp; &nbsp; &nbsp; 第一个问题，如何实现连接多种类型的数据库。</p>\n<p>&nbsp; &nbsp; &nbsp; 如在访问SqlServer 数据库的时候使用SqlDataClient(Net版本不同名字可能不一样)，访问MySql 数据库的时候使用MySql.DataClient。 最简单的办法就是使用接口类，定义一个接口类，把所有数据访问方法都定义出来，使用接口来调用方法，再创建访问SqlServer 的实现类和MySql 的实现类，都要实现该接口。然后最外层再做一个代理类Agent ，用来确定接口要调用哪个类。</p>\n<p>程序结构如下图：</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/34454/202602/34454-20260204162050993-867994170.png\" /></p>\n<p>接口的定义如下图（只显示主要的方法）：</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/34454/202602/34454-20260204162052693-107139067.png\" /></p>\n<p>代理类的定义如下图（只显示主要方法）：</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/34454/202602/34454-20260204162053367-1421368934.png\" /></p>\n<p>&nbsp; &nbsp; &nbsp; 第二个问题，操作数据库的基本方法，有人说基本方法是增删改查，这个没错，我觉得再进一步会归纳一下是执行和获取数据。就是两个方法ExecuteNonQuery和ExecuteQuery。其他所有的操作都是围绕这两个方法，也可以说都是调用这两个方法。要在每种类型的数据库访问类中实现这几个基本方法。</p>\n<p>以SqlServer 为例列出基本方法如下图（只显示主要的方法）：</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/34454/202602/34454-20260204162052434-912150011.png\" /></p>\n<p>&nbsp; &nbsp; &nbsp; 第三个问题，返回数据的对象。</p>\n<p>&nbsp; &nbsp; &nbsp; 前面说了我们用DataTable，而不用数据实体，主要是因为它灵活。这样设计是在项目中成本最低的方案。我曾经设想过使用数据实体的场景，那就是业务需求非常明确，调研充分，数据结构基本定型，字段数量类型都很确切，至少业务模型预演了几遍的，也就保证功能做出来不会经常修改。这种情况我见过，做过对日外包项目的都知道，简直是变态的设计要求，一个字段，一个输入框的尺寸，字数限制，验证提示都要在文档里写清楚，项目周期三个月的话文档要写两个半月。现实中这种情况太少了，很多情况我们拿到个大概的需求就动手了，一边做一边完善数据库字段，大方向不会错，增加个字段是常有的事。不要说这是违反软件开发规范的，严格遵守软件规范是很理想的事情，不知道大厂们是否能严格遵守软件开发规范？</p>\n<p>&nbsp; &nbsp; &nbsp; ExecuteQuery包括两个方法，一个是返回DataTable，一个是返回DataReader，严格来讲DataTable并不存在，在Net的Framework或NetCore框架中有两种方式返回DataTable，一种是通过DataAdapter对象的Fill方法填充DataTable，一种是使用DataReader填充DataTable，其实这已经足够用了。</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/34454/202602/34454-20260204162053187-175167613.png\" /></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/34454/202602/34454-20260204162053774-1873792402.png\" /></p>\n<p>两种方法稍微有点差异，以后再慢慢说，真正使用的时候就知道了，这里不能说多了，说多容易跑题。</p>\n<p>&nbsp; &nbsp; &nbsp; 数据库访问类的设计是重点，除了提供基本方法外，还要处理好数据库连接、数据库关闭，开启事务、关闭事务，事务回滚。这都是很重要的概念，如果数据库只开不关，很快连接数量就用完了。初学者很容易犯的错误，一旦出现还很难排查。再有一个重要的概念是同一批数据操作尽量在一个数据库开闭中完成，不要反复的开闭数据库，例如，修改一条商品信息，先查询商品编号是否已经存在，如果不存在可以保存，已经存在提示重复，不能保存。这个功能包括2个数据操作，一个是按编号查询商品表，一个是更新商品表。这两个动作要在一个数据库连接中完成。不能每个动作都要开闭数据库。在早期的数据库访问层HFBPM3.5中，存在这个问题。那时候的设计考虑要支持本地调用和远程调用（WCF的方式），每个数据操作都可以调用远程的方法，不能在一个本地连接里完成。后来的版本去掉了远程调用。</p>\n<p>&nbsp; &nbsp; &nbsp; 提到WCF不得不跑个题，因为涉及到微软的技术框架，很早微软推出了三大框架WCF、WFF、WPF，至今只留下了WPF，其他两个在微软Core中基本消失了。微软的东西是好，用起来方便，功能也强大，但淘汰也快，太理想化的东西容易走偏，有些东西出的晚，生态就不好。比如这个MVC的架构，我到现在没怎么使用这个架构，但是这个思想我一直在用，在微软asp.net的时候，web界面要使用服务端控件，这个不方便，很快就被淘汰了，随着ajax和jquery的兴起时，我们在传统的aspx上使用ajax和jquery，即使用了aspx的后台功能，又使用了js前端框架的优势，就没有使用MVC，说实话微软的MVC框架出来的有点晚，我们已经在做了，HFbpm4.0使用的就是这种架构，这种架构也类似于NetCore的WebAPI架构，后台接口使用的MVC的路由机制，利用反射技术动态调用方法，比WebAPI还要灵活，WebAPI的依赖注入也有很多不灵活的地方，这里要细讲也需要很大的篇幅，先不赘述了，有兴趣的可以看一下hfbpm4.0的程序架构，总之一句话，用最简单的技术实现最基本的功能，大道至简。</p>\n<p>&nbsp; &nbsp; &nbsp; 这个题跑的有点远，赶紧回到正题上，开闭数据库和数据库事务，这些功能要手动来完成，默认的情况下，每次数据操作都要开闭数据库一次。我们通过数学控制数据操作后下不要关闭数据库连接，等操作完后再手动关闭。如下面的代码：</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/34454/202602/34454-20260204162056417-2110537453.png\" /></p>\n<p>&nbsp; &nbsp; &nbsp; 手动开启事务，手动关闭事务，如下图：</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/34454/202602/34454-20260204162056835-527302775.png\" /></p>\n<p>&nbsp; &nbsp; &nbsp; 这些测试工作是比较复杂的，为了方便测试开发了一个测试工具，主要测试多个操作是否开闭了一次数据库，数据库事务是否能正常回滚等。在执行数据库操作时为每次数据库连接定义一个随机数，从数据库连接打开到关闭，所有的数据库操作都返回这个随机数，如果随机数不一样，说明不是在一个数据库连接中完成的操作。如下图：</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/34454/202602/34454-20260204162055237-1397352915.png\" /></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/34454/202602/34454-20260204162052854-1127795205.png\" /></p>\n<p>&nbsp; &nbsp; &nbsp; 上面介绍的这些功能，是数据库操作的基本功能，有了这些就可以完成数据库的增删改查了。但是如果对一个开发平台来说，这些还不够，一个开发平台，还需要有数据库维护的功能，即元数据操作的功能，比如创建表、创建字段、修改字段，获取表结构等。这些功能也要在数据库访问层中实现。一个完整的数据库访问层应该包括一下功能：</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/34454/202602/34454-20260204162053674-1995650034.png\" /></p>\n<p>&nbsp; &nbsp; &nbsp; 以上是对数据访问层的一点浅浅的认识，不正确的地方欢迎批评指正，很期待与同行们的交流。淌过的水，走过的路，踩过的坑分享出来，共同提高进步！</p>\n\n</div>\n<div id=\"MySignature\">\n    我的程序人生\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 16:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/legweifang\">云飞扬</a>&nbsp;\n阅读(<span id=\"post_view_count\">125</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Apache SeaTunnel Zeta、Flink、Spark 怎么选？底层原理 + 实战对比一次讲透",
      "link": "https://www.cnblogs.com/seatunnel/p/19575007",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/seatunnel/p/19575007\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 16:05\">\n    <span>Apache SeaTunnel Zeta、Flink、Spark 怎么选？底层原理 + 实战对比一次讲透</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文档将深入解析 Apache SeaTunnel 支持的三大执行引擎：Zeta (SeaTunnel Engine)、Flink 和 Spark。我们将从架构设计、核心特性、优缺点对比以及使用方法等多个维度进行详细讲解，帮助你根据业务需求选择最合适的引擎。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><img alt=\"对比\" class=\"lazyload\" /></p>\n<p>本文档将深入解析 Apache SeaTunnel 支持的三大执行引擎：<strong>Zeta (SeaTunnel Engine)</strong>、<strong>Flink</strong> 和 <strong>Spark</strong>。我们将从架构设计、核心特性、优缺点对比以及使用方法等多个维度进行详细讲解，帮助你根据业务需求选择最合适的引擎。</p>\n<h2 id=\"1-引擎概览\">1. 引擎概览</h2>\n<p>SeaTunnel 的架构设计采用了 <strong>API 与执行引擎解耦</strong> 的策略。这意味着同一套数据同步逻辑（Config）可以无缝运行在不同的引擎上。</p>\n<ul>\n<li><strong>Zeta Engine</strong>: SeaTunnel 社区专门为数据集成场景自研的新一代引擎，专注于高性能、低延迟的数据同步。</li>\n<li><strong>Flink Engine</strong>: 利用 Flink 强大的流处理能力，适合已拥有 Flink 集群的用户。</li>\n<li><strong>Spark Engine</strong>: 利用 Spark 强大的批处理能力，适合离线大规模数据处理场景。</li>\n</ul>\n<h2 id=\"2-zeta-引擎核心推荐\">2. Zeta 引擎——核心推荐</h2>\n<p>Zeta 是目前 SeaTunnel 社区主推的默认引擎。它旨在解决 Flink/Spark 在简单数据同步场景下“资源消耗大、部署运维重”的问题。</p>\n<h3 id=\"21-核心架构\">2.1 核心架构</h3>\n<p>Zeta 采用无中心化（Decentralized）或 Master-Slave 架构（取决于部署模式），主要包含以下组件：</p>\n<ul>\n<li><strong>Coordinator (Master)</strong>:\n<ul>\n<li><strong>作业解析</strong>: 将逻辑 DAG (Logical DAG) 转换为物理 DAG (Physical DAG)。</li>\n<li><strong>资源调度</strong>: 管理 Slot，向 Worker 分配任务。</li>\n<li><strong>Checkpoint Coordinator</strong>: 负责触发和协调分布式快照（基于 Chandy-Lamport 算法），保障数据一致性。</li>\n</ul>\n</li>\n<li><strong>Worker (Slave)</strong>:\n<ul>\n<li><strong>Task Execution</strong>: 运行 Source, Transform, Sink 任务。</li>\n<li><strong>Data Transport</strong>: 负责节点间的数据传输。</li>\n</ul>\n</li>\n<li><strong>ResourceManager</strong>: 支持 Standalone, YARN, Kubernetes 等多种资源管理模式。</li>\n</ul>\n<p><img alt=\"SeaTunnel Engine\" class=\"lazyload\" /></p>\n<h3 id=\"22-关键特性\">2.2 关键特性</h3>\n<ol>\n<li><strong>Pipeline 级容错 (Pipeline-level Fault Tolerance)</strong>:\n<ul>\n<li>不同于 Flink 的“全图重启”，Zeta 可以只重启失败的 Pipeline（例如多表同步中，表 A 失败不影响表 B）。</li>\n</ul>\n</li>\n<li><strong>增量快照 (Incremental Checkpoint)</strong>:\n<ul>\n<li>支持高频 Checkpoint，最小化数据丢失风险，同时对性能影响极小。</li>\n</ul>\n</li>\n<li><strong>动态扩缩容 (Dynamic Scaling)</strong>:\n<ul>\n<li>支持在作业运行时动态增加或减少 Worker 节点，无需重启作业。</li>\n</ul>\n</li>\n<li><strong>Schema Evolution (表结构变更)</strong>:\n<ul>\n<li>原生支持 DDL 变更同步（如 Add Column），这对 CDC 场景至关重要。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"23-使用指南\">2.3 使用指南</h3>\n<p>Zeta 引擎通常包含在 SeaTunnel 的二进制包中，开箱即用。</p>\n<p><strong>启动命令 (Local 模式 - 开发测试):</strong></p>\n<pre><code class=\"language-bash\">./bin/seatunnel.sh --config ./config/your_job.conf -e local\n</code></pre>\n<p><strong>启动命令 (Cluster 模式 - 生产环境):</strong></p>\n<ol>\n<li>启动 Server (Master/Worker):<pre><code class=\"language-bash\">./bin/seatunnel-cluster.sh -d\n</code></pre>\n</li>\n<li>提交任务到集群:<pre><code class=\"language-bash\">./bin/seatunnel.sh --config ./config/your_job.conf -e cluster\n</code></pre>\n</li>\n</ol>\n<h2 id=\"3-flink-引擎\">3. Flink 引擎</h2>\n<p><img alt=\"flink-1_highres\" class=\"lazyload\" /></p>\n<p>SeaTunnel 通过翻译层（Translation Layer）将内部的 Source/Sink API 适配为 Flink 的 <code>SourceFunction</code> / <code>SinkFunction</code> (或 Flink 新版 Source/Sink API)。</p>\n<h3 id=\"31-架构原理\">3.1 架构原理</h3>\n<ul>\n<li><strong>Translation</strong>: SeaTunnel 在 Client 端将 Config 解析并翻译成 Flink JobGraph。</li>\n<li><strong>Execution</strong>: 提交给 Flink Cluster 执行。此时，SeaTunnel 任务就是一个标准的 Flink 任务。</li>\n<li><strong>State Backend</strong>: 依赖 Flink 的 Checkpoint 机制（RocksDB/FsStateBackend）管理状态。</li>\n</ul>\n<h3 id=\"32-优缺点\">3.2 优缺点</h3>\n<ul>\n<li><strong>优点</strong>: 生态成熟，运维工具丰富，适合复杂的流式计算+同步场景。</li>\n<li><strong>缺点</strong>: 版本耦合严重（需适配 Flink 1.13-1.18 等不同版本），对于纯同步任务显得过重。</li>\n</ul>\n<h3 id=\"33-使用指南\">3.3 使用指南</h3>\n<p>需要下载对应的 <code>seatunnel-flink-starter</code> jar 包，并确保 Flink 环境已准备好。</p>\n<p><strong>启动命令 (Flink 1.13+):</strong></p>\n<pre><code class=\"language-bash\">./bin/start-seatunnel-flink-13-connector-v2.sh \\\n    --config ./config/your_job.conf \\\n    --run-mode run # 或 run-application\n</code></pre>\n<p><em>(注意：不同 Flink 版本脚本名称略有不同，如 <code>flink-15</code>, <code>flink-18</code>)</em></p>\n<h2 id=\"4-spark-引擎\">4. Spark 引擎</h2>\n<p><img alt=\"spark\" class=\"lazyload\" /></p>\n<p>类似于 Flink，SeaTunnel 将 Source/Sink 适配为 Spark 的 <code>DataSource V2</code> API。</p>\n<h3 id=\"41-架构原理\">4.1 架构原理</h3>\n<ul>\n<li><strong>Batch</strong>: 使用 Spark RDD / DataFrame API 执行离线批处理。</li>\n<li><strong>Streaming</strong>: 使用 Spark Streaming (Micro-batch) 执行流式处理。</li>\n</ul>\n<h3 id=\"42-优缺点\">4.2 优缺点</h3>\n<ul>\n<li><strong>优点</strong>: 批处理性能强大，在大规模离线数据清洗/ETL 场景表现优异。</li>\n<li><strong>缺点</strong>: 流处理基于微批（Micro-batch），延迟通常高于 Flink/Zeta；资源调度较慢。</li>\n</ul>\n<h3 id=\"43-使用指南\">4.3 使用指南</h3>\n<p>需要下载对应的 <code>seatunnel-spark-starter</code> jar 包。</p>\n<p><strong>启动命令 (Spark 3.x):</strong></p>\n<pre><code class=\"language-bash\">./bin/start-seatunnel-spark-3-connector-v2.sh \\\n    --config ./config/your_job.conf \\\n    --master local[4] # 或 yarn, k8s\n</code></pre>\n<h2 id=\"5-三大引擎全方位对比\">5. 三大引擎全方位对比</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">特性</th>\n<th style=\"text-align: left;\">Zeta (SeaTunnel Engine)</th>\n<th style=\"text-align: left;\">Flink Engine</th>\n<th style=\"text-align: left;\">Spark Engine</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>定位</strong></td>\n<td style=\"text-align: left;\"><strong>数据同步专用</strong></td>\n<td style=\"text-align: left;\">通用流批计算</td>\n<td style=\"text-align: left;\">通用批流计算</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>适用场景</strong></td>\n<td style=\"text-align: left;\">海量数据集成、CDC 实时同步、多表整库同步</td>\n<td style=\"text-align: left;\">复杂流式计算 + 同步</td>\n<td style=\"text-align: left;\">大规模离线清洗、ETL</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>部署复杂度</strong></td>\n<td style=\"text-align: left;\"><strong>低</strong> (内置，开箱即用)</td>\n<td style=\"text-align: left;\">中 (需维护 Flink 集群)</td>\n<td style=\"text-align: left;\">中 (需维护 Spark 集群)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>资源消耗</strong></td>\n<td style=\"text-align: left;\"><strong>低</strong> (针对同步优化，无多余开销)</td>\n<td style=\"text-align: left;\">中/高</td>\n<td style=\"text-align: left;\">中/高</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>延迟</strong></td>\n<td style=\"text-align: left;\"><strong>低</strong> (实时流)</td>\n<td style=\"text-align: left;\">低 (实时流)</td>\n<td style=\"text-align: left;\">中 (微批)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>容错粒度</strong></td>\n<td style=\"text-align: left;\"><strong>Pipeline 级</strong> (局部重启)</td>\n<td style=\"text-align: left;\">Job 级 (全局重启)</td>\n<td style=\"text-align: left;\">Stage/Task 级</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>CDC 支持</strong></td>\n<td style=\"text-align: left;\"><strong>完美</strong> (支持 Schema Evolution)</td>\n<td style=\"text-align: left;\">良好</td>\n<td style=\"text-align: left;\">一般</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>多版本适配</strong></td>\n<td style=\"text-align: left;\">无需适配 (自带)</td>\n<td style=\"text-align: left;\">需严格匹配 Flink 版本</td>\n<td style=\"text-align: left;\">需严格匹配 Spark 版本</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"6-如何选择\">6. 如何选择？</h2>\n<ol>\n<li>\n<p><strong>如果你是新项目，或者主要需求是数据同步 (Data Integration)</strong>:</p>\n<ul>\n<li>👉 <strong>首选 Zeta 引擎</strong>。它最轻量、性能最好，且对 CDC 和多表同步有特殊优化。</li>\n</ul>\n</li>\n<li>\n<p><strong>如果你已经有现成的 Flink/Spark 集群，且运维团队不想维护新引擎</strong>:</p>\n<ul>\n<li>👉 选择 <strong>Flink</strong> 或 <strong>Spark</strong> 引擎，复用现有基础设施。</li>\n</ul>\n</li>\n<li>\n<p><strong>如果你的任务包含极其复杂的自定义计算逻辑 (Complex Computation)</strong>:</p>\n<ul>\n<li>👉 优先考虑 <strong>Flink</strong> (流) 或 <strong>Spark</strong> (批)，利用其丰富的算子生态。但也可以考虑 <strong>Zeta + SQL Transform</strong> 满足大部分需求。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"7-新手入门指南\">7. 新手入门指南</h2>\n<p>如果你是第一次接触 SeaTunnel，请按照以下步骤快速体验 Zeta 引擎的强大功能。</p>\n<h3 id=\"71-环境准备\">7.1 环境准备</h3>\n<p>确保你的机器上安装了 Java 8 或 Java 11。</p>\n<pre><code class=\"language-bash\">java -version\n</code></pre>\n<h3 id=\"72-下载与安装\">7.2 下载与安装</h3>\n<ol>\n<li><strong>下载</strong>: 从 <a href=\"https://seatunnel.apache.org/download\" rel=\"noopener nofollow\" target=\"_blank\">Apache SeaTunnel 官网</a> 下载最新版本的二进制包 (<code>apache-seatunnel-x.x.x-bin.tar.gz</code>)。</li>\n<li><strong>解压</strong>:<pre><code class=\"language-bash\">tar -zxvf apache-seatunnel-*.tar.gz\ncd apache-seatunnel-*\n</code></pre>\n</li>\n</ol>\n<h3 id=\"73-安装-connector-插件-重要\">7.3 安装 Connector 插件 (重要!)</h3>\n<p><strong>这是新手最容易忽略的一步</strong>。默认包不包含所有 Connector，你需要运行脚本自动下载。</p>\n<pre><code class=\"language-bash\"># 自动安装 plugin_config 配置文件中定义的所有插件\nsh bin/install-plugin.sh\n</code></pre>\n<h3 id=\"74-快速运行第一个任务\">7.4 快速运行第一个任务</h3>\n<p>创建一个简单的配置文件 <code>config/quick_start.conf</code>，将数据从 Fake 源生成并打印到控制台：</p>\n<pre><code class=\"language-hocon\">env {\n  execution.parallelism = 1\n  job.mode = \"BATCH\"\n}\n\nsource {\n  FakeSource {\n    result_table_name = \"fake\"\n    row.num = 100\n    schema = {\n      fields {\n        name = \"string\"\n        age = \"int\"\n      }\n    }\n  }\n}\n\ntransform {\n  # 简单的 SQL 处理\n  Sql {\n    source_table_name = \"fake\"\n    result_table_name = \"sql_result\"\n    query = \"select name, age from fake where age &gt; 50\"\n  }\n}\n\nsink {\n  Console {\n    source_table_name = \"sql_result\"\n  }\n}\n</code></pre>\n<p><strong>运行任务 (Local 模式)</strong>:</p>\n<pre><code class=\"language-bash\">./bin/seatunnel.sh --config ./config/quick_start.conf -e local\n</code></pre>\n<p>如果看到控制台输出了数据表格，恭喜你，你已经成功掌握了 SeaTunnel 的基本用法！</p>\n<h2 id=\"8-zeta-引擎原理深度学习路径\">8. Zeta 引擎原理深度学习路径</h2>\n<p>如果你希望深入了解 Zeta 引擎的内部运作机制，或者想参与社区贡献，可以按照以下路径进行源码阅读和调试。</p>\n<h3 id=\"81-核心模块概览\">8.1 核心模块概览</h3>\n<p>Zeta 引擎的代码主要集中在 <code>seatunnel-engine</code> 模块下：</p>\n<ul>\n<li><strong>seatunnel-engine-core</strong>: 定义了核心数据结构（如 <code>Job</code>, <code>Task</code>）和通信协议。</li>\n<li><strong>seatunnel-engine-server</strong>: 包含了 Coordinator 和 Worker 的具体实现逻辑。</li>\n<li><strong>seatunnel-engine-client</strong>: 客户端提交逻辑。</li>\n</ul>\n<h3 id=\"82-源码阅读推荐路径\">8.2 源码阅读推荐路径</h3>\n<h4 id=\"1-作业提交与解析-coordinator-侧\">1. 作业提交与解析 (Coordinator 侧)</h4>\n<p>从 <code>JobMaster</code> 类开始，了解作业是如何被接收和初始化的。</p>\n<ul>\n<li><strong>入口</strong>: <code>org.apache.seatunnel.engine.server.master.JobMaster</code></li>\n<li><strong>逻辑</strong>: 关注 <code>init</code> 和 <code>run</code> 方法，了解 <code>LogicalDag</code> 到 <code>PhysicalPlan</code> 的转换过程。</li>\n</ul>\n<h4 id=\"2-任务执行-worker-侧\">2. 任务执行 (Worker 侧)</h4>\n<p>了解 Task 是如何被调度和执行的。</p>\n<ul>\n<li><strong>服务入口</strong>: <a href=\"seatunnel-engine/seatunnel-engine-server/src/main/java/org/apache/seatunnel/engine/server/TaskExecutionService.java\" rel=\"noopener nofollow\" target=\"_blank\">TaskExecutionService.java</a>\n<ul>\n<li>该类负责管理 Worker 节点上的所有 TaskGroup。</li>\n</ul>\n</li>\n<li><strong>执行上下文</strong>: <code>org.apache.seatunnel.engine.server.execution.TaskExecutionContext</code></li>\n</ul>\n<h4 id=\"3-checkpoint-机制-核心难点\">3. Checkpoint 机制 (核心难点)</h4>\n<p>Zeta 的快照机制是保证数据一致性的关键。</p>\n<ul>\n<li><strong>协调器</strong>: <a href=\"seatunnel-engine/seatunnel-engine-server/src/main/java/org/apache/seatunnel/engine/server/checkpoint/CheckpointCoordinator.java\" rel=\"noopener nofollow\" target=\"_blank\">CheckpointCoordinator.java</a>\n<ul>\n<li>重点阅读 <code>triggerCheckpoint</code> 方法，了解 Barrier 是如何分发的。</li>\n</ul>\n</li>\n<li><strong>计划</strong>: <a href=\"seatunnel-engine/seatunnel-engine-server/src/main/java/org/apache/seatunnel/engine/server/checkpoint/CheckpointPlan.java\" rel=\"noopener nofollow\" target=\"_blank\">CheckpointPlan.java</a>\n<ul>\n<li>了解 Checkpoint 涉及的任务范围是如何计算的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"83-调试技巧\">8.3 调试技巧</h3>\n<ol>\n<li><strong>修改日志级别</strong>: 在 <code>config/log4j2.properties</code> 中，将 <code>org.apache.seatunnel</code> 的级别调整为 <code>DEBUG</code>，可以看到详细的 RPC 通信和状态变更日志。</li>\n<li><strong>本地调试</strong>: 在 IDE 中直接运行 <code>org.apache.seatunnel.core.starter.seatunnel.SeaTunnelStarter</code> 类，传入 <code>-c config/your_job.conf -e local</code> 参数，即可断点调试整个流程。</li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 16:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/seatunnel\">ApacheSeaTunnel</a>&nbsp;\n阅读(<span id=\"post_view_count\">70</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}