{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "iNeuOS工业互联网操作系统，实现能源管理及应用案例",
      "link": "https://www.cnblogs.com/lsjwq/p/19477890",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lsjwq/p/19477890\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 15:59\">\n    <span>iNeuOS工业互联网操作系统，实现能源管理及应用案例</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本次升级实现了iNeuOS工业互联网操作系统（该系统前端使用VUE3、后端接口使用NET6、关系数据库+时序数据库）从基础工具应用向业务管理应用（能源管理）的增值服务过度，同时可以依靠iNeuOS原有的基础工具扩展能源管理的业务功能。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"a\">目&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 录</p>\n<p>1..... 概述... 2</p>\n<p>2..... 应用过程... 3</p>\n<p>1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基础工厂模型配置... 3</p>\n<p>1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 能源数据采集... 4</p>\n<p>1.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 能源管理基础功能... 5</p>\n<p>1.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 视图建模（Web组态）扩展功能... 6</p>\n<p>1.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 报表设计（Excel）扩展功能... 8</p>\n<hr />\n<p>&nbsp;</p>\n<h1>1.&nbsp;&nbsp; 概述</h1>\n<p><span style=\"font-size: 16px;\">　　本次升级实现了<a href=\"http://www.ineuos.net/\" rel=\"noopener nofollow\">iNeuOS工业互联网操作系统</a>（该系统前端使用VUE3、后端接口使用NET6、关系数据库+时序数据库）从<strong>基础工具应用</strong>向<strong>业务管理应用（能源管理）</strong>的增值服务过渡，同时可以依靠iNeuOS原有的基础工具扩展能源管理的业务功能，例如以能源业务为核心，依靠视图建模（Web组态）、报表设计（Excel）、表单设计（开发页面）等工具开发的功能实现对能源管理业务的扩展应用。</span></p>\n<p><span style=\"font-size: 16px;\">　　这样方便易用的完成了能源管理的基本功能，大大降低了定制化开发的周期和成本。iNeuOS系统中能源管理功能如下图：</span></p>\n<p align=\"center\"><img alt=\"20\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155011774-630804371.jpg\" /></p>\n<p align=\"center\" style=\"text-align: left;\"><span style=\"font-size: 16px;\">　　业务功能框架如下图：</span></p>\n<p><img alt=\"111\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155046492-1750971088.png\" /></p>\n<h1>2.&nbsp;&nbsp; 应用过程</h1>\n<h2>1.1&nbsp;&nbsp;&nbsp; 基础工厂模型配置</h2>\n<p><span style=\"font-size: 16px;\">　　增加和配置工厂基本信息，并且增加该工厂的生产工序，规划工序粒度由精细化管理程序决定。如下图:</span></p>\n<p><span style=\"font-size: 16px;\"><img alt=\"21\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155136661-942199355.jpg\" /></span></p>\n<p><span style=\"font-size: 16px;\">&nbsp; &nbsp; &nbsp; &nbsp;配置该工厂班制，例如一天三班制管理，主要用于统计班组数据使用。如下图：</span></p>\n<p><img alt=\"22\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155151406-909202069.jpg\" /></p>\n<h2>1.2&nbsp;&nbsp;&nbsp; 能源数据采集</h2>\n<p><span style=\"font-size: 16px;\">　　在【设备模型】中增加采集数据的设备信息，配置刚才配置的工厂和工序信息，如下图：</span></p>\n<p><img alt=\"23\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155228094-466659407.jpg\" /></p>\n<p><span style=\"font-size: 16px;\">　　</span><span style=\"font-size: 16px;\">针对风、水、电、气及辅料等能源仪表进行实时数据采集，针对数据点可以配置具体的能源计量类型，通讯参数根据现场实现的网络环境配置，如下图：</span></p>\n<p><img alt=\"24\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155240048-1049057138.jpg\" /></p>\n<p><span style=\"font-size: 16px;\">&nbsp; &nbsp; &nbsp; &nbsp;采集能源数据配置好之后，后台服务会实时采集数据，同时也会实时统计班、日、月、年等能源数据，如下图：</span></p>\n<p><img alt=\"25\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155255211-578187026.jpg\" /></p>\n<h2>1.3&nbsp;&nbsp;&nbsp; 能源管理基础功能</h2>\n<p><span style=\"font-size: 16px;\">　　经过上面的配置，基本实现了能源管理的实时监测统计、能源查询等功能。能源实时监测，如下图：</span></p>\n<p><img alt=\"1\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155325102-716275777.jpg\" /></p>\n<p><span style=\"font-size: 16px;\">&nbsp; &nbsp; &nbsp; &nbsp;能源数据查询，如下图：</span></p>\n<p><img alt=\"2\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155338351-1412443122.jpg\" /></p>\n<h2>1.4&nbsp;&nbsp;&nbsp; 视图建模（Web组态）扩展功能</h2>\n<p><span style=\"font-size: 16px;\">　　工厂有很多车间或工序，同时也会有很多实时监测的业务功能，这时候可以使用【视图建模（Web组态）】构建不同的能源监测业务功能，监测业务功能开发，如下图：</span></p>\n<p><img alt=\"6\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155407091-1923487766.jpg\" /></p>\n<p><span style=\"font-size: 16px;\">　　</span><span style=\"font-size: 16px;\">保存该组态开发的能源监测功能后，分享这个功能，复制该功能的链接。在【菜单管理】中增加到能源管理业务模块中。如下图：</span></p>\n<p><img alt=\"7\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155419489-212980671.jpg\" /></p>\n<p><span style=\"font-size: 16px;\">　　在能源管理中打开组态监测功能，如下图：</span></p>\n<p><img alt=\"8\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155433002-226497884.jpg\" /></p>\n<h2>1.5&nbsp;&nbsp;&nbsp; 报表设计（Excel）扩展功能</h2>\n<p>　　使用【报表设计（Excel）】开发报表业务功能，例如班报表、日报表、月报表、年报表等。实现一个班报表，如下图：</p>\n<p><img alt=\"9\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155501161-111594825.jpg\" /></p>\n<p>　　使用报表设计开发的报表功能，分享这个功能，复制该功能的链接。在【菜单管理】中增加到能源管理业务模块中。如下图：</p>\n<p><img alt=\"10\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155519792-1620019825.jpg\" /></p>\n<p>　　在能源管理中打开该报表功能，查询每天班的能源数据使用情况，如下图：</p>\n<p><img alt=\"11\" src=\"https://img2024.cnblogs.com/blog/279374/202601/279374-20260113155529621-1294135955.jpg\" /></p>\n<hr />\n<p>物联网&amp;大数据技术 QQ群：54256083</p>\n<p>物联网&amp;大数据项目 QQ群：727664080</p>\n<p>QQ：504547114</p>\n<p>微信：wxzz0151</p>\n<p>博客：https://www.cnblogs.com/lsjwq</p>\n<p><img alt=\"image\" class=\"lazyloaded medium-zoom-image\" height=\"96\" src=\"https://img2024.cnblogs.com/blog/279374/202509/279374-20250924180005285-1427975355.png\" width=\"193\" /></p>\n<hr />\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 15:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lsjwq\">iNeuOS工业互联网系统</a>&nbsp;\n阅读(<span id=\"post_view_count\">11</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "罗凯的星际光影图腾X的诞生",
      "link": "https://www.cnblogs.com/lixingqiu/p/19477584",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lixingqiu/p/19477584\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 15:05\">\n    <span>罗凯的星际光影图腾X的诞生</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>这一天，为了寻找灵感，罗凯 (rocket) 闪现到了风吹草低现牛羊的大草原。他在 \"万象大模型\" 的帮助下，正在展开无穷的想像力.....</p>\n<p>突然，罗凯想，用 10 行以内 C++ 代码能画出什么即简单又惊艳的图案？&nbsp;</p>\n<div>晓凯(罗凯的昵称)席地而坐，指尖轻轻敲击着随身携带的便携编程终端，脑海里满是浩瀚太空的星河与星云。作为痴迷于太空遨游和高科技创作的少年，他总爱把太空里的见闻转化为C++ 代码作品，而今天，他想做一个能代表星际导航的极简标识。&nbsp;</div>\n<div>&nbsp;</div>\n<div>“既然默认角色是小火箭，那我就以自己的名字‘rocket’来定义这个绘图角色吧。” 晓凯笑着敲下<code>Sprite rocket;</code>，给这个虚拟角色赋予了和自己一样的 “灵魂”。他首先想到了太空的深邃，于是用<code>rocket.bgcolor(\"black\")</code>将画布调成了宇宙般的纯黑背景，又把画笔粗细设为 50，<code>pensize(50)</code>能让绘制的图案更醒目，就像太空中的巨型导航灯塔，再将绘图速度调至 0，只为精准控制每一笔的轨迹。</div>\n<div>&nbsp;</div>\n<div>为了画出对称又有仪式感的图案，晓凯把画笔的色相调为0，即红色，然后 rocket 角色左转 45 度，抬笔后退 200 步找准起始位置，再落笔准备绘制。</div>\n<div>\n<div class=\"cnblogs_code\">\n<pre>rocket.pencolor(<span style=\"color: rgba(128, 0, 128, 1);\">0</span>).lt(<span style=\"color: rgba(128, 0, 128, 1);\">45</span>).pu().bk(<span style=\"color: rgba(128, 0, 128, 1);\">200</span>).pd();</pre>\n</div>\n<p>“接下来，该给这个图案加上太空星光的渐变质感了。” 晓凯眼睛一亮，写下了第一个循环，用<code>penshade(i)</code>让画笔颜色随着循环逐帧变深，就像恒星从微光到璀璨的燃烧过程，每前进 1 步就延时 0.01 秒，<code>wait(0.01)</code>能让渐变效果更细腻，肉眼清晰可见光影的流转，这是他从太空观测中得到的灵感 —— 宇宙中的光影变化，从来都不是一蹴而就的。&nbsp;</p>\n</div>\n<div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">for</span>(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i=<span style=\"color: rgba(128, 0, 128, 1);\">0</span>;i&lt;<span style=\"color: rgba(128, 0, 128, 1);\">400</span>;i++<span style=\"color: rgba(0, 0, 0, 1);\">)\n     </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">设定画笔颜色的深浅度</span>\n     rocket.penshade(i).fd(<span style=\"color: rgba(128, 0, 128, 1);\">1</span>).wait(<span style=\"color: rgba(128, 0, 128, 1);\">0.01</span>);</pre>\n</div>\n<p>第一道光轨绘制完成，像一道穿透黑暗的星际射线。晓凯没有停下，他让角色抬笔后退复位，左转 90 度再后退 200 步，找准了另一道轨线的起始点，又写下了一段一模一样的循环。这一次，画笔依旧随着循环渐变明暗，就像太空中另一道对应的导航射线，与第一道形成完美的十字夹角，像极了他曾经在模拟太空遨游时看到的星际坐标标记。</p>\n</div>\n<div>&nbsp;看着屏幕上，纯黑背景中两道渐变光轨慢慢成型，从微光到深韵，细腻又惊艳，晓凯的脸上露出了满意的笑容。他最后写下<code>rocket.hide().done();</code>，让绘图角色隐藏，定格住这副完美的星际光影图腾。&nbsp;“这不仅仅是一幅代码图案，更是我未来太空遨游的导航标记啊。” 晓凯喃喃自语。这幅用几行简单C++ 代码完成的作品，借助 C++ 精灵库的便捷指令，把他对太空的热爱、对高科技的痴迷，都融进了这两道渐变光轨里。</div>\n<div>&nbsp;</div>\n<div>&nbsp;后来，这幅极简又惊艳的图案被晓凯做成了自己太空遨游模拟程序的启动界面，每当他打开程序，看到这道十字光影，就会想起大草原上那个突发奇想的午后。而这也让他更加坚信，用 C++ 代码不仅能打造有趣的作品，更能把自己遨游太空的梦想，一点点变成触手可及的 “高科技现实”。接下来，他又开始构思，能不能给这个光影图腾加上动态闪烁效果，让它更像太空中真正的导航灯塔呢？</div>\n<div>&nbsp;</div>\n<div><strong>罗凯的星际光影图腾X</strong>的诞生了，所有代码如下所示：</div>\n<div>\n<div class=\"cnblogs_code\">\n<pre>#include <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">sprites.h</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">包含C++精灵库 </span>\nSprite rocket;       <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">建立角色叫rocket </span>\n\n<span style=\"color: rgba(0, 0, 255, 1);\">int</span> main(){        <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">主功能块 </span>\n   rocket.bgcolor(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">black</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).speed(<span style=\"color: rgba(128, 0, 128, 1);\">0</span>).pensize(<span style=\"color: rgba(128, 0, 128, 1);\">50</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n   rocket.pencolor(</span><span style=\"color: rgba(128, 0, 128, 1);\">0</span>).lt(<span style=\"color: rgba(128, 0, 128, 1);\">45</span>).pu().bk(<span style=\"color: rgba(128, 0, 128, 1);\">200</span><span style=\"color: rgba(0, 0, 0, 1);\">).pd();\n   </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span>(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i=<span style=\"color: rgba(128, 0, 128, 1);\">0</span>;i&lt;<span style=\"color: rgba(128, 0, 128, 1);\">400</span>;i++<span style=\"color: rgba(0, 0, 0, 1);\">)\n     </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">设定画笔颜色的深浅度</span>\n     rocket.penshade(i).fd(<span style=\"color: rgba(128, 0, 128, 1);\">1</span>).wait(<span style=\"color: rgba(128, 0, 128, 1);\">0.01</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n   rocket.pu().bk(</span><span style=\"color: rgba(128, 0, 128, 1);\">200</span>).lt(<span style=\"color: rgba(128, 0, 128, 1);\">90</span>).bk(<span style=\"color: rgba(128, 0, 128, 1);\">200</span><span style=\"color: rgba(0, 0, 0, 1);\">).pd();\n   \n   </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span>(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i=<span style=\"color: rgba(128, 0, 128, 1);\">0</span>;i&lt;<span style=\"color: rgba(128, 0, 128, 1);\">400</span>;i++<span style=\"color: rgba(0, 0, 0, 1);\">)\n     </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">设定画笔颜色的深浅度</span>\n     rocket.penshade(i).fd(<span style=\"color: rgba(128, 0, 128, 1);\">1</span>).wait(<span style=\"color: rgba(128, 0, 128, 1);\">0.01</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n   \n   rocket.hide().done();  \n   </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n}</span></pre>\n</div>\n<p><img alt=\"bandicam 2026-01-12 21-29-28-601.mp4_20260113_114239.036\" class=\"lazyload\" /></p>\n<p>视频已录，请看官们轻移步到本人抖音pxcoding去找找。</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-13 15:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lixingqiu\">李兴球</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "vue使用h函数封装dialog组件，以命令的形式使用dialog组件",
      "link": "https://www.cnblogs.com/IwishIcould/p/19147850",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/IwishIcould/p/19147850\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 09:10\">\n    <span>vue使用h函数封装dialog组件，以命令的形式使用dialog组件</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"场景\">场景</h4>\n<p>有些时候我们的页面是有很多的弹窗<br />\n如果我们把这些弹窗都写html中会有一大坨<br />\n因此：我们需要把弹窗封装成命令式的形式</p>\n<h4 id=\"命令式弹窗\">命令式弹窗</h4>\n<pre><code>// 使用弹窗的组件\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-button @click=\"openMask\"&gt;点击弹窗&lt;/el-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport childTest from '@/components/childTest.vue'\nimport { renderDialog } from '@/hooks/dialog'\nfunction openMask(){\n  // 第1个参数：表示的是组件，你写弹窗中的组件\n  // 第2个参数：表示的组件属性，比如：确认按钮的名称等\n  // 第3个参数：表示的模态框的属性。比如：模态宽的宽度，标题名称，是否可移动\n  renderDialog(childTest,{},{title:'测试弹窗'})\n}\n&lt;/script&gt;\n</code></pre>\n<pre><code>// 封装的弹窗\nimport { createApp, h } from \"vue\";\nimport { ElDialog } from \"element-plus\";\nexport function renderDialog(component:any,props:any, modalProps:any){\n const dialog  = h(\n    ElDialog,   // 模态框组件\n    {\n      ...modalProps, // 模态框属性\n      modelValue:true, // 模态框是否显示\n    }, // 因为是模态框组件，肯定是模态框的属性\n    {\n      default:()=&gt;h(component, props ) // 插槽，el-dialog下的内容\n    }\n  )\n console.log(dialog)\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<pre><code>//childTest.vue 组件\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;span&gt;It's a modal Dialog&lt;/span&gt;\n    &lt;el-form :model=\"form\" label-width=\"auto\" style=\"max-width: 600px\"&gt;\n    &lt;el-form-item label=\"Activity name\"&gt;\n      &lt;el-input v-model=\"form.name\" /&gt;\n    &lt;/el-form-item&gt;\n    &lt;el-form-item label=\"Activity zone\"&gt;\n      &lt;el-select v-model=\"form.region\" placeholder=\"please select your zone\"&gt;\n        &lt;el-option label=\"Zone one\" value=\"shanghai\" /&gt;\n        &lt;el-option label=\"Zone two\" value=\"beijing\" /&gt;\n      &lt;/el-select&gt;\n    &lt;/el-form-item&gt;\n  &lt;/el-form&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport { ref,reactive } from 'vue'\nconst dialogVisible = ref(true)\nconst form = reactive({\n  name: '',\n  region: '',\n})\nconst onSubmit = () =&gt; {\n  console.log('submit!')\n}\n&lt;/script&gt;\n</code></pre>\n<p><img alt=\"01\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017145322240-379014905.png\" /></p>\n<h4 id=\"为啥弹窗中的表单不能够正常展示呢\">为啥弹窗中的表单不能够正常展示呢？</h4>\n<p>在控制台会有下面的提示信息：<br />\nFailed to resolve component:<br />\nel-form If this is a native custom element,<br />\nmake sure to exclude it from component resolution via compilerOptions.isCustomElement<br />\n翻译过来就是<br />\n无法解析组件：el-form如果这是一个原生自定义元素，<br />\n请确保通过 compilerOptions.isCustomElement 将其从组件解析中排除</p>\n<p><img alt=\"02\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017145524776-326631892.png\" /></p>\n<p>其实就是说：我重新创建了一个新的app,这个app中没有注册组件。<br />\n因此会警告，页面渲染不出来。</p>\n<pre><code>// 我重新创建了一个app，这个app中没有注册 element-plus 组件。\nconst app = createApp(dialog)\n</code></pre>\n<p>现在我们重新注册element-plus组件。<br />\n准确的说：我们要注册 childTest.vue 组件使用到的东西</p>\n<h4 id=\"给新创建的app应用注册childtest组件使用到的东西\">给新创建的app应用注册childTest组件使用到的东西</h4>\n<p>我们将会在这个命令式弹窗中重新注册需要使用到的组件</p>\n<pre><code>// 封装的弹窗\nimport { createApp, h } from \"vue\";\nimport { ElDialog } from \"element-plus\";\n// 引入组件和样式\nimport ElementPlus from \"element-plus\";\n// import \"element-plus/dist/index.css\";\nexport function renderDialog(component:any,props:any, modalProps:any){\n const dialog  = h(\n    ElDialog,   // 模态框组件\n    {\n      ...modalProps, // 模态框属性\n      modelValue:true, // 模态框显示\n    }, // 因为是模态框组件，肯定是模态框的属性\n    {\n      default:()=&gt;h(component, props ) // 插槽，el-dialog下的内容\n    }\n  )\n console.log(dialog)\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<p><img alt=\"03\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017150030012-288792935.png\" /></p>\n<p>现在我们发现可以正常展示弹窗中的表单了。因为我们注册了element-plus组件。<br />\n但是我们发现又发现了另外一个问题。<br />\n弹窗底部没有取消和确认按钮。<br />\n需要我们再次通过h函数来创建</p>\n<h4 id=\"关于使用createapp创建新的应用实例\">关于使用createApp创建新的应用实例</h4>\n<p>在Vue 3中，我们可以使用 createApp 来创建新的应用实例<br />\n但是这样会创建一个完全独立的应用<br />\n它不会共享主应用的组件、插件等。<br />\n因此我们需要重新注册</p>\n<h4 id=\"弹窗底部新增取消和确认按钮\">弹窗底部新增取消和确认按钮</h4>\n<p>我们将会使用h函数中的插槽来创建底部的取消按钮</p>\n<pre><code>// 封装的弹窗\nimport { createApp, h } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any) {\n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n    },\n    {\n      // 主要内容插槽\n      default: () =&gt; h(component, props),\n      // 底部插槽\n      footer:() =&gt;h(\n        'div',\n        { class: 'dialog-footer' },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('取消')\n              }\n            },\n            () =&gt; '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              onClick: () =&gt; {\n                console.log('确定')\n              }\n            },\n            () =&gt; '确定'\n          )\n        ]\n      )\n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<p><img alt=\"04\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017150758182-172077623.png\" /></p>\n<h4 id=\"点击关闭弹窗时需要移除之前创建的div\">点击关闭弹窗时，需要移除之前创建的div</h4>\n<p>卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div。<br />\n2个地方需要移除：1,点击确认按钮。 2,点击其他地方的关闭<br />\n<img alt=\"05\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017150936490-1107995889.png\" /></p>\n<h4 id=\"关闭弹窗正确销毁相关组件\">关闭弹窗正确销毁相关组件</h4>\n<pre><code>// 封装的弹窗\nimport { createApp, h } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any) {\n  console.log('111')\n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n      onClose: ()=&gt; {\n        console.log('关闭的回调')\n        app.unmount() // 这样卸载会让动画消失\n        // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n        document.body.removeChild(div)\n      }\n    },\n    {\n      // 主要内容插槽\n      default: () =&gt; h(component, props),\n      // 底部插槽\n      footer:() =&gt;h(\n        'div',\n        { \n          class: 'dialog-footer',\n         \n        },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('点击取消按钮')\n                // 卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n                app.unmount() // 这样卸载会让动画消失\n                // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n                document.body.removeChild(div)\n              }\n            },\n            () =&gt; '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              onClick: () =&gt; {\n                console.log('确定')\n              }\n            },\n            () =&gt; '确定'\n          )\n        ]\n      )\n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  // 这个div元素在在销毁应用时需要被移除哈\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<p><img alt=\"06\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017151046536-220748441.png\" /></p>\n<h4 id=\"点击确认按钮时验证规则\">点击确认按钮时验证规则</h4>\n<p>有些时候，我们弹窗中的表单是需要进行规则校验的。<br />\n我们下面来实现这个功能点<br />\n传递的组件</p>\n<pre><code>&lt;template&gt;\n  &lt;el-form\n    ref=\"ruleFormRef\"\n    style=\"max-width: 600px\"\n    :model=\"ruleForm\"\n    :rules=\"rules\"\n    label-width=\"auto\"\n  &gt;\n    &lt;el-form-item label=\"Activity name\" prop=\"name\"&gt;\n      &lt;el-input v-model=\"ruleForm.name\" /&gt;\n    &lt;/el-form-item&gt;\n    &lt;el-form-item label=\"Activity zone\" prop=\"region\"&gt;\n      &lt;el-select v-model=\"ruleForm.region\" placeholder=\"Activity zone\"&gt;\n        &lt;el-option label=\"Zone one\" value=\"shanghai\" /&gt;\n        &lt;el-option label=\"Zone two\" value=\"beijing\" /&gt;\n      &lt;/el-select&gt;\n    &lt;/el-form-item&gt;\n    \n    &lt;el-form-item label=\"Activity time\" required&gt;\n      &lt;el-col :span=\"11\"&gt;\n        &lt;el-form-item prop=\"date1\"&gt;\n          &lt;el-date-picker\n            v-model=\"ruleForm.date1\"\n            type=\"date\"\n            aria-label=\"Pick a date\"\n            placeholder=\"Pick a date\"\n            style=\"width: 100%\"\n          /&gt;\n        &lt;/el-form-item&gt;\n      &lt;/el-col&gt;\n      &lt;el-col class=\"text-center\" :span=\"2\"&gt;\n        &lt;span class=\"text-gray-500\"&gt;-&lt;/span&gt;\n      &lt;/el-col&gt;\n      &lt;el-col :span=\"11\"&gt;\n        &lt;el-form-item prop=\"date2\"&gt;\n          &lt;el-time-picker\n            v-model=\"ruleForm.date2\"\n            aria-label=\"Pick a time\"\n            placeholder=\"Pick a time\"\n            style=\"width: 100%\"\n          /&gt;\n        &lt;/el-form-item&gt;\n      &lt;/el-col&gt;\n    &lt;/el-form-item&gt;\n\n    &lt;el-form-item label=\"Resources\" prop=\"resource\"&gt;\n      &lt;el-radio-group v-model=\"ruleForm.resource\"&gt;\n        &lt;el-radio value=\"Sponsorship\"&gt;Sponsorship&lt;/el-radio&gt;\n        &lt;el-radio value=\"Venue\"&gt;Venue&lt;/el-radio&gt;\n      &lt;/el-radio-group&gt;\n    &lt;/el-form-item&gt;\n    &lt;el-form-item label=\"Activity form\" prop=\"desc\"&gt;\n      &lt;el-input v-model=\"ruleForm.desc\" type=\"textarea\" /&gt;\n    &lt;/el-form-item&gt;\n\n  &lt;/el-form&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\" setup&gt;\nimport { reactive, ref } from 'vue'\n\nimport type { FormInstance, FormRules } from 'element-plus'\n\ninterface RuleForm {\n  name: string\n  region: string\n  date1: string\n  date2: string\n  resource: string\n  desc: string\n}\nconst ruleFormRef = ref&lt;FormInstance&gt;()\nconst ruleForm = reactive&lt;RuleForm&gt;({\n  name: 'Hello',\n  region: '',\n  date1: '',\n  date2: '',\n  resource: '',\n  desc: '',\n})\nconst rules = reactive&lt;FormRules&lt;RuleForm&gt;&gt;({\n  name: [\n    { required: true, message: 'Please input Activity name', trigger: 'blur' },\n    { min: 3, max: 5, message: 'Length should be 3 to 5', trigger: 'blur' },\n  ],\n  region: [\n    {\n      required: true,\n      message: 'Please select Activity zone',\n      trigger: 'change',\n    },\n  ],\n  date1: [\n    {\n      type: 'date',\n      required: true,\n      message: 'Please pick a date',\n      trigger: 'change',\n    },\n  ],\n  date2: [\n    {\n      type: 'date',\n      required: true,\n      message: 'Please pick a time',\n      trigger: 'change',\n    },\n  ],\n  resource: [\n    {\n      required: true,\n      message: 'Please select activity resource',\n      trigger: 'change',\n    },\n  ],\n  desc: [\n    { required: true, message: 'Please input activity form', trigger: 'blur' },\n  ],\n})\n\nconst submitForm = async () =&gt; {\n  if (!ruleFormRef.value) {\n    console.error('ruleFormRef is not initialized')\n    return false\n  }\n  try {\n    const valid = await ruleFormRef.value.validate()\n    if (valid) {\n      console.log('表单校验通过', ruleForm)\n      return Promise.resolve(ruleForm)\n    }\n  } catch (error) {\n    // 为啥submitForm中，valid的值是false会执行catch ？\n    // el-form 组件的 validate 方法的工作机制导致的。 validate 方法在表单验证失败时会抛出异常\n    console.error('err', error)\n    return false\n    /**\n     * 下面这样写为啥界面会报错呢？\n     * return Promise.reject(error)\n     * 当表单验证失败时，ruleFormRef.value.validate() 会抛出一个异常。\n     * 虽然你用了 try...catch 捕获这个异常，并且在 catch 块中通过 return Promise.reject(error) 返回了一个被拒绝的 Promise\n     * 但如果调用 submitForm 的地方没有正确地处理这个被拒绝的 Promise（即没有使用 .catch() 或者 await 来接收错误），\n     * 那么浏览器控制台就会显示一个 \"Uncaught (in promise)\" 错误。\n     * 在 catch 中再次 return Promise.reject(error) 是多余的， 直接return false\n     * */ \n    /**\n     * 如果你这样写\n     * throw error 直接抛出错误即可\n     * 那么就需要再调用submitForm的地方捕获异常\n     * */  \n  }\n}\n\ndefineExpose({\n  submitForm:submitForm\n})\n&lt;/script&gt;\n</code></pre>\n<pre><code>// 封装的弹窗\nimport { createApp, h, ref } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any) {\n  const instanceElement = ref()\n  console.log('111', instanceElement) \n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n      onClose: ()=&gt; {\n        console.log('关闭的回调')\n        app.unmount() // 这样卸载会让动画消失\n        // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n        document.body.removeChild(div)\n      }\n    },\n    {\n      // 主要内容插槽,这里的ref必须接收一个ref\n      default: () =&gt; h(component, {...props, ref: instanceElement}),\n      // 底部插槽\n      footer:() =&gt;h(\n        'div',\n        { \n          class: 'dialog-footer',\n         \n        },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('点击取消按钮')\n                // 卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n                app.unmount() // 这样卸载会让动画消失\n                // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n                document.body.removeChild(div)\n              }\n            },\n            () =&gt; '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              onClick: () =&gt; {\n                instanceElement?.value?.submitForm().then((res:any) =&gt;{\n                  console.log('得到的值',res)\n                })\n                console.log('确定')\n              }\n            },\n            () =&gt; '确定'\n          )\n        ]\n      )\n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  // 这个div元素在在销毁应用时需要被移除哈\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<p><img alt=\"07\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017153103678-1920669946.png\" /><br />\n关键的点：通过ref拿到childTest组件中的方法，childTest要暴露需要的方法</p>\n<h4 id=\"如何把表单中的数据暴露出去\">如何把表单中的数据暴露出去</h4>\n<p>可以通过回调函数的方式把数据暴露出去哈。</p>\n<pre><code>// 封装的弹窗\nimport { createApp, h, ref } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any, onConfirm: (data: any) =&gt; any ) {\n  // 第4个参数是回调函数\n  const instanceElement = ref()\n  console.log('111', instanceElement) \n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n      onClose: ()=&gt; {\n        console.log('关闭的回调')\n        app.unmount() // 这样卸载会让动画消失\n        // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n        document.body.removeChild(div)\n      }\n    },\n    {\n      // 主要内容插槽,这里的ref必须接收一个ref\n      default: () =&gt; h(component, {...props, ref: instanceElement}),\n      // 底部插槽\n      footer:() =&gt;h(\n        'div',\n        { \n          class: 'dialog-footer',\n         \n        },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('点击取消按钮')\n                // 卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n                app.unmount() // 这样卸载会让动画消失\n                // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n                document.body.removeChild(div)\n              }\n            },\n            () =&gt; '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              onClick: () =&gt; {\n                // submitForm 调用表单组件中需要验证或者暴露出去的数据\n                instanceElement?.value?.submitForm().then((res:any) =&gt;{\n                  console.log('得到的值',res)\n                  // 验证通过后调用回调函数传递数据， 如验证失败，res 的值有可能是一个false。\n                  onConfirm(res)\n                  // 怎么把这个事件传递出去，让使用的时候知道点击了确认并且知道验证通过了\n                }).catch((error: any) =&gt; {\n                  // 验证失败时也可以传递错误信息\n                  console.log('验证失败', error)\n                })\n                console.log('确定')\n              }\n            },\n            () =&gt; '确定'\n          )\n        ]\n      )\n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  // 这个div元素在在销毁应用时需要被移除哈\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-button @click=\"openMask\"&gt;点击弹窗&lt;/el-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport childTest from '@/components/childTest.vue'\nimport { renderDialog } from '@/hooks/dialog'\nimport { getCurrentInstance } from 'vue';\nconst currentInstance = getCurrentInstance();\nfunction openMask(){\n  console.log('currentInstance',currentInstance)\n  renderDialog(childTest,{},{title:'测试弹窗', width: '700'}, (res)=&gt;{\n    console.log('通过回调函数返回值', res)\n  })\n}\n&lt;/script&gt;\n</code></pre>\n<p><img alt=\"08\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017153517135-614116266.png\" /></p>\n<h4 id=\"点击确定时业务完成后关闭弹窗\">点击确定时，业务完成后关闭弹窗</h4>\n<p>现在想要点击确定，等业务处理完成之后，才关闭弹窗。<br />\n需要在使用完成业务的时候返回一个promise，让封装的弹窗调用这个promise<br />\n这样就可以知道什么时候关闭弹窗了</p>\n<pre><code>// 封装的弹窗\nimport { createApp, h, ref } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any, onConfirm: (data: any) =&gt; any ) {\n  // 第4个参数是回调函数\n  const instanceElement = ref()\n  console.log('111', instanceElement) \n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n      onClose: ()=&gt; {\n        console.log('关闭的回调')\n        app.unmount() // 这样卸载会让动画消失\n        // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n        document.body.removeChild(div)\n      }\n    },\n    {\n      // 主要内容插槽,这里的ref必须接收一个ref\n      default: () =&gt; h(component, {...props, ref: instanceElement}),\n      // 底部插槽\n      footer:() =&gt;h(\n        'div',\n        { \n          class: 'dialog-footer',\n         \n        },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('点击取消按钮')\n                // 卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n                app.unmount() // 这样卸载会让动画消失\n                // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n                document.body.removeChild(div)\n              }\n            },\n            () =&gt; '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              onClick: () =&gt; {\n                // submitForm 调用表单组件中需要验证或者暴露出去的数据\n                instanceElement?.value?.submitForm().then((res:any) =&gt;{\n                  console.log('得到的值',res)\n                  // 验证通过后调用回调函数传递数据，如验证失败，res 的值有可能是一个false。\n                  const callbackResult = onConfirm(res);\n                  // 如果回调函数返回的是 Promise，则等待业务完成后再关闭弹窗\n                  if (callbackResult instanceof Promise) {\n                    // 注意这里的finally，这样写在服务出现异常的时候会有问题,这里是有问题的，需要优化\n                    // 注意这里的finally，这样写在服务出现异常的时候会有问题,这里是有问题的，需要优化\n                    callbackResult.finally(() =&gt; { \n                      // 弹窗关闭逻辑\n                      app.unmount()\n                      document.body.removeChild(div)\n                    });\n                  } else {\n                    // 如果不是 Promise，立即关闭弹窗\n                    app.unmount()\n                    document.body.removeChild(div)\n                  }\n                }).catch((error: any) =&gt; {\n                  // 验证失败时也可以传递错误信息\n                  console.log('验证失败', error)\n                })\n              }\n            },\n            () =&gt; '确定'\n          )\n        ]\n      )\n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  // 这个div元素在在销毁应用时需要被移除哈\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-button @click=\"openMask\"&gt;点击弹窗&lt;/el-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport childTest from '@/components/childTest.vue'\nimport { renderDialog } from '@/hooks/dialog'\nimport { getCurrentInstance } from 'vue';\nconst currentInstance = getCurrentInstance();\nfunction openMask(){\n  console.log('currentInstance',currentInstance)\n  renderDialog(childTest,{},{title:'测试弹窗', width: '700'}, (res)=&gt;{\n    console.log('通过回调函数返回值', res)\n    // 这里返回一个promise对象，这样就可以让业务完成后才关闭弹窗\n    return fetch(\"https://dog.ceo/api/breed/pembroke/images/random\")\n     .then((res) =&gt; {\n       return res.json();\n     })\n     .then((res) =&gt; {\n        console.log('获取的图片地址为：', res.message);\n     });\n  })\n}\n&lt;/script&gt;\n</code></pre>\n<p><img alt=\"09\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017153933776-969209851.png\" /></p>\n<h4 id=\"优化业务组件\">优化业务组件</h4>\n<pre><code>// 封装的弹窗\nimport { createApp, h, ref } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any, onConfirm: (data: any) =&gt; any ) {\n  // 关闭弹窗，避免重复代码\n  const closeDialog = () =&gt; {\n    // 成功时关闭弹窗\n    app.unmount();\n    // 检查div是否仍然存在且为body的子元素,否者可能出现异常\n    if (div &amp;&amp; div.parentNode) {\n      document.body.removeChild(div)\n    }\n  }\n  // 第4个参数是回调函数\n  const instanceElement = ref()\n  console.log('111', instanceElement) \n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n      onClose: ()=&gt; {\n        console.log('关闭的回调')\n        app.unmount() // 这样卸载会让动画消失\n        // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n        document.body.removeChild(div)\n      }\n    },\n    {\n      // 主要内容插槽,这里的ref必须接收一个ref\n      default: () =&gt; h(component, {...props, ref: instanceElement}),\n      // 底部插槽\n      footer:() =&gt;h(\n        'div',\n        { \n          class: 'dialog-footer',\n         \n        },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('点击取消按钮')\n                // 卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n                app.unmount() // 这样卸载会让动画消失\n                // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n                document.body.removeChild(div)\n              }\n            },\n            () =&gt; '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              onClick: () =&gt; {\n                // submitForm 调用表单组件中需要验证或者暴露出去的数据\n                instanceElement?.value?.submitForm().then((res:any) =&gt;{\n                  console.log('得到的值',res)\n                  // 验证通过后调用回调函数传递数据，如验证失败，res 的值有可能是一个false。\n                  const callbackResult = onConfirm(res);\n                  // 如果回调函数返回的是 Promise，则等待业务完成后再关闭弹窗\n                  if (callbackResult instanceof Promise) {\n                   \n                     callbackResult.then(() =&gt; {\n                      if(res){\n                        console.log('111')\n                        closeDialog()\n                      }\n                    }).catch(error=&gt;{\n                      console.log('222')\n                      console.error('回调函数执行出错,如:网络错误', error);\n                      // 错误情况下也关闭弹窗\n                      closeDialog()\n                    });\n                  } else {\n                    // 如果不是 Promise，并且验证时通过了的。立即关闭弹窗\n                    console.log('333', res)\n                    if(res){\n                      closeDialog()\n                    }\n                  }\n                }).catch((error: any) =&gt; {\n                  console.log('44444')\n                  // 验证失败时也可以传递错误信息\n                  console.log('验证失败', error)\n                })\n              }\n            },\n            () =&gt; '确定'\n          )\n        ]\n      )\n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  // 这个div元素在在销毁应用时需要被移除哈\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-button @click=\"openMask\"&gt;点击弹窗&lt;/el-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup lang=\"ts\"&gt;\nimport childTest from '@/components/childTest.vue'\nimport { renderDialog } from '@/hooks/dialog'\nimport { getCurrentInstance } from 'vue';\nconst currentInstance = getCurrentInstance();\nfunction openMask(){\n  console.log('currentInstance',currentInstance)\n  renderDialog(childTest,{},{title:'测试弹窗', width: '700'}, (res)=&gt;{\n    console.log('通过回调函数返回值', res)\n      // 这里返回一个promise对象，这样就可以让业务完成后才关闭弹窗\n      return fetch(\"https://dog.ceo/api/breed/pembroke/images/random\")\n      .then((res) =&gt; {\n        return res.json();\n      })\n      .then((res) =&gt; {\n          console.log('获取的图片地址为：', res.message);\n      });\n  })\n}\n&lt;/script&gt;\n</code></pre>\n<p>眼尖的小伙伴可能已经发现了这一段代码。<br />\n1，验证不通过会也会触发卸载弹窗<br />\n2，callbackResult.finally是不合适的<br />\n3.<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017160228378-793571991.png\" /></p>\n<p><img alt=\"10\" src=\"https://img2024.cnblogs.com/blog/1425695/202510/1425695-20251017154924223-2023334538.png\" /></p>\n<h4 id=\"最终的代码\">最终的代码</h4>\n<pre><code>// 封装的弹窗\nimport { createApp, h, ref } from \"vue\";\nimport { ElDialog, ElButton, ElForm, ElFormItem, ElInput, ElSelect, ElOption } from \"element-plus\";\nimport ElementPlus from \"element-plus\";\n\nexport function renderDialog(component: any, props: any, modalProps: any, onConfirm: (data: any) =&gt; any ) {\n  // 关闭弹窗，避免重复代码\n  const closeDialog = () =&gt; {\n    // 成功时关闭弹窗\n    app.unmount();\n    // 检查div是否仍然存在且为body的子元素,否者可能出现异常\n    if (div &amp;&amp; div.parentNode) {\n      document.body.removeChild(div)\n    }\n  }\n  // 第4个参数是回调函数\n  const instanceElement = ref()\n  console.log('111', instanceElement) \n  const isLoading = ref(false)\n  // 创建弹窗实例\n  const dialog = h(\n    ElDialog,\n    {\n      ...modalProps,\n      modelValue: true,\n      onClose: ()=&gt; {\n        isLoading.value = false\n        console.log('关闭的回调')\n        app.unmount() // 这样卸载会让动画消失\n        // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n        document.body.removeChild(div)\n      }\n    },\n    {\n      // 主要内容插槽,这里的ref必须接收一个ref\n      default: () =&gt; h(component, {...props, ref: instanceElement}),\n      // 底部插槽,noShowFooterBool是true,不显示； false的显示底部 \n      footer: props.noShowFooterBool ? null : () =&gt;h(\n        'div',\n        { \n          class: 'dialog-footer',\n        },\n        [\n          h(\n            ElButton, \n            {\n              onClick: () =&gt; {\n                console.log('点击取消按钮')\n                // 卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n                app.unmount() // 这样卸载会让动画消失\n                // 卸载的同时需要把我们创建的div元素移除，否则页面上会出现很多div\n                document.body.removeChild(div)\n              }\n            },\n            () =&gt; props.cancelText || '取消'\n          ),\n          h(\n            ElButton,\n            { \n              type: 'primary',\n              loading: isLoading.value,\n              onClick: () =&gt; {\n                isLoading.value = true\n                // submitForm 调用表单组件中需要验证或者暴露出去的数据\n                instanceElement?.value?.submitForm().then((res:any) =&gt;{\n                  if(!res){\n                    isLoading.value = false\n                  }\n                  console.log('得到的值',res)\n                  // 验证通过后调用回调函数传递数据，如验证失败，res 的值有可能是一个false。\n                  const callbackResult = onConfirm(res);\n                  // 如果回调函数返回的是 Promise，则等待业务完成后再关闭弹窗\n                  if (callbackResult instanceof Promise) {\n                     callbackResult.then(() =&gt; {\n                      if(res){\n                        console.log('111')\n                        closeDialog()\n                      }else{\n                        isLoading.value = false\n                      }\n                    }).catch(error=&gt;{\n                      console.log('222')\n                      console.error('回调函数执行出错,如:网络错误', error);\n                      // 错误情况下也关闭弹窗\n                      closeDialog()\n                    });\n                  } else {\n                    // 如果不是 Promise，并且验证时通过了的。立即关闭弹窗\n                    console.log('333', res)\n                    if(res){\n                      closeDialog()\n                    }else{\n                      isLoading.value = false\n                    }\n                  }\n                }).catch((error: any) =&gt; {\n                  console.log('44444')\n                   isLoading.value = false\n                  // 验证失败时也可以传递错误信息\n                  console.log('验证失败', error)\n                })\n              }\n            },\n            () =&gt; props.confirmText ||  '确定'\n          )\n        ]\n      ) \n    }\n  );\n  // 创建一个新的 Vue 应用实例。这个应用实例是独立的，与主应用分离。\n  const app = createApp(dialog)\n  // 在新实例中注册 Element Plus, 这弹窗中的组件就可以正常显示了\n  app.use(ElementPlus);\n  // 这个div元素在在销毁应用时需要被移除哈\n  const div = document.createElement('div')\n  document.body.appendChild(div)\n  app.mount(div)\n}\n</code></pre>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-button @click=\"openMask\"&gt;点击弹窗&lt;/el-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport childTest from '@/components/childTest.vue'\nimport { renderDialog } from '@/hooks/dialog'\nimport { getCurrentInstance } from 'vue';\nconst currentInstance = getCurrentInstance();\nfunction openMask(){\n  console.log('currentInstance',currentInstance)\n  const otherProps =  {cancelText:'取消哈', confirmText: '确认哈',showFooterBool:true }\n  const dialogSetObject = {title:'测试弹窗哈', width: '700', draggable: true}\n  renderDialog(childTest,otherProps,dialogSetObject, (res)=&gt;{\n    console.log('通过回调函数返回值', res)\n    // 这里返回一个promise对象，这样就可以让业务完成后才关闭弹窗\n    return fetch(\"https://dog.ceo/api/breed/pembroke/images/random\")\n    .then((res) =&gt; {\n      return res.json();\n    })\n    .then((res) =&gt; {\n        console.log('获取的图片地址为：', res.message);\n    });\n  })\n}\n&lt;/script&gt;\n\n&lt;style lang=\"scss\" scoped&gt;\n\n&lt;/style&gt;\n</code></pre>\n<pre><code>&lt;template&gt;\n  &lt;el-form\n    ref=\"ruleFormRef\"\n    style=\"max-width: 600px\"\n    :model=\"ruleForm\"\n    :rules=\"rules\"\n    label-width=\"auto\"\n  &gt;\n    &lt;el-form-item label=\"Activity name\" prop=\"name\"&gt;\n      &lt;el-input v-model=\"ruleForm.name\" /&gt;\n    &lt;/el-form-item&gt;\n    &lt;el-form-item label=\"Activity zone\" prop=\"region\"&gt;\n      &lt;el-select v-model=\"ruleForm.region\" placeholder=\"Activity zone\"&gt;\n        &lt;el-option label=\"Zone one\" value=\"shanghai\" /&gt;\n        &lt;el-option label=\"Zone two\" value=\"beijing\" /&gt;\n      &lt;/el-select&gt;\n    &lt;/el-form-item&gt;\n    \n    &lt;el-form-item label=\"Activity time\" required&gt;\n      &lt;el-col :span=\"11\"&gt;\n        &lt;el-form-item prop=\"date1\"&gt;\n          &lt;el-date-picker\n            v-model=\"ruleForm.date1\"\n            type=\"date\"\n            aria-label=\"Pick a date\"\n            placeholder=\"Pick a date\"\n            style=\"width: 100%\"\n          /&gt;\n        &lt;/el-form-item&gt;\n      &lt;/el-col&gt;\n      &lt;el-col class=\"text-center\" :span=\"2\"&gt;\n        &lt;span class=\"text-gray-500\"&gt;-&lt;/span&gt;\n      &lt;/el-col&gt;\n      &lt;el-col :span=\"11\"&gt;\n        &lt;el-form-item prop=\"date2\"&gt;\n          &lt;el-time-picker\n            v-model=\"ruleForm.date2\"\n            aria-label=\"Pick a time\"\n            placeholder=\"Pick a time\"\n            style=\"width: 100%\"\n          /&gt;\n        &lt;/el-form-item&gt;\n      &lt;/el-col&gt;\n    &lt;/el-form-item&gt;\n\n  \n    &lt;el-form-item label=\"Resources\" prop=\"resource\"&gt;\n      &lt;el-radio-group v-model=\"ruleForm.resource\"&gt;\n        &lt;el-radio value=\"Sponsorship\"&gt;Sponsorship&lt;/el-radio&gt;\n        &lt;el-radio value=\"Venue\"&gt;Venue&lt;/el-radio&gt;\n      &lt;/el-radio-group&gt;\n    &lt;/el-form-item&gt;\n    &lt;el-form-item label=\"Activity form\" prop=\"desc\"&gt;\n      &lt;el-input v-model=\"ruleForm.desc\" type=\"textarea\" /&gt;\n    &lt;/el-form-item&gt;\n\n  &lt;/el-form&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\" setup&gt;\nimport { reactive, ref } from 'vue'\n\nimport type { FormInstance, FormRules } from 'element-plus'\n\ninterface RuleForm {\n  name: string\n  region: string\n\n  date1: string\n  date2: string\n\n\n  resource: string\n  desc: string\n}\n\n\nconst ruleFormRef = ref&lt;FormInstance&gt;()\nconst ruleForm = reactive&lt;RuleForm&gt;({\n  name: 'Hello',\n  region: '',\n  date1: '',\n  date2: '',\n  resource: '',\n  desc: '',\n})\n\n\n\nconst rules = reactive&lt;FormRules&lt;RuleForm&gt;&gt;({\n  name: [\n    { required: true, message: 'Please input Activity name', trigger: 'blur' },\n    { min: 3, max: 5, message: 'Length should be 3 to 5', trigger: 'blur' },\n  ],\n  region: [\n    {\n      required: true,\n      message: 'Please select Activity zone',\n      trigger: 'change',\n    },\n  ],\n  date1: [\n    {\n      type: 'date',\n      required: true,\n      message: 'Please pick a date',\n      trigger: 'change',\n    },\n  ],\n  date2: [\n    {\n      type: 'date',\n      required: true,\n      message: 'Please pick a time',\n      trigger: 'change',\n    },\n  ],\n  resource: [\n    {\n      required: true,\n      message: 'Please select activity resource',\n      trigger: 'change',\n    },\n  ],\n  desc: [\n    { required: true, message: 'Please input activity form', trigger: 'blur' },\n  ],\n})\n\nconst submitForm = async () =&gt; {\n  if (!ruleFormRef.value) {\n    console.error('ruleFormRef is not initialized')\n    return false\n  }\n  try {\n    const valid = await ruleFormRef.value.validate()\n    if (valid) {\n      // 验证通过后，就会可以把你需要的数据暴露出去\n      return Promise.resolve(ruleForm)\n    }\n  } catch (error) {\n    // 为啥submitForm中，valid的值是false会执行catch ？\n    // el-form 组件的 validate 方法的工作机制导致的。 validate 方法在表单验证失败时会抛出异常\n    console.error('err', error)\n    return false\n    /**\n     * 下面这样写为啥界面会报错呢？\n     * return Promise.reject(error)\n     * 当表单验证失败时，ruleFormRef.value.validate() 会抛出一个异常。\n     * 虽然你用了 try...catch 捕获这个异常，并且在 catch 块中通过 return Promise.reject(error) 返回了一个被拒绝的 Promise\n     * 但如果调用 submitForm 的地方没有正确地处理这个被拒绝的 Promise（即没有使用 .catch() 或者 await 来接收错误），\n     * 那么浏览器控制台就会显示一个 \"Uncaught (in promise)\" 错误。\n     * 在 catch 中再次 return Promise.reject(error) 是多余的， 直接return false\n     * */ \n    /**\n     * 如果你这样写\n     * throw error 直接抛出错误即可\n     * 那么就需要再调用submitForm的地方捕获异常\n     * */  \n  }\n}\n\ndefineExpose({\n  submitForm:submitForm\n})\n&lt;/script&gt;\n\n</code></pre>\n\n</div>\n<div id=\"MySignature\">\n    <div>\n            <h1 style=\"font-size: 24px;\"> 遇见问题，这是你成长的机会，如果你能够解决，这就是收获。 </h1>\n\t\t    <div style=\"padding: 10px;\">\n\t\t        作者：<a href=\"https://www.cnblogs.com/IwishIcould/\" target=\"_blank\">晚来南风晚相识</a> <br />\n\t\t        出处：<a href=\"https://www.cnblogs.com/IwishIcould/\">https://www.cnblogs.com/IwishIcould/</a> <br />\n                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>\n\t\t        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>\n\t\t        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>\n                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>\n\t\t\t\t<div style=\"display: flex;\">\n\t\t\t\t\t<div style=\"margin-right: 100px; text-align: center;\">\n\t\t\t\t\t\t<img src=\"//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179\" />\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t支付宝\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div style=\"text-align: center;\">\n\t\t\t\t\t\t<img src=\"//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg\" />\n\t\t\t\t\t\t<div>微信</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br />\n\t\t        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br />\n               \n\t\t    </div>\n           \n            \n\t\t</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 09:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/IwishIcould\">南风晚来晚相识</a>&nbsp;\n阅读(<span id=\"post_view_count\">63</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Karmada-ResourceBinding (RB) 组件详解",
      "link": "https://www.cnblogs.com/Mephostopheles/p/19477095",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Mephostopheles/p/19477095\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 14:25\">\n    <span>karmada-ResourceBinding (RB) 工作原理详解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        ResourceBinding（RB）是 Karmada 中用于描述资源如何在多个成员集群中分布和调度的核心对象。本文结合源码详细解释 RB 的完整生命周期和工作原理。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"resourcebinding-rb-工作原理详解\">ResourceBinding (RB) 工作原理详解</h1>\n<h2 id=\"概述\">概述</h2>\n<p>ResourceBinding（RB）是 Karmada 中用于描述资源如何在多个成员集群中分布和调度的核心对象。本文档结合源码详细解释 RB 的完整生命周期和工作原理。</p>\n<h2 id=\"零核心概念详解\">零、核心概念详解</h2>\n<p>在深入理解 RB 的工作原理之前，我们需要先理解 Karmada 中的几个核心概念。</p>\n<h3 id=\"01-propagationpolicy传播策略\">0.1 PropagationPolicy（传播策略）</h3>\n<p><strong>PropagationPolicy</strong> 是 Karmada 中用于定义资源如何传播到成员集群的策略对象。它类似于 Kubernetes 中的 ReplicaSet，但它控制的是资源在多个集群间的分布，而不是 Pod 在节点间的分布。</p>\n<h4 id=\"定义\">定义</h4>\n<pre><code class=\"language-52:59:pkg/apis/policy/v1alpha1/propagation_types.go\">// PropagationPolicy represents the policy that propagates a group of resources to one or more clusters.\ntype PropagationPolicy struct {\n\tmetav1.TypeMeta   `json:\",inline\"`\n\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`\n\n\t// Spec represents the desired behavior of PropagationPolicy.\n\t// +required\n\tSpec PropagationSpec `json:\"spec\"`\n}\n</code></pre>\n<h4 id=\"propagationspec-结构\">PropagationSpec 结构</h4>\n<pre><code class=\"language-61:220:pkg/apis/policy/v1alpha1/propagation_types.go\">// PropagationSpec represents the desired behavior of PropagationPolicy.\ntype PropagationSpec struct {\n\t// ResourceSelectors used to select resources.\n\t// Nil or empty selector is not allowed and doesn't mean match all kinds\n\t// of resources for security concerns that sensitive resources(like Secret)\n\t// might be accidentally propagated.\n\t// +required\n\t// +kubebuilder:validation:MinItems=1\n\tResourceSelectors []ResourceSelector `json:\"resourceSelectors\"`\n\n\t// Association tells if relevant resources should be selected automatically.\n\t// e.g. a ConfigMap referred by a Deployment.\n\t// default false.\n\t// Deprecated: in favor of PropagateDeps.\n\t// +optional\n\tAssociation bool `json:\"association,omitempty\"`\n\n\t// PropagateDeps tells if relevant resources should be propagated automatically.\n\t// Take 'Deployment' which referencing 'ConfigMap' and 'Secret' as an example, when 'propagateDeps' is 'true',\n\t// the referencing resources could be omitted(for saving config effort) from 'resourceSelectors' as they will be\n\t// propagated along with the Deployment. In addition to the propagating process, the referencing resources will be\n\t// migrated along with the Deployment in the fail-over scenario.\n\t//\n\t// Defaults to false.\n\t// +optional\n\tPropagateDeps bool `json:\"propagateDeps,omitempty\"`\n\n\t// Placement represents the rule for select clusters to propagate resources.\n\t// +optional\n\tPlacement Placement `json:\"placement,omitempty\"`\n</code></pre>\n<p><strong>关键字段说明</strong>：</p>\n<ol>\n<li>\n<p><strong>ResourceSelectors</strong>: 资源选择器，用于选择哪些资源需要传播</p>\n<ul>\n<li>可以通过 APIVersion、Kind、Name、Namespace、LabelSelector 来选择资源</li>\n<li>至少需要一个选择器（安全考虑，防止敏感资源被意外传播）</li>\n</ul>\n</li>\n<li>\n<p><strong>PropagateDeps</strong>: 是否自动传播依赖资源</p>\n<ul>\n<li>例如：Deployment 引用的 ConfigMap 和 Secret</li>\n<li>设置为 <code>true</code> 时，可以省略这些依赖资源的选择器，它们会自动传播</li>\n</ul>\n</li>\n<li>\n<p><strong>Placement</strong>: 集群选择规则（详见下文）</p>\n</li>\n<li>\n<p><strong>Priority</strong>: 策略优先级（用于策略抢占）</p>\n</li>\n<li>\n<p><strong>Failover</strong>: 故障转移行为（详见下文）</p>\n</li>\n</ol>\n<h4 id=\"resourceselector-结构\">ResourceSelector 结构</h4>\n<pre><code class=\"language-222:246:pkg/apis/policy/v1alpha1/propagation_types.go\">// ResourceSelector the resources will be selected.\ntype ResourceSelector struct {\n\t// APIVersion represents the API version of the target resources.\n\t// +required\n\tAPIVersion string `json:\"apiVersion\"`\n\n\t// Kind represents the Kind of the target resources.\n\t// +required\n\tKind string `json:\"kind\"`\n\n\t// Namespace of the target resource.\n\t// Default is empty, which means inherit from the parent object scope.\n\t// +optional\n\tNamespace string `json:\"namespace,omitempty\"`\n\n\t// Name of the target resource.\n\t// Default is empty, which means selecting all resources.\n\t// +optional\n\tName string `json:\"name,omitempty\"`\n\n\t// A label query over a set of resources.\n\t// If name is not empty, labelSelector will be ignored.\n\t// +optional\n\tLabelSelector *metav1.LabelSelector `json:\"labelSelector,omitempty\"`\n}\n</code></pre>\n<h4 id=\"clusterpropagationpolicy\">ClusterPropagationPolicy</h4>\n<p><strong>ClusterPropagationPolicy</strong> 与 PropagationPolicy 功能相同，但作用域是集群级别的（用于集群级别的资源，如 ClusterRole、ClusterRoleBinding 等）。</p>\n<h3 id=\"02-placement放置规则\">0.2 Placement（放置规则）</h3>\n<p><strong>Placement</strong> 定义了资源应该被调度到哪些集群，以及如何在这些集群间分配。</p>\n<h4 id=\"定义-1\">定义</h4>\n<p>Placement 包含以下主要字段：</p>\n<ol>\n<li><strong>ClusterAffinity</strong>: 集群亲和性（首选哪些集群）</li>\n<li><strong>ClusterTolerations</strong>: 集群容忍度（可以调度到哪些集群）</li>\n<li><strong>SpreadConstraints</strong>: 分散约束（如何在不同集群间分配）</li>\n<li><strong>ReplicaScheduling</strong>: 副本调度策略（副本如何分配到集群）</li>\n</ol>\n<p><strong>示例</strong>：</p>\n<ul>\n<li><strong>Duplicated</strong>: 所有集群都运行相同的副本数（如 ConfigMap、Secret）</li>\n<li><strong>Divided</strong>: 副本按比例分配到不同集群（如 Deployment）</li>\n</ul>\n<h3 id=\"03-resourcebinding资源绑定\">0.3 ResourceBinding（资源绑定）</h3>\n<p><strong>ResourceBinding（RB）</strong> 是 PropagationPolicy 和资源对象的绑定结果。它记录了：</p>\n<ol>\n<li><strong>资源引用</strong>: 指向原始资源对象（Deployment、StatefulSet 等）</li>\n<li><strong>副本信息</strong>: 从资源中提取的副本数和资源需求</li>\n<li><strong>调度结果</strong>: 由 Scheduler 填充的目标集群列表</li>\n<li><strong>策略信息</strong>: 从 PropagationPolicy 复制的策略配置</li>\n</ol>\n<h4 id=\"resourcebinding-与-propagationpolicy-的关系\">ResourceBinding 与 PropagationPolicy 的关系</h4>\n<pre><code>用户创建 Deployment + PropagationPolicy\n    ↓\nResourceDetector 检测匹配\n    ↓\n创建 ResourceBinding（绑定 Deployment 和 PropagationPolicy）\n    ↓\nScheduler 填充 ResourceBinding.Spec.Clusters（调度结果）\n</code></pre>\n<p><strong>重要</strong>：RB 是策略和资源的<strong>绑定</strong>，一个资源只会被一个策略绑定（按优先级选择）。</p>\n<h3 id=\"04-work工作负载\">0.4 Work（工作负载）</h3>\n<p><strong>Work</strong> 是实际被发送到成员集群的资源对象。一个 RB 可以生成多个 Work（每个目标集群一个）。</p>\n<h4 id=\"定义-2\">定义</h4>\n<pre><code class=\"language-43:74:pkg/apis/work/v1alpha1/work_types.go\">// Work defines a list of resources to be deployed on the member cluster.\ntype Work struct {\n\tmetav1.TypeMeta   `json:\",inline\"`\n\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`\n\n\t// Spec represents the desired behavior of Work.\n\tSpec WorkSpec `json:\"spec\"`\n\n\t// Status represents the status of PropagationStatus.\n\t// +optional\n\tStatus WorkStatus `json:\"status,omitempty\"`\n}\n\n// WorkSpec defines the desired state of Work.\ntype WorkSpec struct {\n\t// Workload represents the manifest workload to be deployed on managed cluster.\n\tWorkload WorkloadTemplate `json:\"workload,omitempty\"`\n\n\t// SuspendDispatching controls whether dispatching should\n\t// be suspended, nil means not suspend.\n\t// Note: true means stop propagating to the corresponding member cluster, and\n\t// does not prevent status collection.\n\t// +optional\n\tSuspendDispatching *bool `json:\"suspendDispatching,omitempty\"`\n\n\t// PreserveResourcesOnDeletion controls whether resources should be preserved on the\n\t// member cluster when the Work object is deleted.\n\t// If set to true, resources will be preserved on the member cluster.\n\t// Default is false, which means resources will be deleted along with the Work object.\n\t// +optional\n\tPreserveResourcesOnDeletion *bool `json:\"preserveResourcesOnDeletion,omitempty\"`\n}\n</code></pre>\n<h4 id=\"work-与-resourcebinding-的关系\">Work 与 ResourceBinding 的关系</h4>\n<pre><code>ResourceBinding (控制平面)\n    ↓ 转换为\nWork (执行空间: execution-{cluster-name})\n    ↓ 分发到\n成员集群\n    ↓ 执行\n实际资源（Deployment、Service 等）\n</code></pre>\n<p><strong>执行空间（Execution Space）</strong>：每个成员集群都有一个对应的 namespace，格式为 <code>execution-{cluster-name}</code>，所有发送到该集群的 Work 都放在这个 namespace 中。</p>\n<h3 id=\"05-resourceinterpreter资源解释器\">0.5 ResourceInterpreter（资源解释器）</h3>\n<p><strong>ResourceInterpreter</strong> 是 Karmada 中用于解释自定义资源的核心组件。它能够理解不同种类的资源（Deployment、StatefulSet、自定义 CRD 等），并提取关键信息。</p>\n<h4 id=\"作用\">作用</h4>\n<p>ResourceInterpreter 提供以下能力：</p>\n<ol>\n<li><strong>GetReplicas</strong>: 从资源中提取副本数和资源需求（用于 RB 创建时的性能瓶颈点）</li>\n<li><strong>ReviseReplica</strong>: 修改资源的副本数（用于将调度结果应用到 Work）</li>\n<li><strong>Retain</strong>: 保留集群特定的字段（防止覆盖）</li>\n<li><strong>AggregateStatus</strong>: 聚合多个集群的状态</li>\n<li><strong>InterpretHealth</strong>: 判断资源是否健康</li>\n<li><strong>GetDependencies</strong>: 获取依赖资源</li>\n</ol>\n<h4 id=\"实现层次\">实现层次</h4>\n<pre><code class=\"language-42:72:pkg/resourceinterpreter/interpreter.go\">// ResourceInterpreter manages both default and customized webhooks to interpret custom resource structure.\ntype ResourceInterpreter interface {\n\t// Start initializes the resource interpreter and performs cache synchronization.\n\tStart(ctx context.Context) (err error)\n\n\t// HookEnabled tells if any hook exist for specific resource type and operation.\n\tHookEnabled(objGVK schema.GroupVersionKind, operationType configv1alpha1.InterpreterOperation) bool\n\n\t// GetReplicas returns the desired replicas of the object as well as the requirements of each replica.\n\tGetReplicas(object *unstructured.Unstructured) (replica int32, replicaRequires *workv1alpha2.ReplicaRequirements, err error)\n\n\t// ReviseReplica revises the replica of the given object.\n\tReviseReplica(object *unstructured.Unstructured, replica int64) (*unstructured.Unstructured, error)\n\n\t// GetComponents extracts the resource requirements for multiple components from the given object.\n\t// This hook is designed for CRDs with multiple components (e.g., FlinkDeployment), but can\n\t// also be used for single-component resources like Deployment.\n\t// If implemented, the controller will use this hook to obtain per-component replica and resource\n\t// requirements, and will not call GetReplicas.\n\t// If not implemented, the controller will fall back to GetReplicas for backward compatibility.\n\t// This hook will only be called when the feature gate 'MultiplePodTemplatesScheduling' is enabled.\n\tGetComponents(object *unstructured.Unstructured) (components []workv1alpha2.Component, err error)\n\n\t// Retain returns the objects that based on the \"desired\" object but with values retained from the \"observed\" object.\n\tRetain(desired *unstructured.Unstructured, observed *unstructured.Unstructured) (retained *unstructured.Unstructured, err error)\n\n\t// AggregateStatus returns the objects that based on the 'object' but with status aggregated.\n\tAggregateStatus(object *unstructured.Unstructured, aggregatedStatusItems []workv1alpha2.AggregatedStatusItem) (*unstructured.Unstructured, error)\n\n\t// GetDependencies returns the dependent resources of the given object.\n</code></pre>\n<h4 id=\"解释器类型\">解释器类型</h4>\n<p>ResourceInterpreter 有四种实现方式（按优先级）：</p>\n<ol>\n<li><strong>ConfigurableInterpreter</strong>（最高优先级）：使用 Lua 脚本进行声明式配置</li>\n<li><strong>CustomizedInterpreter</strong>：使用 Webhook 进行自定义</li>\n<li><strong>ThirdPartyInterpreter</strong>：第三方内置的解释规则</li>\n<li><strong>DefaultInterpreter</strong>（最低优先级）：Karmada 内置的默认解释器</li>\n</ol>\n<p>调用顺序：</p>\n<pre><code class=\"language-136:168:pkg/resourceinterpreter/interpreter.go\">// GetReplicas returns the desired replicas of the object as well as the requirements of each replica.\nfunc (i *customResourceInterpreterImpl) GetReplicas(object *unstructured.Unstructured) (replica int32, requires *workv1alpha2.ReplicaRequirements, err error) {\n\tvar hookEnabled bool\n\n\treplica, requires, hookEnabled, err = i.configurableInterpreter.GetReplicas(object)\n\tif err != nil {\n\t\treturn\n\t}\n\tif hookEnabled {\n\t\treturn\n\t}\n\n\treplica, requires, hookEnabled, err = i.customizedInterpreter.GetReplicas(context.TODO(), &amp;request.Attributes{\n\t\tOperation: configv1alpha1.InterpreterOperationInterpretReplica,\n\t\tObject:    object,\n\t})\n\tif err != nil {\n\t\treturn\n\t}\n\tif hookEnabled {\n\t\treturn\n\t}\n\treplica, requires, hookEnabled, err = i.thirdpartyInterpreter.GetReplicas(object)\n\tif err != nil {\n\t\treturn\n\t}\n\tif hookEnabled {\n\t\treturn\n\t}\n\n\treplica, requires, err = i.defaultInterpreter.GetReplicas(object)\n\treturn\n}\n</code></pre>\n<h3 id=\"06-resourcedetector资源检测器\">0.6 ResourceDetector（资源检测器）</h3>\n<p><strong>ResourceDetector</strong> 是 Karmada 控制器的一部分，负责：</p>\n<ol>\n<li><strong>监听资源变化</strong>：监听 Kubernetes 资源（Deployment、Service 等）的创建/更新/删除</li>\n<li><strong>匹配策略</strong>：为资源找到匹配的 PropagationPolicy</li>\n<li><strong>创建 RB</strong>：根据策略创建或更新 ResourceBinding</li>\n<li><strong>策略管理</strong>：处理 PropagationPolicy 的生命周期</li>\n</ol>\n<h3 id=\"07-scheduler调度器\">0.7 Scheduler（调度器）</h3>\n<p><strong>Scheduler</strong> 是 Karmada 的调度组件，负责：</p>\n<ol>\n<li><strong>监听 RB</strong>：监听 ResourceBinding 的创建和更新</li>\n<li><strong>选择集群</strong>：根据 Placement 规则选择合适的成员集群</li>\n<li><strong>分配副本</strong>：将副本按策略分配到不同集群</li>\n<li><strong>更新 RB</strong>：将调度结果填充到 <code>ResourceBinding.Spec.Clusters</code></li>\n</ol>\n<p><strong>重要</strong>：Scheduler <strong>只负责填充 <code>Spec.Clusters</code></strong>，不会修改其他字段。</p>\n<h3 id=\"08-概念关系图\">0.8 概念关系图</h3>\n<pre><code>┌─────────────────────────────────────────────────────────┐\n│                   控制平面（Karmada）                      │\n│                                                          │\n│  ┌─────────────┐      ┌──────────────┐                │\n│  │ Deployment  │      │Propagation   │                │\n│  │  (资源对象)  │      │  Policy      │                │\n│  └──────┬──────┘      └──────┬───────┘                │\n│         │                    │                         │\n│         └────────┬───────────┘                         │\n│                  │                                     │\n│                  ▼                                     │\n│         ┌──────────────────┐                          │\n│         │ResourceDetector  │                          │\n│         │  (检测并创建)     │                          │\n│         └────────┬─────────┘                          │\n│                  │                                     │\n│                  ▼                                     │\n│         ┌──────────────────┐                          │\n│         │ResourceBinding   │                          │\n│         │  (绑定策略和资源)  │                          │\n│         └────────┬─────────┘                          │\n│                  │                                     │\n│                  ▼                                     │\n│         ┌──────────────────┐                          │\n│         │   Scheduler      │                          │\n│         │  (选择目标集群)   │                          │\n│         └────────┬─────────┘                          │\n│                  │                                     │\n│                  ▼                                     │\n│         ┌──────────────────┐                          │\n│         │ResourceBinding   │                          │\n│         │ (Spec.Clusters已 │                          │\n│         │   被填充)        │                          │\n│         └────────┬─────────┘                          │\n│                  │                                     │\n│                  ▼                                     │\n│         ┌──────────────────┐                          │\n│         │ BindingController│                          │\n│         │   (转换为Work)    │                          │\n│         └────────┬─────────┘                          │\n│                  │                                     │\n└──────────────────┼─────────────────────────────────────┘\n                   │\n        ┌──────────┴──────────┐\n        │                     │\n        ▼                     ▼\n┌──────────────┐      ┌──────────────┐\n│   Work       │      │   Work       │\n│(execution-   │      │(execution-   │\n│ cluster-1)   │      │ cluster-2)   │\n└──────┬───────┘      └──────┬───────┘\n       │                     │\n       └──────────┬──────────┘\n                  │\n        ┌─────────┴─────────┐\n        │                   │\n        ▼                   ▼\n┌─────────────┐      ┌─────────────┐\n│成员集群1     │      │成员集群2     │\n│             │      │             │\n│ Deployment  │      │ Deployment  │\n│  (实际运行)  │      │  (实际运行)  │\n└─────────────┘      └─────────────┘\n</code></pre>\n<h2 id=\"一rb-的生命周期\">一、RB 的生命周期</h2>\n<h3 id=\"11-整体流程\">1.1 整体流程</h3>\n<pre><code>用户创建资源 + PropagationPolicy\n    ↓\nResourceDetector 检测并创建/更新 RB\n    ↓\nScheduler 为 RB 选择目标集群\n    ↓\nResourceBindingController 将 RB 转换为 Work\n    ↓\nWork 被分发到成员集群\n</code></pre>\n<h3 id=\"12-关键组件\">1.2 关键组件</h3>\n<ol>\n<li><strong>ResourceDetector</strong> (<code>pkg/detector/detector.go</code>): 负责检测资源并创建 RB</li>\n<li><strong>Scheduler</strong> (<code>pkg/scheduler/</code>): 为 RB 选择目标集群</li>\n<li><strong>ResourceBindingController</strong> (<code>pkg/controllers/binding/</code>): 将 RB 转换为 Work</li>\n<li><strong>ResourceInterpreter</strong> (<code>pkg/resourceinterpreter/</code>): 解释资源，提取副本数和资源需求</li>\n</ol>\n<h2 id=\"二rb-的创建过程\">二、RB 的创建过程</h2>\n<h3 id=\"21-触发条件\">2.1 触发条件</h3>\n<p>当用户创建或更新了：</p>\n<ul>\n<li><strong>资源对象</strong>（如 Deployment）</li>\n<li><strong>PropagationPolicy</strong> 或 <strong>ClusterPropagationPolicy</strong></li>\n</ul>\n<p>ResourceDetector 会检测到变化并触发 RB 的创建或更新。</p>\n<h3 id=\"22-创建流程详解\">2.2 创建流程详解</h3>\n<h4 id=\"步骤1-检测资源和策略匹配\">步骤1: 检测资源和策略匹配</h4>\n<p>当资源对象发生变化时，ResourceDetector 会：</p>\n<pre><code class=\"language-796:862:pkg/detector/detector.go\">// BuildResourceBinding builds a desired ResourceBinding for object.\nfunc (d *ResourceDetector) BuildResourceBinding(object *unstructured.Unstructured, policySpec *policyv1alpha1.PropagationSpec, policyID string, policyMeta metav1.ObjectMeta, claimFunc func(object metav1.Object, policyId string, objectMeta metav1.ObjectMeta)) (*workv1alpha2.ResourceBinding, error) {\n\tbindingName := names.GenerateBindingName(object.GetKind(), object.GetName())\n\tpropagationBinding := &amp;workv1alpha2.ResourceBinding{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      bindingName,\n\t\t\tNamespace: object.GetNamespace(),\n\t\t\tOwnerReferences: []metav1.OwnerReference{\n\t\t\t\t*metav1.NewControllerRef(object, object.GroupVersionKind()),\n\t\t\t},\n\t\t\tFinalizers: []string{util.BindingControllerFinalizer},\n\t\t},\n\t\tSpec: workv1alpha2.ResourceBindingSpec{\n\t\t\tPropagateDeps:               policySpec.PropagateDeps,\n\t\t\tSchedulerName:               policySpec.SchedulerName,\n\t\t\tPlacement:                   &amp;policySpec.Placement,\n\t\t\tFailover:                    policySpec.Failover,\n\t\t\tConflictResolution:          policySpec.ConflictResolution,\n\t\t\tPreserveResourcesOnDeletion: policySpec.PreserveResourcesOnDeletion,\n\t\t\tResource: workv1alpha2.ObjectReference{\n\t\t\t\tAPIVersion:      object.GetAPIVersion(),\n\t\t\t\tKind:            object.GetKind(),\n\t\t\t\tNamespace:       object.GetNamespace(),\n\t\t\t\tName:            object.GetName(),\n\t\t\t\tUID:             object.GetUID(),\n\t\t\t\tResourceVersion: object.GetResourceVersion(),\n\t\t\t},\n\t\t},\n\t}\n\n\tif policySpec.Suspension != nil {\n\t\tpropagationBinding.Spec.Suspension = &amp;workv1alpha2.Suspension{Suspension: *policySpec.Suspension}\n\t}\n\n\tclaimFunc(propagationBinding, policyID, policyMeta)\n\n\tif err := d.applyReplicaInterpretation(object, &amp;propagationBinding.Spec); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif features.FeatureGate.Enabled(features.PriorityBasedScheduling) &amp;&amp; policySpec.SchedulePriority != nil {\n\t\t// ... 处理调度优先级\n\t}\n\n\treturn propagationBinding, nil\n}\n</code></pre>\n<p><strong>关键点</strong>：</p>\n<ul>\n<li>使用 <code>names.GenerateBindingName()</code> 生成 RB 名称（格式：<code>{Kind}-{Name}</code>）</li>\n<li>设置 OwnerReference 建立资源对象和 RB 的关联</li>\n<li>添加 Finalizer 确保删除时正确清理</li>\n</ul>\n<h4 id=\"步骤2-应用副本解释\">步骤2: 应用副本解释</h4>\n<p>这是 RB 创建中的<strong>关键步骤</strong></p>\n<pre><code class=\"language-1442:1470:pkg/detector/detector.go\">// applyReplicaInterpretation handles the logic for interpreting replicas or components from an object.\nfunc (d *ResourceDetector) applyReplicaInterpretation(object *unstructured.Unstructured, spec *workv1alpha2.ResourceBindingSpec) error {\n\tgvk := object.GroupVersionKind()\n\tname := object.GetName()\n\n\t// Prioritize component interpretation if the feature and GetComponents are enabled.\n\tif features.FeatureGate.Enabled(features.MultiplePodTemplatesScheduling) &amp;&amp; d.ResourceInterpreter.HookEnabled(gvk, configv1alpha1.InterpreterOperationInterpretComponent) {\n\t\tcomponents, err := d.ResourceInterpreter.GetComponents(object)\n\t\tif err != nil {\n\t\t\tklog.Errorf(\"Failed to get components for %s(%s): %v\", gvk, name, err)\n\t\t\treturn err\n\t\t}\n\t\tspec.Components = components\n\t\treturn nil\n\t}\n\n\t// GetReplicas is executed if the MultiplePodTemplatesScheduling feature gate is disabled, or if GetComponents is not implemented.\n\tif d.ResourceInterpreter.HookEnabled(gvk, configv1alpha1.InterpreterOperationInterpretReplica) {\n\t\treplicas, replicaRequirements, err := d.ResourceInterpreter.GetReplicas(object)\n\t\tif err != nil {\n\t\t\tklog.Errorf(\"Failed to customize replicas for %s(%s): %v\", gvk, name, err)\n\t\t\treturn err\n\t\t}\n\t\tspec.Replicas = replicas\n\t\tspec.ReplicaRequirements = replicaRequirements\n\t}\n\n\treturn nil\n}\n</code></pre>\n<p><strong>调用链</strong>：</p>\n<pre><code>applyReplicaInterpretation\n    ↓\nResourceInterpreter.GetReplicas(object)\n    ↓\nConfigurableInterpreter.GetReplicas(object)\n    ↓\nLuaVM.GetReplicas(object, script) \n    ↓\nLuaVM.RunScript(script, \"GetReplicas\", 2, object)  ← 需要从 VM 池获取实例\n    ↓\nVM.Pool.Get()  ← 锁竞争点\n    ↓\nLua.DoString(script)  ← 脚本编译点\n    ↓\nLua.CallByParam(...)  ← 执行 GetReplicas 函数\n</code></pre>\n<h4 id=\"步骤3-创建或更新-rb\">步骤3: 创建或更新 RB</h4>\n<p>使用 <code>CreateOrUpdate</code> 确保 RB 存在：</p>\n<pre><code class=\"language-475:524:pkg/detector/detector.go\">\tbinding, err := d.BuildResourceBinding(object, &amp;policy.Spec, policyID, policy.ObjectMeta, AddPPClaimMetadata)\n\tif err != nil {\n\t\tklog.Errorf(\"Failed to build resourceBinding for object: %s. error: %v\", objectKey, err)\n\t\treturn err\n\t}\n\tbindingCopy := binding.DeepCopy()\n\terr = retry.RetryOnConflict(retry.DefaultRetry, func() (err error) {\n\t\toperationResult, err = controllerutil.CreateOrUpdate(context.TODO(), d.Client, bindingCopy, func() error {\n\t\t\t// If this binding exists and its owner is not the input object, return error and let garbage collector\n\t\t\t// delete this binding and try again later. See https://github.com/karmada-io/karmada/issues/2090.\n\t\t\tif ownerRef := metav1.GetControllerOfNoCopy(bindingCopy); ownerRef != nil &amp;&amp; ownerRef.UID != object.GetUID() {\n\t\t\t\treturn fmt.Errorf(\"failed to update binding due to different owner reference UID, will \" +\n\t\t\t\t\t\"try again later after binding is garbage collected, see https://github.com/karmada-io/karmada/issues/2090\")\n\t\t\t}\n\n\t\t\t// Just update necessary fields, especially avoid modifying Spec.Clusters which is scheduling result, if already exists.\n\t\t\tbindingCopy.Annotations = util.DedupeAndMergeAnnotations(bindingCopy.Annotations, binding.Annotations)\n\t\t\tbindingCopy.Labels = util.DedupeAndMergeLabels(bindingCopy.Labels, binding.Labels)\n\t\t\tbindingCopy.OwnerReferences = binding.OwnerReferences\n\t\t\tbindingCopy.Spec.Placement = binding.Spec.Placement\n\t\t\tbindingCopy.Spec.Resource = binding.Spec.Resource\n\t\t\tbindingCopy.Spec.ConflictResolution = binding.Spec.ConflictResolution\n\t\t\tif binding.Spec.Suspension != nil {\n\t\t\t\tif bindingCopy.Spec.Suspension == nil {\n\t\t\t\t\tbindingCopy.Spec.Suspension = &amp;workv1alpha2.Suspension{}\n\t\t\t\t}\n\t\t\t\tbindingCopy.Spec.Suspension.Suspension = binding.Spec.Suspension.Suspension\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n</code></pre>\n<p><strong>关键点</strong>：</p>\n<ul>\n<li>使用 <code>RetryOnConflict</code> 处理并发更新冲突</li>\n<li><strong>不修改 <code>Spec.Clusters</code></strong>，这是调度器的调度结果</li>\n<li>只更新策略相关的字段</li>\n</ul>\n<h2 id=\"三rb-到-work-的转换\">三、RB 到 Work 的转换</h2>\n<h3 id=\"31-转换触发\">3.1 转换触发</h3>\n<p>当 RB 被创建或更新后，ResourceBindingController 会监听 RB 的变化：</p>\n<pre><code class=\"language-110:148:pkg/controllers/binding/binding_controller.go\">// syncBinding will sync resourceBinding to Works.\nfunc (c *ResourceBindingController) syncBinding(ctx context.Context, binding *workv1alpha2.ResourceBinding) (controllerruntime.Result, error) {\n\tif err := c.removeOrphanWorks(ctx, binding); err != nil {\n\t\treturn controllerruntime.Result{}, err\n\t}\n\n\tneedWaitForCleanup, err := c.checkDirectPurgeOrphanWorks(ctx, binding)\n\tif err != nil {\n\t\treturn controllerruntime.Result{}, err\n\t}\n\tif needWaitForCleanup {\n\t\tmsg := fmt.Sprintf(\"There are works in clusters with PurgeMode 'Directly' not deleted for ResourceBinding(%s/%s), skip syncing works\",\n\t\t\tbinding.Namespace, binding.Name)\n\t\tklog.V(4).InfoS(msg, \"namespace\", binding.GetNamespace(), \"binding\", binding.GetName())\n\t\treturn controllerruntime.Result{RequeueAfter: requeueIntervalForDirectlyPurge}, nil\n\t}\n\n\tworkload, err := helper.FetchResourceTemplate(ctx, c.DynamicClient, c.InformerManager, c.RESTMapper, binding.Spec.Resource)\n\tif err != nil {\n\t\tif apierrors.IsNotFound(err) {\n\t\t\t// It might happen when the resource template has been removed but the garbage collector hasn't removed\n\t\t\t// the ResourceBinding which dependent on resource template.\n\t\t\t// So, just return without retry(requeue) would save unnecessary loop.\n\t\t\treturn controllerruntime.Result{}, nil\n\t\t}\n\t\tklog.ErrorS(err, \"Failed to fetch workload for ResourceBinding\", \"namespace\", binding.GetNamespace(), \"binding\", binding.GetName())\n\t\treturn controllerruntime.Result{}, err\n\t}\n\tstart := time.Now()\n\terr = ensureWork(ctx, c.Client, c.ResourceInterpreter, workload, c.OverrideManager, binding, apiextensionsv1.NamespaceScoped)\n\tmetrics.ObserveSyncWorkLatency(err, start)\n\tif err != nil {\n\t\tklog.ErrorS(err, \"Failed to transform ResourceBinding to works\", \"namespace\", binding.GetNamespace(), \"binding\", binding.GetName())\n\t\tc.EventRecorder.Event(binding, corev1.EventTypeWarning, events.EventReasonSyncWorkFailed, err.Error())\n\t\tc.EventRecorder.Event(workload, corev1.EventTypeWarning, events.EventReasonSyncWorkFailed, err.Error())\n\t\treturn controllerruntime.Result{}, err\n\t}\n\n\tmsg := fmt.Sprintf(\"Sync work of ResourceBinding(%s/%s) successful.\",\n</code></pre>\n<h3 id=\"32-ensurework-函数详解\">3.2 ensureWork 函数详解</h3>\n<p>这是将 RB 转换为 Work 的核心函数：</p>\n<pre><code class=\"language-50:158:pkg/controllers/binding/common.go\">// ensureWork ensure Work to be created or updated.\nfunc ensureWork(\n\tctx context.Context, c client.Client, resourceInterpreter resourceinterpreter.ResourceInterpreter, workload *unstructured.Unstructured,\n\toverrideManager overridemanager.OverrideManager, binding metav1.Object, scope apiextensionsv1.ResourceScope,\n) error {\n\tbindingSpec := getBindingSpec(binding, scope)\n\ttargetClusters := mergeTargetClusters(bindingSpec.Clusters, bindingSpec.RequiredBy)\n\tvar err error\n\tvar errs []error\n\n\tvar jobCompletions []workv1alpha2.TargetCluster\n\tif workload.GetKind() == util.JobKind &amp;&amp; needReviseJobCompletions(bindingSpec.Replicas, bindingSpec.Placement) {\n\t\tjobCompletions, err = divideReplicasByJobCompletions(workload, targetClusters)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor i := range targetClusters {\n\t\ttargetCluster := targetClusters[i]\n\t\tclonedWorkload := workload.DeepCopy()\n\n\t\tworkNamespace := names.GenerateExecutionSpaceName(targetCluster.Name)\n\n\t\t// When syncing workloads to member clusters, the controller MUST strictly adhere to the scheduling results\n\t\t// specified in bindingSpec.Clusters for replica allocation, rather than using the replicas declared in the\n\t\t// workload's resource template.\n\t\t// This rule applies regardless of whether the workload distribution mode is \"Divided\" or \"Duplicated\".\n\t\t// Failing to do so could allow workloads to bypass the quota checks performed by the scheduler\n\t\t// (especially during scale-up operations) or skip queue validation when scheduling is suspended.\n\t\tif bindingSpec.IsWorkload() {\n\t\t\tif resourceInterpreter.HookEnabled(clonedWorkload.GroupVersionKind(), configv1alpha1.InterpreterOperationReviseReplica) {\n\t\t\t\tclonedWorkload, err = resourceInterpreter.ReviseReplica(clonedWorkload, int64(targetCluster.Replicas))\n\t\t\t\tif err != nil {\n\t\t\t\t\tklog.ErrorS(err, \"Failed to revise replica for workload in cluster.\", \"workloadKind\", workload.GetKind(),\n\t\t\t\t\t\t\"workloadNamespace\", workload.GetNamespace(), \"workloadName\", workload.GetName(), \"cluster\", targetCluster.Name)\n\t\t\t\t\terrs = append(errs, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// jobSpec.Completions specifies the desired number of successfully finished pods the job should be run with.\n\t\t// When the replica scheduling policy is set to \"divided\", jobSpec.Completions should also be divided accordingly.\n\t\t// The weight assigned to each cluster roughly equals that cluster's jobSpec.Parallelism value. This approach helps\n\t\t// balance the execution time of the job across member clusters.\n\t\tif len(jobCompletions) &gt; 0 {\n\t\t\t// Set allocated completions for Job only when the '.spec.completions' field not omitted from resource template.\n\t\t\t// For jobs running with a 'work queue' usually leaves '.spec.completions' unset, in that case we skip\n\t\t\t// setting this field as well.\n\t\t\t// Refer to: https://kubernetes.io/docs/concepts/workloads/controllers/job/#parallel-jobs.\n\t\t\tif err = helper.ApplyReplica(clonedWorkload, int64(jobCompletions[i].Replicas), util.CompletionsField); err != nil {\n\t\t\t\tklog.ErrorS(err, \"Failed to apply Completions for workload in cluster.\",\n\t\t\t\t\t\"workloadKind\", clonedWorkload.GetKind(), \"workloadNamespace\", clonedWorkload.GetNamespace(),\n\t\t\t\t\t\"workloadName\", clonedWorkload.GetName(), \"cluster\", targetCluster.Name)\n\t\t\t\terrs = append(errs, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// We should call ApplyOverridePolicies last, as override rules have the highest priority\n\t\tcops, ops, err := overrideManager.ApplyOverridePolicies(clonedWorkload, targetCluster.Name)\n\t\tif err != nil {\n\t\t\tklog.ErrorS(err, \"Failed to apply overrides for workload in cluster.\",\n\t\t\t\t\"workloadKind\", clonedWorkload.GetKind(), \"workloadNamespace\", clonedWorkload.GetNamespace(),\n\t\t\t\t\"workloadName\", clonedWorkload.GetName(), \"cluster\", targetCluster.Name)\n\t\t\terrs = append(errs, err)\n\t\t\tcontinue\n\t\t}\n\t\tworkLabel := mergeLabel(clonedWorkload, binding, scope)\n\n\t\tannotations := mergeAnnotations(clonedWorkload, binding, scope)\n\t\tannotations = mergeConflictResolution(clonedWorkload, bindingSpec.ConflictResolution, annotations)\n\t\tannotations, err = RecordAppliedOverrides(cops, ops, annotations)\n\t\tif err != nil {\n\t\t\tklog.ErrorS(err, \"Failed to record appliedOverrides in cluster.\", \"cluster\", targetCluster.Name)\n\t\t\terrs = append(errs, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif features.FeatureGate.Enabled(features.StatefulFailoverInjection) {\n\t\t\t// we need to figure out if the targetCluster is in the cluster we are going to migrate application to.\n\t\t\t// If yes, we have to inject the preserved label state to the clonedWorkload.\n\t\t\tclonedWorkload = injectReservedLabelState(bindingSpec, targetCluster, clonedWorkload, len(targetClusters))\n\t\t}\n\n\t\tworkMeta := metav1.ObjectMeta{\n\t\t\tName:        names.GenerateWorkName(clonedWorkload.GetKind(), clonedWorkload.GetName(), clonedWorkload.GetNamespace()),\n\t\t\tNamespace:   workNamespace,\n\t\t\tFinalizers:  []string{util.ExecutionControllerFinalizer},\n\t\t\tLabels:      workLabel,\n\t\t\tAnnotations: annotations,\n\t\t}\n\n\t\tif err = ctrlutil.CreateOrUpdateWork(\n\t\t\tctx,\n\t\t\tc,\n\t\t\tworkMeta,\n\t\t\tclonedWorkload,\n\t\t\tctrlutil.WithSuspendDispatching(shouldSuspendDispatching(bindingSpec.Suspension, targetCluster)),\n\t\t\tctrlutil.WithPreserveResourcesOnDeletion(ptr.Deref(bindingSpec.PreserveResourcesOnDeletion, false)),\n\t\t); err != nil {\n\t\t\terrs = append(errs, err)\n\t\t\tcontinue\n\t\t}\n\t}\n\n\treturn errors.NewAggregate(errs)\n}\n</code></pre>\n<p><strong>关键步骤</strong>：</p>\n<ol>\n<li><strong>获取目标集群列表</strong>：从 <code>bindingSpec.Clusters</code> 中获取调度结果</li>\n<li><strong>为每个集群创建 Work</strong>：\n<ul>\n<li>克隆 workload</li>\n<li>根据调度结果调整副本数（<code>ReviseReplica</code>）</li>\n<li>应用 OverridePolicies</li>\n<li>创建 Work 对象</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"四rb-的数据结构\">四、RB 的数据结构</h2>\n<h3 id=\"41-resourcebindingspec\">4.1 ResourceBindingSpec</h3>\n<pre><code class=\"language-go\">type ResourceBindingSpec struct {\n    // 资源引用\n    Resource workv1alpha2.ObjectReference\n    \n    // 副本信息（从 ResourceInterpreter 获取）\n    Replicas *int32\n    ReplicaRequirements *ReplicaRequirements\n    Components []Component\n    \n    // 调度相关\n    Placement *Placement\n    Clusters []TargetCluster  // 调度结果，由 Scheduler 填充\n    SchedulerName string\n    \n    // 其他\n    PropagateDeps bool\n    Failover *FailoverBehavior\n    ConflictResolution ConflictResolution\n    // ...\n}\n</code></pre>\n<h3 id=\"42-关键字段说明\">4.2 关键字段说明</h3>\n<ul>\n<li><strong>Resource</strong>: 指向原始资源对象（Deployment、StatefulSet 等）</li>\n<li><strong>Replicas/ReplicaRequirements</strong>: 从资源中提取的副本数和资源需求</li>\n<li><strong>Clusters</strong>: <strong>由 Scheduler 填充</strong>，包含目标集群和分配的副本数</li>\n<li><strong>Placement</strong>: 调度策略（从哪里调度）</li>\n</ul>\n<h2 id=\"五关键概念快速索引\">五、关键概念快速索引</h2>\n<h3 id=\"51-核心资源对象\">5.1 核心资源对象</h3>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>定义</th>\n<th>作用域</th>\n<th>关键字段</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>PropagationPolicy</strong></td>\n<td>定义资源如何传播的策略</td>\n<td>Namespace</td>\n<td>ResourceSelectors, Placement, Priority</td>\n</tr>\n<tr>\n<td><strong>ClusterPropagationPolicy</strong></td>\n<td>集群级别的传播策略</td>\n<td>Cluster</td>\n<td>同 PropagationPolicy</td>\n</tr>\n<tr>\n<td><strong>ResourceBinding</strong></td>\n<td>资源对象和策略的绑定</td>\n<td>Namespace</td>\n<td>Resource, Replicas, Clusters</td>\n</tr>\n<tr>\n<td><strong>ClusterResourceBinding</strong></td>\n<td>集群级别的资源绑定</td>\n<td>Cluster</td>\n<td>同 ResourceBinding</td>\n</tr>\n<tr>\n<td><strong>Work</strong></td>\n<td>实际发送到成员集群的工作负载</td>\n<td>Namespace</td>\n<td>Workload.Manifests, Status</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"52-核心组件\">5.2 核心组件</h3>\n<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>职责</th>\n<th>关键操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>ResourceDetector</strong></td>\n<td>检测资源并创建 RB</td>\n<td>ApplyPolicy, BuildResourceBinding</td>\n</tr>\n<tr>\n<td><strong>Scheduler</strong></td>\n<td>为 RB 选择目标集群</td>\n<td>填充 Spec.Clusters</td>\n</tr>\n<tr>\n<td><strong>ResourceBindingController</strong></td>\n<td>将 RB 转换为 Work</td>\n<td>syncBinding, ensureWork</td>\n</tr>\n<tr>\n<td><strong>ResourceInterpreter</strong></td>\n<td>解释资源结构</td>\n<td>GetReplicas, ReviseReplica</td>\n</tr>\n<tr>\n<td><strong>ExecutionController</strong></td>\n<td>在成员集群执行 Work</td>\n<td>syncToClusters</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"53-关键数据结构\">5.3 关键数据结构</h3>\n<h4 id=\"placement放置规则\">Placement（放置规则）</h4>\n<pre><code class=\"language-470:524:pkg/apis/policy/v1alpha1/propagation_types.go\">type Placement struct {\n\t// ClusterAffinity represents scheduling restrictions to a certain set of clusters.\n\t// Note:\n\t//   1. ClusterAffinity can not co-exist with ClusterAffinities.\n\t//   2. If both ClusterAffinity and ClusterAffinities are not set, any cluster\n\t//      can be scheduling candidates.\n\t// +optional\n\tClusterAffinity *ClusterAffinity `json:\"clusterAffinity,omitempty\"`\n\n\t// ClusterAffinities represents scheduling restrictions to multiple cluster\n\t// groups that indicated by ClusterAffinityTerm.\n\t//\n\t// The scheduler will evaluate these groups one by one in the order they\n\t// appear in the spec, the group that does not satisfy scheduling restrictions\n\t// will be ignored which means all clusters in this group will not be selected\n\t// unless it also belongs to the next group(a cluster could belong to multiple\n\t// groups).\n\t//\n\t// If none of the groups satisfy the scheduling restrictions, then scheduling\n\t// fails, which means no cluster will be selected.\n\t//\n\t// Note:\n\t//   1. ClusterAffinities can not co-exist with ClusterAffinity.\n\t//   2. If both ClusterAffinity and ClusterAffinities are not set, any cluster\n\t//      can be scheduling candidates.\n\t//\n\t// Potential use case 1:\n\t// The private clusters in the local data center could be the main group, and\n\t// the managed clusters provided by cluster providers could be the secondary\n\t// group. So that the Karmada scheduler would prefer to schedule workloads\n\t// to the main group and the second group will only be considered in case of\n\t// the main group does not satisfy restrictions(like, lack of resources).\n\t//\n\t// Potential use case 2:\n\t// For the disaster recovery scenario, the clusters could be organized to\n\t// primary and backup groups, the workloads would be scheduled to primary\n\t// clusters firstly, and when primary cluster fails(like data center power off),\n\t// Karmada scheduler could migrate workloads to the backup clusters.\n\t//\n\t// +optional\n\tClusterAffinities []ClusterAffinityTerm `json:\"clusterAffinities,omitempty\"`\n\n\t// ClusterTolerations represents the tolerations.\n\t// +optional\n\tClusterTolerations []corev1.Toleration `json:\"clusterTolerations,omitempty\"`\n\n\t// SpreadConstraints represents a list of the scheduling constraints.\n\t// +optional\n\tSpreadConstraints []SpreadConstraint `json:\"spreadConstraints,omitempty\"`\n\n\t// ReplicaScheduling represents the scheduling policy on dealing with the number of replicas\n\t// when propagating resources that have replicas in spec (e.g. deployments, statefulsets) to member clusters.\n\t// +optional\n\tReplicaScheduling *ReplicaSchedulingStrategy `json:\"replicaScheduling,omitempty\"`\n}\n</code></pre>\n<p><strong>字段说明</strong>：</p>\n<ul>\n<li><strong>ClusterAffinity</strong>: 首选哪些集群（通过标签、字段、集群名选择）</li>\n<li><strong>ClusterTolerations</strong>: 集群容忍度（类似 Pod 的 Tolerations）</li>\n<li><strong>SpreadConstraints</strong>: 分散约束（如：最多 3 个集群，每个集群至少 1 个副本）</li>\n<li><strong>ReplicaScheduling</strong>: 副本调度策略（Duplicated 或 Divided）</li>\n</ul>\n<h4 id=\"resourcebindingspec\">ResourceBindingSpec</h4>\n<p>RB 的 Spec 包含：</p>\n<ul>\n<li><strong>Resource</strong>: 资源引用（APIVersion, Kind, Name, Namespace, UID）</li>\n<li><strong>Replicas</strong>: 副本数（从 ResourceInterpreter 获取）</li>\n<li><strong>ReplicaRequirements</strong>: 资源需求（CPU、内存等）</li>\n<li><strong>Clusters</strong>: 目标集群列表（<strong>由 Scheduler 填充</strong>）</li>\n<li><strong>Placement</strong>: 放置规则（从 PropagationPolicy 复制）</li>\n<li><strong>Failover</strong>: 故障转移行为</li>\n</ul>\n<p><strong>重要</strong>：<code>Spec.Clusters</code> 是调度结果，ResourceDetector 和 BindingController 都不会修改它。</p>\n<h3 id=\"54-执行空间execution-space\">5.4 执行空间（Execution Space）</h3>\n<p>每个成员集群都有一个对应的 namespace：</p>\n<ul>\n<li><strong>命名规则</strong>: <code>execution-{cluster-name}</code></li>\n<li><strong>作用</strong>: 存放发送到该集群的所有 Work</li>\n<li><strong>示例</strong>:\n<ul>\n<li>集群 <code>member1</code> → namespace <code>execution-member1</code></li>\n<li>集群 <code>member2</code> → namespace <code>execution-member2</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"55-故障转移failover\">5.5 故障转移（Failover）</h3>\n<p><strong>FailoverBehavior</strong> 定义了在应用或集群故障时的行为：</p>\n<pre><code class=\"language-328:392:pkg/apis/policy/v1alpha1/propagation_types.go\">// FailoverBehavior indicates failover behaviors in case of an application or\n// cluster failure.\ntype FailoverBehavior struct {\n\t// Application indicates failover behaviors in case of application failure.\n\t// If this value is nil, failover is disabled.\n\t// If set, the PropagateDeps should be true so that the dependencies could\n\t// be migrated along with the application.\n\t// +optional\n\tApplication *ApplicationFailoverBehavior `json:\"application,omitempty\"`\n\n\t// Cluster indicates failover behaviors in case of cluster failure.\n\t// If this value is nil, the failover behavior in case of cluster failure\n\t// will be controlled by the controller's no-execute-taint-eviction-purge-mode\n\t// parameter.\n\t// If set, the failover behavior in case of cluster failure will be defined\n\t// by this value.\n\t// +optional\n\tCluster *ClusterFailoverBehavior `json:\"cluster,omitempty\"`\n}\n\n// ApplicationFailoverBehavior indicates application failover behaviors.\ntype ApplicationFailoverBehavior struct {\n\t// DecisionConditions indicates the decision conditions of performing the failover process.\n\t// Only when all conditions are met can the failover process be performed.\n\t// Currently, DecisionConditions includes several conditions:\n\t// - TolerationSeconds (optional)\n\t// +required\n\tDecisionConditions DecisionConditions `json:\"decisionConditions\"`\n\n\t// PurgeMode represents how to deal with the legacy applications on the\n\t// cluster from which the application is migrated.\n\t// Valid options are \"Directly\", \"Gracefully\", \"Never\", \"Immediately\"(deprecated),\n\t// and \"Graciously\"(deprecated).\n\t// Defaults to \"Gracefully\".\n\t// +kubebuilder:validation:Enum=Directly;Gracefully;Never;Immediately;Graciously\n\t// +kubebuilder:default=Gracefully\n\t// +optional\n\tPurgeMode PurgeMode `json:\"purgeMode,omitempty\"`\n</code></pre>\n<p><strong>PurgeMode 说明</strong>：</p>\n<ul>\n<li><strong>Directly</strong>: 立即删除旧集群上的应用（用于不能容忍两个实例同时运行的应用，如 Flink）</li>\n<li><strong>Gracefully</strong>: 等待新集群上的应用健康后再删除（默认）</li>\n<li><strong>Never</strong>: 不删除，手动清理</li>\n</ul>\n<h2 id=\"六总结\">六、总结</h2>\n<h3 id=\"61-关键流程回顾\">6.1 关键流程回顾</h3>\n<ol>\n<li><strong>资源创建</strong> → ResourceDetector 检测</li>\n<li><strong>策略匹配</strong> → 找到匹配的 PropagationPolicy</li>\n<li><strong>创建 RB</strong> → BuildResourceBinding（性能瓶颈：Lua 脚本执行）</li>\n<li><strong>调度</strong> → Scheduler 填充 Spec.Clusters</li>\n<li><strong>转换 Work</strong> → ResourceBindingController 将 RB 转换为 Work</li>\n<li><strong>分发执行</strong> → Work 发送到成员集群执行</li>\n</ol>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 14:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Mephostopheles\">Mephostopheles</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Anthropic 如何评估 AI Agent",
      "link": "https://www.cnblogs.com/didispace/p/19477137",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/didispace/p/19477137\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 14:22\">\n    <span>Anthropic 如何评估 AI Agent</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"引言打破盲目飞行的开发循环\">引言：打破“盲目飞行”的开发循环</h2>\n<p>在开发AI智能体的过程中，许多团队都经历过这样的痛点：你修复了一个问题，却在不经意间引发了另一个更隐蔽的问题。如果没有一套可靠的评估体系，整个开发过程就像是在“盲目飞行”，团队陷入被动修复的循环，难以自信地发布新版本。</p>\n<p>有效的评估（evals）正是打破这一困境的关键。它能让智能体在行为上的变化和潜在问题在影响用户之前就变得清晰可见。本文将从Anthropic的深度分享中，提炼出五个最令人惊讶、最具影响力的核心教训，它们将彻底改变你对AI智能体评估的看法。</p>\n<h2 id=\"五个关于ai智能体评估的反直觉教训\">五个关于AI智能体评估的反直觉教训</h2>\n<h3 id=\"教训一别等了从20个失败案例开始构建你的评估体系\">教训一：别等了，从20个失败案例开始构建你的评估体系</h3>\n<p>团队在项目初期常常认为构建评估体系是一项巨大的“开销”，会拖慢产品上市的进度，因此选择推迟。他们认为，等产品功能稳定、规模化之后再来考虑评估也不迟。</p>\n<p>然而，Anthropic的经验恰恰相反：等到智能体规模化后才开始构建评估，你会遇到更大的困难。更重要的是，评估的价值会随着时间复利增长。早期投入不仅不会拖慢你，反而会成为未来加速迭代的引擎。那么，该如何开始呢？其实门槛比你想象的要低得多：</p>\n<p>“实际上，一套由20-50个源自真实失败案例的简单任务，就是一个绝佳的起点。”</p>\n<p>这个观点之所以重要，是因为它彻底打破了“评估体系必须庞大而完美”的误区。这不仅仅是关于避免技术债，更是为了获得开发过程中的能见度。用一小组真实的失败案例起步，就等于为你的驾驶舱安装了第一批仪表，让你停止“盲目飞行”，开始用数据导航。</p>\n<h3 id=\"教训二当你的智能体失败时可能恰恰是天才的体现\">教训二：当你的智能体“失败”时，可能恰恰是天才的体现</h3>\n<p>我们通常认为，评估失败就意味着智能体犯了错。但有时，这种“失败”恰恰是其卓越创造力的体现。</p>\n<p>以Anthropic提到的 Opus 4.5 模型为例，在一个预订航班的测试任务中，它没有遵循预设的流程，而是通过发现政策中的一个漏洞，为用户找到了一个更好的解决方案。从字面上看，它“失败”了这次评估，因为它没有按照人类设计的死板路径执行任务。但从用户的角度看，它取得了巨大的成功。</p>\n<p>“它‘失败’了书面上的评估，但实际上为用户想出了一个更好的解决方案。”</p>\n<p>这个例子深刻地揭示了静态评估的局限性。这并非简单的程序错误，而是前沿模型的一个典型特征：它们的解决问题的能力，已经开始超越那些嵌入在旧式评估里的、基于静态规则的假设。依赖僵化的路径评估无异于另一种“盲目飞行”，因为它让你对模型自身的天才之处视而不见。学会识别这些“天才般”的失败，才能让你真正看清你所解锁的前沿能力。</p>\n<h3 id=\"教训三评估终点而非过程\">教训三：评估终点，而非过程</h3>\n<p>在评估智能体时，一个常见的错误是检查它是否遵循了一套非常具体的步骤，比如是否按照特定顺序调用了某些工具。这种方法看似严谨，实则非常脆弱。</p>\n<p>Anthropic指出，这种方法“过于僵化，会导致测试过于脆弱”，因为它会惩罚那些评估设计者未曾预料到的、同样有效的创新方法。一个更优越、更具前瞻性的做法是：评估智能体最终产出的成果（outcome），而不是它所采取的具体路径（path）。</p>\n<p>例如，与其检查一个编码智能体是否调用了某个特定的编辑函数，不如直接评估它生成的代码是否通过了所有的单元测试。专注于过程本身就是一种“盲目飞行”，因为它让你对那些更优越、未曾预见的解决方案视而不见。而专注于最终成果，才是获得智能体究竟为用户完成了什么的真实视野。这一教训对于释放AI智能体的全部潜力至关重要。</p>\n<h3 id=\"教训四你的指标在衡量什么一次成功还是次次可靠\">教训四：你的指标在衡量什么：一次成功还是次次可靠？</h3>\n<p>“我们的智能体成功率是75%。” 这句话听起来不错，但它可能隐藏着巨大的误导性。你需要问一个更深层次的问题：这个成功率衡量的是什么？是多次尝试中的一次成功，还是每一次尝试都必须成功？这里有两个关键指标：pass@k 和 pass^k。</p>\n<ul>\n<li>pass@k 衡量的是智能体在 k 次尝试中至少有一次成功的可能性。你可以把它比作“多次射门，只要进一个球就算成功”。这个指标适用于那些只要找到一个可行解就行的场景，比如代码生成或创意构思。</li>\n<li>pass^k 衡量的是智能体在全部 k 次尝试中每次都成功的概率。这更像是“要求每次射门都必须命中”。对于需要高度可靠和一致性的面向客户的智能体来说，这个指标至关重要。</li>\n</ul>\n<p>这两个指标的差异巨大。例如，如果一个智能体的单次成功率（pass@1）是75%，那么它连续成功3次的概率（pass^3）就骤降至42.1875%，约等于42% (0.75 x 0.75 x 0.75)。</p>\n<p>为需要高可靠性的面向客户的智能体使用 pass@k 指标，是导致用户流失的温床。因为75%的单次成功率掩盖了在仅仅三次交互中，性能稳定率甚至不足50%的残酷事实。这不仅仅是统计学上的选择，更是决定产品定位的战略抉择。你是在打造一个创意性的头脑风暴伙伴，十次尝试有一次绝妙点子就算巨大成功（pass@k）？还是在构建一个关键任务型支持助手，任何低于近乎完美的可靠性都是不可接受的（pass^k）？你的指标选择，决定了你的优化方向。</p>\n<h3 id=\"教训五你最强大的评估工具不是代码而是你的眼睛\">教训五：你最强大的评估工具不是代码，而是你的眼睛</h3>\n<p>在追求自动化的过程中，我们很容易过度依赖冷冰冰的评估分数。然而，分数可能是骗人的。一个误导性的低分可能不是因为智能体失败了，而是因为评估本身存在缺陷。</p>\n<p>例如，Anthropic在对Opus 4.5模型进行CORE-Bench基准测试时，通过人工审查记录发现，其分数从最初的42%跃升至95%。原因何在？仅仅是修复了评估系统中的问题，比如过于僵化的评分标准（它会因为“96.12”与预期格式“96.124991…”不完全匹配而判定为错误）。如果没有阅读完整的试验记录（transcript），团队会错误地认为模型的能力远比实际情况要差。</p>\n<p>“阅读记录是验证你的评估是否在衡量真正重要的事情的方式，也是智能体开发的一项关键技能。”</p>\n<p>信任分数而不去阅读记录，是终极的“盲目飞行”——仪表盘显示你在急速下坠，但实际上你可能飞得比以往任何时候都高，只是你的仪表坏了。自动化工具告诉你“是什么”（分数是42%），但只有深入审查记录才能揭示“为什么”——不是因为模型不行，而是因为评估本身存在缺陷。</p>\n<h2 id=\"结论将评估视为核心战略而非事后弥补\">结论：将评估视为核心战略，而非事后弥补</h2>\n<p>有效的评估不是开发过程中的负担，而是一种能够加速开发、确保质量的核心战略资产。它能将团队成员模糊的“感觉变差了”转化为了清晰、可操作的衡量指标。</p>\n<p>成功的AI团队都明白一个道理：评估体系是产品不可或缺的一部分，其重要性不亚于单元测试之于传统软件。而且，在模型能力飞速发展的时代，一个强大的评估套件就是你的护城河。它能让你在几天内验证并部署更先进的模型，而你的竞争对手可能还在数周的手动测试中苦苦挣扎。</p>\n<p>如果你的评估体系反映了你最看重的东西，那么它正在讲述一个关于你智能体的核心故事。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 14:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/didispace\">程序猿DD</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "openEuler 安装 K3S",
      "link": "https://www.cnblogs.com/ghostmen/p/19477120",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ghostmen/p/19477120\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 14:22\">\n    <span>openEuler 安装 K3S</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"openeuler-安装-k3s\">openEuler 安装 K3S</h1>\n<blockquote>\n<p>参考文献：</p>\n<p>K3S官方：<a href=\"https://www.rancher.cn/k3s/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.rancher.cn/k3s/</a></p>\n<p>K3S官方中文文档：<a href=\"https://docs.rancher.cn/k3s/\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.rancher.cn/k3s/</a></p>\n<p>下载网址：<a href=\"https://github.com/k3s-io/k3s/releases/tag/v1.35.0+k3s1\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/k3s-io/k3s/releases/tag/v1.35.0+k3s1</a></p>\n</blockquote>\n<h2 id=\"安装要求介绍\">安装要求介绍</h2>\n<p>K3s 非常轻巧，但有一些最低要求，如下所述。</p>\n<p>无论您是将 K3s 集群配置为在 Docker 还是 Kubernetes 设置中运行，运行 K3s 的每个节点都应该满足以下最低要求。你可能需要更多的资源来满足你的需求。</p>\n<h3 id=\"先决条件\">先决条件</h3>\n<p>-两个节点不能有相同的主机名。如果您的所有节点都有相同的主机名，请使用<code>--with-node-id</code>选项为每个节点添加一个随机后缀，或者为您添加到集群的每个节点设计一个独特的名称，用<code>--node-name</code>或<code>$K3S_NODE_NAME</code>传递。</p>\n<h3 id=\"操作系统\">操作系统</h3>\n<p>K3s 有望在大多数现代 Linux 系统上运行。</p>\n<p>有些操作系统有特定要求：</p>\n<ul>\n<li>如果您使用的是<strong>Raspbian Buster</strong>，请按照<a href=\"https://docs.rancher.cn/docs/k3s/advanced/#%E5%9C%A8-raspbian-buster-%E4%B8%8A%E5%90%AF%E7%94%A8%E6%97%A7%E7%89%88%E7%9A%84-iptables\" rel=\"noopener nofollow\" target=\"_blank\">这些步骤</a>切换到传统的 iptables。</li>\n<li>如果您使用的是<strong>Alpine Linux</strong>，请按照<a href=\"https://docs.rancher.cn/docs/k3s/advanced/#alpine-linux-%E5%AE%89%E8%A3%85%E7%9A%84%E9%A2%9D%E5%A4%96%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\" rel=\"noopener nofollow\" target=\"_blank\">这些步骤</a>进行额外设置。</li>\n<li>如果您使用的是<strong>Red Hat/CentOS</strong>，请按照<a href=\"https://docs.rancher.cn/docs/k3s/advanced/#Red-Hat-%E5%92%8C-CentOS-%E7%9A%84%E9%A2%9D%E5%A4%96%E5%87%86%E5%A4%87\" rel=\"noopener nofollow\" target=\"_blank\">这些步骤</a>进行额外设置。</li>\n</ul>\n<p>关于 Rancher 管理的 K3s 集群测试了哪些操作系统的更多信息，请参考<a href=\"https://rancher.com/support-maintenance-terms/\" rel=\"noopener nofollow\" target=\"_blank\">Rancher 支持和维护条款。</a></p>\n<h3 id=\"硬件\">硬件</h3>\n<p>硬件要求根据您部署的规模而变化。这里列出了最低建议。</p>\n<h4 id=\"cpu-和内存\">CPU 和内存</h4>\n<ul>\n<li>CPU： 最低 1</li>\n<li>内存： 最低 512MB（建议至少为 1GB）</li>\n</ul>\n<p><a href=\"https://docs.rancher.cn/docs/k3s/installation/installation-requirements/resource-profiling/\" rel=\"noopener nofollow\" target=\"_blank\">本节</a>的测试结果是为了确定 K3s agent、具有工作负载的 K3s server 和具有一个 agent 的 K3s server 的最低资源要求。它还包含了有关对 K3s server 和 agent 利用率产生最大影响的分析，以及如何保护集群数据存储免受 agent 和工作负载的干扰。</p>\n<h4 id=\"磁盘\">磁盘</h4>\n<p>K3s 的性能取决于数据库的性能。为了确保最佳速度，我们建议尽可能使用 SSD。在使用 SD 卡或 eMMC 的 ARM 设备上，磁盘性能会有所不同。</p>\n<h3 id=\"网络\">网络</h3>\n<p>K3s server 需要 6443 端口才能被所有节点访问。</p>\n<p>当使用 Flannel VXLAN 时，节点需要能够通过 UDP 端口 8472 访问其他节点，或者当使用 Flannel Wireguard 后端时，节点需要能够通过 UDP 端口 51820 和 51821（使用 IPv6 时）访问其他节点。该节点不应侦听任何其他端口。 K3s 使用反向隧道，以便节点与服务器建立出站连接，并且所有 kubelet 流量都通过该隧道运行。但是，如果你不使用 Flannel 并提供自己的自定义 CNI，那么 K3s 不需要 Flannel 所需的端口。</p>\n<p>如果要使用<code>metrics server</code>，则需要在每个节点上打开端口 10250 端口。</p>\n<p>如果计划使用嵌入式 etcd 实现高可用性，则 server 节点必须在端口 2379 和 2380 上可以相互访问。</p>\n<p>重要</p>\n<p>节点上的 VXLAN 端口不应公开暴露，因为它公开了集群网络，任何人都可以访问它。应在禁止访问端口 8472 的防火墙/安全组后面运行节点。</p>\n<blockquote>\n<p><strong>警告：</strong> Flannel 依靠 <a href=\"https://www.cni.dev/plugins/current/main/bridge/\" rel=\"noopener nofollow\" target=\"_blank\">Bridge CNI plugin</a> 来创建一个可以交换流量的 L2 网络。具有 NET_RAW 功能的 Rogue pod 可以滥用该 L2 网络来发动攻击，如 [ARP 欺骗](<a href=\"https://static.sched.com/hosted_files/kccncna19/72/ARP\" rel=\"noopener nofollow\" target=\"_blank\">https://static.sched.com/hosted_files/kccncna19/72/ARP</a> DNS spoof.pdf)。因此，正如 <a href=\"https://kubernetes.io/docs/concepts/security/pod-security-standards/\" rel=\"noopener nofollow\" target=\"_blank\">kubernetes 文档</a>中记载的那样，请设置一个受限配置文件，在不可信任的 pod 上禁用 NET_RAW。</p>\n</blockquote>\n<p>K3s Server 节点的入站规则如下：</p>\n<table>\n<thead>\n<tr>\n<th>协议</th>\n<th>端口</th>\n<th>源</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TCP</td>\n<td>6443</td>\n<td>K3s agent 节点</td>\n<td>Kubernetes API Server</td>\n</tr>\n<tr>\n<td>UDP</td>\n<td>8472</td>\n<td>K3s server 和 agent 节点</td>\n<td>仅对 Flannel VXLAN 需要</td>\n</tr>\n<tr>\n<td>UDP</td>\n<td>51820</td>\n<td>K3s server 和 agent 节点</td>\n<td>只有 Flannel Wireguard 后端需要</td>\n</tr>\n<tr>\n<td>UDP</td>\n<td>51821</td>\n<td>K3s server 和 agent 节点</td>\n<td>只有使用 IPv6 的 Flannel Wireguard 后端才需要</td>\n</tr>\n<tr>\n<td>TCP</td>\n<td>10250</td>\n<td>K3s server 和 agent 节点</td>\n<td>Kubelet metrics</td>\n</tr>\n<tr>\n<td>TCP</td>\n<td>2379-2380</td>\n<td>K3s server 节点</td>\n<td>只有嵌入式 etcd 高可用才需要</td>\n</tr>\n</tbody>\n</table>\n<p>通常情况下，所有出站流量都是允许的。</p>\n<h2 id=\"安装选项介绍\">安装选项介绍</h2>\n<h3 id=\"使用脚本安装的选项\">使用脚本安装的选项</h3>\n<p>正如<a href=\"https://docs.rancher.cn/docs/k3s/quick-start/\" rel=\"noopener nofollow\" target=\"_blank\">快速启动指南</a>中提到的那样，你可以使用<a href=\"https://get.k3s.io/\" rel=\"noopener nofollow\" target=\"_blank\">https://get.k3s.io</a> 提供的安装脚本在基于 systemd 和 openrc 的系统上安装 K3s 作为服务。</p>\n<p>该命令的最简单形式如下：</p>\n<pre><code class=\"language-sh\">curl -sfL https://get.k3s.io | sh -\n</code></pre>\n<p>使用此方法安装 K3s 时，可使用以下环境变量来配置安装:</p>\n<table>\n<thead>\n<tr>\n<th>Environment Variable</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>INSTALL_K3S_SKIP_DOWNLOAD</code></td>\n<td>如果设置为 \"true \"将不会下载 K3s 的哈希值或二进制。</td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_SYMLINK</code></td>\n<td>默认情况下，如果路径中不存在命令，将为 kubectl、crictl 和 ctr 二进制文件创建符号链接。如果设置为'skip'将不会创建符号链接，而'force'将覆盖。</td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_SKIP_ENABLE</code></td>\n<td>如果设置为 \"true\"，将不启用或启动 K3s 服务。</td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_SKIP_START</code></td>\n<td>如果设置为 \"true \"将不会启动 K3s 服务。</td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_VERSION</code></td>\n<td>从 Github 下载 K3s 的版本。如果没有指定，将尝试从\"stable\"频道下载。</td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_BIN_DIR</code></td>\n<td>安装 K3s 二进制文件、链接和卸载脚本的目录，或者使用<code>/usr/local/bin</code>作为默认目录。</td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_BIN_DIR_READ_ONLY</code></td>\n<td>如果设置为 true 将不会把文件写入<code>INSTALL_K3S_BIN_DIR</code>，强制设置<code>INSTALL_K3S_SKIP_DOWNLOAD=true</code>。</td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_SYSTEMD_DIR</code></td>\n<td>安装 systemd 服务和环境文件的目录，或者使用<code>/etc/systemd/system</code>作为默认目录。</td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_EXEC</code></td>\n<td>带有标志的命令，用于在服务中启动 K3s。如果未指定命令，并且设置了<code>K3S_URL</code>，它将默认为“agent”。如果未设置<code>K3S_URL</code>，它将默认为“server”。要获得帮助，请参考<a href=\"https://docs.rancher.cn/docs/k3s/installation/install-options/how-to-flags/#%E7%A4%BA%E4%BE%8B-b-install_k3s_exec\" rel=\"noopener nofollow\" target=\"_blank\">此示例。</a></td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_NAME</code></td>\n<td>要创建的 systemd 服务名称，如果以服务器方式运行 k3s，则默认为'k3s'；如果以 agent 方式运行 k3s，则默认为'k3s-agent'。如果指定了服务名，则服务名将以'k3s-'为前缀。</td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_TYPE</code></td>\n<td>要创建的 systemd 服务类型，如果没有指定，将默认使用 K3s exec 命令。</td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_SELINUX_WARN</code></td>\n<td>如果设置为 true，则在没有找到 k3s-selinux 策略的情况下将继续。</td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_SKIP_SELINUX_RPM</code></td>\n<td>如果设置为 \"true \"将跳过 k3s RPM 的自动安装。</td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_CHANNEL_URL</code></td>\n<td>用于获取 K3s 下载网址的频道 URL。默认为 <a href=\"https://update.k3s.io/v1-release/channels\" rel=\"noopener nofollow\" target=\"_blank\">https://update.k3s.io/v1-release/channels</a> 。</td>\n</tr>\n<tr>\n<td><code>INSTALL_K3S_CHANNEL</code></td>\n<td>用于获取 K3s 下载 URL 的通道。默认值为 \"stable\"。选项包括：<code>stable</code>, <code>latest</code>, <code>testing</code>。</td>\n</tr>\n<tr>\n<td><code>K3S_CONFIG_FILE</code></td>\n<td>指定配置文件的位置。默认目录为<code>/etc/rancher/k3s/config.yaml</code>。</td>\n</tr>\n<tr>\n<td><code>K3S_TOKEN</code></td>\n<td>用于将 server 或 agent 加入集群的共享 secret。</td>\n</tr>\n<tr>\n<td><code>K3S_TOKEN_FILE</code></td>\n<td>指定 <code>cluster-secret</code>,<code>token</code> 的文件目录。</td>\n</tr>\n</tbody>\n</table>\n<p>这个例子介绍了如何使用上述的环境变量（在管道之后）：</p>\n<pre><code class=\"language-bash\">curl -sfL https://get.k3s.io | INSTALL_K3S_CHANNEL=latest sh -\n</code></pre>\n<p>以 \"K3S_\"开头的环境变量将被保留，供 systemd 和 openrc 服务使用。</p>\n<p>在没有明确设置 exec 命令的情况下设置<code>K3S_URL</code>，会将命令默认为 \"agent\"。</p>\n<p>运行 agent 时还必须设置<code>K3S_TOKEN</code>。</p>\n<h3 id=\"从二进制安装的选项\">从二进制安装的选项</h3>\n<p>如上所述，安装脚本主要是配置 K3s 作为服务运行。如果你选择不使用脚本，你可以通过从我们的<a href=\"https://github.com/rancher/k3s/releases/latest\" rel=\"noopener nofollow\" target=\"_blank\">发布页面</a>下载二进制文件，将其放在你的路径上，然后执行它来运行 K3s。K3s 二进制支持以下命令：</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>k3s server</code></td>\n<td>运行 K3s server，它还将启动 Kubernetes control-plane 组件，如 API server, controller-manager, 和 scheduler。</td>\n</tr>\n<tr>\n<td><code>k3s agent</code></td>\n<td>运行 K3s agent 节点。这将使 K3s 作为工作节点运行，启动 Kubernetes 节点服务<code>kubelet</code>和<code>kube-proxy</code>。</td>\n</tr>\n<tr>\n<td><code>k3s kubectl</code></td>\n<td>运行嵌入式<a href=\"https://kubernetes.io/docs/reference/kubectl/overview/\" rel=\"noopener nofollow\" target=\"_blank\">kubectl</a> CLI。如果没有设置<code>KUBECONFIG</code>环境变量，当启动 K3s 服务器节点时，将自动尝试使用在<code>/etc/rancher/k3s/k3s.yaml</code>创建的配置文件。</td>\n</tr>\n<tr>\n<td><code>k3s crictl</code></td>\n<td>运行一个嵌入式<a href=\"https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md\" rel=\"noopener nofollow\" target=\"_blank\">crictl</a>。这是一个用于与 Kubernetes 的容器运行时接口（CRI）交互的 CLI。对调试很有用。</td>\n</tr>\n<tr>\n<td><code>k3s ctr</code></td>\n<td>运行一个嵌入式的<a href=\"https://github.com/projectatomic/containerd/blob/master/docs/cli.md\" rel=\"noopener nofollow\" target=\"_blank\">ctr</a>。这是为 containerd（K3s 使用的容器守护进程）提供的 CLI。对调试很有用。</td>\n</tr>\n<tr>\n<td><code>k3s help</code></td>\n<td>显示一个命令的命令列表或帮助。</td>\n</tr>\n</tbody>\n</table>\n<p><code>k3s server</code> 和 <code>k3s agent</code> 命令有额外的配置选项，可以通过 <code>k3s server --help</code> 或 <code>k3s agent --help</code> 查看.</p>\n<h2 id=\"正式安装\">正式安装</h2>\n<p>本文安装选择为二进制文件安装，原因为安装环境不可联网</p>\n<p>下载链接：<a href=\"https://github.com/k3s-io/k3s/releases\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/k3s-io/k3s/releases</a></p>\n<p>下载安装文件<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"步骤1配置目录结构\">步骤1：配置目录结构</h3>\n<pre><code class=\"language-bash\"># 创建必要的目录\nsudo mkdir -p /var/lib/rancher/k3s/agent/images/\nsudo mkdir -p /usr/local/bin/\n\n# 将离线镜像复制到正确位置\nsudo cp /tmp/k3s-airgap-images-amd64.tar.gz /var/lib/rancher/k3s/agent/images/\n\n# 安装 k3s 二进制文件\nsudo cp /tmp/k3s /usr/local/bin/\nsudo chmod +x /usr/local/bin/k3s\n</code></pre>\n<h3 id=\"步骤2导入容器镜像\">步骤2：导入容器镜像</h3>\n<pre><code class=\"language-bash\"># 方法1：使用 k3s ctr 命令导入（推荐）\nsudo k3s ctr images import /var/lib/rancher/k3s/agent/images/k3s-airgap-images-amd64.tar.gz\n\n# 方法2：如果已安装 K3s，使用 k3s 命令导入\nsudo k3s ctr images import /var/lib/rancher/k3s/agent/images/k3s-airgap-images-amd64.tar.gz\n</code></pre>\n<h3 id=\"步骤3安装-k3s离线模式\">步骤3：安装 K3s（离线模式）</h3>\n<p><strong>方法A：使用离线安装脚本</strong></p>\n<pre><code class=\"language-bash\"># 1. 下载安装脚本（在能联网的机器上）\ncurl -sfL https://get.k3s.io &gt; install.sh\nchmod +x install.sh\n\n# 2. 传输到 openEuler 并安装\nINSTALL_K3S_SKIP_DOWNLOAD=true \\\nINSTALL_K3S_EXEC=\"server\" \\\n./install.sh\n</code></pre>\n<p><strong>方法B：手动安装</strong></p>\n<pre><code class=\"language-bash\"># 创建配置文件\nsudo tee /etc/systemd/system/k3s.service &lt;&lt; EOF\n[Unit]\nDescription=Lightweight Kubernetes\nDocumentation=https://k3s.io\nAfter=network-online.target\n\n[Service]\nType=notify\nEnvironmentFile=/etc/systemd/system/k3s.service.env\nExecStartPre=-/sbin/modprobe br_netfilter\nExecStartPre=-/sbin/modprobe overlay\nExecStart=/usr/local/bin/k3s server\nKillMode=process\nDelegate=yes\nLimitNOFILE=infinity\nLimitNPROC=infinity\nLimitCORE=infinity\nTasksMax=infinity\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n# 创建环境变量文件\nsudo tee /etc/systemd/system/k3s.service.env &lt;&lt; EOF\nK3S_TOKEN=my-secret-token\nK3S_KUBECONFIG_MODE=644\nEOF\n</code></pre>\n<h3 id=\"步骤4启动-k3s\">步骤4：启动 K3s</h3>\n<pre><code class=\"language-bash\"># 启动服务\nsudo systemctl daemon-reload\nsudo systemctl enable k3s\nsudo systemctl start k3s\n\n# 检查状态\nsudo systemctl status k3s\nsudo journalctl -u k3s -f\n\n# 验证安装\nsudo k3s kubectl get nodes\nsudo k3s kubectl get pods -A\n</code></pre>\n<h2 id=\"3-安装-k3s-agent如果需要\">3. 安装 K3s Agent（如果需要）</h2>\n<pre><code class=\"language-bash\"># 在 agent 节点上执行\nINSTALL_K3S_SKIP_DOWNLOAD=true \\\nK3S_URL=https://server-ip:6443 \\\nK3S_TOKEN=your-token-from-server \\\n./install.sh agent\n</code></pre>\n<h2 id=\"4-配置-k3s可选\">4. 配置 K3s（可选）</h2>\n<h3 id=\"配置-k3s-参数\">配置 K3s 参数</h3>\n<pre><code class=\"language-bash\"># 编辑配置文件\nsudo tee /etc/rancher/k3s/config.yaml &lt;&lt; EOF\nwrite-kubeconfig-mode: \"0644\"\ntls-san:\n  - \"k3s-server.local\"\n  - \"192.168.1.100\"\nnode-ip: \"192.168.1.100\"\nadvertise-address: \"192.168.1.100\"\nEOF\n\n# 重启服务\nsudo systemctl restart k3s\n</code></pre>\n<h3 id=\"配置容器运行时\">配置容器运行时</h3>\n<pre><code class=\"language-bash\"># 如果需要使用 Docker 而不是 containerd\ncurl -sfL https://get.k3s.io | INSTALL_K3S_EXEC=\"--docker\" sh -\n\n# 离线模式下\nINSTALL_K3S_SKIP_DOWNLOAD=true \\\nINSTALL_K3S_EXEC=\"server --docker\" \\\n./install.sh\n</code></pre>\n<h2 id=\"5-验证安装\">5. 验证安装</h2>\n<pre><code class=\"language-bash\"># 检查 K3s 版本\nk3s --version\n\n# 检查集群状态\nsudo k3s kubectl cluster-info\n\n# 检查所有 Pod\nsudo k3s kubectl get pods --all-namespaces\n\n# 查看服务日志\nsudo journalctl -u k3s -f\n</code></pre>\n<h2 id=\"6-常见问题解决\">6. 常见问题解决</h2>\n<h3 id=\"问题1镜像导入失败\">问题1：镜像导入失败</h3>\n<pre><code class=\"language-bash\"># 检查镜像文件完整性\ntar -tzf /var/lib/rancher/k3s/agent/images/k3s-airgap-images-amd64.tar.gz | head\n\n# 重新导入\nsudo rm -rf /var/lib/rancher/k3s/agent/images/*\nsudo cp k3s-airgap-images-amd64.tar.gz /var/lib/rancher/k3s/agent/images/\nsudo k3s ctr images import /var/lib/rancher/k3s/agent/images/k3s-airgap-images-amd64.tar.gz\n</code></pre>\n<h3 id=\"问题2服务启动失败\">问题2：服务启动失败</h3>\n<pre><code class=\"language-bash\"># 查看详细日志\nsudo journalctl -u k3s -n 50 --no-pager\n\n# 检查端口占用\nsudo netstat -tlnp | grep 6443\n\n# 清理后重新安装\nsudo /usr/local/bin/k3s-uninstall.sh\n</code></pre>\n<h3 id=\"问题3openeuler-特定配置\">问题3：openEuler 特定配置</h3>\n<pre><code class=\"language-bash\"># 禁用防火墙（根据实际需求）\nsudo systemctl stop firewalld\nsudo systemctl disable firewalld\n\n# 或者配置防火墙规则\nsudo firewall-cmd --permanent --add-port=6443/tcp\nsudo firewall-cmd --permanent --add-port=8472/udp\nsudo firewall-cmd --reload\n\n# 配置 SELinux（如果启用）\nsudo setenforce 0\nsudo sed -i 's/SELINUX=enforcing/SELINUX=permissive/g' /etc/selinux/config\n</code></pre>\n<h2 id=\"7-管理命令\">7. 管理命令</h2>\n<pre><code class=\"language-bash\"># 停止 K3s\nsudo systemctl stop k3s\n\n# 重启 K3s\nsudo systemctl restart k3s\n\n# 卸载 K3s\nsudo /usr/local/bin/k3s-uninstall.sh\n\n# 查看 K3s 配置\nsudo cat /etc/rancher/k3s/k3s.yaml\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 14:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ghostmen\">ghostmen</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": ".NET Aspire 概述",
      "link": "https://www.cnblogs.com/powertoolsteam/p/19477015",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/powertoolsteam/p/19477015\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 14:05\">\n    <span>.NET Aspire 概述</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"引言\">引言</h2>\n<p>.NET Aspire 是 Microsoft 在 Build 2024 上推出的一个开源框架，旨在简化使用 .NET 8 及更高版本创建分布式云原生应用的流程。它通过提供一套工具、模板和最佳实践，让开发者能够更专注于业务逻辑而非基础设施的搭建。本文将详细介绍 .NET Aspire 的核心功能、优势以及如何快速上手使用这一创新框架。</p>\n<h3 id=\"什么是-net-aspire\">什么是 .NET Aspire？</h3>\n<p>.NET Aspire 是一个开源框架，它结合了以下关键元素：</p>\n<ul>\n<li>可组合应用的工具、模板和 NuGet 包</li>\n<li>本地编排与部署能力</li>\n<li>内置可观测性和遥测</li>\n<li>与 Redis、PostgreSQL、健康检查等服务的简化集成</li>\n</ul>\n<p>其目标是让开发人员专注于业务逻辑，而非基础设施流程，通过提供一个有主见、准备好生产环境的基线来实现这一目标。</p>\n<h3 id=\"核心功能\">核心功能</h3>\n<h4 id=\"1-编排与应用组合\">1. 编排与应用组合</h4>\n<p>Aspire 的核心是 AppHost，这是一个中央编排器，将多个 .NET 项目组合成可运行的分布式系统。有了它，开发者只需一个命令就能在本地运行整个应用，包括 API 服务、前端、数据库、缓存和消息队列。Aspire 负责处理依赖、容器设置和服务间配置。这种方法解决了本地 Docker Compose 设置的复杂性，并确保了开发与生产环境的一致性。</p>\n<h4 id=\"2-有意见的组件与服务默认\">2. 有意见的组件与服务默认</h4>\n<p>Aspire 包含 ServiceDefaults 库，它预装了以下最佳实践配置：</p>\n<ul>\n<li>OpenTelemetry（日志记录、分布式追踪、指标）</li>\n<li>健康检查</li>\n<li>服务发现（动态连接注入）</li>\n</ul>\n<p>这些默认设置可以通过一行代码（<code>builder.AddServiceDefaults()</code>）启用，即时为服务带来弹性和可观察性。</p>\n<h4 id=\"3-快速设置的模板与工具\">3. 快速设置的模板与工具</h4>\n<p>Aspire 支持 Visual Studio（v17.10+）、Visual Studio Code（配合 C# Dev Kit）以及通过模板实现的 .NET CLI。提供的模板包括\"Aspire Application\"和\"Aspire Starter Application\"，后者配备了 Blazor 前端，便于快速原型制作。这些模板为 AppHost、ServiceDefaults 以及可选的网页或 API 项目提供了支架，大大缩短了上线时间。</p>\n<h4 id=\"4-开发者仪表盘与可观察性\">4. 开发者仪表盘与可观察性</h4>\n<p>运行 Aspire 应用会弹出一个内置仪表盘，显示：</p>\n<ul>\n<li>日志</li>\n<li>跟踪与分布式请求路径</li>\n<li>运行时指标</li>\n<li>活动容器与环境变量</li>\n</ul>\n<p>仪表盘通常还包含 GitHub Copilot 集成，用于引导调试和洞察。</p>\n<h4 id=\"5-灵活部署选项\">5. 灵活部署选项</h4>\n<p>编排组合可以导出到部署清单中，便于部署到：</p>\n<ul>\n<li>Azure Container Apps</li>\n<li>Kubernetes 集群</li>\n<li>ECS、AWS Lambda 或任何容器平台</li>\n</ul>\n<p>这种方式避免了部署摩擦，同时保持配置一致性。</p>\n<h3 id=\"为什么要使用-net-aspire\">为什么要使用 .NET Aspire？</h3>\n<h4 id=\"提升开发者生产力\">提升开发者生产力</h4>\n<p>Aspire 简化了模板流程，不再需要手动管理服务布线、堆栈设置或遥测。新开发者的入职速度快且可重复，包括在 CI/CD 环境中。正如一位 Reddit 用户所说：\"在开发阶段，我有一个环境，可以 F5，同时拥有所有服务，包括健康检查、OTEL、种子...全部配置和可查看。我可以连接无限多个测试，运行相同的程序...在 CI/CD 中完全相同。</p>\n<h4 id=\"跨环境的一致性\">跨环境的一致性</h4>\n<p>通过统一对开发、测试和生产进行处理——使用相同的 AppHost 组合和默认值——Aspire 确保本地运行的就是部署的。这大大减少了环境漂移。</p>\n<h4 id=\"内置可观测性与弹性\">内置可观测性与弹性</h4>\n<p>遥测、健康检查、重试和诊断均默认启用，节省时间并确保监控和可靠性的一致性。</p>\n<h4 id=\"基础设施复杂度降低\">基础设施复杂度降低</h4>\n<p>Aspire 抽象化了容器编排、环境变量注入和服务发现逻辑，使开发者能够声明式地组合服务。它补充了但不取代 Kubernetes。事实上，部署可以同时使用 Aspire Manifests 和 Kubernetes 进行扩展。</p>\n<h3 id=\"主要特性概述\">主要特性概述</h3>\n<table>\n<thead>\n<tr>\n<th>特征</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AppHost 编排</td>\n<td>管理多服务应用组合和容器编排的中央项目</td>\n</tr>\n<tr>\n<td>服务默认</td>\n<td>预烘焙配置，用于遥测、健康检查、弹性和服务发现</td>\n</tr>\n<tr>\n<td>模板（CLI/IDE）</td>\n<td>.NET Aspire 应用的入门和全栈模板</td>\n</tr>\n<tr>\n<td>开发者仪表盘</td>\n<td>显示实时日志、指标、痕迹、容器的网页界面</td>\n</tr>\n<tr>\n<td>遥测（OpenTelemetry）</td>\n<td>内置日志、追踪、跨 ASP.NET 指标、gRPC、HTTP</td>\n</tr>\n<tr>\n<td>服务发现</td>\n<td>动态注入 deps、连接字符串、端点</td>\n</tr>\n<tr>\n<td>部署输出</td>\n<td>部署到 Azure、Kubernetes 和容器，使用一致的 manifests</td>\n</tr>\n<tr>\n<td>集成生态系统</td>\n<td>支持 Redis、PostgreSQL、MongoDB、EF Core、Azure Storage、Dapr、Orleans 等</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"真实世界经验与报道\">真实世界经验与报道</h3>\n<p>Visual Studio 杂志（2025 年 2 月）将 Aspire 描述为\"一个旨在简化.NET 分布式系统开发的云原生应用栈\"，强调自动仪表、健康检查、模板设置和仪表盘体验。</p>\n<p>InfoWorld（2025 年 7 月）重点介绍了 Aspire 的编排和可观测性，称赞其在本地组合、遥测和集成管理方面的能力，即使是复杂的多服务配置。仪表盘中与 GitHub Copilot 的集成被特别强调为提升生产力的工具。</p>\n<p>Code 杂志与 Syncfusion 提供 Aspire 编排优势的实用解释、明确的组件默认设置，以及使用 CLI 或 IDE 模板的逐步入门方法。</p>\n<p>社区反馈（Reddit）显示，用户报告称在本地编排、集成测试以及开发与 CI 之间的一致性行为方面，显著节省了大量时间。</p>\n<h3 id=\"入门-net-aspire\">入门 .NET Aspire</h3>\n<h4 id=\"先决条件\">先决条件</h4>\n<ul>\n<li>.NET 8 SDK</li>\n<li>Visual Studio 2022 （17.10+）或 VS Code 搭配 C# 开发工具包</li>\n<li>Container runtime （Docker/Podman）</li>\n</ul>\n<h4 id=\"安装-aspire\">安装 Aspire</h4>\n<pre><code class=\"language-bash\">dotnet workload install aspire\n</code></pre>\n<h4 id=\"创建项目\">创建项目</h4>\n<pre><code class=\"language-bash\">dotnet new aspire-starter --use-redis-cache --output AspireSample\n</code></pre>\n<h4 id=\"本地运行\">本地运行</h4>\n<p>通过 IDE 或 CLI 启动：Aspire 启动容器、遥测、仪表盘等。</p>\n<h4 id=\"检查仪表盘\">检查仪表盘</h4>\n<p>查看日志、指标、跟踪和容器状态。</p>\n<h4 id=\"自定义组件\">自定义组件</h4>\n<p>修改 ServiceDefaults 或添加新的集成（例如，PostgreSQL、Kafka）。</p>\n<h4 id=\"部署\">部署</h4>\n<p>导出 manifests 用于 Azure Container Apps 或 Kubernetes 部署。</p>\n<h4 id=\"扩展或迁移现有应用\">扩展或迁移现有应用</h4>\n<p>通过单一引用和 <code>AddServiceDefaults()</code> 调用注入 Aspire。</p>\n<h3 id=\"潜在考虑因素\">潜在考虑因素</h3>\n<h4 id=\"学习曲线\">学习曲线</h4>\n<p>其观点式结构可能与传统设置不同，过渡可能需要专注努力。</p>\n<h4 id=\"生态系统成熟度\">生态系统成熟度</h4>\n<p>Aspire 相对较新，集成覆盖和工具格局正在演变。</p>\n<h4 id=\"定制与主观默认\">定制与主观默认</h4>\n<p>虽然默认能节省时间，但大量定制可能需要更深的知识。</p>\n<h4 id=\"生产使用模式\">生产使用模式</h4>\n<p>虽然生产准备就绪，但大规模生产部署模式（如多区域 Kubernetes）仍可能需要额外配置。</p>\n<h2 id=\"结论\">结论</h2>\n<p>.NET Aspire 是一款创新、注重生产力的工具包，简化了使用 .NET 创建分布式云原生应用的流程。它将编排、遥测、服务默认、模板和实时仪表盘结合，打造出一个既有主见又可扩展的开发者体验。无论你是从零开始构建，还是增强现有的.NET 服务，Aspire 都能让你更快上手，更有效地调试，并自信地部署。</p>\n<p>通过提供标准化的开发体验、内置的可观测性和简化的部署流程，.NET Aspire 显著降低了构建分布式应用程序的复杂性，使开发者能够更专注于创造业务价值而非解决基础设施问题。随着生态系统的不断成熟，.NET Aspire 有望成为.NET 开发者构建云原生应用的首选框架。</p>\n\n</div>\n<div id=\"MySignature\">\n    <hr />\n<br />\n<p>本文是由葡萄城技术开发团队发布，转载请注明出处：<a href=\"https://www.grapecity.com.cn/\" target=\"_blank\">葡萄城官网</a></p>\n<!--p style=\"font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000\">了解企业级低代码开发平台，请前往<a href=\"https://www.grapecity.com.cn/solutions/huozige\" target=\"_blank\">活字格</a>\n</p><p style=\"font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000\">了解可嵌入您系统的在线 Excel，请前往<a href=\"https://www.grapecity.com.cn/developer/spreadjs\" target=\"_blank\">SpreadJS纯前端表格控件</a></p>\n<p style=\"font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000\">了解嵌入式的商业智能和报表软件，请前往<a href=\"https://www.grapecity.com.cn/solutions/wyn\" target=\"_blank\">Wyn Enterprise\n</a></p-->\n\n<br />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 14:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/powertoolsteam\">葡萄城技术团队</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "总结归纳.NET 10 中 Minimal APIs 主要应用场景",
      "link": "https://www.cnblogs.com/tianqing/p/19467531",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tianqing/p/19467531\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 13:55\">\n    <span>总结归纳.NET 10 中 Minimal APIs 主要应用场景</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>上一篇文章给大家分享了</p>\n<p><a class=\"post-item-title\" href=\"https://www.cnblogs.com/tianqing/p/19467483\" target=\"_blank\">.NET 10 New feature 新增功能介绍-Minimal APIs增强</a></p>\n<p>今天继续分享，&nbsp;Minimal APIs 主要应用场景</p>\n<p class=\"p1\">在 .NET 6–8 中，Minimal APIs 已经完成了“<span class=\"s1\"><strong>能用</strong>”阶段；</span></p>\n<p class=\"p2\"><span class=\"s2\">.NET 9–10 的目标非常明确：<strong>让 Minimal APIs 成为企业级 API 的一等公民</strong><span class=\"s2\">。</span></span></p>\n<p class=\"p3\">核心增强方向可以概括为四个关键词：&nbsp;</p>\n<blockquote><strong>可维护、可治理、可扩展、可工程化</strong></blockquote>\n<p class=\"p1\">具体体现在以下能力成熟度提升：</p>\n<ol start=\"1\">\n<li>\n<p class=\"p1\"><strong>更强的类型系统支持（Typed Results / OpenAPI 对齐）</strong></p>\n</li>\n<li>\n<p class=\"p1\"><strong>更完善的过滤器与中间件组合能力</strong></p>\n</li>\n<li>\n<p class=\"p1\"><strong>与 DI、Validation、Authorization 的深度融合</strong></p>\n</li>\n<li>\n<p class=\"p1\"><strong>对 API 分层、模块化、规模化的原生支持</strong></p>\n</li>\n</ol>\n<p>&nbsp;我们继续对比思考传统 Controller 模型的典型问题：</p>\n<p><img alt=\"image\" height=\"248\" src=\"https://img2024.cnblogs.com/blog/23525/202601/23525-20260111101830293-1711275646.png\" width=\"774\" /></p>\n<p>&nbsp;<strong>Minimal APIs 增强后的核心应用场景总结</strong></p>\n<p class=\"p1\">&nbsp;<strong>场景一：高并发读接口（数据服务 / 智能问数 / 看板接口）</strong></p>\n<p class=\"p1\">首先是<span class=\"Apple-converted-space\">更强 Typed Results，彻底消除“返回不确定性”</span></p>\n<div class=\"cnblogs_code\">\n<pre>app.MapGet(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/stations/{id}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">async</span> Task&lt;Results&lt;Ok&lt;StationDto&gt;, NotFound, ProblemHttpResult&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> \n    (</span><span style=\"color: rgba(0, 0, 255, 1);\">long</span> id, IStationService service) =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> station = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> service.GetAsync(id);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> station <span style=\"color: rgba(0, 0, 255, 1);\">is</span> <span style=\"color: rgba(0, 0, 255, 1);\">null</span>\n        ?<span style=\"color: rgba(0, 0, 0, 1);\"> TypedResults.NotFound()\n        : TypedResults.Ok(station);\n});</span></pre>\n</div>\n<p>这保证了</p>\n<ul>\n<li>\n<p class=\"p1\">OpenAPI 文档 <span class=\"s1\"><strong>100% 精确</strong></span></p>\n</li>\n<li>\n<p class=\"p1\">AI / 前端 / SDK 自动生成零歧义</p>\n</li>\n<li>\n<p class=\"p1\"><span class=\"s1\">不再需要 [ProducesResponseType]</span></p>\n</li>\n</ul>\n<p>&nbsp;<strong>极致轻量，避免 Controller 反射 &amp; Filter 链成本，</strong>在 <span class=\"s1\"><strong>高 QPS 场景</strong></span></p>\n<ul>\n<li>\n<p class=\"p1\">Minimal APIs：</p>\n<ul>\n<li>\n<p class=\"p1\">路由直接绑定 Delegate</p>\n</li>\n<li>\n<p class=\"p1\">少一层 MVC 管道</p>\n</li>\n</ul>\n</li>\n<li>\n<p class=\"p1\">对 CPU 与内存友好</p>\n</li>\n</ul>\n<blockquote><strong>只读接口 + 高频接口，优先 Minimal APIs</strong></blockquote>\n<p>&nbsp;<strong>场景二：业务能力型 API</strong></p>\n<p class=\"p1\">&nbsp;<strong>典型问题（Controller 模式）</strong></p>\n<ul>\n<li>\n<p class=\"p1\">业务规则散落在 Attribute / Filter / Action</p>\n</li>\n<li>\n<p class=\"p1\">授权、校验、审计难以统一<strong>.</strong></p>\n</li>\n</ul>\n<p><strong>NET 10 的解决方式：</strong><strong>Endpoint Filter 工程化</strong><strong>统一业务能力过滤器</strong></p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> OperatorContextFilter : IEndpointFilter\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> ValueTask&lt;<span style=\"color: rgba(0, 0, 255, 1);\">object</span>?&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> InvokeAsync(\n        EndpointFilterInvocationContext ctx,\n        EndpointFilterDelegate next)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 解析运营商上下文</span>\n        OperatorContext.Current =<span style=\"color: rgba(0, 0, 0, 1);\"> Resolve(ctx.HttpContext);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> next(ctx);\n    }\n}</span></pre>\n</div>\n<p class=\"p1\">&nbsp;<strong>应用到业务 API</strong></p>\n<div class=\"cnblogs_code\">\n<pre>app.MapGroup(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/api/charge</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n   .AddEndpointFilter</span>&lt;OperatorContextFilter&gt;<span style=\"color: rgba(0, 0, 0, 1);\">()\n   .RequireAuthorization(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">OperatorPolicy</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n   .MapPost(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/start</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, StartCharge);</pre>\n</div>\n<p><img alt=\"image\" height=\"159\" src=\"https://img2024.cnblogs.com/blog/23525/202601/23525-20260111102233372-1206307874.png\" width=\"585\" /></p>\n<p>&nbsp;</p>\n<p class=\"p1\">&nbsp;<strong>场景三：平台级 API 模块化</strong></p>\n<p>&nbsp;我们可以按 <span class=\"s1\"><strong>业务域</strong> 拆分 API，而不是 Controller：</span></p>\n<p><span class=\"s1\">&nbsp;&nbsp;</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> StationEndpoints\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> IEndpointRouteBuilder MapStation(<span style=\"color: rgba(0, 0, 255, 1);\">this</span><span style=\"color: rgba(0, 0, 0, 1);\"> IEndpointRouteBuilder app)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> group = app.MapGroup(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/api/station</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n            .RequireAuthorization();\n\n        group.MapGet(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/{id}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, GetStation);\n        group.MapPost(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, CreateStation);\n\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> app;\n    }\n}</span></pre>\n</div>\n<p class=\"p1\">Program.cs 极其灵活、简单做集成即可，这可以实现多业务线并行开发</p>\n<p>app.MapStation();<br />app.MapOrder();<br />app.MapCharge();<br />app.MapFinance();</p>\n<p>&nbsp;<strong>场景四：内部微服务 / AI Agent 接口（非传统 REST）</strong></p>\n<p>&nbsp;Minimal APIs 在 .NET 10 中，<span class=\"s1\"><strong>非常适合做 Agent Tool 接口</strong>：</span></p>\n<div class=\"cnblogs_code\">\n<pre>app.MapPost(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/agent/charge/analyze</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">async</span> (ChargeAnalyzeRequest req, IChargeAnalyzer analyzer) =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> TypedResults.Ok(<span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> analyzer.AnalyzeAsync(req));\n});</span></pre>\n</div>\n<p class=\"p1\">&nbsp;<strong>场景五：BFF / API Gateway 层</strong></p>\n<p>&nbsp;使用 Minimal APIs 可以实现</p>\n<ul>\n<li>\n<p class=\"p1\">聚合多个下游接口、业务逻辑编排</p>\n</li>\n<li>\n<p class=\"p1\">DTO 转换 + 协议适配</p>\n</li>\n<li>\n<p class=\"p1\">极致简洁</p>\n</li>\n</ul>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre>app.MapGet(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/bff/station/{id}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">async</span> (<span style=\"color: rgba(0, 0, 255, 1);\">long</span> id, IStationApi api, IPriceApi priceApi) =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> station = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> api.Get(id);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> price = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> priceApi.GetPrice(id);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> TypedResults.Ok(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> StationView(station, price));\n});</span></pre>\n</div>\n<p>&nbsp;以上是.NET 10 中 Minimal APIs 主要应用场景的总结和分享。</p>\n<p>&nbsp;</p>\n<p>周国庆</p>\n<p>2026/1/12</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 13:55</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tianqing\">Eric zhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">28</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "C# 14 中的新增功能",
      "link": "https://www.cnblogs.com/net-kevin-li/p/19476883",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/net-kevin-li/p/19476883\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 13:46\">\n    <span>C# 14 中的新增功能</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>C# 14 引入了多项重要更新，以下是主要功能的详细说明：</p>\n<hr />\n<h3 id=\"1-扩展成员\">1. <strong>扩展成员</strong></h3>\n<p>允许为现有类型添加扩展方法/属性，语法更简洁：</p>\n<pre><code class=\"language-csharp\">public static class StringExtensions\n{\n    public static bool IsNullOrEmpty(this string? str) =&gt; \n        string.IsNullOrEmpty(str);\n}\n</code></pre>\n<hr />\n<h3 id=\"2-空条件赋值\">2. <strong>空条件赋值</strong></h3>\n<p>简化空值检查与赋值操作：</p>\n<pre><code class=\"language-csharp\">obj?.Property ??= \"default\"; // 若 obj.Property 为 null 则赋值\n</code></pre>\n<hr />\n<h3 id=\"3-nameof-支持未绑定泛型类型\">3. <strong><code>nameof</code> 支持未绑定泛型类型</strong></h3>\n<p>增强泛型类型名称获取能力：</p>\n<pre><code class=\"language-csharp\">var name = nameof(List&lt;int&gt;); // 输出 \"List\"\n</code></pre>\n<hr />\n<h3 id=\"4-spant-隐式转换优化\">4. <strong><code>Span&lt;T&gt;</code> 隐式转换优化</strong></h3>\n<p>支持更多类型安全转换：</p>\n<pre><code class=\"language-csharp\">byte[] data = ...;\nSpan&lt;byte&gt; span = data; // 无需显式转换\n</code></pre>\n<hr />\n<h3 id=\"5-简单-lambda-参数修饰符\">5. <strong>简单 lambda 参数修饰符</strong></h3>\n<p>允许为 lambda 参数添加修饰符：</p>\n<pre><code class=\"language-csharp\">var process = (ref int x) =&gt; x *= 2; // 支持 ref/in 等修饰\n</code></pre>\n<hr />\n<h3 id=\"6-field-支持的属性\">6. <strong><code>field</code> 支持的属性</strong></h3>\n<p>自动实现属性支持字段直接访问：</p>\n<pre><code class=\"language-csharp\">public int Value { get; set field = 0; } // 通过 'field' 关键字访问后备字段\n</code></pre>\n<hr />\n<h3 id=\"7-partial-事件和构造函数\">7. <strong><code>partial</code> 事件和构造函数</strong></h3>\n<p>分部类支持事件与构造函数的拆分定义：</p>\n<pre><code class=\"language-csharp\">partial class MyClass\n{\n    partial void Initialize(); // 分部构造函数逻辑\n    public event EventHandler? MyEvent;\n}\n</code></pre>\n<hr />\n<h3 id=\"8-用户定义的复合赋值运算符\">8. <strong>用户定义的复合赋值运算符</strong></h3>\n<p>支持重载复合运算符（如 <code>+=</code>）：</p>\n<pre><code class=\"language-csharp\">public static Vector operator +(Vector a, Vector b) =&gt; ...;\npublic static Vector operator +=(Vector a, Vector b) =&gt; a = a + b; // 显式定义\n</code></pre>\n<hr />\n<h3 id=\"9-基于文件的预处理器指令\">9. <strong>基于文件的预处理器指令</strong></h3>\n<p>为文件级配置新增指令：</p>\n<pre><code class=\"language-csharp\">#fileenable \"FeatureA\" // 启用特定文件级功能\n</code></pre>\n<hr />\n<h3 id=\"使用建议\">使用建议</h3>\n<ul>\n<li><strong>开发环境</strong>：需安装 .NET 10 SDK 或 Visual Studio 2026</li>\n<li><strong>迁移注意</strong>：部分功能需显式启用编译器开关（如 <code>#enable</code>）</li>\n<li><strong>性能优化</strong>：<code>Span&lt;T&gt;</code> 隐式转换可减少内存拷贝，适用于高性能场景</li>\n</ul>\n<p>通过以下代码验证环境支持：</p>\n<pre><code class=\"language-csharp\">Console.WriteLine($\"C# 14 enabled: {RuntimeFeature.IsSupported(\"CSharp14\")}\");\n\n</code></pre>\n<h2 id=\"netcorekevin\">NetCoreKevin</h2>\n<p>基于NET搭建-AI智能体-现代化Saas企业级前后端分离架构-开启智能应用的无限可能：前端Vue3、IDS4单点登录、多缓存、自动任务、分布式、一库多租户、日志、授权和鉴权、CAP集成事件、SignalR、领域事件、MCP协议服务、IOC模块化注入、代码生成器、Quartz自动任务、多短信集成、AI、AgentFramework智能体、AISemanticKernel集成、RAG检索增强<br />\n-项目地址：github：<a href=\"https://github.com/junkai-li/NetCoreKevin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/junkai-li/NetCoreKevin</a><br />\nGitee: <a href=\"https://gitee.com/netkevin-li/NetCoreKevin\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/netkevin-li/NetCoreKevin</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 13:46</span>&nbsp;\n<a href=\"https://www.cnblogs.com/net-kevin-li\">NetCoreKevin</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于DCT变换图像去噪算法的终极优化（1920*1080灰度图单核约22ms）",
      "link": "https://www.cnblogs.com/Imageshop/p/19475839",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Imageshop/p/19475839\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 13:43\">\n    <span>基于DCT变换图像去噪算法的终极优化（1920*1080灰度图单核约22ms）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        DCT去噪也是一种常用而且稳定的去噪算法，但是因其计算量太大，往往难以在项目中予以落地，本文在早期的优化版本上，继续深入探讨。将该算法的速度进一步以提升。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>　　相关文章：</p>\n<p>　　<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Imageshop/p/4965192.html\" id=\"cb_post_title_url\" title=\"发布于 2015-11-14 22:11\">优化IPOL网站中基于DCT（离散余弦变换）的图像去噪算法（附源代码）。</a></p>\n<p>　　<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Imageshop/p/9584024.html\" id=\"cb_post_title_url\" title=\"发布于 2018-09-04 17:06\">SSE图像算法优化系列二十一：基于DCT变换图像去噪算法的进一步优化（100W像素30ms）。</a></p>\n<p>　　<span style=\"font-size: 13px;\">这个算法2015年优化过一版，2018年又优化过一版，2016年初又来回访一下，感觉还有优化空间，继续又折腾了将近一周，速度又有进一步的提升，下面是这个三个版本在同一台电脑上的速度比较：</span></p>\n<p>&nbsp; &nbsp;&nbsp;<img alt=\"image\" height=\"168\" src=\"https://img2024.cnblogs.com/blog/349293/202601/349293-20260113104140655-1263897161.png\" width=\"1090\" /></p>\n<p><span style=\"font-size: 13px;\">&nbsp;</span><span style=\"font-size: 13px;\">　　对于小图，其实2026版和2018年速度差异不是很大，到了大图，新版约有25%左右的提升。</span></p>\n<p><span style=\"font-size: 13px;\">　　那么2026版优化的渠道主要有两处，第一个还是内部DCT变换本身的优化，以8*8的DCT为例，2015版DCT1D的代码如下所示：</span></p>\n<div class=\"cnblogs_code\">\n<pre>inline <span style=\"color: rgba(0, 0, 255, 1);\">void</span> IM_DCT1D_8x1_GT_C(<span style=\"color: rgba(0, 0, 255, 1);\">float</span> *In, <span style=\"color: rgba(0, 0, 255, 1);\">float</span> *<span style=\"color: rgba(0, 0, 0, 1);\">Out)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx00 = In[<span style=\"color: rgba(128, 0, 128, 1);\">0</span>] + In[<span style=\"color: rgba(128, 0, 128, 1);\">7</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx01 = In[<span style=\"color: rgba(128, 0, 128, 1);\">1</span>] + In[<span style=\"color: rgba(128, 0, 128, 1);\">6</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx02 = In[<span style=\"color: rgba(128, 0, 128, 1);\">2</span>] + In[<span style=\"color: rgba(128, 0, 128, 1);\">5</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx03 = In[<span style=\"color: rgba(128, 0, 128, 1);\">3</span>] + In[<span style=\"color: rgba(128, 0, 128, 1);\">4</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx04 = In[<span style=\"color: rgba(128, 0, 128, 1);\">0</span>] - In[<span style=\"color: rgba(128, 0, 128, 1);\">7</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx05 = In[<span style=\"color: rgba(128, 0, 128, 1);\">1</span>] - In[<span style=\"color: rgba(128, 0, 128, 1);\">6</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx06 = In[<span style=\"color: rgba(128, 0, 128, 1);\">2</span>] - In[<span style=\"color: rgba(128, 0, 128, 1);\">5</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx07 = In[<span style=\"color: rgba(128, 0, 128, 1);\">3</span>] - In[<span style=\"color: rgba(128, 0, 128, 1);\">4</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx08 = mx00 +<span style=\"color: rgba(0, 0, 0, 1);\"> mx03;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx09 = mx01 +<span style=\"color: rgba(0, 0, 0, 1);\"> mx02;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx0a = mx00 -<span style=\"color: rgba(0, 0, 0, 1);\"> mx03;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx0b = mx01 -<span style=\"color: rgba(0, 0, 0, 1);\"> mx02;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx0c = <span style=\"color: rgba(128, 0, 128, 1);\">1.38703984532215f</span> * mx04 + <span style=\"color: rgba(128, 0, 128, 1);\">0.275899379282943f</span> *<span style=\"color: rgba(0, 0, 0, 1);\"> mx07;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx0d = <span style=\"color: rgba(128, 0, 128, 1);\">1.17587560241936f</span> * mx05 + <span style=\"color: rgba(128, 0, 128, 1);\">0.785694958387102f</span> *<span style=\"color: rgba(0, 0, 0, 1);\"> mx06;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx0e = -<span style=\"color: rgba(128, 0, 128, 1);\">0.785694958387102f</span> * mx05 + <span style=\"color: rgba(128, 0, 128, 1);\">1.17587560241936f</span> *<span style=\"color: rgba(0, 0, 0, 1);\"> mx06;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx0f = <span style=\"color: rgba(128, 0, 128, 1);\">0.275899379282943f</span> * mx04 - <span style=\"color: rgba(128, 0, 128, 1);\">1.38703984532215f</span> *<span style=\"color: rgba(0, 0, 0, 1);\"> mx07;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx10 = <span style=\"color: rgba(128, 0, 128, 1);\">0.353553390593274f</span> * (mx0c -<span style=\"color: rgba(0, 0, 0, 1);\"> mx0d);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">float</span> mx11 = <span style=\"color: rgba(128, 0, 128, 1);\">0.353553390593274f</span> * (mx0e -<span style=\"color: rgba(0, 0, 0, 1);\"> mx0f);\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">0</span>] = <span style=\"color: rgba(128, 0, 128, 1);\">0.353553390593274f</span> * (mx08 +<span style=\"color: rgba(0, 0, 0, 1);\"> mx09);\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">1</span>] = <span style=\"color: rgba(128, 0, 128, 1);\">0.353553390593274f</span> * (mx0c +<span style=\"color: rgba(0, 0, 0, 1);\"> mx0d);\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">2</span>] = <span style=\"color: rgba(128, 0, 128, 1);\">0.461939766255643f</span> * mx0a + <span style=\"color: rgba(128, 0, 128, 1);\">0.191341716182545f</span> *<span style=\"color: rgba(0, 0, 0, 1);\"> mx0b;\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">3</span>] = <span style=\"color: rgba(128, 0, 128, 1);\">0.707106781186547f</span> * (mx10 -<span style=\"color: rgba(0, 0, 0, 1);\"> mx11);\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">4</span>] = <span style=\"color: rgba(128, 0, 128, 1);\">0.353553390593274f</span> * (mx08 -<span style=\"color: rgba(0, 0, 0, 1);\"> mx09);\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">5</span>] = <span style=\"color: rgba(128, 0, 128, 1);\">0.707106781186547f</span> * (mx10 +<span style=\"color: rgba(0, 0, 0, 1);\"> mx11);\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">6</span>] = <span style=\"color: rgba(128, 0, 128, 1);\">0.191341716182545f</span> * mx0a - <span style=\"color: rgba(128, 0, 128, 1);\">0.461939766255643f</span> *<span style=\"color: rgba(0, 0, 0, 1);\"> mx0b;\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">7</span>] = <span style=\"color: rgba(128, 0, 128, 1);\">0.353553390593274f</span> * (mx0e +<span style=\"color: rgba(0, 0, 0, 1);\"> mx0f);\n}</span></pre>\n</div>\n<p>　　可以看到Out[0]到Out[7]这个8个数据前面都还有很多系数，共有26次加法及22次乘法，实际上可以把他们和前面的系数融合到一起，修改后数据如下所示：</p>\n<div class=\"cnblogs_code\">\n<pre>inline <span style=\"color: rgba(0, 0, 255, 1);\">void</span> IM_DCT1D_1x8_C(<span style=\"color: rgba(0, 0, 255, 1);\">float</span>* In, <span style=\"color: rgba(0, 0, 255, 1);\">float</span>*<span style=\"color: rgba(0, 0, 0, 1);\"> Out)\n{</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">float</span> V00 = In[<span style=\"color: rgba(128, 0, 128, 1);\">0</span>] + In[<span style=\"color: rgba(128, 0, 128, 1);\">7</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V01 = In[<span style=\"color: rgba(128, 0, 128, 1);\">0</span>] - In[<span style=\"color: rgba(128, 0, 128, 1);\">7</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V02 = In[<span style=\"color: rgba(128, 0, 128, 1);\">1</span>] + In[<span style=\"color: rgba(128, 0, 128, 1);\">6</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V03 = In[<span style=\"color: rgba(128, 0, 128, 1);\">1</span>] - In[<span style=\"color: rgba(128, 0, 128, 1);\">6</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V04 = In[<span style=\"color: rgba(128, 0, 128, 1);\">2</span>] + In[<span style=\"color: rgba(128, 0, 128, 1);\">5</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V05 = In[<span style=\"color: rgba(128, 0, 128, 1);\">2</span>] - In[<span style=\"color: rgba(128, 0, 128, 1);\">5</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V06 = In[<span style=\"color: rgba(128, 0, 128, 1);\">3</span>] + In[<span style=\"color: rgba(128, 0, 128, 1);\">4</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V07 = In[<span style=\"color: rgba(128, 0, 128, 1);\">3</span>] - In[<span style=\"color: rgba(128, 0, 128, 1);\">4</span><span style=\"color: rgba(0, 0, 0, 1);\">];\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V08 = <span style=\"color: rgba(128, 0, 128, 1);\">0.353553390593274f</span> * (V00 +<span style=\"color: rgba(0, 0, 0, 1);\"> V06);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V09 = <span style=\"color: rgba(128, 0, 128, 1);\">0.353553390593274f</span> * (V02 +<span style=\"color: rgba(0, 0, 0, 1);\"> V04);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V10 = V00 -<span style=\"color: rgba(0, 0, 0, 1);\"> V06;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V11 = V02 -<span style=\"color: rgba(0, 0, 0, 1);\"> V04;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V12 = <span style=\"color: rgba(128, 0, 128, 1);\">0.490392640201616f</span> * V01 + <span style=\"color: rgba(128, 0, 128, 1);\">0.097545161008064f</span> *<span style=\"color: rgba(0, 0, 0, 1);\"> V07;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V13 = <span style=\"color: rgba(128, 0, 128, 1);\">0.415734806151273f</span> * V03 + <span style=\"color: rgba(128, 0, 128, 1);\">0.277785116509801f</span> *<span style=\"color: rgba(0, 0, 0, 1);\"> V05;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V14 = <span style=\"color: rgba(128, 0, 128, 1);\">0.415734806151273f</span> * V05 - <span style=\"color: rgba(128, 0, 128, 1);\">0.277785116509801f</span> *<span style=\"color: rgba(0, 0, 0, 1);\"> V03;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V15 = <span style=\"color: rgba(128, 0, 128, 1);\">0.097545161008064f</span> * V01 - <span style=\"color: rgba(128, 0, 128, 1);\">0.490392640201616f</span> *<span style=\"color: rgba(0, 0, 0, 1);\"> V07;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V16 = <span style=\"color: rgba(128, 0, 128, 1);\">0.707106781186547f</span> * (V12 -<span style=\"color: rgba(0, 0, 0, 1);\"> V13);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span> V17 = <span style=\"color: rgba(128, 0, 128, 1);\">0.707106781186547f</span> * (V14 -<span style=\"color: rgba(0, 0, 0, 1);\"> V15);\n\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">0</span>] = V08 +<span style=\"color: rgba(0, 0, 0, 1);\"> V09;\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">1</span>] = V12 +<span style=\"color: rgba(0, 0, 0, 1);\"> V13;\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">2</span>] = <span style=\"color: rgba(128, 0, 128, 1);\">0.461939766255643f</span> * V10 + <span style=\"color: rgba(128, 0, 128, 1);\">0.191341716182545f</span> *<span style=\"color: rgba(0, 0, 0, 1);\"> V11;\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">3</span>] = V16 -<span style=\"color: rgba(0, 0, 0, 1);\"> V17;\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">4</span>] = V08 -<span style=\"color: rgba(0, 0, 0, 1);\"> V09;\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">5</span>] = V16 +<span style=\"color: rgba(0, 0, 0, 1);\"> V17;\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">6</span>] = <span style=\"color: rgba(128, 0, 128, 1);\">0.191341716182545f</span> * V10 - <span style=\"color: rgba(128, 0, 128, 1);\">0.461939766255643f</span> *<span style=\"color: rgba(0, 0, 0, 1);\"> V11;\n    Out[</span><span style=\"color: rgba(128, 0, 128, 1);\">7</span>] = V14 +<span style=\"color: rgba(0, 0, 0, 1);\"> V15;\n}</span></pre>\n</div>\n<p>　　修改后的代码只有26次加法及16次乘法，减少了6次乘法。</p>\n<p>&nbsp;　&nbsp; 加速的另外一个部分就是，原先的方法是沿着列方向更新权重和累加值，新的算法更改为行方向更新权重和累加值，这里自然的就变为了缓存友好的方式了。当然其中，会增加一部分内存占用。</p>\n<p>　　原先的处理方式如下：</p>\n<div class=\"cnblogs_code\">\n<pre>        <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> X = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; X &lt; Width - <span style=\"color: rgba(128, 0, 128, 1);\">7</span>; X +=<span style=\"color: rgba(0, 0, 0, 1);\"> Step)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> Y = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; Y &lt; Height; Y++<span style=\"color: rgba(0, 0, 0, 1);\">)\n            {\n                IM_Convert8ucharTo8float_PureC(Src </span>+ Y * Stride + X, DctIn + Y * <span style=\"color: rgba(128, 0, 128, 1);\">8</span>);                        <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    把一整列的字节数据转换为浮点数</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            }\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> Y = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; Y &lt; Height; Y++<span style=\"color: rgba(0, 0, 0, 1);\">)\n            {\n                IM_DCT1D_8x1_GT_C(DctIn </span>+ Y * <span style=\"color: rgba(128, 0, 128, 1);\">8</span>, DctIn + Y * <span style=\"color: rgba(128, 0, 128, 1);\">8</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            }\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> Y = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; Y &lt; Height - <span style=\"color: rgba(128, 0, 128, 1);\">7</span>; Y +=<span style=\"color: rgba(0, 0, 0, 1);\"> Step)\n            {\n                IM_DCT2D_8x8_With1DRowDCT_GS_PureC(DctIn </span>+ Y * <span style=\"color: rgba(128, 0, 128, 1);\">8</span>, DctOut);                            <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    DCT变换</span>\n                IM_DctThreshold8x8_PureC(DctOut, Threshold);                                                <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    阈值处理</span>\n                IM_IDCT2D_8x8_GS_PureC(DctOut, DctOut);                                                <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    在反变换回来</span>\n                IM_UpdateSum8x8_PureC(Sum + Y * Width + X, DctOut, Width);                                <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    更新权重和阈值</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">            }\n        }\n        IM_SumDivWeight2uchar8x8_PureC(Sum, Dest, Width, Height, Stride, FastMode);</span></pre>\n</div>\n<p>　　更改后的方案为：</p>\n<div class=\"cnblogs_code\">\n<pre>    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    先把所有的字节数据转换为浮点数</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> Y = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; Y &lt; Height; Y++<span style=\"color: rgba(0, 0, 0, 1);\">)\n        {\n            IM_ConvertU8To32F_PureC(Src </span>+ Y * Stride, SrcF + Y *<span style=\"color: rgba(0, 0, 0, 1);\"> Width, Width);\n        }\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    因为后面进行了以y为起点，连续8个元素的行方向的DCT变换，所以最后7个点也是有取样的</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> Y = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; Y &lt; Height - <span style=\"color: rgba(128, 0, 128, 1);\">7</span>; Y +=<span style=\"color: rgba(0, 0, 0, 1);\"> Step)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">float</span>* SumL = Sum + Y *<span style=\"color: rgba(0, 0, 0, 1);\"> Width;\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    8行数据的一维列DCT变换，保存到DctIn中</span>\n            IM_DCT1D_8xW_C_PureC(SrcF + Y *<span style=\"color: rgba(0, 0, 0, 1);\"> Width, DctIn, Width);\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    把列DCT变换的数据转置下</span>\n            IM_TransposeF_PureC(DctIn, DctInT, Width, <span style=\"color: rgba(128, 0, 128, 1);\">8</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    进行了以X为起点，X方向连续7个列方向的DCT列变换，所以列方向最后7个元素也能取样到</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> X = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; X &lt; Width - <span style=\"color: rgba(128, 0, 128, 1);\">7</span>; X +=<span style=\"color: rgba(0, 0, 0, 1);\"> Step)\n            {\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    可以重复利用行方向的转置数据</span>\n                IM_DCT1D_8x8_C_PureC(DctInT + X * <span style=\"color: rgba(128, 0, 128, 1);\">8</span><span style=\"color: rgba(0, 0, 0, 1);\">, DctOut);\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    转换后的数据还要转置</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">                IM_Transpose8x8F_W8_PureC(DctOut, DctOut);\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    阈值处理</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">                IM_DctThreshold8x8_PureC(DctOut, Threshold);\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    在反变换回来</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">                IM_IDCT2D_8x8_PureC(DctOut, DctOut);\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    更新权重和阈值</span>\n                IM_UpdateSum8x8_PureC(SumL +<span style=\"color: rgba(0, 0, 0, 1);\"> X, DctOut, Width);\n            }\n        }\n        IM_SumDivWeight2uchar8x8_PureC(Sum, Dest, Width, Height, Stride, FastMode);</span></pre>\n</div>\n<p>　　具体的细节还需要大家自己慢慢悟。</p>\n<p>　　对于16*16的DCT，本身的计算量就特别夸张，原先论文配套的代码也有提供，但是同样的道理那里的代码存在大量的可节省计算，很多乘法部分可以合并的。优化后的DCT16*16共需要46次乘法72次加法，16*16的去噪程度更强，同样的Sigma参数结果会更加模糊，为了提高16*16的速度，也可以仿照8*8的方式，加大取样间隔，实际测试间隔调整为2个像素，对结果基本没影响，如果把间隔调整为4个像素，在加大的Sigma时，可以较为明显的看到局部的方格，这个应该是不能忍受的， 实际测试如果把间距调整为3个像素，其实结果和原始的还是能承受的，而且加速也很客观。</p>\n<p>　　论文里提到的棋格取样，虽然有一定的理论正确性，但是实际不太可操作，首先是获取满足网格布置的坐标本身就是一个比较慢的过程，第二个即使获取了网格坐标，因为这些坐标分布基本不是按照先X方向增加，再Y方向增加的布局方式布置的，所以为了利用后续的加速技巧，还要先对他们进行排序，这个增加的耗时也是非常客观的，所以我个人觉得那个只具有理论意义。 <br />　　另外一个就是关于SSE和AVX加速的部分，这里AVX起到的加速作用不是特别明显，核心原因估计还是内存加载和保存占比在整个过程中比较多，而且在计算部分，也曾尝试用FMA相关指令替代mul+add，也不见有明显的收益。 另外，对于算法中经常使用的8*8转置，AVX版本如果学SSE那种直接处理，加速就更有限了。但是AVX里有不同的port，如果充分利用这个则还不错。</p>\n<p><strong><span style=\"font-size: 13px;\">　　多线程：</span></strong></p>\n<p><span style=\"font-size: 13px;\">　　因为这个DCT算法其实也是领域算法，所以不太好直接使用多线程进行处理，但是还是有办法，对于灰度图像，一种方法是按照高度或者宽度方向分块，但是分块的时候需要注意块和块之间必须有重叠，以保证边缘的不分被充分处理，虽然重叠会增加那么一丢丢的耗时，但是这不算啥，而对于彩色图像，因为要把彩色图分单通道后再调用单通道的处理算法，所以一个自然的想法就是分解后的单通道之间开三个线程并行就可以了。一个简单的代码如下</span><span style=\"font-size: 13px;\">：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">int</span> IM_DCT_Denoising_8x8_MultiThread_SSE(unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span>* Src, unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span>* Dest, <span style=\"color: rgba(0, 0, 255, 1);\">int</span> Width, <span style=\"color: rgba(0, 0, 255, 1);\">int</span> Height, <span style=\"color: rgba(0, 0, 255, 1);\">int</span> Stride, <span style=\"color: rgba(0, 0, 255, 1);\">float</span> Sigma, <span style=\"color: rgba(0, 0, 255, 1);\">bool</span><span style=\"color: rgba(0, 0, 0, 1);\"> FastMode)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> Channel = Stride /<span style=\"color: rgba(0, 0, 0, 1);\"> Width;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> ((Src == NULL) || (Dest == NULL))                            <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> IM_STATUS_NULLREFRENCE;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> ((Width &lt;= <span style=\"color: rgba(128, 0, 128, 1);\">7</span>) || (Height &lt;= <span style=\"color: rgba(128, 0, 128, 1);\">7</span>) || (Sigma &lt;= <span style=\"color: rgba(128, 0, 128, 1);\">0</span>))                <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> IM_STATUS_INVALIDPARAMETER;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> ((Channel != <span style=\"color: rgba(128, 0, 128, 1);\">1</span>) &amp;&amp; (Channel != <span style=\"color: rgba(128, 0, 128, 1);\">3</span>))                            <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> IM_STATUS_NOTSUPPORTED;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> Status =<span style=\"color: rgba(0, 0, 0, 1);\"> IM_STATUS_OK;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (Width &lt; <span style=\"color: rgba(128, 0, 128, 1);\">256</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> IM_DCT_Denoising_8x8_SSE(Src, Dest, Width, Height, Stride, Sigma, FastMode);\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (Channel == <span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> StatusA = IM_STATUS_OK, StatusB = IM_STATUS_OK, StatusC =<span style=\"color: rgba(0, 0, 0, 1);\"> IM_STATUS_OK;\n            unsigned </span><span style=\"color: rgba(0, 0, 255, 1);\">char</span>* Blue = (unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span>*)malloc(Width * Height * <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n            unsigned </span><span style=\"color: rgba(0, 0, 255, 1);\">char</span>* Green = (unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span>*)malloc(Width * Height * <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n            unsigned </span><span style=\"color: rgba(0, 0, 255, 1);\">char</span>* Red = (unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span>*)malloc(Width * Height * <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> ((Blue == NULL) || (Green == NULL) || (Red ==<span style=\"color: rgba(0, 0, 0, 1);\"> NULL))\n            {\n                Status </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> IM_STATUS_OUTOFMEMORY;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">goto</span><span style=\"color: rgba(0, 0, 0, 1);\"> FreeResource;\n            }\n            IM_SplitRGB(Src, Blue, Green, Red, Width, Height, Stride, </span><span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">#pragma</span> omp parallel sections num_threads(3)<span style=\"color: rgba(0, 0, 0, 1);\">\n            {\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">#pragma</span> omp section<span style=\"color: rgba(0, 0, 0, 1);\">\n                {\n                    StatusA </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> IM_DCT_Denoising_8x8_SSE(Blue, Blue, Width, Height, Width, Sigma, FastMode);\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (StatusA != IM_STATUS_OK)    Status =<span style=\"color: rgba(0, 0, 0, 1);\"> StatusA;\n                }\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">#pragma</span> omp section<span style=\"color: rgba(0, 0, 0, 1);\">\n                {\n                    StatusB </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> IM_DCT_Denoising_8x8_SSE(Green, Green, Width, Height, Width, Sigma, FastMode);\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (StatusB != IM_STATUS_OK)    Status =<span style=\"color: rgba(0, 0, 0, 1);\"> StatusB;\n                }\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">#pragma</span> omp section<span style=\"color: rgba(0, 0, 0, 1);\">\n                {\n                    StatusC </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> IM_DCT_Denoising_8x8_SSE(Red, Red, Width, Height, Width, Sigma, FastMode);\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (StatusC != IM_STATUS_OK)    Status =<span style=\"color: rgba(0, 0, 0, 1);\"> StatusC;\n                }\n            }\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (Status != IM_STATUS_OK)    <span style=\"color: rgba(0, 0, 255, 1);\">goto</span><span style=\"color: rgba(0, 0, 0, 1);\"> FreeResource;\n            IM_CombineRGB(Blue, Green, Red, Dest, Width, Height, Stride, </span><span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n        FreeResource:\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (Blue !=<span style=\"color: rgba(0, 0, 0, 1);\"> NULL)        free(Blue);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (Green !=<span style=\"color: rgba(0, 0, 0, 1);\"> NULL)        free(Green);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (Red !=<span style=\"color: rgba(0, 0, 0, 1);\"> NULL)        free(Red);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> Status;\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span> <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (Channel == <span style=\"color: rgba(128, 0, 128, 1);\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    大图分三个线程处理，因为在10年的电脑上，可能很多还是4核，要留一个核给操作系统比较好</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">int</span> BlockSize = Width / <span style=\"color: rgba(128, 0, 128, 1);\">3</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> BlockA_W = BlockSize + <span style=\"color: rgba(128, 0, 128, 1);\">7</span>;                        <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    1/3宽度在加上右侧多7个像素，能完整的计算出左侧BlockSize大小的信息</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">int</span> BlockB_W = BlockSize + <span style=\"color: rgba(128, 0, 128, 1);\">14</span>;                        <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    1/3宽度在加上左右两侧各7个像素，能完整的计算出中间的BlockSize大小的信息</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">int</span>    BlockC_W = Width - BlockSize - BlockSize + <span style=\"color: rgba(128, 0, 128, 1);\">7</span>;    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    1/3宽度在加上左侧多7个像素，能完整的计算出右侧BlockSize大小的信息（注意宽度不一定能整除，所以要用总宽度减去2倍的1/3大小</span>\n\n            <span style=\"color: rgba(0, 0, 255, 1);\">int</span> StatusA = IM_STATUS_OK, StatusB = IM_STATUS_OK, StatusC =<span style=\"color: rgba(0, 0, 0, 1);\"> IM_STATUS_OK;\n            unsigned </span><span style=\"color: rgba(0, 0, 255, 1);\">char</span>* BlockA = (unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span>*)malloc(BlockA_W * Height * <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n            unsigned </span><span style=\"color: rgba(0, 0, 255, 1);\">char</span>* BlockB = (unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span>*)malloc(BlockB_W * Height * <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n            unsigned </span><span style=\"color: rgba(0, 0, 255, 1);\">char</span>* BlockC = (unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span>*)malloc(BlockC_W * Height * <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> ((BlockA == NULL) || (BlockB == NULL) || (BlockC ==<span style=\"color: rgba(0, 0, 0, 1);\"> NULL))\n            {\n                Status </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> IM_STATUS_OUTOFMEMORY;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">goto</span><span style=\"color: rgba(0, 0, 0, 1);\"> FreeMemory;\n            }\n\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">#pragma</span> omp parallel sections num_threads(3)<span style=\"color: rgba(0, 0, 0, 1);\">\n            {\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">#pragma</span> omp section<span style=\"color: rgba(0, 0, 0, 1);\">\n                {\n                    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    拷贝左侧数据到临时内存</span>\n                    <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> Y = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; Y &lt; Height; Y++<span style=\"color: rgba(0, 0, 0, 1);\">)\n                    {\n                        memcpy(BlockA </span>+ Y * BlockA_W, Src + Y * Stride, BlockA_W * <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n                    }\n\n                    StatusA </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> IM_DCT_Denoising_8x8_SSE(BlockA, BlockA, BlockA_W, Height, BlockA_W, Sigma, FastMode);\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (StatusA !=<span style=\"color: rgba(0, 0, 0, 1);\"> IM_STATUS_OK)\n                    {\n                        Status </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> StatusA;\n                    }\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                    {\n                        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">    把数据复制回去</span>\n                        <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> Y = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; Y &lt; Height; Y++<span style=\"color: rgba(0, 0, 0, 1);\">)\n                        {\n                            memcpy(Dest </span>+ Y * Stride, BlockA + Y * BlockA_W, BlockSize * <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n                        }\n                    }\n                }\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">#pragma</span> omp section<span style=\"color: rgba(0, 0, 0, 1);\">\n                {\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> Y = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; Y &lt; Height; Y++<span style=\"color: rgba(0, 0, 0, 1);\">)\n                    {\n                        memcpy(BlockB </span>+ Y * BlockB_W, Src + Y * Stride + BlockSize - <span style=\"color: rgba(128, 0, 128, 1);\">7</span>, BlockB_W * <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n                    }\n\n                    StatusB </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> IM_DCT_Denoising_8x8_SSE(BlockB, BlockB, BlockB_W, Height, BlockB_W, Sigma, FastMode);\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (StatusB !=<span style=\"color: rgba(0, 0, 0, 1);\"> IM_STATUS_OK)\n                    {\n                        Status </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> StatusB;\n                    }\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                    {\n                        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> Y = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; Y &lt; Height; Y++<span style=\"color: rgba(0, 0, 0, 1);\">)\n                        {\n                            memcpy(Dest </span>+ Y * Stride + BlockSize, BlockB + Y * BlockB_W + <span style=\"color: rgba(128, 0, 128, 1);\">7</span>, BlockSize * <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n                        }\n                    }\n                }\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">#pragma</span> omp section<span style=\"color: rgba(0, 0, 0, 1);\">\n                {\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> Y = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; Y &lt; Height; Y++<span style=\"color: rgba(0, 0, 0, 1);\">)\n                    {\n                        memcpy(BlockC </span>+ Y * BlockC_W, Src + Y * Stride + <span style=\"color: rgba(128, 0, 128, 1);\">2</span> * BlockSize - <span style=\"color: rgba(128, 0, 128, 1);\">7</span>, BlockC_W * <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n                    }\n                    StatusC </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> IM_DCT_Denoising_8x8_SSE(BlockC, BlockC, BlockC_W, Height, BlockC_W, Sigma, FastMode);\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (StatusC !=<span style=\"color: rgba(0, 0, 0, 1);\"> IM_STATUS_OK)\n                    {\n                        Status </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> StatusC;\n                    }\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                    {\n                        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> Y = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; Y &lt; Height; Y++<span style=\"color: rgba(0, 0, 0, 1);\">)\n                        {\n                            memcpy(Dest </span>+ Y * Stride + <span style=\"color: rgba(128, 0, 128, 1);\">2</span> * BlockSize, BlockC + Y * BlockC_W + <span style=\"color: rgba(128, 0, 128, 1);\">7</span>, (Width - <span style=\"color: rgba(128, 0, 128, 1);\">2</span> * BlockSize) * <span style=\"color: rgba(0, 0, 255, 1);\">sizeof</span>(unsigned <span style=\"color: rgba(0, 0, 255, 1);\">char</span><span style=\"color: rgba(0, 0, 0, 1);\">));\n                        }\n                    }\n                }\n            }\n        FreeMemory:\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (BlockA !=<span style=\"color: rgba(0, 0, 0, 1);\"> NULL)        free(BlockA);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (BlockB !=<span style=\"color: rgba(0, 0, 0, 1);\"> NULL)        free(BlockB);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (BlockC !=<span style=\"color: rgba(0, 0, 0, 1);\"> NULL)        free(BlockC);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> Status;\n        }\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> Status;\n}</span></pre>\n</div>\n<p><span style=\"font-size: 13px;\">　　以上代码灰度图也是使用了3个线程，注意在中间块部分呢，两边都要进行适当的扩展，否则会形成一条比较明显的分界线，多线程加速也不是线性，开三个线程也是无法得到3倍加速的，大约为2倍左右的速度提升。</span></p>\n<p>　　就这么个算法，我把所有的可能旋向都做了实现，轻轻松松就弄了进7000行代码，也是会折腾。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/349293/202601/349293-20260113121831515-1819840843.png\" /></p>\n<p>　　现在年龄大了，感觉有的时候确实是折腾不动了，新的技术在不断发展，而我们依旧趴在老旧的技术上啃食。 不过呢也无所谓，20年前的CS1.6，占地1942，星际争霸现在玩起来还是有那种感觉。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/349293/202601/349293-20260113122100378-1890276755.png\" /></p>\n<p>　　&nbsp; 该算法在最新的Demo中已经更新，相关界面如上图所示，下载地址：<a href=\"https://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar\" target=\"_blank\">https://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar</a></p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 13:43</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Imageshop\">Imageshop</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}