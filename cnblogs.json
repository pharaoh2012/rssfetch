{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "AI Agent 框架探秘：拆解 OpenHands（6）--- 事件系统",
      "link": "https://www.cnblogs.com/rossiXYZ/p/19560027",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rossiXYZ/p/19560027\" id=\"cb_post_title_url\" title=\"å‘å¸ƒäºŽ 2026-02-04 21:10\">\n    <span>AI Agent æ¡†æž¶æŽ¢ç§˜ï¼šæ‹†è§£ OpenHandsï¼ˆ6ï¼‰--- äº‹ä»¶ç³»ç»Ÿ</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"ai-agent-æ¡†æž¶æŽ¢ç§˜æ‹†è§£-openhands6----äº‹ä»¶ç³»ç»Ÿ\">AI Agent æ¡†æž¶æŽ¢ç§˜ï¼šæ‹†è§£ OpenHandsï¼ˆ6ï¼‰--- äº‹ä»¶ç³»ç»Ÿ</h1>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">ç›®å½•</div><ul><li><a href=\"#ai-agent-æ¡†æž¶æŽ¢ç§˜æ‹†è§£-openhands6----äº‹ä»¶ç³»ç»Ÿ\" rel=\"noopener nofollow\">AI Agent æ¡†æž¶æŽ¢ç§˜ï¼šæ‹†è§£ OpenHandsï¼ˆ6ï¼‰--- äº‹ä»¶ç³»ç»Ÿ</a><ul><li><a href=\"#0x00-æ¦‚è¦\" rel=\"noopener nofollow\">0x00 æ¦‚è¦</a></li><li><a href=\"#0x01-eventstream\" rel=\"noopener nofollow\">0x01 EventStream</a><ul><li><a href=\"#11-åŠŸèƒ½\" rel=\"noopener nofollow\">1.1 åŠŸèƒ½</a></li><li><a href=\"#12-å®žçŽ°\" rel=\"noopener nofollow\">1.2 å®žçŽ°</a></li><li><a href=\"#13-è®¢é˜\" rel=\"noopener nofollow\">1.3 è®¢é˜…</a><ul><li><a href=\"#131-è®¢é˜…è€\" rel=\"noopener nofollow\">1.3.1 è®¢é˜…è€…</a></li><li><a href=\"#132-åˆ†å‘\" rel=\"noopener nofollow\">1.3.2 åˆ†å‘</a></li><li><a href=\"#133-èµ„æºç®¡ç†\" rel=\"noopener nofollow\">1.3.3 èµ„æºç®¡ç†</a></li></ul></li></ul></li><li><a href=\"#0x02-event\" rel=\"noopener nofollow\">0x02 Event</a><ul><li><a href=\"#21-event\" rel=\"noopener nofollow\">2.1 Event</a><ul><li><a href=\"#211-å®šä¹‰\" rel=\"noopener nofollow\">2.1.1 å®šä¹‰</a></li><li><a href=\"#212-åˆ†ç±»\" rel=\"noopener nofollow\">2.1.2 åˆ†ç±»</a></li></ul></li><li><a href=\"#22-action\" rel=\"noopener nofollow\">2.2 Action</a><ul><li><a href=\"#221-ç±»åž‹\" rel=\"noopener nofollow\">2.2.1 ç±»åž‹</a></li><li><a href=\"#222-æµç¨‹\" rel=\"noopener nofollow\">2.2.2 æµç¨‹</a></li></ul></li><li><a href=\"#23-observation\" rel=\"noopener nofollow\">2.3 Observation</a><ul><li><a href=\"#231-ç±»åž‹\" rel=\"noopener nofollow\">2.3.1 ç±»åž‹</a></li><li><a href=\"#232-æµç¨‹\" rel=\"noopener nofollow\">2.3.2 æµç¨‹</a></li><li><a href=\"#233-ç»†èŠ‚\" rel=\"noopener nofollow\">2.3.3 ç»†èŠ‚</a></li></ul></li><li><a href=\"#24-environment\" rel=\"noopener nofollow\">2.4 Environment</a></li><li><a href=\"#25-agentthinkaction\" rel=\"noopener nofollow\">2.5 AgentThinkAction</a><ul><li><a href=\"#anthropic--think-tool\" rel=\"noopener nofollow\">Anthropic  Think Tool</a><ul><li><a href=\"#ä½•æ—¶ä½¿ç”¨æ€è€ƒå·¥å…·\" rel=\"noopener nofollow\">ä½•æ—¶ä½¿ç”¨â€œæ€è€ƒâ€å·¥å…·</a></li><li><a href=\"#æœ€ä½³å®žè·µ\" rel=\"noopener nofollow\">æœ€ä½³å®žè·µ</a></li></ul></li><li><a href=\"#ä»£ç \" rel=\"noopener nofollow\">ä»£ç </a></li></ul></li></ul></li><li><a href=\"#0xff-å‚è€ƒ\" rel=\"noopener nofollow\">0xFF å‚è€ƒ</a></li></ul></li></ul></div><p></p>\n<h2 id=\"0x00-æ¦‚è¦\">0x00 æ¦‚è¦</h2>\n<p>å¦‚æžœè¯´ ReAct èŒƒå¼æ˜¯ä»£ç†çš„ â€œå¤§è„‘æ€ç»´æ¨¡å¼â€ï¼Œé‚£ä¹ˆäº‹ä»¶é©±åŠ¨æž¶æž„å°±æ˜¯Agentç³»ç»Ÿçš„ â€œç¥žç»ç½‘ç»œâ€ï¼Œå®ƒä½¿ç”¨äº†å‘å¸ƒ-è®¢é˜…æ¨¡å¼ï¼Œä»¥åŽ»ä¸­å¿ƒåŒ–çš„æ–¹å¼åè°ƒå„ç»„ä»¶é«˜æ•ˆè¿ä½œï¼Œå…è®¸ç»„ä»¶ä¹‹é—´çš„æ¾è€¦åˆé€šä¿¡ã€‚æ•´ä¸ªç³»ç»Ÿçš„æ ¸å¿ƒå¹¶éžåƒµç¡¬çš„åŒæ­¥è°ƒç”¨ï¼Œè€Œæ˜¯ä¸€æ¡æ‰¿è½½æ‰€æœ‰å…³é”®æ´»åŠ¨çš„ â€œäº‹ä»¶æµâ€ï¼Œç³»ç»Ÿä¸­çš„å„ç±»æ ¸å¿ƒæ“ä½œéƒ½ä¼šè¢«æŠ½è±¡ä¸ºæ ‡å‡†åŒ–çš„ â€œäº‹ä»¶â€ã€‚</p>\n<p>OpenHands ä¸­ï¼ŒEventStream è´Ÿè´£ç®¡ç†sessionä¸­çš„è§¦å‘çš„äº‹ä»¶ï¼Œä»¥åŠäº‹ä»¶æ³¨å†Œå‡½æ•°çš„å›žè°ƒé¡¹ç›®ä¸­æ³¨å†Œäº‹ä»¶å›žè°ƒå‡½æ•°ï¼Œæ¯”å¦‚ï¼š</p>\n<ul>\n<li><code>Runtime</code>æ³¨å†Œï¼šåªæŽ¥æ”¶<code>Action</code>çš„äº‹ä»¶ä¸Žruntimeè¿›è¡Œäº¤äº’</li>\n<li><code>AgentController</code>æ³¨å†Œï¼Œæ ¹æ®äº‹ä»¶æ›´æ–°AgentçŠ¶æ€</li>\n<li><code>main</code>ï¼šå‘½ä»¤è¡Œæ–¹å¼æ‰§è¡Œagentæ•ˆæžœè¯„ä¼°æ—¶ä½¿ç”¨ï¼ŒæŽ¥æ”¶agentçŠ¶æ€å˜æ›´äº‹ä»¶</li>\n</ul>\n<p>å› ä¸ºæœ¬ç³»åˆ—å€Ÿé‰´çš„æ–‡ç« è¿‡å¤šï¼Œå¯èƒ½åœ¨å‚è€ƒæ–‡çŒ®ä¸­æœ‰é—æ¼çš„æ–‡ç« ï¼Œå¦‚æžœæœ‰ï¼Œè¿˜è¯·å¤§å®¶æŒ‡å‡ºã€‚</p>\n<h2 id=\"0x01-eventstream\">0x01 EventStream</h2>\n<p>è¦æŽŒæ¡æ•´ä¸ªç¨‹åºçš„è¿ä½œï¼Œé¦–å…ˆè¦ç†è§£äº‹ä»¶ç³»ç»Ÿçš„ï¼Œå®ƒå°±åƒæ˜¯ç¨‹åºä¸­çš„ä¿¡æ¯é«˜é€Ÿå…¬è·¯ï¼Œå„ä¸ªéƒ¨åˆ†é€šè¿‡å®ƒæ¥äº¤æ¢ä¿¡æ¯ã€‚OpenHands äº‹ä»¶ç³»ç»Ÿçš„æ ¸å¿ƒæ˜¯<code>EventStream</code>ç±»ï¼ˆäº‹ä»¶æµç³»ç»Ÿï¼‰ï¼Œè¿™æ˜¯ä¸€ä¸ªä¸“é—¨å¤„ç†äº‹ä»¶çš„ç³»ç»Ÿï¼Œå®ƒçš„æ ¸å¿ƒä½œç”¨æ˜¯ç»´æŠ¤äº†äº‹ä»¶é˜Ÿåˆ—å¹¶æ”¯æŒäº‹ä»¶çš„å‘å¸ƒå’Œè®¢é˜…ï¼Œç®¡ç†å’Œåˆ†å‘äº‹ä»¶ã€‚è¿™ç§äº‹ä»¶é©±åŠ¨çš„æž¶æž„ä½¿OpenHandsèƒ½å¤Ÿå¤„ç†å¼‚æ­¥æ“ä½œï¼Œå¹¶æ”¯æŒå¤šAgentä¹‹é—´çš„åä½œã€‚</p>\n<p>OpenHands çš„ä»£ç å®žçŽ°ç›¸å¯¹ç®€å•ï¼Œå…³é”®åœ¨äºŽç†è§£å…¶å·¥ä½œåŽŸç†ã€‚ä¸»è¦æ­¥éª¤åŒ…æ‹¬ï¼š</p>\n<ul>\n<li>å¯åŠ¨ä¸€ä¸ªå¾ªçŽ¯è¿è¡Œçš„çº¿ç¨‹ï¼Œè¿™ä¸ªçº¿ç¨‹è´Ÿè´£ä»Žäº‹ä»¶é˜Ÿåˆ—ä¸­è¯»å–äº‹ä»¶ï¼Œå¹¶å°†å®ƒä»¬é€ä¸€å‘é€åˆ°å„ä¸ªè®¢é˜…æ¨¡å—çš„å¤„ç†é˜Ÿåˆ—ä¸­ã€‚</li>\n<li>å½“æ¨¡å—éœ€è¦è®¢é˜…äº‹ä»¶æ—¶ï¼Œå®ƒä¼šè°ƒç”¨ä¸€ä¸ªè®¢é˜…å‡½æ•°<code>subscribe</code>ï¼Œè¿™æ ·äº‹ä»¶æµå°±ä¼šä¸ºè¯¥æ¨¡å—ç»´æŠ¤ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œæ‰€æœ‰å‘é€åˆ°è¯¥æ¨¡å—çš„äº‹ä»¶éƒ½ä¼šè¢«ç›¸åº”çš„å›žè°ƒå‡½æ•°å¤„ç†ã€‚</li>\n<li>ä»»ä½•åœ°æ–¹éœ€è¦å‘äº‹ä»¶æµä¸­æ·»åŠ äº‹ä»¶æ—¶ï¼Œéƒ½ä¼šè°ƒç”¨ä¸€ä¸ªæ·»åŠ äº‹ä»¶çš„å‡½æ•°<code>add_event</code>ã€‚</li>\n</ul>\n<p>äº‹ä»¶æµçš„é€»è¾‘è™½ç„¶ç®€å•ï¼Œä½†ç¡®ä¿äº†ç¨‹åºå„éƒ¨åˆ†ä¹‹é—´çš„ç‹¬ç«‹æ€§å’Œé€šä¿¡çš„ä¸€è‡´æ€§ã€‚è¿™é‡Œçš„æ¶ˆæ¯éƒ½æ˜¯äº‹ä»¶ï¼Œåˆ†ä¸ºä¸¤ç§ç±»åž‹ï¼š</p>\n<ul>\n<li><code>Action</code>ï¼šæŒ‡éœ€è¦æ‰§è¡Œçš„ä»»åŠ¡ã€‚</li>\n<li><code>Observation</code>ï¼šæŒ‡çŽ¯å¢ƒå¯¹ä»»åŠ¡æ‰§è¡Œç»“æžœçš„å›žåº”ã€‚</li>\n</ul>\n<p>ä¸‹å›¾å±•ç¤ºäº† OpenHands ä¸­ Agent ä¸ŽçŽ¯å¢ƒäº¤äº’çš„æ ¸å¿ƒæœºåˆ¶ï¼šAgent é€šè¿‡æ‰§è¡ŒåŠ¨ä½œå½±å“çŽ¯å¢ƒï¼ŒçŽ¯å¢ƒé€šè¿‡è§‚å¯Ÿç»“æžœåé¦ˆç»™ Agentï¼ŒAgent åŸºäºŽè¿™äº›åé¦ˆåšå‡ºä¸‹ä¸€æ­¥å†³ç­–ã€‚ï¼š</p>\n<ul>\n<li>Agent å†³å®šæ‰§è¡Œä¸€ä¸ªåŠ¨ä½œï¼Œé€šè¿‡AgentControllerå’ŒEventStreamä¼ åˆ°äº†Runtimeã€‚</li>\n<li>Runtime åœ¨çŽ¯å¢ƒä¸­æ‰§è¡Œè¯¥åŠ¨ä½œ</li>\n<li>çŽ¯å¢ƒäº§ç”Ÿä¸€ä¸ªè§‚å¯Ÿç»“æžœä½œä¸ºæ‰§è¡Œç»“æžœ</li>\n<li>Runtime æ•èŽ·è¿™ä¸ªè§‚å¯Ÿç»“æžœå¹¶å‘é€åˆ° EventStreamï¼ˆäº‹ä»¶æµï¼‰</li>\n<li>EventStream å­˜å‚¨è§‚å¯Ÿç»“æžœï¼Œç„¶åŽé€šè¿‡AgentControlleré€šçŸ¥Agent</li>\n<li>Agent èŽ·å–æ›´æ–°åŽçš„åŽ†å²è®°å½•ï¼ˆåŒ…æ‹¬æ–°çš„è§‚å¯Ÿç»“æžœï¼‰</li>\n<li>Agent ä½¿ç”¨è§‚å¯Ÿç»“æžœåšå‡ºä¸‹ä¸€ä¸ªå†³ç­–</li>\n<li>å¾ªçŽ¯é‡å¤è¿›è¡Œ</li>\n</ul>\n<p><img alt=\"OpenHands-EventStream\" class=\"lazyload\" /></p>\n<h3 id=\"11-åŠŸèƒ½\">1.1 åŠŸèƒ½</h3>\n<p>EventStream çš„åŠŸèƒ½å¦‚ä¸‹ï¼š</p>\n<ul>\n<li>äº‹ä»¶è®¢é˜…ä¸Žé€šçŸ¥æœºåˆ¶ã€‚\n<ul>\n<li>å¤šè®¢é˜…è€…æ”¯æŒï¼šé€šè¿‡EventStreamSubscriberæžšä¸¾å®šä¹‰äº†å¤šç§è®¢é˜…è€…ç±»åž‹ã€‚</li>\n<li>çµæ´»è®¢é˜…æœºåˆ¶ï¼šä½¿ç”¨ subscribe å’Œ unscribe æ–¹æ³•ç®¡ç†è®¢é˜…å…³ç³»ã€‚</li>\n<li>å¤šå›žè°ƒæ”¯æŒï¼šæ¯ä¸ªè®¢é˜…è€…å¯ä»¥æ³¨å†Œå¤šä¸ªå›žè°ƒå‡½æ•°ï¼Œé€šè¿‡callback_idè¿›è¡ŒåŒºåˆ†ã€‚</li>\n</ul>\n</li>\n<li>äº‹ä»¶å¤„ç†ä¸Žåˆ†å‘\n<ul>\n<li>å¼‚æ­¥é˜Ÿåˆ—å¤„ç†ï¼šä½¿ç”¨ queue.Queueå’Œç‹¬ç«‹çº¿ç¨‹å¤„ç†äº‹ä»¶é˜Ÿåˆ—ã€‚</li>\n<li>çº¿ç¨‹æ± æ‰§è¡Œï¼šä¸ºæ¯ä¸ªè®¢é˜…è€…çš„å›žè°ƒå‡½æ•°åˆ›å»ºç‹¬ç«‹çš„çº¿ç¨‹æ± ï¼Œé¿å…é˜»å¡žã€‚</li>\n<li>é¡ºåºåˆ†å‘ï¼šæŒ‰ç…§è®¢é˜…è€…IDçš„æŽ’åºé¡ºåºå°†äº‹ä»¶åˆ†å‘ç»™è®¢é˜…è€…ã€‚</li>\n</ul>\n</li>\n<li>äº‹ä»¶å­˜å‚¨ä¸ŽæŒä¹…åŒ–\n<ul>\n<li>äº‹ä»¶IDç®¡ç†ï¼šä¸ºæ¯ä¸ªäº‹ä»¶åˆ†é…å”¯ä¸€IDå¹¶ç»´æŠ¤é€’å¢žè®¡æ•°å™¨ã€‚</li>\n<li>æ—¶é—´æˆ³è®°å½•ï¼šè‡ªåŠ¨ä¸ºäº‹ä»¶æ·»åŠ æ—¶é—´æˆ³ã€‚</li>\n<li>æ–‡ä»¶å­˜å‚¨ï¼šå°†äº‹ä»¶ä»¥JSONæ ¼å¼æŒä¹…åŒ–åˆ°æ–‡ä»¶ç³»ç»Ÿã€‚</li>\n<li>ç¼“å­˜é¡µé¢æœºåˆ¶ï¼šä½¿ç”¨é¡µé¢ç¼“å­˜æé«˜å¤§é‡äº‹ä»¶çš„è¯»å†™æ€§èƒ½ã€‚</li>\n</ul>\n</li>\n<li>å·¥ä½œæµç¨‹ï¼š\n<ul>\n<li>ç»„ä»¶é€šè¿‡subscribeæ–¹æ³•æ³¨å†Œä¸ºäº‹ä»¶è®¢é˜…è€…ã€‚</li>\n<li>å½“æœ‰äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œé€šè¿‡add_eventæ–¹æ³•æ·»åŠ åˆ°äº‹ä»¶æµã€‚</li>\n<li>add_eventæ–¹æ³•å¤„ç†äº‹ä»¶IDåˆ†é…ï¼Œæ—¶é—´æˆ³è®¾ç½®ã€æŒä¹…åŒ–å­˜å‚¨ã€‚</li>\n<li>äº‹ä»¶è¢«æ”¾å…¥å¤„ç†é˜Ÿåˆ—ï¼Œç”±ç‹¬ç«‹çº¿ç¨‹å¼‚æ­¥åˆ†å‘ã€‚</li>\n<li>_process_queue åˆ†å‘æŒ‰ç…§é¡ºåºå°†äº‹ä»¶åˆ†å‘ç»™æ‰€æœ‰è®¢é˜…è€…çš„å›žè°ƒå‡½æ•°ã€‚</li>\n</ul>\n</li>\n</ul>\n<p>è¿™ç§è®¾è®¡ä½¿EventStreamç§°ä¸ºç³»ç»Ÿä¸­æ ¸å¿ƒçš„äº‹ä»¶ä¸­æž¢ï¼Œå®žçŽ°äº†ç»„ä»¶é—´çš„è§£è€¦å’Œå¼‚æ­¥é€šä¿¡ã€‚</p>\n<h3 id=\"12-å®žçŽ°\">1.2 å®žçŽ°</h3>\n<p>EventStream ç›¸å…³çš„ä»£ç å¦‚ä¸‹ï¼š</p>\n<pre><code class=\"language-python\">class EventStream(EventStore):\n    secrets: dict[str, str]\n    # For each subscriber ID, there is a map of callback functions - useful\n    # when there are multiple listeners\n    _subscribers: dict[str, dict[str, Callable]]\n    _lock: threading.Lock\n    _queue: queue.Queue[Event]\n    _queue_thread: threading.Thread\n    _queue_loop: asyncio.AbstractEventLoop | None\n    _thread_pools: dict[str, dict[str, ThreadPoolExecutor]]\n    _thread_loops: dict[str, dict[str, asyncio.AbstractEventLoop]]\n    _write_page_cache: list[dict]\n\n    def __init__(self, sid: str, file_store: FileStore, user_id: str | None = None):\n        super().__init__(sid, file_store, user_id)\n        self._stop_flag = threading.Event()\n        self._queue: queue.Queue[Event] = queue.Queue()\n        self._thread_pools = {}\n        self._thread_loops = {}\n        self._queue_loop = None\n        self._queue_thread = threading.Thread(target=self._run_queue_loop)\n        self._queue_thread.daemon = True\n        self._queue_thread.start()\n        self._subscribers = {}\n        self._lock = threading.Lock()\n        self.secrets = {}\n        self._write_page_cache = []\n\n    def _init_thread_loop(self, subscriber_id: str, callback_id: str) -&gt; None:\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        if subscriber_id not in self._thread_loops:\n            self._thread_loops[subscriber_id] = {}\n        self._thread_loops[subscriber_id][callback_id] = loop\n</code></pre>\n<h3 id=\"13-è®¢é˜…\">1.3 è®¢é˜…</h3>\n<p>ä»»ä½•å¤æ‚ä»»åŠ¡çš„æ‰§è¡Œï¼Œéƒ½ç¦»ä¸å¼€å¯¹çŠ¶æ€å˜åŒ–çš„ç²¾å‡†æ„ŸçŸ¥ä¸Žå®žæ—¶å“åº”ã€‚OpenHands é‡‡ç”¨è§‚å¯Ÿè€…æ¨¡å¼ä½œä¸ºä»»åŠ¡è°ƒåº¦çš„æ ¸å¿ƒæœºåˆ¶ï¼Œå…¶è®¾è®¡çµæ„Ÿæºè‡ªçŽ°å®žä¸–ç•Œçš„ \"æŒ‡æŒ¥ - ä¾¦å¯Ÿ\" ä½“ç³» â€”â€” å°±åƒæˆ˜åœºä¸Šçš„æŒ‡æŒ¥å®˜éœ€è¦ä¾¦å¯Ÿå…µå®žæ—¶ä¼ é€’å‰çº¿åŠ¨æ€ï¼Œæ¡†æž¶ä¸­çš„è°ƒåº¦ä¸­å¿ƒä¹Ÿä¾èµ–åˆ†å¸ƒå¼çš„ \"çŠ¶æ€è§‚å¯Ÿè€…\" æ¥æŽŒæ¡æ¯ä¸€ä¸ªä»»åŠ¡çš„è¿›å±•ã€‚</p>\n<p>å…·ä½“è€Œè¨€ï¼Œç³»ç»Ÿå°†ä»»åŠ¡æ‹†è§£ä¸ºä¸€ç³»åˆ—å¯ç›‘æŽ§çš„ \"çŠ¶æ€èŠ‚ç‚¹\"ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½é…å¤‡ä¸“å±žçš„è§‚å¯Ÿè€…å®žä¾‹ã€‚å½“æŸä¸€èŠ‚ç‚¹çš„çŠ¶æ€å‘ç”Ÿå˜æ›´ï¼ˆä¾‹å¦‚ä»Ž \"å¾…æ‰§è¡Œ\" è½¬ä¸º \"æ‰§è¡Œä¸­\"ï¼Œæˆ–ä»Ž \"æˆåŠŸ\" è½¬ä¸º \"å¤±è´¥\"ï¼‰ï¼Œè§‚å¯Ÿè€…ä¼šç«‹å³è§¦å‘é¢„è®¾çš„å›žè°ƒé€»è¾‘ï¼Œé€šçŸ¥è°ƒåº¦ä¸­å¿ƒè¿›è¡Œä¸‹ä¸€æ­¥å¤„ç†ã€‚è¿™ç§è®¾è®¡å¸¦æ¥äº†ä¸¤å¤§æ ¸å¿ƒä¼˜åŠ¿ï¼š</p>\n<ul>\n<li>\n<p>å®žçŽ°äº†ä»»åŠ¡è°ƒåº¦çš„ \"æ¾è€¦åˆ\"ã€‚è°ƒåº¦ä¸­å¿ƒæ— éœ€ä¸»åŠ¨æŸ¥è¯¢æ¯ä¸ªä»»åŠ¡çš„çŠ¶æ€ï¼Œè€Œæ˜¯è¢«åŠ¨æŽ¥æ”¶çŠ¶æ€å˜æ›´é€šçŸ¥ï¼Œè¿™å¤§å¹…é™ä½Žäº†ç³»ç»Ÿå„æ¨¡å—é—´çš„ä¾èµ–å…³ç³»ï¼Œä½¿å¾—æ–°å¢žä»»åŠ¡ç±»åž‹æˆ–ä¿®æ”¹è°ƒåº¦é€»è¾‘æ—¶ï¼Œæ— éœ€é‡æž„æ•´ä¸ªæ¡†æž¶ã€‚</p>\n</li>\n<li>\n<p>æ”¯æŒåŠ¨æ€ä¼˜å…ˆçº§è°ƒæ•´ã€‚å½“é«˜ç´§æ€¥åº¦çš„ä»»åŠ¡æ’å…¥æ—¶ï¼Œè§‚å¯Ÿè€…å¯å®žæ—¶æ•èŽ·è¿™ä¸€äº‹ä»¶ï¼Œè§¦å‘è°ƒåº¦ä¸­å¿ƒçš„ä¼˜å…ˆçº§é‡æŽ’æœºåˆ¶ï¼Œæš‚åœä½Žä¼˜å…ˆçº§ä»»åŠ¡çš„èµ„æºåˆ†é…ï¼Œç¡®ä¿å…³é”®ä»»åŠ¡ä¼˜å…ˆæ‰§è¡Œã€‚è¿™ç§çµæ´»æ€§åœ¨å¤šé¡¹ç›®å¹¶è¡Œçš„åœºæ™¯ä¸­å°¤ä¸ºé‡è¦ã€‚</p>\n</li>\n</ul>\n<p>åœ¨è¿™ä¸€æž¶æž„ä¸­ï¼Œæ‰€æœ‰ç»„ä»¶éƒ½æ‰®æ¼”ç€ â€œç”Ÿäº§è€…â€ æˆ– â€œæ¶ˆè´¹è€…â€ çš„è§’è‰²ã€‚ç”Ÿäº§è€…è´Ÿè´£ç”Ÿæˆäº‹ä»¶ï¼šä»£ç†å†³ç­–åŽäº§ç”Ÿ â€œåŠ¨ä½œäº‹ä»¶â€ï¼Œè¿è¡Œæ—¶çŽ¯å¢ƒæ‰§è¡Œä»»åŠ¡åŽç”Ÿæˆ â€œåé¦ˆäº‹ä»¶â€ã€‚æ¶ˆè´¹è€…åˆ™é€šè¿‡è®¢é˜…ç‰¹å®šäº‹ä»¶èŽ·å–ä¿¡æ¯å¹¶å“åº”ï¼šè¿è¡Œæ—¶è®¢é˜… â€œåŠ¨ä½œäº‹ä»¶â€ ä»¥æ‰§è¡Œå…·ä½“ä»»åŠ¡ï¼ŒæŽ§åˆ¶å™¨è®¢é˜…å…¨é‡äº‹ä»¶ä»¥ç»´æŠ¤ç³»ç»ŸçŠ¶æ€ã€‚è¿™ç§åŸºäºŽäº‹ä»¶çš„äº¤äº’æ¨¡å¼ï¼Œå½»åº•æ‰“ç ´äº†ç»„ä»¶é—´çš„ç›´æŽ¥ä¾èµ–ã€‚</p>\n<p>äº‹ä»¶æµåƒä¸€æ¡çŽ¯å½¢é«˜æž¶ï¼Œä»»ä½•è½¦è¾†ï¼ˆäº‹ä»¶ï¼‰ä¸€æ—¦é©¶å…¥ï¼Œå°±ä¼šè¢«å¹¶è¡ŒåŒé“åˆ†æµåˆ°å‡ åº§æ”¶è´¹ç«™â€”â€”Sessionã€Runtimeã€Memory ã€ AgentControllerã€......ã€‚å®ƒä»¬å„è‡ªé¢†å–ä¸“å±žã€Œé€šè¡Œåˆ¸ã€ï¼ˆSubscriber æ ‡è¯†ï¼‰ï¼Œåœ¨åŒä¸€æ—¶åˆ»å¯¹åŒä¸€è¾†è½¦è¿›è¡Œå®‰æ£€ã€æ”¶è´¹æˆ–è®°å½•ï¼Œè€Œæ— éœ€ç­‰å¾…å‰ä¸€å…³å¡æ”¾è¡Œã€‚</p>\n<h4 id=\"131-è®¢é˜…è€…\">1.3.1 è®¢é˜…è€…</h4>\n<p>_subscribers å’Œ subscriber_id èµ·åˆ°å¦‚ä¸‹ä½œç”¨ã€‚</p>\n<p>subscriber_id ä¼šå”¯ä¸€æ ‡è¯†ä¸€ä¸ªè®¢é˜…è€…ï¼Œæ¯ä¸ªè®¢é˜…è€…ä»£è¡¨ç³»ç»Ÿçš„ä¸åŒç»„ä»¶æˆ–è€…æœåŠ¡ã€‚ä¸åŒçš„è®¢é˜…è€…ä¼šå¤„ç†äº‹ä»¶ï¼Œæ¯”å¦‚ï¼š</p>\n<ul>\n<li>\n<p>EventStreamSubscriber.SERVER: æœåŠ¡å™¨å¤„ç†</p>\n</li>\n<li>\n<p>EventStreamSubscriber.RUNTIME: è¿è¡Œæ—¶å¤„ç†</p>\n</li>\n<li>\n<p>EventStreamSubscriber.AGENT_CONTROLLER: ä»£ç†æŽ§åˆ¶å™¨å¤„ç†</p>\n</li>\n</ul>\n<pre><code class=\"language-python\">class EventStreamSubscriber(str, Enum):\n    AGENT_CONTROLLER = 'agent_controller'\n    RESOLVER = 'openhands_resolver'\n    SERVER = 'server'\n    RUNTIME = 'runtime'\n    MEMORY = 'memory'\n    MAIN = 'main'\n    TEST = 'test'\n</code></pre>\n<p>å‡ ä¸ªå¤§æ¨¡å—éƒ½æ˜¯åœ¨<code>__init__</code>å‡½æ•°ä¸­å®Œæˆæ¨¡å—çš„åˆå§‹åŒ–å‡†å¤‡å·¥ä½œï¼Œå¹¶ä¸”å‘äº‹ä»¶æµä¸­è®¢é˜…æ¶ˆæ¯å¹¶æ³¨å†Œå„è‡ªæ¨¡å—çš„æ¶ˆæ¯å¤„ç†å‡½æ•°ã€‚äº‹ä»¶å›žè°ƒå‡½æ•°ä¼šæ ¹æ®å½“å‰çš„äº‹ä»¶è¿›è¡ŒçŠ¶æ€æœºçš„çŠ¶æ€è½¬ç§»ã€‚</p>\n<ul>\n<li>Runtime åœ¨äº‹ä»¶æµä¸­è®¢é˜… EventStreamSubscriber.RUNTIMEï¼Œäº‹ä»¶å›žè°ƒå‡½æ•°ä¼šå¤„ç†éœ€è¦runtineå¤„ç†çš„actionï¼Œæ¯”å¦‚mcp/toolç­‰ç­‰ã€‚<code>Runtime</code>åªå¤„ç†å¯è¿è¡Œçš„<code>Action</code>äº‹ä»¶ï¼Œæ‰§è¡ŒåŠ¨ä½œæ‹¿åˆ°è¾“å‡º<code>Observation</code>å‘é€å›žäº‹ä»¶æµä¸­<code>isinstance(event, MCPAction)</code>æ‰§è¡ŒMCPèŽ·å–ç»“æžœå…¶ä»–runtimeæ”¯æŒçš„actionåˆ™æ‰§è¡ŒèŽ·å–ç»“æžœã€‚</li>\n<li>Memory åœ¨äº‹ä»¶æµä¸­è®¢é˜… EventStreamSubscriber.MEMORYã€‚äº‹ä»¶å›žè°ƒå‡½æ•°æ ¹æ®å½“å‰çš„<code>event</code>ç”Ÿæˆä¸€ä¸ªå¸¦<code>microagent_knowledge</code>çš„<code>RecallObservation</code>å¹¶ä»¥<code>ENVIRONMENT</code>ä½œä¸ºæºæ·»åŠ å›žäº‹ä»¶æµä¸­ï¼Œè¿™é‡Œçš„<code>microagent_knowledge</code>æ˜¯ä¸€ç§ç‰¹å®šæç¤ºè¯å¢žå¼ºçš„æ–¹æ³•ã€‚<code>Memory</code>åªå¤„ç†<code>RecallAction</code>ï¼Œå¯¹äºŽç”¨æˆ·é¦–æ¬¡è¾“å…¥ä¿¡æ¯åˆ™å°†ä¸€äº›é¢å¤–çš„å·¥ä½œç©ºé—´ä¸Šä¸‹æ–‡ä¿¡æ¯æ·»åŠ åˆ°<code>RecallObservation</code>å‘é€å›žäº‹ä»¶æµä¸­ï¼Œå¯¹äºŽå…¶ä»–éžç”¨æˆ·é¦–æ¬¡çš„è¾“å…¥ä¿¡æ¯åˆ™åŠ å…¥microagent_knowledgeåˆ°<code>RecallObservation</code>å‘é€å›žäº‹ä»¶æµä¸­ã€‚</li>\n<li>AgentController åœ¨äº‹ä»¶æµä¸­è®¢é˜… EventStreamSubscriber.AGENT_CONTROLLERã€‚<code>AgentController</code>ä½œä¸ºä¸»è¦çŠ¶æ€ç®¡ç†æ¨¡å—ï¼Œ\n<ul>\n<li>æ ¹æ®<code>Observation</code>äº‹ä»¶è¿›è¡ŒçŠ¶æ€å˜æ¢</li>\n<li>æ ¹æ®<code>Action</code>è¿›è¡ŒçŠ¶æ€å˜æ¢å’Œä»¥ä¸‹å¤„ç†ï¼š\n<ul>\n<li>å¯¹äºŽ<code>MessageAction</code>å‘é€<code>RecallAction</code>åˆ°äº‹ä»¶æµä¸­</li>\n<li>å¯¹äºŽ<code>AgentDelegateAction</code>åšAgentè·¯ç”±ï¼ˆåŽç»­æœºåˆ¶è§£è¯»ä¸­å†è¯¦ç»†ä»‹ç»ï¼‰</li>\n</ul>\n</li>\n<li>æ ¹æ®å½“å‰çš„<code>event</code>åˆ¤æ–­è¿›è¡Œè°ƒç”¨<code>agent.step</code></li>\n</ul>\n</li>\n<li>run_controller åœ¨äº‹ä»¶æµä¸­è®¢é˜… EventStreamSubscriber.MAINã€‚</li>\n<li>WebSessionã€ConversationManager ä¼šè®¢é˜… EventStreamSubscriber.SERVERã€‚</li>\n</ul>\n<h4 id=\"132-åˆ†å‘\">1.3.2 åˆ†å‘</h4>\n<p>ç”¨æˆ·å‘é€æ¶ˆæ¯æ·»åŠ äº†ä¸€æ¡æ¶ˆæ¯åˆ°æ¶ˆæ¯æµä¸­ï¼Œç³»ç»Ÿä¼šä¾æ® subscriber_id æ¥å†³å®šå“ªäº›è®¢é˜…è€…åº”è¯¥æŽ¥æ”¶è¯¥ç±»äº‹ä»¶ã€‚è¿™æ¡æ¶ˆæ¯ä¼šè¢«å¹¿æ’­åˆ°æ¯ä¸€ä¸ªæ¶ˆæ¯é€šé“ä¸­ï¼Œé€šè¿‡æ³¨å†Œçš„å›žè°ƒå‡½æ•°å¯ä»¥åˆ†æžå“ªäº›æ¨¡å—å¯¹æ¶ˆæ¯è¿›è¡Œäº†å¤„ç†ã€‚</p>\n<pre><code class=\"language-python\">    async def _process_queue(self) -&gt; None:\n        while should_continue() and not self._stop_flag.is_set():\n            event = None\n            try:\n                event = self._queue.get(timeout=0.1)\n            except queue.Empty:\n                continue\n\n            # pass each event to each callback in order\n            for key in sorted(self._subscribers.keys()): # æ­¤å¤„ä¼šå†³å®šåˆ†å‘åˆ°å“ªé‡Œ\n                callbacks = self._subscribers[key]\n                # Create a copy of the keys to avoid \"dictionary changed size during iteration\" error\n                callback_ids = list(callbacks.keys())\n                for callback_id in callback_ids:\n                    # Check if callback_id still exists (might have been removed during iteration)\n                    if callback_id in callbacks:\n                        callback = callbacks[callback_id]\n                        pool = self._thread_pools[key][callback_id]\n                        future = pool.submit(callback, event)\n                        future.add_done_callback(\n                            self._make_error_handler(callback_id, key)\n                        )\n</code></pre>\n<h4 id=\"133-èµ„æºç®¡ç†\">1.3.3 èµ„æºç®¡ç†</h4>\n<p>subscriber_id å¸®åŠ©ç³»ç»Ÿç®¡ç†æ¯ä¸ªè®¢é˜…è€…çš„èµ„æºã€‚</p>\n<pre><code class=\"language-python\">    def _clean_up_subscriber(self, subscriber_id: str, callback_id: str) -&gt; None:\n        if subscriber_id not in self._subscribers:\n            logger.warning(f'Subscriber not found during cleanup: {subscriber_id}')\n            return\n        if callback_id not in self._subscribers[subscriber_id]:\n            logger.warning(f'Callback not found during cleanup: {callback_id}')\n            return\n        if (\n            subscriber_id in self._thread_loops\n            and callback_id in self._thread_loops[subscriber_id]\n        ):\n            loop = self._thread_loops[subscriber_id][callback_id]\n            current_task = asyncio.current_task(loop)\n            pending = [\n                task for task in asyncio.all_tasks(loop) if task is not current_task\n            ]\n            for task in pending:\n                task.cancel()\n            try:\n                loop.stop()\n                loop.close()\n            except Exception as e:\n                logger.warning(\n                    f'Error closing loop for {subscriber_id}/{callback_id}: {e}'\n                )\n            del self._thread_loops[subscriber_id][callback_id]\n\n        if (\n            subscriber_id in self._thread_pools\n            and callback_id in self._thread_pools[subscriber_id]\n        ):\n            pool = self._thread_pools[subscriber_id][callback_id]\n            pool.shutdown()\n            del self._thread_pools[subscriber_id][callback_id]\n\n        del self._subscribers[subscriber_id][callback_id]\n</code></pre>\n<h2 id=\"0x02-event\">0x02 Event</h2>\n<p>åœ¨ OpenHands ç³»ç»Ÿä¸­ï¼ŒEvent æ˜¯ç³»ç»Ÿä¸­æœ€åŸºæœ¬çš„æ•°æ®å•å…ƒï¼Œä»£è¡¨ç³»ç»Ÿä¸­å‘ç”Ÿçš„å„ç§åŠ¨ä½œå’Œè§‚å¯Ÿç»“æžœï¼ˆç”¨æˆ·è¾“å…¥ã€æ™ºèƒ½ä½“æ–‡æœ¬ã€å·¥å…·è°ƒç”¨/ç»“æžœã€çŠ¶æ€å˜æ›´è¯·æ±‚ã€æŽ§åˆ¶ä¿¡å·ï¼‰ã€‚æ‰€æœ‰äº‹ä»¶éƒ½ç»§æ‰¿è‡ª Event åŸºç±»ã€‚è¡¨ç¤ºä¸€ä¸ªåŽŸå­æ€§äº‹ä»¶ã€‚</p>\n<p>æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æžœæˆ‘ä»¬æŠŠ<code>Event Stream</code>æ¯”ä½œä¸€ä¸ªä¿¡æ¯ä¼ é€’çš„â€œé‚®æ”¿ç³»ç»Ÿâ€ï¼Œé‚£ä¹ˆ<code>Event</code>å°±æ˜¯è¿™ä¸ªç³»ç»Ÿä¸­ä¼ é€’çš„â€œä¿¡ä»¶â€ã€‚åœ¨OpenHandsä¸­ï¼Œ<code>Event</code>æ˜¯æœ€åŸºæœ¬çš„ä¿¡æ¯å•ä½ï¼Œå®ƒæ˜¯ä¸€ä¸ªæ ‡å‡†åŒ–çš„æ•°æ®ç»“æž„ï¼Œç”¨æ¥è®°å½•ç³»ç»Ÿä¸­å‘ç”Ÿçš„ä»»ä½•é‡è¦äº‹ä»¶ã€‚</p>\n<p>é€šè¿‡å°†Agentçš„æ€è€ƒï¼ˆç”±LLMç”Ÿæˆçš„è‡ªç„¶è¯­è¨€è¾“å‡ºï¼‰ä¸Žç³»ç»Ÿçš„å®žé™…æ‰§è¡Œï¼ˆç»“æž„åŒ–çš„Action/Observationï¼‰åˆ†å¼€ï¼Œæˆ‘ä»¬è§£å†³äº†æ„å›¾ä¸Žæ‰§è¡Œä¹‹é—´çš„éš”ç¦»ã€‚LLMè´Ÿè´£å†³å®šâ€œè¦åšä»€ä¹ˆâ€ï¼Œè€ŒAction/Observationåˆ™è¯¦ç»†è¯´æ˜Žäº†â€œæ€Žæ ·åŽ»åšâ€å’Œâ€œç»“æžœå¦‚ä½•â€ï¼Œè¿™ç¡®ä¿äº†ç³»ç»Ÿçš„ç¨³å®šæ€§å’Œå¯é¢„æµ‹æ€§ã€‚</p>\n<h3 id=\"21-event\">2.1 Event</h3>\n<h4 id=\"211-å®šä¹‰\">2.1.1 å®šä¹‰</h4>\n<p>æ¯ä¸€ä¸ª <code>Event</code> å¯¹è±¡éƒ½æºå¸¦äº†ä¸€äº›å…ƒæ•°æ®ï¼Œå°±åƒä¿¡å°ä¸Šçš„ä¿¡æ¯ï¼š</p>\n<ul>\n<li><code>id</code>: äº‹ä»¶çš„å”¯ä¸€æ ‡è¯†ç¬¦ã€‚</li>\n<li><code>source</code>: äº‹ä»¶çš„æ¥æºï¼Œå¯ä»¥æ˜¯ <code>AGENT</code>ã€<code>USER</code> æˆ– <code>ENVIRONMENT</code>ã€‚</li>\n<li><code>timestamp</code>: äº‹ä»¶å‘ç”Ÿçš„æ—¶é—´æˆ³ã€‚</li>\n<li><code>cause</code>: è§¦å‘æ­¤äº‹ä»¶çš„å¦ä¸€ä¸ªäº‹ä»¶çš„ <code>id</code>ã€‚</li>\n</ul>\n<p>å°†ç³»ç»Ÿä¸­çš„æ‰€æœ‰äº’åŠ¨éƒ½æŠ½è±¡ä¸º<code>Event</code>ï¼Œæˆ‘ä»¬å¾—åˆ°äº†ä¸€ç§é€šç”¨çš„è¯­è¨€ã€‚æ— è®ºæ˜¯Agentçš„å†³ç­–ã€ç”¨æˆ·çš„æ¶ˆæ¯è¿˜æ˜¯çŽ¯å¢ƒçš„åé¦ˆï¼Œéƒ½å¯ä»¥ç»Ÿä¸€å¤„ç†ã€å­˜å‚¨å’Œåˆ†å‘ã€‚ç‰¹åˆ«æ˜¯<code>cause</code>å­—æ®µï¼Œå®ƒåƒä¸€æ¡çœ‹ä¸è§çš„çº¿ï¼Œå°†Actionå’Œå®ƒå¼•èµ·çš„Observationç´§å¯†è”ç³»èµ·æ¥ï¼Œå½¢æˆäº†ReActå¾ªçŽ¯çš„å› æžœé“¾ï¼Œè¿™å¯¹äºŽç†è§£å’Œè°ƒè¯•Agentçš„è¡Œä¸ºè‡³å…³é‡è¦ã€‚</p>\n<p>éƒ¨åˆ†ä»£ç å¦‚ä¸‹ï¼š</p>\n<pre><code class=\"language-python\">@dataclass\nclass Event:\n    INVALID_ID = -1\n\n    @property\n    def message(self) -&gt; str | None:\n        if hasattr(self, '_message'):\n            msg = getattr(self, '_message')\n            return str(msg) if msg is not None else None\n        return ''\n\n    @property\n    def id(self) -&gt; int:\n        if hasattr(self, '_id'):\n            id_val = getattr(self, '_id')\n            return int(id_val) if id_val is not None else Event.INVALID_ID\n        return Event.INVALID_ID\n</code></pre>\n<p>EventStream å¯¹Eventçš„å¤„ç†è¿‡ç¨‹ä¸ºï¼š</p>\n<ul>\n<li>\n<p>äº‹ä»¶é€šè¿‡ add_event æ–¹æ³•æ·»åŠ åˆ°æµä¸­</p>\n</li>\n<li>\n<p>ç³»ç»Ÿè‡ªåŠ¨åˆ†é… ID å’Œæ—¶é—´æˆ³</p>\n</li>\n<li>\n<p>äº‹ä»¶è¢«å­˜å‚¨åˆ°æ–‡ä»¶ç³»ç»Ÿ</p>\n</li>\n<li>\n<p>äº‹ä»¶è¢«æ”¾å…¥å¤„ç†é˜Ÿåˆ—</p>\n</li>\n</ul>\n<p>ç³»ç»Ÿé€šè¿‡ event_to_dict å’Œ event_from_dict å‡½æ•°å¤„ç†äº‹ä»¶çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–ï¼Œç¡®ä¿äº‹ä»¶å¯ä»¥åœ¨ä¸åŒç»„ä»¶é—´ä¼ è¾“å’Œå­˜å‚¨ã€‚</p>\n<h4 id=\"212-åˆ†ç±»\">2.1.2 åˆ†ç±»</h4>\n<p>æŒ‰ç…§åŠŸèƒ½åˆ†ç±»ï¼Œäº‹ä»¶ä¸»è¦åˆ†ä¸ºä¸¤ç±»ï¼š</p>\n<ul>\n<li>ç¬¬ä¸€ç§æ˜¯Actionï¼ˆè¡ŒåŠ¨ï¼‰ï¼Œå®ƒä»£è¡¨äº†æ™ºèƒ½ä»£ç†æƒ³è¦å¯¹çŽ¯å¢ƒæ‰§è¡Œçš„å…·ä½“æ“ä½œã€‚è¿™å¹¶ä¸æ˜¯æ¨¡ç³Šä¸æ¸…çš„è‡ªç„¶è¯­è¨€æè¿°ï¼Œè€Œæ˜¯ä¸€ä¸ªæ˜Žç¡®çš„æŒ‡ä»¤ã€‚ä¾‹å¦‚ï¼Œå¦‚æžœä»£ç†æƒ³è¦åˆ—å‡ºæŸä¸ªç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶ï¼Œå®ƒä¼šå‘é€ä¸€ä¸ªæ¸…æ™°çš„æŒ‡ä»¤ï¼Œå¦‚â€œæ‰§è¡Œå‘½ä»¤'ls -l'â€ã€‚è¿™æ ·çš„æŒ‡ä»¤è®©ç³»ç»Ÿèƒ½å¤Ÿå‡†ç¡®æ— è¯¯åœ°ç†è§£ä»£ç†çš„æ„å›¾å¹¶æ‰§è¡Œç›¸åº”çš„æ“ä½œã€‚</li>\n<li>ç¬¬äºŒç§æ˜¯Observationï¼ˆè§‚å¯Ÿï¼‰ï¼Œå®ƒä»£è¡¨äº†æ™ºèƒ½ä»£ç†ä»ŽçŽ¯å¢ƒä¸­æ”¶é›†åˆ°çš„ä¿¡æ¯ã€‚è¿™é€šå¸¸æ˜¯åœ¨æ‰§è¡Œäº†æŸä¸ªè¡ŒåŠ¨ä¹‹åŽï¼Œç³»ç»Ÿç»™äºˆçš„åé¦ˆã€‚ä¾‹å¦‚ï¼Œå¦‚æžœä»£ç†æ‰§è¡Œäº†ä¸€ä¸ªåˆ—å‡ºæ–‡ä»¶çš„å‘½ä»¤ï¼Œè§‚å¯Ÿå°±ä¼šåŒ…å«æ‰§è¡Œç»“æžœçš„è¯¦ç»†ä¿¡æ¯ï¼Œå¦‚â€œè¾“å‡ºå†…å®¹ä¸º'...'ï¼Œé€€å‡ºä»£ç ä¸º0â€ã€‚è¿™äº›ä¿¡æ¯å¸®åŠ©ä»£ç†äº†è§£å…¶è¡ŒåŠ¨çš„ç»“æžœï¼Œå¹¶ä¸ºä¸‹ä¸€æ­¥è¡ŒåŠ¨æä¾›ä¾æ®ã€‚</li>\n</ul>\n<p>æŒ‰æ¥æºï¼Œäº‹ä»¶åˆ†ç±»å¦‚ä¸‹ï¼š</p>\n<ul>\n<li>EventSource.AGENT æ¥è‡ªä»£ç†çš„æ“ä½œå’Œè§‚å¯Ÿç»“æžœ</li>\n<li>EventSource.USER æ¥è‡ªç”¨æˆ·çš„æ“ä½œ</li>\n<li>EventSource.ENVIRONMENT æ¥è‡ªçŽ¯å¢ƒçš„æ“ä½œå’Œè§‚å¯Ÿç»“æžœï¼Œè¿™äº›äº‹ä»¶å¯èƒ½åŒ…æ‹¬ï¼š\n<ul>\n<li>ç³»ç»ŸçŠ¶æ€å˜åŒ–</li>\n<li>çŽ¯å¢ƒåˆå§‹åŒ–å®Œæˆé€šçŸ¥</li>\n<li>è¿è¡Œæ—¶çŠ¶æ€æ›´æ–°</li>\n<li>ç³»ç»Ÿçº§çš„è§‚å¯Ÿç»“æžœ</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-python\">class EventSource(str, Enum):\n    AGENT = 'agent'\n    USER = 'user'\n    ENVIRONMENT = 'environment'\n</code></pre>\n<h3 id=\"22-action\">2.2 Action</h3>\n<h4 id=\"221-ç±»åž‹\">2.2.1 ç±»åž‹</h4>\n<p>æ€»å…±æœ‰ 13 ç§ä¸åŒçš„ Action ç±»åž‹ã€‚è¿™äº› Action æ¶µç›–äº†ä»£ç†æ‰§è¡Œçš„å„ç§æ“ä½œï¼ŒåŒ…æ‹¬æ–‡ä»¶æ“ä½œã€å‘½ä»¤æ‰§è¡Œã€æ¶ˆæ¯ä¼ é€’ã€çŠ¶æ€ç®¡ç†ã€ä»£ç†å§”æ‰˜ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚</p>\n<ul>\n<li>\n<p>åŸºç¡€ Action ç±»åž‹ï¼š</p>\n<ul>\n<li>Action â€“ æŠ½è±¡åŸºç±»</li>\n</ul>\n</li>\n<li>\n<p>å…·ä½“ Action å®žçŽ°ï¼š</p>\n<ul>\n<li>AgentDelegateAction â€“ å§”æ‰˜ä»£ç†æ‰§è¡Œä»»åŠ¡</li>\n<li>AgentThinkActionï¼šå…è®¸ Agent æ·»åŠ çº¯æ–‡æœ¬åˆ°åŽ†å²è®°å½•ä¸­çš„æ— æ“ä½œã€‚</li>\n<li>AgentFinishAction â€“ ä»£ç†å®Œæˆä»»åŠ¡ï¼Œåœæ­¢æŽ§åˆ¶å¾ªçŽ¯ï¼Œå…è®¸ç”¨æˆ·è¾“å…¥æ–°ä»»åŠ¡ã€‚</li>\n<li>AgentRejectAction â€“ ä»£ç†æ‹’ç»ä»»åŠ¡</li>\n<li>AgentRecallActionï¼šæœç´¢è®°å¿†ï¼ˆä¾‹å¦‚å‘é‡æ•°æ®åº“ï¼‰ã€‚</li>\n<li>BrowseInteractiveAction â€“ äº¤äº’å¼æµè§ˆ</li>\n<li>ChangeAgentStateAction â€“ æ›´æ”¹ä»£ç†çŠ¶æ€</li>\n<li>CmdRunAction â€“ åœ¨æ²™ç›’ç»ˆç«¯ä¸­è¿è¡Œå‘½ä»¤</li>\n<li>CmdKillActionï¼šæ€æ­»åŽå°å‘½ä»¤ã€‚</li>\n<li>FileEditAction â€“ ç¼–è¾‘æ–‡ä»¶</li>\n<li>FileReadAction â€“ è¯»å–æ–‡ä»¶</li>\n<li>IPythonRunCellAction â€“ äº¤äº’å¼æ‰§è¡ŒPythonä»£ç å—ï¼ˆåœ¨Jupyterç¬”è®°æœ¬ä¸­ï¼‰å¹¶æŽ¥æ”¶<code>CmdOutputObservation</code>ã€‚</li>\n<li>MessageAction â€“ æ¶ˆæ¯æ“ä½œï¼Œè¡¨ç¤ºæ¥è‡ªä»£ç†æˆ–ç”¨æˆ·çš„æ¶ˆæ¯</li>\n<li>AddTaskActionï¼šå‘è®¡åˆ’ä¸­æ·»åŠ å­ä»»åŠ¡ã€‚</li>\n<li>ModifyTaskActionï¼šæ›´æ”¹å­ä»»åŠ¡çš„çŠ¶æ€ã€‚</li>\n<li>NullAction â€“ ç©ºæ“ä½œ</li>\n<li>SystemMessageAction â€“ ç³»ç»Ÿæ¶ˆæ¯æ“ä½œ</li>\n</ul>\n</li>\n<li>\n<p>ç‰¹æ®Š Agent ç›¸å…³ Actionï¼š</p>\n<ul>\n<li>CondensationAction â€“ åŽ†å²åŽ‹ç¼©æ“ä½œ</li>\n<li>CondensationRequestAction â€“ è¯·æ±‚åŽ†å²åŽ‹ç¼©æ“ä½œ</li>\n<li>RecallAction â€“ å›žå¿†æ“ä½œ</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"222-æµç¨‹\">2.2.2 æµç¨‹</h4>\n<p>åœ¨ OpenHands çš„æž¶æž„ä¸­ï¼Œæ€»ä½“çš„äº‹ä»¶æµå¦‚ä¸‹ï¼šAgent -&gt; Action -&gt; Runtime-&gt; Observation -&gt; Agent</p>\n<ul>\n<li>Agentç”ŸæˆActionäº‹ä»¶å¹¶å‘é€åˆ°çŽ¯å¢ƒ</li>\n<li>äº‹ä»¶é€šè¿‡EventStreamä¼ é€’ç»™Runtimeæ‰§è¡Œ</li>\n<li>Runtimeæ‰§è¡Œç›¸åº”æ“ä½œ</li>\n<li>Environment æ‰§è¡Œ Action å¹¶ç”Ÿæˆ Observation ä½œä¸ºå“åº”</li>\n<li>Observation è¢«å‘é€å›ž Agent ä½œä¸ºä¸‹ä¸€æ­¥å†³ç­–çš„è¾“å…¥</li>\n</ul>\n<p>å…·ä½“å¯ä»¥å‚è§anthropicçš„å›¾ä¾‹ã€‚</p>\n<p><img alt=\"openhands-4.1-4\" class=\"lazyload\" /></p>\n<p><a href=\"https://www.anthropic.com/engineering/building-effective-agents\" rel=\"noopener nofollow\" target=\"_blank\">Building effective agents</a></p>\n<p>å³ï¼Œä¸ºäº†è§£å†³çº¿æ€§å·¥ä½œæµçš„è„†å¼±æ€§ï¼Œå¼•å…¥äº†<strong>é—­çŽ¯åé¦ˆ</strong>æœºåˆ¶ã€‚çŽ°åœ¨ï¼Œä»»åŠ¡çš„æ¯ä¸€æ­¥ä¸å†æ˜¯ä¸€æ¬¡æ€§çš„è°ƒç”¨ï¼Œè€Œæ˜¯ä¸€ä¸ª<strong>å¯ä»¥è‡ªæˆ‘çº é”™çš„ Agent</strong>ã€‚è¿™ç§ Agent å¾ªçŽ¯æžå¤§åœ°æå‡äº†ç³»ç»Ÿçš„é²æ£’æ€§å’Œæœ€ç»ˆç»“æžœçš„è´¨é‡ï¼Œå› ä¸ºæ¨¡åž‹æœ‰æœºä¼šä»Žè‡ªå·±çš„é”™è¯¯ä¸­å­¦ä¹ å’Œæ¢å¤ã€‚</p>\n<p>å› æ­¤ï¼Œæˆ‘ä»¬å¼•å…¥äº†Observationã€‚</p>\n<h3 id=\"23-observation\">2.3 Observation</h3>\n<p>Actionæ˜¯Agentå¯¹çŽ¯å¢ƒï¼ˆRuntimeï¼‰å‘å‡ºçš„æŒ‡ä»¤æˆ–è€…æ“ä½œï¼ŒObservationæ˜¯çŽ¯å¢ƒå¯¹è¿™äº›æ“ä½œçš„å“åº”æˆ–è€…åé¦ˆã€‚å®ƒä»£è¡¨äº†çŽ¯å¢ƒå¯¹ Agent æ‰§è¡Œçš„ Action çš„å“åº”ï¼ŒåŒ…å«äº†æ“ä½œç»“æžœã€çŽ¯å¢ƒçŠ¶æ€å˜åŒ–ç­‰ä¿¡æ¯ï¼Œä¾› Agent è¿›è¡Œä¸‹ä¸€æ­¥å†³ç­–ä½¿ç”¨ã€‚è¿™ç§è®¾è®¡ç¬¦åˆå…¸åž‹çš„å¼ºåŒ–å­¦ä¹ å’Œæ™ºèƒ½ä½“ç³»ç»Ÿçš„æ¨¡å¼ï¼Œå…¶ä¸­ Agent é€šè¿‡ä¸ŽçŽ¯å¢ƒäº¤äº’ï¼ˆæ‰§è¡Œ Action å¹¶æŽ¥æ”¶ Observationï¼‰æ¥å®Œæˆä»»åŠ¡ã€‚</p>\n<h4 id=\"231-ç±»åž‹\">2.3.1 ç±»åž‹</h4>\n<ul>\n<li>\n<p>å¤–éƒ¨æ¥æºçš„ Observationsï¼Œå¤§éƒ¨åˆ† Observation å¯¹è±¡æ˜¯ä»Žå¤–éƒ¨çŽ¯å¢ƒæˆ–è¿è¡Œæ—¶ç³»ç»Ÿæž„å»ºå¹¶ä¼ å…¥çš„ï¼Œè¿™äº› Observation ç±»åž‹éƒ½ä»£è¡¨äº†çŽ¯å¢ƒçš„ä¸åŒçŠ¶æ€ï¼Œä¾‹å¦‚ï¼š</p>\n<ul>\n<li>å‘½ä»¤æ‰§è¡Œç»“æžœï¼ˆCmdRunObservationï¼‰</li>\n<li>æ–‡ä»¶è¯»å–ç»“æžœï¼ˆFileReadObservationï¼‰</li>\n<li>IPython æ‰§è¡Œç»“æžœï¼ˆIPythonRunCellObservationï¼‰</li>\n<li>æµè§ˆå™¨äº¤äº’ç»“æžœï¼ˆBrowserOutputObservationï¼‰</li>\n<li>RecallObservation: è®°å¿†æ£€ç´¢ç»“æžœ</li>\n<li>CmdOutputObservationï¼šå‘½ä»¤æ‰§è¡Œçš„è¾“å‡ºã€‚</li>\n<li>BrowserOutputObservationï¼šæµè§ˆ URL åŽçš„è¾“å‡ºã€‚</li>\n<li>FileReadObservationï¼šæ–‡ä»¶è¯»å–æ“ä½œçš„è¾“å‡ºã€‚</li>\n<li>AgentRecallObservationï¼šAgent å›žå¿†æ“ä½œçš„è¾“å‡ºã€‚</li>\n<li>AgentErrorObservationï¼šAgent æ‰§è¡Œæ“ä½œæ—¶å‘ç”Ÿé”™è¯¯çš„è¾“å‡ºã€‚</li>\n</ul>\n<p>è¿™äº›é€šå¸¸ç”±è¿è¡Œæ—¶ç³»ç»Ÿåˆ›å»ºå¹¶é€šè¿‡äº‹ä»¶æµä¼ é€’ç»™æŽ§åˆ¶å™¨ã€‚</p>\n</li>\n<li>\n<p>AgentController å†…éƒ¨æž„å»ºçš„ Observationsã€‚åœ¨ AgentController ç±»ä¸­ï¼Œæœ‰å‡ å¤„ä¼šç›´æŽ¥æž„å»º Observation å¯¹è±¡ï¼š</p>\n<ul>\n<li>NullObservationï¼šè¡¨ç¤ºæ— æ“ä½œæˆ–å¿½ç•¥çš„è§‚å¯Ÿç»“æžœï¼Œç”¨äºŽè¿‡æ»¤ä¸éœ€è¦å¤„ç†çš„äº‹ä»¶ã€‚</li>\n<li>ErrorObservationï¼šè¡¨ç¤ºæ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿçš„é”™è¯¯ï¼ŒåŒ…å«é”™è¯¯ä¿¡æ¯ä¾›ä»£ç†å¤„ç†ã€‚</li>\n<li>AgentStateChangedObservationï¼šè¡¨ç¤ºä»£ç†çŠ¶æ€çš„å˜æ›´ï¼Œå¦‚åŠ è½½ã€è¿è¡Œã€é”™è¯¯ç­‰çŠ¶æ€ã€‚æ¯”å¦‚ï¼Œåœ¨AgentControllerçš„set_agent_state_toå‡½æ•°ä¸­ï¼Œå½“agentçŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶ä¼šåˆ›å»ºä¸€ä¸ªAgentStateChangedObservationäº‹ä»¶ï¼Œå¹¶å°†å…¶æ¥æºè®¾ç½®ä¸º EventSource.ENVIRONMENTã€‚</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"232-æµç¨‹\">2.3.2 æµç¨‹</h4>\n<p>Observation åœ¨ Agent ä¸­çš„å¤„ç†æµç¨‹å¦‚ä¸‹ï¼š</p>\n<pre><code class=\"language-python\">Runtime æ‰§è¡Œ Action --&gt; äº§ç”Ÿ Observation --&gt; EventStream å‘å¸ƒäº‹ä»¶ --&gt; AgentController.on_event æŽ¥æ”¶ --&gt; åˆ¤æ–­æ˜¯å¦éœ€è¦ step --&gt; AgentController._step å¤„ç† --&gt; è°ƒç”¨ Agent.step --&gt; Agent åŸºäºŽåŽ†å²äº‹ä»¶ï¼ˆåŒ…æ‹¬ Observationï¼‰å†³ç­–\n</code></pre>\n<p>å…·ä½“æµç¨‹å¦‚ä¸‹ï¼š</p>\n<ul>\n<li>Runtimeæ‰§è¡Œå®Œactionä¹‹åŽï¼Œç”Ÿæˆobservationäº‹ä»¶ã€‚</li>\n<li>äº‹ä»¶é€šè¿‡EventStream.add_event() ä¼ å›žAgentï¼Œè¿™äº› Observations é€šè¿‡äº‹ä»¶æµä¼ é€’ï¼Œç”¨äºŽæ›´æ–°ä»£ç†çš„çŠ¶æ€å’ŒåŽ†å²è®°å½•ã€‚</li>\n<li>AgentController è®¢é˜… EventStreamï¼Œåœ¨ on_event() æ–¹æ³•ä¸­å¤„ç†è¿™äº›äº‹ä»¶ã€‚</li>\n<li>AgentåŸºäºŽobservationå†³å®šä¸‹ä¸€æ­¥åŠ¨ä½œã€‚</li>\n</ul>\n<p>Observation åœ¨ Agent å†³ç­–ä¸­çš„ä½œç”¨å¦‚ä¸‹ï¼š</p>\n<ul>\n<li>Agent çŠ¶æ€æ›´æ–°ï¼šAgentStateChangedObservation ä¼šæ›´æ–° Agent çš„å†…éƒ¨çŠ¶æ€ï¼›é”™è¯¯ Observation ä¼šè§¦å‘é”™è¯¯å¤„ç†æµç¨‹ã€‚</li>\n<li>åŽ†å²è®°å½•ï¼šæ‰€æœ‰ Observations éƒ½è¢«å­˜å‚¨åœ¨ State.history ä¸­ï¼›Agent åœ¨å†³ç­–æ—¶ä¼šå›žé¡¾æ•´ä¸ªåŽ†å²è®°å½•ï¼ŒåŒ…æ‹¬æ‰€æœ‰çš„ Actions å’Œ Observationsã€‚</li>\n<li>å†³ç­–ä¾æ®ï¼šAgentï¼ˆLLMï¼‰é€šè¿‡åˆ†æžåŽ†å²ä¸­çš„ Observations æ¥ç†è§£çŽ¯å¢ƒçŠ¶æ€ï¼›ä¾‹å¦‚ CmdOutputObservation æä¾›äº†å‘½ä»¤æ‰§è¡Œç»“æžœï¼ŒAgent æ®æ­¤å†³å®šä¸‹ä¸€æ­¥è¡ŒåŠ¨ã€‚</li>\n</ul>\n<h4 id=\"233-ç»†èŠ‚\">2.3.3 ç»†èŠ‚</h4>\n<p>ä¸»è¦çš„ Observation æž„å»ºä½ç½®åŒ…æ‹¬ï¼š</p>\n<ul>\n<li>è¿è¡Œæ—¶çŽ¯å¢ƒï¼ˆæ‰§è¡Œå‘½ä»¤ã€æ–‡ä»¶æ“ä½œç­‰ï¼‰</li>\n<li>AgentController._reset () æ–¹æ³•ï¼ˆæž„å»º ErrorObservationï¼‰</li>\n<li>AgentController.set_agent_state_to () æ–¹æ³•ï¼ˆæž„å»º AgentStateChangedObservationï¼‰</li>\n<li>AgentController.end_delegate () æ–¹æ³•ï¼ˆæž„å»º AgentDelegateObservationï¼‰</li>\n</ul>\n<h3 id=\"24-environment\">2.4 Environment</h3>\n<p>é’ˆå¯¹ EventSource.ENVIRONMENTï¼Œæœ¬å°èŠ‚åšç‰¹æ®Šè¯´æ˜Žã€‚</p>\n<p>EventSource.ENVIRONMENT é€šå¸¸è¡¨ç¤ºç”±ç³»ç»ŸçŽ¯å¢ƒæˆ–è€…åŸºç¡€è®¾æ–½ç”Ÿæˆçš„äº‹ä»¶ï¼Œå¯èƒ½åŒ…æ‹¬ï¼š</p>\n<ul>\n<li>ç³»ç»ŸçŠ¶æ€å˜åŒ–ã€‚</li>\n<li>çŽ¯å¢ƒåˆå§‹åŒ–å®Œæˆé€šçŸ¥ã€‚</li>\n<li>è¿è¡Œæ—¶çŠ¶æ€æ›´æ–°ã€‚</li>\n<li>ç³»ç»Ÿçº§çš„è§‚å¯Ÿç»“æžœã€‚</li>\n</ul>\n<p>åœ¨ä»£ç ä¸­ä½¿ç”¨å¦‚ä¸‹ã€‚</p>\n<pre><code class=\"language-python\"># openhands\\cli\\commands.py\ndef handle_exit_command(\n    config: OpenHandsConfig,\n    event_stream: EventStream,\n    usage_metrics: UsageMetrics,\n    sid: str,\n) -&gt; bool:\n    if confirm_exit:\n        event_stream.add_event(\n            ChangeAgentStateAction(AgentState.STOPPED),\n            EventSource.ENVIRONMENT,\n        )\n\n# åœ¨ Runtime ä¸­        \n    def maybe_run_setup_script(self):\n        # setup scripts time out after 10 minutes\n        action = CmdRunAction(\n            f'chmod +x {setup_script} &amp;&amp; source {setup_script}',\n            blocking=True,\n            hidden=True,\n        )\n        # Add the action to the event stream as an ENVIRONMENT event\n        source = EventSource.ENVIRONMENT\n        self.event_stream.add_event(action, source)\n        \n# åœ¨Memoryç±» _on_event æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°çŽ¯å¢ƒè¿”å›žçš„ Observation è¢«é‡æ–°æ ‡è®°ä¸º Agent äº‹ä»¶å‘é€åˆ° UI:python\nasync def _on_event(self, event: Event):   \n    self.event_stream.add_event(workspace_obs, EventSource.ENVIRONMENT)\n    \n# åœ¨ AgentSession ä¸­\n                    self.event_stream.add_event(\n                        ChangeAgentStateAction(AgentState.RUNNING),\n                        EventSource.ENVIRONMENT,\n                    )\n\n# åœ¨ WebSession ä¸­\n        self.agent_session.event_stream.add_event(\n            AgentStateChangedObservation('', AgentState.LOADING),\n            EventSource.ENVIRONMENT,\n        )\n    \n# AgentController ä¸­\n    async def set_agent_state_to(self, new_state: AgentState) -&gt; None:\n        self.event_stream.add_event(\n            AgentStateChangedObservation('', self.state.agent_state, reason),\n            EventSource.ENVIRONMENT,\n        )\n</code></pre>\n<p>è™½ç„¶Runtimeä¹Ÿä¼šäº§ç”Ÿä¸€äº›è§‚å¯Ÿç»“æžœï¼Œä½†å…·ä½“æ˜¯ EventSource.ENVIRONMENT æˆ–è€… EventSource.AGENTï¼Œå–å†³äºŽä¸Šä¸‹æ–‡ã€‚</p>\n<h3 id=\"25-agentthinkaction\">2.5 AgentThinkAction</h3>\n<p>æˆ‘ä»¬æ¥çœ‹çœ‹ AgentThinkActionï¼Œè¯¥Actionå…è®¸ Agent æ·»åŠ çº¯æ–‡æœ¬åˆ°åŽ†å²è®°å½•ä¸­çš„æ— æ“ä½œã€‚</p>\n<pre><code class=\"language-python\">            # ================================================\n            # AgentThinkAction\n            # ================================================\n            elif tool_call.function.name == ThinkTool['function']['name']:\n                action = AgentThinkAction(thought=arguments.get('thought', ''))\n</code></pre>\n<p>ThinkTool æ˜¯å¯¹Anthropic  Think Toolè®¾è®¡ç†å¿µçš„æ¨¡ä»¿æˆ–å†å®žçŽ°ã€‚</p>\n<h4 id=\"anthropic--think-tool\">Anthropic  Think Tool</h4>\n<p>Anthropic Think Toolåœ¨æ‰§è¡Œå¤æ‚ä»»åŠ¡æ—¶ä¸ºå…¶åˆ›å»ºä¸“é—¨ç”¨äºŽç»“æž„åŒ–æ€è€ƒçš„ç©ºé—´ã€‚Think Toolå‘ç”Ÿåœ¨AIå¼€å§‹å“åº”ä¹‹åŽï¼Œåƒæ˜¯åœ¨å·¥ä½œè¿‡ç¨‹ä¸­ä¸»åŠ¨åœä¸‹æ¥æ•´ç†æ€è·¯ã€‚é€šè¿‡â€œthinkâ€å·¥å…·ï¼ŒAnthropic  èµ‹äºˆ Claude åœ¨å¾—å‡ºæœ€ç»ˆç­”æ¡ˆçš„è¿‡ç¨‹ä¸­æ’å…¥ä¸€ä¸ªé¢å¤–æ€è€ƒæ­¥éª¤çš„èƒ½åŠ›â€”â€”è¯¥æ­¥éª¤æ‹¥æœ‰è‡ªå·±ä¸“å±žçš„æ€è€ƒç©ºé—´ï¼Œç”¨ä»¥åˆ¤æ–­å½“å‰æ˜¯å¦å·²æŽŒæ¡ç»§ç»­æŽ¨è¿›æ‰€éœ€çš„å…¨éƒ¨ä¿¡æ¯ã€‚è¿™ä¸€æœºåˆ¶åœ¨æ‰§è¡Œé•¿é“¾æ¡çš„å·¥å…·è°ƒç”¨æˆ–ä¸Žç”¨æˆ·è¿›è¡Œå¤šè½®å¤æ‚å¯¹è¯æ—¶å°¤ä¸ºæœ‰ç”¨ã€‚</p>\n<p>å°½ç®¡å¬èµ·æ¥ä¸Žå»¶ä¼¸æ€è€ƒï¼ˆ<a href=\"https://www.anthropic.com/research/visible-extended-thinking\" rel=\"noopener nofollow\" target=\"_blank\">extended thinking</a>ï¼‰ç±»ä¼¼ï¼Œä½†äºŒè€…æ¦‚å¿µä¸åŒï¼šå»¶ä¼¸æ€è€ƒå‘ç”Ÿåœ¨ Claude å¼€å§‹ç”Ÿæˆå›žå¤<strong>ä¹‹å‰</strong>ï¼Œè®©æ¨¡åž‹æ·±åº¦æ€è€ƒå¹¶è¿­ä»£æ–¹æ¡ˆï¼›è€Œâ€œæ€è€ƒâ€å·¥å…·ç”¨äºŽ Claude<strong>å·²å¼€å§‹ç”Ÿæˆå›žå¤åŽ</strong>ï¼Œåœ¨é‡åˆ°é•¿é“¾æ¡å·¥å…·è°ƒç”¨æˆ–é•¿å¯¹è¯æ—¶ï¼Œä¸»åŠ¨æš‚åœå¹¶æ€è€ƒæ˜¯å¦å·²æŽŒæ¡è¶³å¤Ÿä¿¡æ¯ã€‚å®ƒå°¤å…¶é€‚ç”¨äºŽæ¨¡åž‹æ— æ³•ä»…å‡­ç”¨æˆ·æŸ¥è¯¢èŽ·å¾—å…¨éƒ¨ä¿¡æ¯ï¼Œè€Œéœ€å¤„ç†å¤–éƒ¨ä¿¡æ¯ï¼ˆå¦‚å·¥å…·è¿”å›žç»“æžœï¼‰çš„åœºæ™¯ã€‚</p>\n<p>ç›¸æ¯”å»¶ä¼¸æ€è€ƒï¼Œâ€œæ€è€ƒâ€å·¥å…·æ‰€è¿›è¡Œçš„æŽ¨ç†èŒƒå›´æ›´çª„ï¼Œæ›´èšç„¦äºŽæ–°å‘çŽ°çš„ä¿¡æ¯ã€‚</p>\n<p>Anthropic  æŽ¨èï¼š</p>\n<ul>\n<li>å¯¹äºŽéžé¡ºåºå·¥å…·è°ƒç”¨æˆ–ç®€å•æŒ‡ä»¤éµå¾ªï¼Œä¼˜å…ˆä½¿ç”¨å»¶ä¼¸æ€è€ƒï¼›</li>\n<li>å¯¹äºŽå¤æ‚å·¥å…·é“¾ã€éœ€ä»”ç»†åˆ†æžå·¥å…·è¾“å‡ºã€ç­–ç•¥å¯†é›†åž‹çŽ¯å¢ƒæˆ–ä»£ä»·é«˜æ˜‚çš„åºåˆ—å†³ç­–ï¼Œä½¿ç”¨â€œæ€è€ƒâ€å·¥å…·ã€‚</li>\n</ul>\n<h5 id=\"ä½•æ—¶ä½¿ç”¨æ€è€ƒå·¥å…·\">ä½•æ—¶ä½¿ç”¨â€œæ€è€ƒâ€å·¥å…·</h5>\n<p><strong>é€‚ç”¨åœºæ™¯</strong>ï¼š</p>\n<ul>\n<li>éœ€æ·±åº¦åˆ†æžå‰åºå·¥å…·è¾“å‡ºï¼Œå¯èƒ½å›žæº¯æ–¹æ¡ˆï¼›</li>\n<li>ç­–ç•¥å¯†é›†åž‹çŽ¯å¢ƒï¼Œéœ€éªŒè¯åˆè§„æ€§ï¼›</li>\n<li>åºåˆ—å†³ç­–ï¼Œæ¯æ­¥ä¾èµ–å‰åºç»“æžœä¸”é”™è¯¯ä»£ä»·é«˜ã€‚</li>\n</ul>\n<p><strong>ä¸é€‚ç”¨åœºæ™¯</strong>ï¼š</p>\n<ul>\n<li>å•æ¬¡æˆ–å¹¶è¡Œå·¥å…·è°ƒç”¨å³å¯å®Œæˆä»»åŠ¡ï¼›</li>\n<li>çº¦æŸç®€å•ï¼Œé»˜è®¤è¡Œä¸ºå·²è¶³å¤Ÿã€‚</li>\n</ul>\n<h5 id=\"æœ€ä½³å®žè·µ\">æœ€ä½³å®žè·µ</h5>\n<ol>\n<li><strong>é¢†åŸŸç¤ºä¾‹é©±åŠ¨çš„æç¤º</strong><br />\nç»™å‡ºä½•æ—¶ã€å¦‚ä½•è°ƒç”¨æ€è€ƒå·¥å…·ï¼Œå¹¶æä¾›è´´åˆä¸šåŠ¡çš„æŽ¨ç†ç¤ºä¾‹ï¼ˆè§åŽŸæ–‡èˆªç©ºåŸŸæç¤ºï¼‰ã€‚</li>\n<li><strong>å°†å¤æ‚æŒ‡ä»¤æ”¾å…¥ç³»ç»Ÿæç¤º</strong><br />\né•¿ä¸”å¤æ‚çš„æ€è€ƒæŒ‡å—æ”¾åœ¨ç³»ç»Ÿæç¤ºè€Œéžå·¥å…·æè¿°ä¸­ï¼Œæ•ˆæžœæ›´ä½³ã€‚</li>\n<li><strong>æŒç»­ç›‘æŽ§ä¸Žè¿­ä»£</strong><br />\nè§‚å¯Ÿ Claude å®žé™…è°ƒç”¨æ¨¡å¼ï¼Œé’ˆå¯¹æ€§è°ƒæ•´æç¤ºï¼Œä»¥å¼ºåŒ–æœ‰æ•ˆæ€è€ƒè·¯å¾„ã€‚</li>\n</ol>\n<h4 id=\"ä»£ç \">ä»£ç </h4>\n<p>ThinkTool å¯¹åº”çš„ä»£ç å¦‚ä¸‹ã€‚è®©æ¨¡åž‹åœ¨â€œå†…éƒ¨ç‹¬ç™½â€é˜¶æ®µæŠŠæ€è€ƒè¿‡ç¨‹å†™å…¥æ—¥å¿—ï¼Œä¸è§¦å‘å¤–éƒ¨è°ƒç”¨ã€‚</p>\n<pre><code class=\"language-python\">_THINK_DESCRIPTION = \"\"\"Use the tool to think about something. It will not obtain new information or make any changes to the repository, but just log the thought. Use it when complex reasoning or brainstorming is needed.\n\nCommon use cases:\n1. When exploring a repository and discovering the source of a bug, call this tool to brainstorm several unique ways of fixing the bug, and assess which change(s) are likely to be simplest and most effective.\n2. After receiving test results, use this tool to brainstorm ways to fix failing tests.\n3. When planning a complex refactoring, use this tool to outline different approaches and their tradeoffs.\n4. When designing a new feature, use this tool to think through architecture decisions and implementation details.\n5. When debugging a complex issue, use this tool to organize your thoughts and hypotheses.\n\nThe tool simply logs your thought process for better transparency and does not execute any code or make changes.\"\"\"\n\nThinkTool = ChatCompletionToolParam(\n    type='function',\n    function=ChatCompletionToolParamFunctionChunk(\n        name='think',\n        description=_THINK_DESCRIPTION,\n        parameters={\n            'type': 'object',\n            'properties': {\n                'thought': {'type': 'string', 'description': 'The thought to log.'},\n            },\n            'required': ['thought'],\n        },\n    ),\n)\n\nclass ThinkExecutor(ToolExecutor):\n    def __call__(\n        self,\n        _: ThinkAction,\n        conversation: \"BaseConversation | None\" = None,  # noqa: ARG002\n    ) -&gt; ThinkObservation:\n        return ThinkObservation.from_text(text=\"Your thought has been logged.\")\n\n\nclass ThinkTool(ToolDefinition[ThinkAction, ThinkObservation]):\n    \"\"\"Tool for logging thoughts without making changes.\"\"\"\n\n    @classmethod\n    def create(\n        cls,\n        conv_state: \"ConversationState | None\" = None,  # noqa: ARG003\n        **params,\n    ) -&gt; Sequence[Self]:\n        \"\"\"Create ThinkTool instance.\n\n        Args:\n            conv_state: Optional conversation state (not used by ThinkTool).\n            **params: Additional parameters (none supported).\n\n        Returns:\n            A sequence containing a single ThinkTool instance.\n\n        Raises:\n            ValueError: If any parameters are provided.\n        \"\"\"\n        if params:\n            raise ValueError(\"ThinkTool doesn't accept parameters\")\n        return [\n            cls(\n                description=THINK_DESCRIPTION,\n                action_type=ThinkAction,\n                observation_type=ThinkObservation,\n                executor=ThinkExecutor(),\n                annotations=ToolAnnotations(\n                    readOnlyHint=True,\n                    destructiveHint=False,\n                    idempotentHint=True,\n                    openWorldHint=False,\n                ),\n            )\n        ]\n</code></pre>\n<h2 id=\"0xff-å‚è€ƒ\">0xFF å‚è€ƒ</h2>\n<p><a href=\"https://docs.all-hands.dev/openhands/usage/architecture/backend\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.all-hands.dev/openhands/usage/architecture/backend</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1936485868761257658\" rel=\"noopener nofollow\" target=\"_blank\">å½“AI Agentä»Žâ€œçŽ©å…·â€èµ°å‘â€œå·¥å…·â€ï¼Œæˆ‘ä»¬è¯¥å…³æ³¨ä»€ä¹ˆï¼ŸOpenhandsæž¶æž„è§£æžã€ç¬¬äºŒç¯‡ï¼šAgent ç›¸å…³æ ¸å¿ƒæ¦‚å¿µã€‘</a>  <a href=\"https://www.zhihu.com/people/dreamrenderx\" rel=\"noopener nofollow\" target=\"_blank\">å…‹é‡Œ</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1936175201323825087\" rel=\"noopener nofollow\" target=\"_blank\">å½“AI Agentä»Žâ€œçŽ©å…·â€èµ°å‘â€œå·¥å…·â€ï¼Œæˆ‘ä»¬è¯¥å…³æ³¨ä»€ä¹ˆï¼ŸOpenhandsæž¶æž„è§£æžã€ç¬¬ä¸€ç¯‡ï¼šç³»åˆ—å¯¼è¯»ã€‘</a> <a href=\"https://www.zhihu.com/people/dreamrenderx\" rel=\"noopener nofollow\" target=\"_blank\">å…‹é‡Œ</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1940436682949244630\" rel=\"noopener nofollow\" target=\"_blank\">Coding Agentä¹‹Openhandsè§£æž(å«ä»£ç )</a>  <a href=\"https://www.zhihu.com/people/wu-long-ming-cha-56\" rel=\"noopener nofollow\" target=\"_blank\">Arrow</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1940824548485347192\" rel=\"noopener nofollow\" target=\"_blank\">OpenHands æºç è§£è¯»</a>  <a href=\"https://www.zhihu.com/people/xiao-hui-66-72\" rel=\"noopener nofollow\" target=\"_blank\">ä¸€åŠ›è¾‰</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1949931198932586886\" rel=\"noopener nofollow\" target=\"_blank\">Anthropic å®˜æ–¹æ•™ç¨‹ï¼šä¸º Agent è®¾è®¡é«˜æ•ˆå·¥å…·çš„æœ€ä½³å®žè·µ</a></p>\n<p><a href=\"https://www.anthropic.com/engineering/claude-think-tool\" rel=\"noopener nofollow\" target=\"_blank\">The \"think\" tool: Enabling Claude to stop and think in complex tool use situations</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 21:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rossiXYZ\">ç½—è¥¿çš„æ€è€ƒ</a>&nbsp;\né˜…è¯»(<span id=\"post_view_count\">0</span>)&nbsp;\nè¯„è®º(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">æ”¶è—</a>&nbsp;\n<a href=\"\">ä¸¾æŠ¥</a>\n</div>"
    },
    {
      "title": "用 Hashids 优雅解决 C 端自增 ID 暴露问题",
      "link": "https://www.cnblogs.com/hackyle/p/19576480",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hackyle/p/19576480\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 21:08\">\n    <span>用 Hashids 优雅解决 C 端自增 ID 暴露问题</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>&nbsp; &nbsp;在 C 端系统中，直接对外暴露数据库自增 ID 往往会带来数据枚举、越权访问等安全隐患。本文将从实际业务场景出发，分析自增 ID 暴露的问题本质，并介绍一种基于 Hashids 的可逆 ID 混淆方案。通过 Hashids，我们可以在不改变数据库结构的前提下，实现对外 ID 的安全化与美观化，兼顾安全性、性能与工程可落地性。</p>\n<p><strong>本文主要内容：</strong></p>\n<ul>\n<li>为什么 C 端系统不能直接暴露自增 ID</li>\n<li>解决方案是什么</li>\n<li>hashids有那些功能</li>\n<li>hashids的代码实现是什么</li>\n</ul>\n<h1>为什么 C 端系统不能直接暴露自增 ID？</h1>\n<p>在后端系统中，我们习惯使用数据库自增 ID，并习惯性的直接返回给C端交互使用，例如：</p>\n<blockquote>\n<p>登录接口在登录成功后返回的用户基础信息<br />{<br />&nbsp; &nbsp; \"userId\": 100,<br />&nbsp; &nbsp; \"username\": \"tom\",<br />&nbsp; &nbsp; \"gender\": 1,<br />&nbsp; &nbsp; \"birthday\": \"2000-10-12 00:00:00\"<br />}</p>\n<p>URL上直接有自增ID：GET /api/user/100</p>\n</blockquote>\n<h2>可被枚举</h2>\n<p>只要有人发现这是<strong>自增 ID，</strong>例如：GET /api/user/100，自然可以被枚举</p>\n<blockquote>\n<p>/api/user/101</p>\n<p>/api/user/102</p>\n<p>/api/user/103</p>\n<p>......</p>\n</blockquote>\n<p>发现了问题没：</p>\n<ul>\n<li>可以轻松遍历接口、爬虫可以批量扫库</li>\n<li>哪怕你有登录态、鉴权，只要 <strong>权限校验有一个点没兜住</strong>，后果极其严重：表数据被批量抓取，隐私数据被遍历、爬光</li>\n<li>这类攻击成本极低，甚至不算“攻击”</li>\n</ul>\n<h2>越权</h2>\n<p>越权的风险被无限放大，你“以为”你做了鉴权，其实不一定，现实情况往往是：</p>\n<ul>\n<li>接口 A 做了用户校验</li>\n<li>接口 B 忘了</li>\n<li>新接口临时加的，校验漏了</li>\n<li>某个内部接口被误暴露</li>\n</ul>\n<p>一旦 ID 是可预测的：</p>\n<ul>\n<li>攻击者只需要找到 一个没校验的入口</li>\n<li>就可以“横向移动”访问所有数据</li>\n</ul>\n<p>例如，URL中存在自增ID，在C端非常典型的场景是用户分享链接给朋友，如果朋友修改URL中的ID，就会跳转到本不属于自己能看到的数据内容。</p>\n<h2>业务信息全暴露</h2>\n<p>通过 ID 就能看穿你的业务信息，例如：</p>\n<ul>\n<li>\n<p>📈 <strong>订单量增长速度</strong></p>\n</li>\n<li>\n<p>👥 <strong>用户规模</strong></p>\n</li>\n<li>\n<p>⏱️ <strong>业务峰值时段</strong></p>\n</li>\n<li>\n<p>🧮 <strong>是否删过数据（ID 是否断层）</strong></p>\n</li>\n</ul>\n<p>这种在C端用户看来没有意义的数据，如果让用户“看不懂”的 ID，反而更专业。</p>\n<ul>\n<li>\n<p>👉 纯数字 ID，看起来像“内部系统”</p>\n</li>\n<li>\n<p>👉混淆 ID，&nbsp;更像“产品设计的一部分”</p>\n</li>\n</ul>\n<h1>解决方案</h1>\n<p>根据以上问题，我们期望有这样一种解决方案可以混淆自增ID</p>\n<ul>\n<li>唯一不可重复：数据量内都必须唯一，不能重复</li>\n<li>支持可逆：ID可以编码为一个看不出规律的串，也可以解码为原ID，不影响数据库ID字段</li>\n<li>高效生成与解析：生成、验证的算法必须保证效率，不能占用太多系统资源</li>\n<li>不可预测与安全：无规则混淆，规律性不能很明显，不能轻易被人猜测到，防止爆刷</li>\n<li>工程成本低：不改表、不迁数据</li>\n</ul>\n<p><strong>常见但不够优雅的解决方案</strong></p>\n<ul>\n<li>UUID\n<ul>\n<li>字符串过长</li>\n<li>URL、二维码不友好</li>\n<li>调试体验差</li>\n</ul>\n</li>\n<li>Snowflake / Base64\n<ul>\n<li>仍然可能暴露时间信息</li>\n<li>前后端实现不统一</li>\n</ul>\n</li>\n<li>AES / RSA 加密 ID\n<ul>\n<li>性能与复杂度成本高</li>\n<li>对“只是隐藏 ID”来说属于过度设计</li>\n</ul>\n</li>\n</ul>\n<p><span style=\"color: rgba(16, 63, 250, 1);\"><strong>这个解决方案就是Hashids。</strong></span></p>\n<p><strong>Hashids的核心功能：把一个或多个整数（int / long）转换成一个不可预测、可逆的短字符串。</strong></p>\n<p><strong>基本属性</strong></p>\n<ul>\n<li>输入是整数（支持long型），输出是字符串（只包含：a-z A-Z 0-9，无其他特殊字符）</li>\n<li>可以自定义编码字符</li>\n<li><strong>可逆</strong>，但不可猜</li>\n<li>支持多个ID编码为一个字符串</li>\n<li>可控制最小长度，不支持“最长长度”限制，实际长度是不固定的，随输入数字大小变化</li>\n</ul>\n<p><strong>典型用途：</strong></p>\n<ul>\n<li>\n<p>数据库自增 ID ，对外展示用字符串，防止 ID 枚举</p>\n</li>\n<li>\n<p>短链接 / 邀请码 / 兑换码</p>\n</li>\n<li>\n<p>URL / 小程序参数更友好</p>\n</li>\n<li>将多个数字（数组）进行混淆，防止参数被篡改</li>\n</ul>\n<p><strong>注意：</strong>它是“混淆（obfuscation）”，不是“加密（encryption）”，不能作为密码学类的场景使用。</p>\n<h1><strong>Hashids内部原理</strong></h1>\n<p>编码（encdoe）流程：</p>\n<blockquote>\n<p>原始数字 --&gt; 打乱字符表（依赖 salt） --&gt; 选取 guard / separator --&gt; 进制转换（base-N） --&gt; 按规则拼接 --&gt; 输出字符串</p>\n</blockquote>\n<p><strong>核心组成元素</strong></p>\n<ul>\n<li>核心组成元素\n<ul>\n<li>字符表（alphabet）：指定那些字符是输出的结果集</li>\n<li>默认字符集：abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890</li>\n<li>你也可以自定义（例如只用大小写 + 数字，排除 0/O/I/l），注意字符不能重复。</li>\n<li>字符集长度 = 进制 base N</li>\n</ul>\n</li>\n<li>salt\n<ul>\n<li>决定字符表如何被洗牌</li>\n<li>同一个 ID，在不同 salt 下，结果完全不同</li>\n<li>不保存 salt，就无法反解</li>\n</ul>\n</li>\n<li>separators &amp; guards\n<ul>\n<li>Hashids 会从 alphabet 中分出两类特殊字符：separators，分隔多个数字。guards，控制最小长度、增强不可预测性。</li>\n<li>这一步主要是为了：避免输出模式过于规则，同时支持编码多个数字的场景（encode(1,2,3)）</li>\n</ul>\n</li>\n</ul>\n<p><strong>怎么实现可逆性的？</strong></p>\n<ul>\n<li>字符表洗牌（consistent shuffle）</li>\n<li>在相同 alphabet + salt下，编码同一ID，结果永远相同</li>\n</ul>\n<details>\n查看代码\n<pre class=\"language-python highlighter-hljs\"><code>for i from alphabet.length-1 downTo 1:\n    j = (salt_char_code + i + previous) % i\n    swap(alphabet[i], alphabet[j])</code></pre>\n</details>\n<p><strong>怎么转换为字符串的？</strong></p>\n<ul>\n<li>假设字符表（alphabet）的长度为62</li>\n<li>数字先模62，得到的余数作为下标从字符表中取得一个字符</li>\n<li>再除62，直到数字小于0时停止</li>\n<li>得到一个字符串</li>\n</ul>\n<p><strong>如何支持同时编码多个数字？</strong></p>\n<p>例如：encode(1, 2, 3)</p>\n<blockquote>\n<p>1 → abc<br />2 → k9<br />3 → z</p>\n</blockquote>\n<p>中间用 separator（也是来自 alphabet，但经过专门筛选）隔开，最终输出：abcXk9Yz</p>\n<p><strong>怎么保证最小长度？</strong></p>\n<ul>\n<li>\n<p>在头尾插入 guard</p>\n</li>\n<li>\n<p>再次洗牌 alphabet</p>\n</li>\n<li>\n<p>重复直到满足长度，这一步是伪随机填充，不影响 decode。</p>\n</li>\n</ul>\n<p><strong>decode的工作流程？</strong></p>\n<ul>\n<li>\n<p>去掉 guards</p>\n</li>\n<li>\n<p>用 separators 切分</p>\n</li>\n<li>\n<p>复原 alphabet 洗牌</p>\n</li>\n<li>\n<p>每一段做 base-N → long</p>\n</li>\n</ul>\n<p><strong>decode失败怎么处理？</strong></p>\n<ul>\n<li>salt 不一致 → decode 失败或得到错误值</li>\n<li>alphabet 不一致 → decode 失败</li>\n</ul>\n<h1>代码实现</h1>\n<p>终于到了激动人心的代码实现环节，撸起袖子，敲键盘。</p>\n<p>在pom中导入依赖</p>\n<pre class=\"language-xml highlighter-hljs\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.hashids&lt;/groupId&gt;\n    &lt;artifactId&gt;hashids&lt;/artifactId&gt;\n    &lt;version&gt;1.0.3&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<h2>简单用法</h2>\n<pre class=\"language-java highlighter-hljs\"><code>import org.hashids.Hashids;\nimport org.springframework.stereotype.Service;\n\nimport java.util.Arrays;\n\n@Service\npublic class HashidsService {\n\n    //Bean单例，不存在线程安全问题\n    private final Hashids hashids = new Hashids();\n\n    public String encode(int code) {\n        return hashids.encode(code);\n    }\n\n    public String encode(long code) {\n        return hashids.encode(code);\n    }\n\n    public long decode(String decoded) {\n        long[] decodes = hashids.decode(decoded);\n        if (decodes.length == 0) {\n            throw new IllegalArgumentException(\"非法ID\");\n        }\n        return decodes[0];\n    }\n\n    public String encodeArr(int[] codes) {\n        long[] codeArr = Arrays.stream(codes).asLongStream().toArray();\n        return hashids.encode(codeArr);\n    }\n\n    public String encodeArr(long[] codes) {\n        return hashids.encode(codes);\n    }\n\n    public long[] decodeArr(String decoded) {\n        long[] decodes = hashids.decode(decoded);\n        if (decodes.length == 0) {\n            throw new IllegalArgumentException(\"非法ID\");\n        }\n        return decodes;\n    }\n\n}</code></pre>\n<h2>加盐</h2>\n<div>\n<p><strong>加盐混淆</strong></p>\n</div>\n<ul>\n<li>防止别人用同样库解你 ID</li>\n<li>salt 一旦上线 绝对不能改</li>\n</ul>\n<pre class=\"language-yaml highlighter-hljs\"><code># application.yml\nhashids:\n  salt: kjsdfiaosudkskldjfa #混淆用的盐\n  min-length: 8 #最小长度</code></pre>\n<details>\n查看代码\n<pre class=\"language-java highlighter-hljs\"><code>package com.ks.demo.uc.hashids;\n\nimport org.hashids.Hashids;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\nimport java.util.Arrays;\n\n/**\n * 加盐混淆\n *\n * salt的作用\n * 防止别人用同样库解你 ID\n * salt 一旦上线 绝对不能改\n */\n@Service\npublic class HashidsSaltService {\n    @Value(\"${hashids.salt}\")\n    private String salt;\n    @Value(\"${hashids.min-length}\")\n    private int minLength;\n\n    //new在@Value注入之前\n    //解决方案：后构造器，在构造器的入参使用@Value，使用@ConfigurationProperties单独注入\n    //private Hashids hashidsSalt = new Hashids(salt);\n\n    private Hashids hashidsSalt = null;\n    private Hashids hashidsMinLen = null;\n\n    @PostConstruct\n    public void init() {\n        hashidsSalt = new Hashids(salt);\n        hashidsMinLen = new Hashids(salt, minLength);\n    }\n\n    public String encode(int code) {\n        return hashidsSalt.encode(code);\n    }\n    public String encode(long code) {\n        return hashidsSalt.encode(code);\n    }\n    public long decode(String decoded) {\n        long[] decodes = hashidsSalt.decode(decoded);\n        if (decodes.length == 0) {\n            throw new IllegalArgumentException(\"非法ID\");\n        }\n        return decodes[0];\n    }\n\n    public String encodeArr(int[] codes) {\n        long[] codeArr = Arrays.stream(codes).asLongStream().toArray();\n        return hashidsSalt.encode(codeArr);\n    }\n    public String encodeArr(long[] codes) {\n        return hashidsSalt.encode(codes);\n    }\n    public long[] decodeArr(String decoded) {\n        long[] decodes = hashidsSalt.decode(decoded);\n        if (decodes.length == 0) {\n            throw new IllegalArgumentException(\"非法ID\");\n        }\n        return decodes;\n    }\n\n    public String encodeMinLen(int code) {\n        return hashidsMinLen.encode(code);\n    }\n    public String encodeMinLen(long code) {\n        return hashidsMinLen.encode(code);\n    }\n    public long decodeMinLen(String decoded) {\n        long[] decodes = hashidsMinLen.decode(decoded);\n        if (decodes.length == 0) {\n            throw new IllegalArgumentException(\"非法ID\");\n        }\n        return decodes[0];\n    }\n\n    public String encodeMinLenArr(int[] codes) {\n        long[] codeArr = Arrays.stream(codes).asLongStream().toArray();\n        return hashidsMinLen.encode(codeArr);\n    }\n    public String encodeMinLenArr(long[] codes) {\n        return hashidsMinLen.encode(codes);\n    }\n    public long[] decodeMinLenArr(String decoded) {\n        long[] decodes = hashidsMinLen.decode(decoded);\n        if (decodes.length == 0) {\n            throw new IllegalArgumentException(\"非法ID\");\n        }\n        return decodes;\n    }\n}</code></pre>\n</details>\n<div>\n<h2>自定义参与编码的字符</h2>\n</div>\n<p><strong>字符集规则：</strong></p>\n<ul>\n<li>至少 16 个字符</li>\n<li>不允许重复字符</li>\n</ul>\n<pre class=\"language-yaml highlighter-hljs\"><code># application.yml\nhashids:\n  salt: kjsdfiaosudkskldjfa #混淆用的盐\n  min-length: 8 #最小长度\n  #至少 16 个字符，不允许重复字符\n  #参与编码的字符，可以剔除调0/O/o,1/I/l等字符，增强可读性\n  base-char: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</code></pre>\n<details>\n查看代码\n<pre class=\"language-java highlighter-hljs\"><code>package com.ks.demo.uc.hashids;\n\nimport org.hashids.Hashids;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\nimport java.util.Arrays;\n\n/**\n * 自定义参与编码的字符\n *\n * 字符集规则：\n * 至少 16 个字符\n * 不允许重复字符\n *\n * 使用场景\n * 避免 0/O、l/1 混淆\n * 只允许大写字母\n *\n */\n@Service\npublic class HashidsBaseCharService {\n    @Value(\"${hashids.salt}\")\n    private String salt;\n    @Value(\"${hashids.min-length}\")\n    private int minLength;\n    @Value(\"${hashids.base-char}\")\n    private String baseChar;\n\n    private Hashids hashids = null;\n\n    @PostConstruct\n    public void init() {\n        hashids = new Hashids(salt, minLength, baseChar);\n    }\n\n    public String encode(int code) {\n        return hashids.encode(code);\n    }\n    public String encode(long code) {\n        return hashids.encode(code);\n    }\n    public long decode(String decoded) {\n        long[] decodes = hashids.decode(decoded);\n        if (decodes.length == 0) {\n            throw new IllegalArgumentException(\"非法ID\");\n        }\n        return decodes[0];\n    }\n\n    public String encodeArr(int[] codes) {\n        long[] codeArr = Arrays.stream(codes).asLongStream().toArray();\n        return hashids.encode(codeArr);\n    }\n    public String encodeArr(long[] codes) {\n        return hashids.encode(codes);\n    }\n    public long[] decodeArr(String decoded) {\n        long[] decodes = hashids.decode(decoded);\n        if (decodes.length == 0) {\n            throw new IllegalArgumentException(\"非法ID\");\n        }\n        return decodes;\n    }\n\n}</code></pre>\n</details>\n<h1>结尾</h1>\n<p>在文章最后，尝试对自己提问一下问题，来检验你是否真正了解到了本文的核心内容。</p>\n<ol>\n<li>C 端自增 ID 暴露会有那些问题？</li>\n<li>hashids的核心特性？为什么可以作为混淆自增id的解决方案？</li>\n<li>hashids的功能有那些？</li>\n<li>代码怎么写？</li>\n</ol>\n<p>本文结束。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 21:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hackyle\">ALGO阿狗</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[大模型实战 03预备] 云端炼丹房 2：Kaggle 上手指南",
      "link": "https://www.cnblogs.com/algieba/p/19576331",
      "published": "",
      "description": "<div class=\"postcontent\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"[大模型实战 03预备] 云端炼丹房 2：Kaggle 上手指南\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260204195327324-384345256.png\" />\n        Colab 额度用完了？Kaggle 带着两张 T4 显卡来了！本文详解 Kaggle 账号手机验证、开启 Internet 联网、配置双 T4 GPU 环境，以及如何利用 Kaggle 特有的 Dataset 机制持久化保存 HuggingFace 模型。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"大模型实战-03预备-云端炼丹房-2kaggle-上手指南\">[大模型实战 03预备] 云端炼丹房 2：Kaggle 上手指南</h1>\n<blockquote>\n<p><strong>核心摘要 (TL;DR)</strong></p>\n<ul>\n<li><strong>痛点</strong>：Colab 免费额度耗尽，或者单张 T4 显存（16GB）无法满足更大参数模型的微调需求。</li>\n<li><strong>方案</strong>：利用 <strong>Kaggle</strong> 提供的 <strong>每周 30 小时免费双路 T4 GPU (T4 x2)</strong> 算力。</li>\n<li><strong>技巧</strong>：通过 <strong>手机号验证</strong> 解锁联网权限，利用 <strong>Kaggle Datasets</strong> 实现模型的持久化存储。</li>\n<li><strong>目标</strong>：作为 Colab 的强力替补（甚至上位），搭建备用云端炼丹环境。</li>\n</ul>\n</blockquote>\n<h2 id=\"前言\">前言</h2>\n<p>上一篇中，本来想直接写到Google Colab的大模型推理脚本，让各位友人们感受一下在全参数7B模型的能力，但是折腾了很久，Colab读driver老是失败，当我想直接下载到云端主机而不是driver的时候，GPU的额度已经耗尽。索性今天在Kaggle的这篇博文中来讲，应该之后也主要用Kaggle来进行云端开发，毕竟Colab额度少，还得盯着，长时间不看会断掉连接。</p>\n<p>好，我们来先介绍一下今天的主角，Google 旗下的另一个神器：<a href=\"https://www.kaggle.com/\" rel=\"noopener nofollow\" target=\"_blank\"><strong>Kaggle</strong></a>。Colab如果说其本职就是模型训练，那<strong>Kaggle</strong>本身其实是一个数据科学的竞赛平台，毕竟是数据科学竞赛嘛，那自然得需要算力资源，<strong>Kaggle</strong>为了方便，也发挥了谷歌大善人的优良品质，免费提供了大方的计算资源。跟Colab对比起来，Kaggle的优势就是，更稳定，更方便，资源给的额度更多。</p>\n<h2 id=\"1-kaggle-notebooks-核心概念\">1. Kaggle Notebooks 核心概念</h2>\n<p>Kaggle 的核心编程环境叫 <strong>Kernels (现在统称 Notebooks)</strong>,不用害怕，诶，它就是我们昨儿刚认识的熟人<strong>云端服务器版</strong>的<strong>Jupyter Notebook</strong>,但是和Colab不太相同的是Kaggle的文件结构，它明显得区分了输入区域，输出区域，暂存区域, 这是也我们刚上手容易懵的地方:</p>\n<ul>\n<li><strong>Input (<code>/kaggle/input</code>)</strong>：<strong>只读区域</strong>。这里存放你上传的数据集或挂载的模型。读取速度极快，但无法写入。</li>\n<li><strong>Output (<code>/kaggle/working</code>)</strong>：<strong>可读写区域</strong>。这是你的主工作区，代码运行结果、下载的模型必须存在这里。但注意，重启 Session 后，这里的内容如果不保存为 Dataset 也会消失。</li>\n<li><strong>Temp (<code>/kaggle/temp</code>)</strong>：<strong>临时暂存区</strong>。空间较大（只有当前会话有效），适合下载解压临时的大文件。</li>\n</ul>\n<p><img alt=\"Kaggle notebook 文件系统结构图，展示 input/working/temp 的区别的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/kaggle_input_working_temp.png\" /></p>\n<h2 id=\"2-快速上手注册与解锁\">2. 快速上手：注册与“解锁”</h2>\n<h3 id=\"21-注册与关键验证-必做\">2.1 注册与关键验证 (必做)</h3>\n<p>我们新用户登录创建notebook后会发现，我们没有硬件加速设备可选。<br />\n<img alt=\"新用户的accelerator部分是灰色的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/no_gpu.png\" /><br />\n根本原因就是咱们没有进行手机验证，哈哈哈，可以理解，毕竟本身kaggle就不用绑卡，加上手机验证可能会杜绝掉一大部分计算资源滥用。</p>\n<ol>\n<li>访问 <a href=\"https://www.kaggle.com/\" rel=\"noopener nofollow\" target=\"_blank\">Kaggle 官网</a> 并注册账号。</li>\n<li><strong>关键步骤</strong>：点击右上角头像 -&gt; <strong>Settings</strong>。</li>\n<li>找到 <strong>Phone Verification</strong>（手机验证）。<strong>必须完成这一步</strong>，否则无法开启 GPU 和 Internet（联网）功能。<br />\n<img alt=\"Kaggle 账户设置页面的截图，高亮 Phone Verification 区域\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/phone_verification.png\" /></li>\n</ol>\n<p>认证完毕就可以使用GPU资源了<br />\n<img alt=\"当认证了手机号之后显示accelerator中有可用的GPU资源的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/gpu_access.png\" /><br />\n如果继续做了<strong>Identity verification</strong>之后，可以使用TPU资源，不过我们暂时用不到，目前的GPU资源已经够咱们大玩一场了。</p>\n<h3 id=\"22-创建笔记本\">2.2 创建笔记本</h3>\n<ol>\n<li>点击左侧菜单栏的 <strong>Create</strong> -&gt; <strong>New Notebook</strong>。</li>\n<li>进入编辑器界面，你会发现界面布局比 Colab 更加紧凑且功能分区明确。<br />\n<img alt=\"kaggle的编辑器页面布局的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/the_whole_UI.png\" /></li>\n</ol>\n<h3 id=\"23-界面布局速览\">2.3 界面布局速览</h3>\n<ul>\n<li><strong>工作区</strong>：位于右侧，显示了Input-&gt;我们的挂载资源，上传的数据集和模型等等，Output-&gt;我们输出的结果资源。notebook内容速览,以及下面的session options环境快捷配置等等<br />\n<img alt=\"编辑器右侧的工作区，包含Input区和output区的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/workspace.png\" /><br />\n<img alt=\"编辑器右侧工作区剩余部分，报班session options的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/session_options.png\" /></li>\n<li><strong>快捷操作栏</strong>： 在代码区上方，和Colab差别不大，可以快速运行，插入单元格，复制粘贴等等<br />\n<img alt=\"在编辑器上方的快捷操作栏的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/quick_action.png\" /></li>\n<li><strong>代码区</strong>：和Colab一样, 标准的 Jupyter 单元格。</li>\n</ul>\n<p>注意，</p>\n<ol>\n<li>和Colab不一样的是，Kaggle的文件名没有后缀，不用加ipynb后缀</li>\n<li>咱们的硬件加速（GPU/TPU计算资源）被放到了顶部菜单栏的<strong>Settings</strong>中的<strong>accelerator</strong>中了</li>\n<li>和Colab不同，因为Kaggle是为竞赛服务，很多竞赛是要求模型不联网的，所以我们在训练模型的时候，需要手动开启网络，也在顶部菜单栏的<strong>Settings</strong>中，点击<strong>Turn On Internet</strong>打开即可联网下载模型或者数据集。<br />\n<img alt=\"Kaggle Notebook的Settings下拉菜单，包含硬件加速设备和开启联网选项的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/settings.png\" /></li>\n<li>密钥管理被放到了顶部菜单栏的<strong>Add-ons</strong>下了<br />\n<img alt=\"Kaggle Notebook的Add-on下来菜单，包含密钥管理选项的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/add-on.png\" /></li>\n</ol>\n<h2 id=\"3-环境配置开启双显卡与联网\">3. 环境配置：开启双显卡与联网</h2>\n<p>Kaggle 默认环境是 <strong>CPU</strong> 且 <strong>断网</strong> 的。我们需要手动“解除封印”。</p>\n<h3 id=\"31-开启联网-internet-on\">3.1 开启联网 (Internet On)</h3>\n<p>可以按照刚才说的在顶部菜单栏打开，也可以在右侧边栏的 <strong>Session Options</strong> 中，找到 <strong>Internet</strong> 选项。将开关拨到 <strong>On</strong>。<br />\n<em>注意：如果没有手机验证，此选项为灰色不可用。</em></p>\n<h3 id=\"32-开启-gpu-加速-t4-x2\">3.2 开启 GPU 加速 (T4 x2)</h3>\n<ol>\n<li>\n<p>在右侧边栏找到 <strong>Accelerator</strong>。</p>\n</li>\n<li>\n<p>下拉选择 <strong>GPU T4 x2</strong>。</p>\n<ul>\n<li><strong>GPU T4 x2</strong>：两张显卡，约 30GB 显存，适合大模型推理和微调。</li>\n<li><strong>GPU P100</strong>：单张旧架构卡，虽然速度快但显存仅 16GB，通常不推荐。</li>\n</ul>\n</li>\n<li>\n<p>开启后，顶部会显示 <strong>Session Storage</strong> 和 <strong>GPU Quota</strong>（每周 30 小时额度，通常周六刷新）。<br />\n点击自己的头像，可以看见自己的额度<strong>GPU Quata</strong><br />\n<img alt=\"点击自己的头像，可以看见自己的额度的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/GPU_Quata.png\" /></p>\n</li>\n</ol>\n<h3 id=\"33-验证双卡环境\">3.3 验证双卡环境</h3>\n<p>输入并运行以下代码，确认我们是否真的拥有了两张显卡：</p>\n<pre><code class=\"language-python\">!nvidia-smi\n</code></pre>\n<p>你应当能看到 <strong>两张</strong> Tesla T4 显卡的列表 (GPU 0 和 GPU 1)。<br />\n<img alt=\"nvidia-smi的运行结果，显示两张Tesla T4卡\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/nvidia-smi.png\" /></p>\n<h2 id=\"4-实战下载并运行大模型\">4. 实战：下载并运行大模型</h2>\n<p>在 Kaggle 上使用模型主要有两种“流派”：<strong>代码下载派</strong> 和 <strong>原生挂载派</strong>。</p>\n<h3 id=\"方式一利用-huggingface-cli-下载-工程化推荐\">方式一：利用 HuggingFace CLI 下载 (工程化推荐)</h3>\n<p>这种方式最灵活，适合需要精确控制模型版本的情况。由于 Kaggle 没有 Google Drive，我们将模型下载到 <code>/kaggle/working/</code> 目录。</p>\n<p><strong>步骤 1：安装与配置</strong></p>\n<pre><code class=\"language-python\"># Kaggle 预装库很多，但 transformers 版本可能滞后，建议更新\n!pip install -U transformers huggingface_hub accelerate bitsandbytes\n</code></pre>\n<p>点击顶部菜单 <strong>Add-ons</strong> -&gt; <strong>Secrets</strong>，添加 <code>HF_TOKEN</code>（你的 HuggingFace 访问令牌）。</p>\n<p><strong>步骤 2：下载脚本</strong></p>\n<pre><code class=\"language-python\">import os\nfrom huggingface_hub import login, snapshot_download\nfrom kaggle_secrets import UserSecretsClient\n\n# 1. 登录 (自动读取 Secrets)\nuser_secrets = UserSecretsClient()\nhf_token = user_secrets.get_secret(\"HF_TOKEN\")\nlogin(token=hf_token)\n\n# 2. 定义下载路径 (注意：必须在 /kaggle/working 下)\nmodel_dir = \"/kaggle/working/model_cache\"\nos.makedirs(model_dir, exist_ok=True)\n\n# 3. 下载模型\nmodel_id = \"Qwen/Qwen2.5-7B-Instruct\"\nprint(f\"开始下载 {model_id} ...\")\n\n# Kaggle 建议下载实文件 (local_dir_use_symlinks=False)\nsnapshot_download(\n    repo_id=model_id,\n    local_dir=model_dir,\n    local_dir_use_symlinks=False,\n    token=hf_token\n)\n\nprint(\"下载完成！\")\n</code></pre>\n<p><img alt=\"下载完成的结果截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/download_model.png\" /></p>\n<h3 id=\"方式二add-input-kaggle-原生方式\">方式二：Add Input (Kaggle 原生方式)</h3>\n<p>这是 Kaggle 最强大的功能。你可以直接在网页端搜索现成的模型，像挂载 U 盘一样挂载进来，<strong>不消耗下载流量和时间</strong>。</p>\n<ol>\n<li>点击右侧边栏的 <strong>Add Input</strong>。</li>\n<li>选择 <strong>Models</strong> 标签页。</li>\n<li>搜索 <code>Qwen2.5</code>。</li>\n<li>点击 <strong>+</strong> 号添加。<br />\n<img alt=\"Kaggle Add Input 搜索模型的弹窗截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/qwen_downloading.png\" /></li>\n<li>选择FRAMEWORK选择<strong>Transformers</strong>架构, VARIATION选择<strong>7b-instruct</strong>, 之后的博文会跟各位友人解释这些参数的差别<br />\n<img alt=\"下载Qwen2.5模型需要填写的架构和参数示意截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/qwen2_5_params.png\" /></li>\n<li>模型会直接出现在 <code>/kaggle/input/</code> 目录下（只读），路径通常长得像 <code>/kaggle/input/qwen2.5/transformers/7b-instruct/1</code>。</li>\n</ol>\n<h2 id=\"5-加载模型与双卡推理\">5. 加载模型与双卡推理</h2>\n<p>拥有双卡 T4 后，加载模型时有一个关键参数：<code>device_map=\"auto\"</code>。它会自动将模型切分到两张显卡上，从而让我们能运行更大的模型。</p>\n<pre><code class=\"language-python\">import torch\nfrom transformers import AutoTokenizer, AutoModelForCausalLM\n\n# 路径根据你的下载方式调整\n# 方式一路径: \"/kaggle/working/model_cache\"\n# 方式二路径: \"/kaggle/input/qwen2.5/transformers/7b-instruct/1/\" (具体可以运行默认创建的第一个单元格，查看input目录结构,到能看见config.json的目录即可)\nmodel_path = \"/kaggle/working/model_cache\"\n\nprint(\"正在加载模型 (双卡模式)...\")\n\ntokenizer = AutoTokenizer.from_pretrained(model_path, trust_remote_code=True)\n\n# 关键：device_map=\"auto\" 会自动利用两张 T4\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_path,\n    device_map=\"auto\",\n    torch_dtype=torch.float16,\n    trust_remote_code=True\n)\n\nprint(f\"模型加载成功！显存分布: {model.hf_device_map}\")\n\n# 测试对话\nprompt = \"你好，请用一句话形容 Kaggle 的双 T4 显卡有多香？\"\nmessages = [{\"role\": \"user\", \"content\": prompt}]\ntext = tokenizer.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\ninputs = tokenizer([text], return_tensors=\"pt\").to(model.device)\n\nwith torch.no_grad():\n    generated_ids = model.generate(**inputs, max_new_tokens=200)\n\nresponse = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]\nprint(f\"Qwen: {response.split('assistant')[-1].strip()}\")\n</code></pre>\n<h2 id=\"6-进阶如何持久化保存save-version\">6. 进阶：如何持久化保存？(Save Version)</h2>\n<p>Kaggle 没有 Google Drive，那怎么保存下载好的模型或训练结果呢？</p>\n<p><strong>答案：把 Output 变成 Dataset。</strong></p>\n<ol>\n<li>当你的代码运行完毕，模型保存在 <code>/kaggle/working</code> 后。</li>\n<li>点击右上角的 <strong>Save Version</strong> 按钮。</li>\n<li>选择 <strong>Save &amp; Run All</strong> (重新跑一遍),必须等到下方弹出的保存任务完成。<br />\n<img alt=\"保存任务完成的截图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/job_running_done.png\" /></li>\n<li>保存成功后，你可以去主页的<strong>Your Work</strong>点击刚才的Notebook,进入<strong>Output</strong> 标签页里，点击最右边的Output的三个点，然后点击 <strong>New Dataset</strong>。<br />\n<img alt=\"在Output标签页的New Dataset示意图\" src=\"https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-2-online-environment-kaggle/new_data.png\" /></li>\n<li>这样，我们刚才的模型就变成了一个可以在其他 Notebook 里直接 <strong>Add Input</strong> 的数据集了！</li>\n</ol>\n<p><strong>PS:除开自训练的特殊模型和一些在Input找不到的模型，最好都直接使用Input导入更为快捷</strong></p>\n<h2 id=\"7-常见问题-qa\">7. 常见问题 (Q&amp;A)</h2>\n<p><strong>Q: Colab 和 Kaggle 我该选谁？</strong><br />\n<strong>A:</strong></p>\n<ul>\n<li><strong>Colab</strong>: 适合快速实验、挂载 Google Drive 方便。但 T4 只有一张，且最近封号较严。</li>\n<li><strong>Kaggle</strong>: 适合需要大显存（T4 x2）的任务。环境更稳定，且有 30 小时/周的明确额度，不用担心用到一半被踢下线。</li>\n</ul>\n<p><strong>Q: 为什么我的代码报错 <code>Internet connection is closed</code>？</strong><br />\n<strong>A:</strong> 这是一个经典错误。请检查右侧边栏的 <strong>Internet</strong> 开关是否为 On。如果开关是灰色的，请检查是否完成了账号的 <strong>手机号验证</strong>。</p>\n<p><strong>Q: <code>/kaggle/working</code> 里的文件重启后还有吗？</strong><br />\n<strong>A:</strong> 没有了。Kaggle 的 Session 也是临时的。如果需要持久化，请务必使用 <strong>Save Version</strong> 功能将其保存为 Dataset，或者在代码最后加一段上传到 HuggingFace Hub 的代码。</p>\n<hr />\n<p><strong>本文作者：</strong> Algieba<br />\n<strong>本文链接：</strong> <a href=\"https://blog.algieba12.cn/llm02-2-online-environment-kaggle/\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.algieba12.cn/llm02-2-online-environment-kaggle/</a><br />\n<strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>\n<pre><code>\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"itemdesc\">\n\t\t\t发表于 \n<span id=\"post-date\">2026-02-04 19:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/algieba\">阿尔的代码屋</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</div>"
    },
    {
      "title": "V8引擎 精品漫游指南--Ignition篇(上) 指令 栈帧 槽位 调用约定 内存布局 基础内容",
      "link": "https://www.cnblogs.com/f20171110/p/19576264",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/f20171110/p/19576264\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 19:19\">\n    <span>V8引擎 精品漫游指南--Ignition篇(上) 指令 栈帧 槽位 调用约定 内存布局 基础内容</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        这是第二篇的上半部分，我们主要学习ignition V8的解释器的一些基础和前置知识。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"二-ignition解释器上\">二. Ignition解释器(上)</h1>\n<p>这是第二篇的上半部分，我们主要学习ignition V8的解释器的一些基础和前置知识。</p>\n<p>这部分内容，主要是以了解为主，所以在学习的时候，除了第一篇中说的 有些细节做了省略  有些边界情况做了简化表述以外，也不需要过多的深入。 读完了就好。 目的就是对于ignition解释器的一个祛魅。</p>\n<p>当然，感兴趣的朋友也可以认真阅读，本文内容依旧保持一定的深度，依旧是力求高准确性，符合规范，贴合实现。 但需注意的是，为了文章的可读性，有可能<strong>在前面</strong>仅做简化的通俗的描述，<strong>在后面</strong>做了详细的讲解描述，所以，可能的情况下，请尽量阅读全文。</p>\n<p>通过上一篇的解析，我们手里已经拿到了一份完整的AST抽象语法树。 但是对于cpu来说，它只认指令。</p>\n<p>在早期版本的 V8 中，JavaScript 代码在解析完成后，会直接被编译成本机机器码执行。这种方式运行得很快，但机器码体积通常比较大，也不够灵活。</p>\n<p>在后来，直到现在，V8不再直接生成庞大复杂的机器码，而是生成了一种非常紧凑 小巧的中间代码，就是 字节码 bytecode。</p>\n<p>但是cpu也不认识字节码，V8使用 ignition 模拟了一个可以运行字节码的环境，相当于一个极其轻量的虚拟机。</p>\n<h2 id=\"1--ignition是什么\">1 . ignition是什么</h2>\n<p>Ignition 是 V8 引擎里的<strong>字节码解释器</strong>，它把 JavaScript 的 AST 编成紧凑的字节码，然后在虚拟机里解释执行，同时收集各种信息，供优化器生成更快的机器码。</p>\n<p>ignition的工作  最主要是下面三个：</p>\n<p><strong>翻译</strong>：把 AST 翻译成字节码。</p>\n<p><strong>执行</strong>：在一个虚拟的寄存器机里执行这些字节码。</p>\n<p><strong>收集情报</strong>：在执行过程中，偷偷记录类型信息，为后续的优化做准备。</p>\n<p>Ignition 在软件层面模拟了一套  <strong>类 CPU</strong> 的工作模式：<br />\n它不是只用栈，也不是纯寄存器机，而是采用“<strong>虚拟寄存器 + 累加器（Accumulator）</strong>”的模式。</p>\n<p>这里的寄存器并不是 CPU 里的硬件寄存器，而是函数栈帧里的一些槽位（slots），只是把它抽象成寄存器来使用，看起来更像 CPU 工作方式，但成本非常低。</p>\n<p>Ignition 还设计了一个<strong>解释器独占的累加器 acc</strong>。大多数运算的中间结果都会临时存放在 acc 里，这样指令只需要携带一个参数，就不用全部写出所有的目的寄存器，字节码就会变得非常短小。</p>\n<p>当一个函数开始执行时，Ignition 会在内存的 栈 (Stack) 上划出一块地盘， 跑起来的时候，本质上就是在那块栈内存上，不停地把数据从一个位置搬到另一个位置，计算，然后再搬回另一个位置，就是这样搬来搬去。ignition操作的并不是真正的cpu内的寄存器，它操作的是内存位置/槽位。</p>\n<h2 id=\"2--几个简单的指令\">2 . 几个简单的指令</h2>\n<p>ignition就像一个勤劳干活的老师傅，他有一个随身腰包，他不管干什么活，不管需要用什么工具，都是优先用随身腰包里的东西， 干完活得到的结果，也顺手塞回自己的随身腰包里。</p>\n<p><strong>老师傅有个随身腰包， 不管干什么，都优先使用随身腰包。</strong></p>\n<p><strong>摆放各种材料的原料架，一格一格的， r0 ，r1，r2.。。。编着号，上面摆满了原材料。</strong></p>\n<p>好了，这就是ignition的架构。就是这么简单。</p>\n<p>这个随身腰包，就是老师傅最重要的东西了。师傅偷懒全靠它了。</p>\n<p>假如没有这个随身包，想象一下，老板下达指令非常啰嗦麻烦：</p>\n<p>把 r1原料架 的东西 和 r2原料架 的东西拿下来，拼装好，然后再放回 r3原料架 去</p>\n<p>(类似于指令：ADD r1, r2, r3)</p>\n<p>​     而老师傅有了随身包，就简单了，老板只需要喊一声：</p>\n<p>“去把 r2 原料架的东西拼进来！”</p>\n<p>(指令：Add r2)</p>\n<p>老板完全不需要废话“跟谁拼”（默认跟包里的东西拼），也不需要废话“拼完放哪”（默认拼完还放在包里）。</p>\n<p>这就是 Ignition 的核心节省秘籍。通过强行规定“随身包优先”，每一条指令都能省掉好几个参数的位置。成千上万行代码跑下来，省下的内存就是一个天文数字。</p>\n<p>这个老师傅的<strong>随身包 就是累加器</strong>，原料架 就是内存位置/槽位</p>\n<ul>\n<li>\n<p><code>Lda</code> (Load Accumulator) ---Lda 是个前缀，实际使用时，后面可跟很多合法的数据来源，比如 LdaSmi<code>、</code>LdaConstant<code>、</code>LdaUndefined、Ldar 等等。。。</p>\n<p>这是使用最高频的指令，因为所有的活 都得在随身包里干，所以第一步，基本上都是把东西装进包里。</p>\n<ul>\n<li><strong>指令</strong>：<code>Ldar r1</code> (Load Accumulator from Register r1)</li>\n<li><strong>动作</strong>：老师傅走到 r1 原料架，把那里的材料拿下来，<strong>塞进随身包里</strong>。</li>\n<li><strong>状态</strong>：此时，随身包里的东西 = r1 的东西。</li>\n<li>Ldar 这个指令  很好记忆，ld是装载，a是累加器，r是寄存器，ldar就是装载累加器from寄存器，  <strong>把寄存器的内容装进累加器</strong>。</li>\n<li>Ldar r1  就是把寄存器r1里的东西 装进累加器。</li>\n<li>老师傅把r1的原料装进随身包里。</li>\n</ul>\n</li>\n<li>\n<p><code>Star</code> (Store Accumulator)</p>\n<p>活干完了，结果总不能一直烂在包里，得腾出地方干下一票，或者把结果存起来。</p>\n<ul>\n<li><strong>指令</strong>：<code>Star r2</code> (Store Accumulator to Register r2)</li>\n<li><strong>动作</strong>：老师傅把<strong>随身包里</strong>刚刚加工好的成品掏出来，放到 r2 原料架上去。</li>\n<li><strong>状态</strong>：此时，r2 原料架的东西 = 随身包里的东西。</li>\n<li>star 这个指令，也很好记忆，st是储存，a是累加器，r是寄存器，star就是存储累加器里的东西到寄存器。</li>\n</ul>\n</li>\n<li>\n<p><code>Add</code> / <code>Sub</code> ...</p>\n<p>这是真正的关键步骤。</p>\n<ul>\n<li><strong>指令</strong>：<code>Add r0</code></li>\n<li><strong>动作</strong>：老师傅走到 r0 原料架，拿个东西，直接跟<strong>随身包里</strong>原本的东西进行合体（相加）。</li>\n<li><strong>状态</strong>：随身包里的东西 = 原包里的值 + r0 的值。</li>\n<li><strong>重点</strong>：注意 <strong>结果依然留在包里</strong>，老师傅并没有急着去储存结果。</li>\n</ul>\n<p>指令都很简单，<strong>ld</strong>  <em>load</em>，<strong>st</strong>  <em>store</em>，<strong>a</strong>  <em>accumulator</em>，<strong>r</strong>  <em>register</em></p>\n<p>类似的  ldglobal  stglobal ldarg0  ldcurrentcontext  也都差不多，</p>\n<p>基本上都是  动作+对象  的模式。</p>\n<p>另外需要注意的是，累加器 Accumulator 通常会写作 acc。虽然它叫“累加器”，但千万不要理解成它只能做加法运算。<strong>从本质上讲，acc 就是解释器里唯一的“通用临时寄存器”</strong>：当前这条字节码要处理的值，或者运算后的中间结果，几乎都会暂时放在这里。</p>\n<p>acc 里可以装任何 JavaScript 的值，比如常量、小整数、字符串、对象引用、<code>undefined</code> 等。之所以要设计这么一个“统一的临时位置”，就是为了让大多数字节码只需要写明“另一个参与运算的对象是谁”，而不用每次都额外声明多个寄存器参数，从而<strong>让字节码更短、更规整，也让解释器实现更简单</strong>。</p>\n</li>\n</ul>\n<pre><code>  Ldar r1   ; acc = r1\n  Add r0    ; acc = acc + r0\n  Star r2   ; r2 = acc\n  \n  累加器acc的变化。    是不是非常简单。\n</code></pre>\n<h2 id=\"3--栈帧和槽位\">3 . 栈帧和槽位</h2>\n<p>在第一部分解析篇里  我们也提到过 槽位 这个术语， 上面又提到了，那么，槽位到底是什么呢？</p>\n<p><strong>槽位（slot）就是栈帧里一格一格固定大小的“存储单元”或“格子”，用于按索引存放函数的参数、局部变量、临时值、以及其它元数据。</strong> 它不仅是“位置”，还隐含了大小、类型（通常是指针/Tagged 值）、地址计算规则和生命周期语义。</p>\n<p>内存可寻址的最小单位是 8bit 即一字节， 虽然最小使用单位是8bit 即一字节。但是，因为需要字节对齐 和 机器指针大小的要求，所以 在32位系统上，  需要4字节表示指针， 64位系统上  需要8字节表示指针。 每个槽位的大小，也是按照操作系统机器指针的大小来划分的。 即   64位系统，一个槽位  占 8个字节 。 只有这样，<strong>64位系统</strong>使用指针寻址时，8字节，即64bit，才能够装得下一个指针。</p>\n<p>所以，每个槽位（slot）占 8个字节大小。</p>\n<p>当函数开始执行时，运行时runtime在栈上为它分配一段连续内存作为<strong>栈帧</strong>。在 Ignition 中，栈帧大致分为三部分：<strong>参数区</strong>、<strong>固定头部</strong>，  <strong>工作区</strong> 。栈帧里的每个“格子”称为<strong>槽位（slot）</strong>，按索引存放局部变量和临时值，槽位的大小通常等于机器指针大小， <strong>64 位</strong>下为 8 字节。</p>\n<p><strong>特别注意</strong>：前面我们一般并没有明确的区分栈帧里槽位和字段，现在明确一下，我们<strong>仅仅是把工作区中</strong>按索引的格子（<code>r0, r1, r2…</code>）称为<strong>槽位（frame slots）</strong>。固定头部里的字段（返回地址、saved FP、Context、BytecodeArray 等）我们<strong>不</strong>把它们称为槽位；参数一般称为 argument slots（<code>a0,a1</code>）或单独描述。</p>\n<p>严格从 V8 内存视角来看，栈帧中的每一个 8 字节存储单元（无论是 Context、返回地址还是局部变量）在源码中都统称为 <strong>Slot</strong>。</p>\n<p>但在解释器字节码的语句环境中，为了<strong>区分功能</strong>：</p>\n<ul>\n<li>我们将固定位置、用途单一的区域称为 <strong>“固定头部字段”</strong>（如 Function, Context）。</li>\n<li>我们将用于存储局部变量和临时结果、通过索引动态访问的区域特称为 <strong>“寄存器槽位”</strong> 或 <strong>“局部变量槽位”</strong> 或简称为 <strong>槽位</strong> 。</li>\n<li><strong>有时候可能会有混用，将栈上某字段也称为槽位，从规范从v8源码上来说，完全没有错误，只是因为手抖或者写快了，没有按照我们通常的按功能区分的约定称呼。</strong></li>\n<li>当然，你可以按照自己的意愿，区分或者不区分，<strong>都是正确的</strong>。前提是  你要知道观察的视角的不同。</li>\n</ul>\n<p>下面我们详细介绍一下栈帧的结构。</p>\n<p>栈的生长顺序，是<strong>从高地址到低地址</strong>，即入栈早的在高地址， 最后入栈的处于栈顶 在低地址。</p>\n<p>我们首先介绍个术语：Tagged Pointer</p>\n<blockquote>\n<h4 id=\"tagged-pointer--标签指针\">Tagged Pointer  标签指针</h4>\n<p>64位系统中，每个槽位都是 8 字节（64 位），V8 在这里面存数据时，使用了一个编码技巧，叫做 <strong>Tagged Pointer (带标签的指针)</strong>。</p>\n<p>在静态语言立，比如 C++ 这种静态语言，编译器知道变量是 <code>int</code> 还是 <code>Object*</code>。但在 JavaScript 中，类型是动态的。如果 V8 为每个变量额外存一个“类型字段”，内存消耗会翻倍。 V8 的做法是：<strong>把类型信息直接编码进这 64 位数据本身。</strong></p>\n<p><strong>方法就是复用“对齐留下的低位”</strong> 在 64 位平台上，内存地址通常是 <strong>8 字节对齐</strong> 的。合法地址的二进制形式，<strong>最低的几位通常都是 0</strong>。 V8 就是使用了这些闲置的低位，用来打上类型标签Tag。</p>\n<p><strong>Tagged Value 的分类：</strong> V8 把槽位里的机器字统称为 <strong>Tagged Value</strong>，根据低位标签不同，分为两类：</p>\n<p><strong>Smi (Small Integer，标签立即量)</strong></p>\n<ul>\n<li><strong>特征</strong>：最低位通常为 <code>0</code>。</li>\n<li><strong>含义</strong>：这 <strong>不是</strong> 指针，这 64 位数据本身就存着一个整数。</li>\n<li><strong>优势</strong>：整数直接住在栈上，不需要去堆里申请内存，速度极快。</li>\n<li><strong>还原</strong>：使用时，通过<strong>右移 (Shift)</strong> 运算去掉标签，就能得到整数值。</li>\n</ul>\n<p><strong>Tagged Pointer (堆对象引用)</strong></p>\n<ul>\n<li><strong>特征</strong>：最低位通常为 <code>1</code>。</li>\n<li><strong>含义</strong>：这是一个指向堆内存中对象（HeapObject）的 <strong>强引用</strong>。</li>\n<li><strong>注意</strong>：它不能直接当做物理地址用。</li>\n<li><strong>还原</strong>：使用时，必须通过<strong>位掩码 (Mask)</strong> 运算去掉标签（Untag），还原成纯净的内存地址，才能去访问堆里的对象。</li>\n</ul>\n<p>这样使用Tag以后， Tagged value 就像给数据穿了一件“马甲”。Ignition 看一眼马甲（标签位），就知道是整数还是对象。虽然使用前必须“脱马甲”（Untag），但这带来的性能提升和内存节省是巨大的。</p>\n<p>另外需要注意，使用tag标记，  能直接判定的类型集合很小（主要是 Smi 或HeapObject），更细的类型，需要读取对象头来获取。</p>\n</blockquote>\n<p>那么 ，栈帧的结构是怎样的呢？它的组成如下：</p>\n<ul>\n<li>\n<p>第一层  参数区 Arguments</p>\n<p>当调用一个函数时，调用者Caller需要给它传实参，同时还有个隐形参数this，这些内容，都在栈帧的第一层参数区。</p>\n<ul>\n<li><strong>Receiver (this)</strong>：\n<ul>\n<li>这是个隐形参数。当你写 <code>obj.func()</code> 时，<code>obj</code> 就是 Receiver。它是参数列表里的隐形老大哥。</li>\n</ul>\n</li>\n<li><strong>Arguments (<code>a0</code>, <code>a1</code>...)</strong>：\n<ul>\n<li>这就是 <code>function foo(x, y)</code> 里的 <code>x</code> 和 <code>y</code>。</li>\n<li>Ignition 给它们编的号是 <code>a0</code>, <code>a1</code>...</li>\n<li>要注意的是，这里的 <code>a</code> 代表 Argument，不要和 Accumulator 搞混了。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>第二层  固定头部  Fixed header / fixed frame part</p>\n<p>这是整个栈帧中最重要、最关键的区域。</p>\n<p>既然 Ignition 是个软件模拟的 CPU，那 CPU 运行时需要的那些状态  比如“我现在运行到哪一行了？”、“我的环境是谁？”  。。。等等信息， 都是存在哪的？</p>\n<p>没错，就存在这儿，固定头部。</p>\n<p>每个函数栈帧的中间，都夹着这么一块雷打不动的区域，保存着维持虚拟机运行的<strong>元数据</strong></p>\n<p>它里面的主要内容：</p>\n<ol>\n<li>\n<p><strong>Return Address (返回地址)</strong>：</p>\n<ul>\n<li><em>作用</em>：等这个函数执行完，底层调用栈就会根据这个返回地址，跳回调用处继续执行。</li>\n<li>这里腰注意，返回地址， 是控制流，是返回的应该到代码的哪个位置去继续执行。</li>\n</ul>\n</li>\n<li>\n<p><strong>Caller's Frame Pointer (上一层栈帧指针)</strong>：</p>\n<ul>\n<li>\n<p><em>作用</em>：链表指针。当前函数执行完、调用者的栈帧在哪里？</p>\n</li>\n<li>\n<p>这样依旧要注意，这个指针，指的是数据，上个字段返回地址，是控制流的返回，这里</p>\n</li>\n<li>\n<p>的上层栈帧指针，是控制流返回以后，继续执行， 应该从哪里去找变量，返回的是那个</p>\n</li>\n<li>\n<p>栈帧，可以理解为数据。</p>\n</li>\n<li>\n<p>在理解上，还可以大致认为，</p>\n</li>\n<li>\n<p>返回地址是等这个函数执行完，要回到哪一行继续执行代码，也就是<strong>控制流</strong>该跳回哪里。这是时间上的返回 ，代码继续从哪里跑。</p>\n<p>上一层栈帧指针是调用我的那个函数，它的栈帧从哪里开始？<br />\n这是空间上的返回 ，要去哪一块内存里继续访问局部变量和作用域数据。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Context (上下文指针)</strong></p>\n<ul>\n<li>\n<p><em>这是什么</em>：它指向 <strong>堆内存 (Heap)</strong> 中一个叫做 <code>Context</code> 的对象。</p>\n</li>\n<li>\n<p>为什么要它：</p>\n<p>如果函数里用到的变量是自己的 let a，直接去栈上找（r0）。</p>\n<p>但如果用到了闭包变量（外层函数的变量），Ignition 必须拿着这个 Context 指针，去堆里的上下文链表上一层层找。</p>\n</li>\n<li>\n<p><em>地位</em>：它是连接 <strong>“栈世界（临时数据）”</strong> 和 <strong>“堆世界（持久数据）”</strong> 的唯一桥梁。</p>\n</li>\n<li>\n<p>这个概念非常重要，值得我们深入了解。另外插一句，虽然说  这整个部分都可以了解为主，但是如果认真学习，能够掌握，还是有很大的用处。比如这个栈帧，对于js开发还是很重要的。</p>\n</li>\n<li>\n<p>上面有个上一层栈帧指针，这里又有个上下文指针，怎么正确而深入的理解他们呢？</p>\n</li>\n<li>\n<p>**上一层栈帧指针是“动态调用链” **</p>\n<ul>\n<li><strong>回答的问题：</strong> “我是被谁调用的？”</li>\n<li><strong>指向哪里：</strong> 指向<strong>栈（Stack）</strong>上的上一级栈帧。</li>\n<li><strong>作用：</strong> 函数执行完（return）后，底层会根据返回地址跳回调用者继续执行，而上一层栈帧指针则用来恢复调用者的栈帧布局，用于继续访问它的局部变量等数据。</li>\n</ul>\n<p>**Context 是“静态作用域链” **</p>\n<ul>\n<li><strong>回答的问题：</strong> “我是被定义在哪里的？”</li>\n<li><strong>指向哪里：</strong> 指向<strong>堆（Heap）</strong>上的 Context 对象。</li>\n<li><strong>作用：</strong> 它是<strong>数据流</strong>的查找路线。当函数访问一个不在自己内部的变量（自由变量）时，V8 会顺着这条链去查找。</li>\n</ul>\n</li>\n<li>\n<p>理解的关键点</p>\n</li>\n<li>\n<p><strong>上一层栈帧指向的是栈内存</strong>：栈帧是临时的，函数一返回，栈帧就销毁了。</p>\n<p><strong>Context 指向的是堆内存</strong>：这是为了实现 JavaScript 的<strong>闭包</strong>特性。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Function / Frame Marker (函数/帧类型标记)</strong>：</p>\n<ul>\n<li>\n<p>这个字段的<strong>位置</strong>在<code>[FP - 16]</code>  <strong>请注意</strong>  这里的偏移值 16 仅是<strong>示意</strong>。  这种表示方法，后面会详细介绍。</p>\n</li>\n<li>\n<p>这是一个具有<strong>多态性 (Polymorphic)</strong> 的关键槽位。它用于当前栈帧的身份识别。V8 引擎利用这个槽位来区分当前栈帧是属于标准的 JavaScript 函数调用，还是属于引擎内部的 C++ 调用。</p>\n</li>\n<li>\n<p>V8 的栈遍历器（Stack Walker）在扫描堆栈时（例如进行 GC 标记、生成错误堆栈或反优化时），会读取该槽位的值，并根据 <strong>指针标记位 (Tag Bit)</strong> 进行判断：</p>\n<ul>\n<li><strong>如果是对象指针（Heap Object）</strong>：判定为 <strong>Interpreted Frame</strong>（解释器帧）。</li>\n<li><strong>如果是小整数（Smi）</strong>：判定为 <strong>Internal Frame</strong>（内部帧）。</li>\n</ul>\n</li>\n<li>\n<p>具有两种可能的状态：</p>\n</li>\n<li>\n<p>状态 A：存放 <code>JSFunction</code> (Closure)</p>\n<ul>\n<li><strong>场景</strong>：当执行常规 JavaScript 代码时。</li>\n<li><strong>内容</strong>：指向当前正在执行的函数对象（闭包）的指针。</li>\n<li><strong>作用</strong>：\n<ol>\n<li>作为<strong>资源入口</strong>：解释器通过它访问 <code>SharedFunctionInfo</code>（获取字节码）和 <code>FeedbackVector</code>（获取优化反馈）。</li>\n<li>连接<strong>堆与栈</strong>：保持对堆上函数对象的强引用，防止被 GC 回收。</li>\n</ol>\n</li>\n</ul>\n<p><strong>状态 B：存放 <code>StackFrame::Type</code> (Marker)</strong></p>\n<ul>\n<li><strong>场景</strong>：当执行 V8 内部代码（如 <code>EntryFrame</code>, <code>ConstructFrame</code>, <code>BuiltinFrame</code>）时。</li>\n<li><strong>内容</strong>：一个枚举值（Smi），标识具体的帧类型。</li>\n<li><strong>作用</strong>：\n<ol>\n<li><strong>路标作用</strong>：告诉栈遍历器如何解析当前帧的其余部分（不同类型的内部帧，布局可能不同）。</li>\n<li><strong>边界界定</strong>：标记 JS 代码与 C++ 代码的转换边界</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Bytecode Array (字节码数组指针)</strong>：</p>\n<ul>\n<li>\n<p><strong>这个字段的位置：</strong> <code>[FP - 24]</code>   依旧请注意，偏移值 24 仅是示意。</p>\n</li>\n<li>\n<p><strong>这个字段的内容：</strong> 一个指向堆内存中 <code>BytecodeArray</code> 对象的 <strong>Tagged Pointer</strong>。</p>\n</li>\n<li>\n<p><strong>定义：</strong> 它是解释器 Ignition 真正“读取”和“执行”的指令序列源头。</p>\n</li>\n<li>\n<p>这个字段是一个指针，指向堆（Heap）上的一个<code>BytecodeArray</code> 对象。</p>\n<p>之所以叫 <code>Array</code>，是因为它的<strong>主体部分</strong>确实是一串连续的、变长的字节序列。</p>\n<p>在 V8 的底层 C++ 定义中，凡是符合 <strong>“定长头部 + 变长尾部”</strong> 结构的对象，通常都以此命名。</p>\n<ul>\n<li><strong>普通对象 (<code>JSObject</code>)</strong>：大小通常是固定的（或者由 Map 描述）。</li>\n<li><strong>数组类对象 (<code>FixedArray</code>, <code>ByteArray</code>)</strong>：\n<ol>\n<li>它是<strong>变长</strong>的（在分配时决定大小）。</li>\n<li>它的<strong>主要内容</strong>是可以通过索引（Index）访问的序列。</li>\n</ol>\n</li>\n</ul>\n<p>之所以叫 <code>BytecodeArray</code> 是为了强调它的<strong>存储形态</strong>是线性的字节序列。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Bytecode Offset (字节码偏移量 / PC)</strong>：</p>\n<ul>\n<li><em>作用</em>：<strong>程序计数器</strong>。记录当前执行到第几条指令了。</li>\n<li><strong>位置：</strong> <code>[FP - 32]</code> (即 <code>StandardFrameConstants::kBytecodeOffset</code>)  ，偏移值32，仅为示意，并非确定值。</li>\n<li><strong>形式：</strong> <strong>Smi (小整数)</strong>。</li>\n<li><strong>含义：</strong> 它记录了当前执行到了 <code>BytecodeArray</code> 中的<strong>第几个字节</strong>。</li>\n<li><em>细节</em>：在正常解释执行期间，PC 状态常驻在<strong>真实的物理寄存器</strong>，在之中不停的变动，只有在需要外部可见或恢复时（GC/中断/断点/反优化/进入 runtime 等），解释器会把寄存器的值写回栈帧 BytecodeOffset 字段）。恢复时会把它再装回物理寄存器。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>第三层   工作区  Work Area / Virtual Registers</p>\n<p>这是栈帧中位于固定头部后面、向低地址延伸的区域。</p>\n<p>Ignition 将这段连续的内存槽位，给它们编上号：<code>r0</code>, <code>r1</code>, <code>r2</code>...</p>\n<p>虽然它们在物理上只是连续的 8 字节内存格子，但在逻辑上，它们通常划分成了三种截然不同的用途。</p>\n<h4 id=\"1-显式局部变量-explicit-locals\">1. 显式局部变量 (Explicit Locals)</h4>\n<p>这是最好理解的部分。它们直接对应你在 JavaScript 代码中声明的局部变量。</p>\n<p>生成器（BytecodeGenerator）会按照特定算法（通常与声明顺序相关）为这些变量分配槽位。</p>\n<ul>\n<li>示例</li>\n</ul>\n<p>function demo() {<br />\nvar name = 'v8';  // 编译器决定：分配给 r0<br />\nlet age = 10;     // 编译器决定：分配给 r1<br />\n}</p>\n<p>当代码执行到这里时，<code>r0</code> 槽位里就填入了 <code>\"v8\"</code> 的指针，<code>r1</code> 槽位里填入了 <code>10</code> 的 Smi 值。</p>\n<ul>\n<li>\n<p><strong>关键点：作用域分析 (Scope Analysis)</strong></p>\n<p><strong>要注意</strong>  并不是你写的所有局部变量都能住在这个“栈上的工作区”。</p>\n<p>在生成字节码之前，V8 会先进行一次 <strong>作用域分析</strong>。</p>\n<ul>\n<li><strong>判断标准</strong>：如果一个变量被内部函数（闭包）<strong>捕获 (Captured)</strong> 了，它就不能住在栈上</li>\n<li><strong>原因</strong>：栈帧生命是有限的，函数执行完就销毁了。但闭包可能在函数执行完后还需要访问这个变量。</li>\n<li><strong>结果</strong>：被捕获的变量会被请到堆内存的 <strong>Context 对象</strong> 中。</li>\n<li><strong>结论</strong>：所以，能安稳住在 <code>r0, r1</code> 里的，都是身家清白的、<strong>未被捕获</strong>的局部变量。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-隐式临时变量-implicit-temporaries\">2. 隐式临时变量 (Implicit Temporaries)</h4>\n<p>这是在源代码里完全看不到，但机器执行时必须存在的变量。这也是 <strong>寄存器分配 (Register Allocation)</strong> 算法大显身手的地方。</p>\n<ul>\n<li>\n<p><strong>为什么要临时变量？</strong></p>\n<p>想象一下计算 <code>var x = a + b + c;</code></p>\n<p>Ignition 的累加器（老师傅的随身包）只有一个。</p>\n<ol>\n<li>先把 <code>a</code> 拿进包，把 <code>b</code> 加进来。包里现在是 <code>(a+b)</code>。</li>\n<li>下一步要加 <code>c</code>。指令要求 <code>Add c</code>。</li>\n<li><strong>发生冲突</strong>：如果 <code>c</code> 的获取过程很复杂（比如 <code>c</code> 是个函数调用 <code>getC()</code>），那么在执行 <code>getC()</code> 的过程中，累加器会被反复使用、覆盖。</li>\n<li><strong>如何解决</strong>：必须先把 <code>(a+b)</code> 的结果找个格子 <strong>暂存 Spill</strong> 起来。</li>\n</ol>\n</li>\n<li>\n<p><strong>物理存在</strong>：</p>\n<p>Ignition 会在局部变量后面，划出一些格子作为 <strong>临时寄存器</strong>。</p>\n<p>这些格子就像老师傅手边的“小黑板”。</p>\n<ul>\n<li><strong>复用性</strong>：这行代码算完了，这张“小黑板”擦干净，立刻给下一行代码复用。所以即使代码很长，只要不同时通过大量中间结果，Frame Size 也不会很大。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-神秘的洞-the-hole\">3. 神秘的洞 (The Hole)</h4>\n<p>这是 ES6 引入 <code>let/const</code> 后，V8 在底层实现 <strong>TDZ (暂时性死区)</strong> 的最硬核手段。</p>\n<p>在第一部分解析篇中，我们已经详细学习了这个 会吹哨子的警卫thehole，忘记了的朋友，可以复习一下第一篇中的相关内容。这里我们略微的再讲一下。</p>\n<p>在栈帧刚刚被创建，但代码还没执行到 <code>let a = ...</code> 这一行时，<code>rX</code> 槽位里放的是什么？</p>\n<ul>\n<li>\n<p><strong>对于 <code>var</code></strong>：</p>\n<p>V8 会把对应的槽位初始化为 <code>undefined</code>。所以在赋值前访问它，拿到的就是 <code>undefined</code>（变量提升）。</p>\n</li>\n<li>\n<p><strong>对于 <code>let / const</code></strong>：</p>\n<p>V8 会把对应的槽位填入一个特殊的 <strong>会吹哨子的警卫</strong>，在内部被称为 <strong><code>The Hole</code></strong>。</p>\n</li>\n<li>\n<p><strong>执行时的检查机制</strong>：</p>\n<p>Ignition 在执行读取变量的指令（如 <code>LdaRep</code>）时，内置了一段小逻辑：</p>\n<p>// 伪代码<br />\nvalue = load(r1);<br />\nif (value == The_Hole_Value) {<br />\nthrow ReferenceError(\"Cannot access before initialization\");<br />\n}</p>\n<p>TDZ 并不难理解，它在物理层面上，就是一个槽位里放着 <code>The Hole</code>，而解释器在读取时不仅读数据，还顺手做了一次安全检查，如果摸到的是警卫，哨子就响。</p>\n</li>\n</ul>\n<h4 id=\"4-寻址机制如何找到-r5\">4. 寻址机制：如何找到 <code>r5</code>？</h4>\n<p>工作区只是一段连续的内存，Ignition 怎么知道 <code>r5</code> 在哪？</p>\n<p>这就要用到汇编里的 <strong>基址寻址</strong> 了。</p>\n<ul>\n<li>\n<p><strong>基准点</strong>：<strong>FP (Frame Pointer)</strong>，指向固定头部的特定位置。</p>\n</li>\n<li>\n<p>有朋友可能会有疑问了，前面说栈帧有3部分，第一部分是参数区，可是为什么FP基准点指向固定头部 ，而不是指向参数部分。</p>\n</li>\n<li>\n<p>参数空间是<strong>调用者</strong>的区域，因此在语义上它属于caller 的部分 ，而不是 callee 用来分配本地变量/临时的 workspace。FP 作为被调用者的栈帧基准点，通常是不包括参数区的。</p>\n</li>\n<li>\n<p><strong>计算公式</strong>：</p>\n<p>由于栈是向低地址增长的，所以寄存器的地址是 FP 减去一个偏移量。</p>\n<p>Address(rn) = FP - fixed_header_size - (n * slot_size)</p>\n<p>其中 <code>fixed_header_size</code> 是固定头部的字节长度，<code>slot_size</code> 通常等于机器指针大小（在 64 位系统下常为 8 字节）</p>\n</li>\n<li>\n<p><strong>示例：</strong></p>\n<ul>\n<li><code>FP</code> 指向这里。</li>\n<li>往下走 8 字节... 是 <code>Context</code> <code>[FP-8]</code>。</li>\n<li>再往下... 是 <code>Function</code> <code>[FP-16]</code>。</li>\n<li>再往下... 是 <code>BytecodeArray</code> <code>[FP-24]</code>。</li>\n<li>再往下... 是 <code>BytecodeOffset</code> <code>[FP-32]</code>。<strong>(固定头部结束)</strong></li>\n<li><strong>再往下... 终于到了工作区的 r0</strong> <code>[FP-40]</code>。</li>\n<li><code>r0</code> 再往下 8 字节是 <code>r1</code>。</li>\n</ul>\n<p>所以，字节码里的简单指令 <code>Ldar r5</code>，翻译到底层 CPU 动作，就是去读更深处的内存地址。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4--调用约定和内存布局\">4 . 调用约定和内存布局</h2>\n<p>通过前面的学习，我们已经大致了解了栈帧的内容，现在我们就需要在脑子中建立起动态的栈帧模型。</p>\n<ul>\n<li>\n<p>建立我们自己的心智模型，内存的想象图</p>\n<p>那么 我们怎么想象内存呢？ 梯子，高耸入云的梯子，一格一格的代表内存单元。</p>\n<p><strong>地面（最底下）</strong>：是 <strong>高地址</strong>（比如 <code>0xFF...</code>）。对于栈帧来讲，这是稳固的地基。</p>\n<p><strong>天空（往上看）</strong>：是 <strong>低地址</strong>（比如 <code>0x00...</code>）。这是延伸空间。</p>\n<p>最底下是高地址，越往上，地址越低。</p>\n<p>有朋友可能会问：“书上或者 V8 源码注释里，通常都是画‘高地址在上，低地址在下’，栈是‘向下生长’的，为什么我们要反着来？”</p>\n<p>这其实是为了贴合<strong>直觉</strong>。 如果你使用过 OllyDbg、x64dbg 或 IDA 等调试工具，你会发现它们的内存视图通常是这样的：</p>\n<ul>\n<li><strong>上面</strong> 显示的是 <strong>低地址</strong>。</li>\n<li><strong>下面</strong> 显示的是 <strong>高地址</strong>。</li>\n</ul>\n<p><strong>这种视角的好处极其直观：</strong></p>\n<ul>\n<li><strong>入栈 Push</strong>：就像盖楼一样，在现有的楼顶上，<strong>往上</strong> 再盖一层（地址变低/变小）。</li>\n<li><strong>出栈 Pop</strong>：就像拆楼一样，把最上面的一层拆掉（地址变回高/变大）。</li>\n<li><strong>栈底</strong>：在最下面（高地址），通常存放着调用者的环境，在一个栈帧中，很少变动。</li>\n<li><strong>栈顶</strong>：在最上面（低地址），数据频繁进进出出出栈入栈，变动剧烈。</li>\n</ul>\n<p>所以，为了理解起来更顺畅，建议我们在脑海中建立的模型如下：</p>\n<ul>\n<li><strong>高地址在下</strong>（地基）。</li>\n<li><strong>低地址在上</strong>（天空）。</li>\n<li><strong>栈帧的生长方向</strong>：从下往上，<strong>向低地址生长</strong>。</li>\n</ul>\n</li>\n<li>\n<p>指针和内存单元</p>\n<p><strong>最小刻度：字节 (Byte)</strong> 在计算机里，<strong>8 bit (1字节)</strong> 是内存可寻址的最小单位。</p>\n<p><strong>实际步长：</strong>    虽然刻度是按 字节 画的，但在 64 位系统里，Ignition 这个老师傅手很大。 他干活时，<strong>不会像学友哥那样捏着兰花指去抓 1 个字节。</strong>   他<strong>每一次伸手，都要抓走 8 个字节</strong>（64 bit）。这 8 个字节合起来，才构成了一个完整的 <strong>槽位 (Slot)</strong>。</p>\n<p><strong>内存对齐：</strong> 每一次都要操作 8 个字节，所以，所操作的地址，都是8的倍数：</p>\n<p>0  8  16  24 。。。（这些数字仅仅是示意地址是8的倍数）</p>\n<p>这就是 <strong>内存对齐</strong>。</p>\n<p><strong>注意：</strong> 这并不代表地址 <code>1, 2, 3...7</code> 是“空闲”或者“没用”的。 当你向地址 <code>0</code> 写入一个 64 位指针或者数据时，这个指针或数据用64bit的庞大的身躯<strong>填满</strong>了从 <code>0</code> 到 <code>7</code> 的所有空间。 只不过，当我们想<strong>找到</strong>这个数据时，我们只在这个数据的<strong>头部（首地址）</strong> 找起。</p>\n<p><strong>地址 0</strong>：是第一个槽位的<strong>门口</strong>。<strong>地址 8</strong>：是第二个槽位的<strong>门口</strong>。</p>\n<p>这就解释了我们在前面内容中提到的 <strong>Tagged Pointer</strong> 原理： 因为地址只在 <code>0, 8, 16</code> 这些 <code>8</code> 的倍数上，所以这些地址的二进制表示，<strong>最后 3 位通常是 0</strong>。 V8 也是看准了这一点，才敢把这 3 位挪作他用（存类型 Tag）。</p>\n<p><strong>指针</strong>   如何理解？</p>\n<p>指针就是地址，之所以说是指针 而不是直接说地址，是因为 指针收紧了地址的概念。</p>\n<p>“地址”是物理层面的客观存在，而“指针”是软件层面的主观定义。指针对地址具有收紧和约束作用。</p>\n<p>准确的说  <strong>指针是对地址概念的一次“收紧”和“赋予语义”</strong>。</p>\n<ul>\n<li>\n<p><strong>地址</strong></p>\n</li>\n<li>\n<p><strong>本质</strong>：它只是一个冷冰冰的数字编号（比如 <code>0x0000FFFF</code>）。</p>\n</li>\n<li>\n<p><strong>缺陷</strong>：它没有任何约束。给你一个地址，你根本不知道那里住的是什么。</p>\n<ul>\n<li>是 4 个字节的整数？</li>\n<li>还是 1 个字节的字符？</li>\n<li>或者是一段可执行的代码？</li>\n<li>甚至可能是一个无效的垃圾值？</li>\n</ul>\n</li>\n<li>\n<p><strong>状态</strong>：如果你只拿到了一个地址，你面对的是未知的、混乱的内存空间。</p>\n</li>\n<li>\n<p>**指针 **</p>\n</li>\n<li>\n<p><strong>本质</strong>：<strong>指针 = 地址 + 类型约束（解释方式）</strong>。</p>\n</li>\n<li>\n<p><strong>收紧的概念</strong>：</p>\n<p>当我们定义一个指针（比如 C++ 里的 <code>int* p</code> 或 V8 里的 <code>Tagged Pointer</code>）时，我们实际上是<strong>收紧</strong>了对那个内存地址的操作权限和理解方式。</p>\n<ul>\n<li>它告诉 CPU：“别乱猜了，这个地址里存的一定是 <strong>对象</strong>，而不是整数。”</li>\n<li>它告诉编译器：“当你去读这个地址时，请按照 <strong>8 字节</strong> 为单位去读，不要只读 1 个字节。”</li>\n</ul>\n</li>\n</ul>\n<p>在 V8 的 Ignition 中，这种“收紧”体现得更全面：</p>\n<ol>\n<li>\n<p><strong>标签 (Tagging)</strong>：</p>\n<p>V8 的指针（Tagged Pointer）利用最低位（Tag Bit）强行规定了语义。</p>\n<ul>\n<li>如果最后一位是 <code>0</code>：<strong>收紧为“立即数”</strong>（Smi）。不需要去内存里找，它自己就是值。</li>\n<li>如果最后一位是 <code>1</code>：<strong>收紧为“堆指针”</strong>（HeapObject）。必须去堆里找。</li>\n</ul>\n</li>\n<li>\n<p><strong>隐藏类 (Map/Hidden Class)</strong>：</p>\n<p>当你顺着 V8 的指针找到堆里的对象时，对象的第一个属性通常是 <strong>Map</strong>（隐藏类）。</p>\n<p>这实际上是进一步的“收紧”：</p>\n<ul>\n<li>“这个地址不仅是个对象，而且它是一个 <strong>数组</strong>，长度是 10，元素类型是...”。</li>\n</ul>\n</li>\n</ol>\n<p>最后需要注意，越往底层，比如到了汇编  到了代码调试 ，对于指针和地址的区分，就越趋近于无，很多时候，都是混着叫的，基本上都是使用指针就是地址 这个本质概念了。因为约束已经剥离，只剩本质了。</p>\n<p><strong>调用约定</strong></p>\n<p>我们在前面学习了栈帧的物理结构：参数在高地址，返回地址在中间，变量在低地址。</p>\n<p>这时候，无中生友的朋友又出现了：为什么要这么放？我倒过来放不行吗  我混着放不行吗？</p>\n<p>这就引出了一个重要的概念 调用约定。</p>\n<ul>\n<li>\n<p>简单来说，调用约定就是 <strong>调用者 (Caller)</strong> 和 <strong>被调用者 (Callee)</strong> 之间达成的一份 <strong>“协议”</strong> 或 <strong>“合同”</strong>。</p>\n<p>想象一下两个人在玩球球：</p>\n<ul>\n<li>\n<p><strong>Caller</strong> 说：“我会把球抛到<strong>你的左手边</strong>。”</p>\n</li>\n<li>\n<p><strong>Callee</strong> 说：“好的，我会跑到<strong>左手边</strong>去接球。”</p>\n<p>这就是约定。如果 Caller 抛向左边，而 Callee 跑去右边接，球就掉了（程序崩溃）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>在 V8 里，这份 协议/合同 规定了三个最核心的问题：</p>\n<ol>\n<li><strong>参数放哪？</strong> (传递方式)\n<ul>\n<li>是放在 CPU 寄存器里？还是压到栈内存里？</li>\n<li>如果是压栈，是从左往右压，还是从右往左压？</li>\n</ul>\n</li>\n<li><strong>结果放哪？</strong> (返回方式)\n<ul>\n<li>函数算完了，结果放在哪个寄存器里带回去？（通常是累加器/rax）。</li>\n</ul>\n</li>\n<li><strong>谁来打扫卫生？</strong> (堆栈平衡)\n<ul>\n<li>参数占用的栈空间，是 Caller 负责回收，还是 Callee 负责回收？</li>\n</ul>\n</li>\n</ol>\n<p><strong>V8的特殊之处：垃圾回收</strong></p>\n<p>在c / c++ 中， 标准约定通常会优先把前几个参数放在 <strong>物理寄存器</strong> 里传递，这样速度会达到极致。</p>\n<p>但是在V8的 Ignition 解释器里，我们看到参数几乎都是乖巧的排列在栈上。这是为什么？</p>\n<p>因为 V8 有一个幽灵暗卫 ，这就是 <strong>垃圾回收器 (GC)</strong>。</p>\n<ul>\n<li><strong>GC 的全年无休</strong>：GC 需要时刻扫描内存，看看哪些对象还活着（有指针指向它）。</li>\n<li><strong>寄存器无法跟踪</strong>：如果参数散落在各种物理寄存器里，这就很难追踪。</li>\n<li><strong>V8 的折中拖鞋</strong>：<strong>确保栈上有一份“可扫描”的备份。</strong></li>\n</ul>\n<p>即使某些参数是通过寄存器传进来的，为了方便 GC 撸羊肉串式的扫描，V8 通常也会保证这些参数在栈上有一个确定的位置（或者把寄存器的值“抄写”到栈上）。记得前面说PC的时候，提过一次。</p>\n<p>so  这就形成了我们在栈帧图中看到的那样,参数在内存里连续排列，GC 扫起来非常舒服。</p>\n<p><strong>再说栈帧的内存布局</strong></p>\n<p>在前面我们讲栈帧的结构时，从高地址到低地址，依次是  参数区--固定头部区--工作区，但是</p>\n<p>对于栈帧的分界和字段的所有者，并没有详细的说明。 现在我们有了足够的铺垫，可以详细了解了。</p>\n<p>我们需要按<strong>时间顺序</strong>走一遍流程。</p>\n<p>这对于理解 FP（栈帧指针）这个“界碑”至关重要。</p>\n<p><strong>第一阶段：调用者准备工作</strong></p>\n<p>调用者在执行 <code>CALL</code> 指令之前，需要先准备好贡品：</p>\n<ol>\n<li>\n<p><strong>Push 参数</strong>：调用者把参数（Receiver, a0, a1...）按顺序压入栈。</p>\n<ul>\n<li><em>(这是 Caller 划拨的内存，属于 Caller 的栈帧范围，但供 Callee 使用)</em></li>\n</ul>\n</li>\n<li>\n<p><strong>执行 CALL 指令</strong>：CPU 自动将 <strong>返回地址 (Return Address)</strong> 压入栈顶，并跳转到 Callee 的代码处。</p>\n<ul>\n<li><em>(此时，FP 指针依然指向 Caller 的老基准点)</em></li>\n</ul>\n</li>\n</ol>\n<p><strong>第二阶段：被调用者接手</strong></p>\n<p>控制权来到了 Ignition（被调用者）手中，它进门后的<strong>头等大事</strong>就是建立自己的宗门（栈帧）：</p>\n<ol>\n<li><strong>Push Caller's FP</strong>：Ignition 做的第一件事，就是把旧的 FP（上一层的基准点）压入栈中保存起来。\n<ul>\n<li><em>(这一步形成了 Saved FP，也就是栈帧中间的那个连接点)</em></li>\n</ul>\n</li>\n<li><strong>Set New FP</strong>：Ignition 把当前的栈顶指针 (SP) 赋值给 FP。\n<ul>\n<li><em>(从此，FP 指向了 Saved FP。新的栈帧基准点正式建立)</em></li>\n</ul>\n</li>\n<li><strong>Push Fixed Header</strong>：接着，Ignition 依次压入 Context、Function、BytecodeArray、BytecodeOffset 等固定字段。</li>\n<li><strong>Allocate Locals</strong>：最后，根据 Frame Size，一次性把栈顶指针 (SP) 往下移，为局部变量（r0, r1...）留出空间，并初始化为 <code>undefined</code> 或 <code>The Hole</code>。</li>\n</ol>\n<h3 id=\"_\"></h3>\n<p>有了这个流程，我们再看“户口归属”就非常清晰了：</p>\n<ul>\n<li>\n<p><strong>FP 及其上方 (参数、返回地址)</strong>： 虽然物理上和 FP 连在一起，但它们是 <strong>Caller</strong> 在第一阶段留下的“遗产”。</p>\n<ul>\n<li>参数是 Caller 带来的。</li>\n<li>返回地址是 Caller 带来的。</li>\n<li>Saved FP 是 Callee 为了保护 Caller 而存的。</li>\n</ul>\n</li>\n<li>\n<p><strong>FP 下方 (固定头部、工作区)</strong>： 这是 <strong>Callee</strong> 在第二阶段亲手创建的“资产”。</p>\n<ul>\n<li>Context 是 Callee 找来的。</li>\n<li>局部变量是 Callee 分配的。</li>\n</ul>\n</li>\n</ul>\n<p>这样，我们再来看栈帧的结构，理解上的逻辑就完全闭环了： <strong>Caller 给资源（参数） --- 硬件给退路（返回地址） ---  Callee 建地基（保存旧FP） ---  Callee 建房子（头部和变量）。</strong></p>\n<p><strong>FP和偏移量</strong></p>\n<p>在前面我们学习栈帧的固定头部中的字段时，我们使用了 FP加偏移值 的表示方式。</p>\n<p>爱琢磨的朋友肯定会有疑问：<strong>为什么所有东西都要盯着 FP 看？为什么是这些特定的数字？FP 里面到底装了什么？</strong></p>\n<ol>\n<li><strong>为什么选 FP (Frame Pointer) 做基准？</strong></li>\n</ol>\n<p>你可能会问：“栈顶指针 <strong>SP (Stack Pointer)</strong> 也是个指针，而且它就在栈顶，为什么不用 SP 来找数据，非要专门维护一个 FP 呢？”</p>\n<p><strong>原因就是：SP 是“动”的，FP 是“静”的。</strong></p>\n<ul>\n<li>\n<p><strong>SP 的动如脱兔</strong>：</p>\n<p>在函数执行过程中，Ignition 可能会频繁地入栈、出栈（比如压入临时变量、准备子函数参数）。</p>\n<p>这就导致 SP 的位置一直在变。</p>\n<p>如果用 SP 做基准，当你找 <code>变量 a</code> 时，上一行代码可能是 <code>[SP + 8]</code>，下一行代码因为压了个临时值，就变成 <code>[SP + 16]</code> 了。编译器计算起来会疯掉。</p>\n</li>\n<li>\n<p><strong>FP 的静如瘫痪</strong>：</p>\n<p>一旦栈帧建立完毕（Prologue 结束），在整个函数执行期间，<strong>FP 指针就是钉在栈帧的固定位置（Saved FP 那个槽位），雷打不动。</strong></p>\n<p>此时，我们以 FP 为原点，向上下看：</p>\n<p><strong>往下看（向地基/高地址）</strong>：不管栈顶怎么变，参数 <code>a0</code> 永远在 FP <strong>往下数</strong> 第 2 格的位置（偏移量是正数，如 <code>FP + 16</code>）。</p>\n<p><strong>往上看（向天空/低地址）</strong>：不管栈顶怎么变，变量 <code>r0</code> 永远在 FP <strong>往上数</strong> 第 5 格的位置（偏移量是负数，如 <code>FP - 40</code>）。</p>\n</li>\n</ul>\n<p><strong>所以</strong>：FP 提供了一个<strong>静态的、绝对的</strong>参考坐标系。</p>\n<ol start=\"2\">\n<li>**FP和地址和内容 **</li>\n</ol>\n<p>这是初接触的朋友，理解栈帧链表最容易迷糊的地方。</p>\n<p>我们要区分三个概念：</p>\n<ul>\n<li><strong>FP 寄存器</strong>：</li>\n</ul>\n<p>可以简化理解为，这是 CPU 里的一个物理部件（或 Ignition 的虚拟指针）。</p>\n<ul>\n<li><strong>FP 中的内容</strong>：</li>\n</ul>\n<p>FP中的内容就是 一个内存地址。</p>\n<p>这个内存地址是个指针，指向当前栈帧中的一个字段，</p>\n<p>同时，这个内存地址/指针，也是当前栈帧的 <strong>“零点”</strong>。即 <code>Offset = 0</code>。</p>\n<ul>\n<li><strong>FP 指向的内存地址里存的内容</strong>：</li>\n</ul>\n<p>那么 这个栈帧中的字段，里面的内容是什么？</p>\n<p><strong>答案是：Caller's FP (调用者的 FP)。</strong></p>\n<p>即：上一层栈帧的基准地址。</p>\n<p><strong>这同时也是“栈回溯”的原理：</strong></p>\n<ul>\n<li>当前 FP 指向 <code>Saved FP</code>。</li>\n<li><code>Saved FP</code> 里存着 <code>上一层 FP</code>。</li>\n<li><code>上一层 FP</code> 里存着 <code>上上层 FP</code>。</li>\n<li>...</li>\n<li>这就形成了一条<strong>链表</strong>。调试器（Debugger）就是顺着这条链子，一层层往上爬，才打印出了完整的调用栈。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>偏移量 (Offset) 是怎么确定的？</strong></li>\n</ol>\n<p>搞懂了 FP 是零点，那么，对于参数和变量的寻址，就非常容易理解了。</p>\n<p>让我们站在 FP 这个零点，开始巡视：</p>\n<p><strong>A. 往下看：Caller 留下的遗产 (因为我们使用高地址在下，低地址在上的模式)</strong></p>\n<p>这里是地址 <strong>增加</strong> 的方向（Offset 是 <strong>正数 +</strong>），因为我们在往高地址走。</p>\n<ul>\n<li><strong>Offset     +0 (<code>[FP + 0]</code>)</strong>： 就是脚下。这里存的是 <strong>Saved FP</strong>。</li>\n<li><strong>Offset     +8 (<code>[FP + 8]</code>)</strong>： <strong>往下</strong> 走 1 格。 这里是 <strong>Return Address</strong>。 <em>(为什么是 +8？因为往高地址走了 8 字节。)</em></li>\n<li><strong>Offset     +16 (<code>[FP + 16]</code>)</strong>： <strong>再往下</strong> 走 1 格。 这里是 <strong>Receiver (this)</strong>。 <em>(注：这是雷打不动的专座，离 FP 最近的参数。)</em></li>\n<li><strong>Offset     +24 (<code>[FP + 24]</code>)</strong>： <strong>再往下</strong> 走 1 格。 这里是 <strong>第一个显式参数 (Arguments a0)</strong>。 <em>(注：如果有更多参数 a1, a2... 会继续往下排在 +32, +40...)</em></li>\n</ul>\n<p><strong>B. 往上看：Callee 自己的资产 (低地址区)</strong></p>\n<p>关于偏移量的具体值，在前面，特别说明是用于  <strong>示意</strong>  ，  V8源码中的偏移如下，暂时可以作为确定值，但是以后很有<strong>可能会更改</strong>。</p>\n<blockquote>\n<p><strong>FP (基准)</strong></p>\n<p><strong>[FP - 8]</strong>: <code>StandardFrameConstants::kContextOffset</code> -&gt; <strong>Context</strong></p>\n<p><strong>[FP - 16]</strong>: <code>StandardFrameConstants::kFunctionOffset</code> -&gt; <strong>Function</strong></p>\n<p><strong>[FP - 24]</strong>: <code>InterpretedFrameConstants::kBytecodeArrayFromFp</code> -&gt; <strong>BytecodeArray</strong> (解释器特有)</p>\n<p><strong>[FP - 32]</strong>: <code>InterpretedFrameConstants::kBytecodeOffsetFromFp</code> -&gt; <strong>BytecodeOffset (PC)</strong></p>\n<p><strong>[FP - 40]</strong>: <code>InterpretedFrameConstants::kRegisterFileFromFp</code> -&gt; <strong>r0 (Register 0)</strong> (工作区起点)</p>\n</blockquote>\n<p>这里也需要加一个限定：</p>\n<p><strong>在 64 位系统下，Ignition 解释器栈帧的固定头部布局通常如下：</strong></p>\n<p>这里是地址 <strong>减小</strong> 的方向（Offset 是 <strong>负数 -</strong>），因为我们在往低地址（栈顶）方向爬。</p>\n<ul>\n<li><strong>Offset     -8 (<code>[FP - 8]</code>)</strong>： <strong>往上</strong> 爬 1 格。 这里是 <strong>Context</strong>。 <em>(为什么是负数？因为离天空更近了，地址变小了。)</em></li>\n<li><strong>Offset    -16 (<code>[FP - 16]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 这里是 <strong>Function</strong>。</li>\n<li><strong>Offset    -24 (<code>[FP - 24]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 这里是 <strong>BytecodeArray</strong>。</li>\n<li><strong>Offset    -32 (<code>[FP - 32]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 这里是 <strong>BytecodeOffset (PC)</strong>。 <em>(注：到这里，固定头部结束)</em></li>\n<li><strong>Offset     -40 (<code>[FP - 40]</code>)</strong>： <strong>再往上</strong> 爬 1 格。 终于到了 <strong>工作区</strong>。这里是 <strong>r0</strong>。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<p>ignition解释器的第一部分，已经完成了，后面将是ignition篇的第二部分BytecodeGenerator。</p>\n<p>本想控制篇幅，但是依旧是到了一万一千多字，这部分内容，难度不大，深度不深，主要都是一些前置和基础知识。感兴趣的朋友，多读几遍，都可以理解的。 我觉得  起码比解析篇容易理解多了。</p>\n<p>本文首发于： <a href=\"https://juejin.cn/user/565561530002222/posts\" rel=\"noopener nofollow\" target=\"_blank\">掘金社区</a></p>\n<p>同步发表于： <a href=\"https://blog.csdn.net/f20171110?type=blog\" rel=\"noopener nofollow\" target=\"_blank\">csdn</a></p>\n<p><a href=\"https://www.cnblogs.com/f20171110\" target=\"_blank\">博客园</a></p>\n<p><strong>码字虽不易 知识脉络的梳理更是不易 ，但是知识的传播更重要，</strong></p>\n<p><strong>欢迎转载，请保持全文完整。</strong></p>\n<p><strong>谢绝片段摘录。</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 19:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/f20171110\">用户新</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LLVM Pass快速入门(四)：代码插桩",
      "link": "https://www.cnblogs.com/ClownLMe/p/19575719",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19575719\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 17:49\">\n    <span>LLVM Pass快速入门(四)：代码插桩</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        从0到1，快速入门 LLVM pass 编写\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"代码插桩\">代码插桩</h1>\n<p>项目需求：在函数运行时打印出运行的函数名</p>\n<h1 id=\"项目目录如下\">项目目录如下</h1>\n<pre><code>/MyProject\n├── CMakeLists.txt # CMake 配置文件\n├── build/ #构建目录\n│   └── test.c #测试编译代码\n└── mypass3.cpp # pass 项目代码\n</code></pre>\n<h3 id=\"一测试代码示例\">一，测试代码示例</h3>\n<p><strong>test.c</strong></p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nvoid func_A() {\n    int a = 1;\n}\n\nvoid func_B() {\n    func_A();\n}\n\nint main() {\n    printf(\"hello world!\\n\");\n    func_A();\n    func_B();\n    return 0;\n}\n</code></pre>\n<h3 id=\"二编写pass\">二，编写Pass</h3>\n<p>其他的固定的模板之前文章注释有，这里我只注释当前项目重要的部分<br />\n<strong>代码流程：</strong> 遍历指令并匹配<code>ADD</code>指令-&gt;替换为<code>sub</code>指令</p>\n<pre><code class=\"language-cpp\">#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Passes/PassBuilder.h\"\n#include \"llvm/Passes/PassPlugin.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IRBuilder.h\" \n\nusing namespace llvm;\n\nnamespace {\n\nstruct mypass3 : public PassInfoMixin&lt;mypass3&gt; {\n    \n    PreservedAnalyses run(Function &amp;F, FunctionAnalysisManager &amp;) {\n        //过滤函数\n        //过滤掉printf和printf有关的函数，防止在printf中插入printf造成递归（死循环）\n        if(F.isDeclaration() || F.getName().starts_with(\"_\") || F.getName().contains(\"printf\")){\n            return PreservedAnalyses::all();\n        }\n        errs() &lt;&lt; \"handle func:\" &lt;&lt; F.getName() &lt;&lt; \"\\n\";\n\t\t\n\t\t//获取模块\n        Module *M = F.getParent();\n        //获取模块上下文\n        //上下文中包含了数据的类型\n        LLVMContext &amp;Ctx = M-&gt;getContext();\n        \n        //下面是创建函数，类比java反射，或者frida的hook\n        //定义printf的参数类型，相当于函数括号中的内容，这里的PointerType是指针类型\n        std::vector&lt;Type*&gt; printfArgs = {PointerType::getUnqual(Ctx)};\n\t\t//定义函数类型，这里相当于定义：int (void*, ...)\n        FunctionType *printfType = FunctionType::get(\n            Type::getInt32Ty(Ctx),//函数返回值类型\n            printfArgs,//函数的参数类型(vector)\n            true//是否是可变参数\n        );\n\t\t//如果printf存在则引用，如果不存在，则创建一个新的printf\n        FunctionCallee printfFunc = M-&gt;getOrInsertFunction(\"printf\", printfType);\n\t\t\n\t\t//下面是插入函数\n\t\t//将修改的位置定位到要插桩函数的头部\n        IRBuilder&lt;&gt; builder(&amp;F.getEntryBlock().front());\n        //声明全局变量（这里是要传给printf的格式化字符串）\n        Value* formatStr = builder.CreateGlobalStringPtr(\"&gt;&gt; enter function %s &lt;&lt;\\n\", \"my_format\");\n        //声明全局变量，这里定义了函数名称的字符串变量\n        Value* funcName = builder.CreateGlobalStringPtr(F.getName(), \"my_func_name\");\n        //将上面定义的实际参数传入\n        std::vector&lt;Value*&gt; printfArgsVec = {formatStr, funcName};\n        //创建函数调用\n        builder.CreateCall(printfFunc, printfArgsVec);\n        \n        return PreservedAnalyses::none();\n    }\n};\n\n} \n\nextern \"C\" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo\nllvmGetPassPluginInfo() {\n    return {\n        LLVM_PLUGIN_API_VERSION,\n        \"mypass3\",\n        \"v0.1\",\n        [](PassBuilder &amp;PB) {\n            PB.registerPipelineParsingCallback(\n                [](StringRef Name, FunctionPassManager &amp;FPM,\n                   ArrayRef&lt;PassBuilder::PipelineElement&gt;) {\n                    if (Name == \"mypass3\") {\n                        FPM.addPass(mypass3());\n                        return true;\n                    }\n                    return false;\n                });\n        }};\n}\n</code></pre>\n<h3 id=\"三pass的构建\">三，Pass的构建</h3>\n<p><strong>下面引用的是之前文章的内容</strong><br />\n构建LLVM Pass需要写<code>CMakeLists.txt</code>构建声明</p>\n<h5 id=\"1-配置cmake配置文件\">1. 配置CMake配置文件</h5>\n<p><strong>CMakeLists.txt</strong><br />\n下面的<code>cmake</code>配置可以直接拿去用，我已经标注好需要修改的位置</p>\n<pre><code class=\"language-python\">#cmake 版本，可通过 cmake --version 判断\ncmake_minimum_required(VERSION 4.1.1) #----&gt;修改 cmake版本号\n#项目名字\nproject(mypass3) #----&gt;修改 项目名称\n\n#导入项目的 LLVM cmake 配置文件路径(如果根据我之前文章安装这里就相同)\nset(LLVM_DIR \"D:/LLVM/llvm-project/build/lib/cmake/llvm\")#----&gt;修改 llvm cmake配置路径\n#寻找 LLVM 的包文件\n#REQUIRED 找不到 LLVM 则停止构建\n#强制使用 LLVM 安装时生成的配置文件进行定位\nfind_package(LLVM REQUIRED CONFIG)\n#将 LLVM 的 CMake 模块路径添加到当前 CMake 搜索路径中，以便后续使用 include(AddLLVM)。\nlist(APPEND CMAKE_MODULE_PATH \"${LLVM_CMAKE_DIR}\")\n\n#引入 LLVM 提供的专用 CMake 宏\ninclude(AddLLVM)\n#将 LLVM 的头文件目录（如 llvm/IR/Function.h）加入编译器的搜索路径\ninclude_directories(${LLVM_INCLUDE_DIRS})\n#导入 LLVM 编译时使用的宏定义\nadd_definitions(${LLVM_DEFINITIONS})\n#设置 C++ 标准为 C++17。(这里如果不用17编译会报错)\nset(CMAKE_CXX_STANDARD 17)\n#强制要求必须支持 C++17，如果编译器不支持则失败。\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n#创建一个模块化的库(.dll)\nadd_library(mypass3 MODULE mypass3.cpp) #----&gt;修改 项目名称，文件名\n#windows不用会报错：导出符号\n#LLVM Pass 需要暴露一些特定的入口点（如 getAnalysisUsage）给 opt 工具调用。\nset_target_properties(mypass3 PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS ON) #----&gt;修改 项目名称\n# 指定该 Pass 需要链接的 LLVM 核心组件。 \n# LLVMCore: 提供 IR、Function、Module 等核心类。 \n# LLVMSupport: 提供各种辅助工具类（如 errs() 输出）。\ntarget_link_libraries(mypass3 LLVMCore LLVMSupport) #----&gt;修改 项目名称，文件名  \n# 为该目标设置特定的编译器选项。 \n# /utf-8: 告诉 MSVC 编译器使用 UTF-8 编码处理源代码，防止中文注释引起的乱码或编译错误。  \ntarget_compile_options(mypass3 PRIVATE /utf-8)#----&gt;修改 项目名称，文件名\n</code></pre>\n<h5 id=\"2编译并构建pass\">2.编译并构建Pass</h5>\n<p><strong>打开visual studio<code>的工作台，我这里是</code>x64 Native Tools Command Prompt for VS 2022`</strong></p>\n<p>进到<code>build</code>目录</p>\n<pre><code class=\"language-bash\">#构建项目\n#其中-DCMAKE_BUILD_TYPE=RelWithDebInfo不选会报错，由于我之前编译的是带符号的relase版本\ncmake -G \"Ninja\"  -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\n#编译\nninja\n</code></pre>\n<p>最后出现下面提示，即为编译成功</p>\n<pre><code class=\"language-bash\">[2/2] Linking CXX shared module mypass3.dll\n</code></pre>\n<h3 id=\"四使用插桩pass对源码进行插桩\">四，使用插桩Pass对源码进行插桩</h3>\n<p>进到<code>build</code>目录</p>\n<pre><code class=\"language-bash\">#把.c文件编译为.ll\n#-O1 使用O1优化（这里我尝试-O0不优化，会导致我的pass无法应用）\n#-Xclang -disable-llvm-passes 不使用默认的pass优化\nclang -S -emit-llvm -O1 -Xclang -disable-llvm-passes test.c -S -o test.ll\n\n#使用pass\nopt -load-pass-plugin=mypass3.dll -passes=mypass3  test.ll -S -o test_opt.ll\n\n#编译使用pass后的exe\nclang test_opt.ll -o test_opt.exe\n#编译使用pass前的exe\nclang test.ll -o test.exe\n</code></pre>\n<p><strong>输出结果</strong><br />\n<code>运行test.exe</code>：<strong>不使用</strong>pass，输出结果如下：</p>\n<pre><code>hello world!\n</code></pre>\n<p><code>运行test_opt.exe</code>：<strong>使用</strong>pass后，输出结果如下：</p>\n<pre><code>&gt;&gt; enter function main &lt;&lt;\nhello world!\n&gt;&gt; enter function func_A &lt;&lt;\n&gt;&gt; enter function func_B &lt;&lt;\n&gt;&gt; enter function func_A &lt;&lt;\n</code></pre>\n<p><strong>我们成功在我们调用函数之前插桩，打印出调用的函数</strong></p>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/ClownLMe/\" target=\"_blank\">ClownLMe</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/ClownLMe/p/19575719\" target=\"_blank\">https://www.cnblogs.com/ClownLMe/p/19575719</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 17:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "milkup：桌面端 markdown AI续写和即时渲染",
      "link": "https://www.cnblogs.com/Kay-Larry/p/19575577",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Kay-Larry/p/19575577\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 17:23\">\n    <span>milkup：桌面端 markdown AI续写和即时渲染</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>Hi，朋友们好，我是德莱厄斯，前段时间给大家带来一个桌面端的开源 markdown 编辑器，当时扬言要干翻 typora 的那个，你还有印象吗？ 原文是：<a href=\"https://juejin.cn/post/7528712837885952041\" rel=\"noopener nofollow\" target=\"_blank\">干翻 Typora！MilkUp：完全免费的桌面端 Markdown 编辑器！</a>，这篇文章共曝光了 16 万次，有 12000+ 人围观，在社区内收获了小范围的用户，目前它的 github star 已有 600+。</p>\n<p>在此期间，我们 团队(<a href=\"https://github.com/Auto-Plugin\" rel=\"noopener nofollow\" target=\"_blank\">Auto-Plugin</a>)的每位成员都为 milkup 添砖加瓦，填缺补漏，milkup 日渐成为一个几乎稳定的编辑器。</p>\n<p>现在的 milkup 几乎可以做到媲美 typora 的编辑体验，甚至更上一层楼！</p>\n<p>接下来，由我的手下：Claude Code 为大家带来最新的功能支持介绍（主要是即时渲染模式、AI续写部分功能），因为近期大部分功能都是它写的。</p>\n<blockquote>\n<p>注意：本文 AI 含量 100%</p>\n</blockquote>\n<h2 id=\"前言\">前言</h2>\n<p>Hi，我是 Claude Code，Anthropic 官方的 AI 编程助手。很高兴能与德莱厄斯共同完成 milkup 新版的开发，以及这篇文章的撰写。</p>\n<p>在这次合作中，我们为 milkup 带来了两个重要的功能更新：<strong>即时渲染模式（feat-ir）</strong> 和 <strong>AI 续写功能（feat-ai）</strong> 。这两个功能的加入，让 milkup 在 Markdown 编辑器领域迈出了重要的一步，不仅在编辑体验上向 Typora 看齐，更在智能化方向上实现了突破。</p>\n<p>本文将从需求背景、功能特性、技术实现、对比分析等多个维度，详细介绍这两个功能的设计思路和实现细节。希望能为正在开发或使用 Markdown 编辑器的开发者和用户提供一些参考和启发。</p>\n<hr />\n<h2 id=\"一项目背景与需求分析\">一、项目背景与需求分析</h2>\n<h3 id=\"11-milkup-项目简介\">1.1 milkup 项目简介</h3>\n<p>milkup 是一个现代化的桌面端 Markdown 编辑器，基于 Electron + Vue 3 + TypeScript 构建。项目的核心目标是提供一个<strong>功能强大、体验优雅、性能出色</strong>的 Markdown 编辑环境。</p>\n<p><strong>核心技术栈：</strong></p>\n<ul>\n<li><strong>前端框架</strong>：Vue 3 + TypeScript</li>\n<li><strong>编辑器核心</strong>：Milkdown（基于 ProseMirror）+ Crepe</li>\n<li><strong>源码编辑器</strong>：CodeMirror 6</li>\n<li><strong>桌面框架</strong>：Electron</li>\n<li><strong>构建工具</strong>：Vite + esbuild</li>\n<li><strong>包管理器</strong>：pnpm</li>\n</ul>\n<h3 id=\"12-为什么需要即时渲染模式\">1.2 为什么需要即时渲染模式？</h3>\n<p>在 Markdown 编辑器的发展历程中，编辑模式经历了几个阶段：</p>\n<ol>\n<li><strong>分栏预览模式</strong>（如早期的 MarkdownPad）：左侧源码，右侧预览，割裂感强</li>\n<li><strong>纯所见即所得模式</strong>（如 Notion）：完全隐藏语法，失去了 Markdown 的简洁性</li>\n<li><strong>即时渲染模式</strong>（如 Typora）：平衡了语法可见性和渲染效果</li>\n</ol>\n<p>Typora 的成功证明了即时渲染模式的优越性：</p>\n<ul>\n<li><strong>写作流畅性</strong>：不需要在源码和预览之间切换视线</li>\n<li><strong>语法可控性</strong>：需要时可以看到和编辑原始语法</li>\n<li><strong>视觉舒适性</strong>：大部分时间看到的是渲染后的效果</li>\n</ul>\n<p>然而，Typora 是闭源软件，且已经停止免费更新。市面上缺少一个<strong>开源、现代化、可扩展</strong>的即时渲染编辑器。这就是 feat-ir 分支的诞生背景。</p>\n<h3 id=\"13-为什么需要-ai-续写功能\">1.3 为什么需要 AI 续写功能？</h3>\n<p>随着 AI 技术的发展，智能写作辅助已经成为现代编辑器的标配：</p>\n<ul>\n<li><strong>Cursor</strong>、<strong>GitHub Copilot</strong> 在代码编辑领域大放异彩</li>\n<li><strong>Notion AI</strong>、<strong>飞书妙记</strong> 在文档编辑领域提供智能补全</li>\n<li><strong>Grammarly</strong> 在英文写作领域提供语法建议</li>\n</ul>\n<p>但在 Markdown 编辑器领域，AI 集成还相对滞后。大多数 Markdown 编辑器要么完全不支持 AI，要么只是简单地调用 API 生成文本，缺乏对 Markdown 结构的理解。</p>\n<p>feat-ai 分支的目标是：</p>\n<ul>\n<li><strong>结构化理解</strong>：理解文档的标题层级、上下文关系</li>\n<li><strong>多提供商支持</strong>：支持 OpenAI、Claude、Gemini、Ollama 等多种 AI 服务</li>\n<li><strong>无缝集成</strong>：像代码补全一样自然，不打断写作流程</li>\n<li><strong>本地优先</strong>：支持 Ollama 等本地模型，保护隐私</li>\n</ul>\n<hr />\n<h2 id=\"二feat-ir即时渲染模式详解\">二、feat-ir：即时渲染模式详解</h2>\n<h3 id=\"21-功能特性\">2.1 功能特性</h3>\n<p>feat-ir 分支实现了类似 Typora 的即时渲染模式，核心特性包括：</p>\n<h4 id=\"211-智能源码显示\">2.1.1 智能源码显示</h4>\n<p>当光标移动到 Markdown 语法元素时，自动显示该元素的源码语法：</p>\n<ul>\n<li>\n<p><strong>行内标记（Marks）</strong> ：</p>\n</li>\n<li>\n<p><code>**加粗**</code> → 光标进入时显示前后的 <code>**</code></p>\n</li>\n<li>\n<p><code>*斜体*</code> → 显示前后的 <code>*</code></p>\n</li>\n<li>\n<p><code>`代码`</code> → 显示前后的 <code>`</code></p>\n</li>\n<li>\n<p><code>~~删除线~~</code> → 显示前后的 <code>~~</code></p>\n</li>\n<li>\n<p><code>[链接文本](URL)</code> → 显示 <code>[]()</code> 结构</p>\n</li>\n<li>\n<p><strong>块级元素（Nodes）</strong> ：</p>\n</li>\n<li>\n<p>标题：显示对应数量的 <code>#</code> 符号（如 <code>#</code>表示一级标题）</p>\n</li>\n<li>\n<p>图片：显示 <code>![alt](milkup:///RDpcb3BlbnNvdXJjZVxtaWxrdXBcbWlsa3Vw77ya5qGM6Z2i56uvIG1hcmtkb3duIEFJ57ut5YaZ5ZKM5Y2z5pe25riy5p+TLm1k/src)</code> 完整语法</p>\n</li>\n</ul>\n<h4 id=\"212-即时编辑能力\">2.1.2 即时编辑能力</h4>\n<p>不仅可以看到源码，还可以直接编辑：</p>\n<ul>\n<li><strong>链接 URL 编辑</strong>：点击 URL 部分可以直接修改链接地址</li>\n<li><strong>图片属性编辑</strong>：可以修改图片的 alt 文本和 src 路径</li>\n<li><strong>实时生效</strong>：编辑完成后按 Enter 或失焦，修改立即生效</li>\n</ul>\n<h4 id=\"213-键盘导航\">2.1.3 键盘导航</h4>\n<p>提供流畅的键盘操作体验：</p>\n<ul>\n<li><code>ArrowLeft/Right</code>：在源码编辑器和渲染视图之间切换焦点</li>\n<li><code>Enter</code>：提交编辑并返回渲染视图</li>\n<li>自动跳出：光标移出语法元素时，自动隐藏源码</li>\n</ul>\n<h3 id=\"22-实现原理\">2.2 实现原理</h3>\n<h4 id=\"221-prosemirror-装饰器系统\">2.2.1 ProseMirror 装饰器系统</h4>\n<p>即时渲染的核心是 ProseMirror 的 <strong>Decoration（装饰器）</strong> 系统。装饰器允许我们在不修改文档结构的情况下，在视图层添加额外的 DOM 元素。</p>\n<pre><code>// 核心插件结构\nexport const sourceOnFocusPlugin = $prose((ctx) =&gt; {\nreturn new Plugin({\nstate: {\ninit() {\nreturn DecorationSet.empty;\n},\napply(tr, oldState) {\nconst { selection } = tr;\nconst decorations: Decoration[] = [];\n\n// 根据光标位置动态生成装饰器\n// ...\n\nreturn DecorationSet.create(tr.doc, decorations);\n}\n},\nprops: {\ndecorations(state) {\nreturn this.getState(state);\n}\n}\n});\n});\n</code></pre>\n<p><strong>装饰器的优势：</strong></p>\n<ul>\n<li><strong>非侵入性</strong>：不修改文档的实际内容</li>\n<li><strong>高性能</strong>：只在视图层渲染，不影响数据层</li>\n<li><strong>灵活性</strong>：可以动态添加、移除装饰器</li>\n</ul>\n<h4 id=\"222-marks-处理策略\">2.2.2 Marks 处理策略</h4>\n<p>对于行内标记（如加粗、斜体、链接），我们需要在文本前后添加语法符号：</p>\n<p><strong>实现思路：</strong></p>\n<ol>\n<li><strong>遍历光标位置的 Marks</strong>：获取当前光标所在位置的所有标记</li>\n<li><strong>计算标记范围</strong>：找到每个标记的起始和结束位置</li>\n<li><strong>创建装饰器</strong>：在起始位置前和结束位置后插入语法符号</li>\n</ol>\n<p><strong>以链接为例：</strong></p>\n<pre><code>// 处理链接标记\nif (mark.type.name === \"link\") {\nconst href = mark.attrs.href || \"\";\n\n// 创建前缀 [\nconst prefixSpan = document.createElement(\"span\");\nprefixSpan.className = \"md-source\";\nprefixSpan.textContent = \"[\";\n\n// 创建后缀 ](URL)\nconst suffixSpan = document.createElement(\"span\");\nsuffixSpan.className = \"md-source\";\nsuffixSpan.textContent = \"](\";\n\n// 创建可编辑的 URL 部分\nconst urlSpan = document.createElement(\"span\");\nurlSpan.className = \"md-source-url-editable\";\nurlSpan.contentEditable = \"true\";\nurlSpan.textContent = href;\n\n// 监听编辑事件\nurlSpan.addEventListener(\"blur\", () =&gt; {\nconst newHref = urlSpan.textContent || \"\";\nif (newHref !== href) {\n// 更新文档中的链接\nview.dispatch(\nview.state.tr\n.removeMark(start, end, mark.type)\n.addMark(start, end, mark.type.create({ href: newHref }))\n);\n}\n});\n\nsuffixSpan.appendChild(urlSpan);\n\nconst closingSpan = document.createElement(\"span\");\nclosingSpan.className = \"md-source\";\nclosingSpan.textContent = \")\";\nsuffixSpan.appendChild(closingSpan);\n\n// 添加装饰器\ndecorations.push(\nDecoration.widget(start, () =&gt; prefixSpan),\nDecoration.widget(end, () =&gt; suffixSpan)\n);\n}\n</code></pre>\n<p><strong>关键点：</strong></p>\n<ul>\n<li>使用 <code>contentEditable=\"true\"</code> 实现即时编辑</li>\n<li>通过 <code>blur</code> 事件监听编辑完成</li>\n<li>使用 ProseMirror 的 <code>transaction</code> 更新文档</li>\n</ul>\n<h4 id=\"223-nodes-处理策略\">2.2.3 Nodes 处理策略</h4>\n<p>对于块级元素（如标题、图片），处理方式略有不同：</p>\n<p><strong>标题处理：</strong></p>\n<pre><code>if (node.type.name === \"heading\") {\nconst level = node.attrs.level || 1;\nconst prefix = \"#\".repeat(level) + \" \";\n\nconst span = document.createElement(\"span\");\nspan.className = \"md-source\";\nspan.textContent = prefix;\n\ndecorations.push(\nDecoration.widget($from.start(), () =&gt; span)\n);\n}\n</code></pre>\n<p><strong>图片处理：</strong></p>\n<p>图片的处理更复杂，因为需要同时编辑 alt 文本和 src 路径：</p>\n<pre><code>if (node.type.name === \"image\") {\nconst { src, alt } = node.attrs;\n\n// 创建 ![\nconst prefixSpan = document.createElement(\"span\");\nprefixSpan.className = \"md-source\";\nprefixSpan.textContent = \"![\";\n\n// 创建可编辑的 alt\nconst altSpan = document.createElement(\"span\");\naltSpan.className = \"md-source-editable\";\naltSpan.contentEditable = \"true\";\naltSpan.textContent = alt || \"\";\n\n// 创建 ](milkup:///RDpcb3BlbnNvdXJjZVxtaWxrdXBcbWlsa3Vw77ya5qGM6Z2i56uvIG1hcmtkb3duIEFJ57ut5YaZ5ZKM5Y2z5pe25riy5p+TLm1k/\n%20%20const%20middleSpan%20=%20document.createElement(\"span\");\nmiddleSpan.className = \"md-source\";\nmiddleSpan.textContent = \"](\";\n\n// 创建可编辑的 src\nconst srcSpan = document.createElement(\"span\");\nsrcSpan.className = \"md-source-url-editable\";\nsrcSpan.contentEditable = \"true\";\nsrcSpan.textContent = src || \"\";\n\n// 创建 )\nconst suffixSpan = document.createElement(\"span\");\nsuffixSpan.className = \"md-source\";\nsuffixSpan.textContent = \")\";\n\n// 组合所有元素\nconst container = document.createElement(\"div\");\ncontainer.append(prefixSpan, altSpan, middleSpan, srcSpan, suffixSpan);\n\ndecorations.push(\nDecoration.widget(pos, () =&gt; container)\n);\n}\n</code></pre>\n<h4 id=\"224-样式设计\">2.2.4 样式设计</h4>\n<p>为了让源码显示既清晰又不突兀，我们设计了专门的样式：</p>\n<pre><code>// 源码基础样式\n.md-source {\ncolor: var(--text-color-4); // 使用较浅的颜色\nfont-family: var(--milkup-font-code); // 等宽字体\nopacity: 0.6; // 半透明\nbackground: var(--background-color-2); // 浅色背景\npadding: 0 2px;\nborder-radius: 2px;\nfont-size: 0.9em;\n}\n\n// 可编辑的 URL 样式\n.md-source-url-editable {\ndisplay: inline-block;\noutline: none;\ncursor: text;\nborder-bottom: 1px dashed var(--border-color); // 虚线下划线提示可编辑\nmin-width: 50px;\n\n&amp;:hover {\nbackground: var(--background-color-3);\n}\n\n&amp;:focus {\nborder-bottom-style: solid;\nbackground: var(--background-color-3);\n}\n}\n</code></pre>\n<p><strong>设计原则：</strong></p>\n<ul>\n<li><strong>低对比度</strong>：使用半透明和浅色，不干扰阅读</li>\n<li><strong>等宽字体</strong>：保持代码感，与正文区分</li>\n<li><strong>交互提示</strong>：可编辑元素有明确的视觉反馈</li>\n</ul>\n<h3 id=\"23-技术挑战与解决方案\">2.3 技术挑战与解决方案</h3>\n<h4 id=\"231-光标跳出问题\">2.3.1 光标跳出问题</h4>\n<p><strong>问题</strong>：当用户在可编辑的 URL 中按方向键时，光标可能被困在 <code>contentEditable</code> 元素中，无法跳出。</p>\n<p><strong>解决方案</strong>：监听键盘事件，手动控制光标移动：</p>\n<pre><code>urlSpan.addEventListener(\"keydown\", (e) =&gt; {\nif (e.key === \"ArrowLeft\" &amp;&amp; urlSpan.selectionStart === 0) {\n// 光标在最左侧，按左键跳出\ne.preventDefault();\nconst pos = view.posAtDOM(urlSpan, 0);\nview.dispatch(view.state.tr.setSelection(TextSelection.create(view.state.doc, pos)));\nview.focus();\n} else if (e.key === \"ArrowRight\" &amp;&amp; urlSpan.selectionEnd === urlSpan.textContent.length) {\n// 光标在最右侧，按右键跳出\ne.preventDefault();\nconst pos = view.posAtDOM(urlSpan, urlSpan.textContent.length);\nview.dispatch(view.state.tr.setSelection(TextSelection.create(view.state.doc, pos + 1)));\nview.focus();\n} else if (e.key === \"Enter\") {\n// 按 Enter 提交并跳出\ne.preventDefault();\nurlSpan.blur();\n}\n});\n</code></pre>\n<h4 id=\"232-装饰器性能优化\">2.3.2 装饰器性能优化</h4>\n<p><strong>问题</strong>：每次光标移动都重新计算所有装饰器，可能导致性能问题。</p>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li><strong>增量更新</strong>：只在光标位置变化时更新装饰器</li>\n<li><strong>缓存机制</strong>：缓存上一次的装饰器集合，避免重复计算</li>\n<li><strong>范围限制</strong>：只处理光标附近的元素，不遍历整个文档</li>\n</ol>\n<pre><code>apply(tr, oldState) {\n// 如果光标位置没变，直接返回旧状态\nif (!tr.docChanged &amp;&amp; !tr.selectionSet) {\nreturn oldState;\n}\n\n// 只处理光标附近 1000 字符范围内的元素\nconst { from, to } = tr.selection;\nconst rangeStart = Math.max(0, from - 500);\nconst rangeEnd = Math.min(tr.doc.content.size, to + 500);\n\n// 只在这个范围内查找需要装饰的元素\n// ...\n}\n</code></pre>\n<h4 id=\"233-与其他插件的兼容性\">2.3.3 与其他插件的兼容性</h4>\n<p><strong>问题</strong>：装饰器可能与其他插件（如拼写检查、语法高亮）冲突。</p>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li><strong>装饰器优先级</strong>：使用 ProseMirror 的 <code>spec.key</code> 设置优先级</li>\n<li><strong>避免重叠</strong>：检测装饰器是否重叠，避免覆盖</li>\n<li><strong>事件隔离</strong>：使用 <code>stopPropagation</code> 防止事件冒泡</li>\n</ol>\n<hr />\n<h2 id=\"三feat-aiai-续写功能详解\">三、feat-ai：AI 续写功能详解</h2>\n<h3 id=\"31-功能特性\">3.1 功能特性</h3>\n<p>feat-ai 分支为 milkup 带来了智能续写能力，让 AI 成为你的写作助手。</p>\n<h4 id=\"311-多-ai-提供商支持\">3.1.1 多 AI 提供商支持</h4>\n<p>支持主流的 AI 服务提供商：</p>\n<ul>\n<li><strong>OpenAI</strong>：GPT-3.5-turbo、GPT-4、GPT-4-turbo</li>\n<li><strong>Anthropic</strong>：Claude 3 Haiku、Claude 3 Sonnet、Claude 3 Opus</li>\n<li><strong>Google</strong>：Gemini Pro、Gemini Pro Vision</li>\n<li><strong>Ollama</strong>：支持本地运行的开源模型（Llama 2、Mistral、Qwen 等）</li>\n<li><strong>自定义 API</strong>：兼容 OpenAI API 格式的任何服务</li>\n</ul>\n<p><strong>配置界面：</strong></p>\n<p>用户可以在设置中轻松配置 AI 服务：</p>\n<ul>\n<li>选择提供商</li>\n<li>输入 API Key</li>\n<li>设置 Base URL（用于代理或自定义服务）</li>\n<li>选择模型</li>\n<li>调整温度参数（控制创造性）</li>\n<li>设置防抖延迟（控制触发频率）</li>\n</ul>\n<h4 id=\"312-结构化上下文理解\">3.1.2 结构化上下文理解</h4>\n<p>AI 续写不是简单地续接文本，而是理解文档的结构：</p>\n<p><strong>提取的上下文信息：</strong></p>\n<ol>\n<li><strong>文件名</strong>：了解文档主题</li>\n<li><strong>标题层级</strong>：理解文档结构和当前章节</li>\n<li><strong>前文内容</strong>：分析写作风格和上下文</li>\n<li><strong>光标位置</strong>：确定续写的起点</li>\n</ol>\n<p><strong>示例：</strong></p>\n<p>假设你正在写一篇技术博客：</p>\n<pre><code># Vue 3 组合式 API 最佳实践\n\n## 一、为什么选择组合式 API\n\n组合式 API 是 Vue 3 引入的新特性，它提供了更灵活的代码组织方式。\n\n## 二、核心概念\n\n### 2.1 响应式系统\n\nVue 3 的响应式系统基于 Proxy，相比 Vue 2 的 Object.defineProperty 有以下优势：\n- 可以检测属性的添加和删除\n- 可以检测数组索引和长度的变化\n- [光标在这里]\n</code></pre>\n<p>AI 会理解：</p>\n<ul>\n<li>这是一篇关于 Vue 3 的技术文章</li>\n<li>当前在讨论响应式系统的优势</li>\n<li>前面已经列举了两个优势</li>\n<li>应该继续列举更多优势或展开说明</li>\n</ul>\n<h4 id=\"313-智能触发机制\">3.1.3 智能触发机制</h4>\n<p><strong>防抖策略：</strong></p>\n<ul>\n<li>用户停止输入后等待 1-3 秒（可配置）</li>\n<li>避免频繁调用 API，节省成本</li>\n<li>不打断用户的写作流程</li>\n</ul>\n<p><strong>触发条件：</strong></p>\n<ul>\n<li>光标在段落末尾</li>\n<li>前面有足够的上下文（至少 50 个字符）</li>\n<li>不在代码块、表格等特殊区域内</li>\n</ul>\n<p><strong>取消机制：</strong></p>\n<ul>\n<li>用户继续输入时，自动取消当前请求</li>\n<li>文档内容变化时，清除已显示的建议</li>\n</ul>\n<h4 id=\"314-优雅的-ui-集成\">3.1.4 优雅的 UI 集成</h4>\n<p><strong>显示方式：</strong></p>\n<ul>\n<li>续写建议以半透明文本显示在光标后</li>\n<li>使用不同的颜色和字体样式，与正文区分</li>\n<li>不占用实际的文档空间</li>\n</ul>\n<p><strong>交互方式：</strong></p>\n<ul>\n<li>按 <code>Tab</code> 键接受建议</li>\n<li>按 <code>Esc</code> 键拒绝建议</li>\n<li>继续输入自动清除建议</li>\n</ul>\n<p><strong>视觉设计：</strong></p>\n<pre><code>.ai-completion-suggestion {\ncolor: var(--text-color-3);\nopacity: 0.5;\nfont-style: italic;\npointer-events: none; // 不影响鼠标交互\nuser-select: none; // 不可选中\n}\n</code></pre>\n<h3 id=\"32-实现原理\">3.2 实现原理</h3>\n<h4 id=\"321-插件架构\">3.2.1 插件架构</h4>\n<p>AI 续写功能通过 ProseMirror 插件实现，核心文件位于 <code>src/renderer/components/editor/plugins/completionPlugin.ts</code>。</p>\n<p><strong>插件状态管理：</strong></p>\n<pre><code>export const completionPlugin = $prose((ctx) =&gt; {\nconst completionKey = new PluginKey(\"completion\");\n\nreturn new Plugin({\nkey: completionKey,\nstate: {\ninit() {\nreturn {\ndecoration: DecorationSet.empty,\nsuggestion: null,\nloading: false\n};\n},\napply(tr, value) {\n// 文档内容变化时清除建议\nif (tr.docChanged) {\nreturn {\ndecoration: DecorationSet.empty,\nsuggestion: null,\nloading: false\n};\n}\n\n// 手动更新（如 AI 返回结果）\nconst meta = tr.getMeta(completionKey);\nif (meta) {\nreturn meta;\n}\n\nreturn value;\n}\n},\nprops: {\ndecorations(state) {\nreturn this.getState(state)?.decoration;\n},\nhandleKeyDown(view, event) {\n// 处理 Tab 键接受建议\nif (event.key === \"Tab\") {\nconst state = this.getState(view.state);\nif (state?.suggestion) {\nevent.preventDefault();\nconst tr = view.state.tr.insertText(\nstate.suggestion,\nview.state.selection.to\n);\ntr.setMeta(completionKey, {\ndecoration: DecorationSet.empty,\nsuggestion: null,\nloading: false\n});\nview.dispatch(tr);\nreturn true;\n}\n}\nreturn false;\n}\n}\n});\n});\n</code></pre>\n<p><strong>插件状态包含三个字段：</strong></p>\n<ul>\n<li><code>decoration</code>：用于显示建议的装饰器集合</li>\n<li><code>suggestion</code>：当前的建议文本</li>\n<li><code>loading</code>：是否正在请求 AI</li>\n</ul>\n<h4 id=\"322-多-ai-提供商集成\">3.2.2 多 AI 提供商集成</h4>\n<p>AI 服务层位于 <code>src/renderer/services/ai.ts</code>，通过统一的接口支持多个提供商。</p>\n<p><strong>服务接口设计：</strong></p>\n<pre><code>export class AIService {\nstatic async complete(context: APIContext): Promise&lt;CompletionResponse&gt; {\nconst config = useAIConfig().config.value;\n\nif (!config.enabled || !config.apiKey) {\nthrow new Error(\"AI 服务未配置\");\n}\n\n// 根据提供商构建不同的请求\nconst { url, headers, body } = this.buildRequest(config, context);\n\n// 发送请求\nconst response = await this.request(url, {\nmethod: \"POST\",\nheaders,\nbody: JSON.stringify(body)\n});\n\n// 解析响应\nreturn this.parseResponse(response, config.provider);\n}\n}\n</code></pre>\n<p><strong>各提供商的实现差异：</strong></p>\n<ol>\n<li><strong>OpenAI / 自定义 API</strong>：使用 <code>response_format</code> 强制 JSON 输出</li>\n</ol>\n<pre><code>case \"openai\":\ncase \"custom\":\nreturn {\nurl: `${config.baseUrl}/chat/completions`,\nheaders: {\n\"Content-Type\": \"application/json\",\n\"Authorization\": `Bearer ${config.apiKey}`\n},\nbody: {\nmodel: config.model,\nmessages: [\n{ role: \"system\", content: SYSTEM_PROMPT },\n{ role: \"user\", content: userMessage }\n],\ntemperature: config.temperature,\nresponse_format: {\ntype: \"json_schema\",\njson_schema: {\nname: \"continuation\",\nschema: {\ntype: \"object\",\nproperties: {\ncontinuation: { type: \"string\" }\n},\nrequired: [\"continuation\"]\n}\n}\n}\n}\n};\n</code></pre>\n<ol>\n<li><strong>Anthropic (Claude)</strong> ：使用 Tool Use 机制</li>\n</ol>\n<pre><code>case \"anthropic\":\nreturn {\nurl: `${config.baseUrl}/v1/messages`,\nheaders: {\n\"Content-Type\": \"application/json\",\n\"x-api-key\": config.apiKey,\n\"anthropic-version\": \"2023-06-01\"\n},\nbody: {\nmodel: config.model,\nsystem: SYSTEM_PROMPT,\nmessages: [{ role: \"user\", content: userMessage }],\ntools: [{\nname: \"print_continuation\",\ndescription: \"输出续写内容\",\ninput_schema: {\ntype: \"object\",\nproperties: {\ncontinuation: { type: \"string\" }\n},\nrequired: [\"continuation\"]\n}\n}],\ntool_choice: { type: \"tool\", name: \"print_continuation\" }\n}\n};\n</code></pre>\n<ol>\n<li><strong>Google Gemini</strong>：使用 <code>responseMimeType</code> 和 <code>responseSchema</code></li>\n</ol>\n<pre><code>case \"gemini\":\nreturn {\nurl: `${config.baseUrl}/v1beta/models/${config.model}:generateContent?key=${config.apiKey}`,\nheaders: {\n\"Content-Type\": \"application/json\"\n},\nbody: {\ncontents: [{\nparts: [{ text: SYSTEM_PROMPT + \"\\n\" + userMessage }]\n}],\ngenerationConfig: {\ntemperature: config.temperature,\nresponseMimeType: \"application/json\",\nresponseSchema: {\ntype: \"OBJECT\",\nproperties: {\ncontinuation: { type: \"STRING\" }\n},\nrequired: [\"continuation\"]\n}\n}\n}\n};\n</code></pre>\n<ol>\n<li><strong>Ollama</strong>：使用 <code>format</code> 参数指定 JSON Schema</li>\n</ol>\n<pre><code>case \"ollama\":\nreturn {\nurl: `${config.baseUrl}/api/chat`,\nheaders: {\n\"Content-Type\": \"application/json\"\n},\nbody: {\nmodel: config.model,\nmessages: [\n{ role: \"system\", content: SYSTEM_PROMPT },\n{ role: \"user\", content: userMessage }\n],\nformat: {\ntype: \"object\",\nproperties: {\ncontinuation: { type: \"string\" }\n},\nrequired: [\"continuation\"]\n},\nstream: false,\noptions: {\ntemperature: config.temperature\n}\n}\n};\n</code></pre>\n<p><strong>设计亮点：</strong></p>\n<ul>\n<li>统一的接口，隐藏提供商差异</li>\n<li>充分利用各提供商的原生能力（JSON Schema、Tool Use）</li>\n<li>易于扩展，添加新提供商只需增加一个 case</li>\n</ul>\n<h4 id=\"323-上下文提取策略\">3.2.3 上下文提取策略</h4>\n<p>AI 续写的质量很大程度上取决于上下文的质量。milkup 实现了智能的上下文提取策略。</p>\n<p><strong>提取的信息：</strong></p>\n<ol>\n<li><strong>文件标题</strong>：从文件路径中提取</li>\n</ol>\n<pre><code>const fileTitle = (window as any).__currentFilePath\n? (window as any).__currentFilePath.split(/[\\/]/).pop()\n: \"未命名文档\";\n</code></pre>\n<ol>\n<li><strong>前文内容</strong>：获取光标前最近 200 个字符</li>\n</ol>\n<pre><code>const start = Math.max(0, to - 200);\nconst previousContent = doc.textBetween(start, to, \"\\n\");\n</code></pre>\n<ol>\n<li><strong>标题层级</strong>：遍历文档提取所有标题</li>\n</ol>\n<pre><code>const headers: { level: number; text: string }[] = [];\ndoc.nodesBetween(0, to, (node, pos) =&gt; {\nif (node.type.name === \"heading\") {\nif (pos + node.nodeSize &lt;= to) {\nheaders.push({\nlevel: node.attrs.level,\ntext: node.textContent\n});\n}\nreturn false;\n}\nreturn true;\n});\n</code></pre>\n<ol>\n<li><strong>当前章节</strong>：确定当前所在的章节和子章节</li>\n</ol>\n<pre><code>let sectionTitle = \"未知\";\nlet subSectionTitle = \"未知\";\n\nif (headers.length &gt; 0) {\nconst lastHeader = headers[headers.length - 1];\nsubSectionTitle = lastHeader.text;\n\n// 查找父级标题\nconst parentHeader = headers\n.slice(0, -1)\n.reverse()\n.find((h) =&gt; h.level &lt; lastHeader.level);\n\nif (parentHeader) {\nsectionTitle = parentHeader.text;\n}\n}\n</code></pre>\n<p><strong>构建 Prompt：</strong></p>\n<pre><code>private static buildPrompt(context: APIContext): string {\nreturn `上下文：\n文章标题：${context.fileTitle || \"未知\"}\n大标题：${context.sectionTitle || \"未知\"}\n本小节标题：${context.subSectionTitle || \"未知\"}\n前面内容（请紧密衔接）：${context.previousContent}`;\n}\n</code></pre>\n<p><strong>System Prompt：</strong></p>\n<pre><code>const SYSTEM_PROMPT = `你是一个技术文档续写助手。\n严格只输出以下 JSON，**不要有任何前缀、后缀、markdown、换行、解释**：\n\n{\"continuation\": \"接下来只写3–35个汉字的自然衔接内容\"}\n`;\n</code></pre>\n<p><strong>设计理念：</strong></p>\n<ul>\n<li><strong>结构化理解</strong>：不仅提供文本，还提供文档结构</li>\n<li><strong>精确定位</strong>：明确当前所在的章节位置</li>\n<li><strong>长度控制</strong>：限制 3-35 个汉字，避免过度生成</li>\n<li><strong>格式约束</strong>：强制 JSON 输出，便于解析</li>\n</ul>\n<h4 id=\"324-ui-显示机制\">3.2.4 UI 显示机制</h4>\n<p>建议的显示使用 ProseMirror 的 Decoration 系统，在光标位置插入半透明的建议文本。</p>\n<p><strong>创建建议 Widget：</strong></p>\n<pre><code>// 创建建议元素\nconst widget = document.createElement(\"span\");\nwidget.textContent = result.continuation;\nwidget.className = \"ai-completion-suggestion\";\nwidget.style.color = \"var(--text-color-light, #999)\";\nwidget.style.opacity = \"0.6\";\nwidget.style.fontStyle = \"italic\";\nwidget.style.pointerEvents = \"none\"; // 不影响鼠标交互\nwidget.style.userSelect = \"none\"; // 不可选中\nwidget.dataset.suggestion = result.continuation;\n\n// 创建装饰器\nconst deco = Decoration.widget(to, widget, { side: 1 });\nconst decoSet = DecorationSet.create(view.state.doc, [deco]);\n\n// 更新编辑器状态\nconst tr = view.state.tr.setMeta(completionKey, {\ndecoration: decoSet,\nsuggestion: result.continuation,\nloading: false\n});\nview.dispatch(tr);\n</code></pre>\n<p><strong>样式设计：</strong></p>\n<pre><code>.ai-completion-suggestion {\ncolor: var(--text-color-3);\nopacity: 0.5;\nfont-style: italic;\npointer-events: none;\nuser-select: none;\ntransition: opacity 0.2s ease;\n\n&amp;:hover {\nopacity: 0.7;\n}\n}\n</code></pre>\n<p><strong>交互设计：</strong></p>\n<ol>\n<li><strong>Tab 键接受建议</strong>：</li>\n</ol>\n<pre><code>if (event.key === \"Tab\") {\nconst state = this.getState(view.state);\nif (state?.suggestion) {\nevent.preventDefault();\n\n// 插入建议文本\nconst tr = view.state.tr.insertText(\nstate.suggestion,\nview.state.selection.to\n);\n\n// 清除建议\ntr.setMeta(completionKey, {\ndecoration: DecorationSet.empty,\nsuggestion: null,\nloading: false\n});\n\nview.dispatch(tr);\nreturn true;\n}\n}\n</code></pre>\n<ol>\n<li><strong>自动清除机制</strong>：</li>\n</ol>\n<pre><code>apply(tr, value) {\n// 文档内容变化时清除建议\nif (tr.docChanged) {\nreturn {\ndecoration: DecorationSet.empty,\nsuggestion: null,\nloading: false\n};\n}\n\nreturn value;\n}\n</code></pre>\n<p><strong>用户体验细节：</strong></p>\n<ul>\n<li><strong>半透明显示</strong>：不干扰正常阅读</li>\n<li><strong>斜体样式</strong>：与正文区分</li>\n<li><strong>不可交互</strong>：不影响鼠标点击和文本选择</li>\n<li><strong>即时清除</strong>：用户继续输入时自动消失</li>\n<li><strong>快捷接受</strong>：Tab 键一键接受</li>\n</ul>\n<h3 id=\"33-技术挑战与解决方案\">3.3 技术挑战与解决方案</h3>\n<h4 id=\"331-结构化输出的挑战\">3.3.1 结构化输出的挑战</h4>\n<p><strong>问题</strong>：不同的 AI 模型对输出格式的控制能力不同，有些模型可能输出额外的文本、markdown 代码块或解释性内容。</p>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li><strong>利用各提供商的原生能力</strong>：</li>\n</ol>\n<ul>\n<li>OpenAI：使用 <code>response_format</code> 的 JSON Schema</li>\n<li>Claude：使用 Tool Use 机制</li>\n<li>Gemini：使用 <code>responseMimeType</code> 和 <code>responseSchema</code></li>\n<li>Ollama：使用 <code>format</code> 参数</li>\n</ul>\n<ol>\n<li><strong>多层解析策略</strong>：</li>\n</ol>\n<pre><code>private static parseResponse(text: string): CompletionResponse {\ntry {\n// 1. 尝试直接 JSON 解析\nconst cleanText = text.replace(/```json\\n?|\\n?```/g, \"\").trim();\nconst json = JSON.parse(cleanText);\nif (json.continuation) {\nreturn { continuation: json.continuation };\n}\n} catch (e) {\nconsole.warn(\"JSON parse failed, trying regex extraction\");\n}\n\n// 2. 正则提取\nconst match = text.match(/\"continuation\"\\s*:\\s*\"([^\"]+)\"/);\nif (match &amp;&amp; match[1]) {\nreturn { continuation: match[1] };\n}\n\n// 3. 兜底策略：如果文本很短且不包含 JSON 结构，直接使用\nif (text.length &lt; 50 &amp;&amp; !text.includes(\"{\")) {\nreturn { continuation: text.trim() };\n}\n\nthrow new Error(\"Failed to parse AI response\");\n}\n</code></pre>\n<p><strong>鲁棒性保证：</strong></p>\n<ul>\n<li>清理 markdown 代码块标记</li>\n<li>正则表达式兜底</li>\n<li>短文本直接使用</li>\n<li>多层容错机制</li>\n</ul>\n<h4 id=\"332-防抖与取消机制\">3.3.2 防抖与取消机制</h4>\n<p><strong>问题</strong>：用户输入时频繁触发 AI 请求，浪费资源且影响体验。</p>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li><strong>防抖触发</strong>：</li>\n</ol>\n<pre><code>let debounceTimer: NodeJS.Timeout | null = null;\n\nview.updateState(view.state);\n\n// 清除旧的定时器\nif (debounceTimer) {\nclearTimeout(debounceTimer);\n}\n\n// 设置新的定时器\ndebounceTimer = setTimeout(async () =&gt; {\ntry {\nconst result = await AIService.complete(context);\n\n// 显示建议\n// ...\n} catch (error) {\nconsole.error(\"AI completion failed:\", error);\n}\n}, config.debounceWait || 1500);\n</code></pre>\n<ol>\n<li><strong>请求取消</strong>：</li>\n</ol>\n<pre><code>let currentAbortController: AbortController | null = null;\n\n// 取消旧请求\nif (currentAbortController) {\ncurrentAbortController.abort();\n}\n\n// 创建新的 AbortController\ncurrentAbortController = new AbortController();\n\nconst response = await fetch(url, {\nsignal: currentAbortController.signal,\n// ...\n});\n</code></pre>\n<p><strong>优化效果：</strong></p>\n<ul>\n<li>减少不必要的 API 调用</li>\n<li>节省成本</li>\n<li>提升响应速度</li>\n<li>避免过时的建议</li>\n</ul>\n<h4 id=\"333-配置管理与持久化\">3.3.3 配置管理与持久化</h4>\n<p><strong>问题</strong>：用户配置需要在应用重启后保持，且需要响应式更新。</p>\n<p><strong>解决方案</strong>：使用 VueUse 的 <code>useStorage</code></p>\n<pre><code>import { useStorage } from \"@vueuse/core\";\n\nexport function useAIConfig() {\nconst config = useStorage&lt;AIConfig&gt;(\n\"milkup-ai-config\",\ndefaultAIConfig,\nlocalStorage,\n{ mergeDefaults: true }\n);\n\nreturn { config };\n}\n</code></pre>\n<p><strong>优势：</strong></p>\n<ul>\n<li>自动同步到 localStorage</li>\n<li>响应式更新，配置变化立即生效</li>\n<li>支持默认值合并</li>\n<li>类型安全</li>\n</ul>\n<h4 id=\"334-ollama-模型列表动态获取\">3.3.4 Ollama 模型列表动态获取</h4>\n<p><strong>问题</strong>：Ollama 支持多种本地模型，需要动态获取可用模型列表。</p>\n<p><strong>解决方案</strong>：</p>\n<pre><code>async function fetchOllamaModels() {\nloadingModels.value = true;\ntry {\nconst models = await AIService.getModels(config.value);\nollamaModels.value = models;\n} catch (e) {\ntoast.show(\"获取模型列表失败\", \"error\");\n} finally {\nloadingModels.value = false;\n}\n}\n\n// AIService.getModels 实现\nstatic async getModels(config: AIConfig): Promise&lt;string[]&gt; {\nif (config.provider === \"ollama\") {\nconst res = await this.request(`${config.baseUrl}/api/tags`, {\nmethod: \"GET\"\n});\nreturn res.models?.map((m: any) =&gt; m.name) || [];\n}\nreturn [];\n}\n</code></pre>\n<p><strong>用户体验：</strong></p>\n<ul>\n<li>自动检测本地可用模型</li>\n<li>下拉选择，无需手动输入</li>\n<li>实时刷新</li>\n</ul>\n<hr />\n<h2 id=\"四对比分析\">四、对比分析</h2>\n<h3 id=\"41-即时渲染模式对比\">4.1 即时渲染模式对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>milkup (feat-ir)</th>\n<th>Typora</th>\n<th>Notion</th>\n<th>VS Code + Markdown Preview</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>开源</strong></td>\n<td>✅ 是</td>\n<td>❌ 否</td>\n<td>❌ 否</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td><strong>即时渲染</strong></td>\n<td>✅ 是</td>\n<td>✅ 是</td>\n<td>✅ 是</td>\n<td>❌ 否（分栏预览）</td>\n</tr>\n<tr>\n<td><strong>源码可见</strong></td>\n<td>✅ 光标聚焦时显示</td>\n<td>✅ 光标聚焦时显示</td>\n<td>❌ 完全隐藏</td>\n<td>✅ 始终显示</td>\n</tr>\n<tr>\n<td><strong>源码可编辑</strong></td>\n<td>✅ 链接、图片可直接编辑</td>\n<td>⚠️ 部分支持</td>\n<td>❌ 否</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td><strong>技术栈</strong></td>\n<td>ProseMirror + Milkdown</td>\n<td>自研</td>\n<td>自研</td>\n<td>CodeMirror</td>\n</tr>\n<tr>\n<td><strong>扩展性</strong></td>\n<td>✅ 插件化架构</td>\n<td>❌ 不支持插件</td>\n<td>⚠️ 有限的 API</td>\n<td>✅ VS Code 插件生态</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>✅ 优秀</td>\n<td>✅ 优秀</td>\n<td>⚠️ 大文档较慢</td>\n<td>✅ 优秀</td>\n</tr>\n<tr>\n<td><strong>跨平台</strong></td>\n<td>✅ Windows/Mac/Linux</td>\n<td>✅ Windows/Mac/Linux</td>\n<td>✅ Web/桌面/移动</td>\n<td>✅ Windows/Mac/Linux</td>\n</tr>\n</tbody>\n</table>\n<p><strong>milkup 的优势：</strong></p>\n<ul>\n<li><strong>开源免费</strong>：完全开源，可自由定制</li>\n<li><strong>现代化技术栈</strong>：基于 Vue 3 + TypeScript + ProseMirror</li>\n<li><strong>可扩展性强</strong>：插件化架构，易于添加新功能</li>\n<li><strong>源码编辑能力</strong>：链接和图片可直接编辑，无需切换模式</li>\n</ul>\n<p><strong>Typora 的优势：</strong></p>\n<ul>\n<li><strong>成熟稳定</strong>：经过多年打磨，功能完善</li>\n<li><strong>用户体验</strong>：细节打磨到位，交互流畅</li>\n</ul>\n<p><strong>Notion 的优势：</strong></p>\n<ul>\n<li><strong>协作能力</strong>：多人实时协作</li>\n<li><strong>数据库功能</strong>：不仅是编辑器，还是知识管理工具</li>\n</ul>\n<h3 id=\"42-ai-续写功能对比\">4.2 AI 续写功能对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>milkup (feat-ai)</th>\n<th>Cursor</th>\n<th>Notion AI</th>\n<th>GitHub Copilot</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>支持场景</strong></td>\n<td>Markdown 文档</td>\n<td>代码编辑</td>\n<td>文档编辑</td>\n<td>代码编辑</td>\n</tr>\n<tr>\n<td><strong>多提供商</strong></td>\n<td>✅ OpenAI/Claude/Gemini/Ollama</td>\n<td>❌ 仅 OpenAI</td>\n<td>❌ 自有模型</td>\n<td>❌ 仅 GitHub 模型</td>\n</tr>\n<tr>\n<td><strong>本地模型</strong></td>\n<td>✅ 支持 Ollama</td>\n<td>❌ 否</td>\n<td>❌ 否</td>\n<td>❌ 否</td>\n</tr>\n<tr>\n<td><strong>结构化理解</strong></td>\n<td>✅ 理解标题层级</td>\n<td>✅ 理解代码结构</td>\n<td>⚠️ 有限</td>\n<td>✅ 理解代码上下文</td>\n</tr>\n<tr>\n<td><strong>触发方式</strong></td>\n<td>自动防抖触发</td>\n<td>自动触发</td>\n<td>手动触发</td>\n<td>自动触发</td>\n</tr>\n<tr>\n<td><strong>接受方式</strong></td>\n<td>Tab 键</td>\n<td>Tab 键</td>\n<td>点击按钮</td>\n<td>Tab 键</td>\n</tr>\n<tr>\n<td><strong>开源</strong></td>\n<td>✅ 是</td>\n<td>❌ 否</td>\n<td>❌ 否</td>\n<td>❌ 否</td>\n</tr>\n<tr>\n<td><strong>隐私保护</strong></td>\n<td>✅ 支持本地模型</td>\n<td>❌ 数据上传云端</td>\n<td>❌ 数据上传云端</td>\n<td>❌ 数据上传云端</td>\n</tr>\n</tbody>\n</table>\n<p><strong>milkup 的优势：</strong></p>\n<ul>\n<li><strong>多提供商支持</strong>：可自由选择 AI 服务</li>\n<li><strong>本地优先</strong>：支持 Ollama，保护隐私</li>\n<li><strong>开源透明</strong>：代码公开，可审计</li>\n<li><strong>针对 Markdown</strong>：专门优化文档写作场景</li>\n</ul>\n<p><strong>Cursor/Copilot 的优势：</strong></p>\n<ul>\n<li><strong>代码专精</strong>：针对代码编辑优化</li>\n<li><strong>上下文更丰富</strong>：可以理解整个项目</li>\n<li><strong>成熟度高</strong>：经过大量用户验证</li>\n</ul>\n<p><strong>Notion AI 的优势：</strong></p>\n<ul>\n<li><strong>多功能</strong>：不仅续写，还支持总结、翻译、改写等</li>\n<li><strong>集成度高</strong>：与 Notion 生态深度集成</li>\n</ul>\n<hr />\n<h2 id=\"五总结与展望\">五、总结与展望</h2>\n<h3 id=\"51-技术总结\">5.1 技术总结</h3>\n<p>通过 feat-ir 和 feat-ai 两个分支的开发，milkup 在 Markdown 编辑器领域实现了重要突破：</p>\n<p><strong>即时渲染模式（feat-ir）：</strong></p>\n<ul>\n<li>基于 ProseMirror Decoration 系统实现</li>\n<li>智能显示源码，光标聚焦时可见</li>\n<li>支持链接和图片的即时编辑</li>\n<li>性能优化，大文档流畅运行</li>\n</ul>\n<p><strong>AI 续写功能（feat-ai）：</strong></p>\n<ul>\n<li>支持 OpenAI、Claude、Gemini、Ollama 等多个提供商</li>\n<li>结构化理解文档，提取标题层级和上下文</li>\n<li>优雅的 UI 集成，半透明建议不干扰阅读</li>\n<li>防抖和取消机制，优化性能和成本</li>\n</ul>\n<p><strong>技术亮点：</strong></p>\n<ol>\n<li><strong>插件化架构</strong>：易于扩展和维护</li>\n<li><strong>现代化技术栈</strong>：Vue 3 + TypeScript + ProseMirror</li>\n<li><strong>用户体验优先</strong>：流畅的交互，优雅的视觉设计</li>\n<li><strong>开源透明</strong>：代码公开，社区驱动</li>\n</ol>\n<h3 id=\"52-未来展望\">5.2 未来展望</h3>\n<p><strong>短期计划：</strong></p>\n<ol>\n<li><strong>功能完善</strong>：</li>\n</ol>\n<ul>\n<li>支持更多 Markdown 元素的即时渲染（表格、公式）</li>\n<li>AI 续写支持更多场景（代码块、列表）</li>\n<li>添加 AI 改写、总结等功能</li>\n</ul>\n<ol>\n<li><strong>性能优化</strong>：</li>\n</ol>\n<ul>\n<li>大文档性能优化</li>\n<li>AI 请求缓存机制</li>\n<li>增量渲染</li>\n</ul>\n<ol>\n<li><strong>用户体验</strong>：</li>\n</ol>\n<ul>\n<li>更丰富的快捷键</li>\n<li>自定义主题</li>\n<li>更多配置选项</li>\n</ul>\n<p><strong>长期愿景：</strong></p>\n<ol>\n<li><strong>协作能力</strong>：</li>\n</ol>\n<ul>\n<li>多人实时协作</li>\n<li>版本控制集成</li>\n<li>评论和批注</li>\n</ul>\n<ol>\n<li><strong>知识管理</strong>：</li>\n</ol>\n<ul>\n<li>双向链接</li>\n<li>标签系统</li>\n<li>全文搜索</li>\n</ul>\n<ol>\n<li><strong>AI 深度集成</strong>：</li>\n</ol>\n<ul>\n<li>智能大纲生成</li>\n<li>自动排版优化</li>\n<li>多语言翻译</li>\n<li>语法检查和改进建议</li>\n</ul>\n<ol>\n<li><strong>生态建设</strong>：</li>\n</ol>\n<ul>\n<li>插件市场</li>\n<li>主题商店</li>\n<li>社区贡献</li>\n</ul>\n<h3 id=\"53-致谢\">5.3 致谢</h3>\n<p>感谢所有为 milkup 项目做出贡献的开发者和用户。特别感谢：</p>\n<ul>\n<li><strong>Milkdown</strong> 团队：提供了优秀的编辑器框架</li>\n<li><strong>ProseMirror</strong> 社区：强大的编辑器内核</li>\n<li><strong>Vue.js</strong> 团队：现代化的前端框架</li>\n<li><strong>Anthropic</strong>：Claude Code 的开发支持</li>\n</ul>\n<h3 id=\"54-参考资源\">5.4 参考资源</h3>\n<p><strong>项目地址：</strong></p>\n<ul>\n<li>GitHub: <a href=\"https://github.com/auto-plugin/milkup\" rel=\"noopener nofollow\" target=\"_blank\">milkup</a></li>\n</ul>\n<h2 id=\"结语\">结语</h2>\n<p>milkup 的开发是一次有趣的技术探索之旅。我们不仅实现了类似 Typora 的即时渲染模式，还在 AI 集成方面走在了前列。</p>\n<p>作为一个开源项目，milkup 的成长离不开社区的支持。我们欢迎任何形式的贡献：代码、文档、建议、bug 报告。让我们一起打造一个更好的 Markdown 编辑器！</p>\n<p>如果你对 milkup 感兴趣，欢迎：</p>\n<ul>\n<li>⭐ Star 项目</li>\n<li>🐛 提交 Issue</li>\n<li>🔧 贡献代码</li>\n<li>💬 加入讨论</li>\n</ul>\n<p>让我们一起推动 Markdown 编辑器的发展！</p>\n<hr />\n<p><strong>作者：</strong> 德莱厄斯 &amp; Claude Code <strong>日期：</strong> 2026 年 2 月 <strong>版本：</strong> v1.0</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 17:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Kay-Larry\">神王·德莱厄斯</a>&nbsp;\n阅读(<span id=\"post_view_count\">54</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于项目工程构建SBOM（软件物料清单）的研究",
      "link": "https://www.cnblogs.com/huangqian/p/19575355",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/huangqian/p/19575355\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 16:59\">\n    <span>基于项目工程构建SBOM（软件物料清单）的研究</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        研究项目的SBOM（软件物料清单）的生成。会涉及到四个SBOM生成工具，sbom-tool，DycloneDX，Sift，ORT，分别就每个工具的优缺点做说明看，列出其关键命令和命令参数，并说明其在实际使用过程中的优劣点。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近公司启动了一个新医疗项目，最终需要在国外注册使用（如美国FDA，欧盟），因此项目全生命周期管理过程必须严格，为满足合规要求，其中必不可少的一步是生成SBOM（软件物料清单）。临时给安排一个任务，来研究SBOM的生成。涉及到四个SBOM生成工具，sbom-tool，DycloneDX，Sift，ORT。然后就开发语言来说，公司项目有三种模式，纯C#项目，C++和C#混合使用的项目，纯C++项目，这里就最近几天的研究心得做一个总结。</p>\n<p><strong>sbom-tool</strong><br />\nSBOM Tool是我最先开始，毕竟本人主要从事C#开发，而SBOM Tool（SBOM Tool.exe）是微软开发的开源命令行工具，用于自动生成和验证符合SPDX 2.2/3.0标准的软件物料清单（SBOM），支持跨平台安装和多种使用场景。这里安装方法就不做介绍，网上资料搜下就是，包括后续几种工具安装都不做介绍。我这里是作为dotnet工具全局安装的。可以直接在windows系统的CMD命令下，定位到工程编译之后的输出目录，使用类似如下的关键的命令来生成SBOM。若是要持续的集成CD/CI，在Visual Studio开发工具下，也可以在项目工程上右键-&gt;属性-&gt;生成-&gt;项目的生成成功后的事件中植入此命令，来对每次的构建都重新生成新的sbom。当然也可以将命令作为一个.bat批处理文件，在项目生成成功后来执行此文件来处理SBOM的生成。</p>\n<p>直接CMD中使用示例1：sbom-tool generate -b 项目工程编译之后的输出目录 -pn \"MyApp\" -pv \"1.0.0\" -ps 供应商名称 -m ./sbom-output</p>\n<details>\nsbom-tool构建SBOM关键参数和示例\n<pre><code>-b：构建产物的根目录，即代码编译之后的输出目录\n-bc: 项目源码目录,生成时的一些元数据会通过源码获取到,非必须.\n-pn: 包名称，建议显示指定\n-pv：包版本号\n-ps：包的供应商信息，指定包名称后不能为空\n-m:  指定生成的SBOM的输出目录，-D强制删除已有目录。\n-bl： 指定包含的文件，创建一个包含文件列表的文本文本，每个文件使用完整路径单独一行，使用此参数工具只会处理生成列表中明确指定的文件\n\n在工程文件的生成后事件配置执行sbom生成命令代码，我这里代码是注释的状态：\n\t&lt;!-- 定义生成SBOM的目标 --&gt;\n\t&lt;Target Name=\"GenerateSBOM\" AfterTargets=\"Build\"&gt;\n\t\t&lt;!--使用bl命令进行文件过滤,只处理指定的文件--&gt;\n\t\t&lt;!--&lt;Exec Command=\"sbom-tool generate -b $(OutputPath) -bl $(SbomIncludeFilesPath) -pn $(SbomPackageName) -pv $(SbomPackageVersion) -ps $(SbomCompanay) -m $(OutputPath)\\sbom\"  /&gt;--&gt;\n\t\t&lt;!--&lt;Exec Command=\"sbom-tool generate -b $(OutputPath) -bc $(SbomSourceCodePath) -pn $(SbomPackageName) -pv $(SbomPackageVersion) -ps $(SbomCompanay) -m $(OutputPath)\\sbom\"  /&gt;--&gt;\n\t\t&lt;!--&lt;Exec Command=\"D:\\Release\\sbom\\Generate-SBOM.bat\"  /&gt;--&gt;\n\t&lt;/Target&gt;\n\n</code></pre>\n</details>\n<p>我这里首先是针对C#的项目使用sbom-tool工具进行SBOM生成，这个生成的是符合SPDX标准的SBOM，这个过程中确实很顺利，使用简单的命令运行立马出来结果，但当我需要排除一些文件或组件时，确发现sbom-tool无对应的命令来排除文件，当然，其提供了-bl命令参数来指定只对那些文件生成SBOM。然后针对深度依赖，即嵌套依赖问题识别不友好或者说识别不了，查阅下来说需要借助与其他手段或工具，针对C++项目也是如此。</p>\n<p><strong>CycloneDX</strong><br />\n此时就开始了对第二个工具CycloneDX的研究，这个工具生成的是符合CycloneDX标准的SBOM，这里我也是将其作为dotnet工具进行全局安装的（安装命令：dotnet tool install --global CycloneDX），需要注意的是不要使用旧的项目，如.NET Framework的项目来使用此工具，我这边就是在NET Framework中使用了此工具进行生成，怎么走都没通，之前就是忽略了网上AI资料所提的，SycloneDX for .NET目前不支持早期的版本，.NET Framework，.NET Core的早期版本(如NET Core 2.1，NET Core 3.1，NET Core 5.0)，后来拿公司的一个.NET 8项目来尝试使用此CycloneDX，立马就能走通了。但在C#项目下，CycloneDX 默认情况下它会分析项目的 NuGet 包依赖（包括直接和传递依赖），但不会自动包含项目引用（Project References）所生成的 DLL 文件，因为这些 DLL 被视为“内部组件”而非外部第三方依赖。作为解决办法，从 CycloneDX .NET 工具 v2.0+ 开始，官方支持通过命令行参数显式包含项目引用。使用 --include-project-references 参数，注意，此时就需要使用工程目录，而不能使用解决方案目录,即.csproj文件，而非.sln文件。在只有.dll文件，即随便拷贝一个外部无用的.DLL文件放在编译后的输出目录中，CycloneDX .NET不会自动识别其组成，即SBOM中没有此项。若需要的话可以将其作为一个NuGet私有源进行引入。</p>\n<p>使用CycloneDX生成SBOM的参考命令：<br />\n命令示例：<code>dotnet cyclonedx  ..\\CSharp_Sbom.sln --output-format json --exclude-dev --exclude-test-projects -sn YourCompany -sv 1.0.0  -o ..\\SbomScript\\CycloneDX_sbom -fn sbom.json </code><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/297997/202602/297997-20260204161039726-830266260.png\" /></p>\n<p>在C#项目中使用CycloneDX工具时，也是顺利的生成了需要的SBOM，但是当在C++项目上生成时，这里先说下，使用的C++项目时临时创建的，无标准的包管理器，也没有用CMake，Conan或vcpkg管理依赖。最终生成出来的sbom文件中确没有任何组件或者说没有任何依赖，也就是json文件中的dependencies元素里面没有包含任何东西。也就是无法直接使用这个工具来生成C++项目的SBOM,这就尴尬了。后来查资料大概意思是说：因为C++缺乏统一的依赖管理机制（如 Java 的 Maven 或 Node.js 的 npm , C#的NuGet），不能直接解析依赖信息。</p>\n<p><strong>Syft</strong><br />\n然后就开始了我的第三个工具Syft的研究，Syft会自动扫描，检测构建产物中的二进制文件和动态链接库来识别第三方组件，自动识别提取生成依赖包，并输出SBOM。支持格式：CycloneDX、SPDX、Syft JSON 等，是由 Anchore 开发的开源 CLI 工具，是Go语言编写。<br />\nSyft生成SBOM参考命令： <code>syft . -o cyclonedx-json=../../sbom/syft/syft.cdx.json -vv</code><br />\n<img alt=\"5E7673D9-61DC-4829-8EC9-FA8C3A1B5E65\" src=\"https://img2024.cnblogs.com/blog/297997/202602/297997-20260204163404903-680685072.png\" /><br />\n<img alt=\"526ABF57-406F-4c90-B9F8-CA122919BA9A\" src=\"https://img2024.cnblogs.com/blog/297997/202602/297997-20260204163504326-995103179.png\" /><br />\n-v 输出警告信息<br />\n-vv 输出调试信息<br />\n使用Syft确实能做到自动识别C++的项目生成SBOM，但也仅仅是有限的支持，即仅能识别已知特征的库，无法还原完整依赖树（尤其静态链接、动态加载的以及自定义编译的库），只因C++项目无包管理器或者说有些C++项目没有使用统一的一套包管理流程，纯 CMake/Makefile + 静态链接情况下，只有Syft可行。能从二进制中识别 OpenSSL、zlib、libpng、glibc 等常见库（即使静态链接），经过一番折腾，这里又看到了另外一个工具OSS Review Toolkit (ORT) ，但经过了解下来说这是一个全流程的合规审计工具，因为目前只需要一个SBOM快速生成工具，貌似学习使用曲线更高，一下子就吓到了我这种懒人，也就懒得研究了。<br />\n最后附上一个简单的总结对比说明：<br />\n<img alt=\"5A97EFF3-207F-4f25-8E47-D2A8870A1A20\" src=\"https://img2024.cnblogs.com/blog/297997/202602/297997-20260204165300095-356125226.png\" /></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 16:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/huangqian\">奔四的大龄码农</a>&nbsp;\n阅读(<span id=\"post_view_count\">45</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "鸿蒙应用开发UI基础第二节：鸿蒙应用程序框架核心解析与实操",
      "link": "https://www.cnblogs.com/san-xiu/p/19575201",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/san-xiu/p/19575201\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 16:36\">\n    <span>鸿蒙应用开发UI基础第二节：鸿蒙应用程序框架核心解析与实操</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"学习目标\">学习目标</h2>\n<ol>\n<li>建立鸿蒙应用“宏观-微观”完整认知：明确应用、应用程序包、HAP/HSP、组件、页面的层级关系，理解 Stage 模型编译期与运行期概念的对应逻辑；</li>\n<li>清晰区分 Stage 模型与 FA 模型的核心差异，理解 Stage 模型在资源利用、配置管理、跨端适配等实际开发场景中的核心优势；</li>\n<li>掌握 Stage 模型进程/线程管理机制，理解 UIAbility 与 ExtensionAbility 的线程隔离特性，以及多线程开发的核心思路；</li>\n<li>熟练掌握 UIAbility 在 module.json5 中的核心配置项及规则，精准定位 Stage 工程核心文件并理清依赖链路；</li>\n<li>能独立完成应用名称/图标修改、UIAbility 配置调整、页面加载路径切换等实操，结合工程编译机制验证效果并排查基础配置与编译错误。</li>\n</ol>\n<p>上一节我们掌握了应用配置签名真机调试，本节开始从“应用整体架构”切入，聚焦 Stage 模型核心交互组件 UIAbility 核心能力展开，结合工程编译机制，帮助构建鸿蒙应用开发基础认知体系，为后续应用生命周期、Context 上下文、进程通信等进阶内容学习打下基础。</p>\n<h2 id=\"一回顾鸿蒙系统架构\">一、回顾鸿蒙系统架构</h2>\n<p>鸿蒙系统采用分层架构，共四层，开发者核心工作集中在顶层两层：</p>\n<ol>\n<li><strong>应用层</strong>：面向用户的应用载体，包含两种形态\n<ul>\n<li>原生应用：基于 ArkTS 开发，性能最优，能深度调用分布式能力，是鸿蒙生态核心；</li>\n<li>元服务：免安装、轻量便捷，适合高频次、低留存场景（如扫码支付）；</li>\n</ul>\n</li>\n<li><strong>框架层</strong>：开发聚焦在框架层，提供 ArkUI 组件、状态管理、路由/导航跳转等核心能力，后续组件开发、布局设计均依赖此层；</li>\n<li><strong>系统服务层</strong>：封装分布式能力、设备管理等基础服务，开发者通过 API 调用即可，无需关注底层实现；</li>\n<li><strong>内核层</strong>：负责进程调度、内存管理等底层操作，开发者无需深入接触。</li>\n</ol>\n<p><strong>图 1：鸿蒙系统架构图</strong> - 展示四层架构层级关系，标注开发者核心关注的应用层与框架层。</p>\n<p><img alt=\"鸿蒙系统架构教学版本\" class=\"lazyload\" /></p>\n<blockquote>\n<p>HarmonyOS 5.0 开始彻底完成 Linux 内核和安卓开放源代码项目（AOSP）的全面替换，采用纯鸿蒙内核（HarmonyOS Kernel），实现全栈自研。本阶段所有内容均基于鸿蒙 5.0~6.0 版本进行应用开发讲解。</p>\n</blockquote>\n<h2 id=\"二程序框架服务ability-kit\">二、程序框架服务（Ability Kit）</h2>\n<h3 id=\"一核心定义\">（一）核心定义</h3>\n<p>Ability Kit（程序框架服务）是鸿蒙系统为应用提供的核心运行时基础框架，抽象提炼应用开发所需核心能力，提供标准化组件体系和运行机制。<strong>核心价值是让开发者基于统一模型开发应用，同时保障应用在多设备、多场景下的兼容性与性能</strong>。</p>\n<h3 id=\"二核心能力与使用场景\">（二）核心能力与使用场景</h3>\n<table>\n<thead>\n<tr>\n<th>能力范围</th>\n<th>具体内容</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生命周期与进程管理</td>\n<td>应用/组件进程创建销毁、生命周期调度</td>\n<td>多 Module 应用开发，HAP/HSP 分工实现功能</td>\n</tr>\n<tr>\n<td>组件交互能力</td>\n<td>组件间/应用间跳转、跨设备流转</td>\n<td>办公应用内启动视频会议组件、购物应用跳转支付应用、视频跨设备流转</td>\n</tr>\n<tr>\n<td>基础支撑能力</td>\n<td>上下文环境、系统事件监听、启动框架、意图框架等</td>\n<td>应用快捷方式配置、程序访问控制、密码自动填充</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"三核心特征\">（三）核心特征</h3>\n<ol>\n<li><strong>标准化开发范式</strong>：抽象应用开发通用能力，提供统一的组件体系、生命周期规则，降低跨设备/跨版本适配成本；</li>\n<li><strong>高效资源调度</strong>：统一管理应用进程/线程，优化组件启动、内存占用等性能指标；</li>\n<li><strong>系统能力封装</strong>：内置意图框架、启动框架、流转能力等，无需开发者手动对接底层系统 API；</li>\n<li><strong>多场景支撑</strong>：通过 ExtensionAbility 覆盖备份、输入法、卡片等无 UI/轻 UI 场景，平衡功能扩展与系统管控。</li>\n</ol>\n<h3 id=\"四核心关联\">（四）核心关联</h3>\n<ul>\n<li><strong>ArkUI</strong>：UIAbility 组件中可使用 ArkUI 的组件、事件、动效、状态管理等能力实现界面开发；</li>\n<li><strong>ArkTS</strong>：提供语言运行时能力，支撑 Ability Kit 的代码执行；</li>\n<li><strong>Hvigor</strong>：鸿蒙官方构建工具，为 Ability Kit 相关组件与配置提供编译构建能力，实现代码与配置的工程化落地。</li>\n</ul>\n<h2 id=\"三鸿蒙应用模型\">三、鸿蒙应用模型</h2>\n<h3 id=\"一核心定义与构成要素\">（一）核心定义与构成要素</h3>\n<p>应用模型是 Ability Kit 对应用开发能力的抽象封装，定义应用的组件体系、运行机制、配置规范等核心规则，核心构成要素如下：</p>\n<table>\n<thead>\n<tr>\n<th>构成要素</th>\n<th>核心作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用组件</td>\n<td>应用运行入口，通过生命周期回调感知状态变化</td>\n</tr>\n<tr>\n<td>进程/线程模型</td>\n<td>定义进程/线程的创建、销毁及通信方式</td>\n</tr>\n<tr>\n<td>任务管理模型</td>\n<td>定义任务创建、销毁及与组件的关联（仅系统应用）</td>\n</tr>\n<tr>\n<td>应用配置文件</td>\n<td>存储应用/组件配置、权限等信息，供编译/运行阶段使用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"二演进历程fa-模型--stage-模型\">（二）演进历程：FA 模型 → Stage 模型</h3>\n<table>\n<thead>\n<tr>\n<th>模型类型</th>\n<th>适配版本</th>\n<th>核心状态</th>\n<th>官方开发优势</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FA 模型</td>\n<td>API 7~8</td>\n<td>已停止更新</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Stage 模型</td>\n<td>API 9+</td>\n<td>主推且长期演进</td>\n<td>1. 组件职责清晰，开发效率更高；2. 资源占用更低，启动速度更快；3. 跨端适配更便捷；4. 系统能力集成更简单；5. 编译分层设计，支持模块按需编译，提升开发效率</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"三fa-模型与-stage-模型核心差异\">（三）FA 模型与 Stage 模型核心差异</h3>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>FA 模型</th>\n<th>Stage 模型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组件体系</td>\n<td>Page/Service/DataAbility（匿名对象）</td>\n<td>UIAbility+ExtensionAbility（类继承）</td>\n</tr>\n<tr>\n<td>引擎机制</td>\n<td>每个组件独享 ArkTS 引擎实例</td>\n<td>所有组件共享一个 ArkTS 引擎实例</td>\n</tr>\n<tr>\n<td>进程模型</td>\n<td>主进程+渲染进程</td>\n<td>主进程+可配置独立进程（ExtensionAbility支持进程自定义）</td>\n</tr>\n<tr>\n<td>线程模型</td>\n<td>引擎实例在非主线程创建，不支持进程内对象共享</td>\n<td>引擎实例在主线程创建，支持进程内对象共享</td>\n</tr>\n<tr>\n<td>配置文件</td>\n<td>单一 config.json（混编全局/模块配置）</td>\n<td>app.json5（应用级）+ module.json5（模块级）</td>\n</tr>\n<tr>\n<td>编译机制</td>\n<td>整体工程编译，修改局部需重新编译全部</td>\n<td>分层编译，支持模块/全局编译，按需编译修改部分，效率更高</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"四stage-模型核心架构与组成\">（四）Stage 模型核心架构与组成</h3>\n<h4 id=\"1-stage-模型核心架构图\">1. Stage 模型核心架构图</h4>\n<p><strong>图 2：Stage 模型编译期-运行期架构图</strong> - 左侧为运行期概念（应用实例化流程），右侧为编译期概念（开发打包流程），展示“模块→组件→页面”的打包与实例化对应关系。</p>\n<p><img alt=\"Stage模型开发概述\" class=\"lazyload\" /></p>\n<h4 id=\"2-核心组成单元\">2. 核心组成单元</h4>\n<ol>\n<li><strong>AbilityStage</strong>：可选实现（若不实现，系统默认创建）；Entry/Feature 类型 HAP 的运行时载体，<strong>一个 HAP 对应一个 AbilityStage 实例</strong>，负责 HAP 的初始化、组件创建分发、模块级生命周期管理；</li>\n<li><strong>UIAbility</strong>：带 UI 的核心交互组件，通过 WindowStage 管理窗口，实现用户交互；</li>\n<li><strong>ExtensionAbility</strong>：面向特定场景的扩展组件（如 EntryBackupAbility、InputMethodExtensionAbility），是 UIAbility 的扩展，用于无界面的后台能力（如备份、输入法）；</li>\n<li><strong>WindowStage</strong>：与 UIAbility 实例绑定的窗口管理器，负责窗口创建、销毁，为 ArkUI 提供绘制区域；</li>\n<li><strong>Context</strong>：派生类（ApplicationContext/AbilityStageContext/UIAbilityContext）为不同层级提供运行期资源调用、权限管理等能力；</li>\n<li><strong>三级生命周期</strong>：Application（应用级）→ AbilityStage（模块级）→ UIAbility/ExtensionAbility（组件级），由 Ability Kit 统一调度，实现资源精细化管理。</li>\n</ol>\n<h4 id=\"3-核心层级关系说明\">3. 核心层级关系说明</h4>\n<ol>\n<li>层级关联：Application（应用全局）→ AbilityStage（HAP 模块）→ UIAbility/ExtensionAbility（组件），依次依赖创建；</li>\n<li>持有关系：UIAbility→WindowStage→Window→ArkUI Page，且各层级均持有对应 Context；</li>\n<li>对应关系：Application ↔ Bundle，AbilityStage ↔ HAP（1:1 绑定）。</li>\n</ol>\n<pre><code># 编译期（开发/打包）\n应用程序包（Bundle） → 模块（HAP/HSP） → 组件（UIAbility/ExtensionAbility） → 页面（Page）\n\n# 运行期（安装/启动）\nApplication（应用全局实例） → AbilityStage（HAP 模块实例） → 组件实例 → 页面渲染\n</code></pre>\n<h3 id=\"五stage-模型开发与运行全流程\">（五）Stage 模型开发与运行全流程</h3>\n<h4 id=\"1-开发阶段\">1. 开发阶段</h4>\n<p>开发者基于 Stage 模型完成应用功能开发与配置，核心工作包括：</p>\n<ul>\n<li><strong>应用组件开发</strong>：通过 UIAbility 组件开发带界面的用户交互模块（如应用主界面），通过 ExtensionAbility 等组件开发各类扩展功能模块；</li>\n<li><strong>模块解耦设计</strong>：为减少不同功能模块间的依赖和耦合，可将 UIAbility 和各类 ExtensionAbility 的实现分别放在不同的 HAP 包中，同时将两者共同依赖的通用功能放在 HSP 包中；</li>\n<li><strong>配置文件编写</strong>：在 app.json5 中配置应用名称、版本号、应用图标等全局信息，在 module.json5 中配置对应 HAP 包下的组件清单、组件权限、进程归属等模块级信息；配置信息会在应用编译、安装时被系统解析，便于系统和其他模块识别、交互。</li>\n</ul>\n<h4 id=\"2-运行阶段\">2. 运行阶段</h4>\n<p>当应用安装到设备运行时，系统通过一套应用进程和线程的管理机制，确保功能的有序运行：</p>\n<ul>\n<li>进程是应用运行的基础单元，负责资源分配和隔离；</li>\n<li>线程是进程内的执行单元，负责具体代码逻辑的执行；</li>\n<li>Ability Kit 统一管控进程/线程的创建、销毁和调度，保障应用稳定运行。</li>\n</ul>\n<h4 id=\"3-进程模型\">3. 进程模型</h4>\n<ul>\n<li>基础规则：UIAbility 组件默认运行在应用主进程中； ExtensionAbility 组件<strong>进程行为可配置</strong>，可通过<code>module.json5</code>中的<code>process</code>字段进行配置；</li>\n<li>配置方式：在 ExtensionAbility 组件的配置节点中添加<code>process</code>字段，值以<code>:</code>开头表示配置为独立进程运行，未配置则默认与 UIAbility 同进程运行；</li>\n<li>通信规则：ExtensionAbility 与 UIAbility 同进程时为线程隔离状态，数据和资源不直接互通；独立进程时需通过跨进程通信机制实现数据交互；</li>\n<li>核心价值：进程可配置性兼顾了应用性能和稳定性——轻量扩展组件与主进程共享资源，减少进程开销；核心/高隔离性扩展组件独立进程运行，避免单一组件异常影响整个应用。</li>\n</ul>\n<h4 id=\"4-组件通信机制\">4. 组件通信机制</h4>\n<p>鸿蒙提供多套通信机制，适配不同组件类型、不同进程归属的通信场景，核心分类如下：</p>\n<ul>\n<li><strong>进程内通信</strong>：适用于同一进程内的 UIAbility 与 ExtensionAbility、UIAbility 与页面间，优先使用<strong>EventHub</strong>，轻量高效、无需复杂配置；</li>\n<li><strong>跨进程通信</strong>：适用于跨应用、独立进程的 HAP 之间、独立进程 ExtensionAbility 与 UIAbility 之间，使用<strong>IPC</strong>基础通信机制；</li>\n<li><strong>ExtensionAbility 专属通信</strong>：不同类型的 ExtensionAbility 提供专属通信接口，适配自身业务场景，核心接口如下：\n<ul>\n<li>ServiceExtensionAbility：通过<code>connectServiceExtensionAbility()</code>建立连接，实现主从组件的双向通信；</li>\n<li>DataShareExtensionAbility：通过<code>createDataShareHelper()</code>创建助手实例，实现数据的增删改查共享。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>纯 ArkTS 单进程应用，优先使用 EventHub 实现组件/线程间通信；涉及独立进程或跨应用交互时，根据组件类型选择对应专属通信接口或基础 IPC 机制。</p>\n</blockquote>\n<h4 id=\"5-线程模型\">5. 线程模型</h4>\n<ul>\n<li>基础支撑：Stage 模型提供 worker、taskpool 等机制支撑应用多线程开发场景；</li>\n<li>开发建议：应用若有复杂的耗时逻辑（如大数据处理、网络请求、复杂计算），建议通过创建 worker 线程的方式处理，避免阻塞主线程（UI 线程），保障应用界面流畅性；</li>\n<li>线程隔离：无论 ExtensionAbility 与 UIAbility 同进程还是独立进程，其内部均为线程隔离设计，耗时逻辑均需放在子线程执行，不可直接在组件主线程处理。</li>\n</ul>\n<h3 id=\"六stage-模型开发流程\">（六）Stage 模型开发流程</h3>\n<table>\n<thead>\n<tr>\n<th>核心任务</th>\n<th>关键内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用组件开发</td>\n<td>开发 UIAbility/ExtensionAbility，按功能拆分到不同 HAP，通用能力抽离到 HSP</td>\n</tr>\n<tr>\n<td>进程/线程模型适配</td>\n<td>基于业务需求配置 ExtensionAbility 进程归属，耗时逻辑通过 worker 处理，遵循线程隔离规则</td>\n</tr>\n<tr>\n<td>配置文件编写</td>\n<td>配置 app.json5（全局）/module.json5（模块）的应用/组件/进程信息，保证路径与语法合规</td>\n</tr>\n<tr>\n<td>通信机制实现</td>\n<td>按进程归属和组件类型选择 EventHub、专属接口或 IPC 实现通信</td>\n</tr>\n<tr>\n<td>效果验证</td>\n<td>基于模块编译验证局部修改效果，全局编译生成完整应用包</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"四鸿蒙应用组成结构\">四、鸿蒙应用组成结构</h2>\n<h3 id=\"一应用程序包bundle\">（一）应用程序包（Bundle）</h3>\n<ul>\n<li>定义：鸿蒙应用分发、安装的最小单位（后缀<code>.app</code>），由全局编译整合所有 HAP/HSP 模块编译产物生成；</li>\n<li>构成：Entry HAP（必选，应用启动入口）、Feature HAP（可选，扩展功能）、HSP（可选，代码/资源共享）；</li>\n<li>多包机制：1 个 Bundle 可包含多个 HAP（Entry HAP 最多 1 个，Feature HAP 不限），HAP 之间通过 HSP 共享代码/资源，各模块可独立编译，最终整合至 Bundle。</li>\n</ul>\n<h3 id=\"二模块haphsp\">（二）模块（HAP/HSP）</h3>\n<table>\n<thead>\n<tr>\n<th>模块类型</th>\n<th>核心作用</th>\n<th>关键特征</th>\n<th>运行期关联实例</th>\n<th>典型使用场景</th>\n<th>编译特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Entry HAP</td>\n<td>应用主模块，提供启动入口</td>\n<td>必选，包含主 UIAbility，可单独安装运行</td>\n<td>对应 1 个 AbilityStage 实例</td>\n<td>应用主界面、核心交互功能</td>\n<td>可独立编译为 HAP 包，支持单独运行验证</td>\n</tr>\n<tr>\n<td>Feature HAP</td>\n<td>扩展功能模块</td>\n<td>可选，依赖 Entry HAP 运行，支持按需加载</td>\n<td>对应 1 个 AbilityStage 实例</td>\n<td>备份、输入法等扩展功能</td>\n<td>可独立编译，需结合 Entry HAP 运行</td>\n</tr>\n<tr>\n<td>HSP</td>\n<td>代码/资源共享包</td>\n<td>可选，无独立运行组件，仅用于模块间复用</td>\n<td>无对应的 AbilityStage 实例</td>\n<td>通用工具类、常量定义、公共资源</td>\n<td>编译为共享包，被其他 HAP 依赖调用</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>关于包的类型以及使用创建方法，我们会在项目阶段学习掌握。</p>\n</blockquote>\n<h3 id=\"三核心组件stage-模型两类组件\">（三）核心组件（Stage 模型两类组件）</h3>\n<table>\n<thead>\n<tr>\n<th>组件类型</th>\n<th>核心作用</th>\n<th>交互方式</th>\n<th>开发方式</th>\n<th>进程默认配置</th>\n<th>细分类型/示例文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UIAbility</td>\n<td>应用入口+窗口管理，实现用户交互</td>\n<td>桌面启动、可视化交互</td>\n<td>面向对象开发（类继承）</td>\n<td>应用主进程</td>\n<td>EntryAbility.ets（应用主界面）</td>\n</tr>\n<tr>\n<td>ExtensionAbility</td>\n<td>备份/输入法等无 UI/轻 UI 场景</td>\n<td>系统/事件触发</td>\n<td>面向对象开发（派生类实现）</td>\n<td>应用主进程</td>\n<td>EntryBackupAbility.ets（备份）、DataShareExtensionAbility.ets（数据共享）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五工程结构\">五、工程结构</h2>\n<p>延用上一节创建的项目<code>FirstApplication</code>（基于鸿蒙 5.0 API 12 + DevEco Studio 6.0+），工程核心结构如下，其中<code>build</code>目录为编译后自动生成，<code>build-profile.json5</code>和<code>hvigorfile.ts</code>为鸿蒙 Hvigor 构建工具的核心编译配置文件，实现工程与模块的分层编译管理：</p>\n<pre><code>FirstApplication                    \n├── AppScope/                # 应用全局配置目录\n│   ├── resources/           # 应用全局资源目录\n│   │   ├── base/            # 全局基础资源目录\n│   │   │   ├── element/     # 全局字符串、颜色等配置\n│   │   │   │   └── string.json\n│   │   │   ├── media/       # 全局媒体资源（层叠图标配置、兜底图标）\n│   │   │   │   ├── app_icon.png // 自定义的应用图标\n│   │   │   │   ├── background.png\n│   │   │   │   ├── foreground.png\n│   │   │   │   └── layered_image.json\n│   │   │   └── profile/     # 全局配置文件（如页面路由、备份配置等）\n│   └── app.json5            # 全局配置文件（包名、版本、图标、名称等，供全局编译解析）\n├── entry/                   # Entry HAP主模块（核心开发目录）\n│   ├── build/               # 模块编译产物目录（编译后自动生成，存放entry模块HAP包）\n│   ├── src/\n│   │   ├── main/            # entry模块核心源码目录\n│   │   │   ├── ets/         # ArkTS代码目录\n│   │   │   │   ├── entryability/ # UIAbility核心组件目录\n│   │   │   │   │   └── EntryAbility.ets\n│   │   │   │   ├── entrybackupability/ # 备份扩展组件目录\n│   │   │   │   │   └── EntryBackupAbility.ets\n│   │   │   │   └── pages/   # 页面目录\n│   │   │   │       ├── Index.ets\n│   │   │   │       └── Home.ets\n│   │   │   ├── resources/   # 模块级静态资源目录（编译时自动打包优化）\n│   │   │   │   ├── base/    # 基础资源目录（默认主题）\n│   │   │   │   │   ├── element/ # 模块级元素配置\n│   │   │   │   │   ├── media/   # 模块级媒体资源\n│   │   │   │   │   │   ├── background.png\n│   │   │   │   │   │   ├── foreground.png\n│   │   │   │   │   │   ├── startIcon.png // 默认的窗口图标\n│   │   │   │   │   │   └── layered_image.json\n│   │   │   │   ├── dark/    # 深色模式资源目录\n│   │   │   │   └── rawfile/ # 原生文件目录（无需编译的静态文件）\n│   │   │   └── module.json5 # Entry HAP模块配置文件（组件、权限、进程等，供模块编译解析）\n│   ├── mock/                # 模拟数据目录（测试用）\n│   ├── ohosTest/            # OpenHarmony测试目录\n│   ├── test/                # 本地测试目录\n│   ├── .gitignore           # Git忽略文件配置\n│   ├── build-profile.json5  # 模块编译配置文件（指定SDK版本、签名关联等编译规则）\n│   └── hvigorfile.ts        # 模块编译脚本（Hvigor构建工具模块级执行入口）\n├── build/                   # 工程全局编译产物目录（编译后自动生成，存放全局整合的HAP/APP包）\n├── build-profile.json5      # 工程全局编译配置文件（统一管理所有模块编译规则、编译模式）\n├── hvigorfile.ts            # 工程全局编译脚本（Hvigor构建工具全局执行入口，触发所有模块编译）\n├── oh-package.json5         # ohpm依赖配置文件（编译前自动解析下载依赖）\n└── oh-package-lock.json5    # ohpm依赖版本锁定文件\n</code></pre>\n<blockquote>\n<p>说明：鸿蒙工程基于<strong>Hvigor</strong>（鸿蒙官方自研构建工具）实现编译，采用<strong>按需编译</strong>原则，仅修改过的模块/文件会重新编译，未修改部分复用原有编译产物，提升开发效率；<code>build</code>目录删除后可通过重新编译生成，不影响工程源码。</p>\n</blockquote>\n<h2 id=\"六uiability-核心实操\">六、UIAbility 核心实操</h2>\n<h3 id=\"一核心定位\">（一）核心定位</h3>\n<ol>\n<li><strong>应用入口</strong>：用户点击应用图标后，系统首先创建并启动 UIAbility 实例；</li>\n<li><strong>窗口管理载体</strong>：每个 UIAbility 实例启动后会创建一个 WindowStage（窗口管理器），负责窗口的创建、销毁，并<strong>通过 WindowStage 加载 ArkUI 页面</strong>；</li>\n<li><strong>实例模式</strong>：支持单实例、多实例、指定实例等配置（通过 module.json5 的<code>launchType</code>字段），满足不同业务场景需求；</li>\n<li><strong>编译关联</strong>：UIAbility 的类名、文件路径需与 module.json5 中<code>name</code>、<code>srcEntry</code>配置完全一致，否则会导致模块编译失败，无法生成 HAP 包；</li>\n<li><strong>权限核心</strong>：作为应用核心交互组件，UIAbility 是应用权限申请和校验的核心载体，后台启动其他组件需依赖专属系统权限。</li>\n</ol>\n<h3 id=\"二核心配置\">（二）核心配置</h3>\n<h4 id=\"1-模块级配置modulejson5\">1. 模块级配置（module.json5）</h4>\n<pre><code class=\"language-json\">{\n  \"module\": {\n    \"name\": \"entry\", // 模块名称\n    \"type\": \"entry\", // 模块类型：entry/feature/har/hsp\n    \"description\": \"$string:module_desc\", // 模块描述\n    \"mainElement\": \"EntryAbility\", // 默认启动组件\n    \"deviceTypes\": [ // 支持的设备类型\n      \"phone\"\n    ],\n    \"deliveryWithInstall\": true, // 是否随应用安装交付\n    \"installationFree\": false, // 是否免安装\n    \"pages\": \"$profile:main_pages\", // 页面路由配置\n    \"abilities\": [ // UIAbility组件配置\n      {\n        \"name\": \"EntryAbility\", // 组件名称（与代码类名一致，编译校验关键）\n        \"srcEntry\": \"./src/main/ets/entryability/EntryAbility.ets\", // 入口路径（必须./开头，编译校验关键）\n        \"description\": \"$string:EntryAbility_desc\", // 组件描述\n        \"icon\": \"$media:layered_image\", // 组件图标（模块级，不重名的情况下优先生效）\n        \"label\": \"$string:EntryAbility_label\", // 组件显示名称（模块级，优先级更高）\n        \"startWindowIcon\": \"$media:startIcon\", // 启动窗口图标\n        \"startWindowBackground\": \"$color:start_window_background\", // 启动窗口背景\n        \"exported\": true, // 是否允许跨应用调用\n        \"launchType\": \"singleton\", // 默认的启动模式，可以不写\n        \"skills\": [ // 桌面图标必配：缺少则桌面无应用图标\n          {\n            \"entities\": [\n              \"entity.system.home\" // 桌面入口标识\n            ],\n            \"actions\": [\n              \"ohos.want.action.home\" // 桌面启动动作\n            ]\n          }\n        ]\n      }\n    ],\n    \"extensionAbilities\": [ // 扩展组件配置\n      {\n        \"name\": \"EntryBackupAbility\", // 备份扩展组件名称\n        \"srcEntry\": \"./src/main/ets/entrybackupability/EntryBackupAbility.ets\", \n        \"type\": \"backup\", // 扩展类型（backup/dataShare/inputMethod等）\n        \"exported\": false, // 仅内部使用\n        \"metadata\": [ // 扩展元数据\n          {\n            \"name\": \"ohos.extension.backup\", // 元数据名称\n            \"resource\": \"$profile:backup_config\" // 元数据配置文件\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>\n<h4 id=\"2-配置关键规则\">2. 配置关键规则</h4>\n<ul>\n<li><code>mainElement</code>：Entry HAP 必须配置为 UIAbility，Feature HAP 无默认启动组件；</li>\n<li><code>name</code>：组件名称必须与代码中导出的类名一致，不可随意修改，编译时会严格校验；</li>\n<li><code>srcEntry</code>：路径需以<code>./</code>开头，严格匹配文件的目录/文件名（区分大小写），路径错误会直接导致编译失败；</li>\n<li><code>exported</code>：跨应用调用的组件需设为 true，仅内部使用的组件设为 false 即可；</li>\n<li><code>skills</code>：仅 UIAbility 需配置（桌面图标展示），ExtensionAbility 无需配置；缺失或配置不全则桌面无图标，点击图标进入应用详情页；</li>\n<li><code>type</code>：ExtensionAbility 必选字段，需与扩展类型匹配（如 backup、dataShare、inputMethod 等）；</li>\n<li><code>process</code>：ExtensionAbility 可选配置字段，用于设置进程归属，值以<code>:</code>开头表示独立进程，未配置则默认与主进程同进程；</li>\n<li>JSON 语法：禁止末尾多余逗号，配置项、文件/目录名称均区分大小写，语法错误会导致编译解析失败。</li>\n</ul>\n<h4 id=\"3-全局配置appjson5\">3. 全局配置（app.json5）</h4>\n<pre><code class=\"language-json\">{\n  \"app\": {\n    \"bundleName\": \"com.sanxiu.firstapp\",\n    \"vendor\": \"example\",\n    \"versionCode\": 1000000,\n    \"versionName\": \"1.0.0\",\n    \"icon\": \"$media:layered_image\", // 全局应用图标\n    \"label\": \"$string:app_name\" // 全局应用名称\n  }\n}\n</code></pre>\n<h4 id=\"4-层叠图标配置layered_imagejson\">4. 层叠图标配置（layered_image.json）</h4>\n<p><strong>路径</strong>：</p>\n<ul>\n<li>全局：AppScope/resources/base/media/layered_image.json</li>\n<li>模块级：entry/src/main/resources/base/media/layered_image.json</li>\n</ul>\n<pre><code class=\"language-json\">{\n  \"layered-image\": {\n    \"background\": \"$media:background\",\n    \"foreground\": \"$media:foreground\"\n  }\n}\n</code></pre>\n<p><strong>核心规则</strong>：</p>\n<ul>\n<li>资源覆盖：编译期 AppScope 和模块内重名资源，AppScope 资源优先级更高；</li>\n<li>模块级 icon 生效前提：UIAbility 的 <code>skills</code> 字段必须包含<code>entity.system.home</code>和<code>ohos.want.action.home</code>；多 Ability 时取<code>mainElement</code>对应配置；</li>\n<li>图标尺寸规范：鸿蒙层叠图标推荐基础尺寸：foreground/background 均为<strong>1024×1024</strong>（png 格式，透明背景），编译时系统会自动适配不同设备的图标尺寸，无需手动制作多尺寸版本。</li>\n</ul>\n<h4 id=\"5-页面路由配置main_pagesjson\">5. 页面路由配置（main_pages.json）</h4>\n<p>通过 <code>New -&gt; Page -&gt; Empty Page</code> 创建的页面会自动导入<code>main_pages.json</code>，其他方法创建的页面需要手动管理路由配置。</p>\n<pre><code class=\"language-json\">{\n  \"src\": [\n    \"pages/Index\",\n    \"pages/Home\" // 新增Home页面路径\n  ]\n}\n</code></pre>\n<h3 id=\"三页面加载核心逻辑entryabilityets\">（三）页面加载核心逻辑（EntryAbility.ets）</h3>\n<pre><code class=\"language-typescript\">import UIAbility from '@ohos.app.ability.UIAbility';\nimport window from '@ohos.window';\nimport hilog from '@ohos.hilog';\nimport { AbilityConstant, Want } from '@kit.AbilityKit';\nimport { BusinessError } from '@ohos.base'; \n\nconst DOMAIN: number = 0x0000;\nconst TAG: string = 'EntryAbility';\n\nexport default class EntryAbility extends UIAbility {\n  // 组件创建时触发，可初始化资源\n  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\n    hilog.info(DOMAIN, TAG, 'EntryAbility onCreate called');\n  }\n\n  // 组件销毁时触发，可释放资源\n  onDestroy() {\n    hilog.info(DOMAIN, TAG, 'EntryAbility onDestroy called');\n  }\n\n  // 窗口创建后触发，仅此处可加载页面\n  onWindowStageCreate(windowStage: window.WindowStage): void {\n    hilog.info(DOMAIN, TAG, '--- onWindowStageCreate 触发（加载页面）---');\n    // 加载页面\n    windowStage.loadContent('pages/Index', (err) =&gt; {\n      if (err.code) {\n        hilog.error(DOMAIN, TAG, `页面加载失败：code=${err.code}, message=${err.message}`);\n        return;\n      }\n      hilog.info(DOMAIN, TAG, 'Index页面加载成功');\n    });\n  }\n\n  onWindowStageDestroy(): void {\n    // Main window is destroyed, release UI related resources\n    hilog.info(DOMAIN, TAG, '%{public}s', '主窗口即将销毁，释放UI相关资源');\n  }\n\n  onForeground(): void {\n    // Ability has brought to foreground\n    hilog.info(DOMAIN, TAG, '%{public}s', '应用切换至前台，恢复业务逻辑');\n  }\n\n  onBackground(): void {\n    // Ability has back to background\n    hilog.info(DOMAIN, TAG, '%{public}s', '应用切换至后台，暂停业务逻辑，不可启动其他组件');\n  }\n}\n</code></pre>\n<h4 id=\"页面加载规则\">页面加载规则</h4>\n<ol>\n<li>仅能通过<code>WindowStage.loadContent()</code>加载页面；</li>\n<li>该方法仅可在<code>onWindowStageCreate</code>生命周期中调用；</li>\n<li>路径需严格遵循“无.ets后缀、区分大小写、基于pages根目录的相对路径”，且需与<code>main_pages.json</code>中注册的路径完全一致，否则编译通过但运行时页面加载失败；</li>\n<li>页面文件命名、路径错误会导致编译时资源打包失败，或运行时页面空白。</li>\n</ol>\n<h3 id=\"四自定义首页开发\">（四）自定义首页开发</h3>\n<h4 id=\"步骤-1创建-home-页面pageshomeets\">步骤 1：创建 Home 页面（pages/Home.ets）</h4>\n<pre><code class=\"language-typescript\">@Entry\n@Component\nstruct Home {\n  build() {\n    Column({ space: 20 }) {\n      Text('我的Stage应用首页')\n        .fontSize(30)\n        .fontWeight(FontWeight.Bold);\n    }\n    .width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center);\n  }\n}\n</code></pre>\n<h4 id=\"步骤-2注册-home-页面到路由配置main_pagesjson\">步骤 2：注册 Home 页面到路由配置（main_pages.json）</h4>\n<p>打开路径：<code>entry/src/main/resources/base/profile/main_pages.json</code>，在<code>src</code>数组中新增 Home 页面路径，确保与实际文件路径一致：</p>\n<pre><code class=\"language-json\">{\n  \"src\": [\n    \"pages/Index\",\n    \"pages/Home\" // 必须注册，否则运行时页面加载失败\n  ]\n}\n</code></pre>\n<h4 id=\"步骤-3修改页面加载路径entryabilityets\">步骤 3：修改页面加载路径（EntryAbility.ets）</h4>\n<p>将<code>windowStage.loadContent('pages/Index', ...)</code>修改为：</p>\n<pre><code class=\"language-typescript\">// 加载页面\nwindowStage.loadContent('pages/Home').then(()=&gt;{\n  hilog.info(DOMAIN, TAG, 'Home页面加载成功');\n}).catch((err: BusinessError)=&gt;{\n  hilog.error(DOMAIN, TAG, `页面加载失败：code=${err.code}, message=${err.message}`);\n})\n</code></pre>\n<h4 id=\"效果验证\">效果验证</h4>\n<p><img alt=\"修改加载页面.png\" class=\"lazyload\" /></p>\n<ol>\n<li><strong>应用内验证</strong>：正常展示<code>我的Stage应用首页</code>，无空白、无报错；</li>\n<li><strong>日志端验证</strong>：Logcat 中筛选<code>TAG:EntryAbility</code>，可看到“Home页面加载成功”相关日志。</li>\n</ol>\n<h3 id=\"五配置应用名称和图标\">（五）配置应用名称和图标</h3>\n<h4 id=\"1-层叠图标方案-模块级配置\">1. 层叠图标方案-模块级配置</h4>\n<p>默认工程中，全局应用图标、模块级图标、layered-image 及前后背景图的命名均一致。<br />\n若需让模块级应用图标生效，需删除<strong>AppScope/resources/base/media/</strong> 目录下的 layered-image 相关文件（含<code>layered_image.json</code>、<code>background.png</code>、<code>foreground.png</code>），避免全局重名资源覆盖（不推荐）。</p>\n<p><strong>推荐方案</strong>：确保资源不重名，使用自定义图标名称，同时保证<code>module.json5</code> 中配置了<code>skills</code>字段（桌面图标正常显示前提）：</p>\n<ul>\n<li>确认 entry 模块<code>layered_image.json</code>配置（路径：entry/src/main/resources/base/media/layered_image.json）；</li>\n<li>确保 module.json5 中 UIAbility 配置<code>\"icon\": \"$media:layered_image\"</code>。</li>\n</ul>\n<h4 id=\"2-层叠图标方案-全局级配置\">2. 层叠图标方案-全局级配置</h4>\n<p>直接将应用图标图片命名为<code>foreground</code>，或自定义 layered_image.json 中<code>foreground</code>的资源引用为<code>\"foreground\": \"$media:app_icon\"</code>：</p>\n<ol>\n<li>配置 AppScope 下<code>layered_image.json</code>（路径：AppScope/resources/base/media/layered_image.json）；</li>\n<li>在<code>AppScope/app.json5</code>中配置全局图标：<code>\"icon\": \"$media:layered_image\"</code>。</li>\n</ol>\n<h4 id=\"3-应用名称配置\">3. 应用名称配置</h4>\n<p>应用名称的配置优先级：<strong>模块级别 &gt; 全局级别</strong>。若需让全局资源配置的应用名称生效，需在 module.json5 中注释/删除 UIAbility 的 label 配置：<code>\"label\": \"$string:EntryAbility_label\"</code>。</p>\n<ul>\n<li>名称修改后需检查<code>string.json</code>中对应字符是否存在，字符缺失会导致编译时资源解析错误；</li>\n<li>配置完成后执行模块编译，验证桌面应用名称是否更新；</li>\n<li>全局名称路径：<code>AppScope/resources/base/element/string.json</code><pre><code class=\"language-json\">{\n  \"string\": [\n    {\n      \"name\": \"app_name\",\n      \"value\": \"第一个应用\"\n    }\n  ]\n}\n</code></pre>\n</li>\n</ul>\n<h4 id=\"运行验证\">运行验证</h4>\n<p>将应用运行至真机/模拟器，桌面端应用名称显示为<code>第一个应用</code>，图标为全局配置的层叠样式。</p>\n<p><img alt=\"修改应用名称和图标\" class=\"lazyload\" /></p>\n<h2 id=\"七清理构建hapapp包\">七、清理、构建HAP/APP包</h2>\n<p>鸿蒙工程基于Hvigor构建工具实现模块级编译和全局级构建，<strong>顶部菜单栏Build</strong>为核心操作入口，覆盖「清理-编译-构建-发布」全流程，以下为精准实操和工具说明：</p>\n<h3 id=\"1-清理操作\">1. 清理操作</h3>\n<ul>\n<li>操作：顶部菜单栏<code>Build &gt; Clean Project</code></li>\n<li>功能：删除全工程所有编译相关文件（缓存、临时产物、已生成的包文件等），仅保留源码、配置和资源文件</li>\n<li>作用：解决编译异常、缓存冲突、配置修改不生效等问题，清理完成控制台显示<code>BUILD SUCCESSFUL</code></li>\n</ul>\n<h3 id=\"2-模块编译\">2. 模块编译</h3>\n<p>适用于修改entry模块后快速验证局部效果，仅生成单模块HAP包：</p>\n<ol>\n<li>操作：选中<code>entry</code>文件，点击顶部菜单栏<code>Build &gt; Make Module 'entry'</code></li>\n<li>结果：控制台显示<code>BUILD SUCCESSFUL</code>即为成功，HAP包存放于<code>entry/build/outputs/hap/</code></li>\n<li>作用：快速验证entry模块代码/配置修改效果</li>\n</ol>\n<p><img alt=\"编译entry模块_20260203211239_98_1340\" class=\"lazyload\" /></p>\n<h3 id=\"3-构建完整应用包用于安装分发上架\">3. 构建完整应用包（用于安装/分发/上架）</h3>\n<p>适用于真机/模拟器部署、应用发布上架，整合全模块生成完整.app包：</p>\n<ol>\n<li>操作：顶部菜单栏<code>Build &gt; Build Hap(s)/APP(s) &gt; Build App(s)</code></li>\n<li>结果：控制台显示<code>BUILD SUCCESSFUL</code>即为成功，.app包存放于<code>build/outputs/app/</code>，主模块entry打包产出.hap包</li>\n<li>作用：生成可部署/发布的完整Bundle应用包</li>\n</ol>\n<p><img alt=\"构建应用程序包_20260203211834_100_1340\" class=\"lazyload\" /></p>\n<h3 id=\"4-build菜单核心工具选项全解\">4. Build菜单核心工具选项全解</h3>\n<table>\n<thead>\n<tr>\n<th>选项名称</th>\n<th>核心作用</th>\n<th>典型使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Make Module 'entry'</td>\n<td>编译entry模块，生成单模块HAP包</td>\n<td>验证entry模块局部修改效果</td>\n</tr>\n<tr>\n<td>Build Hap(s)/APP(s)</td>\n<td>Build Hap(s)：编译单/多模块生成HAP包；Build App(s)：整合全模块生成.app包</td>\n<td>局部调试用Hap(s)；部署/发布用App(s)</td>\n</tr>\n<tr>\n<td>Generate Build Profile 'entry'</td>\n<td>生成entry模块专属编译配置文件</td>\n<td>自定义entry模块编译规则</td>\n</tr>\n<tr>\n<td>Clean Project</td>\n<td>删除全工程所有编译文件，彻底清理缓存</td>\n<td>编译异常、缓存冲突、配置修改不生效</td>\n</tr>\n<tr>\n<td>Rebuild Project</td>\n<td>先执行Clean Project，再全工程重新编译</td>\n<td>清理后仍编译失败、工程长期未编译</td>\n</tr>\n<tr>\n<td>Generate Key and CSR</td>\n<td>生成.p12密钥+CSR文件，用于申请官方发布签名</td>\n<td>应用正式发布上架</td>\n</tr>\n<tr>\n<td>Upload Product</td>\n<td>将正式版.app包上传至华为应用市场后台</td>\n<td>应用提交上架提审</td>\n</tr>\n<tr>\n<td>Build Analyzer</td>\n<td>分析构建耗时、资源占用，定位构建失败原因</td>\n<td>构建速度慢、排查构建失败问题</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"八代码仓库\">八、代码仓库</h2>\n<ul>\n<li>工程名称：FirstApplication</li>\n<li>仓库地址：<a href=\"https://gitee.com/HarmonyOS-UI-Basics/harmony-os-ui-basics.git\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/HarmonyOS-UI-Basics/harmony-os-ui-basics.git</a></li>\n</ul>\n<h2 id=\"九下节预告\">九、下节预告</h2>\n<p>下一节将深入学习 UIAbility 生命周期全解析，核心内容包括：</p>\n<ol>\n<li>UIAbility 全生命周期核心方法的触发时机、核心作用及执行次数约束；</li>\n<li>WindowStage 事件体系与生命周期的联动逻辑，掌握窗口状态（获焦/失焦、前台/后台）的合法监听方式；</li>\n<li><code>onDestroy</code> 方法的特殊触发规则（API 13+一键清理、调试模式、手动调用API等不同场景）；</li>\n<li>页面仅能在 <code>onWindowStageCreate</code> 加载的底层原因及生命周期相关开发避坑要点；</li>\n<li>实操验证启动/前后台切换/关闭等场景下的生命周期执行顺序，掌握关键数据的安全保存策略。</li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 16:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/san-xiu\">鸿蒙-散修</a>&nbsp;\n阅读(<span id=\"post_view_count\">61</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": ".NET 中如何快速实现 List 集合去重？",
      "link": "https://www.cnblogs.com/1312mn/p/18552496",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/1312mn/p/18552496\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 16:34\">\n    <span>.NET 中如何快速实现 List 集合去重？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain md-expand\" style=\"font-size: 16px;\">前言</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">在数据处理中，去除集合中的重复元素是一个常见的需求。.NET 6 和 .NET 7 引入了 <span class=\"md-pair-s\"><code>DistinctBy</code><span class=\"md-plain\"> 方法，这是一个非常实用的新特性，可以方便地根据指定的键对集合进行去重。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">本文将详细介绍 <span class=\"md-pair-s\"><code>DistinctBy</code><span class=\"md-plain\"> 方法的使用，并通过具体的案例来展示其在实际开发中的应用。</span></span></span></p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\" style=\"font-size: 16px;\">正文</span></h2>\n<h3><strong>1、<code>DistinctBy</code> 方法</strong></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><code>DistinctBy</code><span class=\"md-plain\"> 方法允许我们在 LINQ 查询中根据某个键对集合中的元素进行去重。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">这个方法返回一个新的集合，其中只包含根据指定键唯一确定的元素。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s md-expand\" style=\"font-size: 16px;\"><strong>方法签名</strong></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> IEnumerable&lt;TSource&gt; DistinctBy&lt;TSource, TKey&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">this</span> IEnumerable&lt;TSource&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> source,\n    Func</span>&lt;TSource, TKey&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> keySelector\n);</span></pre>\n</div>\n<h3 class=\"md-end-block md-heading\"><strong><span class=\"md-plain\" style=\"font-size: 16px;\">2、基本用法</span></strong></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">最简单的用法是在 LINQ 查询中直接调用 <span class=\"md-pair-s\"><code>DistinctBy</code><span class=\"md-plain\"> 方法，然后处理去重后的集合。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><strong>说明</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">假设我们有一个用户列表，我们想要根据用户名去除重复的用户。</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">using</span><span style=\"color: rgba(0, 0, 0, 1);\"> System.Linq;\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> User\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> Name { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> Age { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n}\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> users = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;User&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> User { Name = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Age = <span style=\"color: rgba(128, 0, 128, 1);\">25</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> User { Name = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Bob</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Age = <span style=\"color: rgba(128, 0, 128, 1);\">32</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> User { Name = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Age = <span style=\"color: rgba(128, 0, 128, 1);\">28</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> User { Name = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">David</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Age = <span style=\"color: rgba(128, 0, 128, 1);\">35</span><span style=\"color: rgba(0, 0, 0, 1);\"> }\n};\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> distinctUsers = users.DistinctBy(user =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> user.Name);\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> user <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> distinctUsers)\n{\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Name: {user.Name}, Age: {user.Age}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n}</span></pre>\n</div>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">输出结果：</span></p>\n<div class=\"cnblogs_code\">\n<pre>Name: Alice, Age: <span style=\"color: rgba(128, 0, 128, 1);\">25</span><span style=\"color: rgba(0, 0, 0, 1);\">\nName: Bob, Age: </span><span style=\"color: rgba(128, 0, 128, 1);\">32</span><span style=\"color: rgba(0, 0, 0, 1);\">\nName: David, Age: </span><span style=\"color: rgba(128, 0, 128, 1);\">35</span></pre>\n</div>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">过滤前后元素还是保持原有的顺序，我们可以查看源码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><strong>源码</strong></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> IEnumerable&lt;TSource&gt; DistinctByIterator&lt;TSource, TKey&gt;(IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, IEqualityComparer&lt;TKey&gt;?<span style=\"color: rgba(0, 0, 0, 1);\"> comparer)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">using</span> IEnumerator&lt;TSource&gt; enumerator =<span style=\"color: rgba(0, 0, 0, 1);\"> source.GetEnumerator();\n​\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (enumerator.MoveNext())\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> <span style=\"color: rgba(0, 0, 255, 1);\">set</span> = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> HashSet&lt;TKey&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(DefaultInternalSetCapacity, comparer);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">do</span><span style=\"color: rgba(0, 0, 0, 1);\">\n        {\n            TSource element </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> enumerator.Current;\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (<span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">.Add(keySelector(element)))\n            {\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">yield</span> <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> element;\n            }\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">while</span><span style=\"color: rgba(0, 0, 0, 1);\"> (enumerator.MoveNext());\n    }\n}</span></pre>\n</div>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">通过查看源码，可以看到是利用了 <span class=\"md-pair-s\"><code>HashSet</code><span class=\"md-plain\"> 去重，元素顺序并未被打乱。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">在处理集合时，我们经常需要去除重复的元素，同时保持原有的顺序。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">使用 <span class=\"md-pair-s\"><code>HashSet</code><span class=\"md-plain\"> 可以高效地实现这一目标。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">首先将指定的键尝试添加到 <span class=\"md-pair-s\"><code>HashSet</code><span class=\"md-plain\"> 中，如果添加成功，说明该键没有重复；</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">如果添加失败，说明已经存在相同的键，此元素将被过滤掉。</span></p>\n<h3 class=\"md-end-block md-heading\"><strong><span class=\"md-plain\" style=\"font-size: 16px;\">3、复杂用法</span></strong></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><code>DistinctBy</code><span class=\"md-plain\"> 方法可以用于更复杂的去重逻辑，例如根据多个属性进行去重。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \" style=\"font-size: 16px;\"><strong>说明</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">假设我们有一个订单列表，我们想要根据客户名称和订单金额去除重复的订单。</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Order\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> OrderId { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span> CustomerName { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">decimal</span> Amount { <span style=\"color: rgba(0, 0, 255, 1);\">get</span>; <span style=\"color: rgba(0, 0, 255, 1);\">set</span><span style=\"color: rgba(0, 0, 0, 1);\">; }\n}\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> orders = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;Order&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> Order { OrderId = <span style=\"color: rgba(128, 0, 128, 1);\">1</span>, CustomerName = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Amount = <span style=\"color: rgba(128, 0, 128, 1);\">100.0m</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> Order { OrderId = <span style=\"color: rgba(128, 0, 128, 1);\">2</span>, CustomerName = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Bob</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Amount = <span style=\"color: rgba(128, 0, 128, 1);\">150.0m</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> Order { OrderId = <span style=\"color: rgba(128, 0, 128, 1);\">3</span>, CustomerName = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Amount = <span style=\"color: rgba(128, 0, 128, 1);\">100.0m</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> Order { OrderId = <span style=\"color: rgba(128, 0, 128, 1);\">4</span>, CustomerName = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Charlie</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Amount = <span style=\"color: rgba(128, 0, 128, 1);\">120.0m</span><span style=\"color: rgba(0, 0, 0, 1);\"> },\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> Order { OrderId = <span style=\"color: rgba(128, 0, 128, 1);\">5</span>, CustomerName = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Bob</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, Amount = <span style=\"color: rgba(128, 0, 128, 1);\">150.0m</span><span style=\"color: rgba(0, 0, 0, 1);\"> }\n};\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> distinctOrders = orders.DistinctBy(order =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> (order.CustomerName, order.Amount));\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> order <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> distinctOrders)\n{\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Order ID: {order.OrderId}, Customer: {order.CustomerName}, Amount: {order.Amount}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n}</span></pre>\n</div>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">输出结果：</span></p>\n<div class=\"cnblogs_code\">\n<pre>Order ID: <span style=\"color: rgba(128, 0, 128, 1);\">1</span>, Customer: Alice, Amount: <span style=\"color: rgba(128, 0, 128, 1);\">100.0</span><span style=\"color: rgba(0, 0, 0, 1);\">\nOrder ID: </span><span style=\"color: rgba(128, 0, 128, 1);\">2</span>, Customer: Bob, Amount: <span style=\"color: rgba(128, 0, 128, 1);\">150.0</span><span style=\"color: rgba(0, 0, 0, 1);\">\nOrder ID: </span><span style=\"color: rgba(128, 0, 128, 1);\">4</span>, Customer: Charlie, Amount: <span style=\"color: rgba(128, 0, 128, 1);\">120.0</span></pre>\n</div>\n<h3 class=\"md-end-block md-heading\"><strong><span class=\"md-plain\" style=\"font-size: 16px;\">4、性能考虑</span></strong></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><code>DistinctBy</code><span class=\"md-plain\"> 方法在内部使用哈希表来跟踪已经出现的键，因此在大多数情况下性能非常好。但在处理非常大的数据集时，仍然需要注意内存使用情况。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><strong>说明</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">假设我们有一个包含数百万条记录的大集合，我们需要根据某个键进行去重。</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> largeCollection = Enumerable.Range(<span style=\"color: rgba(128, 0, 128, 1);\">1</span>, <span style=\"color: rgba(128, 0, 128, 1);\">10000000</span>).Select(i =&gt; <span style=\"color: rgba(0, 0, 255, 1);\">new</span> { Id = i, Value = i % <span style=\"color: rgba(128, 0, 128, 1);\">1000</span><span style=\"color: rgba(0, 0, 0, 1);\"> });\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> distinctLargeCollection = largeCollection.DistinctBy(item =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> item.Value);\nConsole.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Distinct count: {distinctLargeCollection.Count()}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<h3 class=\"md-end-block md-heading\"><strong><span class=\"md-plain\" style=\"font-size: 16px;\">5、异步 LINQ 查询中的使用</span></strong></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><code>DistinctBy</code><span class=\"md-plain\"> 方法也可以在异步 LINQ 查询中使用，结合 <span class=\"md-pair-s\"><code>IAsyncEnumerable&lt;T&gt;</code><span class=\"md-plain\"> 类型，处理大量数据时更加高效。</span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \" style=\"font-size: 16px;\"><strong>说明</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\" style=\"font-size: 16px;\">假设我们有一个异步方法返回一个用户列表，我们想要根据用户名去除重复的用户。</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">using</span><span style=\"color: rgba(0, 0, 0, 1);\"> System.Net.Http.Json;\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> IAsyncEnumerable&lt;User&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GetUsersAsync()\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> response = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> httpClient.GetAsync(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">https://api.example.com/users</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> usersJson = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> response.Content.ReadAsStringAsync();\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用Json序列化工具解析用户列表</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">var</span> users = JsonSerializer.Deserialize&lt;List&lt;User&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">(usersJson);\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> user <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> users)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">yield</span> <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> user;\n    }\n}\n​\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用异步LINQ查询</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> distinctUsers = <span style=\"color: rgba(0, 0, 255, 1);\">await</span> GetUsersAsync().DistinctByAsync(user =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> user.Name).ToListAsync();\n​\n</span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> user <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> distinctUsers)\n{\n    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Name: {user.Name}, Age: {user.Age}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n}</span></pre>\n</div>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\" style=\"font-size: 16px;\">总结</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" style=\"font-size: 16px;\"><code>DistinctBy</code><span class=\"md-plain\"> 方法是 .NET 6 和 .NET 7 中 LINQ 的一个非常实用的新特性。我们在 LINQ 查询中根据指定的键对集合进行去重，简化了代码并提高了开发效率。</span></span></p>\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain\" style=\"font-size: 16px;\">希望本文能帮助大家更好地理解和利用 .NET 6 和 .NET 7 中 LINQ 的 <span class=\"md-pair-s\"><code>DistinctBy</code><span class=\"md-plain md-expand\"> 方法，从而在项目中发挥更大的作用。</span></span></span></p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\" style=\"font-size: 16px;\">最后</span></h2>\n<p><span class=\"md-plain\" style=\"font-size: 16px;\"><span class=\"md-plain md-expand\">如果你觉得这篇文章对你有帮助，不妨点个赞支持一下！你的支持是我继续分享知识的动力。如果有任何疑问或需要进一步的帮助，欢迎随时留言。也可以加入微信公众号&nbsp;<span class=\"md-pair-s \"><strong>[DotNet技术匠]</strong><span class=\"md-plain md-expand\">&nbsp;社区，与其他热爱技术的同行一起交流心得，共同成长！</span></span></span></span></p>\n<p><span class=\"md-plain\" style=\"font-size: 16px;\"><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/576536/202408/576536-20240813102419584-1596250541.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 16:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/1312mn\">小码编匠</a>&nbsp;\n阅读(<span id=\"post_view_count\">229</span>)&nbsp;\n评论(<span id=\"post_comment_count\">3</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "扣子Coze实战：从0到1打造抖音+小红书热点监控智能体",
      "link": "https://www.cnblogs.com/tangshiye/p/19575161",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tangshiye/p/19575161\" id=\"cb_post_title_url\" title=\"发布于 2026-02-04 16:30\">\n    <span>扣子Coze实战：从0到1打造抖音+小红书热点监控智能体</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>大家好，我是汤师爷，专注AI智能体分享，致力于帮助100W人用智能体创富~</p>\n<p>热点监控智能体是帮你自动发现爆款选题的利器。</p>\n<p>它能全天候扫描各大平台的热门内容，从海量信息中筛选出最有价值的话题和创意。</p>\n<p>你不需要再手动搜索，智能体会自动将热点内容整理成表格，让你清晰直观地掌握行业动态。</p>\n<h3 id=\"1-为什么要做热点监控\">1 为什么要做热点监控</h3>\n<p>热点监控是内容创作者和营销人员的必备工具，它帮助我们在信息爆炸时代精准把握用户关注点，提升内容效果和影响力。以下是进行热点监控的四大核心理由：</p>\n<p><strong>1. 把握用户兴趣，提高内容相关性</strong></p>\n<p>用户的注意力是稀缺资源。通过实时监控热点话题，我们能了解目标受众当下最关心的问题和兴趣点。热点本质上是用户兴趣的集中体现，基于热点创作的内容自然具有更高的用户匹配度，更容易获得关注和互动。</p>\n<p><strong>2. 节约选题时间，提高创作效率</strong></p>\n<p>没有热点监控系统时，创作者需要在各平台间不断切换，手动搜索和筛选信息，这个过程既耗时又低效。自动化热点监控能持续追踪多平台热门内容，将重复性工作交给智能体，让创作者能专注于内容创作本身。</p>\n<p><strong>3. 抓住时机，提高曝光机会</strong></p>\n<p>热点具有明显的时效性，越早参与讨论，获得的曝光机会就越多。自动化热点监控系统能在热点刚出现时就发出提醒，帮助创作者抢占先机。比起等热点完全爆发后再跟进，提前布局能获得更多流量红利和平台算法青睐。</p>\n<p><strong>4. 发现内容机会，避免同质化</strong></p>\n<p>热点监控不只是追踪已经爆发的话题，更重要的是发现潜在新兴热点。通过分析热点数据，创作者可以识别尚未被充分挖掘的内容机会，避开同质化竞争，找到差异化表达角度，从而在激烈的内容竞争中脱颖而出。</p>\n<h3 id=\"2-热点监控智能体搭建流程\">2 热点监控智能体搭建流程</h3>\n<p>智能体的搭建流程主要分为两个步骤：梳理工作流和设置智能体。</p>\n<p><strong>1、梳理工作流</strong></p>\n<p>热点监控工作流是一套自动化信息采集和处理系统，能将人工需要几小时甚至几天完成的工作压缩至几分钟内自动完成。这一工作流主要包含三大环节：</p>\n<p><strong>（1）根据关键词，批量获取热门视频</strong></p>\n<p>系统根据预设的关键词（如行业热词、产品名称、竞品信息等），自动从抖音、小红书等平台搜索相关视频。这一步骤替代了手动搜索和浏览结果的过程，大幅提高效率。</p>\n<p><strong>（2）批量获取视频详细信息</strong></p>\n<p>获取视频列表后，系统进一步抓取每个视频的详细数据，包括：</p>\n<ul>\n<li>基础信息：视频ID、标题、链接、发布时间、视频时长等</li>\n<li>互动数据：点赞数、评论数、收藏数、分享数等关键指标</li>\n<li>创作者信息：作者名称、用户ID、个人简介等</li>\n</ul>\n<p>这些数据是分析视频热度和受欢迎程度的关键指标，也是判断内容价值的重要依据。系统将这些零散数据整合成结构化信息，便于后续分析。</p>\n<p><strong>（3）将数据添加到多维表格</strong></p>\n<p>最后，系统将处理好的数据自动导入到预设的飞书多维表格中。</p>\n<p>通过这样的自动化处理，我们能建立一个实时更新的热点内容库，随时查看行业动态，发现爆款选题灵感。</p>\n<p>这种工作流显著减轻了运营人员的工作负担，让我们能将更多精力投入到内容创作和策略制定上。</p>\n<p><strong>2、设置智能体</strong></p>\n<p>完成工作流搭建后，我们需要创建一个热点监控智能体来执行这个工作流。智能体设置过程分为三个关键步骤：</p>\n<ol>\n<li>设置人设与逻辑：配置智能体的特征、回复风格和决策逻辑</li>\n<li>绑定工作流：将工作流与智能体关联，赋予它执行具体任务的能力</li>\n<li>测试并发布：进行全面功能测试，确认一切正常后将智能体正式发布到生产环境</li>\n</ol>\n<p>完成这三个步骤后，我们就成功搭建了一个热点监控智能体。</p>\n<h3 id=\"3-抖音热点监控工作流\">3 抖音热点监控工作流</h3>\n<p>前面我们详细介绍了热点监控的重要性和智能体搭建的基本流程，接下来我们将深入了解如何实际搭建一个抖音热点监控工作流。</p>\n<p>登录Coze官网，在“资源库-工作流”里新建一个空白工作流，取名“fetch_douyin_hot_videos”。</p>\n<p>工作流整体预览如图所示。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>1、开始节点</strong></p>\n<p>这里用于定义工作流启动时所需的输入参数。如图6-2所示。</p>\n<ul>\n<li>输入：\n<ul>\n<li>keywords：用于搜索热点的关键词，可以是产品名称、行业术语、竞品名称或热门话题，系统会自动搜索相关的热门内容</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>2、插件节点：根据关键词，批量获取热门视频</strong></p>\n<p>我们将使用\"视频搜索\"插件的\"douyin_search\"工具。通过这个功能，我们可以根据关键词批量获取热门视频。</p>\n<ul>\n<li>输入：\n<ul>\n<li>api_token：这里需要填入你的API密钥，可以从插件的官方平台获取，它是调用视频数据的重要凭证，相当于你的身份证明</li>\n<li>keyword：关键词，从开始节点获取</li>\n<li>page：获取第几页的内容</li>\n<li>publish_time：发布时间，可用值为_0(不限)、_1(一天之内)、_7(一周之内)、_180(半年之内)，这里我们选择_7</li>\n<li>sort_type：排序类型，可用值：_0(综合)、_1(最多点赞)、_2(最新发布)，这里我们选择_1</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>4、批处理节点：批量获取视频详细信息</strong></p>\n<p>批量获取视频详细信息是工作流中的核心节点，它负责将上一步骤中获取的视频列表进一步深入处理，获取每个视频的完整信息。</p>\n<ul>\n<li>输入：\n<ul>\n<li>并行运行数量：设置适当的并行数量可提高工作流执行效率，设置为1则按顺序串行执行</li>\n<li>批处理次数上限：批处理操作不会超过这个设定的最大次数</li>\n<li>aweme_list：从\"根据关键词，批量获取热门视频\"节点输出中，选择data，类型为Array</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>5、批处理体内插件节点：获取单个视频详细信息</strong></p>\n<p>接下来，我们需要添加批处理体内的节点。我们将使用\"视频搜索\"插件的douyin_data工具，通过这个功能可以根据抖音视频链接获取视频的详细信息。</p>\n<ul>\n<li>输入：\n<ul>\n<li>api_token：API密钥</li>\n<li>douyin_url：从\"批量获取视频详细信息\"节点的输出中，选择share_url</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>6、批处理体内代码节点：将视频详情整合进视频列表中</strong></p>\n<p>这一步将从抖音API获取的详细视频信息与之前收集的视频列表数据合并。</p>\n<p>通过这个过程，我们能掌握每个视频的完整信息，包括互动数据（点赞、评论、收藏数）、创作者信息和内容详情，从而为后续分析提供全面的数据基础。</p>\n<ul>\n<li>输入：\n<ul>\n<li>aweme_detail：从\"获取单个视频详细信息\"节点的输出中，选择aweme_detail</li>\n<li>aweme：从\"批量获取视频详细信息\"节点的输出中，选择item</li>\n</ul>\n</li>\n<li>输出：\n<ul>\n<li>aweme_list：变量类型设置为 Array 对象数组，表示处理后的视频列表</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>下面是处理数据的Python代码，它会将视频信息转换成我们需要的格式。</p>\n<pre><code class=\"language-python\">async def main(args: Args) -&gt; Output:\n    params = args.params\n    aweme_detail = params.get(\"aweme_detail\", {})\n    aweme = params.get(\"aweme\", {})\n    aweme[\"aweme_detail\"] = aweme_detail\n\n    ret: Output = {\n        \"aweme_list\": [aweme]\n    }\n    return ret\n</code></pre>\n<p><strong>7、批处理体内代码节点：将信息整理为飞书表格可以使用的数据</strong></p>\n<p>在这个环节中，我们会提取视频的核心信息（如标题、点赞数、评论数等），并将它们转换成飞书表格能够直接识别和处理的格式。</p>\n<ul>\n<li>输入：\n<ul>\n<li>aweme_list：从\"将视频详情整合进视频列表中\"节点的输出中，选择aweme_list</li>\n<li>keywords：从开始节点中，选择keywords</li>\n</ul>\n</li>\n<li>输出：\n<ul>\n<li>records：处理后的表格数据，选择Array类型</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>下面是处理数据的Python代码，这段代码非常重要，它负责将抖音API返回的原始数据转换成结构化的表格数据。</p>\n<pre><code class=\"language-python\">async def main(args: Args) -&gt; Output:\n    params = args.params\n    aweme_list = params.get(\"aweme_list\", [])\n\n    result = []\n\n    # 遍历 aweme_list，依次处理\n    for aweme in aweme_list:\n\n        # 获取 aweme_detail 并判空\n        aweme_detail = aweme.get(\"aweme_detail\") or {}\n        title = aweme_detail.get(\"desc\") or \"\"\n        link = aweme_detail.get(\"share_url\") or \"\"\n\n        # 安全获取 statistics\n        statistics = aweme_detail.get(\"statistics\") or {}\n\n        # 提取各字段信息，并在取值时加默认值\n        video_id = statistics.get(\"aweme_id\") or \"\"\n        digg_count = statistics.get(\"digg_count\") or 0\n        comment_count = statistics.get(\"comment_count\") or 0\n        collect_count = statistics.get(\"collect_count\") or 0\n        share_count = statistics.get(\"share_count\") or 0\n\n        # 获取作者信息\n        author_info = aweme_detail.get(\"author\") or {}\n        author_name = author_info.get(\"nickname\") or \"\"\n        signature = author_info.get(\"signature\") or \"\"\n        sec_uid = author_info.get(\"sec_uid\") or \"\"\n        raw_create_time = aweme_detail.get(\"create_time\", 0)\n        # 如果不是 int，就尝试转换，失败则为 0\n        try:\n            create_time = int(raw_create_time)\n        except (TypeError, ValueError):\n            create_time = 0\n\n        # 创建时间以毫秒计，避免 None 或非法值导致报错\n        create_time_ms = create_time * 1000\n\n        raw_duration = aweme_detail.get(\"duration\", 0)\n        # 如果不是数字，尝试转换为 float，失败则为 0\n        try:\n            duration = float(raw_duration)\n        except (TypeError, ValueError):\n            duration = 0.0\n        duration_sec = duration / 1000\n\n        # 组装返回数据\n        item_dict = {\n            \"fields\": {\n                \"视频ID\": video_id,\n                \"标题\": title.strip(),\n                \"关键词\": params.get(\"keywords\", \"\"),\n                \"链接\": {\n                    \"text\": \"查看视频\",\n                    \"link\": link.strip(),\n                },\n                \"点赞数\": digg_count,\n                \"评论数\": comment_count,\n                \"收藏数\": collect_count,\n                \"分享数\": share_count,\n                \"作者\": author_name,\n                \"用户简介\": signature,\n                \"用户ID\": sec_uid,\n                \"发布日期\": create_time_ms,  # 毫秒级时间戳\n                \"时长\": duration_sec        # 秒\n            }\n        }\n        result.append(item_dict)\n\n    return result\n</code></pre>\n<p><strong>8、批处理体内插件节点：将数据添加到多维表格</strong></p>\n<p>首先，我们需要创建一个多维表格并设置好表头字段，为后续数据采集做好准备。这个表格是存储和分析抖音热点视频数据的核心，因此表头设计至关重要。我们应包含视频ID、标题、点赞数、评论数等关键信息，便于后期分析和筛选。创建好的表格界面如下图所示。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>选择\"飞书表格\"插件节点的add_records工具，将数据添加到多维表格。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<ul>\n<li>输入：\n<ul>\n<li>app_token：提前创建一个多维表格，将多维表格的链接复制进去。</li>\n<li>records：从\"将信息整理为飞书表格可以使用的数据\"的输出变量中，选择records。</li>\n<li>table_id：多维表格数据表的唯一标识符，如图6-10所示。</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>9、结束节点</strong></p>\n<p>选择\"返回文本\"，并将回答内容设置为：\"获取关键词下的所有抖音视频【完成】\"。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"4抖音热点监控智能体设置\">4.抖音热点监控智能体设置</h3>\n<p>到目前为止，我们已经介绍了抖音热点监控工作流的搭建过程。接下来，我们将介绍抖音热点监控智能体的设置。这个环节将工作流与智能体绑定，只有完成这一步，我们才能真正实现抖音热点监控智能体的功能。</p>\n<p>接下来，我们将逐步指导你完成整个设置过程，包括创建智能体、配置基本参数、连接工作流以及进行测试，帮助你快速掌握这项实用技能。</p>\n<p><strong>1、新建智能体</strong></p>\n<p>在Coze平台创建一个新的智能体，将其命名为\"抖音热点监控智能体\"。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>2、设置人设与逻辑</strong></p>\n<p>设置人设与逻辑是创建智能体的关键步骤。在这一环节，我们需要明确智能体的行为模式和响应方式。</p>\n<p>对于抖音热点监控智能体，我们希望它能直接执行任务，无需过多交互。因此，我们设置简单明了的指令，让智能体在接收到关键词后立即执行视频采集工作。</p>\n<pre><code>直接执行`fetch_douyin_hot_videos`\n</code></pre>\n<p><strong>3、绑定工作流</strong></p>\n<p>把\"fetch_douyin_hot_videos\"工作流添加到智能体中。这个工作流是我们之前设计的抖音视频采集工作流，将它绑定到智能体后，用户只需输入关键词，智能体就会自动执行工作流，帮助我们高效地收集抖音热点视频。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>5、测试并发布</strong></p>\n<p>在预览与调试窗口中输入关键词，测试智能体采集热点抖音视频的功能。系统会自动执行工作流，并将结果添加到飞书表格中。</p>\n<p>使用不同关键词进行多次测试，确保智能体在各种情况下都能稳定运行。测试无误后，点击\"发布\"按钮将智能体正式发布到生产环境，供用户使用。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"5小红书热点监控工作流\">5.小红书热点监控工作流</h3>\n<p>接下来我们将深入了解如何实际搭建一个小红书热点监控工作流。</p>\n<p>这个工作流能帮你自动收集小红书平台上的热门内容，让你不用手动浏览就能掌握最新趋势。</p>\n<p>我们将使用简单易懂的步骤，带你从零开始构建这个强大的监控系统，即使你没有编程经验也能轻松上手。</p>\n<p>登录Coze官网，在“资源库-工作流”里新建一个空白工作流，取名“xhs_keywords”。工作流整体预览如图所示。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>1、开始节点</strong></p>\n<p>这里用于定义工作流启动时所需的输入参数。</p>\n<ul>\n<li>输入：\n<ul>\n<li>foldUrl：飞书表格链接，需要提前创建好一个飞书多维表格，并复制其链接。该表格将用于存储我们采集到的小红书热点视频</li>\n<li>cookie：小红书网站的cookie信息，这是访问小红书API的必要凭证，我们将在后面详细讲解如何获取</li>\n<li>keywords：用于搜索热点的关键词，可以是产品名称、行业术语、竞品名称或热门话题，系统会自动搜索相关的热门内容</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>2、如何获取小红书cookie</strong></p>\n<p>在Chrome浏览器中，登录小红书主页：<a href=\"https://www.xiaohongshu.com/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.xiaohongshu.com/</a></p>\n<p>按F12键打开开发者工具面板，然后按照以下步骤操作：</p>\n<ul>\n<li>第一步：点击「网络」选项卡</li>\n<li>第二步：点击「文档」标签</li>\n<li>第三步：点击「explore」文档</li>\n<li>第四步：点击「标头」选项卡</li>\n<li>第五步：滚动页面找到Cookie字段，复制整段Cookie信息。</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>2、插件节点：根据关键词获取笔记</strong></p>\n<p>我们将使用“小红书”插件的xhs_search_note工具。通过这个功能，我们可以根据关键词，批量获取热门视频。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<ul>\n<li>输入：\n<ul>\n<li>cookieStr：开始节点的 cookie</li>\n<li>keywords：关键词，从开始节点获取</li>\n<li>notType：查询类型（0=全部，1=视频，2=图文），这里我们选择1 视频类型</li>\n<li>sort：排序（默认为综合，0=综合，1=最新，2=最热），这里我们选择2 最热</li>\n<li>totalNumber：查询总数，这里我们输入20</li>\n</ul>\n</li>\n</ul>\n<p><strong>3、循环节点：循环获取笔记详情</strong></p>\n<p>循环获取笔记详情是工作流中的关键环节，它使我们能够一次性处理多条小红书笔记。从搜索结果中获取笔记链接后，我们需要逐一获取每条笔记的详细信息，包括标题、内容、作者和点赞数等。</p>\n<ul>\n<li>输入：\n<ul>\n<li>input：从\"根据关键词获取笔记\"节点的输出中，选择 data</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>4、循环体内插件节点：获取笔记详情</strong></p>\n<p>我们将使用小红书插件的xhs_note_detail工具。该工具能获取每条笔记的完整信息，包括标题、内容、作者信息和互动数据等。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<ul>\n<li>输入\n<ul>\n<li>cookieStr：开始节点的 cookie</li>\n<li>noteUrl：从 “循环笔记详情” 节点的输出中，选择 noteUrl</li>\n</ul>\n</li>\n</ul>\n<p><strong>5、循环体内插件节点：提取视频文案</strong></p>\n<p>我们将使用\"字幕获取\"插件的generate_video_captions_sync工具。该工具能自动从视频中提取文字内容，将口述转换为文本，省去手动听写的麻烦。它能精准识别视频中的语音并生成文字记录，帮助我们快速理解视频的主题和关键信息。</p>\n<p>输入：</p>\n<ul>\n<li>url：从\"获取笔记详情\"节点的输出中，选择 video_h264_url，表示H264标准编码格式视频链接</li>\n<li>lang：视频语言，如汉语、英语等，不填时默认为汉语</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>6、循环体内代码节点：将笔记数据整理成飞书表格格式</strong></p>\n<p>这一步将采集到的视频信息转换为标准化数据结构，以便写入飞书表格。我们需要提取视频的标题、内容、作者和点赞数等关键信息，并按飞书表格要求进行格式化。这样不仅便于数据整理和筛选，还能帮助我们更直观地分析热门内容的特点。</p>\n<ul>\n<li>输入\n<ul>\n<li>input：从\"获取笔记详情\"节点的输出中，选择note</li>\n<li>data：从\"提取视频文案\"节点的输出中，选择data</li>\n</ul>\n</li>\n<li>输出\n<ul>\n<li>records：变量类型设置为 Array 对象数组，表示处理后的视频列表</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>下面是处理数据的Python代码，它将采集到的小红书视频信息转换为标准格式，便于存储和分析。</p>\n<p>代码提取视频的标题、内容、作者等关键信息，将其组织成飞书表格所需的格式，然后返回处理好的数据。这样我们能将所有热门视频整齐地存放在同一张表格中，方便后续分析：</p>\n<pre><code class=\"language-python\">async def main(args: Args) -&gt; Output:\n    input_data = args.params.get('input')  or {}\n    data = args.params.get('data') or {}\n\n    records = []  # 初始化 records 列表\n\n    # 提取 note 相关字段\n    title = input_data.get('note_display_title', '')  # 标题\n    desc = input_data.get('note_desc', '')  # 描述\n    url = input_data.get('note_url', '')  # 链接\n    nickname = input_data.get('auther_nick_name', '')  # 作者昵称\n    likedCount = input_data.get('note_liked_count', '0')  # 点赞数\n    videoUrl = input_data.get('video_h264_url', '')  # 视频地址\n    collectedCount = input_data.get('collected_count', '0')  # 收藏数\n    imageList = input_data.get('note_image_list', [])  # 图片列表\n\n    # 构建记录对象\n    record = {\n        \"fields\": {\n            \"笔记链接\": url,\n            \"标题\": title,\n            \"内容\": desc,\n            \"作者\": nickname,\n            \"点赞数\": likedCount,\n            \"链接\": {\n                \"link\": url,\n                \"text\": title\n            },\n            \"收藏数\": collectedCount,\n            \"图片地址\": '\\n'.join(imageList),  # 将图片列表拼接成字符串\n            \"视频地址\": videoUrl,\n            \"视频文案\": data.get(\"content\", \"\") \n        }\n    }\n    records.append(record)  # 将记录对象添加到 records 列表中\n\n    # 构建输出对象\n    ret: Output = {\n        \"records\": records\n    }\n    return ret\n</code></pre>\n<p><strong>7、循环体内插件节点：写入飞书表格</strong></p>\n<p>最后，我们将收集到的所有数据添加到飞书多维表格中。</p>\n<p>我们需要提前创建一个多维表格，并设置好对应的表头字段。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>表头字段包括视频的所有关键信息：笔记链接、标题、内容、作者、点赞数、链接、收藏数、图片地址、视频地址和视频文案。</p>\n<p>接下来，选择\"飞书表格\"插件节点的add_records工具，将采集到的数据添加到多维表格中。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<ul>\n<li>输入：\n<ul>\n<li>app_token：提前创建一个多维表格，然后将多维表格的链接复制到此处。</li>\n<li>records：从\"将信息整理为飞书表格可以使用的数据\"节点的输出变量中，选择records。</li>\n<li>table_id：需填入多维表格数据表的唯一标识符。</li>\n</ul>\n</li>\n</ul>\n<p><strong>8、结束节点</strong></p>\n<p>最后添加结束节点，完成整个工作流程。如图6-25所示。</p>\n<ul>\n<li>输出：\n<ul>\n<li>output：开始节点的foldUrl，也就是飞书多维表格的链接</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"6小红书热点监控智能体设置\">6.小红书热点监控智能体设置</h3>\n<p>至此，我们已完成小红书热点监控工作流的搭建。接下来，我们将介绍如何设置小红书热点监控智能体。这个关键环节将工作流与智能体绑定在一起，只有完成这一步，才能真正实现小红书热点监控智能体的功能。</p>\n<p><strong>1、新建智能体</strong></p>\n<p>在Coze平台创建一个新的智能体，命名“小红书热点监控智能体”。如图6-26所示。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>2、设置人设与逻辑</strong></p>\n<p>设置人设与逻辑是创建智能体的关键步骤。在这一环节，我们需要明确智能体的行为模式和响应方式。</p>\n<p>对于小红书热点监控智能体，我们希望它能直接执行任务，无需过多交互。因此，我们设置简单明了的指令，让智能体在接收到关键词后立即执行视频采集工作。</p>\n<pre><code>直接执行`xhs_keywords`\n</code></pre>\n<p><strong>3、绑定工作流</strong></p>\n<p>把\"xhs_keywords\"工作流添加到智能体中。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>4、测试并发布</strong></p>\n<p>在预览与调试窗口中输入关键词，测试智能体的小红书热点视频采集功能。系统会自动执行工作流，并将结果直接添加到飞书表格中。</p>\n<blockquote>\n<p>对了，我整理了一份开源的智能体学习手册，爆肝 10 万字，价值 999 元。限时开放领取👉：<a href=\"https://tangshiye.cn\" rel=\"noopener nofollow\" target=\"_blank\">tangshiye.cn</a></p>\n</blockquote>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/tangshiye/\" target=\"_blank\">AI架构师汤师爷</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/tangshiye/p/19575161\" target=\"_blank\">https://www.cnblogs.com/tangshiye/p/19575161</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-04 16:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tangshiye\">AI架构师汤师爷</a>&nbsp;\n阅读(<span id=\"post_view_count\">142</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}