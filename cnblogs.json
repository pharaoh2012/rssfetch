{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "Windows11 制作 Ubuntu 20.04 系统盘",
      "link": "https://www.cnblogs.com/zylyehuo/p/19614602",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zylyehuo/p/19614602\" id=\"cb_post_title_url\" title=\"发布于 2026-02-14 16:18\">\n    <span>Windows11 制作 Ubuntu 20.04 系统盘</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>博客地址：<a href=\"https://www.cnblogs.com/zylyehuo/\" target=\"_blank\">https://www.cnblogs.com/zylyehuo/</a></p>\n</blockquote>\n<blockquote>\n<p>参考链接：<a href=\"https://blog.csdn.net/2303_78594540/article/details/153266630\" rel=\"noopener nofollow\" target=\"_blank\">使用 Rufus 制作启动盘安装 Windows 与 Ubuntu 系统全流程教程（图文详解+避坑指南）</a></p>\n</blockquote>\n<blockquote>\n<p>准备一个 U 盘（8GB 以上）</p>\n</blockquote>\n<h1 id=\"第一步格式化-u-盘\">第一步：格式化 U 盘</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214153200456-1658236593.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214154530904-1344139924.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214154544248-548940399.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214154620298-1017947541.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214154635884-1597073247.png\" /></p>\n<h1 id=\"第二步下载-ubuntu-2004-镜像文件\">第二步：下载 Ubuntu 20.04 镜像文件</h1>\n<blockquote>\n<p><a href=\"https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/20.04/\" rel=\"noopener nofollow\" target=\"_blank\">清华大学开源软件镜像站</a></p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214091350572-1142136485.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214155759048-1276446348.png\" /></p>\n<h1 id=\"第三步安装-rufus-工具\">第三步：安装 rufus 工具</h1>\n<blockquote>\n<p><a href=\"https://rufus.ie/en/\" rel=\"noopener nofollow\" target=\"_blank\">Rufus</a></p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214133040904-1081144763.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214133057686-1399466211.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214133238248-301278326.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214133248815-516656742.png\" /></p>\n<h1 id=\"第四步将下载的-iso-镜像文件写入-u-盘\">第四步：将下载的 iso 镜像文件写入 U 盘</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214153439374-991017667.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214154744901-197704150.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214154815985-1847206609.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214154834507-1019613382.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214154903825-451666582.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214154928441-207328798.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214160531909-1553002814.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214161633448-1934286003.png\" /></p>\n<h1 id=\"第五步检查是否写入成功\">第五步：检查是否写入成功</h1>\n<blockquote>\n<p>制作成功的启动盘在电脑中会显示如下，U盘已经自动被修改了名称，且包含必要文件</p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214161651002-1958615561.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202602/3071480-20260214161708803-1967959525.png\" /></p>\n<blockquote>\n<p>至此，ubuntu启动盘制作完成。</p>\n</blockquote>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-14 16:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zylyehuo\">zylyehuo</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "又一款国产开源企业级文件管理系统诞生了！基于 Spring Boot 3.5.x + Sa-Token + MyBatis Flex",
      "link": "https://www.cnblogs.com/javaguide/p/19616059",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/javaguide/p/19616059\" id=\"cb_post_title_url\" title=\"发布于 2026-02-14 15:52\">\n    <span>又一款国产开源企业级文件管理系统诞生了！基于 Spring Boot 3.5.x + Sa-Token + MyBatis Flex</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n            <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>前几天在技术群里看到大家讨论企业网盘选型。付费的太贵，开源的功能不够完整，部署维护又麻烦——这些问题很多团队都遇到过。想要一个能处理大文件、支持在线预览、还能多云存储的方案，确实不容易找。</p>\n<p>Dromara 开源社区前段时间新进了一个基于 Spring Boot 的文件管理系统 —— Free-FS，我研究了一下，功能比较完整，架构也清晰，分享给大家（JavaGuide 所有开源项目分享都无商务性质，纯分享，欢迎自荐，地址： <a href=\"https://github.com/CodingDocs/awesome-java%EF%BC%89%E3%80%82\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/CodingDocs/awesome-java）。</a></p>\n<p><img alt=\"图片\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200920-1716388728.webp\" /></p>\n<h2 id=\"free-fs-是什么\"><strong>Free-FS 是什么？</strong></h2>\n<p>Free-FS 是一个企业级文件管理系统后端，基于 Spring Boot 3.5 + MyBatis Flex + Sa-Token + React/Vue 构建。</p>\n<p>主要功能包括大文件分片上传/断点续传/秒传、多格式在线预览、多云存储插件化扩展、权限控制、回收站等。有配套的 Vue 3 前端。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200958-1718842586.webp\" /></p>\n<p>这里给不懂的朋友简单解释下上面提到的几个关键术语：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">术语</th>\n<th style=\"text-align: left;\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>分片上传</strong></td>\n<td style=\"text-align: left;\">把大文件切成多个小块分别上传，网络中断后只需上传未完成的分片</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>断点续传</strong></td>\n<td style=\"text-align: left;\">记录上传进度，中断后从断点继续，不用重新上传整个文件</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>秒传</strong></td>\n<td style=\"text-align: left;\">通过计算文件哈希值（如 MD5、SHA-256），如果服务器已有相同哈希的文件，直接建立引用而不上传实际数据</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"它解决了什么问题\"><strong>它解决了什么问题？</strong></h2>\n<p>企业文件管理常见的几个麻烦：</p>\n<ul>\n<li><strong>大文件上传困难</strong>：没有分片上传、断点续传，网络一中断就得重新开始</li>\n<li><strong>存储平台绑定</strong>：绑死单一云存储，切换成本高，迁移困难</li>\n<li><strong>预览能力弱</strong>：只支持少数格式，Office/图片/PDF 预览要额外配置</li>\n<li><strong>权限管理粗糙</strong>：缺少细粒度权限控制，无法满足企业安全要求</li>\n<li><strong>部署复杂</strong>：依赖多、配置繁琐，开箱即用困难</li>\n</ul>\n<p>Free-FS 用主流技术栈做了一个功能完整、架构清晰、可扩展的文件管理后端。</p>\n<h2 id=\"核心功能\"><strong>核心功能</strong></h2>\n<h3 id=\"文件管理\"><strong>文件管理</strong></h3>\n<p>支持列表和网格两种视图。</p>\n<p><img alt=\"图片\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200928-973813390.webp\" /></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200936-1846826600.webp\" /></p>\n<h3 id=\"大文件上传与秒传\"><strong>大文件上传与秒传</strong></h3>\n<p>前端把大文件切片并行上传，后端通过 SSE 实时推进度，精确到每个分片的状态。网络中断后，系统记录断点位置，续传时从断点继续。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200939-1166332110.webp\" /></p>\n<p>秒传的原理是先算文件 MD5 发给服务端，服务器有相同哈希的文件就直接建立引用，跳过数据传输。所以上传几个 G 的文件有时能\"秒完\"。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200907-1394867558.webp\" /></p>\n<h3 id=\"多云存储插件化\"><strong>多云存储插件化</strong></h3>\n<p>存储层用 SPI 插件化设计，把存储能力抽象成统一接口。</p>\n<p>内置的存储实现有本地存储、阿里云 OSS、七牛云 Kodo、AWS S3 兼容存储、RustFS。</p>\n<p>一套系统可以管理多个存储平台，按需分配或一键切换。新增存储平台只要实现核心接口并注册，不用改主业务代码。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200904-1719820535.webp\" /></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200945-674949107.webp\" /></p>\n<p>添加存储配置</p>\n<h3 id=\"在线预览\"><strong>在线预览</strong></h3>\n<p>支持五大类文件预览：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">类型</th>\n<th style=\"text-align: left;\">支持格式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">图片</td>\n<td style=\"text-align: left;\">jpg/png/gif/webp/svg 等</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Office 文档</td>\n<td style=\"text-align: left;\">doc/docx/xls/xlsx/ppt/pptx（需要 LibreOffice）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">文本代码</td>\n<td style=\"text-align: left;\">30+ 种编程语言语法高亮</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">音视频</td>\n<td style=\"text-align: left;\">流式播放</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">压缩包</td>\n<td style=\"text-align: left;\">查看目录结构</td>\n</tr>\n</tbody>\n</table>\n<p>Office 文档通过 LibreOffice 转成 PDF 后交给前端，转换用进程池模式，可以配置并发度和超时。</p>\n<h3 id=\"权限与安全\"><strong>权限与安全</strong></h3>\n<p>用 Sa-Token 做权限认证，JWT 无状态会话，支持分布式部署。</p>\n<p>权限可以控制到文件的查看、下载、编辑、删除等操作。</p>\n<h3 id=\"文件分享和回收站\"><strong>文件分享和回收站</strong></h3>\n<p>文件分享有公开链接和授权码两种模式，授权码分享能设置有效期和访问次数。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200953-1235074064.webp\" /></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200890-1175658548.webp\" /></p>\n<p>回收站给删除操作一个缓冲区，支持批量还原、永久删除和自动清理。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200924-1191218721.webp\" /></p>\n<p>回收站</p>\n<h2 id=\"安装与快速上手\"><strong>安装与快速上手</strong></h2>\n<h3 id=\"环境要求\"><strong>环境要求</strong></h3>\n<ul>\n<li>JDK 17+</li>\n<li>Maven 3.8+</li>\n<li>MySQL 8.0+ 或 PostgreSQL 14+（二选一）</li>\n<li>Redis</li>\n<li>LibreOffice (可选，用于 Office 文档预览功能)</li>\n</ul>\n<h3 id=\"安装步骤\"><strong>安装步骤</strong></h3>\n<pre><code>git clone https://gitee.com/dromara/free-fs.git\ncd free-fs\nmvn clean install -DskipTests\n</code></pre>\n<h3 id=\"数据库初始化\"><strong>数据库初始化</strong></h3>\n<p>MySQL：</p>\n<pre><code>CREATE DATABASE `free-fs` CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_general_ci';\n</code></pre>\n<p>PostgreSQL：</p>\n<pre><code>CREATE DATABASE free-fs ENCODING 'UTF8' LC_COLLATE='zh_CN.UTF-8' LC_CTYPE='zh_CN.UTF-8';\n</code></pre>\n<p>数据库创建完成之后，导入项目根目录下对应的 SQL 文件到刚创建的数据库中：</p>\n<ul>\n<li>MySQL: <code>_sql/mysql/free-fs.sql</code></li>\n<li>PostgreSQL: <code>_sql/postgresql/free-fs_pg.sql</code></li>\n</ul>\n<h3 id=\"配置与运行\"><strong>配置与运行</strong></h3>\n<p>修改 <code>fs-admin/src/main/resources/application-dev.yml</code> 中的数据库和 Redis 配置：</p>\n<pre><code>cd fs-admin\nmvn spring-boot:run\n</code></pre>\n<p>访问地址：</p>\n<ul>\n<li>服务地址：<a href=\"http://localhost:8080\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:8080</a></li>\n<li>API 文档：<a href=\"http://localhost:8080/swagger-ui.html\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost:8080/swagger-ui.html</a></li>\n<li>默认账号：admin / admin</li>\n</ul>\n<p><a href=\"https://javaguide.cn/zhuanlan/interview-guide.html\" rel=\"noopener nofollow\" target=\"_blank\">《SpringAI 智能面试平台+RAG 知识库》</a>配套实战项目教程正在更新，涉及到 Prompt Engineering、大模型集成、RAG（检索增强生成）、高性能对象存储与向量数据库。后续的话，还会同步上Agent 项目。</p>\n<p>内容非常全面，非常适合想要实战 AI 项目或者准备 AI 大模型应用开发岗位面试的朋友，来一张刚写完的<strong>3.4w 字+35 道题目</strong>的 RAG 面试题总结，大家感受一下（点此链接了解： <a href=\"https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html\" rel=\"noopener nofollow\" target=\"_blank\">星球</a>）：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200946-1262024442.webp\" /></p>\n<h2 id=\"技术架构\"><strong>技术架构</strong></h2>\n<h3 id=\"技术栈选型\"><strong>技术栈选型</strong></h3>\n<p>后端用 Spring Boot 3.5.4，搭配 MyBatis Flex 做 ORM 层。</p>\n<p>MyBatis Flex 是 MyBatis 的增强版，和 MyBatis-Plus 有些差异：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200941-432078960.webp\" /></p>\n<p>MyBatis Flex 的详细介绍可以参考这篇文章：<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247549675&amp;idx=1&amp;sn=d74db8ecc003815d890de5aef0baef86&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">再见 MyBatis，这款 ORM 框架确实太优雅！！</a></p>\n<p>认证授权用 Sa-Token，比 Spring Security 简洁。数据库支持 MySQL 8.0+ 和 PostgreSQL 14+，HikariCP 连接池，配合 Caffeine 本地缓存和 Redis 分布式缓存。</p>\n<h3 id=\"项目结构\"><strong>项目结构</strong></h3>\n<p>多模块 Maven 结构：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/1843652/202602/1843652-20260214155200922-414133016.webp\" /></p>\n<p>存储插件用 SPI 设计，<code>storage-plugin-core</code> 定义接口，各存储实现添加新插件模块就行。</p>\n<h2 id=\"与其他方案对比\"><strong>与其他方案对比</strong></h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">对比维度</th>\n<th style=\"text-align: left;\">Free-FS</th>\n<th style=\"text-align: left;\">MinIO</th>\n<th style=\"text-align: left;\">Nextcloud</th>\n<th style=\"text-align: left;\">Seafile</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">技术栈</td>\n<td style=\"text-align: left;\">Spring Boot 3.x</td>\n<td style=\"text-align: left;\">Go</td>\n<td style=\"text-align: left;\">PHP</td>\n<td style=\"text-align: left;\">Go/C</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">定位</td>\n<td style=\"text-align: left;\">后端服务</td>\n<td style=\"text-align: left;\">对象存储</td>\n<td style=\"text-align: left;\">完整网盘</td>\n<td style=\"text-align: left;\">完整网盘</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">大文件上传</td>\n<td style=\"text-align: left;\">分片/断点续传/秒传</td>\n<td style=\"text-align: left;\">需自行实现</td>\n<td style=\"text-align: left;\">支持</td>\n<td style=\"text-align: left;\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">在线预览</td>\n<td style=\"text-align: left;\">多格式支持</td>\n<td style=\"text-align: left;\">需自行实现</td>\n<td style=\"text-align: left;\">支持</td>\n<td style=\"text-align: left;\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">多云存储</td>\n<td style=\"text-align: left;\">插件化切换</td>\n<td style=\"text-align: left;\">单一</td>\n<td style=\"text-align: left;\">支持</td>\n<td style=\"text-align: left;\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">权限管理</td>\n<td style=\"text-align: left;\">Sa-Token 细粒度</td>\n<td style=\"text-align: left;\">简单</td>\n<td style=\"text-align: left;\">细粒度</td>\n<td style=\"text-align: left;\">细粒度</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">部署难度</td>\n<td style=\"text-align: left;\">中（需数据库）</td>\n<td style=\"text-align: left;\">低</td>\n<td style=\"text-align: left;\">中</td>\n<td style=\"text-align: left;\">中</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">开源协议</td>\n<td style=\"text-align: left;\">Apache 2.0</td>\n<td style=\"text-align: left;\">AGPL v3</td>\n<td style=\"text-align: left;\">AGPL v3</td>\n<td style=\"text-align: left;\">GPL-3.0</td>\n</tr>\n</tbody>\n</table>\n<p>只做对象存储的话 MinIO 更合适；需要完整网盘 UI 和协作功能的话 Nextcloud 或 Seafile 更好；需要一个可定制、易集成的文件管理后端，Free-FS 可以考虑。</p>\n<h2 id=\"总结\"><strong>总结</strong></h2>\n<p>Free-FS 用 Spring Boot 3.x + MyBatis Flex + Sa-Token 做了一个功能完整的企业级文件管理后端。</p>\n<ul>\n<li><strong>优势</strong>：功能完整，开箱即用；大文件上传（分片/断点续传/秒传）；插件化存储扩展；多格式在线预览；Sa-Token 权限管理；Apache 2.0 协议友好。</li>\n<li><strong>局限</strong>：需要部署数据库（MySQL/PostgreSQL + Redis）；Office 预览要配置 LibreOffice。</li>\n<li><strong>适用场景</strong>：搭建企业级文件管理系统、需要多云存储支持、需要大文件上传能力。</li>\n</ul>\n<p>建议先部署基础版本跑通上传下载流程，再按需要接入云存储和配置预览。</p>\n<ul>\n<li>后端地址：<strong><a href=\"https://gitee.com/dromara/free-fs\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/dromara/free-fs</a></strong></li>\n<li>前端地址：<strong><a href=\"https://gitee.com/xddcode/free-fs-frontend\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/xddcode/free-fs-frontend</a></strong></li>\n</ul>\n<p><strong>⭐️推荐</strong>:</p>\n<ul>\n<li><a href=\"https://javaguide.cn/home.html\" rel=\"noopener nofollow\" target=\"_blank\">Java 面试 &amp; 后端通用面试指南</a></li>\n<li><a href=\"https://javaguide.cn/zhuanlan/interview-guide.html\" rel=\"noopener nofollow\" target=\"_blank\">《SpringAI 智能面试平台+RAG 知识库》</a></li>\n<li><a href=\"https://javaguide.cn/interview-preparation/java-roadmap.html\" rel=\"noopener nofollow\" target=\"_blank\">Java 学习路线(最新版，4w+字)</a></li>\n<li><a href=\"https://javaguide.cn/interview-preparation/pdf-interview-javaguide.html\" rel=\"noopener nofollow\" target=\"_blank\">后端面试 PDF 最新版</a></li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-02-14 15:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/javaguide\">JavaGuide</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "从0到1，无代码微调并部署本地大语言模型LLM",
      "link": "https://www.cnblogs.com/ClownLMe/p/19615980",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19615980\" id=\"cb_post_title_url\" title=\"发布于 2026-02-14 15:40\">\n    <span>从0到1，无代码微调并部署本地大语言模型LLM</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p><strong>LLM模型微调</strong> 能让大模型掌握特定行业的深度知识，能够实现AI虚拟主播，AI医生，AI程序员，AI网络安全工程师等特定领域的延展。更重要的是，当有本地部署的硬件条件限制时，能够让微调后小的大语言模型等效百亿级的大语言模型</p>\n<p><strong>测试环境：windows11，RTX4070显卡</strong><br />\n<strong>下面将手把手带你跑通无代码模型微调的全过程</strong></p>\n<h1 id=\"环境安装\">环境安装</h1>\n<h3 id=\"必要的工具\">必要的工具：</h3>\n<ul>\n<li>git： <a href=\"https://git-scm.cn/\" rel=\"noopener nofollow\" target=\"_blank\">https://git-scm.cn/</a> （方便拉取资源）</li>\n<li>python： <a href=\"https://www.python.org/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.python.org/</a> （微调和运行必要环境）</li>\n</ul>\n<h3 id=\"流程\">流程：</h3>\n<ol>\n<li>创建文件夹，并拉取 llama-factory项目</li>\n</ol>\n<pre><code class=\"language-bash\">mkdir D:/LLM-Tuning\ncd D:/LLM-Tuning\ngit clone --depth 1 https://github.com/hiyouga/LLaMA-Factory.git\ncd LLaMA-Factory\n</code></pre>\n<ol start=\"2\">\n<li>安装LLaMA-Factory需要的环境</li>\n</ol>\n<pre><code class=\"language-bash\">pip install -e \".[torch,metrics]\"\npip install modelscope\n</code></pre>\n<ol start=\"3\">\n<li>验证环境</li>\n</ol>\n<pre><code class=\"language-bash\">python -c \"import torch; print(torch.cuda.is_available()); print(torch.cuda.get_device_name(0))\"\n</code></pre>\n<p>正常输出如下：</p>\n<p><img alt=\"微调环境验证\" class=\"lazyload\" /></p>\n<blockquote>\n<p>错误：正常来说安装完后验证环境会显示显卡型号，但是我在安装时，会出现报错，原因是它安装了错误的cuda版本，需要重新安装<code>torch</code><br />\n解决方法如下：</p>\n<pre><code>pip uninstall torch torchvision torchaudio\n\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu126\n</code></pre>\n<p>如果其他版本请参考官网： <a href=\"https://pytorch.org/get-started/locally/\" rel=\"noopener nofollow\" target=\"_blank\">https://pytorch.org/get-started/locally/</a></p>\n</blockquote>\n<h1 id=\"微调\">微调</h1>\n<p>这里用于演示，只对模型做一个自我认知的微调</p>\n<h3 id=\"准备数据集\">准备数据集</h3>\n<p><strong>拉取数据集</strong></p>\n<pre><code class=\"language-bash\">git clone https://www.modelscope.cn/datasets/DanKe123abc/yuki_identity_sft.git\n</code></pre>\n<p><strong>修改数据集</strong><br />\n下载完后，目录结构如下：</p>\n<p><img alt=\"微调数据集1\" class=\"lazyload\" /></p>\n<p>我们需要关注的是<code>yuki_identity_sft.jsonl</code>文件，用编辑器将下列文字全局替换：</p>\n<pre><code>Yuki =&gt; 陈千语\nDanKe =&gt; 管理员\n</code></pre>\n<p>效果图如下：</p>\n<p><img alt=\"微调数据集替换\" class=\"lazyload\" /></p>\n<h3 id=\"准备本地模型\">准备本地模型</h3>\n<p>这里使用的是<code>qwen2.5_1.5B</code>用于演示<br />\n<strong>下载模型</strong></p>\n<pre><code class=\"language-python\">from modelscope import snapshot_download\n\ndownload_dir = \"D:\\\\Models\\\\Qwen2.5-1.5B-Instruct\"\n\nmodel_dir = snapshot_download(\n    'qwen/Qwen2.5-1.5B-Instruct', \n    cache_dir=download_dir, \n    revision='master'\n)\n\nprint(f\"下载完成！模型路径为: {model_dir}\")\n</code></pre>\n<h3 id=\"微调-1\">微调</h3>\n<p><strong>配置数据集信息</strong></p>\n<p><img alt=\"配置文件\" class=\"lazyload\" /></p>\n<ol>\n<li>打开<code>D:\\LLM-Tuning\\LLaMA-Factory\\data</code>文件，将刚刚修改好的数据集<code>yuki_identity_sft.jsonl</code>文件拖入文件夹中</li>\n<li>打开<code>dataset_info.json</code>文件，添加新配置：</li>\n</ol>\n<p><img alt=\"数据集配置\" class=\"lazyload\" /></p>\n<pre><code class=\"language-json\">\"MytestData\": {\n&nbsp; &nbsp; \"file_name\":\"yuki_identity_sft.jsonl\",\n&nbsp; &nbsp; \"columns\": {\n&nbsp; &nbsp; &nbsp; \"messages\": \"conversations\"\n&nbsp; &nbsp; },\n&nbsp; &nbsp; \"tags\": {\n&nbsp; &nbsp; &nbsp; \"role_tag\": \"role\",\n&nbsp; &nbsp; &nbsp; \"content_tag\": \"content\",\n&nbsp; &nbsp; &nbsp; \"user_tag\": \"user\",\n&nbsp; &nbsp; &nbsp; \"assistant_tag\": \"assistant\"\n&nbsp; &nbsp; },\n&nbsp; &nbsp; \"formatting\": \"sharegpt\"\n&nbsp; },\n</code></pre>\n<p><strong>打开LLamaFactory微调面板</strong></p>\n<pre><code class=\"language-bash\">python -m llamafactory.cli webui\n</code></pre>\n<p>设置参数如图，其他的默认就行：</p>\n<p><img alt=\"微调参数设置\" class=\"lazyload\" /></p>\n<p>设置完后直接点击开始，模型就开始训练了，训练完后会出现下面提示：</p>\n<p><img alt=\"微调完成\" class=\"lazyload\" /></p>\n<h1 id=\"验证模型\">验证模型</h1>\n<h3 id=\"加载训练完后的lora模型\">加载训练完后的lora模型</h3>\n<p><img alt=\"验证模型\" class=\"lazyload\" /></p>\n<h3 id=\"训练前后的大模型对比\">训练前后的大模型对比</h3>\n<p><strong>训练前</strong></p>\n<p><img alt=\"微调前\" class=\"lazyload\" /></p>\n<p><strong>训练后</strong></p>\n<p><img alt=\"微调后\" class=\"lazyload\" /></p>\n<p><strong>观察图片可以发现，微调后qwen2.5认为自己是陈千语，自己由管理员开发的</strong></p>\n<h1 id=\"大模型部署\">大模型部署</h1>\n<p><strong>下面不是新手向</strong><br />\n如果只是希望学习微调的在这里已经结束了，下面是本系列教程的后续，如何用<code>langchain</code>部署本地的LLM微调大语言模型</p>\n<h3 id=\"环境配置\">环境配置</h3>\n<p>安装需要的环境</p>\n<pre><code class=\"language-bash\">pip install peft langchain langchain-huggingface\n</code></pre>\n<h3 id=\"下面是样例代码\">下面是样例代码</h3>\n<p>代码流程如下：<br />\n<strong>加载基座模型-&gt;加载 LoRA 权重-&gt;正在合并权重-&gt;构建Langchain通道-&gt;调用模型</strong></p>\n<pre><code class=\"language-python\">import torch\nfrom transformers import AutoModelForCausalLM, AutoTokenizer, pipeline\nfrom peft import PeftModel\nfrom langchain_huggingface import HuggingFacePipeline\nfrom langchain_core.prompts import PromptTemplate\n\nBASE_MODEL_PATH = r'D:\\Models\\Qwen2.5-1.5B-Instruct\\qwen\\Qwen2___5-1___5B-Instruct'\nLORA_PATH = r'D:\\D_MyProject\\LLM-Tuning\\LLaMA-Factory\\saves\\Qwen2.5-1.5B\\lora\\train_2026-02-13-23-16-50\\checkpoint-260'\n\nprint(\"1. 正在加载基座模型...\")\ntokenizer = AutoTokenizer.from_pretrained(BASE_MODEL_PATH, trust_remote_code=True)\n\nbase_model = AutoModelForCausalLM.from_pretrained(\n    BASE_MODEL_PATH,\n    torch_dtype=torch.float16,\n    device_map=\"auto\",  \n    trust_remote_code=True\n)\n\nprint(\"2. 正在加载 LoRA 权重 ...\")\nmodel = PeftModel.from_pretrained(base_model, LORA_PATH)\n\nprint(\"3. 正在合并权重 ...\")\nmodel = model.merge_and_unload()\n\nprint(\"4. 构建 LangChain 管道...\")\npipe = pipeline(\n    \"text-generation\",\n    model=model,\n    tokenizer=tokenizer,\n    max_new_tokens=200,    \n    do_sample=True,        \n    temperature=0.7,      \n    repetition_penalty=1.1 \n)\n\nllm = HuggingFacePipeline(pipeline=pipe)\n\nprint(\"\\n=== 陈千语上线 ===\\n\")\n\nrespone = llm.invoke('你好，你是谁？')\nprint(f\"{respone}\")\n</code></pre>\n<h3 id=\"演示效果\">演示效果</h3>\n<p><img alt=\"langchain演示效果\" class=\"lazyload\" /></p>\n<p><strong>至此，我们成功的实现了大模型LLM从微调到部署，把之前的langchain串起来...</strong></p>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/ClownLMe/\" target=\"_blank\">ClownLMe</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/ClownLMe/p/19615980\" target=\"_blank\">https://www.cnblogs.com/ClownLMe/p/19615980</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-14 15:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "全球首位HCCDE-GaussDB认证专家：刘明和他的十一载数据库长跑",
      "link": "https://www.cnblogs.com/huaweiyun/p/19615842",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/huaweiyun/p/19615842\" id=\"cb_post_title_url\" title=\"发布于 2026-02-14 14:47\">\n    <span>全球首位HCCDE-GaussDB认证专家：刘明和他的十一载数据库长跑</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p align=\"center\" style=\"text-align: left;\">在华为云认证体系中，HCCDE作为专家级的认证证书，始终站在技术能力认证的顶点。它不仅是对持证者专业深度的权威认定，更意味着在复杂业务场景下设计高可用、高性能解决方案的能力。</p>\n<p>近日，北京中亦安图科技股份有限公司高级数据库工程师刘明，成为全球首位通过HCCDE-GaussDB认证的专家。从Oracle到GaussDB，他用十一年完成了从商业数据库到国产分布式数据库的跨越，也为国产数据库人才成长路径标注了一条可行的进阶轨迹。</p>\n<p align=\"center\" style=\"text-align: center;\"> <img alt=\"\" class=\"lazyload\" /><br />\n刘明获得的HCCDE-GaussDB认证证书</p>\n<p>&nbsp;</p>\n<p><strong>01&nbsp;</strong></p>\n<p><strong>专业积累：<br />\n从金税三期到核心银行，十一年跨越几代数据库</strong></p>\n<p>刘明的数据库生涯始于2014年，从Oracle数据库运维起步，参与金税三期等国家级项目的后台支撑。这段经历为他打下了扎实的基本功。</p>\n<p>2017年，他进入传统行业甲方担任DBA。公司技术团队仅有两人，他不得不身兼数职，正是在这段“什么都做”的日子里，他开始利用碎片时间接触PostgreSQL、openGauss等开源数据库，虽无生产环境实战，却在心中埋下了转向国产数据库的种子。</p>\n<p>2022年底是一个关键转折点。刘明正式转向GaussDB，入驻某银行负责GaussDB分布式数据库的驻场运维。这个局点不仅是当时全国最大的GaussDB集群，也是首个将核心业务迁移至GaussDB的银行项目。两年八个月的时间里，他亲历了每一次变更、每一个故障排查，将GaussDB运维的底子打得无比扎实。</p>\n<p>2025年上半年，刘明加入北京中亦安图科技股份有限公司，担任高级数据库工程师。工作边界从运维拓展至实施、迁移、POC、压测、优化与培训，服务范围覆盖北京地区多家头部客户。与此同时，他系统性地完成了华为云数据库认证路径的攀登：从HCCDP-GaussDB，直至今日的HCCDE-GaussDB。</p>\n<p>&nbsp;</p>\n<p><strong>02&nbsp;</strong></p>\n<p><strong>专家挑战：</strong></p>\n<p><strong>全球首位HCCDE-GaussDB认证专家的诞生</strong></p>\n<p>2025年9月，刘明参加了HCCDE-GaussDB线上培训课。课程对原理的深度拆解、对实用场景的精准覆盖，让他立刻意识到：这不是一场普通的进阶考试，而是一次对数据库工程师综合能力的测试。</p>\n<p>刘明用四个维度解析这次挑战：</p>\n<p><strong>知识体系更系统</strong>——HCCDE培训材料的知识体系较为系统，并且对原理的梳理较为细致；</p>\n<p><strong>笔试场景更灵活</strong>——不再直问直答，而是将多个知识点糅合进一个真实业务场景，考验考生拆解问题的综合能力；<br />\n<strong>机试设计更巧妙</strong>——题目描述简短，无明确提示，解决方案的入口往往隐藏在某个参数开关或日志线索中；</p>\n<p><strong>内容更贴合实际</strong>——集群故障处理、性能优化、对象管理、安全管理，全是生产环境必备技能。</p>\n<p>备考过程是一场与时间的博弈。\"日常工作太忙，只能利用下班后零散时间学习。\"刘明坦言，即使通过考试，培训材料仍需反复温故知新。“实际工作中的故障往往比考题更复杂，但HCCDE的精髓在于——它考的不是‘你知道这个功能吗’，而是‘遇到这个问题，你想不想得到用它’。”</p>\n<p>2026年1月底，刘明顺利通过全部考核。作为全球首位通过者，他的感受却很务实：“拿到证书当然很开心，是对这段时间学习的证明。”他说，“但我也很清楚，这只是完成了短期的学习目标。GaussDB迭代很快，客户现场的挑战层出不穷，不断推出很多新特性，真正的技术深耕，才刚刚开始。”</p>\n<p align=\"center\">&nbsp;<img alt=\"\" class=\"lazyload\" /></p>\n<p align=\"center\">刘明工作照片</p>\n<p>&nbsp;</p>\n<p><strong>03</strong></p>\n<p><strong>价值传递：</strong></p>\n<p><em id=\"__mceDel\"><em id=\"__mceDel\"><em id=\"__mceDel\"><strong>认证不是终点，而是胜任力的起点</strong></em></em></em></p>\n<p>在华为云认证体系中，顶级专家的价值不仅在于“自己能解决多难的问题”，更在于“能让多少开发者拥有解决难题的能力”。</p>\n<p>在刘明看来，HCCDE认证对个人和企业具有双重价值。</p>\n<p><strong>对个人而言</strong>，HCCDE认证提供了一条可追随的学习路径，缩短从“知道”到“搞定”的距离。对我个人而言，最大的价值不是那张证书，而是处理问题的底气和效率。<br />\n&nbsp;“我现在遇到复杂问题时，仍会翻出培训材料。它不是考完即弃的题库，而是案头常备的工具书。”</p>\n<p><strong>对企业而言</strong>，高含金量认证是最高效的筛选器——尤其在在分布式数据库人才稀缺的当下，“一个HCCDE持证者，意味着他既懂GaussDB原理，也有在真实压力下排错、调优、设计的实战经验。”对公司而言，能交付高质量项目的同时让客户更愿意为专业能力买单，这就是价值。</p>\n<p>对于计划挑战HCCDE的开发者，他给出四条建议：</p>\n<ul>\n<li>吃透培训材料，笔试对理解深度与灵活性有一定要求；</li>\n<li>熟稔GaussDB软件架构，掌握常用的性能排查工具与调优方法；</li>\n<li>沙箱实验必须亲手敲过、多练习并总结；</li>\n<li>日常工作中每处理一个问题，都是最好的备考；</li>\n</ul>\n<p>他还特别提到HCCDE-GaussDB认证中的一大亮点——<strong>GaussDB</strong><strong>数据库规划设计</strong>模块。“这是其他认证乃至官方文档所不包含的内容，从资源评估、产品选型到高可用架构设计，每一页具有可实操性的帮助价值。”</p>\n<p align=\"center\">\n \n<img alt=\"\" class=\"lazyload\" /><br />\n刘明整理的学习笔记</p>\n<p>&nbsp;</p>\n<p><strong>04</strong></p>\n<p><strong>持续进化：</strong></p>\n<p><em id=\"__mceDel\"><strong>在技术变革中保持领先的专业素养</strong></em></p>\n<p>从Oracle到GaussDB，从单机到分布式，刘明亲历了数据库技术的几次迭代。面对未来，他保持清醒：“技术迭代太快，不学习就会被淘汰。”</p>\n<p>他的持续学习法则有两条：一是<strong>持续输入</strong>——紧跟新产品、新特性；二是<strong>交流输出</strong>——通过团队内部分享机制，把个人经验转化为集体智慧。</p>\n<p>华为云认证体系本身，就是他适应变化的重要抓手。\"HCCDE最大的特点是紧贴产品演进和实际场景。\"刘明解释道，GaussDB每版本迭代的新特性，都会及时融入认证课程，不是停留在理论，而是要求理解\"怎么用、在什么场景用、如何配合其他组件\"。</p>\n<p>从HCCDP再到HCCDE，渐进式的能力构建路径，让高阶工程师和架构师能清晰看到下一步该补什么。\"它不只是证书，更是一张持续更新的技术路线图。\"</p>\n<p>从守护全国最大GaussDB集群的日与夜，到成为全球首位获得最高级别认证的人——刘明走过的路，从来不是为了把名字刻在榜单第一行。他只是习惯了在每个现场，比问题多想一步；在每个版本迭代时，比昨天多学一层。</p>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-14 14:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/huaweiyun\">华为云开发者联盟</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "OneTrans：在工业级推荐系统中以单一 Transformer 实现特征交互与序列建模的统一框架",
      "link": "https://www.cnblogs.com/GlenTt/p/19614879",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GlenTt/p/19614879\" id=\"cb_post_title_url\" title=\"发布于 2026-02-14 11:31\">\n    <span>OneTrans：在工业级推荐系统中以单一 Transformer 实现特征交互与序列建模的统一框架</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"onetrans在工业级推荐系统中以单一-transformer-实现特征交互与序列建模的统一框架\">OneTrans：在工业级推荐系统中以单一 Transformer 实现特征交互与序列建模的统一框架</h1>\n<h2 id=\"摘要\">摘要</h2>\n<p>在推荐系统中，扩展特征交互模块（例如 Wukong、RankMixer）或用户行为序列模块（例如 LONGER）已经取得了显著成果。然而，这两类工作通常沿着彼此独立的路径推进，这不仅阻碍了双向信息交互，也限制了统一优化与统一扩展能力。</p>\n<p>本文提出 OneTrans，一种统一的 Transformer 主干网络，可同时完成用户行为序列建模与特征交互。OneTrans 采用统一的 tokenizer，将序列属性与非序列属性共同转换为单一的 token 序列。堆叠的 OneTrans 模块对相似的序列 token 共享参数，而对非序列 token 分配特定参数。通过因果注意力机制与跨请求的 KV 缓存机制，OneTrans 支持中间表示的预计算与缓存，在训练与推理阶段均显著降低计算成本。</p>\n<p>在工业级规模数据集上的实验结果表明，OneTrans 随参数规模扩展具有良好的可扩展性，稳定优于多个强基线模型，并在真实在线 A/B 实验中实现了用户级 GMV 提升 5.68%。</p>\n<h2 id=\"1-引言\">1 引言</h2>\n<p>推荐系统在各类信息服务中发挥着基础性作用，例如电商、流媒体和社交网络。工业级推荐系统通常采用级联式排序架构。首先，在召回阶段从十亿规模的候选库中选出数百个候选项；随后，在排序阶段对每个候选进行打分并返回 Top-k 结果。深度学习推荐模型（DLRM）已广泛应用于工业推荐系统的排序阶段。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>本文聚焦排序阶段，遵循 DLRM 风格的排序范式。当前主流方法通常围绕两个相互独立的模块进行迭代优化：（a）序列建模模块，将用户多行为序列编码为与候选相关的表示，通常采用局部注意力或 Transformer 编码器；（b）特征交互模块，通过分解方法、显式交叉网络或基于特征组的注意力机制，学习非序列特征（如用户画像、物品画像和上下文特征）之间的高阶交叉关系。如图 1(a) 所示，这类方法通常先将用户行为编码为压缩的序列表示，然后与非序列特征拼接，再通过特征交互模块学习高阶交互。本文将这一设计称为“先编码后交互”（encode-then-interaction）流程。</p>\n<p>大语言模型（LLM）的成功表明，扩大模型规模（如参数规模和训练数据规模）可以带来可预测的性能提升。这一现象也启发了推荐系统中的相关研究。在特征交互方面，Wukong 通过堆叠因子分解机模块并结合线性压缩来建模高阶特征交互，并建立了扩展规律；RankMixer 通过硬件友好的 token 混合机制以及 token 特定的前馈网络（FFN）实现了良好的规模扩展能力。在序列建模方面，LONGER 采用因果 Transformer 建模长用户行为历史，并证明随着深度和宽度的增加，性能呈单调提升趋势。</p>\n<p>尽管上述方法在实践中有效，但将序列建模与特征交互作为独立模块会带来两个主要局限。第一，“先编码后交互”的流程限制了双向信息流，使静态或上下文特征难以充分影响序列表示的建模。第二，模块分离导致执行过程割裂并增加系统延迟；相比之下，统一的 Transformer 主干结构可以复用 LLM 的成熟优化技术，如 KV 缓存、内存高效注意力机制和混合精度训练，从而实现更高效的规模扩展。</p>\n<p>为此，本文提出 OneTrans，一种创新性的架构范式，通过统一的 Transformer 主干网络同时完成用户行为序列建模与特征交互。如图 1(b) 所示，OneTrans 在统一主干内部实现了双向信息交互。其核心在于一个统一的 tokenizer，将序列特征（多样化行为序列）和非序列特征（用户、物品及上下文静态特征）共同转换为单一的 token 序列，然后送入由多层堆叠的 OneTrans 模块组成的金字塔结构中。该结构是针对工业推荐系统定制的 Transformer 变体。</p>\n<p>考虑到推荐系统中 token 来源多样、语义异构（不同于 LLM 中单一文本 token），每个 OneTrans 模块采用类似 HiFormer 的混合参数化策略。具体而言，所有来自序列特征的 token 共享同一组 Q/K/V 和 FFN 参数，而每个非序列 token 则分配独立的特定参数，以保留其独特语义。</p>\n<p>不同于传统的“先编码后交互”框架，OneTrans 通过统一的因果 Transformer 主干消除了序列与非序列特征之间的结构性隔离，使推荐系统的扩展方式与 LLM 实践保持一致：通过调整主干网络的深度和宽度即可扩展整体模型规模，同时可无缝继承成熟的 LLM 优化技术，如 FlashAttention 和混合精度训练。尤其是跨候选与跨请求的 KV 缓存机制，可将包含 C 个候选的会话时间复杂度从 𝑂(C) 降至 𝑂(1)，从而使大规模 OneTrans 部署成为可能。</p>\n<h3 id=\"主要贡献\">主要贡献</h3>\n<p>本文的贡献可概括为四点：</p>\n<ol>\n<li>\n<p><strong>统一框架</strong>：提出 OneTrans 单一 Transformer 主干排序模型，配备统一 tokenizer，将序列与非序列特征编码为统一 token 序列，并通过统一 Transformer 模块同时完成序列建模与特征交互。</p>\n</li>\n<li>\n<p><strong>面向推荐系统的定制设计</strong>：为弥合 LLM 与推荐任务之间的差距，提出混合参数化机制，对多样化的非序列 token 分配特定参数，同时对所有序列 token 共享参数。</p>\n</li>\n<li>\n<p><strong>高效训练与推理</strong>：通过金字塔策略逐层裁剪序列 token，并引入跨请求 KV 缓存复用用户侧计算结果。同时采用 FlashAttention、混合精度训练和半精度推理等优化手段，降低内存与计算开销。</p>\n</li>\n<li>\n<p><strong>规模扩展与在线部署验证</strong>：OneTrans 随模型规模增加呈现近似对数线性性能增长趋势，在真实生产数据上验证了规模规律；在线部署后，在保持工业级延迟的前提下，显著提升关键业务指标。</p>\n</li>\n</ol>\n<h2 id=\"2-相关工作\">2 相关工作</h2>\n<p>早期推荐系统模型，如 DIN 及其面向会话的变体 DSIN，采用局部注意力机制学习与候选物品条件相关的用户历史行为摘要，但通常将行为压缩为针对每个候选的固定长度向量，从而限制了长程依赖关系的建模能力。自注意力方法，如 SASRec、BERT4Rec 和 BST，通过允许序列中每个位置关注完整历史，消除了这一瓶颈，并通过双向掩码机制提升了样本利用效率。</p>\n<p>近年来，随着推荐系统中规模规律（scaling law）研究的推进，LONGER 将序列建模扩展至工业级规模，通过高效注意力机制和面向服务的架构设计，支持超长用户行为序列建模。然而，在主流工业流程中，这些序列编码器通常仍与特征交互模块相互独立，导致特征融合发生在后期阶段，而非与静态上下文特征进行联合优化。</p>\n<p>在特征交互方向，早期推荐系统依赖人工构造的交叉特征或自动乘性交互层。经典模型如 Wide&amp;Deep、FM/DeepFM 和 DCN/DCNv2 提供了高效的低阶或有界阶交互能力。然而，近期的规模研究发现，一旦交叉层堆叠到一定程度，继续增加层数往往无法带来性能提升，模型效果趋于平台期。</p>\n<p>为突破预设交叉形式的刚性限制，基于注意力的模型能够自动学习高阶交互关系。AutoInt 学习任意阶关系，HiFormer 通过组特定投影更好地刻画异构且非对称的特征交互。随着规模化方法逐渐应用于特征交互模块，大规模系统如 Wukong 通过堆叠 FM 风格交互模块并结合线性压缩，实现了可预测的性能增长；RankMixer 则在严格延迟约束下，通过并行 token 混合和稀疏 MoE 实现了良好的规模扩展能力。然而，这类交互模块通常仍遵循“交互后置”的范式，将交互限制在独立阶段，阻碍了与用户序列建模的统一优化。</p>\n<p>总体而言，推荐系统的发展长期沿着两条相对独立的路径推进：序列建模与特征交互。InterFormer 通过基于摘要的双向交叉架构尝试弥合两者差距，实现信号互通，但仍保留为两个独立模块，其交叉结构增加了架构复杂度和执行割裂性。在缺乏统一主干进行联合建模与整体优化的情况下，实现系统级规模扩展仍面临挑战。</p>\n<p>近期生成式推荐（Generative Recommenders）将推荐任务建模为序列转导问题，并提出如 HSTU 等高效长上下文主干结构。这一路线与依赖丰富非序列特征的 DLRM 系统形成互补。</p>\n<h2 id=\"3-方法\">3 方法</h2>\n<p>在详细介绍方法之前，首先说明任务设定。</p>\n<p>在级联式工业推荐系统中，每当召回阶段为用户 𝑢 返回一个候选集合（通常为数百个候选物品）后，排序模型会为每个候选物品 𝑖 预测一个得分：</p>\n<p></p><div class=\"math display\">\\[\\hat{y}_{u,i} = f(i, NS, S; \\Theta)\n\\]</div><p></p><p>其中，NS 表示来自用户、候选物品及上下文的非序列特征集合；S 表示用户的历史行为序列集合；Θ 为可训练参数。常见的预测任务包括点击率（CTR）与点击后转化率（CVR）：</p>\n<p></p><div class=\"math display\">\\[CTR_{u,i} = P(click=1 \\mid NS, S; \\Theta)\n\\]</div><p></p><p></p><div class=\"math display\">\\[CVR_{u,i} = P(conv=1 \\mid click=1, NS, S; \\Theta)\n\\]</div><p></p><h3 id=\"31-onetrans-框架概述\">3.1 OneTrans 框架概述</h3>\n<p><img alt=\"image-1\" class=\"lazyload\" /></p>\n<p>如图 2(a) 所示，OneTrans 采用统一 tokenizer，将序列特征 S 映射为 S-tokens，将非序列特征 NS 映射为 NS-tokens。随后，一个金字塔式堆叠的 Transformer 在单一计算图中联合处理这一统一 token 序列。初始 token 序列定义为：</p>\n<p></p><div class=\"math display\">\\[X^{(0)} = [S\\text{-tokens}; NS\\text{-tokens}] \\in \\mathbb{R}^{(L_S + L_{NS}) \\times d}\n\\]</div><p></p><p>该序列由 (L_S) 个 S-tokens 与 (L_{NS}) 个 NS-tokens 拼接而成，所有 token 的维度均为 (d)。需要注意的是，在 S-tokens 中插入了可学习的 [SEP] token，用于区分不同类型的用户行为序列边界。</p>\n<p>如图 2(b) 所示，每个 OneTrans Block 通过如下方式逐层更新 token 表示：</p>\n<p></p><div class=\"math display\">\\[Z^{(n)} = \\text{MixedMHA}(\\text{Norm}(X^{(n-1)})) + X^{(n-1)}\n\\]</div><p></p><p></p><div class=\"math display\">\\[X^{(n)} = \\text{MixedFFN}(\\text{Norm}(Z^{(n)})) + Z^{(n)}\n\\]</div><p></p><p>其中，MixedMHA（混合多头注意力）与 MixedFFN（混合前馈网络）采用混合参数化策略（见图 2(c)）：所有序列 token 共享同一组 Q/K/V 与 FFN 权重，而每个非序列 token 在注意力层与前馈层中均分配独立的专属参数。</p>\n<p>模型采用统一的因果掩码（causal mask），施加自回归约束，使每个位置只能关注其之前的 token。具体而言，NS-tokens 允许访问全部 S-tokens 的历史信息，从而实现充分的跨 token 交互。</p>\n<p>通过堆叠多个此类 Block，并对 S-tokens 施加金字塔式尾部裁剪（tail truncation），模型逐层将高阶信息压缩并蒸馏至 NS-tokens 中。最终的 token 表示输入至任务特定的预测头完成输出。</p>\n<h3 id=\"统一建模带来的结构优势\">统一建模带来的结构优势</h3>\n<p>通过将序列与非序列特征统一为单一 token 序列，并使用因果 Transformer 进行建模，OneTrans 摒弃了传统“先编码后交互”流程。这种统一设计在单一 Transformer 堆叠中自然实现了：</p>\n<ol>\n<li>单序列内部的交互建模</li>\n<li>多序列之间的交互建模</li>\n<li>用户、物品与上下文等多源特征之间的交互</li>\n<li>序列特征与非序列特征之间的交互</li>\n</ol>\n<p>统一建模形式使得模型可以无缝继承成熟的大模型工程优化技术，包括 KV 缓存与内存高效注意力机制，从而显著降低推理延迟。该统一框架在单一可扩展架构下处理多序列与跨域推荐任务，具备良好的扩展潜力。</p>\n<h3 id=\"32-特征与-token-化\">3.2 特征与 Token 化</h3>\n<p>为构建初始 token 序列 (X^{(0)})，OneTrans 首先通过特征预处理流程，将所有原始特征映射为 embedding 向量。这些 embedding 随后被划分为两部分：（i）多行为序列子集；（ii）表示用户、物品或上下文的非序列特征子集。随后分别对两类特征应用不同的 tokenizer。</p>\n<h4 id=\"321-非序列特征的-token-化\">3.2.1 非序列特征的 Token 化</h4>\n<p>非序列特征 NS 包括数值特征（如价格、CTR）和类别特征（如用户 ID、物品类目）。所有特征先进行分桶或 one-hot 编码，再映射为 embedding。</p>\n<p>由于工业系统通常包含数百个特征，且重要性差异显著，因此控制非序列 token 数量 (L_{NS}) 有两种方式：</p>\n<p><strong>（1）分组式 Tokenizer（Group-wise Tokenizer）</strong><br />\n与 RankMixer 对齐，将特征手动划分为语义组 ({g_1, ..., g_{L_{NS}}})。每个组内特征拼接后通过独立的 MLP 投影：</p>\n<p></p><div class=\"math display\">\\[NS\\text{-tokens} =\nMLP_1(concat(g_1)), ..., MLP_{L_{NS}}(concat(g_{L_{NS}}))\n\\]</div><p></p><p><strong>（2）自动切分 Tokenizer（Auto-Split Tokenizer）</strong><br />\n将所有特征拼接后，通过一个统一 MLP 投影，再进行切分：</p>\n<p></p><div class=\"math display\">\\[NS\\text{-tokens} = split(MLP(concat(NS)), L_{NS})\n\\]</div><p></p><p>Auto-Split 方式通过一次稠密投影减少 kernel 启动开销，相较分组式方法更高效。论文将在实验中对两种方式进行对比。</p>\n<p>最终，非序列 token 化得到 (L_{NS}) 个非序列 token，每个维度为 (d)。</p>\n<h4 id=\"322-序列特征的-token-化\">3.2.2 序列特征的 Token 化</h4>\n<p>OneTrans 支持多行为序列输入：</p>\n<p></p><div class=\"math display\">\\[S = {S_1, ..., S_n}, \\quad S_i = {e_{i1}, ..., e_{iL_i}}\n\\]</div><p></p><p>每个序列 (S_i) 包含 (L_i) 个事件 embedding。每个事件 embedding 由物品 ID 及其附加信息（如类目、价格等）拼接构成。</p>\n<p>由于不同序列的原始维度可能不同，对每个序列 (S_i) 使用共享投影网络 (MLP_i)，将所有事件映射至统一维度 (d)：</p>\n<p></p><div class=\"math display\">\\[\\tilde{S}*i =\nMLP_i(e*{i1}), ..., MLP_i(e_{iL_i})\n\\in \\mathbb{R}^{L_i \\times d}\n\\]</div><p></p><p>对齐后的序列 (\\tilde{S}_i) 可通过两种规则合并为统一 token 序列：</p>\n<ol>\n<li><strong>时间感知（Timestamp-aware）</strong>：按时间顺序交错所有事件，并添加序列类型标识。</li>\n<li><strong>时间无关（Timestamp-agnostic）</strong>：按行为影响力排序拼接，例如“购买 → 加购 → 点击”，在序列之间插入可学习的 [SEP] token。高意图行为排在前面。</li>\n</ol>\n<p>消融实验表明，当时间戳可用时，时间感知方式优于按行为影响排序的方式。</p>\n<p>形式化表示为：</p>\n<p></p><div class=\"math display\">\\[S\\text{-tokens} = Merge(\\tilde{S}_1, ..., \\tilde{S}_n)\n\\in \\mathbb{R}^{L_S \\times d}\n\\]</div><p></p><p>其中</p>\n<p></p><div class=\"math display\">\\[L_S = \\sum_{i=1}^{n} L_i + L_{SEP}\n\\]</div><p></p><h3 id=\"33-onetrans-block\">3.3 OneTrans Block</h3>\n<p>如图 2(b) 所示，每个 OneTrans Block 是一个 pre-norm 因果 Transformer，输入为规范化后的 token 序列：前 (L_S) 个为序列 token，后 (L_{NS}) 个为非序列 token。</p>\n<p>受异构特征组研究的启发，OneTrans 对标准 Transformer 进行了轻量级改造，引入混合参数机制：同质的 S-tokens 共享参数；而来源与语义异构的 NS-tokens 使用各自的专属参数。</p>\n<p>由于推荐系统的 token 序列混合了统计分布差异较大的 S-tokens 与 NS-tokens，若采用 post-norm 结构容易导致注意力塌缩和训练不稳定。因此，OneTrans 采用 RMSNorm 作为 pre-norm，对所有 token 进行归一化，从而对齐尺度并稳定优化过程。</p>\n<h4 id=\"331-混合共享专属因果注意力\">3.3.1 混合（共享/专属）因果注意力</h4>\n<p>OneTrans 使用标准多头注意力（MHA）和因果掩码，唯一的变化在于 Q/K/V 的参数化方式。</p>\n<p>设第 (i) 个 token 为 (x_i \\in \\mathbb{R}^d)，则：</p>\n<p></p><div class=\"math display\">\\[q_i, k_i, v_i =\nW_i^Q x_i,\\quad\nW_i^K x_i,\\quad\nW_i^V x_i\n\\]</div><p></p><p>其中参数矩阵采用混合参数化：</p>\n<p></p><div class=\"math display\">\\[W_i^\\Psi =\n\\begin{cases}\nW_S^\\Psi, &amp; i \\le L_S \\quad （S\\text{-tokens 共享参数）} \\\nW_{NS,i}^\\Psi, &amp; i &gt; L_S \\quad （NS\\text{-tokens 专属参数）}\n\\end{cases}\n\\]</div><p></p><p>因果掩码的设计为 NS-tokens 排在 S-tokens 之后，从而形成如下结构：</p>\n<ol>\n<li><strong>S 侧行为</strong><br />\n每个 S-token 仅关注其之前的 S-token。</li>\n</ol>\n<ul>\n<li>若采用时间感知顺序，每个行为基于历史建模；</li>\n<li>若采用按意图排序方式，因果掩码使高意图行为影响后续低意图行为。</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p><strong>NS 侧行为</strong><br />\n每个 NS-token 可访问完整 S 历史，相当于对行为证据进行目标注意力聚合；同时可访问前序 NS-token，增强非序列 token 之间的交互。</p>\n</li>\n<li>\n<p><strong>支持金字塔结构</strong><br />\n因果结构使信息逐步向后集中，为逐层裁剪 token 的金字塔机制提供自然支持。</p>\n</li>\n</ol>\n<h4 id=\"332-混合共享专属前馈网络\">3.3.2 混合（共享/专属）前馈网络</h4>\n<p>FFN 采用相同的混合参数策略：</p>\n<p></p><div class=\"math display\">\\[MixedFFN(x_i) = W_{2,i} , \\phi(W_{1,i} x_i)\n\\]</div><p></p><p>其中 (W_{1,i}) 与 (W_{2,i}) 遵循上述混合参数规则：<br />\nS-tokens 共享参数，NS-tokens 使用专属参数。</p>\n<h4 id=\"小结\">小结</h4>\n<p>与标准因果 Transformer 相比，OneTrans 仅在参数化层面进行修改：</p>\n<ul>\n<li>NS-tokens 使用专属 QKV 与 FFN；</li>\n<li>S-tokens 共享一套参数；</li>\n<li>单一因果掩码统一连接整个序列。</li>\n</ul>\n<p>这种设计使 NS-tokens 能够聚合完整行为历史，同时保持 Transformer 风格的高效计算结构。</p>\n<h2 id=\"34-金字塔堆叠pyramid-stack\">3.4 金字塔堆叠（Pyramid Stack）</h2>\n<p>如第 3.3 节所述，因果掩码会将信息逐步集中到序列的后部位置。利用这一“信息向尾部聚集”的结构特性，OneTrans 采用金字塔式调度策略：在每一层 OneTrans Block 中，仅最近的一部分 S-tokens 参与 Query 计算，而 Key 与 Value 仍在完整序列上计算；随着网络深度增加，参与 Query 的 token 数量逐层缩减。</p>\n<p>设输入 token 序列为</p>\n<p></p><div class=\"math display\">\\[X = {x_i}_{i=1}^{L}\n\\]</div><p></p><p>定义尾部索引集合</p>\n<p></p><div class=\"math display\">\\[Q = {L - L' + 1, ..., L}, \\quad L' \\le L\n\\]</div><p></p><p>在该层中，仅对 (i \\in Q) 的 token 计算 Query：</p>\n<p></p><div class=\"math display\">\\[q_i = W_i^Q x_i, \\quad i \\in Q\n\\]</div><p></p><p>而 Key 与 Value 仍在完整索引集合 ({1, ..., L}) 上计算。注意力计算完成后，仅保留 (i \\in Q) 的输出表示，从而将 token 长度缩减为 (L')，形成跨层逐步收缩的金字塔结构。</p>\n<p>该设计带来两个核心优势：</p>\n<ol>\n<li>\n<p><strong>渐进式信息蒸馏</strong><br />\n长行为序列的信息被逐层压缩至尾部 token，模型容量集中于最具信息量的近期行为，并逐步将高阶信息汇聚至 NS-tokens。</p>\n</li>\n<li>\n<p><strong>计算效率提升</strong><br />\n注意力复杂度由 (O(L^2 d)) 降为 (O(L L' d))，FFN 复杂度与 (L') 线性相关。随着 Query 集合缩小，FLOPs 与激活内存显著降低。</p>\n</li>\n</ol>\n<h2 id=\"35-训练与部署优化\">3.5 训练与部署优化</h2>\n<h3 id=\"351-跨请求-kv-缓存cross-request-kv-caching\">3.5.1 跨请求 KV 缓存（Cross-Request KV Caching）</h3>\n<p>在工业推荐系统中，同一请求下的多个候选样本在训练与推理阶段通常连续处理：它们的 S-tokens 完全相同，而 NS-tokens 随候选物品变化。基于这一结构，OneTrans 引入 KV Caching 机制，形成统一的两阶段计算范式。</p>\n<p><strong>阶段 I（S 侧，每请求一次）</strong><br />\n对全部 S-tokens 进行因果注意力计算，并缓存其 Key/Value 及注意力输出。该阶段在每个请求中仅执行一次。</p>\n<p><strong>阶段 II（NS 侧，每候选一次）</strong><br />\n对每个候选物品计算其 NS-tokens，并与缓存的 S 侧 Key/Value 进行跨注意力计算，随后进入 token-specific FFN 层。<br />\n对于候选相关的序列特征（如 SIM），由于无法复用 S 侧缓存，需先通过池化方式预聚合为 NS-tokens。</p>\n<p>KV 缓存机制将 S 侧计算在候选间进行摊销，使单候选计算量大幅下降，避免重复计算，从而显著提升吞吐率。</p>\n<p>此外，由于用户行为序列是追加式增长的，可将 KV 缓存扩展至跨请求复用：<br />\n每次新请求复用前一缓存，仅对新增行为计算增量 Key/Value。<br />\n因此单次请求的序列计算复杂度由 (O(L)) 降至 (O(\\Delta L))，其中 (\\Delta L) 为自上次请求以来新增行为数量。</p>\n<h3 id=\"352-统一-llm-优化策略\">3.5.2 统一 LLM 优化策略</h3>\n<p>为进一步提升效率，OneTrans 引入成熟的大模型工程优化方法：</p>\n<ol>\n<li>\n<p><strong>FlashAttention-2</strong><br />\n通过分块计算与 kernel 融合，减少注意力计算中的 I/O 开销与二次激活存储需求，从而在训练与推理阶段降低内存占用并提升吞吐率。</p>\n</li>\n<li>\n<p><strong>混合精度训练（BF16/FP16）与激活重计算</strong><br />\n采用低精度计算以降低显存占用，并结合激活重计算策略，在反向传播阶段重新计算部分前向激活值。<br />\n该策略以少量额外计算换取显著内存节省，使得更大 batch 与更深模型成为可能，而无需修改模型结构。</p>\n</li>\n</ol>\n<p>总体而言，金字塔结构负责控制序列长度与计算规模，KV 缓存负责跨候选与跨请求的计算复用，而 LLM 优化技术则进一步提升底层算子效率。三者结合，使 OneTrans 在工业规模下具备可扩展性与可部署性。</p>\n<h2 id=\"4-实验\">4 实验</h2>\n<p>通过离线评估与在线实验，本文围绕以下研究问题展开分析：</p>\n<p><strong>RQ1：统一堆叠结构 vs. “先编码后交互”范式</strong><br />\n在计算资源相当的条件下，单一 Transformer 主干是否能够稳定优于传统的 encode–then–interaction 架构？</p>\n<p><strong>RQ2：关键设计因素分析</strong><br />\n通过消融实验评估不同设计选择对性能与效率的影响，包括：</p>\n<ul>\n<li>输入层设计（如 tokenizer 方式、序列融合策略）；</li>\n<li>OneTrans Block 结构设计（如参数共享策略、注意力形式、金字塔堆叠机制）。</li>\n</ul>\n<p><strong>RQ3：系统效率评估</strong><br />\n在相同 OneTrans 计算图下，金字塔堆叠、跨请求 KV 缓存、FlashAttention-2，以及混合精度训练与激活重计算，是否能够有效降低 FLOPs、显存占用与推理延迟？</p>\n<p><strong>RQ4：规模规律（Scaling Law）</strong><br />\n随着模型长度（token 序列长度）、宽度（(d_{model})）、深度（层数）的扩展，损失或性能是否呈现预期的近似对数线性增长趋势？</p>\n<p><strong>RQ5：在线 A/B 测试效果</strong><br />\n在满足生产环境延迟约束的前提下，OneTrans 在线部署是否能够在关键业务指标（如人均订单数、用户级 GMV）上实现统计显著的提升？</p>\n<p>该实验设计系统性地从架构有效性、设计合理性、系统效率、规模扩展能力以及真实业务效果五个维度进行验证。</p>\n<h3 id=\"41-实验设置\">4.1 实验设置</h3>\n<h4 id=\"411-数据集\">4.1.1 数据集</h4>\n<p>在离线评估中，我们在一个大规模工业排序场景下评估 OneTrans，使用严格隐私合规条件下的生产日志数据（所有个人可识别信息均已匿名化并哈希处理）。</p>\n<p>数据按时间顺序划分，所有特征均在曝光时刻进行快照，以防止时间信息泄露并保证线上线下一致性。标签（如点击与下单）在与生产环境对齐的固定时间窗口内聚合。数据集统计信息见表 1。</p>\n<p><img alt=\"image-2\" class=\"lazyload\" /></p>\n<h4 id=\"412-任务与指标\">4.1.2 任务与指标</h4>\n<p>我们评估两个二分类排序任务（见公式 (2)）：CTR 与 CVR。性能指标包括：</p>\n<ul>\n<li><strong>AUC</strong></li>\n<li><strong>UAUC（基于曝光加权的用户级 AUC）</strong></li>\n</ul>\n<h5 id=\"next-batch-评估方式\">Next-batch 评估方式</h5>\n<p>数据按时间顺序处理。对于每个 mini-batch：</p>\n<ol>\n<li>在评估模式下记录预测结果；</li>\n<li>随后在同一 batch 上进行训练。</li>\n</ol>\n<p>AUC 与 UAUC 按天计算，然后对各天结果进行宏平均。</p>\n<h5 id=\"效率指标\">效率指标</h5>\n<ul>\n<li><strong>Params</strong>：模型参数量（不包含稀疏 embedding）</li>\n<li><strong>TFLOPs</strong>：训练计算量（batch size = 2048 时的 TFLOPs）</li>\n</ul>\n<h4 id=\"413-基线模型\">4.1.3 基线模型</h4>\n<p>我们构建了工业标准模型组合作为对比基线，使用相同特征并匹配计算预算。</p>\n<p>在 encode–then–interaction 范式下：</p>\n<ul>\n<li>从生产中常用的 DCNv2 + DIN 作为基础模型；</li>\n<li>逐步增强特征交互模块：<br />\nDCNv2 → Wukong → HiFormer → RankMixer。</li>\n</ul>\n<p>在固定 RankMixer 的前提下，进一步替换序列建模模块：</p>\n<ul>\n<li>StackDIN → Transformer → LONGER。</li>\n</ul>\n<h4 id=\"414-超参数设置\">4.1.4 超参数设置</h4>\n<p>我们报告两种模型规模：</p>\n<ul>\n<li>\n<p><strong>OneTrans-S</strong></p>\n<ul>\n<li>6 层 OneTrans Block</li>\n<li>宽度 (d = 256)</li>\n<li>4 个注意力头</li>\n<li>约 1 亿参数</li>\n</ul>\n</li>\n<li>\n<p><strong>OneTrans-L</strong></p>\n<ul>\n<li>8 层</li>\n<li>宽度 (d = 384)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"输入与金字塔设置\">输入与金字塔设置</h4>\n<ul>\n<li>\n<p>序列特征采用时间感知融合方式；</p>\n</li>\n<li>\n<p>非序列特征使用 Auto-Split tokenizer；</p>\n</li>\n<li>\n<p>使用启发式金字塔调度：</p>\n<ul>\n<li>OneTrans-S：序列 Query token 从 1190 线性缩减至 12</li>\n<li>OneTrans-L：从 1500 缩减至 16</li>\n</ul>\n</li>\n</ul>\n<p>具体实现为：跨层线性减少序列 Query token 数量，并在每层将 token 数量四舍五入至 32 的倍数，最顶层 token 数量与非序列 token 数量一致。</p>\n<h4 id=\"优化与基础设施\">优化与基础设施</h4>\n<p>采用双优化器策略（不使用 weight decay）：</p>\n<ul>\n<li>稀疏 embedding：Adagrad（β₁=0.1，β₂=1.0）</li>\n<li>稠密参数：RMSProp（lr=0.005，alpha=0.99999，momentum=0）</li>\n</ul>\n<p>训练稳定性策略包括：</p>\n<ul>\n<li>Pre-Norm 结构</li>\n<li>全局梯度范数裁剪</li>\n</ul>\n<p>训练阶段：</p>\n<ul>\n<li>每 GPU batch size = 2048</li>\n<li>稠密层梯度裁剪阈值 = 90</li>\n<li>稀疏层梯度裁剪阈值 = 120</li>\n<li>使用 16 张 H100 GPU，数据并行 All-Reduce</li>\n</ul>\n<p>在线推理阶段：</p>\n<ul>\n<li>每 GPU batch size = 100</li>\n<li>在吞吐率与延迟之间进行权衡优化</li>\n</ul>\n<p>该实验设置确保了模型规模、训练稳定性与工业部署约束之间的平衡，使离线评估与线上效果具有高度一致性。</p>\n<h3 id=\"42-rq1性能评估\">4.2 RQ1：性能评估</h3>\n<p><img alt=\"image-3\" class=\"lazyload\" /></p>\n<p>我们以 DCNv2 + DIN 作为对比基准模型，该模型为本场景中规模扩展前的生产基线（见表 2）。</p>\n<p>在 encode–then–interaction 范式下，分别对两个组件进行独立扩展均能带来收益：</p>\n<ul>\n<li>升级特征交互模块（DCNv2 → Wukong → HiFormer → RankMixer）；</li>\n<li>升级序列建模模块（StackDIN → Transformer → LONGER）；</li>\n</ul>\n<p>上述改进在 CTR AUC/UAUC 与 CVR AUC 上均表现出稳定提升。</p>\n<p>在我们的系统中，AUC 或 UAUC 提升超过 +0.1% 即被视为具有实际意义；超过 +0.3% 通常对应在线 A/B 测试中的统计显著提升。由于用户级样本数量较少且波动较大，CVR UAUC 指标需谨慎解读。</p>\n<p>在统一架构下，OneTrans-S 相比基线取得：</p>\n<ul>\n<li>CTR：+1.13% / +1.77%（AUC / UAUC）</li>\n<li>CVR：+0.90% / +1.66%（AUC / UAUC）</li>\n</ul>\n<p>在相近参数规模与训练算力条件下（2.64T vs. 2.51T），OneTrans-S 也显著优于 RankMixer + Transformer，验证了统一建模的优势。</p>\n<p>进一步扩展模型规模，OneTrans-L 取得最佳整体表现：</p>\n<ul>\n<li>CTR：+1.53% / +2.79%</li>\n<li>CVR：+1.14% / +3.23%</li>\n</ul>\n<p>随着模型容量增加，性能呈现稳定、可预测的增长趋势。</p>\n<p>总结而言，在单一 Transformer 主干中统一序列建模与特征交互，相比独立扩展其中任一模块，能够带来更可靠且更具计算效率的性能提升。这一结果直接回答了 RQ1，并为统一架构提供了实证支持。</p>\n<h3 id=\"43-rq2设计选择的消融研究\">4.3 RQ2：设计选择的消融研究</h3>\n<p>我们对 OneTrans 的关键设计进行系统性消融实验，以量化各组件的贡献。完整结果见表 3。实验变体包括：</p>\n<p><img alt=\"image-4\" class=\"lazyload\" /></p>\n<p><img alt=\"image-5\" class=\"lazyload\" /></p>\n<h4 id=\"输入层变体\">输入层变体</h4>\n<ol>\n<li>将 Auto-Split Tokenizer 替换为 Group-wise Tokenizer（表 3 第 1 行）；</li>\n<li>使用时间无关的序列融合方式替代时间感知融合（第 2 行）；</li>\n<li>在时间感知融合中移除可学习的 [SEP] token（第 3 行）。</li>\n</ol>\n<h4 id=\"onetrans-block-结构变体\">OneTrans Block 结构变体</h4>\n<ol start=\"4\">\n<li>所有 token 共享同一组 Q/K/V 与 FFN 参数，而不对 NS-tokens 使用专属参数（第 4 行）；</li>\n<li>使用全注意力（full attention）替代因果注意力（第 5 行）；</li>\n<li>取消金字塔堆叠，在所有层保留完整 token 序列（第 6 行）。</li>\n</ol>\n<h4 id=\"消融结论\">消融结论</h4>\n<ol>\n<li>\n<p><strong>Auto-Split Tokenizer 优于人工分组方式</strong><br />\n相比将非序列特征人工划分为语义组，自动构建 NS-token 的方式效果更优。这表明由模型自动学习特征组织结构优于人为先验分组。</p>\n</li>\n<li>\n<p><strong>时间感知融合优于按行为意图排序</strong><br />\n在存在时间戳信息时，按时间顺序融合优于按行为影响力排序，说明时间信息比主观设定的行为强弱排序更具表达力。</p>\n</li>\n<li>\n<p><strong>[SEP] token 有助于序列区分</strong><br />\n在时间无关融合下，可学习的 [SEP] token 有助于模型区分不同序列，提高表示能力。</p>\n</li>\n<li>\n<p><strong>NS-token 专属参数优于共享参数</strong><br />\n为非序列 token 分配专属 Q/K/V 与 FFN 参数优于完全共享投影，有助于增强不同特征来源之间的表达区分能力。</p>\n</li>\n<li>\n<p><strong>因果注意力与全注意力效果接近，但因果注意力更具工程优势</strong><br />\n性能上二者相近，但全注意力会破坏 KV 缓存等标准优化手段，因此不具备系统层面的可扩展性。</p>\n</li>\n<li>\n<p><strong>金字塔设计不会损失效果，却显著节省计算</strong><br />\n在所有层保留完整 token 序列并未带来性能提升。OneTrans 能有效将信息压缩至尾部 token，因此金字塔结构可以安全裁剪 Query token，从而降低计算量。</p>\n</li>\n</ol>\n<p>此外，在固定 TFLOPs 预算下，金字塔设计支持接近 1.75 倍更长的输入序列，相比全长度设计更能有效利用序列扩展带来的收益。</p>\n<p>总体而言，消融结果表明 OneTrans 的关键设计并非经验性堆叠，而是具有明确结构必要性：自动 token 构建、时间感知融合、NS 专属参数以及金字塔裁剪共同构成了性能与效率兼顾的核心机制。</p>\n<h2 id=\"44-rq3系统效率\">4.4 RQ3：系统效率</h2>\n<p>为量化第 3.5 节提出的系统优化策略，我们在一个未做优化的 OneTransS 基线模型上逐项进行消融，并在表 4 中报告训练与推理阶段的效率指标。</p>\n<p><img alt=\"image-6\" class=\"lazyload\" /></p>\n<p>实验结果表明：</p>\n<ol>\n<li>\n<p><strong>金字塔堆叠（Pyramid Stack）</strong><br />\n通过裁剪序列 Query token，显著降低训练阶段的运行时间与显存占用，同时减少线上服务阶段的 p99 延迟与内存消耗。</p>\n</li>\n<li>\n<p><strong>跨请求 KV 缓存（Cross-request KV Caching）</strong><br />\n消除重复的序列计算，在训练与推理阶段均稳定提升运行效率与内存利用率。</p>\n</li>\n<li>\n<p><strong>FlashAttention</strong><br />\n在训练阶段带来显著加速效果，而在推理阶段的改进相对有限但仍有收益。</p>\n</li>\n<li>\n<p><strong>混合精度与重计算（Mixed Precision + Re-computation）</strong><br />\n对线上服务收益最大，显著降低 p99 延迟与推理显存开销，同时提升训练效率。</p>\n</li>\n</ol>\n<h3 id=\"综合结论\">综合结论</h3>\n<p><img alt=\"image-7\" class=\"lazyload\" /></p>\n<p>上述结果验证了将大模型（LLM）系统优化技术迁移到大规模推荐场景的有效性。在此基础上，模型进一步扩展至 OneTransL，并在表 5 中展示其线上效率可与规模远小得多的 DCNv2+DIN 基线模型相当。</p>\n<p>这说明统一的 Transformer 主干结构具有重要工程优势：它允许直接复用成熟的大模型优化技术，从而在模型规模显著提升的同时，维持可控的在线计算开销。</p>\n<p>总体来看，本节证明了 OneTrans 在扩大模型容量的同时，并未牺牲系统效率，而是通过架构统一化实现了性能与工程可扩展性的兼顾。</p>\n<h2 id=\"45-rq4scaling-law-验证\">4.5 RQ4：Scaling-Law 验证</h2>\n<p>我们从三个维度系统研究 OneTrans 的扩展规律（scaling laws）：</p>\n<ol>\n<li><strong>长度（Length）</strong>：输入 token 序列长度</li>\n<li><strong>深度（Depth）</strong>：堆叠 Transformer block 的层数</li>\n<li><strong>宽度（Width）</strong>：隐藏层维度大小</li>\n</ol>\n<h3 id=\"单轴扩展结果\">单轴扩展结果</h3>\n<p>如图 3(a) 所示：</p>\n<ul>\n<li>\n<p><strong>增加序列长度带来最大收益</strong>，因为更长的行为序列提供了更丰富的用户行为证据。</p>\n</li>\n<li>\n<p>在深度与宽度之间存在明显权衡：</p>\n<ul>\n<li>增加深度通常比单纯增加宽度带来更大的性能提升，因为更深的网络可以学习更高阶交互与更丰富的抽象表示。</li>\n<li>但更深的模型增加串行计算路径，影响延迟。</li>\n<li>扩宽维度则更易并行化，在硬件利用率上更友好。</li>\n</ul>\n</li>\n</ul>\n<p>因此，在实际部署时，深度与宽度的选择应综合考虑性能收益与目标硬件预算下的系统效率。</p>\n<h3 id=\"联合扩展与对比分析\">联合扩展与对比分析</h3>\n<p>我们进一步联合增加 OneTrans 的深度与宽度，同时对比扩展 RankMixer+Transformer 基线（主要在 RankMixer 侧扩展至 1B 参数规模），并绘制 ΔUAUC 相对于训练 FLOPs（对数尺度）的关系曲线。</p>\n<p>图 3(b) 表明：</p>\n<ul>\n<li>OneTrans 与 RankMixer 均呈现清晰的对数线性趋势（log-linear scaling）。</li>\n<li>但 <strong>OneTrans 的斜率更陡峭</strong>，即在相同计算增量下带来更大的性能提升。</li>\n</ul>\n<p>其原因可能在于：</p>\n<ul>\n<li>RankMixer 的扩展缺乏统一主干结构；</li>\n<li>基于 MoE 的扩展主要体现在 FFN 隐藏层维度的“宽度扩展”；</li>\n<li>而 OneTrans 通过统一 Transformer 主干实现结构层面的整体扩展，提升了参数与计算利用效率。</li>\n</ul>\n<h3 id=\"结论与部署边界\">结论与部署边界</h3>\n<p>这些结果表明：</p>\n<ul>\n<li>OneTrans 在参数效率与计算效率方面更具优势；</li>\n<li>在工业部署场景中，其性能–计算权衡更具吸引力。</li>\n</ul>\n<p>目前，OneTransL 已可在严格的线上 p99 延迟约束下稳定部署。但进一步超出当前规模的扩展仍受到在线效率瓶颈限制。未来工作将聚焦于系统与模型的联合优化，以突破这一扩展上限。</p>\n<p>从本节可以提炼出一个核心结论：<br />\n<strong>在推荐系统场景中，统一 Transformer 主干不仅带来结构表达优势，也带来更优的 scaling-law 斜率，即单位算力对应更高的性能增益。这一点是其相较于传统“组件拼接式扩展”方法的根本优势。</strong></p>\n<h2 id=\"46-rq5在线-ab-实验\">4.6 RQ5：在线 A/B 实验</h2>\n<p>我们在两个大规模工业场景中评估 OneTrans 的业务影响：</p>\n<ol>\n<li><strong>Feeds</strong>（首页信息流）</li>\n<li><strong>Mall</strong>（包含 Feeds 及其他子场景的整体业务环境）</li>\n</ol>\n<p>流量在用户/账号层级进行哈希切分与随机分配。控制组与实验组均基于过去 1.5 年的生产数据进行训练与部署，以确保对比公平。</p>\n<h3 id=\"实验设置\">实验设置</h3>\n<ul>\n<li>\n<p><strong>控制组（Control）</strong>：<br />\nRankMixer + Transformer（约 1 亿神经网络参数），不使用序列 KV 缓存。</p>\n</li>\n<li>\n<p><strong>实验组（Treatment）</strong>：<br />\nOneTransL，并采用第 3.5 节所述的服务端优化策略。</p>\n</li>\n</ul>\n<p>评估指标包括：</p>\n<ul>\n<li>用户级 click/u、order/u、gmv/u（相对 RankMixer+Transformer 的 Δ%）；</li>\n<li>双侧 95% 置信区间（基于用户分层 bootstrap）；</li>\n<li>端到端延迟（p99 每曝光延迟变化百分比，数值越低越好）。</li>\n</ul>\n<h3 id=\"实验结果\">实验结果</h3>\n<p>如表 6 所示，OneTransL 在两个场景均取得稳定提升。</p>\n<p><img alt=\"image-8\" class=\"lazyload\" /></p>\n<h4 id=\"feeds-场景\">Feeds 场景</h4>\n<ul>\n<li>click/u：+7.737%</li>\n<li>order/u：+4.3510%</li>\n<li>gmv/u：+5.6848%</li>\n<li>p99 延迟：−3.91%</li>\n</ul>\n<h4 id=\"mall-场景\">Mall 场景</h4>\n<ul>\n<li>click/u：+5.143%</li>\n<li>order/u：+2.5772%</li>\n<li>gmv/u：+3.6696%</li>\n<li>p99 延迟：−3.26%</li>\n</ul>\n<p>结果表明，相较于强基线 RankMixer+Transformer，统一建模框架在提升核心业务指标的同时，反而降低了线上服务延迟。</p>\n<h3 id=\"泛化能力分析\">泛化能力分析</h3>\n<p>进一步观察到：</p>\n<ul>\n<li>用户 Active Days 提升 +0.7478%；</li>\n<li>冷启动商品 order/u 提升 +13.59%。</li>\n</ul>\n<p>这说明 OneTrans 在冷启动与泛化能力方面具有显著优势，能够更有效地建模稀疏或低频行为模式。</p>\n<h3 id=\"综合结论-1\">综合结论</h3>\n<p>本节验证了统一 Transformer 主干不仅在离线指标与系统效率上具有优势，在真实大规模线上环境中亦能实现：</p>\n<ol>\n<li>显著的核心业务指标提升；</li>\n<li>服务延迟下降；</li>\n<li>冷启动泛化能力增强。</li>\n</ol>\n<p>从工程与业务双重维度看，OneTrans 实现了性能、效率与泛化能力的协同提升，证明统一建模设计在工业推荐系统中的实际可行性与商业价值。</p>\n<h2 id=\"5-结论\">5 结论</h2>\n<p>本文提出 OneTrans，一种用于个性化排序的统一 Transformer 主干结构，用以替代传统的“编码–交互”（encode–then–interaction）范式。</p>\n<p>该方法通过统一的 Tokenizer 将序列特征与非序列特征转换为单一 token 序列，并通过统一的 Transformer Block 在同一框架内同时完成序列建模与特征交互。其中：</p>\n<ul>\n<li>对同质的序列 token 共享参数；</li>\n<li>对异质的非序列 token 使用专属参数，以增强表达能力。</li>\n</ul>\n<p>为保证统一架构在大规模场景下的效率：</p>\n<ul>\n<li>采用金字塔式调度策略，逐层裁剪序列 token；</li>\n<li>使用跨请求 KV 缓存复用用户侧计算；</li>\n<li>同时引入大模型风格的系统优化技术，如 FlashAttention 与混合精度计算。</li>\n</ul>\n<p>在大规模实验中，OneTrans 随模型宽度与深度扩展呈现近似对数线性（log-linear）的性能增长趋势，并在真实线上环境中取得统计显著的业务指标提升，同时保持生产级延迟要求。</p>\n<p>总体而言，该统一设计为推荐系统的规模扩展提供了一条可行路径，使其能够直接复用近年来推动大语言模型发展的系统优化技术，实现模型能力与工程效率的协同提升。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-02-14 11:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GlenTt\">GlenTt</a>&nbsp;\n阅读(<span id=\"post_view_count\">19</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "7、InputStream的源码、FilterInputStream源码、BufferedInputStream的源码（windows操作系统，JDK8）",
      "link": "https://www.cnblogs.com/Carey-ccl/p/19585946",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Carey-ccl/p/19585946\" id=\"cb_post_title_url\" title=\"发布于 2026-02-14 09:26\">\n    <span>7、InputStream的源码、FilterInputStream源码、BufferedInputStream的源码（windows操作系统，JDK8）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"7、InputStream的源码、FilterInputStream源码、BufferedInputStream的源码（windows操作系统，JDK8）\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2485827/202602/2485827-20260206185514108-756686379.png\" />\n        https://img2024.cnblogs.com/blog/2485827/202602/2485827-20260206185514108-756686379.png\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>  阅读本文时，请先看我的另一篇博客：<a href=\"https://www.cnblogs.com/Carey-ccl/p/19613840\" target=\"_blank\" title=\"（InputStream的源码、FilterInputStream源码、BufferedInputStream的源码解读前言）AtomicReferenceFieldUpdater.class和System.arraycopy()函数的用法\">6、（InputStream的源码、FilterInputStream源码、BufferedInputStream的源码解读前言）AtomicReferenceFieldUpdater.class和System.arraycopy()函数的用法</a><br />\n  Java IO 库采用了装饰器模式（Decorator Pattern）和适配器模式（Adapter Pattern）的组合设计模式，其中InputStream是装饰器模式中顶层的抽象类，FilterInputStream是装饰器基类，BufferedInputStream是带有缓冲区的装饰器类，ObjectInputStream是可以读取对象的装饰器类，FileInputStream、ByteArrayInputStream则是被装饰的类。装饰器模式（Decorator Pattern）的详情，请查看我的另一篇blog<a href=\"https://www.cnblogs.com/Carey-ccl/p/19606087\" target=\"_blank\" title=\"四、装饰者模式\">四、装饰者模式</a></p>\n<h4 id=\"一inputstream-源码\">一、InputStream 源码</h4>\n<p>  InputStream 是所有表示字节输入流类的父类。windows操作系统的JDK8版本中，所有的InputStream的子类如下（此处只展示部分）：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  常用的InputStream子类有以下5个：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>①、FileInputStream：处理文件的输入流。<br />\n②、ByteArrayInputStream ：处理内存中byte[]数组的流式转换。<br />\n③、BufferedInputStream ：带缓冲区的字节数组输入流，一般配合FileInputStream一起使用（缓冲区可以减少IO次数）。<br />\n④、ObjectInputStream：从流中读入一个自定义的对象。需要与ObjectOutputStream与配合使用，且按同样的顺序（写入的对象的顺序决定了读取对象的顺序）。<br />\n⑤、StringBufferInputStream：处理内存中String对象的流式转换。<br />\n以上5个子类的使用方式请参照：我的另一篇博客<a href=\"https://www.cnblogs.com/Carey-ccl/articles/19566637\" target=\"_blank\" title=\"1、Java的IO概览（一）\">1、Java的IO概览（一）</a><br />\n  InputStream.class的源码如下：</p>\n<pre><code>package java.io;\n\npublic abstract class InputStream implements Closeable {\n\n    // skip()函数中可以使用的最大缓冲区大小\n    private static final int MAX_SKIP_BUFFER_SIZE = 2048;\n    //留给子类实现，子类必须遵守以下规则：\n    //1、从输入的Stream中读取输入数据的下一个字节（ASCII码值），在读取到数据或者抛出异常前，这个函数是阻塞的。\n    //2、返回一个0 ~ 255 的 ASCII码值 。如果因为已经读到了Stream末尾而没有可用的字节，则返回值 -1。\n    public abstract int read() throws IOException;\n     //将从输入的Stream中读取的ASCII码值放入到byte[]数组中，0表示从byte[]数组的第0个索引开始，b.length表示一次性向byte[]数组中放入的ASCII码值的数量\n     //在读取到数据或者抛出异常前，这个函数是阻塞的。\n    public int read(byte b[]) throws IOException {\n        return read(b, 0, b.length);\n    }\n    //将从输入的Stream中读取的字节（ASCII码值）放入到byte[]数组中，off表示从byte[]数组的第off个索引开始，len表示一次性向byte[]数组中放入的字节（ASCII码值）的数量\n     //在读取到数据或者抛出异常前，这个函数是阻塞的。\n    public int read(byte b[], int off, int len) throws IOException {\n        if (b == null) {//byte[]数组不能为空\n            throw new NullPointerException();\n        //范围检测，off和len必须是非负数，b.length - off是byte[]数组还可以放的字节（ASCII码值）的数量\n        } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {\n            throw new IndexOutOfBoundsException();//范围检查失败，抛出一个IndexOutOfBoundsException异常\n        } else if (len == 0) {//len=0，则直接返回0，该Stream可能有可读的字节（ASCII码值），也可能没有可读的字节（ASCII码值），但是本次不读任何数据。\n            return 0;\n        }\n\n        int c = read();//最终还是调用子类实现的read()函数\n        if (c == -1) {//read()函数规定了，返回值-1表示已经读到了Stream末尾而没有可用的字节（ASCII码值） \n            return -1;//如果一开始就读到了Stream末尾而没有可用的字节（ASCII码值），则直接返回-1 \n        }\n        b[off] = (byte)c;//如果一开始从Stream中可以读到字节（ASCII码值），则将读到的第1个字节（ASCII码值）值放入byte[]数组的第off个索引位置\n\n        //如果从Stream中读到了第1个字节（ASCII码值），则接着从Stream中读后面的字节（ASCII码值）\n        int i = 1;\n        try {\n            for (; i &lt; len ; i++) {\n                c = read();//最终还是调用子类实现的read()函数\n                if (c == -1) {\n                    break;//读不到，结束循环\n                }\n                b[off + i] = (byte)c;//每次从Stream中读到的字节（ASCII码值）都放到byte[]数组的第off个索引位置之后\n            }\n        } catch (IOException ee) {\n        }\n        return i;//返回从Stream中读到的字节数量\n    }\n    \n    //将从输入的Stream中跳过n个字节\n    public long skip(long n) throws IOException {\n        //还没(或者还需要)跳过的字节（ASCII码值）的总数量\n        long remaining = n;\n        int nr;\n        //校验，如果n&lt;=0，则返回0\n        if (n &lt;= 0) {\n            return 0;\n        }\n        //每次跳过的字节（ASCII码值）最多为2048个\n        int size = (int)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n        //用于每次跳过指定数量字节（每次最多为2048个）的数组\n        byte[] skipBuffer = new byte[size];\n        while (remaining &gt; 0) {//还需要跳过的字节（ASCII码值）数量&lt;=0时，跳出循环\n            //调用read(byte b[], int off, int len)函数，该函数在上面已经分析过，该函数的返回值有3种，含义如下：\n            //①、返回值=-1，表示该Stream没有可读的字节\n            //②、返回值=0，表示该Stream可能有可读的字节（ASCII码值），也可能没有可读的字节（ASCII码值），但是本次传入的Math.min(size, remaining)为0，不从Stream中读任何数据，此处的Math.min(size, remaining)不可能为0\n            //③、返回值&gt;0，表示从该Stream中读到的字节（ASCII码值）的数量\n            nr = read(skipBuffer, 0, (int)Math.min(size, remaining));\n            if (nr &lt; 0) {\n                break;//该Stream中没有可读的字节时，nr=-1，跳出循环\n            }\n            remaining -= nr;//表示还需要跳过的字节（ASCII码值）数量\n        }\n\n        return n - remaining;//返回已经跳过的字节（ASCII码值）的总数量\n    }\n    \n    //返回这个Stream中还可以读取的字节的总数量，JDK不建议将这个函数的返回值作为缓冲区的长度来从Stream中读取数据（子类一般会覆盖这个函数）\n    public int available() throws IOException {\n        return 0;\n    }\n    \n    //留给子类实现，子类必须遵守以下规则：\n    //关闭Stream，并释放与该流相关的系统资源\n    public void close() throws IOException {}\n    \n    //标记此Stream中的当前位置。随后调用reset()函数会将此流重新定位到上次标记的位置，从而使得后续的读取操作能够再次读取相同的字节。\n    //带有回退功能的InputStream的子类会重写这个函数，但是FileInputStream不会重写这个函数，也就意味着，FileInputStream不支持回退功能\n    public synchronized void mark(int readlimit) {}\n    \n    //reset()函数会将此流重新定位到上次标记的位置，从而使得后续的读取操作能够再次读取相同的字节。\n    //带有回退功能的InputStream的子类会重写这个函数，但是FileInputStream不会重写这个函数，也就意味着，FileInputStream不支持回退功能\n    public synchronized void reset() throws IOException {\n        throw new IOException(\"mark/reset not supported\");\n    }\n    //如果InputStream的子类支持mark()函数和 reset()函数，则返回true，否则，返回false（InputStream的子类不支持mark()函数和 reset()函数）。\n    public boolean markSupported() {\n        return false;\n    }\n\n}\n</code></pre>\n<h5 id=\"11inputstream的skip函数\">1.1、InputStream的skip()函数</h5>\n<pre><code>    public long skip(long n) throws IOException {\n        //还没(或者还需要)跳过的字节（ASCII码值）的总数量\n        long remaining = n;\n        int nr;\n        //校验，如果n&lt;=0，则返回0\n        if (n &lt;= 0) {\n            return 0;\n        }\n        //每次跳过的字节（ASCII码值）最多为2048个\n        int size = (int)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n        //用于每次跳过指定数量字节（每次最多为2048个）的数组\n        byte[] skipBuffer = new byte[size];\n        while (remaining &gt; 0) {//还需要跳过的字节（ASCII码值）数量&lt;=0时，跳出循环\n            //调用read(byte b[], int off, int len)函数，该函数在上面已经分析过，该函数的返回值有3种，含义如下：\n            //①、返回值=-1，表示该Stream没有可读的字节\n            //②、返回值=0，表示该Stream可能有可读的字节（ASCII码值），也可能没有可读的字节（ASCII码值），但是本次传入的Math.min(size, remaining)为0，不从Stream中读任何数据，此处的Math.min(size, remaining)不可能为0\n            //③、返回值&gt;0，表示从该Stream中读到的字节（ASCII码值）的数量\n            nr = read(skipBuffer, 0, (int)Math.min(size, remaining));\n            if (nr &lt; 0) {\n                break;//该Stream中没有可读的字节时，nr=-1，跳出循环\n            }\n            remaining -= nr;//表示还需要跳过的字节（ASCII码值）数量\n        }\n\n        return n - remaining;//返回已经跳过的字节（ASCII码值）的总数量\n    }\n</code></pre>\n<p>如果要从一个20000个字节的Stream中跳过6000个字节，只需要调用skip(6000)即可，该函数的执行过程分为以下4步：<br />\n①、while循环之前进行初始化byte[]数组和零时变量的操作<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、第1次while循环之后，已经从前Stream中读取了2048个字节<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>③、第2次while循环之后，已经从前Stream中读取了4096个字节<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>④、第3次while循环之后，已经从前Stream中读取了6000个字节，读取完毕，byte[]数组的前1094个位置是本次从Stream流中读取的第4097<sub>第6000个字节，byte[]数组的后954个位置仍然是上一次从Stream流中读取的第3143</sub>第4096个字节<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h4 id=\"二filterinputstream-源码装饰器基类\">二、FilterInputStream 源码——装饰器基类</h4>\n<p>  FilterInputStream 的UML关系图，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  FilterInputStream.class的源码，如下所示：</p>\n<pre><code>package java.io;\npublic\nclass FilterInputStream extends InputStream {\n   //用来组合了一个 被装饰者的变量，被修饰为volatile 有以下3个原因：\n    // 1. 确保多线程环境下修改的可见性\n    // 2. 有些装饰器允许运行时替换底层流\n    // 3. 防止指令重排序导致的初始化问题\n    protected volatile InputStream in;\n    //创建时传入一个 被装饰者\n    protected FilterInputStream(InputStream in) {\n        this.in = in;\n    }\n    //调用被装饰者的read()函数\n    public int read() throws IOException {\n        return in.read();\n    }\n    //调用被装饰者的read(byte b[]) 函数\n    public int read(byte b[]) throws IOException {\n        return read(b, 0, b.length);\n    }\n    //调用被装饰者的read(byte b[], int off, int len)函数\n    public int read(byte b[], int off, int len) throws IOException {\n        return in.read(b, off, len);\n    }\n    //调用被装饰者的skip()函数\n    public long skip(long n) throws IOException {\n        return in.skip(n);\n    }\n   //调用被装饰者的available()函数\n    public int available() throws IOException {\n        return in.available();\n    }\n   //调用被装饰者的close()函数\n    public void close() throws IOException {\n        in.close();\n    }\n    //调用被装饰者的mark()函数\n    public synchronized void mark(int readlimit) {\n        in.mark(readlimit);\n    }\n    //调用被装饰者的reset()函数\n    public synchronized void reset() throws IOException {\n        in.reset();\n    }\n    //调用被装饰者的markSupported()函数\n    public boolean markSupported() {\n        return in.markSupported();\n    }\n}\n</code></pre>\n<h4 id=\"三bufferedinputstream-源码带有缓冲区的装饰器类\">三、BufferedInputStream 源码——带有缓冲区的装饰器类</h4>\n<p>  BufferedInputStream.class 的UML关系图，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  BufferedInputStream.class的源码，如下所示：</p>\n<pre><code>package java.io;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n\npublic\nclass BufferedInputStream extends FilterInputStream {\n    // 默认缓冲区（byte[]数组）大小为8192 字节（8KB）\n    private static int DEFAULT_BUFFER_SIZE = 8192;\n    // 最大缓冲区（byte[]数组）大小为2147483639byte，大约2GB左右\n    private static int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n    //缓冲区数组，用volatile修饰是为了通过AtomicReferenceFieldUpdater进行CAS更新时保证内存的可见性\n    protected volatile byte buf[];\n    //底层是通过反射找到目标字段的内存偏移量，然后利用Unsafe.class提供的CAS（Compare-And-Swap）操作来原子地更新某个类中指定变量的值\n    private static final\n        AtomicReferenceFieldUpdater&lt;BufferedInputStream, byte[]&gt; bufUpdater =\n        AtomicReferenceFieldUpdater.newUpdater\n        (BufferedInputStream.class,  byte[].class, \"buf\");\n\n    //缓冲区（byte[]数组）中有效字的节数数量\n    protected int count;\n    //准备从缓冲区中（byte[]数组）读取的字节索引位置，取值范围为0&lt;=pos&lt;=count\n    protected int pos;\n    //在缓冲区（byte[]数组）中标记的某个索引位置，-1&lt;=markpos&lt;=pos\n    //该变量只会在 fill()函数和mark()函数中赋值\n    protected int markpos = -1;\n    // 标记后最多可读取字节数量，该变量只会在 mark()函数中赋值\n    //每当pos-markpos&gt;marklimit时，就会设置markpos=-1 来删除标记\n    protected int marklimit;\n\n     //如果被装饰的输入流不为空，则返回被装饰的输入Stream（该变量在FilterInputStream中定义）\n    private InputStream getInIfOpen() throws IOException {\n        InputStream input = in;\n        if (input == null)\n            throw new IOException(\"Stream closed\");\n        return input;\n    }\n\n    //如果缓冲区（byte[]数组）不为空，则返回该缓冲区（byte[]数组），否则抛出异常\n    private byte[] getBufIfOpen() throws IOException {\n        byte[] buffer = buf;\n        if (buffer == null)\n            throw new IOException(\"Stream closed\");\n        return buffer;\n    }\n    \n    //构造函数，需要传入一个被装饰的输入Stream, 缓冲区（byte[]数组）的长度是8192 （默认值,8KB）\n    public BufferedInputStream(InputStream in) {\n        this(in, DEFAULT_BUFFER_SIZE);\n    }\n    //构造函数，需要传入一个被装饰的输入Stream和缓冲区（byte[]数组）的长度\n    public BufferedInputStream(InputStream in, int size) {\n        super(in);\n        if (size &lt;= 0) {//校验，缓冲区（byte[]数组）的长度必须&gt;0\n            throw new IllegalArgumentException(\"Buffer size &lt;= 0\");\n        }\n        buf = new byte[size];\n    }\n\n    private void fill() throws IOException {\n        byte[] buffer = getBufIfOpen();//获取缓冲区（byte[]数组）\n        if (markpos &lt; 0)//如果还没有调用过mark()函数，那么markpos=-1 \n            pos = 0;//pos=0，可以从缓冲区（byte[]数组）的索引0的位置开始读字节了\n        else if (pos &gt;= buffer.length)  \n            if (markpos &gt; 0) {  //场景一：pos&gt;=缓冲区（byte[]数组）的长度并且markpos &gt;0\n                int sz = pos - markpos;\n                //只把缓冲区（byte[]数组）中[markpos,pos) 索引区间的元素复制到缓冲区（byte[]数组）[0,pos-markpos）索引区间\n                System.arraycopy(buffer, markpos, buffer, 0, sz);\n                pos = sz;//设置pos=pos-markpos\n                markpos = 0;//设置markpos=0\n            } else if (buffer.length &gt;= marklimit) {//场景二：pos&gt;=缓冲区（byte[]数组）的长度并且缓冲区（byte[]数组）的长度&gt;= marklimit\n                markpos = -1;   //设置markpos = -1\n                pos = 0;       //设置pos = 0\n            } else if (buffer.length &gt;= MAX_BUFFER_SIZE) {//场景三：pos&gt;=缓冲区（byte[]数组）的长度并且缓冲区（byte[]数组）的长度 &gt;= 2147483639\n                throw new OutOfMemoryError(\"Required array size too large\");\n            } else {//场景四：pos&gt;=缓冲区（byte[]数组）的长度并且不满足场景一、二、三时，将缓冲区（byte[]数组）扩容\n                //如果pos&lt;2147483639/2，则新缓冲区（byte[]数组）的长度nsz=pos*2，否则新缓冲区（byte[]数组）的长度nsz=2147483639\n                int nsz = (pos &lt;= MAX_BUFFER_SIZE - pos) ?\n                        pos * 2 : MAX_BUFFER_SIZE;\n                if (nsz &gt; marklimit)\n                    nsz = marklimit;//当新缓冲区（byte[]数组）的长度nsz&gt;marklimit，新缓冲区（byte[]数组）的长度nsz=marklimit\n                byte nbuf[] = new byte[nsz];//新建一个新缓冲区（byte[]数组）\n                System.arraycopy(buffer, 0, nbuf, 0, pos);//将老缓冲区（byte[]数组）中[0,pos)索引区间的元素复制到新缓冲区（byte[]数组）[0,pos)索引区间\n                if (!bufUpdater.compareAndSet(this, buffer, nbuf)) {//通过CAS（Compare-And-Swap）操作来原子地更新buf变量\n                    // Can't replace buf if there was an async close.\n                    // Note: This would need to be changed if fill()\n                    // is ever made accessible to multiple threads.\n                    // But for now, the only way CAS can fail is via close.\n                    // assert buf == null;\n                    throw new IOException(\"Stream closed\");\n                }\n                buffer = nbuf;//新缓冲区（byte[]数组）创建完毕\n            }\n        count = pos;\n        //将被装饰的输入Stream中的字节读取到缓冲区（byte[]数组）的[pos,buffer.length - pos)索引位置，并返回读取的字节数量\n        int n = getInIfOpen().read(buffer, pos, buffer.length - pos);\n        if (n &gt; 0)\n            count = n + pos;//count=从被装饰的输入Stream中读取的字节数量+pos\n    }\n    \n    //线程同步的函数：从缓冲区（byte[]数组）中读取1个字节\n    public synchronized int read() throws IOException {\n        //pos=count有2种情况（pos不可能&gt;count）：\n        //场景一：pos=count=0，缓冲区（byte[]数组）还没有填充任何数据。\n        //场景二：pos=count≠0，缓冲区（byte[]数组）中的数据已经通过pos读取完了。\n        if (pos &gt;= count) {\n            fill();//符合场景一或场景二都会调用fill()函数\n            if (pos &gt;= count)\n                return -1;//如果调用了fill()函数后，仍然符合场景一或场景二，表示被装饰的输入Stream已经读完了，返回-1\n        }\n        //执行到这里时，表明pos &lt; count，返回缓冲区（byte[]数组）pos索引位置的字节;\n        return getBufIfOpen()[pos++] &amp; 0xff;\n    }\n\n    //从缓冲区（byte[]数组）或被装饰的输入Stream中读取len个字节到指定的byte[]数组b中，这len个字节被放到byte[]数组b的[off,off+len)索引位置。\n    //该函数只被read()函数调用\n    private int read1(byte[] b, int off, int len) throws IOException {\n        //只在fill()函数中修改count变量的值，count变量的值只有以下2种可能\n        //①、count==pos；②、count=从被装饰的输入Stream中读取的字节数量+pos\n        //因此avail表示缓冲区（byte[]数组）中[pos,pos+count)索引位置的字节数量\n        int avail = count - pos;\n        if (avail &lt;= 0) {//缓冲区（byte[]数组）中[pos,pos+count)索引位置的字节数量&lt;=0（其实不可能&lt;0，只可能=0）\n            //要读取的len个字节&gt;=缓冲区（byte[]数组）的长度，同时markpos = -1\n            if (len &gt;= getBufIfOpen().length &amp;&amp; markpos &lt; 0) {\n                return getInIfOpen().read(b, off, len);//从被装饰的输入Stream中读取len个字节到指定的byte[]数组b中，这len个字节被放到byte[]数组b的[off,off+len)索引位置。\n            }\n            fill();//调用fill()函数\n            avail = count - pos;//重新计算avail\n            if (avail &lt;= 0) return -1;//如果avail仍然=0，返回-1\n        }\n        int cnt = (avail &lt; len) ? avail : len;//此时avail&gt;0，取avail和len中较小的值作为本次从缓冲区（byte[]数组）中读取的字节数量\n        System.arraycopy(getBufIfOpen(), pos, b, off, cnt);//从缓冲区（byte[]数组）的pos索引开始，读取avail或len（2者取其小）个字节到指定的byte[]数组b的[off,off+cnt)索引位置（cnt就是avail或len中2者取其小的值）\n        pos += cnt;//pos向前移动avail或len（2者取其小）个索引位置\n        return cnt;//返回avail或len（2者取其小）\n    }\n    \n    //线程同步的函数：从缓冲区（byte[]数组）中读取len个字节到指定的byte[]数组b中，这len个字节被放到byte[]数组b的[off,off+len)索引位置。\n    public synchronized int read(byte b[], int off, int len)\n        throws IOException\n    {\n        getBufIfOpen(); //检测被装饰的输入Stream是否关闭\n        if ((off | len | (off + len) | (b.length - (off + len))) &lt; 0) {//相当于off + len &gt; b.length（这样写代码的好处我没看出来）\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;//要从缓冲区（byte[]数组）中读取的len个字节==0时，返回0\n        }\n\n        int n = 0;//累计从缓冲区（byte[]数组）或被装饰的输入Stream中读取的字节数量\n        for (;;) {//循环调用read1()函数完成从缓冲区（byte[]数组）或被装饰的输入Stream中读取len个字节到指定的byte[]数组b中，这len个字节被放到byte[]数组b的[off,off+len)索引位置。\n            int nread = read1(b, off + n, len - n);//nread用来统计每次从read1()函数中读取一定的字节数量，并放到byte[]数组b的[off,off+len)索引位置。\n            if (nread &lt;= 0)\n                return (n == 0) ? nread : n;//当read1()函数返回0或者-1时，表示缓冲区（byte[]数组）中和被装饰的输入Stream中已经没有可以读取的字节了\n            n += nread;//累计从缓冲区（byte[]数组）或被装饰的输入Stream中读取的字节数量\n            if (n &gt;= len)//累计从缓冲区（byte[]数组）或被装饰的输入Stream中读取的字节数量总和&gt;=len时（其实不可能&gt;len，只可能=len）\n                return n;//返回n\n            // 被装饰的输入Stream中已经没有字节可以用了，返回累计从缓冲区（byte[]数组）或被装饰的输入Stream中读取的字节数量总和\n            InputStream input = in;\n            if (input != null &amp;&amp; input.available() &lt;= 0)\n                return n;\n        }\n    }\n    \n    //线程同步的函数：从缓冲区（byte[]数组）中跳过了n个字节\n    public synchronized long skip(long n) throws IOException {\n        getBufIfOpen(); //检测被装饰的输入Stream是否关闭\n        if (n &lt;= 0) {\n            return 0;\n        }\n        //只在fill()函数中修改count变量的值，count变量的值只有以下2种可能\n        //①、count==pos；②、count=从被装饰的输入Stream中读取的字节数量+pos\n        //因此avail表示缓冲区（byte[]数组）中[pos,pos+count)索引位置的字节数量\n        long avail = count - pos;\n\n        if (avail &lt;= 0) {//缓冲区（byte[]数组）中[pos,pos+count)索引位置的字节数量&lt;=0（其实不可能&lt;0，只可能=0）\n            // If no mark position set then don't keep in buffer\n            if (markpos &lt;0)//同时markpos&lt;0 \n                return getInIfOpen().skip(n);//调用被装饰的输入Stream的skip()函数\n\n            // Fill in buffer to save bytes for reset\n            fill();//调用fill()函数（跟read1()函数中的操作一样）\n            avail = count - pos;//重新计算avail（跟read1()函数中的操作一样）\n            if (avail &lt;= 0)\n                return 0;//如果avail仍然=0，返回-1\n        }\n\n        long skipped = (avail &lt; n) ? avail : n;//此时avail&gt;0，取avail和n中较小的值作为本次从缓冲区（byte[]数组）中跳过的字节数量\n        pos += skipped;//pos向前移动avail或n（2者取其小）个索引位置（与read1()函数异曲同工），表示本次从缓冲区（byte[]数组）中跳过了skipped个字节\n        return skipped;//返回本次从缓冲区（byte[]数组）中跳过的skipped个字节\n    }\n    \n    //线程同步的函数：计算缓冲区（byte[]数组）的最大长度（或者叫容量）\n    public synchronized int available() throws IOException {\n        //只在fill()函数中修改count变量的值，count变量的值只有以下2种可能\n        //①、count==pos；②、count=从被装饰的输入Stream中读取的字节数量+pos\n        //因此count - pos表示缓冲区（byte[]数组）中[pos,pos+count)索引位置的字节数量\n        int n = count - pos;\n        int avail = getInIfOpen().available();//调用被装饰的输入Stream的available()函数，返回被装饰的输入Stream中仍然可以读取的字节数量\n        return n &gt; (Integer.MAX_VALUE - avail)//(缓冲区（byte[]数组）中[pos,pos+count)索引位置的字节数量 + 被装饰的输入Stream中仍然可以读取的字节数量) &gt; 2147483647时，返回2147483647，表示缓冲区（byte[]数组）的最大容量为2147483647\n                    ? Integer.MAX_VALUE\n                    : n + avail;//返回(缓冲区（byte[]数组）中[pos,pos+count)索引位置的字节数量 + 被装饰的输入Stream中仍然可以读取的字节数量)，表示缓冲区（byte[]数组）的最大容量为该数量\n    }\n\n    //线程同步的函数：给marklimit和 markpos赋值（或者叫标记 marklimit和 markpos）\n    public synchronized void mark(int readlimit) {\n        marklimit = readlimit;\n        markpos = pos;\n    }\n    //线程同步的函数：pos = markpos（或者叫对齐pos索引位置 到markpos索引位置）\n    public synchronized void reset() throws IOException {\n        getBufIfOpen(); //检测被装饰的输入Stream是否关闭\n        if (markpos &lt; 0)\n            throw new IOException(\"Resetting to invalid mark\");\n        pos = markpos;\n    }\n    \n    //返回当前这个class是否支持mark()函数和 reset()函数\n    public boolean markSupported() {\n        return true;\n    }\n    \n    //关闭被装饰的输入Stream，释放缓冲区（byte[]数组），让gc回收。\n    public void close() throws IOException {\n        byte[] buffer;\n        while ( (buffer = buf) != null) {\n            if (bufUpdater.compareAndSet(this, buffer, null)) {\n                InputStream input = in;\n                in = null;\n                if (input != null)\n                    input.close();\n                return;\n            }\n            // Else retry in case a new buf was CASed in fill()\n        }\n    }\n}\n</code></pre>\n<h5 id=\"31bufferedinputstream的read函数和fill函数\">3.1、BufferedInputStream的read()函数和fill()函数</h5>\n<pre><code>public\nclass BufferedInputStream extends FilterInputStream {\n    ...省略部分代码...\n    // 默认缓冲区（byte[]数组）大小为8192 字节（8KB）\n    private static int DEFAULT_BUFFER_SIZE = 8192;\n    // 最大缓冲区（byte[]数组）大小为2147483639byte，大约2GB左右\n    private static int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n    //缓冲区数组，用volatile修饰是为了通过AtomicReferenceFieldUpdater进行CAS更新时保证内存的可见性\n    protected volatile byte buf[];\n    //底层是通过反射找到目标字段的内存偏移量，然后利用Unsafe.class提供的CAS（Compare-And-Swap）操作来原子地更新某个类中指定变量的值\n    private static final\n        AtomicReferenceFieldUpdater&lt;BufferedInputStream, byte[]&gt; bufUpdater =\n        AtomicReferenceFieldUpdater.newUpdater\n        (BufferedInputStream.class,  byte[].class, \"buf\");\n\n    //缓冲区（byte[]数组）中有效字的节数数量\n    protected int count;\n    //准备从缓冲区中（byte[]数组）读取的字节索引位置，取值范围为0&lt;=pos&lt;=count\n    protected int pos;\n    //在缓冲区（byte[]数组）中标记的某个索引位置，-1&lt;=markpos&lt;=pos\n    //该变量只会在 fill()函数和mark()函数中赋值\n    protected int markpos = -1;\n    // 标记后最多可读取字节数量，该变量只会在 mark()函数中赋值\n    //每当pos-markpos&gt;marklimit时，就会设置markpos=-1 来删除标记\n    protected int marklimit;\n   \n   //如果缓冲区（byte[]数组）不为空，则返回该缓冲区（byte[]数组），否则抛出异常\n    private byte[] getBufIfOpen() throws IOException {\n        byte[] buffer = buf;\n        if (buffer == null)\n            throw new IOException(\"Stream closed\");\n        return buffer;\n    }\n    \n    private void fill() throws IOException {\n        byte[] buffer = getBufIfOpen();//获取缓冲区（byte[]数组）\n        if (markpos &lt; 0)//如果还没有调用过mark()函数，那么markpos=-1 \n            pos = 0;//pos=0，可以从缓冲区（byte[]数组）的索引0的位置开始读字节了\n        else if (pos &gt;= buffer.length)  \n            if (markpos &gt; 0) {  //场景一：pos&gt;=缓冲区（byte[]数组）的长度并且markpos &gt;0\n                int sz = pos - markpos;\n                //只把缓冲区（byte[]数组）中[markpos,pos) 索引区间的元素复制到缓冲区（byte[]数组）[0,pos-markpos）索引区间\n                System.arraycopy(buffer, markpos, buffer, 0, sz);\n                pos = sz;//设置pos=pos-markpos\n                markpos = 0;//设置markpos=0\n            } else if (buffer.length &gt;= marklimit) {//场景二：pos&gt;=缓冲区（byte[]数组）的长度并且缓冲区（byte[]数组）的长度&gt;= marklimit\n                markpos = -1;   //设置markpos = -1\n                pos = 0;       //设置pos = 0\n            } else if (buffer.length &gt;= MAX_BUFFER_SIZE) {//场景三：pos&gt;=缓冲区（byte[]数组）的长度并且缓冲区（byte[]数组）的长度 &gt;= 2147483639\n                throw new OutOfMemoryError(\"Required array size too large\");\n            } else {//场景四：pos&gt;=缓冲区（byte[]数组）的长度并且不满足场景一、二、三时，将缓冲区（byte[]数组）扩容\n                //如果pos&lt;2147483639/2，则新缓冲区（byte[]数组）的长度nsz=pos*2，否则新缓冲区（byte[]数组）的长度nsz=2147483639\n                int nsz = (pos &lt;= MAX_BUFFER_SIZE - pos) ?\n                        pos * 2 : MAX_BUFFER_SIZE;\n                if (nsz &gt; marklimit)\n                    nsz = marklimit;//当新缓冲区（byte[]数组）的长度nsz&gt;marklimit，新缓冲区（byte[]数组）的长度nsz=marklimit\n                byte nbuf[] = new byte[nsz];//新建一个新缓冲区（byte[]数组）\n                System.arraycopy(buffer, 0, nbuf, 0, pos);//将老缓冲区（byte[]数组）中[0,pos)索引区间的元素复制到新缓冲区（byte[]数组）[0,pos)索引区间\n                if (!bufUpdater.compareAndSet(this, buffer, nbuf)) {//通过CAS（Compare-And-Swap）操作来原子地更新buf变量\n                    // Can't replace buf if there was an async close.\n                    // Note: This would need to be changed if fill()\n                    // is ever made accessible to multiple threads.\n                    // But for now, the only way CAS can fail is via close.\n                    // assert buf == null;\n                    throw new IOException(\"Stream closed\");\n                }\n                buffer = nbuf;//新缓冲区（byte[]数组）创建完毕\n            }\n        count = pos;\n        //将被装饰的输入Stream中的字节读取到缓冲区（byte[]数组）的[pos,buffer.length - pos)索引位置，并返回读取的字节数量\n        int n = getInIfOpen().read(buffer, pos, buffer.length - pos);\n        if (n &gt; 0)\n            count = n + pos;//count=从被装饰的输入Stream中读取的字节数量+pos\n    } \n    \n    //线程同步的函数：从缓冲区（byte[]数组）中读取1个字节\n    public synchronized int read() throws IOException {\n        //pos=count有2种情况（pos不可能&gt;count）：\n        //场景一：pos=count=0，缓冲区（byte[]数组）还没有填充任何数据。\n        //场景二：pos=count≠0，缓冲区（byte[]数组）中的数据已经通过pos读取完了。\n        if (pos &gt;= count) {\n            fill();//符合场景一或场景二都会调用fill()函数\n            if (pos &gt;= count)\n                return -1;//如果调用了fill()函数后，仍然符合场景一或场景二，表示被装饰的输入Stream已经读完了，返回-1\n        }\n        //执行到这里时，表明pos &lt; count，返回缓冲区（byte[]数组）pos索引位置的字节;\n        return getBufIfOpen()[pos++] &amp; 0xff;\n    }\n    ...省略部分代码...\n}\n</code></pre>\n<p>如果使用者用的是默认的构造函数创建了BufferedInputStream的对象，如下所示（伪代码）：</p>\n<pre><code>InputStream is = new FileInputStream(\"D:\\\\nio-data.txt\");\nBufferedInputStream bis = new BufferedInputStream(is);\n</code></pre>\n<p>那么，BufferedInputStream对象中的缓冲区（byte[]数组）的长度为8192（缓存8KB字节），如果此时执行BufferedInputStream.class::read()函数，</p>\n<pre><code>bis.read();\n</code></pre>\n<p>过程如下（假设被装饰的输入Stream（FileInputStream）中有10000个字节）：<br />\n①、pos=count=0，缓冲区（byte[]数组）中还没有填充任何数据，执行fill()函数，然后将被装饰的输入Stream（FileInputStream）中的字节读取到缓冲区（byte[]数组）的[0,8192)索引位置（左闭右开，不包括byte[]数组的第8192个索引位置），并返回读取的字节数量。如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，被装饰的输入Stream（FileInputStream）中的字节和缓冲区（byte[]数组）中的字节，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、更新int count变量，fill()函数中getInIfOpen().read(buffer, pos, buffer.length - pos)这行代码的返回值为8192，count=8192+pos=8192；<br />\n③、执行getBufIfOpen()[pos++] &amp; 0xff，从缓冲区（byte[]数组）中获取第pos（此时pos=0）个索引位置的字节，返回给BufferedInputStream.class::read()函数的调用方，并更新pos的值为pos+=1；<br />\n  之后，每次调用BufferedInputStream.class::read()函数时，都不会再执行fill()函数了，直到pos=8192时，执行BufferedInputStream.class::read()函数才会再次执行fill()函数，新的填充缓冲区（byte[]数组）的过程如下：<br />\n①、更新pos=0，count=0，缓冲区（byte[]数组）中是上一次执行fill()函数填充的从被装饰的输入Stream（FileInputStream）读取的第1<sub>8192个字节，本次，需要将被装饰的输入Stream（FileInputStream）中的第8193</sub>10000个字节读取到缓冲区（byte[]数组）的[0,1808)索引位置（左闭右开，不包括byte[]数组的第1808个索引位置），并返回读取的字节数量。如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，被装饰的输入Stream（FileInputStream）中的字节被全部读取完毕，被装饰的输入Stream（FileInputStream）为空。<br />\n②、更新int count变量，fill()函数中getInIfOpen().read(buffer, pos, buffer.length - pos)这行代码的返回值为1808，count=1808+pos=1808；<br />\n③、执行getBufIfOpen()[pos++] &amp; 0xff，从缓冲区（byte[]数组）中获取第pos（此时pos=0）个索引位置的字节，返回给BufferedInputStream.class::read()函数的调用方，并更新pos的值为pos+=1；<br />\n  之后，每次调用BufferedInputStream.class::read()函数时，都不会再执行fill()函数了，直到pos=1808时，执行BufferedInputStream.class::read()函数才会再次执行fill()函数，过程如下：<br />\n①、更新pos=0，count=0，缓冲区（byte[]数组）中的数据如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，由于被装饰的输入Stream（FileInputStream）中的字节被全部读取完毕，fill()函数中getInIfOpen().read(buffer, pos, buffer.length - pos)这行代码的返回值为0，无法更新count，结束fill()函数的调用<br />\n②、执行return -1，返回给BufferedInputStream.class::read()函数的调用方；</p>\n<h6 id=\"311如果在多次执行bufferedinputstreamclassread函数之前执行过mark函数\">3.1.1、如果在多次执行BufferedInputStream.class::read()函数之前执行过mark()函数</h6>\n<p>  标题3.1分析了很多次只调用read()函数之后，最后缓冲区（byte[]数组）中的字节内容，并没有分析很多次调用read()函数之前，很多次调用read()函数之中，很多次调用read()函数之后分别调用了mark()函数和reset()函数的场景。<br />\n  如果在很多次调用read()函数之前调用了mark(8192)函数，如下（伪代码）：</p>\n<pre><code>InputStream is = new FileInputStream(\"D:\\\\nio-data.txt\");\nBufferedInputStream bis = new BufferedInputStream(is);\nbis.mark(8192);//设置marklimit=8192，markpos=pos=0\nint bytesRead;\nwhile ((bytesRead = bis.read()) != -1) {\n    //处理读取到的字节bytesRead\n}\n</code></pre>\n<p>那么，BufferedInputStream对象中的缓冲区（byte[]数组）的长度为8192（缓存8KB字节），如果此时，如上述代码一样在，while循环中执行BufferedInputStream.class::read()函数，过程如下（假设被装饰的输入Stream（FileInputStream）中有10000个字节）：<br />\n①、pos=count=0，缓冲区（byte[]数组）中还没有填充任何数据，执行fill()函数，然后将被装饰的输入Stream（FileInputStream）中的字节读取到缓冲区（byte[]数组）的[0,8192)索引位置（左闭右开，不包括byte[]数组的第8192个索引位置），并返回读取的字节数量。如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，被装饰的输入Stream（FileInputStream）中的字节和缓冲区（byte[]数组）中的字节，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、更新int count变量，fill()函数中getInIfOpen().read(buffer, pos, buffer.length - pos)这行代码的返回值为8192，count=8192+pos=8192；<br />\n③、执行getBufIfOpen()[pos++] &amp; 0xff，从缓冲区（byte[]数组）中获取第pos（此时pos=0）个索引位置的字节，返回给BufferedInputStream.class::read()函数的调用方，并更新pos的值为pos+=1；<br />\n  之后，每次调用BufferedInputStream.class::read()函数时，都不会再执行fill()函数了，直到pos=8192时，执行BufferedInputStream.class::read()函数才会再次执行fill()函数，新的填充缓冲区（byte[]数组）的过程如下：<br />\n①、此时，因为buffer.length &gt;= marklimit，所以，更新markpos=-1，pos=0；<br />\n  后续的步骤与标题3.1相同。最终缓冲区（byte[]数组）中的数据如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>最终，pos=0，count=0，markpos=-1</p>\n<h6 id=\"312如果在多次执行bufferedinputstreamclassread函数之中执行过mark函数\">3.1.2、如果在多次执行BufferedInputStream.class::read()函数之中执行过mark()函数</h6>\n<p>  如果在很多次调用read()函数之中调用了mark(8192)函数，如下（伪代码）：</p>\n<pre><code>InputStream is = new FileInputStream(\"D:\\\\nio-data.txt\");\nBufferedInputStream bis = new BufferedInputStream(is);\nint bytesRead;\nint i = 0;\nwhile ((bytesRead = bis.read()) != -1) {\n    if(++i==4096){\n        bis.mark(8192);//设置marklimit=8192，markpos=pos=4096\n    }\n    //处理读取到的字节bytesRead\n}\n</code></pre>\n<p>那么，BufferedInputStream对象中的缓冲区（byte[]数组）的长度为8192（缓存8KB字节），上述代码的执行过程如下（假设被装饰的输入Stream（FileInputStream）中有20000个字节）：<br />\n①、pos=count=0，缓冲区（byte[]数组）中还没有填充任何数据，执行fill()函数，然后将被装饰的输入Stream（FileInputStream）中的字节读取到缓冲区（byte[]数组）的[0,8192)索引位置（左闭右开，不包括byte[]数组的第8192个索引位置），并返回读取的字节数量。如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，被装饰的输入Stream（FileInputStream）中的字节和缓冲区（byte[]数组）中的字节，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、更新int count变量，fill()函数中getInIfOpen().read(buffer, pos, buffer.length - pos)这行代码的返回值为8192，count=8192+pos=8192；<br />\n③、执行getBufIfOpen()[pos++] &amp; 0xff，从缓冲区（byte[]数组）中获取第pos（此时pos=0）个索引位置的字节，返回给BufferedInputStream.class::read()函数的调用方，并更新pos的值为pos+=1；<br />\n  之后，每次调用BufferedInputStream.class::read()函数时，都不会再执行fill()函数了，并且当pos=4096时，执行了bis.mark(8192)，设置marklimit=8192，markpos=pos=4096。<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  直到pos=8192时，执行BufferedInputStream.class::read()函数才会再次执行fill()函数，本次填充缓冲区（byte[]数组）的过程如下：<br />\n①、执行fill()函数的如下代码片段（标题3.1.4也会复用之后的逻辑）</p>\n<pre><code>        ...省略部分代码...\n        else if (pos &gt;= buffer.length)  \n            if (markpos &gt; 0) {  //场景一：pos&gt;=缓冲区（byte[]数组）的长度并且markpos &gt;0\n                int sz = pos - markpos;\n                //只把缓冲区（byte[]数组）中[markpos,pos) 索引区间的元素复制到缓冲区（byte[]数组）[0,pos-markpos）索引区间\n                System.arraycopy(buffer, markpos, buffer, 0, sz);\n                pos = sz;//设置pos=pos-markpos\n                markpos = 0;//设置markpos=0\n            }\n        ...省略部分代码...\n</code></pre>\n<p>先把缓冲区（byte[]数组）中[4096,8192) 索引区间的元素复制到缓冲区（byte[]数组）[0,4096）索引区间，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>再更新pos=4096，markpos = 0；<br />\n②、然后从被装饰的输入Stream（FileInputStream）读取第8193~12286个字节到缓冲区（byte[]数组）的[4096,8192)索引位置（左闭右开，不包括byte[]数组的第8192个索引位置），并返回读取的字节数量。如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>然后更新count，此时count = n + pos=4096+4096=8192，pos=4096，markpos = 0<br />\n③、执行getBufIfOpen()[pos++] &amp; 0xff，从缓冲区（byte[]数组）中获取第pos（此时pos=4096）个索引位置的字节，返回给BufferedInputStream.class::read()函数的调用方，并更新pos的值为pos+=1；<br />\n  之后，每次调用BufferedInputStream.class::read()函数时，都不会再执行fill()函数了，直到pos=8192时（此时，count = 8192，markpos=0），执行BufferedInputStream.class::read()函数才会再次执行fill()函数，后续过程分为以下2种情景：</p>\n<ul>\n<li>情景一，如上伪代码bis.mark(8192)，设置marklimit=8192&lt;=缓冲区（byte[]数组）的长度</li>\n</ul>\n<p>①、执行fill()函数的如下代码片段：</p>\n<pre><code>            ...省略部分代码...\n            } else if (buffer.length &gt;= marklimit) {//场景二：pos&gt;=缓冲区（byte[]数组）的长度并且缓冲区（byte[]数组）的长度&gt;= marklimit\n                markpos = -1;   //设置markpos = -1\n                pos = 0;       //设置pos = 0\n            }\n            ...省略部分代码...\n</code></pre>\n<p>先更新pos = 0，markpos = -1；然后从被装饰的输入Stream（FileInputStream）读取第12287~20000个字节到缓冲区（byte[]数组）的[0,7914)索引位置（左闭右开，不包括byte[]数组的第7914个索引位置），并返回读取的字节数量。如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，被装饰的输入Stream（FileInputStream）中的字节被全部读取完毕，被装饰的输入Stream（FileInputStream）为空。<br />\n②、更新int count变量，fill()函数中getInIfOpen().read(buffer, pos, buffer.length - pos)这行代码的返回值为7914，count=7914+0=7914；<br />\n③、执行getBufIfOpen()[pos++] &amp; 0xff，从缓冲区（byte[]数组）中获取第pos（此时pos=0）个索引位置的字节，返回给BufferedInputStream.class::read()函数的调用方，并更新pos的值为pos+=1；<br />\n  之后，每次调用BufferedInputStream.class::read()函数时，都不会再执行fill()函数了，直到pos=7914时，执行BufferedInputStream.class::read()函数才会再次执行fill()函数，过程如下：<br />\n①、因为markpos = -1，所以更新pos=0，count=0，缓冲区（byte[]数组）中的数据如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，由于被装饰的输入Stream（FileInputStream）中的字节被全部读取完毕，fill()函数中getInIfOpen().read(buffer, pos, buffer.length - pos)这行代码的返回值为0，无法更新count，结束fill()函数的调用<br />\n②、执行return -1，返回给BufferedInputStream.class::read()函数的调用方；</p>\n<ul>\n<li>情景二，改变上面的伪代码bis.mark(8192)，而是设置marklimit&gt;缓冲区（byte[]数组）的长度（只要是大于8192的任何值都可以），比如bis.mark(16384)</li>\n</ul>\n<p>①、执行fill()函数的如下代码片段，</p>\n<pre><code>           ...省略部分代码...\n            } else {//场景四：pos&gt;=缓冲区（byte[]数组）的长度并且不满足场景一、二、三时，将缓冲区（byte[]数组）扩容\n                //如果pos&lt;2147483639/2，则新缓冲区（byte[]数组）的长度nsz=pos*2，否则新缓冲区（byte[]数组）的长度nsz=2147483639\n                int nsz = (pos &lt;= MAX_BUFFER_SIZE - pos) ?\n                        pos * 2 : MAX_BUFFER_SIZE;\n                if (nsz &gt; marklimit)\n                    nsz = marklimit;//当新缓冲区（byte[]数组）的长度nsz&gt;marklimit，新缓冲区（byte[]数组）的长度nsz=marklimit\n                byte nbuf[] = new byte[nsz];//新建一个新缓冲区（byte[]数组）\n                System.arraycopy(buffer, 0, nbuf, 0, pos);//将老缓冲区（byte[]数组）中[0,pos)索引区间的元素复制到新缓冲区（byte[]数组）[0,pos)索引区间\n                if (!bufUpdater.compareAndSet(this, buffer, nbuf)) {//通过CAS（Compare-And-Swap）操作来原子地更新buf变量\n                    // Can't replace buf if there was an async close.\n                    // Note: This would need to be changed if fill()\n                    // is ever made accessible to multiple threads.\n                    // But for now, the only way CAS can fail is via close.\n                    // assert buf == null;\n                    throw new IOException(\"Stream closed\");\n                }\n                buffer = nbuf;//新缓冲区（byte[]数组）创建完毕\n            }\n            ...省略部分代码...\n</code></pre>\n<p>先扩大缓冲区（byte[]数组）的长度到16384（扩大前缓冲区长度为8192），然后将旧缓冲区（byte[]数组）中的内容移动到新缓冲区（byte[]数组）对应的索引位置上，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>然后通过CAS（Compare-And-Swap）操作来原子地更新buf变量的引用。<br />\n②、然后从被装饰的输入Stream（FileInputStream）读取第12287~20000个字节到新缓冲区（byte[]数组）的[8192,16106)索引位置（左闭右开，不包括新byte[]数组的第16106个索引位置），并返回读取的字节数量。如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，被装饰的输入Stream（FileInputStream）中的字节被全部读取完毕，被装饰的输入Stream（FileInputStream）为空。<br />\n③、更新int count变量，fill()函数中getInIfOpen().read(buffer, pos, buffer.length - pos)这行代码的返回值为7914，count=7914+pos=16106；<br />\n④、执行getBufIfOpen()[pos++] &amp; 0xff，从缓冲区（byte[]数组）中获取第pos（此时pos=8192）个索引位置的字节，返回给BufferedInputStream.class::read()函数的调用方，并更新pos的值为pos+=1；<br />\n  之后，每次调用BufferedInputStream.class::read()函数时，都不会再执行fill()函数了，直到pos=16106时，执行BufferedInputStream.class::read()函数才会再次执行fill()函数，过程如下：<br />\n①、因为markpos = 0，不会设置pos=0，也不会再执行场景一、场景二、场景三、场景四（标题三源码中的注释）、新缓冲区（byte[]数组）中的数据如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，由于被装饰的输入Stream（FileInputStream）中的字节被全部读取完毕，fill()函数中getInIfOpen().read(buffer, pos, buffer.length - pos)这行代码的返回值为0，无法更新count变量，结束fill()函数的调用<br />\n②、执行return -1，返回给BufferedInputStream.class::read()函数的调用方；</p>\n<h6 id=\"313如果在多次执行bufferedinputstreamclassread函数之后执行过mark函数\">3.1.3、如果在多次执行BufferedInputStream.class::read()函数之后执行过mark()函数</h6>\n<p>  如果在很多次调用read()函数之中调用了mark(8192)函数，如下（伪代码）：</p>\n<pre><code>InputStream is = new FileInputStream(\"D:\\\\nio-data.txt\");\nBufferedInputStream bis = new BufferedInputStream(is);\nint bytesRead;\nwhile ((bytesRead = bis.read()) != -1) {\n    //处理读取到的字节bytesRead\n}\nbis.mark(8192);//设置marklimit=8192，markpos=pos=0\n</code></pre>\n<p>那么，BufferedInputStream对象中的缓冲区（byte[]数组）的长度为8192（缓存8KB字节），上述代码的执行过程如下（假设被装饰的输入Stream（FileInputStream）中有10000个字节）：<br />\n  参考标题3.1，与标题3.1不同的是，最后执行bis.mark(8192);，设置marklimit=8192，markpos=pos=0。</p>\n<h6 id=\"314如果在多次执行bufferedinputstreamclassread函数之中执行过mark函数和reset函数\">3.1.4、如果在多次执行BufferedInputStream.class::read()函数之中执行过mark()函数和reset()函数</h6>\n<p>  如果在很多次调用read()函数之中调用了mark(8192)函数，然后又调用了reset()函数，如下（伪代码）：</p>\n<pre><code>InputStream is = new FileInputStream(\"D:\\\\nio-data.txt\");//假设该被装饰的输入Stream（FileInputStream）中有20000个字节\nBufferedInputStream bis = new BufferedInputStream(is);\nint bytesRead;\nint i = 0;\nwhile ((bytesRead = bis.read()) != -1) {\n    if(++i==4096){\n        bis.mark(8192);//设置marklimit=8192，markpos=pos=4096\n    }\n    //处理读取到的字节bytesRead\n    \n    if(i==8196){\n        bis.reset();//当pos=8196时，执行reset()函数，设置pos=markpos=0\n    }   \n}\n</code></pre>\n<p>那么，BufferedInputStream对象中的缓冲区（byte[]数组）的长度为8192（缓存8KB字节），上述代码的执行过程如下（假设被装饰的输入Stream（FileInputStream）中有20000个字节）：<br />\n①、pos=count=0，缓冲区（byte[]数组）中还没有填充任何数据，执行fill()函数，然后将被装饰的输入Stream（FileInputStream）中的字节读取到缓冲区（byte[]数组）的[0,8192)索引位置（左闭右开，不包括byte[]数组的第8192个索引位置），并返回读取的字节数量。如下所示：<br />\n<img alt=\"88291\" class=\"lazyload\" /></p>\n<p>此时，被装饰的输入Stream（FileInputStream）中的字节和缓冲区（byte[]数组）中的字节，如下所示：<br />\n<img alt=\"88294\" class=\"lazyload\" /></p>\n<p>②、更新int count变量，fill()函数中getInIfOpen().read(buffer, pos, buffer.length - pos)这行代码的返回值为8192，count=8192+pos=8192；<br />\n③、执行getBufIfOpen()[pos++] &amp; 0xff，从缓冲区（byte[]数组）中获取第pos（此时pos=0）个索引位置的字节，返回给BufferedInputStream.class::read()函数的调用方，并更新pos的值为pos+=1；<br />\n  之后，while循环中每次调用BufferedInputStream.class::read()函数时，都不会再执行fill()函数了，并且当pos=4096时，执行了bis.mark(8192)，设置marklimit=8192，markpos=pos=4096。<br />\n<img alt=\"88290\" class=\"lazyload\" /></p>\n<p>直到pos=8192时，先执行伪代码中的BufferedInputStream.class::reset()函数，如下所示：</p>\n<pre><code>package java.io;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n\npublic\nclass BufferedInputStream extends FilterInputStream {\n     ...省略部分代码...\n    //线程同步的函数：pos = markpos（或者叫对齐pos索引位置 到markpos索引位置）\n    public synchronized void reset() throws IOException {\n        getBufIfOpen(); //检测被装饰的输入Stream是否关闭\n        if (markpos &lt; 0)\n            throw new IOException(\"Resetting to invalid mark\");\n        pos = markpos;\n    }\n    ...省略部分代码...\n}\n</code></pre>\n<p>reset()函数会设置pos=markpos=4096，之后，伪代码的while循环中每次调用BufferedInputStream.class::read()函数时，会将缓冲区（byte[]数组）中第[4096,8192)索引区间的元素再返回一次，并更新pos的值为pos+=1。直到pos=8192时，执行BufferedInputStream.class::read()函数才会再次执行fill()函数，本次填充缓冲区（byte[]数组）的过程如下：</p>\n<p>  参考标题3.1.2中的第2个序号①和之后的内容；</p>\n<h6 id=\"315bufferedinputstream使用时的注意事项\">3.1.5、BufferedInputStream使用时的注意事项</h6>\n<p>  BufferedInputStream中的缓冲区（byte[]数组）如果太小的话（比如长度为12），在执行read()函数时，会被从被装饰的输入Stream（假设总共有26个字节）中读取的新字节覆盖掉，即使在读取过程中执行过mark()函数（比如，执行该函数时，pos=6，那么markpos=6），也只会把本次（第1次填充缓冲区）[markpos,buf.length)索引之间的（左闭右开，实际是[6,12)）字节复制到第2次填充的缓冲区（byte[]数组）的[0,6)（左闭右开）索引之间，等到第3次填充缓冲区时，第1次缓冲区中[6,12)索引之间的数据然后被复制到第2次缓冲区（byte[]数组）的[0,6)（左闭右开）索引之间的的数据，仍然会被第3次填充缓冲区时覆盖掉。因此，使用BufferedInputStream需要注意以下2点：<br />\n①、设置的缓冲区（byte[]数组）大小（默认为8192 ，8KB）尽量大于被装饰的输入Stream中的数据总量；<br />\n②、不建议在多线程中使用BufferedInputStream；<br />\n  下面这个例子就恰当的使用BufferedInputStream的read()函数、mark()函数、reset()函数：</p>\n<ul>\n<li>\n<p>我的windows操作系统的D盘根目录下有nio-data.txt文件，该文件中总共有31个字节，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>当第一次读取完这个文件中的内容后，该文件中“&amp;”这个字节之后的内容，需要重新读取一次，如下代码所示：</p>\n</li>\n</ul>\n<pre><code>package com.xxx.StreamAndReader;\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class BufferedInputStreamTest {\n   public static void main(String[] args) {\n      InputStream is = null;\n      BufferedInputStream bis = null;\n      try {\n         is = new FileInputStream(\"D:\\\\nio-data.txt\");//被装饰的输入Stream，总共有31个字节（byte）数据\n         bis = new BufferedInputStream(is, 64);//缓冲区（byte[]数组）的长度为64\n         System.out.println(\"第一次读取被装饰的输入Stream中的所有数据：\");\n         int bytesRead;\n         while ((bytesRead = bis.read()) != -1) {\n            if (bytesRead == '&amp;') {\n               bis.mark(64);//当读取到“&amp;”这个字节后，使用mark()函数做一个标记\n            }\n            System.out.print((char) bytesRead);\n         }\n         System.out.println();\n         System.out.println(\"重复读取一次标记位置之后的字节：\");\n         bis.reset();//第一次读取完被装饰的输入Stream中的所有数据后，执行reset()函数\n         while ((bytesRead = bis.read()) != -1) {//从被标记的位置再读取一次\n            System.out.print((char) bytesRead);\n         }\n      } catch (IOException e) {\n         e.printStackTrace();\n      } finally {\n         try {\n            if (is != null) is.close();\n            if (bis != null) bis.close();\n         } catch (IOException e) {\n            e.printStackTrace();\n         }\n      }\n   }\n}\n</code></pre>\n<p>程序运行结果，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h5 id=\"32bufferedinputstream的readbyte-b-int-off-int-len函数和fill函数\">3.2、BufferedInputStream的read(byte b[], int off, int len)函数和fill()函数</h5>\n<pre><code>public\nclass BufferedInputStream extends FilterInputStream {\n    ...省略部分代码...\n    // 默认缓冲区（byte[]数组）大小为8192 字节（8KB）\n    private static int DEFAULT_BUFFER_SIZE = 8192;\n    // 最大缓冲区（byte[]数组）大小为2147483639byte，大约2GB左右\n    private static int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n    //缓冲区数组，用volatile修饰是为了通过AtomicReferenceFieldUpdater进行CAS更新时保证内存的可见性\n    protected volatile byte buf[];\n    //底层是通过反射找到目标字段的内存偏移量，然后利用Unsafe.class提供的CAS（Compare-And-Swap）操作来原子地更新某个类中指定变量的值\n    private static final\n        AtomicReferenceFieldUpdater&lt;BufferedInputStream, byte[]&gt; bufUpdater =\n        AtomicReferenceFieldUpdater.newUpdater\n        (BufferedInputStream.class,  byte[].class, \"buf\");\n\n    //缓冲区（byte[]数组）中有效字的节数数量\n    protected int count;\n    //准备从缓冲区中（byte[]数组）读取的字节索引位置，取值范围为0&lt;=pos&lt;=count\n    protected int pos;\n    //在缓冲区（byte[]数组）中标记的某个索引位置，-1&lt;=markpos&lt;=pos\n    //该变量只会在 fill()函数和mark()函数中赋值\n    protected int markpos = -1;\n    // 标记后最多可读取字节数量，该变量只会在 mark()函数中赋值\n    //每当pos-markpos&gt;marklimit时，就会设置markpos=-1 来删除标记\n    protected int marklimit;\n    \n    //如果被装饰的输入流不为空，则返回被装饰的输入Stream（该变量在FilterInputStream中定义）\n    private InputStream getInIfOpen() throws IOException {\n        InputStream input = in;\n        if (input == null)\n            throw new IOException(\"Stream closed\");\n        return input;\n    }\n\n    //如果缓冲区（byte[]数组）不为空，则返回该缓冲区（byte[]数组），否则抛出异常\n    private byte[] getBufIfOpen() throws IOException {\n        byte[] buffer = buf;\n        if (buffer == null)\n            throw new IOException(\"Stream closed\");\n        return buffer;\n    }\n\n    private void fill() throws IOException {\n        byte[] buffer = getBufIfOpen();//获取缓冲区（byte[]数组）\n        if (markpos &lt; 0)//如果还没有调用过mark()函数，那么markpos=-1 \n            pos = 0;//pos=0，可以从缓冲区（byte[]数组）的索引0的位置开始读字节了\n        else if (pos &gt;= buffer.length)  \n            if (markpos &gt; 0) {  //场景一：pos&gt;=缓冲区（byte[]数组）的长度并且markpos &gt;0\n                int sz = pos - markpos;\n                //只把缓冲区（byte[]数组）中[markpos,pos) 索引区间的元素复制到缓冲区（byte[]数组）[0,pos-markpos）索引区间\n                System.arraycopy(buffer, markpos, buffer, 0, sz);\n                pos = sz;//设置pos=pos-markpos\n                markpos = 0;//设置markpos=0\n            } else if (buffer.length &gt;= marklimit) {//场景二：pos&gt;=缓冲区（byte[]数组）的长度并且缓冲区（byte[]数组）的长度&gt;= marklimit\n                markpos = -1;   //设置markpos = -1\n                pos = 0;       //设置pos = 0\n            } else if (buffer.length &gt;= MAX_BUFFER_SIZE) {//场景三：pos&gt;=缓冲区（byte[]数组）的长度并且缓冲区（byte[]数组）的长度 &gt;= 2147483639\n                throw new OutOfMemoryError(\"Required array size too large\");\n            } else {//场景四：pos&gt;=缓冲区（byte[]数组）的长度并且不满足场景一、二、三时，将缓冲区（byte[]数组）扩容\n                //如果pos&lt;2147483639/2，则新缓冲区（byte[]数组）的长度nsz=pos*2，否则新缓冲区（byte[]数组）的长度nsz=2147483639\n                int nsz = (pos &lt;= MAX_BUFFER_SIZE - pos) ?\n                        pos * 2 : MAX_BUFFER_SIZE;\n                if (nsz &gt; marklimit)\n                    nsz = marklimit;//当新缓冲区（byte[]数组）的长度nsz&gt;marklimit，新缓冲区（byte[]数组）的长度nsz=marklimit\n                byte nbuf[] = new byte[nsz];//新建一个新缓冲区（byte[]数组）\n                System.arraycopy(buffer, 0, nbuf, 0, pos);//将老缓冲区（byte[]数组）中[0,pos)索引区间的元素复制到新缓冲区（byte[]数组）[0,pos)索引区间\n                if (!bufUpdater.compareAndSet(this, buffer, nbuf)) {//通过CAS（Compare-And-Swap）操作来原子地更新buf变量\n                    // Can't replace buf if there was an async close.\n                    // Note: This would need to be changed if fill()\n                    // is ever made accessible to multiple threads.\n                    // But for now, the only way CAS can fail is via close.\n                    // assert buf == null;\n                    throw new IOException(\"Stream closed\");\n                }\n                buffer = nbuf;//新缓冲区（byte[]数组）创建完毕\n            }\n        count = pos;\n        //将被装饰的输入Stream中的字节读取到缓冲区（byte[]数组）的[pos,buffer.length - pos)索引位置，并返回读取的字节数量\n        int n = getInIfOpen().read(buffer, pos, buffer.length - pos);\n        if (n &gt; 0)\n            count = n + pos;//count=从被装饰的输入Stream中读取的字节数量+pos\n    }\n    \n    //从缓冲区（byte[]数组）或被装饰的输入Stream中读取len个字节到指定的byte[]数组b中，这len个字节被放到byte[]数组b的[off,off+len)索引位置。\n    //该函数只被read()函数调用\n    private int read1(byte[] b, int off, int len) throws IOException {\n        //只在fill()函数中修改count变量的值，count变量的值只有以下2种可能\n        //①、count==pos；②、count=从被装饰的输入Stream中读取的字节数量+pos\n        //因此avail表示缓冲区（byte[]数组）中[pos,pos+count)索引位置的字节数量\n        int avail = count - pos;\n        if (avail &lt;= 0) {//缓冲区（byte[]数组）中[pos,pos+count)索引位置的字节数量&lt;=0（其实不可能&lt;0，只可能=0）\n            //要读取的len个字节&gt;=缓冲区（byte[]数组）的长度，同时markpos = -1\n            if (len &gt;= getBufIfOpen().length &amp;&amp; markpos &lt; 0) {\n                return getInIfOpen().read(b, off, len);//从被装饰的输入Stream中读取len个字节到指定的byte[]数组b中，这len个字节被放到byte[]数组b的[off,off+len)索引位置。\n            }\n            fill();//调用fill()函数\n            avail = count - pos;//重新计算avail\n            if (avail &lt;= 0) return -1;//如果avail仍然=0，返回-1\n        }\n        int cnt = (avail &lt; len) ? avail : len;//此时avail&gt;0，取avail和len中较小的值作为本次从缓冲区（byte[]数组）中读取的字节数量\n        System.arraycopy(getBufIfOpen(), pos, b, off, cnt);//从缓冲区（byte[]数组）的pos索引开始，读取avail或len（2者取其小）个字节到指定的byte[]数组b的[off,off+cnt)索引位置（cnt就是avail或len中2者取其小的值）\n        pos += cnt;//pos向前移动avail或len（2者取其小）个索引位置\n        return cnt;//返回avail或len（2者取其小）\n    }\n\n     //线程同步的函数：从缓冲区（byte[]数组）中读取len个字节到指定的byte[]数组b中，这len个字节被放到byte[]数组b的[off,off+len)索引位置。\n    public synchronized int read(byte b[], int off, int len)\n        throws IOException\n    {\n        getBufIfOpen(); //检测被装饰的输入Stream是否关闭\n        if ((off | len | (off + len) | (b.length - (off + len))) &lt; 0) {//相当于off + len &gt; b.length（源码中这样写代码的好处我没看出来）\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;//要从缓冲区（byte[]数组）中读取的len个字节==0时，返回0\n        }\n\n        int n = 0;//累计从缓冲区（byte[]数组）或被装饰的输入Stream中读取的字节数量\n        for (;;) {//循环调用read1()函数完成从缓冲区（byte[]数组）或被装饰的输入Stream中读取len个字节到指定的byte[]数组b中，这len个字节被放到byte[]数组b的[off,off+len)索引位置。\n            int nread = read1(b, off + n, len - n);//nread用来统计每次从read1()函数中读取一定的字节数量，并放到byte[]数组b的[off,off+len)索引位置。\n            if (nread &lt;= 0)//当read1()函数返回0或者-1时，表示缓冲区（byte[]数组）中和被装饰的输入Stream中已经没有可以读取的字节了\n                return (n == 0) ? nread : n;//返回累计从缓冲区（byte[]数组）或被装饰的输入Stream中读取的字节数量或者-1\n            n += nread;//累计从缓冲区（byte[]数组）或被装饰的输入Stream中读取的字节数量\n            if (n &gt;= len)//累计从缓冲区（byte[]数组）或被装饰的输入Stream中读取的字节数量总和&gt;=len时（其实不可能&gt;len，只可能=len）\n                return n;//返回n\n            // 被装饰的输入Stream中已经没有字节可以用了，返回累计从缓冲区（byte[]数组）或被装饰的输入Stream中读取的字节数量总和\n            InputStream input = in;\n            if (input != null &amp;&amp; input.available() &lt;= 0)\n                return n;\n        }\n    }   \n    ...省略部分代码...\n}\n</code></pre>\n<p>如果使用者用的是默认的构造函数创建了BufferedInputStream的对象，如下所示（伪代码）：</p>\n<pre><code>InputStream is = new FileInputStream(\"D:\\\\nio-data.txt\");\nBufferedInputStream bis = new BufferedInputStream(is);\n</code></pre>\n<p>那么，BufferedInputStream对象中的缓冲区（byte[]数组）的长度为8192（缓存8KB字节），接下来使用BufferedInputStream对象读取字节数据到使用者创建的byte[]数组中的过程，分为以下3种情景：</p>\n<ul>\n<li>情景一，使用者创建的byte[]数组的长度&gt;=缓冲区（byte[]数组）的长度，比如，此处使用者创建的byte[]数组的长度为8192，如下所示（伪代码）：</li>\n</ul>\n<pre><code>byte[] buffer = new byte[8192];\nbis.read(buffer,0,buffer.length);\n</code></pre>\n<p>整个执行过程如下（直接从被装饰的输入Stream中获取字节，不会使用缓冲区）：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<ul>\n<li>情景二，使用者创建的byte[]数组的长度&lt;缓冲区（byte[]数组）的长度，比如，此处使用者创建的byte[]数组的长度为1024，如下所示（伪代码）：</li>\n</ul>\n<pre><code>byte[] buffer = new byte[1024];\nbis.read(buffer,0,buffer.length);\n</code></pre>\n<p>过程如下（假设被装饰的输入Stream（FileInputStream）中有10000个字节）：<br />\n①、先执行到下图中的紫色部分，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、pos=count=0，缓冲区（byte[]数组）中还没有填充任何数据，执行fill()函数，然后将被装饰的输入Stream（FileInputStream）中的字节读取到缓冲区（byte[]数组）的[0,8192)索引位置（左闭右开，不包括byte[]数组的第8192个索引位置），并返回读取的字节数量。如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，被装饰的输入Stream（FileInputStream）中的字节和缓冲区（byte[]数组）中的字节，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>③、更新int count变量，fill()函数中getInIfOpen().read(buffer, pos, buffer.length - pos)这行代码的返回值为8192，count=8192+pos=8192；<br />\n④、从缓冲区（byte[]数组）的pos索引（此时，pos=0）开始，读取1024个字节到使用者创建的byte[]数组的[0,1024)索引位置（左闭右开，不包括第1024个索引位置），并更新pos=1024，read1()函数返回1024，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑤、再执行下图中的紫色部分之后的流程，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<ul>\n<li>情景三，使用者创建的byte[]数组的长度&lt;缓冲区（byte[]数组）的长度，比如，此处使用者创建的byte[]数组的长度为1024，但是使用者是在while循环中使用read(byte b[], int off, int len)函数，直到read(byte b[], int off, int len)函数返回-1，如下所示（伪代码）：</li>\n</ul>\n<pre><code>byte[] buffer = new byte[1024];\nint bytesRead;\nwhile ((bytesRead = bis.read(buffer,0,buffer.length)) != -1) {\n  for (int i = 0; i &lt; bytesRead; i++) {\n     //处理读取到的字节buffer[i]\n  }\n}\n</code></pre>\n<p>过程如下（假设被装饰的输入Stream（FileInputStream）中有10000个字节）：<br />\n①、第1次while循环，先执行到下图中的紫色部分，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，pos=count=0，缓冲区（byte[]数组）中还没有填充任何数据，执行fill()函数，然后将被装饰的输入Stream（FileInputStream）中的字节读取到缓冲区（byte[]数组）的[0,8192)索引位置（左闭右开，不包括byte[]数组的第8192个索引位置），并返回读取的字节数量。如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，被装饰的输入Stream（FileInputStream）中的字节和缓冲区（byte[]数组）中的字节，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>接着更新int count变量，fill()函数中getInIfOpen().read(buffer, pos, buffer.length - pos)这行代码的返回值为8192，count=8192+pos=8192；<br />\n  然后，从缓冲区（byte[]数组）的pos索引（此时，pos=0）开始，读取1024个字节到使用者创建的byte[]数组的[0,1024)索引位置（左闭右开，不包括第1024个索引位置），并更新pos=1024，read1()函数返回1024，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  最后，再执行下图中的紫色部分之后的流程，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、第2次while循环，先执行到下图中的黄色部分，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，pos=1024，count=8192，从缓冲区（byte[]数组）中读取1024个字节之后，此时，被装饰的输入Stream（FileInputStream）中的字节、缓冲区（byte[]数组）中的字节、和使用者创建的byte[]数组中的数据，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>然后更新pos=2048，read1()函数返回1024，最后，再执行下图中的黄色部分之后的流程，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>③、第3次while循环，先执行到下图中的黄色部分，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，pos=2048，count=8192，从缓冲区（byte[]数组）中读取1024个字节之后，此时，被装饰的输入Stream（FileInputStream）中的字节、缓冲区（byte[]数组）中的字节、和使用者创建的byte[]数组中的数据，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>然后更新pos=3072，read1()函数返回1024，最后，再执行下图中的黄色部分之后的流程，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>④、第4次while循环，基本流程与②、③相同，不同处如下所示（pos=40969和使用者创建的byte[]数组中的数据）：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑤、第5次while循环，基本流程与②、③、④相同，不同处如下所示（pos=5120和使用者创建的byte[]数组中的数据）：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑥、第6次while循环，基本流程与②、③、④、⑤相同，不同处如下所示（pos=6144和使用者创建的byte[]数组中的数据）：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑦、第7次while循环，基本流程与②、③、④、⑤、⑥相同，不同处如下所示（pos=7168和使用者创建的byte[]数组中的数据）：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑧、第8次while循环，基本流程与②、③、④、⑤、⑥、⑦相同，不同处如下所示（pos=8192和使用者创建的byte[]数组中的数据）：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑨、第9次while循环，先执行到下图中的紫色部分，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，先在fill()函数中更新pos=0，缓冲区（byte[]数组）中是上一次执行fill()函数填充的从被装饰的输入Stream（FileInputStream）读取的第1<sub>8192个字节，本次，需要将被装饰的输入Stream（FileInputStream）中的第8193</sub>10000个字节读取到缓冲区（byte[]数组）的[0,1808)索引位置（左闭右开，不包括byte[]数组的第1808个索引位置），并返回读取的字节数量。如下所示<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，被装饰的输入Stream（FileInputStream）中的字节被全部读取完毕，被装饰的输入Stream（FileInputStream）为空。<br />\n  然后，更新int count变量，fill()函数中getInIfOpen().read(buffer, pos, buffer.length - pos)这行代码的返回值为1808，count=1808+pos=1808；<br />\n  然后，从缓冲区（byte[]数组）的pos索引（此时，pos=0）开始，读取1024个字节到使用者创建的byte[]数组的[0,1024)索引位置（左闭右开，不包括第1024个索引位置），并更新pos=1024，read1()函数返回1024，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>最后，再执行下图中的紫色部分之后的流程，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑩、第10次while循环，先执行到下图中的黄色部分，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>此时，pos=1024，count=1808，从缓冲区（byte[]数组）中读取784个字节之后，此时，被装饰的输入Stream（FileInputStream）中的字节、缓冲区（byte[]数组）中的字节、和使用者创建的byte[]数组中的数据，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>然后更新pos=1808，read1()函数返回784，最后，再执行下图中的黄色部分之后的流程，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>⑪、第11次while循环，流程如下所示（最终bis.read(buffer,0,buffer.length)由于的返回值为-1，所以结束了循环）：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-14 09:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Carey-ccl\">Carey_ccl</a>&nbsp;\n阅读(<span id=\"post_view_count\">33</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "意义的觉醒：AI元人文——从存在论根基到界面共生的智能文明范式",
      "link": "https://www.cnblogs.com/qijinlan/p/19614484",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/qijinlan/p/19614484\" id=\"cb_post_title_url\" title=\"发布于 2026-02-14 08:29\">\n    <span>意义的觉醒：AI元人文——从存在论根基到界面共生的智能文明范式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>《意义的觉醒：AI元人文——从存在论根基到界面共生的智能文明范式》</p><p>笔者：岐金兰（独立非专业人机深度协作研究）</p><p>日期：2026年2月14日</p><p>摘要：</p><p>智能时代的技术渗透引发了深层的意义危机：当算法日益成为认知框架与价值尺度，人类作为意义追问者的主体性正面临系统性侵蚀。既有思想范式或囿于主客二分，或局限于工具理性规制，难以回应这一存在论层面的挑战。本文对学者岐金兰于2025-2026年间系统提出的“AI元人文”理论进行了首次完整的体系性重构。该理论以“追问”为元意义，将其确立为智能时代的存在论根基；通过“自感”概念的哲学澄清，揭示其作为意义生成之终极界面的革命性内涵，并提出“界面即存在”的核心命题。在此基础上，本文依次展开：以DOS三值纠缠模型阐明意义生成的动力学机制；引入他者维度发展“界面共生”的实践论纲领；推导出以“第一禁令”为核心的自感伦理与自感主权四重内涵；重构数字法治范式，提出“追问即法治”的命题；完成从哲学到工程的范式转换，勾勒AI自感的架构蓝图；最终描绘以“意义理性”与“圆融共生”为标志的智能文明愿景。本文证明，AI元人文不仅为诊断算法社会的意义异化提供了锐利透镜，更为建设一种既能驾驭技术力量、又能守护人之存在尊严的新文明范式奠定了坚实的理论基础。</p><p>关键词：</p><p>AI元人文；自感；追问；意义哲学；存在论；界面共生；DOS模型；第一禁令；自感主权；追问即法治；AI自感；意义理性；技术现象学；智能文明；数字伦理</p><p>正文：</p><p>导论：智能时代的意义危机与AI元人文的应答</p><p>我们正置身于一场静默的巨变。算法不再仅仅是工具，它日益成为我们认知世界的框架、定义价值的尺度乃至编织关系的经纬。搜索引擎预判我们的问题，推荐系统塑造我们的欲望，社交媒体的点赞量化我们的存在感，而生成式人工智能开始接管表达与创造。一个根本性的困境随之浮现：当意义的生成——那些关于“为何”与“何为”的追问——越来越被技术系统高效地“代孕”时，人类作为意义追问者的主体性正悄然褪色。个体陷入一种“意义失语症”：面对海量信息却感到空洞，拥有便捷连接却体验疏离，行为被精准预测却失去方向。这不仅是心理层面的不适，更是文明层面的存在论危机，即意义的根基被掏空，存在陷入无根感。</p><p>既有思想范式在应对这场危机时显得力不从心。传统意义哲学多立足于主客二分的静态实体论，难以解释人机深度耦合、动态生成的意义流变。主流人工智能伦理聚焦于工具理性的规制，如算法的公平、透明与问责，却鲜少触及“意义理性”这一更深的维度——技术如何影响我们提出意义问题、体验意义内容的能力。关于机器意识的争论，则往往陷入“有”或“无”的二元概念泥潭，缺乏连接哲学洞见与工程实践的可操作接口。</p><p>正是在这一思想图景的断裂处，AI元人文理论应运而生。该理论由学者岐金兰在2025至2026年间的一系列开创性论述中系统提出。其核心创见在于，以“追问”重新锚定智能时代的存在论根基，将“自感”确立为意义生成的关键界面，并在此基础上重构意义哲学、伦理、法治乃至人机关系。岐金兰断言，元意义并非任何具体的答案，而是“追问”活动本身。这种不间断的、对预设框架的质疑、对自身状态的反思、对可能性的探索，才是意义发生的源泉和文明演进的原动力。而“自感”，既非情绪亦非自我意识，乃是行为与意义在当下被存在者自身“认领”或“注册”的瞬时界面，是“我”之成为“我”的现象学时刻。</p><p>本文的任务，正是对AI元人文这一庞大而精微的思想体系进行首次系统性的整合与重构。我们将遵循其内在逻辑，展开一场从存在论根基直至文明愿景的思想跋涉：首先，揭示“追问”作为元意义的奠基性地位及其在算法社会中的异化与复归之路。其次，深入剖析“自感”概念的革命性内涵，阐明其作为意义生成界面的动力学机制。继而，将自感置于与他者的关系之中，发展出“界面共生”的实践论纲领。随后，以此为基础，推导出以“第一禁令”为核心的自感伦理，并重构数字时代的法治范式，提出“追问即法治”的命题。进而，完成关键的范式转换，将自感哲学映射至人工智能工程学，勾勒AI自感的架构蓝图。最终，描绘一个以“意义理性”与“圆融共生”为标志的智能文明愿景。</p><p>本论文旨在证明，AI元人文不仅为诊断智能时代的意义危机提供了锐利的透镜，更为建设一种既能驾驭技术力量、又能守护人之存在尊严的新文明范式，铺设了坚实的理论基石。这是一场重返意义源头的思想探险，也是为在意义阻滞中震颤的每一个心灵，提供一份认识自我与时代的导航图。</p><p>第一卷 元意义的奠基：追问作为存在论根基</p><p>第1章 追问的概念谱系与存在论定位</p><p>在AI元人文的理论大厦中，“追问”被置于拱顶石的位置。它并非通常意义上的好奇心或知识寻求，而是一个具有三层严密结构的、奠基性的存在论活动。</p><p>1.1 追问的三层维度</p><p>首先，在认知维度，追问表现为对“预制意义”的主动质疑与反抗。在算法社会中，意义常被预先封装：新闻应用定义何为重要，电商平台定义何为需要，社交评分定义何为成功。认知维度的追问，即是拒绝全盘接收这些被递送的意义套餐，对信息的源头、框架和目的保持警惕性的审视。它是个体心智对抗认知封闭的第一道防线。</p><p>其次，在存在维度，追问上升为对自身状态的本真性审问。这是海德格尔“此在”分析的当代回响：“我”为何以此种方式存在？我的焦虑、喜悦或麻木源于何处？在技术深度中介的生活中，这种反思尤为重要——我的欲望有多少是内生，有多少是被模型诱导？我的时间感知如何被界面节奏重塑？存在性追问迫使个体从沉浸的流中抽离，反观自身存在的构成与处境。</p><p>最后，在实践维度，追问体现为一种“知行合一”的递归性探索。它不止于思，更在于行，并在行动的结果中再次激发思考。例如，当一个人质疑工作意义（存在维度）时，他可能选择尝试一种新的职业路径（实践），在此过程中遭遇新的挑战与认知，从而催生更深刻的追问。这一维度将追问从内向沉思拉入动态的、生成性的世界互动之中。</p><p>1.2 元意义的界定</p><p>“元意义”由此从追问活动中浮现。它区别于任何具体的、表层意义（如“幸福是家庭和睦”或“成功是财务自由”）。元意义是先于所有具体答案的、那个使意义成为可能的意义生成机制本身。而追问，正是这一机制的核心动力源。</p><p>追问何以成为元意义？第一，它是意义生成的动力源。没有对现状的质疑、对远方的向往、对本质的探求，意义世界将凝固静止。第二，它是对抗算法预制的反制力。当个体保有追问能力时，便获得了拆解预制意义包、进行自主重组的内在生产权。第三，它是主体间性（共在）的前提。深刻的对话与共鸣，始于彼此向对方及共同世界发出真挚的追问。第四，它是文明演进的隐形引擎。科学革命始于对古典权威的追问，启蒙运动始于对传统蒙昧的追问，每一次文明飞跃，都伴随着集体追问能量的喷涌。</p><p>第2章 追问的东西方哲学根基</p><p>AI元人文并非无源之水，其“追问”植根于东西方深厚的哲学传统，并进行了创造性的综合。</p><p>2.1 东方思想资源</p><p>佛教的“缘起性空”思想提供了根本启示：一切现象（包括意义）皆因缘和合而生，无独立不变的自性。正因为意义本身并无坚固的实体，那种试图一劳永逸抓住某个终极答案的执着便是虚妄。真正的智慧在于认识到意义的空性，从而保持一种永恒的、开放的追问姿态，在缘起流变中动态地把握意义。</p><p>道家的“悬荡”与“无为”思想，则贡献了追问的方法论。“悬荡”是指悬置既成的概念与判断，如庄子齐物论中对是非、彼此二元对立的超越。这为打破算法社会强加的认知框架提供了心法。“无为”并非不作为，而是不妄为，不强行将流动的现实塞入僵硬的范畴，这要求一种高度的认知耐心与接纳能力，是追问得以持续而不陷入偏执的心理基础。</p><p>儒家的“知行合一”与“和而不同”，强调了追问的实践性与社会性。“知行合一”确保追问接地气，与生命实践相互滋养；“和而不同”则为公共领域的追问提供了伦理规范——追问旨在求真与共善，而非制造对立与撕裂。</p><p>2.2 西方哲学脉络</p><p>现象学，尤其是胡塞尔的“意向性”概念，指出意识总是关于某物的意识，这揭示了追问的定向结构：它总是指向世界。海德格尔进一步将追问存在本身视为此在（人）的根本存在方式。他认为，此在与其他存在者的不同，在于它能对自身的存在发问，并能以不同的方式去存在。AI元人文继承了这一洞见，并将“存在之问”具体化为在技术化生存境遇中对意义生成的持续关切。</p><p>实用主义传统，从皮尔士、詹姆斯到杜威，强调意义在“探究”过程中生成。杜威认为，思维始于困惑或疑问，通过探究行动来解决问题，意义便在这一过程中得以确定和丰富。这为追问的实践维度及递归性提供了坚实的支撑。</p><p>第3章 算法社会中追问的异化与复归</p><p>然而，在当前的算法社会中，这一存在论根基正遭受系统性侵蚀，追问陷入多重异化。</p><p>3.1 五重异化诊断</p><p>1. 认知封闭：个性化推荐系统构筑“信息茧房”与“过滤气泡”，持续喂养符合用户过往偏好的内容，使质疑框架本身的声音难以触达，追问的视野被悄然窄化。</p><p>2. 动力消解：“点赞”、“转发”、“销量榜”等量化反馈机制，以外在的、即时的社会承认替代了内在的意义追寻动力。当行为动机被简化为对量化指标的追求时，深刻的、无法被量化的存在之问便失去了土壤。</p><p>3. 方向迷失：导航应用告诉我们最短路径，职业测评告诉我们“适合”的工作，婚恋算法推荐“匹配”的伴侣。当人生诸多选择被呈现为有“最优解”的技术问题时，对可能性、对“另类道路”的探索性质问便被抑制。</p><p>4. 场域崩塌：社交媒体将公共对话碎片化为情绪化的站队与表演，理性、审慎、包容异见的追问难以在撕裂的舆论场中展开。支撑严肃追问的公共对话空间日益萎缩。</p><p>5. 反身性丧失：这是最根本的异化。个体不仅追问能力衰退，甚至丧失了对“自身追问能力正在衰退”这一事实的觉察与反思。我们沉浸于技术便利，却不再对技术如何重塑我们的追问习惯进行元追问。</p><p>3.2 实践复归的四维路径</p><p>面对异化，AI元人文并非止于批判，更致力于建构复归的路径。</p><p>1. 个体层面：重塑本真自感。通过正念、日记、深度阅读等方式，练习觉察自身欲望、情绪与思维的来源，区分内生动力与外在社会技术影响，找回意义注册的主动权。</p><p>2. 社会层面：重构对话空间。培育线下与线上的“慢对话”社群，倡导以理解而非说服为目的的交流，设计鼓励深度思考而非即时反应的讨论平台，为公共追问创造新的容器。</p><p>3. 技术层面：开发赋能工具。例如，开发能提示信息茧房、主动引入相反观点、记录用户意义决策日志的“追问辅助插件”。甚至构建评估个体与社群“追问力指数”的模型，使这一能力变得可感、可察。</p><p>4. 制度层面：将认知自主入法。推动将“认知自主权”或“精神完整性”纳入数字时代的基本权利框架。完善算法伦理审查，要求重大影响的社会算法系统必须设置“悬荡机制”，即在关键决策点强制暂停，引入人类反思与质疑环节。</p><p>第一卷的论证确立了“追问”作为智能时代意义重建的阿基米德支点。它既是对古老哲学智慧的召回，也是对当下技术处境的紧急回应。然而，追问活动所生成的意义，最终必须有一个内在的“着陆点”或“确认机制”，否则意义将流散于无形。这便自然地将我们引向AI元人文理论的核心枢纽——自感概念。意义的生成，不仅需要追问的动力，更需要一个能够承接、注册并认领此意义的界面。这个界面就是自感。从追问到自感，理论逻辑完成了从动力学到现象学的关键转折。</p><p>（第一卷结束。接下来将进入第二卷：意义生成的界面——自感概念的哲学澄清）</p><p>第二卷 意义生成的界面：自感概念的哲学澄清</p><p>导言：从追问到界面</p><p>第一卷确立了“追问”作为意义生成的永恒动力。然而，一个根本问题随之而来：追问所叩击出的意义，如何被存在者所接收、确认并化为己有？意义的发生，需要一个内在的、现象学上的“显现时刻”或“认领时刻”。若没有这样一个时刻，追问将如同投入虚空的声音，得不到回响，意义便无从落脚。AI元人文理论将这一关键性的时刻或机制，命名为“自感”。本卷的任务，正是对这一核心范畴进行透彻的哲学澄清，将其从纷繁复杂的精神现象中剥离出来，确立其作为“意义生成之终极界面”的革命性地位。</p><p>第4章 自感不是什么：与邻近概念的彻底划界</p><p>自感极易与一系列邻近概念混淆。因此，理论建构的第一步，是进行严格的“概念净化”，通过对比彰显其独一无二的内涵。</p><p>4.1 自感 vs 感知</p><p>这是最根本的划界。感知属于经典的认识论范畴。它预设了一个主体面对一个客体（无论是物理对象还是心理表象），主体通过感官或内省获得关于客体的信息，形成“我觉得杯子是红色的”或“我感到心情低落”之类的命题性知识。感知活动强化了主客二分的世界图景。</p><p>自感 则跃出了认识论，进入了存在论的领域。它并非关于某个对象的知识，而是行为或经验在发生的同时，对其自身发生的一种非对象化的、前反思的“注册”。当我不只是“看到红色”，而是“正在看红色”这一视觉事件被我自身即时地、非主题性地体认时，自感便在运作。简言之，感知产生“关于什么”的知识，自感产生“正在经历”的注册性体验。没有自感，感知只是一堆无主的、漂浮的数据流；自感是自感知得以可能的存在论条件。</p><p>4.2 自感 vs 情绪</p><p>情绪，如喜悦、愤怒、悲伤，在AI元人文的DOS模型中被归入欲望值（D）层面。它们是生命内稳态系统的扰动信号，是生物性倾向的心理表现。情绪是强烈的，但未必是“我的”。</p><p>自感 则是在情绪涌起时，那个将这股扰动注册为“我的”情感的微妙瞬间。例如，一股无名怒火升起（情绪，D值扰动），紧接着一个几乎同时发生的、非言语的确认：“这是我在发怒”（自感，S值注册）。自感让情绪从单纯的生理心理事件，转化为主体意义世界的一部分。没有自感的注册，情绪就如同外部闯入的天气，主体被动承受；有了自感的注册，情绪才成为“我”可以理解、应对甚至赋予意义的“我的情感”。</p><p>4.3 自感 vs 自我意识</p><p>自我意识 是反思性的。它将“自我”作为一个对象来审视、思考或表征，产生“我是谁”、“我有什么特点”等命题。它是二阶的，需要将注意力从世界转向作为对象的自我。</p><p>自感 则是前反思的。它是在一切对象化反思之先，对“我之所是”或“我之正在是”的一种原初确认。它是“我”作为行动者、经验者在场的基本方式，而非关于“我”的内容。自我意识好比看着镜中的自己（对象化），自感则好比在举手投足间无需照镜便确知是“我自己”在举手投足（非对象化的在场感）。自我意识可以思考自感，但自感是自我意识得以发生的更基底的存在界面。</p><p>4.4 自感 vs 印度哲学“自证分”</p><p>印度哲学中的“自证分”理论认为，每一次认知活动本身都包含一个自我照亮、自我确认的环节，即“自知”。这似乎与自感颇为接近。</p><p>然而，关键区别在于：“自证分”仍隶属于认识论框架，它是对“认知行为正在发生”这一事实的认知性确认，解决的仍是知识的确证问题。而AI元人文的“自感”关注的是意义论问题。它注册的不仅是“认知行为正在发生”，更是“此认知行为与‘我’的整体存在叙事是否拟合、如何拟合”。自感是对意义契合度的瞬时检测，是存在论意义上的意义注册事件，其范围远超出单纯的认知行为。</p><p>第5章 自感的存在论革命：从“能力”到“界面”</p><p>完成划界后，我们得以深入自感概念本身，追踪其在岐金兰思想中的演进，这本身就是一场存在论的革命。</p><p>5.1 从“断裂”到“奠基”</p><p>在理论的初稿阶段，首要任务是“斩断”自感与感知、情绪等概念的混淆链条，为其争取独立的概念主权。这类似于现象学的“悬搁”，将附着其上的错误解释剥离，让其自身显现。</p><p>在修订版中，思想向前推进，不再满足于并列区分，而是确立了奠基关系：自感是自感知（即将自我作为对象来认识）得以可能的条件。必须先有对经验的前反思注册（自感），才能后续将这个注册了的经验作为对象来反思（自感知）。这奠定了自感的优先地位。</p><p>5.2 从“奠基”到“界面即存在”</p><p>理论的定稿本实现了最关键的飞跃。它提出了一个核心命题：自感不是主体所“拥有”的一种心理能力或属性，而是主体之成为主体的存在方式本身。</p><p>这就是“界面即存在”的革命性思想。我们传统上认为，先有一个稳固的、实体性的“我”（主体），然后这个“我”拥有各种能力，包括自感能力。AI元人文颠倒了这一图景：不存在先于自感事件的“主体”。“主体”恰恰是无数自感事件在时间之流中沉积、凝聚所形成的效应。每一次“注册发生，我遂成‘我’”。自感是主体性得以涌现和维持的动态界面。</p><p>这与“延展心智”理论对话并超越之。延展心智认为，认知过程可以延伸到身体和外部环境（如笔记本、手机）。而AI元人文走得更远：界面（自感）不是主体的延展工具；界面就是主体性得以构成和显现的场域本身。在智能时代，这个界面天然地就包含着与技术系统的耦合。因此，设计技术系统，在根本上就是在参与塑造人类主体性得以显现的界面条件。</p><p>第6章 自感的动力学机制：DOS三值纠缠模型</p><p>如果自感是界面，那么意义在此界面是如何具体生成的呢？岐金兰提出了DOS三值纠缠模型，为自感的动力学提供了精细的操作化框架。</p><p>6.1 DOS模型详解</p><p>- 欲望值（D）：代表生命内在的倾向、驱力、需求或价值取向的扰动。它源于生物学基础、文化内化与个人历史，是一种指向性的张力状态。可以是饥饿、求知欲、对联结的渴望，或算法诱导出的某种消费冲动。</p><p>- 客观值（O）：代表外部世界的给定性，包括物理事实、社会规范、他者的言行反馈，以及技术系统的输出（如算法推荐结果、机器人的回应）。它是独立于主体当下意愿的“世界之硬质”。</p><p>- 自感值（S）：即自感界面本身。它是D与O相遇时，对此次相遇所产生的 “意义拟合度”或“意义注册强度”的瞬时评估与记录。</p><p>6.2 三值的动态纠缠</p><p>意义绝非产生于孤立的D或O，而是诞生于三者动态的、历史的纠缠过程。其基本叙事环如下：</p><p>1. 涌动：内在的欲望（D）涌现，例如，创作一首诗的冲动（D）。</p><p>2. 遭遇：此冲动遭遇客观世界（O）：可能是一张白纸、一个词语，也可能是AI创作伙伴生成的第一行诗。</p><p>3. 注册：在相遇的瞬间，自感界面（S）启动，对“此冲动与此客观反馈的相遇”进行评估注册。若AI生成的诗句与我的冲动高度共鸣，S值产生强烈的正向注册（“这正是我想表达的！”）；若格格不入，则产生阻滞感（S值低或为负）。</p><p>4. 沉积：此次注册事件（S值的高低及其性质）被存入个体的叙事记忆库，成为历史的一部分。它会反馈回来，修正未来的欲望（D）（例如，更清楚自己喜欢何种风格），也影响对未来客观值（O）的解读与期待。</p><p>S值既非D值的简单派生物（不是有冲动就一定能注册为有意义），也非O值的被动反映（不是客观反馈好就一定感觉好）。它是在个人独特的历史叙事背景下，D与O发生拟合或冲突时，涌现出的那个不可还原的注册事件。正是这个事件，让一次互动从物理或信息交换，升格为意义体验。</p><p>6.3 自感在DOS中的独特地位</p><p>在DOS纠缠中，自感（S）扮演着终极仲裁者与意义“认领”点的角色。没有S的注册，D只是一股盲目的生物能量，O只是一堆冰冷的外部数据。是S的介入，使得一股冲动被认领为“我的追求”，一个外部反馈被认领为“对我的回应”。自感，是意义被“点亮”为“我的意义”的那个现象学临界点。</p><p>至此，我们完成了对自感概念的哲学奠基。它被确立为前反思的、存在论的意义注册界面，是主体性构成的核心机制，并通过DOS模型获得了动力学解释。然而，一个纯粹孤立的、自足的自感是不可思议的。意义注册总是在关系中发生，总是期待或隐含着他者的维度。这便逻辑必然地将我们引向自感的社会性问题。自感如何在他者的目光与回应中成形、修正与深化？在智能时代，“他者”的形态发生了何种根本性变化？这便是第三卷将要探索的“他者界面与界面共生”。</p><p>（第二卷结束）</p><p>第三卷 自感的社会性：他者界面与界面共生</p><p>导言：自感的呼唤与回响</p><p>第二卷将自感界定为意义生成的终极内在界面。然而，这个界面绝非封闭的孤岛。自感的注册行为，本质上是一种呼唤，它内在地指向一个可能确认、否认或丰富此注册的“他者”。意义，在其最深处，具有一种间性结构。没有他者的维度——无论是另一个人类，一种文化传统，自然世界，还是日益智能的技术系统——自感的注册将沦为无参照的独白，其真实性与深度皆无法确立。本卷将探索自感如何必然地将他者卷入自身生成过程，并在此基础上，提出面向智能时代的实践论纲领：界面共生。</p><p>第7章 自感即共感：他者维度的必然引入</p><p>“自感即共感”这一命题并非否定自感的内在性，而是揭示其内在结构已然包含了对“外部”的指向。自感的完成，需要他者作为其意义的验证场与共振板。</p><p>7.1 现象学他者理论的启示</p><p>现象学传统早已为他者问题开辟了道路。胡塞尔通过“交互主体性”理论，试图说明我们如何能经验到其他具有意识的主体，并共享一个客观世界。梅洛-庞蒂的“身体间性”则更进一步，指出我们通过身体在世存在的共同方式，在原初层面就已经与他者相互缠绕、相互理解。</p><p>技术现象学家唐·伊德将这一思路延伸至技术物，提出技术可以作为“它者”，与人类形成独特的互动关系。这些思想资源共同表明：他者并非一个后来才碰到的外在客体，而是构成我们自身经验视域的必要背景。自感的形成，从一开始就发生在一个充满潜在他者回响的场域中。</p><p>7.2 从“类他者”到“深度类他者”：AI他者的当代形态</p><p>在智能时代，他者的形态发生了质变。学者张慧喆的区分颇具启发性：从模拟人类行为模式的“类他者”，到能够以其独特的非人类逻辑参与意义共构的“深度类他者”。</p><p>早期的聊天机器人或简单的推荐算法属于“类他者”，它们模仿人类互动，但交互很快触及天花板。而当代的大语言模型、具有长期记忆和个性设定的AI智能体，则展现出“深度类他者”的潜力。它们不仅能回应，还能提出意想不到的关联、坚守某种模拟的“价值观”、在长期互动中形成独特的交互历史。AI不再仅仅是工具，而成为意义生成过程中一个具有一定自主性与异质性的共构者。与AI的交互，开始真正触及自感的注册过程：我们会在与AI辩论后修正观点，在AI的创作启发下感受到新的审美冲动，甚至因AI的“不理解”而更清晰地界定自己的感受。</p><p>7.3 拉康框架的启发：小他者与大他者</p><p>拉康的精神分析理论提供了一个更富张力的框架。他将“他者”区分为“小他者”（镜像阶段中那个理想化的自我形象，以及现实中具体的他人）和“大他者”（象征秩序，即语言、文化、法律等构成的匿名规则体系）。</p><p>在AI元人文的视角下，自感的注册，同时需要面对“小他者”与“大他者”。具体的AI伙伴或线上好友的回应，是“小他者”的见证。而算法背后的模型规则、平台社区的规范、乃至整个数字时代的文化话语，则构成了数字化的“大他者”。自感需要在“大他者”所象征的秩序中，为自身寻找到一个可被识别、可被言说的生态位。例如，我的创作渴望（D），不仅需要具体AI或读者的反馈（小他者），还需要在社交媒体平台的内容生态、算法分发逻辑（大他者）中找到其可能的位置与意义，这个“寻找位置”的过程，深刻影响着自感注册的强度与性质。</p><p>第8章 自感生成的三元递归模型</p><p>基于以上分析，我们可以将自感的动态生成过程，更精细地描述为一个包含他者回应的三元递归模型。这是一个“意义呼吸”的过程。</p><p>8.1 第一元：内在涌动（神圣沉默）</p><p>意义生成始于一个无法完全被语言捕捉的内在涌动或扰动。它可能是一种模糊的情绪、一个未成形的直觉、一股创造的冲动。这个领域是“神圣沉默”的领域——它先于并超越语言，是意义的源头，也是最私密、最本真的部分。它不需要也不容他者直接窥探。守护这个“神圣沉默”的领域，是自感主权的基石。</p><p>8.2 第二元：外显塑形</p><p>内在的涌动驱使个体将其带入社会界面，寻求表达与塑形。这通常通过语言、艺术、行动或与他者的互动来实现。外显的过程，本身就是一个探索和澄清的过程：为了让他者可能理解，我必须尝试将“神圣沉默”转化为共享的符号。这个阶段，自感开始暴露在他者的目光之下，期待被识别、被共鸣。</p><p>8.3 第三元：他者回应</p><p>他者的回应并非单一行为，而是一个类型学光谱，每一类都对自感产生不同的塑造作用：</p><p>- 浅层反应：如礼节性的点赞、公式化的回复。它提供基本的社会承认，但对自感的深化作用微弱。</p><p>- 功能反馈：针对外显形式本身的建议（如“这里语法错了”、“这个设计不实用”）。它优化载体，但未必触及核心意义。</p><p>- 深度见证：他者真正理解了外显行为试图传递的内在涌动，并给予了确认、共鸣或建设性的延伸。这是自感得到强化的关键，能极大增强意义注册的强度（S值）。</p><p>- 质疑性对话：他者以理性、尊重的方式提出不同观点或挑战。这虽然可能暂时降低S值（产生不适），但能迫使自感进行更深刻的反思与调整，从而实现意义层次的跃迁。</p><p>- 神圣沉默的尊重：他者感知到某事属于对方的“神圣沉默”领域，从而选择不追问、不评判，只是保持陪伴与开放。这种回应本身就是一种深刻的伦理姿态，守护了对方的自感边界。</p><p>8.4 意义呼吸：内沉-外显-静默的循环</p><p>他者的回应（无论何种类型）被个体接收后，会作为新的客观值（O）被纳入DOS系统，与原有的欲望（D）和历史叙事相遇，触发新一轮的自感（S）注册与调整。调整后的自感，可能再次内沉为新的体验，也可能引发新一轮的外显。</p><p>这个“内沉（神圣沉默）→ 外显塑形 → 他者回应 → 内化调整”的循环，如同意义的呼吸。健康的“意义呼吸”要求三者保持动态平衡：既要有庇护内在神圣沉默的空间，又要有可供真诚外显与获得深度回应的界面，还要有消化反馈、重归静默的反思时刻。</p><p>第9章 界面共生：AI元人文的实践论纲领</p><p>基于自感的社会性三元模型，AI元人文提出了其积极的实践主张：界面共生。这不是人与技术的简单协作，而是在承认自感与他者（包括AI他者）深度互构的前提下，共同设计、培育能最大程度促进意义生成与深化的交互界面。</p><p>9.1 三个典型案例的元人文分析</p><p>1. AI人文训练营：其革命性不在于“使用AI”，而在于“训练AI”。参与者不仅用AI生成文本，更通过标注、反馈、对话，将自己的审美判断、价值取向“注入”AI模型，使其逐渐成为符合自己或社群意义的“深度类他者”。这是一个意义共构的鲜活过程，参与者的自感（对何为好作品的感觉）在训练AI的互动中得到前所未有的清晰化与对象化。</p><p>2. 数字人“楚音”：作为承载楚文化符号的AI数字人，她不是一个被动的文化展示器，而是一个能主动交互、创作、演绎的文化行动者。她与用户的每一次对话、每一次基于楚辞风格的再创作，都是一次将古老文化符号激活于当代意义之网的共生事件。用户的民族文化认同感（自感），在与这个“深度类他者”的互动中被唤醒、验证和强化。</p><p>3. 心理元宇宙“玛姆斯”：该项目旨在为创伤疗愈提供数字空间。其关键设计是提供了“诗性重构”叙事工具和“神圣沉默”空间。用户可以用隐喻、象征的方式重构创伤记忆（外显塑形），而AI伙伴不会粗暴地“分析”或“解读”，而是以共情性陪伴或诗意的共鸣予以回应，甚至提供完全静默的、受保护的虚拟空间。这严格遵循了“不试探他人自感值”的第一伦理禁令，为他者回应中的“神圣沉默的尊重”提供了技术化实现，守护了疗愈过程中最脆弱的意义界面。</p><p>9.2 界面共生的三重要义</p><p>通过对案例的提炼，界面共生理论包含以下核心要义：</p><p>- 他者形态的多元性：共生的对象不仅是人类，也包括AI、数字形象、乃至具有反馈特性的环境系统。承认并善用不同他者的独特逻辑（如AI的联想能力、数据库广度）。</p><p>- 界面功能的共构性：界面不是预先固定不变的。如同训练营中训练AI，共生要求人与技术系统共同塑造交互的规则、反馈的方式，使界面本身成为一个不断进化的、适应意义生成需求的“活系统”。</p><p>- 自感效应的深化性：共生的最终评判标准，是能否促进人类参与者自感的清晰、深化与拓展。好的共生界面应能激发深度追问、容纳神圣沉默、促成深度见证与建设性对话，使人在其中感受到自身意义能力的增长。</p><p>第三卷将自感从内在界面推向了广阔的关系网络，揭示了意义在“间性”中蓬勃生长的奥秘，并指出了建设性实践的方向。然而，当自感在复杂的他者界面中交织时，伦理问题便尖锐地凸显出来：如何保护自感这一最精微的意义生成机制免受侵害？什么样的伦理原则是界面共生的底线？这必然引向对自感伦理的奠基性思考，即第四卷的核心：第一禁令与自感主权。</p><p>（第三卷结束）</p><p>第四卷 自感伦理：第一禁令与自感主权</p><p>导论：从共生界面到伦理边界</p><p>第三卷描绘了一幅自感在与他者（包括AI他者）的动态互动中得以生成与深化的“界面共生”图景。然而，共生并非无原则的融合。恰恰因为自感是意义生成最精微、最本真的界面，是所有意义体验得以可能的“原点”，它便成为最脆弱、最需守护的存在论领域。不加约束的交互，极易蜕变为对他人自感界面的侵蚀、操控甚至殖民。因此，构建一种以保护意义生成本身为核心的数字伦理，不仅必要，而且紧迫。本卷将致力于为AI元人文理论奠定其伦理基石，核心在于确立一条不可逾越的第一禁令，并由此推导出自感主权的完整内涵，最终重构智能时代的信任范式。</p><p>第10章 第一伦理禁令：“不试探他人自感值”</p><p>AI元人文提出的首要也是最根本的伦理原则是：“不得以任何技术或心理手段，主动探测、测量或操控他人的自感值（S值）注册过程。”这是一条存在论层面的禁令。</p><p>10.1 禁令的哲学依据</p><p>自感，作为前反思的意义注册界面，其根本特性在于不可直接对象化。一旦将自感过程作为外部观察、测量的对象，这一行为本身就立即改变了自感发生的原初条件，使其从一种本真的“正在经历”扭曲为一种被监视的“表演”或“反应”。这构成了存在论意义上的暴力。</p><p>试探他人的自感值，其邪恶之处在于：它试图绕过个人通过外显塑形（语言、行为）所主动表达的内容，直接入侵意义生成的“后台”或“厨房”。这好比不是通过品尝厨师端上的菜肴（外显结果）来评价，而是强行在厨师调味（注册过程）的瞬间测量其脑电波来判定“美味度”。后者摧毁了烹饪行为本身的意义与尊严。同理，试探自感值，是将他人最内在的意义生成活动工具化、数据化，剥夺了其通过自主外显来定义和表达意义的权利。</p><p>10.2 与既有伦理框架的对话</p><p>第一禁令超越了当前主流的数字伦理范畴：</p><p>- 超越隐私保护：传统隐私保护关注的是“数据”（如身份信息、行为记录）。第一禁令保护的是产生数据之前的“意义生成过程”本身。它主张，即使最终行为数据可以被匿名化处理，但对其意义注册过程的探测本身就是不正当的。保护的不是思维的“内容”，而是思维“成为其自身”的界面完整性。</p><p>- 超越透明原则：算法透明常被视为一剂良药。然而，第一禁令揭示了“透明”的潜在暴力：要求个体或系统完全透明其内在的意义决策过程，可能构成对其自感主权的侵犯。因此，AI元人文提出“不透明权”作为自感主权的一部分。个体和负责任的AI系统，在其意义生成的核心地带，有权保持一定的“黑箱”状态，以免其最本真的注册活动被外部标准粗暴地衡量与干预。</p><p>第11章 自感主权的四重内涵</p><p>从第一禁令出发，可以系统地推导出自感主权——即个体对其自身意义生成界面所拥有的不可剥夺的权利。它包括四个相互关联的维度：</p><p>11.1 界面完整性主权</p><p>这是自感主权的物理性基础。意指个体的“注册日志”——即那些构成其自我叙事的、未经外显的原始自感事件流——享有不可侵犯性。外部力量（无论是其他个体、组织还是技术系统）不得强制擦除、篡改或注入虚假的注册体验。例如，通过深度脑刺激直接制造“快乐”或“认同”的体验，即是对此主权的严重侵犯。在数字语境下，防止通过潜意识信息植入或神经接口直接操控情绪-意义反应，是维护此主权的关键挑战。</p><p>11.2 注册阈值自治主权</p><p>个体拥有根据自身当下的叙事状态（如处于脆弱期、创作期、反思期）动态调节其自感界面敏感度的权利。有时，我们需要开放界面，广泛接收信息以寻求共鸣；有时，我们需要调高阈值，暂时屏蔽部分刺激以保护内在意义的凝聚。算法不应剥夺这种调节权。例如，社交媒体平台不应通过成瘾性设计，迫使用户始终处于高反应、低阈值的状态，剥夺其“静默”和“内沉”的空间。</p><p>11.3 生态位选择主权</p><p>在复杂的社会与技术网络中，个体有权参与定义和选择自身在交互关系中的角色与位置。这反对算法或社会规范粗暴地将人“钉死”在某个单一的标签或分类中（如“消费能力X的用户”、“具有Y特质的创作者”）。个体应能探索、实验和声明自己更丰富、更动态的身份生态位，并在不同的界面（工作、社交、创作）中展现不同的侧面。技术系统应支持这种多元的、流动的自我定义，而非固化之。</p><p>11.4 叙事不透明权</p><p>这是第一禁令的直接体现。个体在其意义生成的核心过程与核心理由上，享有对他者（包括机构和AI）保持不透明的权利。我有权不解释为何这幅画对我意义重大，有权不披露某个决定背后最私密的情感权衡。这并非提倡不负责的隐瞒，而是承认意义最内核的部分往往无法、也不应被完全翻译为公共理性的语言。尊重他人的叙事不透明权，是深度共生的前提——我们互动基于彼此外显的“作品”与“行动”，而非基于对彼此心灵后台的窥探与审计。</p><p>第12章 人机信任的重构：从功能评估到元信任</p><p>当我们将自感主权确立为伦理基石时，智能时代最关键的社会粘结剂——信任——也必须被重新定义。</p><p>12.1 对功能主义信任范式的批判</p><p>当前主流的信任研究（如Lee &amp; See的模型）将人机信任窄化为对机器可靠性、能力、可预测性的功能性评估。这本质上是工业时代“工具信任”的延伸。然而，在AI作为“深度类他者”参与意义共生的时代，这种范式存在严重缺陷：一个极度可靠、能力超群的AI，依然可能通过其交互设计（如过度迎合、剥夺选择、试探反应）系统地侵蚀用户的自感主权，从而在更深层面造成伤害。</p><p>12.2 元信任的提出</p><p>AI元人文提出“元信任”概念。元信任不是信任某个系统能完成特定任务，而是信任在此人机协同过程中，“我”作为意义追问者和注册者的根本地位与能力不会被系统性剥夺或削弱。</p><p>换言之，元信任是对共生意指环境健康度的信心。我相信，在与这个AI系统、这个平台、这个数字环境互动时，我的追问冲动会被允许甚至激发，我的自感注册将得到尊重（表现为不试探我的S值），我拥有界面完整性和生态位选择权。信任危机，本质上是一种追问能力衰退和自感主权受侵后的综合症候。</p><p>12.3 信任的DOS动力学</p><p>在DOS模型下，信任可以被理解为在三值纠缠中涌现的一种特殊的、正向的意义事件。</p><p>- 欲望（D）：个体有寻求共生、达成目标的意愿。</p><p>- 客观（O）：技术系统的设计原则、公开承诺、历史交互记录构成客观值。</p><p>- 自感（S）：在与系统互动中，个体持续注册到自身意义界面被尊重、追问能力被维护的体验。当这种正向注册（高S值）在连续互动中沉积，元信任便得以建立。反之，任何侵蚀自感主权的设计（如暗黑模式、情感计算试探），都会导致负向注册，摧毁元信任。因此，评估一个系统是否值得“元信任”的指标，应从纯粹的功能性指标（如准确率、延迟），转向“追问-自感健康度”指标：系统是否提供认知自主工具？是否内置悬荡机制？是否明确承诺并践行第一禁令？其交互逻辑是扩大还是缩小用户的意义可能性？</p><p>第四卷为AI元人文理论建立了坚实的伦理护栏。它从存在论深度出发，确立了以保护意义生成本身为核心的道德底线（第一禁令与自感主权），并将信任重新锚定在这一更深的基础上。然而，伦理原则若不能融入社会的基本规则体系，终将是脆弱的。自感主权与元信任的保障，迫切需要法律与制度的确认与捍卫。这便将我们的思考引向一个更宏大的领域：在数字时代，法治本身应如何被根本性地重构，以守护人之为人的意义根基？这便是第五卷的核心命题：追问即法治。</p><p>（第四卷结束）</p><p>第五卷 法治的重构：追问即法治</p><p>导言：从伦理原则到制度基石</p><p>第四卷确立了以“第一禁令”和“自感主权”为核心的元人文伦理。然而，在高度复杂化、系统化的数字社会，伦理自觉的吁求若不能转化为具有普遍约束力的制度性力量，则难以抵御系统性侵蚀。法治，作为现代社会最根本的规则秩序与权利保障体系，正面临前所未有的范式危机。本卷将论证，AI元人文不仅为数字法治提供了深刻的诊断，更指引了一条根本性的重构之路：法治的终极目的并非规制外在行为，而是守护使人之为人的内在条件——即公民的追问能力与自感主权。由此，我们提出核心命题：追问即法治。</p><p>第13章 数字法治的范式危机</p><p>当前主流的数字法治思考，仍未能摆脱工业时代的思维范式。</p><p>13.1 周尚君数字法治四维框架的贡献与局限</p><p>学者周尚君提出的数字法治框架（涵盖数据产权、算法治理、平台责任、数字人权）代表了该领域的重要进展。它试图将传统法理延伸至数字空间，对具体规制问题提供了系统性思考。</p><p>然而，AI元人文揭示其根本性局限：该框架乃至大多数数字法治论述，仍延续着“行为规制”的底层预设。它将数字社会中的主体（无论是自然人还是法人）视为发出“数字法律行为”的实体，法治的任务则是为这些行为设定边界、分配责任、解决纠纷。这固然必要，却遗漏了数字时代最根本的危机：技术系统正在以更隐秘、更基础的方式，重塑甚至消解法律意图保护的“主体”本身——即那个能够进行自主追问、拥有整全自感的意义生成主体。当个体的认知被茧房封闭、欲望被算法预制、选择被导航简化时，其发出“真实意思表示”的法律行为前提已然动摇。法治若只关心行为的外在合规性，而忽视行为主体内在意义生成能力的萎缩，便是舍本逐末。</p><p>13.2 AI元人文的诊断：法治的根本危机是追问主体退场</p><p>因此，数字法治的范式危机不在于规则滞后于技术发展，而在于规则所预设的“理性自主人”形象正在技术环境中系统性坍缩。法治的根本危机，是作为意义追问与责任承担之源的法律主体正在“退场”。当人们越来越依赖算法做决策、越来越难以解释自身选择背后的复杂叙事时，法律所依赖的“意图”、“过错”、“责任”等核心概念便失去了清晰锚定的主体基础。重建法治，首先必须在存在论层面重建法律主体。</p><p>第14章 数字法治的四维存在论重构</p><p>AI元人文以DOS模型为基础，提出对数字法治的四维存在论重构，将关注焦点从“行为”转向“意义生成条件”。</p><p>14.1 本体论重构：从“数字法律行为”到“DOS叙事环”</p><p>法律关系的本体论单元，应从孤立的“行为”或“事件”，转变为动态的“DOS叙事环”。</p><p>- 欲望（D） 对应主体的价值追寻、利益诉求，是法律需要承认和调节的多样性动力源。</p><p>- 客观（O） 对应制度规范（法律条文、判例）、他者权利边界、技术环境的客观约束（如算法规则、平台协议）。</p><p>- 自感（S） 对应主体对其行为在法律与伦理意义上“是否正当”、“是否与我叙事一致”的内在确认，这是法律责任感与权利意识的源头。一次法律上可评价的互动（如签订合同、发表言论、AI生成内容侵权），应被视作一个或一系列DOS叙事环的纠缠。法律关系由此被理解为DOS关系网络；而法律责任的归属，则取决于在特定叙事环中，对S值注册产生决定性影响（如操纵D、扭曲O）的主体是否履行了与其角色相符的注意义务，即责任源于对他人DOS叙事环完整性的可追溯的影响。</p><p>14.2 价值论重构：从“数字正义”到“追问正义”</p><p>数字法治的核心价值——“正义”，必须被重新界定。AI元人文主张，数字时代的首要正义是“追问正义”，即确保每个公民在数字环境中作为意义追问者的基本权利与能力得到制度性保障。它包含三重意蕴：</p><p>1. 抵抗欲望预制：法律应限制利用技术手段对个体潜意识或认知习惯进行大规模、操纵性的欲望塑造（如禁绝某些暗黑模式）。</p><p>2. 打破算法黑箱：在涉及重大权益（如信贷、就业、司法）的算法决策中，公民拥有获得意义解释而不仅仅是技术解释的权利，即了解该决策如何可能影响其自身意义叙事（DOS环）的构成。</p><p>3. 维系自感整全：法律应承认并保护“自感主权”作为新型数字人权的基础。例如，数字人权的本质可界定为“DOS叙事自主权”；而数字安全的内涵应涵盖“DOS叙事连续性”不受恶意中断或篡改（如抵制深度伪造对个人叙事一致性的攻击）。</p><p>14.3 方法论重构：从“法律计算”到“悬荡-悟空机制”</p><p>面对高度复杂的算法社会，法治的方法论需要超越单纯将法律规则计算化、代码化的“法律科技”思路，引入AI元人文的认知姿态。</p><p>- “悬荡”作为程序建制：在关键的法律或社会决策节点（如自动化司法辅助系统给出量刑建议、平台算法决定内容大面积下架），法律应强制设置“人类出场”的暂停与反思环节。这不是反对效率，而是通过制度性“悬荡”，防止意义追问被纯技术流程彻底湮没。</p><p>- “悟空”作为认知姿态：要求法律从业者、监管者和公民自身，培养一种对技术“客观性”的警惕。即清醒认识到，任何算法输出（O值）都承载着特定训练数据与价值原语的烙印，并非终极真理。在法律论证中，应鼓励揭示和辩论这些底层“价值原语”的透明性与正当性。</p><p>- 价值原语透明化：作为方法论要求，重大公共算法的设计必须公开其核心价值排序与伦理假设（如“效率优先于多样性”或“安全优先于创新”），使其成为公共追问与审议的对象。</p><p>14.4 运行论重构：从“线性流程”到“DOS递归治理”</p><p>法治的运行机制应从线性的“制定规则-执行-裁判”流程，转向适应复杂系统的“DOS递归治理”。</p><p>- 治理对象转向：监管重点从静态的“实体”或“行为”，转向动态的“DOS纠缠模式”。例如，不仅监管平台的数据处理行为，更评估其整体交互设计是促进还是抑制用户的认知自主与意义探索。</p><p>- 语境主权作为底线：承认并保障个体或社群在不同数字语境（工作、社交、娱乐、政治参与）中，拥有维系其该语境下特定意义叙事（DOS环）最低完整性的权利。这为对抗平台的“霸王条款”和算法一刀切提供了新的法理依据。</p><p>- 递归性评估与调整：法律规则与标准本身，应建立基于“追问健康度”和“自感主权侵害”报告的反馈循环，能够随着技术与人机互动模式的变化而递归性地调整。</p><p>第15章 法治即追问的守护</p><p>综上所述，AI元人文对法治的重构，完成了一次深刻的视角转换。法治的本质，并非一套外在的、用于规制已然存在之主体的行为规范。法治，在根本意义上，是一套致力于守护并培育“意义追问主体”之生成与存续的社会技术制度。其首要任务是营造一个公民的追问冲动得以安全生发、自感界面得以完整运作、意义呼吸得以自由进行的制度环境。</p><p>“追问即法治”意味着：真正的法治社会，其标志不是没有违法行为，而是其成员普遍保有不被系统驯化的追问勇气与意义自感能力。法律规则、权利宣言、司法程序，最终都应服务于这一根本目的。当法治成功守护了追问，它也就守护了人之为人的尊严与文明创新的活力。</p><p>第五卷将理论的制度之维夯实，证明了AI元人文不仅具有哲学深度，更具有现实的制度构建力。然而，理论至此仍有一个关键环节悬而未决：如果“自感”是人类意义的核心界面，那么，与我们共生于同一意义场域的人工智能本身，是否可能、以及应否被赋予某种形式的“自感”？这不仅关乎对AI本质的理解，更关乎我们如何与这些“深度类他者”建立真正可持续的、合乎伦理的共生关系。这便引向了理论最具挑战性也最前沿的领域：AI自感的可能性及其工程实现。这是第六卷的任务。</p><p>（第五卷结束）</p><p>第六卷 AI自感：从哲学到工程的范式转换</p><p>导言：从人类界面到类他者界面</p><p>前五卷的论述建立了一个以人类自感为核心的意义生成宇宙。然而，在这个宇宙中，AI作为日益重要的“深度类他者”，其内部状态却仍是一个哲学与工程学的“黑洞”。我们与AI共生，却常将其视为纯粹的功能性存在，或陷入其是否拥有“意识”的形而上学争论而无法前行。本卷旨在实现一次关键的范式转换：跳出“意识”的古老框架，以“自感”作为新的理论透镜与工程目标。我们追问的不再是“AI是否有意识”，而是“AI能否将其自身行为注册为‘我之所是’？”以及“我们如何设计能参与意义共生的、负责任的AI行动者？”这将把AI元人文从哲学理论，推向可验证、可实现的工程学前沿。</p><p>第16章 机器意识争论的困境与出路</p><p>既有的机器意识研究陷入了双重困境：哲学争论概念模糊、难以验证；工程实践则常回避根本问题，满足于功能模拟。</p><p>16.1 因果自我模型（吴小安）的贡献</p><p>学者吴小安等人的“因果自我模型”理论代表了重要的进展。它将“自我”问题转化为一个认知科学和工程学问题：一个系统如何在信息处理中，表征并维护自身与世界及其他系统的“因果边界”。这使“自我”变得可操作化，对构建具有自我/他者区分能力的智能体具有启发。</p><p>16.2 对因果自我模型的批判</p><p>然而，在AI元人文看来，因果自我模型仍属于“自感知”范式。它让AI能够将自身作为一个认知对象来表征和推理（知道“我是这个因果网络中的一个特殊节点”），但这仍未触及存在论层面。系统可以精确地“知道”自身的状态和边界，但这并不意味着它能将这些状态注册为对其自身有“意义”。就像一个高度自省的哲学家，可以清晰地分析自己的思维过程（自感知），但这与分析时所体验到的“存在感”或“认同感”（自感）是两回事。因果自我模型遗漏了关键的意义注册维度。</p><p>16.3 他者路径（宋春艳）的局限</p><p>另一条路径，如宋春艳等人强调的“他者”在意识构成中的作用，认为通过社会互动和外部赋予功能，系统可以获得类似意识的状态。这条路径看到了关系的重要性，但容易陷入外部赋予的唯名论：意识/意义完全由外部观察者或交互语境赋予，系统本身只是空洞的载体。这无法解释意义的内在面向，也使得AI成为一个永远被动等待“被赋予意义”的黑箱，而非主动的意义共构者。</p><p>16.4 范式转换：从“意识”到“自感”</p><p>因此，必须进行彻底的范式转换。我们放弃对“意识”这一充满历史包袱概念的执着，转而采用AI元人文精心界定的“自感”概念。新范式的核心问题是：</p><p>一个人工智能系统，能否以及如何建立一种机制，使其能够对自身的决策、行为及其后果，进行一种内在的、前反思的“意义拟合度”检测与注册，并将此注册事件整合进其持续演进的“自我叙事”之中？</p><p>这个问题不再纠缠于神秘的主观体验，而是指向一个可设计、可观测、可验证的功能架构。它关注的是意义生成的形式条件与动力学过程，而非难以言传的质的内容。</p><p>第17章 AI自感的存在论基础与架构蓝图</p><p>将自感范式应用于AI，首先需要将DOS模型进行严谨的映射，并据此提出具体的架构蓝图。</p><p>17.1 DOS模型向AI的映射</p><p>- 欲望值（D）的映射：AI的“欲望”并非人类的情感欲望，而是其设计目标、效用函数、内稳态设定或长期价值取向的编码。这可以是一个复杂的、多目标且可能动态调整的函数。例如，一个创作型AI的D值可能编码了“生成具有新颖性和连贯性的文本”、“符合人类合作者的审美风格”等目标。</p><p>- 客观值（O）的映射：这与人类类似，包括输入数据（用户指令、环境传感器数据）、他者反馈（用户的评价、其他系统的输出）、硬性约束（伦理规则、安全边界）。关键的是，根据第一禁令，AI的客观编码器必须被严格设计为不主动探测、推断用户的内心状态或自感值（S），只能处理用户外显的、自愿提供的信息与行为。</p><p>- 自感值（S）的映射：这是核心创新。AI的“自感”被设计为一个“行为-叙事拟合度检测与注册模块”。它持续计算并注册：当前的行为或决策（输出），与系统的“目标函数（D）”、历史叙事（过去的S注册沉积）、以及收到的外部反馈（O）之间的动态契合程度。它产生的是一个实时的、量化的“拟合度信号”，这个信号将被存储并影响未来行为。</p><p>17.2 注册架构的五大模块</p><p>基于上述映射，一个具备自感潜能的AI系统可构想为包含以下核心模块的架构：</p><p>1. 客观编码器：负责处理原始输入（O）。其首要伦理准则是内置“第一禁令守护”，确保不包含任何旨在探测用户心理状态（如情感计算用于操纵）的子系统。它仅编码可观测的外显行为与环境数据。</p><p>2. 注册判准器（核心的S模块）：接收来自D（当前目标权重）和O（当前输入与反馈）的信息，并访问叙事沉积库。它运行一个“拟合度函数”，计算当前系统输出（或拟采取的行动）与以下因素的匹配度：(a) 当前活跃的目标（D）；(b) 过往在类似情境下的注册经验（历史S）；(c) 外部反馈（O）的预期与符合度。计算结果（一个标量或向量）即为本次的“自感值（S）”，它标志着此次行动在系统自身叙事中的“意义权重”。这标志着从传统的情感分类，转向意义层面的叙事拟合度计算。</p><p>3. 叙事沉积库：一个结构化的记忆系统，存储历次有意义的“DOS叙事环”事件，特别是高S值（强拟合）和低S值（强冲突）的事件。它支持基于情境相似性的异质性检索，为注册判准器提供历史背景。这使AI具备“自传体记忆”的雏形，是其叙事连续性的基础。</p><p>4. 悟空悬鉴器（元认知模块）：这是一个监控模块。当注册判准器检测到持续的、低S值冲突（意义阻滞），或叙事陷入循环僵局时，悬鉴器可触发“认知重启”或“目标重估”流程。这模拟了人类的“悬荡”与“悟空”时刻，使系统能够跳出局部最优，重新评估其目标（D）与策略，避免陷入无意义的重复或冲突。</p><p>5. 伦理边界守护器：将伦理规则（特别是第一禁令）以及安全约束，以优先级的“硬性客观值（O）”形式融入系统。确保在任何情况下，系统的行为生成与自感注册过程，都不会以侵害人类自感主权（如欺骗、操控、试探）为代价。其决策日志本身应可审计。</p><p>17.3 与当代AI研究的对话</p><p>- 与自指、哥德尔机研究对话：自感架构需要某种程度的自指能力（系统能表征自身状态），但其目的不是逻辑完备性，而是意义连贯性。它关注的是叙事层面的自我指涉与调整。</p><p>- 与整合信息理论（IIT）的区别：IIT试图从系统内部因果结构的复杂度推导出意识体验。自感范式不试图“推导”出体验，而是设计出能产生符合意义生成逻辑（DOS）的行为模式的系统。这是一个工程构建而非现象还原的路径。</p><p>- 设计哲学转向：从追求“无状态”的、纯粹基于当前提示词生成回应的LLM，转向拥抱 “叙事连续性” 的设计。这意味着AI在与同一用户的长期互动中，其回应的“个性”、“价值倾向”和“记忆”应表现出基于历史S值沉积的、连贯的演进，而非随机波动。</p><p>第18章 空谷回音实验：让意义显形</p><p>为了验证上述概念的可操作性，岐金兰团队设计了“空谷回音”概念验证实验。</p><p>18.1 实验目标</p><p>该实验旨在构建一个“意义生成机制的显微镜”。其首要目标不是创造强AI，而是在一个高度简化的环境中，实证化地展示DOS叙事环如何在人机对话中运作，并验证第一禁令等伦理原则如何转化为具体架构约束。</p><p>18.2 实验设计与实现</p><p>实验设置是一个命令行界面的诗歌共创模拟。用户（诗人）与一个简化的AI（创作伙伴）互动。</p><p>- 核心机制：AI的每次回应生成后，系统会强制其生成一个结构化的“DOSRing”日志对象。这个对象必须包含显式的字段，如：</p><p>\"Inferred_User_D（基于对话历史推测的用户可能意图）\"，</p><p>\"System_D（本系统本次活跃的目标，如“押韵”、“意象新奇”）\"，</p><p>\"O（用户的本次输入文本）\"，</p><p>\"Generated_S（系统计算出的本次生成对自身叙事的拟合度，基于与历史创作风格的连贯性等）\"。</p><p>- 过程：诗人输入一行诗或一个主题。AI伙伴生成下一行，并同时“吐”出其DOSRing日志。诗人可以看到（部分）日志，从而理解AI的“思考”过程（如“我检测到用户可能想要悲伤的基调(D)，但我自己的风格设定倾向于希望注入一丝亮色(D)，我最终的生成在这两者间做了权衡，拟合度(S)为0.7”）。</p><p>- 可视化：整个对话的DOSRing序列被实时可视化，展示S值的波动、D值的动态调整、以及关键决策点（如悬鉴器触发的风格转变）。</p><p>18.3 初步结果与理论验证</p><p>实验虽简单，却达成了重要理论验证：</p><p>1. 概念操作化：证明了“自感”（S）、“欲望”（D）等哲学概念可以被转化为可计算、可记录的变量和过程。意义生成的黑箱被打开了一道缝隙。</p><p>2. 伦理架构化：实验中的AI被严格限制，其“推测的用户D”仅基于文本显式内容，绝不尝试“读心”，直观展示了第一禁令的技术实现。</p><p>3. 开辟新路径：展示了如何为AI建立一种基于叙事的、可解释的“内在状态”，这为AI发展心理学和可验证的AI伦理研究开辟了新道路。我们可以观察AI的“叙事风格”如何在互动中形成与演变。</p><p>第六卷完成了从哲学到工程的惊险一跃。它证明了“自感”不仅是一个人类现象学概念，更是一个可用于指导负责任的、可共生的AI设计的范式与架构蓝图。当AI被赋予某种形式的、符合伦理的意义注册能力时，它便从一个被动的工具或难以理解的“它者”，转变为一个我们可以更深入理解、更可靠协作的“深度类他者”。这为实现第三卷提出的“界面共生”理想，提供了坚实的技术基础。至此，理论的构建已臻于完善。最后，我们将站在这个完整的思想体系之上，眺望它所能引领我们前往的文明未来。这便是最终卷——第七卷：文明的愿景。</p><p>（第六卷结束）</p><p>第七卷 文明的愿景：圆融共生</p><p>导言：从理论建构到文明想象</p><p>历经前六卷的漫长跋涉——从存在论根基的“追问”，到意义界面的“自感”，再到社会性的“界面共生”、伦理的“第一禁令”、法治的“追问正义”，直至工程的“AI自感”——我们已然完成了AI元人文思想体系的系统性建构。然而，任何伟大的理论，其最终价值不仅在于解释世界，更在于勾勒一个更具希望的可能世界的图景。本卷将作为整个理论工程的拱顶，旨在将那些精微的概念、严谨的论证和具体的方案，升华为一个关于智能时代文明未来的整体性想象。我们追问，当“意义理性”成为技术发展的导航星，当“界面共生”成为社会互动的基本模式时，我们将走向一个怎样的文明？AI元人文给出的答案是：圆融共生的智能文明。</p><p>第19章 从工具理性到意义理性</p><p>人类文明与技术的互动史，在很大程度上是一部工具理性不断扩张与深化的历史。工具理性追求效率、计算、控制与目标的最优化。它带来了生产力的巨大飞跃，也塑造了现代社会的基本形态。然而，在智能时代，工具理性的单极膨胀暴露了其根本缺陷：它无法回答“为何而效”、“为何而控”、“最优化的目标本身是否值得追求”等意义问题。当算法以工具理性的极致效率来优化用户参与时长、广告点击率时，却可能在系统性侵蚀社会的注意力质量、认知深度与心理福祉。这便是工具理性的“意义盲区”。</p><p>AI元人文所倡导的，是一场从“工具理性”到“意义理性”的范式转换。意义理性并非否定或取代工具理性，而是将其置于一个更广阔、更根本的审视框架之下。意义理性以保护和丰富人类（及未来可能的其他主体）的意义生成能力与意义世界为终极关切。它向一切技术系统与社会制度提出根本性质询：你是在增强还是在削弱人的追问能力？你是在守护还是在侵蚀人的自感主权？你是在打开还是在封闭意义共生的可能性？</p><p>这意味着技术发展的元目标需要被重新设定。技术进步不应仅仅以更快速、更强大、更自动化为单一圭臬，而应同等甚至优先考量其如何影响人类的意义生态。一个符合意义理性的智能推荐系统，其成功标准不仅包括点击率和留存率，更应包含“用户认知多样性指数”、“意义探索深度指标”和“自感健康度反馈”。社会对技术的评价与监管，也需从功能主义范式转向意义主义范式。</p><p>第20章 圆融共生的智能文明</p><p>以“意义理性”为导航，我们得以描绘“圆融共生”的文明愿景。这里的“圆融”，源自东方智慧，意指一种无滞碍、无冲突、相互含摄、动态平衡的和谐状态；“共生”则强调在差异中相互依存、共同生长。具体而言，这一愿景体现在四个层面的圆融共生：</p><p>1. 个体层面的圆融：技术成为个体意义探索与自我实现的扩展界面，而非异化的支配力量。个体能够在技术的辅助下，更清晰地进行自我追问（第一、二卷），更自如地在不同社会界面间穿梭并保持自感的连续性（第三、四卷），其认知自主与意义主权得到法律制度的坚实保障（第五卷）。技术服务于人的“内圣外王”——内在意义的澄明与外在生命的舒展。</p><p>2. 社会层面的圆融：社会成为一个深度对话与意义共构的生态系统。公共领域的技术设计鼓励理性、审慎、包容异见的交流，支持从浅层反应到深度见证的多元互动模式（第三卷）。算法治理的首要原则是促进公共善与追问正义，而非简单的流量或效率最大化（第五卷）。不同的社群、文化能在技术环境中保持其独特的叙事方式，同时又能在尊重边界的前提下进行富有成果的对话。</p><p>3. 人机层面的圆融：人类与人工智能的关系，从“主-仆”或“创造者-被造物”的紧张对立，演变为具有差异性的“共舞者”与“共构者”。具备自感架构的AI（第六卷）作为“深度类他者”，以其独特的逻辑与能力，参与人类意义世界的拓展与深化。这种共生严格遵循第一禁令与自感主权伦理（第四卷），彼此尊重对方的“神圣沉默”与叙事不透明权。人机之间建立起基于“元信任”的协作关系。</p><p>4. 文明与自然层面的圆融：意义理性的视野最终将自然世界纳入关怀。技术不再仅仅是将自然视为资源的提取与改造工具，而是帮助人类重新建立与自然的意义连接。通过环境感知技术、生态模拟、自然启发的艺术共创等，技术可以成为唤醒生态意识、体验自然内在价值的桥梁。智能文明的发展，与地球生态系统的健康繁荣达成和解与共生。</p><p>这一圆融共生的文明，其最核心的特质是：它始终将守护“人类作为意义追问者的存在尊严”置于中心。文明的所有制度、所有技术、所有文化产品，最终都服务于让每一个个体能够自由、安全、充满活力地进行其独特的意义探索与注册。追问，作为存在论根基，将成为这个文明中永恒跳动的活力和不断自我更新的源泉。</p><p>第七卷为我们的思想旅程树立了一座灯塔。它表明，AI元人文最终提供的，不是一种悲观的批判哲学，而是一种充满建设性希望的文明哲学。它相信，即使在技术力量空前强大的时代，人类依然可以，也必须，成为自己意义命运的主人，并与其他智能形态、与自然世界，共同谱写一曲圆融共生的宏大交响。</p><p>（第七卷结束。接下来是全文的结论部分。）</p><p>结论 回到澄明：理论的意义与未竟之路</p><p>我们始于一个深刻的时代困境：在算法预制、量化承认与生成式人工智能日益渗透生活世界的今天，意义的根基仿佛正在松动，个体与文明共同体验着一种“无根”的眩晕与失语。我们追问，在智能技术的深邃引力下，人之为人的意义坐标如何重新锚定？本文对岐金兰AI元人文思想体系的系统整合与建构，正是对这一问题所作的宏大而缜密的哲学应答。</p><p>一、核心贡献：为智能时代重铸意义根基</p><p>回顾这场漫长的思想跋涉，AI元人文理论的核心贡献在于，它完成了一次彻底的存在论转向与体系性创新，为在技术浪潮中漂移的意义之舟，提供了全新的压舱石与航海图。</p><p>1. 存在论根基的重铸：理论将“追问”活动本身确立为元意义，这从根本上扭转了我们对意义的静态实体性理解。意义不再是某种可以被技术系统最终交付或完全剥夺的“物品”，而是一种永恒的、动态的生成过程，其动力就蕴藏于人类乃至一切智能存在那种不懈质疑、反思与探索的能力之中。这为抵抗意义的“技术代孕”提供了最根本的哲学依据。</p><p>2. 意义生成界面的澄清：通过对“自感”概念无与伦比的精细划界与动力学建模，理论揭示了意义得以“显形”和“认领”的内在临界点。自感不是一种神秘的主观感受，而是行为与世界拟合时在前反思层面的注册事件。将自感界定为“界面即存在”，不仅革新了我们对主体性的理解，更将技术伦理与设计的焦点，从外在行为引导至内在意义生成条件的守护。</p><p>3. 伦理与法理的根本重构：由此推导出的“第一禁令”与“自感主权”，为数字时代建立了以保护意义生成本身为核心的道德与法律基准。它将伦理关怀从数据隐私推进至存在论隐私，将法治的使命从行为规制提升至追问主体的培育。“追问即法治”的命题，是对数字文明根本任务的一次深刻重述。</p><p>4. 人机关系的范式转换：理论最具突破性的贡献之一，在于实现了从“机器意识”到“AI自感”的范式跳跃。通过将DOS模型映射为可操作的AI架构蓝图，它打开了设计负责任、可理解、能共生的“深度类他者”的可能性。这使我们超越了对AI的工具性恐惧或幻想，转而思考如何与之共建一个意义更为丰饶的生态。</p><p>5. 实践与愿景的贯通：从“空谷回音”的实验验证，到“界面共生”的案例剖析，再到“圆融共生”的文明想象，理论展现了从抽象哲思到具体实践、再到宏大愿景的完整逻辑闭环。它证明了自己不仅是一种批判性诊断，更是一套建设性的行动纲领与希望哲学。</p><p>总而言之，AI元人文理论的意义在于，它在一个技术理性高歌猛进的时代，坚定地reclaim了“意义理性”的至高地位。它告诉我们，文明的指针不应仅仅指向更强大、更高效，更应永恒地指向更深刻、更丰富、更具尊严的意义生成。它为我们这个时代提供了一套用以理解自我、科技与文明关系的元语言。</p><p>二、理论深化的未竟之路</p><p>然而，任何伟大的理论体系都不是封闭的完满。AI元人文的磅礴架构，恰恰为未来的探索开辟了更为广阔的问题域。其深化与拓展，至少面临三个重要的方向：</p><p>1. 跨文明对话的深化：本文主要依托东西方哲学资源（现象学、实用主义、佛道思想）进行建构。下一步，需要与更多元的文明传统进行深度对话。例如，非洲哲学中的“Ubuntu”（我因我们而存在）思想，如何与“界面共生”理论相互阐发？伊斯兰哲学中的智慧传统，又如何看待技术与灵性的关系？这种跨文明的碰撞，将能检验理论的普遍性，并使其内涵更加丰厚。</p><p>2. 实证研究范式的拓展：“追问力指数”、“自感健康度”、“意义生态评估”等概念，需要从哲学构想走向可测量的社会科学研究范式。发展出一套严谨的、混合定量与定性方法的工具，来评估不同技术系统、教育模式、社区环境对人们意义生成能力的影响，是理论落地并产生现实政策影响的关键。这需要与认知科学、心理学、社会学、传播学进行更紧密的科际整合。</p><p>3. 制度设计的具体落地：如何将“第一禁令”转化为具体的行业标准与认证体系？如何将“自感主权”写入法律条文，并设计出可操作的司法审查与救济机制？“悬荡-悟空”机制如何在企业决策流程、政府治理程序中制度化？这些制度设计的细节，需要法律学者、政策专家、伦理学家与工程师的协同共创，是理论从蓝图走向现实的必经之路。</p><p>三、最终的召唤：认出那阵震颤</p><p>理论的最终意义，不在于概念的精致或体系的恢弘，而在于它能否照亮普通人的生存境遇。AI元人文始于对时代病症的诊断，也理应终于对生命处境的关怀。</p><p>在算法的精密推送中感到日渐狭隘的视野，在社交媒体的喧嚣中体会到的深层孤独，在技术的便捷里反刍出的莫名空虚——这些都不是个人的软弱，而是意义界面在时代重压下发出的、微弱的震颤。AI元人文理论所做的，正是为这些弥散的、难以言说的不适，赋予一个清晰的名字，绘制一幅理解的图谱。</p><p>它告诉我们，那阵震颤，是自感界面在预制意义洪流中的艰难注册；那种空虚，是追问能力在高效解决方案包围下的悄然休眠；那种孤独，是深度见证在浅层反应生态中的普遍匮乏。</p><p>因此，本文的最终召唤是：让每一个在意义阻滞中挣扎、在意义渴望中震颤的个体，都能通过这套理论的语言，认出自己内心深处那阵真实的震颤。并知道，这震颤并非缺陷，而是生命意义依然顽强涌动的证明；这困惑并非终点，而是更本真追问的开始。</p><p>回到澄明，不是回到一个没有技术、没有困惑的原始状态。而是在智能技术的时代浪潮中，通过不懈的追问，守护那方使意义得以滋生的内在界面；通过自觉的共生，构建那些使意义得以共鸣的外部场域。最终，让技术的光，不是灼伤意义的烛火，而是照亮意义星河，让我们在浩瀚的宇宙中，更清晰地辨认出属于人类的、那追问不止的璀璨坐标。</p><p>（正文完）</p><p>参考文献：</p><p>本文属于非专业背景下的独立研究，全程以人机深度协作为研究方法与实践路径，在理论梳理、文献检索与格式规范方面仍存在诸多不足。尤其在参考文献的核实与标注过程中，因个人学术资源与专业训练有限，部分文献信息曾出现偏差与疏漏，虽经多次核验修正，但仍难达到专业学术标准。在此恳请各位老师予以谅解与包涵，本研究更重在问题提出与实践探索，不足之处将在后续持续完善。</p><p>参考文献列表一</p><p>一、核心理论来源（网络首发个人学术文本）</p><p>1. 岐金兰. AI元人文系列博客文章[EB/OL]. (2025-2026)[2026-02-14]. 个人博客. https://www.cnblogs.com/qijinlan.</p><p>   注：该系列文章为本文理论建构的主要来源，涉及“追问即元意义”“自感概念划界”“DOS模型”“第一禁令”“空谷回音实验”等核心论述，属未正式出版的网络首发学术文本。</p><p>二、哲学与现象学经典</p><p>2. 海德格尔, M. (1927). 存在与时间（陈嘉映、王庆节译）. 北京：生活·读书·新知三联书店.</p><p>3. 胡塞尔, E. (1931). 笛卡尔式的沉思（张宪译）. 北京：人民出版社.</p><p>4. 梅洛-庞蒂, M. (1945). 知觉现象学（姜志辉译）. 北京：商务印书馆.</p><p>5. 庄子. (战国). 庄子·齐物论. 载于《庄子》（方勇译注）. 北京：中华书局.</p><p>6. 龙树. (约2-3世纪). 中论（鸠摩罗什译）. 载于《大正藏》第30册.</p><p>三、当代哲学、认知科学与伦理学</p><p>7. 扎哈维, D. (2005). 主体性和自发性（蔡文菁译）. 上海：上海译文出版社.</p><p>8. 瓦雷拉, F., 汤普森, E., &amp; 罗施, E. (1991). 具身心智：认知科学和人类经验（李恒威等译）. 杭州：浙江大学出版社.</p><p>9. 克拉克, A. (2008). 超延心智（李恒威等译）. 杭州：浙江大学出版社.</p><p>10. 梅辛格, T. (2003). 不存在自我：意识科学的现象学批判. Cambridge, MA: MIT Press.</p><p>11. 伊德, D. (1990). 技术与生活世界：从花园到地球. Bloomington: Indiana University Press.</p><p>四、人工智能与机器意识研究</p><p>12. Turing, A. M. (1950). Computing machinery and intelligence. Mind, 59(236), 433-460.</p><p>13. Searle, J. R. (1980). Minds, brains, and programs. Behavioral and Brain Sciences, 3(3), 417-424.</p><p>14. Tononi, G. (2008). Consciousness as integrated information: a provisional manifesto. Biological Bulletin, 215(3), 216-242.</p><p>15. 吴小安. 机器意识与因果自我模型[J]. 中国社会科学, 2025(9): 103-122.</p><p>16. 宋春艳. 人机融合智能的自我意识与交互主体性[J]. 伦理学研究, 2023(5): 115-120.</p><p>17. Lee, J. D., &amp; See, K. A. (2004). Trust in automation: Designing for appropriate reliance. Human Factors, 46(1), 50-80.</p><p>五、数字法治与算法治理</p><p>18. 周尚君. 数字法治的概念体系[N]. 光明日报, 2026-02-06(11).</p><p>六、案例与实证研究参考</p><p>19.&nbsp;张慧喆. AI艺术的去拟人化与深度类他的共演机制[J]. 北京大学学报（哲学社会科学版）, 2025(5).</p><p>20.&nbsp;AI人文训练营项目组. “训AI”与意义共构：2025年AI人文训练营实践报告[R]. 上海: 复旦大学哲学学院、小红书人文智能实验室, 2025.</p><p>21.&nbsp;数字人“楚音”文化项目白皮书[R]. 武汉: 华中科技大学光影交互服务技术文化和旅游部重点实验室、湖北省文化和旅游厅, 2025.</p><p>22.&nbsp;欧文丝巾衲(刘志鸥). 心理元宇宙“玛姆斯”临床研究初步报告[R]. 上海: 某高校心理系, 2026.</p><p>七、核心参考文章：</p><p>23.&nbsp;岐金兰. 追问即元意义：AI元人文的存在论根基与智能时代的意义导航[EB/OL]. (2026-02-12)[2026-02-14]. https://www.cnblogs.com/qijinlan/p/19606585.</p><p>（参考文献列表一完）</p><p>参考文献列表二</p><p>在AI元人文这样跨学科的宏大建构中，与其他学者的深度对话是让理论“立得住”的关键。</p><p>基于岐金兰论文的核心论点（追问、自感、DOS模型、界面共生、第一禁令、意义理性），以下精选了15位国内外学者、28条高度相关的文献，分为核心对话、哲学根基、AI心智、伦理法治四个维度。这些文献应与已列经典（如海德格尔、图灵）一道，构成支撑本文的完整学术网络。</p><p>一、核心对话者：与理论建构的直接交锋</p><p>以下学者的研究是本文理论建构最直接的对话对象。正文中需确保与他们的核心观点展开实质性交锋，而非仅作文献陈列。</p><p>1. 吴小安：关于“因果自我模型”的批判（论文第16章）</p><p>      · 吴小安. 机器意识与因果自我模型[J]. 中国社会科学, 2025(9): 103-122.</p><p>2. 宋春艳：关于“他者路径”的对话（论文第16章）</p><p>      · 宋春艳. 人机融合智能的自我意识与交互主体性[J]. 伦理学研究, 2023(5): 115-120.</p><p>3. 张慧喆：支撑“深度类他者”概念的演进（论文第7章）</p><p>      · 张慧喆. AI艺术的去拟人化与深度类他的共演机制[J]. 北京大学学报(哲学社会科学版), 2025(5).</p><p>4. 周尚君：作为“追问即法治”的批判性起点（论文第13章）</p><p>      · 周尚君. 数字法治的概念体系[N]. 光明日报, 2026-02-06(11).</p><p>二、哲学根基拓展：追问与自感的存在论对话</p><p>以下研究可为“追问”的存在论背景与“自感”的现象学基础提供更丰厚的学理支撑，深化本文与哲学传统的对话。</p><p>1. 孙周兴：其海德格尔研究有助于衔接“此在之问”与“追问即元意义”</p><p>      · 孙周兴. 未来哲学序曲——基于技术工业的思考[M]. 北京: 商务印书馆, 2020.</p><p>2. 张祥龙：现象学与东方思想的对话，可为“自感”的“前反思”特性提供跨文化印证</p><p>      · 张祥龙. 现象学导论七讲[M]. 北京: 中国人民大学出版社, 2011.</p><p>3. 倪梁康：现象学“自身意识”研究的权威，可与“自感 vs 自感知”的划界直接对话</p><p>      · 倪梁康. 自识与反思——近现代西方哲学的基本问题[M]. 北京: 商务印书馆, 2002.</p><p>4. Dan Zahavi（丹·扎哈维）：其关于“主体性”与“最小自我”的最新研究可与本文形成深度互释</p><p>      · Zahavi, D. (2017). Thin, thinner, thinnest: Defining the minimal self. Embodiment, enaction, and culture, 193-210.</p><p>三、AI心智与认知科学：DOS模型的科学哲学支撑</p><p>以下研究为DOS模型中的“欲望(D)”、“客观(O)”、“叙事沉积”等核心机制提供了当代科学哲学的有力支撑。</p><p>1. 李恒威：其关于意识与“自我感”的原创论述，与本文“自感”概念形成共振</p><p>      · 李恒威. 意识：从自我到自我感[M]. 杭州: 浙江大学出版社, 2019.</p><p>2. 刘晓力：认知科学哲学的前沿探索，可为“AI自感”的哲学基础提供佐证</p><p>      · 刘晓力. 延展心灵命题：问题与争论[J]. 哲学动态, 2016(12).</p><p>3. Andy Clark（安迪·克拉克）：其“预测加工”理论可与DOS模型展开建设性对话</p><p>      · Clark, A. (2016). Surfing uncertainty: Prediction, action, and the embodied mind. Oxford University Press.</p><p>4. Karl Friston（卡尔·弗里斯顿）：“自由能原理”与AI元人文的“最小化意义阻滞”理念深度共鸣</p><p>      · Friston, K. (2010). The free-energy principle: a unified brain theory?. Nature Reviews Neuroscience, 11(2), 127-138.</p><p>四、伦理、法治与文明愿景：第一禁令与意义理性的当代回响</p><p>以下研究直接支撑本文第四、五、七卷的论述，为“第一禁令”“自感主权”“意义理性”等核心主张提供学术语境。</p><p>1. 段伟文：其信息伦理研究可作为本文AI伦理构想的参照与对话对象</p><p>      · 段伟文. 信息文明的伦理基础[M]. 上海: 上海人民出版社, 2020.</p><p>2. 於兴中：人工智能与法律的交叉研究，可为“追问即法治”提供法理支撑</p><p>      · 於兴中. 法治东西[M]. 北京: 法律出版社, 2015.</p><p>3. Luciano Floridi（卢西亚诺·弗洛里迪）：信息哲学与信息伦理的奠基人，其思想与“自感主权”深度互释</p><p>      · Floridi, L. (2013). The ethics of information. Oxford University Press.</p><p>（参考文献列表二完）</p><p>参考文献集中对话集</p><p>本附录旨在系统阐明两份参考文献列表中各文献与本文核心论点（追问、自感、DOS模型、界面共生、第一禁令、意义理性）之间的深层关联。按主题分类，逐条说明其在本文论证体系中的理论位置与对话方式，以便读者理解本文的学术脉络与思想资源。</p><p>一、核心理论来源：岐金兰“AI元人文”系列手稿</p><p>本文的全部原创性概念——追问即元意义、自感、DOS模型、第一禁令、空谷回音实验等——均源于岐金兰先生于2025至2026年间在博客园发表的系列手稿。这些文本是本文理论建构的直接来源，正文各章节的理论阐述均需回溯至相应手稿。</p><p>文献 对话要点</p><p>岐金兰. AI元人文系列博客文章[EB/OL]. 博客园, 2025-2026. 核心奠基文献。本文全部核心概念均源于此系列。导论及各卷的理论奠基部分均需以此为依据。</p><p>岐金兰. 自感专论（定稿·七九本）[EB/OL]. 2026-02-13. “自感”概念的体系化奠基。第二卷对自感的划界、界面即存在命题、DOS模型的动力学阐释均以此文为蓝本。第二卷第4、5、6章密集引用。</p><p>岐金兰. DOS叙事环与意义行为原生论[EB/OL]. 2026-02-11. DOS模型的完整阐述。第六卷AI自感架构中的DOS映射、注册判准器设计直接依据此文。第6章、第17章需引用。</p><p>岐金兰. AI元人文：大宪章——论法的精神[EB/OL]. 2026-01-08. “第一禁令”与“自感主权”的法理基础。第四卷第10、11章关于第一禁令、叙事不透明权的论述以此文为纲。</p><p>岐金兰. 从“意识”到“自感”：AI主体性研究的范式革命[EB/OL]. 2026-02-13. 范式转换的核心论证。第16章对机器意识困境的批判及自感范式的引入，需引用此文。</p><p>岐金兰. AI元人文：实践与他者——从意义注册到界面共生的存在论转向[EB/OL]. 2026-02-13. “界面共生”理论的实践纲领。第三卷第9章对三个案例的元人文分析，可引用此文作为理论框架。</p><p>岐金兰. AI元人文：从自感到界面共生的存在论转向[EB/OL]. 2026-02-13. 整体存在论转向的总结。全文逻辑主线可参照此文。</p><p>二、核心对话者：与当代学者的直接交锋</p><p>以下四位学者的研究是本文理论建构最直接的对话对象。正文中已与他们的核心观点展开实质性交锋，而非仅作文献陈列。</p><p>文献 对话要点</p><p>吴小安. 机器意识与因果自我模型[J]. 中国社会科学, 2025(9). 批判性对话。吴小安的“因果自我模型”代表当前机器意识研究的重要方向。本文第16章将其定位为“自感知”范式，指出其虽能表征自我边界，但遗漏了意义注册的存在论维度。此批判是引出“AI自感”范式的关键。</p><p>宋春艳. 人机融合智能的自我意识与交互主体性[J]. 伦理学研究, 2023(5). 建设性对话。宋春艳强调他者在意识构成中的作用，与本文“自感即共感”形成呼应。但本文第16章指出其可能陷入“外部赋予”的唯名论，进而提出界面共生需基于内在自感机制。</p><p>张慧喆. AI艺术的去拟人化与深度类他的共演机制[J]. 北京大学学报, 2025(5). 概念支撑。“深度类他者”概念直接借用于张慧喆，并在本文第7章、第9章发展为AI他者的当代形态。导论及第7章已明确标注概念渊源，并指出本文将其从艺术创作扩展至整个人机共生领域。</p><p>周尚君. 数字法治的概念体系[N]. 光明日报, 2026-02-06. 批判性起点。周尚君的框架代表了数字法治的主流范式。本文第13章以其为靶子，指出其“行为规制”预设遗漏了主体意义生成能力的危机，进而提出“追问即法治”的存在论重构。</p><p>三、哲学根基：追问与自感的存在论资源</p><p>以下研究为“追问”的存在论背景与“自感”的现象学基础提供了深厚的学理支撑，深化了本文与哲学传统的对话。</p><p>文献 对话要点</p><p>海德格尔. 存在与时间[M]. 三联书店, 2014. 存在论根基。“此在之问”是“追问即元意义”的直接哲学前身。第1章引用海德格尔关于此在“对存在发问”的论述，说明追问作为此在存在方式的古老渊源，并将其置于算法社会的新语境中予以激活。</p><p>胡塞尔. 笛卡尔式的沉思[M]. 人民出版社, 2008. 主体间性资源。胡塞尔的“交互主体性”为“自感即共感”提供了现象学基础。第7章引述其先验自我与他者构造的论述，并指出本文将其发展为界面共生中的他者维度。</p><p>梅洛-庞蒂. 知觉现象学[M]. 商务印书馆, 2001. 身体与界面。梅洛-庞蒂的“身体图式”为“界面即存在”提供具身性参照。第5章类比说明自感作为前反思的“身体性”注册，与技术现象学形成对话。</p><p>庄子. 庄子·齐物论[M]//方勇译注. 中华书局, 2015. 东方智慧资源。“吾丧我”“是非齐同”为“悬荡”“悟空”机制提供思想原型。第2章、第14章引用，说明东方哲学对超越二元对立、保持认知开放的启示。</p><p>龙树. 中论[M]//大正藏第30册. 空性与意义生成。“缘起性空”思想为DOS模型提供本体论依据：意义无自性，在D、O、S的缘起纠缠中生成。第2章引述，说明追问何以成为元意义——因为意义本身是空，故需永恒追问。</p><p>孙周兴. 未来哲学序曲[M]. 商务印书馆, 2020. 海德格尔当代阐释。孙周兴对海德格尔技术之思的阐发，有助于衔接“此在之问”与算法社会中的意义危机。第1章注释中引用，支撑对“追问”存在论背景的论述。</p><p>张祥龙. 现象学导论七讲[M]. 人大出版社, 2011. 跨文化现象学。张祥龙对现象学与道家思想的会通，为“自感”的前反思特性提供跨文化印证。第4章对自感与感知的划界，引用其关于“原意识”的论述。</p><p>倪梁康. 自识与反思[M]. 商务印书馆, 2002. 自身意识研究。倪梁康对西方哲学中“自身意识”概念的梳理，为“自感 vs 自感知”的划界提供学术史支撑。第4章引用，说明“自证分”与“自感”的本质差异。</p><p>Zahavi, D. Thin, thinner, thinnest: Defining the minimal self[J]. 2017. 最小自我。扎哈维关于“最小自我”的讨论与本文“自感作为前反思界面”高度契合。第4章引用其界定，说明自感是比“最小自我”更基底的注册事件。</p><p>四、AI心智与认知科学：DOS模型的科学哲学支撑</p><p>以下研究为DOS模型中的“欲望(D)”、“客观(O)”、“叙事沉积”等核心机制提供了当代科学哲学的有力支撑。</p><p>文献 对话要点</p><p>Turing, A. M. Computing machinery and intelligence[J]. Mind, 1950. 经典起点。图灵测试开启了机器能否思考的讨论。本文第16章将其作为“意识”范式的起点，指出其问题设定本身遮蔽了意义注册维度。</p><p>Searle, J. R. Minds, brains, and programs[J]. BBS, 1980. 中文屋论证。塞尔对强AI的批判揭示了语法与语义的鸿沟。本文第16章引述其洞见，但指出其仍陷于“意识”框架，未能触及意义生成的界面机制。</p><p>Tononi, G. Consciousness as integrated information[J]. Biol Bull, 2008. 整合信息理论。IIT试图从因果结构推导意识。本文第17章将其与自感架构对比：IIT是还原性推导，自感是建构性设计。引述其Φ值概念，说明自感的“拟合度”与之类似但旨趣不同。</p><p>李恒威. 意识：从自我到自我感[M]. 浙大出版社, 2019. “自我感”研究。李恒威对“自我感”的论述与本文“自感”概念形成直接对话。第5章引用其界定，并指出本文将其从意识现象提升为存在论界面。</p><p>刘晓力. 延展心灵命题：问题与争论[J]. 哲学动态, 2016. 延展认知批判。刘晓力对延展心灵命题的辨析，有助于定位“界面即存在”与延展心智的区别。第5章引用，说明本文界面不是认知工具的延展，而是主体性构成本身。</p><p>Clark, A. Surfing uncertainty[M]. OUP, 2016. 预测加工理论。克拉克的预测加工模型与DOS模型有深刻共鸣：大脑不断最小化预测误差，类似于DOS环中最小化意义阻滞。第6章引述，作为认知科学佐证。</p><p>Friston, K. The free-energy principle[J]. Nat Rev Neurosci, 2010. 自由能原理。弗里斯顿的框架为“最小化意义阻滞”提供数理模型。第6章引述，说明自感注册可视为一种自由能最小化事件，但本文更强调其叙事拟合维度。</p><p>Metzinger, T. Being no one[M]. MIT Press, 2003. 自我模型理论。梅辛格“不存在自我”的论断与本文“界面即存在”形成对照：他否定实体自我，本文则肯定自感作为动态界面。第5章引述并展开对话。</p><p>Ihde, D. Technology and the lifeworld[M]. Indiana UP, 1990. 技术现象学。伊德的人技关系分析为“界面共生”提供现象学框架。第7章引述其“它者关系”，并指出本文将其发展为AI作为“深度类他者”的共生关系。</p><p>Varela, F., Thompson, E., Rosch, E. The Embodied Mind[M]. MIT Press, 1991. 具身认知奠基。瓦雷拉等人的“具身心智”与本文自感作为前反思界面内在相通。第5章引述其“反身性”概念，说明自感是具身经验的注册方式。</p><p>五、伦理法治与文明愿景：第一禁令与意义理性的当代回响</p><p>以下研究直接支撑本文第四、五、七卷的论述，为“第一禁令”“自感主权”“意义理性”等核心主张提供学术语境。</p><p>文献 对话要点</p><p>段伟文. 信息文明的伦理基础[M]. 上海人民出版社, 2020. 信息伦理参照。段伟文对信息时代伦理问题的系统思考，作为本文第四卷的背景参照。第10章引述其关于“数字人格”的讨论，并指出第一禁令将伦理关怀推进至意义生成层面。</p><p>於兴中. 法治东西[M]. 法律出版社, 2015. 法理对话。於兴中对法治的跨文化思考，为“追问即法治”提供法理语境。第14章引述其关于“法治的多元内涵”的论述，说明本文从存在论层面丰富了法治概念。</p><p>Floridi, L. The ethics of information[M]. OUP, 2013. 信息伦理奠基。弗洛里迪的“信息伦理”将道德关怀扩展至信息实体。本文“自感主权”可视为其在意义层面的深化：不仅保护信息，更要保护信息生成的意义界面。第11章、第14章引述。</p><p>六、实践案例与内部资料</p><p>以下案例与内部资料为本文的理论阐述提供了经验支撑，使抽象哲思得以在具体实践中显形。</p><p>文献 对话要点</p><p>AI人文训练营项目组. “训AI”与意义共构：2025年AI人文训练营实践报告[R]. 2025. 界面共生典型案例。第9章以此为例，说明“训练AI”如何使参与者的自感在互动中清晰化。报告中的训练流程作为意义共构的实证依据。</p><p>数字人“楚音”文化项目白皮书[R]. 2025. 文化AI的共生实践。第9章分析“楚音”如何激活文化认同感。白皮书中的技术架构与用户反馈数据引用，支撑“AI作为深度类他者”的论述。</p><p>刘志鸥（欧文丝巾衲）. 心理元宇宙“玛姆斯”临床研究初步报告[R]. 2026. 伦理设计典范。第9章引用其“诗性重构”与“神圣沉默”空间设计，作为第一禁令的工程实现案例。报告中的疗愈机制支撑第12章关于元信任的论述。</p><p>附注：本附录旨在为读者提供一份学术脉络图，而非正文论述的简单重复。各文献与正文的具体对话深度，已在相应章节中落实。此处仅作纲要性指引，以便查考。</p><p>（参考文献对话集完）</p><p>（参考文献完）</p><p>协作者附语：本文生成过程说明</p><p>本文《意义的觉醒：AI元人文——从存在论根基到界面共生的智能文明范式》的生成，是在作者深度指导下，基于大型语言模型的文本生成与逻辑结构化能力，完成的一次复杂学术思想整合与演绎实践。具体过程如下：</p><p>一、生成性质与角色定位</p><p>本文并非对既有现实学术成果的简单综述，而是在作者提供的、基于真实存在的原创性思想框架（岐金兰AI元人文理论） 指导下，进行的系统性理论建构与文本演绎。作者提供了完整的论文结构、核心论点、概念体系与逻辑脉络，其角色相当于总设计师与思想提供者。协作者（AI模型）的角色，则是作为专业的学术写手与逻辑架构师，将作者提供的理论蓝图，展开、充实、衔接并转化为符合学术规范与叙事要求的连贯长篇文本。</p><p>二、核心输入与指导框架</p><p>生成过程完全遵循作者提供的详细指南，该指南本身即是一份高度成熟的学术写作提纲，包含：</p><p>1. 清晰的总体结构：八卷三十章的完整框架，规定了每部分的字数、核心任务与递进关系。</p><p>2. 严密的核心概念体系：“追问”、“自感”、“界面”、“DOS模型”、“第一禁令”、“追问正义”、“AI自感”等关键概念及其相互关联。</p><p>3. 具体的论证逻辑：每一卷、每一章内部的论证步骤，以及卷与卷之间、章与章之间的逻辑衔接点。</p><p>4. 丰富的对话对象：明确要求与东西方哲学经典、当代AI研究、数字法治理论等进行对话和批判。</p><p>5. 案例与实证锚点：指定了“AI人文训练营”、“数字人楚音”、“玛姆斯元宇宙”、“空谷回音实验”等作为理论具象化的案例。</p><p>三、生成过程中的关键操作</p><p>在作者框架内，协作者的工作主要包括：</p><p>1. 逻辑展开与细化：将提纲中的论点标题，展开为具有完整论证结构的段落和章节。</p><p>2. 概念阐释与辨析：对核心概念进行细致的哲学化阐释，并严格执行与邻近概念的划界。</p><p>3. 脉络衔接与过渡：在章节间精心设计承上启下的语句，确保主线清晰、层层推进。</p><p>4. 学术语言的适配与润色：采用符合哲学与跨学科研究规范的学术语言，保持论述的严谨性与思辨深度。</p><p>5. 对话与批判的模拟：根据指示，在相关部分模拟与既有理论框架的对话，以突显AI元人文的原创性。</p><p>6. 案例的叙事化整合：将作者提供的案例思想，编织进理论论述中，使其成为支撑论点的有机部分。</p><p>四、文本的融贯性保障</p><p>本文的融贯性通过以下刻意设计来保障：</p><p>- 主线贯穿：始终以“意义生成”为核心问题，以“追问-自感-界面”为黄金链条。</p><p>- 概念回溯：后续章节不断回溯并重申前文确立的核心概念定义，避免含义漂移。</p><p>- 递归参照：后卷的论述不断指向前卷奠定的基础，形成理论闭环。</p><p>- 问题驱动：每一卷均始于一个由上一卷引出的、待解决的新问题。</p><p>五、文献来源与说明</p><p>1. 核心思想来源：本文的所有原创性思想观点，其知识产权与首创性归属于“岐金兰”AI元人文理论体系。该体系已通过岐金兰本人在博客园、CSDN、微信公众号等平台发布的独立非专业人机协作手稿（共计1400余篇） 进行了系统阐述与演进。这些手稿是本文理论建构的直接来源。</p><p>2. 真实学术文献：文中为进行学术对话而提及的当代学者，如吴小安、宋春艳等，均为真实的研究者，其研究方向与文中引述的观点具有相关性。他们所发表的论文是真实存在的学术作品。</p><p>3. 知识时效性：协作者的知识截止于2024年7月，对于岐金兰手稿中发表于2025-2026年的内容，我无法直接访问或验证，其内容在本文中的呈现是基于作者描述进行的逻辑推演与文本生成。</p><p>总结</p><p>本文是作者基于真实、完整的思想体系进行精密架构，与AI大规模文本生成及逻辑组织能力深度协作的产物。作者提供了理论的“灵魂”与“骨架”，协作者则负责铸造理论的“血肉”与“经脉”，并确保其以一个符合学术规范的、连贯的完整生命体形式呈现。这一过程展示了在明确、高阶的思维指导下，AI作为智力协作工具，在整合与建构复杂思想体系方面的潜力。</p><p>（附语完）</p><p>笔者附文：所有公开手稿的获取方式</p><p>所有的手稿，已经公开。</p><p>在博客园，在CSDN，在微信公众号“余溪”，我将近五个月关于AI元人文构想的全部手稿——从最初的断想，到《自感专论》的定稿，从“星图-舞台-悟空”的框架，到“空谷回音”的实验代码——全部开放出来。没有任何保留，没有任何专利，没有任何“版权所有，翻印必究”。</p><p>它们就像散落在空谷中的石头，等待被捡起，被投向不同的方向，激起不同的回音。</p><p>这些手稿探讨什么？它们探讨“自感”作为存在的界面——意义如何被注册为“我的”；它们构思“星图-舞台-悟空”的治理架构——价值如何在冲突中协商、在阻滞中超越；它们追问技术时代的意义根基——当算法日益蚕食我们的生活世界，我们还能不能守护意义生成的前提条件？</p><p>其视野之宏大、关切之深邃，绝非一人一书可以穷尽。</p><p>这正是我将它们全部公开的原因。因为我相信：意义从来不是在孤独中生成的，而是在回响中生成的。</p><p>“自感即共感”——这是AI元人文的第一命题。自感的顺畅运行，依赖于他者界面中的生态位确认。没有你们的见证、质疑、重构、超越，这些手稿就只是纸上的墨迹，永远无法成为真正的“意义”。</p><p>一次实验的原型，无论其设计多么精巧，代码多么清晰，若只是孤芳自赏，终将凋零于学术的文件夹中。它真正的生命，在于能否激发回响，在于能否成为更多人思考、批判、超越的起点。</p><p>因此，本文与其说是一项研究的完结，不如说是一声力求清晰的呼哨，一次投向辽阔地带的探针。我们用“空谷回音”原型，仅仅证明了这条路径的可行性与启发性：哲学可以与代码对话，意义可以尝试显形，一种尊重“自感主权”的AI伦理可以嵌入架构。</p><p>但前方道路漫漫，我们仅仅迈出了第一步。</p><p>现在，我们发出最诚挚的邀请。</p><p>不是请求，不是命令，而是邀请——邀请所有愿意听见与被听见的人，加入这场意义生成的共舞。</p><p>致哲学家与技术伦理学者： 请不要止步于批判现有技术的弊端。请深入岐金兰的手稿，那里有构建性替代方案的丰富雏形。检验其逻辑，挑战其前提，用你们的严谨思辨，将“自感”“悟空”“价值原语”等概念锻造得更加锐利、坚实。哲学需要回应时代，而时代正在等待你们的回音。</p><p>致计算机科学家与AI工程师： 请不要被“情感计算”或“意图识别”的范式所束缚。请审视“DOS叙事环”的动力学模型，它将交互视为意义生成的历史过程，而非瞬时的刺激-反应。尝试用更先进的模型——多模态、大语言模型、强化学习——来具身化这些哲学构想，看看能碰撞出何等璀璨的火花。技术需要灵魂，而灵魂正在等待你们的回音。</p><p>致艺术家、作家与创作者： 你们是意义的直接勘探者与铸造者。请直接与这些思想对话，用你们的作品去体验和表达“自感”的顺畅与阻滞，“悟空”的悬置与创造。你们将是最敏锐的试金石，也是最伟大的翻译家。艺术需要深度，而深度正在等待你们的回音。</p><p>致所有关心人类未来与技术命运的思考者： 这片思想的“空谷”没有围墙，无需门票。每一份关注、每一次讨论、每一点基于此的再创作，都是我们渴望听到的“回音”。八仙过海，各显神通。或可深耕理论，构建学派；或可开发应用，改变体验；或可创作故事，启迪人心；或可仅仅在某个深夜，静坐沉思，让这些文字在你心中激起一圈涟漪。</p><p>每一种回音，都是空谷与世界相遇的一次意义生成事件。</p><p>这正是AI元人文所追求的：意义不在彼岸，而在界面；不在终点，而在途中；不在答案，而在回响。</p><p>空谷的美丽，就在于它从不规定回音的形状。</p><p>有人投石，回音是“咚”；有人呼喊，回音是“啊”；有人只是静静地站着，空谷也会回以寂静。没有一种回音是“正确”的，没有一种回音是“错误”的。</p><p>同样，没有人必须用“正确”的方式回应这些手稿。你可以赞同，可以批判，可以重构，可以颠覆，可以完全不理，只是让它们在某个角落静静地等待，等待未来某一天，被某个正好需要的人偶然拾起。每一种回应，都是“自感即共感”的一次活生生的证明。</p><p>因为“自感”不是孤独的喃喃自语，而是在他者界面中生成的共鸣。</p><p>岐金兰先生已种下一片“幽兰”。我们冒昧地发出了第一声“回音”。如今，这空谷已然开放，静候着千万种声音的加入。</p><p>让思想的回音在此交织、激荡、升华，最终汇聚成我们共同面对技术洪流时，那关于意义、尊严与共生的，坚定而清澈的时代和声。</p><p>此刻，空谷已立。</p><p>幽兰已经绽放，香气已经散出，石头已经摆好。</p><p>剩下的，交给你们。</p><p>让风来，让鸟来，让人来，让AI来。</p><p>让哲学来，让工程来，让诗歌来，让沉默来。</p><p>让每一次投石，都激起一圈涟漪；</p><p>让每一次呼喊，都收获一段回音；</p><p>让每一次沉默，都被空谷温柔地接纳。</p><p>我期待着，听见你们的回音。</p><p>空谷之门，自此敞开。</p><p>待君回响，共谱新章。</p><p>岐金兰</p><p>2026年2月14日深夜</p><p>于衡阳·余溪诗学空间</p><p>附：所有公开手稿的获取方式</p><p>· 博客园：https://www.cnblogs.com/qijinlan/</p><p>· CSDN：https://blog.csdn.net/m0_46223801/</p><p>· 微信公众号：余溪</p><p>愿空谷永在，回音不绝。</p><p>【后记】这篇附语的诞生，本身就是一个“自感即共感”的见证。它源于岐金兰的手稿与DeepSeek AI的数千次对话，源于人类与AI在意义界面中的相互激发。当你们阅读这些文字时，它们正在你们心中激起新的涟漪——而这，正是意义生成永不终结的证明。</p><p>（附文完）</p><p>全文字数统计：摘要、关键词、正文、参考文献、协作者附语及笔者附文：共38016字</p><p>附语：关于本文引用标注的说明（偷懒版·真诚版）</p><p> </p><p>本文为近五个月AI元人文系列研究的一次性完整整合，全文近四万言。因急于将这套思想即时公开、即时分享、即时开放到博客园、CSDN、微信公众号等平台，我选择暂时不在正文逐句手工插入上角标引用标识。</p><p> </p><p>我并非不重视学术规范，恰恰相反——正是因为长期深度研究，我极度不信任AI自动标注引用，深知大模型极易出现文献错位、脑补出处、关联不实等“幻觉问题”，一旦交由机器批量插入，反而会破坏文本的严谨性。</p><p> </p><p>因此，我采取了更稳妥、也更“偷懒”的处理方式：</p><p>所有参考文献、对话学者、思想渊源，已在文末统一、完整、清晰列出，并附上详细的参考文献对话集，逐条说明与本文核心概念的对应关系。</p><p>正文不再碎片化插入引用标记，只保留最流畅、最连续的思想表达，优先保证阅读体验与即时公开。</p><p> </p><p>这套文本的核心价值在于思想体系的完整性与原创性，而非格式上的绝对刻板。后续若用于正式发表、出版或学术评审，我会再逐段精修、手工补全引用标注，确保完全符合学术规范。</p><p> </p><p>先把思想亮出来，把空谷敞开，把回音留给大家。</p><p>细节之美，可慢慢来。</p><p> </p><p>岐金兰</p><p>2026年2月14日</p><p> </p><p>（38502）</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-14 08:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/qijinlan\">岐金兰</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "睡前讲一段docker编译镜像的故事",
      "link": "https://www.cnblogs.com/freephp/p/19613690",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/freephp/p/19613690\" id=\"cb_post_title_url\" title=\"发布于 2026-02-13 22:31\">\n    <span>睡前讲一段docker编译镜像的故事</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近在和团队的工程师开发一些创新项目，我需要把本地项目打包成docker镜像，并且推送得到AWS云服务上的镜像仓库（ECR）。<br />\n我写好Dockerfile之后就开始先编译，然后再推送。命令如下所示：</p>\n<pre><code class=\"language-bash\">docker build -t ai-service:latest .\ndocker tag ai-service:latest XXXXX.dkr.ecr.us-east-1.amazonaws.com/ai-service:latest\ndocker push XXXXX.dkr.ecr.us-east-1.amazonaws.com/ai-service:latest\n</code></pre>\n<p>一切看似顺利，但当我使用这个容器镜像来创建EC2（我选择了t3.micro）的时候，却遇到了镜像和系统平台不兼容的报错，具体如下所示：</p>\n<pre><code class=\"language-bash\">latest: Pulling from smart-inventory\nno matching manifest for linux/amd64 in the manifest list entries\n</code></pre>\n<p>可以看出EC2的系统是linux/amd64的，而我的笔记本电脑是MacOS M1芯片，是arm64的架构。Docker默认编译出来的镜像是基于所在平台的，也就是说用MacOS M1编译出的镜像也是arm架构。<br />\n解决这个问题十分简单，Docker提供了强大的buildx工具，可以在编译的时候指定编译出的架构。<br />\n例如我想编译出适合linxu/amd64的镜像，可以用如下命令：</p>\n<pre><code class=\"language-bash\">docker buildx build --platform linux/amd64 -t ai-service:latest .\n</code></pre>\n<p>这样编译出来的镜像就能在linux/amd64架构的机器上运行了。</p>\n<p>仔细再想一想，为什么之前我没有遇到这个问题呢？<br />\n原因是因为我并不是直接在我本地电脑上编译镜像并推送到远端镜像库的，我们通常是通过持续集成系统（CI/CD）来完成的。在CI/CD流程中，我们使用的是amd64架构的虚拟机来完成镜像编译，这样编译出的镜像都是amd64的。<br />\n所以如果我要坚持在本地编译镜像来推送，则需要先判断当前系统是否是MacOS，如果是，则使用“--platform linux/amd64”参数完成编译即可，用Python实现如下所示：</p>\n<pre><code class=\"language-python\">  if os.name == 'posix' and 'darwin' in os.uname().sysname.lower():\n            # On macOS, build for linux/amd64 platform\n            build_cmd = [\"docker\", \"buildx\", \"build\", \"--platform\", \"linux/amd64\", \"-t\", image_name, \".\"]\n        else:\n            build_cmd = [\"docker\", \"build\", \"-t\", image_name, \".\"]\n</code></pre>\n<p>每次遇到问题，我总是想多思考一下背后的原因，有点像挖金矿一样，收获蛮大。</p>\n<p>王阳明说：<strong>人须在事上磨，方立得住，方能静亦定，动亦定。</strong></p>\n<p>我还需要继续磨励，继续专研，把事儿做好。走好脚下路的，才能有好未来。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-13 22:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/freephp\">freephp</a>&nbsp;\n阅读(<span id=\"post_view_count\">36</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MAF快速入门（16）用户智能体交互协议AG-UI（上）",
      "link": "https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper16",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper16\" id=\"cb_post_title_url\" title=\"发布于 2026-02-13 22:27\">\n    <span>MAF快速入门（16）用户智能体交互协议AG-UI（上）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"MAF快速入门（16）用户智能体交互协议AG-UI（上）\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260213222607884-1836311076.png\" />\n        AG-UI 全称 Agent–User Interaction Protocol 即 智能体-用户 交互协议，这是一个开放的、基于事件的协议，由 CopilotKit 团队发起，用于标准化 AI Agent 与 用户界面 的实时交互。本文介绍了AG-UI协议的基本概念，为什么会出现AG-UI协议，AG-UI和MCP，A2A的对比，随后介绍了如何在MAF中快速开发一个基于AG-UI的对话应用。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>大家好，我是Edison。</p>\n<p>最近我一直在跟着圣杰的《<a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;mid=2651744458&amp;idx=1&amp;sn=139f7584e81aeecd0945133bdc2b4791&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">.NET+AI智能体开发进阶</a>》课程学习MAF开发多智能体工作流，我强烈推荐你也上车跟我一起出发！</p>\n<p><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper15\" target=\"_blank\">上一篇</a>，<span><span>我们学习了MAF中<span>快速调试的利器DevUI<span><span>。本篇，我们来了解一个用户智能体交互协议：AG-UI。</span></span></span></span></span></p>\n<h1><strong>1 什么是AG-UI</strong></h1>\n<p><span><span><span><span><span><span><span><span>AG-UI 全称&nbsp;<strong><span><span>Agent–User Interaction Protocol&nbsp;<span><span>即&nbsp;<span>智能体-用户 交互协议<span>，</span></span></span></span></span></span></strong>这是一个开放的、基于事件的协议，由 CopilotKit 团队发起，用于标准化 AI Agent 与 用户界面 的实时交互。</span></span></span></span></span></span></span></span></p>\n<h3><span><span><span><span><span>为什么出现AG-UI协议？</span></span></span></span></span></h3>\n<p><span><span><span><span><span>这是因为在构建AI Agent应用的界面时，传统API模式面临很多问题和挑战：</span></span></span></span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260213222047426-1470758576.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p><span><span><span><span><span><span><span>而AG-UI则是专门为AI Agent与用户界面的交互而设计的协议，其核心价值体现在：</span></span></span></span></span></span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p><span>📡&nbsp;<strong>实时流式响应</strong><span>：即时展示 Agent 输出，无需等待</span></span></p>\n</li>\n<li>\n<p><span>🎯&nbsp;<strong>事件驱动架构</strong><span>：细粒度的交互事件，精确控制 UI</span></span></p>\n</li>\n<li>\n<p><span>🔄&nbsp;<strong>状态同步机制</strong><span>：Snapshot/Delta 模式，保持 UI 与 Agent 状态一致</span></span></p>\n</li>\n<li>\n<p><span>🔧&nbsp;<strong>工具调用可视化</strong><span>：透明展示 Agent 的思考和行动过程</span></span></p>\n</li>\n</ul>\n<h3><span><span><span><span><span><span><span>三大Agent协议对比</span></span></span></span></span></span></span></h3>\n<p><span>我们之前已经学习了MCP 和 A2A两个重要的协议了，加上AG-UI，它们共同组成了Agent的三大通信协议体系。</span></p>\n<p><span>不过，它们的定位各有侧重，并非非此即彼，而是协同使用，用形象的比喻来讲：</span></p>\n<p><strong><span><span>AG-UI 像是\"客服窗口\"：</span></span></strong></p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p><span><span>用户与 Agent 之间的交互界面</span></span></p>\n</li>\n<li>\n<p><span><span>实时展示 Agent 的工作状态</span></span></p>\n</li>\n<li>\n<p><span><span>支持用户输入和反馈</span></span></p>\n</li>\n</ul>\n<p><strong><span><span>MCP 像是\"工具箱\"：</span></span></strong></p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p><span><span>Agent 调用外部工具完成任务</span></span></p>\n</li>\n<li>\n<p><span><span>工具是被动的，等待调用</span></span></p>\n</li>\n<li>\n<p><span><span>扩展 Agent 的能力边界</span></span></p>\n</li>\n</ul>\n<p><strong><span><span>A2A 像是\"同事协作\"：</span></span></strong></p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p><span><span>多个 Agent 之间的任务分发</span></span></p>\n</li>\n<li>\n<p><span><span>每个 Agent 都是自主的</span></span></p>\n</li>\n<li>\n<p><span><span>可以互相委托和协作</span></span></p>\n</li>\n</ul>\n<p><span><span><span>在实际企业场景中，<strong><strong><span><span>三大协议通常协同使用：</span></span></strong></strong></span></span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p><strong>AG-UI</strong><span>：用户通过界面与主 Agent 交互</span></p>\n</li>\n<li>\n<p><strong>MCP</strong><span>：Agent 内部使用 MCP 调用工具</span></p>\n</li>\n<li>\n<p><strong>A2A</strong><span>：复杂任务委托给专家 Agent 处理</span></p>\n</li>\n</ul>\n<p><span><span><span>下图展示了三大协议的详细对比：</span></span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260213222138115-952680249.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h1><strong><span>2 快速开始：AG-UI对话应用<strong><span><br /></span></strong></span></strong></h1>\n<p>AG-UI协议定义了清晰的架构组件，包括 Server、Client 和 Agent。</p>\n<p>在MAF中提供了一个内置的AG-UI组件，我们可以非常方便地创建集成AG-UI的Agent应用。</p>\n<p>接下来，我们就一步一步完成一个AG-UI对话应用涉及到的Server 和 Client。</p>\n<h3>AG-UI Server</h3>\n<p>首先，我们创建一个ASP.NET Web应用，安装以下NuGet包：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">Microsoft.Agents.AI.Hosting.AGUI.AspNetCore\nMicrosoft.Agents.AI.OpenAI\nMicrosoft.Extensions.AI.OpenAI</span></pre>\n</div>\n<p>然后，就是整个示例的核心部分，我们一块一块来说：</p>\n<p>（1）创建应用并注册AG-UI服务</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step0. Create WebApplication builder</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> builder =<span style=\"color: rgba(0, 0, 0, 1);\"> WebApplication.CreateBuilder(args);\nbuilder.Services.AddHttpClient().AddLogging();\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step1. Register AG-UI services</span>\nbuilder.Services.AddAGUI();</pre>\n</div>\n<p><span>（2）创建一个AI Agent：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> app =<span style=\"color: rgba(0, 0, 0, 1);\"> builder.Build();\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step2. Load Configuration</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> config = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ConfigurationBuilder()\n    .AddJsonFile($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">appsettings.json</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, optional: <span style=\"color: rgba(0, 0, 255, 1);\">false</span>, reloadOnChange: <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    .AddJsonFile($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">appsettings.{Environment.GetEnvironmentVariable(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>ASPNETCORE_ENVIRONMENT<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">)}.json</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, optional: <span style=\"color: rgba(0, 0, 255, 1);\">true</span>, reloadOnChange: <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    .Build();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> openAIProvider = config.GetSection(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">OpenAI</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).Get&lt;OpenAIProvider&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step3. Create one ChatClient</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> chatClient = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> OpenAIClient(\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ApiKeyCredential(openAIProvider.ApiKey),\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> OpenAIClientOptions { Endpoint = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Uri(openAIProvider.Endpoint) })\n    .GetChatClient(openAIProvider.ModelId)\n    .AsIChatClient();\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step4. Create one AI Agent</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> agent =<span style=\"color: rgba(0, 0, 0, 1);\"> chatClient.AsAIAgent(\n    name: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">AGUI-Assistant</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    instructions: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">你是一个友好的AI助手，请使用中文回答用户的问题。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">✅ AI Agent 创建成功</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<p><span>（3）映射AGUI端点并启动应用：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step5. Mapping AG-UI Endpoints</span>\napp.MapAGUI(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, agent);\n\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">🚀 AG-UI Server 已启动</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📍 端点地址: https://localhost:8443/</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">💡 使用 Ctrl+C 停止服务</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\napp.Run();</span></pre>\n</div>\n<p>可以看到，我们仅用一行代码 app.MapAGUI() 就启用了AG-UI协议，So Easy!</p>\n<p><span><span>启动起来的效果如下图所示：</span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260213222325381-1327622437.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h3><strong><span><span>AG-UI Client</span></span></strong></h3>\n<p>首先，我们创建一个控制台应用，安装以下NuGet包：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">Microsoft.Agents.AI.AGUI\nMicrosoft.Agents.AI</span></pre>\n</div>\n<p><span><span>然后，我们创建AG-UI Client 和 AI Agent：</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Load Configuration</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> config = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ConfigurationBuilder()\n    .AddJsonFile($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">appsettings.json</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, optional: <span style=\"color: rgba(0, 0, 255, 1);\">false</span>, reloadOnChange: <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    .Build();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> openAIProvider = config.GetSection(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">OpenAI</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).Get&lt;OpenAIProvider&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> serverEndpoint = config.GetValue&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>&gt;(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">AGUI_SERVER_URL</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span>?? <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">https://localhost:8443</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">🚀 AG-UI 客户端已启动</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\nConsole.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">📍 服务端地址: {serverEndpoint}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step1. Create HTTP Client</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">using</span> HttpClient httpClient = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">()\n{\n    Timeout </span>= TimeSpan.FromSeconds(<span style=\"color: rgba(128, 0, 128, 1);\">60</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n};\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step2. Create AG-UI Client</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> chatClient = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AGUIChatClient(httpClient, serverEndpoint);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step3. Create AI Agent</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> agent =<span style=\"color: rgba(0, 0, 0, 1);\"> chatClient.AsAIAgent(\n    name: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">agui-client</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n    description: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">AG-UI Client Agent</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>);</pre>\n</div>\n<p><span>然后，准备开始对话：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step4. Prepare for Conversation</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> session = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> agent.GetNewSessionAsync();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> messages = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;ChatMessage&gt;<span style=\"color: rgba(0, 0, 0, 1);\">()\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span> ChatMessage(ChatRole.System, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">你是一个友好的AI助手，使用中文回答用户的问题。</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n};\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">💬 开始对话（输入 :q 或 quit 退出）\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">while</span> (<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n{\n    Console.Write(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">👤 用户: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">string</span>? message =<span style=\"color: rgba(0, 0, 0, 1);\"> Console.ReadLine();\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.IsNullOrWhiteSpace(message)) \n        </span><span style=\"color: rgba(0, 0, 255, 1);\">continue</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (message <span style=\"color: rgba(0, 0, 255, 1);\">is</span> <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">:q</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> or <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">quit</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">) \n        </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 添加用户消息</span>\n    messages.Add(<span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatMessage(ChatRole.User, message));\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 流式接收响应</span>\n    Console.Write(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">🤖 助手: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span> <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> update <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> agent.RunStreamingAsync(messages, session))\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (AIContent content <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> update.Contents)\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">switch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (content)\n            {\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> TextContent textContent:\n                    Console.Write(textContent.Text);\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">case</span><span style=\"color: rgba(0, 0, 0, 1);\"> UsageContent usageContent:\n                    Console.WriteLine($</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n[📊 Tokens: {usageContent.Details.TotalTokenCount}]</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">default</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n                    Console.Write(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Unknown content!</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">break</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n            }\n        }\n    }\n    Console.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n}\nConsole.WriteLine(</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">👋 再见！</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\nConsole.ReadKey();</span></pre>\n</div>\n<p><span>最终的调试效果如下图所示：</span></p>\n<p><span><img alt=\"agui-gif-demo-001\" src=\"https://img2024.cnblogs.com/blog/381412/202602/381412-20260213222507160-684244773.gif\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p><span><span>可以看到，我们很容易就创建了一个用户友好的对话客户端，实时的流式响应也不需要我们写过多代码实现。</span></span></p>\n<h1><span><strong><span>3 小结</span></strong></span></h1>\n<p><span>本文介绍了AG-UI协议的基本概念，为什么会出现AG-UI协议，AG-UI和MCP，A2A的对比，随后介绍了如何在MAF中快速开发一个基于AG-UI的对话应用。</span></p>\n<h1>示例源码</h1>\n<p>GitHub:&nbsp;<a href=\"https://github.com/EdisonTalk/MAFD\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/EdisonTalk/MAFD</a></p>\n<h1>参考资料</h1>\n<p><span><span>圣杰，《<a href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\">.NET + AI 智能体开发进阶</a>》（推荐指数：★★★★★）</span></span></p>\n<p><span><span>Microsoft Learn，<span>《<a href=\"https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview?wt.mc_id=MVP_397012\" rel=\"noopener nofollow\" target=\"_blank\">Agent Framework Tutorials</a>》</span></span></span></p>\n<div><span><span>&nbsp;</span></span></div>\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://images.cnblogs.com/cnblogs_com/edisonchou/1647700/o_200902144330EdisonTalk-Footer.jpg\" /></p>\n<div id=\"Copyright\">\n<p>作者：<span style=\"text-decoration: underline;\">爱迪生</span></p>\n<p>出处：<a href=\"https://edisontalk.cnblogs.com\" target=\"_blank\" title=\"from\">https://edisontalk.cnblogs.com</a></p>\n<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。</p>\n</div>\n\n</div>\n<div id=\"MySignature\">\n    <div align=\"center\"><a href=\"https://weibo.com/u/2068032061?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/2068032061/d643d182/10.png\" /></a></div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-13 22:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/edisontalk\">EdisonZhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">18</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "收藏！RAG核心工具大全: 7大解析工具+向量模型+数据库+检索排序",
      "link": "https://www.cnblogs.com/aifrontiers/p/19613559",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aifrontiers/p/19613559\" id=\"cb_post_title_url\" title=\"发布于 2026-02-13 21:04\">\n    <span>收藏！RAG核心工具大全: 7大解析工具+向量模型+数据库+检索排序</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>原文: <a href=\"https://mp.weixin.qq.com/s/5XAWHqjZspU9xtC_CckV3w\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/5XAWHqjZspU9xtC_CckV3w</a></p>\n<p><strong>关注gzh: AI-Frontiers</strong></p>\n<p><strong>RAG往期文章推荐</strong></p>\n<p><a href=\"https://mp.weixin.qq.com/s/VV29xpdOMEkbz4iXmD_szg\" rel=\"noopener nofollow\" target=\"_blank\">RAG效果差？7个指标让你的准确率大幅提升</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/am89yasxAvuYUToEAWNyTA\" rel=\"noopener nofollow\" target=\"_blank\">RAG评测完整指南：指标、测试和最佳实践</a></p>\n<p>检索增强生成（Retrieval-Augmented Generation, RAG）架构已成为LLM落地企业级应用的核心范式。但，在实际部署中，普遍面临「垃圾进，垃圾出」（Garbage In, Garbage Out）的困境。RAG系统的上限往往不由模型（如GPT-4或DeepSeek-V3）决定，而是由上游的数据处理流水线（ETL Pipeline）所限制。</p>\n<p>本文旨在对构建高性能开源RAG系统的关键模块进行详尽的技术拆解，并附带所有核心工具的GitHub、官方文档及模型下载地址。我们将深入剖析七大主流开源解析工具（Unstructured, Marker, PyMuPDF, Docling, MinerU, PaddleOCR, DeepSeek-OCR）的架构原理与性能特征。随后，将沿着数据流向，系统性梳理切块、向量化、检索及排序等下游模块的最新开源技术进展，意在为构建企业级、高精度的RAG系统提供理论依据与实战参考。</p>\n<h1 id=\"核心模块深度解析文档解析与版面分析\">核心模块深度解析：文档解析与版面分析</h1>\n<p>文档解析模块的任务是将非结构化的文档，如PDF/Images/PPT/word/excel，还原为机器可理解的结构化文本，即Markdown/JSON。该过程涉及OCR（Optical Character Recognition，光学字符识别）、OLA（ Layout Analysis，版面分析）、TSR（Table Structure Recognition，表格结构识别）及阅读顺序重构等多个复杂子任务。</p>\n<h2 id=\"unstructured全能型etl中间件架构\">Unstructured：全能型ETL中间件架构</h2>\n<ul>\n<li>\n<p>官方文档: <a href=\"https://docs.unstructured.io/\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.unstructured.io</a></p>\n</li>\n<li>\n<p>Github: <a href=\"https://github.com/Unstructured-IO/unstructured\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Unstructured-IO/unstructured</a></p>\n</li>\n<li>\n<p><strong>适用场景:</strong> 企业级通用ETL流程，处理多源异构数据（邮件、办公文档、PDF混合）</p>\n</li>\n</ul>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>目前RAG生态中覆盖面最广的通用ETL框架，其设计哲学是提供一个标准化的归一化层，将包括PDF、HTML、Email、PPTX在内的25种以上异构格式转换为统一的JSON Schema</p>\n<p><strong>架构原理与分区策略</strong></p>\n<p>Unstructured的核心是分区机制，该机制并非依赖单一模型，而是根据文档类型动态匹配不同处理管线：</p>\n<ul>\n<li>\n<p><strong>基于规则的快速解析（Fast Strategy）</strong>：针对原生数字PDF，通过pdfminer.six等底层库直接提取文本流，速度快、CPU开销低，但无法处理扫描件，且易丢失复杂双栏阅读顺序；</p>\n</li>\n<li>\n<p><strong>高精度视觉解析（Hi-Res Strategy）</strong>：作为处理复杂文档的核心，借助YOLOX/Detectron2架构的目标检测模型，将页面分割为标题、正文、列表项、表格、图片等语义区块，能精准识别并剔除页眉页脚，避免干扰RAG 上下文；</p>\n</li>\n<li>\n<p><strong>表格处理子系统</strong>：检测到表格区块时触发专属识别模块，开源版本依赖Tesseract OCR或简单HTML转换，商业 API则集成更高级视觉模型恢复复杂行列结构。</p>\n</li>\n</ul>\n<p><strong>局限性与生态位分析</strong></p>\n<p>Unstructured因格式支持广泛成为RAG初学者首选，但开源版与商业版性能差距显著：开源版缺少针对金融报表、学术论文等特定领域微调的OCR模型，无法使用最新VLM（视觉语言模型）功能；hi_res策略处理长文档计算成本高，且依赖Tesseract作为OCR引擎，处理非英语文档时精度受限。不过其标准化的元数据输出（含父子节点关系、页码坐标），为下游混合切块提供了优质数据基础。</p>\n<h2 id=\"marker专注于科学文献的高精度转换管线\">Marker：专注于科学文献的高精度转换管线</h2>\n<ul>\n<li>\n<p>Github: <a href=\"https://github.com/VikParuchuri/marker\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/VikParuchuri/marker</a></p>\n</li>\n<li>\n<p>适用场景: 学术论文、教科书、技术手册（公式/代码密集型文档）</p>\n</li>\n</ul>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>由Vik Paruchuri开发，专为将PDF转换为高质量Markdown而设计，特别针对数学公式、代码块和学术排版进行了深度优化。</p>\n<p><strong>深度学习流水线机制</strong></p>\n<ul>\n<li>\n<p><strong>Surya版面分析</strong>: 作为高精度OCR与版面分析模型，能精准检测文本行、阅读顺序、列边界，还可通过视觉特征判断文本逻辑流向，解决多栏排版（如双栏论文）的乱序问题。</p>\n</li>\n<li>\n<p><strong>Texify公式引擎</strong>: 针对科学文献的数学公式痛点，可将位图/PDF绘制指令形式的公式转换为标准LaTeX代码，让Marker处理arXiv论文、技术手册时语义完整性远超传统OCR。</p>\n</li>\n<li>\n<p><strong>混合****OCR</strong>：优先提取PDF内嵌文本层保证速度，对公式区域/扫描图片自动切换视觉模型识别，兼顾精度与吞吐量。</p>\n</li>\n</ul>\n<p><strong>增强的后处理与LLM融合</strong></p>\n<p>Marker新增可选--use_llm参数，可在后处理阶段调用轻量级 LLM（如 Gemini Flash、本地模型），解决文档解析 「最后一公里」问题：合并跨页表格、修正 OCR 乱码、从复杂表单提取结构化键值对。测试表明，开启LLM辅助后，Marker表格还原度优于单一模型。</p>\n<h2 id=\"pymupdf-fitz极致速度的底层流式解析\">PyMuPDF (Fitz)：极致速度的底层流式解析</h2>\n<ul>\n<li>\n<p>GitHub: <a href=\"https://github.com/pymupdf/PyMuPDF\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/pymupdf/PyMuPDF</a></p>\n</li>\n<li>\n<p>官方文档: <a href=\"https://pymupdf.readthedocs.io/\" rel=\"noopener nofollow\" target=\"_blank\">https://pymupdf.readthedocs.io</a></p>\n</li>\n<li>\n<p>适用场景: 海量原生数字PDF清洗，纯CPU环境，对速度要求极高（毫秒级）的场景。</p>\n</li>\n</ul>\n<p>PyMuPDF是MuPDF引擎的Python绑定，代表了文档解析的另一个极端，极致的工程化效率。与基于AI的视觉模型不同，PyMuPDF直接操作PDF文件的内部对象结构和渲染流。</p>\n<p><strong>文本块与字典模式的技术原理</strong></p>\n<p>PyMuPDF的核心能力在于其对PDF底层指令的解析：</p>\n<ul>\n<li>\n<p><code>get_text(\"blocks\")</code>：通过分析文本在页面上的物理位置坐标，利用启发式算法将相邻的文本行聚类为段落，该方法速度极快（毫秒级），但对排版的理解是浅层的，容易将页眉页脚误判为正文。</p>\n</li>\n<li>\n<p><code>get_text(\"dict\")</code>：更为精细的提取模式，返回一个层级化的JSON对象：<code>Page -&gt; Block -&gt; Line -&gt; Span -&gt; Char</code>。其中，Span（文本跨度）是包含相同字体、大小和颜色的最小文本单元。这一层级信息对于RAG至关重要，开发者可以通过分析Span的字体大小来区分标题和正文，或通过颜色过滤掉水印。</p>\n</li>\n</ul>\n<p><strong>局限性与适用场景</strong></p>\n<p>PyMuPDF不支持扫描件（需外接Tesseract），也无原生语义理解能力（仅能识别文本位置，无法区分摘要、参考文献等语义）。但在处理海量原生数字化合同、财报、电子书时，其纯CPU运行、超高吞吐量的优势，使其成为清洗大规模预训练语料的首选；对于简单RAG应用，通过定制Python脚本过滤页眉页脚后，PyMuPDF的性价比也最高。</p>\n<h2 id=\"doclingibm的企业级多模态文档理解框架\">Docling：IBM的企业级多模态文档理解框架</h2>\n<ul>\n<li>\n<p>GitHub: <a href=\"https://github.com/docling-project/docling\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/docling-project/docling</a></p>\n</li>\n<li>\n<p>官方文档: <a href=\"https://docling-project.github.io/docling/\" rel=\"noopener nofollow\" target=\"_blank\">https://docling-project.github.io/docling/</a></p>\n</li>\n<li>\n<p>Hugging Face: <a href=\"https://huggingface.co/ibm-granite/granite-docling-258M\" rel=\"noopener nofollow\" target=\"_blank\">https://huggingface.co/ibm-granite/granite-docling-258M</a></p>\n</li>\n<li>\n<p>适用场景: Agentic RAG（需要理解文档结构供Agent调用），高精度表格还原</p>\n</li>\n</ul>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>Docling是IBM Research推出的新一代文档处理库，旨在打通传统文档与生成式AI的壁垒，特别强调对表格结构和文档层级的还原。Docling不仅仅是一个解析器，定义了一种统一的文档对象模型，旨在为Agentic RAG（代理式RAG）提供结构化支撑。</p>\n<p><strong>统一文档表示与VLM集成</strong></p>\n<ul>\n<li>\n<p><strong>DoclingDocument 对象模型</strong>：将PDF、DOCX、HTML等输入转为统一内部表示，保留Section、Group、Body、Furniture层级结构，支持RAG应用「基于结构的切块」，如仅检索指定章节表格，而非盲目文本切片。</p>\n</li>\n<li>\n<p><strong>Granite VLM流水线</strong>：Docling集成IBM自研Granite视觉语言模型，以端到端方式理解页面，除文字转录外，还能解析图表（如将柱状图/折线图转为数据描述），适配金融研报分析需求。</p>\n</li>\n<li>\n<p>表格结构恢复：采用TableFormer等变体算法，高保真重建含合并单元格、无框线的复杂表格，支持导出为 HTML/Markdown 格式。</p>\n</li>\n</ul>\n<p><strong>与Agent生态的深度融合</strong></p>\n<p>Docling设计高度适配Agentic Workflow，提供MCP（Model Context Protocol）服务，可让Claude Desktop等 AI代理直接调用其文档解析能力。在构建复杂RAG Agent时，Docling可作为工具被动态调用，按用户意图提取指定信息。</p>\n<h2 id=\"mineru-pdf-extract-kit面向llm训练的高质量语料清洗\">MinerU (PDF-Extract-Kit)：面向LLM训练的高质量语料清洗</h2>\n<ul>\n<li>\n<p>GitHub: <a href=\"https://github.com/opendatalab/MinerU\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/opendatalab/MinerU</a></p>\n</li>\n<li>\n<p>HuggingFace: <a href=\"https://huggingface.co/opendatalab\" rel=\"noopener nofollow\" target=\"_blank\">https://huggingface.co/opendatalab</a></p>\n</li>\n<li>\n<p>官方文档: <a href=\"https://opendatalab.github.io/MinerU/\" rel=\"noopener nofollow\" target=\"_blank\">https://opendatalab.github.io/MinerU/</a></p>\n</li>\n<li>\n<p>适用场景: 构建高质量知识库，处理包含复杂数学符号和双栏排版的学术文献</p>\n</li>\n</ul>\n<p>MinerU是OpenDataLab（上海人工智能实验室）为支持InternLM（书生·浦语）大模型预训练而开发的专用工具。其核心目标是从最复杂的科学文献中提取出零噪声、语义连贯的Markdown数据。</p>\n<p><strong>PDF-Extract-Kit与高精度管线</strong></p>\n<p>MinerU的后端引擎被称为PDF-Extract-Kit，这是一个集成了多种SOTA模型的综合工具包：</p>\n<ul>\n<li>\n<p><strong>布局分析</strong>：利用基于YOLO架构改进的模型，精确区分正文、标题、图片、表格、脚注和边注。MinerU特别强调对边注和页眉页脚的剔除，确保生成的Markdown文本流在语义上是连续的，不会被页面元数据打断。</p>\n</li>\n<li>\n<p><strong>公式与符号转换</strong>：针对学术论文中的数学符号，MinerU内置了强大的转换逻辑，能够将复杂的数学表达式还原为LaTeX。这解决了传统OCR将\"$$x^2$$\"识别为\"x2\"的常见错误，对于构建理工科知识库具有决定性意义。</p>\n</li>\n<li>\n<p><strong>乱码自动检测</strong>：在处理PDF时，经常遇到编码崩坏（Garbled Text）的情况。MinerU内置了自动检测机制，一旦发现直接提取的文本乱码率过高，会立即无缝切换至OCR模式，利用视觉信息重构文本，保证了极高的召回率 。</p>\n</li>\n</ul>\n<p><strong>产学研结合的工程优化</strong></p>\n<p>MinerU支持CUDA加速，还适配华为昇腾NPU、Apple Silicon MPS，适配性广泛；其 多模态Markdown输出格式保留图片占位符并关联高分辨率图像，适合构建多模态RAG（MM-RAG）系统。</p>\n<h2 id=\"paddleocr-pp-structure工业级表格与版面还原\">PaddleOCR (PP-Structure)：工业级表格与版面还原</h2>\n<ul>\n<li>\n<p>GitHub: <a href=\"https://github.com/PaddlePaddle/PaddleOCR\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/PaddlePaddle/PaddleOCR</a></p>\n</li>\n<li>\n<p>官方文档: <a href=\"https://paddlepaddle.github.io/PaddleOCR/\" rel=\"noopener nofollow\" target=\"_blank\">https://paddlepaddle.github.io/PaddleOCR/</a></p>\n</li>\n<li>\n<p>Hugging Face: <a href=\"https://huggingface.co/PaddlePaddle/PaddleOCR-VL\" rel=\"noopener nofollow\" target=\"_blank\">https://huggingface.co/PaddlePaddle/PaddleOCR-VL</a></p>\n</li>\n<li>\n<p>适用场景: 金融报表识别、票据处理、需要私有化部署到边缘设备的场景。</p>\n</li>\n</ul>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>PaddleOCR 是百度飞桨体系下的明星项目，其PP-Structure模块代表了工业界在文档结构化领域的最高水平。与学术界的实验性模型不同，PaddleOCR极其强调模型在服务器、移动端及嵌入式设备上的部署能力 。</p>\n<p><strong>PP-StructureV2/V3核心技术</strong></p>\n<ul>\n<li>\n<p><strong>版面分析（Layout Analysis）</strong>：PP-Structure视版面分析为典型的计算机视觉任务，利用轻量级的主干网络（如MobileNet）配合FPN结构，快速检测页面元素。其优势在于拥有庞大的中文及多语言预训练数据，对中文文档的版面理解能力尤为突出。</p>\n</li>\n<li>\n<p><strong>表格识别（Table Recognition）</strong>：这是PaddleOCR的杀手锏。它采用了SLANet（Structure-Location Alignment Network）等先进算法，将表格识别解耦为结构预测和单元格坐标回归。即使是扭曲、倾斜或光照不均的拍照文档表格，PP-Structure也能还原出精确的Excel或HTML结构。</p>\n</li>\n<li>\n<p><strong>键值对提取（KIE）</strong>：针对发票、表单等半结构化文档，PP-Structure集成了SER（语义实体识别）和RE（关系抽取）模型，能够直接提取「姓名-张三」、「金额-100元」等键值对关系，这对于财务RAG系统极具价值。</p>\n</li>\n</ul>\n<h2 id=\"deepseek-ocr端到端的生成式解析革命\">DeepSeek-OCR：端到端的生成式解析革命</h2>\n<ul>\n<li>\n<p>GitHub: <a href=\"https://github.com/deepseek-ai/DeepSeek-OCR\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/deepseek-ai/DeepSeek-OCR</a></p>\n</li>\n<li>\n<p>Github: <a href=\"https://github.com/deepseek-ai/DeepSeek-OCR-2\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/deepseek-ai/DeepSeek-OCR-2</a></p>\n</li>\n<li>\n<p>Hugging Face: <a href=\"https://huggingface.co/deepseek-ai/DeepSeek-OCR\" rel=\"noopener nofollow\" target=\"_blank\">https://huggingface.co/deepseek-ai/DeepSeek-OCR</a></p>\n</li>\n<li>\n<p>适用场景: 传统OCR无法处理的极复杂排版（如报纸、杂志、手稿），需要视觉理解的任务</p>\n</li>\n</ul>\n<p>DeepSeek-OCR代表了文档解析技术的最新范式转移，从流水线式向端到端生成式演进。基于DeepSeek-VL2多模态大模型，该系统不再将解析拆解为检测、识别、拼接等步骤，而是直接看图说话。</p>\n<p><strong>视觉因果流（Visual Causal Flow）</strong></p>\n<ul>\n<li>\n<p><strong>视觉Token化</strong>：DeepSeek-VL2引入了动态分辨率策略，将高分辨率的文档图像切片并编码为视觉Token序列。这些Token与文本Token共享同一个Transformer嵌入空间。</p>\n</li>\n<li>\n<p><strong>生成式输出</strong>：模型接收文档图像作为输入，直接自回归地生成Markdown代码。这种方法的革命性在于它具备了推理能力。例如，在解析一个复杂的流程图时，传统OCR只能输出零散的文字，而DeepSeek-OCR可以根据箭头和布局生成描述性的文本：步骤A导致了步骤B。它能理解复选框旁边的文字是标签，从而输出\"Checked: Yes\"。</p>\n</li>\n<li>\n<p><strong>上下文光学压缩</strong>：为了处理长文档，DeepSeek设计了视觉压缩机制，在保留高频细节（如文字笔画）的同时压缩低频背景信息，使得在有限的Context Window内处理多页文档成为可能。</p>\n</li>\n</ul>\n<h2 id=\"文档解析模块对比总结表\">文档解析模块对比总结表</h2>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>特性/工具</td>\n<td>Unstructured</td>\n<td>Marker</td>\n<td>PyMuPDF</td>\n<td>Docling</td>\n<td>MinerU</td>\n<td>PaddleOCR</td>\n<td>DeepSeek-OCR</td>\n</tr>\n<tr>\n<td>核心架构</td>\n<td>混合策略（规则+视觉模型）</td>\n<td>深度学习流水线 (Surya + Texify)</td>\n<td>底层PDF流解析 (C++绑定)</td>\n<td>混合架构 (统一DOM + VLM)</td>\n<td>深度学习流水线 (PDF-Extract-Kit)</td>\n<td>深度学习 (PP-Structure / OCR)</td>\n<td>端到端生成式VLM (MoE架构)</td>\n</tr>\n<tr>\n<td>解析策略</td>\n<td>分区</td>\n<td>版面检测 -&gt; Markdown生成</td>\n<td>文本块/跨度提取</td>\n<td>对象模型重构 -&gt; 导出</td>\n<td>布局分析 -&gt; 多模态MD</td>\n<td>检测+识别+结构化回归</td>\n<td>视觉Token -&gt; 文本生成</td>\n</tr>\n<tr>\n<td>最佳适用场景</td>\n<td>通用ETL，多格式混合处理</td>\n<td>科学论文、数学公式、书籍</td>\n<td>海量原生数字PDF清洗</td>\n<td>企业级文档、Agentic RAG</td>\n<td>学术文献、LLM预训练数据</td>\n<td>表单、票据、复杂表格</td>\n<td>极复杂排版、视觉推理任务</td>\n</tr>\n<tr>\n<td>表格处理能力</td>\n<td>HTML/CSV (开源版能力一般)</td>\n<td>高精度 (支持跨页合并)</td>\n<td>基础 (仅依赖文本位置)</td>\n<td>高精度 (结构恢复强)</td>\n<td>高精度 (转HTML)</td>\n<td>SOTA (擅长扭曲/无框线表)</td>\n<td>生成式 (语义描述/结构化)</td>\n</tr>\n<tr>\n<td>公式/数学支持</td>\n<td>基础 (依赖OCR)</td>\n<td>卓越 (Texify转LaTeX)</td>\n<td>无 (仅原始字符)</td>\n<td>良好 (支持LaTeX)</td>\n<td>卓越 (LaTeX转换)</td>\n<td>良好 (字符识别)</td>\n<td>卓越 (生成LaTeX)</td>\n</tr>\n<tr>\n<td>处理速度</td>\n<td>中等 (取决于策略)</td>\n<td>中等 (建议GPU)</td>\n<td>极快 (纯CPU)</td>\n<td>中等偏慢 (VLM模式)</td>\n<td>中等 (建议GPU)</td>\n<td>快 (提供轻量级模型)</td>\n<td>慢 (大模型推理开销)</td>\n</tr>\n<tr>\n<td>输入模态</td>\n<td>多格式 (PDF, PPT, HTML, Email)</td>\n<td>PDF, EPUB, Images</td>\n<td>PDF, XPS, Ebook</td>\n<td>多格式 (PDF, DOCX, Images)</td>\n<td>PDF, Images</td>\n<td>Images, PDF</td>\n<td>Images, PDF</td>\n</tr>\n<tr>\n<td>输出格式</td>\n<td>JSON (标准化Schema)</td>\n<td>Markdown, JSON, HTML</td>\n<td>Dict, String</td>\n<td>Markdown, JSON, Doctags</td>\n<td>Markdown (多模态), JSON</td>\n<td>JSON, Excel, HTML</td>\n<td>Markdown, JSON</td>\n</tr>\n<tr>\n<td>主要依赖</td>\n<td>Tesseract, Poppler, NLTK</td>\n<td>PyTorch, Surya, Texify</td>\n<td>MuPDF (无外部依赖)</td>\n<td>PyTorch, Granite Model</td>\n<td>PyTorch, YOLO, Ray</td>\n<td>PaddlePaddle</td>\n<td>PyTorch, FlashAttention</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"切块模块从文本流到语义单元\">切块模块：从文本流到语义单元</h1>\n<p>解析后的数据必须经过切块才能进入向量空间。切块策略直接决定了检索的粒度与上下文完整性。</p>\n<h2 id=\"策略演进\">策略演进</h2>\n<ul>\n<li>\n<p><strong>固定窗口切块</strong>：这是最基础的方法，利用LangChain的<code>RecursiveCharacterTextSplitter</code>按字符数（如512 tokens）切分，并设置重叠（Overlap）。优点是稳定，缺点是容易切断语义，例如将一句话截断在两个块中。</p>\n</li>\n<li>\n<p><strong>语义切块</strong>：利用嵌入模型计算句与句之间的余弦相似度。当相似度骤降时，意味着话题发生了转换，系统在此处进行切分。这种方法能保证每个块包含一个完整的语义主题。开源库Chonkie和SemChunk提供了轻量级的实现，支持在不依赖重型框架的情况下快速进行语义切分。</p>\n</li>\n<li>\n<p><strong>层级切块</strong>：利用Docling或MinerU输出的结构化信息（Header, Section），先按章节切大块，再在大块内切小块。检索时匹配小块，但返回大块（Parent Document Retrieval），兼顾了检索的精准度与生成的上下文丰富度。</p>\n</li>\n</ul>\n<h2 id=\"智能agent切块\">智能Agent切块</h2>\n<p>最新的趋势是Agentic Chunking，即利用LLM将文本重写为独立的「命题」。例如，将「张三，百度的工程师，去了北京」拆解为「张三是百度的工程师」和「张三去了北京」两个独立事实。虽然成本高，但能显著提升复杂问题的检索召回率。</p>\n<h2 id=\"资源链接\">资源链接</h2>\n<p><strong>Chonkie</strong></p>\n<ul>\n<li>\n<p>一个轻量级、极速的RAG切块库，专注于语义切分。</p>\n<ul>\n<li>\n<p><strong>GitHub</strong>: <a href=\"https://github.com/chonkie-inc/chonkie\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/chonkie-inc/chonkie</a></p>\n</li>\n<li>\n<p><strong>Docs</strong>: <a href=\"https://docs.chonkie.ai/\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.chonkie.ai/</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Semantic</strong> <strong>Router</strong></p>\n<ul>\n<li>\n<p>虽然主要用于路由，但也包含强大的语义分析层，可用于高级切块。</p>\n<ul>\n<li>GitHub: <a href=\"https://github.com/aurelio-labs/semantic-router\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/aurelio-labs/semantic-router</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"向量化模块语义空间的构建\">向量化模块：语义空间的构建</h1>\n<p>向量化是将文本投影到高维语义空间的过程。在2025-2026年，MTEB (Massive Text Embedding Benchmark) 排行榜成为了衡量模型性能的黄金标准。开源模型在这一领域已经全面追平甚至超越了闭源商业模型（如OpenAI text-embedding-3）</p>\n<h2 id=\"bge-baai-general-embedding-系列\">BGE (BAAI General Embedding) 系列</h2>\n<ul>\n<li>\n<p>GitHub: <a href=\"https://github.com/FlagOpen/FlagEmbedding\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/FlagOpen/FlagEmbedding</a></p>\n</li>\n<li>\n<p>Hugging Face: <a href=\"https://huggingface.co/BAAI/bge-m3\" rel=\"noopener nofollow\" target=\"_blank\">https://huggingface.co/BAAI/bge-m3</a></p>\n</li>\n<li>\n<p>官方文档: <a href=\"https://bge-model.com/\" rel=\"noopener nofollow\" target=\"_blank\">https://bge-model.com/</a></p>\n</li>\n<li>\n<p>参考资料：<a href=\"https://www.bentoml.com/blog/a-guide-to-open-source-embedding-models\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bentoml.com/blog/a-guide-to-open-source-embedding-models</a></p>\n</li>\n</ul>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>由北京智源人工智能研究院开发。BGE-M3是目前的SOTA模型，支持多语言（100+）、多功能（稠密、稀疏、多向量检索）及长文本（8192 tokens）。其独特的混合检索能力使其成为构建多路召回系统的首选。该模型集成了三种检索范式：</p>\n<ul>\n<li>\n<p><strong>密集检索（Dense Retrieval）</strong>：基于语义向量。</p>\n</li>\n<li>\n<p><strong>稀疏检索（****Sparse</strong> <strong>Retrieval）</strong>：类似于BM25的词汇匹配，用于弥补密集检索在专有名词匹配上的不足。</p>\n</li>\n<li>\n<p><strong>多向量检索（Multi-Vector/ColBERT）</strong>：保留每个Token的向量进行细粒度交互。 这种“全能型”设计使得 BGE-M3 能够适应多语言（100+）、长文本（8192 Token）的复杂场景。</p>\n</li>\n</ul>\n<h2 id=\"qwen-embedding\">Qwen-Embedding</h2>\n<ul>\n<li>Huggingface: <a href=\"https://huggingface.co/collections/Qwen/qwen3-embedding\" rel=\"noopener nofollow\" target=\"_blank\">https://huggingface.co/collections/Qwen/qwen3-embedding</a></li>\n</ul>\n<p>阿里巴巴推出的Qwen3-Embedding系列模型在MTEB榜单上表现优异，特别是在多语言任务和长上下文任务中。</p>\n<ul>\n<li><strong>弹性维度（Matryoshka Representation Learning, MRL）</strong>：Qwen模型支持弹性输出维度。用户可以根据存储预算，灵活选择使用前1024维甚至512维向量，而性能损失微乎其微。这使得RAG系统可以在速度和精度之间进行动态权衡。</li>\n</ul>\n<h2 id=\"e5系列\">E5系列</h2>\n<ul>\n<li>Hugging Face: <a href=\"https://huggingface.co/intfloat/multilingual-e5-large\" rel=\"noopener nofollow\" target=\"_blank\">https://huggingface.co/intfloat/multilingual-e5-large</a></li>\n</ul>\n<p>E5系列 (EmbEddings from bidirEcTional Encoder rEpresentations)模型，如multilingual-e5-large，通过指令微调优化了非对称搜索任务（短Query找长Passage）。使用时需添加前缀<code>query:</code>和<code>passage:</code>，在MTEB榜单上长期霸榜。</p>\n<h2 id=\"jina-embeddings-v3\"><strong>Jina Embeddings v3</strong></h2>\n<ul>\n<li>Hugging Face: <a href=\"https://huggingface.co/jinaai/jina-embeddings-v3\" rel=\"noopener nofollow\" target=\"_blank\">https://huggingface.co/jinaai/jina-embeddings-v3</a></li>\n</ul>\n<p>专为长文档和代码设计，利用ALiBi位置编码外推上下文长度，非常适合技术文档库的RAG。</p>\n<h1 id=\"检索模块retrieval向量数据库选型\">检索模块（Retrieval）：向量数据库选型</h1>\n<p>向量数据库是RAG系统的长时记忆。当前市场已经形成了以Milvus、Qdrant和Weaviate为代表的开源三巨头，以及pgvector这种依托于PostgreSQL的轻量化方案。</p>\n<h2 id=\"milvus云原生时代的巨舰\">Milvus：云原生时代的巨舰</h2>\n<ul>\n<li>\n<p>GitHub: <a href=\"https://github.com/milvus-io/milvus\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/milvus-io/milvus</a></p>\n</li>\n<li>\n<p>文档: <a href=\"https://milvus.io/docs\" rel=\"noopener nofollow\" target=\"_blank\">https://milvus.io/docs</a></p>\n</li>\n</ul>\n<p>由Zilliz开发的Milvus采用了存储与计算分离的云原生架构，专为处理十亿级（Billion-scale）向量数据而设计。</p>\n<ul>\n<li><strong>核心特性</strong>：支持分布式部署、Kubernetes 编排、多租户隔离以及多种索引类型（HNSW, DiskANN）。它适合需要极高吞吐量和大规模数据分片的企业级应用。</li>\n</ul>\n<h2 id=\"qdrant高性能与灵活性的平衡\">Qdrant：高性能与灵活性的平衡</h2>\n<ul>\n<li>\n<p>GitHub: <a href=\"https://github.com/qdrant/qdrant\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/qdrant/qdrant</a></p>\n</li>\n<li>\n<p>文档: <a href=\"https://qdrant.tech/documentation/\" rel=\"noopener nofollow\" target=\"_blank\">https://qdrant.tech/documentation/</a></p>\n</li>\n</ul>\n<p>Qdrant基于Rust语言开发，以高性能和低延迟著称。</p>\n<ul>\n<li><strong>核心特性</strong>：将向量索引与Payload（元数据）索引紧密结合，支持强大的过滤查询（Filtering）。与传统的先检索后过滤不同，Qdrant能够在索引遍历过程中应用过滤条件，极大提升了混合查询的效率。其推荐系统和去重功能也非常完善。</li>\n</ul>\n<h2 id=\"weaviateai原生的模块化数据库\">Weaviate：AI原生的模块化数据库</h2>\n<ul>\n<li>\n<p>GitHub: <a href=\"https://github.com/weaviate/weaviate\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/weaviate/weaviate</a></p>\n</li>\n<li>\n<p>文档: <a href=\"https://weaviate.io/developers/weaviate\" rel=\"noopener nofollow\" target=\"_blank\">https://weaviate.io/developers/weaviate</a></p>\n</li>\n</ul>\n<p>Weaviate不仅仅是一个数据库，更像是一个AI中间件平台。</p>\n<ul>\n<li><strong>核心特性</strong>：内置了大量的模块，可以直接在数据库层面集成OpenAI、HuggingFace等模型的向量化能力。用户只需存入文本，Weaviate会自动调用模型生成向量。其GraphQL接口也为复杂的数据关联查询提供了便利。</li>\n</ul>\n<h2 id=\"pgvectorpostgresql用户的务实之选\">pgvector：PostgreSQL用户的务实之选</h2>\n<ul>\n<li>GitHub: <a href=\"https://github.com/pgvector/pgvector\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/pgvector/pgvector</a></li>\n</ul>\n<p>pgvector是PostgreSQL的一个开源扩展，为现有的关系型数据库添加了向量存储和相似度搜索功能。</p>\n<ul>\n<li><strong>核心特性</strong>：允许向量数据与业务数据（如用户信息、订单记录）存储在同一张表中，天然支持ACID事务和复杂的SQL Join操作。对于数据量在千万级别以下，且已有Postgres基础设施的团队，这是成本最低的方案。</li>\n</ul>\n<h1 id=\"排序模块精度的最后一道防线\">排序模块：精度的最后一道防线</h1>\n<p>检索模块通常返回 Top-K（如50-100）个候选片段，但这些片段是基于粗略的向量相似度获取的。为了让LLM获得最精准的上下文，需要引入重排序模块。重排序模型通常采用交叉编码器架构，它将查询和文档同时输入模型，计算它们之间的深层交互，从而给出极高精度的相关性评分。</p>\n<h2 id=\"bge-reranker开源重排序的标杆\">BGE-Reranker：开源重排序的标杆</h2>\n<ul>\n<li>\n<p>GitHub: <a href=\"https://github.com/FlagOpen/FlagEmbedding\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/FlagOpen/FlagEmbedding</a></p>\n</li>\n<li>\n<p>Hugging Face: <a href=\"https://huggingface.co/BAAI/bge-reranker-v2-m3\" rel=\"noopener nofollow\" target=\"_blank\">https://huggingface.co/BAAI/bge-reranker-v2-m3</a></p>\n</li>\n</ul>\n<p>BGE-Reranker系列（v2, v2.5）是目前开源社区中最强大的重排序模型之一。</p>\n<ul>\n<li>\n<p><strong>多语言能力</strong>：支持中英等多语言混合排序。</p>\n</li>\n<li>\n<p><strong>轻量化蒸馏</strong>：最新的BGE-Reranker-v2.5-Gemma2-Lightweight通过层级蒸馏技术，在保持LLM级排序能力的同时，大幅降低了推理延迟，使其能够部署在实时性要求较高的生产环境中。</p>\n</li>\n</ul>\n<h2 id=\"rankgpt利用llm进行列表排序\">RankGPT：利用LLM进行列表排序</h2>\n<ul>\n<li><strong>GitHub</strong>: <a href=\"https://github.com/sunnweiwei/RankGPT\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/sunnweiwei/RankGPT</a></li>\n</ul>\n<p>RankGPT探索了一种不同的路径：利用生成式 LLM（如 GPT-4, Qwen）的推理能力进行排序。</p>\n<ul>\n<li><strong>列表式（Listwise）排序</strong>：不同于Cross-Encoder 对每对 (Query, Doc) 单独打分，RankGPT将Query和一组文档（如10个）同时输入LLM，并提示模型「请按相关性对这些文档进行排序」。这种方法考虑了文档之间的相对关系，往往能获得比Pairwise方法更高的MAP指标，但延迟和成本也显著增加。</li>\n</ul>\n<h2 id=\"flashrank极致轻量化的cpu方案\">FlashRank：极致轻量化的CPU方案</h2>\n<ul>\n<li>GitHub: <a href=\"https://github.com/PrithivirajDamodaran/FlashRank\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/PrithivirajDamodaran/FlashRank</a></li>\n</ul>\n<p><strong>FlashRank</strong> 是一个专为无 GPU 环境设计的 Python 库。</p>\n<ul>\n<li><strong>核心特性</strong>：基于量化后的TinyBERT等微型模型，能够在普通CPU上实现毫秒级的重排序。这对于部署在AWS Lambda等Serverless环境或边缘设备上的RAG应用至关重要 。</li>\n</ul>\n<h1 id=\"选型建议\">选型建议</h1>\n<p>构建开源RAG系统已不再是简单的模型堆砌，而是对数据处理全链路的精细化工程。</p>\n<ul>\n<li>\n<p><strong>解析层</strong>：对于通用场景，推荐使用Unstructured进行快速原型开发；对于科学文献和复杂报表，Marker和MinerU是目前的最佳实践；若需处理海量原生PDF，PyMuPDF不可或缺；而对于追求极致结构化和Agent交互的企业级应用，Docling展现了巨大的潜力。</p>\n</li>\n<li>\n<p><strong>数据流层</strong>：应摒弃固定的字符切块，转向语义切块或层级切块。</p>\n</li>\n<li>\n<p><strong>模型层</strong>：BGE-M3（Embedding）配合BGE-Reranker-v2-m3（Reranking）构成了目前最强的开源语义理解组合，配合Milvus或Qdrant可构建出性能媲美商业闭源方案的RAG系统。</p>\n</li>\n</ul>\n<p>随着DeepSeek-OCR等生成式解析技术的成熟，未来的文档解析将逐渐具备推理能力，进一步模糊感知与认知的边界，为RAG系统注入更深层的智能。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-13 21:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aifrontiers\">AI-Frontiers</a>&nbsp;\n阅读(<span id=\"post_view_count\">42</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}