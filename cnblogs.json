{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "AI Agent 框架探秘：拆解 OpenHands（4）--- 服务",
      "link": "https://www.cnblogs.com/rossiXYZ/p/19530117",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rossiXYZ/p/19530117\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 19:50\">\n    <span>AI Agent 框架探秘：拆解 OpenHands（4）--- 服务</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"ai-agent-框架探秘拆解-openhands4----服务\">AI Agent 框架探秘：拆解 OpenHands（4）--- 服务</h1>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#ai-agent-框架探秘拆解-openhands4----服务\" rel=\"noopener nofollow\">AI Agent 框架探秘：拆解 OpenHands（4）--- 服务</a><ul><li><a href=\"#0x00-概述\" rel=\"noopener nofollow\">0x00 概述</a></li><li><a href=\"#0x01-服务\" rel=\"noopener nofollow\">0x01 服务</a><ul><li><a href=\"#11-api-模式\" rel=\"noopener nofollow\">1.1 API 模式</a><ul><li><a href=\"#111-actions\" rel=\"noopener nofollow\">1.1.1 Actions</a></li><li><a href=\"#112-observation\" rel=\"noopener nofollow\">1.1.2 observation</a></li></ul></li><li><a href=\"#12-服务器组件\" rel=\"noopener nofollow\">1.2 服务器组件</a><ul><li><a href=\"#sessionpy\" rel=\"noopener nofollow\">session.py</a></li><li><a href=\"#sessionagent_sessionpy\" rel=\"noopener nofollow\">session/agent_session.py</a></li><li><a href=\"#sessionconversation_managerconversation_managerpy\" rel=\"noopener nofollow\">session/conversation_manager/conversation_manager.py</a></li><li><a href=\"#listenpy\" rel=\"noopener nofollow\">listen.py</a></li></ul></li><li><a href=\"#13-服务工作流程描述\" rel=\"noopener nofollow\">1.3 服务工作流程描述</a></li><li><a href=\"#14-listen_socketpy\" rel=\"noopener nofollow\">1.4 listen_socket.py</a><ul><li><a href=\"#141-核心特色\" rel=\"noopener nofollow\">1.4.1 核心特色</a></li><li><a href=\"#142-具体功能\" rel=\"noopener nofollow\">1.4.2 具体功能</a></li><li><a href=\"#143-流程图\" rel=\"noopener nofollow\">1.4.3 流程图</a></li><li><a href=\"#144-会话连接\" rel=\"noopener nofollow\">1.4.4 会话连接</a></li><li><a href=\"#145-代码\" rel=\"noopener nofollow\">1.4.5 代码</a></li></ul></li></ul></li><li><a href=\"#0xff-参考\" rel=\"noopener nofollow\">0xFF 参考</a></li></ul></li></ul></div><p></p>\n<h2 id=\"0x00-概述\">0x00 概述</h2>\n<p>本篇结合官方文档进行解读OpenHands的服务器，这是OpenHands系统的立身基础。</p>\n<p>因为本系列借鉴的文章过多，可能在参考文献中有遗漏的文章，如果有，还请大家指出。</p>\n<h2 id=\"0x01-服务\">0x01 服务</h2>\n<p>OpenHands提供了WebSocket服务器。</p>\n<p><img alt=\"openhands-server\" class=\"lazyload\" /></p>\n<h3 id=\"11-api-模式\">1.1 API 模式</h3>\n<p>可以发送或从服务器接收两种类型的消息：</p>\n<ul>\n<li>Actions</li>\n<li>Observations</li>\n</ul>\n<h4 id=\"111-actions\">1.1.1 Actions</h4>\n<p>一个action 包含三个部分：</p>\n<ul>\n<li><code>action</code>：要采取的动作</li>\n<li><code>args</code>：动作的参数</li>\n<li><code>message</code>：可以放在聊天记录中的友好消息</li>\n</ul>\n<p>有几种action 。它们的参数列在下面。 随着时间的推移，这个列表可能会增长。</p>\n<ul>\n<li>\n<p><code>initialize</code> - 初始化代理。仅由客户端发送。</p>\n<ul>\n<li><code>model</code> - 要使用的模型名称</li>\n<li><code>directory</code> - 工作空间的路径</li>\n<li><code>agent_cls</code> - 要使用的代理类</li>\n</ul>\n</li>\n<li>\n<p><code>start</code> - 开始一个新的开发任务。仅由客户端发送。</p>\n<ul>\n<li><code>task</code> - 要开始的任务</li>\n</ul>\n</li>\n<li>\n<p><code>read</code> - 读取文件内容。</p>\n<ul>\n<li><code>path</code> - 要读取的文件路径</li>\n</ul>\n</li>\n<li>\n<p><code>write</code> - 写入内容到文件。</p>\n<ul>\n<li><code>path</code> - 要写入的文件路径</li>\n<li><code>content</code> - 写入文件的内容</li>\n</ul>\n</li>\n<li>\n<p><code>run</code> - 运行命令。</p>\n<ul>\n<li><code>command</code> - 要运行的命令</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><code>browse</code> - 打开网页。\n<ul>\n<li><code>url</code> - 要打开的URL</li>\n</ul>\n</li>\n<li><code>think</code> - 允许代理制定计划、设定目标或记录想法\n<ul>\n<li><code>thought</code> - 要记录的想法</li>\n</ul>\n</li>\n<li><code>finish</code> - 代理发出任务完成的信号</li>\n</ul>\n<h4 id=\"112-observation\">1.1.2 observation</h4>\n<p>一个observation 包含四个部分：</p>\n<ul>\n<li><code>observation</code>：观察类型</li>\n<li><code>content</code>：表示观察数据的字符串</li>\n<li><code>extras</code>：额外的结构化数据</li>\n<li><code>message</code>：可以放在聊天记录中的友好消息</li>\n</ul>\n<p>有几种observation 。它们的额外信息列在下面。 随着时间的推移，这个列表可能会增长。</p>\n<ul>\n<li><code>read</code> - 文件内容\n<ul>\n<li><code>path</code> - 读取的文件路径</li>\n</ul>\n</li>\n<li><code>browse</code> - URL的HTML内容\n<ul>\n<li><code>url</code> - 打开的URL</li>\n</ul>\n</li>\n<li><code>run</code> - 命令的输出\n<ul>\n<li><code>command</code> - 运行的命令</li>\n<li><code>exit_code</code> - 命令的退出代码</li>\n</ul>\n</li>\n<li><code>chat</code> - 用户的消息</li>\n</ul>\n<h3 id=\"12-服务器组件\">1.2 服务器组件</h3>\n<p>以下部分描述了OpenHands项目的服务器端组件。</p>\n<h4 id=\"sessionpy\">session.py</h4>\n<p><code>session.py</code> 文件定义了<code>Session</code>类，它代表与客户端的WebSocket会话。关键特性包括：</p>\n<ul>\n<li>处理WebSocket连接和断开</li>\n<li>初始化和管理代理会话</li>\n<li>在客户端和代理之间分发事件</li>\n<li>向客户端发送消息和错误</li>\n</ul>\n<h4 id=\"sessionagent_sessionpy\">session/agent_session.py</h4>\n<p><code>agent_session.py</code> 文件包含<code>AgentSession</code>类，它管理会话内代理的生命周期。关键特性包括：</p>\n<ul>\n<li>创建和管理运行时环境</li>\n<li>初始化代理控制器</li>\n<li>处理安全分析</li>\n<li>管理事件流</li>\n</ul>\n<h4 id=\"sessionconversation_managerconversation_managerpy\">session/conversation_manager/conversation_manager.py</h4>\n<p><code>conversation_manager.py</code> 文件定义了<code>ConversationManager</code>类，它负责管理多个客户端会话。关键特性包括：</p>\n<ul>\n<li>添加和重启会话</li>\n<li>向特定会话发送消息</li>\n<li>清理非活动会话</li>\n</ul>\n<h4 id=\"listenpy\">listen.py</h4>\n<p><code>listen.py</code> 文件是主服务器文件，它设置FastAPI应用程序并定义各种API端点。关键特性包括：</p>\n<ul>\n<li>设置CORS中间件</li>\n<li>处理WebSocket连接</li>\n<li>管理文件上传</li>\n<li>提供代理交互、文件操作和安全分析的API端点</li>\n<li>为前端提供静态文件服务</li>\n</ul>\n<p>该脚本定义了服务接口，主要分为两个部分：</p>\n<ul>\n<li>一部分是通过<code>FastAPI</code>库实现的HTTP接口，其具体实现位于<code>openhands/server/routes</code>目录中；</li>\n<li>另一部分是利用<code>socketio</code>库实现的WebSocket接口，其代码实现在<code>openhands/server/listen_socket.py</code>文件中。用户与代理的交互通过WebSocket进行，连接初始化时会触发<code>connect</code>事件，用户发送消息时会触发<code>oh_user_action</code>事件，连接断开时会触发<code>disconnect</code>事件。因此，梳理代理交互逻辑的核心在于对这三个事件的处理流程进行整理。</li>\n</ul>\n<pre><code class=\"language-python\">import socketio\n\nfrom openhands.server.app import app as base_app\nfrom openhands.server.listen_socket import sio\nfrom openhands.server.middleware import (\n    CacheControlMiddleware,\n    InMemoryRateLimiter,\n    LocalhostCORSMiddleware,\n    RateLimitMiddleware,\n)\nfrom openhands.server.static import SPAStaticFiles\n\nif os.getenv('SERVE_FRONTEND', 'true').lower() == 'true':\n    base_app.mount(\n        '/', SPAStaticFiles(directory='./frontend/build', html=True), name='dist'\n    )\n\nbase_app.add_middleware(LocalhostCORSMiddleware)\nbase_app.add_middleware(CacheControlMiddleware)\nbase_app.add_middleware(\n    RateLimitMiddleware,\n    rate_limiter=InMemoryRateLimiter(requests=10, seconds=1),\n)\n\napp = socketio.ASGIApp(sio, other_asgi_app=base_app)\n</code></pre>\n<h3 id=\"13-服务工作流程描述\">1.3 服务工作流程描述</h3>\n<p>服务的工作流程如下：</p>\n<ol>\n<li><strong>服务器初始化</strong>：\n<ul>\n<li>FastAPI应用程序在<code>listen.py</code>中创建和配置。</li>\n<li>设置CORS中间件和静态文件服务。</li>\n<li>初始化<code>ConversationManager</code>。</li>\n</ul>\n</li>\n<li><strong>客户端连接</strong>：\n<ul>\n<li>当客户端通过WebSocket连接时，创建新的<code>Session</code>或重启现有一个。</li>\n<li><code>Session</code>初始化<code>AgentSession</code>，设置运行时环境和代理控制器。</li>\n</ul>\n</li>\n<li><strong>代理初始化</strong>：\n<ul>\n<li>客户端发送初始化请求。</li>\n<li>服务器根据提供的参数创建和配置代理。</li>\n<li>设置运行时环境，初始化代理控制器。</li>\n</ul>\n</li>\n<li><strong>事件处理</strong>：\n<ul>\n<li><code>Session</code>管理客户端和代理之间的事件流。</li>\n<li>客户端的事件分发到代理。</li>\n<li>代理的观察结果发送回客户端。</li>\n</ul>\n</li>\n<li><strong>文件操作</strong>：\n<ul>\n<li>服务器处理文件上传，确保它们符合大小和类型限制。</li>\n<li>通过运行时环境执行文件读取和写入操作。</li>\n</ul>\n</li>\n<li><strong>安全分析</strong>：\n<ul>\n<li>如果配置了，每个会话初始化安全分析器。</li>\n<li>安全相关的API请求转发到安全分析器。</li>\n</ul>\n</li>\n<li><strong>会话管理</strong>：\n<ul>\n<li><code>ConversationManager</code>定期清理非活动会话。</li>\n<li>它还在需要时处理向特定会话发送消息。</li>\n</ul>\n</li>\n<li><strong>API端点</strong>：\n<ul>\n<li>提供各种API端点，用于代理交互、文件操作和获取配置默认值。</li>\n</ul>\n</li>\n</ol>\n<p>这种服务器架构允许管理多个客户端会话，每个会话都有自己的代理实例、运行时环境和安全分析器。事件驱动设计促进了客户端和代理之间的实时通信，而模块化结构允许轻松扩展和维护不同组件。</p>\n<h3 id=\"14-listen_socketpy\">1.4 listen_socket.py</h3>\n<p>listen_socket.py是 OpenHands 服务器端的 Socket.IO 事件监听器，负责处理客户端和服务器之间的实时双向通信，包括连接建立、事件回放、用户行动转发和连接断开四大核心场景，是客户端与后端会话、代理系统交互的桥梁。</p>\n<h4 id=\"141-核心特色\">1.4.1 核心特色</h4>\n<p>listen_socket.py的核心特色如下：</p>\n<ol>\n<li>断点续传的事件回放：支持通过 <code>latest_event_id</code> 参数实现事件断点续传，客户端重连时仅回放未接收的事件，避免重复数据传输，提升连接效率。</li>\n<li>严格的身份与权限校验：连接建立时校验会话 ID、API 密钥、用户身份（通过 Cookie 和 Authorization 头），确保会话安全性，防止未授权访问。</li>\n<li>向后兼容的事件处理：保留 <code>oh_action</code> 处理器兼容旧版客户端，同时提供 <code>oh_user_action</code> 新版接口，平滑过渡不中断服务。</li>\n<li>有序的事件推送逻辑：代理状态变更事件（<code>AgentStateChangedObservation</code>）最后发送，确保客户端先接收历史事件，再同步最新状态，避免状态不一致。</li>\n<li>异步高效的事件处理：基于异步 IO（<code>async/await</code>）实现事件回放和转发，支持高并发连接，不阻塞主线程，提升系统吞吐量。</li>\n<li>完善的错误处理：连接失败时主动断开无效连接，记录详细日志，便于问题排查；过滤无效事件（如 <code>NullAction</code>），减少不必要的网络传输。</li>\n</ol>\n<h4 id=\"142-具体功能\">1.4.2 具体功能</h4>\n<p>listen_socket.py的具体功能如下：</p>\n<ul>\n<li>\n<p>连接管理（connect 事件）</p>\n<ul>\n<li>身份验证：验证连接参数中的 conversation_id 和 API 密钥</li>\n<li>用户认证：通过 conversation_validator 验证用户身份</li>\n<li>会话恢复：为已存在的会话重放事件流历史</li>\n<li>事件重播：向新连接的客户端发送历史事件，包括过滤特定事件类型</li>\n<li>会话加入：将客户端连接加入到对应的会话中</li>\n</ul>\n</li>\n<li>\n<p>动作处理（oh_user_action 和 oh_action 事件）</p>\n<ul>\n<li>用户动作接收：处理来自客户端的用户操作请求</li>\n<li>事件转发：将用户动作转发到会话管理器进行处理</li>\n<li>向后兼容：同时支持 oh_user_action 和 oh_action 事件处理（后者为兼容旧客户端保留）</li>\n</ul>\n</li>\n<li>\n<p>断开连接处理（disconnect 事件）</p>\n<ul>\n<li>连接清理：当客户端断开连接时，清理相关会话资源</li>\n<li>状态管理：通知会话管理器客户端已断开连接</li>\n</ul>\n</li>\n</ul>\n<p>listen_socket.py的核心工作流程为：</p>\n<ul>\n<li>连接建立：\n<ul>\n<li>解析查询参数（会话 ID、最新事件 ID等）</li>\n<li>验证会话和用户身份</li>\n<li>创建事件存储实例</li>\n</ul>\n</li>\n<li>事件历史重播：\n<ul>\n<li>为客户端重放会话历史事件</li>\n<li>过滤掉 NullAction、NullObservation、RecallAction 等特定事件</li>\n<li>确保 AgentStateChangedObservation 事件最后发送</li>\n</ul>\n</li>\n<li>会话加入：\n<ul>\n<li>将连接 ID 与会话关联</li>\n<li>初始化会话设置</li>\n</ul>\n</li>\n<li>安全机制\n<ul>\n<li>API密钥验证：检查 SESSION_API_KEY 环境变量与查询参数中的密钥是否匹配</li>\n<li>会话权限控制：通过 conversation_validator 验证用户是否有权访问定会话</li>\n</ul>\n</li>\n<li>错误处理\n<ul>\n<li>连接拒绝：在验证失败或出现错误时拒绝连接</li>\n<li>异常传播：使用ConnectionRefusedError处理连接错误</li>\n<li>异步清理：在连接被拒绝后异步断开连接</li>\n</ul>\n</li>\n</ul>\n<p>listen_socket.py 与其他组件关系</p>\n<ul>\n<li>与EventStream紧密配合，负责事件的传输和分发</li>\n<li>通过 connection_manager  管理会话状态</li>\n<li>使用  event_to_dict  进行事件序列化以便通过网络传输</li>\n</ul>\n<h4 id=\"143-流程图\">1.4.3 流程图</h4>\n<p><img alt=\"Openhands-服务\" class=\"lazyload\" /></p>\n<h4 id=\"144-会话连接\">1.4.4 会话连接</h4>\n<p>此处关键一步为与会话管理器 ConversationManager 建立连接。</p>\n<pre><code class=\"language-python\">        conversation_init_data = await setup_init_conversation_settings(\n            user_id, conversation_id, providers_set\n        )\n\n        agent_loop_info = await conversation_manager.join_conversation(\n            conversation_id,\n            connection_id,\n            conversation_init_data,\n            user_id,\n        )\n</code></pre>\n<h4 id=\"145-代码\">1.4.5 代码</h4>\n<p>listen_socket.py的代码举例如下：</p>\n<pre><code class=\"language-python\">@sio.event\nasync def connect(connection_id: str, environ: dict) -&gt; None:\n    \"\"\"\n    SocketIO连接事件处理器：客户端建立连接时触发，完成会话验证、事件回放、会话加入等初始化流程。\n    \n    参数：\n        connection_id: 客户端连接唯一标识（SocketIO分配）\n        environ: WSGI环境变量字典，包含请求头、查询参数等信息\n    \"\"\"\n    try:\n        logger.info(f\"SocketIO连接建立：connection_id={connection_id}\")\n        \n        # 解析查询参数（从WSGI环境变量中提取QUERY_STRING）\n        query_params = parse_qs(environ.get('QUERY_STRING', ''))\n        \n        # 解析最新事件ID（用于断点续传，默认-1表示从最开始回放）\n        latest_event_id_str = query_params.get('latest_event_id', [-1])[0]\n        try:\n            latest_event_id = int(latest_event_id_str)\n        except ValueError:\n            logger.debug(f\"无效的latest_event_id值：{latest_event_id_str}，默认设为-1\")\n            latest_event_id = -1\n        \n        # 解析会话ID（必需参数，用于关联特定对话）\n        conversation_id = query_params.get('conversation_id', [None])[0]\n        logger.info(f\"会话连接请求：conversation_id={conversation_id}, connection_id={connection_id}\")\n        \n        # 解析提供者集合（如支持的LLM提供商列表，用于限制可用资源）\n        raw_list = query_params.get('providers_set', [])\n        providers_list = []\n        for item in raw_list:\n            # 拆分逗号分隔的提供者名称，过滤空值\n            providers_list.extend(item.split(',') if isinstance(item, str) else [])\n        providers_list = [p for p in providers_list if p]\n        providers_set = [ProviderType(p) for p in providers_list]  # 转换为ProviderType枚举类型\n\n        # 校验会话ID是否存在\n        if not conversation_id:\n            logger.error(\"查询参数中缺少conversation_id\")\n            raise ConnectionRefusedError(\"缺少会话ID（conversation_id）\")\n\n        # 校验会话API密钥是否有效\n        if _invalid_session_api_key(query_params):\n            raise ConnectionRefusedError(\"无效的会话API密钥\")\n\n        # 提取请求中的Cookie和Authorization头（用于用户身份验证）\n        cookies_str = environ.get('HTTP_COOKIE', '')\n        # WSGI环境中，HTTP头会转为\"HTTP_前缀+下划线替换短横线\"格式\n        authorization_header = environ.get('HTTP_AUTHORIZATION', None)\n        \n        # 创建会话验证器，校验用户身份（关联会话ID、Cookie、授权头）\n        conversation_validator = create_conversation_validator()\n        user_id = await conversation_validator.validate(\n            conversation_id, cookies_str, authorization_header\n        )\n        \n        # 创建事件存储实例（用于读取会话历史事件）\n        try:\n            event_store = EventStore(\n                conversation_id, conversation_manager.file_store, user_id\n            )\n        except FileNotFoundError as e:\n            logger.error(f\"创建会话事件存储失败：conversation_id={conversation_id}, 错误={e}\")\n            raise ConnectionRefusedError(f\"无法访问会话事件：{e}\")\n\n        agent_state_changed = None  # 存储代理状态变更事件（最后单独发送）\n\n        # 创建异步事件存储包装器，从latest_event_id+1开始回放事件（避免重复）\n        async_store = AsyncEventStoreWrapper(event_store, latest_event_id + 1)\n\n        # 异步回放历史事件（向客户端推送未接收过的事件）\n        async for event in async_store:\n            logger.debug(f\"回放事件：{event.__class__.__name__}\")\n\n            # 跳过无效/召回类事件（无需推送给客户端）\n            if isinstance(\n                event,\n                (NullAction, NullObservation, RecallAction),\n            ):\n                continue\n            # 暂存代理状态变更事件（最后发送，确保客户端状态同步）\n            elif isinstance(event, AgentStateChangedObservation):\n                agent_state_changed = event\n            # 其他事件直接推送给客户端\n            else:\n                await sio.emit('oh_event', event_to_dict(event), to=connection_id)\n\n        # 最后发送代理状态变更事件（确保客户端获取最新状态）\n        if agent_state_changed:\n            await sio.emit(\n                'oh_event', event_to_dict(agent_state_changed), to=connection_id\n            )\n\n        logger.info(f\"会话事件回放完成：conversation_id={conversation_id}\")\n\n        # 初始化会话设置（用户偏好、提供者配置等）\n        conversation_init_data = await setup_init_conversation_settings(\n            user_id, conversation_id, providers_set\n        )\n\n        # 加入会话：关联connection_id与会话，启动代理循环\n        agent_loop_info = await conversation_manager.join_conversation(\n            conversation_id,\n            connection_id,\n            conversation_init_data,\n            user_id,\n        )\n\n        # 校验会话加入结果\n        if agent_loop_info is None:\n            raise ConnectionRefusedError(\"加入会话失败\")\n\n        logger.info(f\"会话加入成功：conversation_id={conversation_id}, connection_id={connection_id}\")\n        \n    except ConnectionRefusedError:\n        # 发送错误后断开无效连接\n        asyncio.create_task(sio.disconnect(connection_id))\n        raise\n\n\n@sio.event\nasync def oh_user_action(connection_id: str, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    处理客户端发送的用户行动事件（如用户输入、操作指令）。\n    \n    参数：\n        connection_id: 客户端连接ID\n        data: 用户行动数据（字典格式，包含行动类型、内容等）\n    \"\"\"\n    # 将用户行动转发到事件流，由会话管理器处理\n    await conversation_manager.send_to_event_stream(connection_id, data)\n\n\n@sio.event\nasync def oh_action(connection_id: str, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    兼容旧版客户端的行动事件处理器（保留用于向后兼容）。\n    \n    注意：待所有客户端升级为使用oh_user_action后，可移除该处理器\n    目前用于支持正在进行中的旧会话，避免中断服务\n    \"\"\"\n    await conversation_manager.send_to_event_stream(connection_id, data)\n\n\n@sio.event\nasync def disconnect(connection_id: str) -&gt; None:\n    \"\"\"\n    SocketIO断开连接事件处理器：客户端断开连接时触发。\n    \n    参数：\n        connection_id: 断开连接的客户端ID\n    \"\"\"\n    logger.info(f\"SocketIO连接断开：connection_id={connection_id}\")\n    # 通知会话管理器，断开该连接与会话的关联\n    await conversation_manager.disconnect_from_session(connection_id)\n</code></pre>\n<h2 id=\"0xff-参考\">0xFF 参考</h2>\n<p><a href=\"https://docs.all-hands.dev/openhands/usage/architecture/backend\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.all-hands.dev/openhands/usage/architecture/backend</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1936485868761257658\" rel=\"noopener nofollow\" target=\"_blank\">当AI Agent从“玩具”走向“工具”，我们该关注什么？Openhands架构解析【第二篇：Agent 相关核心概念】</a>  <a href=\"https://www.zhihu.com/people/dreamrenderx\" rel=\"noopener nofollow\" target=\"_blank\">克里</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1936175201323825087\" rel=\"noopener nofollow\" target=\"_blank\">当AI Agent从“玩具”走向“工具”，我们该关注什么？Openhands架构解析【第一篇：系列导读】</a> <a href=\"https://www.zhihu.com/people/dreamrenderx\" rel=\"noopener nofollow\" target=\"_blank\">克里</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1940436682949244630\" rel=\"noopener nofollow\" target=\"_blank\">Coding Agent之Openhands解析(含代码)</a>  <a href=\"https://www.zhihu.com/people/wu-long-ming-cha-56\" rel=\"noopener nofollow\" target=\"_blank\">Arrow</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1940824548485347192\" rel=\"noopener nofollow\" target=\"_blank\">OpenHands 源码解读</a>  <a href=\"https://www.zhihu.com/people/xiao-hui-66-72\" rel=\"noopener nofollow\" target=\"_blank\">一力辉</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 19:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rossiXYZ\">罗西的思考</a>&nbsp;\n阅读(<span id=\"post_view_count\">26</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI是资本的胜利-未来可能是资本的天下",
      "link": "https://www.cnblogs.com/ztfjs/p/19549290/aiagent",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ztfjs/p/19549290/aiagent\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 16:20\">\n    <span>AI是资本的胜利-未来可能是资本的天下</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2>序</h2>\n<p>——工程师正在自掘坟墓，或许转行外卖才是唯一选择，但资本+AI能够统治一切。</p>\n<p>工业革命（蒸汽机）与 AI 革命最核心的本质差异—— 前者是动力赋能下的人力规模放大，后者是智力替代下的人力价值消解，资本对 AI 的终极诉求并非 “提升人力效率”，而是彻底重构生产要素，让 “人” 从核心创造者沦为边缘监督者，将劳动的价值锚点从人转移到机器、算力、模型这些资本可完全掌控的生产资料上。 ————这是资本的胜利。本文仅讨论AI对资本的实质，并不过多描述AI对人类发展的进步意义。</p>\n<h2>蒸汽机时代-动力赋能下的人力价值放大</h2>\n<p>蒸汽机的诞生，标志着人类从手工劳动迈入机器生产时代，但它自始至终都未曾动摇“人”作为生产核心的地位。其本质是用无生命的动力源，替代了人的体力劳动，却进一步放大了对掌握技能的人力的需求，形成了“机器赋能人、人驱动生产”的共生关系。 在蒸汽机普及前，纺织、采矿、运输等行业依赖人工劳作，生产效率受限于人的体力极限，规模扩张极为缓慢。蒸汽机的出现，打破了这一桎梏——一台蒸汽织布机的效率远超十名熟练织工，一台蒸汽机车的运力抵得上数十辆马车。但这种效率提升，并未导致人力需求的缩减，反而催生了更大规模的人力缺口。一方面，蒸汽机本身需要专业工人操作、调试、维护，原本的手工劳动者通过技能升级，转变为机器操作工，依然是生产流程中不可或缺的一环；另一方面，生产规模的爆发式增长，带动了上下游产业链的扩张，需要更多工人参与原料开采、产品加工、仓储运输、车间管理等环节。</p>\n<p>更关键的是，蒸汽机时代的价值创造锚点始终是人。机器是资本投入的生产资料，但没有工人的操控与技能输出，机器只是一堆无价值的钢铁。资本想要赚取更多利润，就必须雇佣更多工人、提升工人的技能水平，人力劳动依然是价值公式中的核心变量。此时的资本与工人，是“利益共生”关系——资本通过机器放大工人的劳动价值，工人通过依附资本的生产资料获得生存报酬，人在生产中的核心地位不可替代。</p>\n<h2>从AI辅助编程到AI自主编程：人的经验被数字概率替代</h2>\n<p>AI演进路径，我觉得从根源上背离了“工具赋能人”的传统逻辑,现阶段接触到的所有AI，例如manus、claude code、midjourney等不同领域的AI，它们被赋予的终极目标是用“数字概率”替代“人的经验”、”人的美感”、”人的一切脑力价值”，让机器接管最核心的智力劳动。从编程上看，从早期的代码补全工具，到如今能基于自然语言需求生成完整项目代码、自主排查Bug、优化程序性能的AI模型，AI正在逐步消解人们赖以生存的核心价值————经验积累与逻辑思考。 在传统编程模式中，程序员的核心竞争力源于长期实践积累的经验：对编程语言的熟练运用、对业务逻辑的深度理解、对复杂问题的排查能力、对系统架构的设计思维。这些经验是个性化的、不可复制的，是程序员在劳动力市场中议价的核心资本。但AI Coding的底层逻辑，是通过学习海量开源代码与技术文档，将人类的编程经验转化为数字概率模型——AI生成代码的过程，并非“思考”，而是基于数据训练形成的概率预测，它能快速输出符合语法、逻辑通顺的代码，却无需理解代码背后的业务本质与技术原理。</p>\n<p>这种替代带来的直接后果，是人的经验价值急剧缩水。当一名资深程序员花费数年积累的业务逻辑处理经验，能被AI通过数据训练在几小时内复刻；当程序员熬夜调试的Bug，AI能在几秒内定位并修复，人类的经验便不再是稀缺资源。资本无需再为程序员的经验积累支付高额薪酬，只需投入算力与模型训练成本，就能获得源源不断的“数字劳动力”，而程序员的工作，也从“创造性劳动”沦为“对AI生成结果的监督与修正”，经验的溢价空间被彻底压缩。</p>\n<h2>应届生的价值急剧下降：入门门槛与生存空间被双重挤压</h2>\n<p>在AI的冲击下，软件开发行业的人才结构正在发生剧烈重构，应届生成为受影响最直接、最深刻的群体，其劳动力价值急剧下降，入门与生存空间被双重挤压。传统编程行业中，应届生是“潜力股”——资本愿意投入成本培养应届生，让其从基础编码工作做起，逐步积累经验、成长为核心人才，应届生的“可培养性”是其核心价值所在。但AI Coding的普及，直接剥夺了应届生赖以成长的基础岗位与实践机会。 一方面，AI完全替代了应届生最擅长的基础编码工作。过去，应届生通过编写CRUD接口、简单业务逻辑代码、参与单元测试等基础工作积累经验，但如今这些工作已能被AI高效完成，且准确率与效率远超应届生。资本不再需要雇佣应届生从事基础开发，原本的入门岗位大幅缩减，应届生面临“无工可做”的困境。另一方面，行业对人才的需求标准发生扭曲，从“注重潜力与学习能力”转向“注重AI工具操控能力与代码审核效率”。部分企业更愿意雇佣能快速上手AI工具、高效审核AI生成代码的“熟练工”，而非需要花费时间培养、且效率不及AI的应届生。</p>\n<p>更残酷的是，应届生失去了“经验积累的阶梯”。没有基础编码的实践，应届生难以理解复杂系统的架构逻辑与业务底层原理，即便掌握了AI工具的使用，也只能停留在“监督者”的层面，无法成长为具备核心竞争力的高级人才。最终，应届生的价值被压缩到最低，要么接受低薪的“AI辅助岗”，要么被行业淘汰，资本则以极低的成本获得了“可替代的监督劳动力”。</p>\n<h2>智力资源普及廉价：资本掌控下的价值贬值</h2>\n<p>软件开发是典型的智力密集型行业，智力资源曾是少数人拥有的稀缺资源，也是程序员议价权的核心。但AI Coding的出现，让原本稀缺的智力资源变得“普及且廉价”，而这一切的主导者与受益者，正是资本。资本通过掌控AI模型与算力，将人类的智力成果转化为可复制、可批量输出的“数字商品”，彻底打破了智力资源的稀缺性。 在AI出现前，一名程序员的智力输出具有排他性——其编写的代码、设计的架构，只能为雇佣他的企业创造价值，资本想要获得更多智力资源，就必须雇佣更多程序员。但AI模型通过学习海量开源代码与技术文档，整合了全球程序员的智力成果，资本只需投入一次模型训练成本，就能无限次输出智力成果，且边际成本趋近于零。原本需要数十名程序员花费数月完成的项目，如今通过AI Coding工具，几名“监督者”就能在几周内完成，智力资源的使用效率被资本以“规模化复制”的方式拉满。</p>\n<p>同时，智力资源的价值被资本重新定义。过去，程序员的智力劳动直接转化为产品价值，薪酬与价值挂钩；如今，AI成为智力成果的“输出者”，程序员的智力劳动只是AI训练数据的一部分，其价值被稀释到海量数据中，无法单独量化。资本无需为个体的智力劳动支付高额报酬，只需支付少量“数据贡献费”（甚至无需支付，引发诸多知识产权争议），就能掌控海量智力资源，原本稀缺的智力资源，在资本的操作下变得廉价且可随意取用。</p>\n<h2>结合机器人：概率数字能够替代的人力范围扩大</h2>\n<p>AI Coding的价值替代，并非局限于软件开发行业。当AI的“概率数字决策”与机器人技术相结合，资本能够替代的人力范围将实现跨领域扩张，从智力劳动延伸到体力劳动与服务劳动，进一步巩固资本对生产要素的掌控权。AI提供“大脑决策”，机器人提供“肢体执行”，二者结合形成的“数字劳动力体系”，正在逐步替代人类在各行业的劳动角色。 在工业领域，传统机器人需要预设程序才能运行，灵活性与适应性极差，无法应对复杂场景。但结合AI的概率决策能力后，机器人能通过实时数据分析，自主调整操作流程、应对突发状况——比如AI驱动的工业机器人，能自主识别零件缺陷、优化装配路径，无需人类干预就能完成复杂生产任务，替代了原本需要熟练技工与程序员协同完成的工作。在服务领域，AI驱动的服务机器人能通过自然语言处理理解用户需求，结合场景数据做出概率决策，提供客服、导购、护理等服务，替代了大量基础服务岗位。</p>\n<p>这种跨领域替代的核心，依然是资本对生产要素的重构。AI的概率数字模型与机器人，都是资本可完全掌控的生产资料，资本无需再依赖不同行业的熟练劳动力，只需通过升级AI模型与机器人硬件，就能实现跨行业布局与人力替代。原本分散在各行业的劳动力价值，被统一锚定到资本掌控的“数字劳动力体系”中，人类的劳动范围被进一步压缩，资本的统治边界则持续扩大。</p>\n<h2>未来可能是资本的天下</h2>\n<p>当AI Coding重构了智力劳动的价值逻辑，当机器人技术扩大了人力替代的范围，当资本完全掌控了模型、算力、机器人这些核心生产资料，未来的社会生产格局，大概率将是资本的天下。资本通过掌控“数字劳动力体系”，实现了对价值创造的绝对主导，人在生产中的地位被边缘化，劳动的价值被彻底转移到资本的生产资料中。 从经济逻辑来看，资本的边际成本将持续降低，而人力的边际价值将持续缩水。资本只需一次性投入模型训练、算力搭建与机器人研发成本，就能获得无限期的价值输出；而人类劳动则面临“可替代性强、议价权弱”的困境，无论是程序员、技工还是服务人员，都只能在资本掌控的生产体系中，从事低价值的监督、维护工作，薪酬水平被资本牢牢压制。从垄断格局来看，掌握核心AI模型与算力资源的资本，将形成难以打破的行业垄断——新企业想要进入市场，必须投入巨额成本搭建AI与算力基础设施，而巨头资本通过规模效应与数据壁垒，能轻松挤压新竞争者，形成“资本越集中、垄断越强；垄断越强，资本越集中”的循环。</p>\n<p>这种格局下，资本不再是“服务于生产的媒介”，而是“生产的绝对主导者”，人类劳动从“价值创造的核心”沦为“资本生产资料的附属”。AI Coding的普及，只是资本掌控生产要素、巩固统治地位的第一步，当技术持续迭代，资本将彻底掌控价值创造的全链条，成为未来社会的绝对主导力量——这，便是资本通过AI革命赢得的终极胜利。</p>\n\n</div>\n<div id=\"MySignature\">\n    ========================================================\n转载请注明出处。\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 16:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ztfjs\">张泰峰</a>&nbsp;\n阅读(<span id=\"post_view_count\">134</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Python 高效实现 Excel 转 TXT 文本",
      "link": "https://www.cnblogs.com/jazz-z/p/19547652",
      "published": "",
      "description": "<div class=\"postcontent\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在数据处理场景中，将Excel文件转换为纯文本（TXT）格式便成为了一个常见的需求。传统的手动复制粘贴，不仅效率低下，更容易因格式不兼容、数据量庞大而引发错误。本文将解析如何通过 Spire.XLS for Python 实现 Excel 转 TXT 的高效、无依赖操作，提升数据处理效率和灵活性。</p>\n<blockquote>\n<p>安装指令：<code>pip install spire.xls​​</code><br />\n免费版：<code>​​pip install spire.xls.free​​ </code></p>\n</blockquote>\n<h2 id=\"基础示例单工作表-excel-转-txt\">基础示例：单工作表 Excel 转 TXT</h2>\n<p>以下是将一个 Excel 文件中的第一个工作表转换为 TXT 的完整步骤：</p>\n<h3 id=\"1-加载并读取excel文件\">1. 加载并读取Excel文件</h3>\n<pre><code class=\"language-python\">from spire.xls import *\nfrom spire.xls.common import *\n\nworkbook = Workbook()\nworkbook.LoadFromFile(\"示例.xlsx\")\n</code></pre>\n<h3 id=\"2-执行转换并保存\">2. 执行转换并保存</h3>\n<pre><code class=\"language-python\">sheet = workbook.Worksheets[0]\nsheet.SaveToFile(\"output.txt\", \"\\t\", Encoding.get_UTF8())\n</code></pre>\n<h3 id=\"参数说明\">参数说明</h3>\n<table>\n<thead>\n<tr>\n<th>参数类型</th>\n<th>示例值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>分隔符</td>\n<td><code>\\t</code> (制表符)</td>\n<td>定义 TXT 文件中各列数据之间的分隔方式，也可使用逗号 <code>,</code>、分号 <code>;</code> 等。</td>\n</tr>\n<tr>\n<td>编码方式</td>\n<td><code>Encoding.get_UTF8()</code>（国际通用编码）</td>\n<td>指定文本文件的编码格式，推荐使用 <code>UTF-8</code> 以保证中文等字符正常显示。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"进阶处理多工作表分别导出为-txt\">进阶处理：多工作表分别导出为 TXT</h2>\n<p>如果你的 Excel 文件包含多个工作表，并且希望将每个工作表保存为单独的 TXT 文件，可以使用以下代码：</p>\n<pre><code class=\"language-python\">from spire.xls import *\nfrom spire.xls.common import *\n\ndef excel_sheets_to_txt(input_file, output_folder, delimiter=\"\\t\"):\n  \n    # 创建Workbook对象\n    workbook = Workbook()\n    # 加载Excel文件\n    workbook.LoadFromFile(input_file)\n        \n    # 遍历所有工作表\n    for i in range(workbook.Worksheets.Count):\n        sheet = workbook.Worksheets[i]\n            \n        # 构建输出文件路径\n        output_file = f\"sheet_{i+1}_{sheet.Name}.txt\"\n        output_path = os.path.join(output_folder, output_file)\n            \n        # 将工作表内容保存为TXT文件\n        sheet.SaveToFile(output_path, delimiter, Encoding.get_UTF8())\n</code></pre>\n<h2 id=\"excel-转-txt-在自动化流程中的应用\">Excel 转 TXT 在自动化流程中的应用</h2>\n<p>将 Excel 转换为 TXT 不仅是格式的简单转换，更是实现数据自动化流程的重要环节。结合 Spire.XLS for Python，可轻松构建以下应用：</p>\n<ul>\n<li><strong>自动化报告生成</strong>： 从 Excel 模板中提取数据，生成纯文本格式的报告摘要，方便邮件发送或系统集成。</li>\n<li><strong>数据清洗与预处理</strong>： 将复杂格式的 Excel 数据转换为 TXT，作为其他数据分析工具（如Spark、Hadoop）的输入源，进行更深层次的处理。</li>\n<li><strong>配置管理</strong>： 将 Excel 中维护的系统配置、参数表等导出为 TXT 格式，便于脚本直接读取，同时更适合使用 Git 等工具进行版本管理。</li>\n</ul>\n<hr />\n<p>通过以上方法与示例，您可以快速掌握使用 Python 实现 Excel 到 TXT 的高效转换。该方案不仅提升了数据导出效率，也为后续的数据集成与自动化处理奠定了可靠基础。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"itemdesc\">\n                发表于 \n<span id=\"post-date\">2026-01-29 12:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jazz-z\">LAYONTHEGROUND</a>&nbsp;\n阅读(<span id=\"post_view_count\">128</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n            </div>"
    },
    {
      "title": "前端倒计时活动，为什么不推荐直接用 setTimeout / setInterval？",
      "link": "https://www.cnblogs.com/zxlh1529/p/19545350",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zxlh1529/p/19545350\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 11:44\">\n    <span>前端倒计时活动，为什么不推荐直接用 setTimeout / setInterval？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在商城项目中，「倒计时活动」几乎是绕不开的需求：<br />\n秒杀、限时优惠、拼团、支付剩余时间……</p>\n<p>我相信很多都跟我一样一开始写出类似这样的代码：</p>\n<pre><code class=\"language-js\">setInterval(() =&gt; {\n  remainTime--\n}, 1000)\n</code></pre>\n<h2 id=\"功能能跑但线上问题也会跟着跑出来\"><strong>功能能跑，但线上问题也会跟着跑出来。</strong></h2>\n<h2 id=\"一为什么-settimeout--setinterval-不适合活动倒计时\">一、为什么 setTimeout / setInterval 不适合活动倒计时？</h2>\n<h3 id=\"它们天生就不准\">它们天生就不准</h3>\n<p>很多人对定时器有一个误解：</p>\n<blockquote>\n<p><code>setInterval(fn, 1000)</code> ≠ 每 1000ms 准时执行</p>\n</blockquote>\n<p>原因只有一个：<br />\n<strong>JavaScript 是单线程的。</strong></p>\n<p>到这你先回想一下事件循环机制，有哪些？然后再往下看；如果实在想不起来就先上网搜下，或者看看我的<a href=\"https://www.cnblogs.com/zxlh1529/p/18829778\" target=\"_blank\">单线程原理</a>。</p>\n<ul>\n<li>事件循环机制</li>\n<li>主线程被渲染卡住</li>\n<li>执行大量 JS</li>\n<li>GC、布局、重绘</li>\n</ul>\n<p>都会导致定时器回调被<strong>延后执行</strong>。</p>\n<p>倒计时的表现就是：</p>\n<ul>\n<li>跳秒</li>\n<li>变慢</li>\n<li>和真实时间对不上</li>\n</ul>\n<hr />\n<h3 id=\"浏览器会故意降级定时器\">浏览器会「故意」降级定时器</h3>\n<p>这是活动倒计时最容易翻车的一点。</p>\n<p>当页面进入以下状态：</p>\n<ul>\n<li>后台 Tab</li>\n<li>页面最小化</li>\n<li>手机锁屏</li>\n</ul>\n<p>浏览器会主动做这些事：</p>\n<ul>\n<li>延长定时器触发间隔</li>\n<li>甚至直接暂停执行</li>\n</ul>\n<p>结果就是：</p>\n<blockquote>\n<p>用户切个 Tab 回来，<br />\n倒计时还显示 10 秒，<br />\n实际活动已经结束。</p>\n</blockquote>\n<p><strong>对活动类业务，这是不能接受的。</strong></p>\n<hr />\n<h3 id=\"settimeout-递归本质问题没变\">setTimeout 递归，本质问题没变</h3>\n<p>可能有的会写成这样：</p>\n<pre><code class=\"language-js\">function tick() {\n  setTimeout(() =&gt; {\n    remainTime--\n    tick()\n  }, 1000)\n}\n</code></pre>\n<p>看起来比 <code>setInterval</code> 稳一点，但实际上：</p>\n<ul>\n<li>依然受线程影响</li>\n<li>依然受浏览器限流</li>\n<li>依然不可靠</li>\n</ul>\n<p>只是“写法高级了”，问题没解决。</p>\n<hr />\n<h2 id=\"二倒计时的核心思路必须反过来\">二、倒计时的核心思路必须反过来</h2>\n<h3 id=\"错误思路很多第一版代码\">错误思路（很多第一版代码）</h3>\n<blockquote>\n<p>“我现在有 60 秒，每秒减 1”</p>\n</blockquote>\n<h3 id=\"正确思路真实业务\">正确思路（真实业务）</h3>\n<blockquote>\n<p>“活动有一个<strong>确定的结束时间点</strong>，我只计算<strong>当前时间与结束时间的差值</strong>”</p>\n</blockquote>\n<hr />\n<h3 id=\"正确的倒计时模型\">正确的倒计时模型</h3>\n<ol>\n<li>后端返回活动结束时间戳（<code>endTime</code>）</li>\n<li>前端永远不存“剩余秒数”</li>\n<li>每次渲染时：</li>\n</ol>\n<pre><code class=\"language-js\">const remain = endTime - Date.now()\n</code></pre>\n<blockquote>\n<p>前提是： <code>Date.now()</code> 是可信的</p>\n</blockquote>\n<p>这样做的好处是：</p>\n<ul>\n<li>页面卡顿不影响</li>\n<li>切 Tab 不影响</li>\n<li>页面刷新不影响</li>\n<li>时间一定是真实世界的时间</li>\n</ul>\n<hr />\n<h2 id=\"三requestanimationframe-在倒计时里的正确用法\">三、requestAnimationFrame 在倒计时里的正确用法</h2>\n<p>那么有的就得来犟一下：</p>\n<blockquote>\n<p>那是不是可以用 requestAnimationFrame？</p>\n</blockquote>\n<h3 id=\"nonono是这样的\">nonono，是这样的</h3>\n<blockquote>\n<p><strong>requestAnimationFrame 适合“展示型倒计时”，不适合直接当计时器。</strong></p>\n</blockquote>\n<hr />\n<h3 id=\"为什么-raf-比-setinterval-好一点\">为什么 rAF 比 setInterval 好一点？</h3>\n<ul>\n<li>跟随浏览器刷新节奏（通常 60fps）</li>\n<li>页面不可见时自动暂停（省性能）</li>\n<li>不会出现多个定时器竞争</li>\n</ul>\n<p>但它的问题也很明显：</p>\n<ul>\n<li>后台直接停</li>\n<li>不保证时间间隔</li>\n<li>本质还是“帧驱动”，不是“时间驱动”</li>\n</ul>\n<hr />\n<h3 id=\"正确用法raf--时间戳差值\">正确用法：rAF + 时间戳差值</h3>\n<pre><code class=\"language-js\">function startCountdown(endTime, update) {\n  function loop() {\n    const remain = endTime - Date.now()\n\n    if (remain &lt;= 0) {\n      update(0)\n      return\n    }\n\n    update(remain)\n    requestAnimationFrame(loop)\n  }\n\n  loop()\n}\n</code></pre>\n<ol>\n<li>rAF 只负责触发更新</li>\n<li>时间完全由 <code>Date.now()</code> 决定</li>\n<li>不用 rAF 去「数秒」</li>\n</ol>\n<p>这种方式非常适合：</p>\n<ul>\n<li>大屏倒计时</li>\n<li>动画数字变化</li>\n<li>强 UI 表现的倒计时</li>\n</ul>\n<hr />\n<h2 id=\"四真实业务里的性能坑\">四、真实业务里的性能坑</h2>\n<h3 id=\"多个倒计时--多个定时器\">多个倒计时 = 多个定时器</h3>\n<p>列表页如果有 20 个活动：</p>\n<ul>\n<li>20 个 <code>setInterval</code></li>\n<li>页面性能直线下降</li>\n</ul>\n<h3 id=\"组件卸载忘记清理\">组件卸载忘记清理</h3>\n<ul>\n<li>内存泄漏</li>\n<li>幽灵定时器</li>\n<li>难以排查的线上问题</li>\n</ul>\n<h3 id=\"前后端时间不同步\">前后端时间不同步</h3>\n<ul>\n<li>前端显示没结束</li>\n<li>后端接口已判定结束</li>\n<li>用户点击直接报错</li>\n</ul>\n<hr />\n<h2 id=\"五重点来了第三方方案怎么选\">五、重点来了：第三方方案怎么选？</h2>\n<h3 id=\"dayjs--date-fns强烈推荐\">dayjs / date-fns（强烈推荐）</h3>\n<p>它们<strong>不是倒计时库</strong>，但非常适合做倒计时。</p>\n<p>示例（dayjs）：</p>\n<pre><code class=\"language-js\">import dayjs from 'dayjs'\n\nconst endTime = dayjs('2026-01-30 20:00:00')\n\nsetInterval(() =&gt; {\n  const diff = endTime.diff(dayjs(), 'second')\n  console.log(diff &gt; 0 ? diff : 0)\n}, 1000)\n</code></pre>\n<ol>\n<li>时间计算可靠</li>\n<li>不依赖定时器精度</li>\n<li>和后端时间模型一致</li>\n</ol>\n<p><strong>这是我线上最常用的方案之一。</strong></p>\n<hr />\n<h3 id=\"自己封装一个全局时间驱动器\">自己封装一个「全局时间驱动器」</h3>\n<p>这是很多成熟项目最终都会走到的一步。</p>\n<p>核心思想：</p>\n<ul>\n<li>全局只存在一个 timer / rAF</li>\n<li>所有倒计时组件订阅它</li>\n<li>统一调度、统一销毁</li>\n</ul>\n<p>简单示意：</p>\n<pre><code class=\"language-js\">const listeners = new Set()\n\nsetInterval(() =&gt; {\n  const now = Date.now()\n  listeners.forEach(fn =&gt; fn(now))\n}, 1000)\n\nexport function subscribe(fn) {\n  listeners.add(fn)\n  return () =&gt; listeners.delete(fn)\n}\n</code></pre>\n<p>组件只关心：</p>\n<pre><code class=\"language-js\">subscribe(now =&gt; {\n  remain.value = endTime - now\n})\n</code></pre>\n<ol>\n<li>性能稳定</li>\n<li>行为一致</li>\n<li>易维护</li>\n</ol>\n<hr />\n<h3 id=\"ui-倒计时组件慎用\">UI 倒计时组件（慎用）</h3>\n<p>很多组件库提供：</p>\n<ul>\n<li><code>&lt;Countdown /&gt;</code></li>\n<li><code>&lt;Timer /&gt;</code></li>\n</ul>\n<p>适合：</p>\n<ul>\n<li>展示</li>\n<li>Demo</li>\n<li>非关键业务</li>\n</ul>\n<p>不适合：</p>\n<ul>\n<li>活动判定</li>\n<li>支付</li>\n<li>风控相关逻辑</li>\n</ul>\n<p><strong>展示可以用，业务别依赖。</strong></p>\n<hr />\n<h2 id=\"六so\">六、SO</h2>\n<blockquote>\n<p><strong>倒计时不是在“数秒”，而是点对点的时间差。</strong></p>\n</blockquote>\n<ul>\n<li><code>setTimeout / setInterval</code><br />\n只能当“触发器”</li>\n<li><code>requestAnimationFrame</code><br />\n只负责“渲染节奏”</li>\n<li>真正的时间<br />\n永远来自<strong>时间戳差值</strong></li>\n</ul>\n<p>如果一个倒计时：</p>\n<ul>\n<li>切 Tab 就不准</li>\n<li>刷新就重置</li>\n<li>和后端状态对不上</li>\n</ul>\n<p>那它<strong>大概率不是 UI 问题，而是时间模型错了。</strong></p>\n<p>再记住三个原则：</p>\n<ol>\n<li>前端时间永远不能当权威</li>\n<li>用「服务端时间差」而不是本地时间（服务端多分布只允许一个地方定义）</li>\n<li>关键状态以接口返回为准</li>\n</ol>\n<p>为什么说这三个，大家可以好好思考下，评论区欢迎大家讨论！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 11:44</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zxlh1529\">幼儿园技术家</a>&nbsp;\n阅读(<span id=\"post_view_count\">234</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "istio初探以及解决http-426的问题",
      "link": "https://www.cnblogs.com/MrVolleyball/p/19547269",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/MrVolleyball/p/19547269\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 11:19\">\n    <span>istio初探以及解决http-426的问题</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>在之前的文章中，我们花了大量的篇幅，从记录后端pod真实ip开始说起，然后引入envoy，再解决了各种各样的需求：配置自动重载、流量劫持、sidecar自动注入，到envoy的各种能力：熔断、流控、分流、透明代理、可观测性等等，已经可以支撑起一个完整的服务治理框架了</p>\n<p>而今天介绍的istio，正是前面提到的这些所有功能的集大成者，从本文开始，我们将详细介绍istio，并且与之前手搓的功能做一个详细的对比，为大家以后选择服务治理的某个功能提供参考</p>\n<h2 id=\"istio架构\">istio架构</h2>\n<pre><code>           ┌──────────────┐\n           │   istiod     │   ← 控制面\n           │ (Pilot+CA)   │\n           └──────┬───────┘\n                  │ xDS (gRPC / TLS)\n                  │\n┌────────────┐    │    ┌────────────┐\n│  Envoy     │◄───┼───►│   Envoy    │  ← 数据面\n│ (Sidecar)  │         │ (Sidecar)  │\n└─────▲──────┘         └─────▲──────┘\n      │ iptables             │\n      │                      │\n   App Pod                App Pod\n\n</code></pre>\n<ul>\n<li>数据面就是之前一直在研究的envoy，包括4/7代理、熔断、限流、可观测性等等，envoy就是执行由控制面下发的配置</li>\n<li>控制面istiod主要的职责：将配置下发到每一个envoy去。由于istio中配置以crd的形式成为了k8s的资源，所以要不断的监听k8s apiserver，将资源的变化翻译成envoy看得懂的配置，并且下发到envoy去</li>\n</ul>\n<p>至于其余istio的资源，我们后面详细介绍</p>\n<h2 id=\"istio安装\">istio安装</h2>\n<p>不说废话，先把istio安装上去再说</p>\n<p>首先准备好k8s集群，其次下载istio（这一步有可能需要上网）</p>\n<pre><code>curl -L https://istio.io/downloadIstio | sh -\ncd istio-*\nsudo ln -s $PWD/istioctl /usr/local/bin/istioctl\n</code></pre>\n<p>验证兼容性</p>\n<pre><code>istioctl x precheck\n</code></pre>\n<p>开始安装</p>\n<pre><code>istioctl install --set profile=default -y\n</code></pre>\n<p>由于镜像仓库没法直接使用，所以需要一些特殊的方法，具体可以看这篇文章： <a href=\"https://mp.weixin.qq.com/s/Vwesi9_8ThdODfkMi1033Q\" rel=\"noopener nofollow\" target=\"_blank\">快速拉取docker镜像</a></p>\n<p>需要的镜像有：</p>\n<pre><code>docker.io/istio/pilot:1.28.2\ndocker.io/istio/proxyv2:1.28.2\n</code></pre>\n<p>安装完成：</p>\n<pre><code>▶ kubectl -n istio-system get pod\nNAME                                    READY   STATUS    RESTARTS   AGE\nistio-ingressgateway-865c448856-qs8s2   1/1     Running   0          8s\nistiod-86c75775bb-j7qbg                 1/1     Running   0          12s\n\n</code></pre>\n<p>安装完成，要从哪儿开始呢？</p>\n<h2 id=\"istio的自动注入\">istio的自动注入</h2>\n<pre><code>kubectl label namespace default istio-injection=enabled\n</code></pre>\n<p>同之前envoy一样，给namespace打上标签之后，重启服务即可</p>\n<pre><code>kubectl rollout restart deploy nginx-test\n</code></pre>\n<p>重启之后sidecar已经注入进去了，我们来观察一下istio注入到底做了什么事情</p>\n<p>先describe看看events</p>\n<pre><code>Events:\n  Type    Reason     Age   From               Message\n  ----    ------     ----  ----               -------\n  Normal  Scheduled  8s    default-scheduler  Successfully assigned default/nginx-test-6f855b9bb9-9phsv to wilson\n  Normal  Pulled     8s    kubelet            Container image \"docker.io/istio/proxyv2:1.28.2\" already present on machine\n  Normal  Created    8s    kubelet            Created container: istio-init\n  Normal  Started    8s    kubelet            Started container istio-init\n  Normal  Pulled     8s    kubelet            Container image \"docker.io/istio/proxyv2:1.28.2\" already present on machine\n  Normal  Created    8s    kubelet            Created container: istio-proxy\n  Normal  Started    8s    kubelet            Started container istio-proxy\n  Normal  Pulled     6s    kubelet            Container image \"registry.cn-beijing.aliyuncs.com/wilsonchai/nginx:latest\" already present on machine\n  Normal  Created    6s    kubelet            Created container: nginx-test\n  Normal  Started    5s    kubelet            Started container nginx-test\n\n</code></pre>\n<p>1个initContainer，1个业务container和1个sidecar</p>\n<p>其中initContainer：</p>\n<pre><code>Init Containers:\n  istio-init:\n    Container ID:  containerd://2bf56cd37703d82a2a43e94e8c8d683ed66b0afe22bf7148a597d67b89a727a8\n    Image:         docker.io/istio/proxyv2:1.28.2\n    Image ID:      docker.m.daocloud.io/istio/proxyv2@sha256:39065152d6bd3e7fbf6bb04be43c7a8bbd16b5c7181c84e3d78fa164a945ae7f\n    Port:          &lt;none&gt;\n    Host Port:     &lt;none&gt;\n    Args:\n      istio-iptables\n      -p\n      15001\n      -z\n      15006\n      -u\n      1337\n      -m\n      REDIRECT\n      -i\n      *\n      -x\n\n      -b\n      *\n      -d\n      15090,15021,15020\n      --log_output_level=default:info\n...\n</code></pre>\n<p>和之前envoy中劫持流量的做法一样，istio依然是使用iptables将端口流量导入到代理之中处理</p>\n<p>尝试访问一下：</p>\n<pre><code>▶ curl 10.22.12.178:30785/test\ni am backend in backend-6d76f54494-g6srz\n</code></pre>\n<p>成功，再次查看istio-proxy日志。空的？为了调试方便，将其打开并且输出至控制台</p>\n<pre><code>kubectl -n istio-system edit cm istio\n\napiVersion: v1\ndata:\n  mesh: |-\n    accessLogFile: /dev/stdout\n  ...\n</code></pre>\n<p>至此，istio的第一个功能探索完毕，自动注入sidecar container并且完成了流量劫持</p>\n<h2 id=\"upgrade-required-426-的问题\">Upgrade Required 426 的问题</h2>\n<p>当前的架构是左图，现在要前进到右图</p>\n<p><img alt=\"watermarked-istio_1\" class=\"lazyload\" /></p>\n<p>其实就是在backend注入istio-proxy，直接重启就好</p>\n<pre><code>▶ kubectl get pod -owide\nNAME                          READY   STATUS        RESTARTS   AGE     IP            NODE     NOMINATED NODE   READINESS GATES\nbackend-5d4d7b598c-f7852      2/2     Running       0          13s     10.244.0.49   wilson   &lt;none&gt;           &lt;none&gt;\nnginx-test-6f855b9bb9-9phsv   2/2     Running       0          58m     10.244.0.48   wilson   &lt;none&gt;           &lt;none&gt;\n\n</code></pre>\n<p>注入完成，测试一下</p>\n<pre><code>▶ curl 10.22.12.178:30785/test\nUpgrade Required\n</code></pre>\n<pre><code>▶ kubectl logs -f -l app=nginx-test -c istio-proxy\n[2026-01-26T07:54:42.977Z] \"GET /test HTTP/1.1\" 426 - upstream=10.244.0.48:80 duration=6ms route=default\n[2026-01-26T07:54:42.978Z] \"- - -\" 0 - upstream=10.105.148.194:10000 duration=9ms route=-\n\n</code></pre>\n<p>在nginx注入istio-proxy，backend没有注入的时候并没有报错。而一旦nginx与backend都注入的时候就会出现Upgrade Required (426)错误，Nginx Sidecar 发现目标（Backend）是一个纯文本服务，它会回退到“透明代理”模式，简单地把 Nginx 发出的流量透传出去</p>\n<p>Nginx Sidecar 发现目标也有 Sidecar，它会尝试建立一个高度优化的、基于 mTLS 的隧道（关于mTLS后面会详细介绍）。如果此时 Nginx 发出的请求头（比如缺少 Host 字段，或者使用了 HTTP/1.0）不符合 Envoy 对这种隧道<br />\n协议的预期，Envoy 可能会向 Nginx 发送一个特殊的响应，或者 Nginx 在尝试通过这种隧道通信时，因为某些 Header 冲突（如 Connection: close）自发产生了 426 错误</p>\n<p>想要解决这个问题有两种方法</p>\n<h4 id=\"改造nginx中加入标记\">改造nginx中加入标记</h4>\n<pre><code>        location /test {\n            proxy_http_version 1.1; # 必须添加这一行\n            proxy_set_header Host $host; # 这一行也是必须的\n            proxy_pass http://backend_ups;\n        }\n\n</code></pre>\n<p>Nginx 的 proxy_pass 默认使用 HTTP/1.0。在 Istio 环境中，HTTP/1.0 不支持长连接（Keep-Alive）以及一些现代的协议协商，这与 Istio Sidecar（Envoy）默认的 L7 代理行为冲突，Istio 需要 HTTP/1.1 来支持复杂连接管理问题</p>\n<h4 id=\"改造backend-service\">改造backend service</h4>\n<p>如果nginx改造有难度，那也可以尝试改造backend-service</p>\n<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\n  namespace: default\nspec:\n  ports:\n  - name: tcp-80 # 原为 http-80 改为 tcp-80\n    port: 10000\n    protocol: TCP\n    targetPort: 10000\n  selector:\n    app: backend\n\n</code></pre>\n<p>Istio 只有在识别到流量是 HTTP 时才会进行深度的协议检查和转换。如果你把这个服务声明为 TCP，Istio 就会将其视为原始字节流进行透传，不再关心它是 HTTP/1.0 还是 1.1。优点就是彻底解决 426 问题，无需改 Nginx。<br />\n缺点则是你会失去 Istio 针对该服务的 HTTP 监控指标（如请求数、4xx/5xx 统计）、分布式追踪以及基于路径的路由功能</p>\n<h2 id=\"http-10-与-http-11\">http 1.0 与 http 1.1</h2>\n<p>这里再简单介绍一下两个协议版本的区别</p>\n<ul>\n<li>\n<p>连接管理（最显著的区别）</p>\n<ul>\n<li>HTTP 1.0：短连接 (Short-lived)，默认情况下，客户端每发起一个请求，都要与服务器建立一次 TCP 三次握手。请求结束并收到响应后，TCP 连接立即关闭。如果页面有 10 张图片，浏览器就要建立 10 次 TCP 连接。这带来了极高的延迟和资源开销。</li>\n<li>HTTP 1.1：持久连接 (Persistent Connection / Keep-Alive)。默认开启 Connection: keep-alive。一个 TCP 连接可以被多个请求复用。只有在明确声明 Connection: close 或连接超时后才会关闭。</li>\n<li>在 Istio 中： Envoy 极度依赖持久连接来维持高性能的 Sidecar 间隧道。HTTP 1.0 的频繁断开会让 Envoy 感到“压力山大”，甚至认为这是一种非标准的协议行为。</li>\n</ul>\n</li>\n<li>\n<p>Host Header</p>\n<ul>\n<li>HTTP 1.0：人们认为一个 IP 对应一个网站，所以请求头里不需要带域名信息。</li>\n<li>HTTP 1.1：随着虚拟主机（一个 IP 跑多个网站）的流行，HTTP 1.1 规定请求头必须包含 Host 字段。</li>\n<li>在 K8s/Istio 中： Istio 的路由决策、Service 的匹配完全依赖 Host 头。这也是为什么 Nginx 使用 HTTP 1.0 转发时，如果不手动补全 Host 头，后端往往会返回 404 或协议错误。</li>\n</ul>\n</li>\n</ul>\n<p>以上是istio必须要求HTTP 1.1最主要的两个因素，当然还有其他非常重要的区别</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>HTTP 1.0</th>\n<th>HTTP 1.1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>连接模型</td>\n<td>默认短连接，每次请求新开 TCP</td>\n<td>默认持久连接 (Keep-Alive)，复用 TCP</td>\n</tr>\n<tr>\n<td>Host 头部</td>\n<td>可选 (导致无法支持虚拟主机)</td>\n<td>必须 (支持一 IP 多域名)</td>\n</tr>\n<tr>\n<td>流水线 (Pipelining)</td>\n<td>不支持</td>\n<td>支持 (但在实际应用中受限)</td>\n</tr>\n<tr>\n<td>断点续传</td>\n<td>不支持</td>\n<td>支持 (通过 Range 头部)</td>\n</tr>\n<tr>\n<td>缓存控制</td>\n<td>简单 (Expires)</td>\n<td>复杂且强大 (Cache-Control, ETag)</td>\n</tr>\n<tr>\n<td>默认协议版本</td>\n<td>许多旧软件(如 Nginx proxy)的默认值</td>\n<td>现代 Web 应用的基石标准</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"小结\">小结</h2>\n<p>本章内容算是一个开胃小菜，成功安装了istio，并且解决了一个非常常见的426问题，至于怎么把之前在envoy的那些最佳实践搬迁到istio，那就是后面的内容了，敬请期待</p>\n<h2 id=\"后记\">后记</h2>\n<p>如果整个namespace都已经有了注入标签<code>istio-injection=enabled</code>，但是某个deployment不想让istio注入</p>\n<pre><code>kubectl patch deployment nginx -p '{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"sidecar.istio.io/inject\":\"false\"}}}}}'\n</code></pre>\n<h2 id=\"联系我\">联系我</h2>\n<ul>\n<li>联系我，做深入的交流</li>\n</ul>\n<p><img alt=\"\" class=\"lazyload\" height=\"200\" width=\"500\" /></p>\n<hr />\n<p>至此，本文结束<br />\n在下才疏学浅，有撒汤漏水的，请各位不吝赐教...</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/MrVolleyball/\" target=\"_blank\">it排球君</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/MrVolleyball/p/19547269\" target=\"_blank\">https://www.cnblogs.com/MrVolleyball/p/19547269</a></p>\n<div>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须在文章页面给出原文连接，否则保留追究法律责任的权利。 </div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 11:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/MrVolleyball\">it排球君</a>&nbsp;\n阅读(<span id=\"post_view_count\">60</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从0到1打造Skill：完整实战指南",
      "link": "https://www.cnblogs.com/deep-sky/p/19550524",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/deep-sky/p/19550524\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 21:44\">\n    <span>从0到1打造Skill：完整实战指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"引言\">引言</h3>\n<p>最近 Skill 可谓热度颇高，无论是微信公众号还是博客园，都能看到大量围绕 Skill 的开发实践、落地方式以及发展趋势的文章。既然如此，我也打算凑个热闹，从实战的角度写一篇关于 Skill 的实践分享。</p>\n<p>在展开之前，先简要说明一下什么是 Skill。Skills 的概念由 Anthropic 提出，本质上是一种更高层次的模块化能力封装，用于扩展智能体的功能边界。每一个 Skill 都封装了指令、元数据以及可选的资源（如脚本、模板等），智能体在执行任务时，会根据上下文相关性自动选择并调用合适的 Skill。</p>\n<h4 id=\"skills能提供什么\">Skills能提供什么？</h4>\n<ol>\n<li>专业工作流 - 特定领域的多步骤操作流程</li>\n<li>工具集成 - 使用特定文件格式或 API 的指导说明</li>\n<li>领域专长 - 企业特有知识、数据架构、业务规则</li>\n<li>资源包 - 处理复杂和重复任务所需的脚本、参考文档和相关资源</li>\n</ol>\n<p>对Skill不了解的同学可以看下我之前的一篇文章 <a href=\"https://www.cnblogs.com/deep-sky/p/19458519\" target=\"_blank\">Claude Skills是什么？为什么要引入Skills？</a></p>\n<h3 id=\"开发个什么skill呢\">开发个什么Skill呢？</h3>\n<p>通过 Skill，我们可以将某些能力进行模块化封装，从而实现特定的工作流编排、专家领域知识沉淀以及各类工具的集成。<br />\n这里我打算来一次“套娃式”的实践：创建一个用于自动生成 Skill 的 Skill，一是用来展示如何创建Skill，二是通过这种方式再深入理解下Skill的设计理念。在实际使用时，用户只需要输入该 Skill 的功能描述、使用场景以及示例用法，系统便可以自动生成对应的 Skill 说明文档、描述信息等配套内容。把这个自动生成Skill的Skill命名成：<code>skill-creator</code>。</p>\n<p>下面，我们按照步骤向<code>skill-creator</code>的SKILL.md文件中写入以下内容：</p>\n<h4 id=\"一定义skill-creator的描述信息\">一、定义<code>skill-creator</code>的描述信息</h4>\n<pre><code>---\nname: skill-creator\ndescription: 生成有效技能的指南。当用户想要创建新技能（或更新现有技能）时，应该使用此技能，该技能可以通过专业知识、工作流或工具集成来扩展Claude的能力。\n---\n</code></pre>\n<h4 id=\"二解释下skill和关于skill\">二、解释下Skill和关于Skill</h4>\n<p>技能是模块化的、自包含的软件包，通过提供专业知识、工作流程和工具来扩展 Claude 的能力。可以把它们想象成特定领域或任务的\"入职指南\"——它们将 Claude 从通用型智能体转变为专业型智能体，使其具备任何模型都无法完全拥有的程序性知识。</p>\n<h5 id=\"skills能提供什么-1\">Skills能提供什么？</h5>\n<ol>\n<li>专业工作流 - 特定领域的多步骤操作流程</li>\n<li>工具集成 - 使用特定文件格式或 API 的指导说明</li>\n<li>领域专长 - 企业特有知识、数据架构、业务规则</li>\n<li>资源包 - 处理复杂和重复任务所需的脚本、参考文档和相关资源</li>\n</ol>\n<h5 id=\"核心理念\">核心理念</h5>\n<h6 id=\"简洁至上\">简洁至上</h6>\n<p>上下文窗口是一种公共资源。技能与 Claude 所需的其他所有内容共享上下文窗口：系统提示词、对话历史、其他技能的元数据以及实际的用户请求。</p>\n<p><strong>基本前提：Claude 本身已经很聪明。</strong> 只需添加 Claude 还不知道的内容。对每条信息都要提出质疑：\"Claude 真的需要这个说明吗？\" 和 \"这段内容的 token 成本值得吗？\"</p>\n<p>优先使用简洁的示例而非冗长的解释。</p>\n<h6 id=\"给予恰当的自由度\">给予恰当的自由度</h6>\n<p>根据任务的脆弱性和可变性来匹配具体程度：</p>\n<p><strong>高自由度（基于文本的指令）</strong>：当存在多种有效方法、决策取决于上下文，或通过启发式方法指导时使用。</p>\n<p><strong>中等自由度（带参数的伪代码或脚本）</strong>：当存在首选模式、可接受一定程度的变化，或配置会影响行为时使用。</p>\n<p><strong>低自由度（特定脚本、少量参数）</strong>：当操作容易出错且脆弱、一致性至关重要，或必须遵循特定顺序时使用。</p>\n<p>可以把 Claude 想象成在探索一条路径：悬崖边的狭窄桥梁需要具体的护栏（低自由度），而开阔的田野则允许多条路线（高自由度）。</p>\n<h4 id=\"三生成的skill有哪些组成部分\">三、生成的Skill有哪些组成部分</h4>\n<p>每个技能都包含一个必需的 SKILL.md 文件和可选的捆绑资源：</p>\n<pre><code>skill-name/\n├── SKILL.md (required)\n│   ├── YAML frontmatter metadata (required)\n│   │   ├── name: (required)\n│   │   └── description: (required)\n│   └── Markdown instructions (required)\n└── Bundled Resources (optional)\n    ├── scripts/          - Executable code (Python/Bash/etc.)\n    ├── references/       - Documentation intended to be loaded into context as needed\n    └── assets/           - Files used in output (templates, icons, fonts, etc.)\n</code></pre>\n<h5 id=\"什么是skillmd\">什么是SKILL.md</h5>\n<p>每个SKILL.md包含：</p>\n<ul>\n<li><strong>头部元数据</strong>（YAML 格式）：包含 <code>name</code>（名称）和 <code>description</code>（描述）字段。这些是 Claude 判断何时使用技能的唯一依据，因此清晰、全面地描述技能的功能和使用场景非常重要。</li>\n<li><strong>主体内容</strong>（Markdown 格式）：关于如何使用该技能的说明和指引。只有在技能被触发后才会加载（如果被触发的话）。</li>\n</ul>\n<h5 id=\"可选的捆绑资源\">可选的捆绑资源</h5>\n<h6 id=\"脚本-scripts\">脚本 (<code>scripts/</code>)</h6>\n<p>可执行代码（Python/Bash 等），适用于需要确保可靠性或经常重复编写的任务。</p>\n<ul>\n<li><strong>何时使用</strong>：当同一段代码需要反复编写，或需要确定性的可靠执行时</li>\n<li><strong>举例</strong>：<code>scripts/rotate_pdf.py</code> 用于 PDF 旋转操作</li>\n<li><strong>优点</strong>：节省 token、结果确定、可能直接执行而无需加载到上下文</li>\n<li><strong>说明</strong>：Claude 仍可能需要读取脚本以进行修改或适配特定环境</li>\n</ul>\n<h6 id=\"参考资料-references\">参考资料 (<code>references/</code>)</h6>\n<p>文档和参考材料，按需加载到上下文中，用于指导 Claude 的工作流程和思考方式。</p>\n<ul>\n<li><strong>何时使用</strong>：当 Claude 工作时需要查阅的文档资料</li>\n<li><strong>举例</strong>：财务架构文档 <code>references/finance.md</code>、公司保密协议模板 <code>references/mnda.md</code>、公司制度 <code>references/policies.md</code>、API 规范 <code>references/api_docs.md</code></li>\n<li><strong>适用场景</strong>：数据库模式、API 文档、专业领域知识、企业政策、详细操作指南</li>\n<li><strong>优点</strong>：让 SKILL.md 保持简洁，只在 Claude 需要时才加载</li>\n<li><strong>最佳实践</strong>：如果文件很大（超过 1 万字），在 SKILL.md 中添加 grep 搜索模式</li>\n<li><strong>避免重复</strong>：信息应该只放在 SKILL.md 或参考文件的其中一处，不要两边都有。详细信息优先放在参考文件中，除非真的是技能核心——这样既能保持 SKILL.md 简洁，又能让信息易于查找而不会占满上下文窗口。SKILL.md 只保留关键的操作说明和流程指引；详细的参考资料、架构图和示例都移到参考文件里。</li>\n</ul>\n<h6 id=\"资源文件-assets\">资源文件 (<code>assets/</code>)</h6>\n<p>无需加载到上下文的文件，主要用于 Claude 产生的最终输出内容中。</p>\n<ul>\n<li><strong>何时使用</strong>：技能需要在最终成果中用到的文件</li>\n<li><strong>举例</strong>：品牌素材 <code>assets/logo.png</code>、PowerPoint 模板 <code>assets/slides.pptx</code>、HTML/React 脚手架 <code>assets/frontend-template/</code>、字体文件 <code>assets/font.ttf</code></li>\n<li><strong>适用场景</strong>：模板文件、图像、图标、样板代码、字体、需要复制或修改的样例文档</li>\n<li><strong>优点</strong>：把输出用的资源和说明文档分开，让 Claude 可以使用这些文件而不占用上下文空间</li>\n</ul>\n<h6 id=\"技能中不应包含的内容\">技能中不应包含的内容</h6>\n<p>技能应仅包含直接支持其功能的核心文件。不要创建无关的文档或辅助文件，例如：</p>\n<ul>\n<li>README.md</li>\n<li>INSTALLATION_GUIDE.md（安装指南）</li>\n<li>QUICK_REFERENCE.md（快速参考）</li>\n<li>CHANGELOG.md（变更日志）</li>\n<li>等等</li>\n</ul>\n<p>技能只应包含 AI 智能体执行任务所需的信息。不应包含创建过程的附加说明、安装测试步骤、用户使用文档等辅助内容。添加额外的文档文件只会造成混乱和干扰。</p>\n<h4 id=\"四渐进式展开设计原则\">四、渐进式展开设计原则</h4>\n<p>技能使用三级加载系统来高效管理上下文：</p>\n<ol>\n<li><strong>元数据（名称 + 描述）</strong> - 始终在上下文中（约100字）</li>\n<li><strong>SKILL.md 正文</strong> - 当技能触发时（&lt;五千字）</li>\n<li><strong>捆绑资源</strong> - 根据 Claude 需要（无限制，因为脚本可以在不读入上下文窗口的情况下执行）</li>\n</ol>\n<h5 id=\"渐进式展示模式\">渐进式展示模式</h5>\n<p>保持 SKILL.md 主体内容精简，控制在 500 行以内，避免上下文过度膨胀。接近这个限制时，应将内容拆分成独立文件。拆分内容时，务必在 SKILL.md 中引用这些文件，并明确说明何时查阅，确保技能使用者知道这些文件的存在及其使用时机。</p>\n<p><strong>核心原则：</strong> 当技能支持多种变体、框架或选项时，SKILL.md 中只保留核心工作流和选择指引。将各变体的具体细节（模式、示例、配置）移至独立的参考文件。</p>\n<h4 id=\"五skill创建流程\">五、Skill创建流程</h4>\n<p>技能创建包括以下步骤：</p>\n<ol>\n<li>通过具体示例理解技能</li>\n<li>规划可重用的技能内容（脚本、参考资料、资源文件）</li>\n<li>初始化技能（运行 init_skill.py）</li>\n<li>编辑技能（实现资源并编写 SKILL.md）</li>\n<li>打包技能（运行 package_skill.py）</li>\n<li>基于实际使用进行迭代</li>\n</ol>\n<p>按顺序遵循这些步骤，除非有明确理由说明某步骤不适用才可跳过。</p>\n<h5 id=\"步骤-1通过具体示例理解技能\">步骤 1：通过具体示例理解技能</h5>\n<p>仅当技能的使用模式已经非常清楚时才跳过此步骤。即使在处理现有技能时，这一步骤仍然很有价值。</p>\n<p>要创建有效的技能，需要清楚理解该技能将如何被使用的具体示例。这种理解可以来自用户直接提供的示例，或经过用户反馈验证的生成示例。</p>\n<p>例如，在构建图像编辑器技能时，相关问题包括：</p>\n<ul>\n<li>\"图像编辑器技能应该支持什么功能？编辑、旋转，还有其他吗？\"</li>\n<li>\"你能给出一些这个技能如何使用的示例吗？\"</li>\n<li>\"我可以想象用户会提出'去除这张图片的红眼'或'旋转这张图片'之类的请求。你还能想到这个技能的其他使用方式吗？\"</li>\n<li>\"用户会说什么来触发这个技能？\"</li>\n</ul>\n<p>为避免让用户不知所措，避免在单条消息中提出太多问题。从最重要的问题开始，根据需要跟进以提高效率。</p>\n<p>当对技能应支持的功能有了清晰认识时，即可结束此步骤。</p>\n<h5 id=\"步骤-2规划可重用的技能内容\">步骤 2：规划可重用的技能内容</h5>\n<p>要将具体示例转化为有效的技能，需要通过以下方式分析每个示例：</p>\n<ol>\n<li>考虑如何从零开始执行该示例</li>\n<li>识别在重复执行这些工作流程时哪些脚本、参考资料和资源文件会有帮助</li>\n</ol>\n<p>示例：在构建 <code>pdf-editor</code> 技能来处理\"帮我旋转这个 PDF\"之类的查询时，分析显示：</p>\n<ol>\n<li>旋转 PDF 每次都需要重写相同的代码</li>\n<li>将 <code>scripts/rotate_pdf.py</code> 脚本存储在技能中会很有帮助</li>\n</ol>\n<p>示例：在设计 <code>frontend-webapp-builder</code> 技能来处理\"给我做个待办事项应用\"或\"做个仪表板追踪我的步数\"之类的查询时，分析显示：</p>\n<ol>\n<li>编写前端网页应用每次都需要相同的样板 HTML/React 代码</li>\n<li>将包含样板 HTML/React 项目文件的 <code>assets/hello-world/</code> 模板存储在技能中会很有帮助</li>\n</ol>\n<p>示例：在构建 <code>big-query</code> 技能来处理\"今天有多少用户登录了？\"之类的查询时，分析显示：</p>\n<ol>\n<li>查询 BigQuery 每次都需要重新发现表结构和关系</li>\n<li>将记录表结构的 <code>references/schema.md</code> 文件存储在技能中会很有帮助</li>\n</ol>\n<p>要确定技能的内容，需要分析每个具体示例，创建要包含的可重用资源清单：脚本、参考资料和资源文件。</p>\n<h5 id=\"步骤-3初始化技能\">步骤 3：初始化技能</h5>\n<p>到这一步，就该真正创建技能了。</p>\n<p>仅当正在开发的技能已经存在，需要进行迭代或打包时才跳过此步骤。在这种情况下，继续下一步。</p>\n<p>从零开始创建新技能时，始终运行 <code>init_skill.py</code> 脚本。该脚本会方便地生成一个新的技能目录模板，自动包含技能所需的一切，使技能创建过程更加高效和可靠。</p>\n<p>用法：</p>\n<pre><code class=\"language-bash\">scripts/init_skill.py &lt;技能名称&gt; --path &lt;输出目录&gt;\n</code></pre>\n<p>该脚本会：</p>\n<ul>\n<li>在指定路径创建技能目录</li>\n<li>生成带有正确前言信息和待办事项占位符的 SKILL.md 模板</li>\n<li>创建示例资源目录：<code>scripts/</code>、<code>references/</code> 和 <code>assets/</code></li>\n<li>在每个目录中添加可以自定义或删除的示例文件</li>\n</ul>\n<p>初始化后，根据需要自定义或删除生成的 SKILL.md 和示例文件。</p>\n<h5 id=\"步骤-4编辑技能\">步骤 4：编辑技能</h5>\n<p>在编辑（新生成或现有的）技能时，请记住该技能是为另一个Claude实例使用而创建的。包含对Claude有益且不明显的信息。考虑哪些程序性知识、领域特定细节或可重用资源能帮助另一个Claude实例更有效地执行这些任务。</p>\n<h6 id=\"41-学习经过验证的设计模式\">4.1 学习经过验证的设计模式</h6>\n<p>根据技能需求，查阅以下有用的指南：</p>\n<ul>\n<li><strong>多步骤流程</strong>：参见 references/workflows.md 了解顺序工作流程和条件逻辑</li>\n<li><strong>特定输出格式或质量标准</strong>：参见 references/output-patterns.md 了解模板和示例模式</li>\n</ul>\n<p>这些文件包含了有效技能设计的成熟最佳实践。</p>\n<h6 id=\"42-从可重用的技能内容开始\">4.2 从可重用的技能内容开始</h6>\n<p>要开始实现，从上面识别的可重用资源开始：<code>scripts/</code>、<code>references/</code> 和 <code>assets/</code> 文件。请注意，此步骤可能需要用户输入。例如，在实现 <code>brand-guidelines</code> 技能时，用户可能需要提供品牌资源或模板存储在 <code>assets/</code> 中，或提供文档存储在 <code>references/</code> 中。</p>\n<p>添加的脚本必须通过实际运行来测试，以确保没有错误且输出符合预期。如果有许多类似的脚本，只需测试代表性样本即可确保它们都能工作，同时平衡完成时间。</p>\n<p>不需要用于该技能的任何示例文件和目录都应删除。初始化脚本会在 <code>scripts/</code>、<code>references/</code> 和 <code>assets/</code> 中创建示例文件来演示结构，但大多数技能不需要所有这些文件。</p>\n<h6 id=\"43-生成-skillmd文件\">4.3 生成 SKILL.md文件</h6>\n<p><strong>编写准则：</strong> 始终使用祈使句/不定式形式。</p>\n<ul>\n<li>前言信息</li>\n</ul>\n<p>编写包含 <code>name</code> 和 <code>description</code> 的 YAML 前言：</p>\n<ul>\n<li><code>name</code>：技能名称</li>\n<li><code>description</code>：这是技能的主要触发机制，帮助 Claude 理解何时使用该技能。\n<ul>\n<li>包含技能的功能和使用时机的具体触发条件/上下文。</li>\n<li>将所有\"何时使用\"的信息都包含在这里 - 不要放在正文中。正文只在触发后才加载，因此正文中的\"何时使用此技能\"部分对 Claude 没有帮助。</li>\n<li><code>docx</code> 技能的描述示例：\"全面的文档创建、编辑和分析功能，支持修订追踪、评论、格式保留和文本提取。当 Claude 需要处理专业文档（.docx 文件）时使用，包括：(1) 创建新文档，(2) 修改或编辑内容，(3) 处理修订追踪，(4) 添加评论，或任何其他文档任务\"。</li>\n</ul>\n</li>\n</ul>\n<p>不要在 YAML 前言中包含任何其他字段。</p>\n<ul>\n<li>正文</li>\n</ul>\n<p>编写使用该技能及其捆绑资源的说明。</p>\n<h4 id=\"六效果展示\">六、效果展示</h4>\n<p>在<code>cursor</code>和<code>claude code</code>对应的skills目录下新建 skill-creator 文件夹并将上述SKILL.md放在该文件夹下，在<code>cursor</code>和<code>claude code</code>中通过 /skill-creator唤起，例如在cursor中的效果是：<br />\n我想要生成一个为我拟定文章题目的Skill</p>\n<p><img alt=\"skill-creator-desc\" class=\"lazyload\" /></p>\n<p>使用效果：</p>\n<p><img alt=\"skill-creator-effect\" class=\"lazyload\" /></p>\n<p>生成后在skills目录下可以看到：</p>\n<p><img alt=\"tech-article-title-generator\" class=\"lazyload\" /></p>\n<p>在cursor中可以使用：</p>\n<p><img alt=\"tech\" class=\"lazyload\" /></p>\n<p>如果你已经使用过Skill，看到这里其实已经能明白：我实现的这个 skill-creator，本质上就是 开源的<a href=\"https://github.com/ComposioHQ/awesome-claude-skills/blob/master/skill-creator\" rel=\"noopener nofollow\" target=\"_blank\">Skill Creator</a>，只不过在这里对其做了一次翻译和封装。</p>\n<p>通过这种方式，一方面可以更直观地理解Skill的设计思路，另一方面也能在实践中加深对其使用方式和边界的认识。</p>\n<h4 id=\"一些好用的skills\">一些好用的Skills</h4>\n<p>下面是一些我觉得很好用的开源Skill是，分享给大家。</p>\n<h1 id=\"claude-skills-资源列表\">Claude Skills 资源列表</h1>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>用途</th>\n<th>下载链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docx</td>\n<td>用追踪修改、批注和格式化功能，轻松创建、编辑和分析 Word 文档。</td>\n<td><a href=\"https://github.com/anthropics/skills/tree/main/skills/docx\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/skills/tree/main/skills/docx</a></td>\n</tr>\n<tr>\n<td>pdf</td>\n<td>提取文本、表格、元数据，合并与标注 PDF 文件。</td>\n<td><a href=\"https://github.com/anthropics/skills/tree/main/skills/pdf\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/skills/tree/main/skills/pdf</a></td>\n</tr>\n<tr>\n<td>pptx</td>\n<td>读取、生成和调整幻灯片、布局与模板。</td>\n<td><a href=\"https://github.com/anthropics/skills/tree/main/skills/pptx\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/skills/tree/main/skills/pptx</a></td>\n</tr>\n<tr>\n<td>xlsx</td>\n<td>电子表格操作：公式、图表、数据转换。</td>\n<td><a href=\"https://github.com/anthropics/skills/tree/main/skills/xlsx\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/skills/tree/main/skills/xlsx</a></td>\n</tr>\n<tr>\n<td>Markdown to EPUB Converter</td>\n<td>将 Markdown 文档和聊天摘要转换为专业的 EPUB 电子书文件。</td>\n<td><a href=\"https://github.com/smerchek/claude-epub-skill\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/smerchek/claude-epub-skill</a></td>\n</tr>\n<tr>\n<td>MCP Builder</td>\n<td>指导你用 Python 或 TypeScript 创建高质量的 MCP（模型上下文协议）服务器，轻松将外部 API 和服务集成到 LLM 中。</td>\n<td><a href=\"https://github.com/ComposioHQ/awesome-claude-skills/blob/master/mcp-builder\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ComposioHQ/awesome-claude-skills/blob/master/mcp-builder</a></td>\n</tr>\n<tr>\n<td>prompt-engineering</td>\n<td>教你那些经典的提示工程技巧和模式，包括 Anthropic 的最佳实践和智能体说服原则，让你的提示效果直接拉满！</td>\n<td><a href=\"https://github.com/NeoLabHQ/context-engineering-kit/tree/master/plugins/customaize-agent/skills/prompt-engineering\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/NeoLabHQ/context-engineering-kit/tree/master/plugins/customaize-agent/skills/prompt-engineering</a></td>\n</tr>\n<tr>\n<td>Skill Creator</td>\n<td>手把手教你打造高效的 Claude 技能，通过专业领域知识、工作流和工具集成。</td>\n<td><a href=\"https://github.com/ComposioHQ/awesome-claude-skills/blob/master/skill-creator\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ComposioHQ/awesome-claude-skills/blob/master/skill-creator</a></td>\n</tr>\n<tr>\n<td>software-architecture</td>\n<td>实现了包括 Clean Architecture、SOLID 原则以及全面的软件设计最佳实践在内的设计模式。</td>\n<td><a href=\"https://github.com/NeoLabHQ/context-engineering-kit/tree/master/plugins/ddd/skills/software-architecture\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/NeoLabHQ/context-engineering-kit/tree/master/plugins/ddd/skills/software-architecture</a></td>\n</tr>\n<tr>\n<td>article-extractor</td>\n<td>从网页中提取完整文章内容和元数据。</td>\n<td><a href=\"https://github.com/michalparkola/tapestry-skills-for-claude-code/tree/main/article-extractor\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/michalparkola/tapestry-skills-for-claude-code/tree/main/article-extractor</a></td>\n</tr>\n<tr>\n<td>Canvas Design</td>\n<td>通过设计哲学和美学原则，为海报、设计和静态作品创作精美的 PNG 和 PDF 视觉艺术。</td>\n<td><a href=\"https://github.com/ComposioHQ/awesome-claude-skills/blob/master/canvas-design\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ComposioHQ/awesome-claude-skills/blob/master/canvas-design</a></td>\n</tr>\n<tr>\n<td>Image Enhancer</td>\n<td>通过提升分辨率、清晰度和锐度，优化图像和截图质量。</td>\n<td><a href=\"https://github.com/ComposioHQ/awesome-claude-skills/blob/master/image-enhancer\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ComposioHQ/awesome-claude-skills/blob/master/image-enhancer</a></td>\n</tr>\n<tr>\n<td>Theme Factory</td>\n<td>一键为幻灯片、文档、报告和 HTML 首页等文件应用专业字体和配色主题，提供 10 种预设风格。</td>\n<td><a href=\"https://github.com/ComposioHQ/awesome-claude-skills/blob/master/theme-factory\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ComposioHQ/awesome-claude-skills/blob/master/theme-factory</a></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"结语\">结语</h4>\n<p>从本质上看，Skills 仍然属于上下文工程的一部分，其核心目标在于缓解上下文长度受限和Token消耗过快的问题。同时，它也继承了优秀系统提示词所具备的设计原则——清晰、简洁、结构化，只不过是以文件系统目录结构的形式。</p>\n<p>希望本文的分享，能够对大家理解 Skills 的设计理念，以及在实际场景中的应用方式，提供一些参考与帮助。</p>\n<p>点击下载本文中的<a href=\"https://files.cnblogs.com/files/blogs/858241/SKILL.md.zip?t=1769695506&amp;download=true\" target=\"_blank\">SKILL.md </a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 21:44</span>&nbsp;\n<a href=\"https://www.cnblogs.com/deep-sky\">DeepSky丶</a>&nbsp;\n阅读(<span id=\"post_view_count\">16</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款基于 .NET Avalonia 开源免费、快速、跨平台的图片查看器",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19550484",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19550484\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 21:16\">\n    <span>一款基于 .NET Avalonia 开源免费、快速、跨平台的图片查看器</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span class=\"content\">前言</span></h2>\n<p>今天大姚给大家分享一款基于 .NET Avalonia 开源免费、快速、可定制、跨平台的图片查看器：<strong>PicView</strong>。帮助大家享受干净、免费且快速的图片查看体验，没有烦人的弹窗。</p>\n<h2><span class=\"content\">工具介绍</span></h2>\n<p>PicView 是一款基于 .NET Avalonia 的开源免费、快速、可高度定制、跨平台的图片查看器，支持 macOS 和 Windows 10/11 操作系统。它支持几乎所有常见的图像文件类型，包括但不限于 (animated)WEBP、(animated)GIF、SVG、AVIF、HEIC、PSD 等，为用户提供了一个清洁、无干扰且高效的图片浏览体验。</p>\n<p><img alt=\"image\" height=\"577\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211408964-244803537.png\" width=\"864\" /></p>\n<h2><span class=\"content\">工具技术栈</span></h2>\n<p>PicView 是用 C# .NET 构建的，使用 Avalonia 跨平台的 XAML UI 框架。所有的构建版本都使用NativeAOT（附带修剪功能）进行编译，生成一个完全独立的本地可执行文件。</p>\n<p>PicView 利用 Cysharp 的 ZLinq 和 ZString 来实现零内存分配和高性能操作，同时使用R3来实现高性能的 ViewModel 绑定和事件流处理。</p>\n<h2><span class=\"content\">应用场景</span></h2>\n<ul>\n<li><strong>个人用户：</strong>&nbsp;需要快速查看、编辑和管理个人照片和图像收藏。</li>\n<li><strong>专业设计师：</strong>&nbsp;需要查看和预览多种格式的设计稿和图像文件。</li>\n</ul>\n<h2><span class=\"content\">文件类型支持</span></h2>\n<ul>\n<li><strong>常见类型：</strong>&nbsp;.jpg .jpeg .jpe .png .bmp .tif .tiff .gif .ico .jfif .webp .svg .svgz。</li>\n<li><strong>高级类型：</strong>&nbsp;.psd .psb .xcf .jxl .heic .heif .jp2 .hdr .tga .dds。</li>\n<li><strong>RAW类型：</strong>.3fr .arw .cr2 .cr3 .crw .dcr .dng .erf .kdc .mdc .mef .mos .mrw .nrw .orf .pef .raf .raw .rw2 .srf .x3f。</li>\n<li><strong>其他类型：</strong>&nbsp;.pgm .hdr .cut .exr .dib .emf.wmf .wpg .pcx .xbm .xpm .wbmp。</li>\n</ul>\n<h2><span class=\"content\">工具源代码</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211429178-1561826034.png\" /></p>\n<h2><span class=\"content\">功能演示</span></h2>\n<p><img alt=\"image\" height=\"663\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211408964-244803537.png\" width=\"993\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211446529-386230130.png\" /></p>\n<p><strong>图片信息窗口：</strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211521330-1639886864.png\" /></p>\n<p>你可以通过编辑宽度和/或高度文本框来更改图片大小。要按百分比调整大小，只需在数值后加上百分比符号即可。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211532989-1693189361.png\" /></p>\n<p><strong>图片集：</strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211543075-391351691.png\" /></p>\n<p><strong>裁剪图像：</strong></p>\n<div>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211554903-1720426709.png\" /></p>\n<p><strong>批量调整大小：</strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211606261-1842201979.png\" /></p>\n<p><strong>图片更名：</strong></p>\n<div>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211617312-1618992927.png\" /></p>\n<p>按 F2 或右键点击标题栏文件，可以重命名或移动文件。更改文件扩展名后，图片会被转换成相应格式。</p>\n<h2><span class=\"content\">项目源码地址</span></h2>\n<p>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</p>\n<ul>\n<li><strong>GitHub开源地址：</strong>&nbsp;<a href=\"https://github.com/Ruben2776/PicView\" rel=\"noopener nofollow\">https://github.com/Ruben2776/PicView</a></li>\n</ul>\n<h2><span class=\"content\">优秀项目和框架精选</span></h2>\n<p>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong>）。</p>\n<ul>\n<li><strong>GitHub开源地址：</strong>&nbsp;<a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\">https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</a></li>\n<li><strong>Gitee开源地址：</strong>&nbsp;<a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\">https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</a></li>\n</ul>\n</div>\n</div>\n\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 21:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">48</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "快速上手Ultimate++的编译链接和配置",
      "link": "https://www.cnblogs.com/bokong/p/19540095",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/bokong/p/19540095\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 17:28\">\n    <span>快速上手Ultimate++的编译链接和配置</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        U++（全称 Ultimate++）是一个开源的 C++ 跨平台应用程序框架，以其高性能、低资源占用和高度集成的开发理念而闻名。它旨在提供“更少代码、更快执行”的开发体验。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"u简介\">U++简介</h1>\n<p>U++（全称 Ultimate++）是一个<strong>开源的 C++ 跨平台应用程序框架</strong>，以其<strong>高性能、低资源占用和高度集成</strong>的开发理念而闻名。它旨在提供“<strong>更少代码、更快执行</strong>”的开发体验。<br />\n<strong>主要特点：</strong></p>\n<ol>\n<li><strong>高度集成</strong><br />\n包含GUI、数据库、网络、XML、JSON等完整工具链，减少对第三方库的依赖。</li>\n<li><strong>智能编程模型</strong><br />\n强调使用C++ RAII、智能指针等现代特性，自动管理资源，提升代码安全性。</li>\n<li><strong>高效的GUI开发</strong><br />\n提供自绘GUI库（<code>U++ Controls</code>），支持Windows、Linux、macOS，界面响应迅速且内存占用低。</li>\n<li><strong>编译与构建工具</strong><br />\n自带<code>TheIDE</code>集成开发环境，包含智能代码编辑器、可视化设计器和构建系统<code>umake</code>，支持并行编译与代码优化。</li>\n<li><strong>性能优先</strong><br />\n注重运行时效率，生成的程序体积小、启动快，适合开发桌面应用和工具软件。</li>\n</ol>\n<p><strong>示例代码片段（简单窗口）：</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;CtrlLib/CtrlLib.h&gt;\nusing namespace Upp;\n\nclass MyApp : public TopWindow {\npublic:\n    MyApp() {\n        Title(\"Hello U++\");\n        SetRect(0, 0, 400, 200);\n    }\n};\n\nGUI_APP_MAIN\n{\n    MyApp().Run();\n}\n</code></pre>\n<p><strong>适用场景：</strong><br />\n桌面应用程序、工具软件、数据管理平台等对性能和轻量化有较高要求的项目。<br />\n<strong>U++通过“全栈式”设计帮助开发者用C++快速构建高效且跨平台的应用程序。</strong></p>\n<h1 id=\"u集成开发环境theide使用\">U++集成开发环境TheIDE使用</h1>\n<h2 id=\"项目工程\">项目工程</h2>\n<ul>\n<li>TheIDE默认examples（例程）、MyApps、reference（参考项目）、tutorial（教程项目）、uppsrc（U++官方程序集）这5个程序集，其中MyApps是默认留给用户开发项目的，uppsrc是最重要的程序集，所有开发需要的模块包都在这里面。</li>\n<li>程序集又分为Main packages（用来生成最终项目（可执行程序或库））和Non-main packages（供主模块引用的模块包）。</li>\n</ul>\n<p><strong>创建你的项目：</strong><br />\n选择MyApps，窗口左下角选择Main packages，下方靠右边选择New package按钮在弹出的对话框中定制你的项目（或者在Package区右键会有更多功能选择），然后Create按钮就可以写代码了。后续需要打开你的项目，可以选择项目后OK按钮（或直接双击）打开。你也可以新建自己的程序集，在Assembly区右键选择New assembly，自己指定路径。如图：<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<strong>构建生成</strong><br />\n首先看窗口工具栏，有两个可编辑的工具条，分别是构建标志（GUI等，可以多个标志一组，空格隔开）和编译器配置（CLANG Debug等），这决定了最终的输出配置，参考下图：<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n重要的构建标志还有SHARED（构建动态库）、MAKE_LIB（构建静态库）等，见官方文档详细说明。<br />\n<strong>为你的项目添加依赖包：</strong><br />\n选择你的模块包，右键选择Add package to... 如图：<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n选择一个你需要的依赖包即可。<br />\n<strong>包的配置管理：</strong><br />\nProject菜单选择Package organizer（或者模块包右键菜单选择），弹出窗口（选择Core模块作为跨平台配置参考），严格的包依赖关系全部在这里管理，如图：<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\nAccents中是指定标志（包提供者决定怎么编译这个包），编译器将据此生成目标文件。下方是具体的条件编译配置，条件即是构建标志，意思就是根据构建标志这些条件使用依赖包、库、链接选项等。（提示：找到并打开Core.upp文本文件你会观察到这些内容完全一致。）<br />\n同样Project菜单还有个Main package configuration（或者点击工具栏标志工具条），在弹出如下窗口中可配置管理多组构建标志，支持交叉编译等高级跨平台功能。<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<strong>关于标志补充说明：</strong><br />\n所有标志会被U++构建工具自动解析为\"flag\"前缀的预编译宏，如flagGUI、flagDLL、flagUSEMALLOC等，你也可以自定义标志，且完全满足这条规则，意味着你可以灵活地处理条件编译（#ifdef flag...）。<br />\n<strong>输出模式设定</strong><br />\nBuild菜单选择Output mode（或者点击工具栏编译器工具条），弹出窗口，你可以指定覆盖目标文件路径、启用Blitz编译技术、创建其他输出文件等，如图：<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<strong>调试运行设置</strong><br />\nDebug菜单选择Run options，在下图所示的窗口中可设置程序运行输入参数、标准输出重定向到文件等。<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<strong>Assist菜单下提供了U++框架更多的实用和辅助等高级功能。</strong></p>\n<h2 id=\"自定义编译器配置\">自定义编译器配置</h2>\n<p><strong>添加编译器</strong><br />\nSetup菜单选择Build methods弹出如下窗口：<br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n如何添加编译器？以MinGW为例，左边Method下右键，选择Append row，命名MinGWx64（64位程序编译器），右边Builder要选择GCC，底下要正确指定文件夹，我的配置如图<br />\n<img alt=\"MinGWx64\" class=\"lazyload\" /><br />\n我是用msys2下载安装的MinGW，所以可执行文件路径PATH下需要\"msys64\\mingw64/bin\"和\"msys64\\mingw64/x86_64-w64-mingw32/bin\"这样的两个完整路径（Windows路径系统用反斜杠，但建议最后一个文件夹更改为正斜杠）。<br />\nINCLUDE需要\"msys64\\mingw64/include\"，LIB需要\"msys64\\mingw64/lib\"<br />\n<strong>编译链接选项</strong><br />\n这些参数设置同系统标准，可以启用函数级链接、冗余清除等优化最终程序的体积和速度，根据自己的需要配置。需要交叉编译时，必须自己手动添加（如Java、Android等）编译器。当然U++的IDE也有很明显的微小瑕疵，找不到函数的定义便会报错提示（最典型的是使用库函数），但是可以正常生成目标程序，所以只有忽略这些提示。<br />\n以上就是轻量级框架U++基本使用说明。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 17:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/bokong\">南岩亦凛汀</a>&nbsp;\n阅读(<span id=\"post_view_count\">78</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "stable_baseline3 快速入门(一): 训练第一个强化学习模型",
      "link": "https://www.cnblogs.com/ClownLMe/p/19549111",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19549111\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 16:01\">\n    <span>stable_baseline3 快速入门(一): 训练第一个强化学习模型</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简介\">简介</h1>\n<p><strong>stable_baseline3</strong> 是一个基于 PyTorch 的强化学习算法开源库，里面集成了多种强化学习算法，使用这个开源库能够让我们不需要过度关注强化学习算法细节，专注于AI业务的开发。</p>\n<h1 id=\"环境配置\">环境配置</h1>\n<pre><code class=\"language-bash\">pip install stable-baselines3\npip install gymnasium\n</code></pre>\n<p>这里<code>stable-baselines3</code>会默认安装<code>pytroch</code>框架，但是是不带<code>cuda</code>版本的，这就意味着我们无法利用我们的显卡对模型进行训练。<br />\n下载<code>cuda</code>版本的<code>pytroch</code>步骤如下：</p>\n<ol>\n<li>卸载原来版本的<code>pytroch</code>框架</li>\n</ol>\n<pre><code class=\"language-bash\">pip uninstall torch torchvision torchaudio -y\n#这个是针对RTX 30/40/50显卡的。\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu126\n</code></pre>\n<p>如果其他版本请参考官网： <a href=\"https://pytorch.org/get-started/locally/\" rel=\"noopener nofollow\" target=\"_blank\">https://pytorch.org/get-started/locally/</a></p>\n<h1 id=\"认识stable_baseline3\">认识stable_baseline3</h1>\n<p><code>stable_baseline3</code>提供了许多模型，如下列表：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>动作空间</th>\n<th>建议应用场景</th>\n<th>核心优势</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>PPO</strong></td>\n<td>连续 &amp; 离散</td>\n<td><strong>全能选手</strong>，如机器人走动、金融交易、游戏 AI</td>\n<td>极其稳定，对超参数不敏感，支持大规模并行训练。</td>\n</tr>\n<tr>\n<td><strong>DQN</strong></td>\n<td>仅离散</td>\n<td>经典游戏（Atari）、开关控制、迷宫寻路</td>\n<td>理解简单，在离散控制领域非常经典且有效。</td>\n</tr>\n<tr>\n<td><strong>SAC</strong></td>\n<td>仅连续</td>\n<td>复杂物理模拟、机械臂抓取、自动驾驶</td>\n<td>探索效率极高，能自动寻找最优路径且不轻易陷入局部最优。</td>\n</tr>\n<tr>\n<td><strong>TD3</strong></td>\n<td>仅连续</td>\n<td>工业控制、无人机飞行、精密动作</td>\n<td>针对 DDPG 的缺陷做了改进，训练过程比 SAC 更平滑。</td>\n</tr>\n<tr>\n<td><strong>A2C</strong></td>\n<td>连续 &amp; 离散</td>\n<td>简单逻辑测试、快速原型验证</td>\n<td>结构简单，虽然不如 PPO 稳定，但在特定并行环境下速度极快。</td>\n</tr>\n</tbody>\n</table>\n<p>在<strong>声明模型</strong>中，可以设置多种参数，这里列出常用的：<br />\n目前不需要搞懂都有什么作用，后面有文章会详细讲解</p>\n<ol>\n<li>训练参数</li>\n</ol>\n<ul>\n<li><code>learning_rate</code>：学习率</li>\n<li><code>gamma</code>：折扣因子</li>\n<li><code>batch_size</code>：更新模型使用数据量</li>\n<li><code>verbose</code>：打印信息模式。0-静默模式，1-信息模式，2-调试模式</li>\n<li><code>device</code>：指定训练设备<code>cuda</code>使用显卡，<code>cpu</code>使用cpu</li>\n</ul>\n<ol start=\"2\">\n<li>模型规则</li>\n</ol>\n<ul>\n<li><code>MlpPolicy</code>：多层感知机。适用于状态是数值场景（传感器等）</li>\n<li><code>CnnPolicy</code>：卷积神经网络。适用于状态是图像场景（游戏等）</li>\n</ul>\n<h1 id=\"训练第一个强化学习模型\">训练第一个强化学习模型</h1>\n<h3 id=\"案例\">案例</h3>\n<p>案例描述：训练一个<code>gymnasium</code>默认提供的游戏环境，平衡杆游戏。</p>\n<pre><code class=\"language-python\">import gymnasium as gym\nfrom stable_baselines3 import PPO\n\nenv = gym.make(\"CartPole-v1\")\n\nmodel = PPO(\"MlpPolicy\", env, verbose=1, device=\"cuda\")\n\nprint(\"开始训练...\")\nmodel.learn(total_timesteps=10000)\n\nprint(\"正在保存模型...\")\nmodel.save(\"ppo_cartpole\")\n\nprint(\"正在读取模型...\")\nenv = gym.make(\"CartPole-v1\", render_mode=\"human\")\nloaded_model = PPO.load(\"ppo_cartpole\", env=env)\n\nprint(\"训练结束，开始演示...\")\nobs, _ = env.reset()\nfor i in range(1000):\n    action, _states = loaded_model.predict(obs, deterministic=True)\n\n    obs, reward, terminated, truncated, info = env.step(action)\n    \n    if terminated or truncated:\n        obs, _ = env.reset()\n\nenv.close()\n</code></pre>\n<h3 id=\"代码解释\">代码解释</h3>\n<p>代码流程如下：<br />\n<strong>初始化环境模型-&gt;训练模型-&gt;保存模型-&gt;加载模型-&gt;模型预测</strong></p>\n<h5 id=\"初始化环境模型\">初始化环境模型</h5>\n<p>初始化模型以及游戏的环境</p>\n<pre><code class=\"language-python\">env = gym.make(\"CartPole-v1\")\nmodel = PPO(\"MlpPolicy\", env, verbose=1, device=\"cuda\")\n\nenv = gym.make(\"CartPole-v1\", render_mode=\"human\")\n</code></pre>\n<ul>\n<li><code>gym</code>中的<code>make</code>方法利用默认的游戏环境，<code>CartPole-v1</code>是游戏名，下面有一个<code>render_mode=\"human\"</code>参数，用于标识是否展示画面。训练时展示画面会降低训练的速度，一般在预测时才使用</li>\n</ul>\n<h5 id=\"训练模型\">训练模型</h5>\n<pre><code class=\"language-python\">model.learn(total_timesteps=10000)\n</code></pre>\n<ul>\n<li><code>total_timesteps</code>：训练10000次</li>\n</ul>\n<h5 id=\"保存模型\">保存模型</h5>\n<pre><code class=\"language-python\">model.save(\"ppo_cartpole\")\n</code></pre>\n<ul>\n<li><code>\"ppo_cartpole\"</code> 为保存模型的名字，这里是保存在当前文件夹中。</li>\n</ul>\n<h5 id=\"加载模型\">加载模型</h5>\n<pre><code class=\"language-python\">loaded_model = PPO.load(\"ppo_cartpole\", env=env)\n</code></pre>\n<ul>\n<li>第一个参数：刚刚保存的模型路径</li>\n<li>第二个参数：训练的环境</li>\n</ul>\n<h5 id=\"模型预测\">模型预测</h5>\n<pre><code class=\"language-python\">obs, _ = env.reset()\nfor i in range(1000):\n    action, _states = loaded_model.predict(obs, deterministic=True)\n\n    obs, reward, terminated, truncated, info = env.step(action)\n    \n    if terminated or truncated:\n        obs, _ = env.reset()\n</code></pre>\n<ul>\n<li><code>env.reset()</code>重置环境，返回初始观测值<code>obs</code>和<code>info</code>(这里没用到)</li>\n<li>模型的<code>predict</code>方法用于根据观测值<code>obs</code>预测下一步行动。<strong>注意：deterministic参数要为True，不然会报错</strong></li>\n<li>模型的<code>step</code>方法根据行动值返回结果。（这些都是什么后面文章会讲）</li>\n</ul>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 16:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Kuboard 离线安装与 K3s 集群绑定完整指南",
      "link": "https://www.cnblogs.com/ghostmen/p/19548359",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ghostmen/p/19548359\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 14:29\">\n    <span>Kuboard 离线安装与 K3s 集群绑定完整指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"-目录\">📋 目录</h2>\n<ul>\n<li><a href=\"#%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E\" rel=\"noopener nofollow\">环境说明</a></li>\n<li><a href=\"#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\" rel=\"noopener nofollow\">准备工作</a></li>\n<li><a href=\"#%E4%B8%80%E5%87%86%E5%A4%87%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85\" rel=\"noopener nofollow\">一、准备离线安装包</a></li>\n<li><a href=\"#%E4%BA%8C%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8\" rel=\"noopener nofollow\">二、传输文件到服务器</a></li>\n<li><a href=\"#%E4%B8%89%E5%AE%89%E8%A3%85-kuboard\" rel=\"noopener nofollow\">三、安装 Kuboard</a></li>\n<li><a href=\"#%E5%9B%9B%E8%A7%A3%E5%86%B3-404-%E9%97%AE%E9%A2%98\" rel=\"noopener nofollow\">四、解决 404 问题</a></li>\n<li><a href=\"#%E4%BA%94%E7%BB%91%E5%AE%9A-k3s-%E9%9B%86%E7%BE%A4\" rel=\"noopener nofollow\">五、绑定 K3s 集群</a></li>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4\" rel=\"noopener nofollow\">常用管理命令</a></li>\n<li><a href=\"#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\" rel=\"noopener nofollow\">常见问题</a></li>\n</ul>\n<hr />\n<h2 id=\"环境说明\">环境说明</h2>\n<h3 id=\"服务器环境\">服务器环境</h3>\n<ul>\n<li><strong>服务器 IP</strong>: 10.12.12.110</li>\n<li><strong>操作系统</strong>: CentOS/RHEL</li>\n<li><strong>网络环境</strong>: 内网，无法访问外网</li>\n<li><strong>已安装服务</strong>: K3s v1.30.11+k3s1</li>\n</ul>\n<h3 id=\"本地环境\">本地环境</h3>\n<ul>\n<li><strong>操作系统</strong>: Windows</li>\n<li><strong>网络</strong>: 可以联网</li>\n<li><strong>已安装工具</strong>: Docker Desktop、SecureCRT</li>\n</ul>\n<hr />\n<h2 id=\"准备工作\">准备工作</h2>\n<h3 id=\"所需工具\">所需工具</h3>\n<ul>\n<li>Docker Desktop（Windows 本地）</li>\n<li>SecureCRT（SSH 连接工具）</li>\n<li>浏览器</li>\n</ul>\n<h3 id=\"网络要求\">网络要求</h3>\n<ul>\n<li>本地机器可以访问互联网</li>\n<li>本地机器可以 SSH 连接到服务器</li>\n<li>服务器处于内网环境</li>\n</ul>\n<hr />\n<h2 id=\"一准备离线安装包\">一、准备离线安装包</h2>\n<h3 id=\"11-下载-kuboard-镜像\">1.1 下载 Kuboard 镜像</h3>\n<p>在 Windows 本地（已安装 Docker Desktop）的 PowerShell 中执行：</p>\n<pre><code class=\"language-powershell\"># 使用国内镜像源下载 Kuboard v3\ndocker pull swr.cn-east-2.myhuaweicloud.com/kuboard/kuboard:v3\n\n# 重新标记镜像\ndocker tag swr.cn-east-2.myhuaweicloud.com/kuboard/kuboard:v3 eipwork/kuboard:v3\n\n# 验证镜像\ndocker images | Select-String kuboard\n</code></pre>\n<h3 id=\"12-导出镜像为-tar-文件\">1.2 导出镜像为 tar 文件</h3>\n<pre><code class=\"language-powershell\"># 创建目录\nNew-Item -ItemType Directory -Force -Path \"D:\\Documents\\kuboard-offline\\images\"\n\n# 导出镜像（约 126 MB）\ndocker save eipwork/kuboard:v3 -o \"D:\\Documents\\kuboard-offline\\images\\kuboard-v3.tar\"\n\n# 查看文件大小\nGet-ChildItem \"D:\\Documents\\kuboard-offline\\images\\kuboard-v3.tar\"\n</code></pre>\n<h3 id=\"13-下载-docker-离线安装包\">1.3 下载 Docker 离线安装包</h3>\n<pre><code class=\"language-powershell\"># 创建目录\nNew-Item -ItemType Directory -Force -Path \"D:\\Documents\\kuboard-offline\\docker\"\n\n# 下载 Docker 离线包（约 66.6 MB）\nInvoke-WebRequest -Uri \"https://download.docker.com/linux/static/stable/x86_64/docker-24.0.7.tgz\" -OutFile \"D:\\Documents\\kuboard-offline\\docker\\docker-24.0.7.tgz\"\n</code></pre>\n<h3 id=\"14-创建安装脚本\">1.4 创建安装脚本</h3>\n<p>在 <code>D:\\Documents\\kuboard-offline\\</code> 目录下创建 <code>install.sh</code> 文件：</p>\n<pre><code class=\"language-bash\">#!/bin/bash\n# Kuboard 离线安装脚本\n\nset -e\n\necho \"==========================================\"\necho \"Kuboard 离线安装\"\necho \"==========================================\"\n\n# 检查是否为 root 用户\nif [ \"$EUID\" -ne 0 ]; then \n    echo \"请使用 root 用户或 sudo 执行此脚本\"\n    exit 1\nfi\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" &amp;&amp; pwd)\"\n\n# 检查 Docker 是否已安装\nif ! command -v docker &amp;&gt; /dev/null; then\n    echo \"[1/4] 安装 Docker...\"\n    \n    if [ -f \"${SCRIPT_DIR}/docker/docker-24.0.7.tgz\" ]; then\n        cd \"${SCRIPT_DIR}/docker\"\n        tar -xzf docker-24.0.7.tgz\n        cp docker/* /usr/bin/\n        chmod +x /usr/bin/docker*\n        \n        # 创建 Docker systemd 服务\n        cat &gt; /etc/systemd/system/docker.service &lt;&lt; 'DOCKERSERVICE'\n[Unit]\nDescription=Docker Application Container Engine\nDocumentation=https://docs.docker.com\nAfter=network-online.target firewalld.service\nWants=network-online.target\n\n[Service]\nType=notify\nExecStart=/usr/bin/dockerd\nExecReload=/bin/kill -s HUP $MAINPID\nLimitNOFILE=infinity\nLimitNPROC=infinity\nTimeoutStartSec=0\nDelegate=yes\nKillMode=process\nRestart=on-failure\nStartLimitBurst=3\nStartLimitInterval=60s\n\n[Install]\nWantedBy=multi-user.target\nDOCKERSERVICE\n\n        systemctl daemon-reload\n        systemctl start docker\n        systemctl enable docker\n        \n        echo \"✓ Docker 安装完成\"\n    else\n        echo \"⚠ 未找到 Docker 安装包\"\n    fi\nelse\n    echo \"[1/4] Docker 已安装: $(docker --version)\"\nfi\n\necho \"\"\necho \"[2/4] 加载 Kuboard 镜像...\"\nif [ -f \"${SCRIPT_DIR}/images/kuboard-v3.tar\" ]; then\n    docker load -i \"${SCRIPT_DIR}/images/kuboard-v3.tar\"\n    echo \"✓ Kuboard 镜像加载完成\"\nelse\n    echo \"✗ 未找到 Kuboard 镜像文件\"\n    exit 1\nfi\n\necho \"\"\necho \"[3/4] 创建数据目录...\"\nmkdir -p /data/kuboard\necho \"✓ 数据目录创建完成: /data/kuboard\"\n\necho \"\"\necho \"[4/4] 启动 Kuboard 容器...\"\n\nSERVER_IP=\"10.12.12.110\"\n\n# 检查是否已有运行的 kuboard 容器\nif docker ps -a | grep -q kuboard; then\n    echo \"检测到已存在的 kuboard 容器，正在删除...\"\n    docker rm -f kuboard\nfi\n\n# 启动容器\ndocker run -d \\\n  --restart=unless-stopped \\\n  --name=kuboard \\\n  -p 80:80/tcp \\\n  -p 10081:10081/tcp \\\n  -e KUBOARD_ENDPOINT=\"http://${SERVER_IP}:80\" \\\n  -e KUBOARD_AGENT_SERVER_TCP_PORT=\"10081\" \\\n  -v /data/kuboard:/data \\\n  eipwork/kuboard:v3\n\necho \"\"\necho \"等待容器启动...\"\nsleep 5\n\n# 检查容器状态\nif docker ps | grep -q kuboard; then\n    echo \"✓ Kuboard 启动成功！\"\n    echo \"\"\n    echo \"==========================================\"\n    echo \"安装完成！\"\n    echo \"==========================================\"\n    echo \"访问地址: http://${SERVER_IP}\"\n    echo \"默认用户名: admin\"\n    echo \"默认密码: Kuboard123\"\n    echo \"\"\n    echo \"⚠️  请立即登录并修改默认密码！\"\n    echo \"==========================================\"\nelse\n    echo \"✗ Kuboard 启动失败，请查看日志:\"\n    docker logs kuboard\n    exit 1\nfi\n</code></pre>\n<h3 id=\"15-文件结构\">1.5 文件结构</h3>\n<p>准备完成后，目录结构如下：</p>\n<pre><code>D:\\Documents\\kuboard-offline\\\n├── docker/\n│   └── docker-24.0.7.tgz          (66.6 MB)\n├── images/\n│   └── kuboard-v3.tar             (126 MB)\n└── install.sh                      (安装脚本)\n</code></pre>\n<p><strong>总大小</strong>: 约 193 MB</p>\n<hr />\n<h2 id=\"二传输文件到服务器\">二、传输文件到服务器</h2>\n<h3 id=\"21-使用-securecrt-的-sftp-功能\">2.1 使用 SecureCRT 的 SFTP 功能</h3>\n<h4 id=\"连接到服务器\">连接到服务器</h4>\n<ol>\n<li>打开 SecureCRT</li>\n<li>新建会话或快速连接\n<ul>\n<li>协议：SSH2</li>\n<li>主机名：<code>10.12.12.110</code></li>\n<li>端口：<code>22</code></li>\n<li>用户名：<code>sudoroot</code></li>\n</ul>\n</li>\n<li>连接并输入密码</li>\n</ol>\n<h4 id=\"上传文件\">上传文件</h4>\n<ol>\n<li>按 <code>Alt + P</code> 打开 SFTP 窗口</li>\n<li>在 SFTP 窗口中执行：</li>\n</ol>\n<pre><code class=\"language-bash\"># 切换到服务器的 /tmp 目录\ncd /tmp\n\n# 切换本地目录到 D:\\Documents\nlcd D:\\Documents\n\n# 上传整个文件夹\nput -r kuboard-offline\n</code></pre>\n<ol start=\"3\">\n<li>等待传输完成（约 2-5 分钟）</li>\n</ol>\n<h3 id=\"22-验证文件传输\">2.2 验证文件传输</h3>\n<p>在 SecureCRT 命令行中执行：</p>\n<pre><code class=\"language-bash\"># 检查文件是否完整\nls -lh /tmp/kuboard-offline/\nls -lh /tmp/kuboard-offline/docker/\nls -lh /tmp/kuboard-offline/images/\n</code></pre>\n<hr />\n<h2 id=\"三安装-kuboard\">三、安装 Kuboard</h2>\n<h3 id=\"31-执行安装脚本\">3.1 执行安装脚本</h3>\n<p>在 SecureCRT 中执行：</p>\n<pre><code class=\"language-bash\"># 进入目录\ncd /tmp/kuboard-offline\n\n# 给脚本执行权限\nchmod +x install.sh\n\n# 执行安装\nsudo bash install.sh\n</code></pre>\n<h3 id=\"32-等待安装完成\">3.2 等待安装完成</h3>\n<p>安装脚本会自动完成以下操作：</p>\n<ol>\n<li>✅ 检查并安装 Docker（如果未安装）</li>\n<li>✅ 加载 Kuboard 镜像</li>\n<li>✅ 创建数据目录 <code>/data/kuboard</code></li>\n<li>✅ 启动 Kuboard 容器</li>\n</ol>\n<p>安装过程约需 <strong>1-3 分钟</strong>。</p>\n<h3 id=\"33-验证安装\">3.3 验证安装</h3>\n<pre><code class=\"language-bash\"># 查看容器状态\nsudo docker ps | grep kuboard\n\n# 查看日志\nsudo docker logs kuboard | tail -50\n\n# 测试本地访问\ncurl -I http://localhost:80\n</code></pre>\n<hr />\n<h2 id=\"四解决-404-问题\">四、解决 404 问题</h2>\n<h3 id=\"41-问题现象\">4.1 问题现象</h3>\n<p>初次安装后，访问 <code>http://10.12.12.110</code> 可能会遇到 <strong>404 page not found</strong> 错误。</p>\n<h3 id=\"42-问题原因\">4.2 问题原因</h3>\n<p>Kuboard v3 镜像的 nginx 配置文件默认生成不完整，缺少 <code>http {}</code> 块，导致无法正确处理 HTTP 请求。</p>\n<h3 id=\"43-解决方案更换端口并修复配置\">4.3 解决方案：更换端口并修复配置</h3>\n<h4 id=\"步骤-1停止现有容器并使用新端口\">步骤 1：停止现有容器并使用新端口</h4>\n<pre><code class=\"language-bash\"># 停止并删除现有容器\nsudo docker stop kuboard\nsudo docker rm kuboard\n\n# 使用 41878 端口重新启动\nsudo docker run -d \\\n  --restart=unless-stopped \\\n  --name=kuboard \\\n  -p 41878:80/tcp \\\n  -p 10081:10081/tcp \\\n  -e KUBOARD_ENDPOINT=\"http://10.12.12.110:41878\" \\\n  -e KUBOARD_AGENT_SERVER_TCP_PORT=\"10081\" \\\n  -v /data/kuboard:/data \\\n  eipwork/kuboard:v3\n\n# 等待容器启动\nsleep 30\n</code></pre>\n<h4 id=\"步骤-2修复-nginx-配置\">步骤 2：修复 nginx 配置</h4>\n<pre><code class=\"language-bash\"># 创建完整的 nginx 配置\nsudo docker exec kuboard sh -c 'cat &gt; /etc/nginx/nginx.conf &lt;&lt; \"EOF\"\nuser www-data;\nworker_processes auto;\npid /run/nginx.pid;\ninclude /etc/nginx/modules-enabled/*.conf;\n\nevents {\n    worker_connections 65535;\n}\n\nhttp {\n    sendfile on;\n    tcp_nopush on;\n    tcp_nodelay on;\n    keepalive_timeout 65;\n    types_hash_max_size 2048;\n\n    include /etc/nginx/mime.types;\n    default_type application/octet-stream;\n\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log;\n\n    gzip on;\n\n    server {\n        listen 80;\n        server_name _;\n        \n        client_max_body_size 1024m;\n\n        location / {\n            proxy_pass http://127.0.0.1:10080;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection \"upgrade\";\n        }\n    }\n}\n\nstream {}\nEOF'\n\n# 重载 nginx 配置\nsudo docker exec kuboard nginx -s reload\n</code></pre>\n<h4 id=\"步骤-3验证访问\">步骤 3：验证访问</h4>\n<pre><code class=\"language-bash\"># 测试本地访问\ncurl -I http://localhost:41878\n\n# 查看容器状态\nsudo docker ps | grep kuboard\n</code></pre>\n<h3 id=\"44-访问-kuboard\">4.4 访问 Kuboard</h3>\n<p>在浏览器中访问：</p>\n<p><strong><a href=\"http://10.12.12.110:41878\" rel=\"noopener nofollow\" target=\"_blank\">http://10.12.12.110:41878</a></strong></p>\n<p>登录信息：</p>\n<ul>\n<li><strong>用户名</strong>: <code>admin</code></li>\n<li><strong>密码</strong>: <code>Kuboard123</code></li>\n</ul>\n<p>⚠️ <strong>重要提醒</strong>：首次登录后请立即修改默认密码！</p>\n<hr />\n<h2 id=\"五绑定-k3s-集群\">五、绑定 K3s 集群</h2>\n<h3 id=\"51-检查-k3s-状态\">5.1 检查 K3s 状态</h3>\n<p>在 SecureCRT 中执行：</p>\n<pre><code class=\"language-bash\"># 检查 K3s 服务状态\nsudo systemctl status k3s\n\n# 查看节点信息\nsudo kubectl get nodes\n\n# 查看 kubeconfig 文件\nls -la /etc/rancher/k3s/k3s.yaml\n</code></pre>\n<h3 id=\"52-方法一使用-kubeconfig-导入推荐\">5.2 方法一：使用 KubeConfig 导入（推荐）</h3>\n<h4 id=\"步骤-1生成修改后的-kubeconfig\">步骤 1：生成修改后的 kubeconfig</h4>\n<p>在 SecureCRT 中执行：</p>\n<pre><code class=\"language-bash\"># 将 127.0.0.1 替换为服务器实际 IP\nsudo cat /etc/rancher/k3s/k3s.yaml | sed 's/127.0.0.1/10.12.12.110/g'\n</code></pre>\n<h4 id=\"步骤-2复制输出内容\">步骤 2：复制输出内容</h4>\n<p>执行上面命令后，会输出修改后的 kubeconfig，<strong>全部复制</strong>（从 <code>apiVersion: v1</code> 开始到最后）。</p>\n<h4 id=\"步骤-3在-kuboard-中导入\">步骤 3：在 Kuboard 中导入</h4>\n<ol>\n<li>浏览器访问 <strong><a href=\"http://10.12.12.110:41878\" rel=\"noopener nofollow\" target=\"_blank\">http://10.12.12.110:41878</a></strong></li>\n<li>使用 <code>admin/Kuboard123</code> 登录</li>\n<li>点击页面上的「<strong>添加集群</strong>」按钮</li>\n<li>选择「<strong>通过 KubeConfig 导入</strong>」</li>\n<li>将刚才复制的 kubeconfig 内容粘贴到文本框</li>\n<li>点击「<strong>确定</strong>」或「<strong>导入</strong>」</li>\n</ol>\n<h4 id=\"步骤-4验证集群连接\">步骤 4：验证集群连接</h4>\n<p>导入成功后，你应该能看到：</p>\n<ul>\n<li>集群名称：default</li>\n<li>节点数量：1</li>\n<li>K3s 版本：v1.30.11+k3s1</li>\n<li>节点状态：Ready</li>\n</ul>\n<h3 id=\"53-方法二使用-token-方式\">5.3 方法二：使用 Token 方式</h3>\n<p>如果 KubeConfig 导入失败，可以使用 Token 方式。</p>\n<h4 id=\"步骤-1创建-serviceaccount\">步骤 1：创建 ServiceAccount</h4>\n<p>在 SecureCRT 中执行：</p>\n<pre><code class=\"language-bash\"># 创建 Kuboard 专用账号和权限\ncat &lt;&lt;EOF | sudo kubectl apply -f -\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: kuboard\n\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: kuboard-admin\n  namespace: kuboard\n\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: kuboard-admin\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: cluster-admin\nsubjects:\n- kind: ServiceAccount\n  name: kuboard-admin\n  namespace: kuboard\n\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: kuboard-admin-token\n  namespace: kuboard\n  annotations:\n    kubernetes.io/service-account.name: kuboard-admin\ntype: kubernetes.io/service-account-token\nEOF\n</code></pre>\n<h4 id=\"步骤-2获取-token\">步骤 2：获取 Token</h4>\n<pre><code class=\"language-bash\"># 等待 Secret 创建\nsleep 5\n\n# 获取 Token\necho \"==========================================\"\necho \"Token:\"\necho \"==========================================\"\nsudo kubectl get secret kuboard-admin-token -n kuboard -o jsonpath='{.data.token}' | base64 -d\necho \"\"\necho \"\"\n\n# 获取 CA 证书\necho \"==========================================\"\necho \"CA Certificate:\"\necho \"==========================================\"\nsudo kubectl get secret kuboard-admin-token -n kuboard -o jsonpath='{.data.ca\\.crt}'\necho \"\"\n</code></pre>\n<h4 id=\"步骤-3在-kuboard-中添加集群\">步骤 3：在 Kuboard 中添加集群</h4>\n<ol>\n<li>访问 <strong><a href=\"http://10.12.12.110:41878\" rel=\"noopener nofollow\" target=\"_blank\">http://10.12.12.110:41878</a></strong></li>\n<li>点击「<strong>添加集群</strong>」</li>\n<li>选择「<strong>通过 Token 导入</strong>」或「<strong>手动添加</strong>」</li>\n<li>填写信息：\n<ul>\n<li><strong>集群名称</strong>：k3s-cluster（自定义）</li>\n<li><strong>API Server 地址</strong>：<code>https://10.12.12.110:6443</code></li>\n<li><strong>Token</strong>：粘贴步骤 2 获取的 Token</li>\n<li><strong>CA 证书</strong>：粘贴步骤 2 获取的 CA 证书（如果需要）</li>\n</ul>\n</li>\n<li>点击「<strong>确定</strong>」</li>\n</ol>\n<h3 id=\"54-验证集群绑定\">5.4 验证集群绑定</h3>\n<p>绑定成功后，在 Kuboard 界面中可以：</p>\n<ul>\n<li>查看集群节点状态</li>\n<li>查看命名空间列表</li>\n<li>查看工作负载（Deployments、Pods 等）</li>\n<li>管理配置和存储</li>\n<li>查看日志和监控数据</li>\n</ul>\n<hr />\n<h2 id=\"常用管理命令\">常用管理命令</h2>\n<h3 id=\"kuboard-容器管理\">Kuboard 容器管理</h3>\n<pre><code class=\"language-bash\"># 查看容器状态\nsudo docker ps | grep kuboard\n\n# 查看实时日志\nsudo docker logs -f kuboard\n\n# 重启服务\nsudo docker restart kuboard\n\n# 停止服务\nsudo docker stop kuboard\n\n# 启动服务\nsudo docker start kuboard\n\n# 查看容器详细信息\nsudo docker inspect kuboard\n</code></pre>\n<h3 id=\"数据备份\">数据备份</h3>\n<pre><code class=\"language-bash\"># 手动备份\nsudo tar -czf kuboard-backup-$(date +%Y%m%d).tar.gz /data/kuboard\n\n# 查看备份文件\nls -lh kuboard-backup-*.tar.gz\n\n# 恢复备份\nsudo tar -xzf kuboard-backup-20260129.tar.gz -C /\n</code></pre>\n<h3 id=\"端口检查\">端口检查</h3>\n<pre><code class=\"language-bash\"># 查看端口监听\nsudo netstat -tlnp | grep -E '41878|10081'\n\n# 测试本地访问\ncurl -I http://localhost:41878\n\n# 测试外部访问\ntelnet 10.12.12.110 41878\n</code></pre>\n<h3 id=\"k3s-集群管理\">K3s 集群管理</h3>\n<pre><code class=\"language-bash\"># 查看节点状态\nsudo kubectl get nodes\n\n# 查看所有 Pod\nsudo kubectl get pods --all-namespaces\n\n# 查看 K3s 服务状态\nsudo systemctl status k3s\n\n# 重启 K3s\nsudo systemctl restart k3s\n\n# 查看 K3s 日志\nsudo journalctl -u k3s -f\n</code></pre>\n<hr />\n<h2 id=\"常见问题\">常见问题</h2>\n<h3 id=\"q1-访问-kuboard-显示-404-错误\">Q1: 访问 Kuboard 显示 404 错误</h3>\n<p><strong>原因</strong>：nginx 配置不完整，缺少 <code>http {}</code> 块。</p>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li>更换端口（避开 80 端口）</li>\n<li>手动修复 nginx 配置（参考 <a href=\"#%E5%9B%9B%E8%A7%A3%E5%86%B3-404-%E9%97%AE%E9%A2%98\" rel=\"noopener nofollow\">四、解决 404 问题</a>）</li>\n</ol>\n<h3 id=\"q2-无法从浏览器访问-kuboard\">Q2: 无法从浏览器访问 Kuboard</h3>\n<p><strong>排查步骤</strong>：</p>\n<pre><code class=\"language-bash\"># 1. 检查容器是否运行\nsudo docker ps | grep kuboard\n\n# 2. 检查端口监听\nsudo netstat -tlnp | grep 41878\n\n# 3. 检查防火墙\nsudo firewall-cmd --list-ports\n\n# 4. 开放端口\nsudo firewall-cmd --permanent --add-port=41878/tcp\nsudo firewall-cmd --permanent --add-port=10081/tcp\nsudo firewall-cmd --reload\n</code></pre>\n<h3 id=\"q3-k3s-集群无法连接\">Q3: K3s 集群无法连接</h3>\n<p><strong>可能原因</strong>：</p>\n<ol>\n<li>API Server 地址错误（应该是服务器 IP，不是 127.0.0.1）</li>\n<li>Token 或证书错误</li>\n<li>K3s 服务未运行</li>\n</ol>\n<p><strong>解决方案</strong>：</p>\n<pre><code class=\"language-bash\"># 检查 K3s 状态\nsudo systemctl status k3s\n\n# 重启 K3s\nsudo systemctl restart k3s\n\n# 重新生成 kubeconfig\nsudo cat /etc/rancher/k3s/k3s.yaml | sed 's/127.0.0.1/10.12.12.110/g'\n</code></pre>\n<h3 id=\"q4-端口被占用\">Q4: 端口被占用</h3>\n<p><strong>检查端口占用</strong>：</p>\n<pre><code class=\"language-bash\">sudo netstat -tlnp | grep :41878\n</code></pre>\n<p><strong>更换端口</strong>：</p>\n<pre><code class=\"language-bash\"># 停止容器\nsudo docker rm -f kuboard\n\n# 使用新端口（如 8888）\nsudo docker run -d \\\n  --restart=unless-stopped \\\n  --name=kuboard \\\n  -p 8888:80/tcp \\\n  -p 10081:10081/tcp \\\n  -e KUBOARD_ENDPOINT=\"http://10.12.12.110:8888\" \\\n  -e KUBOARD_AGENT_SERVER_TCP_PORT=\"10081\" \\\n  -v /data/kuboard:/data \\\n  eipwork/kuboard:v3\n</code></pre>\n<h3 id=\"q5-docker-镜像拉取失败\">Q5: Docker 镜像拉取失败</h3>\n<p><strong>原因</strong>：国内网络访问 Docker Hub 受限。</p>\n<p><strong>解决方案</strong>：使用国内镜像源</p>\n<pre><code class=\"language-powershell\"># 使用华为云镜像源\ndocker pull swr.cn-east-2.myhuaweicloud.com/kuboard/kuboard:v3\n\n# 重新标记\ndocker tag swr.cn-east-2.myhuaweicloud.com/kuboard/kuboard:v3 eipwork/kuboard:v3\n</code></pre>\n<hr />\n<h2 id=\"总结\">总结</h2>\n<p>本文详细介绍了在内网环境下离线安装 Kuboard 并绑定 K3s 集群的完整流程：</p>\n<ol>\n<li><strong>准备阶段</strong>：在联网的 Windows 机器上下载 Kuboard 镜像和 Docker 离线包</li>\n<li><strong>传输阶段</strong>：使用 SecureCRT 的 SFTP 功能将文件传输到内网服务器</li>\n<li><strong>安装阶段</strong>：执行安装脚本，自动完成 Docker 和 Kuboard 的安装</li>\n<li><strong>修复阶段</strong>：解决 nginx 配置问题，更换端口确保正常访问</li>\n<li><strong>绑定阶段</strong>：通过 KubeConfig 或 Token 方式将 K3s 集群绑定到 Kuboard</li>\n</ol>\n<h3 id=\"关键要点\">关键要点</h3>\n<ul>\n<li>✅ 使用国内镜像源加速下载</li>\n<li>✅ 离线安装适用于内网环境</li>\n<li>✅ 手动修复 nginx 配置解决 404 问题</li>\n<li>✅ 使用非标准端口避免冲突</li>\n<li>✅ KubeConfig 方式是最简单的集群绑定方法</li>\n</ul>\n<h3 id=\"最终效果\">最终效果</h3>\n<ul>\n<li><strong>Kuboard 访问地址</strong>：<a href=\"http://10.12.12.110:41878\" rel=\"noopener nofollow\" target=\"_blank\">http://10.12.12.110:41878</a></li>\n<li><strong>默认账号</strong>：admin / Kuboard123</li>\n<li><strong>K3s 集群</strong>：已成功绑定，可通过 Kuboard 管理</li>\n</ul>\n<hr />\n<h2 id=\"参考资源\">参考资源</h2>\n<ul>\n<li>Kuboard 官网：<a href=\"https://kuboard.cn\" rel=\"noopener nofollow\" target=\"_blank\">https://kuboard.cn</a></li>\n<li>K3s 官网：<a href=\"https://k3s.io\" rel=\"noopener nofollow\" target=\"_blank\">https://k3s.io</a></li>\n<li>Docker 官网：<a href=\"https://www.docker.com\" rel=\"noopener nofollow\" target=\"_blank\">https://www.docker.com</a></li>\n<li>SecureCRT 官网：<a href=\"https://www.vandyke.com/products/securecrt/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.vandyke.com/products/securecrt/</a></li>\n</ul>\n<hr />\n<p><strong>作者</strong>：技术博客<br />\n<strong>日期</strong>：2026-01-29<br />\n<strong>版本</strong>：v1.0</p>\n<hr />\n<h2 id=\"附录\">附录</h2>\n<h3 id=\"a-完整的安装脚本\">A. 完整的安装脚本</h3>\n<p>参考 <a href=\"#%E4%B8%89%E5%AE%89%E8%A3%85-kuboard\" rel=\"noopener nofollow\">三、安装 Kuboard</a> 中的 <code>install.sh</code></p>\n<h3 id=\"b-nginx-完整配置\">B. nginx 完整配置</h3>\n<p>参考 <a href=\"#%E5%9B%9B%E8%A7%A3%E5%86%B3-404-%E9%97%AE%E9%A2%98\" rel=\"noopener nofollow\">四、解决 404 问题</a> 中的 nginx 配置</p>\n<h3 id=\"c-端口说明\">C. 端口说明</h3>\n<table>\n<thead>\n<tr>\n<th>端口</th>\n<th>用途</th>\n<th>协议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>41878</td>\n<td>Kuboard Web 界面</td>\n<td>HTTP</td>\n</tr>\n<tr>\n<td>10081</td>\n<td>Kuboard Agent 通信</td>\n<td>TCP/UDP</td>\n</tr>\n<tr>\n<td>6443</td>\n<td>K3s API Server</td>\n<td>HTTPS</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"d-目录结构\">D. 目录结构</h3>\n<pre><code>/data/kuboard/              # Kuboard 数据目录\n├── etcd-data/              # etcd 数据\n├── questdb/                # QuestDB 数据\n└── ...\n\n/etc/rancher/k3s/           # K3s 配置目录\n└── k3s.yaml                # K3s kubeconfig\n\n/tmp/kuboard-offline/       # 离线安装包\n├── docker/\n├── images/\n└── install.sh\n</code></pre>\n<hr />\n<p><strong>感谢阅读！如有问题，欢迎留言讨论。</strong> 🎉</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 14:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ghostmen\">ghostmen</a>&nbsp;\n阅读(<span id=\"post_view_count\">11</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}