{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "Docker 升级后 VS Code 本地调试 AWS Lambda 报「Running AWS SAM projects locally requires Docker」的那些坑与排查思路",
      "link": "https://www.cnblogs.com/wanghaiwei/p/19505845",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wanghaiwei/p/19505845\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 11:48\">\n    <span>Docker 升级后 VS Code 本地调试 AWS Lambda 报「Running AWS SAM projects locally requires Docker」的那些坑与排查思路</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"一问题场景描述\">一、问题场景描述</h2>\n<ul>\n<li>\n<p>在 VS Code 中使用 AWS Toolkit 本地调试 Lambda（基于 AWS SAM 项目）时，点击本地运行/调试，出现提示：<br />\n“Running AWS SAM projects locally requires Docker. Have you got it installed and running?”</p>\n</li>\n<li>\n<p>实际情况是：本地已经安装并运行 Docker Desktop，使用命令行执行&nbsp;<code>docker ps</code>、<code>docker info</code>&nbsp;等都正常，容器环境可用。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n<li>\n<p>换句话说：<strong>Docker 明明在跑，但 VS Code + SAM CLI 坚持说“找不到 Docker”</strong>。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n</ul>\n<hr />\n<h2 id=\"二最终确认的根因你这次遇到的\">二、最终确认的根因（你这次遇到的）</h2>\n<ul>\n<li>\n<p>你找到的最终原因是：<strong>在升级 Docker Desktop 之后，本地的 AWS SAM CLI 以及关系紧密的 AWS 工具链（如 VS Code 插件）版本没有同步升级，导致与新 Docker 版本的 API/行为不兼容</strong>。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n<li>\n<p>升级 AWS SAM CLI 和 AWS 相关插件到最新版本后，错误提示消失，本地调试恢复正常。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]</p>\n</li>\n<li>\n<p>升级方法：跟着官方文档重新下载安装包，会自动升级：<a href=\"https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html#install-sam-cli-instructions%E2%80%8B\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html#install-sam-cli-instructions​</a></p>\n</li>\n</ul>\n<p>这一点可以作为你分享里的“主线故事”——“隐形的版本兼容问题”。</p>\n<hr />\n<h2 id=\"三可能的原因总览可用作分享中的-checklist\">三、可能的原因总览（可用作分享中的 checklist）</h2>\n<p>你可以按“从最基础到偏高级”的顺序介绍，帮助听众形成排查思路。</p>\n<h3 id=\"31-docker-本身真的没装--没启动\">3.1 Docker 本身真的没装 / 没启动</h3>\n<p>虽然看起来很基础，但在团队里经常是最真实的情况，可以简要提一下。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n<ul>\n<li>\n<p>未安装 Docker Desktop 或其他 Docker 引擎。</p>\n</li>\n<li>\n<p>Docker Desktop 已安装，但当前没有启动（托盘图标还在 starting / 未 running 状态）。</p>\n</li>\n<li>\n<p>在 VS Code 集成终端中运行&nbsp;<code>docker ps</code>&nbsp;报“Cannot connect to the Docker daemon”等错误。</p>\n</li>\n</ul>\n<p><strong>定位方式</strong></p>\n<ul>\n<li>\n<p>打开 VS Code 集成终端，执行&nbsp;<code>docker ps</code>、<code>docker info</code>。</p>\n</li>\n<li>\n<p>如果这里都失败，基本优先检查 Docker 安装和启动状态。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"32-vs-code-所在环境与-docker-不在同一个世界\">3.2 VS Code 所在环境与 Docker 不在同一个“世界”</h3>\n<p>这是第二类很常见的问题：<strong>你在 A 终端里能用 Docker，但 VS Code 使用的是 B 环境</strong>。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n<p>典型情形：</p>\n<ul>\n<li>\n<p>在 Windows 上用 WSL 打开工程，而 Docker Desktop 只在 Windows 环境可见；VS Code 的调试在 WSL 里跑，WSL 内没有可用的 Docker socket。</p>\n</li>\n<li>\n<p>使用 Dev Container / Remote-SSH / Remote-WSL 等远程开发模式，但容器/远程环境内部没有 Docker 或没有映射 Docker socket。</p>\n</li>\n<li>\n<p>手动开终端时用的是一个 shell profile，设置了一些变量或 alias，而 VS Code 集成终端没有加载同样的配置。</p>\n</li>\n</ul>\n<p><strong>定位方式</strong></p>\n<ul>\n<li>\n<p>一律在 VS Code 集成终端中执行：<code>docker ps</code>、<code>sam local invoke</code>，看输出和普通终端是否一致。</p>\n</li>\n<li>\n<p>如果普通终端 OK，VS Code 里失败，就可以讲：<br />\n“问题在于 VS Code 运行 SAM CLI 的环境，与我平时用的终端环境不一样。”[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"33-docker_host--docker-context-配置把-sam-带偏\">3.3 DOCKER_HOST / Docker context 配置把 SAM “带偏”</h3>\n<p>当使用过远程 Docker、Colima、Rancher Desktop 等工具时，很容易留下旧的&nbsp;<code>DOCKER_HOST</code>&nbsp;环境变量或非默认 Docker context。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n<p><strong>典型问题</strong></p>\n<ul>\n<li>\n<p><code>DOCKER_HOST</code>&nbsp;指向一个已经不存在或不可达的远程 Docker。</p>\n</li>\n<li>\n<p>当前 Docker context 是某个远程/实验环境，而不是本地 Desktop。</p>\n</li>\n<li>\n<p>用&nbsp;<code>docker ps</code>&nbsp;可能还显示得正常，但实际连的是某个奇怪的 host。</p>\n</li>\n</ul>\n<p><strong>排查与修复</strong></p>\n<ul>\n<li>\n<p>在 VS Code 集成终端中查看环境变量：</p>\n<ul>\n<li>\n<p>Linux/macOS:&nbsp;<code>env | grep DOCKER_HOST</code></p>\n</li>\n<li>\n<p>PowerShell:&nbsp;<code>Get-ChildItem Env:DOCKER_HOST</code></p>\n</li>\n</ul>\n</li>\n<li>\n<p>如果有值，可以尝试临时&nbsp;<code>unset</code>&nbsp;/&nbsp;<code>Remove-Item Env:DOCKER_HOST</code>，再试一次本地调试。</p>\n</li>\n<li>\n<p>查看 Docker context：<code>docker context ls</code>，确认当前 active 的 context 是否是预期的本地环境。</p>\n</li>\n<li>\n<p>若问题解决，可以在分享中强调：<br />\n“遇到 Docker 明明在跑却被认为‘不可用’时，记得检查 DOCKER_HOST 和 docker context。”[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"34-docker-版本升级后sam-cli--工具链版本太旧你的实际案例\">3.4 Docker 版本升级后，SAM CLI / 工具链版本太旧（你的实际案例）</h3>\n<p>这是你这次遇到的核心原因，也非常适合重点讲解。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n<p><strong>现象</strong></p>\n<ul>\n<li>\n<p>Docker Desktop 升级到新版本之后，<code>docker ps</code>&nbsp;等命令都正常。</p>\n</li>\n<li>\n<p>但通过 VS Code（AWS Toolkit）点击本地运行 Lambda，提示仍然是 “Running AWS SAM projects locally requires Docker…”。</p>\n</li>\n<li>\n<p>手动在终端执行&nbsp;<code>sam local invoke</code>&nbsp;或&nbsp;<code>sam local start-api</code>&nbsp;可能也会报类似“Docker 不可达”或 API 相关的错误。</p>\n</li>\n</ul>\n<p><strong>原因</strong></p>\n<ul>\n<li>\n<p>老版本的 AWS SAM CLI 内部依赖的 Docker 客户端库，对新 Docker API 或某些行为不兼容。</p>\n</li>\n<li>\n<p>VS Code 的 AWS Toolkit 也有对 SAM CLI 或 Docker 的版本要求，如果太旧，检测逻辑会失败。</p>\n</li>\n<li>\n<p>结果就是：<strong>Docker 实际可用，但健康检查阶段就“挂了”，于是前端统一抛出“需要安装 Docker”这种误导性的错误信息</strong>。[<a href=\"https://stackoverflow.com/questions/50791354/running-aws-sam-projects-locally-get-error\" rel=\"noopener nofollow\" target=\"_blank\">stackoverflow</a>]​</p>\n</li>\n</ul>\n<p><strong>解决方式</strong></p>\n<ul>\n<li>\n<p>升级 AWS SAM CLI 到最新稳定版本。</p>\n</li>\n<li>\n<p>升级 VS Code 中的 AWS Toolkit（以及如有需要的 AWS CLI 等依赖）。</p>\n</li>\n<li>\n<p>升级后再次尝试本地运行 Lambda，问题消失。</p>\n</li>\n</ul>\n<p>这一段可以作为你分享里“真正踩坑”的部分，强调“Docker 升级后别忘了升级 SAM / 工具链”。</p>\n<hr />\n<h2 id=\"四推荐的排查顺序可以直接投屏的一张-slide\">四、推荐的排查顺序（可以直接投屏的一张 slide）</h2>\n<p>你可以整理成一个“故障排查流程”：</p>\n<ol>\n<li>\n<p><strong>确认 Docker 真的在 VS Code 环境里可用</strong></p>\n<ul>\n<li>在 VS Code 集成终端执行&nbsp;<code>docker ps</code>、<code>docker info</code>。</li>\n</ul>\n</li>\n<li>\n<p><strong>检查环境是否一致</strong></p>\n<ul>\n<li>\n<p>是否在 WSL / Dev Container / 远程环境中？</p>\n</li>\n<li>\n<p>这些环境里是否也安装/映射了 Docker？</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>检查 DOCKER_HOST 和 Docker context</strong></p>\n<ul>\n<li>移除可疑的&nbsp;<code>DOCKER_HOST</code>；确认当前 context 正确。</li>\n</ul>\n</li>\n<li>\n<p><strong>检查版本兼容</strong></p>\n<ul>\n<li>\n<p>Docker Desktop 是否刚升级？</p>\n</li>\n<li>\n<p><code>sam --version</code>&nbsp;是否很老？</p>\n</li>\n<li>\n<p>升级 AWS SAM CLI、AWS Toolkit 等工具到最新版本。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>再次从 VS Code 中发起本地调试</strong></p>\n<ul>\n<li>验证问题是否解决。</li>\n</ul>\n</li>\n</ol>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 11:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wanghaiwei\">游学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">10</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Python å­¦ä¹ ç¬”è®°ï¼šåŸºç¡€è¯­æ³•å­¦ä¹",
      "link": "https://www.cnblogs.com/owlman/p/19505712",
      "published": "",
      "description": "<h2 class=\"post-title\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/owlman/p/19505712\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 11:34\">\n    <span>Python 学习笔记：基础语法学习</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>[!NOTE] 笔记说明</p>\n<p>根据之前在《[[关于Python的学习|Python 学习路系统图规划]]》一文中的规划，这篇笔记中将会具体记录我在学习 Python 的基础语法规则过程中的一些心得体会与编程练习，它们将主要聚焦于以下议题：</p>\n<ul>\n<li>了解在 Python 代码中会出现的注释、变量、操作符以及表达式等基本元素；</li>\n<li>了解 Python 的内置数据类型、自定义类型以及它们可执行的相关操作；</li>\n<li>了解如何在 Python 中使用函数、对象以及模块来实现面向过程/对象的编程；</li>\n</ul>\n</blockquote>\n<p>自《The C Programming Language》这本在编程语言领域中被誉为“圣经”的经典教材问世以来，在命令行终端环境中输出带有“Hello World”字样的信息已经成为了人们学习一门新的编程语言，或者测试该语言的执行环境是否正常的第一个演示程序。这样做不仅可以先让我们对自己要学习的编程语言及其执行环境有一个整体的印象，同时也为该语言的基础语法学习提供了一个切入点。接下来，就让我们闲话少说，先从《[[编程环境配置]]》那篇笔记末尾的那版 Hello World 程序开始聊起吧，其代码如下所示。</p>\n<pre><code class=\"language-python\">#! /usr/bin/env python\n'''\n    Simple example to say hello\n    \n    Author: lingjie\n    Created on: 2024-06-15\n    '''\n\nauthor_name = \"owlman\"\ndef say_hello(name: str) -&gt; None:\n    '''\n        Say hello by name.\n     \n        Args:\n            name: name to greet\n    '''\n    print(\"Hello World! My name is\", name)\n\nif __name__ == \"__main__\":\n    say_hello(author_name)\n</code></pre>\n<h2 id=\"为代码编写注释\">为代码编写注释</h2>\n<p>在上述代码中，我们首先看到的应该是注释信息。通常情况下，程序员们编写注释的目的是让阅读代码的人能更好地理解自己的设计意图，这对于代码的后期测试和维护工作有着非常重要的现实意义。在 Python 的语法规则中，注释主要有以下两种形式。</p>\n<ul>\n<li>\n<p><strong>以<code>#</code>符号开头的单行注释</strong>：这种形式的注释可以在代码的任意地方以<code>#</code>符号开头编写注释信息，直至其所在行结束为止，例如像下面这样。</p>\n<pre><code class=\"language-python\"># Python 支持加法运算\nx = 7\ny = 8\nz = x + y # 请问 z = ？\n</code></pre>\n</li>\n<li>\n<p><strong>用三个单引号包括起来的字符串</strong>：严格来说，这种形式的字符串并不属于真正的注释语法。但由于它可以被放置在代码中的任何位置上，并且可用于呈现包含换行符的长文本信息，所以常被程序员们用来编写多行注释，例如像下面这样。</p>\n<pre><code class=\"language-python\">'''\n示范 Python 中的加法运算\n涉及变量：x、y、z\n'''\n\nx = 7\ny = 8\nz = x + y\nprint(\"z = \", z)\n</code></pre>\n<p><strong>需要再次强调的是</strong>，如果严格按照 Python 的语法规则来说，上述字符串的作用与纯粹的注释语法并不完全相同。虽然在大多数情况下，这种形式的字符串不会对代码的执行产生任何影响，但如果我们将这种字符串放置在了函数或类定义的开头，它就会被当作该函数或类的<strong>文档字符串（docstring）</strong>来处理，这可以通过<code>help()</code>函数来查看该函数或类的文档说明。例如在上面的 Hello World 程序中，我们就使用了这种多行字符串对象为<code>say_hello()</code>函数编写了一个文档字符串。读者可以通过在 Python 的交互式界面中输入<code>help(say_hello)</code>命令来查看该函数的文档说明，具体如图 1 所示。</p>\n  \n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 1</strong>：Python 中的文档字符串</p>\n</li>\n</ul>\n<p>正如我们之前所说，注释存在的目的是说明程序员编写相关代码的意图，以此来提高代码的可读性，方便日后的测试与维护工作。例如在上面这段示例代码中，我们用注释说明了它用于示范在 Python 中执行加法运算，并使用了<code>x</code>、<code>y</code>、<code>z</code>三个变量，当然了，编写这种画蛇添足式的注释在实际生产环境中并不值得鼓励。因为，我们必须考虑到 Python 本身就是一门用于表达信息的语言，它的作用除了让机器按照它的意图正确执行之外，也应该让使用这门语言的人类看得懂它的意图。<strong>注释的作用只能是辅助说明，可不是充当 Python 自身的翻译</strong>。换而言之，我们应该尽量用代码本身来表达它所要表达的意图，而不是处处都借助注释。</p>\n<p>除了说明代码的意图之外，注释还有一个额外的作用：<strong>在调试过程中临时去除某一行代码</strong>。举个例子，如果我在调试下面这几行代码的时候发现自己的命令行终端不能显示中文，为了确定这不是代码本身的问题，我可能会选择像下面这样，临时注释掉中文的输出，然后增加一条英文的输出。在很多时候，这种利用注释语法来临时切换要执行的代码，也是一种很常用的代码调试技巧。</p>\n<pre><code class=\"language-python\">name = \"lingjie\"\n# print(\"你好！\", name)\nprint(\"Hello \", name)\n</code></pre>\n<h2 id=\"变量与函数\">变量与函数</h2>\n<p>下面，让我们继续之前 Hello World 程序的讲解。读者在看完该程序的注释说明之后，接下来会看到的是一个用于定义变量或函数的语句。众所周知，由于编程语言是一种表达思维更接近于数学的人类语言，所以我们在用它描述一件事物时，通常需要先完成对它的定义，例如，描述一个数据，通常需要先定义一个变量，描述一组操作，通常需要先定义一个函数。下面，就让我们从变量的定义开始，带读者逐步了解如何使用 Python 来描述一件自己想让计算机完成的事情吧！</p>\n<h3 id=\"变量的定义\">变量的定义</h3>\n<p>“变量\"这个概念最早源自于数学中的代数运算，为了方便演算过程的书写，我们通常会用一些简单的字母来指代演算过程中不断变化的已知量或未知量，毕竟在公式中写<code>x</code>、<code>y</code>、<code>z</code>这样的字母总是要比写 <span class=\"math inline\">\\(10^{55}\\)</span> 这样的数字或者 <span class=\"math inline\">\\(\\sum_{i=0}^{n}\\)</span> 这样的表达式简单方便多了。而到了计算机编程语言中，变量的概念得到了进一步扩展，除了是某个数据值的指代外，它还关联着计算机中用于存储该数据的一块内存空间，换而言之，变量现在还是程序用来存储某个数据的容器。当然了，这些容器既然能被称为“变”量，也就说明它们所存储的数据是会随着程序的执行而变化的。由于变量是程序所要操作的基本对象，所以在编写程序时，定义变量往往是我们首先要做的工作。具体到 Python 中，用于定义变量的语法规则如下。</p>\n<pre><code class=\"language-python\">[变量名] = [变量值]\n</code></pre>\n<p>在这里，<code>[变量名]</code>是我们要定义的变量名称，<code>[变量值]</code>则是我们要使用该变量描述的数据。例如在之前的 Hello World 程序中，<code>author_name = \"lingjie\"</code>就是一个标准的变量定义语句，其中的<code>author_name</code>就是<code>[变量名]</code>，而<code>\"lingjie\"</code>则是<code>[变量值]</code>。</p>\n<p>下面，让我们先来具体讨论一下<code>[变量名]</code>的设置问题。和绝大多数编程语言一样，Python 中的变量名可以由字母、数字与下划线以任何顺序排列组合而成，其中不能包含空格符以及<code>-</code>、<code>$</code>这样的特殊符号，并且只能以字母、下划线开头，像下面这些变量名都是不被允许的：</p>\n<pre><code class=\"language-python\">$dollar = 100\n2day = 10\n'Week =11\n\\Month = 12\n/Year = 14\nmy-name = \"lingjie\"\n</code></pre>\n<p>除此之外，我们所使用的变量名还需要注意避开 Python 语言自身要使用的关键字，我们可以利用语言标准库中一个名为<code>keyword</code>的模块来获取当前已被 Python 占用的所有关键字，具体如图 2 所示。</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 2</strong>：Python 中的关键字</p>\n<p>当然了，出于代码可读性方面的考虑，我们在选择变量名的时候还应该尽量使用有意义的单词或单词组合，不能太过随意。在这里，笔者个人更倾向于建议读者应在变量的命名上遵守某种一致的命名规范。譬如驼峰命名法，遵守这种命名规范的变量名通常由一个以上的单词组成，除了首个单词的字母不是大写，其余所有单词的首字母均为大写，例如<code>myName</code>、<code>myBook</code>、<code>someValue</code>、<code>getObject</code>等。而在 Python 社区中，人们通常更倾向于使用下划线来分隔英文单词的蛇形命名法来命名变量，例如<code>my_name</code>、<code>my_book</code>、<code>some_value</code>、<code>get_object</code>等。虽然这些命名规范并不是强制性的，但它们可以帮助我们更好地理解代码的意图，尤其是在团队协作中，遵守统一的命名规范更是至关重要。</p>\n<p>在掌握了<code>[变量名]</code>的设置方法之后，我们就可以接着来讨论<code>[变量值]</code>的设置问题了。如果读者之前学习过 C/C++/Java 这类编程语言，想必一定会发现在 Python 中定义变量是不需要声明变量类型的。因为 Python 是一门动态类型语言，它会在运行时自动根据变量值的类型来决定该变量的类型。也就是说，Python 语言中的变量是可以随时改变其存储的数据类型的。例如，我们可以先将一个整数值赋给一个变量，然后再将一个字符串值赋给同一个变量，这样就可以让该变量的类型从整数变成字符串了，就像下面这样：</p>\n<pre><code class=\"language-python\">x = 100          # 将整数值赋给变量 x\nprint(x)         # 输出变量 x 的值为 100\nx = \"lingjie\"    # 再将字符串值赋给同一个变量 x\nprint(x)         # 输出变量 x 的值为 \"lingjie\"\n</code></pre>\n<p>至于 Python 的变量中究竟可以存储哪些类型的数据，我稍后会在讨论“对象与数据类型”这一议题时再详细介绍。现在，读者只需要知道在 Python 中定义变量时，我们只需要指定变量名和变量值即可。</p>\n<h3 id=\"函数的定义\">函数的定义</h3>\n<p>和变量一样，“函数”这个概念最早也源自于数学，用于描述运算变量之间的关系。例如三角函数中的正弦函数 <span class=\"math inline\">\\(y = sin(x)\\)</span>，它描述的是一个变量 <span class=\"math inline\">\\(x\\)</span> 与另一个变量 <span class=\"math inline\">\\(y\\)</span> 之间的关系。随着计算机编程语言的发展，函数的概念也得到了相应的扩展，它现在不仅可以表示两个变量之间的关系，还可以表示一组操作的集合，这些操作可以接受输入并返回输出。换而言之，函数就是一组可以被调用来执行特定任务的代码块。在 Python 中，函数定义语句的语法规则如下。</p>\n<pre><code class=\"language-python\">def [函数名称]([参数列表]) -&gt; [返回值类型]:\n    '''\n    [功能说明]\n    '''\n    [函数主体]\n</code></pre>\n<p>正如读者所见，按照 Python 的语法规则，函数的定义语句必须要以<code>def</code>这个关键字开头，然后需依次定义<code>[函数名称]</code>、<code>[参数列表]</code>、<code>[功能说明]</code>以及要执行的<code>[函数主体]</code>，其具体说明如下：</p>\n<ul>\n<li><code>[函数名称]</code>是被定义函数的名称，在 Python 中，函数的命名规则与变量是一样的，读者可以自行参考之前关于变量命名规则的介绍来了解更多细节。</li>\n<li><code>[参数列表]</code>是调用函数时需要传入的参数列表，它可以为空，也可以包含一个或多个参数。每个参数之间用逗号隔开，参数的命名规则同样与变量名一致。在 Python 3.5 之后的版本中，我们还可以通过<code>参数名:参数类型标注</code>的形式来标注相应参数的类型，例如<code>name:str</code>、<code>age:int</code>、<code>height:float</code>等。但需要注意的是，参数类型的标注语法是可选的、也不具备强制性的约束，换言之，它并不会在函数被调用时对传入的参数值进行实际的类型检查，但它可以帮助我们更好地理解代码的意图。</li>\n<li><code>-&gt; [返回值类型]</code>是函数返回值的类型标注语法，它也是可选的，用于说明该函数的返回值类型。同样需要注意的是，它也不会在函数被调用时对返回值进行实际的类型检查。</li>\n<li><code>[功能说明]</code>是之前演示过的文档字符串，它是一个用于描述函数功能和用法的多行字符串，通常位于函数定义的第一行。在函数的功能过于简单时，这个说明可以省略不写，但在函数的功能较为复杂时，编写一个清晰的功能说明是非常有必要的。</li>\n<li><code>[函数主体]</code>是函数的具体实现部分，其中包含了该函数执行的所有代码。</li>\n</ul>\n<p>如果具体到 Hello World 程序中，<code>[函数名称]</code>对应的就是<code>say_hello</code>，<code>[参数列表]</code>在这里就是一对小括号中的<code>name:str</code>，而<code>[功能说明]</code>则是我们之前在 Python 交互式终端中使用<code>help</code>函数展示过的那个文档字符串。最后，其<code>[函数主体]</code>中只有一条用于打印文本信息的语句。</p>\n<h3 id=\"作用域与命名空间\">作用域与命名空间</h3>\n<p>与 C/C++/Java 这类大家熟悉的编程语言相比，Python 语法的最大特色之一就是：它不是使用大括号，而是使用文本缩进格式来表示不同的作用域。因此，我们可以在用于函数定义的语法规则中看到，<code>[函数主体]</code>所在的区域与<code>def</code>所在的行之间存在着四个空格的文本缩进，这代表着它们属于不同的作用域。<strong>需要注意的是</strong>：虽然在 Python 的语法规则上，定义作用域的缩进所使用的空格数是可变的，但同一级作用域使用的缩进必须保持相同的空格数，否则就会出现错误。</p>\n<p>在同一个作用域内，我们通常都有一个独立的变量命名空间可以使用，读者可以在其中定义多个局部变量，并编写多行语句来执行与这些变量相关的操作，完全不必担心当前作用域所使用的变量名与某个全局作用域或其他作用域中的变量冲突。例如，如果我们在之前的 Hello World 程序中新增一个名为<code>say_hello_to_me</code>的函数，并在该函数重新定义一个名为<code>author_name</code>的变量，那么它就会覆盖掉之前定义的全局变量<code>author_name</code>，从而使得该函数内部的代码可以使用这个变量名来引用新的值，具体如下。</p>\n<pre><code class=\"language-python\">author_name = \"owlman\"  # 全局变量   \n\ndef say_hello(name: str) -&gt; None:\n    '''\n        Say hello by name.\n     \n        Args:\n            name: name to greet\n    '''\n    print(\"Hello World! My name is\", name)\n\ndef say_hello_to_me() -&gt; None:\n    '''\n        Say hello to myself.\n    '''\n    author_name = \"lingjie\" # 局部变量\n    say_hello(author_name)\n\nif __name__ == \"__main__\":\n    say_hello(author_name)  # 输出：Hello World! My name is owlman\n    say_hello_to_me()       # 输出：Hello World! My name is lingjie\n</code></pre>\n<p>上述修改的执行结果如图 3 所示，读者可以看到，在<code>say_hello_to_me</code>函数中重新定义的<code>author_name</code>变量并没有影响到全局变量的值。</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 3</strong>：Python 中的作用域</p>\n<p>在 Python 中，除了全局作用域和局部作用域之外，还有一类作用域通常称为“内置作用域”（builtins）。它由 Python 的内置名称组成（由内置模块 builtins 提供），例如内置函数 print 就属于这个作用域。内置名称在名称查找的 LEGB 顺序中位于最后一步，通常可以在任何地方使用，但也可以被局部或全局同名变量覆盖（shadow）。</p>\n<h2 id=\"对象与数据类型\">对象与数据类型</h2>\n<p>现在，让我们再回过头来重点关注一下变量中可以存储的数据类型。在计算机中，如果程序想要对某一块内存空间中数据进行存储和操作，首先要明确的是该空间内数据的存储形式和操作方法。譬如，变量中存储的是数据本身还是数据在内存中的位置？这将决定着这些数据的复制方式。再譬如，变量中的数据可以执行什么操作？是算术运算还是逻辑判断，亦或是文本处理？这就需要我们对这些内存空间中的数据，即变量的值进行归类，譬如用来做算术运算的数据归为一类，用于文本处理的数据则归为另一类，在编程术语上，这些归类被人们约定俗成地称之为“类型（type）”。简而言之，就是变量中的值所属的类型决定了该变量的存储形式及其可以执行的操作。下面，我们具体介绍一下在 Python 中可以使用的数据类型，先从该语言支持的基本数据类型开始。</p>\n<h3 id=\"基本数据类型\">基本数据类型</h3>\n<p>在编程语言中，基本数据类型指的是语言本身内置的、可以直接使用的数据类型。Python 语言中支持的基本数据类型主要有以下六种：</p>\n<ul>\n<li>\n<p><strong><code>number</code>类型</strong>：即数字类型，Python 主要支持的数字类型分别是：<code>int</code>（整数类型）、<code>float</code>（浮点类型）、<code>bool</code>（布尔类型）、<code>complex</code>（复数类型）。这些数据类型可用于执行各种数学运算，包括加法、减法、除法、整除、取余、乘法和乘方等，下面是一些操作示例：</p>\n<pre><code class=\"language-python\">print(3+2)         # 加法运算，输出结果是 5\nprint(10.4-3)      # 减法运算，输出结果是 7.4\nprint(15/4)        # 除法运算，输出结果是 3.75\nprint(15//4)       # 整除运算，输出结果是 3\nprint(15%4)        # 取余运算，输出结果是 3\nprint(2*3)         # 乘法运算，输出结果是 6\nprint(2**3)        # 乘方运算，输出结果是 8\n</code></pre>\n<p><em>值得一提的是</em>，Python 在 3.x 版本之后采用了非固定大小的<code>int</code>类型，这让它可以自动适应任意大小的整数值（唯一的限制是计算机的可用内存量）。在处理较小的整数时，Python 会使用计算机底层的<code>int</code>类型来表示它们。当需要处理较大的整数时，Python 就会自动转换为占用位数更多的表示形式。当然，为了能对较大的整数值执行运算，Python 必须要将这些运算拆解成若干个能直接交给计算机硬件处理的小型运算单元，其拆解过程与我们用笔算的方式来进行长除法运算非常类似。尽管这种运算方式的效率并不高（因为这需要执行更多步骤），但是它们允许 Python 将<code>int</code>类型扩展至任意大小。</p>\n</li>\n<li>\n<p><strong><code>string</code>类型</strong>：即字符串类型。在 Python 语言中，字符串类型的数据就是由一对单引号、双引号或三引号括住的一段文本信息，这段文本中所有的空格和制表符都照原样保留。在三种字符串的表示方式中，单引号与双引号的作用在大多数时候是一样的，只有当字符串本身的内容中包含单引号时，它就只能用双引号或三引号来表示。而三引号则通常用于表示包含多行文字的字符串，同样的，我们也可以在三引号中自由使用单引号和双引号。在编程活动中，字符串类型的数据主要用于执行各种文本处理操作，包括文本的输入、输出、存储、拼接和截取等，下面是一些操作示例：</p>\n<pre><code class=\"language-python\">name = \"lingjie\"                   # 存储一般的字符串数据\nI_am = \"I'm \"                      # 存储带单引号的字符串数据\nother = '''\nage:  42\njob: writer\n'''                                # 存储多行字符串数据\nmessage = I_am + name + other      # 拼接字符串数据并存储\n\nprint(message)                     # 输出变量 message 中存储的字符串数据\nprint(message[0:11])               # 截取变量中的某一段字符串并输出\nprint(r\"Newlines are indicated by \\n\") # 忽略字符串中的转义字符并输出\n</code></pre>\n<p>另外，如果读者想要让 Python 运行时环境忽略字符串数据中所有的转义字符，也可以在表示字符串的单引号或双引号之前加一个前缀<code>r</code>。例如在上面的最后一行代码中，如果我们希望的是原样输出下面字符串中的换行符<code>\\n</code>，而不是让它发挥换行效果。</p>\n</li>\n<li>\n<p><strong><code>list</code>类型</strong>：即列表类型。在 Python 语言中，列表类型的数据就是由一对中括号括住的对象序列，序列中的这些对象彼此之间需用逗号隔开，通常被称为列表的元素。这些元素可以是 Python 支持的任意数据类型，既可以是这里正在介绍的六大基本数据类型，也可以是我们稍后要介绍的自定义类型，或者通过引入第三方库获得的扩展数据类型。在基于 Python 的编程中，列表类型的数据可用于执行针对一整个元素序列的相关操作，例如成批量地执行增、删、改、查以及排序等操作，下面是一些操作示例：</p>\n<pre><code class=\"language-python\">list_1 = [                  # 将三个不同类型的数据存储为列表的元素\n    10,                     # 列表的第一个元素为数字类型的数据\n    \"string data\",          # 列表的第二个元素为字符串类型的数据\n    [1, 2, 3]               # 列表的第三个元素为列表类型的数据\n]\nprint(list_1)               # 输出列表中的所有元素\nprint(list_1[1])            # 输出索引值为 1 的元素\nprint(list_1[0:2])          # 使用切片操作指定要输出的列表子序列\n# 请注意：列表的索引值是从 0 开始的，所以这里输出的是第二个元素\nlist_1[0] = 100             # 将索引值为 0 的元素修改为 100\nlist_1.remove([1,2,3])      # 找到并删除列表中的第三个元素\nprint(list_1)               # 重新输出列表中的所有元素\nlist_1.append([7, 8, 9])    # 在列表末尾重新添加元素\nprint(list_1)               # 重新输出列表中的所有元素\n</code></pre>\n</li>\n<li>\n<p><strong><code>tuple</code>类型</strong>：即元组类型。在 Python 语言中，元组类型的数据可以被视为一个只读的列表。元组中的元素也可以是任意类型的数据，这些元素会被放置在一对小括号中，并用逗号隔开。由于元组中的元素是不可修改的，所以该数据类型通常用于执行一次性的批量数据存储以及各种查找、遍历等只读操作，下面是一些操作示例:</p>\n<pre><code class=\"language-python\">tuple_1 = (\"abcd\", 706, \"lyy\", 898, 5.2)    # 将一些数据存储为元组的元素\nprint(tuple_1)                              # 输出元组中的所有元素\nprint(tuple_1[0])                           # 输出索引值为 0 的元素 \nprint(tuple_1[1:3])                         # 使用切片操作指定要输出的元组子序列\n</code></pre>\n</li>\n<li>\n<p><strong><code>set</code>类型</strong>：即集合类型。在 Python 语言中，集合类型的数据可以被视为一个元素不能重复的列表。集合中的元素被放置在一对大括号中，并用逗号隔开。当然，考虑到<code>{}</code>同时也是稍后要介绍的字典类型所使用的符号，空集合就需要调用<code>set()</code>函数来完成初始化了。由于集合中的元素是不能重复的，所以该数据类型通常用于在执行数据存储时需要删除冗余数据的操作，下面是一些操作示例：</p>\n<pre><code class=\"language-python\">set_0 = set()               # 空集合需要通过调用 set() 来完成初始化\nset_1 = {18,19,18,20,21,20} # 如果存储到集合中的元素存在重复\nprint(set_1)                # 我们就会看到相同的元素只会被保留一个\n</code></pre>\n</li>\n<li>\n<p><strong><code>dictionary</code>类型</strong>：即字典类型。在 Python 语言中，字典类型的数据可以被视为一个元素为<code>[键]:[值]</code>结构的列表。字典中的每个元素都必须是一个<code>[键]:[值]</code>结构的数据，它们将会被放置在一对大括号中，并用逗号隔开。该数据类型通常用于执行一些键值查找相关的操作，下面是一些操作示例：</p>\n<pre><code class=\"language-python\">map_1 = { # 将两个[键]:[值]结构的数据存储为字典的元素\n    \"name\" : \"lingjie\",    # name 是键，lingjie 是值\n    \"age\" : \"25\"           # age 是键，25 是值\n}\nprint(map_1)               # 输出字典中的所有元素\nmap_1[\"sex\"] = \"boy\"       # 添加一个键为 sex，值为 boy 的元素 \nprint(map_1)               # 重新输出字典中的所有元素\n\n# 如果想删除字典中的指定元素时，可以使用 del 语句来完成\ndel map_1[\"age\"]           # 删除键为 age 的元素\nprint(map_1)               # 重新输出字典中的所有元素\n</code></pre>\n</li>\n</ul>\n<h3 id=\"自定义类型\">自定义类型</h3>\n<p>除了上述基本数据类型之外，Python 语言还支持程序员通过自定义类型的方式来引入更复杂的数据类型，以便获得更强大的表达能力。和绝大多数支持面向对象的编程语言一样，这一扩展可用数据类型的能力是通过一种叫做“类定义”的语句来完成的，该语句的语法规则具体如下。</p>\n<pre><code class=\"language-python\">class [类型名称]([父类]):\n    '''\n    [类型的功能说明]\n    '''\n    [类型的属性和方法]\n</code></pre>\n<p>在面向对象设计的概念中，“类”可以被视为是对某一种数据类型的结构描述。这种描述通常是抽象的，Python 解释器需要负责将该抽象描述具现化为内存中实际可操作的数据，这一过程被称为“实例化”，实例化的结果则被称为该类型的“实例”或“对象”。而这种抽象化的描述通常主要由 <strong>属性</strong> 和 <strong>方法</strong> 两部分组成。在了解了这些概念之后，我们就可以开始对上述语法规则做一个具体的解释了。</p>\n<p>在 Python 中，类定义语句通常会以<code>class</code>关键字开头。紧接着，我们需要为其指定一个<code>[类型名称]</code>，自定义类型的命名规则与变量是完全一致的，只不过在习惯上，我们通常会选择首字母大写的名称。再接着是需要在一对小括号中指定当前类型继承自哪一个<code>[父类]</code>，在 Python 3.x 中，所有自定义的类型都会默认继承自<code>object</code>类，所以如果没有特别指定的父类，这里其实是可以省略的。再接下来，<code>[类型的功能说明]</code>的部分其实就是用于描述该类型的文档字符串，我们可以用它对该类型的设计意图做个说明，包括该类型在被实例化时所需的参数、该类型所拥有的属性以及可执行的操作等。最后，我们就可以开始定义<code>[类型的属性和方法]</code>了。</p>\n<p>类型的属性通常指的是可以存储在该类及其实例中的数据，例如，如果我们想自定义一个表示“书”这个概念的自定义类型，它的书名、作者、出版社等子数据都属于“书”这个类型的属性。具体到了 Python 这门编程语言中，自定义类型的属性包括实例属性与类属性两种，它们的主要区别如下。</p>\n<ul>\n<li>\n<p>在数据的归属问题上：实例属性中的数据由该类型的每个实例各自拥有，相互独立；而类属性中的数据有且只有一份，由该类型的所有实例共有的属性。也就是说，类属性可以直接通过<code>[类型名称]</code>来访问的数据，而实例属性则是需要先将类型实例化成具体的对象，然后通过该对象才能访问的数据。</p>\n</li>\n<li>\n<p>属性的定义方式上：实例属性需要在一个名为<code>__init__()</code>特殊方法中通过<code>self</code>这个关键字来定义，该方法会在类型被实例化时被自动调用，并对该属性执行初始化操作，实例属性的定义就属于该初始化操作的一部分。而类属性的定义只需在上述语法规范中<code>[类型的属性和方法]</code>所在的缩进区域执行变量添加操作即可，没有特定的位置。例如，如果我们想为之前讨论的“书”这个类型添加一个名为<code>help</code>的类属性和书名、作者、出版社等实例属性，我们可以像下面这样来定义它们。</p>\n</li>\n</ul>\n<pre><code class=\"language-python\">class Book:\n    help = '''这里定义的是一个类属性。'''\n\n    def __init__(self, book_data):\n        # 这里将定义三个实例属性：\n        self.name = book_data[\"name\"]\n        self.author = book_data[\"author\"]\n        self.pub = book_data[\"pub\"]\n</code></pre>\n<p>在上述代码中，<code>__init__</code>就是该自定义类型的一个方法。在面向对象的概念中，类型的方法通常指的是该类型可以执行的操作。我们可以使用<code>def</code>关键字在上述语法规范中<code>[类型的属性和方法]</code>所在的缩进区域为自定义的类型添加方法。具体添加方式与之前介绍的函数定义语句是一样的，只不过在定义方法时需要记住一点：<strong>它的参数列表中必须要有一个名为<code>self</code>的参数，且必须是第一个参数</strong>。这个<code>self</code>参数用于指涉当前被称作的实例，它可以让我们在方法中访问该实例的属性和其他方法。下面是一个示例，展示了如何为之前的“书”类型添加一个名为<code>update_name</code>的方法，用于修改书名。</p>\n<pre><code class=\"language-python\">class Book:\n    help = '''这是一个类属性，用于提供当前类帮助信息。'''\n\n    def __init__(self, book_data):\n        self.name = book_data[\"name\"]\n        self.author = book_data[\"author\"]\n        self.pub = book_data[\"pub\"]\n\n    def update_name(self, new_name):\n        '''修改书名的方法'''\n        self.name = new_name\n</code></pre>\n<p>值得一提的是，虽然<code>__init__()</code>方法在使用方式上与传统面向对象编程语言中的构造函数非常类似，但它其实只是会被构造函数自动调用的初始化方法，而 Python 中真正的构造函数是另一个名为<code>__new__()</code>的特殊方法。只不过在大多数情况下，我们是不需要重新定义构造方法的，定义好初始化方法就足够了。与之相对地，如果我们需要在销毁一个自定义类型的实例时需要执行某些指定的操作，就需要通过定义另一个名为<code>__del__()</code>的特殊方法来实现。当然，考虑到该方法只会在我们显式调用<code>del</code>操作符或 Python 的垃圾回收机制销毁相关实例时才会被调用，而垃圾回收销毁实例的时机是不确定的，我并不建议读者在非必要的情况下去定义这个方法，它一般只会在需要手动释放某些重要的运行时资源时才会被定义。下面，让我们来完整地展示一下在 Python 语言中自定义一个<code>Book</code>类的全部代码：</p>\n<pre><code class=\"language-python\">class Book:\n    help = '''这是一个类属性，用于提供当前类帮助信息。'''\n    \n    def __init__(self, book_data):\n        '''\n        定义 Book 类的初始化方法，该方法需要定义以下两个参数：\n            self：这是初始化方法必须要有的参数，\n                用于指涉将被初始化的实例；\n            book_data：这是字典类型的数据对象，\n                    用于提供初始化时所要提供的数据；\n        '''\n        # 定义三个实例属性：\n        self.name = book_data[\"name\"]\n        self.author = book_data[\"author\"]\n        self.pub = book_data[\"pub\"]\n    \n    def update_name(self, new_name) :\n        '''\n        定义 Book 类中用于修改书名的方法，它需要定义以下两个参数：\n            self：用于指涉当前被称作的实例；\n            new_name：用于指定新书名的字符串对象；\n        '''\n\n        self.name = new_name\n\n    def __del__(self):\n        '''\n        定义 Book 类中用于销毁实例的方法，它需要定义以下参数：\n            self：用于指涉当前被称作的实例；\n        '''\n        print(\"delete \", self.name)        \n</code></pre>\n<p>在完成自定义类型的动作之后，我们就可以对该类型进行实例化并仔细相关操作了。例如，我们在下面以<code>Book</code>类为例，演示了如何查看该类的帮助信息、创建一个实例、修改书名以及销毁实例等操作。</p>\n<pre><code class=\"language-python\"># 通过类属性来查看 Book 类提供的帮助信息：\nprint(Book.help)\n# 创建实例：\nmy_book = Book({\n    \"name\" : \"Python 快速入门\",\n    \"author\" : \"lingjie\",\n    \"pub\" : \"人民邮电出版社\" \n})\n# 修改书名：\nmy_book.update_name(\"Python 3 快速入门\")\n# 销毁实例（这里只做演示之用，不建议手动销毁实例）：\ndel my_book\n</code></pre>\n<h2 id=\"表达式与语句\">表达式与语句</h2>\n<p>众所周知，计算机程序本质上就是一组用某一门编程语言编写而成的指令序列，人类用这门语言表达自己的意图，而计算机则利用这门语言的解释器或编译器理解人类的意图，并将该意图转换成机器指令并执行它。所以，程序员的任务就是要学会用编程语言来表述自己的意图。和所有的语言一样，人们表述意图的基本单元通常被称为“语句”。我们在上一节中学习的变量及其数据类型就相当于人类语言中的“名词”和“动词”，它们所表达的是程序要载入到内存中的数据及其可执行的操作，而现在就是要学习如何按照自己的意图将这些“名词”和“动词”组织成控制程序流程的“语句”了。下面，让我们从最基本的表达式语句开始介绍。</p>\n<h3 id=\"表达式与赋值\">表达式与赋值</h3>\n<p>无论我们使用的是人类语言还是计算机编程语言，编写语句的第一步是要明确自己要表达的内容。该内容可以是执行某个动作，也可以是呈现某个状态。当然，在没有习惯用 Python 语言表达自己意图之前，不妨先用自己熟悉的人类语言将要表达的内容写出来，然后再试着将其翻译成编程语言。举个例子，如果我们想用自然语言来描述将人民币的币值换算成美元的过程，通常会用以下三个短句来描述其具体要执行的步骤：</p>\n<ul>\n<li>先获取人民币的币值：100。</li>\n<li>再取得人民币对美元的汇率：0.1404。</li>\n<li>将人民币的币值乘以汇率，即为美元币值。</li>\n</ul>\n<p>下面，让我们再用 Python 语言来翻译一下上面这三个短句：</p>\n<pre><code class=\"language-python\">CNY = 100\nex_rate = 0.1404\nUSD = CNY * ex_rate\n</code></pre>\n<p>上述代码中出现了三条 Python 语句。它们都是需按照<code>[变量名称] = [表达式])</code>这样的语法规则编写而成，主要作用是将赋值操作符（<code>=</code>）右侧的表达式赋给左侧的变量，通常被称为<strong>赋值语句</strong>。另外，如果被赋值的<code>[变量名称]</code>是第一次出现当前作用域中的话，它们同时也充当了变量定义语句的角色。在这类语句中，变量被赋予的值及其数据类型就取决于赋值操作符右侧的表达式了。另外在 Python 中，通常一个逻辑行代表着一条独立的语句。如果某一条赋值语句因右侧的表达式过长而影响了代码的可读性，代码编辑器可能会对其进行自动换行，但它在 Python 运行时环境看来依然属于同一逻辑行。例如，我们可以对之前的<code>say_hello</code>函数做一些修改，让它输出的内容丰富一些。</p>\n<pre><code class=\"language-python\">def say_hello(name):\n    # 省略之前的代码\n    message = \"\\nThis is an object-oriented,open-source programming language often used for rapid application development.Python's simple syntax emphasizes readability,reducing the cost of program maintenance, while its large library of functions and calls encourages reuse and extensibility.\"\n    print(message)\n</code></pre>\n<p>上述代码在 VS Code 编辑器中的显示效果如下图所示，读者可以看到，我们在<code>say_hello</code>函数的作用域中新增了一个名为<code>message</code>的变量，给它赋值了一个比较长的字符串，虽然编辑器将其自动换行成了三行内容，但它们在逻辑上依然被视为同一行内容来输出的，如图 4 所示。</p>\n\n<p><img alt=\"img\" class=\"lazyload\" /></p>\n<p><strong>图 4</strong>：Python 中的逻辑行与编辑器的自动换行</p>\n<p>在编程语言中，<strong>表达式</strong>通常是由一个或多个变量和运算符（或操作符）组合而成，主要作用是执行某种计算或逻辑判断，并返回一个结果。表达式可以是简单的，也可以是复杂的，具体取决于它们包含的运算符或操作符。下面，让我们来对编程中会用到的表达式做一个简单的整理。</p>\n<ul>\n<li>\n<p><strong>常量表达式</strong>： 这种表达式通常就是某一数据类型的字面常量，即直接使用具体的字面值来表示某一数据。譬如，我们在之前示例中使用的<code>100</code>、<code>0.1404</code>、<code>\"lingjie\"</code>等都属于常量表达式。在 Python 中，我们可以使用整数、浮点数、字符串等字面常量来表示常量表达式。</p>\n</li>\n<li>\n<p><strong>变量表达式</strong>： 这种表达式就是存储了某一类型数据的变量，即直接使用已被定义的变量来表示某一数据。譬如，我们在之前示例中使用的<code>CNY</code>、<code>ex_rate</code>、<code>USD</code>等都属于变量表达式。</p>\n</li>\n<li>\n<p><strong>算术表达式</strong>： 这种表达式通常由一个或多个变量和算术运算符组成，它的主要作用是执行算术运算。譬如上面的例子中，<code>CNY * ex_rate</code>就是一个典型的算术表达式。在 Python 中，我们常用到的算术运算符主要包括加法<code>+</code>、减法<code>-</code>、乘法<code>*</code>、除法<code>/</code>、整除<code>//</code>、取余<code>%</code>和乘方<code>**</code>这七种。</p>\n</li>\n<li>\n<p><strong>关系表达式</strong>： 这种表达式通常由一个或多个变量和关系运算符组成，它的主要作用是执行关系判断。譬如，<code>CNY &gt;= 0</code>就是一个典型的关系表达式。在 Python 中，我们常用到的关系运算符主要包括大于<code>&gt;</code>、小于<code>&lt;</code>、大于等于<code>&gt;=</code>、小于等于<code>&lt;=</code>、等于<code>==</code>和不等于<code>!=</code>这六种。</p>\n</li>\n<li>\n<p><strong>逻辑表达式</strong>： 这种表达式通常由一个或多个变量和逻辑运算符组成，它的主要作用是执行逻辑判断。譬如，<code>CNY &gt;= 0 and ex_rate &gt;= 0</code>就是一个典型的逻辑表达式。在 Python 中，我们常用到的逻辑运算符主要包括与<code>and</code>、或<code>or</code>和非<code>not</code>这三种。</p>\n</li>\n<li>\n<p><strong>函数调用表达式</strong>： 这种表达式通常需按照<code>[函数名称]([参数列表])</code>这样的语法规则编写而成，它的主要作用是通过调用函数的动作来执行某一组预先定义好的操作。譬如，<code>print(USD)</code>就是一个典型的函数调用达式。</p>\n</li>\n<li>\n<p><strong>三元表达式</strong>： 这种表达式通常需按照<code>[表达式_1] if [条件] else [表达式_2]</code>这样的语法规则编写而成，它的主要作用是根据某一条件来决定返回哪个表达式的值。譬如，<code>\"Positive\" if CNY &gt;= 0 else \"Negative\"</code>就是一个典型的三元达式，它会在<code>CNY</code>的值大于或等于<code>0</code>时返回字符串<code>\"Positive\"</code>，否则返回字符串<code>\"Negative\"</code>。</p>\n</li>\n<li>\n<p><strong>成员访问表达式</strong>：这种表达式通常需按照<code>[对象名称].[属性]</code>或<code>[对象名称].[方法]([参数列表])</code>这样的语法规则编写而成，它的主要作用是通过点符号来访问指定对象的属性和方法。譬如，读者在上一节中看到的<code>my_book.update_name(\"Python 3 快速入门\")</code>就是一个典型的对象操作达式。</p>\n</li>\n<li>\n<p><strong>元素测试表达式</strong>： 这种表达式通常需按照<code>[元素] in [可迭代对象]</code>或<code>[元素] not in [可迭代对象]</code>这样的语法规则编写而成，它的主要作用是测试某个指定的值是否存在于指定的可迭代对象中。在这里，<code>[可迭代对象]</code>通常指的是列表、元组、集合或字典等数据类型的实例。譬如，如果<code>name_list</code>是一个包含多个字符串的列表，那么<code>\"lingjie\" in name_list</code>就是一个成员测试表达式，它会在<code>name_list</code>中包含字符串<code>\"lingjie\"</code>时返回<code>True</code>，否则返回<code>False</code>。</p>\n</li>\n<li>\n<p><strong>元素访问表达式</strong>： 这种表达式通常需按照<code>[可迭代对象][索引]</code>或<code>[可迭代对象][键]</code>这样的语法规则编写而成，它的主要作用是通过索引或键来访问指定的可迭代对象中的元素。在这里，<code>[可迭代对象]</code>通常指的是列表、元组、集合或字典等数据类型的实例。譬如，如果<code>name_list</code>是一个包含多个字符串的列表，那么<code>name_list[0]</code>就是一个元素访问表达式，它会返回列表中第一个元素的值。</p>\n</li>\n<li>\n<p><strong>集合切片表达式</strong>： 这种表达式通常需按照<code>[可迭代对象][起始索引:结束索引]</code>这样的语法规则编写而成，它的主要作用是通过切片操作来访问指定的可迭代对象中的一段元素序列。在这里，<code>[可迭代对象]</code>通常指的是列表、元组或字符串等数据类型的实例。譬如，如果<code>name_list</code>是一个包含多个字符串的列表，那么<code>name_list[0:2]</code>就是一个集合切片表达式，它会返回列表中第一个和第二个元素组成的子序列。</p>\n</li>\n<li>\n<p><strong>同一性测试表达式</strong>：这种表达式通常需按照<code>[变量名称_1] is [变量名称_2]</code>或<code>[变量名称_1] is not [变量名称_2]</code>这样的语法规则编写而成，它的主要作用是测试<code>[变量名称_1]</code>和<code>[变量名称_2]</code>是否指向的是相同的对象。同一性运算符（<code>is</code>和<code>is not</code>）和关系运算符（<code>==</code>和<code>!=</code>）的区别是，前者比较的是对象在内存中的位置，而后者比较的是对象中存储的值。下面，让我们用几个具体的示例来帮助读者加深理解：</p>\n<pre><code class=\"language-python\"># 示例1：相同的值，不同的对象\nlist1 = [1, 2, 3]\nlist2 = [1, 2, 3]  # 值相同但不同对象\n\nprint(list1 == list2)  # 输出: True (值相等)\nprint(list1 is list2)  # 输出: False (不是同一个对象)\n\n# 示例2：相同的对象\nlist3 = list1\nprint(list1 == list3)  # 输出: True (值相等)\nprint(list1 is list3)  # 输出: True (同一个对象)\n\n# 示例3：小整数驻留现象（驻留是 Python 的一种内存优化机制）\na = 256\nb = 256\nprint(a == b)  # 输出: True\nprint(a is b)  # 输出: True (Python 对小整数进行缓存优化)\n\nc = 257\nd = 257\nprint(c == d)  # 输出: True\nprint(c is d)  # 输出: False (大于 256 的整数不缓存)\n\n# 示例4：None 比较\nx = None\ny = None\nprint(x == y)  # 输出: True\nprint(x is y)  # 输出: True (None 是单例对象)\n\n# 示例5：字符串驻留\ns1 = \"hello\"\ns2 = \"hello\"\nprint(s1 == s2)  # 输出: True\nprint(s1 is s2)  # 输出: True (短字符串会被驻留)\n\ns3 = \"hello world!\"\ns4 = \"hello world!\"\nprint(s3 == s4)  # 输出: True\nprint(s3 is s4)  # 输出: False (长字符串不会驻留)\n</code></pre>\n</li>\n<li>\n<p><strong>Python 推导式</strong>：这种表达式通常需按照<code>[元素] for [元素] in [可迭代对象]</code>或<code>[元素] for [元素] in [可迭代对象] if [条件表达式]</code>这样的语法规则编写而成，它的主要作用是通过遍历指定的可迭代对象来生成一个新的可迭代对象。在这里，<code>[可迭代对象]</code>通常指的是列表、元组或集合等数据类型的实例。譬如：</p>\n<ul>\n<li>\n<p>如果<code>name_list</code>是一个包含多个字符串的列表，那么<code>[name for name in name_list]</code>或<code>[name for name in name_list if len(name) &gt; 3]</code>就是一个列表推导式，前者会用<code>name_list</code>中的所有元素创建一个新的列表，而后者则会用<code>name_list</code>中所有长度大于 3 的元素创建一个新的列表。</p>\n</li>\n<li>\n<p>如果<code>phone_book</code>是一个包含多个电话号码的字典，那么<code>{name:phone for name, phone in phone_book.items()}</code>或<code>{name:phone for name, phone in phone_book.items() if len(phone) == 11}</code>就是一个字典推导式，前者会用<code>phone_book</code>中的所有元素创建一个新的字典，而后者则会用<code>phone_book</code>中所有电话号码长度为 11 的元素创建一个新的字典。</p>\n</li>\n<li>\n<p>如果<code>number_set</code>是一个包含多个整数的集合，那么<code>{num for num in number_set}</code>或<code>{num for num in number_set if num % 2 == 0}</code>就是一个集合推导式，前者会用<code>number_set</code>中的所有整数创建一个新的集合，而后者则会用<code>number_set</code>中所有偶数创建一个新的集合。</p>\n</li>\n<li>\n<p>如果<code>name_tuple</code>是一个包含多个字符串的元组，那么<code>(name for name in name_tuple)</code>或<code>(name for name in name_tuple if len(name) &gt; 3)</code>就是一个生成器推导式，前者会用<code>name_tuple</code>中的所有元素创建一个生成器对象，而后者则会用<code>name_tuple</code>中所有长度大于 3 的元素来创建一个生成器对象。在这里，它之所以被称为生成器推导式，而不是元组推导式，是因为它执行的是一种被称为“惰性求值”的操作。也就是说，该推导式返回的是一个生成器对象，而不是一个新的元组。这个生成器对象需要通过调用<code>next()</code>函数或使用<code>for</code>循环来动态、按需地生成元素，而不是一次性地生成所有元素，这有助于在处理大量数据时节省内存空间。例如，如果我们想要从一个包含大量字符串的元组中筛选出所有长度大于 3 的字符串，我们可以使用生成器推导式来实现这一点，而不是一次性地将所有符合条件的字符串都存储在内存中，就像下面这样：</p>\n<pre><code class=\"language-python\"># 这里假设我们有一个包含大量字符串的文本文件 large_data.txt，\n# 每行一个字符串，我们可以先将其读取为一个元组。\nwith open(\"large_data.txt\", \"r\") as f:\n    name_tuple = tuple(f.read().splitlines())\n# 使用生成器推导式来筛选出所有长度大于 3 的字符串\nlong_names = (name for name in name_tuple if len(name) &gt; 3)\n# 使用 for 循环来动态地生成并处理这些字符串\nfor name in long_names:\n    print(name) # 这里会逐个输出所有长度大于 3 的字符串\n</code></pre>\n<p>当然，如果非要一次性地获得一个新的元组，我们也可以使用<code>tuple()</code>函数来将生成器推导式的结果转换为一个元组对象，例如，我们可以对上述<code>long_names</code>生成器对象执行如下操作：</p>\n<pre><code class=\"language-python\"># 使用 tuple() 函数将生成器推导式的结果转换为一个新的元组\nlong_names_tuple = tuple(long_names)\n# 现在 long_names_tuple 就是一个包含所有长度大于 3 的字符串的新元组\nprint(long_names_tuple) # 这里会输出所有长度大于 3 的字符串\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"流程控制语句\">流程控制语句</h3>\n<p>在实际编程工作中，我们更多时候使用的是由表达式和其他流程控制语法共同组合而成的，这些语句往往被用于表述比简单的赋值操作更复杂的流程控制意图，我们将其统称为流程控制语句。按照具体的作用，我们可以将流程控制语句细分为条件、循环和跳转三种语句。下面，让我们分别来介绍一下它们。</p>\n<p>到目前为止，我们所看到的所有程序都是按照语句出现的顺序一路执行到底的，基本没有任何应变能力。如果我们希望自己编写的程序能具备一定的“随机应变”能力，就得让它执行条件判断。在编程语言中，我们用来表述条件判断的语句叫做<strong>条件语句</strong>。条件语句在编程设计概念中属于流程控制语句中的一种，它的主要作用是根据某一由程序员预先指定的条件来决定是执行还是跳过某部分的语句（这些语句通常被称之为条件分支）。</p>\n<p>在 Python 中，条件语句主要指的是以<code>if</code>关键字开头的条件判断语句，这种语句也是编程设计中最常见、最基本的一种流程控制语句，它根据条件分支的多少，可以分为以下三种形式。</p>\n<ul>\n<li>\n<p>单分支形式：这种形式的<code>if</code>语句只用于指定在某条件成立时需要执行的条件分支，具体语法如下：</p>\n<pre><code class=\"language-python\">if [条件表达式]:\n    [分支语句]\n</code></pre>\n</li>\n<li>\n<p>双分支形式：这种形式的<code>if</code>语句会同时指定在某条件成立或不成立时需要执行的条件分支，具体语法如下：</p>\n<pre><code class=\"language-python\">if [条件表达式]:\n    [分支语句]\nelse:\n    [分支语句]\n</code></pre>\n</li>\n<li>\n<p>多分支形式：这种形式的<code>if</code>语句会根据多个条件来决定程序需要执行的条件分支，具体语法如下：</p>\n<pre><code class=\"language-python\">if [条件表达式]:\n    [分支语句]\nelif [条件表达式]:\n    [分支语句]\nelif [条件表达式]:\n    [分支语句]\n...\nelse:\n    [分支语句]\n</code></pre>\n</li>\n</ul>\n<p>在这里，<code>[条件表达式]</code>主要会是一些返回布尔类型的表达式，譬如关系表达式、逻辑表达式等。而<code>[分支语句]</code>的部分则既可以是简单的表达式语句，也可以是一个采用同一缩进格式的语句块。下面，我们通过一个具体的例子来演示一下<code>if</code>语句的用法。大家都知道，货币的币值通常不会为负数，基于这一点，我们可以对之前币值换算代码做出如下修改：</p>\n<pre><code class=\"language-python\">ex_rate = 0.1404\nCNY = 200\nif CNY &gt;= 0:\n    USD = CNY * ex_rate\n    print(\"换算的美元币值为：\", USD)\n\n# 继续后面的代码...\n</code></pre>\n<p>在这种情况下，我们只会在<code>CNY</code>的值大于或大于<code>0</code>时才会看到输出结果。但是这种做法有个问题，那就是一旦<code>CNY</code>的值为负数，我们在执行这段代码时将看不到任何反馈信息，甚至不确定程序是否运行过。为了解决问题，我们要让代码在条件不成立时也输出一条提示信息：</p>\n<pre><code class=\"language-python\">ex_rate = 0.1404\nCNY = 200\nif CNY &gt;= 0:\n    USD = CNY * ex_rate\n    print(\"换算的美元币值为：\", USD)\nelse:\n    print(\"人民币的币值不能为负数！\")\n\n# 继续后面的代码...\n</code></pre>\n<p>当然，如果我们还想确保<code>ex_rate</code>的值也不是负数，也可以继续将代码修改成一个多分支判断：</p>\n<pre><code class=\"language-python\">ex_rate = -0.1404  # 现在汇率为负值。\nCNY = 200\nif CNY &lt; 0:\n    print(\"人民币的币值不能为负数！\")\nelif ex_rate &lt; 0:\n    print(\"人民币对美元的汇率不能为负数！\")\nelse:\n    USD = CNY * ex_rate\n    print(\"换算的美元币值为：\", USD)\n\n# 继续后面的代码...\n</code></pre>\n<p>在测试上面这些条件语句时，细心的读者可能已经发现了一个问题，那就是这些条件语句都只能执行一次。而我们如果想测试不同的数据，就得去修改代码本身，这种测试方法不仅操作不方便，而且根本没有办法面对海量的测试数据。如果想要解决这个问题，我们就得想办法让程序能根据我们所指定的条件来重复执行某部分的语句，而这就涉及到了编程语言中另一种流程控制语句：<strong>循环语句</strong>。</p>\n<p>在 Python 中，循环语句主要有<code>for</code>语句和<code>while</code>语句两种形式。下面，就让我们分别来介绍一下它们。从使用习惯上来说，<code>for</code>语句的整个循环过程通常会由某种遍历操作来驱动，其具体语法如下：</p>\n<pre><code class=\"language-python\">for [循环变量] in [被遍历对象]：\n    [被循环语句]\n</code></pre>\n<p>下面具体解释一下上述语法格式中涉及到的语法单元。首先，<code>[循环变量]</code>的作用是读取<code>[被遍历对象]</code>中的每一个值，由于这个变量将被用于驱动整个循环的执行，故而被称之为循环变量；然后，<code>[被遍历对象]</code>通常会是一个可被遍历的数据结构对象，只要该对象中的最后一个元素尚未被<code>[循环变量]</code>读取，循环就会一直执行下去；最后，<code>[被循环语句]</code>就是该循环要重复执行的语句，它既可以是简单的表达式语句，也可以是一个采用了同一缩进格式的语句块。例如，如果你想在命令行终端中逐行输出从 0 到 9 这十个数字，就可以像下面这样做：</p>\n<pre><code class=\"language-python\">for item in range(0, 10): # 生成一个包含 0 到 9 的整数序列\n    print(item)\n</code></pre>\n<p><code>while</code>语句与<code>for</code>语句相比，最大的区别在于它并没有为<code>[循环变量]</code>预留固定的语法单元，其具体语法如下：</p>\n<pre><code class=\"language-python\">while [循环条件测试]:\n    [被循环语句]\nelse: # 可选的语句\n    [循环结束后执行的语句]\n</code></pre>\n<p>正如读者所见，<code>while</code>语句中的语法单元只有两个：在<code>[循环条件测试]</code>处，我们只需要设置一个能返回布尔类型的表达式即可。只要该表达式测试的结果<code>True</code>，循环就会一直执行下去，直到它因满足某一条件而返回<code>False</code>为止；而<code>[被循环语句]</code>就是该循环要重复执行的语句，同样的，它既可以是简单的表达式语句，也可以是一个采用了同一缩进格式的语句块。另外，如果我们想在<code>while</code>循环结束后执行某些特定的操作，也可以在<code>while</code>语句的末尾添加一个可选的<code>else</code>语句块来实现。需要注意的是，<code>else</code>语句块中的语句只会在循环正常结束时才会被执行，而不会在循环被提前终止时被执行。</p>\n<p>与<code>for</code>语句的语法格式相比，<code>while</code>语句显然具有更高的自由度，它允许程序员更灵活地安排循环的执行方式（当然了，这也意味着它更容易出错），因此在习惯上更适合用来描述一些执行次数不确定的循环操作。例如，如果我们需要基于<code>readLine(text)</code>函数来编写一个循环语句来实现一个逐行读取多行文本的功能，由于<code>text</code>对象所指向的多行文本是由其调用方指定的，所以我们无法事先知道该循环语句究竟需要读取多少行文本，但只要能确定该函数会在读取完所有文本之后会返回<code>False</code>，就可以利用下面这个<code>while</code>语句来使用这个函数。</p>\n<pre><code class=\"language-python\">num = 1\nwhile line := readLine(text): # 这里使用了 Python 3.8+ 提供的海象运算符\n    print(f\"{num}. {line}\")   # 这里使用了 f-string 来实现格式化输出\n    num = num + 1\nelse:\n    print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n</code></pre>\n<p>需要特别说明的是，我们在上述<code>while</code>语句的<code>[循环条件测试]</code>处使用了自 Python 3.8 版本之后引入的海象运算符（<code>:=</code>），它的作用是将右侧的表达式结果赋值给左侧的变量，并返回该变量的值。这样，我们就可以在每次循环中直接读取文本行并将其存储到<code>line</code>变量中，而不需要在循环体内再单独执行一次赋值操作了，否则，和我们所熟悉的 C/C++/Java 语言不一样，Python 的语法规则是不允许在<code>while</code>语句的<code>[循环条件测试]</code>处直接执行赋值操作的。如果读者使用的是 Python 3.8 之前的版本，就需要将上述代码修改成下面这样：</p>\n<pre><code class=\"language-python\">num = 1\nline = readLine(text) # 先读取第一行文本\nwhile line: # 只要 line 不为空，就继续循环\n    print(f\"{num}. {line}\") # 使用 f-string 格式化输出\n    num = num + 1\n    line = readLine(text) # 再读取下一行文本\nelse:\n    print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n</code></pre>\n<p>当然了，如果我们硬要用<code>for</code>循环实现上面这样的循环，也是可以做到的，而且<code>while</code>循环也可以用来执行循环次数确定的遍历操作，这里只是笔者在使用习惯上所做的建议，并不存在绝对的一定之规。另外，在程序执行过程中，我们常常会遇到一些需要提前结束当前执行单元（譬如条件语句、循环语句）的特殊情况，这时候就会需要用到一种能让程序直接改变执行位置的语句，我们称之为<strong>跳转语句</strong>，下面来介绍一下 Python 语言中常用的几种跳转语句。</p>\n<ul>\n<li>\n<p><code>break</code>语句：该跳转语句的作用就是让程序的流程直接跳出当前正在执行的条件语句与循环语句。例如，如果我们希望之前那个读取文本的循环在遇到空行时就停止读取，就可以像下面这样做：</p>\n<pre><code class=\"language-python\">num = 1\nwhile line := readLine(text):\n    if line == \"\":\n        break\n    print(f\"{num}. {line}\") \n    num = num + 1\nelse:\n    print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n</code></pre>\n</li>\n<li>\n<p><code>return</code>语句：该跳转语句的作用是让程序的流程终止当前函数的执行，并将指定的数据（如果有的话）返回给该函数的调用方。例如，如果我们希望将之前那个读取文本的循环放到一个名为<code>process_text</code>的函数中，并让它在遇到空行时就停止读取，并返回给调用方一个<code>False</code>值，就可以像下面这样做：</p>\n<pre><code class=\"language-python\">def process_text(text):\n    num = 1\n    while line := readLine(text):\n        if line == \"\":\n            return False\n        print(f\"{num}. {line}\") \n        num = num + 1\n    else:\n        print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n    return True  # 返回 True 表示读取成功\n</code></pre>\n<p>这样一来，我们就可以在调用该函数时根据返回值来判断要读取的文本中是否包含空行了。例如：</p>\n<pre><code class=\"language-python\">text = '''这是一个多行文本示例。\n下面是一个空行。\n\n这是最后一行。'''\nif not process_text(text):\n    print(\"读取文本时遇到空行，停止读取。\")\nelse:\n    print(\"文本读取成功。\")\n</code></pre>\n</li>\n<li>\n<p><code>continue</code>语句：该跳转语句只能被运用在循环语句中，作用是让程序的流程停止当前这一轮的循环操作，直接进入下一轮循环。例如，如今有很多文本格式是用空行来分割段落的（例如 Markdown）。这时候，如果我们觉得遇到空行就直接停止读取的方式不妥当，程序只需不输出空行就可以了，也可以像下面这样做：</p>\n<pre><code class=\"language-python\">num = 1\nwhile line := readLine(text):\n    if line == \"\":\n        continue\n    print(f\"{num}. {line}\")\n    num = num + 1\nelse:\n    print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n</code></pre>\n</li>\n<li>\n<p><code>pass</code>语句：该语句表示程序在当前位置不执行任何操作，并继续执行当前迭代中的下一行语句。它通常被用来占位，表示当前这一行语句是空的。例如，对于上面使用<code>continue</code>语句实现的功能，我们也可以使用<code>pass</code>语句来实现同样的效果，具体做法如下：</p>\n<pre><code class=\"language-python\">num = 1\nwhile line := readLine(text):\n    if line == \"\":\n        pass  # 不执行任何操作\n    else:\n        print(f\"{num}. {line}\")\n        num = num + 1\nelse:\n    print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n</code></pre>\n</li>\n</ul>\n<h3 id=\"一些专用语句\">一些专用语句</h3>\n<p>在 Python 语言中，除了基本的流程控制语句之外，还有一些专门用于处理特定场景的语句。下面，我们来介绍一下这些专用语句。</p>\n<ul>\n<li>\n<p><code>with</code>语句：该语句的作用是用于简化资源管理，通常被用来处理文件、网络连接等需要在使用后释放的资源。它会自动处理资源的打开和关闭，确保资源在使用完毕后被正确释放。例如，如果我们希望读取一个文件中的内容，可以像下面这样做：</p>\n<pre><code class=\"language-python\">with open(\"example.txt\", \"r\") as file:\n    for line in file:\n        print(line.strip())\n</code></pre>\n</li>\n<li>\n<p><code>try</code>、<code>except</code>、<code>finally</code>语句：这些语句的作用是用于处理异常情况，确保程序在遇到错误时不会崩溃。它们通常被用来捕获和处理运行时错误。例如，如果我们希望在读取文件时处理可能出现的文件不存在错误，可以像下面这样做：</p>\n<pre><code class=\"language-python\">try:\n    with open(\"example.txt\", \"r\") as file:\n        for line in file:\n            print(line.strip())\nexcept FileNotFoundError:\n    print(\"文件不存在，请检查文件路径。\")\nfinally:\n    print(\"文件读取操作结束。\")\n</code></pre>\n<p>在上述代码中，<code>try</code>语句块中的代码会尝试执行，如果出现<code>FileNotFoundError</code>异常，则会跳转到<code>except</code>语句块中执行相应的错误处理逻辑。无论是否发生异常，<code>finally</code>语句块中的代码都会被执行，通常用于清理资源或记录日志。</p>\n</li>\n<li>\n<p><code>yield</code>语句：该语句的作用是用于定义生成器函数，它可以在函数执行过程中暂停并返回一个值，等待下一次调用时继续执行。生成器函数通常被用来处理大量数据或无限序列。例如，如果我们希望创建一个生成器函数来逐行读取文件内容，可以像下面这样做：</p>\n<pre><code class=\"language-python\">def read_lines(file_path):\n    with open(file_path, \"r\") as file:\n        for line in file:\n            yield line.strip()  # 使用 yield 返回每一行内容\n</code></pre>\n<p>在使用该生成器函数时，我们可以像下面这样逐行读取文件内容：</p>\n<pre><code class=\"language-python\">    for line in read_lines(\"example.txt\"):\n        print(line)\n</code></pre>\n</li>\n<li>\n<p><code>assert</code>语句：该语句的作用是用于在程序运行时检查某个条件是否成立，如果不成立，则会抛出一个<code>AssertionError</code>异常。它通常被用来进行调试和测试。例如，如果我们希望在读取文本时确保每一行都不是空行，就可以像下面这样做：</p>\n<pre><code class=\"language-python\">num = 1\nwhile line := readLine(text):\n    assert line != \"\", \"读取到空行，程序终止。\"\n    print(f\"{num}. {line}\")\n    num = num + 1\nelse:\n    print(f\"读取完毕，共读取了 {num - 1} 行文本。\")\n</code></pre>\n</li>\n</ul>\n<h2 id=\"标准库的使用\">标准库的使用</h2>\n<p>除了掌握基本语法之外，程序员的编程能力实际上是取决于他如何根据自己面对的问题找到适用的程序库（包括框架），并在合理的时间内掌握它们的使用方法，并用它快速地构建自己的项目。在 Python 语言中，我们可以使用的程序库（与框架）通常可以被分为两大类：一类是由 Python 官方提供的标准库；另一类则是由程序员自己或特定第三方开发的扩展库。下面，让我们先来具体介绍一下标准库的使用方法。</p>\n<p>标准库是 Python 运行时环境的一部分，通常会随着该运行时环境一同被安装到我们的计算机设备中。Python 官方提供的标准库非常庞大，涉及的范围也十分广泛，其中包含了多个内置模块 (以 C 编写)，程序员们必须依靠它们来实现系统级的功能（例如文件的输入输出），此外还有大量以 Python 编写的模块，提供了日常编程中许多问题的标准解决方案。下面，我们来列举一些在实际开发中常常会用到标准库模块。</p>\n<ul>\n<li><code>sys</code>模块：该模块主要用于访问和修改系统相关信息，例如查看当前使用的 Python 版本、系统环境变量、模块信息和 Python 解释器相关信息等。</li>\n<li><code>os</code>模块：该模块主要用于支持执行操作系统相关的操作，它提供了访问操作系统底层 API 的方式。例如，调用可执行输入输出、文件读写、读取异常错误信息、进程线程管理、文件管理、调度程序等操作的 API。</li>\n<li><code>re</code>模块：该模块主要用于支持正则表达式操作。通常情况下，在面对大量字符串处理需求的时候，使用正则表达式是最快速有效的方式。</li>\n<li><code>math</code>模块：该模块主要用于支持数学运算，它提供了对 C 语言标准定义的数学函数访问。例如，实现数论的各种表示方法、幂和对数函数、三角函数、常量圆周率和自然常数等。</li>\n<li><code>random</code>模块：该模块主要用于生成伪随机数，可以模拟现实世界中随机取数、随机抽奖等。需要注意的是，真实的随机数原本是通过物理过程实践得出结论，而伪随机数则是通过计算机的特定算法生成的数，所以后者是可预测的、有规律的，只是循环周期较长，并不能与现实场景相切合。</li>\n<li><code>logging</code>模块：该模块是主要用于支持执行与日志记录相关的工作，它提供了对应用程序和库函数的日志记录，日常开发中我们经常需要通过日志打印出当前程序的运行状态，实时查看可能出现的堆栈异常和错误信息。</li>\n<li><code>json</code>模块：该模块主要用于支持 JSON 数据的编码和解码。在日常开发中，我们经常需要在程序的前后端之间传输 JSON 格式的数据，并对其进行序列化和反序列化操作，而序列化和反序列化本质上就是编码和解码的工作。</li>\n<li><code>socket</code>模块：该模块主要用于执行与底层网络相关的操作，它提供了 BSD 标准的 Socket API，可以通过访问底层操作系统 Socket 的相关接口进行网络通讯。</li>\n<li><code>urllib</code>模块：该模块主要用于执行与 URL（统一资源定位符）处理相关的操作，其中集成了用于向指定 URL 发送请求并处理其响应数据的各种函数。</li>\n<li><code>threading</code>模块：该模块主要用于执行与多线程并行相关的操作，针对多线程并发的问题可以给数据加同步锁，一次只能让一个线程处理数据，从而避免出现数据读写混乱。在 CPython 解释器上，因为 GIL（全局解释器锁）锁机制的存在的，被设计成线程安全，所以同一时间只能执行一个线程，这就导致了多线程不能发挥出计算机的多核特性。</li>\n<li><code>multiprocessing</code>模块：该模块主要用于执行与多进程并行相关的操作，它的功能与<code>threading</code>模块很类似，不同的是进程库可以创建子进程避开 GIL，从而弥补线程库存在的劣势和发挥计算机的多核特性。</li>\n<li><code>asyncio</code>模块：这是一个支持用<code>async/await</code>关键字编写并发操作的模块，它为多个异步框架提供基础功能，能够帮助程序员们实现高性能的网络、Web 服务器、数据库连接和分布式任务队列等。</li>\n<li><code>copy</code>模块：该模块主要用于执行与浅层、深层复制相关的操作。我们都知道要制作对象副本，是无法通过简单值传递创建新变量的方式做到，因为新变量所指向的内存空间依旧是原对象本身，所以对新变量进行任何操作都会改变原对象。那么， <code>copy</code>模块就提供了制作对象副本的各种方法，会开辟一个新的内存空间存放副本对象，修改操作不会对原对象有任何干预。</li>\n<li><code>profile</code>、<code>pstats</code>模块：这两个模块主要用于执行与性能分析相关的操作。其中，<code>profile</code>模块提供了<code>profile</code>和<code>cProfile</code>两种不同实现的性能分析工具，可用来描述程序各个部分的执行时间和频率，统计后的信息可以通过<code>pstats</code>模块保存并使用。</li>\n<li><code>unittest</code>模块：该模块主要用于执行与单元测试相关的操作，它在设计上受到 JUnit 和其他主流测试库的启发，因此在使用方式方面与它们有着相似的风格。</li>\n</ul>\n<p>在 Python 语言中，使用标准库的方式是非常简单且直观的，大体上只需要执行两个步骤即可。下面，让我们借助一个使用<code>threading</code>模块的示例来为读者演示一下这两个步骤。具体做法是在之前创建的<code>say_hello</code>项目的根目录创建一个名为的<code>example_threading.py</code>文件，并在其中输入如下代码：</p>\n<pre><code class=\"language-python\"># 第一步：使用 import 语句在当前作用域中导入要使用的模块：\nimport threading\nimport time\n# 如果只需要导入 time 模块中的 sleep 函数，\n# 也可以使用 from ... import 语句，例如：\n# from time import sleep \n\n# 第二步：根据官方文档中的说明，根据自己的需要来调用模块提供的方法：\ndef loop():\n    print('thread %s is running...' % threading.current_thread().name)\n    n = 0\n    while (n &lt; 5):\n        n = n + 1\n        print('thread %s &gt;&gt;&gt; %s' % (threading.current_thread().name, n))\n        time.sleep(1) # 等待 1 秒\n        # 如果之前是使用 from ... import 语句导入的 sleep 函数，\n        # 这里就只需调用 sleep(1) 即可\n\n    print('thread %s ended.' % threading.current_thread().name)\n\nprint('thread %s is running...' % threading.current_thread().name)\nt = threading.Thread(target=loop, name='LoopThread')\nt.start()\nt.join()\nprint('thread %s ended.' % threading.current_thread().name)\n</code></pre>\n<p>在保存了上述代码之后，我们就可以在终端中运行<code>python example_threading.py</code>命令来执行它。如果一切顺利，我们将会看到类似下面的输出：</p>\n<pre><code class=\"language-python\">thread MainThread is running...\nthread LoopThread is running...\nthread LoopThread &gt;&gt;&gt; 1\nthread LoopThread &gt;&gt;&gt; 2\nthread LoopThread &gt;&gt;&gt; 3\nthread LoopThread &gt;&gt;&gt; 4\nthread LoopThread &gt;&gt;&gt; 5\nthread LoopThread ended.\nthread MainThread ended.\n</code></pre>\n<p>正如读者所见，使用标准库的步骤非常简单，第一步是使用<code>import</code>语句将需要使用的模块导入到当前作用域中；第二步则是根据 Python 标准库的文档来选择要调用的方法，用于实现自己的需求。关于这方面的信息，读者可以前往Python 官方的<a href=\"https://docs.python.org/3/library/index.html\" rel=\"noopener nofollow\" target=\"_blank\">线上文档</a>来查阅。需要注意的是，Python 的标准库是非常庞大的，包含了大量的模块和函数，因此在实际开发中，我们通常只会使用其中的一小部分。为了更好地掌握标准库的使用方法，建议读者在编写代码时多参考官方文档，并结合实际需求进行学习和实践。</p>\n<h2 id=\"学习成果验收\">学习成果验收</h2>\n<p>现在，我们就基本介绍完了 Python 这门编程语言的基本语法规则。如果想要使用这门语言完成各种具体应用的开发工作，掌握它的基本语法规则及其标准库的使用方法无疑是先决条件。虽然在这个系列的后续笔记中，我会假设读者已经满足了这一先决条件，但对于“掌握”程度，我们还是希望先和读者约定以下标准。首先，读者需要掌握的是 Python 语言的标准语法，包括灵活运用各种表达式语句、条件语句、循环语句，以及会使用标准库提供的各种数据类型和数据结构，掌握这一能力的标准是能理解下面代码中实现的各种排序算法，并能正确地调用它们：</p>\n<pre><code class=\"language-python\">import random\n\n# 线性搜索\ndef linear_search(arr, target):  \n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\n# 二分搜索\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left &lt;= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] &lt; target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n# 选择排序\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] &lt; arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\n\n# 快速排序\ndef quick_sort(arr):\n    if len(arr) &lt;= 1:\n        return arr\n    pivot = arr[0]\n    left = [x for x in arr[1:] if x &lt; pivot]\n    right = [x for x in arr[1:] if x &gt;= pivot]\n    return quick_sort(left) + [pivot] + quick_sort(right)\n</code></pre>\n<p>最后，在最理想的情况下，读者还应该具备一些能基于标准库来编写自动化脚本的能力，例如能理解并复述下面这段实现 Git 提交操作的自动化脚本。</p>\n<pre><code class=\"language-python\"># -*- coding: utf-8 -*-\n\"\"\"\n本脚本适用于在 Linux 或 macOS 系统上自动化执行 Git 提交操作，\nWindows 用户可以自行调整一下脚本中执行的命令。\n使用方法：将脚本保存为 git_commit.py，并在终端中运行 python git_commit.py &lt;git_dir&gt; [commit_message]\n其中 &lt;git_dir&gt; 是 Git 仓库的路径，commit_message 是可选的提交信息。\n\"\"\"\n\nimport os\nimport sys\nimport time\n\nif not len(sys.argv) in range(2, 4):\n    print(\"Usage: git_commit.py &lt;git_dir&gt; [commit_message]\") \n    exit(1)\n\ntitle = \"=    Starting \" + sys.argv[0] + \"......    =\"\nn = len(title)\nprint(n*'=')\nprint(title)\nprint(n*'=')\n\nos.chdir(sys.argv[1])\nprint(\"work_dir: \" + sys.argv[1])\nif len(sys.argv) == 3 and sys.argv[2] != \"\":\n    commit_message = sys.argv[2]\nelse:\n    commit_message = \"committed at \" + time.strftime(\"%Y-%m-%d\",time.localtime(time.time()))\n\nos.system(\"git add .\")\nos.system(\"git commit -m '\"+ commit_message + \"'\")\n\nprint(\"Commit is complete!\")\n\nprint(n*'=')    \nprint(\"=     Done!\" + (n-len(\"=     Done!\")-1)*' ' + \"=\")\nprint(n*'=')\n</code></pre>\n<p>需要说明的是，由于我们在这里为了让上述示例显得浅显易懂一些，选择了用<code>os</code>标准库模块中的<code>system()</code>方法来执行脚本的外部命令，但这会带来诸如 shell 注入之类的安全风险（例如恶意执行<code>rm -rf /</code>这样的命令）。因此在实际开发中，我们更推荐使用<code>subprocess</code>这个标准库模块来执行脚本的外部命令，虽然使用起来会更复杂一些，但它会让脚本的执行更安全，也能更好处理与用户的交互。</p>\n<p>如果读者在基于以上标准的自我检验中遇到了一些不可回避的问题，我们会强烈建议先回过头去补习一下 Python 语言的基础知识，例如去阅读一下我在《[[关于Python的学习|Python 的学习路线图]]》一文中推荐的基础教材，等达到了我们在这里约定的对基础知识的“掌握”标准，再继续学习后面的内容，以便实现最好的学习效果。</p>\n<h2 id=\"小结\">小结</h2>\n<p>在这篇笔记中，我们首先介绍了 Python 语言的基本语法规则，包括变量、数据类型、表达式语句、条件语句、循环语句、函数、模块、类和异常处理等。接着，我们介绍了 Python 标准库的使用方法，并给出了一个使用标准库实现多线程的示例。最后，我们给出了学习成果验收的标准，并希望读者能根据这个标准来检验自己的学习成果。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-01-20 11:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/owlman\">凌杰</a>&nbsp;\n阅读(<span id=\"post_view_count\">29</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "20 个神级 AI 编程扩展，爽爆了！",
      "link": "https://www.cnblogs.com/yupi/p/19505500",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19505500\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 11:06\">\n    <span>20 个神级 AI 编程扩展，爽爆了！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"20 个神级 AI 编程扩展，爽爆了！\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202601/2225420-20260120103446751-1400381560.png\" />\n        欢迎在评论区分享你在用的 AI 编程工具，一起进步吧！\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain md-expand\">大家好，我是程序员鱼皮。给大家分享一些我自己在用的 AI 编程扩展，帮你大幅提高 AI 编程效率和代码质量。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><strong>万字长文 + 100 多张图</strong><span class=\"md-plain\">，绝对干货！点个收藏，让我们开始吧~</span></span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">本文已收录到 <span class=\"md-meta-i-c  md-link\"><a href=\"https://ai.codefather.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">鱼皮 AI 导航的《免费 Vibe Coding 教程》</span></a><span class=\"md-plain\"> 中，可以在这里免费获取更多 AI 资源。</span></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">一、MCP 服务器类</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">MCP 的全称是 Model Context Protocol 模型上下文协议。简单来说，就是让 AI 大模型能够连接外部工具和数据源的一个开放标准。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">打个比方，MCP 就像是 AI 的 USB-C 接口，原本 AI 只能根据训练数据来回答问题、生成代码，但有了这个统一接口，它就能连接各种外部工具，比如打开浏览器看网站、搜索并抓取网页内容、部署项目到云端、访问数据库等等，能力一下子就丰富起来了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">⭐️ Firecrawl MCP 网页内容抓取</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先要介绍的是 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.firecrawl.dev/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Firecrawl MCP</span></a><span class=\"md-plain\">，让 AI 能够自动抓取和理解网页内容。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我在开发项目时经常需要从网上获取参考资料、阅读官方文档和技术博客，或者分析竞品的功能实现。如果人工来做这件事，需要先打开网站、再手动复制粘贴内容，或者自己写个爬虫脚本，麻烦得一批。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了 Firecrawl MCP，这事儿就简单多了。我直接在 AI 编程工具中跟 AI 说：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">帮我获取这个网站的内容</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">帮我读一下这个文档</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">帮我从网上搜索 XX 相关的信息</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它就能自动把网页的内容、结构、甚至是动态加载的数据都给我抓下来。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先你需要在 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.firecrawl.dev/app/api-keys\" rel=\"noopener nofollow\"><span class=\"md-plain\">Firecrawl 官网</span></a><span class=\"md-plain\"> 注册账号，并创建一个调用服务的 API Key。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后进入到 AI 编程工具中配置一下 MCP 服务器。这里我以 Cursor 为例，其他 AI 编程工具对接 MCP 的方法可以看各自的官方文档，比如 <span class=\"md-meta-i-c  md-link\"><a href=\"https://docs.anthropic.com/en/docs/claude-code/mcp\" rel=\"noopener nofollow\"><span class=\"md-plain\">Claude Code 接入 MCP 文档</span></a><span class=\"md-plain\">。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">打开 Cursor 设置，找到 Tools &amp; MCP，点击 <span class=\"md-pair-s\"><code>+ New MCP Server</code><span class=\"md-plain\">。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">本质上就是修改 MCP 配置文件，添加这样的配置：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"firecrawl-mcp\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"command\":&nbsp;<span class=\"cm-string\">\"npx\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"args\": [<span class=\"cm-string\">\"-y\",&nbsp;<span class=\"cm-string\">\"firecrawl-mcp\"],<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"env\": {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"FIRECRAWL_API_KEY\":&nbsp;<span class=\"cm-string\">\"你的API密钥\"<br /><span>&nbsp; &nbsp; }<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这段配置的意思是：通过 npx 命令来运行 firecrawl-mcp 这个工具，并且把你的 API 密钥传给它。如果你电脑上还没有安装 npx，需要先 <span class=\"md-meta-i-c  md-link\"><a href=\"https://nodejs.org/zh-cn\" rel=\"noopener nofollow\"><span class=\"md-plain\">到官网安装 Node.js</span></a><span class=\"md-plain\">，npx 会随着 Node.js 一起安装。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">配置好之后，看到绿色的成功点点，表示能够正常使用了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了基础的网页抓取，Firecrawl MCP 还支持批量抓取整站内容、递归抓取网站的多层链接、失败自动重试等高级功能。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Brave Search MCP 隐私搜索</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来是 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/brave/brave-search-mcp-server\" rel=\"noopener nofollow\"><span class=\"md-plain\">Brave Search MCP</span></a><span class=\"md-plain\">，让 AI 能够进行注重隐私保护的网络搜索。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在开发过程中，我经常需要让 AI 帮我搜索最新的技术资料、查找某个库的使用示例、或者了解某个技术问题的解决方案。传统的做法是自己去搜索引擎查，然后把结果复制给 AI，比较麻烦。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了 Brave Search MCP，我直接跟 AI 说：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">帮我搜索一下 React 19 的新特性</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">查一下这个错误怎么解决</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它就能通过 Brave 搜索引擎去找答案。而且 Brave 搜索不会追踪你的搜索记录，隐私保护做得很好。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先去 <span class=\"md-meta-i-c  md-link\"><a href=\"https://brave.com/search/api/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Brave Search API</span></a><span class=\"md-plain\"> 注册账号，然后进入 API Key 管理页面，首先要选择一个订阅计划。必须选择免费版啊！每月有 2000 次查询额度，对于个人开发来说够用了。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但这里比较坑的一点是，即使订阅免费版，也要填写付款方式，没有海外银行卡的朋友可以撤了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">订阅成功后，创建 API Key：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">拿到 API Key 后，在 Cursor 的 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"brave-search\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"command\":&nbsp;<span class=\"cm-string\">\"npx\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"args\": [<span class=\"cm-string\">\"-y\",&nbsp;<span class=\"cm-string\">\"brave-search-mcp\"],<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"env\": {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"BRAVE_API_KEY\":&nbsp;<span class=\"cm-string\">\"你的API密钥\"<br /><span>&nbsp; &nbsp; }<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">配置好后，AI 就能随时帮你搜索最新信息了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">支持网页、图片、视频、新闻等多种类型的内容搜索，甚至能搜索本地商家信息（比如附近的咖啡店）。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它还带有 AI 摘要功能，能把搜索结果自动总结成简洁的答案。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">⭐️ Context7 获取最新文档</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://context7.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Context7</span></a><span class=\"md-plain\"> 能帮 AI 获取到最新的技术文档。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我们都知道，AI 的训练数据是有截止时间的，比如 GPT-4 的知识可能只更新到 2023 年。这就导致一个问题，当你问 AI 关于某个框架最新版本的用法时，它给出的答案可能是过时的。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Context7 就是来解决这个问题的。它会自动从官方文档网站抓取最新的、特定版本的文档内容，然后提供给 AI。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这样一来，AI 给出的代码示例和建议就是基于最新文档的，不会去用已经废弃的写法，大大提高了项目能正常运行的概率。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">访问 <span class=\"md-meta-i-c  md-link\"><a href=\"https://context7.com/dashboard\" rel=\"noopener nofollow\"><span class=\"md-plain\">Context7 Dashboard</span></a><span class=\"md-plain\"> 注册账号并获取 API Key，个人使用是免费的。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后在 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"context7\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"url\":&nbsp;<span class=\"cm-string\">\"https://mcp.context7.com/mcp\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"headers\": {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"CONTEXT7_API_KEY\":&nbsp;<span class=\"cm-string\">\"你的API密钥\"<br /><span>&nbsp; &nbsp; }<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">之后你在 AI 编程工具中跟 AI 对话时，只要跟技术文档相关，或者主动提一嘴 \"use context7\"，它就会自动去获取最新文档来回复你。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Web to MCP 复刻网页组件</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://web-to-mcp.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Web to MCP</span></a><span class=\"md-plain\"> 是一个 Chrome 扩展，搭配 MCP 使用，能把网页上的任何 UI 组件直接发送给 AI，让 AI 生成对应的代码，用最快的速度抄作业！</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">很多时候，我在浏览网站时看到一个不错的 UI 组件，想让 AI 帮我实现类似的效果。以前的做法是截图，然后跟 AI 描述：“帮我做一个类似这样的按钮，圆角、渐变色、带阴影……” 既费时又不准确。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了 Web to MCP，我只需要在网页上点击某个想复刻的元素：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它就会自动捕获组件的 DOM 结构、CSS 样式、甚至是交互效果，并且给你一个让 AI 复刻组件的提示词。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你只需要把提示词发送给 AI，AI 会调用 MCP 拿到完整的组件信息，并生成代码来复刻组件。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">相比于直接给 AI 模糊的截图，生成的代码更准确了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）通过官网或者在 Chrome 应用商店搜索 Web to MCP 来安装扩展</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）用 Google 账号登录，获取你的 MCP 配置：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）在 AI 编程工具的 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"web-to-mcp\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"url\":&nbsp;<span class=\"cm-string\">\"https://web-to-mcp.com/mcp/你的唯一ID\"<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">之后浏览网页时，点击扩展图标，选中你想要的组件，就能直接在 AI 编程工具里引用它，并且快速生成风格一致的代码了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Chrome DevTools MCP 浏览器调试</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/ChromeDevTools/chrome-devtools-mcp\" rel=\"noopener nofollow\"><span class=\"md-plain\">Chrome DevTools MCP</span></a><span class=\"md-plain\"> 是 Chrome 官方团队开发的 MCP 服务器，让 AI 能够直接控制 Chrome 浏览器进行操作和调试。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在做前端开发时，我经常需要调试页面、查看网络请求、分析性能问题。以前这些都得手动在浏览器的开发者工具里操作，现在有了这个工具，我可以直接让 AI 帮我做这些事。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我跟 AI 说：“帮我分析当前这个网站加载慢的原因”，它就能打开 Chrome DevTools，分析网络请求、查看资源加载时间，然后告诉我哪里有问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">或者我说：“帮我测试一下这个表单提交功能”，它就能自动填写表单、点击提交按钮、查看请求响应。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"chrome-devtools\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"command\":&nbsp;<span class=\"cm-string\">\"npx\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"args\": [<span class=\"cm-string\">\"-y\",&nbsp;<span class=\"cm-string\">\"chrome-devtools-mcp@latest\"]<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">配置好后，AI 就能帮你自动化测试、调试页面了。工具会自动连接到你正在运行的 Chrome 浏览器，无需额外设置。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个工具还支持元素定位、网络请求监控、性能分析、页面截图等功能，非常适合前端开发和测试。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">EdgeOne Pages MCP 一键部署</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/TencentEdgeOne/edgeone-pages-mcp\" rel=\"noopener nofollow\"><span class=\"md-plain\">EdgeOne Pages MCP</span></a><span class=\"md-plain\"> 是腾讯云团队开发的部署工具，能把你的项目一键部署到腾讯云的加速网络，让别人能访问你的网站，并且给你的网站提速。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">开发完项目后，你一定会想让别人访问你的网站。传统的部署流程很繁琐，需要人工打包代码、上传代码到服务器、配置域名、设置 HTTPS 安全证书，一套流程下来得花不少时间。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了 EdgeOne Pages MCP，我直接在 AI 编程工具里跟 AI 说：“帮我部署这个项目”，它就能自动完成打包、上传、部署的全过程，最后给我一个可以直接访问的 URL。而且部署到全球加速网络，各地访问速度都很快。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先到 <span class=\"md-meta-i-c  md-link\"><a href=\"https://console.cloud.tencent.com/edgeone/pages\" rel=\"noopener nofollow\"><span class=\"md-plain\">EdgeOne 控制台</span></a><span class=\"md-plain\"> 开通 Pages 服务：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后获取 API Token，作为调用服务的凭证：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"edgeone-pages-mcp-server\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"command\":&nbsp;<span class=\"cm-string\">\"npx\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"args\": [<span class=\"cm-string\">\"edgeone-pages-mcp\"],<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"env\": {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"EDGEONE_PAGES_API_TOKEN\":&nbsp;<span class=\"cm-string\">\"你的API Token\"<br /><span>&nbsp; &nbsp; }<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">配置好后，就能让 AI 帮你一键部署项目了。部署是免费的，支持静态网站、全栈项目、自动配置 HTTPS 和 CDN 加速等功能，非常适合个人项目和小型应用。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">COS MCP 对象存储</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/Tencent/cos-mcp\" rel=\"noopener nofollow\"><span class=\"md-plain\">COS MCP</span></a><span class=\"md-plain\"> 能让 AI 直接操作腾讯云对象存储。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对象存储就是云端的文件存储服务，可以理解为云盘。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在团队协作开发中，我们经常需要让 AI 参考一些项目规范文档、或者引用一些图片。以前的做法是把这些文件放在本地，然后手动上传给 AI，既不方便，也不利于团队维护、修改和共享。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了 COS MCP，我可以说一句话把这些需要共享的文件存到云端，然后让 AI 直接去读取。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我跟 AI 说：“按照我们团队 COS 共享的项目规范文档来写这个功能”，它就能自动从 COS 里读取规范文档，然后按照规范来写代码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）首先需要开通腾讯云 COS 对象存储服务。访问 <span class=\"md-meta-i-c  md-link\"><a href=\"https://console.cloud.tencent.com/cos\" rel=\"noopener nofollow\"><span class=\"md-plain\">腾讯云 COS 控制台</span></a><span class=\"md-plain\">，创建一个存储桶（Bucket）：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）然后在 \"访问管理\" &gt; \"API 密钥管理\" 中获取 SecretId 和 SecretKey，注意一定不要泄露这些信息！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）在 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"cos-mcp\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"command\":&nbsp;<span class=\"cm-string\">\"npx\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"args\": [<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string\">\"cos-mcp\",<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string\">\"--Region=你的地域\",<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string\">\"--Bucket=你的存储桶\",<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string\">\"--SecretId=你的SecretId\",<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string\">\"--SecretKey=你的SecretKey\"<br /><span>&nbsp; &nbsp; ]<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">配置好后，AI 就能读取和管理你云端的文件了，相当于给了 AI 一个网盘。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，这个工具还支持图片搜索、图片处理、文档转换、视频封面生成等功能。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">GitHub MCP 代码仓库管理</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/github/github-mcp-server\" rel=\"noopener nofollow\"><span class=\"md-plain\">GitHub MCP</span></a><span class=\"md-plain\"> 是 GitHub 官方开发的 MCP 服务器，让 AI 能够直接操作 GitHub 代码仓库。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">程序员朋友们对 GitHub 肯定不陌生，这是全球最大的代码托管平台，可以用它来存储代码、团队协作开发。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在日常开发中，我可能需要搜索 GitHub 代码仓库、创建 Issue 问题反馈、提交 PR 代码合并请求、查看代码变更、分析提交历史等等。以前这些操作都得在 GitHub 网站上手动完成，现在我可以直接让 AI 帮我做。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我跟 AI 说：“我最近在 GitHub 上开源了哪些项目？star 数如何？”</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它就能快速给我在 GitHub 上的项目生成一份数据报告：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">或者我说：“帮我看看最近一周的代码变更”，它就能分析 Git 提交记录，告诉我都改了什么。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先需要在 GitHub 获取到你的 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/settings/tokens\" rel=\"noopener nofollow\"><span class=\"md-plain\">Access Token</span></a><span class=\"md-plain\">，作为访问你 GitHub 资源的凭证：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后在 MCP 配置中添加：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"mcpServers\": {<br /><span>&nbsp; &nbsp;<span class=\"cm-string cm-property\">\"github\": {<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"url\":&nbsp;<span class=\"cm-string\">\"https://api.githubcopilot.com/mcp/\",<br /><span>&nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"headers\": {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-string cm-property\">\"Authorization\":&nbsp;<span class=\"cm-string\">\"Bearer 你的GitHub凭证\"<br /><span>&nbsp; &nbsp; }<br /><span>&nbsp; }<br /><span>}<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个工具还支持代码分析、CI/CD 监控、安全扫描等功能，基本上你在 GitHub 中能做的事，AI 都能帮你做。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading md-focus\"><span class=\"md-plain md-expand\">二、IDE 扩展插件类</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">MCP 服务器讲完了，接下来聊聊 IDE 扩展插件。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">IDE 就是集成开发环境，简单理解就是写代码的软件，比如 VS Code、JetBrains IDEA 这些，可以通过安装插件来增强编辑器的能力，让你的开发体验更上一层楼。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">值得一提的是，现在很多有图形界面的 AI 编程工具（比如 Cursor）都是基于 VS Code 开发的，自然也支持 VS Code 的插件，所以下面我也主要分享 VS Code 插件，装上就能用。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Claude Code 官方扩展</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Claude Code 是 Anthropic 推出的 AI 编程助手，原本是独立的命令行工具。而 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.anthropic.com/news/enabling-claude-code-to-work-more-autonomously\" rel=\"noopener nofollow\"><span class=\"md-plain\">Claude Code VS Code 扩展</span></a><span class=\"md-plain\"> 能让你在代码编辑器中直接使用 Claude Code，不用额外打开终端。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在 VS Code 或 Cursor 的扩展商店搜索 \"Claude Code\" 即可安装：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个扩展的优点是提供了图形界面，你可以通过侧边栏面板和 Claude 对话，能够灵活输入文字。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">当 AI 修改代码时，你能在编辑器里实时看到变化，并且自动显示 diff 对比，让你清楚地知道 AI 改了哪些地方。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我经常用它来重构代码、修复 Bug、添加新功能。它还支持多会话并行，也就是说你可以同时让多个 Claude 代理处理不同的任务，比如一个负责前端，一个负责后端，大大提高开发效率。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">顺带一提，类似的插件还有 Cline、GitHub Copilot 等，功能都差不多，大家可以根据自己的喜好选择。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">GitLens Git 可视化</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.gitkraken.com/gitlens\" rel=\"noopener nofollow\"><span class=\"md-plain\">GitLens</span></a><span class=\"md-plain\"> 能让你更直观地查看 Git 代码的修改历史。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Git 是程序员用来管理代码版本的工具，简单理解就是能记录代码的每一次修改，包括谁改的、什么时候改的、为什么改。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了这些记录，出了 Bug 时我就能快速找到 “凶手” 追责。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但 Git 只是个命令行工具，想查看历史记录还需要手敲命令，看起来也不太舒服。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">当我通过编辑器的扩展商店安装了 GitLens 后，把鼠标放到任意代码行上，GitLens 就会自动显示这行代码的作者、相关的 PR 合并请求等等。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">进入 Git 管理面板，整个项目的提交记录一目了然。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，它还支持 AI 功能，能自动生成提交信息、解释代码变更、生成变更日志、用 AI 解释某次改动的目的。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">⭐️ Office Viewer 文档预览</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c md-link\"><a href=\"https://github.com/cweijan/vscode-office\" rel=\"noopener nofollow\"><span class=\"md-plain\">Office Viewer</span></a><span class=\"md-plain\"> 能帮你在编辑器里直接预览和编辑各种文档。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我们知道，AI 输出的文档内容以 Markdown 格式为主，默认的编辑器中打开 Markdown 文件只能看到原始的标记语法，不够直观。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">看长文的时候，我还要用 Typora 等专业的 Markdown 编辑器打开文档，比较麻烦。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在扩展商店搜索 \"Office Viewer\" 并安装后，可以直接在编辑器中使用所见即所得的 Markdown 编辑器，看文档、写文档都很方便，不用来回切换窗口。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，这个插件支持 Excel 表格、Word 文档、PDF 文档、SVG、字体文件、压缩包等多种格式，堪称编辑器里的万能文档查看器。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">⭐️ ESLint 代码质量检查</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c md-link\"><a href=\"https://eslint.org/\" rel=\"noopener nofollow\"><span class=\"md-plain\">ESLint</span></a><span class=\"md-plain\"> 是前端 JavaScript / TypeScript 项目必备的代码检查工具。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">虽然编辑器本身也能检查一些基本的语法错误，但对于代码规范、潜在的逻辑漏洞等问题，就需要专业的代码检查工具来把关了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">现在很多 AI 生成的项目代码都会自带 ESLint 配置文件（比如 <span class=\"md-pair-s\"><code>.eslintrc.js</code><span class=\"md-plain\"> 或者 <span class=\"md-pair-s\"><code>eslint.config.js</code><span class=\"md-plain\">），定义好团队统一的代码检查规则。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在扩展商店搜索 \"ESLint\" 并安装后，插件会自动检测项目中的规则配置文件，然后实时检查代码中的问题，并给出修复建议。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这样一来，AI 写的代码如果有不规范的地方，你立刻就能发现并让 AI 修正，避免埋下隐患。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">⭐️ Prettier 代码格式化</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://prettier.io/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Prettier</span></a><span class=\"md-plain\"> 是一个代码格式化工具，能自动统一代码风格。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">团队协作时，每个人的编码习惯不同，有的代码缩进 4 格、有的缩进 2 格；有的用单引号、有的用双引号。大家的代码风格五花八门，看着就很乱，代码审查时也容易出现 Beef。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这时就需要统一的格式化规范了。现在很多 AI 生成的项目代码都会自带 Prettier 配置文件（比如 <span class=\"md-pair-s\"><code>.prettierrc</code><span class=\"md-plain\">），定义好统一的格式化规则。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在扩展商店搜索 \"Prettier\" 并安装后，就可以用快捷键一键格式化代码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还可以在 VS Code 的设置里搜索 \"Format On Save\" 并开启，这样每次保存代码时就会自动格式化，保证整个项目的代码风格一致。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Error Lens 错误实时显示</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/usernamehw/vscode-error-lens\" rel=\"noopener nofollow\"><span class=\"md-plain\">Error Lens</span></a><span class=\"md-plain\"> 能让你一眼看到代码中的错误。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">一般情况下，如果代码中有错误，你得把鼠标移到红色波浪线上才能看到错误提示，不够直观。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在扩展商店搜索 \"Error Lens\" 并安装后，错误信息会直接高亮显示在代码行尾，你一眼就能看到哪里有问题。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Console Ninja 控制台日志显示</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/wallabyjs/console-ninja\" rel=\"noopener nofollow\"><span class=\"md-plain\">Console Ninja</span></a><span class=\"md-plain\"> 能让你在编辑器里直接看到代码的运行结果。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在调试前端代码时，我经常需要看 <span class=\"md-pair-s\"><code>console.log</code><span class=\"md-plain\"> 打印出来的日志输出。要先切换到浏览器，再按 F12 打开开发者工具来查看控制台，比较麻烦。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在扩展商店搜索 \"Console Ninja\" 并安装后，直接在编辑器里就能看到输出结果，看到每个日志是从哪个文件哪一行输出的，还能显示网络请求和错误堆栈。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了它，不用频繁切换窗口了，调试效率大大提升。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">三、跨编辑器通用工具</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">前面介绍的工具都是对编辑器能力的增强，接下来聊聊跨编辑器通用的工具。这些工具不依赖特定的编辑器，适用于 Cursor、VS Code、Claude Code、GitHub Copilot 等几乎所有主流的 AI 编程工具。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Spec-kit 规范驱动开发</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://speckit.org/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Spec-kit</span></a><span class=\"md-plain\"> 是 GitHub 推出的规范驱动开发（SDD）框架。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">什么是 SDD 呢？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">传统开发流程是：想到什么写什么，边写边改，最后再补文档。这样容易导致需求不清晰、代码和文档对不上。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">而规范驱动开发的思路正好相反：先把需求写成规范文档，并且把规范文档当作代码的 <span class=\"md-pair-s \"><strong>唯一真相来源</strong><span class=\"md-plain\">。你可以把规范文档理解为 <span class=\"md-pair-s \"><strong>法律条文</strong><span class=\"md-plain\">，它包含了详细的需求描述、系统设计和接口定义。AI 必须严格遵守这些条文来生成代码，确保产出完全符合预期。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">听起来有些抽象，我们可以跟着 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/github/spec-kit\" rel=\"noopener nofollow\"><span class=\"md-plain\">Spec-kit GitHub 仓库</span></a><span class=\"md-plain\"> 的官方文档来实战一下。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先打开终端，利用 uvx 命令直接安装运行 Specify 工具，并初始化一个项目：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>uvx&nbsp;<span class=\"cm-attribute\">--from&nbsp;<span class=\"cm-builtin\">git<span class=\"cm-operator\">+https://github.com/github/spec-kit.git specify init my-project</span></span></span></span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">选择你使用的 AI 编程工具，Spec-kit 支持 Claude Code、GitHub Copilot 等几乎所有主流编程工具。这里我选 Claude Code：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">根据操作系统选择脚本类型，Windows 选下面的，其他选上面的：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">执行完这个命令后，会在当前目录下创建一个 <span class=\"md-pair-s\"><code>my-project</code><span class=\"md-plain\"> 文件夹：</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">文件夹里面包含了这些核心文件：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>.specify/memory/constitution.md</code><span class=\"md-plain\">：项目的基本准则和约定</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>.specify/scripts/</code><span class=\"md-plain\">：一些可执行脚本</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>.specify/templates/</code><span class=\"md-plain\">：模板文件</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>.claude/commands/</code><span class=\"md-plain\">：定义了一套内置的斜杠命令，让你在 AI 编程工具中可以直接调用</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">初始化程序还给了我们一些指引，告诉我们接下来如何运用这些命令来开发项目。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">用 Claude Code 打开这个项目文件夹，就可以在对话中使用定义好的命令了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来就是标准化的开发流程，参考 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/github/spec-kit\" rel=\"noopener nofollow\"><span class=\"md-plain\">官方文档</span></a><span class=\"md-plain\">，主要分为 7 个步骤：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）Constitution 制定项目准则</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/speckit.constitution</code><span class=\"md-plain\"> 命令，定义项目的基本原则、代码规范、性能标准等。这是项目的 “宪法”，后续所有开发都要遵守。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/speckit.constitution 禁止使用蓝紫渐变色风格的 UI</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">💡 如果你要做中文项目，最好在制定项目准则时就明确告诉 AI “整个网站使用中文”。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 更新了项目准则文档：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">建议每一步我们都用 Git 提交一个版本，这样出了问题后能及时回滚，也便于我们看到每一步改动的文件。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）Specify 编写功能规范</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/speckit.specify</code><span class=\"md-plain\"> 命令，描述要做什么功能、为什么做、用户需求是什么。比如：</span></span></span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/speckit.specify 我想做个【自动提醒我喝水的网站】</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 为这次的需求创建了一个新的 Git 分支，防止污染现有项目。在这个分支下创建了一个需求规格文档（spec.md） + 一个需求检查文档（requirements.md）。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">需求规格文档非常详细，还包含了边缘测试用例，针对用户各种可能的操作进行处理。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">需求检查文档中记录了 AI 对于需求的理解，打钩表示 AI 理解并确认了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）Clarify 澄清不明确的地方（可选）</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你发现需求检查文档中有的条目没有打钩，那你需要通过 Clarify 命令来让 AI 引导你进一步明确需求，直到所有的条目都打上勾。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/speckit.clarify</code><span class=\"md-plain\"> 命令，AI 会提出结构化的问题，让你来回答。从而帮你填补需求中的空白，比如边界情况、错误处理等。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我运气不错，不需要这一步 AI 就已经理解了所有条目，接下来可以进入制定技术方案阶段。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）Plan 制定技术方案</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/speckit.plan</code><span class=\"md-plain\"> 命令，让 AI 决定用什么技术栈、系统架构、数据模型、API 接口等。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">制定技术方案完成，这次生成了一大堆文档，简单了解一下：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">CLAUDE.md 项目开发指南，记录技术栈和项目结构，用于指导 Claude Code 接下来如何开发</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">quickstart.md 快速入门指南，包含 6 个实施阶段和部署方案</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">plan.md 实施方案，定义了纯客户端架构、存储策略、宪法合规性检查等</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">data-model.md 数据模型设计，定义了 4 个核心实体（提醒设置、水量日志、每日进度、历史记录）和存储结构</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">research.md 技术研究文档，记录了 8 项关键技术决策</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">contracts/api-contract.md API 接口文档</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">接下来，我们就可以准备开发实现了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">5）Tasks 拆解任务</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/speckit.tasks</code><span class=\"md-plain\"> 命令，把计划拆解成可执行的任务列表，并标注依赖关系和优先级。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">生成了一个任务列表文档，每一步要做什么都非常清晰：</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">6）Analyze 分析检查（可选）</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/speckit.analyze</code><span class=\"md-plain\"> 命令，检查规范、计划、任务是否完整一致，提前发现设计缺陷。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可以看到，AI 没有检查出问题，还让我自信地进行下一步，真爽死了！</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">7）Implement 执行实现</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">最后，运行 <span class=\"md-pair-s\"><code>/speckit.implement</code><span class=\"md-plain\"> 命令，让 AI 按照任务列表生成代码。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">大功告成，看一下效果~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">因为我这里始终没有提到使用中文输出，所以网站内容都是英文的，不过我感觉效果还可以。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">到这里，我们已经学会了如何用 Spec-kit 开发完整项目，再复习一下完整流程：</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">即使不用 Spec-kit，我们开发完整项目时也可以人工遵循这些步骤。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这种模式最大的好处是 <span class=\"md-pair-s \"><strong>对齐</strong><span class=\"md-plain\">。所有人都基于同一份清晰的规范文档工作，大家对需求的理解高度一致，既减少了沟通中的误解，又能确保代码质量。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过缺点也很明显，对于小项目，本来直接写代码几分钟就能搞定了，上面这套流程走下来差不多要半个小时！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">所以这套流程比较适合团队从 0 开始做完整的新项目，虽然流程比直接写代码慢一些，但能大大降低返工的风险，长远来看反而更高效。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">OpenSpec 轻量规范框架</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://openspec.dev/\" rel=\"noopener nofollow\"><span class=\"md-plain\">OpenSpec</span></a><span class=\"md-plain\"> 是一个轻量的规范驱动开发框架，比 Spec-kit 更简单易用。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它的核心理念是把规范文档作为代码库的一部分，每次改功能都 <span class=\"md-pair-s \"><strong>先写变更提案</strong><span class=\"md-plain\"> =&gt; 确认后再实现 =&gt; 实现完再把变更归档到规范文档中，让文档和代码始终保持同步。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">访问 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/Fission-AI/OpenSpec/\" rel=\"noopener nofollow\"><span class=\"md-plain\">OpenSpec 官方仓库</span></a><span class=\"md-plain\"> 查看文档。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先确保你的电脑安装了符合要求的 Node.js 版本（比如我这里要求 Node.js &gt;= 20.19.0），然后全局安装 OpenSpec CLI：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span><span class=\"cm-builtin\">npm&nbsp;install&nbsp;<span class=\"cm-attribute\">-g&nbsp;@fission-ai/openspec@latest</span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">进入你的项目目录，运行初始化命令：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>openspec init</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">初始化过程中会让你选择要集成的 AI 工具（比如 Claude Code、Cursor 等），我这里选择 Cursor。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行命令后，OpenSpec 会自动在你的项目中生成一个 <span class=\"md-pair-s\"><code>openspec/</code><span class=\"md-plain\"> 目录，里面包含：</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>openspec/specs/</code><span class=\"md-plain\">：存放主规范文档，记录了项目的完整现状</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>openspec/changes/</code><span class=\"md-plain\">：存放变更提案，记录了每次修改的计划</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">⭐️ <span class=\"md-pair-s\"><code>openspec/AGENTS.md</code><span class=\"md-plain\">：让 AI 编程助手使用 OpenSpec 进行规范驱动开发的操作指南，包含了如何创建变更提案、编写需求规范、验证和归档变更的完整工作流程。</span></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>openspec/project.md</code><span class=\"md-plain\">：当前项目的上下文说明（用来记录项目的信息）</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，还会根据你选择的 AI 编程工具，生成对应的命令文件，比如 Cursor 的：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有了这些文件，我们就可以开始规范化的开发流程了。参考 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/Fission-AI/OpenSpec/\" rel=\"noopener nofollow\"><span class=\"md-plain\">官方文档</span></a><span class=\"md-plain\">，主要分为 5 个步骤：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）Draft 起草变更提案</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">直接在 AI 编程工具中跟 AI 说，让它创建变更提案。比如我想添加用户搜索功能：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>创建一个 OpenSpec 的 change，添加功能：根据名称和邮箱搜索用户</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">也可以用 AI 编程工具（比如 Claude Code、Cursor）的斜杠命令：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/openspec:proposal 添加功能：根据名称和邮箱搜索用户</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 会给这个功能创建一个独立的目录 <span class=\"md-pair-s\"><code>openspec/changes/add-user-search/</code><span class=\"md-plain\">，目录下创建一系列文档：</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>proposal.md</code><span class=\"md-plain\">：描述要改什么、为什么改</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>tasks.md</code><span class=\"md-plain\">：实施步骤的任务分解</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>specs/…/spec.md</code><span class=\"md-plain\">：需求变更的具体内容</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）Verify &amp; Review 验证和审查</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可以运行下列命令，查看 AI 创建的变更提案是否正确：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>openspec list &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-comment\"># 查看所有变更<br /><span>openspec validate add-user-search &nbsp; &nbsp;<span class=\"cm-comment\"># 验证格式是否正确<br /><span>openspec show add-user-search &nbsp; &nbsp; &nbsp; &nbsp;<span class=\"cm-comment\"># 查看详细内容</span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）和团队一起审查提案</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果需要完善，可以继续跟 AI 对话，比如：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>你能帮我添加更多搜索条件和限制么？</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 会更新规范和任务列表，直到大家达成一致。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）Implement 实现变更</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">规范确认后，让 AI 开始实现：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>规范已经很完美了，开始生成代码吧</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">也可以用斜杠命令：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/openspec:apply add-user-search</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AI 会按照 <span class=\"md-pair-s\"><code>tasks.md</code><span class=\"md-plain\"> 中的任务列表逐一实现，并标记完成状态。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">很快生成完成，AI 的输出非常整齐，所有改动一目了然：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">5）Archive 归档变更</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">所有任务完成后，让 AI 归档这次变更：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>请归档这次变更</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">也可以用斜杠命令：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/openspec:archive add-user-search</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">或者在终端运行：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>openspec archive add-user-search&nbsp;<span class=\"cm-attribute\">--yes</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个命令会：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">将变更文件夹移动到 <span class=\"md-pair-s\"><code>openspec/changes/archive/</code><span class=\"md-plain\"> 归档区</span></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">将需求变更自动合并到 <span class=\"md-pair-s\"><code>openspec/specs/</code><span class=\"md-plain\"> 主规范中</span></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">保持文档和代码的同步</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这样一来，通过 <span class=\"md-pair-s\"><code>openspec/changes/</code><span class=\"md-plain\"> 的历史记录，你可以随时追溯每次变更的来龙去脉。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，整个开发过程中，建议大家定期运行 <span class=\"md-pair-s\"><code>openspec validate</code><span class=\"md-plain\"> 验证命令， 确保规范的完整性。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<div class=\"md-hr md-end-block\"><hr /></div>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">到这里，相信大家也能感受到 OpenSpec 和 Spec-kit 的区别了。</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Spec-kit 需要完整的 7 步流程：制定准则 → 写需求 → 澄清疑问 → 定方案 → 拆任务 → 检查 → 写代码），适合从 0 开始做大型新项目</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OpenSpec 的流程更简化：起草提案 → 审查 → 实现 → 归档 → 验证，上手更快，适合在现有项目上迭代功能。</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">⭐️ Agent Skills 通用 AI 技能库</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://claude.com/blog/skills\" rel=\"noopener nofollow\"><span class=\"md-plain\">Agent Skills</span></a><span class=\"md-plain\"> 是 Anthropic 新推出的 AI 技能系统。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它定义了一种 <span class=\"md-pair-s \"><strong>封装 AI 工作流</strong><span class=\"md-plain\"> 的标准：开发者可以把复杂的任务指令、脚本和资源打包成一个 <span class=\"md-pair-s \"><strong>技能（Skill）</strong><span class=\"md-plain\">；作为用户，你只需要安装这些技能，AI 就能立刻学会这项本事，不用重复造轮子。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">让我们来实战一下，利用 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.claudeskill.site/en/skills/anthropic-agent-skills:frontend-design\" rel=\"noopener nofollow\"><span class=\"md-plain\">frontend-design</span></a><span class=\"md-plain\"> 这个 Agent Skills 来优化生成网站的界面。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）安装 Agent Skills</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先打开 Claude Code，输入一行命令，把官方提供的 Skills 注册为插件市场：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/plugin marketplace add anthropics/skills</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后输入 <span class=\"md-pair-s\"><code>/plugin</code><span class=\"md-plain\">，通过 Tab 键切换到 Marketplaces 界面，批量安装官方提供的 Skills。包括：</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">document-skills：文档技能包，可以处理 Excel、Word、PPT、PDF 等文档。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">example-skills：示例技能包 ，可以处理技能创建、构建 MCP、视觉设计、算法艺术、网页测试、动图制作、主题样式等。</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">安装好之后，输入 <span class=\"md-pair-s\"><code>/skills</code><span class=\"md-plain\"> 命令，就能看到所有已经安装完成的技能了，我们要的 <span class=\"md-pair-s\"><code>frontend-design</code><span class=\"md-plain\"> 也在其中。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">可以在本地找到 Skills 的安装位置，你会发现，SKills 的本质就是一组封装好的提示词文档 + 脚本文件等：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还有另外一种安装方式，也可以在 Claude Code 中输入一行命令来安装 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.claudeskill.site/en/skills/anthropic-agent-skills:frontend-design\" rel=\"noopener nofollow\"><span class=\"md-plain\">frontend-design</span></a><span class=\"md-plain\"> 技能。</span></span></span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>skill install anthropic-agent-skills:frontend-design</span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）安装完 SKills 后，你只需要和之前一样跟 AI 对话，程序会自动根据你的任务选择使用什么 Skills。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我让 AI 开发一个精美的狼人杀网页游戏，它会询问我是否要使用 <span class=\"md-pair-s\"><code>frontend-design</code><span class=\"md-plain\"> 技能。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">使用这个技能后，AI 会选择独特的设计风格，生成的界面既有个性又专业，告别千篇一律的蓝紫渐变色。而且不需要你每次都重复输入一堆设计要求，非常方便！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不用技能是这样的，对比一下：</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">目前 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/anthropics/skills\" rel=\"noopener nofollow\"><span class=\"md-plain\">Anthropic 官方技能仓库</span></a><span class=\"md-plain\"> 已经提供了丰富的技能集合，涵盖编程相关的数据库优化、API 安全、测试策略、代码审查、文档生成，还有办公相关的 PPT 制作、Excel 处理、Word 文档、PDF 生成等各个方面。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果官方提供的技能不够用，你还可以上传自定义技能，或者访问 <span class=\"md-meta-i-c  md-link\"><a href=\"https://www.claudeskill.site/\" rel=\"noopener nofollow\"><span class=\"md-plain\">Claude Skills Hub</span></a><span class=\"md-plain\"> 下载社区贡献的技能。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">值得一提的是，Agent Skills 现已成为 <span class=\"md-meta-i-c  md-link\"><a href=\"https://agentskills.io/\" rel=\"noopener nofollow\"><span class=\"md-plain\">通用标准</span></a><span class=\"md-plain\">。除了 Claude，<span class=\"md-meta-i-c  md-link\"><a href=\"https://cursor.com/docs/context/skills\" rel=\"noopener nofollow\"><span class=\"md-plain\">Cursor</span></a><span class=\"md-plain\"> 等主流 AI 编程工具也会陆续提供支持。也就是说，你在一个工具里用的技能，在另一个工具里也能复用。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">Superpowers 核心技能库</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/obra/superpowers\" rel=\"noopener nofollow\"><span class=\"md-plain\">Superpowers</span></a><span class=\"md-plain\"> 是一套让 AI 编程助手变得更专业的 <span class=\"md-pair-s \"><strong>软件开发流程</strong><span class=\"md-plain\">。它不仅为 Claude Code 提供了一套可组合的 <span class=\"md-pair-s \"><strong>编程技能包</strong><span class=\"md-plain\">，还提供了规范和指令，确保 AI 能够正确使用这些技能。</span></span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">传统的 AI 编程，你一说需求它就开始噼里啪啦地写，结果可能并不是你想要的。而装了 Superpowers 之后，AI 会先问清楚你到底想做什么，然后出设计方案让你确认，接着制定详细的执行计划，最后才分步骤去实现，每一步还会自我检查。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">就像给一个刚进公司啥都不懂的 AI 加上了超能力，瞬间让它有了专业程序员的开发习惯。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>如何使用？</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">参考 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/obra/superpowers\" rel=\"noopener nofollow\"><span class=\"md-plain\">Superpowers 官方文档</span></a><span class=\"md-plain\">，在 Claude Code 中运行以下命令安装。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先注册市场：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/plugin marketplace add obra/superpowers-marketplace</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">再从市场安装插件：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>/plugin install superpowers@superpowers-marketplace</span></pre>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">安装后运行 <span class=\"md-pair-s\"><code>/help</code><span class=\"md-plain\"> 查看可用命令，你会看到这 3 个命令</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>/superpowers:brainstorm</code><span class=\"md-plain\"> 通过和用户交互来不断改进设计</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>/superpowers:write-plan</code><span class=\"md-plain\"> 创建实现方案</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>/superpowers:execute-plan</code><span class=\"md-plain\"> 批量执行方案</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下面以开发一个 “用户注册模块” 为例，演示 Superpowers 官方的标准工作流程。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">首先，在终端中运行 <span class=\"md-pair-s\"><code>claude</code><span class=\"md-plain\"> 命令来启动 Claude Code，然后按照下面的 7 个步骤操作：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）Brainstorming 头脑风暴 =&gt; 对齐需求</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">选择 <span class=\"md-pair-s\"><code>/superpowers:brainstorm</code><span class=\"md-plain\"> 命令并输入需求：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Superpowers 不会急着写代码，而是先通过多轮问答和你对齐需求，比如：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">用户注册模块的主要场景是什么？</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">希望支持哪些注册方式？</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">通过交互问答，AI 会探索不同方案、不断改进设计。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">当需求和方案确认无误后，它会自动将详细的设计文档保存到 <span class=\"md-pair-s\"><code>docs/plans/</code><span class=\"md-plain\"> 目录。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）Using Git Worktrees 创建独立工作空间（可选）</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">设计方案通过后，Superpowers 会帮你创建一个 Git 工作树（worktree），在新分支上建立隔离的工作空间，运行项目初始化，并验证测试基线是否干净。这样可以避免污染主分支。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这一步是可选的，我这里直接让 AI 继续执行，看看会发生什么：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）Writing Plans 制定实施计划</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/superpowers:write-plan</code><span class=\"md-plain\"> 命令，让 Superpowers 生成一份详细的实施计划，把开发任务拆解成多个原子级步骤（每个任务控制在 2 ~ 5 分钟）。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我这里 AI 直接自动执行了，省了一步命令~</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">查看 AI 生成的实施计划文档，每个任务都包含：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">精确的文件路径</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">完整的代码内容</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">验证步骤</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">好家伙，这哪里是实施计划文档啊，感觉大多数代码都写出来了！</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）执行任务</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行 <span class=\"md-pair-s\"><code>/superpowers:execute-plan</code><span class=\"md-plain\"> 命令，Superpowers 会采用以下方式之一执行：</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">子代理驱动开发（Subagent-Driven Development）：为每个任务分配一个全新的子代理，经过两阶段审查（规范合规性检查 + 代码质量检查）</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">批量执行（Executing Plans）：分批执行任务，在关键节点暂停让人工检查</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我这里 AI 直接问我想要哪种方式：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我盲选一手 Subagent-Driven 方式，AI 自动选择了对应的开发技能：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后 AI 就开始干活了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">5）Test-Driven Development 测试驱动开发</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在实现过程中，Superpowers 会强制执行 <span class=\"md-pair-s\"><code>红-绿-重构</code><span class=\"md-plain\"> 流程：</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先写失败的测试</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行测试，确认失败</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">写最小化的代码让测试通过</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">运行测试，确认通过</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">提交代码</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果发现有代码是在测试之前写的，Superpowers 会删除它，强制你先写测试。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">6）Code Review 代码审查</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">每完成一批任务后，Superpowers 会自动触发代码审查，对照计划检查代码，按严重程度报告问题。如果发现严重问题（Critical），会阻止继续进行。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">7）完成开发</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">所有任务完成后，Superpowers 会验证所有测试是否通过：</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后 AI 可能会提供几个选项，比如合并到主分支 / 创建 PR / 保留分支 / 丢弃更改。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你确定功能没有问题，可以利用 Superpowers 内置的技能来完成开发分支的清理工作。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<div class=\"md-hr md-end-block\"><hr /></div>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这套 “先设计后编码” 的规范流程走下来，代码质量会更有保障，不过代价就是速度确实比让 AI 直接生成代码会慢很多。真的是慢很多！就这么个需求我搞了半个多小时！！！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你正在开发大型项目，需要团队协作，那么可以试试 Superpowers，前期多花的时间会在后期省回来。但是如果你只是想写个简单的脚本或者快速验证一个想法，用它就有点儿牛刀杀鸡了，真没必要。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">AIChat 命令行增强工具</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/sigoden/aichat\" rel=\"noopener nofollow\"><span class=\"md-plain\">AIChat</span></a><span class=\"md-plain\"> 是一个功能完善的 AI 命令行助手，集成了 20+ 主流大模型。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">现在主流的 AI 编程工具（Cursor、VS Code 等）都内置了终端，有时我们需要敲命令来执行任务，但是命令记不住怎么办？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">用了 AIChat 后，你只需要在终端中说人话，它的 <span class=\"md-pair-s \"><strong>Shell 助手</strong><span class=\"md-plain\"> 能力就会把你的自然语言自动转换成准确可执行的命令。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">使用方法非常简单。打开终端，通过包管理器一行命令就能安装：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span><span class=\"cm-comment\"># macOS/Linux<br /><span>brew install aichat<br /><span><span>​<br /><span><span class=\"cm-comment\"># Windows<br /><span>scoop install aichat</span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">安装完成后，运行 <span class=\"md-pair-s\"><code>aichat</code><span class=\"md-plain\"> 命令，首次执行会引导你创建配置，选择你要用的大模型并填写 API Key：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">然后就可以愉快地跟 AI 对话了：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但是我个人主要用它的 Shell 助手能力（给命令添加 <span class=\"md-pair-s\"><code>-e</code><span class=\"md-plain\"> 选项），而不是 AI 对话能力。</span></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如我想批量重命名文件，但不记得命令怎么写，在终端里执行下列命令：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>aichat -e 帮我把当前目录下所有 .txt 文件改成 .md</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">它就会生成对应的 shell 命令，我确认后它就自动执行了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还可以通过快捷键来智能补全命令：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了 Shell 助手，AIChat 还有一些进阶功能。比如支持 RAG 检索增强生成，可以让 AI 基于你的本地文档回答问题；支持创建 AI 代理，把指令、工具和文档组合成自动化工作流。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，如果你想对比不同模型的效果，运行 <span class=\"md-pair-s\"><code>aichat --serve</code><span class=\"md-plain\"> 可以启动本地网页界面，同时对比多个模型的回答。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading md-focus\"><span class=\"md-plain md-expand\">最后</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">OK，以上就是我推荐的 AI 编程扩展，其中标星 ⭐️ 的是我强烈建议安装的，其他的你可以按需选择安装。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">后续我会深入介绍其中部分扩展的高级用法和实战技巧。如果本期内容对你有帮助，记得点赞收藏三连，欢迎关注鱼皮，不错过更多 AI 编程干货。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这篇文章的文字版我同步到了 <span class=\"md-meta-i-c  md-link\"><a href=\"https://ai.codefather.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">鱼皮的 AI 导航网站</span></a><span class=\"md-plain\">，在这里你还可以获取到更多免费的 AI 学习资源、全面的 AI 工具、最新 AI 资讯等等。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">也欢迎在评论区分享你在用的 AI 编程工具，一起进步吧！</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-meta-i-c md-link md-expand\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 11:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Sdcb Chats 1.8：又一次底层重构，彻底将模型提供商解耦",
      "link": "https://www.cnblogs.com/sdcb/p/19503012/20260119-chats-180",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sdcb/p/19503012/20260119-chats-180\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 08:45\">\n    <span>Sdcb Chats 1.8：又一次底层重构，彻底将模型提供商解耦</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>这是又一篇补档文章，Chats已经发布了1.10，但2025年11月5日发布的1.8版本对我个人来说意义非凡，因为它彻底改变了项目对“模型提供商”的支持方式，从“写死在代码里”变成了“完全配置化”，为后续的可维护性和扩展性打下了坚实基础。</p>\n<p>如果你还不了解 <strong>Sdcb Chats</strong>：简单说，这是一个支持多家主流模型服务商的 AI 网关。它不只能让你在一个统一界面里聚合管理所有模型，同时也兼容标准 API 协议，支持 Docker 一键部署。</p>\n<p>这篇文章聊聊 <strong>Chats 1.8 系列（1.8.0 + 1.8.1）</strong>。它不像“加一个新按钮”那样轻松，而是做了大量“地基工程”：把“模型提供商支持”从静态参考表迁移到了模型实例本身，并且补上了大量用户能直接感知到的体验升级。</p>\n<hr />\n<h2 id=\"18-的核心从静态参考表到模型实例级配置\">1.8 的核心：从“静态参考表”到“模型实例级配置”</h2>\n<p>到 chats 1.7.2 发布以来，已经支持有 18 个模型提供商，我当时为这 18 家模型提供商每一个模型都做了信息和数据跟踪，放到了 ModelReference 表，这个表有 297 条记录了，各大模型提供商卷大模型的速度越来越快，模型更新换代也越来越频繁，要可持续地维护这个表是非常困难的。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170804080-2002986397.png\" /></p>\n<p>除此之外，代码中还有大量根据模型名称写死的逻辑，这导致越来越难以维护。我和项目的合作维护者讨论过许多次，有许多不同的意见，有的说可以继续沿用这种写死的方式，有的说应该做成配置化的方式，但我觉得可持续的维护能力才是我对 chats 项目最重要的承诺，所以我决定在 1.8 版本里彻底重构模型提供商的支持方式，做成完全配置化的方式，这样未来无论是新增模型提供商，还是调整已有模型的支持逻辑，都可以通过配置来完成，而不需要动代码。这个改动虽然在短期内增加了不少工作量，但我相信从长远来看，这会大大提升项目的可维护性和扩展性。</p>\n<p>更技术一点地说：<strong>1.8.0 把“模型能力配置”从 <code>ModelReference</code> 这种静态参考表，迁移到了 <code>Model</code>（模型实例）本身</strong>——模型不再依赖“引用一条固定模板”，而是每个模型实例都拥有完整、可编辑、可验证的能力配置。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170804780-1304764941.png\" /></p>\n<h3 id=\"18-个模型能力字段落到-model终于能真正按实例定制\">18 个“模型能力字段”落到 Model：终于能真正“按实例定制”</h3>\n<p>这次迁移不是口头上的“配置化”，而是实打实的数据库变更：在 <code>src/scripts/db-migration/1.8/1.8.0.sql</code> 里，<code>Model</code> 表新增了一批能力字段（AllowSearch/AllowVision/AllowToolCall/温度范围/上下文窗口/最大输出 token/推理选项/图片尺寸/API 类型等），并且清理了多张静态参考表（<code>ModelReference</code>、<code>ModelProvider</code>、<code>Tokenizer</code>、<code>CurrencyRate</code>、<code>ReasoningResponseKind</code> ……）。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170805164-1145274511.png\" /></p>\n<h3 id=\"第三种-api-类型imagegeneration图像模型终于名正言顺\">第三种 API 类型：ImageGeneration（图像模型终于“名正言顺”）</h3>\n<p>1.8.0 新增了 <code>ApiType.ImageGeneration</code>，把图像生成从“勉强兼容”的逻辑里拎了出来：ChatCompletion / Response / ImageGeneration 三分天下，<code>ChatFactory</code> 也按 <code>ApiType</code> 分派到不同实现。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170805662-834816800.avif\" /></p>\n<h3 id=\"模型验证框架把填错配置的坑提前堵住\">模型验证框架：把“填错配置”的坑提前堵住</h3>\n<p>当能力配置变成“每个模型实例 18 个字段都可编辑”之后，靠用户自觉显然不现实。所以 1.8.0 加了 <code>UpdateModelRequest</code> 的验证框架（包含自定义验证特性和单测），把温度范围、token 上限、字段组合合法性都系统化了。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170806121-2000732051.avif\" /></p>\n<h3 id=\"快速添加模型把配置很多字段的摩擦降下来\">快速添加模型：把“配置很多字段”的摩擦降下来</h3>\n<p>为了对冲“字段变多导致的配置成本”，1.8.0 在后台做了 Quick Add/批量添加模型的流程优化，并补上了默认配置（<code>src/FE/constants/modelDefaults.ts</code> 里能看到一些默认能力/范围策略）。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170806489-55622397.avif\" /></p>\n<h3 id=\"图像链路重构从手写解析器到-imagesharp--全屏预览\">图像链路重构：从“手写解析器”到 ImageSharp + 全屏预览</h3>\n<p>1.8.0 还把图像处理这条链路整体重构了一遍：后端用 ImageSharp 替代了手写解析/嗅探逻辑（代码量直接少了一大截），前端新增了全屏 <code>ImagePreview</code> 组件，支持缩放动画、键盘导航和更顺滑的浏览体验。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170806876-1841292448.avif\" /></p>\n<h3 id=\"骨架屏与按需加载把等待变成可预期\">骨架屏与按需加载：把“等待”变成“可预期”</h3>\n<p>1.8.0 在聊天消息加载、管理后台的模型管理等页面补了骨架屏，并做了按需加载/渐进式渲染：这不是性能“变快了多少 ms”的问题，而是用户感知上从“卡住了”变成“正在加载”。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170807288-1746826065.avif\" /></p>\n<hr />\n<h2 id=\"181在架构变好之后把体验也抠到位\">1.8.1：在“架构变好”之后，把“体验也抠到位”</h2>\n<p>如果说 1.8.0 是地基，那么 1.8.1 更像是把常用路径都重新打磨了一遍：权限、推理内容展示、文件预览、聊天列表性能……这些都是你每天用 Chats 时能立刻感知到的变化。</p>\n<h3 id=\"全新的用户-模型权限管理终于能规模化授权了\">全新的“用户-模型权限”管理：终于能规模化授权了</h3>\n<p>1.8.1 新增了 <code>/admin/user-models</code>（按用户维度管理），同时在模型管理页也增加了“按模型维度管理用户”的入口。更关键的是它的交互设计：<strong>URL 作为状态唯一数据源</strong>，筛选/搜索/展开状态都能分享、刷新不丢。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170807703-1850645716.png\" /><br />\n<img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170808024-210681632.avif\" /></p>\n<h3 id=\"推理内容生命周期追踪--自动折叠屏幕终于不被思考占满\">推理内容“生命周期追踪 + 自动折叠”：屏幕终于不被思考占满</h3>\n<p>推理模型越来越多，推理内容越来越长，UI 不能只“展示”——还得帮用户“管理注意力”。1.8.1 给 <code>ReasoningContent</code> 增加了 <code>finished</code> 语义：推理进行中自动展开、结束后自动折叠；工具调用区块也做了自动折叠与动画，且尊重用户手动操作优先级。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170808347-1492521170.avif\" /></p>\n<h3 id=\"filepreview-组件重构附件展示不再各写一套\">FilePreview 组件重构：附件展示不再“各写一套”</h3>\n<p>1.8.1 引入了统一的 <code>FilePreview</code> 组件：图片/视频/音频直接预览，文档类显示图标+文件名+下载按钮；同时后端把文件处理从 Controller 下沉到了 Service 层，类型检查也更集中。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170808792-1929118479.avif\" /></p>\n<h3 id=\"聊天列表缓存打开就快一点刷新也稳一点\">聊天列表缓存：打开就快一点，刷新也稳一点</h3>\n<p>聊天列表不是什么“酷功能”，但它决定了你每天打开 Chats 的第一感受。1.8.1 里新增了 <code>chatCache.ts</code>：以用户名绑定缓存键、24 小时过期、登出自动清理，并配合并行 API 加载，让首屏更“有感”。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170809126-410299424.png\" /></p>\n<h3 id=\"提供商侧tokenpony-加入azure-openai-更名为-azure-ai-foundry\">提供商侧：TokenPony 加入，Azure OpenAI 更名为 Azure AI Foundry</h3>\n<p>1.8.1 新增了 TokenPony（ID=19），同时把 Azure OpenAI 的命名更新为 Azure AI Foundry（枚举值不变，属于代码层重命名），并补了一个小迁移脚本清理 Azure Host 里的 <code>api-version</code> 参数：<code>src/scripts/db-migration/1.8/1.8.1.sql</code>。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260119170809460-172595794.png\" /></p>\n<h3 id=\"兼容性与稳定性openai-26-升级后推理内容解析修复\">兼容性与稳定性：OpenAI 2.6 升级后推理内容解析修复</h3>\n<p>1.8.1 还处理了一个很“现实”的问题：OpenAI 客户端升级到 2.6.0 后，推理内容的解析/解码出现兼容性问题，导致部分推理段无法正确读取。这个点不显眼，但它直接影响你对推理模型的信任感，所以也被纳入 1.8.1 里修掉了。</p>\n<hr />\n<h2 id=\"升级提醒18-系列需要手动跑-sql-server-迁移脚本\">升级提醒：1.8 系列需要手动跑 SQL Server 迁移脚本</h2>\n<p>和 1.7 一样：Sdcb Chats 的数据库变更 <strong>不支持自动数据迁移</strong>。升级到 1.8 时请务必先备份数据库，并手动执行迁移脚本：</p>\n<ul>\n<li>1.8.0：<code>src/scripts/db-migration/1.8/1.8.0.sql</code></li>\n<li>1.8.1：<code>src/scripts/db-migration/1.8/1.8.1.sql</code>（清理 Azure AI Foundry 的 Host 参数）</li>\n</ul>\n<p>如果你用的是 SQLite/Postgres……老规矩：把脚本丢给 AI 先改，再边跑边修；或者能接受删库的话，让 Chats 启动时自动建新表结构也行。</p>\n<hr />\n<p>感谢大家的阅读！喜欢的朋友请给我的Github项目一个star：<a href=\"https://github.com/sdcb/chats\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/sdcb/chats</a><br />\n如果你好奇的话，这是完整的更新日志：<a href=\"https://github.com/sdcb/chats/blob/main/doc/zh-CN/release-notes/README.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/sdcb/chats/blob/main/doc/zh-CN/release-notes/README.md</a><br />\n有什么想法也欢迎在评论区留言交流，也欢迎加入我的 Chats微信群：<br />\n<img alt=\"\" src=\"https://io.starworks.cc:88/cv-public/2026/chats-wxg-qr.png\" /></p>\n<p>（如果你更喜欢用QQ，可以用QQ群：<strong>498452653</strong>）我们一起探索更多AI技术硬核玩法。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 08:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sdcb\">.NET骚操作</a>&nbsp;\n阅读(<span id=\"post_view_count\">197</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "蓝牙基础(九)：详解蓝牙 GAP、SDP、ATT、GATT 的历史背景与设计哲学",
      "link": "https://www.cnblogs.com/liwen01/p/19492724",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/liwen01/p/19492724\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 08:42\">\n    <span>蓝牙基础(九)：详解蓝牙 GAP、SDP、ATT、GATT 的历史背景与设计哲学</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"js_darkmode__1\"><strong class=\"js_darkmode__2\">liwen01 2026.01.01</strong></p>\n<h2 class=\"js_darkmode__3\"><span class=\"js_darkmode__4\">前言</span></h2>\n<p class=\"js_darkmode__5\">我们现在使用的蓝牙，它不是一蹴而就的，它经历了从<strong class=\"js_darkmode__6\">电缆替代者</strong>（经典蓝牙）到&nbsp;<strong class=\"js_darkmode__7\">万物互联基石</strong>（低功耗蓝牙）的演变。</p>\n<p class=\"js_darkmode__8\">要理解&nbsp;<code class=\"js_darkmode__9\">SDP</code>、<code class=\"js_darkmode__10\">GAP</code>、<code class=\"js_darkmode__11\">ATT</code>、<code class=\"js_darkmode__12\">GATT</code>&nbsp;这些类似重叠的协议，需要回到蓝牙技术发展的历史背景和设计哲学。</p>\n<h2 class=\"js_darkmode__13\"><span class=\"js_darkmode__14\">（一）历史背景</span></h2>\n<h3 class=\"js_darkmode__15\"><span class=\"js_darkmode__16\">（1）早期无线通信的春秋战国</span></h3>\n<p class=\"js_darkmode__17\">在蓝牙标准诞生之初，不同厂家对<strong class=\"js_darkmode__18\">如何发现对方</strong>、<strong class=\"js_darkmode__19\">如何加密</strong>、<strong class=\"js_darkmode__20\">如何连接</strong>有不同的理解。如果没有一个统一的框架，A 厂家的手机可能根本搜不到 B 厂家的耳机。</p>\n<p class=\"js_darkmode__21\"><strong class=\"js_darkmode__22\">GAP</strong>&nbsp;(Generic Access Profile) 的存在是为了定义<strong class=\"js_darkmode__23\">通用的行为准则</strong>，设计目的有两个：</p>\n<p class=\"js_darkmode__24\"><strong class=\"js_darkmode__25\">（A）标准化流程</strong>：它规定了所有蓝牙设备必须如何打招呼（广播）、如何交换名片（发现）以及如何建立外交关系（连接）。</p>\n<p class=\"js_darkmode__26\"><strong class=\"js_darkmode__27\">（B）解耦</strong>：它让上层应用不需要关心底层的物理跳频或链路层状态转换，只需知道自己是<strong class=\"js_darkmode__28\">中心设备</strong>（Central）还是&nbsp;<strong class=\"js_darkmode__29\">外围设备</strong>（Peripheral）。</p>\n<h3 class=\"js_darkmode__30\"><span class=\"js_darkmode__31\">（2）解决经典蓝牙业务繁杂问题</span></h3>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161205390-1764873844.png\" />\n<p class=\"js_darkmode__33\">经典蓝牙（BR/EDR）的设计初衷是取代各种电缆（串口线、打印线、耳机线）。</p>\n<p class=\"js_darkmode__34\">因此，它承载了非常多的特定协议（Profiles），如 HFP（通话）、A2DP（音乐）、SPP（串口）。</p>\n<p class=\"js_darkmode__35\"><strong class=\"js_darkmode__36\">SDP</strong>&nbsp;(Service Discovery Protocol) 就是蓝牙世界里的<strong class=\"js_darkmode__37\">黄页服务</strong>，设计目的也有两个：</p>\n<p class=\"js_darkmode__38\"><strong class=\"js_darkmode__39\">（A）动态查询：</strong>&nbsp;经典蓝牙设备通常功能复杂，当手机连接音箱时，它不知道这个音箱是否带麦克风（HFP），也不知其音质等级（A2DP）。</p>\n<p class=\"js_darkmode__40\"><strong class=\"js_darkmode__41\">（B）按需建立：</strong>&nbsp;通过 SDP，设备可以先查询对方支持哪些服务，获取连接这些服务所需的<strong class=\"js_darkmode__42\">端口号</strong>（如 RFCOMM 通道），然后再建立真正的业务连接，节省了系统资源。</p>\n<h3 class=\"js_darkmode__43\"><span class=\"js_darkmode__44\">（3）解决BLE极致功耗问题</span></h3>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161608250-1350751949.png\" />\n<p class=\"js_darkmode__46\">2010年左右，蓝牙 4.0 (BLE) 问世。此时的设计目标变了：不再是传输高带宽的音频，而是传输极小的数据（如温度、心率），且要求一颗纽扣电池能用一年。</p>\n<p class=\"js_darkmode__47\">经典蓝牙的协议栈（包括 SDP）对于这些小传感器来说太重、太费电了。</p>\n<p class=\"js_darkmode__48\"><strong class=\"js_darkmode__49\">为了极致省电，蓝牙设计者提出了 ATT 和 GATT 的组合：</strong></p>\n<p class=\"js_darkmode__50\">传感器数据通常非常简单（就是一个数值），比如温度湿度传感器。</p>\n<p class=\"js_darkmode__51\"><strong class=\"js_darkmode__52\">（A）ATT (Attribute Protocol)：极简的搬运工</strong></p>\n<p class=\"js_darkmode__53\"><strong class=\"js_darkmode__54\">ATT</strong>&nbsp;弃了复杂的握手，将所有数据简化为<strong class=\"js_darkmode__55\">属性（Attribute）</strong>。它只负责最简单的操作：读、写、通知。它像是一个高效的仓库搬运工，只认<strong class=\"js_darkmode__56\">货架号（Handle）</strong>，不问数据背后的逻辑。</p>\n<p class=\"js_darkmode__57\">但是ATT的属性（Attribute）太底层了，一堆 handle 很难管理，所以就有了GATT 。</p>\n<p class=\"js_darkmode__58\"><strong class=\"js_darkmode__59\">（B）GATT (Generic Attribute Profile)：逻辑的架构师</strong></p>\n<p class=\"js_darkmode__60\"><strong class=\"js_darkmode__61\">GATT</strong>&nbsp;的目的是在 ATT 之上建立了一套层级结构（Service &gt; Characteristic），把 ATT 相关的属性打包。</p>\n<p class=\"js_darkmode__62\">GATT 是声明式的，它不需要像 SDP 那样进行复杂的动态交互，而是通过简单的属性列表直接告诉对方：<strong class=\"js_darkmode__63\">我的 0x0012 货架放的是心率数据</strong></p>\n<h2 class=\"js_darkmode__64\"><span class=\"js_darkmode__65\">（二）GAP（Generic Access Profile）</span></h2>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161618653-435478667.png\" />\n<p class=\"js_darkmode__67\"><strong class=\"js_darkmode__68\">GAP</strong>（Generic Access Profile，通用访问配置文件）是蓝牙协议栈中最基础、最重要的配置文件之一。</p>\n<p class=\"js_darkmode__69\">可以把它看做是蓝牙设备的<strong class=\"js_darkmode__70\">身份证</strong>和<strong class=\"js_darkmode__71\">外交官</strong>。它定义了设备如何互相发现、建立连接以及确保基本的互操作性。</p>\n<h3 class=\"js_darkmode__72\"><span class=\"js_darkmode__73\">（1）GAP 的核心作用</span></h3>\n<p class=\"js_darkmode__74\">为确保不同厂商的设备能够互相发现并建立连接，GAP 的核心作用有4个：</p>\n<p class=\"js_darkmode__75\"><strong class=\"js_darkmode__76\">（A）模式与过程 (Modes and Procedures)：</strong>&nbsp;设备如何被发现（广播）以及如何发现别人（扫描）。</p>\n<p class=\"js_darkmode__77\"><strong class=\"js_darkmode__78\">（B）角色 (Roles)：</strong>&nbsp;定义设备在蓝牙网络中的身份（如手机是 Central，手环是 Peripheral）。</p>\n<p class=\"js_darkmode__79\"><strong class=\"js_darkmode__80\">（C）安全 (Security)：</strong>&nbsp;定义安全级别和配对模式的基础。</p>\n<p class=\"js_darkmode__81\"><strong class=\"js_darkmode__82\">（D）数据格式 (Data Formats)：</strong>&nbsp;定义广播数据和扫描响应数据的通用格式。</p>\n<h3 class=\"js_darkmode__83\"><span class=\"js_darkmode__84\">（2）GAP 四大核心角色(Roles)</span></h3>\n<p class=\"js_darkmode__85\">在连接建立之前，GAP 首先定义了设备在链路层表现出的<strong class=\"js_darkmode__86\">身份</strong>。这决定了谁负责发信号，谁负责找信号。</p>\n<p class=\"js_darkmode__87\">在低功耗蓝牙 (BLE) 中，GAP 定义了四种特定的角色。这些角色决定了链路层 (Link Layer) 的状态。</p>\n<p class=\"js_darkmode__88\"><strong class=\"js_darkmode__89\">（A）Broadcaster（广播者）：</strong>&nbsp;仅发送广播数据，<strong class=\"js_darkmode__90\">不支持</strong>建立连接，比如：温度传感器、Beacon。此时链路层处于 Advertising State 状态。</p>\n<p class=\"js_darkmode__91\"><strong class=\"js_darkmode__92\">（B）Observer（观察者）：</strong>&nbsp;仅扫描广播数据，<strong class=\"js_darkmode__93\">不支持</strong>发起连接，比如：仅用于数据采集的网关，此时链路层处于 Scanning State 状态。</p>\n<p class=\"js_darkmode__94\"><strong class=\"js_darkmode__95\">（C）Peripheral（外设）：</strong>&nbsp;发送广播，<strong class=\"js_darkmode__96\">支持</strong>被连接。通常是数据提供方，通常是性能受限、对功耗敏感的设备，比如：智能手环、心率带、智能锁。</p>\n<p class=\"js_darkmode__97\">此时链路层处于Advertising / Connection (Slave) 状态</p>\n<p class=\"js_darkmode__98\"><strong class=\"js_darkmode__99\">（D）Central（中心设备）：</strong>&nbsp;扫描广播，<strong class=\"js_darkmode__100\">发起</strong>连接。通常是控制方和数据处理方,一般拥有更强处理能力和电量的设备,比如：智能手机、平板电脑。</p>\n<p class=\"js_darkmode__101\">此时链路层处于Scanning / Connection (Master) 状态</p>\n<p class=\"js_darkmode__102\"><strong class=\"js_darkmode__103\">注意</strong>： 一个设备可以在不同时间切换不同角色，甚至在 V5.x 中通过多重连接拓扑同时扮演不同角色。</p>\n<h3 class=\"js_darkmode__104\"><span class=\"js_darkmode__105\">（3）GAP 的操作模式、过程、连接参数</span></h3>\n<p class=\"js_darkmode__106\"><strong class=\"js_darkmode__107\">（A）发现模式 (Discoverability Modes)</strong>&nbsp;:有三种发现模式：</p>\n<p class=\"js_darkmode__108\"><strong class=\"js_darkmode__109\">不可被发现模式 (Non-Discoverable Mode)：</strong>&nbsp;设备不发送广播，或者发送的广播不支持被发现（仅用于维持现有连接或广播特定非发现数据）。</p>\n<p class=\"js_darkmode__110\"><strong class=\"js_darkmode__111\">有限可发现模式 (Limited Discoverable Mode)：</strong>&nbsp;设备在短时间内（通常有超时限制）可被发现。常用于按下按钮后的配对状态。</p>\n<p class=\"js_darkmode__112\"><strong class=\"js_darkmode__113\">一般可发现模式 (General Discoverable Mode)：</strong>&nbsp;设备在很长一段时间内都可以被发现。这是大多数消费电子产品的默认状态。</p>\n<p class=\"js_darkmode__114\"><strong class=\"js_darkmode__115\">（B）连接模式 (Connectability Modes)</strong>&nbsp;有三种:</p>\n<p class=\"js_darkmode__116\"><strong class=\"js_darkmode__117\">不可连接 (Non-Connectable)：</strong>&nbsp;仅广播数据，拒绝连接请求。</p>\n<p class=\"js_darkmode__118\"><strong class=\"js_darkmode__119\">定向可连接 (Directed Connectable)：</strong>&nbsp;仅接受来自特定（已绑定）设备的连接请求，用于快速重连。</p>\n<p class=\"js_darkmode__120\"><strong class=\"js_darkmode__121\">无向可连接 (Undirected Connectable)：</strong>&nbsp;接受任何设备的连接请求。</p>\n<p class=\"js_darkmode__122\"><strong class=\"js_darkmode__123\">（C）发现过程 (Discovery Procedures)</strong></p>\n<p class=\"js_darkmode__124\">作为中心设备（Central）或观察者（Observer），GAP 定义了如何去发现周围设备：</p>\n<p class=\"js_darkmode__125\"><strong class=\"js_darkmode__126\">有限发现过程 (Limited Discovery Procedure)：</strong>&nbsp;仅过滤并显示处于<strong class=\"js_darkmode__127\">有限可发现模式</strong>的设备。</p>\n<p class=\"js_darkmode__128\"><strong class=\"js_darkmode__129\">一般发现过程 (General Discovery Procedure)：</strong>&nbsp;发现所有可发现的设备。</p>\n<p class=\"js_darkmode__130\"><strong class=\"js_darkmode__131\">（D）连接参数 (Connection Parameters)</strong></p>\n<p class=\"js_darkmode__132\">在 GAP 中，定义了中心设备和外围设备建立连接时必须协商的关键参数。这些参数直接影响<strong class=\"js_darkmode__133\">功耗</strong>和<strong class=\"js_darkmode__134\">数据吞吐量</strong>。</p>\n<p class=\"js_darkmode__135\"><strong class=\"js_darkmode__136\">连接间隔 (Connection Interval)：</strong>&nbsp;两次通信之间的时间间隔（7.5ms ~ 4.0s）。</p>\n<p class=\"js_darkmode__137\">间隔越短，速度越快但耗电；间隔越长，越省电。</p>\n<p class=\"js_darkmode__138\"><strong class=\"js_darkmode__139\">外围设备延迟 (Peripheral Latency/Slave Latency)：</strong>&nbsp;允许外围设备在没有数据发送时跳过连接事件的次数。这对低功耗至关重要。</p>\n<p class=\"js_darkmode__140\"><strong class=\"js_darkmode__141\">监督超时 (Supervision Timeout)：</strong>&nbsp;如果超过这个时间没有通信，连接被视为断开。</p>\n<p class=\"js_darkmode__142\">在蓝牙 5.3 引入了 Connection Subrating (连接子速率)，虽然这主要是链路层的功能，</p>\n<p class=\"js_darkmode__143\">但在 GAP 层面，它允许设备在保持低占空比（省电）的同时，能够更快速地切换到高占空比（高性能）模式，而无需完全重新协商连接参数。</p>\n<h3 class=\"js_darkmode__144\"><span class=\"js_darkmode__145\">（4）GAP 与底层（Link Layer）的协调逻辑</span></h3>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161632014-1638310985.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__147\">在架构图中，GAP 位于&nbsp;<strong class=\"js_darkmode__148\">L2CAP</strong>&nbsp;和&nbsp;<strong class=\"js_darkmode__149\">Link Layer (LL)</strong>&nbsp;之上。它的管理指令是自上而下下达的：</p>\n<p class=\"js_darkmode__150\"><strong class=\"js_darkmode__151\">GAP 发指令：</strong>&nbsp;应用层告诉 GAP&nbsp;<strong class=\"js_darkmode__152\">我要连接那台名为 'Apple Watch' 的设备</strong>。</p>\n<p class=\"js_darkmode__153\"><strong class=\"js_darkmode__154\">GAP 调度：</strong>&nbsp;GAP 检查当前配置，并命令 Link Layer 进入&nbsp;<strong class=\"js_darkmode__155\">Initiating State（发起状态）</strong>。</p>\n<p class=\"js_darkmode__156\"><strong class=\"js_darkmode__157\">LL 执行：</strong>&nbsp;Link Layer 在空中监听对方的广播包，并在极短的窗口期内完成握手。</p>\n<p class=\"js_darkmode__158\"><strong class=\"js_darkmode__159\">GAP 反馈：</strong>&nbsp;连接成功后，GAP 会通知上层（如 GATT 或应用层）：<strong class=\"js_darkmode__160\">链路已建立，可以开始传输数据了</strong>。</p>\n<h3 class=\"js_darkmode__161\"><span class=\"js_darkmode__162\">（5）为什么手环设备能省电</span></h3>\n<p class=\"js_darkmode__163\">这里我们以蓝牙手环来举例，从手环的初始化、连接、进入静默期、调整 这个周期来看它是如何进行功耗管理的。</p>\n<p class=\"js_darkmode__164\"><strong class=\"js_darkmode__165\">初始化：</strong>&nbsp;手环 GAP 设置为&nbsp;<strong class=\"js_darkmode__166\">Peripheral</strong>，每 1 秒发一次广播。</p>\n<p class=\"js_darkmode__167\"><strong class=\"js_darkmode__168\">连接：</strong>&nbsp;手机&nbsp;<strong class=\"js_darkmode__169\">Central</strong>&nbsp;发现手环，GAP 建立连接，初始连接间隔设为&nbsp;<strong class=\"js_darkmode__170\">30ms</strong>（为了快速同步数据）。</p>\n<p class=\"js_darkmode__171\"><strong class=\"js_darkmode__172\">进入静默期：</strong>&nbsp;数据同步完了，App 进入后台。此时手机 GAP 发起<strong class=\"js_darkmode__173\">连接参数更新请求</strong>。</p>\n<p class=\"js_darkmode__174\"><strong class=\"js_darkmode__175\">调整：</strong>&nbsp;连接间隔被拉长到&nbsp;<strong class=\"js_darkmode__176\">500ms</strong>，且设置了&nbsp;<strong class=\"js_darkmode__177\">Slave Latency = 10</strong>。这意味着手环即使每 500ms 该醒来一次，但如果没数据，它可以连续<strong class=\"js_darkmode__178\">睡</strong>&nbsp;10 次，也就是 5 秒钟才跟手机通信一次。</p>\n<p class=\"js_darkmode__179\">结果就是：这种由 GAP 协调的参数调整，让你的手环续航从 3 天延长到了 20 天。</p>\n<h2 class=\"js_darkmode__180\"><span class=\"js_darkmode__181\">（三）SDP (Service Discovery Protocol)</span></h2>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161648229-1416782711.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__183\"><strong class=\"js_darkmode__184\">SDP</strong>&nbsp;(Service Discovery Protocol) 是 金典蓝牙(BR/EDR)设备的&nbsp;<strong class=\"js_darkmode__185\">黄页电话簿</strong>。</p>\n<p class=\"js_darkmode__186\">在两个<strong class=\"js_darkmode__187\">金典蓝牙</strong>设备建立连接后，必须通过 SDP 来查询对方：<strong class=\"js_darkmode__188\">你到底支持哪些功能？怎么连接这些功能？</strong></p>\n<h3 class=\"js_darkmode__189\"><span class=\"js_darkmode__190\">（1）SDP 的核心概念与适用范围</span></h3>\n<p class=\"js_darkmode__191\">SDP 提供了一种机制，允许客户端应用程序发现服务器应用程序提供的服务以及这些服务的属性。</p>\n<p class=\"js_darkmode__192\">它不定义具体的服务操作（那是各个 Profile 的事），只负责发现。</p>\n<p class=\"js_darkmode__193\"><strong class=\"js_darkmode__194\">重要前提</strong>： SDP 主要用于 蓝牙经典 (BR/EDR) 技术，虽然 BLE 设备主要用 GATT，但双模设备（Dual Mode，同时支持 Classic 和 BLE）依然必须实现 SDP 栈以支持经典蓝牙部分的功能。</p>\n<h3 class=\"js_darkmode__195\"><span class=\"js_darkmode__196\">（2）SDP 架构与角色 (Architecture &amp; Roles)</span></h3>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161702037-464956041.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__198\">SDP 采用简单的&nbsp;<strong class=\"js_darkmode__199\">Client-Server (客户端-服务器)</strong>&nbsp;模型：</p>\n<p class=\"js_darkmode__200\"><strong class=\"js_darkmode__201\">SDP Server (服务端)：</strong>&nbsp;通常是提供服务的设备（如蓝牙音箱），它维护一个服务记录数据库。</p>\n<p class=\"js_darkmode__202\"><strong class=\"js_darkmode__203\">SDP Client (客户端)：</strong>&nbsp;通常是想要使用服务的设备（如手机），它向服务端发起查询。</p>\n<p class=\"js_darkmode__204\">常见的查询方式有：</p>\n<p class=\"js_darkmode__205\"><strong class=\"js_darkmode__206\">服务搜索 (Service Search)：</strong>&nbsp;客户端问：你这里有支持 UUID 为 0x110B（音频接收）的服务吗？</p>\n<p class=\"js_darkmode__207\"><strong class=\"js_darkmode__208\">属性获取 (Service Attribute)：</strong>&nbsp;客户端问：对于这个音频服务，你的连接通道是多少？</p>\n<p class=\"js_darkmode__209\"><strong class=\"js_darkmode__210\">服务浏览 (Service Browsing)：</strong>&nbsp;客户端请求查看服务器上所有可公开的服务列表。</p>\n<h3 class=\"js_darkmode__211\"><span class=\"js_darkmode__212\">（3）SDP 的核心组件、数据模型</span></h3>\n<p class=\"js_darkmode__213\">SDP 服务器维护的数据库由一系列 Service Records (服务记录) 组成。</p>\n<p class=\"js_darkmode__214\"><strong class=\"js_darkmode__215\">（1）Service Record (服务记录)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161715276-1451476449.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__217\"><strong class=\"js_darkmode__218\">Service Record Handle:</strong>&nbsp; 每一个服务（如<strong class=\"js_darkmode__219\">免提通话</strong>、<strong class=\"js_darkmode__220\">串口通信</strong>）都对应一条记录，这是 SDP 服务器分配给某一个服务的索引号。</p>\n<p class=\"js_darkmode__221\">在一台设备（Server）上，每一个服务记录都有一个唯一的句柄，长度为32位，称为 Handle。</p>\n<p class=\"js_darkmode__222\"><strong class=\"js_darkmode__223\">分配规则</strong>： 范围是 0x00000000 到 0xFFFFFFFF。通常 0x00000000 是保留给 SDP 服务本身的。</p>\n<p class=\"js_darkmode__224\"><strong class=\"js_darkmode__225\">（2）Service Attributes (服务属性)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161727144-2105630239.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__227\">每条记录包含多个属性，描述该服务的细节。属性由&nbsp;<strong class=\"js_darkmode__228\">Attribute ID</strong>&nbsp;和&nbsp;<strong class=\"js_darkmode__229\">Attribute Value</strong>&nbsp;组成。</p>\n<p class=\"js_darkmode__230\"><strong class=\"js_darkmode__231\">Attribute ID</strong>&nbsp; (属性 ID)： 定义了该属性的含义，由蓝牙 SIG 统一规定，例如：</p>\n<ul class=\"list-paddingleft-1 js_darkmode__232\">\n<li><code class=\"js_darkmode__234\">0x0001</code>：始终代表&nbsp;<code class=\"js_darkmode__235\">ServiceClassIDList</code>（服务类别列表）。</li>\n<li><code class=\"js_darkmode__237\">0x0100</code>：始终代表&nbsp;<code class=\"js_darkmode__238\">ServiceName</code>（服务名称）。</li>\n</ul>\n<p class=\"js_darkmode__239\">客户端通过这个 ID 告诉服务器：请把这个服务的 ServiceName（0x0100） 告诉我。</p>\n<p class=\"js_darkmode__240\"><strong class=\"js_darkmode__241\">Attribute Value</strong>&nbsp;(属性值) ： 这是最具体的数据，它的格式叫 Data Element，可以是一个整数、一个字符串、一个布尔值，甚至是一个嵌套的列表。</p>\n<p class=\"js_darkmode__242\"><strong class=\"js_darkmode__243\">（3）UUID (通用唯一标识符)</strong></p>\n<p class=\"js_darkmode__244\">UUID 这是 SDP 的灵魂，它是一个全球唯一的标签，用来标识<strong class=\"js_darkmode__245\">这就是 A2DP 音频</strong>或<strong class=\"js_darkmode__246\">这就是串口协议</strong>。</p>\n<p class=\"js_darkmode__247\"><strong class=\"js_darkmode__248\">关键点</strong>： UUID 通常是作为<strong class=\"js_darkmode__249\">Attribute Value</strong>的一部分出现的。</p>\n<p class=\"js_darkmode__250\">比如在&nbsp;<code class=\"js_darkmode__251\">ServiceClassIDList</code>&nbsp;这个属性（ID 为&nbsp;<code class=\"js_darkmode__252\">0x0001</code>）里，它的值通常就是一个 UUID（如&nbsp;<code class=\"js_darkmode__253\">0x110B</code>&nbsp;代表 A2DP Audio Sink）。</p>\n<p class=\"js_darkmode__254\">一般16位 UUID（简短版）用于官方标准服务，128位 UUID（完整版）用于厂商自定义服务。</p>\n<p class=\"js_darkmode__255\"><strong class=\"js_darkmode__256\">（4）Handle、Attribute ID、Value、UUID 的区别</strong></p>\n<p class=\"js_darkmode__257\"><strong class=\"js_darkmode__258\">Handle</strong>&nbsp;(32位)<strong class=\"js_darkmode__259\">：</strong>找到那个服务记录的钥匙。</p>\n<p class=\"js_darkmode__260\"><strong class=\"js_darkmode__261\">Attribute ID</strong>&nbsp;(16位)：指明你想看记录里的哪一项。</p>\n<p class=\"js_darkmode__262\"><strong class=\"js_darkmode__263\">Attribute Value</strong>：那一项里存的实际数据。</p>\n<p class=\"js_darkmode__264\"><strong class=\"js_darkmode__265\">UUID</strong>：存在数据里的<strong class=\"js_darkmode__266\">标准身份标签</strong>。</p>\n<h3 class=\"js_darkmode__267\"><span class=\"js_darkmode__268\">（4）SDP 协议过程 (Protocol Procedures)</span></h3>\n<p class=\"js_darkmode__269\">SDP 定义了三种主要的 PDU (协议数据单元) 交互模式，运行在 L2CAP 协议之上（通常使用 PSM&nbsp;<code class=\"js_darkmode__270\">0x0001</code>）。</p>\n<p class=\"js_darkmode__271\"><strong class=\"js_darkmode__272\">（A）Service Search Transaction (服务搜索)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161746937-210164031.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__274\"><strong class=\"js_darkmode__275\">Client 问:</strong>&nbsp;你有支持 UUID 为&nbsp;<code class=\"js_darkmode__276\">0x1101</code>&nbsp;(Serial Port) 的服务吗？</p>\n<p class=\"js_darkmode__277\"><strong class=\"js_darkmode__278\">Server 答:</strong>&nbsp;有，对应的 Service Record Handle 是&nbsp;<code class=\"js_darkmode__279\">0x00010005</code>。</p>\n<p class=\"js_darkmode__280\"><strong class=\"js_darkmode__281\">用途:</strong>&nbsp;仅获取记录的句柄，不获取具体细节。</p>\n<p class=\"js_darkmode__282\"><strong class=\"js_darkmode__283\">（B）Service Attribute Transaction (属性获取)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161807388-333043667.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__285\"><strong class=\"js_darkmode__286\">Client 问:</strong>&nbsp;请给我 Handle 为&nbsp;<code class=\"js_darkmode__287\">0x00010005</code>&nbsp;的所有属性（或者特定属性，如协议列表）。</p>\n<p class=\"js_darkmode__288\"><strong class=\"js_darkmode__289\">Server 答:</strong>&nbsp;这是属性列表：ID&nbsp;<code class=\"js_darkmode__290\">0x0001</code>&nbsp;是...，ID&nbsp;<code class=\"js_darkmode__291\">0x0004</code>&nbsp;是...</p>\n<p class=\"js_darkmode__292\"><strong class=\"js_darkmode__293\">用途:</strong>&nbsp;已知句柄，获取详细信息。</p>\n<p class=\"js_darkmode__294\"><strong class=\"js_darkmode__295\">（C）Service Search Attribute Transaction (搜索并获取)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161820643-1809280923.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__297\"><strong class=\"js_darkmode__298\">Client 问:</strong>&nbsp;查找支持 UUID&nbsp;<code class=\"js_darkmode__299\">0x1101</code>&nbsp;的服务，并直接把它们的协议列表属性发给我。</p>\n<p class=\"js_darkmode__300\"><strong class=\"js_darkmode__301\">Server 答:</strong>&nbsp;找到了，这是数据...</p>\n<p class=\"js_darkmode__302\"><strong class=\"js_darkmode__303\">用途:</strong>&nbsp;<strong class=\"js_darkmode__304\">最高效的方式</strong>，一次交互完成搜索和读取，减少空中交互时间。</p>\n<h2 class=\"js_darkmode__305\"><span class=\"js_darkmode__306\">（四）ATT (Attribute Protocol)</span></h2>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161831665-1799709478.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__308\"><strong class=\"js_darkmode__309\">ATT</strong>&nbsp;(Attribute Protocol) 是蓝牙低功耗 (BLE) 世界的&nbsp;<strong class=\"js_darkmode__310\">搬运工</strong>。它是 BLE 通信的最底层数据传输协议。</p>\n<p class=\"js_darkmode__311\">上层的 GATT (Generic Attribute Profile) 几乎所有的操作（读、写、通知）都是通过 ATT 协议定义的 PDU (协议数据单元) 来完成的。</p>\n<h3 class=\"js_darkmode__312\"><span class=\"js_darkmode__313\">（1）ATT 的核心架构与角色</span></h3>\n<p class=\"js_darkmode__314\">ATT 定义了两个核心角色，这两个角色完全独立于 GAP 的<strong class=\"js_darkmode__315\">主机/从机</strong>或<strong class=\"js_darkmode__316\">中心/外围</strong>角色。</p>\n<p class=\"js_darkmode__317\"><strong class=\"js_darkmode__318\">服务器 (Server):</strong>:数据持有者,它存储了所有的状态、数据和配置信息（即<strong class=\"js_darkmode__319\">属性</strong>）。它通常是传感器设备（如心率带、温度计）。</p>\n<p class=\"js_darkmode__320\"><strong class=\"js_darkmode__321\">注意</strong>：在大多数情况下，BLE 外围设备 (Peripheral) 充当 ATT Server，但这并不是强制的。</p>\n<p class=\"js_darkmode__322\"><strong class=\"js_darkmode__323\">客户端</strong>&nbsp;(Client)：数据请求者，它向服务器发起请求，或者接收服务器推送的数据。通常是手机、网关或平板电脑。</p>\n<h3 class=\"js_darkmode__324\"><span class=\"js_darkmode__325\">（2）ATT 的属性（数据单元）</span></h3>\n<p class=\"js_darkmode__326\">ATT 层传输的最小单位就是&nbsp;<strong class=\"js_darkmode__327\">Attribute</strong>&nbsp;(属性)。服务器本质上就是一个巨大的属性列表（Attribute Table）。每一个属性都由以下四个元素组成：</p>\n<p class=\"js_darkmode__328\"><strong class=\"js_darkmode__329\">Attribute Handle</strong>：handle 长度16bit，它是属性的<strong class=\"js_darkmode__330\">地址</strong>或索引。客户端通过句柄来找到它要读写的数据。范围：0x0001 ~ 0xFFFF。</p>\n<p class=\"js_darkmode__331\"><strong class=\"js_darkmode__332\">Attribute Type</strong>&nbsp;：定义这到底是什么数据。使用 UUID 标识（如 0x2800 代表<strong class=\"js_darkmode__333\">服务声明</strong>，0x2A37 代表<strong class=\"js_darkmode__334\">心率测量值</strong>）。</p>\n<p class=\"js_darkmode__335\"><strong class=\"js_darkmode__336\">Attribute Value</strong>&nbsp;：实际的数据载体。长度可变（0 ~ 512 字节）。</p>\n<p class=\"js_darkmode__337\"><strong class=\"js_darkmode__338\">Attribute Permissions</strong>：定义谁可以访问该属性（读/写/加密要求）。注意：权限不通过空中传输，仅存在于服务器内部逻辑中。</p>\n<h3 class=\"js_darkmode__339\"><span class=\"js_darkmode__340\">（3）ATT PDU 类型 (通信方式)</span></h3>\n<p class=\"js_darkmode__341\">ATT 协议定义了 6 种基本的通信交互模式 (PDU Types)。理解这 6 种模式是理解 BLE 数据流的关键。</p>\n<p class=\"js_darkmode__342\"><strong class=\"js_darkmode__343\">（A）请求</strong>&nbsp;(<strong class=\"js_darkmode__344\">Request</strong>) 由 Client -&gt; Server，客户端发送请求，<strong class=\"js_darkmode__345\">必须</strong>等待服务器回复响应，比如：手机读取手环电量 (<code class=\"js_darkmode__346\">Read Request</code>)。 特点是：串行，慢，但可靠。</p>\n<p class=\"js_darkmode__347\"><strong class=\"js_darkmode__348\">（B）响应</strong>(<strong class=\"js_darkmode__349\">Response</strong>)：由 Server -&gt; Client，服务器对请求的回复，比如：手环回复电量值 (<code class=\"js_darkmode__350\">Read Response</code>)。</p>\n<p class=\"js_darkmode__351\"><strong class=\"js_darkmode__352\">（C）命令</strong>&nbsp;(<strong class=\"js_darkmode__353\">Command</strong>)：由 Client -&gt; Server 。客户端发送数据，<strong class=\"js_darkmode__354\">不需要</strong>服务器回复。也叫 \"Write without Response\"。比如：手机快速向智能灯泡发送调色指令。</p>\n<p class=\"js_darkmode__355\">特点是：由底层链路层保证数据到达，应用层不确认，速度最快</p>\n<p class=\"js_darkmode__356\"><strong class=\"js_darkmode__357\">（D）通知</strong>&nbsp;(<strong class=\"js_darkmode__358\">Notification</strong>)： 由 Server -&gt; Client。服务器主动推送数据，<strong class=\"js_darkmode__359\">不需要</strong>客户端确认。比如：心率带每秒推送一次实时心率。特点是：最常用的数据上报方式，吞吐量高。</p>\n<p class=\"js_darkmode__360\"><strong class=\"js_darkmode__361\">（E）指示</strong>&nbsp;(<strong class=\"js_darkmode__362\">Indication</strong>)：由Server -&gt; Client。服务器主动推送数据，<strong class=\"js_darkmode__363\">必须</strong>等待客户端回复确认。在收到确认前，服务器不能发下一条。比如：血糖仪发送血糖结果（数据至关重要，必须确保对方应用层收到了）。</p>\n<p class=\"js_darkmode__364\">特点是：慢，但在应用层极其可靠</p>\n<p class=\"js_darkmode__365\"><strong class=\"js_darkmode__366\">（F）确认</strong>&nbsp;(<strong class=\"js_darkmode__367\">Confirmation</strong>)：由 Client -&gt; Server。是客户端收到指示 (Indication) 后的回复。</p>\n<h3 class=\"js_darkmode__368\"><span class=\"js_darkmode__369\">（4）增强型 ATT (Enhanced ATT, EATT)</span></h3>\n<p class=\"js_darkmode__370\">增强型 ATT (Enhanced ATT, EATT) 这是从蓝牙 5.2 引入并在 V5.3 中继续强化的重要特性。</p>\n<p class=\"js_darkmode__371\"><strong class=\"js_darkmode__372\">传统 ATT (Legacy ATT):</strong>&nbsp;是<strong>顺序 (Sequential)</strong>的。如果你发送了一个 Read Request，在收到 Read Response 之前，你不能发送任何其他请求。</p>\n<p class=\"js_darkmode__373\">这就像单行道，容易造成阻塞（Head-of-Line Blocking）。</p>\n<p class=\"js_darkmode__374\"><strong class=\"js_darkmode__375\">增强型 ATT (EATT):</strong>&nbsp;它运行在 L2CAP 的增强型基于信用的流量控制 (Enhanced Credit Based Flow Control) 模式之上。</p>\n<p class=\"js_darkmode__376\">它的特点是：</p>\n<ul class=\"list-paddingleft-1 js_darkmode__377\">\n<li><strong class=\"js_darkmode__379\">支持并发 (Concurrent):</strong>&nbsp;允许同时执行多个 ATT 事务。</li>\n<li><strong class=\"js_darkmode__381\">低延迟：</strong>&nbsp;优先级高的命令不会被前面正在处理的大数据包阻塞。</li>\n<li><strong class=\"js_darkmode__383\">MTU:</strong>&nbsp;EATT 的 MTU 是独立配置的，通常更灵活。</li>\n</ul>\n<p class=\"js_darkmode__384\">在 V5.3 设备中，如果双方都支持 EATT，设备将优先建立 EATT 信道以提升用户体验（如音频流传输时的同时控制操作）。</p>\n<h3 class=\"js_darkmode__385\"><span class=\"js_darkmode__386\">（5）ATT MTU (最大传输单元)</span></h3>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161848815-585472060.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__388\">ATT_MTU 决定了在一个数据包中最多能传多少字节的有效载荷。默认值为 23 字节 (BLE 4.0)。</p>\n<p class=\"js_darkmode__389\"><strong class=\"js_darkmode__390\">典型值：</strong>&nbsp;为247 字节 (常见的 DLE 扩展后数值) 或 512 字节 (最大)。</p>\n<p class=\"js_darkmode__391\">ATT连接建立后，客户端通常会发起&nbsp;<code class=\"js_darkmode__392\">Exchange MTU Request</code>，双方协商使用两者支持的较小值。</p>\n<h2 class=\"js_darkmode__393\"><span class=\"js_darkmode__394\">（五）GATT (Generic Attribute Profile)</span></h2>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161900151-965016108.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__396\">如果 ATT 是负责运输数据的<strong class=\"js_darkmode__397\">卡车</strong>，那么&nbsp;<strong class=\"js_darkmode__398\">GATT</strong>&nbsp;(Generic Attribute Profile) 就是定义货物如何打包、存放、分类以及如何进行存取操作的<strong class=\"js_darkmode__399\">仓库管理规范</strong>。</p>\n<h3 class=\"js_darkmode__400\"><span class=\"js_darkmode__401\">（1）GATT 核心概念与角色 (Roles)</span></h3>\n<p class=\"js_darkmode__402\">GATT 定义了两个在数据交换中完全不同的角色。请注意，这与链路层的主机 (Central/Master) 和从机 (Peripheral/Slave) 概念是独立的，尽管通常存在某种映射关系。</p>\n<p class=\"js_darkmode__403\"><strong class=\"js_darkmode__404\">GATT Server (服务端):</strong>&nbsp;拥有数据并接受数据访问请求的设备。它的职责是存储数据（Services 和 Characteristics），响应 Client 的读/写请求，或主动向 Client 推送数据。比如智能手环(存有心率数据)</p>\n<p class=\"js_darkmode__405\"><strong class=\"js_darkmode__406\">GATT Client (客户端):</strong>&nbsp;发起命令和请求，试图读取或写入数据的设备。它的职责是执行服务发现 (Service Discovery)，发起读写操作，接收 Server 推送的数据。比如智能手机（想要读取手环的心率）。</p>\n<h3 class=\"js_darkmode__407\"><span class=\"js_darkmode__408\">（2）GATT 数据层级结构 (Hierarchy)</span></h3>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161916556-43068230.png\" />\n<p class=\"js_darkmode__410\">GATT 最重要的贡献是定义了严格的数据层级结构，使得不同厂商的设备可以互相理解。</p>\n<p class=\"js_darkmode__411\"><strong class=\"js_darkmode__412\">（A）Profile (配置文件)</strong>&nbsp;Profile 实际上不是 GATT 协议本身定义的实体，而是由 Bluetooth SIG 或厂商定义的<strong class=\"js_darkmode__413\">集合</strong>。一个 Profile 可能包含一个或多个 Service。</p>\n<p class=\"js_darkmode__414\"><strong class=\"js_darkmode__415\">（B）Service (服务)</strong>&nbsp;:Service 是数据和相关行为的逻辑集合，用于实现特定的功能或特性。这里分三种服务：</p>\n<p class=\"js_darkmode__416\"><strong class=\"js_darkmode__417\">Primary Service (首要服务):</strong>&nbsp;暴露设备主要功能的服务。</p>\n<p class=\"js_darkmode__418\"><strong class=\"js_darkmode__419\">Secondary Service (次要服务):</strong>&nbsp;仅作为被引用的辅助服务（较少见）。</p>\n<p class=\"js_darkmode__420\"><strong class=\"js_darkmode__421\">Include Service (引用服务):</strong>&nbsp;一个服务可以引用另一个服务（类似于编程中的&nbsp;<code class=\"js_darkmode__422\"><a class=\"wx_topic_link\">#include</a></code>），例如<strong class=\"js_darkmode__423\">跑步服务</strong>可能引用<strong class=\"js_darkmode__424\">心率服务</strong>。</p>\n<p class=\"js_darkmode__425\"><strong class=\"js_darkmode__426\">（C）Characteristic (特征)</strong>&nbsp;:Characteristic 是 GATT 中最小的逻辑数据单元，包含实际的数据值。它由三个主要部分组成：</p>\n<p class=\"js_darkmode__427\"><strong class=\"js_darkmode__428\">Declaration (声明):</strong>&nbsp;包含属性（读、写、通知等）、Handle（句柄）和 UUID。</p>\n<p class=\"js_darkmode__429\"><strong class=\"js_darkmode__430\">Value (值):</strong>&nbsp;实际的数据（例如：心率值&nbsp;<code class=\"js_darkmode__431\">0x48</code>）。</p>\n<p class=\"js_darkmode__432\"><strong class=\"js_darkmode__433\">Descriptor (描述符):</strong>&nbsp;（可选）关于特征的额外信息。</p>\n<p class=\"js_darkmode__434\"><strong class=\"js_darkmode__435\">（D）Descriptor (描述符)</strong>&nbsp;:对 Characteristic 的进一步描述或配置。</p>\n<p class=\"js_darkmode__436\">最著名的 Descriptor 是&nbsp;<strong class=\"js_darkmode__437\">CCCD (Client Characteristic Configuration Descriptor)<strong class=\"js_darkmode__438\">。Client 必须写入这个描述符来</strong>开启</strong>&nbsp;Server 的通知 (Notify) 或指示 (Indicate) 功能。</p>\n<h3 class=\"js_darkmode__439\"><span class=\"js_darkmode__440\">（3）GATT 核心操作流程 (GATT Procedures)</span></h3>\n<p class=\"js_darkmode__441\"><strong class=\"js_darkmode__442\">（A）配置与发现 (Discovery)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116161949206-724330768.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__444\">Client 连接 Server 后，通常不知道 Server 有什么功能，需要进行发现：</p>\n<ul class=\"list-paddingleft-1 js_darkmode__445\">\n<li>\n<p class=\"js_darkmode__447\"><strong class=\"js_darkmode__448\">Discover Primary Services:</strong>&nbsp;找出设备支持的所有主要服务。</p>\n</li>\n<li>\n<p class=\"js_darkmode__450\"><strong class=\"js_darkmode__451\">Discover Characteristics:</strong>&nbsp;找出某个服务下有哪些特征。</p>\n</li>\n<li>\n<p class=\"js_darkmode__453\"><strong class=\"js_darkmode__454\">Discover Descriptors:</strong>&nbsp;找出特征下有哪些描述符。</p>\n</li>\n<li>\n<p class=\"js_darkmode__456\"><strong class=\"js_darkmode__457\">Exchange MTU:</strong>&nbsp;协商最大传输单元，以决定一次能传多少字节（蓝牙 4.2/5.0+ 之后非常重要，以提高吞吐量）。</p>\n</li>\n</ul>\n<p class=\"js_darkmode__458\"><strong class=\"js_darkmode__459\">（B）数据读取 (Client -&gt; Server)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116162000883-391759881.png\" />\n<ul class=\"list-paddingleft-1 js_darkmode__461\">\n<li><strong class=\"js_darkmode__463\">Read Characteristic Value:</strong>&nbsp;读取某个句柄的值。</li>\n<li><strong class=\"js_darkmode__465\">Read Blob:</strong>&nbsp;读取长数据的片段（当数据超过 MTU 时）。</li>\n<li><strong class=\"js_darkmode__467\">Read Multiple:</strong>&nbsp;一次性读取多个句柄的值。</li>\n</ul>\n<p class=\"js_darkmode__468\"><strong class=\"js_darkmode__469\">（C）数据写入 (Client -&gt; Server)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116162012058-1758124561.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<ul class=\"list-paddingleft-1 js_darkmode__471\">\n<li><strong class=\"js_darkmode__473\">Write Request:</strong>&nbsp;Client 写入数据，Server&nbsp;<strong class=\"js_darkmode__474\">必须回复</strong>&nbsp;(Ack)。可靠，但慢。</li>\n<li><strong class=\"js_darkmode__476\">Write Command (Write without Response):</strong>&nbsp;Client 写入数据，Server&nbsp;<strong class=\"js_darkmode__477\">不回复</strong>。速度快，用于高吞吐量场景（如 OTA 升级）。</li>\n<li><strong class=\"js_darkmode__479\">Signed Write:</strong>&nbsp;带有签名的写入，用于未加密连接但需要认证的场景。</li>\n</ul>\n<p class=\"js_darkmode__480\"><strong class=\"js_darkmode__481\">（D）服务器发起的数据推送 (Server -&gt; Client)</strong></p>\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/555985/202601/555985-20260116162012058-1758124561.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" />\n<p class=\"js_darkmode__483\">这是 BLE 低功耗的关键，Client 不需要一直轮询 (Polling)，而是订阅后等待 Server 推送。</p>\n<ul class=\"list-paddingleft-1 js_darkmode__484\">\n<li><strong class=\"js_darkmode__486\">Notification (通知):</strong>&nbsp;Server 发送数据给 Client，Client&nbsp;<strong class=\"js_darkmode__487\">不回复</strong>。速度快，但如果丢包不会重传。</li>\n<li><strong class=\"js_darkmode__489\">Indication (指示):</strong>&nbsp;Server 发送数据给 Client，Client&nbsp;<strong class=\"js_darkmode__490\">必须回复</strong>&nbsp;Confirmation。可靠，但在收到回复前 Server 不能发下一条，速度较慢。</li>\n</ul>\n<p class=\"js_darkmode__491\">注意： 要启用 Notification 或 Indication，Client 必须先在对应的 CCCD (描述符) 中写入特定的值。</p>\n<h2 class=\"js_darkmode__492\"><span class=\"js_darkmode__493\">结尾</span></h2>\n<p class=\"js_darkmode__494\">随着低功耗蓝牙的普及，Host 层的改进越来越趋向于<strong class=\"js_darkmode__495\">高效率</strong>和<strong class=\"js_darkmode__496\">低延迟</strong>。理解 GAP 的连接管理、ATT 的原子操作以及 GATT 的层级解构，是开发高性能蓝牙产品的基本。</p>\n<p class=\"js_darkmode__497\">希望这篇文章能有助于你更好地理解蓝牙协议栈及其工作原理。</p>\n<center>------------------End------------------</center><center>如需获取更多内容</center><center>请关注<span style=\"color: rgba(0, 0, 255, 1); font-size: large;\">&nbsp;liwen01&nbsp;</span>公众号</center>\n<div>\n<div class=\"appmsg_card_context wx_profile_card wx-root wx_tap_card wx_card_root common-webchat\">\n<div class=\"wx_profile_card_inner\">\n<div class=\"wx_profile_card_bd\">\n<div class=\"wx_profile weui-flex\">\n<div class=\"wx_profile_bd weui-flex weui-flex__item\">\n<div class=\"weui-flex__item\">\n<div class=\"wx_profile_nickname_wrp\">&nbsp;</div>\n<div class=\"wx_profile_tips\" id=\"js_a11y_wx_profile_tips\">&nbsp;</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 08:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/liwen01\">liwen01</a>&nbsp;\n阅读(<span id=\"post_view_count\">78</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "字符串分割并展开成表格的SQL实现方法",
      "link": "https://www.cnblogs.com/davablog/p/19497701",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/davablog/p/19497701\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 08:08\">\n    <span>字符串分割并展开成表格的SQL实现方法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>一、场景案例</h1>\n<div>在数据开发类项目中，常常会遇到需要将字符串进行切割并展开成表格的场景，如以下两种常见的案例：</div>\n<ol>\n<li>标签类型数据：如将员工标签类型的数据\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(128, 128, 128, 1);\">-</span><span style=\"color: rgba(0, 0, 0, 1);\"> 技能：Java、Spring、微服务、项目管理\n</span><span style=\"color: rgba(128, 128, 128, 1);\">-</span><span style=\"color: rgba(0, 0, 0, 1);\"> 项目经验：电商、金融、教育<br /></span><span style=\"color: rgba(128, 128, 128, 1);\">-</span> 工作风格：#执行力强 #跨部门协作 #数据驱动</pre>\n</div>\n</li>\n<li>分类层级数据：如将组织部门层级数据：“/集团/分公司/信息技术部/数据团队”</li>\n</ol>\n<p>除此之外，在一些特定的业务场景中，如证券场景中，需要将一笔回购合约涉及到的多个质押券进行拆分（提取每个质押券有质押数量及对应标准券转换比例），数据示例如下：</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>&nbsp;另外，API请求的返回的数据多为半结构化的字典列表数据，需要将每行数据从列表中进行提取出来再进行后续的处理，如以下数据：</p>\n<div class=\"cnblogs_code\">\n<pre>{\"data\"<span style=\"color: rgba(0, 0, 0, 1);\">: [<br />　　 {</span>\"AMOUNT\":-9000,\"SUB_TYPE_NAME\":\"债券分销\",\"BRANCH_NAME\":\"银行间\",\"TYPE_NAME\":\"收入\",\"BUSI_DATE\":\"20250831\",\"PROJECT_NAME\":\"调整1月分销佣金-24****MTN001\"<span style=\"color: rgba(0, 0, 0, 1);\">},\n    {</span>\"AMOUNT\":-1075.61,\"SUB_TYPE_NAME\":\"债券分销\",\"BRANCH_NAME\":\"银行间\",\"TYPE_NAME\":\"收入\",\"BUSI_DATE\":\"20250531\",\"PROJECT_NAME\":\"调整计提1月及3月分销佣金\"<span style=\"color: rgba(0, 0, 0, 1);\">}\n    ],\n</span>\"success\":<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">\n}</span></pre>\n</div>\n<h1>二，各类主流SQL方言实现方法</h1>\n<p>针对这类场景，目前没有标准SQL函数支持实现该功能。各类SQL方言通过自定义方法进行支持，以下是常用的实现方法。</p>\n<div id=\"tvoo-1768690884647\">\n<h2>Spark/Hive SQL</h2>\n</div>\n<div>采用split + explode（及升级版posexplode）。以下为测试案例：</div>\n<div><img alt=\"0\" class=\"lazyload\" /></div>\n<div>&nbsp;利用该方法可以轻松的回购质押券进行拆分处理：</div>\n<div>\n<p><img alt=\"image\" class=\"lazyload\" height=\"265\" width=\"905\" /></p>\n</div>\n<h2 id=\"hxy0-1768690884655\">PostgreSQL</h2>\n<div>有两种方法：</div>\n<div>方法一：首先利用string_to_array将字符串切割成数组，然后利用unnest将数组扩展成表</div>\n<div><img alt=\"image\" class=\"lazyload\" height=\"140\" width=\"455\" /></div>\n<div>方法二：直接利用regexp_split_to_table将字符串切割并转换成表</div>\n<div><img alt=\"image\" class=\"lazyload\" height=\"151\" width=\"457\" /></div>\n<div>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed lazyload\" id=\"code_img_closed_384da3ac-fe03-4ded-b878-03d509f19394\" /><img class=\"code_img_opened lazyload\" id=\"code_img_opened_384da3ac-fe03-4ded-b878-03d509f19394\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_384da3ac-fe03-4ded-b878-03d509f19394\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">select</span> string_to_array(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">apple,banana,orange</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(0, 0, 255, 1);\">as</span><span style=\"color: rgba(0, 0, 0, 1);\"> item;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">select</span> string_to_array(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">apple|banana|orange</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">|</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(0, 0, 255, 1);\">as</span><span style=\"color: rgba(0, 0, 0, 1);\"> item;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">select</span> unnest(string_to_array(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">apple,banana,orange</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>)) <span style=\"color: rgba(0, 0, 255, 1);\">as</span><span style=\"color: rgba(0, 0, 0, 1);\"> item;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">select</span> regexp_split_to_array(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">apple|banana|orange</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">\\|</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(0, 0, 255, 1);\">as</span><span style=\"color: rgba(0, 0, 0, 1);\"> item;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">select</span> regexp_split_to_table(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">apple|banana|orange</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">\\|</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(0, 0, 255, 1);\">as</span> item;</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n</div>\n<h2 id=\"AoqL-1768690884660\">Oracle</h2>\n<div>利用connect by + Level来实现</div>\n<div>\n<p><img alt=\"0\" class=\"lazyload\" /></p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed lazyload\" id=\"code_img_closed_0763077f-3809-4cd8-a83d-7e204a54ea87\" /><img class=\"code_img_opened lazyload\" id=\"code_img_opened_0763077f-3809-4cd8-a83d-7e204a54ea87\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_0763077f-3809-4cd8-a83d-7e204a54ea87\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">WITH</span> CTE_DATA <span style=\"color: rgba(0, 0, 255, 1);\">AS</span><span style=\"color: rgba(0, 0, 0, 1);\"> (\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">tom</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> NAME, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">apple,banana,cherry</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> FRUIT <span style=\"color: rgba(0, 0, 255, 1);\">FROM</span><span style=\"color: rgba(0, 0, 0, 1);\"> DUAL\n)\n</span><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> NAME, REGEXP_SUBSTR(FRUIT, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">[^,]+</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>, <span style=\"color: rgba(0, 0, 255, 1);\">LEVEL</span>) <span style=\"color: rgba(0, 0, 255, 1);\">AS</span><span style=\"color: rgba(0, 0, 0, 1);\"> FRUIT\n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span><span style=\"color: rgba(0, 0, 0, 1);\"> CTE_DATA\nCONNECT </span><span style=\"color: rgba(0, 0, 255, 1);\">BY</span> REGEXP_SUBSTR(FRUIT, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">[^,]+</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>, <span style=\"color: rgba(0, 0, 255, 1);\">LEVEL</span>) <span style=\"color: rgba(0, 0, 255, 1);\">IS</span> <span style=\"color: rgba(128, 128, 128, 1);\">NOT</span> <span style=\"color: rgba(0, 0, 255, 1);\">NULL</span><span style=\"color: rgba(0, 0, 0, 1);\">\n;</span></pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n</div>\n<h2 id=\"7fPr-1768690884678\">MySQL</h2>\n<div>5.x+版本只能使用数字辅助表+SUBSTRING_INDEX。</div>\n<div>\n<p><img alt=\"image\" class=\"lazyload\" height=\"360\" width=\"926\" /></p>\n</div>\n<div>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed lazyload\" id=\"code_img_closed_2f00195d-6b1a-4823-9aaf-ce74dfcdb1ee\" /><img class=\"code_img_opened lazyload\" id=\"code_img_opened_2f00195d-6b1a-4823-9aaf-ce74dfcdb1ee\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_2f00195d-6b1a-4823-9aaf-ce74dfcdb1ee\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">CREATE</span> <span style=\"color: rgba(0, 0, 255, 1);\">TABLE</span> <span style=\"color: rgba(0, 0, 255, 1);\">IF</span> <span style=\"color: rgba(128, 128, 128, 1);\">NOT</span> <span style=\"color: rgba(128, 128, 128, 1);\">EXISTS</span> numbers (n <span style=\"color: rgba(0, 0, 255, 1);\">INT</span> <span style=\"color: rgba(0, 0, 255, 1);\">PRIMARY</span> <span style=\"color: rgba(0, 0, 255, 1);\">KEY</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">INSERT</span> <span style=\"color: rgba(0, 0, 255, 1);\">INTO</span><span style=\"color: rgba(0, 0, 0, 1);\"> numbers\n</span><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> a.N <span style=\"color: rgba(128, 128, 128, 1);\">+</span> b.N <span style=\"color: rgba(128, 128, 128, 1);\">*</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">10</span> <span style=\"color: rgba(128, 128, 128, 1);\">+</span> c.N <span style=\"color: rgba(128, 128, 128, 1);\">*</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">100</span> <span style=\"color: rgba(128, 128, 128, 1);\">+</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span><span style=\"color: rgba(0, 0, 0, 1);\"> n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span> (<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> N <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">2</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">3</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">4</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">5</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">6</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">7</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">8</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">9</span><span style=\"color: rgba(0, 0, 0, 1);\">) a\n</span><span style=\"color: rgba(0, 0, 255, 1);\">CROSS</span> <span style=\"color: rgba(128, 128, 128, 1);\">JOIN</span> (<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> N <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">2</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">3</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">4</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">5</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">6</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">7</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">8</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">9</span><span style=\"color: rgba(0, 0, 0, 1);\">) b\n</span><span style=\"color: rgba(0, 0, 255, 1);\">CROSS</span> <span style=\"color: rgba(128, 128, 128, 1);\">JOIN</span> (<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> N <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">2</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">3</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">4</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">5</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">6</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">7</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">8</span> <span style=\"color: rgba(0, 0, 255, 1);\">UNION</span> <span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">9</span><span style=\"color: rgba(0, 0, 0, 1);\">) c;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 使用数字表分割</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span><span style=\"color: rgba(0, 0, 0, 1);\">\nSUBSTRING_INDEX(\nSUBSTRING_INDEX(</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">a,b,c,d</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">, numbers.n),\n</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span><span style=\"color: rgba(128, 128, 128, 1);\">-</span><span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">\n) </span><span style=\"color: rgba(0, 0, 255, 1);\">AS</span><span style=\"color: rgba(0, 0, 0, 1);\"> part\n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span><span style=\"color: rgba(0, 0, 0, 1);\"> numbers\n</span><span style=\"color: rgba(0, 0, 255, 1);\">WHERE</span> numbers.n <span style=\"color: rgba(128, 128, 128, 1);\">&lt;=</span> LENGTH(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">a,b,c,d</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(128, 128, 128, 1);\">-</span> LENGTH(<span style=\"color: rgba(255, 0, 255, 1);\">REPLACE</span>(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">a,b,c,d</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">''</span>)) <span style=\"color: rgba(128, 128, 128, 1);\">+</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>;</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<p>8.0+版本可使用json_table</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span><span style=\"color: rgba(0, 0, 0, 1);\"> \n    o.order_id,\n    j.product_id\n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span><span style=\"color: rgba(0, 0, 0, 1);\"> orders o\n</span><span style=\"color: rgba(128, 128, 128, 1);\">JOIN</span><span style=\"color: rgba(0, 0, 0, 1);\"> JSON_TABLE(\n    CONCAT(</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">[\"</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 255, 1);\">REPLACE</span>(o.product_ids, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">\",\"</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>), <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">\"]</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">),\n    </span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">$[*]</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span> COLUMNS (product_id <span style=\"color: rgba(0, 0, 255, 1);\">INT</span> PATH <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">$</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n) </span><span style=\"color: rgba(0, 0, 255, 1);\">AS</span> j;</pre>\n</div>\n<h2 id=\"AoqL-1768690884660\">SQL Server</h2>\n</div>\n<div>早期版本无内置函数，只能通过自定义表值函数（TVF）或者XML方法</div>\n<div>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed lazyload\" id=\"code_img_closed_f7b1138f-107e-4278-9ae3-23f7365d8755\" /><img class=\"code_img_opened lazyload\" id=\"code_img_opened_f7b1138f-107e-4278-9ae3-23f7365d8755\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_f7b1138f-107e-4278-9ae3-23f7365d8755\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">CREATE</span> <span style=\"color: rgba(0, 0, 255, 1);\">FUNCTION</span><span style=\"color: rgba(0, 0, 0, 1);\"> dbo.SplitString\n(\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">@String</span> <span style=\"color: rgba(0, 0, 255, 1);\">NVARCHAR</span>(<span style=\"color: rgba(255, 0, 255, 1);\">MAX</span><span style=\"color: rgba(0, 0, 0, 1);\">),\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">@Delimiter</span> <span style=\"color: rgba(0, 0, 255, 1);\">CHAR</span>(<span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n)\n</span><span style=\"color: rgba(0, 0, 255, 1);\">RETURNS</span> <span style=\"color: rgba(0, 128, 0, 1);\">@Results</span> <span style=\"color: rgba(0, 0, 255, 1);\">TABLE</span><span style=\"color: rgba(0, 0, 0, 1);\"> \n(\n    ID </span><span style=\"color: rgba(0, 0, 255, 1);\">INT</span> <span style=\"color: rgba(255, 0, 255, 1);\">IDENTITY</span>(<span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>,<span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">),\n    Value </span><span style=\"color: rgba(0, 0, 255, 1);\">NVARCHAR</span>(<span style=\"color: rgba(255, 0, 255, 1);\">MAX</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n)\n</span><span style=\"color: rgba(0, 0, 255, 1);\">AS</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">BEGIN</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">DECLARE</span> <span style=\"color: rgba(0, 128, 0, 1);\">@pos</span> <span style=\"color: rgba(0, 0, 255, 1);\">INT</span> <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">DECLARE</span> <span style=\"color: rgba(0, 128, 0, 1);\">@slice</span> <span style=\"color: rgba(0, 0, 255, 1);\">NVARCHAR</span>(<span style=\"color: rgba(255, 0, 255, 1);\">MAX</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">IF</span> <span style=\"color: rgba(128, 128, 128, 1);\">RIGHT</span>(<span style=\"color: rgba(0, 128, 0, 1);\">@String</span>, <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>) <span style=\"color: rgba(128, 128, 128, 1);\">!=</span> <span style=\"color: rgba(0, 128, 0, 1);\">@Delimiter</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">SET</span> <span style=\"color: rgba(0, 128, 0, 1);\">@String</span> <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(0, 128, 0, 1);\">@String</span> <span style=\"color: rgba(128, 128, 128, 1);\">+</span> <span style=\"color: rgba(0, 128, 0, 1);\">@Delimiter</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">WHILE</span> <span style=\"color: rgba(255, 0, 255, 1);\">CHARINDEX</span>(<span style=\"color: rgba(0, 128, 0, 1);\">@Delimiter</span>, <span style=\"color: rgba(0, 128, 0, 1);\">@String</span>) <span style=\"color: rgba(128, 128, 128, 1);\">&gt;</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">0</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">BEGIN</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">SET</span> <span style=\"color: rgba(0, 128, 0, 1);\">@pos</span> <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(255, 0, 255, 1);\">CHARINDEX</span>(<span style=\"color: rgba(0, 128, 0, 1);\">@Delimiter</span>, <span style=\"color: rgba(0, 128, 0, 1);\">@String</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">SET</span> <span style=\"color: rgba(0, 128, 0, 1);\">@slice</span> <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(128, 128, 128, 1);\">LEFT</span>(<span style=\"color: rgba(0, 128, 0, 1);\">@String</span>, <span style=\"color: rgba(0, 128, 0, 1);\">@pos</span> <span style=\"color: rgba(128, 128, 128, 1);\">-</span> <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        \n        </span><span style=\"color: rgba(0, 0, 255, 1);\">INSERT</span> <span style=\"color: rgba(0, 0, 255, 1);\">INTO</span> <span style=\"color: rgba(0, 128, 0, 1);\">@Results</span> (Value) <span style=\"color: rgba(0, 0, 255, 1);\">VALUES</span> (<span style=\"color: rgba(0, 128, 0, 1);\">@slice</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">SET</span> <span style=\"color: rgba(0, 128, 0, 1);\">@String</span> <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(255, 0, 255, 1);\">STUFF</span>(<span style=\"color: rgba(0, 128, 0, 1);\">@String</span>, <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>, <span style=\"color: rgba(0, 128, 0, 1);\">@pos</span>, <span style=\"color: rgba(255, 0, 0, 1);\">''</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">END</span>\n    \n    <span style=\"color: rgba(0, 0, 255, 1);\">RETURN</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">END</span>\n\n<span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 使用示例</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(128, 128, 128, 1);\">*</span> <span style=\"color: rgba(0, 0, 255, 1);\">FROM</span> dbo.SplitString(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">张三,李四,王五</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>)</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed lazyload\" id=\"code_img_closed_3ed525c1-7f6f-49ac-9b5f-2bc138b81373\" /><img class=\"code_img_opened lazyload\" id=\"code_img_opened_3ed525c1-7f6f-49ac-9b5f-2bc138b81373\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_3ed525c1-7f6f-49ac-9b5f-2bc138b81373\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">DECLARE</span> <span style=\"color: rgba(0, 128, 0, 1);\">@str</span> <span style=\"color: rgba(0, 0, 255, 1);\">NVARCHAR</span>(<span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">100</span>) <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">苹果|香蕉|橙子</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">DECLARE</span> <span style=\"color: rgba(0, 128, 0, 1);\">@separator</span> <span style=\"color: rgba(0, 0, 255, 1);\">CHAR</span>(<span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>) <span style=\"color: rgba(128, 128, 128, 1);\">=</span> <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">|</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> \n    <span style=\"color: rgba(255, 0, 255, 1);\">LTRIM</span>(<span style=\"color: rgba(255, 0, 255, 1);\">RTRIM</span>(m.n.value(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">.[1]</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">NVARCHAR(100)</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>))) <span style=\"color: rgba(0, 0, 255, 1);\">AS</span><span style=\"color: rgba(0, 0, 0, 1);\"> SplitValue\n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span><span style=\"color: rgba(0, 0, 0, 1);\"> \n    (</span><span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span> <span style=\"color: rgba(255, 0, 255, 1);\">CAST</span>(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">&lt;x&gt;</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span> <span style=\"color: rgba(128, 128, 128, 1);\">+</span> <span style=\"color: rgba(255, 0, 255, 1);\">REPLACE</span>(<span style=\"color: rgba(0, 128, 0, 1);\">@str</span>, <span style=\"color: rgba(0, 128, 0, 1);\">@separator</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">&lt;/x&gt;&lt;x&gt;</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(128, 128, 128, 1);\">+</span> <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">&lt;/x&gt;</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span> <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> XML)) <span style=\"color: rgba(0, 0, 255, 1);\">AS</span><span style=\"color: rgba(0, 0, 0, 1);\"> t(x)\n</span><span style=\"color: rgba(0, 0, 255, 1);\">CROSS</span><span style=\"color: rgba(0, 0, 0, 1);\"> APPLY \n    x.nodes(</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">/x</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>) <span style=\"color: rgba(0, 0, 255, 1);\">AS</span> m(n);</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">View Code</span></div>\n<p>2016之后的版本可使用原生方法STRING_SPLIT</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\">带序号的版本（SQL Server 2022+）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">SELECT</span><span style=\"color: rgba(0, 0, 0, 1);\"> value, ordinal\n</span><span style=\"color: rgba(0, 0, 255, 1);\">FROM</span> STRING_SPLIT(<span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">a,b,c</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(255, 0, 0, 1);\">'</span><span style=\"color: rgba(255, 0, 0, 1);\">,</span><span style=\"color: rgba(255, 0, 0, 1);\">'</span>, <span style=\"color: rgba(128, 0, 0, 1); font-weight: bold;\">1</span>) <span style=\"color: rgba(0, 128, 128, 1);\">--</span><span style=\"color: rgba(0, 128, 128, 1);\"> 第三个参数启用序号</span></pre>\n</div>\n</div>\n<h1>三、结论</h1>\n<div>　　Spark SQL、PostgreSQL最方便，思路也比较相似，都是先将字符串拆分数组，然后扩展成表。SQLServer新版本实现较为方法，直接一个函数搞定。Oracle利用其connect by来实现，也相对便捷，只是相对主流SQL方言比较小众一点。Mysql新版本相对方便一点，老版本需要辅助表增加维护成本。</div>\n<h1>四、参考链接</h1>\n<div><a href=\"https://www.kimi.com/share/19bd8855-80d2-8885-8000-00003449be16\" rel=\"noopener nofollow\" target=\"_blank\">https://www.kimi.com/share/19bd8855-80d2-8885-8000-00003449be16</a></div>\n<div><a href=\"https://www.kimi.com/share/19bd8885-e842-8472-8000-000042aa28d0\" rel=\"noopener nofollow\" target=\"_blank\">https://www.kimi.com/share/19bd8885-e842-8472-8000-000042aa28d0</a></div>\n<div><a href=\"https://chat.deepseek.com/share/h9bv2i75c90jcfz3uo\" rel=\"noopener nofollow\" target=\"_blank\">https://chat.deepseek.com/share/h9bv2i75c90jcfz3uo</a></div>\n<div><a href=\"http://blog.itpub.net/16436858/viewspace-624191/\" rel=\"noopener nofollow\">http://blog.itpub.net/16436858/viewspace-624191/</a></div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 08:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/davablog\">大汪的数据之路</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "unity性能优化-实际开发中需要注意的点",
      "link": "https://www.cnblogs.com/pipicfan/p/19503936",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/pipicfan/p/19503936\" id=\"cb_post_title_url\" title=\"发布于 2026-01-19 22:55\">\n    <span>unity性能优化-实际开发中需要注意的点</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><strong>unity性能优化-实际开发中需要注意的点</strong></p>\n<p><a id=\"heading_0\"></a><strong>性能优化建议</strong></p>\n<p>在进行下面优化之前，建议先使用 <strong>Unity Profiler</strong> 定位真实的瓶颈。</p>\n<p><strong>优化核心原则：</strong></p>\n<p><strong>能缓存的就缓存</strong>（变量、组件、材质）。</p>\n<p><strong>能不更新就不更新</strong>（降低 update 频率，使用事件驱动或Coroutine）。</p>\n<p><strong>避免在循环中分配内存</strong>（减少 new 关键字，使用对象池）。</p>\n<p><a id=\"heading_1\"></a><strong>1.复杂数学计算，比如mesh顶点数据的创建，大小和归一化属性都非常耗费 CPU（都涉及计算平方根）</strong></p>\n<p>可以使用对象池来空间换时间处理，涉及开根号的用平方比较</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119225507554-1515541958.png\" /></p>\n<p><a id=\"heading_2\"></a><strong>2.shader的合批处理</strong></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119230139424-582581237.png\" /></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119230139503-1658596290.png\" /></p>\n<p><a id=\"heading_3\"></a><strong>3.一些List，Vector不要用集合，而是指定它的大小</strong></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119230139380-946016432.png\" /></p>\n<p><a id=\"heading_4\"></a><strong>4.不要再update里面去大量调用Component（新手容易忽略重要）</strong></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119225506870-1113031628.png\" /></p>\n<p><a id=\"heading_5\"></a><strong>5.优化字符串对比</strong></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119230139483-820107562.png\" /></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119230139441-648476313.png\" /></p>\n<p><a id=\"heading_6\"></a><strong>6.常量的字符串写成类的成员变量</strong></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119225506734-1746349249.png\" /></p>\n<p><a id=\"heading_7\"></a><strong>7.裁剪引擎，去掉音频</strong></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119225507500-1539839110.png\" /></p>\n<p><a id=\"heading_8\"></a><strong>8.裁剪引擎，去掉物理，注意此时包括包围盒都不能使用</strong></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119230139347-1887459637.png\" /></p>\n<p><a id=\"heading_9\"></a><strong>9.固定帧率，减少帧率</strong></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119230139518-121341222.png\" /></p>\n<p><a id=\"heading_10\"></a><strong>10.避免使用拆箱装箱</strong></p>\n<p>在C#中，装箱（Boxing）和拆箱（Unboxing）是指值类型与引用类型之间的转换。装箱是将值类型转换为对象类型（通常是将值类型包装在堆上），而拆箱则是从对象类型还原为值类型。</p>\n<p><a id=\"heading_11\"></a><strong>装箱（Boxing）开销</strong></p>\n<p><strong>内存分配</strong>：</p>\n<p>装箱过程中，会在堆上分配内存来存储值类型的数据。堆内存的分配通常比栈内存的分配慢，因为堆内存需要处理垃圾回收（Garbage Collection），而且堆内存分配涉及更多的管理操作。</p>\n<p><strong>数据复制</strong>：</p>\n<p>装箱需要将值类型的数据从栈上复制到新分配的堆对象中。这涉及到数据的复制操作，增加了额外的开销。</p>\n<p><strong>垃圾回收</strong>：</p>\n<p>装箱产生的堆对象最终会由垃圾回收器（GC）回收。垃圾回收是一个耗时的过程，会影响应用程序的性能。</p>\n<p><a id=\"heading_12\"></a><strong>拆箱（Unboxing）开销</strong></p>\n<p><strong>类型检查</strong>：</p>\n<p>拆箱过程中，需要进行类型检查，以确保对象确实是预期的值类型。这涉及到运行时的类型元数据访问和检查，增加了开销。</p>\n<p><strong>数据复制</strong>：</p>\n<p>拆箱需要将堆上的数据复制回栈上。这同样涉及数据的复制操作，带来了额外的性能开销。</p>\n<p><a id=\"heading_13\"></a><strong>避免装箱和拆箱的方法</strong></p>\n<p><strong>使用泛型</strong>：泛型可以减少装箱和拆箱的需要，因为泛型可以在编译时确定类型，而不需要在运行时进行类型转换，但是泛型带来另一个问题，即转换为il2cpp的时候，代码会膨胀，这个后面可以再说</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用泛型避免装箱和拆箱</span>\nList&lt;intnumbers = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;<span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">();\nnumbers.Add(</span><span style=\"color: rgba(128, 0, 128, 1);\">42</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">int</span> number = numbers[<span style=\"color: rgba(128, 0, 128, 1);\">0</span>];</pre>\n</div>\n<p>&nbsp;</p>\n<br />\n<p><strong>避免频繁的值类型到引用类型的转换</strong>：在设计程序时，尽量减少值类型与引用类型之间的转换。如果可能，尽量使用值类型本身来进行计算和处理。</p>\n<p><strong>使用struct而不是类</strong>：在某些情况下，可以使用struct来代替类，因为struct是值类型，不需要装箱和拆箱。</p>\n<p><strong>避免接口调用</strong>：接口调用通常需要装箱，特别是在接口接受值类型参数时。尽量避免在接口方法中使用值类型参数</p>\n<p><a id=\"heading_14\"></a><strong>11.GameObject.Instantiate  和 SetParent</strong></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\"> 1</span> <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> ESDRoadEdgePool\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 2</span> <span style=\"color: rgba(0, 0, 0, 1);\">{\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 3</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">public int amountToPool = 100; </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 池中对象的数量 </span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 4</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">int</span> amountToPool = <span style=\"color: rgba(128, 0, 128, 1);\">25</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 5</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 6</span>     pooledObjects = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;GameObject&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 7</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 8</span>     <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt; amountToPool; i++<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 9</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">10</span>         GameObject obj = Instantiate(objectToPool); <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 实例化可以缩减</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">11</span>         obj.SetActive(<span style=\"color: rgba(0, 0, 255, 1);\">false</span>);                       <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 可以预先设置预制体的activeSelf</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">12</span>         obj.transform.parent = <span style=\"color: rgba(0, 0, 255, 1);\">this</span>.transform;      <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 可以合并到Instantiate中</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">13</span> <span style=\"color: rgba(0, 0, 0, 1);\">        pooledObjects.Add(obj);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">14</span>         \n<span style=\"color: rgba(0, 128, 128, 1);\">15</span>            \n<span style=\"color: rgba(0, 128, 128, 1);\">16</span>         GameObject obj =<span style=\"color: rgba(0, 0, 0, 1);\"> Instantiate(objectToPool, transform);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">17</span> <span style=\"color: rgba(0, 0, 0, 1);\">        pooledObjects.Add(obj);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">18</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">19</span> }</pre>\n</div>\n<p>&nbsp;</p>\n<p><a id=\"heading_15\"></a><strong>12.嵌套循环中new Vector3等</strong></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">　</pre>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\"> 1</span> <span style=\"color: rgba(0, 0, 255, 1);\">for</span>(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt; count; i++<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 2</span> <span style=\"color: rgba(0, 0, 0, 1);\">{\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 3</span> <span style=\"color: rgba(0, 0, 0, 1);\">    ...\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 4</span>     Vector2 p1l_uv = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Vector2(offest.x, uvStart /<span style=\"color: rgba(0, 0, 0, 1);\"> 10f);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 5</span>     Vector2 p1r_uv = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Vector2(offest.y, uvStart /<span style=\"color: rgba(0, 0, 0, 1);\"> 10f);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 6</span>     Vector2 p2l_uv = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Vector2(offest.x, (uvStart + distance) / <span style=\"color: rgba(128, 0, 128, 1);\">10</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 7</span>     Vector2 p2r_uv = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Vector2(offest.y, (uvStart + distance) / <span style=\"color: rgba(128, 0, 128, 1);\">10</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 8</span> <span style=\"color: rgba(0, 0, 0, 1);\">    ...\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 9</span> <span style=\"color: rgba(0, 0, 0, 1);\">}\n</span><span style=\"color: rgba(0, 128, 128, 1);\">10</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">11</span> <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 可以将对象创建挪到循环外进行复用</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">12</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">13</span> Vector2 p1l_uv = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Vector2();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">14</span> Vector2 p1r_uv = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Vector2();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">15</span> Vector2 p2l_uv = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Vector2();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">16</span> Vector2 p2r_uv = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> Vector2();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">17</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">18</span> <span style=\"color: rgba(0, 0, 255, 1);\">for</span>(<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt; count; i++<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">19</span> <span style=\"color: rgba(0, 0, 0, 1);\">{\n</span><span style=\"color: rgba(0, 128, 128, 1);\">20</span> <span style=\"color: rgba(0, 0, 0, 1);\">    ...\n</span><span style=\"color: rgba(0, 128, 128, 1);\">21</span>     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 同时可以使用Vector3.Set来一次性对向量的每个分量进行赋值</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">22</span>     p1l_uv.Set(offest.x, uvStart /<span style=\"color: rgba(0, 0, 0, 1);\"> 10f);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">23</span>     p1r_uv.Set(offest.y, uvStart /<span style=\"color: rgba(0, 0, 0, 1);\"> 10f);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">24</span>     p2l_uv.Set(offest.x, (uvStart + distance) / <span style=\"color: rgba(128, 0, 128, 1);\">10</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">25</span>     p2r_uv.Set(offest.y, (uvStart + distance) / <span style=\"color: rgba(128, 0, 128, 1);\">10</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">26</span> <span style=\"color: rgba(0, 0, 0, 1);\">    ...\n</span><span style=\"color: rgba(0, 128, 128, 1);\">27</span> }</pre>\n</div>\n<p>&nbsp;</p>\n</div>\n<p><a id=\"heading_16\"></a><strong>13.每帧循环调用的计算逻辑，可以使用对象池替代</strong></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\"> 1</span> <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt; len - <span style=\"color: rgba(128, 0, 128, 1);\">1</span>; i++<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 2</span> <span style=\"color: rgba(0, 0, 0, 1);\">{\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 3</span> <span style=\"color: rgba(0, 0, 0, 1);\">    ...\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 4</span>     SquareCell cell = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> SquareCell();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 5</span> <span style=\"color: rgba(0, 0, 0, 1);\">    ...\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 6</span> <span style=\"color: rgba(0, 0, 0, 1);\"> }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 7</span>  \n<span style=\"color: rgba(0, 128, 128, 1);\"> 8</span>  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 加入对象池</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 9</span>  <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> SquareCellPool\n</span><span style=\"color: rgba(0, 128, 128, 1);\">10</span> <span style=\"color: rgba(0, 0, 0, 1);\"> {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">11</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span><span style=\"color: rgba(0, 0, 0, 1);\"> SquareCell Allocate()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">12</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">13</span>         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (pool.TryDequeue(<span style=\"color: rgba(0, 0, 255, 1);\">out</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span><span style=\"color: rgba(0, 0, 0, 1);\"> cell))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">14</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">15</span>             totalCount--<span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">16</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> cell;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">17</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">18</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\">19</span>         <span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">int</span> i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt; poolInterval; i++<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">20</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">21</span>             SquareCell newCell = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> SquareCell();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">22</span> <span style=\"color: rgba(0, 0, 0, 1);\">            pool.Enqueue(newCell);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">23</span>             totalCount++<span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">24</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">25</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\">26</span>         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (totalCount &gt; <span style=\"color: rgba(128, 0, 128, 1);\">65535</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">27</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">28</span>             Debug.LogError(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Pool Out of Count!</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> +<span style=\"color: rgba(0, 0, 0, 1);\"> totalCount);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">29</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">30</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">31</span>         cell =<span style=\"color: rgba(0, 0, 0, 1);\"> pool.Dequeue();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">32</span>         totalCount--<span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">33</span>         <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> cell;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">34</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">35</span>  }</pre>\n</div>\n<p>&nbsp;</p>\n<br />\n<p><a id=\"heading_17\"></a><strong>14.Shader中处理逻辑能不使用高精度可以使用低精度的</strong></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119225508259-375921676.png\" /></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119225507827-2125826982.png\" /></p>\n<p><a id=\"heading_18\"></a><strong>15.避免 Camera.main</strong></p>\n<p>在 Unity 中，Camera.main 实际上是调用了 GameObject.FindWithTag(\"MainCamera\")，这是一个非常耗时的操作</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119225502907-593523569.png\" /></p>\n<p>发现unity文档里面,这块其实也是做了缓存gameobject</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/357310/202601/357310-20260119225506505-1590491376.jpg\" /></p>\n<p>但是缓存肯定还是最快的,因为gameobject也有开销</p>\n<p><strong>本文档会陆续补充更新，优化无止境</strong></p>\n</div>\n<div id=\"MySignature\">\n    我自豪 我是一名软件工程师。\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-19 22:55</span>&nbsp;\n<a href=\"https://www.cnblogs.com/pipicfan\">pipicfan</a>&nbsp;\n阅读(<span id=\"post_view_count\">52</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "DeploySharp 全面支持 YOLO26 系列，助力开发者快速部署落地应用",
      "link": "https://www.cnblogs.com/guojin-blogs/p/19503930",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/guojin-blogs/p/19503930\" id=\"cb_post_title_url\" title=\"发布于 2026-01-19 22:47\">\n    <span>DeploySharp 全面支持 YOLO26 系列，助力开发者快速部署落地应用</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"DeploySharp 全面支持 YOLO26 系列，助力开发者快速部署落地应用\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2933426/202601/2933426-20260119224728680-943487144.png\" />\n        DeploySharp是一个专为C#开发者设计的跨平台模型部署框架，全面支持YOLOv26系列模型，包括目标检测、实例分割、姿态估计和旋转框检测。该框架提供多引擎支持(OpenVINO/ONNX Runtime/TensorRT)、两种图像处理库选择(ImageSharp/OpenCvSharp)以及跨平台运行时兼容性。通过模块化架构和NuGet包生态，开发者可以快速部署YOLOv26模型，实现从模型加载到推理执行的端到端解决方案。项目开源且支持多种硬件设备，为计算机视觉应用落地提供高效工具。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"deploysharp-全面支持-yolo26-系列助力开发者快速部署落地应用\">DeploySharp 全面支持 YOLO26 系列，助力开发者快速部署落地应用</h1>\n<h2 id=\"一deploysharp-简介\">一、DeploySharp 简介</h2>\n<p>DeploySharp 是一个专为 C# 开发者设计的跨平台模型部署框架，旨在提供从模型加载、配置管理到推理执行的端到端解决方案。该项目由 椒颜皮皮虾开发并开源，遵循 Apache 2.0 许可协议，目前在 GitHub 上获得了广泛关注。</p>\n<p>DeploySharp 采用了清晰的模块化架构设计：</p>\n<ul>\n<li><strong>根命名空间</strong>：<code>DeploySharp</code> 作为统一入口，集成模型加载、推理执行等核心功能</li>\n<li><strong>子命名空间</strong>：通过 <code>DeploySharp.Engine</code>、<code>DeploySharp.Data</code>、<code>DeploySharp.Model</code> 等子命名空间实现模块化分层</li>\n<li><strong>泛型设计</strong>：关键类采用泛型设计，支持图像处理、分类、检测等多任务标准数据交互</li>\n</ul>\n<p><strong>项目地址</strong>：</p>\n<pre><code>https://github.com/guojin-yan/DeploySharp.git\n</code></pre>\n<h3 id=\"1-多引擎支持\">1. 多引擎支持</h3>\n<p>DeploySharp 原生支持三种主流推理引擎：</p>\n<table>\n<thead>\n<tr>\n<th>推理引擎</th>\n<th>状态</th>\n<th>支持设备</th>\n<th>性能特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OpenVINO</td>\n<td>完成</td>\n<td>CPU、GPU0(集显)、GPU1(独显)、NPU</td>\n<td>Intel 硬件优化</td>\n</tr>\n<tr>\n<td>ONNX Runtime</td>\n<td>完成</td>\n<td>CPU、GPU(CUDA/DML)</td>\n<td>跨平台兼容性好</td>\n</tr>\n<tr>\n<td>TensorRT</td>\n<td>完成</td>\n<td>GPU(TensorRT)</td>\n<td>NVIDIA GPU 极致性能</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-图像处理支持\">2. 图像处理支持</h3>\n<p>框架提供了两种图像处理库的选择：</p>\n<table>\n<thead>\n<tr>\n<th>图像处理库</th>\n<th>特点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ImageSharp</td>\n<td>纯 C# 实现，跨平台兼容性好，无原生依赖</td>\n<td>跨平台应用、Web 应用</td>\n</tr>\n<tr>\n<td>OpenCvSharp</td>\n<td>OpenCV 的 C# 封装，功能强大，性能优异</td>\n<td>桌面应用、高性能场景</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3-跨平台运行时支持\">3. 跨平台运行时支持</h3>\n<p>DeploySharp 兼容了广泛的 .NET 运行时环境：</p>\n<ul>\n<li>.NET Framework 4.8 / 4.8.1</li>\n<li>.NET Core 3.1</li>\n<li>.NET 5.0</li>\n<li>.NET 6.0</li>\n<li>.NET 7.0</li>\n<li>.NET 8.0</li>\n<li>.NET 9.0</li>\n<li>.NET 10.0</li>\n</ul>\n<h3 id=\"4-nuget-包生态\">4. NuGet 包生态</h3>\n<h4 id=\"41-核心包\">4.1 核心包</h4>\n<table>\n<thead>\n<tr>\n<th>包名</th>\n<th>描述</th>\n<th>NuGet 链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JYPPX.DeploySharp</td>\n<td>DeploySharp API 核心库</td>\n<td><a href=\"https://www.nuget.org/packages/JYPPX.DeploySharp/\" rel=\"noopener nofollow\" target=\"_blank\"><img alt=\"NuGet\" class=\"lazyload\" /></a></td>\n</tr>\n</tbody>\n</table>\n<p><strong>核心包功能</strong>：</p>\n<ul>\n<li>推理引擎抽象接口</li>\n<li>数据结构定义</li>\n<li>模型配置基类</li>\n<li>性能分析工具</li>\n<li>日志系统</li>\n<li>可视化基础功能</li>\n</ul>\n<h4 id=\"42-图像处理扩展包\">4.2 图像处理扩展包</h4>\n<table>\n<thead>\n<tr>\n<th>包名</th>\n<th>描述</th>\n<th>NuGet 链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JYPPX.DeploySharp.ImageSharp</td>\n<td>使用 ImageSharp 的图像处理扩展</td>\n<td><a href=\"https://www.nuget.org/packages/JYPPX.DeploySharp.ImageSharp/\" rel=\"noopener nofollow\" target=\"_blank\"><img alt=\"NuGet\" class=\"lazyload\" /></a></td>\n</tr>\n<tr>\n<td>JYPPX.DeploySharp.OpenCvSharp</td>\n<td>使用 OpenCvSharp 的图像处理扩展</td>\n<td><a href=\"https://www.nuget.org/packages/JYPPX.DeploySharp.OpenCvSharp/\" rel=\"noopener nofollow\" target=\"_blank\"><img alt=\"NuGet\" class=\"lazyload\" /></a></td>\n</tr>\n</tbody>\n</table>\n<p><strong>扩展包功能</strong>：</p>\n<ul>\n<li>图像加载和保存</li>\n<li>图像预处理实现</li>\n<li>可视化功能实现</li>\n<li>批量处理支持</li>\n</ul>\n<h3 id=\"5--模型支持列表\">5.  模型支持列表</h3>\n<p>截至目前，DeploySharp 已经完成了以下模型的封装，更多模型持续更新中：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">Model Name</th>\n<th style=\"text-align: center;\">Model Type</th>\n<th style=\"text-align: center;\">OpenVINO</th>\n<th style=\"text-align: center;\">ONNX Runtime</th>\n<th style=\"text-align: center;\">TensorRT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv5</strong></td>\n<td style=\"text-align: center;\">Detection</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv5</strong></td>\n<td style=\"text-align: center;\">Segmentation</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv6</strong></td>\n<td style=\"text-align: center;\">Detection</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv7</strong></td>\n<td style=\"text-align: center;\">Detection</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv8</strong></td>\n<td style=\"text-align: center;\">Detection</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv8</strong></td>\n<td style=\"text-align: center;\">Segmentation</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv8</strong></td>\n<td style=\"text-align: center;\">Pose</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv8</strong></td>\n<td style=\"text-align: center;\">Oriented Bounding Boxes</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv9</strong></td>\n<td style=\"text-align: center;\">Detection</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv9</strong></td>\n<td style=\"text-align: center;\">Segmentation</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv10</strong></td>\n<td style=\"text-align: center;\">Detection</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv11</strong></td>\n<td style=\"text-align: center;\">Detection</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv11</strong></td>\n<td style=\"text-align: center;\">Segmentation</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv11</strong></td>\n<td style=\"text-align: center;\">Pose</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv11</strong></td>\n<td style=\"text-align: center;\">Oriented Bounding Boxes</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLOv12</strong></td>\n<td style=\"text-align: center;\">Detection</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>Anomalib</strong></td>\n<td style=\"text-align: center;\">Segmentation</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>PP-YOLOE</strong></td>\n<td style=\"text-align: center;\">Detection</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>DEIMv2</strong></td>\n<td style=\"text-align: center;\">Detection</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>RFDETR</strong></td>\n<td style=\"text-align: center;\">Detection</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>RFDETR</strong></td>\n<td style=\"text-align: center;\">Segmentation</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>RTDETR</strong></td>\n<td style=\"text-align: center;\">Detection</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLO26</strong></td>\n<td style=\"text-align: center;\">Detection</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLO26</strong></td>\n<td style=\"text-align: center;\">Segmentation</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLO26</strong></td>\n<td style=\"text-align: center;\">Pose</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><strong>YOLO26</strong></td>\n<td style=\"text-align: center;\">Oriented Bounding Boxes</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n<td style=\"text-align: center;\">✅</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二deploysharp-对-yolov26-的全面支持\">二、DeploySharp 对 YOLOv26 的全面支持</h2>\n<p>DeploySharp 框架为 YOLOv26 系列模型提供了全方位的支持，涵盖了目标检测、实例分割、姿态估计和旋转框检测四种主要任务类型。</p>\n<h3 id=\"21-支持的-yolov26-模型类型\">2.1 支持的 YOLOv26 模型类型</h3>\n<table>\n<thead>\n<tr>\n<th>模型类型</th>\n<th>功能描述</th>\n<th>枚举值</th>\n<th>配置类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>YOLOv26Det</td>\n<td>目标检测</td>\n<td><code>ModelType.YOLOv26Det</code></td>\n<td><code>Yolov26DetConfig</code></td>\n</tr>\n<tr>\n<td>YOLOv26Seg</td>\n<td>实例分割</td>\n<td><code>ModelType.YOLOv26Seg</code></td>\n<td><code>Yolov26SegConfig</code></td>\n</tr>\n<tr>\n<td>YOLOv26Pose</td>\n<td>人体姿态估计</td>\n<td><code>ModelType.YOLOv26Pose</code></td>\n<td><code>Yolov26PoseConfig</code></td>\n</tr>\n<tr>\n<td>YOLOv26Obb</td>\n<td>旋转框检测</td>\n<td><code>ModelType.YOLOv26Obb</code></td>\n<td><code>Yolov26ObbConfig</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"22-架构设计\">2.2 架构设计</h3>\n<p>DeploySharp 为 YOLOv26 提供了三层架构设计：</p>\n<h4 id=\"接口层-iyolov26xxxmodel\">接口层 (IYolov26XxxModel)</h4>\n<p>在核心库 <code>DeploySharp</code> 中定义了统一的接口：</p>\n<pre><code class=\"language-csharp\">// YOLOv26 检测接口\n// IYolov26DetModel 继承自 IYolov10DetModel\n// 这种设计使得 YOLOv26 可以复用 YOLOv10 的成熟实现\npublic abstract class IYolov26DetModel : IYolov10DetModel\n{\n    /// &lt;summary&gt;\n    /// 构造函数，接收模型配置\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"config\"&gt;YOLOv26 检测模型配置对象&lt;/param&gt;\n    public IYolov26DetModel(Yolov26DetConfig config) : base(config)\n    {\n        // 使用日志系统记录模型初始化信息\n        MyLogger.Log.Info($\"Initializing {this.GetType().Name}, Config:\\n{config}\");\n    }\n}\n</code></pre>\n<h4 id=\"配置层-yolov26xxxconfig\">配置层 (Yolov26XxxConfig)</h4>\n<p>每种模型类型都有对应的配置类，提供灵活的参数设置：</p>\n<pre><code class=\"language-csharp\">// YOLOv26 检测配置类\n// 继承自 Yolov10DetConfig，复用 YOLOv10 的成熟配置\npublic class Yolov26DetConfig : Yolov10DetConfig\n{\n    /// &lt;summary&gt;\n    /// 默认构造函数\n    /// &lt;/summary&gt;\n    public Yolov26DetConfig() { }\n\n    /// &lt;summary&gt;\n    /// 带模型路径的构造函数\n    /// 自动设置合理的默认参数\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"modelPath\"&gt;模型文件路径&lt;/param&gt;\n    public Yolov26DetConfig(string modelPath)\n    {\n\t\t...\n    }\n}\n</code></pre>\n<h4 id=\"实现层-yolov26xxxmodel\">实现层 (Yolov26XxxModel)</h4>\n<p>分别提供 ImageSharp 和 OpenCvSharp 两种实现，开发者可以根据需求选择。</p>\n<h3 id=\"23-类继承关系图\">2.3 类继承关系图</h3>\n<pre><code>YoloDetConfig (基类)\n    ├── Yolov8DetConfig\n    ├── Yolov10DetConfig\n    └── Yolov26DetConfig (继承自 Yolov10DetConfig)\n\nYoloModel (基类)\n    ├── Yolov8DetModel\n    ├── Yolov10DetModel\n    └── Yolov26DetModel (继承自 Yolov10DetModel)\n</code></pre>\n<p>这种继承设计的优势：</p>\n<ol>\n<li><strong>代码复用</strong>：YOLOv26 可以复用 YOLOv10 的成熟实现</li>\n<li><strong>一致性</strong>：保持与其他 YOLO 版本的 API 一致性</li>\n<li><strong>易维护</strong>：共享的代码逻辑集中管理</li>\n</ol>\n<h2 id=\"三yolov26-目标检测代码实现\">三、YOLOv26 目标检测代码实现</h2>\n<h3 id=\"31-使用-imagesharp-作为图像处理库--tensorrt-推理后端\">3.1 使用 ImageSharp 作为图像处理库 + TensorRT 推理后端</h3>\n<h4 id=\"1nuget-包安装\">（1）NuGet 包安装</h4>\n<p>使用 ImageSharp 作为图像处理库、TensorRT 作为推理后端时，需要安装以下核心包：</p>\n<p><strong>DeploySharp 基础库及扩展库</strong>：</p>\n<pre><code>JYPPX.DeploySharp\nJYPPX.DeploySharp.ImageSharp\n</code></pre>\n<p><strong>TensorRT Runtime 库</strong>：</p>\n<pre><code>JYPPX.TensorRT.CSharp.API.runtime.win-x64.cuda11\n或\nJYPPX.TensorRT.CSharp.API.runtime.win-x64.cuda12\n</code></pre>\n<p><strong>注意</strong>：TensorRT Runtime 库的版本需根据本地设备安装的 CUDA 版本进行选择。</p>\n<h4 id=\"2代码实现\">（2）代码实现</h4>\n<p>以下代码可直接复制运行：</p>\n<pre><code class=\"language-csharp\">using DeploySharp.Model;       // 引入模型相关定义\nusing DeploySharp.Data;        // 引入数据处理相关\nusing DeploySharp.Engine;      // 引入推理引擎核心\nusing DeploySharp;             // 引入 DeploySharp 主库\nusing SixLabors.ImageSharp;    // ImageSharp 图像处理库\nusing SixLabors.ImageSharp.PixelFormats; // ImageSharp 像素格式\n\nnamespace DeploySharp.ImageSharp.Demo\n{\n    /// &lt;summary&gt;\n    /// YOLO26目标检测演示类\n    /// 该类展示了如何加载 TensorRT 引擎文件，对图像进行推理并可视化结果。\n    /// &lt;/summary&gt;\n    public class YOLOv26DetDemo\n    {\n        public static void Run()\n        {\n            // ==========================================\n            // 1. 路径配置\n            // ==========================================\n            \n            // 模型下载提示：模型和测试图片可以前往QQ群(945057948)下载\n            // 设置 .engine 文件路径。\n            // 注意：TensorRT 的 .engine 文件是硬件相关的，即在 RTX 3090 上生成的 engine 通常不能在 RTX 4090 上运行。\n            string modelPath = @\"D:\\Program Files\\TensorRT-10.13.0.35-cu11\\bin\\yolo26s.engine\";\n            \n            // 设置待推理的图片路径\n            string imagePath = @\"E:\\Data\\image\\bus.jpg\";\n            // ==========================================\n            // 2. 模型配置初始化\n            // ==========================================\n            \n            // 创建  YOLO26 的配置对象，传入模型路径\n            Yolov26DetConfig config = new Yolov26DetConfig(modelPath);\n            \n            // 设置最大批处理大小。\n            // 即使只推理一张图片，设置适当的 BatchSize 有时也能利用 GPU 并行能力。\n            // 此处设为 2 表示引擎内部最大可以一次处理 2 张图，但要首先保证模型支持。\n            config.MaxBatchSize = 2;\n            \n            // 显式指定推理后端为 TensorRT。\n            // DeploySharp 支持多种后端（如 ONNX Runtime, OpenVINO 等），这里强制使用 TensorRT 以获得最佳性能。\n            config.SetTargetInferenceBackend(InferenceBackend.TensorRT);\n            // ==========================================\n            // 3. 类别字典定义\n            // ==========================================\n            \n            // COCO 数据集的 80 个类别名称列表\n            // YOLO 模型通常输出的是类别的索引（0-79），我们需要将其映射为人类可读的字符串。\n            List&lt;string&gt; d = new List&lt;string&gt; { \"person\", \"bicycle\", \"car\", \"motorcycle\", \"airplane\", \"bus\",\n                \"train\", \"truck\", \"boat\", \"traffic light\", \"fire hydrant\", \"stop sign\", \"parking meter\", \"bench\",\n                \"bird\", \"cat\", \"dog\", \"horse\", \"sheep\", \"cow\", \"elephant\", \"bear\", \"zebra\", \"giraffe\", \"backpack\",\n                \"umbrella\", \"handbag\", \"tie\", \"suitcase\", \"frisbee\", \"skis\", \"snowboard\", \"sports ball\", \"kite\",\n                \"baseball bat\", \"baseball glove\", \"skateboard\", \"surfboard\", \"tennis racket\", \"bottle\", \"wine glass\",\n                \"cup\", \"fork\", \"knife\", \"spoon\", \"bowl\", \"banana\", \"apple\", \"sandwich\", \"orange\", \"broccoli\", \"carrot\",\n                \"hot dog\", \"pizza\", \"donut\", \"cake\", \"chair\", \"couch\", \"potted plant\", \"bed\", \"dining table\", \"toilet\",\n                \"tv\", \"laptop\", \"mouse\", \"remote\", \"keyboard\", \"cell phone\", \"microwave\", \"oven\", \"toaster\", \"sink\",\n                \"refrigerator\", \"book\", \"clock\", \"vase\", \"scissors\", \"teddy bear\", \"hair drier\", \"toothbrush\" };\n            // 将列表转换为字典，Key 为索引，Value 为类别名称\n            Dictionary&lt;int, string&gt; CategoryDict = new Dictionary&lt;int, string&gt;();\n            for (int i = 0; i &lt; d.Count; i++)\n            {\n                CategoryDict[i] = d[i];\n            }\n            \n            // 将类别字典赋值给配置对象，用于后续结果解析\n            config.CategoryDict = CategoryDict;\n            // ==========================================\n            // 4. 模型实例化\n            // ==========================================\n            \n            // 根据配置初始化检测器模型。\n            // 此步骤会加载 engine 文件到内存，并初始化 GPU 上下文。\n            Yolov26DetModel model = new Yolov26DetModel(config);\n            \n            // 使用 SixLabors.ImageSharp 加载图片。\n            // Image.Load 会自动根据文件扩展名解码图片。\n            var img = Image.Load(imagePath);\n            // ==========================================\n            // 5. 模型推理与性能测试\n            // ==========================================\n            \n            // 执行第一次推理。\n            // 注意：TensorRT 的首次推理通常包含 Kernel 初始化等开销，速度会比后续推理慢。\n            DetResult[] result = model.Predict(img);\n            \n            // 执行第二次推理。\n            // 这次推理的时间更能代表模型在实际场景中的平均推理速度。\n            result = model.Predict(img);\n            \n            // 执行第三次推理（可选），用于进一步取平均值或确保稳定性。\n            result = model.Predict(img);\n            \n            // 打印推理性能分析记录。\n            // 这通常会输出预处理、推理、后端处理各阶段的耗时（毫秒级）。\n            model.ModelInferenceProfiler.PrintAllRecords();\n            \n            // 初始化一个列表，虽然本例未直接使用，但在处理多图结果时可能会用到。\n            List&lt;Image&lt;Rgb24&gt;&gt; resultsMat = new List&lt;Image&lt;Rgb24&gt;&gt;();\n            // ==========================================\n            // 6. 结果可视化与保存\n            // ==========================================\n            \n            // 将推理结果绘制在原图上。\n            // Visualize.DrawDetResult 会根据 DetResult 中的坐标和置信度画框和文字。\n            // 需要将 img 强制转换为 Image&lt;Rgb24&gt;，因为 DrawDetResult 通常需要特定的像素格式。\n            var resultImg = Visualize.DrawDetResult(result, (Image&lt;Rgb24&gt;)img, new VisualizeOptions(1.0f));\n            // 保存带有检测框的图片到当前目录下。\n            // 文件名包含配置的模型类型，便于区分不同模型的结果。\n            resultImg.Save(@$\"./result_{config.ModelType}.jpg\");\n        }\n    }\n}\n</code></pre>\n<h4 id=\"3代码详解\">（3）代码详解</h4>\n<ol>\n<li>\n<p><strong>配置模型参数</strong>：</p>\n<pre><code class=\"language-csharp\">Yolov26DetConfig config = new Yolov26DetConfig(modelPath);\nconfig.MaxBatchSize = 2;\nconfig.SetTargetInferenceBackend(InferenceBackend.TensorRT);\n</code></pre>\n<ul>\n<li>创建配置对象，使用 TensorRT 引擎进行推理</li>\n<li>设置最大批量大小为 2，支持最多 2 张图片的批量推理</li>\n</ul>\n</li>\n<li>\n<p><strong>创建模型实例</strong>：</p>\n<pre><code class=\"language-csharp\">Yolov26DetModel model = new Yolov26DetModel(config);\n</code></pre>\n<p>模型实例化时会自动加载 .engine 文件并初始化 TensorRT 引擎。</p>\n</li>\n<li>\n<p><strong>执行推理</strong>：</p>\n<pre><code class=\"language-csharp\">DetResult[] result = model.Predict(img);\n</code></pre>\n<p><code>Predict()</code> 方法返回检测结果数组，每个元素包含边界框、置信度和类别信息。</p>\n</li>\n<li>\n<p><strong>性能分析</strong>：</p>\n<pre><code class=\"language-csharp\">model.ModelInferenceProfiler.PrintAllRecords();\n</code></pre>\n<p>打印详细的性能统计，包括预处理、推理、后处理各阶段的耗时。</p>\n</li>\n</ol>\n<h4 id=\"4结果展示\">（4）结果展示</h4>\n<p>控制台打印输出：</p>\n<p><img alt=\"image-20260116231024791\" class=\"lazyload\" /></p>\n<p>推理结果图片：</p>\n<p><img alt=\"result_YOLOv26Det\" class=\"lazyload\" /></p>\n<h3 id=\"32-使用-opencvsharp做图像处理库onnx-runtime推理后端\">3.2 使用 OpenCvSharp做图像处理库+ONNX Runtime推理后端</h3>\n<h4 id=\"1nuget-包安装-1\">（1）NuGet 包安装</h4>\n<p>使用 OpenCvSharp 作为图像处理库、ONNX Runtime 作为推理后端时，需要安装以下核心包：</p>\n<p><strong>DeploySharp 基础库及扩展库</strong>：</p>\n<pre><code>JYPPX.DeploySharp\nJYPPX.DeploySharp.OpenCvSharp\n</code></pre>\n<p><strong>OpenCvSharp Runtime 库</strong>：</p>\n<pre><code>OpenCvSharp4.runtime.win\n</code></pre>\n<p><strong>可选加速包</strong>：ONNX Runtime 支持多种推理加速方式，除默认 CPU 加速外，可根据需求安装以下 NuGet 包：</p>\n<table>\n<thead>\n<tr>\n<th>加速方式</th>\n<th>NuGet 包名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OpenVINO 加速</td>\n<td>Intel.ML.OnnxRuntime.OpenVino</td>\n</tr>\n<tr>\n<td>DirectML 加速</td>\n<td>Microsoft.AI.DirectML</td>\n</tr>\n<tr>\n<td>CUDA 加速</td>\n<td>Microsoft.ML.OnnxRuntime.Gpu</td>\n</tr>\n</tbody>\n</table>\n<p>更多加速方式请参考 ONNX Runtime 官方文档。本节以 DirectML 为例进行演示。</p>\n<h4 id=\"2代码实现-1\">（2）代码实现</h4>\n<p>推理代码如下所示，可直接复制运行：</p>\n<pre><code class=\"language-csharp\">using OpenCvSharp;            // 引入 OpenCvSharp，用于图像的读取、显示和矩阵操作\nusing DeploySharp.Model;      // 引入模型定义和配置类\nusing DeploySharp.Data;       // 引入数据处理相关的类\nusing DeploySharp.Engine;     // 引入推理引擎核心接口和枚举\nusing DeploySharp;            // 引入 DeploySharp 主库和可视化工具\nnamespace DeploySharp.OpenCvSharp.Demo\n{\n    /// &lt;summary&gt;\n    ///  YOLO26 目标检测演示 (基于 ONNX Runtime + OpenCvSharp)\n    /// 本示例展示了如何加载 ONNX 模型，并配置使用 DirectML 在 GPU 上进行推理。\n    /// &lt;/summary&gt;\n    public class Yolov26DetDemo\n    {\n        public static void Run()\n        {\n            // ==========================================\n            // 1. 路径配置\n            // ==========================================\n            \n            // 模型下载提示：模型和测试图片可以前往QQ群(945057948)下载\n            // 注意：此处加载的是标准的 .onnx 模型文件，而不是 TensorRT 的 .engine 文件。\n            // ONNX 模型具有良好的跨平台特性。\n            string modelPath = @\"E:\\Model\\yolov28\\yolo26s.onnx\";\n            \n            // 设置待检测的图片路径\n            string imagePath = @\"E:\\Data\\image\\bus.jpg\";\n            // ==========================================\n            // 2. 模型配置与推理后端设置\n            // ==========================================\n            \n            // 创建  YOLO26 的配置对象，传入模型路径\n            Yolov26DetConfig config = new Yolov26DetConfig(modelPath);\n            \n            // [关键步骤] 设置推理后端为 ONNX Runtime。\n            // 这意味着模型将通过 ONNX Runtime 进行加载和执行，而不是 TensorRT。\n            config.SetTargetInferenceBackend(InferenceBackend.OnnxRuntime);\n            \n            // 设置目标设备类型为 GPU 0。\n            // 这是一个逻辑设定，具体执行取决于 ONNX Runtime 的提供程序。\n            config.SetTargetDeviceType(DeviceType.GPU0);\n            \n            // [关键步骤] 设置 ONNX Runtime 的具体执行提供程序为 DML (DirectML)。\n            // DirectML 是 Windows 上的高性能硬件加速接口，支持 AMD、NVIDIA 和 Intel 显卡。\n            // 如果不加这一行，ONNX Runtime 可能默认使用 CPU 进行推理，速度较慢。\n            config.SetTargetOnnxRuntimeDeviceType(OnnxRuntimeDeviceType.DML);\n            // ==========================================\n            // 3. 类别字典定义 (COCO 80类)\n            // ==========================================\n            \n            // 定义 COCO 数据集的 80 个类别名称\n            // 这些名称将用于在结果可视化时标注检测到的物体\n            List&lt;string&gt; d = new List&lt;string&gt; { \"person\", \"bicycle\", \"car\", \"motorcycle\", \"airplane\", \"bus\",\n                \"train\", \"truck\", \"boat\", \"traffic light\", \"fire hydrant\", \"stop sign\", \"parking meter\", \"bench\",\n                \"bird\", \"cat\", \"dog\", \"horse\", \"sheep\", \"cow\", \"elephant\", \"bear\", \"zebra\", \"giraffe\", \"backpack\",\n                \"umbrella\", \"handbag\", \"tie\", \"suitcase\", \"frisbee\", \"skis\", \"snowboard\", \"sports ball\", \"kite\",\n                \"baseball bat\", \"baseball glove\", \"skateboard\", \"surfboard\", \"tennis racket\", \"bottle\", \"wine glass\",\n                \"cup\", \"fork\", \"knife\", \"spoon\", \"bowl\", \"banana\", \"apple\", \"sandwich\", \"orange\", \"broccoli\", \"carrot\",\n                \"hot dog\", \"pizza\", \"donut\", \"cake\", \"chair\", \"couch\", \"potted plant\", \"bed\", \"dining table\", \"toilet\",\n                \"tv\", \"laptop\", \"mouse\", \"remote\", \"keyboard\", \"cell phone\", \"microwave\", \"oven\", \"toaster\", \"sink\",\n                \"refrigerator\", \"book\", \"clock\", \"vase\", \"scissors\", \"teddy bear\", \"hair drier\", \"toothbrush\" };\n            // 构建&lt;索引, 类别名&gt;字典\n            Dictionary&lt;int, string&gt; CategoryDict = new Dictionary&lt;int, string&gt;();\n            for (int i = 0; i &lt; d.Count; i++)\n            {\n                CategoryDict[i] = d[i];\n            }\n            \n            // 将类别字典赋值给配置对象\n            config.CategoryDict = CategoryDict;\n            // ==========================================\n            // 4. 模型初始化\n            // ==========================================\n            \n            // 实例化模型，传入配置。\n            // 此时 DeploySharp 会根据配置加载 ONNX 模型，并初始化 DirectML 会话。\n            Yolov26DetModel model = new Yolov26DetModel(config);\n            \n            // 使用 OpenCvSharp 读取图片到 Mat 对象中\n            // Mat 是 OpenCV 中用于存储图像数据的核心矩阵结构\n            Mat img = Cv2.ImRead(imagePath);\n            // ==========================================\n            // 5. 模型推理 (预热与测试)\n            // ==========================================\n            \n            // 执行多次推理。\n            // 第一次推理通常包含模型加载、内存分配等初始化开销，耗时较长。\n            Result[] result = model.Predict(img);\n            \n            // 后续推理用于测试稳定的推理速度。\n            result = model.Predict(img);\n            result = model.Predict(img);\n            result = model.Predict(img);\n            \n            // 打印性能分析记录。\n            // 这将输出推理过程中各阶段（如预处理、推理执行、后处理）的耗时统计。\n            model.ModelInferenceProfiler.PrintAllRecords();\n            \n            // 初始化列表，用于存储处理后的图像（本例主要用于演示）\n            List&lt;Mat&gt; resultsMat = new List&lt;Mat&gt;();\n            // ==========================================\n            // 6. 结果可视化与显示\n            // ==========================================\n            \n            // 调用可视化工具，将检测框（矩形框）和类别标签绘制在原图上。\n            // VisualizeOptions(1.0f) 可能指定了缩放比例或字体大小等参数。\n            var resultImg = Visualize.DrawDetResult(result, img, new VisualizeOptions(1.0f));\n            \n            // 将绘制好的图像加入列表\n            resultsMat.Add(resultImg);\n            \n            // 使用 OpenCV 的窗口显示结果图像。\n            // \"image\" 是窗口的标题。\n            Cv2.ImShow(\"image\", resultImg);\n            \n            // 等待按键输入。\n            // 参数 0 表示无限期等待，直到用户按下键盘任意键。\n            // 这是为了防止控制台程序执行完毕后窗口立即闪退。\n            Cv2.WaitKey();\n        }\n    \n    }\n}\n</code></pre>\n<h4 id=\"3代码详解-1\">（3）代码详解</h4>\n<p>上述代码与 3.1 节的代码结构基本相似，主要区别在于推理后端的配置：</p>\n<ol>\n<li>\n<p><strong>设置推理后端为 ONNX Runtime</strong>：</p>\n<pre><code class=\"language-csharp\">config.SetTargetInferenceBackend(InferenceBackend.OnnxRuntime);\n</code></pre>\n</li>\n<li>\n<p><strong>设置推理设备为 GPU</strong>（此处使用独显设备）：</p>\n<pre><code class=\"language-csharp\">config.SetTargetDeviceType(DeviceType.GPU0);\n</code></pre>\n</li>\n<li>\n<p><strong>配置 DirectML 加速</strong>：DirectML 是 Windows 上的高性能硬件加速接口，支持 AMD、NVIDIA 和 Intel 显卡，使用简单且无需复杂配置。</p>\n<pre><code class=\"language-csharp\">config.SetTargetOnnxRuntimeDeviceType(OnnxRuntimeDeviceType.DML);\n</code></pre>\n</li>\n</ol>\n<h4 id=\"4结果展示-1\">（4）结果展示</h4>\n<p>控制台输出如下。使用 DirectML 调用显卡加速，虽在速度上与 TensorRT 相比有所差距，但其配置简单、无需复杂设置的优势依然明显，适合快速开发验证。</p>\n<p><img alt=\"image-20260116221718516\" class=\"lazyload\" /></p>\n<h3 id=\"33-使用-opencvsharp-作为图像处理库--openvino-推理后端\">3.3 使用 OpenCvSharp 作为图像处理库 + OpenVINO 推理后端</h3>\n<h4 id=\"1nuget-包安装-2\">（1）NuGet 包安装</h4>\n<p>使用 OpenCvSharp 作为图像处理库、OpenVINO 作为推理后端时，需要安装以下核心包：</p>\n<p><strong>DeploySharp 基础库及扩展库</strong>：</p>\n<pre><code>JYPPX.DeploySharp\nJYPPX.DeploySharp.OpenCvSharp\n</code></pre>\n<p><strong>Runtime 库</strong>：</p>\n<pre><code>OpenCvSharp4.runtime.win\nOpenVINO.runtime.win\n</code></pre>\n<h4 id=\"2代码实现-2\">（2）代码实现</h4>\n<p>推理代码如下所示，可直接复制运行：</p>\n<pre><code class=\"language-csharp\">using OpenCvSharp;            // 引入 OpenCvSharp，用于图像的读取、显示和矩阵操作\nusing DeploySharp.Model;      // 引入模型定义和配置类\nusing DeploySharp.Data;       // 引入数据处理相关的类\nusing DeploySharp.Engine;     // 引入推理引擎核心接口和枚举\nusing DeploySharp;            // 引入 DeploySharp 主库和可视化工具\nnamespace DeploySharp.OpenCvSharp.Demo\n{\n    /// &lt;summary&gt;\n    ///  YOLO26 目标检测演示 (基于OpenVINO  + OpenCvSharp)\n    /// &lt;/summary&gt;\n    public class Yolov26DetDemo\n    {\n        public static void Run()\n        {\n            // ==========================================\n            // 1. 路径配置\n            // ==========================================\n            \n            // 模型下载提示：模型和测试图片可以前往QQ群(945057948)下载\n            // 注意：此处加载的是标准的 .onnx 模型文件，而不是 TensorRT 的 .engine 文件。\n            // ONNX 模型具有良好的跨平台特性。\n            string modelPath = @\"E:\\Model\\yolov28\\yolo26s.onnx\";\n            \n            // 设置待检测的图片路径\n            string imagePath = @\"E:\\Data\\image\\bus.jpg\";\n            // ==========================================\n            // 2. 模型配置\n            // ==========================================\n            \n            // 创建 YOLO26Det 的配置对象，传入模型路径\n            Yolov26DetConfig config = new Yolov26DetConfig(modelPath);\n            \n            // ==========================================\n            // 3. 类别字典定义 (COCO 80类)\n            // ==========================================\n            \n            // 定义 COCO 数据集的 80 个类别名称\n            // 这些名称将用于在结果可视化时标注检测到的物体\n            List&lt;string&gt; d = new List&lt;string&gt; { \"person\", \"bicycle\", \"car\", \"motorcycle\", \"airplane\", \"bus\",\n                \"train\", \"truck\", \"boat\", \"traffic light\", \"fire hydrant\", \"stop sign\", \"parking meter\", \"bench\",\n                \"bird\", \"cat\", \"dog\", \"horse\", \"sheep\", \"cow\", \"elephant\", \"bear\", \"zebra\", \"giraffe\", \"backpack\",\n                \"umbrella\", \"handbag\", \"tie\", \"suitcase\", \"frisbee\", \"skis\", \"snowboard\", \"sports ball\", \"kite\",\n                \"baseball bat\", \"baseball glove\", \"skateboard\", \"surfboard\", \"tennis racket\", \"bottle\", \"wine glass\",\n                \"cup\", \"fork\", \"knife\", \"spoon\", \"bowl\", \"banana\", \"apple\", \"sandwich\", \"orange\", \"broccoli\", \"carrot\",\n                \"hot dog\", \"pizza\", \"donut\", \"cake\", \"chair\", \"couch\", \"potted plant\", \"bed\", \"dining table\", \"toilet\",\n                \"tv\", \"laptop\", \"mouse\", \"remote\", \"keyboard\", \"cell phone\", \"microwave\", \"oven\", \"toaster\", \"sink\",\n                \"refrigerator\", \"book\", \"clock\", \"vase\", \"scissors\", \"teddy bear\", \"hair drier\", \"toothbrush\" };\n            // 构建&lt;索引, 类别名&gt;字典\n            Dictionary&lt;int, string&gt; CategoryDict = new Dictionary&lt;int, string&gt;();\n            for (int i = 0; i &lt; d.Count; i++)\n            {\n                CategoryDict[i] = d[i];\n            }\n            \n            // 将类别字典赋值给配置对象\n            config.CategoryDict = CategoryDict;\n            // ==========================================\n            // 4. 模型初始化\n            // ==========================================\n            \n            // 实例化模型，传入配置。\n            // 此时 DeploySharp 会根据配置加载 ONNX 模型，并初始化 DirectML 会话。\n            Yolov26DetModel model = new Yolov26DetModel(config);\n            \n            // 使用 OpenCvSharp 读取图片到 Mat 对象中\n            // Mat 是 OpenCV 中用于存储图像数据的核心矩阵结构\n            Mat img = Cv2.ImRead(imagePath);\n            // ==========================================\n            // 5. 模型推理 (预热与测试)\n            // ==========================================\n            \n            // 执行多次推理。\n            // 第一次推理通常包含模型加载、内存分配等初始化开销，耗时较长。\n            Result[] result = model.Predict(img);\n            \n            // 后续推理用于测试稳定的推理速度。\n            result = model.Predict(img);\n            result = model.Predict(img);\n            result = model.Predict(img);\n            \n            // 打印性能分析记录。\n            // 这将输出推理过程中各阶段（如预处理、推理执行、后处理）的耗时统计。\n            model.ModelInferenceProfiler.PrintAllRecords();\n            \n            // 初始化列表，用于存储处理后的图像（本例主要用于演示）\n            List&lt;Mat&gt; resultsMat = new List&lt;Mat&gt;();\n            // ==========================================\n            // 6. 结果可视化与显示\n            // ==========================================\n            \n            // 调用可视化工具，将检测框（矩形框）和类别标签绘制在原图上。\n            // VisualizeOptions(1.0f) 可能指定了缩放比例或字体大小等参数。\n            var resultImg = Visualize.DrawDetResult(result, img, new VisualizeOptions(1.0f));\n            \n            // 将绘制好的图像加入列表\n            resultsMat.Add(resultImg);\n            \n            // 使用 OpenCV 的窗口显示结果图像。\n            // \"image\" 是窗口的标题。\n            Cv2.ImShow(\"image\", resultImg);\n            \n            // 等待按键输入。\n            // 参数 0 表示无限期等待，直到用户按下键盘任意键。\n            // 这是为了防止控制台程序执行完毕后窗口立即闪退。\n            Cv2.WaitKey();\n        }\n    \n    }\n}\n</code></pre>\n<h4 id=\"3代码详解-2\">（3）代码详解</h4>\n<p>上述代码与 3.2 节的代码结构基本相似。使用 OpenVINO 作为推理后端时，通常无需额外设置，因为 DeploySharp 默认支持 OpenVINO。</p>\n<p>若设备配备英特尔的集成显卡、独立显卡或 NPU，可通过以下代码指定推理设备以获得更好的性能：</p>\n<pre><code class=\"language-csharp\">config.SetTargetInferenceBackend(InferenceBackend.OpenVINO);\nconfig.SetTargetDeviceType(DeviceType.GPU0);   // 设置设备为集显\n// 或\nconfig.SetTargetDeviceType(DeviceType.GPU1);  // 设置推理设备为独立显卡\n// 或\nconfig.SetTargetDeviceType(DeviceType.NPU);  // 设置推理设备为 NPU\n</code></pre>\n<h4 id=\"4结果展示-2\">（4）结果展示</h4>\n<p>控制台输出如下。使用 OpenVINO 在 CPU 上进行推理时，虽因设备限制推理速度有限，但 OpenVINO 已是 CPU 环境下推理速度最快的工具之一，且配置简单，全面支持英特尔全系设备，欢迎开发者使用。</p>\n<p><img alt=\"image-20260116223936848\" class=\"lazyload\" /></p>\n<h2 id=\"四yolov26-实例分割\">四、YOLOv26 实例分割</h2>\n<h3 id=\"41-代码使用示例\">4.1 代码使用示例</h3>\n<pre><code class=\"language-csharp\">using OpenCvSharp;            // 引入 OpenCvSharp，用于图像读取、显示及矩阵操作\nusing DeploySharp.Model;      // 引入模型配置相关的类\nusing DeploySharp.Data;       // 引入数据结果定义相关的类\nusing DeploySharp.Engine;     // 引入推理引擎核心接口\nusing DeploySharp;            // 引入 DeploySharp 主库及可视化工具\n\nnamespace DeploySharp.OpenCvSharp.Demo\n{\n    /// &lt;summary&gt;\n    /// YOLO26Seg 实例分割演示类\n    /// 本示例展示如何加载 TensorRT 引擎文件，对图像进行实例分割推理，并将掩码绘制在原图上。\n    /// &lt;/summary&gt;\n    public class Yolov26SegDemo\n    {\n        public static void Run()\n        {\n            // ==========================================\n            // 1. 路径配置\n            // ==========================================\n            \n            // 模型下载提示：模型和测试图片可以前往QQ群(945057948)下载\n            // 设置 TensorRT 引擎文件路径。\n            // 注意：这里使用的是 .engine 文件，它是针对特定 GPU 和 TensorRT 版本编译的。\n            // 文件名中的 '-seg' 表示这是一个带有分割头的实例分割模型。\n            string modelPath = @\"D:\\Program Files\\TensorRT-10.13.0.35-cu11\\bin\\yolo26s-seg.engine\";\n            \n            // 设置待推理的图片路径\n            string imagePath = @\"E:\\Data\\image\\bus.jpg\";\n\n\n            // ==========================================\n            // 2. 模型配置与初始化\n            // ==========================================\n            \n            // 创建 YOLO26Seg (实例分割) 的配置对象，传入模型路径\n            Yolov26SegConfig config = new Yolov26SegConfig(modelPath);\n            \n            // [关键设置] 指定推理后端为 TensorRT。\n            // 利用 TensorRT 可以在 NVIDIA GPU 上获得极高的推理速度。\n            config.SetTargetInferenceBackend(InferenceBackend.TensorRT);\n            \n            // 实例化模型。\n            // 此时会加载引擎文件，初始化 GPU 显存上下文。\n            Yolov26SegModel model = new Yolov26SegModel(config);\n\n\n            // ==========================================\n            // 3. 图像加载\n            // ==========================================\n            \n            // 使用 OpenCvSharp 读取图片。\n            // img 是一个 Mat 对象，包含了图像的像素数据。\n            Mat img = Cv2.ImRead(imagePath);\n\n\n            // ==========================================\n            // 4. 模型推理 (预热与性能测试)\n            // ==========================================\n            \n            // 执行第一次推理。\n            // 首次运行通常包含模型加载、显存分配等开销，耗时较长。\n            var result = model.Predict(img);\n            \n            // 执行后续多次推理。\n            // 这是为了排除初始化开销，测试模型在稳定状态下的推理速度。\n            result = model.Predict(img);\n            result = model.Predict(img);\n            result = model.Predict(img);\n            \n            // 打印推理性能分析记录。\n            // 这将输出预处理、推理计算、后处理（包括掩码生成）各阶段的耗时。\n            model.ModelInferenceProfiler.PrintAllRecords();\n\n\n            // ==========================================\n            // 5. 结果可视化\n            // ==========================================\n            \n            // 调用可视化工具，绘制分割结果。\n            // 注意这里使用的是 DrawSegResult (绘制分割结果)，而不是 DrawDetResult (绘制检测框)。\n            // 该函数会将检测到的物体框、类别标签以及彩色的半透明掩码绘制在原图上。\n            var resultImg = Visualize.DrawSegResult(result, img, new VisualizeOptions(1.0f));\n            \n            // 使用 OpenCV 窗口显示渲染后的结果图像。\n            Cv2.ImShow(\"image\", resultImg);\n            \n            // 等待按键输入，防止窗口闪退。\n            Cv2.WaitKey();\n        }\n    }\n}\n\n</code></pre>\n<h3 id=\"42-代码详解\">4.2 代码详解</h3>\n<ol>\n<li>\n<p><strong>创建分割配置</strong>：</p>\n<pre><code class=\"language-csharp\">Yolov26SegConfig config = new Yolov26SegConfig(modelPath);\nconfig.SetTargetInferenceBackend(InferenceBackend.TensorRT);\n</code></pre>\n<p><code>Yolov26SegConfig</code> 是 YOLOv26 分割模型的配置类。</p>\n</li>\n<li>\n<p><strong>执行分割推理</strong>：</p>\n<pre><code class=\"language-csharp\">var result = model.Predict(img);\n</code></pre>\n<p>分割推理返回 <code>SegResult[]</code> 数组，每个元素包含边界框、置信度、类别和分割掩码。</p>\n</li>\n<li>\n<p><strong>可视化分割结果</strong>：</p>\n<pre><code class=\"language-csharp\">var resultImg = Visualize.DrawSegResult(result, img, new VisualizeOptions(1.0f));\n</code></pre>\n<p><code>DrawSegResult</code> 会为每个检测到的对象绘制不同颜色的掩码，叠加在原图上。</p>\n</li>\n</ol>\n<h3 id=\"43-分割结果展示\">4.3 分割结果展示</h3>\n<h4 id=\"控制台输出\">控制台输出</h4>\n<p>以下三张截图分别展示了在 TensorRT GPU、ONNX Runtime(DirectML) GPU、OpenVINO CPU 设备下的推理性能。不同引擎各有优势，开发者可根据自身硬件环境选择最适合的方案。</p>\n<p><strong>TensorRT GPU：</strong></p>\n<p><img alt=\"image-20260116231515663\" class=\"lazyload\" /></p>\n<p><strong>ONNX Runtime (DirectML) GPU：</strong></p>\n<p><img alt=\"image-20260116231805014\" class=\"lazyload\" /></p>\n<p><strong>OpenVINO CPU：</strong></p>\n<p><img alt=\"image-20260116231630904\" class=\"lazyload\" /></p>\n<h4 id=\"推理结果绘制\">推理结果绘制</h4>\n<p>下图为官方预训练模型导出后的推理结果示例：</p>\n<p><img alt=\"image-20260116231431298\" class=\"lazyload\" /></p>\n<h2 id=\"五yolov26-人体姿态估计\">五、YOLOv26 人体姿态估计</h2>\n<h3 id=\"51-功能介绍\">5.1 功能介绍</h3>\n<p>YOLO26 Pose 模型用于检测人体关键点，通常支持 17 个关键点（头部、颈部、肩膀、手肘、手腕、臀部、膝盖、脚踝等）。</p>\n<p><strong>关键点定义</strong>（COCO 格式）：</p>\n<table>\n<thead>\n<tr>\n<th>关键点</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>nose</td>\n<td>鼻子</td>\n</tr>\n<tr>\n<td>1</td>\n<td>left_eye</td>\n<td>左眼</td>\n</tr>\n<tr>\n<td>2</td>\n<td>right_eye</td>\n<td>右眼</td>\n</tr>\n<tr>\n<td>3</td>\n<td>left_ear</td>\n<td>左耳</td>\n</tr>\n<tr>\n<td>4</td>\n<td>right_ear</td>\n<td>右耳</td>\n</tr>\n<tr>\n<td>5</td>\n<td>left_shoulder</td>\n<td>左肩</td>\n</tr>\n<tr>\n<td>6</td>\n<td>right_shoulder</td>\n<td>右肩</td>\n</tr>\n<tr>\n<td>7</td>\n<td>left_elbow</td>\n<td>左肘</td>\n</tr>\n<tr>\n<td>8</td>\n<td>right_elbow</td>\n<td>右肘</td>\n</tr>\n<tr>\n<td>9</td>\n<td>left_wrist</td>\n<td>左腕</td>\n</tr>\n<tr>\n<td>10</td>\n<td>right_wrist</td>\n<td>右腕</td>\n</tr>\n<tr>\n<td>11</td>\n<td>left_hip</td>\n<td>左髋</td>\n</tr>\n<tr>\n<td>12</td>\n<td>right_hip</td>\n<td>右髋</td>\n</tr>\n<tr>\n<td>13</td>\n<td>left_knee</td>\n<td>左膝</td>\n</tr>\n<tr>\n<td>14</td>\n<td>right_knee</td>\n<td>右膝</td>\n</tr>\n<tr>\n<td>15</td>\n<td>left_ankle</td>\n<td>左踝</td>\n</tr>\n<tr>\n<td>16</td>\n<td>right_ankle</td>\n<td>右踝</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"52-代码使用示例\">5.2 代码使用示例</h3>\n<pre><code class=\"language-csharp\">using OpenCvSharp;            // 引入 OpenCvSharp，用于图像的读取、显示和矩阵操作\nusing DeploySharp.Model;      // 引入模型定义和配置类\nusing DeploySharp.Data;       // 引入数据结果相关的类\nusing DeploySharp.Engine;     // 引入推理引擎核心接口\nusing DeploySharp;            // 引入 DeploySharp 主库和可视化工具\nusing System;                 // 引入 System 命名空间以使用 Console\n\nnamespace DeploySharp.OpenCvSharp.Demo\n{\n    /// &lt;summary&gt;\n    /// YOLO26Pose 姿态估计演示类\n    /// 本示例展示了如何加载 ONNX 模型进行人体关键点检测，并可视化骨骼连接。\n    /// &lt;/summary&gt;\n    public class Yolov26PoseDemo\n    {\n        public static void Run()\n        {\n            // ==========================================\n            // 1. 路径配置\n            // ==========================================\n            \n            // 模型下载提示：模型和测试图片可以前往QQ群(945057948)下载\n            // 设置 ONNX 模型文件路径。\n            // '-pose' 后缀表示这是一个专门用于姿态估计（关键点检测）的模型。\n            string modelPath = @\"E:\\Model\\yolov28\\yolo26s-pose.onnx\";\n            \n            // 设置待推理的图片路径\n            string imagePath = @\"E:\\Data\\image\\demo_9.jpg\";\n\n\n            // ==========================================\n            // 2. 模型配置与初始化\n            // ==========================================\n            \n            // 创建 YOLO26Pose (姿态估计) 的配置对象，传入模型路径\n            Yolov26PoseConfig config = new Yolov26PoseConfig(modelPath);\n            \n            // [关键设置] 设置推理后端为 ONNX Runtime。\n            // 这使得模型可以跨平台运行，不仅限于 NVIDIA GPU（取决于 ONNX Runtime 的安装提供程序）。\n            config.SetTargetInferenceBackend(InferenceBackend.OnnxRuntime);\n            \n            // 实例化姿态估计模型。\n            // 模型加载时会解析 ONNX 图结构，准备好输入输出节点。\n            Yolov26PoseModel model = new Yolov26PoseModel(config);\n\n\n            // ==========================================\n            // 3. 图像加载\n            // ==========================================\n            \n            // 使用 OpenCvSharp 读取图片。\n            Mat img = Cv2.ImRead(imagePath);\n\n\n            // ==========================================\n            // 4. 模型推理与结果查看\n            // ==========================================\n            \n            // 执行推理。\n            // 第一次推理通常较慢，包含初始化开销。\n            var result = model.Predict(img);\n            \n            // 执行多次推理以测试稳定状态下的性能。\n            result = model.Predict(img);\n            result = model.Predict(img);\n            result = model.Predict(img);\n            \n            // 打印第一个结果的详细信息到控制台。\n            // 姿态估计的 Result 对象通常包含检测框信息以及一个关键点数组。\n            // 这一行有助于开发者调试，查看模型输出的原始数据结构。\n            Console.WriteLine(result[0].ToString());\n            \n            // 打印性能分析记录，查看各阶段耗时。\n            model.ModelInferenceProfiler.PrintAllRecords();\n\n\n            // ==========================================\n            // 5. 结果可视化\n            // ==========================================\n            \n            // 调用可视化工具，绘制姿态估计结果。\n            // 注意这里使用的是 DrawPoses，它会自动将识别出的关键点（如眼睛、肩膀、肘部等）\n            // 用圆点标出，并根据人体结构连接成骨架。\n            // VisualizeOptions(1.0f) 可能指定了绘制时的线条粗细或字体缩放比例。\n            var resultImg = Visualize.DrawPoses(result, img, new VisualizeOptions(1.0f));\n            \n            // 显示结果图像。\n            Cv2.ImShow(\"image\", resultImg);\n            \n            // 等待按键，防止窗口闪退。\n            Cv2.WaitKey();\n        }\n    }\n}\n\n</code></pre>\n<h3 id=\"53-代码详解\">5.3 代码详解</h3>\n<ol>\n<li>\n<p><strong>创建姿态估计配置</strong>：</p>\n<pre><code class=\"language-csharp\">Yolov26PoseConfig config = new Yolov26PoseConfig(modelPath);\nconfig.SetTargetInferenceBackend(InferenceBackend.OnnxRuntime);\n</code></pre>\n<p><code>Yolov26PoseConfig</code> 是 YOLOv26 姿态估计模型的配置类。</p>\n</li>\n<li>\n<p><strong>执行姿态估计推理</strong>：</p>\n<pre><code class=\"language-csharp\">var result = model.Predict(img);\n</code></pre>\n<p>姿态估计推理返回 <code>KeyPointResult[]</code> 数组，每个元素包含人体边界框、置信度和 17 个关键点坐标。</p>\n</li>\n<li>\n<p><strong>可视化姿态估计结果</strong>：</p>\n<pre><code class=\"language-csharp\">var resultImg = Visualize.DrawPoses(result, img, new VisualizeOptions(1.0f));\n</code></pre>\n<p><code>DrawPoses</code> 会绘制人体骨架（连接关键点）和关键点标记。</p>\n</li>\n</ol>\n<h3 id=\"54-结果展示\">5.4 结果展示</h3>\n<h4 id=\"控制台输出-1\">控制台输出</h4>\n<p>以下截图展示了在 ONNX Runtime CPU 设备下的推理性能：</p>\n<p><img alt=\"image-20260116232926313\" class=\"lazyload\" /></p>\n<h4 id=\"推理结果绘制-1\">推理结果绘制</h4>\n<p>下图为官方预训练模型导出后的推理结果示例：</p>\n<p><img alt=\"image-20260116232942723\" class=\"lazyload\" /></p>\n<h2 id=\"六yolov26-旋转框检测\">六、YOLOv26 旋转框检测</h2>\n<p>YOLOv26 OBB (Oriented Bounding Box) 模型用于检测旋转物体，生成带有旋转角度的边界框。这对于检测航空影像中的建筑物、遥感图像中的车辆等场景非常重要。</p>\n<h3 id=\"61-代码使用示例\">6.1 代码使用示例</h3>\n<p>以下代码演示如何使用 TensorRT 引擎进行旋转目标检测：</p>\n<pre><code class=\"language-csharp\">using OpenCvSharp;            // 引入 OpenCvSharp，用于图像读取、显示及绘图\nusing DeploySharp.Model;      // 引入模型配置相关的类\nusing DeploySharp.Data;       // 引入数据结果定义相关的类\nusing DeploySharp.Engine;     // 引入推理引擎核心接口\nusing DeploySharp;            // 引入 DeploySharp 主库及可视化工具\nnamespace DeploySharp.OpenCvSharp.Demo\n{\n    /// &lt;summary&gt;\n    /// YOLOv26 OBB 旋转目标检测演示类\n    /// 本示例展示如何加载 TensorRT 引擎文件，对图像进行旋转目标检测，并绘制旋转框。\n    /// &lt;/summary&gt;\n    public class Yolov26ObbDemo\n    {\n        public static void Run()\n        {\n            // ==========================================\n            // 1. 路径配置\n            // ==========================================\n            \n            // 模型下载提示：模型和测试图片可以前往 QQ 群（945057948）下载\n            // '-obb' 表示该模型用于输出旋转边界框\n            string modelPath = @\"D:\\Program Files\\TensorRT-10.13.0.35-cu11\\bin\\yolo26s-obb.engine\";\n            \n            // 设置待推理的图片路径\n            // plane.png 是旋转目标检测的经典测试图（飞机停机坪通常包含各种角度的飞机）。\n            string imagePath = @\"E:\\Data\\image\\plane.png\";\n            // ==========================================\n            // 2. 模型配置与初始化\n            // ==========================================\n            \n            // 创建 YOLOv26 OBB (旋转目标检测) 的配置对象，传入模型路径\n            Yolov26ObbConfig config = new Yolov26ObbConfig(modelPath);\n            \n            // [关键设置] 指定推理后端为 TensorRT。\n            // 这将调用 NVIDIA GPU 进行高性能计算。\n            // 注意：因为使用的是 .engine 文件，所以必须选择 TensorRT 后端。\n            config.SetTargetInferenceBackend(InferenceBackend.TensorRT);\n            \n            // 实例化旋转目标检测模型。\n            Yolov26ObbModel model = new Yolov26ObbModel(config);\n            // ==========================================\n            // 3. 图像加载\n            // ==========================================\n            \n            // 使用 OpenCvSharp 读取图片。\n            Mat img = Cv2.ImRead(imagePath);\n            // ==========================================\n            // 4. 模型推理\n            // ==========================================\n            \n            // 执行推理。\n            var result = model.Predict(img);\n            \n     \n            // 如果需要测试纯推理速度（排除初始化开销），可以取消注释进行多次循环。\n            result = model.Predict(img);\n            result = model.Predict(img);\n            result = model.Predict(img);\n            \n            // 打印性能分析记录。\n            // 这将显示预处理、TensorRT 推理、后处理（包含 OBB 解码）的耗时。\n            model.ModelInferenceProfiler.PrintAllRecords();\n            // ==========================================\n            // 5. 结果可视化\n            // ==========================================\n            \n            // 调用可视化工具，绘制旋转检测结果。\n            // DrawObbResult 会根据检测到的 x, y, w, h 和 angle (角度) 绘制旋转矩形。\n            var resultImg = Visualize.DrawObbResult(result, img, new VisualizeOptions(1.0f));\n            \n            // [可选] 调整图片大小以适应屏幕\n            // 航拍图通常分辨率很大，可以缩小显示。\n            //Cv2.Resize(resultImg, resultImg, new Size(resultImg.Width / 4, resultImg.Height / 4));\n            \n            // 显示结果图像。\n            Cv2.ImShow(\"image\", resultImg);\n            \n            // 等待按键，防止窗口闪退。\n            Cv2.WaitKey();\n        }\n    }\n}\n</code></pre>\n<h3 id=\"62-代码详解\">6.2 代码详解</h3>\n<ol>\n<li>\n<p><strong>创建旋转框检测配置</strong>：</p>\n<pre><code class=\"language-csharp\">Yolov26ObbConfig config = new Yolov26ObbConfig(modelPath);\nconfig.SetTargetInferenceBackend(InferenceBackend.TensorRT);\n</code></pre>\n<p><code>Yolov26ObbConfig</code> 是 YOLOv26 旋转框检测模型的配置类。</p>\n</li>\n<li>\n<p><strong>执行旋转框检测推理</strong>：</p>\n<pre><code class=\"language-csharp\">ObbResult[] result = model.Predict(img);\n</code></pre>\n<p>旋转框检测推理返回 <code>ObbResult[]</code> 数组，每个元素包含中心点、宽度、高度、旋转角度和类别信息。</p>\n</li>\n<li>\n<p><strong>可视化旋转框检测结果</strong>：</p>\n<pre><code class=\"language-csharp\">var resultImg = Visualize.DrawObbResult(result, img, new VisualizeOptions(1.0f));\n</code></pre>\n<p><code>DrawObbResult</code> 会绘制旋转的边界框（四边形），而不是普通的轴对齐矩形。</p>\n</li>\n</ol>\n<h3 id=\"63-旋转框检测结果展示\">6.3 旋转框检测结果展示</h3>\n<h4 id=\"控制台输出-2\">控制台输出</h4>\n<p>以下截图展示了在 TensorRT GPU 设备下的推理性能：</p>\n<p><img alt=\"image-20260116233931296\" class=\"lazyload\" /></p>\n<h4 id=\"推理结果绘制-2\">推理结果绘制</h4>\n<p>下图为官方预训练模型导出后的推理结果示例：</p>\n<p><img alt=\"image-20260116233543902\" class=\"lazyload\" /></p>\n<h2 id=\"七跨引擎支持\">七、跨引擎支持</h2>\n<p>DeploySharp 原生支持 OpenVINO、ONNX Runtime、TensorRT 三大主流推理引擎，为开发者在 CPU、GPU、NPU 等不同硬件设备上部署模型提供了最全面的解决方案。集成的 YOLOv26 系列默认支持所有推理引擎，开发者可根据实际硬件环境选择最优的推理方案。</p>\n<h3 id=\"71-引擎性能对比\">7.1 引擎性能对比</h3>\n<table>\n<thead>\n<tr>\n<th>引擎</th>\n<th>优势</th>\n<th>适用场景</th>\n<th>性能特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OpenVINO</td>\n<td>Intel 硬件优化，支持多种设备（CPU、GPU0、GPU1、NPU）</td>\n<td>Intel CPU、Intel GPU、NPU</td>\n<td>Intel 硬件加速</td>\n</tr>\n<tr>\n<td>ONNX Runtime</td>\n<td>广泛支持，跨平台，兼容性好</td>\n<td>CPU、GPU(CUDA/DML)、移动端</td>\n<td>平衡性能与兼容性</td>\n</tr>\n<tr>\n<td>TensorRT</td>\n<td>NVIDIA GPU 极致性能，经过专门优化</td>\n<td>NVIDIA GPU 高性能场景</td>\n<td>最佳 GPU 性能</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"72-引擎选择建议\">7.2 引擎选择建议</h3>\n<p>根据硬件环境和应用场景选择合适的推理引擎：</p>\n<table>\n<thead>\n<tr>\n<th>硬件环境</th>\n<th>推荐引擎</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Intel CPU/GPU</td>\n<td>OpenVINO</td>\n<td>Intel 硬件优化，性能最佳</td>\n</tr>\n<tr>\n<td>NVIDIA GPU</td>\n<td>TensorRT</td>\n<td>极致性能，适合高频推理</td>\n</tr>\n<tr>\n<td>NVIDIA GPU (需要灵活性)</td>\n<td>ONNX Runtime (CUDA)</td>\n<td>兼容性好，易于切换</td>\n</tr>\n<tr>\n<td>通用 CPU</td>\n<td>ONNX Runtime</td>\n<td>跨平台兼容性好</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"73-引擎切换示例\">7.3 引擎切换示例</h3>\n<pre><code class=\"language-csharp\">// 切换到 OpenVINO\nconfig.SetTargetInferenceBackend(InferenceBackend.OpenVINO);\nconfig.TargetDeviceType = DeviceType.CPU;\n\n// 切换到 ONNX Runtime (CUDA)\nconfig.SetTargetInferenceBackend(InferenceBackend.OnnxRuntime);\nconfig.TargetDeviceType = DeviceType.GPU;\n\n// 切换到 TensorRT\nconfig.SetTargetInferenceBackend(InferenceBackend.TensorRT);\nconfig.TargetDeviceType = DeviceType.GPU;\n</code></pre>\n<p><strong>注意</strong>：切换推理引擎可能需要重新加载模型，建议在应用启动时确定使用的引擎。</p>\n<h2 id=\"八性能优化建议\">八、性能优化建议</h2>\n<h3 id=\"81-预热机制\">8.1 预热机制</h3>\n<p>首次推理通常较慢，因为需要加载模型、初始化推理引擎、编译计算图等。建议执行几次预热推理。</p>\n<pre><code class=\"language-csharp\">// 预热模型（执行 3 次推理）\nfor (int i = 0; i &lt; 3; i++)\n{\n    model.Predict(img);\n}\n\n// 实际推理\nvar result = model.Predict(img);\n</code></pre>\n<h3 id=\"82-批量推理\">8.2 批量推理</h3>\n<p>对于大量图像，使用批量推理可以提高吞吐量，前提是模型支持多 Batch Size。</p>\n<pre><code class=\"language-csharp\">// 设置批量大小为 4\nconfig.InferBatch = 4;\n\n// 准备批量图像\nvar imageList = new List&lt;Image&lt;Rgb24&gt;&gt;();\nimageList.Add(Image.Load&lt;Rgb24&gt;(@\"path1.jpg\"));\nimageList.Add(Image.Load&lt;Rgb24&gt;(@\"path2.jpg\"));\nimageList.Add(Image.Load&lt;Rgb24&gt;(@\"path3.jpg\"));\nimageList.Add(Image.Load&lt;Rgb24&gt;(@\"path4.jpg\"));\n\n// 执行批量推理\nvar results = model.Predict(imageList);\n</code></pre>\n<h3 id=\"83-设备选择\">8.3 设备选择</h3>\n<p>根据硬件选择最优设备：</p>\n<pre><code class=\"language-csharp\">// Intel 环境：使用 OpenVINO\nconfig.SetTargetInferenceBackend(InferenceBackend.OpenVINO);\n\n// NVIDIA 环境：使用 TensorRT 或 ONNX Runtime (CUDA)\nconfig.SetTargetInferenceBackend(InferenceBackend.TensorRT);\nconfig.TargetDeviceType = DeviceType.GPU;\n</code></pre>\n<h2 id=\"九总结\">九、总结</h2>\n<p>DeploySharp 对 YOLOv26 系列提供了全面而深入的支持，包括：</p>\n<ol>\n<li><strong>四种任务类型全覆盖</strong>：检测、分割、姿态估计、旋转框检测</li>\n<li><strong>双图像处理库支持</strong>：ImageSharp 和 OpenCvSharp</li>\n<li><strong>三推理引擎兼容</strong>：OpenVINO、ONNX Runtime、TensorRT</li>\n<li><strong>完善的配置系统</strong>：灵活的参数设置</li>\n<li><strong>详细的性能分析</strong>：内置性能分析器</li>\n<li><strong>丰富的可视化选项</strong>：支持多种结果展示方式</li>\n</ol>\n<p>YOLOv26 的简化的输出格式和优化的架构，结合 DeploySharp 的封装和优化，使得开发者可以轻松地将 YOLOv26 集成到各种 C# 应用中，构建高效、准确的计算机视觉解决方案。</p>\n<p>随着 YOLO 系列的持续发展，DeploySharp 也将持续跟进，为开发者提供最新模型的支持。期待 YOLOv26 及未来版本的更多创新和突破。</p>\n<h2 id=\"技术支持\">技术支持</h2>\n<p>如有问题或建议，欢迎通过以下方式交流：</p>\n<ul>\n<li>📧 <strong>GitHub Issues</strong>：在项目仓库提 Issue 或 Pull Request</li>\n<li>💬 <strong>QQ 交流群</strong>：加入 <strong>945057948</strong>，回复更方便更快哦</li>\n</ul>\n<p><img alt=\"QQ群二维码\" class=\"lazyload\" /></p>\n<hr />\n<p><em>作者：Guojin Yan</em><br />\n<em>版本：0.0.6.1</em><br />\n<em>最后更新：2026年1月</em></p>\n<hr />\n<p><strong>【文章声明】</strong></p>\n<p>本文主要内容基于作者的研究与实践，部分表述借助AI工具进行了辅助优化。由于技术局限性，文中可能存在错误或疏漏之处，恳请各位读者批评指正。如果内容无意中侵犯了您的权益，请及时通过公众号后台与我们联系，我们将第一时间核实并妥善处理。感谢您的理解与支持！</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-19 22:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/guojin-blogs\">椒颜皮皮虾</a>&nbsp;\n阅读(<span id=\"post_view_count\">130</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第二周：词嵌入（二）词嵌入模型原理",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19503620",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19503620\" id=\"cb_post_title_url\" title=\"发布于 2026-01-19 20:35\">\n    <span>吴恩达深度学习课程五：自然语言处理  第二周：词嵌入（二）词嵌入模型原理</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第二周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=166\" rel=\"noopener nofollow\" target=\"_blank\">2.4</a>到<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=167\" rel=\"noopener nofollow\" target=\"_blank\">2.5</a>的内容以及一些相关知识的补充。</p>\n<hr />\n<p>本周为第五课的第二周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本周的内容关于词嵌入，是一种<strong>相对于独热编码，更能保留语义信息的文本编码方式</strong>。通过词嵌入，模型不再只是“记住”词本身，而是能够<strong>基于语义关系进行泛化</strong>，在一定程度上实现类似“<strong>举一反三</strong>”的效果。词嵌入是 NLP 领域中最重要的基础技术之一。</p>\n<p>本篇的内容关于<strong>词嵌入模型原理</strong>，是了解基础内容后的下一步引入。</p>\n<h1 id=\"1-词嵌入矩阵\">1. 词嵌入矩阵</h1>\n<p>在<a href=\"https://www.cnblogs.com/Goblinscholar/p/19494158\" target=\"_blank\">上一篇</a>中，我们知道通过词嵌入可以实现词汇的特征化表示，这种序列信息编码方式相比独热编码不仅节约了存储和时间成本，而且可以量化词汇的语义来提升模型性能。<br />\n那么要如何训练一个可以输出对词汇合适编码的词嵌入模型呢？<br />\n实际上，词嵌入模型的原理和我们之前介绍过的<a href=\"https://www.cnblogs.com/Goblinscholar/p/19423276\" target=\"_blank\">图像风格转换</a>有些类似，就像其首先要随机初始化目标图像一样，词嵌入模型的第一步，并不是“理解语义”，而是<strong>先给每个词一个可以被学习的数值载体</strong>。<br />\n具体来说是这样的：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260119203403821-212247932.png\" /></p>\n<p>如图所示，假设我们的词表大小为 <span class=\"math inline\">\\(|V|\\)</span>，词向量维度设为 <span class=\"math inline\">\\(d\\)</span>，那么词嵌入本质上就是一个矩阵，每一行对应词表中的一个词，我们称之为<strong>词嵌入矩阵</strong>。</p>\n<p></p><div class=\"math display\">\\[\\mathbf{E}\n=\n\\begin{bmatrix}\nv_{1,1} &amp; v_{1,2} &amp; v_{1,3} &amp; \\cdots &amp; v_{1,d} \\\\\nv_{2,1} &amp; v_{2,2} &amp; v_{2,3} &amp; \\cdots &amp; v_{2,d} \\\\\nv_{3,1} &amp; v_{3,2} &amp; v_{3,3} &amp; \\cdots &amp; v_{3,d} \\\\\n\\vdots  &amp; \\vdots  &amp; \\vdots  &amp; \\ddots &amp; \\vdots  \\\\\nv_{|V|,1} &amp; v_{|V|,2} &amp; v_{|V|,3} &amp; \\cdots &amp; v_{|V|,d}\n\\end{bmatrix}\n\\]</div><p></p><p>这里需要强调的是，在课程中，吴恩达老师常在词嵌入矩阵中使用列向量来表示词向量，以匹配矩阵乘法的约定。但在实际工程代码中，通常视作行向量（矩阵行对应词向量）。<strong>这只是约定问题</strong>，取决于实现方式：教学中列向量便于公式推导，代码中行向量更高效。了解后，根据场景选择即可。<br />\n回到正题，在模型初始化阶段，词嵌入矩阵<strong>并不包含任何语义信息</strong>，通常采用随机初始化，或者服从均值为 0 的正态分布。<br />\n我们之前就说过，词向量并不是我们手工设定的，而是在模型学习得到的，在我们完成词嵌入矩阵的初始化后，<strong>词嵌入模型的目的就是不断传播和优化词嵌入矩阵，得到对语义编码合理的词向量</strong>，从而进行下一步应用。</p>\n<p>到这里就会发现，学习词嵌入矩阵的过程和图像风格转换的过程非常相似：一开始是随机噪声，但在损失函数的约束下，逐步学习得到结构化、有意义的结果。</p>\n<p>在完成词嵌入矩阵的初始化后，<strong>模型训练的核心任务就是设计合理的上下文预测目标，让矩阵中每一行（词向量）逐步调整位置，从而携带语义信息。</strong></p>\n<h1 id=\"2-早期词嵌入模型\">2. 早期词嵌入模型</h1>\n<p>在 2003 年，一篇论文 <a href=\"https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf\" rel=\"noopener nofollow\" target=\"_blank\">A Neural Probabilistic Language Model</a>，首次展示了一个神经网络语言模型，它不仅预测下一个词的概率分布，还通过一个嵌入层将词索引映射为实值向量。这些向量成为了词的稠密表示，也就是我们今天所说的<strong>词嵌入（word embeddings）</strong>。<br />\n尽管当时论文中并没有直接使用“word embedding”这个术语，但其核心思想：<strong>通过神经网络学习词的分布式向量表示</strong>——正是现代词嵌入模型的理论源头。</p>\n<h2 id=\"21-词嵌入模型原理\">2.1 词嵌入模型原理</h2>\n<p>这一部分我们展开一下，用早期的模型介绍一下最经典的一类词嵌入模型：<strong>预测型词嵌入模型</strong>的基本逻辑：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260119202257923-2120601282.png\" /><br />\n图中简要描述了该模型的传播逻辑，补充一些细节如下：</p>\n<ol>\n<li><strong>嵌入层（Embedding Layer）</strong>：在图中的左半部分，完成的是<strong>存储词嵌入矩阵和根据索引查找机制提取词向量</strong>的工作，我们称完成这部分内容的结构为<strong>嵌入层</strong>。</li>\n<li><strong>窗口大小 <span class=\"math inline\">\\(t\\)</span></strong>：这是一个超参数，当预测序列中第 <span class=\"math inline\">\\(n\\)</span> 个词汇时，我们使用其之前 <span class=\"math inline\">\\(t\\)</span> 个词汇作为序列信息。<strong>在现代，前文如果不足 <span class=\"math inline\">\\(t\\)</span> 个，则会使用特殊符号填充。</strong></li>\n<li><strong>联合更新</strong>：在反向传播过程中，<strong>嵌入层和网络的其他参数同时更新</strong>。这意味着每次看到训练样本，嵌入矩阵中涉及的<strong>词向量会和网络参数一起沿梯度方向调整</strong>，使其更有利于下一个词的预测。</li>\n</ol>\n<p>那词向量具体是怎么更新来学习语义的呢？我们展开说说：</p>\n<h2 id=\"22-词向量的语义学习\">2.2 词向量的语义学习</h2>\n<p>举个例子来理解一下词向量的更新逻辑：<br />\n假设训练语料中出现了许多关于水果的句子，比如：</p>\n<pre><code>I like to eat apple.\nShe bought a banana yesterday.\nOrange juice is tasty.\n</code></pre>\n<p>现在，模型的任务是<strong>根据上下文预测下一个词</strong>。当看到句子 <code>\"I like to eat apple\"</code> 时，模型会预测下一个词可能是 <code>\"apple\"</code>。<br />\n这时，反向传播时，模型会调整 <strong>“apple”对应的词向量</strong>以及上下文中其他词的向量，使得网络更容易正确预测 <code>\"apple\"</code>。</p>\n<p>同理，当训练样本中出现 <code>\"banana\"</code> 或 <code>\"orange\"</code> 时，这些词的向量也会因为相似的上下文而被调整到<strong>相互靠近的位置</strong>：<code>\"apple\"</code>, <code>\"banana\"</code>, <code>\"orange\"</code> <strong>这些同类型的词常出现在类似的上下文</strong>（如 eat、juice、like 等）<br />\n最终模型通过梯度更新，让这些词向量在向量空间中<strong>彼此靠近</strong>，从而自然捕捉到语义相似性。</p>\n<p>这样的效果就是：即使模型从未显式告知“它们都是水果”，词向量也会因为上下文模式相似而自动聚集在一起，形成<strong>语义簇（semantic cluster）</strong>，即向量空间中，语义相近的词自然聚在一起形成的群体。<br />\n这时，面对下面这两句话：</p>\n<pre><code>训练：I like orange juice.\n测试：I love apple _____. \n</code></pre>\n<p>模型即使<strong>没见过测试语句，也可以通过<code>\"love 和 like\"</code>、<code>\"apple 和 orange\"</code> 在向量空间的距离相近得到更可靠的答案，从而提高模型性能。</strong></p>\n<p>用一句话总结一下：<strong>同类型的词汇往往出现在相似的上下文中，因此在更新后更加相似，最终在向量空间中形成语义簇，极大增强了模型的泛化能力。</strong></p>\n<p>你会发现，<strong>在词嵌入模型中，词向量的语义结构并不是显式教给模型的，而是在上下文预测任务中自然而然学到的，模型并没有专门去“训练合适编码”，而是在预测中让相似的词不断靠近。</strong><br />\n同样是对数据进行编码，词嵌入和我们之前介绍的<a href=\"https://www.cnblogs.com/Goblinscholar/p/19418306\" target=\"_blank\">人脸识别</a>又有所不同。</p>\n<p>当然，既然是早期模型，自然有值得优化的地方，我们继续：</p>\n<h2 id=\"23-早期词嵌入模型的局限\">2.3 早期词嵌入模型的局限</h2>\n<p>尽管 A Neural Probabilistic Language Model 成功提出了通过神经网络学习词向量的思路，但作为早期模型，它在实际应用和理论上存在一些明显的局限性：</p>\n<table>\n<thead>\n<tr>\n<th>局限类别</th>\n<th>具体说明</th>\n<th>影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>计算开销大</strong></td>\n<td>输入是 <span class=\"math inline\">\\(t\\)</span> 个词独热向量拼接，输出是词表大小 <span class=\"math inline\">\\(V\\)</span> 的 softmax</td>\n<td>词表大时计算量高，训练预测速度慢</td>\n</tr>\n<tr>\n<td><strong>上下文窗口固定</strong></td>\n<td>每次预测只使用前 <span class=\"math inline\">\\(t\\)</span> 个词</td>\n<td>无法捕捉长距离依赖，语义建模受限</td>\n</tr>\n<tr>\n<td><strong>梯度更新效率低</strong></td>\n<td>嵌入矩阵和网络参数同时更新，每个样本只涉及部分词向量</td>\n<td>收敛慢，低频词向量质量不稳定</td>\n</tr>\n<tr>\n<td><strong>没有显式建模语义规律</strong></td>\n<td>语义相似性完全依赖上下文共现</td>\n<td>稀有词或低频词向量质量差，泛化能力有限，无法处理多义词</td>\n</tr>\n</tbody>\n</table>\n<p>因此，为了解决这些问题，自然有人发明新的技术和模型，我们在之后几篇就来详细介绍这些内容。</p>\n<h1 id=\"3-总结\">3. 总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>词嵌入矩阵（Embedding Matrix）</strong></td>\n<td>将词表中每个词映射为可学习的稠密向量，矩阵行（或列）对应词向量。初始化随机或正态分布，通过梯度更新学习语义信息。</td>\n<td>类似图像风格转换中的“随机噪声图像”，逐步在训练中形成结构化图像。</td>\n</tr>\n<tr>\n<td><strong>嵌入层（Embedding Layer）</strong></td>\n<td>存储词嵌入矩阵并提供索引查找功能，将词索引映射为词向量。</td>\n<td>就像一本“词向量字典”，根据索引直接查到对应的向量。</td>\n</tr>\n<tr>\n<td><strong>上下文预测训练</strong></td>\n<td>利用前 <span class=\"math inline\">\\(t\\)</span> 个词预测下一个词，通过反向传播更新嵌入矩阵和网络参数，使语义相似的词向量靠近。</td>\n<td>好比让水果类词（apple, banana, orange）在向量空间里自然聚成一簇，通过相似上下文学习它们的关系。</td>\n</tr>\n<tr>\n<td><strong>语义簇（Semantic Cluster）</strong></td>\n<td>在向量空间中，语义相近的词自然聚集，捕捉词汇之间的语义关系。</td>\n<td>词向量像朋友一样，常在同一圈子（上下文）出现就靠近在一起。</td>\n</tr>\n<tr>\n<td><strong>早期词嵌入模型局限</strong></td>\n<td>计算开销大（softmax over 大词表）上下文窗口固定、 梯度更新效率低 、无显式语义建模（如多义词）。</td>\n<td>模型像老式拼字游戏，效率低且只能看到局部信息，难以捕捉远距离或复杂规律。</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-19 20:35</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">24</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Agent Skill: react-best-practices",
      "link": "https://www.cnblogs.com/guangzan/p/19490691",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/guangzan/p/19490691\" id=\"cb_post_title_url\" title=\"发布于 2026-01-20 10:14\">\n    <span>Agent Skill: react-best-practices</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"背景\">背景</h2>\n<p>Agent Skill 是一个可复用的能力单元，通常包含明确的职责边界、触发条件、输入输出约定，且可能封装了提示词、工具调用逻辑、状态  处理和约束规则。在工程化 Agent 系统中，Skill 更接近“函数 / 用例 / 子代理”。相对于提示词（Prompt），提示词只是其中的一部分实现细节，而不是 Skill 本身。从抽象层级看，提示词解决的是“模型怎么想、怎么说”，Skill 解决的是这个 Agent 能做什么、在什么条件下做、做到什么程度。</p>\n<p>Vercel 刚刚开源了 <code>react-best-practices</code>——一套封装了其 10 余年 React 与 Next.js 优化经验的 Agent Skills（智能体技能包）。不同于传统的性能文档，这个结构化仓库以AI 友好为核心设计目标，能直接集成到编码智能体（如 Claude Code、Cursor、Codex）中，让开发者与 AI 共同遵循统一的性能优化标准，从事后救火转向事前预防。</p>\n<h2 id=\"为什么需要这套-skills\">为什么需要这套 Skills？</h2>\n<p>React 生态的性能优化长期面临一个痛点：<strong>反应式优化（Reactive Optimization）</strong>。多数团队的流程是“版本发布→用户反馈卡顿→排查性能问题”，这种模式不仅成本高，还容易陷入优化错重点的误区。比如，花大量时间优化 <code>useMemo</code> 调用（React19 以后已无需手动优化）。却忽略了导致 600ms 等待的请求瀑布流，或每个页面额外加载的 300KB 冗余 JavaScript。</p>\n<p>Vercel 团队在 10 余年生产环境实践中发现，90% 以上的 React 性能问题源于三大共性根因：</p>\n<ol>\n<li><strong>异步操作意外串行</strong>：本可并行的请求被写成顺序执行，导致等待时间叠加（即请求瀑布流）；</li>\n<li><strong>客户端 Bundle 膨胀</strong>：随项目迭代，未清理的冗余代码、未懒加载的重组件持续增大包体积，拖慢首屏加载；</li>\n<li><strong>组件不必要重渲染</strong>：状态设计不合理或依赖传递不当，导致无关组件频繁触发重渲染，引发界面卡顿。</li>\n</ol>\n<p>这些问题不是小事，它们会直接转化为用户可感知的加载缓慢和交互卡顿，并随着版本迭代积累成性能债务，持续影响用户的每次访问体验。而 react-best-practices 的核心目标，正是让这类问题变得可识别、可复现，并能通过自动化方式得到修复。</p>\n<h2 id=\"核心理念按影响优先级排序先解决关键问题\">核心理念：按影响优先级排序，先解决关键问题</h2>\n<p>传统性能优化常因切入点太低失败，而 <code>react-best-practices</code> 提出了一套颠覆性思路，按优化影响度排序，先抓主要矛盾。其规则体系从“CRITICAL（关键）”到“LOW（增量）”分级，强制优先解决对用户体验影响最大的问题，具体优先级逻辑如下：</p>\n<table>\n<thead>\n<tr>\n<th>优先级</th>\n<th>优化类别</th>\n<th>影响等级</th>\n<th>核心价值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>消除异步瀑布流</td>\n<td>CRITICAL</td>\n<td>直接减少请求等待时间，提升交互响应速度</td>\n</tr>\n<tr>\n<td>2</td>\n<td>客户端 Bundle 体积优化</td>\n<td>CRITICAL</td>\n<td>降低首屏加载时间，减少流量消耗</td>\n</tr>\n<tr>\n<td>3</td>\n<td>服务端性能优化</td>\n<td>HIGH</td>\n<td>提升服务端渲染（SSR）/静态生成（SSG）效率</td>\n</tr>\n<tr>\n<td>4</td>\n<td>客户端数据获取</td>\n<td>MEDIUM-HIGH</td>\n<td>避免重复请求，减少网络资源浪费</td>\n</tr>\n<tr>\n<td>5-8</td>\n<td>重渲染优化、渲染性能、JS 性能、高级模式</td>\n<td>MEDIUM-LOW</td>\n<td>逐步优化细节体验，降低长期维护成本</td>\n</tr>\n</tbody>\n</table>\n<p>以消除异步瀑布流为例，仓库中给出了典型的错误与正确实践对比：</p>\n<p><strong>错误写法（串行阻塞）</strong>：</p>\n<pre><code class=\"language-typescript\">async function handleRequest(userId: string, skipProcessing: boolean) {\n  // 无论是否需要处理，都先等待 userData 请求完成，造成不必要阻塞\n  const userData = await fetchUserData(userId);\n  \n  if (skipProcessing) {\n    return { skipped: true }; // 虽立即返回，但已浪费请求时间\n  }\n  \n  return processUserData(userData);\n}\n</code></pre>\n<p><strong>正确写法（按需阻塞）</strong>：</p>\n<pre><code class=\"language-typescript\">async function handleRequest(userId: string, skipProcessing: boolean) {\n  // 先判断是否需要处理，避免不必要的请求\n  if (skipProcessing) {\n    return { skipped: true };\n  }\n  \n  // 仅在需要时发起请求，减少等待时间\n  const userData = await fetchUserData(userId);\n  return processUserData(userData);\n}\n</code></pre>\n<p>另一类关键优化是并行化无关请求——若两个请求不依赖彼此，使用 <code>Promise.all()</code> 并行执行可直接将总等待时间减半：</p>\n<pre><code class=\"language-typescript\">// ❌ 串行请求（总耗时 = t1 + t2）\nconst user = await fetchUser(id);\nconst posts = await fetchPosts(user.id);\nconst settings = await fetchSettings(user.id);\n\n// ✅ 并行请求（总耗时 = max(t2, t3)）\nconst user = await fetchUser(id);\nconst [posts, settings] = await Promise.all([\n  fetchPosts(user.id),\n  fetchSettings(user.id)\n]);\n</code></pre>\n<p>我推荐你试试 <a href=\"https://github.com/shuding/better-all\" rel=\"noopener nofollow\" target=\"_blank\">better-all</a>,  <code>Promise.all</code> 支持自动依赖优化和全类型推理。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1501373/202601/1501373-20260116100808350-2036525129.png\" /></p>\n<h2 id=\"仓库结构ai-友好的结构化设计\">仓库结构：AI 友好的结构化设计</h2>\n<p><code>react-best-practices</code> 并非简单的文档集合，而是为 AI 智能体设计的可查询、可集成技能包。其 GitHub 仓库（<a href=\"https://github.com/vercel-labs/agent-skills/tree/main/skills/react-best-practices\" rel=\"noopener nofollow\" target=\"_blank\">vercel-labs/agent-skills</a>）采用高度结构化的目录设计，核心文件与功能如下：</p>\n<table>\n<thead>\n<tr>\n<th>目录/文件</th>\n<th>作用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>rules/</code></td>\n<td>单个优化规则文件，按“类别前缀 + 描述”命名（如 <code>async-parallel.md</code>），含错误/正确代码示例</td>\n</tr>\n<tr>\n<td><code>rules/_template.md</code></td>\n<td>新建规则的模板，强制包含“标题、影响等级、标签、代码示例”等 AI 可识别字段</td>\n</tr>\n<tr>\n<td><code>AGENTS.md</code></td>\n<td>自动编译生成的单文件文档，优化了 LLM 上下文读取效率，供 AI 智能体查询</td>\n</tr>\n<tr>\n<td><code>metadata.json</code></td>\n<td>仓库元数据（版本、组织、摘要），方便工具识别与集成</td>\n</tr>\n<tr>\n<td><code>src/</code></td>\n<td>构建脚本与工具，支持编译规则、验证格式、提取测试用例</td>\n</tr>\n</tbody>\n</table>\n<p>若开发者需要贡献新规则，只需遵循简单流程：</p>\n<ol>\n<li>复制 <code>rules/_template.md</code> 为 <code>rules/[类别前缀]-[描述].md</code>（如 <code>bundle-dynamic-import.md</code>）；</li>\n<li>按模板填写“影响等级（如 MEDIUM）”“规则说明”“错误/正确代码示例”；</li>\n<li>运行 <code>pnpm build</code> 重新编译 <code>AGENTS.md</code> 与测试用例；</li>\n<li>提交 PR 即可。</li>\n</ol>\n<p>这种结构化设计确保了所有规则格式统一、信息完整，AI 智能体可快速提取关键信息，避免因文档格式混乱导致的理解偏差。</p>\n<h2 id=\"如何用ai-集成与团队落地\">如何用？：AI 集成与团队落地</h2>\n<p><code>react-best-practices</code> 的最大亮点是即插即用的 AI 集成能力——开发者无需手动阅读所有规则，只需将其安装为编码智能体的技能，即可让 AI 在写代码、做 Code Review 时自动应用这些优化经验。</p>\n<h3 id=\"1-集成到编码智能体\">1. 集成到编码智能体</h3>\n<p>通过一行命令，即可将技能包安装到 Opencode、Claude Code、Cursor 等主流编码工具中：</p>\n<pre><code class=\"language-bash\">npx add-skill vercel-labs/agent-skills\n</code></pre>\n<p><img alt=\"image\" height=\"880\" src=\"https://img2024.cnblogs.com/blog/1501373/202601/1501373-20260116100949263-567728034.png\" width=\"905\" /></p>\n<p>另一种集成方式，shadcn registry 可能非常适合创建和分发技能与代理，包括扩展第三方代理。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1501373/202601/1501373-20260116101634273-237888103.png\" /></p>\n<p>如何使用呢？以 Cursor 为例，Cursor 启动时会自动从技能目录中发现技能，并将它们提供给 Agent。Agent 会查看可用的技能，并根据上下文决定何时使用。也可以在 Agent 对话中输入 <code>/</code>，通过搜索技能名称手动调用技能。</p>\n<p><img alt=\"image\" height=\"366\" src=\"https://img2024.cnblogs.com/blog/1501373/202601/1501373-20260116102029455-848800598.png\" width=\"555\" /></p>\n<h3 id=\"2-团队内部标准化\">2. 团队内部标准化</h3>\n<p>对于团队而言，<code>react-best-practices</code> 可作为统一的性能优化标准：</p>\n<ul>\n<li>新人无需记忆复杂的优化规则，通过 AI 辅助即可写出高性能代码；</li>\n<li>Code Review 时，团队可直接参考仓库中的规则编号（如async-parallel 规则），避免主观争议；</li>\n<li>定期运行 <code>pnpm validate</code> 验证项目代码是否符合规则，提前发现性能隐患。</li>\n</ul>\n<h2 id=\"实际价值从人治到ai-辅助的标准化\">实际价值：从人治到AI 辅助的标准化</h2>\n<p>Vercel 开源这套技能包，本质上是推动 React 性能优化从依赖个人经验的人治模式，转向AI 辅助的标准化模式。其实际价值体现在三点：</p>\n<ol>\n<li><strong>降低门槛</strong>：初级开发者无需成为性能专家，借助 AI 即可应用 Vercel 10 年的优化经验；</li>\n<li><strong>避免债务</strong>：通过事前预防替代事后救火，减少因小问题积累的长期性能债务；</li>\n<li><strong>统一决策</strong>：大型团队可通过这套规则统一性能标准，避免不同开发者因理解差异导致的优化混乱。</li>\n</ol>\n<h2 id=\"结语\">结语</h2>\n<p><code>react-best-practices</code> 的开源，标志着 React 生态的性能优化进入了AI 协同的新阶段——它不再是一份需要手动翻阅的文档，而是能嵌入开发流程的智能技能。对于开发者而言，这意味着更少的性能调试时间、更稳定的用户体验；对于 React 生态而言，这是一次性能优化标准的重要统一。</p>\n<p>若你正在维护 React 或 Next.js 项目，不妨立即将其集成到你的编码工具中——让 AI 帮你守住性能底线，把精力集中在更有创造性的功能开发上。</p>\n<p>最后，不得不感叹，前端工程师更难打造自身的护城河了，甚至不会有。</p>\n<h2 id=\"参考资料\">参考资料</h2>\n<ul>\n<li><a href=\"https://github.com/vercel-labs/agent-skills/tree/main/skills/react-best-practices\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/vercel-labs/agent-skills/tree/main/skills/react-best-practices</a></li>\n<li><a href=\"https://vercel.com/blog/introducing-react-best-practices\" rel=\"noopener nofollow\" target=\"_blank\">https://vercel.com/blog/introducing-react-best-practices</a></li>\n<li><a href=\"https://cursor.com/cn/docs/context/skills\" rel=\"noopener nofollow\" target=\"_blank\">https://cursor.com/cn/docs/context/skills</a></li>\n<li><a href=\"https://github.com/shuding/better-all\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/shuding/better-all</a></li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-20 10:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/guangzan\">guangzan</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}