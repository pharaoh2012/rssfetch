{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "使用Mixin类简单重构配置模块",
      "link": "https://www.cnblogs.com/XY-Heruo/p/19606287",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/XY-Heruo/p/19606287\" id=\"cb_post_title_url\" title=\"发布于 2026-02-12 00:29\">\n    <span>使用Mixin类简单重构配置模块</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>按照个人习惯，项目伊始我会按照如下结构组织项目配置，也就是配置文件放在<code>conf/</code>目录，单独写一个配置模块<code>pkg/config.py</code>去读取加载。有的小项目还好，没什么配置项。但有的项目要调用很多第三方的接口，配置文件写了一堆接口地址、认证方式等，配置模块也相应增加了几百行。看着这快上千行的配置模块，还是尽早改改比较好。</p>\n<pre><code>conf/\n  app.toml\npkg/\n  config.py\n</code></pre>\n<p>有的项目会把配置打散，各个模块维护各自的配置，但对于使用单一配置模块的项目，除了配置模块，其它模块调用配置类单例的地方我都不想去碰，也懒得碰。这时候，使用Mixin类就比较合适。</p>\n<p>在Python中，Mixin只是一种约定，语言层面没有显式支持，实际上就是python的多重继承。</p>\n<h2 id=\"旧代码的配置类\">旧代码的配置类</h2>\n<p>旧的配置模块<code>pkg/config.py</code>大概长这样，每个配置项都写成了动态属性。即便只是简单的取值，也可能会写很多。如果再加上校验，单个文件的内容就会很多了，鼠标滚轮翻快点估计就找不到哪对哪了。</p>\n<pre><code class=\"language-python\">class Config:\n    def __init__(self) -&gt; None:\n        self._config_file = Path(__file__).parent.parent.parent / \"conf\" / \"config.toml\"\n        self._config = self._load_config()\n\n    def _load_config(self) -&gt; Dict[str, Any]:\n        if not self._config_file.exists():\n            raise FileNotFoundError(f\"Configuration file {self._config_file} does not exist.\")\n        with open(self._config_file, \"rb\") as f:\n            return tomllib.load(f)\n\n    @property\n    def service_host(self) -&gt; str:\n        return self._config.get(\"service\").get(\"host\", \"127.0.0.1\")\n\n    @property\n    def service_port(self) -&gt; int:\n        return self._config.get(\"service\").get(\"port\", 8000)\n</code></pre>\n<h2 id=\"拆分\">拆分</h2>\n<h3 id=\"简单示例\">简单示例</h3>\n<p>如果配置的层级特别深，Mixin里写一长串<code>.get().get()</code>也挺碍眼的。可以写一个基类<code>BaseMixin</code>，在基类中定义一个递归读取配置的方法。</p>\n<pre><code class=\"language-python\">class BaseMixin:\n    _config: Dict[str, Any]\n    \n    def _get_conf(self, *keys: str, default: Any = None) -&gt; Any:\n        \"\"\"递归获取配置\"\"\"\n        data = self._config\n        for k in keys:\n            if isinstance(data, dict):\n                data = data.get(k)\n            else:\n                return default\n        return data if data is not None else default\n\nclass FeatureMixin(BaseMixin):\n    @property\n    def is_feature_enabled(self) -&gt; bool:\n        return self._get_conf(\"module\", \"submodule\", \"enabled\", default=False)\n        \nfrom typing import Any, Dict\n\nclass ServiceMixin(BaseMixin):\n    \"\"\"处理 Service 相关的配置项\"\"\"\n    @property\n    def service_host(self) -&gt; str:\n        return self._get_conf(\"service\", \"host\", default=\"127.0.0.1\")\n\n    @property\n    def service_port(self) -&gt; int:\n        return self._get_conf(\"service\", \"port\", default=8000)\n\nclass DatabaseMixin(BaseMixin):\n    \"\"\"处理 Database 相关的配置项\"\"\"\n    @property\n    def db_url(self) -&gt; str:\n        return self._get_conf(\"database\", \"url\", default=\"sqlite:///./test.db\")\n</code></pre>\n<p>组合成最终的<code>Config</code>类</p>\n<pre><code class=\"language-python\">import tomllib\nfrom pathlib import Path\n\nclass Config(ServiceMixin, DatabaseMixin):\n    \"\"\"\n    最终的聚合类。继承了所有 Mixin，因此它拥有了所有定义好的 @property。\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._config_file = Path(__file__).parent.parent.parent / \"conf\" / \"config.toml\"\n        self._config = self._load_config()\n\n    def _load_config(self) -&gt; Dict[str, Any]:\n        if not self._config_file.exists():\n            raise FileNotFoundError(f\"Configuration file {self._config_file} does not exist.\")\n        with open(self._config_file, \"rb\") as f:\n            return tomllib.load(f)\n\n# --- 调用端代码完全不需要修改 ---\nconfig = Config()\nprint(config.service_host)  # 来源于 ServiceMixin\nprint(config.db_url)        # 来源于 DatabaseMixin\n</code></pre>\n<p>如上改造后，调用方依然使用<code>config.db_url</code> 这样的方式来使用，不用管配置模块如何改动。以后如果再想新增配置，比如Redis的连接配置，只需要新增一个<code>RedisMixin</code>类，并加到<code>Config</code>的继承列表里即可。</p>\n<h3 id=\"中间层聚合\">中间层聚合</h3>\n<p>当配置的Mixin类越来越多，<code>Config</code>类会有一溜排的Mixin类要继承，看着有点头重脚轻。这时可以按逻辑领域先进行聚合。</p>\n<p>比如，数据库相关的先聚合成<code>DBMixins</code>（这种中间层聚合的Mixin类，推荐命名后缀为<code>Mixins</code>）</p>\n<pre><code class=\"language-python\"># pkg/config/mixins/db.py\n\nclass PostgresMixin(BaseMixin):\n    @property\n    def pg_host(self) -&gt; str:\n        pass\n        \n    @property\n    def pg_port(self) -&gt; int:\n        pass\n        \nclass RedisMixin(BaseMixin):\n    @property\n    def redis_host(self) -&gt; str:\n        pass\n        \n    @property\n    def redis_port(self) -&gt; int:\n        pass\n        \nclass DBMixins(PostgresMixin, RedisMixin):\n    pass\n</code></pre>\n<p>在<code>Config</code>类中组装</p>\n<pre><code class=\"language-python\"># pkg/config/config.py\nfrom pkg.config.mixins.db import DBMixins\nclass Config(DBMixins):\n    pass\n</code></pre>\n<p>最终目录结构如下：</p>\n<pre><code>conf/\n  config.toml\npkg/\n  config/\n    __init__.py  # 在此创建 Config 类的单例\n    config.py    # 其中只有 Config 类\n    mixins/\n      __init__.py  # 定义 BaseMixin 基类\n      db.py\n      third_parties.py\n</code></pre>\n<h2 id=\"补充\">补充</h2>\n<p>对于新项目，可以试试把配置全部放到环境变量，各个模块实现各自的配置模块。好处就是找起来方便，而且从环境变量中读取配置也不用操心文件读取的阻塞问题。目前很多运行在k8s上的服务喜欢用这种读取环境变量的配置方式。缺点可能就是维护起来不太方便，毕竟配置被打散了，交接给别人的话，别人可能得到处找配置。</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/XY-Heruo/\" target=\"_blank\">花酒锄作田</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/XY-Heruo/p/19606287\" target=\"_blank\">https://www.cnblogs.com/XY-Heruo/p/19606287</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-12 00:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/XY-Heruo\">花酒锄作田</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "如何用SSH访问远程服务器上的内网服务（如：MySQL、Redis、Kafka）？",
      "link": "https://www.cnblogs.com/hackyle/p/19606177",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hackyle/p/19606177\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 23:13\">\n    <span>如何用SSH访问远程服务器上的内网服务（如：MySQL、Redis、Kafka）？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><strong>你是否有遇到以下的需求场景：</strong></p>\n<ul>\n<li>场景1：你部署在个人的云服务器上的服务，出现了问题，想在本地的Navicat / DBeaver查一下线上MySQL，却发现连都连不上。</li>\n<li>场景2：线上 Redis 出问题了，你排查时发现无从下手。\n<ul>\n<li>如果有打印日志，你还可以结合代码逻辑和日志来分析</li>\n<li>但是对于某些业务场景下的缓存穿透，Key 被误删，排查起来就比较困难了</li>\n</ul>\n</li>\n<li>场景3：Kafka 有消息积压，但我连 Topic 都看不到\n<ul>\n<li>有消息积压，你想：看 topic 列表，看 consumer group 状态，尝试手动消费一条消息。但是，Kafka 端口 9092 / 9093 不开放公网，本地 Kafka 工具根本连不上。</li>\n<li>Kafka 本身就复杂，一出问题，你连“观察窗口”都没有，完全依赖运维、日志和平台，排查问题的复杂度飙升。</li>\n</ul>\n</li>\n</ul>\n<p><strong>以上问题的原因是什么？</strong></p>\n<ul>\n<li>MySQL、Redis、Kafka配置了只有本地127.0.0.1可以访问，不能通过其他IP访问</li>\n<li>防火墙没有对服务端口开放</li>\n<li>云服务器的安全策略也没有对端口打开</li>\n</ul>\n<p><strong>而我只想临时做几件事：</strong></p>\n<ul>\n<li>只想临时查看数据、验证问题</li>\n<li>不想改防火墙、安全策略组</li>\n<li>不想改代码、不想提需求、不想走审批</li>\n</ul>\n<p>我要临时访问内网服务，但是网络不通，不能随便改网络，有没有什么技术方法解决这个问题？答案是肯定的 —— <strong>SSH本地端口转发</strong>。</p>\n<p><strong>注意：这有个很重要的前提条件，你能通过SSH连接到远程服务器。</strong></p>\n<h1><strong><u>实现思路</u></strong></h1>\n<p><strong>一句话概括原理：</strong>利用 SSH 在本地和远程服务器之间建立一条加密通道，把远程内网端口“转发”到本地端口。</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"263\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"550\" /></p>\n<p>对本地工具来说：它以为自己连的是 localhost</p>\n<p>实际上流量通过 SSH：</p>\n<ol>\n<li>先到远程服务器</li>\n<li>再由远程服务器访问内网服务</li>\n<li>你不需要改网络、不需要开端口、不需要暴露服务。</li>\n</ol>\n<p><strong>语法：ssh -L [本地端口]:[目标主机]:[目标端口] [SSH服务器用户名]@[SSH服务器地址]</strong></p>\n<p><strong>对于开发人员来说，常用的两类应用场景：</strong></p>\n<ul>\n<li>远程服务器上的某些服务无法从公网访问</li>\n</ul>\n<ol>\n<li>线上环境里，数据库、中间件（MySQL / Redis / Kafka）几乎从不暴露公网端口，只能在内网访问。</li>\n<li>防火墙是关闭状态，暴露公网访问需要改动防火墙（易出错）</li>\n<li>云服务器的安全策略阻止访问，需要手动配置流入、流出的安全策略端口</li>\n</ol>\n<ul>\n<li>公司内网服务器上的服务无法从本机访问</li>\n</ul>\n<ol>\n<li>服务内网部署，不对开发人员开放</li>\n<li>权限管控严格</li>\n<li>想调试问题，但安全策略比问题还复杂，懒得去配置</li>\n<li>内网服务器上不允许随便安装其他第三方软件</li>\n<li>注意：此方式可能让你违规，谨慎使用</li>\n</ol>\n<p><strong>这种方式适合哪些场景？</strong></p>\n<ul>\n<li>非常适合\n<ul>\n<li>临时排查线上问题</li>\n<li>查看缓存数据</li>\n<li>不想改代码</li>\n<li>不想装客户端</li>\n<li>权限受限环境</li>\n</ul>\n</li>\n<li>不适合\n<ul>\n<li>长期运维通道</li>\n<li>高并发访问</li>\n</ul>\n</li>\n</ul>\n<h1><strong><u>执行步骤</u></strong></h1>\n<p>在了解了基本原理和实现思路后，开始梳理执行步骤，跟着我一步一步来实现吧。</p>\n<p><strong>执行步骤</strong></p>\n<ul>\n<li>第一步：能正常 SSH 登录到一台服务器，且允许端口转发</li>\n<li>第二步：明确你要连接的目标，开启本地端口转发</li>\n<li>第三步：验证 SSH 隧道是否生效</li>\n<li>第四步：远程访问目标服务</li>\n</ul>\n<p>假设我要连接远程服务器（8.145.45.70）的Redis服务，他们在远程服务器上分别使用6379端口。</p>\n<p>在本地选择一个没被占用、你自己记得住的端口，比如：16379。不要求和远端端口一致，只是为了好记。</p>\n<p><strong>如何检查SSH服务器是否允许端口转发？检查sshd_config中以下配置项的值</strong></p>\n<ul>\n<li>AllowTcpForwarding no &nbsp;#应该改为yes</li>\n<li>AllowAgentForwarding no &nbsp;#应该改为yes</li>\n<li>PermitTunnel no &nbsp;#应该改为yes</li>\n</ul>\n<h2><strong><u>开启本地端口转发</u></strong></h2>\n<p>在本地创建 SSH 隧道</p>\n<ul>\n<li>这一操作的目标是：让本地某个端口，指向远程内网服务端口</li>\n<li>流量流向：localhost:本地端口 --&gt; SSH 隧道 --&gt; 远程内网IP:服务端口</li>\n</ul>\n<p><strong>在终端执行命令：</strong>ssh -L 16379:127.0.0.1:6379 root@8.145.45.70</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"225\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"637\" /></p>\n<p><strong>验证本地端口是否生效：netstat -ano | findstr 16379</strong></p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"111\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"612\" /></p>\n<p>验证方式最简单，检查本地端口是否处于监听状态。如上图，本地的16379已经处于LISTENING状态。</p>\n<p>执行完成后：SSH 连接会保持，本地端口开始监听，所有访问都会被转发。此时你“看起来什么都没做”，但通道已经打通了。</p>\n<p>&nbsp;</p>\n<p>在上面的开启本地端口转发的图片中，你可能发现了这个SSH链接进入了交互式的Shell Terminal，要是我不想进入这种交互式的终端，应该怎么做呢？</p>\n<p><strong>不打开交互式对话：</strong>ssh -N -L 16379:127.0.0.1:6379 root@8.145.45.70</p>\n<ul>\n<li>-N：不执行远程命令（只做端口转发）</li>\n<li>更安全、更清晰</li>\n</ul>\n<p><strong>放到后台运行：</strong>ssh -f -N -L 16379:127.0.0.1:6379 user@server_ip</p>\n<ul>\n<li>-f：放到后台</li>\n<li>用完记得杀掉进程：tasklist + taskkill / ps + kill</li>\n</ul>\n<h2><strong><u>远程访问</u></strong></h2>\n<p>接下来是最“反直觉但最爽”的一步：</p>\n<ul>\n<li>不再使用内网 IP，也不再使用远程服务器 IP，而统一使用： 127.0.0.1 或 localhost</li>\n<li>端口使用你刚刚在本地绑定的端口</li>\n</ul>\n<p>&nbsp;</p>\n<p>本地使用已安装的&nbsp;redis-cli&nbsp;工具连接Redis：redis-cli -h 127.0.0.1 -p 16379</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"120\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"996\" /></p>\n<p>使用 GUI 客户端（Another Redis Desktop Manager）连接远程Redis</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"285\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"879\" /></p>\n<h2><strong><u>QA</u></strong></h2>\n<p><strong>报错：prohibited</strong></p>\n<p>channel X: open failed: administratively prohibited</p>\n<p>channel 3: open failed: administratively prohibited: open failed</p>\n<p>原因：管理员禁止了你使用端口转发</p>\n<p>解决：sshd_config 中禁用了端口转发</p>\n<ul>\n<li>AllowTcpForwarding no &nbsp;#应该改为yes</li>\n<li>AllowAgentForwarding no &nbsp;#应该改为yes</li>\n<li>PermitTunnel no &nbsp;#应该改为yes</li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>报错：Connection timed out</strong></p>\n<p>原因：连接超时，网络问题</p>\n<p>解决：检查网络是否连通、防火墙是否开放</p>\n<p>&nbsp;</p>\n<p><strong>我有MySQL、redis、kafka都要进行本地端口转发，可以只有一个端口吗？</strong></p>\n<p>不行。</p>\n<p>SSH 本地端口转发是：一个本地端口 与 一个远程地址:端口 是一对一映射。</p>\n<p>一条命令同时开启转发：ssh user@server \\</p>\n<p>&nbsp;&nbsp;-L 13306:127.0.0.1:3306 \\</p>\n<p>&nbsp;&nbsp;-L 16379:127.0.0.1:6379 \\</p>\n<p>&nbsp;&nbsp;-L 19092:127.0.0.1:9092</p>\n<p>&nbsp;</p>\n<p><strong>连不上 Redis，但 SSH 没报错？</strong></p>\n<ul>\n<li>检查Redis 是否监听 127.0.0.1</li>\n<li>是否启用了密码</li>\n<li>是否限制 protected-mode</li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>在使用过程中，是否</strong><strong>SSH 连接必须保持</strong><strong>？</strong></p>\n<ul>\n<li>是的</li>\n<li>SSH 断开 = 隧道失效，本地工具会立即连不上</li>\n<li>建议单独开一个终端，专门用于维护 SSH 隧道</li>\n<li>根据场景考虑是-N、-f参数</li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>为什么有些公司的安全团队会关闭SSH的端口转发？</strong></p>\n<ul>\n<li>SSH 端口转发 = 隐形隧道</li>\n<li>可绕过防火墙 / 网关 / 审计</li>\n<li>本地流量进了内网，难以追踪</li>\n<li>容易被当成内网代理滥用</li>\n<li>场景配置：\n<ul>\n<li>AllowTcpForwarding no</li>\n<li>AllowAgentForwarding no</li>\n<li>PermitTunnel no</li>\n<li>X11Forwarding no #是否允许把“远程服务器上的图形界面程序”，转发到你本地屏幕上显示。</li>\n</ul>\n</li>\n</ul>\n<p><strong>额外提醒：</strong></p>\n<ul>\n<li>SSH隧道用完即关，本地端口立即释放，不留任何后门</li>\n<li>妥善保管SSH连接密码、私钥</li>\n</ul>\n<h1><strong><u>多级跳板</u></strong></h1>\n<p>企业服务器通常有以下特点：</p>\n<ul>\n<li>内网环境，不直接暴露公网</li>\n<li>安全要求高，必须对访问进行审计</li>\n<li>多人运维或开发团队共用服务器</li>\n<li>不允许直接暴露管理端口</li>\n</ul>\n<p>问题：如果你直接 SSH 登录内网服务器，就会导致</p>\n<ul>\n<li>没有日志记录</li>\n<li>难以审计操作</li>\n<li>可能导致安全风险</li>\n</ul>\n<p>解决方案就是：在公网部署一台或多台跳板机 (Bastion / JumpServer)，通过 SSH 间接访问目标服务器。接下来，我们一起探索如何在一台和多台跳板机上实现端口转发。</p>\n<h2><strong><u>一级跳板</u></strong></h2>\n<p>通过跳板机（Jump Host / Bastion Host），利用 SSH 作为中转，访问内网里的目标服务器。</p>\n<p><strong>一级跳板的网络结构：</strong></p>\n<p><strong><img alt=\"image\" class=\"lazyload\" height=\"227\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"517\" /></strong></p>\n<p><strong>实现方式一：手动两次SSH逐步跳转</strong></p>\n<ul>\n<li>第一步：先登录跳板机：ssh jump_user@jump_host</li>\n<li>第二步：在跳板机上，再 SSH 到目标服务器：ssh target_user@target_host</li>\n</ul>\n<p><strong>实现方式二：</strong><strong>-J</strong><strong>语法实现</strong></p>\n<p>语法：ssh -J jump_user@jump_host target_user@target_host</p>\n<p>例如：ssh -NT -L 3306:127.0.0.1:3306 -J jump_user@jump_host target_user@target_host</p>\n<ul>\n<li>-L 3306:127.0.0.1:3306 &nbsp;本地 3306 → 目标3306</li>\n<li>-J jump_user@jump_host &nbsp;先跳到跳板机</li>\n<li>target_user@target_host 再连到目标机</li>\n<li>-N &nbsp;不执行远程命令</li>\n<li>-T &nbsp;不分配 TTY</li>\n<li>仅支持OpenSSH（7.3+）</li>\n</ul>\n<p><strong>实现方式三：</strong><strong>-o</strong><strong>语法实现</strong></p>\n<p>语法：ssh -o ProxyCommand=\"ssh jump_user@jump_host -W %h:%p\" target_user@target_host</p>\n<p>例如：ssh -NT -L 3306:127.0.0.1:3306 -o ProxyCommand=\"ssh jump_user@jump_host -W %h:%p\" target_user@target_host</p>\n<ul>\n<li>如果 SSH 版本 &lt; 7.3（没有 -J）</li>\n<li><strong>注意是小写的o</strong></li>\n</ul>\n<h2><strong><u>二级跳板</u></strong></h2>\n<p><strong>二级跳板的网络结构：</strong></p>\n<p><strong><img alt=\"image\" class=\"lazyload\" height=\"214\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"533\" /></strong></p>\n<p><strong>实现方式一：</strong><strong>-J</strong><strong>语法实现</strong></p>\n<p>ssh -J user1@jump1,user2@jump2 user3@target</p>\n<p>例子：ssh -NT -L 3306:127.0.0.1:3306&nbsp;-J user1@jump1,user2@jump2 user3@target</p>\n<ul>\n<li>跳板机之间连续写，逗号分割</li>\n<li>注意：跳板机前后顺序非常重要，按网络进入方向写。</li>\n<li>-L 3306:127.0.0.1:3306 &nbsp;本地 3306 → 目标3306</li>\n<li>-N &nbsp;不执行远程命令</li>\n<li>-T &nbsp;不分配 TTY</li>\n<li>仅支持OpenSSH（7.3+）</li>\n</ul>\n<p><strong>实现方式二：</strong><strong>-o</strong><strong>语法实现</strong></p>\n<p>语法：ssh -o ProxyCommand=\"ssh user1@jump1 \\</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-o ProxyCommand='ssh user2@jump2 \\</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-o ProxyCommand=\\\"ssh user3@jump3 -W %h:%p\\\" -W %h:%p' \\</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-W %h:%p\" \\</p>\n<p>&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;user4@target</p>\n<ul>\n<li>注意引号，最外层是双引号，内层是单引号，区分引号的边界</li>\n<li>命令太复杂了，维护起来很难</li>\n<li>不推荐使用</li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>三级跳板？</strong></p>\n<p>语法：ssh -J jump1,jump2,jump3 target</p>\n<p><strong>注意点：-J后面跟跳板机，注意顺序</strong></p>\n<h1><strong><u>服务部署在Docker上</u></strong></h1>\n<p><strong>如果你的内网服务部署在Docker上，如何实现SSH的本地转发呢？</strong></p>\n<p>两种情况</p>\n<ul>\n<li>容器的端口映射到了宿主机</li>\n<li>容器的端口没有映射到了宿主机</li>\n</ul>\n<h2><strong><u>映射到了宿主机</u></strong></h2>\n<p><strong>Redis</strong><strong>容器的端口映射到了宿主机</strong></p>\n<ul>\n<li>在启动容器时指定了端口映射：docker run -d --name redis-server-16379 -p 16379:6379 redis:7</li>\n<li>SSH本地端口转发直接参考上文中的执行步骤。因为相当于宿主机的16379号端口上工作了Redis服务，对于我们来说，跟Redis直接运行于宿主机上没有区别。</li>\n</ul>\n<p><strong>执行步骤</strong></p>\n<ul>\n<li>环境准备\n<ul>\n<li>进入远程服务器，启动一个Redis Docker：docker run -d --name redis-server-16379 -p 16379:6379 redis:7</li>\n<li>进入容器:docker exec -it redis-server-16379 /bin/bash</li>\n<li>往容器中的Redis塞入一个键值对：set name hackyle</li>\n</ul>\n</li>\n</ul>\n<p><strong><img alt=\"image\" class=\"lazyload\" height=\"369\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"713\" /></strong></p>\n<p><strong><img alt=\"image\" class=\"lazyload\" height=\"199\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"881\" /></strong></p>\n<ul>\n<li>在本台机器上开启本地端口转发：ssh -NT -L 16379:127.0.0.1:16379 <a href=\"mailto:root@8.145.45.70\" rel=\"noopener nofollow\"><u>root@8.145.45.70</u></a></li>\n</ul>\n<p><strong><img alt=\"image\" class=\"lazyload\" height=\"176\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"569\" /></strong></p>\n<ul>\n<li><strong>验证：在本台机器上连接16379端口，访问到远程Docker中的Redis</strong></li>\n</ul>\n<p><strong><img alt=\"image\" class=\"lazyload\" height=\"246\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"671\" /></strong></p>\n<h2><strong><u>未映射到宿主机</u></strong></h2>\n<p><strong>MySQL容器的端口没有映射到了宿主机</strong></p>\n<ul>\n<li>先查看容器 IP：docker inspect mysql | grep IPAddress</li>\n<li>再SSH 本地端口转发，直接指向容器 IP：ssh -L 3306:172.17.0.3:6379user@remote-host</li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>执行步骤</strong></p>\n<p>1.环境准备</p>\n<ul>\n<li>进入远程服务器，启动一个Redis Docker：docker run -d --name redis-server-26379 redis:7</li>\n<li>查看容器IP：docker inspect redis-server-26379 | grep IPAddress</li>\n<li>进入容器:docker exec -it redis-server-16379 /bin/bash</li>\n<li>往容器中的Redis塞入一个键值对：set name hackyleshawe</li>\n</ul>\n<p><strong><img alt=\"image\" class=\"lazyload\" height=\"315\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"908\" /></strong></p>\n<p>2. 在本台机器上开启本地端口转发：ssh -NT -L 26379:172.17.0.3:6379 <a href=\"mailto:root@8.145.45.70\" rel=\"noopener nofollow\"><u>root@8.145.45.70</u></a></p>\n<ul>\n<li>本地端口使用26379，转发的目标是docker的IP</li>\n<li>docker redis运行的端口时6379，所以“-L 26379:172.17.0.3:6379”</li>\n</ul>\n<p><strong><img alt=\"image\" class=\"lazyload\" height=\"200\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"820\" /></strong></p>\n<p><strong>3.验证：在本台机器上连接26379端口，访问到远程Docker中的Redis</strong></p>\n<p><strong><img alt=\"image\" class=\"lazyload\" height=\"329\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"826\" /></strong></p>\n<h1><strong><u>结尾</u></strong></h1>\n<p>本文主要阐述了用SSH访问远程服务器上的内网服务（如：Redis）的原理和操作步骤，同时对部署在Docker中的服务如何访问也做了解释说明。</p>\n<p>在文章最后，尝试对自己提问一下问题，来检验你是否真正了解到了本文的核心内容：</p>\n<ul>\n<li>什么是SSH的本地端口转发(Local Port Forwarding）？</li>\n<li>他能做什么？能帮你解决什么问题？</li>\n<li>怎么使用？语法是什么？</li>\n<li>内网服务部署在Docker和宿主机，使用端口转发访问时有什么区别？</li>\n</ul>\n<p>本文结束。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 23:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hackyle\">ALGO阿狗</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从零开始实现一个简易json解析器",
      "link": "https://www.cnblogs.com/xiaoxiongcanguan/p/19605794",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoxiongcanguan/p/19605794\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 20:23\">\n    <span>从零开始实现一个简易json解析器</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"从零开始实现一个简易json解析器\">从零开始实现一个简易json解析器</h1>\n<h2 id=\"1-mysimplejsonparser-介绍与整体设计\">1. MySimpleJsonParser 介绍与整体设计</h2>\n<p>最近在学习编译原理相关的知识。为了加深对词法分析、语法分析阶段中诸如<strong>有限自动机、自顶向下语法分析、AST</strong> 等概念的理解，我选择实现一个json解析器作为练手机会。</p>\n<h5 id=\"_\"></h5>\n<p>相比直接实现一门完整的编程语言，将json解析作为练手对象有几个明显优势：</p>\n<ol>\n<li><strong>几乎零额外学习成本</strong>：json作为一种轻量级的数据交换格式是日常开发中使用最频繁的数据格式之一。</li>\n<li><strong>文法足够简单</strong>：对于编译原理入门者来说，若选择的语言太复杂，很容易在词法/语法规则上被劝退；而json的词法和语法比较规整，语法分析时通常只需根据下一个token即可决定AST的构造方向。</li>\n<li><strong>无需运行时</strong>：json不是编程语言，其完全不需要后端的运行时。只要能把json文本转换成正确的AST就已经算完成任务，在此基础上实现一个基于AST的Pretty JSON输出，就能产生一定的成就感。</li>\n</ol>\n<h5 id=\"_-1\"></h5>\n<p>在本篇博客中，我们将基于<strong>java语言</strong>，不依赖任何第三方库，从零开始实现一个简单的json解析器：<strong>MySimpleJsonParser</strong>。其包括以下几个主要模块：</p>\n<ol>\n<li><strong><code>StaticJsonLexer</code></strong>：一次性解析出全部token的静态json词法分析器</li>\n<li><strong><code>StreamJsonLexer</code></strong>：按需惰性解析token的流式json词法分析器</li>\n<li><strong><code>RecursiveJsonParser</code></strong>：基于递归的json语法解析器</li>\n<li><strong><code>StackBaseJsonParser</code></strong>：基于显式堆栈的json语法解析器（非递归）</li>\n<li><strong><code>AST结构</code></strong>：JsonElement及其子类，并基于AST生成Pretty JSON字符串的工具方法</li>\n</ol>\n<h2 id=\"2-从文法到词法分析器手写-json-lexer\">2. 从文法到词法分析器：手写 json lexer</h2>\n<p>词法分析阶段的任务是：将原始的字符流，按照json的词法规则，转换为token流。之后的语法分析会在token流的基础上按文法规则构建AST。</p>\n<h3 id=\"21-json文法与基本结构\">2.1 json文法与基本结构</h3>\n<p>根据<a href=\"https://www.json.org/json-en.html\" rel=\"noopener nofollow\" target=\"_blank\"><strong>json官方文档</strong></a>，json中主要包含以下几类结构：</p>\n<ol>\n<li><strong>string</strong>：由双引号包住的Unicode字符串，可包含转义字符。一个字符（character）也可以是一个单独的字符串（character string）。</li>\n<li><strong>number</strong>：以<code>0</code>或<code>-</code>开头，可以是整数、小数、、负数或者是包含一个E/e符号的指数。</li>\n<li><strong>object</strong>：以“<code>{</code>” 开头，以“<code>}</code>”结尾。</li>\n<li><strong>array</strong>：以“<code>[</code>” 开头，以“<code>]</code>”结尾。</li>\n<li><strong>value</strong>：可以是string、number、<code>true</code>(关键字)、<code>false</code>(关键字)、<code>null</code>(关键字)、object或者array。</li>\n<li><strong>whitespace</strong>：由任意个space空格、linefeed换行符、carriage return回车符以及tab制表符组成，本身无意义，仅起到分割的作用。</li>\n</ol>\n<h5 id=\"_-2\"></h5>\n<ul>\n<li>仔细分析后，发现string结构、number结构和whitespace结构以及<code>{</code>、<code>}</code>、<code>[</code>、<code>]</code> 这类符号都是基本结构，是自身无法再嵌套其它结构的基本单元，因此其都是最终AST中的叶子节点，而object、array和value都是可以互相嵌套的复合结构，其都是AST中的非叶子节点。</li>\n<li>对于这些可嵌套的非AST叶子节点，必须在语法分析中才能完成解析；而string结构、number结构、false、true、null关键字以及“{”、“]”等特殊符号，则适合在词法分析中完成解析。<br />\n因为json语法中，无论原始的json字符串中一个number字面量有多复杂(比如-2.03214e+6605218)，在语法分析中都只需要当做一个完整的number类型的token来处理即可。</li>\n<li>词法分析专注于局部，将原始的字符流按照词法规则正确的转换为token流；而语法分析则专注于将token流按照语法规则转换为正确的AST树结构。<br />\n通过将整个分析流程，有机的分解为词法分析和语法分析等等不同步骤，每个步骤都依赖于前一个步骤的产出的分层设计，能够很好的控制解析器整体的复杂度，方便调试的同时性能上也有很大的提升。<br />\n因此，除了少数非常简单的语言外，几乎所有的编译器都会采用分层的架构来实现整体的功能。</li>\n</ul>\n<h3 id=\"22-token类型定义\">2.2 token类型定义</h3>\n<p>从文法角度，json中允许的token类型大致可分为三类：</p>\n<ol>\n<li>特殊符号：诸如“<code>{</code>”、“<code>}</code>”、“<code>[</code>”、“<code>]</code>”、“<code>,</code>”,“<code>:</code>”,“<code>\"</code>”等独立的字符是json中的特殊符号</li>\n<li>关键字：完整且独立的<code>true</code>、<code>false</code>、<code>null</code>被视为关键字</li>\n<li>字面量：number、string这两种复杂字符流字面量</li>\n</ol>\n<h5 id=\"_-3\"></h5>\n<p>因此我们可以先定义出json的token类型枚举。其中EOF类型是额外的，用于在完成整个字符流的词法分析后，追加到token流的最后，标志着token流的结束。</p>\n<pre><code class=\"language-java\">public enum JsonTokenTypeEnum {\n    LEFT_BRACE(\"{\"),\n    RIGHT_BRACE(\"}\"),\n\n    LEFT_BRACKET(\"[\"),\n    RIGHT_BRACKET(\"]\"),\n\n    COMMA(\",\"),\n    COLON(\":\"),\n\n    TRUE(\"true\"),\n    FALSE(\"false\"),\n    NULL(\"null\"),\n\n    STRING(\"string\"),\n    NUMBER(\"number\"),\n\n    EOF(\"EOF\"),\n    ;\n    private final String key;\n\n    JsonTokenTypeEnum(String key) {\n        this.key = key;\n    }\n\n    public String getKey() {\n        return key;\n    }\n}\n</code></pre>\n<h3 id=\"23-词法分析器整体框架与特殊字符的词法分析\">2.3 词法分析器整体框架与特殊字符的词法分析</h3>\n<p>现在我们已经知道诸如“{”、“]”等独立字符是json中的特殊符号，但是当我们在字符流中遇到了一个“{”字符时，并不能无脑的将其作为一个LEFT_BRACE类型的token来处理。因为如果其是被双引号包裹的，作为string类型token内容的一部分，那么就并不能将其直接当做独立的token来对待。<br />\n所以，词法分析中一般使用有限状态自动机来解决此类“同一字符在不同上下文含义不同”的问题，在判断如何处理字符流时并不仅仅取决于下一个字符是什么，而还要结合当前自动机的状态来决定行为。<br />\n以上述对“{”字符的处理为例，如果是在初始化状态下(已经完成了一个完整token的解析,准备开始解析下一个新token)，碰到“{”字符时可以确定的将其转化为LEFT_BRACE类型的token，但是当自动机处于string类型token的解析状态时，则需要将其作为string类型token内容的一部分。</p>\n<h5 id=\"json词法分析自动机总览图\">json词法分析自动机总览图</h5>\n<p>基于官方文档中的json文法规则，我们可以设计出一个如下图所示的json有限状态自动机来实现我们的词法分析。<br />\n<img alt=\"lexer_total\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195126490-433213565.png\" /></p>\n<h5 id=\"_-4\"></h5>\n<ul>\n<li>在json解析一开始，自动机位于状态0，随后便会基于字符流的下一个字符的类型进行状态转换，在读取到诸如“{”、“[”、“,”等独立符号时，便会直接接收该字符，推进字符流，同时生成对应类型的token。</li>\n<li>在完整的解析出一个完整token后，自动机便会重新回到状态0，准备尝试解析下一个新的token。状态0只能合法的接收有限种类的字符，对于不符合json文法的字符将认为当前字符流不是合法的json字符串而直接报错，退出解析。</li>\n<li>对于更复杂的string类型、number类型token的解析，我们放在后面的小节再展开，总览图中暂时省略。</li>\n</ul>\n<h5 id=\"静态的词法分析器实现\">静态的词法分析器实现</h5>\n<pre><code class=\"language-java\">public class StaticJsonLexer extends AbstractJsonLexer{\n\n    public StaticJsonLexer(String jsonString) {\n        super(jsonString);\n    }\n\n    /**\n     * 一次完整的扫描，非流式的处理\n     * */\n    public List&lt;JsonToken&gt; doLex(){\n        char[] chars = super.jsonStringArray;\n\n        // 相当于是状态0\n        while(doLexContext.currentIndex &lt; chars.length){\n            char ch = chars[doLexContext.currentIndex];\n\n            switch(ch){\n                case '{':\n                    doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.LEFT_BRACE));\n                    doLexContext.currentIndex++;\n                    break;\n                case '}':\n                    doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.RIGHT_BRACE));\n                    doLexContext.currentIndex++;\n                    break;\n                case '[':\n                    doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.LEFT_BRACKET));\n                    doLexContext.currentIndex++;\n                    break;\n                case ']':\n                    doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.RIGHT_BRACKET));\n                    doLexContext.currentIndex++;\n                    break;\n                case ',':\n                    doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.COMMA));\n                    doLexContext.currentIndex++;\n                    break;\n                case ':':\n                    doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.COLON));\n                    doLexContext.currentIndex++;\n                    break;\n                case '\"':\n                    doLexContext.tokenCollector.add(parseString(chars, doLexContext));\n                    break;\n                case 't':\n                    // 尝试解析true关键字\n                    doLexContext.tokenCollector.add(parseTrueKeyword(chars, doLexContext));\n                    break;\n                case 'f':\n                    // 尝试解析false关键字\n                    doLexContext.tokenCollector.add(parseFalseKeyword(chars, doLexContext));\n                    break;\n                case 'n':\n                    // 尝试解析null关键字\n                    doLexContext.tokenCollector.add(parseNullKeyword(chars, doLexContext));\n                    break;\n                default:\n                    // 其它case\n                    if(ch == '-' || CommonStringUtil.is0_9(ch)){\n                        // number解析\n                        JsonToken numberToken = parseNumber(chars, doLexContext);\n                        doLexContext.tokenCollector.add(numberToken);\n                        break;\n                    }else if(CommonStringUtil.isWhitespace(ch)){\n                        // whiteSpace 直接跳过\n                        doLexContext.currentIndex++;\n                        break;\n                    }else{\n                        throw new MuJsonParserException(\"unexpected character: \" + ch + \" at index \" + doLexContext.currentIndex);\n                    }\n            }\n        }\n\n        // 最后加上EOF\n        doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.EOF));\n        return doLexContext.tokenCollector;\n    }\n}\n</code></pre>\n<p>抽象父类<code>AbstractJsonLexer</code>封装了string/number/keyword等具体类型的公共解析逻辑：</p>\n<pre><code class=\"language-java\">public abstract class AbstractJsonLexer {\n\n    protected final char[] jsonStringArray;\n\n    protected final DoLexContext doLexContext;\n\n    public AbstractJsonLexer(String jsonString) {\n        this.jsonStringArray = jsonString.toCharArray();\n        this.doLexContext = new DoLexContext();\n    }\n\n    protected JsonToken parseNumber(char[] chars, DoLexContext doLexContext){\n        // number类型的内容\n        String numberStr = new NumberLexStatemachine().tryParse(chars,doLexContext);\n\n        return new JsonToken(JsonTokenTypeEnum.NUMBER, numberStr);\n    }\n\n    protected JsonToken parseString(char[] chars, DoLexContext doLexContext){\n        // string类型的内容\n        String stringStr = new StringLexStatemachine().tryParse(chars,doLexContext);\n\n        return new JsonToken(JsonTokenTypeEnum.STRING, stringStr);\n    }\n\n    protected JsonToken parseTrueKeyword(char[] chars, DoLexContext doLexContext){\n        // true关键字\n        String stringStr = new KeywordTrueLexStatementMachine().tryParse(chars,doLexContext);\n\n        return new JsonToken(JsonTokenTypeEnum.TRUE, stringStr);\n    }\n\n    protected JsonToken parseFalseKeyword(char[] chars, DoLexContext doLexContext){\n        // false关键字\n        String stringStr = new KeywordFalseLexStatementMachine().tryParse(chars,doLexContext);\n\n        return new JsonToken(JsonTokenTypeEnum.FALSE, stringStr);\n    }\n\n    protected JsonToken parseNullKeyword(char[] chars, DoLexContext doLexContext){\n        // null关键字\n        String stringStr = new KeywordNullLexStatementMachine().tryParse(chars,doLexContext);\n\n        return new JsonToken(JsonTokenTypeEnum.NULL, stringStr);\n    }\n}\n</code></pre>\n<h5 id=\"_-5\"></h5>\n<ul>\n<li>为了支持后续流式的词法分析器，静态的词法分析器StaticJsonLexer继承自AbstractJsonLexer类，构造方法中接收一个字符串，并通过方法doLex进行解析，返回一次性完整解析字符串后的token列表。</li>\n<li>doLex方法中是一个while循环，每一次循环开始都相当于是自动机位于状态0，在解析时会通过自增currentIndex不断地推进字符流，成功解析出完整的token后便会将新的token保存到上下文中的tokenCollector中。只有在解析报错或者成功完成了整个字符串的解析后才会退出循环。</li>\n<li>在正常退出while循环后，doLex方法返回前token集合的尾部会追加一个特殊的EOF类型的token，用于告知下一阶段的parser已经解析到了token流的末尾，该结束解析了。</li>\n</ul>\n<h3 id=\"24-number类型的词法分析\">2.4 number类型的词法分析</h3>\n<p>number的词法规则相对复杂，因为number类型作为json中表示数字的组件，其可以是整数，也可以是小数、负数，同时还可以是带符号e/E的指数形式。</p>\n<h5 id=\"json-number类型token的词法规则\">json number类型token的词法规则</h5>\n<pre><code>number\n    integer fraction exponent\n\ninteger\n    digit\n    onenine digits\n    '-' digit\n    '-' onenine digits\n\ndigits\n    digit\n    digit digits\n\ndigit\n    '0'\n    onenine\n\nonenine\n    '1' . '9'\n\nfraction\n    \"\"\n    '.' digits\n\nexponent\n    \"\"\n    'E' sign digits\n    'e' sign digits\n\nsign\n    \"\"\n    '+'\n    '-'\n</code></pre>\n<p><img alt=\"json_number_lex_rule\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195806369-790385529.png\" /></p>\n<h5 id=\"_-6\"></h5>\n<p>基于上述词法规则，我们可以构造出如下图所示的用于解析number类型token的状态自动机。</p>\n<h5 id=\"number类型解析的状态自动机示意图\">number类型解析的状态自动机示意图</h5>\n<p><img alt=\"json_number_lex_state_machine\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211201818452-99218238.png\" /></p>\n<h5 id=\"_-7\"></h5>\n<p>设计好上述的状态自动机后，就可以按照图中的状态转移关系手写一个简单的状态机来解析number类型的token了。</p>\n<h5 id=\"number类型解析状态机实现源码\">number类型解析状态机实现源码</h5>\n<pre><code class=\"language-java\">public class NumberLexStatemachine extends LexStatementMachine{\n\n    private static final Map&lt;Integer,Boolean&gt; staticFinalStateMap;\n    private static final LexStateHandler[] lexStateHandlers;\n\n    static{\n        staticFinalStateMap = new HashMap&lt;&gt;();\n        staticFinalStateMap.put(-1,true);\n        staticFinalStateMap.put(1,true);\n        staticFinalStateMap.put(2,false);\n        staticFinalStateMap.put(3,true);\n        staticFinalStateMap.put(4,true);\n        staticFinalStateMap.put(5,false);\n        staticFinalStateMap.put(6,true);\n        staticFinalStateMap.put(7,false);\n        staticFinalStateMap.put(8,false);\n        staticFinalStateMap.put(9,true);\n\n        lexStateHandlers = new LexStateHandler[]{\n            new State0Handler(), new State1Handler(), new State2Handler(), new State3Handler(), new State4Handler(),\n            new State5Handler(),new State6Handler(),new State7Handler(),new State8Handler(),new State9Handler()\n        };\n    }\n\n    public NumberLexStatemachine() {\n        this.stateHandlers = lexStateHandlers;\n        this.isFinalStateMap = staticFinalStateMap;\n    }\n\n    private static abstract class NumberLexStateHandler implements LexStateHandler {\n\n        @Override\n        public int processInState(char[] chars, DoLexContext doLexContext, LexStatementMachine lexStatementMachine, StringBuilder oneTokenAcceptResult) {\n            char currentChar = chars[doLexContext.currentIndex];\n\n            // whitespace符号以及number后合法的终结符\n            if(CommonStringUtil.isWhitespace(currentChar)\n                || currentChar == ']' || currentChar == '}' || currentChar == ',' || currentChar == ':'){\n                if(lexStatementMachine.currentStateIsFinal()){\n                    // 结束number的解析\n                    return -1;\n                }else{\n                    // 遇到了分隔符，但是当前number解析的状态不是终态，无法转换为一个合法的number类型的token，抛异常\n                    throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n                }\n            }\n\n            return doProcessInState(currentChar,doLexContext, oneTokenAcceptResult);\n        }\n\n        abstract int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult);\n    }\n\n    private static class State0Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '0'){\n                // accept\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                // 进入状态1\n                return 1;\n            }\n\n            if(currentChar == '-'){\n                // accept\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                // 进入状态2\n                return 2;\n            }\n\n            if(CommonStringUtil.is1_9(currentChar)){\n                // accept\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                // 进入状态3\n                return 3;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State1Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '.'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 5;\n            }\n\n            if(currentChar == 'e' || currentChar == 'E'){\n                accept(currentChar,doLexContext, oneTokenAcceptResult);\n                return 7;\n            }\n\n            throw new MuJsonParserException(\"unexpected char '\" + currentChar + \"', index=\" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State2Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '0'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 1;\n            }\n\n            if(CommonStringUtil.is1_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 3;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State3Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '.'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 5;\n            }\n\n            if(currentChar == 'e' || currentChar == 'E'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 7;\n            }\n\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 4;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State4Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext,StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '.'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 5;\n            }\n\n            if(currentChar == 'e' || currentChar == 'E'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 7;\n            }\n\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 4;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State5Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 6;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State6Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext,StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 6;\n            }\n\n            if(currentChar == 'e' || currentChar == 'E'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 7;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State7Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext,StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 9;\n            }\n\n            if(currentChar == '-' || currentChar == '+'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 8;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State8Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 9;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State9Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 9;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n}\n\n</code></pre>\n<pre><code class=\"language-java\">public abstract class LexStatementMachine {\n\n    protected int currentState = 0;\n    protected StringBuilder oneTokenAcceptResult = new StringBuilder();\n\n    protected LexStateHandler[] stateHandlers;\n    protected Map&lt;Integer,Boolean&gt; isFinalStateMap;\n\n    public String tryParse(char[] chars, DoLexContext doLexContext){\n        doParse(chars,doLexContext);\n\n        boolean isFinalState = isFinalStateMap.get(currentState);\n        if(isFinalState){\n            return oneTokenAcceptResult.toString();\n        }else{\n            throw new MuJsonParserException(String.format(\"currentState is not finalState! acceptResult=%s, acceptResult=%s\",currentState, oneTokenAcceptResult));\n        }\n    }\n\n    public boolean currentStateIsFinal(){\n        return isFinalStateMap.get(currentState);\n    }\n\n    protected static void accept(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult){\n        oneTokenAcceptResult.append(currentChar);\n        doLexContext.currentIndex++;\n    }\n\n    private void doParse(char[] chars, DoLexContext doLexContext){\n        // 一进来是状态0\n        while(doLexContext.currentIndex &lt; chars.length){\n            if(currentState == -1){\n                // 遇到了合法的分隔符号，退出token解析\n                return;\n            }\n\n            if(currentState &gt;= stateHandlers.length){\n                // 有bug\n                throw new MuJsonParserException(String.format(\"unknown state! currentState=%s\",currentState));\n            }\n            LexStateHandler targetStateHandler = stateHandlers[currentState];\n            \n            currentState = targetStateHandler.processInState(chars,doLexContext,this,oneTokenAcceptResult);\n        }\n    }\n}\n</code></pre>\n<h5 id=\"_-8\"></h5>\n<ul>\n<li>NumberLexStatemachine继承自父类LexStatementMachine。在LexStatementMachine中与doLex方法类似，也是一个while循环来反复的处理每一次的状态跳转。</li>\n<li>子类NumberLexStatemachine定义了一系列的LexStateHandler状态处理器，每一个状态处理器都对应状态机示意图中的一个状态。</li>\n<li>每一个LexStateHandler中的功能都比较类似，即决定在当前状态下自己能够接收的字符类型，以及控制在合法接收字符流当前字符后应该跳转的下一个状态是什么。<br />\n在合法接收字符时，会修改上下文中的当前字符指针以推进字符流，同时将接受到的当前合法字符追加到oneTokenAcceptResult中。</li>\n<li>如果遇到了合法的结束分隔符，比如whitespace或者“}”、“]”之类的字符，且当前状态是属于number解析的终态，则NumberLexStateHandler会返回-1，终止当前token的解析。(比如{\"number\":-123.0}结束时的状态是6，6是终态，所以其是合法的json串)<br />\n如果状态处理器中遇到当前状态下不合法的字符，或者在退出解析时当前状态不属于number解析的终态，说明当前字符串不是合法的json串，则会直接抛出异常，退出词法解析。(比如{\"number\":-123.}结束时的状态是5,5不是终态，所以其是不合法的json串)</li>\n<li>NumberLexStatemachine状态机正常退出当前number类型token后，返回收集到的所有字符oneTokenAcceptResult，作为number类型的字面量返回。</li>\n</ul>\n<h3 id=\"25-string类型的词法分析\">2.5 string类型的词法分析</h3>\n<p>string类型的词法规则相比之下比较简单，要求以双引号开头，并以双引号结尾即可，但需要额外处理转义字符相关的逻辑。</p>\n<h5 id=\"json-string类型token的词法规则\">json string类型token的词法规则</h5>\n<pre><code>string\n    '\"' characters '\"'\n\ncharacters\n    \"\"\n    character characters\n\ncharacter\n    '0020' . '10FFFF' - '\"' - '\\'\n    '\\' escape\n\nescape\n    '\"'\n    '\\'\n    '/'\n    'b'\n    'f'\n    'n'\n    'r'\n    't'\n    'u' hex hex hex hex\n\nhex\n    digit\n    'A' . 'F'\n    'a' . 'f'\n</code></pre>\n<p><img alt=\"json_string_lex_rule\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195844242-1192651121.png\" /></p>\n<h5 id=\"_-9\"></h5>\n<p>基于上述词法规则，我们构造出如下图所示的用于解析string类型token的状态自动机。</p>\n<h5 id=\"string类型解析的状态自动机示意图\">string类型解析的状态自动机示意图</h5>\n<p><img alt=\"json_string_lex_state_machine\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195854133-180088812.png\" /></p>\n<h5 id=\"string类型解析状态机实现源码\">string类型解析状态机实现源码</h5>\n<pre><code class=\"language-java\">public class StringLexStatemachine extends LexStatementMachine{\n\n    private static final Map&lt;Integer,Boolean&gt; staticFinalStateMap;\n    private static final LexStateHandler[] lexStateHandlers;\n\n    static{\n        staticFinalStateMap = new HashMap&lt;&gt;();\n        staticFinalStateMap.put(-1,true);\n        staticFinalStateMap.put(1,false);\n        staticFinalStateMap.put(2,true);\n        staticFinalStateMap.put(3,false);\n        staticFinalStateMap.put(4,false);\n        staticFinalStateMap.put(5,false);\n        staticFinalStateMap.put(6,false);\n        staticFinalStateMap.put(7,false);\n\n        lexStateHandlers = new LexStateHandler[]{\n            new State0Handler(),new State1Handler(),new State2Handler(),new State3Handler(),new State4Handler(),\n            new State5Handler(),new State6Handler(),new State7Handler()};\n    }\n\n    public StringLexStatemachine() {\n        this.stateHandlers = lexStateHandlers;\n        this.isFinalStateMap = staticFinalStateMap;\n    }\n\n    private static abstract class StringLexStateHandler implements LexStateHandler {\n\n        @Override\n        public int processInState(char[] chars, DoLexContext doLexContext, LexStatementMachine lexStatementMachine, StringBuilder oneTokenAcceptResult) {\n            char currentChar = chars[doLexContext.currentIndex];\n\n            return doProcessInState(currentChar,doLexContext,oneTokenAcceptResult);\n        }\n\n        abstract int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult);\n    }\n\n    private static class State0Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '\"'){\n                // accept\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                // 进入状态1\n                return 1;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State1Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '\"'){\n                // accept\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                // 进入状态2\n                return 2;\n            }\n\n            if(currentChar == '\\\\'){\n                // accept\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                // 进入状态3\n                return 3;\n            }\n\n            // 控制字符是不合法的，不能出现在string中\n            if (currentChar &lt; 0x20) {\n                throw new MuJsonParserException(\"unexpected control char \" + currentChar + \" in string, \" + doLexContext.currentIndex);\n            }\n\n            // 除了[\"]和[\\]两个字符，别的都当做字符串的一部分接收\n            // accept\n            accept(currentChar,doLexContext,oneTokenAcceptResult);\n            return 1;\n        }\n    }\n\n    private static class State2Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            // 终态，完成一个string的解析，直接退出\n            return -1;\n        }\n    }\n\n    private static class State3Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            // 合法的转义字符\n            if(currentChar == '\"' || currentChar == '\\\\' || currentChar == '/' ||\n                currentChar == 'b' || currentChar == 'f' || currentChar == 'n' ||\n                currentChar == 'r' || currentChar == 't'){\n                // 接收，回到状态1\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 1;\n            }\n\n            if(currentChar == 'u'){\n                // 特殊case 要求后面连续4个hex字符 '\\\\u hex hex hex hex'\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 4;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State4Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.isHex(currentChar)){\n                // 接收，进入状态5\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 5;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State5Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.isHex(currentChar)){\n                // 接收，进入状态6\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 6;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State6Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.isHex(currentChar)){\n                // 接收，进入状态7\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 7;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State7Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.isHex(currentChar)){\n                // 连续接收了4个hex字符，回到状态1\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 1;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n}\n</code></pre>\n<h5 id=\"_-10\"></h5>\n<ul>\n<li>string类型token解析的状态机与number类型的工作模式类似，同样继承自LexStatementMachine，并且定义了一系列的对应状态机示意图中各个状态的LexStateHandler。</li>\n</ul>\n<h3 id=\"26-关键字的词法分析\">2.6 关键字的词法分析</h3>\n<p>最后，json的词法分析中还有关键字类型的token解析需要实现。所幸json的文法非常简单，只有true、false和null三个关键字，且这三个关键字的f(1)都不相同，也与其它类型的token的f(1)不相同。<br />\n因此，在词法解析时，我们可以很简单的根据第一个字符来决定要解析的关键字类型，在状态0时，如果碰到字符t就尝试解析true类型的token；碰到字符f就尝试解析false类型的token；碰到字符n就尝试解析null类型的token。<br />\n因此我们可以很简单的得到如下图所示的三个关键字的状态自动机。</p>\n<h5 id=\"关键字类型解析的状态自动机示意图\">关键字类型解析的状态自动机示意图</h5>\n<p><img alt=\"json_keyword_lex_state_machine\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195910810-282453956.png\" /></p>\n<h5 id=\"keyword类型解析状态机实现源码\">keyword类型解析状态机实现源码</h5>\n<pre><code class=\"language-java\">public abstract class KeywordLexStatementMachine extends LexStatementMachine{\n\n    protected final String keyword;\n\n    public KeywordLexStatementMachine(String keyword) {\n        this.keyword = keyword;\n    }\n\n    protected static Map&lt;Integer,Boolean&gt; buildIsFinalStateMap(String keyword){\n        Map&lt;Integer,Boolean&gt; isFinalStateMap = new HashMap&lt;&gt;(keyword.length() + 1);\n        isFinalStateMap.put(-1,true);\n\n        for(int i=0; i&lt;keyword.length(); i++) {\n            isFinalStateMap.put(i,false);\n        }\n\n        // 最后一个字符就是合理的终态\n        isFinalStateMap.put(keyword.length(),true);\n\n        return isFinalStateMap;\n    }\n\n    protected static LexStateHandler[] buildLexStateHandlers(String keyword){\n        LexStateHandler[] lexStateHandlers = new LexStateHandler[keyword.length() + 1];\n\n        for(int i=0; i&lt;keyword.length(); i++) {\n            char c = keyword.charAt(i);\n\n            lexStateHandlers[i] = new KeywordLexStateHandler(c,i+1);\n        }\n\n        // 最后一个状态，直接返回\n        lexStateHandlers[keyword.length()] = new KeywordLexStateHandler(' ',-1);\n\n        return lexStateHandlers;\n    }\n\n    private static class KeywordLexStateHandler implements LexStateHandler {\n\n        private final char targetCh;\n        private final int nextState;\n\n        public KeywordLexStateHandler(char targetCh, int nextState) {\n            this.targetCh = targetCh;\n            this.nextState = nextState;\n        }\n\n        @Override\n        public int processInState(char[] chars, DoLexContext doLexContext, LexStatementMachine lexStatementMachine, StringBuilder oneTokenAcceptResult) {\n            char currentChar = chars[doLexContext.currentIndex];\n\n            return doProcessInState(currentChar,doLexContext,oneTokenAcceptResult);\n        }\n\n        private int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult){\n            if(nextState == -1){\n                // -1是特殊的直接返回\n                return nextState;\n            }\n\n            if(currentChar == targetCh) {\n                // 接收，进入下一个状态\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return nextState;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">/**\n * 解析关键字true的状态自动机\n * */\npublic class KeywordTrueLexStatementMachine extends KeywordLexStatementMachine{\n\n    private static final String KEYWORD = JsonTokenTypeEnum.TRUE.getKey();\n    private static final Map&lt;Integer,Boolean&gt; staticIsFinalStateMap;\n    private static final LexStateHandler[] lexStateHandlers;\n\n    static {\n        staticIsFinalStateMap = buildIsFinalStateMap(KEYWORD);\n        lexStateHandlers = buildLexStateHandlers(KEYWORD);\n    }\n\n    public KeywordTrueLexStatementMachine() {\n        super(KEYWORD);\n\n        super.isFinalStateMap = staticIsFinalStateMap;\n        super.stateHandlers = lexStateHandlers;\n    }\n}\n</code></pre>\n<h5 id=\"_-11\"></h5>\n<ul>\n<li>由于关键字的解析都是最简单的单向状态转移，所以单独抽象出了KeywordLexStatementMachine类，其根据构造方法中传入的关键字字面量，自动生成对应数量的LexStateHandler集合和IsFinalStateMap。</li>\n<li>false和null关键字的词法解析与true基本一致，这里省略掉</li>\n</ul>\n<h5 id=\"27-jsontokenreader\">2.7 jsonTokenReader</h5>\n<p>至此，我们就已经实现了基本的json词法分析能力，能够将json字符串一次性的解析成token列表供下一阶段的语法分析使用。<br />\n但在语法解析阶段，parser更希望接收的是能够自己记忆当前所处理token的token流，而不是一个孤零零的List，所以这里简单的以迭代器的方式包装一下方便使用。</p>\n<pre><code class=\"language-java\">public interface JsonTokenReader {\n\n    boolean hasNextToken();\n\n    JsonToken nextToken();\n\n    JsonToken peek();\n\n    int currentIndex();\n}\n</code></pre>\n<p>静态词法分析器的实现：</p>\n<pre><code class=\"language-java\">public class StaticJsonTokenReader implements JsonTokenReader {\n\n    private int currentIndex;\n\n    private final List&lt;JsonToken&gt; tokens;\n\n    public StaticJsonTokenReader(String jsonString) {\n        this.currentIndex = 0;\n\n        StaticJsonLexer staticJsonLexer = new StaticJsonLexer(jsonString);\n        this.tokens = staticJsonLexer.doLex();\n    }\n\n    @Override\n    public boolean hasNextToken() {\n        return tokens.get(currentIndex).getType() != JsonTokenTypeEnum.EOF;\n    }\n\n    @Override\n    public JsonToken nextToken() {\n        JsonToken jsonToken = tokens.get(currentIndex);\n        currentIndex++;\n        return jsonToken;\n    }\n\n    @Override\n    public JsonToken peek() {\n        return tokens.get(currentIndex);\n    }\n\n    @Override\n    public int currentIndex() {\n        return this.currentIndex;\n    }\n}\n</code></pre>\n<p>简单demo：</p>\n<pre><code class=\"language-java\">    public static void main(String[] args) {\n        String json = \"{\\\"k1\\\":{\\\"abc\\\":123},\\\"k2\\\":true}\";\n\n        StaticJsonLexer staticJsonLexer = new StaticJsonLexer(json);\n        List&lt;JsonToken&gt; jsonTokenList = staticJsonLexer.doLex();\n        System.out.println(\"json=\" + json);\n        jsonTokenList.forEach(System.out::println);\n    }\n</code></pre>\n<p><img alt=\"static_json_lexer_demo_result\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195926464-23510035.png\" /></p>\n<h2 id=\"3-手写-json-语法分析器从-token-到-ast\">3. 手写 json 语法分析器：从 token 到 AST</h2>\n<p>语法分析阶段，接收词法分析阶段输出的token流，需要按照语法规则解析出正确的AST抽象语法树。<br />\n在json的AST中其实本质上只有三种类型的元素：</p>\n<ul>\n<li><code>JsonObject</code>：对象</li>\n<li><code>JsonArray</code>：数组</li>\n<li><code>JsonPrimitiveStr</code>：primitive基础类型（string/number/true/false/null）封装为字符串字面量</li>\n</ul>\n<h5 id=\"_-12\"></h5>\n<p>primitive基础类型是无法进行递归嵌套的类型，是AST中的叶节点，而object和array则是可以互相嵌套的(对象的一个属性可以是数组或者另一个对象，数组中的元素也可以是对象或者另一个数组)，其属于AST中的非叶子结点。</p>\n<h3 id=\"31-json-ast节点结构定义\">3.1 json AST节点结构定义</h3>\n<pre><code class=\"language-java\">public abstract class JsonElement {\n}\n</code></pre>\n<pre><code class=\"language-java\">/**\n * json AST的object类型节点\n * */\npublic class JsonObject extends JsonElement{\n\n    private final Map&lt;String,JsonElement&gt; objMap = new LinkedHashMap&lt;&gt;();\n\n    public void putKV(String key, JsonElement value) {\n        objMap.put(key, value);\n    }\n\n    public Map&lt;String, JsonElement&gt; getObjMap() {\n        return objMap;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">/**\n * json AST的array类型节点\n * */\npublic class JsonArray extends JsonElement{\n\n    private List&lt;JsonElement&gt; array = new ArrayList&lt;&gt;();\n\n    public void addElement(JsonElement element) {\n        array.add(element);\n    }\n\n    public List&lt;JsonElement&gt; getArray() {\n        return array;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">/**\n * json AST的primitive类型节点\n * */\npublic class JsonPrimitiveStr extends JsonElement{\n\n    /**\n     * 基础类型的字符串字面量\n     * */\n    private final String primitiveValueStr;\n\n    public JsonPrimitiveStr(String primitiveValueStr) {\n        this.primitiveValueStr = primitiveValueStr;\n    }\n\n    public String getPrimitiveValueStr() {\n        return primitiveValueStr;\n    }\n}\n</code></pre>\n<h5 id=\"_-13\"></h5>\n<ul>\n<li>jsonElement是所有AST节点的共同抽象父类</li>\n<li>json的object结构映射为java中是一个有序的k/v Map结构</li>\n<li>json的array结构映射为java中是一个List结构</li>\n<li>json的primitive结构映射为java中的一个简单字符串字面量</li>\n</ul>\n<h3 id=\"32-json根节点语法解析\">3.2 json根节点语法解析</h3>\n<pre><code>json\n    element\n    \nelement\n    ws value ws\n\nvalue\n    object\n    array\n    string\n    number\n    \"true\"\n    \"false\"\n    \"null\"\n\nobject\n    '{' ws '}'\n    '{' members '}'    \n\narray\n    '[' ws ']'\n    '[' elements ']'\n</code></pre>\n<h5 id=\"_-14\"></h5>\n<p>上述文法中，json是AST的根节点，其最终可以是object、array或者5种基本类型的一种。<br />\nobject类型的f(1)有且仅有'{'，而array类型的f(1)有且仅有'['，因此我们可以构造出一个简单的根节点解析的状态机来实现语法分析。</p>\n<ul>\n<li>若token流中的第一个 token 是 <code>{</code> → 解析为 <code>JsonObject</code>。</li>\n<li>若token流中的第一个 token 是 <code>[</code> → 解析为 <code>JsonArray</code>。</li>\n<li>若token流中的第一个 token 是基础类型 → 解析为 <code>JsonPrimitiveStr</code>。</li>\n<li>否则都是非法json。</li>\n</ul>\n<h5 id=\"json根节点语法解析状态自动机\">json根节点语法解析状态自动机</h5>\n<p><img alt=\"json_parser_root\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195937409-994915878.png\" /></p>\n<h5 id=\"json根节点解析状态自动机实现\">json根节点解析状态自动机实现</h5>\n<pre><code class=\"language-java\">/**\n * 基于递归实现的json解析器\n * */\npublic class RecursiveJsonParser extends JsonParser {\n\n    public RecursiveJsonParser(JsonTokenReader tokenReader) {\n        super(tokenReader);\n    }\n\n    @Override\n    public JsonElement doParse() {\n        JsonToken token = jsonTokenReader.peek();\n\n        if (token.getType() == JsonTokenTypeEnum.LEFT_BRACE) {\n            JsonObjectParseStatementMachine jsonObjectParseStatementMachine = new JsonObjectParseStatementMachine(jsonTokenReader);\n\n            return jsonObjectParseStatementMachine.parseJsonElement();\n        }\n\n        if (token.getType() == JsonTokenTypeEnum.LEFT_BRACKET) {\n            JsonArrayParseStatementMachine jsonArrayParseStatementMachine = new JsonArrayParseStatementMachine(jsonTokenReader);\n\n            return jsonArrayParseStatementMachine.parseJsonElement();\n        }\n\n        // 基础类型的value\n        if (token.getType().isPrimitiveValue()) {\n            return new JsonPrimitiveStr(token.getContent());\n        }\n\n        // 第一个token，不属于json规则的f(1)集合\n        throw new MuJsonParserException(\"unexpected start json token! token=\" + jsonTokenReader.currentIndex());\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">public enum JsonTokenTypeEnum {\n    // 省略了无关逻辑\n\n    /**\n     * 基础类型的value（string、number、true、false、null）\n     * */\n    public boolean isPrimitiveValue(){\n        return this == STRING || this == NUMBER || this == NULL ||this == TRUE || this == FALSE;\n    }\n}\n</code></pre>\n<h3 id=\"33-json-object对象结构解析\">3.3 json object对象结构解析</h3>\n<p>现在我们来研究json object对象的语法解析。object结构是以“{”开头，“}”结尾的结构，内部可以有0到N个kv键值对，其中key必须是string类型，而value则可以是嵌套的结构，key和value之间以冒号分隔，kv对之间以逗号分割。<br />\n因此，使用递归的方式来实现object对象的语法解析是很容易理解和实现的(尽管递归的实现效率不够高)。</p>\n<h5 id=\"json-object对象结构语法\">json object对象结构语法</h5>\n<pre><code>object\n    '{' ws '}'\n    '{' members '}'\n\nmembers\n    member\n    member ',' members\n\nmember\n    ws string ws ':' element\n\nelement\n    ws value ws    \n\nvalue\n    object\n    array\n    string\n    number\n    \"true\"\n    \"false\"\n    \"null\"\n</code></pre>\n<p><img alt=\"json_object_parser\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195946762-1722527366.png\" /></p>\n<h5 id=\"object结构解析状态自动机示意图\">object结构解析状态自动机示意图</h5>\n<p><img alt=\"json_object_state_machine\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195955922-1227811677.png\" /></p>\n<h5 id=\"object结构解析状态自动机递归实现递归版本\">object结构解析状态自动机递归实现（递归版本）</h5>\n<p>语法分析与词法分析类似，也是使用状态自动机来实现的。实现的大致方式也是通过抽象出一个父类(AbstractJsonParseStatementMachine),在父类中通过持续不断的从token流中读取token来推进状态。在子类中定义相应的状态处理器来实现每个状态的处理</p>\n<pre><code class=\"language-java\">/**\n * 基于递归实现的 object类型语法解析状态自动机\n * */\npublic class JsonObjectParseStatementMachine extends AbstractJsonParseStatementMachine&lt;JsonObject&gt;{\n\n    public JsonObjectParseStatementMachine(JsonTokenReader jsonTokenReader) {\n        this.jsonTokenReader = jsonTokenReader;\n        this.targetJsonElement = new JsonObject();\n        this.recursiveDoParserContext = new RecursiveDoParserContext&lt;&gt;(this.targetJsonElement);\n        stateHandlers = new ParserStateHandler[]{\n            new ParserState0Handler(),new ParserState1Handler(),new ParserState2Handler(),new ParserState3Handler(),\n            new ParserState4Handler(),new ParserState5Handler(),new ParserState6Handler()\n        };\n    }\n\n    private static class ParserState0Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() != JsonTokenTypeEnum.LEFT_BRACE){\n                throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n            }\n\n            accept(jsonTokenReader);\n            return 1;\n        }\n    }\n\n    private static class ParserState1Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() == JsonTokenTypeEnum.RIGHT_BRACE){\n                accept(jsonTokenReader);\n                return 2;\n            }\n\n            if(token.getType() == JsonTokenTypeEnum.STRING){\n                // 把key先压入栈中，然后等构造kv对时弹出\n                recursiveDoParserContext.getTokenStack().push(token);\n                accept(jsonTokenReader);\n                return 3;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private static class ParserState2Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            // 终态，直接返回\n            return -1;\n        }\n    }\n\n    private static class ParserState3Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() == JsonTokenTypeEnum.COLON){\n                accept(jsonTokenReader);\n                return 4;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private static class ParserState4Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            JsonToken keyToken = recursiveDoParserContext.getTokenStack().pop();\n            Assert.assertTrue(keyToken != null &amp;&amp; keyToken.getType() == JsonTokenTypeEnum.STRING,\"parse object keyToken not match!\");\n\n            // 嵌套的jsonObject结构\n            if(token.getType() == JsonTokenTypeEnum.LEFT_BRACE){\n                JsonObjectParseStatementMachine jsonObjectParseStatementMachine = new JsonObjectParseStatementMachine(jsonTokenReader);\n\n                JsonObject subJsonObject = jsonObjectParseStatementMachine.parseJsonElement();\n\n                // 构造好了一个kv对（key : obj）\n                recursiveDoParserContext.getTargetJsonElement().putKV(keyToken.getContent(), subJsonObject);\n\n                return 5;\n            }\n\n            // 嵌套的jsonArray结构\n            if(token.getType() == JsonTokenTypeEnum.LEFT_BRACKET){\n                // jsonArray状态机\n                JsonArrayParseStatementMachine jsonArrayParseStatementMachine = new JsonArrayParseStatementMachine(jsonTokenReader);\n\n                JsonArray jsonArray = jsonArrayParseStatementMachine.parseJsonElement();\n                // 构造好了一个kv对 (key ：array)\n                recursiveDoParserContext.getTargetJsonElement().putKV(keyToken.getContent(), jsonArray);\n\n                return 5;\n            }\n\n            // 基础类型的value\n            if(token.getType().isPrimitiveValue()){\n                accept(jsonTokenReader);\n                recursiveDoParserContext.getTargetJsonElement().putKV(keyToken.getContent(), new JsonPrimitiveStr(token.getContent()));\n\n                return 5;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private static class ParserState5Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() == JsonTokenTypeEnum.RIGHT_BRACE){\n                accept(jsonTokenReader);\n                return 2;\n            }\n\n            if(token.getType() == JsonTokenTypeEnum.COMMA){\n                accept(jsonTokenReader);\n                return 6;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private static class ParserState6Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() == JsonTokenTypeEnum.STRING){\n                // 把key先压入栈中，然后等构造kv对时弹出\n                recursiveDoParserContext.getTokenStack().push(token);\n                accept(jsonTokenReader);\n                return 3;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">public class AbstractJsonParseStatementMachine&lt;T extends JsonElement&gt; {\n\n    protected JsonTokenReader jsonTokenReader;\n\n    protected RecursiveDoParserContext&lt;T&gt; recursiveDoParserContext;\n\n    protected int currentState = 0;\n\n    protected T targetJsonElement;\n\n    protected ParserStateHandler[] stateHandlers;\n\n    public T parseJsonElement(){\n        while(jsonTokenReader.hasNextToken()){\n            if(currentState == -1){\n                // 遇到了合法的分隔符号，退出token解析\n                return targetJsonElement;\n            }\n\n            if(currentState &gt;= stateHandlers.length){\n                // 有bug\n                throw new MuJsonParserException(String.format(\"unknown state! currentState=%s\",currentState));\n            }\n            ParserStateHandler targetStateHandler = stateHandlers[currentState];\n            \n            currentState = targetStateHandler.processInState(jsonTokenReader, recursiveDoParserContext);\n        }\n\n        return targetJsonElement;\n    }\n\n    protected static void accept(JsonTokenReader jsonTokenReader){\n        jsonTokenReader.nextToken();\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">public class RecursiveDoParserContext&lt;T extends JsonElement&gt;  {\n\n    private Stack&lt;JsonToken&gt; tokenStack = new Stack&lt;&gt;();\n\n    private T targetJsonElement;\n\n    public RecursiveDoParserContext(T targetJsonElement) {\n        this.targetJsonElement = targetJsonElement;\n    }\n\n    public Stack&lt;JsonToken&gt; getTokenStack() {\n        return tokenStack;\n    }\n\n    public T getTargetJsonElement() {\n        return targetJsonElement;\n    }\n}\n</code></pre>\n<h5 id=\"_-15\"></h5>\n<ul>\n<li>在解析kv对时，需要先将string类型的key暂时缓存起来，等待后续的value类型结构(object、array或者primitive)也完成解析后，再一并的放入AST中(getTargetJsonElement().putKV)。</li>\n<li>解析kv对的value时，当前的实现是基于递归实现的。即当根据当前token的类型创建一个新的对应类型的状态机，去递归的解析更深一层的AST结构。<br />\n递归实现的好处是思路简单易懂，不用过多的考虑不同类型结构之间状态的互相转移，通过递归解析子AST的方式天然的屏蔽掉了大量的复杂度。<br />\n但缺点也同样明显，在解析层次非常深的json字符串时，递归的层次过深可能会导致当前线程栈溢出，解析失败。</li>\n</ul>\n<h3 id=\"34-json-array数组结构解析\">3.4 json array数组结构解析</h3>\n<p>array结构是以“[”开头，“]”结尾的结构，内部可以有0到N个value类型的元素,以逗号做分割，value同样是可以是嵌套的结构。与上面object结构的解析实现方式一样，同样是基于递归实现的。</p>\n<h5 id=\"json-array数组结构语法\">json array数组结构语法</h5>\n<pre><code>array\n    '[' ws ']'\n    '[' elements ']'\n\nelements\n    element\n    element ',' elements\n\nelement\n    ws value ws\n\nvalue\n    object\n    array\n    string\n    number\n    \"true\"\n    \"false\"\n    \"null\"\n</code></pre>\n<p><img alt=\"json_array_parser\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211200007327-1872691214.png\" /></p>\n<h5 id=\"array结构解析状态自动机示意图\">array结构解析状态自动机示意图</h5>\n<p><img alt=\"json_array_state_machine\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211200016319-1527985884.png\" /></p>\n<h5 id=\"array结构解析状态自动机递归实现递归版本\">array结构解析状态自动机递归实现（递归版本）</h5>\n<pre><code class=\"language-java\">/**\n * 基于递归实现的 array类型语法解析状态自动机\n * */\npublic class JsonArrayParseStatementMachine extends AbstractJsonParseStatementMachine&lt;JsonArray&gt; {\n\n    public JsonArrayParseStatementMachine(JsonTokenReader jsonTokenReader) {\n        this.jsonTokenReader = jsonTokenReader;\n        this.targetJsonElement = new JsonArray();\n        this.recursiveDoParserContext = new RecursiveDoParserContext&lt;&gt;(this.targetJsonElement);\n        stateHandlers = new ParserStateHandler[]{\n            new ParserState0Handler(),new ParserState1Handler(),new ParserState2Handler(),\n            new ParserState3Handler(), new ParserState4Handler()\n        };\n    }\n\n    private static class ParserState0Handler implements ParserStateHandler&lt;JsonArray&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonArray&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() != JsonTokenTypeEnum.LEFT_BRACKET){\n                throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n            }\n\n            accept(jsonTokenReader);\n            return 1;\n        }\n    }\n\n    private static class ParserState1Handler implements ParserStateHandler&lt;JsonArray&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonArray&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() == JsonTokenTypeEnum.RIGHT_BRACKET){\n                accept(jsonTokenReader);\n                return 2;\n            }\n\n            // 嵌套的jsonObject结构\n            if(token.getType() == JsonTokenTypeEnum.LEFT_BRACE){\n                JsonObjectParseStatementMachine jsonObjectParseStatementMachine = new JsonObjectParseStatementMachine(jsonTokenReader);\n\n                JsonObject subJsonObject = jsonObjectParseStatementMachine.parseJsonElement();\n\n                // add一个obj\n                recursiveDoParserContext.getTargetJsonElement().addElement(subJsonObject);\n\n                return 3;\n            }\n\n            // 嵌套的jsonArray结构\n            if(token.getType() == JsonTokenTypeEnum.LEFT_BRACKET){\n                // jsonArray状态机\n                JsonArrayParseStatementMachine jsonArrayParseStatementMachine = new JsonArrayParseStatementMachine(jsonTokenReader);\n\n                JsonArray jsonArray = jsonArrayParseStatementMachine.parseJsonElement();\n\n                // add一个array\n                recursiveDoParserContext.getTargetJsonElement().addElement(jsonArray);\n\n                return 3;\n            }\n\n            // 基础类型的value\n            if(token.getType().isPrimitiveValue()){\n                accept(jsonTokenReader);\n                recursiveDoParserContext.getTargetJsonElement().addElement(new JsonPrimitiveStr(token.getContent()));\n\n                return 3;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private static class ParserState2Handler implements ParserStateHandler&lt;JsonArray&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonArray&gt; recursiveDoParserContext) {\n            // 终态，直接返回\n            return -1;\n        }\n    }\n\n    private static class ParserState3Handler implements ParserStateHandler&lt;JsonArray&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonArray&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() == JsonTokenTypeEnum.RIGHT_BRACKET){\n                accept(jsonTokenReader);\n                return 2;\n            }\n\n            if(token.getType() == JsonTokenTypeEnum.COMMA){\n                accept(jsonTokenReader);\n                return 4;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private static class ParserState4Handler implements ParserStateHandler&lt;JsonArray&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonArray&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            // 嵌套的jsonObject结构\n            if(token.getType() == JsonTokenTypeEnum.LEFT_BRACE){\n                JsonObjectParseStatementMachine jsonObjectParseStatementMachine = new JsonObjectParseStatementMachine(jsonTokenReader);\n\n                JsonObject subJsonObject = jsonObjectParseStatementMachine.parseJsonElement();\n\n                // add一个obj\n                recursiveDoParserContext.getTargetJsonElement().addElement(subJsonObject);\n\n                return 3;\n            }\n\n            // 嵌套的jsonArray结构\n            if(token.getType() == JsonTokenTypeEnum.LEFT_BRACKET){\n                // jsonArray状态机\n                JsonArrayParseStatementMachine jsonArrayParseStatementMachine = new JsonArrayParseStatementMachine(jsonTokenReader);\n\n                JsonArray jsonArray = jsonArrayParseStatementMachine.parseJsonElement();\n\n                // add一个array\n                recursiveDoParserContext.getTargetJsonElement().addElement(jsonArray);\n\n                return 3;\n            }\n\n            // 基础类型的value\n            if(token.getType().isPrimitiveValue()){\n                accept(jsonTokenReader);\n                recursiveDoParserContext.getTargetJsonElement().addElement(new JsonPrimitiveStr(token.getContent()));\n\n                return 3;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n}\n</code></pre>\n<h5 id=\"_-16\"></h5>\n<ul>\n<li>相比object结构的状态自动机，array结构的状态自动机则显得比较简单。同样在遇到复杂类型的结构时，通过当前token的类型递归的创建一个新的状态机去构造出子AST(JsonElement)，然后加入到当前JsonArray中(getTargetJsonElement().addElement)。</li>\n</ul>\n<h2 id=\"4-基于ast生成beauty-json字符串\">4. 基于AST生成beauty json字符串</h2>\n<p>现在我们已经实现了json的词法解析和语法解析，可以将一个原始的合法的json字符串正确的转换成对应的AST了。<br />\n拿到AST之后理论上可以做很多事情，比如将json串反序列化为java对象。这里我们实现一个<strong>更简单也更直观的功能</strong>，即将原始的json字符串格式化成缩进良好，更美观，可读性更佳的beauty字符串。</p>\n<h5 id=\"生成格式化后的beauty-json字符串实现\">生成格式化后的beauty json字符串实现</h5>\n<pre><code class=\"language-java\">public abstract class JsonElement {\n\n    private static final String BEAUTY_INDENT = \"    \";  // 四个空格缩进\n    private static final String BEAUTY_KV_INDENT = \" \";  // kv多一个空格\n    private static final String BEAUTY_LINE_BREAK = \"\\n\"; // 换行分割\n\n    /**\n     * 生成美化后的beauty字符串\n     * */\n    public String buildBeautyJsonString(){\n        StringBuilder jsonStringBuilder = new StringBuilder();\n\n        buildJsonString(this,jsonStringBuilder,\"\",BEAUTY_LINE_BREAK,BEAUTY_INDENT,BEAUTY_KV_INDENT);\n\n        return jsonStringBuilder.toString();\n    }\n\n    private static void buildJsonString(JsonElement jsonElement, StringBuilder jsonStringBuilder, String currentIndent,\n                                        String lineBreak, String indent, String kvIndent){\n        if(jsonElement instanceof JsonPrimitiveStr){\n            jsonStringBuilder.append(jsonElement);\n            return;\n        }\n\n        if(jsonElement instanceof JsonArray){\n            JsonArray jsonArray  = (JsonArray) jsonElement;\n            jsonStringBuilder.append(\"[\").append(lineBreak);\n            List&lt;JsonElement&gt; jsonArrayList = jsonArray.getArray();\n            int i=0;\n            for(JsonElement arrayItem : jsonArrayList){\n                jsonStringBuilder.append(currentIndent).append(indent);\n                // 递归下去，currentIndent多缩进一层\n                buildJsonString(arrayItem,jsonStringBuilder,currentIndent + indent,lineBreak,indent,kvIndent);\n                if(i != jsonArrayList.size()-1){\n                    jsonStringBuilder.append(\",\");\n                }\n\n                jsonStringBuilder.append(lineBreak);\n                i++;\n            }\n\n            jsonStringBuilder.append(currentIndent).append(\"]\");\n        }\n\n        if(jsonElement instanceof JsonObject){\n            JsonObject jsonObject  = (JsonObject) jsonElement;\n            jsonStringBuilder.append(\"{\").append(lineBreak);\n\n            Map&lt;String, JsonElement&gt; objMap = jsonObject.getObjMap();\n\n            int i=0;\n            for(Map.Entry&lt;String, JsonElement&gt; entry : objMap.entrySet()){\n                String key = entry.getKey();\n                JsonElement value = entry.getValue();\n\n                // key是string类型的，字面量里自带双引号的\n                jsonStringBuilder.append(currentIndent).append(indent).append(key).append(kvIndent).append(\":\").append(kvIndent);\n                // 递归下去，currentIndent多缩进一层\n                buildJsonString(value,jsonStringBuilder,  currentIndent + indent, lineBreak,indent,kvIndent);\n\n                if(i != objMap.size()-1){\n                    jsonStringBuilder.append(\",\");\n                }\n\n                jsonStringBuilder.append(lineBreak);\n                i++;\n            }\n\n            jsonStringBuilder.append(currentIndent).append(\"}\");\n        }\n    }\n}\n</code></pre>\n<h5 id=\"_-17\"></h5>\n<ul>\n<li>从源码实现中可以看到，输出美化后的beauty字符串本质上就是一个针对AST树形结构的<strong>深度优先遍历</strong>，只需要注意随着递归深度动态调整缩进长度即可。</li>\n<li>格式化json的方式多种多样，像jackson这样成熟的json处理框架中提供了大量的配置参数允许用户以所想要的方式非常灵活的生成所需格式的json字符串。我们这里的实现不够灵活，性能也不够高效，仅仅是起到一个抛砖引玉的作用。</li>\n</ul>\n<h5 id=\"json-beauty示意图\">json beauty示意图</h5>\n<p><img alt=\"json_beauty_demo\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211200026283-104525624.png\" /></p>\n<h2 id=\"5-流式的json词法解析\">5. 流式的json词法解析</h2>\n<p>截止目前我们已经实现了json字符串的解析功能，但还存在两个严重的性能问题需要优化。</p>\n<ul>\n<li>首先是目前的词法分析器是一次性的解析出所有的token后，再交给语法分析去解析的。而这存在一个隐患，因为很多时候我们实际解析的并不总是一个合法的json字符串。<br />\n如果一个非常长的不合法的json字符串，在词法分析阶段看不出任何的问题(比如在合法的以<code>{</code>开头的 json字符串的前面误追加一个123)，而直到语法分析才发现存在语法错误，那么词法分析阶段花费的计算资源就统统浪费了。</li>\n<li>如果能够在完整的词法分析处理的过程中提前发现语法错误就能避免这个问题。但实现这个功能不需要将词法分析和语法分析的功能耦合在一起，而是将词法分析器改造成按需加载的流式解析即可。<br />\n流式的词法分析能够在语法解析器需要读取token时才触发词法分析，并且一次可以只按需的完整解析出一个完整的token交给parser。</li>\n<li>有了流式的词法分析，像上面举得例子，在合法的非常长的json字符串的前面误加一个123的场景，便能够很早的就发现语法错误，结束解析过程。</li>\n</ul>\n<h5 id=\"流式的词法分析解析实现\">流式的词法分析解析实现</h5>\n<pre><code class=\"language-java\">public class StreamJsonLexer extends AbstractJsonLexer{\n\n    public StreamJsonLexer(String jsonString) {\n        super(jsonString);\n    }\n\n    public JsonToken doLex(){\n        if(doLexContext.currentIndex &gt;= jsonStringArray.length){\n            return new JsonToken(JsonTokenTypeEnum.EOF);\n        }\n\n        while(true) {\n            char ch = jsonStringArray[doLexContext.currentIndex];\n\n            // 每一次尝试解析一个完整的token前，都是状态0\n            switch (ch) {\n                case '{':\n                    doLexContext.currentIndex++;\n                    return new JsonToken(JsonTokenTypeEnum.LEFT_BRACE);\n                case '}':\n                    doLexContext.currentIndex++;\n                    return new JsonToken(JsonTokenTypeEnum.RIGHT_BRACE);\n                case '[':\n                    doLexContext.currentIndex++;\n                    return new JsonToken(JsonTokenTypeEnum.LEFT_BRACKET);\n                case ']':\n                    doLexContext.currentIndex++;\n                    return new JsonToken(JsonTokenTypeEnum.RIGHT_BRACKET);\n                case ',':\n                    doLexContext.currentIndex++;\n                    return new JsonToken(JsonTokenTypeEnum.COMMA);\n                case ':':\n                    doLexContext.currentIndex++;\n                    return new JsonToken(JsonTokenTypeEnum.COLON);\n                case '\"':\n                    return parseString(jsonStringArray, doLexContext);\n                case 't':\n                    // 尝试解析true关键字\n                    return parseTrueKeyword(jsonStringArray, doLexContext);\n                case 'f':\n                    // 尝试解析false关键字\n                    return parseFalseKeyword(jsonStringArray, doLexContext);\n                case 'n':\n                    // 尝试解析null关键字\n                    return parseNullKeyword(jsonStringArray, doLexContext);\n                default:\n                    // 走其它case\n                    break;\n            }\n\n            // 其它case\n            if (CommonStringUtil.is0_9(ch) || ch == '-') {\n                // number解析\n                return parseNumber(jsonStringArray, doLexContext);\n            } else if (CommonStringUtil.isWhitespace(ch)) {\n                // whiteSpace 直接跳过\n                doLexContext.currentIndex++;\n            } else{\n                throw new MuJsonParserException(\"unexpected character: \" + ch + \",charIndex=\" + doLexContext.currentIndex);\n            }\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">public class StreamJsonTokenReader implements JsonTokenReader {\n\n    private int currentIndex;\n    private final StreamJsonLexer streamJsonLexer;\n\n    private JsonToken peekToken;\n    private boolean hasNextToken;\n\n    public StreamJsonTokenReader(String jsonString) {\n        this.currentIndex = 0;\n        this.hasNextToken = true;\n        this.streamJsonLexer = new StreamJsonLexer(jsonString);\n    }\n\n    @Override\n    public boolean hasNextToken() {\n        return hasNextToken;\n    }\n\n    @Override\n    public JsonToken nextToken() {\n        JsonToken nextToken = getNextToken();\n        if(nextToken.getType() == JsonTokenTypeEnum.EOF){\n            hasNextToken = false;\n        }\n\n        currentIndex++;\n        return nextToken;\n    }\n\n    private JsonToken getNextToken() {\n        if(peekToken != null){\n            JsonToken nextToken = peekToken;\n            this.peekToken = null;\n            return nextToken;\n        }\n\n        return streamJsonLexer.doLex();\n    }\n\n    @Override\n    public JsonToken peek() {\n        if(peekToken == null) {\n            peekToken = streamJsonLexer.doLex();\n        }\n\n        return peekToken;\n    }\n\n    @Override\n    public int currentIndex() {\n        return currentIndex;\n    }\n}\n</code></pre>\n<h5 id=\"_-18\"></h5>\n<ul>\n<li>流式的词法解析器StreamJsonLexer的核心工作原理与之前已经实现的静态的StaticJsonLexer别无二致，其底层依赖的代码都是相同的。<br />\n最大的区别在于解析出一个完整的token后，在维护当前字符流下标的同时提前终止了后续的词法分析。在StreamJsonTokenReader调用nextToken时，才会按需的惰性解析新的token并返回。</li>\n<li>流式的词法解析毫无疑问是性能更好的，主流的json解析器也都是流式的解析。但静态的词法解析更容易理解，也更容易调试，所以在一开始介绍词法分析原理时，我们先实现了静态的词法分析，将其作为基础，略微的改造后便实现了流式的词法解析。</li>\n</ul>\n<h2 id=\"6-基于堆栈实现的json语法解析\">6. 基于堆栈实现的json语法解析</h2>\n<p>第二个性能问题则是基于递归实现的json语法解析器受限于较小的线程栈空间，无法处理嵌套层级非常深的json串。</p>\n<ul>\n<li>我们知道，一个普通的java进程通常都含有大量的线程，因此给每个线程分配的线程栈通常都比较小，比如1m。而递归实现的语法解析器，在每深入一个层次的json子树时便会向栈上压入一些局部变量，当极端情况下要解析的json串层次过深时，则会出现StackOverflowError，导致解析失败。</li>\n<li>而内存的堆通常都是以GB为单位的，因此如果把递归中隐式压栈的解析逻辑转换为等价的显式基于内存堆的压栈，则可以很好的解决线程栈过小无法处理大深度json串的问题了。</li>\n</ul>\n<h5 id=\"基于堆栈的语法解析状态自动机示意图\">基于堆栈的语法解析状态自动机示意图</h5>\n<p><img alt=\"stack_base_json_parser_state_machine\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211200035364-62927704.png\" /></p>\n<ul>\n<li>为了尽可能的将状态转移与递归实现的逻辑保持一致，堆栈的状态自动机依然冗余了两个状态(obj-0和arr-0)。</li>\n<li>可以看到，基于堆栈的状态自动机会在array与object的解析状态中互相转移，相当于将之前递归实现的各个状态自动机的子状态图合并为了一个大而全的状态自动机。</li>\n<li>同时，由于还涉及了手动模拟的入栈与出栈处理(obj-2，obj-4，arr-1，arr-2)，因此整体的复杂度比起递归实现要高出一个量级。</li>\n</ul>\n<h5 id=\"json根节点解析状态自动机实现源码\">json根节点解析状态自动机实现源码</h5>\n<pre><code class=\"language-java\">/**\n * 基于堆栈的，非递归的json语法解析器\n * */\npublic class StackBaseJsonParser extends JsonParser {\n\n    private final JsonParseStack parseStack = new JsonParseStack();\n\n    private StackBaseJsonParserStatusEnum currentStatus;\n\n    public StackBaseJsonParser(JsonTokenReader tokenReader) {\n        super(tokenReader);\n\n        this.currentStatus = StackBaseJsonParserStatusEnum.START_PARSE;\n    }\n\n    private void accept(){\n        jsonTokenReader.nextToken();\n    }\n\n    @Override\n    public JsonElement doParse() {\n        while(jsonTokenReader.hasNextToken()){\n            JsonToken token = jsonTokenReader.peek();\n\n            if(currentStatus == StackBaseJsonParserStatusEnum.END_PARSE){\n                break;\n            }\n\n            switch (currentStatus){\n                case START_PARSE:\n                    processInStartParse(token);\n                    break;\n                case PARSE_OBJECT_0:\n                    processInParseObject0(token);\n                    break;\n                case PARSE_OBJECT_1:\n                    processInParseObject1(token);\n                    break;\n                case PARSE_OBJECT_2:\n                    processInParseObject2(token);\n                    break;\n                case PARSE_OBJECT_3:\n                    processInParseObject3(token);\n                    break;\n                case PARSE_OBJECT_4:\n                    processInParseObject4(token);\n                    break;\n                case PARSE_OBJECT_5:\n                    processInParseObject5(token);\n                    break;\n                case PARSE_OBJECT_6:\n                    processInParseObject6(token);\n                    break;\n                case PARSE_ARR_0:\n                    processInParseArr0(token);\n                    break;\n                case PARSE_ARR_1:\n                    processInParseArr1(token);\n                    break;\n                case PARSE_ARR_2:\n                    processInParseArr2(token);\n                    break;\n                case PARSE_ARR_3:\n                    processInParseArr3(token);\n                    break;\n                default:\n                    throw new MuJsonParserException(\"Unexpected currentStatus: \" + currentStatus);\n            }\n        }\n\n        // 如果json字符串是合法的，那么最后栈顶必然是有且唯一的一个JsonElement类型的对象\n        if(this.parseStack.size() != 1){\n            throw new MuJsonParserException(\"after parse，stack element size &gt; 1! stack=\" + this.parseStack);\n        }\n\n        JsonParseStackValue object = this.parseStack.pop();\n        return (JsonElement) object.getValue();\n    }\n\n    private void processInStartParse(JsonToken token){\n        if (token.getType() == JsonTokenTypeEnum.LEFT_BRACE) {\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_0;\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_OBJECT,new JsonObject()));\n            return;\n        }\n\n        if (token.getType() == JsonTokenTypeEnum.LEFT_BRACKET) {\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_0;\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_ARRAY,new JsonArray()));\n            return;\n        }\n\n        if (token.getType().isPrimitiveValue()) {\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.END_PARSE;\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_PRIMITIVE,new JsonPrimitiveStr(token.getContent())));\n            return;\n        }\n\n        // 第一个token，不属于json规则的f(1)集合\n        throw new MuJsonParserException(\"unexpected start json token! token=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseObject0(JsonToken token){\n        if(token.getType() != JsonTokenTypeEnum.LEFT_BRACE){\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n\n        accept();\n\n        this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_1;\n    }\n\n    private void processInParseObject1(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.RIGHT_BRACE){\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_2;\n            return;\n        }\n\n        if(token.getType() == JsonTokenTypeEnum.STRING){\n            // 把key先压入栈中，然后等构造kv对时弹出\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_KEY,token));\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_3;\n            return;\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseObject2(JsonToken token){\n        // 遇到'}'才会进来\n        if(token.getType() != JsonTokenTypeEnum.RIGHT_BRACE){\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }else{\n            accept();\n        }\n\n        // 当前栈顶必定是JsonObject，先将其弹出，然后看栈顶的元素类型判断\n        JsonParseStackValue currentJsonObjectStackValue = this.parseStack.popAndCheck(JsonParseStackValueTypeEnum.JSON_OBJECT);\n        if(this.parseStack.isEmpty()){\n            // 说明是root的JsonObject解析完了，再推回去直接返回\n            this.parseStack.push(currentJsonObjectStackValue);\n            this.currentStatus = StackBaseJsonParserStatusEnum.END_PARSE;\n            return;\n        }\n\n        JsonObject currentJsonObject = (JsonObject) currentJsonObjectStackValue.getValue();\n\n        JsonParseStackValueTypeEnum topObjType = this.parseStack.peekTopType();\n\n        if(topObjType == JsonParseStackValueTypeEnum.JSON_KEY){\n            // 如果是json_key，说明是当前jsonObject是父object的一个k/v项中的value。\n            JsonParseStackValue keyStackValue = this.parseStack.popAndCheck(JsonParseStackValueTypeEnum.JSON_KEY);\n            JsonToken keyJsonToken = (JsonToken) keyStackValue.getValue();\n            JsonParseStackValue parentObject = this.parseStack.peekAndCheck(JsonParseStackValueTypeEnum.JSON_OBJECT);\n\n            // 将当前k/v项附加在父object上\n            ((JsonObject)parentObject.getValue()).putKV(keyJsonToken.getContent(), currentJsonObject);\n\n            // 基于下一个token判断状态跳转\n            JsonToken nextJsonToken = this.jsonTokenReader.peek();\n            if(nextJsonToken.getType() == JsonTokenTypeEnum.COMMA){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_5;\n                return;\n            }else if (nextJsonToken.getType() == JsonTokenTypeEnum.RIGHT_BRACE){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_2;\n                return;\n            }else{\n                throw new MuJsonParserException(\"unexpected token! index=\" + (jsonTokenReader.currentIndex()+1));\n            }\n\n        }else if(topObjType == JsonParseStackValueTypeEnum.JSON_ARRAY){\n            // 说明当前jsonObject是jsonArray的一个元素\n\n            JsonParseStackValue parentArr = this.parseStack.peekAndCheck(JsonParseStackValueTypeEnum.JSON_ARRAY);\n            ((JsonArray)parentArr.getValue()).addElement(currentJsonObject);\n\n            // 基于下一个token判断状态跳转\n            JsonToken nextJsonToken = this.jsonTokenReader.peek();\n            if(nextJsonToken.getType() == JsonTokenTypeEnum.COMMA){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_3;\n                return;\n            }else if (nextJsonToken.getType() == JsonTokenTypeEnum.RIGHT_BRACKET){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_2;\n                return;\n            }else{\n                throw new MuJsonParserException(\"unexpected token! index=\" + (jsonTokenReader.currentIndex()+1));\n            }\n        }else{\n            // 别的情况都说明有问题，不是合法的json\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private void processInParseObject3(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.COLON){\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_4;\n            return;\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseObject4(JsonToken token){\n        // 嵌套的jsonObject结构\n        if(token.getType() == JsonTokenTypeEnum.LEFT_BRACE){\n            // 发现'{'，栈上推进一个JsonObject\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_OBJECT, new JsonObject()));\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_1;\n            return;\n        }\n\n        // 嵌套的jsonArray结构\n        if(token.getType() == JsonTokenTypeEnum.LEFT_BRACKET){\n            // 发现'['，栈上推进一个JsonArr\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_ARRAY, new JsonArray()));\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_1;\n            return;\n        }\n\n        // 基础类型的value\n        if(token.getType().isPrimitiveValue()){\n            JsonParseStackValue jsonKeyToken = this.parseStack.popAndCheck(JsonParseStackValueTypeEnum.JSON_KEY);\n\n            JsonToken keyToken  = (JsonToken) jsonKeyToken.getValue();\n            Assert.assertTrue(keyToken.getType() == JsonTokenTypeEnum.STRING,\"parse object keyToken not match!\");\n\n            // 获取栈顶的jsonObject对象，设置k/v\n            JsonParseStackValue topJsonObject = this.parseStack.peekAndCheck(JsonParseStackValueTypeEnum.JSON_OBJECT);\n\n            ((JsonObject) topJsonObject.getValue()).putKV(keyToken.getContent(), new JsonPrimitiveStr(token.getContent()));\n\n            accept();\n\n            // 基于下一个token判断状态跳转\n            JsonToken nextJsonToken = this.jsonTokenReader.peek();\n            if(nextJsonToken.getType() == JsonTokenTypeEnum.COMMA){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_5;\n                return;\n            }else if (nextJsonToken.getType() == JsonTokenTypeEnum.RIGHT_BRACE){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_2;\n                return;\n            }else{\n                throw new MuJsonParserException(\"unexpected token! index=\" + (jsonTokenReader.currentIndex()+1));\n            }\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseObject5(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.COMMA){\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_6;\n            return;\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseObject6(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.STRING){\n            // 把key先压入栈中，然后等构造kv对时弹出\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_KEY,token));\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_3;\n            return;\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseArr0(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.LEFT_BRACKET){\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_1;\n            return;\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseArr1(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.RIGHT_BRACKET){\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_2;\n            return;\n        }\n\n        // 嵌套的jsonObject结构\n        if(token.getType() == JsonTokenTypeEnum.LEFT_BRACE){\n            // 发现'{'，栈上推进一个JsonObject\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_OBJECT, new JsonObject()));\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_1;\n            return;\n        }\n\n        // 嵌套的jsonArray结构\n        if(token.getType() == JsonTokenTypeEnum.LEFT_BRACKET){\n            // 发现'['，栈上推进一个JsonArr\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_ARRAY, new JsonArray()));\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_1;\n            return;\n        }\n\n        // 基础类型的value\n        if(token.getType().isPrimitiveValue()){\n            // 获取栈顶的jsonArr对象，添加一个元素\n            JsonParseStackValue topJsonArr = this.parseStack.peekAndCheck(JsonParseStackValueTypeEnum.JSON_ARRAY);\n\n            ((JsonArray) topJsonArr.getValue()).addElement(new JsonPrimitiveStr(token.getContent()));\n\n            accept();\n\n            // 基于下一个token判断状态跳转\n            JsonToken nextJsonToken = this.jsonTokenReader.peek();\n            if(nextJsonToken.getType() == JsonTokenTypeEnum.COMMA){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_3;\n                return;\n            }else if (nextJsonToken.getType() == JsonTokenTypeEnum.RIGHT_BRACKET){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_2;\n                return;\n            }else{\n                throw new MuJsonParserException(\"unexpected token! index=\" + (jsonTokenReader.currentIndex()+1));\n            }\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseArr2(JsonToken token){\n        // 遇到']'才会进来\n        if(token.getType() != JsonTokenTypeEnum.RIGHT_BRACKET){\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }else{\n            accept();\n        }\n\n        // 当前栈顶必定是JsonArray，先将其弹出，然后看栈顶的元素类型判断\n        JsonParseStackValue currentJsonObjectStackValue = this.parseStack.popAndCheck(JsonParseStackValueTypeEnum.JSON_ARRAY);\n        if(this.parseStack.isEmpty()){\n            // 说明是root的JsonArr解析完了，再推回去直接返回\n            this.parseStack.push(currentJsonObjectStackValue);\n            this.currentStatus = StackBaseJsonParserStatusEnum.END_PARSE;\n            return;\n        }\n\n        JsonArray jsonArray = (JsonArray) currentJsonObjectStackValue.getValue();\n\n        JsonParseStackValueTypeEnum topObjType = this.parseStack.peekTopType();\n\n        if(topObjType == JsonParseStackValueTypeEnum.JSON_KEY){\n            // 如果是json_key，说明是当前jsonArray是父object的一个k/v项中的value。\n            JsonParseStackValue keyStackValue = this.parseStack.popAndCheck(JsonParseStackValueTypeEnum.JSON_KEY);\n            JsonToken keyJsonToken = (JsonToken) keyStackValue.getValue();\n\n            JsonParseStackValue parentObject = this.parseStack.peekAndCheck(JsonParseStackValueTypeEnum.JSON_OBJECT);\n\n            // 将当前k/v项附加在父object上\n            ((JsonObject)parentObject.getValue()).putKV(keyJsonToken.getContent(), jsonArray);\n\n            // 基于下一个token判断状态跳转\n            JsonToken nextJsonToken = this.jsonTokenReader.peek();\n            if(nextJsonToken.getType() == JsonTokenTypeEnum.COMMA){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_5;\n                return;\n            }else if (nextJsonToken.getType() == JsonTokenTypeEnum.RIGHT_BRACE){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_2;\n                return;\n            }else{\n                throw new MuJsonParserException(\"unexpected token! index=\" + (jsonTokenReader.currentIndex()+1));\n            }\n\n        }else if(topObjType == JsonParseStackValueTypeEnum.JSON_ARRAY){\n            // 说明当前jsonObject是jsonArray的一个元素\n\n            JsonParseStackValue parentArr = this.parseStack.peekAndCheck(JsonParseStackValueTypeEnum.JSON_ARRAY);\n            ((JsonArray)parentArr.getValue()).addElement(jsonArray);\n\n            // 基于下一个token判断状态跳转\n            JsonToken nextJsonToken = this.jsonTokenReader.peek();\n            if(nextJsonToken.getType() == JsonTokenTypeEnum.COMMA){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_3;\n                return;\n            }else if (nextJsonToken.getType() == JsonTokenTypeEnum.RIGHT_BRACKET){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_2;\n                return;\n            }else{\n                throw new MuJsonParserException(\"unexpected token! index=\" + (jsonTokenReader.currentIndex()+1));\n            }\n        }else{\n            // 别的情况都说明有问题，不是合法的json\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private void processInParseArr3(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.COMMA){\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_1;\n            return;\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n}\n\n</code></pre>\n<h5 id=\"比较堆栈与递归实现性能差异的demo\">比较堆栈与递归实现性能差异的demo</h5>\n<p>我们可以很简单的构造出一个非常深嵌套层次的json串，即由连续N个“[”和连续N个“]”构成的json字符串。即根节点为数组，同时每个数组中都有且仅有一个子元素，子元素的类型依然是数组，依次类推。</p>\n<pre><code class=\"language-java\">public class TestHugeLevelJsonParse {\n\n    @Test\n    public void testHugeLevelJsonParse() {\n        int level = 3500;\n        String hugeLevelJson = TestUtil.buildHugeLevelJson(level);\n\n        // 3500层的深度，会StackOverflowError栈溢出\n        Error recursiveJsonParseEx = null;\n        try{\n            RecursiveJsonParser recursiveJsonParser = new RecursiveJsonParser(new StreamJsonTokenReader(hugeLevelJson));\n            JsonElement obj = recursiveJsonParser.doParse();\n        }catch (Error e){\n            recursiveJsonParseEx = e;\n        }\n\n        Assert.assertTrue(recursiveJsonParseEx instanceof StackOverflowError);\n        System.out.println(\"level = \" + level + \" recursiveJsonParseEx has StackOverflowError!\");\n\n        // jackson默认json深度为1000，超过了会报错\n        {\n            try {\n                Object obj = JackSonUtil.string2Obj(hugeLevelJson, Object.class);\n            }catch (Exception e){\n                // 会报错\n                System.out.println(\"jackson parse hugeLevelJson error!   \" + e.getCause().getMessage());\n            }\n        }\n\n        // 基于堆栈的能正确的解析出来，不会StackOverflowError栈溢出\n        {\n            StackBaseJsonParser stackBaseJsonParser = new StackBaseJsonParser(new StreamJsonTokenReader(hugeLevelJson));\n            JsonElement obj = stackBaseJsonParser.doParse();\n            int arrayLevel = TestUtil.getSpecialJsonArrayLevel(obj);\n            Assert.assertEquals(arrayLevel, level - 1);\n            System.out.println(\"stackBaseJsonParser parse，arrayLevel=\" + arrayLevel);\n        }\n    }\n}\n</code></pre>\n<p><img alt=\"test_huge_level_json_parse\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211200045678-964632399.png\" /></p>\n<h5 id=\"递归-vs-堆栈解析的取舍\">递归 vs 堆栈解析的取舍</h5>\n<ul>\n<li>基于递归的json语法解析器实现简单，思路更直观，但受限于线程栈大小，在极深层级下会出现StackOverflow。</li>\n<li>基于堆栈的json语法解析器状态机更庞大，实现起来更复杂，但将调用栈搬到堆上之后，能处理极深层级的json（只要堆内存足够）。</li>\n<li>Jackson等成熟的三方库即使同样基于堆栈实现，通常也会设置一个合理的深度上限，避免恶意或异常的json导致系统资源耗尽。</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>到这里，我们已经如开头所说的那般，一步一步的从零开始实现了一个简单的json解析器。<br />\n虽然网络上已经有着大量关于json解析器实现原理的博客，甚至利用ai都能帮你实现的大差不差。但是纸上得来终觉浅，绝知此事要躬行，想要更好的学习编译原理，去理解乃至实现更复杂的编译器、解释器，通过自己动手去体会那些晦涩抽象的原理也许是一种效率较低但长远看受益无穷的学习方式。</p>\n<h5 id=\"_-19\"></h5>\n<p>博客中展示的完整代码在我的github上：<a href=\"https://github.com/1399852153/MySimpleJsonParser\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/1399852153/MySimpleJsonParser</a> (main分支)。<br />\n希望能够帮助到对json解析或是编译原理感兴趣的读者，内容如有错误，还请多多指教。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-02-11 20:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xiaoxiongcanguan\">小熊餐馆</a>&nbsp;\n阅读(<span id=\"post_view_count\">16</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "类型擦除与部分异步编程",
      "link": "https://www.cnblogs.com/suiyuan129/p/19605836",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/suiyuan129/p/19605836\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 20:16\">\n    <span>类型擦除与部分异步编程</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"类型擦除与部分异步编程-消除差别统一使用\">类型擦除与部分异步编程: 消除差别，统一使用</h1>\n<p>C++ 中类型擦除最典型的实现思路分为两类——模板（编译期擦除）与多态（运行时擦除），这两种方式大家都比较熟悉。而标准库为我们封装了更易用的类型擦除工具，核心包括 <code>std::function</code>、<code>std::any</code>、<code>std::span</code> 和 <code>std::variant</code>，它们在不同场景下帮我们“消除类型差别，实现统一使用”；同时，类型擦除也是异步编程的核心基础，<code>std::function</code> 搭配相关组件可实现任意异步任务的统一调度，这也是我们将两者结合讲解的核心原因。</p>\n<h2 id=\"1-stdfunction可调用对象的统一调用接口\">1. std::function：可调用对象的“统一调用接口”</h2>\n<p><code>std::function</code> 是针对<strong>可调用对象</strong>的类型擦除工具，其底层实现核心是「抽象基类 + 模板子类」的多态模式，也是运行时类型擦除的典型应用：</p>\n<ul>\n<li>抽象基类：定义了与“函数签名”完全匹配的纯虚调用接口（比如 <code>virtual Ret call(Args...) = 0</code>），作为统一调用的基准；</li>\n<li>模板子类：存储具体的可调用对象（函数、lambda、仿函数、<code>std::bind</code> 结果等），并重写抽象基类的 <code>call</code> 方法，适配具体对象的调用逻辑。</li>\n</ul>\n<p>正因为 <code>std::function</code> 是通过调用<strong>抽象基类的统一接口</strong>，间接呼叫存入模板子类中的具体函数，所以我们<strong>必须提前明确告知 <code>std::function</code> 完整的函数签名（返回值类型、参数类型、参数个数）</strong> —— 这是抽象基类定义统一调用接口的前提，只有签名一致，所有被擦除类型的可调用对象，才能通过抽象基类的接口被正确调用。也正因运行时的多态派发（通过抽象基类指针调用子类的 <code>call</code> 方法），<code>std::function</code> 会产生一定的运行时开销。</p>\n<h3 id=\"测试代码stdfunction-统一调用不同可调用对象\">测试代码：std::function 统一调用不同可调用对象</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;string&gt;\n\n// 普通函数\nint add(int a, int b) { return a + b; }\n\n// 仿函数\nstruct Multiply {\n    int operator()(int a, int b) { return a * b; }\n};\n\nint main() {\n    // 定义函数签名：int(int, int)\n    std::function&lt;int(int, int)&gt; func;\n\n    // 存储普通函数\n    func = add;\n    std::cout &lt;&lt; \"add(3,4) = \" &lt;&lt; func(3, 4) &lt;&lt; std::endl; // 输出7\n\n    // 存储lambda表达式\n    func = [](int a, int b) { return a - b; };\n    std::cout &lt;&lt; \"sub(3,4) = \" &lt;&lt; func(3, 4) &lt;&lt; std::endl; // 输出-1\n\n    // 存储仿函数\n    func = Multiply{};\n    std::cout &lt;&lt; \"mul(3,4) = \" &lt;&lt; func(3, 4) &lt;&lt; std::endl; // 输出12\n\n    return 0;\n}\n</code></pre>\n<p>代码说明：无论存储的是普通函数、lambda还是仿函数，只要函数签名匹配 <code>int(int, int)</code>，就能通过 <code>std::function</code> 统一调用，体现了类型擦除“消除差别，统一使用”的核心。</p>\n<h2 id=\"2-stdany--stdvariant数据存储的类型擦除双雄\">2. std::any &amp; std::variant：数据存储的“类型擦除双雄”</h2>\n<p>两者均用于实现数据存储的类型擦除，但定位互补，<code>std::variant</code> 核心是弥补 <code>std::any</code> 的繁琐与低效问题。</p>\n<h3 id=\"stdany无约束的全类型擦除\">std::any：无约束的全类型擦除</h3>\n<p><code>std::any</code> 是经典的“全类型擦除”工具，它完全擦除编译期的类型信息，仅保留“数据本身 + 运行时类型ID（<code>std::type_info</code>）”，相当于一个“带类型标签的万能盒子”，能存储任意类型的数据。<br />\n和 <code>std::function</code> 类似，<code>std::any</code> 需在运行时通过类型ID识别内部数据类型，因此存在运行时开销；此外，<code>std::any</code> 对大类型会进行堆内存分配，进一步增加轻微的内存开销。其最大的特点是自由无约束，但这份自由也带来了操作繁琐的问题——使用时必须手动通过 <code>typeid</code> 检查类型，再用 <code>any_cast</code> 提取数据，且类型错误只能在运行时暴露（抛出 <code>std::bad_any_cast</code> 异常）。</p>\n<h3 id=\"stdvariant有限制的高效类型擦除\">std::variant：有限制的高效类型擦除</h3>\n<p><code>std::variant</code> 是为解决 <code>std::any</code> 的痛点而生，它通过<strong>编译期提前声明可存储的类型范围</strong>，实现了更高效、更安全的类型擦除，属于“有限类型擦除”：</p>\n<ul>\n<li>编译期兜底：写错类型（比如用 <code>std::get</code> 提取非活跃类型）会被编译器及时提醒，更早暴露问题，避免运行时异常难以调试；</li>\n<li>统一便捷处理：无需手写一堆 <code>if (typeid)</code> 判断分支，通过 <code>std::visit</code> 就能批量处理所有预定义类型，代码更简洁、不易漏分支；</li>\n<li>零堆开销：<code>std::variant</code> 的大小在编译期确定（等于所有预定义类型中最大类型的尺寸 + 类型标签尺寸），所有数据均存储在栈上，无堆分配开销；</li>\n<li>安全提取：提供 <code>std::holds_alternative</code>（判断是否为指定类型）、<code>std::get_if</code>（安全提取，不匹配返回 <code>nullptr</code>）等工具，无需捕获异常，类型检查和数据提取更直观、安全。</li>\n</ul>\n<p>简单来说，<code>std::any</code> 是“无拘无束但全靠手动”，<code>std::variant</code> 是“有限制但编译器帮你兜底”，这份限制恰恰是它简化操作、提升效率的核心。</p>\n<h3 id=\"测试代码stdany-与-stdvariant-对比\">测试代码：std::any 与 std::variant 对比</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;any&gt;\n#include &lt;variant&gt;\n#include &lt;string&gt;\n#include &lt;typeinfo&gt;\n\n// 处理std::any\nvoid process_any(std::any val) {\n    if (val.type() == typeid(int)) {\n        std::cout &lt;&lt; \"any存储int：\" &lt;&lt; std::any_cast&lt;int&gt;(val) &lt;&lt; std::endl;\n    } else if (val.type() == typeid(std::string)) {\n        std::cout &lt;&lt; \"any存储string：\" &lt;&lt; std::any_cast&lt;std::string&gt;(val) &lt;&lt; std::endl;\n    } else if (val.type() == typeid(double)) {\n        std::cout &lt;&lt; \"any存储double：\" &lt;&lt; std::any_cast&lt;double&gt;(val) &lt;&lt; std::endl;\n    }\n}\n\n// 处理std::variant\nusing MyVariant = std::variant&lt;int, std::string, double&gt;;\nvoid process_variant(const MyVariant&amp; val) {\n    // 无需手写if(typeid)，std::visit批量处理\n    std::visit([](const auto&amp; v) {\n        using T = std::decay_t&lt;decltype(v)&gt;;\n        if constexpr (std::is_same_v&lt;T, int&gt;) {\n            std::cout &lt;&lt; \"variant存储int：\" &lt;&lt; v &lt;&lt; std::endl;\n        } else if constexpr (std::is_same_v&lt;T, std::string&gt;) {\n            std::cout &lt;&lt; \"variant存储string：\" &lt;&lt; v &lt;&lt; std::endl;\n        } else if constexpr (std::is_same_v&lt;T, double&gt;) {\n            std::cout &lt;&lt; \"variant存储double：\" &lt;&lt; v &lt;&lt; std::endl;\n        }\n    }, val);\n}\n\nint main() {\n    // std::any测试\n    std::any a = 10;\n    process_any(a); // 输出any存储int：10\n    a = std::string(\"hello any\");\n    process_any(a); // 输出any存储string：hello any\n    a = 3.14;\n    process_any(a); // 输出any存储double：3.14\n\n    // std::variant测试\n    MyVariant v = 20;\n    process_variant(v); // 输出variant存储int：20\n    v = std::string(\"hello variant\");\n    process_variant(v); // 输出variant存储string：hello variant\n    v = 6.28;\n    process_variant(v); // 输出variant存储double：6.28\n\n    // std::variant安全提取示例\n    if (std::holds_alternative&lt;double&gt;(v)) {\n        auto p = std::get_if&lt;double&gt;(&amp;v);\n        std::cout &lt;&lt; \"安全提取double：\" &lt;&lt; *p &lt;&lt; std::endl; // 输出6.28\n    }\n\n    return 0;\n}\n</code></pre>\n<p>代码说明：</p>\n<ul>\n<li><code>std::any</code> 需手动写 <code>if (typeid)</code> 分支，新增类型时需手动扩展；</li>\n<li><code>std::variant</code> 借助 <code>std::visit</code> 批量处理所有预定义类型，代码更简洁，且 <code>holds_alternative</code>/<code>get_if</code> 让类型检查/提取更安全。</li>\n</ul>\n<h2 id=\"3-stdspan连续容器的零开销类型擦除\">3. std::span：连续容器的“零开销类型擦除”</h2>\n<p><code>std::span</code> 是针对<strong>连续内存容器</strong>的“特制类型擦除工具”，专门用于消除不同连续容器的类型差异，实现统一访问：<br />\n它会擦除 <code>std::vector</code>、<code>std::array</code>、C风格数组等连续容器的具体类型，仅保留“起始指针 + 元素长度”两个核心特征，相当于给所有连续内存容器提供了一个统一的“视图”。<br />\n<code>std::span</code> 的核心优势是<strong>零运行时开销</strong>——类型擦除在编译期完成，无需运行时额外计算或内存分配；但也有明确限制：仅支持连续内存容器，无法处理 <code>std::list</code> 等非连续内存容器。</p>\n<h3 id=\"测试代码stdspan-统一访问不同连续容器\">测试代码：std::span 统一访问不同连续容器</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;span&gt;\n#include &lt;vector&gt;\n#include &lt;array&gt;\n\n// 统一处理所有连续int容器\nvoid print_span(std::span&lt;int&gt; sp) {\n    std::cout &lt;&lt; \"容器长度：\" &lt;&lt; sp.size() &lt;&lt; \"，内容：\";\n    for (int val : sp) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n\nint main() {\n    // std::vector\n    std::vector&lt;int&gt; vec = {1, 2, 3};\n    print_span(vec); // 输出容器长度：3，内容：1 2 3\n\n    // std::array\n    std::array&lt;int, 4&gt; arr = {4, 5, 6, 7};\n    print_span(arr); // 输出容器长度：4，内容：4 5 6 7\n\n    // C风格数组\n    int c_arr[] = {8, 9, 10};\n    print_span(c_arr); // 输出容器长度：3，内容：8 9 10\n\n    // 切片访问（span的额外优势）\n    print_span(std::span(vec).subspan(1, 2)); // 输出容器长度：2，内容：2 3\n\n    return 0;\n}\n</code></pre>\n<p>代码说明：<code>print_span</code> 函数无需关心传入的是 <code>vector</code>、<code>array</code> 还是C数组，<code>std::span</code> 擦除了容器类型差异，实现统一访问，且无任何运行时开销。</p>\n<h2 id=\"4-类型擦除在异步编程中的核心应用\">4. 类型擦除在异步编程中的核心应用</h2>\n<p>为什么要将类型擦除与异步编程结合？因为 <code>std::function</code> 的类型擦除能力，是异步任务“统一管理”的核心，它常搭配 lambda 表达式、<code>std::packaged_task</code>、<code>std::bind</code> 实现任意异步任务的统一调度，核心逻辑是“擦除任务差异，统一管理，按需获取结果”：</p>\n<ol>\n<li>用 <code>std::bind</code> 将任务参数与可调用对象绑定，擦除不同任务的参数类型差异，让有参任务适配统一的调用形式；</li>\n<li>将绑定后的任务装入 <code>std::packaged_task</code>，通过 <code>std::packaged_task</code> 内置的 <code>std::promise</code>，获取 <code>std::future</code> 对象（用于后续接收异步任务的返回值）—— 此时任务的返回值类型未被擦除；</li>\n<li>通过 lambda 表达式封装 <code>std::packaged_task</code> 的执行逻辑，将“有返回值的任务”包装成无返回值的 <code>void()</code> 类型，从而擦除返回值差异；</li>\n<li>最终，所有异步任务均可统一装进 <code>std::function&lt;void()&gt;</code> 中进行管理，任务的返回值则在异步执行完成后，自动存入 <code>std::packaged_task</code> 内部的 <code>std::promise</code>，我们通过之前获取的 <code>std::future</code> 就能按需获取异步结果，实现“任务统一管理 + 结果按需获取”。</li>\n</ol>\n<h3 id=\"测试代码类型擦除实现异步任务统一管理\">测试代码：类型擦除实现异步任务统一管理</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;future&gt;\n#include &lt;thread&gt;\n#include &lt;queue&gt;\n#include &lt;mutex&gt;\n#include &lt;condition_variable&gt;\n#include &lt;string&gt;\n\n// 全局任务队列：存储统一的无返回值任务\nstd::queue&lt;std::function&lt;void()&gt;&gt; task_queue;\nstd::mutex mtx;\nstd::condition_variable cv;\nbool stop = false;\n\n// 工作线程：消费任务队列\nvoid worker() {\n    while (!stop) {\n        std::function&lt;void()&gt; task;\n        // 加锁取任务\n        {\n            std::unique_lock&lt;std::mutex&gt; lock(mtx);\n            cv.wait(lock, []() { return stop || !task_queue.empty(); });\n            if (stop &amp;&amp; task_queue.empty()) return;\n            task = std::move(task_queue.front());\n            task_queue.pop();\n        }\n        // 执行任务\n        task();\n    }\n}\n\n// 提交任务模板：擦除参数/返回值差异，统一存入队列\ntemplate&lt;typename F, typename... Args&gt;\nauto submit_task(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;decltype(f(args...))&gt; {\n    // 绑定参数，擦除参数差异\n    auto bound_task = std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);\n    // 定义packaged_task，保留返回值类型\n    using RetType = decltype(f(args...));\n    std::packaged_task&lt;RetType()&gt; pt(std::move(bound_task));\n    // 获取future用于接收结果\n    std::future&lt;RetType&gt; fut = pt.get_future();\n    // 封装成void()任务，擦除返回值差异\n    std::function&lt;void()&gt; wrapper = [pt = std::move(pt)]() mutable {\n        pt(); // 执行packaged_task，结果存入promise\n    };\n    // 存入任务队列\n    {\n        std::lock_guard&lt;std::mutex&gt; lock(mtx);\n        task_queue.push(std::move(wrapper));\n    }\n    cv.notify_one(); // 唤醒工作线程\n    return fut;\n}\n\n// 测试任务1：有参有返回值（计算平方）\nint square(int x) {\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    return x * x;\n}\n\n// 测试任务2：有参有返回值（拼接字符串）\nstd::string concat(const std::string&amp; a, const std::string&amp; b) {\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    return a + b;\n}\n\nint main() {\n    // 启动工作线程\n    std::thread t(worker);\n\n    // 提交任务1：计算5的平方\n    auto fut1 = submit_task(square, 5);\n    // 提交任务2：拼接字符串\n    auto fut2 = submit_task(concat, \"hello \", \"async\");\n\n    // 主线程等待结果\n    std::cout &lt;&lt; \"等待异步任务结果...\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"5的平方：\" &lt;&lt; fut1.get() &lt;&lt; std::endl; // 输出25\n    std::cout &lt;&lt; \"字符串拼接：\" &lt;&lt; fut2.get() &lt;&lt; std::endl; // 输出hello async\n\n    // 停止工作线程\n    stop = true;\n    cv.notify_one();\n    t.join();\n\n    return 0;\n}\n</code></pre>\n<p>代码说明：</p>\n<ul>\n<li><code>square</code> 和 <code>concat</code> 是不同签名的任务（参数/返回值均不同）；</li>\n<li>通过 <code>std::bind</code> 擦除参数差异，<code>std::packaged_task</code> 保留返回值并绑定 <code>future</code>，lambda 封装成 <code>void()</code> 擦除返回值差异；</li>\n<li>最终所有任务都能存入 <code>std::function&lt;void()&gt;</code> 队列，实现统一管理，体现了类型擦除在异步编程中的核心价值。</li>\n</ul>\n<h2 id=\"整体总结\">整体总结</h2>\n<p>标准库中的四种类型擦除工具，虽定位不同，但核心目标一致——<strong>消除类型差别，实现统一使用</strong>：</p>\n<ol>\n<li><code>std::function</code>：针对可调用对象，统一调用接口，依赖函数签名和多态实现，有运行时开销；</li>\n<li><code>std::any</code>：针对任意数据，全类型擦除，自由但繁琐、有运行时和堆内存开销；</li>\n<li><code>std::variant</code>：针对有限范围数据，弥补 <code>std::any</code> 不足，编译期兜底、高效便捷、零堆开销；</li>\n<li><code>std::span</code>：针对连续容器，零开销类型擦除，统一连续内存访问接口，仅支持连续容器。</li>\n</ol>\n<p>而类型擦除与异步编程的结合，核心是借助 <code>std::function</code> 的统一管理能力，搭配 lambda、<code>std::packaged_task</code>、<code>std::bind</code> 等组件，擦除不同异步任务的参数和返回值差异，实现任意异步任务的统一调度，这也是类型擦除在实际开发中最常用的场景之一。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 20:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/suiyuan129\">suiyuan129</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "简易的分布式kv设计",
      "link": "https://www.cnblogs.com/jackjavacpp/p/19605754",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jackjavacpp/p/19605754\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 19:47\">\n    <span>简易的分布式kv设计</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简易的分布式kv设计--一\">简易的分布式kv设计--(一)</h1>\n<p><strong>这篇文章目前只设计到集群启动，然后自动选主的功能。</strong></p>\n<p>地址：<a href=\"https://github.com/Jack-txf/easy-kv\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Jack-txf/easy-kv</a></p>\n<p><strong>TIPS</strong>：此文章对应的分支版本是<strong>version0211</strong></p>\n<p>raft基础知识：<a href=\"https://mp.weixin.qq.com/s/DHO2CK87kI-clf4O96t5Cw\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/DHO2CK87kI-clf4O96t5Cw</a></p>\n<h1 id=\"1-前言\">1. 前言</h1>\n<p>在 Raft KV 系统中，每个节点（Node）都是对等的。一个典型的请求流向是： <code>Client</code> -&gt; <code>Leader Node</code> -&gt; <code>Raft 日志同步</code> -&gt; <code>大多数节点确认</code> -&gt; <code>应用到状态机 (KV Store)</code> -&gt; <code>返回 Client</code>。</p>\n<h1 id=\"2-设计步骤\">2. 设计步骤</h1>\n<p>Raft 核心组件包括：一致性结点模块，RPC 通信，日志模块。</p>\n<h2 id=\"21-日志\">2.1 日志</h2>\n<pre><code class=\"language-txt\">写日志 → 复制日志 → commit → apply 【leader应用顺序】\n\n细分一下的话就如下：\nClient\n   ↓\nLeader\n   ↓ append log (本地)\n   ↓\n发送 AppendEntries\n   ↓\nFollowers append log\n   ↓\n多数成功\n   ↓\nLeader commit\n   ↓\nLeader apply\n   ↓\n返回客户端成功\n   ↓\nLeader 下次心跳带 commitIndex\n   ↓\nFollowers apply\n</code></pre>\n<p>首先看一下，客户端发送一个请求，涉及到的大致东西有哪些：</p>\n<img src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194613207-412932482.png\" />\n<p>从后往前看，我们需要设计的就是如何写入日志文件，以及日志文件的格式该如何设计呢？此处我们就弄简单一点儿就好了</p>\n<table>\n<thead>\n<tr>\n<th>totalLength （int）</th>\n<th>term（long）</th>\n<th>index（long）</th>\n<th>commandLength（int）</th>\n<th>command（byte[]）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>整条log entry 长度</td>\n<td>Raft term</td>\n<td>日志 index</td>\n<td>命令长度</td>\n<td>真正命令，这个肯定是变长的</td>\n</tr>\n</tbody>\n</table>\n<p>totalLength = 8 (term) + 8 (index) + 4 (commandLength) + commandLength</p>\n<pre><code class=\"language-java\">public class LogEntry {\n    private final long term;\n    private final long index;\n    private final String command;\n    ....\n}\n</code></pre>\n<p>日志存储与管理</p>\n<pre><code class=\"language-java\">/**\n * @Description: 日志存储与管理\n * @Author: txf\n * @Date: 2026/2/9\n */\npublic class LogManager {\n    // 日志文件路径\n    private static final String LOG_FILE_PATH = \"easy_kv_log.dat\";\n    // 内存映射的分段大小（128MB，可根据内存调整）,这里先调整为两兆\n    private static final int MAPPED_SIZE = 2 * 1024 * 1024;\n    // 文件打开模式：rw = 读写\n    private static final String FILE_MODE = \"rw\";\n\n    private final File logFile;\n    private RandomAccessFile raf;\n    private FileChannel fileChannel;\n    // 当前映射的内存缓冲区\n    private MappedByteBuffer currentMappedBuffer;\n    // 当前映射段的起始偏移（文件偏移）\n    private long currentMappedOffset = 0;\n    // 当前写入的位置（相对于文件的总偏移）\n    private long writePosition = 0;\n\n    public LogManager() {\n        this.logFile = new File(LOG_FILE_PATH);\n        initFileChannel();\n        initMappedBuffer();\n        // 初始化时定位到文件末尾（继续追加写）\n        try {\n            this.writePosition = fileChannel.size();\n        } catch (IOException e) {\n            throw new RuntimeException(\"获取文件大小失败\", e);\n        }\n    }\n\n    /**\n     * 追加写入单条日志（核心高性能写入）\n     * @param term Raft任期\n     * @param index 日志索引\n     * @param command KV操作命令（如\"PUT key value\"）\n     */\n    public void appendLogEntry(long term, long index, String command) {\n        // 1. 准备命令字节数组\n        byte[] commandBytes = command.getBytes(StandardCharsets.UTF_8);\n        int commandLength = commandBytes.length;\n        // 2. 计算总长度\n        int totalLength = 4 + 8 + 8 + 4 + commandLength;\n\n        // 3. 准备直接缓冲区（堆外内存，避免拷贝）\n        ByteBuffer directBuffer = ByteBuffer.allocateDirect(totalLength);\n        // 按格式写入缓冲区 -- 这里是写入二进制的，文件内容我们人类就读不懂了\n        directBuffer.putInt(totalLength);\n        directBuffer.putLong(term);\n        directBuffer.putLong(index);\n        directBuffer.putInt(commandLength);\n        directBuffer.put(commandBytes);\n\n        // 这里是写入字符串的\n        // directBuffer.put((term + index + command).getBytes(StandardCharsets.UTF_8));\n\n        // 翻转缓冲区（从写模式转为读模式）\n        directBuffer.flip();\n        // 4. 写入到内存映射缓冲区（核心：零拷贝）\n        writeToMappedBuffer(directBuffer);        // 5. 更新全局写入位置\n        writePosition += totalLength;\n    }\n\n    /**\n     * 将缓冲区数据写入内存映射区（自动扩容映射段）\n     */\n    private void writeToMappedBuffer(ByteBuffer buffer) {\n        while (buffer.hasRemaining()) {\n            // 检查当前映射缓冲区是否有足够剩余空间\n            if (currentMappedBuffer.remaining() &lt; buffer.remaining()) {\n                // 先写入当前映射区的剩余空间\n                int remaining = currentMappedBuffer.remaining();\n                byte[] temp = new byte[remaining];\n                buffer.get(temp);\n                currentMappedBuffer.put(temp);\n                // 强制刷盘（将映射内存的数据同步到磁盘，可选：批量刷盘可提升性能）\n                currentMappedBuffer.force();\n                // 扩容映射段\n                initMappedBuffer();\n            } else {\n                // 直接写入映射缓冲区\n                currentMappedBuffer.put(buffer);\n            }\n        }\n    }\n\n    /**\n     * 读取指定索引的日志条目（高性能读取）\n     */\n    public LogEntry readLogEntry(long index) {\n        try {\n            // 使用FileChannel + 直接缓冲区读取\n            ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024 * 1024); // 1MB直接缓冲区\n            long fileOffset = 0;\n            long fileSize = fileChannel.size();\n\n            while (fileOffset &lt; fileSize) {\n                // 重置缓冲区\n                directBuffer.clear();\n                // 从文件指定偏移读取数据到缓冲区\n                int readBytes = fileChannel.read(directBuffer, fileOffset);\n                if (readBytes == -1) break;\n                directBuffer.flip();\n\n                // 解析缓冲区中的日志条目\n                while (directBuffer.hasRemaining()) {\n                    // 检查剩余字节是否足够读取固定头部（4+8+8+4=24字节）\n                    if (directBuffer.remaining() &lt; 24) break;\n                    // 读取固定字段\n                    int totalLength = directBuffer.getInt();\n                    long term = directBuffer.getLong();\n                    long currentIndex = directBuffer.getLong();\n                    int commandLength = directBuffer.getInt();\n                    // 检查剩余字节是否足够读取command\n                    if (directBuffer.remaining() &lt; commandLength) {\n                        // 回退缓冲区position，下次继续解析\n                        directBuffer.position(directBuffer.position() - 24);\n                        break;\n                    }\n                    // 读取command\n                    byte[] commandBytes = new byte[commandLength];\n                    directBuffer.get(commandBytes);\n                    String command = new String(commandBytes, StandardCharsets.UTF_8);\n                    // 校验总长度\n                    int actualLength = 4 + 8 + 8 + 4 + commandLength;\n                    if (totalLength != actualLength) {\n                        throw new RuntimeException(\"日志文件损坏：总长度不匹配\");\n                    }\n                    // 找到目标索引则返回\n                    if (currentIndex == index) {\n                        return new LogEntry(term, index, command);\n                    }\n                    // 更新文件偏移\n                    fileOffset += totalLength;\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"读取日志条目失败 [index=\" + index + \"]\", e);\n        }\n        return null;\n    }\n\n    /**\n     * 加载所有日志条目（节点启动时恢复）\n     */\n    public List&lt;LogEntry&gt; loadAllLogEntries() {\n        List&lt;LogEntry&gt; logEntries = new ArrayList&lt;&gt;();\n        try {\n            ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024 * 1024);\n            long fileOffset = 0;\n            long fileSize = fileChannel.size();\n\n            while (fileOffset &lt; fileSize) {\n                directBuffer.clear();\n                int readBytes = fileChannel.read(directBuffer, fileOffset);\n                if (readBytes == -1) break;\n                directBuffer.flip();\n\n                while (directBuffer.hasRemaining()) {\n                    if (directBuffer.remaining() &lt; 24) break;\n\n                    int totalLength = directBuffer.getInt();\n                    long term = directBuffer.getLong();\n                    long index = directBuffer.getLong();\n                    int commandLength = directBuffer.getInt();\n\n                    if (directBuffer.remaining() &lt; commandLength) {\n                        directBuffer.position(directBuffer.position() - 24);\n                        break;\n                    }\n\n                    byte[] commandBytes = new byte[commandLength];\n                    directBuffer.get(commandBytes);\n                    String command = new String(commandBytes, StandardCharsets.UTF_8);\n\n                    int actualLength = 4 + 8 + 8 + 4 + commandLength;\n                    if (totalLength != actualLength) {\n                        throw new RuntimeException(\"日志文件损坏：总长度不匹配\");\n                    }\n\n                    logEntries.add(new LogEntry(term, index, command));\n                    fileOffset += totalLength;\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"加载所有日志条目失败\", e);\n        }\n        return logEntries;\n    }\n\n    /**\n     * 强制刷盘（将映射内存的数据同步到磁盘）\n     */\n    public void forceFlush() {\n        if (currentMappedBuffer != null) {\n            currentMappedBuffer.force(); // 同步映射内存到磁盘\n        }\n        try {\n            fileChannel.force(true); // 强制刷盘（包含元数据）\n        } catch (IOException e) {\n            throw new RuntimeException(\"刷盘失败\", e);\n        }\n    }\n\n    /**\n     * 关闭资源（必须调用，否则会导致文件句柄泄漏）\n     */\n    public void close() {\n        try {\n            forceFlush();\n            if (fileChannel != null) {\n                fileChannel.close();\n            }\n            if (raf != null) {\n                raf.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"关闭资源失败\", e);\n        }\n    }\n    /**\n     * 初始化/扩容内存映射缓冲区\n     */\n    private void initMappedBuffer() {\n        try {\n            // 计算需要映射的起始位置和大小\n            long fileSize = fileChannel.size();\n            // 如果当前映射段已写满，或首次初始化，创建新的映射\n            if (currentMappedBuffer == null || writePosition &gt;= currentMappedOffset + MAPPED_SIZE) {\n                currentMappedOffset = (writePosition / MAPPED_SIZE) * MAPPED_SIZE;\n                // 映射文件的指定区间到内存（FileChannel.MapMode.READ_WRITE：读写模式）\n                currentMappedBuffer = fileChannel.map(\n                        FileChannel.MapMode.READ_WRITE,\n                        currentMappedOffset,\n                        MAPPED_SIZE\n                );\n                // 将缓冲区的position定位到当前写入位置相对于映射段的偏移\n                currentMappedBuffer.position((int) (writePosition - currentMappedOffset));\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"初始化内存映射缓冲区失败\", e);\n        }\n    }\n\n    /**\n     * 初始化FileChannel（核心高性能通道）\n     */\n    private void initFileChannel() {\n        try {\n            // 不存在则创建文件\n            if (!logFile.exists()) {\n                boolean newFile = logFile.createNewFile();\n                if (!newFile) {\n                    throw new RuntimeException(\"创建文件失败\");\n                }\n            }\n            this.raf = new RandomAccessFile(logFile, FILE_MODE);\n            this.fileChannel = raf.getChannel();\n        } catch (IOException e) {\n            throw new RuntimeException(\"初始化FileChannel失败\", e);\n        }\n    }\n}\n</code></pre>\n<h2 id=\"22-服务端设计\">2.2 服务端设计</h2>\n<h3 id=\"221-消息设计\">2.2.1 消息设计</h3>\n<p>日志设计好了之后，接下来看服务端如何设计。我们使用的是netty框架，要求有netty基础。然后序列化协议采用的是protobuf，读者可以参考这篇文章：<a href=\"https://mp.weixin.qq.com/s/kg_-AMHRn_DzFbfBnkK4VQ\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/kg_-AMHRn_DzFbfBnkK4VQ</a> 这篇文章大致讲解了一下该序列化协议，并且也是采用netty整合的。根据proto文件生成类的命令如下，也可以用idea的插件自动生成。</p>\n<pre><code class=\"language-proto\">protoc  --proto_path=xxxx目录  --java_out=xxx目录  具体的proto文件\n</code></pre>\n<p>消息模板如下：</p>\n<pre><code class=\"language-proto\">syntax = \"proto3\";\noption java_outer_classname = \"KvRaftProto\"; // 生成的外层类名\noption java_multiple_files = false; // 生成多个独立的Java类（而非内部类）\n\n// ===================== 1. 通用消息封装体（核心） =====================\n// Netty传输时只传这个消息，通过type识别具体消息类型\nmessage RaftKvMessage {\n  // 消息类型枚举（覆盖所有交互场景）\n  enum MessageType {\n    UNKNOWN = 0; // 未知类型（兜底）\n    // 客户端 ↔ 节点：KV操作\n    KV_REQUEST = 1;    // 客户端发起KV请求（PUT/GET/DELETE）\n    KV_RESPONSE = 2;   // 节点响应客户端KV请求\n    // 节点 ↔ 节点：Raft共识\n    VOTE_REQUEST = 3;  // 选举请求（Candidate→Follower）\n    VOTE_RESPONSE = 4; // 选举响应（Follower→Candidate）\n    APPEND_ENTRIES_REQUEST = 5;  // 日志追加/心跳（Leader→Follower）\n    APPEND_ENTRIES_RESPONSE = 6; // 日志追加响应（Follower→Leader）\n  }\n\n  MessageType type = 1; // 消息类型（必传）\n  string node_id = 2;   // 发送方节点ID（用于识别节点）\n\n  // 具体消息体（根据type选择其中一个）\n  KvRequest kv_request = 3;\n  KvResponse kv_response = 4;\n  VoteRequest vote_request = 5;\n  VoteResponse vote_response = 6;\n  AppendEntriesRequest append_entries_request = 7;\n  AppendEntriesResponse append_entries_response = 8;\n}\n\n// ===================== 2. 客户端KV操作相关 =====================\n// 客户端发起的KV请求（PUT/GET/DELETE）\nmessage KvRequest {\n  enum OpType {\n    PUT = 0;    // 写入/更新\n    GET = 1;    // 读取\n    DELETE = 2; // 删除\n  }\n  OpType op_type = 1; // 操作类型（必传）\n  string key = 2;     // KV的key（必传）\n  string value = 3;   // KV的value（仅PUT时传）\n  // 可选：请求ID，用于幂等性（防止重复请求）\n  string request_id = 4;\n}\n\n// 节点响应客户端的KV结果\nmessage KvResponse {\n  bool success = 1;    // 操作是否成功\n  string message = 2;  // 错误信息/提示（失败时必传）\n  string value = 3;    // 返回的value（仅GET成功时传）\n  string request_id = 4; // 对应请求的ID（幂等性）\n}\n\n// ===================== 3. Raft选举相关 =====================\n// Candidate向Follower发起的投票请求\nmessage VoteRequest {\n  int64 term = 1;                // Candidate的当前任期（必传）\n  string candidate_id = 2;       // Candidate的节点ID（必传）\n  int64 last_log_index = 3;      // Candidate最后一条日志的索引（用于日志一致性检查）\n  int64 last_log_term = 4;       // Candidate最后一条日志的任期（用于日志一致性检查）\n}\n\n// Follower响应Candidate的投票结果\nmessage VoteResponse {\n  int64 term = 1;                // Follower的当前任期（必传，用于更新Candidate的任期）\n  bool vote_granted = 2;         // 是否投赞成票（必传）\n}\n\n// ===================== 4. Raft日志追加/心跳相关 =====================\n// 日志条目（与你设计的日志格式对齐，序列化后可直接写入日志文件）\nmessage LogEntry {\n  int64 term = 1;        // Raft任期（对应你日志格式的term）\n  int64 index = 2;       // 日志索引（对应你日志格式的index）\n  string command = 3;    // KV操作命令（如\"PUT key1 value1\"，对应你日志格式的command）\n}\n\n// Leader向Follower发送的日志追加/心跳请求\nmessage AppendEntriesRequest {\n  int64 term = 1;                // Leader的当前任期（必传）\n  string leader_id = 2;          // Leader的节点ID（必传）\n  int64 prev_log_index = 3;      // 前一条日志的索引（用于日志一致性检查）\n  int64 prev_log_term = 4;       // 前一条日志的任期（用于日志一致性检查）\n  repeated LogEntry entries = 5; // 待追加的日志条目（心跳时为空）\n  int64 leader_commit = 6;       // Leader已提交的日志索引（Follower据此更新自己的提交索引）\n}\n\n// Follower响应Leader的日志追加结果\nmessage AppendEntriesResponse {\n  int64 term = 1;                // Follower的当前任期（必传，用于更新Leader的任期）\n  bool success = 2;              // 日志追加是否成功（必传）\n  int64 match_index = 3;         // Follower已匹配的日志索引（Leader据此更新nextIndex）\n}\n</code></pre>\n<p>上面是消息的大致格式。</p>\n<p>接下来看服务端的节点设计，我们从netty服务启动开始往下看：</p>\n<p>在kv-core的app包里面</p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n    int port = getPort(args);\n    RaftNettyServer raftNettyServer = new RaftNettyServer(port);\n    try {\n        raftNettyServer.start();\n    } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n    }\n}\n\nprivate static int getPort(String[] args) {\n    for (String arg : args) {\n        if (arg.startsWith(\"node.port=\")) {\n            return Integer.parseInt(arg.substring(10));\n        }\n    }\n    return 7777;\n}\n</code></pre>\n<p>从java程序启动的命令行读取结点的端口参数，我们可以用一台电脑开启多个应用，在idea中这样配置就可以了：如下图所示</p>\n<img src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194613557-847947640.png\" />\n<p>从上图中可以看到，配置了三个节点，然后本项目的jdk是采用的21这个版本。配置好了之后，在idea的services里面可以把这些配置一起加进去，然后就可以同时启动多个节点了。</p>\n<h3 id=\"222-连接设计\">2.2.2 连接设计</h3>\n<pre><code class=\"language-java\">RaftNettyServer raftNettyServer = new RaftNettyServer(port);\n...\nraftNettyServer.start();\n</code></pre>\n<p>从上一节的启动类看出来主要就是new了一个server对象，然后调用start方法。我们顺着这两个看就可以了。</p>\n<p>首先是构造方法：</p>\n<pre><code class=\"language-java\">public class RaftNettyServer {\n  \t....\n    private final int port;\n    private final RaftNode node;\n\n    public RaftNettyServer(int port) {\n        this.port = port;\n         // 这里创建了一个raft结点对象\n        this.node = new RaftNode(port);\n    }\n}\n\n// 这个是RaftNode类，\npublic RaftNode(int port) {\n    this.port = port;\n\n    // 从配置文件中找到自己\n    this.nodesConfig = new NodesConfig();\n    this.nodeId = nodesConfig.findSelf(port);\n\n    // 需要把自身结点\n    this.rpcPeers = nodesConfig.getNodeList().stream()\n        // node的格式是'ip:port'\n        .map(node -&gt; new RpcPeer(node, node.split(\":\")[0],\n                                 Integer.parseInt(node.split(\":\")[1]), this))\n        .toList();\n\n    this.logManager = new LogManager();\n    this.storage = new MemoryStorage();\n\n    // 把两个时间先初始化咯\n    this.electionTimeout = 8000 + ThreadLocalRandom.current().nextInt(4000);\n    this.lastHeartbeatTime = System.currentTimeMillis();\n    log.info(\"初始化选举超时：{}\", electionTimeout);\n\n    // 定时器\n    scheduler = Executors.newScheduledThreadPool(2);\n    scheduler.scheduleAtFixedRate(this::tick, 2, 2000, TimeUnit.MILLISECONDS);\n}\n</code></pre>\n<p>Raft类是最核心的一个类。上面的构造方法其实很简单。读者自行理解。需要说明一下的就是nodeId的格式：【ip:端口】</p>\n<pre><code class=\"language-java\">127.0.0.1:8888 // 就是这种字符串的格式\n</code></pre>\n<p>还有要说明的就是rpcPeers这个List的构建，可以看出来先是从配置文件读取到了集群节点列表，然后遍历这个列表创建了对象，这个具体是什么意思呢？</p>\n<p>首先看一下Netty的客户端发送请求到服务端，服务端处理后在返回给客户端，客户端根据响应结果进行逻辑处理。这样一个示意图：</p>\n<img src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194613912-363189595.png\" />\n<p>再看一下下面的连接示意图：</p>\n<img src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194614275-746707923.png\" />\n<p>NettyClient不仅仅是给客户用的，集群结点内部互相通信也要用到这个，rpcPeers就是集群节点内部通信使用的。如上图所示，每个节点都有一个NettyServer启动并监听着端口，同时Leader结点需要给所有的Follower结点发送心跳请求，此时这个Leader相当于其他两个Follower结点就相当于Client了，所以在结点一里面有client的部分，在项目归到了rpc的包下，也就是上面那个rpcPeers的由来了。</p>\n<p>在集群启动的时候，都是Follower结点，只有等到超时了才会开始选主，在此之前，每个节点都有成为Candidate的可能，也就是说每个节点都有向其他结点发送投票请求的可能（VoteRequest），那么每个节点里面都要有一套Netty Client及处理流程。就如下图所示：</p>\n<img src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194614720-1938302844.png\" />\n<p>这样就有一个问题了，三个节点，我就要六个tcp连接了，四个节点就要12个连接，十个节点呢，就要90个连接，这也太多了吧，那也确实是的。有一个思路是搞一个中间层叫做routeCenter，所有结点连向它，然后消息都经过这个路由中心来转发，这样连接数就会少很多了。</p>\n<p>还有一个思路，反正NettyClient + 一个NettyServer构建出一个Channel，理论上我只需要三个tcp连接就可以了啊。如下图所示：</p>\n<img src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194615069-208910434.png\" />\n<p>但是这样的话，节点间通信需要转发了，代码逻辑就太复杂了，况且还有一个问题，那就是如何确定这个tcp的连接顺序呢？这个可以按照nodeId的字典顺序来嘛。反正就是麻烦就完事儿了。。。</p>\n<p>综上所述，还是最开始的方案最简单直接了，反正这就是一个简易的案例，不要考虑太多了。如果有一些其他合适的思路，欢迎读者给出。</p>\n<p>节点之间的连接设计就是上面的样子了。</p>\n<p>接下来看RaftNode的设计。</p>\n<h3 id=\"223-raftnode设计\">2.2.3 RaftNode设计</h3>\n<p>那就从构造器开始看吧：</p>\n<pre><code class=\"language-java\">public RaftNode(int port) {\n    this.port = port;\n\n    // 从配置文件中找到自己\n    this.nodesConfig = new NodesConfig();\n    this.nodeId = nodesConfig.findSelf(port);\n\n    // 需要把自身结点\n    this.rpcPeers = nodesConfig.getNodeList().stream()\n        // node的格式是'ip:port'\n        .map(node -&gt; new RpcPeer(node, node.split(\":\")[0],\n                                 Integer.parseInt(node.split(\":\")[1]), this))\n        .toList();\n\n    this.logManager = new LogManager();\n    this.storage = new MemoryStorage();\n\n    // 把两个时间先初始化咯\n    this.electionTimeout = 8000 + ThreadLocalRandom.current().nextInt(4000);\n    this.lastHeartbeatTime = System.currentTimeMillis();\n    log.info(\"初始化选举超时：{}\", electionTimeout);\n\n    // 定时器\n    scheduler = Executors.newScheduledThreadPool(2);\n    scheduler.scheduleAtFixedRate(this::tick, 2, 2000, TimeUnit.MILLISECONDS);\n}\n</code></pre>\n<p>可以看到都是做一些初始化的工作，然后下面是开启了一个定时任务tick</p>\n<pre><code class=\"language-java\">private void tick() {\n    log.info(\"检查是否超时：{} 状态: {}\", nodeId, state);\n    try {\n        if (state != NodeState.LEADER &amp;&amp; isTimeout()) {\n            becomeCandidate();\n        } else if (state == NodeState.LEADER) {\n            // sendHeartbeats();\n        }\n    } catch ( Exception e ) {\n        log.error(\"{} 节点tick定时任务异常\", nodeId, e);\n    }\n}\nprivate void becomeCandidate() {\n    log.info(\"{} 选举超时，转为 Candidate，开始任期: {}\", nodeId, currentTerm.get() + 1);\n    state = NodeState.CANDIDATE;\n    currentTerm.getAndIncrement(); // 任期+1\n    votedFor = nodeId; // 给自己投一票\n    resetElectionTimeout();\n    // 集群发送投票请求\n    requestVotes();\n}\n private boolean isTimeout() {\n     return System.currentTimeMillis() - lastHeartbeatTime &gt; electionTimeout;\n }\nprivate void resetElectionTimeout() {\n    // 8000ms ~ 12000ms 随机超时，避免平票\n    this.electionTimeout = 8000 + ThreadLocalRandom.current().nextInt(4000);\n    log.info(\"重置 {} 节点选举时间，随机超时：{} ms\", nodeId, electionTimeout);\n    this.lastHeartbeatTime = System.currentTimeMillis();\n}\n</code></pre>\n<p>主要就是看becomeCandidate这个方法最后的向集群发送投票请求。</p>\n<pre><code class=\"language-java\">private void requestVotes() {\n    // 1. 初始化票数：自己的一票\n    AtomicInteger grantedVotes = new AtomicInteger(1);\n    long count = rpcPeers.stream().filter(peer -&gt; !peer.isSelf()).count(); // 不包含自己的结点数\n    int majority = (int) ((count + 1) / 2 + 1); // 总节点数(包含自己)的半数以上\n\n    // 2.构造投票消息\n    KvRaftProto.VoteRequest voteRequest = KvRaftProto.VoteRequest.newBuilder()\n        .setTerm(currentTerm.get())\n        .setCandidateId(nodeId)\n        .setLastLogIndex(logManager.getLastLogIndex())\n        .setLastLogTerm(logManager.getLastLogTerm())\n        .build();\n    // 3. 发送投票请求\n    // 构建一个对象，表示当前投票请求的状态\n    // String voteId = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n    // 这里为什么可以用term？因为 Raft 规定，一个节点在一个 term 内只能投一张票。\n    // 所以，只要 term 匹配，这个响应就一定是针对你当前发起的这一轮选举的。\n    GlobalVoteManager.setVoteState(currentTerm.get(), new VoteState(nodeId, currentTerm.get(), majority));\n\n    int countSend = 0;\n    for (RpcPeer peer : rpcPeers) {\n        if (!peer.isSelf()) { // 不是自身结点，就发送投票请求\n            // send方法就很简单了，请读者自行查看\n            boolean send = peer.send(KvRaftProto.RaftKvMessage.newBuilder()\n                                     .setType(KvRaftProto.RaftKvMessage.MessageType.VOTE_REQUEST)\n                                     .setVoteRequest(voteRequest)\n                                     .build());\n            if ( send ) countSend++;\n        }\n    }\n    log.info(\"发送投票请求：{}，已发送给了 {} 个结点..\", voteRequest, countSend);\n}\n</code></pre>\n<p>这样投票请求就发送出去了，此时结点是作为客户端发送给其他节点的，接下来的逻辑就是其他节点接收到voteRequest请求然后做逻辑处理，所以就要在server包下面去查看具体逻辑。</p>\n<pre><code class=\"language-java\">// 在kv-core的server包下面的KvBusinessHandler.java\n// 1.如果是投票请求\nif ( raftKvMessage.getType() == KvRaftProto.RaftKvMessage.MessageType.VOTE_REQUEST) {\n    log.info(\"receive vote request.........\");\n    KvRaftProto.VoteRequest voteRequest = raftKvMessage.getVoteRequest();\n    // 可以看到交给了node去处理\n    KvRaftProto.VoteResponse voteResponse = node.tackleVoteRequest(voteRequest);\n    ctx.writeAndFlush(KvRaftProto.RaftKvMessage.newBuilder()\n                      .setType(KvRaftProto.RaftKvMessage.MessageType.VOTE_RESPONSE)\n                      .setVoteResponse(voteResponse)\n                      .build());\n}\n\n// 又回到了RaftNode类了\npublic KvRaftProto.VoteResponse tackleVoteRequest(KvRaftProto.VoteRequest voteRequest) {\n    // 比较任期\n    if (voteRequest.getTerm() &lt; currentTerm.get()) {\n        log.info(\"{} 投票请求任期太小，拒绝投票\", nodeId);\n        return buildVoteResponse(false, currentTerm.get());\n    }\n    if ( votedFor != null &amp;&amp; !voteRequest.getCandidateId().equals(votedFor) ) {\n        log.info(\"{}已投给其他人，拒绝该投票请求\", nodeId);\n        return buildVoteResponse(false, currentTerm.get());\n    }\n    // 再比较日志情况\n    if ( voteRequest.getLastLogIndex() &gt;= logManager.getLastLogIndex() &amp;&amp;\n        voteRequest.getLastLogTerm() &gt;= logManager.getLastLogTerm() ) {\n        log.info(\"{} 投票请求ok，赞成投票\", nodeId);\n        currentTerm.set(voteRequest.getTerm()); // 更新自己的任期\n        votedFor = voteRequest.getCandidateId(); // 投票给该节点\n        return buildVoteResponse(true, voteRequest.getTerm());\n    }\n    log.info(\"{} 投票请求日志太旧，拒绝该投票请求\", nodeId);\n    return buildVoteResponse(false, currentTerm.get());\n}\n</code></pre>\n<p>其他节点收到了拉票请求，会返回response给candidate结点，candidate结点是作为Client发送的拉票请求，收到的响应肯定是在客户端的处理器handler，接下来的逻辑就要在rpc包下面的RpcClientHandler去查看了：</p>\n<pre><code class=\"language-java\">@Override\nprotected void channelRead0(ChannelHandlerContext ctx, KvRaftProto.RaftKvMessage msg) {\n    // 2.VOTE_RESPONSE 投票请求回来的响应【投票请求是结点作为客户端发出的，应该在客户端的handler处理响应】\n    if (msg.getType() == KvRaftProto.RaftKvMessage.MessageType.VOTE_RESPONSE) {\n        log.info(\"receive vote response.........\");\n        KvRaftProto.VoteResponse voteResponse = msg.getVoteResponse();\n        raftNode.tackleVoteResponse(voteResponse); // 又回到了RaftNode\n    }\n}\n\n// RaftNode.java\n// 投票结果处理,【投票请求是结点作为客户端发出的，要在客户端的handler处理响应】\npublic synchronized void tackleVoteResponse(KvRaftProto.VoteResponse voteResponse) {\n    long term = voteResponse.getTerm();\n    // 2. 发现更高任期，立即降级并更新\n    // 1. 任期检查：对方比我大，我立即认输\n    if (term &gt; currentTerm.get()) {\n        stepDown(term);\n        return;\n    }\n    // 2. 状态检查：如果我已经不是 Candidate 了（比如已经超时重选或收到心跳），忽略\n    if (state != NodeState.CANDIDATE) return;\n\n    // 3. 任期匹配检查：确保这是对“当前这一轮”选举的回复\n    // 如果收到的响应任期比当前小，说明是之前过期的选举回复，直接丢弃\n    if (term &lt; currentTerm.get()) {\n        return;\n    }\n\n    // 4. 从全局管理器获取当前选举的投票状态\n    VoteState voteState = GlobalVoteManager.getVoteState(term);\n    if (voteState == null) {\n        log.error(\"未找到任期 {} 的投票记录状态\", term);\n        return;\n    }\n\n    // 5. 如果对方投了赞成票\n    if (voteResponse.getVoteGranted()) {\n        // 增加票数（这里 AtomicInteger 在 VoteState 内部保证了线程安全，\n        // 但由于本方法加了 synchronized，其实双重保险）\n        int currentVotes = voteState.addVote();\n        int majority = voteState.getMajority();\n        log.info(\"赞成票，当前票数: {}/{}\", currentVotes, nodesConfig.getNodeList().size());\n\n        // 6. 检查是否达到多数派\n        if (currentVotes &gt;= majority) {\n            log.info(\"节点 {} 获得过半选票 ({})，准备晋升为 Leader\", nodeId, currentVotes);\n            becomeLeader();\n        }\n    } else {\n        log.info(\"拒绝了我的投票请求\");\n    }\n}\nprivate synchronized void becomeLeader() {\n    if (state != NodeState.CANDIDATE) return;\n    if (state == NodeState.LEADER) return;\n\n    this.state = NodeState.LEADER;\n    log.info(\"Node {} 赢得选举，即将成为 Leader, Term: {}\", nodeId, currentTerm.get());\n    // 1. 清理上一任期的残留状态\n    this.votedFor = null;\n\n    // 2. 立即发送第一波心跳，宣示主权 (防止其他节点又超时)\n    sendHeartbeats();\n\n    // 3. 启动定时心跳任务 (比如每 2 秒一次)\n    if (heartbeatTask != null) heartbeatTask.cancel(true);\n    heartbeatTask = scheduler.scheduleAtFixedRate(this::sendHeartbeats,\n                                                  0, 1000, TimeUnit.MILLISECONDS);\n    log.info(\"&lt;&lt;&lt;&lt;&lt; 节点 {} 正式成为 Term {} 的 Leader &gt;&gt;&gt;&gt;&gt;\", nodeId, currentTerm.get());\n}\n</code></pre>\n<h1 id=\"3启动测试选主\">3.启动测试选主</h1>\n<p>把配置好的三个节点启动一下看看结果</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194611564-1443963355.png\" /></p>\n<hr />\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194612379-843476723.png\" /></p>\n<hr />\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194612841-1185877353.png\" /></p>\n<p>从上图可以看出，端口9999成为了Leader结点，然后向其他节点发送心跳数据了。</p>\n<p>接下来就是完善一下日志分发那些逻辑了。</p>\n<h1 id=\"end-参考\">end. 参考</h1>\n<ol>\n<li><a href=\"http://thinkinjava.cn/2019/01/12/2019/2019-01-12-lu-raft-kv/#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%89%88-Raft-%E5%88%86%E5%B8%83%E5%BC%8F-KV-%E5%AD%98%E5%82%A8\" rel=\"noopener nofollow\" target=\"_blank\">http://thinkinjava.cn/2019/01/12/2019/2019-01-12-lu-raft-kv/#什么是-Java-版-Raft-分布式-KV-存储</a></li>\n<li><a href=\"https://github.com/stateIs0/lu-raft-kv\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/stateIs0/lu-raft-kv</a></li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 19:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jackjavacpp\">别来无恙✲</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "模型评估小册（1） ROC 曲线与 AUC",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19605705",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19605705\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 19:19\">\n    <span>模型评估小册（1） ROC 曲线与 AUC</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>一点前言：之前完成了吴恩达深度学习的相关内容，最近忙于毕设，更新可能没之前那么频繁。这个新开的分类关于<strong>模型评估的各种指标</strong>的详解，之前翻看书籍总是被一堆很官方化的概念和密密麻麻的符号搞的看不下去，因此，这次的中心思想是以尽可能<strong>通俗的语言、精简的篇幅</strong>来讲解这类概念并辅以实例。<br />\n不多废话，以下为正文。</p>\n<hr />\n<h1 id=\"1-检测问题中的两难情景\">1. 检测问题中的“两难情景”</h1>\n<p>假设我们在机场负责安检。任务很简单：<strong>把携带危险物品的人拦下来。</strong></p>\n<p>但现实远没有这么简单，如果我们把安检<strong>标准定得非常严格</strong>——一点可疑都不放过，那么确实可以拦下几乎所有危险人员。<br />\n但代价是，<strong>正常旅客也会被频繁拦下复检</strong>，队伍排到大厅外。</p>\n<p>而如果我们<strong>把标准放宽</strong>——只在非常明显的情况下才拦人，旅客通行效率会提高。<br />\n但显然，这就<strong>有更大可能漏掉真正的风险</strong>。</p>\n<p>这就是一个经典的两难：<strong>选择杀错还是放过</strong>？</p>\n<blockquote>\n<p><strong>抓得越多，错抓也越多。</strong><br />\n<strong>抓得越少，漏抓就越多。</strong></p>\n</blockquote>\n<p><img alt=\"f2bc31dc-fe19-439e-a7a0-4efb06659caf.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202602/3708248-20260211191745572-2075288255.png\" /></p>\n<p>目标检测问题本质上也是如此，在高光谱目标检测、雷达探测、异常检测等目标检测任务中，我们面对的不是“对或错”这么简单，而是<strong>在任务情景中，对“错报”和“漏报”的权衡选择</strong>：</p>\n<blockquote>\n<p><strong>我的模型，能检测出多少真实目标？但同时会误报多少背景？我的任务要求我更偏向哪边？在哪里二者较为均衡？</strong></p>\n</blockquote>\n<p>总之，在检测系统中，没有免费的午餐：提高检测率，往往要付出虚警率的代价。<br />\nROC 曲线描述的，正是这两者之间的关系。</p>\n<h1 id=\"2-rocreceiver-operating-characteristic\">2. ROC（Receiver Operating Characteristic）</h1>\n<p>ROC 的英文全称为 <strong>Receiver Operating Characteristic</strong> ，直译为受试者工作特征曲线，它来源于<strong>统计学中的检测理论</strong>，而最早的应用领域是<strong>雷达探测</strong>。</p>\n<p>不同于一些常见指标，<strong>ROC 刻画的是虚警概率和检测概率间的函数关系</strong>。<br />\n直接来看一个实例：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202602/3708248-20260211191746062-1023289789.png\" /><br />\n现在，假设一天有 <strong>100 个携带危险物品的旅客</strong>和 <strong>1000 个普通旅客</strong>：</p>\n<p>1.<strong>真阳性率（TPR / Pd）</strong>：系统能正确抓住真正危险旅客的比例，即“该抓的抓了多少”。<br />\n2.<strong>假阳性率（FPR / Fa）</strong>：系统把普通旅客误判为危险旅客的比例，即“不该抓的抓错了多少”。</p>\n<table>\n<thead>\n<tr>\n<th>普通旅客数量</th>\n<th>危险旅客数量</th>\n<th>通过 / 正常数量</th>\n<th>抓到数量</th>\n<th>指标及计算过程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>—</td>\n<td>100</td>\n<td>3 漏掉</td>\n<td>97  抓到</td>\n<td><strong>真阳性率 Pd = 97 / 100 = 0.97 (97%)</strong></td>\n</tr>\n<tr>\n<td>1000</td>\n<td>—</td>\n<td>800 正常通过</td>\n<td>200 误抓</td>\n<td><strong>假阳性率 Fa = 200 / 1000 = 0.2 (20%)</strong></td>\n</tr>\n</tbody>\n</table>\n<p>实际上二者的计算还是对四类基础统计量的应用。<br />\n这样，我们就得到了 ROC 曲线中的一个点：<span class=\"math inline\">\\((0.2,0.97)\\)</span> ，我们称之为<strong>Pd @ Fa 或 Pd / Fa</strong> ，它说明了<strong>在特定虚警率下能抓到多少目标</strong>，展开如下：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202602/3708248-20260211191743792-444019702.png\" /><br />\n到这里，就会发现： <strong>ROC 曲线中的一个点就是一种决策阈值下的模型表现。</strong><br />\n我们不断测试不同的阈值计算，最终就会得到 ROC 曲线，列举几种情况如下：</p>\n<table>\n<thead>\n<tr>\n<th>阈值 t</th>\n<th>判定规则</th>\n<th>危险旅客抓到情况 (Pd)</th>\n<th>普通旅客误抓情况 (Fa)</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0.8</td>\n<td>只有概率 ≥ 0.8 判为危险</td>\n<td>80 / 100 = 0.80</td>\n<td>50 / 1000 = 0.05</td>\n<td>严格判定，只抓最明显的危险旅客，虚警很少</td>\n</tr>\n<tr>\n<td>0.5</td>\n<td>概率 ≥ 0.5 判为危险</td>\n<td>95 / 100 = 0.95</td>\n<td>200 / 1000 = 0.20</td>\n<td>中等判定，抓到大部分危险旅客，虚警适中</td>\n</tr>\n<tr>\n<td>0.3</td>\n<td>概率 ≥ 0.3 判为危险</td>\n<td>99 / 100 = 0.99</td>\n<td>400 / 1000 = 0.40</td>\n<td>宽松判定，几乎抓到全部危险旅客，但虚警明显增加</td>\n</tr>\n<tr>\n<td>0.1</td>\n<td>概率 ≥ 0.1 判为危险</td>\n<td>100 / 100 = 1.00</td>\n<td>800 / 1000 = 0.80</td>\n<td>极度宽松，抓到全部危险旅客，但绝大部分普通旅客也被误抓</td>\n</tr>\n</tbody>\n</table>\n<p>观察下来，你会发现：<strong>误报率越高往往代表阈值越低。</strong><br />\n而到了这里，你可能会有一个问题：<strong>那在实际运行中，我总不能一个个阈值去试吧？要多少次才能拼出来完整曲线？</strong></p>\n<p>实际上，我们<strong>在真实运行中只需要运行一次模型就可以得到完整 ROC 曲线。</strong><br />\n<strong>用一句话概括其算法：存储模型对每个样本的输出概率并排序，从高到低依次确认为正类（抓捕）并计算 Pd @ Fa ，加入图像。</strong><br />\n来看个例子：</p>\n<table>\n<thead>\n<tr>\n<th>排名</th>\n<th>旅客 ID</th>\n<th>是否危险</th>\n<th>模型概率 p</th>\n<th>挨个抓</th>\n<th>累计 TP</th>\n<th>累计 FP</th>\n<th>Pd = TP / 3</th>\n<th>Fa = FP / 7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>A</td>\n<td>✅ 危险</td>\n<td>0.95</td>\n<td>抓</td>\n<td>1</td>\n<td>0</td>\n<td>0.33</td>\n<td>0</td>\n</tr>\n<tr>\n<td>2</td>\n<td>B</td>\n<td>❌ 普通</td>\n<td>0.90</td>\n<td>抓</td>\n<td>1</td>\n<td>1</td>\n<td>0.33</td>\n<td>0.14</td>\n</tr>\n<tr>\n<td>3</td>\n<td>C</td>\n<td>✅ 危险</td>\n<td>0.85</td>\n<td>抓</td>\n<td>2</td>\n<td>1</td>\n<td>0.67</td>\n<td>0.14</td>\n</tr>\n<tr>\n<td>4</td>\n<td>D</td>\n<td>❌ 普通</td>\n<td>0.70</td>\n<td>抓</td>\n<td>2</td>\n<td>2</td>\n<td>0.67</td>\n<td>0.29</td>\n</tr>\n<tr>\n<td>5</td>\n<td>E</td>\n<td>❌ 普通</td>\n<td>0.60</td>\n<td>抓</td>\n<td>2</td>\n<td>3</td>\n<td>0.67</td>\n<td>0.43</td>\n</tr>\n<tr>\n<td><strong>6</strong></td>\n<td><strong>F</strong></td>\n<td><strong>✅ 危险</strong></td>\n<td><strong>0.50</strong></td>\n<td><strong>抓</strong></td>\n<td><strong>3</strong></td>\n<td><strong>3</strong></td>\n<td><strong>1.00</strong></td>\n<td><strong>0.43</strong></td>\n</tr>\n<tr>\n<td>7</td>\n<td>G</td>\n<td>❌ 普通</td>\n<td>0.45</td>\n<td>抓</td>\n<td>3</td>\n<td>4</td>\n<td>1.00</td>\n<td>0.57</td>\n</tr>\n<tr>\n<td>8</td>\n<td>H</td>\n<td>❌ 普通</td>\n<td>0.30</td>\n<td>抓</td>\n<td>3</td>\n<td>5</td>\n<td>1.00</td>\n<td>0.71</td>\n</tr>\n<tr>\n<td>9</td>\n<td>I</td>\n<td>❌ 普通</td>\n<td>0.20</td>\n<td>抓</td>\n<td>3</td>\n<td>6</td>\n<td>1.00</td>\n<td>0.86</td>\n</tr>\n<tr>\n<td>10</td>\n<td>J</td>\n<td>❌ 普通</td>\n<td>0.10</td>\n<td>抓</td>\n<td>3</td>\n<td>7</td>\n<td>1.00</td>\n<td>1.00</td>\n</tr>\n</tbody>\n</table>\n<p>在这里，<strong>当把旅客F抓捕时，计算得到的 Pd @ Fa 较优，也就是说，其对应的模型概率 p=0.5 就是一个可能较优的决策阈值选择。</strong></p>\n<p>到这里 ROC 的内容就基本结束，但是你会发现：<strong>曲线里我光看不同阈值的情况了，那这个模型本身到底好不好？有多好？能不能给我一个明确的评估呢？</strong><br />\n这就是与 ROC 曲线相关联的内容：AUC 。</p>\n<h1 id=\"3-aucarea-under-curve\">3. AUC（Area Under Curve）</h1>\n<p>AUC 的全称是 Area Under Curve，直译就是ROC 曲线下面积。它用一个<strong>单一指标</strong>来衡量模型整体能力。<br />\n在得到 ROC 曲线后，AUC的计算非常简单：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202602/3708248-20260211191744270-1543306405.png\" /><br />\n显然，AUC面积越大，模型越能在低虚警率下实现高检测率，模型的检测效果就越好。<br />\n并且，我们不需要提前选定决策阈值，就可以知道模型整体的好坏。</p>\n<p>总结一句话：<strong>ROC 告诉我们在不同标准下模型表现如何，而 AUC 则给出一个整体评分，实现不用盯着每个阈值也能知道模型好不好，从而帮助相关任务的调优和部署。</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 19:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">13</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Codeforces Round 1078 (Div. 2) A,B,C,D,E,F1个人题解",
      "link": "https://www.cnblogs.com/CUC-MenG/p/19605002",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/CUC-MenG/p/19605002\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 16:26\">\n    <span>Codeforces Round 1078 (Div. 2) A,B,C,D,E,F1个人题解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"a-割草机\">A. <a href=\"https://codeforces.com/contest/2194/problem/A\" rel=\"noopener nofollow\" target=\"_blank\">割草机</a></h1>\n<ul>\n<li>\n<h1 id=\"数学\">数学</h1>\n</li>\n</ul>\n<p>每个测试时间限制：1秒<br />\n每个测试内存限制：256兆字节</p>\n<p>夏季别墅的出口由一道栅栏围成，栅栏由 <span class=\"math inline\">\\(n\\)</span> 块木板组成，每块木板宽 <span class=\"math inline\">\\(1\\)</span> 米。出口的左右两侧是其他地块的栅栏。为了建造浴室，需要移除栅栏中的一些木板（可能是全部或一块也不移除），同时地块上有一台自动割草机，其宽度为 <span class=\"math inline\">\\(w\\)</span> 米，且不能通过栅栏上的缺口离开地块。</p>\n<p>如果被移除的木板编号中，存在至少 <span class=\"math inline\">\\(w\\)</span> 块连续被移除的木板，割草机就能够离开地块。请确定可以从栅栏中移除的最大木板数量。</p>\n<h2 id=\"输入\">输入</h2>\n<p>每个测试包含多个测试用例。第一行包含测试用例的数量 <span class=\"math inline\">\\(t\\)</span>（<span class=\"math inline\">\\(1 \\le t \\le 10^4\\)</span>）。接下来是每个测试用例的描述。</p>\n<p>每个测试用例仅包含一行，其中有两个整数 <span class=\"math inline\">\\(n\\)</span> 和 <span class=\"math inline\">\\(w\\)</span>（<span class=\"math inline\">\\(1 \\le n \\le 10^9\\)</span>，<span class=\"math inline\">\\(1 \\le w \\le 10^9\\)</span>）——分别表示栅栏中的木板数量和割草机的宽度（以米为单位）。</p>\n<h2 id=\"输出\">输出</h2>\n<p>对于每个测试用例，输出一个数字——可以从栅栏中移除的最大木板数量。</p>\n<h2 id=\"思路\">思路</h2>\n<p>通过观察，可以计算出中间需要放置的栅栏有<span class=\"math inline\">\\(\\left\\lfloor  \\frac{n}{k}  \\right\\rfloor\\)</span>个，因此空出来的栅栏一共有<span class=\"math inline\">\\(n-\\left\\lfloor  \\frac{n}{k}  \\right\\rfloor\\)</span>个</p>\n<h2 id=\"代码\">代码</h2>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll \n#define rep(i,a,b) for(int i=(a);i&lt;=(b);i++)\n#define per(i,a,b) for(int i=(a);i&gt;=(b);i--)\n \nvoid solve() {\n    int n, k;cin &gt;&gt; n &gt;&gt; k;\n    cout &lt;&lt; n - n / k &lt;&lt; '\\n';\n}\n \nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;\n    while (t--)solve();\n}\n</code></pre>\n<h1 id=\"b离岸资金\">B.<a href=\"https://codeforces.com/contest/2194/problem/B\" rel=\"noopener nofollow\" target=\"_blank\">离岸资金</a></h1>\n<ul>\n<li>\n<h1 id=\"数学-1\">数学</h1>\n</li>\n</ul>\n<p>每个测试时间限制 1.5 秒<br />\n每个测试内存限制 256 MB<br />\n马克非常喜欢钱，并且他把大部分钱都存在银行里。他在 <span class=\"math inline\">\\(n\\)</span> 家不同的银行中存有资金。在第 <span class=\"math inline\">\\(i\\)</span> 家银行，他有 <span class=\"math inline\">\\(a_i\\)</span> 卢布。</p>\n<p>某天，马克决定将他所有的钱集中到一家银行，因此他需要将资金从一个银行账户转移到另一个账户。所有的银行间转账都按照相同的方式进行：他一次只能转账 <span class=\"math inline\">\\(x\\)</span> 卢布，并且考虑到所有费用，实际到账金额为 <span class=\"math inline\">\\(y\\)</span> 卢布（因为银行要盈利，所以有 <span class=\"math inline\">\\(y \\le x\\)</span>）。</p>\n<p>马克可能无法将所有的钱都转移到一家银行，但他希望找到最终任何一家银行中能得到的最大卢布数量。</p>\n<h2 id=\"输入-1\">输入</h2>\n<p>每个测试包含多个测试用例。第一行包含测试用例的数量 <span class=\"math inline\">\\(t\\)</span> <span class=\"math inline\">\\((1 \\le t \\le 10^4)\\)</span>。接下来是每个测试用例的描述。</p>\n<p>每个测试用例的第一行包含三个整数 <span class=\"math inline\">\\(n\\)</span>、<span class=\"math inline\">\\(x\\)</span> 和 <span class=\"math inline\">\\(y\\)</span> <span class=\"math inline\">\\((2 \\le n \\le 2 \\cdot 10^5, 1 \\le y \\le x \\le 10^9)\\)</span> —— 银行数量、转账金额和实际到账金额。</p>\n<p>每个测试用例的第二行包含 <span class=\"math inline\">\\(n\\)</span> 个整数 <span class=\"math inline\">\\(a_1, a_2, \\dots, a_n\\)</span> <span class=\"math inline\">\\((1 \\le a_i \\le 10^9)\\)</span> —— 每家银行初始的卢布金额。</p>\n<p>保证所有测试用例的 <span class=\"math inline\">\\(n\\)</span> 的总和不超过 <span class=\"math inline\">\\(2 \\cdot 10^5\\)</span>。</p>\n<h2 id=\"输出-1\">输出</h2>\n<p>对于每个测试用例，输出一个数字 —— 任何一家银行中能获得的最大卢布数量。</p>\n<h2 id=\"思路-1\">思路</h2>\n<p>对于一个<span class=\"math inline\">\\(a_{i}\\)</span>，如果想要把他分给其他银行，那么最好的情况是<span class=\"math inline\">\\(a_{i}\\%x==0\\)</span>，此时可以把<span class=\"math inline\">\\(a_{i}\\)</span>完全对答案分出<span class=\"math inline\">\\(\\frac{a_{i}}{x}\\times y\\)</span>的贡献，否则将会有<span class=\"math inline\">\\(r_{i}=a_{i}\\%x\\)</span>的剩余</p>\n<p>对于一个<span class=\"math inline\">\\(r_{i}\\neq 0\\)</span>，如果有别的份额分到了自己身上，可以记为<span class=\"math inline\">\\(r_{i}+t\\cdot y\\)</span>，当<span class=\"math inline\">\\((r_{i}+t\\cdot y)\\%x==0\\)</span>时，当前的<span class=\"math inline\">\\(r_{i}\\)</span>被完全消耗完毕</p>\n<p>然而，注意到就算使用其他的银行份额<span class=\"math inline\">\\(t\\cdot y\\)</span>来消耗剩余的<span class=\"math inline\">\\(r_{i}\\)</span>，最终能够贡献给答案的<span class=\"math inline\">\\(y\\)</span>的数量没有发生变化。比如说，<span class=\"math inline\">\\(a_{i}=t_{i}\\cdot x+r_{i}\\quad a_{j}=t_{j}\\cdot x\\)</span>，并且恰好有<span class=\"math inline\">\\((r_{i}+t_{j}\\cdot y)\\%x==0\\)</span>，无论是否将<span class=\"math inline\">\\(j\\)</span>转移到<span class=\"math inline\">\\(i\\)</span>上，这两个银行对答案的总贡献都为<span class=\"math inline\">\\((t_{i}+t_{j})\\cdot y\\)</span></p>\n<p>因此，最终的策略一定是：选定一个位置作为最终的答案，将除了这个位置以外的所有银行都分到这个位置上，那么选定位置<span class=\"math inline\">\\(i\\)</span>作为最终答案的算式为：</p>\n<p></p><div class=\"math display\">\\[a_{i}+\\left( \\sum_{j=1}^{n}t_{j}-t_{i} \\right)\\cdot y\n\\]</div><p></p><p>因此答案即为枚举所有<span class=\"math inline\">\\(i\\)</span>取最大值</p>\n<p></p><div class=\"math display\">\\[ans=\\max_{1\\leq i\\leq n}\\left\\{ a_{i}+\\left( \\sum_{j=1}^{n}t_{j}-t_{i} \\right)\\cdot y \\right\\}\n\\]</div><p></p><p>ps：一开始没发现这个规律，想了好久，还搞了快速幂和乘法逆元。。。</p>\n<h2 id=\"代码-1\">代码</h2>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll \n#define rep(i,a,b) for(int i=(a);i&lt;=(b);i++)\n#define per(i,a,b) for(int i=(a);i&gt;=(b);i--)\n \nstruct node {\n    int val, m, t;\n};\n \nvoid solve() {\n    int n, x, y;cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;\n    vector&lt;node&gt;a(n + 1);\n    int sumt = 0;\n    rep(i, 1, n) {\n        int val, m, t;\n        cin &gt;&gt; val;\n        m = val % x;\n        t = val / x;\n        a[i] = { val,m,t };\n        sumt += t;\n    }\n    int ans = 0;\n    rep(i, 1, n) {\n        ans = max(ans, (sumt - a[i].t) * y + a[i].val);\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n}\n \nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;\n    while (t--)solve();\n}\n</code></pre>\n<h1 id=\"c秘密信息\">C.<a href=\"https://codeforces.com/contest/2194/problem/C\" rel=\"noopener nofollow\" target=\"_blank\">秘密信息</a></h1>\n<ul>\n<li>\n<h1 id=\"字符串-模拟\">字符串 #模拟</h1>\n</li>\n</ul>\n<p>单点时间限制 2 秒<br />\n内存限制 256 MB</p>\n<p>天才特工 Bob 截获了一条加密信息。他认为其中包含秘密信息，并正在积极破解。</p>\n<p>落入特工手中的纸条由 k 条组成，每条长度为 n，包含严格的小写拉丁字母。凭借在破译此类文件方面的丰富经验，Bob 猜测他感兴趣的信息（即纸条的解密内容）也是一个长度为 n 的字符串，并且该消息的第 i 个字母对应于其中某条纸条的第 i 个字母。</p>\n<p>在 Bob 看来，字符串 s 的信息度定义为最小的正整数 d，使得存在一个长度为 d 的字符串 t，并且 s 可以由 t 重复若干次构成。例如，字符串 \"aaaa\" 的信息度为 1，字符串 \"abab\" 的信息度为 2，字符串 \"abcd\" 的信息度为 4。</p>\n<p>Bob 假设纸条的作者为确保信息传输的可靠性，在消息中重复了数据多次。因此，他认为更合理的解密结果应具有尽可能小的信息度。</p>\n<p>请帮助这位特工：找到能够解密该纸条且具有最小可能信息度的消息。</p>\n<h2 id=\"输入格式\">输入格式</h2>\n<p>每个测试包含多个测试用例。第一行包含测试用例的数量 t <span class=\"math inline\">\\((1 \\le t \\le 10^4)\\)</span>。接下来是每个测试用例的描述。</p>\n<p>每个测试用例的第一行包含数字 n 和 k <span class=\"math inline\">\\((2 \\le n, k \\le 50000, 4 \\le n \\cdot k \\le 10^5)\\)</span> —— 纸条的长度和纸条的数量。</p>\n<p>在每个测试用例接下来的 k 行中，每行有一个由 n 个小写拉丁字母组成的序列 —— 表示下一条纸条。</p>\n<p>保证所有测试用例的 <span class=\"math inline\">\\(n \\cdot k\\)</span> 总和不超过 <span class=\"math inline\">\\(10^5\\)</span>。</p>\n<h2 id=\"输出格式\">输出格式</h2>\n<p>对于每个测试用例，输出一个长度为 n 的字符串 —— 具有最小可能信息度的纸条解密内容。如果有多个合适的答案，输出其中任意一个即可。</p>\n<h2 id=\"思路-2\">思路</h2>\n<p>首先有一个很明显的观察：这个答案的长度<span class=\"math inline\">\\(len\\)</span>选择特别少，因为必须要满足<span class=\"math inline\">\\(n\\%len==0\\)</span>，所以我们可以在<span class=\"math inline\">\\(\\sqrt{ n }\\)</span>的复杂度里升序枚举<span class=\"math inline\">\\(n\\)</span>的因数，也就是所有的长度</p>\n<p>确定了一个长度之后，就判断是否可以找到合法的答案。如果一个串是合法的答案，那么<span class=\"math inline\">\\(s_{i}==s_{i+len}==s_{i+2len}==\\dots==s_{i+t\\cdot len}\\)</span>，其中<span class=\"math inline\">\\(1\\leq i\\leq len,0\\leq t&lt; \\frac{n}{len}\\)</span></p>\n<p>因此，如果一个字母可以填入位置<span class=\"math inline\">\\(i\\)</span>，那么在所有的<span class=\"math inline\">\\(i+t\\cdot len\\)</span>上都必须要可以填入这个字母</p>\n<p>因此开一个二维数组，<span class=\"math inline\">\\(a[j][c]\\)</span>代表第<span class=\"math inline\">\\(j\\)</span>列上是否存在字母<span class=\"math inline\">\\(c\\)</span><br />\n枚举<span class=\"math inline\">\\(len\\)</span>个<span class=\"math inline\">\\(i\\)</span>，随后查找所有的<span class=\"math inline\">\\(i+t\\cdot len\\)</span>判断即可</p>\n<p>复杂度为<span class=\"math inline\">\\(O(n\\cdot k+n\\sqrt{ n })\\)</span></p>\n<h2 id=\"代码-2\">代码</h2>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll \n#define rep(i,a,b) for(int i=(a);i&lt;=(b);i++)\n#define per(i,a,b) for(int i=(a);i&gt;=(b);i--)\n \nvoid solve() {\n    int n, k;cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;vector&lt;int&gt;&gt;a(n + 1, vector&lt;int&gt;(27));\n    rep(i, 1, k) {\n        string s;cin &gt;&gt; s;\n        rep(j, 0, n - 1) {\n            a[j + 1][s[j] - 'a']++;\n        }\n    }\n    string res;\n    for (int len = 1;len &lt;= n;len++) {\n        if (n % len == 0) {\n            res.clear();\n            rep(i, 1, len) {\n                char ans = '#';\n                rep(c, 0, 25) {\n                    bool find = 1;\n                    rep(j, 0, n / len - 1) {\n                        int pos = i + j * len;\n                        if (!a[pos][c]) {\n                            find = 0;break;\n                        }\n                    }\n                    if (find) {\n                        ans = 'a' + c;break;\n                    }\n                }\n                if (ans != '#')res += ans;\n                else break;\n            }\n            if (res.size() == len) {\n                rep(i, 1, n / len)cout &lt;&lt; res;cout &lt;&lt; '\\n';\n                return;\n            }\n        }\n    }\n}\n \nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;\n    while (t--)solve();\n}\n</code></pre>\n<h1 id=\"d-表格切割\">D. <a href=\"https://codeforces.com/contest/2194/problem/D\" rel=\"noopener nofollow\" target=\"_blank\">表格切割</a></h1>\n<ul>\n<li>\n<h1 id=\"dfs-数学\">dfs #数学</h1>\n</li>\n</ul>\n<p><strong>单点测试时间限制</strong> 2 秒<br />\n<strong>单点测试内存限制</strong> 256 兆字节</p>\n<p>给定一个大小为 <span class=\"math inline\">\\(n \\times m\\)</span> 的表格，其中每个单元格包含 <span class=\"math inline\">\\(0\\)</span> 或 <span class=\"math inline\">\\(1\\)</span>。任务是通过一条从左上角到右下角的切割线将其分成两部分。切割线只能向右或向下延伸。</p>\n<p>设 <span class=\"math inline\">\\(a\\)</span> 为切割后表格一部分中 <span class=\"math inline\">\\(1\\)</span> 的数量，<span class=\"math inline\">\\(b\\)</span> 为另一部分中 <span class=\"math inline\">\\(1\\)</span> 的数量。目标是最大化 <span class=\"math inline\">\\(a \\cdot b\\)</span> 的值。</p>\n<h2 id=\"输入-2\">输入</h2>\n<p>每个测试包含多个测试用例。第一行包含测试用例的数量 <span class=\"math inline\">\\(t\\)</span> <span class=\"math inline\">\\((1 \\le t \\le 10^4)\\)</span>。接下来是测试用例的描述。</p>\n<p>每个测试用例的第一行包含两个整数 <span class=\"math inline\">\\(n\\)</span> 和 <span class=\"math inline\">\\(m\\)</span> <span class=\"math inline\">\\((1 \\le n, m \\le 3 \\cdot 10^5, 2 \\le n \\cdot m \\le 3 \\cdot 10^5)\\)</span> —— 分别是表格的行数和列数。</p>\n<p>接下来的 <span class=\"math inline\">\\(n\\)</span> 行，每行包含 <span class=\"math inline\">\\(m\\)</span> 个整数，其中第 <span class=\"math inline\">\\(i\\)</span> 行的第 <span class=\"math inline\">\\(j\\)</span> 个数对应值 <span class=\"math inline\">\\(a_{i,j}\\)</span> <span class=\"math inline\">\\((0 \\le a_{i,j} \\le 1)\\)</span>。</p>\n<p>保证所有测试用例的 <span class=\"math inline\">\\(n \\cdot m\\)</span> 之和不超过 <span class=\"math inline\">\\(3 \\cdot 10^5\\)</span>。</p>\n<h2 id=\"输出-2\">输出</h2>\n<p>对于每个测试用例，在输出数据的第一行输出一个数字 —— 乘积的最大值。</p>\n<p>在第二行，输出一个由 <span class=\"math inline\">\\(n\\)</span> 个字符 'D' 和 <span class=\"math inline\">\\(m\\)</span> 个字符 'R' 组成的字符串，表示下一步切割的方向，其中 'D' 表示向下切割，'R' 表示向右切割。!<img alt=\"[[bf5a95bd1bfc341b05232d999b0048817fc8b08f.webp]]\" src=\"https://i-blog.csdnimg.cn/direct/8572c275568a4aba8cc862471babf6fa.png\" /></p>\n<h2 id=\"思路-3\">思路</h2>\n<p>本题实际上就是一个很典型的基本不等式问题：<br />\n给定<span class=\"math inline\">\\(x+y=k\\)</span>，求<span class=\"math inline\">\\(x\\cdot y\\)</span>的最大值</p>\n<p></p><div class=\"math display\">\\[\\begin{align}\n&amp;已知x+y\\geq 2\\sqrt{ xy }\\\\ \\\\\n&amp;\\Leftrightarrow  \\frac{(x+y)^{2}}{4}\\geq xy\\\\ \\\\\n&amp;\\therefore xy\\leq \\frac{k}{4},当且仅当x=y取等\n\\end{align}\n\\]</div><p></p><p>也就是说，直接取<span class=\"math inline\">\\(x=\\left\\lfloor  \\frac{k}{2}  \\right\\rfloor,y=\\left\\lceil  \\frac{k}{2}  \\right\\rceil\\)</span>即可</p>\n<p>那么接下来就是分割路线<br />\n我们采用<span class=\"math inline\">\\(1-based\\)</span>下标，后面有妙用<br />\n实际上我们从右上向左下遍历所有的斜线，一边遍历一边记录1的个数，当1的个数恰好等于<span class=\"math inline\">\\(x\\)</span>的时候停止，所有走过的点都打上标记<span class=\"math inline\">\\(vis[i][j]=1\\)</span><br />\n接下来我们需要将<span class=\"math inline\">\\(vis[0][j]\\)</span>以及<span class=\"math inline\">\\(vis[i][m+1]\\)</span>全部标为1<br />\n将<span class=\"math inline\">\\((0,1)\\)</span>设为起点，<span class=\"math inline\">\\((n,m+1)\\)</span>设为终点进行dfs，只能向右或向下，<span class=\"math inline\">\\(vis[i][j]=0\\)</span>视为障碍物，即可得到切分的序列</p>\n<h2 id=\"代码-3\">代码</h2>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll \n#define rep(i,a,b) for(int i=(a);i&lt;=(b);i++)\n#define per(i,a,b) for(int i=(a);i&gt;=(b);i--)\n \nstruct node {\n    int x, y;\n    char c;\n};\nvector&lt;int&gt;dx = { 1,0 };\nvector&lt;int&gt;dy = { 0,1 };\nvector&lt;char&gt;c = { 'D','R' };\nvector&lt;vector&lt;bool&gt;&gt;vis;\nint n, m;\nbool dfs(int x, int y) {\n    if (x == n &amp;&amp; y == m + 1)return 1;\n    rep(i, 0, 1) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (nx &gt; n || ny &gt; m + 1 || vis[nx][ny] == 0)continue;\n        vis[nx][ny] = 1;\n        cout &lt;&lt; c[i];\n        if (dfs(nx, ny))return 1;\n    }\n    return 0;\n}\n \nvoid solve() {\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;int&gt;&gt;a(n + 1, vector&lt;int&gt;(m + 1));\n    int sum = 0;\n    rep(i, 1, n) {\n        rep(j, 1, m) {\n            cin &gt;&gt; a[i][j];\n            if (a[i][j])sum++;\n        }\n    }\n    int x = sum / 2, y = sum - x;\n    cout &lt;&lt; x * y &lt;&lt; '\\n';\n    int cnt = 0;\n    vis.assign(n + 1, vector&lt;bool&gt;(m + 1, 0));\n    per(d, m - 1, 1 - n) {\n        rep(j, max(1ll, d + 1), m) {\n            int i = j - d;\n            if (i &gt; n)break;\n            vis[i][j] = 1;\n            if (a[i][j])cnt++;\n            if (cnt == x) break;\n        }\n        if (cnt == x)break;\n    }\n    rep(j, 1, m)vis[0][j] = 1;\n    rep(i, 0, n)vis[i][m + 1] = 1;\n    dfs(0, 1);\n    cout &lt;&lt; '\\n';\n}\n \nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;\n    while (t--)solve();\n}\n</code></pre>\n<h1 id=\"e-乌龟反击\">E. <a href=\"https://codeforces.com/contest/2194/problem/E\" rel=\"noopener nofollow\" target=\"_blank\">乌龟反击</a></h1>\n<ul>\n<li>\n<h1 id=\"dp-前缀和-后缀和-枚举\">dp #前缀和 #后缀和 #枚举</h1>\n</li>\n</ul>\n<p><strong>单点测试时间限制</strong> 2 秒<br />\n<strong>单点测试内存限制</strong> 512 兆字节</p>\n<p>在一次艰苦的训练后，米开朗基罗和拉斐尔决定点披萨。为庆祝节日，披萨店准备了 <span class=\"math inline\">\\(n\\)</span> 行 <span class=\"math inline\">\\(m\\)</span> 列的矩形披萨。每一块切片都有其独特的配方和风味。</p>\n<p>米开朗基罗首先打开了盒子，并粗略估计了享用每一块切片的愉悦度：位于第 <span class=\"math inline\">\\(i\\)</span> 行、第 <span class=\"math inline\">\\(j\\)</span> 列的切片带来的愉悦度等于 <span class=\"math inline\">\\(a_{i,j}\\)</span>。保证至少有一块切片是米开朗基罗喜欢的，也就是说在 <span class=\"math inline\">\\(a_{i,j}\\)</span> 中至少有一个非负数。</p>\n<p>两只乌龟约定，由米开朗基罗先吃。根据古老的传统，他必须选择一条从左上角 <span class=\"math inline\">\\((1,1)\\)</span> 到右下角 <span class=\"math inline\">\\((n,m)\\)</span> 的路径，并吃掉路径上的所有切片。在每一步，他可以向右或向下移动到相邻的切片。</p>\n<p>米开朗基罗的目标是最大化他所吃切片的愉悦度总和。</p>\n<p>然而，拉斐尔决定使用酱料。在米开朗基罗选择路径之前，拉斐尔决定恰好选择一块披萨切片，并涂上他的招牌酱料。但由于这种酱料的特性，该切片的愉悦度会变为相反数：如果原来是 <span class=\"math inline\">\\(a_{i,j}\\)</span>，涂上酱料后变为 <span class=\"math inline\">\\(-a_{i,j}\\)</span>。</p>\n<p>在这之后，知道了拉斐尔的选择，米开朗基罗将为自己选择最优的路径，并吃掉路径上的所有切片。</p>\n<p>拉斐尔很好奇，米开朗基罗最终可能获得的最小愉悦度是多少。帮助他计算这个数值。</p>\n<h2 id=\"输入-3\">输入</h2>\n<p>每个测试包含多个测试用例。第一行包含测试用例的数量 <span class=\"math inline\">\\(t\\)</span> <span class=\"math inline\">\\((1 \\le t \\le 10^4)\\)</span>。接下来是测试用例的描述。</p>\n<p>每个测试用例的第一行给出两个整数 <span class=\"math inline\">\\(n, m\\)</span> <span class=\"math inline\">\\((1 \\le n,m \\le 10^6, 1 \\le n \\cdot m \\le 10^6)\\)</span> — 分别表示表格的行数和列数。</p>\n<p>每个测试用例接下来的 <span class=\"math inline\">\\(n\\)</span> 行中，每行提供 <span class=\"math inline\">\\(m\\)</span> 个以空格分隔的整数。其中第 <span class=\"math inline\">\\(i\\)</span> 行的第 <span class=\"math inline\">\\(j\\)</span> 个数对应值 <span class=\"math inline\">\\(a_{i,j}\\)</span> <span class=\"math inline\">\\((-10^9 \\le a_{i,j} \\le 10^9)\\)</span>。保证在 <span class=\"math inline\">\\(a_{i,j}\\)</span> 中至少有一个非负值。</p>\n<p>保证所有测试用例的 <span class=\"math inline\">\\(n \\cdot m\\)</span> 之和不超过 <span class=\"math inline\">\\(10^6\\)</span>。</p>\n<h2 id=\"输出-3\">输出</h2>\n<p>对于每个测试用例，输出一个整数 — 拉斐尔能够保证的、米开朗基罗可以获得的最小愉悦度。</p>\n<h2 id=\"思路-4\">思路</h2>\n<p>如果没有额外的操作，那么本题就是一个标准线性dp求最大路径点权和问题：</p>\n<p></p><div class=\"math display\">\\[dp[i][j]=max\\{ dp[i-1][j],dp[i][j-1] \\}+w[i][j]\n\\]</div><p></p><p>但是由于我们可以选择一个方块进行权值上的取反，并且要求所有取反方案计算出的最大点权和中的最小值，所以不能直接通过状态来转移</p>\n<p>有一个经典的枚举思维：<br />\n枚举每一个变化点，预处理变化点的前缀以及后缀，这样就可以<span class=\"math inline\">\\(O(1)\\)</span>计算得到每一次枚举变化点的答案，再取最小值</p>\n<p>设<span class=\"math inline\">\\(pre[i][j]\\)</span>为以<span class=\"math inline\">\\((1,1)\\)</span>作为起点，走到<span class=\"math inline\">\\((i,j)\\)</span>的最大点权和：</p>\n<p></p><div class=\"math display\">\\[pre[i][j]=max\\{ pre[i-1][j],pre[i][j-1] \\}+w[i][j]\n\\]</div><p></p><p>设<span class=\"math inline\">\\(suf[i][j]\\)</span>为以<span class=\"math inline\">\\((n,m)\\)</span>作为起点，反向走到<span class=\"math inline\">\\((i,j)\\)</span>的最大点权和：</p>\n<p></p><div class=\"math display\">\\[suf[i][j]=max\\{ suf[i+1][j],suf[i][j+1] \\}+w[i][j]\n\\]</div><p></p><p>设<span class=\"math inline\">\\(dis[i][j]\\)</span>为以<span class=\"math inline\">\\((1,1)\\)</span>作为起点，<span class=\"math inline\">\\((n,m)\\)</span>作为终点，途径<span class=\"math inline\">\\((i,j)\\)</span>的最大路径点权和：</p>\n<p></p><div class=\"math display\">\\[dis[i][j]=max\\{ pre[i-1][j],pre[i][j-1] \\}+max\\{ suf[i+1][j],suf[i][j+1] \\}+w[i][j]\n\\]</div><p></p><p>接下来考虑枚举每一个点作为变化点的答案计算方式：</p>\n<p>假设翻转<span class=\"math inline\">\\((i,j)\\)</span>的位置的权值，那么也就只有两种决策方式：</p>\n<ul>\n<li>继续走<span class=\"math inline\">\\((i,j)\\)</span>的位置，答案变为<span class=\"math inline\">\\(dis[i][j]-2w[i][j]\\)</span></li>\n<li>不走<span class=\"math inline\">\\((i,j)\\)</span>的位置，从<span class=\"math inline\">\\(\\{ (x,y)|x&lt;i,y&gt;j \\}\\)</span>或者<span class=\"math inline\">\\(\\{ (x,y)|x&gt;i,y&lt;j \\}\\)</span>两个区域中选取<span class=\"math inline\">\\(dis[x][y]\\)</span>的最大值，这样可以保证一定不经过<span class=\"math inline\">\\((i,j)\\)</span></li>\n</ul>\n<p>为了快速求出右上以及左下矩形区域的最大值，预处理两个最大值数组：</p>\n<ul>\n<li><span class=\"math inline\">\\(RU[i][j]\\)</span>表示<span class=\"math inline\">\\((i,j)\\)</span>右上区域的<span class=\"math inline\">\\(dis\\)</span>最大值</li>\n<li><span class=\"math inline\">\\(LD[i][j]\\)</span>表示<span class=\"math inline\">\\((i,j)\\)</span>的左下区域的<span class=\"math inline\">\\(dis\\)</span>最大值</li>\n</ul>\n<p>预处理完后就可以枚举变化点<span class=\"math inline\">\\(O(1)\\)</span>进行决策计算了</p>\n<h2 id=\"代码-4\">代码</h2>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll \n#define rep(i,a,b) for(int i=(a);i&lt;=(b);i++)\n#define per(i,a,b) for(int i=(a);i&gt;=(b);i--)\n \nconst int inf = 1e18;\n \nvoid solve() {\n    int n, m;cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;int&gt;&gt;a(n + 1, vector&lt;int&gt;(m + 1));\n    rep(i, 1, n) {\n        rep(j, 1, m)cin &gt;&gt; a[i][j];\n    }\n    vector&lt;vector&lt;int&gt;&gt;pre(n + 1, vector&lt;int&gt;(m + 1, -inf));\n    pre[1][1] = a[1][1];\n    rep(i, 1, n) {\n        rep(j, 1, m) {\n            if (i - 1 &gt; 0)pre[i][j] = max(pre[i][j], pre[i - 1][j] + a[i][j]);\n            if (j - 1 &gt; 0)pre[i][j] = max(pre[i][j], pre[i][j - 1] + a[i][j]);\n        }\n    }\n    vector&lt;vector&lt;int&gt;&gt;suf(n + 1, vector&lt;int&gt;(m + 1, -inf));\n    suf[n][m] = a[n][m];\n    per(i, n, 1) {\n        per(j, m, 1) {\n            if (i + 1 &lt;= n)suf[i][j] = max(suf[i][j], suf[i + 1][j] + a[i][j]);\n            if (j + 1 &lt;= m)suf[i][j] = max(suf[i][j], suf[i][j + 1] + a[i][j]);\n        }\n    }\n    vector&lt;vector&lt;int&gt;&gt;dis(n + 1, vector&lt;int&gt;(m + 1));\n    rep(i, 1, n) {\n        rep(j, 1, m) {\n            int p = -inf, s = -inf;\n            if (i - 1 &gt;= 1)p = max(p, pre[i - 1][j]);\n            if (j - 1 &gt;= 1)p = max(p, pre[i][j - 1]);\n            if (i + 1 &lt;= n)s = max(s, suf[i + 1][j]);\n            if (j + 1 &lt;= m)s = max(s, suf[i][j + 1]);\n            dis[i][j] = a[i][j];\n            if (s != -inf)dis[i][j] += s;\n            if (p != -inf)dis[i][j] += p;\n        }\n    }\n    vector&lt;vector&lt;int&gt;&gt;RU(n + 5, vector&lt;int&gt;(m + 5, -inf));\n    vector&lt;vector&lt;int&gt;&gt;LD(n + 5, vector&lt;int&gt;(m + 5, -inf));\n    per(i, n, 1) {\n        rep(j, 1, m) {\n            LD[i][j] = dis[i][j];\n            if (i + 1 &lt;= n)LD[i][j] = max(LD[i][j], LD[i + 1][j]);\n            if (j - 1 &gt;= 1)LD[i][j] = max(LD[i][j], LD[i][j - 1]);\n        }\n    }\n    rep(i, 1, n) {\n        per(j, m, 1) {\n            RU[i][j] = dis[i][j];\n            if (i - 1 &gt;= 1)RU[i][j] = max(RU[i][j], RU[i - 1][j]);\n            if (j + 1 &lt;= m)RU[i][j] = max(RU[i][j], RU[i][j + 1]);\n        }\n    }\n    int ans = inf;\n    rep(i, 1, n) {\n        rep(j, 1, m) {\n            int res = dis[i][j] - 2 * a[i][j];\n            res = max(res, max(RU[i - 1][j + 1], LD[i + 1][j - 1]));\n            ans = min(ans, res);\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n}\n \nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;\n    while (t--)solve();\n}\n</code></pre>\n<h1 id=\"f1-又是树简单版本\">F1. <a href=\"https://codeforces.com/contest/2194/problem/F1\" rel=\"noopener nofollow\" target=\"_blank\">又是树...（简单版本）</a></h1>\n<ul>\n<li>\n<h1 id=\"dp-树上dp-状态压缩-位运算\">dp #树上dp #状态压缩 #位运算</h1>\n</li>\n</ul>\n<p>时间限制每次测试1秒<br />\n内存限制每次测试1024 MB</p>\n<p>这是问题的简单版本。不同版本之间的区别在于，在这个版本中，<span class=\"math inline\">\\(k \\leq 4\\)</span>。只有在你解决了此问题的所有版本的情况下才能进行黑客攻击。</p>\n<p>给定一棵包含 <span class=\"math inline\">\\(n\\)</span> 个顶点的树。每个顶点上写有一个非负整数 <span class=\"math inline\">\\(a_v\\)</span>。同时给你 <span class=\"math inline\">\\(k\\)</span> 个不同的非负整数 <span class=\"math inline\">\\(b_1, \\ldots, b_k\\)</span>。</p>\n<p>如果一个边的集合是美丽的，当从树中移除这些边后，树会分裂成若干个连通分量，其中每个分量内所有 <span class=\"math inline\">\\(a_v\\)</span> 值的按位异或（bitwise XOR）属于集合 <span class=\"math inline\">\\(b\\)</span>。</p>\n<p>你需要计算美丽的边集合的数量，结果对 <span class=\"math inline\">\\(10^9+7\\)</span> 取模。</p>\n<h2 id=\"输入-4\">输入</h2>\n<p>每个测试包含多个测试用例。第一行包含测试用例的数量 <span class=\"math inline\">\\(t\\)</span>（<span class=\"math inline\">\\(1 \\leq t \\leq 500\\)</span>）。随后是每个测试用例的描述。</p>\n<p>每个测试数据的第一行包含两个整数 <span class=\"math inline\">\\(n\\)</span> 和 <span class=\"math inline\">\\(k\\)</span>（<span class=\"math inline\">\\(2 \\leq n \\leq 10^5\\)</span>，<span class=\"math inline\">\\(1 \\leq k \\leq 4\\)</span>）——树中顶点的数量和集合 <span class=\"math inline\">\\(b\\)</span> 的大小。</p>\n<p>接下来的 <span class=\"math inline\">\\(n-1\\)</span> 行描述树的边。第 <span class=\"math inline\">\\(i\\)</span> 行包含两个整数 <span class=\"math inline\">\\(v_i\\)</span> 和 <span class=\"math inline\">\\(u_i\\)</span>（<span class=\"math inline\">\\(1 \\leq v_i, u_i \\leq n\\)</span>）——第 <span class=\"math inline\">\\(i\\)</span> 条边连接的两个顶点编号。</p>\n<p>接下来一行包含 <span class=\"math inline\">\\(n\\)</span> 个整数 <span class=\"math inline\">\\(a_1, a_2, \\ldots, a_n\\)</span>（<span class=\"math inline\">\\(0 \\leq a_i &lt; 2^{30}\\)</span>）——写在顶点上的值。</p>\n<p>随后一行包含 <span class=\"math inline\">\\(k\\)</span> 个不同的整数 <span class=\"math inline\">\\(b_1, b_2, \\ldots, b_k\\)</span>（<span class=\"math inline\">\\(0 \\leq b_i &lt; 2^{30}\\)</span>）——集合 <span class=\"math inline\">\\(b\\)</span> 的元素。</p>\n<p>保证所有测试数据的 <span class=\"math inline\">\\(n\\)</span> 总和不超过 <span class=\"math inline\">\\(10^5\\)</span>。</p>\n<h2 id=\"输出-4\">输出</h2>\n<p>对于每个测试数据，输出一个整数——问题的答案。<br />\n<img alt=\"![[2a2092f4086e1a411ce476deee506c62e3dec616.webp]]\" src=\"https://i-blog.csdnimg.cn/direct/5fb94e47c9b948bfab1978b1691f845c.png\" /></p>\n<h2 id=\"思路-5\">思路</h2>\n<p>首先需要了解关于异或空间的数学性质：<br />\n对于<span class=\"math inline\">\\(s_{b}=\\{ b_{1},b_{2},\\dots,b_{k} \\}\\)</span>，其中任选任意数量的元素进行异或，将所得的所有可能放入另一个集合<span class=\"math inline\">\\(B\\)</span>，那么另一个集合的大小为<span class=\"math inline\">\\(|B|=O(2^{k})\\)</span><br />\n如果<span class=\"math inline\">\\(x\\oplus y\\in s_{b}\\)</span>那么必然要有<span class=\"math inline\">\\(x\\in B\\)</span>且<span class=\"math inline\">\\(y\\in B\\)</span></p>\n<p>对于简单版，<span class=\"math inline\">\\(k\\leq{4}\\)</span>，<span class=\"math inline\">\\(|B|\\leq 16\\)</span>，也就是说，我们dp转移可以暴力枚举这<span class=\"math inline\">\\(16\\)</span>个数</p>\n<p>因此，首先我们先通过二进制枚举将这个<span class=\"math inline\">\\(B\\)</span>集合构造出来</p>\n<p>接下来进行树上dp：</p>\n<p>状态设计：</p>\n<ul>\n<li><span class=\"math inline\">\\(dp[u][x]\\)</span>表示在以<span class=\"math inline\">\\(u\\)</span>为根的子树中，已经切掉了一些边，所有切出来的分量的异或和为<span class=\"math inline\">\\(x\\)</span>的方案数。特别注意，包含点<span class=\"math inline\">\\(u\\)</span>的连通块没有算进<span class=\"math inline\">\\(x\\)</span>中，因为还没有决策完是否需要断边</li>\n<li>设<span class=\"math inline\">\\(S[u]\\)</span>为<span class=\"math inline\">\\(u\\)</span>的子树内的异或和，则<span class=\"math inline\">\\(u\\)</span>所在连通块的异或和为<span class=\"math inline\">\\(S[u]\\oplus x\\)</span>，这便是为什么要将第二维设计成已经切掉的连通块的异或和</li>\n</ul>\n<p>初始状态：</p>\n<ul>\n<li><span class=\"math inline\">\\(dp[u][0]=1\\)</span>，表示没有边可以切，也就意味着被切掉的异或和为0，这样的方案有一个</li>\n<li><span class=\"math inline\">\\(dp[u][x]=0\\)</span>其余的置0</li>\n</ul>\n<p>状态转移：</p>\n<ul>\n<li>设当前<span class=\"math inline\">\\(u\\)</span>已有的状态为<span class=\"math inline\">\\(dp[u][x]\\)</span>，儿子<span class=\"math inline\">\\(son\\)</span>的状态为<span class=\"math inline\">\\(dp[son][y]\\)</span>，枚举时保证<span class=\"math inline\">\\(x\\in B,y\\in B\\)</span></li>\n<li>不切边<span class=\"math inline\">\\(u\\to son\\)</span>：\n<ul>\n<li><span class=\"math inline\">\\(son\\)</span>所在的连通块将与<span class=\"math inline\">\\(u\\)</span>的连在一起</li>\n<li><span class=\"math inline\">\\(son\\)</span>子树内被切出来的连通块全部并入<span class=\"math inline\">\\(u\\)</span>切出来的连通块中</li>\n<li><span class=\"math inline\">\\(ndp[x\\oplus y]+=dp[u][x]\\cdot dp[son][y]\\cdot[x\\oplus y\\in B]\\)</span></li>\n</ul>\n</li>\n<li>切掉边<span class=\"math inline\">\\(u\\to son\\)</span>\n<ul>\n<li>如果这条边能够切掉，则必须满足<span class=\"math inline\">\\(son\\)</span>所在的连通块的异或和必须在集合<span class=\"math inline\">\\(s_{b}\\)</span>中，即<span class=\"math inline\">\\(S[son]\\oplus y\\in s_{b}\\)</span></li>\n<li>此时<span class=\"math inline\">\\(u\\)</span>子树内被切掉的连通块的异或和变为了<span class=\"math inline\">\\(x\\oplus y\\oplus(S[u]\\oplus y)=x\\oplus S[u]\\)</span></li>\n<li><span class=\"math inline\">\\(ndp[x\\oplus S[son]]+=dp[u][x]\\cdot dp[son][y]\\cdot[S[son]\\oplus y\\in s_{b}]\\cdot[x\\oplus S[son]\\in B]\\)</span></li>\n<li>注意到本条递推等式左端只有<span class=\"math inline\">\\(x\\)</span>，所以可以将枚举<span class=\"math inline\">\\(y\\)</span>的过程进行求和：<span class=\"math inline\">\\(ndp[x\\oplus S[son]]+=dp[u][x]\\cdot \\sum_{S[son]\\oplus y\\in s_{b}}dp[son][y]\\)</span></li>\n<li>因此可以在循环之前先预处理一个常数<span class=\"math inline\">\\(w=\\sum_{S[son]\\oplus y\\in s_{b}}dp[son][y]\\)</span></li>\n<li><span class=\"math inline\">\\(ndp[x\\oplus S[son]]+=dp[u][x]\\cdot w\\)</span>即可</li>\n</ul>\n</li>\n</ul>\n<p>最终答案即为:</p>\n<p></p><div class=\"math display\">\\[ans=\\sum_{S[root]\\oplus x\\in s_{b}}dp[root][x]\n\\]</div><p></p><p>注意：</p>\n<ul>\n<li>计算的时候注意取模</li>\n<li>上述枚举的<span class=\"math inline\">\\(x,y\\)</span>为具体值，在dp的过程中需要通过一个映射来将值映射回<span class=\"math inline\">\\([1,16]\\)</span>的范围中</li>\n</ul>\n<h2 id=\"代码-5\">代码</h2>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll \n#define rep(i,a,b) for(int i=(a);i&lt;=(b);i++)\n#define per(i,a,b) for(int i=(a);i&gt;=(b);i--)\n\nconst int N = 1e5 + 5, mod = 1e9 + 7;\nint n, k, S[N], b[5], a[N];\nmap&lt;int, int&gt;id;\nset&lt;int&gt;sb;\nvector&lt;int&gt;B;\nint nb;\nvector&lt;int&gt;e[N];\nvector&lt;vector&lt;int&gt;&gt;dp;\nvoid dfs(int u, int fa) {\n    S[u] = a[u];\n    for (auto son : e[u]) {\n        if (son == fa)continue;\n        dfs(son, u);\n        S[u] ^= S[son];\n    }\n}\n\nvoid dfs1(int u, int fa) {\n    dp[u][0] = 1;\n    for (auto son : e[u]) {\n        if (son == fa)continue;\n        dfs1(son, u);\n        vector&lt;int&gt;ndp(17, 0);\n        int w = 0;\n        rep(i, 0, nb - 1) {\n            int y = B[i] ^ S[son];\n            if (sb.count(y)) {\n                w += dp[son][i];\n                w %= mod;\n            }\n        }\n        rep(i, 0, nb - 1) {\n            int x = B[i];\n            rep(j, 0, nb - 1) {\n                int y = B[j];\n                if (id.count(x ^ y)) {\n                    ndp[id[x ^ y]] += dp[u][i] * dp[son][j] % mod;\n                    ndp[id[x ^ y]] %= mod;\n                }\n            }\n            if (id.count(x ^ S[son])) {\n                ndp[id[x ^ S[son]]] += dp[u][i] * w % mod;\n                ndp[id[x ^ S[son]]] %= mod;\n            }\n        }\n        dp[u] = ndp;\n    }\n}\n\nvoid solve() {\n    cin &gt;&gt; n &gt;&gt; k;\n    B.clear();\n    id.clear();\n    sb.clear();\n    dp.assign(n + 1, vector&lt;int&gt;(17, 0));\n    rep(i, 1, n)e[i].clear();\n    rep(i, 1, n - 1) {\n        int u, v;cin &gt;&gt; u &gt;&gt; v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    rep(i, 1, n)cin &gt;&gt; a[i];\n    rep(i, 1, k)cin &gt;&gt; b[i], sb.insert(b[i]);\n    rep(mk, 0, (1ll &lt;&lt; k) - 1) {\n        int now = 0;\n        rep(pos, 0, k - 1) {\n            if ((mk &gt;&gt; pos) &amp; 1)now ^= b[pos + 1];\n        }\n        B.push_back(now);\n    }\n    sort(B.begin(), B.end());\n    nb = unique(B.begin(), B.end()) - B.begin();\n    while (B.size() != nb)B.pop_back();\n    rep(i, 0, B.size() - 1) {\n        id[B[i]] = i;\n    }\n    dfs(1, 0);\n    dfs1(1, 0);\n    int ans = 0;\n    rep(i, 0, nb - 1) {\n        if (sb.count(B[i] ^ S[1])) {\n            ans += dp[1][i];\n            ans %= mod;\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n}\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;\n    while (t--)solve();\n}\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 16:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/CUC-MenG\">CUC-MenG</a>&nbsp;\n阅读(<span id=\"post_view_count\">23</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "V4L2 vs GStreamer vs FFmpeg：Linux多媒体处理的三个层级",
      "link": "https://www.cnblogs.com/tlink/p/19604853",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tlink/p/19604853\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 15:55\">\n    <span>V4L2 vs GStreamer vs FFmpeg：Linux多媒体处理的三个层级</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"V4L2 vs GStreamer vs FFmpeg：Linux多媒体处理的三个层级\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/394390/202602/394390-20260211155518455-1216702517.png\" />\n        V4L2、GStreamer 和 FFmpeg，理清它们之间的关系、区别和适用场景\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>本文详细解析 Linux 系统中三个关键的多媒体技术：V4L2、GStreamer 和 FFmpeg，理清它们之间的关系、区别和适用场景。</p>\n<h2 id=\"-概述\">📌 概述</h2>\n<ul>\n<li><strong>V4L2</strong>：Linux 访问摄像头的<strong>底层标准接口</strong>（驱动层）</li>\n<li><strong>GStreamer</strong>：构建视频处理流水线的<strong>应用框架</strong>（框架层）</li>\n<li><strong>FFmpeg</strong>：强大的多媒体<strong>工具箱</strong>（工具层）</li>\n</ul>\n<h2 id=\"-核心概念解析\">🎯 核心概念解析</h2>\n<h3 id=\"1-v4l2---视频采集的基石\">1. V4L2 - 视频采集的基石</h3>\n<p><strong>Video for Linux 2</strong>（Linux 视频框架第 2 版）是 Linux 内核中视频设备驱动的标准接口。</p>\n<h4 id=\"-主要功能\">🔧 主要功能：</h4>\n<ul>\n<li>提供统一接口访问所有视频设备</li>\n<li>控制摄像头参数（分辨率、帧率、格式等）</li>\n<li>管理视频缓冲区</li>\n<li>支持流式传输</li>\n</ul>\n<h4 id=\"-设备文件\">📁 设备文件：</h4>\n<pre><code class=\"language-bash\">/dev/video0    # 第一个摄像头\n/dev/video1    # 第二个摄像头\n/dev/video2    # 可能是一个摄像头的不同流\n</code></pre>\n<h4 id=\"️-常用工具\">🛠️ 常用工具：</h4>\n<pre><code class=\"language-bash\"># 查看设备\nv4l2-ctl --list-devices\n\n# 查看支持的格式\nv4l2-ctl --list-formats --device /dev/video0\n\n# 设置分辨率\nv4l2-ctl --set-fmt-video=width=640,height=480 --device /dev/video0\n\n# 拍照\nv4l2-ctl --device /dev/video0 --stream-mmap=3 --stream-to=photo.jpg\n</code></pre>\n<h3 id=\"2-gstreamer---多媒体流水线框架\">2. GStreamer - 多媒体流水线框架</h3>\n<p>GStreamer 是一个基于管道的多媒体框架，采用插件化设计，适合构建复杂的实时流媒体应用。</p>\n<h4 id=\"️-核心概念\">🏗️ 核心概念：</h4>\n<ul>\n<li><strong>Pipeline（管道）</strong>：连接多个元素的完整处理流程</li>\n<li><strong>Element（元素）</strong>：处理单元（source、filter、sink）</li>\n<li><strong>Pad（连接点）</strong>：元素之间的数据连接接口</li>\n<li><strong>Caps（能力）</strong>：描述数据格式的元数据</li>\n</ul>\n<p><img alt=\"1\" class=\"lazyload\" /></p>\n<h4 id=\"-典型流水线\">🔄 典型流水线：</h4>\n<pre><code class=\"language-bash\"># 显示摄像头\ngst-launch-1.0 v4l2src device=/dev/video0 ! videoconvert ! autovideosink\n\n# 录制视频\ngst-launch-1.0 v4l2src ! videoconvert ! x264enc ! mp4mux ! filesink location=output.mp4\n\n# OpenCV 使用\nstd::string pipeline = \"v4l2src ! videoconvert ! video/x-raw,format=BGR ! appsink\";\ncv::VideoCapture cap(pipeline, cv::CAP_GSTREAMER);\n</code></pre>\n<h3 id=\"3-ffmpeg---多媒体瑞士军刀\">3. FFmpeg - 多媒体瑞士军刀</h3>\n<p>FFmpeg 是一套完整的跨平台解决方案，用于记录、转换和流式传输音频和视频。</p>\n<h4 id=\"-核心组件\">🎯 核心组件：</h4>\n<ul>\n<li><strong>ffmpeg</strong>：命令行工具，用于格式转换</li>\n<li><strong>ffplay</strong>：简单的媒体播放器</li>\n<li><strong>ffprobe</strong>：多媒体流分析器</li>\n<li><strong>libav</strong>*：供开发者使用的库</li>\n</ul>\n<h4 id=\"-典型用法\">🚀 典型用法：</h4>\n<pre><code class=\"language-bash\"># 显示摄像头\nffplay -f v4l2 -i /dev/video0 -video_size 640x480\n\n# 格式转换\nffmpeg -i input.mp4 output.avi\n\n# 视频处理\nffmpeg -i input.mp4 -vf \"scale=640:480\" output.mp4\n\n# OpenCV 使用\ncv::VideoCapture cap(\"video.mp4\", cv::CAP_FFMPEG);\n</code></pre>\n<h2 id=\"-三者对比表\">📊 三者对比表</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>V4L2</th>\n<th>GStreamer</th>\n<th>FFmpeg</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>层级定位</strong></td>\n<td>驱动层/内核接口</td>\n<td>应用框架层</td>\n<td>应用工具层</td>\n</tr>\n<tr>\n<td><strong>主要用途</strong></td>\n<td>硬件设备访问</td>\n<td>实时流处理</td>\n<td>文件格式转换</td>\n</tr>\n<tr>\n<td><strong>设计哲学</strong></td>\n<td>标准硬件接口</td>\n<td>模块化流水线</td>\n<td>一体化工具集</td>\n</tr>\n<tr>\n<td><strong>编程接口</strong></td>\n<td>系统调用/ioctl</td>\n<td>C API/管道描述</td>\n<td>命令行/库API</td>\n</tr>\n<tr>\n<td><strong>插件系统</strong></td>\n<td>无（驱动级别）</td>\n<td>运行时动态加载</td>\n<td>编译时链接</td>\n</tr>\n<tr>\n<td><strong>学习曲线</strong></td>\n<td>陡峭（需要了解内核）</td>\n<td>中等</td>\n<td>相对平缓</td>\n</tr>\n<tr>\n<td><strong>实时性</strong></td>\n<td>优秀（直接硬件访问）</td>\n<td>优秀</td>\n<td>良好</td>\n</tr>\n<tr>\n<td><strong>社区规模</strong></td>\n<td>中等（Linux内核）</td>\n<td>大型</td>\n<td>非常庞大</td>\n</tr>\n<tr>\n<td><strong>语言绑定</strong></td>\n<td>主要为C</td>\n<td>丰富（Python、C++、Rust等）</td>\n<td>有限</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"️-技术架构关系\">🏗️ 技术架构关系</h2>\n<pre><code>┌─────────────────────────────────────────┐\n│           应用程序层                      │\n│  (OpenCV、Python应用、自定义程序)          │\n└─────────────┬───────────────────────────┘\n              │\n    ┌─────────┴─────────┐\n    │                   │\n┌───▼──────┐      ┌─────▼──────┐\n│ GStreamer│      │   FFmpeg   │\n│ (框架层)  │      │  (工具层)  │\n└───┬──────┘      └─────┬──────┘\n    │                   │\n    └─────────┬─────────┘\n              │\n       ┌──────▼──────┐\n       │    V4L2     │←──── 关键路径！\n       │ (驱动接口层) │     所有Linux视频应用都要经过这里\n       └──────┬──────┘\n              │\n       ┌──────▼──────┐\n       │  摄像头驱动  │\n       │  (内核层)   │\n       └──────┬──────┘\n              │\n       ┌──────▼──────┐\n       │  摄像头硬件  │\n       │ (USB/CSI等) │\n       └─────────────┘\n</code></pre>\n<h3 id=\"类比文件系统\">类比文件系统</h3>\n<ul>\n<li><strong>V4L2</strong> = <strong>文件操作API</strong>（open/read/write）</li>\n<li><strong>GStreamer</strong> = <strong>文本处理流水线</strong>（cat | grep | sed）</li>\n<li><strong>FFmpeg</strong> = <strong>文件格式转换工具</strong>（unzip、tar等）</li>\n</ul>\n<h2 id=\"-如何选择\">💡 如何选择？</h2>\n<h3 id=\"当使用-v4l2\">当使用 V4L2：</h3>\n<p>✅ 需要直接控制摄像头硬件参数<br />\n✅ 开发底层驱动程序<br />\n✅ 需要最小化延迟<br />\n✅ 进行性能基准测试</p>\n<h3 id=\"当使用-gstreamer\">当使用 GStreamer：</h3>\n<p>✅ 构建实时视频处理应用<br />\n✅ 需要复杂的处理流水线<br />\n✅ 开发 GUI 多媒体应用<br />\n✅ 需要插件化架构<br />\n✅ 处理网络流媒体</p>\n<h3 id=\"当使用-ffmpeg\">当使用 FFmpeg：</h3>\n<p>✅ 批量转换视频格式<br />\n✅ 执行简单的多媒体任务<br />\n✅ 需要丰富的编解码器支持<br />\n✅ 快速原型开发<br />\n✅ 不想写太多代码</p>\n<h2 id=\"-实际开发示例\">🔧 实际开发示例</h2>\n<h3 id=\"opencv-中的不同访问方式\">OpenCV 中的不同访问方式：</h3>\n<pre><code class=\"language-cpp\">// 方式1：自动选择后端\ncv::VideoCapture cap(0);\n\n// 方式2：使用 V4L2 直接访问\ncv::VideoCapture cap(0, cv::CAP_V4L2);\n\n// 方式3：使用 GStreamer 流水线\nstd::string pipeline = \"v4l2src device=/dev/video0 ! \"\n                       \"videoconvert ! \"\n                       \"video/x-raw,format=BGR ! \"\n                       \"appsink\";\ncv::VideoCapture cap(pipeline, cv::CAP_GSTREAMER);\n\n// 方式4：使用 FFmpeg 后端\ncv::VideoCapture cap(\"video.mp4\", cv::CAP_FFMPEG);\n</code></pre>\n<h3 id=\"典型应用场景\">典型应用场景：</h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐技术</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>视频监控系统</strong></td>\n<td>GStreamer</td>\n<td>需要多路流、实时处理、网络传输</td>\n</tr>\n<tr>\n<td><strong>视频编辑软件</strong></td>\n<td>GStreamer + FFmpeg</td>\n<td>GStreamer做实时预览，FFmpeg做导出</td>\n</tr>\n<tr>\n<td><strong>批量格式转换</strong></td>\n<td>FFmpeg</td>\n<td>命令行简单高效</td>\n</tr>\n<tr>\n<td><strong>摄像头驱动开发</strong></td>\n<td>V4L2</td>\n<td>直接与硬件交互</td>\n</tr>\n<tr>\n<td><strong>嵌入式视觉应用</strong></td>\n<td>V4L2 + GStreamer</td>\n<td>V4L2获取数据，GStreamer处理</td>\n</tr>\n<tr>\n<td><strong>快速脚本工具</strong></td>\n<td>FFmpeg</td>\n<td>一行命令完成任务</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"-性能对比\">🚀 性能对比</h2>\n<table>\n<thead>\n<tr>\n<th>任务类型</th>\n<th>V4L2</th>\n<th>GStreamer</th>\n<th>FFmpeg</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>单帧延迟</strong></td>\n<td>⭐⭐⭐⭐⭐</td>\n<td>⭐⭐⭐⭐</td>\n<td>⭐⭐⭐</td>\n</tr>\n<tr>\n<td><strong>CPU占用</strong></td>\n<td>低</td>\n<td>中等</td>\n<td>高</td>\n</tr>\n<tr>\n<td><strong>内存使用</strong></td>\n<td>低</td>\n<td>中等</td>\n<td>高</td>\n</tr>\n<tr>\n<td><strong>多路流支持</strong></td>\n<td>需要手动管理</td>\n<td>天然支持</td>\n<td>需要复杂命令</td>\n</tr>\n<tr>\n<td><strong>格式兼容性</strong></td>\n<td>有限（硬件依赖）</td>\n<td>优秀（插件丰富）</td>\n<td>极佳（支持广泛）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"-调试技巧\">🔍 调试技巧</h2>\n<h3 id=\"1-摄像头问题排查\">1. 摄像头问题排查：</h3>\n<pre><code class=\"language-bash\"># 检查设备\nls -l /dev/video*\nv4l2-ctl --list-devices\n\n# 测试摄像头\ngst-launch-1.0 v4l2src ! autovideosink\nffplay -f v4l2 -i /dev/video0\n\n# 查看详细参数\nv4l2-ctl --all --device /dev/video0\n</code></pre>\n<h3 id=\"2-gstreamer-调试\">2. GStreamer 调试：</h3>\n<pre><code class=\"language-bash\"># 查看元素信息\ngst-inspect-1.0 v4l2src\n\n# 调试输出\nGST_DEBUG=*:3 gst-launch-1.0 ...\n\n# 查看支持的格式\ngst-launch-1.0 v4l2src device=/dev/video0 ! fakesink\n</code></pre>\n<h3 id=\"3-ffmpeg-调试\">3. FFmpeg 调试：</h3>\n<pre><code class=\"language-bash\"># 查看支持格式\nffmpeg -formats\nffmpeg -codecs\n\n# 详细输出\nffmpeg -i input.mp4 -f null - 2&gt;&amp;1 | head -50\n</code></pre>\n<h2 id=\"-总结\">🌟 总结</h2>\n<table>\n<thead>\n<tr>\n<th>技术</th>\n<th>核心价值</th>\n<th>一句话描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>V4L2</strong></td>\n<td>统一硬件访问</td>\n<td>Linux 上访问摄像头的唯一标准方式</td>\n</tr>\n<tr>\n<td><strong>GStreamer</strong></td>\n<td>灵活流水线处理</td>\n<td>构建复杂多媒体应用的框架</td>\n</tr>\n<tr>\n<td><strong>FFmpeg</strong></td>\n<td>强大编解码能力</td>\n<td>处理多媒体文件的瑞士军刀</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"-三者协作\">🤝 三者协作</h2>\n<p>在实际项目中，三者常常协同工作：</p>\n<pre><code class=\"language-bash\"># 场景：实时视频分析系统\n# 1. V4L2 采集原始视频\n# 2. GStreamer 进行实时处理和分析\n# 3. FFmpeg 录制片段或转码存储\n\n# 流水线示例\ngst-launch-1.0 v4l2src ! \\\ntee name=t ! \\\nqueue ! videoconvert ! xvimagesink \\\nt. ! queue ! videoconvert ! x264enc ! mp4mux ! filesink location=record.mp4\n</code></pre>\n<h2 id=\"-发展趋势\">📈 发展趋势</h2>\n<ol>\n<li><strong>V4L2</strong>：持续发展，增加对新硬件的支持</li>\n<li><strong>GStreamer</strong>：在嵌入式、IoT、汽车领域应用增多</li>\n<li><strong>FFmpeg</strong>：仍然是行业标准，社区活跃</li>\n</ol>\n<h2 id=\"-相关链接\">📖 相关链接</h2>\n<ul>\n<li><a href=\"https://www.kernel.org/doc/html/latest/userspace-api/media/v4l/v4l2.html\" rel=\"noopener nofollow\" target=\"_blank\">V4L2 官方文档</a></li>\n<li><a href=\"https://gstreamer.freedesktop.org/documentation/tutorials/\" rel=\"noopener nofollow\" target=\"_blank\">GStreamer 官方教程</a></li>\n<li><a href=\"https://ffmpeg.org/documentation.html\" rel=\"noopener nofollow\" target=\"_blank\">FFmpeg 官方文档</a></li>\n<li><a href=\"https://docs.opencv.org/4.x/\" rel=\"noopener nofollow\" target=\"_blank\">OpenCV 视频I/O模块</a></li>\n</ul>\n<hr />\n<p><strong>关键点</strong>：在 Linux 上，无论你使用 GStreamer 还是 FFmpeg 还是 OpenCV，最终都要通过 <strong>V4L2</strong> 来与摄像头硬件通信！选择合适的工具取决于你的具体需求和场景。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 15:55</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tlink\">Tlink</a>&nbsp;\n阅读(<span id=\"post_view_count\">41</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大模型榜单周报（2026/02/08）",
      "link": "https://www.cnblogs.com/xjk15082/p/19606070",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xjk15082/p/19606070\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 21:45\">\n    <span>大模型榜单周报（2026/02/08）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1-本周概览\">1. 本周概览</h2>\n<p>本周大模型行业呈现多维度竞争格局，模型调用量榜单出现显著变化，Google Gemini 3 Flash Preview强势登顶，Kimi K2.5爆发式增长。各大厂商密集发布新模型，OpenAI推出GPT-5.3-Codex编码模型，Anthropic发布Claude Opus 4.6，美团推出多模态统一大模型方案STAR，快手可灵AI发布3.0版本，上海AI实验室发布书生Intern-S1-Pro。编程能力榜单中，Kimi K2.5-thinking成为国产编程模型榜首。前沿数学能力榜单出现重大调整，Claude Opus 4.5 (no thinking)成绩暴增跃居前三。</p>\n<h2 id=\"2-重点关注事件\">2. 重点关注事件</h2>\n<ul>\n<li><strong>OpenAI发布GPT-5.3-Codex编码模型</strong>（2.6）：融合GPT-5.2推理能力与GPT-5.2-Codex编码性能，运行速度提升25%，支持终端操作与长期任务。该模型曾参与自身训练调试，被定为首个\"高\"网络安全风险等级。</li>\n<li><strong>Anthropic发布Claude Opus 4.6</strong>（2.6）：显著提升编码、推理与代理任务能力，首创百万token上下文窗口。Terminal-Bench 2.0等评测领先，GDPval-AA超GPT-5.2达144 Elo分，定价维持$5/$25每百万token不变。</li>\n<li><strong>美团推出多模态统一大模型方案STAR</strong>（2.4）：凭借创新的\"堆叠自回归架构 + 任务递进训练\"双核心设计，GenEval突破0.91，实现了\"理解能力不打折、生成能力达顶尖\"的双重突破。</li>\n<li><strong>快手可灵AI发布3.0版本</strong>（2.4）：推出视频3.0与Omni模型，支持智能分镜、图生视频+主体参考、多语种对口型、15秒长视频生成。</li>\n<li><strong>上海AI实验室发布书生Intern-S1-Pro</strong>（2.4）：核心科学能力实现跃升，高难度综合学科评测稳居AI4S领域国际领先水平，复杂数理逻辑推理能力达奥赛金牌水平，面向真实科研流程的智能体能力位居开源模型第一梯队。</li>\n</ul>\n<h2 id=\"3-榜单变化\">3. 榜单变化</h2>\n<h3 id=\"openrouter模型调用量排名\">OpenRouter模型调用量排名</h3>\n<ul>\n<li><strong>整体调用量</strong>：Google Gemini 3 Flash Preview强势登顶，从上周第2位（580B tokens，14%增长）跃升至本周第1位（791B tokens，36%增长），反超Claude Sonnet 4.5成为榜首；Claude Sonnet 4.5退居次席，从上周第1位（766B tokens，15%增长）降至本周第2位（727B tokens，5%增长），环比调用量绝对值减少39B tokens；Kimi K2.5爆发式增长新入前三，本周以673B tokens和350%的增长率位列第3，而上周未进入前十榜单；Grok Code Fast 1大幅下滑，从上周第3位（477B tokens，12%增长）骤降至本周第8位（336B tokens，下降30%），排名下跌5位；MiniMax M2.1高速增长新入榜，本周以371B tokens和115%的增长率位列第7，上周未在榜单中。</li>\n<li><strong>模型市占率</strong>：MoonshotAI爆发式攀升，从上周203B tokens（3.5%，第7位）暴涨至本周606B tokens（8.8%，第5位），份额增长5.3个百分点，排名上升2位；x-ai大幅下滑，从上周719B tokens（12.3%，第4位）骤降至本周587B tokens（8.6%，第6位），份额减少3.7个百分点；MiniMax强势入榜，本周以323B tokens（4.7%）新进入前十榜单第7位；三大巨头份额齐降，Google保持第1但份额从24%降至23%，Anthropic保持第2但份额从17.1%降至15.4%，OpenAI保持第3但份额从14%降至13.4%；DeepSeek稳中有进，从上周553B tokens（9.4%，第5位）增至本周651B tokens（9.5%，第4位），超越x-ai上升1位。</li>\n<li><strong>模型吞吐量</strong>：gpt-oss-120b速度大幅回落，从上周第2位（836 tok/s）骤降至本周第4位（447 tok/s），速度下降46%；Llama 3.1 8B Instruct性价比跃升，从上周第9位（Cerebras提供，203 tok/s，0.10/M）升至本周第6位（Groq提供，306tok/s，0.05/M），速度提升51%且价格降低50%；两款模型跌出前十，上周第5位的Llama 3.3 70B Instruct（265 tok/s）和第8位的Qwen3 Next 80B（233 tok/s）本周退出榜单；两款模型入榜，Llama 4 Maverick（第8位，181 tok/s）和Mistral Small Creative（第9位，180 tok/s）新进入前十；Gemini 2.5 Flash Lite Preview持续提速，从上周第10位（169 tok/s）升至本周第7位（221 tok/s），速度提升31%。</li>\n<li><strong>编程调用量</strong>：Kimi K2.5爆发式增长登顶，从上周第4位（139B tokens，8.9%）暴涨至本周第1位（463B tokens，25.2%），份额激增16.3个百分点；Grok Code Fast 1大幅下滑，从上周榜首（255B tokens，16.4%）骤降至本周第3位（173B tokens，9.4%），份额减少7个百分点；MiniMax M2.1快速攀升，从上周第6位（115B tokens，7.4%）跃升至本周第2位（226B tokens，12.3%），份额增长4.9个百分点；Claude双模型份额齐降，Claude Sonnet 4.5从第2位（12.3%）降至第5位（7.9%），Claude Opus 4.5从第3位（10.0%）降至第4位（8.7%）；GPT-5.2持续收缩，从第8位（61.4B tokens，3.9%）降至第9位（38.7B tokens，2.1%），同时https://www.arcee.ai/发布的400B参数稀疏MoE开源模型Trinity Large Preview (free)新进入前十榜单，排名第7位。</li>\n</ul>\n<h3 id=\"各领域能力榜单\">各领域能力榜单</h3>\n<ul>\n<li><strong>编程能力榜单（Code Arena）</strong>：Kimi K2.5-thinking新晋榜单第5位，仅次于御三家的模型，成为国产编程模型榜首。</li>\n<li><strong>文生图能力榜单（Artificial Analysis Text to Image Leaderboard）</strong>：FLUX.2 [dev] Turbo分数超过Nano Banana，二者排名易位，分别排名9、10。</li>\n<li><strong>理科能力榜单（GPQA LLM Stats）</strong>：Claude Opus 4.6以91.3%的得分排名第4位，仅次于GPT-5.2 Pro、GPT 5.2和Gemini 3 Pro。</li>\n<li><strong>前沿数学能力榜单（EPOCH AI FrontierMath）</strong>：Claude Opus 4.5 (no thinking)成绩暴增跃居前三，从上周五第16位（准确率20.7%，60/290）飙升至本周第3位（38.3%，111/290），准确率提升17.6个百分点；其次是Kimi K2.5 (Fireworks)新进入前十榜单，以27.9%（81/290）排名第10，取代了同系列的Kimi K2 Thinking（21.4%，第15位）。</li>\n<li><strong>GAIA测试集榜单</strong>：LR AILab of Lenovo CTO Org发布的Lemon agent登顶首位。</li>\n</ul>\n<h2 id=\"4-排行榜\">4. 排行榜</h2>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>第一名</th>\n<th>第二名</th>\n<th>第三名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模型调用量</td>\n<td>Gemini 3 Flash Preview</td>\n<td>Claude Sonnet 4.5</td>\n<td>Kimi K 2.5</td>\n</tr>\n<tr>\n<td>公司市占率</td>\n<td>Google</td>\n<td>Anthropic</td>\n<td>OpenAI</td>\n</tr>\n<tr>\n<td>模型速度</td>\n<td>gpt-oss-safeguard-20b</td>\n<td>Qwen3 32B</td>\n<td>gpt-oss-20b</td>\n</tr>\n<tr>\n<td>编程模型调用量</td>\n<td>Kimi K 2.5</td>\n<td>MiniMax M2.1</td>\n<td>Grok Code Fast 1</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"各公司按不同能力领域排名汇总\">各公司按不同能力领域排名汇总</h3>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>领先公司</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>大语言模型 Text Arena</td>\n<td>Google、xAI、Anthropic、百度、OpenAI、智谱、阿里巴巴、月之暗面</td>\n</tr>\n<tr>\n<td>编程能力 Code Arena</td>\n<td>Anthropic、OpenAI、Google、智谱、MiniMax</td>\n</tr>\n<tr>\n<td>编程能力 LiveCodeBench</td>\n<td>OpenAI、Anthropic、Google</td>\n</tr>\n<tr>\n<td>代码工程任务能力 SWE-benchLite</td>\n<td>基于Claude、Gemini、GPT、Qwen、DeepSeek开发的开源系统</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Edit Arena</td>\n<td>OpenAI、Google、字节、腾讯、Black Forest Labs、Reve</td>\n</tr>\n<tr>\n<td>文生图能力 Text-to-Image Arena</td>\n<td>OpenAI、Google、Black Forest Labs、腾讯</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Editing Leaderboard</td>\n<td>OpenAI、Google、字节、Black Forest Labs、阿里巴巴、Reve</td>\n</tr>\n<tr>\n<td>文生图能力 Text to Image Leaderboard</td>\n<td>OpenAI、Google、Black Forest Labs、字节、Fal</td>\n</tr>\n<tr>\n<td>GPQA</td>\n<td>OpenAI、Google、Anthropic、xAI、阿里巴巴</td>\n</tr>\n<tr>\n<td>FrontierMath</td>\n<td>OpenAI、Google、Anthropic、DeepSeek、月之暗面、xAI</td>\n</tr>\n<tr>\n<td>Humanity's Last Exam</td>\n<td>Google、OpenAI、Anthropic</td>\n</tr>\n<tr>\n<td>GAIA</td>\n<td>LR AILab of Lenovo CTO Org、JoinAI、Nvidia、Suzhou AI Lab&amp;Shuqian Tech、Microsoft AI Asia -Ads、ShawnAgent、ZTE-AICloud</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p>关注我，第一时间掌握更多AI前沿资讯！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 21:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xjk15082\">KAI智习</a>&nbsp;\n阅读(<span id=\"post_view_count\">10</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MyBatis XML 里＜![CDATA[ ]]＞的使用",
      "link": "https://www.cnblogs.com/yanshajiuzhou/p/19606003",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yanshajiuzhou/p/19606003\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 21:15\">\n    <span>MyBatis XML 里＜![CDATA[ ]]＞的使用</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n         是 MyBatis 中处理 SQL 语句与 XML 语法冲突的安全屏障。对包含 特殊字符 的 SQL 片段进行最小范围的 CDATA 包裹，既保证了安全，又确保了 MyBatis 动态 SQL 功能的完整性。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>今天我们来聊聊&nbsp;MyBatis XML 文件里的&nbsp;<strong>&lt;![CDATA[ ]]&gt;</strong> ，我依稀记得我第一次看到&nbsp;<strong>&lt;![CDATA[ ]]&gt;</strong>，心想，这是个啥啊？</p>\n<p>首先我们要明确：<strong>&lt;![CDATA[ ]]&gt;&nbsp; 不是 MyBatis 的专属语法</strong>，而是 XML 的原生语法（全称 Character Data，字符数据）。</p>\n<p><strong>XML 解析器&nbsp;</strong>对某些特殊字符（比如 <strong>&lt;、&gt;、&amp;、'、\" </strong>等）进行解析的时候，可能会将这些特殊字符 <strong>误判</strong>，比如 将 <strong>&lt;</strong> 识别为 XML 标签的开始，等等。</p>\n<p><strong>&lt;![CDATA[ ]]&gt;</strong> 的核心作用：<strong>将包裹的内容标记为 \"纯文本\"</strong>，XML 解析器会跳过对其中内容的语法解析，直接 <strong>原样保留</strong>，从而避免特殊字符与 XML 语法的冲突，保证 MyBatis 最终拿到的 SQL 是我们预期的样子。</p>\n<p>我们除了可以使用&nbsp;<strong>&lt;![CDATA[ ]]&gt;</strong>，也可以使用 <strong>转义字符</strong>。</p>\n<p>常用的 <strong>转义字符对照</strong>：</p>\n<ul>\n<li><strong>&lt; → &amp;lt;</strong></li>\n<li><strong>&gt; → &amp;gt;</strong></li>\n<li><strong>&amp; → &amp;amp;</strong></li>\n<li><strong>\" → &amp;quot;</strong></li>\n<li><strong>' → &amp;apos;</strong></li>\n</ul>\n<p>注意结尾的 <strong>; </strong>需要留着。</p>\n<p><strong>错误写法</strong>：</p>\n<pre class=\"language-sql highlighter-hljs\"><code>&lt;!-- XML解析器会把 &lt; 识别为标签开始，直接报错 --&gt;\n&lt;select id=\"getUserByAge\" resultType=\"User\"&gt;\n    SELECT * FROM user WHERE age &lt; #{age}\n&lt;/select&gt;</code></pre>\n<p><strong>使用 转义 写法</strong>：</p>\n<pre class=\"language-sql highlighter-hljs\"><code>&lt;select id=\"getUserByAge\" resultType=\"User\"&gt;\n    SELECT * FROM user WHERE age &amp;lt; #{age}\n&lt;/select&gt;</code></pre>\n<p><strong>使用 CDATA 写法</strong>：</p>\n<pre class=\"language-sql highlighter-hljs\"><code>&lt;select id=\"getUserByAge\" resultType=\"User\"&gt;\n    SELECT * FROM user WHERE &lt;![CDATA[ age &lt; #{age} ]]&gt;\n&lt;/select&gt;</code></pre>\n<p>是不是使用&nbsp;<strong>CDATA </strong>的可读性要高很多，所以推荐使用&nbsp;<strong>CDATA</strong>，尤其是复杂SQL。</p>\n<p>我们看个不是很复杂的SQL。</p>\n<p><strong>复杂SQL 转义 写法</strong>：</p>\n<pre class=\"language-sql highlighter-hljs\"><code>&lt;select id=\"getUserBySpec\" resultType=\"User\"&gt;\n    SELECT * FROM user WHERE (age &amp;lt; #{age} OR salary &amp;gt; #{salary})\n    AND (create_time gt;= #{startTime} OR update_time lt;= #{endTime})\n&lt;/select&gt;</code></pre>\n<p><strong>复杂SQL CDATA 写法</strong>：</p>\n<pre class=\"language-sql highlighter-hljs\"><code>&lt;select id=\"getUserBySpec\" resultType=\"User\"&gt;\n    SELECT * FROM user\n    &lt;![CDATA[\n        WHERE (age &lt; #{age} OR salary &gt; #{salary}) \n        AND (create_time &gt;= #{startTime} OR update_time &lt;= #{endTime})\n    ]]&gt;\n&lt;/select&gt;</code></pre>\n<p><strong>MyBatis 高版本 </strong>对部分特殊字符做了兼容，比如直接写 <strong>&gt; </strong>可能不报错了。这是 \"宽松解析\"，跨环境（比如不同 XML 解析器、不同数据库驱动等）仍有可能出问题，<strong>推荐始终用 CDATA 保证兼容性</strong>。</p>\n<p><strong>&lt;![CDATA[ ]]&gt;</strong> 是 MyBatis 中处理 SQL 语句与 XML 语法冲突的安全屏障。对包含 <strong>特殊字符</strong> 的 SQL 片段进行最小范围的 <strong>CDATA 包裹</strong>，既保证了安全，又确保了 MyBatis 动态 SQL 功能的完整性。</p>\n<p style=\"text-align: right;\"><span style=\"color: rgba(53, 152, 219, 1);\">手执烟火以谋生，心怀诗意以谋爱。-- 烟沙九洲</span></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 21:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yanshajiuzhou\">烟沙九洲</a>&nbsp;\n阅读(<span id=\"post_view_count\">6</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}