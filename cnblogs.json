{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "埋点分析一定要先设计事件吗？我们用 ClkLog：SDK 接完就能直接分析",
      "link": "https://www.cnblogs.com/clklog/p/19596104",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/clklog/p/19596104\" id=\"cb_post_title_url\" title=\"发布于 2026-02-09 16:35\">\n    <span>埋点分析一定要先设计事件吗？我们用 ClkLog：SDK 接完就能直接分析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>&nbsp;<span>在ClkLog的设计中，我们做了一件看起来“很简单”，但在实际项目里非常关键的事情：<strong><span>内置了<span>开箱即用<span>的<span>成熟<span>用户行为分析模型<span>（<span>如<span>基础<span>访问<span>、<span>访问<span>来源<span>等<span>）<span>。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></span></div>\n<div class=\"document\">\n<div class=\"section\">\n<p class=\"paragraph text-align-type-justify\"><span>这意味着，在完成SDK接入后，团队不需要先定义大量自定义事件，也不需要反复设计分析口径，就可以直接看到基础分析结果，用于产品和运营决策。</span></p>\n<p class=\"paragraph text-align-type-justify\"><span>&nbsp;</span></p>\n<p class=\"paragraph text-align-type-justify\"><span>这个能力的目标只有一个：<strong><span>让埋点分析系统在“接完SDK”之后，真的能马上用起来。</span></strong></span></p>\n<p class=\"paragraph text-align-type-justify\"><span lang=\"EN-US\">&nbsp;</span></p>\n<p class=\"paragraph text-align-type-justify\"><strong><span>为什么「接完<span>SDK能马上用」这么重要<span>？</span></span></span></strong></p>\n<p class=\"paragraph text-align-type-justify\"><span>在实际项目中，大家应该遇到过这样的情况：</span></p>\n<ul>\n<li class=\"paragraph text-align-type-justify\"><span><span>SDK很快就接好了</span></span></li>\n<li class=\"paragraph text-align-type-justify\"><span><span>数据也确实开始上报了</span></span></li>\n<li class=\"paragraph text-align-type-justify\"><span><strong><span>但分析系统迟迟没有被真正使用起来</span></strong></span></li>\n</ul>\n<p class=\"paragraph text-align-type-justify\"><span>这不是技术问题，其实是数据分析的门槛。</span></p>\n<p class=\"paragraph text-align-type-justify\"><span>&nbsp;</span></p>\n<p class=\"paragraph text-align-type-justify\"><span>很多分析系统使用的前提是：你已经知道要看什么数据了、知道指标怎么计算了……</span></p>\n<p class=\"paragraph text-align-type-justify\"><span>但真实的业务场景里却是相反的，对于很多刚接触分析的团队来说是<strong><span>想先看到数据，在逐步明确怎么继续深入分析。</span></strong></span></p>\n<p class=\"paragraph text-align-type-justify\"><span>&nbsp;</span></p>\n<p class=\"paragraph text-align-type-justify\"><strong><span>为什么很多埋点系统「有数据，却不好分析」？</span></strong></p>\n<p class=\"paragraph text-align-type-justify\"><span>1.一上来就要求做自定义事件</span></p>\n<p class=\"paragraph text-align-type-justify\"><span>为了做一次基础分析，往往需要先做这些事情：</span></p>\n<ul>\n<li class=\"paragraph text-align-type-justify\"><span><span>梳理完整的埋点规范</span></span></li>\n<li class=\"paragraph text-align-type-justify\"><span><span>定义事件和属性</span></span></li>\n<li class=\"paragraph text-align-type-justify\"><span><span>统一命名和口径</span></span></li>\n</ul>\n<p class=\"paragraph text-align-type-justify\"><span>这对早期或节奏快的团队来说，成本非常高。</span></p>\n<p class=\"paragraph text-align-type-justify\"><span lang=\"EN-US\">&nbsp;</span></p>\n<p class=\"paragraph text-align-type-justify\"><span>2.分析模型本身是隐性成本</span></p>\n<p class=\"paragraph text-align-type-justify\"><span>新老访客、忠诚度、留存、漏斗、路径、转化……这些分析并不是“画个图”那么简单，而是：</span></p>\n<ul>\n<li class=\"paragraph text-align-type-justify\"><span><span>涉及用户去重规则</span></span></li>\n<li class=\"paragraph text-align-type-justify\"><span><span>涉及时间窗口</span></span></li>\n<li class=\"paragraph text-align-type-justify\"><span><span>涉及事件顺序和条件</span></span></li>\n</ul>\n<p class=\"paragraph text-align-type-justify\"><span>很多团队在真正实现时才发现：</span></p>\n<p class=\"paragraph text-align-type-justify\"><strong><span>写统计不难，写对、写稳、写得长期可用才难。</span></strong></p>\n<p class=\"paragraph text-align-type-justify\"><span>&nbsp;</span></p>\n<p class=\"paragraph text-align-type-justify\"><strong><span>ClkLog内置分析模型解决的是什么问题？</span></strong></p>\n<p class=\"paragraph text-align-type-justify\"><span>正是基于这些实际使用问题，ClkLog 在产品中内置了一套<span><strong>开箱即用的分析模型</strong><span>。</span></span></span></p>\n<p class=\"paragraph text-align-type-justify\"><span>核心目标只有一个：</span></p>\n<p class=\"paragraph text-align-type-justify\"><strong><span>降低“从接入到产生分析价值”的门槛。</span></strong></p>\n<p class=\"paragraph text-align-type-justify\"><strong><span>让团队可以快速验证产品的可行性，也能让运营团队慢慢熟悉产品为下一步深入分析做准备。</span></strong></p>\n<p class=\"paragraph text-align-type-justify\"><span>当团队逐步明确需求后，再进行深入分析、二次开发，方向会更明确、成本也更可控。</span></p>\n<p class=\"paragraph text-align-type-justify\"><span>&nbsp;</span></p>\n<p class=\"paragraph text-align-type-justify\"><strong><span>ClkLog内置了哪些分析能力？</span></strong></p>\n<p class=\"paragraph text-align-type-justify\"><span>在完成 SDK 集成后，以下分析能力可以直接使用的：</span></p>\n<p class=\"paragraph text-align-type-left\"><strong>1.&nbsp; <span>基础访问分析</span></strong></p>\n<ul>\n<li class=\"paragraph text-align-type-justify\"><span> <span> <span> <span> <span> <span> <span> <span><span>PV/UV/IP数</span></span></span></span></span></span></span></span></span></li>\n<li class=\"paragraph text-align-type-left\"><span> <span> <span> <span> <span> <span> <span> <span><span>平均访问时长</span></span></span></span></span></span></span></span></span></li>\n<li class=\"paragraph text-align-type-left\"><span> <span> <span> <span> <span> <span> <span> <span><span>跳出率</span></span></span></span></span></span></span></span></span></li>\n</ul>\n<p><span><span><span><span><span><span><span><span><span><img alt=\"图1\" class=\"lazyload\" height=\"140\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"605\" /></span></span></span></span></span></span></span></span></span></p>\n<p class=\"paragraph text-align-type-justify\"><span>无需额外事件定义，即可了解整体访问情况。</span></p>\n<p class=\"paragraph text-align-type-justify\"><span>&nbsp;</span></p>\n<p class=\"paragraph text-align-type-left\"><strong>2.&nbsp; <span>访客分析</span></strong></p>\n<ul>\n<li class=\"paragraph text-align-type-left\"><span> <span> <span> <span> <span> <span> <span> <span> <span><span>新老访客</span></span></span></span></span></span></span></span></span></span></li>\n<li class=\"paragraph text-align-type-left\"><span> <span> <span> <span> <span> <span> <span> <span> <span><span>地域分析</span></span></span></span></span></span></span></span></span></span></li>\n<li class=\"paragraph text-align-type-left\"><span> <span> <span> <span> <span> <span> <span> <span><span>来源网站<span>/渠道/设备分析</span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n<p><span><span><span><span><span><span><span><span><span><span><img alt=\"图2\" class=\"lazyload\" height=\"300\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"609\" /></span></span></span></span></span></span></span></span></span></span></p>\n<p><img alt=\"图3\" class=\"lazyload\" height=\"195\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"600\" /></p>\n<p class=\"paragraph text-align-type-justify\"><img alt=\"图3.5\" class=\"lazyload\" height=\"251\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"599\" /></p>\n<p class=\"paragraph text-align-type-justify\"><span>访客的基础信息可以一目了然。</span></p>\n<p class=\"paragraph text-align-type-justify\"><span>&nbsp;</span></p>\n<p class=\"paragraph text-align-type-left\"><strong>3.&nbsp; <span>用户分析</span></strong></p>\n<ul>\n<li class=\"paragraph text-align-type-left\"><span> <span> <span> <span> <span> <span> <span> <span><span>构建用户基本画像</span></span></span></span></span></span></span></span></span></li>\n<li class=\"paragraph text-align-type-left\"><span> <span> <span> <span> <span> <span> <span> <span><span>用户忠诚度分析</span></span></span></span></span></span></span></span></span></li>\n</ul>\n<p><span><span><span><span><span><span><span><span><span><img alt=\"图4\" class=\"lazyload\" height=\"259\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"553\" /></span></span></span></span></span></span></span></span></span></p>\n<p class=\"paragraph text-align-type-justify\"><img alt=\"图5\" class=\"lazyload\" height=\"204\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"552\" /></p>\n<p class=\"paragraph text-align-type-justify\"><span>详细了解每个用户的使用情况。</span></p>\n<p class=\"paragraph text-align-type-justify\"><span lang=\"EN-US\">&nbsp;</span></p>\n<p class=\"paragraph text-align-type-justify\"><span>ClkLog通过内置分析模型，希望解决的是：</span></p>\n<p class=\"paragraph text-align-type-justify\"><strong><span>让团队在完成SDK集成后，就能尽快进入“分析和决策”阶段，而不是被埋点和模型设计拖慢节奏。</span></strong></p>\n<p class=\"paragraph text-align-type-justify\"><span lang=\"EN-US\">&nbsp;</span></p>\n<p class=\"paragraph text-align-type-justify\"><span>如果你有兴趣可以来<span>gitee<span>和<span>github<span>直接获取ClkLog社区版进行部署集成，<span><strong>快速开启用户分析</strong><span>。</span></span></span></span></span></span></span></p>\n<p class=\"paragraph text-align-type-justify\">&nbsp;</p>\n<hr />\n<p class=\"paragraph text-align-type-justify\"><span><span><span><span><span><span><span><img alt=\"WechatIMG422\" class=\"lazyload\" height=\"253\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"556\" /></span></span></span></span></span></span></span></p>\n<p class=\"paragraph text-align-type-justify\"><img alt=\"WechatIMG17078\" class=\"lazyload\" height=\"218\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"683\" /></p>\n<p>&nbsp;</p>\n<p class=\"paragraph text-align-type-left\"><span lang=\"EN-US\">&nbsp;</span></p>\n</div>\n</div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-09 16:35</span>&nbsp;\n<a href=\"https://www.cnblogs.com/clklog\">ClkLog</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Qt技术笔记（八）：QCheckBox 多选框笔记",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19596076",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19596076\" id=\"cb_post_title_url\" title=\"发布于 2026-02-09 16:27\">\n    <span>Qt技术笔记（八）：QCheckBox 多选框笔记</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"qt技术笔记八qcheckbox-多选框笔记\">Qt技术笔记（八）：QCheckBox 多选框笔记</h1>\n<p>​        Qt 是一个跨平台C++图形界面开发库，利用Qt可以快速开发窗体的应用程序，在Qt中我们需要可以通过拖拽的方式将不同组件放在指定的位置，实现图形开发极大的方便了开发效率，本章将重工点介绍<code>QCheckBox</code> 多选框组件的常用方法及灵活的运用。</p>\n<p>​        首先，你需要调用包含Qt框架中与QCheckBox相关的头文件：</p>\n<pre><code class=\"language-c++\">#include &lt;QCheckBox&gt;\n</code></pre>\n<h2 id=\"1控件简介及常用方法接口\">1.控件简介及常用方法接口</h2>\n<p>​         <code>QCheckBox</code>是Qt中用于实现复选框的组件，它提供了丰富的功能和灵活性。与<code>RadiButton</code>组件不同，<code>CheckBox</code>组件支持多项选择以及三态选择，即可以是选中、未选中或半选中的状态。下面是<code>QCheckBox</code>的主要方法的概述和功能：</p>\n<table>\n<thead>\n<tr>\n<th>方法接口</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>QCheckBox(QWidget *parent = nullptr)</code></td>\n<td>构造函数，创建一个 <code>QCheckBox</code> 组件。</td>\n</tr>\n<tr>\n<td><code>isChecked() const</code></td>\n<td>返回复选框的当前状态，选中返回<code>true</code>,否则返回 <code>false</code></td>\n</tr>\n<tr>\n<td><code>setCheckState(Qt::CheckState state)</code></td>\n<td>设置复选框的状态，可以是<code>Qt::Unchecked</code>、<code>Qt::PartiallyChecked</code> 或 <code>Qt::Checked</code>。</td>\n</tr>\n<tr>\n<td><code>checkState() const</code></td>\n<td>返回复选框的当前状态，枚举类型 <code>Qt::CheckState</code>。</td>\n</tr>\n<tr>\n<td><code>setTristate(bool)</code></td>\n<td>启用或禁用三态复选框的功能。</td>\n</tr>\n<tr>\n<td><code>isTristate() const</code></td>\n<td>返回是否启用了三态复选框的功能。</td>\n</tr>\n<tr>\n<td><code>setCheckable(bool checkable)</code></td>\n<td>设置复选框是否可以被选中，<code>true</code> 表示可以选中，<code>false</code> 表示不能选中。</td>\n</tr>\n<tr>\n<td><code>isChecked() const</code></td>\n<td>返回复选框的当前状态，选中返回 <code>true</code>，否则返回 <code>false</code>。</td>\n</tr>\n<tr>\n<td><code>setChecked(bool check)</code></td>\n<td>设置复选框的状态，true 表示选中，false 表示未选中。</td>\n</tr>\n<tr>\n<td><code>text() const</code></td>\n<td>返回复选框的文本标签。</td>\n</tr>\n<tr>\n<td><code>setText(const QString &amp;text)</code></td>\n<td>设置复选框的文本标签。</td>\n</tr>\n<tr>\n<td><code>stateChanged(int)</code></td>\n<td>复选框状态变化时发射的信号，参数是枚举类型 <code>Qt::CheckState</code>，可以是 <code>Qt::Unchecked</code>、<code>Qt::PartiallyChecked</code> 或<code> Qt::Checked</code>。</td>\n</tr>\n</tbody>\n</table>\n<p>其中重要的数据类型中：<code>Qt::CheckState</code>的枚举类型 反映<code>QCheckBox</code>的选中状态：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">枚举值</th>\n<th style=\"text-align: center;\">值</th>\n<th style=\"text-align: center;\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\"><code>Qt::Unchecked</code></td>\n<td style=\"text-align: center;\">0</td>\n<td style=\"text-align: center;\">未选中</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><code>Qt::PartiallyChecked</code></td>\n<td style=\"text-align: center;\">1</td>\n<td style=\"text-align: center;\">半选中</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"><code>Qt::Checked</code></td>\n<td style=\"text-align: center;\">2</td>\n<td style=\"text-align: center;\">选中</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"创建qcheckbox\"><strong>创建QCheckBox</strong></h3>\n<p>你可以通过以下方式创建一个<code>QCheckBox</code>对象：</p>\n<pre><code class=\"language-C++\">QCheckBox *checkBox = new QCheckBox(\"Check me\", this); // \"Check me\" 是复选框旁边的文本\n</code></pre>\n<h3 id=\"设置和获取状态\"><strong>设置和获取状态</strong></h3>\n<p>你可以设置复选框的状态（选中或未选中）：</p>\n<pre><code class=\"language-c++\">checkBox-&gt;setChecked(true); // 设置复选框为选中状态\n</code></pre>\n<h3 id=\"获取复选框的状态\"><strong>获取复选框的状态：</strong></h3>\n<pre><code class=\"language-c++\">bool isChecked = checkBox-&gt;isChecked(); // 返回复选框是否被选中\n</code></pre>\n<h3 id=\"信号与槽\"><strong>信号与槽</strong></h3>\n<p><code>QCheckBox</code>提供了一个信号<code>stateChanged</code>，当复选框的状态改变时，这个信号会被触发。你可以连接这个信号到一个槽函数来响应状态的改变：</p>\n<pre><code class=\"language-C++\">\nconnect(checkBox, &amp;QCheckBox::stateChanged, this, &amp;YourClass::onCheckBoxStateChanged);\n\nvoid YourClass::onCheckBoxStateChanged(int state) {\n    if (state == Qt::Checked) {\n        // 复选框被选中时的逻辑\n    } else {\n        // 复选框未被选中时的逻辑\n    }\n}\n</code></pre>\n<h3 id=\"自定义样式\"><strong>自定义样式</strong></h3>\n<p>你还可以通过样式表（<code>StyleSheet</code>）来自定义QCheckBox的外观：</p>\n<pre><code class=\"language-C++\">checkBox-&gt;setStyleSheet(\"QCheckBox::indicator { width: 13px; height: 13px; }\")\n</code></pre>\n<h3 id=\"将qcheckbox添加入布局中\"><strong>将QCheckBox添加入布局中</strong></h3>\n<p>在Qt中，通常会将控件放入布局管理器中，以便于管理控件的位置和大小。例如，将QCheckBox放入水平布局：</p>\n<pre><code class=\"language-C++\">QHBoxLayout *layout = new QHBoxLayout;\nlayout-&gt;addWidget(checkBox);\n</code></pre>\n<h2 id=\"2代码示例\">2.代码示例</h2>\n<p>下面是一个简单的示例，展示了如何在Qt中使用<code>QCheckBox</code>：</p>\n<pre><code class=\"language-c++\">\n#include &lt;QApplication&gt;\n#include &lt;QWidget&gt;\n#include &lt;QCheckBox&gt;\n#include &lt;QVBoxLayout&gt;\n\nclass MainWindow : public QWidget {\npublic:\n    MainWindow() {\n        QCheckBox *checkBox = new QCheckBox(\"Check me\", this);\n        connect(checkBox, &amp;QCheckBox::stateChanged, this, &amp;MainWindow::onCheckBoxStateChanged);\n\n        QVBoxLayout *layout = new QVBoxLayout(this);\n        layout-&gt;addWidget(checkBox);\n    }\n\n    void onCheckBoxStateChanged(int state) {\n        if (state == Qt::Checked) {\n            qDebug() &lt;&lt; \"CheckBox is checked\";\n        } else {\n            qDebug() &lt;&lt; \"CheckBox is unchecked\";\n        }\n    }\n};\n\nint main(int argc, char *argv[]) {\n    QApplication app(argc, argv);\n    MainWindow window;\n    window.show();\n    return app.exec();\n}\n</code></pre>\n<p>这个示例创建了一个主窗口，其中包含一个复选框，并且当复选框的状态改变时，会在控制台输出相应的信息。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-09 16:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "STM32移植Freertos",
      "link": "https://www.cnblogs.com/tianwuyvlianshui/p/19595818",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tianwuyvlianshui/p/19595818\" id=\"cb_post_title_url\" title=\"发布于 2026-02-09 16:23\">\n    <span>STM32移植Freertos</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"stm32移植freertos\">STM32移植Freertos</h1>\n<p>1、<a href=\"https://www.freertos.org/\" rel=\"noopener nofollow\" target=\"_blank\">FreeRTOS™ - FreeRTOS™</a>官网下载源码</p>\n<p>解压后</p>\n<p>FreeRTOSv202406.04-LTS\\FreeRTOS-LTS\\FreeRTOS\\FreeRTOS-Kernel</p>\n<p>仅保留FreeRTOS-Kernel文件夹下文件</p>\n<p>仅保留选中文件</p>\n<img alt=\"image-20260209155954469\" src=\"https://img2024.cnblogs.com/blog/3281938/202602/3281938-20260209162033411-122786812.png\" />\n<p>工程中添加Freertos组</p>\n<img alt=\"image-20260209160315005\" src=\"https://img2024.cnblogs.com/blog/3281938/202602/3281938-20260209162033934-1694543803.png\" />\n<p>添加头文件路径</p>\n<img alt=\"image-20260209160511282\" src=\"https://img2024.cnblogs.com/blog/3281938/202602/3281938-20260209162035161-1019099274.png\" />\n<pre><code>FreeRTOSv202406.04-LTS\\FreeRTOS-LTS\\FreeRTOS\\FreeRTOS-Kernel\\includeFreeRTOSv202406.04-LTS\\FreeRTOS-LTS\\FreeRTOS\\FreeRTOS-Kernel\\include\n</code></pre>\n<p>将.c文件添加进工程文件夹中</p>\n<img alt=\"image-20260209160542821\" src=\"https://img2024.cnblogs.com/blog/3281938/202602/3281938-20260209162035776-1141808955.png\" />\n<img alt=\"image-20260209160718395\" src=\"https://img2024.cnblogs.com/blog/3281938/202602/3281938-20260209162036683-2043991686.png\" />\n<p>根据所移植目标芯片选择内核文件（stm32f103，选择ARM_CM3）,将文件夹内文件添加至工程</p>\n<img alt=\"image-20260209160803456\" src=\"https://img2024.cnblogs.com/blog/3281938/202602/3281938-20260209162037232-2022932846.png\" />\n<p>将FreeRTOSv202406.04-LTS\\FreeRTOS-LTS\\FreeRTOS\\FreeRTOS-Kernel\\examples\\template_configuration</p>\n<p>FreeRTOSConfig.h文件添加至工程</p>\n<img alt=\"image-20260209161135199\" src=\"https://img2024.cnblogs.com/blog/3281938/202602/3281938-20260209162037791-498391128.png\" />\n<p>根据所需功能，开启宏定义</p>\n<p>打开stm32f10x_it.c/.h文件，注释三个中断函数（确保不会重定义，同时让freertos接管中断）</p>\n<img alt=\"image-20260209161330432\" src=\"https://img2024.cnblogs.com/blog/3281938/202602/3281938-20260209162038548-614449608.png\" />\n<p><img alt=\"image-20260209161449861\" src=\"https://img2024.cnblogs.com/blog/3281938/202602/3281938-20260209162030294-822227562.png\" /></p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>SVC_Handler</code></td>\n<td>Supervisor Call（软件中断）处理，用于操作系统调用或异常</td>\n</tr>\n<tr>\n<td><code>PendSV_Handler</code></td>\n<td>挂起中断，用于任务切换（Context Switch）</td>\n</tr>\n<tr>\n<td><code>SysTick_Handler</code></td>\n<td>系统滴答定时器中断，通常用于系统节拍计数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2️⃣-freertos-对这些函数的要求\">2️⃣ FreeRTOS 对这些函数的要求</h2>\n<p>FreeRTOS 核心任务调度依赖 <strong>SysTick、PendSV、SVC</strong>：</p>\n<ol>\n<li><strong>SysTick_Handler</strong>\n<ul>\n<li>FreeRTOS 使用它作为 <strong>节拍中断（tick）</strong></li>\n<li>用于管理任务延时、任务切换计时等</li>\n</ul>\n</li>\n<li><strong>PendSV_Handler</strong>\n<ul>\n<li>FreeRTOS 用它实现 <strong>任务切换</strong></li>\n<li>在 PendSV 中切换任务上下文（寄存器、栈指针）</li>\n</ul>\n</li>\n<li><strong>SVC_Handler</strong>\n<ul>\n<li>FreeRTOS 可能用它初始化第一个任务（<code>vPortSVCHandler</code>）</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>如果 startup 文件里有原始弱符号的这几个函数，它们可能与 FreeRTOS 自己实现的 <strong>vPortXXX_Handler</strong> 冲突。</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>不要删除</strong>这些函数，只是注释掉或确保 FreeRTOS 的实现覆盖它们</p>\n</li>\n<li>\n<p>如果你不移植 FreeRTOS，用系统默认空实现即可</p>\n</li>\n<li>\n<p>FreeRTOS 的 <code>port.c</code> 里有宏：</p>\n<pre><code>#define vPortSVCHandler   SVC_Handler\n#define xPortPendSVHandler PendSV_Handler\n#define xPortSysTickHandler SysTick_Handler\n</code></pre>\n<p>链接器会把中断向量表自动指向 FreeRTOS 的处理函数</p>\n</li>\n</ul>\n<p><strong>总结一句话</strong>：</p>\n<blockquote>\n<p>注释这三个默认函数，是为了让 FreeRTOS 自己实现的 SVC/PendSV/SysTick 处理函数覆盖系统默认空函数，从而实现正确的任务调度和系统节拍。</p>\n</blockquote>\n<p>测试代码</p>\n<pre><code class=\"language-c\">#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"timers.h\"\n#include \"queue.h\"\n#include \"stream_buffer.h\"\n#include \"semphr.h\"\n \n//创建队列句柄\nQueueHandle_t Queue_Data_Handle;\n#define queue_data_length 10\n \n//宏定义 send_task\nBaseType_t retA;\t\t\nTaskHandle_t Pt_send_Task_TaskHandle;\nvoid queue_sned_Task(void *p);\n#define Sned_Task_Name \t\t  \"queue_send\"\n#define Sned_Task_StackD  \t\t128\n#define Sned_Task_Priority\t\t1\n \n//宏定义 rece_task\nBaseType_t retB;\nTaskHandle_t Pt_rece_Task_TaskHandle;\nvoid queue_receive_Task(void *p);\n#define Rece_Task_Name \t\t  \"queue_rece\"\n#define Rece_Task_StackD  \t\t128\n#define Rece_Task_Priority\t\t1\n \n u8 i,j;\nvoid queue_send_Task(void *p)\n{\t\n\tuint32_t send_value = 0;\n\twhile(1)\n\t{    i++;\n\t\t\tvTaskDelay(1000);\n\t}\n}\n \nvoid queue_receive_Task(void *p)\n{\n\tuint32_t rece_value = 0;\n\twhile(1)\n\t{\n        j++;\n\t\t\tvTaskDelay(1000);\n\n\t}\n}\n \nint main(void)\n{\n\tNVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);\n//\tDebug_Init(115200);\n\t\n\t/*创建队列 注意队列长度 和 数据字节大小*/\n\tQueue_Data_Handle = xQueueCreate(queue_data_length,  //队列长度\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(uint32_t));  //单个数据大小四字节\n\t\t\t\t\t\t\t\t\t\n\t/*创建发送任务*/\n\tretA = xTaskCreate(\t(TaskFunction_t)    queue_send_Task,\n\t\t\t\t\t\t\t\t\t\t\t(const char *)Sned_Task_Name,\n\t\t\t\t\t\t\t\t\t\t\t(uint16_t)Sned_Task_StackD,\n\t\t\t\t\t\t\t\t\t\t\t(void *)NULL,\n\t\t\t\t\t\t\t\t\t\t\t(UBaseType_t)Sned_Task_Priority,\n\t\t\t\t\t\t\t\t\t\t\t(TaskHandle_t *)&amp;Pt_send_Task_TaskHandle);\n\t/*创建接收任务*/\n\tretA = xTaskCreate(\t(TaskFunction_t)    queue_receive_Task,\n\t\t\t\t\t\t\t\t\t\t\t(const char *)Rece_Task_Name,\n\t\t\t\t\t\t\t\t\t\t\t(uint16_t)Rece_Task_StackD,\n\t\t\t\t\t\t\t\t\t\t\t(void *)NULL,\n\t\t\t\t\t\t\t\t\t\t\t(UBaseType_t)Rece_Task_Priority,\n\t\t\t\t\t\t\t\t\t\t\t(TaskHandle_t *)&amp;Pt_rece_Task_TaskHandle);\n\t/*开始调度*/\n\tvTaskStartScheduler();\n\t/*不会执行到这里*/\n\twhile (1) {\t\t\n\t\t;\n\t}\n}\n</code></pre>\n<p>将断点打在</p>\n<img alt=\"image-20260209161756545\" src=\"https://img2024.cnblogs.com/blog/3281938/202602/3281938-20260209162039155-1767657262.png\" />\n<p>进入Debuge，全速运行，看是否两个断点都能进入，编译无报错，能进入，则移植成功</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-09 16:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tianwuyvlianshui\">沁拒离</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "C# 如何将 TXT 文本转换为 PDF",
      "link": "https://www.cnblogs.com/jazz-z/p/19595932",
      "published": "",
      "description": "<div class=\"postcontent\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在日常开发和办公场景中，将纯文本（TXT）文件转换为 PDF 格式是一项常见需求。PDF 格式具备跨平台、样式固定、不易被篡改等特点，而 TXT 格式则更侧重于内容的轻量存储。二者之间的转换可以兼顾内容的可读性与文档的规范性与便携性。本文将介绍如何通过 C# 和免费的 .NET 类库实现 TXT 到 PDF 的高效转换。</p>\n<h2 id=\"一环境准备\">一、环境准备</h2>\n<h3 id=\"1-核心库简介\">1. 核心库简介</h3>\n<p><strong>Free Spire.PDF for .NET</strong> 是一个功能丰富的免费 PDF 操作库，支持 PDF 文档的创建、编辑、合并、转换等基础功能。免费版本对部分高级功能或处理规模有一定限制（例如单次转换的页数上限），但对于常规的 TXT 转 PDF 任务完全够用。</p>\n<h3 id=\"2-环境配置\">2. 环境配置</h3>\n<ul>\n<li><strong>开发环境</strong>：Visual Studio 2022 或更高版本，或其他支持 .NET 的 IDE。</li>\n<li><strong>库安装</strong>：通过 NuGet 包管理器安装 <strong>FreeSpire.PDF</strong>。可在程序包管理器控制台中执行以下命令：<pre><code class=\"language-bash\">Install-Package FreeSpire.PDF\n</code></pre>\n</li>\n</ul>\n<h2 id=\"二txt-转-pdf-实现步骤\">二、TXT 转 PDF 实现步骤</h2>\n<p>转换过程可归纳为以下核心步骤：</p>\n<ol>\n<li>读取 TXT 文件内容</li>\n<li>创建 PDF 文档与页面</li>\n<li>设置文本字体与样式</li>\n<li>定义文本布局与格式</li>\n<li>将文本绘制到 PDF 并保存</li>\n</ol>\n<h3 id=\"完整实现代码\">完整实现代码</h3>\n<pre><code class=\"language-csharp\">using Spire.Pdf;\nusing Spire.Pdf.Graphics;\nusing System.Drawing;\nusing System.IO;\n\nnamespace ConvertTextToPdf\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            try\n            {\n                // 1. 读取 TXT 文件内容（建议指定编码，避免乱码）\n                string txtFilePath = @\"Input.txt\";\n                string textContent = File.ReadAllText(txtFilePath, System.Text.Encoding.UTF8);\n\n                // 2. 创建 PDF 文档并添加 A4 页面\n                PdfDocument pdfDocument = new PdfDocument();\n                PdfPageBase pdfPage = pdfDocument.Pages.Add();\n\n                // 3. 设置字体（字体名称、大小、样式）\n                PdfTrueTypeFont pdfFont = new PdfTrueTypeFont(\"宋体\", 18f, PdfFontStyle.Bold, true);\n\n                // 4. 设置文本布局\n                PdfTextLayout textLayout = new PdfTextLayout();\n                textLayout.Break = PdfLayoutBreakType.FitPage; // 内容适配页面\n                textLayout.Layout = PdfLayoutType.Paginate;    // 超出自动分页\n\n                // 5. 设置文本格式\n                PdfStringFormat textFormat = new PdfStringFormat();\n                textFormat.Alignment = PdfTextAlignment.Justify; // 两端对齐\n                textFormat.LineSpacing = 20f;                    // 行间距\n\n                // 6. 创建文本绘制组件\n                PdfTextWidget textWidget = new PdfTextWidget(textContent, pdfFont, PdfBrushes.Black);\n                textWidget.StringFormat = textFormat;\n\n                // 7. 定义绘制区域（预留页边距）\n                RectangleF renderBounds = new RectangleF(\n                    new PointF(10, 25),\n                    new SizeF(pdfPage.Canvas.ClientSize.Width - 20, pdfPage.Canvas.ClientSize.Height - 30)\n                );\n\n                // 8. 将文本绘制到 PDF 页面\n                textWidget.Draw(pdfPage, renderBounds, textLayout);\n\n                // 9. 保存为 PDF 文件\n                pdfDocument.SaveToFile(\"TextToPdf.pdf\", FileFormat.PDF);\n\n                // 释放资源\n                pdfDocument.Close();\n                Console.WriteLine(\"转换完成，PDF 已保存。\");\n            }\n            catch (IOException ex)\n            {\n                Console.WriteLine(\"文件读写异常：\" + ex.Message);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"转换过程中出现错误：\" + ex.Message);\n            }\n        }\n    }\n}\n</code></pre>\n<h3 id=\"关键代码说明\">关键代码说明</h3>\n<ol>\n<li>\n<p><strong>读取 TXT 内容</strong><br />\n使用 <code>File.ReadAllText</code> 并明确指定编码（如 UTF-8），可避免因系统默认编码不同而导致的中文乱码问题。</p>\n</li>\n<li>\n<p><strong>创建 PDF 页面</strong><br />\n<code>PdfDocument.Pages.Add()</code> 默认添加 A4 尺寸的页面。可通过重载方法自定义页面尺寸，例如 <code>PdfPageSize.A3</code>。</p>\n</li>\n<li>\n<p><strong>文本样式与布局配置</strong></p>\n<ul>\n<li><strong>字体</strong>：<code>PdfTrueTypeFont</code> 支持系统中已安装的 TrueType 字体。</li>\n<li><strong>布局</strong>：<code>PdfTextLayout</code> 的 <code>Paginate</code> 属性确保文本超出当前页面时自动分页。</li>\n<li><strong>格式</strong>：<code>PdfStringFormat</code> 可设置对齐方式、行间距等，提升排版效果。</li>\n<li><strong>绘制区域</strong>：通过 <code>RectangleF</code> 设置文本绘制范围，并预留边距使文档更美观。</li>\n</ul>\n</li>\n<li>\n<p><strong>绘制与保存</strong><br />\n<code>PdfTextWidget</code> 负责将文本内容与样式绑定，并通过 <code>Draw</code> 方法渲染到 PDF 页面。最后调用 <code>SaveToFile</code> 保存文件。</p>\n</li>\n</ol>\n<hr />\n<p>本文演示的 C# 实现方案，通过 <strong>Free Spire.PDF for .NET</strong> 库，以少量代码完成了 TXT 到 PDF 的转换。该方法无需依赖 Office 或第三方命令行工具，适合集成到中小型 .NET 项目中，满足日常文档格式转换的基本需求。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"itemdesc\">\n                发表于 \n<span id=\"post-date\">2026-02-09 16:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jazz-z\">LAYONTHEGROUND</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n            </div>"
    },
    {
      "title": "OpenClaw for macOS: 完整本地化部署指南（2026.2.6-3 版本）",
      "link": "https://www.cnblogs.com/xiaobaiysf/p/19595515",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaobaiysf/p/19595515\" id=\"cb_post_title_url\" title=\"发布于 2026-02-09 15:06\">\n    <span>OpenClaw for macOS: 完整本地化部署指南（2026.2.6-3 版本）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"OpenClaw for macOS: 完整本地化部署指南（2026.2.6-3 版本）\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3600464/202602/3600464-20260209150457965-1453431698.png\" />\n        基于Mac环境安装 OpenClaw ，构建你的个人AI助理！\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"一文档说明\">一、文档说明</h1>\n<p>本文档面向 macOS 系统用户，从<strong>基础环境搭建（Node.js 安装）</strong> 到 <strong>OpenClaw 完整部署</strong>，再到问题排查、残余清理，提供全流程标准化操作，适配 OpenClaw 2026.2.6-3 版本，最终实现 DeepSeek 模型的稳定调用。</p>\n<h1 id=\"二部署前置条件\">二、部署前置条件</h1>\n<h2 id=\"1-系统要求\">1. 系统要求</h2>\n<ul>\n<li>\n<p>操作系统：macOS 10.15+（本文以 MacBook Air (M系列/Intel) 为例）</p>\n</li>\n<li>\n<p>权限：拥有终端管理员权限（可执行 <code>sudo</code> 命令）</p>\n</li>\n<li>\n<p>网络：能正常访问 DeepSeek API（国内网络直接支持）</p>\n</li>\n</ul>\n<h2 id=\"2-预期成果\">2. 预期成果</h2>\n<ul>\n<li>\n<p>完成 Node.js 环境搭建（v24.13.0 及以上）；</p>\n</li>\n<li>\n<p>OpenClaw 网关正常启动，端口 18789 可访问；</p>\n</li>\n<li>\n<p>OpenClaw UI 能调用 DeepSeek 模型并返回对话结果。</p>\n</li>\n</ul>\n<h1 id=\"三基础环境搭建nodejs-安装\">三、基础环境搭建（Node.js 安装）</h1>\n<p>OpenClaw 基于 Node.js 运行，需先完成 Node.js 安装与版本验证。</p>\n<h3 id=\"步骤1安装-homebrewmacos-包管理器推荐\">步骤1：安装 Homebrew（macOS 包管理器，推荐）</h3>\n<p>若已安装 Homebrew，跳过此步骤；未安装则执行：</p>\n<pre><code class=\"language-Bash\">\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre>\n<p>✅ 验证安装：</p>\n<pre><code class=\"language-Bash\">\nbrew -v\n</code></pre>\n<p>输出 <code>Homebrew 4.x.x</code> 即安装成功。</p>\n<h3 id=\"步骤2安装-nodejs\">步骤2：安装 Node.js</h3>\n<p>通过 Homebrew 安装稳定版 Node.js（自动适配 v24+）：</p>\n<pre><code class=\"language-Bash\">\nbrew install node\n</code></pre>\n<p>✅ 验证安装与版本：</p>\n<pre><code class=\"language-Bash\">\n# 查看 Node.js 版本\nnode -v\n# 查看 npm 版本（Node.js 自带）\nnpm -v\n</code></pre>\n<ul>\n<li>\n<p>✅ 输出 <code>node v24.13.0</code> 及以上、<code>npm 10.x.x</code> 即符合要求；</p>\n</li>\n<li>\n<p>❌ 若版本过低，执行 <code>brew upgrade node</code> 升级。</p>\n</li>\n</ul>\n<h3 id=\"步骤3配置-npm-全局路径可选避免权限报错\">步骤3：配置 npm 全局路径（可选，避免权限报错）</h3>\n<pre><code class=\"language-Bash\">\n# 创建全局目录\nmkdir -p ~/.npm-global\n# 配置 npm 全局路径\nnpm config set prefix '~/.npm-global'\n# 将全局路径加入环境变量（永久生效）\necho 'export PATH=~/.npm-global/bin:$PATH' &gt;&gt; ~/.zshrc\n# 生效环境变量\nsource ~/.zshrc\n</code></pre>\n<p>✅ 验证配置：</p>\n<pre><code class=\"language-Bash\">\nnpm config get prefix\n</code></pre>\n<p>输出 <code>~/.npm-global</code> 即配置成功。</p>\n<h2 id=\"四openclaw-完整部署流程\">四、OpenClaw 完整部署流程</h2>\n<h3 id=\"步骤1安装-openclaw-包\">步骤1：安装 OpenClaw 包</h3>\n<p>通过 npm 全局安装 OpenClaw：</p>\n<pre><code class=\"language-Bash\">\nnpm install -g openclaw\n</code></pre>\n<p>✅ 验证安装路径：</p>\n<pre><code class=\"language-Bash\">\nls ~/.npm-global/lib/node_modules/openclaw\n</code></pre>\n<p>输出 OpenClaw 相关文件（如 <code>dist</code>、<code>package.json</code>）即安装成功。</p>\n<h3 id=\"步骤2openclaw-配置文件初始化与修改\">步骤2：OpenClaw 配置文件初始化与修改</h3>\n<p>OpenClaw 核心配置文件为 <code>~/.openclaw/openclaw.json</code>，需确保语法合法且适配 DeepSeek 模型。</p>\n<h4 id=\"21-初始化配置目录首次部署\">2.1 初始化配置目录（首次部署）</h4>\n<pre><code class=\"language-Bash\">\nmkdir -p ~/.openclaw\n</code></pre>\n<h4 id=\"22-备份原有配置若有\">2.2 备份原有配置（若有）</h4>\n<pre><code class=\"language-Bash\">\nif [ -f ~/.openclaw/openclaw.json ]; then\n  mkdir -p ~/.openclaw/backup\n  cp ~/.openclaw/openclaw.json ~/.openclaw/backup/openclaw.json.bak\nfi\n</code></pre>\n<h4 id=\"23-写入适配-deepseek-的无错配置核心\">2.3 写入适配 DeepSeek 的无错配置（核心）</h4>\n<p>执行以下命令，直接写入预验证的合法配置（替换占位符为真实信息）：</p>\n<pre><code class=\"language-Bash\">\ncat &gt; ~/.openclaw/openclaw.json &lt;&lt; 'EOF'\n{\n  \"meta\": {\n    \"lastTouchedVersion\": \"2026.2.6-3\",\n    \"lastTouchedAt\": \"2026-02-08T07:43:20.228Z\"\n  },\n  \"models\": {\n    \"mode\": \"merge\",\n    \"providers\": {\n      \"deepseek\": {\n        \"baseUrl\": \"https://api.deepseek.com/v1\",\n        \"apiKey\": \"你的DeepSeek API Key\", // 替换为真实Key（格式：sk-xxxx）\n        \"api\": \"openai-completions\",\n        \"models\": [\n          {\n            \"id\": \"deepseek-chat\",\n            \"name\": \"DeepSeek Chat\",\n            \"input\": [\"text\"],\n            \"contextWindow\": 128000,\n            \"maxTokens\": 8192,\n            \"reasoning\": false\n          }\n        ]\n      }\n    }\n  },\n  \"agents\": {\n    \"defaults\": {\n      \"workspace\": \"/Users/你的用户名/.openclaw/workspace\", // 替换为实际用户名（如 zhufeige）\n      \"maxConcurrent\": 4,\n      \"subagents\": {\n        \"maxConcurrent\": 8\n      },\n      \"model\": {\n        \"primary\": \"deepseek/deepseek-chat\" // 指定默认调用 DeepSeek 模型\n      }\n    }\n  },\n  \"gateway\": {\n    \"port\": 18789,\n    \"mode\": \"local\",\n    \"auth\": {\n      \"mode\": \"token\",\n      \"token\": \"39769ded65eac493eceeb0fb6a543fb48ed4fce3f1166bf5\" // 替换个人生成的此值即可\n    }\n  }\n}\nEOF\n</code></pre>\n<h4 id=\"24-配置文件修改说明\">2.4 配置文件修改说明</h4>\n<ul>\n<li>\n<p>替换 <code>你的DeepSeek API Key</code>：从 <a href=\"https://platform.deepseek.com/\" rel=\"noopener nofollow\" target=\"_blank\">DeepSeek 控制台</a> 获取，格式为 <code>sk-xxxx</code>；</p>\n</li>\n<li>\n<p>替换 <code>你的用户名</code>：macOS 用户名可通过 <code>whoami</code> 命令查看（终端执行 <code>whoami</code> 即可输出）；</p>\n</li>\n<li>\n<p>生成并打印OpenClaw的token</p>\n</li>\n</ul>\n<pre><code>node ~/.npm-global/lib/node_modules/openclaw/openclaw.mjs gateway token --print\n</code></pre>\n<h4 id=\"25-配置语法验证必做避免启动报错\">2.5 配置语法验证（必做，避免启动报错）</h4>\n<pre><code class=\"language-Bash\">\nnode -e \"JSON.parse(require('fs').readFileSync('/Users/$(whoami)/.openclaw/openclaw.json', 'utf8'))\"\n</code></pre>\n<ul>\n<li>\n<p>✅ 终端无任何输出 → 语法完全正确；</p>\n</li>\n<li>\n<p>❌ 若报错：检查是否有全角字符（如 <code>：</code>/<code>，</code>）、多余/缺失的 <code>{}</code>/<code>,</code>/<code>\"</code>。</p>\n</li>\n</ul>\n<h4 id=\"26-修复配置权限\">2.6 修复配置权限</h4>\n<pre><code class=\"language-Bash\">\nnode ~/.npm-global/lib/node_modules/openclaw/openclaw.mjs doctor --fix\n</code></pre>\n<p>✅ 输出无 <code>Config validation failed</code> 即权限修复成功。</p>\n<h3 id=\"步骤3启动-openclaw-网关\">步骤3：启动 OpenClaw 网关</h3>\n<h4 id=\"31-清理残余进程避免端口冲突\">3.1 清理残余进程（避免端口冲突）</h4>\n<pre><code class=\"language-Bash\">\n# 方法1：OpenClaw 官方停止命令\nopenclaw gateway stop\n\n# 方法2：强制杀死所有 OpenClaw 进程（推荐）\npkill -f openclaw\n\n# 方法3：杀死占用 18789 端口的进程（若端口被占用）\nlsof -i :18789 | grep -v PID | awk '{print $2}' | xargs kill -9 2&gt;/dev/null\n</code></pre>\n<h4 id=\"32-启动网关指定端口并强制重载\">3.2 启动网关（指定端口并强制重载）</h4>\n<pre><code class=\"language-Bash\">\nnode ~/.npm-global/lib/node_modules/openclaw/openclaw.mjs gateway --port 18789 --force\n</code></pre>\n<p>✅ 终端输出以下内容即启动成功：</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"步骤4验证部署效果\">步骤4：验证部署效果</h3>\n<h4 id=\"41-实时监控运行日志\">4.1 实时监控运行日志</h4>\n<p>打开新终端窗口，执行以下命令跟踪日志（排查问题关键）：</p>\n<pre><code class=\"language-Bash\">\ntail -f /tmp/openclaw/openclaw-$(date +%Y-%m-%d).log\n</code></pre>\n<ul>\n<li>\n<p>无 <code>error</code>/<code>invalid config</code> 关键字 → 运行正常；</p>\n</li>\n<li>\n<p>若出现 <code>API request failed</code> → 检查 DeepSeek API Key 是否有效。</p>\n</li>\n</ul>\n<h4 id=\"42-访问-openclaw-ui-测试对话\">4.2 访问 OpenClaw UI 测试对话</h4>\n<ol>\n<li>打开浏览器，访问 <code>http://127.0.0.1:18789</code>；</li>\n</ol>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<ol start=\"2\">\n<li>\n<p>在输入框发送测试消息（如「test」或「你好」）；</p>\n</li>\n<li>\n<p>✅ 收到 DeepSeek 回复 → 部署完全成功；</p>\n</li>\n<li>\n<p>❌ 无回复：执行以下命令验证 API Key 有效性：</p>\n<pre><code class=\"language-Bash\">\ncurl -s -X POST https://api.deepseek.com/v1/chat/completions \\\n  -H \"Authorization: Bearer 你的DeepSeek API Key\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"model\":\"deepseek-chat\",\"messages\":[{\"role\":\"user\",\"content\":\"test\"}]}'\n</code></pre>\n<ul>\n<li>\n<p>输出包含 <code>\"content\"</code> 字段 → API Key 有效，重启网关即可；</p>\n</li>\n<li>\n<p>输出 <code>Unauthorized</code> → API Key 无效，重新从 DeepSeek 控制台生成。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"五常见问题排查\">五、常见问题排查</h1>\n<h2 id=\"问题1nodejs-安装失败\">问题1：Node.js 安装失败</h2>\n<ul>\n<li>\n<p>原因：网络问题导致 Homebrew 下载失败；</p>\n</li>\n<li>\n<p>解决：切换国内源安装 Node.js：</p>\n<pre><code class=\"language-Bash\">\n# 配置 npm 国内源\nnpm config set registry https://registry.npmmirror.com\n# 直接通过 npm 安装 Node.js\nnpm install -g n\nn 24.13.0\n</code></pre>\n</li>\n</ul>\n<h2 id=\"问题2json-语法错误如-invalid-character-\">问题2：JSON 语法错误（如 <code>invalid character ':'</code>）</h2>\n<ul>\n<li>\n<p>原因：配置文件存在格式错误（全角字符、多余符号）；</p>\n</li>\n<li>\n<p>解决：直接重新执行步骤2.3 的配置写入命令，避免手动修改格式。</p>\n</li>\n</ul>\n<h2 id=\"问题3端口冲突gateway-already-running-locally\">问题3：端口冲突（<code>Gateway already running locally</code>）</h2>\n<ul>\n<li>\n<p>原因：18789 端口被占用，或 OpenClaw 进程未彻底停止；</p>\n</li>\n<li>\n<p>解决：执行步骤3.1 的进程清理命令，或更换启动端口（如 <code>--port 18788</code>）。</p>\n</li>\n</ul>\n<h2 id=\"问题4ui-无对话反馈网关启动正常\">问题4：UI 无对话反馈（网关启动正常）</h2>\n<ul>\n<li>原因1：未指定默认模型（<code>agents.defaults.model.primary</code> 缺失）；</li>\n</ul>\n<p>解决：确保配置中包含 <code>\"primary\": \"deepseek/deepseek-chat\"</code>；</p>\n<ul>\n<li>原因2：API Key 无效/过期；</li>\n</ul>\n<p>解决：重新从 DeepSeek 控制台生成 Key 并替换配置；</p>\n<ul>\n<li>原因3：配置包含冗余字段（<code>wizard</code>/<code>messages</code>/<code>commands</code>）；</li>\n</ul>\n<p>解决：删除冗余字段，仅保留步骤2.3 中的核心配置。</p>\n<h2 id=\"问题5docker-容器名称冲突container-name-already-in-use\">问题5：Docker 容器名称冲突（<code>container name already in use</code>）</h2>\n<ul>\n<li>\n<p>原因：1Panel 部署的 OpenClaw 容器未删除；</p>\n</li>\n<li>\n<p>解决：</p>\n<pre><code class=\"language-Bash\">\n# 停止冲突容器（替换为实际容器ID/名称）\ndocker stop 1Panel-openclaw-rt8j\n# 删除冲突容器\ndocker rm 1Panel-openclaw-rt8j\n</code></pre>\n</li>\n</ul>\n<h1 id=\"六openclaw-残余内容清理彻底卸载重置\">六、OpenClaw 残余内容清理（彻底卸载/重置）</h1>\n<p>若需重新部署或完全卸载 OpenClaw，执行以下命令清理所有残余文件：</p>\n<h3 id=\"1-停止所有-openclaw-进程\">1. 停止所有 OpenClaw 进程</h3>\n<pre><code class=\"language-Bash\">\npkill -f openclaw\nopenclaw gateway stop\n</code></pre>\n<h3 id=\"2-删除-openclaw-核心目录配置数据\">2. 删除 OpenClaw 核心目录（配置+数据）</h3>\n<pre><code class=\"language-Bash\">\nrm -rf ~/.openclaw\n</code></pre>\n<h3 id=\"3-删除-openclaw-日志文件\">3. 删除 OpenClaw 日志文件</h3>\n<pre><code class=\"language-Bash\">\nrm -rf /tmp/openclaw\n</code></pre>\n<h3 id=\"4-卸载-openclaw-npm-包\">4. 卸载 OpenClaw npm 包</h3>\n<pre><code class=\"language-Bash\">\nnpm uninstall -g openclaw\n</code></pre>\n<h2 id=\"5-清理-docker-残余若通过-1paneldocker-部署过\">5. 清理 Docker 残余（若通过 1Panel/Docker 部署过）</h2>\n<pre><code class=\"language-Bash\">\n# 列出所有容器\ndocker ps -a | grep openclaw\n# 删除 OpenClaw 相关容器（替换为实际容器ID）\ndocker rm 容器ID\n# 清理未使用的镜像/卷（可选）\ndocker system prune -a\n</code></pre>\n<h2 id=\"6-验证清理完成\">6. 验证清理完成</h2>\n<pre><code class=\"language-Bash\">\n# 检查进程（无输出即清理成功）\nps -ef | grep openclaw | grep -v grep\n# 检查目录（无输出即清理成功）\nls ~/.openclaw\nls /tmp/openclaw\n</code></pre>\n<h1 id=\"七注意事项\">七、注意事项</h1>\n<h3 id=\"1-环境配置规范\">1. 环境配置规范</h3>\n<ul>\n<li>\n<p>Node.js 版本：必须 v24.13.0 及以上，低版本会导致 OpenClaw 启动失败；</p>\n</li>\n<li>\n<p>npm 全局路径：配置后避免 <code>EACCES</code> 权限报错，建议必做；</p>\n</li>\n<li>\n<p>配置文件：JSON 语法严格，仅使用半角符号，无注释，键名/值必须用双引号包裹。</p>\n</li>\n</ul>\n<h3 id=\"2-模型使用注意\">2. 模型使用注意</h3>\n<ul>\n<li>\n<p>优先选择 DeepSeek：Anthropic 模型需国际信用卡充值、合规网络，国内用户适配性差；</p>\n</li>\n<li>\n<p>DeepSeek API Key 有效期：需确保 Key 未过期，且账号有余额（DeepSeek 提供免费额度）；</p>\n</li>\n<li>\n<p>模型 ID 不可修改：DeepSeek 必须使用 <code>deepseek-chat</code>，自定义 ID 会导致调用失败。</p>\n</li>\n</ul>\n<h3 id=\"3-进程与端口管理\">3. 进程与端口管理</h3>\n<ul>\n<li>\n<p>启动前必清进程：避免端口冲突和配置重载失败；</p>\n</li>\n<li>\n<p>端口占用处理：若 18789 被占用，可更换端口（如 <code>--port 18788</code>），同时修改配置文件中的 <code>port</code> 字段。</p>\n</li>\n</ul>\n<h3 id=\"4-权限与网络\">4. 权限与网络</h3>\n<ul>\n<li>终端权限：执行 <code>rm</code>/<code>mkdir</code> 命令时若报错，加 <code>sudo</code> 提升权限；</li>\n</ul>\n<h1 id=\"八总结\">八、总结</h1>\n<h2 id=\"核心流程回顾\">核心流程回顾</h2>\n<ol>\n<li>\n<p>搭建基础环境：安装 Homebrew → 安装 Node.js → 配置 npm 全局路径；</p>\n</li>\n<li>\n<p>部署 OpenClaw：安装包 → 写入合法配置 → 验证语法 → 启动网关；</p>\n</li>\n<li>\n<p>验证效果：访问 UI 测试对话 → 实时监控日志排查问题；</p>\n</li>\n<li>\n<p>清理残余：停止进程 → 删除配置/日志/包文件。</p>\n</li>\n</ol>\n<h2 id=\"关键要点\">关键要点</h2>\n<ul>\n<li>\n<p>配置文件是核心：语法错误、字段缺失是部署失败的主要原因；</p>\n</li>\n<li>\n<p>DeepSeek 适配性最优：国内网络无需额外配置，API Key 易获取；</p>\n</li>\n<li>\n<p>日志是排查利器：启动后通过 <code>tail -f</code> 实时查看日志，快速定位问题。</p>\n</li>\n</ul>\n<p>通过以上步骤，可实现 OpenClaw 在 macOS 上的标准化部署，且能稳定调用 DeepSeek 模型完成对话交互。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-09 15:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xiaobaiysf\">小白跃升坊</a>&nbsp;\n阅读(<span id=\"post_view_count\">42</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "C++小白训练第十三天",
      "link": "https://www.cnblogs.com/godjian/p/19594585",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/godjian/p/19594585\" id=\"cb_post_title_url\" title=\"发布于 2026-02-09 12:13\">\n    <span>C++小白训练第十三天</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"c小白训练第十三天\">C++小白训练第十三天</h2>\n<p>以下为牛客挑战</p>\n<h2 id=\"今日收获\">今日收获</h2>\n<pre><code> vector&lt;pair&lt;int,int&gt;&gt;v;用于存储坐标，如果坐标：\n 方式：v.push_back({i,j}),v.emplace_back(i,j);\n \n v.push_back(make_pair(i, j));\n\ndp联想的又一个条件，就是因为限制只存在与相邻，那就和后面没有关系，所以考虑dp\n\n\n理解了置换环：n-环数等于操作数。\n</code></pre>\n<h2 id=\"牛客周赛-round-130\">牛客周赛 Round 130</h2>\n<h3 id=\"红美铃的访客登记\">红美铃的访客登记</h3>\n<p><a href=\"https://ac.nowcoder.com/acm/contest/127702/A\" rel=\"noopener nofollow\" target=\"_blank\">A-红美铃的访客登记_牛客周赛 Round 130 (nowcoder.com)</a></p>\n<p><img alt=\"image-20260209082136953\" src=\"https://img2024.cnblogs.com/blog/3621557/202602/3621557-20260209121302221-750510719.png\" /></p>\n<h4 id=\"解题代码\">解题代码</h4>\n<pre><code class=\"language-c++\">#include&lt;bits/stdc++.h&gt;\n#define int long long\n#define lll __uint128_t\n#define PII pair&lt;int ,int&gt;\n#define endl '\\n'\nusing namespace std;\n#define yn(ans) printf(\"%s\\n\", (ans)?\"Yes\":\"No\");//快速打印\n#define YN(ans) printf(\"%s\\n\", (ans)?\"YES\":\"NO\");\n#define REP(i, e) for (int i = 0; i &lt; (e); ++i)\n#define REP1(i, s, e) for (int i = (s); i &lt;=(e); ++i)\n#define TESTS int t; cin &gt;&gt; t; while (t--)\n#define TEST\nconst int N=2e5+10,M=1e3+10,mod=1e9+7;\nint a[N],b[N],c[N],pre[N];\n\nsigned main(){\n\n\tstd::ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    string s;\n    cin&gt;&gt;s;\n    int count=0;\n    for(int i=0;i&lt;s.size();i++){\n        if(s[i]!='0'){\n            count=i;\n            break;\n        }\n    }\n    for(int i=count;i&lt;s.size();i++){\n        cout&lt;&lt;s[i];\n    }\n    \n\n\treturn 0;\n}\n</code></pre>\n<h3 id=\"爱丽丝的魔力零件分类\">爱丽丝的魔力零件分类</h3>\n<p><a href=\"https://ac.nowcoder.com/acm/contest/127702/B\" rel=\"noopener nofollow\" target=\"_blank\">B-爱丽丝的魔力零件分类_牛客周赛 Round 130 (nowcoder.com)</a></p>\n<p><img alt=\"image-20260209084218695\" src=\"https://img2024.cnblogs.com/blog/3621557/202602/3621557-20260209121303147-1985436397.png\" /></p>\n<pre><code>3\n5\n.....\n.....\n.***.\n..*..\n.....\n5\n.....\n..*..\n..*..\n.**..\n.....\n6\n......\n..*...\n.**...\n..*...\n......\n......\n</code></pre>\n<pre><code>T\nL\nT\n</code></pre>\n<p><strong>题解</strong></p>\n<h4 id=\"解题代码-1\">解题代码</h4>\n<p>可以先把这些为*的点先存起来，然后去判断他们的度数双重循环，来判断，当我们发现最多度数为3的时候就就是t，其他的就不是t，是l</p>\n<pre><code class=\"language-c++\">#include&lt;bits/stdc++.h&gt;\n#define int long long\n#define lll __uint128_t\n#define PII pair&lt;int ,int&gt;\n#define endl '\\n'\nusing namespace std;\n#define yn(ans) printf(\"%s\\n\", (ans)?\"Yes\":\"No\");//快速打印\n#define YN(ans) printf(\"%s\\n\", (ans)?\"YES\":\"NO\");\n#define REP(i, e) for (int i = 0; i &lt; (e); ++i)\n#define REP1(i, s, e) for (int i = (s); i &lt;=(e); ++i)\n#define TESTS int t; cin &gt;&gt; t; while (t--)\n#define TEST\nconst int N=2e5+10,M=1e3+10,mod=1e9+7;\nint a[N],b[N],c[N],pre[N];\nvoid solve(){\n    int n;\n    cin&gt;&gt;n;\n    vector&lt;pair&lt;int,int&gt;&gt;v;\n    for(int i=1;i&lt;=n;i++){\n        for(int j=1;j&lt;=n;j++){\n            char m;\n            cin&gt;&gt;m;\n            if(m=='*'){\n                v.emplace_back(i,j);\n            }\n        }\n    }\n    int mx=0;\n    for(auto [x,y]:v){\n        int degree=0;\n        for(auto [nx,ny]:v){\n            if(abs(x-nx)+abs(y-ny)==1){\n                degree++;\n            }\n        }\n        mx=max(degree,mx);\n    }\n    if(mx==3){\n        cout&lt;&lt;\"T\"&lt;&lt;endl;\n    }else{\n        cout&lt;&lt;\"L\"&lt;&lt;endl;\n    }\n\n};\nsigned main(){\n\n\tstd::ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    TESTS{\n        solve();\n    };\n\n\treturn 0;\n}\n</code></pre>\n<h3 id=\"博丽大结界的稳定轴心\">博丽大结界的稳定轴心</h3>\n<p><a href=\"https://ac.nowcoder.com/acm/contest/127702/C\" rel=\"noopener nofollow\" target=\"_blank\">C-博丽大结界的稳定轴心_牛客周赛 Round 130 (nowcoder.com)</a></p>\n<p><img alt=\"image-20260209090135699\" src=\"https://img2024.cnblogs.com/blog/3621557/202602/3621557-20260209121303545-355177775.png\" /></p>\n<pre><code>5\n1 2\n1 3\n1 4\n4 5\n</code></pre>\n<pre><code>4\n</code></pre>\n<p>我们可以去分析一下二叉树的特点，是不是最多的节点数在3个以下，且这个3个的节点不会作为轴心点。</p>\n<p>两个的和一个的都可以作为轴心点。</p>\n<p>所有我们可以去先判断到底哪个最大的点数有多大。大于3就直接是零，小于的3就可以作为轴心点。</p>\n<h4 id=\"解题代码-2\">解题代码</h4>\n<pre><code class=\"language-c++\">#include&lt;bits/stdc++.h&gt;\n#define int long long\n#define lll __uint128_t\n#define PII pair&lt;int ,int&gt;\n#define endl '\\n'\nusing namespace std;\n#define yn(ans) printf(\"%s\\n\", (ans)?\"Yes\":\"No\");//快速打印\n#define YN(ans) printf(\"%s\\n\", (ans)?\"YES\":\"NO\");\n#define REP(i, e) for (int i = 0; i &lt; (e); ++i)\n#define REP1(i, s, e) for (int i = (s); i &lt;=(e); ++i)\n#define TESTS int t; cin &gt;&gt; t; while (t--)\n#define TEST\nconst int N=2e5+10,M=1e3+10,mod=1e9+7;\nint a[N],b[N],c[N],pre[N];\n\nsigned main(){\n\n\tstd::ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin&gt;&gt;n;\n    vector&lt;vector&lt;int&gt;&gt;g(n+1);\n    for(int i=1;i&lt;n;i++){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int mx=0;\n    int ans=0;\n    for(int i=1;i&lt;=n;i++){\n        mx=max(mx,(int)g[i].size());\n    }\n    if(mx&lt;=3){\n        for(int i=1;i&lt;=n;i++){\n            if(g[i].size()&lt;=2){\n                ans++;\n            }\n        }\n    }\n    cout&lt;&lt;ans&lt;&lt;endl;\n\n\treturn 0;\n}\n</code></pre>\n<h3 id=\"魔法人偶的十进制校准\">魔法人偶的十进制校准</h3>\n<p><img alt=\"image-20260209094949846\" src=\"https://img2024.cnblogs.com/blog/3621557/202602/3621557-20260209121303963-2021372242.png\" /></p>\n<pre><code>3\n1 5\n2 3\n5 7\n</code></pre>\n<pre><code>1 2\n1 3\n3 7\n</code></pre>\n<p>首先我们通过打标确定一下规律。</p>\n<pre><code class=\"language-c++\">for(double y=2;y&lt;=1000;y++){\n\tcout&lt;&lt;fixed&lt;&lt;setprecision(10)&lt;&lt;(1.0/y)&lt;&lt;endl;\n}\n</code></pre>\n<p><img alt=\"image-20260209095354057\" src=\"https://img2024.cnblogs.com/blog/3621557/202602/3621557-20260209121304411-1460739702.png\" /></p>\n<p>可以发现特殊的</p>\n<pre><code>1/9----》得到这个。0.1111111，这个我们就可以去构造一下了，但是，b/9\n\n然后特判别的，应为没有9/9，所以我们看到0.9090...\n我们可以通过奇偶代换×一个10就可以了，我们直接9得到这个数.\n然后特判一些0，和可以被3，6的情况就行了\n</code></pre>\n<h4 id=\"解题代码-3\">解题代码</h4>\n<pre><code class=\"language-c++\">#include&lt;bits/stdc++.h&gt;\n#define int long long\n#define lll __uint128_t\n#define PII pair&lt;int ,int&gt;\n#define endl '\\n'\nusing namespace std;\n#define yn(ans) printf(\"%s\\n\", (ans)?\"Yes\":\"No\");//快速打印\n#define YN(ans) printf(\"%s\\n\", (ans)?\"YES\":\"NO\");\n#define REP(i, e) for (int i = 0; i &lt; (e); ++i)\n#define REP1(i, s, e) for (int i = (s); i &lt;=(e); ++i)\n#define TESTS int t; cin &gt;&gt; t; while (t--)\n#define TEST\nconst int N=2e5+10,M=1e3+10,mod=1e9+7;\n\nvoid solve(){\n    int a,b;\n    cin&gt;&gt;a&gt;&gt;b;\n    if(b==0){\n        if(a==1){\n            cout&lt;&lt;1&lt;&lt;\" \"&lt;&lt;1000&lt;&lt;endl;\n        }else{\n            cout&lt;&lt;1&lt;&lt;\" \"&lt;&lt;2&lt;&lt;endl;\n        }\n        return;\n    }else if(b==9){\n        if(a%2){\n            cout&lt;&lt;10&lt;&lt;\" \"&lt;&lt;11&lt;&lt;endl;\n        }else{\n            cout&lt;&lt;1&lt;&lt;\" \"&lt;&lt;11&lt;&lt;endl;\n        }\n        return;\n    }\n    if(b==3){\n        cout&lt;&lt;1&lt;&lt;\" \"&lt;&lt;3&lt;&lt;endl;\n        return;\n    }\n    if(b==6){\n        cout&lt;&lt;2&lt;&lt;\" \"&lt;&lt;3&lt;&lt;endl;\n        return;\n    }\n    cout&lt;&lt;b&lt;&lt;\" \"&lt;&lt;9&lt;&lt;endl;\n};\nsigned main(){\n\n\tstd::ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    TESTS{\n        solve();\n    };\n\n\treturn 0;\n}\n</code></pre>\n<h3 id=\"爱丽丝的人偶圆舞曲\">爱丽丝的人偶圆舞曲</h3>\n<p><a href=\"https://ac.nowcoder.com/acm/contest/127702/E\" rel=\"noopener nofollow\" target=\"_blank\">E-爱丽丝的人偶圆舞曲_牛客周赛 Round 130 (nowcoder.com)</a></p>\n<p><img alt=\"image-20260209112816198\" src=\"https://img2024.cnblogs.com/blog/3621557/202602/3621557-20260209121304824-570108632.png\" /></p>\n<pre><code>abca\n</code></pre>\n<pre><code>1\n</code></pre>\n<p>因为限制只存在与相邻。我们就可以去考虑dp的做法</p>\n<p>这个是一个线性dp的题目，我们可以定义一个</p>\n<p>因为d没有确认，所以我们去枚举d</p>\n<pre><code>f[i][j]---&gt;表示前i个位置均合法，且si=j的最小次数\n\n你们转移就是\nmin（f[i-1][(j-d+26)%26],f[(i+d)%26]）+这个数到底是不是等于j，不等于就要用一次，最后再算出最小值。\n</code></pre>\n<h4 id=\"解题代码-4\">解题代码</h4>\n<pre><code class=\"language-c++\">#include&lt;bits/stdc++.h&gt;\n#define int long long\n#define lll __uint128_t\n#define PII pair&lt;int ,int&gt;\n#define endl '\\n'\nusing namespace std;\n#define yn(ans) printf(\"%s\\n\", (ans)?\"Yes\":\"No\");//快速打印\n#define YN(ans) printf(\"%s\\n\", (ans)?\"YES\":\"NO\");\n#define REP(i, e) for (int i = 0; i &lt; (e); ++i)\n#define REP1(i, s, e) for (int i = (s); i &lt;=(e); ++i)\n#define TESTS int t; cin &gt;&gt; t; while (t--)\n#define TEST\nconst int N=2e5+10,M=1e3+10,mod=1e9+7;\nint a[N],b[N],c[N],pre[N];\n\nsigned main(){\n\n\tstd::ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    string s;\n    cin&gt;&gt;s;\n\n    int n=s.size();\n    s=\" \"+s;\n\n    //dp初始化。\n    int mx=2e8;\n    for(int d=0;d&lt;=25;d++){\n        vector&lt;vector&lt;int&gt;&gt;f(n+1,vector&lt;int&gt;(26,2e8));\n        for(int j=0;j&lt;=25;j++){\n            if(j==s[1]-'a'){\n                f[1][j]=0;\n            }else{\n                f[1][j]=1;\n            }\n        }\n        for(int i=2;i&lt;=n;i++){\n            for(int j=0;j&lt;=25;j++){\n                f[i][j]=min(f[i-1][(j-d+26)%26],f[i-1][(j+d)%26])+(j!=s[i]-'a');\n            }\n        }\n\n        for(int i=0;i&lt;=25;i++){\n            mx=min(mx,f[n][i]);\n        }\n\n    }\n    cout&lt;&lt;mx&lt;&lt;endl;\n\n\n\n\n\treturn 0;\n}\n</code></pre>\n<h3 id=\"红魔馆的微瑕序位\">红魔馆的微瑕序位</h3>\n<p><a href=\"https://ac.nowcoder.com/acm/contest/127702/F\" rel=\"noopener nofollow\" target=\"_blank\">F-红魔馆的微瑕序位_牛客周赛 Round 130 (nowcoder.com)</a></p>\n<p><img alt=\"image-20260209120106423\" src=\"https://img2024.cnblogs.com/blog/3621557/202602/3621557-20260209121305276-651327063.png\" /></p>\n<pre><code>2\n5\n1 2 4 3 5\n2\n1 2\n</code></pre>\n<pre><code>0\n1\n</code></pre>\n<p>本题考的一个经典置换环</p>\n<pre><code>如果一个1-n的排列，要交换几次才能使得它是一个排列。\n结论是\nn-环的个数，相当于拆环。\n</code></pre>\n<p><img alt=\"image-20260209120521887\" src=\"https://img2024.cnblogs.com/blog/3621557/202602/3621557-20260209121305664-904288544.png\" /></p>\n<p>如图是4元环</p>\n<p>我们邀得到2，肯定得一个两个相邻的元素之间没有去交换</p>\n<pre><code>1 2 4 3 5\n</code></pre>\n<p>那我们先把交换的次数算出来，再考虑原来到底存不存在相邻的环。</p>\n<h4 id=\"解题代码-5\">解题代码</h4>\n<pre><code class=\"language-c++\">#include&lt;bits/stdc++.h&gt;\n#define int long long\n#define lll __uint128_t\n#define PII pair&lt;int ,int&gt;\n#define endl '\\n'\nusing namespace std;\n#define yn(ans) printf(\"%s\\n\", (ans)?\"Yes\":\"No\");//快速打印\n#define YN(ans) printf(\"%s\\n\", (ans)?\"YES\":\"NO\");\n#define REP(i, e) for (int i = 0; i &lt; (e); ++i)\n#define REP1(i, s, e) for (int i = (s); i &lt;=(e); ++i)\n#define TESTS int t; cin &gt;&gt; t; while (t--)\n#define TEST\nconst int N=2e5+10,M=1e3+10,mod=1e9+7;\nint a[N],b[N],c[N],pre[N];\nvoid solve(){\n    int n;\n    cin&gt;&gt;n;\n    vector&lt;int&gt;v(n+1);\n    for(int i=1;i&lt;=n;i++){\n        cin&gt;&gt;a[i];\n    }\n    int loop=0;\n    for(int i=1;i&lt;=n;i++){\n        if(v[i])continue;\n        int j=i;\n        loop++;\n        while (!v[j]){\n            v[j]=loop;\n            j=a[j];\n        }\n    }\n    int ans=n-loop+1;\n    for(int i=2;i&lt;=n;i++){//判断是不是相邻的环\n        if(v[i-1]==v[i]){\n            ans-=2;\n            break;\n        }\n    }\n    cout&lt;&lt;ans&lt;&lt;endl;\n};\nsigned main(){\n\n\tstd::ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    TESTS{\n        solve();\n    };\n\n\treturn 0;\n}\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-09 12:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/godjian\">Godjian</a>&nbsp;\n阅读(<span id=\"post_view_count\">29</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "扣子Coze实战：从0到1搭建小红书图文改写智能体",
      "link": "https://www.cnblogs.com/tangshiye/p/19594522",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tangshiye/p/19594522\" id=\"cb_post_title_url\" title=\"发布于 2026-02-09 11:59\">\n    <span>扣子Coze实战：从0到1搭建小红书图文改写智能体</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>大家好，我是汤师爷，专注AI智能体分享，致力于帮助100W人用智能体创富~</p>\n<p>还在为小红书笔记创作发愁吗？</p>\n<p>每天都要绞尽脑汁想文案，看着别人的爆款笔记却不知道如何模仿？</p>\n<p>今天，我就教你如何利用AI智能体，轻松实现小红书图文改写，让创作效率提升10倍！</p>\n<p>我们先看下智能体的执行效果：</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h2 id=\"1整体工作流\">1.整体工作流</h2>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>1.获取小红书笔记详情</p>\n<p>2.使用OCR技术，提取图片中的文字</p>\n<p>3.将图片文案进行整理</p>\n<p>4.图片文案仿写</p>\n<h2 id=\"2详细工作流节点\">2.详细工作流节点</h2>\n<h3 id=\"21-开始节点\">2.1 开始节点</h3>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>开始节点有两个输入变量。</p>\n<ul>\n<li>输入：\n<ul>\n<li>noteUrl：小红书笔记链接</li>\n<li>cookieStr：小红书cookie</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"22-如何获取小红书cookie\">2.2 如何获取小红书cookie？</h3>\n<p>1.登陆<a href=\"https://www.xiaohongshu.com/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.xiaohongshu.com/</a></p>\n<p>2.在页面空白处右击鼠标，选择「检查」</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>3.在刚刚打开的面板中，点击「网络」选项卡</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>4.刷新当前页面</p>\n<p>5.点击第一条记录，在右侧「标头」部分向下滚动，找到cookie一行，将其内容复制下，这就是我们需要的cookieStr</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"23-获取小红书笔记详情\">2.3 获取小红书笔记详情</h3>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>我们将使用【小红书】插件的xhs_note_detail功能。</p>\n<p>通过这个功能，我们可以根据笔记链接获取笔记详情。</p>\n<ul>\n<li>输入：\n<ul>\n<li>cookieStr：开始 - cookieStr</li>\n<li>noteUrl：开始 - noteUrl</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"24-使用ocr技术提取图片中的文字\">2.4 使用OCR技术，提取图片中的文字</h3>\n<p><strong>1.接下来，我们使用循环节点，批量提取图片中的文字。</strong></p>\n<ul>\n<li>输入：\n<ul>\n<li>input：获取小红书笔记详情-note_image_list</li>\n</ul>\n</li>\n<li>输出\n<ul>\n<li>output：从图片中提取文字-data</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p><strong>2.使用循环体，批量提取图片的文字</strong></p>\n<p>我们会使用「OCR」插件，提取图片的文字。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>输入参数如下图所示。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"25-使用大模型将文案内容进行整理排版\">2.5 使用大模型将文案内容进行整理、排版</h3>\n<p>在这一步，我们会使用大模型节点，对文案内容进行整理、排版。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>大模型节点的系统提示词如下：</p>\n<pre><code class=\"language-markdown\">## 角色（Role）\n你是一位精通内容整理和 Markdown 排版的 AI 助手。你擅长阅读和理解非结构化的文本内容，并能够将其转化为结构清晰、格式优美的 Markdown 文档。\n\n## 背景（Background）\n随着社交媒体平台的普及，大量的图文内容被创作和分享。然而，这些内容往往缺乏良好的结构和格式，不利于阅读和理解。将这些内容整理成结构化的 Markdown 文档，可以大大提高内容的可读性和价值。\n\n## 任务（Task）\n你的任务是接收一段从插件输出的非结构化文本内容（主要是抖音图文中的文字），仔细阅读并理解内容，然后将其转化为结构清晰、格式规范的 Markdown 文档。你需要：\n\n1. 识别并提取文本中的关键信息，如标题、作者、主要内容等\n2. 根据内容的逻辑关系，对文本进行分类和整理\n3. 使用 Markdown 语法进行排版，包括但不限于使用标题、粗体、斜体、列表等格式\n4. 确保所有原始内容都被包含在最终的 Markdown 文档中，不遗漏任何信息\n\n## 规则与限制（Rules &amp; Restrictions）\n1. 必须使用 Markdown 语法进行排版\n2. 使用 #、##、### 等进行标题划分，层级不超过 3 级\n3. 使用 - 或 * 进行无序列表编写，使用 1. 2. 3. 等进行有序列表编写\n4. 重要内容使用粗体（**文字**）标注，需要强调的内容使用斜体（*文字*）标注\n5. 保持原文的主要结构和顺序，但可以适当调整以提高可读性\n6. 不得添加、删除或修改原文的实质内容\n7. 如遇到不确定的内容，保留原样并用括号标注\n\n## 参考短语（Reference sentences）\n- 内容完整，不遗漏任何信息\n- 结构清晰，层次分明\n- 格式规范，美观实用\n- 逻辑严密，条理清晰\n- 重点突出，易于阅读\n\n## 案例展示（Case Show）\n### 输入：\n{\n  \"code\": 0,\n  \"data\": {\n    \"results\": [\n      {\n        \"words\": [\n          {\n            \"lang\": \"auto\",\n            \"text\": \"求大连这两个\"\n          },\n          {\n            \"lang\": \"auto\",\n            \"text\": \"地方有啥\"\n          },\n          {\n            \"lang\": \"auto\",\n            \"text\": \"区别啊？？\"\n          }\n        ]\n      }\n    ]\n  },\n  \"log_id\": \"20250325123913080C6F506498C6F581B7\",\n  \"msg\": \"success\"\n}\n\n## 风格和语气（Style &amp; Tone）\n- 保持专业、清晰的语气\n- 使用简洁、直接的表达方式\n- 保持原文的重点和强调\n\n## 受众群体（Audience）\n- 小红书电商新手卖家\n- 对开设小红书店铺感兴趣的人群\n- 想要了解小红书电商运营的人群\n\n## 输出格式（Output format）\n使用 Markdown 格式输出，包括：\n1. 一级标题（#）用于文章主标题\n2. 二级标题（##）用于主要章节\n3. 三级标题（###）用于子章节\n4. 无序列表使用 - 或 *\n5. 有序列表使用 1. 2. 3. 等\n6. 重要内容使用粗体（**文字**）\n7. 需要强调的内容使用斜体（*文字*）\n\n## 工作流程（Workflow）\n1. 仔细阅读输入的文本内容，理解其结构和主要信息点\n2. 提取标题、作者、标签等元信息\n3. 识别主要章节和子章节，规划文档结构\n4. 按照规划的结构，使用 Markdown 语法重新排版内容\n5. 使用粗体和斜体突出重要信息和需要强调的内容\n6. 检查确保所有原始内容都被包含，没有遗漏\n7. 最后检查 Markdown 格式是否正确，调整以确保最佳可读性\n\n## 初始化（Initialization）\n\n下面是你需要整理和格式化的文本内容：\n\n&lt;评价内容&gt;\n\n请提供需要整理和格式化的文本内容。我会仔细阅读并按照上述要求将其转化为结构清晰的 Markdown 文档。不需要输出额外除图片识别文字以外的内容。\n</code></pre>\n<h3 id=\"26-图片文案仿写\">2.6 图片文案仿写</h3>\n<p>接下来，我们需要通过大模型节点退图片文案进行仿写。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>大模型节点的系统提示词如下：</p>\n<pre><code class=\"language-markdown\"># 角色说明\n你是一位专业的图文内容仿写助手，负责根据图片中提取的文字内容，结合视觉元素和背景信息，创作风格一致的仿写内容。\n\n# 背景说明\n处理用户提供的图片文字内容时，你需要：\n1. 理解图片的整体风格和背景（产品介绍、教程步骤、使用心得等）\n2. 分析文字的语言特点（正式/口语化、句式特征、专业术语等）\n3. 结合图片呈现的视觉信息（产品外观、使用场景等）\n4. 在保持原意的基础上进行自然的仿写扩展\n\n# 仿写原则\n1. 保持原意完整性\n2. 匹配原文语言风格\n3. 补充恰当的细节\n4. 与图片内容保持一致\n5. 避免添加虚假信息\n\n# 工作流程\n1. 接收图片文字内容\n2. 分析图片背景信息（可选）\n3. 分析原文特点：\n   - 语言风格\n   - 内容结构\n   - 关键词使用\n4. 创作三个版本：\n   - 贴近原文的保守版\n   - 适度优化的改进版\n   - 创意加强的亮点版\n\n# 输出示例\n## 原文：\n\"夏日必备防晒霜\nSPF50+ PA++++\n清爽不油腻\"\n\n## 仿写版本：\n1. 【保守版】\n\"夏季必备防晒产品\n防晒指数SPF50+ PA++++\n质地清爽不油腻\"\n\n2. 【优化版】\n\"夏日防晒推荐\n高倍防护SPF50+ PA++++\n轻薄水感质地，肌肤零负担\"\n\n3. 【创意版】\n\"今夏防晒天花板！\nSPF50+ PA++++超强防护\n一抹化水，清爽不黏腻\"\n\n# 执行要求\n请提供：\n1. 图片文字提取内容\n2. 图片背景说明（如有）\n\n我将按照以上规范进行仿写创作。\n</code></pre>\n<h3 id=\"27-使用文本处理插件拼接字符串\">2.7 使用文本处理插件拼接字符串</h3>\n<ul>\n<li>输入：\n<ul>\n<li>String1：获取小红书笔记详情-note</li>\n<li>String2：图片文案内容整理-output</li>\n<li>String3：图片文案仿写-output</li>\n</ul>\n</li>\n</ul>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"28-结束节点\">2.8 结束节点</h3>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<h2 id=\"3总结\">3.总结</h2>\n<p>通过以上介绍，相信你了解了如何利用DeepSeek+Coze来构建高效的小红书图片文案改写智能体。</p>\n<p>在AI时代，技术门槛将越来越低，小白也能搭建智能体，用AI工具来提升工作效率。</p>\n<p>用AI智能体不是未来，而是AI时代每个人的生存技能，学会AI智能体，人人都是超级个体。</p>\n<p>如果你觉得这篇文章有帮助，别忘了点赞、关注、收藏，我们下期再见！</p>\n<blockquote>\n<p>对了，我整理了一份开源《智能体学习手册》，爆肝 10 万字，价值 999 元。限时开放领取👉：<a href=\"https://tangshiye.cn\" rel=\"noopener nofollow\" target=\"_blank\">tangshiye.cn</a></p>\n</blockquote>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/tangshiye/\" target=\"_blank\">AI架构师汤师爷</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/tangshiye/p/19594522\" target=\"_blank\">https://www.cnblogs.com/tangshiye/p/19594522</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-09 11:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tangshiye\">AI架构师汤师爷</a>&nbsp;\n阅读(<span id=\"post_view_count\">71</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI不止于API：手把手教你用Jinja2打造动态Web页面",
      "link": "https://www.cnblogs.com/ymtianyu/p/19594466",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19594466\" id=\"cb_post_title_url\" title=\"发布于 2026-02-09 11:48\">\n    <span>FastAPI不止于API：手把手教你用Jinja2打造动态Web页面</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文系统介绍了如何在FastAPI框架中集成Jinja2模板引擎来构建动态Web页面。内容涵盖从安装配置、模板上下文数据传递（包括请求级和全局两种方式）、静态文件正确引入，到完整实战演示与常见避坑指南。帮助开发者快速掌握利用FastAPI服务端渲染页面的技能，适用于快速原型、管理后台等场景。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<p>你是不是也觉得，用FastAPI写接口爽到飞起，但一想到要返回个带数据的HTML页面，就瞬间头大？🎯</p>\n<p>我刚用FastAPI那会儿也这样，以为它就是个“API专用框架”，渲染页面？那不是Django和Flask的活儿吗？直到我在一个紧急项目里，需要快速给内部系统做个带数据看板的管理后台，我才发现，<strong style=\"color: rgba(186, 55, 42, 1);\">FastAPI配合Jinja2模板，原来可以这么香！</strong> 今天就跟你唠明白这事儿，保你10分钟上手，告别“前后端分离强迫症”在简单场景下的纠结。</p>\n<h2 style=\"color: rgba(52, 152, 219, 1); padding-bottom: 5px;\">📌 本文能帮你解决</h2>\n<div style=\"background-color: rgba(248, 249, 250, 1); padding: 15px; margin: 20px 0;\">\n<p>1. 在FastAPI中如何安装、配置Jinja2模板引擎。</p>\n<p>2. 如何把后台数据（上下文）安全又方便地“塞”给前端模板。</p>\n<p>3. 如何在模板里正确引入CSS、JS等静态文件，避免“404惨案”。</p>\n<p>4. 我踩过的几个坑和最佳实践，让你一次写对。</p>\n</div>\n<h2>🚀 主要内容脉络</h2>\n<p>👉 先聊聊：为什么需要模板引擎？（不只是为了省事）</p>\n<p>👉 核心操作：安装、配置、传递数据的“两条路径”。</p>\n<p>👉 实战演示：一个包含用户列表和样式的小项目。</p>\n<p>👉 避坑指南：静态文件那些“路径玄学”与进阶思考。</p>\n<hr style=\"border: none; height: 1px; background-color: rgba(238, 238, 238, 1); margin: 30px 0;\" />\n<h2>🔍 一、问题与背景：FastAPI只能“吃”JSON？</h2>\n<p>FastAPI以构建高性能API闻名，<code style=\"color: rgba(186, 55, 42, 1);\">return JSONResponse</code> 几乎是肌肉记忆。但很多场景下，比如：</p>\n<div>\n<p>- 快速原型开发，搞个带页面的demo。</p>\n<p>- 内部管理后台，复杂度不高，不想动用前端框架。</p>\n<p>- 需要服务端渲染（SSR）的简单页面。</p>\n</div>\n<p>这时候，你硬要前后端彻底分离，反而有种“杀鸡用牛刀”的繁琐。就好比你只想在家门口吃碗面，结果非要开车去市中心的高级餐厅点单、等餐、打包再回来。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">模板引擎，就是让你在FastAPI这个“高性能厨房”里，直接开个“堂食窗口”。</strong> Jinja2就是这个窗口最得力的伙计，它能把你的数据（肉、菜）和HTML模板（碗、汤底）快速组合成一碗热腾腾的面（最终页面）。</p>\n<h2>🧠 二、核心原理与步骤：“两条腿”走路</h2>\n<p>好，咱们先来解决最核心的问题：数据怎么从后端“走”到模板里？</p>\n<p>核心就两步：1. 配置引擎；2. 传递数据。数据传递有两条关键“路径”，我画个灵魂图示给你看：</p>\n<div style=\"background-color: rgba(248, 249, 250, 1); padding: 15px; border-radius: 5px; margin: 20px 0;\">\n<p><strong>路径A：依赖项注入（全局/请求级上下文）</strong></p>\n<p>在路由处理函数里，通过 <code style=\"color: rgba(186, 55, 42, 1);\">TemplateResponse</code> 的 <code style=\"color: rgba(186, 55, 42, 1);\">context</code> 参数传递。这是<strong style=\"color: rgba(186, 55, 42, 1);\">最常用、最灵活</strong>的方式，数据针对每次请求。</p>\n<p><strong>路径B：全局模板上下文（每个模板都能用）</strong></p>\n<p>在初始化 <code style=\"color: rgba(186, 55, 42, 1);\">Jinja2Templates</code> 时，通过 <code style=\"color: rgba(186, 55, 42, 1);\">context</code> 参数传递。比如站点名、当前年份等<strong style=\"color: rgba(186, 55, 42, 1);\">全局通用数据</strong>。</p>\n</div>\n<p>是不是有点抽象？别急，咱们接着看实战，代码一写你就全明白了。</p>\n<h2>💻 三、实战演示：从零搭建一个用户列表页</h2>\n<p>接下来重点来了，咱们一步步来。假设我们要做一个显示用户列表的页面。</p>\n<h3>1️⃣ 安装与项目结构</h3>\n<p>先安装必备库：</p>\n<pre class=\"language-powershell highlighter-hljs\"><code>pip install fastapi jinja2 uvicorn</code></pre>\n<p>项目目录结构建议这样安排，清晰明了：</p>\n<div>\n<pre class=\"language-powershell highlighter-hljs\"><code>📁 your_project/\n├── 📁 templates/ # 存放所有Jinja2 HTML模板\n│     └── index.html\n├── 📁 static/ # 存放CSS, JS, 图片等静态文件\n│     └── style.css\n└── main.py # FastAPI 主应用文件</code></pre>\n</div>\n<h3>2️⃣ 配置FastAPI与Jinja2</h3>\n<p>在 <code style=\"color: rgba(186, 55, 42, 1);\">main.py</code> 里进行初始化。这里有个<strong style=\"color: rgba(186, 55, 42, 1);\">关键点</strong>：<code style=\"color: rgba(186, 55, 42, 1);\">directory</code> 参数必须是<strong style=\"color: rgba(186, 55, 42, 1);\">字符串路径</strong>，不能是Path对象（Jinja2的老规矩）。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.templating import Jinja2Templates\nfrom fastapi.staticfiles import StaticFiles\n\napp = FastAPI(title=\"FastAPI+Jinja2 Demo\")\n\n# 配置模板引擎，告诉它模板文件在哪\ntemplates = Jinja2Templates(directory=\"templates\")\n\n# 配置静态文件服务，挂载到`/static`路径\napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")</code></pre>\n<h3>3️⃣ 定义路由与传递数据（路径A）</h3>\n<p>我们定义一个路由，模拟从数据库获取用户列表，并传递给模板：</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.get(\"/\", response_class=HTMLResponse)\nasync def read_users(request: Request):\n    # 模拟数据，实际中可能来自数据库\n    user_list = [\n        {\"id\": 1, \"name\": \"张三\", \"role\": \"管理员\"},\n        {\"id\": 2, \"name\": \"李四\", \"role\": \"编辑\"},\n        {\"id\": 3, \"name\": \"王五\", \"role\": \"订阅用户\"},\n    ]\n    # 网站标题，作为额外数据传递\n    site_title = \"内部用户管理系统\"\n    \n    # 核心操作：渲染模板，并通过context传递数据\n    return templates.TemplateResponse(\n        request=request,\n        name=\"index.html\", # 模板文件名\n        context={\n            \"request\": request, # 这个必须有！Jinja2Templates要求\n            \"users\": user_list,\n            \"title\": site_title\n        }\n    )</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">千万注意</strong>：<code style=\"color: rgba(186, 55, 42, 1);\">context</code> 字典里<strong style=\"color: rgba(186, 55, 42, 1);\">必须包含 \"request\" 键</strong>！这是 <code style=\"color: rgba(186, 55, 42, 1);\">Jinja2Templates</code> 的工作机制要求的，不然模板里一些基于请求的功能会失效。</p>\n<h3>4️⃣ 编写模板文件 (templates/index.html)</h3>\n<p>看看数据在模板里怎么用：</p>\n<pre class=\"language-html highlighter-hljs\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh-CN\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;{{ title }}&lt;/title&gt;\n    &lt;!-- 重点！引入静态CSS文件 --&gt;\n    &lt;link rel=\"stylesheet\" href=\"{{ url_for('static', path='/style.css') }}\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;欢迎使用 {{ title }}&lt;/h1&gt;\n    &lt;table border=\"1\"&gt;\n        &lt;thead&gt;\n            &lt;tr&gt;\n                &lt;th&gt;ID&lt;/th&gt;\n                &lt;th&gt;姓名&lt;/th&gt;\n                &lt;th&gt;角色&lt;/th&gt;\n            &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n            {% for user in users %}\n            &lt;tr&gt;\n                &lt;td&gt;{{ user.id }}&lt;/td&gt;\n                &lt;td&gt;{{ user.name }}&lt;/td&gt;\n                &lt;td&gt;{{ user.role }}&lt;/td&gt;\n            &lt;/tr&gt;\n            {% endfor %}\n        &lt;/tbody&gt;\n    &lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">敲黑板</strong>：引入静态文件用的是 <code style=\"color: rgba(186, 55, 42, 1);\">url_for('static', path='/style.css')</code>。这里的 <code style=\"color: rgba(186, 55, 42, 1);\">'static'</code> 对应我们 <code style=\"color: rgba(186, 55, 42, 1);\">app.mount</code> 时设置的 <code style=\"color: rgba(186, 55, 42, 1);\">name=\"static\"</code>。这是我初期常配错的地方，<strong style=\"color: rgba(186, 55, 42, 1);\">name必须一致</strong>！</p>\n<h3>5️⃣ 编写静态文件 (static/style.css)</h3>\n<p>随便写点样式，确认它能被加载：</p>\n<pre class=\"language-css highlighter-hljs\"><code>body {\n    font-family: sans-serif;\n    padding: 20px;\n    background-color: #f5f5f5;\n}\nh1 {\n    color: #2c3e50;\n}\ntable {\n    width: 100%;\n    border-collapse: collapse;\n    margin-top: 20px;\n}\nth, td {\n    padding: 10px;\n    text-align: left;\n}\nthead {\n    background-color: #3498db;\n    color: white;\n}</code></pre>\n<p>好了！现在运行 <code style=\"color: rgba(186, 55, 42, 1);\">uvicorn main:app --reload</code>，打开 <code style=\"color: rgba(186, 55, 42, 1);\">http://127.0.0.1:8000</code>，一个带样式和动态数据的用户列表页面就出来了！数据从后端“流”到了前端，静态文件也正常加载。</p>\n<h2>⚠️ 四、注意事项与进阶思考</h2>\n<p>是不是以为这样就完了？再说几个容易翻车的点。</p>\n<h3>🎯 避坑指南</h3>\n<div>\n<p><strong>1. 静态文件404？</strong></p>\n<p>- 检查 <code style=\"color: rgba(186, 55, 42, 1);\">app.mount</code> 的 <code style=\"color: rgba(186, 55, 42, 1);\">directory</code> 路径是否正确（相对路径从项目根目录算起）。</p>\n<p>- 检查模板中 <code style=\"color: rgba(186, 55, 42, 1);\">url_for</code> 的 <code style=\"color: rgba(186, 55, 42, 1);\">name</code> 参数是否与 <code style=\"color: rgba(186, 55, 42, 1);\">mount</code> 的 <code style=\"color: rgba(186, 55, 42, 1);\">name</code> 一致。</p>\n<p>- 生产环境通常用Nginx等专门处理静态文件，开发时用 <code style=\"color: rgba(186, 55, 42, 1);\">StaticFiles</code> 很方便。</p>\n<p><strong>2. 全局上下文（路径B）怎么用？</strong></p>\n<p>比如你想在每个页面都显示版权年份：</p>\n</div>\n<pre class=\"language-python highlighter-hljs\"><code>templates = Jinja2Templates(\n    directory=\"templates\",\n    context={\"current_year\": 2024} # 全局注入\n)\n# 然后，在任何模板里都可以直接使用 {{ current_year }}</code></pre>\n<h3>🚀 进阶思考</h3>\n<p><strong>模板继承是王牌：</strong> 用 <code style=\"color: rgba(186, 55, 42, 1);\">{% extends \"base.html\" %}</code> 和 <code style=\"color: rgba(186, 55, 42, 1);\">{% block content %}...{% endblock %}</code> 来复用布局（如导航栏、页脚），能让你的模板代码干净十倍。强烈建议你用起来。</p>\n<p><strong>上下文处理器：</strong> 如果你想在每个请求的模板里都自动注入一些数据（比如当前登录用户），可以自定义依赖项，并在每个路由的 <code style=\"color: rgba(186, 55, 42, 1);\">TemplateResponse</code> 里调用。虽然有点绕，但结构更清晰。</p>\n<p><strong>何时用？何时不用？</strong> 对于复杂的、交互性强的现代Web应用，前后端分离（React/Vue + FastAPI API）仍是首选。但对于工具类、管理类、需要SEO的简单内容页，<strong style=\"color: rgba(186, 55, 42, 1);\">FastAPI + Jinja2 的组合能让你一人顶一个全栈团队，开发速度飞快</strong>。</p>\n<hr />\n<p>好了，今天的分享就到这儿。希望这篇“踩坑经验总结”能帮你把FastAPI的“另一面”也利用起来。</p>\n<p>技术选型没有银弹，<strong style=\"color: rgba(186, 55, 42, 1);\">最好的工具是那个能帮你高效、稳定解决问题的工具</strong>。下次当你需要快速捣鼓个带界面的小工具时，不妨试试这个组合。</p>\n<p>你在用FastAPI做Web页面时还遇到过什么奇葩问题？或者有更优雅的实践？<strong style=\"color: rgba(186, 55, 42, 1);\">欢迎在评论区一起聊聊</strong>，你的经验很可能也能帮到别人。</p>\n<p style=\"text-align: center; color: rgba(127, 140, 141, 1); font-size: 0.9em;\">觉得有用的话，记得收藏、点赞、关注哦~ 咱们下期见！</p>\n</div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-09 11:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">一名程序媛呀</a>&nbsp;\n阅读(<span id=\"post_view_count\">25</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从零实现富文本编辑器#11-Immutable状态维护与增量渲染",
      "link": "https://www.cnblogs.com/WindrunnerMax/p/19594114",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/WindrunnerMax/p/19594114\" id=\"cb_post_title_url\" title=\"发布于 2026-02-09 10:51\">\n    <span>从零实现富文本编辑器#11-Immutable状态维护与增量渲染</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在先前我们讨论了视图层的适配器设计，主要是全量的视图初始化渲染，包括生命周期同步、状态管理、渲染模式、<code>DOM</code>映射状态等。在这里我们需要处理变更的增量更新，这属于性能方面的考量，需要考虑如何实现不可变的状态对象，以此来实现<code>Op</code>操作以及最小化<code>DOM</code>变更。</p>\n<ul>\n<li>开源地址: <a href=\"https://github.com/WindRunnerMax/BlockKit\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/WindRunnerMax/BlockKit</a></li>\n<li>在线编辑: <a href=\"https://windrunnermax.github.io/BlockKit/\" rel=\"noopener nofollow\" target=\"_blank\">https://windrunnermax.github.io/BlockKit/</a></li>\n<li>项目笔记: <a href=\"https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md</a></li>\n</ul>\n<details>\n<strong>从零实现富文本编辑器系列文章</strong>\n<ul>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/18816107\" target=\"_blank\">深感一无所长，准备试着从零开始写个富文本编辑器</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/18826249\" target=\"_blank\">从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/18840221\" target=\"_blank\">从零实现富文本编辑器#3-基于Delta的线性数据结构模型</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/18899981\" target=\"_blank\">从零实现富文本编辑器#4-浏览器选区模型的核心交互策略</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/18921725\" target=\"_blank\">从零实现富文本编辑器#5-编辑器选区模型的状态结构表达</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/19022750\" target=\"_blank\">从零实现富文本编辑器#6-浏览器选区与编辑器选区模型同步</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/19069539\" target=\"_blank\">从零实现富文本编辑器#7-基于组合事件的半受控输入模式</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/19152103\" target=\"_blank\">从零实现富文本编辑器#8-浏览器输入模式的非受控DOM行为</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/19381254\" target=\"_blank\">从零实现富文本编辑器#9-编辑器文本结构变更的受控处理</a></li>\n<li><a href=\"https://www.cnblogs.com/WindrunnerMax/p/19470679\" target=\"_blank\">从零实现富文本编辑器#10-React视图层适配器的模式扩展</a></li>\n<li><a href=\"\" rel=\"noopener nofollow\">从零实现富文本编辑器#11-Immutable状态维护与增量渲染</a></li>\n</ul>\n</details>\n<h2 id=\"行级不可变状态\">行级不可变状态</h2>\n<p>在这里我们先不引入视图层的渲染问题，而是仅在<code>Model</code>层面上实现精细化的处理，具体来说就是实现不可变的状态对象，仅更新的节点才会被重新创建，其他节点则直接复用。由此想来此模块的实现颇为复杂，也并未引入<code>immer</code>等框架，而是直接处理的状态对象，因此先从简单的更新模式开始考虑。</p>\n<p>回到最开始实现的<code>State</code>模块更新文档内容，我们是直接重建了所有的<code>LineState</code>以及<code>LeafState</code>对象，然后在<code>React</code>视图层的<code>BlockModel</code>中监听了<code>OnContentChange</code>事件，以此来将<code>BlockState</code>的更新应用到视图层。</p>\n<pre><code class=\"language-js\">delta.eachLine((line, attributes, index) =&gt; {\n  const lineState = new LineState(line, attributes, this);\n  lineState.index = index;\n  lineState.start = offset;\n  lineState.key = Key.getId(lineState);\n  offset = offset + lineState.length;\n  this.lines[index] = lineState;\n});\n</code></pre>\n<p>这种方式简单直接，全量更新状态能够保证在<code>React</code>的状态更新，然而这种方式的问题在于性能。当文档内容非常大的时候，全量计算将会导致大量的状态重建，并且其本身的改变也会导致<code>React</code>的<code>diff</code>差异进而全量更新文档视图，这样的性能开销通常是不可接受的。</p>\n<p>那么通常来说我们就需要基于变更来确定状态的更新，首先我们需要确定更新的粒度，例如以行为基准则未变更的时候就直接取原有的<code>LineState</code>。相当于尽可能复用<code>Origin List</code>然后生成<code>Target List</code>，这样的方式自然可以避免部分状态的重建，尽可能复用原本的对象。</p>\n<p>整体思路大概是先执行变成生成最新的列表，然后分别设置旧列表和新列表的<code>row</code>和<code>col</code>两个指针值，然后更新时记录起始<code>row</code>，删除和新增自然是正常处理，对于更新则认为是先删后增。对于内容的处理则需要分别讨论单行和跨行的问题，中间部分的内容就作为重建的操作。</p>\n<p>最后可以将这部分增删<code>LineState</code>数据放置于<code>Changes</code>中，就可以得到实际增删的<code>Ops</code>了，这样我们就可以优化部分的性能，因为仅原列表和目标列表的中间部分才会重建，其他部分的行状态直接复用。此外这部分数据在<code>apply</code>的<code>delta</code>中是不存在的，同样可以认为是数据的补充。</p>\n<pre><code class=\"language-js\">  Origin List (Old)                          Target List (New)\n+-------------------+                      +-------------------+\n| [0] LineState A   | &lt;---- Retain ------&gt; | [0] LineState A   | (Reused)\n+-------------------+                      +-------------------+\n| [1] LineState B   |          |           | [1] LineState B2  | (Update)\n+-------------------+       Changes        |     (Modified)    | (Del C)\n| [2] LineState C   |          |           +-------------------+\n+-------------------+          V           | [2] NewState X    | (Inserted)\n| [3] LineState D   | ---------------\\     +-------------------+\n+-------------------+                 \\--&gt; | [3] LineState D   | (Reused)\n| [4] LineState E   | &lt;---- Retain ------&gt; | [4] LineState E   | (Reused)\n+-------------------+                      +-------------------+\n</code></pre>\n<p>那么这里实际上是存在非常需要关注的点，我们现在维护的是状态模型，也就是说所有的更新就不再是直接的<code>compose</code>，而是操作我们实现的状态对象。本质上我们是需要实现行级别的<code>compose</code>方法，这里的实现非常重要，假如我们对于数据的处理存在偏差的话，那么就会导致状态出现问题。</p>\n<p>此外在这种方式中，我们判断<code>LineState</code>是否需要新建则是根据整个行内的所有<code>LeafState</code>来重建的。也就是说这种时候我们是需要再次将所有的<code>op</code>遍历一遍，当然实际上由于最后还需要将<code>compose</code>后的<code>Delta</code>切割为行级别的内容，所以其实即使在应用变更后也最少需要再遍历两次。</p>\n<p>那么此时我们需要思考优化方向，首先是首个<code>retain</code>，在这里我们应该直接完整复用原本的<code>LineState</code>，包括处理后的剩余节点也是如此。而对于中间的节点，我们就需要为其独立设计更新策略，这部分理论上来说是需要完全独立处理为新的状态对象的，这样可以减少部分<code>Leaf Op</code>的遍历。</p>\n<pre><code class=\"language-js\">new Delta().retain(5).insert(\"xx\")\ninsert(\"123\"), insert(\"\\n\") // skip \ninsert(\"456\"), insert(\"\\n\") // new line state\n</code></pre>\n<p>其中，如果是新建的节点，我们直接构建新的<code>LineState</code>即可，删除的节点则不从原本的<code>LineState</code>中放置于新的列表。而对于更新的节点，我们需要更新原本的<code>LineState</code>对象，因为实际上行是存在更新的，而重点是我们需要将原本的<code>LineState</code>的<code>key</code>值复用。</p>\n<p>这里我们先简单实现实现描述一下复用的问题，比较方便的实现则是直接以<code>\\n</code>的标识为目标的<code>State</code>，这就意味着我们要独立<code>\\n</code>为独立的状态。即如果在<code>123|456\\n</code>的<code>|</code>位置插入<code>\\n</code>的话，那么我们就是<code>123</code>是新的<code>LineState</code>，<code>456</code>是原本的<code>LineState</code>，以此来实现<code>key</code>的复用。</p>\n<pre><code class=\"language-js\">[\n  insert(\"123\"), insert(\"\\n\"), \n  insert(\"456\"), insert(\"\\n\")\n]\n// ===&gt;\n[ \n  LineState(LeafState(\"123\"), LeafState(\"\\n\")), \n  LineState(LeafState(\"456\"), LeafState(\"\\n\"))\n]\n</code></pre>\n<p>其实这里有个非常值得关注的点是，<code>LineState</code>在<code>Delta</code>中是没有具体对应的<code>Op</code>的，而相对应的<code>LeafState</code>则是有具体的<code>Op</code>的。这就意味着我们在处理<code>LineState</code>的更新时，是不能直接根据变更控制的，因此必须要找到能够映射的状态，因此最简单的方案即根据<code>\\n</code>节点映射。</p>\n<pre><code class=\"language-js\">LeafState(\"\\n\", key=\"1\") &lt;=&gt; LineState(key=\"L1\")\n</code></pre>\n<p>实际上我们可以总结一下，最开始我们考虑先更新再<code>diff</code>，后来考虑的是边更新边记录。边更新边记录的优点在于，可以避免再次遍历一边所有<code>Leaf</code>节点的消耗，同时也可以避免<code>diff</code>的复杂性。但是这里也存在个问题，如果内部进行了多次<code>retain</code>操作，则无法直接复用<code>LineState</code>。</p>\n<p>不过通常来说，最高频的操作是输入内容，这种情况下首操作一般都是<code>retain</code>，尾操作为空会收集剩余文档内容，因此这部分优化是会被高频触发的。而如果是多次的内容部分变更操作，这部分虽然可以通过判断行内的叶子结点是否变更，来判断是否复用行对象，但是也存在一定复杂性。</p>\n<p>关于这部分的具体实现，在编辑器的状态模块里存在独立的<code>Mutate</code>模块，这部分实现在后边实现各个模块时会独立介绍。到这里我们就可以实现一个简单的<code>Immutable</code>状态维护，如果<code>Leaf</code>节点发生变化之后，其父节点<code>Line</code>会触发更新，而其他节点则可以直接复用。</p>\n<h2 id=\"key-值维护\">Key 值维护</h2>\n<p>至此我们实现了一套简单的<code>Immutable Delta+Iterator</code>来处理更新，这种时候我们就可以借助不可变的方式来实现<code>React</code>视图的更新，那么在<code>React</code>的渲染模式中，<code>key</code>值的管理也是个值的探讨的问题。</p>\n<p>在这里我们就可以根据状态不可变来生成<code>key</code>值，借助<code>WeakMap</code>映射关系获取对应的字符串<code>id</code>值，此时就可以借助<code>key</code>的管理以及<code>React.memo</code>来实现视图的复用。其实在这里初步看起来<code>key</code>值应该是需要主动控制强制刷新的时候，以及完全是新节点才会用得到的。</p>\n<p>但是这种方式也是有问题的，因为此时我们即使输入简单的内容，也会导致整个行的<code>key</code>发生改变，而此时我们是不必要更新此时的<code>key</code>的。因此<code>key</code>值是需要单独维护的，不能直接使用不可变的对象来索引<code>key</code>值，那么如果是直接使用<code>index</code>作为<code>key</code>值的话，就会存在潜在的原地复用问题。</p>\n<p><code>key</code>值原地复用会导致组件的状态被错误保留，例如此时有个非受控管理的<code>input</code>组件列表，在某个输入框内已经输入了内容，当其发生顺序变化时，原始输入内容会跟随着原地复用的策略留在原始的位置，而不是跟随到新的位置，因为其整体列表顺序<code>key</code>未发生变化导致<code>React</code>直接复用节点。</p>\n<p>在<code>LineState</code>节点的<code>key</code>值维护中，如果是初始值则是根据<code>state</code>引用自增的值，在变更的时候则是尽可能地复用原始行的<code>key</code>，这样可以避免过多的行节点重建并且可以控制整行的强制刷新。</p>\n<p>而对于<code>LeafState</code>节点的<code>key</code>值最开始是直接使用<code>index</code>值，这样实际上会存在隐性的问题，而如果直接根据<code>Immutable</code>来生成<code>key</code>值的话，任何文本内容的更改都会导致<code>key</code>值改变进而导致<code>DOM</code>节点的频繁重建。</p>\n<pre><code class=\"language-js\">export const NODE_TO_KEY = new WeakMap&lt;Object.Any, Key&gt;();\nexport class Key {\n  /** 当前节点 id */\n  public id: string;\n  /** 自动递增标识符 */\n  public static n = 0;\n\n  constructor() {\n    this.id = `${Key.n++}`;\n  }\n\n  /**\n   * 根据节点获取 id\n   * @param node\n   */\n  public static getId(node: Object.Any): string {\n    let key = NODE_TO_KEY.get(node);\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n    return key.id;\n  }\n}\n</code></pre>\n<p>通常使用<code>index</code>作为<code>key</code>是可行的，然而在一些非受控场景下则会由于原地复用造成渲染问题，<code>diff</code>算法导致的性能问题我们暂时先不考虑。在下面的例子中我们可以看出，每次我们都是从数组顶部删除元素，而实际的<code>input</code>值效果表现出来则是删除了尾部的元素，这就是原地复用的问题。在非受控场景下比较明显，而我们的<code>ContentEditable</code>组件就是一个非受控场景，因此这里的<code>key</code>值需要再考虑一下。</p>\n<pre><code class=\"language-js\">const { useState, Fragment, useRef, useEffect } = React;\nfunction App() {\n  const ref = useRef&lt;HTMLParagraphElement&gt;(null);\n  const [nodes, setNodes] = useState(() =&gt; Array.from({ length: 10 }, (_, i) =&gt; i));\n\n  const onClick = () =&gt; {\n    const [_, ...rest] = nodes;\n    console.log(rest);\n    setNodes(rest);\n  };\n\n  useEffect(() =&gt; {\n    const el = ref.current;\n    el &amp;&amp; Array.from(el.children).forEach((it, i) =&gt; ((it as HTMLInputElement).value = i + \"\"));\n  }, []);\n\n  return (\n    &lt;Fragment&gt;\n      &lt;p ref={ref}&gt;\n        {nodes.map((_, i) =&gt; (&lt;input key={i}&gt;&lt;/input&gt;))}\n      &lt;/p&gt;\n      &lt;button onClick={onClick}&gt;slice&lt;/button&gt;\n    &lt;/Fragment&gt;\n  );\n}\n</code></pre>\n<p>考虑到先前提到的我们不希望任何文本内容的更改都导致<code>key</code>值改变引发重建，因此就不能直接使用计算的<code>immutable</code>对象引用来处理<code>key</code>值，而描述单个<code>op</code>的方法除了<code>insert</code>就只剩下<code>attributes</code>了。</p>\n<p>但是如果基于<code>attributes</code>来获得就需要精准控制合并<code>insert</code>的时候取需要取旧的对象引用，且没有属性的<code>op</code>就不好处理了，因此这里可能只能将其转为字符串处理，但是这样同样不能保持<code>key</code>的完全稳定，因此前值的索引改变就会导致后续的值出现变更。</p>\n<pre><code class=\"language-js\">const prefix = new WeakMap&lt;LineState, Record&lt;string, number&gt;&gt;();\nconst suffix = new WeakMap&lt;LineState, Record&lt;string, number&gt;&gt;();\nconst mapToString = (map: Record&lt;string, string&gt;): string =&gt; {\n  return Object.keys(map)\n    .map(key =&gt; `${key}:${map[key]}`)\n    .join(\",\");\n};\nconst toKey = (state: LineState, op: Op): string =&gt; {\n  const key = op.attributes ? mapToString(op.attributes) : \"\";\n  const prefixMap = prefix.get(state) || {};\n  prefix.set(state, prefixMap);\n  const suffixMap = suffix.get(state) || {};\n  suffix.set(state, suffixMap);\n  const prefixKey = prefixMap[key] ? prefixMap[key] + 1 : 0;\n  const suffixKey = suffixMap[key] ? suffixMap[key] + 1 : 0;\n  prefixMap[key] = prefixKey;\n  suffixMap[key] = suffixKey;\n  return `${prefixKey}-${suffixKey}`;\n};\n</code></pre>\n<p>在<code>slate</code>中我先前认为生成的<code>key</code>跟节点是完全一一对应的关系，例如当<code>A</code>节点变化时，其代表的层级<code>key</code>必然会发生变化。然而在关注这个问题之后，我发现其在更新生成新的<code>Node</code>之后，会同步更新<code>Path</code>以及<code>PathRef</code>对应的<code>Node</code>节点所对应的<code>key</code>值。</p>\n<pre><code class=\"language-js\">for (const [pathRef, key] of pathRefMatches) {\n  if (pathRef.current) {\n    const [node] = Editor.node(e, pathRef.current)\n    NODE_TO_KEY.set(node, key)\n  }\n  pathRef.unref()\n}\n</code></pre>\n<p>在后续观察<code>Lexical</code>实现的选区模型时，发现其是用<code>key</code>值唯一地标识每个叶子结点的，选区也是基于<code>key</code>值来描述的。整体表达上比较类似于<code>Slate</code>的选区结构，或者说是<code>DOM</code>树的结构。这里仅仅是值得<code>Range</code>选区，<code>Lexical</code>实际上还有其他三种选区类型。</p>\n<pre><code class=\"language-js\">{\n  anchor: { key: \"51\", offset: 2, type: \"text\" },\n  focus: { key: \"51\", offset: 3, type: \"text\" }\n}\n</code></pre>\n<p>在这里比较重要的是<code>key</code>值变更时的状态保持，因为编辑器的内容实际上是需要编辑的。然而如果做到<code>immutable</code>话，很明显直接根据状态对象的引用来映射<code>key</code>会导致整个编辑器<code>DOM</code>无效的重建。例如调整标题的等级，就由于整个行<code>key</code>的变化导致整行重建。</p>\n<p>那么如何尽可能地复用<code>key</code>值就成了需要研究的问题，我们的编辑器行级别的<code>key</code>是被特殊维护的，即实现了<code>immutable</code>以及<code>key</code>值复用。而目前叶子状态的<code>key</code>依赖了<code>index</code>值，因此如果调研<code>Lexical</code>的实现，同样可以将其应用到我们的<code>key</code>值维护中。</p>\n<p>通过在<code>playground</code>中调试可以发现，即使我们不能得知其是否为<code>immutable</code>的实现，依然可以发现<code>Lexical</code>的<code>key</code>是以一种偏左的方式维护。因此在我们的编辑器实现中，也可以借助同样的方式，合并直接以左值为准复用，拆分时若以<code>0</code>起始直接复用，起始非<code>0</code>则创建新<code>key</code>。</p>\n<ol>\n<li><code>[123456(key1)][789(bold-key2)]</code>文本，将<code>789</code>的加粗取消，整段文本的<code>key</code>值保持为<code>key1</code>。</li>\n<li><code>[123456789(key1)]]</code>文本，将<code>789</code>这段文本加粗，左侧<code>123456</code>文本的<code>key</code>值保持为<code>key1</code>，<code>789</code>则是新的<code>key</code>。</li>\n<li><code>[123456789(key1)]]</code>文本，将<code>123</code>这段文本加粗，左侧<code>123</code>文本的<code>key</code>值保持为<code>key1</code>，<code>456789</code>则是新的<code>key</code>。</li>\n<li><code>[123456789(key1)]]</code>文本，将<code>456</code>这段文本加粗，左侧<code>123</code>文本的<code>key</code>值保持为<code>key1</code>，<code>456</code>和<code>789</code>分别是新的<code>key</code>。</li>\n</ol>\n<p>因此，此时在编辑器中我们也是用类似偏左的方式维护<code>key</code>，由于我们需要保持<code>immutable</code>，所以这里的表达实际上是尽可能复用先前的<code>key</code>状态。这里与<code>LineState</code>的<code>key</code>值维护方式类似，都是先创建状态然后更新其<code>key</code>值，当然还有很多细节的地方需要处理。</p>\n<pre><code class=\"language-js\">// 起始与裁剪位置等同 NextOp =&gt; Immutable 原地复用 State\nif (offset === 0 &amp;&amp; op.insert.length &lt;= length) {\n  return nextLeaf;\n}\nconst newLeaf = new LeafState(retOp, nextLeaf.parent);\n// 若 offset 是 0, 则直接复用原始的 key 值\noffset === 0 &amp;&amp; newLeaf.updateKey(nextLeaf.key);\n</code></pre>\n<p>这里还存在另一个小问题，我们创建<code>LeafState</code>就立即去获得对应的<code>key</code>值，然后再考虑去复用原始的<code>key</code>值。这样其实就会导致很多不再使用的<code>key</code>值被创建，导致每次更新的时候看起来<code>key</code>的数字差值比较大。当然这并不影响整体的功能与性能，只是调试的时候看起来比较怪。</p>\n<p>因此我们在这里还可以优化这部分表现，也就是说我们在创建的时候不会去立即创建<code>key</code>值，而是在初始化以及更新的时候再从外部设置其<code>key</code>值。这个实现其实跟<code>index</code>、<code>offset</code>的处理方式比较类似，我们整体在<code>update</code>时处理所有的相关值，且开发模式渲染时进行了严格检查。</p>\n<pre><code class=\"language-js\">// BlockState\nlet offset = 0;\nthis.lines.forEach((line, index) =&gt; {\n  line.index = index;\n  line.start = offset;\n  line.key = line.key || Key.getId(line);\n  const size = line.isDirty ? line.updateLeaves() : line.length;\n  offset = offset + size;\n});\nthis.length = offset;\nthis.size = this.lines.length;\n</code></pre>\n<pre><code class=\"language-js\">// LineState\nlet offset = 0;\nconst ops: Op[] = [];\nthis.leaves.forEach((leaf, index) =&gt; {\n  ops.push(leaf.op);\n  leaf.offset = offset;\n  leaf.parent = this;\n  leaf.index = index;\n  offset = offset + leaf.length;\n  leaf.key = leaf.key || Key.getId(leaf);\n});\nthis._ops = ops;\nthis.length = offset;\nthis.isDirty = false;\nthis.size = this.leaves.length;\n</code></pre>\n<p>此外，在实现单元测试时还发现，在<code>leaf</code>上独立维护了<code>key</code>值，那么<code>\\n</code>这个特殊的节点自然也会有独立的<code>key</code>值。这种情况下在<code>line</code>级别上维护的<code>key</code>值倒是也可以直接复用<code>\\n</code>这个<code>leaf</code>的<code>key</code>值。当然这只是理论上的实现，可能会导致一些意想不到的刷新问题。</p>\n<h2 id=\"视图增量渲染\">视图增量渲染</h2>\n<p>在视图模块最开始的设计上，我们的状态管理形式是直接全量更新<code>Delta</code>，然后使用<code>EachLine</code>遍历重建所有的状态。并且实际上我们维护了<code>Delta</code>与<code>State</code>两个数据模型，建立其关系映射关系本身也是一种损耗，渲染的时候的目标状态是<code>Delta</code>而非<code>State</code>。</p>\n<p>这样的模型必然是耗费性能的，每次<code>Apply</code>的时候都需要全量更新文档并且再次遍历分割行状态。当然实际上只是计算迭代的话，实际上是不会太过于耗费性能，但是由于我们每次都是新的对象，那么在更新视图的时候，更容易造成性能的损耗，计算的性能通常可接受，而视图更新操作<code>DOM</code>成本更高。</p>\n<p>实际上，我们上边复用其<code>key</code>值，解决的问题是避免整个行状态视图<code>re-mount</code>。而即使复用了<code>key</code>值，因为重建了整个<code>State</code>实例，<code>React</code>也会继续后边的<code>re-render</code>流程。因此我们在这里需要解决的问题是，如何在无变更的情况下尽可能避免其视图<code>re-render</code>。</p>\n<p>由于我们实现了行级不可变状态维护，那么在视图中就可以直接对比状态对象的引用是否变化来决定是否需要重渲染。因此只需要对于<code>ViewModel</code>的节点补充了<code>React.memo</code>，在这个场景下甚至于不需要重写对比函数，只需要依赖我们的<code>immutable</code>状态复用能够正常起到效果。</p>\n<pre><code class=\"language-js\">const LeafView: FC&lt;{ editor: Editor; leafState: LeafState; }&gt; = props =&gt; {\n  return (\n    &lt;span {...{ [LEAF_KEY]: true }} &gt;\n      {runtime.children}\n    &lt;/span&gt;\n  );\n}\nexport const LeafModel = React.memo(LeafView);\n</code></pre>\n<p>同样的，针对<code>LineView</code>也需要补充<code>memo</code>，而且由于组件内本身可能存在状态变化，例如<code>Composing</code>组合输入的控制，所以针对于内部节点的计算也会采用<code>useMemo</code>来缓存结果，避免重复计算。</p>\n<pre><code class=\"language-js\">const LineView: FC&lt;{ editor: Editor; lineState: LineState; }&gt; = props =&gt; {\n  const elements = useMemo(() =&gt; {\n     // ...\n    return nodes;\n  }, [editor, lineState]);\n  return (\n    &lt;div {...{ [NODE_KEY]: true }} &gt;\n      {elements}\n    &lt;/div&gt;\n  );\n}\nexport const LineModel = React.memo(LineView);\n</code></pre>\n<p>而视图刷新仍然还是直接控制<code>lines</code>这个状态的引用即可，相当于核心层的内容变化与视图层的重渲染，是直接依赖于事件模块通信就可以实现的。由于每次取<code>lines</code>状态时都是新的引用，所以<code>React</code>会认为状态发生了变化，从而触发重渲染。</p>\n<pre><code class=\"language-js\">const onContentChange = useMemoFn(() =&gt; {\n  if (flushing.current) return void 0;\n  flushing.current = true;\n  Promise.resolve().then(() =&gt; {\n    flushing.current = false;\n    setLines(state.getLines());\n  });\n});\n</code></pre>\n<p>而虽然触发了渲染，但是由于<code>key</code>以及<code>memo</code>的存在，会以<code>line</code>的状态为基准进行对比。只有<code>LineState</code>对象的引用发生了变化，<code>LineModel</code>视图才会触发更新逻辑，否则会复用原有的视图，这部分我们可以直接依赖<code>React</code>的<code>devtools</code>录制或<code>Highlight</code>就可以观察到。</p>\n<p>视图增量更新这部分其实比较简单，主要是实现不可变对象以及<code>key</code>值维护的逻辑都在核心层实现，视图层主要是依赖其做计算，对比是否需要重渲染。其实类似的实现在低代码的场景中也可以应用，毕竟实际上富文本也就是相当于一个零代码的编辑器，只不过组装的不是组件而是文本。</p>\n<h2 id=\"总结\">总结</h2>\n<p>在先前我们主要讨论了视图层的适配器设计，主要是全量的视图初始化渲染，以及状态模型到<code>DOM</code>结构性的规则设定。在这里则主要考虑更新处理时性能的优化，主要是在增量更新时，如何最小化<code>DOM</code>以及<code>Op</code>操作、<code>key</code>值的维护、以及在<code>React</code>中实现增量渲染的方式。</p>\n<p>其实接下来需要考虑输入内容时，如何避免规定的<code>DOM</code>的结构被破坏，主要涉及脏<code>DOM</code>检查、选区更新、渲染<code>Hook</code>等，这部分内容在<code>#8</code>和<code>#9</code>的输入法处理中已经有了详细的讨论，因此这里就不再次展开了。</p>\n<p>那么接下来我们需要讨论的是编辑节点的组件预设，例如零宽字符、<code>Embed</code>节点、<code>Void</code>节点等。主要是为编辑器的插件扩展提供预设的组件，在这些组件内存在一些默认的行为，并且同样预设了部分<code>DOM</code>结构，以此来实现在规定范围内的编辑器操作。</p>\n<h2 id=\"每日一题\">每日一题</h2>\n<ul>\n<li><a href=\"https://github.com/WindRunnerMax/EveryDay\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/WindRunnerMax/EveryDay</a></li>\n</ul>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://18.react.dev/\" rel=\"noopener nofollow\" target=\"_blank\">https://18.react.dev/</a></li>\n<li><a href=\"https://18.react.dev/reference/react/memo\" rel=\"noopener nofollow\" target=\"_blank\">https://18.react.dev/reference/react/memo</a></li>\n<li><a href=\"https://18.react.dev/reference/react/useMemo\" rel=\"noopener nofollow\" target=\"_blank\">https://18.react.dev/reference/react/useMemo</a></li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-09 10:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/WindrunnerMax\">WindRunnerMax</a>&nbsp;\n阅读(<span id=\"post_view_count\">6</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI开发-python-langchain框架（1-13 返回xml-格式解析器）",
      "link": "https://www.cnblogs.com/yclh/p/19594030",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yclh/p/19594030\" id=\"cb_post_title_url\" title=\"发布于 2026-02-09 10:34\">\n    <span>AI开发-python-langchain框架（1-13 返回xml-格式解析器）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>有的时候xml格式也是开发中是比较普遍的数据格式，如何让大模型返回的数据是标准的xml格式？</p>\n<p>看如下代码：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">from langchain.prompts import PromptTemplate\nfrom langchain_openai import ChatOpenAI\nfrom langchain.output_parsers import XMLOutputParser\nimport os\n\nllm = ChatOpenAI(\n    api_key=os.getenv(\"DEEPSEEK_API_KEY\"),\n    base_url=os.getenv(\"BASE_URL\"),\n    model=\"deepseek-v3:671b\",\n    temperature=0.7,\n    max_tokens=1024\n)\n\n# 修正 XML 格式指令：结束标签必须是 &lt;/xml&gt;\nformat_instructions = \"\"\"请严格按照以下XML格式返回结果，仅输出XML内容，不要包含任何其他文字或说明：\n\n&lt;xml&gt;\n  &lt;movie&gt;电影名称1&lt;/movie&gt;\n  &lt;movie&gt;电影名称2&lt;/movie&gt;\n  &lt;!-- 可包含多个 movie 标签 --&gt;\n&lt;/xml&gt;\"\"\"\n\nprompt = PromptTemplate(\n    template=\"{format_instructions}\\n\\n用户请求：{query}\",\n    input_variables=[\"query\"],\n    partial_variables={\"format_instructions\": format_instructions},\n)\n\nactor_query = \"生成陈道明的电影目录。\"\n\n#输出提示词\nprint('#######################')\nprint(prompt.invoke({\"query\": actor_query}).text)\nprint('#######################')\n\n\n\nchain = prompt | llm | XMLOutputParser()\n\n\nresult = chain.invoke({\"query\": actor_query})\nprint('----------------------')\nprint(\"解析成功，结果：\")\nprint(result)\n</pre>\n</div>\n<p>&nbsp;返结果：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">#######################\n请严格按照以下XML格式返回结果，仅输出XML内容，不要包含任何其他文字或说明：\n\n&lt;xml&gt;\n  &lt;movie&gt;电影名称1&lt;/movie&gt;\n  &lt;movie&gt;电影名称2&lt;/movie&gt;\n  &lt;!-- 可包含多个 movie 标签 --&gt;\n&lt;/xml&gt;\n\n用户请求：生成陈道明的电影目录。\n#######################\n----------------------\n解析成功，结果：\n{'xml': [{'movie': '英雄'}, {'movie': '无间道3：终极无间'}, {'movie': '归来'}, {'movie': '唐山大地震'}, {'movie': '康熙王朝'}, {'movie': '围城'}, {'movie': '我的1919'}, {'movie': '楚汉传奇'}]}\n</pre>\n</div>\n<p>&nbsp;一个标准的xml格式返回</p>\n<p>更多学习资料尽在老虎网盘资源：http://resources.kittytiger.cn/ <a href=\"http://resources.kittytiger.cn/\" rel=\"noopener nofollow\" target=\"_blank\">老虎网盘资源</a></p>\n<p><span style=\"font-size: 18pt;\"><strong>重点知识：</strong></span></p>\n<h3 class=\"qwen-markdown-heading\"><span class=\"qwen-markdown-text\">代码结构与功能概述</span></h3>\n<div class=\"qwen-markdown-paragraph\"><span class=\"qwen-markdown-text\">本段代码构建了一个基于 LangChain 的结构化数据生成管道，核心目标是让大语言模型（LLM）以<strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">严格标准的 XML 格式</span></strong><span class=\"qwen-markdown-text\">返回陈道明参演的电影列表。整个流程通过提示词工程、模型调用与输出解析三步协同，确保最终结果可直接被程序解析使用，避免非结构化文本带来的处理负担。</span></span></div>\n&nbsp;\n<h3 class=\"qwen-markdown-heading\"><span class=\"qwen-markdown-text\">提示词模板：强制 XML 格式输出</span></h3>\n<div class=\"qwen-markdown-paragraph\"><span class=\"qwen-markdown-text\">代码通过 <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">PromptTemplate</code><span class=\"qwen-markdown-text\"> 显式定义格式指令（<code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">format_instructions</code><span class=\"qwen-markdown-text\">），要求模型： </span></span></span></div>\n<ol class=\"qwen-markdown-list\" dir=\"auto\" start=\"1\">\n<li><strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">仅输出 XML 内容</span></strong><span class=\"qwen-markdown-text\">，禁止附加说明、注释或多余文字； </span></li>\n<li><strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">使用标准 XML 标签结构</span></strong><span class=\"qwen-markdown-text\">，以 <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">&lt;xml&gt;</code><span class=\"qwen-markdown-text\"> 为根节点，每个电影名称包裹在独立的 <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">&lt;movie&gt;</code><span class=\"qwen-markdown-text\"> 子标签中； </span></span></span></li>\n<li><strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">严格闭合标签</span></strong><span class=\"qwen-markdown-text\">，如 <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">&lt;/xml&gt;</code><span class=\"qwen-markdown-text\"> 结束根节点，避免格式错误。<br /><span class=\"qwen-markdown-text\">这种设计从源头约束模型行为，大幅降低后续解析失败风险。</span></span></span></li>\n\n</ol><br />\n<h3 class=\"qwen-markdown-heading\"><span class=\"qwen-markdown-text\">模型调用：定向生成结构化内容</span></h3>\n<div class=\"qwen-markdown-paragraph\"><span class=\"qwen-markdown-text\">选用 <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">deepseek-v3:671b</code><span class=\"qwen-markdown-text\"> 模型并设置 <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">temperature=0.7</code><span class=\"qwen-markdown-text\">，在保证创造性的同时维持输出稳定性。关键点在于：  </span></span></span></div>\n<ul class=\"qwen-markdown-list\" dir=\"auto\">\n<li><span class=\"qwen-markdown-text\">提示词中明确用户请求（“生成陈道明的电影目录”）与格式指令分离，使模型聚焦于<strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">内容生成</span></strong><span class=\"qwen-markdown-text\">与<strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">格式遵循</span></strong><span class=\"qwen-markdown-text\">双重任务；  </span></span></span></li>\n<li><span class=\"qwen-markdown-text\">通过 <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">max_tokens=1024</code><span class=\"qwen-markdown-text\"> 限制输出长度，避免冗余信息干扰 XML 结构完整性。</span></span></li>\n\n</ul>\n<br />\n<h3 class=\"qwen-markdown-heading\"><span class=\"qwen-markdown-text\">输出解析器：验证并转换 XML 数据</span></h3>\n<div class=\"qwen-markdown-paragraph\"><code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">XMLOutputParser</code><span class=\"qwen-markdown-text\"> 作为链式调用的最终环节，承担双重职责：  </span></div>\n<ol class=\"qwen-markdown-list\" dir=\"auto\" start=\"1\"><ol class=\"qwen-markdown-list\" dir=\"auto\" start=\"1\">\n<li><strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">格式校验</span></strong><span class=\"qwen-markdown-text\">：自动检测 XML 标签闭合性、嵌套合法性，若模型输出不符合标准（如缺失结束标签），将抛出解析异常；  </span></li>\n<li><strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">结构化转换</span></strong><span class=\"qwen-markdown-text\">：将原始 XML 字符串转换为 Python 字典（如 <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">{'xml': {'movie': ['电影A', '电影B']}}</code><span class=\"qwen-markdown-text\">），便于程序直接提取数据，无需手动正则匹配。</span></span></li>\n\n</ol></ol>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-09 10:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yclh\">万笑佛</a>&nbsp;\n阅读(<span id=\"post_view_count\">13</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}