{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "让WinForms再次伟大",
      "link": "https://www.cnblogs.com/xdesigner/p/19438384/Make_WinForms_Great_Again",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xdesigner/p/19438384/Make_WinForms_Great_Again\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 15:49\">\n    <span>让WinForms再次伟大</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"postText\">    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本项目就是专门帮助将WinForms 应用程序迁移到 Blazor WASM平台上，即使这些程序使用GDI+功能，我们也预期将对这些程序源码的修改量不超过10%。这极大的降低WinForms软件现代化的成本和风险。\n我们的长期目标是能将全球1000亿行经过市场验证的C#代码能重获新生，在现代Web前端平台上继续发挥价值。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"让-winforms-再次伟大-httpsgithubcomdcsoft-yyfmwga\">让 WinForms 再次伟大 <a href=\"https://github.com/dcsoft-yyf/MWGA\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/dcsoft-yyf/MWGA</a></h1>\n<h2 id=\"更新日志\">更新日志</h2>\n<ul>\n<li>2026-1-4 :第一滴血 <a href=\"https://dcsoft-yyf.github.io/MWGA/WinFormCalculator.html\" rel=\"noopener nofollow\" target=\"_blank\">https://dcsoft-yyf.github.io/MWGA/WinFormCalculator.html</a></li>\n</ul>\n<h2 id=\"全球-winforms-现代化现状\">全球 WinForms 现代化现状</h2>\n<p>全球范围内，估计WinForms开发者约有300万至500万人，占.NET开发者总数的40%至50%。生产环境中运行着1000万至1500万个WinForms应用程序。在这些应用中，60%至80%有现代化改造需求，其中40%至60%优先选择Web化迁移，涉及的C#代码可能有<code>数千亿行</code>。核心驱动因素包括网页端访问、界面现代化、跨平台支持、云集成和安全合规。由于可复用C#代码且具备基于浏览器的跨平台能力，Blazor WebAssembly成为热门选择。</p>\n<p>但是有大量的WinForms使用了<code>System.Drawing</code>模块调用<code>GDI+</code>进行复杂的自定义绘图和交互，这些部分难以通过简单的控件映射迁移，通常需要重写或大幅修改。为此，市场上对低改动、可复用业务逻辑和绘图代码的现代化迁移解决方案需求强烈。但长期以来一直缺乏有效工具和方法，导致许多企业面临高昂的重写成本和风险。</p>\n<h2 id=\"项目简介\">项目简介</h2>\n<p>本项目就是专门帮助将WinForms 应用程序迁移到 Blazor WASM平台上，即使这些程序使用GDI+功能，我们也预期将对这些程序源码的修改量不超过<code>10%</code>。这极大的降低WinForms软件现代化的成本和风险。</p>\n<p>我们的长期目标是能将全球<code>1000亿</code>行经过市场验证的C#代码能重获新生，在现代Web前端平台上继续发挥价值。</p>\n<h2 id=\"全球待迁移-winforms-应用市场规模估算美元\">全球待迁移 WinForms 应用市场规模估算（美元）</h2>\n<p>假设需要迁移的 WinForms 应用约 50 万 – 200 万 个；应用复杂度分布：简单 60%、中等 30%、复杂 10%。</p>\n<ul>\n<li>按示例单应用迁移成本中位数估算（美元）：加权均价约 5.5 万美元/应用。</li>\n<li>TAM（总可寻址市场）估算：约 275 亿 – 1,100 亿 美元（50 万 – 200 万 应用 × 5.5 万美元）。</li>\n<li>工具/许可模式可寻址市场（5 千 – 2 万 美元/应用）：约 25 亿 – 400 亿 美元。</li>\n<li>复杂应用（10%）市场：约 5 万 – 20 万 个，按每例 15 万美元计约 75 亿 – 300 亿 美元。</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n</div>\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-01-04 15:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xdesigner\">袁永福 电子病历，医疗信息化</a>&nbsp;\n阅读(<span id=\"post_view_count\">82</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "读写分离面临的问题及其解决方案",
      "link": "https://www.cnblogs.com/huang-changfan/p/19185323",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/huang-changfan/p/19185323\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 15:48\">\n    <span>读写分离面临的问题及其解决方案</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"1读写分离带来的问题及解决方法\">1.读写分离带来的问题及解决方法</h1>\n<h2 id=\"11-延时问题\">1.1 延时问题</h2>\n<p>主从复制，主库与从库之间由于网络，设备差异，负载情况等，必然存在延时，延时有大有小，只要延时保持再一个合理的范围内是可以接受的。</p>\n<p>1.1.1造成主从延时的参见原因</p>\n<ul>\n<li>主从设备差异：例如主库性能较好，从库性能较差，对于同样的写入或更新操作，主库能较快完成，从库花费时间较多，如果系统持续维持高频的写入更新，主库与从库之间的差异会被逐渐拉大。导致主从的延迟越来越大。对于这种情况，需要尽量保证主从服务器性能一致，使得两种处理相同量的数据花费的时间尽可能接近。这样一般情况而言主从延时可以保证在一个合理范围，不会出现很大的差异。</li>\n<li>从库上执行了过多任务：由于从库是只读的，加上相比于主库而言重要性没那么高，所以其他系统可能会从库进行大量的数据同步或分析业务，导致从库被占用过多资源，处理从主库同步过来的日志较慢，造成了延迟。此时需要注意从库的压力，考虑负载均衡或采用其他方式使得从库负载不要太高，造成较长延迟。</li>\n<li>大事务：如果主库执行一个要更新或删除大量数据的SQL，例如主库都需要执行20s.那么对于语句或数据（取决于binlog格式）复制到从库，从库也需要执行20s.这样主从之间就天然的存在一个延迟，这个延时由事务的执行时间决定。所以需要避免大事务，开发过程中就需要注意，同时需要添加监控，对于执行情况进行监控预警。</li>\n</ul>\n<p>提高从库复制性能的方法：从库的io线程通过读取主库的日志，然后sql线程将读取日志内容执行，如果执行sql的线程是单线程执行效率会偏低。主库写入时是可以并发写入的，如果从库执行采用多线程执行，可以提高从库的复制效率降低延迟。MySQL会判断可以并发执行的部分语句使用多个线程并发执行。</p>\n<h2 id=\"12--读写分离的挑战读一致性\">1.2  读写分离的挑战：读一致性</h2>\n<p>主从的延迟总会存在，那么一个操作写入主库，此时从从库读取数据，可能读到可能读不到，这取决于从库的延迟以及读取的时机。如果主从延迟大于，写入主库与读取从库的间隔，那么读取的从库就不会存在这次写入操作。反之就可以读取到这次写入操作。这两种情况存在一定的随机成分，例如用户写入主库后，很快进行了读取，可能这次读取的从库没有当前的写入数据。如果用户隔了一段时间才读取，这次可能可以在从库中读取对于的操作。<br />\n由此引发了读一致的问题，有些操作可以接受一定程度的延迟，有些操作不能接收延迟，需要保证写后立即可见。</p>\n<h3 id=\"121-读之所写\">1.2.1 读之所写</h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1435315/202511/1435315-20251129211311701-1878061974.png\" /><br />\n例如用户编辑自己的主页信息，保存后刷新页面获取自己的主页信息。第一个操作是写操作，请求会被路由到主库，第二个操作是读操作会被路由到从库。<br />\n如果主库与从库之间存在延时，且第二次读取操作的从库还没有及时同步主库的数据，此时就会出现怪异的现象，用户编辑后执行保存，提示保存成功。但他刷新页面，发现页面还是修改前的信息。<br />\n这显然会对用户造成困扰，或者所一致性被破坏，记录提示了用户保存成功，那么刷新页面读取时应该读取到保存的数据，但实际情况确没有读取到。这种不一致性可能还会导致用户重复操作，造成损失，例如用户执行一个操作提示成功，然后用户查询，发现没有记录刚才的操作，他可能会再次执行这个操作，后续主从同步完毕后，他会查询到两次操作，可他的预期是只进行一次操作。<br />\n针对用户写入后，需要读取到自己写入的最新数据，这种读一致性称为读己所写。</p>\n<p>如何保证读己所写的隔离级别？</p>\n<ul>\n<li>读主库：简单粗暴直接读主库，如果当前的读操作对一致性要去较高，直接读主库，这次请求肯定保证读的一致性，对于同一个实例就不存在一致性问题了。但其缺点也很明显，读写分离是为了将读操作路由到从库，降低主库负载，使得系统提供更多的吞吐量。如果多数读请求最后还是被路由到了主库，扩展性降低了，大量操作都依赖主库，没有被剥离出来。</li>\n<li>判断主从点位，选择合适的从库<br />\n例如用户写入主库后，当前bindlog的点位是100.执行<code>show slave status;</code>获取从库同步主库的点位信息，如果当前从库的点位信息大于等于主库，那么主库之前的写操作在该从库是可见的。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1435315/202511/1435315-20251129213640521-349884627.png\" /><br />\n例如上图，如果主库写入的时的点位小于等于当前从库的点位，那么此次读取操作对之前的写入操作可见。<br />\n当然，如果主从延时比较大，例如30s.不可能等到从库同步好之后再查询从库，延时较大情况，指定时间内没有满足条件的从库需要触发降级逻辑，可直接查询主库。同时添加好监控，延时达到上限需要告警，同时统计好路由从库失败被转发到主库的操作，想办法优化对应问题。</li>\n</ul>\n<p>当然也不是所有的操作需要读己所写，还需要根据具体业务情况分析。以上例为例，对于用户编辑自己主页信息，对于用户本人来说肯定是需要读己所写的。当对于其他人来说则不需要读己所写，访问其他人的主页，由于自己不可能编辑他人的主页，所以主页的写操作对他人来说是不可见的，此时直接读取从库即可，等待从库同步好对应数据后，才读取最新数据也是可以接受的。这样看读取其他用户的主页似乎没有问题，何时同步好就何时读取最新数据，但是存在多个从库又会带来新的问题，这就是下一节的单调读问题。</p>\n<h3 id=\"122基于sharding-jdbc实现读之所写\">1.2.2基于sharding jdbc实现读之所写。</h3>\n<ul>\n<li>基本环境：一主两从基于jdbc。主库3310端口，从库3311，3312端口.</li>\n<li>实现思路：自定义从库选择算法，如果需要读己所写，将请求路由到合适的从库，如果没有从库符合条件，路由到主库。</li>\n<li>整体流程：\n<ol>\n<li>定时Job读取主库从库点位信息记录在Redis中。</li>\n<li>对于需要记录点位信息的写操作添加注解，写入后记录事务提交时的点位信息</li>\n<li>读请求添加注解，标识当前请求是否需要读之所写，记录在上下文中。</li>\n<li>根据当前用户写入操作时记录的点位，选择合适的从库，如果没有符合条件的，降级到主库。</li>\n</ol>\n</li>\n</ul>\n<pre><code>    /**  \n     * 1.定时Job读取主库从库点位信息记录在Redis中。\n     * 每500ms刷新主库与库点位信息\n     *\n     * @throws SQLException\n     */\n    @Scheduled(fixedRate = 5000) // 每500ms更新一次\n    public void refreshSlavePositon() throws SQLException {\n        log.info(\"zookeeper info ={}\", JSON.toJSONString(this.zookeeperCurrentVersionInfoHolder));\n        //写入从库点位\n        Map&lt;String, Connection&gt; slaveConnection = getSlaveConnection();\n        slaveConnection.forEach((slaveName, connection) -&gt; {\n            try {\n                log.info(\"slave={} url={}\", slaveName, connection.getMetaData().getURL());\n            } catch (SQLException e) {\n                throw new RuntimeException(e);\n            }\n            BinlogPosition binlogPosition = this.getSlaveBinLogPoint(connection);\n            redisTemplate.&lt;String, String&gt;opsForHash().put(slavesPositionInfoCachePreKey, slaveName, JSON.toJSONString(binlogPosition));\n        });\n\n        //写入主库点位\n        Connection masterConnection = getMasterConnection();\n        log.info(\"masterConnection url={}\", masterConnection.getMetaData().getURL());\n        BinlogPosition binlogPosition = this.getMasterBinLogPoint(masterConnection);\n        redisTemplate.&lt;String, String&gt;opsForHash().put(slavesPositionInfoCachePreKey, MASTER_DB_NAME, JSON.toJSONString(binlogPosition));\n    }\n</code></pre>\n<pre><code>/**\n * 2.对于需要记录点位信息的写操作添加注解，写入后记录事务提交时的点位信息\n */\n@Slf4j\n@Aspect\n@Component\npublic class CacheUserBinlogPositionAspect {\n\n    @Autowired\n    private BinlogPositionService binLogService;\n\n    @Pointcut(\"@annotation(com.example.annotation.CacheUserBinlogPosition)\")\n    public void cacheUserMasterPositionCut() {\n    }\n\n    @AfterReturning(pointcut = \"cacheUserMasterPositionCut()\", returning = \"result\")\n    public Object cacheMasterPosition(JoinPoint joinPoint, Object result) throws Throwable {\n        String uid = UserManager.getUid();\n\n        // 注册事务回调，由于执行到改切面时，事务的切面还没有提交，所以需要注册事务提交后执行获取点位方法，以确保获取提交后的点位信息\n        TransactionSynchronizationManager.registerSynchronization(\n                new TransactionSynchronization() {\n                    @Override\n                    public void afterCommit() {\n                        // 在事务提交后执行\n                        try {\n                            //获取主库点位\n                            BinlogPosition masterDBPosition = binLogService.getMasterBinLogPoint();\n                            //缓存当前用户主库点位\n                            binLogService.cacheUserBinlogPosition(uid, masterDBPosition);\n                        } catch (Exception e) {\n                            log.error(\"记录binlog点位失败\", e);\n                        }\n                    }\n                }\n        );\n\n        return result;\n    }\n}\n</code></pre>\n<pre><code>/**\n * 3. 读请求添加注解，标识当前请求是否需要读之所写，记录在上下文中。\n */\n@Slf4j\n@Aspect\n@Component\npublic class ReadConsistencyAspect {\n\n    @Pointcut(\"@annotation(com.example.annotation.ReadSelfWrite)\")\n    public void readSelfWritePointCut() {\n    }\n\n    @Before(value = \"readSelfWritePointCut()\")\n    public void readSelfWritePoint(JoinPoint joinPoint) throws Throwable {\n        //对于标注了读己所写的接口，上下文中设置对应属性\n        ReadConsistencyManager.setReadSelfWrite();\n    }\n}\n</code></pre>\n<pre><code>  /**\n   *4. 根据当前用户写入操作时记录的点位，选择合适的从库，如果没有符合条件的，降级到主库。\n  */\n  @Slf4j\npublic class BinlogAwareLoadBalanceAlgorithm implements ReadQueryLoadBalanceAlgorithm {\n\n    private Properties properties;\n\n    @Override\n    public Properties getProps() {\n        return this.properties;\n\n    }\n\n    @Override\n    public void init(Properties properties) {\n        this.properties = properties;\n    }\n\n    @Override\n    public String getType() {\n        return \"BINLOG_AWARE\";\n    }\n\n    /**\n     * read query load-balance algorithm.\n     * @param name read query logic data source name\n     * @param writeDataSourceName name of write data source\n     * @param readDataSourceNames names of read data sources\n     * @param context context\n     * @return\n     */\n    @Override\n    public String getDataSource(String name, String writeDataSourceName, List&lt;String&gt; readDataSourceNames, TransactionConnectionContext context) {\n        return this.getDataSource(name, writeDataSourceName, readDataSourceNames);\n    }\n\n    /**\n     * 选择数据源的核心方法\n     *\n     * @param name                read query logic data source name\n     * @param writeDataSourceName 主库名称\n     * @param readDataSourceNames 从库名称列表\n     * @return 选择的数据源名称\n     */\n    public String getDataSource(String name, String writeDataSourceName, List&lt;String&gt; readDataSourceNames) {\n        try {\n            if (ReadConsistencyManager.readSelfWrite()) {\n                //要求读之所写\n                return getDb(writeDataSourceName, readDataSourceNames);\n            } else {\n                //不要求读之所写\n                return loadBalance(readDataSourceNames);\n            }\n        } finally {\n            //清理Thread Local\n            ReadConsistencyManager.clear();\n        }\n    }\n\n    /**\n     * 获取大于等于用户当前存储点位信息的从库，如果没有从库满足条件，返回主库。存储的点位不不会过期情况下。\n     * @param writeDataSourceName\n     * @param readDataSourceNames\n     * @return\n     */\n    private String getDb(String writeDataSourceName, List&lt;String&gt; readDataSourceNames) {\n        //该类被SPI创建，无法通过spring容器注入，所以通过单例模式从容器中获取service\n        BinlogPositionService binlogPositionService = Singleton.getBinlogPositionServiceInstance();\n        //获取用户点位\n        BinlogPosition positionInfo = binlogPositionService.getUserPosition(UserManager.getUid());\n        //存在点位信息\n        if (positionInfo.isEffective()) {\n            //可以找到包含指定点位的从库，返回对于从库\n            List&lt;String&gt; containsSpecPositionSourceName = binlogPositionService.getContainSpecPositionSlave(positionInfo);\n            if (CollectionUtils.isNotEmpty(containsSpecPositionSourceName)) {\n                return loadBalance(containsSpecPositionSourceName);\n            }\n\n            //没有查询到满足条件的从库，查询主库\n            return writeDataSourceName;\n        } else {\n            //没有点位信息,用户没有执行过写操作\n            //此时，任选一个从库即可\n            return loadBalance(slaveNames);\n        }\n    }\n\n    /**\n     * 负载均衡策略随机选择\n     *\n     * @param readDataSourceNames\n     * @return\n     */\n    private String loadBalance(List&lt;String&gt; readDataSourceNames) {\n        return readDataSourceNames.get(ThreadLocalRandom.current().nextInt(readDataSourceNames.size()));\n    }\n</code></pre>\n<p>以上策略实在用户点位信息没有过期时间的基础上可保证读己所写。如果点位设置了过期时间，则需要调整逻辑。（如果保证点位信息不会过期，或者存储到用户侧始终会有点位信息，就不需要考入下列逻辑了）<br />\n如果点位设置了过期时间，没有获取到点位信息可能存在两种情况。<br />\n1.用户没有执行写操作。<br />\n2.用户执行了写操作，但当前时间已经超过点位的过期时间。<br />\n由于1.2在点位不存在的情况下，无法区分具体是哪一种情况。所以此时就需要判断主从同步延时，选取延迟时间小于等于过期时间的从库，满足条件的从库即可以读取到之前写入的数据。<br />\n证明过程如下：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1435315/202511/1435315-20251130170958176-301806385.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1435315/202511/1435315-20251130171047342-618582452.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1435315/202511/1435315-20251130171106033-569878748.png\" /><br />\n延迟时间小于等于过期时间的从库，可以读取到之前的写入数据，但如果延时时间大于过期时间，实际存在两种情况，一种是可以读取到，一种是无法读取到。<br />\n此时由于点位已经过期，无法区分出来。所以统一走降级逻辑查主库。<br />\n从库包含写入的条件：Δt ≥ L。<br />\n延时时间(L)大于过期时间（6s）<br />\nΔt = 10秒, L = 8秒<br />\n条件：10 ≥ 8 ✅<br />\n结果：从库已包含写入，可以安全读取</p>\n<p>Δt = 7秒, L = 9秒<br />\n条件：7 ≥ 9 ❌<br />\n结果：从库还未同步写入，读取会得到旧数据<br />\n例如用户写入后，数据被同步到了所有从库，用户第二天发起查询请求，此时点位信息以及过期，且用户写入主库数据已经同步到所有从库。<br />\n用户此时需要判断主从延时，假设此时主从延时达到30s.但是用户昨天的数据早已写入，此时还是会被路由到主库。</p>\n<pre><code>/**\n     * 获取大于等于用户当前存储点位信息的从库，如果没有从库满足条件，返回主库。\n     * @param writeDataSourceName\n     * @param readDataSourceNames\n     * @return\n     */\n    private String getDb(String writeDataSourceName, List&lt;String&gt; readDataSourceNames) {\n        //该类被SPI创建，无法通过spring容器注入，所以直接从容器中获取service\n        BinlogPositionService binlogPositionService = Singleton.getBinlogPositionServiceInstance();\n        //获取用户点位\n        BinlogPosition positionInfo = binlogPositionService.getUserPosition(UserManager.getUid());\n        //存在有效的点位信息\n        if (positionInfo.isEffective()) {\n            //可以找到包含指定点位的从库，返回对于从库\n            List&lt;String&gt; containsSpecPositionSourceName = binlogPositionService.getContainSpecPositionSlave(positionInfo);\n            if (CollectionUtils.isNotEmpty(containsSpecPositionSourceName)) {\n                return loadBalance(containsSpecPositionSourceName);\n            }\n\n            //没有查询到满足条件的从库，查询主库\n            return writeDataSourceName;\n        } else {\n            //没有点位信息存在两种情况\n            //case1 用户没有执行过写操作\n            //此时，任选一个从库即可\n            //case2 用户执行写操作，但存储的用户点位信息已过期。\n            //可将用户点位信息过期时间，设置为主从延迟的三倍。用户点位过期是主从延迟的三倍，过期后一般情况下，从库都同步了对应点位数据。\n            //但也可能存在没有同步的情况，此时就需要判断主从同步延时，选取延迟时间小于等于过期时间的从库。\n            //或者，将点位信息不设置过期时间，这样始终可以通过点位比较，然后通过定时任务，判断存储的点位信息小于所有从库当前点位就将其清空。\n            Set&lt;String&gt; slaveNames = binlogPositionService.getReasonablyDelayedSlave();\n            if (CollectionUtils.isNotEmpty(slaveNames)) {\n                return loadBalance(slaveNames);\n            }\n\n            //没有符合条件的，降级主库。\n            return writeDataSourceName;\n        }\n    }\n</code></pre>\n<p>由于Shrding Jdbc的自定义查询负载均衡算法使用SPI加载的，所以还需要指定自定义算法SPI文件。<br />\n在<code>resource</code>目录下创建一个META-INF/services文件夹，添加一个名为org.apache.shardingsphere.readwritesplitting.spi.ReadQueryLoadBalanceAlgorithm的文件。<br />\n文件中添加自定义实现了ReadQueryLoadBalanceAlgorithm的具体类的路基。</p>\n<pre><code>#SPI load\ncom.example.config.BinlogAwareLoadBalanceAlgorithm\n</code></pre>\n<h3 id=\"123-单调读\">1.2.3 单调读</h3>\n<p>单调读如下图所示，如果用户A更新或插入了数据，这个行为对用户B不可见，用户B只需要查询从库即可，从库何时同步了对应数据，就何时读取即可。由于写入操作是用户A进行的，所以用户B无需读己所写的保证。但如果用户B第一次读取的从库，已经同步了用户A的写入或更新内容，此时用户B可以查看到A的写入或更新。但是用户B再次刷新页面，此时读请求被路由到另外一个从库，此从库因为网络问题改从库没有同步用户A的写入或更新。此时对用户B来说，第一次看到了内容，第二次又没有看到内容。用户首先从新鲜副本读取，然后从陈旧副本读取，时间似乎倒退了。为了防止这种异常，我们需要单调读。单调读提供的保证是，不会读取到比之前读取数据更旧的数据。也就说单调读读取的数据，保持单调递增，每一次读取的数据版本只会大于或等于前一次读取的数据。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1435315/202511/1435315-20251129215659292-1491477398.png\" /></p>\n<p>如何保证单调读隔离级别？</p>\n<ul>\n<li>同一个用户每个请求路由到固定的从库，就当个数据库而言，数据版本是递增的，读取单个实例，读取的数据版本只会大于或等于上一次读取的数据。</li>\n<li>记录第一次读取数据库的点位信息，保证后续请求只会被路由到比记录点位相等或更新的数据库。</li>\n</ul>\n<p>如果仅仅只是需要单调读的保证，将读操作根据用户uid hash后路由到固定从库是实现最简单的方式。但某些在单调读的基础上，需要保证读之所写的混合情况时，路由到固定从库这个方案就不行了，路由到固定从库只能满足单调读的一致性，但无法满足读己所写。下一节会说明单调读+读己所写的混合情况。</p>\n<h3 id=\"124-基于shrding-jdbc实现单调读\">1.2.4 基于Shrding Jdbc实现单调读</h3>\n<pre><code>/**\n *1. 读一致性切面添加单调读标识\n * 读一致性注解，用于标识当读请求的一致性级别\n */\n@Slf4j\n@Aspect\n@Component\npublic class ReadConsistencyAspect {\n    \n    //读己所写\n    @Pointcut(\"@annotation(com.example.annotation.ReadSelfWrite)\")\n    public void readSelfWritePointCut() {\n    }\n\n    @Before(value = \"readSelfWritePointCut()\")\n    public void readSelfWritePoint(JoinPoint joinPoint) throws Throwable {\n        //对于标注了读之所写的接口，上下文中设置对应属性\n        ReadConsistencyManager.setReadSelfWrite();\n    }\n\n    //单调读\n    @Pointcut(\"@annotation(com.example.annotation.MonotonicRead)\")\n    public void monotonicReadPointCut() {\n    }\n\n    @Before(value = \"monotonicReadPointCut()\")\n    public void monotonicReadPoint(JoinPoint joinPoint) throws Throwable {\n        //对于标注了读之所写的接口，上下文中设置对于属性\n        ReadConsistencyManager.setMonotonicRead();\n    }\n\n}\n</code></pre>\n<pre><code>/**\n     * 2.自定义算法中，单调读选择分区。\n     *\n     * @param name                read query logic data source name\n     * @param writeDataSourceName 主库名称\n     * @param readDataSourceNames 从库名称列表\n     * @return 选择的数据源名称\n     */\n    public String getDataSource(String name, String writeDataSourceName, List&lt;String&gt; readDataSourceNames) {\n        try {\n\n            if (ReadConsistencyManager.readSelfWrite()) {\n                //2.只要求读之所写\n                return getDb(writeDataSourceName, readDataSourceNames);\n            } else if (ReadConsistencyManager.monotonicRead()) {\n                //3.只要求单调读（根据唯一标识分区即可），此处使用uid hash后取余，将请求路由到指定分区。\n                //由于hashCode可能算出负数，所以将其与0x7ffffff按位相与，使其首位置0变为正数。\n                return readDataSourceNames.get((UserManager.getUid().hashCode() &amp; Integer.MAX_VALUE) % readDataSourceNames.size());\n            } else {\n                //4.不要求读之所写+单调读\n                return loadBalance(readDataSourceNames);\n            }\n        } finally {\n            //清理Thread Local\n            ReadConsistencyManager.clear();\n        }\n    }\n</code></pre>\n<h3 id=\"125-读己所写单调读\">1.2.5 读己所写+单调读</h3>\n<p>前面提到，读己所写和单调读，但这两个混合的情况呢。这两个读一致性是独立的，满足其中一个并不能意味着满足另外一个。但有时会需要当前的请求需要同时满足两个读一致性的要求。<br />\n例如当前用户编辑自己主页，后续读取自己主页要满足读己所写，此时在用户看来，编辑和读取自己的主页都没有问题，可以看到修改后的数据。但是读取别人主页呢，此时就没有任何保证了。<br />\n例如用户当前最新的更新已经同步到所有从库（S1,S2），当前读取满足读己所写，请求被路由到任一个从库即可，该从库有自己最新写入的数据，满足读己所写，同时当前从库S1有用户B的更新操作，但由于网络原因，用户B的最新数据没有被同步到从库S2,此时用户如果只保证读己所写，第一次被路由到S1满足读己所写，用户同时查看用户B的主页，第一次被路由到S1可以看到修改过后的内容，第二次被路由到S2又无法看到用户修改后的内容，S1，S2均满足读己所写，但写入操作是其他用户B写入的，对当前用户来说感知不到，但此时读取其他用户又存在单调读的问题。<br />\n或者是购物车场景，用户需要满足读己所写，即添加到购物车的内容需要添加后马上可见，同时多次读取自己购物车需要满足单调读，不能出现数据回退的现象。<br />\n两种读一致性需要根据具体场景具体满足对于一致性要求。</p>\n<p>既然要实现读己所写+单调读，如何保证这两种读一致性，本质上不一致问题都是读取的数据版本造成的，读取到比当前应该看见的数据版本更旧的版本导致的。无论时读己所写（读取数据版本 ≥ 自己最后写入版本），还是单调读（读取版本要 ≥ 最后一次读取的数据版本），所以只要保证了读取的数据版本 ≥ max(最后读取版本, 最后写入版本)，即可保证两种一致性。</p>\n<p>所以具体实现策略为，<strong>根据用户记录的点位，先保证读己所写，获取一个满足条件的数据版本，然后读取该数据版本，并且记录当前读取的版本，将其最为最新点位。</strong><br />\n后续读取操作必须大于等于当前点位，即不会出现回退现象。写入操作时写入主库，同时更新点位(写入操作是写入主库，点位保持单调递增)，即不会出现违背读己所写情况。<br />\n所以最后读取的数据版本 ≥ max(最后读取版本, 最后写入版本)，即可保证两种一致性。</p>\n<p>L​ = 当前已知最大版本点位<br />\nVᵣ​ = 读操作实际版本<br />\nV​ = 写操作产生版本<br />\n设写操作 w(x,v) 在 r(x) 之前：<br />\nw(x,v) 后：L ≥ v (写操作更新规则，记录写入点位)<br />\nr(x) 要求：Vᵣ ≥ L (读操作要求，即当前读取数据副本要大于等于记录的用户副本)<br />\n由传递性：Vᵣ ≥ L ≥ v，即当前读操作可以读取到自己最新写入的数据<br />\n即 Vᵣ ≥ v 满足读己所写。</p>\n<p>设 r₁(x) 在 r₂(x) 之前：<br />\nr₁(x) 后：L ≥ Vᵣ₁ (读操作更新规则，读取数据后记录当前读取点位，即L ≥ Vᵣ₁)<br />\nr₂(x) 要求：Vᵣ₂ ≥ L (读操作要求，读取要求读取数据必须大于等于记录点位)<br />\n由传递性：Vᵣ₂ ≥ L ≥ Vᵣ₁，即第二次读取的数据，必得大于等于第一次读取数据不会出现回退。<br />\n即 Vᵣ₂ ≥ Vᵣ₁ 满足单调读。</p>\n<h3 id=\"126-基于sahrding-jdbc实现读己所写单调读\">1.2.6 基于Sahrding Jdbc实现读己所写+单调读</h3>\n<pre><code>/**\n     * 选择数据源的核心方法\n     *\n     * @param name                read query logic data source name\n     * @param writeDataSourceName 主库名称\n     * @param readDataSourceNames 从库名称列表\n     * @return 选择的数据源名称\n     */\n    public String getDataSource(String name, String writeDataSourceName, List&lt;String&gt; readDataSourceNames) {\n        try {\n\n            if (ReadConsistencyManager.readSelfWrite() &amp;&amp; ReadConsistencyManager.monotonicRead()) {\n                //如果是读之所写+单调读\n                //先根据读之所写，获取能读取的库。\n                //此时有三种清空\n                //1. 存在点位信息，可以找到满足点位的从库，选择从库。\n                //2. 存在点位信息，无法找到满足点位的从库，选择主库。\n                String dbName = getDb(writeDataSourceName, readDataSourceNames);\n\n                //获取当前读取库的点位信息，并缓存\n                //后续请求必须大于等于存储的最新点位。\n                BinlogPositionService binlogPositionService = Singleton.getBinlogPositionServiceInstance();\n                BinlogPosition specDbPosition = binlogPositionService.getPositionFromCache(dbName);\n                binlogPositionService.cacheUserBinlogPosition(UserManager.getUid(), specDbPosition);\n\n                return dbName;\n            } else if (ReadConsistencyManager.readSelfWrite()) {\n                //2.只要求读之所写\n                return getDb(writeDataSourceName, readDataSourceNames);\n            } else if (ReadConsistencyManager.monotonicRead()) {\n                //3.只要求单调读（根据唯一标识分区即可）\n                return readDataSourceNames.get((UserManager.getUid().hashCode() &amp; Integer.MAX_VALUE) % readDataSourceNames.size());\n            } else {\n                //4.不要求读之所写+单调读\n                return loadBalance(readDataSourceNames);\n            }\n        } finally {\n            //清理Thread Local\n            ReadConsistencyManager.clear();\n        }\n    }\n\n</code></pre>\n<h2 id=\"13-高可用篇---故障切换\">1.3 高可用篇 - 故障切换</h2>\n<h3 id=\"131-切换的一致性问题\">1.3.1 切换的一致性问题</h3>\n<p>切换前，首先要讨论，主从数据一致性问题。如果是预期的切换，即主库没有宕机的情况下。这种情况一致性是很容易保证的。<br />\n具体切换流程如下。<br />\n1.判断备库 B 现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；<br />\n2.把主库 A 改成只读状态，即把 readonly 设置为 true；<br />\n3.判断备库 B 的 seconds_behind_master 的值，直到这个值变成 0 为止；<br />\n4.把备库 B 改成可读写状态，也就是把 readonly 设置为 false；<br />\n5.把业务请求切到备库 B。<br />\n切换后数据主从数据是一致的，且没有丢失。</p>\n<p>那如果是主库宕机呢？这时情况就比较复杂呢。<br />\n首先，我们主从复制的情况下，数据有两个大的约束。<br />\n约束1，客户端收到成功响应保证主库事务已提交并持久化。<br />\n约束2，从库读取主库binlog写入relay log成功，主库必定写入对应binlog。<br />\n约束1，由MySQL保证，约束2，也很容易看出，从库中继日志的内容就是主库的binlog内容，写入了从库中继日志，主库必定会存在对应日志内容。<br />\n那么主要场景如下：</p>\n<table>\n<thead>\n<tr>\n<th>场景编号</th>\n<th>客户端接收响应</th>\n<th>主库binlog写入状态</th>\n<th>从库ready blog状态</th>\n<th>最终切换后主从数据状态</th>\n<th>切换从库后客户端与从库一致性</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>✓ 成功</td>\n<td>✓ 已写入</td>\n<td>✓ 已写入</td>\n<td>一致</td>\n<td>一致</td>\n<td>普遍情况</td>\n</tr>\n<tr>\n<td>2</td>\n<td>✓ 成功</td>\n<td>✓ 已写入</td>\n<td>✗ 未写入</td>\n<td>数据丢失</td>\n<td>不一致，客户端接收到成功响应，切换后从库没有数据</td>\n<td>在正确配置半同步情况不会出现，如果出现降级则会出现这种情况。</td>\n</tr>\n<tr>\n<td>3</td>\n<td>✓ 成功</td>\n<td>✗ 未写入</td>\n<td>✓ 已写入</td>\n<td></td>\n<td></td>\n<td>不会出现，违反约束2</td>\n</tr>\n<tr>\n<td>4</td>\n<td>✓ 成功</td>\n<td>✗ 未写入</td>\n<td>✗ 未写入</td>\n<td></td>\n<td></td>\n<td>不会出现，违反约束1，约束2</td>\n</tr>\n<tr>\n<td>5</td>\n<td>✗ 失败</td>\n<td>✓ 已写入</td>\n<td>✓ 已写入</td>\n<td>一致</td>\n<td>不一致，客户端接收到失败响应，切换后从库已经完成操作</td>\n<td>可能出现，主从都写入binlog后，返回客户端失败，如网络故障。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>✗ 失败</td>\n<td>✓ 已写入</td>\n<td>✗ 未写入</td>\n<td>数据丢失</td>\n<td>认知一致，客户端接收失败消息，从库也没有数据。</td>\n<td>可能出现，从库降级，写入主库成功，响应客户端前故障。在正确配置半同步情况不会出现，如果出现降级则会出现这种情况。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>✗ 失败</td>\n<td>✗ 未写入</td>\n<td>✓ 已写入</td>\n<td></td>\n<td></td>\n<td>不会出现，违法约束2</td>\n</tr>\n<tr>\n<td>8</td>\n<td>✗ 失败</td>\n<td>✗ 未写入</td>\n<td>✗ 未写入</td>\n<td>一致</td>\n<td>认知一致，客户端接收失败，主从都没有写入。</td>\n<td>会出现，主库写入前直接挂了，或SQL语法错误，长度超长等主库就直接未执行。</td>\n</tr>\n<tr>\n<td>9</td>\n<td>▲ 超时未知</td>\n<td>✓ 已写入</td>\n<td>✓ 已写入</td>\n<td>一致</td>\n<td>未知，需要重试或查询。</td>\n<td>可能出现，超时了。</td>\n</tr>\n<tr>\n<td>10</td>\n<td>▲ 超时未知</td>\n<td>✓ 已写入</td>\n<td>✗ 未写入</td>\n<td>数据丢失</td>\n<td>未知，需要重试或查询。</td>\n<td>可能出现，超时了。同时从库由半同步降级为异步。</td>\n</tr>\n<tr>\n<td>11</td>\n<td>▲ 超时未知</td>\n<td>✗ 未写入</td>\n<td>✓ 已写入</td>\n<td></td>\n<td></td>\n<td>不会出现，违法约束2</td>\n</tr>\n<tr>\n<td>12</td>\n<td>▲ 超时未知</td>\n<td>✗ 未写入</td>\n<td>✗ 未写入</td>\n<td>一致</td>\n<td>未知，需要重试或查询。</td>\n<td>可能出现，网络故障。</td>\n</tr>\n</tbody>\n</table>\n<p>读写分离场景下，用户不关注主从数据是否一致，用户只关注客户端接收响应，与切换后从库数据状态。所以我们提取这两列。<br />\n去除不可能出现和前后一致的情况，保留不一致的情况如下:</p>\n<table>\n<thead>\n<tr>\n<th>场景编号</th>\n<th>客户端</th>\n<th>切换后从库</th>\n<th>客户端与从库数据一致性</th>\n<th>客户端与从库一致性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>✓ 成功</td>\n<td>✗ 未写入</td>\n<td>丢失数据</td>\n<td>不一致，客户端接收成功，切换后从库没有数据</td>\n</tr>\n<tr>\n<td>2</td>\n<td>✗ 失败</td>\n<td>✓ 已写入</td>\n<td>幽灵数据</td>\n<td>不一致，客户端接收失败，切换后从库有数据</td>\n</tr>\n<tr>\n<td>3</td>\n<td>▲ 超时未知</td>\n<td>✓ 已写入</td>\n<td>未知，需要查询或重试</td>\n<td>一致，超时未知，需要重新查询。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>▲ 超时未知</td>\n<td>✗ 未写入</td>\n<td>未知，需要查询或重试</td>\n<td>一致，超时未知，需要重新查询。</td>\n</tr>\n</tbody>\n</table>\n<p>场景1，明显数据丢失了，内部统还好，操作以事务为单位，即使数据丢失，整体数据状态也是一致的。预期是由一致性状态A转移到一致性状态B。即使没有转移到一致性状态B,但数据也保持了之前的一致性状态A，也是安全的。例如状态，A用户扣减100，B用户增加100.即使这个事务操作丢失，A用户钱也没有扣减，B用户钱也没增加还是一致的。但涉及第三方系统一致性既没有办法得到保证了，事务只能保证内部系统的一致性，例如是创建一个订单，后续根据这个订单调用第三方接口转账，然后更新订单状态。如果这个订单数据丢失，同时也调用了第三方接口完成了状态。那这个就需要对账去处理了。系统内当前有100笔订单，第三方系统有101笔，通过监控找出不一致性的数据，要么在第三方系统中退掉订单，或在内部系统恢复数据。<br />\n场景2，幽灵数据，客户接收响应失败，但数据写入了，这时用户可能重复操作，有些操作是覆盖的，重复操作以最后一次为准即可，例如修改个人主页。重复写入后面覆盖前面即可，多次操作是安全的。<br />\n但有些不允许出现重复数据的操作，就需要结合业务场景考虑幂等操作。<br />\n场景3，4，对于客户来说，接收的是超时。那么切换后，从库数据无论是存在还是丢失都是可以接受的，比较没有明确的返回成功或失败。针对这些返回，需要先查询一次，同时考虑重试或幂等去重即可。</p>\n<p>上述就是切换后的一致性问题，需要根据业务重要性去做相对于的兜底操作。对于不重要的业务数据，丢失或重复都是可接收的。<br />\n对于重要的数据就需要考虑好各种情况，能通过监控等手段，识别最终数据的一致性情况，加上做好预案，出现问题能快速修复即可。<br />\n毕竟，真正的不一致情况相对来说还是较少的，大多数情况都是正常情况，但也要考虑到最坏情况。</p>\n<h3 id=\"132-基于zookeeper的动态配置切换\">1.3.2 基于Zookeeper的动态配置切换</h3>\n<pre><code class=\"language-xml\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;\n            &lt;artifactId&gt;shardingsphere-cluster-mode-core&lt;/artifactId&gt;\n            &lt;version&gt;5.2.1&lt;/version&gt;\n\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.yaml&lt;/groupId&gt;\n                    &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.yaml&lt;/groupId&gt;\n            &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt;\n            &lt;version&gt;1.33&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;\n            &lt;artifactId&gt;shardingsphere-cluster-mode-repository-zookeeper&lt;/artifactId&gt;\n            &lt;version&gt;5.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<pre><code class=\"language-yaml\">  # ShardingSphere读写分离配置：\n  shardingsphere:\n    mode:\n      type: Cluster\n      repository:\n        type: ZooKeeper\n        props:\n          namespace: governance_ds\n          server-lists: hcf.com:2181\n          retryIntervalMilliseconds: 500\n          timeToLiveSeconds: 60\n          maxRetries: 3\n          operationTimeoutMilliseconds: 5000\n      overwrite: false\n</code></pre>\n<p>应用启动，配置信息上传到zookeeper。后续直接修改zookeeper中的配置信息。shrding-jdbc会收到通知，修改对应配置，如分片规则，主从数据源等。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1435315/202601/1435315-20260103213755857-1418909837.png\" /></p>\n<p>主：3311，从1：3312，从2：3313<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1435315/202601/1435315-20260103212522657-533951894.png\" /></p>\n<p>修改zookeeper上的配置。假装主库宕机，3312变为新的主库，3313保持从库。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1435315/202601/1435315-20260103212539665-780073460.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1435315/202601/1435315-20260103212657920-1583796145.png\" /><br />\n可以看到，zookeeper中versions下新增一个版本号为1的配置，在里面填写修改后配置，然后将active_version修改为1，后续项目中数据源也刷新了。主库变为3312，从库变为了3313.</p>\n<p><a href=\"https://github.com/GCMH/Read-Write-Separation\" rel=\"noopener nofollow\" target=\"_blank\">完整代码详见https://github.com/GCMH/Read-Write-Separation</a></p>\n<p>参考资料：<br />\n[1].《数据密集型应用系统设计》<br />\n[2].《MySQL45讲》<br />\n[3]. <a href=\"http://shardingsphere.apache.org/document/current/en/overview/\" rel=\"noopener nofollow\" target=\"_blank\">Shrding Jdbc</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 15:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/huang-changfan\">gcmh</a>&nbsp;\n阅读(<span id=\"post_view_count\">28</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于 ContextCapture SDK 的 Python 自动化三维建模",
      "link": "https://www.cnblogs.com/foury/p/19438102",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/foury/p/19438102\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 15:13\">\n    <span>基于 ContextCapture SDK 的 Python 自动化三维建模</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"基于-contextcapture-sdk-的-python-自动化三维建模\">基于 ContextCapture SDK 的 Python 自动化三维建模</h1>\n<p>ContextCapture 是 Bentley 提供的一款商业级三维重建软件，广泛应用于无人机倾斜摄影、实景三维建模等场景。</p>\n<p>本文基于 ContextCapture 官方提供的 MasterKernel SDK，介绍如何通过 Python 脚本实现对 ContextCapture 建模流程的自动化控制，包括项目创建、空中三角测量（AT）、三维重建以及多种格式成果的顺序生产。</p>\n<p><strong>ContextCapture MasterKernel SDK介绍</strong>:<a href=\"https://docs.bentley.com/LiveContent/web/ContextCapture%20Help-v18/zh-cn/GUID-8A35B878-C2BB-4F01-8D5A-18321EF04410.html\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.bentley.com/LiveContent/web/ContextCapture Help-v18/zh-cn/GUID-8A35B878-C2BB-4F01-8D5A-18321EF04410.html</a></p>\n<h2 id=\"1安装contextcapture\">1.安装ContextCapture</h2>\n<p>基于ContextCapture的安装网上有很多详细的教程，本文不再对安装步骤进行详细展开。<br />\n本文测试环境使用的ContextCapture版本为 <strong>v10.18.0.232</strong>，后续示例均基于该版本，仅供参考。</p>\n<h2 id=\"2配置适合contextcapture的python环境\">2.配置适合ContextCapture的Python环境</h2>\n<p>在 ContextCapture 安装目录的 <code>sdk/dist</code> 文件夹中，可以找到官方提供的 Python SDK 安装包（<code>.whl</code> 文件）。</p>\n<p>例如：<br />\n<code>ccmasterkernel-10.18.0.232-cp36-cp36m-win_amd64.whl</code></p>\n<p>其中“cp36-cp36m”表示只支持 Python3.6 相关版本（要安装正确的Python版本）。</p>\n<p>安装完成Python环境后，打开命令行进入sdk/dist文件夹下，执行<code>pip install ccmasterkernel-10.18.0.232-cp36-cp36m-win_amd64.whl</code>安装好这个包。</p>\n<p><img alt=\"企业微信截图_17675106628003\" class=\"lazyload\" /></p>\n<h2 id=\"3编写python脚本\">3.编写Python脚本</h2>\n<p>关于sdk使用的相关文档说明在sdk/doc/html文件夹下。</p>\n<p>下面给出一个完整的 Python 脚本示例，用于演示如何通过 ContextCapture SDK 实现无人机影像的自动化三维建模流程。</p>\n<p>该脚本后续可根据实际需求进行裁剪或扩展。</p>\n<p>此脚本是一个用于自动化 ContextCapture (CC) 建模流程的 Python 脚本。它能够自动创建项目、提交空三运算 (AT)，并按顺序生成多种格式的三维模型（OBJ, LAS, 3D Tiles）。</p>\n<p><strong>注意：</strong> 正式运行脚本前，需确保ContextCapture Engine 已启动，否则任务无法正常提交；</p>\n<h3 id=\"31命令行参数\">3.1命令行参数</h3>\n<p>脚本支持通过命令行参数进行灵活配置：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">参数</th>\n<th style=\"text-align: left;\">必选/可选</th>\n<th style=\"text-align: left;\">默认值</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>--photos</code></td>\n<td style=\"text-align: left;\"><strong>必选</strong></td>\n<td style=\"text-align: left;\">-</td>\n<td style=\"text-align: left;\">照片所在的源文件夹路径。支持 jpg, tif, png 等格式。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>--project</code></td>\n<td style=\"text-align: left;\"><strong>必选</strong></td>\n<td style=\"text-align: left;\">-</td>\n<td style=\"text-align: left;\">项目输出的根文件夹路径。脚本将在此目录下创建 <code>.ccm</code> 项目文件和各个产物文件夹。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>--memory</code></td>\n<td style=\"text-align: left;\">可选</td>\n<td style=\"text-align: left;\"><code>16.0</code></td>\n<td style=\"text-align: left;\">目标内存使用量 (GB)。用于控制分块大小，建议设置为机器物理内存的 50%-70%。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>--formats</code></td>\n<td style=\"text-align: left;\">可选</td>\n<td style=\"text-align: left;\">全部</td>\n<td style=\"text-align: left;\">指定要生产的格式列表。可选值: <code>OBJ</code>, <code>LAS</code>, <code>3DTiles</code>。多个值之间用空格分隔。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"32-使用示例\">3.2 使用示例</h3>\n<p>在命令行 (CMD 或 PowerShell) 中运行以下命令。</p>\n<h4 id=\"1-基础用法\">1） 基础用法</h4>\n<p>生成所有默认格式 (OBJ, LAS, 3D Tiles)，默认使用 16GB 内存限制。</p>\n<pre><code class=\"language-powershell\">python test_cc_sequential.py --photos \"D:\\MyData\\Mission_01\\Images\" --project \"D:\\Projects\\Mission_01\"\n</code></pre>\n<h4 id=\"2指定输出格式\">2）指定输出格式</h4>\n<p>如果你只需要点云 (LAS) 和 OBJ 模型，不需要 3D Tiles：</p>\n<pre><code class=\"language-powershell\">python test_cc_sequential.py --photos \"D:\\Images\" --project \"D:\\Output\" --formats LAS OBJ\n</code></pre>\n<h4 id=\"3自定义内存限制\">3）自定义内存限制</h4>\n<p>针对大内存 (例如 64GB 内存)，可以调高限制以加快处理速度 (例如设为 48GB)：</p>\n<pre><code class=\"language-powershell\">python test_cc_sequential.py --photos \"D:\\Images\" --project \"D:\\Output\" --memory 48.0\n</code></pre>\n<p>针对小内存机器 (例如 16GB 内存)，建议调低限制 (例如 8GB)：</p>\n<pre><code class=\"language-powershell\">python test_cc_sequential.py --photos \"D:\\Images\" --project \"D:\\Output\" --memory 8.0\n</code></pre>\n<h3 id=\"33-输出结构\">3.3 输出结构</h3>\n<p>运行完成后，在指定的 <code>--project</code> 目录下会自动生成以下结构：</p>\n<pre><code class=\"language-text\">D:\\Projects\\Mission_01\\         &lt;-- 项目根目录\n│  Mission_01.ccm              &lt;-- CC 工程文件\n│  cc_sequential.log           &lt;-- 详细运行日志\n│\n├─ Production_OBJ\\             &lt;-- OBJ 模型输出目录\n│      metadata.xml\n│      ...\n│\n├─ Production_LAS\\             &lt;-- LAS 点云输出目录\n│      cloud.las\n│      ...\n│\n└─ Production_3DTiles\\         &lt;-- Cesium 3D Tiles 输出目录\n       tileset.json\n       ...\n</code></pre>\n<h3 id=\"34-日志\">3.4 日志</h3>\n<p>脚本运行过程中，简要信息会显示在屏幕上。<br />\n详细的带时间戳的日志会保存在脚本同级目录下的 <code>cc_sequential.log</code> 文件中。</p>\n<h3 id=\"35-具体代码实现\">3.5 具体代码实现</h3>\n<pre><code class=\"language-python\">\"\"\"\nContextCapture 顺序多格式生产脚本\n支持 OBJ、LAS 点云、Cesium 3D Tiles 三种格式\n使用分块处理 (Tiling) 控制内存\n顺序执行避免内存不足\n\"\"\"\nimport sys\nimport time\nimport os\nimport logging\nfrom logging.handlers import RotatingFileHandler\nimport traceback\nimport argparse\n\n# --- 日志配置 ---\n# 日志文件名为 cc_sequential.log，位于脚本所在目录\nlog_file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'cc_sequential.log')\n\nlogger = logging.getLogger('CC_Production')\nlogger.setLevel(logging.INFO)\n\n# 1. RotatingFileHandler: 10MB 切割，保留 5 个备份\n# maxBytes = 10 * 1024 * 1024 = 10485760 B\nrf_handler = RotatingFileHandler(log_file_path, maxBytes=10 * 1024 * 1024, backupCount=5, encoding='utf-8')\nfile_formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s')\nrf_handler.setFormatter(file_formatter)\nlogger.addHandler(rf_handler)\n\n# 2. StreamHandler: 输出到控制台\nconsole_handler = logging.StreamHandler(sys.stdout)\nconsole_handler.setFormatter(logging.Formatter('%(message)s'))  # 控制台输出保持原样，纯文本方便阅读\nlogger.addHandler(console_handler)\n# ----------------\n\ntry:\n    import ccmasterkernel\n\n    logger.info(\"成功导入 ccmasterkernel 模块\")\nexcept ImportError:\n    logger.error(\"错误: 无法导入 ccmasterkernel 模块。\")\n    sys.exit(1)\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser(description=\"ContextCapture 顺序多格式生产脚本\")\n\n    # 路径参数 (必须)\n    parser.add_argument('--photos', required=True, help='照片所在目录路径')\n    parser.add_argument('--project', required=True, help='项目输出目录路径')\n\n    # 可选参数\n    parser.add_argument('--memory', type=float, default=16.0, help='目标内存使用量 (GB)，默认 16.0')\n    parser.add_argument('--formats', nargs='+', default=['OBJ', 'LAS', '3DTiles'],\n                        choices=['OBJ', 'LAS', '3DTiles'],\n                        help='指定要生产的格式 (默认全部): OBJ, LAS, 3DTiles')\n\n    return parser.parse_args()\n\n\ndef main():\n    args = parse_args()\n\n    # 定义路径变量 (从 args 获取)\n    project_dir = args.project\n    # 自动根据目录名生成项目文件名\n    project_name_base = os.path.basename(os.path.normpath(project_dir))\n    project_file_path = os.path.join(project_dir, f\"{project_name_base}.ccm\")\n    photos_dir = args.photos\n\n    # 多格式输出目录\n    production_obj_dir = os.path.join(project_dir, \"Production_OBJ\")\n    production_las_dir = os.path.join(project_dir, \"Production_LAS\")\n    production_3dtiles_dir = os.path.join(project_dir, \"Production_3DTiles\")\n\n    logger.info(\"\\n\" + \"=\" * 60)\n    logger.info(\"ContextCapture 顺序多格式自动化脚本 (CLI Mode)\")\n    logger.info(\"=\" * 60)\n    logger.info(f\"项目文件路径: {project_file_path}\")\n    logger.info(f\"照片目录:     {photos_dir}\")\n    logger.info(f\"目标内存:     {args.memory} GB\")\n\n    # 确定要生产的格式\n    formats_to_produce_list = []\n\n    # 格式定义映射: Name -&gt; (DriverName, OutputDir, Description)\n    format_map = {\n        'OBJ': (\"OBJ\", production_obj_dir, \"OBJ 网格模型\"),\n        'LAS': (\"LAS\", production_las_dir, \"LAS 点云\"),\n        '3DTiles': (\"Cesium 3D Tiles\", production_3dtiles_dir, \"Cesium 3D Tiles\")\n    }\n\n    req_formats = args.formats\n\n    logger.info(f\"计划生产格式: {', '.join(req_formats)}\")\n\n    # 构建 production list\n    # 保持原有顺序: OBJ -&gt; LAS -&gt; 3DTiles (如果被选中)\n    if 'OBJ' in req_formats:\n        formats_to_produce_list.append(('OBJ', *format_map['OBJ']))\n    if 'LAS' in req_formats:\n        formats_to_produce_list.append(('LAS', *format_map['LAS']))\n    if '3DTiles' in req_formats:\n        formats_to_produce_list.append(('Cesium 3D Tiles', *format_map['3DTiles']))\n\n    logger.info(\"\\n输出位置预览:\")\n    for _, _, out_dir, desc in formats_to_produce_list:\n        logger.info(f\"  - {desc}: {out_dir}\")\n\n    logger.info(\"\\n注意: 选中格式将依次执行，避免内存不足\")\n    logger.info(\"=\" * 60 + \"\\n\")\n\n    # 确保项目目录存在\n    if not os.path.exists(project_dir):\n        try:\n            os.makedirs(project_dir)\n        except OSError as e:\n            logger.error(f\"错误: 无法创建项目目录 {project_dir}: {e}\")\n            return\n\n    # 1. 创建并配置项目\n    logger.info(\"正在创建项目...\")\n    project = ccmasterkernel.Project()\n    project.setName(project_name_base)  # 使用目录名作为项目名\n    project.setProjectFilePath(project_file_path)\n\n    # 2. 创建区块并添加照片\n    logger.info(\"正在创建初始区块...\")\n    block = ccmasterkernel.Block(project)\n    project.addBlock(block)\n    block.setName(\"InitialBlock\")\n\n    logger.info(\"正在添加照片...\")\n    photogroups = block.getPhotogroups()\n\n    if os.path.exists(photos_dir):\n        photo_files = [f for f in os.listdir(photos_dir)\n                       if f.lower().endswith(('.jpg', '.jpeg', '.tif', '.tiff', '.png'))]\n        if not photo_files:\n            logger.warning(f\"警告: 在 {photos_dir} 中未找到照片文件。\")\n\n        for f in photo_files:\n            full_path = os.path.join(photos_dir, f)\n            photogroups.addPhotoInAutoMode(full_path)\n        logger.info(f\"已尝试添加 {len(photo_files)} 张照片。\")\n    else:\n        logger.error(f\"错误: 照片目录 {photos_dir} 不存在。\")\n        return\n\n    # 验证区块是否有效\n    if not block.isReadyForAT():\n        logger.error(\"错误: 区块未准备好进行 AT。\")\n        return\n\n    # 保存项目\n    logger.info(\"正在保存项目...\")\n    save_error = project.writeToFile()\n    if not save_error.isNone():\n        logger.error(f\"保存项目失败: {save_error.message}\")\n        return\n    logger.info(\"项目保存成功。\")\n\n    # 3. 空中三角测量 (AT)\n    logger.info(\"\\n准备空中三角测量 (AT) 区块...\")\n    block_at = ccmasterkernel.Block(project)\n    project.addBlock(block_at)\n    block_at.setName(\"AT_Block\")\n    block_at.setBlockTemplate(ccmasterkernel.BlockTemplate.Template_adjusted, block)\n\n    # 保存更新后的项目\n    logger.info(\"正在保存更新后的项目...\")\n    save_error = project.writeToFile()\n    if not save_error.isNone():\n        logger.error(f\"保存项目失败: {save_error.message}\")\n        return\n\n    logger.info(\"开始提交 AT 处理...\")\n    at = block_at.getAT()\n    if at is None:\n        logger.error(\"错误: 无法获取 AT 对象。\")\n        return\n\n    # 提交 AT 处理\n    submit_error = at.submitProcessing()\n    if not submit_error.isNone():\n        logger.error(f\"AT 提交失败: {submit_error.message}\")\n        return\n\n    # 监控 AT 任务\n    if not monitor_job(at, \"AT\"):\n        logger.error(\"AT 处理未成功完成，脚本终止。\")\n        return\n\n    logger.info(\"AT 处理完成。\\n\")\n\n    # 4. 重建 (Reconstruction) - 配置分块处理\n    logger.info(\"=\" * 60)\n    logger.info(\"创建重建项目...\")\n    logger.info(\"=\" * 60)\n\n    reconstruction = ccmasterkernel.Reconstruction(block_at)\n    block_at.addReconstruction(reconstruction)\n    reconstruction.setName(\"Reconstruction_Sequential\")\n\n    # 配置重建设置\n    logger.info(\"\\n配置重建设置...\")\n    settings = reconstruction.getSettings()\n    reconstruction.setSettings(settings)\n\n    # 配置分块处理 (Tiling)\n    logger.info(\"配置分块处理 (Tiling)...\")\n    tiling = reconstruction.getTiling()\n    tiling.tilingMode = ccmasterkernel.TilingMode.TilingMode_adaptive\n    tiling.targetMemoryUse = args.memory  # 使用命令行参数\n    tiling.overlapRatio = 0.2\n    tiling.discardEmptyTiles = True\n    reconstruction.setTiling(tiling)\n\n    logger.info(f\"  - 模式: Adaptive (自动分块)\")\n    logger.info(f\"  - 目标内存: {tiling.targetMemoryUse} GB\")\n    logger.info(f\"  - 瓦片重叠率: {tiling.overlapRatio * 100}%\")\n\n    # 保存重建配置\n    logger.info(\"\\n保存重建配置...\")\n    save_error = project.writeToFile()\n    if not save_error.isNone():\n        logger.error(f\"保存项目失败: {save_error.message}\")\n        return\n\n    # 获取瓦片数量\n    num_tiles = reconstruction.getNumInternalTiles()\n    logger.info(f\"\\n重建包含 {num_tiles} 个瓦片\")\n\n    # 5. 顺序生产 - 依次执行每种格式\n    logger.info(\"\\n\" + \"=\" * 60)\n    logger.info(\"开始顺序生产（依次执行，避免内存不足）\")\n    logger.info(\"=\" * 60)\n\n    results = []\n\n    # 遍历我们构建的格式列表\n    for idx, (prod_name, driver_name, output_dir, description) in enumerate(formats_to_produce_list, 1):\n        logger.info(\"\\n\" + \"=\" * 60)\n        logger.info(f\"第 {idx}/{len(formats_to_produce_list)} 步: 生产 {description}\")\n        logger.info(\"=\" * 60)\n\n        # 创建生产\n        logger.info(f\"\\n配置 {description}...\")\n        production = ccmasterkernel.Production(reconstruction)\n        reconstruction.addProduction(production)\n        production.setName(f\"Production_{prod_name}\")\n        production.setDriverName(driver_name)\n        production.setDestination(output_dir)\n        logger.info(f\"  ✓ {description} 配置完成\")\n\n        # 保存项目\n        save_error = project.writeToFile()\n        if not save_error.isNone():\n            logger.error(f\"  ✗ 保存项目失败: {save_error.message}\")\n            results.append((description, False))\n            continue\n\n        # 添加所有瓦片任务\n        logger.info(f\"\\n为 {description} 添加 {num_tiles} 个瓦片任务...\")\n        production_jobs = []\n        try:\n            for i in range(num_tiles):\n                tile = reconstruction.getInternalTile(i)\n                job = ccmasterkernel.TileProductionJob(production, tile)\n                production.addProductionJob(job)\n                production_jobs.append(job)\n            logger.info(f\"  ✓ 已添加 {num_tiles} 个瓦片任务\")\n        except Exception as e:\n            logger.error(f\"  ✗ 添加任务时出错: {e}\")\n            results.append((description, False))\n            continue\n\n        # 提交生产\n        logger.info(f\"\\n提交 {description} 生产...\")\n        submit_error = production.submitProcessing()\n        if not submit_error.isNone():\n            logger.error(f\"  ✗ 提交失败: {submit_error.message}\")\n            results.append((description, False))\n            continue\n        logger.info(f\"  ✓ 提交成功\")\n\n        # 监控所有瓦片任务\n        logger.info(f\"\\n监控 {description} 任务（{num_tiles} 个瓦片）...\")\n        all_tiles_success = True\n        for tile_idx, job in enumerate(production_jobs):\n            job_desc = f\"{description} - 瓦片 {tile_idx}\"\n            if not monitor_job(job, job_desc):\n                logger.error(f\"  ✗ 瓦片 {tile_idx} 处理失败\")\n                all_tiles_success = False\n                break  # 如果一个瓦片失败，停止监控后续瓦片\n            else:\n                logger.info(f\"  ✓ 瓦片 {tile_idx} 处理成功\")\n\n        if all_tiles_success:\n            logger.info(f\"\\n✓ {description} 所有瓦片处理成功！\")\n            logger.info(f\"  输出位置: {output_dir}\")\n            results.append((description, True))\n        else:\n            logger.error(f\"\\n✗ {description} 处理失败\")\n            results.append((description, False))\n\n    # 最终结果汇总\n    logger.info(\"\\n\" + \"=\" * 60)\n    logger.info(\"生产结果汇总\")\n    logger.info(\"=\" * 60)\n\n    for description, success in results:\n        status = \"✓ 成功\" if success else \"✗ 失败\"\n        logger.info(f\"  {status}: {description}\")\n\n    all_success = all(success for _, success in results)\n\n    if all_success:\n        logger.info(\"\\n\" + \"=\" * 60)\n        logger.info(\"所有请求的格式生产成功完成！\")\n        logger.info(\"=\" * 60)\n    else:\n        logger.error(\"\\n部分格式生产失败，请检查日志获取详细信息。\")\n\n\ndef monitor_job(job_object, job_name):\n    \"\"\"\n    通用任务监控函数\n    \"\"\"\n    previous_status = ccmasterkernel.JobStatus.Job_unknown\n\n    while True:\n        # 更新状态\n        try:\n            job_object.updateJobStatus()\n        except AttributeError:\n            pass\n\n        status = job_object.getJobStatus()\n\n        # 显示状态变化\n        if status != previous_status:\n            status_str = ccmasterkernel.jobStatusAsString(status)\n            logger.info(f\"    [{job_name}] {status_str}\")\n            previous_status = status\n\n        # 检查是否结束\n        if status in [ccmasterkernel.JobStatus.Job_completed,\n                      ccmasterkernel.JobStatus.Job_failed,\n                      ccmasterkernel.JobStatus.Job_cancelled]:\n            break\n\n        time.sleep(2)\n\n    # 最终结果检查\n    if status == ccmasterkernel.JobStatus.Job_completed:\n        return True\n    else:\n        msg = job_object.getJobMessage()\n        if msg:\n            logger.error(f\"    [{job_name}] 错误: {msg}\")\n        return False\n\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except KeyboardInterrupt:\n        logger.info(\"\\n\\n用户中断脚本执行。\")\n    except Exception as e:\n        logger.error(f\"\\n错误: {e}\")\n        logger.error(\"详细堆栈:\", exc_info=True)\n\n\n</code></pre>\n<p><strong>github仓库地址</strong>：<a href=\"https://github.com/Canon-create/contextcapture-python-example\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Canon-create/contextcapture-python-example</a></p>\n<p><strong>参考文章</strong>：<a href=\"https://blog.csdn.net/qq_41475842/article/details/112959892\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/qq_41475842/article/details/112959892</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 15:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/foury\">深紫色的三北六号</a>&nbsp;\n阅读(<span id=\"post_view_count\">36</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【译】Copilot Profiler Agent —— 分析任务交由 AI，应用性能不受影响",
      "link": "https://www.cnblogs.com/MeteorSeed/p/19434707",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/MeteorSeed/p/19434707\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 14:17\">\n    <span>【译】Copilot Profiler Agent —— 分析任务交由 AI，应用性能不受影响</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在 Visual Studio 2026 中，我们推出了 Copilot Profiler Agent，这是一款新的人工智能驱动的助手，可帮助您分析和优化代码中的性能瓶颈。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>　　在 Visual Studio 2026 中，我们推出了 Copilot Profiler Agent，这是一款新的人工智能驱动的助手，可帮助您分析和优化代码中的性能瓶颈。通过将 GitHub Copilot 的功能与 Visual Studio 的性能分析器相结合，您现在可以用自然语言询问有关性能的问题，深入了解热点路径，并快速发现优化机会。让我们来看一个真实的例子，了解这款工具如何帮助您实现有意义的性能改进。</span></p>\n<h1><span><span>对实际项目进行基准测试</span></span></h1>\n<p><span>　　为了展示 Copilot Profiler Agent 的功能，让我们对一个广受欢迎的开源项目 CsvHelper 进行优化。您可以按照以下步骤操作：克隆我的代码仓库分支，然后通过“git checkout 435ff7c”命令切换到我修复之前的版本，我们将在下文详细介绍该修复。</span></p>\n<p><span>　　在我之前的一篇博客文章中，我添加了一个 CsvHelper.Benchmarks 项目，其中包含一个用于读取 CSV 记录的基准测试。这次我想看看我们是否可以优化 CSV 记录的写入。通常，我会通过为想要优化的代码创建基准测试来开始这项研究，不过虽然我们仍然会这样做，但我们可以让 Copilot 来承担这些繁重的工作。在 Copilot 聊天窗口中，我可以问@Profiler “帮我为&nbsp;<span><a class=\"wx_topic_link\">#WriteRecords</a>&nbsp;方法编写一个基准测试<span>”。@Profiler 让我们直接与 Copilot Profiler Agent 对话，而&nbsp;<a class=\"wx_topic_link\">#WriteRecords</a>&nbsp;则明确告诉它我们要进行基准测试的方法。</span></span></span></p>\n<p><span><img alt=\"1\" src=\"https://img2024.cnblogs.com/blog/270073/202601/270073-20260103183046930-1636522852.webp\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p><span>　　从这里开始，Copilot 着手创建我们的新基准测试，它会询问我们是否可以安装分析器的 NuGet 包，以便在运行基准测试时从中提取信息。它还会根据找到的任何现有基准测试来构建新的基准测试模型，因此生成的基准测试与我们已经编写的非常相似，从而保持与存储库风格的一致性。最后，它会启动构建过程，以确保一切正常。</span></p>\n<p><span><img alt=\"2\" src=\"https://img2024.cnblogs.com/blog/270073/202601/270073-20260103183102876-936615004.webp\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p><span>　　完成后，它会提供一些有用的后续提示来启动调查。我们可以点击其中一个来展开调查，不过我想对基准测试做些细微的修改。</span></p>\n<p><span><img alt=\"3\" src=\"https://img2024.cnblogs.com/blog/270073/202601/270073-20260103183116605-1267996258.webp\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p><span>　　我对基准测试做了些调整，增加了几个供我们写入的字段，这里具体是 2 个整数字段和 2 个字符串字段。在为这篇博客撰写内容之前，我最初让 Copilot 来做这件事时，它每次都是写入一个新的内存流，而不是同一个内存流。写入同一个内存流或许是更好的做法，这次算你赢了 Copilot，但在我给 CsvHelper 提交的最初的拉取请求中，我并没有这么做，不过应该也没什么问题。</span></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">public class BenchmarkWriteCsv \n{ \n    private const int entryCount = 10000; \n    private readonly List records = new(entryCount); \n\n    public class Simple \n    { \n        public int Id1 { get; set; } \n        public int Id2 { get; set; } \n        public string Name1 { get; set; } \n        public string Name2 { get; set; } \n    } \n\n    [GlobalSetup] \n    public void GlobalSetup() \n    { \n        var random = new Random(42); \n        var chars = new char[10]; \n\n        string getRandomString() \n        { \n            for (int i = 0; i &lt; 10; ++i) \n                chars[i] = (char)random.Next('a', 'z' + 1); \n            return new string(chars); \n        } \n\n        for (int i = 0; i &lt; entryCount; ++i) \n        { \n            records.Add(new Simple \n            { \n                Id1 = random.Next(), \n                Id2 = random.Next(), \n                Name1 = getRandomString(), \n                Name2 = getRandomString(), \n            }); \n        } \n    } \n\n    [Benchmark] \n    public void WriteRecords() \n    { \n        using var stream = new MemoryStream(); \n        using var streamWriter = new StreamWriter(stream); \n        using var writer = new CsvHelper.CsvWriter(streamWriter, CultureInfo.InvariantCulture); \n        writer.WriteRecords(records); \n        streamWriter.Flush(); \n    } \n} </pre>\n</div>\n<h1><span><span>深入了解基准测试</span></span></h1>\n<p><span>　　现在开始分析，我既可以让 Profiler Agent 运行基准测试，也可以直接点击后续提示“@Profiler Run the benchmark and analyze results”。从这里开始，Copilot 会编辑我的主方法，乍一看可能有些奇怪，但查看所做的更改后，我发现它为了使用 BenchmarkSwitcher 进行了必要的修改，这样就能选择要运行的基准测试了：</span></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">static void Main(string[] args)\n{\n    // Use assembly-wide discovery so all benchmarks in this assembly are run,\n    // including the newly added BenchmarkWriteRecords.\n    _ = BenchmarkSwitcher.FromAssembly(typeof(BenchmarkEnumerateRecords).Assembly).Run(args);\n}</pre>\n</div>\n<p><span>　　然后它启动了一次基准测试运行，完成后会给我一个诊断会话，我可以在其中开始调查。</span></p>\n<h1><span><span>使用 Copilot Profiler Agent 来查找瓶颈</span></span></h1>\n<p><span>　　现在到了令人兴奋的部分。运行基准测试后，Profiler Agent 会分析跟踪信息，并突出显示时间的消耗位置。我可以向 Profiler Agent 询问有关跟踪的问题，让它解释代码为什么运行缓慢，或者某些优化为何会有帮助。它已经指出，大部分时间都花在委托编译和调用上，这是针对 CSV 记录中的每个字段进行的。对于一个有 4 个字段、被写入 10,000 次的记录来说，这意味着会有 40,000 次委托调用。每次调用都有开销，而这在分析器中显示为一个热点路径。</span></p>\n<p><span><img alt=\"6\" src=\"https://img2024.cnblogs.com/blog/270073/202601/270073-20260103183341061-1323757922.webp\" /></span></p>\n<p><span>　　我可以问 Profiler Agent：“我怎样才能减少委托调用的开销？”或者“为什么委托调用很慢？”，而它会像一位耐心的老师一样解释相关概念并提出修复建议。</span></p>\n<h1><span><span>实施修复方案</span></span></h1>\n<p><span>　　我点击 @Profiler Optimize library to produce a single compiled write delegate (reduce multicast invokes)，看看会得到什么结果。 Profiler Agent 会对 ObjectRecordWriter 进行编辑，我可以在聊天窗口中点击它来查看所做更改的差异。</span></p>\n<p><span>　　查看当前的实现，代码构建了一个委托列表，每个字段对应一个委托：</span></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">var delegates = new List&lt;Action&gt;();\n\nforeach (var memberMap in members)\n{\n    // ... field writing logic ...\n\n    delegates.Add(Expression.Lambda&lt;Action&gt;(writeFieldMethodCall, recordParameter).Compile());\n}\n\nvar action = CombineDelegates(delegates) ?? new Action((T parameter) =&gt; { });\nreturn action;</pre>\n</div>\n<p><span>　　问题在于 CombineDelegates 会创建一个多播委托，该委托会依次单独调用每个独立的委托。相反，Profiler Agent 建议我们在编译前使用 Expression.Block 来组合所有表达式：</span></p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">var expressions = new List&lt;Expression&gt;(members.Count);\n\nforeach (var memberMap in members)\n{\n    // ... field writing logic ...\n\n    expressions.Add(writeFieldMethodCall);\n}\n\nif (expressions.Count == 0)\n{\n    return new Action&lt;T&gt;((T parameter) =&gt; { });\n}\n\n// Combine all field writes into a single block\nvar block = Expression.Block(expressions);\nreturn Expression.Lambda&lt;Action&lt;T&gt;&gt;(block, recordParameter).Compile();</pre>\n</div>\n<p><span>　　这一改动虽小却很精妙：我们没有创建多个委托并按顺序调用它们，而是创建了一个包含所有字段写入操作的单个块表达式，然后对其进行一次编译。现在，当我们为每条记录调用委托时，所有字段都会在一次调用中完成写入，不存在额外的委托开销。</span></p>\n<h1><span><span>衡量影响</span></span></h1>\n<p><span>　　做出这一更改后，Copilot 会自动重新运行基准测试以衡量改进效果。结果显示，在此次使用分析器的运行中，性能大约提升了 24%。我们之前为 CsvHelper 准备的分阶段拉取请求显示性能提升了约 15%。CPU 分析器证实，我们已经消除了委托调用的开销，对于每条有 4 个字段的 10,000 条记录，之前需要进行 40,000 次委托调用，而现在只需要 10,000 次委托调用。</span></p>\n<p><span><img alt=\"9\" src=\"https://img2024.cnblogs.com/blog/270073/202601/270073-20260103183513372-1911198811.webp\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p><span>　　对于一个已经经过大量优化的库来说，这是一场意义重大的胜利。对于那些编写包含许多字段的大型 CSV 文件的应用程序而言，这一改进直接意味着 CPU 时间的减少和处理速度的提升。而且，由于 CsvHelper 的下载量高达数百万次，这项优化惠及了大量用户。在此基础上，我继续推进并提交了拉取请求，不过 Copilot 贴心地提供了更多关于类型转换和 ShouldQuote 逻辑的后续提示，以便我能进一步提升性能。</span></p>\n<h1><span><span>Copilot Profiler Agent 的价值</span></span></h1>\n<p><span>　　这个工作流程之所以强大，是因为它将 Visual Studio Profiler 提供的精确性能数据与 Copilot 的分析和代码生成能力相结合。您无需手动深入研究 CPU 跟踪并试图理解热点路径的含义，而是可以提出自然语言问题，获取可执行的见解，并快速测试想法。</span></p>\n<p><span>　　该 Agent 不仅会告诉您哪些部分运行缓慢，还会帮助您理解其缓慢的原因，并提出具体的修复方法。在这种情况下，它识别出委托调用的开销是瓶颈，并建议采用 Expression.Block 优化，这正是解决该问题的正确方案。它甚至还重新运行了基准测试来确认该优化的效果！</span></p>\n<h1><span><span>让我们知道您的想法</span></span></h1>\n<p><span>　　我们已经展示了 Copilot Profiler Agent 如何帮助您处理实际项目，通过自然语言查询识别性能瓶颈，并在数据支持下做出有意义的改进。当您能够就性能数据提出问题并获得智能答案时，测量/更改/测量的循环会变得快得多。我们很想听听您的想法！</span></p>\n<p><span>&nbsp;</span></p>\n<p><span>原文链接：https://devblogs.microsoft.com/visualstudio/delegate-the-analysis-not-the-performance/</span></p>\n<p><span><img alt=\"me\" src=\"https://img2024.cnblogs.com/blog/270073/202508/270073-20250825145337681-1658462272.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p><strong>作者：</strong><a href=\"http://www.cnblogs.com/MeteorSeed\">MeteorSeed</a></p>\n<p><strong>我希望您喜欢这篇博文，并一如既往地感谢您阅读并与朋友和同事分享我的博文。</strong></p>\n<p><strong>转载请注明出处。</strong></p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 14:17</span>&nbsp;\n<a href=\"https://www.cnblogs.com/MeteorSeed\">MeteorSeed</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【指南手册】Maven依赖错误排查指南",
      "link": "https://www.cnblogs.com/weipt0106/p/19437521",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/weipt0106/p/19437521\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 14:08\">\n    <span>【指南手册】Maven依赖错误排查指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>&nbsp;</p>\n<div>\n<h1 style=\"color: rgba(44, 62, 80, 1); font-size: 28px; margin-bottom: 15px; padding-bottom: 10px;\">Maven依赖错误排查指南</h1>\n<p style=\"margin-bottom: 15px; text-align: justify;\"><strong>AI声明：本文基于作者和元宝AI多次问答交互生成。</strong></p>\n<p style=\"margin-bottom: 15px; text-align: justify;\">Maven是Java项目中最流行的构建工具之一，但在使用过程中经常会遇到各种依赖下载问题。本文档整理了常见的Maven依赖错误，提供了详细的排查步骤和解决方案，帮助您快速定位和解决问题。</p>\n<div style=\"background-color: rgba(240, 247, 255, 1); padding: 15px; margin: 20px 0; border-radius: 0 5px 5px 0;\">\n<h3 style=\"color: rgba(44, 62, 80, 1); font-size: 18px; margin: 0 0 10px;\">📋 使用说明</h3>\n<p style=\"margin-bottom: 0; text-align: justify;\">本文档按照错误类型分类，每种错误包含错误示例、严重程度、主要原因和详细排查步骤。您可以根据遇到的错误信息快速定位到相应章节。</p>\n</div>\n<h2 style=\"color: rgba(52, 73, 94, 1); font-size: 22px; margin: 25px 0 15px; padding-left: 10px;\">一、错误类型概览</h2>\n<table>\n<thead>\n<tr><th style=\"background-color: rgba(44, 62, 80, 1); color: rgba(255, 255, 255, 1); font-weight: 600; text-align: left; padding: 12px 15px; width: 20%;\">错误类型</th><th style=\"background-color: rgba(44, 62, 80, 1); color: rgba(255, 255, 255, 1); font-weight: 600; text-align: left; padding: 12px 15px; width: 35%;\">常见错误提示</th><th style=\"background-color: rgba(44, 62, 80, 1); color: rgba(255, 255, 255, 1); font-weight: 600; text-align: left; padding: 12px 15px; width: 15%;\">严重程度</th><th style=\"background-color: rgba(44, 62, 80, 1); color: rgba(255, 255, 255, 1); font-weight: 600; text-align: left; padding: 12px 15px; width: 30%;\">主要特征</th></tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 12px 15px;\"><span style=\"display: inline-block; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; margin-right: 5px; background-color: rgba(255, 234, 167, 1); color: rgba(211, 84, 0, 1);\">网络问题</span></td>\n<td style=\"padding: 12px 15px;\">Connect timed out, SSL handshake failure</td>\n<td style=\"padding: 12px 15px;\"><span style=\"font-weight: bold; color: rgba(231, 76, 60, 1);\">高</span></td>\n<td style=\"padding: 12px 15px;\">与Maven仓库连接失败，无法下载依赖</td>\n</tr>\n<tr style=\"background-color: rgba(248, 249, 250, 1);\">\n<td style=\"padding: 12px 15px;\"><span style=\"display: inline-block; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; margin-right: 5px; background-color: rgba(162, 155, 254, 1); color: rgba(45, 52, 54, 1);\">缓存问题</span></td>\n<td style=\"padding: 12px 15px;\">was cached in local repository, HTTPS Required</td>\n<td style=\"padding: 12px 15px;\"><span style=\"font-weight: bold; color: rgba(243, 156, 18, 1);\">中</span></td>\n<td style=\"padding: 12px 15px;\">本地缓存了错误或过期的依赖，协议问题</td>\n</tr>\n<tr>\n<td style=\"padding: 12px 15px;\"><span style=\"display: inline-block; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; margin-right: 5px; background-color: rgba(253, 121, 168, 1); color: rgba(45, 52, 54, 1);\">依赖问题</span></td>\n<td style=\"padding: 12px 15px;\">Could not find artifact, Could not resolve</td>\n<td style=\"padding: 12px 15px;\"><span style=\"font-weight: bold; color: rgba(231, 76, 60, 1);\">高</span></td>\n<td style=\"padding: 12px 15px;\">依赖不存在、版本冲突或依赖链断裂</td>\n</tr>\n<tr style=\"background-color: rgba(248, 249, 250, 1);\">\n<td style=\"padding: 12px 15px;\"><span style=\"display: inline-block; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; margin-right: 5px; background-color: rgba(129, 236, 236, 1); color: rgba(45, 52, 54, 1);\">配置问题</span></td>\n<td style=\"padding: 12px 15px;\">Plugin not found, packaging error</td>\n<td style=\"padding: 12px 15px;\"><span style=\"font-weight: bold; color: rgba(243, 156, 18, 1);\">中</span></td>\n<td style=\"padding: 12px 15px;\">插件配置错误，打包配置问题</td>\n</tr>\n</tbody>\n</table>\n<h2 style=\"color: rgba(52, 73, 94, 1); font-size: 22px; margin: 25px 0 15px; padding-left: 10px;\">二、网络连接问题</h2>\n<div style=\"border-radius: 5px; margin: 20px 0; overflow: hidden;\">\n<div style=\"background-color: rgba(248, 249, 250, 1); padding: 12px 15px; font-weight: 600;\"><span style=\"display: inline-block; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; margin-right: 5px; background-color: rgba(255, 234, 167, 1); color: rgba(211, 84, 0, 1);\">网络问题</span> 错误1: 连接超时错误</div>\n<div style=\"padding: 15px;\">\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">错误提示示例：</h4>\n<div>Could not transfer artifact com.example:demo:jar:1.0.0 from/to central (https://repo.maven.apache.org/maven2): Connect timed out</div>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">严重程度：<span style=\"font-weight: bold; color: rgba(231, 76, 60, 1);\">高</span></h4>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">问题描述：</h4>\n<p style=\"margin-bottom: 15px; text-align: justify;\">Maven无法连接到远程仓库下载依赖，通常是由于网络连接问题、代理配置错误或仓库地址不可用导致。</p>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">排查步骤：</h4>\n<ol style=\"margin: 10px 0 15px 25px;\">\n<li style=\"margin-bottom: 8px;\"><strong>检查网络连接</strong>：确认网络连接正常，尝试访问Maven中央仓库网站 (https://repo.maven.apache.org)</li>\n<li style=\"margin-bottom: 8px;\"><strong>检查代理配置</strong>：如果使用代理上网，检查Maven的settings.xml文件中的代理配置\n<div>&lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;host&gt;proxy.example.com&lt;/host&gt; &lt;port&gt;8080&lt;/port&gt; &lt;username&gt;user&lt;/username&gt; &lt;password&gt;pass&lt;/password&gt; &lt;/proxy&gt;</div>\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>配置镜像仓库</strong>：使用阿里云等国内镜像加速下载\n<div>&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/mirror&gt;</div>\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>检查防火墙设置</strong>：确保防火墙没有阻止Maven访问网络</li>\n<li style=\"margin-bottom: 8px;\"><strong>尝试强制更新</strong>：使用<span>mvn -U clean compile</span>强制更新依赖</li>\n</ol></div>\n</div>\n<div style=\"border-radius: 5px; margin: 20px 0; overflow: hidden;\">\n<div style=\"background-color: rgba(248, 249, 250, 1); padding: 12px 15px; font-weight: 600;\"><span style=\"display: inline-block; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; margin-right: 5px; background-color: rgba(255, 234, 167, 1); color: rgba(211, 84, 0, 1);\">网络问题</span> 错误2: SSL/TLS握手失败</div>\n<div style=\"padding: 15px;\">\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">错误提示示例：</h4>\n<div>Received fatal alert: handshake_failure<br />javax.net.ssl.SSLHandshakeException: SSL peer shut down incorrectly</div>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">严重程度：<span style=\"font-weight: bold; color: rgba(231, 76, 60, 1);\">高</span></h4>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">问题描述：</h4>\n<p style=\"margin-bottom: 15px; text-align: justify;\">Maven与远程仓库的SSL/TLS握手失败，通常是因为JDK版本过旧、系统时间不正确或证书问题。</p>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">排查步骤：</h4>\n<ol style=\"margin: 10px 0 15px 25px;\">\n<li style=\"margin-bottom: 8px;\"><strong>升级JDK版本</strong>：确保使用JDK 8u101+或JDK 11+版本，旧版本可能不支持新的TLS协议</li>\n<li style=\"margin-bottom: 8px;\"><strong>检查系统时间</strong>：确保系统时间正确，错误的系统时间会导致SSL证书验证失败</li>\n<li style=\"margin-bottom: 8px;\"><strong>导入自签名证书</strong>：如果是公司内网自签名证书，需要导入到JDK信任库\n<div># 导出证书 keytool -export -alias example -keystore example.keystore -rfc -file example.cer # 导入到JDK信任库 keytool -import -alias example -file example.cer -keystore $JAVA_HOME/jre/lib/security/cacerts</div>\n\n\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>跳过SSL验证</strong>（不推荐用于生产）：\n<div>mvn -Dmaven.wagon.http.ssl.insecure=true \\ -Dmaven.wagon.http.ssl.allowall=true clean install</div>\n\n\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>更新Maven版本</strong>：使用最新版本的Maven（3.6.3+）</li>\n\n\n</ol>\n</div>\n\n\n</div>\n<h2 style=\"color: rgba(52, 73, 94, 1); font-size: 22px; margin: 25px 0 15px; padding-left: 10px;\">三、缓存相关问题</h2>\n<div style=\"border-radius: 5px; margin: 20px 0; overflow: hidden;\">\n<div style=\"background-color: rgba(248, 249, 250, 1); padding: 12px 15px; font-weight: 600;\"><span style=\"display: inline-block; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; margin-right: 5px; background-color: rgba(162, 155, 254, 1); color: rgba(45, 52, 54, 1);\">缓存问题</span> 错误3: 本地缓存过期</div>\n<div style=\"padding: 15px;\">\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">错误提示示例：</h4>\n<div>... was cached in the local repository, resolution will not be reattempted until the update interval has elapsed or updates are forced</div>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">严重程度：<span style=\"font-weight: bold; color: rgba(243, 156, 18, 1);\">中</span></h4>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">问题描述：</h4>\n<p style=\"margin-bottom: 15px; text-align: justify;\">Maven本地仓库缓存了错误或过期的依赖，默认更新策略导致不会立即重新下载。</p>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">排查步骤：</h4>\n<ol style=\"margin: 10px 0 15px 25px;\">\n<li style=\"margin-bottom: 8px;\"><strong>强制更新依赖</strong>：使用<span>-U</span>参数强制更新\n<div>mvn clean install -U</div>\n\n\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>清理本地仓库</strong>：删除本地仓库中对应的依赖目录\n<div># 删除特定依赖 rm -rf ~/.m2/repository/com/example/demo/ # 或使用Maven命令 mvn dependency:purge-local-repository -DmanualInclude=\"com.example:demo\"</div>\n\n\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>修改更新策略</strong>：在settings.xml中配置更新策略为always\n<div>&lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;releases&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt;</div>\n\n\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>清理IDE缓存</strong>：在IDE中执行\"Maven Reimport\"或\"Reload Project\"</li>\n<li style=\"margin-bottom: 8px;\"><strong>删除.lastUpdated文件</strong>：清理本地仓库中损坏的元数据文件\n<div># Linux/Mac find ~/.m2/repository -name \"*.lastUpdated\" -delete # Windows (PowerShell) Get-ChildItem -Path ~/.m2/repository -Filter *.lastUpdated -Recurse | Remove-Item</div>\n\n\n</li>\n\n\n</ol>\n</div>\n\n\n</div>\n<div style=\"border-radius: 5px; margin: 20px 0; overflow: hidden;\">\n<div style=\"background-color: rgba(248, 249, 250, 1); padding: 12px 15px; font-weight: 600;\"><span style=\"display: inline-block; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; margin-right: 5px; background-color: rgba(162, 155, 254, 1); color: rgba(45, 52, 54, 1);\">缓存问题</span> 错误4: HTTPS协议要求</div>\n<div style=\"padding: 15px;\">\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">错误提示示例：</h4>\n<div>Return code is: 501 , ReasonPhrase:HTTPS Required.<br />Using insecure protocol with repository ...</div>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">严重程度：<span style=\"font-weight: bold; color: rgba(243, 156, 18, 1);\">中</span></h4>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">问题描述：</h4>\n<p style=\"margin-bottom: 15px; text-align: justify;\">Maven中央仓库已强制使用HTTPS协议，但配置中仍使用HTTP协议访问。</p>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">排查步骤：</h4>\n<ol style=\"margin: 10px 0 15px 25px;\">\n<li style=\"margin-bottom: 8px;\"><strong>更新仓库URL</strong>：确保所有repository配置使用https协议\n<div>&lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;/repository&gt;</div>\n\n\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>更新Maven版本</strong>：升级到Maven 3.2.3+，旧版本可能不支持自动重定向</li>\n<li style=\"margin-bottom: 8px;\"><strong>检查镜像配置</strong>：确保镜像地址也使用HTTPS\n<div>&lt;mirror&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Aliyun Maven Mirror&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/mirror&gt;</div>\n\n\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>清理缓存文件</strong>：删除相关缓存文件\n<div># 清理仓库元数据文件 find ~/.m2/repository -name \"_remote.repositories\" -delete find ~/.m2/repository -name \"*.lastUpdated\" -delete</div>\n\n\n</li>\n\n\n</ol>\n</div>\n\n\n</div>\n<h2 style=\"color: rgba(52, 73, 94, 1); font-size: 22px; margin: 25px 0 15px; padding-left: 10px;\">四、依赖解析问题</h2>\n<div style=\"border-radius: 5px; margin: 20px 0; overflow: hidden;\">\n<div style=\"background-color: rgba(248, 249, 250, 1); padding: 12px 15px; font-weight: 600;\"><span style=\"display: inline-block; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; margin-right: 5px; background-color: rgba(253, 121, 168, 1); color: rgba(45, 52, 54, 1);\">依赖问题</span> 错误5: 依赖不存在</div>\n<div style=\"padding: 15px;\">\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">错误提示示例：</h4>\n<div>Could not find artifact com.example:demo:jar:1.0.0 in central (https://repo.maven.apache.org/maven2)</div>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">严重程度：<span style=\"font-weight: bold; color: rgba(231, 76, 60, 1);\">高</span></h4>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">问题描述：</h4>\n<p style=\"margin-bottom: 15px; text-align: justify;\">指定的依赖在仓库中不存在，可能是groupId、artifactId、version拼写错误，或依赖确实不存在于配置的仓库中。</p>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">排查步骤：</h4>\n<ol style=\"margin: 10px 0 15px 25px;\">\n<li style=\"margin-bottom: 8px;\"><strong>检查依赖坐标</strong>：确认groupId、artifactId、version拼写正确</li>\n<li style=\"margin-bottom: 8px;\"><strong>搜索依赖</strong>：在Maven中央仓库(https://search.maven.org)或公司私有仓库中搜索确认依赖是否存在</li>\n<li style=\"margin-bottom: 8px;\"><strong>检查作用域</strong>：确认依赖的作用域(scope)是否正确，比如test、provided等</li>\n<li style=\"margin-bottom: 8px;\"><strong>检查仓库配置</strong>：如果依赖在公司私有仓库，确保settings.xml中正确配置了仓库\n<div>&lt;server&gt; &lt;id&gt;my-repo&lt;/id&gt; &lt;username&gt;user&lt;/username&gt; &lt;password&gt;pass&lt;/password&gt; &lt;/server&gt;</div>\n\n\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>检查排除配置</strong>：查看是否有<span>&lt;exclusions&gt;</span>排除了该依赖</li>\n<li style=\"margin-bottom: 8px;\"><strong>清理并重试</strong>：清理本地仓库中该依赖的文件夹，重新下载</li>\n\n\n</ol>\n<div style=\"background-color: rgba(255, 248, 225, 1); padding: 15px; margin: 20px 0; border-radius: 0 5px 5px 0;\"><strong>注意：</strong> 某些依赖可能有特殊的classifier（如tests、sources），需要确认是否需要指定。</div>\n\n\n</div>\n\n\n</div>\n<div style=\"border-radius: 5px; margin: 20px 0; overflow: hidden;\">\n<div style=\"background-color: rgba(248, 249, 250, 1); padding: 12px 15px; font-weight: 600;\"><span style=\"display: inline-block; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; margin-right: 5px; background-color: rgba(253, 121, 168, 1); color: rgba(45, 52, 54, 1);\">依赖问题</span> 错误6: 依赖解析失败</div>\n<div style=\"padding: 15px;\">\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">错误提示示例：</h4>\n<div>Could not resolve dependencies for project com.example:my-project:jar:1.0: Failure to find com.example:lib:jar:2.0 in ...</div>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">严重程度：<span style=\"font-weight: bold; color: rgba(231, 76, 60, 1);\">高</span></h4>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">问题描述：</h4>\n<p style=\"margin-bottom: 15px; text-align: justify;\">Maven无法解析项目的依赖关系，可能是版本冲突、依赖链断裂或仓库配置问题。</p>\n<h4 style=\"color: rgba(44, 62, 80, 1); font-size: 16px; margin: 15px 0 8px;\">排查步骤：</h4>\n<ol style=\"margin: 10px 0 15px 25px;\">\n<li style=\"margin-bottom: 8px;\"><strong>分析依赖树</strong>：使用<span>mvn dependency:tree</span>查看依赖关系\n<div>mvn dependency:tree -Dverbose</div>\n\n\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>排除冲突依赖</strong>：使用<span>&lt;exclusions&gt;</span>排除冲突的传递依赖\n<div>&lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;module-a&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;conflict-group&lt;/groupId&gt; &lt;artifactId&gt;conflict-artifact&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;</div>\n\n\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>检查版本兼容性</strong>：尝试升级或降级相关依赖版本</li>\n<li style=\"margin-bottom: 8px;\"><strong>使用dependency:analyze</strong>：分析依赖问题\n<div>mvn dependency:analyze</div>\n\n\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>检查循环依赖</strong>：使用maven-enforcer-plugin检测循环依赖\n<div>mvn enforcer:enforce -Drules=banCircularDependencies</div>\n\n\n</li>\n<li style=\"margin-bottom: 8px;\"><strong>检查dependencyManagement</strong>：查看父pom是否覆盖了依赖版本</li>\n\n\n</ol>\n</div>\n\n\n</div>\n<h2 style=\"color: rgba(52, 73, 94, 1); font-size: 22px; margin: 25px 0 15px; padding-left: 10px;\">五、通用排查建议</h2>\n<div style=\"background-color: rgba(240, 247, 255, 1); padding: 15px; margin: 20px 0; border-radius: 0 5px 5px 0;\">\n<h3 style=\"color: rgba(44, 62, 80, 1); font-size: 18px; margin: 0 0 10px;\">标准排查流程：</h3>\n<ol style=\"margin: 10px 0 15px 25px;\">\n<li style=\"margin-bottom: 8px;\"><strong>清理并强制更新</strong>：首先尝试<span>mvn clean install -U</span>，这能解决大部分缓存问题</li>\n<li style=\"margin-bottom: 8px;\"><strong>检查网络连接</strong>：确认可以访问Maven仓库，使用浏览器测试</li>\n<li style=\"margin-bottom: 8px;\"><strong>查看详细日志</strong>：使用<span>mvn -X</span>或<span>mvn -e</span>获取详细错误信息</li>\n<li style=\"margin-bottom: 8px;\"><strong>验证依赖坐标</strong>：在Maven中央仓库确认依赖是否存在</li>\n<li style=\"margin-bottom: 8px;\"><strong>检查配置文件</strong>：验证settings.xml和pom.xml配置，特别是镜像和仓库配置</li>\n<li style=\"margin-bottom: 8px;\"><strong>分析依赖关系</strong>：使用<span>mvn dependency:tree</span>分析依赖树</li>\n<li style=\"margin-bottom: 8px;\"><strong>检查IDE配置</strong>：在IDE中执行Maven Reimport/Reload Project</li>\n<li style=\"margin-bottom: 8px;\"><strong>更新工具版本</strong>：确保使用最新稳定版的Maven和JDK</li>\n\n\n</ol>\n</div>\n<h2 style=\"color: rgba(52, 73, 94, 1); font-size: 22px; margin: 25px 0 15px; padding-left: 10px;\">六、常用Maven命令</h2>\n<table>\n<thead>\n<tr><th style=\"background-color: rgba(44, 62, 80, 1); color: rgba(255, 255, 255, 1); font-weight: 600; text-align: left; padding: 12px 15px; width: 30%;\">命令</th><th style=\"background-color: rgba(44, 62, 80, 1); color: rgba(255, 255, 255, 1); font-weight: 600; text-align: left; padding: 12px 15px; width: 20%;\">参数</th><th style=\"background-color: rgba(44, 62, 80, 1); color: rgba(255, 255, 255, 1); font-weight: 600; text-align: left; padding: 12px 15px; width: 50%;\">用途</th>\n</tr>\n\n\n</thead>\n<tbody>\n<tr>\n<td style=\"padding: 12px 15px;\"><span>mvn clean install -U</span></td>\n<td style=\"padding: 12px 15px;\">-U (强制更新)</td>\n<td style=\"padding: 12px 15px;\">清理并强制更新所有依赖，解决缓存问题</td>\n\n\n</tr>\n<tr style=\"background-color: rgba(248, 249, 250, 1);\">\n<td style=\"padding: 12px 15px;\"><span>mvn dependency:tree</span></td>\n<td style=\"padding: 12px 15px;\">-Dverbose (详细模式)</td>\n<td style=\"padding: 12px 15px;\">显示依赖树，分析依赖冲突</td>\n\n\n</tr>\n<tr>\n<td style=\"padding: 12px 15px;\"><span>mvn dependency:analyze</span></td>\n<td style=\"padding: 12px 15px;\">-DignoreNonCompile</td>\n<td style=\"padding: 12px 15px;\">分析依赖使用情况，发现未使用的依赖</td>\n\n\n</tr>\n<tr style=\"background-color: rgba(248, 249, 250, 1);\">\n<td style=\"padding: 12px 15px;\"><span>mvn dependency:purge-local-repository</span></td>\n<td style=\"padding: 12px 15px;\">-DmanualInclude=\"groupId:artifactId\"</td>\n<td style=\"padding: 12px 15px;\">清理本地仓库中的特定依赖</td>\n\n\n</tr>\n<tr>\n<td style=\"padding: 12px 15px;\"><span>mvn help:effective-pom</span></td>\n<td style=\"padding: 12px 15px;\">-Doutput=effective-pom.xml</td>\n<td style=\"padding: 12px 15px;\">查看生效的POM配置（合并了所有父POM）</td>\n\n\n</tr>\n<tr style=\"background-color: rgba(248, 249, 250, 1);\">\n<td style=\"padding: 12px 15px;\"><span>mvn -X clean compile</span></td>\n<td style=\"padding: 12px 15px;\">-X (详细日志)<br />-e (显示错误)</td>\n<td style=\"padding: 12px 15px;\">启用详细日志，帮助诊断问题</td>\n\n\n</tr>\n<tr>\n<td style=\"padding: 12px 15px;\"><span>mvn versions:display-dependency-updates</span></td>\n<td style=\"padding: 12px 15px;\">&nbsp;</td>\n<td style=\"padding: 12px 15px;\">检查依赖是否有新版本</td>\n\n\n</tr>\n\n\n</tbody>\n\n\n</table>\n<div style=\"background-color: rgba(255, 235, 238, 1); padding: 15px; margin: 20px 0; border-radius: 0 5px 5px 0;\">\n<h3 style=\"color: rgba(44, 62, 80, 1); font-size: 18px; margin: 0 0 10px;\">⚠️ 重要提醒</h3>\n<p style=\"margin-bottom: 0; text-align: justify;\"><strong>生产环境中不要跳过SSL验证</strong>，应正确配置证书。不要将明文密码提交到版本控制系统，使用Maven的密码加密功能或从环境变量读取。</p>\n\n\n</div>\n<div style=\"margin-top: 30px; padding-top: 15px; color: rgba(127, 140, 141, 1); font-size: 14px; text-align: center;\">\n<p>Maven依赖错误排查指南 | 最后更新: 2026年1月</p>\n<p>本文档总结了常见的Maven依赖问题及其解决方案，适用于大多数Java开发场景。</p>\n\n\n</div>\n\n\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 14:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/weipt0106\">山岚破晓</a>&nbsp;\n阅读(<span id=\"post_view_count\">55</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "10只老鼠试毒1000瓶水问题思考笔记",
      "link": "https://www.cnblogs.com/mysticbinary/p/19436756",
      "published": "",
      "description": "<div class=\"postTitle\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/mysticbinary/p/19436756\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 13:22\">\n    <span>10只老鼠试毒1000瓶水问题思考笔记</span>\n    \n\n</a>\n\n        </div>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#问题描述\" rel=\"noopener nofollow\">问题描述</a></li><li><a href=\"#原理图\" rel=\"noopener nofollow\">原理图</a></li><li><a href=\"#思想\" rel=\"noopener nofollow\">思想</a></li><li><a href=\"#比特世界和物理世界的差异\" rel=\"noopener nofollow\">比特世界和物理世界的差异</a></li></ul></div><p></p>\n<hr />\n<h1 id=\"问题描述\">问题描述</h1>\n<p>1000瓶水里有一瓶有毒，可以使用10只老鼠去尝毒，当老鼠喝下毒水1个小时后死去，请设计一种方案，能够在1小时找到这瓶毒药。</p>\n<hr />\n<h1 id=\"原理图\">原理图</h1>\n<p>如果从二进制编码位的视角来解决这个问题则很简单：<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1552062/202601/1552062-20260104132050245-398290625.png\" /></p>\n<ul>\n<li>\n<p>给瓶子和老鼠编号：将1000瓶水编号为0到999。给10只老鼠从左到右（或从右到左）编号0到9。</p>\n<ul>\n<li>用二进制表示：将瓶子编号转换为10位二进制数（例如，瓶子1是0000000001，瓶子1000是1111101000）。</li>\n</ul>\n</li>\n<li>\n<p>如果瓶子编号的第1位是1（从右往左数），则将该瓶水混入给第1只老鼠喝的混合液中。</p>\n</li>\n<li>\n<p>如果1个小时候后，哪个位的老鼠死去，记录哪个老鼠的位。<br />\n图片假设365有毒，则老鼠0号、老鼠2号、老鼠3号、老鼠0号、老鼠5号、老鼠6号、老鼠8号死去标记为1，其余位标记0 ，转10进制=365。</p>\n</li>\n</ul>\n<hr />\n<h1 id=\"思想\">思想</h1>\n<p>这个问题看似是一个逻辑谜题，但实际上体现了信息编码的核心思想：<strong>用最少的“检测位”区分最多的可能性。</strong></p>\n<p>这种思维在现代计算机科学、通信技术和信息论中无处不在。<br />\n从硬盘的纠错编码到网络传输的数据校验，从条形码到二维码，二进制编码的思想贯穿了我们的数字世界。</p>\n<hr />\n<p>解决这个问题的关键在于二进制编号。我们将 1000 瓶药水编号为 0-999。<br />\n用二进制表示这些编号时，1000 ≤ 1024 = 2¹⁰，这意味着我们需要 10 位二进制数就可以表示所有瓶子。<br />\n每只老鼠对应二进制编码中的一位。10 位二进制，正好对应 10 只老鼠。<br />\n<strong>这种方法能够一次性测试所有瓶子，而不是传统的逐瓶测试。</strong> 效率提升很大。</p>\n<hr />\n<h1 id=\"比特世界和物理世界的差异\">比特世界和物理世界的差异</h1>\n<p>二进制编码方案在理论计算机科学和逻辑谜题中是完美的，但在实际毒理学检测或现实场景中，往往需要结合剂量反应曲线、分组测试或现代分析化学方法（如色谱、质谱）来更可靠地识别毒物。在实践中，通常会采用分段测试或浓缩样本的方式，以确保检测的灵敏度和可靠性。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-04 13:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/mysticbinary\">Mysticbinary</a>&nbsp;\n阅读(<span id=\"post_view_count\">244</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[浏览器/Cookie] 2026年了，Google力推移除的浏览器Cookie技术消失了吗？",
      "link": "https://www.cnblogs.com/johnnyzen/p/19437233",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/johnnyzen/p/19437233\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 12:51\">\n    <span>[浏览器/Cookie] 2026年了，Google力推移除的浏览器Cookie技术消失了吗？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"浏览器cookie技术\">浏览器Cookie技术</h1>\n<h2 id=\"序言\">序言</h2>\n<p>今日打开电脑浏览器访问一个新网站时，再次弹出了是否需要接受cookie策略的弹窗。</p>\n<p>已经好几年不写前端代码了，在笔者的印象中，至少2018年前就一直在说Google Chrome要移除cookie技术。<br />\n那么到了2026年了，为啥这个技术还在呢？相信不搞前端或不熟悉前端进展的小伙伴们也有此疑问。</p>\n<h2 id=\"开门见山先说结论\">开门见山，先说结论</h2>\n<p>到了2026年，关于Google Chrome浏览器去除第三方Cookie（Third-Party Cookies）这件事，答案其实和几年前大家预想的<strong>完全不同</strong>。</p>\n<p>简单直接地回答：<strong>并没有消失，而且Google已经彻底放弃了“强力去除”的计划。</strong></p>\n<p>到了2026年1月的今天，第三方Cookie依然存在于Chrome浏览器中，并没有被Google强制移除。这背后发生了一个巨大的战略转折。</p>\n<p>为了更清楚现在的状况，让AI梳理了这一变化的来龙去脉：</p>\n<h2 id=\"核心现状计划已正式终止\">核心现状：计划已正式终止</h2>\n<p>你可能还记得几年前Google一直在推行的“隐私沙盒”（Privacy Sandbox）计划，原本是要像Safari和Firefox那样，直接默认阻止第三方Cookie。</p>\n<p>但在<strong>2025年4月</strong>，Google正式宣布终止了在Chrome中逐步淘汰第三方Cookie的计划。</p>\n<ul>\n<li><strong>现在的机制：</strong> Google决定维持现状，也就是继续沿用目前的用户选择方式，<strong>不再强制默认阻止</strong>第三方Cookie。</li>\n<li><strong>不再推出新功能：</strong> Google不会再推出新的独立提示来处理第三方Cookie，这意味着用户不会被强制要求做出选择，除非他们自己主动去设置中调整。</li>\n</ul>\n<h2 id=\"为什么计划会夭折\">为什么计划会“夭折”？</h2>\n<p>到了2026年回头看，这个计划的终止并非偶然，主要受到了以下几方面因素的强力影响：</p>\n<ol>\n<li>\n<p><strong>监管与反垄断压力（关键因素）</strong></p>\n<ul>\n<li><strong>英国CMA（竞争与市场管理局）</strong> 长期监督Google的这一举措，担心其会通过“隐私沙盒”中的替代技术（如Topics API等）进一步巩固其在广告领域的垄断地位。</li>\n<li><strong>美国司法部</strong> 也在对Google进行反垄断审判。面对这些法律风险，Google最终选择妥协，放弃了原本的替代方案。</li>\n</ul>\n</li>\n<li>\n<p><strong>技术方案的失败</strong></p>\n<ul>\n<li>Google原本开发了十余项“隐私沙盒”API（如Topics、FLEDGE等）来替代Cookie的功能，但在2025年底，Google确认这些技术<strong>采纳率低</strong>且面临合规风险，因此正式停用了它们。</li>\n<li>行业普遍认为这些替代方案并没有解决根本问题，反而可能让Google掌握更多数据。</li>\n</ul>\n</li>\n<li>\n<p><strong>行业生态的反对</strong></p>\n<ul>\n<li>广告商、出版商和开发者普遍反对这一激进的改变。数据显示，如果直接移除第三方Cookie，发布商的广告收入会大幅下降（有报告指出可能减少20%以上）。整个数字广告生态并没有准备好接受Google提供的“替代品”。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"现在格局cookie还在但ai来了\">现在格局：Cookie还在，但AI来了</h2>\n<p>到了2026年，虽然第三方Cookie“活”了下来，但浏览器的隐私策略重心发生了偏移：</p>\n<ul>\n<li><strong>Cookie的存续：</strong> Chrome将继续支持第三方Cookie，但同时也强调会进一步提升用户在Cookie方面的<strong>选择权</strong>。如果你（用户）想屏蔽，依然可以通过设置或插件来实现，但不再是浏览器强制“一刀切”。</li>\n<li><strong>战略转移：</strong> Google将重心从“修补广告追踪”转向了<strong>AI代理（AI Agents）</strong>。现在的趋势是利用AI来理解用户需求并促成交易，而不是单纯依赖Cookie进行行为追踪。</li>\n<li><strong>保留的技术：</strong> 虽然大部分“隐私沙盒”技术被砍了，但有几项获得行业较高认可的技术得以保留并优化，例如：\n<ul>\n<li><strong>CHIPS</strong>（用于改善Cookie隐私和安全性）</li>\n<li><strong>FedCM</strong>（用于简化联合登录流程）</li>\n<li><strong>Private State Tokens</strong>（用于反欺诈）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"话题总结\">话题总结</h2>\n<p>到了2026年的今天，你可以放心，那个困扰了互联网行业多年的“Chrome将彻底杀死Cookie”的末日时钟，<strong>已经停止了</strong>。</p>\n<p>Google最终没有选择通过“隐私沙盒”来强力去除Cookie，而是选择让市场和监管来决定Cookie的未来。现在的局面是：<strong>Cookie依然存在，但行业正在向第一方数据和AI驱动的广告模式迁移。</strong></p>\n<h1 id=\"x-参考文献\">X 参考文献</h1>\n\n</div>\n<div id=\"MySignature\">\n    <div class=\"essaySuffix-box\">\n    <div class=\"essaySuffix-box-left\" style=\"margin: 6px auto;\">\n        <img alt=\"QQ沟通交流群\" src=\"https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148\" />\n    </div>\n<div class=\"essaySuffix-box-right\">\n    <span class=\"essaySuffix-right-title\">本文作者</span>：\n        <strong><span><a href=\"https://github.com/Johnny-ZTSD\" target=\"_blank\">千千寰宇</a></span></strong>\n    <br />\n    <span style=\"font-weight: bold; white-space: nowrap;\">本文链接</span>：\n        <a href=\"https://www.cnblogs.com/johnnyzen\" id=\"articleLinkElement\" target=\"_blank\"> https://www.cnblogs.com/johnnyzen</a>\n    <br />\n    <span class=\"essaySuffix-right-title\">关于博文</span>：评论和私信会在第一时间回复，或<a href=\"https://msg.cnblogs.com/msg/send/johnnyzen\" target=\"_blank\">直接私信</a>我。\n    <br />\n    <span class=\"essaySuffix-right-title\">版权声明</span>：本博客所有文章除特别声明外，均采用 <a alt=\"BY-NC-SA\" href=\"http://blog.sina.com.cn/s/blog_896327b90102y6c6.html\" target=\"_blank\" title=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">BY-NC-SA</a> \n    许可协议。转载请注明出处！<br />\n    <span class=\"essaySuffix-right-title\">日常交流</span>：大数据与软件开发-QQ交流群: 774386015<strong>\n        <span style=\"color: #ff0000; font-size: 12pt;\">【<a href=\"\" id=\"post-up\">入群二维码</a>】</span></strong>参见左下角。您的支持、鼓励<span style=\"color: #ff0000; font-size: 12pt;\"></span>是博主技术写作的重要动力！\n    <br />\n</div>\n<div style=\"clear: both;\">\n</div>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 12:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/johnnyzen\">千千寰宇</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MQ如何保证消息不丢失？",
      "link": "https://www.cnblogs.com/12lisu/p/19437091",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19437091\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 12:21\">\n    <span>MQ如何保证消息不丢失？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>今天我们来聊聊一个让很多开发者头疼的话题——MQ消息丢失问题。</p>\n<p>有些小伙伴在工作中，一提到消息队列就觉得很简单，但真正遇到线上消息丢失时，排查起来却让人抓狂。</p>\n<p>其实，我在实际工作中，也遇到过MQ消息丢失的情况。</p>\n<p>今天这篇文章，专门跟大家一起聊聊这个话题，希望对你会有所帮助。</p>\n<h2 id=\"一消息丢失的三大环节\">一、消息丢失的三大环节</h2>\n<p>在深入解决方案之前，我们先搞清楚消息在哪几个环节可能丢失：</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"1-生产者发送阶段\">1. 生产者发送阶段</h3>\n<ul>\n<li>网络抖动导致发送失败</li>\n<li>生产者宕机未发送</li>\n<li>Broker处理失败未返回确认</li>\n</ul>\n<h3 id=\"2-broker存储阶段\">2. Broker存储阶段</h3>\n<ul>\n<li>内存消息未持久化，重启丢失</li>\n<li>磁盘故障导致数据丢失</li>\n<li>集群切换时消息丢失</li>\n</ul>\n<h3 id=\"3-消费者处理阶段\">3. 消费者处理阶段</h3>\n<ul>\n<li>自动确认模式下处理异常</li>\n<li>消费者宕机处理中断</li>\n<li>手动确认但忘记确认</li>\n</ul>\n<p>理解了问题根源，接下来我们看5种实用的解决方案。</p>\n<h2 id=\"二方案一生产者确认机制\">二、方案一：生产者确认机制</h2>\n<h3 id=\"核心原理\">核心原理</h3>\n<p>生产者发送消息后等待Broker确认，确保消息成功到达。</p>\n<p>这是防止消息丢失的第一道防线。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"关键实现\">关键实现</h3>\n<pre><code class=\"language-java\">// RabbitMQ生产者确认配置\n@Bean\npublic RabbitTemplate rabbitTemplate() {\n    RabbitTemplate template = new RabbitTemplate(connectionFactory);\n    template.setConfirmCallback((correlationData, ack, cause) -&gt; {\n        if (ack) {\n            // 消息成功到达Broker\n            messageStatusService.markConfirmed(correlationData.getId());\n        } else {\n            // 发送失败，触发重试\n            retryService.scheduleRetry(correlationData.getId());\n        }\n    });\n    return template;\n}\n\n// 可靠发送方法\npublic void sendReliable(String exchange, String routingKey, Object message) {\n    String messageId = generateId();\n    // 先落库保存发送状态\n    messageStatusService.saveSendingStatus(messageId, message);\n    \n    // 发送持久化消息\n    rabbitTemplate.convertAndSend(exchange, routingKey, message, msg -&gt; {\n        msg.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);\n        msg.getMessageProperties().setMessageId(messageId);\n        return msg;\n    }, new CorrelationData(messageId));\n}\n</code></pre>\n<h3 id=\"适用场景\">适用场景</h3>\n<ul>\n<li>对消息可靠性要求高的业务</li>\n<li>金融交易、订单处理等关键业务</li>\n<li>需要精确知道消息发送结果的场景</li>\n</ul>\n<h2 id=\"三方案二消息持久化机制\">三、方案二：消息持久化机制</h2>\n<h3 id=\"核心原理-1\">核心原理</h3>\n<p>将消息保存到磁盘，确保Broker重启后消息不丢失。</p>\n<p>这是防止Broker端消息丢失的关键。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"关键实现-1\">关键实现</h3>\n<pre><code class=\"language-java\">// 持久化队列配置\n@Bean\npublic Queue orderQueue() {\n    return QueueBuilder.durable(\"order.queue\")  // 队列持久化\n            .deadLetterExchange(\"order.dlx\")    // 死信交换机\n            .build();\n}\n\n// 发送持久化消息\npublic void sendPersistentMessage(Object message) {\n    rabbitTemplate.convertAndSend(\"order.exchange\", \"order.create\", message, msg -&gt; {\n        msg.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT); // 消息持久化\n        return msg;\n    });\n}\n\n// Kafka持久化配置\n@Bean\npublic ProducerFactory&lt;String, Object&gt; producerFactory() {\n    Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();\n    props.put(ProducerConfig.ACKS_CONFIG, \"all\"); // 所有副本确认\n    props.put(ProducerConfig.RETRIES_CONFIG, 3);   // 重试次数\n    props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true); // 幂等性\n    return new DefaultKafkaProducerFactory&lt;&gt;(props);\n}\n</code></pre>\n<h3 id=\"优缺点\">优缺点</h3>\n<p><strong>优点：</strong></p>\n<ul>\n<li>有效防止Broker重启导致的消息丢失</li>\n<li>配置简单，效果明显</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>磁盘IO影响性能</li>\n<li>需要足够的磁盘空间</li>\n</ul>\n<h2 id=\"四方案三消费者确认机制\">四、方案三：消费者确认机制</h2>\n<h3 id=\"核心原理-2\">核心原理</h3>\n<p>消费者处理完消息后手动向Broker发送确认，Broker收到确认后才删除消息。</p>\n<p>这是保证消息不丢失的最后一道防线。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"关键实现-2\">关键实现</h3>\n<pre><code class=\"language-java\">// 手动确认消费者\n@RabbitListener(queues = \"order.queue\")\npublic void handleMessage(Order order, Message message, Channel channel) {\n    long deliveryTag = message.getMessageProperties().getDeliveryTag();\n    \n    try {\n        // 业务处理\n        orderService.processOrder(order);\n        \n        // 手动确认\n        channel.basicAck(deliveryTag, false);\n        log.info(\"消息处理完成: {}\", order.getOrderId());\n        \n    } catch (Exception e) {\n        log.error(\"消息处理失败: {}\", order.getOrderId(), e);\n        \n        // 处理失败，重新入队\n        channel.basicNack(deliveryTag, false, true);\n    }\n}\n\n// 消费者容器配置\n@Bean\npublic SimpleRabbitListenerContainerFactory containerFactory() {\n    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n    factory.setAcknowledgeMode(AcknowledgeMode.MANUAL); // 手动确认\n    factory.setPrefetchCount(10); // 预取数量\n    factory.setConcurrentConsumers(3); // 并发消费者\n    return factory;\n}\n</code></pre>\n<h3 id=\"注意事项\">注意事项</h3>\n<ul>\n<li>确保业务处理完成后再确认</li>\n<li>合理设置预取数量，避免内存溢出</li>\n<li>处理异常时要正确使用NACK</li>\n</ul>\n<h2 id=\"五方案四事务消息机制\">五、方案四：事务消息机制</h2>\n<h3 id=\"核心原理-3\">核心原理</h3>\n<p>通过事务保证本地业务操作和消息发送的原子性，要么都成功，要么都失败。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"关键实现-3\">关键实现</h3>\n<pre><code class=\"language-java\">// 本地事务表方案\n@Transactional\npublic void createOrder(Order order) {\n    // 1. 保存订单到数据库\n    orderRepository.save(order);\n    \n    // 2. 保存消息到本地消息表\n    LocalMessage localMessage = new LocalMessage();\n    localMessage.setBusinessId(order.getOrderId());\n    localMessage.setContent(JSON.toJSONString(order));\n    localMessage.setStatus(MessageStatus.PENDING);\n    localMessageRepository.save(localMessage);\n    \n    // 3. 事务提交，本地业务和消息存储保持一致性\n}\n\n// 定时任务扫描并发送消息\n@Scheduled(fixedDelay = 5000)\npublic void sendPendingMessages() {\n    List&lt;LocalMessage&gt; pendingMessages = localMessageRepository.findByStatus(MessageStatus.PENDING);\n    \n    for (LocalMessage message : pendingMessages) {\n        try {\n            // 发送消息到MQ\n            rabbitTemplate.convertAndSend(\"order.exchange\", \"order.create\", message.getContent());\n            \n            // 更新消息状态为已发送\n            message.setStatus(MessageStatus.SENT);\n            localMessageRepository.save(message);\n            \n        } catch (Exception e) {\n            log.error(\"发送消息失败: {}\", message.getId(), e);\n        }\n    }\n}\n\n// RocketMQ事务消息\npublic void sendTransactionMessage(Order order) {\n    TransactionMQProducer producer = new TransactionMQProducer(\"order_producer\");\n    \n    // 发送事务消息\n    Message msg = new Message(\"order_topic\", \"create\", \n                             JSON.toJSONBytes(order));\n    \n    TransactionSendResult result = producer.sendMessageInTransaction(msg, null);\n    \n    if (result.getLocalTransactionState() == LocalTransactionState.COMMIT_MESSAGE) {\n        log.info(\"事务消息提交成功\");\n    }\n}\n</code></pre>\n<h3 id=\"适用场景-1\">适用场景</h3>\n<ul>\n<li>需要严格保证业务和消息一致性的场景</li>\n<li>分布式事务场景</li>\n<li>金融、电商等对数据一致性要求高的业务</li>\n</ul>\n<h2 id=\"六方案五消息重试与死信队列\">六、方案五：消息重试与死信队列</h2>\n<h3 id=\"核心原理-4\">核心原理</h3>\n<p>通过重试机制处理临时故障，通过死信队列处理最终无法消费的消息。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"关键实现-4\">关键实现</h3>\n<pre><code class=\"language-java\">// 重试队列配置\n@Bean\npublic Queue orderQueue() {\n    return QueueBuilder.durable(\"order.queue\")\n            .withArgument(\"x-dead-letter-exchange\", \"order.dlx\") // 死信交换机\n            .withArgument(\"x-dead-letter-routing-key\", \"order.dead\")\n            .withArgument(\"x-message-ttl\", 60000) // 60秒后进入死信\n            .build();\n}\n\n// 死信队列配置\n@Bean\npublic Queue orderDeadLetterQueue() {\n    return QueueBuilder.durable(\"order.dead.queue\").build();\n}\n\n// 消费者重试逻辑\n@RabbitListener(queues = \"order.queue\")\npublic void handleMessageWithRetry(Order order, Message message, Channel channel) {\n    long deliveryTag = message.getMessageProperties().getDeliveryTag();\n    \n    try {\n        orderService.processOrder(order);\n        channel.basicAck(deliveryTag, false);\n        \n    } catch (TemporaryException e) {\n        // 临时异常，重新入队重试\n        channel.basicNack(deliveryTag, false, true);\n        \n    } catch (PermanentException e) {\n        // 永久异常，直接确认进入死信队列\n        channel.basicAck(deliveryTag, false);\n        log.error(\"消息进入死信队列: {}\", order.getOrderId(), e);\n    }\n}\n\n// 死信队列消费者\n@RabbitListener(queues = \"order.dead.queue\")\npublic void handleDeadLetterMessage(Order order) {\n    log.warn(\"处理死信消息: {}\", order.getOrderId());\n    // 发送告警、记录日志、人工处理等\n    alertService.sendAlert(\"死信消息告警\", order.toString());\n}\n</code></pre>\n<h3 id=\"重试策略建议\">重试策略建议</h3>\n<ol>\n<li><strong>指数退避</strong>：1s, 5s, 15s, 30s</li>\n<li><strong>最大重试次数</strong>：3-5次</li>\n<li><strong>死信处理</strong>：人工介入或特殊处理流程</li>\n</ol>\n<h2 id=\"七方案对比与选型指南\">七、方案对比与选型指南</h2>\n<p>为了帮助大家选择合适的方案，我整理了详细的对比表：</p>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>可靠性</th>\n<th>性能影响</th>\n<th>复杂度</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生产者确认</td>\n<td>高</td>\n<td>中</td>\n<td>低</td>\n<td>所有需要可靠发送的场景</td>\n</tr>\n<tr>\n<td>消息持久化</td>\n<td>中</td>\n<td>中</td>\n<td>低</td>\n<td>Broker重启保护</td>\n</tr>\n<tr>\n<td>消费者确认</td>\n<td>高</td>\n<td>低</td>\n<td>中</td>\n<td>确保消息被成功处理</td>\n</tr>\n<tr>\n<td>事务消息</td>\n<td>最高</td>\n<td>高</td>\n<td>高</td>\n<td>强一致性要求的业务</td>\n</tr>\n<tr>\n<td>重试+死信</td>\n<td>高</td>\n<td>低</td>\n<td>中</td>\n<td>处理临时故障和最终死信</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"选型建议\">选型建议</h3>\n<p><strong>初创项目/简单业务：</strong></p>\n<ul>\n<li>生产者确认 + 消息持久化 + 消费者确认</li>\n<li>满足大部分场景，实现简单</li>\n</ul>\n<p><strong>电商/交易系统：</strong></p>\n<ul>\n<li>生产者确认 + 事务消息 + 重试机制</li>\n<li>保证数据一致性，处理复杂业务</li>\n</ul>\n<p><strong>大数据/日志处理：</strong></p>\n<ul>\n<li>消息持久化 + 消费者确认</li>\n<li>允许少量丢失，追求吞吐量</li>\n</ul>\n<p><strong>金融/支付系统：</strong></p>\n<ul>\n<li>全方案组合使用</li>\n<li>最高可靠性要求</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>消息丢失问题是消息队列使用中的常见挑战，通过今天介绍的5种方案，我们可以构建一个可靠的消息系统：</p>\n<ol>\n<li><strong>生产者确认机制</strong> - 保证消息成功发送到Broker</li>\n<li><strong>消息持久化机制</strong> - 防止Broker重启导致消息丢失</li>\n<li><strong>消费者确认机制</strong> - 确保消息被成功处理</li>\n<li><strong>事务消息机制</strong> - 保证业务和消息的一致性</li>\n<li><strong>重试与死信队列</strong> - 处理异常情况和最终死信</li>\n</ol>\n<p>有些小伙伴可能会问：\"我需要全部使用这些方案吗？</p>\n<p>\"我的建议是：<strong>根据业务需求选择合适的组合</strong>。</p>\n<p>对于关键业务，建议至少使用前三种方案；对于普通业务，可以根据实际情况适当简化。</p>\n<p>记住，没有完美的方案，只有最适合的方案。</p>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n<p>更多项目实战在我的技术网站：<a href=\"http://www.susan.net.cn/project\" rel=\"noopener nofollow\" target=\"_blank\">http://www.susan.net.cn/project</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 12:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">19</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "场论笔记（三）矢量分析基础",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19436590",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19436590\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 11:10\">\n    <span>场论笔记（三）矢量分析基础</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        矢量函数分析基础：矢量分析是矢量代数的继续，是场论的基础知识，同时也是弹性波动力学等其他学科的有用工具。其本笔记主要内容是介绍矢性函数，矢端曲线及其微分，积分计算及其性质。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"场论笔记三矢量分析基础\">场论笔记（三）矢量分析基础</h1>\n<p>​       矢量分析是矢量代数的继续，是场论的基础知识，同时也是弹性波动力学等其他学科的有用工具。其本笔记主要内容是介绍矢性函数，矢端曲线及其微分，积分计算及其性质。</p>\n<h2 id=\"11矢性函数\">1.1矢性函数</h2>\n<p>​       在矢量代数中，曾经学过矢量的模长和方向都保持不变的矢量，这种矢量称为常矢(注意：零矢量的方向为任意，可作为一种特殊的常矢量)；然而，在许多科学，技术问题中，我们常常遇到模长和方向或其中之一会改变的矢量，这种矢量称为变矢。</p>\n<p>​     <strong>Definition 1.1</strong> 设有数性变量<span class=\"math inline\">\\(t\\)</span>和变矢量<span class=\"math inline\">\\(\\mathbf{A}\\)</span>，如果对于<span class=\"math inline\">\\(t\\)</span>在某个范围<span class=\"math inline\">\\(G\\)</span>内的每一个数值，变矢量<span class=\"math inline\">\\(\\mathbf{A}\\)</span>都以一个确定的矢量和它对应，则称<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 为数性变量<span class=\"math inline\">\\(t\\)</span>的矢量函数，记作</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}=\\mathbf{A}(t) \\tag{1.1.1}\n\\]</div><p></p><p>并称<span class=\"math inline\">\\(\\mathbf{G}\\)</span>为函数<span class=\"math inline\">\\(\\mathbf{A}\\)</span>的定义域。</p>\n<p>​      矢量函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在<span class=\"math inline\">\\(Oxyz\\)</span>直角坐标系的三个坐标（即它的三个坐标系的投影），显然都是<span class=\"math inline\">\\(t\\)</span>的函数：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}(t)=[A_x(t),A_y(t),A_z(t)] \\tag{1.1.2}\n\\]</div><p></p><p>所以，矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的坐标表达式为：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}=A_x(t)\\mathbf{i}+A_y(t)\\mathbf{j}+A_z(t)\\mathbf{k} \\tag{1.1.3}\n\\]</div><p></p><p>其中<span class=\"math inline\">\\(i,j,k\\)</span>为沿<span class=\"math inline\">\\(x,y,z\\)</span>三个坐标轴正向的单位矢量。可见，一个矢性函数和三个有序的数性函数（坐标）构成一一对应的关系。</p>\n<h2 id=\"12矢端曲线\">1.2矢端曲线</h2>\n<p>​       本笔记所讲的矢量均指自由矢量，就是当两矢量的模长和方向相同时，就认为此二矢量是相等的。据此，为了能用图形来直观地表示矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的变化状态，我们就可以把<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的起点取在坐标原点。这样，当<span class=\"math inline\">\\(t\\)</span> 变化时，矢量<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 的终点<span class=\"math inline\">\\(\\mathbf{M}\\)</span>就描绘出一条曲线<span class=\"math inline\">\\(l\\)</span>; 这条曲线叫做矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的矢端曲线，亦叫做矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的图形。</p>\n<p>​      由矢量代数知道：起点在坐标原点<span class=\"math inline\">\\(\\mathbf{O}\\)</span>，终点为<span class=\"math inline\">\\(\\mathbf{M}(x,y,z)\\)</span>的矢量<span class=\"math inline\">\\(OM\\)</span>叫做点<span class=\"math inline\">\\(M\\)</span>(对于<span class=\"math inline\">\\(O\\)</span>点)的矢径，常用<span class=\"math inline\">\\(\\mathbf{r}\\)</span>表示：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{r}=OM=x\\mathbf{i}+y\\mathbf{j}+z\\mathbf{k} \\tag{1.2.1}\n\\]</div><p></p><p>当我们把矢量函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 的起点取在坐标原点时，<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>实际上就成为其终点<span class=\"math inline\">\\(M(x,y,z)\\)</span>的矢径。因此，<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的三个坐标<span class=\"math inline\">\\(A_x(t),A_y(t),A_z(t)\\)</span>就对应地等于其终点<span class=\"math inline\">\\(M\\)</span>的三个坐标<span class=\"math inline\">\\(x_{M},y_{M},z_{M}\\)</span>，即有</p>\n<p></p><div class=\"math display\">\\[\\begin{cases}\nx_{M}&amp;=A_x(t)\\\\\ny_{M}&amp;=A_y(t)\\\\\nz_{M}&amp;=A_z(t)\\\\\n\\end{cases}\n\\tag{1.2.2}\n\\]</div><p></p><p>式(1.1.2)就是矢端曲线<span class=\"math inline\">\\(l\\)</span>的以<span class=\"math inline\">\\(t\\)</span>为参数的参数方程。容易看出，曲线<span class=\"math inline\">\\(l\\)</span>的矢量方程式(1.3)和参数方程式(1.5)之间一一对应关系，只要知道其中的一个，就可以立刻写出另一个。</p>\n<h2 id=\"13矢性函数的极限和连续性\">1.3矢性函数的极限和连续性</h2>\n<p>​       和数性函数一样，矢性函数的极限和连续性，是矢性函数的微分与积分的基础概念。兹分述如下：</p>\n<p>​        <strong>Definition 1.2 矢性函数极限的定义：</strong> 设矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在点<span class=\"math inline\">\\(t_0\\)</span>的某个领域内有定义（但在<span class=\"math inline\">\\(t_0\\)</span>处可以没有定义），<span class=\"math inline\">\\(\\mathbf{A_{0}}\\)</span>为一常矢。若对于任意给定的正数<span class=\"math inline\">\\(\\varepsilon\\)</span>, 都存在一个正数<span class=\"math inline\">\\(\\delta\\)</span>，使得当<span class=\"math inline\">\\(t\\)</span>满足<span class=\"math inline\">\\(0&lt;|t-t_0|&lt;\\delta\\)</span>时，就有</p>\n<p></p><div class=\"math display\">\\[|\\mathbf{A}(t)-\\mathbf{A_{0}}|&lt;\\varepsilon \\tag{1.3.1}\n\\]</div><p></p><p>成立，则称<span class=\"math inline\">\\(\\mathbf{A}_{0}\\)</span>为矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>当<span class=\"math inline\">\\(t\\rightarrow{t_0}\\)</span>时的极限，记作</p>\n<p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}\\mathbf{A}(t)=\\mathbf{A_0} \\tag{1.3.2}\n\\]</div><p></p><p>这个定义与数性函数的极限的定义完全类似。因此，矢性函数也就有类似于数性函数中的一些极限运算法则。例如：</p>\n<p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}u(t)\\mathbf{A}(t)=\\lim_{t\\rightarrow{t_0}}u(t)\\lim_{t\\rightarrow{t_0}}\\mathbf{A}(t) \\tag{1.3.3}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}[\\mathbf{A}(t)\\pm\\mathbf{B}(t)]=\\lim_{t\\rightarrow{t_0}}{\\mathbf{A}(t)}\\pm\\lim_{t\\rightarrow{t_0}}{\\mathbf{B}(t)} \\tag{1.3.4}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}[\\mathbf{A}(t)\\cdot\\mathbf{B}(t)]=\\lim_{t\\rightarrow{t_0}}\\mathbf{A}(t)\\lim_{t\\rightarrow{t_0}}\\mathbf{B}(t) \\tag{1.3.5}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}[\\mathbf{A}(t)\\times\\mathbf{B}(t)]=\\lim_{t\\rightarrow{t_0}}\\mathbf{A}(t)\\times\\lim_{t\\rightarrow{t_0}}{\\mathbf{B}}(t) \\tag{1.3.6}\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(u(t)\\)</span>为数性函数，<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>,<span class=\"math inline\">\\(\\mathbf{B}(t)\\)</span> 为矢性函数；且当<span class=\"math inline\">\\(t\\rightarrow{t_0}\\)</span> 时，<span class=\"math inline\">\\(u(t)\\)</span>,<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>,<span class=\"math inline\">\\(\\mathbf{B}(t)\\)</span> 均有极限存在。</p>\n<p>​       依此，根据式(1.3)有下式</p>\n<p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}\\mathbf{A}(t)=\\lim_{t\\rightarrow{t_0}}A_x(t)\\mathcal{i}+\\lim_{t\\rightarrow{t_0}}A_y(t)\\mathcal{j}+\\lim_{t\\rightarrow{t_0}}A_z(t)\\mathcal{k} \\tag{1.3.7}\n\\]</div><p></p><p>此式把求矢性函数的极限，归结为求三个数性函数的极限。</p>\n<p>​       <strong>Definition 1.3 矢性函数连续性的定义：</strong>若矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在点<span class=\"math inline\">\\(t_0\\)</span>的某个领域内有定义，而且有</p>\n<p></p><div class=\"math display\">\\[\\lim_{t\\rightarrow{t_0}}\\mathbf{A}(t)=\\mathbf{A}(t_0) \\tag{1.3.8}\n\\]</div><p></p><p>则称<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在<span class=\"math inline\">\\(t=t_0\\)</span>处连续。</p>\n<p>​      容易看出:矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在点<span class=\"math inline\">\\(t_0\\)</span>处连续的充要条件是它的三个坐标函数<span class=\"math inline\">\\(A_x(t)\\)</span>, <span class=\"math inline\">\\(A_y(t)\\)</span>, <span class=\"math inline\">\\(A_z(t)\\)</span> 都在<span class=\"math inline\">\\(t_0\\)</span> 处连续。</p>\n<p>​      若矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在某个区间内的每一个点处都联系，则称它在该区间内连续。</p>\n<h2 id=\"14-矢性函数的导数与微分\">1.4 矢性函数的导数与微分</h2>\n<p>​         在上述小结中，我们初步定义了矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 及其几何意义矢端曲线，在此基础上，类似数性函数，在本节中从矢性函数的导数出发，给出矢性函数的微分及其性质。</p>\n<h3 id=\"141-矢性函数的导数\">1.4.1 矢性函数的导数</h3>\n<p>设有起点在<span class=\"math inline\">\\(O\\)</span>点的矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>，当数性变量<span class=\"math inline\">\\(t\\)</span>在其定义域内从<span class=\"math inline\">\\(t\\)</span>到<span class=\"math inline\">\\(t+\\Delta{t}(t\\neq0)\\)</span>时，对应的矢量分别为：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}(t)=OM \\tag{1.4.1}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\mathbf{A}(t+\\Delta{t})=ON \\tag{1.4.2}\n\\]</div><p></p><p>由此可定义矢性函数的增量，记作<span class=\"math inline\">\\(\\Delta{\\mathbf{A}}\\)</span>，则</p>\n<p></p><div class=\"math display\">\\[\\Delta{\\mathbf{A}}=\\mathbf{A}(t+\\Delta{t})-\\mathbf{A}(t)=MN \\tag{1.4.3}\n\\]</div><p></p><p>据此，就可以给出矢性函数的导数的定义。</p>\n<p><strong>Definition 1.4 矢性函数的导数：</strong>设矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在点<span class=\"math inline\">\\(t\\)</span>的某一领域内有定义，并设<span class=\"math inline\">\\(t+\\Delta{t}\\)</span>也在这个领域内。若<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>对应于<span class=\"math inline\">\\(\\Delta{t}\\)</span>的增量<span class=\"math inline\">\\(\\Delta{\\mathbf{A}}\\)</span> 与<span class=\"math inline\">\\(\\Delta{t}\\)</span>的之比</p>\n<p></p><div class=\"math display\">\\[\\frac{d{\\mathbf{A}}}{d{t}}=\\frac{\\mathbf{A}(t+\\Delta{t})-\\mathbf{A}(t)}{\\Delta{t}} \\tag{1.4.4}\n\\]</div><p></p><p>在<span class=\"math inline\">\\(\\Delta{t}\\rightarrow{0}\\)</span>时，及其极限存在，则称此极限为矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在点<span class=\"math inline\">\\(t\\)</span>处的导数（简称为导矢），记作 <span class=\"math inline\">\\(\\frac{d{\\mathbf{A}}}{d{t}}\\)</span> 或者 <span class=\"math inline\">\\(\\mathbf{A}^{'}(t)\\)</span>，即</p>\n<p></p><div class=\"math display\">\\[\\frac{d\\mathbf{A}(t)}{d{t}}=\\lim_{t\\rightarrow{t_0}}\\frac{\\Delta{\\mathbf{A}}}{\\Delta{t}}=\\lim_{t\\rightarrow{t_0}}\\frac{\\mathbf{A}(t+\\Delta{t})-\\mathbf{A}(t)}{\\Delta{t}} \\tag{1.4.5}\n\\]</div><p></p><p>若<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 由坐标性质给出：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}(t)=A_x(t)\\mathbf{i}+A_y(t)\\mathbf{j}+A_z(t)\\mathbf{k} \\tag{1.4.6}\n\\]</div><p></p><p>且函数<span class=\"math inline\">\\(A_x(t),A_y(t),A_z(t)\\)</span> 在点<span class=\"math inline\">\\(t\\)</span>可导，则有</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n\\frac{d{\\mathbf{A}}}{d{t}}&amp;=\\lim_{\\Delta{t}\\rightarrow{0}}\\frac{\\Delta\\mathbf{A}}{\\Delta{t}}\\\\\n&amp;=\\lim_{\\Delta{t}\\rightarrow{0}}\\frac{\\Delta{A_x}}{\\Delta{t}}\\mathbf{i}+\\lim_{\\Delta{t}\\rightarrow{0}}\\frac{\\Delta{A_y}}{\\Delta{t}}\\mathbf{j}+\\lim_{\\Delta{t}\\rightarrow{0}}\\frac{\\Delta{A_z}}{\\Delta{t}}\\mathbf{k}\\\\\n&amp;=\\frac{d{A_x}}{d{t}}\\mathbf{i}+\\frac{d{A_y}}{dt}\\mathbf{j}+\\frac{d{A_z}}{d{z}}\\mathbf{k}\n\\end{aligned}\n\\tag{1.4.7}\n\\]</div><p></p><p>即</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A^{\\prime}}(t)=A_x^{\\prime}(t)\\mathbf{i}+A_y^{\\prime}(t)\\mathbf{j}+A_z^{\\prime}\\mathbf{k} \\tag{1.4.8}\n\\]</div><p></p><p>此式把求矢量函数的导数归结为求三个分量的数性函数的导数。</p>\n<h3 id=\"142-矢性函数的导数几何意义\">1.4.2 矢性函数的导数几何意义</h3>\n<p>​        如图，<span class=\"math inline\">\\(l\\)</span>为<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>矢端曲线，<span class=\"math inline\">\\(\\frac{\\Delta\\mathbf{A}}{\\Delta{t}}\\)</span> 是在<span class=\"math inline\">\\(l\\)</span>的割线<span class=\"math inline\">\\(MN\\)</span>上的一个矢量。当<span class=\"math inline\">\\(\\Delta{t}&gt;0\\)</span>时，其指向与<span class=\"math inline\">\\(\\Delta{A}\\)</span>一致，系指向对应<span class=\"math inline\">\\(t\\)</span>值增大的一方；当<span class=\"math inline\">\\(\\Delta{t}&lt;0\\)</span>时，其指向与<span class=\"math inline\">\\(\\Delta{\\mathbf{A}}\\)</span> 相反，但此时<span class=\"math inline\">\\(\\Delta{A}\\)</span>指向对应<span class=\"math inline\">\\(t\\)</span>值函数减小的一方，从而<span class=\"math inline\">\\(\\frac{\\Delta\\mathbf{A}}{\\Delta{t}}\\)</span> 依然指向对应<span class=\"math inline\">\\(t\\)</span>值增大的一方。</p>\n<p>​       在<span class=\"math inline\">\\(\\Delta{t}\\rightarrow{0}\\)</span> 时，由于割线<span class=\"math inline\">\\(MN\\)</span>绕点<span class=\"math inline\">\\(M\\)</span>转动，且以点<span class=\"math inline\">\\(M\\)</span>处的切线为其极限位置。此时，在割线上的矢量<span class=\"math inline\">\\(\\Delta{\\mathbf{A}}\\over{\\Delta{t}}\\)</span>的极限位置。此时，在割线上的矢量<span class=\"math inline\">\\(\\Delta{\\mathbf{A}}\\over{\\Delta{t}}\\)</span> 的极限位置，自然也就在此切线上，则也就是说，导矢</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}^{\\prime}(t)=\\lim_{t\\rightarrow{0}}\\frac{\\Delta{\\mathbf{A}}}{\\Delta{t}} \\tag{1.4.9}\n\\]</div><p></p><p>当其不为零时，是在点<span class=\"math inline\">\\(M\\)</span>处的切线上，且由上述可知，其方向恒指向对应<span class=\"math inline\">\\(t\\)</span>值增大的方向。故导矢在几何上为一矢端曲线的切向矢量，指向对应<span class=\"math inline\">\\(t\\)</span>值增大的一方。</p>\n<h3 id=\"143-矢性函数的微分\">1.4.3 矢性函数的微分</h3>\n<p>（1）微分的概念与几何意义</p>\n<p>​        根据数性函数的微分的定义，设矢性函数<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{A^{\\prime}}(t)\\)</span>，我们把</p>\n<p></p><div class=\"math display\">\\[d\\mathbf{A}=\\mathbf{A^{\\prime}}(t)dt \\space  (dt=\\Delta{t}) \\tag{1.4.10}\n\\]</div><p></p><p>称为矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 在<span class=\"math inline\">\\(t\\)</span> 处的微分。</p>\n<p>​       由于微分<span class=\"math inline\">\\(d{\\mathbf{A}}\\)</span> 是导矢<span class=\"math inline\">\\(\\mathbf{A^{\\prime}}(t)\\)</span>与增量<span class=\"math inline\">\\(\\Delta{t}\\)</span> 的乘积，所以其是一个矢量，而且和导矢<span class=\"math inline\">\\(\\mathbf{A}^{\\prime}(t)\\)</span> 一样，也在点<span class=\"math inline\">\\(M\\)</span>处与<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 的矢端曲线<span class=\"math inline\">\\(l\\)</span> 相切，但其指向：当<span class=\"math inline\">\\(dt&gt;0\\)</span>时，与<span class=\"math inline\">\\(\\mathbf{A}^{\\prime}(t)\\)</span> 相切方向一致；而当<span class=\"math inline\">\\(dt&lt;0\\)</span>时，则与<span class=\"math inline\">\\(\\mathbf{A}^{\\prime}(t)\\)</span> 的方向相反。微分<span class=\"math inline\">\\(d{\\mathbf{A}}\\)</span> 的分量表达式如下：</p>\n<p></p><div class=\"math display\">\\[d{\\mathbf{A}}=A_x^{\\prime}(t)dt\\mathbf{i}+A_{y}^{\\prime}(t)dt\\mathbf{j}+A_z^{\\prime}(t)dt\\mathbf{k} \\tag{1.4.11}\n\\]</div><p></p><p>或</p>\n<p></p><div class=\"math display\">\\[d{\\mathbf{A}}=d{A_x}\\mathbf{i}+d{A_y}\\mathbf{j}+d{A_z}\\mathbf{k} \\tag{1.4.12}\n\\]</div><p></p><p>(2)   <span class=\"math inline\">\\(\\frac{d\\mathbf{r}}{ds}\\)</span> 的几何意义</p>\n<p>​       如果把矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)=A_x(t)\\mathbf{i}+A_y(t)\\mathbf{j}+A_z(t)\\mathbf{k}\\)</span> 看作其终点<span class=\"math inline\">\\(M(x,y,z)\\)</span> 的矢径函数：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{r}=x\\mathbf{i}+y\\mathbf{j}+z\\mathbf{k} \\tag{1.4.13}\n\\]</div><p></p><p>这里<span class=\"math inline\">\\(x=A_x(t),y=A_y(t),z=A_z(t)\\)</span>，则上式可以写为如下的形式：</p>\n<p></p><div class=\"math display\">\\[|d{\\mathbf{r}}|=\\sqrt{dx^2+dy^2+dz^2} \\tag{1.4.14}\n\\]</div><p></p><p>通常都将矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的矢端曲线<span class=\"math inline\">\\(l\\)</span>视为有向曲线，在无特别声明时，都是取<span class=\"math inline\">\\(t\\)</span> 值增加的一方为<span class=\"math inline\">\\(l\\)</span>之正向。若在<span class=\"math inline\">\\(l\\)</span>上取定一点<span class=\"math inline\">\\(M_0\\)</span> 作为计算弧长<span class=\"math inline\">\\(s\\)</span>的起点，并以<span class=\"math inline\">\\(l\\)</span>之正向（即<span class=\"math inline\">\\(t\\)</span>值增大的方向）作为<span class=\"math inline\">\\(s\\)</span>增大的方向，则在任一点<span class=\"math inline\">\\(M\\)</span>处，弧长的微分是</p>\n<p></p><div class=\"math display\">\\[ds=\\pm\\sqrt{dx^2+dy^2+dz^2} \\tag{1.4.15}\n\\]</div><p></p><p>按照下述办法取右端符号：以点<span class=\"math inline\">\\(M\\)</span>为界，当<span class=\"math inline\">\\(ds\\)</span>位于<span class=\"math inline\">\\(s\\)</span>增大一方时取正号；反之取负号。由此可见有：</p>\n<p></p><div class=\"math display\">\\[|d{\\mathbf{r}}|=|d{s}| \\tag{1.4.16}\n\\]</div><p></p><p>就是说，矢性函数的微分向量的模长等于（其矢端曲线的）弧长微分的绝对值，从而由</p>\n<p></p><div class=\"math display\">\\[|d{\\mathbf{r}}|=\\left|\\frac{d{\\mathbf{r}}}{ds}ds\\right|=\\left|\\frac{d{\\mathbf{r}}}{ds}\\right|\\cdot|ds| \\tag{1.4.17}\n\\]</div><p></p><p>有</p>\n<p></p><div class=\"math display\">\\[\\left|\\frac{d{\\mathbf{r}}}{ds}\\right|=\\frac{|d{\\mathbf{r}}|}{|ds|}=1 \\tag{1.4.18}\n\\]</div><p></p><p>结合导矢的几何意义，便知：矢<strong>性函数对（其矢端曲线的）弧长<span class=\"math inline\">\\(s\\)</span> 的导数<span class=\"math inline\">\\(\\frac{d{\\mathbf{r}}}{ds}\\)</span> 在几何上为切向单位向量，恒指向<span class=\"math inline\">\\(s\\)</span>增大的一方</strong>。</p>\n<p><strong>Equation 1.5.1</strong>  证明 <span class=\"math inline\">\\(\\frac{ds}{dt}=\\left|\\frac{d{\\mathbf{r}}}{dt}\\right|\\)</span></p>\n<p>证明：</p>\n<p></p><div class=\"math display\">\\[\\frac{d{\\mathbf{r}}}{dt}=\\frac{dx}{dt}\\mathbf{i}+\\frac{dy}{dt}\\mathbf{j}+\\frac{dz}{dt}\\mathbf{k} \\tag{1.4.19}\n\\]</div><p></p><p>由此可知，<span class=\"math inline\">\\(\\mathbf{r}\\)</span> 的矢性微分的模长：</p>\n<p></p><div class=\"math display\">\\[\\left|\\frac{d\\mathbf{r}}{dt}\\right|=\\sqrt{\\left(\\frac{dx}{dt}\\right)^2+\\left(\\frac{dy}{dt}\\right)^2+\\left(\\frac{dz}{dt}\\right)^2} \\tag{1.4.20}\n\\]</div><p></p><p>由此可知，<span class=\"math inline\">\\(ds\\)</span>与<span class=\"math inline\">\\(dt\\)</span> 具有相同的符号，固有</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n\\frac{ds}{dt}&amp;=\\frac{\\pm\\sqrt{dx^2+dy^2+dz^2}}{\\pm\\sqrt{dt^2}}  \\\\\n&amp;=\\sqrt{\\left(\\frac{dx}{dt}\\right)^2+\\left(\\frac{dy}{dt}\\right)^2+\\left(\\frac{dz}{dt}\\right)^2}\\\\\n&amp;=\\left|\\frac{d\\mathbf{r}}{dt}\\right|\n\\end{aligned}\n\\tag{1.4.21}\n\\]</div><p></p><p>由此可知：<strong>矢端曲线的切向单位矢量，即</strong></p>\n<p></p><div class=\"math display\">\\[\\frac{d{\\mathbf{r}}}{d{s}}=\\frac{\\frac{d\\mathbf{r}}{d{t}}}{\\frac{ds}{dt}}=\\frac{d\\mathbf{r}}{dt}\\bigg/\\left|\\frac{d{\\mathbf{r}}}{dt}\\right| \\tag{1.4.19}\n\\]</div><p></p><h3 id=\"144-矢性函数的导数性质\">1.4.4 矢性函数的导数性质</h3>\n<p>设矢性函数<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{A}(t),\\mathbf{B}=\\mathbf{B}(t)\\)</span> 及数性函数 <span class=\"math inline\">\\(u=u(t)\\)</span> 在<span class=\"math inline\">\\(t\\)</span> 的某个范围内可导，则下列公式在该范围内成立</p>\n<ol>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}{\\mathbf{C}}=\\mathbf{0}\\)</span> (<span class=\"math inline\">\\(\\mathbf{C}\\)</span>为常矢)；</li>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}(\\mathbf{A}\\pm\\mathbf{B})=\\frac{d{\\mathbf{A}}}{dt}\\pm\\frac{d\\mathbf{B}}{dt}\\)</span>;</li>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}(k\\mathbf{A})=k\\frac{d\\mathbf{A}}{dt}\\)</span>(<span class=\"math inline\">\\(k\\)</span>为常数);</li>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}(u\\mathbf{A})=\\frac{du}{dt}\\mathbf{A}+u\\frac{d{\\mathbf{A}}}{dt};\\)</span></li>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}(\\mathbf{A}\\cdot\\mathbf{B})=\\mathbf{A}\\cdot\\frac{d\\mathbf{B}}{dt}+\\mathbf{B}\\cdot\\frac{d\\mathbf{A}}{dt};\\)</span></li>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}(\\mathbf{A}\\times\\mathbf{B})=\\mathbf{A}\\times\\frac{d{\\mathbf{B}}}{dt}+\\mathbf{B}\\times\\frac{d{\\mathbf{A}}}{dt}\\)</span></li>\n<li><span class=\"math inline\">\\(\\frac{d}{dt}\\mathbf{A^2}=2\\mathbf{A}\\cdot\\frac{d{\\mathbf{A}}}{dt}\\)</span>(其中<span class=\"math inline\">\\(\\mathbf{A}^2=\\mathbf{A}\\cdot\\mathbf{A}\\)</span>)</li>\n<li>复合函数求导公式：若<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{A}(u),u=u(t)\\)</span>，则</li>\n</ol>\n<p></p><div class=\"math display\">\\[\\frac{d{\\mathbf{A}}}{dt}=\\frac{d{\\mathbf{A}}}{dt}\\frac{du}{dt} \\tag{1.4.20}\n\\]</div><p></p><p>这些公式的证明方法，与微积分学中数性函数的类似公式的证法：完全相同，比如公式（5）可以这样证明：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n\\Delta(\\mathbf{A}\\cdot\\mathbf{B})&amp;=(\\mathbf{A}+\\Delta{\\mathbf{A}})\\cdot(\\mathbf{B}+\\Delta{\\mathbf{B}})-\\mathbf{A}\\cdot\\mathbf{B} \\\\\n&amp;=\\mathbf{A}\\cdot\\mathbf{B}+\\mathbf{A}\\cdot(\\Delta\\mathbf{B})+\\mathbf{B}\\cdot(\\Delta{\\mathbf{A}})+\\Delta{\\mathbf{A}}\\cdot\\Delta{\\mathbf{B}}-\\mathbf{A}\\cdot\\mathbf{B}\\\\\n&amp;=\\mathbf{A}\\cdot{\\Delta{\\mathbf{B}}}+\\mathbf{B}\\cdot\\Delta\\mathbf{A}+\\Delta{\\mathbf{A}}\\cdot\\Delta{\\mathbf{B}}\n\\end{aligned}\n\\tag{1.4.21}\n\\]</div><p></p><p>以<span class=\"math inline\">\\(\\Delta{t}\\)</span> 除以两端，有</p>\n<p></p><div class=\"math display\">\\[\\frac{\\Delta{\\mathbf{A}\\cdot\\mathbf{B}}}{\\Delta{t}}=\\mathbf{A}\\cdot\\frac{\\Delta{\\mathbf{B}}}{\\Delta{t}}+\\mathbf{B}\\cdot\\frac{\\Delta{\\mathbf{A}}}{\\Delta{t}} \\tag{1.4.22}\n\\]</div><p></p><p>再令 <span class=\"math inline\">\\(\\Delta{t}\\rightarrow{0}\\)</span> 两端取极限，就得到：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n\\frac{d}{dt}(\\mathbf{A}\\cdot\\mathbf{B})&amp;=\\mathbf{A}\\cdot\\frac{d{\\mathbf{B}}}{dt}+\\mathbf{B}\\frac{d{\\mathbf{A}}}{dt}+\\mathbf{0}\\cdot\\frac{d{\\mathbf{B}}}{dt}\\\\\n&amp;=\\mathbf{A}\\cdot\\frac{d{\\mathbf{B}}}{dt}+\\mathbf{B}\\frac{d{\\mathbf{A}}}{dt}\n\\end{aligned}\\tag{1.4.23}\n\\]</div><p></p><p><strong>定理</strong>  矢性函数<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 的模不变的充要条件是</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}\\cdot\\frac{d\\mathbf{A}}{dt}=0 \\tag{1.4.24}\n\\]</div><p></p><p><strong>证明：</strong> 假定 <span class=\"math inline\">\\(|\\mathbf{A}|=constant\\)</span>, 则有</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}^2=|\\mathbf{A}|^2=constant \\tag{1.4.25}\n\\]</div><p></p><p>两端对<span class=\"math inline\">\\(t\\)</span> 求导，就得到</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}\\cdot\\frac{d{\\mathbf{A}}}{dt}=0 \\tag{1.4.26}\n\\]</div><p></p><p>反之，若有 <span class=\"math inline\">\\(\\mathbf{A}\\cdot\\frac{d\\mathbf{A}}{dt}=0\\)</span>, 从而</p>\n<p></p><div class=\"math display\">\\[\\frac{d}{dt}\\mathbf{A}^2=0 \\tag{1.4.27}\n\\]</div><p></p><p>则有，</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}^2=|\\mathbf{A}|^2=constant \\tag{1.4.28}\n\\]</div><p></p><p>所以要有</p>\n<p></p><div class=\"math display\">\\[|\\mathbf{A}|= constant \\tag{1.4.29}\n\\]</div><p></p><p>这个例子，可以简单地说成：定长矢量<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 与其导矢量互相垂直。特别，对于单位矢量$$</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}^{o}\\perp \\frac{d{\\mathbf{A}^{o}}}{dt} \\tag{1.4.30}\n\\]</div><p></p><h3 id=\"145--导矢的物理意义\">1.4.5  导矢的物理意义</h3>\n<p>​        设质点<span class=\"math inline\">\\(M\\)</span>在空间运动，其矢径<span class=\"math inline\">\\(\\mathbf{r}\\)</span> 与时间<span class=\"math inline\">\\(t\\)</span>的函数关系为</p>\n<p></p><div class=\"math display\">\\[\\mathbf{r}=\\mathbf{r}(t) \\tag{1.4.31}\n\\]</div><p></p><p>这个函数的矢端曲线<span class=\"math inline\">\\(l\\)</span>就是质点<span class=\"math inline\">\\(M\\)</span>的运动轨迹。</p>\n<p>​        为了说明导矢<span class=\"math inline\">\\(\\frac{d{\\mathbf{r}}}{dt}\\)</span> 的物理意义，假定质点在时刻 <span class=\"math inline\">\\(t=0\\)</span>时位于点<span class=\"math inline\">\\(M_0\\)</span>处，经过一段时间<span class=\"math inline\">\\(t\\)</span> 以后到达点<span class=\"math inline\">\\(M\\)</span>,其间在<span class=\"math inline\">\\(l\\)</span>上所经过的路程为<span class=\"math inline\">\\(s\\)</span>。这样，点<span class=\"math inline\">\\(M\\)</span>的矢径<span class=\"math inline\">\\(\\mathbf{r}\\)</span> 显然是路程<span class=\"math inline\">\\(s\\)</span> 的函数，而<span class=\"math inline\">\\(s\\)</span> 又是时间<span class=\"math inline\">\\(t\\)</span> 的函数，从而可以将<span class=\"math inline\">\\(\\mathbf{r}=\\mathbf{r}(t)\\)</span> 看作<span class=\"math inline\">\\(\\mathbf{r}\\)</span> 是通过中间变量<span class=\"math inline\">\\(s\\)</span>而成为时间<span class=\"math inline\">\\(t\\)</span>的一个复合函数，于是由复合函数的求导公式有；</p>\n<p></p><div class=\"math display\">\\[\\frac{d{\\mathbf{r}}}{dt}=\\frac{d{\\mathbf{r}}}{ds}\\cdot\\frac{ds}{dt} \\tag{1.4.32}\n\\]</div><p></p><p>矢中<span class=\"math inline\">\\(\\frac{d{\\mathbf{r}}}{ds}\\)</span>的几何意义，如前段所示，是在点<span class=\"math inline\">\\(M\\)</span>处的一个切向单位向量，指向<span class=\"math inline\">\\(s\\)</span>增大的方向，因此，它表示在点<span class=\"math inline\">\\(M\\)</span>处质点运动的方向，现在以<span class=\"math inline\">\\(\\boldsymbol{\\tau}\\)</span> 表示之；而式中的$$</p>\n<p></p><div class=\"math display\">\\[\\frac{d{\\mathbf{r}}}{dt}=v\\boldsymbol{\\tau} \\tag{1.4.33}\n\\]</div><p></p><p>由此可见，导矢<span class=\"math inline\">\\(\\frac{d\\mathbf{r}}{dt}\\)</span> 表示出了质点<span class=\"math inline\">\\(M\\)</span>运动的速度大小和方向，因而它就是质点<span class=\"math inline\">\\(M\\)</span>运动的速度矢量<span class=\"math inline\">\\(\\boldsymbol{v}\\)</span>  ,即</p>\n<p></p><div class=\"math display\">\\[\\boldsymbol{v}=\\frac{d\\mathbf{r}}{dt} \\tag{1.4.33}\n\\]</div><p></p><p>若定义二阶导矢<span class=\"math inline\">\\(\\mathbf{w}\\)</span></p>\n<p></p><div class=\"math display\">\\[\\mathbf{w}=\\frac{d^2\\mathbf{r}}{dt^2}=\\frac{d}{dt}\\left(\\frac{d{\\mathbf{r}}}{dt}\\right) \\tag{1.4.34}\n\\]</div><p></p><p>则<span class=\"math inline\">\\(\\mathbf{w}\\)</span>为质点<span class=\"math inline\">\\(\\mathbf{M}\\)</span>运动的加速度矢量。</p>\n<p>​</p>\n<h2 id=\"15-矢性函数的积分\">1.5 矢性函数的积分</h2>\n<p>​         矢性函数的积分和数性函数的积分类似，也有不定积分和定积分两种，现在分述于下：</p>\n<h3 id=\"151--矢性函数的不定积分\">1.5.1  矢性函数的不定积分</h3>\n<p>​         <strong>定义</strong> 若在<span class=\"math inline\">\\(t\\)</span>的某个区间<span class=\"math inline\">\\(I\\)</span>上，有 <span class=\"math inline\">\\(\\mathbf{B^{'}}(t)=\\mathbf{A}(t)\\)</span>，则称<span class=\"math inline\">\\(\\mathbf{B}(t)\\)</span>为<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在区间上的一个<strong>原函数</strong>。在区间<span class=\"math inline\">\\(I\\)</span>上，<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的原函数全体，加做<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>的原函数的全体，叫做<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在<span class=\"math inline\">\\(I\\)</span>上的不定积分，记作</p>\n<p></p><div class=\"math display\">\\[\\int{\\mathbf{A}(t)}dt \\tag{1.5.1}\n\\]</div><p></p><p>这个定义和数性函数的不定积分定义完全类似。故和数性函数一样，若已知<span class=\"math inline\">\\(\\mathbf{B}(t)\\)</span>和是<span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span> 的一个原函数，则有</p>\n<p></p><div class=\"math display\">\\[\\int{\\mathbf{A}(t)}dt=\\mathbf{B}(t)+\\mathbf{C} \\tag{1.5.2}\n\\]</div><p></p><p>而且，数性函数不定积分的基本性质对矢性函数来说也仍然成立。例如：</p>\n<p></p><div class=\"math display\">\\[\\begin{equation}\n\\int k\\mathbf{A}(t)dt=k\\int\\mathbf{A}(t)dt \\tag{1.5.3}\n\\end{equation}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\begin{equation}\n\\int [\\mathbf{A}(t)+\\mathbf{B}(t)]dt=\\int\\mathbf{A}(t)dt+\\int\\mathbf{B}(t)dt \\tag{1.5.4}\n\\end{equation}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\begin{equation}\n\\int u(t)\\mathbf{a}dt=\\mathbf{a}\\int u(t)dt \\tag{1.5.5}\n\\end{equation}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\int\\mathbf{a}\\cdot\\mathbf{A}(t)dt=\\mathbf{a}\\cdot\\int \\mathbf{A}(t)dt \\tag{1.5.6}\n\\]</div><p></p><p></p><div class=\"math display\">\\[\\int \\mathbf{a}\\times\\mathbf{A}(t)dt=\\mathbf{a}\\times\\int\\mathbf{A}(t)dt \\tag{1.5.7}\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(k\\)</span>为非零常数，<span class=\"math inline\">\\(\\mathbf{a}\\)</span> 为非零常矢量。</p>\n<p>​       据此，若已知矢性函数的分量表达式<span class=\"math inline\">\\(\\mathbf{A}(t)=A_x(t)\\boldsymbol{i}+A_y(t)\\boldsymbol{j}+A_z(t)\\boldsymbol{k}\\)</span> ,根据式(1.6.3)和式(1.6.4)可知：</p>\n<p></p><div class=\"math display\">\\[\\int\\mathbf{A}(t)dt=\\boldsymbol{i}\\int{A_x(t)}dt+\\boldsymbol{j}\\int{A_y(t)}dt+\\boldsymbol{k}\\int{A_z(t)}dt \\tag{1.5.8}\n\\]</div><p></p><p>此式把求一个矢性函数的不定积分，归纳为求一个三个数性函数的不定积分。</p>\n<p>​      此外，数性函数的换元积分法与分部积分法亦适用于矢性函数。但由于两个矢量的矢量积服从于负交换律，即<span class=\"math inline\">\\(\\mathbf{A}\\times\\mathbf{B}=-(\\mathbf{B}\\times\\mathbf{A})\\)</span>, 故其分部积分公式的应用端应为两项相加：</p>\n<p></p><div class=\"math display\">\\[\\int\\mathbf{A}\\times\\mathbf{B}^{\\prime}dt=\\mathbf{A}\\times \\mathbf{B}+\\int \\mathbf{B}\\times\\mathbf{A}^{\\prime}dt \\tag{1.5.9}\n\\]</div><p></p><h3 id=\"152--矢性函数的定积分\">1.5.2  矢性函数的定积分</h3>\n<p><strong>定义</strong>   设矢性函数 <span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在区间<span class=\"math inline\">\\([T_1,T_2]\\)</span> 上连续，则 <span class=\"math inline\">\\(\\mathbf{A}(t)\\)</span>在<span class=\"math inline\">\\([T_1,T_2]\\)</span> 上的定积分是指下面形式的极限：</p>\n<p></p><div class=\"math display\">\\[\\int_{T_1}^{T_2}\\mathbf{A}(t)dt=\\lim_{\\lambda\\rightarrow{0}}\\sum_{i=1}^{n}\\mathbf{A}(\\xi_{i})\\Delta{t_i} \\tag{1.5.10}\n\\]</div><p></p><p>其中 <span class=\"math inline\">\\(T_1=t_0&lt;t_1&lt;t_2&lt;...&lt;t_n=T_2\\)</span>；<span class=\"math inline\">\\(\\xi_i\\)</span>为区间<span class=\"math inline\">\\([t_{i-1},t_i]\\)</span>上的一点；<span class=\"math inline\">\\(\\Delta{t_i}=t_i-t_{i-1}\\)</span>; <span class=\"math inline\">\\(\\lambda=max{\\Delta{t_i}}\\)</span>,<span class=\"math inline\">\\(i=1,2,3,...,n\\)</span>。</p>\n<p>​       可以看出，矢性函数的定积分概念也和数性函数的定积分完全类似。因此，也具有和数性函数的定积分相应的基本性质，例如：</p>\n<p></p><div class=\"math display\">\\[\\int_{T_1}^{T_2}\\mathbf{A}(t)dt=\\mathbf{B}(T_2)-\\mathbf{B}(T_1) \\tag{1.5.11}\n\\]</div><p></p><p>其他性质就不一一列举了。</p>\n<p>​       此外，类似于（1.6.11）式，求矢性函数的定积分也可以归纳于求三个数性函数的定积分，既有：</p>\n<p></p><div class=\"math display\">\\[\\int_{T_1}^{T_2}\\mathbf{A}(t)dt=\\boldsymbol{i}\\int_{T_1}^{T_2}A_x(t)dt+\\boldsymbol{j}\\int_{T_1}^{T_2}A_y(t)dt+\\boldsymbol{k}\\int_{T_1}^{T_2}A_z(t)dt \\tag{1.5.12}\n\\]</div><p></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 11:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">23</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Zod：TypeScript 类型守卫与数据验证",
      "link": "https://www.cnblogs.com/guangzan/p/19350726",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/guangzan/p/19350726\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 10:32\">\n    <span>Zod：TypeScript 类型守卫与数据验证</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>我见过许多因为运行时数据不匹配而导致的崩溃，也曾写过无数防御性代码和 <code>any</code> 断言，哈哈 😄。TypeScript 的类型安全本来就不该止步于编译期。直到遇见 Zod，Zod 不仅是一个验证库，它为 TypeScript 带来运行时安全，是目前最优雅、最彻底的解决方案。</p>\n<h2 id=\"我们为何需要-zod\">我们为何需要 Zod？</h2>\n<p>TypeScript 最让人上瘾的地方在于编译时类型检查，但这也是它的最大谎言，因为类型在运行时彻底消失，你需要小心小心再小心，使用 TypeScript 并不代表类型安全。</p>\n<pre><code class=\"language-ts\">interface User {\n  name: string;\n  age: number;\n  role: 'admin' | 'user';\n}\n\nfetch('/api/user').then(res =&gt; res.json()).then((data: User) =&gt; {\n  // 编译通过，但如果 data.role 返回的是 \"administrator\"，运行会报错\n  console.log(data.role.toUpperCase());\n});\n</code></pre>\n<p>而 Zod 的答案是：只定义一次 Schema，既得到运行时验证，又得到完美的 TypeScript 类型。</p>\n<pre><code class=\"language-ts\">const UserSchema = z.object({\n  name: z.string(),\n  age: z.number(),\n  role: z.enum(['admin', 'user']),\n});\n\ntype User = z.infer&lt;typeof UserSchema&gt;;\n</code></pre>\n<p>通过 Schema 推断出完美类型 User，无需二次声明。这样， UserSchema 用于运行时验证，User 用于类型推断。</p>\n<h2 id=\"zod-入门\">Zod 入门</h2>\n<pre><code class=\"language-bash\">npm install zod\n</code></pre>\n<pre><code class=\"language-ts\">import { z } from 'zod';\n\n// 基础类型\nconst StringSchema = z.string();\nconst NumberSchema = z.number().int().positive();\n</code></pre>\n<p>核心 API：parse 和 safeParse，我建议优先使用 <code>.safeParse()</code>。</p>\n<pre><code class=\"language-ts\">const schema = z.string();\n\ntry {\n  const result = schema.parse(123);\n  console.log(result);\n} catch (error) {\n  console.error('验证失败:', error.errors);\n}\n</code></pre>\n<p>parse 抛出 ZodError, 你需要通过 <code>try catch</code> 捕获错误，否则导致程序崩溃。</p>\n<pre><code class=\"language-ts\">const schema = z.string();\nconst result = schema.safeParse(123);\n\nif (result.success) {\n  console.log('验证成功:', result.data);\n} else {\n  console.log('验证失败:', result.error.errors);\n}\n</code></pre>\n<p>safeParse 返回 <code>{ success: true, data: T }</code> 或 <code>{ success: false, error: ZodError }</code>，你可以通过 success 判断是否验证成功，然后通过 data 获取验证后的数据，或者通过 <code>error.errors</code> 获取错误信息, 这样你可以优雅地处理错误。</p>\n<h2 id=\"构建复杂数据模型\">构建复杂数据模型</h2>\n<pre><code class=\"language-ts\">const AddressSchema = z.object({\n  street: z.string(),\n  city: z.string(),\n  zipCode: z.string().regex(/^\\d{5}$/),\n});\n\nconst UserSchema = z.object({\n  id: z.string().uuid(),\n  name: z.string().min(2).max(50),\n  email: z.string().email(),\n  age: z.number().int().min(13).max(120),\n  address: AddressSchema.optional(), // 可选嵌套对象\n  tags: z.array(z.string()).default([]), // 默认值\n  role: z.enum(['admin', 'user', 'moderator']),\n  status: z.enum(['active', 'inactive']).default('active'),\n});\n</code></pre>\n<p>组合技巧，这些是我最常用的：</p>\n<p><code>.extend()</code> 是 Zod 最被低估的特性之一。它让你能以面向对象的方式构建 Schema 体系，比 interface 继承更安全，因为运行时验证也会继承。</p>\n<pre><code class=\"language-ts\">// 扩展\nconst AdminSchema = UserSchema.extend({\n  permissions: z.array(z.string()),\n});\n</code></pre>\n<p>比较常见的是，实现查询接口的分页查询 Schema，分页查询 Schema 包含 page 和 pageSize 字段，自其他 Schema 可以继承分页查询 Schema 并添加其他字段。</p>\n<pre><code class=\"language-ts\">const PageSchema = z.object({\n  page: z.number().min(1).default(1),\n  pageSize: z.number().min(1).max(100).default(10),\n});\n\nconst UserPageSchema = PageSchema.extend({\n  name: z.string().min(2).max(50),\n});\n\ntype UserPage = z.infer&lt;typeof UserPageSchema&gt;;\n</code></pre>\n<p>合并, 优先级后者覆盖前者。</p>\n<pre><code class=\"language-ts\">const MergedSchema = UserSchema.merge(z.object({\n  role: z.literal('admin'), // 强制覆盖\n}));\n</code></pre>\n<p>交集。</p>\n<pre><code class=\"language-ts\">const IntersectionSchema = z.intersection(UserSchema, z.object({\n  isVerified: z.boolean(),\n}));\n</code></pre>\n<h2 id=\"进阶模式与精细校验\">进阶模式与精细校验</h2>\n<p>可辨识联合（Discriminated Union），比如我们用它来处理 Redux Action。</p>\n<blockquote>\n<p>可辨识联合（Discriminated Union），也称为标签联合（Tagged Union）或代数数据类型（Algebraic Data Type），是一种高级类型系统特性，用于表示可能是多种不同类型之一的值。</p>\n</blockquote>\n<pre><code class=\"language-ts\">const ActionSchema = z.discriminatedUnion('type', [\n  z.object({ type: z.literal('INCREMENT'), payload: z.number() }),\n  z.object({ type: z.literal('DECREMENT'), payload: z.number() }),\n  z.object({ type: z.literal('SET_USER'), payload: UserSchema }),\n]);\n\ntype Action = z.infer&lt;typeof ActionSchema&gt;;\n</code></pre>\n<p><code>z.discriminatedUnion</code> 比手动写 <code>.or()</code> 更清晰，TypeScript 窄化（narrowing）也更完美。</p>\n<p>字符串高级校验</p>\n<pre><code class=\"language-ts\">z.string()\n  .min(8, '至少8位')\n  .regex(/[A-Z]/, '必须含大写字母')\n  .regex(/[a-z]/, '必须含小写字母')\n  .regex(/[0-9]/, '必须含数字')\n  .regex(/[^A-Za-z0-9]/, '必须含特殊字符');\n</code></pre>\n<p>通过 Transform 验证后自动转换，这太棒了，比如写 restful 接口时，我们希望 Query id 是 number 类型，但是传入 string 类型，我们可以借助 Transform 自动转换为 number 类型。</p>\n<pre><code class=\"language-ts\">const IdSchema = z.string().transform(str =&gt; parseInt(str));\n</code></pre>\n<h2 id=\"推断-typescript-类型\">推断 TypeScript 类型</h2>\n<p>修改 Schema，类型自动更新，无需手动更新类型，完美同步。</p>\n<pre><code class=\"language-ts\">type User = z.infer&lt;typeof UserSchema&gt;;\n</code></pre>\n<p>与 TypeScript 原生 enum 互操作。</p>\n<pre><code class=\"language-ts\">enum Role {\n  Admin = 'admin',\n  User = 'user',\n}\n\nconst RoleSchema = z.nativeEnum(Role);\n</code></pre>\n<h2 id=\"常见应用场景\">常见应用场景</h2>\n<h3 id=\"api-响应验证\">API 响应验证</h3>\n<pre><code class=\"language-ts\">async function apiFetch&lt;T extends z.ZodType&gt;(\n  url: string,\n  schema: T\n): Promise&lt;z.infer&lt;T&gt;&gt; {\n  const res = await fetch(url);\n  const data = await res.json();\n  \n  const result = schema.safeParse(data);\n  if (!result.success) {\n    throw new Error(`API验证失败: ${result.error.message}`);\n  }\n\n  return result.data;\n}\n\n// 使用\nconst user = await apiFetch('/api/user', UserSchema);\n</code></pre>\n<h3 id=\"表单验证\">表单验证</h3>\n<p>与 React-Hook-Form 完美结合，类型安全 + 错误信息自动同步。AI 非常喜欢这套方案，AI 生成的代码非常不容易出错。</p>\n<pre><code class=\"language-ts\">const formSchema = z.object({\n  email: z.string().email('邮箱格式错误'),\n  password: z.string().min(8, '密码至少8位'),\n  confirm: z.string(),\n}).refine(data =&gt; data.password === data.confirm, {\n  message: \"两次密码不一致\",\n  path: [\"confirm\"],\n});\n\ntype FormData = z.infer&lt;typeof formSchema&gt;;\n\nconst { register, handleSubmit, formState: { errors } } = useForm&lt;FormData&gt;({\n  resolver: zodResolver(formSchema),\n});\n</code></pre>\n<p>但是，我们最常用的 antd 的 Form 组件，与 Zod 结合并不完美 <a href=\"https://github.com/ant-design/ant-design/issues/40580\" rel=\"noopener nofollow\" target=\"_blank\">#40580</a>。表单一旦复杂，字段之间的关联性就更多了，如果都在 jsx 中处理，代码的可读性、可维护性就大大降低，如果把字段的定义以及验证单独提取出来，形成业务实体对应的实体逻辑，无疑更好。</p>\n<p>社区有人为此实现了一个 <a href=\"https://github.com/MrBr/antd-zod\" rel=\"noopener nofollow\" target=\"_blank\">antd-zod</a> 库，是目前我比较推荐的方案。</p>\n<pre><code class=\"language-tsx\">import { createSchemaFieldRule } from 'antd-zod';\n\nconst CustomFormValidationSchema = z.object({\n  fieldString: z.string(),\n  fieldNumber: z.number(),\n});\n\nconst rule = createSchemaFieldRule(CustomFormValidationSchema);\n\nexport function SimpleForm() {\n  return (\n    &lt;Form&gt;\n      &lt;Form.Item label=\"String field\" name=\"fieldString\" rules={[rule]}&gt;\n        &lt;Input/&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item label=\"Number field\" name=\"fieldNumber\" rules={[rule]}&gt;\n        &lt;InputNumber/&gt;\n      &lt;/Form.Item&gt;\n      &lt;Button htmlType=\"submit\"&gt;Submit&lt;/Button&gt;\n    &lt;/Form&gt;\n  );\n};\n</code></pre>\n<h3 id=\"环境变量验证\">环境变量验证</h3>\n<pre><code class=\"language-ts\">const envSchema = z.object({\n  DATABASE_URL: z.string().url(),\n  NODE_ENV: z.enum(['development', 'production', 'test']),\n  JWT_SECRET: z.string().min(32),\n});\n\ntype Env = z.infer&lt;typeof envSchema&gt;;\n\nexport const env = envSchema.parse(process.env);\n</code></pre>\n<p>对于环境变量校验我推荐你使用 <a href=\"https://github.com/t3-oss/t3-env\" rel=\"noopener nofollow\" target=\"_blank\">t3-env</a>,使用无效的环境变量部署应用程序是一件麻烦事。这个包可以帮助你避免这种情况。它支持使用任何  Standard Schema 兼容验证器，当然包括 Zod。</p>\n<p>定义环境变量：</p>\n<pre><code class=\"language-ts\">// src/env.mjs\nimport { createEnv } from \"@t3-oss/env-nextjs\"; // or core package\nimport { z } from \"zod\";\n\nexport const env = createEnv({\n  /*\n   * Serverside Environment variables, not available on the client.\n   * Will throw if you access these variables on the client.\n   */\n  server: {\n    DATABASE_URL: z.string().url(),\n    OPEN_AI_API_KEY: z.string().min(1),\n  },\n  /*\n   * Environment variables available on the client (and server).\n   *\n   * 💡 You'll get type errors if these are not prefixed with NEXT_PUBLIC_.\n   */\n  client: {\n    NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: z.string().min(1),\n  },\n  /*\n   * Due to how Next.js bundles environment variables on Edge and Client,\n   * we need to manually destructure them to make sure all are included in bundle.\n   *\n   * 💡 You'll get type errors if not all variables from `server` &amp; `client` are included here.\n   */\n  runtimeEnv: {\n    DATABASE_URL: process.env.DATABASE_URL,\n    OPEN_AI_API_KEY: process.env.OPEN_AI_API_KEY,\n    NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY:\n      process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY,\n  },\n});\n</code></pre>\n<p>使用时具有自动完成和类型推断功能</p>\n<pre><code class=\"language-ts\">import { env } from \"../env.mjs\";\n\nexport const GET = (req: Request) =&gt; {\n  const DATABASE_URL = env.DATABASE_URL;\n  // use it...\n};\n</code></pre>\n<p><img alt=\"image\" height=\"276\" src=\"https://img2024.cnblogs.com/blog/1501373/202512/1501373-20251215092951646-947278288.png\" width=\"913\" /></p>\n<h3 id=\"服务端应用trpc-示例\">服务端应用：tRPC 示例</h3>\n<p>tRPC 是一个端到端类型安全的服务端框架。tRPC 的核心魔力就在于 Zod。输入验证、类型推断、自动生成客户端类型，全程零配置。</p>\n<p>服务端实现文章发布接口，使用 Zod 验证输入</p>\n<p><img alt=\"image\" height=\"471\" src=\"https://img2024.cnblogs.com/blog/1501373/202601/1501373-20260104094555995-1536803202.png\" width=\"754\" /></p>\n<p>前端类型推断</p>\n<p><img alt=\"image\" height=\"204\" src=\"https://img2024.cnblogs.com/blog/1501373/202601/1501373-20260104095551745-800796286.png\" width=\"664\" /></p>\n<p>端到端类型安全对于 AI 自动补全和提升生成代码质量也是非常有帮助的</p>\n<p><img alt=\"image\" height=\"209\" src=\"https://img2024.cnblogs.com/blog/1501373/202601/1501373-20260104095742062-1513470318.png\" width=\"589\" /></p>\n<h3 id=\"ai-生成结构化数据\">AI 生成结构化数据</h3>\n<p>许多语言模型都能够生成结构化数据，通常定义为使用“JSON modes”或“tools”。然而，您需要手动提供模式，然后验证生成的数据，因为 LLM 可能会产生错误或不完整的结构化数据。</p>\n<p>Vercel AI SDK 通过在 <a href=\"https://ai-sdk.dev/docs/reference/ai-sdk-core/generate-text\" rel=\"noopener nofollow\" target=\"_blank\"><code>generateText</code></a> 上使用 <code>output</code> 属性，标准化了模型提供商之间的结构化对象生成。 和 <a href=\"https://ai-sdk.dev/docs/reference/ai-sdk-core/stream-text\" rel=\"noopener nofollow\" target=\"_blank\"><code>streamText</code></a>。您可以使用 <a href=\"https://ai-sdk.dev/docs/reference/ai-sdk-core/zod-schema\" rel=\"noopener nofollow\" target=\"_blank\">Zod schemas</a>，<a href=\"https://ai-sdk.dev/docs/reference/ai-sdk-core/valibot-schema\" rel=\"noopener nofollow\" target=\"_blank\">Valibot</a> 或 <a href=\"https://ai-sdk.dev/docs/reference/ai-sdk-core/json-schema\" rel=\"noopener nofollow\" target=\"_blank\">JSON schemas</a> 来指定您想要的数据结构，AI 模型将生成符合该结构的数据。</p>\n<p>使用 <code>generateText</code> 和 <code>Output.object()</code> 从提示中生成结构化数据。该模式还用于验证生成的数据，确保类型安全和正确性。</p>\n<pre><code class=\"language-ts\">import { generateText, Output } from 'ai';\nimport { deepseek } from \"@ai-sdk/deepseek\";\nimport { z } from 'zod';\n\nconst { output } = await generateText({\n  model: deepseek(\"deepseek-v3.1\"),\n  output: Output.object({\n    schema: z.object({\n      recipe: z.object({\n        name: z.string(),\n        ingredients: z.array(\n          z.object({ name: z.string(), amount: z.string() }),\n        ),\n        steps: z.array(z.string()),\n      }),\n    }),\n  }),\n  prompt: '生成一份扬州炒饭食谱',\n});\n</code></pre>\n<p><img alt=\"image\" height=\"366\" src=\"https://img2024.cnblogs.com/blog/1501373/202601/1501373-20260104102825415-1010215762.png\" width=\"860\" /></p>\n<h2 id=\"与其他验证库对比\">与其他验证库对比</h2>\n<table>\n<thead>\n<tr>\n<th>库</th>\n<th>TypeScript 支持</th>\n<th>类型推断</th>\n<th>体积</th>\n<th>学习成本</th>\n<th>生态</th>\n<th>推荐场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Zod</td>\n<td>原生一流</td>\n<td>完美</td>\n<td>~6KB</td>\n<td>低</td>\n<td>极强</td>\n<td>所有 TS 项目（强烈推荐）</td>\n</tr>\n<tr>\n<td>Yup</td>\n<td>需 cast</td>\n<td>差</td>\n<td>~20KB</td>\n<td>中</td>\n<td>强</td>\n<td>老项目、JS 项目</td>\n</tr>\n<tr>\n<td>Joi</td>\n<td>差</td>\n<td>无</td>\n<td>大</td>\n<td>中</td>\n<td>强</td>\n<td>Node.js 后端</td>\n</tr>\n<tr>\n<td>io-ts</td>\n<td>好（FP 风格）</td>\n<td>好</td>\n<td>中</td>\n<td>高</td>\n<td>弱</td>\n<td>喜欢函数式编程的团队</td>\n</tr>\n<tr>\n<td>AJV</td>\n<td>差</td>\n<td>无</td>\n<td>小（快）</td>\n<td>中</td>\n<td>强</td>\n<td>纯 JSON 验证场景</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"总结\">总结</h2>\n<p>这才是 TypeScript 应该有的样子。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 10:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/guangzan\">guangzan</a>&nbsp;\n阅读(<span id=\"post_view_count\">66</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}