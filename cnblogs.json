{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "语言开发随笔2",
      "link": "https://www.cnblogs.com/xuld/p/19495478",
      "published": "",
      "description": "<div class=\"posthead\">\n\t\t\t<h2>\n\t\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xuld/p/19495478\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 12:13\">\n    <span>语言开发随笔2</span>\n    \n\n</a>\n\n\t\t\t</h2>\n \t\t\tPosted on \n<span id=\"post-date\">2026-02-02 12:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xuld\">xuld</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\t\t\t\n\t\t</div>\n\t\t<div class=\"postbody\"><div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>自 2023 年重新开发语言到现在，已经有三年了。</p>\n<p>目前项目还在开发中，离发布还有一段时间。不过好的一点是，很多问题已经想明白了，对这个项目的未来也愈来愈清晰了。</p>\n<h2 id=\"为什么要开发新语言\">为什么要开发新语言</h2>\n<p>不同的人对编程这件事的态度不一样。</p>\n<p>对多数人来说，编程只是一份工作。代码嘛，怎么写都行，能跑就好。<br />\n但我不这么认为，我觉得，优秀的产品背后应该有一份优雅的代码，是一种艺术作品，具有美感。</p>\n<p>能够<strong>稳定地</strong>、<strong>高效地</strong>、<strong>优雅地</strong>完成业务项目，是我一直追求的目标。<br />\n如果代码不能按直觉预期正确地执行，我认为是不稳定的。<br />\n如果常见的需求，也需要写很多代码、花大量时间来实现，我认为是低效的。<br />\n如果本来一行代码就能搞定的功能，却需要写十多行，我认为是不优雅的。</p>\n<p>现有的编程语言总有一些地方让我觉得很不满。<br />\n这种不满不是因为个人习惯或喜好问题，而是它真正影响了项目开发效率。<br />\n为了我追求的目标，我决定打造自己的“干活工具”——刚好我还有这个精力。</p>\n<h2 id=\"我为什么不喜欢-java\">我为什么不喜欢 Java</h2>\n<p>Java 总是给人一种“把简单问题复杂化”的感觉。</p>\n<p>同样的需求，用 Java 需要的工作量总是比其他语言要多地多。</p>\n<p>以读取文件为例，在多数语言的系统库都提供了现成的函数可以直接读取。</p>\n<p>但在 Java 里，你需要先学习“Stream”的概念，然后需要学习“StreamReader”的概念，然后再学习“BufferedReader”，最后，你才可以实现真正的文件读取的功能。</p>\n<p>虽然很多 Javaer 美其名曰“高性能文件读取就是这样的”，但业务中真的需要这么时刻在乎性能吗？而且用 Java 写的程序，好像总体性能都不如用 Go 写的程序吧？</p>\n<p>Java 最新版似乎有点改进了，<code>Files.readString(Path.of(\"test.txt\"))</code> 一行也能搞定。但 <code>Path.of</code> 又是什么鬼？总之吧，不逼你先学习下“Path”这个概念，就不是 Java 了。</p>\n<p>对我来说，用 Java 开发就像开拖拉机一样慢（当然，也不是不能开）。</p>\n<h2 id=\"我为什么不喜欢-kotlin\">我为什么不喜欢 Kotlin</h2>\n<p>Kotlin 比 Java 确实好太多了，但同样热衷于发明新概念。<br />\n我认为这些新概念仅仅是简化了 Java 的语法，但没有本质区别——相当于大家不用学“拖拉机”了，但还是需要学“手动挡”——概念的复杂度并没有降低。<br />\n而且 Kotlin 离不开 Java 生态，一个没学过 Java 的人，我觉得他也很难用 Kotlin 干活。</p>\n<p>比如 <code>companion object</code>，本质就是静态方法、静态类、命名空间的另一种写法而已。<br />\n其他语言不需要类似概念，因为他们要不选择直接使用静态方法，要不选择彻底删除静态方法。</p>\n<h2 id=\"我为什么不喜欢-rust\">我为什么不喜欢 Rust</h2>\n<p>Rust 号称很先进。<br />\n但我不喜欢需要手动管理内存，因为这会增加工作量。<br />\n虽然手动管理的性能更好，但实际业务中，我也不需要为了追求极致性能而牺牲开发效率。</p>\n<h2 id=\"我为什么不喜欢-go\">我为什么不喜欢 Go</h2>\n<p>相比其他语言，Go 的简单和性能，使它成为我目前开发后端的首选语言。</p>\n<p>但 Go 的语法实在是太简陋，仿佛回到了 C 时代。</p>\n<p>特别是业务中常用的 <code>a ? b : c</code> 和 <code>a?.fn()</code>，使得实际代码量增加不少。</p>\n<h2 id=\"我为什么不喜欢-c\">我为什么不喜欢 C#</h2>\n<p>在 Go 之前，我倾向于用 C# 开发后端。<br />\n但相比 Go，C# 就显得过于复杂了。</p>\n<p>C# 的约束太多，一股“大公司味”：如果我的项目有上百人一起开发，C# 的合规性约束确实是有意义的。<br />\n但我的项目没有这么多人一起开发，很多时候，我不想为了所谓的“合规”而牺牲工作效率。</p>\n<p>比如 C# 的规范要求所有参数都作 null 校验，否则报 <code>ArgumentNullException</code>，而不是更普遍的 <code>NullReferenceException</code>。如果自己的项目不校验，显得代码不正规。如果校验了，又增加了工作量。</p>\n<h2 id=\"我为什么不喜欢-javascripttypescript\">我为什么不喜欢 JavaScript/TypeScript</h2>\n<p>从语法上，我认为 TypeScript 是所有语言中最优秀的。<br />\n既符合传统 C 语言的美感，又为业务开发提供了需多语法糖。</p>\n<p>但核心的缺点是“慢”。<br />\n慢到无法写实际业务的后端，毕竟它是单线程的。</p>\n<p>虽然有很多人反对说，很多公司也用 Nodejs 写后端的。<br />\n但用 Nodejs 写的后端一定不能处理复杂业务的高并发，或者 Nodejs 只是个代理，真正的业务由其他语言开发完成。</p>\n<h2 id=\"我为什么不喜欢-python\">我为什么不喜欢 Python</h2>\n<p>将空格作为语法的一部分，在代码复制时特别麻烦。</p>\n<p>特别是业务项目里，复制代码是很常见的。</p>\n<h2 id=\"我需要的是什么\">我需要的是什么</h2>\n<p>目前，我的首选语言只有 TypeScript 和 Go，分别写前后端。</p>\n<p>相比其他语言，它们是最好的选择。</p>\n<p>但我希望为自己打造一门更好的语言，它是 TypeScript 和 Go 的结合体：<br />\n拥有和 TypeScript 一样强大的类型系统，一样便利的语法糖，同时又具有 Go 的高性能、编译能力。<br />\n它既可以用来写前端，也可以用来写后端。</p>\n<h2 id=\"对语言设计的思考\">对语言设计的思考</h2>\n<p>虽然每个语言都有不同的语法、特性，但多数语法本质是相通的，纯粹是写法的区别。<br />\n每个语言作者都有自己的偏执和抉择，并试图让他人接受和自己相同的选择。</p>\n<p>我非常反感有些语言设计者把多数人都熟知的概念换成一个新概念，但这种新概念又没有引入什么优势，纯粹是习惯上的区别而已。</p>\n<p>比如 PHP 里面，用 “.” 作字符串连接符，导致对象调用必须用 “-&gt;”，在所有语言里独树一帜，就是不好的设计。</p>\n<p>新设计语言时，应该尽量追求和主流语言类似，因为主流的背后代表有很多已经习惯他的用户。<br />\n如果没有功能性上的改进，尽量不要发明新语法。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n</div>"
    },
    {
      "title": "spring6-多种类型的注入方式",
      "link": "https://www.cnblogs.com/alineverstop/p/19563560",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/alineverstop/p/19563560\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 12:12\">\n    <span>spring6-多种类型的注入方式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"ocp原则\">OCP原则</h1>\n<p>ocp指开闭原则，对扩展开放，对修改关闭。是七大原则中最基本的一个原则。</p>\n<h1 id=\"依赖倒置原则dip\">依赖倒置原则（DIP）</h1>\n<h2 id=\"什么是依赖倒置原则\">什么是依赖倒置原则</h2>\n<p>核心是面向接口编程、面向抽象编程， 不是面向具体编程。</p>\n<h2 id=\"依赖倒置原则的目的\">依赖倒置原则的目的</h2>\n<p>降低耦合度，提高扩展力</p>\n<h1 id=\"什么是控制反转\">什么是控制反转</h1>\n<p>控制反转：Ioc（Inversion of Controll），一种编程思想、设计模式。为了降低程序耦合度</p>\n<p>反转有两点：</p>\n<ol>\n<li>不在程序中采用硬编码的方式new对象，把创建对象交给别人（UserService userService = new UserServiceImplForMysql()）。</li>\n<li>不在程序中采用硬编码的方式维护对象关系。</li>\n</ol>\n<h1 id=\"spring框架\">spring框架</h1>\n<p>spring实现了Ioc，因此可以创建和维护对象见的关系。</p>\n<p>控制反转实现方式主要有 <strong>依赖注入（Dependency Injection DI）</strong></p>\n<p>依赖注入的方式有以下方式：</p>\n<ol>\n<li>Set注入（执行Set方法赋值）</li>\n<li>构造方法注入（执行构造方法赋值）</li>\n</ol>\n<h2 id=\"依赖注入中的依赖注入的含义\">依赖注入中的“依赖”、“注入”的含义</h2>\n<p>依赖：A对象和B对象的关系</p>\n<p>注入：是一种手段，通过这种手段让A和B产生关系。</p>\n<p>依赖注入的实现方式有：set注入和构造方法注入。</p>\n<h3 id=\"set注入\">set注入</h3>\n<ol>\n<li>配置文件配置bean</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;!--    配置dao--&gt;\n    &lt;bean id=\"userDao\" class=\"com.ali.dao.UserDao\"&gt;\n    &lt;/bean&gt;\n&lt;!--    配置Service--&gt;\n    &lt;bean id=\"userService\" class=\"com.ali.service.UserService\"&gt;\n        &lt;!--注入dao，这里的name是 set方法名去掉set字符后剩下的单词首字母小写--&gt;\n&lt;!--        ref后面指定要注入的bean的id--&gt;\n        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;\n    &lt;/bean&gt;\n</code></pre>\n<ol start=\"2\">\n<li>在类中写set方法</li>\n</ol>\n<pre><code class=\"language-java\">package com.ali.service;\n\nimport com.ali.dao.UserDao;\n\npublic class UserService {\n\n    private UserDao userDao;\n\n    // set注入需要提供一个set方法，方法名以set开头，spring容器调用这个set方法注入UserDao\n        public void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n    public void saveUser(){\n        userDao.insertUser();\n    }\n}\n</code></pre>\n<p>这样即可注入成功。</p>\n<h4 id=\"注入外部bean\">注入外部bean</h4>\n<pre><code class=\"language-xml\">&lt;!--    声明bean--&gt;\n    &lt;bean id=\"orderDao\" class=\"com.ali.dao.OrderDao\" /&gt;\n\n    &lt;bean id=\"orderService\" class=\"com.ali.service.OrderService\"&gt;\n&lt;!--    使用ref 来    注入外部bean--&gt;\n        &lt;property name=\"orderDao\" ref=\"orderDao\"/&gt;\n    &lt;/bean&gt;\n</code></pre>\n<h4 id=\"注入内部bean\">注入内部bean</h4>\n<pre><code class=\"language-xml\">    &lt;bean id=\"orderService2\" class=\"com.ali.service.OrderService\"&gt;\n      &lt;property name=\"orderDao\"&gt;\n&lt;!--          在property标签中使用嵌套bean，这就是内部bean--&gt;\n          &lt;bean class=\"com.ali.dao.OrderDao\" &gt;&lt;/bean&gt;\n      &lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<h4 id=\"注入简单类型\">注入简单类型</h4>\n<pre><code class=\"language-xml\">&lt;!--    注入简单类型属性--&gt;\n&lt;bean id=\"userBean\" class=\"com.ali.bean.User\"&gt;\n&lt;!--    简单类型赋值使用value属性--&gt;\n    &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;\n    &lt;property name=\"age\" value=\"30\"&gt;&lt;/property&gt;\n    &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p>实际开发中，一般不会吧Date类型当作简单类型，会使用ref来注入Date类型</p>\n<h4 id=\"级联属性赋值\">级联属性赋值</h4>\n<pre><code class=\"language-xml\">&lt;!--     使用级联属性赋值，给studentBean的clazz属性赋值必须有set、get方法--&gt;\n&lt;!--        先配置clazz  再配置clazz.name--&gt;\n    &lt;bean id=\"studentBean\" class=\"com.ali.bean.Student\"&gt;\n        &lt;property name=\"name\" value=\"李四\"&gt;&lt;/property&gt;\n        &lt;property name=\"clazz\" ref=\"clazzBean\"&gt;&lt;/property&gt;\n        &lt;!--级联属性赋值，给studentBean的clazz属性赋值\n        这里的clazz是Student类中的属性名\n        clazz 必须有set、get方法--&gt;\n        &lt;property name=\"clazz.name\" value=\"高三二班\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=\"clazzBean\" class=\"com.ali.bean.Clazz\"&gt;\n    &lt;/bean&gt;\n</code></pre>\n<h4 id=\"注入数组\">注入数组</h4>\n<pre><code class=\"language-xml\">   &lt;!--    注入简单类型属性--&gt;\n&lt;bean id=\"userBean1\" class=\"com.ali.bean.User\"&gt;\n&lt;!--    简单类型赋值使用value属性--&gt;\n    &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;\n    &lt;property name=\"age\" value=\"30\"&gt;&lt;/property&gt;\n    &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=\"userBean2\" class=\"com.ali.bean.User\"&gt;\n        &lt;!--    简单类型赋值使用value属性--&gt;\n        &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;\n        &lt;property name=\"age\" value=\"30\"&gt;&lt;/property&gt;\n        &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=\"userBean3\" class=\"com.ali.bean.User\"&gt;\n        &lt;!--    简单类型赋值使用value属性--&gt;\n        &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;\n        &lt;property name=\"age\" value=\"30\"&gt;&lt;/property&gt;\n        &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n   \n   &lt;bean id=\"qdyBean\" class=\"com.ali.bean.QDY\"&gt;\n&lt;!--        aihao属性是一个字符串数组--&gt;\n        &lt;property name=\"aihao\"&gt;\n            &lt;array&gt;\n                &lt;value&gt;吃&lt;/value&gt;\n                &lt;value&gt;喝&lt;/value&gt;\n            &lt;/array&gt;\n        &lt;/property&gt;\n&lt;!--        friends是一个User对象数组--&gt;\n        &lt;property name=\"friends\"&gt;\n            &lt;array&gt;\n                &lt;ref bean=\"userBean1\"&gt;&lt;/ref&gt;\n                &lt;ref bean=\"userBean2\"&gt;&lt;/ref&gt;\n                &lt;ref bean=\"userBean3\"&gt;&lt;/ref&gt;\n            &lt;/array&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<h4 id=\"注入list和set类型\">注入List和Set类型</h4>\n<pre><code class=\"language-xml\">    &lt;bean id=\"personBean\" class=\"com.ali.bean.Person\"&gt;\n&lt;!--        names是 List&lt;String&gt; 类型--&gt;\n        &lt;property name=\"names\"&gt;\n            &lt;list&gt;\n                &lt;value&gt;张三&lt;/value&gt;\n                &lt;value&gt;里斯&lt;/value&gt;\n                &lt;value&gt;詹姆思&lt;/value&gt;\n            &lt;/list&gt;\n        &lt;/property&gt;\n&lt;!--        address 是 Set&lt;String&gt;   类型--&gt;\n        &lt;property name=\"address\"&gt;\n            &lt;set&gt;\n                &lt;value&gt;北京&lt;/value&gt;\n                &lt;value&gt;上海&lt;/value&gt;\n                &lt;value&gt;广州&lt;/value&gt;\n            &lt;/set&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<h4 id=\"注入map集合\">注入Map集合</h4>\n<pre><code class=\"language-xml\">&lt;!--      phone 是一个Map&lt;Integer, String&gt;类型\n      如果key是简单类型，可以直接使用entry标签的key属性赋值\n      如果key是复杂类型，可以使用\n      &lt;entry key-ref=\"keyBean\" value-ref=\"valueBean\"&gt;&lt;/entry&gt;\n      value同理--&gt;\n      &lt;property name=\"phone\"&gt;\n          &lt;map&gt;\n              &lt;entry key=\"1\" value=\"13800138000\"&gt;&lt;/entry&gt;\n              &lt;entry key=\"2\" value=\"13900139000\"&gt;&lt;/entry&gt;\n              &lt;entry key=\"3\" value=\"13700137000\"&gt;&lt;/entry&gt;\n          &lt;/map&gt;\n      &lt;/property&gt;\n</code></pre>\n<h4 id=\"注入properties类型\">注入Properties类型</h4>\n<pre><code class=\"language-xml\">&lt;!--        Properties 的key 和value只能是字符串类型--&gt;\n        &lt;property name=\"properties\"&gt;\n            &lt;props&gt;\n                &lt;prop key=\"k1\"&gt;v1&lt;/prop&gt;\n                &lt;prop key=\"k2\"&gt;v2&lt;/prop&gt;\n                &lt;prop key=\"k3\"&gt;v3&lt;/prop&gt;\n            &lt;/props&gt;\n        &lt;/property&gt;\n</code></pre>\n<h4 id=\"注入null和空字符串\">注入null和空字符串</h4>\n<pre><code class=\"language-xml\">&lt;!--        以下是手动注入null--&gt;\n        &lt;property name=\"name\" &gt;\n            &lt;null&gt;&lt;/null&gt;\n        &lt;/property&gt;\n        &lt;!--        不给属性注入，属性的默认值是null--&gt;\n&lt;!--        &lt;property name=\"name\" value=\"tom\"&gt;&lt;/property&gt;--&gt;\n&lt;!--       注入空字符串方式一 --&gt;\n        &lt;property name=\"name\" value=\"\"&gt;&lt;/property&gt;\n&lt;!--        注入空字符串方式二 --&gt;\n        &lt;property name=\"name\" &gt;\n            &lt;value&gt;&lt;/value&gt;\n        &lt;/property&gt;\n        &lt;property name=\"age\" value=“31”&gt;&lt;/property&gt;\n</code></pre>\n<h4 id=\"注入特殊字符串\">注入特殊字符串</h4>\n<pre><code class=\"language-xml\"> &lt;bean id=\"mathBean\" class=\"com.ali.bean.MathBean\"&gt;\n        &lt;!--     第一种：使用实体符号代替特殊符号    2&lt;3 --&gt;\n&lt;!--        &lt;property name=\"result\" value=\"2 &amp;lt; 3\"&gt;&lt;/property&gt;--&gt;\n        &lt;!--     第二种：使用&lt;![CDATA[]]&gt; 这里面的内容不会被xml解析    2&lt;3 --&gt;\n        &lt;property name=\"result\"&gt;\n&lt;!--            只能使用value标签--&gt;\n            &lt;value&gt;&lt;![CDATA[2&lt;3]]&gt;&lt;/value&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<h3 id=\"构造注入\">构造注入</h3>\n<ol>\n<li>配置文件配置bean</li>\n</ol>\n<pre><code class=\"language-xml\">    &lt;bean id=\"userDaoBean\" class=\"com.ali.dao.UserDao\"&gt;\n    &lt;/bean&gt;\n&lt;!--     构造注入--&gt;\n    &lt;bean class=\"com.ali.service.CustomerService\" id=\"customerService\"&gt;\n&lt;!--        指定构造方法的第一个参数，下标是0--&gt;\n        &lt;constructor-arg index=\"0\" ref=\"userDaoBean\"&gt;&lt;/constructor-arg&gt;\n        &lt;!--        根据参数名注入--&gt;\n        &lt;constructor-arg name=\"userDao\" ref=\"userDaoBean“&gt;&lt;/constructor-arg&gt;\n    &lt;/bean&gt;\n</code></pre>\n<ol start=\"2\">\n<li>在类中写构造方法</li>\n</ol>\n<pre><code class=\"language-java\">public class CustomerService {\n\n    private UserDao userDao;\n\n    public CustomerService(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n    public  void save(){\n        userDao.insertUser();\n    }\n}\n</code></pre>\n<h3 id=\"p命名空间注入简化set注入\">p命名空间注入（简化set注入）</h3>\n<pre><code class=\"language-xml\">&lt;!--  p命名空间注入底层还是set注入（类中的属性必须有set方法），只不过p命名空间注入让spring配置更加简单\n  1.在spring配置文件头部添加p命名空间。  xmlns:p=\"http://www.springframework.org/schema/p\"\n  2.使用p命名空间注入属性，语法：p:属性名=\"属性值\"  p:属性名-ref=\"引用类型属性值\"--&gt;\n  &lt;bean id=\"dogBean\" class=\"com.ali.bean.Dog\" p:age=\"22\" p:name=\"张三\" p:birthday-ref=\"birthdayBean\"/&gt;\n\n  &lt;bean id=\"birthdayBean\" class=\"java.util.Date\" /&gt;\n</code></pre>\n<h3 id=\"c命名空间注入简化构造注入\">c命名空间注入（简化构造注入）</h3>\n<pre><code class=\"language-xml\">&lt;!--  c命名空间注入底层还是构造器注入（类中必须有对应的构造器），只不过c命名空间注入让spring配置更加简单\n  1.在spring配置文件头部添加c命名空间。  xmlns:c=\"http://www.springframework.org/schema/c\"\n  2.使用c命名空间注入属性，语法：c:属性名=\"属性值\"  c:属性名-ref=\"引用类型属性值\"\n  c:_0 下标方式   c:name  参数名方式--&gt;\n&lt;bean id=\"peopleBean\" class=\"com.ali.bean.People\" c:name=\"咪咪\" c:age=\"3\" c:sex=\"true\"/&gt;\n</code></pre>\n<h3 id=\"基于xml的自动装配byname\">基于xml的自动装配byName</h3>\n<pre><code class=\"language-xml\">&lt;!--        自动装配：byName、 也是基于set的--&gt;\n&lt;!--    根据名字自动装配，其中OrderDao是OrderService里面的一个属性。必须有set方法--&gt;\n    &lt;bean id=\"orderServiceBean\" class=\"com.ali.service.OrderService\" autowire=\"byName\"&gt;&lt;/bean&gt;\n\n&lt;!--    这个id 必须是OrderService中set方法去掉“set”后首字母小写--&gt;\n    &lt;bean id=\"orderDao\" class=\"com.ali.dao.OrderDao\"&gt;&lt;/bean&gt;\n</code></pre>\n<h3 id=\"基于xml的自动装配bytype\">基于xml的自动装配byType</h3>\n<pre><code class=\"language-xml\">&lt;!--     根据类型自动装配，自动装配是基于set方法的\n         根据类型进行自动装配时，配置文件中某个类型的实例只能有一个\n         --&gt;\n    &lt;bean class=\"com.ali.dao.VipDao\"&gt;&lt;/bean&gt;\n    &lt;bean class=\"com.ali.dao.UserDao\"&gt;&lt;/bean&gt;\n&lt;!--    CustomerService类里面VipDao和UserDao属性，这2个属性必须有set方法才能自动注入上面2个bean--&gt;\n    &lt;bean id=\"customerServiceBean\" class=\"com.ali.service.CustomerService\" autowire=\"byType\"&gt;&lt;/bean&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<h3 id=\"引入外部的属性配置文件\">引入外部的属性配置文件</h3>\n<pre><code class=\"language-xml\">   &lt;!-- 引入外部的properties文件\n     第一步：引入context命名空间 xmlns:context=\"http://www.springframework.org/schema/context\"\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n     第二步：使用&lt;context:property-placeholder&gt;标签引入外部的properties文件,默认从类的根路径下加载\n     --&gt;\n    &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;\n\n    &lt;bean id=\"mydataSource\" class=\"com.ali.bean.MyDataSource\"&gt;\n        &lt;!-- 使用${}占位符引用外部properties文件中的属性值 这4个属性必须有set方法--&gt;\n        &lt;property name=\"driver\" value=\"${jdbc.diverClass}\"/&gt;\n        &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;\n        &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;\n        &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p>jdbc.properties文件</p>\n<pre><code class=\"language-properties\">jdbc.diverClass=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/spring6db?useSSL=false&amp;server\njdbc.username=root\njdbc.password=123456\n</code></pre>\n<h1 id=\"spring怎么实例化对象\">spring怎么实例化对象？</h1>\n<p>默认情况下spring通过反射机制，调用类的无参数构造方法实例化对象</p>\n<p>把创建好的对象存储到Map结构中。</p>\n<p>当有多个配置文件时，可读取多个配置文件</p>\n<pre><code class=\"language-java\">ApplicationContext context = new ClassPathXmlApplicationContext(\"spring.xml\",\"spring-dao.xml\");\n</code></pre>\n<p>可以在配置文件中注入jdk自带的类，只要这个类有无参数构造方法就行。</p>\n<p>getBean（）时，Bean的id不存在时会报错</p>\n<h2 id=\"从类路径之外的路径获取xml配置文件\">从类路径之外的路径获取xml配置文件</h2>\n<pre><code class=\"language-java\">// 读取类路径之外的配置文件\nApplicationContext context = new FileSystemXmlApplicationContext(\"D:/applicationContext.xml\");\nObject user=  context.getBean(\"user\"); // 获取spring容器中的对象\n</code></pre>\n<p>ApplicationContext的超级父接口是BeanFactory。</p>\n<p>BeanFactory是Ioc容器的顶级接口。</p>\n<p>spring的Ioc容器底层使用了工厂模式。</p>\n<h1 id=\"启用log4j2\">启用Log4j2</h1>\n<p>spring5之后支持Log4j2框架。</p>\n<ol>\n<li>引入依赖</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;\n    &lt;version&gt;2.19.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n    &lt;version&gt;2.19.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<ol>\n<li>编写配置文件，文件名必须是log4j2.xml，放在类根路径下</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;configuration&gt;\n\n    &lt;loggers&gt;\n        &lt;!--\n            level指定日志级别，从低到高的优先级：\n                ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF\n        --&gt;\n        &lt;root level=\"DEBUG\"&gt;\n            &lt;appender-ref ref=\"spring6log\"/&gt;\n        &lt;/root&gt;\n    &lt;/loggers&gt;\n\n    &lt;appenders&gt;\n        &lt;!--输出日志信息到控制台--&gt;\n        &lt;console name=\"spring6log\" target=\"SYSTEM_OUT\"&gt;\n            &lt;!--控制日志输出的格式--&gt;\n            &lt;PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss SSS} [%t] %-3level %logger{1024} - %msg%n\"/&gt;\n        &lt;/console&gt;\n    &lt;/appenders&gt;\n\n&lt;/configuration&gt;\n</code></pre>\n<ol>\n<li>使用日志框架 ，在SpringTest01类中使用如下代码</li>\n</ol>\n<pre><code class=\"language-java\">Logger logger = LoggerFactory.getLogger(SpringTest01.class);\nlogger.info(\"日志信息\");\n</code></pre>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/alineverstop/\" target=\"_blank\">NE_STOP</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/alineverstop/p/19563560\" target=\"_blank\">https://www.cnblogs.com/alineverstop/p/19563560</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 12:12</span>&nbsp;\n<a href=\"https://www.cnblogs.com/alineverstop\">NE_STOP</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Java中的数据类型",
      "link": "https://www.cnblogs.com/chenxvhua/p/19563547",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chenxvhua/p/19563547\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 12:07\">\n    <span>Java中的数据类型</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"java-数据类型详解\">Java 数据类型详解</h1>\n<h2 id=\"目录\">目录</h2>\n<ul>\n<li><a href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB\" rel=\"noopener nofollow\">数据类型分类</a></li>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\" rel=\"noopener nofollow\">基本数据类型</a></li>\n<li><a href=\"#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\" rel=\"noopener nofollow\">引用类型</a></li>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-vs-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\" rel=\"noopener nofollow\">基本类型 vs 引用类型</a></li>\n<li><a href=\"#%E5%8C%85%E8%A3%85%E7%B1%BB\" rel=\"noopener nofollow\">包装类</a></li>\n<li><a href=\"#string-%E8%AF%A6%E8%A7%A3\" rel=\"noopener nofollow\">String 详解</a></li>\n<li><a href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0\" rel=\"noopener nofollow\">字符串常量池</a></li>\n<li><a href=\"#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80\" rel=\"noopener nofollow\">内存布局</a></li>\n<li><a href=\"#%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\" rel=\"noopener nofollow\">对象生命周期</a></li>\n<li><a href=\"#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\" rel=\"noopener nofollow\">常见问题</a></li>\n</ul>\n<hr />\n<h2 id=\"数据类型分类\">数据类型分类</h2>\n<pre><code>Java 数据类型\n├── 基本类型（8种）\n│   ├── 整数类型：byte, short, int, long\n│   ├── 浮点类型：float, double\n│   ├── 字符类型：char\n│   └── 布尔类型：boolean\n└── 引用类型\n    ├── 类（如 String）\n    ├── 接口\n    └── 数组\n</code></pre>\n<hr />\n<h2 id=\"基本数据类型\">基本数据类型</h2>\n<h3 id=\"整数类型\">整数类型</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>位数</th>\n<th>范围</th>\n<th>默认值</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>byte</code></td>\n<td>8位</td>\n<td>-128 ~ 127</td>\n<td>0</td>\n<td><code>byte b = 100;</code></td>\n</tr>\n<tr>\n<td><code>short</code></td>\n<td>16位</td>\n<td>-32,768 ~ 32,767</td>\n<td>0</td>\n<td><code>short s = 10000;</code></td>\n</tr>\n<tr>\n<td><code>int</code></td>\n<td>32位</td>\n<td>-21亿 ~ 21亿</td>\n<td>0</td>\n<td><code>int i = 100000;</code></td>\n</tr>\n<tr>\n<td><code>long</code></td>\n<td>64位</td>\n<td>极大</td>\n<td>0L</td>\n<td><code>long l = 100000L;</code></td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"language-java\">byte  a = 127;     // ✅ 最大值\n// byte b = 128;  // ❌ 超出范围\n\nint   c = 100;\nlong  d = 100000L; // long 需加 L 或 l\nlong  e = 10000000000L; // ✅ 超出int范围必须加L\n// long  f = 10000000000; // ❌ 编译错误，超出 int 范围\n</code></pre>\n<h3 id=\"浮点类型\">浮点类型</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>位数</th>\n<th>精度</th>\n<th>默认值</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>float</code></td>\n<td>32位</td>\n<td>单精度（7位有效数字）</td>\n<td>0.0f</td>\n<td><code>float f = 3.14f;</code></td>\n</tr>\n<tr>\n<td><code>double</code></td>\n<td>64位</td>\n<td>双精度（15位有效数字）</td>\n<td>0.0</td>\n<td><code>double d = 3.14;</code></td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"language-java\">double a = 3.14;     // 默认是 double\n// float b = 3.14;  // ❌ 编译错误\nfloat  c = 3.14f;    // ✅\n</code></pre>\n<h3 id=\"字符类型\">字符类型</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>位数</th>\n<th>说明</th>\n<th>默认值</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>char</code></td>\n<td>16位</td>\n<td>单个 Unicode 字符</td>\n<td>\\u0000</td>\n<td><code>char c = 'A';</code></td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"language-java\">char a = 'A';       // 字符\nchar b = '中';      // 中文\nchar c = 65;        // 数字对应字符 'A'\nchar d = '\\u0041';  // Unicode 转义，'A'\nchar e = '\\u0000';  // null 字符，char 的默认值\n\n// char f = 'AB';  // ❌ char 只能存单个字符\n</code></pre>\n<h3 id=\"布尔类型\">布尔类型</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>取值</th>\n<th>默认值</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>boolean</code></td>\n<td>true, false</td>\n<td>false</td>\n<td><code>boolean flag = true;</code></td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"language-java\">boolean a = true;\nboolean b = false;\n</code></pre>\n<hr />\n<h2 id=\"引用类型\">引用类型</h2>\n<h3 id=\"什么是引用类型\">什么是引用类型</h3>\n<p><strong>引用类型存储的是对象的地址（引用），对象本身存储在堆中。</strong></p>\n<h3 id=\"常见引用类型\">常见引用类型</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String</td>\n<td>字符串类</td>\n<td><code>String s = \"hello\";</code></td>\n</tr>\n<tr>\n<td>数组</td>\n<td>数组</td>\n<td><code>int[] arr = {1, 2, 3};</code></td>\n</tr>\n<tr>\n<td>接口</td>\n<td>接口类型</td>\n<td><code>List&lt;String&gt; list;</code></td>\n</tr>\n<tr>\n<td>自定义类</td>\n<td>用户定义的类</td>\n<td><code>Person p = new Person();</code></td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"基本类型-vs-引用类型\">基本类型 vs 引用类型</h2>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>基本类型</th>\n<th>引用类型（如 String）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存储位置</strong></td>\n<td>栈中，直接存值</td>\n<td>栈存引用，堆存对象</td>\n</tr>\n<tr>\n<td><strong>大小</strong></td>\n<td>固定（如 int 4字节）</td>\n<td>不固定</td>\n</tr>\n<tr>\n<td><strong>默认值</strong></td>\n<td>0/false/\\u0000</td>\n<td>null</td>\n</tr>\n<tr>\n<td><strong>比较</strong></td>\n<td><code>==</code> 比较值</td>\n<td><code>==</code> 比较地址，<code>equals()</code> 比较内容</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"内存图示\">内存图示</h3>\n<pre><code>基本类型：\n栈\n┌─────────┐\n│ int a   │ = 10\n└─────────┘\n  直接存值\n\n引用类型：\n栈                    堆\n┌─────────┐          ┌─────────┐\n│String s │ ────────→│ \"hello\" │\n└─────────┘          └─────────┘\n 引用变量            实际对象\n</code></pre>\n<h3 id=\"比较示例\">比较示例</h3>\n<pre><code class=\"language-java\">// 基本类型\nint a = 10;\nint b = 10;\nSystem.out.println(a == b);  // true（比较值）\n\n// 引用类型\nString s1 = new String(\"hello\");\nString s2 = new String(\"hello\");\nSystem.out.println(s1 == s2);         // false（不同地址）\nSystem.out.println(s1.equals(s2));    // true（内容相同）\n</code></pre>\n<hr />\n<h2 id=\"包装类\">包装类</h2>\n<p>每个基本类型都有对应的包装类：</p>\n<table>\n<thead>\n<tr>\n<th>基本类型</th>\n<th>包装类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>byte</code></td>\n<td><code>Byte</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>short</code></td>\n<td><code>Short</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>int</code></td>\n<td><code>Integer</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>long</code></td>\n<td><code>Long</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>float</code></td>\n<td><code>Float</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>double</code></td>\n<td><code>Double</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>char</code></td>\n<td><code>Character</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>boolean</code></td>\n<td><code>Boolean</code></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"language-java\">int a = 10;              // 基本类型\nInteger b = 10;          // 包装类\nInteger c = Integer.valueOf(10); // 显式创建\n\n// 自动装箱/拆箱\nInteger d = a;           // 自动装箱\nint e = d;               // 自动拆箱\n</code></pre>\n<hr />\n<h2 id=\"string-详解\">String 详解</h2>\n<h3 id=\"string-是什么\">String 是什么？</h3>\n<p><strong>String 是类，不是基本类型，是不可变的引用类型。</strong></p>\n<h3 id=\"string-的不可变性\">String 的不可变性</h3>\n<pre><code class=\"language-java\">String a = \"hello\";\nString b = a;              // a 和 b 指向同一对象\n\na = \"world\";               // a 指向新对象\n\nSystem.out.println(b);     // 输出: hello（b 不变）\nSystem.out.println(a == b); // false（已不是同一对象）\n</code></pre>\n<pre><code>内存变化：\n\n修改前：\na ──→ [\"hello\"]\n      ↑\n      b\n\n修改后：\na ──→ [\"world\"]  ← 新对象\n\nb ──→ [\"hello\"]  ← 原对象不变\n</code></pre>\n<h3 id=\"为什么-string-不可变\">为什么 String 不可变？</h3>\n<pre><code class=\"language-java\">// String 简化版源码\npublic final class String {\n    private final char value[];  // final，不能修改\n\n    // 所有修改操作都返回新 String\n    public String substring(int beginIndex) {\n        return new String(value, beginIndex, count);\n    }\n}\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>原因</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>不可变</strong></td>\n<td>String 对象一旦创建，内容不能改</td>\n</tr>\n<tr>\n<td><strong>final</strong></td>\n<td>String 类内部用 final 修饰字符数组</td>\n</tr>\n<tr>\n<td><strong>安全</strong></td>\n<td>多线程环境下，无需加锁就能安全共享</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"string-vs-可变对象\">String vs 可变对象</h3>\n<pre><code class=\"language-java\">// String - 不可变\nString a = \"hello\";\nString b = a;\na = \"world\";\nSystem.out.println(b);  // hello（不变）\n\n// StringBuilder - 可变\nStringBuilder sb1 = new StringBuilder(\"hello\");\nStringBuilder sb2 = sb1;\nsb1.append(\" world\");\nSystem.out.println(sb2);  // hello world（变了！）\n</code></pre>\n<hr />\n<h2 id=\"字符串常量池\">字符串常量池</h2>\n<h3 id=\"什么是字符串常量池\">什么是字符串常量池</h3>\n<pre><code>┌─────────────────────────────────────────────────────┐\n│                   字符串常量池                       │\n│  (JVM 堆内存中的一块特殊区域，专门存储字符串字面量)  │\n│                                                     │\n│   \"hello\"                                           │\n│   \"world\"                                           │\n│   \"java\"                                            │\n└─────────────────────────────────────────────────────┘\n</code></pre>\n<h3 id=\"字面量-vs-new\">字面量 vs new</h3>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>写法</th>\n<th>存储位置</th>\n<th>是否复用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>隐式（字面量）</strong></td>\n<td><code>String s = \"hello\";</code></td>\n<td>字符串常量池</td>\n<td>✅ 复用</td>\n</tr>\n<tr>\n<td><strong>显式（new）</strong></td>\n<td><code>String s = new String(\"hello\");</code></td>\n<td>堆内存（新对象）</td>\n<td>❌ 新对象</td>\n</tr>\n<tr>\n<td><strong>动态创建</strong></td>\n<td><code>scanner.nextLine()</code></td>\n<td>堆内存（新对象）</td>\n<td>❌ 新对象</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"字面量隐式赋值\">字面量（隐式赋值）</h3>\n<pre><code class=\"language-java\">String a = \"hello\";\nString b = \"hello\";\n</code></pre>\n<p><strong>流程：</strong></p>\n<ol>\n<li>JVM 检查常量池中是否有 <code>\"hello\"</code></li>\n<li>有 → 直接引用（复用）</li>\n<li>无 → 在常量池创建 <code>\"hello\"</code>，然后引用</li>\n</ol>\n<pre><code>常量池：\n┌─────────┐\n│ \"hello\" │ ← a ─┐\n└─────────┘       │\n                  │ 两者指向同一对象\n                  ├─ b\n</code></pre>\n<pre><code class=\"language-java\">System.out.println(a == b);  // true（同一对象）\n</code></pre>\n<h3 id=\"new显式赋值\">new（显式赋值）</h3>\n<pre><code class=\"language-java\">String c = new String(\"hello\");\nString d = new String(\"hello\");\n</code></pre>\n<p><strong>流程：</strong></p>\n<ol>\n<li>先在常量池检查/创建 <code>\"hello\"</code></li>\n<li>然后在堆内存<strong>强制创建新对象</strong></li>\n<li>变量引用堆上的新对象（不是常量池）</li>\n</ol>\n<pre><code>常量池：            堆内存：\n┌─────────┐        ┌─────────┐\n│ \"hello\" │ ───→   │ \"hello\" │ ← c\n└─────────┘        └─────────┘\n                   ┌─────────┐\n                   │ \"hello\" │ ← d\n                   └─────────┘\n</code></pre>\n<pre><code class=\"language-java\">System.out.println(c == d);   // false（不同对象）\nSystem.out.println(c == a);   // false（c 在堆，a 在常量池）\nSystem.out.println(c.equals(a)); // true（值相同）\n</code></pre>\n<h3 id=\"scanner-输入\">scanner 输入</h3>\n<pre><code class=\"language-java\">String c = scanner.nextLine(); // 输入: hello\nString d = scanner.nextLine(); // 输入: hello\nSystem.out.println(c == d);    // false（每次新对象）\n</code></pre>\n<hr />\n<h2 id=\"内存布局\">内存布局</h2>\n<h3 id=\"java-版本差异\">Java 版本差异</h3>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th>常量池位置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Java 6 及之前</td>\n<td>方法区（永久代 PermGen）</td>\n</tr>\n<tr>\n<td>Java 7+</td>\n<td><strong>堆</strong></td>\n</tr>\n<tr>\n<td>Java 8+</td>\n<td><strong>堆</strong>（方法区改为元空间 Metaspace）</td>\n</tr>\n</tbody>\n</table>\n<p><strong>现代 Java（7+）：字符串常量池在堆上。</strong></p>\n<h3 id=\"完整内存布局\">完整内存布局</h3>\n<pre><code>String s1 = \"first\";\nString s2 = new String(\"second\");\n\n栈：\n┌─────────┐      ┌─────────┐\n│   s1    │      │   s2    │\n└─────────┘      └─────────┘\n  ↓ 引用            ↓ 引用\n\n堆（都在堆上）：\n┌───────────────────────────────────────────────────┐\n│                                                   │\n│  常量池区域：         普通堆区域：                  │\n│  ┌─────────┐        ┌─────────────────────┐       │\n│  │ \"first\" │        │ String对象           │       │\n│  │\"second\" │        │ value → \"second\"    │       │\n│  └─────────┘        └─────────────────────┘       │\n│                             ↓                      │\n│                     ┌─────────┐                   │\n│                     │\"second\" │ ← 在常量池         │\n│                     └─────────┘                   │\n│                                                   │\n└───────────────────────────────────────────────────┘\n</code></pre>\n<h3 id=\"new-stringxxx-的步骤\">new String(\"xxx\") 的步骤</h3>\n<pre><code>1. 先处理 \"xxx\" 字面量\n   → 检查常量池有没有 \"xxx\"\n   → 没有 → 在常量池创建 \"xxx\"\n   → 有 → 复用\n\n2. 再执行 new String()\n   → 在普通堆创建新对象\n   → 对象内部引用常量池的 \"xxx\"\n</code></pre>\n<pre><code class=\"language-java\">String s = new String(\"second\");\n\n// 等价于：\nString literal = \"second\";      // 先处理字面量，进常量池\nString s = new String(literal); // 再创建堆对象\n</code></pre>\n<hr />\n<h2 id=\"对象生命周期\">对象生命周期</h2>\n<h3 id=\"对象的一生\">对象的一生</h3>\n<pre><code>┌─────────────────────────────────────────────────────────┐\n│                   对象一生                               │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  1. 创建     →  new String() / scanner.nextLine()      │\n│     ↓                                                  │\n│  2. 使用     →  被变量引用，可以访问                    │\n│     ↓                                                  │\n│  3. 失去引用 →  变量指向其他对象或离开作用域            │\n│     ↓                                                  │\n│  4. 可回收    →  等待 GC 清理                          │\n│     ↓                                                  │\n│  5. 回收     →  GC 自动回收内存                        │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n</code></pre>\n<h3 id=\"示例引用丢失\">示例：引用丢失</h3>\n<pre><code class=\"language-java\">String s1 = scanner.nextLine();  // 创建对象\ns1 = scanner.nextLine();         // s1 指向新对象，原对象可被回收\n</code></pre>\n<h3 id=\"垃圾回收gc\">垃圾回收（GC）</h3>\n<p><strong>GC = Garbage Collection，Java 自动内存管理机制。</strong></p>\n<pre><code>GC 工作原理：\n1. 定期扫描堆内存\n2. 找出没有被引用的对象\n3. 回收内存\n</code></pre>\n<h3 id=\"不同区域的回收策略\">不同区域的回收策略</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>生命周期</th>\n<th>回收方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>字面量（常量池）</strong></td>\n<td>程序运行期间</td>\n<td>一般不回收</td>\n</tr>\n<tr>\n<td><strong>动态对象（堆）</strong></td>\n<td>到无引用时</td>\n<td>GC 回收</td>\n</tr>\n<tr>\n<td><strong>基础类型（栈）</strong></td>\n<td>作用域内</td>\n<td>自动销毁</td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"language-java\">String a = \"hello\";  // 常量池，程序运行期间存在\nString b = scanner.nextLine();  // 堆对象\nb = null;  // 失去引用，等待 GC\n</code></pre>\n<h3 id=\"intern-方法\">intern() 方法</h3>\n<p><strong>将字符串内容放入常量池。</strong></p>\n<pre><code class=\"language-java\">String s = new String(\"aaa\");\ns.intern();  // 将 \"aaa\" 内容放入常量池（如果还没）\n</code></pre>\n<pre><code class=\"language-java\">String s1 = new String(\"aaa\");\nString s2 = new String(\"aaa\");\nString s3 = \"aaa\";  // 字面量，常量池\nString s4 = s1.intern();  // 返回常量池中的引用\n\nSystem.out.println(s1 == s2);   // false（堆对象，不同）\nSystem.out.println(s1 == s3);   // false（堆 vs 常量池）\nSystem.out.println(s3 == s4);   // true（都是常量池）\n</code></pre>\n<hr />\n<h2 id=\"常见问题\">常见问题</h2>\n<h3 id=\"q1-u0000-是什么\">Q1: \\u0000 是什么？</h3>\n<p><strong>\\u0000</strong> 是 Unicode 字符的转义表示，表示 Unicode 值为 0 的字符。</p>\n<table>\n<thead>\n<tr>\n<th>方面</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Unicode 值</strong></td>\n<td>0</td>\n</tr>\n<tr>\n<td><strong>名称</strong></td>\n<td>null 字符 / 空字符</td>\n</tr>\n<tr>\n<td><strong>可见性</strong></td>\n<td>不可见（控制字符）</td>\n</tr>\n<tr>\n<td><strong>Java 中</strong></td>\n<td>char 的默认值</td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"language-java\">char c = '\\u0000';          // null 字符\nchar d = 0;                 // 等价写法\nSystem.out.println(c == d); // true\nSystem.out.println((int)c); // 输出: 0\n</code></pre>\n<h3 id=\"q2-string-引用相同但值不同\">Q2: String 引用相同但值不同？</h3>\n<p><strong>对于 String，不可能。</strong></p>\n<pre><code class=\"language-java\">String a = \"hello\";\nString b = a;\na = \"world\";\nSystem.out.println(b);  // hello（b 不变）\n</code></pre>\n<p><strong>核心原因：</strong> String 是不可变的，引用相同则值必相同。</p>\n<h3 id=\"q3-scannernextline-返回什么\">Q3: scanner.nextLine() 返回什么？</h3>\n<p><strong>永远返回 String，无论输入什么。</strong></p>\n<pre><code class=\"language-java\">Scanner scanner = new Scanner(System.in);\nString input = scanner.nextLine();  // 输入 27 → \"27\"（字符串）\n\n// 如果要转整数\nint num = Integer.parseInt(input);  // \"27\" → 27\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>输入 27</th>\n<th>返回类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>nextLine()</code></td>\n<td><code>\"27\"</code></td>\n<td>String</td>\n</tr>\n<tr>\n<td><code>nextInt()</code></td>\n<td><code>27</code></td>\n<td>int</td>\n</tr>\n<tr>\n<td><code>nextDouble()</code></td>\n<td><code>27.0</code></td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"q4-常量池在堆上吗\">Q4: 常量池在堆上吗？</h3>\n<p><strong>是的，现代 Java（7+）中，字符串常量池在堆上。</strong></p>\n<p>但常量池是堆中特殊管理的区域，与普通堆对象有区别：</p>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>常量池对象</th>\n<th>普通堆对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>位置</strong></td>\n<td>堆（特殊区域）</td>\n<td>堆（普通区域）</td>\n</tr>\n<tr>\n<td><strong>创建方式</strong></td>\n<td>字面量、intern()</td>\n<td>new String()</td>\n</tr>\n<tr>\n<td><strong>去重</strong></td>\n<td>✅ 自动去重</td>\n<td>❌ 不去重</td>\n</tr>\n<tr>\n<td><strong>生命周期</strong></td>\n<td>一般长期存在</td>\n<td>无引用后 GC 回收</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"总结速查表\">总结速查表</h2>\n<h3 id=\"基本类型速查\">基本类型速查</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>位数</th>\n<th>范围</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>byte</code></td>\n<td>8</td>\n<td>-128 ~ 127</td>\n<td>0</td>\n</tr>\n<tr>\n<td><code>short</code></td>\n<td>16</td>\n<td>±3.2万</td>\n<td>0</td>\n</tr>\n<tr>\n<td><code>int</code></td>\n<td>32</td>\n<td>±21亿</td>\n<td>0</td>\n</tr>\n<tr>\n<td><code>long</code></td>\n<td>64</td>\n<td>极大</td>\n<td>0L</td>\n</tr>\n<tr>\n<td><code>float</code></td>\n<td>32</td>\n<td>单精度</td>\n<td>0.0f</td>\n</tr>\n<tr>\n<td><code>double</code></td>\n<td>64</td>\n<td>双精度</td>\n<td>0.0</td>\n</tr>\n<tr>\n<td><code>char</code></td>\n<td>16</td>\n<td>单字符</td>\n<td>\\u0000</td>\n</tr>\n<tr>\n<td><code>boolean</code></td>\n<td>1</td>\n<td>true/false</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"string-对比速查\">String 对比速查</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>String a = \"hello\";</code> <br /> <code>String b = \"hello\";</code></td>\n<td><code>a == b</code> → <strong>true</strong></td>\n</tr>\n<tr>\n<td><code>String c = new String(\"hello\");</code> <br /> <code>String d = new String(\"hello\");</code></td>\n<td><code>c == d</code> → <strong>false</strong></td>\n</tr>\n<tr>\n<td><code>a == c</code></td>\n<td><strong>false</strong>（常量池 vs 堆）</td>\n</tr>\n<tr>\n<td><code>a.equals(c)</code></td>\n<td><strong>true</strong>（值相同）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"记忆口诀\">记忆口诀</h3>\n<pre><code>基础类型     引用类型\n    ↓            ↓\n   栈          栈 + 堆\n 直接值       引用+对象\n\n字面量       scanner输入\n    ↓            ↓\n 常量池        堆新对象\n 可复用        不复用\n\nString  → 引用同，值必同（不可变）\nStringBuilder → 引用同，值随变（可变）\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 12:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chenxvhua\">雀啼春</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Google终于动手了：Gemini杀进Chrome，OpenAI的Atlas还没捂热乎",
      "link": "https://www.cnblogs.com/haibindev/p/19563454",
      "published": "",
      "description": "<div class=\"postTitle\">\n\t\t<h1><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/haibindev/p/19563454\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 11:47\">\n    <span>Google终于动手了：Gemini杀进Chrome，OpenAI的Atlas还没捂热乎</span>\n    \n\n</a>\n</h1>\n\t</div>\n\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Google终于动手了：Gemini杀进Chrome，OpenAI的Atlas还没捂热乎\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260202114708188-321337481.png\" />\n        OpenAI 对其AI 浏览器 ChatGPT Atlas 进行了更新，Google这边就坐不住了，开始正式上线Gemini in Chrome。\nChrome直接内置Gemini这事，其实早就在beta版里藏着，但一直没大范围开放。现在终于能用了，虽然——得绕点弯路。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"google终于动手了gemini杀进chromeopenai的atlas还没捂热乎\">Google终于动手了：Gemini杀进Chrome，OpenAI的Atlas还没捂热乎</h1>\n<blockquote>\n<p>OpenAI 对其AI 浏览器 ChatGPT Atlas 进行了更新，Google这边就坐不住了，开始正式上线Gemini in Chrome。</p>\n</blockquote>\n<p>Chrome直接内置Gemini这事，其实早就在beta版里藏着，但一直没大范围开放。现在终于能用了，虽然——得绕点弯路。</p>\n<h2 id=\"先说说openai那边\">先说说OpenAI那边</h2>\n<p>Atlas是OpenAI新推的桌面端应用，目前只有macOS版本。</p>\n<p><img alt=\"chatGPTAtlas页面\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260202114341923-2007242055.png\" /></p>\n<p>说白了就是把ChatGPT做成了原生应用，可以常驻在系统里，随时呼出：</p>\n<p><img alt=\"chatGPTAtlas页面展示\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260202114840325-1202318674.png\" /></p>\n<p>浏览网页的时候，侧边栏直接问问题，能根据当前页面内容回答。比如你在看一双跑鞋，问它适不适合跑马拉松，它能结合页面上的参数给你分析。</p>\n<p>这个场景确实刚需。但问题是，只有Mac能用，Windows用户只能干看着。</p>\n<h2 id=\"google的回应gemini-in-chrome\">Google的回应：Gemini in Chrome</h2>\n<p>然后Google就出手了。</p>\n<p>不搞独立应用那套，直接把Gemini塞进Chrome里。打开浏览器，右上角就有个Gemini图标：</p>\n<p><img alt=\"chrome右上角显示Gemini\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260202114351506-1973955822.png\" /></p>\n<p>点开就是侧边栏，交互逻辑和Atlas几乎一样。但这里有个关键区别：Chrome的用户基数是Atlas的几十倍，而且Windows、Mac、Linux通吃。</p>\n<h2 id=\"实际能干什么\">实际能干什么</h2>\n<p>随便试了试</p>\n<p><strong>总结页面内容</strong></p>\n<p>这是最常用的场景。打开一篇长文，让Gemini给你划重点：</p>\n<p><img alt=\"GeminiInChrome演示\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260202114359346-1242237796.png\" /></p>\n<p>响应速度比想象中快，而且支持中文页面。技术文章、新闻报道、产品文档，都能处理得比较清楚。</p>\n<p><strong>读图</strong></p>\n<p>页面上有图片，可以让它分析：</p>\n<p><img alt=\"可以解析图片\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260202114415882-477386825.png\" /></p>\n<p>识别各种AI工具的logo，然后分类整理出来。这个在看一些信息量大的图表时特别有用。</p>\n<p><strong>生图</strong></p>\n<p>对，还能画图。底层用的是nanobanana模型：</p>\n<p><img alt=\"可以调用nanobanana生成图片\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260202114423326-134018182.png\" /></p>\n<p>写博客临时需要个配图，不用再开别的工具了。</p>\n<p><strong>其他</strong><br />\n应该还能做很多，等有时间了再试试。大家也可以尝试一下，估计时间久了就会又开始限制访问了。</p>\n<h2 id=\"现在的问题\">现在的问题</h2>\n<p>好消息说完了，说说坑。</p>\n<p><strong>最大的问题是地区限制。</strong> 目前只对美国地区开放，其他地区的Chrome默认看不到这个功能。Google的灰度策略一向保守，全球开放可能还得等几个月。</p>\n<p><strong>其次是隐私问题。</strong> Gemini要分析页面内容，就必须读取你的浏览数据。虽然Google说数据不会被用于训练模型，但这话信不信由你。</p>\n<p><strong>另外就是稳定性。</strong> 毕竟还在早期阶段，偶尔会抽风，响应超时或者干脆不理你。</p>\n<p><strong>降智</strong> 会话多了就这样，感觉无解</p>\n<h2 id=\"怎么开启非美国地区\">怎么开启（非美国地区）</h2>\n<p>如果你和我一样不在美国，需要手动改点东西。</p>\n<p><strong>第一步：升级Chrome</strong></p>\n<p>确保是最新版本。打开 <code>chrome://settings/help</code>，让它自动更新到最新。</p>\n<p><strong>第二步：改系统地区</strong></p>\n<p>打开chrome设置，把语言设置成美国。（界面语言也必须是english（美国），否则不会展现）</p>\n<p><strong>第三步：关闭Chrome</strong></p>\n<p>完全关闭。去任务管理器里确认没有chrome.exe在后台跑着。</p>\n<p><strong>第四步：改配置文件</strong></p>\n<p>这是关键步骤。先备份！</p>\n<p>找到这个文件：</p>\n<pre><code>C:\\Users\\你的用户名\\AppData\\Local\\Google\\Chrome\\User Data\\Local State\n</code></pre>\n<p>复制一份存好，然后用记事本打开原文件，找到这三个字段并修改：</p>\n<pre><code>\"is_glic_eligible\": true\n\"variations_country\": \"us\"\n\n// 注意这一项不是把值完全改成us，是把国家简称改成us\n\"variations_permanent_consistency_country\": \"us\"\n</code></pre>\n<p>如果找不到就手动加进去，注意JSON格式别写错。</p>\n<p>保存，关闭。</p>\n<p><strong>第五步：重启Chrome</strong></p>\n<p>重新打开浏览器，右上角应该就能看到Gemini图标了。</p>\n<p>如果改完Chrome打不开，说明JSON格式写坏了，把备份的文件恢复回去重来。</p>\n<h2 id=\"说点感想\">说点感想</h2>\n<p>AI助手这个赛道，正在从\"谁的模型更强\"变成\"谁的入口更多\"。</p>\n<p>OpenAI选择做独立应用，走的是精品路线，体验可控但覆盖面窄。Google选择塞进Chrome，走的是流量路线，体验参差但触达面广。</p>\n<p>微软那边，Edge早就集成了Copilot。现在Chrome也跟上了。浏览器变成AI的入口，已经是确定的趋势。</p>\n<p>至于谁能赢，我觉得现阶段不重要。重要的是，我们作为用户，能用的工具越来越多了。</p>\n<p>这就挺好。</p>\n<blockquote>\n<p><em>最后，如果按教程操作遇到问题，评论区说，我尽量回复。</em></p>\n</blockquote>\n<hr />\n<p><strong>作者简介：</strong> 10年+视频技术、后端架构、AI应用开发经验，曾任某互联网大厂技术专家。对AI编程工具、云原生架构、视频处理技术有深入研究。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/254714/202307/254714-20230701143418754-1351786962.jpg\" /></p>\n<p><strong>合作请加WX：hbstream</strong><br />\n<strong>（<a href=\"http://haibindev.cnblogs.com\" target=\"_blank\">http://haibindev.cnblogs.com</a>），转载请注明作者和出处</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-02-02 11:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/haibindev\">haibindev</a>&nbsp;\n阅读(<span id=\"post_view_count\">18</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "天翼云全面上线Moltbot，通过云主机、AI云电脑、息壤应用托管一键开启AI助手体验！",
      "link": "https://www.cnblogs.com/developer-tianyiyun/p/19563414",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/developer-tianyiyun/p/19563414\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 11:41\">\n    <span>天翼云全面上线Moltbot，通过云主机、AI云电脑、息壤应用托管一键开启AI助手体验！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p align=\"left\">在人工智能从技术演示走向规模化商业应用的关键时期，一个核心挑战是如何将极客圈层的创新转化为企业级可用的稳健生产力。近期，在海外开发者社区引发现象级关注的开源AI智能体Moltbot（原Clawdbot），展示了个人AI助理的全新可能性。</p>\n<p align=\"left\">近日，天翼云宣布全面上线Moltbot，为用户提供“7×24小时在线的AI助手”助力企业及个人低门槛、高效率地拥抱AI生产力。</p>\n<p align=\"left\">据悉，Moltbot此前在海外已积累超高人气，其在Github星数超6万，收藏数突破7200，搜索指数快速攀升并超越Claude Code，成为硅谷极客圈追捧的焦点工具，被不少开发者称为“能真正做事的AI”。不同于普通聊天机器人，Moltbot以“扎根工作流、主动解难题”为核心定位，可接入Claude、GPT系列等多种主流LLM，集各家技术之长，轻松集成于iMessage、QQ、飞书、钉钉等常用平台，实现随时随地调用。</p>\n<p>在天翼云平台，用户可通过多种方式便捷部署Moltbot，享受企业级的高可用保障与极简操作体验。无需Node.js、Docker知识，也无需操心服务器运维，天翼云提供坚实的算力底座，确保云端服务稳定可靠、算力弹性扩展，实现持续响应，不掉线。支持按需付费模式，用户仅为实际消耗的资源买单，无需预先投入硬件成本，极大降低了使用门槛与资源浪费。</p>\n<p align=\"center\"><img alt=\"\" class=\"lazyload\" />&nbsp;</p>\n<p><strong>配置完成后，用户还可尝试其他场景，解锁更多玩法。</strong>例如<strong>搜索桌面内文件并总结，实现高效办公：</strong>Moltbot可遍历云电脑内相关文件，高效输出包含文件名称、类型、核心摘要、关键数据的结构化总结内容，无需用户再一个个找文件，快速掌握文件核心信息。</p>\n<p align=\"left\">&nbsp;<img alt=\"\" class=\"lazyload\" /></p>\n<p>Moltbot还可以自动打开浏览器访问淘宝、搜索关键词，过滤广告和无货商品，最终输出包含商品名称、售价、店铺、链接的列表，方便用户快速选择，实现智能购物。</p>\n<p align=\"left\">&nbsp;<img alt=\"\" class=\"lazyload\" /></p>\n<p>依托云基础设施的坚实底座，Moltbot全方位赋能办公全场景：7×24小时弹性云主机保障AI助手永不离线，Moltbot天翼AI云电脑将云端AI能力融入工作流，微信、WPS、飞书、钉钉、QQ等常用办公软件一键导入、无缝衔接，零部署零学习，智能办公高效直达，让效率时刻在线。</p>\n<p>随着类似Moltbot等开源项目与云服务的深度结合，以及国内厂商推出更多“本土化、安全可控”的企业级Agent产品，AI正加速转变为各行各业触手可及的新质生产力。天翼云此次集成Moltbot，正是云厂商作为AI应用“助推器”与“稳定器”角色的一次具体实践，为AI智能体的规模化、规范化应用提供了新的范本。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 11:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/developer-tianyiyun\">天翼云开发者社区</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MySQL MGR自动化安装工具，支持单主和多主",
      "link": "https://www.cnblogs.com/liuziyi1/p/19563387",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/liuziyi1/p/19563387\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 11:36\">\n    <span>MySQL MGR自动化安装工具，支持单主和多主</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>这款 MySQL MGR 自动化安装工具专为组复制集群打造，原生支持单主、多主两种核心部署模式，适配 MySQL 8.0 主流稳定版本，兼容 CentOS、Ubuntu 等主流 Linux 发行版。工具实现全流程自动化，一键完成环境前置检测、系统依赖安装、MGR 核心配置初始化、节点组通信验证，无需手动编写复杂配置，规避人工操作失误。同时支持集群快速部署与节点弹性增删，单主模式自带自动选主、故障自动转移能力，多主模式适配多节点读写分散场景，内置配置备份、集群健康检测轻量功能，无额外依赖，大幅降低 MGR 集群部署门槛，提升规模化运维效率，适配各类业务的 MGR 集群搭建与日常管理需求。<br />\n<img alt=\"b98da584-a9cd-413e-87c6-b983a85ebf1f\" class=\"lazyload\" /><br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n需要工具的可以联系我。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-02-02 11:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/liuziyi1\">刘子毅</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "揭开 C#中的异步/等待：隐藏状态机",
      "link": "https://www.cnblogs.com/powertoolsteam/p/19563347",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/powertoolsteam/p/19563347\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 11:28\">\n    <span>揭开 C#中的异步/等待：隐藏状态机</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"引言\">引言</h2>\n<p>作为.NET开发者，我们每天都在使用async和await关键字来编写异步代码。这些关键字让异步代码看起来像同步代码一样直观易读，同时避免了回调地狱的问题。但你是否好奇过，当C#编译器遇到async方法时，底层究竟发生了什么魔法？本文将基于微软官方文档，深入剖析async/await背后的秘密——编译器生成的状态机机制。</p>\n<h2 id=\"正文\">正文</h2>\n<h3 id=\"异步等待解决了什么问题\">异步/等待解决了什么问题？</h3>\n<p>在传统同步I/O操作中（如文件读取或Web API调用），调用线程会被阻塞直到操作完成。这在UI应用中会导致界面冻结，在服务器应用中则造成线程资源的浪费。async/await通过非阻塞的异步操作解决了这些问题，同时保持了代码的线性结构和可读性。</p>\n<h3 id=\"编译器的转换从方法到状态机\">编译器的转换：从方法到状态机</h3>\n<p>当你用async标记一个方法时，C#编译器并不会直接执行你的代码。相反，它会将该方法重写为一个状态机结构体。这个结构体实现了IAsyncStateMachine接口，包含以下关键部分：</p>\n<ul>\n<li>当前状态（整数，表示执行暂停的位置）</li>\n<li>捕获的局部变量和参数（提升为字段以便在await之间保持状态）</li>\n<li>方法构建器（如AsyncTaskMethodBuilder用于Task返回）</li>\n</ul>\n<p>原始方法被转换为一个存根(stub)方法：它在栈上创建状态机实例，初始化并启动它。而你的主要代码逻辑则被移动到状态机的MoveNext()方法中，通过状态值和switch语句实现执行点的跳转。</p>\n<p>特别重要的是：如果异步方法同步完成（所有等待的操作已经完成），状态机将保留在栈上，不会发生堆分配。只有当真正的await暂停执行时，结构体才会被装箱到堆中。</p>\n<h3 id=\"一个简单示例\">一个简单示例</h3>\n<p>考虑以下异步方法：</p>\n<pre><code class=\"language-csharp\">public async Task&lt;int&gt; DownloadDataAsync(string url)\n{\n    using var client = new HttpClient();\n    string data = await client.GetStringAsync(url);\n    return data.Length;\n}\n</code></pre>\n<p>在编译时，编译器会将该方法重写为状态机结构体，并生成一个存根方法替换原始方法签名。方法体被拆分并移入状态机的MoveNext()方法中，按状态组织。</p>\n<p>运行时调用流程：</p>\n<ol>\n<li>生成的存根创建状态机实例（初始在栈上）</li>\n<li>初始化状态机（状态设为-1，捕获必要参数/局部变量）</li>\n<li>调用MoveNext()开始执行</li>\n</ol>\n<p>在MoveNext()内部：</p>\n<ul>\n<li>执行从当前状态开始，直到遇到await</li>\n<li>如果等待的任务已完成，继续同步执行（快速路径，无堆分配）</li>\n<li>如果任务未完成，注册继续回调，立即返回控制（非阻塞），并暂停执行</li>\n<li>任务完成后，继续回调会再次调用MoveNext()，从await点恢复执行</li>\n</ul>\n<h3 id=\"编译器生成的状态机\">编译器生成的状态机</h3>\n<p>以下是编译器生成的状态机简化伪代码（基于Release模式下的反编译结果）：</p>\n<pre><code class=\"language-csharp\">private struct &lt;DownloadDataAsync&gt;d__1 : IAsyncStateMachine\n{\n    public int &lt;&gt;1__state;                      // 状态：-1=开始，0=等待中，-2=完成\n    public AsyncTaskMethodBuilder&lt;int&gt; &lt;&gt;t__builder;\n    public string url;                          // 捕获的参数\n    private string &lt;data&gt;5__2;                  // 提升的局部变量\n    private HttpClient &lt;client&gt;5__3;            // using变量也被提升\n\n    private void MoveNext()\n    {\n        int num = this.&lt;&gt;1__state;\n        try\n        {\n            if (num == -1)                          // 初始执行\n            {\n                this.&lt;client&gt;5__3 = new HttpClient();\n                Task&lt;string&gt; getTask = this.&lt;client&gt;5__3.GetStringAsync(this.url);\n\n                var awaiter = getTask.GetAwaiter();\n                if (!awaiter.IsCompleted)\n                {\n                    this.&lt;&gt;1__state = 0;            // 标记为等待中\n                    this.&lt;&gt;t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);\n                    return;                         // 在此暂停 - 继续回调稍后调用MoveNext\n                }\n\n                // 已完成时的快速路径\n                this.&lt;data&gt;5__2 = awaiter.GetResult();\n            }\n            else                                    // num == 0 → await后恢复\n            {\n                this.&lt;data&gt;5__2 = /* awaiter.GetResult()逻辑 */;\n            }\n\n            // await之后的代码\n            int result = this.&lt;data&gt;5__2.Length;\n\n            // 清理\n            this.&lt;client&gt;5__3?.Dispose();\n\n            // 设置最终结果\n            this.&lt;&gt;1__state = -2;\n            this.&lt;&gt;t__builder.SetResult(result);\n        }\n        catch (Exception exception)\n        {\n            this.&lt;&gt;1__state = -2;\n            this.&lt;&gt;t__builder.SetException(exception);\n        }\n    }\n\n    void IAsyncStateMachine.MoveNext() =&gt; MoveNext();\n    // SetStateMachine(...)为简洁省略\n}\n</code></pre>\n<p>原始方法被转换为类似这样的存根：</p>\n<pre><code class=\"language-csharp\">public Task&lt;int&gt; DownloadDataAsync(string url)\n{\n    var stateMachine = new &lt;DownloadDataAsync&gt;d__1();\n    stateMachine.&lt;&gt;t__builder = AsyncTaskMethodBuilder&lt;int&gt;.Create();\n    stateMachine.url = url;\n    stateMachine.&lt;&gt;1__state = -1;\n    stateMachine.&lt;&gt;t__builder.Start(ref stateMachine);\n    return stateMachine.&lt;&gt;t__builder.Task;\n}\n</code></pre>\n<h3 id=\"理解状态机的重要性\">理解状态机的重要性</h3>\n<p>理解状态机的工作机制有助于我们：</p>\n<ol>\n<li>认识同步完成时的零分配快速路径</li>\n<li>理解为什么局部变量需要被捕获（它们成为结构体的字段以便在暂停和恢复状态时使用）</li>\n<li>掌握正确的性能特征（当操作正确时开销最小）</li>\n</ol>\n<p>正如微软文档所述：\"编译器会把你的程序转化为状态机。该构造会追踪代码中的各种操作和状态，比如当代码达到等待表达式时放弃执行，以及在后台作业完成时恢复执行。\"</p>\n<h2 id=\"结论\">结论</h2>\n<p>async/await不仅仅是让异步代码更简洁的语法糖，其背后是编译器将顺序逻辑转换为高效状态机的复杂过程。通过深入理解这一机制，我们可以：</p>\n<ul>\n<li>编写更高效的异步代码</li>\n<li>避免常见的性能陷阱</li>\n<li>更好地调试异步程序</li>\n</ul>\n<p>下次使用async/await时，请记住：你正在利用C#编译器的强大魔法，将看似简单的顺序代码转换为高效的状态机实现。这种理解将帮助你成为更优秀的.NET开发者。</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <hr />\n<br />\n<p>本文是由葡萄城技术开发团队发布，转载请注明出处：<a href=\"https://www.grapecity.com.cn/\" target=\"_blank\">葡萄城官网</a></p>\n<!--p style=\"font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000\">了解企业级低代码开发平台，请前往<a href=\"https://www.grapecity.com.cn/solutions/huozige\" target=\"_blank\">活字格</a>\n</p><p style=\"font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000\">了解可嵌入您系统的在线 Excel，请前往<a href=\"https://www.grapecity.com.cn/developer/spreadjs\" target=\"_blank\">SpreadJS纯前端表格控件</a></p>\n<p style=\"font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000\">了解嵌入式的商业智能和报表软件，请前往<a href=\"https://www.grapecity.com.cn/solutions/wyn\" target=\"_blank\">Wyn Enterprise\n</a></p-->\n\n<br />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 11:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/powertoolsteam\">葡萄城技术团队</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "在 Cloudflare 平台上构建垂直微前端",
      "link": "https://www.cnblogs.com/didispace/p/19563285",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/didispace/p/19563285\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 11:21\">\n    <span>在 Cloudflare 平台上构建垂直微前端</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>想象一下，你正在开发一个大型Web应用。营销团队想要用Astro构建他们的页面以获得最佳的SEO效果，而产品团队却坚持要用React来构建功能丰富的后台管理系统。更糟糕的是，每次发布新版本时，十几个团队的代码都需要一起打包、一起测试、一起上线——只要其中一个团队引入了一个bug，整个发布就要回滚。这种\"一荣俱荣、一损俱损\"的耦合方式，是不是让你感到无比头疼？</p>\n<p>或者，你的公司刚刚收购了一个创业公司，他们的产品是用Vue写的，而你们的主站是用React写的。你想把他们的功能整合进来，但又不希望把两个完全不同的代码库强行混在一起。</p>\n<p>这些都是现代Web开发中真实存在的难题。传统的微前端架构通常是\"水平\"的——同一个页面上的不同组件来自不同的服务。但如果有一种方式，能让每个团队完全独立地开发、部署和维护自己的功能模块，而用户却感觉在使用一个无缝的、统一的应用呢？</p>\n<p>这就是垂直微前端（Vertical Microfrontends）要解决的问题。现在，Cloudflare推出了一款全新的Worker模板，让这种架构变得前所未有的简单。</p>\n<h2 id=\"什么是垂直微前端\">什么是垂直微前端？</h2>\n<p>垂直微前端是一种架构模式，单个独立团队拥有应用程序功能的完整切片，从用户界面一直到底层的CI/CD流水线。这些切片通过域名上的路径来定义，你可以将各个独立的Worker与特定路径关联起来：</p>\n<pre><code class=\"language-text\">/      = 营销网站\n/docs  = 文档\n/blog  = 博客\n/dash  = 仪表盘\n</code></pre>\n<p>我们还可以进一步细化，在更细粒度的子路径上关联不同的Worker。比如在仪表盘中，你可能通过各种功能或产品来划分URL路径的深度（例如 <code>/dash/product-a</code>），在两个产品之间导航可能意味着两个完全不同的代码库。</p>\n<p>现在有了垂直微前端，我们还可以这样设计：</p>\n<pre><code class=\"language-text\">/dash/product-a  = WorkerA\n/dash/product-b  = WorkerB\n</code></pre>\n<p>上面的每个路径都是独立的前端项目，它们之间没有任何共享代码。<code>product-a</code> 和 <code>product-b</code> 路由映射到分别部署的前端应用，它们有自己的框架、库、CI/CD流水线，由各自的团队定义和拥有。</p>\n<p>你可以端到端地拥有自己的代码。但现在我们需要找到一种方法将这些独立的项目缝合在一起，更重要的是，让它们感觉像是一个统一的体验。</p>\n<p>Cloudflare自己也在经历这个痛点，因为仪表盘有许多独立的团队负责各自的产品。团队必须面对一个事实：在他们控制范围之外所做的更改会影响用户对其产品的体验。</p>\n<p>在内部，我们现在对自己的仪表盘也采用了类似的策略。当用户从核心仪表盘导航到我们的ZeroTrust产品时，实际上它们是两个完全独立的项目，用户只是通过路径 <code>/:accountId/one</code> 被路由到那个项目。</p>\n<h2 id=\"视觉上的统一体验\">视觉上的统一体验</h2>\n<p>将这些独立项目缝合在一起，让它们感觉像一个统一的体验，并没有你想象的那么困难：只需要几行CSS魔法。我们绝对不希望发生的事情是将我们的实现细节和内部决策泄露给用户。如果我们无法让这个用户体验感觉像一个统一的前端，那我们就对用户犯下了严重的错误。</p>\n<p>要实现这种巧妙的手法，让我们先了解一下视图过渡和文档预加载是如何发挥作用的。</p>\n<h3 id=\"视图过渡\">视图过渡</h3>\n<p>当我们想要在两个不同页面之间无缝导航，同时让最终用户感觉流畅时，视图过渡非常有用。在页面上定义特定的DOM元素，让它们一直保留到下一页可见，并定义任何变化的处理方式，这成为了多页应用的强大缝合工具。</p>\n<p>然而，在某些情况下，让各个垂直微前端感觉不同也是完全可以接受的。比如我们的营销网站、文档和仪表盘，它们各自都有独特的定义。用户不会期望这三者在导航时都感觉统一。但是……如果你决定在单个体验中引入垂直切片（例如 <code>/dash/product-a</code> 和 <code>/dash/product-b</code>），那么用户绝对不应该知道它们底层是两个不同的仓库/Worker/项目。</p>\n<p>好了，说得够多了——让我们开始动手吧。我说过让两个独立的项目对用户来说感觉像是一个是低成本的，如果你还没有听说过CSS视图过渡，那么接下来我要让你大开眼界了。</p>\n<p>如果我告诉你，你可以在单页应用（SPA）或多页应用（MPA）的不同视图之间创建动画过渡，让它们感觉像是一个整体？在添加任何视图过渡之前，如果我们导航属于两个不同Worker的页面，中间加载状态会是浏览器中的白色空白屏幕，持续几百毫秒，直到下一页开始渲染。页面不会感觉统一，当然也不会像单页应用。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>如果希望元素保留，而不是看到白色空白页，我们可以通过定义CSS视图过渡来实现。通过下面的代码，我们告诉当前文档页面，当视图过渡事件即将发生时，将<code>nav</code> DOM元素保留在屏幕上，如果现有页面和目标页面之间存在任何外观差异，我们将使用<code>ease-in-out</code>过渡来动画展示。</p>\n<p>突然之间，两个不同的Worker感觉就像一个了。</p>\n<pre><code class=\"language-css\">@supports (view-transition-name: none) {\n  ::view-transition-old(root),\n  ::view-transition-new(root) {\n    animation-duration: 0.3s;\n    animation-timing-function: ease-in-out;\n  }\n  nav { view-transition-name: navigation; }\n}\n</code></pre>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"预加载\">预加载</h3>\n<p>在两个页面之间过渡让它\"看起来\"无缝——我们还希望它\"感觉\"像客户端SPA一样即时。虽然目前Firefox和Safari不支持Speculation Rules，但Chrome/Edge/Opera确实支持这个较新的API。Speculation Rules API旨在提高未来导航的性能，特别是对于文档URL，让多页应用感觉更像单页应用。</p>\n<p>分解成代码，我们需要定义一个特定格式的脚本规则，告诉支持的浏览器如何预取与我们Web应用程序连接的其他垂直切片——可能通过某些共享导航链接。</p>\n<pre><code class=\"language-html\">&lt;script type=\"speculationrules\"&gt;\n  {\n    \"prefetch\": [\n      {\n        \"urls\": [\"https://product-a.com\", \"https://product-b.com\"],\n        \"requires\": [\"anonymous-client-ip-when-cross-origin\"],\n        \"referrer_policy\": \"no-referrer\"\n      }\n    ]\n  }\n&lt;/script&gt;\n</code></pre>\n<p>有了这些，我们的应用程序会预取其他微前端并将它们保留在内存缓存中，所以如果我们导航到那些页面，会感觉几乎是即时的。</p>\n<p>对于明显可区分的垂直切片（营销、文档、仪表盘），你可能不需要这样做，因为用户在它们之间导航时会预期有轻微的加载。然而，当垂直切片定义在特定可见体验内时（例如在仪表盘页面中），强烈建议使用。</p>\n<p>通过视图过渡和推测规则，我们能够将完全不同的代码仓库联系在一起，感觉就像它们来自单页应用一样。如果你问我，这太神奇了。</p>\n<h2 id=\"零配置请求路由\">零配置请求路由</h2>\n<p>现在我们需要一种机制来托管多个应用程序，以及一种在请求流入时将它们缝合在一起的方法。定义一个Cloudflare Worker作为\"路由器\"，允许在边缘的单个逻辑点处理网络请求，然后将它们转发给负责该URL路径的垂直微前端。而且我们可以将单个域名映射到该路由器Worker，其余的就\"正常工作\"了。</p>\n<h3 id=\"服务绑定\">服务绑定</h3>\n<p>如果你还没有探索过Cloudflare Worker服务绑定，那么值得花点时间了解一下。</p>\n<p>服务绑定允许一个Worker调用另一个Worker，而无需经过公开可访问的URL。服务绑定允许Worker A调用Worker B上的方法，或将请求从Worker A转发到Worker。进一步分解，路由器Worker可以调用已定义的每个垂直微前端Worker（例如营销、文档、仪表盘），假设它们都是Cloudflare Workers。</p>\n<p>这为什么重要？这正是将这些垂直切片\"缝合\"在一起的机制。我们将在下一节深入探讨请求路由如何处理流量分割。但要定义这些微前端中的每一个，我们需要更新路由器Worker的wrangler定义，这样它就知道允许调用哪些前端。</p>\n<pre><code class=\"language-json\">{\n  \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n  \"name\": \"router\",\n  \"main\": \"./src/router.js\",\n  \"services\": [\n    {\n      \"binding\": \"HOME\",\n      \"service\": \"worker_marketing\"\n    },\n    {\n      \"binding\": \"DOCS\",\n      \"service\": \"worker_docs\"\n    },\n    {\n      \"binding\": \"DASH\",\n      \"service\": \"worker_dash\"\n    }\n  ]\n}\n</code></pre>\n<p>上面的示例定义在我们的路由器Worker中，然后告诉我们被允许向三个独立的额外Worker（营销、文档和仪表盘）发出请求。授予权限就这么简单，但让我们深入研究一些更复杂的逻辑，包括请求路由和HTML重写网络响应。</p>\n<h3 id=\"请求路由\">请求路由</h3>\n<p>了解了在需要时可以调用的各种其他Worker之后，现在我们需要一些逻辑来确定何时将网络请求定向到哪里。由于路由器Worker被分配到我们的自定义域名，所有传入的请求首先在网络边缘到达它。然后它确定哪个Worker应该处理请求，并管理结果响应。</p>\n<p>第一步是将URL路径映射到关联的Worker。当收到某个请求URL时，我们需要知道它需要被转发到哪里。我们通过定义规则来实现这一点。虽然我们支持通配符路由、动态路径和参数约束，但我们将专注于基础——字面路径前缀——因为它更清楚地说明了要点。</p>\n<p>在这个例子中，我们有三个微前端：</p>\n<pre><code class=\"language-text\">/      = 营销\n/docs  = 文档\n/dash  = 仪表盘\n</code></pre>\n<p>上面的每个路径都需要映射到一个实际的Worker（参见上面章节中的wrangler服务定义）。对于我们的路由器Worker，我们定义一个额外的变量，包含以下数据，这样我们就知道哪些路径应该映射到哪些服务绑定。现在我们知道当请求进来时应该将用户路由到哪里！定义一个名为ROUTES的wrangler变量，内容如下：</p>\n<pre><code class=\"language-json\">{\n  \"routes\": [\n    {\"binding\": \"HOME\", \"path\": \"/\"},\n    {\"binding\": \"DOCS\", \"path\": \"/docs\"},\n    {\"binding\": \"DASH\", \"path\": \"/dash\"}\n  ]\n}\n</code></pre>\n<p>让我们设想一个用户访问我们网站的路径 <code>/docs/installation</code>。在底层，发生的情况是请求首先到达我们的路由器Worker，它负责了解什么URL路径映射到哪个独立的Worker。它理解 <code>/docs</code> 路径前缀映射到我们的 <code>DOCS</code> 服务绑定，参照我们的wrangler文件指向我们的 <code>worker_docs</code> 项目。我们的路由器Worker知道 <code>/docs</code> 被定义为垂直微前端路由，从路径中移除 <code>/docs</code> 前缀，将请求转发给我们的 <code>worker_docs</code> Worker来处理请求，然后最终返回我们得到的任何响应。</p>\n<p>为什么要删除 <code>/docs</code> 路径呢？这是一个实现细节的选择，目的是当Worker通过路由器Worker访问时，它可以清理URL来处理请求，就像它是从路由器Worker外部调用的一样。像任何Cloudflare Worker一样，我们的 <code>worker_docs</code> 服务可能有自己的独立URL可以访问。我们决定希望该服务URL继续独立工作。当它附加到我们的新路由器Worker时，它会自动处理移除前缀，这样服务就可以从自己定义的URL或通过我们的路由器Worker访问……任何地方都可以，无所谓。</p>\n<h3 id=\"htmlrewriter\">HTMLRewriter</h3>\n<p>用URL路径分割我们的各种前端服务（例如 <code>/docs</code> 或 <code>/dash</code>）让我们很容易转发请求，但当我们的响应包含不知道它被通过路径组件反向代理的HTML时……嗯，这就会出问题。</p>\n<p>假设我们的文档网站在响应中有一个图片标签 <code>&lt;img src=\"./logo.png\" /&gt;</code>。如果我们的用户正在访问页面 <code>https://website.com/docs/</code>，那么加载 <code>logo.png</code> 文件可能会失败，因为我们的 <code>/docs</code> 路径只是由我们的路由器Worker人为定义的。</p>\n<p>只有当我们的服务通过路由器Worker访问时，我们才需要对一些绝对路径进行HTML重写，这样我们返回的浏览器响应才能引用有效的资源。实际上发生的是，当请求通过我们的路由器Worker时，我们将请求传递给正确的服务绑定，并从中接收响应。在将其传回客户端之前，我们有机会重写DOM——所以在看到绝对路径的地方，我们继续用代理路径预先填充它。以前我们的HTML返回的图片标签是 <code>&lt;img src=\"./logo.png\" /&gt;</code>，现在我们修改为在返回客户端浏览器之前 <code>&lt;img src=\"./docs/logo.png\" /&gt;</code>。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>让我们回到CSS视图过渡和文档预加载的魔法。我们当然可以把那段代码手动放到我们的项目中并让它工作，但这个路由器Worker也会使用HTMLRewriter自动为我们处理这些逻辑。</p>\n<p>在你的路由器Worker <code>ROUTES</code> 变量中，如果你在根级别设置 <code>smoothTransitions</code> 为 <code>true</code>，那么CSS过渡视图代码会自动添加。此外，如果你在路由中设置 <code>preload</code> 键为 <code>true</code>，那么该路由的推测规则脚本代码也会自动添加。</p>\n<p>下面是两者结合使用的示例：</p>\n<pre><code class=\"language-json\">{\n  \"smoothTransitions\": true,\n  \"routes\": [\n    {\"binding\": \"APP1\", \"path\": \"/app1\", \"preload\": true},\n    {\"binding\": \"APP2\", \"path\": \"/app2\", \"preload\": true}\n  ]\n}\n</code></pre>\n<h2 id=\"开始使用\">开始使用</h2>\n<p>你今天就可以开始使用垂直微前端模板构建了。</p>\n<p>访问Cloudflare仪表盘的链接，或者进入\"Workers &amp; Pages\"并点击\"创建应用程序\"按钮开始。从那里，点击\"选择模板\"然后\"创建微前端\"，你就可以开始配置你的设置了。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>更多使用指南，可以点击<a href=\"https://developers.cloudflare.com/workers/framework-guides/web-apps/microfrontends\" rel=\"noopener nofollow\" target=\"_blank\">查看文档</a> ，如果您对各种云原生架构的内容感兴趣，也可以<a href=\"https://didispace.com\" rel=\"noopener nofollow\" target=\"_blank\">关注我的博客：程序猿DD</a>，第一时间获得干货更新。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 11:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/didispace\">程序猿DD</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI开发-python-langchain框架（1-8-2 缓存机制——验证缓存的效果）",
      "link": "https://www.cnblogs.com/yclh/p/19563034",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yclh/p/19563034\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 10:51\">\n    <span>AI开发-python-langchain框架（1-8-2 缓存机制——验证缓存的效果）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>　　在AI应用中，缓存机制的经济价值不仅节省Token成本，还能消除用户等待焦虑、提升系统吞吐量、保障服务稳定性——这才是企业级应用的真正痛点。<br />　　当用户提出一个常见问题时，首次调用大模型需要经历网络传输、排队等待、模型推理等完整链路，响应时间通常在1至3秒。这个时长已超过人类对“流畅交互”的心理阈值（200毫秒），用户会明显感知到“卡顿”和“等待焦虑”。而启用缓存后，相同问题的后续请求直接从本地数据库读取结果，响应时间骤降至10毫秒以内——这种“无感秒回”的体验，让用户感觉系统始终在线、反应迅捷，极大提升了产品专业度和信任感。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;下面看看这段代码，就能清晰的体现使用缓存后能提升的用户体验。（同一个问题问大模型三次，第一次没有缓存，后两次有缓存）</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">import os\nimport time\nfrom langchain_community.cache import SQLiteCache\nfrom langchain_openai import ChatOpenAI\nfrom langchain.globals import set_llm_cache, get_llm_cache\n\n# ========== 1. 清理旧缓存（确保演示纯净）==========\nCACHE_DB = \"langchain_demo.db\"\nif os.path.exists(CACHE_DB):\n    os.remove(CACHE_DB)\n    print(f\" 已清理旧缓存: {CACHE_DB}\")\n\n# ========== 2. 启用缓存 ==========\nset_llm_cache(SQLiteCache(database_path=CACHE_DB))\nprint(f\" 缓存已启用: {get_llm_cache()}\\n\")\n\n# ========== 3. 配置 LLM ==========\nllm = ChatOpenAI(\n    api_key=os.getenv(\"DEEPSEEK_API_KEY\"),\n    base_url=os.getenv(\"DEEP_URL\"),  # Deepseek 的 API 基础地址\n    model=\"deepseek-v3:671b\",  # Deepseek 对话模型（可选：deepseek-chat-pro 等高级模型）\n    temperature=0.7,  # 温度参数（0-1，越低越稳定）\n    max_tokens=1024  # 最大生成 tokens\n)\n\n\n# ========== 4. 核心演示函数 ==========\ndef demonstrate_cache_effect(query: str, repeat: int = 3):\n    \"\"\"\n    演示缓存效果：首次调用（慢） vs 后续调用（快）\n\n    Args:\n        query: 要提问的问题\n        repeat: 重复调用次数（第1次未缓存，后续应命中缓存）\n    \"\"\"\n    print(\"=\" * 60)\n    print(f\" 测试问题: \\\"{query}\\\"\")\n    print(f\" 将重复调用 {repeat} 次（第1次无缓存，后续应命中缓存）\")\n    print(\"=\" * 60 + \"\\n\")\n\n    durations = []\n\n    for i in range(repeat):\n        print(f\"\\n[第 {i + 1} 次调用]\")\n        start = time.perf_counter()  # 高精度计时\n\n        # 关键：使用完全相同的输入触发缓存\n        response = llm.invoke(query)\n\n        duration = (time.perf_counter() - start) * 1000  # 转为毫秒\n        durations.append(duration)\n\n        # 判断是否命中缓存（通过耗时阈值粗略判断）\n        is_cached = i &gt; 0   # 首次通常 &gt;500ms，缓存通常 &lt;50ms\n\n        if i &gt; 0:\n            print('缓存命中,耗时：'+str(duration))\n        else:\n            print('真实请求,耗时：'+str(duration))\n        print(f\" 回答: {response.content[:60]}...\")\n\n\n\n# ========== 5. 执行演示 ==========\nif __name__ == \"__main__\":\n    # 测试标准问题（确保完全相同的字符串）\n    demonstrate_cache_effect(\"太阳系哪个行星最大？\", repeat=3)\n</pre>\n</div>\n<p>&nbsp;运行结果：</p>\n<p>&nbsp;<br />&nbsp;已清理旧缓存: langchain_demo.db<br />&nbsp;缓存已启用: &lt;langchain_community.cache.SQLiteCache object at 0x000001D668B50410&gt;<br /><br />============================================================<br />&nbsp;测试问题: \"太阳系哪个行星最大？\"<br />&nbsp;将重复调用 3 次（第1次无缓存，后续应命中缓存）<br />============================================================<br /><br /><br />[第 1 次调用]<br />真实请求,耗时：17445.118000000093<br />&nbsp;回答: 太阳系中最大的行星是**木星**。以下是关于木星的一些关键信息：<br /><br />### 木星的基本特征：<br />1. **体积与质量** ...<br /><br />[第 2 次调用]<br />缓存命中,耗时：410.93799999998737<br />&nbsp;回答: 太阳系中最大的行星是**木星**。以下是关于木星的一些关键信息：<br /><br />### 木星的基本特征：<br />1. **体积与质量** ...<br /><br />[第 3 次调用]<br />缓存命中,耗时：1.475199999731558<br />&nbsp;回答: 太阳系中最大的行星是**木星**。以下是关于木星的一些关键信息：<br /><br />### 木星的基本特征：<br />1. **体积与质量** ...<br /><br />&nbsp;<br />结论：从时间消耗上看，缓存命中几何倍数的缩短了用户等待时间，提升了用户的使用体验。</p>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 10:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yclh\">万笑佛</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI部署中间件实战：从CORS到自定义，让你的API更健壮",
      "link": "https://www.cnblogs.com/ymtianyu/p/19562887",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19562887\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 10:32\">\n    <span>FastAPI部署中间件实战：从CORS到自定义，让你的API更健壮</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文深入浅出地讲解了FastAPI中间件的核心概念与实战应用。从解决最常见的CORS跨域问题入手，逐步演示如何编写自定义中间件（如日志记录），并重点剖析了多个中间件的执行顺序这一关键难点。同时，对比了HTTP中间件与ASGI中间件的区别与选用场景，最后分享了作者在实际开发中总结的踩坑经验与最佳实践，帮助你构建更健壮、易维护的Web应用。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><em>本文摘要：你是否为FastAPI应用的跨域请求（CORS）头疼过？或者想给所有请求统一加点“料”却不知从何下手？本文通过实战演示FastAPI中间件的使用，涵盖CORS处理、自定义中间件编写、多个中间件执行顺序等核心内容，帮你构建更安全、高效的Web应用。</em></p>\n<hr />\n<p>你的FastAPI应用在本地跑得风生水起，一部署上线，前端同学就火急火燎地找你：“老大，接口跨域了，报错！” 🚨</p>\n<p>或者，你突然接到需求：<strong style=\"color: rgba(186, 55, 42, 1);\">“所有请求都要记录日志，敏感接口还要额外校验一个自定义Header。”</strong> 难不成要给每个路由都加一遍代码？</p>\n<p>别慌，这就是今天要聊的“中间件”（Middleware）要解决的经典问题。它就像你API的“前厅经理”，所有请求和响应都得先经过它手，验身份、记日志、处理跨域……妥妥的。</p>\n<h2>🎯 一、中间件是啥？咱用“餐厅”打个比方</h2>\n<p>想象一下，你的FastAPI应用是个高级餐厅。</p>\n<div>\n<p>👉 顾客（客户端请求）来到门口。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;- <strong style=\"color: rgba(186, 55, 42, 1);\">迎宾（CORS中间件）</strong>：先看你是不是从允许的街区（域名）来的，不是就直接劝退（返回CORS错误）。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;- <strong style=\"color: rgba(186, 55, 42, 1);\">领位员（日志中间件）</strong>：记下顾客几点来的、几个人。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;- <strong style=\"color: rgba(186, 55, 42, 1);\">安检（认证中间件）</strong>：检查你有没有预约码（Token）。</p>\n<p>👉 之后，顾客才能见到<strong style=\"color: rgba(186, 55, 42, 1);\">真正的厨师（你的路径操作函数）</strong>点菜吃饭（处理业务逻辑）。</p>\n<p>👉 吃完离开时，还得经过<strong style=\"color: rgba(186, 55, 42, 1);\">传菜员（响应处理中间件）</strong>，可能给打包盒贴个标签（添加响应头）。</p>\n</div>\n<p>这一系列站在“核心业务”前后的服务人员，就是中间件。<strong style=\"color: rgba(186, 55, 42, 1);\">它的核心价值在于：全局处理、业务无侵入。</strong></p>\n<p>官方文档讲得比较散，咱们今天就把这块硬骨头啃透，直接上代码。</p>\n<h2>🔧 二、核心：怎么用？从最常用的CORS开始</h2>\n<p>好，咱们先来解决开头的“跨域”问题。这是99%的Web应用都会遇到的。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp = FastAPI()\n\n# 1. 配置允许的源、方法、请求头\norigins = [\n    \"http://localhost:3000\",  # 你的前端开发地址\n    \"https://your-production-site.com\",\n]\n\n# 2. 添加中间件\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,  # 允许的源列表，也可以用 [\"*\"] 放行所有（不安全！）\n    allow_credentials=True, # 允许携带Cookie\n    allow_methods=[\"*\"],    # 允许所有方法 (GET, POST, 等)\n    allow_headers=[\"*\"],    # 允许所有请求头\n)\n\n@app.get(\"/\")\nasync def main():\n    return {\"message\": \"Hello World\"}</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">这里千万别学我当初偷懒，图省事直接上 `allow_origins=[\"*\"]`</strong>，这在生产环境是安全大忌，相当于餐厅大门敞开，谁都能进。线上务必明确指定前端域名！</p>\n<h2>🧪 三、动手：写一个自己的中间件</h2>\n<p>接下来重点来了，自定义中间件。比如，我们要给每个请求记日志，并计算处理耗时。</p>\n<pre class=\"language-python highlighter-hljs\"><code>import time\nfrom fastapi import FastAPI, Request\napp = FastAPI()\n\n@app.middleware(\"http\") # 这是关键装饰器\nasync def log_request_time(request: Request, call_next):\n    # 1. 请求进来时\n    # 这里我们使用 time.perf_counter() 而不是 time.time()，因为它对于这些用例可能更精确\n    start_time = time.perf_counter()\n    path = request.url.path\n    method = request.method\n    print(f\"👉 收到请求: {method} {path}\")\n\n    # 2. 把请求交给下一个处理环节（可能是其他中间件，或者是最终的路由）\n    response = await call_next(request)\n\n    # 3. 响应返回前\n    process_time = time.perf_counter() - start_time\n    response.headers[\"X-Process-Time\"] = str(process_time) # 可以往响应头加东西\n    print(f\"✅ 请求完成: {method} {path}, 耗时: {process_time:.4f}秒\")\n    return response\n\n@app.get(\"/test\")\nasync def test():\n    return {\"message\": \"ok\"}</code></pre>\n<p>访问 <code style=\"color: rgba(186, 55, 42, 1);\">/test</code>，看看控制台，是不是日志和响应头都有了？这就是一个最基础的HTTP中间件。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">划重点：</strong> 中间件函数接收一个 <code style=\"color: rgba(186, 55, 42, 1);\">call_next</code>，它就像接力棒，你必须调用它（<code style=\"color: rgba(186, 55, 42, 1);\">await call_next(request)</code>），请求才能继续往后走。你在它前面和后面写的代码，就分别对应了“请求处理”和“响应处理”两个阶段。</p>\n<h2>🔄 四、灵魂拷问：多个中间件，谁先谁后？</h2>\n<p>你是不是以为加完就完事了？<strong style=\"color: rgba(186, 55, 42, 1);\">多个中间件的执行顺序是超级易错点！</strong></p>\n<p>想象一下，你既加了CORS中间件，又加了上面的日志中间件，还加了一个认证中间件。它们怎么排队？</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">结论：按照添加的<span style=\"text-decoration: underline; font-size: 16px;\">相反顺序</span>执行“请求阶段”，再按照添加的<span style=\"text-decoration: underline; font-size: 16px;\">正序</span>执行“响应阶段”。</strong> 像洋葱一样，一层层进去，再一层层出来。</p>\n<pre class=\"language-python highlighter-hljs\"><code>app = FastAPI()\n\n# 假设我们按顺序添加三个中间件\napp.add_middleware(MiddlewareC) # 第三个添加\napp.add_middleware(MiddlewareB) # 第二个添加\napp.middleware(\"http\")(middleware_a) # 第一个添加（装饰器写法）\n\n# 实际执行顺序（请求阶段）：\n# 1. middleware_a 的请求处理代码\n# 2. MiddlewareB 的请求处理代码\n# 3. MiddlewareC 的请求处理代码\n# --- 到达路由函数 ---\n# 4. MiddlewareC 的响应处理代码\n# 5. MiddlewareB 的响应处理代码\n# 6. middleware_a 的响应处理代码\n# --- 响应返回给客户端 ---</code></pre>\n<p>官方文档虽然说了是“装饰器顺序”，但用 <code style=\"color: rgba(186, 55, 42, 1);\">app.add_middleware()</code> 添加时更容易迷糊。记不住就背下这个口诀：<strong style=\"color: rgba(186, 55, 42, 1);\">“后来居上（请求），原路返回（响应）”。</strong> 设计时，要把依赖关系想清楚，比如认证应该放在靠“里”层（后添加），日志可以放在最“外”层（先添加）。</p>\n<h2>🚀 五、进阶：更底层的ASGI中间件</h2>\n<p>再说个容易翻车的点。上面我们用 <code style=\"color: rgba(186, 55, 42, 1);\">@app.middleware(\"http\")</code> 叫HTTP中间件，是FastAPI封装好的。还有一种更底层、更强大的叫<strong style=\"color: rgba(186, 55, 42, 1);\">ASGI中间件</strong>。</p>\n<p>它和HTTP中间件啥区别？好比一个是高级餐厅的固定流程（HTTP），另一个是后厨的原子操作（ASGI），能处理WebSocket等更多协议。</p>\n<p>怎么用？通常你需要一个第三方库，比如 <code style=\"color: rgba(186, 55, 42, 1);\">starlette-context</code> 来在请求中传递全局数据，或者自己封装（FastAPI在<span style=\"color: rgba(186, 55, 42, 1);\"><code>fastapi.middleware</code></span>中提供了几个中间件，仅仅是为了方便开发者，但大多数可用的中间件直接来自Starlette）：</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nclass CustomHeaderMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request, call_next):\n        response = await call_next(request)\n        response.headers[\"X-Custom-Header\"] = \"MyValue\"\n        return response\n\napp = FastAPI()\napp.add_middleware(CustomHeaderMiddleware) # 这里添加的就是ASGI中间件</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">注意：</strong> <code style=\"color: rgba(186, 55, 42, 1);\">BaseHTTPMiddleware</code> 使用简单，但官方提示可能有轻微性能损耗，因为每个请求都会创建新的类实例。对于超高并发场景，用之前的函数式 <code style=\"color: rgba(186, 55, 42, 1);\">@app.middleware(\"http\")</code> 或直接写纯ASGI中间件是更优解。</p>\n<h2>💎 六、我的踩坑经验与最佳实践</h2>\n<p>最后啰嗦几句，都是实战中总结的血泪教训：</p>\n<div>\n<p>1️⃣ <strong style=\"color: rgba(186, 55, 42, 1);\">响应式中间件要小心：</strong> 如果你想在中间件里读取响应的body，比如做全局响应体格式化，需要先把它读出来（<code style=\"color: rgba(186, 55, 42, 1);\">body = await response.body()</code>），但这会让响应体在内存中多存一份。对于大文件流响应，慎用！</p>\n<p>2️⃣ <strong style=\"color: rgba(186, 55, 42, 1);\">异常处理要覆盖：</strong> 中间件里的 <code style=\"color: rgba(186, 55, 42, 1);\">call_next</code> 可能会抛出异常，记得用 <code style=\"color: rgba(186, 55, 42, 1);\">try...except</code> 包住，并返回一个合理的错误响应，而不是让服务崩掉。</p>\n<p>3️⃣ <strong style=\"color: rgba(186, 55, 42, 1);\">区分中间件和依赖注入：</strong> 像认证这种，每个路由可能要求不同（有的需要登录，有的不需要），用依赖注入（<code style=\"color: rgba(186, 55, 42, 1);\">Depends</code>）更灵活。中间件更适合做<strong style=\"color: rgba(186, 55, 42, 1);\">全局的、无差异的</strong>处理，比如CORS、全局日志、GZip压缩。</p>\n</div>\n<p>工具的选择，好比选螺丝刀，不是最贵的就好，而是<strong style=\"color: rgba(186, 55, 42, 1);\">“合适”</strong>最好。对于大部分业务场景，HTTP中间件+依赖注入的组合，已经能解决99%的问题了。</p>\n<hr />\n<p>好了，关于FastAPI中间件的实战经验，今天就先聊到这。中间件就像你应用的“基础设施”，搭建好了，后面写业务代码才能安心、省心。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">老规矩，代码片段都跑过，放心参考。</strong> 如果你在配置中间件时还遇到了其他妖魔鬼怪，欢迎留言，咱们一起降妖除魔。</p>\n<p>觉得有用的话，<strong style=\"color: rgba(186, 55, 42, 1);\">点赞、收藏、关注</strong>三连一下呗？你的支持是我熬夜写干货的最大动力。下期咱们可以聊聊FastAPI的依赖注入怎么玩出花，或者部署上线的那些坑。回见！👩💻</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 10:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">一名程序媛呀</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}