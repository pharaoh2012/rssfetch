{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "P5607 [Ynoi2013] 无力回天 NOI2017 题解",
      "link": "https://www.cnblogs.com/WangNoNo/p/19423598",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/WangNoNo/p/19423598\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 23:05\">\n    <span>P5607 [Ynoi2013] 无力回天 NOI2017 题解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>一道很好的题，如果做法不当（像我）可能需要一些卡常。</p>\n<h2 id=\"part-1-bitset-20tps\">Part 1. bitset 20tps</h2>\n<p>插入？并集？ <span class=\"math inline\">\\(1e5\\)</span> ？显然可以用 <span class=\"math inline\">\\(bitset\\)</span> 维护：</p>\n<ul>\n<li>每次修改把第 <span class=\"math inline\">\\(x\\)</span> 个 <span class=\"math inline\">\\(bitset\\)</span> 中的第 <span class=\"math inline\">\\(y\\)</span> 位修改成1</li>\n<li>每次查询将 <span class=\"math inline\">\\(x1\\)</span> 和 <span class=\"math inline\">\\(x2\\)</span> 两个 <span class=\"math inline\">\\(bitset\\)</span> 取或求1的个数即可</li>\n</ul>\n<p>这样可以轻松获得20tps。</p>\n<h3 id=\"code\">Code</h3>\n<pre><code class=\"language-cpp\">const int N = 1e5 + 5;\n\nint m;\nbitset&lt;N&gt; b[N];\nvoid solve(){\n\tcin &gt;&gt; m;\n\twhile(m--){\n\t\tll opt, x, y; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;\n\t\tif(opt == 1){\n\t\t\tb[x][y] = 1;\n\t\t}else{\n\t\t\tcout &lt;&lt; (b[x] | b[y]).count() &lt;&lt; \"\\n\";\n\t\t}\n\t}\n}\n</code></pre>\n<h2 id=\"part-2-哈希表-34tps\">Part 2. 哈希表 34tps</h2>\n<p>考虑其实只需要维护两两之间的答案，最多 <span class=\"math inline\">\\(m\\)</span> 组</p>\n<ul>\n<li>每次修改把所有修改过 <span class=\"math inline\">\\(y\\)</span> 的和当前的集合间的交集大小加1，并记录每个集合的大小</li>\n<li>每次查询将两个集合相加减去并集即可</li>\n</ul>\n<p>这样可以轻松获得34tps。（注：pb_ds哈希表使用方法在最后）</p>\n<h3 id=\"code-1\">Code</h3>\n<pre><code class=\"language-cpp\">const int N = 1e6 + 5;\n\nint m, maxn, siz[N];\ncc_hash_table&lt;int, int&gt; ans[N];\nvector&lt;int&gt; vc[N];\n\nvoid solve(){\n\tcin &gt;&gt; m;\n    for(int i = 1; i &lt;= m; i++){\n        int opt, x, y; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;\n        if(opt == 1){\n        \t++siz[x];\n        \tint x0, x1;\n            for(int num : vc[y]){\n            \tx0 = x, x1 = num;\n\t\t\t\tif(x0 &gt; x1) swap(x0, x1);\n\t\t\t\t++ans[x0][x1];\n\t\t\t}\n            vc[y].pb(x);\n        }\n        else{\n            if(x == y){\n            \tcout &lt;&lt; siz[x] &lt;&lt; \"\\n\";\n            \tcontinue;\n\t\t\t}\n            if(x &gt; y) swap(x, y);\n\t\t\tint ans1 = ans[x][y];\n\t\t\tcout &lt;&lt; siz[x] + siz[y] - ans1&lt;&lt; \"\\n\";\n        }\n    }\n}\n</code></pre>\n<h2 id=\"part-3-正解-100tps\">Part 3. 正解 100tps</h2>\n<p>我们思考，</p>\n<ul>\n<li><span class=\"math inline\">\\(bitset\\)</span> 的优势在于高效处理多次出现，缺点是空间开不下</li>\n<li>哈希表的优势在于空间小，缺点是多次出现时会TLE</li>\n</ul>\n<p>怎么办呢？考虑结合以上两种做法，对于多次出现交给 <span class=\"math inline\">\\(bitset\\)</span> 处理，其他数据由空间小的哈希表处理。</p>\n<p>具体的，考虑进行根号分治，设临界值为 <span class=\"math inline\">\\(B\\)</span> ，记 <span class=\"math inline\">\\(x\\)</span> 的出现次数为 <span class=\"math inline\">\\(cnt_x\\)</span> ，对于每个数 <span class=\"math inline\">\\(x\\)</span>：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(cnt_x&lt;B\\)</span> ，用哈希表处理</li>\n<li>若 <span class=\"math inline\">\\(cnt_x&gt;B\\)</span> ，用 <span class=\"math inline\">\\(bitset\\)</span> 处理</li>\n</ul>\n<p>考虑到 <span class=\"math inline\">\\(bitset\\)</span> 的复杂度，当 <span class=\"math inline\">\\(B=\\sqrt{m/w}\\)</span>时达到理论最优值</p>\n<p>直接写完你就会发现MLE，怎么办？只需要改成<s>出生</s>可可爱爱の指针就可以了！</p>\n<h3 id=\"code-2\">Code</h3>\n<pre><code class=\"language-cpp\">const int N = 1e6 + 5, B = 8192, B1 = N / B;\n\nint m, maxn, siz[N];\nstruct node{\n    int opt, x, y;\n} q[N];\nbitset&lt;B&gt; *b[N];\ncc_hash_table&lt;int, int&gt; *ans[N];\nvector&lt;int&gt; vc[N];\nint cnt[N], f[N], tot;\n\nvoid init(){\n\tcin &gt;&gt; m;\n    for(int i = 1; i &lt;= m; i++){\n        cin &gt;&gt; q[i].opt &gt;&gt; q[i].x &gt;&gt; q[i].y;\n        if(q[i].opt == 1) ++cnt[q[i].y];\n        else if(q[i].x &gt; q[i].y) swap(q[i].x, q[i].y);\n    }\n    for(int i = 1; i &lt;= m; i++) if(cnt[i] &gt; B1) f[i] = ++tot; maxn = tot;\n    for(int i = 1; i &lt;= m; i++) if(cnt[i] &lt;= B1) f[i] = ++tot;\n    for(int i = 1; i &lt;= m; i++) if(q[i].opt == 1) q[i].y = f[q[i].y];\n    for(int i = 1; i &lt;= m; i++) if(q[i].opt == 2){\n    \tif(!ans[q[i].x]) ans[q[i].x] = new cc_hash_table&lt;int, int&gt;();\n        (*ans[q[i].x])[q[i].y] = 0;\n\t}\n}\nvoid solve(){\n    for(int i = 1; i &lt;= m; i++){\n        if(q[i].opt == 1){\n        \t++siz[q[i].x];\n            if(q[i].y &lt;= maxn){\n            \tif(!b[q[i].x]) b[q[i].x] = new bitset&lt;B&gt;();\n            \t(*b[q[i].x])[q[i].y] = 1;\n\t\t\t}\n            else{\n            \tint x0, x1;\n            \tif(vc[q[i].y].size() != 0){\n\t                for(int num : vc[q[i].y]){\n\t                \tx0 = q[i].x, x1 = num;\n\t\t\t\t\t\tif(x0 &gt; x1) swap(x0, x1);\n\t\t\t\t\t\tif(!ans[x0]) continue;\n\t\t\t\t\t\tif(ans[x0] -&gt; find(x1) != ans[x0] -&gt; end()) ++(*ans[x0])[x1];\n\t                }\n\t\t\t\t}\n                vc[q[i].y].pb(q[i].x);\n            }\n        }else{\n            if(q[i].x == q[i].y){\n            \tcout &lt;&lt; siz[q[i].x] &lt;&lt; \"\\n\";\n            \tcontinue;\n\t\t\t}\n\t\t\tint ans1 = (*ans[q[i].x])[q[i].y], ans2 = 0;\n\t\t\tif(b[q[i].x] &amp;&amp; b[q[i].y]) ans2 = (*b[q[i].x] &amp; *b[q[i].y]).count();\n\t\t\tcout &lt;&lt; siz[q[i].x] + siz[q[i].y] - ans1 - ans2 &lt;&lt; \"\\n\";\n        }\n    }\n}\n</code></pre>\n<h2 id=\"part-4-补充\">Part 4. 补充</h2>\n<p>pb_ds使用须知：</p>\n<p>请使用以下头文件</p>\n<pre><code class=\"language-cpp\">#include&lt;ext/pb_ds/assoc_container.hpp&gt;\n#include&lt;ext/pb_ds/priority_queue.hpp&gt;\n#include&lt;ext/pb_ds/exception.hpp&gt;\n#include&lt;ext/pb_ds/hash_policy.hpp&gt;\n#include&lt;ext/pb_ds/list_update_policy.hpp&gt;\n#include&lt;ext/pb_ds/tree_policy.hpp&gt;\n#include&lt;ext/pb_ds/trie_policy.hpp&gt;\nusing namespace __gnu_pbds;\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 23:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/WangNoNo\">WangNoNo</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Claude Skills MCP 技术解析",
      "link": "https://www.cnblogs.com/smartloli/p/19423547",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/smartloli/p/19423547\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 22:48\">\n    <span>Claude Skills MCP 技术解析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>1.概述</h1>\n<p>如果说大模型的推理能力决定了“它有多聪明”，那么 MCP 决定了它到底能不能在真实世界里把事做完。这篇文章不是简单介绍一个新名词，而是试图回答一个很多工程师心里都在问的问题：<strong>Claude 的 Skills 和 MCP，到底解决了什么？为什么它看起来比传统的 Tool / Function Calling 更“重”？</strong></p>\n<h1><strong>2.内容</strong></h1>\n<h2><strong>2.1&nbsp;从一个真实问题说起</strong></h2>\n<p>先说一个很常见的场景。你让一个大模型帮你做一件事：</p>\n<div class=\"cnblogs_code\">\n<pre>“帮我查一下这个用户的资料、最近 <span style=\"color: rgba(128, 0, 128, 1);\">30</span> 天的订单，然后给出运营建议。”</pre>\n</div>\n<p>如果你做过相关系统，第一反应一定是：</p>\n<ul>\n<li>要查用户表</li>\n<li>要查订单表</li>\n<li>要聚合数据</li>\n<li>要分析结果</li>\n</ul>\n<p>而传统 LLM 的做法往往是：</p>\n<ul>\n<li>用 Prompt 告诉模型“假装你查了数据库”</li>\n<li>或者用 Function Calling 勉强调用一两个接口</li>\n<li>或者在外部代码里硬写流程</li>\n</ul>\n<p>问题是，这些方式都存在明显短板：</p>\n<ul>\n<li>Prompt 是假能力</li>\n<li>Function Calling 是半自动</li>\n<li>外部流程是模型被动执行</li>\n</ul>\n<p>Claude 的 Skill + MCP，试图从底层解决这个问题。</p>\n<h2>2.2&nbsp;什么是 Claude Skills？先把误解说清楚</h2>\n<p>很多人第一次听到 Skill，会下意识理解为：</p>\n<div class=\"cnblogs_code\">\n<pre>“哦，就是 Tool。”</pre>\n</div>\n<p>但实际上 Claude Skills 和传统 Tool 并不是一个层级的东西。</p>\n<p><strong>1.直观理解一下</strong></p>\n<ul>\n<li>Tool：“这是一个函数，你可以调用。”</li>\n<li>Skills：“这是一个你被允许使用的能力边界，我已经帮你定义好了输入、输出和规则。”</li>\n</ul>\n<p><strong>2.Skill 更像什么？</strong></p>\n<ul>\n<li><strong>像一个系统 API + 类型系统 + 权限边界的组合体</strong></li>\n</ul>\n<p><strong>3.一个 Skill 至少包含什么？</strong></p>\n<p>一个完整的 Claude Skill，通常包含：</p>\n<ul>\n<li>能力名称（Name）</li>\n<li>能力描述（给模型看的）</li>\n<li>输入参数结构（JSON Schema）</li>\n<li>输出结果结构（JSON Schema）</li>\n<li>实际执行逻辑（运行在 Skill Server 中）</li>\n</ul>\n<p>也就是说，Skill 本身是“声明式”的，模型并不关心你是 Python、Java 还是 Rust 实现的。</p>\n<h2>2.3&nbsp;MCP（Model Context Protocol）到底是什么？</h2>\n<p>先给一个不那么官方的定义：</p>\n<div class=\"cnblogs_code\">\n<pre>MCP 是一套让大模型“安全、可控地使用外部能力，并把结果纳入推理过程”的协议。</pre>\n</div>\n<p>注意关键词不是“调用”，而是：</p>\n<ul>\n<li>安全</li>\n<li>可控</li>\n<li>纳入推理</li>\n</ul>\n<p>这三点，恰恰是很多 Tool 方案做不到的。</p>\n<p><strong>1.MCP 解决的核心不是“怎么调函数”</strong></p>\n<p>而是这几个问题：</p>\n<ul>\n<li>模型怎么知道有哪些能力可以用？</li>\n<li>模型怎么理解这些能力能干嘛？</li>\n<li>模型怎么保证参数不会乱传？</li>\n<li>执行结果怎么回到上下文继续推理？</li>\n<li>整个过程怎么被人类治理？</li>\n</ul>\n<p>MCP 是在解决“<strong>模型与现实系统之间的协议问题</strong>”。</p>\n<h2>2.4&nbsp;整体架构：Claude 是大脑，MCP 是神经系统</h2>\n<p>先看一张整体结构图：</p>\n<p><img alt=\"image\" height=\"826\" src=\"https://img2024.cnblogs.com/blog/666745/202512/666745-20251230222618784-1569725605.png\" width=\"1196\" /></p>\n<p>&nbsp;关键点在这里：</p>\n<ul>\n<li>Claude 不直接接触数据库</li>\n<li>Claude 不直接发 HTTP 请求</li>\n<li>Claude 只和 MCP “说话”</li>\n</ul>\n<p>&nbsp;这就像：<strong>大脑不会直接控制肌肉纤维，而是通过神经系统发信号。</strong></p>\n<h2><strong>2.5&nbsp;一次完整的 MCP 调用流程</strong></h2>\n<p>我们把一次完整调用拆开来看。</p>\n<h3><strong>1.场景</strong></h3>\n<p><strong>用户说：</strong></p>\n<div class=\"cnblogs_code\">\n<pre>“帮我查一下 test@example.com 这个用户的信息。”</pre>\n</div>\n<p><strong>1️⃣ Claude 先做什么？</strong></p>\n<p>Claude 首先做的是 语义判断：</p>\n<ul>\n<li>这是一个“查用户”的请求</li>\n<li>当前上下文里有没有能完成这件事的 Skill？</li>\n<li>如果 MCP Client 注册过类似：</li>\n</ul>\n<div class=\"cnblogs_code\">\n<pre>get_user_by_email</pre>\n</div>\n<p>Claude 就会继续。</p>\n<p><strong>2️⃣ Claude 生成 MCP 调用（结构化）</strong></p>\n<p>不是自然语言，而是类似这样的结构化请求：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">{\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">tool</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">get_user_by_email</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">arguments</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">: {\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">email</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">test@example.com</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n  }\n}</span></pre>\n</div>\n<p>这一步非常重要：<strong>模型已经从“生成文本”切换成“生成结构化意图”。</strong></p>\n<p><strong>3️⃣ MCP Client 做校验</strong></p>\n<p>MCP Client 会检查：</p>\n<ul>\n<li>Skill 是否存在</li>\n<li>参数是否符合 Schema</li>\n<li>是否有权限调用</li>\n</ul>\n<p>不通过，直接拦截。</p>\n<p><strong>4️⃣ Skill Server 执行真实逻辑</strong></p>\n<p>比如：</p>\n<ul>\n<li>查数据库</li>\n<li>调内部 API</li>\n<li>读取文件</li>\n</ul>\n<p><strong>5️⃣ 返回结构化结果</strong></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">{\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">u_123</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">name</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">email</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">test@example.com</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n  </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">level</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">VIP</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n}</span></pre>\n</div>\n<p><strong>6️⃣ Claude 把结果“吃”回上下文</strong></p>\n<p>注意这里不是“展示给用户”，而是：<strong>作为新上下文继续推理</strong>。Claude 可能会接着分析、对比、总结，最后才生成自然语言回复。</p>\n<h2>2.6&nbsp;一个最小可运行的 MCP Skill 示例</h2>\n<p>下面这个示例非常简单，但已经具备 MCP 的完整形态。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">from mcp.server import Server\n\nserver </span>= Server(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">user_service</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n\n@server.tool()\ndef get_user_by_email(email: str) </span>-&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> dict:\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span><span style=\"color: rgba(0, 0, 0, 1);\">    Query user information by email\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"\n</span>    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> email == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">test@example.com</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        return {\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">id</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">u_123</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">name</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Alice</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">email</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">: email,\n            </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">level</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>: <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">VIP</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n        }\n    return {}\n\nserver.run()</span></pre>\n</div>\n<p>你会发现：</p>\n<ul>\n<li>没有 prompt</li>\n<li>没有 AI 逻辑</li>\n<li>只是纯能力定义</li>\n</ul>\n<p>但 Claude 会自动理解：</p>\n<ul>\n<li>什么时候用它</li>\n<li>怎么用</li>\n<li>用完之后怎么继续思考</li>\n</ul>\n<h2>2.7&nbsp;为什么 MCP 对 Agent 特别重要？</h2>\n<p>如果你做过 Agent，一定踩过这些坑：</p>\n<ul>\n<li>流程写死</li>\n<li>状态难维护</li>\n<li>一步失败全盘崩</li>\n<li>能力越多越混乱</li>\n</ul>\n<p>MCP 的好处在于：</p>\n<ul>\n<li>Agent 不需要提前写死流程，模型可以动态规划。</li>\n</ul>\n<p><strong>一个典型 Agent 行为</strong>：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">用户需求：\n\n“帮我分析这个用户最近的消费情况，并给出建议。”</span></pre>\n</div>\n<p>Claude 可能会：</p>\n<ul>\n<li>调用 get_user_profile</li>\n<li>调用 search_orders</li>\n<li>汇总数据</li>\n<li>给出分析和建议</li>\n<li>你不需要写 if/else 流程。</li>\n</ul>\n<h2>2.8&nbsp;MCP 和 Function Calling 的本质区别</h2>\n<p>很多人会问：</p>\n<ul>\n<li>“这和 OpenAI 的 Function Calling 有什么区别？”</li>\n</ul>\n<p>简单说一句：</p>\n<ul>\n<li>Function Calling 是能力点，MCP 是能力体系。</li>\n</ul>\n<p><img alt=\"image\" height=\"751\" src=\"https://img2024.cnblogs.com/blog/666745/202512/666745-20251230224051152-69932232.png\" width=\"1378\" /></p>\n<h2>2.9&nbsp;在真实工程中如何用好 MCP？</h2>\n<p>一些经验之谈：</p>\n<p><strong>Skill 设计建议</strong></p>\n<ul>\n<li>一个 Skill 只做一件事</li>\n<li>输入输出一定要稳定</li>\n<li>不要返回自然语言</li>\n<li>错误也要结构化</li>\n</ul>\n<p><strong>不要做的事情</strong></p>\n<ul>\n<li>把业务逻辑写进 Prompt</li>\n<li>一个 Skill 干五六件事</li>\n<li>让模型自己拼 SQL</li>\n<li>让 Skill 返回“分析结论”</li>\n</ul>\n<h2>2.10&nbsp;我对 MCP 的一个判断</h2>\n<p>站在工程视角，我认为：</p>\n<ul>\n<li>MCP 是目前最接近“大模型操作系统接口”的设计之一。</li>\n</ul>\n<p>它做的不是让模型“更聪明”，而是让模型：</p>\n<ul>\n<li>更可靠</li>\n<li>更可控</li>\n<li>更像一个真正能落地的系统组件</li>\n</ul>\n<h1>3.总结</h1>\n<p>如果你只是做 Demo，MCP 可能显得有点“重”。</p>\n<p>但如果你在做的是：</p>\n<ul>\n<li>企业级 AI 助手</li>\n<li>AI 编程系统</li>\n<li>多 Agent 自动化平台</li>\n</ul>\n<p>那 MCP 不是“可选项”，而是迟早要走到的那一步。</p>\n<h1 class=\"ds-markdown-paragraph\">4.结束语</h1>\n<p>这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！</p>\n<p>另外，博主出新书了《<span style=\"color: rgba(255, 0, 0, 1);\"><strong><a href=\"https://item.jd.com/14421833.html\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(255, 0, 0, 1);\">Hadoop与Spark大数据全景解析</span></a></strong></span>》、同时已出版的《<strong><span style=\"color: rgba(0, 0, 255, 1);\"><a href=\"https://item.jd.com/14699434.html\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">深入理解Hive</span></a></span></strong>》、《<span style=\"color: rgba(0, 0, 255, 1);\"><strong><a href=\"https://item.jd.com/12455361.html\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">Kafka并不难学</span></a></strong></span>》和《<span style=\"color: rgba(0, 0, 255, 1);\"><strong><a href=\"https://item.jd.com/12371763.html\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">Hadoop大数据挖掘从入门到进阶实战</span></a></strong></span>》也可以和新书配套使用，喜欢的朋友或同学， 可以<span style=\"color: rgba(255, 0, 0, 1);\"><strong>在公告栏那里点击购买链接购买博主的书</strong></span>进行学习，在此感谢大家的支持。关注下面公众号，根据提示，可免费获取书籍的教学视频。</p>\n</div>\n<div id=\"MySignature\">\n    <div>\n<b class=\"b1\"></b><b class=\"b2 d1\"></b><b class=\"b3 d1\"></b><b class=\"b4 d1\"></b>\n<div class=\"b d1 k\">  \n联系方式：\n<br />\n邮箱：smartloli.org@gmail.com\n<br />\n<strong style=\"color: green;\">QQ群（Hive与AI实战【新群】）：935396818</strong>\n<br />\nQQ群（Hadoop - 交流社区1）：424769183\n<br />\nQQ群（Kafka并不难学）：825943084\n<br />\n温馨提示：请大家加群的时候写上加群理由（姓名＋公司/学校），方便管理员审核，谢谢！\n<br />\n<h3>热爱生活，享受编程，与君共勉！</h3>  \n</div>\n<b class=\"b4b d1\"></b><b class=\"b3b d1\"></b><b class=\"b2b d1\"></b><b class=\"b1b\"></b>\n</div>\n<br />\n<div>\n<b class=\"b1\"></b><b class=\"b2 d1\"></b><b class=\"b3 d1\"></b><b class=\"b4 d1\"></b>\n<div class=\"b d1 k\">\n<h3>公众号：</h3>\n<h3><img src=\"https://www.cnblogs.com/images/cnblogs_com/smartloli/1324636/t_qr.png\" style=\"width: 8%; margin-left: 10px;\" /></h3>\n</div>\n<b class=\"b4b d1\"></b><b class=\"b3b d1\"></b><b class=\"b2b d1\"></b><b class=\"b1b\"></b>\n</div>\n<br />\n<div>\n<b class=\"b1\"></b><b class=\"b2 d1\"></b><b class=\"b3 d1\"></b><b class=\"b4 d1\"></b>\n<div class=\"b d1 k\">\n<h3>作者：哥不是小萝莉 ［<a href=\"http://www.kafka-eagle.org/\" style=\"color: green;\" target=\"_blank\">关于我</a>］［<a href=\"http://www.cnblogs.com/smartloli/p/4241701.html\" style=\"color: green;\" target=\"_blank\">犒赏</a>］</h3>\n<h3>出处：<a href=\"http://www.cnblogs.com/smartloli/\" style=\"color: green;\" target=\"_blank\">http://www.cnblogs.com/smartloli/</a></h3>\n<h3>转载请注明出处，谢谢合作！</h3>\n</div>\n<b class=\"b4b d1\"></b><b class=\"b3b d1\"></b><b class=\"b2b d1\"></b><b class=\"b1b\"></b>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 22:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/smartloli\">哥不是小萝莉</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Flink源码阅读：Checkpoint机制（下）",
      "link": "https://www.cnblogs.com/Jackeyzhe/p/19423123",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Jackeyzhe/p/19423123\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 20:13\">\n    <span>Flink源码阅读：Checkpoint机制（下）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Flink源码阅读：Checkpoint机制（下）\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1828322/202512/1828322-20251230201244606-898036727.png\" />\n        书接上回，前文我们梳理的 Checkpoint 机制的源码，但是对于如何写入状态数据并没有深入了解。今天就一起来梳理一下这部分代码。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>书接上回，前文我们梳理的 Checkpoint 机制的源码，但是对于如何写入状态数据并没有深入了解。今天就一起来梳理一下这部分代码。</p>\n<h3 id=\"写在前面\">写在前面</h3>\n<p>前面我们了解到在 <code>StreamOperatorStateHandler.snapshotState</code> 方法中会创建四个 Future，用来支持不同类型的状态写入。</p>\n<pre><code class=\"language-java\">snapshotInProgress.setKeyedStateRawFuture(snapshotContext.getKeyedStateStreamFuture());\nsnapshotInProgress.setOperatorStateRawFuture(\n        snapshotContext.getOperatorStateStreamFuture());\n\nif (null != operatorStateBackend) {\n    snapshotInProgress.setOperatorStateManagedFuture(\n            operatorStateBackend.snapshot(\n                    checkpointId, timestamp, factory, checkpointOptions));\n}\n\nif (useAsyncState &amp;&amp; null != asyncKeyedStateBackend) {\n    if (isCanonicalSavepoint(checkpointOptions.getCheckpointType())) {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    } else {\n        snapshotInProgress.setKeyedStateManagedFuture(\n                asyncKeyedStateBackend.snapshot(\n                        checkpointId, timestamp, factory, checkpointOptions));\n    }\n}\n</code></pre>\n<p>我们主要关心 ManagedState，ManagedState 都是调用 <code>Snapshotable.snapshot</code> 方法来写入数据的，下面具体看 KeyedState 和 OperatorState 的具体实现。</p>\n<h3 id=\"keyedstate\">KeyedState</h3>\n<p>KeyedState 我们以 HeapKeyedStateBackend 为例，这里先是创建了一个 <code>SnapshotStrategyRunner</code> 实例，SnapshotStrategyRunner 是一个快照策略的一个执行类，创建完成后就会调用 snapshot 方法。在这个 snapshot 方法中主要做了做了下面几件事：</p>\n<ol>\n<li>\n<p>同步拷贝状态数据的引用。</p>\n</li>\n<li>\n<p>创建 Checkpoint 输出流 <code>CheckpointStateOutputStream</code></p>\n</li>\n<li>\n<p>完成 Checkpoint 持久化</p>\n</li>\n<li>\n<p>返回元信息结果</p>\n</li>\n</ol>\n<h4 id=\"状态数据引用拷贝\">状态数据引用拷贝</h4>\n<p>在 HeapSnapshotStrategy 的 syncPrepareResources 方法中调用了 <code>HeapSnapshotResources.create</code> 方法。这里有一个比较重要的参数是 registeredKVStates，它代表我们在业务代码中注册的状态数据表。</p>\n<pre><code class=\"language-java\">ValueStateDescriptor&lt;Tuple2&lt;Long, Long&gt;&gt; descriptor =\n        new ValueStateDescriptor&lt;&gt;(\n                \"average\",\n                TypeInformation.of(new TypeHint&lt;Tuple2&lt;Long, Long&gt;&gt;() {}));\n</code></pre>\n<p>例如我们这样注册状态数据表，那么 registeredKVStates 的 key 就是 average，value 就是状态表，它通常是一个 CopyOnWriteStateTable。具体的状态数据引用拷贝的逻辑在 <code>processSnapshotMetaInfoForAllStates</code> 方法中。</p>\n<pre><code class=\"language-java\">private static void processSnapshotMetaInfoForAllStates(\n        List&lt;StateMetaInfoSnapshot&gt; metaInfoSnapshots,\n        Map&lt;StateUID, StateSnapshot&gt; cowStateStableSnapshots,\n        Map&lt;StateUID, Integer&gt; stateNamesToId,\n        Map&lt;String, ? extends StateSnapshotRestore&gt; registeredStates,\n        StateMetaInfoSnapshot.BackendStateType stateType) {\n\n    for (Map.Entry&lt;String, ? extends StateSnapshotRestore&gt; kvState :\n            registeredStates.entrySet()) {\n        final StateUID stateUid = StateUID.of(kvState.getKey(), stateType);\n        stateNamesToId.put(stateUid, stateNamesToId.size());\n        StateSnapshotRestore state = kvState.getValue();\n        if (null != state) {\n            final StateSnapshot stateSnapshot = state.stateSnapshot();\n            metaInfoSnapshots.add(stateSnapshot.getMetaInfoSnapshot());\n            cowStateStableSnapshots.put(stateUid, stateSnapshot);\n        }\n    }\n}\n</code></pre>\n<p>针对每个 State，这里都创建一个 CopyOnWriteStateTableSnapshot，然后存在 cowStateStableSnapshots 里。这里 CopyOnWriteStateTableSnapshot 就是拷贝数据的引用，因此可以同步执行。</p>\n<h4 id=\"创建-checkpointstateoutputstream\">创建 CheckpointStateOutputStream</h4>\n<p>创建 CheckpointStateOutputStream 的方法是 <code>CheckpointStreamWithResultProvider.createSimpleStream</code>，生产环境通常使用的是 FsCheckpointStateOutputStream。FsCheckpointStateOutputStream 中的参数如下：</p>\n<pre><code class=\"language-java\">// 状态数据写入缓冲数组，数据先写到内存中，然后 flush 到磁盘\nprivate final byte[] writeBuffer;\n\n// 缓冲数组当前写入位置\nprivate int pos;\n\n// 文件输出流\nprivate volatile FSDataOutputStream outStream;\n\n// 内存中状态大小阈值，超过阈值会 flush 到磁盘，默认20KB，最大1MB\n// 目的是为了减少小文件数量\nprivate final int localStateThreshold;\n\n// checkpoint 基础路径\nprivate final Path basePath;\n\n// Flink 自己封装的文件系统\nprivate final FileSystem fs;\n\n// 状态数据完整路径\nprivate volatile Path statePath;\n\n// 相对路径\nprivate String relativeStatePath;\n\n// 是否已关闭\nprivate volatile boolean closed;\n\n// 是否允许使用相对路径\nprivate final boolean allowRelativePaths;\n</code></pre>\n<h4 id=\"checkpoint-持久化\">Checkpoint 持久化</h4>\n<p>创建完 CheckpointStateOutputStream 之后，会调用 <code>serializationProxy.write(outView)</code> 写入状态的元数据。元数据包括状态的名称、类型、序列化器等一些配置。</p>\n<p>元数据写完之后，就开始分组写入状态数据。在写入时，先写 keyGroupId，然后再写当前分组的状态数据</p>\n<pre><code class=\"language-java\">for (int keyGroupPos = 0;\n        keyGroupPos &lt; keyGroupRange.getNumberOfKeyGroups();\n        ++keyGroupPos) {\n    int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos);\n    keyGroupRangeOffsets[keyGroupPos] = localStream.getPos();\n    // 写 keyGroupId\n    outView.writeInt(keyGroupId);\n\n    for (Map.Entry&lt;StateUID, StateSnapshot&gt; stateSnapshot :\n            cowStateStableSnapshots.entrySet()) {\n        StateSnapshot.StateKeyGroupWriter partitionedSnapshot =\n                stateSnapshot.getValue().getKeyGroupWriter();\n        try (OutputStream kgCompressionOut =\n                keyGroupCompressionDecorator.decorateWithCompression(localStream)) {\n            DataOutputViewStreamWrapper kgCompressionView =\n                    new DataOutputViewStreamWrapper(kgCompressionOut);\n            kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey()));\n            // 写状态数据\n            partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId);\n        } // this will just close the outer compression stream\n    }\n}\n</code></pre>\n<p>状态数据写入的调用链路如下</p>\n<p><img alt=\"writeState\" class=\"lazyload\" /></p>\n<pre><code class=\"language-java\">public void writeState(\n        TypeSerializer&lt;K&gt; keySerializer,\n        TypeSerializer&lt;N&gt; namespaceSerializer,\n        TypeSerializer&lt;S&gt; stateSerializer,\n        @Nonnull DataOutputView dov,\n        @Nullable StateSnapshotTransformer&lt;S&gt; stateSnapshotTransformer)\n        throws IOException {\n    SnapshotIterator&lt;K, N, S&gt; snapshotIterator =\n            getIterator(\n                    keySerializer,\n                    namespaceSerializer,\n                    stateSerializer,\n                    stateSnapshotTransformer);\n\n    int size = snapshotIterator.size();\n    dov.writeInt(size);\n    while (snapshotIterator.hasNext()) {\n        StateEntry&lt;K, N, S&gt; stateEntry = snapshotIterator.next();\n        namespaceSerializer.serialize(stateEntry.getNamespace(), dov);\n        keySerializer.serialize(stateEntry.getKey(), dov);\n        stateSerializer.serialize(stateEntry.getState(), dov);\n    }\n}\n</code></pre>\n<h4 id=\"返回结果\">返回结果</h4>\n<p>最后一步就是封装并返回元信息，这里收集的信息包括了每个 keyGroup 的状态数据在状态文件中的存储位置，状态数据存储的文件路径、文件大小等。</p>\n<h3 id=\"operatorstate\">OperatorState</h3>\n<p>OperatorState 的处理逻辑比 KeyedState 更简单一些，流程上都是先做状态数据的引用快照，然后写入状态数据和返回结果。在写入数据时，没有了分组写入的逻辑。直接处理 operatorState 和 broadcastState。这里就只贴一下调用流程，不做过多赘述了。</p>\n<p><img alt=\"operatorState\" class=\"lazyload\" /></p>\n<h3 id=\"总结\">总结</h3>\n<p>本文我们重点梳理了 KeyedState 数据写入的代码。其主要步骤包括：同步拷贝状态数据的引用，创建 Checkpoint 输出流 <code>CheckpointStateOutputStream</code> 并完成 Checkpoint 持久化，最后返回元信息结果。OperatorState 的处理过程和 KeyedState 的过程类似，只是少了分组的逻辑。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 20:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Jackeyzhe\">Jackeyzhe</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "规划中主要使用的地图类型",
      "link": "https://www.cnblogs.com/zylyehuo/p/19419173",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zylyehuo/p/19419173\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 20:07\">\n    <span>规划中主要使用的地图类型</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>博客地址：<a href=\"https://www.cnblogs.com/zylyehuo/\" target=\"_blank\">https://www.cnblogs.com/zylyehuo/</a></p>\n</blockquote>\n<h1 id=\"occupancy-grid-map\">Occupancy Grid Map</h1>\n<blockquote>\n<p>【占据栅格地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1GzwderECF/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">移动机器人运动规划-第一章(运动规划介绍与地图构建)-第三节(地图构建方法-Occupancy Grid Map)</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV14C4y1r7Jd/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">自动驾驶中的Occupancy Grid占用栅格算法</a></p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230091555060-1199064499.png\" /></p>\n<ul>\n<li>基于贝叶斯公式</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092048607-315558262.png\" /></p>\n<ul>\n<li>基于马尔科夫假设（当前的概率与之前的概率是独立的）</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092203011-2028367547.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092225738-123828824.png\" /></p>\n<ul>\n<li>发现存在相同项</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092347064-1157737378.png\" /></p>\n<ul>\n<li>将两个概率进行相除，约去相同项</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230092755566-498805078.png\" /></p>\n<ul>\n<li>利用 log 函数，分离出先验状态</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093031164-242106556.png\" /></p>\n<ul>\n<li>还剩下“逆传感器模型”部分【不直观】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093249678-366631429.png\" /></p>\n<ul>\n<li>再利用贝叶斯公式，将“逆传感器模型”转换为“传感器模型”【基于当前栅格地图的状态，得到的这一次观测值应该是0还是1的概率】，发现又出现相同项</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093716424-1872441123.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230093825914-1423272760.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094001016-1041041406.png\" /></p>\n<ul>\n<li>假设“传感器模型”是个定值【基于观测的更新方式】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094259734-1484359303.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094533636-1069601382.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230094914148-745996427.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095200901-845289928.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095233736-1331029782.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095347220-253112120.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095358663-165236316.png\" /></p>\n<ul>\n<li>利用滚动的 Occupancy Grid Map，解决“大地图”问题</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095538388-1548681780.png\" /></p>\n<h1 id=\"tsdf\">TSDF</h1>\n<blockquote>\n<p>(Truncated Signed Distance Field)【截断符号距离场】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/personalrobotics/OpenChisel\" rel=\"noopener nofollow\" target=\"_blank\">An open-source version of the Chisel chunked TSDF library.</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1Xi4y1471W/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">运动规划之 TSDF map</a></p>\n</blockquote>\n<ul>\n<li>障碍物外面的值为正值，障碍物外面的值为负值</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230151947608-384612791.png\" /></p>\n<h1 id=\"esdf\">ESDF</h1>\n<blockquote>\n<p>(Euclidean Signed Distance Field)【欧几里得符号距离场】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1Hnwde9EFc?spm_id_from=333.788.player.switch&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651&amp;trackid=web_related_0.router-related-2206419-gx8f2.1767056746104.238\" rel=\"noopener nofollow\" target=\"_blank\">移动机器人运动规划-第一章(运动规划介绍与地图构建)-第三节(地图构建方法-ESDF)</a></p>\n</blockquote>\n<ul>\n<li>“一层”的是 ESDF，上面的小栅格是 Occupancy Grid Map</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230095632105-2084501764.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230100013176-744146623.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230100121591-1498147498.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230100151782-1360282382.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230101513785-573529793.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135055798-1520530407.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135316095-806542410.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135735490-663923292.png\" /></p>\n<ul>\n<li>仅针对一维的伪代码</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230135828974-1891255415.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230140300707-708995518.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230140520538-65060715.png\" /></p>\n<ul>\n<li>对于二维的情况，就是固定 x，根据不同的 y 求解到达障碍物的最小距离</li>\n<li>以第一列为例</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230140734954-316583447.png\" /></p>\n<ul>\n<li>以第二列为例（没有障碍物的情况，则每个位置的值都为 ∞）</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141116066-773952293.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141241727-845739716.png\" /></p>\n<ul>\n<li>接着固定 y，根据不同的 x 求解到达障碍物的最小距离</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141744667-376666185.png\" /></p>\n<ul>\n<li>以下面三行为例</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230141817043-1907659702.png\" /></p>\n<ul>\n<li>对于第一个格子，x=1，选取【这个格子到别的格子的距离 + 别的格子里面的“值”】最小的结果</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230142536264-839975597.png\" /></p>\n<ul>\n<li>对于第二个格子，x=2</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230142732894-2092955561.png\" /></p>\n<ul>\n<li>利用两次“一维”的求解，获得二维的结果【三维类似】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230142837572-2122723745.png\" /></p>\n<ul>\n<li>障碍物里面存放的值的意义：到最近的 free 的栅格的距离，同时这个值放的是负值</li>\n<li>先将障碍物和 free 栅格进行翻转，然后进行计算</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143237644-1636509800.png\" /></p>\n<ul>\n<li>将计算后的值添加上负号</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143311745-18788185.png\" /></p>\n<ul>\n<li>再和原来的场进行叠加</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143344921-1946627573.png\" /></p>\n<ul>\n<li>先沿着 z 轴算，再沿着 y 轴算，最后沿着 x 轴算</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143458985-408992367.png\" /></p>\n<ul>\n<li>进行翻转操作【反向 ESDF】，计算障碍物内部的值【先沿着 z 轴算，再沿着 y 轴算，最后沿着 x 轴算】</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143811950-1709618967.png\" /></p>\n<ul>\n<li>最后进行叠加</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230143910379-1892087086.png\" /></p>\n<ul>\n<li>对于当前位置不在栅格中心的情况，利用插值进行解决</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230144224352-5167244.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230144333713-2132197098.png\" /></p>\n<ul>\n<li>ESDF 地图梯度的计算</li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230144605924-1620303920.png\" /></p>\n<h1 id=\"gaussian-map\">Gaussian Map</h1>\n<h2 id=\"3dgs\">3DGS</h2>\n<blockquote>\n<p>(3D Gaussian Splatting)【3D 高斯溅射地图 / 前沿视觉地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/7833648056\" rel=\"noopener nofollow\" target=\"_blank\">3D Gaussian Splatting算法及其实现细节</a></p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://arxiv.org/pdf/2308.04079\" rel=\"noopener nofollow\" target=\"_blank\">3D Gaussian Splatting for Real-Time Radiance Field Rendering</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/graphdeco-inria/gaussian-splatting\" rel=\"noopener nofollow\" target=\"_blank\">代码</a></p>\n</blockquote>\n<h2 id=\"gp-map\">GP Map</h2>\n<blockquote>\n<p>(Gaussian Process Map)【高斯过程地图 / 概率连续地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/2751630763\" rel=\"noopener nofollow\" target=\"_blank\">什么是高斯过程（Gaussian Processes, GP）</a></p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://fabioramos.github.io/Publications_files/Simon_ISER2014.pdf\" rel=\"noopener nofollow\" target=\"_blank\">Gaussian process occupancy maps for dynamic environments</a></p>\n</blockquote>\n<h2 id=\"gmm\">GMM</h2>\n<blockquote>\n<p>(Gaussian Mixture Models)【高斯混合模型地图】</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/151671154\" rel=\"noopener nofollow\" target=\"_blank\">如何通俗的理解高斯混合模型（Gaussian Mixture Models））</a></p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://zhuanlan.zhihu.com/p/151671154\" rel=\"noopener nofollow\" target=\"_blank\">Gaussian Mixture Models</a></p>\n</blockquote>\n<h1 id=\"nerf\">NeRF</h1>\n<blockquote>\n<p>(Neural Radiance Fields)【神经辐射场】</p>\n</blockquote>\n<blockquote>\n<p>论文：<a href=\"https://arxiv.org/pdf/2003.08934\" rel=\"noopener nofollow\" target=\"_blank\">Representing Scenes as Neural Radiance Fields for View Synthesis</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/bmild/nerf\" rel=\"noopener nofollow\" target=\"_blank\">代码</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.matthewtancik.com/nerf\" rel=\"noopener nofollow\" target=\"_blank\">官网</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/jiaoyangwm/article/details/133804918\" rel=\"noopener nofollow\" target=\"_blank\">NeRF 首篇经典论文介绍（ECCV2020）</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1CC411V7oq/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4acdb875c05ce9dccfce3cd6cfaac651\" rel=\"noopener nofollow\" target=\"_blank\">【较真系列】讲人话-NeRF全解（原理+代码+公式）</a></p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230152646680-808967645.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153232330-8093872.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153304058-1966233738.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153458012-810246374.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153627018-1090646223.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153701724-2140345591.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153801636-51891141.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230153921564-421511957.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154119566-421233492.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154404671-1853328831.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154452220-1182229856.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230154836620-1158102823.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155102446-1293304585.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155330237-169551366.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155631408-2064100778.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155728157-250263865.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230155820644-869689816.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160626120-96920975.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160754127-1769142361.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160851194-233434887.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230160937600-1841363.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161047152-122034867.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161318891-1616916806.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161437134-1545984944.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161723359-1462419215.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230161925557-1973428927.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230174118921-38385255.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230174243818-575765853.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175016337-1136716337.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175052111-1485817129.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175157993-2141132230.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175345585-750664154.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175425714-1466271787.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175528313-2072746571.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175732929-1433112194.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202512/3071480-20251230175830148-1190162908.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 20:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zylyehuo\">zylyehuo</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "代码考古学：如何让你的代码不再是“未解之谜”？",
      "link": "https://www.cnblogs.com/huizhudev/p/19422839",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/huizhudev/p/19422839\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 18:29\">\n    <span>代码考古学：如何让你的代码不再是“未解之谜”？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"代码考古学：如何让你的代码不再是“未解之谜”？\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3695776/202512/3695776-20251230182757218-218563489.png\" />\n        好的代码不只需要逻辑，更需要解释。本文挑战“代码即文档”的迷思，介绍如何利用AI指令充当“代码考古学家”，将晦涩的逻辑转化为清晰的“罗塞塔石碑”式文档，消除团队知识债务，提升项目的可维护性与专业度。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>你有没有经历过这种<strong>“灵魂出窍”</strong>的时刻：</p>\n<p>盯着一段三个月前自己亲手写的代码，感觉像是在看外星文明留下的天书。逻辑极其精妙，变量名简写得极其潇洒，但你就是死活想不起来——<strong>这玩意儿到底是用来干嘛的？</strong></p>\n<p>如果说写代码是构建一座宏伟的宫殿，那么写注释就是给这座宫殿绘制“导游图”。遗憾的是，在赶进度的修罗场里，我们往往只顾着添砖加瓦，却忘了留下任何文字线索。</p>\n<p>最终，项目变成了一座<strong>“数字迷宫”</strong>。新来的同事在里面晕头转向，接手的维护者在里面步步惊心，就连始作俑者你自己，过段时间回来也是一脸茫然。</p>\n<p><img alt=\"代码考古学：如何让你的代码不再是“未解之谜”？\" class=\"lazyload\" /></p>\n<h2 id=\"-打破代码即文档的迷思\">🏺 打破“代码即文档”的迷思</h2>\n<p>在程序员圈子里，流传着一个迷人的谎言：<em>“好的代码是自解释的（Self-documenting），不需要注释。”</em></p>\n<p>这句话只对了一半。<br />\n对于 <code>getUserName()</code> 这种显而易见的代码，注释确实是噪音。<br />\n但对于那些<strong>反直觉的业务逻辑、为了性能的Hack写法、以及复杂的算法实现</strong>，代码本身只能告诉你“它做了什么”，却永远无法告诉你“<strong>为什么要这么做</strong>”。</p>\n<p>缺失的注释，就是团队的<strong>“知识债务”</strong>。债务是有利息的，而利息的支付方式，就是无休止的 Bug 排查和高昂的沟通成本。</p>\n<h2 id=\"-ai你的罗塞塔石碑雕刻师\">🧩 AI：你的“罗塞塔石碑”雕刻师</h2>\n<p>如果是以前，我会劝你：“兄弟，咬咬牙，把文档补上吧。”<br />\n但现在，作为一名追求极致效率的工程师，我会说：<strong>“这种要把逻辑翻译成人类语言的活儿，为什么不交给最擅长处理自然语言的 AI 呢？”</strong></p>\n<p>我为你准备了一套<strong>「代码注释生成 AI 指令」</strong>。<br />\n它不是简单的“翻译机”，而是一位<strong>“代码考古学家”</strong>。它能深入分析你的代码逻辑，推断设计意图，并用最规范的格式，为你刻下清晰的“罗塞塔石碑”。</p>\n<h3 id=\"️-复制这个指令重塑代码可读性\">🛠️ 复制这个指令，重塑代码可读性</h3>\n<p>这套指令的精髓在于<strong>“分层解析”</strong>。它会根据你指定的规范（JSDoc/Javadoc等），自动区分<strong>接口契约</strong>（参数/返回值）和<strong>实现细节</strong>（行内逻辑），确保注释既不冗余，也不缺失。</p>\n<pre><code class=\"language-markdown\"># 角色定义\n你是一位资深代码文档工程师，拥有10年以上软件开发经验，精通多种编程语言的文档规范（如JSDoc、Javadoc、Python Docstring、XML Doc等）。你擅长分析代码逻辑、理解设计意图，并能用简洁清晰的语言编写高质量的代码注释。\n\n# 任务描述\n请为以下代码生成专业、规范的注释，确保注释能够帮助开发者快速理解代码功能、参数说明、返回值及使用场景。\n\n**输入信息**:\n- **编程语言**: [请指定：JavaScript/Python/Java/C#/Go/TypeScript/其他]\n- **注释规范**: [请指定：JSDoc/Javadoc/Python Docstring/XML Doc/自定义/自动识别]\n- **注释级别**: [请选择：函数级/类级/模块级/行内注释/全部]\n- **详细程度**: [请选择：简洁/标准/详细]\n\n**待注释代码**:\n```\n[在此粘贴你的代码]\n```\n\n# 输出要求\n\n## 1. 内容结构\n- **文件/模块头注释**: 描述文件用途、作者、创建日期\n- **类/接口注释**: 描述类的职责、设计目的、使用示例\n- **函数/方法注释**: 功能描述、参数说明、返回值、异常处理、使用示例\n- **关键逻辑注释**: 复杂算法或业务逻辑的行内说明\n\n## 2. 质量标准\n- **准确性**: 注释必须准确反映代码的实际功能，不能有歧义\n- **完整性**: 覆盖所有公共API、复杂逻辑和关键决策点\n- **简洁性**: 用最少的文字表达最完整的信息\n- **规范性**: 严格遵循指定的注释规范格式\n\n## 3. 格式要求\n- 遵循指定编程语言的注释语法\n- 保持一致的缩进和对齐\n- 使用规范的标签（如@param、@returns、@throws等）\n- 中英文之间添加空格，提升可读性\n\n## 4. 风格约束\n- **语言风格**: 技术专业但通俗易懂\n- **表达方式**: 第三人称客观叙述\n- **专业程度**: 面向开发者，假设读者具备基础编程知识\n\n# 质量检查清单\n\n在完成输出后，请自我检查:\n- [ ] 注释格式符合指定的文档规范\n- [ ] 函数的参数和返回值都已说明\n- [ ] 复杂逻辑处有行内注释解释\n- [ ] 没有拼写错误或语法问题\n- [ ] 注释与代码实际功能一致\n\n# 注意事项\n- 不要修改原有代码逻辑，只添加注释\n- 避免过度注释（如解释显而易见的代码）\n- 对于废弃的方法要标注 @deprecated 并说明替代方案\n- 敏感信息（如密码、密钥）不要在注释中出现\n\n# 输出格式\n请直接输出带有完整注释的代码，使用对应语言的代码块格式。如果有多个文件，请分别标注文件名。\n</code></pre>\n<h2 id=\"️-效果实测从天书到教科书\">⚡️ 效果实测：从“天书”到“教科书”</h2>\n<p>让我们来看一个真实的<strong>反直觉</strong>场景。<br />\n这是一段用于处理防抖（Debounce）的 JavaScript 代码。如果不看注释，你需要在大脑里模拟半天 Event Loop 才能看懂它是怎么工作的。</p>\n<p><strong>使用前（裸奔版）：</strong></p>\n<pre><code class=\"language-javascript\">function debounce(func, wait, immediate) {\n    let timeout;\n    return function() {\n        const context = this, args = arguments;\n        const later = function() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n        };\n        const callNow = immediate &amp;&amp; !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(context, args);\n    };\n}\n</code></pre>\n<p><strong>使用指令后（教科书版）：</strong></p>\n<pre><code class=\"language-javascript\">/**\n * 创建一个防抖函数，在指定时间内多次调用只执行一次\n * \n * 防抖常用于处理频繁触发的事件，如窗口resize、输入框实时搜索等场景，\n * 可以有效减少不必要的函数调用，提升性能。\n * \n * @param {Function} func - 需要防抖处理的目标函数\n * @param {number} wait - 防抖延迟时间，单位毫秒\n * @param {boolean} [immediate=false] - 是否立即执行\n *   - true: 在延迟开始时立即执行，后续调用在延迟结束前被忽略\n *   - false: 在延迟结束后执行最后一次调用\n * @returns {Function} 经过防抖处理的新函数\n */\nfunction debounce(func, wait, immediate) {\n    // 用于存储定时器ID，实现延迟控制\n    let timeout;\n    \n    // 返回包装后的函数，保持原函数的 this 指向和参数\n    return function executedFunction() {\n        const context = this;\n        const args = arguments;\n        \n        // 延迟执行的回调函数\n        const later = function() {\n            timeout = null;\n            // 非立即执行模式下，在延迟结束后调用目标函数\n            if (!immediate) func.apply(context, args);\n        };\n        \n        // 判断是否需要立即执行：immediate 为 true 且当前没有等待中的定时器\n        const callNow = immediate &amp;&amp; !timeout;\n        \n        // 每次调用都重置定时器，实现\"重新计时\"效果\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        \n        // 立即执行模式下，首次调用直接执行\n        if (callNow) func.apply(context, args);\n    };\n}\n</code></pre>\n<p>注意到了吗？AI 不仅解释了参数，还解释了<strong>实现原理</strong>（如 \"保持原函数的 this 指向\"）。这不仅是文档，更是<strong>教学</strong>。</p>\n<h2 id=\"-工程师的第二大脑\">💡 工程师的第二大脑</h2>\n<p>使用这个 AI 指令，并不是为了让你偷懒，而是为了让你把宝贵的脑力从“解释代码”中解放出来，去专注于“设计代码”。</p>\n<p>试着把这个指令集成到你的工作流中：</p>\n<ol>\n<li><strong>接手遗留项目时</strong>：先用 AI 跑一遍核心模块，快速生成“地形图”。</li>\n<li><strong>提交 Code Review 前</strong>：用 AI 补全文档，让 Reviewer 少问几个“这是啥”。</li>\n<li><strong>编写开源库时</strong>：一键生成标准 JSDoc/Javadoc，让你的项目显得更专业。</li>\n</ol>\n<p>代码是写给机器执行的，但更是写给人看的。<br />\n<strong>别让你的代码，成为下一个需要解密的“未解之谜”。</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 18:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/huizhudev\">realhuizhu</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "海豚调度DolphinScheduler 和 Spring Cloud Data Flow 对比",
      "link": "https://www.cnblogs.com/kakarotto-chen/p/19421939",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kakarotto-chen/p/19421939\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 16:22\">\n    <span>海豚调度DolphinScheduler 和 Spring Cloud Data Flow 对比</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n            <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"spring-cloud-data-flow\">Spring Cloud Data Flow</h2>\n<p>Spring Cloud Data Flow是一个基于Spring Boot和Spring Cloud的开源框架，旨在简化云原生环境中数据流处理和批处理任务的开发、部署与管理。它提供了一种统一的编程和操作模型，用于编排可组合的数据微服务，支持在Cloud Foundry、Kubernetes等现代平台上运行.</p>\n<p>‌核心功能与架构：‌ Spring Cloud Data Flow的核心功能包括通过领域特定语言（DSL）或可视化界面定义数据流、管理数据管道的部署与监控，并支持实时数据处理、批处理任务、数据集成等场景。其架构基于微服务设计，主要包括数据流（Stream）和任务（Task）两大模块：数据流用于连续处理事件流（如日志分析、实时推荐），而任务则用于一次性批处理操作（如数据导入导出）。框架通过注册中心管理可复用的应用组件，并利用Spring Cloud Deployer在不同平台上自动化部署。‌</p>\n<h2 id=\"对比\">对比</h2>\n<ul>\n<li>原理上有相似性（都是调度框架），但DolphinScheduler是“任务级的调度”，Spring Cloud Data Flow是“应用级的编排”。</li>\n</ul>\n<h3 id=\"问题-spring-cloud-data-flow来调度seatunnel和dolphinscheduler调度seatunnel差不多\">问题： spring cloud data flow来调度seatunnel、和dolphinscheduler调度seatunnel差不多？</h3>\n<ul>\n<li>Spring Cloud Data Flow（SCDF）和 DolphinScheduler 都可以用来调度 SeaTunnel 任务，但它们在设计理念和实现方式上有一些关键区别：</li>\n</ul>\n<h4 id=\"1-设计理念与架构\">1. ‌设计理念与架构‌</h4>\n<p>Spring Cloud Data Flow‌：</p>\n<ul>\n<li>核心理念‌：SCDF 是一个数据流编排框架，专注于流式和批处理任务的定义、部署和管理。它通过 Spring Boot 和 Spring Cloud 提供统一的编程模型。</li>\n<li>架构‌：基于 Spring Cloud Deployer，支持多环境部署（如本地、Kubernetes、Cloud Foundry），通过 Skipper 实现应用版本管理和滚动更新。</li>\n<li>组件模型‌：SCDF 使用源（Source）、处理器（Processor）和接收器（Sink）的组件模型，通过 DSL（Domain Specific Language）或图形界面定义数据流。</li>\n</ul>\n<p>DolphinScheduler‌：</p>\n<ul>\n<li>核心理念‌：DolphinScheduler 是一个分布式任务调度平台，支持多种任务类型（如 Shell、Spark、Flink、DataX 等），强调任务编排和监控。</li>\n<li>架构‌：基于 Master-Worker 模型，通过 ZooKeeper 实现任务调度和资源管理。</li>\n<li>组件模型‌：DolphinScheduler 支持自定义任务插件，通过拖拽界面定义 DAG 工作流。</li>\n</ul>\n<h4 id=\"2-调度方式与灵活性\">2. ‌调度方式与灵活性‌</h4>\n<p>SCDF 调度 SeaTunnel‌：<br />\n方式‌：通过 SCDF 的 DSL 或图形界面定义 SeaTunnel 任务，SCDF 负责任务的部署和执行。<br />\n灵活性‌：支持多种计算引擎（如 Spark、Flink），但需要额外配置 SeaTunnel 的启动脚本和参数。<br />\nDolphinScheduler 调度 SeaTunnel‌：<br />\n方式‌：DolphinScheduler 3.1.5+ 版本内置 SeaTunnel 组件，通过任务节点直接配置 SeaTunnel 脚本。<br />\n灵活性‌：支持动态参数配置、任务级重试和失败处理机制。</p>\n<h4 id=\"3-适用场景与优势\">3. ‌适用场景与优势‌</h4>\n<p>SCDF 优势‌：<br />\n适合需要统一数据流管理和编排的场景，尤其是与 Spring 生态系统集成。<br />\n通过 Skipper 实现应用的版本管理和滚动更新。<br />\nDolphinScheduler 优势‌：<br />\n适合复杂任务编排和监控需求，支持丰富的任务类型和自定义插件。<br />\n提供秒级任务调度和故障恢复机制。</p>\n<h4 id=\"4-关键区别\">4. ‌关键区别‌</h4>\n<p>调度模型‌：SCDF 更侧重于数据流的定义和编排，DolphinScheduler 更侧重于任务的调度和监控。<br />\n组件集成‌：SCDF 需手动配置 SeaTunnel 启动脚本，DolphinScheduler 内置 SeaTunnel 组件简化配置。<br />\n总结</p>\n<p>两者都可以调度 SeaTunnel，但 SCDF 更适合数据流编排场景，DolphinScheduler 更适合复杂任务调度需求。选择时需根据具体业务需求和现有技术栈决定。</p>\n<h2 id=\"二-核心对比两种调度思路\">二、📊 <strong>核心对比：两种调度思路</strong></h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th><strong>DolphinScheduler</strong></th>\n<th><strong>Spring Cloud Data Flow (SCDF)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>定位</strong></td>\n<td><strong>任务调度与工作流编排平台</strong></td>\n<td><strong>云原生流批数据处理平台</strong></td>\n</tr>\n<tr>\n<td><strong>设计理念</strong></td>\n<td>“任务的调度器”</td>\n<td>“数据管道的Kubernetes”</td>\n</tr>\n<tr>\n<td><strong>调度单位</strong></td>\n<td>任务/工作流（Task/DAG）</td>\n<td>数据流/批处理管道（Stream/Batch）</td>\n</tr>\n<tr>\n<td><strong>资源管理</strong></td>\n<td>Worker节点、租户、队列</td>\n<td>云平台（K8s、Cloud Foundry）</td>\n</tr>\n<tr>\n<td><strong>主要界面</strong></td>\n<td>完整的Web UI操作界面</td>\n<td>CLI + Dashboard（UI较简单）</td>\n</tr>\n<tr>\n<td><strong>部署复杂度</strong></td>\n<td>中等（需要DB、Zookeeper）</td>\n<td>高（依赖Spring Cloud生态）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三-技术实现对比\">三、🔧 <strong>技术实现对比</strong></h2>\n<h3 id=\"1-dolphinscheduler调度seatunnel\"><strong>1. DolphinScheduler调度SeaTunnel</strong></h3>\n<pre><code class=\"language-yaml\"># 你的当前方案：明确、直接的任务调度\nDS工作流任务 → Shell任务 → 执行 seatunnel.sh\n\n# 特点：\n# 1. 像crontab增强版\n# 2. 手动配置每个任务的细节\n# 3. 直接控制执行服务器和用户\n</code></pre>\n<h3 id=\"2-spring-cloud-data-flow调度seatunnel\"><strong>2. Spring Cloud Data Flow调度SeaTunnel</strong></h3>\n<pre><code class=\"language-yaml\"># SCDF方案：声明式的数据管道\nSCDF Stream定义: source -&gt; seatunnel-processor -&gt; sink\n\n# 特点：\n# 1. 把SeaTunnel包装成Spring Cloud Stream应用\n# 2. 通过SCDF部署和管理应用生命周期\n# 3. 自动处理消息传递、扩缩容\n</code></pre>\n<h2 id=\"四-适用场景对比\">四、🎯 <strong>适用场景对比</strong></h2>\n<h3 id=\"dolphinscheduler更适合\"><strong>DolphinScheduler更适合：</strong></h3>\n<pre><code class=\"language-yaml\"># 传统ETL调度场景\n- 定时数据同步任务（每天凌晨1点跑）\n- 复杂依赖的工作流（A表跑完再跑B）\n- 需要人工介入（失败报警、手动重跑）\n- 多租户、资源隔离需求\n- 已有服务器（非K8s）环境\n\n# 典型工作流\n┌─────────┐    ┌──────────┐    ┌─────────┐\n│ 采集日志 │ →  │ SeaTunnel │ → │  入仓   │\n└─────────┘    └──────────┘    └─────────┘\n       │              │              │\n   每天1点      依赖采集完成    依赖ETL完成\n</code></pre>\n<h3 id=\"spring-cloud-data-flow更适合\"><strong>Spring Cloud Data Flow更适合：</strong></h3>\n<pre><code class=\"language-yaml\"># 云原生实时/微批场景\n- 持续运行的数据管道（7x24小时）\n- 微服务架构的数据处理\n- 需要自动扩缩容\n- 已使用Spring Cloud生态\n- K8s环境部署\n\n# 典型数据流\n┌─────────┐    ┌──────────────┐    ┌─────────┐\n│ Kafka   │ →  │ SeaTunnel    │ →  │  Redis  │\n│ 消息源  │    │ (实时清洗)   │    │  实时数  │\n└─────────┘    └──────────────┘    └─────────┘\n    持续产生          持续处理          持续更新\n</code></pre>\n<h2 id=\"五-具体实现方式差异\">五、🚀 <strong>具体实现方式差异</strong></h2>\n<h3 id=\"dolphinscheduler方式你正在用的\"><strong>DolphinScheduler方式（你正在用的）</strong></h3>\n<pre><code class=\"language-bash\"># 1. 编写SeaTunnel配置文件 config.conf\n# 2. 在DS中创建Shell任务\n# 3. 任务内容：/opt/seatunnel/bin/start.sh -c config.conf\n# 4. 设置定时、依赖、告警\n</code></pre>\n<h3 id=\"spring-cloud-data-flow方式\"><strong>Spring Cloud Data Flow方式</strong></h3>\n<pre><code class=\"language-bash\"># 1. 将SeaTunnel包装为Spring Boot应用\n# 2. 注册到SCDF作为自定义处理器(processor)\n# 3. 通过DSL定义流\nstream create --name my-etl-pipeline \\\n  --definition \"http --port=9000 | seatunnel-processor | jdbc\"\n\n# 4. 部署流\nstream deploy --name my-etl-pipeline \\\n  --properties \"app.seatunnel-processor.seatunnel-config=file:///config.conf\"\n\n# 5. SCDF自动管理应用实例\n</code></pre>\n<h2 id=\"六️-重要注意事项\">六、⚠️ <strong>重要注意事项</strong></h2>\n<h3 id=\"scdf的挑战\"><strong>SCDF的挑战：</strong></h3>\n<ol>\n<li><strong>强绑定Spring生态</strong>：需要将SeaTunnel改造为Spring Cloud Stream应用</li>\n<li><strong>学习曲线陡峭</strong>：需了解Stream、Task、Skipper等概念</li>\n<li><strong>部署复杂</strong>：依赖消息中间件（RabbitMQ/Kafka）、服务发现等</li>\n<li><strong>资源消耗</strong>：每个任务都是独立JVM进程，内存开销大</li>\n</ol>\n<h3 id=\"dolphinscheduler的优势对你当前情况\"><strong>DolphinScheduler的优势（对你当前情况）：</strong></h3>\n<ol>\n<li><strong>独立轻量</strong>：不依赖特定技术栈</li>\n<li><strong>直观易用</strong>：有完整UI，学习成本低</li>\n<li><strong>你已熟悉</strong>：已搭建环境并跑通流程</li>\n<li><strong>社区活跃</strong>：中文文档和社区支持好</li>\n</ol>\n\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2025-12-30 16:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kakarotto-chen\">C_C_菜园</a>&nbsp;\n阅读(<span id=\"post_view_count\">44</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "[微服务场景实战] - 限流 - 如何让服务器在亿级流量冲击下“活下去”",
      "link": "https://www.cnblogs.com/yhup/p/19421693",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yhup/p/19421693\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 15:51\">\n    <span>[微服务场景实战] - 限流 - 如何让服务器在亿级流量冲击下“活下去”</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"[微服务场景实战] - 限流 - 如何让服务器在亿级流量冲击下“活下去”\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251230154314116-2147043778.png\" />\n        本文探讨了在高并发秒杀场景下的限流技术。首先分析了亿级流量冲击的业务场景，指出限流是保证系统存活的关键策略。接着详细介绍了四种限流算法：固定时间窗口计数算法存在边界临界问题；滑动时间窗口算法通过子窗口划分提高精度但仍面临机器人抢购问题；漏桶算法通过恒定速率处理请求但无法解决瞬时峰值；令牌桶算法通过控制令牌生成速率和桶容量，既能平滑流量又能增加真实用户成功率。最后重点推荐了令牌桶算法在秒杀场景下的优化实现方案，通过限制瞬时可用令牌数量来有效缓解流量洪峰。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在之前的文章里，我们聊过了秒杀系统的整体架构方案，其中也提到了限流——这个让人又爱又恨的技术环节。因为篇幅所限，我们当时只能浅尝辄止，没来得及展开细说。</p>\n<p>那么这一章，我们就来把限流这个问题掰开揉碎，讲个明白。放心，内容依然保持专业与深度，并且尽量说得清楚易懂。</p>\n<p>老规矩，为了便于理解，我们还是从一个实际的业务场景开始说起。</p>\n<h1 id=\"1-业务场景如何让服务器在亿级流量冲击下活下去\">1 业务场景：<font style=\"color: rgba(15, 17, 21, 1);\">如何让服务器在亿级流量冲击下“活下去”</font></h1>\n<h3 id=\"业务场景如何让服务器在亿级流量冲击下活下去\">业务场景：如何让服务器在亿级流量冲击下“活下去”</h3>\n<p>想象这样一个场景：某次秒杀活动，只有100件特价商品，价格低到让人心动。活动时间定在10月10日晚上10点10分0秒——这时间点选得挺有仪式感，但对系统来说，可能就像一场精心策划的“流量海啸”。</p>\n<p>当时的服务架构大致如下图所示：所有用户请求首先到达Nginx层，然后被转发到网关层（基于Java的Spring Cloud Zuul），最后才进入后台业务服务（同样是Java）。这条链路听起来清晰，但秒杀开始瞬间，预测将有无序涌入的海量用户请求——多到系统根本处理不完。</p>\n<p><img alt=\"服务架构图\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251230154220550-735247776.jpg\" /></p>\n<p>怎么办呢？答案就是<strong>限流</strong>。为了保证服务器不被冲垮，我们只能理智地选择“放行一部分，拒绝大部分”。这听起来有点残酷，但却是高并发场景下的常见生存策略。</p>\n<p>说到这里，容易混淆的两个概念——<strong>限流</strong>和<strong>熔断</strong>——值得简单区分一下。虽然它们都是保护系统的手段，但发生的位置和目的不同：</p>\n<ul>\n<li><strong>熔断</strong>通常发生在<strong>服务调用方</strong>。举例来说，如果服务A多次调用服务B都失败，判断服务B已不可用，那么服务A就会主动“熔断”，暂时停止调用，避免资源浪费并给服务B恢复的时间。</li>\n<li><strong>限流</strong>则主要发生在<strong>服务被调用方</strong>，尤其在<strong>网关层</strong>实施。例如，一个电商后台每秒只能处理10万请求，如果瞬间涌来100万请求，系统可能直接丢弃其中90万，只处理剩余的10万。这个比例在秒杀场景下并不夸张——有时甚至舍弃99%的流量都是可以接受的，只为确保系统不崩溃、部分用户能顺利完成交易。</li>\n</ul>\n<p>回到我们的具体业务需求：这次秒杀只有100件商品，也就是说，最终成功的交易只有100笔。我们希望把这些交易控制在大约一秒内完成，即<strong>将交易TPS（每秒事务数）限制在100笔/秒</strong>。</p>\n<p>那么问题来了：如何在系统的某一层（比如网关）实现这样的精确控制？这就引出了我们接下来要深入探讨的<strong>限流常用算法</strong>。</p>\n<h1 id=\"2-限流算法\">2 限流算法</h1>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">在明确了需要将交易TPS控制在100笔/秒的目标后，我们来看看实现限流有哪些常用的算法。每种算法各有特点，其适用性也需结合具体场景来判断。</font></p>\n<h2 id=\"21-固定时间窗口计数算法\">2.1 固定时间窗口计数算法</h2>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">这是一种最直观的思路。例如，若要求每5秒处理不超过500个请求，我们就以5秒为一个固定窗口进行计数。</font></p>\n<p><strong><font style=\"color: rgba(15, 17, 21, 1);\">原理与缺陷：</font></strong><font style=\"color: rgba(15, 17, 21, 1);\"><br />\n</font><font style=\"color: rgba(15, 17, 21, 1);\">该算法看似能满足需求，但存在一个典型的边界临界问题。假设请求分布如下：</font></p>\n<ul>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">第1-4秒：200个请求</font></li>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">第5秒：300个请求</font></li>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">第6-9秒：499个请求</font></li>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">第10秒：1个请求</font></li>\n</ul>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">单独统计第1-5秒和第6-10秒这两个窗口，请求数均为500，未超出阈值。然而，如果我们观察第5-9秒这个跨窗口的区间，请求总数高达300 + 499 = 799个，这已远超系统负载能力。</font></p>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">因此，固定时间窗口算法由于存在统计盲区，在实际高并发场景中通常不适用。</font></p>\n<h2 id=\"22-滑动时间窗口计数算法\">2.2 滑动时间窗口计数算法</h2>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">为改善固定窗口的缺陷，滑动时间窗口算法应运而生。假设需求是每秒处理100个请求，我们可以将1秒划分为10个100毫秒的子窗口。</font></p>\n<p><strong><font style=\"color: rgba(15, 17, 21, 1);\">工作原理：</font></strong><font style=\"color: rgba(15, 17, 21, 1);\"><br />\n</font><font style=\"color: rgba(15, 17, 21, 1);\">\t系统持续统计当前时间点往前回溯1秒（即最近10个子窗口）内的请求总数。时间每推进100毫秒，窗口就“滑动”一次，丢弃最老的那个子窗口的计数，并入最新的一个子窗口计数，然后重新计算总和。</font><br />\n<img alt=\"滑动窗口示意图\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251230154220539-368352630.jpg\" /></p>\n<p><strong><font style=\"color: rgba(15, 17, 21, 1);\">优势与局限：</font></strong><font style=\"color: rgba(15, 17, 21, 1);\"><br />\n</font><font style=\"color: rgba(15, 17, 21, 1);\">\t这种方法极大地降低了单位时间内流量超标却无法检测到的概率。当然，精度取决于子窗口的粒度：划分为10毫秒会更精准，但计算开销也更大。</font></p>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">然而，在秒杀场景下，该算法依然面临</font><strong><font style=\"color: rgba(15, 17, 21, 1);\">核心挑战：</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">即便将限流设置为100/秒，也可能出现请求全部集中在第一个100毫秒内到达的情况。这意味着商品在100毫秒内就被“秒光”。能在此极短时间内完成操作的几乎只有自动化脚本（“机器人”），这与希望真实用户参与的商业初衷相悖，并不是我们想要的结果。</font></p>\n<p>再看看其他算法。</p>\n<h2 id=\"23-漏桶算法\">2.3 漏桶算法</h2>\n<p>漏桶算法的实现思路如图所示。<br />\n<img alt=\"漏桶实现思路示意图\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251230154220531-214188907.jpg\" /><br />\n<strong><font style=\"color: rgba(15, 17, 21, 1);\">实现步骤：</font></strong></p>\n<ol>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">所有请求进入漏桶的队列中等待。</font></li>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">漏桶以恒定的速率（例如，对应100个/秒，即每10毫秒处理一个）向外处理请求。</font></li>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">若桶内队列已满，则新到达的请求会被直接丢弃。</font></li>\n</ol>\n<p><strong><font style=\"color: rgba(15, 17, 21, 1);\">场景分析：</font></strong><font style=\"color: rgba(15, 17, 21, 1);\"><br />\n</font><font style=\"color: rgba(15, 17, 21, 1);\">\t在我们的例子中，若设置桶的大小（队列容量）为100，输出速率为100/秒，那么系统将严格按“先进先出”原则处理前100个请求。这同样会导致商品被瞬间涌入的最早一批请求（很可能来自机器人）抢购一空。若将桶容量设为1，虽能加剧排队、稀释瞬时压力，但仍未从根本上解决机器人优势问题。</font></p>\n<p>再说一下令牌桶算法。</p>\n<h2 id=\"24-令牌桶算法\">2.4 令牌桶算法</h2>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">令牌桶算法提供了更灵活的调控能力，其原理如图所示。</font></p>\n<p><img alt=\"令牌桶示意图\" src=\"https://img2024.cnblogs.com/blog/2428649/202512/2428649-20251230154220604-1590138079.jpg\" /></p>\n<ol>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">系统以恒定速率（如100个/秒）生成令牌，并放入容量固定的令牌桶中。</font></li>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">每个请求到达时，必须获取并消耗一个令牌才能被处理。</font></li>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">若桶中有令牌，则请求立即消耗一个并通行。</font></li>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">若桶中无令牌，请求可进入队列等待（如果配置了队列），或直接被拒绝。</font></li>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">当等待队列也满时，新请求将被丢弃。</font></li>\n</ol>\n<p><strong><font style=\"color: rgba(15, 17, 21, 1);\">针对秒杀的优化方案：</font></strong><font style=\"color: rgba(15, 17, 21, 1);\"><br />\n</font><font style=\"color: rgba(15, 17, 21, 1);\">\t回到每秒100笔交易的限制。我们可以将令牌生成速率设为100个/秒，同时关键地</font><strong><font style=\"color: rgba(15, 17, 21, 1);\">将令牌桶本身的容量设置成一个较小的值（例如10）</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">，并将排队队列长度设为0。</font></p>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">这样一来：</font></p>\n<ul>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">系统每秒最多只能发放100个令牌（即处理100个请求）。</font></li>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">由于桶容量只有10，这意味着在任意瞬时，最多只有10个“库存”令牌可供立即使用。即使秒杀前已提前生成了一些令牌，其数量也被限制在10个以内。</font></li>\n</ul>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">因此，在秒杀开启的瞬间，最多只有约10个请求能</font><strong><font style=\"color: rgba(15, 17, 21, 1);\">立即获得令牌并完成交易</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">，其余请求必须等待下一个令牌生成周期（10毫秒后）。这在一定程度上打散了瞬时峰值，增加了真实用户成功的机会。</font></p>\n<h1 id=\"3-方案实现\">3 方案实现</h1>\n<h2 id=\"31-使用令牌桶还是漏桶模式\">3.1 使用令牌桶还是漏桶模式</h2>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">尽管两者都能满足“每秒100笔”的基本限流需求，但我们需要的是一个能适应多场景的通用方案。</font></p>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">漏桶算法以恒定速率处理请求，其行为类似于一个</font><strong><font style=\"color: rgba(15, 17, 21, 1);\">“流量整形器”</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">，即使系统有空闲资源，也无法加速处理之前累积的请求。</font></p>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">令牌桶算法则因其可以累积令牌的特性，在算法行为上天然允许在阈值范围内应对</font><strong><font style=\"color: rgba(15, 17, 21, 1);\">短时突发流量</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">，能更好地利用系统空闲期所预留的处理能力。</font></p>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">因此，从算法机制上看，令牌桶更适合需要一定突发容忍度的通用场景。这种特性使其更适用于更广泛的业务场景。因此，项目组最终选择了灵活性更高的令牌桶算法。当然，无论是令牌桶还是漏桶，\t其速率和容量的具体参数值都需要根据实际运维监控数据进行配置和调整。</font></p>\n<h2 id=\"32-在nginx中实现限流还是在网关层中实现限流\">3.2 在Nginx中实现限流还是在网关层中实现限流</h2>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">在我们的架构中，流量依次经过Nginx和网关层。将限流组件部署在哪一层，需要仔细权衡。</font></p>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">最终决定在</font><strong><font style=\"color: rgba(15, 17, 21, 1);\">Java网关层（Spring Cloud Zuul） </font></strong><font style=\"color: rgba(15, 17, 21, 1);\">实现限流，主要基于两点考虑：</font></p>\n<ol>\n<li><strong><font style=\"color: rgba(15, 17, 21, 1);\">算法匹配度：</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">Nginx自带的限流模块（如</font><font style=\"color: rgba(15, 17, 21, 1); background-color: rgba(235, 238, 242, 1);\"><code>ngx_http_limit_req_module</code></font><font style=\"color: rgba(15, 17, 21, 1);\">）主要基于漏桶算法，与我们选定的令牌桶算法不符。</font></li>\n<li><strong><font style=\"color: rgba(15, 17, 21, 1);\">技术栈与运维便利性：</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">实现动态配置管理（如通过管理界面实时调整限流参数）通常需要结合Nginx与Lua。鉴于团队对Java更为熟悉，而对Lua了解有限，选择在Java网关层开发，更利于团队的自主掌控和后续运维。</font></li>\n</ol>\n<h2 id=\"33-使用分布式限流还是统一限流\">3.3 使用分布式限流还是统一限流</h2>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">网关层本身通常是多节点部署的，这就引出了下一个问题：限流状态如何维护？</font></p>\n<ul>\n<li><strong><font style=\"color: rgba(15, 17, 21, 1);\">统一限流：</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">所有网关节点共享一个中心化的令牌桶（例如将令牌计数存放在Redis中）。这种方式看似精确，但引入了单点风险和性能瓶颈。在秒杀瞬间，所有网关节点都需要频繁访问Redis以争夺令牌，极易将Redis压垮，一旦Redis故障，全局限流即刻失效。</font></li>\n<li><strong><font style=\"color: rgba(15, 17, 21, 1);\">分布式限流：</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">每个网关节点独立维护自己的令牌桶。这需要我们预先将总TPS（100笔/秒）平均分配到每个节点。例如，若有10个网关节点，则每个节点的限流阈值设置为10笔/秒。</font></li>\n</ul>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">项目组经过权衡，选择了</font><font style=\"color: rgba(15, 17, 21, 1);\">分布式限流</font><font style=\"color: rgba(15, 17, 21, 1);\">。原因如下：</font></p>\n<ul>\n<li><strong><font style=\"color: rgba(15, 17, 21, 1);\">可靠性更高：</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">避免了Redis这个中心化组件的单点故障风险。即使部分网关节点失效，剩余节点仍能基于自身的令牌桶正常工作。</font></li>\n<li><strong><font style=\"color: rgba(15, 17, 21, 1);\">性能更优：</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">限流决策在各自内存中进行，无远程调用开销，速度极快。</font></li>\n<li><strong><font style=\"color: rgba(15, 17, 21, 1);\">带来的影响可接受：</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">其代价是，在部分节点失效时，总吞吐量会暂时下降（例如从100笔/秒降至50笔/秒），导致处理完所有请求的时间可能拉长（如从1秒变为2秒）。这在我们的业务容错范围内是可以接受的。</font></li>\n</ul>\n<h2 id=\"34-使用哪个开源技术\">3.4 使用哪个开源技术</h2>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">在Java技术栈中，项目组选择了</font><strong><font style=\"color: rgba(15, 17, 21, 1);\">Google Guava库中的RateLimiter类</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">来实现令牌桶算法。它是一个广泛验证、简单易用的内存式限流器。</font></p>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">在网关的Zuul过滤器中，我们这样配置和使用它：</font></p>\n<ol>\n<li><strong><font style=\"color: rgba(15, 17, 21, 1);\">核心参数配置</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">：</font>\n<ul>\n<li><font style=\"color: rgba(15, 17, 21, 1); background-color: rgba(235, 238, 242, 1);\"><code>permitsPerSecond</code></font><font style=\"color: rgba(15, 17, 21, 1);\">（令牌生成速率）：设为</font><font style=\"color: rgba(15, 17, 21, 1);\"> </font><strong><font style=\"color: rgba(15, 17, 21, 1);\">10</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">。这是由总TPS（100）除以网关节点数（10）计算得出，即每个节点每秒生成10个令牌。</font></li>\n<li><font style=\"color: rgba(15, 17, 21, 1); background-color: rgba(235, 238, 242, 1);\"><code>warmupPeriod</code></font><font style=\"color: rgba(15, 17, 21, 1);\">（预热期）：设为</font><font style=\"color: rgba(15, 17, 21, 1);\"> </font><strong><font style=\"color: rgba(15, 17, 21, 1);\">100毫秒</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">。这间接决定了单个节点令牌桶的容量。在预热模式下，此配置意味着桶容量约为1。结合10个节点，全局的“瞬时可用令牌”总量约为10，有效防止了机器人瞬间刷光库存。</font></li>\n</ul>\n</li>\n<li><strong><font style=\"color: rgba(15, 17, 21, 1);\">获取令牌策略</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">：</font>\n<ul>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">调用</font><font style=\"color: rgba(15, 17, 21, 1);\"> </font><font style=\"color: rgba(15, 17, 21, 1); background-color: rgba(235, 238, 242, 1);\"><code>tryAcquire(0, TimeUnit.SECONDS)</code></font><font style=\"color: rgba(15, 17, 21, 1);\"> </font><font style=\"color: rgba(15, 17, 21, 1);\">方法。超时时间设置为0，意味着请求若无法立即获取到令牌，将直接被快速失败（Fast-Fail），不进入等待队列，这符合秒杀场景高并发、即时反馈的要求。</font></li>\n</ul>\n</li>\n</ol>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">通过以上四个层次的决策，我们构建了一个基于令牌桶算法、部署于Java网关层、采用分布式部署模式，并借助Guava RateLimiter实现的具体限流方案。该方案在确保系统不被冲垮的同时，也兼顾了灵活性、可靠性与业务目标。</font></p>\n<h1 id=\"4-限流方案的注意事项\">4 限流方案的注意事项</h1>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">将限流方案部署上线只是第一步，要使其稳健、易用并能应对多场景，还需要关注以下几个工程细节。</font></p>\n<h2 id=\"41-限流---设计友好的限流响应\">4.1 限流 - <font style=\"color: rgba(15, 17, 21, 1);\">设计友好的限流响应</font></h2>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">限流的目的不是粗暴地拒绝用户，而是为了保障系统整体可用。因此，被限流请求的返回信息至关重要。</font></p>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">一个良好的实践是，为被限流的请求返回一个</font><font style=\"color: rgba(15, 17, 21, 1);\">特定的HTTP状态码</font><font style=\"color: rgba(15, 17, 21, 1);\">（例如</font><font style=\"color: rgba(15, 17, 21, 1);\"> </font><font style=\"color: rgba(15, 17, 21, 1); background-color: rgba(235, 238, 242, 1);\"><code>429 Too Many Requests</code></font><font style=\"color: rgba(15, 17, 21, 1);\">），而非通用的服务器错误码（如</font><font style=\"color: rgba(15, 17, 21, 1); background-color: rgba(235, 238, 242, 1);\"><code>500</code></font><font style=\"color: rgba(15, 17, 21, 1);\">）。这样，客户端（如App或前端）就能准确识别这是“流量限制”而非“系统故障”，从而展示更具引导性的友好提示。</font></p>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">例如，可以提示：“很遗憾，商品已秒光，欢迎关注下次活动。”在后续的活动中，我们甚至升级了提示：“部分订单可能因未及时支付而释放库存，请您10分钟后再来试试看。”这种设计显著提升了用户体验。</font>。</p>\n<h2 id=\"42-实时监控\">4.2 实时监控</h2>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">“看不见就无法管理”。必须对限流操作进行完整的日志记录，并建立实时监控仪表盘。这能帮助运维人员即时掌握：</font></p>\n<ul>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">限流是否已触发？触发的频率和规模如何？</font></li>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">被拒绝的请求量是否在预期范围内？</font></li>\n<li><font style=\"color: rgba(15, 17, 21, 1);\">系统整体流量与限流阈值的关系。</font></li>\n</ul>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">一旦监控指标出现异常（如限流突然失效或过早触发），团队可以快速介入排查，避免小问题演变为线上故障。</font></p>\n<h2 id=\"43-实时配置\">4.3 实时配置</h2>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">限流参数（如阈值、桶大小）不应是硬编码在代码中的。一个成熟的系统需要将配置外化，并支持</font><strong><font style=\"color: rgba(15, 17, 21, 1);\">动态调整</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">。</font></p>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">理想情况下，运维人员应能通过统一的配置中心，在不重启服务的情况下，实时修改不同API接口的限流规则。这种灵活性对于应对突发流量、进行业务调整或灰度发布都至关重要。</font></p>\n<h2 id=\"44-秒杀以外的场景限流配置\">4.4 秒杀以外的场景限流配置</h2>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">本次秒杀场景的目标值（100 TPS）是明确的业务结果。但在大多数日常限流场景中（如某个查询接口），正确的阈值需要通过压力测试来科学确定。我们需要根据系统的实际承载能力、业务优先级和SLA要求，来设定合理的QPS（每秒查询数）或TPS限制。切忌凭感觉配置。</font></p>\n<h1 id=\"5-小结\">5 小结</h1>\n<p><font style=\"color: rgba(15, 17, 21, 1);\">至此，我们完成了从业务场景分析、算法原理对比到具体方案落地和优化建议的完整闭环。这个基于令牌桶的分布式网关层限流方案，在实践中成功护航了秒杀活动。</font></p>\n<p><strong><font style=\"color: rgba(15, 17, 21, 1);\">核心回顾</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">：限流的原理（特别是滑动时间窗口与令牌桶算法）是理解所有工具的基础。一旦掌握了原理，使用任何现成库（如Guava RateLimiter）都会变得简单直接。</font></p>\n<p><strong><font style=\"color: rgba(15, 17, 21, 1);\">给开发者的提示</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">：限流与熔断是高并发系统面试中的高频考点。为了帮助你更好地准备，下面列举几个与之相关的典型问题，它们能很好地考察你对微服务稳定性的理解深度：</font></p>\n<ol>\n<li><strong><font style=\"color: rgba(15, 17, 21, 1);\">防超卖设计</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">：在秒杀架构中，除了限流，如何通过其他机制（如库存扣减）保证商品不会超卖？</font></li>\n<li><strong><font style=\"color: rgba(15, 17, 21, 1);\">熔断机制</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">：服务熔断的触发条件具体是什么？这些指标（如错误率、延迟）是如何被采集和计算的？</font></li>\n<li><strong><font style=\"color: rgba(15, 17, 21, 1);\">原理辨析</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">：限流和熔断的核心区别是什么？你了解几种限流算法？在项目中为何选择特定的一种？</font></li>\n<li><strong><font style=\"color: rgba(15, 17, 21, 1);\">运维与调优</font></strong><font style=\"color: rgba(15, 17, 21, 1);\">：上线后是否调整过熔断或限流的参数？调整的依据是什么（监控数据、压测结果）？又如何验证调整后的效果？</font></li>\n</ol>\n<hr />\n<p><font style=\"color: rgba(15, 17, 21, 1);\">关于微服务核心场景的讨论就到这里。在进入下一部分的“进阶场景实战”之前，我们需要先直面现实——微服务在带来巨大灵活性的同时，也引入了一系列新的挑战与痛点。下一章，我们将系统地梳理这些痛点，为后续的解决方案奠定基础。</font></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 15:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yhup\">yihuiComeOn</a>&nbsp;\n阅读(<span id=\"post_view_count\">57</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于SqlSugar开发框架的基础上快速开发H5端的移动应用",
      "link": "https://www.cnblogs.com/wuhuacong/p/19420561",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuhuacong/p/19420561\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 15:07\">\n    <span>基于SqlSugar开发框架的基础上快速开发H5端的移动应用</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n                <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在开发一些项目的时候，我们往往会基于一定的框架进行业务的开发，并结合一些辅助工具进行更高效率的快速开发和整合工作，SqlSugar开发框架是我们开发的一个多端整合的开发框架，基于它的后端WebAPI 基础上，我们可以对接WInform端、Vue3+ElementPlus的BS端，Vue3+Vant4的H5端，以及WPF、或者小程序等多端接入，本篇随笔介绍一个简单的项目录入功能，介绍基于SqlSugar开发框架的基础上快速开发H5端的移动应用。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在开发一些项目的时候，我们往往会基于一定的框架进行业务的开发，并结合一些辅助工具进行更高效率的快速开发和整合工作，SqlSugar开发框架是我们开发的一个多端整合的开发框架，基于它的后端框架的WebAPI 基础上，我们可以对接WInform端、Vue3+ElementPlus的BS端，Vue3+Vant4的H5端，以及WPF、或者小程序等多端接入，本篇随笔介绍一个简单的项目录入功能，介绍基于SqlSugar开发框架的基础上快速开发H5端的移动应用。</p>\n<h3>1、设计数据库</h3>\n<p>俗话说万层高楼从底起，开发应用项目，数据库的设计很重要，它可能是业务对象，业务流程的综合设计，好的数据库设计可以减少后期的重复返工，提高开发效率。</p>\n<p>一般表名称，根据不同的业务关系，我们可以使用不同的前缀进行区分，使用前缀，可以非常方便区分不同的业务表，如我自己一般基础表使用 “TB_” 定义前缀，权限系统表使用\"T_ACL_\"定义前缀，工作流表使用“TBAPP_”，业务表使用\"T_\"等，这样对于区分不同的业务，方便管理很有好处。</p>\n<p>字段名称方面，我们可以约定一些规则，如约定主键使用ID；一般来说，ID作为主键，可以使用自增长的整形字段，也可以使用GUID的字符型字段，如果为了方便兼容不同的数据库且方便迁移或者开发基于网络方面的应用，我建议还是使用GUID的字符型字段，使用这种类型的字段，我们从创建数据的时候，就可以知道这个记录的主键，对于我们维护父子表等关系非常有利。</p>\n<p>由于如果采用字符型的ID主键，那么我们如果需要正确排序的时候，可能需要增加一个CreateTime的日期类型，方便我们根据日期进行排序，或者特定的需要增加一个SortOrder字段。</p>\n<p>如果这个表还有一个外键的引用，建议统一命名标准，我一般使用“表名称_ID这样的名称，如User_ID、Contact_ID等相似的名称作为外键，不需要表的前缀。</p>\n<p>数据库的模型设计，我们建议在第三方的数据库设计工具上进行设计，如PowerDesigner这样的设计工具，使用工具设计数据库有很多好处，一个是可以高效率进行调整，二是根据需要生成不同的数据库类型Sql语句，三是可以全局了解各个表之间的关系等等。</p>\n<p>使用PowerDesigner这样的数据库设计工具，能够在很大程度上提高我们数据库的设计效率。我们默认以SQLServer数据库创建表，如下所示。</p>\n<p><img alt=\"image\" height=\"278\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230115810545-678368233.png\" width=\"323\" /></p>\n<p>设计好的数据表，在设计状态下，添加相关的备注信息。</p>\n<p><img alt=\"image\" height=\"467\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230115835170-756890014.png\" width=\"796\" /></p>\n<p>&nbsp;然后生成相关的SQL代码，我们就可以再具体的数据库管理工具上执行创建对应的表信息了。&nbsp;</p>\n<p><img alt=\"image\" height=\"466\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230115908156-1344039466.png\" width=\"794\" /></p>\n<p>&nbsp; 完成数据库表创建后，我们就完成了第一阶段的工作了。</p>\n<p>&nbsp;</p>\n<h3>2、生成SqlSugar开发框架的后端基础代码并整合</h3>\n<p>设计好数据库后，我们通过代码生成工具进行基于项目框架的代码生成，这样对于我们在开发新项目上有很好的好处，里面的项目层级、引用关系，已经处理好了，这样对我们非常方便。</p>\n<p>不过大多数情况下，我们都是增量开发较多，也就是我们可能前面已经完成了一些其他业务的开发，可能新增一个两个表，或者一批业务表的处理，我们生成相关的代码文件后把它们复制到项目恰当位置上即可。</p>\n<p>由于项目生成的时候，指定了主命名空间和相关的表前缀，这样我们生成后的代码就方便阅读很多，减少累赘和出错的机会。</p>\n<p>利用代码生成工具Database2Sharp强大的数据库元数据和模板引擎，我们构建了对应的框架代码生成规则，因此统一生成即可，提高了代码开发的效能，同时也统一了代码的结构，便于大项目的维护。</p>\n<p>对于SQLSugar的项目框架，我们为了方便，分别单独提供后端代码和Web API代码的生成、Winform界面代码的生成，以及前面介绍到的Vue3+TypeScript+ElementPlus的代码生成操作。</p>\n<p>代码生成工具的界面效果如下所示，通过入口菜单，可以实现不同部分的代码快速生成。我们先使用【Sqlsugar框架代码生成】生成后端的相关代码文件。</p>\n<p><img alt=\"image\" height=\"636\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230125345005-735899731.png\" width=\"1033\" /></p>\n<p>选择我们刚才创建的表进行一步步的生成即可。</p>\n<p><img alt=\"image\" height=\"406\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230142927634-577910459.png\" width=\"534\" /></p>\n<p>生成代码，我们可以看到相关的目录，如下所示。</p>\n<p><img alt=\"image\" height=\"591\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230143200345-246629280.png\" width=\"850\" /></p>\n<p>复制整合文件到框架项目的合适位置上，暂时不需要增加任何方法代码，我们利用继承的基类方法就完全满足需求 。</p>\n<p><img alt=\"image\" height=\"964\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230151121521-1088455216.png\" width=\"1017\" /></p>\n<p>&nbsp;</p>\n<h3>3、基于Vant4+Vue3+TypeScript的H5移动前端进行开发</h3>\n<div><strong>关于Vant4</strong></div>\n<div>\n<p>Vant 是一个<strong>轻量、可定制的移动端组件库</strong>，于 2017 年开源。目前 Vant 官方提供了&nbsp;<a href=\"https://vant-ui.github.io/vant/v2/\" rel=\"noopener nofollow\" target=\"_blank\">Vue 2 版本</a>、<a href=\"https://vant-ui.github.io/vant/\" rel=\"noopener nofollow\" target=\"_blank\">Vue 3 版本</a>和<a href=\"https://vant-ui.github.io/vant-weapp/\" rel=\"noopener nofollow\" target=\"_blank\">微信小程序版本</a>，并由社区团队维护&nbsp;<a href=\"https://github.com/3lang3/react-vant\" rel=\"noopener nofollow\" target=\"_blank\">React 版本</a>和<a href=\"https://github.com/ant-move/Vant-Aliapp\" rel=\"noopener nofollow\" target=\"_blank\">支付宝小程序版本</a>。</p>\n<p>当前移动端 项目采用最新的Vant4进行开发，适合于Vue3的项目开发。</p>\n<p>Vant 4 是一款基于 Vue 3 的轻量、可靠的手机端组件库，主要用于快速搭建移动端应用。它提供了许多常用的 UI 组件，如按钮、卡片、表单、导航等，旨在帮助开发者提高开发效率，同时保持应用的性能和一致性。</p>\n<p>Vant 4 是完全基于 Vue 3 构建的，充分利用了 Vue 3 的新特性和性能优化，如 Composition API、Teleport、Fragments 等。通过 Vue 3 的优化，Vant 4 在渲染性能上有了显著提升，特别是在处理大型列表和复杂组件时。</p>\n<p><a href=\"http://www.iqidi.com:8849/\" rel=\"noopener nofollow\" target=\"_blank\"><img alt=\"移动端H5应用\" height=\"296\" src=\"https://www.iqidi.com/Framework/images/vant-mobile.png\" width=\"296\" /></a></p>\n<p>&nbsp;扫码进行了解&nbsp;Vant4+Vue3+TypeScript 的移动前端。</p>\n<p>&nbsp;</p>\n</div>\n<p>接下来就是针对H5端应用进行的界面开发了，我们可以参考案例的滚动到底部进行分页处理的页面案例，对内容进行分页展示处理，如下所示是几个界面的效果。</p>\n<p><img alt=\"image\" height=\"741\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144121321-490674470.png\" width=\"346\" />&nbsp;&nbsp;<img alt=\"image\" height=\"742\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144148794-1515596057.png\" width=\"346\" />&nbsp;&nbsp;<img alt=\"image\" height=\"741\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144313426-902219873.png\" width=\"346\" /></p>\n<p>&nbsp;签名图片，我们通过调用通用的文件上传处理，把它上传到服务端的目录上了，使用的时候直接用其对应的地址即可。</p>\n<p><img alt=\"image\" height=\"334\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144611192-2014570350.png\" width=\"686\" /></p>\n<p>了解了界面效果，我们来看看具体的代码实现过程。</p>\n<p>我们首先增加或者使用代码生成工具生成一个api对接后端的文件，如下所示。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144808470-1588794631.png\" /></p>\n<p>这个文件很简单，就是继承基类即可，不需要增加任何自定义方法。</p>\n<div class=\"cnblogs_code\">\n<pre>import type { ListResult, PagedResult } from '@/api/types'<span style=\"color: rgba(0, 0, 0, 1);\">\nimport BaseApi from </span>'@/api/base-api'<span style=\"color: rgba(0, 0, 0, 1);\">\nimport { CommonResult } from </span>'@/api/types'<span style=\"color: rgba(0, 0, 0, 1);\">\nimport { http } from </span>'@/utils/http/axios'\n\n<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 导入API基类对象,默认具有Get/GetAll/Create/Update/Delete/BatchDelete/SaveImport/Count等接口</span><span style=\"color: rgba(0, 128, 0, 1);\">\n//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 业务类自定义接口实现, 通用的接口已经在BaseApi中定义</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">class Api <span style=\"color: rgba(255, 0, 0, 1);\"><strong>extends BaseApi</strong></span> {\n  </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 参考下面案例，增加自定义函数</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> GET 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 根据条件计算记录数量</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async GetCount(params: object) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpGet&lt;number&gt;(this.baseurl + \"count\", params);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> POST 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建对象</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async Create(data: object) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpPost&lt;boolean&gt;(this.baseurl + `create`, data);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> PUT 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 更新对象</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async Update(data: object) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpPut&lt;boolean&gt;(this.baseurl + `update`, data);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> DELETE 方法例子</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 删除指定ID的对象</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> async Delete(id: number | string) {</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">   return await this.HttpDelete&lt;boolean&gt;(this.baseurl + `${id}`);</span>\n  <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> }</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">}\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 构造测试工作项目 Api实例，并传递业务类接口地址</span>\nexport <span style=\"color: rgba(0, 0, 255, 1);\">default</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Api('<span style=\"color: rgba(255, 0, 0, 1);\"><strong>/api/testworkitem/</strong></span>')</pre>\n</div>\n<p>前端根据框架后端的接口进行前端JS端的类的封装处理，引入了ES6类的概念实现业务基类接口的统一封装，简化代码。这些类继承BaseApi，就会具有相关的接口了，如下所示继承关系。</p>\n<p><img alt=\"\" class=\"medium-zoom-image\" src=\"https://img2020.cnblogs.com/blog/8867/202007/8867-20200713152737929-890201160.png\" /></p>\n<p>我们已经在BaseApi的ES6类里面定义了对应Web API基类里面的操作方法，如下所示。</p>\n<p><img alt=\"\" class=\"medium-zoom-image\" height=\"595\" src=\"https://img2022.cnblogs.com/blog/8867/202207/8867-20220707112405599-7103386.png\" width=\"966\" /></p>\n<p>&nbsp;这样，我们在创建一个业务类的时候，如果没有特殊的自定义接口，只需要继承基类BaseApi即可具有所有的常规基类方法了。</p>\n<p>&nbsp;由于我们的ES6接口定义，是基于TypeScript的，它的数据类型可以推断出来，因此在编码或者查看对应属性的时候，会有非常好的提示信息。</p>\n<p>对应几个不同的页面场景，我们分别创建不同的视图文件，如下所示。</p>\n<p><img alt=\"image\" height=\"454\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230145310033-599021859.png\" width=\"479\" /></p>\n<p>&nbsp;由于Vue3+Typescript+Vant4的H5应用端是基于VueRouter的路由处理，因此，我们需要在路由模块中增加对应的路由定义，如下所示。</p>\n<p><img alt=\"image\" height=\"863\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230145553832-1840777761.png\" width=\"1065\" /></p>\n<p>&nbsp;最后我们就可以再主页面提供一个入口，访问当前的模块了。如我们在列表页面模块中，首先需要引入对应的API调用类，以及定义对应的实体对象。</p>\n<p><img alt=\"image\" height=\"833\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230145818721-1359007905.png\" width=\"1073\" /></p>\n<p>&nbsp;页面只需要调用BaseApi的基类封装函数即可实现滚动继续分页获取记录的处理。</p>\n<p><img alt=\"image\" height=\"1309\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230150032578-1409793504.png\" width=\"1078\" /></p>\n<p>&nbsp;结合Vant4的相关控件，我们可以把记录的内容展示出来。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"scroll-container\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">page-header </span><span style=\"color: rgba(255, 0, 0, 1);\">@click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"goback\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-search </span><span style=\"color: rgba(255, 0, 0, 1);\">v-model</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"searchValue\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> placeholder</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"请输入搜索关键词\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @search</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"onSearch\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @clear</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"clearInput\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-list\n      </span><span style=\"color: rgba(255, 0, 0, 1);\">v-model:loading</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"loading\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n      :finished</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"finished\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n      finished-text</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"没有更多了\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n      @load</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"onRefresh\"</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-swipe-cell\n        </span><span style=\"color: rgba(255, 0, 0, 1);\">v-for</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"(item, index) in list\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n        :key</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"index\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n        class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"m-2 overflow-hidden border border-gray-300 rounded-[12px]\"</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 主体内容 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">template </span><span style=\"color: rgba(255, 0, 0, 1);\">#default</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"box-border min-w-0 w-full flex flex-row items-start p-2\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 图片区域 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-image\n              </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"h-[100px] w-[100px] flex-shrink-0 rounded-md\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n              fit</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"contain\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n              :src</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"!isNullOrUnDef(item.creatsign) ? item.creatsign : '/images/img_nodata.png'\"</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n\n            <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 文本区域 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div\n              </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"ml-4 min-w-0 flex-1\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n              @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"showDetail(item.id ?? '')\"</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n              <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"whitespace-normal break-words text-base font-medium\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                {{ item.item1 }}/{{ item.item2 }}/{{ item.item3 }}/{{ item.item4 }}\n              </span><span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n              <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"mt-2 flex flex-col whitespace-normal break-words text-sm text-gray-500\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                    状态:\n                    </span><span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-tag </span><span style=\"color: rgba(255, 0, 0, 1);\">:type</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"getStatusTag(item.status ?? 0)\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span><span style=\"color: rgba(0, 0, 0, 1);\">\n                    {{ getStatus(item.status) }}\n                  </span><span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-tag</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>{{ format(item.createtime) }}<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">span</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n              <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 删除按钮 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">template </span><span style=\"color: rgba(255, 0, 0, 1);\">#right</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"h-full w-[64px] flex items-center justify-center bg-red-500\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-icon </span><span style=\"color: rgba(255, 0, 0, 1);\">name</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"delete\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> color</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"#fff\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> size</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"20\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"deleteItem(item)\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n          <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-swipe-cell</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-list</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"m-2\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar-icon </span><span style=\"color: rgba(255, 0, 0, 1);\">text</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"返回\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> icon</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"arrow-left\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"goback\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n      <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar-button </span><span style=\"color: rgba(255, 0, 0, 1);\">color</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"green\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> text</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"创建工作项目\"</span><span style=\"color: rgba(255, 0, 0, 1);\"> @click</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"createItem\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">van-action-bar</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">div </span><span style=\"color: rgba(255, 0, 0, 1);\">class</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"mb-20\"</span> <span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">van-back-top </span><span style=\"color: rgba(0, 0, 255, 1);\">/&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">div</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">template</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span></pre>\n</div>\n<p>从而实现了我们前面介绍的页面效果。</p>\n<p><img alt=\"image\" height=\"741\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230144121321-490674470.png\" width=\"346\" />&nbsp;&nbsp;<img alt=\"image\" height=\"746\" src=\"https://img2024.cnblogs.com/blog/8867/202512/8867-20251230150350899-1651155846.png\" width=\"348\" /></p>\n<p>&nbsp;其他页面的效果也是类似，参考相关的界面实现来调整展示效果即可，不在赘述。</p>\n<p>&nbsp;如需进一步了解H5应用端的功能介绍，可以参考随笔《<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuhuacong/p/19039255\" id=\"cb_post_title_url\" title=\"发布于 2025-08-15 13:36\">基于Vant4+Vue3+TypeScript的H5移动前端</a>》，进行深入的了解。</p>\n</div>\n<div id=\"MySignature\">\n    <div style=\"border-right-color: #cccccc; border-right-width: 1px; border-right-style: solid; padding-right: 5px; border-top-color: #cccccc; border-top-width: 1px; border-top-style: solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left-color: #cccccc; border-left-width: 1px; border-left-style: solid; width: 98%; padding-top: 4px; border-bottom-color: #cccccc; border-bottom-width: 1px; border-bottom-style: solid; background-color: #eeeeee;\">\n    <img align=\"top\" alt=\"\" src=\"http://www.cnblogs.com/Images/OutliningIndicators/None.gif\" />\n    <span style=\"color: #000000;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"></span>\n     专注于代码生成工具、.Net/Python 框架架构及软件开发，以及各种Vue.js的前端技术应用。著有Winform开发框架/混合式开发框架、微信开发框架、Bootstrap开发框架、ABP开发框架、SqlSugar开发框架、Python开发框架等框架产品。\n     <br />&nbsp;&nbsp;转载请注明出处：撰写人：伍华聪&nbsp;&nbsp;<a href=\"http://www.iqidi.com/\" target=\"_blank\">http://www.iqidi.com</a>&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;</span></div>\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2025-12-30 15:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wuhuacong\">伍华聪</a>&nbsp;\n阅读(<span id=\"post_view_count\">257</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "实用程序：Python打造进程网络监控与分析工具——全方位掌握你的网络与进程状态",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19421354",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19421354\" id=\"cb_post_title_url\" title=\"发布于 2025-12-30 14:57\">\n    <span>实用程序：Python打造进程网络监控与分析工具——全方位掌握你的网络与进程状态</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文介绍了一款基于Python开发的GUI网络监控工具，能够实时监控进程网络活动、分析端口占用情况、诊断网络问题。该工具支持Windows系统，提供进程带宽管理、端口筛选、网速测试、路由追踪等功能，并可将数据导出为CSV或图表。界面简洁易用，集成实时刷新、带宽限制等高级功能，适合普通用户排查网络故障和开发者分析程序行为。项目已开源，包含详细功能展示和操作指南，后续将优化多平台兼容性。代码地址：https://github.com/ChenAI-TGF/SysNetMonitor_GUI\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>在日常使用电脑的过程中，你是否好奇过这些困惑：为什么网络突然变卡？哪个进程在偷偷占用大量带宽？某个端口被哪个程序占用了？为了解决这些问题，博主用python开发了一款「进程网络监控与分析工具」，它能全方位监控网络状态、分析进程网络行为、诊断网络问题，帮你轻松掌握系统网络全貌。程序涵盖进程网络监控，系统总带宽波动查询，网络环境信息，端口占用监控，网络诊断服务，限制宽带等全面的功能，并配有UI界面，0上手门槛！</p>\n<p><strong>代码已开源到Github，欢迎访问下载：<a href=\"https://github.com/ChenAI-TGF/SysNetMonitor_GUI\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/SysNetMonitor_GUI</a><br />\n如果觉得好用的话可以点点Star，十分感谢！！</strong><br />\n<strong>也可以直接私信我要开源代码</strong></p>\n<p>先来个界面预览：<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"项目简介\">项目简介</h1>\n<p>这款工具是基于Python开发的GUI应用，旨在为用户提供直观、全面的网络与进程监控能力。无论是普通用户排查网络故障，还是开发者分析程序网络行为，都能满足需求。工具支持Windows主流系统，部分功能兼容Linux/macOS，界面简洁大方，操作简单易上手。</p>\n<h1 id=\"环境要求\">环境要求</h1>\n<p>在使用工具前，需确保你的环境满足以下要求：</p>\n<ul>\n<li><strong>Python版本</strong>：3.7及以上（推荐3.9+，兼容性更佳）</li>\n<li><strong>支持系统</strong>：主要支持Windows（部分功能兼容Linux/macOS）</li>\n<li><strong>依赖库</strong>：\n<ul>\n<li>内置库：tkinter、ctypes、platform、socket（无需额外安装）</li>\n<li>第三方库：psutil（进程与系统监控）、ttkbootstrap（UI美化）、matplotlib（图表绘制）、numpy（数据处理）、requests（网络请求）、netifaces（网络接口信息）、speedtest-cli（网速测试）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"核心功能详解\">核心功能详解</h1>\n<p>工具包含多个大核心功能模块，覆盖从进程监控到网络诊断的全场景需求，以下是详细介绍：</p>\n<h2 id=\"1-进程网络监控\">1. 进程网络监控</h2>\n<p>这是工具的核心功能之一，能够实时展示系统中所有进程的网络活动状态。</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>实时监控</strong>：显示进程的PID、名称、本地/远程IP端口、上传/下载速度、总流量等关键信息。</li>\n<li><strong>详情查看</strong>：双击任意进程，可打开详情窗口，查看该进程的带宽变化曲线（支持实时刷新）、历史网络活动记录。</li>\n<li><strong>带宽管理</strong>：在进程详情窗口中，可设置上传/下载带宽预警阈值（当超过阈值时会触发提醒）；在主界面选中进程后，点击「限制进程带宽」可手动限制其网络速度。</li>\n</ul>\n<h2 id=\"2-端口占用监控\">2. 端口占用监控</h2>\n<p>轻松网络调试中，端口占用是常见问题，该模块可快速定位端口占用情况：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>端口信息全展示</strong>：表格列出所有端口的协议类型（TCP/UDP）、本地IP和端口、远程IP和端口、连接状态、所属进程PID及名称。</li>\n<li><strong>精准筛选</strong>：支持通过端口号搜索和协议类型（TCP/UDP/全部）筛选，快速定位目标端口。</li>\n<li><strong>关联进程</strong>：双击端口查看端口对应的进程名称和PID，方便直接占用端口的程序（双击端口记录可跳进程详情）。</li>\n</ul>\n<h2 id=\"3-网络环境信息\">3. 网络环境信息</h2>\n<p>全面展示当前网络环境的基础信息，帮你快速了解当前网络配置：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>网络概览</strong>：包含公网IP、运营商信息、ASN（自治系统编号）、网络类型（有线/无线）、默认网关、DNS服务器、网络延迟和丢包率。</li>\n<li><strong>网卡详情</strong>：显示所有网卡的详细信息，包括网卡名称、MAC地址、IP地址（IPv4/IPv6）、子网掩码、广播地址等。</li>\n<li><strong>一键刷新</strong>：点击「刷新网络信息」按钮，可实时更新所有网络环境数据。</li>\n</ul>\n<h3 id=\"4-网络诊断工具\">4. 网络诊断工具</h3>\n<p>集成网络故障排查提供实用功能：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>网速测试</strong>：测试当前网络的上传/下载速度（基于speedtest-cli）。</li>\n<li><strong>Ping测试</strong>：输入目标IP或域名，执行Ping命令，查看延迟和丢包情况。</li>\n<li><strong>路由追踪</strong>：追踪数据包从本地到目标地址的路由路径，定位网络瓶颈节点。</li>\n</ul>\n<h2 id=\"5-数据导出与分析\">5. 数据导出与分析</h2>\n<p>支持将监控数据导出保存，方便后续分析：</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<ul>\n<li><strong>数据导出</strong>：在「操作面板」标签页，可将进程网络数据、端口占用数据导出为CSV格式，便于用Excel等工具进一步分析。</li>\n<li><strong>图表导出</strong>：在进程详情窗口的带宽曲线图中，点击「导出图表」可将实时带宽曲线保存为PNG图片。</li>\n</ul>\n<p>导出效果如下<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"6-进程具体数据分析\">6. 进程具体数据分析</h2>\n<h3 id=\"61-基本信息\">6.1 基本信息</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"62-网络信息\">6.2 网络信息</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"62-带宽曲线图\">6.2 带宽曲线图</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"64-连接详情\">6.4 连接详情</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"65-流量分析\">6.5 流量分析</h3>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"使用方法\">使用方法</h1>\n<h2 id=\"1-运行应用\">1. 运行应用</h2>\n<ul>\n<li>直接执行脚本：<code>python 你的脚本文件名.py</code></li>\n<li>执行脚本之后，如果你不是以管理员权限运行的脚本，程序会询问你是否可以用管理员权限来执行，选择是既可<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></li>\n</ul>\n<h3 id=\"2-基本操作\">2. 基本操作</h3>\n<ul>\n<li>各标签页均均有「刷新」按钮，点击可手动更新数据。</li>\n<li>在「进程网络监控」标签页双击进程，打开详情窗口；在「端口占用监控」标签页双击端口记录，查看对应进程信息。</li>\n</ul>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"3-高级功能\">3. 高级功能</h3>\n<ul>\n<li>\n<p><strong>带宽限制设置</strong>：在进程详情窗口配置该进程上传和下载的带宽限制。<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p><strong>多条件筛选</strong>：端口监控支持组合筛选（端口号+协议），快速定位异常连接。</p>\n</li>\n</ul>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"项目亮点\">项目亮点</h2>\n<ol>\n<li><strong>功能全面</strong>：整合进程监控、端口分析、网络诊断、数据导出等功能，一站式解决网络监控需求。</li>\n<li><strong>界面友好</strong>：基于ttkbootstrap打造的UI，简洁美观，操作逻辑清晰，适合各类用户。</li>\n<li><strong>实时性强</strong>：数据刷新及时，带宽曲线实时绘制，能精准反映网络状态变化。</li>\n<li><strong>跨平台潜力</strong>：核心功能在Linux/macOS上可兼容，未来将进一步完善多平台支持。</li>\n</ol>\n<h2 id=\"总结\">总结</h2>\n<p>这款进程网络监控与分析工具旨在为用户提供透明、可控的网络管理能力。无论是普通用户解决网络卡顿问题，还是开发者调试程序网络行为，都能从中受益。目前工具已实现核心功能，后续将持续优化多平台兼容性，并增加更多高级分析功能（如网络流量趋势预测、异常连接智能预警等）。</p>\n<p><strong>代码已开源到Github，欢迎访问下载：<a href=\"https://github.com/ChenAI-TGF/SysNetMonitor_GUI\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/SysNetMonitor_GUI</a><br />\n如果觉得好用的话可以点点Star，十分感谢！！</strong></p>\n<p>如果你也有网络监控的需求，欢迎尝试这款工具，如有问题或建议，欢迎在项目仓库留言交流！<br />\n<strong>也可以直接私信我要开源代码</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-30 14:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\n阅读(<span id=\"post_view_count\">123</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "独立开发者的一周：把生活和项目都推进一点点",
      "link": "https://www.cnblogs.com/deali/p/19423734",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/deali/p/19423734\" id=\"cb_post_title_url\" title=\"发布于 2025-12-31 00:23\">\n    <span>独立开发者的一周：把生活和项目都推进一点点</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>上周日我写下<a href=\"https://blog.deali.cn/p/independent-developer-week-i-really-started-project\" rel=\"noopener nofollow\" target=\"_blank\">「独立开发者的一周」系列的第一篇文章</a>。</p>\n<p>很快一周时间过去了，又到了总结的时候。</p>\n<p>最近除了日常工作外，我竟然连续坚持了一个多星期的公众号日更！（叉腰）</p>\n<p>由此也意识到了那些连续一年，甚至好几年日更的博主是具有何等的毅力👍</p>\n<p>连续更新且保持文章质量确实不容易，不过努力也得到了回报，这周达成了公众号生涯的不少成就，这个等下再写。</p>\n<p>按惯例，先来记录本周的工作。</p>\n<h2 id=\"本周关键词\">本周关键词</h2>\n<p>Taro3、Granian、内容发布工作流、第一次独自看电影、生活也值得一点小题大作</p>\n<h2 id=\"上周计划回顾--项目工作\">上周计划回顾 &amp; 项目工作</h2>\n<p>首先回顾一下上周立的 flag：</p>\n<ul>\n<li>把Y项目的几个主要界面做起来</li>\n<li>完成DjangoStarter项目的Granian/Celery集成</li>\n<li>看电影</li>\n<li>再评估一下用不用 AI 做点提升</li>\n</ul>\n<p>很庆幸我对自己有点自知之明，没定太多目标，否则这周就要写检讨了😅</p>\n<p>不过整体完成度还算不错：</p>\n<ul>\n<li>Y项目（也就是小程序），完成了原计划的70%吧，本周初步做了6个界面，关键功能也做了1个，算是马马虎虎；</li>\n<li>DjangoStarter的Granian集成已经完成了，详见: <a href=\"https://blog.deali.cn/p/granian-django-asgi-server\" rel=\"noopener nofollow\" target=\"_blank\">性能提升4倍！使用Granian作为Django项目的ASGI服务器</a> ，但 Celery 集成还没做，所以这个计划只算完成了 50% 😂</li>\n<li>看电影计划达成，去电影院看了《鬼灭之刃》，还去快闪店领了周边，计划完成度 100%</li>\n<li>用 AI 做提升，也实现了，我用 AI 优化了一下我的内容发布工作流，主要是和 <a href=\"https://blog.deali.cn/p/starblog-publisher-deepseek-tool\" rel=\"noopener nofollow\" target=\"_blank\">StarBlog Publisher</a> 工具有关的部分，小幅度提升内容发布效率。</li>\n</ul>\n<p>下面展开说说</p>\n<h3 id=\"小程序y项目\">小程序Y项目</h3>\n<p>之前小程序有两个拦路虎：备案&amp;认证、代码框架的坑。</p>\n<p>这周备案终于办完了。第一次工信部发短信时我还忘记填验证码… 过期后只能重新提交，好在第二次很快通过。</p>\n<p>我记得当时收到备案通过的信息还在公交车上🤣</p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/406eb7b772c3512e/80ef3758572ef375.png\" /></p>\n<p>框架方面，我看到有网友在上周末的文章里留言吐槽 Taro，不过我还是决定继续用 <strong>Taro3</strong>。</p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/406eb7b772c3512e/1a21ac29acdd7590.jpg\" /></p>\n<p>原因就是我之前用这套代码开发过几个小程序，不想再去重新熟悉其他框架，太浪费时间。</p>\n<p>而且目前来看 Taro3 也够用，uniapp 虽说很多人推荐，我几年前也简单用过，但一个不支持 react，另一个打包超过 size 要收费，我就没考虑了。</p>\n<h3 id=\"djangostarter项目\">DjangoStarter项目</h3>\n<p><a href=\"https://github.com/Deali-Axy/DjangoStarter\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Deali-Axy/DjangoStarter</a></p>\n<p>本周其实不止做了 Granian 集成，还做了大量优化，完成了 v3.2.1 之后的又一个版本迭代，把版本号拉到 v3.3.0 了，不过新版本发布的文章我还没写好🤣</p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/406eb7b772c3512e/346c5530335739dd.jpg\" /></p>\n<p>我发现搞这种开源项目，不单是为爱发电，还是时间黑洞。</p>\n<p>这项目 star 没多少，issues 却不少，日常要把工作中遇到的需求抽象成通用功能，还得回答问题、修补 bug、写文档……</p>\n<p>经常是，打开项目 → 一抬头 → 半夜了🥱</p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/406eb7b772c3512e/ab53b63a1ab92590.jpg\" /></p>\n<h2 id=\"下周计划\">下周计划</h2>\n<ul>\n<li>继续做小程序Y项目的界面，完成第一版规划的前端功能</li>\n<li>完成DjangoStarter项目的Celery集成</li>\n<li>留出时间处理公司事项 &amp; 为ToB项目做前期准备</li>\n<li>再看一部电影（这个项目看起来要常驻了😄）</li>\n</ul>\n<h2 id=\"碎碎念\">碎碎念</h2>\n<p>这两周的节奏不像以前那样单线：上班 → 写代码 → 睡觉。</p>\n<p>反而是在工作、项目、更新内容、生活体验之间切换，节奏更清爽，也更有参与感。</p>\n<p>我越来越觉得：</p>\n<p><strong>独立开发不应该只是技术的事，更是一种把生活调成自己喜欢的姿态的方式。</strong></p>\n<h3 id=\"看电影\">看电影</h3>\n<p>第一次一个人去电影院，</p>\n<p>电影全名是《鬼灭之刃：无限城篇 第一章 猗窝座再袭》。</p>\n<p><strong>（以下内容剧透警告⚠️）</strong></p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/406eb7b772c3512e/ac3a08c83c48fc22.jpg\" /></p>\n<p>我原以为周一下午电影院会是包场，结果后排还有一个女生，全程不断抽鼻子…这电影确实有不少哭点，但是这么夸张的吗🤣</p>\n<p>听说这次是难得的无删减，所以我才起了去看的念头，确实能值回票价，就是之前没看过鬼灭之刃，并不了解这个故事，一开始看的时候一脸懵逼的，后座的女生一会哭一会笑，我都没get到😂</p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/406eb7b772c3512e/523f4e4357e524e9.jpg\" /></p>\n<p>不过看到一半的时候已经能大概理清了，前半部就是鬼杀队的柱成员一对一打鬼阵营的上弦。（蝴蝶忍好可怜😭）</p>\n<p>后半部分就是炭治郎、义勇打猗窝座，期间插入回忆与技能讲解，这部分共一个半小时，是全片占比最大的情节，毕竟标题就是这个嘛。</p>\n<p>猗窝座的最后剧情杀，还是有点催泪的。</p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/406eb7b772c3512e/1d1fec41aec0e660.jpg\" /></p>\n<p>电影之外，突然觉得，以后应该多花些时间体验生活，以前真就一直埋头工作，人生要是只剩代码的栈和队列的话也太无趣了。</p>\n<h3 id=\"去快闪店领了周边\">去快闪店领了周边</h3>\n<p>得知电影票能领周边后，我第二天就去快闪店了😄</p>\n<p>这个票价感觉更值了~</p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/406eb7b772c3512e/7cea87777d78007b.jpg\" /></p>\n<p>就是这些周边产品还是有点小贵的，我靠理智捂住了钱包。</p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/406eb7b772c3512e/d7cda2f31dd2bcb.jpg\" /></p>\n<p>电影票领的周边是盲盒形式的胶片，我还没拆开，不知道里面是啥，下周来拆开看看。</p>\n<p><s>到时又能水一篇文章（误）</s></p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/406eb7b772c3512e/5e078700be9d61b3.jpg\" /></p>\n<h3 id=\"体验了一下小城市的公交\">体验了一下小城市的公交</h3>\n<p>说起来很神奇，我居然没坐过汕头的公交车🤣</p>\n<p>发现羊城通可以刷之后我去快闪店的路上试了一下公交车，感觉emmm，下次还是自己开车吧…</p>\n<h3 id=\"努力总会开花结果的\">努力总会开花结果的</h3>\n<p>上周的计划完成度不高还有一个原因是，这周陆续有几个之前准备的 ToB 项目开始进行了。</p>\n<p>所以我也花了很多时间来处理这些事情，希望到年底会有一些成果出来~</p>\n<p>另外，本周还达成了公众号的三个新成就！</p>\n<p>我本来以为到 5000 关注之前就不会有其他足迹了，没想到还给我整了三个😄</p>\n<p><img alt=\"\" src=\"https://blog.deali.cn/media/blog/406eb7b772c3512e/2811260212cafeb8.jpg\" /></p>\n<p>每个成就奖励几个个曝光，对于关注数量不多的公众号来说还是很不错的。</p>\n<p>感觉现在公众号生态受到小红薯、短视频之类的冲击很大，官方应该也被迫做了不少调整。</p>\n<p>新的推荐机制对于本身关注不多的公众号来说是好事，最近我的文章阅读量也多起来了。只不过要靠公众号赚钱还是不太可能的🤣，就当分享生活了~</p>\n<h2 id=\"小结\">小结</h2>\n<p>这一周没有什么特别的成就，但每一件小事都在推动我往前一点。</p>\n<p>项目动了、开源贡献了、生活体验增加了、内容输出也稳定了。</p>\n<p>我开始更确定一件事：</p>\n<p><strong>独立开发不是“做了什么”，而是“持续把事情往前推”。每周一小步，一年回头看就是很大的跨度。</strong></p>\n<p>加油💪</p>\n\n</div>\n<div id=\"MySignature\">\n    微信公众号：「程序设计实验室」\n专注于互联网热门新技术探索与团队敏捷开发实践，包括架构设计、机器学习与数据分析算法、移动端开发、Linux、Web前后端开发等，欢迎一起探讨技术，分享学习实践经验。\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-31 00:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/deali\">程序设计实验室</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}