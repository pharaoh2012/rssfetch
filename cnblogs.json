{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "持续集成的价值流——质量门禁、报告可视化与快速反馈的设计重点",
      "link": "https://www.cnblogs.com/shiyuelp/p/19492092",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shiyuelp/p/19492092\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 14:53\">\n    <span>持续集成的价值流——质量门禁、报告可视化与快速反馈的设计重点</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>写在前面，本人目前处于求职中，如有合适内推岗位，请加：lpshiyue 感谢。同时还望大家一键三连，赚点奶粉钱。</strong></p>\n<p><strong>系列文章已完结，全文阅读链接：<a href=\"https://p.kdocs.cn/s/EJACICRFACQBS\" rel=\"noopener nofollow\" target=\"_blank\">https://p.kdocs.cn/s/EJACICRFACQBS</a></strong></p>\n<blockquote>\n<p>持续集成的真正价值不在于工具链的复杂程度，而在于反馈速度与质量保障的完美平衡</p>\n</blockquote>\n<p>在确立契约测试作为微服务协作的基石后，我们面临一个更关键的工程挑战：如何将质量保障无缝融入持续交付流水线。持续集成（CI）已成为现代软件开发的标配，但大多数团队仅停留在\"定期集成\"层面，未能充分发挥其价值流潜力。本文将从价值流视角深入分析质量门禁、报告可视化与快速反馈的设计原则，帮助团队构建高效可靠的CI/CD体系。</p>\n<h2 id=\"1-持续集成的价值流本质\">1 持续集成的价值流本质</h2>\n<h3 id=\"11-从集成频率到价值流动的思维转变\">1.1 从集成频率到价值流动的思维转变</h3>\n<p>传统持续集成强调<strong>代码提交频率</strong>，而现代CI的价值流关注<strong>代码从提交到生产的完整流动效率</strong>。价值流分析不仅衡量集成次数，更关注<strong>滞留时间</strong>、<strong>转化率</strong>和<strong>质量损耗</strong>。</p>\n<p><strong>价值流的核心指标</strong>包括：</p>\n<ul>\n<li><strong>前置时间</strong>：从代码提交到生产部署的总时间</li>\n<li><strong>流程时间</strong>：代码在CI流水线中的实际处理时间</li>\n<li><strong>百分位耗时</strong>：P50、P95、P99的流水线执行时间，反映稳定性</li>\n<li><strong>质量门禁通过率</strong>：首次提交即通过所有检查的比例</li>\n<li><strong>反馈闭环效率</strong>：从问题发现到修复确认的周期</li>\n</ul>\n<p>工商银行软件开发中心在DevOps转型中发现，优化价值流而非单纯提升集成频率，能将交付效率提升35%以上。</p>\n<h3 id=\"12-价值流瓶颈的识别与消除\">1.2 价值流瓶颈的识别与消除</h3>\n<p>价值流映射（Value Stream Mapping）是识别CI瓶颈的关键工具。通过可视化代码从提交到部署的完整路径，可以识别四大类瓶颈：</p>\n<p><strong>协作瓶颈</strong>：团队等待代码审查、合并授权<br />\n<strong>测试瓶颈</strong>：顺序执行的漫长测试套件<br />\n<strong>环境瓶颈</strong>：测试环境争夺或配置复杂<br />\n<strong>反馈瓶颈</strong>：结果分散在不同工具中，缺乏统一视图</p>\n<div class=\"mermaid\">graph TD\n    A[代码提交] --&gt; B[静态检查]\n    B --&gt; C[单元测试]\n    C --&gt; D[集成测试]\n    D --&gt; E[部署测试环境]\n    E --&gt; F[验收测试]\n    F --&gt; G[生产部署]\n    \n    B --&gt;|快速失败| H[开发者反馈]\n    C --&gt;|快速失败| H\n    D --&gt;|详细报告| I[团队反馈]\n    E --&gt;|环境状态| J[运维反馈]\n    F --&gt;|业务验证| K[产品反馈]\n    \n    style H fill:#e1f5fe\n    style I fill:#fff3e0\n    style J fill:#f3e5f5\n    style K fill:#e8f5e8\n</div><p><em>持续集成价值流与反馈节点图</em></p>\n<h2 id=\"2-质量门禁体系的设计哲学\">2 质量门禁体系的设计哲学</h2>\n<h3 id=\"21-质量门禁的层次化策略\">2.1 质量门禁的层次化策略</h3>\n<p>质量门禁不是单一关卡，而是<strong>分层防御体系</strong>。合理的门禁设计应在保证质量的同时最小化开发阻力。</p>\n<p><strong>代码级门禁</strong>是最早的防线，关注代码基本质量：</p>\n<ul>\n<li><strong>静态代码分析</strong>：复杂度、重复率、代码异味</li>\n<li><strong>安全扫描</strong>：潜在漏洞、依赖组件风险</li>\n<li><strong>编码规范</strong>：团队约定的风格一致性</li>\n</ul>\n<p><strong>验证级门禁</strong>确保功能正确性：</p>\n<ul>\n<li><strong>单元测试覆盖率</strong>：关键模块覆盖率达到80%以上</li>\n<li><strong>集成测试</strong>：服务间接口验证</li>\n<li><strong>API契约测试</strong>：基于OpenAPI规范的接口合规性</li>\n</ul>\n<p><strong>部署级门禁</strong>保障发布可靠性：</p>\n<ul>\n<li><strong>健康检查</strong>：服务启动后自验证</li>\n<li><strong>性能基准</strong>：关键API的响应时间阈值</li>\n<li><strong>合规检查</strong>：安全策略、审计要求</li>\n</ul>\n<p>京东云DevOps平台通过分层质量门禁，在双11大促期间实现了故障率降低50%以上的效果。</p>\n<h3 id=\"22-智能门禁与动态阈值\">2.2 智能门禁与动态阈值</h3>\n<p>固定阈值的门禁在复杂项目中往往成为开发阻力。<strong>智能门禁</strong>根据代码变更特征动态调整标准：</p>\n<pre><code class=\"language-yaml\"># 智能门禁配置示例\nquality_gates:\n  test_coverage:\n    base_requirement: 80%\n    adjustment_rules:\n      - if: change_type == 'bugfix'\n        then: requirement = 75%  # 修复代码适当放宽\n      - if: files_modified contains 'legacy/'\n        then: requirement = 70%  # 遗留代码特殊处理\n      - if: lines_added &lt; 10\n        then: requirement = 60%  # 微小变更降低要求\n  \n  static_analysis:\n    base_requirement: zero_new_critical\n    adjustment_rules:\n      - if: is_hotfix == true\n        then: allow_1_critical  # 热修复允许1个严重问题\n</code></pre>\n<p>这种基于上下文的动态阈值既保证了质量底线，又避免了不必要的开发阻碍。</p>\n<h3 id=\"23-质量门禁的流水线集成模式\">2.3 质量门禁的流水线集成模式</h3>\n<p>门禁与流水线的集成方式直接影响反馈效率。<strong>并行检查</strong>模式可以大幅缩短反馈周期：</p>\n<pre><code class=\"language-yaml\"># 并行门禁检查配置\nstages:\n  - prepare\n  - quality_checks\n  - deployment\n\nquality_checks:\n  stage: quality_checks\n  parallel:  # 并行执行质量检查\n    - script: sonar-scanner\n      name: sonarqube_analysis\n    - script: npm run security-scan\n      name: security_scan\n    - script: pytest --cov --cov-report=xml\n      name: test_coverage\n  allow_failure: false\n</code></pre>\n<p>当检查任务较多时，通过<strong>依赖关系分析</strong>优先执行关键路径检查，进一步优化反馈速度。</p>\n<h2 id=\"3-报告可视化从数据噪音到决策洞察\">3 报告可视化：从数据噪音到决策洞察</h2>\n<h3 id=\"31-多层次可视化设计原则\">3.1 多层次可视化设计原则</h3>\n<p>报告可视化不是简单的数据展示，而是<strong>问题定位和决策支持的认知工具</strong>。有效的可视化应遵循<strong>金字塔原则</strong>：顶层展示核心健康度，支持逐层下钻分析。</p>\n<p><strong>流水线健康度全景图</strong>为团队提供一站式视图：</p>\n<ul>\n<li><strong>构建成功率趋势</strong>：识别稳定性问题</li>\n<li><strong>测试覆盖率变化</strong>：监控质量演进</li>\n<li><strong>门禁通过率统计</strong>：评估代码提交质量</li>\n<li><strong>构建时间分布</strong>：发现性能退化</li>\n</ul>\n<p><strong>失败分析视图</strong>帮助快速定位问题：</p>\n<ul>\n<li><strong>失败类型分布</strong>：测试失败、编译错误、环境问题</li>\n<li><strong>失败模块热力图</strong>：识别问题集中区域</li>\n<li><strong>历史对比分析</strong>：与之前成功构建的差异对比</li>\n</ul>\n<p>Allure测试报告通过丰富的图表展示测试执行详情、历史趋势和缺陷分布，大大提升了测试结果的分析效率。</p>\n<h3 id=\"32-面向角色的可视化策略\">3.2 面向角色的可视化策略</h3>\n<p>不同角色关注不同的指标和视图，<strong>个性化可视化</strong>能显著提升信息获取效率。</p>\n<p><strong>开发者视角</strong>关注快速反馈：</p>\n<ul>\n<li><strong>本次提交影响范围</strong>：修改的文件、关联的测试</li>\n<li><strong>个人提交质量趋势</strong>：近期通过率、常见错误类型</li>\n<li><strong>快速修复指导</strong>：错误定位、修复建议</li>\n</ul>\n<p><strong>技术负责人视角</strong>关注整体质量：</p>\n<ul>\n<li><strong>团队质量指标</strong>：平均通过率、技术债务趋势</li>\n<li><strong>模块健康度排名</strong>：问题集中度分析</li>\n<li><strong>质量演进预测</strong>：基于历史数据的质量预测</li>\n</ul>\n<p><strong>项目经理视角</strong>关注交付风险：</p>\n<ul>\n<li><strong>迭代进度可视化</strong>：已完成、进行中、受阻的任务</li>\n<li><strong>质量风险预警</strong>：可能影响发布的质量问题</li>\n<li><strong>效率指标</strong>：构建时长、反馈周期</li>\n</ul>\n<h3 id=\"33-可视化反馈的实时性与交互性\">3.3 可视化反馈的实时性与交互性</h3>\n<p><strong>实时更新</strong>的可视化能够及时驱动行动。通过WebSocket等技术实现仪表板实时更新，让团队成员在问题发生几分钟内即可感知。</p>\n<p><strong>交互式下钻</strong>能力使分析从宏观到微观：</p>\n<pre><code class=\"language-javascript\">// 可视化下钻示例\nfunction setupDrillDown() {\n  // 点击构建失败率图表，下钻到具体失败任务\n  chart.on('click', function(params) {\n    if (params.componentType === 'series') {\n      const buildId = params.data.buildId;\n      // 加载该构建的详细失败信息\n      loadFailureDetails(buildId);\n    }\n  });\n}\n</code></pre>\n<p>在团队工作区域设置<strong>物理可视化看板</strong>，结合电子仪表板，形成线上线下的立体反馈系统。</p>\n<h2 id=\"4-快速反馈机制的设计重点\">4 快速反馈机制的设计重点</h2>\n<h3 id=\"41-反馈速度与质量的平衡艺术\">4.1 反馈速度与质量的平衡艺术</h3>\n<p>快速反馈不是一味追求速度，而是<strong>在合适的时间提供有价值的信息</strong>。反馈机制需要平衡<strong>速度</strong>、<strong>精度</strong>和<strong>行动性</strong>。</p>\n<p><strong>分层反馈策略</strong>在不同阶段提供不同粒度的反馈：</p>\n<ul>\n<li><strong>即时反馈</strong>（&lt;5分钟）：编译、基础静态检查、关键单元测试</li>\n<li><strong>快速反馈</strong>（5-15分钟）：完整单元测试、基础集成测试</li>\n<li><strong>完整反馈</strong>（15-60分钟）：全量集成测试、端到端测试</li>\n</ul>\n<pre><code class=\"language-yaml\"># 分层反馈配置\nfeedback_levels:\n  immediate:\n    timeout: 5min\n    checks: [compile, lint, critical_unit_tests]\n    notification: [slack_immediate, IDE]\n  fast:\n    timeout: 15min \n    checks: [all_unit_tests, integration_smoke]\n    notification: [slack_channel, email]\n  full:\n    timeout: 60min\n    checks: [all_integration, e2e, performance]\n    notification: [slack_channel, email, dashboard]\n</code></pre>\n<h3 id=\"42-精准通知与告警防骚扰\">4.2 精准通知与告警防骚扰</h3>\n<p>过度的通知会导致<strong>告警疲劳</strong>，重要信息被淹没。智能通知策略基于<strong>上下文</strong>和<strong>相关性</strong>进行精准推送。</p>\n<p><strong>通知路由规则</strong>确保信息送达正确的人：</p>\n<pre><code class=\"language-yaml\">notification_rules:\n  - match: { failure_type: \"compile\", component: \"frontend\" }\n    notify: [\"frontend-team\", \"commit-author\"]\n    urgency: \"high\"\n    \n  - match: { failure_type: \"test\", component: \"legacy-system\" }  \n    notify: [\"legacy-maintainers\", \"tech-lead\"]\n    urgency: \"medium\"\n    \n  - match: { failure_type: \"performance\", degradation: \"&gt;20%\" }\n    notify: [\"performance-team\", \"architect\"]\n    urgency: \"high\"\n</code></pre>\n<p><strong>反馈摘要</strong>机制将相关通知聚合，避免信息过载：</p>\n<ul>\n<li><strong>每日质量摘要</strong>：当天构建情况、质量趋势</li>\n<li><strong>迭代总结报告</strong>：本迭代质量改进成效</li>\n<li><strong>个性化摘要</strong>：个人提交质量改进建议</li>\n</ul>\n<h3 id=\"43-反馈闭环验证与持续改进\">4.3 反馈闭环验证与持续改进</h3>\n<p>反馈只有形成闭环才有价值。<strong>闭环验证</strong>确保每个问题都被跟踪到解决：</p>\n<div class=\"mermaid\">graph LR\n    A[问题发现] --&gt; B[通知分发]\n    B --&gt; C[负责人处理]\n    C --&gt; D[修复验证]\n    D --&gt; E[根本原因分析]\n    E --&gt; F[流程改进]\n    F --&gt; A\n</div><p><em>反馈闭环流程图</em></p>\n<p><strong>反馈效率度量</strong>是改进的基础：</p>\n<ul>\n<li><strong>问题发现到通知时间</strong>：检测效率</li>\n<li><strong>通知到确认时间</strong>：响应效率</li>\n<li><strong>确收到修复时间</strong>：解决效率</li>\n<li><strong>修复到验证时间</strong>：验证效率</li>\n</ul>\n<p>通过定期分析这些指标，识别反馈链条中的瓶颈并持续优化。</p>\n<h2 id=\"5-流水线性能优化策略\">5 流水线性能优化策略</h2>\n<h3 id=\"51-并行化与分布式执行\">5.1 并行化与分布式执行</h3>\n<p>流水线性能直接影响反馈速度。<strong>任务依赖分析</strong>是并行优化的基础，通过建立任务依赖图识别可并行阶段。</p>\n<p><strong>智能并行化</strong>策略：</p>\n<pre><code class=\"language-yaml\"># 并行执行配置\nparallelization:\n  strategy: optimistic\n  rules:\n    - when: test_files_changed\n      then: parallelize_tests_by_module\n    - when: frontend_changed\n      then: run_frontend_tests_only\n    - when: backend_changed  \n      then: run_backend_tests_only\n</code></pre>\n<p><strong>分布式执行</strong>通过集群化大幅缩短执行时间：</p>\n<ul>\n<li><strong>动态资源分配</strong>：根据任务需求分配合适配置的执行器</li>\n<li><strong>缓存共享</strong>：节点间共享依赖缓存、Docker镜像</li>\n<li><strong>负载均衡</strong>：基于节点负载和网络状况智能调度</li>\n</ul>\n<h3 id=\"52-增量检查与缓存优化\">5.2 增量检查与缓存优化</h3>\n<p>全量检查在大型项目中往往不现实。<strong>增量分析</strong>只检查变更影响范围，平衡速度与准确性。</p>\n<p><strong>智能缓存策略</strong>避免重复工作：</p>\n<pre><code class=\"language-yaml\">cache_strategy:\n  dependencies:\n    key: \"dependencies-${checksum['package.json']}\"\n    paths: [node_modules]\n  build_output:\n    key: \"build-${CI_COMMIT_REF_SLUG}\"\n    paths: [dist]\n  test_results:\n    key: \"tests-${CI_COMMIT_REF_SLUG}\"\n    paths: [test_results]\n</code></pre>\n<p>工商银行通过优化缓存策略，将流水线平均执行时间从45分钟缩短到18分钟。</p>\n<h2 id=\"6-文化因素质量内建与集体负责\">6 文化因素：质量内建与集体负责</h2>\n<h3 id=\"61-从质量门禁到质量内建\">6.1 从质量门禁到质量内建</h3>\n<p>技术手段必须与文化建设相结合。<strong>质量内建</strong>强调在开发过程中构建质量，而非依赖后期检查。</p>\n<p><strong>质量内建实践</strong>包括：</p>\n<ul>\n<li><strong>代码审查</strong>：通过Pull Request和结对编程提前发现问题</li>\n<li><strong>测试驱动开发</strong>：先写测试，确保代码可测试性</li>\n<li><strong>持续重构</strong>：小步迭代，避免技术债务累积</li>\n</ul>\n<p><strong>集体代码所有权</strong>文化确保每个成员都关心质量：</p>\n<ul>\n<li><strong>交叉评审</strong>：不同背景的开发者相互评审代码</li>\n<li><strong>知识共享</strong>：定期分享质量改进经验</li>\n<li><strong>无指责文化</strong>：关注问题解决而非责任追究</li>\n</ul>\n<h3 id=\"62-持续改进的质量社区\">6.2 持续改进的质量社区</h3>\n<p>建立<strong>质量社区</strong>实践，让质量成为团队对话的核心：</p>\n<ul>\n<li><strong>质量研讨会</strong>：定期讨论质量标准和改进点</li>\n<li><strong>失败分析会</strong>：深度分析重大故障，分享学习</li>\n<li><strong>工具优化日</strong>：定期优化开发工具和流水线</li>\n</ul>\n<p>某大型互联网公司通过建立质量社区，在6个月内将生产环境缺陷率降低了40%。</p>\n<h2 id=\"总结\">总结</h2>\n<p>持续集成的价值流优化是一个系统工程，需要技术、流程和文化的协同改进。有效的CI系统应该像<strong>精密的神经系统</strong>，能够快速感知变化、准确诊断问题、及时触发修复动作。</p>\n<p><strong>成功实施的关键原则</strong>：</p>\n<ol>\n<li><strong>价值流导向</strong>：关注端到端流动效率，而非局部优化</li>\n<li><strong>快速反馈循环</strong>：建立分层反馈机制，平衡速度与准确性</li>\n<li><strong>质量内建文化</strong>：将质量意识融入开发全过程</li>\n<li><strong>数据驱动改进</strong>：基于度量数据持续优化流水线</li>\n<li><strong>人员协同优先</strong>：工具为协作服务，而非相反</li>\n</ol>\n<p>真正的持续集成价值流能够将<strong>代码提交</strong>转化为<strong>可靠的产品增量</strong>，在这个过程中，每个团队成员都能快速获得有意义的反馈，并充满信心地向用户交付价值。</p>\n<hr />\n<p><strong>📚 下篇预告</strong><br />\n《容器镜像的工程化思维——最小化、分层与可复现构建的取舍》—— 我们将深入探讨：</p>\n<ul>\n<li>🏗️ <strong>镜像分层策略</strong>：基础镜像选择、层优化与安全更新的平衡之道</li>\n<li>📦 <strong>最小化镜像</strong>：多阶段构建、Distroless与静态编译的技术选型</li>\n<li>🔄 <strong>可复现构建</strong>：环境一致性、构建缓存与版本追溯的实践方案</li>\n<li>🛡️ <strong>安全治理</strong>：漏洞扫描、签名验证与供应链安全的最佳实践</li>\n<li>⚖️ <strong>大小与效率的权衡</strong>：开发体验与运行时性能的优化取舍</li>\n</ul>\n<p><strong>点击关注，掌握容器镜像的工程化实践！</strong></p>\n<blockquote>\n<p><strong>今日行动建议</strong>：</p>\n<ol>\n<li>绘制当前CI系统的价值流图，识别瓶颈环节</li>\n<li>评估质量门禁的层级设计，确保快速反馈与深度检查的平衡</li>\n<li>优化报告可视化策略，基于角色提供差异化视图</li>\n<li>建立反馈效率度量体系，持续优化闭环效率</li>\n<li>培育质量社区文化，将质量内建融入开发日常</li>\n</ol>\n</blockquote>\n\n</div>\n<div id=\"MySignature\">\n    个人微信：lpshiyue 添加暗号：道生一 <br />\n欢迎搜索关注微信公众号： 基础进阶，第一时间阅读最新文章\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 14:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shiyuelp\">十月南城</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "unibest：基于 Vite + Vue 3 的 Uni-app 开发终极方案",
      "link": "https://www.cnblogs.com/lijinhuaboke/p/19491916",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lijinhuaboke/p/19491916\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 14:50\">\n    <span>unibest：基于 Vite + Vue 3 的 Uni-app 开发终极方案</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"告别-hbuilderx拥抱-unibest基于-vite--vue-3-的-uni-app-开发终极方案\">告别 HBuilderX？拥抱 unibest：基于 Vite + Vue 3 的 Uni-app 开发终极方案</h1>\n<p>在移动端跨平台开发领域，<strong>Uni-app</strong> 凭借其强大的跨端能力不仅统一了小程序和 App 的开发，更构建了庞大的生态。然而，传统的开发模式（依赖 HBuilderX、基于 Webpack 的构建速度、繁琐的样式写法）在面对日益复杂的大型项目时，逐渐显露出工程化能力的短板。</p>\n<p><strong>unibest</strong> (uni-app + best) 的出现，正是为了解决这些痛点。它是一套集成了当前前端最前沿技术栈的 Uni-app 开发模板，旨在提供<strong>极致的开发体验</strong>和<strong>最佳的工程实践</strong>。</p>\n<p>今天，我们就了解下，为什么 unibest 是你下一个 Uni-app 项目的不二之选。</p>\n<h2 id=\"核心技术栈快不仅是构建速度\">核心技术栈：快，不仅是构建速度</h2>\n<p>unibest 的核心理念是“现代化”。它抛弃了陈旧的工具链，全面拥抱了以下技术：</p>\n<ul>\n<li><strong>构建工具</strong>：<strong>Vite 5</strong> —— 毫秒级的冷启动和热更新（HMR），相比 Webpack 提升 10 倍以上。</li>\n<li><strong>核心框架</strong>：<strong>Vue 3 (Script Setup)</strong> —— 更简洁的代码组织，更强的逻辑复用能力。</li>\n<li><strong>语言</strong>：<strong>TypeScript</strong> —— 全链路类型安全，重构不再心惊胆战。</li>\n<li><strong>样式引擎</strong>：<strong>UnoCSS</strong> —— 原子化 CSS 引擎，样式开发效率的革命。</li>\n<li><strong>状态管理</strong>：<strong>Pinia</strong> —— 轻量、直观，完美支持 Composition API。</li>\n</ul>\n<h2 id=\"深入-unibest-的技术亮点\">深入 unibest 的技术亮点</h2>\n<h3 id=\"1-极致的原子化样式体验-unocss\">1. 极致的原子化样式体验 (UnoCSS)</h3>\n<p>写小程序最耗时的往往不是逻辑，而是写样式。传统的 <code>class</code> + <code>css</code> 模式需要在模板和样式文件间反复横跳。</p>\n<p>unibest 内置了 <strong>UnoCSS</strong>，让你可以在模板中直接书写原子类，所见即所得。</p>\n<p><strong>传统写法：</strong></p>\n<pre><code class=\"language-html\">&lt;!-- template --&gt;\n&lt;view class=\"card\"&gt;\n  &lt;view class=\"title\"&gt;标题&lt;/view&gt;\n&lt;/view&gt;\n\n&lt;!-- style --&gt;\n.card { padding: 10px; background: #fff; border-radius: 4px; box-shadow: 0 2px\n4px rgba(0,0,0,0.1); } .title { font-size: 16px; font-weight: bold; color: #333;\n}\n</code></pre>\n<p><strong>unibest (UnoCSS) 写法：</strong></p>\n<pre><code class=\"language-html\">&lt;view class=\"p-4 bg-white rounded shadow-sm\"&gt;\n  &lt;view class=\"text-base font-bold text-gray-800\"&gt;标题&lt;/view&gt;\n&lt;/view&gt;\n</code></pre>\n<p><strong>优点</strong>：代码量减少 50%，无需费劲想类名，CSS 体积极致压缩。</p>\n<h3 id=\"2-自动化开发的魅力-auto-imports\">2. 自动化开发的魅力 (Auto Imports)</h3>\n<p>利用 <code>unplugin-auto-import</code> 和 <code>unplugin-vue-components</code>，unibest 实现了 API 和组件的<strong>自动按需引入</strong>。</p>\n<p>你不再需要满屏的 <code>import</code> 语句：</p>\n<pre><code class=\"language-typescript\">// 以前\nimport { ref, computed, onMounted } from \"vue\";\nimport { onLoad } from \"@dcloudio/uni-app\";\n\n// 现在：直接用！编译器会自动处理\nconst count = ref(0);\nonLoad(() =&gt; {\n  console.log(\"Page loaded\");\n});\n</code></pre>\n<h3 id=\"3-企业级的网络请求封装-promise--interceptors\">3. 企业级的网络请求封装 (Promise &amp; Interceptors)</h3>\n<p>unibest 模板中通常包含了一套成熟的 <code>uni.request</code> 封装方案，展示了如何优雅地处理拦截器、Token 注入和并发控制。</p>\n<p><strong>亮点模式：静默登录与 Token 自动注入</strong><br />\n框架支持在请求拦截器中处理复杂的鉴权逻辑，例如：在 Token 不存在时自动挂起请求，完成登录后再继续。</p>\n<pre><code class=\"language-typescript\">// utils/http.ts 示例架构\nexport const http = async &lt;T&gt;(options: CustomRequestOptions) =&gt; {\n  // 1. 动态 Token 注入\n  const token = uni.getStorageSync(\"token\");\n\n  // 2. 智能拦截：如果是需要鉴权的接口且无 token，自动触发登录流程\n  if (options.auth &amp;&amp; !token) {\n    await useUserStore().login();\n  }\n\n  return new Promise&lt;Result&lt;T&gt;&gt;((resolve, reject) =&gt; {\n    uni.request({\n      ...options,\n      success(res) {\n        // 3. 统一错误拦截（如 401 过期）\n        if (res.statusCode === 401) {\n          // 清理状态，跳转登录页或无感刷新 Token\n          reject(\"Unauthorized\");\n        } else {\n          resolve(res.data);\n        }\n      },\n    });\n  });\n};\n</code></pre>\n<h3 id=\"4-基于文件系统的路由-file-based-routing\">4. 基于文件系统的路由 (File-based Routing)</h3>\n<p>摆脱臃肿的 <code>pages.json</code>！unibest 集成了 <code>vite-plugin-uni-pages</code>，支持通过文件目录结构自动生成路由配置。</p>\n<ul>\n<li><strong>自动注册</strong>：新建 <code>src/pages/login/index.vue</code>，自动识别为页面。</li>\n<li><strong>配置内聚</strong>：页面的标题、导航栏样式直接在 Vue 文件的 <code>&lt;route&gt;</code> 块中定义，无需去 <code>pages.json</code> 里查找。</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!-- src/pages/index/index.vue --&gt;\n&lt;route lang=\"json5\"&gt; { style: { navigationBarTitleText: '首页', } } &lt;/route&gt;\n\n&lt;template&gt;\n  &lt;view&gt;Home&lt;/view&gt;\n&lt;/template&gt;\n</code></pre>\n<h3 id=\"5-优秀的并发处理范式\">5. 优秀的并发处理范式</h3>\n<p>在处理小程序登录（<code>uni.login</code>）等异步操作时，unibest 推荐使用 <strong>Promise 锁</strong> 模式来防止并发请求导致的重复调用。这是非常实用的高阶技巧。</p>\n<pre><code class=\"language-typescript\">// store/user.ts\nlet loginPromise: Promise&lt;void&gt; | null = null;\n\nconst login = () =&gt; {\n  // 如果已经在登录中，直接返回现有的 Promise，避免重复调用 uni.login\n  if (loginPromise) return loginPromise;\n\n  loginPromise = (async () =&gt; {\n    try {\n      const { code } = await uni.login();\n      // ... 换取 Token\n    } finally {\n      loginPromise = null; // 释放锁\n    }\n  })();\n\n  return loginPromise;\n};\n</code></pre>\n<h2 id=\"为什么选择-unibest\">为什么选择 unibest？</h2>\n<ol>\n<li><strong>工程化完备</strong>：开箱即用的 ESLint, Prettier, Husky, Commitlint 配置，规范团队代码。</li>\n<li><strong>多端适配强</strong>：不仅支持微信小程序，还通过条件编译和 polyfill 完美支持 H5、App 及其他小程序平台。</li>\n<li><strong>生态活跃</strong>：基于 Vite 生态，可以复用大量现有的 Vue 3 插件和工具。</li>\n</ol>\n<h2 id=\"使用体验\">使用体验</h2>\n<p>个人使用体验还是蛮不错的，支持 vscode 作为编辑器，基础的封装（比如 uni.request）都有,引入了实用的插件(比如 z-paging),自动化开发（约定式路由，自动引入组件、自动引入 api），使用 wot-ui 组件库、原子化样式等等，比原来使用 uniapp 开发起来效率和效果确实要好.<br />\n官网地址：<a href=\"https://www.unibest.tech/%EF%BC%8C%E8%BF%98%E6%9C%89%E5%BE%88%E5%A4%9A%E5%BE%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%8C%E5%A4%A7%E5%AE%B6%E5%8F%AF%E4%BB%A5%E5%AE%98%E7%BD%91%E5%8E%BB%E7%9C%8B%E7%9C%8B%E3%80%82\" rel=\"noopener nofollow\" target=\"_blank\">https://www.unibest.tech/，还有很多很有意思的东西，大家可以官网去看看。</a></p>\n<h2 id=\"结语\">结语</h2>\n<p>技术在不断演进，工具也在不断革新。unibest 不仅仅是一个模板，它代表了一种<strong>高效、规范、现代</strong>的 Uni-app 开发方式。如果你希望摆脱传统开发模式的束缚，提升团队的开发效率和代码质量，unibest 绝对值得一试。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 14:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lijinhuaboke\">此颜差矣。</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "终于找到了一款足够简单的任务管理软件",
      "link": "https://www.cnblogs.com/lbnnbs/p/19491338",
      "published": "",
      "description": "<div class=\"postTitle\">\n            <h1><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lbnnbs/p/19491338\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 12:23\">\n    <span>终于找到了一款足够简单的任务管理软件</span>\n    \n\n</a>\n</h1>\n        </div>\n        <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n现在大家不但休息时间很碎片化，工作时间很多时候都是碎片化的。为了管理好自己的工作，我各类软件都使用过。但市面上多数工具要么功能繁杂，要么不支持手机版，要不就是收费太贵，真不是我这样的小白能用的起的。我个人使用过使用过很多的工作任务管理软件，有项目管理类的，有便签类的，有日程类的。但项目管理类的操作过于复杂，日程类和便签类的又没有团队协作功能。总之很难找一款简单好用的小团队小项目任务管理软件。后来百度的时候搜索到了一款叫九运任务宝的小工具，它官网上强调以 “简单、轻快、好用” 为核心定位，感觉有点点靠谱。下载试用后感觉还真不错，最起码要的东西都有。现在经过了几个月的使用，感觉找到了梦中情软（说的过分了点^_^）。<br /><br />传统任务管理软件，创建一个任务需要经历填写名称、设置分类、选择成员、调整时间等多个繁琐步骤，甚至需要跳转多个页面才能完成配置，新手入门需要花不少时间去学习，特别是项目管理类的，特别复杂。不但没有帮到工作排期，反而给增加了额外负担。而且有些工具的任务编辑功能简陋，缺少撤销重做，手机上操作一不小心删除时删过了头，就要重写一大段了。但这个九运任务宝任务创建全流程都和简单，只需专注填写任务内容，会自动根据首段内容智能生成任务名称，不用反复斟酌标题，秒速完成任务记录。任务内容编辑框带了撤销和重做功能，操作失误要不怕。<br /><br />他还有一个上传的图片会自动标注序号的功能，可以和任务内容上的描述匹配起来，让任务要求更清晰。这种 “少操作、多专注” 的设计，让任务创建效率提高不少。<br /><br />传统任务管理软件常常追求 “大而全”，堆砌了大量使用率极低的复杂功能，不仅增加了软件体积和操作难度，还容易让我在众多功能面前一脸懵逼。<br /><br />比如吧，项目管理类软件权限管理模块设计太复杂，设置流程繁琐。在比如大多数工具的任务状态没有 “搁置” 等选项，暂时无需处理的任务只能占用列表空间，导致信息杂乱。<br /><br />但这个九运任务宝在任务设置上，有“已搁置” 这个任务状态，就很方便，任务列表更整洁。在时间选择界面用绿色加粗字体标注节假日，工作排期时不需要额外切换日历APP查询假期。批量操作功能简单直观，长按任务即就可以进入批量编辑模式，右滑操作也很人性化，搞得我不时就像去划一下。此外，任务分类、优先级设置、协作人指派、甘特图等核心功能一应俱全，既满足多场景需求，又没啥多余的操作。<br /><br />另外，大多拥有项目和任务管理的软件移动端都比较难用，外出时宅手机上处理任务很头疼。这个九运任务宝就支持 PC 电脑端、手机 APP 端、微信小程序端、手机 H5 网页端，在外面也能随时随地操作。<br /><br />感觉现在的软件都越做越复杂，不实用的功能一大堆，追求大而全，像这类关注核心需要的软件倒是更少，也不知道是咋回事，是不知道我们需要什么样的工具才顺手吗。\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-16 12:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lbnnbs\">lbnnbs</a>&nbsp;\n阅读(<span id=\"post_view_count\">207</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MySQL深度分页优化实战：从踩坑到落地的全攻略",
      "link": "https://www.cnblogs.com/sun-10387834/p/19491242",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19491242\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 11:57\">\n    <span>MySQL深度分页优化实战：从踩坑到落地的全攻略</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>做后端开发的同学，大概率都遇到过MySQL分页的坑——浅分页时查询秒回，一旦翻到几十页、上百页之后，接口就开始卡顿，甚至直接超时。之前在做电商商品列表接口时，就因为没处理好深度分页，线上出现过多次接口超时告警，排查后才发现是分页SQL的问题。今天就结合实际开发经验，聊聊MySQL深度分页的本质问题，以及那些能直接落地的优化方案，都是经过生产环境验证的干货。</p>\n<p>先说说最开始踩的坑。当时商品列表接口用的是最常规的分页写法，也就是LIMIT offset, size，代码里封装了通用分页逻辑，前端传页码和每页条数，后端计算offset后拼SQL。上线初期数据量少，翻个十几页都没问题，可随着商品数据涨到几十万条，用户翻到第500页之后，接口响应时间直接从几十毫秒飙升到几百甚至上千毫秒，监控面板上全是红色告警。</p>\n<h2 id=\"一深度分页为什么会慢\">一、深度分页为什么会慢？</h2>\n<p>一开始以为是索引没建对，排查后发现索引是正常的，后来翻了MySQL官方文档，再结合执行计划分析，才搞懂了核心原因。我们常用的LIMIT offset, size写法，比如LIMIT 100000, 20，MySQL并不是直接跳过前10万条数据取后面20条，而是会从表的第一条数据开始，逐行扫描，一共读取100020条数据，然后丢弃前10万条，只返回最后20条。</p>\n<p>这就意味着，offset越大，MySQL需要扫描的行数就越多，磁盘IO和内存消耗都会急剧增加，查询效率自然呈指数级下降。如果分页SQL还没命中索引，触发全表扫描，那情况会更糟，直接导致整个数据库实例压力飙升，影响其他接口。</p>\n<h2 id=\"二实战优化方案从易到难落地\">二、实战优化方案：从易到难落地</h2>\n<p>针对深度分页问题，没有万能方案，只能结合业务场景选择最合适的。下面按优先级排序，分享几个实际项目中用过的优化方案，从改造成本低到高逐步说明。</p>\n<h3 id=\"方案一书签分页最优解90场景适用\">方案一：书签分页（最优解，90%场景适用）</h3>\n<p>这是我目前在项目中用得最多的方案，改造成本低，性能提升明显，核心思路是放弃offset偏移，用上一页最后一条数据的主键或唯一索引作为“书签”，让MySQL直接通过索引定位到书签位置，再往后查询指定条数，彻底避免扫描无用数据。</p>\n<p>比如之前的商品列表，用主键id排序，原来的低效写法是：</p>\n<pre><code class=\"language-sql\">-- 第5001页，每页20条，offset=100000\nSELECT id, name, price, category FROM goods WHERE category=1 ORDER BY id LIMIT 100000, 20;\n</code></pre>\n<p>优化后，让前端传递上一页最后一条数据的id，比如上一页最后一条id是100000，新的SQL写法是：</p>\n<pre><code class=\"language-sql\">SELECT id, name, price, category FROM goods WHERE category=1 AND id &gt; 100000 ORDER BY id LIMIT 20;\n</code></pre>\n<p>这样MySQL会直接通过主键索引定位到id=100000的位置，再往后取20条数据，只扫描20条记录，不管数据量多大，查询速度都能稳定在毫秒级。</p>\n<p>这里有个需要注意的点：如果排序字段不是主键，而是普通字段（比如create_time），且存在重复值，直接用该字段作为书签会导致分页重复或漏数据。这时需要用“排序字段+主键”的组合作为锚点，保证唯一性。</p>\n<p>比如按创建时间倒序分页，优化写法如下：</p>\n<pre><code class=\"language-sql\">-- 上一页最后一条数据：create_time='2026-01-15 18:30:00'，id=100000\nSELECT id, name, price, create_time FROM goods \nWHERE category=1 AND (create_time &lt; '2026-01-15 18:30:00' OR (create_time = '2026-01-15 18:30:00' AND id &lt; 100000))\nORDER BY create_time DESC, id DESC LIMIT 20;\n</code></pre>\n<p>这种组合锚点的方式，能完美解决排序字段重复导致的分页异常问题，也是生产环境中处理非主键排序分页的标准写法。</p>\n<h3 id=\"方案二子查询join优化兼容跳页需求\">方案二：子查询/JOIN优化（兼容跳页需求）</h3>\n<p>书签分页的缺点是不支持直接跳转到指定页码，而很多业务场景（比如后台管理系统的分页组件）必须有页码选择功能，这时就需要用子查询或JOIN来优化。</p>\n<p>核心思路是：先通过索引查询出需要的主键ID，再通过主键关联查询全字段数据。因为主键是聚簇索引，查询主键的速度极快，子查询只扫描主键字段的offset+size条数据，而不是全字段，能大幅降低IO开销。</p>\n<p>原来的低效写法优化前：</p>\n<pre><code class=\"language-sql\">SELECT * FROM goods WHERE category=1 ORDER BY id LIMIT 100000, 20;\n</code></pre>\n<p>用JOIN优化后的写法（性能更优，MySQL推荐）：</p>\n<pre><code class=\"language-sql\">SELECT g.* FROM goods g\nJOIN (SELECT id FROM goods WHERE category=1 ORDER BY id LIMIT 100000, 20) t ON g.id = t.id\nORDER BY g.id;\n</code></pre>\n<p>这种方案能完美兼容跳页需求，不需要改造前端分页组件，性能比原生LIMIT提升10~100倍，offset越大，优化效果越明显。需要注意的是，子查询中的排序字段必须建立索引，否则子查询依然会全表扫描，优化失效。</p>\n<h3 id=\"方案三业务层限制最简单的兜底方案\">方案三：业务层限制（最简单的兜底方案）</h3>\n<p>其实很多ToC业务场景中，用户根本不会翻到第100页之后。比如电商商品列表，用户通常只看前10页，翻到后面的概率极低。针对这种场景，最简单的优化方式就是在业务层限制最大页码。</p>\n<p>我们当时在商品列表接口中做了限制：最多只能翻到第50页，超过50页就提示“暂无更多数据”，同时引导用户通过筛选条件（比如价格区间、销量排序）缩小查询范围。这种方式零开发成本，零性能损耗，直接从根源解决问题，适合大多数ToC业务。</p>\n<h3 id=\"方案四特殊场景兜底海量数据批量导出\">方案四：特殊场景兜底（海量数据/批量导出）</h3>\n<p>如果遇到千万级数据的深度分页，或者需要批量导出海量数据的场景，上面的方案可能不够用，这时可以考虑预生成分段ID或使用游标分页。</p>\n<p>预生成分段ID的思路是：在数据表中新增segment_id字段，按主键分段（比如每1000条数据为一个分段），建立segment_id索引。分页时先按segment_id定位分段，再在分段内分页，避免大范围扫描。这种方式适合数据更新频率低的场景，性能极致，但需要预处理数据。</p>\n<p>游标分页则适合批量数据导出、离线任务等不需要跳页的场景，通过MySQL游标逐行读取数据，避免一次性加载大量数据到内存，不会有offset的性能问题，但业务改造成本较高，只适合后端离线任务。</p>\n<h2 id=\"三优化必守原则缺一不可\">三、优化必守原则（缺一不可）</h2>\n<p>不管用哪种优化方案，以下两个原则必须遵守，否则所有优化都会失效：</p>\n<p>1. 分页SQL必须命中索引：WHERE筛选条件+ORDER BY排序条件，必须建立对应的单列索引或联合索引，否则MySQL会触发全表扫描+文件排序，性能依然极差。比如上面的商品列表，需要建立category+id的联合索引，才能让分页SQL高效执行。</p>\n<p>2. 避免使用SELECT *：只查询需要的字段，减少数据传输和内存开销。如果表中有text、blob等大字段，SELECT *会导致性能严重损耗，甚至拖慢整个数据库。</p>\n<h2 id=\"四总结\">四、总结</h2>\n<p>MySQL深度分页的核心矛盾，本质是offset导致的无效扫描。优化的核心思路就是：能不用offset就不用，优先用书签分页；必须用offset就减少扫描数据量，用子查询/JOIN优化；业务上能限制分页深度就限制，从根源规避问题。</p>\n<p>在实际开发中，不需要追求最复杂的方案，而是要结合业务场景选择最合适的。大部分场景下，书签分页+索引优化就能满足需求，改造成本低，性能又稳定。希望这篇实战总结能帮到大家，避开MySQL深度分页的坑。</p>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19491242\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19491242</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 11:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">58</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "网络问题如何排查？mtr命令详解",
      "link": "https://www.cnblogs.com/deep-sky/p/19491194",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/deep-sky/p/19491194\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 11:47\">\n    <span>网络问题如何排查？mtr命令详解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"mtr\">mtr</h3>\n<p><code>mtr</code>命令是一个网络诊断工具，用于检测网络的连通性和延迟。MTR是My Traceroute的缩写，是traceroute和ping命令的结合体。</p>\n<p><code>mtr</code>默认使用<code>ICMP</code>协议，在介绍<code>mtr</code>的详细用法前我们先了解下<code>ICMP</code>协议。</p>\n<h3 id=\"imcp\">IMCP</h3>\n<p><code>ICMP</code>（Internet Control Message Protocol，互联网控制报文协议）<br />\n是一种网络层（OSI 第三层）协议，主要用于在 IP 网络中传递控制信息和错误信息，而不是用来传输业务数据。<br />\n<code>ICMP</code>的作用是：<br />\n1、网络连通性测试<br />\n最常用的就是<code>ping</code>命令，发送的是<code>ICMP Echo Request</code>，对方回复<code>ICMP Echo Reply</code>，用来判断网络是否可达、是否丢包以及延迟</p>\n<p>2、网络故障和错误反馈<br />\n当 IP 包在传输过程中出现问题时，<code>ICMP</code> 会返回错误信息，例如：</p>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>ICMP 类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>目标主机不可达</td>\n<td>Destination Unreachable</td>\n</tr>\n<tr>\n<td>路由中 TTL 用尽</td>\n<td>Time Exceeded</td>\n</tr>\n<tr>\n<td>需要分片但禁止分片</td>\n<td>Fragmentation Needed</td>\n</tr>\n</tbody>\n</table>\n<p>例如：路由器发现下一跳不可达时就会被源主机发送一个ICMP不可达报文</p>\n<p>3、网络路径诊断<br />\n<code>traceroute</code>和<code>tracert</code>就是通过<code>ICMP</code>实现的</p>\n<h3 id=\"mtr的用法\">mtr的用法</h3>\n<pre><code>Usage:\n mtr [options] hostname\n\n -F, --filename FILE              从文件中读取hostname(s)\n -4                               使用IPv4\n -6                               使用IPv6\n -f, --first-ttl NUMBER           起跳ttl参数，跳过前面的N-1跳，只只显示TTL=N后的跳（不改变真实路由，只是不显示）\n -m, --max-ttl NUMBER             maximum number of hops\n -u, --udp                        使用UDP 替代 ICMP echo\n -T, --tcp                        使用 TCP 替代ICMP echo\n -P, --port PORT                  使用TCP、SCTP或UDP探测时的目标端口\n -s, --psize PACKETSIZE           设置探测包的 payload 大小（字节）\n -i, --interval SECONDS           设置探测包的 发送间隔\n -r, --report                     报告模式（一次性输出，不刷新）\n -w, --report-wide                报告模式，宽屏对齐输出（字段不截断）\n -c, --report-cycles COUNT        发送探测包次数，设置20快速判断，设置100较为可信\n -j, --json                       以json格式输出\n -x, --xml                        以xml格式输出\n -C, --csv                        以csv格式输出\n -l, --raw                        以原始格式输出\n -n, --no-dns                     不做反向dns解析(只显示ip)\n -y, --ipinfo NUMBER              输出 IP 归属信息（国家 / 运营商）\n\n</code></pre>\n<p>在linux上执行<code>mtr</code>时，<code>mtr</code>会直接操作网络层构造IP/ICMP报文，所以一般需要使用<code>sudo</code>执行</p>\n<p>示例：<br />\n<code>sudo mtr -r -n -c 100 www.baidu.com</code></p>\n<p>输出结果:</p>\n<pre><code>Start: 2026-01-15T19:00:01+0800\nHOST: LTB-MBP.local               Loss%   Snt   Last   Avg  Best  Wrst StDev\n  1.|-- 183.2.172.177              0.0%   100    2.0   1.8   0.4  26.2   3.4\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n<th>解读要点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>HOST</code></td>\n<td>当前跳主机</td>\n<td><code>*</code> 代表无响应</td>\n</tr>\n<tr>\n<td><code>Loss%</code></td>\n<td>丢包率</td>\n<td><strong>核心指标</strong></td>\n</tr>\n<tr>\n<td><code>Snt</code></td>\n<td>发送包数</td>\n<td>统计样本量</td>\n</tr>\n<tr>\n<td><code>Last</code></td>\n<td>最近一次延迟</td>\n<td>波动参考</td>\n</tr>\n<tr>\n<td><code>Avg</code></td>\n<td>平均延迟</td>\n<td>主要看</td>\n</tr>\n<tr>\n<td><code>Best</code></td>\n<td>最小延迟</td>\n<td>理想情况</td>\n</tr>\n<tr>\n<td><code>Wrst</code></td>\n<td>最大延迟</td>\n<td>是否有抖动</td>\n</tr>\n<tr>\n<td><code>StDev</code></td>\n<td>抖动</td>\n<td>越小越稳定</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"icmp限速\">ICMP限速</h4>\n<p>分析MTR输出时，需要关注两个方面：<strong>丢包率</strong>和<strong>延迟</strong>。如果在某个跳点看到一定程度的丢包，这可能说明该路由器有问题。然而，一些服务提供商普遍会限制MTR使用的<code>ICMP</code>响应速率。这可能会让人误以为丢包，实际上并没有丢包。要判断看到的丢包是真实的还是速率限制引起的，可以看看后续跳跃。如果跳跃显示损失为0.0%，那么很可能是因为：<code>ICMP</code>响应速率限制导致的而非真实的丢包，以下面的MTR结果为例:</p>\n<pre><code>root@localhost:~# mtr -r www.google.com\nHOST: example                       Loss%   Snt   Last  Avg  Best  Wrst   StDev\n   1. 63.247.74.43                  0.0%    10    0.3   0.6   0.3   1.2   0.3\n   2. 63.247.64.157                50.0%    10    0.4   1.0   0.4   6.1   1.8\n   3. 209.51.130.213                0.0%    10    0.8   2.7   0.8  19.0   5.7\n   4. aix.pr1.atl.google.com        0.0%    10    6.7   6.8   6.7   6.9   0.1\n   5. 72.14.233.56                  0.0%    10    7.2   8.3   7.1  16.4   2.9\n   6. 209.85.254.247                0.0%    10   39.1  39.4  39.1  39.7   0.2\n   7. 64.233.174.46                 0.0%    10   39.6  40.4  39.4  46.9   2.3\n   8. gw-in-f147.1e100.net          0.0%    10   39.6  40.5  39.5  46.7   2.2\n</code></pre>\n<p>第二跳的丢包率虽然是 50%，但是其后续跳没有丢包且最终能到到达第8跳，所以整个链路实际上通的，第二跳的丢包率是因为<code>ICMP</code>限速导致的。</p>\n<p>可能有的同学会有疑问了，难道最后一跳不会出现<code>ICMP</code>限速吗？<br />\n实际上，<code>mtr</code>发送数据包后，会根据收到的 ICMP 响应类型来判断：</p>\n<pre><code>中间跳返回：ICMP Type 11 (Time Exceeded)\n            → \"TTL 耗尽，我不是目标\"\n            → 继续增加 TTL 探测下一跳\n\n最后一跳返回：ICMP Type 0 (Echo Reply)\n或 ICMP Type 3 (Destination Unreachable)\n            → \"我就是目标主机\"\n            → 停止探测\n</code></pre>\n<p>过程可以类比快递配送链路：</p>\n<ul>\n<li>中间转运站（路由器）：可能不会告诉你\"包裹经过了这里\"（限制或完全不响应ICMP Time Exceeded）</li>\n<li>最终收货点（目标主机）：必须签收并确认\"收到了\"（响应ICMP Echo Reply）</li>\n</ul>\n<p>即使中间转运站不告诉你进度，只要最后收到包裹并有签收确认，就说明整条链路是通的。</p>\n<h4 id=\"真实的丢包场景\">真实的丢包场景</h4>\n<p>以下面的MTR结果为例：</p>\n<pre><code>root@localhost:~# mtr -r www.google.com\nHOST: localhost                      Loss%   Snt   Last  Avg  Best  Wrst   StDev\n   1. 63.247.74.43                   0.0%    10    0.3   0.6   0.3   1.2   0.3\n   2. 63.247.64.157                  0.0%    10    0.4   1.0   0.4   6.1   1.8\n   3. 209.51.130.213                60.0%    10    0.8   2.7   0.8  19.0   5.7\n   4. aix.pr1.atl.google.com        60.0%    10    6.7   6.8   6.7   6.9   0.1\n   5. 72.14.233.56                  50.0%    10    7.2   8.3   7.1  16.4   2.9\n   6. 209.85.254.247                40.0%    10   39.1  39.4  39.1  39.7   0.2\n   7. 64.233.174.46                 40.0%    10   39.6  40.4  39.4  46.9   2.3\n   8. gw-in-f147.1e100.net          40.0%    10   39.6  40.5  39.5  46.7   2.2\n</code></pre>\n<p>在这个示例中，第三跳的丢包率高达60%且后续跳均出现了丢包率并且影响了最后的第8跳，所以可以判断第三跳是有问题的。由于中间跳<code>ICMP</code>限速和真实丢包会同时发生，所以会出现中间跳的丢包率高于最后一跳丢包率。</p>\n<p>当判断确实出现了丢包时，最好使用MTR双向测试下，因为数据包可能是发送时遇到了问题，也可能是在返回响应时出现了问题。</p>\n<h4 id=\"延迟\">延迟</h4>\n<p>MTR还能测试主机与目标主机之间连接的延迟。由于物理约束，延迟总是随着路由跳数的增加而增加。然而，增长应保持一致且线性。延迟通常是相对的，并且很大程度上取决于主机连接的质量及其物理距离。 在评估可能有问题的连接的 MTR 报告时，除了给定区域中其他主机之间的已知连接速度之外，还应将早期的功能齐全的报告视为上下文。</p>\n<p>以下面的MTR结果为例：</p>\n<pre><code>root@localhost:~# mtr --report www.google.com\nHOST: localhost                      Loss%   Snt   Last   Avg  Best  Wrst  StDev\n    1. 63.247.74.43                  0.0%    10    0.3   0.6   0.3   1.2   0.3\n    2. 63.247.64.157                 0.0%    10    0.4   1.0   0.4   6.1   1.8\n    3. 209.51.130.213                0.0%    10    0.8   2.7   0.8  19.0   5.7\n    4. aix.pr1.atl.google.com        0.0%    10  388.0 360.4 342.1 396.7   0.2\n    5. 72.14.233.56                  0.0%    10  390.6 360.4 342.1 396.7   0.2\n    6. 209.85.254.247                0.0%    10  391.6 360.4 342.1 396.7   0.4\n    7. 64.233.174.46                 0.0%    10  391.8 360.4 342.1 396.7   2.1\n    8. gw-in-f147.1e100.net          0.0%    10  392.0 360.4 342.1 396.7   1.2\n</code></pre>\n<p>在第3跳和第4跳之间延迟突然增高，并且在后续跳中仍然很高，这可能表明存在网络延迟问题。</p>\n<p>但是，高延迟并不总是意味着当前路由有问题。 像上面这样的报告意味着，尽管第四跳存在某种问题，流量仍然到达目标主机并返回源主机。 延迟也可能是由返回路线问题引起的。 返回路线不会在 MTR 报告中看到，并且数据包可以采用完全不同的路线往返于特定目的地。</p>\n<p>在上面的示例中，虽然在第3跳和第4跳之间的延迟存在较大跳跃，但在任何后续跳中延迟并没有再增高。 由此，可以合理地假设第四个路由器存在问题。</p>\n<p><code>ICMP</code>限速也会导致延迟增加，以下面的MTR报告为例：</p>\n<pre><code>root@localhost:~# mtr --report www.google.com\nHOST:  localhost                     Loss%   Snt   Last  Avg  Best  Wrst   StDev\n    1. 63.247.74.43                  0.0%    10    0.3   0.6   0.3   1.2   0.3\n    2. 63.247.64.157                 0.0%    10    0.4   1.0   0.4   6.1   1.8\n    3. 209.51.130.213                0.0%    10    0.8   2.7   0.8  19.0   5.7\n    4. aix.pr1.atl.google.com        0.0%    10    6.7   6.8   6.7   6.9   0.1\n    5. 72.14.233.56                  0.0%    10  254.2 250.3 230.1 263.4   2.9\n    6. 209.85.254.247                0.0%    10   39.1  39.4  39.1  39.7   0.2\n    7. 64.233.174.46                 0.0%    10   39.6  40.4  39.4  46.9   2.3\n    8. gw-in-f147.1e100.net          0.0%    10   39.6  40.5  39.5  46.7   2.2\n</code></pre>\n<p>乍一看，第4跳和第5跳之间的延迟突然增高了。然而，在第五跳之后，延迟急剧下降。这里测得的实际延迟约为40ms，且并没有影响最后一条的延迟，网络实际上是没有问题的。</p>\n<h4 id=\"什么时候需要使用tcp和udp协议进行检测\">什么时候需要使用TCP和UDP协议进行检测？</h4>\n<p>三种协议的对比</p>\n<table>\n<thead>\n<tr>\n<th>协议</th>\n<th>默认使用场景</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ICMP</td>\n<td>默认模式</td>\n<td>最常用,大多数设备支持</td>\n<td>容易被防火墙过滤</td>\n</tr>\n<tr>\n<td>UDP</td>\n<td>测试 UDP 服务</td>\n<td>模拟真实 UDP 流量</td>\n<td>可能被过滤,不可靠</td>\n</tr>\n<tr>\n<td>TCP</td>\n<td>测试 Web/API 服务</td>\n<td>最接近真实应用流量,不易被过滤</td>\n<td>需要指定端口</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"什么时候使用tcp模式\">什么时候使用TCP模式？</h5>\n<ul>\n<li>场景 1：ICMP被防火墙屏蔽或ICMP限速</li>\n</ul>\n<pre><code># ICMP 模式失败\nmtr api.example.com\n→ 大量 \"waiting for reply\" 或 100% 丢包\n\n# 改用 TCP 模式（测试 443 端口）\nmtr -T -P 443 api.example.com\n→ 正常显示路由路径\n</code></pre>\n<ul>\n<li>场景 2：测试特定服务的网络质量</li>\n</ul>\n<pre><code># 测试 HTTPS 服务（443 端口）\nmtr -T -P 443 api.example.com\n\n# 测试 HTTP 服务（80 端口）\nmtr -T -P 80 www.example.com\n\n# 测试 SSH 服务（22 端口）\nmtr -T -P 22 server.example.com\n\n# 测试数据库（3306 端口）\nmtr -T -P 3306 db.example.com\n</code></pre>\n<p><code>mtr</code>使用TCP协议进行网络检测的过程是通过 TCP三次握手的前两步完成的</p>\n<pre><code>Client → SYN (dst port 443, TTL=N)\nServer → SYN-ACK\nClient → RST   （立刻）\n\n</code></pre>\n<p><code>mtr</code>的TCP模式只完成“三次握手的前两步”，并在收到响应后立刻主动 <code>RST</code>，不会建立真正的TCP连接，更不会形成大量的ESTABLISHED 连接，对目标主机性能几乎没有影响。</p>\n<h5 id=\"什么时候使用udp模式\">什么时候使用UDP模式？</h5>\n<ul>\n<li>场景 1：测试 UDP 应用</li>\n</ul>\n<pre><code># 测试 DNS 服务（53 端口）\nmtr -u -P 53 8.8.8.8\n\n# 测试 VoIP/视频会议（如 10000-20000 端口范围）\nmtr -u -P 16384 meeting.example.com\n\n# 测试游戏服务器\nmtr -u -P 27015 game.example.com\n\n# 测试 VPN（如 OpenVPN，1194 端口）\nmtr -u -P 1194 vpn.example.com\n</code></pre>\n<ul>\n<li>场景 2：ICMP 被限流但 UDP 没有</li>\n</ul>\n<pre><code># 某些网络对 ICMP 限流但允许 UDP\nmtr -u api.example.com\n</code></pre>\n<h3 id=\"小结\">小结</h3>\n<p>有了 mtr 之后，当客户反馈诸如：“我们办公室是千兆宽带、Wi-Fi 也是满格，就是你们的产品不行，页面加载慢、接口响应慢”这类问题时，不必慌张。</p>\n<p>拉上客户一起跑一跑 <code>mtr</code>，把链路情况和丢包率、延迟摆出来，沿途每一跳的网络状态都会清清楚楚地呈现在眼前。问题究竟出在本地网络、运营商链路，还是服务器侧，基本就一目了然了。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 11:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/deep-sky\">DeepSky丶</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "没有前端后，我把 MCP 做进了 Chats 1.7.0 AI 网关",
      "link": "https://www.cnblogs.com/sdcb/p/19489261/20260115-chats-170",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sdcb/p/19489261/20260115-chats-170\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 08:45\">\n    <span>没有前端后，我把 MCP 做进了 Chats 1.7.0 AI 网关</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>这是一篇补档文章。</p>\n<p>如果你还不了解 <strong>Sdcb Chats</strong>：简单说，这是一个支持 20+ 主流模型服务商的 AI 网关。它不只能让你在一个统一界面里聚合管理所有模型，同时也兼容标准 API 协议，支持 Docker 一键部署。</p>\n<p>现在回头看，Sdcb Chats 最新版本已经到了 1.10，后续又融合了交错思考、Code Interpreter、多模态和企业级权限等“看起来更酷”的能力。但如果要问我：<strong>哪个版本是我个人开发节奏的分水岭？</strong>答案大概率还是 1.7.0。</p>\n<p>因为 1.7.0 不只是“加了个功能”，而是有三件事同时发生：</p>\n<ul>\n<li>MCP（Model Context Protocol）在 Chats 里真正落地，终于从“能聊”走向“能调用工具”，理论上能支持任何符合 MCP 的模型服务商和工具服务商，比如知识库、搜索引擎、计算引擎等；</li>\n<li>数据模型与数据库大改（破坏性变更），为后续演进把地基打牢；</li>\n<li>更关键的是：从这个版本开始，Chats 基本变成我一个人维护了——而我第一次深度尝试了 AI 的“氛围编程（Vibe Coding）”。</li>\n</ul>\n<hr />\n<h2 id=\"三个月空窗没有前端的我第一次把ai当同事\">三个月空窗：没有前端的我，第一次把AI当同事</h2>\n<p>距离上次 1.6 正式发布过去了 3 个多月。这期间，和我搭档做 Chats 前端的朋友因为有事没办法继续参与开发。没有前端开发，我一个后端在 Next.js / React 这套体系里，生产力几乎直接归零——项目一度陷入停滞。</p>\n<p>于是我第一次认真尝试把 AI 当作“副驾驶”：从页面布局、状态管理、组件拆分，到各种奇怪的 UI 边角行为（尤其是流式输出和工具调用展示），都让 AI 一起参与。</p>\n<p>可以这样说：</p>\n<ul>\n<li>Chats 1.7 之前：基本还是人类一行代码一行代码撸上去的；</li>\n<li>Chats 1.7.0 起：我开始“系统性”地 Vibe Coding，<strong>尤其是在我并不熟的 React 上，生产力提升非常明显</strong>；</li>\n<li>也从这时起，Chats 的维护者（几乎）变成了我一个人。</li>\n</ul>\n<p>所以这篇文章标题里写“感谢 AI”，不是客套，是事实。</p>\n<hr />\n<h2 id=\"170-的核心mcp-协议全面落地\">1.7.0 的核心：MCP 协议全面落地</h2>\n<p>如果你把 Chats 只当成一个“统一模型网关 + 漂亮 UI”的聊天前端，那它的上限就只是“把模型回答展示出来”。但 MCP 的出现，让“模型能做事”有了更统一、更可组合的方式。</p>\n<p>在 1.7.0 里，MCP 的落地不是停留在“能连上”，而是把整条链路打通了：</p>\n<ul>\n<li>\n<p>后端有完整的 MCP 实体与权限关系（Server、Tool、User 授权、Chat 绑定）；</p>\n</li>\n<li>\n<p>前端设置页新增 MCP 管理：新增/编辑 Server、抓取工具、分配用户；<br />\n<img alt=\"02-mcp-list\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260115213720114-1699629549.png\" /><br />\n<img alt=\"03-mcp-edit\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260115213726314-440296231.png\" /><br />\n<img alt=\"04-mcp-assign-user\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260115213729222-1808157068.png\" /></p>\n</li>\n<li>\n<p>会话侧可绑定多个 MCP Server，并在会话前校验当前用户权限；</p>\n</li>\n<li>\n<p>工具调用全程走流式输出，参数与结果能以结构化方式进入消息内容，前端也能更好地可视化展示。<br />\n<img alt=\"05-mcp-call\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260115213734256-659322865.png\" /></p>\n</li>\n</ul>\n<p>对我而言，这意味着 Chats 从“聊天 UI”升级成了“工具编排平台”的雏形：你可以给不同的 Chat Span 配置不同的工具集合，让它们在同一套对话体验里发挥作用。</p>\n<hr />\n<h2 id=\"工具调用体验不只是能用而是要看得懂\">工具调用体验：不只是能用，而是要“看得懂”</h2>\n<p>做过工具调用的人都知道：<strong>能调用是一回事，让用户看懂发生了什么是另一回事。</strong></p>\n<p>1.7.0 在工具调用的事件与消息结构上做了比较大的增强：SSE 事件更丰富、消息内容里新增了工具请求/响应的类型，前端能把“调用了什么工具、传了什么参数、拿到了什么结果”以更清晰的方式展示出来。<br />\n<img alt=\"06-sse-response-line\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260115213740193-1073025986.png\" /></p>\n<p>这件事看起来偏“体验”，但它会直接影响你是否愿意在真实业务里用工具调用：当工具一多、调用链一长，如果 UI 只是一坨 Markdown 混在一起，那基本等于不可用。</p>\n<hr />\n<h2 id=\"破坏性变更数据库与数据模型的大规模重构\">破坏性变更：数据库与数据模型的大规模重构</h2>\n<p>1.7.0 还有一个绕不开的关键词：<strong>破坏性变更</strong>。</p>\n<p>为了提升可维护性与可观测性，我在这个版本里对消息存储层做了重构（比如把 <code>Message</code> 拆分为 <code>ChatTurn/Step</code> 的分层结构），同时还伴随了用量关联、默认值约束、排序字段等一系列调整。<br />\n<img alt=\"07-db-schema\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260115213746807-893994786.png\" /></p>\n<p>这种重构的特点是：你短期会痛一次，但长期会省很多命。尤其是当你后面要持续叠加“推理/工具/多模态/审计/性能统计”这些能力时，底层结构是否清晰，决定了你是在“继续写功能”，还是在“每加一个功能都要拆一次墙”。</p>\n<hr />\n<h2 id=\"一些我很在意的细节改进\">一些我很在意的细节改进</h2>\n<p>除了 MCP 和数据库重构，1.7.0 还把不少“用起来会爽一点”的点补齐了，比如：</p>\n<ul>\n<li>模型/密钥/预设支持拖拽排序（Provider/Key/Model 的组织方式更清晰）；<br />\n<img alt=\"\" src=\"https://io.starworks.cc:88/cv-public/2026/08-drag-reordering.avif\" /></li>\n<li>聊天再生成能力增强：单条重新生成、从某条用户消息开始重新生成整段；<br />\n<img alt=\"\" src=\"https://io.starworks.cc:88/cv-public/2026/09-regenerate.avif\" /></li>\n<li>Markdown Mermaid 渲染升级：暗/亮主题适配、全屏查看、流式友好；<br />\n<img alt=\"\" src=\"https://io.starworks.cc:88/cv-public/2026/10-mermaid.avif\" /></li>\n<li>图片生成尺寸控制：在会话中指定常用尺寸；</li>\n<li>OpenAI 兼容与第三方联调增强（工具调用适配修复、登录兼容优化等）。<br />\n<img alt=\"11-image-size-control\" src=\"https://img2024.cnblogs.com/blog/233608/202601/233608-20260115214018456-481361818.png\" /><br />\n这些看起来零碎，但它们共同指向同一个目标：<strong>把 Chats 从“功能堆叠”推向“可长期使用的产品质感”。</strong></li>\n</ul>\n<hr />\n<h2 id=\"升级与数据迁移不支持自动迁移请手动跑-sql只提供-sql-server\">升级与数据迁移：不支持自动迁移，请手动跑 SQL（只提供 SQL Server）</h2>\n<p>Sdcb Chats的数据库变更 <strong>不支持自动数据迁移</strong>。升级时你需要<strong>手动执行 SQL 迁移脚本</strong>，并且目前只提供了 <strong>SQL Server</strong> 的迁移脚本：</p>\n<ul>\n<li>1.7.0 迁移脚本：<code>src/scripts/db-migration/1.7/20250516-mcp.sql</code></li>\n</ul>\n<p>基本步骤也很朴素：</p>\n<ol>\n<li>先备份数据库；</li>\n<li>在 SQL Server 上执行上面的迁移脚本；</li>\n</ol>\n<p>如果你用的是 SQLite 或 Postgres……我建议你像我一样：把 SQL 甩给 AI，让它帮你改成 SQLite/Postgres 版本，然后你再一边跑一边修，或者如果你能接受，先删库，Chats 会在第一次启动时自动创建新表结构。</p>\n<hr />\n<h2 id=\"致谢\">致谢</h2>\n<p>1.7.0 的发布说明里，我特别感谢过社区贡献（比如<a href=\"https://github.com/sdcb/chats/pull/96\" rel=\"noopener nofollow\" target=\"_blank\">修复登录页面运行时错误的 PR #96</a>）。而在这篇补档里，我还想加一个更个人的致谢：感谢 AI。</p>\n<hr />\n<p>感谢阅读！喜欢的朋友请给我的Github项目一个star：<a href=\"https://github.com/sdcb/chats\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/sdcb/chats</a><br />\n有什么想法也欢迎在评论区留言交流，也欢迎加入我的 <strong>Chats QQ群：498452653</strong>，我们一起探索更多AI技术硬核玩法。</p>\n<p>微信群：<img alt=\"\" src=\"https://io.starworks.cc:88/cv-public/2026/chats-wxg-qr.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 08:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sdcb\">.NET骚操作</a>&nbsp;\n阅读(<span id=\"post_view_count\">225</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "别再手写 URL 解析器了：PHP 8.5 URI 扩展让 URL 处理更安全、更干净",
      "link": "https://www.cnblogs.com/catchadmin/p/19490082",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19490082\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 07:48\">\n    <span>别再手写 URL 解析器了：PHP 8.5 URI 扩展让 URL 处理更安全、更干净</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"别再手写-url-解析器了php-85-uri-扩展让-url-处理更安全更干净\">别再手写 URL 解析器了：PHP 8.5 URI 扩展让 URL 处理更安全、更干净</h1>\n<h2 id=\"parse_url-能用但不够用\">parse_url() 能用，但不够用</h2>\n<p>多年来，PHP 开发者处理 URL 的方式大同小异：</p>\n<ul>\n<li>用 <code>parse_url()</code> 拆分各部分</li>\n<li>用 <code>rawurlencode()</code> / <code>urlencode()</code> 转义</li>\n<li>用字符串拼接重建最终 URL</li>\n<li>遇到\"奇怪\"输入时，再上几个正则</li>\n</ul>\n<p>大多数情况下这套流程能跑通。问题在于，URL 处理恰恰是那种\"在边角情况下出问题\"的领域：编码、fragment、userinfo、国际化域名、\"等价但不相同\"的 URL，以及各种只在生产日志里才冒出来的边缘场景。</p>\n<p>PHP 8.5 提供了一个内置替代方案：一个始终可用的 URI 扩展，提供 API 来按照 RFC 3986 和 WHATWG URL 标准解析、修改 URL/URI。</p>\n<p>如果\"标准\"二字让你觉得抽象，这里给出实际含义：</p>\n<ul>\n<li>拿到 URI/URL 对象，而不是数组 + 字符串拼接。</li>\n<li>用安全的组件 getter 和不可变的 <code>with*()</code> 方法。</li>\n<li>你可以选择 RFC 3986 行为（严格 URI，\"原始 vs 规范化解码\"）或浏览器风格的 WHATWG 行为（Unicode/IDNA、软错误、自动编码）。</li>\n</ul>\n<p>本文是一篇实战教程，重点讲：</p>\n<ul>\n<li>为什么手动解析容易出错，</li>\n<li>新 URI 对象怎么用，</li>\n<li>如何安全地修改/规范化，</li>\n<li>在重定向、签名链接等安全敏感场景下如何使用。</li>\n</ul>\n<p>不讲升级指南，不讲废弃清单——只讲 URI 扩展。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/php85-uri-extension-safer-cleaner-urls\" rel=\"noopener nofollow\" target=\"_blank\">原文 别再手写 URL 解析器了：PHP 8.5 URI 扩展让 URL 处理更安全、更干净</a></p>\n<h2 id=\"手动-url-解析的问题\">手动 URL 解析的问题</h2>\n<h3 id=\"parse_url-不解码而且很容易忘\">parse_url() 不解码（而且很容易忘）</h3>\n<p>PHP 的 <code>parse_url()</code> 返回各组件，但<strong>不会</strong> URL 解码它们。</p>\n<p>也就是说：</p>\n<pre><code class=\"language-php\">$u = parse_url(\"https://example.com/t%65st?name=Ali%63e#fr%61g\");\nvar_dump($u['path']);   // \"/t%65st\"\nvar_dump($u['query']);  // \"name=Ali%63e\"\nvar_dump($u['fragment']); // \"fr%61g\"\n</code></pre>\n<p>如果你在比较路径或应用路由规则时没有统一解码/规范化，可能会把等价的 URI 当成不同的来处理。</p>\n<p>更糟的是：团队往往混用：</p>\n<ul>\n<li>有些地方用解码后的值，</li>\n<li>有些地方用原始值，</li>\n<li>再加上散落在各处的临时解码逻辑。</li>\n</ul>\n<p>这种混乱很容易埋下隐蔽 bug 和安全隐患。</p>\n<h3 id=\"字符串拼接容易拼出差一点对的-url\">字符串拼接容易拼出\"差一点对\"的 URL</h3>\n<p>手动重建 URL 容易犯的错：</p>\n<ul>\n<li>漏掉 <code>?</code> 或 <code>#</code></li>\n<li>重复编码</li>\n<li>完全没编码</li>\n<li>编码错了东西（比如把整个 query string 编码而不是只编码 value）</li>\n<li>丢失或打乱参数顺序</li>\n<li>空 query/fragment 处理不当</li>\n</ul>\n<p>一个常见的\"差一点对\"函数：</p>\n<pre><code class=\"language-php\">function addQueryParam(string $url, string $key, string $value): string\n{\n    $parts = parse_url($url);\n    $query = $parts['query'] ?? '';\n    $query .= ($query === '' ? '' : '&amp;') . $key . '=' . urlencode($value);\n    $out = $parts['scheme'] . '://' . $parts['host'] . ($parts['path'] ?? '');\n    if ($query !== '') {\n        $out .= '?' . $query;\n    }\n    if (isset($parts['fragment'])) {\n        $out .= '#' . $parts['fragment'];\n    }\n    return $out;\n}\n</code></pre>\n<p>看起来没问题。直到遇到：</p>\n<ul>\n<li>没有 scheme/host 的 URL（相对 URL），</li>\n<li>带 userinfo/port 的 URL，</li>\n<li>已经编码过的值，</li>\n<li>需要 <code>rawurlencode()</code> 规则（RFC 3986）的参数，</li>\n<li>应该原样保留的 fragment。</li>\n</ul>\n<h3 id=\"等价的-url-不一定是相同的字符串\">等价的 URL 不一定是相同的字符串</h3>\n<p>下面这些可以指向同一个资源，但字符串不同：</p>\n<ul>\n<li>scheme/host 大小写不同（<code>HTTPS://EXAMPLE.com</code>）</li>\n<li>path 中 <code>%65</code> vs <code>e</code>（<code>/t%65st</code> vs <code>/test</code>）</li>\n<li>path 中的点号段（<code>/foo/../bar/</code>）</li>\n<li>默认端口（https 的 <code>:443</code>）</li>\n</ul>\n<p>如果你把 URL 当成纯字符串处理，要么：</p>\n<ul>\n<li>缓存/路由出现诡异问题，</li>\n<li>要么安全检查被绕过，因为你比较的是\"错误的表示形式\"。</li>\n</ul>\n<h3 id=\"idna国际化域名还涉及安全问题\">IDNA（国际化域名）还涉及安全问题</h3>\n<p>如果你允许用户提交 URL，国际化域名可能是合法的——但也可能造成混淆。域名可以用 Unicode 或 punycode（ASCII 形式）表示。RFC 讨论中明确指出人为风险：punycode 域名在 Unicode 渲染时可能看起来像一个熟悉的、但实际不同的域名。</p>\n<p>这不是你想用正则\"手动处理\"然后祈祷没问题的事。</p>\n<h2 id=\"uri-扩展的概念uri-对象--两套标准\">URI 扩展的概念：URI 对象 + 两套标准</h2>\n<p>PHP 8.5 的 URI 扩展提供两个主要类：</p>\n<ul>\n<li><code>Uri\\Rfc3986\\Uri</code>（RFC 3986 合规，严格 URI 规则）</li>\n<li><code>Uri\\WhatWg\\Url</code>（WHATWG URL 合规，浏览器风格的 URL 规则）</li>\n</ul>\n<p>配套的类型包括：</p>\n<ul>\n<li><code>Uri\\InvalidUriException</code></li>\n<li><code>Uri\\WhatWg\\InvalidUrlException</code></li>\n<li><code>Uri\\WhatWg\\UrlValidationError</code> 和 <code>UrlValidationErrorType</code></li>\n<li><code>Uri\\UriComparisonMode</code>（用于比较）</li>\n</ul>\n<p>一个关键设计决策：两个实现都是 readonly 且以不可变方式使用——<code>withPath()</code>、<code>withQuery()</code> 等方法返回新实例。</p>\n<p>另一个要点：这个扩展在 PHP 8.5 中始终可用，底层由以下库驱动：</p>\n<ul>\n<li>uriparser（用于 RFC 3986）</li>\n<li>Lexbor（用于 WHATWG URL）</li>\n</ul>\n<p>所以你不需要第三方库就能获得合理的 URL 处理能力。</p>\n<h2 id=\"创建和解析-uri从字符串到组件\">创建和解析 URI：从字符串到组件</h2>\n<h3 id=\"最简单的情况解析一个-http-url-并访问各部分\">最简单的情况：解析一个 HTTP URL 并访问各部分</h3>\n<p>RFC 3986：</p>\n<pre><code class=\"language-php\">use Uri\\Rfc3986\\Uri;\n\n$uri = new Uri(\"https://php.net/releases/8.5/en.php\");\n\necho $uri-&gt;getScheme(); // \"https\"\necho $uri-&gt;getHost();   // \"php.net\"\necho $uri-&gt;getPath();   // \"/releases/8.5/en.php\"\n</code></pre>\n<p>WHATWG：</p>\n<pre><code class=\"language-php\">use Uri\\WhatWg\\Url;\n\n$url = new Url(\"https://example.com/path?query=1#frag\");\n\necho $url-&gt;getScheme();      // \"https\"\necho $url-&gt;getAsciiHost();   // \"example.com\"\necho $url-&gt;getPath();        // \"/path\"\necho $url-&gt;getQuery();       // \"query=1\"\necho $url-&gt;getFragment();    // \"frag\"\n</code></pre>\n<p>注意：WHATWG 的 getter 故意不返回分隔符（如 <code>:</code> <code>/</code> <code>?</code> <code>#</code>）。</p>\n<h3 id=\"构造函数抛异常parse-返回-null\">构造函数抛异常；parse() 返回 null</h3>\n<p>两个实现都支持两种解析风格：</p>\n<ul>\n<li>构造函数：无效时抛异常</li>\n<li><code>parse()</code>：无效时返回 null</li>\n</ul>\n<p>RFC 3986 行为：</p>\n<pre><code class=\"language-php\">use Uri\\Rfc3986\\Uri;\nuse Uri\\InvalidUriException;\n\ntry {\n    $uri = new Uri(\"not a uri\");\n} catch (InvalidUriException $e) {\n    // 拒绝输入\n}\n\n$uri = Uri::parse(\"not a uri\");\nvar_dump($uri); // null\n</code></pre>\n<p>WHATWG 行为提供更丰富的错误信息：</p>\n<pre><code class=\"language-php\">use Uri\\WhatWg\\Url;\nuse Uri\\WhatWg\\InvalidUrlException;\n\ntry {\n    $url = new Url(\"invalid url\");\n} catch (InvalidUrlException $e) {\n    // $e-&gt;errors 包含 UrlValidationError 实例\n}\n\n$errors = [];\n$url = Url::parse(\"invalid url\", null, $errors);\nvar_dump($url);    // null\nvar_dump($errors); // UrlValidationError 数组\n</code></pre>\n<p>这种区分（硬错误 vs 软错误 vs parse-and-return-null）在 RFC 中有详细说明。</p>\n<h3 id=\"base-url-和引用解析相对--绝对\">Base URL 和引用解析（相对 → 绝对）</h3>\n<p>有了这个功能，你不再需要手动检查是否以 <code>/</code> 开头然后拼接。</p>\n<p>在构造函数或 <code>parse()</code> 中使用 base URL：</p>\n<pre><code class=\"language-php\">use Uri\\Rfc3986\\Uri;\n\n$base = new Uri(\"https://example.com\");\n$uri  = new Uri(\"/foo\", $base);\n\necho $uri-&gt;toString(); // \"https://example.com/foo\"\n</code></pre>\n<p>WHATWG 类似：</p>\n<pre><code class=\"language-php\">use Uri\\WhatWg\\Url;\n\n$base = new Url(\"https://example.com\");\n$url  = Url::parse(\"/foo\", $base);\n\necho $url-&gt;toAsciiString(); // \"https://example.com/foo\"\n</code></pre>\n<p>扩展还提供了便捷的 <code>resolve()</code> 方法，以当前对象作为 base。</p>\n<h2 id=\"安全修改设置替换-pathqueryfragment不可变\">安全修改：设置/替换 path、query、fragment（不可变）</h2>\n<p>拿到对象后，可以用 <code>with*()</code> 方法修改组件。这些方法返回新实例，原对象保持不变。</p>\n<h3 id=\"rfc-3986withpathwithquerywithfragment\">RFC 3986：withPath()、withQuery()、withFragment()</h3>\n<pre><code class=\"language-php\">use Uri\\Rfc3986\\Uri;\n\n$uri = new Uri(\"https://example.com/products?sort=asc#top\");\n\n$updated = $uri\n    -&gt;withPath(\"/products/123\")\n    -&gt;withQuery(\"sort=desc&amp;ref=home\")\n    -&gt;withFragment(\"reviews\");\n\necho $uri-&gt;toString();     // 原对象不变\necho $updated-&gt;toString(); // 修改后的\n</code></pre>\n<p>RFC 3986 提供\"原始\"和\"规范化解码\"两种 getter（下一节详述），以及 <code>toString()</code> 和 <code>toRawString()</code> 方法。</p>\n<h3 id=\"whatwg同样的思路外加-asciiunicode-字符串输出\">WHATWG：同样的思路，外加 ASCII/Unicode 字符串输出</h3>\n<pre><code class=\"language-php\">use Uri\\WhatWg\\Url;\n\n$url = new Url(\"https://example.com/\");\n\n$new = $url\n    -&gt;withPath(\"/search\")\n    -&gt;withQuery(\"q=php+8.5\")\n    -&gt;withFragment(\"results\");\n\necho $new-&gt;toAsciiString();\necho $new-&gt;toUnicodeString();\n</code></pre>\n<p>WHATWG 有 <code>toAsciiString()</code> 和 <code>toUnicodeString()</code> 两种输出，分别用于机器处理和人类展示。</p>\n<h3 id=\"一个小但重要的行为输入中的分隔符\">一个小但重要的行为：输入中的分隔符</h3>\n<p>使用 WHATWG 时，如果你在设置 query/fragment 时不小心包含了 <code>?</code> 或 <code>#</code>，它会把它们当作分隔符并去掉：</p>\n<pre><code class=\"language-php\">use Uri\\WhatWg\\Url;\n\n$url = new Url(\"https://example.com/\");\n$url = $url-&gt;withQuery(\"?foo\");\n$url = $url-&gt;withFragment(\"#bar\");\n\necho $url-&gt;getQuery();    // \"foo\"\necho $url-&gt;getFragment(); // \"bar\"\n</code></pre>\n<p>这个行为在文档中有明确说明。</p>\n<h2 id=\"规范化与编码避免重复编码和奇怪字符\">规范化与编码：避免重复编码和\"奇怪字符\"</h2>\n<p>URI 扩展的价值不止于 API 设计——它让你能控制 URL 的表示形式。</p>\n<h3 id=\"rfc-3986-给你两种表示原始-vs-规范化解码\">RFC 3986 给你两种表示：原始 vs 规范化解码</h3>\n<p>对于大多数组件，<code>Uri\\Rfc3986\\Uri</code> 暴露：</p>\n<ul>\n<li>raw：解析器给出的形式（最接近原始输入）</li>\n<li>规范化解码：规范化 + 百分号解码，意在成为规范形式且可往返转换</li>\n</ul>\n<p>RFC 解释了为什么需要两种形式以及何时使用——签名方和 API 客户端通常偏好 raw，而路由/缓存通常偏好规范化解码。</p>\n<p>具体效果：</p>\n<pre><code class=\"language-php\">use Uri\\Rfc3986\\Uri;\n\n$uri = new Uri(\"https://%61pple:p%61ss@ex%61mple.com:433/foob%61r?%61bc=%61bc#%61bc\");\n\necho $uri-&gt;getRawHost(); // \"ex%61mple.com\"\necho $uri-&gt;getHost();    // \"example.com\"\n\necho $uri-&gt;getRawPath(); // \"/foob%61r\"\necho $uri-&gt;getPath();    // \"/foobar\"\n\necho $uri-&gt;getRawQuery(); // \"%61bc=%61bc\"\necho $uri-&gt;getQuery();    // \"abc=abc\"\n</code></pre>\n<p>规范化示例：</p>\n<pre><code class=\"language-php\">use Uri\\Rfc3986\\Uri;\n\n$uri = new Uri(\"HTTPS://EXAMPLE.COM/foo/../bar/\");\n\necho $uri-&gt;getRawScheme(); // \"HTTPS\"\necho $uri-&gt;getScheme();    // \"https\"\n\necho $uri-&gt;getRawHost(); // \"EXAMPLE.COM\"\necho $uri-&gt;getHost();    // \"example.com\"\n\necho $uri-&gt;getRawPath(); // \"/foo/../bar/\"\necho $uri-&gt;getPath();    // \"/bar/\"\n</code></pre>\n<h3 id=\"whatwg-在修改时自动编码某些字符\">WHATWG 在修改时自动编码某些字符</h3>\n<p>如果你设置的 path 包含该组件必须百分号编码的字符，WHATWG 会自动编码：</p>\n<pre><code class=\"language-php\">use Uri\\WhatWg\\Url;\n\n$url = new Url(\"https://example.com\");\n$url = $url-&gt;withPath(\"/?#:\");\n\necho $url-&gt;getPath(); // \"/%3F%23:\"\n</code></pre>\n<p>这能防止意外构建出损坏的 URL。</p>\n<h3 id=\"重复编码陷阱以及新-api-如何帮忙\">\"重复编码\"陷阱（以及新 API 如何帮忙）</h3>\n<p>重复编码通常这样发生：</p>\n<ol>\n<li>你用 <code>rawurlencode()</code> 编码一个值，因为\"它要放进 URL\"</li>\n<li>你手动把它加到 query string</li>\n<li>后来某处又编码了一次（框架、代理、客户端）</li>\n</ol>\n<p>使用 URI 对象，一个好做法是：</p>\n<ul>\n<li>数据保持为普通字符串（未编码）</li>\n<li>用 <code>http_build_query()</code> 构建 query（或你偏好的编码器）</li>\n<li>把结果传给 <code>withQuery()</code></li>\n</ul>\n<p>示例：</p>\n<pre><code class=\"language-php\">use Uri\\Rfc3986\\Uri;\n\n$base = new Uri(\"https://example.com/search\");\n\n$params = [\n    'q' =&gt; 'php 8.5 uri',\n    'tag' =&gt; 'url/encoding',\n];\n\n// RFC 3986 风格编码（空格用 %20 而非 +）\n$query = str_replace('+', '%20', http_build_query($params));\n\n$uri = $base-&gt;withQuery($query);\necho $uri-&gt;toString();\n</code></pre>\n<p><code>http_build_query()</code> 不一定适合所有场景，但好处是编码规则集中在一处，而非散落在各种字符串拼接里。</p>\n<p>如果确实需要对 path 段进行 RFC 3986 原始编码，PHP 的 <code>rawurlencode()</code> 遵循 RFC 3986 规则。</p>\n<h2 id=\"验证用户输入的-url实用的最低规则\">验证用户输入的 URL：实用的最低规则</h2>\n<p>如果输入来自用户（或不可信来源），验证应该有明确的立场。</p>\n<p>对于你打算 fetch 或跳转的 URL，一个务实的安全导向模式：</p>\n<ul>\n<li>必须解析成功（硬错误直接拒绝）</li>\n<li>只允许 http / https</li>\n<li>URL 中不能有用户名/密码</li>\n<li>域名白名单（用 ASCII 形式比较）</li>\n<li>可选：限制端口</li>\n<li>可选：要求绝对 URL（或相对 URL 基于已知 base 解析）</li>\n</ul>\n<h3 id=\"严格验证-helperwhatwg-版本\">严格验证 helper（WHATWG 版本）</h3>\n<p>WHATWG 适合处理\"浏览器风格\"URL 和 IDNA。</p>\n<pre><code class=\"language-php\">use Uri\\WhatWg\\Url;\nuse Uri\\WhatWg\\InvalidUrlException;\n\nfunction validateExternalUrl(string $input, array $allowedHosts): Url\n{\n    try {\n        $softErrors = [];\n        $url = new Url($input, null, $softErrors);\n    } catch (InvalidUrlException $e) {\n        throw new InvalidArgumentException(\"Invalid URL.\");\n    }\n\n    // Scheme 白名单\n    $scheme = $url-&gt;getScheme();\n    if (!in_array($scheme, ['http', 'https'], true)) {\n        throw new InvalidArgumentException(\"Unsupported scheme.\");\n    }\n\n    // 禁止凭证\n    if ($url-&gt;getUsername() !== null || $url-&gt;getPassword() !== null) {\n        throw new InvalidArgumentException(\"Credentials in URL are not allowed.\");\n    }\n\n    // Host 白名单（ASCII 比较）\n    $host = $url-&gt;getAsciiHost();\n    if ($host === null || !in_array(strtolower($host), $allowedHosts, true)) {\n        throw new InvalidArgumentException(\"Host not allowed.\");\n    }\n\n    // 可选：端口限制\n    $port = $url-&gt;getPort();\n    if ($port !== null &amp;&amp; !in_array($port, [80, 443], true)) {\n        throw new InvalidArgumentException(\"Port not allowed.\");\n    }\n\n    return $url;\n}\n</code></pre>\n<p>几点说明：</p>\n<ul>\n<li><code>Url</code> 即使解析成功也可能返回软错误。RFC 解释了\"软 vs 硬\"模型，并给出了解析继续但报告验证错误的例子。</li>\n<li>WHATWG 同时暴露 <code>getAsciiHost()</code> 和 <code>getUnicodeHost()</code>；比较通常用 ASCII，展示用 Unicode。</li>\n</ul>\n<h3 id=\"rfc-3986-验证严格-uri-解析--规范化选项\">RFC 3986 验证：严格 URI 解析 + 规范化选项</h3>\n<p>如果你在验证通用 URI（不只是 HTTP URL），或者你关心 raw vs 规范化解码的表示，<code>Uri\\Rfc3986\\Uri</code> 是个好选择。</p>\n<pre><code class=\"language-php\">use Uri\\Rfc3986\\Uri;\nuse Uri\\InvalidUriException;\n\nfunction validateHttpUri(string $input, array $allowedHosts): Uri\n{\n    try {\n        $uri = new Uri($input);\n    } catch (InvalidUriException $e) {\n        throw new InvalidArgumentException(\"Invalid URI.\");\n    }\n\n    $scheme = $uri-&gt;getScheme();\n    if (!in_array($scheme, ['http', 'https'], true)) {\n        throw new InvalidArgumentException(\"Unsupported scheme.\");\n    }\n\n    // Userinfo 在大多数 Web 应用中是个坑\n    if ($uri-&gt;getUserInfo() !== null) {\n        throw new InvalidArgumentException(\"Userinfo is not allowed.\");\n    }\n\n    $host = $uri-&gt;getHost();\n    if ($host === null || !in_array(strtolower($host), $allowedHosts, true)) {\n        throw new InvalidArgumentException(\"Host not allowed.\");\n    }\n\n    return $uri;\n}\n</code></pre>\n<h2 id=\"实际用例签名链接安全重定向规范-url\">实际用例：签名链接、安全重定向、规范 URL</h2>\n<h3 id=\"用例签名链接而不破坏编码\">用例：签名链接而不破坏编码</h3>\n<p>签名 URL（HMAC token、临时访问链接、CDN 认证）对表示形式极其敏感。一个小的\"规范化变更\"就能使签名失效。</p>\n<p>这也是 RFC 明确指出\"API 客户端或签名方\"通常偏好原始表示的原因。</p>\n<p>一个简单的签名 URL 方法：</p>\n<ol>\n<li>构建 URL</li>\n<li>对稳定的字符串表示计算签名</li>\n<li>把签名作为 query 参数加进去</li>\n</ol>\n<p>示例，使用 RFC 3986 和 <code>toRawString()</code> 签名：</p>\n<pre><code class=\"language-php\">use Uri\\Rfc3986\\Uri;\n\nfunction signUri(Uri $uri, string $secret): Uri\n{\n    // 当你想避免意外转换时，用 raw string\n    $baseString = $uri-&gt;toRawString();\n    $sig = hash_hmac('sha256', $baseString, $secret);\n\n    $query = $uri-&gt;getRawQuery();\n    $query = $query ? $query . '&amp;' : '';\n    $query .= 'sig=' . rawurlencode($sig);\n\n    return $uri-&gt;withQuery($query);\n}\n\n$uri = new Uri(\"https://download.example.com/file/%2Fsafe?expires=1736035200\");\n$signed = signUri($uri, \"super-secret-key\");\n\necho $signed-&gt;toRawString();\n</code></pre>\n<p>两个要点：</p>\n<ul>\n<li>你是故意选择 raw 的，因为签名关心的是\"线上实际发送的是什么\"。</li>\n<li>query 构建仍然要小心，避免编码错误。</li>\n</ul>\n<p>如果你的签名算法需要规范形式（有些确实需要），可以故意对 <code>toString()</code> 签名——但要知道自己在做什么，而不是意外这么做。</p>\n<h3 id=\"用例安全重定向避免开放重定向--解析混淆\">用例：安全重定向（避免开放重定向 + 解析混淆）</h3>\n<p>安全重定向问题通常长这样：</p>\n<ol>\n<li>你有 <code>/login?next=&lt;something&gt;</code></li>\n<li>登录后跳转到 next</li>\n<li>攻击者尝试 <code>next=https://evil.com</code> 或各种变体</li>\n</ol>\n<p>一个健壮的模式是：</p>\n<ol>\n<li>把用户输入解析为相对 URL 或绝对 URL</li>\n<li>相对 URL 基于你自己的已知 base 解析</li>\n<li>验证 host/scheme 是你的（或在允许列表中）</li>\n</ol>\n<p>使用 WHATWG：</p>\n<pre><code class=\"language-php\">use Uri\\WhatWg\\Url;\n\nfunction safeRedirectTarget(string $next, string $appBase): string\n{\n    $base = new Url($appBase);\n\n    // 安全解析相对引用\n    $errors = [];\n    $resolved = Url::parse($next, $base, $errors);\n\n    if ($resolved === null) {\n        return $base-&gt;toAsciiString(); // fallback\n    }\n\n    // 只允许同 host\n    if (strtolower($resolved-&gt;getAsciiHost() ?? '') !== strtolower($base-&gt;getAsciiHost() ?? '')) {\n        return $base-&gt;toAsciiString();\n    }\n\n    // 只允许 http/https\n    if (!in_array($resolved-&gt;getScheme(), ['http', 'https'], true)) {\n        return $base-&gt;toAsciiString();\n    }\n\n    return $resolved-&gt;toAsciiString();\n}\n\necho safeRedirectTarget(\"/dashboard\", \"https://app.example.com\");\n</code></pre>\n<p>这里用到了 base URL 解析和引用解析功能。</p>\n<h3 id=\"用例规范-urlseo-和缓存的一致表示\">用例：规范 URL（SEO 和缓存的一致表示）</h3>\n<p>规范化通常意味着：</p>\n<ul>\n<li>scheme/host 小写</li>\n<li>移除 path 中的点号段</li>\n<li>移除默认端口</li>\n<li>query 保持一致（有时排序）</li>\n<li>决定如何处理末尾斜杠</li>\n</ul>\n<p>使用 <code>Uri\\Rfc3986\\Uri</code>，你已经可以通过 <code>get*()</code> vs <code>getRaw*()</code>（以及 <code>toString()</code> vs <code>toRawString()</code>）清晰地获得规范化行为。</p>\n<p>一个简单的规范化示例：</p>\n<pre><code class=\"language-php\">use Uri\\Rfc3986\\Uri;\n\nfunction canonicalizeForCache(Uri $uri): Uri\n{\n    // 从规范化解码的部分开始\n    $uri = $uri\n        -&gt;withScheme($uri-&gt;getScheme())\n        -&gt;withHost($uri-&gt;getHost())\n        -&gt;withPath($uri-&gt;getPath());\n\n    // 为缓存 key 排序 query 参数（这是一种策略选择）\n    $query = $uri-&gt;getQuery();\n    if ($query) {\n        parse_str($query, $params);\n        ksort($params);\n        $sorted = http_build_query($params, '', '&amp;', PHP_QUERY_RFC3986);\n        $uri = $uri-&gt;withQuery($sorted);\n    }\n\n    return $uri;\n}\n\n$u = new Uri(\"HTTPS://EXAMPLE.COM/foo/../bar/?b=2&amp;a=1\");\necho canonicalizeForCache($u)-&gt;toString();\n</code></pre>\n<p>这个函数不试图覆盖所有规范化策略（那是应用层面的事），但结构化 API 的好处是：规则可以显式构建、可以测试。</p>\n<h2 id=\"从-parse_url--字符串拼接迁移不痛苦\">从 parse_url() + 字符串拼接迁移（不痛苦）</h2>\n<p>你不需要一次性重写所有代码。最简单的迁移路径是：</p>\n<p><strong>1. 找出 URL 处理对安全敏感或容易出 bug 的地方：</strong></p>\n<ul>\n<li>重定向</li>\n<li>webhook 验证</li>\n<li>签名 URL</li>\n<li>域名白名单</li>\n<li>路由/缓存 key</li>\n</ul>\n<p><strong>2. 先替换这些。</strong></p>\n<p><strong>3. 纯展示用途的简单解析，等到有必要时再处理。</strong></p>\n<h3 id=\"迁移前数组解析--手动重建\">迁移前：数组解析 + 手动重建</h3>\n<pre><code class=\"language-php\">$parts = parse_url($input);\n$host  = $parts['host'] ?? null;\n\nif ($host !== 'example.com') {\n    throw new Exception(\"Bad host\");\n}\n\n$newUrl = $parts['scheme'] . '://' . $parts['host'] . '/new-path';\n</code></pre>\n<p>问题：</p>\n<ul>\n<li>没处理 port、userinfo、fragment、相对 URL</li>\n<li>没有规范化</li>\n<li>没有规范化选择</li>\n<li>容易构建出无效输出</li>\n</ul>\n<h3 id=\"迁移后使用-urluri改动局部化\">迁移后：使用 Url/Uri，改动局部化</h3>\n<pre><code class=\"language-php\">use Uri\\WhatWg\\Url;\n\n$url = new Url($input);\n\nif (strtolower($url-&gt;getAsciiHost() ?? '') !== 'example.com') {\n    throw new InvalidArgumentException(\"Bad host\");\n}\n\n$new = $url-&gt;withPath('/new-path');\necho $new-&gt;toAsciiString();\n</code></pre>\n<p>代码更短，意图更明确，细节上更难出错。</p>\n<h3 id=\"rfc-3986-和-whatwg-怎么选经验法则\">RFC 3986 和 WHATWG 怎么选（经验法则）</h3>\n<p><strong>使用 <code>Uri\\WhatWg\\Url</code> 当：</strong></p>\n<ul>\n<li>你在处理来自浏览器/用户的 HTTP(S) URL</li>\n<li>你需要 IDNA/Unicode 域名处理（<code>getUnicodeHost()</code> 用于展示，<code>getAsciiHost()</code> 用于比较）</li>\n<li>你想要 WHATWG 解析行为和错误报告（软错误）</li>\n</ul>\n<p><strong>使用 <code>Uri\\Rfc3986\\Uri</code> 当：</strong></p>\n<ul>\n<li>你在处理\"Web URL\"之外的通用 URI</li>\n<li>你需要 raw vs 规范化解码的表示</li>\n<li>你在做签名或协议层面的工作，表示形式很重要</li>\n</ul>\n<p>RFC 明确区分了这两种方法，包括 Unicode/IDNA 支持的差异。</p>\n<h2 id=\"附加内容正确比较-urlequals-以及为什么没有-__tostring\">附加内容：正确比较 URL（equals() 以及为什么没有 __toString()）</h2>\n<p>一个值得留意的设计：内置 URI 类故意不实现 <code>__toString()</code>，因为松散比较（<code>==</code>）容易出错。</p>\n<p>取而代之，你用 <code>equals()</code> 比较：</p>\n<pre><code class=\"language-php\">use Uri\\Rfc3986\\Uri;\nuse Uri\\UriComparisonMode;\n\n$u1 = new Uri(\"https://example.COM#foo\");\n$u2 = new Uri(\"https://EXAMPLE.COM\");\n\nvar_dump($u1-&gt;equals($u2)); // true\nvar_dump($u1-&gt;equals($u2, UriComparisonMode::IncludeFragment)); // false\n</code></pre>\n<p>WHATWG 类似：</p>\n<pre><code class=\"language-php\">use Uri\\WhatWg\\Url;\nuse Uri\\UriComparisonMode;\n\n$a = new Url(\"https:////example.COM/\");\n$b = new Url(\"https://EXAMPLE.COM\");\n\nvar_dump($a-&gt;equals($b)); // true\n</code></pre>\n<h2 id=\"结论\">结论</h2>\n<p>PHP 8.5 的 URI 扩展看起来是个小功能，用一段时间后才会发现它挡掉了多少细微的 URL bug。</p>\n<p>核心价值在于<strong>控制</strong>：</p>\n<ul>\n<li>你可以选择 RFC 3986 vs WHATWG 语义。</li>\n<li>你可以决定要 raw 还是规范化解码的表示。</li>\n<li>你可以不可变且安全地修改组件。</li>\n<li>你可以用更难意外削弱的方式验证和比较 URL。</li>\n</ul>\n<p>如果你曾经发布过一个\"快速 URL 修复\"，后来在安全报告或生产事故中看到它，这个扩展值得尽早采用——从重定向和签名 URL 开始。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 07:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MySQL性能优化：从底层原理到实战落地的全维度方案",
      "link": "https://www.cnblogs.com/liuziyi1/p/19489439",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/liuziyi1/p/19489439\" id=\"cb_post_title_url\" title=\"发布于 2026-01-15 22:26\">\n    <span>MySQL性能优化：从底层原理到实战落地的全维度方案</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在数据驱动的业务场景中，MySQL作为主流开源关系型数据库，其性能直接决定系统响应速度、吞吐量与运维成本。尤其对于高并发、大数据量的平台（如DeepSeek这类AI服务场景），慢查询与不合理索引设计可能引发系统卡顿甚至雪崩。MySQL性能优化并非零散的“调参改SQL”，而是基于底层原理的系统性工程——既要掌握可落地的实战技巧，更要理解优化背后的核心逻辑，才能实现从“治标”到“治本”的突破。本文将融合底层理论与实战经验，构建“原理认知-问题定位-优化实施-工程保障”的完整体系，助力开发者实现MySQL性能的精准提升。</p>\n<h1 id=\"-一底层逻辑mysql性能的核心支撑与失衡本质\"># 一、底层逻辑：MySQL性能的核心支撑与失衡本质</h1>\n<p>MySQL性能的底层核心是“资源消耗与结构设计的平衡”，所有慢查询与性能瓶颈，本质都是存储结构、资源分配或执行逻辑出现了失衡。</p>\n<h2 id=\"-11-存储引擎核心b树与磁盘io的底层关联\">## 1.1 存储引擎核心：B+树与磁盘IO的底层关联</h2>\n<p>InnoDB作为MySQL默认存储引擎，其核心存储结构为B+树，性能优劣直接由“磁盘IO次数”决定。B+树的设计特性决定了查询效率的上限：</p>\n<ul>\n<li>\n<p>- 结构特性：B+树为平衡树，叶子节点存储全量数据，非叶子节点仅存储索引键与指针；单页大小默认16KB，高度通常为1-3层，高度3的B+树可存储约2000万行数据。</p>\n</li>\n<li>\n<p>- IO成本：每次查询的IO次数=B+树高度+回表次数（非覆盖索引场景）。全表扫描需遍历所有叶子节点，IO次数飙升至百万级，是慢查询的核心诱因。</p>\n</li>\n<li>\n<p>- 缓存价值：InnoDB缓冲池（innodb_buffer_pool）可缓存数据页与索引页，命中率理想值需超过99%，缓存命中可直接避免磁盘IO，大幅提升查询速度。</p>\n</li>\n</ul>\n<h2 id=\"-12-性能核心维度四大资源的消耗平衡\">## 1.2 性能核心维度：四大资源的消耗平衡</h2>\n<p>MySQL性能瓶颈最终可归结为CPU、磁盘IO、内存、锁四大资源的消耗失衡，其中磁盘IO占比最高，是优化的核心靶点：</p>\n<ul>\n<li>\n<p>- CPU：用于SQL解析、排序、分组、函数计算等操作，低效排序与复杂计算易导致CPU过载。</p>\n</li>\n<li>\n<p>- 磁盘IO：数据页/索引页的读取与写入，全表扫描、索引失效是IO消耗激增的主要原因。</p>\n</li>\n<li>\n<p>- 内存：缓冲池缓存数据页，内存不足会导致缓存命中率下降，被迫频繁读取磁盘。</p>\n</li>\n<li>\n<p>- 锁：行锁/表锁引发的查询等待，如更新操作阻塞查询、高并发下的锁竞争，会间接拉长查询耗时。</p>\n</li>\n</ul>\n<h2 id=\"-13-慢查询的本质执行逻辑与资源消耗的双重失衡\">## 1.3 慢查询的本质：执行逻辑与资源消耗的双重失衡</h2>\n<p>慢查询并非“执行时间长”的表面现象，而是底层执行逻辑与资源消耗的双重问题：一是执行计划不合理（如全表扫描、索引失效），导致IO次数过多；二是资源竞争（如锁等待、缓存失效），导致有效执行时间被拉长。优化慢查询，本质就是优化执行计划、减少资源消耗、化解资源竞争。</p>\n<h1 id=\"-二问题定位从慢查询捕捉到执行计划解析\"># 二、问题定位：从慢查询捕捉到执行计划解析</h1>\n<p>精准定位问题是优化的前提，核心依赖“慢查询日志捕捉+执行计划分析”，实现从“发现问题”到“定位根源”的闭环。</p>\n<h2 id=\"-21-慢查询日志性能瓶颈的第一重捕捉\">## 2.1 慢查询日志：性能瓶颈的第一重捕捉</h2>\n<p>慢查询日志是记录低效SQL的核心工具，需合理配置阈值与存储路径，确保精准捕捉关键问题SQL。</p>\n<h3 id=\"-211-日志配置临时生效永久固化\">### 2.1.1 日志配置（临时生效+永久固化）</h3>\n<p>临时配置（重启MySQL后失效，适用于快速排查）：</p>\n<pre><code class=\"language-sql\">-- 设置慢查询阈值（单位：秒，生产环境建议0.5-1秒，平衡灵敏度与日志量）\nSET GLOBAL long_query_time = 0.5; \n-- 开启慢查询日志\nSET GLOBAL slow_query_log = 'ON';\n-- 指定日志文件路径（需确保MySQL有写入权限）\nSET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';\n-- 记录未使用索引的查询（辅助定位索引失效场景）\nSET GLOBAL log_queries_not_using_indexes = 'ON';\n</code></pre>\n<p>永久配置（修改my.cnf文件，重启后生效，适用于生产环境常态化监控）：</p>\n<pre><code class=\"language-ini\">[mysqld]\nslow_query_log = 1\nslow_query_log_file = /var/log/mysql/slow.log\nlong_query_time = 0.5\nlog_queries_not_using_indexes = 1\n</code></pre>\n<h3 id=\"-212-日志分析工具提取核心问题sql\">### 2.1.2 日志分析工具：提取核心问题SQL</h3>\n<p>慢查询日志需通过工具解析，才能快速定位高频、高耗的核心SQL，常用工具分为两类：</p>\n<ul>\n<li>\n<p>- pt-query-digest（Percona Toolkit）：分析维度最全面，支持输出执行次数、平均耗时、扫描行数、锁等待时间等指标，适合复杂场景： <code>pt-query-digest /var/log/mysql/slow.log &gt; slow_report.txt</code></p>\n</li>\n<li>\n<p>- mysqldumpslow（MySQL自带工具）：轻量便捷，适合快速提取TopN慢查询： <code>-- 提取耗时最多的10条SELECT语句</code> <code>mysqldumpslow -s t -t 10 -g 'select' /var/log/mysql/slow.log</code></p>\n</li>\n</ul>\n<p>分析报告需重点关注“执行次数多+平均耗时长”“扫描行数多”“锁等待时间长”三类SQL，这类SQL对整体性能影响最大，优先纳入优化清单。</p>\n<h2 id=\"-22-explain执行计划读懂mysql的执行逻辑\">## 2.2 EXPLAIN执行计划：读懂MySQL的执行逻辑</h2>\n<p>捕捉到慢查询后，需通过EXPLAIN关键字分析执行计划，判断索引是否生效、查询是否存在低效操作，核心是读懂MySQL的“执行思路”。</p>\n<h3 id=\"-221-核心字段解读\">### 2.2.1 核心字段解读</h3>\n<p>执行<code>EXPLAIN SELECT * FROM orders WHERE user_id = 100 AND status = 'PAID';</code>后，重点关注以下字段：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>字段</td>\n<td>核心意义</td>\n<td>优化判断标准</td>\n</tr>\n<tr>\n<td>type</td>\n<td>访问类型，反映查询效率</td>\n<td>从优到劣：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL；需避免ALL（全表扫描）</td>\n</tr>\n<tr>\n<td>key</td>\n<td>实际使用的索引</td>\n<td>NULL表示未使用索引，需排查索引失效原因</td>\n</tr>\n<tr>\n<td>rows</td>\n<td>预估扫描行数</td>\n<td>数值越大，IO消耗越高，需通过索引缩小范围</td>\n</tr>\n<tr>\n<td>Extra</td>\n<td>附加执行信息</td>\n<td>Using filesort/Using temporary需优化；Using index为理想状态（覆盖索引）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"-222-关键判断逻辑\">### 2.2.2 关键判断逻辑</h3>\n<p>通过执行计划可快速定位核心问题：若type为ALL（全表扫描），优先排查索引是否缺失或失效；若Extra出现Using filesort，说明排序未使用索引，需优化排序字段；若rows远大于实际返回行数，说明索引选择性差，需调整索引设计。</p>\n<h1 id=\"-三核心优化索引设计与失效规避的实战指南\"># 三、核心优化：索引设计与失效规避的实战指南</h1>\n<p>索引是MySQL性能优化的核心手段，其本质是“基于B+树的有序数据结构”，目的是减少磁盘IO次数。优化索引需同时兼顾“设计合理性”与“避免失效”，遵循底层逻辑与实战原则。</p>\n<h2 id=\"-31-索引设计的三大核心原则\">## 3.1 索引设计的三大核心原则</h2>\n<p>索引设计并非“越多越好”，而是要在“查询效率”与“维护成本”之间找到平衡，核心遵循三大原则：</p>\n<h3 id=\"-311-选择性优先原则\">### 3.1.1 选择性优先原则</h3>\n<p>索引选择性=唯一值数量/总行数，选择性越高，索引定位精度越强，IO次数越少。设计时需将高选择性字段（如用户ID、订单号）放在联合索引前列，低选择性字段（如性别、状态，选择性&lt;0.1）尽量不单独建索引，避免优化器放弃使用。</p>\n<h3 id=\"-312-三星索引原则实战核心\">### 3.1.2 三星索引原则（实战核心）</h3>\n<p>三星索引是理想的索引设计标准，可最大化减少IO与计算消耗：</p>\n<ul>\n<li>\n<p>- 一星：WHERE条件列纳入索引，缩小扫描范围；</p>\n</li>\n<li>\n<p>- 二星：ORDER BY/GROUP BY列纳入索引，利用索引有序性避免排序（Using filesort）；</p>\n</li>\n<li>\n<p>- 三星：SELECT查询列被索引覆盖，避免回表操作（Extra显示Using index）。</p>\n</li>\n</ul>\n<p>示例：查询<code>SELECT user_id, username FROM users WHERE email = 'user@deepseek.com';</code>，设计覆盖索引<code>ALTER TABLE users ADD INDEX idx_email_cover (email, user_id, username);</code>，可实现无回表、无排序的高效查询。</p>\n<h3 id=\"-313-最小维护成本原则\">### 3.1.3 最小维护成本原则</h3>\n<p>索引会增加插入、更新、删除操作的维护成本（需调整B+树结构），设计时需：</p>\n<ul>\n<li>\n<p>- 控制单表索引数在5个以内，避免冗余索引（如已有(a,b)联合索引，单独a索引为冗余）；</p>\n</li>\n<li>\n<p>- 大文本、Blob字段不建索引，避免索引体积过大；</p>\n</li>\n<li>\n<p>- 联合索引需覆盖高频查询场景，减少重复索引。</p>\n</li>\n</ul>\n<h3 id=\"-314-联合索引的字段顺序技巧\">### 3.1.4 联合索引的字段顺序技巧</h3>\n<p>联合索引遵循“最左前缀原则”，本质是基于B+树的有序存储特性，设计时需遵循：</p>\n<ul>\n<li>\n<p>- 等值查询字段在前，范围查询字段在后（如(a,b)联合索引，a=1 AND b&gt;10可走索引，b&gt;10则不可）；</p>\n</li>\n<li>\n<p>- 高频查询字段在前，低频字段在后，确保更多查询能命中索引前缀。</p>\n</li>\n</ul>\n<p>示例：查询<code>SELECT * FROM sales WHERE region='Asia' AND category='Tech' AND sale_date BETWEEN '2023-01-01' AND '2023-12-31' ORDER BY revenue DESC;</code>，最优联合索引为<code>idx_region_category_date (region, category, sale_date)</code>。</p>\n<h2 id=\"-32-索引失效的十大典型场景与解决方案\">## 3.2 索引失效的十大典型场景与解决方案</h2>\n<p>索引失效是慢查询的主要诱因，本质是破坏了B+树的有序性或定位规则，以下是实战中最常见的场景及优化方案：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>失效场景</td>\n<td>错误示例</td>\n<td>优化方案</td>\n</tr>\n<tr>\n<td>索引列参与计算/函数</td>\n<td>SELECT * FROM users WHERE YEAR(create_time) = 2023;</td>\n<td>SELECT * FROM users WHERE create_time BETWEEN '2023-01-01' AND '2023-12-31';</td>\n</tr>\n<tr>\n<td>隐式类型转换</td>\n<td>SELECT * FROM logs WHERE user_id = '123'（user_id为INT）;</td>\n<td>SELECT * FROM logs WHERE user_id = 123（匹配字段类型）;</td>\n</tr>\n<tr>\n<td>LIKE以%开头</td>\n<td>SELECT * FROM user WHERE userId LIKE '%123';</td>\n<td>改用覆盖索引或LIKE '123%';</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-01-15 22:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/liuziyi1\">刘子毅</a>&nbsp;\n阅读(<span id=\"post_view_count\">56</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "CLAUDE.md 全方位指南：构建高效 AI 开发上下文",
      "link": "https://www.cnblogs.com/didispace/p/19489098",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/didispace/p/19489098\" id=\"cb_post_title_url\" title=\"发布于 2026-01-15 20:09\">\n    <span>CLAUDE.md 全方位指南：构建高效 AI 开发上下文</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>如果你是 Claude 的日常用户，你一定熟悉这个场景：每次开启一个新的对话，都必须不厌其烦地重复设置项目背景、编码规范和特定的指令。这不仅耗时，也容易出错。当你忘记提醒某个关键细节时，就不得不花更多时间去修复那些不符合规范的代码。</p>\n<p>CLAUDE.md 文件正是解决这一痛点的关键。它就像 Claude 的项目专属记忆，让 AI 在每次对话开始前自动加载并记住你的所有偏好。这是一个简单而强大的功能，但大多数用户仅仅停留在基础层面。</p>\n<p>事实上，要真正释放 CLAUDE.md 的威力，需要掌握一些更深刻、甚至有些违反直觉的技巧。本文将为你揭示其中最关键的五个，帮助你将这个简单的配置文件，转变为一个能够持续进化的项目知识库。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"1-你的-claudemd-应该是一个活的文档而不是一次性配置\">1. 你的 CLAUDE.md 应该是一个“活的文档”，而不是“一次性配置”</h2>\n<p>许多人认为 CLAUDE.md 文件只需在项目开始时配置一次，然后就可以置之不理。这是一个巨大的误区。最有效的 CLAUDE.md 应该随着项目的演进而持续更新和优化。</p>\n<p>最佳的维护方式是在日常工作中“有机地”构建它。例如，当 Claude 做出了一个需要纠正的假设——比如它建议使用 console.log 进行调试，而你的团队规范是使用特定的日志库——不要只是临时修正。直接告诉 Claude：“将‘总是使用日志库而不是 console.log’这条规则添加到我的 CLAUDE.md 文件中。” 这样，你的修正就会沉淀下来，在未来的所有会话中生效。值得注意的是，早期版本的 Claude 有一个 # 快捷键来添加指令，但在 2.0.70 版本后已被移除。目前，直接请求 Claude 进行修改是官方推荐的最佳实践。</p>\n<p>这种做法的价值在于，它能实时捕捉并固化工作流程中的隐性知识。正如一个精妙的比喻所说：</p>\n<p>这就像在会议中做笔记，不同的是，这些笔记真的会被使用。</p>\n<p>更高级的维护方法是将其与团队协作流程结合。在代码审查（Code Review）中发现的未被文档化的规范，正是更新 CLAUDE.md 的绝佳时机。一个由 Boris Cherny 分享的高效工作流是：通过 GitHub Action，你甚至可以直接在 PR 评论中 @claude，让它将新规范添加到 CLAUDE.md 文件中。这创建了一个强大的反馈循环，将团队的集体智慧源源不断地沉淀到这个核心文件中。</p>\n<h2 id=\"2-少即是多上下文是宝贵资源精简至上\">2. 少即是多：上下文是宝贵资源，精简至上</h2>\n<p>人们普遍认为，提供给 AI 的上下文越多，结果就越好。然而在使用 CLAUDE.md 时，这个直觉可能是错误的。</p>\n<p>核心论点是：“上下文是宝贵的（Context is precious）”。CLAUDE.md 中的每一行内容，都在与你当前的工作指令竞争 AI 的注意力。一个臃肿、充满冗余信息的文件，反而可能稀释掉最关键的指令，导致 AI 抓不住重点。<br />\n因此，精简至上。一个很好的起点是使用 /init 命令，它会根据你的项目结构和技术栈生成一个初始文件。我的建议是，以此为基础，然后删除所有你不需要的内容。从现有内容中删除比从零开始创建要容易得多。</p>\n<p>一般建议将文件长度保持在 300 行以下。当然，这并非硬性规定。对于一些具有复杂约定或非寻常模式的 codebase，一个更长的 CLAUDE.md 反而能通过预先加载足够的上下文，有效防止 Claude 做出错误假设。关键在于，文件中的每一行都应该有其明确的价值。毫不留情地删除那些显而易见的废话（例如“请编写高质量代码”）或没有实际指导意义的“填充”信息。</p>\n<p>精简的 CLAUDE.md 迫使你仔细思考并只保留最重要的指令。这不仅能节省宝贵的上下文空间，更能确保 AI 在处理你的请求时，能够更准确地聚焦于核心要求，而不是在大量无关信息中迷失方向。</p>\n<h2 id=\"3-超越单个文件用模块化结构管理复杂性\">3. 超越单个文件：用模块化结构管理复杂性</h2>\n<p>许多用户只知道在项目根目录下创建一个 CLAUDE.md 文件。这对于小型项目来说足够了，但对于大型或结构复杂的项目，存在着更优雅、更强大的模块化管理方式。</p>\n<ul>\n<li>@imports 语法 你可以使用 @path/to/file 语法，从主 CLAUDE.md 文件中引用其他文件的内容。这能让主文件保持简洁，同时将详细的规范拆分到独立的文档中。例如，你可以将复杂的 API 设计模式放在 docs/api-patterns.md 中，然后在主文件里用 @docs/api-patterns.md 引用它。</li>\n<li>.claude/rules/ 目录 这是一个非常适合大型团队的结构。所有放在 .claude/rules/ 目录下的 .md 文件都会被 Claude 自动加载，无需手动 @import。这使得不同领域的团队可以独立维护各自的规则文件，例如，前端团队维护 code-style.md，安全团队维护 security.md。大家各司其职，有效避免了在单个大文件中频繁产生合并冲突。</li>\n<li>子目录中的 CLAUDE.md 对于 Monorepo（单一代码库）项目，这是一个绝佳的解决方案。你可以在项目的特定子目录（例如 api/ 或 packages/ui/）中放置 CLAUDE.md 文件。这些文件非常特殊：它们并不会在会话启动时加载，而只在 Claude 主动处理该特定子目录中的内容时才会被包含进来。这使得你可以为项目的不同模块定义截然不同的规范，实现真正精细化的上下文管理。<br />\n• 个人配置 CLAUDE.local.md 还有一个关键文件：CLAUDE.local.md。它用于存放那些不应提交到版本控制中的个人偏好，例如你习惯的编辑器 quirks 或偏好的代码冗余度。由于这是个人专属的，请务必将其添加到 .gitignore 文件中，以避免将个人配置泄露给整个团队。</li>\n</ul>\n<h2 id=\"4-魔鬼在细节中文件名是区分大小写的\">4. 魔鬼在细节中：文件名是区分大小写的</h2>\n<p>这是一个极其微小但至关重要的技术细节，也是最容易被忽略的陷阱之一：CLAUDE.md 这个文件名是区分大小写的。</p>\n<p>正确的文件名必须是“CLAUDE.md”——CLAUDE 部分为大写，.md 扩展名为小写。如果你将其命名为 claude.md、Claude.md 或其他任何变体，Claude 的系统将无法识别并加载它。</p>\n<p>这个细节之所以重要，是因为它是一个典型的“陷阱”（gotcha）。有趣的是，这一点在官方文档中并未明确说明。我是通过询问官方文档的 AI 助手才最终确认了这一规则。一旦出错，你可能会花费大量时间排查为什么自己精心编写的指令完全没有生效，最终才发现问题出在一个简单的大小写错误上。这个看似微不足道的细节，恰恰体现了与 AI 高效协作时，精确配置的重要性。</p>\n<h2 id=\"5-让-ai-优化-ai定期请-claude-审查自己的说明书\">5. 让 AI 优化 AI：定期请 Claude 审查自己的“说明书”</h2>\n<p>这是一个非常巧妙的“元认知”技巧：定期让 Claude 自己来审查和优化它的“说明书”——CLAUDE.md 文件。</p>\n<p>随着时间的推移，CLAUDE.md 中不可避免地会积累一些过时、冗余甚至相互冲突的指令。通过一个简单的提示，例如“请审查这个 CLAUDE.md 文件，并提出改进建议以使其更清晰、更高效”，你可以利用 Claude 自身的能力来发现这些问题。它可能会建议你合并重复的规则，或澄清模糊的表述。</p>\n<p>对于那些绝对不能违反的关键规则，你可以使用强调词来引起 Claude 的注意，比如 IMPORTANT: 或 YOU MUST。这能提高 Claude 遵循这些指令的概率，但请务必谨慎使用。正如一句古老的建议所说：如果所有东西都被标记为重要，那就没有什么是重要的了。</p>\n<p>诚然，这需要一些维护成本，但其回报是巨大的。正如源文所说：<br />\n这听起来像是维护开销。确实是。但它比在每个会话中重复自己的话，或修复那些忽略了你的规范的代码要省事得多。</p>\n<p>这不仅仅是一种文件维护策略，更是一种与 AI 协作的新范式。我们不再仅仅是 AI 的使用者，更是其成长过程中的引导者，让工具本身参与到自我完善的流程中，形成一个持续改进的良性循环。</p>\n<h2 id=\"结论\">结论</h2>\n<p>CLAUDE.md 远不止一个简单的配置文件。通过本文分享的五个高级技巧——将其视为活文档、保持精简、模块化管理、注意大小写，以及让 AI 自我优化——你可以将其从一个静态的指令列表，转变为一个强大的、与项目共同成长的动态知识库。</p>\n<p>这些策略代表了一种更深层次的思维方式：将你的 AI 上下文本身视为一个“代码库”。它也需要像代码一样被重构、被审查、被持续改进。你的 CLAUDE.md 值得你如此对待。现在，不妨思考一下：你的 CLAUDE.md 中沉淀了多少团队智慧？或许，现在就是开始构建它的最佳时机。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-15 20:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/didispace\">程序猿DD</a>&nbsp;\n阅读(<span id=\"post_view_count\">49</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【笔记】A Conceptual Overview of asyncio",
      "link": "https://www.cnblogs.com/wngtk/p/19491520",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wngtk/p/19491520\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 14:07\">\n    <span>【笔记】A Conceptual Overview of asyncio</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>读了这两篇（也可以说是一篇），我才正确认识了 Python 的协程。不能直接把 Python async/await 当作 JavaScript async/await一样的东西。</p>\n<ul>\n<li><a href=\"https://docs.python.org/3/howto/a-conceptual-overview-of-asyncio.html\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.python.org/3/howto/a-conceptual-overview-of-asyncio.html</a></li>\n<li><a href=\"https://github.com/anordin95/a-conceptual-overview-of-asyncio/tree/main\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anordin95/a-conceptual-overview-of-asyncio/tree/main</a></li>\n</ul>\n<p>在学习 Python 协程之前，我对 JavaScript 协程已经略有了解，在 JavaScript async/await 很直觉直接用就可以，在学习 Python 协程的过程中，我发现我对 JavaScript Promise 也忘了不少，之前写过一个博客记录。</p>\n<h2 id=\"一开始我不熟悉-python-asyncio\">一开始我不熟悉 Python asyncio</h2>\n<p>Python 的协程用起来需要用<code>asyncio.run()</code>，在 Python 3.6 还没有<code>asyncio.run()</code>。<code>asyncio.create_task()</code> 为什么报错 No running event loop</p>\n<pre><code class=\"language-python\">Python 3.12.3 (main, Jan  8 2026, 11:30:50) [GCC 13.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; async def foo(): ...\n...\n&gt;&gt;&gt; asyncio.create_task(foo())\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/usr/lib/python3.12/asyncio/tasks.py\", line 417, in create_task\n    loop = events.get_running_loop()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\nRuntimeError: no running event loop\n&gt;&gt;&gt;\n</code></pre>\n<h2 id=\"协程不会立刻执行\">协程不会立刻执行</h2>\n<p>调用异步函数，创建了一个协程对象。协程对象内部的逻辑不会立刻执行，等到事件循环拥有控制权，并且启动/继续协程的时候，协程的逻辑才会执行。</p>\n<pre><code class=\"language-python\">Python 3.12.3 (main, Jan  8 2026, 11:30:50) [GCC 13.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; async def foo(): print('bar')\n...\n&gt;&gt;&gt; foo()\n&lt;coroutine object foo at 0x720ef6db5a80&gt;\n&gt;&gt;&gt;\n</code></pre>\n<p>我们可以看到协程的内部的逻辑没有执行。要执行这个协程我们可以使用 <code>asyncio.run()</code>。</p>\n<pre><code class=\"language-python\">&gt;&gt;&gt; asyncio.run(foo())\nbar\n</code></pre>\n<p>在 Python 的协程中，要想启动另外一个协程，就要用 <code>asyncio.create_task()</code> 创建一个 Task 并且和事件循环关联起来，这个函数会找到当前正在运行的事件循环。一个线程只有一个正在运行的事件循环。</p>\n<p><code>asyncio.run()</code> 和 <code>asyncio.create_task()</code> 帮我做了一些事情，但是我不知道他到底干什么了。老实说，我很讨厌编程语言各种隐式的行为。</p>\n<p><code>asyncio.run()</code> 相当于是这样几行：</p>\n<pre><code class=\"language-python\">loop = asyncio.new_event_loop()\ntask = asyncio.Task(foo(), loop=loop)\nloop.run_util_complete(task)\n</code></pre>\n<p>run_util_complete 支持 coroutine，也可以不手动创建 Task.</p>\n<pre><code class=\"language-python\">loop = asyncio.new_event_loop()\nloop.run_util_complete(foo())\n</code></pre>\n<p>我们见到了手动创建 Task 的方法，可以想象到 create_task 是如何知道放在哪个事件循环上的。</p>\n<pre><code class=\"language-python\">def create_task(coro):\n  loop = asyncio.get_running_loop()\n  return asyncio.Task(coro, loop=loop)\n</code></pre>\n<p>JavaScript 调用异步函数直接就执行了函数体，哪怕你不加 await。JavaScript 异步函数体就相当于传递给 Promise 的回调函数。</p>\n<pre><code class=\"language-js\">let promise = new Promise(function(resolve, reject) {\n  // this function will executes immediately\n})\n</code></pre>\n<h2 id=\"让步控制权给事件循环\">让步控制权给事件循环</h2>\n<pre><code>class YieldToEventLoop:\n    def __await__(self):\n        yield\n</code></pre>\n<blockquote>\n<p>The only way to yield (or effectively cede control) from a coroutine is to await an object that <code>yield</code>s in its <code>__await__</code> method.</p>\n</blockquote>\n<p><strong>在一个对象的 <code>__await__</code> 方法中 yield 是让步控制权给事件循环的唯一的方式</strong>。<code>await object</code> 会调用对象的 <code>__awit__</code> 方法。</p>\n<p>await coroutine 不会将控制权交给事件循环，简单的 await coroutine 就好似 yield from generator。这对熟悉 JavaScript 协程的人是很反直觉的。Python 的经典协程，也就是 Python 生成器当作协程使用，但是我们没有事件循环。</p>\n<p>coroutine 指的是 coroutine object。调用一个 async function 会创建一个 coroutine object。</p>\n<p><strong>await 一个 Task(Future) 对象就会让步控制给事件循环</strong>。Task 是 Future 的子类，Future 的 <code>__await__</code> 方法会 yield。</p>\n<p>注意，我们不能直接在异步函数（协程函数）里面直接写 yield 实现让步控制给事件循环，调用函数就会变成异步生成器。</p>\n<h2 id=\"我们需要持有-task-对象并且-await\">我们需要持有 Task 对象，并且 await</h2>\n<blockquote>\n<p>It’s important to be aware that the task itself is not added to the event loop, only a callback to the task is. This matters if the task object you created is garbage collected before it’s called by the event loop</p>\n</blockquote>\n<p>Task 对象一定要有变量持有，并 await。不然当变量超出作用域，被 GC 回收后，协程没执行完自己就静悄悄退出了（不会报错）。Task 对象 GC 回收，<s>那么 coroutine 对象也被回收了</s>。</p>\n<p>说实话，我很难理解事件循环没有 Task 对象。但是反过来 JavaScript 的 Promise .then 的时候不就是在注册回调函数吗，V8 的微任务队列里面不是保存 Promise 的对象，是回调函数啊。</p>\n<pre><code class=\"language-python\">import asyncio\n\nasync def async_print(str):\n    print(str)\n\nasync def coro_a():\n    for _ in range(3):\n        await async_print(\"I am coro_a()!\")\n\nclass YieldToEventLoop:\n    def __await__(self):\n        yield\n\nasync def coro_b():\n    for _ in range(3):\n        print(\"I am coro_b()!\")\n        await YieldToEventLoop() # neccessay to show coro_b() one time\n\nasync def main():\n    task = asyncio.create_task(coro_b())\n    await coro_a()\n\nasyncio.run(main())\n\n# Output:\n# I am coro_a()!\n# I am coro_a()!\n# I am coro_a()!\n# I am coro_b()!\n\n</code></pre>\n<p>如果读懂了这个例子，那也就读懂了整篇笔记或者原文了。</p>\n<p>main() 函数创建 task 后没有 await task，不会让步控制权给事件循环，所以 main 函数继续执行。await coro_a 在 await coroutine，不会让步控制给事件循环，执行 coro_a()。<code>coro_a()</code> await 的也是协程对象，也不会让步给事件循环，所以连着打印了三次<code>I am coro_a()!</code>。循环执行完毕后 <code>main()</code> 协程对象执行完了，事件循环才拿到控制权，开始执行 <code>coro_b</code> 的逻辑。<code>coro_b</code> 刚开始一次，协程 <code>await YieldToEvnetLoop</code> 让步控制给事件循环。因为 main() 函数早已执行完毕退出 task 早已超出作用域，被 GC 回收，等事件循环再次运行 coro_b 的时候发现对应的 Task 对象已经被 GC 回收了。所以就打印了一次 <code>I am coro_b()!</code>。</p>\n<p>我很好奇，这个地方创建回调函数的时候怎么就没有形成闭包呢？怎么就没有把 task 对象隐藏在闭包里面呢？</p>\n<h2 id=\"总结\">总结</h2>\n<p>await 协程不会让步控制权，await Future 才会让步控制权给 Event Loop。实现协程让步就是在 <code>__await__</code> 方法中 yield。</p>\n<p>Python 不像 JavaScript 有微任务队列，我们需要自己主动去创建事件循环，并将任务放到事件循环中去，当然更准确的说法是在事件循环中注册回调函数。也就是 <code>asyncio.create_task()</code>, <code>asyncio.run()</code> 这两个函数。</p>\n<p>JavaScript 都是 Promise 对象，await Promise 对象就会让步。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 14:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wngtk\">wngtk</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}