{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "Contrastive Learning 对比学习 | InfoNCE loss 与互信息的数学关联",
      "link": "https://www.cnblogs.com/moonout/p/19432533",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/moonout/p/19432533\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 20:07\">\n    <span>Contrastive Learning 对比学习 | InfoNCE loss 与互信息的数学关联</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        InfoNCE loss 可以表示互信息的下界：I(X;Y) ≥ log N - L_InfoNCE 。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<br />\n<p>参考博客：<a href=\"https://blog.csdn.net/iiiiii11/article/details/154584585\" rel=\"noopener nofollow\" target=\"_blank\">CSDN | 【理论推导】互信息与 InfoNCE 损失：从公式推导理解对比学习的本质</a> ，感觉是讲的最清楚的一个博客。</p>\n<hr />\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#1-infonce-loss-和互信息的数学形式\" rel=\"noopener nofollow\">1 InfoNCE loss 和互信息的数学形式</a><ul><li><a href=\"#11-互信息的数学形式\" rel=\"noopener nofollow\">1.1 互信息的数学形式</a></li><li><a href=\"#12-infonce-loss-的数学形式\" rel=\"noopener nofollow\">1.2 InfoNCE loss 的数学形式</a></li><li><a href=\"#13-为什么我们希望最大化--的互信息\" rel=\"noopener nofollow\">1.3 为什么我们希望最大化 <span class=\"math inline\">\\((X,Y)\\)</span> 的互信息</a></li></ul></li><li><a href=\"#2-infonce-loss-与互信息的数学关联\" rel=\"noopener nofollow\">2 InfoNCE loss 与互信息的数学关联</a></li><li><a href=\"#3-证明过程\" rel=\"noopener nofollow\">3 证明过程</a><ul><li><a href=\"#31-第一步证明使-infonce-loss-取值最小的-满足-\" rel=\"noopener nofollow\">3.1 第一步：证明使 InfoNCE loss 取值最小的 <span class=\"math inline\">\\(f(x,y)\\)</span>，满足 <span class=\"math inline\">\\(f(x, y) = \\log [p(y|x) / p(y)]\\)</span></a></li><li><a href=\"#32-第二步将以上--代入推导互信息下界\" rel=\"noopener nofollow\">3.2 第二步：将以上 <span class=\"math inline\">\\(f(x,y)\\)</span> 代入，推导互信息下界</a></li></ul></li></ul></div><p></p>\n<hr />\n<h2 id=\"1-infonce-loss-和互信息的数学形式\">1 InfoNCE loss 和互信息的数学形式</h2>\n<h3 id=\"11-互信息的数学形式\">1.1 互信息的数学形式</h3>\n<p>互信息 <span class=\"math inline\">\\(I(X,Y)\\)</span> 是信息论中的核心概念，用于衡量两个随机变量 <span class=\"math inline\">\\(X,Y\\)</span> 之间的依赖程度。</p>\n<p>从直观上理解，互信息回答了这样一个问题：知道一个变量 Y 后，我们对另一个变量 X 的不确定性减少了多少？如果 X 的不确定性减少较多，则代表 XY 之间的互信息较大（为正）；如果 X 的不确定性没有减少，则 XY 是相互独立的，即 <span class=\"math inline\">\\(P(X)P(Y) = P(X,Y)\\)</span>，XY 之间的互信息为 0。</p>\n<p>数学上，互信息有三种等价的定义方式：</p>\n<p>① 基于联合分布 <span class=\"math inline\">\\(p(x,y)\\)</span> 和边缘分布 <span class=\"math inline\">\\(p(x)p(y)\\)</span> 的 KL 散度的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = D_{KL}\\big(p(x,y) ~\\|~ p(x)p(y)\\big) = \\mathbb{E}_{p(x,y)}\\left[\\log\\frac{p(x,y)}{p(x)p(y)}\\right]\n\\]</div><p></p><p>这个形式直接体现了互信息的本质：它衡量的是联合分布 <span class=\"math inline\">\\(p(x,y)\\)</span> 与假设 X 和 Y 独立时的分布 <span class=\"math inline\">\\(p(x)p(y)\\)</span> 之间的差异。如果 X 和 Y 独立，这个差异为 0，否则为正数，差异越大说明两个变量关联越强。</p>\n<p>② 基于熵的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = H(X) - H(X|Y) = H(Y) - H(Y|X)\n\\]</div><p></p><p>这里 <span class=\"math inline\">\\(H(X)=\\int p(x)\\log p(x)\\)</span> 是 X 的熵（不确定性），<span class=\"math inline\">\\(H(X|Y)\\)</span> 是已知 Y 时 X 的条件熵，互信息则是不确定性的减少量。</p>\n<p>③ 基于条件概率的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}_{p(x,y)}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n\\]</div><p></p><p>这个形式在对比学习中特别有用，因为它直接表达了“在给定 x 的情况下，y 的概率相对于其先验概率的变化”。</p>\n<h3 id=\"12-infonce-loss-的数学形式\">1.2 InfoNCE loss 的数学形式</h3>\n<p>InfoNCE loss 是现代对比学习（Contrastive Learning）的核心。它的设计灵感来自一个简单的直觉：从一堆样本中，找出与给定样本 x 匹配的正样本 y。</p>\n<p>具体的，假设我们有一个正样本对 <span class=\"math inline\">\\((x, y)\\)</span>，比如同一张图片的两种不同数据增强结果，同时从数据集中随机采样 <span class=\"math inline\">\\(N-1\\)</span> 个负样本 <span class=\"math inline\">\\(y_2, y_3, ..., y_N\\)</span>。我们定义一个评分函数 <span class=\"math inline\">\\(f(x, y)\\)</span>（通常是神经网络）来衡量 x 和 y 的相似度。InfoNCE loss 的形式为：</p>\n<p></p><div class=\"math display\">\\[L = -\\mathbb{E}\\left[\\log\\frac{e^{f(x,y)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}}\\right]\n\\]</div><p></p><p>其中，分子 <span class=\"math inline\">\\(e^{f(x,y)}\\)</span> 是正样本的得分，而分母 <span class=\"math inline\">\\(\\sum_{j=1}^{N} e^{f(x,y_j)}\\)</span> 是所有样本（1 个正样本 + N-1 个负样本）得分的总和。整个分式表示：给定 x 和 N 个候选 y，我们正确选出正样本 y 的概率。</p>\n<p>也可将其视为交叉熵损失（cross-entropy loss）的一个变种。交叉熵损失的形式如下：</p>\n<p></p><div class=\"math display\">\\[L_\\text{CE} = \\sum p(a)\\log \\hat p(a)\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(p(a)\\)</span> 为真是概率，而 <span class=\"math inline\">\\(\\hat p(a)\\)</span> 是我们估计的概率。在 InfoNCE loss 的 setting 中，真概率 <span class=\"math inline\">\\(p(x,y) = 1\\)</span>，而 <span class=\"math inline\">\\(p(x,y_j) = 0\\)</span>。</p>\n<h3 id=\"13-为什么我们希望最大化--的互信息\">1.3 为什么我们希望最大化 <span class=\"math inline\">\\((X,Y)\\)</span> 的互信息</h3>\n<p>在对比学习中，我们希望最大化正样本对的互信息，同时最小化正负样本之间的互信息。这迫使编码器提取出两个不同视图（view）的共享信息（比如同一张图片的不同数据增强版本、语言 / 视觉等不同的模态），这些信息通常对应于数据的内在语义，例如物体的类别、场景等，而忽略无关的噪声或增强引入的变化。</p>\n<p>在 <a href=\"https://www.cnblogs.com/moonout/tag/Skill%20Discovery/\" target=\"_blank\">skill discovery</a>（强化学习的一个子领域）中，我们希望最大化 skill z 和 state s 之间的互信息。从信息理论的角度，最大化 <span class=\"math inline\">\\(I(S;Z)\\)</span> 意味着，我们希望从状态 <span class=\"math inline\">\\(s\\)</span> 中尽可能多地获取关于技能 <span class=\"math inline\">\\(z\\)</span> 的信息。这确保了技能是“有区分度的”：看到智能体的行为，我们就能推断出它使用了哪个技能。</p>\n<h2 id=\"2-infonce-loss-与互信息的数学关联\">2 InfoNCE loss 与互信息的数学关联</h2>\n<p>核心结论：最小化 InfoNCE loss，等价于最大化互信息的一个下界。</p>\n<p>（互信息下界的含义是，互信息的取值将会大于这个值。从这个角度来说，下界的值越大，互信息的值就随之变大，所以，我们最小化 InfoNCE loss，相当于在推动互信息最大化。）</p>\n<p>具体来说，对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，有以下不等式成立：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(L\\)</span> 是我们模型的 InfoNCE loss，这个差值就是互信息的下界。</p>\n<h2 id=\"3-证明过程\">3 证明过程</h2>\n<p>证明过程可以分为两步：</p>\n<h3 id=\"31-第一步证明使-infonce-loss-取值最小的-满足-\">3.1 第一步：证明使 InfoNCE loss 取值最小的 <span class=\"math inline\">\\(f(x,y)\\)</span>，满足 <span class=\"math inline\">\\(f(x, y) = \\log [p(y|x) / p(y)]\\)</span></h3>\n<p>我们要证明：使 InfoNCE loss 最小的 <span class=\"math inline\">\\(f(x,y)\\)</span> 满足：</p>\n<p></p><div class=\"math display\">\\[f(x,y) = \\log\\frac{p(y|x)}{p(y)}\n\\]</div><p></p><p>我们考虑 InfoNCE loss 的期望形式：</p>\n<p></p><div class=\"math display\">\\[L = -\\mathbb{E}_{p(x,y)} \\left[\\log\\frac{e^{f(x,y)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}}\\right]\n\\]</div><p></p><p>我们可以将这个损失看作一个分类问题：给定 x 和 N 个样本 <span class=\"math inline\">\\({y_1, y_2, \\cdots, y_N}\\)</span>，其中只有 <span class=\"math inline\">\\(y_1=y\\)</span> 是正样本，其余是负样本。模型的任务是选出正样本。</p>\n<p>对于固定的 x，最优的分类器应该给出真实的后验概率，即给定 x 后，y 为这个 x 的正样本的概率。那么，真实的后验概率是多少呢？</p>\n<p>根据贝叶斯定理，在给定 x 和 y 样本集合的情况下，第 k 个样本是正样本的概率为（这个没完全看懂）：</p>\n<p></p><div class=\"math display\">\\[p(\\text{第 k 个是正样本} | x, {y_{1\\cdots N}}) = \\frac{p(y_k|x) \\prod_{i\\neq k} p(y_i) }{ \\sum_{j=1}^{N} p(y_j|x) \\prod_{i\\neq j} p(y_i)}\n\\]</div><p></p><p>化简后得到：</p>\n<p></p><div class=\"math display\">\\[= \\frac{p(y_k|x)/p(y_k)}{\\sum_{j=1}^{N} p(y_j|x)/p(y_j)}\n\\]</div><p></p><p>关键观察：如果我们取 <span class=\"math inline\">\\(f(x,y) = \\log\\frac{p(y|x)}{p(y)} + c(x)\\)</span>，其中 <span class=\"math inline\">\\(c(x)\\)</span> 是只依赖于 x 的任意函数，那么：</p>\n<p></p><div class=\"math display\">\\[\\frac{e^{f(x,y_k)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}} = \\frac{p(y_k|x)/p(y_k)}{\\sum_{j=1}^{N} p(y_j|x)/p(y_j)}\n\\]</div><p></p><p>这正是真实的后验分布。因此，这个 <span class=\"math inline\">\\(f(x,y)\\)</span> 取值使得模型的输出分布与真实分布完全一致，从而最小化 InfoNCE loss。</p>\n<p>为简便起见，我们通常取 <span class=\"math inline\">\\(c(x)=0\\)</span>，得到最优 <span class=\"math inline\">\\(f(x,y)\\)</span>：</p>\n<p></p><div class=\"math display\">\\[f^*(x,y) = \\log\\frac{p(y|x)}{p(y)}\n\\]</div><p></p><h3 id=\"32-第二步将以上--代入推导互信息下界\">3.2 第二步：将以上 <span class=\"math inline\">\\(f(x,y)\\)</span> 代入，推导互信息下界</h3>\n<p>现在我们将最优 <span class=\"math inline\">\\(f^*(x,y)\\)</span> 代入 InfoNCE loss：</p>\n<p></p><div class=\"math display\">\\[L_{\\text{min}} = -\\mathbb{E}\\left[\\log\\frac{e^{f^*(x,y)}}{\\sum_{j=1}^{N} e^{f^*(x,y_j)}}\\right]\n= -\\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right]\n\\]</div><p></p><p>考虑互信息 <span class=\"math inline\">\\(I(X;Y)\\)</span> 的以下形式：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n\\]</div><p></p><p>现在，我们想建立 <span class=\"math inline\">\\(I(X;Y)\\)</span> 和 <span class=\"math inline\">\\(L_{\\text{min}}\\)</span> 的关系。通过巧妙的代数变换，把互信息拆开：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n= \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right] + \\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\n\\]</div><p></p><p>第一项就是 <span class=\"math inline\">\\(-L_{\\text{min}}\\)</span> 吗？不完全是。实际上，<span class=\"math inline\">\\(-L_{\\text{min}}\\)</span> = 第一项 - log N：</p>\n<p></p><div class=\"math display\">\\[-L_{\\text{min}} = \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right]\n= \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right] - \\log N\n\\]</div><p></p><p>所以：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = (-L_{\\text{min}} + \\log N) + \\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\n\\]</div><p></p><p>现在看最后一项：<span class=\"math inline\">\\(\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\\)</span></p>\n<p>由于对数函数是凹函数，根据琴生不等式（Jensen's Inequality）：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}[\\log(Z)] \\leq \\log(\\mathbb{E}[Z])\n\\]</div><p></p><p>因此：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right] \\leq \\log\\left(\\mathbb{E}\\left[\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right]\\right)\n\\]</div><p></p><p>我们计算这个 log 里面的期望：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\frac{p(y_j|x)}{p(y_j)}\\right] = \\int p(y_j) \\cdot \\frac{p(y_j|x)}{p(y_j)} dy_j = \\int p(y_j|x) dy_j = 1\n\\]</div><p></p><p>期望 = 1。所以：</p>\n<p></p><div class=\"math display\">\\[\\log\\left(\\mathbb{E}\\left[\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right]\\right) = \\log(1) = 0\n\\]</div><p></p><p>代入上式 = 0，使用琴生不等式，因此：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right] \\leq 0\n\\]</div><p></p><p>将上式 ≤ 0 代回原式：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L_{\\text{min}}\n\\]</div><p></p><p>由于 <span class=\"math inline\">\\(f^*\\)</span> 是最优的，所以对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，有 <span class=\"math inline\">\\(L(f) \\geq L_{\\text{min}}\\)</span>，得到：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L_{\\text{min}} \\geq \\log N - L(f)\n\\]</div><p></p><p>证毕：对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，<span class=\"math inline\">\\(\\log N - L(f)\\)</span> 是互信息 <span class=\"math inline\">\\(I(X;Y)\\)</span> 的一个下界。</p>\n<br />\n<br />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 20:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/moonout\">MoonOut</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LangChain4j 工具调用实战",
      "link": "https://www.cnblogs.com/BNTang/p/19432093",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/BNTang/p/19432093\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 15:32\">\n    <span>LangChain4j 工具调用实战</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>你有没有遇到过这种场景：</p>\n<ul>\n<li>用户问 AI：\"帮我查下今天上海的天气\"</li>\n<li>AI 回答：\"抱歉，我无法获取实时信息。\"</li>\n</ul>\n<p><strong>问题的核心是：AI 没有工具。</strong>就像给你一双手脚，让你去盖房子，你也做不到。但如果给你一套工具箱，情况就完全不同了。</p>\n<p><strong>今天我们就来给 AI 装上一套工具箱</strong>，让它能够从博客园实时获取最新技术文章。</p>\n<h2 id=\"什么是工具调用\">什么是工具调用？</h2>\n<p>简单来说，工具调用就是让 AI 能够\"借用\"外部能力。</p>\n<p>这些能力包括但不限于：</p>\n<ul>\n<li>联网搜索</li>\n<li>调用第三方 API</li>\n<li>读写文件</li>\n<li>查询数据库</li>\n<li>执行代码</li>\n</ul>\n<p><strong>但有一个关键点要特别注意</strong>：</p>\n<p>工具调用 <strong>不是</strong> AI 自己去执行这些工具，而是 AI 说\"我需要调用 XX 工具\"，真正执行的是我们的应用程序。</p>\n<p>流程是这样的：</p>\n<pre><code>用户提问 → AI 分析意图 → AI 决定调用工具\n→ 我们的程序执行工具 → 把结果返回给 AI → AI 继续回答\n</code></pre>\n<h2 id=\"要实现的目标\">要实现的目标</h2>\n<p>让 AI 能够查询博客园用户的最新文章，并提取这些信息：</p>\n<ul>\n<li>文章标题</li>\n<li>文章链接</li>\n<li>发布日期</li>\n<li>摘要内容</li>\n<li>阅读数、评论数、推荐数</li>\n</ul>\n<p><strong>实现方案</strong>：用 Jsoup 抓取博客园页面，把数据整理后返回给 AI。</p>\n<h2 id=\"快速了解流程\">快速了解流程</h2>\n<p>完整流程其实很简单：</p>\n<ol>\n<li>用户提问 → 2. AI 分析意图 → 3. AI 决定调用工具 → 4. 程序执行工具 → 5. 结果返回给 AI → 6. AI 整理后回复用户</li>\n</ol>\n<p><strong>核心就是</strong>：AI 不直接调用工具，而是告诉我们的程序\"我需要调用这个工具\"，程序执行完后把结果给 AI，AI 再基于结果回答用户。</p>\n<blockquote>\n<p>想看详细的调用链路？文章最后有完整的时序图，包你一看就懂。</p>\n</blockquote>\n<h2 id=\"动手实现四步搞定\">动手实现（四步搞定）</h2>\n<h3 id=\"步骤-1引入依赖\">步骤 1：引入依赖</h3>\n<p>先在 <code>pom.xml</code> 中加入 Jsoup（网页爬虫库）：</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.jsoup&lt;/groupId&gt;\n    &lt;artifactId&gt;jsoup&lt;/artifactId&gt;\n    &lt;version&gt;1.20.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"步骤-2编写工具类\">步骤 2：编写工具类</h3>\n<p>在 <code>tools</code> 包下创建一个工具类，用 <code>@Tool</code> 注解告诉 LangChain4j：\"这是一个工具\"。</p>\n<p><strong>⚠️ 重点</strong>：工具描述一定要写清楚，AI 能否正确调用工具全看这个描述！</p>\n<pre><code class=\"language-java\">/**\n * 博客园文章搜索工具\n * 用于从博客园抓取用户的最新文章信息\n *\n * @author BNTang\n */\n@Slf4j\npublic class CnblogsArticleTool {\n\n    /**\n     * 从指定用户的博客园主页获取最新的技术文章列表。\n     * 支持提取文章标题、链接、发布日期、摘要、阅读数、评论数和推荐数等信息。\n     *\n     * @param input 博客园用户名或URL，可选地附加\"|N\"来限制结果数量\n     * @return 技术文章列表的JSON格式，包含详细信息，若失败则返回错误信息\n     */\n    @Tool(name = \"cnblogsSearch\", value = \"\"\"\n            从博客园获取最新文章。输入可以是：\n            - 博客园用户名（例如：'someUser'）\n            - 完整的个人主页URL（例如：'https://www.cnblogs.com/someUser/'）\n            可选择性地附加'|N'来限制结果数量，例如：'someUser|5'。\n            返回包含标题、链接、日期、摘要、阅读数、评论数、推荐数的JSON数组。\n            \"\"\"\n    )\n    public String searchCnblogsArticles(@P(value = \"用户名或URL（可选地附加|限制数量）\") String input) {\n        if (input == null || input.trim().isEmpty()) {\n            return \"{\\\"error\\\":\\\"Empty input\\\"}\";\n        }\n\n        String[] parts = input.trim().split(\"\\\\|\", 2);\n        String target = parts[0].trim();\n        int limit = 10;\n        if (parts.length == 2) {\n            try {\n                limit = Math.max(1, Math.min(100, Integer.parseInt(parts[1].trim())));\n            } catch (NumberFormatException ignored) { /* keep default */ }\n        }\n\n        String url;\n        if (target.startsWith(\"http://\") || target.startsWith(\"https://\")) {\n            url = target;\n        } else {\n            url = \"https://www.cnblogs.com/\" + target + \"/\";\n        }\n\n        Document doc = fetchDocumentWithRetries(url, 3, 8000);\n        if (doc == null) {\n            return \"{\\\"error\\\":\\\"Failed to fetch or parse page\\\"}\";\n        }\n\n        // 选择博客文章的主容器\n        Elements dayElements = doc.select(\".day\");\n\n        List&lt;ArticleInfo&gt; results = new ArrayList&lt;&gt;();\n\n        for (Element dayEl : dayElements) {\n            if (results.size() &gt;= limit) {\n                break;\n            }\n\n            // 提取标题和链接\n            Element titleEl = dayEl.selectFirst(\".postTitle a, .postTitle2\");\n            if (titleEl == null) {\n                continue;\n            }\n\n            String title = titleEl.text().trim();\n            // 移除\"[置顶]\"标记\n            title = title.replaceAll(\"^\\\\[置顶]\\\\s*\", \"\");\n\n            String href = titleEl.absUrl(\"href\");\n            if (href.isEmpty()) {\n                href = titleEl.attr(\"href\").trim();\n            }\n\n            // 去重检查\n            boolean seen = false;\n            for (ArticleInfo r : results) {\n                if (r.url.equals(href)) {\n                    seen = true;\n                    break;\n                }\n            }\n            if (seen) {\n                continue;\n            }\n\n            // 提取日期\n            String date = \"\";\n            Element dateEl = dayEl.selectFirst(\".dayTitle a\");\n            if (dateEl != null) {\n                date = dateEl.text().trim();\n            }\n\n            // 提取摘要\n            String summary = \"\";\n            Element summaryEl = dayEl.selectFirst(\".c_b_p_desc, .postCon\");\n            if (summaryEl != null) {\n                summary = summaryEl.text().trim();\n                // 移除\"阅读全文\"链接文本\n                summary = summary.replaceAll(\"阅读全文$\", \"\").trim();\n                // 限制摘要长度\n                if (summary.length() &gt; 200) {\n                    summary = summary.substring(0, 200) + \"...\";\n                }\n            }\n\n            // 提取统计信息\n            String viewCount = \"0\";\n            String commentCount = \"0\";\n            String diggCount = \"0\";\n\n            Element postDesc = dayEl.selectFirst(\".postDesc\");\n            if (postDesc != null) {\n                Element viewEl = postDesc.selectFirst(\".post-view-count\");\n                if (viewEl != null) {\n                    viewCount = extractNumber(viewEl.text());\n                }\n\n                Element commentEl = postDesc.selectFirst(\".post-comment-count\");\n                if (commentEl != null) {\n                    commentCount = extractNumber(commentEl.text());\n                }\n\n                Element diggEl = postDesc.selectFirst(\".post-digg-count\");\n                if (diggEl != null) {\n                    diggCount = extractNumber(diggEl.text());\n                }\n            }\n\n            if (!title.isEmpty() &amp;&amp; !href.isEmpty()) {\n                results.add(new ArticleInfo(title, href, date, summary, viewCount, commentCount, diggCount));\n            }\n        }\n\n        if (results.isEmpty()) {\n            return \"{\\\"message\\\":\\\"未找到文章。\\\"}\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for (int i = 0; i &lt; results.size(); i++) {\n            ArticleInfo article = results.get(i);\n            sb.append(\"{\");\n            sb.append(\"\\\"title\\\":\").append(jsonEscape(article.title)).append(\",\");\n            sb.append(\"\\\"url\\\":\").append(jsonEscape(article.url)).append(\",\");\n            sb.append(\"\\\"date\\\":\").append(jsonEscape(article.date)).append(\",\");\n            sb.append(\"\\\"summary\\\":\").append(jsonEscape(article.summary)).append(\",\");\n            sb.append(\"\\\"viewCount\\\":\").append(article.viewCount).append(\",\");\n            sb.append(\"\\\"commentCount\\\":\").append(article.commentCount).append(\",\");\n            sb.append(\"\\\"diggCount\\\":\").append(article.diggCount);\n            sb.append(\"}\");\n            if (i &lt; results.size() - 1) {\n                sb.append(\",\");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * 带重试机制获取网页文档\n     *\n     * @param url         目标URL\n     * @param maxAttempts 最大尝试次数\n     * @param timeoutMs   超时时间（毫秒）\n     * @return Jsoup文档对象，失败返回null\n     */\n    private Document fetchDocumentWithRetries(String url, int maxAttempts, int timeoutMs) {\n        String userAgent = \"Mozilla/5.0 (compatible; Bot/1.0; +https://example.com/bot)\";\n        int attempt = 0;\n        while (attempt &lt; maxAttempts) {\n            attempt++;\n            try {\n                return Jsoup.connect(url)\n                        .userAgent(userAgent)\n                        .timeout(timeoutMs)\n                        .referrer(\"https://www.google.com\")\n                        .get();\n            } catch (IOException e) {\n                log.warn(\"第{}次尝试获取 {} 失败: {}\", attempt, url, e.getMessage());\n                try {\n                    Thread.sleep(500L * attempt);\n                } catch (InterruptedException ignored) {\n                    Thread.currentThread().interrupt();\n                    break;\n                }\n            }\n        }\n        log.error(\"所有尝试均失败，无法获取 {}\", url);\n        return null;\n    }\n\n    /**\n     * 从文本中提取数字\n     *\n     * @param text 包含数字的文本，如\"阅读(123)\"\n     * @return 提取的数字字符串\n     */\n    private String extractNumber(String text) {\n        if (text == null) {\n            return \"0\";\n        }\n        text = text.replaceAll(\"[^0-9]\", \"\");\n        return text.isEmpty() ? \"0\" : text;\n    }\n\n    /**\n     * JSON字符串转义\n     *\n     * @param s 待转义的字符串\n     * @return 转义后的JSON字符串\n     */\n    private String jsonEscape(String s) {\n        if (s == null) {\n            return \"\\\"\\\"\";\n        }\n        String escaped = s.replace(\"\\\\\", \"\\\\\\\\\")\n                .replace(\"\\\"\", \"\\\\\\\"\")\n                .replace(\"\\n\", \"\\\\n\")\n                .replace(\"\\r\", \"\\\\r\");\n        return \"\\\"\" + escaped + \"\\\"\";\n    }\n\n    /**\n     * 文章信息类\n     */\n    private static class ArticleInfo {\n        String title;\n        String url;\n        String date;\n        String summary;\n        String viewCount;\n        String commentCount;\n        String diggCount;\n\n        ArticleInfo(String title, String url, String date, String summary,\n                    String viewCount, String commentCount, String diggCount) {\n            this.title = title;\n            this.url = url;\n            this.date = date;\n            this.summary = summary;\n            this.viewCount = viewCount;\n            this.commentCount = commentCount;\n            this.diggCount = diggCount;\n        }\n    }\n}\n</code></pre>\n<p><strong>核心逻辑</strong>：</p>\n<ol>\n<li>解析用户输入（支持用户名或 URL）</li>\n<li>用 Jsoup 抓取博客园页面</li>\n<li>用 CSS 选择器提取文章信息</li>\n<li>返回 JSON 格式的结果</li>\n</ol>\n<h3 id=\"步骤-3把工具绑定到-ai-service\">步骤 3：把工具绑定到 AI Service</h3>\n<pre><code class=\"language-java\">public AiCodeHelperService aiCodeHelperService() {\n    ChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(10);\n\n    return AiServices.builder(AiCodeHelperService.class)\n            .chatModel(qwenChatModel)\n            .chatMemory(chatMemory)\n            .contentRetriever(contentRetriever)\n            .tools(new CnblogsArticleTool())  // ← 绑定工具\n            .build();\n}\n</code></pre>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134201705-1158921879.png\" /></p>\n<h3 id=\"步骤-4测试一下\">步骤 4：测试一下</h3>\n<p>写个单元测试：</p>\n<pre><code class=\"language-java\">@Test\nvoid chatWithTools() {\n    String result = aiCodeHelperService.chat(\n        \"帮我查下博客园用户 BNTang 的最新文章\"\n    );\n    System.out.println(result);\n}\n</code></pre>\n<p><strong>关键来了</strong>，在工具方法里打断点，Debug 运行：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134527464-344030566.png\" /></p>\n<p><strong>你会看到断点真的停下来了！</strong></p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134605221-2143614017.png\" /></p>\n<p>这说明 <strong>AI 真的调用了我们的工具</strong>！</p>\n<p>工具把数据返回给 AI 后，AI 会整理成自然语言：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134407815-1435969741.png\" /></p>\n<p>在 Debug 模式下，你还能看到 AI Service 加载了工具：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102134818678-1880921390.png\" /></p>\n<p>以及工具的完整调用链路：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102135157469-2000354683.png\" /></p>\n<p><strong>完美运行！</strong></p>\n<h2 id=\"工具定义的两种方式\">工具定义的两种方式</h2>\n<p>前面用的是声明式定义（注解），LangChain4j 也支持编程式定义：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2105804/202601/2105804-20260102135244721-1011469314.png\" /></p>\n<p><strong>简单场景用声明式，需要动态创建工具用编程式。</strong></p>\n<h2 id=\"还能做更多\">还能做更多</h2>\n<p>除了搜索，工具调用还能实现这些功能：</p>\n<ul>\n<li>读写本地文件</li>\n<li>生成 PDF 报告</li>\n<li>执行 Shell 命令</li>\n<li>生成图表</li>\n<li>调用企业内部 API</li>\n</ul>\n<p><strong>更棒的是</strong>：这些工具不一定都要自己写，可以通过 MCP（Model Context Protocol）协议直接用别人开发好的工具。</p>\n<h2 id=\"完整的调用链路\">完整的调用链路</h2>\n<p>如果想深入理解工具调用的每一步，看这个时序图就对了：</p>\n<div class=\"mermaid\">sequenceDiagram\n      autonumber\n\n      participant U2 as 🧪 Test(用户)\n      participant B1 as AiCodeHelperService\n      participant L1 as LangChain4j框架\n      participant L2 as ChatModel(LLM)\n      participant B3 as CnblogsArticleTool\n      participant T1 as Jsoup(网页抓取)\n\n      Note over U2,T1: chatWithTools() 测试流程\n\n      U2-&gt;&gt;B1: chat(\"帮我查询博客园用户 BNTang 的最新技术文章...\")\n      B1-&gt;&gt;L1: 转发请求\n      L1-&gt;&gt;L1: 加载 system-prompt.txt\n      L1-&gt;&gt;L1: 添加 ChatMemory(最近10条消息)\n      L1-&gt;&gt;L2: 发送用户消息\n\n      L2-&gt;&gt;L2: 分析意图\n      L2-&gt;&gt;L2: 识别需要调用 cnblogsSearch 工具\n\n      L2--&gt;&gt;L1: 返回工具调用请求\n      L1-&gt;&gt;B3: searchCnblogsArticles(\"BNTang\")\n\n      B3-&gt;&gt;B3: 解析输入参数\n      B3-&gt;&gt;B3: 构造URL (https://www.cnblogs.com/BNTang/)\n\n      B3-&gt;&gt;T1: fetchDocumentWithRetries(url, 3, 8000)\n      T1-&gt;&gt;T1: 发送HTTP请求\n      T1--&gt;&gt;B3: 返回HTML文档\n\n      B3-&gt;&gt;B3: 解析HTML (.day 元素)\n      B3-&gt;&gt;B3: 提取文章信息(标题、链接、日期、摘要等)\n      B3-&gt;&gt;B3: 生成JSON结果\n\n      B3--&gt;&gt;L1: 返回文章列表JSON\n      L1-&gt;&gt;L2: 发送工具结果给LLM\n\n      L2-&gt;&gt;L2: 基于工具结果生成最终回复\n      L2--&gt;&gt;L1: 返回最终答案\n      L1--&gt;&gt;B1: 返回结果\n      B1--&gt;&gt;U2: 返回 String 结果\n\n      U2-&gt;&gt;U2: System.out.println(result)\n</div><p><strong>时序图解读</strong>：</p>\n<ol>\n<li><strong>用户发起请求</strong>（步骤 1-4）：Test 调用 Service，Service 转发给 LangChain4j 框架</li>\n<li><strong>AI 分析意图</strong>（步骤 5-7）：LLM 分析用户问题，决定需要调用 <code>cnblogsSearch</code> 工具</li>\n<li><strong>工具执行</strong>（步骤 8-17）：Tool 用 Jsoup 抓取博客园页面，解析数据</li>\n<li><strong>结果返回</strong>（步骤 18-21）：工具结果返回给 LLM，LLM 生成最终答案</li>\n</ol>\n<p><strong>关键点</strong>：工具执行在应用侧（B3、T1），不在 AI 服务器（L2）。</p>\n<h2 id=\"写在最后\">写在最后</h2>\n<p>工具调用是让 AI 突破能力边界的关键技术。</p>\n<p><strong>记住三个要点</strong>：</p>\n<ol>\n<li>工具描述写清楚，AI 才能正确调用</li>\n<li>工具在应用侧执行，不在 AI 服务器</li>\n<li>声明式定义简单，编程式定义灵活</li>\n</ol>\n<p>通过 LangChain4j 的 <code>@Tool</code> 注解，只需要几行代码，就能让 AI 拥有\"超能力\"。</p>\n<hr />\n<p><strong>系列文章持续更新中，关注我不错过每一篇干货。</strong></p>\n<p><strong>这篇文章对你有用的话，点个赞、在看支持一下吧！</strong></p>\n<hr />\n<p><strong>相关文章推荐</strong>：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/XhmFIeKpJR37AqqLg46b5w\" rel=\"noopener nofollow\" target=\"_blank\">智谱 GLM-4.7 编程第一</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/8fRzTXtAJ8_IfX2OggGDsw\" rel=\"noopener nofollow\" target=\"_blank\">LangChain4j 结构化输出实战</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/KtaNzGc3wbVKPwMTVl1z4g\" rel=\"noopener nofollow\" target=\"_blank\">让 AI 不再失忆</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/pnCbt98Ob4hb8sj9WPVV3g\" rel=\"noopener nofollow\" target=\"_blank\">Claude Code 免费指南</a></li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 15:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/BNTang\">BNTang</a>&nbsp;\n阅读(<span id=\"post_view_count\">25</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "独立开发者的 2025：我为什么还在做一个“看起来很普通”的客服系统",
      "link": "https://www.cnblogs.com/sheng_chao/p/19431954",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sheng_chao/p/19431954\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 15:02\">\n    <span>独立开发者的 2025：我为什么还在做一个“看起来很普通”的客服系统</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        过去几年里，技术社区反复讨论同样几个话题：AI、出海、SaaS、独立开发者。热度在变，说法在升级，但真正把一个系统长期跑起来的人，感受往往更具体也更现实。这篇文章，算是一次不太宏大的回顾——记录我在 2025 年围绕一个客服系统所做的选择、踩过的坑，以及一些被现实反复校正过的认知。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>过去几年里，技术社区反复讨论同样几个话题：AI、出海、SaaS、独立开发者。<br />\n热度在变，说法在升级，但真正把一个系统长期跑起来的人，感受往往更具体也更现实。<br />\n2025 年对我来说，并不是一个有明显拐点的年份，没有爆发式增长，也没有戏剧性转向，只是持续做事、持续暴露问题、持续修正判断的一年。<br />\n这篇文章，算是一次不太宏大的回顾——记录我在 2025 年围绕一个客服系统所做的选择、踩过的坑，以及一些被现实反复校正过的认知。</p>\n<hr />\n<h2 id=\"一2025一个看似普通其实很残酷的一年\">一、2025：一个“看似普通、其实很残酷”的一年</h2>\n<p>如果只看技术社区的热词，2025 年似乎并不特别。<br />\nAI、出海、SaaS、独立开发者，这些词在过去几年里已经被反复讨论，甚至有些“疲劳”。</p>\n<p>但真正身处其中的人，大多能感受到一种很微妙的变化：</p>\n<p><strong>机会并没有消失，但容错率在急剧下降。</strong></p>\n<ul>\n<li>流量不再自然增长</li>\n<li>用户不再愿意“陪你一起成熟”</li>\n<li>技术红利逐步变成工程与耐力的比拼</li>\n</ul>\n<p>你依然可以做产品、写代码、发布版本，但<strong>每一次决策的代价都变得更真实、更不可逆</strong>。</p>\n<hr />\n<h3 id=\"表面平静底层在加速分化\">表面平静，底层在加速分化</h3>\n<p>从外部看，2025 年不像 2020 那样剧烈，也不像 2022 那样充满不确定性。<br />\n但从内部看，它更像是一个<strong>分水岭年份</strong>：</p>\n<ul>\n<li>大厂在收缩战线，只保留“确定性强”的方向</li>\n<li>中小团队开始意识到，靠融资和故事续命越来越难</li>\n<li>独立开发者要么更专业，要么更快放弃</li>\n</ul>\n<p><strong>“能跑起来”已经不算本事，“能活下去”才是。</strong></p>\n<hr />\n<h3 id=\"技术依然重要但不再是护城河本身\">技术依然重要，但不再是护城河本身</h3>\n<p>2025 年我最大的一个感受是：</p>\n<blockquote>\n<p>技术没有贬值，但“只靠技术”的路径，正在快速变窄。</p>\n</blockquote>\n<p>框架在变，模型在升级，工具链越来越完善。<br />\n一个功能，从想法到落地，前所未有地快。</p>\n<p>但这也意味着：</p>\n<ul>\n<li>同质化速度极快</li>\n<li>抄一个“能用的版本”几乎没有门槛</li>\n<li>真正拉开差距的，是长期维护、稳定性、细节和取舍</li>\n</ul>\n<p>很多项目不是死于“做不出来”，<br />\n而是死于 <strong>“做到一半，发现后面的路太长”</strong>。</p>\n<hr />\n<h3 id=\"对独立开发者而言这是清醒的一年\">对独立开发者而言，这是“清醒”的一年</h3>\n<p>如果说前几年还可以抱有某种浪漫幻想，<br />\n那么 2025 年更像是一年集体清醒期：</p>\n<ul>\n<li>你开始认真计算服务器、运维、支持成本</li>\n<li>你意识到每一个“免费用户”都在消耗注意力</li>\n<li>你必须直面一个问题：<strong>这东西有没有人愿意长期用、长期付费</strong></li>\n</ul>\n<p>对我来说，这一年并没有发生什么戏剧性的转折。<br />\n没有爆发式增长，也没有彻底放弃。</p>\n<p>只是逐渐意识到：<br />\n<strong>如果要继续做，就必须把它当成一件长期、甚至有点枯燥的事来对待。</strong></p>\n<hr />\n<h3 id=\"正是在这样的背景下我继续推进了-升讯威在线客服与营销系统\">正是在这样的背景下，我继续推进了 升讯威在线客服与营销系统</h3>\n<p>在 2025 年，我仍然选择把时间投入到一个看起来并不“性感”的方向——客服系统。</p>\n<p>不是因为它新，<br />\n而是因为它<strong>足够现实</strong>：</p>\n<ul>\n<li>足够考验工程能力</li>\n<li>足够暴露产品取舍</li>\n<li>也足够真实地反映“有没有人在用”</li>\n</ul>\n<p>后面的章节，我会具体聊聊这一年里踩过的坑、做过的取舍，以及一些被反复验证过的反直觉结论。</p>\n<p>但所有这些，都源于同一个前提：</p>\n<blockquote>\n<p><strong>2025 年，不再是“试试看”的年份了。</strong></p>\n</blockquote>\n<p>如果你还在做事，大概率和我一样，已经意识到了这一点。</p>\n<hr />\n<h2 id=\"二我为什么在-2025-年还要做一个客服系统\">二、我为什么在 2025 年还要做一个“客服系统”</h2>\n<p>如果只从“赛道选择”的角度看，<br />\n在 2025 年做客服系统，几乎是一个<strong>反直觉</strong>的决定。</p>\n<p>它不新、不酷、不在风口上。<br />\n也很难用一句话讲出“颠覆性”。</p>\n<p>但正因为如此，它反而成了一个非常诚实的选择。</p>\n<hr />\n<h3 id=\"客服系统是一面照妖镜\">客服系统是一面“照妖镜”</h3>\n<p>我一直觉得，客服系统是 SaaS 产品里非常特殊的一类：</p>\n<ul>\n<li>它不解决“增长”，而是暴露问题</li>\n<li>它不创造幻想，而是承接情绪</li>\n<li>它每天面对的，都是系统最真实、最糟糕的状态</li>\n</ul>\n<p>当一切都运转良好时，客服系统几乎是隐形的；<br />\n<strong>只有当别的地方出问题，它才会被频繁打开。</strong></p>\n<p>这意味着两件事：</p>\n<ol>\n<li>它对稳定性和实时性的要求极端苛刻</li>\n<li>它几乎无法靠“营销叙事”掩盖真实体验</li>\n</ol>\n<p><strong>好不好用，用几天就知道。</strong></p>\n<hr />\n<h3 id=\"红海并不等于没问题可解决\">“红海”并不等于“没问题可解决”</h3>\n<p>客服系统常被视为红海产品，但我在实际使用和调研中发现的却是另一种景象：</p>\n<ul>\n<li>功能很多，但长期使用体验割裂</li>\n<li>演示很好看，真实场景却频繁卡壳</li>\n<li>对销售友好，对工程师不友好</li>\n</ul>\n<p>尤其是对中小团队来说，常见的困境是：</p>\n<ul>\n<li>SaaS 版本限制多、定制难</li>\n<li>私有化版本部署复杂、维护成本高</li>\n<li>出了问题，很难快速定位到底是哪一层在出错</li>\n</ul>\n<p><strong>不是没有产品，而是“能安心长期用的产品”不多。</strong></p>\n<hr />\n<h3 id=\"我想验证一件事工程导向能不能做出好产品\">我想验证一件事：工程导向能不能做出好产品</h3>\n<p>在 2025 年继续做客服系统，对我来说更像一次验证，而不是押注。</p>\n<p>我想验证的不是“能不能做成一个大平台”，<br />\n而是一个更具体、也更残酷的问题：</p>\n<blockquote>\n<p>如果从一开始就以工程可控性、可维护性为核心，<br />\n能不能反过来，做出一个真正对用户友好的系统？</p>\n</blockquote>\n<p>这意味着很多不讨巧的选择：</p>\n<ul>\n<li>把时间花在日志、遥测、异常采集上</li>\n<li>花精力设计清晰、可预期的系统边界</li>\n<li>接受“功能慢一点，但稳定优先”的节奏</li>\n</ul>\n<p>这些东西在 Demo 里几乎看不出来，<br />\n但在第 100 次、第 1000 次使用时，会被反复感知。</p>\n<hr />\n<h3 id=\"升讯威在线客服与营销系统-只是这个验证过程的载体\">升讯威在线客服与营销系统 只是这个验证过程的载体</h3>\n<p>在这个过程中，我做了一个叫 <strong>升讯威在线客服与营销系统</strong> 的客服系统。</p>\n<p>但它并不是一个“先定产品、再找用户”的项目，<br />\n更像是一个<strong>长期承载思考和取舍的容器</strong>：</p>\n<ul>\n<li>哪些功能值得做，哪些应该克制</li>\n<li>哪些问题应该由系统解决，哪些必须交还给人</li>\n<li>在 SaaS 和私有化之间，边界应该如何划分</li>\n</ul>\n<p>很多决策，并不是“行业最佳实践”，<br />\n而是一次次被现实逼出来的选择。</p>\n<hr />\n<h3 id=\"为什么是-2025而不是更早或更晚\">为什么是 2025，而不是更早或更晚</h3>\n<p>如果是更早几年，我可能会更激进；<br />\n如果再晚几年，可能会更保守。</p>\n<p>2025 刚好处在一个微妙的位置：</p>\n<ul>\n<li>技术足够成熟，可以把基础问题解决好</li>\n<li>用户足够理性，不再被概念牵着走</li>\n<li>我自己，也已经不再执着于“做一个看起来很厉害的东西”</li>\n</ul>\n<p>而是更在意：</p>\n<blockquote>\n<p><strong>这个系统，在真实世界里，能不能被长期信任。</strong></p>\n</blockquote>\n<p>这就是我在 2025 年，仍然选择做一个客服系统的核心原因。</p>\n<hr />\n<h2 id=\"三2025-年我真正踩过的-5-个坑\">三、2025 年我真正踩过的 5 个坑</h2>\n<p>这一年里，我越来越清楚一件事：</p>\n<blockquote>\n<p>真正决定一个系统能不能“长期活着”的，<br />\n往往不是你最得意的那部分代码。</p>\n</blockquote>\n<p>下面这 5 个坑，都不是概念问题，而是<strong>上线之后、真实使用中反复出现</strong>的问题。</p>\n<hr />\n<h3 id=\"坑一把功能完整误当成系统可用\">坑一：把“功能完整”误当成“系统可用”</h3>\n<p>这是最早、也是最隐蔽的一个坑。</p>\n<p>在开发初期，很容易用 checklist 思维判断进度：</p>\n<ul>\n<li>会话有了</li>\n<li>转接有了</li>\n<li>访客追踪有了</li>\n<li>历史记录能查</li>\n</ul>\n<p><strong>看起来一切都齐了。</strong></p>\n<p>但真正上线后才发现，客服系统的“可用”，并不取决于有没有功能，而取决于：</p>\n<ul>\n<li>高峰期会不会卡</li>\n<li>网络抖动时会不会丢消息</li>\n<li>客服端卡死后能不能恢复</li>\n</ul>\n<p>这些问题，只有在<strong>真实用户、真实压力</strong>下才会暴露。</p>\n<p>后来我不得不承认：<br />\n<strong>客服系统不是功能型产品，而是稳定性型产品。</strong></p>\n<hr />\n<h3 id=\"坑二低估实时系统的复杂度\">坑二：低估“实时系统”的复杂度</h3>\n<p>理论上，一个客服系统就是：</p>\n<blockquote>\n<p>WebSocket + 消息转发 + 状态同步</p>\n</blockquote>\n<p>实际写起来，完全不是一回事。</p>\n<p>只要系统存在：</p>\n<ul>\n<li>多客服</li>\n<li>多会话</li>\n<li>多设备登录</li>\n<li>客服/访客随时上下线</li>\n</ul>\n<p>就必然会遇到这些问题：</p>\n<ul>\n<li>状态不同步</li>\n<li>幽灵会话</li>\n<li>已关闭的连接仍然被认为“在线”</li>\n<li>消息已发送，但对方并未真正接收</li>\n</ul>\n<p>最痛苦的是：<br />\n<strong>这些问题很难稳定复现。</strong></p>\n<p>后来我才真正理解，实时系统的核心不是“快”，<br />\n而是 <strong>状态一致性的收敛能力</strong>。</p>\n<hr />\n<h3 id=\"坑三把日志当成事后工具\">坑三：把日志当成“事后工具”</h3>\n<p>一开始，我也和很多人一样：</p>\n<ul>\n<li>出问题了，再加日志</li>\n<li>定位到了，再删一部分</li>\n</ul>\n<p>直到有一天我意识到：</p>\n<blockquote>\n<p>在客服系统里，如果你需要“复现问题”，<br />\n这个问题本身就已经很严重了。</p>\n</blockquote>\n<p>很多用户反馈的问题，本质是：</p>\n<ul>\n<li>“刚刚还能用，现在不行了”</li>\n<li>“有时候会断”</li>\n<li>“偶尔收不到消息”</li>\n</ul>\n<p>如果没有<strong>结构化、可关联的日志和遥测数据</strong>，<br />\n你根本无法判断问题发生在哪一层。</p>\n<p>从那之后，我开始把日志、异常、遥测当作<strong>系统的一部分</strong>，<br />\n而不是附加模块。</p>\n<hr />\n<h3 id=\"坑四以为-saas-和私有化只是部署方式不同\">坑四：以为 SaaS 和私有化只是“部署方式不同”</h3>\n<p>这是一个非常典型、也非常昂贵的认知错误。</p>\n<p>在早期，我下意识地认为：</p>\n<blockquote>\n<p>SaaS 跑得通，私有化就是“多打个包”。</p>\n</blockquote>\n<p>真正开始支持私有化之后才发现：</p>\n<ul>\n<li>网络环境完全不可控</li>\n<li>依赖服务可能被裁剪</li>\n<li>客户更关心“可诊断性”而不是“自动化”</li>\n</ul>\n<p>很多在 SaaS 下理所当然的假设，在私有化环境中都会失效。</p>\n<p><strong>它们不是同一个产品，只是共享了一部分代码。</strong></p>\n<hr />\n<h3 id=\"坑五忽视非功能需求的长期成本\">坑五：忽视“非功能需求”的长期成本</h3>\n<p>性能、稳定性、可观测性、安全性，<br />\n这些东西在需求评审时，往往排在最后。</p>\n<p>但在客服系统里，它们会以一种非常直接的方式反噬你：</p>\n<ul>\n<li>一次卡顿，就可能造成大量负面体验</li>\n<li>一次异常，客服就会怀疑“是不是系统问题”</li>\n<li>一次数据异常，信任成本要用很久才能修复</li>\n</ul>\n<p>我在 2025 年学到的最重要一课是：</p>\n<blockquote>\n<p><strong>非功能需求不是“以后再补”的东西，<br />\n它们决定了你以后还有没有机会补。</strong></p>\n</blockquote>\n<hr />\n<h2 id=\"四产品层面的-3-个反直觉认知\">四、产品层面的 3 个反直觉认知</h2>\n<p>在 2025 年之前，我对“做产品”这件事，多少还带着一点工程师式的理想主义。<br />\n但真正把一个系统放进长期、真实使用场景后，很多直觉其实是错的。</p>\n<p>下面这 3 个认知，都是踩坑之后才慢慢形成的。</p>\n<hr />\n<h3 id=\"认知一用户真正渴望的不是更多能力而是更少意外\">认知一：用户真正渴望的，不是“更多能力”，而是“更少意外”</h3>\n<p>在做客服系统之前，我也以为：</p>\n<blockquote>\n<p>功能多一点，总是好的。</p>\n</blockquote>\n<p>但真实情况恰恰相反。</p>\n<p>对客服来说，一个“好用”的系统，往往意味着：</p>\n<ul>\n<li>今天和昨天的行为是一致的</li>\n<li>高峰期不会突然变慢</li>\n<li>操作之后的结果是可预期的</li>\n</ul>\n<p>他们并不关心系统“还能不能再多做点事”，<br />\n他们更关心的是：</p>\n<blockquote>\n<p><strong>它会不会在关键时刻出问题。</strong></p>\n</blockquote>\n<p>很多功能一旦进入真实使用场景，就会暴露出维护成本、理解成本、误操作成本。<br />\n这些成本，不会出现在 PRD 里，但会长期存在于用户的心理负担中。</p>\n<hr />\n<h3 id=\"认知二真正能被长期使用的系统往往是没有存在感的\">认知二：真正能被长期使用的系统，往往是“没有存在感”的</h3>\n<p>这是一个很反产品直觉的结论。</p>\n<p>我们习惯于强调：</p>\n<ul>\n<li>易用性</li>\n<li>交互细节</li>\n<li>视觉反馈</li>\n</ul>\n<p>但在客服系统这种<strong>高频、长时间使用</strong>的产品里，<br />\n“存在感”本身，反而是一种负担。</p>\n<p>当系统足够稳定、足够顺滑时，用户甚至不会意识到它在“帮忙”。<br />\n它更像空气或地面——<br />\n<strong>只有消失或出问题时，才会被注意到。</strong></p>\n<p>我后来发现，很多所谓的“高级设计”，<br />\n在长期使用中都会被用户下意识地绕开。</p>\n<hr />\n<h3 id=\"认知三对中小团队来说可控性往往比自动化更重要\">认知三：对中小团队来说，“可控性”往往比“自动化”更重要</h3>\n<p>在产品设计层面，“自动化”听起来永远是正确方向。<br />\n但在真实环境中，它是有前提的。</p>\n<p>对中小团队而言：</p>\n<ul>\n<li>人少，但责任清晰</li>\n<li>出问题时，希望知道“哪里坏了”</li>\n<li>更愿意手动介入，而不是面对黑盒</li>\n</ul>\n<p>这意味着：</p>\n<ul>\n<li>清晰的状态</li>\n<li>可追溯的操作</li>\n<li>可解释的结果</li>\n</ul>\n<p>往往比“全自动”更有价值。</p>\n<p>我在 2025 年最大的转变之一，是开始主动压制某些看起来很“聪明”的设计，<br />\n转而强调：</p>\n<blockquote>\n<p><strong>系统是否让人安心。</strong></p>\n</blockquote>\n<hr />\n<h2 id=\"五2025-年我对-升讯威在线客服与营销系统-的几个关键取舍\">五、2025 年我对 升讯威在线客服与营销系统 的几个关键取舍</h2>\n<p>在前面的章节里，我提到过不少“坑”和认知转变。<br />\n但如果这些东西不能反映到具体决策中，它们就只是感悟。</p>\n<p>2025 年，对 升讯威在线客服与营销系统 来说，不是快速扩张的一年，<br />\n而是一年持续做选择、并且<strong>不断否定“看起来更诱人方案”</strong>的过程。</p>\n<p>下面这几个取舍，基本决定了它今天的形态。</p>\n<hr />\n<h3 id=\"取舍一同时提供-saas-和私有化而不是二选一\">取舍一：同时提供 SaaS 和私有化，而不是二选一</h3>\n<p>这是一个从一开始就很“反效率”的决定。</p>\n<p>从纯开发成本看，<br />\nSaaS + 私有化意味着：</p>\n<ul>\n<li>两套部署逻辑</li>\n<li>更多环境差异</li>\n<li>更高的维护复杂度</li>\n</ul>\n<p>但真实需求非常明确：</p>\n<ul>\n<li>有些团队需要“即开即用”</li>\n<li>有些团队必须“完全可控”</li>\n</ul>\n<p>我不想用一种模式去强迫所有人适应。</p>\n<p>最终的取舍是：<br />\n<strong>共享核心能力，但承认它们是两类不同用户。</strong></p>\n<p>这也直接影响了后面很多架构决策。</p>\n<hr />\n<h3 id=\"取舍二克制功能扩张把精力花在系统边界上\">取舍二：克制功能扩张，把精力花在“系统边界”上</h3>\n<p>在 2025 年，我刻意放慢了新增功能的节奏。</p>\n<p>不是因为没想法，<br />\n而是越来越清楚：</p>\n<blockquote>\n<p>客服系统真正的复杂度，不在功能数量，而在系统边界。</p>\n</blockquote>\n<p>比如：</p>\n<ul>\n<li>哪些状态是“强一致”的</li>\n<li>哪些问题必须在服务端解决</li>\n<li>哪些异常可以交给人工兜底</li>\n</ul>\n<p>这些决定，远比“加一个新功能”更影响长期体验。</p>\n<p>很多时候，我选择<strong>不做</strong>，<br />\n而不是做一个“可能有用”的功能。</p>\n<hr />\n<h3 id=\"取舍三优先工程可诊断性而不是全自动体验\">取舍三：优先工程可诊断性，而不是“全自动体验”</h3>\n<p>这是一个非常工程师导向的选择。</p>\n<p>在 升讯威在线客服与营销系统 中，我把相当一部分精力，<br />\n投入到了普通用户几乎看不到的地方：</p>\n<ul>\n<li>更清晰的日志结构</li>\n<li>更明确的错误分类</li>\n<li>更可追溯的会话和事件链路</li>\n</ul>\n<p>这意味着：</p>\n<ul>\n<li>短期内体验并不会“惊艳”</li>\n<li>但一旦出问题，更容易被定位和解释</li>\n</ul>\n<p>对我来说，这比“自动处理一切”更重要。</p>\n<hr />\n<h3 id=\"取舍四国际化不是加语言包而是提前约束设计\">取舍四：国际化不是“加语言包”，而是提前约束设计</h3>\n<p>在 2025 年，我开始认真推进国际化相关工作。</p>\n<p>但这个过程很快让我意识到：<br />\n国际化并不是后期优化，而是<strong>设计约束</strong>。</p>\n<ul>\n<li>文案长度</li>\n<li>时间与时区</li>\n<li>权限与角色命名</li>\n<li>默认行为假设</li>\n</ul>\n<p>这些一旦在早期写死，后期改动成本会非常高。</p>\n<p>所以在 升讯威在线客服与营销系统 中，<br />\n我宁愿慢一点，也要避免“只为单一市场优化”的捷径。</p>\n<hr />\n<h3 id=\"取舍五把-升讯威在线客服与营销系统-当成一个长期系统而不是可卖的功能集合\">取舍五：把 升讯威在线客服与营销系统 当成一个长期系统，而不是“可卖的功能集合”</h3>\n<p>这是所有取舍背后的底层判断。</p>\n<p>如果目标是尽快卖掉，<br />\n有很多更聪明、更激进的做法。</p>\n<p>但在 2025 年，我更关心的是：</p>\n<ul>\n<li>它能不能在真实环境中稳定跑几年</li>\n<li>它是否经得起不断有人接手、维护</li>\n<li>它会不会在某一天变成“没人敢动的系统”</li>\n</ul>\n<p>这决定了我对技术债、对重构、对节奏的态度。</p>\n<hr />\n<h2 id=\"六2026我打算继续做的-3-件小而确定的事\">六、2026：我打算继续做的 3 件“小而确定的事”</h2>\n<p>如果说 2025 年是一个不断做减法、校正方向的年份，<br />\n那对 2026 年，我反而没有太多宏大的规划。</p>\n<p>不是因为没有野心，<br />\n而是越来越清楚：</p>\n<blockquote>\n<p>在一个长期系统里，<br />\n<strong>真正重要的不是“下一步有多远”，而是“这一步能不能站稳”。</strong></p>\n</blockquote>\n<p>所以在 2026 年，我给自己定下的目标非常克制，只做三件“小而确定”的事。</p>\n<hr />\n<h3 id=\"第一件事把稳定从结果变成能力\">第一件事：把“稳定”从结果，变成能力</h3>\n<p>在 2025 年，稳定更多是一个结果导向的判断：<br />\n“最近没出什么大问题”。</p>\n<p>但到了 2026 年，我希望把它前移，变成一种<strong>系统能力</strong>：</p>\n<ul>\n<li>问题是否能被提前发现</li>\n<li>异常是否有明确归因</li>\n<li>在不同环境下，行为是否可预测</li>\n</ul>\n<p>这意味着我会继续投入在：</p>\n<ul>\n<li>更完整的可观测性</li>\n<li>更明确的系统状态模型</li>\n<li>更保守、但可验证的变更策略</li>\n</ul>\n<p>稳定不应该依赖“经验和小心”，<br />\n而应该来自<strong>结构本身</strong>。</p>\n<hr />\n<h3 id=\"第二件事把国际化真正跑一遍而不是支持一下\">第二件事：把国际化真正跑一遍，而不是“支持一下”</h3>\n<p>在 2025 年，国际化更多是设计层面的准备。<br />\n到了 2026 年，我希望让它进入真实运行状态。</p>\n<p>这包括：</p>\n<ul>\n<li>真正的非中文用户</li>\n<li>真正不同的使用习惯</li>\n<li>真正不同的部署环境</li>\n</ul>\n<p>而不是只停留在“可以切换语言”。</p>\n<p>这一步不一定会带来明显增长，<br />\n但它会非常清楚地暴露：</p>\n<blockquote>\n<p>升讯威在线客服与营销系统 的哪些设计是通用的，<br />\n哪些其实是隐含假设。</p>\n</blockquote>\n<hr />\n<h3 id=\"第三件事更明确地知道谁不适合用-升讯威在线客服与营销系统\">第三件事：更明确地知道“谁不适合用 升讯威在线客服与营销系统”</h3>\n<p>这是一个看起来有些反商业，但我认为非常必要的目标。</p>\n<p>在 2026 年，我希望能更清楚地回答一个问题：</p>\n<ul>\n<li><strong>什么样的团队，用 升讯威在线客服与营销系统 会很舒服</strong></li>\n<li><strong>什么样的团队，用它反而会痛苦</strong></li>\n</ul>\n<p>这包括：</p>\n<ul>\n<li>技术能力与期望的匹配</li>\n<li>对可控性 vs 自动化的偏好</li>\n<li>对私有化与合规的真实需求</li>\n</ul>\n<p>一个产品如果试图取悦所有人，<br />\n最终往往谁都留不住。</p>\n<hr />\n<h2 id=\"七结尾给同样在慢慢做事的人\">七、结尾：给同样在“慢慢做事”的人</h2>\n<p>写到这里，其实已经很清楚了。<br />\n这不是一篇“阶段性胜利”的复盘，也不是某种成功经验。</p>\n<p>它更像是一次记录：<br />\n在一个不再奖励冲动和幻想的阶段，<br />\n一个人如何选择继续把事情做好。</p>\n<hr />\n<p>在 2025 年，我越来越少问自己：</p>\n<ul>\n<li>这个方向是不是风口</li>\n<li>这个产品能不能快速放大</li>\n</ul>\n<p>而是反复确认一些更朴素的问题：</p>\n<ul>\n<li>它是不是在解决真实问题</li>\n<li>它有没有在变得更稳定</li>\n<li>如果明年继续做，我是否还能心安</li>\n</ul>\n<p>很多时候，继续做下去，并不是因为看到了希望，<br />\n而是因为<strong>已经看清了现实，仍然觉得值得</strong>。</p>\n<hr />\n<p>如果你也在做一个进展缓慢、反馈稀疏、很难被外人理解的项目，<br />\n那你大概能体会这种状态：</p>\n<ul>\n<li>每一步都很小</li>\n<li>每一次改动都要反复权衡</li>\n<li>很难兴奋，但也不再轻易动摇</li>\n</ul>\n<p>这并不浪漫，<br />\n但它可能是少数真正可持续的节奏。</p>\n<hr />\n<p>我不确定 升讯威在线客服与营销系统 会走到哪一步，<br />\n也不打算在这里承诺什么结果。</p>\n<p>我能确定的只有一件事：</p>\n<blockquote>\n<p><strong>它至少是按照我能长期负责的方式，被认真对待的。</strong></p>\n</blockquote>\n<p>如果你刚好也在寻找一个<br />\n可控、工程友好、愿意陪你走很久的客服系统，<br />\n你大概能理解我为什么会把它做成现在这个样子。</p>\n<p>项目叫 <strong>升讯威在线客服与营销系统</strong>。</p>\n<p>如果没有，也没关系。<br />\n能在这个阶段，继续慢慢把事做好，本身就已经很难得了。</p>\n<hr />\n<h2 id=\"独立者的产品成果\">独立者的产品成果</h2>\n<blockquote>\n<p><a href=\"https://kf.shengxunwei.com\" rel=\"noopener nofollow\" target=\"_blank\">https://kf.shengxunwei.com</a></p>\n</blockquote>\n<p><strong>可全天候 7 × 24 小时挂机运行，网络中断，拔掉网线，手机飞行模式，不掉线不丢消息，欢迎实测。</strong></p>\n<h3 id=\"访客端轻量直观秒级响应的沟通入口\">访客端：轻量直观、秒级响应的沟通入口</h3>\n<p>访客端是客户接触企业的第一窗口，我们精心打磨每一处交互细节，确保用户无需任何学习成本即可发起对话。无论是嵌入式聊天窗口、悬浮按钮，还是移动端自适应支持，都实现了真正的“即点即聊”。系统支持智能欢迎语、来源识别、设备类型判断，可自动记录访客路径并呈现于客服端，帮助企业更好地理解用户意图。在性能方面，访客端采用异步加载与自动重连机制，即使网络波动也能保障消息顺畅送达，真正做到——轻量不失稳定，简单不失智能。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110426304-100322970.png\" /></p>\n<h3 id=\"客服端软件为高效率沟通而生\">客服端软件：为高效率沟通而生</h3>\n<p>客服端是客服人员的作战平台，我们构建了一个专注、高效、响应迅速的桌面级体验。系统采用多标签会话设计，让客服可同时处理多组对话；访客轨迹、历史会话、地理位置、设备信息、来源渠道等关键信息一目了然，协助客服快速做出判断。内置快捷回复、常用文件、表情支持和智能推荐功能，大幅降低重复劳动成本。同时，系统还支持智能分配、会话转接、转人工、自定义状态等多种机制，保障团队协作流畅，让客服不仅能应对高峰，更能稳定交付满意度。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110431346-1228494411.png\" /></p>\n<h3 id=\"web-管理后台\">Web 管理后台：</h3>\n<p>Web 管理后台是企业对客服系统的“驾驶舱”，从接入配置、坐席管理，到数据统计、权限控制，一切尽在掌握。你可以灵活设置接待策略、工作时间、转接规则，支持按部门/标签/渠道精细分配访客，满足复杂业务场景。系统还内置访问监控、聊天记录检索、客服绩效统计、错失会话提醒等运营级功能，助力管理者洞察服务瓶颈，持续优化资源配置。支持私有化部署、分权限管理、日志记录与数据导出，为追求安全性与高可控性的企业，提供真正“掌握在自己手里的客服系统”。</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/78019/202506/78019-20250601110403917-63642615.png\" /></p>\n<h2 id=\"希望能够打造-开放开源共享努力打造一款优秀的社区开源产品\">希望能够打造： 开放、开源、共享。努力打造一款优秀的社区开源产品。</h2>\n<p>钟意的话请给个赞支持一下吧，谢谢~</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 15:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sheng_chao\">升讯威在线客服系统</a>&nbsp;\n阅读(<span id=\"post_view_count\">65</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2025年终总结——在奔跑中前行",
      "link": "https://www.cnblogs.com/lucky_hu/p/19430418",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lucky_hu/p/19430418\" id=\"cb_post_title_url\" title=\"发布于 2026-01-01 17:27\">\n    <span>2025年终总结——在奔跑中前行</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"导航\">导航</h3>\n<ul>\n<li>前言</li>\n<li>职场人的核心竞争力是什么</li>\n<li>拥抱AI，拥抱大模型</li>\n<li>尝试自媒体</li>\n<li>读毛选</li>\n<li>写过的文章</li>\n<li>结语</li>\n<li>参考</li>\n</ul>\n<br />\n<section>\n    <a href=\"https://img.zhikestreet.com/2026-01-01_165557_428.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/2026-01-01_165557_428.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<h3 id=\"前言\">前言</h3>\n<blockquote>\n<p>不是先学好了再干，而是干起来再学习，干就是学习。——《毛选》</p>\n</blockquote>\n<p>2025年，对于笔者而言，是极不平凡的一年。</p>\n<p>这一年，有快乐、有焦虑、有遗憾、有成长。</p>\n<p><strong>忙碌了一整年，回顾了这一年的经历，笔者对主要工作做了梳理和总结，同时要有一些自己的感悟,或许能与您产生共鸣。</strong></p>\n<h3 id=\"职场人的核心竞争力是什么\">职场人的核心竞争力是什么</h3>\n<blockquote>\n<p>对大部分企业而言，增长才是的核心竞争力,技术不是。</p>\n</blockquote>\n<p>在很多年的技术职业生涯中，笔者曾坚定地认为把产品做好，技术方案做好，兢兢业业，持续迭代，就一定能赢得公司的认可。(请参考<a href=\"https://www.52interview.com/solutions/31\" rel=\"noopener nofollow\" target=\"_blank\">《技术更迭，一往无前》</a>)</p>\n<p>然而,随着工作年限的增长,发现很多企业并不这么认为。他们更看重的是业绩的增长,技术只是实现增长的手段之一。</p>\n<p><strong>结论：让业绩增长才是职场人的核心竞争力。</strong></p>\n<h3 id=\"拥抱ai拥抱大模型\">拥抱AI，拥抱大模型</h3>\n<blockquote>\n<p>一定不能让自己被AI列车甩下，无论是玩还是工作，一定要经常使用它们。</p>\n</blockquote>\n<p>2025年的年初，deepseek-r1的强势发布，让AI大模型在业界引起了轩然大波，各个行业开始纷纷拥抱AI大模型。</p>\n<p>2025年的年末，Manus被Meta收购，在科技界十分轰动。</p>\n<p>过去，我们认为AI只是个玩具，离自己很远。</p>\n<p>而现在，它已经能够做具体的工作了。</p>\n<h3 id=\"尝试自媒体\">尝试自媒体</h3>\n<blockquote>\n<p>转型，不一定非的转行。</p>\n</blockquote>\n<p>2025年的国庆节后，笔者开始做视频号。</p>\n<p>主要基于两点考虑：</p>\n<ul>\n<li>希望能够突破自我，拓宽自己的视野。</li>\n<li>培养兴趣、爱好，丰富自己的生活。</li>\n</ul>\n<p>干技术工作十几年了，如果只是沉浸在技术领域,那未免有些枯燥。<br />\n何况，生活不止是工作，还有诗和远方。</p>\n<br />\n<section>\n    <a href=\"https://img.zhikestreet.com/2026-01-01_160015_444-min.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/2026-01-01_160015_444-min.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<br />\n<section>\n    <a href=\"https://img.zhikestreet.com/2026-01-01_160113_397.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/2026-01-01_160113_397.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<p>做视频很花心思，也很有挑战性，也没啥收益。<br />\n每次期待有粉丝关注，也算是一种成就感。</p>\n<h3 id=\"读毛选\">读毛选</h3>\n<blockquote>\n<p>内心强大才是真正的强大。</p>\n</blockquote>\n<p>2025年，职场遭遇困境，几乎快要到了面临抉择的时候，笔者开始阅读《毛选》。<br />\n就这样，深一脚，浅一脚挺了过来。</p>\n<p>不管是企业还是个人，都有遇到困难的时候。</p>\n<p>有时候，逃避问题很容易，直面问题需要莫大的勇气。</p>\n<p>\"贵人成全你，小人成就你。\"，经历过风雨的人，深有感受。</p>\n<section>\n    <a href=\"https://img.zhikestreet.com/20260101162415_666_2-min.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/20260101162415_666_2-min.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<section>\n    <a href=\"https://img.zhikestreet.com/1767255242289-min.jpg?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/1767255242289-min.jpg?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<h3 id=\"写过的文章\">写过的文章</h3>\n<blockquote>\n<p>经验创造价值，分享成就未来。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.cnblogs.com/lucky_hu/collections/29080\" target=\"_blank\">《AI工作流实战》</a></li>\n</ul>\n<br />\n<section>\n    <a href=\"https://www.52interview.com/book/100\" rel=\"noopener nofollow\"><img alt=\"\" src=\"https://img.zhikestreet.com/2026-01-01_164320_875.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n<h3 id=\"结语\">结语</h3>\n<blockquote>\n<p>我们都在奔跑,但是短暂地停下来思考,是为了更好地再出发。</p>\n</blockquote>\n<p>过去的一年，为了\"柴米油盐、三餐四季\"忙碌奔波。</p>\n<p>新的一年，希望可以多一点战略思考，发掘更多个人的潜力和强项，突破发展瓶颈，找到属于自己的赛道。</p>\n<p>以上只是笔者个人的一点点浅见,有理解不对的地方，请大家多多包含和指正。</p>\n<h3 id=\"致谢\">致谢</h3>\n<p>最后，分享一首《踏莎行·元旦》，祝您在新的一年里，一路向阳，温暖前行，万事无忧。</p>\n<blockquote>\n<p>爆竹庭前，树桃门右。香汤浴罢，五更后。高烧银烛，瑞烟喷金兽。萱堂次第了，相为寿。<br />\n改岁宜新、应时纳祐。从今诸事愿、胜如旧。人生强健，喜一年入手。休辞最后饮，酴酥酒。</p>\n</blockquote>\n<br />\n<section>\n <a href=\"https://www.52interview.com/\" rel=\"noopener nofollow\" target=\"_blank\"><img alt=\"\" src=\"https://img.zhikestreet.com/20210522-22216942.jpg\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></a>\n</section> \n<br />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-01 17:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lucky_hu\">楠木大叔</a>&nbsp;\n阅读(<span id=\"post_view_count\">142</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "实用程序：解放双手！Python 打造 PDF 手写模拟器，轻松搞定手写作业",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19430267",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19430267\" id=\"cb_post_title_url\" title=\"发布于 2026-01-01 15:59\">\n    <span>实用程序：解放双手！Python 打造 PDF 手写模拟器，轻松搞定手写作业</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文介绍了一款基于Python开发的PDF手写模拟工具，可自动将电子文本转换为逼真手写效果并填充至PDF指定区域。该工具支持中英文独立配置字体、大小、颜色等参数，通过随机扰动算法模拟真实手写的行倾斜、字符偏移等不规则特性。用户可通过可视化界面框选填写区域、实时预览效果并保存配置模板。技术实现采用PyMuPDF处理PDF核心操作，结合tkinter构建GUI界面，Pillow实现图像渲染。开源项目地址已提供，可帮助学生高效完成手写作业需求，显著提升工作效率。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>作为学生，想必大家都有过被海量手写实验报告、课程作业支配的痛苦。要花费大量时间一笔一划地抄写到纸质文档中再进行扫描成pdf提交，不仅耗时耗力，手写的字迹还可能参差不齐，影响作业美观度。</p>\n<p>为了偷懒，博主开发了一款基于python的PDF手写模拟器，它能够模拟真实手写笔迹，将电脑上的文字批量填充到 PDF 指定区域，支持中文/英文分开配置、手写扰动效果自定义、配置模版复用等功能，生成的效果高度贴近真实手写，帮你彻底告别手动抄写的烦恼。首先来个界面以及效果预览：</p>\n<p><strong>代码已经开源在Github：<a href=\"https://github.com/ChenAI-TGF/PDF_HandWrite\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/PDF_HandWrite</a><br />\n欢迎大家下载，如果觉得有用的话可以给我点个Star，万分感谢！！<br />\n如果登不上Github的话也欢迎直接私信博主要代码</strong></p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"流程思路总览\">流程思路总览</h2>\n<p>这款 PDF 手写模拟器的整体运作流程可以分为「用户操作流程」和「技术实现流程」两层，清晰易懂：</p>\n<h2 id=\"1--用户操作流程简单易上手\">1.  用户操作流程（简单易上手）</h2>\n<ol>\n<li>\n<p>打开目标 PDF：选择需要填写的实验报告、作业等 PDF 文件；<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>框选填写区域：在 PDF 预览界面拖动鼠标，框选出需要插入文字的区域（红色矩形标记）；<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>配置手写参数：分别在中文、英文/数字选项卡中调整字体、大小、颜色、扰动效果等参数；<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>输入并预览文字：在右侧文本框输入需要填写的内容，开启「实时预览」查看手写效果；<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>不满意可实时调整参数<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>确认并保存：效果满意后确认应用笔迹，支持撤销、擦除错误内容，也可保存当前配置为模版，最后导出填写完成的 PDF。</p>\n</li>\n</ol>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"2--技术实现流程分层协作\">2.  技术实现流程（分层协作）</h3>\n<ol>\n<li>UI 交互层：基于 tkinter 搭建可视化界面，提供按钮、选项卡、文本框等交互组件，接收用户操作；</li>\n<li>参数配置层：管理中文/英文手写参数，支持配置保存（JSON）与加载，实现模版复用；</li>\n<li>PDF 操作层：基于 PyMuPDF 实现 PDF 的读取、页面渲染、文字插入、擦除、保存等核心操作；</li>\n<li>手写渲染层：核心逻辑层，实现文字排版、语言区分、手写扰动效果生成，最终将模拟手写文字插入 PDF。</li>\n</ol>\n<pre><code class=\"language-bash\">┌─────────────────────┐\n│  UI交互层（tkinter） │  # 可视化交互，接收操作\n└─────────────┬───────┘\n              ▼\n┌─────────────────────┐\n│  参数配置层（JSON）  │  # 参数管理，模版复用\n└─────────────┬───────┘\n              ▼\n┌─────────────────────┐\n│ PDF操作层（PyMuPDF） │  # PDF核心操作（读写/保存等）\n└─────────────┬───────┘\n              ▼\n┌─────────────────────┐\n│  手写渲染层（核心）  │  # 手写效果生成，文字插入\n└─────────────────────┘\n</code></pre>\n<h1 id=\"涉及的具体技术\">涉及的具体技术</h1>\n<p>这款工具基于 Python 生态的常用库开发，技术栈轻量化且实用性强，核心涉及以下技术：</p>\n<ol>\n<li><strong>tkinter</strong>：Python 内置 GUI 库，无需额外安装，负责搭建整个应用的可视化界面，实现按钮点击、参数调整、文本输入、PDF 预览等交互功能；</li>\n<li><strong>PyMuPDF（fitz）</strong>：核心 PDF 处理库，提供高效的 PDF 读取、写入、页面渲染、文字插入、红act标注（擦除功能）等接口，是实现 PDF 编辑的核心依赖；</li>\n<li><strong>Pillow（PIL）</strong>：图像处理库，将 PyMuPDF 渲染出的 PDF 页面像素数据，转换成 tkinter 画布可显示的图像格式，实现 PDF 页面的可视化预览；</li>\n<li><strong>JSON</strong>：轻量级数据格式，用于保存用户配置的手写参数模版（字体、大小、扰动值等），方便后续直接复用，无需重复调整；</li>\n<li><strong>Python 随机数与数学计算</strong>：实现手写效果的「不规则扰动」，模拟真实手写的位置偏移、大小波动、行倾斜等特性；</li>\n<li><strong>TTF 字体支持</strong>：读取自定义 TrueType 字体文件，支持切换不同手写风格字体，适配不同用户的手写习惯。</li>\n</ol>\n<h1 id=\"最终效果演示\">最终效果演示</h1>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"代码原理简单讲解手写字体生成--扰动效果\">代码原理简单讲解（手写字体生成 + 扰动效果）</h1>\n<p>我们重点讲解核心功能 —— 手写字体生成与扰动效果的实现，忽略 UI 搭建等辅助代码，聚焦核心逻辑：</p>\n<h2 id=\"一-手写字体生成文字插入-pdf-核心\">一、 手写字体生成（文字插入 PDF 核心）</h2>\n<p>这部分的核心是将文字按规则排版后，插入到 PDF 指定区域，关键步骤如下：</p>\n<ol>\n<li>\n<p><strong>文字与区域预处理</strong><br />\n首先获取文本框中的输入文字，按换行符 <code>\\n</code> 分割成多行，同时将用户框选的预览区域坐标（带缩放比例）转换为 PDF 实际坐标（除以缩放系数 <code>self.zoom</code>），得到真实的填写范围 <code>(x1, y1, x2, y2)</code>。</p>\n<pre><code class=\"language-python\"># 读取输入文字并分割行\ntext = self.text_editor.get(\"1.0\", tk.END).strip(\"\\n\")\nlines = text.split('\\n')\n# 转换为 PDF 实际坐标（去除预览缩放影响）\nx1, y1 = min(self.start_x, self.end_x)/self.zoom, min(self.start_y, self.end_y)/self.zoom\nx2, y2 = max(self.start_x, self.end_x)/self.zoom, max(self.start_y, self.end_y)/self.zoom\n</code></pre>\n</li>\n<li>\n<p><strong>语言区分与参数匹配</strong><br />\n通过 <code>is_chinese</code> 函数判断单个字符是中文还是英文/数字，分别匹配对应的配置参数（中文/英文独立的字体、大小、字距等），确保不同语言的手写效果适配合理。</p>\n<pre><code class=\"language-python\"># 判断是否为中文（含中文标点）\ndef is_chinese(self, char):\n    if '\\u4e00' &lt;= char &lt;= '\\u9fff': return True\n    if char in \"。，、？！：；“”‘’（）《》【】\": return True\n    return False\n\n# 遍历字符时匹配对应语言参数\nlang = 'zh' if self.is_chinese(char) else 'en'\np = self.params[lang]  # 获取对应语言的配置参数\n</code></pre>\n</li>\n<li>\n<p><strong>PDF 文字插入核心 API</strong><br />\n使用 PyMuPDF 的 <code>page.insert_text</code> 方法实现文字插入，这是手写字体生成的关键，核心参数说明如下：</p>\n<ul>\n<li><code>fitz.Point(final_x, final_y)</code>：文字的实际插入坐标（经排版和扰动调整后）；</li>\n<li><code>char</code>：要插入的单个字符（逐字符插入实现精细排版）；</li>\n<li><code>fontsize</code>：字符的实际大小（带大小抖动）；</li>\n<li><code>fontfile</code>：TTF 手写字体文件路径，决定字体风格；</li>\n<li><code>color</code>：文字颜色（默认纯黑，支持用户自定义）；</li>\n<li><code>morph</code>：变换矩阵，实现字符旋转效果（叠加行倾斜与字符旋转抖动）。</li>\n</ul>\n</li>\n<li>\n<p><strong>行与字符排版</strong><br />\n按行遍历文字，逐字符计算插入坐标，处理空格（单独预留间距），当字符横坐标超出框选区域右侧时自动换行，同时根据「行距参数」调整下一行的纵坐标，确保文字排版规整且不超出框选范围。</p>\n</li>\n</ol>\n<h2 id=\"二-扰动效果实现模拟真实手写不规则性\">二、 扰动效果实现（模拟真实手写不规则性）</h2>\n<p>这是工具的灵魂所在，通过「行级扰动」和「字符级扰动」两层效果，彻底摆脱打印体的规整感，贴近真实手写，对应代码中的配置参数：</p>\n<ol>\n<li>\n<p><strong>行级扰动（整行不规则性）</strong><br />\n针对每一行文字，添加整体的偏移和倾斜，模拟手写时「行不直、略有偏移」的特点，对应三个参数：</p>\n<ul>\n<li>行左右平移（<code>line_jitter_x</code>）：随机生成 <code>-line_jitter_x ~ line_jitter_x</code> 范围内的偏移量 <code>line_dx</code>，使每行文字左右轻微晃动；</li>\n<li>行上下平移（<code>line_jitter_y</code>）：随机生成 <code>-line_jitter_y ~ line_jitter_y</code> 范围内的偏移量 <code>line_dy</code>，使行与行之间的间距略有差异；</li>\n<li>行整行倾斜（<code>line_tilt</code>）：随机生成倾斜角度 <code>line_angle_deg</code>，转换为弧度后，通过 <code>tilt_y_offset = (curr_x - line_start_x) * math.tan(line_angle_rad)</code> 计算每个字符的Y轴偏移，实现整行轻微倾斜。</li>\n</ul>\n<pre><code class=\"language-python\"># 行级扰动参数计算\nline_dx = random.uniform(-p_line['line_jitter_x'].get(), p_line['line_jitter_x'].get())\nline_dy = random.uniform(-p_line['line_jitter_y'].get(), p_line['line_jitter_y'].get())\nline_angle_deg = random.uniform(-p_line['line_tilt'].get(), p_line['line_tilt'].get())\nline_angle_rad = math.radians(line_angle_deg)\n</code></pre>\n</li>\n<li>\n<p><strong>字符级扰动（单个字符不规则性）</strong><br />\n针对每个字符，添加位置、大小、旋转的细微差异，模拟手写时「每个字大小不一、略有晃动」的特点，对应三个参数：</p>\n<ul>\n<li>字位置抖动（<code>jitter_pos</code>）：随机生成 <code>(-jitter_pos ~ jitter_pos)</code> 的X、Y偏移量，使字符脱离严格的水平对齐；</li>\n<li>字大小抖动（<code>jitter_size</code>）：在基础字体大小上，随机增减 <code>(-jitter_size ~ jitter_size)</code> 的数值，生成 <code>char_jitter_fs</code>，使字符大小略有差异；</li>\n<li>字旋转抖动（<code>jitter_rot</code>）：随机生成 <code>(-jitter_rot ~ jitter_rot)</code> 的旋转角度，叠加行倾斜角度后，通过 <code>morph</code> 参数实现字符轻微旋转。</li>\n</ul>\n<pre><code class=\"language-python\"># 字符级扰动参数计算\nchar_jitter_x = random.uniform(-p['jitter_pos'].get(), p['jitter_pos'].get())\nchar_jitter_y = random.uniform(-p['jitter_pos'].get(), p['jitter_pos'].get())\nchar_jitter_rot = random.uniform(-p['jitter_rot'].get(), p['jitter_rot'].get())\nchar_jitter_fs = f_size + random.uniform(-p['jitter_size'].get(), p['jitter_size'].get())\n</code></pre>\n</li>\n<li>\n<p><strong>随机数控制（预览稳定 + 实际随机）</strong><br />\n为了保证实时预览时效果稳定可调整，设置随机数种子 <code>random.seed(42)</code> 固定扰动效果；实际应用笔迹时，不设置种子 <code>random.seed()</code>，生成随机的扰动效果，让每次生成的手写风格略有差异，更贴近真实场景。</p>\n<pre><code class=\"language-python\">if is_preview: random.seed(42)  # 预览模式：固定随机数，效果稳定\nelse: random.seed()  # 实际生成：随机种子，效果更真实\n</code></pre>\n</li>\n</ol>\n<h1 id=\"总结\">总结</h1>\n<p>这款 PDF 手写模拟器完美解决了手写作业、实验报告的痛点，兼具「实用性」和「灵活性」：</p>\n<ol>\n<li><strong>实用性拉满</strong>：无需手动抄写，一键生成手写风格 PDF，节省大量时间和精力，生成效果高度贴近真实手写；</li>\n<li><strong>自定义性强</strong>：中文/英文独立配置，支持字体、颜色、大小、字距行距调整，多层扰动参数可精细调控手写风格；</li>\n<li><strong>操作便捷</strong>：可视化界面友好，支持实时预览、撤销、擦除、模版复用，零基础用户也能快速上手；</li>\n<li><strong>技术轻量化</strong>：基于 Python 常用库开发，无需复杂环境配置，代码可灵活修改扩展。</li>\n</ol>\n<p>当然，这款工具还有优化空间，比如支持连笔效果、笔迹粗细变化、批量处理多个 PDF 等。如果大家有类似需求，可以基于这份代码进行二次开发，适配自己的使用场景。希望这款工具能帮大家解放双手，把更多时间投入到核心学习和研究中！</p>\n<p><strong>代码已经开源在Github：<a href=\"https://github.com/ChenAI-TGF/PDF_HandWrite\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ChenAI-TGF/PDF_HandWrite</a><br />\n欢迎大家下载，如果觉得有用的话可以给我点个Star，万分感谢！！<br />\n如果登不上Github的话也欢迎直接私信博主要代码</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-01 15:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\n阅读(<span id=\"post_view_count\">109</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Perigon.CLI 10.0 重磅发布【AspNetCore开发模板和辅助工具】",
      "link": "https://www.cnblogs.com/msdeveloper/p/19430150/perigon-10-announce",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/msdeveloper/p/19430150/perigon-10-announce\" id=\"cb_post_title_url\" title=\"发布于 2026-01-01 15:18\">\n    <span>Perigon.CLI 10.0 重磅发布【AspNetCore开发模板和辅助工具】</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"-perigoncli-100-重磅发布\">🎉 Perigon.CLI 10.0 重磅发布</h1>\n<p><img alt=\"perigon_logo320\" src=\"https://img2024.cnblogs.com/blog/1074783/202601/1074783-20260101151334306-54452182.png\" /></p>\n<p>我们很高兴地宣布，Perigon.CLI 10.0 现已正式发布！此次更新带来了众多令人兴奋的新功能和改进，旨在提升开发者的生产力和开发体验。</p>\n<p>简而言之，Perigon是围绕<code>Aspire/AspNetCore/EF Core</code>等相关技术栈的开发辅助工具，帮助你快速构建可维护的项目，它主要提供：</p>\n<ul>\n<li><strong>项目脚手架</strong>：通过解决方案模板(Perigon.templates)，快速创建符合最佳实践的项目结构。</li>\n<li><strong>代码生成器</strong>：提供WebUI界面，用来通过实体来生成对应的增删改查代码，以及客户端请求服务的生成，极大减少重复劳动；同时提供自定义模板功能，满足不同项目需求。</li>\n<li><strong>MCP</strong>: 提供MCP支持，以与现有IDE中的AI集成。</li>\n<li><strong>命令行工具</strong>：用来创建解决方案/启动WebUI/生成客户端请求服务等。</li>\n</ul>\n<h2 id=\"由来\">由来</h2>\n<p>最初，它只是我个人在开发前后端项目时，为了减少重复劳动而开发的简单的项目分层脚手架和代码生成工具。当时(2020年)它叫<code>GT.CLI</code>和<code>GT.Framework.Web</code>。</p>\n<p>2021年，重构了结构，并开始在团队项目中使用，模板改名为<code>ater.web.templates</code>，CLI工具也经过两次大改，分别为<code>ater.droplet.cli</code>和<code>ater.dry</code>，它加入了一些公司内项目需求的功能，如提供更多开箱即用的模块。</p>\n<blockquote>\n<p>[!TIP]<br />\n以上工具可在<code>nuget</code>中找到，但都不再维护。</p>\n</blockquote>\n<h2 id=\"-现在\">✨ 现在</h2>\n<p>2025年.NET10发布，在年初，我开始计划进行全面的重构和优化，提供一个全新的版本，完全基于.NET10，不再兼容之前的版本，经过数月的开发和测试，最终发布了<code>Perigon.CLI</code>和<code>Perigon.templates</code>，该版本主要的特点包括：</p>\n<ul>\n<li>\n<p>操作界面从<code>Angular</code>改为<code>Blazer server</code>，使用<code>fluent-ui</code>组件库，从技术到视觉上都更贴近<code>NET</code>生态。</p>\n</li>\n<li>\n<p>在项目结构上，去复杂化，更加通用。去除了以下设计</p>\n<ul>\n<li><code>仓储模式</code></li>\n<li>默认使用<code>QueryDbContext</code>和<code>CommandDbContext</code>的设计，需要多一层DataAccess来抽象。</li>\n<li>默认生成业务接口类</li>\n<li><code>[Module]</code>特性，直接使用目录结构来区分模块</li>\n<li>其他不必要的抽象和复杂设计</li>\n</ul>\n</li>\n<li>\n<p>重构项目结构，并添加了更多通用和实用的功能</p>\n<ul>\n<li>引入Aspire：解决开发环境基础设施和多服务支持问题</li>\n<li>多服务支持：结合单体和微服务，一个解决方案都搞定</li>\n<li>多租户支持：通过配置在单租户和多租户间切换</li>\n<li>多数据库支持：通过工厂模式支持多种数据库</li>\n<li>多语言支持：内置多语言支持，方便国际化</li>\n<li>MCP支持：直接在IDE中调用工具生成代码</li>\n<li>源代码生成器支持(多语言和自动注入Manager)</li>\n</ul>\n</li>\n</ul>\n<p>更为重要的是，新版本确定了一些核心设计原则：</p>\n<ul>\n<li>通用且开放：不依托于特定设计模式或架构，优先使用通用且成熟的技术栈</li>\n<li>简单易用：不引入新的设计模式或理论，降低学习成本和心智负担</li>\n<li>以开发者为中心：提高开发效率和使用体验是主要目标</li>\n</ul>\n<p>现在，你可以通过我们的📚<a href=\"https://dusi.dev/docs/Perigon.html\" rel=\"noopener nofollow\" target=\"_blank\">官方文档</a>，了解如何安装和使用<code>Perigon.CLI</code>，并开始你的高效开发之旅！</p>\n<h2 id=\"未来\">🚀未来</h2>\n<p>未来将在三个方面持续改进：</p>\n<ul>\n<li>生产力。如今我们通过IDE和代码生成器避免重复性的工作。而今年使用code agent编程已经是非常平常的事情，其能力和效果无需多言，虽然还有些局限性，但其能力还在不断提升。我们会将更多AI编程的实践经验融入到工具中，进一步提升开发效率和开发体验。</li>\n<li>性能。在保持模板框架稳定的基础上，尽可能的提升性能，完善性能方面的最佳实践(文档说明)。</li>\n<li>生态。我们将基于<code>perigon</code>构建更多的内容，如身份验证系统，AIAgent系统等，也就是在基础框架的基础上，提供更多面向特定场景的解决方案。此外，还将尝试对模块进行打包和分发，进一步提高复用性和可维护性。</li>\n</ul>\n<h3 id=\"版本计划\">版本计划</h3>\n<p>对于<code>Perigon.CLI</code>，它将跟随<code>.NET</code>的版本迭代进行更新，计划每年发布一个大版本，单数版本会同时支持上一个LTS版本，偶数版本只支持当前LTS版本。</p>\n<p>对于``Perigon.templates<code>，它从</code>1.0.0`开始，由于它影响整个项目的结构和技术选型，未来主要专注于问题修复和性能提升。新的功能特性尽可能在不改变现有结构的前提下进行添加。</p>\n<h2 id=\"️️社区参与\">🏃‍♂️‍➡️社区参与</h2>\n<p>如果你对.NET开发有兴趣，并希望参与到Perigon.CLI的建设中来，欢迎访问我们的<a href=\"https://github.com/AterDev/Perigon.CLI\" rel=\"noopener nofollow\" target=\"_blank\">GitHub仓库</a>，提交你的想法、建议或贡献代码。我们期待与你一起打造更好的开发工具！</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-01 15:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/msdeveloper\">TypingLearn</a>&nbsp;\n阅读(<span id=\"post_view_count\">119</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Ansible 学习总结",
      "link": "https://www.cnblogs.com/kqdssheng/p/19432562",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kqdssheng/p/19432562\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 17:46\">\n    <span>Ansible 学习总结</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>世事洞明皆学问，人情练达即文章。</p>\n</blockquote>\n<h2 id=\"导航\">导航</h2>\n<ul>\n<li><a href=\"#id1\" rel=\"noopener nofollow\">1 工具介绍</a>\n<ul>\n<li><a href=\"#id1.1\" rel=\"noopener nofollow\">1.1 Ansible 简介</a></li>\n<li><a href=\"#id1.2\" rel=\"noopener nofollow\">1.2 Ansible 概念</a></li>\n<li><a href=\"#id1.3\" rel=\"noopener nofollow\">1.3 工作原理</a></li>\n<li><a href=\"#id1.4\" rel=\"noopener nofollow\">1.4 作用范围</a></li>\n</ul>\n</li>\n<li><a href=\"#id2\" rel=\"noopener nofollow\">2 配套命令</a>\n<ul>\n<li><a href=\"#id2.1\" rel=\"noopener nofollow\">2.1 ansible</a></li>\n<li><a href=\"#id2.2\" rel=\"noopener nofollow\">2.2 ansible-playbook</a></li>\n<li><a href=\"#id2.3\" rel=\"noopener nofollow\">2.3 ansible-doc</a></li>\n<li><a href=\"#id2.4\" rel=\"noopener nofollow\">2.4 ansible-vault</a></li>\n<li><a href=\"#id2.5\" rel=\"noopener nofollow\">2.5 ansible-galaxy</a></li>\n<li><a href=\"#id2.6\" rel=\"noopener nofollow\">2.6 ansible-console</a></li>\n</ul>\n</li>\n<li><a href=\"#id3\" rel=\"noopener nofollow\">3 Inventory - 主机清单</a></li>\n<li><a href=\"#id4\" rel=\"noopener nofollow\">4 Playbook - 任务清单</a>\n<ul>\n<li><a href=\"#id4.1\" rel=\"noopener nofollow\">4.1 Keywords - 关键词</a></li>\n<li><a href=\"#id4.2\" rel=\"noopener nofollow\">4.2 Vars - 变量</a>\n<ul>\n<li><a href=\"#id4.2.1\" rel=\"noopener nofollow\">4.2.1 变量优先级</a></li>\n<li><a href=\"#id4.2.2\" rel=\"noopener nofollow\">4.2.2 文件变量</a></li>\n<li><a href=\"#id4.2.3\" rel=\"noopener nofollow\">4.2.3 特殊变量</a></li>\n<li><a href=\"#id4.2.4\" rel=\"noopener nofollow\">4.2.4 调用变量</a></li>\n</ul>\n</li>\n<li><a href=\"#id4.3\" rel=\"noopener nofollow\">4.3 Tasks - 任务</a>\n<ul>\n<li><a href=\"#id4.3.1\" rel=\"noopener nofollow\">4.3.1 Tasks</a></li>\n<li><a href=\"#id4.3.2\" rel=\"noopener nofollow\">4.3.2 Roles</a></li>\n<li><a href=\"#id4.3.3\" rel=\"noopener nofollow\">4.3.3 Handlers</a></li>\n</ul>\n</li>\n<li><a href=\"#id4.4\" rel=\"noopener nofollow\">4.4 其它技巧</a>\n<ul>\n<li><a href=\"#id4.4.1\" rel=\"noopener nofollow\">4.4.1 When - 判断</a></li>\n<li><a href=\"#id4.4.2\" rel=\"noopener nofollow\">4.4.2 Loop - 循环</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#id5\" rel=\"noopener nofollow\">5 常用模块</a></li>\n<li><a href=\"#id6\" rel=\"noopener nofollow\">6 常用插件</a></li>\n<li><a href=\"#id7\" rel=\"noopener nofollow\">7 杂七杂八</a></li>\n</ul>\n<hr />\n<h2 id=\"1工具介绍\"><strong><div id=\"id1\">1、工具介绍</div></strong></h2>\n<h3 id=\"11ansible-简介\"><strong><div id=\"id1.1\">1.1、Ansible 简介</div></strong></h3>\n<p><strong>Ansible</strong> 是一款开源的自动化运维工具，主要用于服务器批量管理、应用部署和任务自动化。它主要的特点有：（1）<strong>无客户端的架构</strong>，免去了安装客户端的困扰。（2）<strong>基于 YAML 的语法配置</strong>，使得 Playbook 配置很容易阅读。（3）采用了 <strong>模块化的设计</strong>，使得其灵活度较高。（4）<strong>幂等性</strong>。</p>\n<blockquote>\n<p>注：<strong>什么是幂等性？</strong> 当系统处于您的任务所描述的状态时，即使多次运行同一任务，Ansible 也不会更改任何内容。【例如：通过 lineinfile 模块去为 test 文件中以 a 开头的行的前面添加一行字串 test123，当多次执行同一任务 <code>ansible localhost -m lineinfile -a \"path=test  state=present line=test123 insertbefore='^a'\"</code> 时，会发现 test 文件并没有随着任务的重复执行而重复添加多行 test123 字串，这便是幂等性。】</p>\n</blockquote>\n<h3 id=\"12ansible-概念\"><strong><div id=\"id1.2\">1.2、Ansible 概念</div></strong></h3>\n<ul>\n<li>管理节点：运行 Ansible CLI 工具（ansible、ansible-playbook、ansible-vault 等）的机器。</li>\n<li>被管节点：用 Ansible 管理的目标设备（服务器、网络设备或任何计算机）。</li>\n<li>====</li>\n<li>清单-inventory：被管节点的 <strong>主机列表</strong>，也被叫做“主机文件”。</li>\n<li><strong>剧本-playbook</strong>：用 YAML 编写的，用来描述自动化任务（<strong>指定哪些主机运行哪些命令任务</strong>）的文件。\n<ul>\n<li><strong>剧集-play</strong>：一个剧本可以包含多个剧集，而一个剧集可以理解为：<strong>针对一组主机的一次完整执行任务的计划</strong>。【注：一个 Play 是由 <strong>关键词、变量、任务</strong> 组成，其中任务又分为以下三种。】\n<ul>\n<li><strong>任务-task</strong>：用于定义执行的命令操作，相当于执行 <strong>单条命令</strong>。</li>\n<li><strong>角色-role</strong>：多个任务集中整合在了一起，相当于执行 <strong>一个 Bash 脚本</strong>。【注：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/index_role.html\" rel=\"noopener nofollow\" target=\"_blank\">Ansible 内置角色</a>、<a href=\"https://galaxy.ansible.com/ui/standalone/roles/\" rel=\"noopener nofollow\" target=\"_blank\">第三方角色</a>】</li>\n<li><strong>处理器-handler</strong>：可触发式的任务，相当于 Bash 脚本中定义的 <strong>Bash 函数</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>====</li>\n<li>模块：一个模块相当于一条 <strong>Linux 命令</strong>。【注：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/index_module.html\" rel=\"noopener nofollow\" target=\"_blank\">Ansible 内置模块</a>】</li>\n<li>插件：用于 <strong>扩展 Ansible 的功能</strong>。默认情况下，Ansible 远程目标只支持 ssh 的连接协议，但通过连接插件，它还可以支持 winrm、netconf 协议。【注：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/all_plugins.html\" rel=\"noopener nofollow\" target=\"_blank\">Ansible 内置插件</a>】</li>\n<li>集合：<strong>Ansible 内容的分发格式</strong>，可以包含剧本、角色、模块和插件。默认情况下，我们所使用的模块、插件 都是来自 <a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/builtin/index.html#ansible-builtin\" rel=\"noopener nofollow\" target=\"_blank\">Ansible.Builtin</a> 集合。如果你想管控 windows 设备，那我们一定要使用 <a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/windows/index.html#ansible-windows\" rel=\"noopener nofollow\" target=\"_blank\">Ansible.Windows</a> 集合中的模块。【注：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/index.html\" rel=\"noopener nofollow\" target=\"_blank\">Ansible 内置集合</a>、<a href=\"https://galaxy.ansible.com/ui/collections/\" rel=\"noopener nofollow\" target=\"_blank\">第三方集合</a>】</li>\n</ul>\n<p><strong>Playbook 用法汇总示例</strong>：</p>\n<pre><code class=\"language-yaml\">#本配置中的所有内容即代表一个剧本\n\n#剧集一\n- hosts: linux\n  tasks:\n##任务1\n\t- name: install nginx\n      yum:\t\t#yum 模块\n        name: nginx\n        state: present\n##任务2\n\t- name: update nginx config\n      template:\t#template 模块\n        src: nginx.conf.j2\n        dest: /etc/nginx/nginx.conf\n        notify: restart nginx\t#调用处理器\n\n  handlers:\t\t\t\t\t\t#定义处理器\n    - name: restart nginx\n      service:\n        name: nginx\n        state: restarted\n\n#剧集二     \n- hosts: windows\n  collections:\t\t#声明集合，不声明调用集合模块需带集合名称，如 ansible.windows.win_file。\n    - ansible.windows\n  tasks:\n    - name: Remove a file, if present\n  \t  win_file:\t\t#调用 windows 集合中的模块\n    \tpath: C:\\Temp\\foo.conf\n    \tstate: absent\n\n#剧集三\n- hosts: web\n  roles:\t#角色\n    - nginx\n</code></pre>\n<h3 id=\"13工作原理\"><strong><div id=\"id1.3\">1.3、工作原理</div></strong></h3>\n<p>Ansible 管理节点（1）首先与被管节点 Agent 建立远程连接，并检查当前系统的模块脚本执行环境。（2）接着管理端将任务模块对应的模块脚本传输至 Agent 端并执行，模块脚本执行时会先进行“<strong>状态检测判断</strong>”，然后将结果以 json 格式返回。（3）最后删除 Agent 处的临时模块脚本文件并关闭连接。</p>\n<blockquote>\n<p>注：（1）<strong>状态检测判断流程</strong>：① 获取当前状态。② 与 Playbook 期望状态对比。③ 决定是否执行修改。【注：以上述修改 test 文件为例。当第二次执行任务时，发现文件中已在 a 行的前面添加了 test123，这正符合 Playbook 的期望，于是本次任务并不会做出任何修改。】（2）Ansible 中的 <strong>模块其实是用 Python/Powershell 脚本实现的，它具有和 Linux 命令相类似的功能。</strong> 因此，这也就说明了为什么 Ansible 要求被管节点需要具备 Python 或 Powershell 的执行环境。</p>\n</blockquote>\n<h3 id=\"14作用范围\"><strong><div id=\"id1.4\">1.4、作用范围</div></strong></h3>\n<p>Ansible 拥有丰富的插件和功能模块。而借助其 <strong>连接插件</strong>，理论上可对大多数设备（Linxu、Windows、网络设备）进行远程管理。但实际上，它只是对 Linux 设备支持度较好（注：大多数功能模块都只对 Linux 有效），对 Windows 和网络设备的管理效果一般。</p>\n<blockquote>\n<p>注：Ansible 对不同设备能否被管理的要求如下：</p>\n<ul>\n<li>对 Linux 设备的要求：（1）开启 SSH 服务。（2）安装 Python 2.7 或更高版本。</li>\n<li>对 Windows 设备的要求：（1）开启 WinRM 服务。（2）安装 PowerShell 3.0 或更高版本，以及至少 .NET 4.0。（3）PowerShell 脚本执行策略设置为 Restricted。</li>\n<li>对网络设备（交换机/路由器）的要求：开启 NETCONF  服务。【注：由于是新协议，因此老旧网络设备可能并不支持该功能。】</li>\n</ul>\n</blockquote>\n<h2 id=\"2配套工具\"><strong><div id=\"id2\">2、配套工具</div></strong></h2>\n<h3 id=\"21ansible\"><strong><div id=\"id2.1\">2.1、ansible</div></strong></h3>\n<p>ansible 是用于临时 <strong>执行单一命令任务</strong> 的工具，不用写 playbook 即可执行任务。</p>\n<pre><code class=\"language-bash\">#对所有主机执行 id 命令，并查看输出结果。\nansible all -i hosts -m command -a \"id\" -v\n</code></pre>\n<h3 id=\"22ansible-playbook\"><strong><div id=\"id2.2\">2.2、ansible-playbook</div></strong></h3>\n<p>ansible-playbook 是用于 <strong>执行复杂命令任务</strong> 的工具，必须依赖 playbook 文件才能运行。</p>\n<pre><code class=\"language-bash\">#执行 task.yml 任务集。\nansible-playbook -i hosts task.yml\n\ncat task.yml\n###文本内容###\n- hosts: linux\n  tasks:\n\t- name: install nginx\n      yum:\n        name: nginx\n        state: present\n######\n</code></pre>\n<h3 id=\"23ansible-doc\"><strong><div id=\"id2.3\">2.3、ansible-doc</div></strong></h3>\n<p>ansible-doc 是用于 <strong>查看模块/插件使用说明</strong> 的工具，相当于是 Ansible 的“man 手册”。</p>\n<pre><code class=\"language-bash\">#查看 ping 模块的参数介绍。\nansible-doc -s ping\n\n#查看 ping 模块的参数介绍。\nansible-doc -t module -s ping\n</code></pre>\n<h3 id=\"24ansible-vault\"><strong><div id=\"id2.4\">2.4、ansible-vault</div></strong></h3>\n<p>ansible-vault 是用于 <strong>加密 playbook 配置</strong> 的工具，防止剧本中的密码信息泄露。</p>\n<pre><code class=\"language-bash\">#加密 playbook 任务文件\nansible-vault encrypt task.yml\n\n#执行被加密的 playbook 任务文件\nansible-playbook task.yml --ask-vault-pass\n</code></pre>\n<h3 id=\"25ansible-galaxy\"><strong><div id=\"id2.5\">2.5、ansible-galaxy</div></strong></h3>\n<p>ansible-galaxy 是用于 <strong>下载管理角色/集合</strong> 的工具，相当于是 Ansible 的“任务/模块应用商店”或是类似 pip 的“包管理器”。</p>\n<p>角色/集合的官网地址：<a href=\"https://galaxy.ansible.com/ui/standalone/roles/%E3%80%81https://galaxy.ansible.com/ui/collections/%E3%80%82\" rel=\"noopener nofollow\" target=\"_blank\">https://galaxy.ansible.com/ui/standalone/roles/、https://galaxy.ansible.com/ui/collections/。</a></p>\n<pre><code class=\"language-bash\">#下载用于自动化部署 nginx 任务的角色\nansible-galaxy role install geerlingguy.nginx\n\n#角色的使用类似 task 一样，具体操作见本文 Playbook 小节。\n</code></pre>\n<h3 id=\"26ansible-console\"><strong><div id=\"id2.6\">2.6、ansible-console</div></strong></h3>\n<p>ansible-console 是用于 <strong>与 Ansible 进行命令交互</strong> 的工具，相当于是面向 Ansible 的 Shell。</p>\n<pre><code class=\"language-bash\">ansible-console\n&gt; hosts web\n&gt; ping\n&gt; shell uptime\n</code></pre>\n<h2 id=\"3inventory---主机清单\"><strong><div id=\"id3\">3、Inventory - 主机清单</div></strong></h2>\n<p>在主机清单中支持定义：<strong>主机、主机组、主机变量、主机组变量</strong>，但一般不建议在主机清单中定义变量，变量都是定义在单独的 <strong>主机/组文件</strong> 中。主机清单支持多种格式去书写，但最常用的格式是 ini 格式。以下是一个主机清单的示例：</p>\n<pre><code class=\"language-ini\"># hosts.ini\n[windows]\t# windows 组定义了5个主机\nwww.test-[01:05].com\n\n[linux]\t\t# linux 组定义了2个主机，其中一个主机自带登录变量。\n192.168.1.1 ansible_user=kali ansible_password=kali\nwww.test-06.com ansible_host=192.168.1.2\n\n[windows:vars]\t# windows 组变量\nansible_connection=winrm\nansible_user=administrator\nansible_password=password123\n\n[hosts:children]\t# 基于组创建的 hosts 组\nwindows\nlinux\n</code></pre>\n<blockquote>\n<p>注：Ansible 默认预定义了两个主机组：<strong>all</strong> 分组（所有主机）、<strong>ungrouped</strong> 分组（不在分组内的主机）。需要注意的是，这两个组都不包括 <strong>localhost</strong>（管理节点本机） 这个特殊的节点。【注：命令 <code>ansible windows --list-hosts</code> 可列出 windows 组中的所有主机。】</p>\n</blockquote>\n<h2 id=\"4playbook---任务清单\"><strong><div id=\"id4\">4、Playbook - 任务清单</div></strong></h2>\n<p>Playbook 是 Ansible 中最重要的一个概念，它定义了批量的主机任务应该如何去执行。而一个 Playbook 则是由一个或多个 Play 构成的，因此，<strong>只要了解了 Play 的构成也就了解了 Playbook</strong>。</p>\n<p>一个 Play 主要是由以下三部分构成:</p>\n<ul>\n<li><strong>Keywords</strong>：指定主机组、远程连接的方式、是否提权等全局参数。其中主机组必须被指定。【注：<a href=\"https://docs.ansible.org.cn/ansible/latest/reference_appendices/playbooks_keywords.html#id2\" rel=\"noopener nofollow\" target=\"_blank\">可用参数参考</a>】</li>\n<li><strong>Vars</strong>：定义 playbook 在运行时需要使用的变量。【非必须】</li>\n<li><strong>Tasks</strong>：指定要执行的任务。</li>\n</ul>\n<h3 id=\"41keywords---关键词\"><strong><div id=\"id4.1\">4.1、Keywords - 关键词</div></strong></h3>\n<p>Play 中的关键词有点像是 C 语言中的全局变量，在一个 Play 中，hosts 和 tasks/roles 是必不可少的，其余参数则可有可无。Play 常用关键词如下：</p>\n<ul>\n<li>hosts：指定要执行任务的主机组。</li>\n<li>connection：使用指定的协议，连接需要执行该任务的主机。默认是 ssh。</li>\n<li>port：指定连接协议对应的端口。默认是指定协议对应的默认端口。</li>\n<li>====</li>\n<li>become：开启提权功能，使用提权之后的身份执行任务。</li>\n<li>become_method：提权支持 sudo、su 这两种方法，默认是使用 sudo 进行提权。</li>\n<li>become_user：指定提权之后获得的用户身份，默认是 root 用户。</li>\n<li>collections：全局声明集合名称，这样在调用此集合的模块时不需要携带集合的前缀名称。</li>\n<li>====</li>\n<li>vars、vars_files：定义变量。【注：这些关键词指的便是下面的小节。】</li>\n<li>tasks、roles、handlers：定义任务。【注：这些关键词指的便是下面的小节。】</li>\n</ul>\n<blockquote>\n<p>注意：并不只是在 Play 中存在关键词的说法，Task、Role 中也依然存在。虽然三者之间的关键词各有差异（关键词 when 在 Play 中没有，但在 Task、Role 中是有的。），但相似的地方有很多，像如关键词 become、vars 等。</p>\n</blockquote>\n<h3 id=\"42vars---变量\"><strong><div id=\"id4.2\">4.2、Vars - 变量</div></strong></h3>\n<h4 id=\"421变量优先级\"><strong><div id=\"id4.2.1\">4.2.1、变量优先级</div></strong></h4>\n<p>Ansible 中支持自定义变量的地方有很多，以下我将按照优先级的顺序依次列出：</p>\n<ol>\n<li>命令行变量：通过命令行参数带入，优先级最高。如：<code>ansible-playbook -i hosts -v main.yml --extra-vars \"v1=a v2=b\"</code>。</li>\n<li>playbook 变量：通过关键词 vars 带入。</li>\n<li>Inventory 主机变量：通过主机 ip 带入。如：<code>1.1.1.1 v1=a v2=b</code></li>\n<li>host_vars 主机变量：不可描述。</li>\n<li>group_vars 主机组变量：不可描述。</li>\n<li>Inventory 主机组变量：不可描述。</li>\n</ol>\n<h4 id=\"422文件变量\"><strong><div id=\"id4.2.2\">4.2.2、文件变量</div></strong></h4>\n<p>在上述变量中，关于文件变量 host_vars、group_vars 的构成不太好理解，故以一个 ansible 项目示例做说明：</p>\n<p>（1）首先，按照如下项目的目录结构制作相应的文件。</p>\n<pre><code class=\"language-wiki\">nginx_install\n├── inventory\n│   ├── group_vars\n│   │   └── lin.yml\n│   ├── hosts\n│   └── host_vars\n│       └── 192.168.56.20.yml\n└── main.yml\n</code></pre>\n<p>其中，hosts 文本内容如下：</p>\n<pre><code class=\"language-ini\">[lin]\n192.168.56.20\n</code></pre>\n<p>（2）然后，以 YAML 的语法格式去编写文件中的变量。lin.yml 文本内容如下：</p>\n<pre><code class=\"language-yaml\">---\nv1: a\nv2: b\n</code></pre>\n<p>（3）最后，在工作目录 nginx_install 下执行命令 <code>ansible-playbook -i inventory -v main.yml</code> 即可。【注：参数 i 的值不仅可以是文件也可以是目录。】</p>\n<h4 id=\"423特殊变量\"><strong><div id=\"id4.2.3\">4.2.3、特殊变量</div></strong></h4>\n<h5 id=\"facts-变量\">Facts 变量</h5>\n<p>为了让 Ansible 更了解目标节点，可以让它去收集目标节点的信息，比如获取目标节点的：主机名、系统版本、IP 地址、分区挂载信息等。这些节点信息被称为 Facts，可通过命令 <code>ansible localhost -m gather_facts</code> 去查看。有了这些信息，我们便可以更灵活的管理节点了，比如当 IP 地址为 xxx 时就怎样，当系统是 CentOS 6 时怎样，等等这些。</p>\n<p><strong>这些变量中以 <code>ansible_</code> 开头的变量默认都被  Ansible 注入到了其自身维护的变量表 hostvars 中了。因此，我们可以直接去访问变量本身，而无需以访问“组变量或字典变量”的方式去访问它们。</strong></p>\n<blockquote>\n<p>注：这些变量只能通过 Playbook 去调用，使用命令 <code>ansible localhost -m debug -a \"var=ansible_facts.ansible_interfaces\"</code> 并不能够查看，应该是 ansible 在执行任务时默认并不会收集 Facts 所导致，但 ansible-playbook 默认是会收集的。</p>\n</blockquote>\n<p>变量 Facts 和 Hostvars 的值还可通过以下 Play 去查看。</p>\n<pre><code class=\"language-yaml\">- name: playbooks\n  hosts: lin\n  tasks:\n    - name: info in ansible_facts\n      debug:\n        var: ansible_facts\n    - name: info in hostvars\n      debug:\n        var: hostvars\n</code></pre>\n<h5 id=\"register-变量\">register 变量</h5>\n<p>有时候，可能需要将某一条任务执行的结果保存下来，以便在接下的任务中调用或者做些判断。这时就可以通过 register 关键字来将某一任务结果保存为一个变量。【注：这个变量的结构类似于 上面的 hostvars 变量，因此在调用的时候需要注意。】</p>\n<pre><code class=\"language-yaml\">- name: register variables\n  hosts: lin\n  tasks:\n    - name: capture output of whoami command\n      command: whoami\n      register: login\n\n    - name: get var\n      debug:\n        msg: \"login user is {{ login.stdout }}\"\n</code></pre>\n<h4 id=\"424调用变量\"><strong><div id=\"id4.2.4\">4.2.4、调用变量</div></strong></h4>\n<p>构造的变量最终都是为了使用，而变量的类型又多种多样，如：整数、字串、数组、字典 等类型，那么面对这些类型的变量该如何使用呢？以下以一个示例的两种用法去调用它们。</p>\n<p>以上面测试 register 变量的示例为例，假设输出的复杂变量 login 的值如下：</p>\n<pre><code class=\"language-wiki\">\"login\": {\n        \"changed\": true,\n        \"cmd\": [\n            \"whoami\"\n        ],\n        \"delta\": \"0:00:00.011976\",\n        \"end\": \"2025-12-31 05:27:48.401127\",\n        \"failed\": false,\n        \"msg\": \"\",\n        \"rc\": 0,\n        \"start\": \"2025-12-31 05:27:48.389151\",\n        \"stderr\": \"\",\n        \"stderr_lines\": [],\n        \"stdout\": \"kali\",\n        \"stdout_lines\": [\n            \"kali\"\n        ]\n    }\n</code></pre>\n<p>那么在 Play 中调用其中值的方法如下：</p>\n<pre><code class=\"language-yaml\">- name: register variables\n  hosts: lin\n  tasks:\n    - name: capture output of whoami command\n      command: whoami\n      register: login\n\n    - name: get var\n      debug:\n        msg: \"login user1 is {{ login.stdout_lines[0] }}\"\n\n    - name: get var\n      debug:\n        msg: \"login user2 is {{ login['stdout_lines'][0] }}\"\n</code></pre>\n<h3 id=\"43tasks---任务\"><strong><div id=\"id4.3\">4.3、Tasks - 任务</div></strong></h3>\n<p>在 Play 中用来执行任务的方式有三种，分别是：tasks（常规任务）、roles（任务组织化）、handlers（可复用任务），三者虽各有各的用法，但本质上都是一样的：执行任务。</p>\n<h4 id=\"431tasks\"><strong><div id=\"id4.3.1\">4.3.1、Tasks</div></strong></h4>\n<ul>\n<li><strong>任务列表中的各任务按次序逐个在 hosts 中指定的所有主机上执行，在所有主机上先完成第一个任务后再开始第二个。</strong></li>\n<li>在自上而下运行某 playbook 时，如果中途发生错误，则整个 playbook 会停止执行，而由于 playbook 的幂等性，playbook 可以被反复执行，所以即使发生了错误，在修复错误后，再执行一次即可。</li>\n</ul>\n<pre><code class=\"language-yaml\">- name: task test\n  hosts: linux\n  tasks:\n    - name: make sure apache is running\n      service: \n        name: httpd\n        state: started\n  \n    - name: run this command and ignore the result\n      command: /usr/bin/somecommand\n      ignore_errors: True\t\t#若命令会返回错误信息，但这个错误对后续任务的执行影响不大时，可使用此关键词忽略错误，让任务继续顺利执行。\n</code></pre>\n<h4 id=\"432roles\"><strong><div id=\"id4.3.2\">4.3.2、Roles</div></strong></h4>\n<ul>\n<li>Roles 的出现完美解决了在<strong>复杂任务下 playbook 篇幅过长、过于臃肿、缺乏灵活性、维护成本巨大</strong>等问题。</li>\n<li>Roles 的构建严重依赖目录命名规则和目录摆放，所以目录的命名和摆放非常重要。【注：但此处不会详述 Roles 的构建过程。】</li>\n<li>由于运维中的很多业务场景都是一样的，因此可以将一些业务的 Playbook 转换为 Role 格式以供其他人复用。为此，官方提供了一个可托管 Role 的平台，让 Role 角色可以像 APT 软件包一样随下随用。【注：<a href=\"https://galaxy.ansible.com/ui/standalone/roles/\" rel=\"noopener nofollow\" target=\"_blank\">官方地址</a>】</li>\n</ul>\n<p><strong>（1）Role 角色的管理</strong>：</p>\n<pre><code class=\"language-bash\">#列出已安装的 Role\nansible-galaxy role list\n\n#安装找到的 Role\nansible-galaxy role install geerlingguy.nginx\n\n#删除指定的 Role\nansible-galaxy role remove geerlingguy.nginx\n</code></pre>\n<p><strong>（2）Role 角色的应用</strong>：</p>\n<pre><code class=\"language-yaml\">- name: install nginx\n  hosts: linux\n  roles:\n    - role: geerlingguy.nginx\n      vars:\n        v1: a\n        v2: b\n</code></pre>\n<p><strong>（3）Role 角色的结构</strong>：</p>\n<pre><code class=\"language-wiki\">#ansible-galaxy init role_name\n#tree role_name/\n\nrole_name/            \\\\ 角色名称\n├── defaults           \\\\ 为当前角色设定默认变量时使用此目录，应当包含一个main.yml文件；\n│   └── main.yml        \n├── files              \\\\ 存放有copy或script等模块调用的文件\n├── handlers           \\\\ 此目录应当包含一个main.yml文件，用于定义各角色用到的各handler\n│   └── main.yml\n├── meta               \\\\ 应当包含一个main.yml，用于定义角色的特殊设定及其依赖关系；1.3及以后版本支持\n│   └── main.yml\n├── README.md\n├── tasks              \\\\ 至少包含一个名为main.yml的文件，定义了此角色的任务列表\n│   └── main.yml\n├── templates          \\\\ template模块会自动在此目录中寻找Jinja2模板文件\n├── tests\n│   ├── inventory\n│   └── test.yml\n└── vars              \\\\ 应当包含一个main.yml，用于定义此角色用到的变量\n   └── main.yml\n</code></pre>\n<h4 id=\"433handlers\"><strong><div id=\"id4.3.3\">4.3.3、Handlers</div></strong></h4>\n<ul>\n<li>Handler 通过任务关键词 notify 来监视某个 task，一旦 task 的执行结果发生变化，则触发 Handler 任务。</li>\n<li>Handler 任务并不是被 notify 后立刻执行的。默认情况下，是在 <strong>“当前 Play 的所有 tasks 执行完之后”</strong> 才执行。</li>\n<li>默认情况下，在一个 Play 中，只要有 task 执行失败，则 play 终止，即使是与 handler 关联的 task 在失败的 task 之前运行成功了，handler 也不会被执行。如果希望在这种情况下 handler 仍然能够执行，可开启 Play 关键词 <code>force_handlers: yes</code>。</li>\n</ul>\n<pre><code class=\"language-yaml\">- name: handler task test\n  hosts: all\n  force_handlers: yes\n  tasks:\n    - name: a task which always notifies its handler\n      command: /bin/true\n      notify: restart the database\n    - name: a task which fails because the package doesn't exist\n      yum:\n        name: notapkg\n        state: latest\n      \n  handlers:\n    - name: restart the database\n      service:\n        name: mariadb\n        state: restarted\n</code></pre>\n<h3 id=\"44其它技巧\"><strong><div id=\"id4.4\">4.4、其它技巧</div></strong></h3>\n<h4 id=\"441when---判断\"><strong><div id=\"id4.4.1\">4.4.1、When - 判断</div></strong></h4>\n<p>任务关键词 when 可根据某些条件的是否达成来决定 task 是否应该被执行。</p>\n<pre><code class=\"language-yaml\">- name: Install vim\n  hosts: all\n  tasks:\n    - name:Install VIM via yum\n      yum: \n        name: vim-enhanced \n        state: installed\n      when: ansible_os_family == \"RedHat\"\n#      when: some_var | float &gt; 90\n#      when: result is changed\n</code></pre>\n<blockquote>\n<p>注：When 的条件判断<strong>因为可以配合过滤器插件和测试插件使用，故使其变得很灵活也很复杂</strong>，具体可参考<a href=\"https://clay-wangzhi.com/devops/ansible/playbook-if.html\" rel=\"noopener nofollow\" target=\"_blank\">第三方手册</a>或<a href=\"https://docs.ansible.org.cn/ansible/latest/playbook_guide/playbooks_conditionals.html\" rel=\"noopener nofollow\" target=\"_blank\">官方手册</a>查看。</p>\n</blockquote>\n<h4 id=\"442loop---循环\"><strong><div id=\"id4.4.2\">4.4.2、Loop - 循环</div></strong></h4>\n<p>任务关键词 loop 可执行一些重复性的操作。</p>\n<p><strong>（1）普通循环</strong></p>\n<pre><code class=\"language-yaml\">tasks:\n  - name: postfix and httpd are running\n    service:\n      name: \"{{ item }}\"\n      state: started\n    loop:\n      - postfix\n      - httpd\n\n- name: retrieve the list of home directories\n    command: ls /home\n    register: home_dirs\n- name: add home dirs to the backup spooler\n    file: \n      path: /mnt/{{ item }}\n      src: /home/{{ item }}\n      state: link\n    loop: \"{{ home_dirs.stdout_lines }}\"\n</code></pre>\n<p><strong>（2）高级循环</strong></p>\n<pre><code class=\"language-yaml\">- name: test loop\n  hosts: test\n  tasks:\n  - name: add several users\n    user: \n      name: \"{{ item.name }}\"\n      state: present \n      groups: \"{{ item.groups }}\"\n    loop:\n      - { name: 'user1', groups: 'wheel' }\n      - { name: 'user2', groups: 'sudo' }\n</code></pre>\n<blockquote>\n<p>注：loop 循环的用法多种多样，具体可参考<a href=\"https://clay-wangzhi.com/devops/ansible/playbook-for.html\" rel=\"noopener nofollow\" target=\"_blank\">第三方手册</a>或<a href=\"https://docs.ansible.org.cn/ansible/latest/playbook_guide/playbooks_loops.html\" rel=\"noopener nofollow\" target=\"_blank\">官方手册</a>查看。</p>\n</blockquote>\n<h2 id=\"5常用模块\"><div id=\"id5\">5、常用模块</div></h2>\n<p>以下模块均来自默认集合 <a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/builtin/index.html#plugins-in-ansible-builtin\" rel=\"noopener nofollow\" target=\"_blank\">ansible.builtin（面向 linux 系统）</a>。此外，还有两个集合也值得关注，分别是：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/windows/index.html#plugins-in-ansible-windows\" rel=\"noopener nofollow\" target=\"_blank\">ansible.windows（面向 windows 系统）</a>、<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/netcommon/index.html#plugins-in-ansible-netcommon\" rel=\"noopener nofollow\" target=\"_blank\">ansible.netcommon（面向网络设备）</a>。</p>\n<ul>\n<li>\n<p>ping 模块 – 对目标节点进行连通性测试。【示例：<code>ansible localhost -m ping</code>】</p>\n</li>\n<li>\n<p>debug 模块 – Playbook 配置调试。【示例：<code>ansible localhost -m debug -e \"str=123\" -a \"var=str\"</code>】</p>\n</li>\n<li>\n<p><strong>copy 模块</strong> – 将本地文件复制到目标节点。【示例：<code>ansible localhost -m copy -a \"src=/etc/hosts dest=/tmp/hosts mode=0777\"</code>】</p>\n</li>\n<li>\n<p>file 模块 – 管理文件和文件属性。【示例：<code>ansible localhost -m file -a \"path=/tmp/hosts state=directory\"</code> - 新建目录】</p>\n</li>\n<li>\n<p><strong>lineinfile 模块</strong> – 类似 sed 的文本编辑器。【示例：<code>ansible localhost -m lineinfile -a \"path=test  state=present line=c=345 regexp='^a'\"</code> - 将 a 开头的整行替换为 c=345】</p>\n</li>\n<li>\n<p><strong>template 模块</strong> – 将模板文件输出到目标节点。【示例：<code>ansible localhost -m template -a \"src=/root/test.sh.j2 dest=/tmp/test.sh\" -e \"arg=id\"</code> - 将 test.sh.j2 文件中的 arg 变量替换之后，将文件传输到目标节点。】</p>\n<pre><code class=\"language-yaml\"># test.sh.j2 文本内容\n\n#!/bin/sh\n{{ arg }} &gt;&gt; /tmp/id.txt\n</code></pre>\n</li>\n<li>\n<p>package 模块 – 通用软件包管理器。【示例：<code>ansible localhost -m package -a \"name=hello state=present\"</code> - 安装 hello 软件包】</p>\n</li>\n<li>\n<p>service/systemd 模块 – 管理系统服务。【示例：<code>ansible localhost -m service -a \"name=apache2 state=stopped\"</code> - 关闭 apache2 服务】</p>\n</li>\n<li>\n<p>command 模块 – 在目标节点上执行命令，<strong>但该模块不支持像如 通配符、管道符 这类特殊符号</strong>。【示例：<code>ansible localhost -m command -a \"id\"</code>】</p>\n</li>\n<li>\n<p><strong>shell 模块</strong> – 在目标节点上启动一个 shell 然后在其中执行命令。【示例：<code>ansible localhost -m shell -a \"id\"</code>】</p>\n</li>\n<li>\n<p>raw 模块 – 目标节点即便不具备 python 环境，依然能够执行命令，就像是通过 ssh 连接之后执行命令一样，此时将失去 ansible 的<strong>幂等性</strong>特点。【示例：<code>ansible localhost -m raw -a \"id\"</code>】</p>\n</li>\n<li>\n<p><strong>script 模块</strong> –- 将本地脚本传输到目标节点并执行，执行之后脚本被删除。【示例：<code>ansible localhost -m script -a \"/root/test.sh --somearg\"</code>】</p>\n</li>\n</ul>\n<blockquote>\n<p>注：通过 ansible 命令使用 command、shell、raw 这三个模块执行命令时，参数不可以以 <code>ansible localhost -m shell -a \"cmd=id\"</code> 这样的方式使用，只能以 <code>ansible localhost -m shell -a \"id\"</code> 这样的方式使用。</p>\n<p>这是因为：只有这三个模块的“核心参数”不是普通 key = value，而是 _raw_params（裸参数），其余大多模块都是以键值对的方式传递参数的。</p>\n</blockquote>\n<h2 id=\"6常用插件\"><strong><div id=\"id6\">6、常用插件</div></strong></h2>\n<p><a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/builtin/index.html#filter-plugins\" rel=\"noopener nofollow\" target=\"_blank\">过滤器插件</a> 主要配合 when 对一些变量做一些<strong>类型转换</strong>，之后再进行判断。</p>\n<p><a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/builtin/index.html#filter-plugins\" rel=\"noopener nofollow\" target=\"_blank\">查找插件</a> 主要配合插件 lookup 从各种类型的文件中<strong>读取文本内容</strong>。</p>\n<p><a href=\"https://docs.ansible.org.cn/ansible/latest/collections/ansible/builtin/index.html#test-plugins\" rel=\"noopener nofollow\" target=\"_blank\">测试插件</a> 主要配合 when 对变量做一些<strong>条件的判断</strong>。</p>\n<h2 id=\"7杂七杂八\"><strong><div id=\"id7\">7、杂七杂八</div></strong></h2>\n<p>（1）学习参考集合。</p>\n<ul>\n<li>Playbook 参考手册：<a href=\"https://docs.ansible.org.cn/ansible/latest/playbook_guide/index.html\" rel=\"noopener nofollow\" target=\"_blank\">官方</a>/<a href=\"https://clay-wangzhi.com/devops/ansible/dir-handler.html\" rel=\"noopener nofollow\" target=\"_blank\">第三方</a>。</li>\n<li>Inventory 参考手册：<a href=\"https://docs.ansible.org.cn/ansible/latest/inventory_guide/index.html\" rel=\"noopener nofollow\" target=\"_blank\">官方</a>/<a href=\"https://clay-wangzhi.com/devops/ansible/inventory.html\" rel=\"noopener nofollow\" target=\"_blank\">第三方</a>。</li>\n<li>Ansible 模块列表：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/index_module.html\" rel=\"noopener nofollow\" target=\"_blank\">官方</a>。</li>\n<li>Ansible 集合列表：<a href=\"https://docs.ansible.org.cn/ansible/latest/collections/index.html\" rel=\"noopener nofollow\" target=\"_blank\">官方</a>。</li>\n<li>Ansible 角色商店：<a href=\"https://galaxy.ansible.com/ui/standalone/roles/\" rel=\"noopener nofollow\" target=\"_blank\">官方</a>。</li>\n<li>Playbook 关键词：<a href=\"https://docs.ansible.org.cn/ansible/latest/reference_appendices/playbooks_keywords.html\" rel=\"noopener nofollow\" target=\"_blank\">官方</a>。</li>\n<li>视频教程：<a href=\"https://www.bilibili.com/video/BV1qq4y1u7x2\" rel=\"noopener nofollow\" target=\"_blank\">B 站</a>。</li>\n</ul>\n<p>（2）命令技巧。</p>\n<pre><code class=\"language-bash\">#对主机清单和 playbook 进行语法检查。\nansible-playbook -i hosts --syntax-check playbook\n\n#在开始批量执行任务之前，最好先对所有的目标主机进行通性测试。\nansible all -i hosts -m ping\n\n#查看 web 组有哪些主机\nansible web --list\n\n#以 kali 用户的身份去远程目标，同时再进行 sudo 提权，并打开 5 个并发连接。\nansible lin -i hosts -u kali -k -b -K -f 5 -m command -a \"whoami\"\n</code></pre>\n<p>（3）Playbook 示例。</p>\n<pre><code class=\"language-yaml\">#本配置中的所有内容即代表一个剧本\n\n#剧集一\n- hosts: linux\n  tasks:\n##任务1\n\t- name: install nginx\n      yum:\t\t#yum 模块\n        name: nginx\n        state: present\n##任务2\n\t- name: update nginx config\n      template:\t#template 模块\n        src: nginx.conf.j2\n        dest: /etc/nginx/nginx.conf\n        notify: restart nginx\t#调用处理器\n\n  handlers:\t\t\t\t\t\t#定义处理器\n    - name: restart nginx\n      service:\n        name: nginx\n        state: restarted\n\n#剧集二     \n- hosts: windows\n  collections:\t\t#声明集合，不声明调用集合模块需带集合名称，如 ansible.windows.win_file。\n    - ansible.windows\n  tasks:\n    - name: Remove a file, if present\n  \t  win_file:\t\t#调用 windows 集合中的模块\n    \tpath: C:\\Temp\\foo.conf\n    \tstate: absent\n\n#剧集三\n- hosts: web\n  roles:\t#角色\n    - nginx\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 17:46</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kqdssheng\">扛枪的书生</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "格式塔原理：数据可视化如何引导观众的注意力",
      "link": "https://www.cnblogs.com/wang_yb/p/19431960",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19431960\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 15:05\">\n    <span>格式塔原理：数据可视化如何引导观众的注意力</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在数据分析中，我们常说：“一张好的图表胜过千言万语。”</p>\n<p>但很多时候，我们做出来的图表却是“千言万语堵在心口难开”。读者看了半天，抓不住重点。</p>\n<p>这是为什么？</p>\n<p>因为人类的视觉感知遵循一套被称为 <strong>格式塔（Gestalt）</strong> 的心理学原理。</p>\n<p>简单来说，当我们看到一组物体时，大脑会自动将它们视为一个整体或一种模式，而不是孤立的碎片。</p>\n<p>下面我们用 <code>Python</code> 的 <code>Matplotlib</code> 库，来演示 <strong>格式塔（Gestalt）</strong> 心理学中的 6 个核心原理，看看如何利用这些原理“控制”读者的注意力。</p>\n<h1 id=\"1-邻近原理距离产生关系\">1. 邻近原理：距离产生“关系”</h1>\n<p><strong>邻近原理</strong>就是距离越近，关系越亲，我们的大脑会自动把靠得近的物体归为一类。</p>\n<p>就像在一个派对上，站在一起聊天的几个人，你会下意识觉得他们是一伙的。</p>\n<pre><code class=\"language-python\"># 邻近原理\n# 创建测试数据\nnp.random.seed(42)\ndata_a = np.random.normal(5, 1.5, 30)\ndata_b = np.random.normal(10, 1.5, 30)\ndata_c = np.random.normal(15, 1.5, 30)\n\n# 不使用邻近原理\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n\n# 左侧：未应用邻近原理（所有点均匀分布）\nall_data = np.concatenate([data_a, data_b, data_c])\nx_positions = np.arange(90)\nax1.scatter(x_positions, all_data, alpha=0.7)\nax1.grid(True, alpha=0.3)\n\n# 右侧：应用邻近原理（按组聚集）\nfor i, (data, x_offset) in enumerate(zip([data_a, data_b, data_c], [0, 30, 60])):\n    x_positions = np.arange(len(data)) + x_offset\n    ax2.scatter(x_positions, data, alpha=0.7, label=f'组{i+1}')\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260102150252034-156796734.png\" /></p>\n<p><strong>设计要点</strong>：将相关的数据点或元素放在靠近的位置，可以让观众自然地理解它们属于同一类别或具有某种关联。</p>\n<h1 id=\"2-相似原理相似的性格吸引\">2. 相似原理：相似的“性格”吸引</h1>\n<p><strong>相似原理</strong>就是长得像的，就是一家人，当物体在颜色、形状或大小上相似时，大脑会将它们分为一组。</p>\n<p>比如在足球场上，穿着相同颜色球衣的人，你不需要看清他们的脸，就知道他们是队友。</p>\n<pre><code class=\"language-python\"># 相似原理\n# 创建测试数据\ncategories = [\"A\", \"B\", \"C\", \"D\", \"E\"]\nvalues1 = [12, 16, 14, 18, 15]\nvalues2 = [8, 11, 9, 12, 10]\nx_pos = np.arange(len(categories))\n\n# 相似原理示例\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n\n# 左侧：未应用相似原理（随机颜色和样式）\nbars1 = ax1.bar(x_pos - 0.2, values1, 0.4, color=colors1, edgecolor=\"black\")\nbars2 = ax1.bar(\n    x_pos + 0.2, values2, 0.4, color=colors2, edgecolor=\"black\", hatch=hatches[0]\n)\n\n# 为每组条形添加不同图案\nfor i, bar in enumerate(bars2):\n    bar.set_hatch(hatches[i % len(hatches)])\n\n# 右侧：应用相似原理（一致的颜色和样式）\nax2.bar(x_pos - 0.2, values1, 0.4, color=\"skyblue\", edgecolor=\"black\", label=\"数据集1\")\nax2.bar(\n    x_pos + 0.2, values2, 0.4, color=\"lightcoral\", edgecolor=\"black\", label=\"数据集2\"\n)\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260102150251991-767107594.png\" /></p>\n<p><strong>设计要点</strong>：使用一致的颜色、形状或样式来表示相同类型的数据，可以大大降低观众的认知负担。</p>\n<h1 id=\"3-包围原理边界创造归属感\">3. 包围原理：边界创造\"归属感\"</h1>\n<p>包围原理就是有围墙的地方就是家。如果在某些物体周围加上边界或背景色，它们就被视为一个独立的群体。</p>\n<p>这个原理甚至比 <strong>“邻近”</strong> 和 <strong>“相似”</strong> 更强大。</p>\n<p>比如，草地上散落着羊群，一旦你用栅栏圈住其中几只，大家就会认为这几只是被特别选中的。</p>\n<pre><code class=\"language-python\"># 包围原理\n# 创建测试数据\nnp.random.seed(42)\nx1 = np.random.normal(2, 0.8, 50)\ny1 = np.random.normal(3, 0.8, 50)\n\nx2 = np.random.normal(5, 0.8, 50)\ny2 = np.random.normal(5, 0.8, 50)\n\n# 包围原理示例\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n\n# 左侧：未应用包围原理\nax1.scatter(x1, y1, alpha=0.7, color=\"blue\")\nax1.scatter(x2, y2, alpha=0.7, color=\"red\")\n\n# 右侧：应用包围原理\nfrom matplotlib.patches import Ellipse\n\nax2.scatter(x1, y1, alpha=0.7, color=\"blue\", label=\"组A\")\nax2.scatter(x2, y2, alpha=0.7, color=\"red\", label=\"组B\")\n\n# 添加包围区域\nellipse1 = Ellipse((2, 3), width=4, height=3, edgecolor=\"blue\")\nellipse2 = Ellipse((5, 5), width=4, height=3, edgecolor=\"red\")\n\nax2.add_patch(ellipse1)\nax2.add_patch(ellipse2)\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260102150252070-854536119.png\" /></p>\n<p><strong>设计要点</strong>：使用边界、背景色或容器将相关的数据元素包围起来，可以明确地告诉观众这些元素属于同一组。</p>\n<h1 id=\"4-闭合原理大脑的自动补全\">4. 闭合原理：大脑的\"自动补全\"</h1>\n<p><strong>闭合原理</strong>就是大脑是天生的“补图高手”。即使图形不完整，只要有足够的提示，大脑也会自动脑补出缺失的部分。</p>\n<p>比如看到一个虚线画圆，你不会觉得那是断断续续的线段，你会直接说：“这是一个圆”。</p>\n<pre><code class=\"language-python\"># 闭合原理示例\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n\n# 创建一些不完整的数据点\nnp.random.seed(42)\nangles = np.linspace(0, 2*np.pi, 7)[:-1]  # 故意少一个点形成不闭合\nradii = np.random.uniform(3, 5, 6)\nx = radii * np.cos(angles)\ny = radii * np.sin(angles)\n\n# 左侧：不完整的形状（未利用闭合原理）\nax1.plot(x, y, 'o-', linewidth=2, markersize=8)\n\n# 右侧：闭合的形状（应用闭合原理）\n# 添加缺失的点使形状闭合\nangles_closed = np.linspace(0, 2*np.pi, 7)\nradii_closed = np.append(radii, radii[0])  # 回到起点\nx_closed = radii_closed * np.cos(angles_closed)\ny_closed = radii_closed * np.sin(angles_closed)\n\nax2.plot(x_closed, y_closed, 'o-', linewidth=2, markersize=8)\nax2.fill(x_closed, y_closed, alpha=0.3)  # 填充增强闭合感\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260102150252005-1834837851.png\" /></p>\n<p><strong>设计要点</strong>：我们不需要展示每一个细节，可以利用观众的自动补全能力来简化图表。</p>\n<p>但要<strong>注意</strong>，过于不完整的图形可能导致误解。</p>\n<h1 id=\"5-连续原理流畅的视觉路径\">5. 连续原理：流畅的\"视觉路径\"</h1>\n<p><strong>连续原理</strong>就是顺藤摸瓜。我们的视线倾向于跟随平滑、连续的路径，而不是剧烈折线或不规则的排列。</p>\n<p>比如排队时，如果队伍弯弯曲曲但每个人都看着前一个人的后脑勺，你知道这还是一条队。</p>\n<pre><code class=\"language-python\"># 连续原理示例\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n\n# 创建数据\nnp.random.seed(42)\ntime = np.arange(0, 10, 0.1)\nsignal1 = np.sin(time) + np.random.normal(0, 0.1, len(time))\nsignal2 = np.cos(time) + np.random.normal(0, 0.1, len(time))\n\n# 左侧：不连续的展示\nax1.plot(time[:50], signal1[:50], 'b-', linewidth=2, label='信号A (第一部分)')\nax1.plot(time[70:], signal1[70:], 'b--', linewidth=2, label='信号A (第二部分)')\nax1.plot(time[:40], signal2[:40], 'r-', linewidth=2, label='信号B (第一部分)')\nax1.plot(time[60:], signal2[60:], 'r--', linewidth=2, label='信号B (第二部分)')\n\n# 右侧：连续的展示\nax2.plot(time, signal1, 'b-', linewidth=2, label='信号A')\nax2.plot(time, signal2, 'r-', linewidth=2, label='信号B')\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260102150252039-1585935589.png\" /></p>\n<p><strong>设计要点</strong>：保持线条、形状或元素的连续性可以帮助观众追踪数据的变化趋势。在折线图、面积图中尤其重要。</p>\n<h1 id=\"6-连接原理看得见的关系线\">6. 连接原理：看得见的\"关系线\"</h1>\n<p><strong>连接原理</strong>就是藕断丝连。被线连接的物体，被视为强关联。这个视觉信号比颜色和距离都要强。</p>\n<p>比如，两个人站得再远，如果手里牵着一根绳子，你也会觉得他们俩在互动。</p>\n<pre><code class=\"language-python\"># 连接原理示例 - 散点图版本\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n\n# 创建散点数据：4个相关点集，每个点集有5个点\nnp.random.seed(42)\nn_points = 5\nn_groups = 4\n\n# 为每组生成相关点\ngroups = []\nfor i in range(n_groups):\n    center_x = np.random.uniform(2, 8)\n    center_y = np.random.uniform(2, 8)\n\n    # 生成围绕中心的相关点\n    x_points = center_x + np.random.normal(0, 0.8, n_points)\n    y_points = center_y + np.random.normal(0, 0.8, n_points)\n\n    # 添加一些趋势\n    trend = np.random.uniform(-1, 1)\n    y_points = y_points + trend * (x_points - center_x)\n\n    groups.append((x_points, y_points))\n\n# 左侧：未应用连接原理（独立的散点）\ncolors = [\"blue\", \"red\", \"green\", \"orange\"]\nmarkers = [\"o\", \"s\", \"^\", \"D\"]\n\nfor i, (x_points, y_points) in enumerate(groups):\n    ax1.scatter(\n        x_points,\n        y_points,\n        color=colors[i],\n        marker=markers[i],\n        alpha=0.7,\n        s=80,\n        label=f\"数据集{i+1}\",\n    )\n\n\n# 右侧：应用连接原理（连接相关散点）\nfor i, (x_points, y_points) in enumerate(groups):\n    # 首先绘制连接线\n    # 按照x值排序，使连接线更有序\n    sorted_indices = np.argsort(x_points)\n    sorted_x = x_points[sorted_indices]\n    sorted_y = y_points[sorted_indices]\n\n    ax2.plot(\n        sorted_x,\n        sorted_y,\n        color=colors[i],\n        linewidth=2,\n        alpha=0.5,\n        linestyle=\"--\",\n        label=f\"数据集{i+1}趋势线\",\n    )\n\n    # 然后绘制散点（在线上方，避免被线遮挡）\n    ax2.scatter(\n        x_points,\n        y_points,\n        color=colors[i],\n        marker=markers[i],\n        alpha=0.7,\n        s=80,\n        edgecolor=\"black\",\n        linewidth=1,\n    )\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260102150251985-1606569356.png\" /></p>\n<p><strong>设计要点</strong>：在散点图中，连接相关数据点的线可以帮助观众识别出数据的模式、趋势或分组关系。</p>\n<p>这就像在地图上连接各个城市来显示旅行路线一样，使相关的点之间建立了明确的视觉联系。</p>\n<h1 id=\"7-总结\">7. 总结</h1>\n<p>做数据可视化，不仅仅是写代码画图，更是一场 <strong>“注意力争夺战”</strong>。<br />\n通过这 6 个格式塔原理，我们不是在改变数据本身，而是在优化数据的呈现方式，让读者的脑力消耗降到最低。</p>\n<p>每次我们画图时，不妨问自己一句：</p>\n<ul>\n<li>“这些数据应该是一组吗？它们靠得够近吗？”（邻近）</li>\n<li>“重点数据突出了吗？”（包围/相似）</li>\n<li>“视线流动顺畅吗？”（连续）</li>\n</ul>\n<p>最好的可视化不是展示所有数据，而是引导观众看到最重要的信息。格式塔原理就是我们实现这一目标的强大工具。</p>\n<p>希望这篇文章能帮助你在创建数据可视化时，更加有意地引导观众的注意力。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 15:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">14</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从后端获取数据传输到前端进行显示(cpp-httplib+Vditor+Handlebars)",
      "link": "https://www.cnblogs.com/charlee44/p/19431854",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/charlee44/p/19431854\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 13:53\">\n    <span>从后端获取数据传输到前端进行显示(cpp-httplib+Vditor+Handlebars)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        通过 cpp-httplib 后端提供 Markdown 文章的 JSON API，前端使用 Vite + Handlebars + Vditor 实现动态渲染与目录交互，完成了一个简单的前后端分离博客展示系统。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"1-引言\">1. 引言</h1>\n<p>在之前的文章中，笔者实现了一个渲染 Markdown 格式文章的网页前端 Vite 项目（参看<a href=\"https://charlee44.com/post.html?id=1f8bf6fca114499fb1db7e15e9777ac7\" rel=\"noopener nofollow\" target=\"_blank\">《给 Markdown 渲染网页增加一个目录组件(Vite+Vditor+Handlebars)》</a>）,以及一个支持 Markdown格式数据的静态文件服务的后端项目（参看<a href=\"https://charlee44.com/post.html?id=ae7a9a676916493f8f73c6217273b7eb\" rel=\"noopener nofollow\" target=\"_blank\">《使用cpp-httplib发布静态文件服务》</a>）。在这里，就将前端与后端打通，通过 cpp-httplib 提供的 API 接口动态返回 Markdown 文章数据，由前端 Vite 项目利用 Handlebars 模板与 Vditor 渲染引擎完成展示与交互。</p>\n<h1 id=\"2-实现\">2. 实现</h1>\n<h2 id=\"21-后端\">2.1 后端</h2>\n<p>JSON 是 HTTP 传输中事实上的标准数据格式，尤其是在现代 Web API（特别是 RESTful API）中，因此我们将后端的接口改成返回 JSON 格式数据的接口。按照 RESTful API 风格，命名为 <code>/api/v1/post</code>，使用 HTTP 的 Get 方法。具体代码如下：</p>\n<pre><code class=\"language-cpp\">#include &lt;httplib.h&gt;\n\n#include &lt;filesystem&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;string&gt;\n\n#include \"BlogData.h\"\n\nusing namespace std;\nusing namespace nlohmann;\nnamespace fs = std::filesystem;\n\nint main() {\n  httplib::Server svr;\n\n  std::u8string docRoot =\n      u8\"D:/Work/HttpServer/public/最小二乘问题详解1：线性最小二乘\";\n\n  svr.Get(\"/api/v1/post\",\n          [&amp;](const httplib::Request&amp; req, httplib::Response&amp; res) {\n            DataTransfer::BlogData blogData;\n\n            {\n              fs::path blogMetaJsonPath = fs::path(docRoot) / \"meta.json\";\n              nlohmann::json blogMetaJson;\n              ifstream infile(blogMetaJsonPath);\n              infile &gt;&gt; blogMetaJson;\n              blogData.blogMeta = blogMetaJson;\n            }\n\n            {\n              fs::path blogContentPath =\n                  fs::path(docRoot) / u8\"最小二乘问题详解1：线性最小二乘.md\";\n              std::ifstream file(blogContentPath, std::ios::binary);\n\n              std::string content((std::istreambuf_iterator&lt;char&gt;(file)),\n                                  std::istreambuf_iterator&lt;char&gt;());\n              blogData.content = std::move(content);\n            }\n\n            // 构造响应 JSON\n            json response_data = blogData;\n\n            // 设置响应\n            res.set_header(\"Access-Control-Allow-Origin\",\n                           \"http://127.0.0.1:8000\");  // 允许跨域\n            res.set_content(response_data.dump(), \"application/json\");\n          });\n\n  std::cout &lt;&lt; \"Server listening on http://127.0.0.1:8080\\n\";\n  svr.listen(\"0.0.0.0\", 8080);\n\n  return 0;\n}\n</code></pre>\n<p>这段代码的实现非常简单，分别读取元数据 <code>meta.json</code> 和 文章内容 <code>最小二乘问题详解1：线性最小二乘.md</code> 文件，组织成 JSON 格式，设置到 HTTP 响应的内容中并且返回。其中，用到 nlohmann/json 对 结构体对象序列化和反序列化（参考<a href=\"https://charlee44.com/post.html?id=d5736f77509345b2a66a2de4a70beb31\" rel=\"noopener nofollow\" target=\"_blank\">《C++中JSON序列化和反序列化的实现》</a>）。</p>\n<p>另外需要注意的就是跨域问题。由于前端项目与后端项目是分离的，因此它们处在不同的域中，前端要请求后端的资源，就会发生跨域问题。解决办法就是在 HTTP 的响应头中设置允许跨域的键和值：</p>\n<pre><code class=\"language-cpp\">res.set_header(\"Access-Control-Allow-Origin\", \"http://127.0.0.1:8000\");  // 允许跨域\n</code></pre>\n<h2 id=\"22-前端\">2.2 前端</h2>\n<p>前端的修改就简单多了，只需要修改获取远端数据的接口就可以了：</p>\n<pre><code class=\"language-cpp\">const response = await fetch(\"http://127.0.0.1:8080/api/v1/post\");\nif (!response.ok) {\n    throw new Error(\"网络无响应\");\n}\nconst blogData = await response.json();\n//...\n</code></pre>\n<p>其实这也是前后端分离的优势，后端提供数据资源的获取，前端则负责数据的可视化。最终的效果如下所示：</p>\n<p><img alt=\"从后端访问数据到前端进行展示\" class=\"lazyload\" /></p>\n<h1 id=\"3-其他\">3. 其他</h1>\n<p>以上就是一个最简单的前后端分离 Web 项目。任何复杂功能都可以在此基础上进行扩展，只需搭配相应的架构设计，以更好地支持具体业务需求。</p>\n<p><a href=\"https://download.csdn.net/download/charlee44/92492805\" rel=\"noopener nofollow\" target=\"_blank\">实现代码</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 13:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/charlee44\">charlee44</a>&nbsp;\n阅读(<span id=\"post_view_count\">19</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "手把手搞定FastAPI静态文件：安全、上传与访问",
      "link": "https://www.cnblogs.com/ymtianyu/p/19431849",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19431849\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 13:47\">\n    <span>手把手搞定FastAPI静态文件：安全、上传与访问</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文系统讲解了FastAPI框架中静态文件的加载、存储、安全设置以及媒体文件上传等核心功能，通过具体代码示例详细说明了如何挂载静态目录、设置安全防护、处理favicon请求和实现文件上传接口，并提供了一个可直接运行的完整实战案例，帮助开发者快速掌握在FastAPI项目中高效安全地管理各类文件资源。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<p style=\"font-size: 18px; font-weight: bold; color: rgba(26, 26, 26, 1);\">你的FastAPI应用还在“裸奔”吗？超过70%的Web应用安全问题源于静态资源的不当配置！</p>\n<blockquote style=\"padding: 10px 15px; margin: 20px 0; background-color: rgba(249, 249, 249, 1); color: rgba(85, 85, 85, 1); font-style: italic;\">这篇文章将带你系统掌握FastAPI中静态文件处理的方方面面，不止是简单的“挂载”，更涵盖安全防护、性能技巧和实战坑点，包含一个可直接运行的完整示例。 <br /><br />- 📂 静态文件的加载、存储与应用场景<br />- 🛡️ 至关重要的静态文件安全设置<br />- 🎯 一行代码搞定网站favicon<br />- 🖼️ 处理图片等媒体文件的上传与访问</blockquote>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">✨ 目录一览</h2>\n<p>- 🚀 起步：为什么需要处理静态文件？<br />- 📁 FastAPI的“文件管家”：StaticFiles<br />- 🔒 给静态文件加把“锁”：安全设置详解<br />- ⭐ 小图标大学问：Favicon的处理<br />- 🎬 不止于图片：媒体文件的上传与响应<br />- 🧪 实战演练：一个完整的示例应用</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🚀 起步：为什么需要处理静态文件？</h2>\n<p>你的API很酷，但用户访问 <code>http://localhost:8000/logo.png</code> 却得到404？这是因为FastAPI默认是个纯粹的API框架，<strong style=\"color: rgba(186, 55, 42, 1);\">它不会自动提供像图片、CSS、JavaScript这样的静态文件。</strong></p>\n<p>静态文件是那些内容固定、不经常改变的文件。它们对于构建一个完整的Web应用或API文档门户至关重要。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">📁 FastAPI的“文件管家”：StaticFiles</h2>\n<p>引入<code>StaticFiles</code>，你就能轻松搭建一个文件服务器。其核心三步法：</p>\n<p>- 导入：<code>from fastapi.staticfiles import StaticFiles</code><br />- 挂载：将URL路径“挂载”到一个实际目录。<br />- 应用：使用<code>app.mount</code>方法。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI\nfrom fastapi.staticfiles import StaticFiles\n\napp = FastAPI()\n\n# 将路径 “/static” 映射到项目下的 “static” 目录\napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">理解“挂载”</strong>：它意味着所有访问<code>/static/*</code>的请求，都会由<code>StaticFiles</code>实例去<code>./static</code>目录下查找对应文件。它不是API路由，而是一个独立的子应用。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🔒 给静态文件加把“锁”：安全设置详解</h2>\n<p>开放文件访问是危险的！错误的配置可能导致敏感文件泄露（如<code>.env</code>、<code>.git</code>目录）。</p>\n<p>1. <strong style=\"color: rgba(186, 55, 42, 1);\">限制目录访问范围</strong>：永远不要将根目录“<code>/</code>”挂载到静态文件服务。务必使用一个独立的、权限明确的子目录（如<code>static</code>、<code>assets</code>）。</p>\n<p>2. <strong style=\"color: rgba(186, 55, 42, 1);\">使用“html=True”安全地提供HTML</strong>：如果你想提供单页应用（如Vue/React构建的产物），可以设置<code>html=True</code>，并让<code>index.html</code>作为目录的默认页。</p>\n<pre class=\"language-python highlighter-hljs\"><code># 安全地提供前端构建产物目录\napp.mount(\"/app\", StaticFiles(directory=\"./frontend/dist\", html=True), name=\"spa_app\")</code></pre>\n<p>注意：<code>html=True</code>只对提供前端SPA友好，它本身并不是一个安全漏洞。真正的安全在于对<code>directory</code>参数的控制。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">⭐ 小图标大学问：Favicon的处理</h2>\n<p>浏览器会自动请求<code>/favicon.ico</code>。如果你没处理，日志里就会堆满404错误，显得不专业。</p>\n<p>最简单的方法：直接把它当成一个静态文件处理。</p>\n<pre class=\"language-python highlighter-hljs\"><code># 方法：为favicon.ico单独设置一个路径路由（或将它放在static目录）\nfrom fastapi.responses import FileResponse\n\n@app.get(\"/favicon.ico\")\nasync def favicon():\n    return FileResponse(\"static/favicon.ico\")</code></pre>\n<p>这能一劳永逸地消除那个烦人的404请求。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🎬 不止于图片：媒体文件的上传与响应</h2>\n<p>静态文件是“读”，媒体文件则常涉及“写”（上传）。FastAPI处理上传非常优雅。</p>\n<p>- <strong style=\"color: rgba(186, 55, 42, 1);\">上传</strong>：使用<code>File</code>和<code>UploadFile</code>。<br />- <strong style=\"color: rgba(186, 55, 42, 1);\">存储</strong>：使用<code>shutil</code>或<code>aiofiles</code>写入特定目录（如<code>media/</code>）。<br />- <strong style=\"color: rgba(186, 55, 42, 1);\">访问</strong>：再次借助<code>StaticFiles</code>挂载<code>media/</code>目录。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import File, UploadFile\nimport shutil\nimport os\n\nUPLOAD_DIR = \"media\"\nos.makedirs(UPLOAD_DIR, exist_ok=True)\n\n@app.post(\"/upload/image/\")\nasync def upload_image(file: UploadFile = File(...)):\n    file_path = os.path.join(UPLOAD_DIR, file.filename)\n    with open(file_path, \"wb\") as buffer:\n        shutil.copyfileobj(file.file, buffer)\n    return {\"filename\": file.filename, \"url\": f\"/media/{file.filename}\"}\n\n# 挂载上传的媒体文件目录\napp.mount(\"/media\", StaticFiles(directory=\"media\"), name=\"media\")</code></pre>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🧪 实战演练：一个完整的示例应用</h2>\n<p>下面是一个整合了上述所有知识点的完整<code>main.py</code>文件，复制即可运行体验。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, File, UploadFile, Request\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import FileResponse, HTMLResponse\nimport shutil\nimport os\nfrom pathlib import Path\n\napp = FastAPI()\n\n# 1. 创建必要的目录\nstatic_dir = Path(\"static\")\nmedia_dir = Path(\"media\")\nstatic_dir.mkdir(exist_ok=True)\nmedia_dir.mkdir(exist_ok=True)\n\n# 2. 挂载静态文件目录（存放CSS，JS，预置图片）\napp.mount(\"/static\", StaticFiles(directory=static_dir), name=\"static\")\n\n# 3. 挂载媒体文件目录（存放用户上传的图片）\napp.mount(\"/media\", StaticFiles(directory=media_dir), name=\"media\")\n\n# 4. 处理favicon请求\n@app.get(\"/favicon.ico\", include_in_schema=False)\nasync def get_favicon():\n    # 假设你的favicon.ico放在static目录下\n    return FileResponse(static_dir / \"favicon.ico\")\n\n# 5. 文件上传接口\n@app.post(\"/upload/\")\nasync def create_upload_file(file: UploadFile = File(...)):\n    # 保存上传的文件到media目录\n    save_path = media_dir / file.filename\n    with save_path.open(\"wb\") as buffer:\n        shutil.copyfileobj(file.file, buffer)\n    # 返回文件的访问URL\n    return {\"url\": f\"/media/{file.filename}\"}\n\n# 6. 一个简单的前端页面，用于演示和测试上传\n@app.get(\"/\", response_class=HTMLResponse)\nasync def main():\n    return \"\"\"\n    &lt;html&gt;\n        &lt;head&gt;\n            &lt;title&gt;FastAPI静态文件演示&lt;/title&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;h2&gt;上传图片测试&lt;/h2&gt;\n            &lt;form action=\"/upload/\" enctype=\"multipart/form-data\" method=\"post\"&gt;\n            &lt;input name=\"file\" type=\"file\"&gt;\n            &lt;input type=\"submit\"&gt;\n            &lt;/form&gt;\n            &lt;br&gt;\n            &lt;h3&gt;尝试访问：&lt;/h3&gt;\n            &lt;ul&gt;\n                &lt;li&gt;&lt;a href=\"/static/example.txt\"&gt;预置的静态文件 (/static/example.txt)&lt;/a&gt;&lt;/li&gt;\n                &lt;li&gt;上传后，访问：&lt;code&gt;/media/[你的文件名]&lt;/code&gt;&lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)</code></pre>\n<p>运行后，访问 <code>http://localhost:8000</code> 即可体验上传和访问文件。记得先在<code>static/</code>目录下放个<code>example.txt</code>文件。</p>\n<div style=\"text-align: center; margin: 30px 0;\">---</div>\n<p style=\"text-align: center; font-size: 0.9em; color: rgba(102, 102, 102, 1);\">喜欢本文？不要错过✨，点赞👍收藏⭐关注我👆，一起学习更多有用的知识，完善你我的技能树！也请路过的大佬给些建议和指教👉👈🥺！</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 13:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">曲幽</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}