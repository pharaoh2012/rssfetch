{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "Flink源码阅读：窗口",
      "link": "https://www.cnblogs.com/Jackeyzhe/p/19444937",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Jackeyzhe/p/19444937\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 22:47\">\n    <span>Flink源码阅读：窗口</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Flink源码阅读：窗口\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1828322/202601/1828322-20260105224732284-1871293272.png\" />\n        前文我们梳理了 Watermark 相关的源码，Watermark 的作用就是用来触发窗口，本文我们就一起看一下窗口相关的源码。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>前文我们梳理了 Watermark 相关的源码，Watermark 的作用就是用来触发窗口，本文我们就一起看一下窗口相关的源码。</p>\n<h3 id=\"写在前面\">写在前面</h3>\n<p>在<a href=\"https://jackeyzhe.github.io/2025/07/19/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AA%97%E5%8F%A3/\" rel=\"noopener nofollow\" target=\"_blank\">Flink学习笔记：窗口</a>一文中，我们介绍了窗口的分类以及基本的用法。按照处理数据流的类型划分，Flink 可以分为 Keyed Window 和 Non-Keyed Window，它们的用法如下：</p>\n<pre><code class=\"language-java\">stream\n       .keyBy(...)               &lt;-  仅 keyed 窗口需要\n       .window(...)              &lt;-  必填项：\"assigner\"\n      [.trigger(...)]            &lt;-  可选项：\"trigger\" (省略则使用默认 trigger)\n      [.evictor(...)]            &lt;-  可选项：\"evictor\" (省略则不使用 evictor)\n      [.allowedLateness(...)]    &lt;-  可选项：\"lateness\" (省略则为 0)\n      [.sideOutputLateData(...)] &lt;-  可选项：\"output tag\" (省略则不对迟到数据使用 side output)\n       .reduce/aggregate/apply()      &lt;-  必填项：\"function\"\n      [.getSideOutput(...)]      &lt;-  可选项：\"output tag\"\n\nstream\n       .windowAll(...)           &lt;-  必填项：\"assigner\"\n      [.trigger(...)]            &lt;-  可选项：\"trigger\" (else default trigger)\n      [.evictor(...)]            &lt;-  可选项：\"evictor\" (else no evictor)\n      [.allowedLateness(...)]    &lt;-  可选项：\"lateness\" (else zero)\n      [.sideOutputLateData(...)] &lt;-  可选项：\"output tag\" (else no side output for late data)\n       .reduce/aggregate/apply()      &lt;-  必填项：\"function\"\n      [.getSideOutput(...)]      &lt;-  可选项：\"output tag\"\n</code></pre>\n<p>下面我们根据用法，分别来看两种窗口的源码。</p>\n<h3 id=\"keyed-window\">Keyed Window</h3>\n<p><img alt=\"KeyedWindow\" class=\"lazyload\" /></p>\n<h4 id=\"windowassigner\">WindowAssigner</h4>\n<p>在示例代码中，数据流类型流转过程如图。我们聚焦于 WindowedStream，它是在调用 <code>KeyedStream.window</code> 方法之后生成的。window 方法需要传入一个 WindowAssigner，用来确定一条消息属于哪几个窗口，各个类型的窗口都有不同的实现。</p>\n<p><img alt=\"windowAssigner\" class=\"lazyload\" /></p>\n<p>我们以 TumblingEventTimeWindows 为例，看一下它具体的分配逻辑。</p>\n<pre><code class=\"language-java\">public Collection&lt;TimeWindow&gt; assignWindows(\n        Object element, long timestamp, WindowAssignerContext context) {\n    if (timestamp &gt; Long.MIN_VALUE) {\n        if (staggerOffset == null) {\n            staggerOffset =\n                    windowStagger.getStaggerOffset(context.getCurrentProcessingTime(), size);\n        }\n        // Long.MIN_VALUE is currently assigned when no timestamp is present\n        long start =\n                TimeWindow.getWindowStartWithOffset(\n                        timestamp, (globalOffset + staggerOffset) % size, size);\n        return Collections.singletonList(new TimeWindow(start, start + size));\n    } else {\n        throw new RuntimeException(\n                \"Record has Long.MIN_VALUE timestamp (= no timestamp marker). \"\n                        + \"Did you forget to call 'DataStream.assignTimestampsAndWatermarks(...)'?\");\n    }\n}\n</code></pre>\n<p>这里就是根据消息的 timestamp 来确定窗口的开始和结束时间，然后返回消息所属的窗口。这里还有个 windowStagger 变量，它是窗口触发是否错峰的配置，如果你的任务有成千上万个子任务，同时触发窗口计算带来的瞬时流量可能会对服务器本身和下游造成稳定性的影响，这时就可以通过修改 WindowStagger 配置将流量打散。</p>\n<p>将我们自己定义好的 WindowAssigner 传入 window 方法后，会创建一个 WindowOperatorBuilder，它负责创建一个 WindowOperator 对象，WindowOperator 来执行窗口具体的计算逻辑。</p>\n<pre><code class=\"language-java\">public WindowedStream(KeyedStream&lt;T, K&gt; input, WindowAssigner&lt;? super T, W&gt; windowAssigner) {\n\n    this.input = input;\n    this.isEnableAsyncState = input.isEnableAsyncState();\n\n    this.builder =\n            new WindowOperatorBuilder&lt;&gt;(\n                    windowAssigner,\n                    windowAssigner.getDefaultTrigger(),\n                    input.getExecutionConfig(),\n                    input.getType(),\n                    input.getKeySelector(),\n                    input.getKeyType());\n}\n</code></pre>\n<h4 id=\"trigger\">Trigger</h4>\n<p>有了 WindowOperatorBuilder 之后，我们可以对它进行一些设置，如 trigger、evictor 等，trigger 中提供了一些回调函数，这些回调函数的返回结果 TriggerResult 决定了是否触发窗口计算。</p>\n<pre><code class=\"language-java\">public abstract class Trigger&lt;T, W extends Window&gt; implements Serializable {\n\n    private static final long serialVersionUID = -4104633972991191369L;\n\n    public abstract TriggerResult onElement(T element, long timestamp, W window, TriggerContext ctx)\n            throws Exception;\n\n    public abstract TriggerResult onProcessingTime(long time, W window, TriggerContext ctx)\n            throws Exception;\n\n    public abstract TriggerResult onEventTime(long time, W window, TriggerContext ctx)\n            throws Exception;\n\n    public boolean canMerge() {\n        return false;\n    }\n\n    public void onMerge(W window, OnMergeContext ctx) throws Exception {\n        throw new UnsupportedOperationException(\"This trigger does not support merging.\");\n    }\n\n    public abstract void clear(W window, TriggerContext ctx) throws Exception;\n}\n</code></pre>\n<p>回调函数有三个，分别是 onElement、onProcessingTime、onEventTime，onElement 是在处理每条消息的时候触发，onProcessingTime 和 onEventTime 都是与定时器配合触发，上一篇文章我们提到过，在处理 Watermark 的时候会注册定时器，触发时就会回调这两个方法。</p>\n<p>此外，Trigger 类中还有三个方法，我们简单介绍一下。canMerge 是用来判断窗口是否可以被合并，onMerge 则是在合并窗口时的回调方法。clear 方法用于清除窗口的状态数据。</p>\n<pre><code class=\"language-java\">public enum TriggerResult {\n\n    /** No action is taken on the window. */\n    CONTINUE(false, false),\n\n    /** {@code FIRE_AND_PURGE} evaluates the window function and emits the window result. */\n    FIRE_AND_PURGE(true, true),\n\n    /**\n     * On {@code FIRE}, the window is evaluated and results are emitted. The window is not purged,\n     * though, all elements are retained.\n     */\n    FIRE(true, false),\n\n    /**\n     * All elements in the window are cleared and the window is discarded, without evaluating the\n     * window function or emitting any elements.\n     */\n    PURGE(false, true);\n}\n</code></pre>\n<p>说回 TriggerResult，它有四种枚举：</p>\n<ul>\n<li>\n<p>CONTINUE：什么也不做</p>\n</li>\n<li>\n<p>FIRE_AND_PURGE：触发窗口计算并清除窗口中的元素</p>\n</li>\n<li>\n<p>FIRE：只触发窗口计算</p>\n</li>\n<li>\n<p>PURGE：清除窗口中的元素，不触发计算</p>\n</li>\n</ul>\n<h4 id=\"evictor\">Evictor</h4>\n<p>Evictor 是用来自定义删除窗口中元素的的接口，如果设置了 evictor，WindowOperatorBuilder 就会创建 EvictingWindowOperator。在执行窗口计算逻辑前后，都会调用 evictBefore 和 evictAfter。</p>\n<pre><code class=\"language-java\">private void emitWindowContents(\n        W window, Iterable&lt;StreamRecord&lt;IN&gt;&gt; contents, ListState&lt;StreamRecord&lt;IN&gt;&gt; windowState)\n        throws Exception {\n    ...\n    evictorContext.evictBefore(recordsWithTimestamp, Iterables.size(recordsWithTimestamp));\n\n    FluentIterable&lt;IN&gt; projectedContents =\n            recordsWithTimestamp.transform(\n                    new Function&lt;TimestampedValue&lt;IN&gt;, IN&gt;() {\n                        @Override\n                        public IN apply(TimestampedValue&lt;IN&gt; input) {\n                            return input.getValue();\n                        }\n                    });\n\n    processContext.window = triggerContext.window;\n    userFunction.process(\n            triggerContext.key,\n            triggerContext.window,\n            processContext,\n            projectedContents,\n            timestampedCollector);\n    evictorContext.evictAfter(recordsWithTimestamp, Iterables.size(recordsWithTimestamp));\n    ...\n}\n</code></pre>\n<h4 id=\"allowedlateness--sideoutputlatedata\">allowedLateness &amp; sideOutputLateData</h4>\n<p>allowedLateness 和 sideOutputLateData 都是针对迟到数据的，allowedLateness 是用来指定允许的最大迟到时长，sideOutputLateData 则是将迟到数据输出到指定 outputTag。</p>\n<p>判断是否迟到的方法如下：</p>\n<pre><code class=\"language-java\">protected boolean isElementLate(StreamRecord&lt;IN&gt; element) {\n    return (windowAssigner.isEventTime())\n            &amp;&amp; (element.getTimestamp() + allowedLateness\n                    &lt;= internalTimerService.currentWatermark());\n}\n</code></pre>\n<p>如果是迟到数据，则进行如下处理：</p>\n<pre><code class=\"language-java\">if (isSkippedElement &amp;&amp; isElementLate(element)) {\n    if (lateDataOutputTag != null) {\n        sideOutput(element);\n    } else {\n        this.numLateRecordsDropped.inc();\n    }\n}\n</code></pre>\n<h4 id=\"windowoperator\">WindowOperator</h4>\n<p>设置好 WindowOperatorBuilder 之后，接着就可以调用 process/aggregate/reduce 等方法进行数据计算。</p>\n<p>我们以 process 方法为例，来看下具体的处理逻辑。</p>\n<pre><code class=\"language-java\">public &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; process(\n        ProcessWindowFunction&lt;T, R, K, W&gt; function, TypeInformation&lt;R&gt; resultType) {\n    function = input.getExecutionEnvironment().clean(function);\n\n    final String opName = builder.generateOperatorName();\n    final String opDesc = builder.generateOperatorDescription(function, null);\n\n    OneInputStreamOperator&lt;T, R&gt; operator =\n            isEnableAsyncState ? builder.asyncProcess(function) : builder.process(function);\n\n    return input.transform(opName, resultType, operator).setDescription(opDesc);\n}\n</code></pre>\n<p>在 <code>WindowedStream.process</code> 方法中，就是调用 WindowOperatorBuilder 的 process 方法（如果是异步则调用异步方法）生成 WindowOperator，再将 WindowOperator 加入到执行图中。</p>\n<p>下面我们来看 WindowOperator 中几个重要的方法。</p>\n<h5 id=\"open\">open</h5>\n<p>首先是 open 方法，它主要负责进行初始化，包括创建 timerService，创建 windowState 等。</p>\n<pre><code class=\"language-java\">public void open() throws Exception {\n    super.open();\n\n    this.numLateRecordsDropped = metrics.counter(LATE_ELEMENTS_DROPPED_METRIC_NAME);\n    timestampedCollector = new TimestampedCollector&lt;&gt;(output);\n\n    internalTimerService = getInternalTimerService(\"window-timers\", windowSerializer, this);\n\n    triggerContext = new Context(null, null);\n    processContext = new WindowContext(null);\n\n    windowAssignerContext =\n            new WindowAssigner.WindowAssignerContext() {\n                @Override\n                public long getCurrentProcessingTime() {\n                    return internalTimerService.currentProcessingTime();\n                }\n            };\n\n    // create (or restore) the state that hold the actual window contents\n    // NOTE - the state may be null in the case of the overriding evicting window operator\n    if (windowStateDescriptor != null) {\n        windowState =\n                (InternalAppendingState&lt;K, W, IN, ACC, ACC&gt;)\n                        getOrCreateKeyedState(windowSerializer, windowStateDescriptor);\n    }\n\n    // create the typed and helper states for merging windows\n    if (windowAssigner instanceof MergingWindowAssigner) {\n        ...\n    }\n}\n</code></pre>\n<h5 id=\"processelement\">processElement</h5>\n<p>processElement 是负责处理进入窗口的数据，这里首先调用 <code>WindowAssigner.assignWindows</code> 方法确认元素属于哪些窗口。然后遍历窗口进行处理，包括向 windowState 中添加元素，调用 trigger 的 onElement 方法获取 TriggerResult。如果触发了窗口计算，调用 emitWindowContents 执行计算逻辑。最后是处理迟到数据，我们前面提到过。</p>\n<pre><code class=\"language-java\">public void processElement(StreamRecord&lt;IN&gt; element) throws Exception {\n    final Collection&lt;W&gt; elementWindows =\n            windowAssigner.assignWindows(\n                    element.getValue(), element.getTimestamp(), windowAssignerContext);\n\n    // if element is handled by none of assigned elementWindows\n    boolean isSkippedElement = true;\n\n    final K key = this.&lt;K&gt;getKeyedStateBackend().getCurrentKey();\n\n    if (windowAssigner instanceof MergingWindowAssigner) {\n        ...\n    } else {\n        for (W window : elementWindows) {\n\n            // drop if the window is already late\n            if (isWindowLate(window)) {\n                continue;\n            }\n            isSkippedElement = false;\n\n            windowState.setCurrentNamespace(window);\n            windowState.add(element.getValue());\n\n            triggerContext.key = key;\n            triggerContext.window = window;\n\n            TriggerResult triggerResult = triggerContext.onElement(element);\n\n            if (triggerResult.isFire()) {\n                ACC contents = windowState.get();\n                if (contents != null) {\n                    emitWindowContents(window, contents);\n                }\n            }\n\n            if (triggerResult.isPurge()) {\n                windowState.clear();\n            }\n            registerCleanupTimer(window);\n        }\n    }\n\n    // side output input event if\n    // element not handled by any window\n    // late arriving tag has been set\n    // windowAssigner is event time and current timestamp + allowed lateness no less than\n    // element timestamp\n    if (isSkippedElement &amp;&amp; isElementLate(element)) {\n        if (lateDataOutputTag != null) {\n            sideOutput(element);\n        } else {\n            this.numLateRecordsDropped.inc();\n        }\n    }\n}\n</code></pre>\n<h5 id=\"oneventtime\">onEventTime</h5>\n<p>onEventTime 方法是 eventTime 触发窗口计算时调用的。主要逻辑就是获取 TriggerResult，然后触发计算逻辑，以及对 windowState 的处理。</p>\n<pre><code class=\"language-java\">public void onEventTime(InternalTimer&lt;K, W&gt; timer) throws Exception {\n    triggerContext.key = timer.getKey();\n    triggerContext.window = timer.getNamespace();\n\n    MergingWindowSet&lt;W&gt; mergingWindows;\n\n    if (windowAssigner instanceof MergingWindowAssigner) {\n        mergingWindows = getMergingWindowSet();\n        W stateWindow = mergingWindows.getStateWindow(triggerContext.window);\n        if (stateWindow == null) {\n            // Timer firing for non-existent window, this can only happen if a\n            // trigger did not clean up timers. We have already cleared the merging\n            // window and therefore the Trigger state, however, so nothing to do.\n            return;\n        } else {\n            windowState.setCurrentNamespace(stateWindow);\n        }\n    } else {\n        windowState.setCurrentNamespace(triggerContext.window);\n        mergingWindows = null;\n    }\n\n    TriggerResult triggerResult = triggerContext.onEventTime(timer.getTimestamp());\n\n    if (triggerResult.isFire()) {\n        ACC contents = windowState.get();\n        if (contents != null) {\n            emitWindowContents(triggerContext.window, contents);\n        }\n    }\n\n    if (triggerResult.isPurge()) {\n        windowState.clear();\n    }\n\n    if (windowAssigner.isEventTime()\n            &amp;&amp; isCleanupTime(triggerContext.window, timer.getTimestamp())) {\n        clearAllState(triggerContext.window, windowState, mergingWindows);\n    }\n\n    if (mergingWindows != null) {\n        // need to make sure to update the merging state in state\n        mergingWindows.persist();\n    }\n}\n</code></pre>\n<h5 id=\"onprocessingtime\">onProcessingTime</h5>\n<p>onProcessingTime 和 onEventTime 逻辑基本一致，只是触发条件不同，这里就不再赘述了。</p>\n<p>至此，Keyed Window 从设置到使用的源码我们就梳理完成了，下面再来看另外一种窗口 Non-Keyed Window。</p>\n<h3 id=\"non-keyed-window\">Non-Keyed Window</h3>\n<p><img alt=\"AllWindow\" class=\"lazyload\" /></p>\n<p>我们调用 windowAll 得到 AllWindowedStream，在构造函数中，会给对 input 调用 keyBy 方法，传入 NullByteKeySelector， NullByteKeySelector 对每个 key 都返回0，因此所有的 key 都会被分配到同一个节点。</p>\n<pre><code class=\"language-java\">public class NullByteKeySelector&lt;T&gt; implements KeySelector&lt;T, Byte&gt; {\n\n    private static final long serialVersionUID = 614256539098549020L;\n\n    @Override\n    public Byte getKey(T value) throws Exception {\n        return 0;\n    }\n}\n</code></pre>\n<p>Non-Keyed Window 后续的逻辑都和 Keyed Window 比较类似。</p>\n<h3 id=\"总结\">总结</h3>\n<p>本文我们梳理了窗口相关的源码，几个重点概念包括 WindowAssginer、WindowOperator、Trigger、Evictor。其中 WindowAssigner 是用来确定一条消息属于哪些窗口，WindowOperator 则是窗口计算逻辑的具体执行层。Trigger 和 Evictor 分别用于触发窗口和清理窗口中数据。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 22:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Jackeyzhe\">Jackeyzhe</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": ".NET 传统信息系统无缝集成飞书审批流",
      "link": "https://www.cnblogs.com/mudtools/p/19444914",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/mudtools/p/19444914\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 22:39\">\n    <span>.NET 传统信息系统无缝集成飞书审批流</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>周末深夜，你收到紧急审批通知——却发现只能在 PC 端处理，只能摸黑起床开电脑……</p>\n</blockquote>\n<p>这样的场景，你是否也经历过？</p>\n<p><strong>传统 .NET 系统与现代移动协同之间的鸿沟，正在悄悄吞噬着企业的效率</strong>。审批卡在桌面端、通知滞后、数据孤岛——这些问题让工作体验大打折扣。</p>\n<p>推倒重来？成本太高，风险太大。</p>\n<p><strong>本文将带你走一条渐进式改造之路</strong>：保持 .NET 系统作为业务核心，将飞书审批作为移动门户，通过 API 实现无缝协同。从原理、设计到编码，完整呈现如何让传统系统焕发新生，实现移动化、实时化的现代化升级。</p>\n<p>无论你是开发者、架构师还是技术管理者，都能收获一套可落地、可扩展的集成方案和直接复用的代码实践。</p>\n<h2 id=\"当传统业务遇上现代协同为何必须破壁\">当传统业务遇上现代协同，为何必须\"破壁\"？</h2>\n<h3 id=\"我们正在解决什么\">我们正在解决什么？</h3>\n<p><strong>传统 .NET 系统的局限</strong></p>\n<p>许多企业拥有多年累积的 .NET 业务系统，这些系统在企业运营中扮演着核心角色。然而，随着移动办公和现代协同工具的普及，这些传统系统正面临着严峻的挑战：</p>\n<table>\n<thead>\n<tr>\n<th>痛点</th>\n<th>具体表现</th>\n<th>业务影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>审批流程封闭</strong></td>\n<td>审批只能在桌面端完成，无法随时随地处理</td>\n<td>移动办公受阻，响应迟缓</td>\n</tr>\n<tr>\n<td><strong>通知方式滞后</strong></td>\n<td>依赖邮件或站内消息推送</td>\n<td>审批人及时性差，流程延误</td>\n</tr>\n<tr>\n<td><strong>数据孤岛严重</strong></td>\n<td>审批数据与业务数据分离</td>\n<td>无法形成完整的业务闭环</td>\n</tr>\n<tr>\n<td><strong>用户体验陈旧</strong></td>\n<td>界面风格陈旧，交互体验差</td>\n<td>用户满意度低，使用意愿下降</td>\n</tr>\n</tbody>\n</table>\n<p><strong>飞书审批的赋能价值</strong></p>\n<p>飞书审批作为企业级的审批协作平台，为我们提供了一个理想的\"流程协作中心\"：</p>\n<div class=\"mermaid\">graph LR\n    A[飞书审批平台] --&gt; B[移动优先]\n    A --&gt; C[即时强通知]\n    A --&gt; D[流程可视化]\n    A --&gt; E[完善审计日志]\n\n    B --&gt; B1[随时随地处理审批]\n    C --&gt; C1[App推送/短信提醒]\n    D --&gt; D1[拖拽式流程配置]\n    E --&gt; E1[完整操作痕迹追溯]\n</div><p><strong>我们的核心目标</strong></p>\n<p>通过本文的实践，我们将建立 <strong>\".NET 系统为业务核心，飞书审批为流程门户\"</strong> 的现代化混合架构：</p>\n<blockquote>\n<p><strong>架构愿景</strong>：将飞书审批作为统一的移动审批门户，保持 .NET 系统作为业务逻辑和数据存储的核心，通过 API 实时同步，形成优势互补的协同体系。</p>\n</blockquote>\n<h3 id=\"你将收获什么\">你将收获什么？</h3>\n<ul>\n<li>✅ <strong>一套端到端的集成方法论</strong>，覆盖从原理、设计到部署的全流程</li>\n<li>✅ <strong>清晰的 .NET 侧架构蓝图</strong>，包含关键的技术选型与设计决策</li>\n<li>✅ <strong>可直接复用的 C# 核心代码</strong>与实践中总结的\"避坑指南\"</li>\n<li>✅ <strong>一个完整的\"请假审批\"实战案例</strong>，助你从零到一完成验证</li>\n</ul>\n<hr />\n<h2 id=\"飞书审批开放平台如何与我们对话\">飞书审批开放平台如何与我们\"对话\"？</h2>\n<h3 id=\"双向集成的关键流程\">双向集成的关键流程</h3>\n<p>飞书审批与 .NET 系统的集成是一个<strong>双向数据流</strong>的过程：</p>\n<div class=\"mermaid\">sequenceDiagram\n    participant User as 用户\n    participant NET as .NET系统\n    participant API as 飞书API\n    participant FS as 飞书App\n\n    Note over User,FS: 流程输出：发起审批\n    User-&gt;&gt;NET: 1. 提交请假申请\n    NET-&gt;&gt;NET: 2. 保存业务数据（状态：审批中）\n    NET-&gt;&gt;API: 3. 调用 CreateInstanceAsync\n    API--&gt;&gt;NET: 4. 返回 instance_code\n    NET-&gt;&gt;NET: 5. 关联业务ID与instance_code\n\n    Note over User,FS: 流程输入：回调通知\n    User-&gt;&gt;FS: 6. 在飞书App中审批\n    FS-&gt;&gt;API: 7. 审批完成\n    API-&gt;&gt;NET: 8. Webhook回调事件\n    NET-&gt;&gt;NET: 9. 根据instance_code更新业务状态\n</div><h4 id=\"流程输出发起阶段\">流程输出（发起阶段）</h4>\n<p>当用户在 .NET 系统发起审批时，系统会：</p>\n<ol>\n<li>保存业务数据，状态标记为\"审批中\"</li>\n<li>调用飞书 API <code>CreateInstanceAsync</code> 创建审批实例</li>\n<li>接收返回的 <code>instance_code</code>，持久化到关联表</li>\n</ol>\n<h4 id=\"流程输入回调阶段\">流程输入（回调阶段）</h4>\n<p>当审批人在飞书 App 完成审批后：</p>\n<ol>\n<li>飞书服务器主动回调 .NET 系统的 Webhook 接口</li>\n<li>.NET 系统解析事件，提取 <code>instance_code</code> 和 <code>status</code></li>\n<li>根据关联表查询对应的业务记录</li>\n<li>更新业务状态，完成闭环</li>\n</ol>\n<h3 id=\"必须理解的三个核心概念\">必须理解的三个核心概念</h3>\n<h4 id=\"审批定义approval_code\">审批定义（approval_code）</h4>\n<p><strong>审批定义</strong>是审批流程的\"蓝图\"，在飞书管理后台配置：</p>\n<pre><code class=\"language-csharp\">// 示例：请假审批的审批定义\nvar approvalCode = \"7C468A54-8745-2245-9675-08B7C63E7A85\";\n</code></pre>\n<p><strong>定义包含</strong>：</p>\n<ul>\n<li>表单结构（请假类型、开始时间、结束时间、请假事由等）</li>\n<li>审批流程（直属主管审批 → 人事审批）</li>\n<li>权限设置（谁可以发起、谁可以审批）</li>\n</ul>\n<h4 id=\"审批实例instance_code\">审批实例（instance_code）</h4>\n<p><strong>审批实例</strong>是依据审批定义发起的一次具体审批任务：</p>\n<pre><code class=\"language-csharp\">// 创建审批实例时返回\npublic record CreateInstancesResult\n{\n    /// &lt;summary&gt;\n    /// 审批实例 Code\n    /// &lt;/summary&gt;\n    [JsonPropertyName(\"instance_code\")]\n    public string InstanceCode { get; set; } = string.Empty;\n}\n</code></pre>\n<p><strong>关键属性</strong>：</p>\n<ul>\n<li>唯一标识一次审批流程</li>\n<li>包含该次审批的所有表单数据</li>\n<li>拥有独立的状态（审批中、通过、拒绝、撤回等）</li>\n</ul>\n<h4 id=\"身份映射免登\">身份映射（免登）</h4>\n<p>实现 .NET 系统用户与飞书用户的关联：</p>\n<div class=\"mermaid\">graph LR\n    A[.NET系统用户&lt;br/&gt;UserId: 1001] --&gt;|映射关系| B[飞书用户&lt;br/&gt;OpenId: ou_3cda9c...]\n    B --&gt;|通过飞书App审批| C[审批完成]\n    C --&gt;|回调instance_code| A\n</div><p><strong>实现方式</strong>：</p>\n<ol>\n<li>在 .NET 系统的用户表中添加 <code>FeishuOpenId</code> 字段</li>\n<li>用户首次登录时进行飞书免登录认证，获取并存储 <code>open_id</code></li>\n<li>发起审批时，使用 <code>open_id</code> 指定审批发起人</li>\n</ol>\n<hr />\n<h2 id=\"构建稳健可扩展的-net-侧集成层\">构建稳健、可扩展的 .NET 侧集成层</h2>\n<h3 id=\"技术栈推荐\">技术栈推荐</h3>\n<table>\n<thead>\n<tr>\n<th>层次</th>\n<th>技术选型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>应用框架</strong></td>\n<td>.NET 6/8/10</td>\n<td>长期支持版本，性能优异</td>\n</tr>\n<tr>\n<td><strong>飞书 SDK</strong></td>\n<td>Mud.Feishu</td>\n<td>高度封装的飞书 API 客户端</td>\n</tr>\n<tr>\n<td><strong>Webhook 处理</strong></td>\n<td>Mud.Feishu.Webhook</td>\n<td>飞书事件回调处理组件</td>\n</tr>\n<tr>\n<td><strong>认证授权</strong></td>\n<td>ASP.NET Core Identity / JWT</td>\n<td>内部系统身份管理</td>\n</tr>\n<tr>\n<td><strong>异步解耦</strong></td>\n<td>RabbitMQ / Hangfire</td>\n<td>回调消息队列处理，提升可靠性</td>\n</tr>\n<tr>\n<td><strong>数据存储</strong></td>\n<td>SQL Server / PostgreSQL</td>\n<td>业务数据 + 审批关联表</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"分层架构图\">分层架构图</h3>\n<div class=\"mermaid\">graph TB\n    subgraph \"表示层 (UI)\"\n        A[Web 前端 / 移动端]\n    end\n\n    subgraph \"应用层 (API)\"\n        B[LeaveController]\n        C[FeishuWebhookController]\n    end\n\n    subgraph \"领域层 (业务逻辑)\"\n        D[ILeaveService]\n        E[ApprovalIntegrationService]\n        F[IApprovalService]\n    end\n\n    subgraph \"基础设施层\"\n        G[Mud.Feishu HTTP客户端]\n        H[Mud.Feishu.Webhook处理器]\n        I[数据仓储&lt;br/&gt;EF Core]\n    end\n\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    C --&gt; E\n    D --&gt; F\n    E --&gt; F\n    F --&gt; G\n    F --&gt; H\n    F --&gt; I\n</div><h4 id=\"关键设计领域层抽象\">关键设计：领域层抽象</h4>\n<p>在领域层引入 <code>IApprovalService</code> 接口，将飞书集成细节与核心业务逻辑解耦：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 审批服务抽象接口 - 解耦飞书实现细节\n/// &lt;/summary&gt;\npublic interface IApprovalService\n{\n    /// &lt;summary&gt;\n    /// 发起审批\n    /// &lt;/summary&gt;\n    Task&lt;string&gt; CreateApprovalAsync(ApprovalRequest request);\n\n    /// &lt;summary&gt;\n    /// 处理审批结果回调\n    /// &lt;/summary&gt;\n    Task HandleApprovalCallbackAsync(ApprovalCallbackEvent callbackEvent);\n}\n\n/// &lt;summary&gt;\n/// 飞书审批服务实现\n/// &lt;/summary&gt;\npublic class FeishuApprovalService : IApprovalService\n{\n    private readonly IFeishuTenantV4Approval _approvalApi;\n    private readonly IApprovalRecordRepository _repository;\n\n    public FeishuApprovalService(\n        IFeishuTenantV4Approval approvalApi,\n        IApprovalRecordRepository repository)\n    {\n        _approvalApi = approvalApi;\n        _repository = repository;\n    }\n\n    public async Task&lt;string&gt; CreateApprovalAsync(ApprovalRequest request)\n    {\n        // 调用飞书 API\n        var result = await _approvalApi.CreateInstanceAsync(...);\n        return result.Data?.InstanceCode ?? string.Empty;\n    }\n}\n</code></pre>\n<p><strong>优势</strong>：</p>\n<ul>\n<li>业务逻辑不依赖具体飞书实现</li>\n<li>便于单元测试（可 Mock 接口）</li>\n<li>未来可轻松切换到其他审批平台</li>\n</ul>\n<hr />\n<h2 id=\"实战手把手完成请假审批集成\">实战：手把手完成\"请假审批\"集成</h2>\n<h3 id=\"第一步飞书平台侧配置审批流出口\">第一步：飞书平台侧配置（审批流出口）</h3>\n<h4 id=\"创建企业自建应用\">创建企业自建应用</h4>\n<p>登录飞书开放平台（<a href=\"https://open.feishu.cn\" rel=\"noopener nofollow\" target=\"_blank\">https://open.feishu.cn</a>），进入应用管理：</p>\n<div class=\"mermaid\">graph LR\n    A[创建自建应用] --&gt; B[获取App ID]\n    A --&gt; C[获取App Secret]\n    B --&gt; D[配置到.NET系统]\n    C --&gt; D\n</div><p><strong>关键配置</strong>：</p>\n<ul>\n<li>记录 <code>App ID</code> 和 <code>App Secret</code></li>\n<li>配置应用权限：审批相关权限（<code>approval:approval:read</code>, <code>approval:instance:read</code>, <code>approval:instance:create</code>）</li>\n</ul>\n<h4 id=\"配置审批定义\">配置审批定义</h4>\n<p>在飞书管理后台创建\"请假审批\"模板：</p>\n<div class=\"mermaid\">graph LR\n    A[审批定义配置] --&gt; B[表单设置]\n    A --&gt; C[流程设置]\n    A --&gt; D[权限设置]\n\n    B --&gt; B1[请假类型&lt;br/&gt;开始时间&lt;br/&gt;结束时间&lt;br/&gt;请假天数&lt;br/&gt;请假事由]\n    C --&gt; C1[直属主管审批&lt;br/&gt;→ 人事审批]\n    D --&gt; D1[全员可发起]\n</div><p><strong>记录关键信息</strong>：</p>\n<ul>\n<li><code>approval_code</code>：审批定义的唯一标识</li>\n<li>表单控件的 <code>id</code>：用于程序填充表单数据</li>\n</ul>\n<h4 id=\"配置事件订阅\">配置事件订阅</h4>\n<p>在飞书开放平台配置 Webhook：</p>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>请求网址</td>\n<td><code>https://your-domain.com/api/feishu/webhook</code></td>\n</tr>\n<tr>\n<td>验证 Token</td>\n<td><code>your_verification_token</code>（自定义）</td>\n</tr>\n<tr>\n<td>加密 Key</td>\n<td><code>your_encrypt_key</code>（自定义）</td>\n</tr>\n<tr>\n<td>订阅事件</td>\n<td><code>approval_instance</code>（审批实例状态变更）</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h3 id=\"第二步net-侧基础搭建集成基石\">第二步：.NET 侧基础搭建（集成基石）</h3>\n<h4 id=\"封装飞书-api-客户端\">封装飞书 API 客户端</h4>\n<p>基于 <code>MudFeishu SDK</code> 封装审批服务：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 飞书审批服务封装\n/// &lt;/summary&gt;\npublic class FeishuApprovalClient\n{\n    private readonly IFeishuTenantV4Approval _approvalApi;\n    private readonly ILogger&lt;FeishuApprovalClient&gt; _logger;\n\n    public FeishuApprovalClient(\n        IFeishuTenantV4Approval approvalApi,\n        ILogger&lt;FeishuApprovalClient&gt; logger)\n    {\n        _approvalApi = approvalApi;\n        _logger = logger;\n    }\n\n    /// &lt;summary&gt;\n    /// 创建审批实例\n    /// &lt;/summary&gt;\n    public async Task&lt;string&gt; CreateInstanceAsync(CreateInstanceRequest request)\n    {\n        var result = await _approvalApi.CreateInstanceAsync(request);\n\n        if (result == null || result.Code != 0)\n        {\n            _logger.LogError(\"创建审批实例失败: {Msg}\", result?.Msg);\n            throw new InvalidOperationException($\"创建审批实例失败: {result?.Msg}\");\n        }\n\n        _logger.LogInformation(\"创建审批实例成功: {InstanceCode}\", result.Data?.InstanceCode);\n        return result.Data?.InstanceCode ?? string.Empty;\n    }\n\n    /// &lt;summary&gt;\n    /// 获取审批实例详情\n    /// &lt;/summary&gt;\n    public async Task&lt;GetApprovalInstanceResult?&gt; GetInstanceAsync(string instanceCode)\n    {\n        var result = await _approvalApi.GetInstanceByIdAsync(instanceCode);\n\n        if (result == null || result.Code != 0)\n        {\n            _logger.LogError(\"获取审批实例失败: {Msg}\", result?.Msg);\n            return null;\n        }\n\n        return result.Data;\n    }\n}\n</code></pre>\n<h4 id=\"设计数据关联表\">设计数据关联表</h4>\n<p>在业务数据库中添加审批关联表：</p>\n<pre><code class=\"language-sql\">-- 审批关联表\nCREATE TABLE ApprovalRecords (\n    Id BIGINT PRIMARY KEY IDENTITY(1,1),\n    BusinessType NVARCHAR(50) NOT NULL,          -- 业务类型：LeaveRequest, PurchaseRequest...\n    BusinessId BIGINT NOT NULL,                   -- 业务ID\n    InstanceCode NVARCHAR(64) NOT NULL,           -- 飞书审批实例Code\n    ApprovalCode NVARCHAR(64) NOT NULL,            -- 审批定义Code\n    Status NVARCHAR(20) NOT NULL,                  -- 状态：PENDING, APPROVED, REJECTED...\n    CallbackData NVARCHAR(MAX),                   -- 回调数据（JSON）\n    CreatedTime DATETIME2 NOT NULL DEFAULT GETUTCDATE(),\n    UpdatedTime DATETIME2 NOT NULL DEFAULT GETUTCDATE(),\n\n    CONSTRAINT UK_ApprovalRecords_Business UNIQUE(BusinessType, BusinessId)\n);\n\nCREATE INDEX IX_ApprovalRecords_InstanceCode ON ApprovalRecords(InstanceCode);\nCREATE INDEX IX_ApprovalRecords_Status ON ApprovalRecords(Status);\n</code></pre>\n<p>对应的实体类：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 审批关联记录\n/// &lt;/summary&gt;\npublic class ApprovalRecord\n{\n    public long Id { get; set; }\n    public string BusinessType { get; set; } = string.Empty;  // \"LeaveRequest\"\n    public long BusinessId { get; set; }                       // 请假申请ID\n    public string InstanceCode { get; set; } = string.Empty;   // 飞书实例Code\n    public string ApprovalCode { get; set; } = string.Empty;    // 审批定义Code\n    public string Status { get; set; } = string.Empty;         // PENDING/APPROVED/REJECTED\n    public string? CallbackData { get; set; }                  // JSON格式\n    public DateTime CreatedTime { get; set; }\n    public DateTime UpdatedTime { get; set; }\n}\n</code></pre>\n<hr />\n<h3 id=\"第三步核心业务流程编码双向联通\">第三步：核心业务流程编码（双向联通）</h3>\n<h4 id=\"场景用户提交请假单发起审批\">场景：用户提交请假单，发起审批</h4>\n<p><strong>流程图</strong>：</p>\n<div class=\"mermaid\">sequenceDiagram\n    participant User as 用户\n    participant Controller as LeaveController\n    participant Service as LeaveService\n    participant DB as 数据库\n    participant FeishuAPI as 飞书API\n\n    User-&gt;&gt;Controller: 提交请假申请\n    Controller-&gt;&gt;Service: SubmitLeaveRequest(request)\n    Service-&gt;&gt;DB: 保存请假记录（状态：审批中）\n    Service-&gt;&gt;Service: 构造表单数据\n    Service-&gt;&gt;FeishuAPI: CreateInstanceAsync(approvalCode, form)\n    FeishuAPI--&gt;&gt;Service: instance_code\n    Service-&gt;&gt;DB: 保存ApprovalRecord关联\n    Service--&gt;&gt;Controller: 提交成功\n    Controller--&gt;&gt;User: 等待审批\n</div><p><strong>代码实现</strong>：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 请假服务\n/// &lt;/summary&gt;\npublic class LeaveService\n{\n    private readonly ILeaveRequestRepository _leaveRepo;\n    private readonly IApprovalRecordRepository _approvalRepo;\n    private readonly FeishuApprovalClient _feishuClient;\n    private readonly ILogger&lt;LeaveService&gt; _logger;\n\n    public LeaveService(\n        ILeaveRequestRepository leaveRepo,\n        IApprovalRecordRepository approvalRepo,\n        FeishuApprovalClient feishuClient,\n        ILogger&lt;LeaveService&gt; logger)\n    {\n        _leaveRepo = leaveRepo;\n        _approvalRepo = approvalRepo;\n        _feishuClient = feishuClient;\n        _logger = logger;\n    }\n\n    /// &lt;summary&gt;\n    /// 提交请假申请并发起审批\n    /// &lt;/summary&gt;\n    public async Task&lt;long&gt; SubmitLeaveRequestAsync(SubmitLeaveRequestDto dto)\n    {\n        // 1. 保存请假业务数据\n        var leaveRequest = new LeaveRequest\n        {\n            UserId = dto.UserId,\n            LeaveType = dto.LeaveType,\n            StartTime = dto.StartTime,\n            EndTime = dto.EndTime,\n            Days = dto.Days,\n            Reason = dto.Reason,\n            Status = LeaveStatus.Pending,  // 审批中\n            CreatedTime = DateTime.UtcNow\n        };\n\n        await _leaveRepo.AddAsync(leaveRequest);\n        await _leaveRepo.SaveChangesAsync();\n\n        // 2. 构造飞书审批表单数据\n        var form = new List&lt;object&gt;\n        {\n            new { id = \"leave_type\", type = \"select\", value = dto.LeaveType },\n            new { id = \"start_time\", type = \"date\", value = dto.StartTime.ToString(\"yyyy-MM-dd\") },\n            new { id = \"end_time\", type = \"date\", value = dto.EndTime.ToString(\"yyyy-MM-dd\") },\n            new { id = \"days\", type = \"number\", value = dto.Days.ToString() },\n            new { id = \"reason\", type = \"textarea\", value = dto.Reason }\n        };\n\n        // 3. 调用飞书API创建审批实例\n        var request = new CreateInstanceRequest\n        {\n            ApprovalCode = \"7C468A54-8745-2245-9675-08B7C63E7A85\",  // 请假审批定义Code\n            UserId = dto.FeishuUserId,  // 飞书用户ID\n            Form = JsonSerializer.Serialize(form),\n            Uuid = Guid.NewGuid().ToString()  // 幂等ID\n        };\n\n        string instanceCode;\n        try\n        {\n            instanceCode = await _feishuClient.CreateInstanceAsync(request);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"创建飞书审批实例失败\");\n            // 回滚业务数据\n            leaveRequest.Status = LeaveStatus.Failed;\n            await _leaveRepo.SaveChangesAsync();\n            throw;\n        }\n\n        // 4. 保存审批关联记录\n        var approvalRecord = new ApprovalRecord\n        {\n            BusinessType = \"LeaveRequest\",\n            BusinessId = leaveRequest.Id,\n            InstanceCode = instanceCode,\n            ApprovalCode = request.ApprovalCode,\n            Status = \"PENDING\",\n            CreatedTime = DateTime.UtcNow,\n            UpdatedTime = DateTime.UtcNow\n        };\n\n        await _approvalRepo.AddAsync(approvalRecord);\n        await _approvalRepo.SaveChangesAsync();\n\n        _logger.LogInformation(\"请假申请已提交并创建审批: LeaveId={LeaveId}, InstanceCode={InstanceCode}\",\n            leaveRequest.Id, instanceCode);\n\n        return leaveRequest.Id;\n    }\n}\n</code></pre>\n<h4 id=\"场景审批完结飞书回调通知结果\">场景：审批完结，飞书回调通知结果</h4>\n<p><strong>基于 Mud.Feishu.Webhook 实现安全的回调处理器</strong></p>\n<pre><code class=\"language-csharp\">using Mud.Feishu.Abstractions;\nusing Mud.Feishu.Abstractions.DataModels.Approval;\nusing Mud.Feishu.Abstractions.EventHandlers;\n\n/// &lt;summary&gt;\n/// 审批实例事件处理器\n/// &lt;/summary&gt;\npublic class ApprovalInstanceEventHandler : ApprovalInstanceEventHandler\n{\n    private readonly IApprovalRecordRepository _approvalRepo;\n    private readonly ILeaveRequestRepository _leaveRepo;\n\n    public ApprovalInstanceEventHandler(\n        ILogger&lt;ApprovalInstanceEventHandler&gt; logger,\n        IApprovalRecordRepository approvalRepo,\n        ILeaveRequestRepository leaveRepo)\n        : base(logger)\n    {\n        _approvalRepo = approvalRepo;\n        _leaveRepo = leaveRepo;\n    }\n\n    /// &lt;summary&gt;\n    /// 处理审批实例事件业务逻辑\n    /// &lt;/summary&gt;\n    protected override async Task ProcessBusinessLogicAsync(\n        EventData eventData,\n        ObjectEventResult&lt;ApprovalInstanceResult&gt;? eventEntity,\n        CancellationToken cancellationToken = default)\n    {\n        if (eventEntity?.Object == null)\n        {\n            _logger.LogWarning(\"审批实例事件数据无效\");\n            return;\n        }\n\n        var approvalEvent = eventEntity.Object;\n\n        _logger.LogInformation(\"收到审批实例事件: InstanceCode={InstanceCode}, Status={Status}\",\n            approvalEvent.InstanceCode, approvalEvent.Status);\n\n        // 幂等性处理：检查是否已处理过该事件\n        var existingRecord = await _approvalRepo.GetByInstanceCodeAsync(approvalEvent.InstanceCode ?? string.Empty);\n        if (existingRecord != null &amp;&amp; existingRecord.Status == approvalEvent.Status)\n        {\n            _logger.LogInformation(\"该事件已处理过，跳过: EventId={EventId}\", eventData.EventId);\n            return;\n        }\n\n        // 根据业务类型处理审批结果\n        await ProcessApprovalResultAsync(eventData, approvalEvent, cancellationToken);\n    }\n\n    /// &lt;summary&gt;\n    /// 处理审批结果\n    /// &lt;/summary&gt;\n    private async Task ProcessApprovalResultAsync(\n        EventData eventData,\n        ApprovalInstanceResult approvalEvent,\n        CancellationToken cancellationToken)\n    {\n        if (string.IsNullOrEmpty(approvalEvent.InstanceCode))\n        {\n            _logger.LogWarning(\"审批实例Code为空，跳过处理\");\n            return;\n        }\n\n        // 查询审批关联记录\n        var approvalRecord = await _approvalRepo.GetByInstanceCodeAsync(approvalEvent.InstanceCode);\n        if (approvalRecord == null)\n        {\n            _logger.LogWarning(\"未找到审批关联记录: InstanceCode={InstanceCode}\",\n                approvalEvent.InstanceCode);\n            return;\n        }\n\n        // 更新审批记录状态\n        approvalRecord.Status = approvalEvent.Status ?? string.Empty;\n        approvalRecord.CallbackData = JsonSerializer.Serialize(approvalEvent);\n        approvalRecord.UpdatedTime = DateTime.UtcNow;\n        await _approvalRepo.SaveChangesAsync();\n\n        // 根据业务类型处理\n        switch (approvalRecord.BusinessType)\n        {\n            case \"LeaveRequest\":\n                await ProcessLeaveApprovalAsync(approvalRecord, approvalEvent.Status ?? string.Empty);\n                break;\n\n            // 可扩展其他业务类型\n            default:\n                _logger.LogWarning(\"未知的业务类型: {BusinessType}\", approvalRecord.BusinessType);\n                break;\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 处理请假审批结果\n    /// &lt;/summary&gt;\n    private async Task ProcessLeaveApprovalAsync(ApprovalRecord approvalRecord, string status)\n    {\n        var leaveRequest = await _leaveRepo.GetByIdAsync(approvalRecord.BusinessId);\n        if (leaveRequest == null)\n        {\n            _logger.LogWarning(\"未找到请假申请: BusinessId={BusinessId}\", approvalRecord.BusinessId);\n            return;\n        }\n\n        // 根据审批状态更新请假记录\n        leaveRequest.Status = status switch\n        {\n            \"APPROVED\" =&gt; LeaveStatus.Approved,\n            \"REJECTED\" =&gt; LeaveStatus.Rejected,\n            \"CANCELED\" =&gt; LeaveStatus.Canceled,\n            \"DELETED\" =&gt; LeaveStatus.Deleted,\n            _ =&gt; LeaveStatus.Pending\n        };\n\n        leaveRequest.UpdatedTime = DateTime.UtcNow;\n        await _leaveRepo.SaveChangesAsync();\n\n        _logger.LogInformation(\"请假申请状态已更新: LeaveId={LeaveId}, Status={Status}\",\n            leaveRequest.Id, leaveRequest.Status);\n\n        // TODO: 发送通知给申请人\n        // TODO: 同步到考勤系统\n    }\n}\n</code></pre>\n<p><strong>注册 Webhook 服务（Program.cs）</strong>：</p>\n<pre><code class=\"language-csharp\">using Mud.Feishu.Webhook;\nusing Mud.Feishu;\nusing YourApp.Handlers;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// 注册飞书 API 服务\nbuilder.Services.AddFeishuServices()\n    .ConfigureFrom(builder.Configuration)  // 从 \"Feishu\" 配置节读取\n    .Build();\n\n// 注册飞书 Webhook 事件订阅服务\nbuilder.Services.AddFeishuWebhookServiceBuilder()\n    .ConfigureFrom(builder.Configuration)  // 从 \"FeishuWebhook\" 配置节读取\n    .AddHandler&lt;ApprovalInstanceEventHandler&gt;()  // 添加审批事件处理器\n    .Build();\n\n// 注册业务服务\nbuilder.Services.AddScoped&lt;ILeaveRequestRepository, LeaveRequestRepository&gt;();\nbuilder.Services.AddScoped&lt;IApprovalRecordRepository, ApprovalRecordRepository&gt;();\n\nvar app = builder.Build();\n\napp.UseFeishuWebhook();  // 添加 Webhook 中间件\n\napp.Run();\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ul>\n<li><code>ApprovalInstanceEventHandler</code> 继承自 <code>ApprovalInstanceEventHandler</code> 基类</li>\n<li>基类已经实现了 <code>HandleAsync</code> 方法，会自动反序列化 <code>ApprovalInstanceResult</code> 类型的事件数据</li>\n<li>只需重写 <code>ProcessBusinessLogicAsync</code> 方法实现具体的业务逻辑即可</li>\n<li>SDK 会根据 <code>SupportedEventType</code> 属性自动路由对应的事件到这个处理器</li>\n<li><code>AddFeishuServices()</code> 注册飞书 API 客户端服务，使用 <code>Feishu</code> 配置节</li>\n<li><code>AddFeishuWebhookServiceBuilder()</code> 注册 Webhook 事件订阅服务，使用 <code>FeishuWebhook</code> 配置节</li>\n</ul>\n<p><strong>配置文件（appsettings.json）</strong>：</p>\n<pre><code class=\"language-json\">{\n  // 飞书 Webhook 事件订阅配置\n  \"FeishuWebhook\": {\n    \"VerificationToken\": \"your_verification_token\",\n    \"EncryptKey\": \"your_encrypt_key\",\n    \"RoutePrefix\": \"api/feishu/webhook\",\n    \"AutoRegisterEndpoint\": true,\n    \"EnableRequestLogging\": true,\n    \"EnableExceptionHandling\": true,\n    \"EventHandlingTimeoutMs\": 30000,\n    \"MaxConcurrentEvents\": 10\n  },\n\n  // 飞书 API 客户端配置\n  \"Feishu\": {\n    \"AppId\": \"your_app_id\",\n    \"AppSecret\": \"your_app_secret\",\n    \"BaseUrl\": \"https://open.feishu.cn\",\n    \"TimeOut\": \"30\",\n    \"RetryCount\": 3,\n    \"EnableLogging\": true\n  }\n}\n</code></pre>\n<hr />\n<h3 id=\"第四步功能完善与联调测试\">第四步：功能完善与联调测试</h3>\n<h4 id=\"状态同步展示\">状态同步展示</h4>\n<p>在请假列表页展示审批状态：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 请假列表响应DTO\n/// &lt;/summary&gt;\npublic class LeaveRequestDto\n{\n    public long Id { get; set; }\n    public DateTime StartTime { get; set; }\n    public DateTime EndTime { get; set; }\n    public int Days { get; set; }\n    public string Status { get; set; } = string.Empty;      // 业务状态：Approved, Rejected\n    public string ApprovalStatus { get; set; } = string.Empty; // 飞书审批状态：APPROVED, REJECTED, PENDING\n    public string? FeishuInstanceUrl { get; set; }          // 飞书审批详情链接\n    public DateTime CreatedTime { get; set; }\n}\n\n/// &lt;summary&gt;\n/// 查询请假列表\n/// &lt;/summary&gt;\npublic async Task&lt;List&lt;LeaveRequestDto&gt;&gt; GetLeaveListAsync(long userId)\n{\n    var leaves = await _leaveRepo.GetByUserIdAsync(userId);\n    var instanceCodes = leaves.Select(l =&gt; l.InstanceCode).ToList();\n\n    // 批量查询审批记录\n    var approvals = await _approvalRepo.GetByInstanceCodesAsync(instanceCodes);\n\n    var result = leaves.Select(leave =&gt;\n    {\n        var approval = approvals.FirstOrDefault(a =&gt; a.InstanceCode == leave.InstanceCode);\n\n        return new LeaveRequestDto\n        {\n            Id = leave.Id,\n            StartTime = leave.StartTime,\n            EndTime = leave.EndTime,\n            Days = leave.Days,\n            Status = leave.Status.ToString(),\n            ApprovalStatus = approval?.Status ?? \"UNKNOWN\",\n            FeishuInstanceUrl = !string.IsNullOrEmpty(approval?.InstanceCode)\n                ? $\"https://www.feishu.cn/approval/approval/view/{approval.InstanceCode}\"\n                : null,\n            CreatedTime = leave.CreatedTime\n        };\n    }).ToList();\n\n    return result;\n}\n</code></pre>\n<h4 id=\"添加在飞书中查看链接\">添加\"在飞书中查看\"链接</h4>\n<p>在列表页添加操作按钮：</p>\n<pre><code class=\"language-html\">&lt;!-- 前端页面示例 --&gt;\n&lt;table class=\"leave-list\"&gt;\n    &lt;thead&gt;\n        &lt;tr&gt;\n            &lt;th&gt;开始时间&lt;/th&gt;\n            &lt;th&gt;结束时间&lt;/th&gt;\n            &lt;th&gt;天数&lt;/th&gt;\n            &lt;th&gt;审批状态&lt;/th&gt;\n            &lt;th&gt;操作&lt;/th&gt;\n        &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody&gt;\n        @foreach (var leave in Model.Leaves)\n        {\n            &lt;tr&gt;\n                &lt;td&gt;@leave.StartTime.ToString(\"yyyy-MM-dd\")&lt;/td&gt;\n                &lt;td&gt;@leave.EndTime.ToString(\"yyyy-MM-dd\")&lt;/td&gt;\n                &lt;td&gt;@leave.Days&lt;/td&gt;\n                &lt;td&gt;\n                    &lt;span class=\"status @leave.ApprovalStatus\"&gt;\n                        @GetStatusText(leave.ApprovalStatus)\n                    &lt;/span&gt;\n                &lt;/td&gt;\n                &lt;td&gt;\n                    @if (!string.IsNullOrEmpty(leave.FeishuInstanceUrl))\n                    {\n                        &lt;a href=\"@leave.FeishuInstanceUrl\" target=\"_blank\" class=\"btn\"&gt;\n                            在飞书中查看\n                        &lt;/a&gt;\n                    }\n                &lt;/td&gt;\n            &lt;/tr&gt;\n        }\n    &lt;/tbody&gt;\n&lt;/table&gt;\n</code></pre>\n<h4 id=\"联调测试\">联调测试</h4>\n<table>\n<thead>\n<tr>\n<th>测试场景</th>\n<th>验证要点</th>\n<th>测试工具</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>发起审批</strong></td>\n<td>飞书是否收到审批通知、表单数据是否正确</td>\n<td>直接在系统发起</td>\n</tr>\n<tr>\n<td><strong>审批流程</strong></td>\n<td>各审批节点是否正确流转</td>\n<td>飞书管理后台</td>\n</tr>\n<tr>\n<td><strong>回调接收</strong></td>\n<td>Webhook是否正确接收事件、数据是否完整</td>\n<td>飞书\"模拟事件推送\"工具</td>\n</tr>\n<tr>\n<td><strong>状态同步</strong></td>\n<td>业务状态是否正确更新、通知是否发送</td>\n<td>数据库查询、日志查看</td>\n</tr>\n<tr>\n<td><strong>异常处理</strong></td>\n<td>网络异常、签名验证失败等边界情况</td>\n<td>模拟异常场景</td>\n</tr>\n</tbody>\n</table>\n<p><strong>飞书模拟事件推送工具</strong>：</p>\n<p>在飞书开放平台的\"事件订阅\"页面，可以使用\"模拟事件推送\"功能测试 Webhook 接口：</p>\n<div class=\"mermaid\">graph LR\n    A[飞书管理后台] --&gt;|模拟事件推送| B[Webhook接口]\n    B --&gt;|日志输出| C[检查处理结果]\n    C --&gt;|成功| D[验证完成]\n    C --&gt;|失败| E[查看错误日志]\n</div><hr />\n<h2 id=\"生产级注意事项\">生产级注意事项</h2>\n<h3 id=\"安全与可靠性\">安全与可靠性</h3>\n<h4 id=\"机密管理\">机密管理</h4>\n<p><strong>切勿将敏感信息硬编码在代码中！</strong></p>\n<pre><code class=\"language-csharp\">// ❌ 错误示例\nvar appSecret = \"cli_xxxxxxxxxxxxxxx\";  // 危险！\n\n// ✅ 正确示例\nbuilder.Configuration.AddAzureKeyVault(\n    new Uri($\"https://{vaultName}.vault.azure.net/\"),\n    new DefaultAzureCredential());\n\nvar appSecret = builder.Configuration[\"Feishu:AppSecret\"];\n</code></pre>\n<p><strong>推荐方案</strong>：</p>\n<ul>\n<li>Azure Key Vault / AWS Secrets Manager</li>\n<li>HashiCorp Vault</li>\n<li>Docker Secrets（容器化部署）</li>\n</ul>\n<h4 id=\"幂等性处理\">幂等性处理</h4>\n<p>飞书可能会重复推送同一个事件（网络重试等），必须保证业务逻辑的幂等性：</p>\n<pre><code class=\"language-csharp\">public async Task HandleAsync(EventData eventData, CancellationToken cancellationToken = default)\n{\n    // 使用 EventId 或 instance_code + status 组合作为幂等键\n    var idempotencyKey = $\"{approvalEvent.InstanceCode}_{approvalEvent.Status}\";\n\n    // 检查是否已处理过\n    if (await _cache.ExistsAsync(idempotencyKey))\n    {\n        _logger.LogInformation(\"事件已处理过，跳过: Key={IdempotencyKey}\", idempotencyKey);\n        return;\n    }\n\n    // 标记为已处理（设置过期时间，如24小时）\n    await _cache.SetAsync(idempotencyKey, \"1\", TimeSpan.FromHours(24));\n\n    // 执行业务逻辑\n    await ProcessEventAsync(approvalEvent, cancellationToken);\n}\n</code></pre>\n<h4 id=\"api-容错\">API 容错</h4>\n<p>使用 Polly 为飞书 API 调用添加重试和熔断机制：</p>\n<pre><code class=\"language-csharp\">// 注册 HttpClient 时添加 Polly 策略\nbuilder.Services.AddHttpClient(\"Feishu\")\n    .AddTransientHttpErrorPolicy(p =&gt;\n        p.WaitAndRetryAsync(3, retryAttempt =&gt;\n            TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))))\n    .AddPolicyHandler(Policy&lt;HttpResponseMessage&gt;\n        .Handle&lt;HttpRequestException&gt;()\n        .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30)));\n</code></pre>\n<h3 id=\"边界情况与优雅降级\">边界情况与优雅降级</h3>\n<h4 id=\"审批人失效处理\">审批人失效处理</h4>\n<pre><code class=\"language-csharp\">// 飞书审批定义中配置默认审批人\nvar request = new CreateInstanceRequest\n{\n    ApprovalCode = \"xxxx\",\n    // 如果自选审批人为空，使用默认审批人\n    NodeApproverUserIdLists = dto.ApproverUserId.HasValue\n        ? new[] { new NodeApprover { NodeId = \"node1\", ApproverUserIds = new[] { dto.ApproverUserId.Value } } }\n        : null  // 走默认审批人流程\n};\n</code></pre>\n<h4 id=\"网络超时与异步处理\">网络超时与异步处理</h4>\n<p>回调处理应快速响应飞书（建议在 3 秒内），复杂逻辑移至后台作业：</p>\n<pre><code class=\"language-csharp\">public async Task HandleAsync(EventData eventData, CancellationToken cancellationToken = default)\n{\n    // 1. 快速保存事件到队列\n    await _eventQueue.EnqueueAsync(eventData);\n\n    // 2. 立即返回，由后台作业处理\n    // Hangfire、RabbitMQ 等会异步消费队列\n    await Task.CompletedTask;\n}\n\n// 后台作业处理\n[Queue(\"approval-callback\")]\npublic async Task ProcessApprovalEventAsync(EventData eventData)\n{\n    // 复杂的业务逻辑处理\n    await _approvalService.ProcessCallbackAsync(eventData);\n}\n</code></pre>\n<h4 id=\"监控与告警\">监控与告警</h4>\n<p>建立关键节点的监控：</p>\n<pre><code class=\"language-csharp\">// 监控指标\npublic class ApprovalMetrics\n{\n    private readonly Counter _approvalCreatedCounter;\n    private readonly Counter _callbackReceivedCounter;\n    private readonly Histogram _processingTimeHistogram;\n\n    public void RecordApprovalCreated(string approvalType)\n    {\n        _approvalCreatedCounter.WithLabels(approvalType).Inc();\n    }\n\n    public void RecordCallbackReceived(string status)\n    {\n        _callbackReceivedCounter.WithLabels(status).Inc();\n    }\n\n    public void RecordProcessingTime(TimeSpan duration)\n    {\n        _processingTimeHistogram.Observe(duration.TotalSeconds);\n    }\n}\n\n// 告警规则（Prometheus 示例）\n# 审批发起失败率超过 5% 触发告警\nalert: ApprovalCreationFailureRate\nexpr: rate(approval_creation_failed_total[5m]) / rate(approval_creation_total[5m]) &gt; 0.05\nfor: 5m\nannotations:\n  summary: \"审批创建失败率过高\"\n</code></pre>\n<h3 id=\"扩展性与维护性\">扩展性与维护性</h3>\n<h4 id=\"策略模式支持多平台\">策略模式支持多平台</h4>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 审批平台策略接口\n/// &lt;/summary&gt;\npublic interface IApprovalPlatformStrategy\n{\n    string PlatformName { get; }\n    Task&lt;string&gt; CreateInstanceAsync(ApprovalRequest request);\n}\n\n/// &lt;summary&gt;\n/// 飞书审批策略\n/// &lt;/summary&gt;\npublic class FeishuApprovalStrategy : IApprovalPlatformStrategy\n{\n    public string PlatformName =&gt; \"Feishu\";\n    // ... 实现\n}\n\n/// &lt;summary&gt;\n/// 钉钉审批策略\n/// &lt;/summary&gt;\npublic class DingTalkApprovalStrategy : IApprovalPlatformStrategy\n{\n    public string PlatformName =&gt; \"DingTalk\";\n    // ... 实现\n}\n\n/// &lt;summary&gt;\n/// 审批策略工厂\n/// &lt;/summary&gt;\npublic class ApprovalStrategyFactory\n{\n    private readonly IEnumerable&lt;IApprovalPlatformStrategy&gt; _strategies;\n\n    public IApprovalPlatformStrategy GetStrategy(string platformName)\n    {\n        return _strategies.FirstOrDefault(s =&gt; s.PlatformName == platformName)\n            ?? throw new NotSupportedException($\"不支持的审批平台: {platformName}\");\n    }\n}\n</code></pre>\n<h4 id=\"审计日志\">审计日志</h4>\n<p>详细记录审批流转换的关键日志：</p>\n<pre><code class=\"language-csharp\">public class ApprovalAuditService\n{\n    private readonly IApprovalAuditRepository _auditRepo;\n\n    public async Task LogAsync(ApprovalAuditLog log)\n    {\n        log.Timestamp = DateTime.UtcNow;\n        await _auditRepo.AddAsync(log);\n        await _auditRepo.SaveChangesAsync();\n\n        // 结构化日志输出\n        _logger.LogInformation(\"审批审计: {AuditType}, InstanceCode={InstanceCode}, BusinessId={BusinessId}\",\n            log.AuditType, log.InstanceCode, log.BusinessId);\n    }\n}\n\n// 使用示例\nawait _auditService.LogAsync(new ApprovalAuditLog\n{\n    AuditType = \"ApprovalStarted\",\n    InstanceCode = instanceCode,\n    BusinessId = leaveRequest.Id,\n    OperatorId = userId,\n    Details = new { leaveType, days, reason }\n});\n</code></pre>\n<hr />\n<h2 id=\"最后一点内容\">最后一点内容</h2>\n<h3 id=\"核心价值\">核心价值</h3>\n<p>通过本文的实践，我们成功实现了：</p>\n<table>\n<thead>\n<tr>\n<th>价值点</th>\n<th>实现方式</th>\n<th>收益</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>移动化审批</strong></td>\n<td>飞书 App 作为审批门户</td>\n<td>随时随地处理审批</td>\n</tr>\n<tr>\n<td><strong>即时通知</strong></td>\n<td>飞书强通知机制</td>\n<td>审批人及时响应</td>\n</tr>\n<tr>\n<td><strong>数据闭环</strong></td>\n<td>.NET 业务库 + 审批关联表</td>\n<td>完整的业务流程追踪</td>\n</tr>\n<tr>\n<td><strong>解耦设计</strong></td>\n<td>领域层抽象 + 策略模式</td>\n<td>便于扩展和维护</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"全文总结\">全文总结</h3>\n<p>本文提供了一个从理念、设计到编码落地的完整闭环：</p>\n<div class=\"mermaid\">mindmap\n  root((飞书审批集成))\n    理念\n      双向集成\n      .NET为业务核心\n      飞书为流程门户\n    设计\n      分层架构\n      领域抽象\n      安全机制\n    实现\n      发起审批\n      回调处理\n      状态同步\n    最佳实践\n      机密管理\n      幂等性\n      异步处理\n      监控告警\n</div><h3 id=\"扩展\">扩展</h3>\n<h4 id=\"场景扩展\">场景扩展</h4>\n<p>将此模式快速复用于其他业务场景：</p>\n<table>\n<thead>\n<tr>\n<th>业务场景</th>\n<th>审批流程</th>\n<th>复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>报销审批</strong></td>\n<td>发起 → 直属主管 → 财务审核</td>\n<td>中</td>\n</tr>\n<tr>\n<td><strong>采购申请</strong></td>\n<td>发起 → 部门主管 → 采购部 → 总经理</td>\n<td>高</td>\n</tr>\n<tr>\n<td><strong>合同审批</strong></td>\n<td>法务审核 → 财务审核 → 总经理</td>\n<td>高</td>\n</tr>\n<tr>\n<td><strong>加班申请</strong></td>\n<td>直属主管审批</td>\n<td>低</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"深度集成\">深度集成</h4>\n<p>利用飞书更多能力，打造更丰富的协同体验：</p>\n<div class=\"mermaid\">graph TB\n    A[飞书审批] --&gt; B[消息卡片]\n    A --&gt; C[智能机器人]\n    A --&gt; D[知识库]\n\n    B --&gt; B1[审批详情展示]\n    B --&gt; B2[操作按钮]\n    C --&gt; C1[智能提醒]\n    C --&gt; C2[自动补全]\n    D --&gt; D1[历史记录查询]\n    D --&gt; D2[审批规范]\n\n    E[.NET系统] --&gt; A\n    B --&gt; E\n    C --&gt; E\n    D --&gt; E\n</div><p><strong>功能扩展示例</strong>：</p>\n<ul>\n<li>在飞书群聊中通过消息卡片直接查看审批详情</li>\n<li>通过机器人智能回复，引导用户填写审批表单</li>\n<li>将审批记录同步到飞书知识库，方便查阅</li>\n</ul>\n<h4 id=\"平台化\">平台化</h4>\n<p>将审批集成能力抽象为中台服务，供企业内部所有系统统一调用：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 统一审批服务中台\n/// &lt;/summary&gt;\npublic interface IApprovalCenterService\n{\n    /// &lt;summary&gt;\n    /// 统一发起审批（支持多平台）\n    /// &lt;/summary&gt;\n    Task&lt;string&gt; CreateApprovalAsync(UnifiedApprovalRequest request);\n\n    /// &lt;summary&gt;\n    /// 查询审批状态\n    /// &lt;/summary&gt;\n    Task&lt;ApprovalStatus&gt; GetStatusAsync(string instanceId);\n\n    /// &lt;summary&gt;\n    /// 审批统计报表\n    /// &lt;/summary&gt;\n    Task&lt;ApprovalStatistics&gt; GetStatisticsAsync(DateTime from, DateTime to);\n}\n\n// 多个系统统一调用\nawait _approvalCenter.CreateApprovalAsync(new UnifiedApprovalRequest\n{\n    BusinessSystem = \"HR\",\n    BusinessType = \"LeaveRequest\",\n    BusinessId = leaveId,\n    Platform = \"Feishu\"  // 可切换到其他平台\n});\n</code></pre>\n<hr />\n<p><strong>结语</strong></p>\n<p>传统 .NET 系统无需推倒重来，通过合理的架构设计与飞书审批的深度集成，同样可以焕发新的活力。希望本文的实践能够为你的数字化转型之路提供有价值的参考。</p>\n<p>让我们一起告别信息孤岛，拥抱现代化的协同办公体验！🚀</p>\n<hr />\n<h2 id=\"相关资源\">相关资源</h2>\n<h3 id=\"项目地址\">项目地址</h3>\n<ul>\n<li>\n<p><strong>Gitee 仓库</strong>：<a href=\"https://gitee.com/mudtools/MudFeishu\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/mudtools/MudFeishu</a></p>\n</li>\n<li>\n<p><strong>GitHub 仓库</strong>：<a href=\"https://github.com/mudtools/MudFeishu\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/mudtools/MudFeishu</a></p>\n</li>\n<li>\n<p><strong>NuGet 包</strong>：</p>\n<ul>\n<li>\n<p><a href=\"https://www.nuget.org/packages/Mud.Feishu.Abstractions/\" rel=\"noopener nofollow\" target=\"_blank\">Mud.Feishu.Abstractions</a></p>\n</li>\n<li>\n<p><a href=\"https://www.nuget.org/packages/Mud.Feishu/\" rel=\"noopener nofollow\" target=\"_blank\">Mud.Feishu</a></p>\n</li>\n<li>\n<p><a href=\"https://www.nuget.org/packages/Mud.Feishu.WebSocket/\" rel=\"noopener nofollow\" target=\"_blank\">Mud.Feishu.WebSocket</a></p>\n</li>\n<li>\n<p><a href=\"https://www.nuget.org/packages/Mud.Feishu.Webhook/\" rel=\"noopener nofollow\" target=\"_blank\">Mud.Feishu.Webhook</a></p>\n</li>\n</ul>\n</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 22:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/mudtools\">玩泥巴的|mudtools.cn</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【面试题】MySQL 三层 B+ 树能存多少数据？",
      "link": "https://www.cnblogs.com/sun-10387834/p/19388703",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19388703\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 18:57\">\n    <span>【面试题】MySQL 三层 B+ 树能存多少数据？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>这是一个经典的面试题，但实际估算需要考虑多个变量。下面我将详细拆解计算过程：</p>\n<h2 id=\"核心计算模型\"><strong>核心计算模型</strong></h2>\n<p>MySQL B+树存储量 = 根节点扇出 × 中间节点扇出 × 叶子节点容量</p>\n<hr />\n<h2 id=\"关键假设以innodb默认配置为例\"><strong>关键假设（以InnoDB默认配置为例）</strong></h2>\n<ol>\n<li><strong>页大小</strong>：16KB（16384字节）</li>\n<li><strong>主键类型</strong>：BIGINT（8字节）</li>\n<li><strong>指针大小</strong>：6字节（InnoDB页指针）</li>\n<li><strong>行数据大小</strong>：1KB（1024字节） - <em>这是关键变量</em></li>\n<li><strong>页空间利用率</strong>：约70%（需扣除页头、页尾等元数据）</li>\n</ol>\n<hr />\n<h2 id=\"三层b树结构\"><strong>三层B+树结构</strong></h2>\n<pre><code>第1层：根节点（1个）\n第2层：中间节点（fan_out个）\n第3层：叶子节点（fan_out²个） ← 存储实际数据\n</code></pre>\n<hr />\n<h2 id=\"详细计算步骤\"><strong>详细计算步骤</strong></h2>\n<h3 id=\"1-计算单个非叶子节点能存储的键值对数量fan_out\"><strong>1. 计算单个非叶子节点能存储的键值对数量（fan_out）</strong></h3>\n<p>每个索引项大小 = 主键(8B) + 指针(6B) = 14B<br />\n可用空间 = 16KB × 70% = 11.2KB ≈ 11468字节<br />\n单个节点索引项数 = 11468 / 14 ≈ <strong>819</strong></p>\n<p>即：<strong>每个非叶子节点可指向约819个子节点</strong></p>\n<h3 id=\"2-计算单个叶子节点能存储的数据行数\"><strong>2. 计算单个叶子节点能存储的数据行数</strong></h3>\n<p>可用空间 = 16KB × 70% = 11.2KB<br />\n假设每行数据1KB → 每页约存储 <strong>11行</strong><br />\n假设每行数据200字节 → 每页约存储 <strong>57行</strong><br />\n假设每行数据800字节 → 每页约存储 <strong>14行</strong></p>\n<h3 id=\"3-三层b树总容量计算\"><strong>3. 三层B+树总容量计算</strong></h3>\n<p><strong>公式</strong>：总行数 = fan_out² × 每页行数</p>\n<ul>\n<li>若每页11行：819² × 11 ≈ <strong>730万行</strong></li>\n<li>若每页57行：819² × 57 ≈ <strong>3800万行</strong></li>\n<li>若每页14行：819² × 14 ≈ <strong>940万行</strong></li>\n</ul>\n<hr />\n<h2 id=\"更精确的估算考虑真实innodb结构\"><strong>更精确的估算（考虑真实InnoDB结构）</strong></h2>\n<p>实际InnoDB叶子节点存储的是完整数据行，需要考虑：</p>\n<ul>\n<li>行格式开销（行头约23字节）</li>\n<li>事务系统开销（MVCC的隐藏列：DB_TRX_ID 6B + DB_ROLL_PTR 7B）</li>\n<li>可能的NULL位图、变长字段列表等</li>\n</ul>\n<p><strong>保守估算</strong>：<br />\n假设主键为BIGINT，每行额外开销约50字节：</p>\n<ul>\n<li>行大小 = 数据(1024B) + 行开销(50B) = 1074B</li>\n<li>每页行数 = (16384×70%) / 1074 ≈ 10行</li>\n<li>总行数 = 819² × 10 ≈ <strong>670万行</strong></li>\n</ul>\n<hr />\n<h2 id=\"场景分析表\"><strong>场景分析表</strong></h2>\n<table>\n<thead>\n<tr>\n<th>行大小</th>\n<th>每页行数</th>\n<th>三层B+树容量</th>\n<th>四层B+树容量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200B（小记录）</td>\n<td>~57行</td>\n<td>约3800万行</td>\n<td>约310亿行</td>\n</tr>\n<tr>\n<td>1KB（典型记录）</td>\n<td>~10行</td>\n<td>约670万行</td>\n<td>约55亿行</td>\n</tr>\n<tr>\n<td>2KB（较大记录）</td>\n<td>~5行</td>\n<td>约335万行</td>\n<td>约27亿行</td>\n</tr>\n<tr>\n<td>8KB（大记录）</td>\n<td>~1行</td>\n<td>约67万行</td>\n<td>约5.5亿行</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"重要说明\"><strong>重要说明</strong></h2>\n<ol>\n<li>\n<p><strong>实际容量可能更大</strong>：</p>\n<ul>\n<li>若使用INT主键（4字节），fan_out ≈ 1365，容量提升近3倍</li>\n<li>若行记录更紧凑，每页存储行数更多</li>\n</ul>\n</li>\n<li>\n<p><strong>B+树层数增长</strong>：</p>\n<ul>\n<li>当数据量超过三层容量时，B+树变为四层</li>\n<li>四层B+树容量 = fan_out³ × 每页行数</li>\n<li>对于1KB行，四层B+树可存储约 <strong>55亿行</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>聚簇索引 vs 二级索引</strong>：</p>\n<ul>\n<li>上述计算针对<strong>聚簇索引</strong>（叶子节点存完整数据）</li>\n<li>二级索引叶子节点存储主键值，容量会更大</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h2 id=\"结论\"><strong>结论</strong></h2>\n<p>在典型的配置下（BIGINT主键、1KB行数据）：</p>\n<ul>\n<li><strong>三层B+树大约能存储600万～1000万行数据</strong></li>\n<li><strong>四层B+树可存储数十亿行数据</strong></li>\n</ul>\n<p>这也是为什么我们常说：</p>\n<ul>\n<li>单表千万级别数据时，查询性能仍能保持良好（三层B+树）</li>\n<li>数据量过亿时，可能需要考虑分库分表或优化索引设计</li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19388703\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19388703</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 18:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （一）序列数据与序列模型",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19437798",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19437798\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 18:52\">\n    <span>吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （一）序列数据与序列模型</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第一周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=151\" rel=\"noopener nofollow\" target=\"_blank\">1.1</a>的内容以及一些基础的补充。</p>\n<hr />\n<p>本周为第五课的第一周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本篇的内容关于<strong>序列数据和序列模型</strong>，是自然语言处理中基础内容。</p>\n<h1 id=\"1-序列数据\">1. 序列数据</h1>\n<p>在 NLP 中，一个最基础、也最核心的问题是：<strong>语言数据，和我们之前见过的数据，有什么本质不同？</strong><br />\n答案可以简单概括为：<strong>它是有顺序的。</strong></p>\n<p>在机器学习中，我们把 <strong>”顺序本身携带信息”</strong> 的数据称为<strong>序列数据</strong>。<br />\n最直观的例子就是一句话，同样是这几个词：</p>\n<blockquote>\n<p>“我 吃 饭”<br />\n“饭 吃 我”</p>\n</blockquote>\n<p>包含的词完全一样，但表达的含义却天差地别，这说明：<strong>在语言中，信息不仅存在于“有哪些元素”，还存在于“元素出现的顺序”。</strong></p>\n<p>这与我们之前在 CV 中常见的数据有所不同。<br />\n一张图像在进入模型之前，通常已经被表示为一个<strong>固定尺寸的二维像素网格</strong>。<br />\n无论我们先看左上角还是右下角，<strong>整幅图像的所有信息在输入时是同时存在的</strong>，模型面对的是一个“完整画面”。<br />\n在这种设定下，卷积网络更关注的是<strong>空间结构关系</strong>：哪些像素彼此相邻、哪些局部区域可以组成更高层的形状。</p>\n<p>而语言数据的形式则不同，一句话并不是一个天然的“整体对象”，而是由词语<strong>按顺序依次出现</strong>的。<br />\n简单来说：在按序建模的假设下，模型对当前词的理解，往往依赖于<strong>之前已经出现的所有词所构成的上下文</strong>。</p>\n<p>需要说明的是，这里的“按顺序”并不一定意味着模型必须<strong>像人一样一个词一个词地读</strong>。<br />\n在后续将要介绍的 <strong>Transformer</strong> 模型中，整句话的所有词可以被<strong>同时送入模型进行处理</strong>，但模型仍然需要通过<strong>显式地引入位置信息</strong>，来区分“哪个词在前、哪个词在后”。</p>\n<p>再打个比方：<br />\n图像更像是一张<strong>已经摊开在桌面上的地图</strong>，所有信息一眼都在，模型在处理时不依赖显式的时间顺序，而是直接建模整体的空间结构关系。<br />\n而语言更像是一段<strong>正在播放的语音或文字流</strong>，我们从哪里听，哪里看，结果是截然不同的。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260104144013115-1425405995.png\" /><br />\n因此，在语言任务中，“先出现什么、后出现什么”本身就构成了信息的一部分，而不能被随意打乱<br />\n正因为这种差异，让CV 模型更擅长处理<strong>空间结构与局部模式</strong>，而 NLP 模型必须重点解决<strong>顺序、依赖关系以及上下文记忆</strong>的问题。</p>\n<p>我们总结语言、语音、时间等序列数据的特征如下：</p>\n<ol>\n<li>数据是<strong>按顺序排列</strong>的。</li>\n<li>当前信息往往依赖于<strong>之前已经出现的内容</strong>。</li>\n<li>数据长度通常<strong>不固定</strong>。</li>\n</ol>\n<p>这些特征决定了：<strong>在处理序列数据时，模型必须显式地考虑顺序与上下文，而不能仅把输入当作一个无序的特征集合来处理。</strong></p>\n<h1 id=\"2-序列模型\">2. 序列模型</h1>\n<p>我们分别看看，如果使用我们已经了解过的<strong>全连接网络</strong>和<strong>卷积网络</strong>来处理序列数据，效果会怎么样。</p>\n<h2 id=\"21-全连接网络无法自然处理顺序\">2.1 全连接网络：无法自然处理“顺序”</h2>\n<p>如果要应用全连接网络，最直接的想法是：  把一句话中的每个词表示成向量，再把这些向量<strong>拼接成一个长向量</strong>，送进全连接网络。</p>\n<p>这种做法在形式上是可行的，但问题也非常明显：<br />\n首先，全连接网络要求<strong>固定长度输入</strong>，而语言序列的长度是天然不固定的。<br />\n一句话可以只有几个词，也可以非常长。为了满足输入要求，我们不得不进行截断或填充，这本身就引入了额外的工程复杂度。</p>\n<p>其次，更关键的是：<strong>全连接网络并不具备“顺序感知”能力</strong>。在它看来，输入只是一个高维向量，各个维度之间没有“先后”这一概念。<br />\n模型本身并不知道：“这是第一个词”“这是第三个词”。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260104144012968-399183777.png\" /></p>\n<p>因此，这种处理方式天然忽略了语言中最重要的结构信息——顺序与依赖关系。不能用来处理序列数据。</p>\n<h2 id=\"22-卷积网络擅长局部模式但缺乏长期依赖\">2.2 卷积网络：擅长局部模式，但缺乏长期依赖</h2>\n<p>那卷积网络呢？  既然 CNN 能在图像中建模局部结构，是否也可以用于序列数据？<br />\n答案是：<strong>部分可以，但不够自然。</strong></p>\n<p>在序列上使用一维卷积时，卷积核可以捕捉<strong>局部连续片段</strong>，例如相邻几个词构成的短语或固定搭配。 从这个角度看，CNN 确实能够建模<strong>局部上下文信息</strong>。</p>\n<p>在这里，我们需要引入一个概念：<strong>感受野（receptive field）</strong>。<br />\n感受野指的是卷积层中某个神经元<strong>能够“看到”的输入区域范围</strong>。<br />\n打个比方：</p>\n<ul>\n<li>在图像中，如果一个卷积神经元的感受野是 <span class=\"math inline\">\\(3\\times3\\)</span>，它只能感知这九个像素的局部信息；</li>\n<li>类似地，在序列上，一个卷积核的感受野就是它<strong>一次性能看到的连续词的数量</strong>。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260104144316440-1063086196.png\" /><br />\n这就意味着，卷积网络在处理序列时天然擅长捕捉<strong>局部模式或短距离依赖</strong>，但如果想让模型理解“句首的词”与“句尾的词”之间的关系，就必须<strong>堆叠很多层卷积</strong>或<strong>人为扩大卷积核范围</strong>，才能覆盖整个序列。<br />\n简单来说，感受野越大，模型越容易捕捉<strong>长距离依赖</strong>，但这也带来了计算和训练上的问题。<br />\n这使得模型：</li>\n<li>对<strong>短距离依赖</strong>敏感。</li>\n<li>对<strong>长距离依赖</strong>不够高效。</li>\n<li>并且仍然缺乏一种明确的“时间状态”概念。</li>\n</ul>\n<p>可以这样理解：<br />\n卷积网络更像是在<strong>扫描局部片段</strong>，而不是在<strong>沿着时间轴逐步理解一句话的发展过程</strong>，因此，虽然卷积对序列数据的处理能力强于全连接网络，但是它仍有所局限。</p>\n<h2 id=\"23-序列模型要解决的核心问题\">2.3 序列模型要解决的核心问题</h2>\n<p>通过以上对比可以看到，全连接网络和卷积网络并不是“不能”处理序列数据，而是<strong>处理方式与序列数据的本质存在冲突</strong>。</p>\n<p>序列数据的核心特点在于：信息是<strong>随顺序逐步展开的</strong>、当前理解依赖于<strong>历史上下文</strong>且序列长度<strong>不固定</strong>。<br />\n因此，我们真正需要的是这样一类模型：  <strong>在处理当前输入的同时，能够保留并更新对“过去信息”的表示。</strong><br />\n也就是说，序列模型的核心能力并不在于“输入形式”，  而在于它是否具备一种<strong>可随时间演化的内部状态</strong>，用来承载上下文信息，并参与后续决策。<br />\n后续我们将看到的 RNN、LSTM、GRU 以及 Transformer，  虽然实现方式不同，但都围绕着同一个目标展开：  <strong>让模型在理解当前内容时，不是孤立地“看这一刻”，而是基于整个上下文来判断。</strong></p>\n<p>这就是序列模型所具备的能力。</p>\n<h1 id=\"3-序列模型的应用领域\">3. 序列模型的应用领域</h1>\n<p>序列模型在 NLP 中应用广泛，但需要注意的是：<strong>序列模型不一定要求输入和输出都是序列</strong>。它的核心能力在于能够<strong>保留上下文信息并处理随时间展开的数据</strong>。只要输入或输出中存在序列性质，序列模型就能发挥作用。<br />\n从输入和输出的角度，可以分为以下几类情况：</p>\n<ol>\n<li><strong>序列→序列：</strong> 输入和输出都是序列，例如机器翻译。模型需要根据输入序列的上下文生成对应的输出序列。</li>\n<li><strong>序列→标量或类别：</strong> 输入是序列，输出是单个值或类别，例如情感分析、文本分类。模型需要理解整段序列的语义，并输出整体判断。</li>\n<li><strong>标量或固定输入→序列：</strong> 输入不是序列，但模型需要生成序列作为输出，例如文本生成或对话系统中根据提示生成完整回答。</li>\n</ol>\n<p>由此可见，序列模型的核心能力不是“必须处理序列输入或输出”，而是<strong>能够在处理过程中维护上下文信息</strong>。<br />\n来看看序列模型的一些常见应用领域：</p>\n<table>\n<thead>\n<tr>\n<th>任务</th>\n<th>输入类型</th>\n<th>输出类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>文本分类</td>\n<td>序列</td>\n<td>类别</td>\n<td>如情感分析、新闻分类，理解整段文本并输出单一标签</td>\n</tr>\n<tr>\n<td>命名实体识别 (NER)</td>\n<td>序列</td>\n<td>序列</td>\n<td>对每个词进行标注，如“人名”“地名”等</td>\n</tr>\n<tr>\n<td>机器翻译</td>\n<td>序列</td>\n<td>序列</td>\n<td>将源语言句子转换为目标语言句子</td>\n</tr>\n<tr>\n<td>文本生成</td>\n<td>序列或标量</td>\n<td>序列</td>\n<td>根据输入文本或提示生成完整文本</td>\n</tr>\n<tr>\n<td>语音识别</td>\n<td>序列</td>\n<td>序列</td>\n<td>将语音信号转为文字序列</td>\n</tr>\n<tr>\n<td>问答系统</td>\n<td>序列</td>\n<td>序列或标量</td>\n<td>根据问题生成答案，答案可以是短文本或单一类别</td>\n</tr>\n<tr>\n<td>时间序列预测</td>\n<td>序列</td>\n<td>序列或标量</td>\n<td>如股价预测，根据历史序列预测未来数值</td>\n</tr>\n</tbody>\n</table>\n<p>通过这个分类，可以清晰地看到：<strong>序列模型的核心是处理顺序和上下文，不必限制输入输出都为序列</strong>。只要有序列信息存在，它就可以发挥价值。</p>\n<h1 id=\"4-总结\">4. 总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>序列数据</td>\n<td>数据元素按顺序排列，当前理解依赖历史上下文，长度不固定</td>\n<td>图像像摊开的地图，一眼可见整体；语言像正在播放的语音或文字流，需要顺序感知</td>\n</tr>\n<tr>\n<td>全连接网络处理序列</td>\n<td>只能接受固定长度输入，无法天然感知顺序</td>\n<td>只是把所有词拼成一个长向量，模型看不到先后顺序</td>\n</tr>\n<tr>\n<td>卷积网络处理序列</td>\n<td>能捕捉局部连续模式（短距离依赖），感受野有限，长距离依赖不高效</td>\n<td>卷积像扫描局部片段，而不是沿时间轴理解整句话的发展</td>\n</tr>\n<tr>\n<td>感受野 (Receptive Field)</td>\n<td>一个卷积神经元一次能够看到的输入区域</td>\n<td>图像：3×3像素只能看到局部；序列：卷积核一次看到几个连续词</td>\n</tr>\n<tr>\n<td>序列模型核心能力</td>\n<td>通过可随时间演化的内部状态，保留并更新上下文信息，理解当前输入时考虑历史信息</td>\n<td>模型像带记忆的阅读者，理解每个词时参考整段上下文</td>\n</tr>\n<tr>\n<td>输入/输出类型灵活性</td>\n<td>序列模型不要求输入输出都为序列，只要一方为序列即可发挥作用</td>\n<td>输入是流，输出是判断或生成，模型记忆历史信息</td>\n</tr>\n<tr>\n<td>序列模型应用</td>\n<td>NLP、语音、时间序列等领域，如文本分类、NER、机器翻译、文本生成、语音识别、问答、时间序列预测</td>\n<td>依赖上下文信息，模型像“顺序感知器”，根据过去信息做当前决策</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 18:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "NVIDIA CUDA 高性能计算笔记（一）cuda编程简介及矩阵赋值案例",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19444388",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19444388\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 18:33\">\n    <span>NVIDIA CUDA 高性能计算笔记（一）cuda编程简介及矩阵赋值案例</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        CUDA （Compute  Unified Device Architecture）是NIVIDIA 推出的通用并行计算平台，支持C，C++，Python等语言，实现CPU和GPU协同计算。其架构采用Grid-Blocks-Threads线程层次结构和SIMT并行模式，在给出CUDA的编程实例之前，需要给出模型的基础知识做个简单的介绍。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"nvidia-cuda-高性能计算笔记一\">NVIDIA CUDA 高性能计算笔记（一）</h1>\n<p>​       CUDA （Compute  Unified Device Architecture）是NIVIDIA 推出的通用并行计算平台，支持C，C++，Python等语言，实现CPU和GPU协同计算。其架构采用Grid-Blocks-Threads线程层次结构和SIMT并行模式，在给出CUDA的编程实例之前，需要给出模型的基础知识做个简单的介绍。</p>\n<h2 id=\"11cuda编程模型简介\">1.1CUDA编程模型简介</h2>\n<p>​      CUDA编程模型是一个异构模型，需要GPU和CPU协同工作。在CUDA架构中，我们用host端指代CPU及其内存的，用device指代GPU及其内存。CUDA程序中即包含Host程序，又包含device程序，它们分别在CPU与GPU上运行。同时，host与device之间进行通信，这样它们之间可以进行数据拷贝。典型的CUDA程序的执行的程序的流程为：</p>\n<ol>\n<li>分配host内存，并进行数据初始化；</li>\n<li>分配device内存（显存、共享内存），并从host端将数据拷贝到device端；</li>\n<li>调用CUDA的核函数在device函数上完成指定的运算；</li>\n<li>将device上的运算结果拷贝到host上；</li>\n<li>释放device和host上分配的内存。</li>\n</ol>\n<p>​        由于CUDA编程模型实际上是异构编程模型，所以需要区分host和device上的代码，在CUDA中是通过函数类型限定词区别开host和device上的函数，主要的三个函数类型限定词如下：</p>\n<ul>\n<li><code>__global__</code>: 在device端上执行，从host中调用（一些特定的GPU也可以从device上调用），返回类型必须为 <code>void</code> , 不支持可变参数，不能成为类成员函数。注意<code>__global__</code> 定义的kernel是异步的，这意味着host端不会等待kernel执行完就执行下一步；</li>\n<li><code>__device__</code>: 在device端上执行，但仅可以从device中调用，不可以和 <code>__global__</code> 同时用；</li>\n<li><code>__host__</code>: 在host上执行，仅可以从host中调用，一般省略不写，不可以和 <code>__global__</code>同时用，但可以和 <code>__device__</code>，此时函数会在device和host都编译。</li>\n</ul>\n<p>​         上面的流程中最重要的一个过程是调用CUDA的核函数来执行并行计算，kernel是CUDA中的一个重要的概念，kernel是在device上线程中并行执行的函数，在调用时需要用 <code>&lt;&lt;&lt;grid,block&gt;&gt;&gt; </code> 来指定kernel要执行的线程数量，在CUDA中，每个线程都要执行核函数，并且每个线程会分配一个唯一的<span class=\"math inline\">\\(thread\\space ID\\)</span> ,这个<span class=\"math inline\">\\(ID\\)</span> 值可以通过核函数的内置变量 <code>thread Idx</code> 来获得。</p>\n<p>​       要深刻理解<span class=\"math inline\">\\(kernel\\)</span>，必须要对<span class=\"math inline\">\\(kernel\\)</span> 的线程层次结构有一个清晰的认识。首先，<span class=\"math inline\">\\(GPU\\)</span>上很多并形化的轻量级线程。<span class=\"math inline\">\\(kernel\\)</span> 在device上执行时实际上是启动很多线程，一个<span class=\"math inline\">\\(kernel\\)</span> 所启动的所有线程称为<strong>网格</strong><span class=\"math inline\">\\(grid\\)</span> ，同一个网格的线程共享相同的全局内存空间，grid是线程结构的第一个层次，而网格又可以分为很多<strong>线程块</strong>(block)，一个线程块里面包含很多线程，这是第二个层次。  为了编程方便，<span class=\"math inline\">\\(grid\\)</span> 和<span class=\"math inline\">\\(block\\)</span> 都是定义为 <code>dim3</code> 类型的变量，<code>dim3</code> 可以看成是包含三个无符号整数<span class=\"math inline\">\\((x,y,z)\\)</span> 成员的结构体变量，在定义时，缺失值初始化为1。因此，grid和block可以灵活地定义为1-dim，2-dim以及3-dim的结构，对于，<span class=\"math inline\">\\(knernel\\)</span>在定义调用时也必须通过执行配置 <code>&lt;&lt;&lt;grid,block&gt;&gt;&gt;</code>来指定kernel所使用的线程数及结构。</p>\n<p><img alt=\"fHaSP2zNs\" class=\"lazyload\" /></p>\n<p>​    所以，为了方便编程，CUDA中使用了 <code>dim3</code> 类型（<code>dim3</code> 是基于unit3定义的矢量类型，相当于由3个 <code>unsigned int</code>类型组成的结构体）的内建变量 <code>threadIdx</code> 和 <code>blockIdx</code>。这样，就可以使用一维、二维或三维的索引来标识线程，构成 一维、二维或三维线程块。使得线程组织形式对各种域（向量、矩阵，或者高维张量）中数据的划分变得直观、自然。</p>\n<ul>\n<li>对于一维的block，线程的<span class=\"math inline\">\\(threadID\\)</span>就是<span class=\"math inline\">\\(threadId.x\\)</span>;</li>\n<li>对于大小为<span class=\"math inline\">\\((Dx,Dy)\\)</span>的二维线程块block，线程的<span class=\"math inline\">\\(threadID\\)</span> 是 <span class=\"math inline\">\\((threadIdx.x+threadIdx.x\\times{Dx})\\)</span>;</li>\n<li>对于大小为<span class=\"math inline\">\\((Dx,Dy,Dz)\\)</span>的三维线程块block, 线程的<span class=\"math inline\">\\(threadID\\)</span>是（<span class=\"math inline\">\\(threadIdx.x+threadIdx.y\\times{Dx}+threadIdx.z\\times{Dx}\\times{Dy}\\)</span>）;</li>\n</ul>\n<p>另外，线程还有内置变量gridDim，用于获取网格块各个维度的大小。</p>\n<p>​       此外，这里简单介绍一下CUDA的内存模块，如图所示。可以看到，每个线程有自己的私有本地内存（<span class=\"math inline\">\\(Local Memory\\)</span>）, 而每个线程块有包含共享内存（<span class=\"math inline\">\\(Shared \\space Memory\\)</span>）。还可以访问一些只读内存块：常用内存（<span class=\"math inline\">\\(Constant \\space Memory\\)</span>）和纹理内存 （<span class=\"math inline\">\\(Texture \\space Memory\\)</span>）。内存结构涉及到程序优化，这里就过多讨论。</p>\n<p><img alt=\"fHaRlklWa\" class=\"lazyload\" /></p>\n<p>​       还有重要一点，你需要对<span class=\"math inline\">\\(GPU\\)</span>的硬件实现有一个基本的认识。上面说到了<span class=\"math inline\">\\(kernel\\)</span>的线程组织层次，那么一个<span class=\"math inline\">\\(kernel\\)</span> 实际上会启动很多线程，这些线程是逻辑上是并行的，但是在物理层也是无法却并不一定。这其实和CPU的多线程有类似之处，多线程如果没有多核支持，在物理层也无法实现并行的。但是好在<span class=\"math inline\">\\(GPU\\)</span> 存在很多CUDA核心，充分利用CUDA核心可以充分发挥GPU的并行计算能力。GPU硬件的一个核心组件是SM，前面已经说过，SM是Streaming Multiprocessor，SM的核心组件包括的CUDA核心、共享内存、寄存器等，SM可以并发的执行上，一个线程块只能在一个SM上被调度。SM一般可以调度多个线程块，这要看SM本身的能力。那么有可能一个kernel的各个线程块被分配多个SM，所以grid只是逻辑层，而SM才是执行的物理层。SM采用的是<a href=\"https://link.zhihu.com/?target=http%3A//docs.nvidia.com/cuda/cuda-c-programming-guide/index.html%23simt-architecture\" rel=\"noopener nofollow\" target=\"_blank\">SIMT</a>(Single-Instruction, Multiple-Thread，单指令多线程)架构，基本的执行单元是线程束（warps)，线程束包含32个线程，这些线程同时执行相同的指令，但是每个线程都包含自己的指令地址计数器和寄存器状态，也有自己独立的执行路径。所以尽管线程束中的线程同时从同一程序地址执行，但是可能具有不同的行为，比如遇到了分支结构，一些线程可能进入这个分支，但是另外一些有可能不执行，它们只能死等，因为GPU规定线程束中所有线程在同一周期执行相同的指令，线程束分化会导致性能下降。当线程块被划分到某个SM上时，它将进一步划分为多个线程束，因为这才是SM的基本执行单元，但是一个SM同时并发的线程束数是有限的。这是因为资源限制，SM要为每个线程块分配共享内存，而也要为每个线程束中的线程分配独立的寄存器。所以SM的配置会影响其所支持的线程块和线程束并发数量。总之，就是网格和线程块只是逻辑划分，一个kernel的所有线程其实在物理层是不一定同时并发的。所以kernel的grid和block的配置不同，性能会出现差异，这点是要特别注意的。还有，由于SM的基本执行单元是包含32个线程的线程束，所以block大小一般要设置为32的倍数。</p>\n<table>\n<thead>\n<tr>\n<th>内存类型：</th>\n<th>内存作用：</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>全局内存（Global Memory）</strong></td>\n<td><strong>容量最大（通常数GB），所有线程可访问，但延迟高（400-800周期）</strong></td>\n</tr>\n<tr>\n<td><strong>共享内存（shared Memory）</strong></td>\n<td><strong>片上内存，速度比全局内存快100倍，但容量有限（每SM通常16-64KB）</strong></td>\n</tr>\n<tr>\n<td><strong>寄存器（Registers）</strong></td>\n<td><strong>最快的存储，每个线程私有</strong></td>\n</tr>\n<tr>\n<td><strong>常量内存（Constant Memory）</strong></td>\n<td><strong>只读缓存，适合广播数据</strong></td>\n</tr>\n<tr>\n<td><strong>纹理内存（Texture Memory）</strong></td>\n<td><strong>专为图形处理优化的特殊缓存</strong></td>\n</tr>\n</tbody>\n</table>\n<p>​     内存访问特性比较：</p>\n<table>\n<thead>\n<tr>\n<th>内存类型</th>\n<th>物理位置</th>\n<th>作用域</th>\n<th>带宽、速度</th>\n<th>使用场景</th>\n<th>显式控制关键字</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>寄存器</td>\n<td>GPU芯片寄存器</td>\n<td>线程私有</td>\n<td>最高（1周期）</td>\n<td>高频访问的私有变量（如循环计数器）</td>\n<td>自动分配（局部变量）</td>\n</tr>\n<tr>\n<td>共享内存</td>\n<td>GPU芯片上的SM处理器</td>\n<td>线程块共享</td>\n<td>高（1-32周期）</td>\n<td>线程协作（如规约运算、矩阵分块）</td>\n<td><code>__share__</code></td>\n</tr>\n<tr>\n<td>本地内存</td>\n<td>实际在全局内存中内存</td>\n<td>线程私有</td>\n<td>中低（<span class=\"math inline\">\\(\\approx\\)</span>全局内存）</td>\n<td>大数组或寄存器不足时的溢出变量</td>\n<td>编译器自动分配</td>\n</tr>\n<tr>\n<td>全局内存</td>\n<td>GPU设备显存</td>\n<td>所有线程+主机</td>\n<td>中（400~800周期）</td>\n<td>大规模数据存储，需要频繁访问时需合并访问优化</td>\n<td><code>cudaMalloc</code>分配</td>\n</tr>\n<tr>\n<td>常量内存</td>\n<td>GPU芯片上的缓存</td>\n<td>所有线程只读</td>\n<td>中（缓存加速）</td>\n<td>需要广播给所有线程的至多</td>\n<td><code>__constant__</code></td>\n</tr>\n<tr>\n<td>纹理内存</td>\n<td>GPU专用缓存</td>\n<td>所有线程</td>\n<td>中 （优化访存）</td>\n<td>图形处理、具有空间局部性的非对齐访问</td>\n<td>纹理API绑定</td>\n</tr>\n<tr>\n<td>主机内存</td>\n<td>CPU内存</td>\n<td>主机+设备（需要拷贝）</td>\n<td>最低（PCLe瓶颈）</td>\n<td>CPU-GPU数据传输的中间存储</td>\n<td>malloc、cudaHostAlloc</td>\n</tr>\n</tbody>\n</table>\n<p>下面我将详细地介绍CUDA中各种内存管理函数的功能、参数和使用方法。</p>\n<p><strong>CUDA</strong>是一种用于异构并行计算的编程模型，经常需要在主机端（host）和设备端（Device）之间进行数据传输。这是因为CUDA核函数传入的必须是指向其中处理GPU显存的三个关键的API：<code>cudaMalloc</code>,<code>cudaMemcpy</code>和 <code>cudaFree</code>。</p>\n<ul>\n<li><code>cudaMalloc</code>：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">其接口API形式：</th>\n<th style=\"text-align: left;\">cudaError_t  cudaMalloc(void ** <em>devPtr</em>,size_t <em>size</em> )</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>函数功能：</strong></td>\n<td style=\"text-align: left;\"><strong>在设备上分配线性内存size字节，并通过指针返回分配的内存devPtr。分配的内存对应任何类型的变量。记忆没有被清除。失败时返回 cudaErrorMemoryAllocation。</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>参数：</strong></td>\n<td style=\"text-align: left;\"><strong><code>devPtr</code> 设备内存分配指针；<code>size</code> ：分配的字节数</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>返回值：</strong></td>\n<td style=\"text-align: left;\"><strong><code>cudaSuccess</code> , <code>cudaErrorMemoryAllocation</code></strong></td>\n</tr>\n</tbody>\n</table>\n<p>注意事项：</p>\n<p>分配的内存</p>\n<ul>\n<li>\n<p><code>cudaMemcpy</code> ：</p>\n<table>\n<thead>\n<tr>\n<th>其接口形式：</th>\n<th>cudaError_t cudaMemcpy(void * dist, const void * src,size_t count,CudaMemcpyKind kind)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>函数功能：</strong></td>\n<td><strong>将指向的内存区域的字节复制到指向的存储区域</strong></td>\n</tr>\n<tr>\n<td><strong>参数：</strong></td>\n<td><strong>dist-目的存储地址；src -源内存地址；count-复制内存的字节数； kind-传输类型</strong></td>\n</tr>\n<tr>\n<td><strong>返回值：</strong></td>\n<td><strong>cudaSuccess，cudaErrorInvalidValue，cudaErrorInvalidDevicePointer，cudaErrorInvalidMemcpyDirection</strong></td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p><code>cudaFree</code>：</p>\n<table>\n<thead>\n<tr>\n<th>其接口形式：</th>\n<th>cudaError_t cudaFree(void * devPtr)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>函数功能</strong>：</td>\n<td><strong>释放由 指向的内存空间，该空间必须是之前调用cudaMalloc()或cudaMallocPitch()时返回过的。否则，或者如果cudaFree()之前已被调用过，则返回错误。如果 为 0，则不执行作。cudaFree() 在失败时返回cudaErrorInvalidDevicePointer。</strong></td>\n</tr>\n<tr>\n<td><strong>参数:</strong></td>\n<td><strong><code>devPtr</code> -设备指针指向内存释放</strong></td>\n</tr>\n<tr>\n<td><strong>返回值：</strong></td>\n<td><strong>cudaSuccess，cudaErrorInvalidDevicePointer, cudaErrorInitialization</strong></td>\n</tr>\n</tbody>\n</table>\n<p>​</p>\n</li>\n</ul>\n<h2 id=\"12-cuda的第一个程序矩阵赋值matrix-assign\">1.2 CUDA的第一个程序—矩阵赋值(Matrix Assign)</h2>\n<p>​            在本节通过一个矩阵赋值（matrix Assign）例子开始真正的CUDA程序实现，本例是在SDK中template程序的基础上修改得到的。<span class=\"math inline\">\\(template\\)</span> 是 <span class=\"math inline\">\\(NVIDIA\\)</span> 公司提供的CUDA程序模板，也就是CUDA程序最基本的框架。要创建一个CUDA程序，可以把整个template文件复制一份。在一个CUDA程序中，基本的主机端代码主要完成以下的功能：</p>\n<ul>\n<li>启动CUDA，使用多卡时应该时应该加上设备号，或使用<span class=\"math inline\">\\(cudaSetDevice()\\)</span>设备GPU设备；</li>\n<li>为输入数据分配内存空间；</li>\n<li>初始化输入数据；</li>\n<li>为GPU分配内存，用于存放输入数据；</li>\n<li>将内存中的输入数据拷贝到显存；</li>\n<li>为GPU分配显存，用于存放输出数据；</li>\n<li>调用device端的kernel进行计算，将结果写到显存中的对应区域；</li>\n<li>为CPU分配内存，用于存放GPU传回来的输出数据；</li>\n<li>将显存中的结果读取到内存；</li>\n<li>释放内存和显存空间；</li>\n<li>退出CUDA；</li>\n</ul>\n<p>最简单的设备端代码主要完成以下功能：</p>\n<ul>\n<li>\n<p>从显存读取数据到GPU片内；</p>\n</li>\n<li>\n<p>对数据进行处理；</p>\n</li>\n<li>\n<p>将处理后的数据写回显存；</p>\n<p>其整个工程包含了三：</p>\n<p>（1）主程序文件CPU-Host端程序（example1main.cu）；</p>\n</li>\n</ul>\n<p>​       （2）GPU设备端函数的处理函数头文件（example_matrixassign_kernel.cuh）；</p>\n<p>​       （3）GPU设备端函数的处理函数文件（example_matrixassign_kernel.cu）；</p>\n<p>File1：主程序文件CPU-Host端程序（example1main.cu）；</p>\n<pre><code class=\"language-c\">#include&lt;stdio.h&gt; //系统头文件\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\n#include&lt;math.h&gt;\n\n#include\"cuda_runtime.h\" //cuda项目头文件\n#include\"device_launch_parameters.h\"\n#include\"example_matrixassign_kernel.cuh\"  //核函数的数据的头文件\n\n\nvoid runTest(int argc, char** argv);\n\nint main(int argc,char** argv){\n\n\trunTest(argc,argv);\n\n}\n\nvoid runTest(int argc, char** argv){\n\n\tunsigned int num_blocks = 4;  //定义网格中的线程块数量\n\tunsigned int num_threads= 4;  //定义每个线程块中的线程数量\n\n\tunsigned int mem_size = sizeof(float) * num_blocks * num_threads; //为了数据分配的存储器大小，这里每一个人线程计算一个flaot\n\n\t//在host端分配内存，h_表示host端，i表示input，o表示output\n\tfloat* h_idata = nullptr;\n\tfloat* h_odata = nullptr;\n\n\th_idata =(float *)malloc(mem_size);\n\th_odata = (float*)malloc(mem_size);\n\n\tif(h_idata != nullptr) {\n\t   memset(h_idata, 0, mem_size);\n\t}else{\n\t\treturn;\n\t}\n\tif(h_odata!=nullptr){\n\t\tmemset(h_odata, 0, mem_size);\n\t}else{\n\t\treturn;\n\t}\n\t\n\t//在device端分配显存，d_表示device端，i表示input，o表示output\n\tfloat* d_idata = nullptr;\n\tfloat* d_odata = nullptr;\n\n\tcudaError_t cudaStatus;  //cuda状态判断\n\n\tcudaStatus=cudaMalloc((void**)&amp;d_idata, mem_size);\n\tif(cudaStatus != cudaSuccess){\n\t\tprintf(\"d_idata is cudaMalloc failed!\\n\");\n\t\treturn;\n\t}\n\tcudaStatus=cudaMalloc((void**)&amp;d_odata, mem_size);\n\tif(cudaStatus!=cudaSuccess){\n\t\tprintf(\"d_odata is cudaMalloc failed!\\n\");\n\t\treturn;\n\t}\n\t\n\t//初始化内存中的值\n\tfor(unsigned int i = 0; i &lt; num_threads * num_blocks;i++){\n\t\th_idata[i] =1.0f;\n\t}//end for(unsigned int i = 0; i &lt; num_threads * num_blocks;i++)\n\n\t//将内存中的输入数据读入设备端显存，这样就完成了主机对设备的数据写入\n\tcudaStatus=cudaMemcpy(d_idata,h_idata,mem_size,cudaMemcpyHostToDevice);\n\n\t//设置运行参数，即网格的形状和线程块的形状\n\tdim3 grid(num_blocks,1,1);\n\tdim3 block(num_threads,1,1);\n\n\t// 运行核函数，调用GPU进行运算\n\ttestMatrixAssignKernel &lt;&lt;&lt;grid, block&gt;&gt;&gt; (d_idata,d_odata);\n\n\t//将结果从显存写入内存\n\tcudaStatus = cudaMemcpy(h_odata,d_odata,mem_size,cudaMemcpyDeviceToHost);\n\n\t//打印结果\n\tprintf(\"赋值前的矩阵：\\n\");\n\tfor (unsigned int iblock = 0; iblock &lt; num_blocks; iblock++) {\n\t\tfor (unsigned int ithread = 0; ithread &lt; num_threads; ithread++) {\n\t\t\tprintf(\"%5.0f\", h_idata[iblock * num_threads + ithread]);\n\t\t}//end for(unsigned int ithread = 0; ithread &lt; num_threads; ithread++)\n\t\tprintf(\"\\n\");\n\t}//end for(unsigned int iblock = 0; iblock &lt; num_blocks; iblock++)\n\n\tprintf(\"赋值后的矩阵：\\n\");\n\tfor(unsigned int iblock = 0; iblock &lt; num_blocks; iblock++){\n\t\tfor(unsigned int ithread = 0; ithread &lt; num_threads; ithread++){\n\t\t\tprintf(\"%5.0f\",h_odata[iblock*num_threads+ithread]);\n\t\t}//end for(unsigned int ithread = 0; ithread &lt; num_threads; ithread++)\n\t\tprintf(\"\\n\");\n\t}//end for(unsigned int iblock = 0; iblock &lt; num_blocks; iblock++)\n\n\t//输出存储器指针\n\tfree(h_idata);\n\tfree(h_odata);\n\tcudaFree(d_idata);\n\tcudaFree(d_odata);\n}\n\n</code></pre>\n<p>从代码中看出，CUDA的主机端代码与C语言非常相似。但也有一部分C语言中没有的语句，下面逐一进行分析。</p>\n<p>​      （1）<code>cudaMalloc(size)</code>在显存global memory上分配大小为size字节的线性空间。需要注意的是，与malloc和free一样，cudaMalloc() 也必须与cudaFree()成对使用，否则无法释放显存空间，运行几次程序以后显卡上就没有显存可供分配，程序也就无法正常运行了。另外，为了杜绝指针指费的情况现象，最好在程序结束前将指针赋空并摧毁。</p>\n<p>​      （2） <code>cudaMemcpy()</code>用于拷贝存储器中的数据，其中第二参数是指向目标的指针，第二个参数是指向源的指针，第三个参数是需要拷贝的字节数，第四个参数是拷贝操作的类型。拷贝操作类型共有三种：</p>\n<ul>\n<li>cudaMemcpyDeviceToHost 将显存中的数据拷贝内存中；</li>\n<li>cudaMemcpyHostToDevice 将内存中的数据拷贝到显存中；</li>\n<li>cudaMemcpyDeviceToDevice将global memory中的数据拷贝到同一个CUDA上下文的global的另一个区域中；</li>\n</ul>\n<p>​      （3）<code>&lt;&lt;&lt;&gt;&gt;&gt;</code>运算符对kernel函数完整的执行参数配置形式是<code>&lt;&lt;&lt;Dg,Db,Ns,S&gt;&gt;&gt;</code>，其中各个参数的含义是：</p>\n<ul>\n<li>参数Dg用于定义整个grid的维度和尺寸，为dim3类型，但实际上只有前两维可以不为1。<code>Dim3 Dg(Dg.x,Dg.y,1)</code>中每行有Dg.x个block，每列有Dg.y个block的维度，第三维恒为1。</li>\n<li>参数Db为dim3类型，用于定义每个block的维度与尺寸。<code>Dim3 Db(Db.x,Db.y,Db.z)</code> 中每行有<code>Db.x</code>个thread，每列<code>Db.y</code>个thread，高为<code>Db.z</code>，可以定义三维尺寸。整个block中共有<code>Db.x*Db.y*Db.z</code> 个线程；</li>\n<li>参数Ns是一个可选参数，用于设置每个block的共享内存shared memory以外，最多能够动态分配的shared memory大小，单位为Byte。</li>\n<li>参数<span class=\"math inline\">\\(s\\)</span>是一个cudaStream_t类型的可选参数，初始值为0。在本案例中没有用到Stream的相关内容因此这个参数不填，默认为0号流。</li>\n</ul>\n<p>File2：主程序文件CPU-Host端程序（example1main.cu）；</p>\n<p>​</p>\n<pre><code class=\"language-c\">\n#pragma once\n#ifndef EXAMPLE_MATRIXASSIGN_KERNEL_H\n#define EXAMPLE_MATRIXASSIGN_KERNEL_H\n\n#include&lt;stdio.h&gt;\n#include\"cuda_runtime.h\"\n\n__global__ void testMatrixAssignKernel(float* data_input, float* data_output);\n\n\n#endif // !_EXAMPLE_MATRIXASSIGN_KERNEL_H_\n</code></pre>\n<p>File2：主程序文件CPU-Host端程序（example1main.cu）；</p>\n<pre><code class=\"language-C\">\n__global__ void testMatrixAssignKernel(float *data_input,float *data_output){\n\n\t//shared memory,extern表示大小由host端的Ns参数确定\n\textern __shared__ float sdata[];\n\n\tconst unsigned int bid = blockIdx.x; //线程所在的block的索引号\n\tconst unsigned int tid_in_block = threadIdx.x; //线程在block中的位置\n\tconst unsigned int tid_in_grid = blockDim.x * blockIdx.x + threadIdx.x;\n\n\t//按行划分任务时，线程在整个grid中的位置\n\n  // 将数据从global memory读入shared memory\n\tsdata[tid_in_block] = data_input[tid_in_grid];\n\t//读入数据后进行一次同步，保证计算时所有数据均已到位\n\t__syncthreads();\n\n\t// 计算\n\tsdata[tid_in_block] = (float)tid_in_grid;\n\t//  sdata[tid_in_block] *= (float)tid_in_block;\n\t//  sdata[tid_in_block] *= (float)tid_in_grid;\n\n\t  //进行同步，确保要写入的数据已经被更新\n\t__syncthreads();\n\n\t// 将shared memory中的数据写到global memory\n\tdata_output[tid_in_grid] = sdata[tid_in_block];\n\n\n}\n</code></pre>\n<p>由上可知，最简单的<code>__gloabal__</code>程序由以下的过程组成：</p>\n<ol>\n<li>分配<span class=\"math inline\">\\(shared \\space memory\\)</span>；</li>\n<li>将<span class=\"math inline\">\\(global\\space memory\\)</span> 中的数据读入<span class=\"math inline\">\\(shared \\space memory\\)</span>;</li>\n<li>将进行计算，将结果写到<span class=\"math inline\">\\(shared \\space memory\\)</span>;</li>\n<li>将<span class=\"math inline\">\\(shared\\)</span>中的结果写到<span class=\"math inline\">\\(global \\space memory\\)</span> ;</li>\n</ol>\n<p>​         进行一次GPU计算，要在多种存储器进行几次数据传输，要消耗相当多的时间。这导致了较大的延迟，这导致使<span class=\"math inline\">\\(GPU\\)</span> 不适合处理一些实时性要求很高的应用。不同存储器间的数据传输速率和使用方法有很大差异，开发人员需要根据硬件的特点来设计算法，以优化存储器访问。在理想情况下，在所有的存储器传输进行的同时，GPU的各个核心也始终在进行计算，这样就能够很好的隐藏各种访问延迟。CUDA 并不是一种完全硬件透明的语言，程序员需要根据硬件特征将任务进行合理的分解，在编程时对数据传输和寄存器访问进行优化。</p>\n<p>​       <code>__global__</code>前缀表示这一段代码是cuda GPU端内核函数。内核函数运行在设备上，其返回类型必须为void。<code>__global__</code>函数中是每一个线程要执行的语句，但由于<span class=\"math inline\">\\(shared\\space memory\\)</span>和同步的存在，在最好将<code>__global__</code>函数理解为对每一个block的行为的描述。</p>\n<p>​        在这一端内核函数中，首先定义了<span class=\"math inline\">\\(shared \\space memory\\)</span> 中的变量；然后根据内建变量定义每一个block和thread的索引，对任务进行划分；最后，每一个线程执行了相同的求和运算，但处理数据不同，由线程的索引决定的。程序员在编写<code>__global__</code>函数之前，要先对任务进行划分，设计各个block的工作流程后，做到成竹在胸。</p>\n<p>​        由于CUDA采用了两层并行，因此本例在划分任务时，每个thread在grid中的索引<span class=\"math inline\">\\(tid\\_in\\_grid\\)</span> 是由thread所在block内编号tid计算得来的。计算出每个线程的索引后，就可以根据索引处理线程中不同的数据，请读者好好体会这一点。</p>\n<p>​      <code>extern __shared__ float sdata[]</code> 在shared  memory中为数组data动态分配了空间。<code>extern</code> 在设备端和主机端有不同的含义：<code>__device__</code>和<code>__global__</code> 函数中表示动态分配，而在主机端函数中表示外部变量。如果要静态分配一块 <code>shared memory</code>，那么在<code>__shared__</code>之前就不加<code>extern</code>，还必须在[]中写上要分配的字节数。动态分配的shared memory大小，是&lt;&lt;&lt;&gt;&gt;&gt;的执行参数中第三个参数规定的大小。关于<code>shared memory</code>大小。</p>\n<p>​        CUDA定义了一些内建变量如下：</p>\n<ol>\n<li>gridDim： 网格的维度的变量，dim3类型</li>\n<li>blockIdx:    块的索引变量，unit3类型</li>\n<li>blockDim：块的维度变量，dim3类型</li>\n<li>threadIdx：块内的线程索引变量，unit3类型</li>\n<li>warpSize：线程中的warp大小，int类型</li>\n</ol>\n<p>其输出结果：</p>\n<p><img alt=\"输出结果\" class=\"lazyload\" /></p>\n<p>​</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 18:33</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "C语言程序自动化转CUDA的方法研究",
      "link": "https://www.cnblogs.com/huanxx/p/19443586",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/huanxx/p/19443586\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 16:18\">\n    <span>C语言程序自动化转CUDA的方法研究</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"C语言程序自动化转CUDA的方法研究\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3550672/202601/3550672-20260105161800826-262297873.png\" />\n        自动将C语言程序转化为能够直接使用nvcc编译的CUDA程序, 研究思路\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"c2cuda\">C2CUDA</h1>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#c2cuda\" rel=\"noopener nofollow\">C2CUDA</a><ul><li><a href=\"#目标分析\" rel=\"noopener nofollow\">目标分析</a><ul><li><a href=\"#cuda加速的原理\" rel=\"noopener nofollow\">CUDA加速的原理</a></li><li><a href=\"#c语言中可被有效加速的部分\" rel=\"noopener nofollow\">C语言中可被有效加速的部分</a></li></ul></li><li><a href=\"#定义定理\" rel=\"noopener nofollow\">定义定理</a></li></ul></li></ul></div><p></p>\n<hr />\n<h2 id=\"目标分析\">目标分析</h2>\n<p>首先，目标是将C语言转化为CUDA加速程序的运行，从这里我们引出两点需要探究的内容是：</p>\n<ul>\n<li>CUDA加速的原理是什么？</li>\n<li>C语言中的什么部分可以被CUDA有效的加速？</li>\n</ul>\n<hr />\n<h3 id=\"cuda加速的原理\">CUDA加速的原理</h3>\n<blockquote>\n<p>2006年，NVIDIA推出了<em>统一计算设备架构</em>（CUDA），使任何计算工作负载都能不受图形API的限制，利用GPU的吞吐量能力。</p>\n<p><strong>——CUDA编程指南</strong></p>\n</blockquote>\n<p>从上面的引用可以看出，CUDA设计的目的是利用GPU的吞吐量能力（单位时间内系统能处理的任务总量（或数据量））</p>\n<p>而CUDA 的核心逻辑是将大规模并行的软件逻辑（Thread）映射到大规模并行的硬件资源（Core）上</p>\n<p>因此最核心的原理就是并行，因此C语言中的什么部分可以被CUDA有效的加速？</p>\n<hr />\n<h3 id=\"c语言中可被有效加速的部分\">C语言中可被有效加速的部分</h3>\n<p>最核心的就是可以并行的部分，那么在一个串行的C语言代码中有什么可以并行呢？</p>\n<ul>\n<li>数据并行：在<strong>C 语言</strong>中，循环（Loop）是数据并行最主要、甚至几乎是唯一的显式表现形式。</li>\n<li>任务并行：代码中互不相关的<strong>函数调用</strong>或<strong>代码块</strong>也可以并行， 任务并行的规模通常很小（比如同时跑 2-4 个不同的任务），相比于循环动辄上百万次的迭代，它带来的加速效果远不如循环并行明显</li>\n<li>指令级并行： 这种并行通常由硬件和后端编译器（如 NVCC）自动优化，通常不需要关注它。</li>\n</ul>\n<p>因此，核心目标就是将C语言中的循环利用CUDA并行化运行在不同硬件上。</p>\n<blockquote>\n<p>[!IMPORTANT]</p>\n<p>将循环并行化意味着不同循环循环迭代之间的运行顺序是不保证的！</p>\n<p>CUDA 执行线程是并发的，硬件调度是不确定的。迭代 <span class=\"math inline\">\\(100\\)</span> 可能比迭代 <span class=\"math inline\">\\(1\\)</span> 先执行，也可能同时执行。这本质上就是一种<strong>极端的“重排序”</strong>。</p>\n</blockquote>\n<p>因此要确保并行化有效（不能改变程序的最终结果），就必须识别什么循环可以用并行。这里从一个定理引入</p>\n<blockquote>\n<p>定理\t<strong>迭代重排序</strong>\t一个变换重排<span class=\"math inline\">\\(k\\)</span>层循环迭代的顺序，此外不做任何其他的改变，如果该循环不携带依赖，那么它是有效的。</p>\n<p>**——现代体系结构的优化编译器 ([美] Randy Allen) **</p>\n</blockquote>\n<p>这个定理可以说是本项目研究的基石，项目的入口，因为只有确定什么样的循环迭代能够进行迭代重排序我们才能使用CUDA对其进行并行化。</p>\n<p>由此定理引出的概念：<a href=\"#xhxdyl\" rel=\"noopener nofollow\">循环携带依赖</a>、<a href=\"#xhxdyldc\" rel=\"noopener nofollow\">循环携带依赖的层</a></p>\n<p>到此为止, 我们已经知道项目要如何进行了, 使用定义<a href=\"#xhxdyl\" rel=\"noopener nofollow\">循环携带依赖</a>判断循环嵌套是否有依赖以及依赖所在的层(对于某些存在循环携带的层, 利用循环变换能够转化为不携带依赖的层), 根据定理<strong>迭代重排序</strong>对不存在携带依赖的层利用CUDA并行化</p>\n<hr />\n<h2 id=\"定义定理\">定义定理</h2>\n<blockquote>\n<p>[!NOTE]</p>\n<p>定理皆来自于现代体系结构的优化编译器 ([美] Randy Allen)</p>\n</blockquote>\n<blockquote>\n<p><span id=\"xhxdyl\"> </span><strong>定义\t循环携带依赖</strong>\t语句<span class=\"math inline\">\\(S_2\\)</span>对语句<span class=\"math inline\">\\(S_1\\)</span>有一个循环携带依赖,当且仅当<span class=\"math inline\">\\(S_1\\)</span>在迭代i中引用单元<span class=\"math inline\">\\(M\\)</span>,而<span class=\"math inline\">\\(S_2\\)</span>在迭代j中引用<span class=\"math inline\">\\(M\\)</span>,且<span class=\"math inline\">\\(d(i,j)&gt;0\\)</span>(即<span class=\"math inline\">\\(D(i,j)\\)</span>包含一个“&lt;”作为它的最左非“=”分量)</p>\n</blockquote>\n<p>此定义引出的概念:<a href=\"#ddxl\" rel=\"noopener nofollow\">迭代向量</a>,<a href=\"#yljlxl\" rel=\"noopener nofollow\">依赖距离向量</a>,<a href=\"#ylfxxl\" rel=\"noopener nofollow\">依赖方向向量</a></p>\n<blockquote>\n<p><span id=\"xhxdyldc\"> </span><strong>定义\t循环携带依赖的层</strong>\t此依赖的<span class=\"math inline\">\\(D(i,j)\\)</span>的最左非“=”索引</p>\n</blockquote>\n<blockquote>\n<p><span id=\"ddxl\"> </span><strong>定义\t迭代向量</strong>\t给定<span class=\"math inline\">\\(n\\)</span>个循环的嵌套,最内层循环的<strong>一个特定的迭代</strong>的迭代向量<span class=\"math inline\">\\(i\\)</span>是一个整形向量,它包含按嵌套层顺序的每层循环的迭代号.</p>\n<p></p><div class=\"math display\">\\[i=\\{i_1,i_2,\\dots,i_n\\}\n\\]</div><p></p><p>其中<span class=\"math inline\">\\(i_k,(1\\le k \\le n)\\)</span>表示在嵌套层k上的循环迭代号.</p>\n</blockquote>\n<p>此定义引出的概念:<a href=\"#xhddh\" rel=\"noopener nofollow\">循环迭代号</a></p>\n<blockquote>\n<p><span id=\"yljlxl\"> </span><strong>定义\t依赖距离向量</strong>\t假设从循环嵌套迭代 <span class=\"math inline\">\\(i\\)</span> 中语句 <span class=\"math inline\">\\(S_1\\)</span> 到迭代 $ j $ 中语句 <span class=\"math inline\">\\(S_2\\)</span> 有一依赖，则依赖距离向量 $ \\mathbf{d}(i, j) $ 定义为长度为 <span class=\"math inline\">\\(n\\)</span> 的向量，使得</p>\n<p></p><div class=\"math display\">\\[\\mathbf{d}(i, j)_k = j_k - i_k\n\\]</div><p></p></blockquote>\n<blockquote>\n<p><span id=\"ylfxxl\"> </span><strong>定义\t依赖方向向量</strong>\t假设从 <span class=\"math inline\">\\(n\\)</span> 层循环嵌套的迭代 <span class=\"math inline\">\\(i\\)</span> 中语句 <span class=\"math inline\">\\(S_1\\)</span> 到迭代 $ j $ 中语句 <span class=\"math inline\">\\(S_2\\)</span> 有一依赖；那么依赖方向向量 $ \\mathbf{D}(i, j) $ 定义为长度为 <span class=\"math inline\">\\(n\\)</span> 的向量，使得</p>\n<p></p><div class=\"math display\">\\[\\mathbf{D}(i, j)_k = \n\\begin{cases}\n&lt; , &amp; \\text{如果 } \\mathbf{d}(i, j)_k &gt; 0 \\\\\n= , &amp; \\text{如果 } \\mathbf{d}(i, j)_k = 0 \\\\\n&gt; , &amp; \\text{如果 } \\mathbf{d}(i, j)_k &lt; 0\n\\end{cases}\n\\]</div><p></p></blockquote>\n<blockquote>\n<p><span id=\"xhddh\"> </span><strong>定义\t循环迭代号</strong>\t对任意一个循环，其中循环索引 $ I $ 以步长 $ S $ 从 $ L $ 步进到 $ U $，一个特定迭代的（正规化）迭代号 <span class=\"math inline\">\\(i\\)</span> 等于值 $ (I - L + S) / S $，其中 $ I $ 是该迭代中索引变量的值。</p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 16:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/huanxx\">幻星晞</a>&nbsp;\n阅读(<span id=\"post_view_count\">20</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "新版微信4.1及以上dat文件转图片",
      "link": "https://www.cnblogs.com/wang_xy/p/19444824",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_xy/p/19444824\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 21:48\">\n    <span>新版微信4.1及以上dat文件转图片</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>微信电脑版现在已经是日常工作生活必不可少的工具，有时删除了聊天记录或被系统清理软件清理了，但还想查看曾经的微信聊天图片。<br />这个时候辛辛苦苦找到了文件，却发现无法查看，因为微信电脑版为了保护我们的隐私，把原先的图片格式文件给做了加密处理变成了DAT格式，这里不得不给微信一个大大的赞。<br />那么我们就只能是看着文件没有办法了么？答案当然是：有方法的。下面看看应该如何处理微信DAT图片转换jpg图片格式（或gif或png）吧。<br />一键批量将微信聊天接受到的加密存储DAT图片文件转化为普通图片。<br /><span style=\"color: rgba(255, 0, 255, 1);\">通过查看转化后的图片，您可以：</span><br /><span style=\"color: rgba(255, 0, 255, 1);\">（1）清理无用的历史图片，节省电脑硬盘存储空间。</span><br /><span style=\"color: rgba(255, 0, 255, 1);\">（2）恢复寻找重要照片资料。</span></p>\n<p>下载地址：</p>\n<p>（1）点击下载：<a href=\"https://weijiesoft.lanzouu.com/iJ7Bq3f44h8h\" rel=\"noopener nofollow\" target=\"_blank\">&gt;&gt;&gt;点我下载&lt;&lt;&lt;</a></p>\n<p>（2）或复制链接到浏览器下载：&nbsp;https://weijiesoft.lanzouu.com/iJ7Bq3f44h8h</p>\n<p>他支持微信4.1版本及以上，也支持微信3.9.x的老版本微信的dat的转换图片。</p>\n<p>支持批量转换，支持单个转换。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/687256/202601/687256-20260105213100992-1663916089.png\" /></p>\n<p>&nbsp;（1）单个转换</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/687256/202601/687256-20260105214431641-1449253764.png\" /></p>\n<p>&nbsp;</p>\n<p>（2）批量转换</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/687256/202601/687256-20260105213422839-134454665.png\" /></p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\">\n    <div id=\"MySignature\" style=\"display: block;\"><br />\n<fieldset style=\"padding: 10px; margin: 10px; background-color: #708090; width: 850px;\">\n<p><span style=\"color: #fff;\">版权声明</span></p><p>\n</p><hr style=\"color: #fff;\" />\n<p><span style=\"color: #fff;\">作者：</span><span style=\"color: #fff;\">Wagwei</span></p>\n  <p><span style=\"color: #fff;\">联系方式：</span><span style=\"color: #fff;\">\n   \n   \n   <span><a class=\"btn btn-qq\" href=\"\"><img alt=\"qq:453357830\" border=\"0\" src=\"http://pub.idqqimg.com/wpa/images/counseling_style_52.png\" title=\"与我聊天\" /></a></span>\n\n\n\n    QQ:453357830\n    </span></p>\n<p><span style=\"color: #fff;\">出处：</span><a href=\"http://www.cnblogs.com/wagxy\" style=\"color: #fff;\" target=\"_blank\">博客园 Wagwei 的技术博客--http://www.cnblogs.com/wagxy</a> </p>\n<p><span style=\"color: #fff;\">您的支持是对博主最大的鼓励，感谢您的认真阅读。</span></p>\n<p><span style=\"color: #fff;\">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span></p>\n</fieldset></div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 21:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_xy\">Wagwei</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[python] 配置管理框架Hydra使用指北",
      "link": "https://www.cnblogs.com/luohenyueji/p/19444783",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/luohenyueji/p/19444783\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 21:29\">\n    <span>[python] 配置管理框架Hydra使用指北</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>Hydra是Facebook Research开发的开源Python配置管理框架，旨在解决复杂项目中配置混乱、多环境与多参数组合管理的难题。该框架采用分层配置与动态组合设计，支持以YAML文件实现结构化配置。Hydra尤其适用于简化机器学习实验、软件开发及其他复杂应用的配置管理。它的名字来源于希腊神话中的九头蛇，寓意其能够灵活管理多种配置组合。Hydra的核心特性包括支持多源分层配置组合、可通过命令行直接覆盖配置、提供动态命令补全功能，同时支持本地与远程运行，并能通过单命令执行批量参数作业。</p>\n<p><img alt=\"https://github.com/facebookresearch/hydra/blob/main/website/static/img/Hydra-Readme-logo2.svg\" src=\"https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/%5Bpython%5D%20%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6Hydra%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/imgs/img1.svg\" /></p>\n<p>Hydra的官方仓库地址为：<a href=\"https://github.com/facebookresearch/hydra\" rel=\"noopener nofollow\" target=\"_blank\">hydra</a>，详细文档可参阅：<a href=\"https://hydra.cc/docs/intro/\" rel=\"noopener nofollow\" target=\"_blank\">hydra-doc</a>。Hydra功能全面，本文主要介绍其基本使用方法，更多高级功能请参考官方文档。截至本文撰写时，Hydra的稳定版本为1.3，该版本兼容Python 3.6至3.11，并全面支持Linux、macOS和Windows操作系统。安装命令如下：</p>\n<blockquote>\n<p>pip install hydra-core --upgrade</p>\n</blockquote>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#1-基础教程\" rel=\"noopener nofollow\">1 基础教程</a><ul><li><a href=\"#11-快速入门\" rel=\"noopener nofollow\">1.1 快速入门</a></li><li><a href=\"#12-整合应用\" rel=\"noopener nofollow\">1.2 整合应用</a></li><li><a href=\"#13-信息管理\" rel=\"noopener nofollow\">1.3 信息管理</a></li></ul></li><li><a href=\"#2-结构化配置\" rel=\"noopener nofollow\">2 结构化配置</a><ul><li><a href=\"#21-hydra代码配置\" rel=\"noopener nofollow\">2.1 Hydra代码配置</a></li><li><a href=\"#22-配置模式\" rel=\"noopener nofollow\">2.2 配置模式</a></li></ul></li><li><a href=\"#3-参考\" rel=\"noopener nofollow\">3 参考</a></li></ul></div><p></p>\n<h1 id=\"1-基础教程\">1 基础教程</h1>\n<h2 id=\"11-快速入门\">1.1 快速入门</h2>\n<p><strong>简单示例</strong></p>\n<p>以下代码是一个简单的Hydra应用示例，它会打印出配置信息，其中my_app函数是编写业务逻辑的入口。</p>\n<pre><code class=\"language-python\">from omegaconf import DictConfig, OmegaConf\nimport hydra\n\n@hydra.main(version_base=None)\ndef my_app(cfg: DictConfig) -&gt; None:\n    print(OmegaConf.to_yaml(cfg))\n\nif __name__ == \"__main__\":\n    my_app()\n</code></pre>\n<p>如果你直接执行这段代码（没有任何命令行参数），程序会输出一个空的配置对象：</p>\n<pre><code>{}\n</code></pre>\n<p>这是因为，当运行<code>my_app.py</code>时，<code>@hydra.main</code>装饰器会自动拦截对 <code>my_app()</code>的调用。此时Hydra会初始化一个空的<code>DictConfig</code>对象（类似于Python字典），并将其作为参数<code>cfg</code> 传递给函数。由于当前配置为空，<code>OmegaConf.to_yaml(cfg)</code>将其转换为YAML格式后，仅输出一个空对象。OmegaConf是Hydra的底层配置引擎，Hydra基于OmegaConf实现上层的复杂应用配置与运行管理，且OmegaConf可独立使用。</p>\n<p>此外默认情况下，Hydra会创建以下目录结构以追踪和管理程序的运行结果：</p>\n<pre><code>outputs/\n├── yyyy-mm-dd/          # 按日期分组\n│   └── hh-mm-ss/        # 按时间精确到秒\n│       └── .hydra/      # 保存本次运行的配置\n│           ├── config.yaml    # 完整的配置\n│           ├── hydra.yaml     # Hydra 自身的配置\n│           └── overrides.yaml # 命令行覆盖的参数\n│       └── my_app.log   # 日志文件（如果配置了日志）\n│       └── 其他输出文件     # 你的程序生成的文件\n</code></pre>\n<p>可以通过以下方式为配置添加内容：</p>\n<ol>\n<li>\n<p>通过命令行添加：</p>\n<pre><code class=\"language-bash\"># 不支持直接在 +key=value 语法中传入非 ASCII 字符\npython my_app.py +name=\"zhangsan\" +age=25\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"language-yaml\">name: zhangsan\nage: 25\n</code></pre>\n</li>\n<li>\n<p>创建配置文件：<br />\n创建一个<code>config.yaml</code>文件，然后运行：</p>\n<pre><code class=\"language-bash\">python my_app.py --config-path=. --config-name=config\n</code></pre>\n</li>\n<li>\n<p>在代码中设置默认配置：<br />\n可以修改代码，为<code>@hydra.main</code>装饰器添加配置参数：</p>\n<pre><code class=\"language-python\">from omegaconf import DictConfig, OmegaConf\nimport hydra\n\n@hydra.main(version_base=None, config_path=\".\", config_name=\"config\")\ndef my_app(cfg):\n    print(OmegaConf.to_yaml(cfg))\n\nif __name__ == \"__main__\":\n    my_app()\n</code></pre>\n<p>可以通过命令行覆盖已加载配置中的值，但是注意无需添加+前缀：</p>\n<pre><code class=\"language-bash\">python my_app.py name=\"lisi\"\n</code></pre>\n<p>使用++前缀可实现若配置中已存在该参数则覆盖，若不存在则新增：</p>\n<pre><code class=\"language-bash\">python my_app.py ++name=\"wangwu\" ++password=1234\n</code></pre>\n<p>要注意🤖：Hydra通过命令行修改配置时，仅会覆盖或新增程序运行时内存中的配置数据，不会改动磁盘上的原始配置文件，重启程序后仍会配置加载文件的原始配置。</p>\n</li>\n</ol>\n<p><strong>配置对象使用</strong></p>\n<p>通过Hydra加载配置后，可通过属性或字典式访问或修改已有的配置项，访问不存在的配置项时会抛出异常：</p>\n<pre><code class=\"language-python\">from omegaconf import DictConfig, OmegaConf\nimport hydra\n\n@hydra.main(version_base=None, config_path=\".\", config_name=\"config\")\ndef my_app(cfg: DictConfig):\n    # 属性式访问配置值\n    assert cfg.name == \"张三\"\n    # 字典式访问配置值\n    assert cfg[\"age\"] == 25\n    \n    # 修改已有配置值\n    cfg.name = \"李四\"          \n    cfg[\"age\"] = 30            \n    assert cfg.name == \"李四\"\n    assert cfg[\"age\"] == 30\n\n    # 访问缺失值会抛出异常\n    try:\n        cfg.birth_year\n    except Exception as e:\n        print(\"error !!\")\n        print(e)\n\nif __name__ == \"__main__\":\n    my_app()\n</code></pre>\n<p>之所以不允许访问不存在的配置键，仅能操作已有配置键，是因为Hydra默认启用了struct模式以严格结构化配置。如需新增或修改配置，可先关闭严格模式，允许动态新增键。但如果嵌套层级也未提前声明，则需要先创建空嵌套，再为其添加子项：</p>\n<pre><code class=\"language-python\">from omegaconf import DictConfig, OmegaConf\nimport hydra\nimport os\n\n@hydra.main(version_base=None, config_path=\".\", config_name=\"config\")\ndef my_app(cfg: DictConfig):\n    # 关闭struct模式，允许新增配置键\n    OmegaConf.set_struct(cfg, False)\n\n    # 同一级新增配置\n    cfg.birth_year = 1995      \n    cfg[\"hobby\"] = [\"篮球\", \"编程\"]\n\n    # 无法直接给不存在的嵌套层级链式赋值\n    # cfg.address.city = \"北京\"          \n    # 需要先创建嵌套层级，再赋值子键\n    cfg.address = OmegaConf.create({})  # 显式创建空的嵌套\n    cfg.address.city = \"北京\"         \n    cfg.address[\"district\"] = \"朝阳区\"\n\n    # 验证写入结果\n    assert cfg.birth_year == 1995  \n    assert cfg.address.district == \"朝阳区\"\n    print(\"配置写入验证通过！\")\n\nif __name__ == \"__main__\":\n    my_app()\n</code></pre>\n<p><strong>对配置文件进行分组</strong></p>\n<p>若希望分别使用CNN和Transformer模型对数据集进行训练基准测试，可通过配置组（Config Group）实现这一需求。配置组是一个带有名称的分组，包含一组有效的配置项。若选择不存在的配置项，系统会生成错误提示，并列出所有有效的配置项。</p>\n<p>创建配置组时，需先新建一个目录（例如model），用于存放各模型配置项对应的文件。由于预计会创建多个配置组，建议提前将所有配置文件统一移至conf目录下管理。</p>\n<p>目录结构如下：</p>\n<pre><code class=\"language-shell\">├─ conf\n│  └─ model\n│      ├─ cnn.yaml\n│      └─ transformer.yaml\n└── my_app.py\n</code></pre>\n<p>model/cnn.yaml：</p>\n<pre><code class=\"language-shell\">backbone: resnet50\nlearning_rate: 0.001\nbatch_size: 32\nepochs: 20\ndropout: 0.2\n</code></pre>\n<p>model/transformer.yaml：</p>\n<pre><code class=\"language-shell\">backbone: vit_base\nlearning_rate: 0.0001\nbatch_size: 16\nepochs: 30\nattention_heads: 12\n</code></pre>\n<p>所有配置文件已统一存放至conf目录，需通过config_path参数告知Hydra该目录位置，并在代码中指定待加载的配置文件名config_name。若未明确指定具体配置文件名，Hydra无法自动推断加载目标，最终会输出空配置:</p>\n<pre><code class=\"language-python\">from omegaconf import DictConfig, OmegaConf\nimport hydra\n\n@hydra.main(version_base=None, config_path=\"conf\", config_name=\"model/cnn\")\ndef my_app(cfg: DictConfig) -&gt; None:\n    print(OmegaConf.to_yaml(cfg))\n\nif __name__ == \"__main__\":\n    my_app()\n</code></pre>\n<p>也可以通过命令行从配置组中选择特定配置项，命令行使用<code>+分组名=配置项</code>的格式，例如：</p>\n<pre><code class=\"language-python\">python my_app.py +model=transformer\n</code></pre>\n<p>与常规用法一致，仍可覆盖最终配置中的单个参数值：</p>\n<pre><code class=\"language-python\">python my_app.py +model=transformer model.epochs=40\n</code></pre>\n<p><strong>多文件处理</strong></p>\n<p>可以生成一个配置文件，在配置文件中用<code>defaults</code>参数添加默认配置列表。该列表用于指定Hydra组合最终配置对象的规则，按照约定，它需作为配置文件的首个配置项。如下所示：</p>\n<pre><code class=\"language-shell\">defaults:\n  - model: cnn\n</code></pre>\n<p>然后这个配置文件可以命名为任意名字，如conf文件夹下的config.yaml，这样运行会默认加载model对应的文件配置：</p>\n<pre><code class=\"language-python\">from omegaconf import DictConfig, OmegaConf\nimport hydra\n\n@hydra.main(version_base=None, config_path=\"conf\", config_name=\"config\")\ndef my_app(cfg: DictConfig) -&gt; None:\n    print(OmegaConf.to_yaml(cfg))\n\nif __name__ == \"__main__\":\n    my_app()\n</code></pre>\n<p>默认配置列表支持叠加多个深度学习相关配置项。若同一配置组存在两个配置文件，系统会将这两个配置文件合并为一个新字典；当配置中出现相同键名时，后加载的配置项会覆盖先加载的配置项。示例默认配置如下：</p>\n<pre><code class=\"language-shell\">defaults:\n  - model: \n    - cnn\n    - transformer\n</code></pre>\n<p>若在配置文件夹conf下的dataset目录中，存在如下配置文件model/cifar10.yaml：</p>\n<pre><code class=\"language-shell\">name: CIFAR-10\npath: ./data/cifar10\nnum_classes: 10\nlearning_rate: 0.0001\naugmentation: true  # 是否开启数据增强\n</code></pre>\n<p>当默认配置文件conf/config.yaml中默认配置列表的内容如下：</p>\n<pre><code class=\"language-shell\">defaults:\n  - model: cnn\n  - dataset: cifar10 \n</code></pre>\n<p>由于model和dataset分属不同的配置组，Hydra会将这两个配置组的默认配置进行独立合并。最终生成的完整配置结构中，会包含model和dataset两个一级配置项，各自保留对应配置组的完整参数：</p>\n<pre><code class=\"language-shell\">model:\n  # 此处为conf/model/cnn.yaml中的配置内容\ndataset:\n  # 此处为conf/dataset/cifar10.yaml中的配置内容\n</code></pre>\n<p>即使设置了默认配置，仍可手动确定参数并覆盖部分配置参数：</p>\n<pre><code class=\"language-shell\">python my_app.py model=cnn model.epochs=30\n</code></pre>\n<p>在配置项前添加~前缀，可从默认配置列表中移除该默认项：</p>\n<pre><code class=\"language-shell\">python my_app.py ~model\n</code></pre>\n<p><strong>主配置的组合顺序</strong></p>\n<p>主配置文件中可同时包含配置参数和默认配置列表。在此情况下，若需调整默认配置列表与主配置之间的覆盖关系，可通过添加<code>_self_</code>关键字实现：将<code>_self_</code>置于默认配置列表末尾，则主配置参数将覆盖默认配置列表中的对应项；若将其置于列表开头，则默认配置列表中的参数将覆盖主配置中的内容。</p>\n<p>需注意的是，从Hydra 1.1版本开始，默认行为为主配置覆盖默认配置列表中的配置；而在此之前的版本中，默认配置列表会覆盖主配置的参数。</p>\n<p>例如默认配置文件config.yaml内容如下，会进行数据覆盖，也就是说配置文件里dataset部分会覆盖默认配置中的同名部分：</p>\n<pre><code class=\"language-shell\">defaults:\n  - model: cnn\n  - dataset: cifar10 \n  - _self_\n\ndataset: \n  name: my_dataset\nversion: 1.0\n</code></pre>\n<h2 id=\"12-整合应用\">1.2 整合应用</h2>\n<p>随着软件复杂度的不断提升，我们会采用模块化与组合化的设计思路来保证其可维护性。这种思路同样适用于配置文件的管理。假设我们需要为示例程序配置多类深度学习模型支持，且每个模型对应多种训练策略、搭配不同的数据预处理流程。使用Hydra时，既不必为模型、策略、预处理流程的各类组合编写独立类，也无需为其单独编写配置文件。我们可以借鉴底层软件开发的核心思路：通过组合化配置来解决这一问题。</p>\n<p><img alt=\"https://github.com/facebookresearch/hydra/blob/main/website/static/img/Hydra-plugins2.svg\" src=\"https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/%5Bpython%5D%20%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6Hydra%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/imgs/img2.svg\" /></p>\n<p><strong>多轮运行（Multi-run）</strong></p>\n<p>对于使用多套配置运行同一应用程序的场景，可以通过命令行或配置文件两种方式为Hydra应用启用多轮运行功能。该功能自Hydra 1.2版本起引入，通过设置hydra.mode配置项实现。hydra.mode的合法取值包括RUN（单次运行）和MULTIRUN（多轮运行）。若在输入配置中将hydra.mode设为MULTIRUN，应用程序将默认以多轮运行模式启动。</p>\n<p>例如默认配置文件为：</p>\n<pre><code class=\"language-python\">defaults:\n  - model: cnn\n  - dataset: cifar10 \n</code></pre>\n<p>多轮运行命令如下：</p>\n<pre><code class=\"language-python\">python my_app.py hydra.mode=MULTIRUN model=cnn,transformer dataset=cifar10\n</code></pre>\n<p>只要参数值用逗号分隔，就会被Hydra识别为多取值参数，Hydra会把所有带多个取值的参数做笛卡尔积（全组合），Hydra会把每个参数的取值两两配对，生成以下多个任务，依次运行：</p>\n<pre><code class=\"language-shell\">python my_app.py hydra.mode=MULTIRUN model=cnn,transformer dataset=cifar10\n# 本地启动2个任务\n#0 : model=cnn dataset=cifar10\n#1 : model=transformer dataset=cifar10\n</code></pre>\n<p>该命令可以用命令行参数简化：</p>\n<pre><code class=\"language-shell\">python my_app.py --multirun model=cnn,transformer dataset=cifar10\n# 或\npython my_app.py -m model=cnn,transformer dataset=cifar10\n</code></pre>\n<p>注意Hydra会在任务启动时延迟组合配置。若在启动任务参数遍历后修改代码或配置文件，最终组合生成的配置可能会受影响。</p>\n<p>也可以在输入配置中通过覆盖hydra.sweeper.params来定义参数遍历规则并通过mode设置运行模式。沿用上述示例，以下配置可实现完全相同的多轮运行效果：</p>\n<pre><code class=\"language-shell\">defaults:\n  - model: cnn\n  - dataset: cifar10 \n\nhydra:\n  mode: MULTIRUN # 设置运行模式\n  sweeper:\n    params:\n      dataset: cifar10\n      model: transformer, cnn\n</code></pre>\n<p>直接运行程序不使用任何附加参数，结果如下：</p>\n<pre><code class=\"language-shell\">$ python my_app.py\n# 本地启动2个任务\n#0 : model=transformer dataset=cifar10\n#1 : model=cnn dataset=cifar10\n</code></pre>\n<h2 id=\"13-信息管理\">1.3 信息管理</h2>\n<p><strong>输出目录</strong></p>\n<p>Hydra能够解决每次运行程序时需要手动指定新输出目录的问题，它会为每次运行自动创建一个专属目录，并在该输出目录中执行代码。默认情况下，每次运行应用程序时，都会生成一个全新的输出目录。可以通过读取Hydra配置来获取本次运行该输出目录的路径，示例如下：</p>\n<pre><code class=\"language-python\">from omegaconf import DictConfig, OmegaConf\nimport hydra\nimport os\n\n@hydra.main(version_base=None, config_path=\"conf\", config_name=\"config\")\ndef my_app(_cfg: DictConfig) -&gt; None:\n    print(f\"工作目录：{os.getcwd()}\")\n    print(f\"输出目录：{hydra.core.hydra_config.HydraConfig.get().runtime.output_dir}\")\n\nif __name__ == \"__main__\":\n    my_app()\n</code></pre>\n<p>通过设置hydra.job.chdir=True，可以让Hydra的<code>@hydra.main</code>装饰器在执行用户的主函数前，调用os.chdir将Python工作目录切换到输出目录：</p>\n<pre><code class=\"language-shell\">python my_app.py hydra.job.chdir=True\n</code></pre>\n<p>可以通过覆盖配置项hydra.output_subdir将设为null，则会完全禁用该子目录的创建。</p>\n<p><strong>日志</strong></p>\n<p>由于标准logging模块配置较为复杂，为实现常规的日志功能通常需要编写较多代码，且配置过程不够简便。Hydra能够自动完成Python logging的配置，从而有效解决这一问题。默认情况下，Hydra会以INFO级别向控制台输出日志，同时在当前工作目录自动生成日志文件留存记录。以下为使用Hydra进行日志记录的示例：</p>\n<pre><code class=\"language-python\"># hydra_log_demo.py\nimport logging\nfrom omegaconf import DictConfig\nimport hydra\n# 为本文件创建日志器\nlog = logging.getLogger(__name__)\n@hydra.main(version_base=None)\ndef my_app(_cfg: DictConfig) -&gt; None:\n    log.info(\"Info 级别日志消息\")\n    log.debug(\"Debug 级别日志消息\")\nif __name__ == \"__main__\":\n    my_app()\n</code></pre>\n<p>可通过在命令行中指定<code>hydra.verbose</code>配置项来启用DEBUG级别的日志输出。该配置项支持布尔值、字符串或列表类型的取值，开启全部或指定日志器的DEBUG级别输出如下：</p>\n<pre><code>python hydra_log_demo.py hydra.verbose=true\n</code></pre>\n<p>若要将特定函数对应日志器的级别设为DEBUG，可使用如下命令：</p>\n<pre><code>python hydra_log_demo.py hydra.verbose=\"[__main__,my_custom_logger]\"\n</code></pre>\n<p>其效果等同于代码：</p>\n<pre><code class=\"language-python\">import logging\nlogging.getLogger(NAME).setLevel(logging.DEBUG)\n</code></pre>\n<p>如果不希望Hydra自动配置日志系统，可以将hydra/job_logging（对应程序的日志）和hydra/hydra_logging（对应Hydra框架自身的日志）均设为none：</p>\n<pre><code class=\"language-python\">python my_app.py hydra/job_logging=None hydra/hydra_logging=None\n</code></pre>\n<p><strong>调试功能</strong></p>\n<p>Hydra提供多种配置选项，可有效提升程序的可调试性。在命令行中使用<code>--cfg</code>或<code>-c</code>参数，即可在不运行目标函数的情况下打印应用程序的配置信息。该参数需配合一个选项来指定打印的配置范围：</p>\n<ul>\n<li>job：打印业务代码的配置</li>\n<li>hydra：打印hydra框架自身的配置</li>\n<li>all：打印完整配置内容，即业务配置与hydra配置的合集</li>\n</ul>\n<p>仅打印业务配置指令如下：</p>\n<pre><code class=\"language-bash\">$ python my_app.py --cfg job\n</code></pre>\n<p>若只展示配置中的某一子集，可搭配参数<code>--package</code>或简写<code>-p</code>使用：</p>\n<pre><code class=\"language-bash\">python my_app.py --cfg hydra --package hydra.job\n</code></pre>\n<p>默认情况下，配置中的插值表达式不会被解析。若需打印解析后的最终配置，可在<code>--cfg</code>参数基础上，额外添加<code>--resolve</code>参数。</p>\n<p><strong>信息查询功能</strong></p>\n<p>使用<code>--info</code>参数可查询Hydra框架及应用程序的各类相关信息：</p>\n<ul>\n<li>--info all：默认模式，打印所有可用信息</li>\n<li>--info config：打印配置组合相关的辅助信息，包括：配置搜索路径、默认配置树、默认配置列表及最终生效的配置内容</li>\n<li>--info defaults：打印最终的默认配置列表</li>\n<li>--info defaults-tree：打印默认配置树结构</li>\n<li>--info plugins：打印已安装的插件信息</li>\n</ul>\n<h1 id=\"2-结构化配置\">2 结构化配置</h1>\n<p>在复杂项目中，配置文件常面临类型模糊、配置错误难排查、缺少静态校验等问题。例如：字段类型不明确易引发运行时异常、多层级配置的结构一致性难以保障、协作时难以通过工具提前发现配置冲突。</p>\n<p><img alt=\"https://github.com/facebookresearch/hydra/blob/main/website/static/img/undraw_product_teardown_hydra_plain.svg\" src=\"https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/%5Bpython%5D%20%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6Hydra%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/imgs/img3.svg\" /></p>\n<p>为此，Hydra基于Python数据类（dataclasses）定义了配置结构与类型，其核心价值在于提供运行时类型检查与静态类型检查双重保障。它支持基础类型（int、str、bool、float、Enum 等）、嵌套结构、容器类型（List、Dict）以及可选字段，但也存在部分限制，例如仅部分支持联合类型，且不支持自定义方法。</p>\n<p>Hydra中结构化配置主要有两种使用模式，均完整保留其核心功能：</p>\n<ol>\n<li>直接作为配置使用（替代配置文件），适合快速入门；</li>\n<li>作为配置模式（schema）使用，用于校验现有配置文件，适合大型或协作项目。</li>\n</ol>\n<p>本教程将按此顺序依次详解两种模式。</p>\n<h2 id=\"21-hydra代码配置\">2.1 Hydra代码配置</h2>\n<p>在后续的教程中，我们将使用ConfigStore类把数据类（dataclasses）注册为Hydra中的输入配置。ConfigStore是一个在内存中存储配置的单例（singleton）对象，与它交互的核心API是下文将要介绍的store方法。</p>\n<pre><code class=\"language-python\">class ConfigStore(metaclass=Singleton):\n    def store(\n        self,\n        name: str,\n        node: Any,\n        group: Optional[str] = None,\n        package: Optional[str] = \"_group_\",\n        provider: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        将配置节点存储至配置仓库中\n        :param name: 配置名称\n        :param node: 配置节点，支持 DictConfig、ListConfig、\n            结构化配置（Structured configs），甚至普通的 dict 和 list 类型\n        :param group: 配置分组，子分组分隔符为 '/'，\n            例如 hydra/launcher\n        :param package: 配置节点的父级层级结构。\n            子节点分隔符为 '.'，例如 foo.bar.baz\n        :param provider: 提供该配置的模块/应用名称，\n            有助于调试排查问题。\n        \"\"\"\n    ...\n</code></pre>\n<p>ConfigStore具备与YAML输入配置完全一致的功能，除此之外还提供类型校验能力。它既可单独使用，也可与YAML配合使用。</p>\n<p><strong>基础用例</strong></p>\n<p>假设我们有一个简单的应用程序，且存在一个包含cnn选项的model配置分组：</p>\n<pre><code class=\"language-python\">from omegaconf import DictConfig, OmegaConf\nimport hydra\n\n@hydra.main(version_base=None, config_path=\"conf\", config_name=\"model/cnn\")\ndef my_app(cfg: DictConfig) -&gt; None:\n    print(OmegaConf.to_yaml(cfg))\n\nif __name__ == \"__main__\":\n    my_app()\n</code></pre>\n<p>目录结构：</p>\n<pre><code>├─ conf\n│  └─ model\n│      └─ cnn.yaml\n└── my_app.py\n</code></pre>\n<p>model/cnn.yaml：</p>\n<pre><code class=\"language-yaml\">backbone: resnet50\nlearning_rate: 0.001\nbatch_size: 32\nepochs: 20\ndropout: 0.2\n</code></pre>\n<p>如果现在想要新增一个transformer选项该怎么做？我们可以直接新增<code>model/transformer.yaml</code>配置分组文件，但这并非唯一方式！也可以通过ConfigStore为Hydra新增model配置分组的transformer选项。</p>\n<p>要实现这个需求，只需在上述代码文件中添加几行代码：</p>\n<pre><code class=\"language-python\">from dataclasses import dataclass\nimport hydra\nfrom omegaconf import DictConfig, OmegaConf\nfrom hydra.core.config_store import ConfigStore\n@dataclass\nclass TransformerConfig:\n    optimizer: str = \"sgd\"\n    lr: float = 0.0005\n    hidden_dim: int = 256\n\ncs = ConfigStore.instance()\n# 将名为transformer的配置类注册至model配置分组\n# 注意出现实体文件会报错\ncs.store(name=\"transformer\", group=\"model\", node=TransformerConfig)\n\n@hydra.main(version_base=None, config_path=\"conf\")\ndef my_app(cfg: DictConfig) -&gt; None:\n    print(OmegaConf.to_yaml(cfg))\n\nif __name__ == \"__main__\":\n    my_app()\n</code></pre>\n<p>上述代码不会生成实际的物理配置文件，它仅用于在内存中注册配置类。现在应用程序已经能够识别model配置组中的两个选项，您可以通过以下命令运行程序来验证效果：</p>\n<pre><code class=\"language-bash\">python my_app.py +model=cnn\n</code></pre>\n<p>或</p>\n<pre><code class=\"language-bash\">python my_app.py +model=transformer\n</code></pre>\n<p>在深度学习实验中管理多个模型配置时，我们还可以借助ConfigStore支持的三种注册方式灵活控制配置节点，实现不同方案间的快速切换：</p>\n<pre><code class=\"language-python\">from dataclasses import dataclass\nimport hydra\nfrom omegaconf import DictConfig, OmegaConf\nfrom hydra.core.config_store import ConfigStore\n\n@dataclass\nclass TransformerConfig:\n    optimizer: str = \"sgd\"\n    lr: float = 0.0005\n    hidden_dim: int = 256\n\ncs = ConfigStore.instance()\n\n# 直接使用类类型\ncs.store(name=\"config1\", node=TransformerConfig)\n# 使用类实例（覆盖部分默认值）\ncs.store(name=\"config2\", node=TransformerConfig(optimizer=\"rmsprop\", lr=0.002))\n# 使用字典（会失去运行时类型安全保障）\ncs.store(name=\"config3\", node={\"optimizer\": \"adam\", \"lr\": 0.003, \"hidden_dim\": 256})\n\n# 3. Hydra主函数：加载并打印配置\n@hydra.main(version_base=None, config_name=\"config1\")  # 默认加载config1\ndef main(cfg: DictConfig) -&gt; None:\n    print(\"当前加载的配置内容：\")\n    print(cfg)  \n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<p><strong>配置组</strong></p>\n<p>在Hydra框架中，配置组是一种用于组织互斥但相关配置项的机制。以深度学习场景为例，训练CNN与Transformer属于不同的模型配置，它们都属于模型配置这一大类，但一次训练只能选择其中一种，这就是配置组的典型应用。</p>\n<pre><code class=\"language-python\"># 导入必要的库\nfrom dataclasses import dataclass \nfrom typing import Any           \nimport hydra                   \nfrom hydra.core.config_store import ConfigStore \nfrom omegaconf import OmegaConf  \n\n# 1. 定义CNN模型的配置\n@dataclass  # 装饰器：将普通类转为结构化配置类（自动生成初始化、比较等方法）\nclass CNNConfig:\n    \"\"\"CNN模型的训练配置（包含该模型特有的所有参数）\"\"\"\n    model_type: str = \"cnn\"      \n    batch_size: int = 32          \n    learning_rate: float = 0.001  \n\n# 2. 定义Transformer模型的配置\n@dataclass\nclass TransformerConfig:\n    \"\"\"Transformer模型的训练配置（包含该模型特有的所有参数）\"\"\"\n    model_type: str = \"transformer\" \n    batch_size: int = 16            \n    learning_rate: float = 0.0001  \n    num_heads: int = 8         \n \n@dataclass\nclass Config:\n    \"\"\"整个训练程序的主配置类\"\"\"\n    # model字段：用于接收配置组中选择的模型配置（暂时标注为Any类型）\n    model: Any\n\n# 1. 获取配置存储库的单例实例（整个程序只有一个ConfigStore）\ncs = ConfigStore.instance()\n\n# 2. 注册主配置（名称为\"config\"，对应后续hydra.main的config_name）\ncs.store(name=\"config\", node=Config)\n\n# 3. 注册配置组：组名是\"model\"，包含两个选项：\ncs.store(group=\"model\", name=\"cnn\", node=CNNConfig)\ncs.store(group=\"model\", name=\"transformer\", node=TransformerConfig)\n\n# hydra.main装饰器：标记程序入口，指定配置名称为\"config\"\n@hydra.main(version_base=None, config_name=\"config\")\ndef train_model(cfg: Config) -&gt; None:\n    \"\"\"深度学习模型训练的主函数\"\"\"\n    print(\"===== 当前使用的训练配置 =====\")\n    print(OmegaConf.to_yaml(cfg))\n\n# 程序启动入口\nif __name__ == \"__main__\":\n    train_model()\n</code></pre>\n<p>代码运行直接输出为：</p>\n<pre><code>model: ???\n</code></pre>\n<p>??? 表示：该字段本应有值，但目前处于缺失状态。由于我们未给模型配置组设置默认值，因此必须通过命令行显式指定要使用的模型配置。注意命令中的+是必需的，因为模型配置组没有默认值，+在这里表示添加并覆盖该配置字段：</p>\n<pre><code class=\"language-python\">python my_app.py +model=cnn\n</code></pre>\n<p>在上面实现中，model字段被标注为Any类型，这虽然不会阻碍程序运行，但却把配置对象当作一个缺乏类型信息的黑箱字典，使得IDE无法提供智能提示，静态类型检查也完全失效，从而降低了代码的可维护性和长期可靠性。要解决这一问题，解决方法是将不同模型配置之间的公共字段进行抽象，创建一个BaseModelConfig基础配置类：</p>\n<pre><code class=\"language-python\">from dataclasses import dataclass\nfrom typing import Any\nimport hydra\nfrom omegaconf import MISSING  # 标记字段“无默认值”\nfrom hydra.core.config_store import ConfigStore \nfrom omegaconf import OmegaConf  \n\n@dataclass\nclass BaseModelConfig:\n    \"\"\"所有深度学习模型的基础配置（抽离公共字段）\"\"\"\n    model_type: str = MISSING       # 模型类型：无默认值（必须由子类指定）\n    batch_size: int = 32            # 公共字段：默认批次大小（子类可重写）\n    learning_rate: float = 0.001    # 公共字段：默认学习率（子类可重写）\n\n# 1. 定义CNN模型的配置\n@dataclass  # 装饰器：将普通类转为结构化配置类（自动生成初始化、比较等方法）\nclass CNNConfig(BaseModelConfig):\n    \"\"\"CNN模型的训练配置（包含该模型特有的所有参数）\"\"\"\n    model_type: str = \"cnn\"      \n    batch_size: int = 32          \n    learning_rate: float = 0.001  \n\n# 2. 定义Transformer模型的配置\n@dataclass\nclass TransformerConfig(BaseModelConfig):\n    \"\"\"Transformer模型的训练配置（包含该模型特有的所有参数）\"\"\"\n    model_type: str = \"transformer\" \n    batch_size: int = 16            \n    learning_rate: float = 0.0001   \n    num_heads: int = 8         \n\n@dataclass\nclass Config:\n    \"\"\"整个训练程序的主配置类\"\"\"\n    # 不再是Any，而是BaseModelConfig\n    model: BaseModelConfig\n\n# 1. 获取配置存储库的单例实例（整个程序只有一个ConfigStore）\ncs = ConfigStore.instance()\n\n# 2. 注册主配置（名称为\"config\"，对应后续hydra.main的config_name）\ncs.store(name=\"config\", node=Config)\n\n# 3. 注册配置组：组名是\"model\"，包含两个选项：\ncs.store(group=\"model\", name=\"cnn\", node=CNNConfig)\ncs.store(group=\"model\", name=\"transformer\", node=TransformerConfig)\n\n# hydra.main装饰器：标记程序入口，指定配置名称为\"config\"\n@hydra.main(version_base=None, config_name=\"config\")\ndef train_model(cfg: Config) -&gt; None:\n    \"\"\"深度学习模型训练的主函数\"\"\"\n    print(\"===== 当前使用的训练配置 =====\")\n    print(OmegaConf.to_yaml(cfg))\n\n# 程序启动入口\nif __name__ == \"__main__\":\n    train_model()\n</code></pre>\n<p>可以在主结构化配置中设置默认值，方法与在config.yaml配置文件中定义相似。以下是一个深度学习模型配置的示例，新增了默认配置列表，使其默认加载model=cnn。只需在代码中添加默认列表，并相应修改配置类即可：</p>\n<pre><code class=\"language-python\">from dataclasses import dataclass, field\nfrom typing import Any, List       \n\n# 定义默认配置列表：从配置组\"model\"中加载名为\"cnn\"的配置\ndefaults = [\n    {\"model\": \"cnn\"}\n    # 设为 MISSING，则可强制用户在命令行中指定该参数的值。\n    # {\"model\": MISSING}\n]\n\n@dataclass\nclass Config:\n    \"\"\"整个训练程序的主配置类\"\"\"\n    # 受@dataclass限制，此处需通过field定义默认配置列表（默认加载cnn配置）\n    defaults: List[Any] = field(default_factory=lambda: defaults)\n    # Hydra会根据默认配置列表自动填充该字段，类型为BaseModelConfig\n    model: BaseModelConfig = MISSING\n</code></pre>\n<p>你也可以通过命令行覆盖默认配置，指定使用Transformer模型，注意不要+号，因为这是覆盖操作：</p>\n<pre><code class=\"language-shell\">python my_app.py model=transformer\n</code></pre>\n<h2 id=\"22-配置模式\">2.2 配置模式</h2>\n<p>Hydra的结构化配置本质是用代码定义的结构化规则来管理配置。它除了可以用代码定义的结构化配置替代传统的YAML配置文件外，还能将结构化配置作为配置规则模板（Schema），用于校验已有YAML配置文件是否符合规范。Schema能够在程序启动时校验配置的合法性，提前拦截所有配置错误。这对于保障大型项目的稳定性至关重要，尤其适合多人协作的场景，可以有效避免配置错写、漏写字段等问题。</p>\n<p><strong>同一配置组内的Schema校验</strong></p>\n<p>以深度学习训练场景的模型配置为例，下文将拆解如何通过预设的Schema模板，校验同一配置分组下各配置文件的字段、类型等是否符合规范要求。</p>\n<p>给定如下配置目录结构：</p>\n<pre><code class=\"language-shell\">conf/\n├── config.yaml          # 主配置（包含训练、模型、数据等）\n└── model                # 模型配置组\n    ├── resnet.yaml      # ResNet模型配置\n    └── transformer.yaml # Transformer模型配置\n</code></pre>\n<p>需为上述每个配置文件添加结构化配置Schema，核心方式是在YAML文件的defaults列表中声明要继承的Schema模板，并将这些Schema以base_config、model/resnet.yaml、model/transformer.yaml为名注册至Hydra配置仓库。各配置文件的defaults列表配置如下：</p>\n<p>config.yaml：</p>\n<pre><code class=\"language-shell\">defaults:\n  - base_config          # 继承基础配置Schema\n  - model: resnet        # 默认使用ResNet模型配置\n  - _self_               # 自身配置覆盖默认值\n\n# 自定义训练参数\ntrain:\n  batch_size: 32\n  lr: 0.001\ndebug: true\n</code></pre>\n<p>model/resnet.yaml：</p>\n<pre><code class=\"language-shell\">defaults:\n  - base_resnet  # 继承ResNet基础Schema\n\n# ResNet专属参数\nlayers: 50\npretrained: true\nnum_classes: 1000\n</code></pre>\n<p>model/transformer.yaml：</p>\n<pre><code class=\"language-shell\">defaults:\n  - base_transformer  # 继承Transformer基础Schema\n\n# Transformer专属参数\nnum_heads: 8\nnum_layers: 6\nhidden_dim: 512\nmax_seq_len: 512\n</code></pre>\n<p>通过Python dataclass定义各种Schema规则，并注册到Hydra配置仓库，使YAML配置文件可关联到对应的校验规则：</p>\n<pre><code class=\"language-python\">from dataclasses import dataclass\nfrom omegaconf import OmegaConf, MISSING\nimport hydra\nfrom hydra.core.config_store import ConfigStore\n\n# -------------------------- 基础Schema定义 --------------------------\n@dataclass\nclass BaseModelConfig:\n    \"\"\"所有模型的基础配置Schema\"\"\"\n    model_type: str = MISSING  # 必选字段，无默认值\n    device: str = \"cuda\"       # 可选字段，默认值cuda\n    dropout: float = MISSING   # 必选字段，无默认值\n\n@dataclass\nclass ResNetConfig(BaseModelConfig):\n    \"\"\"ResNet模型专属Schema（继承基础模型配置）\"\"\"\n    model_type: str = \"resnet\"  # 固定值，标识模型类型\n    dropout: float = 0.1        # 覆盖默认值\n    layers: int = MISSING       # ResNet专属必选字段\n    pretrained: bool = MISSING\n    num_classes: int = MISSING\n\n@dataclass\nclass TransformerConfig(BaseModelConfig):\n    \"\"\"Transformer模型专属Schema（继承基础模型配置）\"\"\"\n    model_type: str = \"transformer\"  # 固定值\n    dropout: float = 0.1             # 覆盖默认值\n    num_heads: int = MISSING         # Transformer专属必选字段\n    num_layers: int = MISSING\n    hidden_dim: int = MISSING\n    max_seq_len: int = MISSING\n\n@dataclass\nclass TrainConfig:\n    \"\"\"训练配置Schema\"\"\"\n    batch_size: int = MISSING\n    lr: float = MISSING\n    epochs: int = 10  # 默认训练10轮\n\n@dataclass\nclass Config:\n    \"\"\"整体配置Schema\"\"\"\n    model: BaseModelConfig = MISSING  # 模型配置（必选）\n    train: TrainConfig = MISSING     # 训练配置（必选）\n    debug: bool = False              # 调试模式（可选）\n\n# -------------------------- 注册Schema到配置仓库 --------------------------\ncs = ConfigStore.instance()\ncs.store(name=\"base_config\", node=Config)  # 注册主配置Schema\ncs.store(group=\"model\", name=\"base_resnet\", node=ResNetConfig)  # 注册ResNet Schema\ncs.store(group=\"model\", name=\"base_transformer\", node=TransformerConfig)  # 注册Transformer Schema\n\n# -------------------------- 主函数 --------------------------\n@hydra.main(version_base=None, config_path=\"conf\", config_name=\"config\")\ndef train_app(cfg: Config) -&gt; None:\n    \"\"\"深度学习训练入口，打印最终配置\"\"\"\n    print(\"最终训练配置：\")\n    print(OmegaConf.to_yaml(cfg))\n\nif __name__ == \"__main__\":\n    train_app()\n</code></pre>\n<p>运行代码时，Hydra会先加载YAML配置文件，再通过关联的Schema完成合法性校验，若配置存在错误会立即抛出异常：</p>\n<pre><code class=\"language-shell\"># 正常运行（使用默认ResNet配置）\npython my_app.py\n\n# 模拟配置错误（layers字段应为int类型，传入字符串触发校验失败）\npython my_app.py model.layers='attention' \n</code></pre>\n<p><strong>跨配置组的Schema校验</strong></p>\n<p>在前文的模型训练场景中，Schema都定义在主程序里。但实际开发中，常会遇到第三方库提供标准化的Schema，我们需要跨配置组引用这些Schema来校验自己的配置文件，而非把所有Schema都写在主程序中。</p>\n<p>假设存在一个公共的optimizer_lib库，该库预先定义了所有模型的标准Schema并注册在独立配置组中；本地conf/optimizer配置组下的YAML文件（如sgd.yaml、adam.yaml）仅需编写YAML配置文件，并关联这个外部库的Schema完成校验，无需重复定义模型规则，配置目录结构如下：</p>\n<pre><code class=\"language-shell\"># 项目整体目录\n├── my_app.py               # 主程序\n├── optimizer_lib.py        # 独立的优化器Schema库\n└── conf/\n    ├── config.yaml         # 主配置\n    └── optimizer/          # 本地优化器配置组\n        ├── sgd.yaml        \n        └── adam.yaml       \n</code></pre>\n<p>optimizer_lib.py代码如下：</p>\n<pre><code class=\"language-python\">from dataclasses import dataclass\nfrom omegaconf import MISSING\nfrom hydra.core.config_store import ConfigStore\n\n# -------------------------- 优化器基础Schema --------------------------\n@dataclass\nclass BaseOptimizerConfig:\n    \"\"\"所有优化器的基础Schema（独立库定义）\"\"\"\n    opt_type: str = MISSING    # 必选字段：优化器类型\n    lr: float = MISSING        # 必选字段：学习率\n    weight_decay: float = 0.0  # 可选字段：权重衰减，默认0\n\n# -------------------------- 具体优化器Schema --------------------------\n@dataclass\nclass SGDConfig(BaseOptimizerConfig):\n    \"\"\"SGD优化器专属Schema\"\"\"\n    opt_type: str = \"sgd\"      # 固定标识\n    momentum: float = MISSING  # SGD专属必选字段\n    nesterov: bool = False     # 可选字段：是否使用Nesterov动量\n\n@dataclass\nclass AdamConfig(BaseOptimizerConfig):\n    \"\"\"Adam优化器专属Schema\"\"\"\n    opt_type: str = \"adam\"     # 固定标识\n    betas: tuple[float, float] = (0.9, 0.999)  # 可选字段：beta参数\n    eps: float = MISSING                       # Adam专属必选字段\n\n# -------------------------- 注册跨配置组的Schema --------------------------\ndef register_optimizer_configs() -&gt; None:\n    cs = ConfigStore.instance()\n    # 注册到独立分组：optimizer_lib/optimizer\n    cs.store(\n        group=\"optimizer_lib/optimizer\",\n        name=\"sgd\",\n        node=SGDConfig\n    )\n    cs.store(\n        group=\"optimizer_lib/optimizer\",\n        name=\"adam\",\n        node=AdamConfig\n    )\n</code></pre>\n<p>主程序my_app.py中定义整体配置Schema，并调用optimizer_lib的注册函数，将跨配置组的Schema纳入Hydra配置仓库：</p>\n<pre><code class=\"language-python\">from dataclasses import dataclass\nfrom omegaconf import MISSING, OmegaConf\nimport hydra\nfrom hydra.core.config_store import ConfigStore\nimport optimizer_lib  # 导入独立的优化器库\n\n# -------------------------- 整体配置Schema --------------------------\n@dataclass\nclass TrainConfig:\n    \"\"\"训练配置Schema\"\"\"\n    batch_size: int = 32\n    epochs: int = 10\n\n@dataclass\nclass Config:\n    \"\"\"主配置Schema\"\"\"\n    optimizer: optimizer_lib.BaseOptimizerConfig = MISSING  # 引用独立库的Schema\n    train: TrainConfig = MISSING\n    debug: bool = False\n\n# -------------------------- 注册本地Schema并加载跨组Schema --------------------------\ncs = ConfigStore.instance()\ncs.store(name=\"base_config\", node=Config)  # 注册主配置Schema\noptimizer_lib.register_optimizer_configs()  # 注册跨配置组的优化器Schema\n\n# -------------------------- 主函数 --------------------------\n@hydra.main(version_base=None, config_path=\"conf\", config_name=\"config\")\ndef train_app(cfg: Config) -&gt; None:\n    \"\"\"训练入口，打印最终配置并触发Schema校验\"\"\"\n    print(\"最终训练配置（含跨组优化器配置）：\")\n    print(OmegaConf.to_yaml(cfg))\n\nif __name__ == \"__main__\":\n    train_app()\n</code></pre>\n<p>本地conf/optimizer下的YAML文件需要通过绝对路径引用optimizer_lib中的Schema，并通过<code>@_here_</code>指定包路径，确保Schema的校验作用域与当前配置一致。</p>\n<p>conf/optimizer/sgd.yaml：</p>\n<pre><code class=\"language-shell\">defaults:\n  - /optimizer_lib/optimizer/sgd@_here_  # 绝对路径引用跨组Schema，@_here_统一包作用域\n\n# SGD专属配置（需符合SGDConfig的Schema规则）\nlr: 0.01\nmomentum: 0.9\nweight_decay: 0.0001\n</code></pre>\n<p>conf/optimizer/adam.yaml：</p>\n<pre><code class=\"language-shell\">defaults:\n  - /optimizer_lib/optimizer/adam@_here_  # 绝对路径引用跨组Schema\n  - _self_  # 自身配置覆盖Schema默认值（组合顺序：Schema先加载，自身配置后覆盖）\n\n# Adam专属配置（需符合AdamConfig的Schema规则）\nlr: 0.001\nbetas: (0.9, 0.999)\neps: 1e-08\nweight_decay: 0.0005\n</code></pre>\n<p>主配置conf/config.yaml：</p>\n<pre><code class=\"language-shell\">defaults:\n  - base_config          # 主配置Schema\n  - optimizer: sgd      # 默认使用SGD优化器配置\n  - _self_\n\n# 自定义训练参数\ntrain:\n  batch_size: 64\n  epochs: 20\ndebug: true\n</code></pre>\n<p>运行代码时，Hydra会先加载第三方库的Schema，再校验本地YAML配置：</p>\n<pre><code class=\"language-python\"># 正常运行（SGD配置符合Schema规则）\npython my_app.py\n\n# 配置错误（momentum应为float，传入字符串触发校验失败）\npython my_app.py optimizer.momentum='high'\n\n# 配置错误（Adam必选字段eps缺失，启动时直接报错）\npython my_app.py optimizer=adam optimizer.eps=none\n</code></pre>\n<h1 id=\"3-参考\">3 参考</h1>\n<ul>\n<li><a href=\"https://github.com/facebookresearch/hydra\" rel=\"noopener nofollow\" target=\"_blank\">hydra</a></li>\n<li><a href=\"https://hydra.cc/docs/intro/\" rel=\"noopener nofollow\" target=\"_blank\">Hydra-doc</a></li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/luohenyueji/\" target=\"_blank\">落痕的寒假</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/luohenyueji/p/19444783\" target=\"_blank\">https://www.cnblogs.com/luohenyueji/p/19444783</a></p>\n\n<div style=\"text-align: center;\">\n    <img src=\"https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/wechat/content/%E5%8A%A0%E6%B2%B9%E9%B8%AD.gif\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 21:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/luohenyueji\">落痕的寒假</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一文入门 Spring Security with 单点登录(jasig)",
      "link": "https://www.cnblogs.com/dddy/p/19444770",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/dddy/p/19444770\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 21:24\">\n    <span>一文入门 Spring Security with 单点登录(jasig)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>2018-6-18</p>\n<p>[[后端栈/Java SE/Java]]</p>\n<h1 id=\"spring-security-是什么\">Spring Security 是什么?</h1>\n<p>人们使用Spring Secruity的原因有很多, 单大部分都发现了javaEE的Servlet规范或EJB规范中的安全功能缺乏典型企业应用场景所需的深度;<br />\n提到这些规范, 重要的是要认识到他们在WAR或EAR级别无法移植; 因此如果你更换服务器环境, 这里有典型的大量工作去重新配置你的应用程序员安全到新的目标环境; 使用Spring Security 解决了这些问题, 也为你提供许多其他有用的, 可定制的安全功能;</p>\n<p>正如你可能知道的两个应用程序的两个主要区域是\"认证\"和\"授权\"（或者访问控制）; 这两个主要区域是Spring Security 的两个目标; \"认证\", 是建立一个他声明的主题的过程（一个\"主体\"一般是指用户, 设备或一些可以在你的应用程序中执行动作的其他系统）; \"授权\"指确定一个主体是否允许在你的应用程序执行一个动作的过程; 为了抵达需要授权的店, 主体的身份已经有认证过程建立; 这个概念是通用的而不只在Spring Security中;</p>\n<blockquote>\n<p>参考: <a href=\"https://springcloud.cc/spring-security-zhcn.html#what-is-acegi-security\" rel=\"noopener nofollow\" target=\"_blank\">中文文档</a><br />\n<a href=\"https://docs.spring.io/spring-security/site/docs/4.2.7.RELEASE/reference/htmlsingle/#what-is-acegi-security\" rel=\"noopener nofollow\" target=\"_blank\">英文文档 4.2</a></p>\n</blockquote>\n<h1 id=\"spring-3x-mvc--security\">Spring 3.X MVC + Security</h1>\n<p>copy of xxx 的一些jar包的版本<br />\nspring core = 3.0.5<br />\nspring security core = 3.0.5<br />\nspring web = 3.0.5</p>\n<h2 id=\"for-maven\">For maven</h2>\n<p>Maven项目 如果tomcat不加载maven lib, 右键项目 <code>Web Deployment Assembly</code>加进去</p>\n<p>完整配置.</p>\n<pre><code class=\"language-xml\"> &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n\n&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n&lt;groupId&gt;myproject&lt;/groupId&gt;\n&lt;artifactId&gt;springsecurity&lt;/artifactId&gt;\n&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n&lt;packaging&gt;war&lt;/packaging&gt;\n&lt;name&gt;springsecurity&lt;/name&gt;\n\n&lt;dependencies&gt;\n    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n        &lt;version&gt;3.0.5.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n        &lt;version&gt;3.0.5.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- spring security --&gt;\n   &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt;\n         &lt;version&gt;3.0.5.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;\n         &lt;version&gt;3.0.5.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;\n         &lt;version&gt;3.0.5.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;\n         &lt;version&gt;3.0.5.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n            &lt;version&gt;3.1&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;source&gt;1.7&lt;/source&gt;\n                &lt;target&gt;1.7&lt;/target&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;\n            &lt;version&gt;2.4&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;warSourceDirectory&gt;webapp&lt;/warSourceDirectory&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre>\n<ul>\n<li>写一个控制器</li>\n</ul>\n<pre><code class=\"language-java\">@Controller\n@RequestMapping(\"/user\")\npublic class UserController {\n    \n    \n    @RequestMapping(value = \"/login\")\n    public ModelAndView login() {\n        System.out.println(\"login\");\n        ModelAndView model = new ModelAndView();\n        model.addObject(\"title\", \"login\");\n        model.addObject(\"message\", \"This is hello page!\");\n        model.setViewName(\"login\");\n        \n        return model;\n\n    }\n    \n    \n    @RequestMapping(value = { \"/\", \"/welcome\" }, method = RequestMethod.GET)\n    public ModelAndView welcomePage() {\n        System.out.println(\"welcomePage\");\n        ModelAndView model = new ModelAndView();\n        model.addObject(\"title\", \"Spring  Hello World\");\n        model.addObject(\"message\", \"This is welcome page!\");\n        model.setViewName(\"hello\");\n        \n        return model;\n    }\n    @RequestMapping(value = \"/admin\", method = RequestMethod.GET)\n    public ModelAndView adminPage() {\n        System.out.println(\"adminPage\");\n        ModelAndView model = new ModelAndView();\n        model.addObject(\"title\", \"Spring  Hello World\");\n        model.addObject(\"message\", \"This is protected page!\");\n        model.setViewName(\"admin\");\n        \n        return model;\n\n    }\n}\n\n</code></pre>\n<blockquote>\n<p>两个公开页面hello 不需要限制, 而admin 需要限制访问</p>\n</blockquote>\n<ul>\n<li>在web.xml增加spring Security过滤器</li>\n</ul>\n<pre><code class=\"language-xml\">&lt;filter&gt;\n    &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;\n&lt;/filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;\n</code></pre>\n<ul>\n<li>spring Security配置<br />\n在spring-mvc.xml引入命名空间(xmlns:security), 一般而言都是单独一个<code>applicationContext-security.xml</code>文件, 在初始spring ioc的时候引入</li>\n</ul>\n<pre><code class=\"language-xml\">&lt;listener&gt;\n    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n&lt;/listener&gt;\n&lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    &lt;param-value&gt;classpath:applicationContext.xml,classpath:applicationContext-security.xml&lt;/param-value&gt;\n&lt;/context-param&gt;\n</code></pre>\n<ul>\n<li>spring Security的简单配置</li>\n</ul>\n<pre><code class=\"language-xml\">省略..头部.\n&lt;security:http auto-config=\"true\"&gt;\n    &lt;security:form-login login-page=\"/login.jsp\" default-target-url=\"/springsecurity/user/admin.htm\" /&gt;\n    &lt;!-- 表示匿名用户可以访问 --&gt;\n    &lt;security:intercept-url pattern=\"/login.jsp\" access=\"IS_AUTHENTICATED_ANONYMOUSLY\"/&gt;\n    &lt;security:intercept-url pattern=\"/user/welcome*\" access=\"IS_AUTHENTICATED_ANONYMOUSLY\"/&gt;\n    &lt;!-- 访问下面URL需要 ROLE_USER 权限 --&gt;\n    &lt;security:intercept-url pattern=\"/**\" access=\"ROLE_USER\" /&gt;\n&lt;/security:http&gt;\n&lt;security:authentication-manager&gt;\n    &lt;security:authentication-provider&gt;\n        &lt;security:user-service&gt;\n            &lt;security:user name=\"user\" password=\"user\" authorities=\"ROLE_USER\"/&gt;\n            &lt;security:user name=\"admin\" password=\"admin\" authorities=\"ROLE_USER, ROLE_ADMIN\"/&gt;\n        &lt;/security:user-service&gt;\n    &lt;/security:authentication-provider&gt;\n&lt;/security:authentication-manager&gt;\n\n&lt;/beans&gt; \n</code></pre>\n<h2 id=\"测试\">测试</h2>\n<ul>\n<li>访问任何一个能被springSecurityFilterChain拦截的url 即可看到登陆页面</li>\n</ul>\n<p><img alt=\"20180710183503\" class=\"lazyload\" /></p>\n<blockquote>\n<p>使用上<code>&lt;security:user-service&gt;</code>元素配置的用户名跟密码即可登陆<br />\n登陆后 访问<code>&lt;a href=\"../j_spring_security_logout\" /&gt; Logout&lt;/a&gt;</code>退出</p>\n</blockquote>\n<h1 id=\"认证过程\">认证过程</h1>\n<p>Spring Security, 这是一种基于 Spring AOP 和 Servlet 过滤器的安全框架;</p>\n<p>Spring Security的核心类主要包括以下几个：<br />\n<code>SecurityContextHolder</code>: 存放身份信息的容器<br />\n<code>Authentication</code>: 身份信息的抽象接口<br />\n<code>AuthenticationManager</code> : 身份认证器，认证的核心接口<br />\n<code>UserDetailsService</code> ： 一般用于从数据库中加载身份信息<br />\n<code>UserDetails</code> : 相比 Authentication，有更详细的身份信息</p>\n<ol>\n<li>用户使用用户名和密码进行登录;</li>\n<li>Spring Security 将获取到的用户名和密码封装成一个实现了 Authentication 接口的 <code>UsernamePasswordAuthenticationToken; </code></li>\n<li>将上述产生的 token 对象传递给 <code>AuthenticationManager</code> 进行登录认证;</li>\n<li><code>AuthenticationManager</code> 认证成功后将会返回一个封装了用户权限等信息的 Authentication 对象;</li>\n<li>通过调用 <code>SecurityContextHolder.getContext().setAuthentication(...) </code>将 <code>AuthenticationManager</code> 返回的 <code>Authentication</code> 对象赋予给当前的 SecurityContext;</li>\n</ol>\n<h1 id=\"成功与失败的额外处理\">成功与失败的额外处理</h1>\n<ul>\n<li>\n<p>form-login 元素的 <font style=\"color: rgba(0, 255, 255, 1);\">authentication-success-handler-ref</font> 对应一个 <code>AuthencticationSuccessHandler</code> 实现类的引用;</p>\n<ul>\n<li>如果指定了 authentication-success-handler-ref, 登录认证成功后会调用指定 <code>AuthenticationSuccessHandler</code> 的 <code>onAuthenticationSuccess</code> 方法; 我们需要在该方法体内对认证成功做一个处理, 然后返回对应的认证成功页面; 使用了 之前的那些 default-target-url 之类的就都不起作用了</li>\n</ul>\n</li>\n<li>\n<p>同样通过 form-login 元素的<font style=\"color: rgba(0, 255, 255, 1);\">authentication-failure-url</font> 来指定登录失败后的页面(对应<code>AuthenticationFailureHandler</code> 接口)</p>\n<ul>\n<li>需要注意的是登录失败后的页面跟登录页面一样也是需要配置成在未登录的情况下可以访问, 否则登录失败后请求失败页面时又会被 Spring Security 重定向到登录页面;</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-xml\">..掐头..\n      &lt;!-- ...handler-ref 认证 成功 失败的处理器 --&gt; \n      &lt;security:form-login login-page=\"/login.jsp\" default-target-url=\"/springsecurity/user/admin.htm\"\n        authentication-success-handler-ref=\"authSuccessHandler\"\n       authentication-failure-handler-ref =\"authFailureHandler\" /&gt;\n      &lt;!-- 表示匿名用户可以访问 --&gt;\n      &lt;security:intercept-url pattern=\"/login.jsp\" access=\"IS_AUTHENTICATED_ANONYMOUSLY\"/&gt;\n      &lt;security:intercept-url pattern=\"/user/welcome*\" access=\"IS_AUTHENTICATED_ANONYMOUSLY\"/&gt;\n       &lt;!-- 访问下面URL需要 ROLE_USER 权限 --&gt;\n      &lt;security:intercept-url pattern=\"/**\" access=\"ROLE_USER\" /&gt;\n      &lt;!-- 指定退出登陆后的重定向url--&gt;\n      &lt;security:logout logout-success-url=\"/login.jsp\" /&gt;\n   &lt;/security:http&gt;\n   \n    &lt;!-- 认证成功的 处理bean --&gt;\n   &lt;bean id=\"authSuccessHandler\" class=\"net.bean.AuthenticationSuccessHandlerImpl\" /&gt;\n   &lt;!-- 认证失败的 处理bean --&gt;\n   &lt;bean id=\"authFailureHandler\" class=\"net.bean.AuthenticationFailureHandlerImpl\" /&gt;\n..去尾..\n</code></pre>\n<blockquote>\n<p>参考: <a href=\"https://www.w3cschool.cn/springsecurity/4lwn1ihz.html\" rel=\"noopener nofollow\" target=\"_blank\">https://www.w3cschool.cn/springsecurity/4lwn1ihz.html</a></p>\n</blockquote>\n<h1 id=\"退出登录-logout\">退出登录 logout</h1>\n<ul>\n<li>\n<p>在 http 元素下定义<strong>logout</strong> 元素</p>\n<ul>\n<li>这样 Spring Security 将自动为我们添加用于处理退出登录的过滤器 <code>LogoutFilter</code> 到<font style=\"color: rgba(0, 191, 255, 1);\">FilterChain</font>;</li>\n<li>当我们指定了 http 元素的 auto-config 属性为 true 时<strong>logout</strong> 定义是会自动配置的, 此时我们默认退出登录的 URL 为 \"/j_spring_security_logout\", 可以通过 logout 元素的 logout-url 属性来改变退出登录的默认地址;</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>参考: <a href=\"https://www.w3cschool.cn/springsecurity/g86w1iig.html\" rel=\"noopener nofollow\" target=\"_blank\">https://www.w3cschool.cn/springsecurity/g86w1iig.html</a></p>\n</blockquote>\n<br />\n<br />\n<hr />\n<br />\n<br />\n<h1 id=\"细谈认证过程\">细谈认证过程</h1>\n<p>完整过程图</p>\n<p><img alt=\"20180810154038\" class=\"lazyload\" /></p>\n<h2 id=\"1springsecurityfilterchain\">1.SpringSecurityFilterChain</h2>\n<p>首先客户端一个请求到达 Spring Security 的入口过滤器是: SecurityContextPersistenceFilter (默认实现是: <code>org.springframework.security.web.DefaultSecurityFilterChain</code>)<br />\n它其实是一个代理维持着多个<code>FilterChain</code>, 这些过滤器, 过滤链都是被spring容器管理着,可以非常方便热插拔.</p>\n<p>关于FilterChain 见:<strong>DelegatingFilterProxy 简介</strong></p>\n<h2 id=\"2usernamepasswordauthenticationfilter\">2.UsernamePasswordAuthenticationFilter</h2>\n<p>如果未登陆,如 <code>UsernamePasswordAuthenticationFilter, CasAuthenticationFilter</code>..过滤器负责获取到的用户名和密码封装成一个实现了<font style=\"color: rgba(0, 191, 255, 1);\">Authentication</font>接口的 UsernamePasswordAuthenticationToken;</p>\n<blockquote>\n<p>见<code>org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter</code> 源码, 85行</p>\n</blockquote>\n<pre><code class=\"language-java\">public Authentication attemptAuthentication(HttpServletRequest request,\n        HttpServletResponse response) throws AuthenticationException {\n    if (postOnly &amp;&amp; !request.getMethod().equals(\"POST\")) {\n        throw new AuthenticationServiceException(\n                \"Authentication method not supported: \" + request.getMethod());\n    }\n    //获取用户名密码\n    String username = obtainUsername(request);\n    String password = obtainPassword(request);\n\n    if (username == null) {\n        username = \"\";\n    }\n\n    if (password == null) {\n        password = \"\";\n    }\n\n    username = username.trim();\n    //封装 UsernamePasswordAuthenticationToken; \n    UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(\n            username, password);\n\n    // Allow subclasses to set the \"details\" property\n    setDetails(request, authRequest);\n    //使用 AuthenticationManager 认证\n    return this.getAuthenticationManager().authenticate(authRequest);\n}\n</code></pre>\n<h2 id=\"3authentication\">3.Authentication</h2>\n<p>将上述产生的 <font style=\"color: rgba(0, 191, 255, 1);\">token</font> 对象传递给 AuthenticationManager 进行登录认证;</p>\n<h2 id=\"4authenticationmanager\">4.AuthenticationManager</h2>\n<p><code>AuthenticationManager</code>并不认证,而是调用AuthenticationProvider的列表认证</p>\n<blockquote>\n<p>见<code>org.springframework.security.authentication.ProviderManager::doAuthentication</code>源码</p>\n</blockquote>\n<h2 id=\"5authenticationprovider\">5.AuthenticationProvider</h2>\n<p><code>AuthenticationProvider</code> 接口的<code>public abstract Authentication authenticate(Authentication paramAuthentication) throws AuthenticationException;</code>方法是真正在处理认证逻辑的地方</p>\n<blockquote>\n<p>它持有一个<code>UserDetailsService</code>,用于加载用户信息,<strong>简而言之,改变认证,实现 AuthenticationProvider, 改变信息来源, 实现UserDetailsService即可</strong></p>\n</blockquote>\n<blockquote>\n<p>认证成功: 后会补充<font style=\"color: rgba(0, 191, 255, 1);\">Authentication</font>详细的角色权限等 返回给AuthenticationManager</p>\n</blockquote>\n<blockquote>\n<p>认证失败: 抛出<code>AuthenticationException</code></p>\n</blockquote>\n<blockquote>\n<p>未知: 返回<code>null</code>,这将交给下一个Provider认证</p>\n</blockquote>\n<blockquote>\n<p>还有一点 xml 配置<code>&lt;authentication-provider&gt;</code> 会默认实例化一个<code>DaoAuthenticationProvider</code>加入到认证流程中,它持有<code>PasswordEncoder</code>加密是在这一步. xml配置 在<code>authentication-provider</code>的节点下 <code>password-encoder</code></p>\n</blockquote>\n<pre><code class=\"language-xml\">&lt;authentication-provider user-service-ref=\"userDetailsService\" &gt;\n    &lt;password-encoder hash=\"md5\"&gt;\n        &lt;!-- &lt;salt-source user-property=\"username\"/&gt;  无盐--&gt;\n    &lt;/password-encoder&gt;\n&lt;/authentication-provider&gt;\n</code></pre>\n<blockquote>\n<p>见<code>org.springframework.security.authentication.ProviderManager::doAuthentication</code>源码</p>\n</blockquote>\n<ol>\n<li>在<code>AuthenticationManager</code>中, 只要有一个Provider认证成功, 就不会再继续做更多验证, 将返回的<font style=\"color: rgba(0, 191, 255, 1);\">Authentication</font>对象赋予给当前的SecurityContext;</li>\n</ol>\n<ul>\n<li>如果全部认证失败, 抛出<code>AuthenticationException</code>异常, 这会被<code>ExceptionTransactionFilter</code> Catch 到并返回一个失败页面</li>\n</ul>\n<blockquote>\n<p>见<code>org.springframework.security.authentication.ProviderManager::doAuthentication</code>源码</p>\n</blockquote>\n<h2 id=\"6exceptiontranslationfilter\">6.ExceptionTranslationFilter</h2>\n<p>认证异常处理</p>\n<p><code>org.springframework.security.web.access.ExceptionTranslationFilter</code></p>\n<pre><code class=\"language-java\">public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n    HttpServletRequest request = (HttpServletRequest) req;\n    HttpServletResponse response = (HttpServletResponse) res;\n\n    try {\n        chain.doFilter(request, response);\n\n        logger.debug(\"Chain processed normally\");\n    }\n    catch (IOException ex) {\n        throw ex;\n    }\n    catch (Exception ex) {\n        //catch 所有异常\n        // Try to extract a SpringSecurityException from the stacktrace\n        Throwable[] causeChain = throwableAnalyzer.determineCauseChain(ex);\n        // 拿到异常类型\n        RuntimeException ase = (AuthenticationException) throwableAnalyzer\n                .getFirstThrowableOfType(AuthenticationException.class, causeChain);\n\n        if (ase == null) {\n            ase = (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType(\n                    AccessDeniedException.class, causeChain);\n        }\n\n        if (ase != null) {\n            if (response.isCommitted()) {\n                throw new ServletException(\"Unable to handle the Spring Security Exception because the response is already committed.\", ex);\n            }\n            //处理 security 类型异常/ 即: org.springframework.security.access.AccessDeniedException 和 org.springframework.security.core.AuthenticationException;\n            handleSpringSecurityException(request, response, chain, ase);\n        }\n        else {\n            // Rethrow ServletExceptions and RuntimeExceptions as-is\n            if (ex instanceof ServletException) {\n                throw (ServletException) ex;\n            }\n            else if (ex instanceof RuntimeException) {\n                throw (RuntimeException) ex;\n            }\n\n            // Wrap other Exceptions. This shouldn't actually happen\n            // as we've already covered all the possibilities for doFilter\n            throw new RuntimeException(ex);\n        }\n    }\n}\n\n\nprivate void handleSpringSecurityException(HttpServletRequest request,\n        HttpServletResponse response, FilterChain chain, RuntimeException exception)\n        throws IOException, ServletException {\n    if (exception instanceof AuthenticationException) {\n        logger.debug(\n                \"Authentication exception occurred; redirecting to authentication entry point\",\n                exception);\n\n        sendStartAuthentication(request, response, chain,\n                (AuthenticationException) exception);\n    }\n    else if (exception instanceof AccessDeniedException) {\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        if (authenticationTrustResolver.isAnonymous(authentication) || authenticationTrustResolver.isRememberMe(authentication)) {\n            logger.debug(\n                    \"Access is denied (user is \" + (authenticationTrustResolver.isAnonymous(authentication) ? \"anonymous\": \"not fully authenticated\") + \"); redirecting to authentication entry point\",\n                    exception);\n\n            sendStartAuthentication(\n                    request,\n                    response,\n                    chain,\n                    new InsufficientAuthenticationException(\n                        messages.getMessage(\n                            \"ExceptionTranslationFilter.insufficientAuthentication\",\n                            \"Full authentication is required to access this resource\")));\n        }\n        else {\n            logger.debug(\n                    \"Access is denied (user is not anonymous); delegating to AccessDeniedHandler\",\n                    exception);\n\n            accessDeniedHandler.handle(request, response,\n                    (AccessDeniedException) exception);\n        }\n    }\n}\n\n\n</code></pre>\n<br />\n<br />\n<h1 id=\"tomcat-过滤链的生成\">Tomcat 过滤链的生成</h1>\n<p>在tomcat 源码</p>\n<h2 id=\"orgapachecatalinacorestandardwrappervalve\">org.apache.catalina.core.StandardWrapperValve</h2>\n<pre><code class=\"language-java\">\n @Override\npublic final void invoke(Request request, Response response)\n    throws IOException, ServletException {\n    ....\n\n    MessageBytes requestPathMB = request.getRequestPathMB();\n    DispatcherType dispatcherType = DispatcherType.REQUEST;\n    if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n    request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n    request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n            requestPathMB);\n    // Create the filter chain for this request// 这个ApplicationFilterChain 实现了 FilterChain\n    ApplicationFilterChain filterChain =\n            ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n</code></pre>\n<p>关键在:</p>\n<h2 id=\"orgapachecatalinacoreapplicationfilterfactorycreatefilterchain\">org.apache.catalina.core.ApplicationFilterFactory::createFilterChain</h2>\n<pre><code class=\"language-java\">public static ApplicationFilterChain createFilterChain(ServletRequest request,\n            Wrapper wrapper, Servlet servlet) {\n\n        // If there is no servlet to execute, return null\n        if (servlet == null)\n            return null;\n\n        // Create and initialize a filter chain object\n        ApplicationFilterChain filterChain = null;\n        if (request instanceof Request) {\n            Request req = (Request) request;\n            if (Globals.IS_SECURITY_ENABLED) {\n                // Security: Do not recycle\n                filterChain = new ApplicationFilterChain();\n            } else {\n                filterChain = (ApplicationFilterChain) req.getFilterChain();\n                if (filterChain == null) {\n                    filterChain = new ApplicationFilterChain();\n                    req.setFilterChain(filterChain);\n                }\n            }\n        } else {\n            // Request dispatcher in use\n            filterChain = new ApplicationFilterChain();\n        }\n\n        filterChain.setServlet(servlet);\n        filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());\n\n        // Acquire the filter mappings for this Context\n        StandardContext context = (StandardContext) wrapper.getParent();\n        FilterMap filterMaps[] = context.findFilterMaps();\n\n        // If there are no filter mappings, we are done\n        if ((filterMaps == null) || (filterMaps.length == 0))\n            return filterChain;\n\n        // Acquire the information we will need to match filter mappings\n        DispatcherType dispatcher =\n                (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);\n\n        String requestPath = null;\n        Object attribute = request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR);\n        if (attribute != null){\n            requestPath = attribute.toString();\n        }\n\n        String servletName = wrapper.getName();\n\n        // Add the relevant path-mapped filters to this filter chain //关键是这个Map , 其中就有 springSecurityFilterChain\n        for (FilterMap filterMap: filterMaps) {\n            if (!matchDispatcher(filterMap, dispatcher)) {\n                continue;\n            }\n            if (!matchFiltersURL(filterMap, requestPath))\n                continue;\n            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)\n                    context.findFilterConfig(filterMap.getFilterName());\n            if (filterConfig == null) {\n                // FIXME - log configuration problem\n                continue;\n            }\n            filterChain.addFilter(filterConfig);\n        }\n\n        // Add filters that match on servlet name second\n        for (FilterMap filterMap: filterMaps) {\n            if (!matchDispatcher(filterMap, dispatcher)) {\n                continue;\n            }\n            if (!matchFiltersServlet(filterMap, servletName))\n                continue;\n            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)\n                    context.findFilterConfig(filterMap.getFilterName());\n            if (filterConfig == null) {\n                // FIXME - log configuration problem\n                continue;\n            }\n            filterChain.addFilter(filterConfig);\n        }\n\n        // Return the completed filter chain\n        return filterChain;\n    }\n</code></pre>\n<h1 id=\"delegatingfilterproxy-简介--与预定义的过滤器\">DelegatingFilterProxy 简介 &amp; 与预定义的过滤器</h1>\n<p>Spring Security本质上是一连串的Filter,  然后又以一个独立的Filter的形式插入到Filter Chain里</p>\n<p>实际上FilterChainProxy下面可以有多条Filter Chain, 来针对不同的URL做验证, 而Filter Chain中所拥有的Filter则会根据定义的服务自动增减; 所以无需要显示再定义这些Filter, 除非想要实现自己的逻辑;</p>\n<p>可以往这个链加入, 例如: 验证码过滤器</p>\n<p><img alt=\"20180810162137\" class=\"lazyload\" /></p>\n<p>Spring Security 已经定义了一些 Filter, 不管实际应用中你用到了哪些, 它们应当保持如下顺序;</p>\n<ol>\n<li>\n<p>ChannelProcessingFilter, 如果你访问的 channel 错了, 那首先就会在 channel 之间进行跳转, 如 http 变为 https;</p>\n</li>\n<li>\n<p><code>SecurityContextPersistenceFilter</code>, 在一开始进行 request 的时候就可以在 SecurityContextHolder 中建立一个 SecurityContext, 然后在请求结束的时候, 任何对 SecurityContext 的改变都可以被 copy 到 HttpSession;<br />\n<strong>负责将 SecurityContextHolder 中的登陆用户信息 (默认保存在ThreadLocal) 加载到,SecurityContext<code>SecurityContextHolder.getContext()</code>!!</strong></p>\n</li>\n<li>\n<p>ConcurrentSessionFilter, 因为它需要使用 SecurityContextHolder 的功能, 而且更新对应 session 的最后更新时间, 以及通过 SessionRegistry 获取当前的 SessionInformation 以检查当前的 session 是否已经过期, 过期则会调用 LogoutHandler;</p>\n</li>\n<li>\n<p>认证处理机制, 如 UsernamePasswordAuthenticationFilter, CasAuthenticationFilter, BasicAuthenticationFilter 等, 以至于 SecurityContextHolder 可以被更新为包含一个有效的 Authentication 请求;</p>\n</li>\n<li>\n<p>SecurityContextHolderAwareRequestFilter, 它将会把 HttpServletRequest 封装成一个继承自 HttpServletRequestWrapper 的 SecurityContextHolderAwareRequestWrapper, 同时使用 SecurityContext 实现了 HttpServletRequest 中与安全相关的方法;</p>\n</li>\n<li>\n<p>JaasApiIntegrationFilter, 如果 SecurityContextHolder 中拥有的 Authentication 是一个 JaasAuthenticationToken, 那么该 Filter 将使用包含在 JaasAuthenticationToken 中的 Subject 继续执行 FilterChain;</p>\n</li>\n<li>\n<p>RememberMeAuthenticationFilter, 如果之前的认证处理机制没有更新 SecurityContextHolder, 并且用户请求包含了一个 Remember-Me 对应的 cookie, 那么一个对应的 Authentication 将会设给 SecurityContextHolder;</p>\n</li>\n<li>\n<p>AnonymousAuthenticationFilter, 如果之前的认证机制都没有更新 SecurityContextHolder 拥有的 Authentication, 那么一个 AnonymousAuthenticationToken 将会设给 SecurityContextHolder;</p>\n</li>\n<li>\n<p>ExceptionTransactionFilter, 用于处理在 FilterChain 范围内抛出的 AccessDeniedException 和 AuthenticationException, 并把它们转换为对应的 Http 错误码返回或者对应的页面;</p>\n</li>\n<li>\n<p>FilterSecurityInterceptor, 保护 Web URI, 并且在访问被拒绝时抛出异常;</p>\n</li>\n</ol>\n<blockquote>\n<p><a href=\"https://www.w3cschool.cn/springsecurity/4j1s1iid.html\" rel=\"noopener nofollow\" target=\"_blank\">参考: W3C 翻译的文档</a></p>\n</blockquote>\n<h2 id=\"过滤器链位置-一览\">过滤器链位置 一览</h2>\n<blockquote>\n<p>5.0文档<br />\n<a href=\"https://docs.spring.io/spring-security/site/docs/5.0.13.RELEASE/reference/htmlsingle/\" rel=\"noopener nofollow\" target=\"_blank\">Table 6.1. Standard Filter Aliases and Ordering</a></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Alias</th>\n<th>Filter Class</th>\n<th>Namespace Element or Attribute</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CHANNEL_FILTER</td>\n<td>ChannelProcessingFilter</td>\n<td>http/intercept-url@requires-channel</td>\n</tr>\n<tr>\n<td>SECURITY_CONTEXT_FILTER</td>\n<td>SecurityContextPersistenceFilter</td>\n<td>http</td>\n</tr>\n<tr>\n<td>CONCURRENT_SESSION_FILTER</td>\n<td>ConcurrentSessionFilter</td>\n<td>session-management/concurrency-control</td>\n</tr>\n<tr>\n<td>HEADERS_FILTER</td>\n<td>HeaderWriterFilter</td>\n<td>http/headers</td>\n</tr>\n<tr>\n<td>CSRF_FILTER</td>\n<td>CsrfFilter</td>\n<td>http/csrf</td>\n</tr>\n<tr>\n<td>LOGOUT_FILTER</td>\n<td>LogoutFilter</td>\n<td>http/logout</td>\n</tr>\n<tr>\n<td>X509_FILTER</td>\n<td>X509AuthenticationFilter</td>\n<td>http/x509</td>\n</tr>\n<tr>\n<td>PRE_AUTH_FILTER</td>\n<td>AbstractPreAuthenticatedProcessingFilter Subclasses</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>CAS_FILTER</td>\n<td>CasAuthenticationFilter</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>FORM_LOGIN_FILTER</td>\n<td>UsernamePasswordAuthenticationFilter</td>\n<td>http/form-login</td>\n</tr>\n<tr>\n<td>BASIC_AUTH_FILTER</td>\n<td>BasicAuthenticationFilter</td>\n<td>http/http-basic</td>\n</tr>\n<tr>\n<td>SERVLET_API_SUPPORT_FILTER</td>\n<td>SecurityContextHolderAwareRequestFilter</td>\n<td>http/@servlet-api-provision</td>\n</tr>\n<tr>\n<td>JAAS_API_SUPPORT_FILTER</td>\n<td>JaasApiIntegrationFilter</td>\n<td>http/@jaas-api-provision</td>\n</tr>\n<tr>\n<td>REMEMBER_ME_FILTER</td>\n<td>RememberMeAuthenticationFilter</td>\n<td>http/remember-me</td>\n</tr>\n<tr>\n<td>ANONYMOUS_FILTER</td>\n<td>AnonymousAuthenticationFilter</td>\n<td>http/anonymous</td>\n</tr>\n<tr>\n<td>SESSION_MANAGEMENT_FILTER</td>\n<td>SessionManagementFilter</td>\n<td>session-management</td>\n</tr>\n<tr>\n<td>EXCEPTION_TRANSLATION_FILTER</td>\n<td>ExceptionTranslationFilter</td>\n<td>http</td>\n</tr>\n<tr>\n<td>FILTER_SECURITY_INTERCEPTOR</td>\n<td>FilterSecurityInterceptor</td>\n<td>http</td>\n</tr>\n<tr>\n<td>SWITCH_USER_FILTER</td>\n<td>SwitchUserFilter</td>\n<td>N/A</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"过滤器顺序位置作用\">过滤器顺序/位置/作用</h2>\n<blockquote>\n<p>5.0文档<br />\n<a href=\"https://docs.spring.io/spring-security/site/docs/5.0.13.RELEASE/reference/htmlsingle/\" rel=\"noopener nofollow\" target=\"_blank\">14.3 Filter Ordering</a></p>\n</blockquote>\n<p>The order that filters are defined in the chain is very important. Irrespective of which filters you are actually using, the order should be as follows:</p>\n<p><code>ChannelProcessingFilter</code>, because it might need to redirect to a different protocol</p>\n<p><code>SecurityContextPersistenceFilter</code>, so a SecurityContext can be set up in the SecurityContextHolder at the beginning of a web request, and any changes to the SecurityContext can be copied to the HttpSession when the web request ends (ready for use with the next web request)<br />\nso 没有经过<code>SecurityContextPersistenceFilter</code> 是用不了 SecurityContextHolder的!!!</p>\n<p><code>ConcurrentSessionFilter</code>, because it uses the SecurityContextHolder functionality and needs to update the SessionRegistry to reflect ongoing requests from the principal</p>\n<p><em>Authentication</em> processing mechanisms - <code>UsernamePasswordAuthenticationFilter</code>, <code>CasAuthenticationFilter</code>, <code>BasicAuthenticationFilter</code> etc - so that the SecurityContextHolder can be modified to contain a valid Authentication request token</p>\n<p>The <code>SecurityContextHolderAwareRequestFilter</code>, if you are using it to install a Spring Security aware HttpServletRequestWrapper into your servlet container</p>\n<p>The <code>JaasApiIntegrationFilter</code>, if a JaasAuthenticationToken is in the SecurityContextHolder this will process the FilterChain as the Subject in the JaasAuthenticationToken</p>\n<p><code>RememberMeAuthenticationFilter</code>, so that if no earlier authentication processing mechanism updated the SecurityContextHolder, and the request presents a cookie that enables remember-me services to take place, a suitable remembered Authentication object will be put there</p>\n<p><code>AnonymousAuthenticationFilter</code>, so that if no earlier authentication processing mechanism updated the SecurityContextHolder, an anonymous Authentication object will be put there<br />\n<code>ExceptionTranslationFilter</code>, to catch any Spring Security exceptions so that either an HTTP error response can be returned or an appropriate AuthenticationEntryPoint can be launched</p>\n<p><code>FilterSecurityInterceptor</code>, to protect web URIs and raise exceptions when access is denied</p>\n<h2 id=\"securitycontextholder-工作模式securitycontext-保存的位置\">SecurityContextHolder 工作模式(SecurityContext 保存的位置)</h2>\n<pre><code class=\"language-java\">public class SecurityContextHolder {\n\t// ~ Static fields/initializers\n\t// =====================================================================================\n\n\tpublic static final String MODE_THREADLOCAL = \"MODE_THREADLOCAL\";\n\tpublic static final String MODE_INHERITABLETHREADLOCAL = \"MODE_INHERITABLETHREADLOCAL\";\n\tpublic static final String MODE_GLOBAL = \"MODE_GLOBAL\";\n\tpublic static final String SYSTEM_PROPERTY = \"spring.security.strategy\";\n\tprivate static String strategyName = System.getProperty(SYSTEM_PROPERTY);\n\tprivate static SecurityContextHolderStrategy strategy;\n\tprivate static int initializeCount = 0;\n    ...\n\n\n\n}\n</code></pre>\n<p>可通过 <code>spring.security.strategy</code> 配置</p>\n<p><code>MODE_THREADLOCAL</code>: 缺省工作模式, 保存在ThreadLocal<br />\n<code>MODE_INHERITABLETHREADLOCAL</code>: 存储在线程中, 但子线程可以获取到父线程中的<br />\n<code>MODE_GLOBAL</code>: 全局策略, 所有线程都获取</p>\n<h1 id=\"实例-一个项目例子\">实例 一个项目例子</h1>\n<p>主要配置部分</p>\n<pre><code class=\"language-xml\">&lt;http auto-config=\"false\" access-denied-page=\"/login.htm\" entry-point-ref=\"authenticationEntryPoint\"&gt;\n\t\t&lt;intercept-url pattern=\"/images/*\" filters=\"none\"/&gt;\n\t\t&lt;intercept-url pattern=\"/style/*\" filters=\"none\"/&gt;\n\t\t&lt;intercept-url pattern=\"/login.htm*\" filters=\"none\"/&gt;\n\t\t&lt;intercept-url pattern=\"/login.jsp*\" filters=\"none\"/&gt;\n\t\t&lt;intercept-url pattern=\"/logout.jsp\" filters=\"none\"/&gt;\n\t\t&lt;intercept-url pattern=\"/index/map.sh*\" filters=\"none\"/&gt;\n\t\t&lt;intercept-url pattern=\"/map/map_topic/topicList.sh*\" filters=\"none\"/&gt;\n\t\t&lt;intercept-url pattern=\"/map/searchNearby.sh*\" filters=\"none\"/&gt;\n\t\t&lt;intercept-url pattern=\"/solr/*\" filters=\"none\"/&gt;\n\t\t&lt;intercept-url pattern=\"/mobileRest/*\" filters=\"none\"/&gt;\n\t\t&lt;intercept-url pattern=\"/**\" access=\"ROLE_USER\"/&gt;\n        &lt;!-- 验证码过滤器, spring 安全过滤器链 有默认的过滤器而且还是有默认顺序位置的(position这个属性指定)--&gt;\n\t\t&lt;custom-filter ref=\"captchaAuthenticaionFilter\" position=\"FORM_LOGIN_FILTER\" /&gt;\n\t\t&lt;!--成功注销后跳转到的页面; --&gt;\n\t\t&lt;logout logout-success-url=\"/login.htm\" /&gt;\n\t\t&lt;http-basic /&gt;\n\t&lt;/http&gt;\n\n</code></pre>\n<h2 id=\"1entry-point-ref\">1.<strong>entry-point-ref</strong></h2>\n<pre><code>认证入口点, 在过滤链, 检验失败的时候, 引导到登陆页面,其配置.  \n</code></pre>\n<pre><code class=\"language-xml\">        &lt;beans:bean id=\"authenticationEntryPoint\" class=\"net.jk.auth.JKLoginUrlAuthenticationEntryPoint\"&gt;\n            &lt;beans:property name=\"loginFormUrl\" value=\"/login.jsp\" /&gt;\n            &lt;beans:property name=\"ajaxLoginFormUrl\" value=\"ajaxLogin.htm\" /&gt;\n        &lt;/beans:bean&gt;\n</code></pre>\n<h2 id=\"2captchaauthenticaionfilter\">2.<strong>captchaAuthenticaionFilter</strong></h2>\n<p>见上: <em>细谈认证过程</em>的第二步<br />\n&gt; 如果未登陆,如 UsernamePasswordAuthenticationFilter, CasAuthenticationFilter..过滤器负责获取到的用户名和密码封装成一个实现了<font style=\"color: rgba(0, 191, 255, 1);\">Authentication</font>接口的 UsernamePasswordAuthenticationToken;</p>\n<pre><code class=\"language-xml\">        &lt;beans:bean id=\"captchaAuthenticaionFilter\" class=\"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter\"&gt;\n        &lt;!-- 注入认证管理--&gt;\n            &lt;beans:property name=\"authenticationManager\" ref=\"authenticationManager\" /&gt;\n            &lt;!-- 成功与失败的处理--&gt;\n            &lt;beans:property name=\"authenticationFailureHandler\" ref=\"authenticationFailureHandler\" /&gt;\n            &lt;beans:property name=\"authenticationSuccessHandler\" ref=\"authenticationSuccessHandler\" /&gt;\n            &lt;beans:property name=\"filterProcessesUrl\" value=\"/j_spring_security_check\" /&gt;\n        &lt;/beans:bean&gt;\n</code></pre>\n<h2 id=\"3authenticationmanager\">3.<strong>authenticationManager</strong></h2>\n<p>见上: <em>细谈认证过程</em>的第五步<br />\n&gt; <code>AuthenticationManager</code>并不认证,而是调用AuthenticationProvider的列表认证</p>\n<pre><code class=\"language-xml\">    &lt;!-- 认证管理 它应该持有DetailsService,AuthenticationProvider,如果没有AuthenticationProvider 配置默认会实例DaoAuthenticationProvider --&gt;\n        &lt;authentication-manager alias=\"authenticationManager\"&gt;\n            &lt;authentication-provider user-service-ref=\"userDetailsService\" /&gt;\n        &lt;/authentication-manager&gt;\n</code></pre>\n<blockquote>\n<p><code>AuthenticationProvider</code> 接口的<code>public abstract Authentication authenticate(Authentication paramAuthentication) throws AuthenticationException;</code>方法是真正在处理认证逻辑的<br />\n它持有一个<code>UserDetailsService</code>,用于加载用户信息,<font style=\"color: rgba(255, 0, 0, 1);\">简而言之: 改变认证 实现AuthenticationProvider; 改变信息来源 实现UserDetailsService</font><br />\n认证成功: 后会补充<font style=\"color: rgba(0, 191, 255, 1);\">Authentication</font>详细的角色权限等 返回给AuthenticationManager<br />\n认证失败: 抛出<code>AuthenticationException</code><br />\n未知: 返回<code>null</code>,这将交给下一个Provider认证<br />\n<code>&lt;authentication-provider&gt;</code> 会默认实例化一个<code>DaoAuthenticationProvider</code></p>\n</blockquote>\n<h2 id=\"4userdetailsservice\">4.<strong>userDetailsService</strong></h2>\n<p>在注解中</p>\n<pre><code class=\"language-java\">@Service(\"userDetailsService\")\npublic class LoadUserDetailsService implements UserDetailsService{\n    ...\n    //`UserDetailsService`,用于加载用户信息\n\t@Override\n\tpublic UserDetails loadUserByUsername(String loginid)\n\t\t\tthrows UsernameNotFoundException, DataAccessException {\n\t\tfinal List&lt;GrantedAuthority&gt; grantedAuthorities = new ArrayList&lt;GrantedAuthority&gt;();//这是角色规则\n\t\tif(StringUtils.isBlank(loginid))throw new UsernameIsEmptyException(\"请输入用户名! \");\n\t\tBs_user user=bs_userDao.findByLoginId(loginid);\n\t\tif(user==null)throw new UsernameNotFoundException(\"UserDetailsService.usernameNotFound\");\n\t\tgrantedAuthorities.add(new GrantedAuthorityImpl(AuthConstants.ROLE_USER));\n\t\tList&lt;String&gt; permissionCode=bs_roleService.findPermissionCodeByAccount(loginid);\n\t\tif(permissionCode!=null &amp;&amp; !permissionCode.isEmpty()){\n\t\t\tfor(String code:permissionCode){\n\t\t\t\tgrantedAuthorities.add(new GrantedAuthorityImpl(code));\n\t\t\t}\n\t\t}\n\t...\n        //返回详细信息, 最终认证会在默认的 DaoAuthenticationProvider\n\t\treturn (UserDetails) authuser;\n\t}\n    \t...\n</code></pre>\n<h1 id=\"remember-me-记住登陆\">Remember-Me 记住登陆</h1>\n<p>10.4 Remember-Me Interfaces and Implementations (3.0)</p>\n<p>Remember-Me, 不是在基本验证身份验证的时候使用, 在<code>AbstractAuthenticationProcessingFilter</code>过滤器基类<br />\n它有个<code>RememberMeServices</code>引用在<strong>适当的时候调用</strong> =.=</p>\n<blockquote>\n<p>Remember-me authentication is not used with basic authentication, given it is often not used with HttpSessions. Remember-me is used with UsernamePasswordAuthenticationFilter, and is implemented via hooks in the AbstractAuthenticationProcessingFilter superclass. The hooks will invoke a concrete RememberMeServices at the appropriate times. The interface looks like this:</p>\n</blockquote>\n<p>在Spring Security的过滤器链里, <code>RememberMeAuthenticationFilter</code> 是排在<code>UsernamePasswordAuthenticationFilter</code> 之后的. 在第一次登录时(如果勾选了remember me), 在验证信息正确后,&nbsp;AbstractAuthenticationProcessingFilter(UsernamePasswordAuthenticationFilter的父类)最后会调用一个叫successfulAuthentication()的方法:</p>\n<p>注意几点:</p>\n<ol>\n<li>在 <code>authenticationManager</code> 里要加多一个authentication provider --&nbsp;RememberMeAuthenticationProvider;</li>\n<li>要为<code>UsernamePasswordAuthenticationFilter</code>的 rememberMeServices属性指定一个实例;<br />\n3)&nbsp;<code>RememberMeAuthenticationProvider</code> 和<code>TokenBasedRememberMeServices</code>都要为它们的key属性指定一个唯一的值. 这个值可以用应用名加一个不少于36位长度的随机字符串. 这个key是用来识别当前应用的唯一值.</li>\n<li>在提交登录表单的时候, 一定要加多一个名的 <code>_spring_security_remember_me</code> 的参数名(可以改), 值可以是\"true\", \"yes\", \"on\"或\"1\".</li>\n</ol>\n<h2 id=\"前端页面表单\">前端页面表单</h2>\n<pre><code class=\"language-html\"> &lt;input type=\"checkbox\" name=\"remember-me\"  value=\"true\"/&gt; Remember me\n &lt;!-- _spring_security_remember_me 远古版本 --&gt;\n &lt;input type=\"checkbox\" name=\"_spring_security_remember_me\"  value=\"true\"/&gt; Remember me\n</code></pre>\n<h2 id=\"配置基于xml\">配置(基于xml)</h2>\n<pre><code class=\"language-xml\">&lt;http auto-config=\"false\" access-denied-page=\"/login.htm\"\n\t\tentry-point-ref=\"authenticationEntryPoint\"&gt;\n    &lt;intercept-url pattern=\"/images/*\" filters=\"none\"/&gt;\n.......\n        &lt;!-- 插入 过滤链--&gt;\n        &lt;custom-filter ref=\"rememberMeFilter\" position=\"REMEMBER_ME_FILTER\" /&gt; --&gt;\n        &lt;custom-filter ref=\"captchaAuthenticaionFilter\" position=\"FORM_LOGIN_FILTER\" /&gt;\n        \n.......\n&lt;/http&gt;\n\n &lt;!-- dv2它其实是继承UsernamePasswordAuthenticationFilter(捕获用户密码 填充Authentication 见上认证流程) --&gt;\n&lt;beans:bean id=\"captchaAuthenticaionFilter\" class=\"net.jk.auth.service.CaptchaAuthenticationFilter\"&gt;\n    &lt;beans:property name=\"authenticationManager\" ref=\"authenticationManager\" /&gt;\n    &lt;beans:property name=\"authenticationFailureHandler\" ref=\"authenticationFailureHandler\" /&gt;\n    &lt;beans:property name=\"authenticationSuccessHandler\" ref=\"authenticationSuccessHandler\" /&gt;\n     &lt;!-- rememberMeServices (生成cookie的入口)\n     RememberMeAuthenticationFilter是排在UsernamePasswordAuthenticationFilter之后的. 在第一次登录时(如果勾选了remember me), 在验证信息正确后,&nbsp;AbstractAuthenticationProcessingFilter(UsernamePasswordAuthenticationFilter的父类)最后会调用一个叫successfulAuthentication()的方法 --&gt;\n    &lt;beans:property name=\"rememberMeServices\" ref=\"tokenBasedRememberMeServices\" /&gt;\n\n    &lt;beans:property name=\"filterProcessesUrl\" value=\"/j_spring_security_check\" /&gt;\n&lt;/beans:bean&gt;\n\n &lt;!-- 需要一个过滤器, (这应该是 认证的入口)插入到过滤链中 --&gt;\n&lt;beans:bean id=\"rememberMeFilter\" class=\"org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter\"&gt;\n\t&lt;beans:property name=\"authenticationManager\" ref=\"authenticationManager\" /&gt;\n\t&lt;beans:property name=\"rememberMeServices\" ref=\"tokenBasedRememberMeServices\" /&gt;\n&lt;/beans:bean&gt;\n\n&lt;!-- 认证提供器(认证) --&gt;\n&lt;beans:bean id=\"rememberMeAuthenticationProvider\" class=\"org.springframework.security.authentication.RememberMeAuthenticationProvider\"&gt;\n\t&lt;beans:property name=\"key\" value=\"1C6D97ACA4924F81926E7B302D14DB6D\"/&gt;\n&lt;/beans:bean&gt;\n\n &lt;!-- RememberMeServices (生成cookie) --&gt;\n&lt;beans:bean id=\"tokenBasedRememberMeServices\" class=\"org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices\"&gt;\n\t&lt;beans:property name=\"key\" value=\"1C6D97ACA4924F81926E7B302D14DB6D\" /&gt;\n\t&lt;beans:property name=\"userDetailsService\" ref=\"userDetailsService\" /&gt;\n&lt;/beans:bean&gt;\n</code></pre>\n<p>登陆后 , 默认应该会有一个 SPRING_SECURITY_REMEMBER_ME_COOKIE 名字的cookie</p>\n<ul>\n<li>remember-me属性详解<br />\nremember-me属性是spring security命名空间中实现自动登录的专属配置项,它有如下属性</li>\n</ul>\n<ol>\n<li>key: 这个\"key\"属性用来辨别分辨不同项目的cookie</li>\n<li>authentication-success-handler-ref 指向一个AuthenticationSuccessHandler</li>\n<li>data-source-ref 指向一个DataSource数据源</li>\n<li>remember-me-cookie: cookie存放的名称.默认为’remember-me’.</li>\n<li>remember-me-parameter: 触发自动登录的请求参数名称.默认为’remember-me’.</li>\n<li>services-alias: 声明一个内部定义的RememberMeServices的bean的别名,提供给程序的其他bean使用</li>\n<li>services-ref: 指向一个RememberMeServices,可以自定义实现自己的自动登录逻辑</li>\n<li>token-repository-ref: 指向一个PersistentTokenRepository bean,用来实现持久化令牌的自动登录</li>\n<li>token-validity-seconds: cookie存在的时间周期,单位为秒</li>\n<li>use-secure-cookie: 是否设置\"secure\"标志,具体使用不详</li>\n<li>user-service-ref: 指向一个UserDetailsService的bean</li>\n</ol>\n<p><a href=\"https://docs.spring.io/spring-security/site/docs/3.0.8.RELEASE/reference/remember-me.html\" rel=\"noopener nofollow\" target=\"_blank\">spring-security 3.0.8 远古版本文档</a><br />\n<a href=\"https://spring.io/projects/spring-security#learn\" rel=\"noopener nofollow\" target=\"_blank\">参考spring-security 文档</a>: Remember-Me Authentication 章节</p>\n<h1 id=\"在代码中设置-securitycontextholder-为登陆状态\">在代码中设置 SecurityContextHolder 为登陆状态</h1>\n<pre><code class=\"language-java\">///load userDetails ...\nUsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());\nauthentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\nSecurityContextHolder.getContext().setAuthentication(authentication);\n\n</code></pre>\n<h2 id=\"securitycontextholder-的原理\">SecurityContextHolder 的原理</h2>\n<p><code>SecurityContextHolder</code> 用于存储安全上下文(security context)的信息，即一个存储身份信息，认证信息等的容器。<br />\nSecurityContextHolde 默认使用 <code>ThreadLocal</code> 策略来存储认证信息，即一种与线程绑定的策略，每个线程执行时都可以获取该线程中的安全上下文(security context)，各个线程中的安全上下文互不影响。</p>\n<h1 id=\"sectrity-配置-java-bean形式\">Sectrity 配置 (Java Bean形式)</h1>\n<pre><code class=\"language-java\">@Configuration\npublic class DefaultSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity httpSecurity) throws Exception {\n    log.info(\"当前使用安全配置是: default\");\n    httpSecurity.headers().frameOptions().disable();//iframe \n    ExpressionInterceptUrlRegistry eiur=httpSecurity\n        // 禁用 CSRF\n        .csrf().disable()\n        // 授权异常\n        .exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint() ).and()\n        .addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)\n        // 不创建会话\n        .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n        // 过滤请求\n        .authorizeRequests()\n        .antMatchers(\n                HttpMethod.GET,\n                \"/*.html\",\n                \"/**/*.html\",\n                \"/**/*.css\",\n                \"/**/*.js\"\n        ).anonymous()\n\n\n        // 支付宝回调\n        .antMatchers(\"/api/aliPay/return\").anonymous()\n        .antMatchers(\"/api/aliPay/notify\").anonymous()\n        //微信公众号回调\n        .antMatchers(\"/api/wechat/core\").permitAll()\n        \n        //登陆接口\n        .antMatchers(\"/auth/**\").permitAll()\n        \n        // swagger start\n        .antMatchers(\"/swagger-ui.html\").anonymous()\n        .antMatchers(\"/swagger-resources/**\").anonymous()\n        .antMatchers(\"/webjars/**\").anonymous()\n        .antMatchers(\"/*/api-docs\").anonymous()\n        .antMatchers(\"/*/api-docs-ext\").anonymous()\n        // swagger end\n\n        // 接口限流测试\n        .antMatchers(\"/test/**\").anonymous()\n        .antMatchers(HttpMethod.OPTIONS, \"/**\").anonymous()\n\n        .antMatchers(\"/druid/**\").anonymous()\n        //rest接口\n        .antMatchers(\"/api/rest/**\").anonymous();\n\n        //除此之外所有地址都需要验证\n        httpSecurity.authorizeRequests().anyRequest().authenticated();\n    }\n\n    ...\n}\n</code></pre>\n<p><strong>一个简单内存认证</strong></p>\n<pre><code class=\"language-java\">@Configuration\n@Order(1)\npublic class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {\n    @Bean\n    public UserDetailsService userDetailsService()  {\n        // ensure the passwords are encoded properly\n        User.UserBuilder users = User.withDefaultPasswordEncoder();\n        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();\n        manager.createUser(users.username(\"yang\").password(\"123..\").roles(\"USER\").build());\n        //manager.createUser(users.username(\"admin\").password(\"dfgddd\").roles(\"USER\",\"ADMIN\").build());\n        return manager;\n    }\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.formLogin()\n                .successForwardUrl(\"/index.html\")\n                .and()\n                .authorizeRequests().anyRequest().authenticated();\n    }\n}\n\n</code></pre>\n<h1 id=\"集成单点登陆jasig\">集成单点登陆(<strong>jasig</strong>)</h1>\n<h2 id=\"服务端\">服务端</h2>\n<p>官下载页 - <a href=\"https://www.apereo.org/programs/software/cas\" rel=\"noopener nofollow\" target=\"_blank\">https://www.apereo.org/programs/software/cas</a><br />\nGitHub - <a href=\"https://github.com/apereo/cas\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/apereo/cas</a></p>\n<p>下载其发布版包,例: cas-server-webapp-4.0.0 - (_v_resouces/cas-server-4.0.0-release.zip)<br />\n一般而言仅需要其编译好的即可,例:<code>cas-server-webapp-4.0.0.war</code> 和数据源支持 <code>cas-server-support-jdbc-4.0.0.jar</code><br />\n解压war把support-jdbc放到lib下,还有使用的数据库驱动,比如<code>mysql-connector-java-5.0.8-bin.jar</code></p>\n<ul>\n<li>服务端配置<br />\n找到./WEB-INF/deployerConfigContext.xml 文件,修改</li>\n</ul>\n<ol>\n<li>注释</li>\n</ol>\n<pre><code class=\"language-xml\">    &lt;bean id=\"primaryAuthenticationHandler\"\n          class=\"org.jasig.cas.authentication.AcceptUsersAuthenticationHandler\"&gt;\n        &lt;property name=\"users\"&gt;\n            &lt;map&gt;\n                &lt;entry key=\"casuser\" value=\"Mellon\"/&gt;\n            &lt;/map&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<ol start=\"2\">\n<li>增加</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;!-- from 数据库 --&gt;\n&lt;bean id=\"dataSource\"\n        class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;\n        &lt;property name=\"driverClassName\" value=\"net.sourceforge.jtds.jdbc.Driver\" /&gt;\n        &lt;property name=\"url\"\n            value=\"jdbc.url=jdbc:jtds:sqlserver://127.0.0.1:1433/asp-gdagri-auth;useUnicode=true;charset=GB2312\" /&gt;\n        &lt;property name=\"username\" value=\"user_dev\" /&gt;\n        &lt;property name=\"password\" value=\"user@dev\" /&gt;\n    &lt;/bean&gt;\n    \n    &lt;bean id=\"primaryAuthenticationHandler\"\n          class=\"org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler\"\n          p:dataSource-ref=\"dataSource\"\n          p:passwordEncoder-ref=\"MD5PasswordEncoder\"\n          p:sql=\"select password from bs_role where name=?\" /&gt;\n          \n    &lt;bean id=\"MD5PasswordEncoder\" class=\"org.jasig.cas.authentication.handler.DefaultPasswordEncoder\"&gt;\n        &lt;constructor-arg index=\"0\"&gt;\n            &lt;value&gt;MD5&lt;/value&gt;\n        &lt;/constructor-arg&gt;\n    &lt;/bean&gt;\n</code></pre>\n<blockquote>\n<p><code>p:sql</code>应该是指定查询语句</p>\n</blockquote>\n<h3 id=\"一些配置\">一些配置</h3>\n<h3 id=\"ticketexpirationpoliciesxml\">ticketExpirationPolicies.xml</h3>\n<p>ticket 过期策略配置</p>\n<pre><code class=\"language-xml\">\n\n&lt;!-- TGT 配置--&gt;\n\t&lt;bean id=\"serviceTicketExpirationPolicy\" class=\"org.jasig.cas.ticket.support.MultiTimeUseOrTimeoutExpirationPolicy\"&gt;\n    \n\t\t&lt;!-- This argument is the number of times that a ticket can be used before its considered expired. \n        (ticket 在过期前[下 过期时间 参数] 可以使用的次数)\n        --&gt;\n\t\t&lt;constructor-arg\n\t\t\tindex=\"0\"\n\t\t\tvalue=\"999999999\" /&gt;\n\t\t\n\t\t&lt;!-- This argument is the time a ticket can exist before its considered expired.  \n        ( 过期时间 单位:毫秒)\n        --&gt;\n\t\t&lt;constructor-arg\n\t\t\tindex=\"1\"\n\t\t\tvalue=\"100000\" /&gt;\n\t&lt;/bean&gt;\n\t&lt;!--ST 配置 --&gt;\n\t&lt;bean id=\"grantingTicketExpirationPolicy\" class=\"org.jasig.cas.ticket.support.TimeoutExpirationPolicy\"&gt;\n\t\t&lt;!-- This argument is the time a ticket can exist before its considered expired. \n        (ticket 在不活跃的时候过期时间 毫秒)\n         --&gt;\n\t\t&lt;constructor-arg\n\t\t\tindex=\"0\"\n\t\t\tvalue=\"7200000\" /&gt;\n\t&lt;/bean&gt;\n\n</code></pre>\n<p><a href=\"https://www.cnblogs.com/gao241/p/3367869.html\" target=\"_blank\">参考</a></p>\n<h4 id=\"tgc-ticket-granting-cookie\">TGC: Ticket Granting Cookie</h4>\n<p>CAS 会将生成的 TGT 放在 session 中, 而 TGC 就是这个 session 的唯一标识(sessionId), 可以认为是 TGT 的key, 为 TGT 就是 TGC 的 value, TGC 以 cookie 的形式保存在浏览器中, 每个请求都会尝试携带 TGC; （每个服务都会在 session 和 cookie 中保存对应的 TGT 和 TGC）</p>\n<h4 id=\"tgt-ticket-granting-ticket\">TGT: Ticket Granting Ticket</h4>\n<p>TGT 是CAS 为用户签发的登录 ticket, 也是用于验证用户登录成功的唯一方式;  TGT 封装了 Cookie 值以及 Cookie 值对应的用户信息, CAS 通过 Cookie 值（TGC）为 key 查询缓存中有无 TGT（TGC:TGT（key:value））, 如果有的话就说明用户已经登录成;</p>\n<h4 id=\"st-service-ticket\">ST: Service Ticket</h4>\n<p>ST 是当用户访问某一服务时提供的 ticket; 用户在访问其他服务时, 发现没有 cookie 或 ST , 那么就会302到 CAS 服务器获取 ST; 然后会携带着 ST 302 回来;</p>\n<h2 id=\"客户端-xml形式配置\">客户端 (XML形式配置)</h2>\n<ol>\n<li>首先需要做的是将应用的登录认证入口改为使用<code>CasAuthenticationEntryPoint</code>;</li>\n</ol>\n<pre><code class=\"language-xml\">  &lt;!-- 指定登录入口为casEntryPoint --&gt;\n   &lt;security:http  entry-point-ref=\"casEntryPoint\"&gt;\n      ...\n   &lt;/security:http&gt;\n</code></pre>\n<ol start=\"2\">\n<li>所以首先我们需要配置一个<code>CasAuthenticationEntryPoint</code>对应的bean, 然后指定需要进行登录认证时使用该<code>AuthenticationEntryPoint</code>;</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;!-- 认证的入口 --&gt;\n\n   &lt;bean id=\"casEntryPoint\"\n\n      class=\"org.springframework.security.cas.web.CasAuthenticationEntryPoint\"&gt;\n\n      &lt;!-- Cas Server的登录地址, elim是我的计算机名 --&gt;\n\n      &lt;property name=\"loginUrl\" value=\"https://elim:8443/cas/login\" /&gt;\n\n      &lt;!-- service相关的属性 --&gt;\n\n      &lt;property name=\"serviceProperties\" ref=\"serviceProperties\" /&gt;\n   &lt;/bean&gt;\n</code></pre>\n<ol start=\"3\">\n<li>配置CasAuthenticationEntryPoint时需要指定一个<code>ServiceProperties</code>, 该对象主要用来描述service（Cas概念）相关的属性, 主要是指定在Cas Server认证成功后将要跳转的地址;</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;!-- 指定service相关信息 --&gt;\n   &lt;bean id=\"serviceProperties\"class=\"org.springframework.security.cas.ServiceProperties\"&gt;\n      &lt;!-- Cas Server认证成功后的跳转地址, 这里要跳转到我们的Spring Security应用, 之后会由CasAuthenticationFilter处理, 默认处理地址为/j_spring_cas_security_check --&gt;\n      //&lt;!&gt;本地地址了, 这里开始就是本地Spring Security 流程了, 再由 cas filter 封装 UsernamePasswordAuthenticationToken \n      //再到 AuthenticationManager, 到 AuthenticationProvider 流程..\n      &lt;property name=\"service\"\n         value=\"http://elim:8080/app/j_spring_cas_security_check\" /&gt;\n\n   &lt;/bean&gt;\n</code></pre>\n<ol start=\"4\">\n<li>之后我们需要配置一个<code>CasAuthenticationFilter</code>, 并将其放置在Filter链表中CAS_FILTER的位置, 以处理Cas Server认证成功后的页面跳转, 用以在Spring Security中进行认证;</li>\n</ol>\n<blockquote>\n<p>该Filter会将Cas Server传递过来的ticket（Cas概念）封装成一个<code>Authentication</code>（对应UsernamePasswordAuthenticationToken, 其中ticket作为该Authentication的password）, 然后传递给<code>AuthenticationManager</code>进行认证;</p>\n</blockquote>\n<pre><code class=\"language-xml\">  &lt;security:http entry-point-ref=\"casEntryPoint\"&gt;\n      ...\n        &lt;!-- 定义CasAuthenticationFilter 并将其放置在Filter链表中CAS_FILTER的位置--&gt;\n      &lt;security:custom-filter ref=\"casFilter\" position=\"CAS_FILTER\"/&gt;\n      ...\n   &lt;/security:http&gt;\n   &lt;bean id=\"casFilter\" class=\"org.springframework.security.cas.web.CasAuthenticationFilter\"&gt;\n      &lt;property name=\"authenticationManager\" ref=\"authenticationManager\" /&gt;\n      &lt;!-- 指定处理地址, 不指定时默认将会是\"/j_spring_cas_security_check\" --&gt;\n      &lt;property name=\"filterProcessesUrl\" value=\"/j_spring_cas_security_check\"/&gt;\n   &lt;/bean&gt;\n</code></pre>\n<ol start=\"5\">\n<li><code>CasAuthenticationFilter</code>会将封装好的包含Cas<strong>Server传递过来的ticket的Authentication</strong>对象传递给<strong>AuthenticationManager进行认证</strong>;</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;security:authentication-manager alias=\"authenticationManager\"&gt;\n&lt;!-- 给AuthenticationManager 提供一个 认证 ; 参考: 细谈认证过程 5--&gt;\n      &lt;security:authentication-provider ref=\"casAuthenticationProvider\"/&gt;\n\n   &lt;/security:authentication-manager&gt;\n</code></pre>\n<ol start=\"6\">\n<li>默认的AuthenticationManager实现类为ProviderManager, 而ProviderManager中<strong>真正进行认证的是AuthenticationProvider</strong>;</li>\n</ol>\n<p>所以接下来我们要在AuthenticationManager中配置一个能够处理<strong>CasAuthenticationFilter传递过来的Authentication对象的AuthenticationProvider实现,</strong> <code>CasAuthenticationProvider</code>;</p>\n<pre><code class=\"language-xml\">&lt;!&gt; 真正认证逻辑bean \n &lt;bean id=\"casAuthenticationProvider\"\n\n   class=\"org.springframework.security.cas.authentication.CasAuthenticationProvider\"&gt;\n      &lt;!-- 通过username来加载UserDetails --&gt;\n      &lt;property name=\"authenticationUserDetailsService\"&gt;\n         &lt;beanclass=\"org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper\"&gt;\n            &lt;!-- 真正加载UserDetails的UserDetailsService实现 --&gt;\n            &lt;constructor-arg ref=\"userDetailsService\" /&gt;\n         &lt;/bean&gt;\n      &lt;/property&gt;\n\n      &lt;property name=\"serviceProperties\" ref=\"serviceProperties\" /&gt;\n\n      &lt;!-- 配置TicketValidator在登录认证成功后验证ticket --&gt;\n      &lt;property name=\"ticketValidator\"&gt;\n\n         &lt;bean class=\"org.jasig.cas.client.validation.Cas20ServiceTicketValidator\"&gt;\n            &lt;!-- Cas Server访问地址的前缀, 即根路径--&gt;\n            &lt;constructor-arg index=\"0\" value=\"https:// elim:8443/cas\" /&gt;\n         &lt;/bean&gt;\n      &lt;/property&gt;\n      &lt;property name=\"key\" value=\"key4CasAuthenticationProvider\" /&gt;\n\n   &lt;/bean&gt;\n</code></pre>\n<p><strong>CasAuthenticationProvider首先会利用TicketValidator</strong>（Cas概念）对Authentication中包含的ticket信息进行认证;</p>\n<p>认证通过后将利用持有的<code>AuthenticationUserDetailsService</code> 根据认证通过后回传的Assertion对象中拥有的username加载用户对应的UserDetails,</p>\n<p>即主要是加载用户的相关权限信息GrantedAuthority; 然后构造一个 CasAuthenticationToken进行返回; 之后的逻辑就是正常的Spring Security的逻辑了;</p>\n<p>访问测试</p>\n<blockquote>\n<p><a href=\"http://127.0.0.1/cas-server/login\" rel=\"noopener nofollow\" target=\"_blank\">http://127.0.0.1/cas-server/login</a><br />\n<a href=\"https://127.0.0.1:8443/cas-server/login\" rel=\"noopener nofollow\" target=\"_blank\">https://127.0.0.1:8443/cas-server/login</a></p>\n</blockquote>\n<h2 id=\"客户端-java-bean形式配置\">客户端 (Java Bean形式配置)</h2>\n<pre><code class=\"language-xml\">&lt;!-- security 对CAS支持 --&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;\n\t&lt;artifactId&gt;spring-security-cas&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<pre><code class=\"language-java\">    //入口点\n   @Bean\n\tpublic CasAuthenticationEntryPoint casAuthenticationEntryPoint() {\n\t\tCasAuthenticationEntryPoint casAuthenticationEntryPoint = new CasAuthenticationEntryPoint();\n\t\tcasAuthenticationEntryPoint.setLoginUrl(casProperties.getServerPrefix()+casProperties.getServerLogin());\n\t\tcasAuthenticationEntryPoint.setServiceProperties(serviceProperties());\n\t\treturn casAuthenticationEntryPoint;\n\t}\n    // 本地缓存认证\n    @Bean\n  \tpublic CasLocalCacheAuthenticationFilter casLocalCacheAuthenticationFilter()  {\n    \tCasLocalCacheAuthenticationFilter ccaf;\n    \ttry {\n    \t\tccaf = new CasLocalCacheAuthenticationFilter(casProperties, redisTemplate, casUserDetailsService());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(e.getMessage() );\n\t\t}\n  \t\treturn ccaf;\n  \t}\n    // cas 认证过滤器\n    @Bean\n\tpublic CasAuthenticationFilter casAuthenticationFilter() throws Exception {\n\t\tCasAuthenticationFilter casAuthenticationFilter = new CasAuthenticationFilter();\n\t\tcasAuthenticationFilter.setAuthenticationManager(authenticationManager());\n\t\tcasAuthenticationFilter.setFilterProcessesUrl(casProperties.getAppLogin());\n\t\tcasAuthenticationFilter.setAuthenticationSuccessHandler(casAuthenticationSuccessHandler());\n\t\treturn casAuthenticationFilter;\n\t}\n\n    ////////////认证相关处理\n    @Bean\n    @Override\n\tprotected AuthenticationManager authenticationManager() {\n\t\tList&lt;AuthenticationProvider&gt; p = new ArrayList&lt;AuthenticationProvider&gt;(1);\n\t\tp.add(casAuthenticationProvider());\n\t\tProviderManager authenticationManager = new ProviderManager(p);\n\t\treturn authenticationManager;\n\t}\n    @Bean\n\tpublic CasAuthenticationProvider casAuthenticationProvider() {\n\t\tCasAuthenticationProvider casAuthenticationProvider = new CasAuthenticationProvider();\n\t\ttry {\n\t\t\tcasAuthenticationProvider.setAuthenticationUserDetailsService(casUserDetailsService());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(e.getMessage() );\n\t\t}\n\t\tcasAuthenticationProvider.setServiceProperties(serviceProperties());\n\t\tcasAuthenticationProvider.setTicketValidator(cas20ServiceTicketValidator());\n\t\tcasAuthenticationProvider.setKey(\"jk_www_123ProviderKey\");\n\t\treturn casAuthenticationProvider;\n\t}\n\t@Bean\n\tpublic Cas20ServiceTicketValidator cas20ServiceTicketValidator() {\n\t\treturn new Cas20ServiceTicketValidator(casProperties.getServerPrefix());\n\t}\n\t\n\t@Bean\n\tpublic ServiceProperties serviceProperties() {\n\t\tServiceProperties serviceProperties = new ServiceProperties();\n\t\tserviceProperties.setService(casProperties.getAppPrefix()+ casProperties.getAppLogin());\n\t\tserviceProperties.setAuthenticateAllArtifacts(true);\n\t\treturn serviceProperties;\n\t}\n    @Bean\n\tpublic CasAuthenticationSuccessHandler casAuthenticationSuccessHandler()  {\n    \tCasAuthenticationSuccessHandler casAuthenticationSuccessHandler = new CasAuthenticationSuccessHandler(this.casProperties, redisTemplate);\n\t\treturn casAuthenticationSuccessHandler;\n\t}\n    \n    // 本地 UserDetailsService\n\t@Bean\t\n\t@ConditionalOnMissingBean( value={AuthenticationUserDetailsService.class} )\n \tpublic AuthenticationUserDetailsService casUserDetailsService() throws Exception {\n \t\treturn new CasUserDetailsServiceImp();\n \t}\n     //登出\n    @Bean\n\tpublic CasLogoutFilter casLogoutFilter() {\n\t\treturn new CasLogoutFilter(casProperties, redisTemplate);\n\t}\n    \n    //配置\n    @Override\n    protected void configure(HttpSecurity httpSecurity) throws Exception {\n      \tlog.info(\"当前使用安全配置是: cas\");\n    \tExpressionInterceptUrlRegistry eiur=httpSecurity\n                // 禁用 CSRF\n                .csrf().disable()\n                // 授权异常\n                .exceptionHandling().authenticationEntryPoint(casAuthenticationEntryPoint() ).and()\n                // 不创建会话\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n    \t//\n\t\t    \thttpSecurity\n\t\t\t\t\t.formLogin()\n\t\t\t\t\t.loginProcessingUrl(casProperties.getAppLogin());\n                // 防止iframe 造成跨域\n                .and().headers().frameOptions().disable();\n        httpSecurity\n        \t\t.addFilterAt(casLogoutFilter(), LogoutFilter.class)\n                .addFilterBefore(casAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)\n                .addFilterBefore(casLocalCacheAuthenticationFilter(), CasAuthenticationFilter.class);\n      \n    }\n</code></pre>\n<p>定义一个 CasProperties 配置类,用于将properties文件指定的内容注入以方便使用</p>\n<pre><code class=\"language-java\">public class CasProperties {\n\tprivate String serverPrefix;\n\tprivate String serverLogin;\n\tprivate String serverLogout;\n\t//\n\tprivate String appPrefix;\n\tprivate String appLogin;\n\tprivate String appLogout;\n\n</code></pre>\n<h3 id=\"注意1-casauthenticationfilter\">注意1 CasAuthenticationFilter</h3>\n<p>CasAuthenticationFilter 认证过滤器</p>\n<pre><code class=\"language-java\">@Bean\npublic CasAuthenticationFilter casAuthenticationFilter() throws Exception {\n    CasAuthenticationFilter casAuthenticationFilter = new CasAuthenticationFilter();\n    //根据 spring securiry 步骤 authenticationManager 会调用 Provider list 认证 规则\n    //所以还要把CasAuthenticationProvider  注给 authenticationManager, 最好覆盖父的方法, 自己写.. 先不管了\n    List&lt;AuthenticationProvider&gt; p = new ArrayList&lt;AuthenticationProvider&gt;(1);\n    p.add(casAuthenticationProvider());\n    ProviderManager authenticationManager = new ProviderManager(p);\n    casAuthenticationFilter.setAuthenticationManager(authenticationManager);\n    casAuthenticationFilter.setFilterProcessesUrl(casProperties.getAppLogin());//cas 的回调 登陆地址\n    return casAuthenticationFilter;\n}\n</code></pre>\n<h3 id=\"注意2-casauthenticationprovider\">注意2 CasAuthenticationProvider</h3>\n<p>这仍是 spring 框架内的扩展; 这个Provider 需要几个实现?</p>\n<p>要引 jasig client</p>\n<pre><code class=\"language-xml\">&lt;!-- https://mvnrepository.com/artifact/org.jasig.cas.client/cas-client-core --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.jasig.cas.client&lt;/groupId&gt;\n    &lt;artifactId&gt;cas-client-core&lt;/artifactId&gt;\n    &lt;version&gt;xxx&lt;/version&gt;\n&lt;/dependency&gt;\n\n</code></pre>\n<pre><code class=\"language-java\">\ncasAuthenticationProvider.setServiceProperties(serviceProperties());//cas 服务器配置\ncasAuthenticationProvider.setTicketValidator(cas20ServiceTicketValidator()); // 验证实现 , jasig client 已实现\ncasAuthenticationProvider.setAuthenticationUserDetailsService(casUserDetailsService());//这是登陆成功之后 加载本应用的 用户详细信息\ncasAuthenticationProvider.setKey(\"casAuthenticationProviderKey\"); //key  可以标识它(Provider)先前已认证的令牌, 避免重复验证,参考源码105\n</code></pre>\n<pre><code class=\"language-java\">\nif (authentication instanceof CasAuthenticationToken) {\n\t\t\tif (this.key.hashCode() == ((CasAuthenticationToken) authentication)\n\t\t\t\t\t.getKeyHash()) {\n\t\t\t\treturn authentication;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new BadCredentialsException(\n\t\t\t\t\t\tmessages.getMessage(\"CasAuthenticationProvider.incorrectKey\",\n\t\t\t\t\t\t\t\t\"The presented CasAuthenticationToken does not contain the expected key\"));\n\t\t\t}\n\t\t}\n</code></pre>\n<p><a href=\"https://apereo.atlassian.net/wiki/spaces/CASC/overview\" rel=\"noopener nofollow\" target=\"_blank\">官方wiki?</a><br />\n<a href=\"https://www.jianshu.com/p/2ba25bd3a5cb?tdsourcetag=s_pctim_aiomsg\" rel=\"noopener nofollow\" target=\"_blank\">https://www.jianshu.com/p/2ba25bd3a5cb?tdsourcetag=s_pctim_aiomsg</a><br />\n<a href=\"https://blog.csdn.net/cl_andywin/article/details/53998986\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/cl_andywin/article/details/53998986</a></p>\n<h1 id=\"踩坑指南\">踩坑指南</h1>\n<h2 id=\"anonymous-和-permitall\">anonymous 和 permitAll</h2>\n<pre><code class=\"language-java\">.antMatchers(\"/auth/ttx\").anonymous()\n.antMatchers(\"/auth/ttp\").permitAll()\n</code></pre>\n<p><code>anonymous()</code> 允许匿名/不检验权限/经过Security 过滤链; 同XMl的<code>&lt;intercept-url pattern=\"/auth/ttx*\"  access=\"IS_AUTHENTICATED_ANONYMOUSLY\"/&gt;</code></p>\n<p><code>permitAll()</code> 完全免登/不经过Security 过滤链; 同XMl的<code>&lt;intercept-url pattern=\"/auth/ttp*\"  filters=\"none\" /&gt;</code></p>\n<h2 id=\"antmatchers-的配置规则\">antMatchers 的配置规则</h2>\n<p>Examples</p>\n<p><code>com/t?st.jsp</code> — matches <code>com/test.jsp</code> but also <code>com/tast.jsp</code> or <code>com/txst.jsp</code><br />\n<code>com/*.jsp</code> — matches all .jsp files in the com directory</p>\n<p><code>com/**/test.jsp</code> — matches all test.jsp files underneath the com path</p>\n<p><code>org/springframework/**/*.jsp</code> — matches all .jsp files underneath the org/springframework path</p>\n<p><code>org/**/servlet/bla.jsp</code> — matches org/springframework/servlet/bla.jsp but also org/springframework/testing/</p>\n<p><code>servlet/bla.jsp and</code> org/servlet/bla.jsp</p>\n<p><code>com/{filename:\\\\w+}.jsp </code>will match com/test.jsp and assign the value test to the filename variable</p>\n<p><strong>最具的规则, 应该排在最前面!</strong></p>\n<h2 id=\"失败时不调用-authenticationentrypoint-入口的问题\">失败时不调用 authenticationEntryPoint 入口的问题</h2>\n<pre><code class=\"language-java\">\nprotected void configure(HttpSecurity httpSecurity) throws Exception {\nhttpSecurity.headers().frameOptions().disable();//iframe \nExpressionInterceptUrlRegistry eiur=httpSecurity\n        // 禁用 CSRF\n        .csrf().disable()\n        // 授权异常\n        .exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint() ).and()\n        .addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)\n</code></pre>\n<p>参见上: <code>细谈认证过程</code></p>\n<p>自定义 <code>authenticationTokenFilter</code> 认证实现时</p>\n<ol>\n<li>\n<p><code>ExceptionTransactionFilter</code> 基本在过滤最后面, 没办法处理FilterChain中Filter 的异常, 它主要是处理Action 抛出的异常, 如是认证相关异常(即 <code>AccessDeniedException</code> 和 <code>AuthenticationException</code>) 它就会处理翻译并会调到 <code>authenticationEntryPoint</code></p>\n</li>\n<li>\n<p>如果认证失败: 没有任何处理会继续回调链 <code>chain.doFilter(request, response)</code>;<strong>注意在httpSecurity 末尾追加 <code>authenticated()</code> 兜底(除此之外都需要验证), 否则会以未登陆状态访问到Action!</strong></p>\n</li>\n</ol>\n<pre><code class=\"language-java\"> //除此之外的 所有地址都需要验证(兜底)\nhttpSecurity.authorizeRequests().anyRequest().authenticated();\n</code></pre>\n<h2 id=\"权限问题\">权限问题</h2>\n<h3 id=\"记一-filtersecurityinterceptor-奇怪的权限拦截\">记一 FilterSecurityInterceptor 奇怪的权限拦截!</h3>\n<h4 id=\"项目调试过程记录\">项目调试过程记录</h4>\n<p><em>项目接口调用, 在<code>JwtAuthorizationTokenFilter</code> 认证成功,过滤链最后一个<code>org.springframework.security.web.access.intercept.FilterSecurityInterceptor</code> 权限投票失败,<code>AccessDeniedException: Access is denied</code>异常问题调试</em><br />\n被异常翻译过滤器<code>org.springframework.security.web.access.ExceptionTranslationFilter</code>, 翻译为403;</p>\n<p><code>FilterSecurityInterceptor</code> 该过滤器用于控制method级别的权限控制.也就是处理 <code>@PreAuthorize</code> 注解的过滤器</p>\n<ul>\n<li>org.springframework.security.access.vote.AffirmativeBased</li>\n</ul>\n<p><em>最终调到<code>org.springframework.security.access.vote.AffirmativeBased::decide</code> 方法</em></p>\n<pre><code class=\"language-java\">public void decide(Authentication authentication, Object object,\n\t\t\tCollection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException {\n\t\tint deny = 0;\n\nfor (AccessDecisionVoter voter: getDecisionVoters()) {\n    //只有一个 org.springframework.security.web.access.expression.WebExpressionVoter , 它投拒绝\n    int result = voter.vote(authentication, object, configAttributes);\n    switch (result) {\n    case AccessDecisionVoter.ACCESS_GRANTED:\n        return;\n\n    case AccessDecisionVoter.ACCESS_DENIED:\n        deny++;\n\n        break;\n\n    default:\n        break;\n    }\n}\n</code></pre>\n<p><strong>AffirmativeBased</strong> 的逻辑是这样的:<br />\n（1）只要有AccessDecisionVoter的投票为ACCESS_GRANTED则同意用户进行访问;<br />\n（2）如果全部弃权也表示通过;<br />\n（3）如果没有一个人投赞成票, 但是有人投反对票, 则将抛出AccessDeniedException;</p>\n<p><strong>AffirmativeBased</strong> 的投票接口列表(<strong>AccessDecisionVoter</strong>)只有一个*</p>\n<p><code>org.springframework.security.web.access.expression.WebExpressionVoter</code></p>\n<ul>\n<li>AccessDecisionVoter</li>\n</ul>\n<p><code>AccessDecisionVoter.vote()</code>方法的返回结果会是AccessDecisionVoter中定义的三个常量之一; ACCESS_GRANTED表示同意, ACCESS_DENIED表示拒绝, ACCESS_ABSTAIN表示弃权; 如果一个AccessDecisionVoter不能判定当前Authentication是否拥有访问对应受保护对象的权限, 则其vote()方法的返回值应当为弃权ACCESS_ABSTAIN;</p>\n<p><em>最最终在 <code>ReflectivePropertyAccessor$OptimalPropertyAccessor.read</code> 方法, 反射调用回 <code>WebSecurityExpressionRoot[SecurityExpressionRoot.isAnonymous()]</code>方法的返回值</em></p>\n<p>isAnonymous 顾名思义, 是否匿名...</p>\n<h4 id=\"解决方式\">解决方式</h4>\n<p>HttpSecurity 的配置 <code>.antMatchers(\"/auth/*\").anonymous()</code> (允许匿名用户, 而登陆用户不是匿名用户?) ..使用<code>permitAll</code> 替代之.</p>\n<pre><code class=\"language-java\">//例如\n.antMatchers(\"/auth/ttx\").anonymous()\n.antMatchers(\"/auth/ttp\").permitAll()\n</code></pre>\n<h3 id=\"记二-接口403无权限的问题\">记二 接口403无权限的问题!</h3>\n<h4 id=\"preauthorize-接口权限注解\">@PreAuthorize 接口权限注解</h4>\n<p>一般而言在 controller 通过<code>@PreAuthorize</code> 注解访问权限,<br />\n它调用的是在 <code>org.springframework.security.access.expression.SecurityExpressionRoot</code>里面的方法判断权限的 (EL表达式);</p>\n<blockquote>\n<p>记得需启用<code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></p>\n</blockquote>\n<p>最终是在 <code>org.springframework.security.access.prepost.PreInvocationAuthorizationAdviceVoter::vote</code>方法投票</p>\n<pre><code class=\"language-java\">public int vote(Authentication authentication, MethodInvocation method,\n        Collection&lt;ConfigAttribute&gt; attributes) {\n\n    // Find prefilter and preauth (or combined) attributes\n    // if both null, abstain\n    // else call advice with them\n\n    PreInvocationAttribute preAttr = findPreInvocationAttribute(attributes);\n\n    if (preAttr == null) {\n        // No expression based metadata, so abstain\n        return ACCESS_ABSTAIN;\n    }\n    //org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice\n    boolean allowed = preAdvice.before(authentication, method, preAttr);\n\n    return allowed ? ACCESS_GRANTED: ACCESS_DENIED;\n}\n\n\n//org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice :: before\n\tpublic boolean before(Authentication authentication, MethodInvocation mi,\n\t\t\tPreInvocationAttribute attr) {\n\t\tPreInvocationExpressionAttribute preAttr = (PreInvocationExpressionAttribute) attr;\n\t\tEvaluationContext ctx = expressionHandler.createEvaluationContext(authentication,\n\t\t\t\tmi);\n\t\tExpression preFilter = preAttr.getFilterExpression();\n\t\tExpression preAuthorize = preAttr.getAuthorizeExpression();\n\n\t\tif (preFilter != null) {\n\t\t\tObject filterTarget = findFilterTarget(preAttr.getFilterTarget(), ctx, mi);\n\n\t\t\texpressionHandler.filter(filterTarget, preFilter, ctx);\n\t\t}\n\n\t\tif (preAuthorize == null) {\n\t\t\treturn true;\n\t\t}\n        //这里执行 Spring EL表达式 \n\t\treturn ExpressionUtils.evaluateAsBoolean(preAuthorize, ctx);\n\t}\n\n\n\n// org.springframework.expression.spel.standard.SpelExpression::getValue 方法\npublic &lt;T&gt; T getValue(EvaluationContext context, @Nullable Class&lt;T&gt; expectedResultType) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext is required\");\n\n\t\tif (this.compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tObject result = this.compiledAst.getValue(context.getRootObject().getValue(), context);\n\t\t\t\tif (expectedResultType != null) {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.interpretedCount = 0;\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType);\n\t}\n///最最终 org.springframework.expression.spel.support.ReflectiveMethodExecutor::execute 方法 反射调用\n@Override\npublic TypedValue execute(EvaluationContext context, Object target, Object... arguments) throws AccessException {\n    try {\n        this.argumentConversionOccurred = ReflectionHelper.convertArguments(\n                context.getTypeConverter(), arguments, this.originalMethod, this.varargsPosition);\n        if (this.originalMethod.isVarArgs()) {\n            arguments = ReflectionHelper.setupArgumentsForVarargsInvocation(\n                    this.originalMethod.getParameterTypes(), arguments);\n        }\n        ReflectionUtils.makeAccessible(this.methodToInvoke);\n        \n        /**\n//this.methodToInvoke = public abstract boolean org.springframework.security.access.expression.SecurityExpressionOperations.hasAnyRole(java.lang.String[]) // 这是个抽象类, 实际调用 见下\n// target = org.springframework.security.access.expression.method.MethodSecurityExpressionRoot\n// arguments = ADMIN ... 角色代码数组\n       **/\n        Object value = this.methodToInvoke.invoke(target, arguments);\n        return new TypedValue(value, new TypeDescriptor(new MethodParameter(this.originalMethod, -1)).narrow(value));\n    }\n    catch (Exception ex) {\n        throw new AccessException(\"Problem invoking method: \" + this.methodToInvoke, ex);\n    }\n}\n//实际调用的是 org.springframework.security.access.expression.SecurityExpressionRoot 对象\n</code></pre>\n<h4 id=\"解决方式-1\">解决方式</h4>\n<p>注意 <code>org.springframework.security.access.expression.SecurityExpressionRoot</code> 有个属性它默认带<code>private String defaultRolePrefix = \"ROLE_\";</code>前缀 我*!</p>\n<p>定义一个 <code>GrantedAuthorityDefaults</code> bean 可以解决它</p>\n<pre><code class=\"language-java\">@Bean\nGrantedAuthorityDefaults grantedAuthorityDefaults() {\n    // Remove the ROLE_ prefix\n    return new GrantedAuthorityDefaults(\"\");\n}\n</code></pre>\n\n</div>\n<div id=\"MySignature\">\n    预防老年痴呆，保持终身学习!    —— <a href=\"https://www.cnblogs.com/dddy/\" target=\"_blank\">daidaidaiyu</a>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 21:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/dddy\">daidaidaiyu</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "C#/.NET/.NET Core优秀项目和框架2025年12月简报",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19444711",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19444711\" id=\"cb_post_title_url\" title=\"发布于 2026-01-05 21:01\">\n    <span>C#/.NET/.NET Core优秀项目和框架2025年12月简报</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205720027-409669949.png\" /></p>\n<h2><span>前言</span></h2>\n<p><span>公众号每月定期推广和分享的C#/.NET/.NET Core优秀项目和框架（每周至少会推荐两个优秀的项目和框架当然节假日除外），公众号推文中有项目和框架的详细介绍、功能特点、使用方式以及部分功能截图等（打不开或者打开GitHub很慢的同学可以优先查看公众号推文，文末一定会附带项目和框架源码地址）。注意：排名不分先后，都是十分优秀的开源项目和框架，每周定期更新分享<span>。</span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>💡简报Gitee开源地址：<a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectMonthly.md\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectMonthly.md</a></strong></li>\n<li><strong>🔔简报GitHub开源地址：<a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectMonthly.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectMonthly.md</a></strong></li>\n</ul>\n<h2><span>FlaUI</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>项目简介：</strong><span>&nbsp;FlaUI 是一个 .NET 开源免费（<span>MIT license）、功能强大 的 UI 自动化库，专为 Windows 桌面应用程序（如 Win32、WinForms、WPF、Store Apps 等应用）的自动化测试而设计。该项目基于 Microsoft 的原生 UI Automation 库构建，并作为这些库的封装器，提供了丰富的功能和灵活的 API，以便开发者能够高效地编写自动化测试脚本。</span></span></li>\n<li><strong>项目源码地址：</strong>&nbsp;<a href=\"https://github.com/FlaUI/FlaUI\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/FlaUI/FlaUI</a></li>\n<li><strong>项目详细介绍：</strong><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=MzIxMTUzNzM5Ng==&amp;mid=2247518968&amp;idx=1&amp;sn=5bdf3e28f94e488bdf752f9bb8c8898f&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/PE4S-fUyeG7U8Z78NYu6Rw</a></span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205745833-718718878.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251222211450021-574322057.png\" /></p>\n<h2><span>RuYiAdmin</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>项目简介：</strong><span>&nbsp;RuYiAdmin 一款基于 .NET 9 构建的企业级、前后端分离、开源（Apache License） Web RBAC 快速开发框架，具有灵活的架构设计和强大的功能，适用于快速开发高性能的企业级应用，具有低代码、跨平台、分布式、多线程和高性能等特色。</span></li>\n<li><strong>项目源码地址：</strong>&nbsp;<a href=\"https://gitee.com/pang-mingjun/RuYiAdmin\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/pang-mingjun/RuYiAdmin</a></li>\n<li><strong>项目详细介绍：</strong><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=MzIxMTUzNzM5Ng==&amp;mid=2247519045&amp;idx=1&amp;sn=e623f3c2c7adcc07fba70b65d13a38b2&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/XCcbLiV8Dhb9pfp8wi-Teg</a></span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205853857-1849985119.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205859134-1945950810.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205908099-602806087.png\" /></p>\n<h2><span>CxFlatUI</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>项目简介：</strong><span>&nbsp;CxFlatUI 是一款开源（Apache License）、现代化的 WinForm UI 控件库，值得大家参考学习使用。</span></li>\n<li><strong>项目源码地址：</strong>&nbsp;<a href=\"https://github.com/HuJinguang/CxFlatUI\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/HuJinguang/CxFlatUI</a></li>\n<li><strong>项目详细介绍：</strong><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=MzIxMTUzNzM5Ng==&amp;mid=2247518782&amp;idx=1&amp;sn=062e8d80f2798c045ed84af4402503ef&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/g1O4ngtrrFpS8yrDWbYz5A</a></span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205930598-1899511103.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205936788-530387827.png\" /></p>\n<h2><span>TypedSql</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>项目简介：</strong><span>&nbsp;TypedSQL 是一个小型实验性类 SQL 查询引擎，其执行计划依赖于 C# 类型系统。每个查询都变成由 Where / Select / Stop 节点构建的封闭泛型类型，完全通过静态方法运行，因此热路径中没有虚拟派遣或表达式树解释。</span></li>\n<li><strong>项目源码地址：</strong>&nbsp;<a href=\"https://github.com/hez2010/TypedSql\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/hez2010/TypedSql</a></li>\n<li><strong>项目详细介绍：</strong><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=MzIxMTUzNzM5Ng==&amp;mid=2247518856&amp;idx=1&amp;sn=3a2dfb720ffa6eb3167540f307ea5bc1&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/WkS6qjDslM2UWDdjpQsjuw</a></span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105210006154-1881076622.png\" /></p>\n<h2><span>OfficeInterop</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>项目简介：</strong><span>&nbsp;OfficeInterop 是一个针对 Microsoft Office 应用程序的 .NET 封装库，其核心目标是简化 Office COM 组件的使用，使开发者能够更方便、更高效地在 .NET 环境中操作 Office 应用程序，如 Excel、Word 等。</span></li>\n<li><strong>项目源码地址：</strong>&nbsp;<a href=\"https://gitee.com/mudtools/OfficeInterop\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/mudtools/OfficeInterop</a></li>\n<li><strong>项目详细介绍：</strong><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=MzIxMTUzNzM5Ng==&amp;mid=2247519132&amp;idx=1&amp;sn=30d44be5bd462bdee250a3c7b2b9861e&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/SOJdHwrP-X1suv0v8PNEcg</a></span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105210024912-785737110.png\" /></p>\n<h2><span>SuperSocket</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>项目简介：</strong><span>&nbsp;SuperSocket 是一个高性能、可扩展的.NET 套接字服务器应用程序框架。它提供了一个强大的架构，用于构建自定义网络通信应用程序，支持多种协议，包括 TCP、UDP 和 WebSocket。</span></li>\n<li><strong>项目源码地址：</strong>&nbsp;<a href=\"https://gitee.com/kerryjiang/SuperSocket\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/kerryjiang/SuperSocket</a></li>\n<li><strong>项目详细介绍：</strong><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=MzIxMTUzNzM5Ng==&amp;mid=2247518786&amp;idx=1&amp;sn=08b980a157a9b52619988321e264ee92&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/oNA-dDh80e-WI__9Itf2JA</a></span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105210044135-102801096.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105210049143-538169729.png\" /></p>\n<h2><span>SVGImage</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>项目简介：</strong><span>&nbsp;SVGImage 是一个为 WPF（Windows Presentation Foundation）应用程序设计、开源（MIT license）、免费的 SVG（Scalable Vector Graphics）图像查看控件。</span></li>\n<li><strong>项目源码地址：</strong>&nbsp;<a href=\"https://github.com/dotnetprojects/SVGImage\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/dotnetprojects/SVGImage</a></li>\n<li><strong>项目详细介绍：</strong><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=MzIxMTUzNzM5Ng==&amp;mid=2247519009&amp;idx=1&amp;sn=ed66ac9347dfd77bb102c8c2df546eab&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/69x0B6jhYja58Ze0NSi9ew</a></span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105210112231-249466901.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105210117130-1247635100.png\" /></p>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-05 21:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">19</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}