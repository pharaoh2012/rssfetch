{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "重磅发布，限时领取！2025 年 Apache DolphinScheduler 案例精选集，企业实战经验全览",
      "link": "https://www.cnblogs.com/DolphinScheduler/p/19457361",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/DolphinScheduler/p/19457361\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 16:00\">\n    <span>重磅发布，限时领取！2025 年 Apache DolphinScheduler 案例精选集，企业实战经验全览</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        过去一年，Apache DolphinScheduler 已深入更多企业生产环境，为复杂任务调度提供解决方案。社区精心整理了应用实践，汇编成《2025 年 Apache DolphinScheduler 案例精选集》，现已 重磅发布，限时 7 天免费领取！\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>过去一年，Apache DolphinScheduler 已深入更多企业生产环境，为复杂任务调度提供解决方案。社区精心整理了应用实践，汇编成《2025 年 Apache DolphinScheduler 案例精选集》，现已 <strong>重磅发布，限时 7 天免费领取</strong>！</p>\n<p><img alt=\"2025 年 Apache DolphinScheduler 案例精选集\" class=\"lazyload\" /></p>\n<p>本精选集汇总了 2025 年 Apache DolphinScheduler 在多家企业的典型实践，包括奇虎 360、天翼云、Zoom、网易邮箱与深圳某大型智能制造企业等。内容涵盖平台部署、容器化改造、任务迁移、流批统一调度、二次开发优化、资源隔离及数据集成等全流程应用场景，展示了企业在大规模数据调度与治理中的落地经验与技术探索。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>精选集旨在为企业数据团队、调度平台开发者及开源社区成员提供参考指南，帮助理解 DolphinScheduler 在复杂生产环境中的架构设计、性能优化及运维策略，同时展现其在智能化调度与数据治理场景中的应用潜力。</p>\n<p>本案例集由 <strong>Apache DolphinScheduler 社区（包括白鲸开源）志愿者</strong> 编撰整理。同时，特别感谢 <strong>王远朋、陆小龙、师彬杰、雷宝鑫、邱忠标</strong> 的实践经验与分享，以及所有 Apache DolphinScheduler 社区贡献者的持续投入，让本案例集得以完整呈现。</p>\n<p>📥 立即扫描二维码下载，获取企业实战经验与技术洞察，为您的数据平台建设提供参考与启发。</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 16:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/DolphinScheduler\">海豚调度</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【面试题】Redis 集群的实现原理是什么？",
      "link": "https://www.cnblogs.com/sun-10387834/p/19457309",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19457309\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 15:49\">\n    <span>【面试题】Redis 集群的实现原理是什么？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"redis集群原理就像外卖平台的多店铺配送系统-\">Redis集群原理：就像外卖平台的多店铺配送系统 🚚</h1>\n<h2 id=\"一整体比喻外卖平台如何运作\">一、整体比喻：外卖平台如何运作？</h2>\n<p>想象<strong>美团外卖平台</strong>：</p>\n<ul>\n<li><strong>多个餐厅</strong>：每个餐厅负责一部分菜品（数据分片）</li>\n<li><strong>配送中心</strong>：协调订单分配（集群管理）</li>\n<li><strong>骑手网络</strong>：互相传递信息（节点通信）</li>\n<li><strong>备用厨房</strong>：主厨病了，副厨顶上（主从复制）</li>\n</ul>\n<p><strong>Redis集群就是这样一个\"分布式外卖系统\"！</strong></p>\n<h2 id=\"二redis集群的核心原理\">二、Redis集群的核心原理</h2>\n<h3 id=\"1-数据分片每个餐厅只做自己的拿手菜-\">1. <strong>数据分片：每个餐厅只做自己的拿手菜</strong> 🍔</h3>\n<pre><code class=\"language-bash\"># Redis集群把数据分成16384个\"菜品槽\"（slots）\n# 就像把全城分成16384个配送区域\n\n# 假设有3个餐厅（Redis节点）：\n节点A: 负责槽 0-5460      # 做汉堡薯条\n节点B: 负责槽 5461-10922   # 做披萨意面  \n节点C: 负责槽 10923-16383  # 做中餐\n\n# 用户点\"宫保鸡丁\" → 系统计算：hash(\"宫保鸡丁\") % 16384 = 12000\n# 12000属于中餐区 → 自动派单给节点C（中餐餐厅）\n</code></pre>\n<p><strong>原理</strong>：</p>\n<ul>\n<li>每个键通过CRC16算法计算哈希值</li>\n<li>对16384取模，得到槽位</li>\n<li>数据存储到负责该槽的节点</li>\n</ul>\n<h3 id=\"2-集群架构餐厅联盟的三种角色-\">2. <strong>集群架构：餐厅联盟的三种角色</strong> 👥</h3>\n<pre><code>                  ┌─────────────────┐\n                  │   客户端App      │\n                  └────────┬────────┘\n                           │\n         ┌─────────────────┼─────────────────┐\n         ▼                 ▼                 ▼\n    ┌─────────┐      ┌─────────┐      ┌─────────┐\n    │ 主节点A  │      │ 主节点B  │      │ 主节点C  │\n    │ (主厨)   │      │ (主厨)   │      │ (主厨)   │\n    │ 槽0-5460 │      │5461-10922│      │10923-16383│\n    └────┬────┘      └────┬────┘      └────┬────┘\n         │                │                 │\n    ┌────▼────┐      ┌────▼────┐      ┌────▼────┐\n    │ 从节点A1 │      │ 从节点B1 │      │ 从节点C1 │\n    │ (副厨)   │      │ (副厨)   │      │ (副厨)   │\n    └─────────┘      └─────────┘      └─────────┘\n</code></pre>\n<p><strong>节点类型</strong>：</p>\n<ul>\n<li><strong>主节点</strong>：存储数据，处理读写请求（主厨）</li>\n<li><strong>从节点</strong>：复制主节点数据，只读（副厨）</li>\n<li><strong>哨兵节点</strong>：监控节点健康（餐厅卫生监督员）</li>\n</ul>\n<h3 id=\"3-节点通信餐厅经理们的微信群-\">3. <strong>节点通信：餐厅经理们的微信群</strong> 📱</h3>\n<pre><code class=\"language-bash\"># 节点间通过Gossip协议通信（就像微信群聊）\n# 每个节点都知道其他节点的：槽分配、在线状态、地址\n\n# 通信内容：\n1. \"我是餐厅A，负责汉堡区，我健康！\"\n2. \"餐厅C好像掉线了？有谁联系得上？\"\n3. \"新开了餐厅D，接手了披萨区一部分\"\n\n# Gossip协议特点：\n# - 定期广播（每100ms）\n# - 最终一致性（消息慢慢传开）\n# - 容错性强（几个餐厅掉线不影响）\n</code></pre>\n<h3 id=\"4-故障转移主厨病了副厨顶上-\">4. <strong>故障转移：主厨病了，副厨顶上</strong> 🚑</h3>\n<p><strong>场景</strong>：主节点A（汉堡主厨）突然心脏病发作（宕机）</p>\n<p><strong>流程</strong>：</p>\n<pre><code>1. 从节点A1发现主厨失联：\"主厨10秒没回我消息了！\"\n2. 向其他餐厅确认：\"你们联系得上汉堡主厨吗？\"\n3. 多数餐厅确认失联：\"我们也联系不上\"\n4. 选举新主厨：所有副厨投票，A1得票最多\n5. A1晋升为主厨：\"我来接管汉堡区！\"\n6. 更新微信群名片：A1改为主节点A\n</code></pre>\n<p><strong>技术实现</strong>：</p>\n<pre><code class=\"language-bash\"># Redis哨兵（Sentinel）监控机制\n1. 主观下线（SDOWN）：一个哨兵认为主节点不可用\n2. 客观下线（ODOWN）：超过半数哨兵认为不可用\n3. 选举领头哨兵：Raft算法选举\n4. 故障转移：领头哨兵选择最合适的从节点升级\n\n# Redis Cluster内置的故障检测\n1. 每个节点定期ping其他节点\n2. 标记疑似下线（PFAIL）\n3. 广播下线信息，其他节点确认\n4. 标记为已下线（FAIL）\n5. 从节点开始选举\n</code></pre>\n<h3 id=\"5-集群扩容开新分店-\">5. <strong>集群扩容：开新分店</strong> 🏪</h3>\n<p><strong>场景</strong>：生意太好，要开第四家餐厅（节点D）</p>\n<p><strong>流程</strong>：</p>\n<pre><code>1. 新餐厅加入：\"大家好，我是新开的日料店D\"\n2. 重新分配菜品槽：从A、B、C各分一些槽给D\n3. 数据迁移：把对应菜品搬到新餐厅\n    - A把\"薯条\"菜谱发给D\n    - B把\"海鲜披萨\"菜谱发给D\n    - C把\"麻婆豆腐\"菜谱发给D\n4. 迁移期间，用户点菜：\n    - 如果菜还在老店：\"稍等，正在搬到新店，去新店点\"\n    - 如果已搬到新店：\"请去新店点餐\"\n</code></pre>\n<p><strong>技术命令</strong>：</p>\n<pre><code class=\"language-bash\"># 1. 添加新节点\nredis-cli --cluster add-node new_host:new_port existing_host:existing_port\n\n# 2. 重新分配槽\nredis-cli --cluster reshard host:port\n\n# 3. 数据迁移是同步的，迁移期间集群仍可用\n# 迁移过程中，客户端可能收到ASK重定向\n</code></pre>\n<h2 id=\"三客户端如何与集群交互-\">三、客户端如何与集群交互？ 📲</h2>\n<h3 id=\"场景用户点餐流程\">场景：用户点餐流程</h3>\n<pre><code class=\"language-java\">// 客户端（用户）想点一份\"宫保鸡丁\"\npublic class RedisClient {\n    public void orderFood() {\n        // 1. 第一次请求，随便选个餐厅\n        String key = \"宫保鸡丁\";\n        JedisCluster jedis = new JedisCluster(nodes); // 连接集群\n        \n        // 2. 计算槽位：hash(\"宫保鸡丁\") % 16384 = 12000\n        // 3. 槽位12000属于节点C（中餐）\n        \n        // 4. 直接发给节点C\n        jedis.set(key, \"一份宫保鸡丁\");\n        \n        // 5. 如果发错餐厅（比如发给A），A会告诉你：\n        // \"MOVED 12000 节点C的地址\"\n        // 客户端自动重定向到节点C\n        \n        // 6. 聪明的客户端会缓存槽位映射表\n        // 下次直接找对的餐厅，不用重定向\n    }\n}\n</code></pre>\n<h3 id=\"两种重定向\">两种重定向：</h3>\n<pre><code class=\"language-bash\"># 1. MOVED重定向（永久重定向）\n# 就像：\"这道菜不是我们做的，你永远去中餐厅点\"\n客户端→节点A: 我要\"宫保鸡丁\"\n节点A→客户端: MOVED 12000 节点C地址\n客户端→节点C: 我要\"宫保鸡丁\"\n节点C→客户端: 好的，给你做\n\n# 2. ASK重定向（临时重定向）\n# 发生在数据迁移时\n# 就像：\"这道菜正在从我们店搬到新店，你去新店看看\"\n客户端→节点A: 我要\"薯条\"\n节点A→客户端: ASK 新节点地址  # 槽500正在迁移\n客户端→新节点: ASKING命令  # 先打个招呼\n客户端→新节点: 我要\"薯条\"\n新节点→客户端: 好的，我们刚接手这道菜\n</code></pre>\n<h2 id=\"四集群的限制不是万能的-\">四、集群的限制：不是万能的 🚧</h2>\n<h3 id=\"1-不支持跨节点事务\">1. <strong>不支持跨节点事务</strong></h3>\n<pre><code class=\"language-bash\"># 事务要求所有键在同一个节点\n# 就像：不能同时点汉堡店的汉堡和中餐厅的宫保鸡丁在一个订单里\n\n# ❌ 错误做法（键在不同节点）\nMULTI\nSET key1 value1  # key1在节点A\nSET key2 value2  # key2在节点B\nEXEC            # 会失败！\n\n# ✅ 正确做法：使用哈希标签\n# 用{}确保两个键在同一个槽\nMULTI\nSET user:{1000}:name \"张三\"  # 都在user:1000相关槽\nSET user:{1000}:age 25      # {}内内容决定槽\nEXEC\n</code></pre>\n<h3 id=\"2-批量操作限制\">2. <strong>批量操作限制</strong></h3>\n<pre><code class=\"language-bash\"># mget/mset只能用于同一个节点上的键\n# 就像：不能一次从汉堡店和中餐厅同时取餐\n\n# ❌ 可能失败\nMGET key1 key2 key3  # 如果key1、key2、key3在不同节点\n\n# ✅ 解决方案\n# 1. 使用哈希标签\n# 2. 客户端分组发送\n# 3. 使用Pipeline分别发送\n</code></pre>\n<h3 id=\"3-lua脚本限制\">3. <strong>Lua脚本限制</strong></h3>\n<pre><code class=\"language-bash\"># Lua脚本中的所有键必须在同一个节点\n# 就像：脚本厨师不能同时用汉堡店和中餐厅的厨房\n\n# 脚本示例（必须所有键在同一个槽）\nEVAL \"return redis.call('GET', KEYS[1])\" 1 user:{1000}:name\n</code></pre>\n<h2 id=\"五集群搭建实战开个小型外卖平台-️\">五、集群搭建实战：开个小型外卖平台 🛠️</h2>\n<h3 id=\"1-最少6个节点配置3主3从\">1. <strong>最少6个节点配置（3主3从）</strong></h3>\n<pre><code class=\"language-bash\"># 目录结构\nredis-cluster/\n├── node-7000/  # 主节点1\n├── node-7001/  # 主节点2  \n├── node-7002/  # 主节点3\n├── node-7003/  # 从节点1（复制7000）\n├── node-7004/  # 从节点2（复制7001）\n└── node-7005/  # 从节点3（复制7002）\n\n# 每个节点的redis.conf\nport 7000\ncluster-enabled yes\ncluster-config-file nodes-7000.conf\ncluster-node-timeout 5000\nappendonly yes\n</code></pre>\n<h3 id=\"2-一键创建集群\">2. <strong>一键创建集群</strong></h3>\n<pre><code class=\"language-bash\"># Redis 5.0+ 使用redis-cli创建\nredis-cli --cluster create \\\n  127.0.0.1:7000 \\\n  127.0.0.1:7001 \\\n  127.0.0.1:7002 \\\n  127.0.0.1:7003 \\\n  127.0.0.1:7004 \\\n  127.0.0.1:7005 \\\n  --cluster-replicas 1  # 每个主节点配1个从节点\n</code></pre>\n<h3 id=\"3-查看集群状态\">3. <strong>查看集群状态</strong></h3>\n<pre><code class=\"language-bash\"># 查看集群信息\nredis-cli -p 7000 cluster info\n\n# 查看节点信息\nredis-cli -p 7000 cluster nodes\n\n# 查看槽分配\nredis-cli -p 7000 cluster slots\n</code></pre>\n<h3 id=\"4-集群健康检查\">4. <strong>集群健康检查</strong></h3>\n<pre><code class=\"language-bash\"># 检查集群状态\nredis-cli --cluster check 127.0.0.1:7000\n\n# 输出示例：\n[OK] All nodes agree about slots configuration.\n&gt;&gt;&gt; Check for open slots...\n&gt;&gt;&gt; Check slots coverage...\n[OK] All 16384 slots covered.  # 所有槽都有节点负责\n</code></pre>\n<h2 id=\"六集群-vs-哨兵-vs-主从三种外卖模式对比-️\">六、集群 vs 哨兵 vs 主从：三种外卖模式对比 🍽️</h2>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>比喻</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>主从复制</strong></td>\n<td>一家餐厅+一个备用厨房</td>\n<td>简单、读写分离</td>\n<td>主节点单点故障</td>\n<td>小餐厅，可接受短暂停业</td>\n</tr>\n<tr>\n<td><strong>哨兵模式</strong></td>\n<td>餐厅+备用厨房+卫生监督员</td>\n<td>自动故障转移</td>\n<td>写操作单点、扩容麻烦</td>\n<td>中等餐厅，需要高可用</td>\n</tr>\n<tr>\n<td><strong>集群模式</strong></td>\n<td>多个餐厅联盟</td>\n<td>高可用、高并发、易扩容</td>\n<td>实现复杂、客户端需支持</td>\n<td>大型连锁餐厅，海量订单</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"七集群常见问题与解决方案-\">七、集群常见问题与解决方案 🚨</h2>\n<h3 id=\"1-脑裂问题split-brain\">1. <strong>脑裂问题（Split Brain）</strong></h3>\n<pre><code class=\"language-bash\"># 场景：网络分区，形成两个\"外卖平台\"\n# 节点A、B在一个网络，C、D在另一个网络\n# 两边都认为自己是\"正宗平台\"\n\n# 解决方案：多数派原则\n# 集群需要至少3个主节点，故障容忍度 = (N-1)/2\n# 3主节点：允许1个节点故障\n# 5主节点：允许2个节点故障\n</code></pre>\n<h3 id=\"2-数据一致性\">2. <strong>数据一致性</strong></h3>\n<pre><code class=\"language-bash\"># Redis集群采用异步复制\n# 主节点写成功就返回，然后异步复制到从节点\n# 可能丢失少量数据（主节点宕机前未同步的数据）\n\n# 解决方案（根据业务选择）：\n# 1. 等待复制：WAIT命令，等待N个从节点确认\n# 2. 强一致性：用Redlock等算法，但性能下降\n# 3. 最终一致性：接受短暂不一致，多数业务够用\n</code></pre>\n<h3 id=\"3-热点key问题\">3. <strong>热点Key问题</strong></h3>\n<pre><code class=\"language-bash\"># 场景：某个商品突然爆单（如iPhone新品）\n# 所有请求都打到同一个节点，造成压力\n\n# 解决方案：\n# 1. 本地缓存：客户端缓存热点数据\n# 2. 拆分Key：iphone:13:stock → iphone:13:stock:1、iphone:13:stock:2\n# 3. 限流降级：对热点请求限流\n</code></pre>\n<h3 id=\"4-集群扩容时的性能问题\">4. <strong>集群扩容时的性能问题</strong></h3>\n<pre><code class=\"language-bash\"># 迁移大量数据时，网络和磁盘IO压力大\n# 客户端频繁收到ASK重定向\n\n# 解决方案：\n# 1. 业务低峰期迁移\n# 2. 分批迁移，控制迁移速度\n# 3. 使用专业的迁移工具\n</code></pre>\n<h2 id=\"八redis集群最佳实践-\">八、Redis集群最佳实践 📚</h2>\n<h3 id=\"1-合理规划节点数\">1. <strong>合理规划节点数</strong></h3>\n<pre><code class=\"language-bash\"># 推荐配置：至少3主3从，最多1000个节点\n# 主节点数最好是奇数（选举时避免平票）\n# 每个主节点的从节点不超过2个（太多复制影响性能）\n\n# 生产环境建议：\n# 小规模：3主3从（可承受1主+1从同时故障）\n# 中规模：5主5从（可承受2主+2从同时故障）\n# 大规模：按业务分集群，不要一个集群太大\n</code></pre>\n<h3 id=\"2-监控指标\">2. <strong>监控指标</strong></h3>\n<pre><code class=\"language-bash\"># 关键监控项：\n1. 集群状态：cluster_state:ok?\n2. 槽覆盖率：16384个槽是否全部分配\n3. 节点健康：主从节点是否在线\n4. 内存使用：避免单个节点内存过大\n5. 网络流量：节点间通信是否正常\n6. 命中率：缓存命中率是否正常\n</code></pre>\n<h3 id=\"3-客户端使用规范\">3. <strong>客户端使用规范</strong></h3>\n<pre><code class=\"language-java\">public class RedisClusterBestPractice {\n    // 1. 使用连接池\n    private JedisCluster jedisCluster;\n    \n    public void init() {\n        JedisPoolConfig config = new JedisPoolConfig();\n        config.setMaxTotal(100);\n        config.setMaxIdle(20);\n        \n        Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();\n        nodes.add(new HostAndPort(\"127.0.0.1\", 7000));\n        // ... 添加所有节点\n        \n        // 2. 设置合理的超时时间\n        jedisCluster = new JedisCluster(nodes, \n            2000,  // 连接超时\n            2000,  // 读取超时\n            3,     // 重试次数\n            config);\n    }\n    \n    // 3. 使用Pipeline批量操作（相同节点）\n    public void batchSetSameSlot() {\n        String slotTag = \"{user:1000}\";  // 使用哈希标签\n        Pipeline p = jedisCluster.pipelined();\n        p.set(slotTag + \":name\", \"张三\");\n        p.set(slotTag + \":age\", \"25\");\n        p.sync();\n    }\n}\n</code></pre>\n<h2 id=\"九一张图总结redis集群-️\">九、一张图总结Redis集群 🗺️</h2>\n<pre><code>                ┌─────────────────────────────────────┐\n                │        Redis集群：外卖平台联盟         │\n                └────────────────┬────────────────────┘\n                                 │\n       ┌─────────────────────────┼─────────────────────────┐\n       ▼                         ▼                         ▼\n┌─────────────┐          ┌─────────────┐          ┌─────────────┐\n│  汉堡餐厅    │          │  披萨餐厅    │          │  中餐厅      │\n│ (主节点A)    │          │ (主节点B)    │          │ (主节点C)    │\n│ 槽0-5460    │          │ 5461-10922  │          │ 10923-16383 │\n└──────┬──────┘          └──────┬──────┘          └──────┬──────┘\n       │ 微信群聊(Gossip)        │                        │\n       ▼                        ▼                        ▼\n┌─────────────┐          ┌─────────────┐          ┌─────────────┐\n│  备用厨房    │          │  备用厨房    │          │  备用厨房    │\n│ (从节点A1)   │          │ (从节点B1)   │          │ (从节点C1)   │\n└─────────────┘          └─────────────┘          └─────────────┘\n       │                        │                        │\n       └────────────────────────┼────────────────────────┘\n                                 │\n                ┌────────────────▼────────────────┐\n                │          客户端(用户)              │\n                │    自动路由 + 缓存槽位映射         │\n                └──────────────────────────────────┘\n</code></pre>\n<h2 id=\"十一句话总结\">十、一句话总结</h2>\n<p><strong>Redis集群 = 数据分片（16384槽）+ 主从复制（高可用）+ Gossip通信（自管理）</strong></p>\n<p>记住口诀：<strong>\"一六三八四槽分，三主三从起步稳，Gossip协议传消息，故障转移自动跟，客户端需知槽映射，哈希标签保同门。\"</strong></p>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19457309\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19457309</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 15:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "你们的Agent写代码吗？Agent-Sandbox开源首发",
      "link": "https://www.cnblogs.com/xguo/p/19457007",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xguo/p/19457007\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 15:41\">\n    <span>你们的Agent写代码吗？Agent-Sandbox开源首发</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"你们的Agent写代码吗？Agent-Sandbox开源首发\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108145436183-1755523701.png\" />\n        Manus的高价出售，让Sandbox再次进入人们的视野，它之前用的Sandbox是E2B，这是一个非常强大的Sandbox工具，它可以帮助Agent执行代码或命令，但它不方便我们使用，之前我们的办法是部署一个Python的执行代码的服务，或着部署一个Playwright的服务，各自提供MCP或普通API，来满足需求，但是遇到的问题也是显而易见的，那就是无法实现多次访问的隔离，例如一个Agent访问了A网站，另一个Agent访问了B网站，就会相互干扰，性能也是问题，除非你部署很多实例，那也浪费。那我们的选择是什么？\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<div style=\"text-align: center;\">\n\n<img height=\"381px\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144423805-386973583.png\" width=\"255px\" />\n\n</div>\n<h2 id=\"开源地址\">开源地址：</h2>\n<p><strong>Agent-Sandbox</strong> <a href=\"https://github.com/agent-sandbox/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/agent-sandbox/agent-sandbox</a></p>\n<h2 id=\"效果预演\">效果预演：</h2>\n<p><img alt=\"gitdemo\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144402352-314698307.gif\" /></p>\n<h2 id=\"1为什么需要agent-sandbox\">1，为什么需要Agent-Sandbox？</h2>\n<p>在我们的业务中，经常需要让Agent执行一些代码或者访问网站等，例如用户提供了一个excel文件，处理里面的一些数据，最终生成报告，或者用户提供了一个网站，让Agent访问网站，然后获取一些数据，最终生成报告。</p>\n<p>这些都是很常见的场景，例如最近非常受关注的Manus，卖了很多钱的那个（羡慕啊～）,它就是利用了各种工具来完成用户的复杂任务，你们知道的。</p>\n<p>但问题来了，我们如何让Agent执行这些代码或者访问网站呢？</p>\n<p>因此Manus把E2B带火了，E2B是一个非常强大的Sandbox工具，它可以帮助Agent执行代码或命令，但是E2B基本上是个商业的，不方便我们使用，之前我们的办法是部署一个Python的执行代码的服务，或着部署一个Playwright的服务，各自提供MCP或普通API，来满足需求，但是遇到的问题也是显而易见的，那就是无法实现多次访问的隔离，例如一个Agent访问了A网站，另一个Agent访问了B网站，就会相互干扰，性能也是问题，除非你部署很多实例，那也浪费。</p>\n<p>这个问题你们是怎么解决的？</p>\n<h2 id=\"2agent-sandbox\">2，Agent-Sandbox</h2>\n<p>没有选择，只能自己搞了，上半年我们拉了几个兄弟，按照以上的痛点，开发了一个Agent-Sandbox，是的，名字就叫<strong>Agent-Sandbox</strong>，是不是很技术流，</p>\n<p>目前已经在生产环境使用了，效果还不错，支持MCP和REST API，Agent可以在任何需要的时候创建一个Sandbox，然后执行代码，访问网站等，完事儿后自己删除Sandbox，非常方便。</p>\n<p>不过最近也发现市面上出现很多关于Agent Sandbox的工具和讨论，开源的包括<a href=\"https://github.com/kubernetes-sigs/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">kubernetes-sigs/agent-sandbox</a> 、 <a href=\"https://github.com/agent-infra/sandbox\" rel=\"noopener nofollow\" target=\"_blank\">AIO Sandbox</a> 等，说明大家也在解决这个问题，AIO Sandbox这个是火山的，只提供一个集成化的Sandbox环境，也就是一个Docker的Image，里面有各种工具，包括执行代码、浏览器、文件系统等，而kubernetes-sigs/agent-sandbox是个部署工具，可以部署各种Sandbox环境，例如他就支持部署AIO Sandbox，可以通过它拉起很多AIO Sandbox的实例，但功能还是太基础了，无法直接给Agent使用，安装也麻烦，要求的Kubernetes版本比较高，目前大家生产用的K8S的版本都比较滞后。</p>\n<p>像我们这样开源的Sandbox还是没有看到，我们就决定把我们这个开源给大家，也许大家跟我们希望的一样，那就可以用得上了。</p>\n<h2 id=\"3agent-sandbox有哪些特点\">3，Agent-Sandbox有哪些特点？</h2>\n<p>目前实现了主要的功能，包括通过MCP或REST API来CRUD Sandbox，指定Sandbox的Image等，后续会支持更多场景的Sandbox运行环境，支持各种SDK，来满足编程场景的Sandbox控制，更多Sandbox的管理功能，包括TTL回收、无调用回收等，以及管理UI，可以看到在创建的全部Sandbox和相关操作，也可以通过这个UI来创建Sandbox等，方便与治理。</p>\n<p><img alt=\"full-lifecycle-demo\" height=\"601\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144446225-906065250.png\" width=\"1129\" /></p>\n<h3 id=\"特性\">特性：</h3>\n<ol>\n<li>Ai使用友好，可以直接让Agent控制Sandbox的全生命周期，而不一定得提前创建好，在给Agent去使用，Agent按需创建和回收；</li>\n<li>生态开放，部署的Sandbox运行环境可以与社区的兼容，列如可以直接拉起前面提到的AIO Sandbox、Code Server或Playwright等，方便大家利用现有的资源，当然，可以自定义运行环境；</li>\n<li>企业生产可用，当然，考虑前面提到的痛点，基于K8S开发，支持规模化使用，根据需要，可以大量创建Sandbox，相互之间隔离使用；</li>\n<li>轻量化，就一个组件，没有采用K8S的CRD来开发，这个后续用户按照和升级都比较麻烦，用户得接受一种新的资源类型，我们采用RS+Label的方式，尽量依赖K8S现有的特性来快速实现。</li>\n</ol>\n<h2 id=\"4如何使用agent-sandbox\">4，如何使用Agent-Sandbox？</h2>\n<p>所以怎么使用呢，</p>\n<h3 id=\"部署agent-sandbox\">部署Agent-Sandbox</h3>\n<p>要求 <strong>Kubernetes version 1.26</strong> 或以上，<br />\n在 <code>https://github.com/agent-sandbox/agent-sandbox</code> 下载 <code>install.yaml</code> 后，</p>\n<pre><code class=\"language-bash\">kubectl create namespace agent-sandbox\nkubectl apply -nagent-sandbox -f install.yaml\n</code></pre>\n<p>里面会安装deployment、service等，之后你应该是需要配置一个ingress，如：</p>\n<pre><code class=\"language-yaml\">apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: agent-sandbox\n  namespace: agent-sandbox\nspec:\n  ingressClassName: ingress-nginx\n  rules:\n  - host: agent-sandbox.your-host.com\n    http:\n      paths:\n      - backend:\n          service:\n            name: agent-sandbox\n            port:\n              number: 80\n        path: /(.*)\n</code></pre>\n<p>主要是 <code>host</code> 需要你给出，其他可以直接使用。正常情况访问 <code>http://agent-sandbox.your-host.com/mcp</code> 就可以给Agent用了，里面有对Sandbox的CURD等工具。</p>\n<h4 id=\"agent用mcp-server的演示\">Agent用MCP Server的演示：</h4>\n<p>园子无法上传mp4，看GitHub Readme吧，<a href=\"https://github.com/agent-sandbox/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/agent-sandbox/agent-sandbox</a></p>\n<h3 id=\"通过api来管理sandbox\">通过API来管理Sandbox</h3>\n<p>Agent-Sandbox提供RESTful API来管理Sandbox，典型的工作流程包括创建Sandbox、访问Sandbox、删除Sandbox。</p>\n<h4 id=\"创建一个sandbox\">创建一个Sandbox</h4>\n<pre><code class=\"language-shell\">curl --location '/api/v1/sandbox' \\\n--header 'Content-Type: application/json' \\\n--data '{\"name\":\"sandbox-01\"}'\n</code></pre>\n<p>默认会拉起AIO Sandbox，可以通过以下方式，指定国内镜像，</p>\n<pre><code class=\"language-shell\">curl --location '/api/v1/sandbox' \\\n--header 'Content-Type: application/json' \\\n--data '{\"name\":\"sandbox-01\",\"image\":\"enterprise-public-cn-beijing.cr.volces.com/vefaas-public/all-in-one-sandbox:latest\"}'\n</code></pre>\n<h4 id=\"访问sandbox\">访问Sandbox</h4>\n<p><code>/sandbox/{sandbox_name}</code> 通过这个地址可以访问Sandbox,</p>\n<p>例如刚才创建的 <strong>sandbox-01</strong> 访问地址是： <code>/sandbox/sandbox-01</code>.</p>\n<p>访问后你应该会看到：</p>\n<p><img alt=\"aio-demo\" height=\"956\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144513435-1606524670.jpg\" width=\"1464\" /></p>\n<p>访问这个Sandbox的MCP地址是： <code>http://agent-sandbox.your-host.com/sandbox/sandbox-01/mcp</code> ，这种场景是先创建好Sandbox，然后让Agent去访问这个Sandbox。</p>\n<h4 id=\"删除sandbox\">删除Sandbox</h4>\n<p>删除API： <code>/api/v1/sandbox/{sandbox_name}</code> . 例如删除Sandbox <code>sandbox-01</code> :<br />\n<strong>Shell</strong></p>\n<pre><code class=\"language-shell\">curl --location --request DELETE '/api/v1/sandbox/sandbox-01'\n</code></pre>\n<p><strong>结果:</strong></p>\n<pre><code class=\"language-json\">{\n  \"code\": \"0\",\n  \"data\": \"Sandbox sandbox-01 deleted successfully\"\n}\n</code></pre>\n<p>以上就是Agent-Sandbox的简单介绍和使用方法，更多内容请关注<a href=\"https://github.com/agent-sandbox/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">Agent-Sandbox</a>项目，后续我们会持续更新更多功能和特性，包括提到的支持更多场景的Sandbox运行环境，支持各种SDK来满足编程场景的Sandbox控制，更多Sandbox的管理功能，包括TTL回收、无调用回收，并发弹性伸缩等，以及管理UI，可以看到和管理创建的全部Sandbox，也可以通过这个UI来创建和操作Sandbox，例如上传下载文件、查看日志、执行命令、查看状态等。</p>\n<p>最后欢迎大家Star、Issue和PR~</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 15:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xguo\">i'm老土豆</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为什么很多伟大的作品都是诞生在一些不起眼的地方",
      "link": "https://www.cnblogs.com/lixingqiu/p/19457141",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lixingqiu/p/19457141\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 15:23\">\n    <span>为什么很多伟大的作品都是诞生在一些不起眼的地方</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在历史的长河中，我们不难发现，许多震撼人心、改变世界的伟大作品，往往并非出自繁华喧嚣的大都市，而是诞生于一些看似平凡甚至有些偏僻的角落。</p>\n<p>比如，梵高的许多传世画作，是在法国南部那个宁静的小村庄阿尔勒创作出来的。那里没有巴黎的灯红酒绿与艺术圈的纷繁复杂，有的只是质朴的田园风光和淳朴的村民。正是在这样相对安静的环境中，梵高得以全身心地投入到绘画创作中，用他那独特的笔触和色彩，描绘出一幅幅充满生命力的作品，给后世留下了无尽的艺术瑰宝。</p>\n<p>再比如，美国作家马克·吐温，他的许多经典文学作品，灵感来源于他童年生活的密西西比河畔小镇。那个远离城市喧嚣的地方，有着独特的风土人情和社会风貌，为他的写作提供了丰富的素材。他在那片土地上，观察着形形色色的人物，体验着生活的酸甜苦辣，从而创作出了《汤姆·索亚历险记》《哈克贝利·费恩历险记》等不朽之作。</p>\n<p>还有，著名的数学家陈景润，在一个并不起眼小县城里，默默钻研哥德巴赫猜想。在那个条件相对艰苦的环境中，他凭借着对数学的热爱和执着，克服了重重困难，最终取得了举世瞩目的成就，为数学领域的发展做出了巨大贡献。</p>\n<p>而如今，我们要说的<strong>C++精灵库</strong>，它的诞生地同样是一个毫不起眼的地方——江西省萍乡市。这里曾经是江南煤都，然而随着煤炭资源的枯竭，这座城市逐渐失去了往日的辉煌。人口不断流出，街头巷尾充斥着麻将声和抖音里各种喧闹的声音。想象一下，在这样的五线小城市里，年轻人大多选择逃离，前往长沙、南昌、杭州等大城市，甚至是一线城市去追寻自己的梦想，留下的大多是一些安于现状或者因各种原因无法离开的人。</p>\n<p>但是，就是在这样的环境中，却诞生了如此优秀的<strong>C++精灵库</strong>。它的背后，有一位了不起的人物——李兴球老师。李老师可是上世纪的学霸，年轻时曾在充满机遇与挑战的一线城市深圳闯荡了7年。自2010年发现Scratch图形化计算机语言以来，他便扎根在萍乡，从事青少儿编程教育长达10多年。</p>\n<p>时间来到2019年末，这是一个具有特殊意义的节点。李老师开始着手Python精灵模块的开发。为什么要开发这个模块呢？这源于李老师那颗始终充满好奇的心。在教学过程中，他敏锐地发现了Python turtle功能上的不足。比如说，想要让角色的造型图片进行缩放，或者是进行像素级别的碰撞检测，这些功能在Python turtle中都没有。于是，李老师便深入研究python turtle库的源文件turtle.py，经过不懈的努力，最终成功编写出了Python精灵模块。这一段经历，其实为后来C++精灵库的诞生埋下了深厚的根基，因为任何伟大的创新都不是凭空而来的，都需要有前期的积累和探索。</p>\n<p>岁月流转，到了2025年8月，暑假课程结束了。李老师那颗探索的心再次萌动起来。在人们的传统观念中，C++是一门非常难学的编程语言，似乎只有那些所谓的“小天才”才能掌握。这种观念流传至今，几乎已经固化。但李老师却不这么想，他一直思考着如何降低C++的教学门槛。一个大胆的想法在他脑海中浮现：能不能把Python turtle的命令移植到C++中呢？这样一来，学生们在学习了Python turtle之后再学习C++，岂不是会容易很多？</p>\n<p>为了实现这个想法，李老师进行了多方面的调研。他深入研究底层技术，了解现有的库是否能够满足需求。经过深思熟虑，李老师最终决定采用SDL2库进行全新编写。这样做的好处是显而易见的，基于工业级别的SDL2库，不仅底层代码可以全程掌握，而且拓展性极强，为后续的开发和完善提供了广阔的空间。</p>\n<p>在这个小城市里，李老师已经实现了生活无忧，并且能够完全掌控自己的时间，没有绩效考核等繁琐的压力。所以，暑假过后，从周一到周五，他每天都全身心地投入到C++精灵库的开发与调试工作中。有时候，一个小小的问题可能需要花费好几天的时间来解决。如果是在一线城市，这样的时间和人力成本无疑是巨大的，但在五线小城市，相对来说就显得微不足道了。也许，只有在这种相对“休闲”的状态中，人才能静下心来，专注于一件事情，从而做出伟大的、革命性的产品。</p>\n<p>如今，C++精灵库已经实现了超越。就拿它的链式调用来说，这种设计让代码更加优雅，更接近自然语言，大大降低了学习和使用的难度。李老师还精心设计了许多画笔颜色的调节命令，如penshade、pentone、pensat以及penhsv等，这些在Python turtle中都是没有的。这些独特的命令，为美术生的艺术创造打开了方便之门，让他们能够在编程的世界里更加自由地发挥想象力和创造力。</p>\n<p>让我们来看下面的C++代码：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:cpp;gutter:true;\">#include \"sprites.h\"  //包含C++精灵库 \nSprite turtle;       //建立角色叫turtle \n\nint main(){        //主功能块 \n   turtle.bgcolor(\"black\");\n   turtle.pensize(4).speed(0);\n   for(int i=0;i&lt;36;i++)\n       turtle.fd(10).left(10);\n   for(int i=0;i&lt;36;i++)\n       turtle.fd(10).right(10); \n    \n   turtle.ht(); \n   turtle.done();  \n   return 0;\n}\n</pre>\n</div>\n<p>　　再看下对应的Python turtle代码：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:php;gutter:true;\">import turtle\nturtle.bgcolor(\"black\")\nturtle.pensize(4)\nturtle.speed(0)\nfor i in range(36):\n    turtle.fd(10)\n    turtle.left(10)\nfor i in range(36):\n    turtle.fd(10)\n    turtle.right(10)\n</pre>\n</div>\n<p>　　</p>\n<p>它们的本质是一样的！C++版本的核心逻辑代码，只需稍加修改，将C++的链式调用改成Python的单个命令调用，复制到Python IDLE中就能运行。不过，这一改，倒是把原本优雅的C++代码换成了传统的Python书写方式。</p>\n<p>所以说，为什么很多伟大的作品都是诞生在一些不起眼的地方呢？因为在这里，人们可以摆脱外界的干扰和压力，以最低的成本去追求自己的理想，同时又能将自己的价值最大化。就像C++精灵库一样，它在萍乡这个小城市里诞生，却有可能为整个编程教育领域带来深远的影响。</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-08 15:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lixingqiu\">李兴球</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "欧拉函数",
      "link": "https://www.cnblogs.com/Samhu07/p/19455379",
      "published": "",
      "description": "<div class=\"postcontent\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        欧拉函数\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>本文是对<a href=\"https://blog.csdn.net/Wxb314/article/details/148166969\" rel=\"noopener nofollow\" target=\"_blank\">这篇文章</a>的补充说明，补充了一些结论4的一些细节</p>\n<p><span class=\"math inline\">\\(\\varphi(n)\\)</span> 表示的是小于等于 $ 𝑛 $ 和 $ 𝑛 $ 互质的数的个数</p>\n<h1 id=\"结论1\">结论1</h1>\n<p><span class=\"math inline\">\\(p\\)</span> 为质数，则 <span class=\"math inline\">\\(\\varphi(p) = p - 1\\)</span></p>\n<h1 id=\"结论2\">结论2</h1>\n<p><span class=\"math inline\">\\(p\\)</span> 为质数，则 <span class=\"math inline\">\\(\\varphi(p^k) = p^k-p^{k-1} = (p-1) \\times p^{k-1}\\)</span><br />\n证明：<br />\n<span class=\"math inline\">\\(\\because 1\\)</span> 到 <span class=\"math inline\">\\(p^k\\)</span> 中共有 <span class=\"math inline\">\\(p^{k-1}\\)</span> 个数是 <span class=\"math inline\">\\(p\\)</span> 的倍数<br />\n$\\therefore $ 与 <span class=\"math inline\">\\(p^k\\)</span> 互质的数有 <span class=\"math inline\">\\(p^k-p^{k-1}\\)</span> 个</p>\n<h1 id=\"结论3\">结论3</h1>\n<p><span class=\"math inline\">\\(p,q\\)</span> 为互异质数，则 <span class=\"math inline\">\\(\\varphi(pq) = \\varphi(p) \\times \\varphi(q)\\)</span><br />\n证明:<br />\n<span class=\"math inline\">\\(\\varphi(p) = p - 1, \\varphi(q) = q - 1\\)</span><br />\n<span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(pq\\)</span> 中有 <span class=\"math inline\">\\(q\\)</span> 个 <span class=\"math inline\">\\(p\\)</span> 的倍数， <span class=\"math inline\">\\(p\\)</span> 个 <span class=\"math inline\">\\(q\\)</span> 的倍数，其中 <span class=\"math inline\">\\(pq\\)</span> 算了两次<br />\n<span class=\"math inline\">\\(\\therefore \\varphi (pq) = pq-p-q+1=(p-1)(q-1)=\\varphi (p) \\times \\varphi (q)\\)</span></p>\n<h1 id=\"结论4\">结论4</h1>\n<p><span class=\"math inline\">\\(p,q\\)</span> 为互异质数，则 <span class=\"math inline\">\\(\\varphi(p^a  q^b) = \\varphi(p^a) \\times \\varphi(q^b)\\)</span><br />\n证明：<br />\n<span class=\"math inline\">\\(\\varphi(p^a) = (p-1) \\times p^{a-1} , \\varphi(q^b) = (q-1) \\times q^{b-1}\\)</span><br />\n<span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(p^a q^b\\)</span> 中有 <span class=\"math inline\">\\(p^{a-1} q^b\\)</span> 个 <span class=\"math inline\">\\(p\\)</span> 的倍数， <span class=\"math inline\">\\(p^a q^{b-1}\\)</span> 个 <span class=\"math inline\">\\(q\\)</span> 的倍数， <span class=\"math inline\">\\(p^{a-1} q^{b-1}\\)</span> 个 <span class=\"math inline\">\\(pq\\)</span> 的倍数</p>\n<p><span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(p^a q^b\\)</span> 中与 <span class=\"math inline\">\\(p^aq^b\\)</span> 不互质的数有 <span class=\"math inline\">\\(p^{a-1} q^b+p^a q^{b-1}-p^{a-1} q^{b-1}\\)</span> 个</p>\n<p><span class=\"math inline\">\\(\\begin{align*}\n\\varphi(p^a  q^b) &amp;= p^aq^b-p^{a-1} q^b-p^a q^{b-1}+p^{a-1} q^{b-1} \\\\\n                  &amp;= (pq-q-p+1)p^{a-1} q^{b-1} \\\\\n                  &amp;= (p-1)p^{a-1}(q-1)q^{b-1} \\\\\n                  &amp;= \\varphi(p^a) \\times \\varphi(q^b)\n\\end{align*}\\)</span></p>\n<h1 id=\"结论45\">结论4.5</h1>\n<p>推广： <span class=\"math inline\">\\(\\varphi({\\textstyle \\prod_{i=1}^{n}} p_i^{a_i})= {\\textstyle \\prod_{i=1}^{n}}\\varphi( p_i^{a_i})\\)</span><br />\n证明：<br />\n考虑数学归纳法<br />\n假设第 <span class=\"math inline\">\\(n\\)</span> 项成立，设 <span class=\"math inline\">\\(m={\\textstyle \\prod_{i=1}^{m+1}}p_i^{a_i},A={\\textstyle \\prod_{i=1}^{m}}p_i^{a_i},B=p_{n+1}^{a_{n+1}}\\)</span></p>\n<h5 id=\"1--到--中与--不互质的数有--个\">（1） <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(m\\)</span> 中与 <span class=\"math inline\">\\(A\\)</span> 不互质的数有 <span class=\"math inline\">\\((A - \\varphi (A)) \\times B\\)</span> 个</h5>\n<p>解释：<br />\n设 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(m\\)</span> 中与 <span class=\"math inline\">\\(A\\)</span> 不互质的数为 <span class=\"math inline\">\\(b\\)</span><br />\n设 <span class=\"math inline\">\\(b = kA+a,0\\le k\\le B-1,1\\le a \\le A\\)</span><br />\n（注意，这里对 <span class=\"math inline\">\\(b\\)</span> 的分解不同于普通的 <span class=\"math inline\">\\(\\bmod A\\)</span> ，但仍然保持一一对应的关系）<br />\n<span class=\"math inline\">\\(gcd(b,A) = gcd(kA+a,A) = gcd(a,A)\\)</span><br />\n$\\therefore $ 要使 <span class=\"math inline\">\\(b\\)</span> 与 <span class=\"math inline\">\\(A\\)</span> 不互质，充要条件是 <span class=\"math inline\">\\(a\\)</span> 与 <span class=\"math inline\">\\(A\\)</span> 不互质，而与 <span class=\"math inline\">\\(k\\)</span> 无关<br />\n<span class=\"math inline\">\\(a\\)</span> 有 <span class=\"math inline\">\\((A - \\varphi (A))\\)</span> 个取值， <span class=\"math inline\">\\(k\\)</span> 有 <span class=\"math inline\">\\(B\\)</span> 个取值<br />\n$\\therefore b $ 有 <span class=\"math inline\">\\((A - \\varphi (A)) \\times B\\)</span> 个取值</p>\n<h5 id=\"2---到--中与--不互质的数有--个\">（2）  <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(m\\)</span> 中与 <span class=\"math inline\">\\(B\\)</span> 不互质的数有 <span class=\"math inline\">\\((B - \\varphi (B)) \\times A\\)</span> 个</h5>\n<p>同理可得</p>\n<h5 id=\"3---到--中与--不互质与--不互质的数有--个\">（3）  <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(m\\)</span> 中与 <span class=\"math inline\">\\(A\\)</span> 不互质、与 <span class=\"math inline\">\\(B\\)</span> 不互质的数有 <span class=\"math inline\">\\((A - \\varphi (A)) \\times (B - \\varphi (B))\\)</span> 个</h5>\n<hr />\n<p>引理：在模 <span class=\"math inline\">\\(p_{n+1}\\)</span> 时， <span class=\"math inline\">\\(yA(0 \\le y \\le p_{n+1}-1)\\)</span> 互不相等<br />\n考虑反证<br />\n假设 <span class=\"math inline\">\\(\\exists y_1,y_2\\in [0,p_{n+1}-1],y_1\\ne y_2,\\)</span><br />\n$y_1A \\equiv y_2A \\pmod{p_{n+1}} $<br />\n则 <span class=\"math inline\">\\((y_1-y_2)A \\equiv 0 \\pmod{p_{n+1}}\\)</span><br />\n<span class=\"math inline\">\\(\\because gcd(A,p_{n+1})=1\\)</span><br />\n<span class=\"math inline\">\\(\\therefore y_1-y_2\\equiv 0 \\pmod{p_{n+1}}\\)</span><br />\n矛盾<br />\n此事在费马小定理中亦有记载</p>\n<hr />\n<p>依旧设 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(m\\)</span> 中与 <span class=\"math inline\">\\(A\\)</span> 不互质的数为 <span class=\"math inline\">\\(b\\)</span><br />\n依旧设 <span class=\"math inline\">\\(b = kA+a,0\\le k\\le B-1,1\\le a \\le A\\)</span><br />\n设 <span class=\"math inline\">\\(k=xp_{n+1}+y,0\\le x\\le p_{n+1}^{a_{n+1}-1}-1,0\\le y\\le p_{n+1}-1\\)</span><br />\n<span class=\"math inline\">\\(b=(xp_{n+1}+y)A+a=Axp_{n+1}+yA+a\\)</span><br />\n要使 <span class=\"math inline\">\\(b\\)</span> 与 <span class=\"math inline\">\\(A\\)</span> 不互质， <span class=\"math inline\">\\(a\\)</span> 有 <span class=\"math inline\">\\(A-\\varphi(A)\\)</span> 个取值<br />\n要使 <span class=\"math inline\">\\(b\\)</span> 与 <span class=\"math inline\">\\(B\\)</span> 不互质，即 <span class=\"math inline\">\\(b\\)</span> 是 <span class=\"math inline\">\\(p_{n+1}\\)</span> 的倍数，<br />\n由引理得，对于任意的 <span class=\"math inline\">\\(a\\)</span> 与 <span class=\"math inline\">\\(x\\)</span>，有且仅有 1 个 <span class=\"math inline\">\\(y\\)</span> 使 <span class=\"math inline\">\\(b\\)</span> 是 <span class=\"math inline\">\\(p_{n+1}\\)</span> 的倍数。<br />\n<span class=\"math inline\">\\(x\\)</span> 有 <span class=\"math inline\">\\(p_{n+1}^{a_{n+1}-1}\\)</span> 种取值，<span class=\"math inline\">\\(a\\)</span> 有 <span class=\"math inline\">\\(A-\\varphi(A)\\)</span> 种取值，<span class=\"math inline\">\\(y\\)</span> 在 <span class=\"math inline\">\\(x\\)</span> 与 <span class=\"math inline\">\\(a\\)</span> 确定时只有一种取值<br />\n故共有 <span class=\"math inline\">\\(p_{n+1}^{a_{n+1}-1} \\times (A-\\varphi(A)) = (A - \\varphi (A)) \\times (B - \\varphi (B))\\)</span> 种取值</p>\n<hr />\n<p>综上， <span class=\"math inline\">\\(\\varphi(m)=\\varphi(AB)=AB-(A - \\varphi (A)) \\times B-(B - \\varphi (B)) \\times A+(A - \\varphi (A)) \\times (B - \\varphi (B))=\\varphi(A)\\varphi(B)\\)</span></p>\n<h1 id=\"总结\">总结</h1>\n<p>对于结论3、结论4、结论4.5的证明都用到了以下结构：<br />\n<span class=\"math inline\">\\(\\varphi (xy)=xy- 与 x 不互质的数的个数 - 与 y 不互质的数的个数 + 与 x , y 都不互质的数的个数\\)</span><br />\n这是容斥思想的体现</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"itemdesc\">\n\t\t\tposted on \n<span id=\"post-date\">2026-01-08 15:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Samhu07\">Samhu07</a>&nbsp;\n阅读(<span id=\"post_view_count\">8</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</div>"
    },
    {
      "title": "自适应可变速率ID生成器的设计与实践(视频)",
      "link": "https://www.cnblogs.com/Zongsoft/p/19457036/sequence",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Zongsoft/p/19457036/sequence\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 15:03\">\n    <span>自适应可变速率ID生成器的设计与实践(视频)</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2026-01-08 15:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Zongsoft\">Zongsoft</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n            <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在分布式系统架构中，全局唯一ID生成器是支撑高并发、高可用系统的基石。市面上的常见方案（如Snowflake-ID、UUID、Redis自增）各有优劣，但往往难以兼顾高性能、无中心化与灵活的业务需求。\n本系列视频将带你深入剖析一个开源项目中的核心组件，重点解析如何设计一款能智能适应流量波动、兼顾全局唯一与趋势递增特性的高性能ID生成器。我们将从理论设计、性能压测到源码实现，全方位解读这套算法如何在保证极高吞吐量的同时，实现毫秒级的自适应与可变速率调节。\n无论你是架构师、后端开发工程师，还是对高性能算法感兴趣的爱好者，这个系列都将为你提供宝贵的实战经验和深度的技术洞察。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在分布式系统设计中，ID生成器 <em>(<strong>S</strong>equence)</em> 是看似基础却至关重要的组件。然而，一些常用解决方案 <em>(如 Snowflake-ID 算法)</em> 在高并发、弹性伸缩场景下，常面临机器节点分配、时钟回拨、序列号耗尽、跨机房容错等挑战。你是否也曾为这些问题困扰？</p>\n<p><a href=\"http://zongsoft.com\" rel=\"noopener nofollow\" target=\"_blank\"><em><strong>Z</strong>ongsoft</em></a> 开源项目中的 <a href=\"https://github.com/Zongsoft/framework/blob/master/Zongsoft.Core/src/Common/Sequence.cs\" rel=\"noopener nofollow\" target=\"_blank\"><em>自适应可变速率ID生成器</em></a>，或许能为你提供一种新的思路。</p>\n<p>我强烈推荐大家关注近期上线的 <strong>视频系列</strong>：《<a href=\"https://space.bilibili.com/20995572\" rel=\"noopener nofollow\" target=\"_blank\">自适应可变速率ID生成器的设计与实践</a>》。</p>\n<p>系列视频采取 “<strong>理论</strong>-<strong>实验</strong>-<strong>源码</strong>” 三层递进结构，涵盖从设计理念到性能验证再到实现细节的完整知识链，展示了如何设计并实现一个智能适应流量波动、兼顾全局唯一与高信息密度、高性能的解决方案。无论是分布式系统初学者还是资深工程师都能从中获益。其亮点在于：</p>\n<ol>\n<li>\n<p><strong>直面痛点，突破传统局限​</strong></p>\n<p>视频中对比了 Snowflake-ID、UUID、数据库自增等方案的优劣，并重点解析了如何通过动态速率调整和时钟回拨容错机制，避免序列号争用与时间同步问题。这种设计尤其适合流量突增场景 <em>（如秒杀、日志高频写入）</em>，显著提升系统的稳定性。</p>\n</li>\n<li>\n<p><strong>实验驱动，数据说话​</strong></p>\n<p>系列中通过 <strong>6</strong> 组严谨实验，验证了算法在性能、正确性、稳定性方面的表现，并与原生 Redis 生成器进行对比。结果清晰展示了其在高压下的吞吐量优势，为技术选型提供了可靠依据。</p>\n</li>\n<li>\n<p><strong>开源实战，源码级解读​</strong></p>\n<p>视频直接基于 <a href=\"https://github.com/Zongsoft/framework\" rel=\"noopener nofollow\" target=\"_blank\"><em><strong>Z</strong>ongsoft</em></a> 开源项目代码解析，从位运算设计到异常处理逻辑，逐行拆解实现细节。无论是学习分布式系统设计，还是需要二次开发，都具有极高参考价值。</p>\n</li>\n</ol>\n<blockquote>\n<p>无论你是架构师、后端开发工程师，还是对高性能算法感兴趣的爱好者，这个系列都将为你提供宝贵的实战经验和深度的技术洞察。又或者你正在构建高并发系统，或对分布式基础组件有深入探索的兴趣，这一系列视频将是不可多得的学习资源。<br />\n它不仅能帮助你理解ID生成器的本质，更能拓宽解决复杂问题的思路。</p>\n</blockquote>\n<hr />\n<h3 id=\"-视频-1自适应可变速率id生成器设计与实践上\">🎥 视频 1：自适应可变速率ID生成器设计与实践(上)</h3>\n<blockquote>\n<p>副标题： 从理论到架构：为什么我们需要新的ID生成方案？<br /><br />\n视频地址：<a href=\"https://www.bilibili.com/video/BV15fiSBXEW5\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV15fiSBXEW5</a></p>\n</blockquote>\n<p>在本系列的第一部分，我们将首先对现有的常见分布式ID生成方案进行深度的横向对比与剖析。</p>\n<p>深入探讨 Snowflake ID 的机器节点分配和时钟回拨、时钟漂移问题、UUID 的无序性、时钟问题与存储浪费、数据库自增ID的性能瓶颈与各种限制，以及 Redis 递增方案的优缺点。</p>\n<p>详细阐述本算法的设计初衷与核心理念；在此基础上，视频深入阐述自适应可变速率ID生成器的设计目标与核心理念，重点讲解如何通过动态速率调整、时钟回拨容错等机制，解决传统方案在高并发场景下的序列号耗尽、时钟同步等痛点问题。该视频为理解后续实验与源码实现奠定理论基础。</p>\n<h3 id=\"-视频-2自适应可变速率id生成器设计与实践中\">🎥 视频 2：自适应可变速率ID生成器设计与实践(中)</h3>\n<blockquote>\n<p>副标题： 数据说话：性能、稳定性与正确性的硬核实测<br /><br />\n视频地址：<a href=\"https://www.bilibili.com/video/BV1EQiSBtE38\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV1EQiSBtE38</a></p>\n</blockquote>\n<p>光有理论不够，数据才是硬道理。在本集中，我们将通过 <strong>6</strong> 个精心设计的实验，对算法进行全方位的压力测试与验证：</p>\n<ul>\n<li>核心指标：验证生成器在高并发场景下的吞吐量（TPS）与响应延迟。</li>\n<li>稳定性测试：模拟延迟环境中，算法在长时间高并发运行下的稳定性与正确性。</li>\n<li>横向对比：我们将本算法与原生 Redis 生成器进行同场景下的性能对比，直观展示其在资源消耗与生成效率上的优势。</li>\n</ul>\n<blockquote>\n<p>通过这些实验，你将看到这套算法在实际应用中表现出的卓越性能。</p>\n</blockquote>\n<p>视频特别设置了与原生 Redis 生成器的对比测试，通过量化数据展现自适应算法在可变负载场景下的性能优势。例如，在流量突增时，传统生成器可能因序列号快速耗尽而导致ID生成延迟或阻塞，而自适应算法能动态调整生成策略，保持高性能与稳定性。这些实验为开发者提供了客观的评估依据，帮助他们在技术选型时做出明智决策。</p>\n<h3 id=\"-视频-3自适应可变速率id生成器设计与实践下\">🎥 视频 3：自适应可变速率ID生成器设计与实践(下)</h3>\n<blockquote>\n<p>副标题： 源码深潜：揭秘核心逻辑与环境配置<br /><br />\n视频地址：即将发布，请关注微信公众号(<code>Zongsoft</code>)以获得及时发布通知。</p>\n</blockquote>\n<p>最后一集，我们将带你潜入代码深处，直面该算法的核心实现以及如何快速搭建开发与测试环境。</p>\n<p>逐行剖析 <a href=\"https://github.com/Zongsoft/framework/blob/master/Zongsoft.Core/src/Common/Sequence.cs\" rel=\"noopener nofollow\" target=\"_blank\">Sequence</a> 类的关键逻辑，解读代理模式封装、动态步长调整、本地无锁递增、边界保障机制、时序感知优化等核心代码块。<br />\n详细介绍算法运行所需的环境依赖与配置参数，帮助你快速将这套高性能组件集成到自己的项目中。</p>\n<p>通过本集，你将掌握从源码到部署的全链路能力——不仅 <em>“用得上”</em>，更能 <em>“懂透原理”</em>，在实际项目中快速构建出自适应、高可靠、零运维的ID生成服务，为高并发系统筑牢基石。</p>\n<hr />\n<ul>\n<li>Bilibili\n<blockquote>\n<p><a href=\"https://space.bilibili.com/20995572\" rel=\"noopener nofollow\" target=\"_blank\">https://space.bilibili.com/20995572</a></p>\n</blockquote>\n</li>\n<li>抖音\n<blockquote>\n<p><a href=\"https://www.douyin.com/user/MS4wLjABAAAA9NmpuYVoLopaB6XdHoQ1CcmDF5DIb5YgwKzBLjZZdyU\" rel=\"noopener nofollow\" target=\"_blank\">https://www.douyin.com/user/MS4wLjABAAAA9NmpuYVoLopaB6XdHoQ1CcmDF5DIb5YgwKzBLjZZdyU</a></p>\n</blockquote>\n</li>\n<li>微信公众号\n<blockquote>\n<p><img alt=\"Zongsoft 微信公众号\" class=\"lazyload\" /></p>\n</blockquote>\n</li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    <div style=\"text-align: center;\">\n\t<img src=\"https://raw.githubusercontent.com/Zongsoft/Guidelines/master/zongsoft-qrcode%28wechat%29.png\" />\n</div>\n\n<hr style=\"margin-top: 2em; margin-bottom: 2em; margin-left: 0; margin-right: 0; padding: 0; height: 2px; border: 0; background-color: #e8e8e8;\" />\n\n<div id=\"license\">\n\t<img src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" width=\"\" />\n\t<p style=\"margin-top: 4px;\">\n本作品采用 <a class=\"bi-link\" href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" target=\"_blank\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a> 进行许可。欢迎转载、使用、重新发布，但必须保留本文的署名 <a class=\"bi-link\" href=\"https://github.com/zongsoft\" target=\"_blank\">钟峰</a>（包含链接：<a class=\"bi-link\" href=\"http://zongsoft.github.io/\" target=\"_blank\">http://zongsoft.github.io</a>），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问或授权方面的协商，请致信给我 (zongsoft@qq.com)。\n\t</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "强烈推荐 | 阿里开源的这10个神级项目",
      "link": "https://www.cnblogs.com/12lisu/p/19456855",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19456855\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 14:35\">\n    <span>强烈推荐 | 阿里开源的这10个神级项目</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>最近趁着放假休息，特地整理了一下，阿里巴巴开源的10款神级项目。</p>\n<p>这些开源项目中的绝大多数，我都在实际工作中用过，或者有同事用过。确实挺不错，挺有价值的，现在推荐给大家。</p>\n<h2 id=\"1-druid\">1. Druid</h2>\n<p>Druid自称是Java语言中最好的数据库连接池，它能够提供强大的监控和扩展功能。监控后台如下图所示：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>Druid的主要优点如下：</p>\n<ul>\n<li>它能监控数据库访问性能。</li>\n<li>它提供了WallFilter，它是基于SQL语义分析来实现防御SQL注入攻击的。</li>\n<li>它提供了多种监测连接泄漏的手段。</li>\n<li>它提供了数据库密码加密的功能。</li>\n<li>它能打印SQL执行日志。</li>\n</ul>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/druid\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/druid</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba/druid\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba/druid</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n\t\t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;druid&lt;/artifactId&gt;\n\t\t&lt;version&gt;${druid-version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"2-fastjson\">2. fastjson</h2>\n<p><code>fastjson</code>是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p>\n<p>fastjson的主要优点如下：</p>\n<ul>\n<li>速度快，fastjson相对其他JSON库的特点是快，从2011年fastjson发布1.1.x版本之后，其性能从未被其他Java实现的JSON库超越。</li>\n<li>使用广泛，fastjson在阿里巴巴大规模使用，在数万台服务器上部署，fastjson在业界被广泛接受。在2012年被开源中国评选为最受欢迎的国产开源软件之一。</li>\n<li>使用简单，fastjson的API十分简洁。</li>\n</ul>\n<pre><code class=\"language-java\">//序列化\nString text = JSON.toJSONString(obj); \n//反序列化\nVO vo = JSON.parseObject(\"{...}\", VO.class); \n</code></pre>\n<ul>\n<li>功能完备，支持泛型，支持流处理超大文本，支持枚举，支持序列化和反序列化扩展。</li>\n</ul>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/fastjson\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/fastjson</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba/fastjson\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba/fastjson</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n    &lt;version&gt;1.2.76&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"3-dubbo\">3. Dubbo</h2>\n<p>Apache Dubbo 是一款微服务开发框架，它提供了 RPC通信 与 微服务治理 两大关键能力。这意味着，使用 Dubbo 开发的微服务，将具备相互之间的远程发现与通信能力， 同时利用 Dubbo 提供的丰富服务治理能力，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。</p>\n<p>同时 Dubbo 是高度可扩展的，用户几乎可以在任意功能点去定制自己的实现，以改变框架的默认行为来满足自己的业务需求。它目前已交给Apache管理和维护。</p>\n<p>架构图如下：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>Dubbo的主要优点如下：</p>\n<ul>\n<li>基于透明接口的RPC</li>\n<li>智能负载均衡</li>\n<li>自动服务注册和发现</li>\n<li>高扩展性</li>\n<li>运行时流量路由</li>\n<li>可视化服务治理</li>\n<li>云原生友好</li>\n</ul>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/apache/dubbo\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/apache/dubbo</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba/dubbo/\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba/dubbo/</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;properties&gt;\n    &lt;dubbo.version&gt;3.0.3&lt;/dubbo.version&gt;\n&lt;/properties&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;\n        &lt;artifactId&gt;dubbo&lt;/artifactId&gt;\n        &lt;version&gt;${dubbo.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;\n        &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;\n        &lt;version&gt;${dubbo.version}&lt;/version&gt;\n        &lt;type&gt;pom&lt;/type&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<h2 id=\"4-rocketmq\">4. Rocketmq</h2>\n<p>Apache RocketMQ是一个分布式消息和流媒体平台，具有低延迟、高性能和可靠性、万亿级容量和灵活的可扩展性。</p>\n<p>它提供了多种功能：</p>\n<ul>\n<li>消息传递模式，包括发布/订阅、请求/回复和流媒体</li>\n<li>金融级交易消息</li>\n<li>基于DLedger的内置容错和高可用配置选项</li>\n<li>多种跨语言客户端，如Java、C/C++、Python、Go</li>\n<li>可插拔传输协议，例如 TCP、SSL、AIO</li>\n<li>内置消息追踪能力，也支持opentracing</li>\n<li>多功能大数据和流媒体生态系统集成</li>\n<li>按时间或偏移量的消息追溯</li>\n<li>可靠的 FIFO 和同一队列中的严格有序消息传递</li>\n<li>高效的拉推式消费模式</li>\n<li>单个队列百万级消息累积能力</li>\n<li>多种消息传递协议，如 JMS 和 OpenMessaging</li>\n<li>灵活的分布式横向扩展部署架构</li>\n<li>闪电般的批量消息交换系统</li>\n<li>各种消息过滤机制，例如 SQL 和 Tag</li>\n<li>用于隔离测试和云隔离集群的 Docker 镜像</li>\n<li>用于配置、指标和监控的功能丰富的管理仪表板</li>\n<li>认证和授权</li>\n<li>免费的开源连接器，用于源和接收器</li>\n</ul>\n<p>rocketmq后台管理界面：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/apache/rocketmq\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/apache/rocketmq</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/org.apache.rocketmq/rocketmq-spring-boot-starter\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/org.apache.rocketmq/rocketmq-spring-boot-starter</a></p>\n</blockquote>\n<p>rocketmq包含：服务端和客户端，在我们的项目中主要关注客户端的代码即可。</p>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;\n    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;\n    &lt;version&gt;4.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"4-arthas\">4. Arthas</h2>\n<p>Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。</p>\n<p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>\n<ul>\n<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>\n<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>\n<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>\n<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li>\n<li>是否有一个全局视角来查看系统的运行状况？</li>\n<li>有什么办法可以监控到JVM的实时运行状态？</li>\n<li>怎么快速定位应用的热点，生成火焰图？</li>\n<li>怎样直接从JVM内查找某个类的实例？</li>\n</ul>\n<p>分析代码消耗时间：<br />\n<img alt=\"\" class=\"lazyload\" /><br />\nArthas支持JDK 6+，能够运行在多种操作系统上，比如：Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。</p>\n<blockquote>\n<p>github地址: <a href=\"https://alibaba.github.io/arthas/\" rel=\"noopener nofollow\" target=\"_blank\">https://alibaba.github.io/arthas/</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.taobao.arthas/arthas-spring-boot-starter\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.taobao.arthas/arthas-spring-boot-starter</a></p>\n</blockquote>\n<p>在目标机器执行如下命令即可启动arthas：</p>\n<pre><code class=\"language-java\">curl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n</code></pre>\n<h2 id=\"5-nacos\">5. Nacos</h2>\n<p>Nacos是一个易于使用的平台，专为动态服务发现和配置以及服务管理而设计。它可以帮助您轻松构建云原生应用程序和微服务平台。</p>\n<p>服务是Nacos的一等公民。Nacos 支持几乎所有类型的服务，例如Dubbo/gRPC 服务、Spring Cloud RESTFul 服务或Kubernetes 服务。</p>\n<p>Nacos 提供了四大功能。</p>\n<ul>\n<li><code>服务发现和服务健康检查</code>。Nacos 使服务通过 DNS 或 HTTP 接口注册自己和发现其他服务变得简单。Nacos 还提供服务的实时健康检查，以防止向不健康的主机或服务实例发送请求。</li>\n<li><code>动态配置管理</code>。动态配置服务允许您在所有环境中以集中和动态的方式管理所有服务的配置。Nacos 无需在更新配置时重新部署应用程序和服务，这使得配置更改更加高效和敏捷。</li>\n<li><code>动态 DNS 服务</code>。Nacos 支持加权路由，让您更容易在数据中心内的生产环境中实现中层负载均衡、灵活的路由策略、流量控制和简单的 DNS 解析服务。它可以帮助您轻松实现基于 DNS 的服务发现，并防止应用程序耦合到特定于供应商的服务发现 API。</li>\n<li><code>服务和元数据管理</code>。Nacos 提供了一个易于使用的服务仪表板，帮助您管理您的服务元数据、配置、kubernetes DNS、服务健康和指标统计。</li>\n</ul>\n<p>Nacos 地图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>Nacos 生态图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/nacos\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/nacos</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-discovery\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-discovery</a></p>\n</blockquote>\n<h2 id=\"6-easyexcel\">6. easyexcel</h2>\n<p>Java解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。</p>\n<p>easyexcel重写了poi对07版Excel的解析，一个3M的excel用POI sax解析依然需要100M左右内存，改用easyexcel可以降低到几M，并且再大的excel也不会出现内存溢出；03版依赖POI的sax模式，在上层做了模型转换的封装，让使用者更加简单方便。</p>\n<p>64M内存1分钟内读取75M(46W行25列)的Excel</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/easyexcel\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/easyexcel</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba/easyexcel\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba/easyexcel</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;\n    &lt;version&gt;2.2.6&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"7-sentinel\">7. Sentinel</h2>\n<p>随着分布式系统变得越来越流行，服务之间的可靠性变得比以往任何时候都更加重要。</p>\n<p>Sentinel以“流量”为切入点，在流量控制、 流量整形、熔断、系统自适应保护等多个领域开展工作，保障微服务的可靠性和弹性。</p>\n<p>Sentinel具有以下特点：</p>\n<ul>\n<li><code>丰富的适用场景</code>：Sentinel在阿里巴巴得到了广泛的应用，几乎覆盖了近10年双11（11.11）购物节的所有核心场景，比如需要限制突发流量的“秒杀”满足系统容量、消息削峰填谷、下游不可靠业务断路、集群流量控制等。</li>\n<li><code>实时监控</code>：Sentinel 还提供实时监控能力。可以实时查看单台机器的运行时信息，以及500个节点以下集群的运行时信息汇总。</li>\n<li><code>广泛的开源生态系统</code>：Sentinel 提供与 Spring Cloud、Dubbo 和 gRPC 等常用框架和库的开箱即用集成。您只需将适配器依赖项添加到您的服务即可轻松使用 Sentinel。</li>\n<li><code>多语言支持</code>：Sentinel 为 Java、Go和C++提供了本机支持。</li>\n<li><code>丰富的SPI扩展</code>：Sentinel提供简单易用的SPI扩展接口，可以让您快速自定义逻辑，例如自定义规则管理、适配数据源等。</li>\n</ul>\n<p>功能概述：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>生态系统景观：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/Sentinel\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/Sentinel</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba.csp/sentinel-core\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba.csp/sentinel-core</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;\n    &lt;artifactId&gt;sentinel-core&lt;/artifactId&gt;\n    &lt;version&gt;1.8.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"8-otter\">8. otter</h2>\n<p>阿里巴巴B2B公司，因为业务的特性，卖家主要集中在国内，买家主要集中在国外，所以衍生出了杭州和美国异地机房的需求，同时为了提升用户体验，整个机房的架构为双A，两边均可写，由此诞生了otter这样一个产品。</p>\n<p>otter第一版本可追溯到04~05年，此次外部开源的版本为第4版，开发时间从2011年7月份一直持续到现在，目前阿里巴巴B2B内部的本地/异地机房的同步需求基本全上了otte4。</p>\n<p>目前同步规模：</p>\n<ul>\n<li>同步数据量6亿</li>\n<li>文件同步1.5TB(2000w张图片)</li>\n<li>涉及200+个数据库实例之间的同步</li>\n<li>80+台机器的集群规模</li>\n</ul>\n<p>otter能解决什么？</p>\n<ul>\n<li>\n<p><code>异构库同步</code>。 mysql -&gt; mysql/oracle. (目前开源版本只支持mysql增量，目标库可以是mysql或者oracle，取决于canal的功能)</p>\n</li>\n<li>\n<p><code>单机房同步</code> (数据库之间RTT &lt; 1ms)</p>\n<p>a. 数据库版本升级</p>\n<p>b. 数据表迁移</p>\n<p>c. 异步二级索引</p>\n</li>\n<li>\n<p><code>异地机房同步</code> (比如阿里巴巴国际站就是杭州和美国机房的数据库同步，RTT &gt; 200ms，亮点)</p>\n<p>a. 机房容灾</p>\n</li>\n<li>\n<p><code>双向同步</code></p>\n<p>a. 避免回环算法 (通用的解决方案，支持大部分关系型数据库)</p>\n<p>b. 数据一致性算法 (保证双A机房模式下，数据保证最终一致性，亮点)</p>\n</li>\n<li>\n<p><code>文件同步</code><br />\n站点镜像 (进行数据复制的同时，复制关联的图片，比如复制产品数据，同时复制产品图片).</p>\n</li>\n</ul>\n<p>工作原理图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>单机房复制示意图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>异地机房复制示意图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/otter\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/otter</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba.otter/canal.client\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba.otter/canal.client</a></p>\n</blockquote>\n<h2 id=\"9-p3c\">9. P3C</h2>\n<p>P3C插件呈现了阿里巴巴 Java 编码指南，它整合了阿里巴巴集团技术团队多年来的最佳编程实践。由于我们鼓励重用和更好地理解彼此的程序，因此大量 Java 编程团队对跨项目的代码质量提出了苛刻的要求。</p>\n<p>阿里巴巴过去见过很多编程问题。例如，有缺陷的数据库表结构和索引设计可能会导致软件架构缺陷和性能风险。另一个例子是混乱的代码结构难以维护。此外，未经身份验证的易受攻击的代码容易受到黑客的攻击。为了解决这些问题，我们为阿里巴巴的Java开发人员编写了这份文档。</p>\n<p>更多信息请参考阿里巴巴Java编码指南：</p>\n<ul>\n<li>中文版：阿里巴巴Java开发手册</li>\n<li>英文版：Alibaba Java Coding Guidelines</li>\n</ul>\n<p>该项目由3部分组成：</p>\n<ul>\n<li>PMD 实现</li>\n<li>IntelliJ IDEA 插件</li>\n<li>Eclipse 插件</li>\n</ul>\n<p>四十九条规则是基于PMD实现的，更多详细信息请参考P3C-PMD文档。IDE 插件（IDEA 和 Eclipse）中实现的四个规则如下：</p>\n<ul>\n<li>\n<p>[Mandatory]禁止使用已弃用的类或方法。<br />\n注意：例如，应该使用 decode(String source, String encode) 而不是不推荐使用的方法 decode(String encodeStr)。一旦接口被弃用，接口提供者就有义务提供一个新的接口。同时，客户端程序员有义务检查它的新实现是什么。</p>\n</li>\n<li>\n<p>[Mandatory]来自接口或抽象类的重写方法必须用 @Override 注释标记。反例：对于 getObject() 和 get0bject()，第一个是字母“O”，第二个是数字“0”。为了准确判断覆盖是否成功，需要一个@Override注解。同时，一旦抽象类中的方法签名发生变化，实现类将立即报告编译时错误。</p>\n</li>\n<li>\n<p>[Mandatory] 静态字段或方法应直接通过其类名而不是其对应的对象名来引用。</p>\n</li>\n<li>\n<p>[Mandatory] hashCode 和 equals 的用法应该遵循：</p>\n</li>\n</ul>\n<ol>\n<li>如果 equals 被覆盖，则覆盖 hashCode。</li>\n<li>这两个方法必须为 Set 重写，因为它们用于确保不会在 Set 中插入重复的对象。</li>\n<li>如果使用自定义对象作为 Map 的键，则必须覆盖这两个方法。注意：String 可以用作 Map 的键，因为这两个方法已经被重写。</li>\n</ol>\n<p>使用p3c插件的效果：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>最新版阿里巴巴Java开发手册下载地址：<br />\n<a href=\"https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/p3c/blob/master/Java开发手册（嵩山版）.pdf</a></p>\n<blockquote>\n<p>github地址:<a href=\"https://github.com/alibaba/p3c/tree/master/idea-plugin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/p3c/tree/master/idea-plugin</a></p>\n</blockquote>\n<h2 id=\"10-spring-cloud-alibaba\">10. Spring Cloud Alibaba</h2>\n<p>Spring Cloud Alibaba 为分布式应用开发提供一站式解决方案。它包含开发分布式应用程序所需的所有组件，使您可以轻松地使用 Spring Cloud 开发应用程序。</p>\n<p>使用Spring Cloud Alibaba，您只需添加一些注解和少量配置，即可将Spring Cloud应用连接到阿里巴巴的分布式解决方案，并通过阿里巴巴中间件构建分布式应用系统。</p>\n<p>主要功能如下：</p>\n<ul>\n<li><code>流量控制和服务降级</code>：默认支持 HTTP 服务的流量控制。您还可以使用注释自定义流量控制和服务降级规则。规则可以动态更改。</li>\n<li><code>服务注册和发现</code>：可以注册服务，客户端可以使用 Spring 管理的 bean，自动集成 Ribbon 来发现实例。</li>\n<li><code>分布式配置</code>：支持分布式系统中的外化配置，配置变化时自动刷新。</li>\n<li><code>事件驱动</code>：支持构建与共享消息系统连接的高度可扩展的事件驱动微服务。</li>\n<li><code>分布式事务</code>：支持高性能、易用的分布式事务解决方案。</li>\n<li><code>阿里云对象存储</code>：海量、安全、低成本、高可靠的云存储服务。支持随时随地在任何应用程序中存储和访问任何类型的数据。</li>\n<li><code>阿里云SchedulerX</code>：精准、高可靠、高可用的定时作业调度服务，响应时间秒级。</li>\n<li><code>阿里云短信</code>：覆盖全球的短信服务，阿里短信提供便捷、高效、智能的通讯能力，帮助企业快速联系客户。</li>\n</ul>\n<p>主要包含如下组件：</p>\n<ul>\n<li><code>Sentinel</code>：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li>\n<li><code>Nacos</code>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li>\n<li><code>RocketMQ</code>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li>\n<li><code>Dubbo</code>：Apache Dubbo™ 是一款高性能 Java RPC 框架。</li>\n<li><code>Seata</code>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li>\n<li><code>Alibaba Cloud OSS</code>: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>\n<li><code>Alibaba Cloud SchedulerX</code>: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li>\n<li><code>Alibaba Cloud SMS</code>: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>\n</ul>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/spring-cloud-alibaba\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/spring-cloud-alibaba</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n</code></pre>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n<p>更多项目实战在我的技术网站：<a href=\"http://www.susan.net.cn/project\" rel=\"noopener nofollow\" target=\"_blank\">http://www.susan.net.cn/project</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 14:35</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2026 年 PHP 的三大优势 这门\"老将\"为何依然重要",
      "link": "https://www.cnblogs.com/catchadmin/p/19454737",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19454737\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 08:16\">\n    <span>2026 年 PHP 的三大优势 这门\"老将\"为何依然重要</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"2026-年-php-的三大优势-这门老将为何依然重要\">2026 年 PHP 的三大优势 这门\"老将\"为何依然重要</h1>\n<p>PHP \"快死了\"这句话喊了这么多年，如果真有来世，它的简历应该已经相当可观了。</p>\n<p>你大概见过这些论调：\"PHP 过时了\"、\"现在没人用 PHP 做正经系统了\"、\"只有老项目还在用\"。这些说法也不算全错——确实有大量遗留 PHP 代码在运行。但还有另一个现实很少被提及：PHP 仍然在驱动大量生产环境的后端系统，新的 PHP 项目也在不断出现，因为团队想要的东西和五年、十年前一样：</p>\n<ul>\n<li>可预测的部署流程</li>\n<li>快速迭代</li>\n<li>成熟的生态</li>\n<li>能够经受多人协作、多年维护的可读代码</li>\n</ul>\n<p>我喜欢这类问题，因为它逼你把话说清楚。不是\"我喜欢用\"，不是\"它很流行\"，而是你在生产代码中能实际指出的工程优势。</p>\n<p>下面是我的回答，写给两类读者：</p>\n<ul>\n<li><strong>如果你刚接触后端开发</strong>：你会得到一个清晰的心智模型，理解 PHP 为何仍然适合 Web 系统。</li>\n<li><strong>如果你经验丰富</strong>：你会看到现代 PHP 实践（类型、静态分析、清晰边界、务实的 API 模式）如何把\"PHP 容易上手\"变成\"PHP 可靠\"。</li>\n</ul>\n<p>我会尽量用平实的语言，但不会回避技术细节。真实的系统本来就是技术性的。目标是让这些技术内容变得易懂且实用。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/php-3-biggest-strengths-2026\" rel=\"noopener nofollow\" target=\"_blank\">原文 2026 年 PHP 的三大优势 这门\"老将\"为何依然重要</a></p>\n<h2 id=\"什么是优势在真实后端工作中的定义\">什么是\"优势\"：在真实后端工作中的定义</h2>\n<p>开发者比较语言时，讨论经常跑偏到性能基准、语法偏好或者互联网文化。但当你在构建 API 或 Web 后端时，\"优势\"通常意味着一些更无聊——也更重要的东西：</p>\n<ul>\n<li>能否快速交付功能而不埋下维护陷阱？</li>\n<li>能否集成数据库、队列和第三方 API 而不从头造轮子？</li>\n<li>能否处理混乱的数据和边缘情况而不把代码变成鬼屋？</li>\n</ul>\n<p>这就是 PHP 最擅长的领域。不是因为它最优雅，而是因为它的形状刚好契合大多数 Web 后端。</p>\n<p>带着这个思路，来看 PHP 在 2026 年的三大优势。</p>\n<h2 id=\"优势一web-原生的生产力php-天然契合-http-世界\">优势一：Web 原生的生产力（PHP 天然契合 HTTP 世界）</h2>\n<p>大多数后端都是 HTTP 机器。这不是比喻，而是日常工作：</p>\n<ul>\n<li>请求进来</li>\n<li>校验并规范化</li>\n<li>调用服务 / 数据库 / 外部 API</li>\n<li>返回 JSON</li>\n<li>记录日志和追踪</li>\n<li>循环</li>\n</ul>\n<p>PHP 的第一个优势是它在这个循环里感觉很自然。你不需要在处理请求之前\"搭建世界\"。PHP 的默认模型就是面向 Web 的，这一点往往被低估了。</p>\n<h3 id=\"经典的-php-执行模型为何仍然有用\">经典的 PHP 执行模型为何仍然有用</h3>\n<p>PHP 传统的请求生命周期很简单：</p>\n<ol>\n<li>开始请求</li>\n<li>运行代码</li>\n<li>返回响应</li>\n<li>结束请求</li>\n</ol>\n<p>然后下一个请求从头开始。</p>\n<p>有人把这当成相对于长驻服务器的劣势，但在实践中它往往是优势：</p>\n<ul>\n<li>内存泄漏不会那么致命，因为进程会回收。</li>\n<li>每个请求天然隔离。</li>\n<li>不太可能意外依赖内存状态。</li>\n<li>调试往往更简单，因为每个请求有清晰的边界。</li>\n</ul>\n<p>你也可以用长驻模式跑 PHP（RoadRunner、Swoole 等），它们在特定场景下确实很好。但经典模型对许多 API 仍然是可靠的默认选择，因为它稳定且对运维友好。</p>\n<h3 id=\"一个纯-php的-api-入口展示基本形态\">一个\"纯 PHP\"的 API 入口（展示基本形态）</h3>\n<p>即使你在生产环境使用 Laravel 或 Symfony（大多数正经应用确实该用），看看 PHP 为何在 Web 工作中高效还是有帮助的。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\nrequire __DIR__ . '/../vendor/autoload.php';\nheader('Content-Type: application/json; charset=utf-8');\n$method = $_SERVER['REQUEST_METHOD'] ?? 'GET';\n$path = parse_url($_SERVER['REQUEST_URI'] ?? '/', PHP_URL_PATH) ?: '/';\nfunction jsonResponse(array $payload, int $status = 200): void {\n    http_response_code($status);\n    echo json_encode($payload, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);\n    exit;\n}\nfunction readJsonBody(): array {\n    $raw = file_get_contents('php://input') ?: '';\n    $data = json_decode($raw, true);\n    return is_array($data) ? $data : [];\n}\nif ($method === 'GET' &amp;&amp; $path === '/health') {\n    jsonResponse(['ok' =&gt; true, 'time' =&gt; date(DATE_ATOM)]);\n}\nif ($method === 'POST' &amp;&amp; $path === '/users') {\n    $body = readJsonBody();\n    $email = strtolower(trim((string)($body['email'] ?? '')));\n    $name  = trim((string)($body['name'] ?? ''));\n    if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {\n        jsonResponse(['error' =&gt; 'Invalid email'], 422);\n    }\n    if ($name === '') {\n        jsonResponse(['error' =&gt; 'Name is required'], 422);\n    }\n    $id = random_int(1000, 9999);\n    jsonResponse(['id' =&gt; $id, 'email' =&gt; $email, 'name' =&gt; $name], 201);\n}\njsonResponse(['error' =&gt; 'Not found'], 404);\n</code></pre>\n<p>这不是\"最佳实践架构\"，但它演示了核心思想：PHP 的 Web 循环直接且易懂。这就是基础的生产力优势。</p>\n<h3 id=\"快与乱的区别薄-handler真服务\">\"快\"与\"乱\"的区别：薄 handler，真服务</h3>\n<p>PHP 的 Web 生产力要成为长期优势，前提是保持边界清晰。最容易失去这个优势的方式就是把所有东西都塞进控制器。</p>\n<p>一个可扩展的模式：</p>\n<ul>\n<li><strong>Handler / 控制器</strong>：解码请求、调用服务、编码响应</li>\n<li><strong>服务</strong>：业务逻辑 + 编排</li>\n<li><strong>Repository / Client</strong>：存储 + 外部 API 调用</li>\n</ul>\n<p>这是一个与框架无关的小例子：</p>\n<pre><code class=\"language-php\">final class CreateUserHandler\n{\n    public function __construct(\n        private readonly UserService $service\n    ) {}\n    public function __invoke(array $body): array\n    {\n        $input = CreateUserInput::fromArray($body);\n        $user  = $this-&gt;service-&gt;create($input);\n        return UserResource::toArray($user);\n    }\n}\n</code></pre>\n<p>Handler 读起来像一段叙述。这就对了。</p>\n<p>现在服务来做真正的决策：</p>\n<pre><code class=\"language-php\">final class UserService\n{\n    public function __construct(\n        private readonly UserRepository $users\n    ) {}\n    public function create(CreateUserInput $input): User\n    {\n        if ($this-&gt;users-&gt;existsByEmail($input-&gt;email)) {\n            throw new DomainException('Email already registered');\n        }\n        $user = User::register($input-&gt;email, $input-&gt;name);\n        $this-&gt;users-&gt;save($user);\n        return $user;\n    }\n}\n</code></pre>\n<p>这个结构并不花哨，但它能防止代码库在六个月内变成意大利面。</p>\n<h3 id=\"真实世界的-api-工作超时和重试是功能的一部分\">真实世界的 API 工作：超时和重试是功能的一部分</h3>\n<p>PHP 保持实用的一个原因是，做 PHP 后端的团队往往很早就被迫面对 Web 的现实。不是因为 PHP 特殊，而是因为 Web 本身就不宽容。</p>\n<p>如果你调用外部 API 却不设超时、不设重试策略，你就是在埋下未来的事故。</p>\n<p>下面是一个用 Guzzle 写的封装，在生产环境中能正经干活：</p>\n<pre><code class=\"language-php\">use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\nfinal class ShippingClient\n{\n    private Client $http;\n    public function __construct(string $baseUrl, string $token)\n    {\n        $this-&gt;http = new Client([\n            'base_uri' =&gt; rtrim($baseUrl, '/') . '/',\n            'timeout' =&gt; 3.0,\n            'connect_timeout' =&gt; 1.0,\n            'headers' =&gt; [\n                'Authorization' =&gt; \"Bearer {$token}\",\n                'Accept' =&gt; 'application/json',\n            ],\n        ]);\n    }\n    public function createLabel(array $payload): array\n    {\n        $attempts = 0;\n        while (true) {\n            $attempts++;\n            try {\n                $resp = $this-&gt;http-&gt;post('labels', ['json' =&gt; $payload]);\n                $data = json_decode((string)$resp-&gt;getBody(), true);\n                return is_array($data) ? $data : [];\n            } catch (GuzzleException $e) {\n                if ($attempts &gt;= 3) {\n                    throw new RuntimeException('Shipping API failed after retries', 0, $e);\n                }\n                // small exponential backoff + jitter\n                usleep((int)(100_000 * $attempts) + random_int(0, 50_000));\n            }\n        }\n    }\n}\n</code></pre>\n<p>当互联网本身是你的依赖时，这种代码是必须的——而 PHP 很适应这个场景。</p>\n<p><strong>为什么这是优势一</strong>：PHP 契合 HTTP 工作的形状，让团队能快速构建功能而不用与平台对抗。</p>\n<h2 id=\"优势二生态成熟度composer--框架--标准降低风险\">优势二：生态成熟度（Composer + 框架 + 标准降低风险）</h2>\n<p>PHP 的第二个优势是杠杆。</p>\n<p>很多语言都能做 Web 开发。但能让\"无聊的部分\"以可复用的方式被解决、让团队能招到已经熟悉这些模式的人，这样的成熟生态并不多。</p>\n<p>当你选择 PHP，你选择的不只是语法，还有：</p>\n<ul>\n<li>Composer + Packagist</li>\n<li>Laravel / Symfony（以及其他框架）</li>\n<li>PSR 标准（互操作性）</li>\n<li>稳定的工具链（测试、静态分析、格式化、重构）</li>\n</ul>\n<p>生态的成熟度能降低风险。风险才是真正花钱的地方。</p>\n<h3 id=\"composer让结构化成为常态的安静基石\">Composer：让结构化成为常态的安静基石</h3>\n<p>Composer 不只是依赖管理——它推动你走向模块化的代码库，用自动加载和命名空间。</p>\n<p>一个最小的例子：</p>\n<pre><code class=\"language-json\">{\n  \"require\": {\n    \"php\": \"^8.2\",\n    \"monolog/monolog\": \"^3.0\",\n    \"guzzlehttp/guzzle\": \"^7.0\"\n  },\n  \"autoload\": {\n    \"psr-4\": {\n      \"App\\\\\": \"src/\"\n    }\n  }\n}\n</code></pre>\n<p>一旦你采用 PSR-4 自动加载，你的代码就不再是\"文件\"，而开始变成\"模块\"。这个转变是现代 PHP 比老刻板印象更易维护的重要原因。</p>\n<h3 id=\"框架用无聊的方案解决无聊的问题这正是重点\">框架：用无聊的方案解决无聊的问题（这正是重点）</h3>\n<p>框架可能被过度使用，但\"不用框架\"的做法在应用增长后往往更糟。</p>\n<p>Laravel 和 Symfony 为你不想重新发明的东西提供了可靠的默认方案：</p>\n<ul>\n<li>路由和中间件</li>\n<li>校验和请求处理</li>\n<li>DI 容器模式</li>\n<li>缓存和队列</li>\n<li>数据库迁移</li>\n<li>结构化的错误处理</li>\n</ul>\n<p>大多数生产事故不是来自精妙的业务逻辑，而是来自胶水代码：超时、重试、不一致的校验、部分失败、意外的 payload、不一致的错误响应。</p>\n<p>框架默认方案减少这些事故，因为你建立在已经经历过成千上万个生产系统考验的模式之上。</p>\n<h3 id=\"psr-标准让你的代码不再被锁死\">PSR 标准：让你的代码不再被锁死</h3>\n<p>标准在你集成库或者超出最初决策时最为重要。</p>\n<p>例如：PSR-3 日志。</p>\n<pre><code class=\"language-php\">use Psr\\Log\\LoggerInterface;\nfinal class BillingService\n{\n    public function __construct(private readonly LoggerInterface $logger) {}\n    public function charge(int $userId, int $amountCents): void\n    {\n        $this-&gt;logger-&gt;info('Charge request', [\n            'userId' =&gt; $userId,\n            'amountCents' =&gt; $amountCents,\n        ]);\n        // ...\n    }\n}\n</code></pre>\n<p>这个类不在乎你今天用 Monolog 还是明天换成别的日志库。这种解耦才能让系统演进。</p>\n<h3 id=\"工具链和-2015-年相比现代-php-像换了一门语言\">工具链：和 2015 年相比，现代 PHP 像换了一门语言</h3>\n<p>很多\"PHP 黑\"来自于对老代码库的体验：弱类型、不一致的模式、\"先上线再说\"的文化。</p>\n<p>现代 PHP 团队通常会用一套简单的质量工具链：</p>\n<ul>\n<li>严格类型</li>\n<li>静态分析（PHPStan / Psalm）</li>\n<li>测试（PHPUnit / Pest）</li>\n<li>格式化（PHP-CS-Fixer）</li>\n<li>自动重构（Rector）</li>\n</ul>\n<p>这套组合会改变你写代码的方式。目标不是完美，而是尽早暴露问题，让代码在迭代中保持可读。</p>\n<p>下面是一个小例子，静态分析帮你避免一个运行时 bug：</p>\n<pre><code class=\"language-php\">final class UserRepository\n{\n    public function findByEmail(string $email): User\n    {\n        // DB lookup...\n        return null; // bug\n    }\n}\n</code></pre>\n<p>配置好静态分析后，这会立即被标记出来。</p>\n<p>PHP 的测试也不必很重。一个聚焦的测试可以读起来像文档：</p>\n<pre><code class=\"language-php\">final class MoneyTest extends TestCase\n{\n    public function testItAddsMoneyInSameCurrency(): void\n    {\n        $a = Money::usd(1000);\n        $b = Money::usd(250);\n        $sum = $a-&gt;add($b);\n        $this-&gt;assertSame(1250, $sum-&gt;cents());\n        $this-&gt;assertSame('USD', $sum-&gt;currency());\n    }\n}\n</code></pre>\n<p><strong>为什么这是优势二</strong>：PHP 的生态让你能快速交付并安全构建，因为工具链和惯例都已成熟。</p>\n<h2 id=\"优势三务实的数据管道php-擅长乱进干净出\">优势三：务实的数据管道（PHP 擅长\"乱进、干净出\"）</h2>\n<p>如果你做过一段时间后端，你就知道真相：这份工作就是数据转换。</p>\n<p>请求进来格式奇怪。数据库行取出来格式奇怪。外部 API 返回的是\"差不多是你期望的\"。Webhook 在不方便的时候重试。边缘情况在周五发生。</p>\n<p>PHP 在这类工作上特别强，因为它在两种模式下都很自如：</p>\n<ul>\n<li>快速操作（字符串、数组、JSON）</li>\n<li>结构化代码（DTO、值对象、枚举、readonly 属性）</li>\n</ul>\n<p>为了说明我的意思，来构建一个现实的管道：处理来自支付提供商的 webhook。</p>\n<p>这是一个很好的测试，因为它结合了：</p>\n<ul>\n<li>安全验证</li>\n<li>幂等性（重试）</li>\n<li>载荷规范化</li>\n<li>状态变更</li>\n<li>优雅处理未知事件类型</li>\n</ul>\n<h3 id=\"步骤一保持载荷边界显式化dto-优于原始数组\">步骤一：保持载荷边界显式化（DTO 优于原始数组）</h3>\n<p>数组在边界处没问题，但在整个应用中传递原始数组会变得痛苦。所以：尽早解析，尽早结构化。</p>\n<pre><code class=\"language-php\">final class WebhookEvent\n{\n    public function __construct(\n        public readonly string $id,\n        public readonly string $type,\n        public readonly int $createdAtEpoch,\n        public readonly array $data\n    ) {}\n    public static function fromArray(array $payload): self\n    {\n        return new self(\n            id: (string)($payload['id'] ?? ''),\n            type: (string)($payload['type'] ?? ''),\n            createdAtEpoch: (int)($payload['created_at'] ?? 0),\n            data: is_array($payload['data'] ?? null) ? $payload['data'] : []\n        );\n    }\n}\n</code></pre>\n<p>这是务实的做法：我们依赖的字段用强类型，原始数据留着灵活性，新字段加进来也不会炸。</p>\n<h3 id=\"步骤二验证签名不要信任-json\">步骤二：验证签名（不要\"信任 JSON\"）</h3>\n<pre><code class=\"language-php\">final class WebhookSignatureVerifier\n{\n    public function __construct(private readonly string $secret) {}\n    public function verify(string $rawBody, string $signatureHeader): bool\n    {\n        $expected = hash_hmac('sha256', $rawBody, $this-&gt;secret);\n        return hash_equals($expected, $signatureHeader);\n    }\n}\n</code></pre>\n<p>这里 <code>hash_equals</code> 很重要，用于避免时序攻击。这是个小细节，但这类习惯正是区分业余代码和生产代码的地方。</p>\n<h3 id=\"步骤三幂等性因为-webhook-会重试\">步骤三：幂等性（因为 webhook 会重试）</h3>\n<p>如果你处理同一个事件两次，你可能会：</p>\n<ul>\n<li>重复更新订阅</li>\n<li>重复发送邮件</li>\n<li>重复给账户加款</li>\n</ul>\n<p>所以要存储已处理的事件 ID。</p>\n<pre><code class=\"language-php\">final class WebhookIdempotencyStore\n{\n    public function __construct(private readonly PDO $pdo) {}\n    public function hasProcessed(string $eventId): bool\n    {\n        $stmt = $this-&gt;pdo-&gt;prepare(\"SELECT 1 FROM processed_webhooks WHERE event_id = :id\");\n        $stmt-&gt;execute([':id' =&gt; $eventId]);\n        return (bool)$stmt-&gt;fetchColumn();\n    }\n    public function markProcessed(string $eventId): void\n    {\n        $stmt = $this-&gt;pdo-&gt;prepare(\n            \"INSERT INTO processed_webhooks (event_id, processed_at)\n             VALUES (:id, NOW())\"\n        );\n        $stmt-&gt;execute([':id' =&gt; $eventId]);\n    }\n}\n</code></pre>\n<h3 id=\"步骤四干净地映射事件类型枚举很有帮助\">步骤四：干净地映射事件类型（枚举很有帮助）</h3>\n<pre><code class=\"language-php\">enum PaymentEventType: string\n{\n    case PaymentSucceeded = 'payment.succeeded';\n    case PaymentFailed = 'payment.failed';\n}\n</code></pre>\n<h3 id=\"步骤五用事务型-handler-把它们组合起来\">步骤五：用事务型 handler 把它们组合起来</h3>\n<pre><code class=\"language-php\">final class PaymentWebhookHandler\n{\n    public function __construct(\n        private readonly WebhookSignatureVerifier $verifier,\n        private readonly WebhookIdempotencyStore $idem,\n        private readonly PaymentService $payments,\n        private readonly PDO $pdo\n    ) {}\n    public function handle(string $rawBody, string $signatureHeader): void\n    {\n        if (!$this-&gt;verifier-&gt;verify($rawBody, $signatureHeader)) {\n            throw new RuntimeException('Invalid webhook signature');\n        }\n        $payload = json_decode($rawBody, true);\n        if (!is_array($payload)) {\n            throw new RuntimeException('Invalid JSON');\n        }\n        $event = WebhookEvent::fromArray($payload);\n        if ($event-&gt;id === '' || $event-&gt;type === '') {\n            throw new RuntimeException('Missing event fields');\n        }\n        if ($this-&gt;idem-&gt;hasProcessed($event-&gt;id)) {\n            return; // safe no-op\n        }\n        $this-&gt;pdo-&gt;beginTransaction();\n        try {\n            $this-&gt;dispatch($event);\n            $this-&gt;idem-&gt;markProcessed($event-&gt;id);\n            $this-&gt;pdo-&gt;commit();\n        } catch (Throwable $e) {\n            $this-&gt;pdo-&gt;rollBack();\n            throw $e;\n        }\n    }\n    private function dispatch(WebhookEvent $event): void\n    {\n        $type = PaymentEventType::tryFrom($event-&gt;type);\n        if ($type === null) {\n            // unknown event type: ignore or log\n            return;\n        }\n        $paymentId = (string)($event-&gt;data['payment_id'] ?? '');\n        if ($paymentId === '') return;\n        match ($type) {\n            PaymentEventType::PaymentSucceeded =&gt; $this-&gt;payments-&gt;markSucceeded($paymentId),\n            PaymentEventType::PaymentFailed    =&gt; $this-&gt;payments-&gt;markFailed($paymentId),\n        };\n    }\n}\n</code></pre>\n<p>这是一个干净的管道：</p>\n<ol>\n<li>验证真实性</li>\n<li>解析载荷</li>\n<li>规范化为 DTO</li>\n<li>强制幂等性</li>\n<li>事务</li>\n<li>分发领域动作</li>\n<li>容忍未知事件</li>\n</ol>\n<p>这就是 PHP 擅长的\"Web 现实\"代码：处理那些真正重要的脏活，同时保持可读。</p>\n<p><strong>为什么这是优势三</strong>：大多数后端都是数据管道，而 PHP 在真实世界约束下构建可理解的管道方面很强。</p>\n<h2 id=\"额外内容游标分页的实践深入因为它把三个优势串在一起\">额外内容：游标分页的实践深入（因为它把三个优势串在一起）</h2>\n<p>分页是那种看起来简单、等用户翻到深页才暴露问题的功能。它也是个好例子，能说明 PHP 为何还没过时：它同时涉及 HTTP、SQL 性能和响应设计。</p>\n<h3 id=\"为什么-offset-会伤害你\">为什么 OFFSET 会伤害你</h3>\n<p>Offset 分页（<code>LIMIT 20 OFFSET 100000</code>）迫使数据库扫描并丢弃大量行。在大表上，深页会变慢。</p>\n<p>它在并发写入时也可能不一致：插入/删除可能导致\"窗口\"移动时出现跳过或重复。</p>\n<p>游标分页（keyset/seek）通过使用稳定的排序和代表\"你上次停在哪里\"的游标来避免这些问题。</p>\n<h3 id=\"规则一游标逻辑必须匹配排序方向\">规则一：游标逻辑必须匹配排序方向</h3>\n<p>如果你按最新优先排序：</p>\n<pre><code class=\"language-sql\">ORDER BY created_at DESC, id DESC\n</code></pre>\n<ul>\n<li>下一页应该获取\"更早\"的行</li>\n<li>所以条件用 <code>&lt;</code></li>\n</ul>\n<p>如果你的数据库支持元组比较：</p>\n<pre><code class=\"language-sql\">SELECT id, created_at, total_cents\nFROM orders\nWHERE (created_at, id) &lt; (?, ?)\nORDER BY created_at DESC, id DESC\nLIMIT ?\n</code></pre>\n<p>如果不支持，用显式逻辑：</p>\n<pre><code class=\"language-sql\">SELECT id, created_at, total_cents\nFROM orders\nWHERE created_at &lt; ?\n   OR (created_at = ? AND id &lt; ?)\nORDER BY created_at DESC, id DESC\nLIMIT ?\n</code></pre>\n<h3 id=\"规则二游标应该是不透明的且防篡改\">规则二：游标应该是不透明的且防篡改</h3>\n<p>游标通常是一个类似 <code>(created_at, id)</code> 的对，序列化给客户端。Base64 编码在传输时没问题——但不是安全措施。如果你想防止客户端伪造游标，就签名它。</p>\n<pre><code class=\"language-php\">final class Cursor\n{\n    public function __construct(\n        public readonly string $createdAtIso,\n        public readonly int $id\n    ) {}\n}\nfinal class CursorCodec\n{\n    public function __construct(private readonly string $secret) {}\n    public function encode(Cursor $cursor): string\n    {\n        $json = json_encode([\n            'created_at' =&gt; $cursor-&gt;createdAtIso,\n            'id' =&gt; $cursor-&gt;id\n        ], JSON_UNESCAPED_SLASHES);\n        $b64 = rtrim(strtr(base64_encode($json), '+/', '-_'), '=');\n        $sig = hash_hmac('sha256', $b64, $this-&gt;secret);\n        return $b64 . '.' . $sig;\n    }\n    public function decode(string $token): Cursor\n    {\n        $parts = explode('.', $token, 2);\n        if (count($parts) !== 2) {\n            throw new InvalidArgumentException('Invalid cursor');\n        }\n        [$b64, $sig] = $parts;\n        $expected = hash_hmac('sha256', $b64, $this-&gt;secret);\n        if (!hash_equals($expected, $sig)) {\n            throw new InvalidArgumentException('Cursor signature mismatch');\n        }\n        $json = base64_decode(strtr($b64, '-_', '+/'), true);\n        if ($json === false) {\n            throw new InvalidArgumentException('Invalid cursor encoding');\n        }\n        $data = json_decode($json, true);\n        if (!is_array($data)) {\n            throw new InvalidArgumentException('Invalid cursor payload');\n        }\n        return new Cursor(\n            createdAtIso: (string)($data['created_at'] ?? ''),\n            id: (int)($data['id'] ?? 0)\n        );\n    }\n}\n</code></pre>\n<h3 id=\"repository-方法返回条目--下一个游标\">Repository 方法：返回条目 + 下一个游标</h3>\n<pre><code class=\"language-php\">final class OrderRepository\n{\n    public function __construct(private readonly PDO $pdo) {}\n    /**\n     * @return array{items: list&lt;array&gt;, next: ?Cursor}\n     */\n    public function listPage(?Cursor $after, int $limit): array\n    {\n        $limit = max(1, min($limit, 100));\n        if ($after === null) {\n            $sql = \"SELECT id, created_at, total_cents\n                    FROM orders\n                    ORDER BY created_at DESC, id DESC\n                    LIMIT :limit\";\n            $stmt = $this-&gt;pdo-&gt;prepare($sql);\n            $stmt-&gt;bindValue(':limit', $limit, PDO::PARAM_INT);\n        } else {\n            $sql = \"SELECT id, created_at, total_cents\n                    FROM orders\n                    WHERE created_at &lt; :created_at\n                       OR (created_at = :created_at AND id &lt; :id)\n                    ORDER BY created_at DESC, id DESC\n                    LIMIT :limit\";\n            $stmt = $this-&gt;pdo-&gt;prepare($sql);\n            $stmt-&gt;bindValue(':created_at', $after-&gt;createdAtIso);\n            $stmt-&gt;bindValue(':id', $after-&gt;id, PDO::PARAM_INT);\n            $stmt-&gt;bindValue(':limit', $limit, PDO::PARAM_INT);\n        }\n        $stmt-&gt;execute();\n        $rows = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);\n        $items = array_map(fn($r) =&gt; [\n            'id' =&gt; (int)$r['id'],\n            'created_at' =&gt; (string)$r['created_at'],\n            'total_cents' =&gt; (int)$r['total_cents'],\n        ], $rows);\n        $next = null;\n        if ($items !== []) {\n            $last = $items[count($items) - 1];\n            $next = new Cursor($last['created_at'], $last['id']);\n        }\n        return ['items' =&gt; $items, 'next' =&gt; $next];\n    }\n}\n</code></pre>\n<p>现在你的 handler 可以解码 <code>after</code>、获取结果、编码 <code>next_cursor</code>——一个横跨 HTTP + SQL + JSON 响应的干净端到端管道。</p>\n<p>这就是实践中的最佳平衡点：PHP 的 Web 原生特性、生态工具和数据处理能力在这里汇合。</p>\n<h2 id=\"php-不是最佳默认选择的场景以及好团队怎么做\">PHP 不是最佳默认选择的场景（以及好团队怎么做）</h2>\n<p>PHP 不是万能的最佳工具：</p>\n<ul>\n<li>CPU 密集型工作负载（视频处理、大规模数值计算）</li>\n<li>将极高并发的 socket 服务器作为默认架构</li>\n<li>要求前后端用同一门语言共享严格类型的组织</li>\n</ul>\n<p>但大多数成功的团队不会把这当成重写一切的理由。他们做的是 Web 一直鼓励的事：组合系统。</p>\n<ul>\n<li>在 PHP 强的地方保留 API 表面。</li>\n<li>把重计算卸载给 worker 或专门的服务。</li>\n<li>用队列处理后台任务。</li>\n<li>在怪罪语言之前先优化数据库查询和缓存。</li>\n</ul>\n<p>这不是什么\"PHP 用户的自我安慰\"，这就是正常的系统设计。</p>\n<h2 id=\"结论\">结论</h2>\n<p>回到最初的问题——PHP 的三大优势：</p>\n<ul>\n<li><strong>Web 原生的生产力</strong>：PHP 天然契合 HTTP 工作，保持构建循环快速。</li>\n<li><strong>生态成熟度</strong>：Composer + 框架 + 标准 + 工具链给你杠杆并降低风险。</li>\n<li><strong>务实的数据管道</strong>：PHP 擅长把混乱的真实世界数据转换成干净、稳定的输出——同时不让代码变得不可读。</li>\n</ul>\n<p>如果你想让 PHP 感觉现代（而不是像那些刻板印象），方法始终如一：</p>\n<ul>\n<li>保持 handler/控制器薄</li>\n<li>用 DTO/值对象建模边界</li>\n<li>把超时、重试和幂等性当作一等功能</li>\n<li>按读取方式建索引（尤其是分页）</li>\n<li>用测试 + 静态分析保护重构</li>\n</ul>\n<p>PHP 不需要追热点。它只要继续做它擅长的事就够了：跑那些实用、好维护、能稳定上线的 Web 系统。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 08:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">339</span>)&nbsp;\n评论(<span id=\"post_comment_count\">5</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一文学习和实践 当下互联网安全的基石  -  TLS 和 SSL",
      "link": "https://www.cnblogs.com/dddy/p/19453911",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/dddy/p/19453911\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 21:18\">\n    <span>一文学习和实践 当下互联网安全的基石  -  TLS 和 SSL</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>[[N_OSI 模型.TCP 协议.封包]]<br />\n[[Java TLS Socket]]</p>\n<h1 id=\"what-is-ssltls-\">What is SSL/TLS ?</h1>\n<p>TLS（Transport Layer Security）即传输层安全协议，SSL（Secure Sockets Layer）即安全套接层协议。它们都是用于在网络通信中保障数据安全和隐私的加密协议。</p>\n<p>[[TLS&amp;SSL协议]]</p>\n<h2 id=\"tlstransport-layer-security传输层安全协议\">TLS（Transport Layer Security）传输层安全协议</h2>\n<ol>\n<li><strong>发展历程</strong></li>\n</ol>\n<ul>\n<li>TLS 是 SSL 协议的继任者。由于 SSL 协议存在一些安全漏洞，并且随着网络安全需求的不断提高，IETF（Internet Engineering Task Force）对 SSL 3.0 进行了改进，推出了 TLS 1.0 协议，于 1999 年发布。TLS 协议在后续又不断更新版本，如 TLS 1.1、TLS 1.2 和 TLS 1.3，每一个新版本都在安全性和性能等方面有所提升。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<ul>\n<li>TLS 的工作原理与 SSL 类似，也包括握手阶段。在 TLS 握手过程中，客户端和服务器会协商协议版本、加密算法套件、交换密钥等。TLS 1.3 相比之前的版本，简化了握手过程，减少了握手消息的往返次数，从而提高了连接建立的速度，并且增强了安全性，如加强了密钥交换的安全性。</li>\n<li>例如，TLS 1.3 使用了更安全的密钥交换算法，如基于椭圆曲线的 Diffie - Hellman 密钥交换（ECDHE），这种算法能够有效抵抗中间人攻击等安全威胁。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>应用场景</strong></li>\n</ol>\n<ul>\n<li>TLS 的应用范围非常广泛。它不仅用于 Web 安全，还用于电子邮件安全（如 IMAP、POP3 和 SMTP 协议的安全版本）、虚拟专用网络（VPN）等众多网络通信场景。在现代互联网中，几乎所有需要安全通信的地方都会优先考虑使用 TLS 协议。</li>\n</ul>\n<h2 id=\"ssl-secure-sockets-layer安全套接层协议\">SSL （Secure Sockets Layer）安全套接层协议</h2>\n<ol>\n<li><strong>发展历程</strong></li>\n</ol>\n<ul>\n<li>SSL 最初是由网景公司（Netscape）在 1994 年开发的，目的是为了保障网络通信的安全，特别是在 Web 浏览器和服务器之间的通信安全。SSL 1.0 由于存在安全漏洞从未发布，SSL 2.0 在 1995 年发布，但也有安全问题。SSL 3.0 于 1996 年发布，它修复了许多 SSL 2.0 的问题，成为当时比较流行的安全协议。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<ul>\n<li>SSL 协议在应用层和传输层之间工作。它通过使用公钥和私钥加密技术来保证通信的保密性。当客户端（如浏览器）与服务器建立连接时，首先会进行 SSL 握手过程。</li>\n<li>在握手阶段，客户端向服务器发送客户端支持的加密算法列表等信息。服务器从列表中选择一种加密算法，并将服务器的证书发送给客户端。客户端验证服务器证书的合法性，例如检查证书是否由可信任的证书颁发机构（CA）颁发，证书是否过期等。</li>\n<li>如果证书验证通过，客户端和服务器就会协商出一个对称加密密钥。之后的数据传输就使用这个对称密钥进行加密，这样可以保证数据在传输过程中的保密性，因为只有客户端和服务器知道这个对称密钥。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>应用场景</strong></li>\n</ol>\n<ul>\n<li>SSL 主要应用于 Web 安全。例如，在早期的 https（Hypertext Transfer Protocol Secure）网站访问中，就是通过 SSL 协议来加密浏览器和服务器之间的数据传输。这使得用户在网站上输入的敏感信息，如登录密码、信用卡信息等在传输过程中不会被窃取。</li>\n</ul>\n<h2 id=\"两者关系和区别\">两者关系和区别</h2>\n<ol>\n<li><strong>关系</strong></li>\n</ol>\n<ul>\n<li>TLS 可以看作是 SSL 的升级版。TLS 协议在设计上借鉴了 SSL 协议的很多理念，并且在 SSL 的基础上进行了改进和扩展，以应对不断出现的新的安全威胁和网络通信需求。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>区别</strong></li>\n</ol>\n<ul>\n<li><strong>安全性</strong>：TLS 在安全性能上比 SSL 更优越。例如，SSL 3.0 存在 POODLE（Padding Oracle On Downgraded Legacy Encryption）攻击漏洞，而 TLS 协议通过不断更新版本来修复类似的安全漏洞。TLS 1.3 更是在密钥交换等关键环节采用了更先进的加密技术，提供了更强的安全性。</li>\n<li><strong>兼容性</strong>：SSL 是比较早期的协议，在一些旧的系统和软件中有应用。但随着网络安全标准的提高，现代的应用和系统更倾向于使用 TLS 协议。TLS 在兼容性方面也在不断扩展，能够更好地与各种新的网络技术和应用场景相结合。</li>\n</ul>\n<blockquote>\n<p>目前常用的是 TLS 1.2 和 TLS 1.3;  SSL不多见了</p>\n</blockquote>\n<h2 id=\"https-工作流程\">HTTPS 工作流程</h2>\n<ol>\n<li>Client 发起请求（端口443）</li>\n<li>Server 返回公钥证书</li>\n<li>Client 验证证书</li>\n<li>Client 生成对称密钥，用公钥加密后发给Server</li>\n<li>Server使用私钥解密，得到对称密钥</li>\n<li>C/S双方使用对称密钥：\n<ul>\n<li>加密明文并发送</li>\n<li>解密密文得到明文</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"for-tls-12\">For TLS 1.2</h3>\n<p><img alt=\"Pasted image 20241218204449\" class=\"lazyload\" /><br />\n<img alt=\"Pasted image 20241218211322\" class=\"lazyload\" /></p>\n<h3 id=\"for-tls-13\">For TLS 1.3</h3>\n<p><img alt=\"Pasted image 20241218204507\" class=\"lazyload\" /></p>\n<p><img alt=\"Pasted image 20241218203919\" class=\"lazyload\" /></p>\n<h1 id=\"tls\">TLS</h1>\n<p><img alt=\"Pasted image 20231116112623\" class=\"lazyload\" /></p>\n<h2 id=\"证书签名与验证\">证书签名与验证</h2>\n<p>颁发证书的过程</p>\n<ol>\n<li>撰写<strong>证书元数据</strong>: 包括 <code>签发人(Issuer)</code>, 地址, 签发时间, 有效期 等, 还包括<code>证书持有者(Owner)</code>基本信息, 比如 DN(DNS Name, 即证书生效的域名), <strong>Owner 公钥</strong> 等信息</li>\n<li>使用通用的 Hash 算法（如SHA-256）对证书元数据计算生成<strong>数字摘要</strong></li>\n<li>使用 <strong>签发人 Issuer (CA)的私钥</strong>  对该<strong>数字摘要</strong>进行加密, 生成一个<strong>加密的数字摘要</strong>, 也就是<strong>Issuer的数字签名</strong></li>\n<li>将<strong>数字签名</strong>附加到数字证书上, 变成一个<strong>签过名的数字证书</strong><br />\n将<strong>签过名的数字证书</strong>与 <strong>Issuer (CA)的公钥</strong>, 一同发给证书使用者（注意, 将公钥主动发给使用者是一个形象的说法, 通常系统或者浏览器都内置 Issuer (CA)的公钥 为可信任的根证书）</li>\n</ol>\n<blockquote>\n<p>所以 CA的私钥是绝对不能被泄露, 它作为互联网被信任的基础</p>\n</blockquote>\n<h2 id=\"验证证书的过程\">验证证书的过程</h2>\n<ol>\n<li>证书使用者获通过某种途径（如浏览器访问）获取到该数字证书, 解压后分别获得<strong>证书元数据</strong> 和<strong>数字签名</strong>,<strong>(Owner)的公钥</strong>等</li>\n<li>使用同样的Hash算法计算证书元数据的<strong>数字摘要</strong></li>\n<li>使用 <strong>签发人 Issuer (CA)的公钥</strong> 对数字签名进行解密, 得到 解密后的数字摘要</li>\n</ol>\n<p>从第1步获得的数字摘要值,  再对比 2 和 3 两个步骤得到的数字摘要值; 如果相同, 则说明这个数字证书确实是被 签发人Issuer 验证过合法证书, 证书中的信息</p>\n<blockquote>\n<p>最主要的是确定 Owner 的公钥是可信的, 此后通信 信任使用该公钥解密对方私钥加密的数据</p>\n</blockquote>\n<p><strong>in short 握手时服务端需要提供自己的公钥 和被 ca签发过的数字摘要;  关键在与客户端需要一个可信任 Issuer(CA)</strong></p>\n<h3 id=\"证书链\">证书链</h3>\n<p>在 chrome 证书信息-&gt; 证书路径,  可以看到证书的签发链.</p>\n<p>例, 百度的网站:</p>\n<p><code>GlobalSign Root CA -&gt; GlobalSign Organization Validation CA -&gt; baidu.com</code><br />\n<img alt=\"Pasted image 20231116113047\" class=\"lazyload\" /></p>\n<p>这个路径可以抽象为三个级别:</p>\n<p><code>end-user</code>: 即 baidu.com, 该证书包含百度的公钥, 访问者就是使用该公钥将数据加密后再传输给百度, 即在 HTTPS 中使用的证书</p>\n<p><code>intermediates</code>: 即上文提到的 签发人 Issuer, 用来认证公钥持有者身份的证书, 负责确认 HTTPS 使用的 end-user 证书确实是来源于百度; 这类 intermediates 证书可以有很多级, 也就是说 签发人 Issuer 可能会有有很多级</p>\n<p><code>root</code>: 可以理解为<strong>最高级别的签发人 Issuer, 负责认证<code> intermediates 身份的</code>合法性</strong></p>\n<p><strong>in short 其实就是一个可信任的链条, 最终的目的就是为了保证 end-user 证书是可信的, 该证书的公钥也就是可信的.</strong></p>\n<blockquote>\n<p>参考: <a href=\"https://www.jianshu.com/p/fcd0572c4765\" rel=\"noopener nofollow\" target=\"_blank\">关于证书链的一点认知</a></p>\n</blockquote>\n<h2 id=\"tls-握手步骤\">TLS 握手步骤</h2>\n<p>(0) Client 与 <code>Server</code> 之间建立 (TCP 三次握手) 连接</p>\n<p>(1) Client 向 <code>Server</code> 发送 \"client hello\" 消息, 里面包含了安全相关的信息, 例如<strong>SSL/TLS 版本号</strong>, Client 支持的加密套件 (CipherSuite); \"client hello\" 消息<strong>还包含了一个随机数client random</strong>, 用于通信密钥的计算;<br />\n(可选)SSL/TLS 协议还允许 \"client hello\" 消息包含 Client 所支持的压缩算法</p>\n<p>(2) <code>Server</code> 回复一条 \"server hello\" 消息, 里面包含了加密套件<strong>(Server 从 \"client hello\" 消息的 CipherSuites 列表中选择其中一个)</strong>,<strong>session id</strong> 和 另一个随机数<strong>server random</strong>; Server 还会在消息中<strong>附带自己的数字证书</strong>;</p>\n<p>(可选)<strong>如果 Server 需要 Client 的数字证书进行客户端认证</strong>, 会向 Client 发送 \"client certificate request\" 请求消息, 里面包含了<strong>Server 所支持的证书类型</strong>和<strong>认可的证书颁发机构 CA</strong> (<strong>双向认证</strong>, 同认证客户端同理)</p>\n<p>(3) Client 收到 \"server hello\",<strong>验证 Server 端的数字证书</strong>, 并得到证书中<strong>Server 端的公钥</strong><br />\n<strong>(关键这里客户端有可信任的证书签发者<code>Issuer</code>, 验证服务端的证书)</strong></p>\n<p>(4) Client 向 <code>Server</code> 发送<strong>第三个随机数 pre-master secret</strong>; 与之前不同,<strong>这次的随机数使用了 Server 的公钥加密</strong> (非对称加密); 现在双方同时拥有这三个随机数client random,server random,premaster secret, 可以用来计算生成共同的通信密钥 master secret 用于加密后面传输的业务数据;</p>\n<p>(5 - 可选) 如果收到 <code>Server</code> 端发来的 \"client certificate request\" 请求消息, Client 会向 Server 发送一个使用 Client 自己的私钥加密过的随机数 (暂时记作 secret-A), 附带 Client 的数字证书; 或者发送一个 \"no digital certificate alert\" 无证书警告, 这种情况下基本可以认为 SSL/TLS 握手失败;</p>\n<p>(6 - 可选) <code>Server</code> 验证 Client 发送过来的数字证书, 并得到证书中公钥对 Client 进行身份认证 (通过公钥解密上面那个 secret-A);</p>\n<p>(7) Client 向 <code>Server</code> 发送 \"finished\" 消息, 使用<strong>第 4 步中计算出来的密钥进行加密传输 (对称加密)</strong>, 这表示 Client 端握手阶段已经完成;</p>\n<p>(8) <code>Server</code> 也向 Client 发送 \"finished\" 消息, 使用<strong>第 4 步中计算出来的密钥进行加密传输 (对称加密)</strong>, 这表示 Server 端握手阶段完成;</p>\n<p>(9) SSL/TLS 握手阶段完成, 接下来双方通信的消息都会使用协商出来的密钥进行加密 (对称加密)<br />\nContent Type: Handshake (22)</p>\n<p><img alt=\"SLLhandshanke\" class=\"lazyload\" /></p>\n<p><a href=\"https://www.cnblogs.com/piyeyong/archive/2010/07/02/1770208.html\" target=\"_blank\">证书的应用之一 —— TCP&amp;SSL通信实例及协议分析(中)</a></p>\n<p>每一条消息都会包含有ContentType,Version,HandshakeType等信息;</p>\n<p>ContentType 指示SSL通信处于哪个阶段, 是握手(Handshake), 开始加密传输(ChangeCipherSpec)还是正常通信(Application)等, 见下表</p>\n<p>Hex\tDec\tType<br />\n0x14\t20\tChangeCipherSpec<br />\n0x15\t21\tAlert<br />\n0x16\t22\tHandshake<br />\n0x17\t23\tApplication</p>\n<p>Handshake Type是在handshanke阶段中的具体哪一步, 见下表\t<br />\nCode\tDescription<br />\n0\tHelloRequest<br />\n1\tClientHello<br />\n2\tServerHello<br />\n11\tCertificate<br />\n12\tServerKeyExchange<br />\n13\tCertificateRequest<br />\n14\tServerHelloDone<br />\n15\tCertificateVerify<br />\n16\tClientKeyExchange<br />\n20\tFinished</p>\n<h3 id=\"关于双向认证\">关于双向认证</h3>\n<p>所有通信中，涉及两个端点，即浏览器和它所连接的网站（即客户端和服务器）。 在单向SSL身份认证过程中，仅验证一个端点（服务器）的身份。<br />\n双向认证是指在SSL握手过程中将同时验证客户端和服务器的身份，所以双向认证SSL证书至少包括两个或两个以上的证书，一个是服务器证书，另一个或多个是客户端证书（即个人认证证书）。</p>\n<h1 id=\"主流的证书格式\">主流的证书格式</h1>\n<p><strong>主流的SSL证书格式:</strong><br />\nDER、CER，文件是二进制格式，只保存证书，不保存私钥。</p>\n<p>PEM，一般是文本格式，可保存证书，可保存私钥。<br />\nPrivacy Enhanced Mail，一般为文本格式，以 -----BEGIN... 开头，以 -----END... 结尾。中间的内容是 BASE64 编码。这种格式可以保存证书和私钥，有时我们也把PEM 格式的私钥的后缀改为 .key 以区别证书与私钥</p>\n<p>CRT，可以是二进制格式，可以是文本格式，与 DER 格式相同，不保存私钥。<br />\nPFX P12，二进制格式，同时包含证书和私钥，一般有密码保护。<br />\nJKS，二进制格式，同时包含证书和私钥，一般有密码保护。</p>\n<p><strong>各服务器平台使用的证书格式:</strong><br />\nNginx：pem<br />\nApache：pem<br />\nIIS：pfx/pkcs12<br />\nTomcat：jks</p>\n<h1 id=\"netty-for-tls-实例\">Netty For TLS 实例</h1>\n<h2 id=\"证书生成\">证书生成</h2>\n<h3 id=\"ca-根证书生成\">CA 根证书生成</h3>\n<p>或者称为 Issuer , 它可以签发证书, 作为客户端和服务端共同信任者</p>\n<ol>\n<li><strong>创建一个私钥</strong><br />\n生成一个安全的私钥。这个私钥将用于签署根证书以及将来由该根CA签发的所有其他证书。为了确保安全性，使用足够长的密钥长度。</li>\n</ol>\n<pre><code class=\"language-sh\">openssl genpkey -algorithm RSA -out root_ca.key -aes256 -pkeyopt rsa_keygen_bits:4096\n# 不加密\n# openssl genpkey -algorithm RSA -out root_ca.key -pkeyopt rsa_keygen_bits:2048\n</code></pre>\n<blockquote>\n<p>输入私钥密码</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>创建自签名的根证书</strong><br />\n使用刚刚生成的私钥来创建一个自签名的根证书。这一步骤不仅会生成证书本身，还会收集有关颁发者的详细信息，这些信息将嵌入到证书中。</li>\n</ol>\n<pre><code class=\"language-sh\">openssl req -x509 -new -nodes -key root_ca.key -sha256 -days 36500 -out root_ca.crt\n</code></pre>\n<ul>\n<li><code>req</code>&nbsp;是用来处理证书请求的命令。</li>\n<li><code>-x509</code>&nbsp;表示要创建一个X.509格式的自签名证书。</li>\n<li><code>-new</code>&nbsp;表示这是一个新的证书请求。</li>\n<li><code>-nodes</code>&nbsp;表示不加密私钥（仅适用于这次命令，因为私钥已经加密）。</li>\n<li><code>-key root_ca.key</code>&nbsp;指定了用于签名的私钥。</li>\n<li><code>-sha256</code>&nbsp;指定了哈希算法。</li>\n<li><code>-days 3650</code>&nbsp;指定了证书的有效期为10年。</li>\n<li><code>-out root_ca.crt</code>&nbsp;指定了输出文件名为&nbsp;<code>root_ca.crt</code>。</li>\n</ul>\n<p>在运行该命令时，你会被要求填写一系列问题，这些问题的答案将作为证书的主题字段（Subject）的一部分。例如：</p>\n<ul>\n<li><strong>Country Name (2 letter code)</strong>: 输入国家代码，如&nbsp;<code>CN</code>。</li>\n<li><strong>State or Province Name (full name)</strong>: 输入省份或州的全名。</li>\n<li><strong>Locality Name (eg, city)</strong>: 输入城市名。</li>\n<li><strong>Organization Name (eg, company)</strong>: 输入组织名称。</li>\n<li><strong>Organizational Unit Name (eg, section)</strong>: 输入部门名称。</li>\n<li><strong>Common Name (e.g. server FQDN or YOUR name)</strong>: (注意这个) 输入通用名称，通常是组织的域名或描述性名称，对于根证书而言，可以是类似于&nbsp;<code>Root CA</code>&nbsp;的字符串。</li>\n<li><strong>Email Address</strong>: 可选，可以留空。</li>\n</ul>\n<ol start=\"3\">\n<li>验证其内容</li>\n</ol>\n<pre><code class=\"language-sh\">openssl x509 -in root_ca.crt -text -noout\n</code></pre>\n<ol start=\"4\">\n<li>客户端信任</li>\n</ol>\n<p>至此</p>\n<ul>\n<li><code>root_ca.crt</code> 是CA 自签名的带公钥的证书</li>\n<li><code>root_ca.key</code> 是CA的私钥(绝对不能泄露)</li>\n</ul>\n<p>为了让客户端信任这个新创建的根证书，需要将CA公钥安装到目标系统的受信任根证书存储中。<br />\n例如，在Windows上，你可以双击 <code>root_ca.crt</code> 文件，然后按照提示选择“安装证书”，并将安装位置设置为“受信任的根证书颁发机构</p>\n<h3 id=\"ca-签署颁发服务端证书\">CA 签署/颁发服务端证书</h3>\n<ol>\n<li>生成目标实体的私钥</li>\n</ol>\n<pre><code class=\"language-sh\">openssl genpkey -algorithm RSA -out server.key -aes256 -pkeyopt rsa_keygen_bits:2048\n</code></pre>\n<ol start=\"2\">\n<li>生成目标实体的签发请求 (CSR)<br />\n使用刚刚生成的私钥来创建一个证书签名请求（CSR）。CSR包含了申请者的公钥以及一些识别信息，如组织名称、域名等。</li>\n</ol>\n<pre><code class=\"language-sh\">openssl req -new -key server.key -out server.csr\n\n# openssl req -newkey rsa:2048 -nodes -keyout server.key -out server.csr -subj \"/C=CN/ST=State/L=City/O=Organization/CN=your.server.domain\"\n</code></pre>\n<ol start=\"3\">\n<li>使用CA根证书的<strong>私钥</strong> 签署CSR</li>\n</ol>\n<pre><code class=\"language-sh\">openssl x509 -req -in server.csr -CA root_ca.crt -CAkey root_ca.key -CAcreateserial -out server.crt -days 7300 -sha256\n# openssl x509 -req -in server.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out server.crt -days 500 -sha256\n</code></pre>\n<h3 id=\"各文件说明\">各文件说明</h3>\n<p>至此有6个文件分别是:<br />\n1.&nbsp;<strong>root_ca.crt (根CA证书公钥) - 自签名 公开 双方信任</strong></p>\n<ul>\n<li><strong>描述</strong>：这是由CA自身创建并签署的自签名证书，作为信任链的起点。根证书通常包含CA的公钥、名称和其他元数据，并且是由CA私钥签名的</li>\n<li><strong>用途</strong>：根证书用于验证由该CA签发的所有下级证书的真实性。它通常被预装在操作系统、浏览器或其他应用程序的信任库中，作为受信任的根证书机构</li>\n</ul>\n<p>2.&nbsp;<strong>root_ca.key (根CA证书私钥)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是与根CA证书配对的私钥，用于签署其他证书。私钥是高度敏感的信息，不应公开或共享。</li>\n<li><strong>用途</strong>：根CA私钥用于签署中间CA证书、服务器证书、客户端证书等。它是建立信任链的基础。</li>\n<li><strong>安全性</strong>：私钥应存储在安全的地方，最好是在离线环境中，只有在需要签署新证书时才连接到网络。 它一旦被攻破，所有依赖它的证书都将失去信任。</li>\n</ul>\n<p>3.&nbsp;<strong>root_ca.srl (序列号文件)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是一个包含十六进制正整数的文件，用于记录已签发证书的序列号。每次签署新证书时，OpenSSL会从这个文件中读取当前的最大序列号，并为新证书分配一个递增的序列号。</li>\n</ul>\n<p>4.&nbsp;<strong>server.crt (服务器公钥)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是由CA签署的服务器证书，包含服务器的公钥以及关于证书的一些信息，如版本、序列号、签名算法、颁发者、持有者、有效期等。服务器证书用于加密客户端与服务器之间的通信，确保数据传输的安全性。</li>\n<li><strong>用途</strong>：服务器证书安装在Web服务器上，用于HTTPS协议下的安全通信。客户端通过验证服务器证书的有效性来确认服务器的身份，并使用证书中的公钥进行加密通信。</li>\n<li><strong>格式</strong>：常见的格式包括PEM（以&nbsp;<code>-----BEGIN CERTIFICATE-----</code>&nbsp;开头，<code>-----END CERTIFICATE-----</code>&nbsp;结尾）和DER（二进制格式）。Linux系统通常使用&nbsp;<code>.crt</code>&nbsp;文件扩展名，而Windows系统可能使用&nbsp;<code>.cer</code></li>\n</ul>\n<p>5.&nbsp;<strong>server.csr (证书签名请求)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是证书申请者在申请数字证书时生成的文件，包含了公钥和标识名称（Distinguished Name, DN），如国家、省份、城市、组织名称、通用名称（通常是域名）等。CSR是以&nbsp;<code>-----BEGIN CERTIFICATE REQUEST-----</code>&nbsp;开头，<code>-----END CERTIFICATE REQUEST-----</code>&nbsp;结尾的Base64编码格式。</li>\n<li><strong>用途</strong>：CSR文件提交给CA后，CA会使用其根证书私钥对CSR中的信息进行签名，生成正式的数字证书。CSR文件本身不是证书，而是申请证书的请求。</li>\n<li><strong>生成</strong>：CSR文件通常由服务器管理员使用OpenSSL等工具生成，同时生成相应的私钥。生成CSR时，必须确保私钥的安全性，因为CSR文件中不包含私钥</li>\n</ul>\n<p>6.&nbsp;<strong>server.key (服务器私钥)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是与服务器证书配对的私钥，用于解密客户端发送的加密信息。私钥是高度敏感的信息，不应公开或共享。</li>\n<li><strong>用途</strong>：服务器私钥用于解密通过TLS/SSL协议传输的数据。在HTTPS通信中，客户端使用服务器证书中的公钥加密数据，服务器则使用私钥解密这些数据。</li>\n<li><strong>格式</strong>：常见的格式包括PEM（以&nbsp;<code>-----BEGIN RSA PRIVATE KEY-----</code>&nbsp;或&nbsp;<code>-----BEGIN PRIVATE KEY-----</code>&nbsp;开头，<code>-----END RSA PRIVATE KEY-----</code>&nbsp;或&nbsp;<code>-----END PRIVATE KEY-----</code>&nbsp;结尾）和DER（二进制格式）。Linux系统通常使用&nbsp;<code>.key</code>&nbsp;文件扩展名</li>\n</ul>\n<h4 id=\"每个角色验证需要\">每个角色验证需要</h4>\n<ol>\n<li>**客户端需要</li>\n</ol>\n<ul>\n<li><strong><code>root_ca.crt</code></strong>：根 CA 的公钥证书。客户端将使用此证书来验证服务器的证书是否由可信的 CA 签发。</li>\n</ul>\n<ol>\n<li>**服务端端需要</li>\n</ol>\n<ul>\n<li><strong><code>server.key</code></strong>：服务器的私钥。服务器将使用此私钥来解密客户端发送的加密数据，并签署响应。</li>\n<li><strong><code>server.crt</code></strong>：服务器的公钥证书，由根 CA 签发。服务器将使用此证书向客户端证明其身份。</li>\n<li><strong><code>root_ca.crt</code></strong>（可选, 双向验证必选）：如果你的服务器证书是由中间 CA 签发的，你可以将根 CA 证书或中间 CA 证书链一起加载到服务器的信任库中，以便客户端可以验证整个证书链。</li>\n</ul>\n<h2 id=\"在netty-使用\">在Netty 使用</h2>\n<h3 id=\"证书的加载\">证书的加载</h3>\n<ol>\n<li>\n<p>公钥加载  <code>.pem, .crt, .cer</code>  : 通常以&nbsp;<code>-----BEGIN CERTIFICATE-----</code>&nbsp;开头，以&nbsp;<code>-----END CERTIFICATE-----</code>&nbsp;结尾。它既可以包含公钥证书，也可以包含私钥。<strong>Java本身支持 pem</strong></p>\n</li>\n<li>\n<p>私钥加载 <code>.key</code>:  openssl 默认给私钥加密了 , 将其转为不加密的, 可使用 bouncycastle加载之</p>\n</li>\n</ol>\n<pre><code># **转换为 PKCS#8 格式 (PEM 编码)**\nopenssl pkcs8 -topk8 -inform PEM -in server.key -outform PEM -nocrypt -out server_pkcs8.key\n\n# **转换为 PKCS#8 格式 (DER 编码)** 二进制格式\nopenssl pkcs8 -topk8 -inform PEM -in server.key -outform DER -nocrypt -out server_pkcs8.der\n</code></pre>\n<ul>\n<li>使用 bouncycastle 加载 pkcs8 私钥</li>\n</ul>\n<pre><code>implementation(\"cn.hutool:hutool-all:5.8.16\")\nimplementation(\"org.bouncycastle:bcprov-jdk15on:1.70\")\nimplementation(\"org.bouncycastle:bcpkix-jdk15on:1.70\")\n</code></pre>\n<pre><code class=\"language-java\">\n\npublic static void main(String[] args) throws Exception {\n\n\tfinal String ca_cet = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\root_ca.crt\";\n\tfinal String server_crt = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server.crt\";\n\n\tfinal String server_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server.key\";\n\tfinal String server_pkcs8_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server_pkcs8.key\";\n\t\n\tPublicKey root_caKey = PemUtil.readPemPublicKey(FileUtil.getInputStream(ca_cet));\n\tSystem.out.println(\"root_caKey  ==&gt; \"+root_caKey );\n\tCertificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(server_crt));\n\tSystem.out.println(\"X509C  ==&gt; \"+root_caKey );\n\t\n\tPublicKey server_crtKey = PemUtil.readPemPublicKey(FileUtil.getInputStream(server_crt));\n\tSystem.out.println(\"server_crtKey  ==&gt; \"+server_crtKey );\n\n\tPrivateKey privateKey = PemUtil.readPemPrivateKey(FileUtil.getInputStream(server_pkcs8_key));\n\tSystem.out.println(\"server_pkcs8  ==&gt; \"+privateKey );\n}\n</code></pre>\n<ul>\n<li>使用 bouncycastle 如何 加载默认 openssl 加密的 <code>server.key</code> ?</li>\n</ul>\n<pre><code class=\"language-java\">public static PrivateKey loadEncryptedPrivateKeyFromPem(String pemFile, char[] password) throws Exception {\n\ttry (Reader reader = new FileReader(pemFile);\n\t\t PEMParser pemParser = new PEMParser(reader)) {\n\n\t\tObject object = pemParser.readObject();\n\t\tJcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n\n\t\tif (object instanceof PEMEncryptedKeyPair) {\n\t\t\tPEMEncryptedKeyPair encryptedKeyPair = (PEMEncryptedKeyPair) object;\n\t\t\tInputDecryptorProvider decryptorProvider = new JceOpenSSLPKCS8DecryptorProviderBuilder().build(password);\n\t\t\tKeyPair kp = converter.getKeyPair(encryptedKeyPair.decryptKeyPair(decryptorProvider));\n\t\t\treturn kp.getPrivate();\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"Unsupported encrypted key type: \" + object.getClass().getName());\n\t\t}\n\t}\n}\n\n\n</code></pre>\n<h3 id=\"单向验证的tls\">单向验证的TLS</h3>\n<p>客户端单向了验证服务端</p>\n<h4 id=\"服务端\">服务端</h4>\n<pre><code class=\"language-java\">public static void main(String[] args) throws Exception {\n\n\tNioEventLoopGroup boosGroup = new NioEventLoopGroup();\n\tfinal ServerBootstrap serverBootstrap = new ServerBootstrap();\n\tint port = 19977;\n\t// 1. 加载 PEM 私钥,  2.  加载 证书\n\tfinal String server_crt = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server.crt\";\n\tfinal String server_pkcs8_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server_pkcs8.key\";\n\n\tCertificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(server_crt));\n\tPrivateKey privateKey = PemUtil.readPemPrivateKey(FileUtil.getInputStream(server_pkcs8_key));\n\t// 3. 创建 KeyStore 并将私钥和证书添加到其中\n\tKeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n\tkeyStore.load(null, null);\n\tkeyStore.setKeyEntry(\"alias\", privateKey, \"password\".toCharArray(), new Certificate[]{certificate});\n\n\t// 4. 创建 KeyManagerFactory 并初始化\n\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n\tkmf.init(keyStore, \"password\".toCharArray());\n\n\t// 5. 构建 SslContext\n\tfinal SslContext sslContext = SslContextBuilder.forServer(kmf)\n\t\t\t.build();\n\n\tserverBootstrap\n\t\t\t.group(boosGroup)\n\t\t\t.channel(NioServerSocketChannel.class)\n\t\t\t.option(ChannelOption.SO_BACKLOG, 1024)\n\t\t\t.childOption(ChannelOption.SO_KEEPALIVE, true)\n\t\t\t.childOption(ChannelOption.TCP_NODELAY, true)\n\t\t\t.childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() {\n\t\t\t\t@Override\n\t\t\t\tprotected void initChannel(NioSocketChannel ch) {\n\t\t\t\t\t// 添加 SSL/TLS 处理器\n\t\t\t\t\tch.pipeline().addLast(sslContext.newHandler(ch.alloc()));\n\t\t\t\t\tch.pipeline().addLast(new StringDecoder())\n\t\t\t\t\t\t\t.addLast(new StringEncoder())\n\t\t\t\t\t\t\t.addLast(new ServerHandler());\n\t\t\t\t}\n\t\t\t});\n\tChannelFuture f = serverBootstrap.bind(port).addListener(future -&gt; {\n\t\tif (future.isSuccess()) {\n\t\t\tSystem.out.println(new Date() + \": 端口[\" + port + \"]绑定成功!\");\n\t\t} else {\n\t\t\tSystem.err.println(\"端口[\" + port + \"]绑定失败!\");\n\t\t}\n\t});\n\t//下面会进行阻塞, 等待服务器连接关闭之后 main 方法退出, 程序结束;\n\tf.channel().closeFuture().sync();\n}\n</code></pre>\n<h4 id=\"客户端\">客户端</h4>\n<pre><code class=\"language-java\"> public static void main(String[] args) throws Exception {\n \n\tBootstrap bootstrap = new Bootstrap();\n\tNioEventLoopGroup group = new NioEventLoopGroup();\n\n\tString host = \"192.168.20.130\";\n\tint port = 19977;\n\n\t// 1. 加载 CA 证书\n\tfinal String ca_cet = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\root_ca.crt\";\n\tCertificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(ca_cet));\n\n\t// 2. 创建 KeyStore 并将 CA 证书添加到信任库中\n\tKeyStore trustStore = KeyStore.getInstance(\"JKS\");\n\ttrustStore.load(null, null);\n\ttrustStore.setCertificateEntry(\"ca\", certificate);\n\n\t// 3. 创建 TrustManagerFactory 并初始化\n\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\ttmf.init(trustStore);\n\n\t// 4. 构建 SslContext\n\tSslContext build = SslContextBuilder.forClient()\n\t\t\t.trustManager(tmf)\n\t\t\t.build();\n\n\tbootstrap.group(group)\n\t\t\t.channel(NioSocketChannel.class)\n\t\t\t.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 30000)\n\t\t\t.option(ChannelOption.SO_KEEPALIVE, true)\n\t\t\t.handler( new SimpleChannelInboundHandler&lt;String&gt;() {\n\t\t\t\t@Override\n\t\t\t\tprotected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n\t\t\t\t\tSystem.out.println(\"客户端接收: \"+msg);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.connect(host, port).addListener(new ChannelFutureListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n\t\t\t\t\tfuture.channel().pipeline()\n\t\t\t\t\t\t\t.addFirst(new StringEncoder())\n\t\t\t\t\t\t\t.addFirst(new StringDecoder())\n\t\t\t\t\t\t\t.addFirst( build.newHandler(future.channel().alloc() ));\n\t\t\t\t\tfinal String helloToServer = \"珠玉买歌笑，糟糠养贤才。方知黄鹄举，千里独徘徊。\"+System.currentTimeMillis();\n\t\t\t\t\tfuture.channel().writeAndFlush(helloToServer);\n\t\t\t\t}\n\t\t\t});\n//        group.shutdownGracefully();\n    }\n\n</code></pre>\n<p>Android 上使用 java.security.KeyStore 时，可能会遇到 KeyStoreException: JKS not found 的错误。这是因为 Android 的安全框架与标准 Java 不同，Android 并不支持 JKS（Java KeyStore）格式。相反，Android 支持其他类型的密钥库，如 BKS（Bouncy Castle KeyStore）和 PKCS12。</p>\n<pre><code class=\"language-java\">private SslContext getSslContext() throws Exception {\n\tCertificate caCert = CertificateUtils.getCertificate();\n\tKeyStore trustStore = KeyStore.getInstance(\"BKS\");  // 使用 BKS 或 PKCS12\n\ttrustStore.load(null, null);\n\ttrustStore.setCertificateEntry(\"ca\", caCert);\n\n\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\ttmf.init(trustStore);\n\n\tSslContext build = SslContextBuilder.forClient()\n\t\t\t.trustManager(tmf)\n\t\t\t.build();\n\treturn build;\n}\n</code></pre>\n<p>抓包看看<br />\n![[Pasted image 20241219145126.png]]</p>\n<h3 id=\"双向验证的tls\">双向验证的TLS</h3>\n<p>其实同服务端一样的逻辑 1.生成客户端私钥, 2.生成客户端CRS, 3.用CA根证书签发客户端的公钥</p>\n<h4 id=\"客户端证书准备\">客户端证书准备</h4>\n<h5 id=\"生成客户端私钥\"><strong>生成客户端私钥</strong></h5>\n<pre><code>openssl genpkey -algorithm RSA -out client.key -aes256 -pkeyopt rsa_keygen_bits:2048\n</code></pre>\n<p>转换为pkcs#8 格式</p>\n<pre><code>openssl pkcs8 -topk8 -inform PEM -in client.key -outform PEM -nocrypt -out client_pkcs8.key\n</code></pre>\n<h5 id=\"创建客户端的证书签名请求-csr\"><strong>创建客户端的证书签名请求 (CSR)</strong></h5>\n<pre><code>openssl req -new -key client.key -out client.csr\n</code></pre>\n<h5 id=\"使用根-ca-签名客户端的-csr\"><strong>使用根 CA 签名客户端的 CSR</strong></h5>\n<pre><code>openssl x509 -req -in client.csr -CA root_ca.crt -CAkey root_ca.key -CAcreateserial -out client.crt -days 7300 -sha256\n\n</code></pre>\n<h4 id=\"服务端-1\">服务端</h4>\n<pre><code class=\"language-java\">public static void main(String[] args) throws Exception {\n        NioEventLoopGroup boosGroup = new NioEventLoopGroup();\n        final ServerBootstrap serverBootstrap = new ServerBootstrap();\n        int port = 19977;\n        // 1. 加载 PEM 私钥,  2.  加载 证书\n        final String server_crt = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server.crt\";\n        final String server_pkcs8_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server_pkcs8.key\";\n\n        Certificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(server_crt));\n        PrivateKey privateKey = PemUtil.readPemPrivateKey(FileUtil.getInputStream(server_pkcs8_key));\n        // 3. 创建 KeyStore 并将私钥和证书添加到其中\n        KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n        keyStore.load(null, null);\n        keyStore.setKeyEntry(\"alias\", privateKey, \"password\".toCharArray(), new Certificate[]{certificate});\n\n        // 4. 创建 KeyManagerFactory 并初始化\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        kmf.init(keyStore, \"password\".toCharArray());\n\n        //双向认证 CA根证书\n        final String root_ca = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\root_ca.crt\";\n        X509Certificate caCertificate = (X509Certificate) SecureUtil.readX509Certificate(FileUtil.getInputStream(root_ca));\n\n        // 5. 构建 SslContext\n        final SslContext sslContext = SslContextBuilder.forServer(kmf)\n                .trustManager(caCertificate)\n                .clientAuth(io.netty.handler.ssl.ClientAuth.REQUIRE)//双向认证 &gt; 配置要求客户端也认证\n                .build();\n\n        serverBootstrap\n                .group(boosGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) {\n                        // 添加 SSL/TLS 处理器\n                        ch.pipeline().addLast(sslContext.newHandler(ch.alloc()));\n                        ch.pipeline().addLast(new StringDecoder())\n                                .addLast(new StringEncoder())\n                                .addLast(new ServerHandler());\n                    }\n                });\n        ChannelFuture f = serverBootstrap.bind(port).addListener(future -&gt; {\n            if (future.isSuccess()) {\n                System.out.println(new Date() + \": 端口[\" + port + \"]绑定成功!\");\n            } else {\n                System.err.println(\"端口[\" + port + \"]绑定失败!\");\n            }\n        });\n        //下面会进行阻塞, 等待服务器连接关闭之后 main 方法退出, 程序结束;\n        f.channel().closeFuture().sync();\n    }\n</code></pre>\n<h4 id=\"客户端-1\">客户端</h4>\n<pre><code class=\"language-java\">public static void main(String[] args) throws Exception {\n        Bootstrap bootstrap = new Bootstrap();\n        NioEventLoopGroup group = new NioEventLoopGroup();\n\n        String host = \"192.168.20.130\";\n        int port = 19977;\n\n        // 1. 加载 CA 证书\n        final String ca_cet = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\root_ca.crt\";\n        Certificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(ca_cet));\n\n        // 2. 创建 KeyStore 并将 CA 证书添加到信任库中\n        KeyStore trustStore = KeyStore.getInstance(\"JKS\");\n        trustStore.load(null, null);\n        trustStore.setCertificateEntry(\"ca\", certificate);\n\n        // 3. 创建 TrustManagerFactory 并初始化\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        tmf.init(trustStore);\n\n        // 双向认证 &gt; 客户端证书\n        final String client_crt = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\client.crt\";\n        final String client_pkcs8_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\client_pkcs8.key\";\n\n        // 4. 构建 SslContext\n        SslContext build = SslContextBuilder.forClient()\n                .keyManager(FileUtil.file(client_crt), FileUtil.file(client_pkcs8_key))\n                .trustManager(tmf)\n                .build();\n\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 30000)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .handler( new SimpleChannelInboundHandler&lt;String&gt;() {\n                    @Override\n                    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n                        System.out.println(\"客户端接收: \"+msg);\n                    }\n                })\n                .connect(host, port).addListener(new ChannelFutureListener() {\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        future.channel().pipeline()\n                                .addFirst(new StringEncoder())\n                                .addFirst(new StringDecoder())\n                                .addFirst( build.newHandler(future.channel().alloc() ));\n                        final String helloToServer = \"珠玉买歌笑，糟糠养贤才。方知黄鹄举，千里独徘徊。\"+System.currentTimeMillis();\n                        future.channel().writeAndFlush(helloToServer);\n                    }\n                });\n//        group.shutdownGracefully();\n    }\n</code></pre>\n<p>最后, 抓包看看</p>\n<p><img alt=\"Pasted image 20241220115443\" class=\"lazyload\" /></p>\n\n</div>\n<div id=\"MySignature\">\n    预防老年痴呆，保持终身学习!    —— <a href=\"https://www.cnblogs.com/dddy/\" target=\"_blank\">daidaidaiyu</a>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 21:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/dddy\">daidaidaiyu</a>&nbsp;\n阅读(<span id=\"post_view_count\">94</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Supertonic 部署与使用全流程保姆级指南（附已部署镜像）",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19453758",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19453758\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 19:57\">\n    <span>Supertonic 部署与使用全流程保姆级指南（附已部署镜像）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Supertonic开源工具Python版部署与使用指南 摘要：本文详细介绍了Supertonic(一款语音处理工具)Python版本的完整部署流程，包括服务器环境准备、源码下载、依赖安装、常见报错解决方法等关键步骤。部署成功后，用户只需修改示例脚本中的文本内容，即可生成对应的音频结果文件。文章还提供了已部署镜像的获取方式，帮助用户快速上手。部署过程中需注意模型自动下载、依赖版本冲突等常见问题。通过本指南，用户可以快速完成Supertonic的环境搭建并开始使用其核心功能。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"前言\">前言</h1>\n<p>Supertonic 是一款实用的开源工具（注：可根据实际补充Supertonic的核心功能，如语音合成/处理等），本文将详细讲解其 Python 版本的完整部署流程、日常使用方法，并附上我已部署好的镜像链接，帮大家快速上手。</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h1 id=\"一部署前准备\">一、部署前准备</h1>\n<ol>\n<li>服务器环境要求：已安装 Python 3.7+（推荐3.8-3.10）、pip 工具，确保服务器有基础的网络访问权限；</li>\n<li>工具准备：本地电脑（或服务器）可通过 <code>scp</code>/<code>rz</code>/<code>sftp</code> 等方式传输文件到服务器。<br />\n<strong>我的服务器是在星图上面租的4090，1.46元一小时，相对来说还是很便的</strong><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></li>\n</ol>\n<h1 id=\"二完整部署步骤\">二、完整部署步骤</h1>\n<h2 id=\"步骤1从github下载源码包\">步骤1：从GitHub下载源码包</h2>\n<p>首先在本地或服务器直接下载 Supertonic 的 Python 版本源码，GitHub 地址（请替换为实际地址）：</p>\n<pre><code class=\"language-bash\"># 方式1：服务器直接git克隆（推荐）\ngit clone https://github.com/supertone-inc/supertonic\n\n# 方式2：本地下载zip包后，手动上传到服务器\n# 访问上述GitHub地址，点击「Code」→「Download ZIP」下载压缩包\n</code></pre>\n<p>github链接：<a href=\"https://github.com/supertone-inc/supertonic\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/supertone-inc/supertonic</a><br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"步骤2将源码包转移到服务器\">步骤2：将源码包转移到服务器</h2>\n<p>如果是本地下载的 zip 包，通过jupyter可以直接拖动上传到服务器上面<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"步骤3解压程序包\">步骤3：解压程序包</h2>\n<p>登录服务器，进入文件存放目录，解压源码包：<br />\n<strong>在左侧切换到压缩包所在的目录的时候，右边界面点击 Terminal</strong></p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<p><strong>输入以下命令解压包</strong></p>\n<pre><code class=\"language-bash\"># 解压zip包（如果是git克隆则无需此步骤）\nunzip supertonic-main.zip\n\n# 解压后会生成 supertonic-main 目录\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"步骤4进入指定路径并安装依赖\">步骤4：进入指定路径并安装依赖</h2>\n<p>进入 Supertonic Python 代码的核心路径，安装 <code>requirements.txt</code> 中的依赖：</p>\n<pre><code class=\"language-bash\"># 进入supertonic-main/py路径\ncd supertonic-main/py/\n\n# 安装依赖（建议先升级pip，避免安装失败）\npip install --upgrade pip\npip install -r requirements.txt\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"步骤5首次运行示例脚本并补充缺失库\">步骤5：首次运行示例脚本并补充缺失库</h2>\n<p>运行示例脚本 <code>example_pypi.py</code>，此时大概率会提示缺少某个库（如 <code>supertonic</code> 库）：</p>\n<pre><code class=\"language-bash\"># 首次运行示例脚本\npython example_pypi.py\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"常见报错示例\">常见报错示例：</h3>\n<pre><code>ModuleNotFoundError: No module named 'supertonic'\n</code></pre>\n<h4 id=\"解决方法\">解决方法：</h4>\n<p>根据报错提示，用 pip 补充安装缺失的库：</p>\n<pre><code class=\"language-bash\"># 替换xxx为实际缺失的库名，如 pip install soundfile\npip install supertonic\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"步骤6重新运行脚本并等待模型下载\">步骤6：重新运行脚本并等待模型下载</h2>\n<p>补充安装缺失库后，再次运行示例脚本：</p>\n<pre><code class=\"language-bash\">python example_pypi.py\n</code></pre>\n<p>⚠️ 注意：<strong>第一次运行时，脚本会自动下载所需的模型文件</strong>，下载速度取决于服务器网络，需耐心等待（通常几分钟），不要中断进程。</p>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"步骤7验证部署成功\">步骤7：验证部署成功</h2>\n<p>运行完成后，检查 <code>supertonic-main/py/result</code> 目录，若生成了 wav 格式的结果文件，说明部署成功！</p>\n<pre><code class=\"language-bash\"># 查看result目录内容\nls result/\n</code></pre>\n<p>或者直接利用左侧文件管理系统查看<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h2 id=\"三supertonic-使用步骤\">三、Supertonic 使用步骤</h2>\n<p>部署完成或者直接使用我部署完的镜像之后，日常使用只需以下4步：</p>\n<h3 id=\"步骤1进入指定工作路径\">步骤1：进入指定工作路径</h3>\n<p>每次使用前，先登录服务器并进入核心路径：</p>\n<pre><code class=\"language-bash\">cd /supertonic-main/py/\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"步骤2修改示例脚本的文本内容\">步骤2：修改示例脚本的文本内容</h3>\n<p>编辑 <code>example_pypi.py</code> 文件，修改其中的 <code>text</code> 变量（核心输入内容，如语音合成的文本）：</p>\n<pre><code class=\"language-bash\"># 用vim编辑文件\nvim example_pypi.py\n\n# 找到类似如下的代码行，修改text的值\ntext = \"这是默认的测试文本\"  # 将此行改为你需要的内容\n</code></pre>\n<p>修改完成后，按 <code>Esc</code> → 输入 <code>:wq</code> 保存并退出 vim。</p>\n<p>或者直接用可视化界面修改内容<br />\n<img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<h3 id=\"步骤3运行脚本生成结果\">步骤3：运行脚本生成结果</h3>\n<p>在当前路径下执行脚本，触发处理流程：</p>\n<pre><code class=\"language-bash\">python example_pypi.py\n</code></pre>\n<p>结果没有任何输出就是生成成功了，直接在result里面查看就可以了</p>\n<h3 id=\"步骤4查看生成的结果文件\">步骤4：查看生成的结果文件</h3>\n<p>处理完成后，所有结果会以 <code>wav</code> 音频文件格式存储在 <code>supertonic-main/py/result</code> 目录下，可通过 <code>scp</code> 下载到本地播放，或直接在服务器上用音频工具查看：</p>\n<pre><code class=\"language-bash\"># 下载结果文件到本地（示例）\nscp root@192.168.1.100:/opt/supertonic-main/py/result/xxx.wav ~/Desktop/\n</code></pre>\n<h1 id=\"四已部署好的镜像链接\">四、已部署好的镜像链接</h1>\n<p>为了方便大家快速使用，我已将部署完成的 Supertonic 环境打包为星图的社区镜像，可直接拉取使用，等待审核通过之后我会把链接搬到博客上面来。</p>\n<h1 id=\"五常见注意事项\">五、常见注意事项</h1>\n<ol>\n<li>模型下载失败：若首次运行时模型下载中断，可手动下载模型文件后放到脚本指定的缓存目录（通常在 <code>~/.cache/</code> 下）；</li>\n<li>依赖版本冲突：若安装 <code>requirements.txt</code> 时出现版本冲突，可尝试添加 <code>--force-reinstall</code> 参数重新安装，或降级对应库版本；</li>\n<li>权限问题：若运行脚本提示权限不足，执行 <code>chmod +x example_pypi.py</code> 或用 <code>sudo python example_pypi.py</code> 运行。</li>\n</ol>\n<hr />\n<h1 id=\"总结\">总结</h1>\n<ol>\n<li>Supertonic Python 版本部署核心步骤：下载源码→上传服务器→解压→安装依赖→补装缺失库→首次运行（等待模型下载）；</li>\n<li>日常使用只需修改 <code>example_pypi.py</code> 的 <code>text</code> 内容，运行脚本即可在 <code>result</code> 目录获取 wav 结果；</li>\n<li>可直接使用博主提供的已部署镜像，跳过繁琐的环境配置步骤，快速上手。</li>\n</ol>\n<p>如果部署或使用过程中遇到问题，欢迎在评论区交流～</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 19:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\n阅读(<span id=\"post_view_count\">31</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}