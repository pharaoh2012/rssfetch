{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "PHP 8.5 升级生存指南：避免凌晨两点回滚的检查清单",
      "link": "https://www.cnblogs.com/catchadmin/p/19479967",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19479967\" id=\"cb_post_title_url\" title=\"发布于 2026-01-14 07:43\">\n    <span>PHP 8.5 升级生存指南：避免凌晨两点回滚的检查清单</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"php-85-升级生存指南避免凌晨两点回滚的检查清单\">PHP 8.5 升级生存指南：避免凌晨两点回滚的检查清单</h1>\n<h2 id=\"升级-php-不难被坑才难\">升级 PHP 不难，被坑才难</h2>\n<p>一月初是做那种\"你永远不想赶工\"的工作的好时机：运行时升级。</p>\n<p>大多数 PHP 8.x 小版本升级很顺利，但\"顺利\"不等于\"零风险\"。真正的问题通常来自：</p>\n<ul>\n<li>隐藏的平台约束（扩展、系统库、SAPI），</li>\n<li>能编译但行为不同的依赖，</li>\n<li>被忽略多年的警告/弃用突然淹没日志，</li>\n<li>假设回滚\"很简单\"的上线计划（实际上很少简单）。</li>\n</ul>\n<p>这篇文章侧重实操。我不会重新讲 PHP 8.5 的新特性，比如管道操作符或 URI 处理。新特性只会作为兼容性检查点简单提及。目标是像成年人一样发布 PHP 8.5：有计划、有防护、有监控、有真正能用的回滚路径。</p>\n<p>PHP 8.5 的稳定版于 2025 年 11 月 20 日发布，遵循正常的 PHP 支持周期。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/php85-upgrade-survival-guide-checklist\" rel=\"noopener nofollow\" target=\"_blank\">原文 PHP 8.5 升级生存指南：避免凌晨两点回滚的检查清单</a></p>\n<h2 id=\"确定目标版本定义内部支持策略\">确定目标版本，定义内部支持策略</h2>\n<p>在动 CI 或 Composer 之前，先回答一个问题：</p>\n<p><strong>在你的组织里，这次升级\"完成\"意味着什么？</strong></p>\n<h3 id=\"确定目标和截止日期\">确定目标和截止日期</h3>\n<p>PHP 分支有两年的活跃支持，然后是两年的安全修复。</p>\n<p>官方支持表：</p>\n<ul>\n<li>PHP 8.5：2025 年 11 月 20 日初始发布</li>\n<li>活跃支持至 2027 年 12 月 31 日</li>\n<li>安全支持至 2029 年 12 月 31 日</li>\n</ul>\n<p>支持窗口很宽裕——但你的内部截止日期通常由以下因素驱动：</p>\n<ul>\n<li>合规要求，</li>\n<li>托管镜像 / 基础容器，</li>\n<li>框架支持窗口，</li>\n<li>停留在\"仅安全修复\"阶段的成本。</li>\n</ul>\n<h3 id=\"定义范围升级常常在这里无声失败\">定义范围（升级常常在这里无声失败）</h3>\n<p>写下什么包含、什么不包含：</p>\n<p><strong>包含：</strong></p>\n<ul>\n<li>运行时版本升级（FPM/CLI），</li>\n<li>Composer 依赖调整，</li>\n<li>CI 矩阵更新，</li>\n<li>生产环境上线策略，</li>\n<li>升级后验证。</li>\n</ul>\n<p><strong>不包含（除非你明确加进去）：</strong></p>\n<ul>\n<li>重构代码以使用 PHP 8.5 新特性，</li>\n<li>与 PHP 8.5 无关的主要框架升级，</li>\n<li>\"顺手改\"的重写。</li>\n</ul>\n<p>如果不定义范围，\"升级\"会变成\"重写\"，然后就会停滞。</p>\n<h3 id=\"提前决定兼容性策略\">提前决定兼容性策略</h3>\n<p>如果代码库需要在旧版 PHP 和 8.5 上同时运行一段时间：</p>\n<ul>\n<li>用 CI 强制双版本兼容，</li>\n<li>在生产环境切到 8.5 之前，不要合并 8.5 专属语法（比如 <code>|&gt;</code>）。</li>\n</ul>\n<p>如果做硬切换：</p>\n<ul>\n<li>确保上线/回滚方案万无一失，</li>\n<li>接受功能分支可能更早开始使用 8.5 专属语法。</li>\n</ul>\n<h2 id=\"初始审计当前-php扩展和依赖约束\">初始审计：当前 PHP、扩展和依赖约束</h2>\n<p>大多数\"PHP 升级\"bug 不是语言 bug，而是环境不匹配。</p>\n<h3 id=\"快照实际运行的运行时\">快照实际运行的运行时</h3>\n<p>在生产环境运行这些命令，不是你的笔记本：</p>\n<pre><code class=\"language-bash\">php -v\nphp -m\nphp --ini\nphp -i | head -n 50\n</code></pre>\n<p>如果用 PHP-FPM，还要捕获：</p>\n<ul>\n<li>FPM pool 配置，</li>\n<li>ini 覆盖，</li>\n<li>传给 FPM 的环境变量，</li>\n<li>opcache/JIT 设置（这些在不同环境可能不同）。</li>\n</ul>\n<h3 id=\"创建可复用的平台快照脚本\">创建可复用的\"平台快照\"脚本</h3>\n<p>把这样一个脚本放到 <code>tools/php-platform-snapshot.php</code>，在每个环境（开发/预发/生产）运行。提交脚本本身，不要让它成为口口相传的知识。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\nfunction ext_version(string $ext): ?string {\n    $v = phpversion($ext);\n    return $v === false ? null : $v;\n}\n$snapshot = [\n    'php_version' =&gt; PHP_VERSION,\n    'php_version_id' =&gt; PHP_VERSION_ID,\n    'sapi' =&gt; PHP_SAPI,\n    'os' =&gt; PHP_OS_FAMILY . ' ' . php_uname('r'),\n    'ini_loaded' =&gt; php_ini_loaded_file(),\n    'ini_scanned' =&gt; php_ini_scanned_files(),\n    'extensions' =&gt; [],\n];\n$exts = get_loaded_extensions();\nsort($exts);\nforeach ($exts as $ext) {\n    $snapshot['extensions'][$ext] = ext_version($ext);\n}\necho json_encode($snapshot, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . PHP_EOL;\n</code></pre>\n<p>这能给你两个有用的东西：</p>\n<ul>\n<li>测试 8.5 时可以 diff 的\"什么变了\"记录，</li>\n<li>快速发现\"预发能跑生产不能跑\"问题的方法——往往是生产多了一个扩展或 ini 不同。</li>\n</ul>\n<h3 id=\"盘点-composer-平台要求\">盘点 Composer 平台要求</h3>\n<p>Composer 把你的 PHP 运行时和扩展当作\"平台包\"，依赖可以 require 它们。</p>\n<p>有用的命令：</p>\n<pre><code class=\"language-bash\">composer show --platform\ncomposer check-platform-reqs\n</code></pre>\n<ul>\n<li><code>composer show --platform</code> 列出 Composer 看到的平台包。</li>\n<li><code>composer check-platform-reqs</code> 验证你的真实服务器是否满足已安装包的 PHP/ext 要求（它会故意忽略 <code>config.platform</code>）。</li>\n</ul>\n<p>这是在部署前发现\"生产缺 ext-intl\"最快的方法。</p>\n<h2 id=\"构建-ci-矩阵在旧版-php-和-85-上运行测试把警告当信号\">构建 CI 矩阵：在旧版 PHP 和 8.5 上运行测试（把警告当信号）</h2>\n<p>CI 是让升级变得可预测的地方。</p>\n<h3 id=\"规则在生产稳定运行-85-之前保留旧运行时在-ci-中\">规则：在生产稳定运行 8.5 之前，保留旧运行时在 CI 中</h3>\n<p>即使你计划硬切换，短暂的重叠期也能帮你避免\"我们在生产准备好之前合并了 8.5 专属代码\"。</p>\n<h3 id=\"github-actions-矩阵示例旧版-php--php-85\">GitHub Actions 矩阵示例（旧版 PHP + PHP 8.5）</h3>\n<p>如果用 GitHub Actions，shivammathur/setup-php 支持直接指定 <code>'8.5'</code>。</p>\n<pre><code class=\"language-yaml\">name: CI\non:\n  push:\n  pull_request:\njobs:\n  tests:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        php: ['8.3', '8.5'] # 调整为你的当前版本 + 目标版本\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup PHP\n        uses: shivammathur/setup-php@v2\n        with:\n          php-version: ${{ matrix.php }}\n          tools: composer:v2\n          coverage: none\n      - name: Install dependencies\n        run: composer install --no-interaction --prefer-dist\n      - name: Run tests\n        run: vendor/bin/phpunit\n</code></pre>\n<h3 id=\"区分错误警告和弃用\">区分\"错误\"、\"警告\"和\"弃用\"</h3>\n<p>不要立刻把所有东西都当失败。先分类：</p>\n<ul>\n<li><strong>解析错误 / 致命错误</strong>：阻止升级。</li>\n<li><strong>行为变更</strong>：通常需要测试 + 代码修复。</li>\n<li><strong>弃用</strong>：不一定阻止升级，但它们预示未来会坏——而且可能很快淹没日志。</li>\n</ul>\n<p>PHPUnit 本身就区分 outcomes（failed/errored）和 issues（warnings、risky tests 等）。</p>\n<p>一个实用的升级策略：</p>\n<ul>\n<li>即使存在弃用，也让测试在 8.5 上通过，</li>\n<li>但加一个单独的 CI job 来统计弃用数量并强制执行预算（比如\"弃用不能超过 N 条\"）。</li>\n</ul>\n<p>这通常比一夜之间打开\"任何弃用都失败\"更现实。</p>\n<h2 id=\"弃用和行为变更像处理故障一样分类而非当重构\">弃用和行为变更：像处理故障一样分类，而非当重构</h2>\n<p>PHP 8.5 新增了一批弃用特性和几个可能让人意外的不兼容变更。官方迁移指南对此有详细说明。</p>\n<h3 id=\"一个有效的分类工作流\">一个有效的分类工作流</h3>\n<ol>\n<li>\n<p><strong>暴露</strong>：在 CI 和预发环境启用 E_ALL。</p>\n</li>\n<li>\n<p><strong>分组</strong>：按消息签名聚类（相同文件/行/消息）。</p>\n</li>\n<li>\n<p><strong>排序</strong>：按风险优先：</p>\n<ul>\n<li>安全相关，</li>\n<li>运行时正确性，</li>\n<li>日志量 / 运维噪音，</li>\n<li>未来破坏可能性。</li>\n</ul>\n</li>\n<li>\n<p><strong>修复</strong>：最小的安全变更。</p>\n</li>\n<li>\n<p><strong>防止回归</strong>：添加针对性测试或静态规则。</p>\n</li>\n</ol>\n<h3 id=\"到处都会冒出来的常见弃用\">到处都会冒出来的常见弃用</h3>\n<p>这些是让团队说\"等等，这以前居然允许？\"的问题：</p>\n<p><strong>非规范的类型转换名称已弃用</strong>：<code>(boolean)</code>、<code>(integer)</code>、<code>(double)</code>、<code>(binary)</code> → 用 <code>(bool)</code>、<code>(int)</code>、<code>(float)</code>、<code>(string)</code>。</p>\n<p>快速搜索：</p>\n<ul>\n<li>grep 搜 <code>\\(integer\\)</code> / <code>\\(boolean\\)</code> 等，</li>\n<li>应用 codemod（或 Rector——后面会讲）。</li>\n</ul>\n<p><strong>case 语句用分号结尾已弃用</strong>（用 <code>:</code>）。</p>\n<p>这常出现在\"一直能跑\"的老 switch 块里。</p>\n<p><strong>用 null 作为数组偏移（或在 array_key_exists 中）已弃用</strong>；PHP 建议用空字符串代替。</p>\n<p>这通常指向输入规范化 bug——修根本原因，不只是修警告。</p>\n<p><strong>递增非数字字符串已弃用</strong>；用 <code>str_increment()</code> 代替。</p>\n<p>如果你有代码用 <code>$s++</code> 做字母递增，会看到这个。</p>\n<p><strong>反引号操作符已弃用</strong>（它是 shell_exec 的别名）。</p>\n<p>即使你接受安全风险，也不想让弃用警告风暴淹没生产日志。</p>\n<p><strong><code>__sleep()</code> 和 <code>__wakeup()</code> 软弃用</strong>；优先用 <code>__serialize()</code> / <code>__unserialize()</code>（或在过渡期同时支持两者）。</p>\n<h3 id=\"运维相关的弃用扩展ini空操作函数\">运维相关的弃用（扩展、ini、\"空操作\"函数）</h3>\n<p>有些弃用是\"你不再需要这个了\"，但仍可能让你措手不及：</p>\n<ul>\n<li><code>curl_close()</code> 和 <code>curl_share_close()</code> 已弃用，因为句柄会自动释放。</li>\n<li><code>imagedestroy()</code> 已弃用，因为 GdImage 会自动释放。</li>\n<li><code>finfo_close()</code> 已弃用，因为 finfo 对象会自动释放。</li>\n<li><code>MHASH_*</code> 常量已弃用。</li>\n<li>PDO <code>\"uri:\"</code> DSN scheme 因安全原因已弃用。</li>\n</ul>\n<p>如果你运维大型应用，这些很重要，因为它们可能：</p>\n<ul>\n<li>日志爆炸（噪音），</li>\n<li>掩盖真正的错误，</li>\n<li>或指示值得审查的安全敏感行为（远程 URI 的 PDO DSN）。</li>\n</ul>\n<h3 id=\"值得尽早检查的不兼容变更\">值得尽早检查的不兼容变更</h3>\n<p>来自官方列表：</p>\n<ul>\n<li><code>class_alias()</code> 不能再用 \"array\" 或 \"callable\" 作为别名。</li>\n<li>对象到布尔的松散比较被统一为与 <code>(bool)$object</code> 行为一致。</li>\n<li>Trait 在父类之前绑定（微妙的行为变更）。</li>\n<li>某些 attribute 目标验证错误现在在编译期发生（有选项可以延迟）。</li>\n</ul>\n<p>你可能永远不会遇到这些。但如果遇到，你希望它们在 CI 立刻失败——而不是在生产环境。</p>\n<h2 id=\"composer-策略lock-文件平台要求和分阶段更新\">Composer 策略：lock 文件、平台要求和分阶段更新</h2>\n<p>依赖管理是升级出问题的地方。</p>\n<h3 id=\"理解-composer-在检查什么\">理解 Composer 在检查什么</h3>\n<p>Composer 把当前 PHP 版本建模为平台包（<code>php</code>），并据此检查你的依赖。</p>\n<p>所以你有两个相关的问题：</p>\n<ol>\n<li>\"我的依赖图能在 PHP 8.5 上解析吗？\"</li>\n<li>\"我的生产环境真的满足解析出的依赖图吗？\"</li>\n</ol>\n<h3 id=\"分阶段更新依赖不要一次性搞定\">分阶段更新依赖（不要\"一次性搞定\"）</h3>\n<p>一个实用的分阶段方法：</p>\n<p><strong>阶段 A：不改变运行时，解析依赖</strong></p>\n<ul>\n<li>在当前 PHP 版本上更新依赖（如果可能）。</li>\n<li>目标：减少同时出现的未知数。</li>\n</ul>\n<p><strong>阶段 B：假设在 PHP 8.5 上解析依赖</strong></p>\n<ul>\n<li>在 <code>composer.json</code> 中用 <code>config.platform.php</code> 模拟 PHP 8.5 进行依赖解析（临时的，在分支上）。</li>\n<li>然后可控地运行 <code>composer update</code>。</li>\n</ul>\n<p><strong>阶段 C：在真实 PHP 8.5 运行时上安装</strong></p>\n<ul>\n<li>在 CI/预发环境的真实 8.5 上运行完整测试套件。</li>\n</ul>\n<h3 id=\"正确使用-composer-的平台检查\">正确使用 Composer 的平台检查</h3>\n<ul>\n<li><code>platform-check</code> 控制在 Composer 的 autoloader bootstrap 中生成 <code>platform_check.php</code>。</li>\n<li><code>composer check-platform-reqs</code> 验证真实运行时是否匹配已安装包的要求。</li>\n</ul>\n<p>换句话说：</p>\n<ul>\n<li>用 <code>config.platform</code> 来模拟和解析。</li>\n<li>用 <code>check-platform-reqs</code> 来确保生产实际兼容。</li>\n</ul>\n<h3 id=\"升级期间会反复使用的安全更新命令\">升级期间会反复使用的安全更新命令</h3>\n<p>常见模式：</p>\n<pre><code class=\"language-bash\"># 保守地更新依赖\ncomposer update --no-interaction --with-all-dependencies\n\n# 严格按 lock 文件安装\ncomposer install --no-interaction --prefer-dist\n</code></pre>\n<p>如果需要追查一个有问题的包：</p>\n<ul>\n<li>显式更新它（加依赖），</li>\n<li>在 CI 的两个运行时上重新运行。</li>\n</ul>\n<p>避免把\"忽略平台要求\"当成解决方案。它能让你本地脱困，但不是迁移策略。</p>\n<h2 id=\"部署前添加可观测性这样你能证明升级是健康的\">部署前添加可观测性（这样你能证明升级是健康的）</h2>\n<p>如果不能度量，就会争论。</p>\n<h3 id=\"基线化健康的含义\">基线化\"健康\"的含义</h3>\n<p>在部署 PHP 8.5 之前，捕获：</p>\n<ul>\n<li>错误率（HTTP 5xx + 未捕获异常），</li>\n<li>慢请求率（p95/p99），</li>\n<li>内存使用趋势（FPM worker），</li>\n<li>队列延迟（如果你跑 worker），</li>\n<li>日志量（尤其是警告/弃用）。</li>\n</ul>\n<h3 id=\"临时增加日志信号但不要让日志变成垃圾场\">临时增加日志信号（但不要让日志变成垃圾场）</h3>\n<p>在升级窗口期间，加一个短期的\"升级视角\"是合理的：</p>\n<ul>\n<li>在进程启动时记录 PHP 版本（FPM/CLI worker），</li>\n<li>给错误打上运行时标签（旧版 vs 8.5），</li>\n<li>按端点/worker 类型统计弃用数量。</li>\n</ul>\n<p>在 PHP 中，你可以在前端控制器（或框架 bootstrap）里为预发环境添加一个最小的错误处理器：</p>\n<pre><code class=\"language-php\">set_error_handler(static function (int $severity, string $message, string $file, int $line): bool {\n    if (!(error_reporting() &amp; $severity)) {\n        return false;\n    }\n    // 示例：把弃用/警告路由到专用 logger channel\n    if ($severity === E_DEPRECATED || $severity === E_USER_DEPRECATED) {\n        error_log(\"[DEPRECATED] {$message} in {$file}:{$line}\");\n        return true; // 已处理\n    }\n    return false; // 让正常处理器运行\n});\n</code></pre>\n<p>保持临时性。目标是上线期间的清晰度，不是一个永久的自定义错误框架。</p>\n<h3 id=\"确保绕过处理器的警告不会让你措手不及\">确保\"绕过处理器的警告\"不会让你措手不及</h3>\n<p>PHP 8.5 弃用了在用户输出处理器内部产生输出的行为，并指出警告会绕过处理器以确保可见性。</p>\n<p>如果你做自定义输出缓冲的骚操作，在预发环境用真实流量模式测试它们。</p>\n<h2 id=\"上线策略金丝雀或蓝绿部署加上实际能用的回滚\">上线策略：金丝雀或蓝绿部署，加上实际能用的回滚</h2>\n<p>这是运维升级成败的关键。</p>\n<h3 id=\"金丝雀基础最小可行的安全上线\">金丝雀基础（最小可行的安全上线）</h3>\n<ol>\n<li>先把 PHP 8.5 部署到小比例的流量。</li>\n<li>对比错误率和延迟与基线。</li>\n<li>保持金丝雀足够长的时间以覆盖真实业务流程（不只是健康检查）。</li>\n</ol>\n<p>实现取决于你的技术栈：</p>\n<ul>\n<li>负载均衡器后面的两个 FPM pool，</li>\n<li>Kubernetes deployment 加权重路由，</li>\n<li>两个 ASG / 两个 service 加渐进流量切换。</li>\n</ul>\n<h3 id=\"蓝绿部署适合大爆炸式组织\">蓝绿部署适合\"大爆炸\"式组织</h3>\n<p>如果你的组织偏好硬切换：</p>\n<ul>\n<li>保持新旧环境都在线，</li>\n<li>切换流量，</li>\n<li>保持旧环境热备以便快速回滚。</li>\n</ul>\n<h3 id=\"回滚计划必须包含依赖和缓存\">回滚计划必须包含依赖和缓存</h3>\n<p>回滚不只是\"指回旧的 PHP 二进制\"。</p>\n<p>回滚现实性检查清单：</p>\n<ul>\n<li>保留之前的容器镜像（或包）。</li>\n<li>保留之前的 <code>composer.lock</code> 制品。</li>\n<li>知道切换运行时时 opcache/APCu 或框架缓存是否需要清理。</li>\n<li>确保数据库迁移是向后兼容的（或明确排除在升级范围外）。</li>\n</ul>\n<p>如果回滚需要三个人和一份 wiki 页面，在压力下它会失败。</p>\n<h2 id=\"升级后检查清单先验证正确性再验证性能然后清理\">升级后检查清单：先验证正确性，再验证性能，然后清理</h2>\n<p>一旦 PHP 8.5 开始服务真实流量，你的工作还没完。现在进入\"验证和稳定\"模式。</p>\n<h3 id=\"即时检查第一小时\">即时检查（第一小时）</h3>\n<ul>\n<li>扫描错误日志查找新的致命错误/异常。</li>\n<li>观察日志量是否突然增长（通常是弃用）。</li>\n<li>在生产主机上验证 <code>composer check-platform-reqs</code>。</li>\n<li>用合成检查验证核心流程（登录、结账、上传、定时任务端点）。</li>\n</ul>\n<h3 id=\"首日检查\">首日检查</h3>\n<ul>\n<li>对比 p95/p99 延迟与基线。</li>\n<li>检查内存使用：\n<ul>\n<li>FPM worker RSS 增长，</li>\n<li>worker 回收频率，</li>\n<li>队列 worker 内存泄漏。</li>\n</ul>\n</li>\n<li>验证后台任务：\n<ul>\n<li>worker 在新运行时上已重启，</li>\n<li>没有\"卡住\"的队列，</li>\n<li>没有静默失败。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"首周清理\">首周清理</h3>\n<ul>\n<li>移除你为上线视角添加的临时额外日志。</li>\n<li>把高频弃用转成跟踪的工单并逐步消灭。</li>\n<li>再次收紧 CI：\n<ul>\n<li>提高弃用的标准，</li>\n<li>确认稳定后从矩阵中移除旧 PHP 版本。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"关于-php-85-特性的快速兼容性说明不展开教程\">关于 PHP 8.5 特性的快速兼容性说明（不展开教程）</h2>\n<p>PHP 8.5 引入了新的语言和运行时特性，如管道操作符、URI 扩展、clone-with 等。</p>\n<p>升级期间不需要采用它们。但你应该：</p>\n<ul>\n<li>确保你的 linter/formatter 识别 PHP 8.5 语法，</li>\n<li>确保 CI 在 PHP 8.5 上运行后再合并任何 8.5 专属语法，</li>\n<li>把特性采用和运行时迁移分开（范围控制）。</li>\n</ul>\n<h2 id=\"结论把升级当部署来对待就会顺利\">结论：把升级当部署来对待，就会顺利</h2>\n<p>升级到 PHP 8.5 通常不是\"重写\"问题。是纪律问题：</p>\n<ul>\n<li>定义范围，</li>\n<li>审计真实平台，</li>\n<li>运行 CI 矩阵，</li>\n<li>系统地分类弃用和不兼容，</li>\n<li>有意识地管理依赖，</li>\n<li>上线前添加可观测性，</li>\n<li>带着策略和回滚路径部署，</li>\n<li>切换后验证和稳定。</li>\n</ul>\n<p>如果你遵循这个顺序，PHP 升级就不再可怕——它只是另一个常规的运维变更。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-14 07:43</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">10</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "LangChain、LangFlow、LangGraph：一文讲清三大 LLM 框架的定位与差异",
      "link": "https://www.cnblogs.com/jyzhao/p/19479470/langchainlangflowlanggraph-yi-wen-jiang-qing-san-d",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jyzhao/p/19479470/langchainlangflowlanggraph-yi-wen-jiang-qing-san-d\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 23:25\">\n    <span>LangChain、LangFlow、LangGraph：一文讲清三大 LLM 框架的定位与差异</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2026-01-13 23:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jyzhao\">AlfredZhao</a>&nbsp;\n阅读(<span id=\"post_view_count\">43</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>随着大模型（LLM）进入工程化落地阶段，<strong>“如何把模型变成真正可用的应用”</strong> 成了很多从业者绕不开的问题。<br />\n围绕这个目标，社区里逐渐形成了一批成熟的开源框架，其中被讨论最多的就是 <strong>LangChain、LangFlow、LangGraph</strong>。</p>\n<p>它们名字相似，但<strong>解决的问题并不相同</strong>。本文笔者将基于官方文档与开源实践，从<strong>定位、能力、使用场景和差异</strong>几个角度，帮你一次性理清。</p>\n<hr />\n<h2 id=\"01--langchainllm-应用的基础设施层\">01 | LangChain：LLM 应用的“基础设施层”</h2>\n<h3 id=\"-langchain-是什么\">① LangChain 是什么？</h3>\n<p>LangChain 是一个<strong>用于构建 LLM 应用的通用框架</strong>，核心目标只有一句话：</p>\n<blockquote>\n<p>把「大模型 + 外部工具 + 数据源 + Prompt」系统化地组织起来。</p>\n</blockquote>\n<p>它并不是一个“产品”，而是一套 <strong>开发范式和组件库</strong>。</p>\n<hr />\n<h3 id=\"-langchain-解决什么问题\">② LangChain 解决什么问题？</h3>\n<p>在没有 LangChain 之前，开发者通常需要自己处理：</p>\n<ul>\n<li>Prompt 拼接</li>\n<li>模型调用</li>\n<li>上下文管理</li>\n<li>工具调用（SQL、搜索、API）</li>\n<li>RAG（检索增强生成）</li>\n</ul>\n<p>LangChain 把这些抽象成了标准组件，例如：</p>\n<ul>\n<li>LLM / ChatModel</li>\n<li>PromptTemplate</li>\n<li>Chain</li>\n<li>Tool / Agent</li>\n<li>Memory</li>\n</ul>\n<hr />\n<h3 id=\"-典型应用场景\">③ 典型应用场景</h3>\n<ul>\n<li>RAG 问答系统</li>\n<li>NL2SQL</li>\n<li>AI 助手 / Copilot</li>\n<li>工具型 Agent</li>\n</ul>\n<p><strong>一句话总结</strong>：<br />\n<strong>LangChain = 写 LLM 应用的“后端开发框架”</strong></p>\n<hr />\n<h2 id=\"02--langflowlangchain-的可视化低代码入口\">02 | LangFlow：LangChain 的可视化“低代码入口”</h2>\n<h3 id=\"-langflow-是什么\">① LangFlow 是什么？</h3>\n<p>LangFlow 是一个 <strong>基于 LangChain 的可视化编排工具</strong>。</p>\n<p>你可以理解为：</p>\n<blockquote>\n<p>用“拖拽流程图”的方式来搭 LangChain 应用。</p>\n</blockquote>\n<p>它本质上是：</p>\n<ul>\n<li>前端可视化</li>\n<li>后端仍然运行 LangChain 逻辑</li>\n</ul>\n<hr />\n<h3 id=\"-langflow-的核心价值\">② LangFlow 的核心价值</h3>\n<p>LangFlow 并没有引入新的模型能力，它的优势在于：</p>\n<ul>\n<li><strong>降低学习门槛</strong></li>\n<li>快速原型验证</li>\n<li>Prompt / Chain 可视化调试</li>\n</ul>\n<p>对不熟悉 Python 或刚接触 LLM 的人非常友好。</p>\n<hr />\n<h3 id=\"-典型应用场景-1\">③ 典型应用场景</h3>\n<ul>\n<li>产品经理 / 咨询顾问做 Demo</li>\n<li>Prompt 调优与流程验证</li>\n<li>教学与分享演示</li>\n<li>小型 PoC 项目</li>\n</ul>\n<p><strong>一句话总结</strong>：<br />\n<strong>LangFlow = LangChain 的“可视化操作台”</strong></p>\n<hr />\n<h2 id=\"03--langgraph为复杂-agent-而生的状态机框架\">03 | LangGraph：为复杂 Agent 而生的“状态机框架”</h2>\n<h3 id=\"-langgraph-是什么\">① LangGraph 是什么？</h3>\n<p>LangGraph 是 LangChain 官方推出的一个<strong>新框架</strong>，专门解决一个问题：</p>\n<blockquote>\n<p>当 Agent 逻辑变复杂，Chain 已经不够用了，怎么办？</p>\n</blockquote>\n<p>LangGraph 引入的是：</p>\n<ul>\n<li><strong>Graph（图）</strong></li>\n<li><strong>State（状态）</strong></li>\n<li><strong>节点 + 边 + 循环</strong></li>\n</ul>\n<p>本质上是：<br />\n<strong>把 LLM Agent 当成一个“有状态的工作流/状态机”来建模</strong>。</p>\n<hr />\n<h3 id=\"-langgraph-为什么出现\">② LangGraph 为什么出现？</h3>\n<p>在真实项目中，Agent 往往需要：</p>\n<ul>\n<li>多轮决策</li>\n<li>条件分支</li>\n<li>回退 / 重试</li>\n<li>人工介入（Human-in-the-loop）</li>\n</ul>\n<p>这些用传统 Chain 非常别扭，而 LangGraph 天然支持：</p>\n<ul>\n<li>循环</li>\n<li>分支</li>\n<li>并行</li>\n<li>可恢复执行</li>\n</ul>\n<hr />\n<h3 id=\"-典型应用场景-2\">③ 典型应用场景</h3>\n<ul>\n<li>多 Agent 协作系统</li>\n<li>复杂业务流程自动化</li>\n<li>长任务 AI 助手</li>\n<li>需要“可控行为”的智能体</li>\n</ul>\n<p><strong>一句话总结</strong>：<br />\n<strong>LangGraph = 面向复杂 Agent 的“流程与状态控制层”</strong></p>\n<hr />\n<h2 id=\"04--三者核心差异一图读懂\">04 | 三者核心差异一图读懂</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>LangChain</th>\n<th>LangFlow</th>\n<th>LangGraph</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>核心定位</td>\n<td>LLM 应用框架</td>\n<td>可视化编排工具</td>\n<td>Agent 状态机框架</td>\n</tr>\n<tr>\n<td>抽象模型</td>\n<td>Chain / Agent</td>\n<td>Flow</td>\n<td>Graph / State</td>\n</tr>\n<tr>\n<td>使用方式</td>\n<td>写代码</td>\n<td>拖流程</td>\n<td>写图结构代码</td>\n</tr>\n<tr>\n<td>适合人群</td>\n<td>工程师</td>\n<td>初学者 / 产品</td>\n<td>高级工程师</td>\n</tr>\n<tr>\n<td>复杂逻辑</td>\n<td>一般</td>\n<td>一般</td>\n<td>非常强</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"05--应该如何选择\">05 | 应该如何选择？</h2>\n<p>笔者给你一个<strong>不踩坑的选择建议</strong>：</p>\n<ul>\n<li><strong>想系统做 LLM 应用</strong> → 先学 <strong>LangChain</strong></li>\n<li><strong>想快速出 Demo / 学概念</strong> → 用 <strong>LangFlow</strong></li>\n<li><strong>Agent 逻辑开始变复杂</strong> → 上 <strong>LangGraph</strong></li>\n</ul>\n<p>现实项目中，<strong>三者是可以组合使用的</strong>：</p>\n<blockquote>\n<p>LangFlow 画流程 → LangChain 落代码 → LangGraph 控复杂控制</p>\n</blockquote>\n<hr />\n<h2 id=\"06--写在最后\">06 | 写在最后</h2>\n<p>LangChain 生态的演进，本质上反映了一件事：</p>\n<blockquote>\n<p>LLM 应用，正在从“Prompt 工程”，走向真正的软件工程。</p>\n</blockquote>\n<p>理解这三者的边界，比死记 API 更重要。<br />\n如果你正在做 <strong>RAG、NL2SQL、AI Agent</strong>，这套认知几乎是绕不开的基础。</p>\n<p>希望这篇文章，能帮你少走一些弯路。</p>\n\n</div>\n<div id=\"MySignature\">\n    <a href=\"https://www.cnblogs.com/jyzhao/\" target=\"_blank\">AlfredZhao</a>©版权所有「从Oracle起航，领略精彩的IT技术。」<br />\n转载请注明原文链接：<a href=\"https://www.cnblogs.com/jyzhao/p/19479470/langchainlangflowlanggraph-yi-wen-jiang-qing-san-d\" target=\"_blank\">https://www.cnblogs.com/jyzhao/p/19479470/langchainlangflowlanggraph-yi-wen-jiang-qing-san-d</a>\n<hr />\n<div style=\"text-align: center; margin-top: 30px;\">\n  <p style=\"font-size: 14px; color: #555;\">\n    👋 感谢阅读，欢迎关注我的公众号 <b>「赵靖宇」</b>\n  </p>\n  <img src=\"https://images.cnblogs.com/cnblogs_com/jyzhao/824234/o_250208075013_qrcode-zjy.jpg\" style=\"border: 1px solid #ddd; border-radius: 8px;\" width=\"160\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "浅聊算法竞赛中维护中位数的小技巧",
      "link": "https://www.cnblogs.com/GroundhogKing/p/19479345",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GroundhogKing/p/19479345\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 23:13\">\n    <span>浅聊算法竞赛中维护中位数的小技巧</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>首先来看暑假杭电多校的一道题目：</p>\n<hr />\n<p>对于一个长度为 <span class=\"math inline\">\\(L\\)</span>(<span class=\"math inline\">\\(L\\)</span>为奇数) 的数组 <span class=\"math inline\">\\(a\\)</span>，定义它的中位数 <span class=\"math inline\">\\(median(a)\\)</span> 为 <span class=\"math inline\">\\(a\\)</span> 中第 <span class=\"math inline\">\\(\\frac{L+1}{2}\\)</span> 大的数。现在给你一个长度为 <span class=\"math inline\">\\(n\\)</span> 的排列，对于每对满足 <span class=\"math inline\">\\(1\\leq i \\leq j \\leq n\\)</span> 且 <span class=\"math inline\">\\(j-i \\equiv 0 (mod 2)\\)</span> 的 <span class=\"math inline\">\\((i,j)\\)</span>，你需要计算 <span class=\"math inline\">\\(i*j*median(p[i,j])\\)</span>。输出所有值的和。</p>\n<p>多测数 <span class=\"math inline\">\\(T \\leq 20\\)</span>，排列长度 <span class=\"math inline\">\\(n \\leq 2000\\)</span>。</p>\n<hr />\n<p>对于这道题，首先想到的是枚举所有 <span class=\"math inline\">\\([i,j]\\)</span>，通过数据结构(对顶堆等)维护中位数。由于这些方法都带log，并且本题多测数据不保证 <span class=\"math inline\">\\(n\\)</span> 的总和。因此复杂度 <span class=\"math inline\">\\(O(n^2lognT)\\)</span>，无法通过本题。</p>\n<p>换个思路，枚举区间不行，就计算每个位置的贡献。想想一个位置能成为一个区间的中位数，需要满足什么条件？该区间中大于它和小于它的数的数量相等。</p>\n<p>一个很经典的处理就是，将小于 <span class=\"math inline\">\\(x\\)</span> 的数赋-1，将大于 <span class=\"math inline\">\\(x\\)</span> 的数赋1，我们对这个数组做前缀和，记作 <span class=\"math inline\">\\(pre\\)</span>。于是问题就转换为，在 <span class=\"math inline\">\\(x\\)</span> 的左边找到 <span class=\"math inline\">\\(pre_i\\)</span>，在 <span class=\"math inline\">\\(x\\)</span> 的右边找到 <span class=\"math inline\">\\(pre_j\\)</span>，使得 <span class=\"math inline\">\\(pre_i = pre_j\\)</span>。那么 <span class=\"math inline\">\\(pre_j - pre_i = 0\\)</span>，这就意味着，区间 <span class=\"math inline\">\\([l+1,r]\\)</span> 中大于 <span class=\"math inline\">\\(x\\)</span> 和小于 <span class=\"math inline\">\\(x\\)</span> 的数的数量相等。</p>\n<p>对于每个数处理一次这样的前缀和数组是 <span class=\"math inline\">\\(O(n)\\)</span> 的，因此可以在 <span class=\"math inline\">\\(O(n^2T)\\)</span> 的时间下通过本题。</p>\n<p><strong>Code:</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nusing ll = long long;\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n+10);\n    for (int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n\n    ll ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) //枚举中位数\n    {\n        vector&lt;int&gt; pre(n+10);\n        vector&lt;int&gt; t(2*n+10); //桶,因为会出现负数，要带n的偏移\n        t[n]++;\n        for (int j = 1 ; j &lt;= n ; j++)\n        {\n            pre[j] = pre[j-1];\n            if (a[j] &gt; a[i]) pre[j]++;\n            else if (a[j] &lt; a[i]) pre[j]--;\n\n            if (j &lt; i) t[pre[j]+n] += j + 1;\n            else ans += (ll)a[i] * t[pre[j]+n] * j;\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int T;\n    cin &gt;&gt; T;\n    while (T--) solve();\n\n    return 0;\n}\n</code></pre>\n<p>基于本题，可以归纳一个维护中位数的小技巧：通过给大于 <span class=\"math inline\">\\(x\\)</span> 和 小于 <span class=\"math inline\">\\(x\\)</span> 的数分别赋值，并求前缀和，就可以把求中位数问题，转化成维护前缀和之差为0。</p>\n<p>以下再做个拓展：序列 <span class=\"math inline\">\\(a\\)</span> 的中位数 <span class=\"math inline\">\\(median(a) \\ge v\\)</span>，当且仅当 <span class=\"math inline\">\\(a\\)</span> 中 <span class=\"math inline\">\\(cnt_{a_i \\geq v} \\geq cnt_{a_i &lt; v}\\)</span>（式中是否取等号取决于题目怎么定义中位数）。也就是说，<span class=\"math inline\">\\(median(a) \\geq v\\)</span> 的充要条件是 <span class=\"math inline\">\\(a\\)</span> 中 <span class=\"math inline\">\\(\\geq v\\)</span> 的数的数量多于或等于 <span class=\"math inline\">\\(&lt; v\\)</span> 的数的数量。这个式子比较好理解，这里不做证明。</p>\n<p>这个式子给我们提供了一种二分的思路。</p>\n<p>看下面这道题<a href=\"https://codeforces.com/contest/2128/problem/E1\" rel=\"noopener nofollow\" target=\"_blank\">Submedians (Easy Version)</a>：</p>\n<hr />\n<p>对于长度为 <span class=\"math inline\">\\(m\\)</span> 的数组 <span class=\"math inline\">\\(b\\)</span>，整数 <span class=\"math inline\">\\(v\\)</span> 是 <span class=\"math inline\">\\(b\\)</span> 的中位数，当且仅当：</p>\n<ul>\n<li><span class=\"math inline\">\\(v\\)</span> 至少大于等于数组中 <span class=\"math inline\">\\(\\lceil \\frac{m}{2} \\rceil\\)</span> 个元素，并且</li>\n<li><span class=\"math inline\">\\(v\\)</span> 至少小于等于数组中 <span class=\"math inline\">\\(\\lceil \\frac{m}{2} \\rceil\\)</span> 个元素。</li>\n</ul>\n<p>现在给定一个整数 <span class=\"math inline\">\\(k\\)</span> 和一个由 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 之间的整数构成的数组 <span class=\"math inline\">\\(a_1, \\ldots, a_n\\)</span>。</p>\n<p>如果存在至少一对下标 <span class=\"math inline\">\\((l, r)\\)</span> 满足：</p>\n<ul>\n<li><span class=\"math inline\">\\(1 \\leq l \\leq r \\leq n\\)</span>，</li>\n<li><span class=\"math inline\">\\(r - l + 1 \\geq k\\)</span>，</li>\n<li><span class=\"math inline\">\\(v\\)</span> 是子数组 <span class=\"math inline\">\\([a_l, \\ldots, a_r]\\)</span> 的中位数，</li>\n</ul>\n<p>则称 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 之间的整数 <span class=\"math inline\">\\(v\\)</span> 是一个子中位数。</p>\n<p>可以证明，至少存在一个子中位数。请你找出最大的子中位数 <span class=\"math inline\">\\(v_{\\max}\\)</span>，以及任意一组对应的下标对 <span class=\"math inline\">\\((l, r)\\)</span>。</p>\n<hr />\n<p>考虑二分：当 <span class=\"math inline\">\\(v\\)</span> 越大，<span class=\"math inline\">\\(cnt_{a_i\\geq v}\\)</span> 越少，反之 <span class=\"math inline\">\\(cnt_{a_i &lt; v}\\)</span> 越大，因此越大的数越不可能作为中位数。</p>\n<p>同样将 <span class=\"math inline\">\\(\\geq v\\)</span> 的数赋1，<span class=\"math inline\">\\(&lt; v\\)</span> 的数赋-1，做前缀和维护即可。</p>\n<p><strong>Code:</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid solve()\n{\n    int n,k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;int&gt; a(n+10);\n    for (int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n\n    int ansl, ansr;\n    auto check = [&amp;](int mid)\n    {\n        vector&lt;int&gt; sum(n+10);\n        for (int i = 1 ; i &lt;= n ; i++)\n        {\n            sum[i] = sum[i-1];\n            if (a[i] &gt;= mid) sum[i]++;\n            else sum[i]--;\n        }\n\n        int minn = 2e9;\n        int l;\n        for (int i = k ; i &lt;= n ; i++)\n        {\n            if (sum[i-k] &lt; minn)\n            {\n                minn = sum[i-k];\n                l = i - k + 1;\n            }\n            if (sum[i]-minn &gt;= 0)\n            {\n                ansl = l;\n                ansr = i;\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    int l = 0;\n    int r = n + 1;\n    while (l+1 != r)\n    {\n        int mid = (l+r) &gt;&gt; 1;\n        if (check(mid)) l = mid;\n        else r = mid;\n    }\n\n    check(l);\n    cout &lt;&lt; l &lt;&lt; \" \" &lt;&lt; ansl &lt;&lt; \" \" &lt;&lt; ansr &lt;&lt; endl;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int T;\n    cin &gt;&gt; T;\n    while (T--) solve();\n\n    return 0;\n}\n</code></pre>\n<p>一道与上题几乎一样的题目<a href=\"https://codeforces.com/contest/1486/problem/D\" rel=\"noopener nofollow\" target=\"_blank\">Max Median</a>：</p>\n<p>题目很短，这里不做题意概述。需要注意的是，由于本题定义中位数为第 <span class=\"math inline\">\\(\\lfloor \\frac{L+1}{2} \\rfloor\\)</span> 大的数，因此本题 <span class=\"math inline\">\\(median(a) \\geq v\\)</span> 的条件为：<span class=\"math inline\">\\(cnt_{a_i \\geq v} &gt; cnt_{a_i &lt; v}\\)</span>。</p>\n<p><strong>Code:</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid solve()\n{\n    int n,k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;int&gt; a(n+10);\n    for (int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i];\n\n    int ansl, ansr;\n    auto check = [&amp;](int mid)\n    {\n        vector&lt;int&gt; sum(n+10);\n        for (int i = 1 ; i &lt;= n ; i++)\n        {\n            sum[i] = sum[i-1];\n            if (a[i] &gt;= mid) sum[i]++;\n            else sum[i]--;\n        }\n\n        int minn = 2e9;\n        int l;\n        for (int i = k ; i &lt;= n ; i++)\n        {\n            if (sum[i-k] &lt; minn)\n            {\n                minn = sum[i-k];\n                l = i - k + 1;\n            }\n            if (sum[i]-minn &gt; 0)\n            {\n                ansl = l;\n                ansr = i;\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    int l = 0;\n    int r = n + 1;\n    while (l+1 != r)\n    {\n        int mid = (l+r) &gt;&gt; 1;\n        if (check(mid)) l = mid;\n        else r = mid;\n    }\n\n    check(l);\n    cout &lt;&lt; l &lt;&lt; endl;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int T = 1;\n    while (T--) solve();\n\n    return 0;\n}\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 23:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GroundhogKing\">GroundhogKing</a>&nbsp;\n阅读(<span id=\"post_view_count\">1</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "当条形图遇上极坐标：径向与圆形条形图的视觉革命",
      "link": "https://www.cnblogs.com/wang_yb/p/19479454",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19479454\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 23:10\">\n    <span>当条形图遇上极坐标：径向与圆形条形图的视觉革命</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>想象一下，你正站在一个圆形广场的中心，周围均匀排列着12根高度不同的灯柱，这就是<strong>径向条形图</strong>带给我们的视觉体验。</p>\n<p>在数据可视化领域，我们常常满足于传统的直角坐标系条形图，但当数据具有周期性或比较性时，<strong>径向条形图</strong>和<strong>圆形条形图</strong>为我们打开了新的可能性。</p>\n<h1 id=\"1-设计原理\">1. 设计原理</h1>\n<p>这两种图表把传统的<strong>笛卡尔坐标系</strong>换成<strong>极坐标系</strong>：角度表示类别，半径或角度长度表示数值。</p>\n<h2 id=\"11-径向条形图\">1.1. 径向条形图</h2>\n<p><strong>径向条形图</strong>本质上是将传统条形图的直角坐标系转换为极坐标系。</p>\n<p>在极坐标系中，每个数据点不再由<code>(x, y)</code>定位，而是由<strong>(角度, 半径)</strong>确定，条形的高度（或长度）由半径值表示，而条形的排列则沿着圆周方向。</p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260113230907077-321355021.png\" /></p>\n<p><strong>设计灵感</strong>：如同钟表的指针或雷达的扫描线，径向条形图借鉴了自然界和人工制品中常见的圆形布局，利用了人类对角度和对称性的天然感知能力。</p>\n<h2 id=\"12-圆形条形图\">1.2. 圆形条形图</h2>\n<p><strong>圆形条形图</strong>是径向条形图的一种特殊形式，它固定了起点和终点，使所有条形都在同一圆周上开始，只在半径方向上延伸。</p>\n<p>这种设计解决了完全径向布局可能导致的<strong>数据比较困难</strong>问题，因为所有条形的基准线是一致的。</p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260113230907250-2040360098.png\" /></p>\n<p><strong>设计比喻</strong>：想象一组跳高运动员，他们都从同一高度起跳，只是跳跃的高度不同——圆形条形图就是这样公平的\"竞技场\"。</p>\n<h1 id=\"2-应用示例\">2. 应用示例</h1>\n<p>下面通过示例来演示这两种图在实际场景中的应用。</p>\n<h2 id=\"21-径向条形图\">2.1. 径向条形图</h2>\n<pre><code class=\"language-python\"># --- 1. 构造测试数据 ---\n# 假设我们想比较一年中每个月的平均降水量\n月份 = [\n    \"一月\",\n    \"二月\",\n    \"三月\",\n    \"四月\",\n    \"五月\",\n    \"六月\",\n    \"七月\",\n    \"八月\",\n    \"九月\",\n    \"十月\",\n    \"十一月\",\n    \"十二月\",\n]\n# 生成模拟的降水量数据 (单位: mm)\nnp.random.seed(42)  # 为了结果可复现\n降水量 = np.random.uniform(30, 150, size=len(月份))  # 随机生成30-150mm的数据\n\n# --- 2. 创建图形 ---\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 7), facecolor=\"white\")\n\n# --- 2.1 绘制传统条形图 ---\n# ... 省略 ...\n\n# --- 2.2 绘制径向条形图 ---\n# 计算每个条形的角度位置\n# ... 省略 ...\n\n# 使用极坐标子图\nax2 = plt.subplot(122, projection=\"polar\")\n# 关键：设置 'bottom' 参数为 inner_radius，这样条形就从 inner_radius 开始画，长度为 radii\nbars = ax2.bar(\n    theta,\n    radii,\n    width=0.4,\n    bottom=inner_radius,\n    color=\"lightcoral\",\n    edgecolor=\"darkred\",\n    alpha=0.7,\n)\n\n# 添加数值标签 (在条形内部，靠近外侧)\nfor angle, radius, month in zip(theta, radii, 月份):\n    ax2.text(\n        angle,\n        inner_radius + radius / 2,\n        f\"{radius:.1f}\",\n        ha=\"center\",\n        va=\"center\",\n        fontsize=8,\n        color=\"black\",\n    )\n\n# 添加月份标记 (在条形外部)\n# ... 省略 ...\n\n# --- 3. 显示图形 ---\nplt.tight_layout()\nplt.show()\n</code></pre>\n<p>这段代码首先生成了模拟的月度降水量数据，然后在同一个图形窗口中创建了两个子图。</p>\n<p>左侧是使用 <code>plt.bar</code> 创建的传统条形图，右侧是使用 <code>plt.subplot(..., projection='polar')</code> 和 <code>ax.bar</code> 创建的径向条形图。</p>\n<p><strong>径向条形图</strong>利用了极坐标系，将类别（月份）分布在圆周上，将数值（降水量）映射到径向长度上。</p>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260113230907232-60855079.png\" /></p>\n<p><strong>径向条形图</strong>是一种在极坐标系上绘制的图表，可以提供比传统条形图更具视觉吸引力的替代方案。它通过弧长来表示数值，并且可以有效地利用空间，尤其是在处理类别较多或需要强调周期性模式（例如按月份或季度分组的数据）时。</p>\n<h2 id=\"22-圆形条形图\">2.2. 圆形条形图</h2>\n<pre><code class=\"language-python\">from matplotlib import cm\nfrom math import log10\n\nlabels = list(\"ABCDEFG\")\ndata = [21, 57, 88, 14, 76, 91, 26]\n# ... 省略 ...\n\n#create colors along a chosen colormap\ncolors = [cm.terrain(i / n) for i in range(n)]\n\n#create figure, axis\nfig, ax = plt.subplots()\n\n#create rings of donut chart\nfor i in range(n):\n    current_outer_radius = r - i * w\n    innerring, _ = ax.pie([m - data[i], data[i]], \n                          radius = current_outer_radius, \n                          startangle = 90, \n                          colors = [\"white\", colors[i]])\n\n    # 添加标签\n    # ... 省略 ...\n\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260113230907034-1742470964.png\" /></p>\n<p><strong>圆形条形图</strong>从同一基准线开始，避免了<strong>径向条形图</strong>中不同角度起始点不同的问题，更加便于比较。</p>\n<h1 id=\"3-总结\">3. 总结</h1>\n<p><strong>径向条形图</strong>和<strong>圆形条形图</strong>代表了数据可视化从纯功能向功能美学平衡的演进。</p>\n<p>它们不是要完全取代传统条形图，而是为我们提供了更多视觉叙事的工具。</p>\n<p>就像一位熟练的厨师拥有多种刀具一样，优秀的数据分析师也应该掌握多种可视化技术，根据数据特性和沟通目标选择最合适的\"刀具\"。</p>\n<p>当你的数据讲述着周期性的故事，或需要在有限空间内进行多维度比较时，不妨尝试这些圆形可视化方法。它们不仅能更有效地传达信息，还能为你的报告或仪表板增添独特的视觉魅力。</p>\n<p>最好的可视化不是最复杂的，而是最能清晰传达数据故事的。</p>\n<p><strong>径向</strong>和<strong>圆形条形图</strong>正是这样一种工具：在传统与现代之间，在功能与美学之间，找到了优雅的平衡点。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 23:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Spring 的西西弗斯之石：理解 BeanFactory、FactoryBean 与 ObjectFactory",
      "link": "https://www.cnblogs.com/xzqcsj/p/19479429",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xzqcsj/p/19479429\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 22:46\">\n    <span>Spring 的西西弗斯之石：理解 BeanFactory、FactoryBean 与 ObjectFactory</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Spring 的西西弗斯之石：理解 BeanFactory、FactoryBean 与 ObjectFactory\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3703499/202601/3703499-20260113224556329-1020363253.png\" />\n        今天，代码又报错了。或者也许是昨天，我不清楚。\n不管怎样，Spring 容器抛出了一个 BeanCreationException。为了解决它，我被迫潜入框架的深处，去注视那些平时被 @Autowired 掩盖的齿轮。\n在 Spring 的世界里，存在着一种必然的复杂性。这种复杂性并非设计者的恶趣味，而是为了在一个静态的语言中构建动态世界所付出的代价。\n在这个庞大的机器中，有三个名字极其相似的概念经常被混淆：BeanFactory、FactoryBean 和 ObjectFactory。这并不是命名的贫瘠，而是它们在本质上确实存在着微妙的纠缠。\n今天，我们剥离掉那些花哨的比喻和无用的糖衣，用一种冷静的、近乎解剖学的视角，去审视这三个概念的本质。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>今天，代码又报错了。或者也许是昨天，我不清楚。<br />\n不管怎样，Spring 容器抛出了一个 <code>BeanCreationException</code>。为了解决它，我被迫潜入框架的深处，去注视那些平时被 <code>@Autowired</code> 掩盖的齿轮。</p>\n<p>在 Spring 的世界里，存在着一种必然的复杂性。这种复杂性并非设计者的恶趣味，而是为了在一个静态的语言中构建动态世界所付出的代价。</p>\n<p>在这个庞大的机器中，有三个名字极其相似的概念经常被混淆：<code>BeanFactory</code>、<code>FactoryBean</code> 和 <code>ObjectFactory</code>。这并不是命名的贫瘠，而是它们在本质上确实存在着微妙的纠缠。</p>\n<p>今天，我们剥离掉那些花哨的比喻和无用的糖衣，用一种冷静的、近乎解剖学的视角，去审视这三个概念的本质。</p>\n<hr />\n<h2 id=\"一beanfactory存在的容器\">一、BeanFactory：存在的容器</h2>\n<p><strong>让我们首先纠正一个观念：BeanFactory 名为工厂，但其本质是容器（Container）。</strong></p>\n<p>当我们谈论 Spring 容器时，我们实际上是在谈论 <code>BeanFactory</code>。它是 Spring IoC 容器的根接口，是整个世界的物理法则。</p>\n<h3 id=\"11-唯一的职责\">1.1 唯一的职责</h3>\n<p>它的定义极其克制。它不关心业务逻辑，只关心一件事：<strong>管理对象的生命周期</strong>。</p>\n<pre><code class=\"language-java\">public interface BeanFactory {\n    Object getBean(String name) throws BeansException;\n    &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType);\n    boolean containsBean(String name);\n    // ...\n}\n</code></pre>\n<p>当你启动一个 Spring Boot 应用时，<code>ApplicationContext</code> 就像一个充满活力的城市，而 <code>BeanFactory</code> 则是支撑这座城市的地下管网。所有的 BeanDefinition（关于 Bean 应该如何创建的蓝图）都注册在这里。</p>\n<h3 id=\"12-残酷的现实\">1.2 残酷的现实</h3>\n<p>在大多数情况下，你不需要直接与 <code>BeanFactory</code> 对话。因为 <code>ApplicationContext</code> 已经为你封装好了一切。<br />\n但当你试图理解为什么你的 Bean 没有被正确初始化，或者为什么你的循环依赖失效时，你就必须意识到：<strong>你所有的 Bean，都只是 <code>BeanFactory</code> 中的 entries（条目）。</strong></p>\n<p>它是一个巨大的 <code>Map&lt;String, BeanDefinition&gt;</code> 和 <code>Map&lt;String, Object&gt;</code> 的管理者。它冷酷无情，只按照定义的规则（Scope, Lazy, Dependence）来实例化对象。</p>\n<hr />\n<h2 id=\"二factorybean必要的欺骗\">二、FactoryBean：必要的欺骗</h2>\n<p>如果说 <code>BeanFactory</code> 是宏观规则的制定者，那么 <code>FactoryBean</code> 就是微观规则的<strong>潜行者</strong>。</p>\n<h3 id=\"21-静态语言的困境\">2.1 静态语言的困境</h3>\n<p>想象这样一个场景：<strong>你需要注入一个接口的实现，但这个实现类并不存在于代码中，它是通过动态代理在运行时生成的。</strong><br />\n这在 RPC 框架（如 Dubbo、Feign）和 ORM 框架（如 MyBatis）中极其常见。</p>\n<p>你无法通过简单的 <code>&lt;bean class=\"...\"&gt;</code> 或 <code>@Component</code> 来描述一个“不存在的类”。<br />\n这时候，你需要一个中间人。这个中间人表面上是一个普通的 Bean，但实际上，它是一个工厂。</p>\n<h3 id=\"22-伪装的艺术以-mybatis-为例\">2.2 伪装的艺术：以 MyBatis 为例</h3>\n<p>为什么你只需要写一个 <code>UserMapper</code> 接口，就能直接 <code>@Autowired</code> 使用？<br />\n因为 Spring 容器里注册的那个 \"userMapper\" Bean，根本不是你的接口实现，而是一个 <code>MapperFactoryBean</code>。</p>\n<pre><code class=\"language-java\">// 简化的逻辑示意\npublic class MapperFactoryBean&lt;T&gt; implements FactoryBean&lt;T&gt; {\n    \n    private Class&lt;T&gt; mapperInterface;\n\n    @Override\n    public T getObject() throws Exception {\n        // 往里跟进，最终这里发生了魔法：通过 JDK 动态代理生成接口的实\n        return (T) Proxy.newProxyInstance(\n            mapperInterface.getClassLoader(), \n            new Class[] { mapperInterface }, \n            new MapperProxy&lt;&gt;()\n        );\n    }\n\n    @Override\n    public Class&lt;?&gt; getObjectType() {\n        return mapperInterface;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n}\n</code></pre>\n<h3 id=\"23-这里的真相\">2.3 这里的真相</h3>\n<p>当容器调用 <code>getBean(\"userMapper\")</code> 时，它发现这是一个 <code>FactoryBean</code>。于是，它不会返回 <code>FactoryBean</code> 实例本身，而是默默地调用 <code>getObject()</code>，并返回那个代理对象。</p>\n<p>这就是欺骗。<strong>你以为你拿到了一个 Bean，其实你拿到的是 Bean 生产的产品。</strong></p>\n<p>如果你渴望看到真相，看到那个操纵傀儡的幕后黑手，你需要在 Bean 名称前加上 <code>&amp;</code>：</p>\n<pre><code class=\"language-java\">// 获取的是 MapperProxy 代理对象\nObject product = context.getBean(\"userMapper\"); \n\n// 获取的是 FactoryBean 工厂本身\nObject factory = context.getBean(\"&amp;userMapper\");\n</code></pre>\n<hr />\n<h2 id=\"三objectfactory时间的延迟\">三、ObjectFactory：时间的延迟</h2>\n<p><code>BeanFactory</code> 负责掌控空间（容器），<code>FactoryBean</code> 负责掌控构造（逻辑），而 <code>ObjectFactory</code> 则是为了掌控<strong>时间</strong>。</p>\n<h3 id=\"31-循环的死结\">3.1 循环的死结</h3>\n<p>在 Spring 的世界里，有一个经典的荒谬：A 需要 B，B 需要 A。<br />\n如果是构造器注入，只需坦然承认失败。但如果是 Setter 注入，Spring 试图挽救这种死结。</p>\n<p>在 A 创建的过程中，需要注入 B。B 创建时，又需要注入 A。<br />\n此时 A 还在创建中，尚不是一个完整的 Bean。怎么办？<br />\nSpring 引入了三级缓存的概念。而第三级缓存，存放的就是一个 <code>ObjectFactory</code>。</p>\n<h3 id=\"32-回调的本质\">3.2 回调的本质</h3>\n<p><code>ObjectFactory</code> 在源码中简单得令人发指：</p>\n<pre><code class=\"language-java\">@FunctionalInterface\npublic interface ObjectFactory&lt;T&gt; {\n    T getObject() throws BeansException;\n}\n</code></pre>\n<p>它只是一个<strong>函数式接口</strong>，一个回调。<br />\n它存在的意义在于：<strong>我现在不想要这个对象，但我想要一个“在未来某个时刻能获取这个对象”的能力。</strong></p>\n<p>在循环依赖中，Spring 提前暴露了一个 <code>ObjectFactory</code>：</p>\n<pre><code class=\"language-java\">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n</code></pre>\n<p>当 B 需要 A 时，它通过这个 <code>ObjectFactory</code> 拿到了 A 的早期引用（Early Reference）。尽管 A 还没完全初始化好，但 B 已经可以持有它的引用了。死结解开了。</p>\n<h3 id=\"33-作用域的错位\">3.3 作用域的错位</h3>\n<p>另一个场景是：一个单例（Singleton）的 Service 需要使用一个 原型（Prototype）的 Bean。<br />\n如果你直接 <code>@Autowired</code>，原型的 Bean 只有在 Service 创建时被注入一次，之后也就是永远同一个对象了。这违背了原型的初衷。</p>\n<p>如何解决？使用 <code>ObjectFactory</code> 延迟获取。</p>\n<pre><code class=\"language-java\">@Service\npublic class ReportService {\n    \n    @Autowired\n    private ObjectFactory&lt;ReportBuilder&gt; builderFactory;\n\n    public void generate() {\n        // 每次调用 getObject()，容器都会创建一个全新的 ReportBuilder\n        ReportBuilder builder = builderFactory.getObject();\n        builder.build();\n    }\n}\n</code></pre>\n<p>在这里，<strong><code>ObjectFactory</code> 就像是一个通往容器的句柄，让你随时可以伸手进去拿一个新的对象，而不是守着陈旧的缓存。</strong></p>\n<hr />\n<h2 id=\"四审判与裁决\">四、审判与裁决</h2>\n<p>让我们在最后，用最客观的表格来审判这三者的区别。这不是为了背诵，而是为了理清混乱。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">维度</th>\n<th style=\"text-align: left;\">BeanFactory</th>\n<th style=\"text-align: left;\">FactoryBean</th>\n<th style=\"text-align: left;\">ObjectFactory</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>存在形式</strong></td>\n<td style=\"text-align: left;\"><strong>容器</strong> (Container)</td>\n<td style=\"text-align: left;\"><strong>Bean</strong> (Component)</td>\n<td style=\"text-align: left;\"><strong>接口</strong> (Interface/Callback)</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>底层逻辑</strong></td>\n<td style=\"text-align: left;\"><code>ApplicationContext</code> 的父级接口 / <strong>宏观工厂</strong></td>\n<td style=\"text-align: left;\">实现了 <code>FactoryBean</code> 接口的类 / <strong>微观工厂</strong></td>\n<td style=\"text-align: left;\">函数式接口 / <strong>延迟回调</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>核心职责</strong></td>\n<td style=\"text-align: left;\">管理所有 Bean 的生命周期</td>\n<td style=\"text-align: left;\">此 Bean 负责<strong>生产</strong>另一个复杂的 Bean</td>\n<td style=\"text-align: left;\">封装对象的创建过程，提供<strong>延迟</strong>获取能力</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>获取方式</strong></td>\n<td style=\"text-align: left;\"><code>ApplicationContext</code> 是它的超集</td>\n<td style=\"text-align: left;\"><code>getBean(\"name\")</code> 拿产品<br /><code>getBean(\"&amp;name\")</code> 拿工厂</td>\n<td style=\"text-align: left;\">注入 <code>ObjectFactory&lt;T&gt;</code> 后调用 <code>getObject()</code></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>真实场景</strong></td>\n<td style=\"text-align: left;\">Spring 框架的基石</td>\n<td style=\"text-align: left;\">Mybatis <code>MapperFactoryBean</code>, <code>ProxyFactoryBean</code></td>\n<td style=\"text-align: left;\">解决循环依赖(三级缓存), Scope(原型模式)适配</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五结语\">五、结语</h2>\n<p>在代码的荒原上，我们通过构建抽象来对抗混乱。</p>\n<ul>\n<li><strong>BeanFactory</strong> 是我们脚下的大地。<strong>它被称为工厂，但它实际是孕育万物的土壤（容器）。</strong></li>\n<li><strong>FactoryBean</strong> 是我们手中的精密机床。<strong>它是一个特殊的 Bean，存在的目的却是为了制造另一个 Bean。</strong></li>\n<li><strong>ObjectFactory</strong> 是我们预留的时间胶囊。<strong>它只是一个单纯的接口，为了应对循环与未来的不确定性。</strong></li>\n</ul>\n<p>理解它们，并不是为了通过面试，而是为了在下一次抛出异常时，你能冷静地凝视堆栈信息，知道机器的哪个齿轮发生了错位。</p>\n<p>既然我们选择了与机器共舞，就必须理解机器的逻辑。这或许就是作为开发者的西西弗斯式命运——<strong>我们需要一次又一次地将巨石推向山顶，以此证明我们对这个庞大系统的掌控</strong>。</p>\n<blockquote>\n<p><strong>本文通过 AI 润色（加缪风格），试图以一种冷静、客观甚至存在主义的视角，去解构这些在日常 Coding 中被我们习以为常的概念。希望这种独特的叙事风格，能让你对这些枯燥的技术概念有更深刻的“存在感”。</strong></p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 22:46</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xzqcsj\">一旅人</a>&nbsp;\n阅读(<span id=\"post_view_count\">38</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （七）双向 RNN 与深层 RNN",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19479253",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19479253\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 22:37\">\n    <span>吴恩达深度学习课程五：自然语言处理  第一周：循环神经网络 （七）双向 RNN 与深层 RNN</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课的第一周内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=161\" rel=\"noopener nofollow\" target=\"_blank\">1.11</a>到<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=162\" rel=\"noopener nofollow\" target=\"_blank\">1.12</a>的内容，同时也是本周理论部分的最后一篇。</p>\n<hr />\n<p>本周为第五课的第一周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本篇的内容关于<strong>双向 RNN 与深层 RNN</strong>，是对基础 RNN 结构的一些补充。</p>\n<h1 id=\"1-双向-rnnbidirectional-rnn\">1. 双向 RNN（Bidirectional RNN）</h1>\n<p>在前面对 <strong><a href=\"https://www.cnblogs.com/Goblinscholar/p/19449622\" target=\"_blank\">RNN</a>、<a href=\"https://www.cnblogs.com/Goblinscholar/p/19463351\" target=\"_blank\">GRU</a> 与 <a href=\"https://www.cnblogs.com/Goblinscholar/p/19474433\" target=\"_blank\">LSTM</a></strong> 的讨论中，我们始终默认了一个前提：<strong>序列只能沿时间轴单向展开，模型在当前时刻只能利用已经出现的历史信息。</strong></p>\n<p>这种设定在一些简单任务中是合理的，但在大量<strong>序列理解与标注任务</strong>中，却隐藏着一个结构性限制：  <strong>当前时刻的语义或状态，往往同时依赖于过去和未来的上下文信息。</strong><br />\n举个课程里的例子：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211513804-150472822.png\" /><br />\n于是，问题出现了：<strong>如果未来信息才是判定当前状态的重要依据，该怎么办？</strong></p>\n<p>正是在这样的背景下，<strong>双向 RNN（Bidirectional Recurrent Neural Networks）</strong> 被提出。<br />\n早在 <strong>1997 年</strong>，<strong><a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=650093\" rel=\"noopener nofollow\" target=\"_blank\">Bidirectional Recurrent Neural Networks</a></strong> 这篇论文中就指出：对于序列标注与整体理解任务，仅依赖过去上下文会造成信息利用上的先天不足，因此有必要在模型结构层面<strong>同时建模正向与反向的时间依赖关系</strong>。</p>\n<p>需要强调的是，双向 RNN 并不是一种新的循环单元设计。<br />\n它并不改变 RNN、LSTM 或 GRU 内部的计算形式，而是通过在时间维度上引入<strong>前向与后向两条独立的状态传播链路</strong>，使模型在每一个时间步都能够融合<strong>历史与未来的上下文信息</strong>。</p>\n<p>也正因为这种“结构独立于单元”的特性，双向 RNN 可以自然地与 LSTM、GRU 结合，形成 <strong>Bi-LSTM、Bi-GRU</strong>，成为提升上下文建模能力的标准配置。</p>\n<p>它的实现逻辑并不复杂，这里引用一张比较清晰易懂的传播图：（<a href=\"https://medium.com/@fraidoonomarzai99/bidirectional-rnn-in-depth-1efd32c3cf46\" rel=\"noopener nofollow\" target=\"_blank\">出处</a>）<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211514563-1603287401.png\" /><br />\n这样，你就会发现，同一序列被 <strong>正向（蓝色）</strong> 和 <strong>反向（绿色）</strong> 两条 RNN 同时建模，每个时间步 <span class=\"math inline\">\\(t\\)</span> 都能“看到”正向的历史上下文和反向的未来上下文，最终输出 <span class=\"math inline\">\\(\\hat y^{\\langle t\\rangle}\\)</span> 由两个方向的信息共同决定。</p>\n<p></p><div class=\"math display\">\\[h^{(t)}\n=\n\\operatorname{concat}\\!\\left(\n\\overrightarrow{{h}^{(t)}},\n\\overleftarrow{{h}^{(t)}}\n\\right)\n\\quad \\text{or} \\quad\n\\overrightarrow{{h}^{(t)}} + \\overleftarrow{{h}^{(t)}}\n\\]</div><p></p><p>在实践中，双向 RNN 更常采用<strong>拼接方式</strong>保留来自两个时间方向的完整信息，而<strong>逐元素相加</strong>则是一种更紧凑、但表达能力受限的折中选择。</p>\n<p>最后，再打个比方：把序列比作一座<strong>要建的桥</strong>，双向 RNN 就像是两队工人从两侧同时施工并不断交流进度，确保精准，但同时，施工队伍翻倍，整体成本也随之上升。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211553645-1826290875.png\" /></p>\n<h1 id=\"2-深层-rnn\">2. 深层 RNN</h1>\n<p>深层 RNN 的概念同样不难理解。<br />\n在最开始引入 <strong><a href=\"https://www.cnblogs.com/Goblinscholar/p/19449622\" target=\"_blank\">循环神经网络</a></strong> 时，我们说明过，默认使用<strong>单层 RNN</strong> 来进行演示：<br />\n在每一个时间步 <span class=\"math inline\">\\(t\\)</span>，输入 <span class=\"math inline\">\\(x^{(t)}\\)</span> 经过一次循环计算，得到对应的隐藏状态 <span class=\"math inline\">\\(a^{(t)}\\)</span>，并沿时间轴不断传递。</p>\n<p>但从模型表达能力的角度来看，这种结构存在限制：<strong>每个时间步内部，只进行了一次非线性变换。</strong><br />\n这意味着，无论序列本身有多复杂，在“同一时刻”对输入信息的处理深度都是有限的。<br />\n到这里，就和之前的全连接、卷积网络相通了：<br />\n<strong>如果我们希望模型在每一个时间步上，也具备类似深度前馈网络、卷积网络那样的层级表达能力，该怎么办？</strong><br />\n答案自然就是：<strong>在时间维度之外，再引入层级维度。</strong></p>\n<p>在深层 RNN 中，循环结构不再只有一层，而是<strong>在同一时间步上堆叠多层 RNN 单元</strong>。<br />\n它的传播图是这样的：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211513339-2004923823.png\" /><br />\n关于深度的逻辑和之前都是相同的，深层 RNN 通过在同一时间步上的堆叠，让模型可以进行更复杂的非线性变换，<strong>增强了其表达能力</strong>。但同样也会增加计算成本，<strong>带来梯度问题与过拟合风险</strong>，这些都是我们的老生常谈了。</p>\n<p>于此同时，和双向 RNN 类似，<strong>深层结构同样独立于具体的循环单元设计</strong>。  而且在工程实践中，<strong>深度、方向性和门控机制往往是可以同时叠加的</strong>，例如：</p>\n<ul>\n<li>多层 Bi-LSTM</li>\n<li>多层 Bi-GRU</li>\n</ul>\n<p>我们把各个组件组合或创新，便形成了深度学习 NLP 中纷繁复杂的诸多模型。</p>\n<p>最后，如果继续沿用前面的比喻：<br />\n<strong>双向 RNN</strong> 像是从桥的两端同时施工。<br />\n那么 <strong>深层 RNN</strong> 更像是： 每一个施工点上，不只是铺一层路面，而是<strong>一层层打地基、加结构、再铺表层。</strong> 这样结构更稳、表达更强，但施工流程更复杂，成本和训练难度也随之上升。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202601/3708248-20260113211517590-653078512.png\" /></p>\n<h1 id=\"3总结\">3.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>双向 RNN（Bidirectional RNN）</td>\n<td>在时间维度上引入<strong>正向和反向两条独立状态链路</strong>，每个时间步同时利用过去和未来上下文信息。适用于序列标注与整体理解任务。可以与 RNN/LSTM/GRU 结合，形成 Bi-RNN、Bi-LSTM、Bi-GRU。</td>\n<td>序列比作桥，两队工人从两端同时施工并交流进度，确保精准，但施工队伍翻倍，成本增加。</td>\n</tr>\n<tr>\n<td>深层 RNN（Deep RNN）</td>\n<td>在同一时间步上<strong>堆叠多层 RNN 单元</strong>，增加每个时间步内部的非线性表达能力，从而增强模型的表示能力。可与门控机制和双向结构叠加，形成多层 Bi-LSTM、Bi-GRU 等。</td>\n<td>每个施工点上不是只铺一层路面，而是<strong>一层层打地基、加结构、再铺表层</strong>，结构更稳、表达更强，但施工流程复杂，成本和训练难度增加。</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 22:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">24</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "synchronized关键字相关",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19479394",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19479394\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 22:24\">\n    <span>synchronized关键字相关</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h5 id=\"synchronized是java中用于解决并发问题的核心关键字它通过确保多个线程对共享资源的互斥访问来避免线程安全问题如竞态条件数据不一致等\">synchronized是Java中用于解决并发问题的核心关键字，它通过确保多个线程对共享资源的互斥访问，来避免线程安全问题（如竞态条件、数据不一致等）。</h5>\n<h4 id=\"synchronized的核心特性\">synchronized的核心特性</h4>\n<ul>\n<li>原子性（Atomicity）：确保一个或多个操作要么全部执行成功，要么全部执行失败。在synchronized代码块中的代码是不可中断的，同一时刻只有一个线程能执行。</li>\n<li>可见性（Visibility）：保证一个线程对共享变量的修改，对于其他后续进入同步代码块的线程是可见的。当线程释放锁时，会将私有内存中的变量值刷新回主内存。</li>\n<li>有序性（Ordering）：虽然编译器和处理器为了优化会进行指令重排，但synchronized可以保证多线程程序在逻辑上的执行顺序，即“同步块内的代码在执行上具有先后顺序”。</li>\n<li>可重入性：可重入性是指一个线程已经获取到某个锁后，再次请求该锁时可以直接获取，无需重新竞争。synchronized是可重入锁，其内部通过计数器记录锁的持有次数（初始为0，获取锁时加1，释放锁时减1，计数器为0时锁才被真正释放）。这一特性避免了线程在递归调用同步方法/代码块时出现死锁。例如，一个同步方法A调用另一个同步方法B（两者锁对象相同），线程获取A的锁后，调用B时可直接获取锁。</li>\n</ul>\n<h4 id=\"synchronized的使用方式\">synchronized的使用方式</h4>\n<h5 id=\"synchronized的使用灵活可修饰不同的代码结构核心是明确锁对象线程竞争的是锁对象只有获取到锁对象的线程才能执行同步代码常见使用方式有3种\">synchronized的使用灵活，可修饰不同的代码结构，核心是明确“锁对象”——线程竞争的是锁对象，只有获取到锁对象的线程才能执行同步代码，常见使用方式有3种。</h5>\n<ol>\n<li>修饰实例方法（对象锁），语法：<code>public synchronized void methodName() { ... }</code></li>\n</ol>\n<ul>\n<li>锁对象：当前类的实例对象（this）。</li>\n<li>特点：不同实例对象的锁相互独立，即多个线程访问同一个实例的同步实例方法时会竞争锁；访问不同实例的同步实例方法时，因锁对象不同，不会竞争。</li>\n<li>示例：同一User实例的add()方法被多线程调用时互斥，不同User实例的add()方法可并行执行。</li>\n</ul>\n<ol start=\"2\">\n<li>修饰静态方法（类锁）语法：<code>public static synchronized void methodName() { ... }</code></li>\n</ol>\n<ul>\n<li>锁对象：当前类的Class对象（每个类在JVM中只有一个Class对象，是全局唯一的）。</li>\n<li>特点：类锁是全局锁，无论创建多少个类的实例，所有线程访问该类的同步静态方法时，都会竞争同一个Class对象锁。</li>\n<li>注意：类锁与对象锁相互独立，即同步静态方法和同步实例方法的锁对象不同，线程访问时不会竞争。</li>\n</ul>\n<ol start=\"3\">\n<li>修饰代码块（自定义锁对象），语法：<code>synchronized (锁对象) { ... 同步代码 ... }</code></li>\n</ol>\n<ul>\n<li>锁对象：可自定义，支持两种类型：① 实例对象（this或其他实例）；② Class对象（类名.class）。</li>\n<li>特点：粒度最细，可精准控制需要同步的代码片段（而非整个方法），减少锁竞争，提高程序性能。</li>\n<li>常见场景：\n<ul>\n<li>锁当前实例：<code>synchronized (this) { ... }</code>，效果与修饰实例方法一致，但仅同步代码块内的逻辑。</li>\n<li>锁Class对象：<code>synchronized (User.class) { ... }</code>，效果与修饰静态方法一致。</li>\n<li>锁自定义对象：<code>private Object lock = new Object(); synchronized (lock) { ... }</code>，通过独立的锁对象，避免与其他同步逻辑竞争锁，灵活性最高。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"synchronized的锁机制\">synchronized的锁机制</h4>\n<ul>\n<li>Java 6及以后对synchronized进行了大幅优化，引入了“偏向锁、轻量级锁、重量级锁”三种锁状态，目的是根据线程竞争的激烈程度动态切换锁状态，平衡性能与线程安全。锁机制的核心是“对象头”——Java对象在内存中的布局包括对象头、实例数据、对齐填充，其中对象头存储了锁的状态信息（Mark Word）、类元数据指针等。</li>\n<li>三种锁状态的优先级：无锁 &lt; 偏向锁 &lt; 轻量级锁 &lt; 重量级锁，随着线程竞争的加剧，锁会从低级别向高级别升级，且升级过程不可逆（一旦升级为重量级锁，无法回退为轻量级锁或偏向锁）。\n<ul>\n<li>无锁（No Lock）：初始状态。</li>\n<li>偏向锁（Biased Lock）：当只有一个线程访问同步块时，直接在对象头记录线程ID，下次该线程进入时无需CAS操作，性能极高。</li>\n<li>轻量级锁（Lightweight Lock）：当出现竞争，但竞争不激烈时，通过CAS自旋来尝试获取锁，避免线程阻塞。</li>\n<li>重量级锁（Heavyweight Lock）：当自旋超过一定次数或竞争非常激烈时，升级为重量级锁。此时未获取到锁的线程会进入阻塞（Blocked）状态，交给操作系统管理。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"锁优化补充\">锁优化补充</h5>\n<ul>\n<li><strong>锁消除</strong>：JVM的即时编译器（JIT）在运行时，会对一些“不可能存在竞争的锁”进行消除。例如，局部变量作为锁对象（每个线程都有独立的局部变量，无共享），JVM会直接删除该synchronized修饰，避免不必要的锁开销。</li>\n<li><strong>锁粗化</strong>：当多个连续的synchronized代码块使用同一个锁对象时，JVM会将这些代码块合并为一个大的同步代码块，减少锁的获取/释放次数（每次获取/释放锁都有开销）。例如，循环内多次调用同步方法，JVM可能将锁粗化到循环外部。</li>\n</ul>\n<hr />\n<h4 id=\"cas-compare-and-swap比较并交换-是并发编程中实现原子操作的核心算法是一种乐观锁的实现策略\">CAS (Compare And Swap，比较并交换) 是并发编程中实现原子操作的核心算法，是一种乐观锁的实现策略。</h4>\n<ol>\n<li>CAS的工作原理，包含三个核心参数：</li>\n</ol>\n<ul>\n<li>内存地址 V (Memory Location)：变量在内存中的实际值。</li>\n<li>期望值 A (Expected Value)：线程认为该变量当前应该是什么值。</li>\n<li>新值 B (New Value)：线程想要更新成的值。</li>\n<li>执行逻辑：当且仅当内存地址 V 的值等于期望值 A 时，处理器才会将 V 的值更新为 B。否则，说明该变量已被其他线程修改，当前线程什么都不做，通常会进入自旋（死循环重试）。</li>\n</ul>\n<ol start=\"2\">\n<li>CAS的优缺点<br />\n<strong>优点：</strong></li>\n</ol>\n<ul>\n<li>非阻塞性：CAS 是一种非阻塞算法（Non-blocking），它不需要像 synchronized 那样挂起和恢复线程。</li>\n<li>性能高：在低、中度竞争的情况下，由于减少了线程上下文切换的开销，效率远高于重量级锁。<br />\n<strong>缺点：</strong></li>\n<li>循环时间长（自旋开销）：如果高并发下竞争激烈，CAS 会频繁失败并不断自旋，这会给 CPU 带来巨大的计算压力。</li>\n<li>只能保证一个共享变量的原子操作：对于多个变量的操作，仍需使用 synchronized 或 ReentrantLock。</li>\n<li>ABA 问题（最经典的缺点）。</li>\n</ul>\n<ol start=\"3\">\n<li>什么是 ABA 问题？</li>\n</ol>\n<ul>\n<li>如果变量初始值为A，在线程1准备修改它的过程中，线程2快速地将其改成了B，然后又改回了A。 现象：线程1观察到值依然是A，认为它没变过，于是CAS成功。 风险：虽然数值没变，但变量的状态（或对象内部的属性）可能已经发生了变化，导致逻辑错误。</li>\n<li>Java提供了AtomicStampedReference类，通过引入版本号（Stamp）来解决： 每次变量更新时，不仅更新值，还增加一个版本号。只有值和版本号都一致，CAS才会成功。</li>\n<li>还可以设置时间戳来解决。</li>\n</ul>\n<ol start=\"4\">\n<li>CAS 在Java中的实现</li>\n</ol>\n<ul>\n<li>在Java中，CAS主要由 sun.misc.Unsafe 类提供支持。该类中的方法（如 compareAndSwapInt）是 native 的，直接调用硬件底层的指令。</li>\n</ul>\n<hr />\n<h4 id=\"reentrantlock可重入锁\">ReentrantLock（可重入锁）</h4>\n<ul>\n<li>ReentrantLock是 Java java.util.concurrent.locks 包下的可重入锁实现，基于 AQS（抽象队列同步器）构建，是 synchronized 的 “增强版”—— 既保留了 synchronized 的可重入特性，又提供了更灵活的同步控制能力。</li>\n</ul>\n<h5 id=\"两者对比\">两者对比:</h5>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>synchronized</th>\n<th>ReentrantLock</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>实现层面</td>\n<td>JVM 层面（关键字），由 C++ 实现</td>\n<td>JDK 层面（API），由 Java 编写（基于 AQS）</td>\n</tr>\n<tr>\n<td>锁的释放</td>\n<td>自动释放（代码执行完或异常后）</td>\n<td>手动释放（必须在 finally 中调用 unlock()）</td>\n</tr>\n<tr>\n<td>灵活性</td>\n<td>低（不可中断，无超时机制）</td>\n<td>高（支持尝试获取、超时获取、可中断获取）</td>\n</tr>\n<tr>\n<td>公平性</td>\n<td>只支持非公平锁</td>\n<td>支持公平锁与非公平锁（默认非公平）</td>\n</tr>\n<tr>\n<td>等待队列</td>\n<td>只能关联 1 个 等待队列（wait/notify）</td>\n<td>可以绑定 多个 Condition（精细化唤醒）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"reentrantlock的特有高级功能\">ReentrantLock的特有高级功能</h5>\n<ol>\n<li>响应中断 (lockInterruptibly)</li>\n</ol>\n<ul>\n<li>synchronized一旦进入阻塞等待，除非拿到锁，否则无法被中断。而ReentrantLock允许线程在等待锁的过程中响应Thread.interrupt()，从而避免死等。</li>\n</ul>\n<ol start=\"2\">\n<li>超时机制 (tryLock)</li>\n</ol>\n<ul>\n<li>线程可以尝试获取锁，如果锁被占用，立即返回 false 或者等待一段时间后返回，而不是一直阻塞。这在预防死锁时非常有用。</li>\n</ul>\n<ol start=\"3\">\n<li>公平锁 (Fairness)</li>\n</ol>\n<ul>\n<li>公平锁：按照线程请求锁的顺序分配，先到先得。</li>\n<li>非公平锁（默认）：允许“插队”。如果新来的线程正好碰到锁释放，它可以直接抢占，性能通常比公平锁高。</li>\n</ul>\n<ol start=\"4\">\n<li>多个 Condition 对象</li>\n</ol>\n<ul>\n<li>通过lock.newCondition()，你可以创建多个等待集。例如在阻塞队列中，可以定义 notFull 和 notEmpty 两个条件，实现比 notifyAll 更精准的线程唤醒。</li>\n</ul>\n<h5 id=\"基本使用示例\">基本使用示例：</h5>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReentrantLock;\n\npublic class ReentrantLockDemo {\n    // 创建非公平锁（默认），若需公平锁：new ReentrantLock(true)\n    private static final ReentrantLock lock = new ReentrantLock();\n\n    public static void doTask() {\n        // 1. 普通获取锁（不可中断）\n        lock.lock();\n        try {\n            // 临界区代码（线程安全）\n            System.out.println(Thread.currentThread().getName() + \" 执行任务\");\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            // 必须在finally中释放锁，否则锁永远无法释放\n            lock.unlock();\n        }\n    }\n\n    // 超时获取锁示例\n    public static void tryLockWithTimeout() {\n        try {\n            // 尝试在2秒内获取锁，获取成功返回true，失败返回false\n            if (lock.tryLock(2, java.util.concurrent.TimeUnit.SECONDS)) {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" 超时获取锁成功\");\n                } finally {\n                    lock.unlock();\n                }\n            } else {\n                System.out.println(Thread.currentThread().getName() + \" 超时获取锁失败\");\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public static void main(String[] args) {\n        // 测试普通获取锁\n        new Thread(ReentrantLockDemo::doTask, \"线程1\").start();\n        new Thread(ReentrantLockDemo::doTask, \"线程2\").start();\n        \n        // 测试超时获取锁\n        new Thread(ReentrantLockDemo::tryLockWithTimeout, \"线程3\").start();\n    }\n}\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 22:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">26</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Spring IOC 源码学习 一文学习完整的加载流程",
      "link": "https://www.cnblogs.com/dddy/p/19479364",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/dddy/p/19479364\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 22:09\">\n    <span>Spring IOC 源码学习 一文学习完整的加载流程</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"ioc-的入口说明\">IOC 的入口说明</h1>\n<h2 id=\"applicationcontext-对象\">ApplicationContext 对象</h2>\n<p><strong>in short 可以理解为作为具现化的 IOC 的对象根接口, 它是一个重量级的对象, 整个应用期间应该保持单例</strong></p>\n<p>官文 Container Overview: <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/basics.html\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.spring.io/spring-framework/reference/core/beans/basics.html</a></p>\n<blockquote>\n<p>The&nbsp;<code>org.springframework.context.ApplicationContext</code>&nbsp;interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on the components to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata can be represented as annotated component classes, configuration classes with factory methods, or external XML files or Groovy scripts.</p>\n</blockquote>\n<blockquote>\n<p><code>org.springframework.context.ApplicationContext</code>&nbsp;接口代表 Spring IoC 容器，负责实例化、配置和组装 bean。容器通过读取配置元数据来获取实例化、配置和组装组件的指令。配置元数据可以表示为带注解的组件类、具有工厂方法的配置类，或外部 XML 文件或 Groovy 脚本。</p>\n</blockquote>\n<p>Several implementations of the&nbsp;<code>ApplicationContext</code>&nbsp;interface are part of core Spring. In stand-alone applications, it is common to create an instance of&nbsp;<a href=\"https://docs.spring.io/spring-framework/docs/7.0.1/javadoc-api/org/springframework/context/annotation/AnnotationConfigApplicationContext.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>AnnotationConfigApplicationContext</code></a>&nbsp;or&nbsp;<a href=\"https://docs.spring.io/spring-framework/docs/7.0.1/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>ClassPathXmlApplicationContext</code></a>.</p>\n<blockquote>\n<p><code>ApplicationContext</code>&nbsp;接口有多个实现 , 是Spring 核心的一部分。在独立应用程序中，通常创建&nbsp;<a href=\"https://docs.spring.io/spring-framework/docs/7.0.1/javadoc-api/org/springframework/context/annotation/AnnotationConfigApplicationContext.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>AnnotationConfigApplicationContext</code></a>&nbsp;or&nbsp;<a href=\"https://docs.spring.io/spring-framework/docs/7.0.1/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html\" rel=\"noopener nofollow\" target=\"_blank\"><code>ClassPathXmlApplicationContext</code></a>&nbsp;的实例。</p>\n</blockquote>\n<h2 id=\"xml和注解-配置的-applicationcontext\">XML和注解 配置的 ApplicationContext</h2>\n<p>我们通常使用 Spring IOC 配置容器的方式一般有两种: 1. 通过XML配置文件,  2. 基于注解的形式配置, 它们分别是入口类不一样.</p>\n<ol>\n<li>\n<p>基于XML配置, 实际有两个类实现  <strong>ClassPathXmlApplicationContext</strong> 还有一个是 <strong>FileSystemXmlApplicationContext</strong> <s>(很少用就是了)</s> 它们主要的代码逻辑都是在它父 <code>AbstractXmlApplicationContext</code> 中.</p>\n</li>\n<li>\n<p>基于注解的形式配置,  <a href=\"https://docs.spring.io/spring-framework/reference/core/beans/annotation-config.html\" rel=\"noopener nofollow\" target=\"_blank\">Annotation-based configuration</a>  基于 Spring 自定义, 使用<a href=\"https://docs.spring.io/spring-framework/reference/core/beans/factory-extension.html#beans-factory-extension-bpp-examples-aabpp\" rel=\"noopener nofollow\" target=\"_blank\"><code>AutowiredAnnotationBeanPostProcessor</code></a> 处理解析相关注解的实现, 另外 JSR 330 中标准的注解也是它处理的.</p>\n</li>\n</ol>\n<p>本博文以 XML 加载作为源码入口点进行分析:</p>\n<h1 id=\"上汇总大图\">上汇总大图</h1>\n<p>真的很大的大图..</p>\n<p><img alt=\"Spring IOC 容器加载的详细流程\" class=\"lazyload\" /></p>\n<p>看不清, 请使用原生浏览器打开链接: <a href=\"https://img2024.cnblogs.com/blog/3723410/202601/3723410-20260113220603061-1916535706.jpg\" target=\"_blank\">https://img2024.cnblogs.com/blog/3723410/202601/3723410-20260113220603061-1916535706.jpg</a></p>\n<h1 id=\"xml-实例入口\">XML 实例入口</h1>\n<h2 id=\"实例代码\">实例代码</h2>\n<p><code>org.yang.learn.spring.dto.Address</code></p>\n<pre><code class=\"language-java\">package org.yang.learn.spring.dto;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\n\n/**\n * @author yangfh\n * @date 2023-12-14 21:30\n **/\npublic class Address  {\n\tString city;\n\tString country;\n\tString street;\n\n\tpublic Address() {\n\t\tSystem.out.println(\"Address 无参构造函数: \"+ this.toString());\n\t}\n\n\tpublic Address(String city, String country, String street) {\n\t\tthis.city = city;\n\t\tthis.country = country;\n\t\tthis.street = street;\n\t\tSystem.out.println(\"Address 构造函数: \"+ this.toString());\n\t}\n\t... getter  setter ...\n}\n\n</code></pre>\n<p><code>org.yang.learn.spring.dto.User</code></p>\n<pre><code class=\"language-java\">package org.yang.learn.spring.dto;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.DisposableBean;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\nimport org.springframework.core.PriorityOrdered;\nimport org.springframework.lang.Nullable;\n\n/**\n * @author yangfh\n * @date 2023-12-14 21:30\n **/\npublic class User implements InitializingBean, DisposableBean {\n\tprivate Long id;\n\tprivate String username;\n\tprivate String email;\n\tprivate Address address;\n\tprivate Long age;\n\n\tpublic User() {\n\t\tSystem.out.println(\"User 无参构造函数: \"+ this.toString());\n\t}\n\n\tpublic User(Long id, String username, String email, Address address) {\n\t\tthis.id = id;\n\t\tthis.username = username;\n\t\tthis.email = email;\n\t\tthis.address = address;\n\t\tSystem.out.println(\"User 有参构造函数: \"+ this.toString());\n\t}\n\n\tpublic void initMethod(){\n\t\tSystem.out.println(\"User initMethod\");\n\t}\n\n\tpublic void destroyMethod(){\n\t\tSystem.out.println(\"User destroyMethod\");\n\t}\n\n\t@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\tSystem.out.println(\"User afterPropertiesSet\");\n\t}\n\n\t@Override\n\tpublic void destroy() throws Exception {\n\t\tSystem.out.println(\"User destroy\");\n\t}\n\t\n\t\n\t... getter  setter ...\n}\n</code></pre>\n<p><code>org.yang.learn.spring.dto.UserServiceImpl</code></p>\n<pre><code class=\"language-java\">public class UserServiceImpl implements BeanPostProcessor, BeanFactoryPostProcessor, ApplicationContextAware {\n\tpublic UserServiceImpl(){\n\t\tSystem.out.println(\"UserServiceImpl 无参构造\");\n\t}\n\n\t@Override\n\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tSystem.out.println(\"UserServiceImpl postProcessBeforeInitialization 增强处理 [\"+beanName+\"]\");\n\t\treturn BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);\n\t}\n\n\t@Override\n\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tSystem.out.println(\"UserServiceImpl postProcessAfterInitialization 增强处理 [\"+beanName+\"]\");\n\t\treturn BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);\n\t}\n\n\t@Override\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tSystem.out.println(\"UserServiceImpl postProcessBeanFactory beanFactory 增强处理 [\"+beanFactory+\"]\");\n\t}\n\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n\t\tSystem.out.println(\"UserServiceImpl setApplicationContext \");\n\t}\n}\n</code></pre>\n<p><code>application.xml</code></p>\n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t   xmlns:context=\"http://www.springframework.org/schema/context\"\n\t   xmlns:aop=\"http://www.springframework.org/schema/cache\"\n\t   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t\thttps://www.springframework.org/schema/beans/spring-beans.xsd\n\t\thttp://www.springframework.org/schema/context\n\t\thttps://www.springframework.org/schema/context/spring-context.xsd\n\t\thttp://www.springframework.org/schema/cache\n\t\thttp://www.springframework.org/schema/cache/spring-cache.xsd\"&gt;\n\n\t&lt;bean id=\"address\" class=\"org.yang.learn.spring.dto.Address\" &gt;\n\t\t&lt;constructor-arg value=\"深圳\"/&gt;\n\t\t&lt;constructor-arg value=\"罗湖\"/&gt;\n\t\t&lt;constructor-arg value=\"xxx街道101号\"/&gt;\n\t&lt;/bean&gt;\n\t&lt;bean id=\"user\" class=\"org.yang.learn.spring.dto.User\" init-method=\"initMethod\" destroy-method=\"destroyMethod\" &gt;\n\t\t&lt;property name=\"username\" value=\"张三\"&gt;&lt;/property&gt;\n\t\t&lt;property name=\"age\" value=\"9764534\"&gt;&lt;/property&gt;\n\t&lt;/bean&gt;\n\t&lt;bean id=\"userService\" class=\"org.yang.learn.spring.dto.UserServiceImpl\" &gt;\n\t&lt;/bean&gt;\n\n&lt;/beans&gt;\n\n\n</code></pre>\n<pre><code class=\"language-java\">public static void main(String[] args) throws Exception {\n\tSystem.out.println(\"===========================容器启动===============================\\n\");\n\tClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\");\n\tSystem.out.println(\"\\n==========================容器完成================================\");\n\tUser user = context.getBean(\"user\", User.class);\n\tSystem.out.println(\"获取容器的user Bean: \"+user);\n\tcontext.close();\n}\n</code></pre>\n<h2 id=\"容器的创建-classpathxmlapplicationcontext\">容器的创建 (ClassPathXmlApplicationContext)</h2>\n<p><code>org.springframework.context.support.ClassPathXmlApplicationContext#ClassPathXmlApplicationContext(java.lang.String)</code><br />\n<code>org.springframework.context.support.ClassPathXmlApplicationContext#ClassPathXmlApplicationContext(java.lang.String[], boolean, org.springframework.context.ApplicationContext)</code></p>\n<pre><code class=\"language-java\">/**\n * Create a new ClassPathXmlApplicationContext with the given parent,\n * loading the definitions from the given XML files.\n * @param configLocations array of resource locations\n * @param refresh whether to automatically refresh the context,\n * loading all bean definitions and creating all singletons.\n * Alternatively, call refresh manually after further configuring the context.\n * @param parent the parent context\n * @throws BeansException if context creation failed\n * @see #refresh()\n */\npublic ClassPathXmlApplicationContext(\n\t\tString[] configLocations, boolean refresh, @Nullable ApplicationContext parent)\n\t\tthrows BeansException {\n\t/**\n\t * 调用父类构造, 初始了一些对象和字段属性, 例如:\n\t *  1. 当前 context 的属性初始化:\n\t *   - 存储BeanFactoryPostProcessor(BFPP)的集合  {@link org.springframework.context.support.AbstractApplicationContext#beanFactoryPostProcessors}\n\t *\t - id 容器ID, displayName 容器名称,  closed, active 容器关闭启动 活动的 AtomicBoolean标识符 ; {@link org.springframework.context.support.AbstractApplicationContext#id}\n\t *   - startupShutdownMonitor 容器锁对象, 在容器'刷新'和'销毁'时需要锁住(同步)的 {@link AbstractApplicationContext#startupShutdownMonitor}\n\t *    shutdownHook; JVM 的 HOOK {@link AbstractApplicationContext#shutdownHook}\n\t *\n\t *  2. 如果有父容器,则设置父容器,还会合并配置;\n\t *  {@link org.springframework.context.support.AbstractApplicationContext#setParent(org.springframework.context.ApplicationContext)}\n\t *\n\t *  3. 创建支持ant风格解析的资源解析器,支持通配符的类似`\"classpath*:applicationContext-*.xml\"` 这种, 解析容器所需要的 xml, yml, properties 等配置文件; `spring.profiles.active` 的变量 也是由这个解析器进行处理\n\t * \t解析容器所需要的 xml, yml, properties 等配置文件;  {@link AbstractApplicationContext#AbstractApplicationContext()}\n\t */\n\tsuper(parent);\n\t/**\n\t * 解析路径, 路径中支持表达式的变量, 例如: 文件名 application-${env}.xml 环境对象里面有env变量会替换之\n\t */\n\tsetConfigLocations(configLocations);\n\tif (refresh) {\n\t\trefresh();\n\t}\n}\n</code></pre>\n<h3 id=\"总结\">总结</h3>\n<p>调用父类构造, 初始了一些对象和字段属性, 例如:</p>\n<ol>\n<li>当前 context 的属性初始化:</li>\n</ol>\n<ul>\n<li>存储 BeanFactoryPostProcessor(BFPP) 的集合 </li>\n<li>id 容器ID, displayName 容器名称,  closed, active 容器关闭启动 活动的 AtomicBoolean标识符 ;</li>\n<li><code>startupShutdownMonitor</code> 容器锁对象, 在容器'刷新'和'销毁'时需要锁住(同步)的</li>\n<li>shutdownHook; JVM 的 HOOK</li>\n</ul>\n<ol start=\"2\">\n<li>如果有父容器,则设置父容器,还会合并配置;</li>\n</ol>\n<ul>\n<li></li>\n</ul>\n<ol start=\"3\">\n<li>创建支持ant风格解析的资源解析器,支持通配符的类似<code>\"classpath*:applicationContext-*.xml\"</code> 这种, 解析容器所需要的 xml, yml, properties 等配置文件; <code>spring.profiles.active</code> 的变量 也是由这个解析器进行处理<br />\n解析容器所需要的 xml, yml, properties 等配置文件; </li>\n</ol>\n<h2 id=\"refresh-方法\">refresh() 方法</h2>\n<p>这个是重点方法,  几乎整个生命周期的代码, 都可以在这个方法内找到, 所以代码断点 书签 调试, 都给它干上..</p>\n<p><code>org.springframework.context.support.AbstractApplicationContext#refresh</code></p>\n<p><code>org.springframework.context.support.AbstractApplicationContext#refresh</code></p>\n<pre><code class=\"language-java\">\n\t@Override\n\tpublic void refresh() throws BeansException, IllegalStateException {\n\t\t// 容器刷新, 执行时, 需要锁住\n\t\tsynchronized (this.startupShutdownMonitor) {\n\t\t\t//记录容器 启动时间, 步骤 用于分析性能的 (不重要)\n\t\t\tStartupStep contextRefresh = this.applicationStartup.start(\"spring.context.refresh\");\n\n\t\t\t// Prepare this context for refreshing.\n\t\t\t/**\n\t\t\t * 一, (ApplicationContext)的预准备工作;\n\t\t\t * 容器刷新前的准备工作\n\t\t\t * 1. 设置容器的一些状态标志符;设置启动时间, 活动标志符; {@link AbstractApplicationContext#prepareRefresh()}\n\t\t\t * 2. 获取或者创建 Environment 对象; 加载 System.getProperties(); {@see AbstractApplicationContext#environment}\n\t\t\t * 3. 验证环境是否包含某配置; 手动添加配置. {@link AbstractApplicationContext#initPropertySources()}\n\t\t\t * 4. 准备存储 事件监听器 和 事件 的集合容器, 默认为空 {@link AbstractApplicationContext#prepareRefresh()};\n\t\t\t */\n\t\t\tprepareRefresh();\n\n\t\t\t// Tell the subclass to refresh the internal bean factory.\n\t\t\t/**\n\t\t\t * 二, 创建 BeanFactory;\n\t\t\t * 1. 销毁之前的 beanFactory (如果有的话) {@link AbstractRefreshableApplicationContext#refreshBeanFactory()}\n\t\t\t * 2. 实例化/创建 beanFactory, 这里是实例类是 `DefaultListableBeanFactory` {@link org.springframework.context.support.AbstractRefreshableApplicationContext#createBeanFactory}\n\t\t\t * 3. 设置 beanFactory 忽略  BeanNameAware, BeanClassLoaderAware, BeanFactoryAware这三个Aware的接口 {@link AbstractAutowireCapableBeanFactory#AbstractAutowireCapableBeanFactory()}\n\t\t\t * \t\t因为在初始化Bean时, 会直接调用它们(而不是通过通过 BeanPostProcessor扩展的Aware机制调用) {@link org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(java.lang.String, java.lang.Object, org.springframework.beans.factory.support.RootBeanDefinition)}\n\t\t\t * 4. 设置 beanFactory 序列化ID, 名称 {@link AbstractRefreshableApplicationContext#refreshBeanFactory()}\n\t\t\t * 5. 扩展点, 定制化这个 BeanFactory 例如: 是否允许 BeanDefinition 覆盖; 是否自动处理循环依赖;\n\t\t\t * 6. 创建(XML解析器/读取器) XmlBeanDefinitionReader, 并初始化; 留下扩展点, 扩展Reader 例如 是否验证xml等 {@link AbstractXmlApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory)}\n\t\t\t * 7. 创建相关对象DocumentLoader, BeanDefinitionDocumentReader,BeanDefinitionParserDelegate {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions(org.w3c.dom.Document, org.springframework.core.io.Resource)}\n\t\t\t * \t\t{@link DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions(Element)}\n\t\t\t *    加载/解析 XML标签/元素/属性等将其封装为 一个个 BeanDefinition 对象\n\t\t\t * 8. 将 BeanDefinitions 注册到 registry {@link BeanDefinitionReaderUtils#registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry)}\n\t\t\t */\n\t\t\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n\t\t\t/**\n\t\t\t * 三,(BeanFactory)预准备工作;\n\t\t\t * {@link AbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory)}\n\t\t\t * 1. 为 beanFactory 设置 bean 的类加载器 {@link ConfigurableBeanFactory#setBeanClassLoader(ClassLoader)}\n\t\t\t * 2. 为 beanFactory 设置 bean 的 StandardBeanExpressionResolver (表达式(Spring EL)解析器) {@link ConfigurableBeanFactory#setBeanExpressionResolver(BeanExpressionResolver)}\n\t\t\t *   关于 (Spring EL)解析器: StandardBeanExpressionResolver 的设计是组合优于继承, 内部有两个 SpelExpressionParser(真正解析的) SpelParserConfiguration(配置类)\n\t\t\t * 3. 为 beanFactory 设置 PropertyEditorRegistrar (主要为 Bean 设置属性的管理类){@link ConfigurableBeanFactory#addPropertyEditorRegistrar(PropertyEditorRegistrar)}\n\t\t\t * \t\t *  PropertyEditorRegistrar 这个主要为 Bean 设置属性的管理类, 比如, 日期类型的数据: 可以是特定格式的字符串, 数字, 还可以是时间戳...\n\t\t\t * \t\t *  Spring 为 bean 填充属性, 使用 BeanWrapperImpl 包装了一下(装饰模式)\n\t\t\t * \t\t *  BeanWrapperImpl 实现了 PropertyEditorRegistry, 可以往里面注册 PropertyEditor, 可以自定义属性的转换, 编辑逻辑\n\t\t\t * 4. 给 beanFactory 添加一个 处理Aware的 BeanPostProcessor (ApplicationContextAwareProcessor) 并忽略掉这7个接口的自动注入:{@link ConfigurableBeanFactory#addBeanPostProcessor(BeanPostProcessor)}\n\t\t\t * \t\tEnvironmentAware.class, EmbeddedValueResolverAware.class, ResourceLoaderAware.class, ApplicationEventPublisherAware.class, MessageSourceAware.class, ApplicationContextAware.class, ApplicationStartupAware.class\n\t\t\t * 5. 指定内置的 BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContext {@link ConfigurableListableBeanFactory#registerResolvableDependency(Class, Object)}\n\t\t\t * \t\t这几个Bean对象,  自动注入的 Primary\n\t\t\t * 6. 给 beanFactory 添加一个 BeanPostProcessor (ApplicationListenerDetector)TODO (事件监听相关)\n\t\t\t * 7. 给 beanFactory 添加一个 BeanPostProcessor(LoadTimeWeaverAwareProcessor) TODO (AOP AspectJ 织入处理相关的)\n\t\t\t * 8. beanFactory中如果没有以下名称的 bean, 则直接给 BeanFactory 的一级缓存, 注册几个环境对象 Bean {@link SingletonBeanRegistry#registerSingleton(String, Object)}\n\t\t\t *  名称常量分别是:\n\t\t\t *  org.springframework.context.ConfigurableApplicationContext#ENVIRONMENT_BEAN_NAME\n\t\t\t *  org.springframework.context.ConfigurableApplicationContext#SYSTEM_PROPERTIES_BEAN_NAME\n\t\t\t *  org.springframework.context.ConfigurableApplicationContext#SYSTEM_ENVIRONMENT_BEAN_NAME\n\t\t\t *  org.springframework.context.ConfigurableApplicationContext#APPLICATION_STARTUP_BEAN_NAME\n\t\t\t *\n\t\t\t */\n\t\t\t// Prepare the bean factory for use in this context.\n\t\t\tprepareBeanFactory(beanFactory);\n\n\t\t\ttry {\n\t\t\t\t// Allows post-processing of the bean factory in context subclasses.\n\t\t\t\t/**\n\t\t\t\t * 四, beanFactory 已经准备好了, 设计目的是给(Context)子类预留一个扩展点, 在此时这里所有的 Bean 已经被注册了, 尚未实例化任何bean;\n\t\t\t\t * BeanPostProcessors\n\t\t\t\t * (这里是空实现)\n\t\t\t\t */\n\t\t\t\tpostProcessBeanFactory(beanFactory);\n\n\t\t\t\tStartupStep beanPostProcess = this.applicationStartup.start(\"spring.context.beans.post-process\");\n\n\t\t\t\t// Invoke factory processors registered as beans in the context.\n\t\t\t\t/**\n\t\t\t\t * 五, 调用 BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor\n\t\t\t\t * 若是注册的bean definition 实现了这两个接口, 则会调用(getBean)实例化它, 再调用相应的接口方法;\n\t\t\t\t * (注意一下 BeanDefinitionRegistryPostProcessor 是继承自 BeanFactoryPostProcessor的)\n\t\t\t\t * 总的来说 调用的优先级是:\n\t\t\t\t * 1. 调用接口的优先级:\n\t\t\t\t *    1. 优先调用(子类) BeanDefinitionRegistryPostProcessor\n\t\t\t\t *    2. 再调用(父类) BeanFactoryPostProcessor\n\t\t\t\t * 2. 调用添加的方式的优先级:\n\t\t\t\t *    1. 优先调用外部入参, 即直接通过{@link AbstractApplicationContext#addBeanFactoryPostProcessor(org.springframework.beans.factory.config.BeanFactoryPostProcessor)} 代码添加的\n\t\t\t\t *    2. 再调用容器中实现 BeanFactoryPostProcessor 或者 BeanDefinitionRegistryPostProcessor 的 Bean\n\t\t\t\t * 见: {@link org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List)}\n\t\t\t\t *\n\t\t\t\t * 值得一提的是:  Spring 对于支持 SPEL表达式, 就是通过 `PropertySourcesPlaceholderConfigurer` 这种方式扩展实现的\n\t\t\t\t * {@link org.springframework.context.support.PropertySourcesPlaceholderConfigurer}\n\t\t\t\t */\n\t\t\t\tinvokeBeanFactoryPostProcessors(beanFactory);\n\n\t\t\t\t// Register bean processors that intercept bean creation.\n\t\t\t\t/**\n\t\t\t\t *  六, 注册 BeanPostProcessor (BPP)处理器;\n\t\t\t\t *\n\t\t\t\t *  1. 拿到所有 BeanPostProcessor 类型的 bean\n\t\t\t\t *  2. 实例化 BeanPostProcessor\n\t\t\t\t *  \t优先实例化 实现了 PriorityOrdered 接口的, 在实例化其它的(BPP)\n\t\t\t\t *  3. 进行分类存到集合 {@link PostProcessorRegistrationDelegate#registerBeanPostProcessors(ConfigurableListableBeanFactory, AbstractApplicationContext)}\n\t\t\t\t *   \t* 对 BeanPostProcessor 进行分类存起来,  再调用, 每个集合分别是\n\t\t\t\t * \t\t * 1. priorityOrderedPostProcessors //有实现(PriorityOrdered)排序接口的\n\t\t\t\t * \t\t * 2. internalPostProcessors //Spring内部的bean, 见: Spring将bean分为三种角色\n\t\t\t\t * \t\t * 3. orderedPostProcessorNames //实现 Ordered 接口\n\t\t\t\t * \t\t * 4. nonOrderedPostProcessorNames //没有指定顺序, 无序的\n\t\t\t\t *  这有一点, Spring 对 BeanDefinition 分成三种角色:\n\t\t\t\t *  \t1. 用户定义的 业务相关的 Bean Bean (ROLE_APPLICATION)\n\t\t\t\t *      2. 较复杂的 (ROLE_SUPPORT) 较复杂的, 支持 AOP、事务等功能的内部实现?  (不重要, 不要每一个细节都扣...)\n\t\t\t\t *      3. Spring 内置的(ROLE_INFRASTRUCTURE)\n\t\t\t\t *\n\t\t\t\t *  4. 排序并注册到 beanFactory\n\t\t\t\t *    \t1. 这里按实现(PriorityOrdered)排序接口的、@Ordered注解的 等排序存起来. 实际调用的顺序 其实就是存起来的顺序\n\t\t\t\t *      2. 另外 BeanPostProcessor 接口粗粒度太大了, Spring 还细分一些子接口:\n\t\t\t\t *         1. SmartInstantiationAwareBeanPostProcessor 它提供了更高级的Bean实例化控制方法。主要作用在于允许对Bean的实例化过程进行更精细的控制和定制。\n\t\t\t\t *         2. MergedBeanDefinitionPostProcessor 在合并Bean定义（MergedBeanDefinition）之后但在实例化Bean之前，允许对合并后的Bean定义进行修改、调整或附加元数据。\n\t\t\t\t *         3. DestructionAwareBeanPostProcessor 它允许在Bean被销毁之前（例如，容器关闭或特定作用域的Bean销毁）执行一些操作。\n\t\t\t\t *         等等以上也会存起来\n\t\t\t\t *      3. 最终调用 BPP是在 {@link AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory)} 实例初始化其他Bean调用\n\t\t\t\t */\n\t\t\t\tregisterBeanPostProcessors(beanFactory);\n\n\t\t\t\tbeanPostProcess.end();\n\n\t\t\t\t// Initialize message source for this context.\n\t\t\t\t/**\n\t\t\t\t * 七, 初始化国际化(I18N) 信息源;\n\t\t\t\t * 里面很简单:\n\t\t\t\t * 1. 如果beanFactory中有名称为 messageSource 的Bean定义 ，就使用这bean作物国际化消息源\n\t\t\t\t * 如果没有则默认使用 org.springframework.context.support.DelegatingMessageSource 并注册到 beanFactory\n\t\t\t\t */\n\t\t\t\tinitMessageSource();\n\n\t\t\t\t// Initialize event multicaster for this context.\n\t\t\t\t/**\n\t\t\t\t * 八, 初始化事件多播器;\n\t\t\t\t * 1. 如果 beanFactory 中包含名称为 applicationEventMulticaster 的bean定义, 则使用这个Bean作为事件多播器;\n\t\t\t\t *   如果不包含则创建 SimpleApplicationEventMulticaster作为事件多播器;\n\t\t\t\t * 2.创建SimpleApplicationEventMulticaster其实就是初始化了一个,用于存放/管理 ApplicationListener 监听器(观察者)的类, 并注册到 beanFactory\n\t\t\t\t * \t主要是 {@link org.springframework.context.event.AbstractApplicationEventMulticaster#defaultRetriever} 用于存放/管理 各个监听器的(观察者)\n\t\t\t\t *  {@link org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType) }调用容器发布事件\n\t\t\t\t */\n\t\t\t\tinitApplicationEventMulticaster();\n\n\t\t\t\t// Initialize other special beans in specific context subclasses.\n\t\t\t\t/**\n\t\t\t\t * 九, 给子类(Context)留下一个扩展点\n\t\t\t\t * 没什么好说的, 这里是空实现\n\t\t\t\t */\n\t\t\t\tonRefresh();\n\n\t\t\t\t// Check for listener beans and register them.\n\t\t\t\t/**\n\t\t\t\t * 十, 向多播器注册监听器;\n\t\t\t\t * 1. 向多播器中注册 在context中的监听器(观察者);\n\t\t\t\t * 2. 向多播器中注册 在beanFactory中的bean是监听器(ApplicationListener.class)的(观察者)\n\t\t\t\t * 3. 广播 this.earlyApplicationEvents 属性中的事件;\n\t\t\t\t * 为什么?\n\t\t\t\t * 因为有可能 在容器生命周期中调用了当前 `AbstractApplicationContext#publishEvent` 发布事件, 但是多播器没有初始化完成, 所以会将事件存在this.earlyApplicationEvents 中;\n\t\t\t\t * 待容器初始化完成后在流程  {@link org.springframework.context.support.AbstractApplicationContext#registerListeners()} 中会发布存在这里面的事件\n\t\t\t\t * (例如: 在 BeanFactoryPostProcessor 的业务逻辑触发容器的广播事件, 这时候多播器都不存在)\n\t\t\t\t * @see AbstractApplicationContext#prepareRefresh()\n\t\t\t\t */\n\t\t\t\tregisterListeners();\n\n\t\t\t\t// Instantiate all remaining (non-lazy-init) singletons.\n\t\t\t\t/**\n\t\t\t\t * 十一, 实例化剩下的所有单例bean\n\t\t\t\t *\n\t\t\t\t * 1. 为 beanFactory 设置类型转换器(ConversionService) 属性填充时会用到 {@link AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory)}\n\t\t\t\t * 2. 为 beanFactory 添加变量解析器 (StringValueResolver)\n\t\t\t\t * \t如果 beanFactory 上下文中不包含 \"默认的变量解析器 (类似 PropertySourcesPlaceholderConfigurer) 解析类似 '${}' 这样的变量 \"\n\t\t\t\t * \t则使用环境对象(ConfigurableEnvironment)中的 ConfigurablePropertyResolver实现来作为 StringValueResolver 添加进去\n\t\t\t\t * 3. 冻结配置, 此后就不再允许更改 beanDefinition 了\n\t\t\t\t * 4. 实例化所有剩余的 (非lazy-init) 单例 Bean\n\t\t\t\t * 5. 处理 FactoryBean 类型的bean {@link DefaultListableBeanFactory#preInstantiateSingletons()}\n\t\t\t\t * \t如果该bean是 FactoryBean, 则在 bean name 前面加一个 '&amp;' 前缀, 先获取/实例化 FactoryBean 本身;\n\t\t\t\t * \t(注意一下 FactoryBean 生成对象是不遵循 Spring 的bean生命周期的)\n\t\t\t\t * \t这有两个对象, 如何获取? getBean(beanName) :\n\t\t\t\t * \t1. 传入 FactoryBean 的 name 返回的是其 getObject 的目标对象实例;\n\t\t\t\t * \t2. 如果想获取 FactoryBean 本身实例, 则前面需要加一个 '&amp;' 前缀;\n\t\t\t\t * 6. 尝试从当前容器 一 二 三级缓存获取 {@link AbstractBeanFactory#doGetBean(String, Class, Object[], boolean)}\n\t\t\t\t * 7. 处理 AOP 代理对象生成 {@link AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])}\n\t\t\t\t * 8. 在JVM层面实例化对象 {@link AbstractAutowireCapableBeanFactory#doCreateBean(String, RootBeanDefinition, Object[])}\n\t\t\t\t * \t1.真正在jvm层面实例化对象;\n\t\t\t\t * \t\t1. 如果该 BeanDefinition 有配置 instanceSupplier属性(java.util.function.Supplier),\n\t\t\t\t * \t\t 将使用其Supplier#get方法的返回, 作为实例对象\n\t\t\t\t * \t\t2. 如果该 BeanDefinition 有配置 factory-method 将使用该方法返回的, 作为实例对象\n\t\t\t\t * \t\t 这里这里包括'静态工厂'和'实例工厂'的处理(通过bd的factoryBeanName 进行判断, 如果存在则是'实例工厂')\n\t\t\t\t * \t\t3. 使用反射实例化, 根据策略实例化Bean对象 {@link org.springframework.beans.factory.support.SimpleInstantiationStrategy}\n\t\t\t\t * \t\t- 使用有参构造函数注入,创建 (new)\n\t\t\t\t * \t\t- 使用无参构造函数创建 (new)\n\t\t\t\t * \t\t- 工厂方法实例化 ('静态工厂' '实例工厂' )\n\t\t\t\t * \t\t`&lt;bean  factory-bean=\"bookFactoryBean\"  factory-method=\"getBook()\"/&gt;`\n\t\t\t\t * \t\t静态工厂: factory-bean 若是 全限定类名 则使用 BookFactoryBean::getBook 的静态方法返回的对象\n\t\t\t\t * \t\t实例工厂:  factory-bean 若是 bean 名 则使用该实例方法返回的对象\n\t\t\t\t * \t2. 用 BeanWrapper 包装原始bean (装饰模式)\n\t\t\t\t * \t3. 初始化 BeanWrapper\n\t\t\t\t * \t\t1. 给 BeanWrapper 设置了, ConversionService\n\t\t\t\t * \t\t2. 给 BeanWrapper 注册了, 当前 bean factory (propertyEditorRegistrars)中的全部 PropertyEditor\n\t\t\t\t * \t\t3. 处理 MergedBeanDefinitionPostProcessor 的接口回调 {@link AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class, String)}\n\t\t\t\t * \t\t调用 添加在 context 中 BeanPostProcessor 的 MergedBeanDefinitionPostProcessor 的接口回调\n\t\t\t\t * \t\t解析到诸如`@Autowired`之类的注解 (Metadata)元信息,合并到BeanDefinition中\n\t\t\t\t * \t4. 填充Bean属性 {@link AbstractAutowireCapableBeanFactory#populateBean(String, RootBeanDefinition, BeanWrapper)}\n\t\t\t\t * \t\t1. 如果是AOP, pointcut, advice相关的, synthetic 会配置为 true  调用 BeanPostProcessor 的子接口 InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation\n\t\t\t\t * \t\t(作用是 在实例化之后，属性填充之前执行操作, 可以拦截属性填充操作)\n\t\t\t\t * \t\t2. 处理注解的  byName 或者 byType 注入的属性\n\t\t\t\t * \t\t3. 回调所有 InstantiationAwareBeanPostProcessor#postProcessProperties 方法\n\t\t\t\t * \t\t比如, `@Autowired` 的处理对应实现类: {@link org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor}\n\t\t\t\t * \t\t(作用是: 在工厂将属性值应用到给定bean之前，对它们进行处理)\n\t\t\t\t * \t\t注意这里也只是解析, 并没有设置进去, 实际赋值方法见: {@link AbstractAutowireCapableBeanFactory#applyPropertyValues(java.lang.String, org.springframework.beans.factory.config.BeanDefinition, org.springframework.beans.BeanWrapper, org.springframework.beans.PropertyValues)}\n\t\t\t\t * \t5.初始化Bean对象 {@link AbstractAutowireCapableBeanFactory#initializeBean(String, Object, RootBeanDefinition)}\n\t\t\t\t * \t\t1. 先调用这三个 BeanNameAware, BeanClassLoaderAware, BeanFactoryAware {@link AbstractAutowireCapableBeanFactory#invokeAwareMethods(String, Object)}\n\t\t\t\t * \t\t这三个是在创建BeanFactory 时忽略的三个 Aware 接口\n\t\t\t\t * \t\t2. 调用所有 BeanPostProcessors#postProcessBeforeInitialization (作用: 在Bean初始化之前调用) {@link AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization(Object, String)}\n\t\t\t\t * \t\t3. 调用 init-method 方法 {@link AbstractAutowireCapableBeanFactory#invokeInitMethods(String, Object, RootBeanDefinition)}\n\t\t\t\t * \t\t4. 调用所有 BeanPostProcessors#postProcessAfterInitialization (作用: 在Bean初始化之后调用) {@link AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization(Object, String)}\n\t\t\t\t * \t6. 注册 bean销毁的工作(如果需要){@link AbstractBeanFactory#registerDisposableBeanIfNecessary(String, Object, RootBeanDefinition)}\n\t\t\t\t * \t\t\t1. org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor#postProcessBeforeDestruction(Object,String) BPP接口\n\t\t\t\t * \t\t\t2. org.springframework.beans.factory.DisposableBean 接口\n\t\t\t\t * \t\t\t3. 自定义 destroy方法\n\t\t\t\t * \t\t\t(在容器关闭时会调用会按这个顺序调用)\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tfinishBeanFactoryInitialization(beanFactory);\n\n\t\t\t\t// Last step: publish corresponding event.\n\t\t\t\t/**\n\t\t\t\t * 十二, 完成容器刷新\n\t\t\t\t * 1. 清理各种缓存资源\n\t\t\t\t * 2. 为当前上下文初始化生命周期处理器\n\t\t\t\t * 3. 发布 ContextRefreshedEvent (Context 完成刷新)事件\n\t\t\t\t */\n\t\t\t\tfinishRefresh();\n\t\t\t}\n\n\t\t\tcatch (RuntimeException | Error ex ) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Exception encountered during context initialization - \" +\n\t\t\t\t\t\t\t\"cancelling refresh attempt: \" + ex);\n\t\t\t\t}\n\t\t\t\t// Destroy already created singletons to avoid dangling resources.\n\t\t\t\tdestroyBeans();\n\n\t\t\t\t// Reset 'active' flag.\n\t\t\t\tcancelRefresh(ex);\n\n\t\t\t\t// Propagate exception to caller.\n\t\t\t\tthrow ex;\n\t\t\t}\n\n\t\t\tfinally {\n\t\t\t\tcontextRefresh.end();\n\t\t\t}\n\t\t}\n\t}\n</code></pre>\n<h2 id=\"一--applicationcontext的预准备工作\">一.  (ApplicationContext)的预准备工作</h2>\n<p>ApplicationContext 的预准备工作, 容器刷新前的准备工作<br />\n<code>org.springframework.context.support.AbstractApplicationContext#prepareRefresh</code></p>\n<pre><code class=\"language-java\">/**\n\t * Prepare this context for refreshing, setting its startup date and\n\t * active flag as well as performing any initialization of property sources.\n\t * 容器刷新前的准备工作\n\t * 1. 设置容器的一些状态标志符;设置启动时间, 活动标志符; {@link AbstractApplicationContext#prepareRefresh()}\n\t * 2. 获取或者创建 Environment 对象; 加载 System.getProperties(); {@see AbstractApplicationContext#environment}\n\t * 3. 验证环境是否包含某配置; 手动添加配置. {@link AbstractApplicationContext#initPropertySources()}\n\t * 4. 准备存储 事件监听器 和 事件 的集合容器, 默认为空 {@link AbstractApplicationContext#prepareRefresh()};\n\t */\n\tprotected void prepareRefresh() {\n\t\t// 设置容器的一些状态标志符;设置启动时间, 活动标志符;\n\t\t// Switch to active.\n\t\tthis.startupDate = System.currentTimeMillis();\n\t\tthis.closed.set(false);\n\t\tthis.active.set(true);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Refreshing \" + this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.debug(\"Refreshing \" + getDisplayName());\n\t\t\t}\n\t\t}\n\n\t\t// Initialize any placeholder property sources in the context environment.\n\t\t//留给子类扩展的方法: 验证环境是否包含某配置; 手动添加配置;...\n\t\tinitPropertySources();\n\n\t\t// Validate that all properties marked as required are resolvable:\n\t\t/**\n\t\t *  验证必须的存在的配置. 例如调用 `setRequiredProperties(\"iot.config.thread\")`之后, 在这里会验证是否存在 iot.config.thread 配置,否则会抛出异常 MissingRequiredPropertiesException\n\t\t * \t {@link ConfigurablePropertyResolver#setRequiredProperties(String...) }\n\t\t */\n\t\tgetEnvironment().validateRequiredProperties();\n\n\t\t// s tore pre-refresh ApplicationListeners...\n\t\t//存储监听器的集合初始化; this.earlyApplicationEvents(刷新前的监听器)\n\t\tif (this.earlyApplicationListeners == null) {\n\t\t\t//如果为空,则添加 this.applicationListeners 在boot中是有值的\n\t\t\tthis.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners);\n\t\t}\n\t\telse {\n\t\t\t// 如果不为空, 则清空; 注意这是 content 的复用方法 Refresh()\n\t\t\t// Reset local application listeners to pre-refresh state.\n\t\t\tthis.applicationListeners.clear();\n\t\t\tthis.applicationListeners.addAll(this.earlyApplicationListeners);\n\t\t}\n\n\t\t// Allow for the collection of early ApplicationEvents,\n\t\t// to be published once the multicaster is available...\n\t\tthis.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();\n\t}\n</code></pre>\n<h3 id=\"总结-1\">总结</h3>\n<ol>\n<li>设置容器的一些状态标志符;设置启动时间, 活动标志符;</li>\n<li>获取或者创建 Environment 对象; 加载 System.getProperties();</li>\n<li>验证环境是否包含某配置; 手动添加配置.</li>\n<li>准备存储 事件监听器 和 事件 的集合容器, 默认为空 {@link AbstractApplicationContext#prepareRefresh()};</li>\n</ol>\n<h2 id=\"二-创建-beanfactory---obtainfreshbeanfactory\">二. 创建 BeanFactory - obtainFreshBeanFactory()</h2>\n<h3 id=\"创建-beanfactory\">创建 BeanFactory</h3>\n<p>第一步当然是创建存储Bean的容器啦..<br />\n<code>org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory</code><br />\n<code>org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory</code></p>\n<pre><code class=\"language-java\">/**\n\t * This implementation performs an actual refresh of this context's underlying\n\t * bean factory, shutting down the previous bean factory (if any) and\n\t * initializing a fresh bean factory for the next phase of the context's lifecycle.\n\t */\n\t@Override\n\tprotected final void refreshBeanFactory() throws BeansException {\n\t\t// 如果有 则销毁之前的 BeanFactory\n\t\tif (hasBeanFactory()) {\n\t\t\tdestroyBeans();\n\t\t\tcloseBeanFactory();\n\t\t}\n\t\ttry {\n\t\t\t// &lt;!&gt; 创建 DefaultListableBeanFactory\n\t\t\tDefaultListableBeanFactory beanFactory = createBeanFactory();\n\t\t\t// 设置 beanFactory 序列化ID\n\t\t\tbeanFactory.setSerializationId(getId());\n\t\t\t// 定制化 BeanFactory &lt;!&gt; 可扩展点\n\t\t\tcustomizeBeanFactory(beanFactory);\n\t\t\t/**\n\t\t\t * 加载 BeanDefinitions &lt;!&gt;重点\n\t\t\t * 1. 创建(XML解析器/读取器) XmlBeanDefinitionReader, 并初始化; 留下扩展点, 扩展Reader 例如 是否验证xml等\n\t\t\t * 2. 创建相关对象DocumentLoader, BeanDefinitionDocumentReader,BeanDefinitionParserDelegate\n\t\t\t *    加载解析 XML的标签/元素/属性 等并且将其封装为 一个个 BeanDefinition 对象\n\t\t\t * 3. 将 BeanDefinitions 注册到 registry\n\t\t\t */\n\t\t\tloadBeanDefinitions(beanFactory);\n\t\t\tthis.beanFactory = beanFactory;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex);\n\t\t}\n\t}\n</code></pre>\n<h3 id=\"创建-xmlbeandefinitionreader\">创建 XmlBeanDefinitionReader</h3>\n<p><code>XmlBeanDefinitionReader</code> 这个对象是用来读取 xml 配置的</p>\n<p><code>org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory)</code></p>\n<pre><code class=\"language-java\">/**\n * Loads the bean definitions via an XmlBeanDefinitionReader.\n *\n *  1. 创建(XML解析器/读取器) XmlBeanDefinitionReader {@link AbstractXmlApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory)}\n *    - 给 beanDefinitionReader 设置环境对象, 可以让 XmlBeanDefinitionReader 做变量表达式解析比如 ${jdbc.url}\n *    - 给 beanDefinitionReader 设置 BeanFactory\n * \t  - 给 beanDefinitionReader 设置 要用于解析的SAX实体解析器; (SAX全称 Simple API for XML，既是一种接口，也是一种软件包。它是一种XML解析的替代方法)\n * \t\t\t注意这里加载了两个对象: 1. BeansDtdResolver (XSD,DTD解析器); 2. PluggableSchemaResolver  映射(本地文件xsd检验) 'META-INF/spring.schemas'文件信息\n * \t\t\t例如, context 命名空间xml检验的映射:\n * \t\t\t&lt;code&gt; http\\://www.springframework.org/schema/context/spring-context.xsd=org/springframework/context/config/spring-context.xsd&lt;/code&gt;\n * \t\t\t@see DelegatingEntityResolver#DelegatingEntityResolver(java.lang.ClassLoader)\n * {@link AbstractXmlApplicationContext#initBeanDefinitionReader(XmlBeanDefinitionReader)}\n *  2. 调用扩展点方法, 扩展/定制 XmlBeanDefinitionReader\n *  3. 加载 BeanDefinitions &lt;!&gt;\n *\n * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader\n * @see #initBeanDefinitionReader\n * @see #loadBeanDefinitions\n */\n@Override\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n\t// Create a new XmlBeanDefinitionReader for the given BeanFactory.\n\t/**\n\t * 创建(XML解析器/读取器) XmlBeanDefinitionReader {@link AbstractXmlApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory)}\n\t * 注意传过去的 DefaultListableBeanFactory 它实现了 BeanDefinitionRegistry 作为 Registry 传递进去\n\t * 最后解析出来的 BeanDefinition, 使用该 Registry 作为注册中心\n\t */\n\tXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\t// Configure the bean definition reader with this context's\n\t// resource loading environment.\n\t// 给 beanDefinitionReader 设置环境对象, 可以让 XmlBeanDefinitionReader 做变量表达式解析比如 ${jdbc.url}\n\tbeanDefinitionReader.setEnvironment(getEnvironment());\n\t// 给 beanDefinitionReader 设置 BeanFactory\n\tbeanDefinitionReader.setResourceLoader(this);\n\t/**\n\t * 给 beanDefinitionReader 设置 要用于解析的SAX实体解析器; (SAX全称 Simple API for XML，既是一种接口，也是一种软件包。它是一种XML解析的替代方法)\n\t * \t\t注意这里加载了两个对象: 1. BeansDtdResolver (XSD,DTD解析器); 2. PluggableSchemaResolver  映射(本地文件xsd检验) 'META-INF/spring.schemas'文件信息\n\t * \t\t\t\t例如, context 命名空间xml检验的映射: `http\\://www.springframework.org/schema/context/spring-context.xsd=org/springframework/context/config/spring-context.xsd`\n\t * \t\t使用这两个解析器避免从网络下载DTD或XSD,解析器会根据这些模式定义验证配置文件的结构是否正确。如果验证失败，容器将无法启动\n\t * @see DelegatingEntityResolver#DelegatingEntityResolver(java.lang.ClassLoader)\n\t */\n\tbeanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\n\t// Allow a subclass to provide custom initialization of the reader,\n\t// then proceed with actually loading the bean definitions.\n\t/**\n\t * 调用扩展点方法, 扩展/定制 XmlBeanDefinitionReader {@link AbstractXmlApplicationContext#initBeanDefinitionReader(XmlBeanDefinitionReader)}\n\t */\n\tinitBeanDefinitionReader(beanDefinitionReader);\n\t\n\t/**\n\t * 加载 BeanDefinitions, 并注册到 Registry 中, 这个步骤, 为了复用代码嵌套的方法非常多, 总结一下关键点\n\t * 1. 为了代码复用,多个方法重载 配置文件路径 (String参数), 多配置文件(数组参数) , 在统一转为 `org.springframework.core.io.Resource` 对象去迭代\n\t * \t\t最终读取配置文件的输入流在 {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.support.EncodedResource)}\n\t * 2.\n\t */\n\tloadBeanDefinitions(beanDefinitionReader);\n}\n</code></pre>\n<h4 id=\"自定义命名空间处理器\">自定义命名空间处理器</h4>\n<p>注意一点  <code>XmlBeanDefinitionReader</code> 持有 一个 <code>namespaceHandlerResolver</code>, 默认它的创建逻辑是在<br />\n<code>org.springframework.beans.factory.xml.XmlBeanDefinitionReader#createDefaultNamespaceHandlerResolver</code></p>\n<pre><code class=\"language-java\">\n/**\n\t * Create the default implementation of {@link NamespaceHandlerResolver} used if none is specified.\n\t * &lt;p&gt;The default implementation returns an instance of {@link DefaultNamespaceHandlerResolver}.\n\t * @see DefaultNamespaceHandlerResolver#DefaultNamespaceHandlerResolver(ClassLoader)\n\t */\n\tprotected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() {\n\t\tResourceLoader resourceLoader = getResourceLoader();\n\t\tClassLoader cl = (resourceLoader != null ? resourceLoader.getClassLoader() : getBeanClassLoader());\n\t\t// 解析自定义标签的 NamespaceHandlerResolver 命名空间 handle 映射\n\t\t//\n\t\treturn new DefaultNamespaceHandlerResolver(cl);\n\t}\n</code></pre>\n<h3 id=\"加载-beandefinition-到容器\">加载 BeanDefinition 到容器</h3>\n<p>这一步 为了复用, 嵌套的方法非常多, 这里列出关键方法</p>\n<h4 id=\"转为数组参数迭代\">转为数组参数迭代</h4>\n<p>数组方式迭代以支持多配置文件</p>\n<pre><code class=\"language-java\">\t/**\n\t * Load the bean definitions with the given XmlBeanDefinitionReader.\n\t * &lt;p&gt;The lifecycle of the bean factory is handled by the {@link #refreshBeanFactory}\n\t * method; hence this method is just supposed to load and/or register bean definitions.\n\t *\n\t * 根据资源文件数组迭代加载解析\n\t * \t\t加载 Resource[] 形式的配置文件\n\t * \t\t加载 String[] 形式的配置文件\n\t *\n\t * @param reader the XmlBeanDefinitionReader to use\n\t * @throws BeansException in case of bean registration errors\n\t * @throws IOException if the required XML document isn't found\n\t * @see #refreshBeanFactory\n\t * @see #getConfigLocations\n\t * @see #getResources\n\t * @see #getResourcePatternResolver\n\t */\n\tprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {\n\t\t//加载 Resource[] 形式的配置文件\n\t\tResource[] configResources = getConfigResources();\n\t\tif (configResources != null) {\n\t\t\treader.loadBeanDefinitions(configResources);\n\t\t}\n\t\t//加载 String[] 形式的配置文件\n\t\tString[] configLocations = getConfigLocations();\n\t\tif (configLocations != null) {\n\t\t\treader.loadBeanDefinitions(configLocations);\n\t\t}\n\t}\n</code></pre>\n<h4 id=\"转为-resource\">转为 Resource</h4>\n<p>统一转为 <code>Resource</code> 对象以方便加载</p>\n<pre><code class=\"language-java\">\t/**\n\t * Load bean definitions from the specified resource location.\n\t * &lt;p&gt;The location can also be a location pattern, provided that the\n\t * ResourceLoader of this bean definition reader is a ResourcePatternResolver.\n\t * @param location the resource location, to be loaded with the ResourceLoader\n\t * (or ResourcePatternResolver) of this bean definition reader\n\t * @param actualResources a Set to be filled with the actual Resource objects\n\t * that have been resolved during the loading process. May be {@code null}\n\t * to indicate that the caller is not interested in those Resource objects.\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t * @see #getResourceLoader()\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource)\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])\n\t */\n\tpublic int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException {\n\t\tResourceLoader resourceLoader = getResourceLoader();\n\t\tif (resourceLoader == null) {\n\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\"Cannot load bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n\t\t}\n\t\tif (resourceLoader instanceof ResourcePatternResolver resourcePatternResolver) {\n\t\t\t// Resource pattern matching available.\n\t\t\ttry {\n\t\t\t\t/**\n\t\t\t\t * 对于变量处理 在 {@link org.springframework.context.support.AbstractRefreshableConfigApplicationContext#setConfigLocations(String...)} 已经处理过一遍了, 这里又处理一遍?\n\t\t\t\t *\n\t\t\t\t * 这里的重点是: 将 String 路径 转为Resourced对象, 处不处理变量无所谓, 不是重点\n\t\t\t\t * 处理文件名包含变量表达式的, 例如: application-${active}.xml, 用环境对象变量替换之\n\t\t\t\t */\n\t\t\t\tResource[] resources = resourcePatternResolver.getResources(location);\n\t\t\t\tint count = loadBeanDefinitions(resources);\n\t\t\t\tif (actualResources != null) {\n\t\t\t\t\tCollections.addAll(actualResources, resources);\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Loaded \" + count + \" bean definitions from location pattern [\" + location + \"]\");\n\t\t\t\t}\n\t\t\t\treturn count;\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Can only load single resources by absolute URL.\n\t\t\tResource resource = resourceLoader.getResource(location);\n\t\t\tint count = loadBeanDefinitions(resource);\n\t\t\tif (actualResources != null) {\n\t\t\t\tactualResources.add(resource);\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Loaded \" + count + \" bean definitions from location [\" + location + \"]\");\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t}\n</code></pre>\n<h4 id=\"转为-encodedresource\">转为 EncodedResource</h4>\n<p>转为 <code>EncodedResource</code> 对象以解决编码<br />\n<code>org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource)</code></p>\n<pre><code class=\"language-java\">/**  \n * 将 Resource 包装为 EncodedResource 加载, 应该主要是解决编码的问题  \n * Load bean definitions from the specified XML file.  \n * @param resource the resource descriptor for the XML file  \n * @return the number of bean definitions found  \n * @throws BeanDefinitionStoreException in case of loading or parsing errors  \n */@Override  \npublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {  \n    return loadBeanDefinitions(new EncodedResource(resource));  \n}\n\n</code></pre>\n<h4 id=\"读取配置文件输入流\">读取配置文件输入流</h4>\n<p><code>org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.support.EncodedResource)</code></p>\n<pre><code class=\"language-java\">/**\n\t * 校验一下, 这里解决循环导入\n\t * Load bean definitions from the specified XML file.\n\t * @param encodedResource the resource descriptor for the XML file,\n\t * allowing to specify an encoding to use for parsing the file\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t */\n\tpublic int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n\t\tAssert.notNull(encodedResource, \"EncodedResource must not be null\");\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Loading XML bean definitions from \" + encodedResource);\n\t\t}\n\n\t\t//使用Set存储已加载的配置资源\n\t\tSet&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();\n\n\t\t// 当遇到循环 import definitions 时抛出异常\n\t\tif (!currentResources.add(encodedResource)) {\n\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\");\n\t\t}\n\t\t// 获得配置文件的输入流; 这里真正的开始读\n\t\ttry (InputStream inputStream = encodedResource.getResource().getInputStream()) {\n\t\t\tInputSource inputSource = new InputSource(inputStream);\n\t\t\tif (encodedResource.getEncoding() != null) {\n\t\t\t\tinputSource.setEncoding(encodedResource.getEncoding());\n\t\t\t}\n\t\t\treturn doLoadBeanDefinitions(inputSource, encodedResource.getResource());\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\"IOException parsing XML document from \" + encodedResource.getResource(), ex);\n\t\t}\n\t\tfinally {\n\t\t\tcurrentResources.remove(encodedResource);\n\t\t\tif (currentResources.isEmpty()) {\n\t\t\t\tthis.resourcesCurrentlyBeingLoaded.remove();\n\t\t\t}\n\t\t}\n\t}\n</code></pre>\n<h4 id=\"创建--beandefinitiondocumentreader\">创建  BeanDefinitionDocumentReader</h4>\n<p><code>org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions</code></p>\n<pre><code class=\"language-java\">/**\n\t * Register the bean definitions contained in the given DOM document.\n\t * Called by {@code loadBeanDefinitions}.\n\t * &lt;p&gt;Creates a new instance of the parser class and invokes\n\t * {@code registerBeanDefinitions} on it.\n\t * @param doc the DOM document\n\t * @param resource the resource descriptor (for context information)\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of parsing errors\n\t * @see #loadBeanDefinitions\n\t * @see #setDocumentReaderClass\n\t * @see BeanDefinitionDocumentReader#registerBeanDefinitions\n\t */\n\tpublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {\n\t\t/**\n\t\t *  这里又创建了一个 BeanDefinitionDocumentReader 对象, 用来读取/解析 Document\n\t\t */\n\t\tBeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();\n\t\tint countBefore = getRegistry().getBeanDefinitionCount();\n\n\t\t/**\n\t\t * 解析并注册 bean definitions 到 Registry 中\n\t\t * &lt;br /&gt;\n\t\t * 解析XML自定义标签 需要注意一下, 这里的第2个参数创建的 XmlReaderContext;\n\t\t * \t\t它从这里创建了 {@link XmlBeanDefinitionReader#getNamespaceHandlerResolver()} 命名空间处理器解析器, 后续解析到对应的命名空间处理, 调用其 NamespaceHandler#parse 进行解析\n\t\t * \t\t它默认读取的配置是 `META-INF/spring.handlers`\n\t\t * \t\t例如:\n\t\t * \t\tspring-context 模块的中 `META-INF/spring.handlers` 定义的handles有如下这些\n\t\t * http\\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler\n\t\t * http\\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler\n\t\t * http\\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler\n\t\t * http\\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler\n\t\t * http\\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler\n\t\t *\n\t\t * \t\tspring-aop 模块的中 `META-INF/spring.handlers` 定义的handles有如下这些\n\t\t * http\\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler\n\t\t */\n\t\tdocumentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n\t\t// 返回解析 bean definitions 的数量\n\t\treturn getRegistry().getBeanDefinitionCount() - countBefore;\n\t}\n</code></pre>\n<h4 id=\"递归嵌套加载\">递归嵌套加载</h4>\n<p><code>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions</code></p>\n<pre><code class=\"language-java\">/**\n\t * Register each bean definition within the given root {@code &lt;beans/&gt;} element.\n\t *  在给定的(beans)根元素中注册每个bean定义, 这里的 Element 是 xml 根元素\n\t */\n\t@SuppressWarnings(\"deprecation\")  // for Environment.acceptsProfiles(String...)\n\tprotected void doRegisterBeanDefinitions(Element root) {\n\t\t// Any nested &lt;beans&gt; elements will cause recursion in this method. In\n\t\t// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,\n\t\t// keep track of the current (parent) delegate, which may be null. Create\n\t\t// the new (child) delegate with a reference to the parent for fallback purposes,\n\t\t// then ultimately reset this.delegate back to its original (parent) reference.\n\t\t// this behavior emulates a stack of delegates without actually necessitating one.\n\t\t/**\n\t\t * 在此方法中，任何嵌套的&lt;beans&gt;元素都将导致递归调用\n\t\t *   为了正确地传播和保存&lt;beans&gt;默认属性，请跟踪当前(父)委托(它可能为空)。\n\t\t *   创建新的(子)委托，并将其引用到父(父)委托用于回退目的，然后最终将 this.delegate重置为其原始(父)引用。\n\t\t *   此行为模拟委托堆栈，而实际上不需要委托堆栈。\n\t\t *\n\t\t * 应该是嵌套解析/递归时, 都用这一个 delegate解析, 保存状态, 用于传递上下文的参数;\n\t\t */\n\t\tBeanDefinitionParserDelegate parent = this.delegate;\n\t\t/**\n\t\t * 委托 namespaceHandlerResolver\n\t\t */\n\t\tthis.delegate = createDelegate(getReaderContext(), root, parent);//parent 委派, 上级的parent\n\n\t\t/**\n\t\t * 是否默认命名空间; 这里是 xml 的命名空间解析判断\n\t\t *    简而言之默认命名空间判定是: http://www.springframework.org/schema/beans 或者是 org/springframework/beans/factory/xml/spring-beans.dtd 其DTD定义的标签\n\t\t *    如:\n\t\t *    &lt;beans..&gt;&lt;/beans&gt;, &lt;bean&gt;&lt;/bean&gt;, &lt;import resource=\"\" /&gt; 这些标签是默认命名空间\n\t\t *    &lt;tx:TAG ...&gt; , &lt;aop:TAG ...&gt; 这些标签不是默认命名空间\n\t\t */\n\t\tif (this.delegate.isDefaultNamespace(root)) {\n\t\t\tString profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n\t\t\tif (StringUtils.hasText(profileSpec)) {\n\t\t\t\tString[] specifiedProfiles = StringUtils.tokenizeToStringArray(\n\t\t\t\t\t\tprofileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n\t\t\t\t// We cannot use Profiles.of(...) since profile expressions are not supported\n\t\t\t\t// in XML config. See SPR-12458 for details.\n\t\t\t\tif (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec +\n\t\t\t\t\t\t\t\t\"] not matching: \" + getReaderContext().getResource());\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 前置-钩子方法, 预留扩展, 这里是空实现\n\t\tpreProcessXml(root);\n\t\t// 真正解析逻辑\n\t\tparseBeanDefinitions(root, this.delegate);\n\t\t// 后置-钩子方法, 预留扩展, 这里是空实现\n\t\tpostProcessXml(root);\n\n\t\tthis.delegate = parent;\n\t}\n</code></pre>\n<h4 id=\"解析默认命名空间\">解析默认命名空间</h4>\n<pre><code class=\"language-java\">/**\n\t * Parse the elements at the root level in the document:\n\t * \"import\", \"alias\", \"bean\".\n\t * @param root the DOM root element of the document\n\t */\n\tprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n\t\tif (delegate.isDefaultNamespace(root)) {\n\t\t\tNodeList nl = root.getChildNodes();\n\t\t\tfor (int i = 0; i &lt; nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tif (node instanceof Element ele) {//是否 是元素标签\n\t\t\t\t\t/**\n\t\t\t\t\t * 处理默认命名空间的标签, 有如下四个\n\t\t\t\t\t * &lt;import&gt;&lt;/import&gt;, &lt;alias&gt;&lt;/alias&gt;, &lt;bean&gt;&lt;/bean&gt;, &lt;beans&gt;&lt;/beans&gt;\n\t\t\t\t\t *\n\t\t\t\t\t */\n\t\t\t\t\tif (delegate.isDefaultNamespace(ele)) {\n\t\t\t\t\t\tparseDefaultElement(ele, delegate);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * 处理 非默认命名空间的标签;\n\t\t\t\t\t\t * \t注意这里包括 &lt;context:bean ...&gt; &lt;aop:xx ...&gt; &lt;tx:xx ...&gt; 等等所有指定命名空间的xml配置\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdelegate.parseCustomElement(ele);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdelegate.parseCustomElement(root);\n\t\t}\n\t}\n</code></pre>\n<p><code>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseDefaultElement</code></p>\n<pre><code class=\"language-java\">/**\n\t * 默认命名空间的处理\n\t * @param ele\n\t * @param delegate\n\t */\n\tprivate void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {\n\t\t// 默认命名空间的 import 元素处理\n\t\tif (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n\t\t\timportBeanDefinitionResource(ele);\n\t\t}\n\t\t// 默认命名空间的 alias 元素处理\n\t\telse if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n\t\t\tprocessAliasRegistration(ele);\n\t\t}\n\t\t// 默认命名空间的 bean 元素处理\n\t\telse if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n\t\t\tprocessBeanDefinition(ele, delegate);\n\t\t}\n\t\t// 默认命名空间的 beans 元素处理\n\t\telse if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n\t\t\t// recurse\n\t\t\tdoRegisterBeanDefinitions(ele);\n\t\t}\n\t}\n</code></pre>\n<h4 id=\"解析自定义标签\">解析自定义标签</h4>\n<p><code>org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseCustomElement(org.w3c.dom.Element, org.springframework.beans.factory.config.BeanDefinition)</code></p>\n<pre><code class=\"language-java\">\t/**\n\t * 主要逻辑是 拿到元素的命名空间URI, 再从 XmlReaderContext 找到对应的 NamespaceHandler 调用解析 `parse`方法解析到 BeanDefinition 返回\n\t *  Parse a custom element (outside the default namespace).\n\t * @param ele the element to parse\n\t * @param containingBd the containing bean definition (if any)\n\t * @return the resulting bean definition\n\t */\n\t@Nullable\n\tpublic BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) {\n\t\t//拿到 命名空间URI\n\t\tString namespaceUri = getNamespaceURI(ele);\n\t\tif (namespaceUri == null) {\n\t\t\treturn null;\n\t\t}\n\t\t/**\n\t\t * 拿到对应命名空间的 Handler , this.readerContext 是在\n\t\t * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions(org.w3c.dom.Document, org.springframework.core.io.Resource) 创建的\n\t\t * \t\t它会从父属性的 namespaceHandlerResolver 中拿到命名空间处理器, 调用NamespaceHandler#parse 进行解析\n\t\t * \t\t它默认读取的配置是 `META-INF/spring.handlers` 文件\n\t\t *\n\t\t * spring 对于 注解 AOP TX事务 的支持, 均是同个这种方式扩展的, 但这些不属IOC内容, 本篇不作说明..\n\t\t */\n\t\tNamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n\t\tif (handler == null) {\n\t\t\terror(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele);\n\t\t\treturn null;\n\t\t}\n\t\t// 调用 Handler 解析, 返回的是 BeanDefinition;\n\t\treturn handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));\n\t}\n</code></pre>\n<h4 id=\"注册-beandefinition-到-registry\">注册 BeanDefinition 到 Registry</h4>\n<p><code>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#processBeanDefinition</code></p>\n<pre><code class=\"language-java\">/**\n\t * Process the given bean element, parsing the bean definition\n\t * and registering it with the registry.\n\t *\n\t * - 处理bean元素，解析 BeanDefinition 并将其注册到注册中心。\n\t * - 其实就是往 DefaultListableBeanFactory 的这两个集合属性添加:\n\t * \t\t1. 这个list 存储所有的 bean definition 名称 {@link org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionNames}\n\t * \t\t2. 这个map存储所有的BeanDefinition, key是bean主name, value是BeanDefinition {@link org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap}\n\t */\n\tprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n\t\t/**\n\t\t * 对于 BeanDefinitionHolder 其实它就是一个DTO对象, 它包含以下属性:\n\t\t * \tprivate final BeanDefinition beanDefinition;//Bean  beanDefinition\n\t\t * \tprivate final String beanName; \t\t\t\t//Bean 名称\n\t\t *  private final String[] aliases;\t\t\t\t//Bean 别名列表\n\t\t *\n\t\t */\n\t\tBeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\n\t\t// 此时, 就完成了 对 BeanDefinition 解析了\n\t\tif (bdHolder != null) {\n\t\t\t/**\n\t\t\t * 装饰 BeanDefinition（如果需要）, 类似于:\n\t\t\t * \t\t&lt;bean id=\"user\" class=\"..\"&gt;\n\t\t\t *  \t\t&lt;myBean:user username=\"这是 Spring\"/&gt;\n\t\t\t * \t\t&lt;/bean&gt;\n\t\t\t *  对应`myBean:user` 这种自定义标签进行处理;\n\t\t\t *  后面会找到对应的命名空间 Handler (NamespaceHandler) 进行处理 : NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n\t\t\t */\n\t\t\tbdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n\t\t\ttry {\n\t\t\t\t/**\n\t\t\t\t * 注册到 Registry\n\t\t\t\t */\n\t\t\t\t// Register the final decorated instance.\n\t\t\t\tBeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n\t\t\t}\n\t\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\t\tgetReaderContext().error(\"Failed to register bean definition with name '\" +\n\t\t\t\t\t\tbdHolder.getBeanName() + \"'\", ele, ex);\n\t\t\t}\n\t\t\t// Send registration event.\n\t\t\tgetReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n\t\t}\n\t}\n</code></pre>\n<p><code>org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition</code></p>\n<pre><code class=\"language-java\">/**\n\t * Register the given bean definition with the given bean factory.\n\t * @param definitionHolder the bean definition including name and aliases\n\t * @param registry the bean factory to register with\n\t * @throws BeanDefinitionStoreException if registration failed\n\t */\n\tpublic static void registerBeanDefinition(\n\t\t\tBeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\t// Register bean definition under primary name.\n\t\t/**\n\t\t * 以 beanName 向 Register 注册\n\t\t * 其实就是往 DefaultListableBeanFactory 的这两个集合属性添加:\n\t\t * 1. 这个list 存储所有的 bean definition 名称 {@link org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionNames}\n\t\t * 2. 这个map存储所有的BeanDefinition, key是bean主name, value是BeanDefinition {@link org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap}\n\t\t */\n\t\tString beanName = definitionHolder.getBeanName();\n\t\tregistry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n\n\t\t/**\n\t\t * 向 Register 注册别名列表\n\t\t * 其实就是 {@link org.springframework.core.SimpleAliasRegistry#aliasMap}\n\t\t * 在这个 map存储bean 的别名, key是别名, value 是bean主name;\n\t\t */\n\t\t// Register aliases for bean name, if any.\n\t\tString[] aliases = definitionHolder.getAliases();\n\t\tif (aliases != null) {\n\t\t\tfor (String alias : aliases) {\n\t\t\t\tregistry.registerAlias(beanName, alias);\n\t\t\t}\n\t\t}\n\t}\n</code></pre>\n<p>至此, BeanDefinition 算是成功解析, 并注册到 Register 中了</p>\n<h3 id=\"总结-2\">总结</h3>\n<ol>\n<li>销毁之前的 beanFactory (如果有的话)</li>\n<li>实例化/创建 beanFactory, 这里是实例类是 <code>DefaultListableBeanFactory</code></li>\n<li>设置 beanFactory 忽略  BeanNameAware, BeanClassLoaderAware, BeanFactoryAware这三个Aware的接口 {@link AbstractAutowireCapableBeanFactory#AbstractAutowireCapableBeanFactory()}<br />\n因为在初始化Bean时, 会直接调用它们(而不是通过通过 BeanPostProcessor扩展的Aware机制调用)</li>\n<li>设置 beanFactory 序列化ID, 名称</li>\n<li>扩展点, 定制化这个 BeanFactory 例如: 是否允许 BeanDefinition 覆盖; 是否自动处理循环依赖;</li>\n<li>创建(XML解析器/读取器) XmlBeanDefinitionReader, 并初始化; 留下扩展点, 扩展Reader 例如 是否验证xml等</li>\n<li>创建相关对象DocumentLoader, BeanDefinitionDocumentReader,BeanDefinitionParserDelegate {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions(org.w3c.dom.Document, org.springframework.core.io.Resource)}<br />\n{@link DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions(Element)}<br />\n加载/解析 XML标签/元素/属性等将其封装为 一个个 BeanDefinition 对象</li>\n<li>将 BeanDefinitions 注册到 registry</li>\n</ol>\n<h2 id=\"三-beanfactory预准备工作\">三. (BeanFactory)预准备工作</h2>\n<p><code>org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory</code></p>\n<pre><code class=\"language-java\">\t/**\n\t * Configure the factory's standard context characteristics,\n\t * such as the context's ClassLoader and post-processors.\n\t * @param beanFactory the BeanFactory to configure\n\t */\n\tprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n\t\t// Tell the internal bean factory to use the context's class loader etc.\n\t\t/**\n\t\t * 为 beanFactory 设置 bean 的类加载器\n\t\t */\n\t\tbeanFactory.setBeanClassLoader(getClassLoader());\n\t\t/**\n\t\t * 为 beanFactory 设置 bean 的表达式(Spring EL)解析器\n\t\t * 默认风格是: `#{var}`  当然这些 前缀 后缀都是可以自定义\n\t\t * 关于 (Spring EL)解析器: StandardBeanExpressionResolver 的设计是组合优于继承, 内部有两个 SpelExpressionParser(真正解析的) SpelParserConfiguration(配置类)\n\t\t */\n\t\tbeanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n\n\t\t/**\n\t\t *  为 beanFactory 设置 PropertyEditorRegistrar\n\t\t *  这个主要为 Bean 设置属性的管理类, 比如, 日期类型的数据: 可以是特定格式的字符串, 数字, 还可以是时间戳...\n\t\t *  Spring 为 bean 填充属性, 使用 BeanWrapperImpl 包装了一下(装饰模式)\n\t\t *  BeanWrapperImpl 实现了 PropertyEditorRegistry, 可以往里面注册 PropertyEditor, 可以自定义属性的转换, 编辑逻辑\n\t\t */\n\t\tbeanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n\n\t\t/**\n\t\t * 添加一个 BeanPostProcessor 回调, 作用是如果Bean实现这些接口:\n\t\t * (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||\n\t\t * \t\t\t\tbean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||\n\t\t * \t\t\t\tbean instanceof MessageSourceAware || bean instanceof ApplicationContextAware ||\n\t\t * \t\t\t\tbean instanceof ApplicationStartupAware)\n\t\t *  它负责调用其对应 Aware 的方法, 给Bean 注入对象\n\t\t *\n\t\t * in short 就是给 bean 设置 上下文, 内置的对象; 注意是 (postProcessBeforeInitialization)\n\t\t */\n\t\t// Configure the bean factory with context callbacks.\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n\n\t\t/**\n\t\t * 因为上面由 ApplicationContextAwareProcessor 负责注入 7个接口\n\t\t * 这里就忽略掉这7个接口的自动注入\n\t\t * \t\tEnvironmentAware.class, EmbeddedValueResolverAware.class, ResourceLoaderAware.class,\n\t\t * \t\tApplicationEventPublisherAware.class, MessageSourceAware.class, ApplicationContextAware.class, ApplicationStartupAware.class\n\t\t */\n\t\tbeanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n\t\tbeanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);\n\n\t\t/**\n\t\t * 类似 @Primary, 当有多个的相同类型的时候, 指定谁优先注入\n\t\t * 指定内置的 BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContext\n\t\t *  几个Bean对象,  自动注入的 Primary\n\t\t * registerResolvableDependency\n\t\t */\n\t\t// BeanFactory interface not registered as resolvable type in a plain factory.\n\t\t// MessageSource registered (and found for autowiring) as a bean.\n\t\tbeanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n\t\tbeanFactory.registerResolvableDependency(ResourceLoader.class, this);\n\t\tbeanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n\t\tbeanFactory.registerResolvableDependency(ApplicationContext.class, this);\n\n\t\t// Register early post-processor for detecting inner beans as ApplicationListeners.\n\t\t/**\n\t\t * TODO 时间监听器相关\n\t\t */\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n\n\t\t/**\n\t\t * TODO  这里是 AOP AspectJ处理\n\t\t * LoadTimeWeaver (AOP的加载时织入)\n\t\t */\n\t\t// Detect a LoadTimeWeaver and prepare for weaving, if found.\n\t\tif (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n\t\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n\t\t\t// Set a temporary ClassLoader for type matching.\n\t\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n\t\t}\n\n\t\t/**\n\t\t * beanFactory 中如果没有以下这些名称的 bean 则 直接给 BeanFactory 的一级缓存, 注册几个默认环境 Bean\n\t\t */\n\t\t// Register default environment beans.\n\t\tif (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n\t\t\tbeanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n\t\t}\n\t\tif (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n\t\t\tbeanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n\t\t}\n\t\tif (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n\t\t\tbeanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n\t\t}\n\t\tif (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) {\n\t\t\tbeanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());\n\t\t}\n\t}\n</code></pre>\n<h3 id=\"总结-3\">总结</h3>\n<p>{@link AbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory)}</p>\n<ol>\n<li>为 beanFactory 设置 bean 的类加载器</li>\n<li>为 beanFactory 设置 bean 的 StandardBeanExpressionResolver (表达式(Spring EL)解析器) {@link ConfigurableBeanFactory#setBeanExpressionResolver(BeanExpressionResolver)}<br />\n关于 (Spring EL)解析器: StandardBeanExpressionResolver 的设计是组合优于继承, 内部有两个 SpelExpressionParser(真正解析的) SpelParserConfiguration(配置类)</li>\n<li>为 beanFactory 设置 PropertyEditorRegistrar (主要为 Bean 设置属性的管理类){@link ConfigurableBeanFactory#addPropertyEditorRegistrar(PropertyEditorRegistrar)}<br />\nPropertyEditorRegistrar 这个主要为 Bean 设置属性的管理类, 比如, 日期类型的数据: 可以是特定格式的字符串, 数字, 还可以是时间戳...<br />\nSpring 为 bean 填充属性, 使用 BeanWrapperImpl 包装了一下(装饰模式)<br />\nBeanWrapperImpl 实现了 PropertyEditorRegistry, 可以往里面注册 PropertyEditor, 可以自定义属性的转换, 编辑逻辑</li>\n<li>给 beanFactory 添加一个 处理Aware的 BeanPostProcessor (ApplicationContextAwareProcessor) 并忽略掉这7个接口的自动注入:{@link ConfigurableBeanFactory#addBeanPostProcessor(BeanPostProcessor)}<br />\nEnvironmentAware.class, EmbeddedValueResolverAware.class, ResourceLoaderAware.class, ApplicationEventPublisherAware.class, MessageSourceAware.class, ApplicationContextAware.class, ApplicationStartupAware.class</li>\n<li>指定内置的 BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContext {@link ConfigurableListableBeanFactory#registerResolvableDependency(Class, Object)}<br />\n这几个Bean对象,  自动注入的 Primary</li>\n<li>给 beanFactory 添加一个 BeanPostProcessor (ApplicationListenerDetector)TODO (事件监听相关)</li>\n<li>给 beanFactory 添加一个 BeanPostProcessor(LoadTimeWeaverAwareProcessor) TODO (AOP AspectJ 织入处理相关的)</li>\n<li>beanFactory中如果没有以下名称的bean, 则直接给 BeanFactory 的一级缓存, 注册几个环境对象 Bean {@link SingletonBeanRegistry#registerSingleton(String, Object)}<br />\n名称常量分别是:<br />\norg.springframework.context.ConfigurableApplicationContext#ENVIRONMENT_BEAN_NAME<br />\norg.springframework.context.ConfigurableApplicationContext#SYSTEM_PROPERTIES_BEAN_NAME<br />\norg.springframework.context.ConfigurableApplicationContext#SYSTEM_ENVIRONMENT_BEAN_NAME<br />\norg.springframework.context.ConfigurableApplicationContext#APPLICATION_STARTUP_BEAN_NAME</li>\n</ol>\n<h2 id=\"四-postprocessbeanfactory-扩展点调用\">四. postProcessBeanFactory 扩展点调用</h2>\n<p>beanFactory 已经准备好了, 给子类(Context)预留一个扩展点;</p>\n<p><code>org.springframework.context.support.AbstractApplicationContext#postProcessBeanFactory</code> (这里是空实现)</p>\n<pre><code class=\"language-java\">/**\n * Modify the application context's internal bean factory after its standard\n * initialization. The initial definition resources will have been loaded but no\n * post-processors will have run and no derived bean definitions will have been\n * registered, and most importantly, no beans will have been instantiated yet.\n * &lt;p&gt;This template method allows for registering special BeanPostProcessors\n * etc in certain AbstractApplicationContext subclasses.\n * @param beanFactory the bean factory used by the application context\n */\nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n}\n</code></pre>\n<h2 id=\"五-调用-beanfactorypostprocessor-处理器\">五. 调用 BeanFactoryPostProcessor 处理器</h2>\n<p><code>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors</code></p>\n<pre><code class=\"language-java\">/**\n\t * Instantiate and invoke all registered BeanFactoryPostProcessor beans,\n\t * respecting explicit order if given.\n\t * &lt;p&gt;Must be called before singleton instantiation.\n\t */\n\tprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n\t\t/**\n\t\t * 调用 BeanFactory 内的所有 BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor\n\t\t */\n\t\tPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n\n\t\t/**\n\t\t * LOAD_TIME_WEAVER_BEAN_NAME bean 是AOP相关的.\n\t\t * 在 GraalVM 中能编译为本地代码, 不支持AOP的\n\t\t */\n\t\t// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n\t\t// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n\t\tif (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.getTempClassLoader() == null &amp;&amp;\n\t\t\t\tbeanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {//这里 beanFactory 不包含 LOAD_TIME_WEAVER_BEAN_NAME\n\t\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n\t\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n\t\t}\n\t}\n</code></pre>\n<p><code>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)</code></p>\n<pre><code class=\"language-java\">\t/**\n\t * 注意一点 BeanDefinitionRegistryPostProcessor 是继承自 BeanFactoryPostProcessor的\n\t * 总的来说, 调用的时候优先级是:\n\t * 1. 调用接口的优先级\n\t * 优先调用(子类) BeanDefinitionRegistryPostProcessor\n\t * 再调用(父类) BeanFactoryPostProcessor\n\t *\n\t * 2. 调用添加的方式的优先级\n\t * 优先调用外部入参类, 即直接通过 {@link AbstractApplicationContext#addBeanFactoryPostProcessor(org.springframework.beans.factory.config.BeanFactoryPostProcessor)} 代码添加的\n\t * 再调用容器中 实现 BeanFactoryPostProcessor或者 BeanDefinitionRegistryPostProcessor 的 Bean\n\t */\n\tpublic static void invokeBeanFactoryPostProcessors(\n\t\t\tConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {\n\n\t\t// WARNING: Although it may appear that the body of this method can be easily\n\t\t// refactored to avoid the use of multiple loops and multiple lists, the use\n\t\t// of multiple lists and multiple passes over the names of processors is\n\t\t// intentional. We must ensure that we honor the contracts for PriorityOrdered\n\t\t// and Ordered processors. Specifically, we must NOT cause processors to be\n\t\t// instantiated (via getBean() invocations) or registered in the ApplicationContext\n\t\t// in the wrong order.\n\t\t//\n\t\t// Before submitting a pull request (PR) to change this method, please review the\n\t\t// list of all declined PRs involving changes to PostProcessorRegistrationDelegate\n\t\t// to ensure that your proposal does not result in a breaking change:\n\t\t// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22\n\n\t\t// Invoke BeanDefinitionRegistryPostProcessors first, if any.\n\t\t/**\n\t\t * 存储已经调用 BeanDefinitionRegistryPostProcessor 过的 bean name\n\t\t * 避免重复处理\n\t\t */\n\t\tSet&lt;String&gt; processedBeans = new HashSet&lt;&gt;();\n\n\t\tif (beanFactory instanceof BeanDefinitionRegistry registry) {\n\n\t\t\t/**\n\t\t\t * 存储 BeanFactoryPostProcessor 的集合, 后面统一调用\n\t\t\t */\n\t\t\tList&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();\n\n\t\t\t/**\n\t\t\t * 存储已经调用过的 BeanDefinitionRegistryPostProcessor 集合\n\t\t\t */\n\t\t\tList&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();\n\n\t\t\t/**\n\t\t\t * 先调用外部入参的 BeanDefinitionRegistryPostProcessor (代码添加的)\n\t\t\t */\n\t\t\tfor (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\n\t\t\t\tif (postProcessor instanceof BeanDefinitionRegistryPostProcessor registryProcessor) {\n\t\t\t\t\t// 这就调了\n\t\t\t\t\tregistryProcessor.postProcessBeanDefinitionRegistry(registry);\n\t\t\t\t\t// 是 BeanDefinitionRegistryPostProcessor 接口 存入registryProcessors\n\t\t\t\t\tregistryProcessors.add(registryProcessor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// 不是 BDRPP  是 BeanFactoryPostProcessor(BFPP) 存入regularPostProcessors, 后面在统一调用\n\t\t\t\t\tregularPostProcessors.add(postProcessor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t\t// uninitialized to let the bean factory post-processors apply to them!\n\t\t\t// Separate between BeanDefinitionRegistryPostProcessors that implement\n\t\t\t// PriorityOrdered, Ordered, and the rest.\n\t\t\t/**\n\t\t\t * 当前将调用的 BeanDefinitionRegistryPostProcessor 集合\n\t\t\t */\n\t\t\tList&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();\n\n\t\t\t// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n\t\t\t// 1. 先调用 实现PriorityOrdered (排序)的 BDRPP\n\t\t\tString[] postProcessorNames =\n\t\t\t\t\tbeanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\t\t//&lt;!&gt; beanFactory.getBean, 先走实例化bean流程;\n\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//排序\n\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\t//调用 BDRPP\n\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());\n\t\t\t//调完了就清调\n\t\t\tcurrentRegistryProcessors.clear();\n\n\t\t\t// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n\t\t\t// 2. 再调用 实现 Ordered (排序)的 BDRPP\n\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\tif (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());\n\t\t\tcurrentRegistryProcessors.clear();\n\n\t\t\t// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n\t\t\t// 3. 再调用在容器中实现 BeanDefinitionRegistryPostProcessors (BDRPP)的\n\t\t\tboolean reiterate = true;\n\t\t\twhile (reiterate) {\n\t\t\t\treiterate = false;\n\t\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\t\tif (!processedBeans.contains(ppName)) {\n\t\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t\t\treiterate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());\n\t\t\t\tcurrentRegistryProcessors.clear();\n\t\t\t}\n\t\t\t// Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n\t\t\tinvokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n\t\t\t// 3. 最后再调用BeanFactoryPostProcessor(BFPP)\n\t\t\tinvokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n\t\t}\n\n\t\telse {\n\t\t\t// Invoke factory processors registered with the context instance.\n\t\t\tinvokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n\t\t}\n\n\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t// uninitialized to let the bean factory post-processors apply to them!\n\t\tString[] postProcessorNames =\n\t\t\t\tbeanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n\t\t// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n\t\t// Ordered, and the rest.\n\t\tList&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();\n\t\tList&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();\n\t\tList&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();\n\t\tfor (String ppName : postProcessorNames) {\n\t\t\tif (processedBeans.contains(ppName)) {\n\t\t\t\t// skip - already processed in first phase above\n\t\t\t}\n\t\t\telse if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\tpriorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n\t\t\t}\n\t\t\telse if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\torderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnonOrderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t}\n\n\t\t// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\t\tinvokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n\t\t// Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n\t\tList&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size());\n\t\tfor (String postProcessorName : orderedPostProcessorNames) {\n\t\t\torderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n\t\t}\n\t\tsortPostProcessors(orderedPostProcessors, beanFactory);\n\t\tinvokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n\t\t// Finally, invoke all other BeanFactoryPostProcessors.\n\t\tList&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());\n\t\tfor (String postProcessorName : nonOrderedPostProcessorNames) {\n\t\t\tnonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n\t\t}\n\t\tinvokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n\n\t\t// Clear cached merged bean definitions since the post-processors might have\n\t\t// modified the original metadata, e.g. replacing placeholders in values...\n\t\tbeanFactory.clearMetadataCache();\n\t}\n</code></pre>\n<h3 id=\"总结-4\">总结</h3>\n<p>若是注册的bean definition 实现了这两个接口, 则会调用(getBean)实例化它, 再调用相应的接口方法;<br />\n(注意一下 BeanDefinitionRegistryPostProcessor 是继承自 BeanFactoryPostProcessor的)<br />\n总的来说 调用的优先级是:</p>\n<ol>\n<li>调用接口的优先级:\n<ol>\n<li>优先调用(子类) BeanDefinitionRegistryPostProcessor</li>\n<li>再调用(父类) BeanFactoryPostProcessor</li>\n</ol>\n</li>\n<li>调用添加的方式的优先级:\n<ol>\n<li>优先调用外部入参, 即直接通过{@link AbstractApplicationContext#addBeanFactoryPostProcessor(org.springframework.beans.factory.config.BeanFactoryPostProcessor)} 代码添加的</li>\n<li>再调用容器中实现 BeanFactoryPostProcessor 或者 BeanDefinitionRegistryPostProcessor 的 Bean<br />\n见:</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>值得一提的是:  Spring 对于支持 SPEL表达式, 就是通过 <code>PropertySourcesPlaceholderConfigurer</code> 这种方式扩展实现的</p>\n</blockquote>\n<h2 id=\"六-注册-beanpostprocessor-bpp处理器\">六. 注册 BeanPostProcessor (BPP)处理器</h2>\n<p><code>org.springframework.context.support.AbstractApplicationContext#registerBeanPostProcessors</code><br />\n<code>org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext)</code></p>\n<pre><code class=\"language-java\">/**\n\t *  in short:\n\t *  1. 拿到所有实现 BeanPostProcessor 的 bean, 然后进行分类存起来\n\t *  这有一点, Spring 对 BeanDefinition 分成三种角色:\n\t *  \t1. 用户定义的 Bean (ROLE_APPLICATION)\n\t *      2. 较复杂的 (ROLE_SUPPORT) 较复杂的? 通常是一个外部配置\n\t *      3. Spring 内置的(ROLE_INFRASTRUCTURE)\n\t *  2. 如果实现了 BeanPostProcessor 则会实例化这个bean, 但注意这里只是注册,并不会调用BeanPostProcessor的相关方法\n\t *\n\t *  另外 BeanPostProcessor 粗粒度太大, Spring 还细分一些子接口:\n\t *  - SmartInstantiationAwareBeanPostProcessor 它提供了更高级的Bean实例化控制方法。主要作用在于允许对Bean的实例化过程进行更精细的控制和定制。\n\t *  - MergedBeanDefinitionPostProcessor 在合并Bean定义（MergedBeanDefinition）之后但在实例化Bean之前，允许对合并后的Bean定义进行修改、调整或附加元数据。\n\t *  - DestructionAwareBeanPostProcessor 它允许在Bean被销毁之前（例如，容器关闭或特定作用域的Bean销毁）执行一些操作。\n\t */\n\tpublic static void registerBeanPostProcessors(\n\t\t\tConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n\n\t\t// WARNING: Although it may appear that the body of this method can be easily\n\t\t// refactored to avoid the use of multiple loops and multiple lists, the use\n\t\t// of multiple lists and multiple passes over the names of processors is\n\t\t// intentional. We must ensure that we honor the contracts for PriorityOrdered\n\t\t// and Ordered processors. Specifically, we must NOT cause processors to be\n\t\t// instantiated (via getBean() invocations) or registered in the ApplicationContext\n\t\t// in the wrong order.\n\t\t//\n\t\t// Before submitting a pull request (PR) to change this method, please review the\n\t\t// list of all declined PRs involving changes to PostProcessorRegistrationDelegate\n\t\t// to ensure that your proposal does not result in a breaking change:\n\t\t// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22\n\t\t/**\n\t\t * 拿到所有实现 BeanPostProcessor 的 bean名称\n\t\t */\n\t\tString[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\n\n\t\t// Register BeanPostProcessorChecker that logs an info message when\n\t\t// a bean is created during BeanPostProcessor instantiation, i.e. when\n\t\t// a bean is not eligible for getting processed by all BeanPostProcessors.\n\t\t/**\n\t\t * 计算 BeanPostProcessor(BPP) 的总数.\n\t\t * +1 是什么操作? 原因是: 下一行,又加了一个 BeanPostProcessorChecker\n\t\t */\n\t\tint beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n\t\t// BeanPostProcessorChecker 这个BeanPostProcessor, 没啥实际作用, 就是记录了一些日志;\n\t\tbeanFactory.addBeanPostProcessor(\n\t\t\t\tnew BeanPostProcessorChecker(beanFactory, postProcessorNames, beanProcessorTargetCount));\n\t\t// Separate between BeanPostProcessors that implement PriorityOrdered,\n\t\t// Ordered, and the rest.\n\t\t/**\n\t\t * 对 BeanPostProcessor 进行分类存起来,  再调用, 每个集合分别是\n\t\t * 1. priorityOrderedPostProcessors //有实现(PriorityOrdered)排序接口的\n\t\t * 2. internalPostProcessors //Spring内部的bean, 见: Spring将bean分为三种角色\n\t\t * 3. orderedPostProcessorNames //实现 Ordered 接口\n\t\t * 4. nonOrderedPostProcessorNames //没有指定顺序, 无序的\n\t\t */\n\t\tList&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();\n\t\tList&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();\n\t\tList&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();\n\t\tList&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();\n\t\tfor (String ppName : postProcessorNames) {\n\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\t/**\n\t\t\t\t * 注意, 若 bean 实现了 PriorityOrdered 接口, 则会优先实例化它;\n\t\t\t\t */\n\t\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\t\tpriorityOrderedPostProcessors.add(pp);\n\t\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\torderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnonOrderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t}\n\n\t\t// First, register the BeanPostProcessors that implement PriorityOrdered.\n\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n\n\t\t// Next, register the BeanPostProcessors that implement Ordered.\n\t\tList&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size());\n\t\tfor (String ppName : orderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\torderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n\t\tsortPostProcessors(orderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, orderedPostProcessors);\n\n\t\t/**\n\t\t * 注册所有常规BeanPostProcessors\n\t\t * 这里 getBean 实例化bean !;\n\t\t */\n\t\t// Now, register all regular(常规) BeanPostProcessors.\n\t\tList&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());\n\t\tfor (String ppName : nonOrderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\tnonOrderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n\t\tregisterBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n\n\t\t/**\n\t\t * 最后, 注册所有 内置 BeanPostProcessor\n\t\t */\n\t\t// Finally, re-register all internal BeanPostProcessors.\n\t\tsortPostProcessors(internalPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, internalPostProcessors);\n\n\t\t//最后再放一个 ApplicationListenerDetector 让它在最后 (不是重点, 见名应该是事件相关的)\n\t\t// Re-register post-processor for detecting inner beans as ApplicationListeners,\n\t\t// moving it to the end of the processor chain (for picking up proxies etc).\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n\t}\n</code></pre>\n<h3 id=\"总结-5\">总结</h3>\n<ol>\n<li>拿到所有 BeanPostProcessor 类型的 bean</li>\n<li>实例化 BeanPostProcessor<br />\n优先实例化 实现了 PriorityOrdered 接口的, 在实例化其它的(BPP)</li>\n<li>进行分类存到集合 {@link PostProcessorRegistrationDelegate#registerBeanPostProcessors(ConfigurableListableBeanFactory, AbstractApplicationContext)}<br />\n对 BeanPostProcessor 进行分类存起来,  再调用, 每个集合分别是\n<ol>\n<li>priorityOrderedPostProcessors //有实现(PriorityOrdered)排序接口的</li>\n<li>internalPostProcessors //Spring内部的bean, 见: Spring将bean分为三种角色</li>\n<li>orderedPostProcessorNames //实现 Ordered 接口</li>\n<li>nonOrderedPostProcessorNames //没有指定顺序, 无序的<br />\n这有一点, Spring 对 BeanDefinition 分成三种角色:\n<ul>\n<li>用户定义的 业务相关的 Bean Bean (ROLE_APPLICATION)</li>\n<li>较复杂的 (ROLE_SUPPORT) 较复杂的, 支持 AOP、事务等功能的内部实现?  (不重要, 不要每一个细节都扣...)</li>\n<li>Spring 内置的(ROLE_INFRASTRUCTURE)</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>排序并注册到 beanFactory\n<ol>\n<li>这里按实现(PriorityOrdered)排序接口的、@Ordered注解的 等排序存起来. 实际调用的顺序 其实就是存起来的顺序</li>\n<li>另外 BeanPostProcessor 接口粗粒度太大了, Spring 还细分一些子接口:\n<ol>\n<li>SmartInstantiationAwareBeanPostProcessor 它提供了更高级的Bean实例化控制方法。主要作用在于允许对Bean的实例化过程进行更精细的控制和定制。</li>\n<li>MergedBeanDefinitionPostProcessor 在合并Bean定义（MergedBeanDefinition）之后但在实例化Bean之前，允许对合并后的Bean定义进行修改、调整或附加元数据。</li>\n<li>DestructionAwareBeanPostProcessor 它允许在Bean被销毁之前（例如，容器关闭或特定作用域的Bean销毁）执行一些操作。<br />\n等等以上也会存起来</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>最终调用 BPP是在 {@link AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory)} 实例初始化其他Bean调用</li>\n</ol>\n<h2 id=\"七-初始化国际化i18n-信息源\">七. 初始化国际化(I18N) 信息源</h2>\n<p><code>org.springframework.context.support.AbstractApplicationContext#initMessageSource</code></p>\n<pre><code class=\"language-java\">/**\n\t * Initialize the MessageSource.\n\t * Use parent's if none defined in this context.\n\t * 主要是对I18N国际化的处理，\n\t */\n\tprotected void initMessageSource() {\n\t\t/**\n\t\t * //拿到 bean factory\n\t\t */\n\t\tConfigurableListableBeanFactory beanFactory = getBeanFactory();\n\t\t/**\n\t\t * 是否有定义名称为 MESSAGE_SOURCE_BEAN_NAME 的 Bean\n\t\t *  {@link org.springframework.context.support.AbstractApplicationContext#MESSAGE_SOURCE_BEAN_NAME }\n\t\t */\n\t\tif (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {\n\t\t\tthis.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);\n\t\t\t// Make MessageSource aware of parent MessageSource.\n\t\t\tif (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource hms &amp;&amp;\n\t\t\t\t\thms.getParentMessageSource() == null) {\n\t\t\t\t// Only set parent context as parent MessageSource if no parent MessageSource\n\t\t\t\t// registered already.\n\t\t\t\t/**\n\t\t\t\t * 如果有的话，就使用该定义的MessageSource 处理消息国际化\n\t\t\t\t */\n\t\t\t\thms.setParentMessageSource(getInternalParentMessageSource());\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Using MessageSource [\" + this.messageSource + \"]\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/**\n\t\t\t *  如果没有 MESSAGE_SOURCE_BEAN_NAME 则默认使用 DelegatingMessageSource;\n\t\t\t *  注册到 beanFactory\n\t\t\t */\n\t\t\t// Use empty MessageSource to be able to accept getMessage calls.\n\t\t\tDelegatingMessageSource dms = new DelegatingMessageSource();\n\t\t\tdms.setParentMessageSource(getInternalParentMessageSource());\n\t\t\t//注意这 Context属性\n\t\t\tthis.messageSource = dms;\n\t\t\tbeanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No '\" + MESSAGE_SOURCE_BEAN_NAME + \"' bean, using [\" + this.messageSource + \"]\");\n\t\t\t}\n\t\t}\n\t}\n</code></pre>\n<h3 id=\"总结-6\">总结</h3>\n<p>很简单:</p>\n<ol>\n<li>如果beanFactory中有名称为 messageSource 的Bean定义，就使用这bean作物国际化消息源<br />\n如果没有则默认使用 org.springframework.context.support.DelegatingMessageSource 并注册到 beanFactory</li>\n</ol>\n<p><s>用于国际化的, 不重要, 本屌作为社会底层牛马, 暂未做过跨国项目</s></p>\n<h2 id=\"八-初始化事件多播器\">八. 初始化事件多播器</h2>\n<p><code>org.springframework.context.support.AbstractApplicationContext#initApplicationEventMulticaster</code></p>\n<pre><code class=\"language-java\">\t/**\n\t * Initialize the ApplicationEventMulticaster.\n\t * Uses SimpleApplicationEventMulticaster if none defined in the context.\n\t * @see org.springframework.context.event.SimpleApplicationEventMulticaster\n\t */\n\tprotected void initApplicationEventMulticaster() {\n\t\tConfigurableListableBeanFactory beanFactory = getBeanFactory();\n\t\t/**\n\t\t * 1. 如果 beanFactory 中包含名称为 APPLICATION_EVENT_MULTICASTER_BEAN_NAME的bean定义, 则使用这个 ApplicationEventMulticaster 作为 事件多播器\n\t\t * 如果不包含则创建 SimpleApplicationEventMulticaster作为事件多播器;\n\t\t */\n\t\tif (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {\n\t\t\tthis.applicationEventMulticaster =\n\t\t\t\t\tbeanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Using ApplicationEventMulticaster [\" + this.applicationEventMulticaster + \"]\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/**\n\t\t\t * 2. 创建 SimpleApplicationEventMulticaster 作为默认的事件多播器 (Event Channel)\n\t\t\t *  其实就是初始化了一个 用于存放/管理 ApplicationListener 监听器(观察者)的类\n\t\t\t *   在Spring 事件机制中, 在容器发布事件时 `this.applicationEventMulticaster.multicastEvent(new ObjectEvent());`\n\t\t\t *  @see org.springframework.context.event.AbstractApplicationEventMulticaster#defaultRetriever 用户存放/管理 各个监听器的(观察者)\n\t\t\t *  @see AbstractApplicationContext#publishEvent(Object, ResolvableType) 调用容器发布事件\n\t\t\t *\n\t\t\t *  这个 applicationEventMulticaster 除了在容器发布事件时用它, 在注册监听器时直接用它 {@link AbstractApplicationContext#registerListeners()}\n\t\t\t */\n\t\t\tthis.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);\n\t\t\t/**\n\t\t\t * 将其注册到 beanFactory;\n\t\t\t * 注意 这是实例, 它直接放到一级缓存中.\n\t\t\t */\n\t\t\tbeanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No '\" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + \"' bean, using \" +\n\t\t\t\t\t\t\"[\" + this.applicationEventMulticaster.getClass().getSimpleName() + \"]\");\n\t\t\t}\n\t\t}\n\t}\n</code></pre>\n<h3 id=\"总结-7\">总结</h3>\n<ol>\n<li>如果 beanFactory 中包含名称为 applicationEventMulticaster 的bean定义, 则使用这个Bean作为事件多播器;<br />\n如果不包含则创建 SimpleApplicationEventMulticaster作为事件多播器;</li>\n<li>创建SimpleApplicationEventMulticaster其实就是初始化了一个,用于存放/管理 ApplicationListener 监听器(观察者)的类, 并注册到 beanFactory</li>\n</ol>\n<ul>\n<li>主要是 {@link org.springframework.context.event.AbstractApplicationEventMulticaster#defaultRetriever} 用于存放/管理 各个监听器的(观察者)</li>\n<li>{@link org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType) }调用容器发布事件</li>\n</ul>\n<p>参考此前的博客 - <a href=\"https://www.cnblogs.com/dddy/p/19191523\" target=\"_blank\" title=\"发布于 2025-11-04 22:25\">Spring 中的Event机制</a></p>\n<h2 id=\"九-给子类context留下一个扩展点\">九. 给子类(Context)留下一个扩展点</h2>\n<p>没什么好说的, 这里是空实现</p>\n<p><code>org.springframework.context.support.AbstractApplicationContext#onRefresh</code></p>\n<pre><code class=\"language-java\">/**\n * Template method which can be overridden to add context-specific refresh work.\n * Called on initialization of special beans, before instantiation of singletons.\n * &lt;p&gt;This implementation is empty.\n * @throws BeansException in case of errors\n * @see #refresh()\n */\nprotected void onRefresh() throws BeansException {\n\t// For subclasses: do nothing by default.\n}\n</code></pre>\n<h2 id=\"十-向多播器注册监听器\">十. 向多播器注册监听器</h2>\n<p><code>org.springframework.context.support.AbstractApplicationContext#registerListeners</code></p>\n<pre><code class=\"language-java\">/**\n\t * Add beans that implement ApplicationListener as listeners.\n\t * Doesn't affect other listeners, which can be added without being beans.\n\t */\n\tprotected void registerListeners() {\n\t\t/**\n\t\t * 1. 向多播器中注册 在context中的监听器(观察者)\n\t\t */\n\t\t// Register statically specified listeners first.\n\t\tfor (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) {\n\t\t\tgetApplicationEventMulticaster().addApplicationListener(listener);\n\t\t}\n\n\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t// uninitialized to let post-processors apply to them!\n\t\t/**\n\t\t *  2. 向多播器中注册 在beanFactory中的bean是监听器(ApplicationListener.class)的(观察者)\n\t\t *  注意:\n\t\t *  2.1 这里是会先从 BeanFactory (getBeanNamesForType)获取是 ApplicationListener.class 的 bean name\n\t\t *  2.2 注意只是查找匹配类型的 bean 名称, 没有实例化 存的也是 bean name;\n\t\t */\n\t\tString[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);\n\t\tfor (String listenerBeanName : listenerBeanNames) {\n\t\t\tgetApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n\t\t}\n\n\t\t/**\n\t\t * 3. 广播 this.earlyApplicationEvents 属性中的事件;\n\t\t * 为什么?\n\t\t * 因为有可能 在容器生命周期中调用了当前 `AbstractApplicationContext#publishEvent` 发布事件, 但是多播器没有初始化完成, 所以会将事件存在this.earlyApplicationEvents 中;\n\t\t * 待容器初始化完成后, \t在流程  {@link org.springframework.context.support.AbstractApplicationContext#registerListeners()} 中会发布存在这里面的事件\n\t\t * (例如: 在 BeanFactoryPostProcessor 的业务逻辑触发容器的广播事件, 这时候多播器都不存在, 也不知道有哪些 bean作为观察者)\n\t\t * @see AbstractApplicationContext#prepareRefresh()\n\t\t */\n\t\t// Publish early application events now that we finally have a multicaster...\n\t\tSet&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;\n\t\tthis.earlyApplicationEvents = null;//下一步 multicastEvent 后就没用了, 赋 null 释放资源.\n\t\tif (!CollectionUtils.isEmpty(earlyEventsToProcess)) {\n\t\t\tfor (ApplicationEvent earlyEvent : earlyEventsToProcess) {\n\t\t\t\tgetApplicationEventMulticaster().multicastEvent(earlyEvent);\n\t\t\t}\n\t\t}\n\t}\n</code></pre>\n<h3 id=\"总结-8\">总结</h3>\n<ol>\n<li>向多播器中注册 在context中的监听器(观察者);</li>\n<li>向多播器中注册 在beanFactory中的bean是监听器(ApplicationListener.class)的(观察者)</li>\n<li>广播 this.earlyApplicationEvents 属性中的事件;<br />\n为什么?\n<ul>\n<li>因为有可能 在容器生命周期中调用了当前 <code>AbstractApplicationContext#publishEvent</code> 发布事件, 但是多播器没有初始化完成, 所以会将事件存在this.earlyApplicationEvents 中;  这里多播器已经准备 会发布存在这里面的事件 (例如: 在 BeanFactoryPostProcessor 的业务逻辑触发容器的广播事件, 这时候多播器都不存在)</li>\n</ul>\n<ul>\n<li>@see AbstractApplicationContext#prepareRefresh()</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"十一-实例化剩下的所有单例bean\">十一. 实例化剩下的所有单例bean</h2>\n<h3 id=\"准备类型转换器-变量解析器等\">准备类型转换器 变量解析器等</h3>\n<p><code>org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</code></p>\n<pre><code class=\"language-java\">/**\n\t * Finish the initialization of this context's bean factory,\n\t * initializing all remaining singleton beans.\n\t */\n\tprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n\t\t// Initialize conversion service for this context.\n\t\t/**\n\t\t *\n\t\t * 1. 为 beanFactory 初始化类型转换器(ConversionService)\n\t\t *   注意: 在 Spring 中`ConversionService` 是用于类型转换的服务接口, 它是转换类型的入口点, 但是真正的转换逻辑功能 则由 Converter 和 GenericConverter 接口的实现处理的\n\t\t */\n\t\tif (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;\n\t\t\t\tbeanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n\t\t\tbeanFactory.setConversionService(\n\t\t\t\t\tbeanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n\t\t}\n\n\t\t// Register a default embedded value resolver if no BeanFactoryPostProcessor\n\t\t// (such as a PropertySourcesPlaceholderConfigurer bean) registered any before:\n\t\t// at this point, primarily for resolution in annotation attribute values.\n\t\t/**\n\t\t * 2. 如果 beanFactory 上下文中不包含 \"默认的变量解析器 (类似 PropertySourcesPlaceholderConfigurer) 解析类似 '${}' 这样的变量 \"\n\t\t * 则使用环境对象(ConfigurableEnvironment)中的 ConfigurablePropertyResolver实现来作为 StringValueResolver 添加进去\n\t\t */\n\t\tif (!beanFactory.hasEmbeddedValueResolver()) {\n\t\t\tbeanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));\n\t\t}\n\t\t// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.\n\t\t/**\n\t\t * 3. 先实例化化 LoadTimeWeaverAware bean，以便尽早注册它们的转换器。\n\t\t * TODO AOP 相关的\n\t\t */\n\t\tString[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n\t\tfor (String weaverAwareName : weaverAwareNames) {\n\t\t\tgetBean(weaverAwareName);\n\t\t}\n\n\t\t// Stop using the temporary ClassLoader for type matching.\n\t\t// 停止使用临时ClassLoader进行类型匹配\n\t\tbeanFactory.setTempClassLoader(null);\n\n\t\t// Allow for caching all bean definition metadata, not expecting further changes.\n\t\t/**\n\t\t * 4. 冻结配置, 这时候就不再允许更改 beanDefinition 了; (其实就是 clearMetadataCache 和 设置了一个标识符)\n\t\t */\n\t\tbeanFactory.freezeConfiguration();\n\n\t\t// Instantiate all remaining (non-lazy-init) singletons.\n\t\t/**\n\t\t * 5. 实例化所有剩余的 (非lazy-init) 单例 Bean\n\t\t */\n\t\tbeanFactory.preInstantiateSingletons();\n\t}\n</code></pre>\n<h3 id=\"处理-factorybean-等\">处理 FactoryBean 等</h3>\n<p><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</code></p>\n<pre><code class=\"language-java\">@Override\n\tpublic void preInstantiateSingletons() throws BeansException {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Pre-instantiating singletons in \" + this);\n\t\t}\n\t\t// Iterate over a copy to allow for init methods which in turn register new bean definitions.\n\t\t// While this may not be part of the regular factory bootstrap, it does otherwise work fine.\n\t\t/**\n\t\t *  所有已注册的Bean name 列表;\n\t\t *  这里复制一份, 方便遍历;\n\t\t */\n\t\tList&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);\n\n\t\t// Trigger initialization of all non-lazy singleton beans...\n\t\tfor (String beanName : beanNames) {\n\t\t\t/**\n\t\t\t * 合并到父类的 BeanDefinition 得到 RootBeanDefinition, 放入缓存中.\n\t\t\t * (每一个Bean都有 RootBeanDefinition, 没有的话 getMergedLocalBeanDefinition 会创建一个, 并放入缓存中)\n\t\t\t *\n\t\t\t * 为什么需要往上缓存 RootBeanDefinition ?\n\t\t\t * 实例化一个对象的时候, 肯定是先实例化父对象, 有父对象才能实例子对象\n\t\t\t */\n\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\t\t\t//如果该 bean 是: 非抽象, 是单例, 非懒加载\n\t\t\tif (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {\n\t\t\t\t/**\n\t\t\t\t * 如果该bean是 FactoryBean, 则在 bean name 前面加一个 '&amp;' 前缀, 先获取/实例化 FactoryBean 本身;\n\t\t\t\t *  注意一下 FactoryBean 生成对象是不遵循 Spring 的bean生命周期的\n\t\t\t\t *\n\t\t\t\t * 这有两个对象, 如何获取? getBean(beanName) :\n\t\t\t\t * 1. 传入 FactoryBean 的 name 返回的是其 getObject 的目标对象实例;\n\t\t\t\t * 2. 如果想获取 FactoryBean 本身实例, 则前面需要加一个 '&amp;' 前缀;\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif (isFactoryBean(beanName)) {\n\t\t\t\t\t/**\n\t\t\t\t\t * 获取/实例化 factoryBean 本身\n\t\t\t\t\t */\n\t\t\t\t\tObject bean = getBean(FACTORY_BEAN_PREFIX + beanName);\n\t\t\t\t\tif (bean instanceof SmartFactoryBean&lt;?&gt; smartFactoryBean\n\t\t\t\t\t\t\t&amp;&amp; smartFactoryBean.isEagerInit()) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * 如果是 SmartFactoryBean 并且 是急加载:\n\t\t\t\t\t\t * 则再获取/实例化该 FactoryBean 的目标对象\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgetBean(beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgetBean(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Trigger post-initialization callback for all applicable beans...\n\t\tfor (String beanName : beanNames) {\n\t\t\tObject singletonInstance = getSingleton(beanName);\n\t\t\tif (singletonInstance instanceof SmartInitializingSingleton smartSingleton) {\n\t\t\t\tStartupStep smartInitialize = getApplicationStartup().start(\"spring.beans.smart-initialize\")\n\t\t\t\t\t\t.tag(\"beanName\", beanName);\n\t\t\t\tsmartSingleton.afterSingletonsInstantiated();\n\t\t\t\tsmartInitialize.end();\n\t\t\t}\n\t\t}\n\t}\n</code></pre>\n<h3 id=\"尝试从-一-二-三级缓存中获取\">尝试从 一 二 三级缓存中获取</h3>\n<p><code>org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)</code><br />\n<code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</code></p>\n<pre><code class=\"language-java\">/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * @param name the name of the bean to retrieve\n\t * @param requiredType the required type of the bean to retrieve\n\t * @param args arguments to use when creating a bean instance using explicit arguments\n\t * (only applied when creating a new instance as opposed to retrieving an existing one)\n\t * @param typeCheckOnly whether the instance is obtained for a type check,\n\t * not for actual use\n\t * @return an instance of the bean\n\t * @throws BeansException if the bean could not be created\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected &lt;T&gt; T doGetBean(\n\t\t\tString name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly)\n\t\t\tthrows BeansException {\n\n\t\t/**\n\t\t *\n\t\t * 转换 bean name; 如果名称中带 BeanFactory.FACTORY_BEAN_PREFIX, 则会去掉它;\n\t\t * {@link BeanFactory#FACTORY_BEAN_PREFIX}\n\t\t */\n\t\tString beanName = transformedBeanName(name);\n\t\tObject beanInstance;\n\t\t// Eagerly check singleton cache for manually registered singletons.\n\t\t/**\n\t\t * 尝试从当前容器 一 二 三级缓存获取\n\t\t */\n\t\tObject sharedInstance = getSingleton(beanName);\n\t\tif (sharedInstance != null &amp;&amp; args == null) {\n\t\t\t/**\n\t\t\t * 如果缓存中有\n\t\t\t */\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\t\tlogger.trace(\"Returning eagerly cached instance of singleton bean '\" + beanName +\n\t\t\t\t\t\t\t\"' that is not fully initialized yet - a consequence of a circular reference\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.trace(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**\n\t\t\t * 如果拿到的Bean是 FactoryBean 实现, 则会调用 `T getObject() throws Exception` 获取其对象\n\t\t\t * 再将目标对象放入org.springframework.beans.factory.support.FactoryBeanRegistrySupport#factoryBeanObjectCache缓存中\n\t\t\t * 最终在 {@link org.springframework.beans.factory.support.FactoryBeanRegistrySupport#doGetObjectFromFactoryBean}\n\t\t\t */\n\t\t\tbeanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n\t\t}\n\t\telse {\n\t\t\t/**\n\t\t\t * 如果缓存中没有\n\t\t\t */\n\n\t\t\t/**\n\t\t\t *  判断该bean是否在创建中 (循环创建), 用的是一个ThreadLocal\n\t\t\t *  {@link org.springframework.beans.factory.support.AbstractBeanFactory#prototypesCurrentlyInCreation}\n\t\t\t */\n\t\t\t// Fail if we're already creating this bean instance:\n\t\t\t// We're assumably within a circular reference.\n\t\t\tif (isPrototypeCurrentlyInCreation(beanName)) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName);\n\t\t\t}\n\t\t\t/**\n\t\t\t * 优先尝试从 父 BeanFactory中拿, 类似类加载器的双亲委托机制\n\t\t\t * 一般 父容器都是空的\n\t\t\t */\n\t\t\t// Check if bean definition exists in this factory.\n\t\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\t\tif (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n\t\t\t\t// Not found -&gt; check parent.\n\t\t\t\tString nameToLookup = originalBeanName(name);\n\t\t\t\tif (parentBeanFactory instanceof AbstractBeanFactory abf) {\n\t\t\t\t\treturn abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);\n\t\t\t\t}\n\t\t\t\telse if (args != null) {\n\t\t\t\t\t// Delegation to parent with explicit args.\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup, args);\n\t\t\t\t}\n\t\t\t\telse if (requiredType != null) {\n\t\t\t\t\t// No args -&gt; delegate to standard getBean method.\n\t\t\t\t\treturn parentBeanFactory.getBean(nameToLookup, requiredType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * 标记该 bean为创建中或者已创建;\n\t\t\t * 其实就是用 Set集合 {@link org.springframework.beans.factory.support.AbstractBeanFactory#alreadyCreated} 存起来\n\t\t\t */\n\t\t\tif (!typeCheckOnly) {\n\t\t\t\tmarkBeanAsCreated(beanName);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * 记录器 (打印某些关键过程日志, 收集分析, 不重要)\n\t\t\t */\n\t\t\tStartupStep beanCreation = this.applicationStartup.start(\"spring.beans.instantiate\")\n\t\t\t\t\t.tag(\"beanName\", name);\n\t\t\ttry {\n\t\t\t\tif (requiredType != null) {\n\t\t\t\t\tbeanCreation.tag(\"beanType\", requiredType::toString);\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * 拿到其 RootBeanDefinition (完整的Bean元数据描述)\n\t\t\t\t */\n\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\t//检查BeanDefinition, 就判断一下是该bean 否抽象类\n\t\t\t\tcheckMergedBeanDefinition(mbd, beanName, args);\n\n\t\t\t\t/**\n\t\t\t\t * 如果存在依赖配置, 则先创建依赖的Bean\n\t\t\t\t * (即XML的 &lt;bean id=\"...\" depends-on=\"\" ...&gt;&lt;/bean&gt; 配置)\n\t\t\t\t */\n\t\t\t\t// Guarantee initialization of beans that the current bean depends on.\n\t\t\t\tString[] dependsOn = mbd.getDependsOn();\n\t\t\t\tif (dependsOn != null) {\n\t\t\t\t\tfor (String dep : dependsOn) {\n\t\t\t\t\t\tif (isDependent(beanName, dep)) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tregisterDependentBean(dep, beanName);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tgetBean(dep);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"'\" + beanName + \"' depends on missing bean '\" + dep + \"'\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create bean instance.\n\t\t\t\tif (mbd.isSingleton()) {\n\t\t\t\t\t/**\n\t\t\t\t\t * 如果是单例的 Bean\n\t\t\t\t\t * =============================\n\t\t\t\t\t */\n\n\t\t\t\t\t/**\n\t\t\t\t\t * 注意 传递一个 '创建Bean' 的Lambda函数/对象 (ObjectFactory)\n\t\t\t\t\t * getSingleton 的逻辑是:\n\t\t\t\t\t * \t 1. 尝试从一级缓存中拿\n\t\t\t\t\t * \t 2. 将Bean Name 添加到 创建中状态的集合 记录起来;\n\t\t\t\t\t * \t  {@link org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonsCurrentlyInCreation}\n\t\t\t\t\t *   3. 调用 ObjectFactory#getObject() 回调回来 createBean\n\t\t\t\t\t *   4. 如果是新创建的添加到一级缓冲中\n\t\t\t\t\t */\n\t\t\t\t\tsharedInstance = getSingleton(beanName, () -&gt; {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * 见: {@link AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t\t\t// Explicitly remove instance from singleton cache: It might have been put there\n\t\t\t\t\t\t\t// eagerly by the creation process, to allow for circular reference resolution.\n\t\t\t\t\t\t\t// Also remove any beans that received a temporary reference to the bean.\n\t\t\t\t\t\t\tdestroySingleton(beanName);\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbeanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n\t\t\t\t}\n\t\t\t\telse if (mbd.isPrototype()) {\n\t\t\t\t\t/**\n\t\t\t\t\t * 如果是原型的 Bean\n\t\t\t\t\t * =============================\n\t\t\t\t\t */\n\t\t\t\t\t// It's a prototype -&gt; create a new instance.\n\t\t\t\t\tObject prototypeInstance = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\tprototypeInstance = createBean(beanName, mbd, args);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t}\n\t\t\t\t\tbeanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tString scopeName = mbd.getScope();\n\t\t\t\t\tif (!StringUtils.hasLength(scopeName)) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No scope name defined for bean '\" + beanName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tScope scope = this.scopes.get(scopeName);\n\t\t\t\t\tif (scope == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject scopedInstance = scope.get(beanName, () -&gt; {\n\t\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbeanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\t\tthrow new ScopeNotActiveException(beanName, scopeName, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tbeanCreation.tag(\"exception\", ex.getClass().toString());\n\t\t\t\tbeanCreation.tag(\"message\", String.valueOf(ex.getMessage()));\n\t\t\t\tcleanupAfterBeanCreationFailure(beanName);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tbeanCreation.end();\n\t\t\t\tif (!isCacheBeanMetadata()) {\n\t\t\t\t\tclearMergedBeanDefinition(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 适配转换为 需求的目标类型 requiredType\n\t\t * 多态: 子类是可以向上转型的\n\t\t */\n\t\treturn adaptBeanInstance(name, beanInstance, requiredType);\n\t}\n</code></pre>\n<h3 id=\"处理instantiationawarebeanpostprocessor-aop代理\">处理InstantiationAwareBeanPostProcessor AOP代理</h3>\n<p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</code></p>\n<pre><code class=\"language-java\">/**\n\t * Central method of this class: creates a bean instance,\n\t * populates the bean instance, applies post-processors, etc.\n\t * @see #doCreateBean\n\t */\n\t@Override\n\tprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\t\tthrows BeanCreationException {\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Creating instance of bean '\" + beanName + \"'\");\n\t\t}\n\t\tRootBeanDefinition mbdToUse = mbd;\n\n\t\t// Make sure bean class is actually resolved at this point, and\n\t\t// clone the bean definition in case of a dynamically resolved Class\n\t\t// which cannot be stored in the shared merged bean definition.\n\t\t/**\n\t\t * 1. 解析到 BeanDefinition 的 Class\n\t\t */\n\t\tClass&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);\n\t\t/**\n\t\t * 2. 创建BeanDefinition 复制一份 RootBeanDefinition\n\t\t */\n\t\tif (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {\n\t\t\tmbdToUse = new RootBeanDefinition(mbd);\n\t\t\tmbdToUse.setBeanClass(resolvedClass);\n\t\t}\n\n\t\t// Prepare method overrides.\n\t\ttry {\n\t\t\t/**\n\t\t\t * 3. 准备和验证 lookup-method 和 replace-method;\n\t\t\t * 注意: 这里只是标记, 真正处理是在实例化时, 选择策略生成一个CgLib的代理对象 {@link org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy}\n\t\t\t * 关于它们的作用见笔记 [[Spring lookup-method 和 replace-method.md]]\n\t\t\t */\n\t\t\tmbdToUse.prepareMethodOverrides();\n\t\t}\n\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n\t\t\t\t\tbeanName, \"Validation of method overrides failed\", ex);\n\t\t}\n\n\t\ttry {\n\t\t\t// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n\t\t\t/**\n\t\t\t * 4. 给 BeanPostProcessors 一个返回(用户自定义, 如果有AOP, 则会 用户代理 再 Spring代理)代理实例的机会;\n\t\t\t * 调用 InstantiationAwareBeanPostProcessor 的\n\t\t\t * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation(java.lang.Class, java.lang.String)}\n\t\t\t * 和\n\t\t\t * {@link InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation(java.lang.Class, java.lang.String)}\n\t\t\t * 可以自定义创建 bean动态代理实例返回 (AOP相关)\n\t\t\t *  \n\t\t\t * 见笔记:\n\t\t\t * [[BeanPostProcessor接口.md]]\n\t\t\t * [[Spring 中的AOP]]\n\t\t\t *\n\t\t\t * 注意, 这里的逻辑:\n\t\t\t * 如果其 InstantiationAwareBeanPostProcessor 返回不为null, 则直接使用这个bean实例返回了, 不走 doCreateBean等下面的流程\n\t\t\t * (注意的注意! 如果有用户自定义的拦截创建, 甚至优先Spring的AOP代理创建)\n\t\t\t */\n\t\t\tObject bean = resolveBeforeInstantiation(beanName, mbdToUse);\n\t\t\tif (bean != null) {\n\t\t\t\treturn bean;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n\t\t\t\t\t\"BeanPostProcessor before instantiation of bean failed\", ex);\n\t\t}\n\n\t\ttry {\n\t\t\t/**\n\t\t\t * 继续\n\t\t\t */\n\t\t\tObject beanInstance = doCreateBean(beanName, mbdToUse, args);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Finished creating instance of bean '\" + beanName + \"'\");\n\t\t\t}\n\t\t\treturn beanInstance;\n\t\t}\n\t\tcatch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {\n\t\t\t// A previously detected exception with proper bean creation context already,\n\t\t\t// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbdToUse.getResourceDescription(), beanName, \"Unexpected exception during bean creation\", ex);\n\t\t}\n\t}\n</code></pre>\n<h3 id=\"真正在jvm层面实例化对象\">真正在jvm层面实例化对象</h3>\n<p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</code></p>\n<pre><code class=\"language-java\">/**\n\t * Actually create the specified bean. Pre-creation processing has already happened\n\t * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.\n\t * &lt;p&gt;Differentiates between default bean instantiation, use of a\n\t * factory method, and autowiring a constructor.\n\t *\n\t * 真正的 在JVM层 创建Bean实例\n\t *\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a new instance of the bean\n\t * @throws BeanCreationException if the bean could not be created\n\t * @see #instantiateBean\n\t * @see #instantiateUsingFactoryMethod\n\t * @see #autowireConstructor\n\t *\n\t */\n\tprotected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\t\tthrows BeanCreationException {\n\n\t\t// Instantiate the bean.\n\t\tBeanWrapper instanceWrapper = null;\n\t\tif (mbd.isSingleton()) {\n\t\t\tinstanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n\t\t}\n\t\tif (instanceWrapper == null) {\n\t\t\t/**\n\t\t\t *  1. 真正在jvm层面实例化对象;\n\t\t\t *    1.1 如果该 BeanDefinition 有配置 instanceSupplier属性(java.util.function.Supplier),\n\t\t\t * \t\t 将使用其Supplier#get方法的返回, 作为实例对象\n\t\t\t *    1.2 如果该 BeanDefinition 有配置 factory-method 将使用该方法返回的, 作为实例对象\n\t\t\t * \t\t 这里这里包括'静态工厂'和'实例工厂'的处理(通过bd的factoryBeanName 进行判断, 如果存在则是'实例工厂')\n\t\t\t * \t  1.3 使用反射实例化, 根据策略实例化Bean对象 {@link org.springframework.beans.factory.support.SimpleInstantiationStrategy}\n\t\t\t * \t   - 使用有参构造函数注入,创建 (new)\n\t\t\t * \t   - 使用无参构造函数创建 (new)\n\t\t\t * \t   - 工厂方法实例化 ('静态工厂' '实例工厂' )\n\t\t\t * \t     `&lt;bean  factory-bean=\"bookFactoryBean\"  factory-method=\"getBook()\"/&gt;`\n\t\t\t * \t        静态工厂: factory-bean 若是 全限定类名 则使用 BookFactoryBean::getBook 的静态方法返回的对象\n\t\t\t * \t        实例工厂:  factory-bean 若是 bean 名 则使用该实例方法返回的对象\n\t\t\t *\n\t\t\t * \t{@link AbstractAutowireCapableBeanFactory#createBeanInstance(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])}\n\t\t\t *  2. 用BeanWrapper 包装原始bean (装饰模式)\n\t\t\t *  初始化 BeanWrapper\n\t\t\t * \t 2.1 给 BeanWrapper 设置了, ConversionService\n\t\t\t *   2.2 给 BeanWrapper 注册了, 当前 bean factory (propertyEditorRegistrars)中的全部 PropertyEditor\n\t\t\t * {@link org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#instantiateBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition)}\n\t\t\t *\n\t\t\t */\n\t\t\tinstanceWrapper = createBeanInstance(beanName, mbd, args);\n\t\t}\n\t\t/**\n\t\t * 获取 BeanWrapper中的原始 Bean 实例\n\t\t */\n\t\tObject bean = instanceWrapper.getWrappedInstance();\n\t\t/**\n\t\t * 获取 Bean Class类型\n\t\t */\n\t\tClass&lt;?&gt; beanType = instanceWrapper.getWrappedClass();\n\t\tif (beanType != NullBean.class) {\n\t\t\tmbd.resolvedTargetType = beanType;\n\t\t}\n\n\t\t// Allow post-processors to modify the merged bean definition.\n\t\tsynchronized (mbd.postProcessingLock) {\n\t\t\tif (!mbd.postProcessed) {\n\t\t\t\ttry {\n\t\t\t\t\t/**\n\t\t\t\t\t * 3. 处理 MergedBeanDefinitionPostProcessor 的接口回调\n\t\t\t\t\t * 调用 添加在 context 中 BeanPostProcessor 的 MergedBeanDefinitionPostProcessor 的接口回调\n\t\t\t\t\t * 解析到诸如`@Autowired`之类的注解 (Metadata)元信息,合并到BeanDefinition中\n\t\t\t\t\t *\n\t\t\t\t\t * 注意在当前步骤中,只是解析,并注册(修改)到 BeanDefinition 中, 并没有调用;\n\t\t\t\t\t *\n\t\t\t\t\t * 例如:\n\t\t\t\t\t *  1. 处理 `@Autowired` `@Value`, `@Inject`\n\t\t\t\t\t * 对应处理类是 `org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor`\n\t\t\t\t\t * 这个 真正处理是在填充属性时, [[回调所有 InstantiationAwareBeanPostProcessor#postProcessProperties 方法]] {@link org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, org.springframework.beans.BeanWrapper)}\n\t\t\t\t\t * 负责查找相应的注解方法信息, 封装为 Metadata 元数据(使用集合存起来), 再将这些 Metadata 元数据, 注册(修改)到 BeanDefinition 中\n\t\t\t\t\t *\n\t\t\t\t\t *  2. 处理 `@Resource`\n\t\t\t\t\t * 对应处理类 `org.springframework.context.annotation.CommonAnnotationBeanPostProcessor`\n\t\t\t\t\t *\n\t\t\t\t\t *  3. 处理 `init-method`, `@PostConstruct`, `@PreDestroy`\n\t\t\t\t\t * 对应处理类 `org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor`\n\t\t\t\t\t *\n\t\t\t\t\t */\n\t\t\t\t\tapplyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\"Post-processing of merged bean definition failed\", ex);\n\t\t\t\t}\n\t\t\t\tmbd.markAsPostProcessed();\n\t\t\t}\n\t\t}\n\n\t\t// Eagerly cache singletons to be able to resolve circular references\n\t\t// even when triggered by lifecycle interfaces like BeanFactoryAware.\n\t\t/**\n\t\t * 判断当前:  是否单例 &amp;&amp; 是否允许循环依赖 &amp;&amp; 是否正在创建过程中\n\t\t *(循环依赖AOP)\n\t\t */\n\t\tboolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;\n\t\t\t\tisSingletonCurrentlyInCreation(beanName));\n\t\tif (earlySingletonExposure) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Eagerly caching bean '\" + beanName +\n\t\t\t\t\t\t\"' to allow for resolving potential circular references\");\n\t\t\t}\n\t\t\t/**\n\t\t\t * 放到三级缓存(三级缓存 存放Lambda)\n\t\t\t * &lt;!&gt; 循环依赖 AOP :这里其实就是会调用到 AutoProxyCreator 在其进行判断是否需要, 最终会调用到 createProxy 进行动态代理对象创建\n\t\t\t * {@link org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#getEarlyBeanReference(java.lang.Object, java.lang.String)}\n\t\t\t *\n\t\t\t */\n\t\t\taddSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n\t\t}\n\n\t\t// Initialize the bean instance.\n\t\tObject exposedObject = bean;\n\t\ttry {\n\t\t\t/**\n\t\t\t * 2.填充Bean属性\n\t\t\t * 如果是AOP, pointcut, advice相关的, synthetic 会配置为 true\n\t\t\t *   1. 调用 BeanPostProcessor 的子接口 InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation\n\t\t\t * \t (作用是 在实例化之后，属性填充之前执行操作, 可以拦截属性填充操作)\n\t\t\t */\n\t\t\tpopulateBean(beanName, mbd, instanceWrapper);\n\t\t\t/**\n\t\t\t * 3.初始化Bean对象\n\t\t\t *   1.先调用这三个 BeanNameAware, BeanClassLoaderAware, BeanFactoryAware\n\t\t\t * \t  这三个是在创建BeanFactory 时忽略的三个 Aware 接口\n\t\t\t *   2. 调用所有 BeanPostProcessors#postProcessBeforeInitialization (作用: 在Bean初始化之前调用)\n\t\t\t *   3. 调用 init-method 方法\n\t\t\t *   4. 调用所有 BeanPostProcessors#postProcessAfterInitialization (作用: 在Bean初始化之后调用)\n\t\t\t */\n\t\t\texposedObject = initializeBean(beanName, exposedObject, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (ex instanceof BeanCreationException bce &amp;&amp; beanName.equals(bce.getBeanName())) {\n\t\t\t\tthrow bce;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);\n\t\t\t}\n\t\t}\n\n\t\tif (earlySingletonExposure) {\n\t\t\t/**\n\t\t\t * 循环依赖AOP 相关 (循环依赖AOP)\n\t\t\t * =======================\n\t\t\t */\n\n\t\t\t/**\n\t\t\t * 再从缓存中拿一次获取并替换,是因为有可能是被代理(earlySingletonReference)\n\t\t\t */\n\t\t\tObject earlySingletonReference = getSingleton(beanName, false);\n\t\t\tif (earlySingletonReference != null) {\n\t\t\t\t/**\n\t\t\t\t *  (循环依赖AOP)\n\t\t\t\t *  注意: 这个bean是原始实例, 再从缓存中拿一次,是因为有可能是被代理(earlySingletonReference)\n\t\t\t\t */\n\t\t\t\tif (exposedObject == bean) {\n\t\t\t\t\t// 不一致就是被代理了\n\t\t\t\t\texposedObject = earlySingletonReference;\n\t\t\t\t}\n\t\t\t\telse if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {\n\t\t\t\t\tString[] dependentBeans = getDependentBeans(beanName);\n\t\t\t\t\tSet&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);\n\t\t\t\t\tfor (String dependentBean : dependentBeans) {\n\t\t\t\t\t\tif (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n\t\t\t\t\t\t\tactualDependentBeans.add(dependentBean);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!actualDependentBeans.isEmpty()) {\n\t\t\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName,\n\t\t\t\t\t\t\t\t\"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n\t\t\t\t\t\t\t\t\t\tStringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n\t\t\t\t\t\t\t\t\t\t\"] in its raw version as part of a circular reference, but has eventually been \" +\n\t\t\t\t\t\t\t\t\t\t\"wrapped. This means that said other beans do not use the final version of the \" +\n\t\t\t\t\t\t\t\t\t\t\"bean. This is often the result of over-eager type matching - consider using \" +\n\t\t\t\t\t\t\t\t\t\t\"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Register bean as disposable.\n\t\ttry {\n\t\t\t/**\n\t\t\t * 注册 bean销毁的工作(如果需要)\n\t\t\t * 1. org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor#postProcessBeforeDestruction(Object,String) BPP接口\n\t\t\t * 2. org.springframework.beans.factory.DisposableBean 接口\n\t\t\t * 3. 自定义 destroy方法\n\t\t\t * 在容器关闭时会调用会按这个顺序调用\n\t\t\t */\n\t\t\tregisterDisposableBeanIfNecessary(beanName, bean, mbd);\n\t\t}\n\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n\t\t}\n\n\t\treturn exposedObject;\n\t}\n</code></pre>\n<h3 id=\"实例化-构造函数的细节\">实例化 构造函数的细节</h3>\n<pre><code class=\"language-java\">\n\t/**\n\t * 实例化详细过程\n\t * \n\t * Create a new instance for the specified bean, using an appropriate instantiation strategy:\n\t * factory method, constructor autowiring, or simple instantiation.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a BeanWrapper for the new instance\n\t * @see #obtainFromSupplier\n\t * @see #instantiateUsingFactoryMethod\n\t * @see #autowireConstructor\n\t * @see #instantiateBean\n\t *\n\t */\n\tprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {\n\t\t// Make sure bean class is actually resolved at this point.\n\t\t// 确保Class 是可以实例化的\n\t\tClass&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);\n\t\t/**\n\t\t * 验证一下构造方法 访问修饰符\n\t\t */\n\t\tif (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean class isn't public, and nonpublic access not allowed: \" + beanClass.getName());\n\t\t}\n\t\t/**\n\t\t * 如果该 BeanDefinition 有配置 instanceSupplier属性(java.util.function.Supplier),\n\t\t * 将使用其Supplier#get方法的返回, 作为实例对象\n\t\t */\n\t\tSupplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();\n\t\tif (instanceSupplier != null) {\n\t\t\treturn obtainFromSupplier(instanceSupplier, beanName, mbd);\n\t\t}\n\n\t\t/**\n\t\t * 如果该 BeanDefinition 有配置 factory-method 将使用该方法的返回 作为实例对象\n\t\t * 这里这里包括'静态工厂'和'实例工厂'的处理(通过bd的factoryBeanName 进行判断, 如果存在则是'实例工厂')\n\t\t *\n\t\t * 静态工厂(注意 工厂方法是static方法)\n\t\t * &lt;bean id=\"user\" class=\"org.yang.User\"  factory-method=\"createUser\"/&gt;\n\t\t *\n\t\t * 实例工厂(注意 工厂对象是一个实例, 使用该实例方法返回的)\n\t\t * &lt;bean id=\"userFactory\" class=\"org.yang.UserFactory\"/&gt;\n\t\t *  &lt;! -- factory-bean 指向实例工厂 Bean --&gt;\n\t\t * &lt;bean id=\"user\" class=\"org.yang.User\" factory-bean=\"userFactory\" factory-method=\"createUser\"/&gt;\n\t\t *\n\t\t */\n\t\tif (mbd.getFactoryMethodName() != null) {\n\t\t\treturn instantiateUsingFactoryMethod(beanName, mbd, args);\n\t\t}\n\n\t\t/**\n\t\t *  =======================\n\t\t *  in short : 下面主要逻辑就是 找到一个合适的构造函数和注入方式, 然后存起来, 通过反射实例化\n\t\t *  如果下次还需要就直接根据情况直接执行(仅原型Bean才有重复创建的情况)\n\t\t */\n\t\t// Shortcut when re-creating the same bean...\n\t\t/**\n\t\t * 是否已经解析/创建过了\n\t\t */\n\t\tboolean resolved = false;\n\t\t/**\n\t\t * 是否需要自动注入\n\t\t */\n\t\tboolean autowireNecessary = false;\n\t\tif (args == null) {\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\t/**\n\t\t\t\t * 类似一个缓存机制, 后面在 {@link org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate(org.springframework.beans.factory.support.RootBeanDefinition, java.lang.String, org.springframework.beans.factory.BeanFactory)}\n\t\t\t\t * 解析过程中会给它赋值存起来; 下面就根据解析的情况执行\n\t\t\t\t */\n\t\t\t\tif (mbd.resolvedConstructorOrFactoryMethod != null) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tautowireNecessary = mbd.constructorArgumentsResolved;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * 已经解析过了, 根据解析的情况, 执行\n\t\t */\n\t\tif (resolved) {\n\t\t\tif (autowireNecessary) {\n\t\t\t\t/**\n\t\t\t\t * 使用有参构造函数注入,创建 (new)\n\t\t\t\t */\n\t\t\t\treturn autowireConstructor(beanName, mbd, null, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/**\n\t\t\t\t * 使用无参构造函数注入,创建 (new)\n\t\t\t\t */\n\t\t\t\treturn instantiateBean(beanName, mbd);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * 首次解析创建Bean\n\t\t * =============================\n\t\t */\n\n\t\t// Candidate constructors for autowiring?\n\t\t/**\n\t\t * 从 BeanPostProcessors 里面推断构造方法\n\t\t * SmartInstantiationAwareBeanPostProcessor 接口可以对 '构造方法注入的选择' 进行调整(推荐?)\n\t\t * {@link org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors(java.lang.Class, java.lang.String)}\n\t\t *\n\t\t */\n\t\tConstructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n\t\t/**\n\t\t * 自动转配的方式, 有五种 (见 {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory}的几个常量):\n\t\t *  1. AUTOWIRE_NO = 0; 未指定, 不注入\n\t\t * \t2. AUTOWIRE_BY_NAME = 1; byName\n\t\t * \t3. AUTOWIRE_BY_TYPE = 2; byType\n\t\t * \t4. AUTOWIRE_CONSTRUCTOR = 3; by构造\n\t\t *  5. AUTOWIRE_AUTODETECT = 4;(将弃用)\n\t\t *\n\t\t */\n\t\tif (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||\n\t\t\t\tmbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {\n\t\t\t/**\n\t\t\t * 使用有参构造函数注入,创建\n\t\t\t */\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, args);\n\t\t}\n\n\t\t// Preferred constructors for default construction?\n\t\t/**\n\t\t *  没有找到合适的构造函数, 如果mbd有配置 首选的构造函数, 就用它\n\t\t */\n\t\tctors = mbd.getPreferredConstructors();\n\t\tif (ctors != null) {\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, null);\n\t\t}\n\n\t\t// No special handling: simply use no-arg constructor.\n\t\t/**\n\t\t * 使用无参构造函数注入,创建\n\t\t */\n\t\treturn instantiateBean(beanName, mbd);\n\t}\n</code></pre>\n<h3 id=\"填充属性\">填充属性</h3>\n<pre><code class=\"language-java\">/**\n\t * Populate the bean instance in the given BeanWrapper with the property values\n\t * from the bean definition.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the beanT\n\t * @param bw the BeanWrapper with bean instance\n\t */\n\tprotected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n\t\t// 验证一下入参\n\t\tif (bw == null) {\n\t\t\tif (mbd.hasPropertyValues()) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Skip property population phase for null instance.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (bw.getWrappedClass().isRecord()) {\n\t\t\tif (mbd.hasPropertyValues()) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Cannot apply property values to a record\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Skip property population phase for records since they are immutable.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n\t\t// state of the bean before properties are set. This can be used, for example,\n\t\t// to support styles of field injection.\n\t\t/**\n\t\t * 如果是AOP, pointcut, advice相关的, synthetic 会配置为 true\n\t\t * 1. 调用 BeanPostProcessor 的子接口 InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation\n\t\t * (作用是 在实例化之后，属性填充之前执行操作, 可以拦截属性填充操作)\n\t\t */\n\t\tif (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tif (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n\t\t\t\t\t//postProcessAfterInstantiation 返回 false , 拦截属性填充;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * 包含一个或多个{@link PropertyValue}对象的Holder，通常针对特定目标bean的一次更新\n\t\t * 可以理解为: 该bean所有属性的描述\n\t\t */\n\t\tPropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n\n\t\t/**\n\t\t * 获取自动注入的方式\n\t\t */\n\t\tint resolvedAutowireMode = mbd.getResolvedAutowireMode();\n\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\t/**\n\t\t\t * 2. 处理注解的  byName 或者 byType 注入的属性\n\t\t\t * (有注解才会走这个分支)\n\t\t\t * ===============================\n\t\t\t */\n\t\t\tMutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\t\t\t// Add property values based on autowire by name if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME) {\n\t\t\t\t/**\n\t\t\t\t * 通过名称注入\n\t\t\t\t */\n\t\t\t\tautowireByName(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\t// Add property values based on autowire by type if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\t\t/**\n\t\t\t\t * 通过类型注入\n\t\t\t\t */\n\t\t\t\tautowireByType(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\tpvs = newPvs;\n\t\t}\n\t\t/**\n\t\t *  3. 回调所有 InstantiationAwareBeanPostProcessor#postProcessProperties 方法\n\t\t *  比如, `@Autowired` 的处理对应实现类: {@link org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor}\n\t\t *  (作用是: 在工厂将属性值应用到给定bean之前，对它们进行处理)\n\t\t * \t 注意这里也只是解析, 并没有设置进去, 实际赋值方法见下: {@link AbstractAutowireCapableBeanFactory#applyPropertyValues(java.lang.String, org.springframework.beans.factory.config.BeanDefinition, org.springframework.beans.BeanWrapper, org.springframework.beans.PropertyValues)}\n\t\t *\n\t\t */\n\t\tif (hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tif (pvs == null) {\n\t\t\t\tpvs = mbd.getPropertyValues();\n\t\t\t}\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tPropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);\n\t\t\t\tif (pvsToUse == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpvs = pvsToUse;\n\t\t\t}\n\t\t}\n\n\t\tboolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);\n\t\tif (needsDepCheck) {\n\t\t\tPropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n\t\t\tcheckDependencies(beanName, mbd, filteredPds, pvs);\n\t\t}\n\t\t/**\n\t\t * 4. 解析BeanDefinition的描述值, 反射调用 赋值 bean 属性 (将解析到的 pvs 赋值到 bw)\n\t\t */\n\t\tif (pvs != null) {\n\t\t\tapplyPropertyValues(beanName, mbd, bw, pvs);\n\t\t}\n\t}\n</code></pre>\n<h3 id=\"初始化-调用-init-method-aware-bpp方法\">初始化 调用 init-method Aware BPP方法</h3>\n<p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(java.lang.String, java.lang.Object, org.springframework.beans.factory.support.RootBeanDefinition)</code></p>\n<pre><code class=\"language-java\">/**\n\t * Initialize the given bean instance, applying factory callbacks\n\t * as well as init methods and bean post processors.\n\t * &lt;p&gt;Called from {@link #createBean} for traditionally defined beans,\n\t * and from {@link #initializeBean} for existing bean instances.\n\t * @param beanName the bean name in the factory (for debugging purposes)\n\t * @param bean the new bean instance we may need to initialize\n\t * @param mbd the bean definition that the bean was created with\n\t * (can also be {@code null}, if given an existing bean instance)\n\t * @return the initialized bean instance (potentially wrapped)\n\t * @see BeanNameAware\n\t * @see BeanClassLoaderAware\n\t * @see BeanFactoryAware\n\t * @see #applyBeanPostProcessorsBeforeInitialization\n\t * @see #invokeInitMethods\n\t * @see #applyBeanPostProcessorsAfterInitialization\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tprotected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {\n\n\t\t/**\n\t\t * 先调用这三个 BeanNameAware, BeanClassLoaderAware, BeanFactoryAware\n\t\t * 这三个是在创建 BeanFactory 时忽略的三个 Aware 接口\n\t\t * { @link org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#AbstractAutowireCapableBeanFactory() }\n\t\t *\n\t\t */\n\t\tinvokeAwareMethods(beanName, bean);\n\n\t\tObject wrappedBean = bean;\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\t/**\n\t\t\t * 调用所有 BeanPostProcessors#postProcessBeforeInitialization\n\t\t\t * (作用 在Bean初始化之前调用)\n\t\t\t * 比如 Spring 中Aware属性的设置, 是通过这种方式扩展的\n\t\t\t * - org.springframework.context.support.ApplicationContextAwareProcessor\n\t\t\t * 对应调用 ApplicationContextAware, EnvironmentAware, ApplicationEventPublisherAware 等Aware方法\n\t\t\t *\n\t\t\t */\n\t\t\twrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\ttry {\n\t\t\t/**\n\t\t\t * 调用 init-method 方法\n\t\t\t */\n\t\t\tinvokeInitMethods(beanName, wrappedBean, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t(mbd != null ? mbd.getResourceDescription() : null), beanName, ex.getMessage(), ex);\n\t\t}\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\t/**\n\t\t\t * 调用所有 BeanPostProcessors#postProcessAfterInitialization\n\t\t\t * (作用 在Bean初始化之后调用)\n\t\t\t *\n\t\t\t * - AspectJAwareAdvisorAutoProxyCreator.class\n\t\t\t * org.springframework.aop.config.internalAutoProxyCreator 对应的类有根据情况有三个可能\n\t\t\t *   InfrastructureAdvisorAutoProxyCreator.class,\n\t\t\t *   AspectJAwareAdvisorAutoProxyCreator.class,\n\t\t\t *   AnnotationAwareAspectJAutoProxyCreator.class\n\t\t\t *\n\t\t\t *  如果需要代理, 这里会真正的对原始 bean 进行代理  进行代理的创建 createProxy\n\t\t\t *\n\t\t\t */\n\t\t\twrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\treturn wrappedBean;\n\t}\n</code></pre>\n<h3 id=\"总结-9\">总结</h3>\n<pre><code>1. 为 beanFactory 设置类型转换器(ConversionService) 属性填充时会用到 {@link AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory)}\n2. 为 beanFactory 添加变量解析器 (StringValueResolver)\n\t如果 beanFactory 上下文中不包含 \"默认的变量解析器 (类似 PropertySourcesPlaceholderConfigurer) 解析类似 '${}' 这样的变量 \"\n\t则使用环境对象(ConfigurableEnvironment)中的 ConfigurablePropertyResolver实现来作为 StringValueResolver 添加进去\n3. 冻结配置, 此后就不再允许更改 beanDefinition 了\n4. 实例化所有剩余的 (非lazy-init) 单例 Bean\n5. 处理 FactoryBean 类型的bean {@link DefaultListableBeanFactory#preInstantiateSingletons()}\n\t如果该bean是 FactoryBean, 则在 bean name 前面加一个 '&amp;' 前缀, 先获取/实例化 FactoryBean 本身;\n\t(注意一下 FactoryBean 生成对象是不遵循 Spring 的bean生命周期的)\n\t这有两个对象, 如何获取? getBean(beanName) :\n\t1. 传入 FactoryBean 的 name 返回的是其 getObject 的目标对象实例;\n\t2. 如果想获取 FactoryBean 本身实例, 则前面需要加一个 '&amp;' 前缀;\n6. 尝试从当前容器 一 二 三级缓存获取 {@link AbstractBeanFactory#doGetBean(String, Class, Object[], boolean)}\n7. 处理 AOP 代理对象生成 {@link AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])}\n8. 在JVM层面实例化对象 {@link AbstractAutowireCapableBeanFactory#doCreateBean(String, RootBeanDefinition, Object[])}\n\t1.真正在jvm层面实例化对象;\n\t\t1. 如果该 BeanDefinition 有配置 instanceSupplier属性(java.util.function.Supplier),\n\t\t 将使用其Supplier#get方法的返回, 作为实例对象\n\t\t2. 如果该 BeanDefinition 有配置 factory-method 将使用该方法返回的, 作为实例对象\n\t\t 这里这里包括'静态工厂'和'实例工厂'的处理(通过bd的factoryBeanName 进行判断, 如果存在则是'实例工厂')\n\t\t3. 使用反射实例化, 根据策略实例化Bean对象 {@link org.springframework.beans.factory.support.SimpleInstantiationStrategy}\n\t\t- 使用有参构造函数注入,创建 (new)\n\t\t- 使用无参构造函数创建 (new)\n\t\t- 工厂方法实例化 ('静态工厂' '实例工厂' )\n\t\t`&lt;bean  factory-bean=\"bookFactoryBean\"  factory-method=\"getBook()\"/&gt;`\n\t\t静态工厂: factory-bean 若是 全限定类名 则使用 BookFactoryBean::getBook 的静态方法返回的对象\n\t\t实例工厂:  factory-bean 若是 bean 名 则使用该实例方法返回的对象\n\t2. 用BeanWrapper 包装原始bean (装饰模式)\n\t3. 初始化 BeanWrapper\n\t\t1. 给 BeanWrapper 设置了, ConversionService\n\t\t2. 给 BeanWrapper 注册了, 当前 bean factory (propertyEditorRegistrars)中的全部 PropertyEditor\n\t\t3. 处理 MergedBeanDefinitionPostProcessor 的接口回调 {@link AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class, String)}\n\t\t调用 添加在 context 中 BeanPostProcessor 的 MergedBeanDefinitionPostProcessor 的接口回调\n\t\t解析到诸如`@Autowired`之类的注解 (Metadata)元信息,合并到BeanDefinition中\n\t4. 填充Bean属性 {@link AbstractAutowireCapableBeanFactory#populateBean(String, RootBeanDefinition, BeanWrapper)}\n\t\t1. 如果是AOP, pointcut, advice相关的, synthetic 会配置为 true  调用 BeanPostProcessor 的子接口 InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation\n\t\t(作用是 在实例化之后，属性填充之前执行操作, 可以拦截属性填充操作)\n\t\t2. 处理注解的  byName 或者 byType 注入的属性\n\t\t3. 回调所有 InstantiationAwareBeanPostProcessor#postProcessProperties 方法\n\t\t比如, `@Autowired` 的处理对应实现类: {@link org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor}\n\t\t(作用是: 在工厂将属性值应用到给定bean之前，对它们进行处理)\n\t\t注意这里也只是解析, 并没有设置进去, 实际赋值方法见: {@link AbstractAutowireCapableBeanFactory#applyPropertyValues(java.lang.String, org.springframework.beans.factory.config.BeanDefinition, org.springframework.beans.BeanWrapper, org.springframework.beans.PropertyValues)}\n\t5. 初始化Bean对象 {@link AbstractAutowireCapableBeanFactory#initializeBean(String, Object, RootBeanDefinition)}\n\t\t1. 先调用这三个 BeanNameAware, BeanClassLoaderAware, BeanFactoryAware {@link AbstractAutowireCapableBeanFactory#invokeAwareMethods(String, Object)}\n\t\t这三个是在创建BeanFactory 时忽略的三个 Aware 接口\n\t\t2. 调用所有 BeanPostProcessors#postProcessBeforeInitialization (作用: 在Bean初始化之前调用) {@link AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization(Object, String)}\n\t\t3. 调用 init-method 方法 {@link AbstractAutowireCapableBeanFactory#invokeInitMethods(String, Object, RootBeanDefinition)}\n\t\t4. 调用所有 BeanPostProcessors#postProcessAfterInitialization (作用: 在Bean初始化之后调用) {@link AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization(Object, String)}\n\t6. 注册 bean销毁的工作(如果需要){@link AbstractBeanFactory#registerDisposableBeanIfNecessary(String, Object, RootBeanDefinition)}\n\t\t1. org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor#postProcessBeforeDestruction(Object,String) BPP接口\n\t\t2. org.springframework.beans.factory.DisposableBean 接口\n\t\t3. 自定义 destroy方法\n\t\t(在容器关闭时会调用会按这个顺序调用)\n\n</code></pre>\n<h2 id=\"十二-完成容器刷新\">十二 完成容器刷新</h2>\n<p><code>org.springframework.context.support.AbstractApplicationContext#finishRefresh</code></p>\n<pre><code class=\"language-java\">/**  \n * Finish the refresh of this context, invoking the LifecycleProcessor's * onRefresh() method and publishing the * {@link org.springframework.context.event.ContextRefreshedEvent}.  \n */\n protected void finishRefresh() {  \n   \n}\n</code></pre>\n<h3 id=\"总结-10\">总结</h3>\n<ol>\n<li>清理各种缓存</li>\n<li>为当前上下文初始化生命周期处理器</li>\n<li>发布 ContextRefreshedEvent (Context 完成刷新)事件</li>\n</ol>\n<h1 id=\"关于-bean-的继承parent属性\">关于 Bean 的继承(parent属性)</h1>\n<p>这里的继承和 java 语法中的继承没有任何关系, 不过思路是相通的; child bean 会继承 parent bean 的所有配置, 也可以覆盖一些配置, 当然也可以新增额外的配置;</p>\n<p>Spring 中提供了继承自 AbstractBeanDefinition 的 ChildBeanDefinition 来表示 child bean;</p>\n<p>看如下一个例子:</p>\n<pre><code class=\"language-xml\">&lt;bean id=\"inheritedTestBean\" abstract=\"true\" class=\"org.springframework.beans.TestBean\"&gt;\n    &lt;property name=\"name\" value=\"parent\"/&gt;\n    &lt;property name=\"age\" value=\"1\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"inheritsWithDifferentClass\" class=\"org.springframework.beans.DerivedTestBean\"\n        parent=\"inheritedTestBean\" init-method=\"initialize\"&gt;\n\n    &lt;property name=\"name\" value=\"override\"/&gt;\n&lt;/bean&gt;\n\n</code></pre>\n<p>parent bean 设置了 <code>abstract=\"true\"</code> 所以它不会被实例化, child bean<strong>(inheritsWithDifferentClass)</strong>继承了 parent bean<strong>(inheritedTestBean)</strong> 的<code> name</code> <code>age</code> 两个属性, 但是对 <code>name</code> 属性进行了覆写, 增加了<code>init-method</code>;</p>\n<p><strong>in short: 即配置继承, child bean 会继承 scope, 构造器参数值, 属性值, init-method, destroy-method 等等配置</strong></p>\n<pre><code class=\"language-java\">@Configuration\npublic class WebConfigBeans {\n\t\n\t@Autowired\n\tprivate RequestMappingHandlerAdapter handlerAdapter;\n\t\n\t@PostConstruct\n\tpublic void initEditableValidation(){\n\t\t//获得 RequestMappingHandler 中的 ConfigurableWebBindingInitializer\n\t\tConfigurableWebBindingInitializer initializer =(ConfigurableWebBindingInitializer)handlerAdapter.getWebBindingInitializer();\n\t\tif(initializer.getConversionService()!=null){\n\t\t\tGenericConversionService genericConversionService=(GenericConversionService)initializer.getConversionService();\n\t\t\t//添加自定义转换器\n\t\t\tgenericConversionService.addConverter(new StringToDateConverter());\n\t\t}\n\t}\n\t\n}\n</code></pre>\n<h1 id=\"关于-factorybean\">关于 FactoryBean</h1>\n<p><code>org.springframework.beans.factory.FactoryBean</code> 适用于 Bean 的创建过程比较复杂的场景, 比如数据库连接池的创建;</p>\n<p>我们假设现在需要创建一个 Person 的 Bean, 首先我们需要一个 Car 的实例, 我们这里假设 Car 的实例创建很麻烦, 那么我们可以把创建 Car 的复杂过程包装起来:</p>\n<p><strong>注意: 使用FactoryBean 完全自定义创建Bean, 不会走Bean生命周期的各种 Processor回调.</strong></p>\n<pre><code class=\"language-java\">public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;{\n    private String make; \n    private int year ;\n\n    public void setMake(String m){ this.make =m ; }\n\n    public void setYear(int y){ this.year = y; }\n\n    public Car getObject(){ \n      // 这里我们假设 Car 的实例化过程非常复杂, 反正就不是几行代码可以写完的那种\n      CarBuilder cb = CarBuilder.car();\n\n      if(year!=0) cb.setYear(this.year);\n      if(StringUtils.hasText(this.make)) cb.setMake( this.make ); \n      return cb.factory(); \n    }\n\n    public Class&lt;Car&gt; getObjectType() { return Car.class ; } \n\n    public boolean isSingleton() { return false; }\n}\n</code></pre>\n<p>装配的时候是怎么配置的:</p>\n<pre><code class=\"language-xml\">&lt;bean class = \"com.javadoop.MyCarFactoryBean\" id = \"car\"&gt;\n  &lt;property name = \"make\" value =\"Honda\"/&gt;\n  &lt;property name = \"year\" value =\"1984\"/&gt;\n&lt;/bean&gt;\n&lt;bean class = \"com.javadoop.Person\" id = \"josh\"&gt;\n  &lt;property name = \"car\" ref = \"car\"/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p><strong>简而言之 就是实现 FactoryBean的接口的bean, 有几个方法:<code>T getObject()</code> ,<code>Class&lt;?&gt; getObjectType();</code> <code>default boolean isSingleton()</code>, 用来封装创建复杂的bean</strong></p>\n<h1 id=\"关于循环依赖的处理\">关于循环依赖的处理</h1>\n<h2 id=\"为什么要需要三级缓存\">为什么要需要三级缓存?</h2>\n<p><code>singletonObjects</code>:<br />\n第一级缓存, 里面放置的是已经实例化好的单例对象, 是单例缓存池（singletonObjects）</p>\n<p><code>earlySingletonObjects</code>:<br />\n第二级缓存, 里面存放的是提早曝光的单例对象, 早期对象（earlySingletonObjects）. 简单粗暴的说就是new的对象, 可是这个对象还没填充属性</p>\n<p><code>singletonFactories</code>:<br />\n第三级缓存, 里面存放的是将要被实例化的对象的对象工厂（存放 bean 工厂对象）, 是一个包裹对象<code>ObjectFactory(registeredSingletons)</code>, 经过getObject获取到早期对象.</p>\n<p>正常来讲, 处理循环依赖, 类似交换变量, 只需要一级缓存就可以了; 加上单例缓存池, 两级缓存池即可;</p>\n<pre><code class=\"language-js\">function swap(a, b){\n\ttemp = a;\n\ta = b;\n\tb = temp;\n}\n</code></pre>\n<p>例如: <code>Aservice</code> 依赖 Bservice, <code>Bservice</code> 依赖 <code>Aservice</code>.</p>\n<p>创建 <code>Aservice</code> 时, 将生成A的lambda放入三级缓存, 填充属性 <code>Bservice</code>, 一二三级缓存中都没,<br />\n去创建 <code>Bservice</code>, 将生成B的lambda放入三级缓存, 填充 <code>Aservice</code> 属性, 发现三级缓存中有A, 执行A的lambda生成 <code>Aservice</code> 对象, 放入二级缓存(不能放一级这时候A的Bservice属性还是null), 并删除A的三级缓存,<br />\n继续执行B的 lambda 生成 <code>Bservice</code> 对象, 放入一级缓存, 并删除B的三级缓存;<br />\n创建 <code>Aservice</code> 的流程中获取到Bservice对象之后, 把二级缓存的 <code>Aservice</code> 对象删除, 并放入一级缓存.</p>\n<p>第三级缓存是处理 AOP 增强的bean 问题:<br />\n<strong>因为不知道当前对象什么时候会被引用, 所以只能在第一次引用的时候来判断对象是否需要被代理, 所以它是一个lambda表达式</strong></p>\n<h1 id=\"关于生命周期\">关于生命周期</h1>\n<h2 id=\"spring中的bean生命周期\">Spring中的Bean生命周期</h2>\n<p>Spring中的Bean生命周期可以分为以下几个阶段:</p>\n<ol>\n<li>实例化（Instantiation）: 在这个阶段, Spring容器根据Bean的配置信息创建Bean实例. 通常, 这是通过构造函数或工厂方法来完成的.</li>\n<li>属性赋值（Property Assignment）: 在实例化之后, Spring容器将会对Bean的属性进行赋值. 这可以通过setter方法、注解、或构造函数参数来实现.</li>\n<li>Aware接口回调（Aware Interface Callbacks）: 在属性赋值之后, Spring容器会检查Bean是否实现了Aware接口. 如果实现了, 容器会调用相应的Aware接口回调方法, 让Bean获取与容器相关的额外信息.</li>\n<li>初始化（Initialization）: 在属性赋值完成后, Spring容器会调用Bean的初始化回调方法. 这可以通过实现InitializingBean接口的afterPropertiesSet()方法或在配置文件中声明的自定义初始化方法来实现.</li>\n<li>BeanPostProcessor回调（BeanPostProcessor Callbacks）: 在Bean初始化之前和之后, Spring容器会调用注册的BeanPostProcessor接口的方法. 这允许您在Bean的初始化过程中进行自定义处理, 如添加额外的逻辑或对Bean进行代理包装.</li>\n<li>使用（Bean in Use）: 在初始化完成后, Bean就可以被应用程序使用了</li>\n<li>销毁（Destruction）: 当容器关闭或者从容器中移除Bean时, 会触发Bean的销毁. 这可以通过实现 DisposableBean 接口的destroy()方法或在配置文件中声明的自定义销毁方法来实现.</li>\n</ol>\n<p>实例化 -&gt; 填充属性 -&gt; 各种Aware<br />\n-&gt; 调用 BeanPostProcessor (初始前)<br />\n-&gt; 调用 InitializingBean -&gt; 调用自定义 init-method<br />\n-&gt; 调用 BeanPostProcessor (初始后)<br />\n&lt;使用&gt;<br />\n-&gt; 调用 DisposableBean -&gt; 调用自定义 destroy-method</p>\n\n</div>\n<div id=\"MySignature\">\n    预防老年痴呆，保持终身学习!    —— <a href=\"https://www.cnblogs.com/dddy/\" target=\"_blank\">daidaidaiyu</a>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 22:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/dddy\">daidaidaiyu</a>&nbsp;\n阅读(<span id=\"post_view_count\">23</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从Shapefile到GeoJSON：用GDAL实现GIS矢量数据读写与空间分析",
      "link": "https://www.cnblogs.com/charlee44/p/19479143",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/charlee44/p/19479143\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 20:25\">\n    <span>从Shapefile到GeoJSON：用GDAL实现GIS矢量数据读写与空间分析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"从Shapefile到GeoJSON：用GDAL实现GIS矢量数据读写与空间分析\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1000410/202601/1000410-20260113202625252-636759511.png\" />\n        通过 GDAL/OGR 实现了 GIS 矢量数据的完整处理流程——从 Shapefile 读取、WGS84 到 Web 墨卡托坐标转换，到 GeoJSON 写入，并演示了点与多边形拓扑关系（如 Contains）的判断方法。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>本文节选自作者新书<a href=\"https://item.jd.com/14603137.html\" rel=\"noopener nofollow\" target=\"_blank\">《GIS基础原理与技术实践》</a>第4章，系统讲解矢量数据开发基础，涵盖 OGR/GDAL 使用、坐标转换、拓扑判断等实战内容。</p>\n</blockquote>\n<p><img alt=\"GIS基础原理与技术实践\" class=\"lazyload\" /></p>\n<h2 id=\"44-矢量数据开发基础\">4.4 矢量数据开发基础</h2>\n<p>通过之前的介绍，相信读者已经对于GIS的矢量数据有了一个全面的认识，尽管可能不是那么深入。但是没有关系，我们可以在实际的开发过程中加深对其的认识。</p>\n<h3 id=\"441-第三方开源库ogrgdal\">4.4.1 第三方开源库OGR/GDAL</h3>\n<p>在第3章的时候，我们小试牛刀，通过第三方开源库PROJ/GDAL很简单的就实现了地理空间参考系统的相互转换。在这里同样如此，我们可以通过GDAL的OGR组件，轻松实现GIS矢量数据的基础开发。</p>\n<p>OGR曾经是一个独立的矢量IO库，表示OpenGIS Simple Features Reference Implementation的意思，但其实OGR不完全符合OGC的Simple Feature标准规范，因此未被批准作为该规范的参考实现（当然也非常接近规范了）。从GDAL2.0开始，GDAL和OGR组件被集成在一起。</p>\n<p>OGR/GDAL提供了非常强大的矢量读写能力，支持市面上绝大多数矢量数据格式。在第3章我们介绍GDAL的时候就提到过，GDAL是一个GIS数据抽象库。所谓数据抽象，是指无论是哪一种具体的矢量数据格式，GDAL都会将其抽象成数据集对象（Dataset），从而可以支持读取、写出和处理操作。常用的矢量数据格式如下：</p>\n<ul>\n<li>DXF/DWG：应用最广泛的几何图形数据格式，在CAD领域内用的非常多，但是缺点是缺少地理信息。</li>\n<li>ESRI Shapefile：GIS中最常见的矢量数据格式，几乎所有的商业和开源GIS软件都支持。除了几何信息之外，还包含空间信息和属性信息。</li>\n<li>GeoJSON：一种通过JSON来表述要素的矢量数据格式，因而很容易被JavaScript解析和处理，适用于Web端的轻量化应用。</li>\n<li>KML：Google提出的一种基于XML标准来描述地理空间信息的数据格式（包括点、线、面、多边形和模型等），并且已经被OGC认定为开放地理信息编码标准。</li>\n</ul>\n<p>在GDAL中，对数据格式的支持被封装成驱动（dirver），包括上述格式在内的数据驱动要么内嵌在GDAL中，要么通过另外的第三方库来支持。当然这些我们可以暂时不用关心，直接使用本书Github主页代码仓库中的GDAL即可。</p>\n<h3 id=\"442-矢量数据的读取处理和写入\">4.4.2 矢量数据的读取、处理和写入</h3>\n<p>了解了第三方库OGR/GDAL，接下来我们就通过其实现关于GIS矢量数据的基础开发。一个很容易理解的常识是，包含GIS矢量数据在内的任何数据的操作都离不开三个过程：读取、处理和写入。因此，这里我们结合前面空间坐标参考转换的实践，实现一个简单的实例：读取一个面的矢量，然后对其进行空间参考的转换，最后重新写出一个矢量。具体的实现代码如下：</p>\n<pre><code class=\"language-cpp\">#include &lt;ogrsf_frmts.h&gt;\n\n#include &lt;Eigen/Eigen&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nusing namespace Eigen;\n\nusing Point = Vector3d;\nusing Line = vector&lt;Point&gt;;\nusing Polygon = vector&lt;Line&gt;;\n\nvector&lt;Polygon&gt; polygonData;\n\nOGRSpatialReference srcFileSpatialReference;\nOGRSpatialReference dstFileSpatialReference;\n\nvoid OgrRing2Line(OGRLinearRing *ogrLinearRing, Line &amp;line) {\n  for (int i = 0; i &lt; ogrLinearRing-&gt;getNumPoints(); i++) {\n    line.emplace_back(ogrLinearRing-&gt;getX(i), ogrLinearRing-&gt;getY(i),\n                      ogrLinearRing-&gt;getZ(i));\n  }\n}\n\nvoid OgrPolygon2Polygon(OGRPolygon *ogrPolygon, Polygon &amp;polygon) {\n  //外环\n  Line line;\n  OgrRing2Line(ogrPolygon-&gt;getExteriorRing(), line);\n  polygon.push_back(line);\n\n  //内环\n  for (int ri = 0; ri &lt; ogrPolygon-&gt;getNumInteriorRings(); ri++) {\n    Line line;\n    OgrRing2Line(ogrPolygon-&gt;getInteriorRing(ri), line);\n    polygon.push_back(line);\n  }\n}\n\nbool ReadShp() {\n  string srcFile = getenv(\"GISBasic\");\n  srcFile = srcFile + \"/../Data/Vector/multipolygons.shp\";\n\n  GDALDataset *poDS = (GDALDataset *)GDALOpenEx(srcFile.c_str(), GDAL_OF_VECTOR,\n                                                NULL, NULL, NULL);\n  if (!poDS) {\n    printf(\"无法读取该文件，请检查数据是否存在问题！\");\n    return false;\n  }\n\n  if (poDS-&gt;GetLayerCount() &lt; 1) {\n    printf(\"该文件的层数小于1，请检查数据是否存在问题！\");\n    return false;\n  }\n\n  //原始数据空间参考\n  char *pszWKT = nullptr;\n  poDS-&gt;GetLayer(0)-&gt;GetSpatialRef()-&gt;exportToWkt(&amp;pszWKT);\n  srcFileSpatialReference.importFromWkt(pszWKT);\n  CPLFree(pszWKT);\n  pszWKT = nullptr;\n\n  for (int li = 0; li &lt; poDS-&gt;GetLayerCount(); li++) {\n    OGRLayer *poLayer = poDS-&gt;GetLayer(li);  //读取层\n    poLayer-&gt;ResetReading();\n\n    //输出字段名\n    OGRFeatureDefn *poFDefn = poLayer-&gt;GetLayerDefn();\n    int n = poFDefn-&gt;GetFieldCount();\n    for (int iField = 0; iField &lt; n; iField++) {\n      OGRFieldDefn *OGRFieldDefn = poFDefn-&gt;GetFieldDefn(iField);\n      cout &lt;&lt; OGRFieldDefn-&gt;GetNameRef() &lt;&lt; endl;\n    }\n\n    //遍历特征\n    OGRFeature *poFeature = nullptr;\n    while ((poFeature = poLayer-&gt;GetNextFeature()) != nullptr) {\n      OGRGeometry *geometry = poFeature-&gt;GetGeometryRef();\n      OGRwkbGeometryType geometryType = geometry-&gt;getGeometryType();\n\n      switch (geometryType) {\n        case wkbPolygon:\n        case wkbPolygonM:\n        case wkbPolygonZM: {\n          OGRPolygon *ogrPolygon = dynamic_cast&lt;OGRPolygon *&gt;(geometry);\n          if (!ogrPolygon) {\n            continue;\n          }\n\n          Polygon polygon;\n          OgrPolygon2Polygon(ogrPolygon, polygon);\n          polygonData.push_back(polygon);\n\n          break;\n        }\n        case wkbMultiPolygon:\n        case wkbMultiPolygonM:\n        case wkbMultiPolygonZM: {\n          OGRMultiPolygon *ogrMultiPolygon =\n              dynamic_cast&lt;OGRMultiPolygon *&gt;(geometry);\n          if (!ogrMultiPolygon) {\n            continue;\n          }\n\n          for (int gi = 0; gi &lt; ogrMultiPolygon-&gt;getNumGeometries(); gi++) {\n            OGRPolygon *ogrPolygon =\n                dynamic_cast&lt;OGRPolygon *&gt;(ogrMultiPolygon-&gt;getGeometryRef(gi));\n            if (!ogrPolygon) {\n              continue;\n            }\n\n            Polygon polygon;\n            OgrPolygon2Polygon(ogrPolygon, polygon);\n            polygonData.push_back(polygon);\n          }\n\n          break;\n        }\n        default: {\n          printf(\"未处理的特征类型\\n\");\n          break;\n        }\n      }\n\n      //输出每个字段的值\n      for (int iField = 0; iField &lt; n; iField++) {\n        cout &lt;&lt; poFeature-&gt;GetFieldAsString(iField) &lt;&lt; \"    \";\n      }\n      cout &lt;&lt; endl;\n\n      OGRFeature::DestroyFeature(poFeature);\n    }\n  }\n\n  GDALClose(poDS);\n  poDS = nullptr;\n\n  return true;\n}\n\nvoid Convert() {\n  dstFileSpatialReference.importFromEPSG(3857);\n  dstFileSpatialReference.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n  srcFileSpatialReference.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n\n  OGRCoordinateTransformation *src2DstTransformation =\n      OGRCreateCoordinateTransformation(&amp;srcFileSpatialReference,\n                                        &amp;dstFileSpatialReference);\n\n  if (!src2DstTransformation) {\n    return;\n  }\n\n  for (auto &amp;polygon : polygonData) {\n    for (auto &amp;line : polygon) {\n      for (auto &amp;point : line) {\n        src2DstTransformation-&gt;Transform(1, point.data(), point.data() + 1,\n                                         point.data() + 2);\n      }\n    }\n  }\n}\n\nbool CreateField(OGRLayer *poLayer) {\n  // 字符串\n  OGRFieldDefn oField1(\"Type\", OFTString);\n  oField1.SetWidth(8);\n  if (poLayer-&gt;CreateField(&amp;oField1) != OGRERR_NONE) {\n    printf(\"Creating Name field failed.\\n\");\n    return false;\n  }\n\n  // 浮点数\n  OGRFieldDefn oField2(\"Area\", OFTReal);\n  oField2.SetPrecision(3);\n  if (poLayer-&gt;CreateField(&amp;oField2) != OGRERR_NONE) {\n    printf(\"Creating Name field failed.\\n\");\n    return false;\n  }\n\n  // 整型\n  OGRFieldDefn oField3(\"VertexCount\", OFTInteger);\n  if (poLayer-&gt;CreateField(&amp;oField3) != OGRERR_NONE) {\n    printf(\"Creating Name field failed.\\n\");\n    return false;\n  }\n\n  return true;\n}\n\nbool WriteGeoJson() {\n  string dstFile = getenv(\"GISBasic\");\n  dstFile = dstFile + \"/../Data/Out.geoJson\";\n\n  //创建\n  GDALDriver *driver = GetGDALDriverManager()-&gt;GetDriverByName(\"GeoJSON\");\n  if (!driver) {\n    printf(\"Get Driver GeoJSON Error！\\n\");\n    return false;\n  }\n\n  GDALDataset *dataset =\n      driver-&gt;Create(dstFile.c_str(), 0, 0, 0, GDT_Unknown, NULL);\n  OGRLayer *poLayer = dataset-&gt;CreateLayer(\n      \"FirstLayer\", &amp;dstFileSpatialReference, wkbPolygon, NULL);\n\n  if (!CreateField(poLayer)) {\n    return false;\n  }\n\n  //创建特征\n  for (const auto &amp;polygon : polygonData) {\n    OGRFeature ogrFeature(poLayer-&gt;GetLayerDefn());\n\n    OGRPolygon ogrPolygon;\n\n    int vertexNum = 0;\n    for (const auto &amp;line : polygon) {\n      OGRLinearRing ogrRing;\n      for (const auto &amp;point : line) {\n        ogrRing.addPoint(point.x(), point.y(), point.z());\n        vertexNum++;\n      }\n      ogrPolygon.addRing(&amp;ogrRing);\n    }\n    ogrFeature.SetGeometry(&amp;ogrPolygon);\n\n    ogrFeature.SetField(\"Type\", \"Polygon\");\n    ogrFeature.SetField(\"Area\", ogrPolygon.get_Area());\n    ogrFeature.SetField(\"VertexCount\", vertexNum);\n\n    if (poLayer-&gt;CreateFeature(&amp;ogrFeature) != OGRERR_NONE) {\n      printf(\"Failed to create feature.\\n\");\n      return false;\n    }\n  }\n\n  //释放\n  GDALClose(dataset);\n  dataset = nullptr;\n\n  return true;\n}\n\nint main() {\n  GDALAllRegister();\n  CPLSetConfigOption(\"GDAL_FILENAME_IS_UTF8\", \"NO\");  //支持中文路径\n  CPLSetConfigOption(\"SHAPE_ENCODING\", \"\");           //解决中文乱码问题\n\n  if (!ReadShp()) {\n    return 1;\n  }\n\n  Convert();\n\n  WriteGeoJson();\n}\n</code></pre>\n<p>在这里，读取的矢量是一个Shapefile文件，包含的都是多边形的要素，空间参考为WGS84地理坐标系（EPSG：4326），显示如下图4.14所示：</p>\n<p><img alt=\"图4.14 处理前多边形矢量要素\" class=\"lazyload\" /></p>\n<p>经过空间参考转换后，空间参考为Web墨卡托投影坐标系（EPSG：3857），且生成的是一个GeoJson文件。如下图4.15所示，可以看到在空间坐标参考转换之后形状似乎“变窄”了一点，这是地图投影变换的特性决定的（参考第2章介绍的知识）。</p>\n<p><img alt=\"图4.15 处理后多边形矢量要素\" class=\"lazyload\" /></p>\n<p>这段代码的关键在于如下几点：</p>\n<ul>\n<li>\n<p>读取矢量时，矢量数据被读取成数据集对象GDALDataset，GDALDataset管理图层对象OGRLayer，OGRLayer管理特征类对象OGRFeature，OGRFeature则包含几何对象类OGRGeometry。OGRGeometry是一个抽象父类，有意义的是其表达具体的几何对象的子类，比如OGRPolygon代表多边形几何对象。OGRPolygon又是由1个外环和多个内环（环线：OGRLinearRing）组成。矢量就是这样一层层抽象组合表达出来的。</p>\n</li>\n<li>\n<p>在进行数据处理也就是空间参考转换之前，我们把读取的数据放到我们自己的数据容器中：</p>\n<pre><code class=\"language-cpp\">using Point = Vector3d;\nusing Line = vector&lt;Point&gt;;\nusing Polygon = vector&lt;Line&gt;;\n\nvector&lt;Polygon&gt; polygonData;\n</code></pre>\n<p>真实的GIS数据处理开发要求是千变万化的，操作的往往不是读取组件（这里指OGR）定义的数据结构对象。我们可以将其读取在成自定义的数据结构中，以方便我们进行更加通用的操作，或者进行并行优化。在这里我们遍历了自定义的数据结构对象中的顶点，逐点进行空间坐标参考的转换。进行其他的数据处理也是如此，根据自己的需要操作自己的数据结构容器。</p>\n</li>\n<li>\n<p>写出矢量时，将处理结束的自定义数据结构对象恢复成数据集对象GDALDataset（读取矢量的逆操作）。另外，需要关注的是GDAL的数据驱动GDALDriver，其是通过名称来创建对应格式的矢量文件，例如这里传入到名称是GeoJson:</p>\n<pre><code class=\"language-cpp\">GDALDriver *driver = GetGDALDriverManager()-&gt;GetDriverByName(\"GeoJSON\");\nif (!driver) {\n  printf(\"Get Driver GeoJSON Error！\\n\");\n  return false;\n}\n</code></pre>\n</li>\n<li>\n<p>矢量数据的属性表数据与数据库中的表结构比较类似，每个字段具有自己的定义属性，例如数据类型、长度、精度等。并且，每一个特征都对应了一行记录。因而属性表的操作还是挺复杂的，往往与业务操作相关联。这里仅仅只是输出显示了读取的属性表信息，写入了自己创建的字段与值。读取和写入的属性表数据如下图4.16、图4.17所示：</p>\n</li>\n</ul>\n<p><img alt=\"图4.16 读取的属性表信息\" class=\"lazyload\" /><br />\n<img alt=\"图4.17 写入的属性表信息\" class=\"lazyload\" /></p>\n<h3 id=\"443-空间拓扑关系的判断\">4.4.3 空间拓扑关系的判断</h3>\n<p>对矢量要素进行空间拓扑关系的判断也是GIS开发中常用的功能。在4.3.3节中介绍了OGC的Simple Feature标准规范中拓扑关系，OGR/GDAL对其做了具体的实现。任何继承了OGRGeometry的几何对象类（如OGRPoint、OGRPolygon）都可以调用标准中定义的接口（二元谓词），判断该几何对象与另外一个几何对象的拓扑关系。在如下实例中，判断了空间中某点与某多边形是否存在包含（Contains）关系：</p>\n<pre><code class=\"language-cpp\">#include &lt;ogrsf_frmts.h&gt;\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n  OGRLinearRing linearRing;\n  linearRing.addPoint(268.28, 784.75);\n  linearRing.addPoint(153.98, 600.60);\n  linearRing.addPoint(274.63, 336.02);\n  linearRing.addPoint(623.88, 401.64);\n  linearRing.addPoint(676.80, 634.47);\n  linearRing.addPoint(530.75, 822.85);\n  linearRing.closeRings();\n\n  OGRPolygon polygon;\n  polygon.addRing(&amp;linearRing);\n\n  cout &lt;&lt; \"点A是否在多边形内：\";\n  OGRPoint pointA(407.98, 579.43);  \n  cout &lt;&lt; polygon.Contains(&amp;pointA) &lt;&lt; endl;\n\n  cout &lt;&lt; \"点B是否在多边形内：\";\n  OGRPoint pointB(678.92, 482.07);  \n  cout &lt;&lt; polygon.Contains(&amp;pointB) &lt;&lt; endl;\n}\n</code></pre>\n<p>运行的结果如下所示：</p>\n<pre><code class=\"language-text\">点A是否在多边形内：1\n点B是否在多边形内：0\n</code></pre>\n<p>在4.3.3节中介绍过，包含(Contains)与内含(Within)是一对相反的关系。在这里我们当然也可以调用OGRPoint的内含(Within)接口，会返回与上述同样的结果。不止如此，其他空间拓扑关系的接口也是这样调用，读者可以根据自己的需求尝试一二，这里只是抛砖引玉。</p>\n<hr />\n<p>本文节选自作者新书《GIS基础原理与技术实践》第4章。书中系统讲解 GIS 核心理论与多语言实战，适合开发者与高校师生。</p>\n<p>📚 <strong>配套资源开源</strong>：<a href=\"https://github.com/fafa1899/GISBasic\" rel=\"noopener nofollow\" target=\"_blank\">GitHub</a> | <a href=\"https://gitcode.com/charlee44/GISBasic\" rel=\"noopener nofollow\" target=\"_blank\">GitCode</a></p>\n<p>🛒 <strong>支持正版</strong>：<a href=\"https://item.jd.com/14603137.html\" rel=\"noopener nofollow\" target=\"_blank\">京东</a>｜<a href=\"https://product.dangdang.com/29988568.html\" rel=\"noopener nofollow\" target=\"_blank\">当当</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-13 20:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/charlee44\">charlee44</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "电位器实现电机绝对位置测量-PART-电位计-绝对位置",
      "link": "https://www.cnblogs.com/SimLab/p/19479117",
      "published": "",
      "description": "<h2>\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/SimLab/p/19479117\" id=\"cb_post_title_url\" title=\"发布于 2026-01-13 20:11\">\n    <span>电位器实现电机绝对位置测量-PART-电位计-绝对位置</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"postbody\">\n            <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"电位器实现电机绝对位置测量-part-电位计-绝对位置\">电位器实现电机绝对位置测量-PART-电位计-绝对位置</h1>\n<blockquote>\n<p><strong>关键字</strong>：绝对位置, 电位器, Vishay Spectrol, 132</p>\n</blockquote>\n<hr />\n<h2 id=\"一问题分析\">一、问题分析</h2>\n<p>在运动控制实验中，我们需要测量旋转电机在有限角度范围（如 0–90°）内来回摆动的<strong>绝对位置</strong>。</p>\n<p>常规方法：</p>\n<ul>\n<li>绝对编码器或增量编码器输出数字信号，精度高。</li>\n</ul>\n<p>现场问题：</p>\n<ul>\n<li><strong>实验硬件本身不支持绝对编码器采集</strong>，无法直接使用</li>\n<li>摆动角度有限（不需要全圈 360°）</li>\n<li>系统需要稳定、可实时获取绝对位置的方案</li>\n</ul>\n<blockquote>\n<p>核心问题：如何在硬件不支持绝对编码器采集的情况下，实现可靠的绝对位置测量？</p>\n</blockquote>\n<hr />\n<h2 id=\"二解决方法--实施方案\">二、解决方法 / 实施方案</h2>\n<h3 id=\"1️⃣-硬件方案\">1️⃣ 硬件方案</h3>\n<ul>\n<li><strong>电位器选型</strong>：Vishay Spectrol Model 132（旋转角 352°）</li>\n<li><strong>齿轮传动</strong>：电机轴 → 齿轮 → 电位器滑动轴\n<ul>\n<li>电机旋转角 → 齿轮比 → 电位器滑动角</li>\n<li>保证电位器满量程覆盖实验摆动角度</li>\n</ul>\n</li>\n<li><strong>供电与电路设计</strong>：\n<ul>\n<li>电位器两端各自串7.5 kΩ 电阻分别接入 ±12 V 供电</li>\n<li>输出电压与摆动角度线性映射</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2️⃣-示意图\">2️⃣ 示意图</h3>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"三使用提示\">三、使用提示</h2>\n<ul>\n<li>实验硬件不支持绝对编码器采集时，可使用电位器方案</li>\n<li>摆动角度有限（通常 0–90°）时，132 型电位器配齿轮可覆盖全范围</li>\n<li>电位器末端预留死区，避免机械磨损</li>\n<li>齿轮比合理设计，保证电位器满量程对应实验摆动角度</li>\n<li>输出电压可直接用于采集系统或模拟控制器</li>\n<li>若实验需要更大角度或全圈测量，可考虑升级电位器或使用绝对编码器</li>\n</ul>\n<blockquote>\n<p>总结：在硬件不支持绝对编码器采集的实验环境下，<strong>132 型电位器 + 齿轮传动 + 串联电阻供电</strong>是一种稳定、可行的绝对位置测量方案，操作简单，实验验证稳定。</p>\n</blockquote>\n<hr />\n<h2 id=\"四说明\">四、说明</h2>\n<ul>\n<li>\n<blockquote>\n<p>本文首发于【GitHub/Gitee】，作者：KANIC，研究方向为 自动化实验平台、控制算法验证及半实物仿真系统。</p>\n</blockquote>\n<p>相关实验或程序已整理至 GitHub，可在 GitHub 平台搜索 KANIC-lab/KANIC 查看。</p>\n<p>如需进一步讨论，可私信联系，并注明文章编号。文章编号位于标题末尾，以字母开头如“EXP-XXXX-XXX”</p>\n</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n        </div>\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2026-01-13 20:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/SimLab\">控制迷思</a>&nbsp;\n阅读(<span id=\"post_view_count\">24</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    }
  ]
}