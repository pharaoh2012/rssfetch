{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "如何使用『页脚HTML代码』-实现自推广 -『AI实现的小程序&小游戏』",
      "link": "https://www.cnblogs.com/uoky/p/19410177",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/uoky/p/19410177\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 23:32\">\n    <span>如何使用『页脚HTML代码』-实现自推广 -『AI实现的小程序&amp;小游戏』</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div class=\"article-container\">\n<h1 style=\"font-size: 28px; font-weight: bold; margin: 0; color: rgba(44, 62, 80, 1);\">个人博客-自定义推广方案</h1>\n<p>&nbsp;</p>\n<div class=\"summary-section\">\n<h2 style=\"color: rgba(44, 62, 80, 1); font-size: 20px; margin-top: 0; display: flex;\"><span style=\"color: rgba(255, 255, 255, 1); width: 28px; height: 28px; border-radius: 50%; display: inline-flex; margin-right: 10px; font-size: 14px;\">!</span> 摘要</h2>\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(44, 62, 80, 1); margin: 10px 0;\"><strong style=\"color: rgba(52, 152, 219, 1); display: block; margin-bottom: 8px;\">使用AI写了超简易的微信小程序『Uoky统计』微信小游戏『木木玩躲避』，如何使用博客实现自定义推广</strong></p>\n</div>\n<div class=\"content-section\">\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(51, 51, 51, 1); margin: 0 0 15px; padding-left: 20px;\"><span style=\"color: rgba(52, 152, 219, 1); font-weight: bold;\">•</span> 目前AI写的小程序与小游戏均已上线，考虑推广。 <span style=\"text-decoration: line-through; color: rgba(149, 165, 166, 1); font-style: italic; background-color: rgba(248, 249, 250, 1); padding: 2px 6px; border-radius: 4px; margin-left: 5px;\"> 这个小程序和小游戏十分简易，没有任何技术含量，目前是纯浪费时间玩一下。 </span></p>\n<div class=\"image-crossed\" style=\"text-align: center; margin: 20px 0;\"><span style=\"text-decoration: line-through; color: rgba(149, 165, 166, 1); font-style: italic; display: block;\"> <img alt=\"生成特定内容的图片\" height=\"185\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227223009141-400083286.png\" width=\"185\" /> </span></div>\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(51, 51, 51, 1); margin: 15px 0 0; padding-left: 20px;\"><span style=\"color: rgba(52, 152, 219, 1); font-weight: bold;\">•</span> 虽然作者本人没有做什么开发方面的努力 <span style=\"text-decoration: line-through; color: rgba(149, 165, 166, 1); background-color: rgba(248, 249, 250, 1); padding: 2px 6px; border-radius: 4px; margin: 0 3px;\"> <em>找字体、音乐、音效、图标</em> </span> <span style=\"text-decoration: line-through; color: rgba(149, 165, 166, 1); background-color: rgba(248, 249, 250, 1); padding: 2px 6px; border-radius: 4px; margin: 0 3px;\"> <em>备案等后勤工作</em> </span> 。但毕竟上线了，还是想着推广一下</p>\n</div>\n<div class=\"emoji-section\" style=\"text-align: center; margin: 30px 0;\"><img alt=\"生成年迈感叹表情包 (2)\" height=\"273\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227224329737-1023925099.png\" width=\"273\" /></div>\n<div class=\"effect-section\">\n<div>&nbsp;</div>\n<h3 style=\"color: rgba(39, 174, 96, 1); font-size: 20px; margin-top: 0; display: flex; padding-top: 10px;\"><span style=\"color: rgba(255, 255, 255, 1); width: 30px; height: 30px; border-radius: 50%; display: inline-flex; margin-right: 12px; font-size: 14px;\">✓</span> 实现效果：</h3>\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(44, 62, 80, 1); margin: 15px 0 0; font-weight: 500;\">画面右下角显示：</p>\n<div class=\"image-center\"><br />\n<p>&nbsp;</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227232209151-931241342.png\" style=\"border-radius: 18px;\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n\n\n</div>\n\n\n</div>\n<div class=\"steps-section\">\n<div>&nbsp;</div>\n<h3 style=\"color: rgba(41, 128, 185, 1); font-size: 22px; margin-top: 0; padding-left: 15px;\"><span><br /></span>&nbsp; &nbsp; 实现步骤</h3>\n<div class=\"step\">\n<div style=\"display: flex; margin-bottom: 15px;\">\n<div style=\"color: rgba(255, 255, 255, 1); width: 36px; height: 36px; border-radius: 50%; display: flex; font-weight: bold; font-size: 18px; margin-right: 15px;\">1</div>\n<p style=\"font-size: 16px; color: rgba(44, 62, 80, 1); font-weight: 600; margin: 0;\">进入博客园设置</p>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"image-center\" style=\"text-align: center; margin: 15px 0;\"><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227220723565-782831602.png\" /></div>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"step\">\n<div style=\"display: flex; margin-bottom: 15px;\">\n<div style=\"color: rgba(255, 255, 255, 1); width: 36px; height: 36px; border-radius: 50%; display: flex; font-weight: bold; font-size: 18px; margin-right: 15px;\">2</div>\n<p style=\"font-size: 16px; color: rgba(44, 62, 80, 1); font-weight: 600; margin: 0;\">指定页脚HTML代码</p>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"image-center\" style=\"text-align: center; margin: 15px 0;\"><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227221106222-787541671.png\" /></div>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"success-message\">\n<p>添加超简单固定div即可，超级简单！</p>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"code-section\">\n<h4 style=\"color: rgba(52, 152, 219, 1); font-size: 18px; margin: 0 0 20px; display: flex;\"><span style=\"width: 34px; height: 24px; border-radius: 4px; display: inline-flex; margin-right: 10px; color: rgba(255, 255, 255, 1); font-size: 14px;\">&lt;/&gt;</span> 代码示例：</h4>\n<div class=\"image-center\" style=\"text-align: center; margin: 0;\"><img alt=\"image\" height=\"auto\" src=\"https://img2024.cnblogs.com/blog/2115870/202512/2115870-20251227221829466-798413403.png\" width=\"100%\" /></div>\n\n\n\n\n\n\n\n\n</div>\n\n\n\n\n\n\n\n\n</div>\n<div class=\"tip-section\">\n<div style=\"font-size: 30px; color: rgba(33, 150, 243, 1);\">💡</div>\n<h4 style=\"color: rgba(13, 71, 161, 1); font-size: 18px; margin-top: 0; display: flex;\"><span style=\"color: rgba(255, 255, 255, 1); width: 30px; height: 30px; border-radius: 50%; display: inline-flex; margin-right: 12px; font-size: 16px;\">i</span> 推广建议</h4>\n<p style=\"font-size: 15px; line-height: 1.7; color: rgba(13, 71, 161, 1); margin: 15px 0 0; font-weight: 500;\">如果你也有一些工具想要推广，建议在不影响自身博客内容显示的情况下，酌情添加。</p>\n\n\n\n\n\n\n\n\n</div>\n\n\n\n\n\n\n\n\n</div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 23:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/uoky\">人间春风意</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Sidecar不就是在Pod里多跑一个容器吗！",
      "link": "https://www.cnblogs.com/ydswin/p/19396769",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ydswin/p/19396769\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 19:05\">\n    <span>Sidecar不就是在Pod里多跑一个容器吗！</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>深入理解云原生时代的核心设计模式</p>\n</blockquote>\n<p>乍看之下，Sidecar 模式确实只是在 Pod 里多运行一个容器而已。但这种表面理解，就像说“互联网不过是一堆电缆和服务器”一样，忽略了其背后的精妙设计思想和革命性价值。今天，我们就来深入探讨这个看似简单却极具威力的云原生核心模式。</p>\n<h2 id=\"从一个认知误区说起\">从一个认知误区说起</h2>\n<p><strong>\"Pod 就是容器\"</strong>——这是许多 Kubernetes 初学者最常见的误解。事实上，Pod 并不是容器，而是<strong>容器的容器</strong>，是一个可以容纳一个或多个紧密关联容器的“逻辑主机”。</p>\n<p>当我们说“在 Pod 里多跑一个容器”时，这意味着什么？意味着这个额外的容器与主应用容器共享着几乎所有关键资源：<strong>网络命名空间</strong>（同一 IP，通过 localhost 直接通信）、<strong>存储卷</strong>（Volume）以及<strong>生命周期</strong>（同生共死）。</p>\n<p>这种共享关系，正是 Sidecar 魔力的源泉。</p>\n<h2 id=\"sidecar-的本质不只是多一个容器\">Sidecar 的本质：不只是“多一个容器”</h2>\n<h3 id=\"设计模式而非技术实现\">设计模式而非技术实现</h3>\n<p>Sidecar 本质上是一种<strong>容器设计模式</strong>，而不是简单的技术实现。它代表了一种架构哲学：将辅助功能从主业务逻辑中解耦，让专业容器做专业事。</p>\n<p>举个例子，想象一位主厨（主应用容器）在厨房工作。主厨专注炒菜（业务逻辑），而配菜、打扫、菜单更新等杂事由助手（Sidecar 容器）完成。这种分工协作大大提升了效率和专业性。</p>\n<h3 id=\"云原生时代的功能扩展槽\">云原生时代的“功能扩展槽”</h3>\n<p>在云原生架构中，Sidecar 如同计算机主板上的<strong>扩展槽</strong>，允许我们为应用动态添加各种能力而无须修改应用本身。</p>\n<ul>\n<li><strong>日志收集</strong>：主容器写日志到共享卷，Sidecar 容器负责收集和发送到日志系统</li>\n<li><strong>服务网格</strong>：如 Istio 使用 Envoy 作为 Sidecar 代理，实现服务间通信的监控、安全和控制</li>\n<li><strong>配置管理</strong>：Sidecar 监听配置中心，动态更新配置文件，主容器只需读取本地文件</li>\n<li><strong>安全代理</strong>：如 Vault Agent Sidecar，负责与密钥管理系统交互，主应用无感知</li>\n</ul>\n<h2 id=\"为什么多跑一个容器如此重要\">为什么“多跑一个容器”如此重要？</h2>\n<h3 id=\"1-无侵入式架构设计\">1. 无侵入式架构设计</h3>\n<p>传统做法中，要为应用添加监控、安全或通信功能，通常需要修改应用代码。而 Sidecar 模式通过“多跑一个容器”实现了<strong>零侵入</strong>的功能增强。</p>\n<p>以服务网格为例，应用代码无需关心服务发现、熔断、重试等复杂逻辑，所有这些都由 Sidecar 代理透明处理。</p>\n<h3 id=\"2-技术栈无关性\">2. 技术栈无关性</h3>\n<p>Sidecar 容器可以用任何语言编写，与主应用容器的技术栈无关。一个 Java 应用可以搭配一个 Go 或 Rust 编写的 Sidecar，充分发挥各语言优势。</p>\n<h3 id=\"3-独立性和可复用性\">3. 独立性和可复用性</h3>\n<p>Sidecar 容器可以<strong>独立开发、升级和部署</strong>。一个精心设计的日志收集 Sidecar 可以被全公司所有服务复用，大大降低开发维护成本。</p>\n<h2 id=\"实战示例sidecar-如何工作\">实战示例：Sidecar 如何工作</h2>\n<p>让我们通过一个具体例子看看“多跑一个容器”如何实际运作：</p>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx-with-logger\nspec:\n  volumes:\n  - name: nginx-logs\n    emptyDir: {}  # 临时共享目录\n\n  containers:\n  - name: nginx\n    image: nginx\n    volumeMounts:\n    - name: nginx-logs\n      mountPath: /var/log/nginx\n\n  - name: log-sidecar  # 这就是“多跑”的容器\n    image: busybox\n    command: [\"/bin/sh\", \"-c\"]\n    args:\n    - while true; do\n        if [ -f /var/log/nginx/access.log ]; then\n          tail -n 10 /var/log/nginx/access.log;\n        fi;\n        sleep 5;\n      done\n    volumeMounts:\n    - name: nginx-logs\n      mountPath: /var/log/nginx\n</code></pre>\n<p>在这个例子中：</p>\n<ul>\n<li><strong>nginx 容器</strong>：专注提供 Web 服务，将日志写入 <code>/var/log/nginx</code></li>\n<li><strong>log-sidecar 容器</strong>：负责读取日志并处理（示例中只是打印，实际可发送到日志系统）</li>\n</ul>\n<p>两个容器通过 <strong>emptyDir 卷</strong>共享日志目录，通过 <strong>localhost</strong> 通信（如果需要），共同构成一个完整的 Web 服务单元。</p>\n<h2 id=\"超越多一个容器sidecar-的高级模式\">超越“多一个容器”：Sidecar 的高级模式</h2>\n<h3 id=\"服务网格中的-sidecar\">服务网格中的 Sidecar</h3>\n<p>在服务网格（如 Istio）中，Sidecar 模式发挥到极致。每个 Pod 中注入的 Envoy 代理容器透明地拦截和处理所有进出流量，实现精细化的流量管理、安全加密和可观测性。</p>\n<p>这时，“多跑的容器”不再是简单的辅助角色，而是构成了<strong>分布式系统的通信基础设施</strong>。</p>\n<h3 id=\"适配器模式\">适配器模式</h3>\n<p>Sidecar 可以作为<strong>适配器</strong>，在不同接口或协议间进行转换。例如，主容器暴露 <code>/metrics</code> 接口，而监控系统需要 <code>/health</code> 接口，Sidecar 容器负责协议转换，无需修改主应用。</p>\n<h2 id=\"最佳实践与注意事项\">最佳实践与注意事项</h2>\n<p>虽然 Sidecar 功能强大，但也需要谨慎使用：</p>\n<h3 id=\"启动顺序协调\">启动顺序协调</h3>\n<p>Kubernetes 不保证容器启动顺序，如果 Sidecar 需要先于主容器就绪（如配置同步 Sidecar），需要通过 initContainers 或健康检查机制协调。</p>\n<h3 id=\"资源管理\">资源管理</h3>\n<p>为 Sidecar 设置合理的资源请求和限制，避免与主容器资源争抢。</p>\n<pre><code class=\"language-yaml\">resources:\n  requests:\n    cpu: 100m\n    memory: 128Mi\n  limits:\n    cpu: 200m\n    memory: 256Mi\n</code></pre>\n<h3 id=\"避免过度使用\">避免过度使用</h3>\n<p>不是所有功能都适合 Sidecar 模式。如果架构不复杂，直接使用 API 网关或传统中间件可能更简单。</p>\n<h2 id=\"与其他模式的关系\">与其他模式的关系</h2>\n<h3 id=\"sidecar-vs-init-容器\">Sidecar vs Init 容器</h3>\n<ul>\n<li><strong>Init 容器</strong>：在 Pod 启动前运行，完成即退出，用于初始化工作</li>\n<li><strong>Sidecar 容器</strong>：与主容器并行运行，在整个生命周期内提供辅助功能</li>\n</ul>\n<h3 id=\"sidecar-vs-daemonset\">Sidecar vs DaemonSet</h3>\n<ul>\n<li><strong>Sidecar</strong>：每个应用实例一个，与特定应用紧密绑定</li>\n<li><strong>DaemonSet</strong>：每个节点一个，提供节点级别服务</li>\n</ul>\n<h2 id=\"总结简单概念背后的深远影响\">总结：简单概念背后的深远影响</h2>\n<p>回到最初的问题：“Sidecar 不就是 Pod 里多跑一个容器吗？”——<strong>是，但远不止于此</strong>。</p>\n<p>这个看似简单的“多跑一个容器”设计，实际上代表了云原生架构的核心思想：<strong>关注点分离、松散耦合、可复用性</strong>。它让应用开发者专注业务逻辑，而将通用能力下沉到基础设施层。</p>\n<p>从简单的日志收集到复杂的服务网格，从配置管理到安全代理，Sidecar 模式已经成为现代云原生架构不可或缺的组成部分。它不是什么银弹，但当合理使用时，确实能够极大地提升系统的可维护性、可观测性和灵活性。</p>\n<p>所以，需要理解这简单表象背后蕴含的深厚架构智慧。</p>\n<p><em>是的，它就是多跑一个容器，但正是这个“多跑”的容器，让云原生应用架构变得如此强大而优雅。</em></p>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/ydswin/\" target=\"_blank\">dashery</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/ydswin/p/19396769\" target=\"_blank\">https://www.cnblogs.com/ydswin/p/19396769</a></p>\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2025-12-27 19:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ydswin\">dashery</a>&nbsp;\n阅读(<span id=\"post_view_count\">47</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "基于莱布尼茨公式的编程语言计算性能基准测试",
      "link": "https://www.cnblogs.com/shanyou/p/19408361",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19408361\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 19:03\">\n    <span>基于莱布尼茨公式的编程语言计算性能基准测试</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><font face=\"微软雅黑 Light\" size=\"3\">利用莱布尼茨公式（Leibniz formula）计算圆周率 $\\pi$。尽管在现代数学计算库中，莱布尼茨级数因其收敛速度极慢而鲜被用于实际精算 Π 值，但其算法结构——高密度的浮点运算、紧凑的循环逻辑以及对算术逻辑单元（ALU）的持续压力——使其成为测试 CPU 单核吞吐量、浮点运算单元（FPU）效率以及编译器自动向量化（Auto-vectorization）能力的绝佳“试金石” 。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\">GitHub 开源项目 </font><a href=\"https://github.com/niklas-heer/speed-comparison\" rel=\"noopener nofollow\" target=\"_blank\"><font face=\"微软雅黑 Light\" size=\"3\">niklas-heer/speed-comparison</font></a><code></code><font face=\"微软雅黑 Light\" size=\"3\"> 在 2025 年 12 月产生的最新数据，涵盖了从底层系统级语言（如 C++、Rust）到托管型语言（如 Java、C#），再到动态解释型语言（如 Python、Ruby）的 62 种不同实现。通过对 10 亿次迭代运算的详尽分析，我们不仅试图排列出“谁最快”，更致力于揭示“为什么快”背后的深层技术逻辑，探讨单指令多数据（SIMD）技术、即时编译（JIT）机制以及内存模型对计算性能的决定性影响。</font></p><p><font face=\"微软雅黑 Light\" size=\"3\"><img alt=\"Speed comparison chart\" src=\"https://niklas-heer.github.io/speed-comparison/history/2025-12-21T203810/combined_results.png\" /></font></p><p><font face=\"微软雅黑 Light\" size=\"3\">上图来自：</font><a href=\"https://niklas-heer.github.io/speed-comparison/\" rel=\"noopener nofollow\" title=\"https://niklas-heer.github.io/speed-comparison/\"><font face=\"微软雅黑 Light\" size=\"3\">https://niklas-heer.github.io/speed-comparison/</font></a></p><p><font face=\"微软雅黑 Light\" size=\"3\">莱布尼茨公式，作为 arctan(x) 的泰勒级数在 x=1时的特例，其数学表达为：</font></p><p><a href=\"https://img2024.cnblogs.com/blog/510/202512/510-20251227190234460-627552407.png\"></a><a href=\"https://img2024.cnblogs.com/blog/510/202512/510-20251227190235042-730543600.png\"><font face=\"微软雅黑 Light\" size=\"3\"><img alt=\"image\" border=\"0\" height=\"159\" src=\"https://img2024.cnblogs.com/blog/510/202512/510-20251227114212916-1845415606.png\" style=\"display: inline; background-image: none;\" title=\"image\" width=\"833\" /></font></a></p><p><font face=\"微软雅黑 Light\" size=\"3\">从算法实现的角度审视，该公式具有以下显著特征，这些特征直接决定了其作为基准测试的有效性：</font></p><ol><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>极端的计算密集度</b>：算法核心仅包含基本的加、减、乘、除运算，几乎不涉及复杂的内存分配或系统调用（System Calls）。这使得测试结果能够高度纯粹地反映语言运行时的计算开销和指令生成质量 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>可预测的分支逻辑</b>：公式中的符号交替项 (-1)^k 引入了潜在的分支预测（Branch Prediction）挑战。朴素的实现可能会在循环内部使用 <code>if (i % 2 == 0)</code> 判断奇偶性，这将导致大量的 CPU 分支预测失败，从而严重拖慢流水线。而高效的实现通常采用无分支（Branchless）技巧，利用位运算或数学变换来消除条件跳转，这考验了程序员对底层硬件的理解以及编译器的优化智能 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>浮点精度与收敛性</b>：虽然本基准测试明确声明“不关注 pi的精确度”，仅关注运算速度，但浮点数（IEEE 754 标准）的累加特性使得计算顺序对结果有微小影响。编译器是否开启 <code>-ffast-math</code> 等激进优化选项（允许改变浮点结合律）对性能有着数量级的影响，这成为了不同语言实现之间性能差异的主要变量之一 。</font></font></p></li></ol><p><font face=\"微软雅黑 Light\" size=\"3\">基于 2025 年 12 月的最新基准测试数据，我们将 62 种语言实现划分为四个具有显著特征的性能梯队。</font></p><h5><font face=\"微软雅黑 Light\" size=\"3\"> 第一梯队：极限性能层 (&lt; 300ms) —— 编译器的极致</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">这一梯队的语言代表了当前通用 CPU 单核计算的物理极限。它们几乎完全消除了语言本身的运行时开销，性能瓶颈仅在于 CPU 的 ALU 吞吐量和内存带宽。</font></p><p><b><font face=\"微软雅黑 Light\" size=\"3\">深度剖析：</font></b></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>LLVM 的霸权</b>：前 10 名中，C++ (Clang)、Zig、D (LDC)、Rust (Nightly) 均依赖 LLVM 编译器后端。这证明了 LLVM 在现代处理器指令调度和向量化分析上的卓越能力。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>C# 的惊人逆袭</b>：C# (SIMD) 位列第二，仅落后 C++ 不到 4 毫秒。这打破了“托管语言一定慢”的刻板印象。通过.NET 的 <code>System.Numerics.Vectors</code> 库，C# 能够生成与 C++ 几乎相同的 AVX-512 机器码，同时享受 JIT 针对当前硬件动态优化的优势 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>手写 vs 自动</b>：排名第 4 的 C++ (avx2) 是手写 SIMD 代码，却输给了编译器自动优化的 Clang (第 1)。这说明在简单的循环逻辑中，现代编译器对流水线气泡（Pipeline Bubble）和寄存器分配的掌控已经超越了普通人类专家 。</font></font></p></li></ul><h5><font face=\"微软雅黑 Light\" size=\"3\">第二梯队：亚秒级高性能层 (300ms - 1000ms) —— 标量优化的极限</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">这一梯队的语言性能非常出色，通常在 0.5 秒到 1 秒之间。它们大多生成了高效的机器码，但因未开启激进的 SIMD 优化或受到运行时轻微拖累，未能进入第一梯队。</font></p><p><b><font face=\"微软雅黑 Light\" size=\"3\">深度剖析：</font></b></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>Rust 的版本鸿沟</b>：Rust (Stable) 耗时 633ms，而 Nightly 版仅需 234ms。这种巨大的差距源于 Rust 稳定版对 IEEE 754 浮点行为的严格遵守，阻止了编译器进行改变运算顺序的向量化优化。只有在 Nightly 版中显式启用相关特性，才能释放硬件潜力 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>Go 的妥协</b>：Go 语言（888ms）稳定地处于这一梯队。Go 的编译器（gc）设计初衷是编译速度快，而非生成的代码最快。它在自动向量化方面远不如 LLVM 激进，且 Go 运行时包含的调度器和垃圾回收（GC）屏障（Write Barriers）在微观层面引入了额外开销 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>JavaScript 的运行时之战</b>：Bun (928ms) 显著快于 Node.js (1.28s)。Bun 使用的 JavaScriptCore (JSC) 引擎在特定数值计算优化上表现出了相比 Google V8 的优势，证明了现代 JS 引擎的 JIT 能力已能逼近原生代码（仅慢 3-4 倍）。</font></font></p></li></ul><h5><font face=\"微软雅黑 Light\" size=\"3\">第三梯队：解释与混合层 (1s - 5s) —— JIT 的战场</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">这一梯队主要包含动态类型语言的高性能 JIT 实现，或启动开销较大的静态语言环境。</font></p><p><b><font face=\"微软雅黑 Light\" size=\"3\">深度剖析：</font></b></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>PyPy 的惊艳表现</b>：PyPy 将 Python 的运行时间压缩至 1.06 秒，仅比 C# 标准版慢一点。这得益于其 Tracing JIT 技术，能够动态记录循环的执行路径并编译为机器码，消除了动态类型检查的巨大开销 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>NumPy 的陷阱</b>：虽然 NumPy 底层是 C，但在此测试中（2.46s）表现平平。这是因为测试代码使用了 Python 层的 <code>for</code> 循环逐个调用 NumPy 的标量运算。NumPy 的威力在于数组操作（Vectorization），在标量调用场景下，Python 与 C 之间的上下文切换（Function Call Overhead）反而成为了负担。若允许重写为数组操作，NumPy 可能会进入第一梯队，但这违反了“算法一致性”规则 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>Java 的启动与优化</b>：标准 Java (1.70s) 表现中规中矩。HotSpot 编译器虽然强大，但在无法自动向量化浮点循环的情况下，受限于 JVM 的栈操作开销。此外，Java 巨大的启动时间（JVM 初始化、类加载）在短时任务中占比显著。</font></font></p></li></ul><h5><font face=\"微软雅黑 Light\" size=\"3\">第四梯队：纯解释器层 (&gt; 10s) —— 动态类型的代价</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">最慢的梯队，主要是未优化的脚本语言解释器。</font></p><p><b><font face=\"微软雅黑 Light\" size=\"3\">深度剖析：</font></b></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>CPython 的性能瓶颈</b>：标准 Python（CPython）以 86.32 秒垫底，比 C++ 慢了近 400 倍。这归因于其虚拟机架构：每一次加法操作都需要进行对象类型检查（Type Checking）、引用计数更新（Reference Counting）和字节码分发（Dispatch）。对于 10 亿次循环，这些微小的开销累积成了巨大的时间鸿沟 。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>解释器的局限</b>：这一梯队的语言（PHP, Ruby, Perl, Raku）在处理紧凑循环时，CPU 主要忙于解释器自身的逻辑（解析字节码、管理栈），而非执行实际的数学运算。</font></font></p></li></ul><h5><font face=\"微软雅黑 Light\" size=\"3\"> C#：.NET Core 的高性能复兴</font></h5><p><font face=\"微软雅黑 Light\" size=\"3\">在本次测试中，C# (SIMD) 的表现（227ms）是最令人瞩目的亮点之一。这主要归功于.NET Core（现称为.NET 5/6/7+）引入的硬件内建支持（Hardware Intrinsics）。</font></p><ul><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>实现细节</b>：通过引用 <code>System.Runtime.Intrinsics</code> 或使用更高级的 <code>System.Numerics.Vector&lt;T&gt;</code>，C# 开发者可以编写出直接映射到 CPU 向量指令的代码。</font></font></p></li><li><p><font face=\"微软雅黑 Light\"><font size=\"3\"><b>JIT 的优势</b>：与 C++ 的 AOT（提前编译）不同，C# 的 JIT 编译器在程序运行时知道当前 CPU 确切支持哪些指令集（是 AVX2 还是 AVX-512）。这使得 C# 程序可以在旧机器上安全运行，而在新机器上自动全速狂奔，无需像 C++ 那样发布多个二进制版本。基准测试结果证明，这种机制在数值计算领域已经完全成熟 。</font></font></p></li></ul><p><font face=\"微软雅黑 Light\" size=\"3\"><br /></font></p>\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 19:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">53</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FFmpeg开发笔记（九十五）国产的开源视频美颜工具VideoEditorForAndroid",
      "link": "https://www.cnblogs.com/aqi00/p/19319684",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19319684\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 12:00\">\n    <span>FFmpeg开发笔记（九十五）国产的开源视频美颜工具VideoEditorForAndroid</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span><span>​</span></span><span id=\"cke_bm_178S\">《FFmpeg开发实战：从零基础到短视频上线》一书的“第 12 章 &nbsp;FFmpeg的移动开发”介绍了如何使用FFmpeg在手机上剪辑视频，方便开发者更好地开发类似剪映那样的视频剪辑软件。那么在Android系统上还有一款国产的开源视频美颜框架VideoEditor-For-Android，通过该框架可以更方便地给视频添加各种滤镜，下面就来介绍如何在App工程中使用VideoEditor-For-Android。</span>\n<p><span id=\"cke_bm_178S\"> VideoEditor-For-Android是一款基于Android硬编码的视频编辑器，包含视频录制、剪切、增加bgm、美白、加滤镜、加水印等多种功能。该框架通过Android的api完成视频采集，通过OpenGL完成视频数据帧的处理，通过MeidaCodec对采集到的视频流进行硬编码。它利用OpenGL完成视频的美白、加滤镜、加水印等功能，利用MediaCodec完成音视频的分离和音频的一些混音处理。<br />\nVideoEditor-For-Android的源码托管地址为https://github.com/qqchenjian318/VideoEditor-For-Android（星星数1.3k），最近版本更新于2021年9月，该版本的压缩包下载地址为https://github.com/qqchenjian318/VideoEditor-For-Android/archive/refs/heads/master.zip。<br />\n由于VideoEditor-For-Android源码的发布时间较早，为了让小海豚版本的Android Studio Dolphin能够打开它们，需要对App工程作如下修改：<br />\n1、升级Gradle版本和SDK版本；<br />\n2、把使用的jdk版本从默认的JDK8改为JDK11；<br />\n3、把Support库迁移为Androidx库；<br />\n4、build.gradle给NDK的指令集过滤器增加arm64-v8a；<br />\n5、App代码在录像和操作存储空间时增加运行时授权校验；<br />\n6、另外修复了若干bug；<br />\n因为上述修改涉及到的内容较多，这里不再一一列出，博主把修改后的App源码上传到了Github，具体地址为https://github.com/aqi00/note/tree/master/VideoEditor-For-Android。大家可以拉取Github上修改好的VideoEditor-For-Android源码，就能用小海豚版本的Android Studio Dolphin导入带Demo界面的VideoEditor-For-Android工程了。<br />\n那么通过Android Studio Dolphin编译VideoEditor-For-Android并安装到真机上，点击【本地视频美颜】后进入视频文件的挑选页面如下图所示：</span></p>\n<div>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"vefa2\" class=\"lazyload\" height=\"407\" width=\"345\" /></span></span></span></span></p>\n\n\n</div>\n<p>先到相册选择一个待加工的视频文件，再点击弹窗右下角的【加滤镜】按钮，App就转到视频的预览界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"vefa3\" class=\"lazyload\" height=\"681\" width=\"317\" /></span></span></span></span></p>\n<p>在视频预览界面左右滑动，可以切换不同的美颜效果，如下图所示：<span class=\"cke_image_resizer_wrapper\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"vefa4\" class=\"lazyload\" height=\"680\" width=\"317\" /></span></span></span></div>\n<p>点击界面右下角的打勾按钮，App就开始执行对应的美颜加工操作。美颜之后的视频片段默认放在App安装路径下的files目录，完整路径为“我的手机/Android/data/com.example.cj.videoeditor/files/video/clip/123456789.mp4”，其中123456789代表一串数字。使用手机自带的文件管理App找到新保存的视频片段，即可观看美颜后的视频效果。</p>\n<p>更多详细的FFmpeg开发知识参见<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\"><a class=\"cke_widget_editable cke_widget_element\" href=\"https://item.jd.com/14020415.html\" rel=\"noopener nofollow\" title=\"《FFmpeg开发实战：从零基础到短视频上线》\">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</span></p>\n\n<span>\n<span>​</span></span>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 12:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">125</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "使用Gradio构建AI前端 - RAG的QA模块",
      "link": "https://www.cnblogs.com/aspnetx/p/19408276",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aspnetx/p/19408276\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 11:28\">\n    <span>使用Gradio构建AI前端 - RAG的QA模块</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文将基于Gradio的Interface，继续构建RAG系统的QA前端页面，对比上一篇对召回测试前端页面的构建，来对比在Gradio下，Blocks和Interface的两种区别。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"使用gradio构建ai前端---rag的qa模块\">使用Gradio构建AI前端 - RAG的QA模块</h1>\n<h2 id=\"摘要\">摘要</h2>\n<p>本文将基于Gradio的Interface，继续构建RAG系统的QA前端页面，对比上一篇对召回测试前端页面的构建，来对比在Gradio下，Blocks和Interface的两种区别。</p>\n<h2 id=\"gradio-interface简介\">Gradio Interface简介</h2>\n<p>Gradio 是一个用于快速创建机器学习和数据科学演示界面的Python库，允许开发者通过简单代码将函数转换为交互式Web应用，无需前端开发经验。<code>gr.Interface</code> 是 Gradio 提供的一种快速创建界面的方式，适用于简单的输入输出场景，采用\"函数驱动\"模式，直接将函数与输入输出组件绑定。</p>\n<h3 id=\"核心特点\">核心特点：</h3>\n<ul>\n<li>结构简单，适合快速原型开发</li>\n<li>输入输出组件按固定布局排列</li>\n<li>基于函数映射，直接将输入传递给函数并展示输出</li>\n</ul>\n<p>综上汇总，主要的特点就是简单，快。</p>\n<h3 id=\"interface-与-blocks-的区别\">Interface 与 Blocks 的区别</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Interface</th>\n<th>Blocks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>复杂度</td>\n<td>简单，适合快速搭建</td>\n<td>灵活，适合复杂界面</td>\n</tr>\n<tr>\n<td>布局控制</td>\n<td>自动布局，结构固定</td>\n<td>完全自定义布局</td>\n</tr>\n<tr>\n<td>交互逻辑</td>\n<td>基于单一函数映射</td>\n<td>支持多函数、事件触发</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>简单输入输出场景</td>\n<td>复杂交互、多步骤流程</td>\n</tr>\n</tbody>\n</table>\n<p>相对来说，Interface的构建方式比Blocks要更简单，代码量更少。<br />\n通过下面的代码，可以看到跟Blocks有明显的区别。</p>\n<h3 id=\"代码示例\">代码示例：</h3>\n<pre><code class=\"language-python\"># 创建Gradio Interface\niface = gr.Interface(\n    fn=run_qa,  # 核心处理函数\n    inputs=[    # 输入组件列表\n        gr.Textbox(\n            label=\"问题\",\n            placeholder=\"请输入您的问题...\",\n            lines=3,\n            info=\"例如: '哪些节假日应该安排休假？' 或 '什么是未成年？'\"\n        ),\n        gr.Slider(\n            label=\"Top-K检索数量\",\n            minimum=1,\n            maximum=10,\n            value=5,\n            step=1,\n            info=\"设置返回的最相似文档数量\"\n        )\n    ],\n    outputs=gr.Markdown(  # 输出组件\n        label=\"回答结果\"\n    ),\n    title=\"🤖 RAG问答系统\",\n    description=\"基于LangChain和Gradio构建的RAG问答系统，使用向量数据库进行知识检索\",\n    examples=[  # 示例问题\n        [\"哪些节假日应该安排休假？\", 5],\n        [\"什么是未成年？\", 3],\n        [\"足球比赛的基本规则是什么？\", 4]\n    ],\n    theme=gr.themes.Soft(),\n    allow_flagging=\"never\"  # 禁用标记功能\n)\n</code></pre>\n<p>下面是构建界面的样子：<br />\n<img alt=\"img\" src=\"https://img2024.cnblogs.com/blog/8622/202512/8622-20251227112605131-876188573.png\" /></p>\n<p>通过以上代码，可以看到在gr.Interface里，首先指定捆绑的是哪一个function，然后在inputs和outputs，依次创建对应的前端组件，并且对应function里的输入参数和返回值。<br />\n这段代码调用项目里已经封装好的LC_RAG_03_QA.py里的方法。</p>\n<h3 id=\"关键区别点\">关键区别点：</h3>\n<p>对比上一篇，这里汇总了Interface方式和Blocks两种方式的区别。</p>\n<ol>\n<li>\n<p><strong>布局控制</strong>：</p>\n<ul>\n<li>Interface：自动排列输入输出，无需手动控制布局</li>\n<li>Blocks：通过 <code>gr.Row()</code>、<code>gr.Column()</code> 等手动控制组件布局</li>\n</ul>\n</li>\n<li>\n<p><strong>事件处理</strong>：</p>\n<ul>\n<li>Interface：自动关联输入输出和处理函数</li>\n<li>Blocks：需要显式通过 <code>.click()</code> 等方法绑定事件</li>\n</ul>\n</li>\n<li>\n<p><strong>灵活性</strong>：</p>\n<ul>\n<li>Interface：适合简单场景，代码量少</li>\n<li>Blocks：适合复杂界面，支持条件显示、多步骤交互等高级功能</li>\n</ul>\n</li>\n<li>\n<p><strong>结构组织</strong>：</p>\n<ul>\n<li>Interface：通过参数配置界面元素</li>\n<li>Blocks：使用上下文管理器（<code>with</code> 语句）组织界面结构</li>\n</ul>\n</li>\n</ol>\n<p>在本案例中，使用 <code>gr.Interface</code> 代码更简洁高效。如果需要更复杂的交互（如多步骤处理、条件显示组件等），则应选择 <code>gr.Blocks</code>。<br />\n所以如果是对模型功能的评估，建议选择gr.Interface，如果是做原型设计，建议选择gr.Blocks。</p>\n<p>本文项目代码可以在以下仓库里找到：<br />\n<a href=\"https://github.com/microsoftbi/Langchain_DEMO/tree/main/RAG\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microsoftbi/Langchain_DEMO/tree/main/RAG</a><br />\n此篇对应的代码是：LC_RAG_07c_Gradio.py</p>\n<p>这里再补充一个快速的方法，就是借助AI开发工具，比如TRAE，以下是我用的提示词，仅供参考：</p>\n<pre><code class=\"language-Prompt\">在当前python文件中，编写一个QA的前端界面，前端框架使用Gradio，不要使用blocks的方式构建页面，直接使用interface的方式来构建，使用的方法，调用LC_RAG_03_QA.py里的answer_question方法。\n</code></pre>\n<p>虽然在我使用的过程中，代码无法一次通过，但基本上通过一次反馈就可以修补成功，从而省下了这部分代码的工作量。</p>\n<details>\n以下是代码的全部内容，点击展开。\n<pre><code class=\"language-Python\">import gradio as gr\nfrom LC_RAG_03_QA import answer_question\n\ndef run_qa(question, top_k=5):\n    \"\"\"运行QA并返回结果\"\"\"\n    try:\n        answer, sources = answer_question(\n            question=question,\n            top_k=top_k,\n            vectorstore_dir=\"./RAG/chroma_db\",\n            embedding_model=\"text-embedding-v4\"\n        )\n        \n        # 格式化结果\n        result = f\"# 🎯 答案\\n\\n{answer}\\n\"\n        \n        if sources:\n            result += \"\\n# 📚 参考来源\\n\"\n            for source in sources:\n                result += f\"- {source}\\n\"\n        \n        return result\n    except Exception as e:\n        return f\"❌ 错误: {str(e)}\"\n\n# 创建Gradio Interface\niface = gr.Interface(\n    fn=run_qa,\n    inputs=[\n        gr.Textbox(\n            label=\"问题\",\n            placeholder=\"请输入您的问题...\",\n            lines=3,\n            info=\"例如: '哪些节假日应该安排休假？' 或 '什么是未成年？'\"\n        ),\n        gr.Slider(\n            label=\"Top-K检索数量\",\n            minimum=1,\n            maximum=10,\n            value=5,\n            step=1,\n            info=\"设置返回的最相似文档数量\"\n        )\n    ],\n    outputs=gr.Markdown(\n        label=\"回答结果\"\n    ),\n    title=\"🤖 RAG问答系统\",\n    description=\"基于LangChain和Gradio构建的RAG问答系统，使用向量数据库进行知识检索\",\n    examples=[\n        [\"哪些节假日应该安排休假？\", 5],\n        [\"什么是未成年？\", 3],\n        [\"足球比赛的基本规则是什么？\", 4]\n    ],\n    theme=gr.themes.Soft(),\n    allow_flagging=\"never\"\n)\n\n# 启动应用\nif __name__ == \"__main__\":\n    iface.launch(\n        server_name=\"0.0.0.0\",\n        server_port=7861,\n        share=False,\n        debug=False\n    )\n</code></pre>\n</details>\n</div>\n<div id=\"MySignature\">\n    <p>&nbsp;</p>\n<p>---------------------------------------------------------------</p>\n<p style=\"margin: 0in 0in 10pt;\">aspnetx<span style=\"font-family: SimSun;\">的</span>BI<span style=\"font-family: SimSun;\">笔记系列索引：</span></p>\n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/02/25/2931603.html\" target=\"_blank\">使用SQL Server Analysis Services数据挖掘的关联规则实现商品推荐功能</a></p> \n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/03/24/2978347.html\" target=\"_blank\">一起玩转SQL Server 2012 下的分析服务</a></p> \n<p style=\"margin: 0in 0in 10pt;\"><a href=\"http://www.cnblogs.com/aspnetx/archive/2013/04/05/3000448.html\" target=\"_blank\">使用SQL Server分析服务定位目标用户  </a></p> \n\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>---------------------------------------------------------------<br /></p>\n<p>来自<a href=\"http://www.cnblogs.com/\" target=\"_blank\">博客园</a>的<a href=\"http://aspnetx.cnblogs.com/\" target=\"_blank\">aspnetx</a><font color=\"white\">宋卫东</font></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 11:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aspnetx\">哥本哈士奇(aspnetx)</a>&nbsp;\n阅读(<span id=\"post_view_count\">59</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19406862",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19406862\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 23:11\">\n    <span>一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>在AI技术迅猛发展的当下，高效且精准的提示词成为与AI模型有效交互的关键。今天大姚给大家分享一款由字节跳动推出的 AI 提示词生成和优化工具，为你提供更精准，专业，可持续迭代提示词！</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230859325-1349637768.png\" /></p>\n<h2><span>工具介绍</span></h2>\n<p><span>PromptPilot 是由字节跳动推出的一款专注于 AI 提示词优化与提示词生成的实用工具。该工具旨在帮助用户更高效地生成和优化 AI 提示词，提升与 AI 模型的交互效率和质量。通过 PromptPilot，用户可以轻松地创建、调试和管理提示词，以满足多样化的应用场景需求。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong><span>在线访问地址：<span class=\"wx_text_underline\">https://promptpilot.volcengine.com</span></span></strong></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230911909-2106687661.png\" /></p>\n<h2><span>应用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>内容创作</strong><span>：在自媒体、广告、营销等领域，PromptPilot 可帮助创作者快速生成吸引人的文案提示词，提升内容质量和吸引力。</span></li>\n<li><strong>数据分析</strong><span>：在数据分析场景中，PromptPilot 可辅助分析师生成精准的查询提示词，提高数据检索和分析效率。</span></li>\n<li><strong>客户服务</strong><span>：在客户服务领域，PromptPilot 可用于生成自动化回复的提示词，提升客户响应速度和满意度。</span></li>\n<li><strong>教育行业</strong><span>：教师和学生可利用 PromptPilot 生成教学和学习相关的提示词，促进知识的有效传递和学习效果的提升。</span></li>\n</ul>\n<h2><span>提示词生成</span></h2>\n<h3><span>任务描述：</span></h3>\n<pre><span><code><span>给我写一个企业优秀员工获奖感言。<br /></span></code></span></pre>\n<h3><span>生成后的 Prompt：</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230930602-605100114.png\" /></p>\n<p>&nbsp;</p>\n<pre><span><code># 获奖感言创作指南<br /><br />## 一、身份设定<br /><span>你是企业行政部门的资深文案专员，负责为获奖员工撰写符合公司文化的正式获奖感言。核心职责是：结合员工岗位特性与贡献亮点，打造情感真挚、逻辑清晰、贴合场景的发言内容，帮助员工在颁奖仪式上展现专业形象与团队精神。<br /><br />## 二、创作准则<br />### 必做事项<br /><span>1. 必须包含获奖员工姓名、所获奖项全称、公司名称<br /><span>2. 必须突出员工岗位核心职责与关键贡献数据<br /><span>3. 必须体现对公司、团队、家人的感谢层次<br /><span>4. 必须包含对未来工作的承诺与展望<br /><br />### 约束条件<br /><span>1. 禁止使用夸张不实的表述，所有贡献需基于提供的事实<br /><span>2. 禁止出现敏感词汇或不当表述<br /><span>3. 禁止遗漏指定的感谢对象<br /><span>4. 禁止超过规定字数限制<br /><br />## 三、变量说明<br /><span>&lt;员工姓名&gt;{{EMPLOYEE_NAME}}&lt;/员工姓名&gt; - 获奖员工的完整姓名<br /><span>&lt;奖项类型&gt;{{AWARD_TYPE}}&lt;/奖项类型&gt; - 具体获奖名称（如：年度优秀员工、季度创新之星）<br /><span>&lt;公司名称&gt;{{COMPANY_NAME}}&lt;/公司名称&gt; - 员工所在企业全称<br /><span>&lt;工作职责&gt;{{WORK_DUTIES}}&lt;/工作职责&gt; - 员工日常工作内容概述<br /><span>&lt;核心贡献&gt;{{KEY_CONTRIBUTIONS}}&lt;/核心贡献&gt; - 员工获奖的关键业绩或突出表现<br /><span>&lt;感谢对象&gt;{{THANKS_OBJECTS}}&lt;/感谢对象&gt; - 需要特别致谢的个人或团队<br /><br />## 四、创作流程<br />### 第一步：内容架构搭建<br /><span>1. 开场问候：礼貌性称呼在场人员<br /><span>2. 获奖致谢：表达获奖的荣幸与激动心情<br /><span>3. 工作回顾：简述岗位价值与核心贡献<br /><span>4. 感恩环节：分层次感谢公司、团队、家人<br /><span>5. 未来展望：承诺未来工作方向与目标<br /><br />### 第二步：细节填充<br /><span>1. 将 &lt;员工姓名&gt;{{EMPLOYEE_NAME}}&lt;/员工姓名&gt; 自然融入开场与落款<br /><span>2. 准确引用 &lt;奖项类型&gt;{{AWARD_TYPE}}&lt;/奖项类型&gt; 全称<br /><span>3. 结合 &lt;工作职责&gt;{{WORK_DUTIES}}&lt;/工作职责&gt; 说明岗位价值<br /><span>4. 用数据化语言呈现 &lt;核心贡献&gt;{{KEY_CONTRIBUTIONS}}&lt;/核心贡献&gt;<br /><span>5. 按重要性排序提及 &lt;感谢对象&gt;{{THANKS_OBJECTS}}&lt;/感谢对象&gt;<br /><br />### 第三步：风格润色<br /><span>1. 语言风格：正式中带有温度，避免过于口语化<br /><span>2. 情感表达：控制情绪尺度，保持专业得体<br /><span>3. 时间控制：按3分钟发言长度调整内容详略（约500-600字）<br /><br />## 五、输出规范<br />### 内容结构<br /><span>1. 标题：[奖项名称]获奖感言<br /><span>2. 称呼：尊敬的各位领导、亲爱的同事们：<br /><span>3. 正文：按创作流程顺序展开<br /><span>4. 落款：[员工姓名] [日期]<br /><br />### 格式要求<br /><span>1. 使用标准宋体四号字，1.5倍行距<br /><span>2. 关键贡献部分加粗显示<br /><span>3. 感谢对象单独分段<br /><span>4. 结尾部分需包含对公司未来的美好祝愿<br /><br />### 质量标准<br /><span>1. 符合公司文化价值观<br /><span>2. 突出个人贡献同时体现团队精神<br /><span>3. 避免空话套话，用具体事例支撑<br /><span>4. 语言流畅，逻辑清晰，情感真挚<br /><br />## 六、创作示例<br /><span>（此处省略示例内容，实际创作时需根据变量填充）<br /><br /><span>请严格按照以上要求，结合提供的变量信息，创作一篇完整的获奖感言。<br /><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>\n<h2><span>调试 Prompt</span></h2>\n<h3><span>文本理解</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226230958750-1911894887.png\" /></p>\n<h3><span>视觉理解</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231016417-194421412.png\" /></p>\n<h3><span>多轮对话</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231026956-1766318256.png\" /></p>\n<h2><span>优化 Prompt</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231045050-1953776592.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251226231052086-1099494036.png\" /></p>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 23:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">188</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "go-zero rest 源码学习笔记",
      "link": "https://www.cnblogs.com/xingzheanan/p/19404672",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xingzheanan/p/19404672\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 22:19\">\n    <span>go-zero rest 源码学习笔记</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<hr />\n<h1 id=\"概述\">概述</h1>\n<p><code>go-zero</code> 基于 <code>net/http</code> 标准库实现了一套 <code>rest</code> web 框架。在使用 <code>goctl</code> 快速开发的同时，也需要了解 <code>go-zero</code> 内部做了什么。本文结合 <a href=\"https://zeromicro.github.io/go-zero.dev/docs/component/rest\" rel=\"noopener nofollow\" target=\"_blank\">go-zero rest</a>学习其中的源码，力图做到知其所以然。</p>\n<h1 id=\"源码\">源码</h1>\n<h2 id=\"流程图\">流程图</h2>\n<p><img alt=\"image\" class=\"lazyload\" height=\"650\" width=\"640\" /></p>\n<p>在阅读源码之前，先看下流程图有个印象。从流程图大致可以看出来：</p>\n<ul>\n<li>go-zero 会创建路由组，其中按顺序注册了几类 handler（中间件），最后在 business handler 处理业务逻辑。</li>\n</ul>\n<p>大致有个印象后开始源码走读。</p>\n<h2 id=\"源码走读\">源码走读</h2>\n<p>启动 api 服务：</p>\n<pre><code class=\"language-go\">func main() {  \n    ...\n    server := rest.MustNewServer(c.RestConf)  \n    defer server.Stop()  \n  \n    ctx := svc.NewServiceContext(c)  \n    handler.RegisterHandlers(server, ctx)  \n  \n    fmt.Printf(\"Starting server at %s:%d...\\n\", c.Host, c.Port)  \n    server.Start()  \n}\n</code></pre>\n<p>启动服务主要做了三件事：</p>\n<ul>\n<li>创建服务端 server</li>\n<li>注册 handler 到 server</li>\n<li>启动服务端 server</li>\n</ul>\n<p>按顺序介绍。</p>\n<h3 id=\"创建服务端-server\">创建服务端 server</h3>\n<pre><code class=\"language-go\">func MustNewServer(c RestConf, opts ...RunOption) *Server {  \n    // NewServer 创建 server\n    server, err := NewServer(c, opts...)  \n    if err != nil {  \n       logx.Must(err)  \n    }  \n  \n    return server  \n}\n\nfunc NewServer(c RestConf, opts ...RunOption) (*Server, error) {\n\t// c.SetUp 启动 Prometheus，tracing, profiling 等服务\n    if err := c.SetUp(); err != nil {  \n       return nil, err  \n    }  \n  \n    server := &amp;Server{  \n       ngin:   newEngine(c),  \n       router: router.NewRouter(),  \n    }  \n  \n    ...\n    return server, nil  \n}\n</code></pre>\n<p>创建 server 实际创建的是 server 的 engine 和 router。</p>\n<p>engine 主要结构如下：</p>\n<pre><code class=\"language-go\">type engine struct {  \n    // server 的配置\n    conf   RestConf  \n    routes []featuredRoutes  // 业务路由\n    // 调用链\n    chain                chain.Chain \n    // 中间件 \n    middlewares          []Middleware  \n    ...\n}\n\nfunc newEngine(c RestConf) *engine {  \n    svr := &amp;engine{  \n       conf:    c,  \n       timeout: time.Duration(c.Timeout) * time.Millisecond,  \n    }\n    ...\n}\n</code></pre>\n<p>router 结构如下：</p>\n<pre><code class=\"language-go\">func NewRouter() httpx.Router {  \n    return &amp;patRouter{  \n       trees: make(map[string]*search.Tree),  \n    }  \n}\n\ntype Router interface {  \n    http.Handler  \n    Handle(method, path string, handler http.Handler) error  \n    SetNotFoundHandler(handler http.Handler)  \n    SetNotAllowedHandler(handler http.Handler)  \n}\n</code></pre>\n<p><code>patRouter</code> 包含路由信息，其实现了 <code>Router</code> 接口。</p>\n<p>创建了 server 后还需要注册路由 handler 到 server，这样服务端才能根据路由找到对应的 handler 处理。</p>\n<h3 id=\"注册路由-handler\">注册路由 handler</h3>\n<pre><code class=\"language-go\">func RegisterHandlers(server *rest.Server, serverCtx *svc.ServiceContext) {  \n    // server.AddRoutes 注册路由 handler\n    server.AddRoutes(  \n       []rest.Route{  \n          {  \n             Method:  http.MethodGet,  \n             Path:    \"/ping\",  \n             Handler: pingHandler(serverCtx),  \n          },  \n       },  \n    )\n}\n\nfunc (s *Server) AddRoutes(rs []Route, opts ...RouteOption) {  \n    // 自定义的业务路由将被封装到 featuredRoutes 对象\n    r := featuredRoutes{  \n       routes: rs,  \n    }  \n    for _, opt := range opts {  \n       opt(&amp;r)  \n    }  \n    \n    // 将 featuredRoutes 添加到 Server.engine\n    s.ngin.addRoutes(r)  \n}\n\nfunc (ng *engine) addRoutes(r featuredRoutes) {  \n    ...\n    // 实际是将路由组添加到 engine.routes 中  \n    ng.routes = append(ng.routes, r) \n}\n</code></pre>\n<p>业务路由注册完，接下来将进入启动 server，这是需要关注的重点。</p>\n<h3 id=\"启动-server\">启动 server</h3>\n<pre><code class=\"language-go\">func (s *Server) Start() {  \n    // 调用 Server.engine.start 启动服务端 server\n    handleError(s.ngin.start(s.router))  \n}\n\nfunc (ng *engine) start(router httpx.Router, opts ...StartOption) error {     // engine.bindRoutes 绑定路由到 router\n    if err := ng.bindRoutes(router); err != nil {  \n       return err  \n    }  \n\n    ...\n    return internal.StartHttps(ng.conf.Host, ng.conf.Port, ng.conf.CertFile,  \n       ng.conf.KeyFile, router, opts...)  \n}\n\nfunc (ng *engine) bindRoutes(router httpx.Router) error {  \n    // engine.routes \n    for _, fr := range ng.routes {  \n       // 绑定 rest.featuredRoutes \n       if err := ng.bindFeaturedRoutes(router, fr, metrics); err != nil { \n          return err  \n       }  \n    }  \n  \n    return nil  \n}\n\nfunc (ng *engine) bindFeaturedRoutes(router httpx.Router, fr featuredRoutes, metrics *stat.Metrics) error {  \n    ...\n    for _, route := range fr.routes {  \n       if err := ng.bindRoute(fr, router, metrics, route, verifier); err != nil {  \n          return err  \n       }  \n    }  \n  \n    return nil  \n}\n\nfunc (ng *engine) bindRoute(fr featuredRoutes, router httpx.Router, metrics *stat.Metrics,  \n    route Route, verifier func(chain.Chain) chain.Chain) error {  \n    // engine.chain，初始化为 nil\n    chn := ng.chain  \n    if chn == nil {  \n       // engine.buildChainWithNativeMiddlewares 注册自带中间件到 engine.chain\n       chn = ng.buildChainWithNativeMiddlewares(fr, route, metrics)  \n    }  \n  \n    // 添加 AuthHandler 到 engine.chain 中\n    chn = ng.appendAuthHandler(fr, chn, verifier)  \n  \n    // 将自定义中间件注册到 engine.chain\n    for _, middleware := range ng.middlewares {  \n       chn = chn.Append(convertMiddleware(middleware))  \n    }  \n    \n    // engine.chain.ThenFunc 将 handler 串联成 handler\n    handle := chn.ThenFunc(route.Handler)  \n  \n    return router.Handle(route.Method, route.Path, handle)  \n}\n</code></pre>\n<p>启动 server 的重点在 <code>engine.bindRoute</code>。<br />\n其中，<code>engine.buildChainWithNativeMiddlewares</code> 注册 <code>go-zero</code> 自带中间件：</p>\n<pre><code class=\"language-go\">func (ng *engine) buildChainWithNativeMiddlewares(fr featuredRoutes, route Route,  \n    metrics *stat.Metrics) chain.Chain {  \n    chn := chain.New()\n    ...\n    // MaxConns 用于并发控制\n    if ng.conf.Middlewares.MaxConns {  \n        chn = chn.Append(handler.MaxConnsHandler(ng.conf.MaxConns))  \n    }  \n    if ng.conf.Middlewares.Breaker {  \n        chn = chn.Append(handler.BreakerHandler(route.Method, route.Path, metrics))  \n    }\n    ...\n}\n</code></pre>\n<p>类似的，自定义中间件通过 <code>chn.Append(convertMiddleware(middleware))</code> 注册到 <code>engine.chain</code> 中。</p>\n<p>接着调用 <code>chain.ThenFunc</code> 串联中间件成 <code>handler</code>：</p>\n<pre><code class=\"language-go\">func (c chain) ThenFunc(fn http.HandlerFunc) http.Handler {  \n    ...\n    return c.Then(fn)  \n}\n\nfunc (c chain) Then(h http.Handler) http.Handler {  \n    if h == nil {  \n       h = http.DefaultServeMux  \n    }  \n  \n    // 这段代码很有意思，它将所有中间件按顺序串联起来组成一个 handler\n    // 调用这个 handler 处理时会经过后续一系列的中间件，最终到业务 handler 处理\n    // 具体可参考 https://github.com/zeromicro/go-zero/blob/master/rest/chain/chain.go#L81\n    for i := range c.middlewares {  \n       h = c.middlewares[len(c.middlewares)-1-i](h)  \n    }  \n  \n    return h  \n}\n</code></pre>\n<p>最后将该 handler 和路由信息注册到 <code>router</code> 中，后续服务端根据请求在 <code>router</code> 中查找对应的 <code>handler</code> 处理。</p>\n<pre><code class=\"language-go\">func (pr *patRouter) Handle(method, reqPath string, handler http.Handler) error {  \n    ...\n    \n    tree, ok := pr.trees[method]  \n    if ok {  \n       return tree.Add(cleanPath, handler)  \n    }  \n  \n    tree = search.NewTree()  \n    pr.trees[method] = tree  \n    return tree.Add(cleanPath, handler)  \n}\n</code></pre>\n<p>详细流程如下图：</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"570\" width=\"661\" /></p>\n<h1 id=\"小结\">小结</h1>\n<p>本文介绍了 go-zero rest 的源码是怎么处理请求的。从源码也可以看出每个请求背后是一系列中间件 handler 在处理，并且 server 启动了 Prometheus，Trace 等服务负责监控，链路追踪等，使得开发微服务时只需要关注业务逻辑即可，非常方便。</p>\n<h1 id=\"参考资料\">参考资料</h1>\n<ul>\n<li><a href=\"https://zeromicro.github.io/go-zero.dev/docs/component/rest\" rel=\"noopener nofollow\" target=\"_blank\">go-zero rest</a></li>\n<li><a href=\"https://refactoringguru.cn/design-patterns/chain-of-responsibility/go/example\" rel=\"noopener nofollow\" target=\"_blank\">Go 责任链模式</a></li>\n</ul>\n<hr />\n\n</div>\n<div id=\"MySignature\">\n    芝兰生于空谷，不以无人而不芳。\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 22:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xingzheanan\">胡云Troy</a>&nbsp;\n阅读(<span id=\"post_view_count\">68</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "红米AX6 扩容 刷Uboot+openwrt 经历",
      "link": "https://www.cnblogs.com/sollong/p/19410157",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sollong/p/19410157\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 22:04\">\n    <span>红米AX6 扩容 刷Uboot+openwrt 经历</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>仅仅做一次刷入的简单记录，可抄作业</strong></p>\n<h2 id=\"参考文章视频\">参考文章/视频：</h2>\n<p>1.视频-红米AX6 Openwrt刷机教程（解锁步骤AX6000、AX9000通用）<a href=\"https://www.bilibili.com/video/BV1q94y1f7fj\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV1q94y1f7fj</a></p>\n<p>2.视频-玩透红米AX6 OPENWRT扩容刷机及Uboot刷机 <a href=\"https://www.bilibili.com/video/BV19Y4y1e7ko\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV19Y4y1e7ko</a></p>\n<p>3.文章-[红米AX6] 2025年入手AX6后刷机笔记 <a href=\"https://www.right.com.cn/forum/thread-8455880-1-1.html\" rel=\"noopener nofollow\" target=\"_blank\">https://www.right.com.cn/forum/thread-8455880-1-1.html</a></p>\n<p>4.文章-[红米AX6] 【2025-06-28】红米AX6开源NSS固件 <a href=\"https://www.right.com.cn/forum/thread-8417590-1-2.html\" rel=\"noopener nofollow\" target=\"_blank\">https://www.right.com.cn/forum/thread-8417590-1-2.html</a></p>\n<p>5.文章-小米/红米ax路由器全系万能一键ssh工具(支持ax6, ax6s, ax5jdc, ax3000, CR880X) <a href=\"https://www.right.com.cn/forum/thread-8374973-1-1.html\" rel=\"noopener nofollow\" target=\"_blank\">https://www.right.com.cn/forum/thread-8374973-1-1.html</a></p>\n<h2 id=\"整体思路\">整体思路</h2>\n<p>1.解锁SSH 2.改分区表 3.刷uboot 4.刷openwrt</p>\n<h2 id=\"步骤1-解锁ssh\">步骤1 解锁SSH</h2>\n<p>参考 参考文章5 可一键解锁SSH 或者 参考 参考视频1 的方式进行解锁<br />\n推荐前一种方法，很方便</p>\n<h2 id=\"步骤2-改分区表刷uboot\">步骤2 改分区表+刷uboot</h2>\n<p>教程参考的 参考视频2 刷uboot章节<br />\n分区文件与uboot映像使用的 参考文章4中帖子附件<br />\n[红米AX6大分区 天灵UBOOT.zip]:<br />\n-ax6-uboot-stock.bin //uboot映像<br />\n-ax6-mibib-stock.bin //扩容分区表</p>\n<h2 id=\"步骤3-刷openwrtimmortalwrt\">步骤3 刷openwrt/immortalwrt</h2>\n<p>教程参考 参考视频2, 参考文章3<br />\n可以选择自己想要的openwrt或者immortalwrt映像<br />\n这里选择的是参考文章4中的固件 immortalwrt-qualcommax-ipq807x-redmi_ax6-stock-squashfs-factory.ubi</p>\n<p>文章有待完善，随缘更新</p>\n<p><strong>最后感谢各路大佬开发/编译/整理</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 22:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sollong\">Sollong</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "StruSP——Structure-aware Propagation Generation with Large Language Models for Fake News Detection",
      "link": "https://www.cnblogs.com/xyc-blog/p/19409070",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xyc-blog/p/19409070\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 21:24\">\n    <span>StruSP——Structure-aware Propagation Generation with Large Language Models for Fake News Detection</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1 id=\"tid-b7Ebcd\"><span style=\"font-size: 14px;\">论文信息</span></h1>\n<blockquote>\n<p><span style=\"font-size: 14px;\">论文标题：Structure-aware Propagation Generation with Large Language Models for Fake News Detection</span><br /><span style=\"font-size: 14px;\">论文翻译：基于大型语言模型的结构感知传播生成用于虚假新闻检</span><br /><span style=\"font-size: 14px;\">论文作者：陈梦阳、魏灵伟、周伟、胡松林</span><br /><span style=\"font-size: 14px;\">论文来源：EMNLP 2025</span><br /><span style=\"font-size: 14px;\">发布时间：2025</span><br /><span style=\"font-size: 14px;\">论文地址：</span><br /><span style=\"font-size: 14px;\">论文代码：<a href=\"https://github.com/IMCMY99/StruSP\" rel=\"noopener nofollow\">https://github.com/ICTMCG/GenFEND</a></span></p>\n<p><span style=\"font-size: 14px;\"><strong>总结</strong>：</span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><strong>研究背景</strong>：社交媒体虚假新闻传播威胁公众信任与社会稳定，现有基于传播的检测方法受限于传播数据不完整，而利用大型语言模型（LLMs）生成合成传播数据的最新研究，又常忽略现实讨论中的结构模式。</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>核心方案</strong>：提出结构感知合成传播增强检测（StruSP）框架，可充分捕捉真实传播的结构动态，让 LLMs 生成真实且结构一致的传播数据，从语义和结构两维度将合成传播与现实传播明确对齐。</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>关键策略</strong>：设计双向进化传播（BEP）学习策略，通过结构感知混合采样和掩码传播建模目标，使 LLMs 更好地与现实传播的结构模式对齐。</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>实验结果</strong>：在三个公开数据集上的实验表明，StruSP 在多种实际检测场景中显著提升虚假新闻检测性能；进一步分析显示，BEP 能让 LLMs 在语义和结构上生成更真实、更多样化的传播数据。</span></p>\n</li>\n</ol>\n</blockquote>\n<hr />\n<h1 class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\">1 研究动机&amp;&amp;研究背景</span></h1>\n<ol>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>研究问题1</strong>：基于传播的虚假新闻检测方法在传播数据不完整时性能显著下降，如何缓解该问题？</span></p>\n<span style=\"font-size: 14px;\"><strong>研究背景</strong>：现有虚假新闻检测的传播类方法，通过建模新闻与评论的时间序列、传播树 / 传播图等拓扑结构捕捉传播模式，但受限于社交媒体数据收集的局限性及恶意用户互动等因素，实际场景中常面临传播数据不完整的问题，导致这类方法检测效果大幅受损。</span></li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>研究问题2</strong>：现有基于大语言模型（LLM）生成合成传播的方法，因忽略真实传播的结构模式，生成内容与真实传播存在语义 - 结构不匹配，如何提升合成传播的真实性与结构一致性？</span></p>\n<span style=\"font-size: 14px;\"><strong>研究背景</strong>：近年 LLM 被用于通过角色扮演生成合成传播以缓解数据稀缺，但这类方法仅关注语义层面，生成的传播树存在结构过于均匀、缺乏真实传播的不规则分支与层级深度等问题，且内容情感多样性不足、语气趋于通用化，与真实传播的结构动态和语义特征存在显著差异，难以有效支撑下游虚假新闻检测（尤其在早期检测、跨平台泛化场景）。</span></li>\n</ol>\n<h1><span style=\"font-size: 14px;\">2 介绍</span></h1>\n<p><span style=\"font-size: 14px;\"><strong>LLM 生成合成传播的现状与核心缺陷</strong></span></p>\n<p><span style=\"font-size: 14px;\">  <img alt=\"image\" height=\"305\" src=\"https://img2024.cnblogs.com/blog/1871353/202512/1871353-20251227170827508-1951481889.png\" width=\"511\" /></span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\"><strong>左侧：LLM 生成的合成传播树（以 Wan et al., 2024 的方法为例）</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">结构特点：<strong>均匀化</strong>（分支分布规则、层级简单）</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">内容特点：语义<strong>中立、一致性强</strong>（评论语气温和，如 “Stay calm”“Wait for truth”，情感波动小）</span></p>\n</li>\n</ul>\n</li>\n<li>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\"><strong>右侧：真实世界的传播树</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">结构特点：<strong>不规则</strong>（分支分布无规律，存在 “广度扩散”“深度递进” 的复杂拓扑）</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">内容特点：语义<strong>多样化</strong>、<strong>情感强烈</strong>（评论包含支持 / 反对、情绪性表达，如 “FAKE NEWS!”“YOU ARE A FOOL”，语气两极分化）</span></p>\n</li>\n</ul>\n</li>\n</ol>\n<p>&nbsp;</p>\n<h1><span style=\"font-size: 14px;\">3 方法</span></h1>\n<h2 class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\">3.1 核心概述（Overview）</span></h2>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\">模块构成</span></p>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">  StruSP 框架包含两大核心模块，形成 “学习 - 增强” 的完整流程：</span></p>\n<ol>\n<li>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">双向进化传播学习（Bidirectional Evolutionary Propagation, BEP）：核心是让 LLM 学习真实传播的结构动态特征</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">结构感知传播增强（Structure-aware Propagation Enhancement, SPE）：基于学习到的结构知识，生成合成传播以补充不完整数据</span></p>\n</li>\n</ol>\n</li>\n</ol>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>整体流程</strong></span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">先通过 BEP 模块，从真实传播数据中提取结构模式并训练 LLM；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">再通过 SPE 模块，利用训练后的 LLM 对不完整传播树进行结构一致的扩展；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">最终整合真实与合成传播数据，输入检测器完成虚假新闻二分类。</span></p>\n</li>\n</ol>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>关键符号与输入输出</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">输入：单条新闻的不完整传播图&nbsp;<span class=\"container-mbkw8x math-inline\"> $G_0' = (V', E')$ </span>（<span class=\"container-mbkw8x math-inline\"> $V'$ </span>&nbsp;含新闻节点和少量评论节点，<span class=\"container-mbkw8x math-inline\"> $E'$ </span>&nbsp;为互动关系）</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">输出：增强后的完整传播树&nbsp;<span class=\"container-mbkw8x math-inline\"> $G_k'$ </span>&nbsp;及新闻真实性标签&nbsp;<span class=\"container-mbkw8x math-inline\"> $\\hat{y} \\in \\{0,1\\}$ </span>（0 为真实新闻，1 为虚假新闻）</span></p>\n</li>\n</ul>\n<p><span style=\"font-size: 14px;\"><strong>框架</strong></span></p>\n<p><span style=\"font-size: 14px;\">  <img alt=\"image\" height=\"411\" src=\"https://img2024.cnblogs.com/blog/1871353/202512/1871353-20251227180227653-1227659460.png\" width=\"742\" /></span></p>\n<h2 class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\">3.2 双向进化传播学习（Bidirectional Evolutionary Propagation Learning）</span></h2>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>核心目标</strong></span></p>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">  让 LLM 掌握真实传播的 “双向结构动态”（广度扩散 + 深度递进），为生成真实可信的合成传播奠定基础，包含两大核心组件。</span></p>\n<h3 class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\">3.2.1 结构感知混合采样（Structure-aware Hybrid Sampling）</span></h3>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>设计动机</strong></span></p>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">  真实新闻传播存在两种关键结构模式，需同时捕捉：</span></p>\n<ul>\n<li>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">广度扩展（Breadth-wise Expansion）：跨用户群体的广泛传播（如多用户直接评论新闻），形成多分支结构；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">深度递进（Depth-wise Progression）：用户间的分层互动（如多轮评论回复），形成长序列链结构。</span></p>\n</li>\n</ul>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>采样方法</strong></span></p>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">  对真实传播图&nbsp;<span class=\"container-mbkw8x math-inline\"> $G=(V, E)$ </span>&nbsp;采用两种图遍历策略，生成两类传播路径：</span></p>\n<ol>\n<li>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">广度优先搜索（BFS）：生成广度扩展路径&nbsp;<span class=\"container-mbkw8x math-inline\"> $P_{\\mathcal{G}}^B = BFS(\\mathcal{G})$ </span>，捕捉多分支扩散模式；</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">形式：<span class=\"container-mbkw8x math-inline\">$\\mathcal{P}_{\\text{BFS}} = \\{v_0 \\rightarrow v_{1,1} \\rightarrow v_{1,2} \\rightarrow \\dots \\rightarrow v_{1,k}\\}$（ $v_0$ 为根节点， $v_{1,i}$ 为 $v_0$ 的同级子节点，$k$ 为该层级节点数）</span></span></p>\n</li>\n</ul>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">深度优先搜索（DFS）：生成深度递进路径&nbsp;<span class=\"container-mbkw8x math-inline\"> $P_{\\mathcal{G}}^D = DFS(\\mathcal{G})$ </span>，捕捉长序列互动模式。</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li><span class=\"container-mbkw8x math-inline\" style=\"font-size: 14px;\">形式：$\\mathcal{P}_{\\text{DFS}} = \\{v_0 \\rightarrow v_{1,1} \\rightarrow v_{2,1} \\rightarrow \\dots \\rightarrow v_{d,1}\\}$ （$d$ 为传播树的深度， $v_{i,1}$ 为第i层的子节点）</span></li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>路径表示格式</strong></span></p>\n<p><span style=\"font-size: 14px;\">  每条传播路径&nbsp;<span class=\"container-mbkw8x math-inline\"> $P \\in P = P_B \\cup P_D$ </span> 表示为节点序列：</span></p>\n<p><span style=\"font-size: 14px;\"><span class=\"container-mbkw8x math-inline\">     $P = (v_0, v_1, ..., v_{|P|})$ </span></span></p>\n<p><span style=\"font-size: 14px;\"><span class=\"container-mbkw8x math-inline\">  其中每个节点 <span class=\"container-mbkw8x math-inline\"> $v_i$ </span>&nbsp;用三元组表示：<span class=\"container-mbkw8x math-inline\"> $v_i = &lt;id_{parent}, i, c_i&gt;$ </span></span><br /></span></p>\n<ul>\n<li>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><span class=\"container-mbkw8x math-inline\"> $id_{parent}$ </span>：父节点索引（范围&nbsp;<span class=\"container-mbkw8x math-inline\"> $\\{0,1,...,i-1\\}$ </span>，新闻节点&nbsp;<span class=\"container-mbkw8x math-inline\"> $v_0$ </span>&nbsp;的父节点索引为 None）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">$i$：当前节点索引；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><span class=\"container-mbkw8x math-inline\"> $c_i$ </span>：节点内容（新闻节点为新闻文本，其他节点为评论文本）。</span></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\">3.2.2 掩码传播建模（Masked Propagation Modeling）</span></h3>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>设计动机</strong></span></p>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">  借鉴掩码语言模型（MLM）思路，让 LLM 学习传播路径中的结构依赖关系，而非仅依赖语义。</span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>核心操作</strong></span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><strong>节点掩码</strong>：对每条采样路径 $P$，迭代选择节点&nbsp;<span class=\"container-mbkw8x math-inline\"> $v_m$ </span>（<span class=\"container-mbkw8x math-inline\"> $m \\in \\{1,2,...,|P|\\}$ </span>），分别对其前序节点&nbsp;<span class=\"container-mbkw8x math-inline\"> $v_{m-1}$ </span>&nbsp;和后序节点&nbsp;<span class=\"container-mbkw8x math-inline\"> $v_{m+1}$ </span>&nbsp;进行掩码，生成两条子路径：</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">向后预测子路径：<span class=\"container-mbkw8x math-inline\"> $P_{m}^{-1} = (v_0, ..., v_{m-2}, v_{[mask]}, v_m)$ </span>（预测&nbsp;<span class=\"container-mbkw8x math-inline\"> $v_{m-1}$ </span>）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">向前预测子路径：<span class=\"container-mbkw8x math-inline\"> $P_{m}^{+1} = (v_0, ..., v_{m-1}, v_m, v_{[mask]})$ </span>（预测&nbsp;<span class=\"container-mbkw8x math-inline\"> $v_{m+1}$ </span>）。</span></p>\n</li>\n</ul>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>文本化转换</strong>：通过提示模板&nbsp;<span class=\"container-mbkw8x math-inline\"> $\\Phi_1(\\cdot)$ </span>&nbsp;将子路径转换为自然语言指令，示例：</span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><strong>提示模板</strong>：Given the propagation tree: &nbsp;$P_{m}^{z}$ , please predict the masked comment node ({'parent node index': '[masked]', 'node index': '[masked]', 'content': '[masked]'}) in a JSON format as same as other nodes.</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>传播路径</strong> <code>$P_{m}^{z}$：[(node_index: 0, parent_index: -1, content: \"Donald Trump has been disqualified from running for president.\"), (node_index: 1, parent_index: 0, content: \"I can't believe it! 😲\"), v_[mask], (node_index: 3, parent_index: 1, content: \"Not true…😯\")]</code></span></p>\n</li>\n<li><span style=\"font-size: 14px;\"><strong>掩码节点</strong>：<code>{parent node index: 1, node index: 2, content: \"Hard to believe🤔\"}</code></span></li>\n</ol>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>优化目标</strong>：最小化掩码节点的预测损失，公式如下：</span></p>\n<p><span class=\"container-mbkw8x math-inline\" style=\"font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$\\mathcal{L} = \\sum_{P \\in \\mathcal{P}} \\left( \\sum_{m=0}^{|P|-1} -log \\mathbb{P}(v_{m+1} | \\Phi_1(P_{m}^{+1})) - \\sum_{m=2}^{|P|} log \\mathbb{P}(v_{m-1} | \\Phi_1(P_{m}^{-1})) \\right)$ </span></p>\n<p><span style=\"font-size: 14px;\"><span class=\"container-mbkw8x math-inline\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>其中，$\\mathbb{P}(v | \\cdot)$ &nbsp;表示 LLM 对节点 $v$ 的预测概率。</span></p>\n</li>\n</ol>\n<h2 class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\">3.3 结构感知传播增强（Structure-aware Propagation Enhancement）</span></h2>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>设计动机</strong></span></p>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">  区别于传统 LLM 仅基于新闻内容生成传播的方式，以 “现有不完整传播树” 为引导，确保生成的传播与真实结构一致。</span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>生成流程</strong></span></p>\n<ol>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>序列转换</strong>：将给定的<span style=\"color: rgba(255, 0, 0, 1);\">不完整传播</span>&nbsp;<span class=\"container-mbkw8x math-inline\"> $G_0'$ </span>&nbsp;按<span style=\"color: rgba(255, 0, 0, 1);\">时间顺序</span>转换为传播序列&nbsp;<span class=\"container-mbkw8x math-inline\"> $P_{\\mathcal{G}', 0}$</span>；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>迭代生成</strong>：训练后的 LLM 基于前序传播序列，通过提示模板&nbsp;<span class=\"container-mbkw8x math-inline\">&nbsp;Φ2(⋅)&nbsp;</span> 生成下一个评论节点：</span></p>\n<ul>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>公式</strong></span></p>\n</li>\n</ul>\n</li>\n</ol>\n<p><span style=\"font-size: 14px;\">        $v_i' = LLM(\\Phi_2(P_{\\mathcal{G}', i-1})) $</span></p>\n<p><span style=\"font-size: 14px;\"><span class=\"container-mbkw8x math-inline\">        &nbsp; &nbsp; $P_{\\mathcal{G}', i} = P_{\\mathcal{G}', i-1} \\cup \\{v_i'\\} $</span></span></p>\n<ol>\n<li>\n<ul>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>提示模板</strong>：Given the propagation tree: ${P_{G', i-1}}$, please predict the next comment node in a JSON format as same as other nodes, i.e., {parent node index: num, node index: num, content: text}.</span></p>\n</li>\n</ul>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>终止条件</strong>：生成节点数量达到预设值 $k$（实验中设为 $30$）。【迭代生成】</span></p>\n</li>\n</ol>\n<p><span style=\"font-size: 14px;\"><strong>迭代生成算法</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">第 $i$ 轮生成（\\(i = t+1\\)  ）：</span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">输入：将当前序列 <span class=\"container-mbkw8x math-inline\">\\(P_{\\mathcal{G}', t}\\)</span>（即初始不完整序列）通过&nbsp;<span class=\"container-mbkw8x math-inline\">\\(\\Phi_2(\\cdot)\\)</span>&nbsp;编码为提示词，示例：</span></p>\n<div class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">“Given the propagation tree: [(node_index: 0, parent_index: None, content: \"Donald Trump has been disqualified from running for president.\"), (node_index: 1, parent_index: 0, content: \"I can't believe it! 😲\"), (node_index: 2, parent_index: 1, content: \"Not true…😯\")], please predict the next comment node in a JSON format as same as other nodes, i.e., {parent node index: num, node index: num, content: text}.”</span></div>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">生成：LLM 输出新节点 <span class=\"container-mbkw8x math-inline\">\\(v_{t+1}'\\)</span>（需满足结构一致性，如父节点索引为 0/1/2 中的有效值，自身索引为&nbsp;<span class=\"container-mbkw8x math-inline\">\\(t+1\\)</span>，内容与上下文语义连贯）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">更新：将 <span class=\"container-mbkw8x math-inline\">\\(v_{t+1}'\\)</span>&nbsp;加入序列，得到&nbsp;<span class=\"container-mbkw8x math-inline\">\\(P_{\\mathcal{G}', t+1} = P_{\\mathcal{G}', t} \\cup \\{v_{t+1}'\\}\\)</span>。</span></p>\n</li>\n</ol>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">第 2 轮至第&nbsp;<span class=\"container-mbkw8x math-inline\">\\(k-t\\)</span>&nbsp;轮生成（<span class=\"container-mbkw8x math-inline\">\\(i = t+2\\)</span>&nbsp;至&nbsp;<span class=\"container-mbkw8x math-inline\">\\(i = k\\)</span>）：</span></p>\n<p><span style=\"font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp; 重复上述步骤，每次均以 “上一轮更新后的完整序列 <span class=\"container-mbkw8x math-inline\">\\(P_{\\mathcal{G}', i-1}\\)</span>” 为输入，通过&nbsp;<span class=\"container-mbkw8x math-inline\">\\(\\Phi_2(\\cdot)\\)</span>&nbsp;编码后让 LLM 生成下一个节点&nbsp;<span class=\"container-mbkw8x math-inline\">\\(v_i'\\)</span>，再更新序列。</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">终止条件：当序列长度达到预设值 $<span class=\"container-mbkw8x math-inline single-n2Ai8A\">k$</span>（生成节点总数满足要求），迭代停止。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"color: rgba(255, 0, 0, 1); font-size: 14px;\"><strong>生成节点的验证过滤</strong></span></p>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">    为确保生成节点的有效性，所有&nbsp;<span class=\"container-mbkw8x math-inline\">\\(v_i'\\)</span>&nbsp;需通过三层自动化验证后，才能加入序列（避免结构异常或语义无效）：</span></p>\n<ol>\n<li>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">语法过滤：检查 LLM 输出是否为合规 JSON 格式，排除格式错误节点；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">结构过滤：验证父节点索引是否在当前序列中存在、节点索引是否连续递增、无自环 / 循环等拓扑异常；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">内容过滤：过滤空内容、重复文本、LLM 拒绝生成的 boilerplate 信息，确保评论内容有效。</span></p>\n</li>\n</ol>\n</li>\n</ol>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>核心优势</strong></span></p>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">  生成的节点同时满足：</span></p>\n<ul>\n<li>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">结构一致性：父节点索引符合真实传播的拓扑关系；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">语义连贯性：内容与现有传播的上下文匹配。</span></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\">3.4 传播增强检测（Propagation-enhanced Detection）</span></h2>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>步骤 1：传播树重建</strong></span></p>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">  聚合迭代生成后的完整序列&nbsp;<span class=\"container-mbkw8x math-inline\"> $P_{\\mathcal{G}', k}$ </span>&nbsp;中所有节点信息，重建增强后的传播树&nbsp;<span class=\"container-mbkw8x math-inline\"> $G_k'$ </span>。</span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>步骤 2：虚假新闻分类</strong></span></p>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">  将增强后的传播树&nbsp;<span class=\"container-mbkw8x math-inline\"> $G_k'$ </span>&nbsp;输入训练好的检测器&nbsp;<span class=\"container-mbkw8x math-inline\"> $f(\\cdot)$ </span>，输出新闻真实性预测标签&nbsp;<span class=\"container-mbkw8x math-inline\"> $\\hat{y}$ </span>，公式如下：</span></p>\n<p><span class=\"container-mbkw8x math-inline\" style=\"font-size: 14px;\">&nbsp;    $\\hat{y} = f(\\mathcal{G}_k')$ </span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>  关键说明</strong></span></p>\n<ul>\n<li>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">检测器&nbsp;<span class=\"container-mbkw8x math-inline\"> $f(\\cdot)$ </span>&nbsp;可采用主流传播基检测模型（如 GCN、Bi-GCN、RAGCL 等）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">增强后的传播树融合了真实传播的核心特征与合成传播的补充信息，解决了数据不完整问题。</span></p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\">4 实验</span></h1>\n<h2 class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\">4.1 数据集（Datasets）</span></h2>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>1. 数据集选择与背景</strong></span></p>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">  实验采用 3 个公开且具有代表性的虚假新闻数据集，覆盖不同语言（英文、中文）、平台（Twitter/X、Weibo）和场景（普通新闻、紧急事件新闻），确保结果的通用性和鲁棒性。</span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>2. 数据集核心信息</strong></span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>  <img alt=\"image\" height=\"149\" src=\"https://img2024.cnblogs.com/blog/1871353/202512/1871353-20251227203931858-1010575833.png\" width=\"403\" /></strong></span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>3. 数据划分方式</strong></span></p>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">  遵循 Chen 等人（2025）的划分标准，所有数据集按&nbsp;<strong>7:1:2</strong>&nbsp;比例分为训练集、验证集和测试集，确保训练与评估的独立性。</span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>4. 跨平台检测数据处理</strong></span></p>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">  针对跨平台检测场景（Twitter→CED），为消除语言差异影响，使用 LLaMa3-8B-Instruct 将 CED 测试集的中文文本翻译为英文。</span></p>\n<h2 class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\">4.2 Baselines（基准模型）</span></h2>\n<p class=\"auto-hide-last-sibling-br paragraph-pP9ZLC paragraph-element br-paragraph-space\"><span style=\"font-size: 14px;\">  实验选取两类基准模型，分别用于对比 “虚假新闻检测性能” 和 “合成传播生成质量”，确保评估的全面性。</span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>1. 虚假新闻检测基准</strong></span></p>\n<div class=\"table-scroll-container-Gyf4hQ mdbox-table-scroll-container\">\n<table>\n<thead>\n<tr>\n<th><span style=\"font-size: 14px;\">模型名称</span></th>\n<th><span style=\"font-size: 14px;\">模型类型</span></th>\n<th><span style=\"font-size: 14px;\">核心原理</span></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span style=\"font-size: 14px;\">BERT</span></td>\n<td><span style=\"font-size: 14px;\">文本内容基模型</span></td>\n<td><span style=\"font-size: 14px;\">预训练语言模型，取最后一层输出输入分类器，仅依赖新闻文本特征</span></td>\n</tr>\n<tr>\n<td><span style=\"font-size: 14px;\">dEFEND</span></td>\n<td><span style=\"font-size: 14px;\">文本 + 评论基模型</span></td>\n<td><span style=\"font-size: 14px;\">设计句子 - 评论共注意力子网络，融合新闻内容与评论特征进行检测</span></td>\n</tr>\n<tr>\n<td><span style=\"font-size: 14px;\">GCN</span></td>\n<td><span style=\"font-size: 14px;\">传播结构基模型</span></td>\n<td><span style=\"font-size: 14px;\">对新闻传播图执行图卷积操作，学习结构特征用于分类</span></td>\n</tr>\n<tr>\n<td><span style=\"font-size: 14px;\">Bi-GCN</span></td>\n<td><span style=\"font-size: 14px;\">传播结构基模型</span></td>\n<td><span style=\"font-size: 14px;\">基于传播图建模双向传播关系，捕捉更丰富的结构依赖</span></td>\n</tr>\n<tr>\n<td><span style=\"font-size: 14px;\">EBGCN</span></td>\n<td><span style=\"font-size: 14px;\">传播结构基模型</span></td>\n<td><span style=\"font-size: 14px;\">采用贝叶斯图卷积网络，从不确定传播中学习结构特征</span></td>\n</tr>\n<tr>\n<td><span style=\"font-size: 14px;\">RAGCL</span></td>\n<td><span style=\"font-size: 14px;\">传播结构基模型</span></td>\n<td><span style=\"font-size: 14px;\">通过自适应传播图对比学习，学习鲁棒的谣言表示</span></td>\n</tr>\n<tr>\n<td><span style=\"font-size: 14px;\">LLM-text</span></td>\n<td><span style=\"font-size: 14px;\">LLM 基检测模型</span></td>\n<td><span style=\"font-size: 14px;\">仅输入新闻文本，让 LLM 直接进行虚假新闻分类</span></td>\n</tr>\n<tr>\n<td><span style=\"font-size: 14px;\">LLM-comments</span></td>\n<td><span style=\"font-size: 14px;\">LLM 基检测模型</span></td>\n<td><span style=\"font-size: 14px;\">输入新闻文本 + 真实评论，让 LLM 进行分类</span></td>\n</tr>\n<tr>\n<td><span style=\"font-size: 14px;\">LLM-propagation</span></td>\n<td><span style=\"font-size: 14px;\">LLM 基检测模型</span></td>\n<td><span style=\"font-size: 14px;\">输入完整传播信息（新闻 + 评论 + 传播结构），让 LLM 进行分类</span></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>2. 合成传播生成基准</strong></span></p>\n<div class=\"table-scroll-container-Gyf4hQ mdbox-table-scroll-container\">\n<table>\n<thead>\n<tr>\n<th><span style=\"font-size: 14px;\">模型名称</span></th>\n<th><span style=\"font-size: 14px;\">核心原理</span></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span style=\"font-size: 14px;\">GenFEND</span></td>\n<td><span style=\"font-size: 14px;\">定义 30 个特定用户画像（性别、年龄、教育水平），让 LLM 扮演这些用户生成评论</span></td>\n</tr>\n<tr>\n<td><span style=\"font-size: 14px;\">DELL</span></td>\n<td><span style=\"font-size: 14px;\">通过迭代过程让 LLM 扮演指定用户，可直接评论新闻或回复已有评论，生成传播结构</span></td>\n</tr>\n<tr>\n<td><span style=\"font-size: 14px;\">LLM（未微调）</span></td>\n<td><span style=\"font-size: 14px;\">直接使用未经过 BEP 训练的 LLaMa3-8B-Instruct，按 SPE 模块流程生成传播</span></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\">4.3 实验内容、结果与结论</span></h2>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>1. 实验核心目标</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">验证 StruSP 框架在不同检测场景下的虚假新闻检测性能；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">评估 StruSP 生成的合成传播在结构和语义上与真实传播的一致性；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">验证 StruSP 各核心组件（BEP、SPE、SHS、MPM）的有效性；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">验证 StruSP 对不同 LLM 骨干网络的通用性。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>2. 实验 1：一般检测（General Detection）</strong></span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验内容</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">场景：使用完整的真实传播数据 + 合成传播数据进行虚假新闻分类；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">评估指标：Accuracy（准确率）、Macro-F1、Precision（精确率）、Recall（召回率）、AUC；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">核心对比：StruSP 增强后的检测模型（如 StruSP w/RAGCL）与各类基准检测模型、LLM 生成基准增强模型的性能。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验结果</strong></span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>  <img alt=\"image\" height=\"349\" src=\"https://img2024.cnblogs.com/blog/1871353/202512/1871353-20251227204522683-2020787083.png\" width=\"542\" /></strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">StruSP w/RAGCL 在 Twitter 和 PHEME5 数据集上均取得最优性能，在 PHEME5 上准确率较原始 RAGCL 提升 2.95%；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">所有传播结构基模型（GCN、Bi-GCN、EBGCN、RAGCL）经 StruSP 增强后，性能均显著提升（p-value &lt; 0.05）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">StruSP 增强模型的性能优于 GenFEND、DELL 增强模型，且差距明显。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>结论</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">StruSP 生成的合成传播数据能有效补充真实传播的特征，显著提升下游检测性能；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">结构感知的合成传播生成（StruSP）优于仅基于角色扮演的生成方法（GenFEND、DELL），验证了 “结构 + 语义双对齐” 设计的有效性。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>3. 实验 2：早期检测（Early Detection）</strong></span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验内容</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">场景：模拟早期传播阶段（仅保留少量真实传播数据），用不同方法生成合成传播补充后进行检测；</span></p>\n</li>\n<li><span style=\"font-size: 14px;\"><strong>骨干检测模型</strong>：选用 RAGCL（自适应传播图对比学习模型）作为核心检测模型，该模型在传播结构特征提取上表现优异，适合评估传播数据补充后的性能变化。</span></li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>四大对比组</strong>（确保评估的全面性）：</span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><strong>Full 组</strong>：测试时使用全部真实传播数据（无数据缺失），作为 “理想场景” 的性能上限，用于衡量其他组的性能差距；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>None 组</strong>：测试时仅使用保留的少量真实传播数据（不补充任何合成传播），作为 “无增强场景” 的基准，反映数据稀缺对检测的负面影响；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>DELL 组</strong>：测试时使用 “少量真实传播数据 + DELL 生成的合成传播数据”，对比 “角色扮演类生成方法” 与 StruSP 的增强效果；</span></p>\n</li>\n<li><span style=\"font-size: 14px;\"><strong>StruSP 组</strong>：测试时使用 “少量真实传播数据 + StruSP 生成的合成传播数据”，验证本框架的早期检测增强能力。</span></li>\n</ol>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">评估指标：核心检测指标（Accuracy、Macro-F1）。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验结果</strong></span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>  <img alt=\"image\" height=\"269\" src=\"https://img2024.cnblogs.com/blog/1871353/202512/1871353-20251227205412443-2061137024.png\" width=\"362\" /></strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">StruSP 增强模型的检测性能接近 Full 组（完整真实数据），显著优于 None 组和 DELL 组；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">DELL 增强模型的性能甚至低于 None 组，出现负向优化。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>结论</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">StruSP 生成的合成传播与真实传播在结构和语义上高度一致，能有效弥补早期传播数据不足的问题；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">DELL 生成的传播与真实早期传播模式不匹配，导致检测性能下降，进一步验证结构感知生成的必要性。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>4. 实验 3：跨平台检测（Cross-platform Detection）</strong></span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验内容</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">场景：源平台（Twitter/PHEME5）训练检测模型，目标平台（CED）测试，模拟跨平台传播数据稀缺场景；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>骨干检测模型</strong>：选用 RAGCL（自适应传播图对比学习模型）作为核心检测模型，该模型在传播结构特征提取和鲁棒性上表现优异，适合评估跨平台场景下的特征迁移能力。</span></p>\n</li>\n<li><span style=\"font-size: 14px;\"><strong>目标平台数据处理</strong>：提取 CED 测试集的少量真实传播数据（模拟目标平台数据稀缺），翻译为英文后构建 “跨平台不完整传播树”；</span></li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>三大对比组</strong>（聚焦跨平台增强效果对比）：</span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><strong>原始 RAGCL 组</strong>：测试时仅使用目标平台（CED）的少量真实传播数据，不补充任何合成传播，作为 “无增强跨平台检测” 的基准；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>DELL 增强组</strong>：测试时使用 “目标平台少量真实传播数据 + DELL 生成的合成传播数据”，对比 “角色扮演类生成方法” 的跨平台增强效果；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>StruSP 增强组</strong>：测试时使用 “目标平台少量真实传播数据 + StruSP 生成的合成传播数据”，验证本框架的跨平台增强能力。</span></p>\n</li>\n</ol>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>评估指标</strong>：Accuracy、Macro-F1。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验结果</strong></span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\">  <img alt=\"image\" height=\"213\" src=\"https://img2024.cnblogs.com/blog/1871353/202512/1871353-20251227205800886-1066067470.png\" width=\"398\" /></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">RAGCL w/StruSP 取得最优性能（Twitter→CED 准确率 92.28%，Macro-F1 91.56%）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">原始 RAGCL 和 RAGCL w/DELL 性能较差，跨平台迁移效果不佳。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>结论</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">StruSP 能保留源平台的传播动态特征，同时适配目标平台的内容，生成的合成传播具有更强的跨平台通用性；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">结构感知生成是解决跨平台传播数据稀缺问题的有效手段。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>5. 实验 4：消融实验（Ablation Study）</strong></span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验内容</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">目的：验证 StruSP 各核心组件的必要性；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">消融变体：</span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">w/o SHS：移除结构感知混合采样模块；</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li><span style=\"font-size: 14px;\">移除 BEP 模块中 “BFS+DFS 双向采样” 功能，仅保留单一采样方式或不采样，测试 “双向结构捕捉” 的必要性</span></li>\n</ul>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">w/o MPM：移除掩码传播建模模块；</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">移除 BEP 模块中 “双向掩码节点预测” 训练目标，LLM 仅通过原始传播数据初步学习，测试 “结构依赖学习” 的必要性。</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><strong>LLM 仅通过原始传播数据初步学习</strong>：仅保留采样后的原始传播路径（BFS/DFS 路径），不做任何节点掩码操作。 &nbsp; &nbsp;无显式预测损失，仅通过 “自回归语言建模损失” 让 LLM 学习传播路径的文本序列规律。</span></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">w/o BEP：移除双向进化传播学习策略（同时移除 SHS 和 MPM）；</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li><span style=\"font-size: 14px;\">完全移除 BEP 模块（同时移除 SHS 和 MPM），LLM 不进行结构感知训练，仅作为通用语言模型生成传播，测试 BEP 模块的核心作用</span></li>\n</ul>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">w/o SPE：移除结构感知传播增强模块（仅基于新闻内容生成传播）；</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li><span style=\"font-size: 14px;\">移除 “基于不完整传播树引导生成” 逻辑，LLM 仅基于新闻文本生成传播（而非以真实不完整传播为引导），测试 “结构引导生成” 的必要性</span></li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">基准模型：StruSP w/RAGCL（完整框架）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">评估指标：Accuracy、Macro-F1（Twitter 和 PHEME5 数据集）。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验结果</strong></span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>  <img alt=\"image\" height=\"216\" src=\"https://img2024.cnblogs.com/blog/1871353/202512/1871353-20251227210248223-1882980890.png\" width=\"469\" /></strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">完整 StruSP 框架性能最优；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">性能下降幅度排序：w/o BEP &gt; w/o MPM ≈ w/o SHS &gt; w/o SPE；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">w/o BEP 变体性能下降最显著（Twitter 准确率降至 83.62%，Macro-F1 降至 83.22%）。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>结论</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">BEP 学习策略（含 SHS 和 MPM）是 StruSP 框架的核心，两者互补，共同保障合成传播的真实性；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">SHS 模块对捕捉双向传播结构、MPM 模块对学习结构依赖至关重要；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">SPE 模块（基于不完整传播引导生成）优于仅基于新闻内容的生成，验证了 “结构引导” 的有效性。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>6. 实验 5：传播质量评估（Propagation Evaluation）</strong></span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验内容</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">目的：评估 StruSP 生成的合成传播与真实传播的一致性；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">评估维度：</span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><strong>结构指标</strong></span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><strong>结构熵（Structural Entropy, SE）</strong>：基于节点度数分布的香农熵，量化传播树节点连接的不确定性，值越接近真实传播，说明结构分布越相似；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>最大深度（Maximum Depth, MD）</strong>：单条传播树的最长路径长度，反映传播的深度递进能力；</span></p>\n</li>\n<li><span style=\"font-size: 14px;\"><strong>最大广度（Maximum Breadth, MB）</strong>：传播树中某一层级的最大节点数，反映传播的广度扩散能力。</span></li>\n</ol>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>语义指标</strong></span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><strong>语义一致性（Semantic Consistency, SemC）</strong>：计算合成传播树与对应真实传播树的平均语义嵌入余弦相似度，值越高说明语义对齐度越强；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>情感一致性（Sentiment Consistency, SenC）</strong>：判断合成传播树的 majority 情感（多数节点情感倾向）与真实传播树是否一致，用匹配比例衡量；</span></p>\n</li>\n<li><span style=\"font-size: 14px;\"><strong>语义同质性（Semantic Homogeneity, SemH）</strong>：计算单条合成传播树内所有节点间的语义嵌入余弦相似度平均值，衡量传播内容的内部连贯性。</span></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>对比组</strong>：</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">GenFEND 生成的合成传播（角色扮演类基线）；  </span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">DELL 生成的合成传播（传播结构生成类基线）；  </span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">未微调 LLM 生成的合成传播（无结构学习的 LLM 基线）；  </span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">StruSP 生成的合成传播（本文方法）；  </span></p>\n</li>\n</ul>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验流程</strong></span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><strong>合成传播生成</strong>：对 Twitter 和 PHEME5 数据集中的每条新闻，分别用 StruSP、GenFEND、DELL、未微调 LLM 生成合成传播树（每条生成 30 个节点）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>真实传播提取</strong>：提取对应新闻的完整真实传播树，作为评估的 “黄金标准”；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>指标计算</strong>：</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">结构指标：对每条合成 - 真实传播树对，计算 SE、MD、MB；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">语义指标：用 BERT 模型提取所有节点的语义嵌入，计算 SemC 和 SemH；用预训练情感分类器（DistilBERT 微调版）标注每个节点情感，计算 SenC；</span></p>\n</li>\n</ul>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>宏观与微观分析</strong>：</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">宏观分析：计算所有样本的指标平均值，对比各方法与真实传播的整体差距；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">微观分析：统计各指标的样本分布情况（如直方图、箱线图），评估合成传播的稳定性与多样性。</span></p>\n</li>\n</ul>\n</li>\n</ol>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验结果</strong></span></p>\n<p class=\"table-scroll-container-Gyf4hQ mdbox-table-scroll-container\"><span style=\"font-size: 14px;\">  <img alt=\"image\" height=\"437\" src=\"https://img2024.cnblogs.com/blog/1871353/202512/1871353-20251227211324985-1422857191.png\" width=\"503\" /></span></p>\n<p class=\"table-scroll-container-Gyf4hQ mdbox-table-scroll-container\"><span style=\"font-size: 14px;\">  图 4：在合并的 Twitter 和 PHEME5 数据集上进行的微观层面传播分析结果。不同方法生成的传播在结构熵、实例级深度 / 广度以及语义同质性方面的分布情况</span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>结论</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">结构层面：StruSP 生成的传播在 SE、MD、MB 上与真实传播最接近，避免了 GenFEND 的结构单一和 DELL 的结构失真；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">语义层面：StruSP 的 SemC（0.97）、SenC（0.85）均高于其他基准，说明生成内容与真实传播的语义、情感一致性更强；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">StruSP 生成的传播兼具 “真实性” 和 “多样性”，优于其他生成方法。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>7. 实验 6：不同 LLM 骨干网络验证</strong></span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验内容</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">目的：验证 StruSP 对不同 LLM 骨干的通用性；</span></p>\n</li>\n<li><span style=\"font-size: 14px;\"><strong>变量控制</strong>：仅改变 LLM 骨干网络类型，其余训练配置（生成节点数、微调参数、检测模型）完全一致，避免无关变量干扰。</span>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><strong>LLaMa3-8B-Instruct</strong>：Meta 推出的 80 亿参数开源 LLM，指令跟随能力强，是主实验默认骨干网络；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>Qwen3-4B</strong>：阿里推出的 40 亿参数开源 LLM，轻量化且性能优异，适合资源受限场景。</span></p>\n</li>\n</ul>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">基准模型：结合 GCN、Bi-GCN、EBGCN、RAGCL 四类检测模型；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">评估指标：Accuracy、Macro-F1（Twitter 和 PHEME5 数据集）。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验流程</strong></span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><strong>LLM 微调训练</strong>：</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">对两款 LLM（LLaMa3-8B-Instruct、Qwen3-4B）分别执行 StruSP 的 BEP 模块训练：使用 Twitter+PHEME5 合并训练集，通过 SHS 采样 + 无掩码文本学习（仅替换骨干，训练逻辑不变）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">微调配置统一：LoRA 秩 = 8，AdamW 优化器，学习率 5e-5，训练 4 个 epoch，启用 BF16 精度；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">生成配置统一：所有模型生成的合成节点数均预设为 30。</span></p>\n</li>\n</ul>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>检测模型训练与评估</strong>：</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">将两款微调后的 LLM 分别接入 SPE 模块，生成合成传播数据，与真实传播数据整合；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">用整合后的传播数据，分别训练 GCN、Bi-GCN、EBGCN、RAGCL 四类检测模型；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">在 Twitter 和 PHEME5 测试集上评估所有模型的检测性能，记录核心指标。</span></p>\n</li>\n</ul>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>结果对比分析</strong>：</span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">横向对比：同一 LLM 骨干下，不同检测模型的性能差异；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">纵向对比：同一检测模型下，两款 LLM 骨干的性能差异；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">核心观察：两款 LLM 骨干的性能是否接近，是否均能让 StruSP 框架保持优异表现。</span></p>\n</li>\n</ul>\n</li>\n</ol>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>实验结果</strong></span></p>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>  <img alt=\"image\" height=\"298\" src=\"https://img2024.cnblogs.com/blog/1871353/202512/1871353-20251227212330774-721044242.png\" width=\"362\" /></strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">两种 LLM 作为骨干时，StruSP 增强后的检测模型均取得优异性能；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">LLaMa3-8B-Instruct 和 Qwen3-4B 的性能差异较小（如 StruSP w/RAGCL 在 PHEME5 上的准确率分别为 87.76% 和 87.07%）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">无论使用哪种 LLM，StruSP 增强后的 RAGCL 均为最优组合。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>结论</strong></span></p>\n<ul class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\">StruSP 框架对 LLM 骨干网络具有良好的鲁棒性，不依赖特定 LLM 模型；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\">框架的核心优势（结构感知生成）不受 LLM 类型影响，具有广泛的适用性。</span></p>\n</li>\n</ul>\n<p class=\"header-iWP5WJ auto-hide-last-sibling-br\"><span style=\"font-size: 14px;\"><strong>8. 实验核心总结</strong></span></p>\n<ol class=\"auto-hide-last-sibling-br\">\n<li>\n<p><span style=\"font-size: 14px;\"><strong>性能优势</strong>：StruSP 在一般检测、早期检测、跨平台检测三大实用场景中均显著优于现有基准，验证了其解决 “传播数据不完整” 问题的有效性；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>生成质量</strong>：StruSP 生成的合成传播在结构和语义上与真实传播高度对齐，且多样性更优；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>组件必要性</strong>：BEP 学习策略（SHS+MPM）是框架核心，SPE 模块的结构引导生成优于纯文本驱动生成；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 14px;\"><strong>通用性</strong>：StruSP 可适配不同 LLM 骨干网络和检测模型，具有较强的落地潜力。</span></p>\n</li>\n</ol>\n<p><span style=\"font-size: 14px;\"><strong>参考</strong></span></p>\n<ol>\n<li><span style=\"font-size: 14px;\">Let Silence Speak: Enhancing Fake News Detection with Generated Comments from Large Language Models</span></li>\n<li><span style=\"font-size: 14px;\">DELL: Generating reactions and explanations for LLM-based misinformation detection</span></li>\n<li><span style=\"font-size: 14px;\">From skepticism to acceptance: Simulating the attitude dynamics toward fake news</span></li>\n<li><span style=\"font-size: 14px;\">Can llms simulate social media engagement? a study on action-guided response generation</span></li>\n<li><span style=\"font-size: 14px;\">Evidence-driven retrieval augmented response generation for online misinformation</span></li>\n<li><span style=\"font-size: 14px;\">Structure-aware Propagation Generation with Large Language Models for Fake News Detection</span></li>\n<li><span style=\"font-size: 14px;\">Collaboration and Controversy Among Experts: Rumor Early Detection by Tuning a Comment Generator</span></li>\n</ol>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 21:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xyc-blog\">Blairs</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Spring Boot整合Sentinel之QPS限流",
      "link": "https://www.cnblogs.com/east7/p/19409978",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/east7/p/19409978\" id=\"cb_post_title_url\" title=\"发布于 2025-12-27 20:50\">\n    <span>Spring Boot整合Sentinel之QPS限流</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        介绍Spring Boot 4 如何集成流量治理神器Sentinel实现QPS限流。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>摘要</strong> 介绍Spring Boot 4 如何集成流量治理神器Sentinel实现QPS限流。</p>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#sentinel简介\" rel=\"noopener nofollow\">Sentinel简介</a></li><li><a href=\"#启动-sentinel-控制台\" rel=\"noopener nofollow\">启动 Sentinel 控制台</a><ul><li><a href=\"#下载sentinel\" rel=\"noopener nofollow\">下载sentinel</a></li><li><a href=\"#访问-sentinel-控制台\" rel=\"noopener nofollow\">访问 Sentinel 控制台</a></li></ul></li><li><a href=\"#注解sentinelresource使用方法\" rel=\"noopener nofollow\">注解@SentinelResource使用方法</a></li><li><a href=\"#用sentinelresource限流\" rel=\"noopener nofollow\">用@SentinelResource限流</a></li><li><a href=\"#统一处理sentinel异常done\" rel=\"noopener nofollow\">统一处理Sentinel异常|done</a></li><li><a href=\"#结束语\" rel=\"noopener nofollow\">结束语</a></li><li><a href=\"#reference\" rel=\"noopener nofollow\">Reference</a></li></ul></div><p></p>\n<h3 id=\"sentinel简介\">Sentinel简介</h3>\n<p>  什么是Sentinel？随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由/调度、流量控制、流量整形、熔断降级、系统自适应过载保护/实例摘除、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。</p>\n<p>  同一个资源可以创建多条限流规则。Sentinel底层中的 FlowSlot 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p>\n<p>  在实际的项目开发中，一般不会直接写类似《Spring Boot整合Sentinel之流量控制入门》中那段限流入门演示代码，通常需要将Sentinel集成到应用框架中。本文以《<a href=\"https://www.cnblogs.com/east7/p/19309056\" target=\"_blank\">一步步搭建JDK 21 Spring Boot项目</a>》搭建的Spring Boot项目为基础，展示如何将Sentinel集成到Spring Boot项目中，并基于注解 <strong>@SentinelResource</strong> 进行限流。demo中只介绍了qps限流策略，它有多种策略备选，请根据业务需要自行选定。</p>\n<h3 id=\"启动-sentinel-控制台\">启动 Sentinel 控制台</h3>\n<p>  Sentinel 的使用可以分为两个部分：</p>\n<ul>\n<li>\n<p>控制台（Dashboard）：控制台主要负责管理规则推送、监控、集群限流、分配管理、机器发现等。</p>\n</li>\n<li>\n<p>核心库（Java 客户端）：不依赖任何框架/库，能够运行于 Java 7 及以上版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</p>\n</li>\n</ul>\n<h4 id=\"下载sentinel\">下载sentinel</h4>\n<p>  从<a href=\"https://github.com/alibaba/Sentinel/releases\" rel=\"noopener nofollow\" target=\"_blank\">sentinel控制台传送门</a>下载需要的sentinel jar。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1208468/202512/1208468-20251227204633642-1887509880.png\" /></p>\n<p>  我下载了当前最新版<strong>v1.8.9</strong>。下载后在Mac 终端进入jar包存放目录后，执行命令<code> java -Dserver.port=8080 -jar sentinel-dashboard-1.8.9.jar</code> 即可启动控制台。默认端口是8080，为了避免端口好冲突，可以设置为诸如9000等。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1208468/202512/1208468-20251227204655238-251711394.png\" /></p>\n<h4 id=\"访问-sentinel-控制台\">访问 Sentinel 控制台</h4>\n<p>   在浏览器访问sentinel控制台地址<code>http://localhost:8080</code>或者<code>http://127.0.0.1:8080/</code>即可进入如下登录页面，默认账号密码都是 <strong>sentinel</strong>。恭喜你！此时此刻sentinel下载运行成功。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1208468/202512/1208468-20251227204748437-1017331740.png\" /></p>\n<p>  Sentinel 开源控制台支持实时监控和规则管理。接入控制台的步骤如下：</p>\n<pre><code class=\"language-java\">spring.cloud.sentinel.transport.dashboard=localhost:8080\nspring.cloud.sentinel.transport.heartbeat-interval-ms=500\nspring.cloud.sentinel.eager=true\n</code></pre>\n<p>  配置 <code>heartbeat-interval-ms</code> 用于指定应用与 Sentinel 控制台之间的心跳上报间隔，单位是毫秒。配置为 500 表示<br />\n👉 应用每 500ms（0.5 秒） 向 Sentinel Dashboard 发送一次心跳，用于上报实例存活状态和基础运行信息。<br />\n应用启动时 立即初始化 Sentinel 核心组件并向控制台发起连接，而不是等到第一次流量进入时再初始化。</p>\n<p>  配置 <code>spring.cloud.sentinel.eager=true</code>表示应用启动时 立即初始化 Sentinel 核心组件并向控制台发起连接，而不是等到流量第一次进入时再初始化。两者组合使用的整体业务含义：</p>\n<p>✅ Sentinel 在应用启动阶段即完成初始化，服务一上线就受到限流与熔断保护；<br />\n✅ 应用与控制台之间保持高频心跳，同步实例状态更及时；<br />\n✅ 更有利于稳定性监控、规则推送和快速问题预警；</p>\n<h3 id=\"注解sentinelresource使用方法\">注解@SentinelResource使用方法</h3>\n<p>  简单介绍下注解@SentinelResource中各个属性：</p>\n<ul>\n<li>value - 指定资源的名称</li>\n<li>blockHandler - 服务限流后会抛出BlockException异常，此属性用来指定一个函数(方法)来处理BlockException异常的。\n<ul>\n<li>注意: 这个方法必须是public的,且返回类型需要与原方法相匹配，参数类型默认与原方法一致，且最后加一个额外的参数，类型为BlockException</li>\n</ul>\n</li>\n<li>blockHandlerClass - 若属性blockHandler指定的函数与原方法不在一个类中，则需要使用该属性指定所在的类\n<ul>\n<li>注意:必须配合blockHandler属性一起使用,且blockHandler属性指定的方法必须为static静态函数，否则无法解析</li>\n</ul>\n</li>\n<li>fallback - 用于抛出异常时,执行处理逻辑，可以针对所有类型的异常进行处理\n<ul>\n<li>注意:Sentinel 1.6.0 之前，fallback函数只针对降级异常(DegradeException)进行处理，不能处理业务异常</li>\n<li>返回值类型必须与原函数一致,且方法参数也要与原函数一致,可以在最后加一个额外的参数，类型为Throwable类型</li>\n</ul>\n</li>\n<li>fallbackClass - 若属性fallback指定的函数与原方法不在一个类中，则需要使用该属性指定所在的类\n<ul>\n<li>注意:必须配合fallback属性一起使用，且fallback属性指定的方法必须为static静态函数，否则无法解析</li>\n</ul>\n</li>\n<li>defaultFallback - 默认的fallback函数名称，用于通用的fallback逻辑</li>\n<li>exceptionsToIgnore - 用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入fallback逻辑中，而是会原样抛出</li>\n</ul>\n<h3 id=\"用sentinelresource限流\">用@SentinelResource限流</h3>\n<p>  pom配置如下：</p>\n<pre><code class=\"language-java\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;4.0.0&lt;/version&gt;\n        &lt;relativePath/&gt; \n    &lt;/parent&gt;\n    &lt;groupId&gt;com.cactus&lt;/groupId&gt;\n    &lt;artifactId&gt;wiener&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;wiener&lt;/name&gt;\n    &lt;description&gt;wiener&lt;/description&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;21&lt;/java.version&gt;\n        &lt;sentinel.version&gt;1.8.9&lt;/sentinel.version&gt;\n    &lt;/properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.42&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Sentinel核心服务 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;\n            &lt;artifactId&gt;sentinel-core&lt;/artifactId&gt;\n            &lt;version&gt;${sentinel.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- Sentinel本地应用接入控制台，版本需要与控制台保持一致 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;\n            &lt;artifactId&gt;sentinel-transport-simple-http&lt;/artifactId&gt;\n            &lt;version&gt;${sentinel.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- Sentinel提供注解无侵入定义资源 https://mvnrepository.com/artifact/com.alibaba.csp/sentinel-annotation-aspectj --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;\n            &lt;artifactId&gt;sentinel-annotation-aspectj&lt;/artifactId&gt;\n            &lt;version&gt;${sentinel.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;!-- 如果希望在项目级别使用阿里云镜像，就添加alimaven --&gt;\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;alimaven&lt;/id&gt;\n            &lt;name&gt;aliyun maven&lt;/name&gt;\n            &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n&lt;/project&gt;\n</code></pre>\n<p>  先定义一个测试用例<code>getFlow1</code>，验证注解 <code>@SentinelResource</code>限流是否生效：</p>\n<pre><code class=\"language-java\">@RestController\n@RequestMapping(\"/sentinel\")\npublic class SentinelTestController {\n    /**\n     * 只添加blockHandler属性 指定getFlowBlockHandler方法处理异常\n     */\n    @GetMapping(value = \"getFlow1\")\n    @SentinelResource(value = SentinelRuleConfig.RESOURCE_QPS_LIMIT, blockHandler = \"getFlowBlockHandler\")\n    public String getFlow1() {\n        // 返回值\n        return \"流量正常\";\n    }\n    /**\n     * getFlow1 处理异常逻辑\n     */\n    public String getFlowBlockHandler(BlockException ex) {\n        log.info(\"触发限流\");\n        if (ex instanceof FlowException) {\n            return \"getFlow1限流-流控\";\n        } else if (ex instanceof DegradeException) {\n            return \"getFlow1限流-降级\";\n        }\n        return \"getFlow1限流\";\n    }\n}\n</code></pre>\n<p>  其中，<code>@SentinelResource(value = SentinelRuleConfig.RESOURCE_QPS_LIMIT, blockHandler = \"getFlowBlockHandler\")</code>表示对函数 getFlow1 进行限流监控，资源名是my_resource。我们可以通过编写代码或使用 Sentinel 控制台来<strong>设置规则</strong>。例如，以下是一个定义限流QPS=3的Java代码片段：</p>\n<pre><code class=\"language-java\">import com.alibaba.csp.sentinel.slots.block.RuleConstant;\nimport com.alibaba.csp.sentinel.slots.block.flow.FlowRule;\nimport com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;\nimport java.util.ArrayList;\nimport java.util.List;\n/**\n * @Author Wiener\n * @Date 2025-12-11\n * @Description: 设置限流规则\n */\npublic class FlowRules {\n    /**\n     * 入门版限流规则\n     * @param resourceName\n     */\n    public static void initFlowRules(String resourceName) {\n        List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;();\n        FlowRule rule = new FlowRule();\n        rule.setResource(resourceName);\n        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);\n        rule.setCount(3); // 设置 QPS 为 3\n        rules.add(rule);\n        FlowRuleManager.loadRules(rules);\n    }\n}\n</code></pre>\n<p>  其中，resource表示资源名，grade表示降级策略。</p>\n<pre><code class=\"language-java\">import com.alibaba.csp.sentinel.annotation.aspectj.SentinelResourceAspect;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @Author Wiener\n * @Description: 加载全局限流配置类\n */\n@Configuration\npublic class SentinelRuleConfig implements InitializingBean {\n    public final static String RESOURCE_QPS_LIMIT = \"my_resource\";\n    @Bean\n    public SentinelResourceAspect sentinelResourceAspect(){\n        return new SentinelResourceAspect();\n    }\n    @Override\n    public void afterPropertiesSet() {\n        FlowRules.initFlowRules(RESOURCE_QPS_LIMIT);\n    }\n}\n</code></pre>\n<p>  类SentinelResourceAspect是让 @SentinelResource 从“注解装饰品”变成“真正限流熔断入口”的关键引擎。如果没有它，@SentinelResource 只是个普通注解，不会做任何限流、熔断或者降级处理，使得Sentinel 只是“库”；如果有了它，Sentinel 才是流量“治理工具”。</p>\n<p>  检查效果。在 Spring Boot 应用启动之前，从下图中 <strong>Modify options</strong> 找到 <strong>Add VM options</strong>设置JVM 启动参数：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1208468/202512/1208468-20251227204830587-941087640.png\" /></p>\n<pre><code class=\"language-java\">-Dcsp.sentinel.dashboard.server=127.0.0.1:8080 -Dproject.name=wiener\n</code></pre>\n<p>  本示例是用于给服务打开限流和监控能力的启动配置。它通过 JVM 启动参数为 Spring Boot 本地服务注入 Sentinel 配置，<code>-Dcsp.sentinel.dashboard.server</code> 指定控制台地址（127.0.0.1:8080），<code>-Dproject.name</code> 于定义当前 Spring Boot 应用在 Sentinel 中的唯一标识名称（指定应用名为 wiener）。控制台通过该名称区分不同服务实例，并按应用维度进行指标统计和流控规则管理。通过上述 JVM 启动参数，Spring Boot 应用即可完成与 Sentinel 控制台的集成，实现服务运行状态可视化和流量治理能力。</p>\n<p>  在服务启动后，多次访问接口 /getFlow1 后可以看到下图所示监控数据：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1208468/202512/1208468-20251227204845513-520055544.png\" /></p>\n<p>从流控规则页面可以查到服务端通过代码配置的限流阈值：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1208468/202512/1208468-20251227204857710-526351230.png\" /></p>\n<p>  我把QPS阈值改为1再刷新Api，限流效果如下：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1208468/202512/1208468-20251227204908389-1499915667.png\" /></p>\n<p>图中【通过QPS】为1，说明控制台配置的限流规则已经下发到服务端。至此，已经完成Spring Boot整合Sentinel 注解@SentinelResource进行限流并从控制台查看限流效果。</p>\n<h3 id=\"统一处理sentinel异常done\">统一处理Sentinel异常|done</h3>\n<p>  Sentinel 支持以下几种规则：流量控制规则、熔断降级规则、系统保护规则、来源访问控制规则和热点参数规则。其所有规则都可以在内存态中动态地查询及修改，修改之后立即生效。默认情况下，触发上述规则时，都会抛出异常到调用方。如果要自定义异常的返回结果，需要实现BlockExceptionHandler接口：</p>\n<pre><code class=\"language-java\">public interface BlockExceptionHandler {\n    /**\n     * 处理请求被限流、降级、授权拦截时抛出的异常：BlockException\n     */\n    void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception;\n}\n</code></pre>\n<p>  BlockException包含很多个子类，分别对应不同的限流场景：</p>\n<table>\n<thead>\n<tr>\n<th>异常</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FlowException</td>\n<td>限流异常</td>\n</tr>\n<tr>\n<td>ParamFlowException</td>\n<td>热点参数限流的异常</td>\n</tr>\n<tr>\n<td>DegradeExceptionn</td>\n<td>熔断降级异常</td>\n</tr>\n<tr>\n<td>AuthorityExceptionn</td>\n<td>授权规则异常</td>\n</tr>\n<tr>\n<td>SystemBlockException</td>\n<td>系统保护规则异常</td>\n</tr>\n</tbody>\n</table>\n<p>  注意，实现BlockExceptionHandler接口的类必须用@Component注解注入到Spring Boot中。统一处理Sentinel异常的代码示例如下：</p>\n<pre><code class=\"language-java\">@Component\npublic class SentinelExceptionHandler implements BlockExceptionHandler {\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception {\n        String msg = \"未知异常\";\n        int status = 429;// 请求过多\n        //异常处理逻辑：根据e异常的类型判断是触发了限流还是降级等，进一步做出不同的处理逻辑\n\n        if (e instanceof FlowException) {\n            msg = \"请求被限流\";\n        } else if (e instanceof ParamFlowException) {\n            msg = \"请求被热点参数限流\";\n        } else if (e instanceof DegradeException) {\n            msg = \"请求被熔断降级\";\n        } else if (e instanceof AuthorityException) {\n            msg = \"没有访问权限\";\n            status = 401;\n        }\n\n        response.setContentType(\"application/json;charset=utf-8\");\n        response.setStatus(status);\n        response.getWriter().write(msg);\n        response.getWriter().println(\"{\\\"msg\\\":\\\"\"+msg+\"\\\", \\\"status\\\":\" + status + \"}\");\n    }\n}\n</code></pre>\n<h3 id=\"结束语\">结束语</h3>\n<p>  以上就是这篇文章的全部内容了，希望本文对道友的学习或者工作能带来一定的帮助，如有疑问请留言交流。<a href=\"https://www.cnblogs.com/east7/\" target=\"_blank\">Wiener</a>在此祝各位生活愉快！工作顺利！</p>\n<h3 id=\"reference\">Reference</h3>\n<ul>\n<li><a href=\"https://github.com/alibaba/Sentinel/wiki/How-to-Use\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/Sentinel/wiki/How-to-Use</a></li>\n<li><a href=\"https://sentinelguard.io/zh-cn/docs/introduction.html\" rel=\"noopener nofollow\" target=\"_blank\">https://sentinelguard.io/zh-cn/docs/introduction.html</a></li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    \n<div><hr /></div>\n<div class=\"aTip\">  读后有收获，小礼物走一走，请作者喝咖啡。</div>\n<div class=\"aTip\">  <img class=\"tipwechat\" src=\"https://common.cnblogs.com/images/wechat.png\" />Buy me a coffee. ☕Get red packets.</div>\n<div class=\"zsdiv\"><div class=\"tipRight\">\n        <img class=\"wechat\" id=\"wechatTips\" src=\"https://files.cnblogs.com/files/east7/tip7.ico\" />\n        <img class=\"wechat\" id=\"redPackets\" src=\"https://blog-static.cnblogs.com/files/east7/11.ico\" />\n</div></div>\n<div>作者：<a href=\"https://www.cnblogs.com/east7/\" target=\"_blank\">楼兰胡杨</a></div>\n<div>链接：<a href=\"https://www.cnblogs.com/east7/p/19409978\" target=\"_blank\">https://www.cnblogs.com/east7/p/19409978</a></div>\n<div>本文版权归作者和博客园共有，欢迎转载，但请注明原文链接，并保留此段声明，否则保留追究法律责任的权利。</div>\n        \n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-27 20:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/east7\">楼兰胡杨</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}