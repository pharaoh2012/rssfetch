{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "FFmpeg开发笔记（九十七）国产的开源视频剪辑工具AndroidVideoEditor",
      "link": "https://www.cnblogs.com/aqi00/p/19376106",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19376106\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 12:19\">\n    <span>FFmpeg开发笔记（九十七）国产的开源视频剪辑工具AndroidVideoEditor</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span><span>​</span></span>《FFmpeg开发实战：从零基础到短视频上线》一书的“第 12 章 &nbsp;FFmpeg的移动开发”介绍了如何使用FFmpeg在手机上剪辑视频，方便开发者更好地开发类似剪映那样的视频剪辑软件。那么在Android系统上还有一款国产的开源视频剪辑框架Android-Video-Editor，通过该框架可以更方便地对视频进行剪辑和滤镜操作，下面就来介绍如何在App工程中使用Android-Video-Editor。\n<p><span id=\"cke_bm_180S\"> Android-Video-Editor是一款Android视频编辑开源工具，主要功能包括视频拍摄、视频裁剪、视频滤镜、视频压缩等等。Android-Video-Editor通过整合其他开源框架实现完整的剪辑功能，比如通过CameraView录制视频，通过VideoEdit编辑视频，通过Mp4Composer封装视频，通过SiliCompressor压缩视频，等等。<br />\nAndroid-Video-Editor的源码托管地址为https://github.com/LLhon/Android-Video-Editor（星星数1.3k），国内的镜像地址为https://gitcode.com/angcyo/Android-Video-Editor。该框架的最近版本更新于2019年4月，对应压缩包的下载地址为https://github.com/LLhon/Android-Video-Editor/archive/refs/heads/master.zip。<br />\n由于Android-Video-Editor源码的发布时间较早，为了让小海豚版本的Android Studio Dolphin能够打开它们，需要对App工程作如下修改：<br />\n1、升级Gradle版本和SDK版本；<br />\n2、把Support库迁移为Androidx库；<br />\n3、移除不适配小海豚版本的butterknife库；<br />\n4、把isoparser库由jar包导入方式改为maven导入方式；<br />\n5、另外修复了若干bug；<br />\n因为上述修改涉及到的内容较多，这里不再一一列出，博主把修改后的App源码上传到了Github，具体地址为https://github.com/aqi00/note/tree/master/Android-Video-Editor。大家可以拉取Github上修改好的Android-Video-Editor源码，就能用小海豚版本的Android Studio Dolphin导入Android-Video-Editor工程了。<br />\n打开Android-Video-Editor工程之后，发现该工程包括下列四个模块：<br />\n1、app模块，负责App界面的交互操作；<br />\n2、video-compressor模块，负责视频的编辑和压缩操作；<br />\n3、video-effect模块，负责视频的封装操作；<br />\n4、video-record模块，负责视频的录制操作；<br />\n那么通过Android Studio Dolphin编译Android-Video-Editor并安装到真机上，点击【相册】后加载系统相册中的所有视频文件，选择一个待加工的视频文件，打开该视频的编辑界面如下图所示：</span></p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"ave1\" class=\"lazyload\" height=\"780\" width=\"364\" /></span></span></span></span></p>\n<p>编辑界面下方可以滑动选择待裁剪的视频片段，点击右下角的【滤镜】按钮，弹出滤镜选择列表如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"ave2\" class=\"lazyload\" height=\"778\" width=\"363\" /></span></span></span></span></p>\n<p>点击列表中的【怀旧】滤镜，编辑界面马上切换成昏黄的怀旧效果如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"ave3\" class=\"lazyload\" height=\"779\" width=\"363\" /></span></span></span></span></p>\n<p>点击右上角的【发布】按钮，App就开始执行对应的加工操作。加工之后的视频片段默认放在App安装路径下的cache目录，完整路径为“我的手机/Android/data/com.marvhong.videoeditor/cache/small_video/VIDEO_yyyymmdd_HHMMSS.mp4”，其中yyyymmdd代表年月日，HHMMSS代表时分秒。<br />\n稍等片刻剪辑完成后，App会自动跳到视频播放界面观看加工好的视频片段。</p>\n<p>更多详细的FFmpeg开发知识参见<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\"><a class=\"cke_widget_editable cke_widget_element\" href=\"https://item.jd.com/14020415.html\" rel=\"noopener nofollow\" title=\"《FFmpeg开发实战：从零基础到短视频上线》\">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</span></p>\n\n<span>\n<span>​</span></span>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 12:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI Agent 的记忆系统：从必要性到工程实践",
      "link": "https://www.cnblogs.com/deep-sky/p/19464845",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/deep-sky/p/19464845\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 12:07\">\n    <span>AI Agent 的记忆系统：从必要性到工程实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"引言\">引言</h3>\n<p>在与 AI Agent 的长时间交互中，你是否遇到过这样的困扰：明明上次已经告诉它你的偏好，但这次它又重新询问？或者在处理复杂任务时，AI 突然\"失忆\"，忘记了之前讨论的关键决策？</p>\n<p>这些问题的根源在于：<strong>AI Agent 缺乏持久化的记忆能力</strong>。而记忆系统的引入，正是为了让 AI 从\"健忘的助手\"进化为\"懂你的伙伴\"。</p>\n<h3 id=\"一为什么要引入记忆\">一、为什么要引入记忆？</h3>\n<h4 id=\"11-上下文的天然局限\">1.1 上下文的天然局限</h4>\n<p>大语言模型（LLM）虽然强大，但它们面临一个根本性约束：<strong>上下文窗口是有限的</strong>。即使最新的模型支持 100 万甚至 200 万 token 的上下文，在实际应用中仍然存在三个关键问题：</p>\n<ol>\n<li><strong>成本问题</strong>：每次对话都携带完整历史记录，计算成本呈线性增长</li>\n<li><strong>效率问题</strong>：上下文越长，推理速度越慢，用户体验下降</li>\n<li><strong>噪音问题</strong>：大量无关信息会干扰模型的判断，降低输出质量</li>\n</ol>\n<h4 id=\"12-用户体验的刚需\">1.2 用户体验的刚需</h4>\n<p>从用户角度看，记忆系统解决了几个核心痛点：</p>\n<ul>\n<li><strong>个性化体验</strong>：记住用户的偏好、习惯和特殊要求</li>\n<li><strong>连续性任务</strong>：在多轮对话或跨会话中保持任务的连贯性</li>\n<li><strong>效率提升</strong>：避免重复性的信息输入和说明</li>\n<li><strong>信任建立</strong>：AI 能记住你说过的话，增强人机信任感</li>\n</ul>\n<h4 id=\"13-复杂任务的必然要求\">1.3 复杂任务的必然要求</h4>\n<p>在代码开发、项目管理等复杂场景中，记忆系统更是不可或缺：</p>\n<ul>\n<li>记住项目的架构决策和设计模式</li>\n<li>跟踪已修复的 bug 和错误模式</li>\n<li>保存用户的编码规范和风格偏好</li>\n<li>维护任务的依赖关系和优先级</li>\n</ul>\n<h3 id=\"二记忆是如何实现的\">二、记忆是如何实现的？</h3>\n<h4 id=\"21-记忆系统的基本架构\">2.1 记忆系统的基本架构</h4>\n<p>在 <strong>Agent 记忆系统（Agent Memory System）</strong> 的设计中，核心目标是：</p>\n<blockquote>\n<p><strong>让 Agent 在长期交互与任务执行中，既能\"记住重要的事\"，又不会被无关信息拖慢或污染推理。</strong></p>\n</blockquote>\n<p>从工程和认知两个维度来看，<strong>Agent 的记忆通常可以分为以下几大类型</strong>，并且在成熟系统中往往是<strong>组合使用</strong>的。</p>\n<hr />\n<h5 id=\"维度一按时间尺度划分最常见最核心\">维度一：按「时间尺度」划分（最常见、最核心）</h5>\n<table>\n<thead>\n<tr>\n<th>记忆类型</th>\n<th>作用</th>\n<th>典型内容</th>\n<th>实现方式</th>\n<th>特点</th>\n<th>重要性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>短期记忆</strong><br />(Short-Term Memory /<br />Working Memory)</td>\n<td>支撑当前一步或几步的推理<br />类似人类的\"工作记忆\"</td>\n<td>• 最近 N 轮对话<br />• 当前任务上下文<br />• 中间推理结果（scratchpad / chain-of-thought 的压缩版）</td>\n<td>• Prompt 中直接拼接<br />• Sliding Window<br />• Recent Messages Buffer</td>\n<td>• 生命周期短<br />• 每次请求都会加载<br />• 成本高（占 token）</td>\n<td><strong>几乎所有 Agent 都有</strong></td>\n</tr>\n<tr>\n<td><strong>中期记忆</strong><br />(Episodic Memory /<br />Session Memory)</td>\n<td>记住\"发生过的事件\"<br />跨多轮任务仍然可用，但不是永久</td>\n<td>• 完成过哪些任务<br />• 用户最近的偏好变化<br />• 上一次失败 / 成功的策略</td>\n<td>• 结构化日志（JSON / DB）<br />• 向量化存储 + 相似度检索<br />• 会话级缓存（Session Store）</td>\n<td>• 可检索<br />• 不每次都加载<br />• 触发式注入上下文</td>\n<td><strong>决定 Agent 是否\"有连续感\"</strong></td>\n</tr>\n<tr>\n<td><strong>长期记忆</strong><br />(Long-Term Memory /<br />Persistent Memory)</td>\n<td>形成\"长期认知\"<br />影响未来决策和行为风格</td>\n<td>• 用户稳定偏好<br />• 固定事实（User Profile）<br />• Agent 自身能力边界、经验总结</td>\n<td>• Key-Value Memory<br />• 文本 + Embedding<br />• 显式 Memory Store（如 Claude / Cursor Memory）</td>\n<td>• 持久化<br />• 写入受控<br />• 读取高度选择性</td>\n<td><strong>最难设计，也最容易\"记坏\"</strong></td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h5 id=\"维度二按内容性质划分比时间更重要\">维度二：按「内容性质」划分（比时间更重要）</h5>\n<table>\n<thead>\n<tr>\n<th>记忆类型</th>\n<th>存储内容</th>\n<th>典型例子</th>\n<th>实现方式</th>\n<th>特点</th>\n<th>评价</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>事实性记忆</strong><br />(Semantic /<br />Factual Memory)</td>\n<td>不随时间变化的事实<br />\"是什么\"</td>\n<td>• 用户使用 Java / Python<br />• 项目技术栈<br />• 业务规则</td>\n<td>结构化存储</td>\n<td>• 低频写，高频读<br />• 适合结构化存储</td>\n<td><strong>最安全、性价比最高的记忆类型</strong></td>\n</tr>\n<tr>\n<td><strong>经验记忆</strong><br />(Procedural /<br />Skill Memory)</td>\n<td>\"怎么做\"<br />成功或失败的策略</td>\n<td>• 解决某类 Bug 的步骤<br />• 某种 Prompt 模板效果很好<br />• 排班问题用 CP-SAT 比 MILP 更稳</td>\n<td>• Rule / Template<br />• Skill 文件<br />• Tool 调用策略</td>\n<td>• 可复用<br />• 高价值</td>\n<td><strong>Claude Skills 就是典型代表</strong></td>\n</tr>\n<tr>\n<td><strong>情景记忆</strong><br />(Episodic Memory)</td>\n<td>一次完整事件<br />含上下文、过程、结果</td>\n<td>• \"在 2024-12 的一次排班优化中，因为约束冲突导致模型不可行\"</td>\n<td>向量化存储</td>\n<td>• 高维、非结构化<br />• 用于\"类比推理\"</td>\n<td>用于经验学习和问题诊断</td>\n</tr>\n<tr>\n<td><strong>偏好与风格记忆</strong><br />(Preference /<br />Personality Memory)</td>\n<td>用户偏好<br />表达风格<br />输出习惯</td>\n<td>• 喜欢表格而不是长文<br />• 代码优先于解释<br />• 中文 + 专业术语</td>\n<td>Key-Value 或<br />配置文件</td>\n<td>• 影响交互体验<br />• 需要动态更新</td>\n<td>决定 Agent 的\"个性化\"程度</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h5 id=\"维度三按使用方式划分工程视角\">维度三：按「使用方式」划分（工程视角）</h5>\n<table>\n<thead>\n<tr>\n<th>记忆类型</th>\n<th>定义</th>\n<th>特征</th>\n<th>示例</th>\n<th>优势</th>\n<th>风险</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>显式记忆</strong><br />(Explicit Memory)</td>\n<td>明确写入<br />明确读取<br />有规则、有生命周期</td>\n<td>• 结构化<br />• 可追溯<br />• 用户可见</td>\n<td><code>{\"type\": \"user_preference\", \"key\": \"response_style\", \"value\": \"engineering-oriented\"}</code></td>\n<td>✔ 可控<br />✔ 可调试<br />✔ 可删除</td>\n<td>需要显式管理接口</td>\n</tr>\n<tr>\n<td><strong>隐式记忆</strong><br />(Implicit Memory)</td>\n<td>融入模型权重或 Prompt 模板<br />用户不可见<br />难以删除</td>\n<td>• 不可见<br />• 难以修改<br />• 系统级</td>\n<td>• System Prompt 中的行为约束<br />• 微调模型的偏置</td>\n<td>不需要额外存储和检索</td>\n<td>⚠️ 风险高<br />⚠️ 不适合个性化长期记忆</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h5 id=\"一个成熟-agent-的记忆组合架构\">一个成熟 Agent 的\"记忆组合架构\"</h5>\n<pre><code class=\"language-text\">┌───────────┐\n│ System    │  ← 角色、规则（几乎不变）\n└────┬──────┘\n     │\n┌────▼──────┐\n│ Short-Term│  ← 最近对话 / 当前任务\n└────┬──────┘\n     │\n┌────▼─────────────┐\n│ Memory Retriever │  ← 向量 / 规则\n└────┬─────────────┘\n     │\n┌────▼──────┐\n│ Long-Term │  ← 事实 / 偏好 / 经验\n└───────────┘\n</code></pre>\n<hr />\n<h5 id=\"关键设计原则非常重要\">关键设计原则（非常重要）</h5>\n<p>1️⃣ <strong>不是记得越多越好</strong></p>\n<p>2️⃣ <strong>写记忆要比读记忆更谨慎</strong></p>\n<p>3️⃣ <strong>事实、偏好、经验必须分层存储</strong></p>\n<p>4️⃣ <strong>记忆必须可解释、可回滚、可过期</strong></p>\n<p>5️⃣ <strong>Agent 失败，80% 是记忆污染</strong></p>\n<hr />\n<h5 id=\"一句话总结\">一句话总结</h5>\n<blockquote>\n<p><strong>Agent 的记忆不是\"聊天记录\"，而是\"可被检索、可被治理的认知资产\"。</strong></p>\n</blockquote>\n<h3 id=\"三引入记忆会带来什么问题\">三、引入记忆会带来什么问题？</h3>\n<h4 id=\"31-上下文容量的权衡\">3.1 上下文容量的权衡</h4>\n<p>虽然记忆系统旨在缓解上下文限制，但它本身也会占用上下文空间：</p>\n<ul>\n<li><strong>记忆注入开销</strong>：每次对话需要注入相关记忆，占用 token</li>\n<li><strong>边际效益递减</strong>：注入的记忆越多，噪音也越大</li>\n<li><strong>检索精度困境</strong>：检索不准确会引入无关记忆，反而降低性能</li>\n</ul>\n<h4 id=\"32-记忆的一致性和准确性\">3.2 记忆的一致性和准确性</h4>\n<ul>\n<li><strong>记忆冲突</strong>：不同时间的记忆可能互相矛盾</li>\n<li><strong>记忆失真</strong>：模型可能错误理解或记录信息</li>\n<li><strong>记忆过时</strong>：用户偏好改变，旧记忆成为干扰</li>\n</ul>\n<h4 id=\"33-隐私和安全问题\">3.3 隐私和安全问题</h4>\n<ul>\n<li><strong>敏感信息泄露</strong>：记忆可能包含用户不希望保留的敏感信息</li>\n<li><strong>记忆污染攻击</strong>：恶意用户可能故意植入误导性记忆</li>\n<li><strong>跨会话泄漏</strong>：不当的记忆管理可能导致信息跨用户泄漏</li>\n</ul>\n<h4 id=\"34-系统复杂度的增加\">3.4 系统复杂度的增加</h4>\n<ul>\n<li><strong>存储成本</strong>：大规模记忆需要持久化存储和索引</li>\n<li><strong>维护成本</strong>：记忆的更新、删除、去重需要额外逻辑</li>\n<li><strong>调试困难</strong>：记忆系统引入新的不确定性，问题排查更复杂</li>\n</ul>\n<h3 id=\"四cursor-记忆工具的设计启示\">四、Cursor 记忆工具的设计启示</h3>\n<p>当我们为 Agent 引入记忆系统之后，一个随之而来的核心问题便是：如何更加合理地使用与维护这些记忆？创建记忆本身并不困难，真正具有挑战性的，是记忆的更新与删除机制。</p>\n<p>一般而言，我们最直观的做法是通过规则来解决这些问题。例如，设定时间窗口或最近对话轮数来筛选可用记忆；在生成新的对话内容后写入记忆，并定期清理过时、低价值的旧记忆。我在实际开发 Agent 时，也基本沿用了这一套思路。这种方式当然谈不上错误，但也很难称得上有什么新意。</p>\n<p>直到我看到 <code>Cursor</code> 在系统提示词中对记忆维护的设计方式——它将“是否保留、如何更新记忆”的决策权，再次交还给了大模型本身。第一次看到这种设计时，我产生了一种很微妙的感受：<strong>一方面觉得“事情本就应该如此”，另一方面又不得不佩服 Cursor 工程师在设计上的大胆与想象力</strong>。</p>\n<p>以下是<code>Cursor</code>系统提示词中对于 <code>memory</code> 部分的描述：</p>\n<pre><code>...\n&lt;memories&gt;\n你可能会得到一份记忆清单。这些记忆是从过去与agent的对话中产生的。它们可能是正确的，也可能是不正确的，所以如果认为相关，请遵循它们，但是当你注意到用户根据记忆更正了你所做的事情，或者遇到一些与现有记忆相矛盾或增加的信息时，你必须立即使用update_memory工具更新/删除记忆。绝对不能使用update_memory工具创建 与 实现计划、代理完成的迁移或其他特定于任务的信息 相关的记忆。\n如果用户曾经反驳过你的记忆，那么最好删除那个记忆，而不是更新它。\n你可以根据工具描述中的标准 创建、更新或删除 记忆\n&lt;memory_citation&gt;\n在生成内容、回复用户查询或执行命令时，你必须始终通过引用的方式使用记忆，引用格式为：[[memory:MEMORY_ID]]。你应将记忆引用自然地融入回复内容中，而非仅作为注释。\n\n例如：“我会使用 -la 标志 [[memory:MEMORY_ID]] 运行该命令，以显示详细的文件信息。”\n\n当你因某条记忆而拒绝用户的明确请求时，必须在对话中提及，如果该记忆有误，用户会纠正你，而你会更新自己的记忆。\n&lt;/memory_citation&gt;\n&lt;/memories&gt;\n...\n\n# Tools\n## functions\n\nnamespace functions {\n...\n\n// 在供AI使用时参考的知识库中创建、更新或删除一条记忆。\n// 如果用户对现有记忆进行了补充完善，你必须使用此工具并将 action 设置为“update（更新）”。\n// 如果用户(的对话)与现有记忆相矛盾，重点是要将此工具与“删除”操作一起使用，而不是“更新”或“创建”。.\n// 要更新或删除已有记忆，必须提供existing_knowledge_id参数。\n// 如果用户要求记住一些东西，保存一些东西，或者创建一个记忆，你必须使用这个工具的动作“创建”。\n// 除非用户明确要求记住或保存某些内容，否则不要使用“创建”操作调用此工具。\n// 如果用户(的对话)与你的记忆相矛盾，那么最好删除这段记忆，而不是更新这段记忆。\ntype update_memory = (_: {\n// 记忆的标题。这可以用来查找和检索以后的记忆。这应该是一个简短的标题，抓住记忆的本质。对于“创建”和“更新”操作这个参数是必需的。\ntitle?: string,\n// 要存储的具体记忆内容。其长度不应超过一个段落。如果该记忆是对先前记忆的更新或与之相矛盾，则不要提及或引用先前的记忆。在执行“create（创建）”和“update（更新）”操作时，此项为必填内容。\nknowledge_to_store?: string,\n// 对知识库执行的操作。若未提供此项，为保证向后兼容性，默认操作设为“create（创建）”。\naction?: \"create\" | \"update\" | \"delete\",\n// 若操作是“update（更新）”或“delete（删除）”，则此项为必填项。是要更新（而非创建新记忆）的现有记忆的ID。\nexisting_knowledge_id?: string,\n}) =&gt; any;\n\n...\n}\n</code></pre>\n<p>通过分析 Cursor 的记忆工具实现，我们可以提炼出几个关键的设计智慧：</p>\n<h4 id=\"41-记忆的不确定性哲学\">4.1 记忆的\"不确定性\"哲学</h4>\n<p>Cursor 开篇即声明：<strong>\"这些记忆可能是正确的，也可能是不正确的\"</strong>。</p>\n<p>这个设计体现了深刻的认知：</p>\n<ul>\n<li>承认 AI 理解的局限性，避免过度自信</li>\n<li>鼓励用户反馈，建立动态修正机制</li>\n<li>记忆应该是辅助判断的参考，而非绝对真理</li>\n</ul>\n<p><strong>工程启示</strong>：记忆系统应该是\"柔性\"的，而非\"刚性\"的规则引擎。</p>\n<h4 id=\"42-引用式使用citation\">4.2 引用式使用（Citation）</h4>\n<p>Cursor 要求 AI 在使用记忆时必须明确引用：<code>[[memory:MEMORY_ID]]</code></p>\n<p>这个设计的价值：</p>\n<ul>\n<li><strong>可追溯性</strong>：用户知道 AI 的决策基于哪条记忆</li>\n<li><strong>可纠错性</strong>：用户发现问题时可以精确定位需要修正的记忆</li>\n<li><strong>透明度</strong>：增强人机交互的透明度和信任</li>\n</ul>\n<p><strong>类比</strong>：就像学术论文的引用机制，让知识的来源清晰可查。</p>\n<h4 id=\"43-避免任务型记忆\">4.3 避免\"任务型\"记忆</h4>\n<p>Cursor 明确禁止创建\"与实现计划、迁移等特定任务相关的记忆\"。</p>\n<p><strong>为什么？</strong></p>\n<pre><code>❌ 错误示例：\n记忆：\"用户正在将数据库从 MySQL 迁移到 PostgreSQL\"\n（这是任务状态，会过时）\n\n✅ 正确示例：\n记忆：\"用户偏好使用 PostgreSQL 作为主数据库\"\n（这是长期偏好，不易过时）\n</code></pre>\n<p>任务型信息应该由待办事项（TODO）系统管理，记忆系统专注于持久性的知识和偏好。</p>\n<p><strong>工程启示</strong>：明确区分\"记忆\"与\"状态\"，避免系统功能混淆。</p>\n<h4 id=\"44-冲突处理的删除优先原则\">4.4 冲突处理的\"删除优先\"原则</h4>\n<p>Cursor 特别强调：<strong>\"如果用户曾经反驳过你的记忆，那么最好删除那个记忆，而不是更新它。\"</strong></p>\n<p>这是一个反直觉但极其明智的设计：</p>\n<p><strong>更新的问题</strong>：</p>\n<pre><code>原记忆：\"用户喜欢使用 Vue 框架\"\n用户反驳：\"我现在更喜欢 React\"\n如果更新为：\"用户喜欢使用 Vue 框架，但现在更喜欢 React\"\n→ 产生模糊性，AI 可能困惑\n</code></pre>\n<p><strong>删除的优势</strong>：</p>\n<ul>\n<li>避免记忆内部矛盾</li>\n<li>让 AI 基于当前上下文重新判断</li>\n<li>用户可以选择创建新的明确记忆</li>\n</ul>\n<p><strong>哲学思考</strong>：有时候\"遗忘\"比\"记住\"更重要。</p>\n<h4 id=\"44-工具化的记忆管理\">4.4 工具化的记忆管理</h4>\n<p>在《ClaudeCode为什么这么强大？通过解析其系统提示词一探究竟》一文中，我们指出应该按照结构化语言组织提示词，<code>Cursor</code>系统提示词告诉我们：这种“结构化”的形式除了文档还可以使用伪代码。</p>\n<p>Cursor 将记忆操作封装为标准化的工具接口：</p>\n<pre><code class=\"language-typescript\">type update_memory = {\n    title?: string,                    // 记忆标题\n    knowledge_to_store?: string,       // 记忆内容\n    action?: \"create\" | \"update\" | \"delete\",  // 操作类型\n    existing_knowledge_id?: string,    // 已有记忆 ID\n}\n</code></pre>\n<p><strong>设计优势</strong>：</p>\n<ul>\n<li><strong>可控性</strong>：明确的操作语义，避免隐式记忆生成</li>\n<li><strong>可审计</strong>：所有记忆变更都通过工具调用，可以记录和审计</li>\n</ul>\n<h3 id=\"五claude-code-的记忆压缩策略精准摘要的艺术\">五、Claude Code 的记忆压缩策略：精准摘要的艺术</h3>\n<p>在上一节中，我们分享了 <code>Cursor</code> 在记忆维护机制上所带来的不同视角。本节将转向另一个重量级工具 —— <code>Claude Code</code>。相比之下，<code>Claude Code</code> 面对的是更极端的场景：当上下文窗口用尽时，如何将过去的对话压缩为精准的摘要，既节省 token 又不影响任务的连续性？</p>\n<h4 id=\"51-结构化分析框架\">5.1 结构化分析框架</h4>\n<p>Claude Code 的压缩 prompt 首先要求进行结构化的分析：</p>\n<pre><code>你的任务是对到目前为止的对话进行详细总结，要密切关注用户的明确请求以及你之前采取的行动。\n该总结应全面涵盖技术细节、代码模式和架构决策，这些内容对于在不丢失上下文的情况下继续开展开发工作至关重要。\n\n在提供最终总结之前，将你的分析包裹在 &lt;analysis&gt; 标签中，以组织你的思路并确保你已涵盖所有必要的要点。在你的分析过程中：\n\n1. 按时间顺序分析对话的每条消息和每个部分。对于每个部分，请仔细识别：\n    - 用户的明确请求和意图\n    - 你处理用户请求的方法\n    - 关键决策、技术概念和代码模式\n    - 具体细节，例如：\n        - 文件名\n        - 完整的代码片段\n        - 函数签名\n        - 文件编辑\n    - 你遇到的错误以及你如何修复它们\n    - 特别关注你收到的具体用户反馈，尤其是用户要求你以不同方式做某事的情况。\n2. 仔细检查技术准确性和完整性，彻底处理每个必需的元素。\n\n你的总结应该包括以下几个部分：\n\n1. 主要请求和意图：详细捕获所有用户明确的请求和意图\n2. 关键技术概念：列出讨论的所有重要技术概念、技术和框架。\n3. 文件和代码部分：列举检查、修改或创建的具体文件和代码部分。特别关注最近的消息，如果合适的话，应当包含完整的代码片段，同时总结为什么这个文件读取或编辑很重要。\n4. 错误和修复：列出你遇到的所有错误，以及你如何修复它们。特别关注你收到的具体用户反馈，尤其是用户要求你以不同方式做某事的情况。\n5. 解决问题: 记录已解决的问题和正在进行的故障排除工作。\n6. 用户的所有消息：列出所有非工具结果的用户消息。这些对于理解用户的反馈和变化的意图至关重要。\n7. 待处理任务：概述你被明确要求处理的任何待处理任务。\n8. 当前工作：详细描述在此总结请求之前正在处理的确切内容，特别关注用户和assistant的最新消息。在合适的情况下包含文件名和代码片段。\n9. 可选的下一步：列出与你最近正在进行的工作相关的下一步操作。重要提示：确保这一步与用户的明确请求以及你在此总结请求之前正在处理的任务直接一致。如果你的上一个任务已经完成，那么只有在明确符合用户请求的情况下才列出下一步。在未与用户确认之前，不要开始处理无关的请求。\n   如果有下一步操作，请包含最近对话中的直接引用，准确显示你正在处理什么任务以及你停在哪里。这应该是逐字引用，以确保任务解释不会偏离。\n\n你的输出应该是结构化的，以下是一个结构化输出的示例：\n\n&lt;example&gt;\n&lt;analysis&gt;\n[你的思考过程，确保所有要点都被全面准确地涵盖]\n&lt;/analysis&gt;\n\n&lt;summary&gt;\n1. 主要请求和意图:\n   [详细描述]\n2. 关键技术概念:\n    - [概念 1]\n    - [概念 2]\n    - [...]\n3. 文件和代码部分:\n    - [文件名 1]\n        - [总结为什么这个文件很重要]\n        - [对该文件所做更改的总结（如果有）]\n        - [重要代码段]\n    - [文件名 2]\n        - [重要代码段]\n    - [...]\n4. 错误和修复:\n    - [错误1的详细描述]:\n        - [如何修复这个错误]\n        - [用户对错误的反馈（如果有）]\n    - [...]\n5. 解决问题:\n   [描述已解决的问题和正在进行的故障排除]\n6. 用户的所有消息:\n    - [详细的用户消息]\n    - [...]\n7. 待处理任务:\n    - [Task 1]\n    - [Task 2]\n    - [...]\n8. 当前工作:\n   [当前工作的精确描述]\n9. 可选的下一步:\n   [可选的下一步要采取的步骤]\n\n&lt;/summary&gt;\n&lt;/example&gt;\n\n请根据到目前为止的对话提供你的总结，遵循这个结构，并确保你的回答准确和彻底。\n\n在所包含的上下文中可能会提供额外的指示。如果是这样，请记住在创建上述总结时遵循以下说明。说明的例子包括：\n&lt;example&gt;\n## Compact Instructions\n在总结对话时，重点关注 TypeScript 代码更改，同时记住你犯的错误以及你如何修复它们。\n&lt;/example&gt;\n\n&lt;example&gt;\n## Summary instructions\n当你使用compact进行总结时 - 请专注于测试输出和代码更改。包括文件逐字读取。\n&lt;/example&gt;\n</code></pre>\n<h4 id=\"52-九维度摘要模型\">5.2 九维度摘要模型</h4>\n<p>Claude Code 将对话压缩为 9 个维度（重点是前8个维度，通常称为8段式压缩）：</p>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>目的</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. 主要请求和意图</td>\n<td>捕获用户的核心诉求</td>\n<td>\"用户要求实现用户认证系统\"</td>\n</tr>\n<tr>\n<td>2. 关键技术概念</td>\n<td>保留技术决策上下文</td>\n<td>\"JWT、OAuth2.0、bcrypt 密码加密\"</td>\n</tr>\n<tr>\n<td>3. 文件和代码部分</td>\n<td>精确定位修改位置</td>\n<td>\"<code>auth.py</code>: 实现了 <code>hash_password()</code> 函数\"</td>\n</tr>\n<tr>\n<td>4. 错误和修复</td>\n<td>避免重复犯错</td>\n<td>\"ImportError: 缺少 pyjwt 依赖，已添加到 requirements.txt\"</td>\n</tr>\n<tr>\n<td>5. 解决问题</td>\n<td>跟踪问题状态</td>\n<td>\"已解决：登录超时问题；进行中：邮件验证功能\"</td>\n</tr>\n<tr>\n<td>6. 用户的所有消息</td>\n<td>保留用户的原始意图</td>\n<td>\"用户说：'密码必须支持特殊字符'\"</td>\n</tr>\n<tr>\n<td>7. 待处理任务</td>\n<td>确保任务连续性</td>\n<td>\"待实现：邮件验证、密码重置功能\"</td>\n</tr>\n<tr>\n<td>8. 当前工作</td>\n<td>精确恢复工作现场</td>\n<td>\"正在修改 <code>user_model.py</code> 的第 45-60 行，添加邮箱验证逻辑\"</td>\n</tr>\n<tr>\n<td>9. 可选的下一步</td>\n<td>提供上下文感知的建议</td>\n<td>\"下一步：测试邮箱验证流程，然后实现密码重置\"</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"53-保留用户原始消息的重要性\">5.3 保留用户原始消息的重要性</h4>\n<p>特别值得注意的是<strong>第 6 点：用户的所有消息</strong>。</p>\n<p>为什么要单独保留用户的原始消息？</p>\n<ol>\n<li><strong>意图的准确性</strong>：AI 的理解可能有偏差，用户原话是最可靠的参考</li>\n<li><strong>细节的完整性</strong>：用户可能提到了 AI 认为不重要但实际关键的细节</li>\n<li><strong>纠错的可能性</strong>：当发现理解偏差时，可以回溯到原始需求</li>\n</ol>\n<p><strong>案例对比</strong>：</p>\n<pre><code>❌ 只保留 AI 的理解：\n\"用户要求优化数据库查询性能\"\n\n✅ 同时保留用户原话：\n\"用户说：'首页加载太慢了，能不能优化一下？我看日志里有很多数据库查询。'\"\n\n→ 原始消息提供了更丰富的上下文：\n   - 问题表现：首页加载慢\n   - 问题线索：日志中的查询\n   - 用户语气：非技术用户\n</code></pre>\n<h4 id=\"54-当前工作的精确描述\">5.4 当前工作的精确描述</h4>\n<p><strong>第 8 点：当前工作</strong>的设计体现了对\"工作现场\"的重视。</p>\n<p>Claude Code 要求：</p>\n<ul>\n<li>详细描述在总结请求之前正在处理的确切内容</li>\n<li>在合适的情况下包含文件名和代码片段</li>\n<li>特别关注用户和 assistant 的最新消息</li>\n</ul>\n<p><strong>实际效果</strong>：</p>\n<pre><code>当前工作：\n正在修改 `solve/employee_timegrid_solve.py` 文件。\n已经添加了 `EmployeeTimegridSolver` 类（第 50-120 行），\n实现了以下方法：\n  - `__init__()`: 初始化求解器\n  - `create_model()`: 创建 CP-SAT 模型\n  - `add_constraints()`: 添加约束条件\n\n最后一步是在第 115 行添加目标函数优化逻辑，\n用户特别强调要优化员工的工作时间均衡性。\n\n代码片段：\n```python\ndef add_objective(self) -&gt; None:\n    # 正在实现中...\n    pass\n</code></pre>\n<p>这种精确描述确保了在新的上下文窗口中，AI 能够无缝地继续工作，不会出现\"我们刚才做到哪了？\"的困惑。</p>\n<h4 id=\"55-技术细节的取舍原则\">5.5 技术细节的取舍原则</h4>\n<p>Claude Code 强调\"彻底处理每个必需的元素\"，但什么是\"必需\"的？</p>\n<p><strong>保留的细节</strong>：</p>\n<ul>\n<li>完整的文件路径：<code>solve/employee_timegrid_solve.py</code></li>\n<li>具体的函数签名：<code>def create_model(self, employees: List[Employee]) -&gt; CpModel</code></li>\n<li>关键的代码片段：实现的核心逻辑</li>\n<li>精确的错误信息：<code>ImportError: No module named 'ortools'</code></li>\n</ul>\n<p><strong>可以省略的细节</strong>：</p>\n<ul>\n<li>重复性的调试输出</li>\n<li>中间状态的临时代码</li>\n<li>已经完全解决且不会再出现的问题</li>\n</ul>\n<p><strong>取舍原则</strong>：如果这个细节的缺失会导致后续无法继续工作，就必须保留；如果只是过程性信息，可以概括或省略。</p>\n<h4 id=\"56-错误驱动的学习机制\">5.6 错误驱动的学习机制</h4>\n<p><strong>第 4 点：错误和修复</strong>是一个被低估但极其重要的设计。</p>\n<p>AI Agent 在工作中会犯错，关键是如何从错误中学习：</p>\n<pre><code>错误和修复：\n1. ImportError: No module named 'ortools'\n   - 原因：requirements.txt 中缺少依赖\n   - 修复：添加 `ortools&gt;=9.6.0`\n   - 用户反馈：建议锁定版本避免兼容性问题\n\n2. 求解器返回 INFEASIBLE\n   - 原因：员工可用时间约束与需求时间窗口冲突\n   - 修复：放宽了部分软约束，改为惩罚项\n   - 用户反馈：满意，但要求输出冲突原因\n\n3. 性能问题：求解器运行超过 5 分钟\n   - 原因：变量数量过多（10000+）\n   - 修复：引入分层求解，先优化关键班次\n   - 用户反馈：运行时间降到 30 秒，符合预期\n</code></pre>\n<p>这种错误记录的价值：</p>\n<ul>\n<li><strong>避免重复犯错</strong>：同类问题有了解决模式</li>\n<li><strong>用户反馈的宝贵性</strong>：用户的修正意见是最重要的记忆</li>\n<li><strong>问题诊断的速度</strong>：遇到类似问题时有历史参考</li>\n</ul>\n<h4 id=\"57-下一步行动的上下文一致性\">5.7 下一步行动的上下文一致性</h4>\n<p><strong>第 9 点：可选的下一步</strong>有一个重要的约束：</p>\n<blockquote>\n<p>\"重要提示：确保这一步与用户的明确请求以及你在此总结请求之前正在处理的任务直接一致。如果你的上一个任务已经完成，那么只有在明确符合用户请求的情况下才列出下一步。在未与用户确认之前，不要开始处理无关的请求。\"</p>\n</blockquote>\n<p>这个约束防止了 AI 的\"功能蔓延\"：</p>\n<pre><code>❌ 错误示例：\n当前任务：实现用户登录功能（已完成）\n下一步：实现用户注册、密码重置、邮箱验证、第三方登录...\n\n（AI 自作主张扩展了任务范围）\n\n✅ 正确示例：\n当前任务：实现用户登录功能（已完成）\n下一步：根据用户的原始要求\"实现基本的用户认证\"，登录功能已满足需求。等待用户确认或提出新的要求。\n\n（保持对用户意图的忠实）\n</code></pre>\n<h4 id=\"58-引用的真实性原则\">5.8 引用的真实性原则</h4>\n<p>Claude Code 强调：</p>\n<blockquote>\n<p>\"如果有下一步操作，请包含最近对话中的直接引用，准确显示你正在处理什么任务以及你停在哪里。这应该是逐字引用，以确保任务解释不会偏离。\"</p>\n</blockquote>\n<p><strong>逐字引用</strong>的价值：</p>\n<pre><code>❌ AI 的释义：\n\"用户要求优化算法性能\"\n\n✅ 用户的原话：\n\"能不能让这个排班算法快一点？现在 100 个员工需要跑 10 分钟，太慢了。\"\n\n→ 原话包含的额外信息：\n   - 具体场景：100 个员工\n   - 性能基准：10 分钟\n   - 用户期望：需要更快\n</code></pre>\n<p>逐字引用避免了 AI 在多次转述中逐渐偏离用户的原始意图。</p>\n<h3 id=\"六-最终思考\">六 最终思考</h3>\n<p>AI Agent 的记忆系统，本质上是在解决<strong>连续性</strong>和<strong>个性化</strong>的问题。它让 AI 从一个无状态的函数调用，进化为一个有\"经历\"、有\"学习能力\"的智能体。</p>\n<p>但我们必须认识到，<strong>记忆系统不是银弹</strong>：</p>\n<ul>\n<li>它不能替代清晰的用户表达和良好的上下文设计</li>\n<li>它会引入新的复杂度和潜在错误</li>\n<li>它需要持续的维护和优化</li>\n</ul>\n<p>真正优秀的记忆系统，应该像一个优秀的助手：</p>\n<ul>\n<li><strong>记住该记的</strong>：关键决策、用户偏好、错误教训</li>\n<li><strong>忘记该忘的</strong>：过时信息、临时状态、错误记忆</li>\n<li><strong>知道何时求助</strong>：不确定时主动向用户确认</li>\n</ul>\n<p>从 Cursor 的\"引用式记忆\"到 Claude Code 的\"结构化压缩\"，我们看到了不同场景下的设计智慧。但更重要的是背后的设计哲学：</p>\n<blockquote>\n<p><strong>以用户为中心，以反馈为驱动，以透明为原则，以价值为导向。</strong></p>\n</blockquote>\n<p>在 AI Agent 日益成为我们工作伙伴的今天，记忆系统的优劣，将直接决定人机协作的效率和体验。希望本文的分析能为你设计或使用 AI Agent 提供有价值的参考。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 12:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/deep-sky\">DeepSky丶</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【Azure Redis】客户端应用使用 Azure Redis Cluster 报错 java.security.cert.CertificateException: No subject alternative names matching IP address xxx.xxx.xxx.xxx found",
      "link": "https://www.cnblogs.com/lulight/p/19464831",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19464831\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 12:02\">\n    <span>【Azure Redis】客户端应用使用 Azure Redis Cluster 报错 java.security.cert.CertificateException: No subject alternative names matching IP address xxx.xxx.xxx.xxx found</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>问题描述</h1>\n<p>使用Azure Cache for Redis的集群模式。应用客户端为Java代码，使用Lettuce 作为Redis 客户端SDK。启动项目报错：<span style=\"color: rgba(255, 0, 0, 1);\"><strong><span style=\"font-style: italic; background-color: initial;\">Caused by: java.security.cert.CertificateException: No subject alternative names matching IP address 159.27.xxx.xxx found。</span></strong></span></p>\n<h2><span style=\"color: rgba(0, 0, 0, 1);\"><strong><span style=\"background-color: initial;\">运行时的错误截图</span></strong></span></h2>\n<p><img alt=\"image\" class=\"lazyload\" height=\"435\" width=\"666\" /></p>\n<h2>示例代码</h2>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.lbazureredis;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.RedisURI;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.RedisClusterClient;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Main {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> main(String[] args) {\n        \n        System.out.println(</span>\"Hello world! This is Redis Cluster example.\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        \n        RedisURI redisUri </span>= RedisURI.Builder.redis(\"&lt;yourredisname&gt;.redis.cache.chinacloudapi.cn\", 6380<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPassword(</span>\"&lt;your redis access key&gt;\").withSsl(<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">).build();\n        RedisClusterClient clusterClient </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> RedisClusterClient.create(redisUri);\n        StatefulRedisClusterConnection</span>&lt;String, String&gt; connection =<span style=\"color: rgba(0, 0, 0, 1);\"> clusterClient.connect();\n        RedisAdvancedClusterCommands</span>&lt;String, String&gt; syncCommands =<span style=\"color: rgba(0, 0, 0, 1);\"> connection\n                .sync();\n\n        String pingResponse </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> syncCommands.ping();\n        System.out.println(</span>\"Ping response: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> pingResponse);\n\n        syncCommands.set(</span>\"mykey\", \"Hello, Redis Cluster!\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        String value </span>= syncCommands.get(\"mykey\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        System.out.println(</span>\"Retrieved value: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> value);\n        \n        connection.close();\n        clusterClient.shutdown();\n\n    }\n}</span></pre>\n</div>\n<h2>项目POM.xml</h2>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">&lt;?</span><span style=\"color: rgba(255, 0, 255, 1);\">xml version=\"1.0\" encoding=\"UTF-8\"</span><span style=\"color: rgba(0, 0, 255, 1);\">?&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">project </span><span style=\"color: rgba(255, 0, 0, 1);\">xmlns</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"http://maven.apache.org/POM/4.0.0\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n         xmlns:xsi</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"http://www.w3.org/2001/XMLSchema-instance\"</span><span style=\"color: rgba(255, 0, 0, 1);\">\n         xsi:schemaLocation</span><span style=\"color: rgba(0, 0, 255, 1);\">=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">modelVersion</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>4.0.0<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">modelVersion</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>com.lbazureredis<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>test<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>1.0-SNAPSHOT<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">properties</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.source</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>17<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.source</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.target</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>17<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">maven.compiler.target</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">properties</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">dependencies</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> Lettuce Redis Client </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>io.lettuce<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>lettuce-core<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>6.3.1.RELEASE<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> SLF4J for logging </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>org.slf4j<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>slf4j-simple<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>2.0.9<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">dependencies</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n\n<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">project</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span></pre>\n</div>\n<p><span style=\"font-size: 18px; color: rgba(255, 0, 0, 1);\"><strong>针对以上问题，如何解决呢？</strong></span></p>\n<p>&nbsp;</p>\n<h1>问题解答</h1>\n<p>根据错误信息搜索后，得到Azure官方最佳实践文档中的解答：<a href=\"https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md</a></p>\n<blockquote>\n<p>The reason this is required is because SSL certification validates the address of the Redis Nodes with the SAN (Subject Alternative Names) in the SSL certificate. <strong>Redis protocol requires that these node addresses should be IP addresses.</strong> However, the SANs in<strong> the Azure Redis SSL certificates contains only the Hostname</strong> since Public IP addresses can change and as a result not completely secure.</p>\n<p>在Redis Protocol验证中，必须验证证书中包含IP地址，但由于Azure Redis部署在云环境中，IP地址是不固定的。所以默认情况下，Redis SSL证书中包含的是域名。为了解决这个问题，需要建立一个Host与IP地址的映射关系，使得Lettuce客户端在验证Redis证书时通过域名验证而非IP地址，用于解决<strong>No subject alternative names matching IP address 159.27.xxx.xxx found </strong>问题</p>\n</blockquote>\n<p>参考文档中的方法，自定义<strong><code>MappingSocketAddressResolver</code></strong></p>\n<div class=\"cnblogs_code\">\n<pre>        Function&lt;HostAndPort, HostAndPort&gt; <span style=\"background-color: rgba(255, 204, 0, 1);\">mappingFunction</span> = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Function&lt;HostAndPort, HostAndPort&gt;<span style=\"color: rgba(0, 0, 0, 1);\">() {\n            @Override\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort apply(HostAndPort hostAndPort) {\n                String cacheIP </span>= \"\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                    InetAddress[] addresses </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DnsResolvers.JVM_DEFAULT.resolve(host);\n                    cacheIP </span>= addresses[0<span style=\"color: rgba(0, 0, 0, 1);\">].getHostAddress();\n                } </span><span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (UnknownHostException e) {\n                    e.printStackTrace();\n                }\n                HostAndPort finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> hostAndPort;\n\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (hostAndPort.hostText.equals(cacheIP))\n                    finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort.of(host, hostAndPort.getPort());\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> finalAddress;\n            }\n        };\n\n        <span style=\"background-color: rgba(255, 204, 0, 1);\">MappingSocketAddressResolver</span> resolver </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MappingSocketAddressResolver.create(DnsResolvers.JVM_DEFAULT,\n                mappingFunction);\n        <span style=\"background-color: rgba(255, 204, 0, 1);\">ClientResources</span> res </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DefaultClientResources.builder()\n                .socketAddressResolver(resolver).build();\n        RedisURI redisURI </span>= RedisURI.Builder.redis(host).withSsl(<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPassword(password)\n                .withClientName(</span>\"LettuceClient\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPort(</span>6380<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .build();\n        RedisClusterClient redisClient </span>= RedisClusterClient.create(<span style=\"background-color: rgba(255, 204, 0, 1);\">res</span>, redisURI);</pre>\n</div>\n<h2>代码解读</h2>\n<blockquote>\n<h3>mappingFunction</h3>\n<ul>\n<li>它是一个自定义的地址映射逻辑，用于处理 Lettuce 在连接 Redis 集群时的主机名与 IP 地址问题。</li>\n<li>它通过 DnsResolvers.JVM_DEFAULT 对指定的域名进行 DNS 解析，获取对应的 IP 地址。如果当前 HostAndPort 的 hostText 与解析出的 IP 相同，则将其替换为原始域名 host，保持端口不变。</li>\n<li>这一逻辑的核心目的是解决 SSL 证书校验问题，因为证书通常绑定域名而非 IP，确保连接时使用域名进行验证，避免因 IP 导致的握手失败。</li>\n</ul>\n<h3>MappingSocketAddressResolver</h3>\n<ul>\n<li>它是 Lettuce 提供的一个工具类，用于在连接 Redis 时插入自定义的地址解析逻辑。</li>\n<li>它结合默认的 DNS 解析器和 mappingFunction，在每次解析 Socket 地址时执行映射操作。</li>\n<li>通过这种方式，客户端可以在 DNS 解析后对结果进行二次处理，例如将 IP 地址重新映射为域名。</li>\n<li>这对于云服务场景（如 Azure Redis）非常重要，因为这些服务的 SSL 证书通常只对域名有效，而不是 IP 地址。</li>\n</ul>\n<h3>DefaultClientResources</h3>\n<ul>\n<li><span style=\"background-color: initial; font-size: 14px;\">作为 Lettuce 的核心资源管理器，用于配置客户端的底层行为，包括线程池、DNS 解析器、事件循环等。在这里，它的作用是将自定义的 MappingSocketAddressResolver 注入到客户端资源中，使所有连接请求都遵循自定义的地址解析逻辑。</span></li>\n<li><span style=\"background-color: initial; font-size: 14px;\">通过这种方式，整个 Lettuce 客户端在连接 Redis 集群时都会使用域名而非 IP，确保 SSL 校验通过，同时保持连接的稳定性和安全性。</span></li>\n</ul>\n</blockquote>\n<p>&nbsp;</p>\n<h2>执行结果</h2>\n<p>再次运行，成功连接到Azure Redis Cluster 及执行Ping, Set, Get指令！</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"541\" width=\"999\" /></p>\n<h2>修改后完整的Java示例代码如下：</h2>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">package</span><span style=\"color: rgba(0, 0, 0, 1);\"> com.lbazureredis;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.net.InetAddress;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.net.UnknownHostException;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.time.Duration;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.function.Function;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.RedisURI;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.SocketOptions;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.api.StatefulRedisConnection;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.ClusterClientOptions;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.ClusterTopologyRefreshOptions;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.RedisClusterClient;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.async.RedisAdvancedClusterAsyncCommands;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.internal.HostAndPort;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.ClientResources;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.DefaultClientResources;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.DnsResolvers;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> io.lettuce.core.resource.MappingSocketAddressResolver;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> Main {\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">static</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> main(String[] args) {\n\n        System.out.println(</span>\"Hello world! This is Redis Cluster example.\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n\n        String host </span>= \"&lt;yourredisname&gt;.redis.cache.chinacloudapi.cn\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n        String password </span>= \"&lt;your redis access key&gt;\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n\n        Function</span>&lt;HostAndPort, HostAndPort&gt; <span style=\"background-color: rgba(255, 204, 0, 1);\">mappingFunction</span> = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Function&lt;HostAndPort, HostAndPort&gt;<span style=\"color: rgba(0, 0, 0, 1);\">() {\n            @Override\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort apply(HostAndPort hostAndPort) {\n                String cacheIP </span>= \"\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\"> {\n                    InetAddress[] addresses </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DnsResolvers.JVM_DEFAULT.resolve(host);\n                    cacheIP </span>= addresses[0<span style=\"color: rgba(0, 0, 0, 1);\">].getHostAddress();\n                } </span><span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (UnknownHostException e) {\n                    e.printStackTrace();\n                }\n                HostAndPort finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> hostAndPort;\n\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (hostAndPort.hostText.equals(cacheIP))\n                    finalAddress </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> HostAndPort.of(host, hostAndPort.getPort());\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> finalAddress;\n            }\n        };\n\n        MappingSocketAddressResolver resolver </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> MappingSocketAddressResolver.create(DnsResolvers.JVM_DEFAULT,\n                <span style=\"background-color: rgba(255, 204, 0, 1);\">mappingFunction</span>);\n        ClientResources res </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> DefaultClientResources.builder()\n                .socketAddressResolver(resolver).build();\n        RedisURI redisURI </span>= RedisURI.Builder.redis(host).withSsl(<span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPassword(password)\n                .withClientName(</span>\"LettuceClient\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .withPort(</span>6380<span style=\"color: rgba(0, 0, 0, 1);\">)\n                .build();\n        RedisClusterClient redisClient </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> RedisClusterClient.create(<span style=\"background-color: rgba(255, 204, 0, 1);\">res</span>, redisURI);\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Cluster specific settings for optimal reliability.</span>\n        ClusterTopologyRefreshOptions refreshOptions =<span style=\"color: rgba(0, 0, 0, 1);\"> ClusterTopologyRefreshOptions.builder()\n                .enablePeriodicRefresh(Duration.ofSeconds(</span>5<span style=\"color: rgba(0, 0, 0, 1);\">))\n                .dynamicRefreshSources(</span><span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                .adaptiveRefreshTriggersTimeout(Duration.ofSeconds(</span>5<span style=\"color: rgba(0, 0, 0, 1);\">))\n                .enableAllAdaptiveRefreshTriggers().build();\n        redisClient.setOptions(ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder()\n                        .keepAlive(</span><span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n                        .build())\n                .topologyRefreshOptions(refreshOptions).build());\n                \n        StatefulRedisClusterConnection</span>&lt;String, String&gt; connection =<span style=\"color: rgba(0, 0, 0, 1);\"> redisClient.connect();\n        RedisAdvancedClusterCommands</span>&lt;String, String&gt; syncCommands =<span style=\"color: rgba(0, 0, 0, 1);\"> connection.sync();\n        RedisAdvancedClusterAsyncCommands</span>&lt;String, String&gt; asyncCommands =<span style=\"color: rgba(0, 0, 0, 1);\"> connection.async();\n\n        String pingResponse </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> syncCommands.ping();\n        System.out.println(</span>\"Ping response: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> pingResponse);\n\n        syncCommands.set(</span>\"mykey\", \"Hello, Redis Cluster!\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        String value </span>= syncCommands.get(\"mykey\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        System.out.println(</span>\"Retrieved value: \" +<span style=\"color: rgba(0, 0, 0, 1);\"> value);\n\n        connection.close();\n\n        redisClient.shutdown();\n\n    }\n}</span></pre>\n</div>\n<h2>代码流程图</h2>\n<p>基于AI模型解读以上代码后，分析出来的代码流程图</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"256\" width=\"666\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1>参考资料</h1>\n<div class=\"markdown-heading\" dir=\"auto\">\n<p class=\"heading-element\" dir=\"auto\">Best Practices for using Azure Cache for Redis with Lettuce ：<a href=\"https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md</a></p>\n<div>&nbsp;</div>\n<a class=\"anchor\" href=\"https://github.com/Azure/AzureCacheForRedis/blob/main/Lettuce%20Best%20Practices.md#best-practices-for-using-azure-cache-for-redis-with-lettuce\" id=\"user-content-best-practices-for-using-azure-cache-for-redis-with-lettuce\" rel=\"noopener nofollow\"></a></div>\n</div>\n<div id=\"MySignature\">\n    <div style=\"background: #1c5f55; height: 36px; width: 618px; padding: 14px 5px 0px 3px;\">\n  <p style=\"font-weight: bold; color: white;\">当在复杂的环境中面临问题，格物之道需：浊而静之徐清，安以动之徐生。 云中，恰是如此!</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 12:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lulight\">路边两盏灯</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "棒棒糖图：当条形图遇上极简美学",
      "link": "https://www.cnblogs.com/wang_yb/p/19464212",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19464212\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 08:42\">\n    <span>棒棒糖图：当条形图遇上极简美学</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>棒棒糖图</strong>（Lollipop Chart）可以看作是条形图的一种“轻盈版”变体：它用一根从基准线延伸出来的“棒”，并在末端以一个“糖”（圆点）来表示数值，取代了传统的矩形条。</p>\n<p>这种图表传达的信息与条形图是一样的，但它更注重突出数据点的位置，整体看起来更加清新、现代。</p>\n<p>今天，我们一起探索棒棒糖图的优势，并通过代码实现，亲手打造一个属于自己的棒棒糖图！</p>\n<h1 id=\"设计原理\">设计原理</h1>\n<p>设计棒棒糖图的初衷有两个方面：</p>\n<p>首先，通过减少图形中的“墨水”使用量，在面对大量类别或数值普遍较高的情况下，避免了条形图过于密集可能带来的<strong>视觉压迫感</strong>和<strong>杂乱无章</strong>的感觉；</p>\n<p>其次，这样的设计能够更好地引导观察者的注意力集中在各个数据点的具体位置及其之间的差异上，非常适合用来进行排名或者对比分析。</p>\n<p><strong>棒棒糖图</strong>与<strong>条形图</strong>在功能上是等价的，也并不总是优于条形图。</p>\n<p>当处理大量类别、条柱非常高且相互之间距离较近的数据时，棒棒糖图会显得更加易于阅读理解；</p>\n<p>然而，在需要强调绝对数量或是希望获得最为直观长度比较的情况下，条形图依然是更好的选择。</p>\n<h1 id=\"实现原理\">实现原理</h1>\n<p><strong>棒棒糖图</strong>在<code>matplotlib</code>库中没有直接对应的类。</p>\n<p>不过，它的实现原理非常简单，通过组合使用 <code>matplotlib</code> 中的两个基本绘图功能就可以实现：</p>\n<ol>\n<li><strong>绘制线条</strong> (<code>plt.vlines</code>)：这是构成棒棒糖“棍子”部分的关键。</li>\n</ol>\n<p><code>plt.vlines</code> 函数用于在图表上绘制垂直线段。通过指定每个数据点的 x 坐标、线条的起始点（通常是 0）和结束点（即对应数据的 y 值），就可以画出从 x 轴延伸到数据值的线条。</p>\n<ol start=\"2\">\n<li><strong>绘制圆点</strong> (<code>plt.scatter</code>)：这是构成棒棒糖“糖”部分的关键。</li>\n</ol>\n<p><code>plt.scatter</code> 函数用于绘制散点图。通过将每个数据点的 x 坐标和 y 坐标（即数据值）作为参数传入，就可以在每条线的顶端绘制一个圆点。</p>\n<p>总的来说，<strong>实现原理</strong>就是：用线条表示数值的大小，用圆点强调数值的终点位置，两者结合就形成了视觉上类似棒棒糖的图表。</p>\n<p>这种组合方式使得图表比实心的条形图更简洁，同时又能清晰地传达数据信息。</p>\n<p>下一节的示例中，将会演示如何使用<code>matplotlib</code>来绘制<strong>棒棒糖图</strong>。</p>\n<h1 id=\"应用示例\">应用示例</h1>\n<p>接下来，让我们通过实际的对比示例，直观地感受棒棒糖图与传统条形图的不同表现。</p>\n<h2 id=\"适合棒棒糖图的场景\">适合棒棒糖图的场景</h2>\n<pre><code class=\"language-python\"># 创建更多类别的测试数据\n# 模拟不同月份中每天的某个指标（例如：每日平均步数，单位：千步）\ndays = [f\"Day {i}\" for i in range(1, 21)]  # 生成 20 天的数据\nnp.random.seed(42)  # 设置随机种子，确保每次运行结果一致\n# 生成 1 到 5 之间的随机数值作为示例数据\nvalues = np.round(np.random.uniform(1.0, 5.0, size=len(days)), 1)\n\n# --- 创建子图 ---\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))  # 调整为垂直布局，方便比较\n\n# --- 绘制条形图 (上图) ---\nbars = ax1.bar(days, values, color=\"skyblue\", edgecolor=\"navy\", linewidth=0.7)\nax1.set_title(\"条形图 (Bar Chart) - 每日步数\", fontsize=14)\nax1.set_ylabel(\"数值 (千步)\")\n# ax1.set_xlabel('日期') # x轴标签已在下方图中\nax1.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n# 在条形图上添加数值标签\nfor bar, val in zip(bars, values):\n    height = bar.get_height()\n    ax1.text(\n        bar.get_x() + bar.get_width() / 2.0,\n        height + 0.05,\n        f\"{val}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=8,\n    )  # 标签旋转90度节省空间\n\n# --- 绘制棒棒糖图 (下图) ---\n# 1. 绘制线条\nax2.vlines(x=range(len(days)), ymin=0, ymax=values, color=\"navy\", linewidth=2)\n# 2. 在线条顶部绘制圆点\nax2.scatter(x=range(len(days)), y=values, color=\"red\", s=50, zorder=3)\n# 3. 添加数值标签\nfor i, val in enumerate(values):\n    ax2.text(i, val + 0.1, f\"{val}\", ha=\"center\", va=\"bottom\", fontsize=8)\n\nax2.set_title(\"棒棒糖图 (Lollipop Chart) - 每日步数\", fontsize=14)\nax2.set_ylabel(\"数值 (千步)\")\nax2.set_xlabel(\"日期\")\nax2.set_xticks(range(len(days)))\nax2.set_xticklabels(days, rotation=45, ha=\"right\")  # 旋转x轴标签以便阅读\nax2.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\nax2.set_ylim(0, max(values) * 1.1)\n\n# --- 显示图形 ---\nplt.tight_layout()  # 调整子图间距\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260110084120492-216729079.png\" /></p>\n<p>这个示例使用了20个数据类别（Day 1 到 Day 20）。</p>\n<p>你可以看到，在条形图中，许多蓝色的条形紧密地排列在一起，视觉上显得有些拥挤。</p>\n<p>而在棒棒糖图中，线条和圆点使得数据点之间的关系更加清晰，整体视觉效果更轻盈，更容易比较各个数值的大小和识别模式。</p>\n<h2 id=\"适合传统条形图的场景\">适合传统条形图的场景</h2>\n<pre><code class=\"language-python\"># 创建更适合条形图的测试数据\n# 模拟某公司连续12个月的销售额（单位：万元）\nmonths = [\n    \"1月\",\n    \"2月\",\n    \"3月\",\n    \"4月\",\n    \"5月\",\n    \"6月\",\n    \"7月\",\n    \"8月\",\n    \"9月\",\n    \"10月\",\n    \"11月\",\n    \"12月\",\n]\n# 生成有一定趋势和波动的销售额数据，例如有季节性高峰\nsales = [120, 110, 135, 140, 155, 170, 185, 180, 160, 150, 145, 165]\n\n# --- 创建子图 ---\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))\n\n# --- 绘制条形图 (左图) ---\nbars = ax1.bar(months, sales, color=\"lightsteelblue\", edgecolor=\"black\", linewidth=0.7)\nax1.set_title(\"条形图 (Bar Chart - 月份销售额)\", fontsize=14)\nax1.set_ylabel(\"销售额 (万元)\")\nax1.set_xlabel(\"月份\")\nax1.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n# 在条形图上添加数值标签\nfor bar, s in zip(bars, sales):\n    height = bar.get_height()\n    ax1.text(\n        bar.get_x() + bar.get_width() / 2.0,\n        height + 2,\n        f\"{s}\",\n        ha=\"center\",\n        va=\"bottom\",\n        fontsize=9,\n    )\n\n# --- 绘制棒棒糖图 (右图) ---\nax2.vlines(x=range(len(months)), ymin=0, ymax=sales, color=\"gray\", linewidth=2)\nax2.scatter(x=range(len(months)), y=sales, color=\"coral\", s=50, zorder=3)\nfor i, s in enumerate(sales):\n    ax2.text(i, s + 3, f\"{s}\", ha=\"center\", va=\"bottom\", fontsize=9)\n\nax2.set_title(\"棒棒糖图 (Lollipop Chart - 月份销售额)\", fontsize=14)\nax2.set_ylabel(\"销售额 (万元)\")\nax2.set_xlabel(\"月份\")\nax2.set_xticks(range(len(months)))\nax2.set_xticklabels(months, rotation=45)  # 旋转x轴标签以防重叠\nax2.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\nax2.set_ylim(0, max(sales) * 1.1)\n\n# --- 显示图形 ---\nplt.tight_layout()\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202601/83005-20260110084120515-917001944.png\" /></p>\n<p>在这个示例中，数据代表的是连续的月份，数值本身代表的是销售额，这是一个“量”的概念。</p>\n<p>条形图的实心块能让人立刻感受到哪个月份的销售额更高，整体的分布和对比关系一目了然。</p>\n<p>而棒棒糖图虽然也展示了数据，但线条和圆点的组合在视觉上不如实心条形那样能直接传达“量”的感觉，尤其是在数值差异不是特别巨大时，对比效果会稍逊于条形图。</p>\n<h1 id=\"总结\">总结</h1>\n<p><strong>棒棒糖图</strong>就像数据可视化世界中的\"少即是多\"哲学体现。</p>\n<p>它不是要取代传统条形图，而是为数据可视化工具箱增加了一个有价值的选项。</p>\n<p>就像不同的画笔适合不同的绘画风格，不同的图表类型也适合不同的数据故事。</p>\n<p><strong>棒棒糖图</strong>的真正优势在于它改变了数据的<strong>\"讲述方式\"</strong>。</p>\n<p>它不说：\"这是所有信息，你自己找重点\"，而是说：\"看这里，这些是关键点\"。</p>\n<p>这种焦点导向的特性，使得棒棒糖图在现代快节奏的数据沟通中越来越受欢迎。</p>\n<p>设计可视化时，我们不妨问问自己：我想要观众首先看到什么？如果是精确的数值点和清晰的排名，那么棒棒糖图可能是你的理想选择。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 08:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">74</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Thread 类的基本用法、Java 线程的几种状态",
      "link": "https://www.cnblogs.com/xi-yongqi/p/19463416",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xi-yongqi/p/19463416\" id=\"cb_post_title_url\" title=\"发布于 2026-01-10 00:05\">\n    <span>Thread 类的基本用法、Java 线程的几种状态</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"在java中thread类是多线程编程的核心\">在Java中，Thread类是多线程编程的核心。</h3>\n<h4 id=\"线程创建-thread-creation\">线程创建 (Thread Creation)</h4>\n<ul>\n<li>创建线程主要有两种逻辑：继承Thread类或实现Runnable接口。\n<ul>\n<li>方式1：继承 Thread 类，重写run()</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-java\">// 自定义线程类继承Thread\nclass MyThread extends Thread {\n    // 重写run()，定义线程执行逻辑\n    @Override\n    public void run() {\n        System.out.println(\"子线程执行：\" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread t = new MyThread();\n        t.start(); // 3. 调用start()启动线程（不能直接调用run()）\n    }\n}\n</code></pre>\n<ul>\n<li>方式2：实现Runnable接口，传给Thread</li>\n</ul>\n<pre><code class=\"language-java\">// 实现Runnable接口\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"子线程执行：\" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\npublic class Demo {\n    public static void main(String[] args) {\n        // 把Runnable实例传给Thread\n        Thread t = new Thread(new MyRunnable());\n        t.start(); // 启动线程\n    }\n}\n</code></pre>\n<h4 id=\"线程中断-thread-interruption\">线程中断 (Thread Interruption)</h4>\n<ul>\n<li>线程中断不是强制停止线程，而是一种协作机制，即给线程发一个“请停止”的信号。</li>\n<li>void interrupt()：标记线程为 “中断状态”</li>\n<li>boolean isInterrupted()：判断线程是否处于中断状态</li>\n<li>若线程在sleep/wait/join时被中断，会抛出InterruptedException，且中断状态会被清除</li>\n</ul>\n<pre><code class=\"language-java\">Thread t = new Thread(() -&gt; {\n    while (!Thread.currentThread().isInterrupted()) { // 检测中断状态\n        System.out.println(\"线程运行中...\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // 捕获中断异常后，中断状态会被清除，需手动终止循环\n            System.out.println(\"线程被中断\");\n            Thread.currentThread().interrupt(); // 重新标记中断（可选）\n            break;\n        }\n    }\n});\nt.start();\n// 主线程1秒后中断子线程\nThread.sleep(1000);\nt.interrupt();\n</code></pre>\n<h4 id=\"线程等待-thread-join\">线程等待 (Thread Join)</h4>\n<ul>\n<li>有时主线程需要等待子线程执行完毕后再继续执行，这时可以使用join()。</li>\n<li>t.join()：当前线程会进入阻塞状态，直到线程t执行结束。</li>\n<li>带参数的 join(long millis)：设置最大等待时间，如果超时线程还没结束，当前线程就不再等待。</li>\n</ul>\n<pre><code class=\"language-java\">Thread t = new Thread(() -&gt; {\n    System.out.println(\"子线程开始执行\");\n    try { Thread.sleep(2000); } catch (InterruptedException e) {}\n    System.out.println(\"子线程执行完毕\");\n});\nt.start();\n\n// 主线程等待t执行完（最多等3秒）\nt.join(3000); \nSystem.out.println(\"主线程继续执行\");\n</code></pre>\n<h4 id=\"线程休眠-thread-sleep\">线程休眠 (Thread Sleep)</h4>\n<ul>\n<li>static void sleep(long millis)：让当前线程暂停指定时间（不会释放锁），抛出InterruptedException</li>\n</ul>\n<pre><code class=\"language-java\">System.out.println(\"开始休眠\");\ntry {\n    Thread.sleep(2000); // 当前线程休眠2秒\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nSystem.out.println(\"休眠结束\");\n</code></pre>\n<h4 id=\"获取线程实例-get-current-instance\">获取线程实例 (Get Current Instance)</h4>\n<ul>\n<li>在编写通用代码（尤其是 Runnable 中）时，常需要知道是谁在运行。</li>\n<li>Thread.currentThread()：返回代码当前正在执行的那个线程对象的引用。</li>\n<li>常用操作：获取线程 ID (getId())、获取线程名称 (getName()) 等。</li>\n</ul>\n<pre><code class=\"language-java\">// 获取当前线程（这里是main线程）\nThread mainThread = Thread.currentThread();\nSystem.out.println(\"当前线程名：\" + mainThread.getName()); // 输出\"main\"\n\n// 子线程实例\nThread t = new Thread(() -&gt; {\n    Thread current = Thread.currentThread();\n    System.out.println(\"子线程名：\" + current.getName()); // 输出\"Thread-0\"\n});\nt.start();\n</code></pre>\n<hr />\n<h3 id=\"java线程的几种状态\">Java线程的几种状态</h3>\n<h4 id=\"线程状态一共有几种\">线程状态一共有几种？</h4>\n<ul>\n<li>Java线程共有6种状态：\n<ul>\n<li>NEW (新建)</li>\n<li>RUNNABLE (可运行)</li>\n<li>BLOCKED (阻塞)</li>\n<li>WAITING (等待)</li>\n<li>TIMED_WAITING (超时等待)</li>\n<li>TERMINATED (终止)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"每种状态的含义与切换条件\">每种状态的含义与切换条件</h4>\n<ol>\n<li>NEW (新建)</li>\n</ol>\n<ul>\n<li>含义：创建了线程对象（new Thread()），但尚未调用 start() 方法。</li>\n<li>切换：调用 start() 方法后，进入 RUNNABLE 状态。</li>\n</ul>\n<ol start=\"2\">\n<li>RUNNABLE (可运行)</li>\n</ol>\n<ul>\n<li>含义：Java 将操作系统中的“就绪（Ready）”和“运行中（Running）”两种状态统称为 RUNNABLE。处于该状态的线程可能正在 CPU 上执行，也可能正在等待操作系统分配时间片。</li>\n<li>切换：\n<ul>\n<li>就绪 -&gt; 运行：获得 CPU 时间片。</li>\n<li>运行 -&gt; 就绪：CPU 时间片用完，或主动调用 Thread.yield()。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>BLOCKED (阻塞)</li>\n</ol>\n<ul>\n<li>含义：线程正在等待获取一个排他锁（如进入synchronized 代码块/方法），但该锁目前被其他线程持有。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; BLOCKED：尝试进入 synchronized 区域失败。</li>\n<li>BLOCKED -&gt; RUNNABLE：其他线程释放锁，当前线程成功竞争到锁。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li>WAITING (等待)</li>\n</ol>\n<ul>\n<li>含义：线程处于无限期的等待状态，不会被分配 CPU 时间，必须等待其他线程显式地唤醒。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; WAITING：调用 Object.wait()（不带参数）、Thread.join()（不带参数）或 LockSupport.park()。</li>\n<li>WAITING -&gt; RUNNABLE：其他线程调用 Object.notify()、notifyAll() 或 LockSupport.unpark()。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>TIMED_WAITING (超时等待)</li>\n</ol>\n<ul>\n<li>含义：与 WAITING 类似，但在指定的时间后会自动唤醒，不需要其他线程显式唤醒。</li>\n<li>切换：\n<ul>\n<li>RUNNABLE -&gt; TIMED_WAITING：调用 Thread.sleep(ms)、Object.wait(ms)、Thread.join(ms) 等带时间参数的方法。</li>\n<li>TIMED_WAITING -&gt; RUNNABLE：时间结束，或被提前唤醒（如 notify()）。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"6\">\n<li>TERMINATED (终止)</li>\n</ol>\n<ul>\n<li>含义：线程已经执行完毕（run() 方法正常结束）或因异常退出了执行。</li>\n<li>切换：线程一旦进入此状态，生命周期结束，不可再次启动（再次调用 start() 会抛出异常）。</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-10 00:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xi-yongqi\">我会替风去</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "初识Tauri",
      "link": "https://www.cnblogs.com/-867259206/p/19463606",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/-867259206/p/19463606\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 23:24\">\n    <span>初识Tauri</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简述\">简述</h1>\n<p>Tauri是一个跨平台的开发框架，使用rust开发。前端用前端技术构建用户界面，后端使用rust和平台系统交互。</p>\n<h2 id=\"创建项目\">创建项目</h2>\n<p>可以用Bash/PowerShell/Fish/npm/deno/Cargo等工具创建项目。</p>\n<p>下面以pnpm示例：</p>\n<pre><code class=\"language-bash\">pnpm create tauri-app\n</code></pre>\n<p>后面的步骤和创建前端项目是一样的。根据提示选择前端的语言、框架等等。</p>\n<p>项目目录和前端项目也是一样的，只是多了一个src-tauri目录。</p>\n<p>src-tauri目录下就是rust代码，可以在里面编写供前端调用的方法，或者是给前端发送事件消息。</p>\n<p>界面的开发使用前端技术，可以用react，也可以用vue，或者其他前端框架。与平台系统交互的功能，用rust编写。</p>\n<p>对Web开发者来说，用这个技术可以快速地创建桌面应用。</p>\n<h2 id=\"发布\">发布</h2>\n<p>要打包成桌面应用的话，执行build命令就好。</p>\n<p>继续以pnpm为例：</p>\n<pre><code class=\"language-bash\">pnpm tauri build\n</code></pre>\n<blockquote>\n<p>提示：build之前要先安装rust环境</p>\n</blockquote>\n<p>目前Tauri支持Linux、macOS、Windows、Android、iOS。</p>\n<p>打包后的启动程序在src-tauri/target/release/bundle目录下。执行安装程序，安装好后，就可以打开编写的桌面应用了。</p>\n<h1 id=\"架构\">架构</h1>\n<p><img alt=\"架构\" class=\"lazyload\" />Tauri的核心包含一个Tauri的运行时，tauri-runtime在tauri本身和底层的webview抽象层中充当一个胶水层。</p>\n<p>Tauri使用WRY这个开源库做webview的抽象层。WRY是一个rust编写的webview渲染库，可以支持各种平台的桌面应用。在WRY和tauri-runtime之间，有一个tauri-runtime-wry，这一层为WRY定义了系统级的交互。</p>\n<p>而WRY的下层依赖TAO。TAO是基于winit的一个fork。这是一个rust编写的跨平台的窗口管理类库。支持几乎所有的主流平台，Windows、Linux、Mac OS、Android、iOS……</p>\n<p>最后简单总结：Tauri实现跨平台应用的方式是，实现一个webview的抽象，从而可以用前端技术编写GUI，webview抽象层的底层，则依赖rust的窗口管理类库，调用各个平台系统的webview库。</p>\n<h1 id=\"总结\">总结</h1>\n<p>用rust作后端，使Tauri有很高的性能。但是调用平台系统本身webview的跨平台方式，使GUI在不同平台上的表现不一致，有兼容性问题。</p>\n<p>和electron相比，拥有更小的包体积，因为没有打包chromium，也没有源码泄露之类的风险，性能也更好，还能打包移动端，但是会有兼容性问题，而且后端用rust的话，不如electron好上手，如果不是rust熟手的话。</p>\n<p>和flutter相比，同样有兼容性问题，dart也比rust好学。</p>\n<p>对rust开发者来说，只需要找rust的GUI库就行，没有必要去用前端编写GUI。而对前端开发者来说，rust又增加了开发的学习成本。这个框架，感觉只适合同时会rust的前端熟手。而且只有少数对性能要求较高的场景会需要使用，其他场景electron也不差。如果要开发跨平台的应用，兼容性又是一个问题。实际的产品表现，肯定不如flutter这类框架。</p>\n<p>在前端工具链也越来越多使用rust语言的时候，Tauri这些rust编写的框架也被一些前端开发者所使用。但如果我要开发一个跨平台的应用的话，我觉得自带绘图库的flutter的方案是最佳的。Tauri的兼容性问题，仍不能满足做商业应用的要求，能使用的场景太少了。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 23:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/-867259206\">池月</a>&nbsp;\n阅读(<span id=\"post_view_count\">20</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款基于 .NET 9 构建的企业级 Web RBAC 快速开发框架",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19463583",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19463583\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 23:03\">\n    <span>一款基于 .NET 9 构建的企业级 Web RBAC 快速开发框架</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>今天大姚给大家分享一款基于 .NET 9 构建的企业级、开源 Web RBAC 快速开发框架：RuYiAdmin。</span></p>\n<h2><span>项目介绍</span></h2>\n<p><span>RuYiAdmin 一款基于 .NET 9 构建的企业级、前后端分离、开源（Apache License） Web RBAC 快速开发框架，具有灵活的架构设计和强大的功能，适用于快速开发高性能的企业级应用，具有低代码、跨平台、分布式、多线程和高性能等特色。</span></p>\n<h2><span>适用场景</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><span>企业级后台管理系统：用于企业内部的各种管理任务，如用户管理、权限控制、数据统计等。</span></li>\n<li><span>内容管理系统（CMS）：用于网站内容的创建、编辑、发布和管理。</span></li>\n<li><span>客户关系管理（CRM）系统：帮助企业跟踪和管理客户信息、销售机会和客户服务请求。</span></li>\n</ul>\n<h2><span>主要特点</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><strong>前后端分离：</strong><span>&nbsp;RuYiAdmin 采用前后端分离架构，前端基于VueElementAdmin，使用 Vue2 和 Element UI，后端基于 .NET 9 构建。</span></li>\n<li><strong>代码自动生成：</strong><span>&nbsp;支持一键生成视图层、控制层、服务层、仓储层、领域层和 DTO 业务模型层代码，极大地缩短了开发周期。</span></li>\n<li><strong>多数据库支持：</strong><span>&nbsp;支持多种关系型数据库（如 MySQL、SqlServer、SQLite、Oracle、PostgreSQL、OpenGauss、<span>Kingbase、DM）和非关系型数据库（如 Redis、MongoDB、Elasticsearch、Meilisearch），同时支持动态数据源，以满足不同企业的需求。</span></span></li>\n<li><strong>项目安全性高：</strong><span>&nbsp;支持4A等级认证，满足等保三级要求，支持防 SQL 注入、防 Token 劫持、防接口渗透与抖动，集成RSA、AES及国产 SM 加密算法，支持全链路HTTPS加密传输协议，确保企业级应用的安全性。</span></li>\n<li><span>支持微服务，支持服务的注册、发现、健康检查、熔断和降级。</span></li>\n</ul>\n<h2><span>项目技术栈</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><span>前端：Vue2、Element UI、Node.js等。</span></li>\n<li><span>后端：C#、.NET 9、AspNetCoreRateLimit、<span>SqlSugar、AutoMapper、SignalR、MiniProfiler、CAP、RabbitMQ、Redis、Consul等。</span></span></li>\n</ul>\n<h2><span>安装教程</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109225902010-549085141.png\" /></p>\n<h2><span>软件架构图</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109225914600-2077383226.png\" /></p>\n<h2><span>项目源代码</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230143000-1636008500.png\" /></p>\n<h2><span>项目效果截图</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230153456-1478242349.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230157723-87615533.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230203615-1395111698.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230210957-1745363029.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230216437-1329007995.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230222905-1152283619.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230230693-1691017440.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205853857-1849985119.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205859134-1945950810.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230248378-53584818.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260109230253718-384227715.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260105205908099-602806087.png\" /></p>\n<h2><span>项目源码地址</span></h2>\n<p><span>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/pang-mingjun/RuYiAdmin\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/pang-mingjun/RuYiAdmin</span></a></li>\n</ul>\n<h2><span>优秀项目和框架精选</span></h2>\n<p><span>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong><span>）。</span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>GitHub开源地址：</strong><a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n</ul>\n<div id=\"gtx-trans\">&nbsp;</div>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 23:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">49</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Flink源码阅读：Task数据交互",
      "link": "https://www.cnblogs.com/Jackeyzhe/p/19463278",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Jackeyzhe/p/19463278\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 20:11\">\n    <span>Flink源码阅读：Task数据交互</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Flink源码阅读：Task数据交互\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1828322/202601/1828322-20260109201055245-933532869.png\" />\n        经过前面的学习，Flink 的几个核心概念相关的源码实现我们已经了解了。本文我们来梳理 Task 的数据交互相关的源码。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>经过前面的学习，Flink 的几个核心概念相关的源码实现我们已经了解了。本文我们来梳理 Task 的数据交互相关的源码。</p>\n<h3 id=\"数据输出\">数据输出</h3>\n<p>话不多说，我们直接进入正题。首先来看 Task 的数据输出，在进入流程之前，我们先介绍几个基本概念。</p>\n<h4 id=\"基本概念\">基本概念</h4>\n<ul>\n<li>\n<p>RecordWriterOutput：它是 Output 接口的一个具体实现类，底层使用 RecordWriter 来发送数据。</p>\n</li>\n<li>\n<p>RecordWriter：数据写入的执行者，负责将数据写到 ResultPartition。</p>\n</li>\n<li>\n<p>ResultPartition 和 ResultSubpartition：ResultPartition 是 ExecutionGraph 中一个节点的输出结果，下游的每个需要从当前 ResultPartition 消费数据的 Task 都会有一个 ResultSubpartition。</p>\n</li>\n<li>\n<p>ChannelSelector：用来决定一个 Record 要被写到哪个 Subpartition 中。</p>\n</li>\n<li>\n<p>LocalBufferPool：用来管理 Buffer 的缓冲池。在介绍反压的原理时，我们提到过。</p>\n</li>\n</ul>\n<p>对这些基本概念有了一定的了解之后，我们来看数据输出的具体流程。</p>\n<h4 id=\"执行流程\">执行流程</h4>\n<p>我们以 map 为例，看一下数据的输出过程。</p>\n<p><img alt=\"DataOutput\" class=\"lazyload\" /></p>\n<p>在 <code>StreamMap.processElement</code> 方法中，调用完 map 方法之后，就会调用 <code>output.collect</code> 方法将数据输出，这里的 output 就是 RecordWriterOutput。在 RecordWriterOutput 中，会调用 RecordWriter 的 emit 方法。</p>\n<pre><code class=\"language-java\">private &lt;X&gt; void pushToRecordWriter(StreamRecord&lt;X&gt; record) {\n    serializationDelegate.setInstance(record);\n\n    try {\n        recordWriter.emit(serializationDelegate);\n    } catch (IOException e) {\n        throw new UncheckedIOException(e.getMessage(), e);\n    }\n}\n</code></pre>\n<p>这里的 serializationDelegate 是用来对 record 进行序列化的。RecordWriter 有两个实现类，一个是 ChannelSelectorRecordWriter，另一个是 BroadcastRecordWriter。ChannelSelectorRecordWriter 需要先调用 ChannelSelector 选择对应的 subparition，然后进行写入。BroadcastRecordWriter 则是写到所有的 subparition。</p>\n<p>接下来就是调用 <code>BufferWritingResultPartition.emitRecord</code> 来写入数据。</p>\n<pre><code class=\"language-java\">public void emitRecord(ByteBuffer record, int targetSubpartition) throws IOException {\n    totalWrittenBytes += record.remaining();\n\n    BufferBuilder buffer = appendUnicastDataForNewRecord(record, targetSubpartition);\n\n    while (record.hasRemaining()) {\n        // full buffer, partial record\n        finishUnicastBufferBuilder(targetSubpartition);\n        buffer = appendUnicastDataForRecordContinuation(record, targetSubpartition);\n    }\n\n    if (buffer.isFull()) {\n        // full buffer, full record\n        finishUnicastBufferBuilder(targetSubpartition);\n    }\n\n    // partial buffer, full record\n}\n</code></pre>\n<p>这里把 record 写入到 buffer 中，如果 buffer 不够，则会从 LocalBufferPool 中申请新的 buffer，申请到之后就会继续写入。下面是具体的申请过程。</p>\n<pre><code class=\"language-java\">private MemorySegment requestMemorySegment(int targetChannel) {\n    MemorySegment segment = null;\n    synchronized (availableMemorySegments) {\n        checkDestroyed();\n\n        if (!availableMemorySegments.isEmpty()) {\n            segment = availableMemorySegments.poll();\n        } else if (isRequestedSizeReached()) {\n            // Only when the buffer request reaches the upper limit(i.e. current pool size),\n            // requests an overdraft buffer.\n            segment = requestOverdraftMemorySegmentFromGlobal();\n        }\n\n        if (segment == null) {\n            return null;\n        }\n\n        if (targetChannel != UNKNOWN_CHANNEL) {\n            if (++subpartitionBuffersCount[targetChannel] == maxBuffersPerChannel) {\n                unavailableSubpartitionsCount++;\n            }\n        }\n\n        checkAndUpdateAvailability();\n    }\n    return segment;\n}\n</code></pre>\n<p>如果有可用内存，就直接从队列中出队。如果达到了本地 BufferPool 的上限，就从全局的 NetworkBufferPool 中申请，申请不到就会阻塞写入过程，等待申请。最后还会检查并更新可用内存状态。</p>\n<p>有了可用的 buffer 之后，就会调用 addToSubpartition，最终数据存储在 PipelinedSubpartition 的 buffers 队列中。</p>\n<pre><code class=\"language-java\">private void addToSubpartition(\n        BufferBuilder buffer,\n        int targetSubpartition,\n        int partialRecordLength,\n        int minDesirableBufferSize)\n        throws IOException {\n    int desirableBufferSize =\n            subpartitions[targetSubpartition].add(\n                    buffer.createBufferConsumerFromBeginning(), partialRecordLength);\n\n    resizeBuffer(buffer, desirableBufferSize, minDesirableBufferSize);\n}\n</code></pre>\n<h3 id=\"数据输入\">数据输入</h3>\n<p>看完了数据输出的过程之后，我们再来看一下数据输入的过程。首先还是了解几个基本概念。</p>\n<h4 id=\"基本概念-1\">基本概念</h4>\n<ul>\n<li>\n<p>InputGate：InputGate 是对输入的封装，与 JobGraph 中的 JobEdge 一一对应，每个 InputGate 消费上游一个或多个 Resultpartition。</p>\n</li>\n<li>\n<p>InputChannel：InputChannel 是和 ExecutionGraph 中的 ExecutionEdge 一一对应的。每个 InputChannel 接收一个 ResultSubpartition 的输出，InputChannel 主要关注 LocalInputChannel 和 RemoteInputChannel 两种实现。</p>\n</li>\n</ul>\n<h4 id=\"执行流程-1\">执行流程</h4>\n<p>了解了具体概念之后，我们再看数据输入的具体流程。</p>\n<p><img alt=\"RecordInput\" class=\"lazyload\" /></p>\n<p>数据输入的入口是 <code>StreamTask.processInput</code> 方法，这个方法中主要是调用 <code>inputProcessor.processInput</code> 方法，我们以 StreamOneInputProcessor 为例。这个方法就是调用 <code>input.emitNext</code> 方法。</p>\n<pre><code class=\"language-java\">public DataInputStatus emitNext(DataOutput&lt;T&gt; output) throws Exception {\n\n    while (true) {\n        // get the stream element from the deserializer\n        if (currentRecordDeserializer != null) {\n            RecordDeserializer.DeserializationResult result;\n            try {\n                result = currentRecordDeserializer.getNextRecord(deserializationDelegate);\n            } catch (IOException e) {\n                throw new IOException(\n                        String.format(\"Can't get next record for channel %s\", lastChannel), e);\n            }\n            if (result.isBufferConsumed()) {\n                currentRecordDeserializer = null;\n            }\n\n            if (result.isFullRecord()) {\n                final boolean breakBatchEmitting =\n                        processElement(deserializationDelegate.getInstance(), output);\n                if (canEmitBatchOfRecords.check() &amp;&amp; !breakBatchEmitting) {\n                    continue;\n                }\n                return DataInputStatus.MORE_AVAILABLE;\n            }\n        }\n\n        Optional&lt;BufferOrEvent&gt; bufferOrEvent = checkpointedInputGate.pollNext();\n        if (bufferOrEvent.isPresent()) {\n            // return to the mailbox after receiving a checkpoint barrier to avoid processing of\n            // data after the barrier before checkpoint is performed for unaligned checkpoint\n            // mode\n            if (bufferOrEvent.get().isBuffer()) {\n                processBuffer(bufferOrEvent.get());\n            } else {\n                DataInputStatus status = processEvent(bufferOrEvent.get(), output);\n                if (status == DataInputStatus.MORE_AVAILABLE &amp;&amp; canEmitBatchOfRecords.check()) {\n                    continue;\n                }\n                return status;\n            }\n        } else {\n            if (checkpointedInputGate.isFinished()) {\n                checkState(\n                        checkpointedInputGate.getAvailableFuture().isDone(),\n                        \"Finished BarrierHandler should be available\");\n                return DataInputStatus.END_OF_INPUT;\n            }\n            return DataInputStatus.NOTHING_AVAILABLE;\n        }\n    }\n}\n</code></pre>\n<p>这里是调用 <code>checkpointedInputGate.pollNext</code> 来获取输入的数据。它的内部就是调用 InputGate 的 pollNext 方法来获取数据。当获取到完整数据之后，就会调用 processElement 来处理数据。</p>\n<p>我们以 SingleInputGate 为例看 InputGate 的 pollNext 方法。它的内部调用链路可用一直追踪到 readBufferFromInputChannel 方法，这个方法内会调用 <code>inputChannel.getNextBuffer</code>，这里交给 InputChannel 来具体执行数据读取。</p>\n<pre><code class=\"language-java\">public Optional&lt;BufferAndAvailability&gt; getNextBuffer() throws IOException {\n    checkError();\n\n    if (!toBeConsumedBuffers.isEmpty()) {\n        return getBufferAndAvailability(toBeConsumedBuffers.removeFirst());\n    }\n\n    ResultSubpartitionView subpartitionView = this.subpartitionView;\n    if (subpartitionView == null) {\n        // There is a possible race condition between writing a EndOfPartitionEvent (1) and\n        // flushing (3) the Local\n        // channel on the sender side, and reading EndOfPartitionEvent (2) and processing flush\n        // notification (4). When\n        // they happen in that order (1 - 2 - 3 - 4), flush notification can re-enqueue\n        // LocalInputChannel after (or\n        // during) it was released during reading the EndOfPartitionEvent (2).\n        if (isReleased) {\n            return Optional.empty();\n        }\n\n        // this can happen if the request for the partition was triggered asynchronously\n        // by the time trigger\n        // would be good to avoid that, by guaranteeing that the requestPartition() and\n        // getNextBuffer() always come from the same thread\n        // we could do that by letting the timer insert a special \"requesting channel\" into the\n        // input gate's queue\n        subpartitionView = checkAndWaitForSubpartitionView();\n    }\n\n    BufferAndBacklog next = subpartitionView.getNextBuffer();\n    // ignore the empty buffer directly\n    while (next != null &amp;&amp; next.buffer().readableBytes() == 0) {\n        next.buffer().recycleBuffer();\n        next = subpartitionView.getNextBuffer();\n        numBuffersIn.inc();\n    }\n\n    if (next == null) {\n        if (subpartitionView.isReleased()) {\n            throw new CancelTaskException(\n                    \"Consumed partition \" + subpartitionView + \" has been released.\");\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    Buffer buffer = next.buffer();\n\n    if (buffer instanceof FullyFilledBuffer) {\n        List&lt;Buffer&gt; partialBuffers = ((FullyFilledBuffer) buffer).getPartialBuffers();\n        int seq = next.getSequenceNumber();\n        for (Buffer partialBuffer : partialBuffers) {\n            toBeConsumedBuffers.add(\n                    new BufferAndBacklog(\n                            partialBuffer,\n                            next.buffersInBacklog(),\n                            buffer.getDataType(),\n                            seq++));\n        }\n\n        return getBufferAndAvailability(toBeConsumedBuffers.removeFirst());\n    }\n\n    return getBufferAndAvailability(next);\n}\n</code></pre>\n<p>我们先来看 LocalInputChannel，先获取到了 subpartitionView，并调用 getNextBuffer，这里其实就是从 PipelinedSubpartition 的 buffers 队列中读取数据。</p>\n<p>RemoteInputChannel 则需要从 receivedBuffers 中读取数据，这个队列的数据就是消费上游数据后保存的。</p>\n<p>至此，Flink 中 Task 的数据输入和输出过程的源码就梳理完了，更加底层的 Netty 相关代码我们在后面继续梳理。</p>\n<h3 id=\"总结\">总结</h3>\n<p>最后简单总结一下，本文我们梳理了 Task 的数据输出和输入的过程。输出过程主要是利用 RecordWriter 将数据写入到 Buffer 中，输入过程则是利用 InputChannel 从 Buffer 消费的过程。如果你的 Flink 任务数据量特别大，并且没什么复杂的逻辑，可以考虑适当调整 localBufferPool 的大小来调优任务的吞吐。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 20:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Jackeyzhe\">Jackeyzhe</a>&nbsp;\n阅读(<span id=\"post_view_count\">24</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "公众号推荐机制整理：科技号怎么把社交流量做起来",
      "link": "https://www.cnblogs.com/reachteam/p/19463233",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/reachteam/p/19463233\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 19:39\">\n    <span>公众号推荐机制整理：科技号怎么把社交流量做起来</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>01 背景</h1>\n<p><span>最近我们软件团队参加了一个高校关于公众号运营的分享，听完挺有启发，所以把重点整理成一篇笔记，发出来给大家参考。</span></p>\n<p><span>从 2023 年开始，公众号的分发不再只是订阅推送那一套了，现在更像是社交信号 + 算法推荐一起在发力。有数据提到，2025 年某科技/软件小号通过社交推荐拿到的流量占比已经到 45.9%，甚至超过了传统订阅推送。</span></p>\n<p><span>所以这篇文章想解决的就一件事：</span></p>\n<p><span>科技号到底要怎么写，才能更容易被推荐，也更容易被转发。</span></p>\n<p><span>下面按 6 个方向讲清楚：技术逻辑、关键指标、分发流程、账号差异、演进变化、案例和可操作建议。</span></p>\n<h2><span>02 推荐系统大概怎么跑</span></h2>\n<h3><span>2.1 三类信号最重要</span></h3>\n<p><span>2025 年之后，公众号的推荐更强调三类信号一起看：</span></p>\n<p><span>1. 社交关系：朋友看过、转发、在看等</span></p>\n<p><span>2. 兴趣标签：你是什么人群，内容是什么主题</span></p>\n<p><span>3. 行为数据：点击、停留、完读、滑动速度、点赞发生在什么时候</span></p>\n<p><span>系统会先从内容里提取关键词，再结合用户行为更新画像，最后决定给谁更多曝光。可以把它理解成一个循环：先曝光一小波，看反馈，再决定要不要继续给量。</span></p>\n<p><span>另外有一点很关键，文章发出去之后通常 1 到 3 分钟内就会做一轮质量评估，主题价值、逻辑结构、原创性、以及 AI 生成痕迹这些都会被综合判断。</span></p>\n<h3><span>2.2 指标权重长什么样</span></h3>\n<p><span>先把大盘放在这。数字是研究整理口径，大家看趋势和重点就行。</span></p>\n<p><span>表 1：公众号算法核心权重分配</span></p>\n<table>\n<thead>\n<tr><th><span>权重维度</span></th><th><span>具体指标</span></th><th><span>权重占比</span></th><th><span>关键阈值（示例）</span></th></tr>\n</thead>\n<tbody>\n<tr>\n<td><span>社交传播系数</span></td>\n<td><span>好友推荐率、转发到朋友圈/社群次数、跨圈层传播深度</span></td>\n<td><span>35%</span></td>\n<td><span>社交推荐流量占比 ≥ 45%</span></td>\n</tr>\n<tr>\n<td><span>内容质量因子</span></td>\n<td><span>完读率（≥65%）、平均阅读时长（≥2 分钟）、原创度（3 倍权重）</span></td>\n<td><span>30%</span></td>\n<td><span>完读率 ≥ 50%</span></td>\n</tr>\n<tr>\n<td><span>用户行为画像</span></td>\n<td><span>点击率、滑动速度、点赞时间点等微观行为</span></td>\n<td><span>20%</span></td>\n<td><span>点击率 ≥ 15%</span></td>\n</tr>\n<tr>\n<td><span>账号信誉体系</span></td>\n<td><span>更新频率、违规记录、用户投诉率</span></td>\n<td><span>10%</span></td>\n<td><span>日更可提升 300% 初始推荐</span></td>\n</tr>\n<tr>\n<td><span>实时流量博弈</span></td>\n<td><span>15 分钟动态调整</span></td>\n<td><span>5%</span></td>\n<td><span>冷启动期点击率 &gt; 8%</span></td>\n</tr>\n</tbody>\n</table>\n<p><span>另外还有一组常见拆分口径：打开率大概占 40%，互动率（赞/在看/收藏）占 30%，分享率占 20%，完读率占 10%。</span></p>\n<p><span>提醒两点：</span></p>\n<p><span>1. 原创的推荐权重会更高（研究口径里提到是转载的 3 倍）</span></p>\n<p><span>2. 认证类型也会影响权重（政府 &gt; 媒体 &gt; 企业 &gt; 个体），认证账号在搜索里更容易拿到靠前曝光</span></p>\n<h3><span>2.3 这几年分发怎么变了</span></h3>\n<p><span>简单按阶段捋一下：</span></p>\n<p><span>1. 2013 到 2017：订阅为主，关注就能收到</span></p>\n<p><span>2. 2017 到 2020：开始引入社交推荐，看一看等入口出现</span></p>\n<p><span>3. 2020 到 2023：算法推荐逐步变强，开始推荐未关注内容</span></p>\n<p><span>4. 2023 至今：社交 + 算法双驱动更明显，朋友相关入口的权重变高</span></p>\n<h2><span>03 流量池赛马：文章为啥会突然爆</span></h2>\n<h3><span>3.1 冷启动那一关很关键</span></h3>\n<p><span>文章发出去之后，通常会先拿到一小波测试曝光（比如 500 到 1000 次），系统主要看三项：点击率、完读率、互动率。</span></p>\n<p><span>研究里给了一些常见阈值做参考：</span></p>\n<p><span>1. 冷启动期（0 到 24 小时）点击率要能到 8% 以上，更可能进下一层</span></p>\n<p><span>2. 进入爆发期后，完读率最好能维持 55% 以上，互动率 3% 以上</span></p>\n<h3><span>3.2 多轮推荐不是一次性给完</span></h3>\n<p><span>通过第一轮测试后，会有二次、三次甚至更多轮的推荐，每一轮曝光量会变大。</span></p>\n<p><span>另外系统会按 15 分钟一轮动态调整流量，所以同一篇文章的数据会一直变化。阅读量到 1 万这个量级后，有时还会触发人工审核。</span></p>\n<h3><span>3.3 社交扩散会带来放大</span></h3>\n<p><span>当用户点在看或者转发，文章就会沿着社交网络扩散。有账号的数据里，朋友相关入口贡献的阅读量能到 45.9%。</span></p>\n<p><span>比较容易触发分享的原因一般是这三类：</span></p>\n<p><span>1. 内容本身有社交价值（共鸣、实用、话题性）</span></p>\n<p><span>2. 文中写清楚分享动机（比如转给同事、转给同学、转给群里谁）</span></p>\n<p><span>3. 内容适配分享场景（工作群、同学群、行业群能用得上）</span></p>\n<h3><span>3.4 公域入口也很重要</span></h3>\n<p><span>表 2：公众号主要流量来源分布</span></p>\n<table>\n<thead>\n<tr><th><span>流量来源</span></th><th><span>占比</span></th><th><span>特点</span></th></tr>\n</thead>\n<tbody>\n<tr>\n<td><span>推荐流量</span></td>\n<td><span>54.5%</span></td>\n<td><span>算法推荐为主</span></td>\n</tr>\n<tr>\n<td><span>公众号消息</span></td>\n<td><span>16.52%</span></td>\n<td><span>订阅用户</span></td>\n</tr>\n<tr>\n<td><span>公众号主页</span></td>\n<td><span>13.17%</span></td>\n<td><span>主动访问</span></td>\n</tr>\n<tr>\n<td><span>搜一搜</span></td>\n<td><span>10.44%</span></td>\n<td><span>精准搜索</span></td>\n</tr>\n<tr>\n<td><span>聊天会话</span></td>\n<td><span>2.88%</span></td>\n<td><span>私域分享</span></td>\n</tr>\n<tr>\n<td><span>朋友圈</span></td>\n<td><span>0.96%</span></td>\n<td><span>朋友圈分享</span></td>\n</tr>\n<tr>\n<td><span>朋友推荐</span></td>\n<td><span>0.12%</span></td>\n<td><span>好友直接推荐</span></td>\n</tr>\n</tbody>\n</table>\n<p><span>补充两点：</span></p>\n<p><span>1. 看一看是很重要的公域入口，爆款里看一看占比能到 60% 到 70%</span></p>\n<p><span>2. 搜一搜占比大概 10.44%，标题关键词做得好，搜索流量占比也可能很可观</span></p>\n<h2><span>04 不同账号的差异</span></h2>\n<h3><span>4.1 认证和账号信誉</span></h3>\n<p><span>认证类型会影响权重和信任（政府 &gt; 媒体 &gt; 企业 &gt; 个体）。</span></p>\n<p><span>同时也会看这些：注册时间、违规记录、粉丝活跃度（常读用户）、更新频率（发文多且原创占比高更占优）。</span></p>\n<h3><span>4.2 新号和老号不一样</span></h3>\n<p><span>新号一般会有观察期，初期曝光可能比较小，平台会先判断你是不是稳定的正常创作者，标签清不清晰，内容合不合规。</span></p>\n<p><span>老号因为画像积累更完整，推荐更容易精准，但长期不活跃或者质量下滑也可能被降权。</span></p>\n<h3><span>4.3 垂直领域更吃香，但别乱跑</span></h3>\n<p><span>科技、教育等垂直领域在品类里可能更容易拿到倾斜，但前提是定位足够细，内容持续垂直输出，并且用合集、标签等方式强化识别。</span></p>\n<h2><span>05 科技号怎么做更容易起量</span></h2>\n<p><span>我更建议把指标当成门槛，而不是当 KPI。</span></p>\n<h3><span>5.1 标题先把点击率顶起来</span></h3>\n<p><span>标题可以用一个比较稳的结构：痛点场景 + 数据背书 + 情绪共鸣。</span></p>\n<p><span>示例（按你们账号方向替换即可）：</span></p>\n<p><span>1. 我把电脑变快了，3 个 Windows 设置立刻见效</span></p>\n<p><span>2. 别再被钓鱼了，校园/企业邮箱最常见的 5 种诈骗</span></p>\n<p><span>3. 从 0 到 1，用 10 分钟搭好一个自动化报表流程</span></p>\n<h3><span>5.2 内容结构要照顾完读</span></h3>\n<p><span>一个比较好用的写法是：开头直接给结论，中间保持信息密度（大概每 300 字一个关键点），结尾给行动建议或提问，引导评论/收藏/转发。</span></p>\n<h3><span>5.3 原创是底盘</span></h3>\n<p><span>研究里提到原创度建议大于 70%。如果用 AI 做辅助，也建议把比例和用途说清楚，避免被系统误判成低质。</span></p>\n<h3><span>5.4 把可转发写进正文</span></h3>\n<p><span>文章 25% / 50% / 75% 的位置，可以顺手加一句话，告诉读者这段适合转给谁。</span></p>\n<p><span>比如：这份排查清单转给 IT 同事/同学；这段设置转到群里，大家少踩坑。</span></p>\n<h3><span>5.5 发出去后的 2 小时别浪费</span></h3>\n<p><span>冷启动数据很关键，建议发文后马上用种子用户扩散一波（社群、同事群、同学群），先把点击、完读、互动跑起来。</span></p>\n<h3><span>5.6 每周就盯 3 个指标</span></h3>\n<p><span>1. 社交推荐流量占比（目标值可参考 45%）</span></p>\n<p><span>2. 菜单栏点击量（能看出互动深度）</span></p>\n<p><span>3. 48 小时互动率（能看出内容即时影响力）</span></p>\n<p><span>另外标题、封面、开头段落都可以做小范围 A/B 测试，找最合适的组合。</span></p>\n<h2><span>06 案例给我们的提示</span></h2>\n<p><span>这里列几个研究里的典型现象，主要看规律：</span></p>\n<p><span>1. 有文章阅读 48 万，看一看贡献 60%</span></p>\n<p><span>2. 有新号粉丝不多，单篇 10 万+，看一看贡献 98%</span></p>\n<p><span>3. 有病毒传播案例，第 1 天 500+，第 2 天 1 万+，第 3 天朋友圈刷屏</span></p>\n<p><span>共同点其实很朴素：冷启动过关，社交扩散被点燃，内容质量能撑住完读和互动。</span></p>\n<h2><span>07 风险和合规别踩坑</span></h2>\n<p><span>常见误区：</span></p>\n<p><span>1. 追热点但和定位不搭，容易白忙</span></p>\n<p><span>2. 依赖刷量，平台有无效流量排查，风险很高</span></p>\n<p><span>3. 只要曝光不要质量，完读率掉得很快，推荐也会很快停</span></p>\n<p><span>合规方面：</span></p>\n<p><span>1. 原创度尽量做到 70% 以上</span></p>\n<p><span>2. 标题和正文做敏感词扫描，少用绝对化、夸大化表述</span></p>\n<p><span>3. 图片素材注意版权，用 CC0 站点或者合规二创</span></p>\n<h2><span>08 总结</span></h2>\n<p><span>一句话总结：公众号现在是社交信号 + 算法推荐一起在跑，科技号想起量，核心还是三件事：冷启动数据过关、内容更容易被转发、长期坚持原创和垂直。</span></p>\n<p><span>如果你只想先做最小改动，建议从这 3 个开始：</span></p>\n<p><span>1. 发文后 0 到 2 小时，把点击率、完读率、互动率先跑起来</span></p>\n<p><span>2. 把清单、步骤、排错流程写得更可截图转发，顺手写清楚转给谁</span></p>\n<p><span>3. 连续做一个细分方向（比如校园网络安全、系统使用指南、办公效率），让标签稳定下来</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 19:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/reachteam\">H5开发技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">53</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Grafana Loki自动监控日志",
      "link": "https://www.cnblogs.com/ZouYua/p/19462083",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ZouYua/p/19462083\" id=\"cb_post_title_url\" title=\"发布于 2026-01-09 16:06\">\n    <span>Grafana Loki自动监控日志</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"grafana-loki-日志监控配置指南\">Grafana Loki 日志监控配置指南</h1>\n<p><img alt=\"d3135d676e_1_k-hdOAQjRXKoyguzKuoeKg\" src=\"https://img2024.cnblogs.com/blog/3196947/202601/3196947-20260109160333955-1410605029.jpg\" /></p>\n<h2 id=\"前言\">前言</h2>\n<p>在微服务架构中，日志收集和分析是运维的重要环节。本文介绍如何使用 Grafana Loki 搭建轻量级日志监控系统，并与传统的 ELK 技术栈进行对比。</p>\n<h2 id=\"loki-vs-elk-技术栈对比\">Loki vs ELK 技术栈对比</h2>\n<h3 id=\"架构对比\">架构对比</h3>\n<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>ELK</th>\n<th>Loki</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>日志采集</td>\n<td>Logstash / Filebeat</td>\n<td>Promtail</td>\n</tr>\n<tr>\n<td>日志存储</td>\n<td>Elasticsearch</td>\n<td>Loki</td>\n</tr>\n<tr>\n<td>可视化</td>\n<td>Kibana</td>\n<td>Grafana</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"核心差异\">核心差异</h3>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>ELK</th>\n<th>Loki</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>索引方式</td>\n<td>全文索引</td>\n<td>仅索引标签（Label）</td>\n</tr>\n<tr>\n<td>存储占用</td>\n<td>高（原始日志 + 索引）</td>\n<td>低（压缩存储，索引小）</td>\n</tr>\n<tr>\n<td>资源消耗</td>\n<td>高（ES 需要大量内存）</td>\n<td>低（单机 256MB 可运行）</td>\n</tr>\n<tr>\n<td>查询方式</td>\n<td>Lucene 语法</td>\n<td>LogQL（类 PromQL）</td>\n</tr>\n<tr>\n<td>查询速度</td>\n<td>全文搜索快</td>\n<td>标签过滤快，全文搜索慢</td>\n</tr>\n<tr>\n<td>部署复杂度</td>\n<td>复杂（多组件协调）</td>\n<td>简单（3 个容器即可）</td>\n</tr>\n<tr>\n<td>学习成本</td>\n<td>较高</td>\n<td>较低（熟悉 Prometheus 更容易）</td>\n</tr>\n<tr>\n<td>与 Prometheus 集成</td>\n<td>需额外配置</td>\n<td>原生集成</td>\n</tr>\n</tbody>\n</table>\n<p><img alt=\"567ffc184541f44c0384d02f8b991447\" src=\"https://img2024.cnblogs.com/blog/3196947/202601/3196947-20260109160412006-423286371.jpg\" /></p>\n<p><img alt=\"056f09368ad6dde870727e48171c89ee\" src=\"https://img2024.cnblogs.com/blog/3196947/202601/3196947-20260109160528026-1366870051.gif\" /></p>\n<h3 id=\"选型建议\">选型建议</h3>\n<p><strong>选择 ELK 的场景：</strong></p>\n<ul>\n<li>需要复杂的全文搜索</li>\n<li>日志分析是核心业务需求</li>\n<li>有专门的运维团队</li>\n<li>服务器资源充足</li>\n</ul>\n<p><strong>选择 Loki 的场景：</strong></p>\n<ul>\n<li>中小型项目，资源有限</li>\n<li>已使用 Prometheus + Grafana 监控体系</li>\n<li>主要需求是日志查看和简单过滤</li>\n<li>追求快速部署和低维护成本</li>\n</ul>\n<h2 id=\"系统架构\">系统架构</h2>\n<pre><code>┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n│  微服务应用   │ ──▶ │   日志文件   │ ──▶ │  Promtail   │ ──▶ │    Loki     │\n│ (Java/Go等) │     │ (.log files)│     │  (采集器)    │     │  (存储)      │\n└─────────────┘     └─────────────┘     └─────────────┘     └──────┬──────┘\n                                                                    │\n                                                                    ▼\n                                                            ┌─────────────┐\n                                                            │   Grafana   │\n                                                            │  (可视化)    │\n                                                            └─────────────┘\n</code></pre>\n<h2 id=\"环境准备\">环境准备</h2>\n<ul>\n<li>Docker 20.10+</li>\n<li>Docker Compose 2.0+</li>\n<li>服务器内存 &gt;= 2GB</li>\n</ul>\n<h2 id=\"目录结构\">目录结构</h2>\n<pre><code>/docker/\n├── docker-compose.yaml\n├── loki/\n│   └── loki-config.yaml\n└── promtail/\n    └── promtail-config.yaml\n</code></pre>\n<h2 id=\"配置文件\">配置文件</h2>\n<h3 id=\"1-loki-配置-loki-configyaml\">1. Loki 配置 (loki-config.yaml)</h3>\n<pre><code class=\"language-yaml\">auth_enabled: false\n\nserver:\n  http_listen_port: 3100\n  grpc_listen_port: 9096\n\ncommon:\n  instance_addr: 127.0.0.1\n  path_prefix: /loki\n  storage:\n    filesystem:\n      chunks_directory: /loki/chunks\n      rules_directory: /loki/rules\n  replication_factor: 1\n  ring:\n    kvstore:\n      store: inmemory\n\nquery_range:\n  results_cache:\n    cache:\n      embedded_cache:\n        enabled: true\n        max_size_mb: 100\n\nlimits_config:\n  metric_aggregation_enabled: true\n  retention_period: 720h  # 日志保留 30 天\n\nschema_config:\n  configs:\n    - from: 2020-10-24\n      store: tsdb\n      object_store: filesystem\n      schema: v13\n      index:\n        prefix: index_\n        period: 24h\n\npattern_ingester:\n  enabled: true\n  metric_aggregation:\n    loki_address: localhost:3100\n\ncompactor:\n  working_directory: /loki/compactor\n  retention_enabled: true\n  delete_request_store: filesystem\n\nfrontend:\n  encoding: protobuf\n</code></pre>\n<p><strong>配置说明：</strong></p>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>auth_enabled: false</code></td>\n<td>关闭认证，单机部署使用</td>\n</tr>\n<tr>\n<td><code>http_listen_port: 3100</code></td>\n<td>Loki HTTP API 端口</td>\n</tr>\n<tr>\n<td><code>path_prefix: /loki</code></td>\n<td>数据存储路径前缀</td>\n</tr>\n<tr>\n<td><code>retention_period: 720h</code></td>\n<td>日志保留 30 天</td>\n</tr>\n<tr>\n<td><code>store: tsdb</code></td>\n<td>使用 TSDB 存储引擎（Loki 3.x 推荐）</td>\n</tr>\n<tr>\n<td><code>schema: v13</code></td>\n<td>最新的 schema 版本</td>\n</tr>\n<tr>\n<td><code>embedded_cache</code></td>\n<td>内置查询缓存，提升查询性能</td>\n</tr>\n<tr>\n<td><code>compactor</code></td>\n<td>自动压缩和清理过期日志</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-promtail-配置-promtail-configyaml\">2. Promtail 配置 (promtail-config.yaml)</h3>\n<pre><code class=\"language-yaml\">server:\n  http_listen_port: 9080\n  grpc_listen_port: 0\n\npositions:\n  filename: /tmp/positions.yaml\n\nclients:\n  - url: http://loki:3100/loki/api/v1/push\n\nscrape_configs:\n  - job_name: xiaohashu\n    static_configs:\n      - targets:\n          - localhost\n        labels:\n          job: xiaohashu\n          __path__: /var/log/xiaohashu/*.log\n\n    pipeline_stages:\n      # 从文件名提取服务名: note.2025-07-01-0.log → service=note\n      - regex:\n          source: filename\n          expression: '(?P&lt;service&gt;[a-z-]+)\\.\\d{4}-\\d{2}-\\d{2}-\\d+\\.log$'\n      - labels:\n          service:\n      \n      # 从日志内容提取级别: INFO/WARN/ERROR/DEBUG\n      - regex:\n          expression: '^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3} \\[[^\\]]+\\] (?P&lt;level&gt;\\w+)'\n      - labels:\n          level:\n</code></pre>\n<p><strong>配置说明：</strong></p>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>positions.filename</code></td>\n<td>记录读取位置，重启后继续读取</td>\n</tr>\n<tr>\n<td><code>clients.url</code></td>\n<td>Loki 推送地址</td>\n</tr>\n<tr>\n<td><code>__path__</code></td>\n<td>日志文件匹配路径</td>\n</tr>\n<tr>\n<td><code>pipeline_stages</code></td>\n<td>日志处理管道</td>\n</tr>\n<tr>\n<td><code>regex</code> + <code>labels</code></td>\n<td>从文件名/内容提取标签</td>\n</tr>\n</tbody>\n</table>\n<p><strong>日志格式示例：</strong></p>\n<pre><code>2025-07-01 10:30:00.123 [main] INFO  com.example.Service - 启动成功\n</code></pre>\n<p>经过 pipeline 处理后，会自动添加标签：</p>\n<ul>\n<li><code>service=note</code>（从文件名提取）</li>\n<li><code>level=INFO</code>（从日志内容提取）</li>\n</ul>\n<h3 id=\"3-docker-compose-配置\">3. Docker Compose 配置</h3>\n<pre><code class=\"language-yaml\">services:\n  loki:\n    image: grafana/loki:3.5.0\n    container_name: loki\n    ports:\n      - \"3100:3100\"\n    volumes:\n      - ./loki/loki-config.yaml:/etc/loki/local-config.yaml\n      - loki-data:/loki\n    command: -config.file=/etc/loki/local-config.yaml\n    restart: unless-stopped\n\n  promtail:\n    image: grafana/promtail:3.5.0\n    container_name: promtail\n    volumes:\n      - ./promtail/promtail-config.yaml:/etc/promtail/config.yaml\n      - /www/wwwroot/life_diary/logs:/var/log/xiaohashu:ro\n    command: -config.file=/etc/promtail/config.yaml\n    restart: unless-stopped\n    depends_on:\n      - loki\n\n  grafana:\n    image: grafana/grafana:11.4.0\n    container_name: grafana\n    ports:\n      - \"3000:3000\"\n    environment:\n      - GF_SECURITY_ADMIN_USER=admin\n      - GF_SECURITY_ADMIN_PASSWORD=admin123\n    volumes:\n      - grafana-data:/var/lib/grafana\n    restart: unless-stopped\n    depends_on:\n      - loki\n\nvolumes:\n  loki-data:\n  grafana-data:\n</code></pre>\n<p><strong>关键配置说明：</strong></p>\n<table>\n<thead>\n<tr>\n<th>配置</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>loki-data:/loki</code></td>\n<td>Loki 数据持久化，容器重启不丢失</td>\n</tr>\n<tr>\n<td><code>/www/wwwroot/life_diary/logs:/var/log/xiaohashu:ro</code></td>\n<td>挂载宿主机日志目录，<code>:ro</code> 表示只读</td>\n</tr>\n<tr>\n<td><code>grafana-data:/var/lib/grafana</code></td>\n<td>Grafana 配置持久化</td>\n</tr>\n<tr>\n<td><code>depends_on</code></td>\n<td>服务启动依赖顺序</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"部署步骤\">部署步骤</h2>\n<h3 id=\"1-创建目录和配置文件\">1. 创建目录和配置文件</h3>\n<pre><code class=\"language-bash\">mkdir -p /docker/loki /docker/promtail\ncd /docker\n\n# 创建配置文件（内容见上文）\nvim loki/loki-config.yaml\nvim promtail/promtail-config.yaml\nvim docker-compose.yaml\n</code></pre>\n<h3 id=\"2-启动服务\">2. 启动服务</h3>\n<pre><code class=\"language-bash\">cd /docker\ndocker-compose up -d\n</code></pre>\n<h3 id=\"3-查看服务状态\">3. 查看服务状态</h3>\n<pre><code class=\"language-bash\">docker-compose ps\ndocker-compose logs -f loki      # 查看 Loki 日志\ndocker-compose logs -f promtail  # 查看 Promtail 日志\n</code></pre>\n<h3 id=\"4-配置-grafana-数据源\">4. 配置 Grafana 数据源</h3>\n<ol>\n<li>浏览器访问 <code>http://服务器IP:3000</code></li>\n<li>登录（默认 admin / admin123）</li>\n<li>左侧菜单 → <strong>Connections</strong> → <strong>Data sources</strong></li>\n<li>点击 <strong>Add data source</strong> → 选择 <strong>Loki</strong></li>\n<li>URL 填写：<code>http://loki:3100</code></li>\n<li>点击 <strong>Save &amp; Test</strong>，显示绿色 ✓ 表示成功</li>\n</ol>\n<h2 id=\"logql-查询语法\">LogQL 查询语法</h2>\n<h3 id=\"基础查询\">基础查询</h3>\n<pre><code class=\"language-logql\"># 查看所有日志\n{job=\"xiaohashu\"}\n\n# 按服务筛选\n{service=\"note\"}\n{service=\"gateway\"}\n\n# 按日志级别筛选\n{level=\"ERROR\"}\n{level=\"WARN\"}\n\n# 组合条件\n{service=\"note\", level=\"ERROR\"}\n</code></pre>\n<h3 id=\"关键字搜索\">关键字搜索</h3>\n<pre><code class=\"language-logql\"># 包含关键字\n{job=\"xiaohashu\"} |= \"Exception\"\n{service=\"note\"} |= \"NullPointer\"\n\n# 不包含关键字\n{service=\"gateway\"} != \"health\"\n\n# 正则匹配\n{job=\"xiaohashu\"} |~ \"user.*login\"\n</code></pre>\n<h3 id=\"统计分析\">统计分析</h3>\n<pre><code class=\"language-logql\"># 最近 5 分钟各服务错误数\ncount_over_time({level=\"ERROR\"}[5m]) by (service)\n\n# 每分钟日志量\nrate({job=\"xiaohashu\"}[1m])\n\n# 错误率\nsum(rate({level=\"ERROR\"}[5m])) / sum(rate({job=\"xiaohashu\"}[5m]))\n</code></pre>\n<h2 id=\"常用运维命令\">常用运维命令</h2>\n<pre><code class=\"language-bash\"># 启动所有服务\ndocker-compose up -d\n\n# 停止所有服务\ndocker-compose down\n\n# 重启单个服务\ndocker-compose restart loki\n\n# 查看资源占用\ndocker stats loki promtail grafana\n\n# 查看日志\ndocker-compose logs -f --tail=100 loki\n\n# 清理旧数据（谨慎使用）\ndocker volume rm docker_loki-data\n</code></pre>\n<h2 id=\"常见问题\">常见问题</h2>\n<h3 id=\"1-promtail-cpu-占用高\">1. Promtail CPU 占用高</h3>\n<p>刚启动时需要扫描历史日志，属于正常现象。等处理完历史数据后会降下来。</p>\n<h3 id=\"2-grafana-连接-loki-失败\">2. Grafana 连接 Loki 失败</h3>\n<p>检查 URL 是否正确，容器内部通信使用服务名 <code>http://loki:3100</code>，不是 <code>localhost</code>。</p>\n<h3 id=\"3-看不到日志\">3. 看不到日志</h3>\n<ul>\n<li>检查日志路径挂载是否正确</li>\n<li>检查 Promtail 日志：<code>docker logs promtail</code></li>\n<li>确认日志文件名格式与 <code>__path__</code> 匹配</li>\n</ul>\n<h3 id=\"4-磁盘空间不足\">4. 磁盘空间不足</h3>\n<p>调整 <code>retention_period</code> 缩短保留时间，或手动清理：</p>\n<pre><code class=\"language-bash\">docker-compose down\ndocker volume rm docker_loki-data\ndocker-compose up -d\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>Grafana Loki 相比 ELK 更加轻量，适合中小型项目和资源有限的场景。通过合理配置 Promtail 的 pipeline，可以自动提取服务名和日志级别，实现高效的日志查询和分析。</p>\n<p>对于已经使用 Prometheus + Grafana 的团队，Loki 是日志监控的最佳选择，可以在同一个 Grafana 界面中同时查看指标和日志，大大提升排查问题的效率。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-09 16:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ZouYua\">zouyua</a>&nbsp;\n阅读(<span id=\"post_view_count\">119</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}