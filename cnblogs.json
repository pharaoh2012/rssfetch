{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "一个 .NET 开源免费、功能强大的 UI 自动化库",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19395009",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19395009\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 23:31\">\n    <span>一个 .NET 开源免费、功能强大的 UI 自动化库</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>今天大姚给大家分享一个 .NET 开源免费（MIT license）、功能强大的 UI 自动化库：FlaUI。</span></p>\n<h2><span>项目介绍</span></h2>\n<p><span>FlaUI 是一个 .NET 开源免费（MIT license）、功能强大 的 UI 自动化库，专为 Windows 桌面应用程序（如 Win32、WinForms、WPF、Store Apps 等应用）的自动化测试而设计。该项目基于 Microsoft 的原生 UI Automation 库构建，并作为这些库的封装器，提供了丰富的功能和灵活的 API，以便开发者能够高效地编写自动化测试脚本。</span></p>\n<h2><span>应用场景</span></h2>\n<p><span>FlaUI 适用于多种自动化测试场景，包括但不限于：</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>功能测试</strong><span>：验证应用程序的各项功能是否正常工作。</span></li>\n<li><strong>回归测试</strong><span>：在应用程序更新后，确保现有功能不受影响。</span></li>\n<li><strong>UI 验证</strong><span>：检查 UI 元素是否按预期显示和交互。</span></li>\n<li><strong>等等等...</strong></li>\n</ul>\n<h2><span>项目源代码</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251224232937849-1816295785.png\" /></p>\n<h2><span>创建 FlaUIExercise</span></h2>\n<p><span>创建名为<code><span>FlaUIExercise</span></code><span>的控制台应用：</span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251224232948718-478027617.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251224232953189-2015296513.png\" /></p>\n<h2><span><span>NuGet 包安装</span></span></h2>\n<p><span>在 NuGet 包管理器中搜索&nbsp;<code><span>FlaUI.UIA3</span></code><span>&nbsp;安装：</span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251224233007491-894041148.png\" /></p>\n<h2><span>操作记事本（Notepad）</span></h2>\n<pre><span><code><span>&nbsp; &nbsp; public class Program<br /><span>&nbsp; &nbsp; {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; static void Main(string[] args)<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OperateNotepad();<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;summary&gt;<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; /// 操作记事本（Notepad）<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;/summary&gt;<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;returns&gt;&lt;/returns&gt;<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; private static void&nbsp;OperateNotepad<span>()<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 启动记事本<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var notepadApp = Application.Launch(\"notepad.exe\"<span>);<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using (var automation = new UIA3Automation())<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var window = notepadApp.GetMainWindow(automation);<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; window.WaitUntilClickable();<br /><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine(window.Title);<br /><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 获取编辑框（Edit 控件）<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var edit = window.FindFirstDescendant(cf =&gt; cf.ByControlType(ControlType.Document))<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ?.AsTextBox();<br /><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(edit == null)<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine(\"未找到记事本编辑区域！\"<span>);<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notepadApp.Close();<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return<span>;<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 输入文本<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edit.Text =&nbsp;\"⚔【DotNetGuide专栏C#/.NET/.NET Core编程技巧练习集】C#/.NET/.NET Core编程常用语法、算法、技巧、中间件、类库、工作业务实操练习集，配套详细的文章教程和代码示例，助力快速掌握C#/.NET/.NET Core中各种编程常用语法、算法、技巧、中间件、类库、工作业务实操等等。\"<span>;<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notepadApp.Close();<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return<span>;<br /><span>&nbsp; &nbsp; &nbsp; &nbsp; }<br /><span>&nbsp; &nbsp; }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202512/1336199-20251224233032178-1607355406.png\" /></p>\n<h2><span>项目源码地址</span></h2>\n<p><span>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>GitHub开源地址：</strong>&nbsp;<a href=\"https://github.com/FlaUI/FlaUI\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/FlaUI/FlaUI</a></li>\n<li><strong>本文代码示例：</strong>&nbsp;<a href=\"https://github.com/YSGStudyHards/DotNetExercises/tree/master/FlaUIExercise\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/YSGStudyHards/DotNetExercises/tree/master/FlaUIExercise</a></li>\n</ul>\n<h2><span>优秀项目和框架精选</span></h2>\n<p><span>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong><span>）。</span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>GitHub开源地址：</strong><a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n<li><strong>Gitee开源地址：</strong><a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span>https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></li>\n</ul>\n<div id=\"gtx-trans\">&nbsp;</div>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 23:31</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "电信公网IPV4被收回之后：家庭网络的“绝地求生”折腾记",
      "link": "https://www.cnblogs.com/sueyyyy/p/19394875",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sueyyyy/p/19394875\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 23:04\">\n    <span>电信公网IPV4被收回之后：家庭网络的“绝地求生”折腾记</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>好久好久没写过博客了，最近心血来潮登上来看看，不过既然来都来了就顺便写一篇博客再走吧，想来想去没啥好素材，遂把最近家里网络的折腾记录分享一下。</p>\n</blockquote>\n<p>作为一名苦逼码农，我一直信奉行规：<strong>“代码能跑就不要动，架构能用就别重构”</strong>。<br />\n这几年我家的电信网络一直稳如老狗：手握稀缺的 <strong>公网 IPv4</strong>，在小米路由器上开个端口转发，配合DDNS+防火墙策略，在外访问家里的 Nas和 Mac mini，那叫一个丝般顺滑且安全。那时候觉得这已经一步到位，不用再折腾了。<br />\n然而，今年4月，天塌了。</p>\n<h2 id=\"第一章失去-ipv4-的那个四月\">第一章：失去 IPv4 的那个四月</h2>\n<p>坑爹的江苏电信在没有任何预警和通知的情况下，单方面收回了我的公网 IPv4。我看着 WAN 口那个 <code>100.73</code> 开头的内网地址，陷入了沉思。<br />\n<img alt=\"image\" height=\"365\" src=\"https://img2024.cnblogs.com/blog/2482940/202512/2482940-20251224222436013-1105168401.png\" width=\"1095\" /><br />\n作为一个不信邪的人，我开始了漫长的维权之路。打客服、找片区经理、甚至硬着头皮去工信部、通管局、12345投诉。结果大家懂的，得到的回复出奇一致：“资源枯竭，合同为明确表示有该服务，无法办理”。<br />\n没办法，生活还得继续。胳膊拧不过大腿，我只能被迫妥协，转向了 <strong>IPv6</strong>。</p>\n<h2 id=\"第二章在互联网上裸奔的日子\">第二章：在互联网上“裸奔”的日子</h2>\n<p>好在ipv6没有限制，直接开启路由器的IPV6就能使用。我重新捡起 <code>ddns-go</code>，配合域名做解析。<br />\n但这玩意儿有个巨大的坑——<strong>小米路由器的 IPv6 防火墙设计简直是“反人类”</strong>。它就像一个只有开关键的灯泡：要么全开（外网彻底进不来），要么全关（家里大门敞开）。为了能用，我被迫选择了<strong>关闭防火墙</strong>。<br />\n始终担心哪天会被攻击，因为我的 NAS、内网服务完全是在互联网上<strong>“裸奔”</strong>。这就好比我出门上班，家里大门不仅没锁，甚至连门都卸了，谁路过都能往里瞅一眼。<br />\n而且这方案极其难用：公司和星巴克的 WiFi 大多还是纯 IPv4 环境，导致我在外面想连回家，还得先把手机 WiFi 断了切成 5G。<strong>那一刻，我感觉自己像个拿着智能手机的原始人。</strong></p>\n<h2 id=\"第三章cloudflare-tunnel-救我狗命\">第三章：Cloudflare Tunnel 救我狗命</h2>\n<p>这种“裸奔”且“便秘”的日子，我忍到了前几天，终于决定对架构进行重构。首先登场的是 <strong>Cloudflare Tunnel</strong>，给内网穿条裤子。</p>\n<h3 id=\"-简要步骤\">👨‍💻 简要步骤</h3>\n<p>其实这玩意儿配置起来意外地简单，核心就三步：</p>\n<ol>\n<li><strong>搞个域名：</strong> 斥巨资（47块钱一年）在spaceship又买了个域名，托管到 Cloudflare。</li>\n<li><strong>内网部署守护进程：</strong> 在家里的 Mac Mini（或者 NAS）上装个 <code>cloudflared</code> 服务。这玩意儿就像个“地道挖掘机”，主动向 Cloudflare 的服务器打洞。</li>\n<li><strong>云端配置：</strong> 登录 Cloudflare Zero Trust 后台，动动鼠标，把 <code>nas.mydomain.com</code> 指向内网的 <code>http://192.168.31.199:5000</code>。</li>\n</ol>\n<h3 id=\"-效果立竿见影\">🚀 效果立竿见影</h3>\n<ul>\n<li><strong>不用关防火墙了！</strong> 我赶紧把小米那个“人工智障”防火墙重新打开，心里踏实多了。</li>\n<li><strong>兼容性无敌：</strong> 它就像个翻译官，我在外面就算用只有 IPv4 的破烂 WiFi，也能通过域名顺畅访问家里的服务。(不得不说CF真实大善人呀，免费功能都贼多贼好用！)<br />\n<img alt=\"image\" height=\"600\" src=\"https://img2024.cnblogs.com/blog/2482940/202512/2482940-20251224223703831-1192856318.png\" width=\"1477\" /></li>\n</ul>\n<h2 id=\"第四章拉满带宽tailscale--游戏\">第四章：拉满带宽（Tailscale &amp; 游戏）</h2>\n<p>CF Tunnel 虽然稳，但毕竟要绕道别人的服务器，传大文件有点温吞水。始终达不到原来公网IPV6的速度，而且，最近心里长草想搞 <strong>远程游戏串流</strong>。于是我又盯上了 <strong>Tailscale</strong>。</p>\n<h3 id=\"-简要步骤-1\">👨‍💻 简要步骤</h3>\n<p>Tailscale 主打一个“无感”，但要玩得好，得用点魔法：</p>\n<ol>\n<li><strong>全员安装：</strong> Mac Mini、手机、iPad 全部装上 Tailscale 客户端并登录。</li>\n<li><strong>开启子网路由 (Subnet Router)：</strong> 这是关键。我在 Mac Mini 的终端敲了一行命令 <code>advertise-routes=192.168.31.0/24</code>。这相当于告诉 Tailscale：“去往我家内网的路，我熟，大家把包发给我就行。”</li>\n<li><strong>客户端设置：</strong> 在手机 App 里，有个藏得很深的开关叫 <strong>\"Use Subnets\"</strong>，必须把它打开，否则手机还是会傻傻地走本地网络。</li>\n</ol>\n<p>这一试不要紧，直接打开了新世界的大门。我惊讶地发现：<strong>Tailscale 居然能穿透小米的防火墙！</strong>即使我开着防火墙，只要两头都有 IPv6，它俩竟然能私下里<strong>“打洞”</strong>成功，建立 P2P 直连。<br />\n<img alt=\"image\" height=\"629\" src=\"https://img2024.cnblogs.com/blog/2482940/202512/2482940-20251224224255559-841000158.png\" width=\"1443\" /></p>\n<h3 id=\"-游戏串流配置-moonlight\">🎮 游戏串流配置 (Moonlight)</h3>\n<ul>\n<li><strong>服务端：</strong> PC 安装 <strong>Sunshine</strong>（替代老黄的 GameStream），设置好用户名密码。</li>\n<li><strong>客户端：</strong> 手机装 <strong>Moonlight</strong>，搜到 PC 后输个 PIN 码配对。</li>\n<li><strong>调优：</strong> 考虑到家里上行带宽只有 50M，我把码率锁死在 <strong>60Mbps</strong>，并强制开启 <strong>HEVC (H.265)</strong> 编码。</li>\n</ul>\n<p>实测延迟 40ms。在外直接串流回家，对比Windows自带的远程工具流畅度简直好到飞起。</p>\n<h2 id=\"第五章最后的强迫症消灭-19216831x\">第五章：最后的强迫症（消灭 192.168.31.x）</h2>\n<p>所有的技术问题都解决了，最后一个抽象大坑竟然是——<strong>IP 冲突</strong>。</p>\n<p>因为小米路由默认网段是 <code>192.168.31.x</code>，外面很多公共 WiFi 也是这个网段。经常出现“我在外面连回家，系统以为我在访问本地”的路由错乱，导致TailScale无法正常联通。</p>\n<p>一不做二不休，既然折腾了，就折腾到底。我把全家网段迁移到了冷门的 <strong><code>192.168.81.x</code></strong>。</p>\n<blockquote>\n<p><strong>⚠️ 高危操作警告：</strong><br />\n在改路由器 IP 之前，<strong>记得一定要先把 NAS 和服务器的静态 IP 解绑改成 DHCP！OpenWrt、Docker等配置了固定ip的服务也要记得修改</strong> 。不然就是断网惨案，得扛着电脑、网线去弱电箱里救火。</p>\n</blockquote>\n<hr />\n<h2 id=\"现在的状态\">现在的状态</h2>\n<p>经过这几天的疯狂折腾，现在的架构是：</p>\n<ul>\n<li><strong>安全：</strong> 小米防火墙全开，不再裸奔。</li>\n<li><strong>入口：</strong>\n<ul>\n<li><strong>日常访问 (Web)：</strong> 走 Cloudflare Tunnel，全网通吃。</li>\n<li><strong>高性能访问 (游戏/传输)：</strong> 走 Tailscale IPv6 直连，速度拉满。</li>\n</ul>\n</li>\n<li><strong>心情：</strong> 极度舒适。</li>\n</ul>\n<p>虽然失去了公网 IPv4 很难受，但逼着自己搞出了这一套更现代、更安全的方案，也算是<strong>因祸得福</strong>吧。折腾无止境，生命不息，挖坑不止！</p>\n<blockquote>\n<p>大家如果对此感兴趣或有疑问的话，欢迎评论留言，有空我单独做一些更详细的折腾教程。</p>\n</blockquote>\n\n</div>\n<div id=\"MySignature\">\n    <p><br />\n本博客文章均已测试验证，欢迎评论、交流、点赞。<br />\n部分文章来源于网络，如有侵权请联系删除。<br />\n转载请注明原文链接：<a href=\"https://www.cnblogs.com/sueyyyy/p/19394875\" target=\"_blank\">https://www.cnblogs.com/sueyyyy/p/19394875</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 23:04</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sueyyyy\">少说点话</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "自适应滤波算法的FPGA实现思路",
      "link": "https://www.cnblogs.com/y0011/p/19394755/bugao123",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/y0011/p/19394755/bugao123\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 22:50\">\n    <span>自适应滤波算法的FPGA实现思路</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1><span>1、原理简介</span></h1>\n<span>　<span style=\"font-size: 16px;\">　参考相关论文，自适应滤波器主要由FIR滤波器本体、参数自适应计算两部分组成。参数自适应计算部分是用来迭代计算滤波器系数的，它的输入是期望估计误差f、原始数据采样保存的向量U，输出是可变的FIR滤波器系数。FIR滤波器就是传统的有限冲击响应滤波器，可以是低通、高通等类型。所谓滤波器系数可变，指的是自适应算法根据动态变化的期望估计误差f和输入向量U，不停地进行迭代和更新FIR滤波器系数。有了自适应算法，FIR滤波器对动态误差的响应会更快，理论上噪声抑制效果也更好。</span></span>\n<p><img alt=\"image\" class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p style=\"text-align: center;\">图1 自适应滤波器架构</p>\n<p>　<span>　自适应算法有很多种，其中LMS最小均方差自适应滤波算法计算量比较小，所以我选择它用在自己的项目里。</span></p>\n<p><span>　　LMS自适应算法公式：</span></p>\n<p>　　<img alt=\"image\" class=\"lazyload\" height=\"34\" width=\"310\" /></p>\n<p><span>　　公式里的</span><img alt=\"image\" class=\"lazyload\" height=\"19\" width=\"28\" /><span>就是需要不断迭代的滤波器系数，M维向量；c和r都是常数；UT表示U的转置也是M维的向量；其他符号在图里面已经比较清楚。</span><span>这是一种可变更新步长的算法，因为U<sup>T</sup>U是变化的。</span></p>\n<p><span>　　如果用固定步长算法，那么公式就是：</span></p>\n<p>　　<img alt=\"image\" class=\"lazyload\" height=\"19\" width=\"247\" /></p>\n<p><span>　　这里面的h就是步长，相当于是一个固定的系数。</span></p>\n<p><span>　　可变步长算法的好处是收敛快，滤波器延时更小。</span></p>\n<h1><span style=\"font-size: 18px;\">2、实现流程</span></h1>\n<p><span>　　明白了原理，下面再设计滤波器的verilog实现方案。</span></p>\n<p><span>　　分析前面第1个公式，有加法、乘法、除法，还有M维的向量。做过FPGA算法的开发者应该有体会，向量和矩阵计算在verilog里面不太好实现，一般会把它转化成单个元素的计算，不然会占用太多资源，换种说法就是要把并行计算架构转成流水线形式的计算架构。这里面还需要关注的是参数向量B(n)和输入向量U(n)：如何表示这两个动态变化的向量，还有就是如何计算</span><img alt=\"image\" class=\"lazyload\" height=\"19\" width=\"30\" />。</p>\n<p><span>　　我选择用FIFO表示前面提到的几个M维向量，需要计算时就读FIFO中的数据，计算完成之后更新FIFO。至于</span><img alt=\"image\" class=\"lazyload\" height=\"19\" width=\"30\" />&nbsp;<span>，手动推导后可以看出它其实就是向量各元素的平方和，因此也可以用FIFO通过不断缓存</span><img alt=\"image\" class=\"lazyload\" height=\"21\" width=\"39\" /><span>以及动态累加的方式实现。</span></p>\n<p><span>　　基于FIFO的自适应算法架构如下图所示。</span></p>\n<p>　　</p>\n<p><img alt=\"image\" class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>&nbsp;</p>\n<p><span>　　图片画的不太简洁，用文字描述一下在FPGA中实现的过程。</span></p>\n<p><span>　　第一步：系统复位后先对<strong>FIFOA1</strong>和<strong>FIFOB1</strong>初始化，也就是先缓存得到一组向量B和向量U。</span></p>\n<p><span>　　第二步：初始化结束后，等待输入数据（滤波前）u和滤波后数据u1更新，然后FIFOCtrlB模块读FIFOA1的数据并参与计算流水线，动态累加模块读FIFOC以及新输入数据完成累加值更新并参与计算流水线，FIFOCTRLU模块读FIFOB1数据参与计算流水线。</span></p>\n<p><span>　　第三步：计算流水线完成乘法、加法全部计算过程，得到一个新的参数B(n+1)，FIFOCtrlB把这个新参数写入FIFOA2，以供下一轮计算使用，同时FIFOCTRLU模块把上一步参与计算流水线的数据写入FIFOB2，也是为了下一轮次计算使用。直到FIFOA1中的参数读完了也就是计算完了，与此同时FIFOB1也被读空了，相应的FIFOA2、FIFOB2也都写完成了，这一轮计算结束。</span></p>\n<p><span>　　下一轮计算时，FIFOA1和FIFOA2互换读写次序，FIFOB1、FIFOB2互换读写次序。循环往复。</span></p>\n<p><span>　　由于和都是常数，因此代入常数后就省掉了除法器，用乘法代替。</span></p>\n<p><span>　　自适应算法是滤波器最核心最难的部分，把这部分的输出直接接入FIR滤波器，就可以实现了自适应FIR滤波。至于FIR滤波器，用IP核就可以，不需要自行设计。当然也可以自己用逻辑和加法器、乘法器搭建FIR滤波器，这样可控性更好，不然还要去理解FIR的IP核的接口和参数的含义，也挺费事的。</span></p>\n<p><span>　　目前已经按照这个流程写好了verilog逻辑，后面会仿真测试，与MATLAB计算的结果比较一下，验证设计是否正确。</span></p>\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/y0011/\" target=\"_blank\">不高工程师</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/y0011/p/19394755/bugao123\" target=\"_blank\">https://www.cnblogs.com/y0011/p/19394755/bugao123</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 22:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/y0011\">不高工程师</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【大数据 & AI】Flink Agents 源码解读 --- (1) ---  设计",
      "link": "https://www.cnblogs.com/rossiXYZ/p/19369697",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rossiXYZ/p/19369697\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 20:21\">\n    <span>【大数据 &amp; AI】Flink Agents 源码解读 --- (1) ---  设计</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"大数据--aiflink-agents-源码解读-----1------设计\">【大数据 &amp; AI】Flink Agents 源码解读 --- (1) ---  设计</h1>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#大数据--aiflink-agents-源码解读-----1------设计\" rel=\"noopener nofollow\">【大数据 &amp; AI】Flink Agents 源码解读 --- (1) ---  设计</a><ul><li><a href=\"#0x00-概述\" rel=\"noopener nofollow\">0x00 概述</a></li><li><a href=\"#0x01-目标\" rel=\"noopener nofollow\">0x01 目标</a><ul><li><a href=\"#11-事件驱动的智能体\" rel=\"noopener nofollow\">1.1 事件驱动的智能体</a></li><li><a href=\"#12-典型应用场景\" rel=\"noopener nofollow\">1.2 典型应用场景</a></li><li><a href=\"#13-事件驱动智能体的技术要求\" rel=\"noopener nofollow\">1.3 事件驱动智能体的技术要求</a></li><li><a href=\"#14-核心设计理念\" rel=\"noopener nofollow\">1.4 核心设计理念</a></li><li><a href=\"#15-事件驱动编排架构\" rel=\"noopener nofollow\">1.5 事件驱动编排架构</a></li><li><a href=\"#16-技术展望\" rel=\"noopener nofollow\">1.6 技术展望</a></li></ul></li><li><a href=\"#0x02-设计分析\" rel=\"noopener nofollow\">0x02 设计分析</a><ul><li><a href=\"#21-flink-agents-要解决的核心问题\" rel=\"noopener nofollow\">2.1 Flink Agents 要解决的核心问题</a><ul><li><a href=\"#211-问题1单机局限\" rel=\"noopener nofollow\">2.1.1 问题1：单机局限</a></li><li><a href=\"#212-问题2异步--分阶段处理\" rel=\"noopener nofollow\">2.1.2 问题2：异步 / 分阶段处理</a></li><li><a href=\"#213-问题3适配鸿沟\" rel=\"noopener nofollow\">2.1.3 问题3：适配鸿沟</a></li><li><a href=\"#214-问题4状态一致性\" rel=\"noopener nofollow\">2.1.4 问题4：状态一致性</a></li><li><a href=\"#215-问题5兼容性\" rel=\"noopener nofollow\">2.1.5 问题5：兼容性</a></li></ul></li><li><a href=\"#22-针对问题的核心设计\" rel=\"noopener nofollow\">2.2 针对问题的核心设计</a><ul><li><a href=\"#221-问题1单机局限\" rel=\"noopener nofollow\">2.2.1 问题1：单机局限</a></li><li><a href=\"#222-问题2异步--分阶段处理\" rel=\"noopener nofollow\">2.2.2 问题2：异步 / 分阶段处理</a></li><li><a href=\"#223-问题3适配鸿沟\" rel=\"noopener nofollow\">2.2.3 问题3：适配鸿沟</a></li><li><a href=\"#224-问题4状态一致性\" rel=\"noopener nofollow\">2.2.4 问题4：状态一致性</a></li><li><a href=\"#225-问题5兼容性\" rel=\"noopener nofollow\">2.2.5 问题5：兼容性</a></li></ul></li><li><a href=\"#23-关键设计的落地示例\" rel=\"noopener nofollow\">2.3 关键设计的落地示例</a></li><li><a href=\"#24-总结\" rel=\"noopener nofollow\">2.4 总结</a></li></ul></li><li><a href=\"#0xff-参考\" rel=\"noopener nofollow\">0xFF 参考</a></li></ul></li></ul></div><p></p>\n<h2 id=\"0x00-概述\">0x00 概述</h2>\n<p>Flink Agents 是Apache Flink社区最近推出的一个全新的项目，一个专门为事件驱动场景设计的智能体框架。该项目聚焦事件驱动型AI智能体，结合Flink的实时处理能力，推动AI在工业场景中的工程化落地，涵盖智能运维、直播分析等典型应用，展现其在AI发展第四层次——智能体AI中的重要意义。</p>\n<p>本系列从源码入手，深入解析 / 反推 Flink Agents项目的架构设计。因为属于反推，肯定存在各种错误，还请大家不吝指出。</p>\n<h2 id=\"0x01-目标\">0x01 目标</h2>\n<p>本节内容 摘录于官方分享\"Flink Agents：基于Apache Flink的事件驱动AI智能体框架\"。</p>\n<p>在人工智能技术快速发展的今天，AI应用从简单的对话交互正在向更加复杂和智能化的方向演进。智能体AI就像给AI的\"大脑\"配上了\"身体\"。AI不仅能够思考和分析，还能够像人一样以特定目标为导向，自主分析应该采取什么行动。在这个过程中，AI可以主动获取所需的信息，查阅相关资料，甚至使用各种工具来真正对外界产生影响。</p>\n<h3 id=\"11-事件驱动的智能体\">1.1 事件驱动的智能体</h3>\n<p>Flink Agents项目专注于智能体AI的工程化实现。</p>\n<p>为什么Apache Flink社区还要开发一个新的框架呢？答案在于Flink Agents专注于一个特殊的应用场景——事件驱动的智能体。</p>\n<p>传统的AI应用大多属于对话式（Conversational）智能体，这种模式下用户通过对话框用自然语言描述问题或任务，然后让AI去执行。这是一种用户主动触发的交互模式，比如常见的 AI Coding、ChatBI、DeepResearch等产品都属于这一类型。</p>\n<p>与之相对的是事件驱动（Event-Driven）智能体，这种应用由系统自动产生的实时事件或数据更新来触发AI的处理过程。随着AI技术的发展和成熟，未来智能体的发展方向必然是工业化的，也就是说会有更多的AI请求由系统自动触发，而不需要人工手动操作。这个趋势就像数据分析领域的发展历程一样，从最初的人工编写SQL查询，发展到今天大量的OLAP分析都基于模板自动生成，能够达到每秒数百QPS的处理能力。</p>\n<h3 id=\"12-典型应用场景\">1.2 典型应用场景</h3>\n<p>一个典型应用场景是实时直播分析。在网络直播或直播带货过程中，热门直播间会产生大量的观众评论和弹幕。主播无法实时逐条阅读和分析所有内容，传统做法需要配备后台分析团队和导播来完成这项工作。</p>\n<p>通过事件驱动的AI智能体，系统可以实时分析最近几分钟内的所有弹幕评论，进行信息提取和汇总。比如识别出观众询问最多的问题，或者及时发现技术问题（如音画不同步、声音延迟等），让主播能够及时响应和解决。</p>\n<p>更进一步，结合多模态AI模型，系统还可以识别当前直播的主题和商品，分析观众的用户画像。基于这些分析结果，AI可以提供有价值的建议，比如根据观众的性别和年龄分布来调整商品推荐策略，或者根据观众的年龄特征来选择合适的背景音乐。</p>\n<h3 id=\"13-事件驱动智能体的技术要求\">1.3 事件驱动智能体的技术要求</h3>\n<p>事件驱动智能体的几个关键技术特点如下：</p>\n<ul>\n<li>\n<p>首先是实时性要求，事件产生后通常需要实时处理。其次是规模处理能力，系统自动触发的事件数量和频率远大于人工触发的请求，需要大规模分布式计算能力支撑。</p>\n</li>\n<li>\n<p>稳定性是另一个重要要求。与对话式智能体不同，事件驱动的智能体需要7×24小时长时间运行，没有人能够持续监控，因此必须具备强大的容错和自我恢复能力。数据处理能力也必不可少，因为在整个应用的端到端流程中，往往伴随着AI模型的非结构化处理和传统的结构化数据处理。</p>\n</li>\n<li>\n<p>最后是连接能力，需要能够从不同系统中消费各种实时事件。这些技术要求恰好与Apache Flink的核心能力高度吻合：毫秒级实时性、大规模分布式处理、状态管理和容错能力、丰富的数据处理功能，以及对主流存储系统的广泛支持。</p>\n</li>\n</ul>\n<h3 id=\"14-核心设计理念\">1.4 核心设计理念</h3>\n<p>Flink Agents的架构设计体现了几个核心设计理念。在智能体核心概念方面，沿用 AI Agent 的核心概念，对熟悉 Agent 的开发者没有额外学习成本。在API层面，项目支持Python和Java两种编程语言，同时提供不同接口来支持Workflow和ReAct两种编程模式。</p>\n<p><img alt=\"1-1\" class=\"lazyload\" /></p>\n<p>在生态系统方面，项目集成了市面上主流的模型提供商，支持MCP协议兼容以及Java、Python函数直接作为工具使用。对于向量存储等常用组件，也提供了相应的抽象和标准实现，同时支持用户自定义扩展。</p>\n<p>在运行时层面，项目提供了轻量级的Python运行时用于本地开发测试，以及基于完整Flink运行时的分布式版本，能够提供完整的分布式执行、状态管理、容错和端到端一致性保障。</p>\n<h3 id=\"15-事件驱动编排架构\">1.5 事件驱动编排架构</h3>\n<p><img alt=\"1-2\" class=\"lazyload\" /></p>\n<p>在智能体内部，Flink Agents采用了以事件为中心的编排方式。每个Agent由一系列Action组成，每个Action由特定的事件触发，同时在执行过程中也可以通过发出新的事件来触发其他Action的执行。</p>\n<p>这种架构提供了足够的灵活性，能够同时支持Workflow和ReAct两种主流的智能体开发方式。Workflow模式允许用户对智能体行为进行精细化控制，明确定义先做什么、后做什么，但编程复杂度相对较高。ReAct模式则将更多控制权交给AI模型，用户只需要指定模型版本、提示词和可用工具，其余工作交给AI自动处理。</p>\n<p>项目中提到的Action和事件既可以是框架内置的，也可以是用户自定义的，还支持两者混合使用。这种设计既支持框架本身的开发扩展，也满足了企业级应用中平台型部门提供通用库供业务部门使用的需求。</p>\n<p>所有智能体内部发生的事情都以事件为载体进行传递，框架甚至可以提供关于事件更新、Action执行开始和结束等元事件。结合这些事件信息，系统能够提供详细的事件日志来帮助用户理解智能体的执行过程，同时支持在线回调机制进行运行时监控。</p>\n<h3 id=\"16-技术展望\">1.6 技术展望</h3>\n<p>Flink Agents项目的推出标志着Apache Flink社区在AI领域的重要布局。通过将Flink强大的流处理能力与AI智能体技术相结合，为事件驱动的AI应用提供了一个工业级的解决方案。</p>\n<p>对于希望构建大规模、高可靠性AI应用的开发者和企业来说，Flink Agents提供了一个全新的技术选择。它不仅继承了Apache Flink在流处理领域的技术优势，还针对AI应用的特殊需求进行了专门的设计和优化，有望成为下一代AI应用开发的重要工具。</p>\n<h2 id=\"0x02-设计分析\">0x02 设计分析</h2>\n<p>既然初步了解了Flink Agents下面，我们来反推下其设计。看看 Flink Agents 框架的核心解决目标，以及针对这些问题的核心设计思路和具体方案，本质是理解该框架的 “问题 - 设计” 对应逻辑。</p>\n<p>Flink Agents 是基于 Flink 流处理能力构建的 Agent 运行时框架，核心解决<strong>传统 Agent 框架在分布式、高并发、流处理场景下的短板</strong>，同时适配 Agent 特有的 “事件驱动、动作执行、状态管理” 需求。以下是问题与设计的对应分析：</p>\n<h3 id=\"21-flink-agents-要解决的核心问题\">2.1 Flink Agents 要解决的核心问题</h3>\n<h4 id=\"211-问题1单机局限\">2.1.1 问题1：单机局限</h4>\n<p>传统 Agent 框架（如 LangChain、AutoGPT）多基于单机运行，存在 “单机局限”—— 无法应对大规模流数据 / 高并发事件。具体而言，传统 Agent 框架面对<strong>实时流数据（如用户指令流、设备事件流）</strong> 或高并发 Agent 调用时，存在如下问题：</p>\n<ul>\n<li>无法横向扩展，并发量受限；</li>\n<li>无内置的流处理能力，难以处理持续输入的事件流；</li>\n<li>缺乏分布式容错机制，单点故障导致 Agent 执行中断。</li>\n</ul>\n<h4 id=\"212-问题2异步--分阶段处理\">2.1.2 问题2：异步 / 分阶段处理</h4>\n<p>Agent 执行时存在 “异步 / 分阶段处理” 难题 —— 难以管理复杂动作的生命周期。具体而言，Agent 的核心是 “事件→决策→动作执行→结果反馈” 的循环，而动作执行常包含：</p>\n<ul>\n<li>异步操作（如调用外部 API、执行 Python 脚本）；</li>\n<li>分阶段任务（如先发起 HTTP 请求，等待响应后再处理）；</li>\n<li>动态生成后续任务（如一次决策触发多个动作）；</li>\n</ul>\n<p>传统框架难以标准化管理这类 “非原子化” 的动作执行，易出现任务丢失、状态混乱。</p>\n<h4 id=\"213-问题3适配鸿沟\">2.1.3 问题3：适配鸿沟</h4>\n<p>Agent 与流处理场景之间存在 “适配鸿沟”—— 原生 Flink 不支持 Agent 语义。具体而言，原生 Flink 是通用流处理引擎，缺乏 Agent 特有的语义抽象：</p>\n<ul>\n<li>无 “Agent”“Action（动作）”“Event（事件）” 的原生定义，用户需手动封装；</li>\n<li>无内置的 Agent 状态管理（如会话上下文、工具调用记录）；</li>\n<li>无工具 / 资源的统一注册与调度机制，需重复开发适配逻辑。</li>\n</ul>\n<h4 id=\"214-问题4状态一致性\">2.1.4 问题4：状态一致性</h4>\n<p>Agent 执行存在 “状态一致性” 问题 —— 分布式场景下状态易丢失 / 不一致。具体而言，Agent 执行过程中需维护：</p>\n<ul>\n<li>\n<p>短期状态（如当前会话的动作执行上下文）；</p>\n</li>\n<li>\n<p>长期状态（如 Agent 实例的运行状态、工具调用记录）；</p>\n</li>\n</ul>\n<p>传统分布式框架若直接适配 Agent，易出现状态分片混乱、故障恢复后状态丢失的问题。</p>\n<h4 id=\"215-问题5兼容性\">2.1.5 问题5：兼容性</h4>\n<p>目前仍存在“多语言动作执行”的兼容难题——Agent 的 Tool/Function 可能分别用 Java（高性能）或 Python（生态丰富）实现，传统框架暴露出两类弱点：</p>\n<ul>\n<li>进程通信或 RPC 需手工编写，开发成本高；</li>\n<li>缺乏统一的多语言任务调度器，易形成执行阻塞。</li>\n</ul>\n<h3 id=\"22-针对问题的核心设计\">2.2 针对问题的核心设计</h3>\n<h4 id=\"221-问题1单机局限\">2.2.1 问题1：单机局限</h4>\n<p>核心设计思路为：基于 Flink 分布式流处理内核，封装 Agent 语义的流处理能力。</p>\n<p>具体实现方案为：</p>\n<ul>\n<li><strong>Agent 作为流作业抽象</strong>：将 Agent 逻辑封装为 Flink DataStream 作业，天然支持横向扩展、并行执行；</li>\n<li><strong>事件驱动的流输入适配</strong>：定义 InputEvent / OutputEvent 等标准化事件，直接对接 Flink 的流数据输入，处理实时事件流；</li>\n<li><strong>Flink 原生容错</strong>：复用 Flink 的 Checkpoint/StateBackend 机制，实现 Agent 执行的故障恢复。</li>\n</ul>\n<h4 id=\"222-问题2异步--分阶段处理\">2.2.2 问题2：异步 / 分阶段处理</h4>\n<p>核心设计思路为：标准化 “动作执行 - 任务拆分 - 队列调度” 的生命周期管理。</p>\n<p>具体实现方案为：</p>\n<ul>\n<li><strong>ActionTask 原子化拆分</strong>：将复杂 Action 拆分为最小执行单元（ActionTask），支持异步 / 分阶段执行；</li>\n<li><strong>动态任务生成与队列管理</strong>：\n<ul>\n<li>ActionTask.invoke () 可返回新的 ActionTask，实现任务的动态扩展；</li>\n<li>基于 <code>ListState</code> 存储待执行任务，通过 Mailbox 机制调度，避免阻塞；</li>\n</ul>\n</li>\n<li><strong>任务执行闭环</strong>：<code>processActionTaskForKey</code> 实现 “执行→结果处理→新任务入队→循环调度”，确保任务不丢失。</li>\n</ul>\n<h4 id=\"223-问题3适配鸿沟\">2.2.3 问题3：适配鸿沟</h4>\n<p>核心设计思路为：抽象 Agent 核心语义层，适配原生 Flink 执行引擎。</p>\n<p>具体实现方案为：</p>\n<ul>\n<li><strong>核心语义抽象</strong>：\n<ul>\n<li><code>Agent</code>：封装 Agent 逻辑（动作、资源、事件绑定）；</li>\n<li><code>AgentPlan</code>：将 Agent 编译为 Flink 可执行的计划（对应 JobGraph）；</li>\n<li><code>Action</code>：定义 Agent 可执行的动作，通过 <code>@action</code> 装饰器绑定事件；</li>\n</ul>\n</li>\n<li><strong>事件 - 动作绑定机制</strong>：Action 与 Event 解耦绑定（如 <code>@action(UserCommandEvent)</code>），支持事件触发指定动作；</li>\n<li><strong>资源统一注册</strong>：通过 <code>ResourceProvider</code> 注册工具 / 资源（如 <code>menu_db</code>），Agent 按需获取，无需重复初始化。</li>\n</ul>\n<h4 id=\"224-问题4状态一致性\">2.2.4 问题4：状态一致性</h4>\n<p>核心设计思路为：基于 Flink 键控状态实现 Agent 状态隔离与持久化。</p>\n<p>具体实现方案为：</p>\n<ul>\n<li><strong>Keyed State 状态隔离</strong>：按 Agent 实例 / 会话 ID 作为 key，隔离不同 Agent 的状态（如上下文、任务队列）；</li>\n<li><strong>分层状态管理</strong>：\n<ul>\n<li>短期状态：<code>LocalRunnerContext</code> 存储会话级临时数据；</li>\n<li>长期状态：复用 Flink 的 StateBackend（如 RocksDB）持久化 Agent 运行状态；</li>\n</ul>\n</li>\n<li><strong>Checkpoint 状态快照</strong>：定期快照 Agent 状态，故障恢复时还原执行上下文。</li>\n</ul>\n<h4 id=\"225-问题5兼容性\">2.2.5 问题5：兼容性</h4>\n<p>核心设计思路为：统一的多语言 ActionTask 封装与调度。</p>\n<p>具体实现方案为：</p>\n<ul>\n<li><strong>多语言 ActionTask 实现</strong>：\n<ul>\n<li><code>JavaActionTask</code>：处理 Java 实现的 Action；</li>\n<li><code>PythonActionTask</code>：封装 Python 脚本执行，支持异步调用；</li>\n</ul>\n</li>\n<li><strong>跨语言通信标准化</strong>：通过结构化数据（JSON）传递参数 / 结果，避免语言间适配成本；</li>\n<li><strong>Python 生成器适配</strong>：<code>PythonGeneratorActionTask</code> 支持 Python 生成器的分阶段执行，适配异步场景。</li>\n</ul>\n<h3 id=\"23-关键设计的落地示例\">2.3 关键设计的落地示例</h3>\n<p>我们以 “用户发送‘显示菜单’指令” 为例，设计如何解决问题：</p>\n<ol>\n<li><strong>流处理适配</strong>：用户指令以事件形式进入 Flink 流，Agent 作业并行处理该事件流，支持高并发；</li>\n<li><strong>任务拆分</strong>：任务动作被封装为 <code>PythonActionTask</code>，执行时先获取 <code>menu_db</code> 资源（统一注册的资源），再发送 <code>MenuDisplayEvent</code>；</li>\n<li><strong>状态管理</strong>：按用户 ID 作为 key，隔离不同用户的菜单查询状态，Checkpoint 确保状态不丢失；</li>\n<li><strong>分布式执行</strong>：ActionExecutionOperator 运行在多个 TaskManager 上，横向扩展处理海量用户指令。</li>\n</ol>\n<h3 id=\"24-总结\">2.4 总结</h3>\n<ol>\n<li>Flink Agents 的核心目标是<strong>让 Agent 框架具备分布式、高并发、流处理能力</strong>，同时解决 Agent 特有的任务管理、状态一致性、多语言执行问题；</li>\n<li>核心设计逻辑是 <strong>“Agent 语义抽象 + Flink 原生能力复用”</strong>：既封装 Agent 所需的 Event/Action/State 语义，又复用 Flink 的分布式、容错、流处理内核；</li>\n<li>关键设计落地：ActionTask 解决任务拆分，ActionExecutionOperator 解决执行调度，Keyed State 解决状态一致性，多语言 ActionTask 解决跨语言执行。</li>\n</ol>\n<h2 id=\"0xff-参考\">0xFF 参考</h2>\n<p><a href=\"https://developer.aliyun.com/article/1681147\" rel=\"noopener nofollow\" target=\"_blank\">Flink Agents：基于Apache Flink的事件驱动AI智能体框架</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 20:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rossiXYZ\">罗西的思考</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于深度学习的学生上课行为检测系统演示与介绍(YOLOv12/v11/v8/v5模型+Pyqt5界面+训练代码+数据集)",
      "link": "https://www.cnblogs.com/codingtea/p/19394328",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/codingtea/p/19394328\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 19:24\">\n    <span>基于深度学习的学生上课行为检测系统演示与介绍(YOLOv12/v11/v8/v5模型+Pyqt5界面+训练代码+数据集)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"基于深度学习的学生上课行为检测系统演示与介绍(YOLOv12/v11/v8/v5模型+Pyqt5界面+训练代码+数据集)\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3687401/202512/3687401-20251224192354400-513900075.png\" />\n        本文介绍了一套基于YOLO深度学习算法的学生上课行为检测系统。该系统能自动识别低头、使用手机、举手等12种课堂行为，支持图片、视频和实时摄像头检测，检测结果可标注保存并导出Excel报表。系统采用PyQt5开发界面，支持多模型切换，包含用户管理和模型训练功能。实验对比显示，YOLO12n模型在3700张训练集上达到74.7%的mAP@0.5准确率，优于其他版本。该系统将传统课堂观察转化为量化分析，为智慧教育提供智能化解决方案。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2 id=\"%E8%A7%86%E9%A2%91%E6%BC%94%E7%A4%BA\">视频演示</h2>\n<p><a href=\"https://www.bilibili.com/video/BV1aT2jB1EFo\" rel=\"noopener nofollow\" target=\"_blank\">基于深度学习的学生上课行为检测系统</a></p>\n<h2>1. 前言​</h2>\n<p><span style=\"font-size: 16px;\">大家好，欢迎来到 Coding 茶水间。</span></p>\n<p><span style=\"font-size: 16px;\">在智慧教育的推进中，课堂管理正从“经验驱动”走向“数据驱动”。学生的上课行为——比如低头、使用手机、举手、睡觉等——不仅关系到学习效果，也影响课堂秩序与教学质量。传统观察方式难以全程、客观地记录与分析这些行为，而人工判别又易受主观因素影响。今天我们要介绍的项目，就是基于 <strong>YOLO 算法</strong>（文中误写为 ULO，实为 YOLO）的<strong>学生上课行为检测系统</strong>，它能自动识别学生在课堂中的多种行为，把原本依赖老师巡视的定性观察，转化为可量化、可回放的智能分析过程。</span></p>\n<p><span style=\"font-size: 16px;\">这套系统的主界面分为左、中、右三大功能区：左侧是操作入口，支持单图、视频、批量图片、摄像头实时检测，可切换模型与保存检测结果；中间是检测展示区，可调节置信度与交并比，实时显示检测耗时与目标数量，并用表格列出每个行为的详细信息；右侧负责统计与过滤，可按类别汇总行为数量，聚焦查看某一类行为的置信度与坐标，还支持将检测结果导出为 Excel，方便教学分析与反馈。</span></p>\n<p><span style=\"font-size: 16px;\">除了可视化检测，我们加入了登录与个人中心，可对账号信息、密码、头像进行管理；同时提供脚本化检测方式，无需界面即可批量处理图片、视频或摄像头画面；更有训练脚本，可按需配置模型数量、批次大小与训练轮次，用自己的课堂行为图像数据训练出更贴合实际场景的检测模型。训练结果会保存在指定目录，包含最佳权重文件、评估曲线与混淆矩阵，让模型表现透明可查。</span></p>\n<p><span style=\"font-size: 16px;\">接下来，我们会从界面布局讲到功能演示，再到脚本检测与模型训练，完整呈现这套“能看、能用、能改”的学生上课行为检测系统，希望它能让大家看到 YOLO 在教育场景智能化中的实用价值与研究趣味。</span></p>\n<h2 id=\"2.%20%E9%A1%B9%E7%9B%AE%E6%BC%94%E7%A4%BA\">2. 项目演示</h2>\n<h3 id=\"2.1%20%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2\">2.1&nbsp;<strong>用户登录界面</strong></h3>\n<p><span style=\"font-size: 16px;\">登录界面布局简洁清晰，左侧展示系统主题，用户需输入用户名、密码及验证码完成身份验证后登录系统。</span></p>\n<p><img alt=\"1\" class=\"lazyload\" /></p>\n<h3 id=\"2.2%20%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C\">2.2&nbsp;<strong>新用户注册</strong></h3>\n<p><span style=\"font-size: 16px;\">注册时可自定义用户名与密码，支持上传个人头像；如未上传，系统将自动使用默认头像完成账号创建。</span></p>\n<p><img alt=\"ScreenShot_2025-12-04_150932_707\" class=\"lazyload\" /></p>\n<h3 id=\"2.3%20%E4%B8%BB%E7%95%8C%E9%9D%A2\">2.3&nbsp;<strong>主界面布局</strong></h3>\n<p><span style=\"font-size: 16px;\">主界面采用三栏结构，左侧为功能操作区，中间用于展示检测画面，右侧呈现目标详细信息，布局合理，交互流畅。</span></p>\n<p><img alt=\"2\" class=\"lazyload\" /></p>\n<h3 id=\"2.4%20%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF\">2.4&nbsp;<strong>个人信息管理</strong></h3>\n<p><span style=\"font-size: 16px;\">用户可在此模块中修改密码或更换头像，个人信息支持随时更新与保存。</span></p>\n<p><img alt=\"ScreenShot_2025-12-04_151001_332\" class=\"lazyload\" /></p>\n<h3 id=\"2.5%20%E6%A3%80%E6%B5%8B%E5%8A%9F%E8%83%BD%E5%B1%95%E7%A4%BA\">2.5&nbsp;<strong>多模态检测展示</strong></h3>\n<p><span style=\"font-size: 16px;\">系统支持图片、视频及摄像头实时画面的目标检测。识别结果将在画面中标注显示，并在下方列表中逐项列出。点击具体目标可查看其类别、置信度及位置坐标等详细信息。</span></p>\n<p><img alt=\"3\" class=\"lazyload\" /></p>\n<h3>2.6 检测结果保存</h3>\n<p><span style=\"font-size: 16px;\">可以将检测后的图片、视频进行保存，生成新的图片和视频，新生成的图片和视频中会带有检测结果的标注信息，并且还可以将所有检测结果的数据信息保存到excel中进行，方便查看检测结果。</span></p>\n<p>&nbsp;</p>\n<h3 id=\"2.6%20%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9\">2.7&nbsp;<strong>多模型切换</strong></h3>\n<p><span style=\"font-size: 16px;\">系统内置多种已训练模型，用户可根据实际需求灵活切换，以适应不同检测场景或对比识别效果。</span></p>\n<p><img alt=\"ScreenShot_2025-12-04_154455_010\" class=\"lazyload\" /></p>\n<h2 id=\"3.%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81\">3.模型训练核心代码</h2>\n<p><span style=\"font-size: 16px;\">本脚本是YOLO模型批量训练工具，可自动修正数据集路径为绝对路径，从pretrained文件夹加载预训练模型，按设定参数（100轮/640尺寸/批次8）一键批量训练YOLOv5nu/v8n/v11n/v12n模型。</span></p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element highlighter-hljs\"><code># -*- coding: utf-8 -*-\n\"\"\"\n该脚本用于执行YOLO模型的训练。\n\n它会自动处理以下任务：\n1. 动态修改数据集配置文件 (data.yaml)，将相对路径更新为绝对路径，以确保训练时能正确找到数据。\n2. 从 'pretrained' 文件夹加载指定的预训练模型。\n3. 使用预设的参数（如epochs, imgsz, batch）启动训练过程。\n\n要开始训练，只需直接运行此脚本。\n\"\"\"\nimport os\nimport yaml\nfrom pathlib import Path\nfrom ultralytics import YOLO\n\ndef main():\n    \"\"\"\n    主训练函数。\n    \n    该函数负责执行YOLO模型的训练流程，包括：\n    1. 配置预训练模型。\n    2. 动态修改数据集的YAML配置文件，确保路径为绝对路径。\n    3. 加载预训练模型。\n    4. 使用指定参数开始训练。\n    \"\"\"\n    # --- 1. 配置模型和路径 ---\n    \n    # 要训练的模型列表\n    models_to_train = [\n        {'name': 'yolov5nu.pt', 'train_name': 'train_yolov5nu'},\n        {'name': 'yolov8n.pt', 'train_name': 'train_yolov8n'},\n        {'name': 'yolo11n.pt', 'train_name': 'train_yolo11n'},\n        {'name': 'yolo12n.pt', 'train_name': 'train_yolo12n'}\n    ]\n    \n    # 获取当前工作目录的绝对路径，以避免相对路径带来的问题\n    current_dir = os.path.abspath(os.getcwd())\n    \n    # --- 2. 动态配置数据集YAML文件 ---\n    \n    # 构建数据集yaml文件的绝对路径\n    data_yaml_path = os.path.join(current_dir, 'train_data', 'data.yaml')\n    \n    # 读取原始yaml文件内容\n    with open(data_yaml_path, 'r', encoding='utf-8') as f:\n        data_config = yaml.safe_load(f)\n    \n    # 将yaml文件中的 'path' 字段修改为数据集目录的绝对路径\n    # 这是为了确保ultralytics库能正确定位到训练、验证和测试集\n    data_config['path'] = os.path.join(current_dir, 'train_data')\n    \n    # 将修改后的配置写回yaml文件\n    with open(data_yaml_path, 'w', encoding='utf-8') as f:\n        yaml.dump(data_config, f, default_flow_style=False, allow_unicode=True)\n    \n    # --- 3. 循环训练每个模型 ---\n    \n    for model_info in models_to_train:\n        model_name = model_info['name']\n        train_name = model_info['train_name']\n        \n        print(f\"\\n{'='*60}\")\n        print(f\"开始训练模型: {model_name}\")\n        print(f\"训练名称: {train_name}\")\n        print(f\"{'='*60}\")\n        \n        # 构建预训练模型的完整路径\n        pretrained_model_path = os.path.join(current_dir, 'pretrained', model_name)\n        if not os.path.exists(pretrained_model_path):\n            print(f\"警告: 预训练模型文件不存在: {pretrained_model_path}\")\n            print(f\"跳过模型 {model_name} 的训练\")\n            continue\n        \n        try:\n            # 加载指定的预训练模型\n            model = YOLO(pretrained_model_path)\n            \n            # --- 4. 开始训练 ---\n            \n            print(f\"开始训练 {model_name}...\")\n            # 调用train方法开始训练\n            model.train(\n                data=data_yaml_path,  # 数据集配置文件\n                epochs=100,           # 训练轮次\n                imgsz=640,            # 输入图像尺寸\n                batch=8,             # 每批次的图像数量\n                name=train_name,      # 模型名称\n            )\n            \n            print(f\"{model_name} 训练完成！\")\n            \n        except Exception as e:\n            print(f\"训练 {model_name} 时出现错误: {str(e)}\")\n            print(f\"跳过模型 {model_name}，继续训练下一个模型\")\n            continue\n    \n    print(f\"\\n{'='*60}\")\n    print(\"所有模型训练完成！\")\n    print(f\"{'='*60}\")\n\nif __name__ == \"__main__\":\n    # 当该脚本被直接执行时，调用main函数\n    main()</code></pre>\n<span class=\"cke_reset cke_widget_drag_handler_container\"><img class=\"cke_reset cke_widget_drag_handler lazyload\" height=\"15\" width=\"15\" /></span></div>\n<h2 id=\"3.%20%E6%8A%80%E6%9C%AF%E6%A0%88\">4. 技术栈</h2>\n<ul>\n<li>\n<p><span style=\"font-size: 16px;\">语言：Python 3.10</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px;\">前端界面：PyQt5</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px;\">数据库：SQLite（存储用户信息）</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px;\">模型：YOLOv5、YOLOv8、YOLOv11、YOLOv12</span></p>\n</li>\n</ul>\n<h2 id=\"4.%20YOLO%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94%E4%B8%8E%E8%AF%86%E5%88%AB%E6%95%88%E6%9E%9C%E8%A7%A3%E6%9E%90\">5. YOLO模型对比与识别效果解析</h2>\n<h3 id=\"4.1%20YOLOv5%2FYOLOv8%2FYOLOv11%2FYOLOv12%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94\">5.1 YOLOv5/YOLOv8/YOLOv11/YOLOv12模型对比</h3>\n<p><span style=\"font-size: 16px;\">基于Ultralytics官方COCO数据集训练结果：</span></p>\n<table class=\"mceItemTable\">\n<thead>\n<tr>\n<th>\n<p><span style=\"font-size: 16px;\">模型</span></p>\n</th>\n<th>\n<p><span style=\"font-size: 16px;\">尺寸(像素)</span></p>\n</th>\n<th>\n<p><span style=\"font-size: 16px;\">mAPval 50-95</span></p>\n</th>\n<th>\n<p><span style=\"font-size: 16px;\">速度(CPU ONNX/毫秒)</span></p>\n</th>\n<th>\n<p><span style=\"font-size: 16px;\">参数(M)</span></p>\n</th>\n<th>\n<p><span style=\"font-size: 16px;\">FLOPs(B)</span></p>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<p><span style=\"font-size: 16px;\">YOLO12n</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">640</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">40.6</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">-</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">2.6</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">6.5</span></p>\n</td>\n</tr>\n<tr>\n<td>\n<p><span style=\"font-size: 16px;\">YOLO11n</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">640</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">39.5</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">56.1 ± 0.8</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">2.6</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">6.5</span></p>\n</td>\n</tr>\n<tr>\n<td>\n<p><span style=\"font-size: 16px;\">YOLOv8n</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">640</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">37.3</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">80.4</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">3.2</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">8.7</span></p>\n</td>\n</tr>\n<tr>\n<td>\n<p><span style=\"font-size: 16px;\">YOLOv5nu</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">640</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">34.3</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">73.6</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">2.6</span></p>\n</td>\n<td>\n<p><span style=\"font-size: 16px;\">7.7</span></p>\n</td>\n</tr>\n</tbody>\n</table>\n<p><span style=\"font-size: 16px;\"><strong>关键结论</strong>：</span></p>\n<ol>\n<li>\n<p><span style=\"font-size: 16px;\"><strong>精度最高</strong>：YOLO12n（mAP 40.6%），显著领先其他模型（较YOLOv5nu高约6.3个百分点）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px;\"><strong>速度最优</strong>：YOLO11n（CPU推理56.1ms），比YOLOv8n快42%，适合实时轻量部署；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px;\"><strong>效率均衡</strong>：YOLO12n/YOLO11n/YOLOv8n/YOLOv5nu参数量均为2.6M，FLOPs较低（YOLO12n/11n仅6.5B）；YOLOv8n参数量（3.2M）与计算量（8.7B）最高，但精度优势不明显。</span></p>\n</li>\n</ol>\n<p><span style=\"font-size: 16px;\"><strong>综合推荐</strong>：</span></p>\n<ul>\n<li>\n<p><span style=\"font-size: 16px;\">追求高精度：优先选YOLO12n（精度与效率兼顾）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px;\">需高速低耗：选YOLO11n（速度最快且精度接近YOLO12n）；</span></p>\n</li>\n<li>\n<p><span style=\"font-size: 16px;\">YOLOv5nu/YOLOv8n因性能劣势，无特殊需求时不建议首选。</span></p>\n</li>\n</ul>\n<h3 id=\"5.2%C2%A0%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%86%E6%9E%90\">5.2&nbsp;数据集分析</h3>\n<p><img alt=\"labels\" class=\"lazyload\" /></p>\n<p><span style=\"font-size: 16px;\">数据集中训练集和验证集一共3700张图片，数据集目标类别两种：正常肾脏，肾结石<span>，</span>数据集配置代码如下：</span></p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"language-xml highlighter-hljs\"><code>names:\n- Using_phone\n- bend\n- book\n- bow_head\n- hand-raising\n- phone\n- raise_head\n- reading\n- sleep\n- turn_head\n- upright\n- writing\nnc: 12\npath: D:\\project\\python\\yolo_Student_Posture_Detection\\train_data\ntest: ../test/images\ntrain: ../train/images\nval: ../valid/images</code></pre>\n</div>\n<p id=\"5.%20%E7%BB%93%E6%9D%9F%E8%AF%AD\">&nbsp;<img alt=\"train_batch0\" class=\"lazyload\" /></p>\n<p><img alt=\"train_batch1\" class=\"lazyload\" /></p>\n<p><span style=\"font-size: 16px;\">上面的图片就是部分样本集训练中经过数据增强后的效果标注。</span></p>\n<h3 id=\"5.3%20%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C\">5.3 训练结果</h3>\n<p><img alt=\"confusion_matrix_normalized\" class=\"lazyload\" /></p>\n<p><span style=\"font-size: 16px;\">混淆矩阵显示中识别精准度显示是一条对角线，方块颜色越深代表对应的类别识别的精准度越高<span>。</span></span></p>\n<p><img alt=\"BoxF1_curve\" class=\"lazyload\" /></p>\n<p><span style=\"font-size: 16px;\">F1指数（F1 Score）是统计学和机器学习中用于评估分类模型性能的核心指标，综合了模型的精确率（Precision）和召回率（Recall），通过调和平均数平衡两者的表现。&nbsp;</span></p>\n<p><span style=\"font-size: 16px;\">当置信度为0.366时，所有类别的综合F1值达到了0.73（蓝色曲线）。</span></p>\n<p><img alt=\"BoxPR_curve\" class=\"lazyload\" /></p>\n<p><span style=\"font-size: 16px;\">mAP@0.5：是目标检测任务中常用的评估指标，表示在交并比（IoU）阈值为0.5时计算的平均精度均值（mAP）。其核心含义是：只有当预测框与真实框的重叠面积（IoU）≥50%时，才认为检测结果正确。</span></p>\n<p><span style=\"font-size: 16px;\">图中可以看到综合mAP@0.5达到了0.747（74.7%），准确率非常高。</span></p>\n<h2 id=\"4.%20YOLO%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94%E4%B8%8E%E8%AF%86%E5%88%AB%E6%95%88%E6%9E%9C%E8%A7%A3%E6%9E%90\">6. 源码获取方式</h2>\n<p><span><a href=\"https://www.bilibili.com/video/BV1aT2jB1EFo\" rel=\"noopener nofollow\" target=\"_blank\">源码获取方式：https://www.bilibili.com/video/BV1aT2jB1EFo</a>​</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 19:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/codingtea\">Coding茶水间</a>&nbsp;\n阅读(<span id=\"post_view_count\">48</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "拒绝“裸奔”上线：FastAPI + Pytest 自动化测试实战指南",
      "link": "https://www.cnblogs.com/swizard/p/19394227",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/swizard/p/19394227\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 18:48\">\n    <span>拒绝“裸奔”上线：FastAPI + Pytest 自动化测试实战指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2>1. 引言：为什么你需要雇佣一群“机器人”？</h2>\n<p>你是否经历过这种绝望： 你刚刚修复了一个“用户无法登录”的 Bug，满怀信心地推上线。结果两分钟后，老板打电话吼道：“为什么现在的用户没法注册了？！”</p>\n<p>这就是典型的<strong>回归缺陷（Regression Bug）</strong>——修了旧的，坏了新的。</p>\n<p>手动测试（用 Postman 一个个点）就像是让主厨在每道菜端出去前都亲自尝一口。这在小餐馆（小项目）行得通，但如果是流水线工厂（大项目），主厨会被撑死，或者因为味觉疲劳而漏掉变质的菜。</p>\n<p><strong>自动化测试（Pytest）</strong> 就像是雇佣了一万个不知疲倦的机器人。你每改一行代码，它们就能在几秒钟内把所有菜品（API）全部尝一遍，并告诉你：“老板，酸辣汤（登录接口）咸了！”</p>\n<hr />\n<h2>2. 概念拆解：TestClient 与“替身演员”</h2>\n<p>FastAPI 的测试之所以简单，是因为它提供了一个神器：<code>TestClient</code>。</p>\n<h3>核心机制：TestClient</h3>\n<p>想象一下，通常你测试 API 需要启动服务器，然后用 HTTP 请求去撞它。 而 <code>TestClient</code> 是一种<strong>欺骗</strong>手段。它不需要真的启动网络服务，它直接通过 Python 代码调用你的 FastAPI 应用函数。</p>\n<ul>\n<li>\n<p><strong>速度极快</strong>：没有网络延迟。</p>\n</li>\n<li>\n<p><strong>同步写法</strong>：即使你的 API 是 <code>async</code> 的，测试代码也可以写成普通的同步代码（它是基于 <code>httpx</code> 的）。</p>\n</li>\n</ul>\n<h3>核心策略：依赖覆盖（Dependency Override）</h3>\n<p>这是 FastAPI 测试的杀手锏。还记得我们在“最佳实践”里提到的依赖注入吗？ 在测试时，我们不希望操作真实的生产数据库，也不希望真的发送短信验证码。 我们可以用<strong>替身（Mock/Override）</strong> 来替换掉真实的组件。</p>\n<hr />\n<h2>3. 动手实战：由浅入深</h2>\n<h3>3.0 准备工作</h3>\n<p>首先，我们需要安装测试界的“瑞士军刀”：</p>\n<div class=\"code-block ng-tns-c3098535048-140 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-140 ng-star-inserted\"><span class=\"ng-tns-c3098535048-140\">Bash</span>\n<div class=\"buttons ng-tns-c3098535048-140 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-140\">\n<div class=\"animated-opacity ng-tns-c3098535048-140\">\n<pre class=\"ng-tns-c3098535048-140 highlighter-hljs\"><code>pip install pytest httpx</code></pre>\n</div>\n</div>\n</div>\n<h3>3.1 Hello World 测试 (MVP)</h3>\n<p>假设你的 <code>main.py</code> 是这样的：</p>\n<div class=\"code-block ng-tns-c3098535048-141 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-141 ng-star-inserted\"><span class=\"ng-tns-c3098535048-141\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-141 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-141\">\n<div class=\"animated-opacity ng-tns-c3098535048-141\">\n<pre class=\"ng-tns-c3098535048-141 highlighter-hljs\"><code># main.py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def read_main():\n    return {\"msg\": \"Hello World\"}</code></pre>\n</div>\n</div>\n</div>\n<p>我们在同级目录下创建一个 <code>test_main.py</code>：</p>\n<div class=\"code-block ng-tns-c3098535048-142 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-142 ng-star-inserted\"><span class=\"ng-tns-c3098535048-142\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-142 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-142\">\n<div class=\"animated-opacity ng-tns-c3098535048-142\">\n<pre class=\"ng-tns-c3098535048-142 highlighter-hljs\"><code># test_main.py\nfrom fastapi.testclient import TestClient\nfrom main import app # 导入你的 app 对象\n\n# 1. 创建测试客户端\nclient = TestClient(app)\n\n# 2. 编写测试函数（必须以 test_ 开头）\ndef test_read_main():\n    # Act: 模拟发送请求\n    response = client.get(\"/\")\n    \n    # Assert: 断言（验证结果是否符合预期）\n    assert response.status_code == 200\n    assert response.json() == {\"msg\": \"Hello World\"}</code></pre>\n</div>\n</div>\n</div>\n<p><strong>运行测试：</strong> 在终端输入 <code>pytest</code>。你会看到迷人的绿色字体，显示测试通过。</p>\n<h3>3.2 进阶深潜：搞定数据库测试 (The Real Challenge)</h3>\n<p>这才是大多数人卡住的地方。如果 API 连了数据库，怎么测？ <strong>绝对不要连接生产库测试！</strong> 也不要连接开发库，因为测试产生的数据（比如 <code>test_user_1</code>）会污染环境。</p>\n<p><strong>解决方案</strong>：使用 <code>dependency_overrides</code> 将数据库替换为 SQLite 内存数据库（跑完即焚）。</p>\n<p>假设你的 <code>main.py</code> 依赖 <code>get_db</code>：</p>\n<div class=\"code-block ng-tns-c3098535048-143 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-143 ng-star-inserted\"><span class=\"ng-tns-c3098535048-143\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-143 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-143\">\n<div class=\"animated-opacity ng-tns-c3098535048-143\">\n<pre class=\"ng-tns-c3098535048-143 highlighter-hljs\"><code># app/dependencies.py\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()</code></pre>\n</div>\n</div>\n</div>\n<p>我们来编写一个高级的 <code>test_db.py</code>：</p>\n<div class=\"code-block ng-tns-c3098535048-144 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-144 ng-star-inserted\"><span class=\"ng-tns-c3098535048-144\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-144 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-144\">\n<div class=\"animated-opacity ng-tns-c3098535048-144\">\n<pre class=\"ng-tns-c3098535048-144 highlighter-hljs\"><code># test_db.py\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import StaticPool\n\nfrom main import app\nfrom app.dependencies import get_db\nfrom app.database import Base\n\n# 1. 创建一个临时的内存数据库（SQLite）\n# connect_args={\"check_same_thread\": False} 是 SQLite 的特殊配置\nSQLALCHEMY_DATABASE_URL = \"sqlite:///:memory:\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, \n    connect_args={\"check_same_thread\": False}, \n    poolclass=StaticPool # 确保测试过程中连接不中断\n)\nTestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# 2. 在测试开始前，把表结构建好\nBase.metadata.create_all(bind=engine)\n\n# 3. 定义新的依赖函数（替身）\ndef override_get_db():\n    try:\n        db = TestingSessionLocal()\n        yield db\n    finally:\n        db.close()\n\n# 4. 【关键步骤】告诉 FastAPI：当有人要 get_db 时，用 override_get_db 顶上去！\napp.dependency_overrides[get_db] = override_get_db\n\nclient = TestClient(app)\n\ndef test_create_user():\n    # 这一步请求，实际上是写到了内存数据库里，不会污染真实环境\n    response = client.post(\n        \"/users/\",\n        json={\"email\": \"test@example.com\", \"password\": \"securepassword\"},\n    )\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"email\"] == \"test@example.com\"\n    assert \"id\" in data</code></pre>\n</div>\n</div>\n</div>\n<p><strong>代码解析：</strong></p>\n<ul>\n<li>\n<p><code>sqlite:///:memory:</code>：这是一个存在于 RAM 中的数据库。测试结束，程序退出，它就彻底消失了，干干净净。</p>\n</li>\n<li>\n<p><code>app.dependency_overrides</code>：这是 FastAPI 专门为测试留的后门。它拦截了所有对 <code>get_db</code> 的调用，并将其重定向到我们的测试数据库。</p>\n</li>\n</ul>\n<hr />\n<h2>4. 最佳实践与常见陷阱</h2>\n<h3>陷阱一：测试顺序依赖</h3>\n<p><strong>错误</strong>：测试 A 创建了一个用户，测试 B 尝试登录这个用户。 <strong>问题</strong>：Pytest 默认是多线程或乱序执行的。如果 B 在 A 之前跑，就挂了。 <strong>解决</strong>：每个测试函数都应该是<strong>独立</strong>的。在每个测试开始前初始化数据，或者使用 Pytest 的 <code>fixture</code> 在测试结束后回滚事务。</p>\n<h3>技巧：使用 <code>conftest.py</code> 共享配置</h3>\n<p>不要在每个测试文件里都写一遍数据库配置。把通用的配置（比如 <code>client</code> 的初始化、数据库的 override）放到 <code>conftest.py</code> 文件中，Pytest 会自动识别并应用到所有测试。</p>\n<div class=\"code-block ng-tns-c3098535048-145 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-145 ng-star-inserted\"><span class=\"ng-tns-c3098535048-145\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-145 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-145\">\n<div class=\"animated-opacity ng-tns-c3098535048-145\">\n<pre class=\"ng-tns-c3098535048-145 highlighter-hljs\"><code># conftest.py (位于测试根目录)\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom main import app\n\n@pytest.fixture(scope=\"module\")\ndef client():\n    # 这里可以做一些 setup 工作\n    with TestClient(app) as c:\n        yield c\n    # 这里可以做一些 teardown 工作</code></pre>\n</div>\n</div>\n</div>\n<hr />\n<h2>5. 总结与延伸</h2>\n<h3>总结</h3>\n<ol start=\"1\">\n<li>\n<p><strong>TestClient</strong> 是 FastAPI 测试的核心，它快且方便。</p>\n</li>\n<li>\n<p><strong>Dependency Overrides</strong> 是解耦的关键，让你能用“假数据库”或“假服务”来测试逻辑。</p>\n</li>\n<li>\n<p><strong>自动化测试</strong> 是你重构代码时的安全网，让你敢于大刀阔斧地修改代码。</p>\n</li>\n</ol>\n<h3>课后小作业</h3>\n<p>回到你的项目中，创建一个 <code>tests</code> 文件夹。</p>\n<ol start=\"1\">\n<li>\n<p>写一个 <code>test_health_check</code>，测试你的 <code>/ping</code> 或 <code>/</code> 接口。</p>\n</li>\n<li>\n<p><strong>挑战题</strong>：尝试测试一个需要 Authentication（登录）的接口。你需要先在测试代码中调用登录接口获取 Token，然后把 Token 放入后续请求的 Header 中：</p>\n<div class=\"code-block ng-tns-c3098535048-146 ng-animate-disabled ng-trigger ng-trigger-codeBlockRevealAnimation\">\n<div class=\"code-block-decoration header-formatted gds-title-s ng-tns-c3098535048-146 ng-star-inserted\"><span class=\"ng-tns-c3098535048-146\">Python</span>\n<div class=\"buttons ng-tns-c3098535048-146 ng-star-inserted\">&nbsp;</div>\n</div>\n<div class=\"formatted-code-block-internal-container ng-tns-c3098535048-146\">\n<div class=\"animated-opacity ng-tns-c3098535048-146\">\n<pre class=\"ng-tns-c3098535048-146 highlighter-hljs\"><code>client.get(\"/users/me\", headers={\"Authorization\": f\"Bearer {token}\"})</code></pre>\n</div>\n</div>\n</div>\n</li>\n</ol>\n<p><strong>下一步</strong>：当你写好了测试，你肯定不想每次都要手动跑 <code>pytest</code>。你想了解如何利用 <strong>GitHub Actions (CI/CD)</strong>，在你每次 <code>git push</code> 代码时自动运行这些测试吗？这样你就可以在睡觉时也确保代码没崩了！</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 18:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/swizard\">Swizard</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "纯前端直连大模型 API，真的安全吗？",
      "link": "https://www.cnblogs.com/The-AI-Enthusiast/p/19394193",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/The-AI-Enthusiast/p/19394193\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 18:34\">\n    <span>纯前端直连大模型 API，真的安全吗？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在大模型应用刚兴起的时候，我也一度被“纯前端直连模型 API”这种方案吸引过：不需要后端、不需要部署服务，前端拿到 key 直接请求模型接口，几行代码就能跑起来，Demo 效果立竿见影。但当这种方案真正进入工程讨论，甚至被尝试放进测试环境后，问题很快暴露出来，而且几乎都绕不开“安全”这个核心主题。</p>\n<p>一、API Key 泄露几乎是必然事件<br />\n从工程角度看，只要 API Key 出现在前端环境，就意味着它已经不再是秘密。无论是写在代码里、放在构建产物中，还是通过环境变量注入，最终都会被打包进浏览器可访问的资源。即使做了混淆、压缩，熟悉前端调试的人依然可以通过 Network 面板、Source Map、甚至直接拦截请求轻松拿到 key。<br />\n很多人会寄希望于“低频使用”“内部项目”或“没人会注意”，但现实往往相反。一旦 key 泄露，风险并不会体现在功能异常上，而是体现在账单和配额消耗上，而且通常是滞后发现。</p>\n<p>二、配额滥用不是假设，而是常态<br />\nAPI Key 一旦暴露，就等于给了任何人“无限试错”的机会。你无法控制第三方如何使用这个 key：</p>\n<ul>\n<li>被脚本刷调用</li>\n<li>被嵌入到其他站点</li>\n<li>被当作“免费模型接口”传播</li>\n</ul>\n<p>从系统角度看，这类问题几乎无法通过前端手段解决。前端无法限制调用频率、无法区分真实用户和恶意请求，更无法基于业务逻辑做精细化控制。一旦出现异常消耗，往往只能通过整体吊销 key 来止损，代价是服务中断。</p>\n<p>三、所谓“前端代理”的常见误区</p>\n<p>有些方案看起来像是折中方案：在前端和模型 API 之间加一层“轻量代理”，但实际上只是把风险换了个位置。如果这个代理只是简单转发请求、不做鉴权、不校验来源、不限制调用频率，那么它本质上仍然是一个“公开接口”，只是从浏览器调用变成了 HTTP 调用。</p>\n<p>真正有意义的后端代理，至少需要承担以下职责：</p>\n<ul>\n<li>API Key 的安全托管</li>\n<li>基于用户或业务的权限控制</li>\n<li>请求限流与异常监控</li>\n<li>日志与审计能力</li>\n</ul>\n<p>如果这些能力缺失，那么“加一层代理”更多只是心理安慰，而不是工程上的安全设计。</p>\n<p>四、从 Demo 思维到工程思维的转变<br />\n纯前端直连模型 API 在 Demo 阶段并非完全不可接受，它的价值在于快速验证想法。但一旦系统进入可持续运行阶段，模型调用就已经成为后端资源的一部分，需要被纳入整体系统的安全、成本和稳定性管理中。此时，把关键调用放在后端，反而能让前端变得更简单、职责更清晰。</p>\n<p>在实验阶段，我用过 GPT Proto 提供的统一接口来快速对比不同模型的调用方式，但在最终方案中，依然选择将核心模型调用收敛到后端完成，这也是目前更稳妥、也更符合工程实践的做法。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 18:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/The-AI-Enthusiast\">冬未了</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【面试题】MySQL 中的索引数量是否越多越好？为什么？",
      "link": "https://www.cnblogs.com/sun-10387834/p/19371728",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19371728\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 16:16\">\n    <span>【面试题】MySQL 中的索引数量是否越多越好？为什么？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"️-mysql索引数量越多越好吗\">⚖️ MySQL索引：数量越多越好吗？</h1>\n<h2 id=\"-一句话答案\">🎯 一句话答案</h2>\n<p><strong>绝对不是！索引就像</strong>调料<strong>——</strong>放对了美味，放多了毁菜<strong>。</strong></p>\n<h2 id=\"-索引的代价为什么不能多\">📊 索引的代价（为什么不能多）</h2>\n<h3 id=\"1-写入性能急剧下降\"><strong>1. 写入性能急剧下降</strong></h3>\n<pre><code class=\"language-sql\">-- 假设表有5个索引，插入一条数据：\nINSERT INTO users (name, age, city, phone, email) \nVALUES ('张三', 25, '北京', '13800138000', 'zhangsan@example.com');\n\n-- 实际发生：\n主数据写入 1 次\n索引1写入 1 次\n索引2写入 1 次\n索引3写入 1 次\n索引4写入 1 次\n索引5写入 1 次\n</code></pre>\n<p><strong>总共：6次写入！每加一个索引，写入就多一次。</strong></p>\n<h3 id=\"2-更新删除变慢\"><strong>2. 更新/删除变慢</strong></h3>\n<pre><code class=\"language-sql\">UPDATE users SET city = '上海' WHERE id = 100;\n-- 如果city列有索引，需要：1.删除旧索引 2.插入新索引\n-- 多个索引时，每个涉及到的索引都要更新\n</code></pre>\n<h2 id=\"-索引的成本分析\">💰 索引的\"成本\"分析</h2>\n<h3 id=\"空间成本\"><strong>空间成本</strong></h3>\n<pre><code class=\"language-sql\">-- 查看索引占用空间\nSELECT \n    table_name,\n    index_name,\n    ROUND(index_length/1024/1024, 2) AS '索引大小(MB)',\n    ROUND(data_length/1024/1024, 2) AS '数据大小(MB)',\n    ROUND(index_length/data_length, 2) AS '索引/数据比'\nFROM information_schema.TABLES \nWHERE table_schema = 'your_db';\n\n-- 典型情况：\n-- 数据：100MB\n-- 1个索引：20MB\n-- 5个索引：100MB（和原始数据一样大！）\n</code></pre>\n<h3 id=\"时间成本对比\"><strong>时间成本对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>无索引</th>\n<th>1个索引</th>\n<th>5个索引</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插入1000条</td>\n<td>0.1秒</td>\n<td>0.2秒</td>\n<td>0.6秒</td>\n</tr>\n<tr>\n<td>更新100条</td>\n<td>0.05秒</td>\n<td>0.1秒</td>\n<td>0.4秒</td>\n</tr>\n<tr>\n<td>删除100条</td>\n<td>0.05秒</td>\n<td>0.08秒</td>\n<td>0.3秒</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"-索引过多的危害\">🚨 索引过多的危害</h2>\n<h3 id=\"1-优化器选择困难\"><strong>1. 优化器选择困难</strong></h3>\n<pre><code class=\"language-sql\">-- 假设表有10个索引，查询：\nSELECT * FROM users WHERE age &gt; 20 AND city = '北京';\n\n-- 优化器可能面临选择：\n-- idx_age (age)\n-- idx_city (city)  \n-- idx_age_city (age, city)\n-- idx_city_age (city, age)\n-- ...等等\n\n-- 选择过程消耗CPU，还可能选错索引！\n</code></pre>\n<h3 id=\"2-重复冗余索引\"><strong>2. 重复/冗余索引</strong></h3>\n<pre><code class=\"language-sql\">-- 常见重复索引：\nCREATE INDEX idx_a ON users(a);\nCREATE INDEX idx_a_b ON users(a, b);  -- idx_a是冗余的！\n\n-- 冗余索引：\nCREATE INDEX idx_b_a ON users(b, a);  -- 和idx_a_b顺序不同，可能都需要\nCREATE INDEX idx_a_b_c ON users(a, b, c);  -- 包含idx_a_b的功能\n</code></pre>\n<h3 id=\"3-内存浪费\"><strong>3. 内存浪费</strong></h3>\n<pre><code>MySQL缓冲池大小有限（比如4GB）\n\n理想情况：\n数据缓存：3GB\n索引缓存：1GB\n查询：快速\n\n索引过多时：\n数据缓存：2GB  \n索引缓存：2GB（大量不常用的索引占内存）\n查询：经常需要从磁盘读数据，变慢！\n</code></pre>\n<h2 id=\"-如何判断索引是否过多\">🔍 如何判断索引是否过多？</h2>\n<h3 id=\"健康指标检查\"><strong>健康指标检查</strong></h3>\n<pre><code class=\"language-sql\">-- 1. 索引与数据比例\n-- 健康：索引大小 &lt; 数据大小\n-- 危险：索引大小 &gt; 数据大小\n\n-- 2. 索引数量\n-- 小型表（&lt;10万行）：3-5个索引\n-- 中型表（10万-1000万）：5-8个索引  \n-- 大型表（&gt;1000万）：8-12个索引（需严格评估）\n\n-- 3. 索引使用率\nSELECT \n    object_schema,\n    object_name,\n    index_name,\n    rows_read,\n    rows_inserted,\n    rows_updated,\n    rows_deleted\nFROM performance_schema.table_io_waits_summary_by_index_usage\nWHERE index_name IS NOT NULL\nORDER BY rows_read DESC;\n\n-- 如果rows_read很低，说明索引很少被用\n</code></pre>\n<h3 id=\"找出无用索引\"><strong>找出无用索引</strong></h3>\n<pre><code class=\"language-sql\">-- MySQL 8.0+ 查看未使用索引\nSELECT * FROM sys.schema_unused_indexes;\n\n-- 手动分析（所有版本适用）\nSELECT \n    s.index_name,\n    s.table_name,\n    s.rows_selected,\n    s.rows_inserted,\n    s.rows_updated,\n    s.rows_deleted,\n    CASE \n        WHEN s.rows_selected &lt; 1000 THEN '考虑删除'\n        WHEN s.rows_selected &lt; 10000 THEN '观察'\n        ELSE '保留'\n    END AS recommendation\nFROM (\n    SELECT \n        OBJECT_NAME AS table_name,\n        INDEX_NAME AS index_name,\n        COUNT_READ AS rows_selected,\n        COUNT_INSERT AS rows_inserted,\n        COUNT_UPDATE AS rows_updated,\n        COUNT_DELETE AS rows_deleted\n    FROM performance_schema.table_io_waits_summary_by_index_usage\n    WHERE OBJECT_SCHEMA = DATABASE()\n) s\nWHERE rows_selected = 0 \n   OR (rows_selected &lt; 100 AND rows_updated &gt; 1000);\n</code></pre>\n<h2 id=\"-最佳索引数量策略\">🎯 最佳索引数量策略</h2>\n<h3 id=\"根据业务类型决定\"><strong>根据业务类型决定</strong></h3>\n<pre><code>OLTP系统（在线交易，频繁写）：\n  ✅ 索引要少而精（3-8个）\n  ✅ 只给高频查询建索引\n  ✅ 定期清理无用索引\n\nOLAP系统（分析报表，频繁读）：\n  ✅ 索引可以稍多（8-15个）\n  ✅ 覆盖多种查询模式\n  ✅ 但要注意维护成本\n</code></pre>\n<h3 id=\"索引优先级排序\"><strong>索引优先级排序</strong></h3>\n<pre><code class=\"language-sql\">-- 按重要性创建索引：\n1. 主键索引（必须有）            -- ⭐⭐⭐⭐⭐\n2. 唯一约束索引                  -- ⭐⭐⭐⭐⭐\n3. 高频查询的WHERE条件列         -- ⭐⭐⭐⭐\n4. 高频查询的JOIN条件列          -- ⭐⭐⭐⭐  \n5. 高频的ORDER BY/GROUP BY列     -- ⭐⭐⭐\n6. 覆盖索引（避免回表）           -- ⭐⭐⭐\n7. 全文索引（文本搜索）           -- ⭐⭐\n8. 低选择性列索引（如性别）       -- ⭐（通常不需要）\n</code></pre>\n<h2 id=\"-实战案例电商系统索引优化\">📝 实战案例：电商系统索引优化</h2>\n<h3 id=\"商品表优化前\"><strong>商品表优化前</strong></h3>\n<pre><code class=\"language-sql\">-- 有15个索引！\nCREATE TABLE products (\n    id INT PRIMARY KEY,\n    name VARCHAR(200),\n    category_id INT,\n    price DECIMAL(10,2),\n    stock INT,\n    status TINYINT,\n    created_time DATETIME,\n    updated_time DATETIME,\n    -- 各种单列索引\n    INDEX idx_name (name),\n    INDEX idx_category (category_id),\n    INDEX idx_price (price),\n    INDEX idx_stock (stock),\n    INDEX idx_status (status),\n    INDEX idx_created (created_time),\n    INDEX idx_updated (updated_time),\n    -- 各种组合索引\n    INDEX idx_cat_price (category_id, price),\n    INDEX idx_cat_status (category_id, status),\n    INDEX idx_price_status (price, status),\n    -- 还有重复冗余的...\n    INDEX idx_name_part (name(20)),  -- 和idx_name重复\n    INDEX idx_cat_price_stock (category_id, price, stock)\n);\n</code></pre>\n<p><strong>问题</strong>：写入慢，维护成本高，内存占用大。</p>\n<h3 id=\"优化后\"><strong>优化后</strong></h3>\n<pre><code class=\"language-sql\">-- 精简到6个核心索引\nCREATE TABLE products (\n    id INT PRIMARY KEY,\n    name VARCHAR(200),\n    category_id INT,\n    price DECIMAL(10,2),\n    stock INT,\n    status TINYINT,\n    created_time DATETIME,\n    updated_time DATETIME,\n    -- 1. 高频查询：按分类+价格排序\n    INDEX idx_cat_price_status (category_id, price, status),\n    -- 2. 高频查询：按状态+创建时间\n    INDEX idx_status_created (status, created_time),\n    -- 3. 名称搜索（前缀索引）\n    INDEX idx_name (name(50)),\n    -- 4. 库存预警\n    INDEX idx_stock_status (stock, status),\n    -- 5. 时间范围查询\n    INDEX idx_created (created_time),\n    -- 6. 管理后台复合查询\n    INDEX idx_cat_created (category_id, created_time)\n);\n</code></pre>\n<p><strong>效果</strong>：写入速度提升40%，内存占用减少60%，查询性能基本不变。</p>\n<h2 id=\"️-索引管理最佳实践\">🛠️ 索引管理最佳实践</h2>\n<h3 id=\"1-定期审计\"><strong>1. 定期审计</strong></h3>\n<pre><code class=\"language-sql\">-- 每月执行一次\n-- 检查索引使用情况\nSELECT * FROM sys.schema_unused_indexes;\n\n-- 检查重复索引\nSELECT \n    a.table_name,\n    a.index_name AS idx1,\n    b.index_name AS idx2,\n    a.column_name\nFROM information_schema.statistics a\nJOIN information_schema.statistics b \n    ON a.table_schema = b.table_schema\n    AND a.table_name = b.table_name\n    AND a.column_name = b.column_name\n    AND a.seq_in_index = b.seq_in_index\n    AND a.index_name != b.index_name\nWHERE a.table_schema = DATABASE();\n</code></pre>\n<h3 id=\"2-使用不可见索引测试\"><strong>2. 使用不可见索引测试</strong></h3>\n<pre><code class=\"language-sql\">-- MySQL 8.0+ 功能\n-- 先让索引不可见，观察影响\nALTER TABLE users ALTER INDEX idx_test INVISIBLE;\n\n-- 运行一段时间业务\n-- 如果没影响，再删除\nDROP INDEX idx_test ON users;\n</code></pre>\n<h3 id=\"3-监控写入性能\"><strong>3. 监控写入性能</strong></h3>\n<pre><code class=\"language-sql\">-- 监控索引对写入的影响\nSHOW GLOBAL STATUS LIKE 'Innodb_rows_inserted';\nSHOW GLOBAL STATUS LIKE 'Innodb_rows_updated';\nSHOW GLOBAL STATUS LIKE 'Innodb_rows_deleted';\n\n-- 计算索引维护成本\n-- 如果发现写入性能下降，考虑减少索引\n</code></pre>\n<h2 id=\"-黄金法则\">💡 黄金法则</h2>\n<h3 id=\"索引创建检查清单\"><strong>索引创建检查清单</strong></h3>\n<p>✅ 这个查询每天执行多少次？（&gt;100次考虑索引）<br />\n✅ 这个索引能覆盖多个查询吗？<br />\n✅ 表的主要操作是读还是写？<br />\n✅ 索引列的选择性高吗？（&gt;10%）<br />\n✅ 已有类似索引吗？（避免重复）<br />\n✅ 索引会占用多少空间？<br />\n✅ 维护成本能接受吗？</p>\n<h3 id=\"简单决策流程\"><strong>简单决策流程</strong></h3>\n<pre><code>新查询需要索引吗？\n    ↓\n每天执行超过100次？ → 否 → 不需要\n    ↓是\n有类似索引吗？ → 是 → 复用现有索引\n    ↓否  \n选择性 &gt; 10%？ → 否 → 可能不需要\n    ↓是\n表写入频繁吗？ → 是 → 谨慎评估\n    ↓否\n创建索引，监控效果\n</code></pre>\n<h2 id=\"-总结索引数量的平衡点\">📈 总结：索引数量的平衡点</h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>建议索引数</th>\n<th>理由</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>配置/字典表（&lt;1万行）</td>\n<td>0-2个</td>\n<td>数据少，全表扫描快</td>\n</tr>\n<tr>\n<td>用户表（10-100万）</td>\n<td>3-6个</td>\n<td>平衡读写</td>\n</tr>\n<tr>\n<td>订单表（&gt;1000万）</td>\n<td>5-8个</td>\n<td>写频繁，需谨慎</td>\n</tr>\n<tr>\n<td>日志/流水表（只读）</td>\n<td>可稍多</td>\n<td>主要是查询，写少</td>\n</tr>\n<tr>\n<td>数据仓库表</td>\n<td>6-12个</td>\n<td>复杂分析查询多</td>\n</tr>\n</tbody>\n</table>\n<p><strong>记住</strong>：<br />\n🔹 <strong>每个索引都是负债</strong>（维护成本）<br />\n🔹 <strong>只有高频查询才值得建索引</strong><br />\n🔹 <strong>定期清理就像定期大扫除</strong><br />\n🔹 <strong>质量 &gt; 数量</strong>（一个设计良好的复合索引顶三个单列索引）</p>\n<p><strong>最终建议</strong>：从核心查询开始，按需创建，定期评估，保持精简！</p>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19371728\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19371728</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 16:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">76</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "用 AI Vibe Coding - word-cards 自部署 TTS + Vercel 部署实践",
      "link": "https://www.cnblogs.com/neozhu/p/19393390",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/neozhu/p/19393390\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 16:16\">\n    <span>用 AI Vibe Coding - word-cards 自部署 TTS + Vercel 部署实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"用 AI Vibe Coding - word-cards 自部署 TTS + Vercel 部署实践\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/5997/202512/5997-20251224161539030-993228798.png\" />\n        这篇文章以我在 `word-cards` 项目中的真实开发节奏为主线：**先把“体验”做出来，再把“工程化”补齐**。重点讲三件事：  \n 1) AI vibe coding 的工作流怎么落地；2) 为什么要把 TTS 自己部署；3) 前端如何用 Vercel 稳定上线。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"用-ai-vibe-coding-把-word-cards-做到可上线自部署-tts--vercel-部署实践\">用 AI “Vibe Coding” 把 <code>word-cards</code> 做到可上线：自部署 TTS + Vercel 部署实践</h1>\n<blockquote>\n<p>这篇文章以我在 <code>word-cards</code> 项目中的真实开发节奏为主线：<strong>先把“体验”做出来，再把“工程化”补齐</strong>。重点讲三件事：</p>\n<ol>\n<li>AI vibe coding 的工作流怎么落地；2) 为什么要把 TTS 自己部署；3) 前端如何用 Vercel 稳定上线。</li>\n</ol>\n</blockquote>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/5997/202512/5997-20251224161428049-2082163795.png\" /></p>\n<h2 id=\"demo-httpsword-cardsblazorservercom\">Demo: <a href=\"https://word-cards.blazorserver.com/\" rel=\"noopener nofollow\" target=\"_blank\">https://word-cards.blazorserver.com/</a></h2>\n<h2 id=\"github-httpsgithubcomneozhuword-cards\">GitHub: <a href=\"https://github.com/neozhu/word-cards\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/neozhu/word-cards</a></h2>\n<hr />\n<h2 id=\"0-项目一句话介绍word-cards-是什么\">0. 项目一句话介绍：<code>word-cards</code> 是什么？</h2>\n<p><code>word-cards</code> 本质是一个“单词卡片”应用：给儿童/学习者展示单词、短句（phrase），并配合发音（TTS）提升记忆效率。</p>\n<p>项目数据有非常直观的结构（例如 <code>content.json</code>）：</p>\n<ul>\n<li>Key：卡片 id（如 <code>dog</code>、<code>lion_face</code>）</li>\n<li>Value：<code>word</code> + <code>phrase</code></li>\n</ul>\n<p>这种结构非常适合：</p>\n<ul>\n<li>快速迭代内容（只改 JSON 就能新增卡片）</li>\n<li>用 AI 辅助批量生成/润色 phrase</li>\n<li>与 TTS 天然对接：<code>word</code> 或 <code>phrase</code> 都可以直接读出来</li>\n</ul>\n<hr />\n<h2 id=\"1-我怎么用-ai-vibe-coding-推进开发\">1. 我怎么用 AI “Vibe Coding” 推进开发？</h2>\n<p>所谓 vibe coding，不是“全交给 AI”，而是把 AI 当成<strong>高频的结对搭档</strong>：<br />\n<strong>用最短路径把“可运行的体验”堆出来，再迭代到可维护、可部署。</strong></p>\n<p>我常用的节奏是 4 步循环：</p>\n<h3 id=\"11-先问我想要什么感觉\">1.1 先问“我想要什么感觉？”</h3>\n<p>不要一上来写架构文档，先定义体验目标，比如：</p>\n<ul>\n<li>打开页面：立刻看到卡片</li>\n<li>点击：立刻切下一张</li>\n<li>点喇叭：立即播报（最好有缓存，不要每次生成）</li>\n<li>手机上也顺畅（延迟、带宽都要考虑）</li>\n</ul>\n<h3 id=\"12-让-ai-给出最小可行路径mvp\">1.2 让 AI 给出“最小可行路径”（MVP）</h3>\n<p>典型产物是：</p>\n<ul>\n<li>页面组件怎么组织</li>\n<li>数据怎么读（<code>content.json</code>）</li>\n<li>TTS 是走浏览器 Web Speech 还是后端生成音频</li>\n</ul>\n<p>这一步的关键是：<strong>先能跑</strong>。哪怕方案不完美，但能验证“用户体验”是不是对的。</p>\n<h3 id=\"13-我负责约束边界成本风险\">1.3 我负责约束：边界、成本、风险</h3>\n<p>AI 很容易“建议上全家桶”。我会明确约束：</p>\n<ul>\n<li>Vercel Serverless 不适合重推理/长时任务</li>\n<li>TTS 音频要缓存，否则成本和延迟爆炸</li>\n<li>接口必须加限流/鉴权（至少防刷）</li>\n</ul>\n<h3 id=\"14-最后再让-ai-帮我补工程化\">1.4 最后再让 AI 帮我补工程化</h3>\n<p>当体验跑通后，再补：</p>\n<ul>\n<li>目录结构整理</li>\n<li>环境变量与部署文档</li>\n<li>API 错误处理</li>\n<li>缓存策略（本地/对象存储/CDN）</li>\n</ul>\n<hr />\n<h2 id=\"2-为什么我要自部署-tts而不是全放在-vercel\">2. 为什么我要“自部署 TTS”？（而不是全放在 Vercel）</h2>\n<h3 id=\"21-纯浏览器-ttsweb-speech的问题\">2.1 纯浏览器 TTS（Web Speech）的问题</h3>\n<p>优点：零后端、最快上线。<br />\n缺点也很明显：</p>\n<ul>\n<li>不同浏览器/系统音色差异巨大</li>\n<li>有的环境不可用或权限麻烦</li>\n<li>不能稳定复现“同一句话”的音频（不利于缓存、分享、离线）</li>\n</ul>\n<h3 id=\"22-让-vercel-来跑-tts通常不划算\">2.2 让 Vercel 来跑 TTS？通常不划算</h3>\n<p>即便你用 Serverless Function 调第三方 TTS，仍可能遇到：</p>\n<ul>\n<li>冷启动 + 生成耗时 → 体验抖动</li>\n<li>生成音频属于“重任务”，并发上来容易被限</li>\n<li>成本不可控（按量计费的 TTS + 频繁请求）</li>\n</ul>\n<h3 id=\"23-自部署-tts把重活从前端平台拆出去\">2.3 自部署 TTS：把“重活”从前端平台拆出去</h3>\n<p>我更倾向的落地方式：</p>\n<ul>\n<li><strong>Vercel：只负责前端与轻量 API（业务编排）</strong></li>\n<li><strong>自建 TTS 服务：负责生成音频（CPU/GPU 都可）</strong></li>\n<li><strong>缓存层：存储音频文件，尽量走 CDN</strong></li>\n</ul>\n<p>这样做的收益是：</p>\n<ul>\n<li>延迟更稳定（尤其是命中缓存时）</li>\n<li>费用结构清晰（算力/带宽自己掌控）</li>\n<li>可定制音色、采样率、语速、发音规则</li>\n</ul>\n<hr />\n<h2 id=\"3-一个可落地的整体架构适配-word-cards-这类应用\">3. 一个可落地的整体架构（适配 <code>word-cards</code> 这类应用）</h2>\n<h3 id=\"31-核心路径从卡片到声音\">3.1 核心路径：从卡片到声音</h3>\n<ol>\n<li>前端展示 <code>content.json</code> 的 <code>word/phrase</code></li>\n<li>用户点击“播放”</li>\n<li>前端请求：<code>/api/tts?text=...</code>（或直接请求你的 TTS 服务）</li>\n<li>后端逻辑：\n<ul>\n<li>计算文本 hash（例如 <code>sha1(text + voice + speed)</code>）</li>\n<li>查缓存（对象存储/本地磁盘/Redis）</li>\n<li>未命中则调用 TTS 引擎生成音频</li>\n<li>存储并返回音频 URL（或直接返回音频流）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"32-缓存策略建议决定体验上限\">3.2 缓存策略建议（决定体验上限）</h3>\n<ul>\n<li>强烈建议做“可重复命中”的缓存：同一句 <code>phrase</code> 每次生成应该得到同一份缓存文件</li>\n<li>文件命名使用 hash，避免中文路径和特殊字符问题</li>\n<li>返回时尽量给可缓存响应头（<code>Cache-Control</code>），让浏览器/CDN 吃满缓存</li>\n</ul>\n<hr />\n<h2 id=\"4-自部署-tts我会怎么做docker--独立服务\">4. 自部署 TTS：我会怎么做（Docker + 独立服务）</h2>\n<p>这里不绑定某一种引擎，你可以选：</p>\n<ul>\n<li><strong>Piper</strong>：轻量、CPU 友好、部署简单</li>\n<li><strong>Coqui TTS</strong>：可玩性高，但资源占用更大</li>\n<li><strong>系统/云厂商 TTS</strong>：省维护，但成本与依赖更强</li>\n</ul>\n<p>一个实用的“工程形态”是：</p>\n<ul>\n<li>用 Docker 跑一个 HTTP 服务（<code>/synthesize</code>）</li>\n<li>输入：<code>text, voice, speed, format</code></li>\n<li>输出：音频文件或音频流（wav/mp3）</li>\n</ul>\n<p>Windows 本地开发常用命令（示意）：</p>\n<pre><code class=\"language-bash\"># 1) 本地启动前端（示意）\nnpm run dev\n\n# 2) 启动自部署 TTS（示意，按你的实现调整）\ndocker compose up -d\n</code></pre>\n<p>生产部署建议：</p>\n<ul>\n<li>把 TTS 放到 VPS（Linux）或家用小主机（注意上行带宽）</li>\n<li>用 Nginx/Caddy 做反代 + HTTPS</li>\n<li>给 TTS 接口做最小保护（token 或仅允许你的前端域名访问）</li>\n</ul>\n<hr />\n<h2 id=\"5-vercel-部署我踩过的现实问题\">5. Vercel 部署：我踩过的“现实问题”</h2>\n<h3 id=\"51-vercel-擅长什么\">5.1 Vercel 擅长什么？</h3>\n<ul>\n<li>静态资源/CDN 分发</li>\n<li>Next.js 前端与轻量 API</li>\n<li>快速预览环境（PR Preview）</li>\n</ul>\n<h3 id=\"52-vercel-不擅长什么\">5.2 Vercel 不擅长什么？</h3>\n<ul>\n<li>长时间运行任务（TTS/转码/大文件处理）</li>\n<li>高 CPU 推理（成本和限制都不友好）</li>\n<li>需要本地磁盘持久化的缓存（Serverless 天生不稳定）</li>\n</ul>\n<p>所以我的原则是：<br />\n<strong>Vercel 用来“接住用户与页面”，TTS 用独立服务“把重活做完”。</strong></p>\n<h3 id=\"53-环境变量与跨域\">5.3 环境变量与跨域</h3>\n<p>你通常需要这些变量（示意）：</p>\n<pre><code class=\"language-txt\">TTS_BASE_URL=https://tts.example.com\nTTS_TOKEN=********\n</code></pre>\n<p>前端调用方式两种：</p>\n<ul>\n<li>前端直接请求 TTS（要处理 CORS、token 暴露风险）</li>\n<li>前端请求 Vercel API，再由 API 转发到 TTS（更安全、可加限流与缓存策略）</li>\n</ul>\n<p>一般更建议第二种：<strong>把 token 留在服务端</strong>。</p>\n<hr />\n<h2 id=\"6-ai--内容在-word-cards-的增益点\">6. “AI + 内容”在 <code>word-cards</code> 的增益点</h2>\n<p>像 <code>content.json</code> 这种结构非常适合 AI 参与：</p>\n<ul>\n<li>批量生成 phrase（控制难度、长度、词汇覆盖）</li>\n<li>统一风格（例如都用现在时、句子长度 6~10 个词）</li>\n<li>纠错与去重（避免 phrase 重复、语法问题）</li>\n<li>生成多语言版本（后续做中英双语卡片也很自然）</li>\n</ul>\n<p>人工底线建议保留两条：</p>\n<ul>\n<li><strong>可读性与年龄段适配</strong>（AI 容易写得太“成人化”）</li>\n<li><strong>TTS 可读性</strong>（缩写、数字、特殊符号要规范化）</li>\n</ul>\n<hr />\n<h2 id=\"7-结语vibe-coding-的正确打开方式\">7. 结语：vibe coding 的正确打开方式</h2>\n<ul>\n<li>vibe coding 最强的地方是<strong>把“从 0 到 1 的阻力”打穿</strong></li>\n<li>真正上线、可维护、可扩展，还是要回到工程常识：<strong>分层、缓存、限流、部署边界</strong></li>\n</ul>\n<p><code>word-cards</code> 这类项目尤其适合：<br />\n<strong>内容驱动 + 体验优先 + TTS 拆分部署 + Vercel 前端加速</strong>，快速做出“像产品”的效果。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 16:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/neozhu\">阿新</a>&nbsp;\n阅读(<span id=\"post_view_count\">38</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "关于Agentic AI的一些总结和思考",
      "link": "https://www.cnblogs.com/tianqing/p/19392908",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tianqing/p/19392908\" id=\"cb_post_title_url\" title=\"发布于 2025-12-24 15:07\">\n    <span>关于Agentic AI的一些总结和思考</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>引用Google Gemini的释义：</p>\n<p>Agentic AI frameworks are&nbsp;software toolkits that provide structure, components, and protocols for building autonomous AI agents that can reason, plan, and act to achieve goals, streamlining development with features like memory, tool integration (APIs), and multi-agent orchestration, with popular examples including&nbsp;<span class=\"Yjhzub\"><a class=\"GI370e\" href=\"https://www.google.com/search?q=AutoGen&amp;sca_esv=1a5899b9da7a2cf9&amp;sxsrf=AE3TifPdjtqWcQWWKJzHfYKuBTeM_d06Sw%3A1766554845653&amp;ei=3XxLaerTJ6aa2roPtPjfsQw&amp;oq=agentic+ai+&amp;gs_lp=Egxnd3Mtd2l6LXNlcnAiC2FnZW50aWMgYWkgKgIIADIFEAAYgAQyCBAAGIAEGLEDMgUQABiABDIFEAAYgAQyCBAAGIAEGLEDMgUQABiABDIIEAAYgAQYsQMyBRAAGIAEMgUQABiABDIOEAAYgAQYsQMYgwEYigVIiDFQAFj7H3ACeAGQAQGYAdUEoAGeIaoBCzEuMS44LjMuMS4xuAEDyAEA-AEBmAIOoAKvGMICChAjGIAEGCcYigXCAg4QLhiABBiRAhjlBBiKBcICChAAGIAEGEMYigXCAhAQLhiABBjRAxhDGMcBGIoFwgIREC4YgAQYsQMY0QMYgwEYxwHCAgsQLhiABBjRAxjHAcICBBAjGCfCAgsQABiABBiRAhiKBcICChAuGIAEGEMYigXCAg4QLhiABBixAxiDARiKBcICCxAAGIAEGLEDGIMBwgINEAAYgAQYsQMYQxiKBcICEBAAGIAEGLEDGEMYgwEYigXCAggQABiABBjLAcICBhAAGBYYHsICCxAAGIAEGIYDGIoFmAMAkgcJMy4wLjguMi4xoAfuerIHCTEuMC44LjIuMbgHpBjCBwcwLjQuOS4xyAc7gAgA&amp;sclient=gws-wiz-serp&amp;mstk=AUtExfDPsRmUCCqYRf1z4hR47f-IwwEuYRFX2OKsILw8umm3nminB4CzBn65R6CK-ilCBFb9-pCDDoTFRcrJ5d0-RSl9325C75-06QwictOXteEoAeXEX_pYPAjrvLQXoLhHNI1IiMUxzeyDF6dHcDFVMexUlGhyRKx3Tju8I2I6CV0P8uQ&amp;csui=3&amp;ved=2ahUKEwjz1py109WRAxWUklYBHXX2AzwQgK4QegQIARAC\" rel=\"noopener nofollow\">AutoGen</a>,&nbsp;<span class=\"Yjhzub\">CrewAI,&nbsp;<span class=\"Yjhzub\">LangGraph, and&nbsp;<span class=\"Yjhzub\"><a class=\"GI370e\" href=\"https://www.google.com/search?q=Semantic+Kernel&amp;sca_esv=1a5899b9da7a2cf9&amp;sxsrf=AE3TifPdjtqWcQWWKJzHfYKuBTeM_d06Sw%3A1766554845653&amp;ei=3XxLaerTJ6aa2roPtPjfsQw&amp;oq=agentic+ai+&amp;gs_lp=Egxnd3Mtd2l6LXNlcnAiC2FnZW50aWMgYWkgKgIIADIFEAAYgAQyCBAAGIAEGLEDMgUQABiABDIFEAAYgAQyCBAAGIAEGLEDMgUQABiABDIIEAAYgAQYsQMyBRAAGIAEMgUQABiABDIOEAAYgAQYsQMYgwEYigVIiDFQAFj7H3ACeAGQAQGYAdUEoAGeIaoBCzEuMS44LjMuMS4xuAEDyAEA-AEBmAIOoAKvGMICChAjGIAEGCcYigXCAg4QLhiABBiRAhjlBBiKBcICChAAGIAEGEMYigXCAhAQLhiABBjRAxhDGMcBGIoFwgIREC4YgAQYsQMY0QMYgwEYxwHCAgsQLhiABBjRAxjHAcICBBAjGCfCAgsQABiABBiRAhiKBcICChAuGIAEGEMYigXCAg4QLhiABBixAxiDARiKBcICCxAAGIAEGLEDGIMBwgINEAAYgAQYsQMYQxiKBcICEBAAGIAEGLEDGEMYgwEYigXCAggQABiABBjLAcICBhAAGBYYHsICCxAAGIAEGIYDGIoFmAMAkgcJMy4wLjguMi4xoAfuerIHCTEuMC44LjIuMbgHpBjCBwcwLjQuOS4xyAc7gAgA&amp;sclient=gws-wiz-serp&amp;mstk=AUtExfDPsRmUCCqYRf1z4hR47f-IwwEuYRFX2OKsILw8umm3nminB4CzBn65R6CK-ilCBFb9-pCDDoTFRcrJ5d0-RSl9325C75-06QwictOXteEoAeXEX_pYPAjrvLQXoLhHNI1IiMUxzeyDF6dHcDFVMexUlGhyRKx3Tju8I2I6CV0P8uQ&amp;csui=3&amp;ved=2ahUKEwjz1py109WRAxWUklYBHXX2AzwQgK4QegQIARAD\" rel=\"noopener nofollow\">Semantic Kernel</a>, enabling complex automation beyond simple prompts.<span class=\"uJ19be notranslate\"><span class=\"vKEkVd\">&nbsp;</span></span></span></span></span></span></p>\n<div class=\"otQkpb\">Core Components &amp; Capabilities</div>\n<ul class=\"KsbFXc U6u95\">\n<li><span class=\"T286Pc\"><span class=\"Yjhzub\"><a class=\"GI370e\" href=\"https://www.google.com/search?q=Planning+%26+Reasoning&amp;sca_esv=1a5899b9da7a2cf9&amp;sxsrf=AE3TifPdjtqWcQWWKJzHfYKuBTeM_d06Sw%3A1766554845653&amp;ei=3XxLaerTJ6aa2roPtPjfsQw&amp;oq=agentic+ai+&amp;gs_lp=Egxnd3Mtd2l6LXNlcnAiC2FnZW50aWMgYWkgKgIIADIFEAAYgAQyCBAAGIAEGLEDMgUQABiABDIFEAAYgAQyCBAAGIAEGLEDMgUQABiABDIIEAAYgAQYsQMyBRAAGIAEMgUQABiABDIOEAAYgAQYsQMYgwEYigVIiDFQAFj7H3ACeAGQAQGYAdUEoAGeIaoBCzEuMS44LjMuMS4xuAEDyAEA-AEBmAIOoAKvGMICChAjGIAEGCcYigXCAg4QLhiABBiRAhjlBBiKBcICChAAGIAEGEMYigXCAhAQLhiABBjRAxhDGMcBGIoFwgIREC4YgAQYsQMY0QMYgwEYxwHCAgsQLhiABBjRAxjHAcICBBAjGCfCAgsQABiABBiRAhiKBcICChAuGIAEGEMYigXCAg4QLhiABBixAxiDARiKBcICCxAAGIAEGLEDGIMBwgINEAAYgAQYsQMYQxiKBcICEBAAGIAEGLEDGEMYgwEYigXCAggQABiABBjLAcICBhAAGBYYHsICCxAAGIAEGIYDGIoFmAMAkgcJMy4wLjguMi4xoAfuerIHCTEuMC44LjIuMbgHpBjCBwcwLjQuOS4xyAc7gAgA&amp;sclient=gws-wiz-serp&amp;mstk=AUtExfDPsRmUCCqYRf1z4hR47f-IwwEuYRFX2OKsILw8umm3nminB4CzBn65R6CK-ilCBFb9-pCDDoTFRcrJ5d0-RSl9325C75-06QwictOXteEoAeXEX_pYPAjrvLQXoLhHNI1IiMUxzeyDF6dHcDFVMexUlGhyRKx3Tju8I2I6CV0P8uQ&amp;csui=3&amp;ved=2ahUKEwjz1py109WRAxWUklYBHXX2AzwQgK4QegQIBBAB\" rel=\"noopener nofollow\">Planning &amp; Reasoning</a>:&nbsp;Breaking down tasks, selecting tools, tracking progress.</span></span></li>\n<li><span class=\"T286Pc\"><span class=\"Yjhzub\"><a class=\"GI370e\" href=\"https://www.google.com/search?q=Autonomy&amp;sca_esv=1a5899b9da7a2cf9&amp;sxsrf=AE3TifPdjtqWcQWWKJzHfYKuBTeM_d06Sw%3A1766554845653&amp;ei=3XxLaerTJ6aa2roPtPjfsQw&amp;oq=agentic+ai+&amp;gs_lp=Egxnd3Mtd2l6LXNlcnAiC2FnZW50aWMgYWkgKgIIADIFEAAYgAQyCBAAGIAEGLEDMgUQABiABDIFEAAYgAQyCBAAGIAEGLEDMgUQABiABDIIEAAYgAQYsQMyBRAAGIAEMgUQABiABDIOEAAYgAQYsQMYgwEYigVIiDFQAFj7H3ACeAGQAQGYAdUEoAGeIaoBCzEuMS44LjMuMS4xuAEDyAEA-AEBmAIOoAKvGMICChAjGIAEGCcYigXCAg4QLhiABBiRAhjlBBiKBcICChAAGIAEGEMYigXCAhAQLhiABBjRAxhDGMcBGIoFwgIREC4YgAQYsQMY0QMYgwEYxwHCAgsQLhiABBjRAxjHAcICBBAjGCfCAgsQABiABBiRAhiKBcICChAuGIAEGEMYigXCAg4QLhiABBixAxiDARiKBcICCxAAGIAEGLEDGIMBwgINEAAYgAQYsQMYQxiKBcICEBAAGIAEGLEDGEMYgwEYigXCAggQABiABBjLAcICBhAAGBYYHsICCxAAGIAEGIYDGIoFmAMAkgcJMy4wLjguMi4xoAfuerIHCTEuMC44LjIuMbgHpBjCBwcwLjQuOS4xyAc7gAgA&amp;sclient=gws-wiz-serp&amp;mstk=AUtExfDPsRmUCCqYRf1z4hR47f-IwwEuYRFX2OKsILw8umm3nminB4CzBn65R6CK-ilCBFb9-pCDDoTFRcrJ5d0-RSl9325C75-06QwictOXteEoAeXEX_pYPAjrvLQXoLhHNI1IiMUxzeyDF6dHcDFVMexUlGhyRKx3Tju8I2I6CV0P8uQ&amp;csui=3&amp;ved=2ahUKEwjz1py109WRAxWUklYBHXX2AzwQgK4QegQIBBAD\" rel=\"noopener nofollow\">Autonomy</a>:&nbsp;Operating independently, adjusting strategies.</span></span></li>\n<li><span class=\"T286Pc\"><span class=\"Yjhzub\">Memory:&nbsp;Retaining context and past actions for better reasoning.</span></span></li>\n<li><span class=\"T286Pc\"><span class=\"Yjhzub\">Tool Integration:&nbsp;Accessing external APIs, databases, and systems.</span></span></li>\n<li><span class=\"T286Pc\"><span class=\"Yjhzub\">Multi-Agent Orchestration:&nbsp;Coordinating multiple agents for complex workflows.</span></span></li>\n<li><span class=\"T286Pc\"><span class=\"Yjhzub\">Human-AI Interaction:&nbsp;Interfaces for feedback and oversight.<span class=\"uJ19be notranslate\"><span class=\"vKEkVd\">&nbsp;</span></span></span></span></li>\n</ul>\n<p><span class=\"T286Pc\">这里其实应该先看一下GenAI和AgenticAI的区别</span></p>\n<blockquote><strong>GenAI 解决“生成什么”，Agentic AI 解决“为了目标要做什么、下一步做什么”。</strong></blockquote>\n<p><img alt=\"image\" height=\"192\" src=\"https://img2024.cnblogs.com/blog/23525/202512/23525-20251224150439443-1162336740.png\" width=\"703\" /></p>\n<p class=\"p1\"><span class=\"s1\">👉 <strong>GenAI 是“会写、会说、会生成”的大脑</strong></span></p>\n<p class=\"p1\"><span class=\"s1\">👉 <strong>Agentic AI 是“会思考下一步并动手”的数字员工</strong></span></p>\n<p class=\"p1\">&nbsp;<strong>GenAI 擅长</strong>&nbsp;</p>\n<ul>\n<li>\n<p class=\"p1\">文本生成（文案、代码、方案）</p>\n</li>\n<li>\n<p class=\"p1\">总结、改写、翻译</p>\n</li>\n<li>\n<p class=\"p1\">单轮或多轮问答</p>\n</li>\n<li>\n<p class=\"p1\">规则内推理（RAG + Prompt）</p>\n</li>\n</ul>\n<p>&nbsp;从<span class=\"s1\">本质上看：<strong>“输入 → 输出”</strong></span></p>\n<h3><strong>Agentic AI 擅长</strong></h3>\n<ul>\n<li>\n<p class=\"p1\">拆解目标</p>\n</li>\n<li>\n<p class=\"p1\">制定计划</p>\n</li>\n<li>\n<p class=\"p1\">调用工具 / 系统</p>\n</li>\n<li>\n<p class=\"p1\">多步执行</p>\n</li>\n<li>\n<p class=\"p1\">根据结果动态调整策略</p>\n</li>\n</ul>\n<p>&nbsp;从<span class=\"s1\">本质上看是：<strong>“目标 → 行动闭环”</strong></span></p>\n<p class=\"p1\"><span class=\"s1\"><strong>二者在关键技术上的差异有<br /></strong></span></p>\n<p><img alt=\"image\" height=\"258\" src=\"https://img2024.cnblogs.com/blog/23525/202512/23525-20251224150624128-1338682233.png\" width=\"727\" /></p>\n<blockquote><strong>Agentic AI = GenAI + 规划 + 工具 + 状态 + 决策</strong></blockquote>\n<p class=\"p1\"><span class=\"s1\"><strong>&nbsp;</strong></span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-24 15:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tianqing\">Eric zhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">79</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}