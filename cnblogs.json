{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "为什么同样是\"学过C++\"，有人面试碾压，有人开口就怂？差距在这18个C++硬核项目",
      "link": "https://www.cnblogs.com/xiaokang-coding/p/19605989",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaokang-coding/p/19605989\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 21:05\">\n    <span>为什么同样是\"学过C++\"，有人面试碾压，有人开口就怂？差距在这18个C++硬核项目</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>嘿，各位C++er，我是小康👋</p>\n<p>今天这篇文章，我想写得和以往不太一样。</p>\n<p>不聊技术原理，不讲架构设计，就聊一个问题：</p>\n<p><strong>你学了那么久C++，为什么还是写不出一个拿得出手的项目？</strong></p>\n<h2 id=\"先看一条让我感触最深的私信\">先看一条让我感触最深的私信</h2>\n<p>前几天一个学员发给我这段话：</p>\n<p>\"康哥，我把内存池项目整理进简历，面试官问我'你这个内存池比malloc快7倍，怎么实现的'，我从ThreadCache讲到PageHeap，再讲到批量分配和无锁设计，面试官直接说'这个掌握得很扎实'。三年了，第一次在面试里感觉到底气。\"</p>\n<p>这不是段子，是真实发生的事。</p>\n<p>过去大半年，我陆续做了<strong>18个C++硬核项目实战课程</strong>，带了<strong>300多位同学</strong>从零开始实现这些项目——985、211有，普通本科有，工作3年换方向的有，应届生有，大家背景差距很大，但收获出奇地一致：</p>\n<p><strong>从\"看得懂别人代码\"升级成了\"自己能从0写出来\"。</strong></p>\n<p>这篇文章，我就把这18个项目完整介绍一遍。</p>\n<h2 id=\"先说说我对市面上那些c课程的看法\">先说说我对市面上那些C++课程的看法</h2>\n<p>直接说：大部分都是\"伪实战\"。</p>\n<p><strong>模式一：开源项目搬运工。</strong> 去GitHub找个高star项目，照着讲一遍。你看完知道\"这段代码在做什么\"，但根本不知道\"为什么这样设计\"，更不会自己从头写。</p>\n<p><strong>模式二：给你个完整代码自己啃。</strong> 扔一个3000行项目给你，说\"学完就行了\"。遇到问题找不到人问，踩了坑不知道怎么解。</p>\n<p><strong>模式三：只有玩具Demo。</strong> 核心功能一删再删，结果弄出来的东西根本上不了生产，面试一问细节就露馅。</p>\n<p>我的方式不一样：<strong>所有项目都是我本人从0到1设计实现的原创代码，用增量式教学带你一步步构建，每天都有可运行的版本，每个设计决策都会解释\"为什么这么做\"。</strong></p>\n<p><strong>不过在介绍项目之前，先说说这套课程更适合哪些人：</strong></p>\n<p><strong>① 正在求职、不知道简历上该写什么项目的同学</strong>——不是说你没能力，而是你缺少一个从0开始、能讲出来、经得起面试官追问的项目。这里面任何一个，都可以正大光明写进简历，而且面试官越问越有底气。</p>\n<p><strong>② 工作了几年、代码量一直上不去的开发者</strong>——你不是缺理论，是缺一次把工业级代码从零写出来的完整经历。很多人工作三年，写的代码逻辑复杂度没超过CRUD，这些项目可以帮你快速补上这段经历。</p>\n<p><strong>③ 想系统提升C++实战能力的同学</strong>——不管你是在校生还是转方向的，能独立实现一个高性能内存池、一个无锁队列、一个协程库，你的C++已经超过80%的同龄人了。</p>\n<p>用一句话概括：<strong>这套课程不是让你\"看懂别人的代码\"，而是带你快速实现项目，从零到一，真正写出来。</strong></p>\n<p>好了，废话少说，下面进入正题。</p>\n<h2 id=\"-18个项目完整介绍\">📦 18个项目完整介绍</h2>\n<h3 id=\"-基础设施篇6个项目\">🧵 基础设施篇（6个项目）</h3>\n<p><strong>1. 线程池 · 299元 · 7天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/10md6XvqpFug5S7LW8m29Q\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>几乎所有C++后台面试必问，但99%的候选人只背过答案，没实现过。</p>\n<p>这个项目不是那种\"几十行就完事\"的玩具。1700+行代码，从基础框架到完整的工业级线程池，包含：任务优先级调度、动态调整线程数、基于<code>std::future</code>的异步结果获取、任务取消与超时机制、完整的状态监控……</p>\n<p>7天渐进式实现，每天一个可运行版本。学完你能自信跟面试官说：这个我自己写过，来，我给你画架构图。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>2. 高性能日志库 MiniSpdlog · 299元 · 8天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/Gt4dgmq8V6tbPZOgEqDlZg\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>spdlog源码有几万行，看不懂、改不动。MiniSpdlog用2500行核心代码，实现了spdlog的精华设计——同步/异步、多Sink、格式化、滚动文件、MPMC队列、线程池……</p>\n<p>实测下来性能可能不如开源日志库spdlog，但是代码完全可读可改，适合学习。这才是\"学完真的懂\"的项目。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>3. 高性能内存池 · 299元 · 10天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/xpSUbVwRZuVoQpRorbpnqA\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>花了三周，做了一个让malloc\"破防\"的内存池。</p>\n<p>实测数据：2048B对象分配比malloc快<strong>7.37倍</strong>，16线程并发下<strong>9战9胜</strong>。</p>\n<p>核心是仿TCMalloc的三层架构：ThreadCache（无锁分配）+ CentralCache（桶锁，降低208倍锁竞争）+ PageHeap（批量申请，1次系统调用撑1000+次分配）。4000+行代码，每个优化决策都有perf数据支撑。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>4. MySQL连接池 · 299元 · 8天</strong> <a href=\"https://mp.weixin.qq.com/s/b01e8Muwpgnd1jBgwB2fgg\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>数据库连接管理是后端开发的\"右臂\"。这个项目4200+行代码，包含：智能连接管理、自定义重连机制（比MySQL官方重连更智能）、三种负载均衡算法（随机/轮询/权重）、健康检查、完整事务支持、10+项性能监控指标……</p>\n<p>有学员学完直接用在公司项目优化上，拿了技术奖励。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>5. 内存泄漏检测器 MemTracker · 299元 · 7天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/u7xa1rLz0kXD0cax84pxiw\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>Valgrind太重、ASan集成复杂、VS诊断工具只支持Windows……这些痛点，MemTracker都解决了。</p>\n<p>64段分段锁架构、16384哈希桶、静态变量检测（业界少有）、精确定位到文件名和行号，性能开销几乎可以忽略。800行核心代码，只需包含一个头文件就能用。</p>\n<p>面试官问\"如何检测内存泄漏\"的时候，你可以说：我自己实现过一个。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>6. 死锁检测工具 DeadLock-Sentinel · 299元 · 6天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/kp2yiGupj1ei3M6XPnKeRQ\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>死锁是多线程开发者的噩梦。这个工具基于图论算法（拓扑排序）自动检测，集成backward-cpp实现堆栈追踪，报告直接显示死锁发生的文件名和行号，还集成spdlog自动保存日志。零侵入，只需把<code>std::mutex</code>换成<code>DeadlockMutex</code>即可启用，Release时一个宏关掉，零性能损耗。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"-高性能组件篇5个项目\">⚡ 高性能组件篇（5个项目）</h3>\n<p><strong>7. ReactorX事件驱动引擎 · 299元 · 5天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/OpHbNeLvmTaXA4ZlRI785w\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>腾讯/字节面试官都在问的Reactor模式，终于有人教你从0到1实现了。</p>\n<p>2000行代码实现完整的Reactor引擎：epoll封装、EventLoop事件循环、基于timerfd的高精度定时器、eventfd跨线程通信、EventLoopThreadPool……实测支持50000+并发连接，QPS达50万+。这是后续网络库、HTTP服务器的基础。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>8. 无锁栈 InfiniteStack · 299元 · 7天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/tjtNHV-_92r2Z-JA_3_q6A\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>无锁编程入门的最佳项目。从CAS原子操作原理讲起，到ABA问题的完整解决方案，再到工业级的Hazard Pointer(危险指针)内存回收机制，7天带你彻底搞懂无锁数据结构设计。性能比std::stack+mutex快2-3倍。</p>\n<p><strong>9. 无锁队列 SPSC LightningQueue · 100元 · 6天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/VXbGq_27nnnPgJQWhaFzbw\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>SPSC（单生产者单消费者）无锁队列，游戏引擎、音视频处理、金融交易系统的标配。实测比queue+mutex方案快2-4倍，延迟降低到2411ns。基于环形缓冲区，6天从原理到生产可用实现。</p>\n<p><strong>10. 无锁队列 MPMC Thunder Queue · 299元 · 6天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/Nk91RZ6RD4gYRRT7VWfNyg\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>无锁编程的\"珠穆朗玛峰\"。多生产者多消费者场景，lock+queue方案只有0.27Mops/s，Thunder Queue能达到4.85Mops/s，性能提升<strong>近20倍</strong>。基于Facebook Folly设计思想，包含turn机制、stride伪共享优化、自适应自旋+Futex阻塞等关键技术。</p>\n<p><strong>11. 工业级智能指针 CraftedPtr · 299元 · 7天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/kfG1VoH9eRnCE0YCuKAD5w\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>网上那些shared_ptr实现大多是玩具，CraftedPtr是真正对标std::shared_ptr的工业级实现。控制块分离、类型擦除、Hazard Pointer线程安全、weak_ptr完整支持、make_shared单次内存分配优化……部分性能指标超越标准库。7天完整实现，还你一个\"自己造的共享指针\"。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"-综合实战篇7个项目\">🌐 综合实战篇（7个项目）</h3>\n<p><strong>12. 高性能网络库 NetCore · 499元 · 10天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/Y3713qRGGQgCO8btemWR_w\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>muduo几万行看不懂？NetCore用2200行核心代码完整实现了Multi-Reactor多线程网络库：Socket RAII封装、Acceptor连接接受、Buffer自动扩容、TcpConnection状态机、TcpServer负载均衡……完整的Echo Server演示，3行代码启动服务。</p>\n<p>已报名ReactorX的同学，补差价200元即可。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>13. 高性能HTTP服务器 FlashHTTP · 699元 · 16天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/GGGDwi9VlXJKBk9cXlNbtw\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>3600+行代码，16天从Reactor到HTTP服务器。实测：<strong>45万QPS，P99延迟22.96ms，支持4万并发连接</strong>，压测结果吊打市面上大部分开源HTTP Server。支持GET/POST/PUT/DELETE、状态机解析、Keep-Alive、静态文件服务、大文件保护……写进简历就是硬货。</p>\n<p>已报名ReactorX的补差价400元，已报名网络库的补差价200元。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>14. 高性能异步日志库 ZephyrLog · 299元 · 6天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/BdsY05V3OXzHAcrQoGbsGA\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>性能数据说话：单线程吞吐量<strong>1250万msg/s</strong>，是spdlog的6倍，是g3log的17倍；16线程极限并发下依然稳在<strong>1100万QPS</strong>，而spdlog直接崩盘。双模式设计（高性能模式/零丢失模式），800行核心代码，6天完整实现。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>15. 多线程下载工具 FastDL · 299元 · 7天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/_Ldit_7qWYBS2kmasGiODA\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>32线程并发，速度提升10倍以上，真正能安装到系统使用的命令行下载神器。HTTP/2协议、定位写入零磁盘占用、JSON断点续传、信号处理优雅中断……2200+行代码，7天学完你就有了一个能跟朋友炫耀\"我自己写的\"的下载工具。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>16. 高性能协程库 CoroForge · 399元 · 7天</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/tuInQxfwqWHFQLU3tKIROA\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>微信libco同款技术，性能完全媲美——在2万并发下吞吐量与libco完全一致（实测）。从汇编上下文切换讲起，到共享栈设计（内存降低99%）、epoll事件驱动、Hook系统调用实现透明协程化……2000行代码搞定libco需要3000行才能做到的事。7天，从\"不懂协程\"到\"能写协程库\"。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>17. HTTP压测工具（即将发布）· 299元</strong></p>\n<p>参考开源项目wrk实现，wrk支持的功能全部支持（多线程、Lua脚本、自定义请求、延迟统计等）。如果你做了网络库或HTTP服务器，有一个自己实现的压测工具是非常加分的。详情发布后会第一时间通知。</p>\n<p><strong>项目架构图:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>18. Redis核心实战 · 1200元（早鸟价）</strong> 👉 <a href=\"https://mp.weixin.qq.com/s/qwcEFKVfeU66AghX__tW7A\" rel=\"noopener nofollow\" target=\"_blank\">点击查看详情</a></p>\n<p>这个项目体量最大：基于Redis 7.x版本，5大阶段、16个核心模块，从SDS/跳表/哈希表等基础数据结构，到事件驱动、主从复制、哨兵集群，从0到1手写Redis核心模块。</p>\n<p>目前课程制作中，早鸟价1200元，制作完毕后涨价到2000-2500元。注意：Redis项目不包含在打包套餐内，单独报名。</p>\n<h2 id=\"-300学员说什么\">💬 300+学员说什么</h2>\n<p><strong>先来看下部分学员的真实反馈和评价：</strong></p>\n<p><strong>学员1：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员2：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员3：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员4：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员5：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员6：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员7：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员8：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员9：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员10：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员11：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员12：</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>学员13:</strong></p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"-报名方式与定价\">💰 报名方式与定价</h2>\n<h3 id=\"单个项目购买\">单个项目购买</h3>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>价格</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>线程池</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>高性能日志库 MiniSpdlog</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>高性能内存池</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>多线程下载工具 FastDL</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>MySQL连接池</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>内存泄漏检测器 MemTracker</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>ReactorX 事件驱动引擎</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>无锁栈 InfiniteStack</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>无锁队列 SPSC LightningQueue</td>\n<td><strong>100元</strong></td>\n</tr>\n<tr>\n<td>无锁队列 MPMC ThunderQueue</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>工业级智能指针 CraftedPtr</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>高性能网络库 NetCore</td>\n<td><strong>499元</strong></td>\n</tr>\n<tr>\n<td>高性能异步日志库 ZephyrLog</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>死锁检测工具 DeadLock-Sentinel</td>\n<td><strong>299元</strong></td>\n</tr>\n<tr>\n<td>高性能协程库 CoroForge</td>\n<td><strong>399元</strong></td>\n</tr>\n<tr>\n<td>Redis 7.x 源码实战（早鸟价）</td>\n<td><strong>1200元</strong> （不含在打包里）</td>\n</tr>\n<tr>\n<td>FlashHTTP HTTP服务器</td>\n<td><strong>699元</strong></td>\n</tr>\n<tr>\n<td>HTTP压测工具</td>\n<td><strong>299元</strong>（即将发布）</td>\n</tr>\n</tbody>\n</table>\n<p>单个购买总计约 <strong>4985 元</strong>。</p>\n<h3 id=\"春节限时特惠--全套打包\">春节限时特惠 · 全套打包</h3>\n<p>原价 4985 元 → <strong>春节特惠价 4200 元</strong>  直接省下近 <strong>800</strong> 元，相当于<strong>送 3 个项目</strong>。</p>\n<p>对于想系统提升 C++ 工程能力、备战面试的你，这可能是今年最划算的一笔投资。</p>\n<p>⏰<strong>活动时间</strong>：<strong>即日起至大年初七（2月23日）</strong>，过后恢复原价。</p>\n<p><strong>PS：</strong> 如果暂时只想从某几个方向入手，<strong>购买部分课程也有优惠</strong>，具体可以私聊我，会根据你的情况给出最合适的方案。</p>\n<h3 id=\"-redis-7x-源码实战单独定价\">🌟 Redis 7.x 源码实战（单独定价）</h3>\n<p>这门课体量独立、内容庞大，分5阶段16模块，与其他项目课定价逻辑不同，不含在打包价内。<a href=\"https://mp.weixin.qq.com/s/qwcEFKVfeU66AghX__tW7A\" rel=\"noopener nofollow\" target=\"_blank\">点击查看项目详情</a></p>\n<p>早鸟价：<strong>1200元</strong>（课程制作完成后涨至2000元-2500元，先报先得）</p>\n<h2 id=\"-如何报名\">🤝 如何报名？</h2>\n<ol>\n<li>扫描下方二维码添加我的微信，或直接搜索：<strong>jkfwdkf</strong></li>\n<li>备注「 <strong>项目实战</strong> 」</li>\n<li>确认后 <strong>微信/支付宝</strong> 付款</li>\n<li>当天加入专属学习群，获取全部资料</li>\n</ol>\n<p><strong>或者扫码加我微信</strong>:</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h2 id=\"最后说几句真心话\">最后说几句真心话</h2>\n<p>我做这些项目课程，有个不变的原则：<strong>所有代码都是我本人从零设计实现的，不从开源项目改造，不拼凑，不水。</strong></p>\n<p>因为我知道，一个真正能让学员受益的项目，必须让他们理解每一个设计决策背后的原因——不只是\"代码是什么\"，而是\"为什么这么写\"。</p>\n<p>这一年多，300多位同学跟着我做了这些项目。有人靠它拿了心仪的Offer，有人靠它在团队里赢得了认可，有人只是纯粹享受\"自己造出来了\"的成就感。</p>\n<p>不管你的出发点是什么，只要你真的想把C++学扎实，想拥有那种\"我能从0写出来\"的底气—— 那就赶紧来，我们一起做。</p>\n<p><strong>微信：jkfwdkf，备注 「项目实战」</strong></p>\n<p>期待你的加入 💪</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 21:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xiaokang-coding\">江小康</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "简单的干掉PPL的方法",
      "link": "https://www.cnblogs.com/PaperPlaneFly/p/19605893",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/PaperPlaneFly/p/19605893\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 20:36\">\n    <span>简单的干掉PPL的方法</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Windows Protected Process Light (PPL) 是一项内核强制执行的安全功能，旨在防止未经授权访问和操纵敏感系统进程，例如 LSASS、反恶意软件服务和其他关键组件。那么很显然干掉PPL这件事得在Driver层干\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简单的干掉ppl的方法\">简单的干掉PPL的方法</h1>\n<h2 id=\"原理\">原理</h2>\n<p>Windows Protected Process Light (PPL) 是一项内核强制执行的安全功能，旨在防止未经授权访问和操纵敏感系统进程，例如 LSASS、反恶意软件服务和其他关键组件。</p>\n<p>那么很显然干掉PPL这件事得在Driver层干</p>\n<p>思路很简单，就是用户空间程序向驱动程序发送进程 ID ，驱动程序找到该进程的内部内核结构（ <code>EPROCESS</code> ），然后在 <code>EPROCESS</code> 中查找 <strong>PS_PROTECTION</strong> 字段，最后驱动程序将保护级别设置为 <strong>0</strong> 。</p>\n<p><code>PS_PROTECTION</code>可以通过windbg来看其内部是怎么定义的，逆向出来就是</p>\n<pre><code class=\"language-c\">typedef struct _PS_PROTECTION {\n    union {\n        UCHAR Level;\n        struct {\n            UCHAR Type : 3;\n            UCHAR Audit : 1;\n            UCHAR Signer : 4;\n        } Flags;\n    } u;\n} PS_PROTECTION;\n\n</code></pre>\n<p>然后拿固定的偏移量</p>\n<pre><code class=\"language-c\">PS_PROTECTION* protection =\n    (PS_PROTECTION*)((UCHAR*)Process + 0x5fa);\n</code></pre>\n<p>这个<code>0x5fa</code>是咋来的呢，当然也是windbg的</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260211203639080-1789561322.png\" /></p>\n<p>需要注意的是，微软官方并未给出具体 <code>EPROCESS</code> 的定义，此偏移量取决于 Windows 版本，因此很难不保证在某次更新后其偏移量就改变了，</p>\n<pre><code class=\"language-c\">DbgPrint(\"Old Level: %02x\\n\", protection-&gt;u.Level);\nprotection-&gt;u.Level = 0;\n</code></pre>\n<p>然后清零就可以了。</p>\n<h2 id=\"验证\">验证</h2>\n<p>首先加载驱动（你需要有测试环境才能加载无签名驱动）</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260211203455938-695518548.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260211203506511-835022939.png\" /></p>\n<p>然后拿<code>MsMpEng.exe</code>开刀，更改前：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260211203530101-2137232901.png\" /></p>\n<p>启动用户态exe</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260211203606743-546561996.png\" /></p>\n<p>再查更改后的</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/3540252/202602/3540252-20260211203616508-604517146.png\" /></p>\n<p>可以看到<code>Level</code>已经变成0了</p>\n<h2 id=\"驱动层代码\">驱动层代码</h2>\n<pre><code class=\"language-c\">#include &lt;ntifs.h&gt;\n#include &lt;ntddk.h&gt;\n\n\n#define IOCTL_CLEAR_PROTECTION CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)\n\n\ntypedef struct _PS_PROTECTION\n{\n    union\n    {\n        UCHAR Level;\n        struct\n        {\n            UCHAR Type : 3;\n            UCHAR Audit : 1;\n            UCHAR Signer : 4;\n        } Flags;\n    } u;\n} PS_PROTECTION, * PPS_PROTECTION;\n\nDRIVER_INITIALIZE DriverEntry;\nDRIVER_UNLOAD UnloadDriver;\nDRIVER_DISPATCH IrpCreateHandler;\nDRIVER_DISPATCH DriverDeviceControl;\n\nNTSTATUS IrpCreateHandler(PDEVICE_OBJECT DeviceObject, PIRP Irp) {\n    UNREFERENCED_PARAMETER(DeviceObject);\n    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;\n    Irp-&gt;IoStatus.Information = 0;\n    IoCompleteRequest(Irp, IO_NO_INCREMENT);\n    return STATUS_SUCCESS;\n}\n\nVOID UnloadDriver(PDRIVER_OBJECT DriverObject) {\n    UNICODE_STRING dos;\n    RtlInitUnicodeString(&amp;dos, L\"\\\\DosDevices\\\\QuitPPLs\"); \n    IoDeleteSymbolicLink(&amp;dos);\n    IoDeleteDevice(DriverObject-&gt;DeviceObject);\n    DbgPrint(\"Driver Unloaded\\n\");\n}\n\nNTSTATUS DriverDeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) {\n    UNREFERENCED_PARAMETER(DeviceObject);\n    PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);\n    NTSTATUS status = STATUS_SUCCESS;\n    ULONG ProcessId = 0;\n    PEPROCESS Process;\n\n    switch (stack-&gt;Parameters.DeviceIoControl.IoControlCode) {\n    case IOCTL_CLEAR_PROTECTION:\n        if (stack-&gt;Parameters.DeviceIoControl.InputBufferLength &lt; sizeof(ULONG)) {\n            status = STATUS_BUFFER_TOO_SMALL;\n            break;\n        }\n\n        ProcessId = *(ULONG*)Irp-&gt;AssociatedIrp.SystemBuffer;\n        DbgPrint(\"Request to clear protection for PID: %d\\n\", ProcessId);\n\n        status = PsLookupProcessByProcessId((HANDLE)(ULONG_PTR)ProcessId, &amp;Process);\n        if (NT_SUCCESS(status)) {\n            PS_PROTECTION* protection = (PS_PROTECTION*)((UCHAR*)Process + 0x5fa);\n            DbgPrint(\"Old Level: %02x\\n\", protection-&gt;u.Level);\n            protection-&gt;u.Level = 0;\n            ObDereferenceObject(Process);\n        }\n        break;\n    default:\n        status = STATUS_INVALID_DEVICE_REQUEST;\n        break;\n    }\n\n    Irp-&gt;IoStatus.Status = status;\n    Irp-&gt;IoStatus.Information = 0;\n    IoCompleteRequest(Irp, IO_NO_INCREMENT);\n    return status;\n}\n\nNTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {\n    UNREFERENCED_PARAMETER(RegistryPath);\n\n    UNICODE_STRING dev, dos;\n    RtlInitUnicodeString(&amp;dev, L\"\\\\Device\\\\QuitPPLs\");\n    RtlInitUnicodeString(&amp;dos, L\"\\\\DosDevices\\\\QuitPPLs\");\n\n    PDEVICE_OBJECT DeviceObject;\n    NTSTATUS status = IoCreateDevice(DriverObject, 0, &amp;dev, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;DeviceObject);\n\n    if (!NT_SUCCESS(status)) return status;\n\n    status = IoCreateSymbolicLink(&amp;dos, &amp;dev);\n    if (!NT_SUCCESS(status)) {\n        IoDeleteDevice(DeviceObject);\n        return status;\n    }\n\n    DriverObject-&gt;DriverUnload = UnloadDriver;\n    DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = DriverDeviceControl;\n    DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = IrpCreateHandler;\n\n    return STATUS_SUCCESS;\n}\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 20:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/PaperPlaneFly\">纸飞机低空飞行</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从零开始实现一个简易json解析器",
      "link": "https://www.cnblogs.com/xiaoxiongcanguan/p/19605794",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaoxiongcanguan/p/19605794\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 20:23\">\n    <span>从零开始实现一个简易json解析器</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"从零开始实现一个简易json解析器\">从零开始实现一个简易json解析器</h1>\n<h2 id=\"1-mysimplejsonparser-介绍与整体设计\">1. MySimpleJsonParser 介绍与整体设计</h2>\n<p>最近在学习编译原理相关的知识。为了加深对词法分析、语法分析阶段中诸如<strong>有限自动机、自顶向下语法分析、AST</strong> 等概念的理解，我选择实现一个json解析器作为练手机会。</p>\n<h5 id=\"_\"></h5>\n<p>相比直接实现一门完整的编程语言，将json解析作为练手对象有几个明显优势：</p>\n<ol>\n<li><strong>几乎零额外学习成本</strong>：json作为一种轻量级的数据交换格式是日常开发中使用最频繁的数据格式之一。</li>\n<li><strong>文法足够简单</strong>：对于编译原理入门者来说，若选择的语言太复杂，很容易在词法/语法规则上被劝退；而json的词法和语法比较规整，语法分析时通常只需根据下一个token即可决定AST的构造方向。</li>\n<li><strong>无需运行时</strong>：json不是编程语言，其完全不需要后端的运行时。只要能把json文本转换成正确的AST就已经算完成任务，在此基础上实现一个基于AST的Pretty JSON输出，就能产生一定的成就感。</li>\n</ol>\n<h5 id=\"_-1\"></h5>\n<p>在本篇博客中，我们将基于<strong>java语言</strong>，不依赖任何第三方库，从零开始实现一个简单的json解析器：<strong>MySimpleJsonParser</strong>。其包括以下几个主要模块：</p>\n<ol>\n<li><strong><code>StaticJsonLexer</code></strong>：一次性解析出全部token的静态json词法分析器</li>\n<li><strong><code>StreamJsonLexer</code></strong>：按需惰性解析token的流式json词法分析器</li>\n<li><strong><code>RecursiveJsonParser</code></strong>：基于递归的json语法解析器</li>\n<li><strong><code>StackBaseJsonParser</code></strong>：基于显式堆栈的json语法解析器（非递归）</li>\n<li><strong><code>AST结构</code></strong>：JsonElement及其子类，并基于AST生成Pretty JSON字符串的工具方法</li>\n</ol>\n<h2 id=\"2-从文法到词法分析器手写-json-lexer\">2. 从文法到词法分析器：手写 json lexer</h2>\n<p>词法分析阶段的任务是：将原始的字符流，按照json的词法规则，转换为token流。之后的语法分析会在token流的基础上按文法规则构建AST。</p>\n<h3 id=\"21-json文法与基本结构\">2.1 json文法与基本结构</h3>\n<p>根据<a href=\"https://www.json.org/json-en.html\" rel=\"noopener nofollow\" target=\"_blank\"><strong>json官方文档</strong></a>，json中主要包含以下几类结构：</p>\n<ol>\n<li><strong>string</strong>：由双引号包住的Unicode字符串，可包含转义字符。一个字符（character）也可以是一个单独的字符串（character string）。</li>\n<li><strong>number</strong>：以<code>0</code>或<code>-</code>开头，可以是整数、小数、、负数或者是包含一个E/e符号的指数。</li>\n<li><strong>object</strong>：以“<code>{</code>” 开头，以“<code>}</code>”结尾。</li>\n<li><strong>array</strong>：以“<code>[</code>” 开头，以“<code>]</code>”结尾。</li>\n<li><strong>value</strong>：可以是string、number、<code>true</code>(关键字)、<code>false</code>(关键字)、<code>null</code>(关键字)、object或者array。</li>\n<li><strong>whitespace</strong>：由任意个space空格、linefeed换行符、carriage return回车符以及tab制表符组成，本身无意义，仅起到分割的作用。</li>\n</ol>\n<h5 id=\"_-2\"></h5>\n<ul>\n<li>仔细分析后，发现string结构、number结构和whitespace结构以及<code>{</code>、<code>}</code>、<code>[</code>、<code>]</code> 这类符号都是基本结构，是自身无法再嵌套其它结构的基本单元，因此其都是最终AST中的叶子节点，而object、array和value都是可以互相嵌套的复合结构，其都是AST中的非叶子节点。</li>\n<li>对于这些可嵌套的非AST叶子节点，必须在语法分析中才能完成解析；而string结构、number结构、false、true、null关键字以及“{”、“]”等特殊符号，则适合在词法分析中完成解析。<br />\n因为json语法中，无论原始的json字符串中一个number字面量有多复杂(比如-2.03214e+6605218)，在语法分析中都只需要当做一个完整的number类型的token来处理即可。</li>\n<li>词法分析专注于局部，将原始的字符流按照词法规则正确的转换为token流；而语法分析则专注于将token流按照语法规则转换为正确的AST树结构。<br />\n通过将整个分析流程，有机的分解为词法分析和语法分析等等不同步骤，每个步骤都依赖于前一个步骤的产出的分层设计，能够很好的控制解析器整体的复杂度，方便调试的同时性能上也有很大的提升。<br />\n因此，除了少数非常简单的语言外，几乎所有的编译器都会采用分层的架构来实现整体的功能。</li>\n</ul>\n<h3 id=\"22-token类型定义\">2.2 token类型定义</h3>\n<p>从文法角度，json中允许的token类型大致可分为三类：</p>\n<ol>\n<li>特殊符号：诸如“<code>{</code>”、“<code>}</code>”、“<code>[</code>”、“<code>]</code>”、“<code>,</code>”,“<code>:</code>”,“<code>\"</code>”等独立的字符是json中的特殊符号</li>\n<li>关键字：完整且独立的<code>true</code>、<code>false</code>、<code>null</code>被视为关键字</li>\n<li>字面量：number、string这两种复杂字符流字面量</li>\n</ol>\n<h5 id=\"_-3\"></h5>\n<p>因此我们可以先定义出json的token类型枚举。其中EOF类型是额外的，用于在完成整个字符流的词法分析后，追加到token流的最后，标志着token流的结束。</p>\n<pre><code class=\"language-java\">public enum JsonTokenTypeEnum {\n    LEFT_BRACE(\"{\"),\n    RIGHT_BRACE(\"}\"),\n\n    LEFT_BRACKET(\"[\"),\n    RIGHT_BRACKET(\"]\"),\n\n    COMMA(\",\"),\n    COLON(\":\"),\n\n    TRUE(\"true\"),\n    FALSE(\"false\"),\n    NULL(\"null\"),\n\n    STRING(\"string\"),\n    NUMBER(\"number\"),\n\n    EOF(\"EOF\"),\n    ;\n    private final String key;\n\n    JsonTokenTypeEnum(String key) {\n        this.key = key;\n    }\n\n    public String getKey() {\n        return key;\n    }\n}\n</code></pre>\n<h3 id=\"23-词法分析器整体框架与特殊字符的词法分析\">2.3 词法分析器整体框架与特殊字符的词法分析</h3>\n<p>现在我们已经知道诸如“{”、“]”等独立字符是json中的特殊符号，但是当我们在字符流中遇到了一个“{”字符时，并不能无脑的将其作为一个LEFT_BRACE类型的token来处理。因为如果其是被双引号包裹的，作为string类型token内容的一部分，那么就并不能将其直接当做独立的token来对待。<br />\n所以，词法分析中一般使用有限状态自动机来解决此类“同一字符在不同上下文含义不同”的问题，在判断如何处理字符流时并不仅仅取决于下一个字符是什么，而还要结合当前自动机的状态来决定行为。<br />\n以上述对“{”字符的处理为例，如果是在初始化状态下(已经完成了一个完整token的解析,准备开始解析下一个新token)，碰到“{”字符时可以确定的将其转化为LEFT_BRACE类型的token，但是当自动机处于string类型token的解析状态时，则需要将其作为string类型token内容的一部分。</p>\n<h5 id=\"json词法分析自动机总览图\">json词法分析自动机总览图</h5>\n<p>基于官方文档中的json文法规则，我们可以设计出一个如下图所示的json有限状态自动机来实现我们的词法分析。<br />\n<img alt=\"lexer_total\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195126490-433213565.png\" /></p>\n<h5 id=\"_-4\"></h5>\n<ul>\n<li>在json解析一开始，自动机位于状态0，随后便会基于字符流的下一个字符的类型进行状态转换，在读取到诸如“{”、“[”、“,”等独立符号时，便会直接接收该字符，推进字符流，同时生成对应类型的token。</li>\n<li>在完整的解析出一个完整token后，自动机便会重新回到状态0，准备尝试解析下一个新的token。状态0只能合法的接收有限种类的字符，对于不符合json文法的字符将认为当前字符流不是合法的json字符串而直接报错，退出解析。</li>\n<li>对于更复杂的string类型、number类型token的解析，我们放在后面的小节再展开，总览图中暂时省略。</li>\n</ul>\n<h5 id=\"静态的词法分析器实现\">静态的词法分析器实现</h5>\n<pre><code class=\"language-java\">public class StaticJsonLexer extends AbstractJsonLexer{\n\n    public StaticJsonLexer(String jsonString) {\n        super(jsonString);\n    }\n\n    /**\n     * 一次完整的扫描，非流式的处理\n     * */\n    public List&lt;JsonToken&gt; doLex(){\n        char[] chars = super.jsonStringArray;\n\n        // 相当于是状态0\n        while(doLexContext.currentIndex &lt; chars.length){\n            char ch = chars[doLexContext.currentIndex];\n\n            switch(ch){\n                case '{':\n                    doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.LEFT_BRACE));\n                    doLexContext.currentIndex++;\n                    break;\n                case '}':\n                    doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.RIGHT_BRACE));\n                    doLexContext.currentIndex++;\n                    break;\n                case '[':\n                    doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.LEFT_BRACKET));\n                    doLexContext.currentIndex++;\n                    break;\n                case ']':\n                    doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.RIGHT_BRACKET));\n                    doLexContext.currentIndex++;\n                    break;\n                case ',':\n                    doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.COMMA));\n                    doLexContext.currentIndex++;\n                    break;\n                case ':':\n                    doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.COLON));\n                    doLexContext.currentIndex++;\n                    break;\n                case '\"':\n                    doLexContext.tokenCollector.add(parseString(chars, doLexContext));\n                    break;\n                case 't':\n                    // 尝试解析true关键字\n                    doLexContext.tokenCollector.add(parseTrueKeyword(chars, doLexContext));\n                    break;\n                case 'f':\n                    // 尝试解析false关键字\n                    doLexContext.tokenCollector.add(parseFalseKeyword(chars, doLexContext));\n                    break;\n                case 'n':\n                    // 尝试解析null关键字\n                    doLexContext.tokenCollector.add(parseNullKeyword(chars, doLexContext));\n                    break;\n                default:\n                    // 其它case\n                    if(ch == '-' || CommonStringUtil.is0_9(ch)){\n                        // number解析\n                        JsonToken numberToken = parseNumber(chars, doLexContext);\n                        doLexContext.tokenCollector.add(numberToken);\n                        break;\n                    }else if(CommonStringUtil.isWhitespace(ch)){\n                        // whiteSpace 直接跳过\n                        doLexContext.currentIndex++;\n                        break;\n                    }else{\n                        throw new MuJsonParserException(\"unexpected character: \" + ch + \" at index \" + doLexContext.currentIndex);\n                    }\n            }\n        }\n\n        // 最后加上EOF\n        doLexContext.tokenCollector.add(new JsonToken(JsonTokenTypeEnum.EOF));\n        return doLexContext.tokenCollector;\n    }\n}\n</code></pre>\n<p>抽象父类<code>AbstractJsonLexer</code>封装了string/number/keyword等具体类型的公共解析逻辑：</p>\n<pre><code class=\"language-java\">public abstract class AbstractJsonLexer {\n\n    protected final char[] jsonStringArray;\n\n    protected final DoLexContext doLexContext;\n\n    public AbstractJsonLexer(String jsonString) {\n        this.jsonStringArray = jsonString.toCharArray();\n        this.doLexContext = new DoLexContext();\n    }\n\n    protected JsonToken parseNumber(char[] chars, DoLexContext doLexContext){\n        // number类型的内容\n        String numberStr = new NumberLexStatemachine().tryParse(chars,doLexContext);\n\n        return new JsonToken(JsonTokenTypeEnum.NUMBER, numberStr);\n    }\n\n    protected JsonToken parseString(char[] chars, DoLexContext doLexContext){\n        // string类型的内容\n        String stringStr = new StringLexStatemachine().tryParse(chars,doLexContext);\n\n        return new JsonToken(JsonTokenTypeEnum.STRING, stringStr);\n    }\n\n    protected JsonToken parseTrueKeyword(char[] chars, DoLexContext doLexContext){\n        // true关键字\n        String stringStr = new KeywordTrueLexStatementMachine().tryParse(chars,doLexContext);\n\n        return new JsonToken(JsonTokenTypeEnum.TRUE, stringStr);\n    }\n\n    protected JsonToken parseFalseKeyword(char[] chars, DoLexContext doLexContext){\n        // false关键字\n        String stringStr = new KeywordFalseLexStatementMachine().tryParse(chars,doLexContext);\n\n        return new JsonToken(JsonTokenTypeEnum.FALSE, stringStr);\n    }\n\n    protected JsonToken parseNullKeyword(char[] chars, DoLexContext doLexContext){\n        // null关键字\n        String stringStr = new KeywordNullLexStatementMachine().tryParse(chars,doLexContext);\n\n        return new JsonToken(JsonTokenTypeEnum.NULL, stringStr);\n    }\n}\n</code></pre>\n<h5 id=\"_-5\"></h5>\n<ul>\n<li>为了支持后续流式的词法分析器，静态的词法分析器StaticJsonLexer继承自AbstractJsonLexer类，构造方法中接收一个字符串，并通过方法doLex进行解析，返回一次性完整解析字符串后的token列表。</li>\n<li>doLex方法中是一个while循环，每一次循环开始都相当于是自动机位于状态0，在解析时会通过自增currentIndex不断地推进字符流，成功解析出完整的token后便会将新的token保存到上下文中的tokenCollector中。只有在解析报错或者成功完成了整个字符串的解析后才会退出循环。</li>\n<li>在正常退出while循环后，doLex方法返回前token集合的尾部会追加一个特殊的EOF类型的token，用于告知下一阶段的parser已经解析到了token流的末尾，该结束解析了。</li>\n</ul>\n<h3 id=\"24-number类型的词法分析\">2.4 number类型的词法分析</h3>\n<p>number的词法规则相对复杂，因为number类型作为json中表示数字的组件，其可以是整数，也可以是小数、负数，同时还可以是带符号e/E的指数形式。</p>\n<h5 id=\"json-number类型token的词法规则\">json number类型token的词法规则</h5>\n<pre><code>number\n    integer fraction exponent\n\ninteger\n    digit\n    onenine digits\n    '-' digit\n    '-' onenine digits\n\ndigits\n    digit\n    digit digits\n\ndigit\n    '0'\n    onenine\n\nonenine\n    '1' . '9'\n\nfraction\n    \"\"\n    '.' digits\n\nexponent\n    \"\"\n    'E' sign digits\n    'e' sign digits\n\nsign\n    \"\"\n    '+'\n    '-'\n</code></pre>\n<p><img alt=\"json_number_lex_rule\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195806369-790385529.png\" /></p>\n<h5 id=\"_-6\"></h5>\n<p>基于上述词法规则，我们可以构造出如下图所示的用于解析number类型token的状态自动机。</p>\n<h5 id=\"number类型解析的状态自动机示意图\">number类型解析的状态自动机示意图</h5>\n<p><img alt=\"json_number_lex_state_machine\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211201818452-99218238.png\" /></p>\n<h5 id=\"_-7\"></h5>\n<p>设计好上述的状态自动机后，就可以按照图中的状态转移关系手写一个简单的状态机来解析number类型的token了。</p>\n<h5 id=\"number类型解析状态机实现源码\">number类型解析状态机实现源码</h5>\n<pre><code class=\"language-java\">public class NumberLexStatemachine extends LexStatementMachine{\n\n    private static final Map&lt;Integer,Boolean&gt; staticFinalStateMap;\n    private static final LexStateHandler[] lexStateHandlers;\n\n    static{\n        staticFinalStateMap = new HashMap&lt;&gt;();\n        staticFinalStateMap.put(-1,true);\n        staticFinalStateMap.put(1,true);\n        staticFinalStateMap.put(2,false);\n        staticFinalStateMap.put(3,true);\n        staticFinalStateMap.put(4,true);\n        staticFinalStateMap.put(5,false);\n        staticFinalStateMap.put(6,true);\n        staticFinalStateMap.put(7,false);\n        staticFinalStateMap.put(8,false);\n        staticFinalStateMap.put(9,true);\n\n        lexStateHandlers = new LexStateHandler[]{\n            new State0Handler(), new State1Handler(), new State2Handler(), new State3Handler(), new State4Handler(),\n            new State5Handler(),new State6Handler(),new State7Handler(),new State8Handler(),new State9Handler()\n        };\n    }\n\n    public NumberLexStatemachine() {\n        this.stateHandlers = lexStateHandlers;\n        this.isFinalStateMap = staticFinalStateMap;\n    }\n\n    private static abstract class NumberLexStateHandler implements LexStateHandler {\n\n        @Override\n        public int processInState(char[] chars, DoLexContext doLexContext, LexStatementMachine lexStatementMachine, StringBuilder oneTokenAcceptResult) {\n            char currentChar = chars[doLexContext.currentIndex];\n\n            // whitespace符号以及number后合法的终结符\n            if(CommonStringUtil.isWhitespace(currentChar)\n                || currentChar == ']' || currentChar == '}' || currentChar == ',' || currentChar == ':'){\n                if(lexStatementMachine.currentStateIsFinal()){\n                    // 结束number的解析\n                    return -1;\n                }else{\n                    // 遇到了分隔符，但是当前number解析的状态不是终态，无法转换为一个合法的number类型的token，抛异常\n                    throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n                }\n            }\n\n            return doProcessInState(currentChar,doLexContext, oneTokenAcceptResult);\n        }\n\n        abstract int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult);\n    }\n\n    private static class State0Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '0'){\n                // accept\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                // 进入状态1\n                return 1;\n            }\n\n            if(currentChar == '-'){\n                // accept\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                // 进入状态2\n                return 2;\n            }\n\n            if(CommonStringUtil.is1_9(currentChar)){\n                // accept\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                // 进入状态3\n                return 3;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State1Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '.'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 5;\n            }\n\n            if(currentChar == 'e' || currentChar == 'E'){\n                accept(currentChar,doLexContext, oneTokenAcceptResult);\n                return 7;\n            }\n\n            throw new MuJsonParserException(\"unexpected char '\" + currentChar + \"', index=\" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State2Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '0'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 1;\n            }\n\n            if(CommonStringUtil.is1_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 3;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State3Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '.'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 5;\n            }\n\n            if(currentChar == 'e' || currentChar == 'E'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 7;\n            }\n\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 4;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State4Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext,StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '.'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 5;\n            }\n\n            if(currentChar == 'e' || currentChar == 'E'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 7;\n            }\n\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 4;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State5Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 6;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State6Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext,StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 6;\n            }\n\n            if(currentChar == 'e' || currentChar == 'E'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 7;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State7Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext,StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 9;\n            }\n\n            if(currentChar == '-' || currentChar == '+'){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 8;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State8Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 9;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State9Handler extends NumberLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.is0_9(currentChar)){\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 9;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n}\n\n</code></pre>\n<pre><code class=\"language-java\">public abstract class LexStatementMachine {\n\n    protected int currentState = 0;\n    protected StringBuilder oneTokenAcceptResult = new StringBuilder();\n\n    protected LexStateHandler[] stateHandlers;\n    protected Map&lt;Integer,Boolean&gt; isFinalStateMap;\n\n    public String tryParse(char[] chars, DoLexContext doLexContext){\n        doParse(chars,doLexContext);\n\n        boolean isFinalState = isFinalStateMap.get(currentState);\n        if(isFinalState){\n            return oneTokenAcceptResult.toString();\n        }else{\n            throw new MuJsonParserException(String.format(\"currentState is not finalState! acceptResult=%s, acceptResult=%s\",currentState, oneTokenAcceptResult));\n        }\n    }\n\n    public boolean currentStateIsFinal(){\n        return isFinalStateMap.get(currentState);\n    }\n\n    protected static void accept(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult){\n        oneTokenAcceptResult.append(currentChar);\n        doLexContext.currentIndex++;\n    }\n\n    private void doParse(char[] chars, DoLexContext doLexContext){\n        // 一进来是状态0\n        while(doLexContext.currentIndex &lt; chars.length){\n            if(currentState == -1){\n                // 遇到了合法的分隔符号，退出token解析\n                return;\n            }\n\n            if(currentState &gt;= stateHandlers.length){\n                // 有bug\n                throw new MuJsonParserException(String.format(\"unknown state! currentState=%s\",currentState));\n            }\n            LexStateHandler targetStateHandler = stateHandlers[currentState];\n            \n            currentState = targetStateHandler.processInState(chars,doLexContext,this,oneTokenAcceptResult);\n        }\n    }\n}\n</code></pre>\n<h5 id=\"_-8\"></h5>\n<ul>\n<li>NumberLexStatemachine继承自父类LexStatementMachine。在LexStatementMachine中与doLex方法类似，也是一个while循环来反复的处理每一次的状态跳转。</li>\n<li>子类NumberLexStatemachine定义了一系列的LexStateHandler状态处理器，每一个状态处理器都对应状态机示意图中的一个状态。</li>\n<li>每一个LexStateHandler中的功能都比较类似，即决定在当前状态下自己能够接收的字符类型，以及控制在合法接收字符流当前字符后应该跳转的下一个状态是什么。<br />\n在合法接收字符时，会修改上下文中的当前字符指针以推进字符流，同时将接受到的当前合法字符追加到oneTokenAcceptResult中。</li>\n<li>如果遇到了合法的结束分隔符，比如whitespace或者“}”、“]”之类的字符，且当前状态是属于number解析的终态，则NumberLexStateHandler会返回-1，终止当前token的解析。(比如{\"number\":-123.0}结束时的状态是6，6是终态，所以其是合法的json串)<br />\n如果状态处理器中遇到当前状态下不合法的字符，或者在退出解析时当前状态不属于number解析的终态，说明当前字符串不是合法的json串，则会直接抛出异常，退出词法解析。(比如{\"number\":-123.}结束时的状态是5,5不是终态，所以其是不合法的json串)</li>\n<li>NumberLexStatemachine状态机正常退出当前number类型token后，返回收集到的所有字符oneTokenAcceptResult，作为number类型的字面量返回。</li>\n</ul>\n<h3 id=\"25-string类型的词法分析\">2.5 string类型的词法分析</h3>\n<p>string类型的词法规则相比之下比较简单，要求以双引号开头，并以双引号结尾即可，但需要额外处理转义字符相关的逻辑。</p>\n<h5 id=\"json-string类型token的词法规则\">json string类型token的词法规则</h5>\n<pre><code>string\n    '\"' characters '\"'\n\ncharacters\n    \"\"\n    character characters\n\ncharacter\n    '0020' . '10FFFF' - '\"' - '\\'\n    '\\' escape\n\nescape\n    '\"'\n    '\\'\n    '/'\n    'b'\n    'f'\n    'n'\n    'r'\n    't'\n    'u' hex hex hex hex\n\nhex\n    digit\n    'A' . 'F'\n    'a' . 'f'\n</code></pre>\n<p><img alt=\"json_string_lex_rule\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195844242-1192651121.png\" /></p>\n<h5 id=\"_-9\"></h5>\n<p>基于上述词法规则，我们构造出如下图所示的用于解析string类型token的状态自动机。</p>\n<h5 id=\"string类型解析的状态自动机示意图\">string类型解析的状态自动机示意图</h5>\n<p><img alt=\"json_string_lex_state_machine\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195854133-180088812.png\" /></p>\n<h5 id=\"string类型解析状态机实现源码\">string类型解析状态机实现源码</h5>\n<pre><code class=\"language-java\">public class StringLexStatemachine extends LexStatementMachine{\n\n    private static final Map&lt;Integer,Boolean&gt; staticFinalStateMap;\n    private static final LexStateHandler[] lexStateHandlers;\n\n    static{\n        staticFinalStateMap = new HashMap&lt;&gt;();\n        staticFinalStateMap.put(-1,true);\n        staticFinalStateMap.put(1,false);\n        staticFinalStateMap.put(2,true);\n        staticFinalStateMap.put(3,false);\n        staticFinalStateMap.put(4,false);\n        staticFinalStateMap.put(5,false);\n        staticFinalStateMap.put(6,false);\n        staticFinalStateMap.put(7,false);\n\n        lexStateHandlers = new LexStateHandler[]{\n            new State0Handler(),new State1Handler(),new State2Handler(),new State3Handler(),new State4Handler(),\n            new State5Handler(),new State6Handler(),new State7Handler()};\n    }\n\n    public StringLexStatemachine() {\n        this.stateHandlers = lexStateHandlers;\n        this.isFinalStateMap = staticFinalStateMap;\n    }\n\n    private static abstract class StringLexStateHandler implements LexStateHandler {\n\n        @Override\n        public int processInState(char[] chars, DoLexContext doLexContext, LexStatementMachine lexStatementMachine, StringBuilder oneTokenAcceptResult) {\n            char currentChar = chars[doLexContext.currentIndex];\n\n            return doProcessInState(currentChar,doLexContext,oneTokenAcceptResult);\n        }\n\n        abstract int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult);\n    }\n\n    private static class State0Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '\"'){\n                // accept\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                // 进入状态1\n                return 1;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State1Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(currentChar == '\"'){\n                // accept\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                // 进入状态2\n                return 2;\n            }\n\n            if(currentChar == '\\\\'){\n                // accept\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                // 进入状态3\n                return 3;\n            }\n\n            // 控制字符是不合法的，不能出现在string中\n            if (currentChar &lt; 0x20) {\n                throw new MuJsonParserException(\"unexpected control char \" + currentChar + \" in string, \" + doLexContext.currentIndex);\n            }\n\n            // 除了[\"]和[\\]两个字符，别的都当做字符串的一部分接收\n            // accept\n            accept(currentChar,doLexContext,oneTokenAcceptResult);\n            return 1;\n        }\n    }\n\n    private static class State2Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            // 终态，完成一个string的解析，直接退出\n            return -1;\n        }\n    }\n\n    private static class State3Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            // 合法的转义字符\n            if(currentChar == '\"' || currentChar == '\\\\' || currentChar == '/' ||\n                currentChar == 'b' || currentChar == 'f' || currentChar == 'n' ||\n                currentChar == 'r' || currentChar == 't'){\n                // 接收，回到状态1\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 1;\n            }\n\n            if(currentChar == 'u'){\n                // 特殊case 要求后面连续4个hex字符 '\\\\u hex hex hex hex'\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 4;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State4Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.isHex(currentChar)){\n                // 接收，进入状态5\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 5;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State5Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.isHex(currentChar)){\n                // 接收，进入状态6\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 6;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State6Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.isHex(currentChar)){\n                // 接收，进入状态7\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 7;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n\n    private static class State7Handler extends StringLexStateHandler {\n        @Override\n        int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult) {\n            if(CommonStringUtil.isHex(currentChar)){\n                // 连续接收了4个hex字符，回到状态1\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return 1;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n}\n</code></pre>\n<h5 id=\"_-10\"></h5>\n<ul>\n<li>string类型token解析的状态机与number类型的工作模式类似，同样继承自LexStatementMachine，并且定义了一系列的对应状态机示意图中各个状态的LexStateHandler。</li>\n</ul>\n<h3 id=\"26-关键字的词法分析\">2.6 关键字的词法分析</h3>\n<p>最后，json的词法分析中还有关键字类型的token解析需要实现。所幸json的文法非常简单，只有true、false和null三个关键字，且这三个关键字的f(1)都不相同，也与其它类型的token的f(1)不相同。<br />\n因此，在词法解析时，我们可以很简单的根据第一个字符来决定要解析的关键字类型，在状态0时，如果碰到字符t就尝试解析true类型的token；碰到字符f就尝试解析false类型的token；碰到字符n就尝试解析null类型的token。<br />\n因此我们可以很简单的得到如下图所示的三个关键字的状态自动机。</p>\n<h5 id=\"关键字类型解析的状态自动机示意图\">关键字类型解析的状态自动机示意图</h5>\n<p><img alt=\"json_keyword_lex_state_machine\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195910810-282453956.png\" /></p>\n<h5 id=\"keyword类型解析状态机实现源码\">keyword类型解析状态机实现源码</h5>\n<pre><code class=\"language-java\">public abstract class KeywordLexStatementMachine extends LexStatementMachine{\n\n    protected final String keyword;\n\n    public KeywordLexStatementMachine(String keyword) {\n        this.keyword = keyword;\n    }\n\n    protected static Map&lt;Integer,Boolean&gt; buildIsFinalStateMap(String keyword){\n        Map&lt;Integer,Boolean&gt; isFinalStateMap = new HashMap&lt;&gt;(keyword.length() + 1);\n        isFinalStateMap.put(-1,true);\n\n        for(int i=0; i&lt;keyword.length(); i++) {\n            isFinalStateMap.put(i,false);\n        }\n\n        // 最后一个字符就是合理的终态\n        isFinalStateMap.put(keyword.length(),true);\n\n        return isFinalStateMap;\n    }\n\n    protected static LexStateHandler[] buildLexStateHandlers(String keyword){\n        LexStateHandler[] lexStateHandlers = new LexStateHandler[keyword.length() + 1];\n\n        for(int i=0; i&lt;keyword.length(); i++) {\n            char c = keyword.charAt(i);\n\n            lexStateHandlers[i] = new KeywordLexStateHandler(c,i+1);\n        }\n\n        // 最后一个状态，直接返回\n        lexStateHandlers[keyword.length()] = new KeywordLexStateHandler(' ',-1);\n\n        return lexStateHandlers;\n    }\n\n    private static class KeywordLexStateHandler implements LexStateHandler {\n\n        private final char targetCh;\n        private final int nextState;\n\n        public KeywordLexStateHandler(char targetCh, int nextState) {\n            this.targetCh = targetCh;\n            this.nextState = nextState;\n        }\n\n        @Override\n        public int processInState(char[] chars, DoLexContext doLexContext, LexStatementMachine lexStatementMachine, StringBuilder oneTokenAcceptResult) {\n            char currentChar = chars[doLexContext.currentIndex];\n\n            return doProcessInState(currentChar,doLexContext,oneTokenAcceptResult);\n        }\n\n        private int doProcessInState(char currentChar, DoLexContext doLexContext, StringBuilder oneTokenAcceptResult){\n            if(nextState == -1){\n                // -1是特殊的直接返回\n                return nextState;\n            }\n\n            if(currentChar == targetCh) {\n                // 接收，进入下一个状态\n                accept(currentChar,doLexContext,oneTokenAcceptResult);\n                return nextState;\n            }\n\n            throw new MuJsonParserException(\"unexpected char \" + currentChar + \" \" + doLexContext.currentIndex);\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">/**\n * 解析关键字true的状态自动机\n * */\npublic class KeywordTrueLexStatementMachine extends KeywordLexStatementMachine{\n\n    private static final String KEYWORD = JsonTokenTypeEnum.TRUE.getKey();\n    private static final Map&lt;Integer,Boolean&gt; staticIsFinalStateMap;\n    private static final LexStateHandler[] lexStateHandlers;\n\n    static {\n        staticIsFinalStateMap = buildIsFinalStateMap(KEYWORD);\n        lexStateHandlers = buildLexStateHandlers(KEYWORD);\n    }\n\n    public KeywordTrueLexStatementMachine() {\n        super(KEYWORD);\n\n        super.isFinalStateMap = staticIsFinalStateMap;\n        super.stateHandlers = lexStateHandlers;\n    }\n}\n</code></pre>\n<h5 id=\"_-11\"></h5>\n<ul>\n<li>由于关键字的解析都是最简单的单向状态转移，所以单独抽象出了KeywordLexStatementMachine类，其根据构造方法中传入的关键字字面量，自动生成对应数量的LexStateHandler集合和IsFinalStateMap。</li>\n<li>false和null关键字的词法解析与true基本一致，这里省略掉</li>\n</ul>\n<h5 id=\"27-jsontokenreader\">2.7 jsonTokenReader</h5>\n<p>至此，我们就已经实现了基本的json词法分析能力，能够将json字符串一次性的解析成token列表供下一阶段的语法分析使用。<br />\n但在语法解析阶段，parser更希望接收的是能够自己记忆当前所处理token的token流，而不是一个孤零零的List，所以这里简单的以迭代器的方式包装一下方便使用。</p>\n<pre><code class=\"language-java\">public interface JsonTokenReader {\n\n    boolean hasNextToken();\n\n    JsonToken nextToken();\n\n    JsonToken peek();\n\n    int currentIndex();\n}\n</code></pre>\n<p>静态词法分析器的实现：</p>\n<pre><code class=\"language-java\">public class StaticJsonTokenReader implements JsonTokenReader {\n\n    private int currentIndex;\n\n    private final List&lt;JsonToken&gt; tokens;\n\n    public StaticJsonTokenReader(String jsonString) {\n        this.currentIndex = 0;\n\n        StaticJsonLexer staticJsonLexer = new StaticJsonLexer(jsonString);\n        this.tokens = staticJsonLexer.doLex();\n    }\n\n    @Override\n    public boolean hasNextToken() {\n        return tokens.get(currentIndex).getType() != JsonTokenTypeEnum.EOF;\n    }\n\n    @Override\n    public JsonToken nextToken() {\n        JsonToken jsonToken = tokens.get(currentIndex);\n        currentIndex++;\n        return jsonToken;\n    }\n\n    @Override\n    public JsonToken peek() {\n        return tokens.get(currentIndex);\n    }\n\n    @Override\n    public int currentIndex() {\n        return this.currentIndex;\n    }\n}\n</code></pre>\n<p>简单demo：</p>\n<pre><code class=\"language-java\">    public static void main(String[] args) {\n        String json = \"{\\\"k1\\\":{\\\"abc\\\":123},\\\"k2\\\":true}\";\n\n        StaticJsonLexer staticJsonLexer = new StaticJsonLexer(json);\n        List&lt;JsonToken&gt; jsonTokenList = staticJsonLexer.doLex();\n        System.out.println(\"json=\" + json);\n        jsonTokenList.forEach(System.out::println);\n    }\n</code></pre>\n<p><img alt=\"static_json_lexer_demo_result\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195926464-23510035.png\" /></p>\n<h2 id=\"3-手写-json-语法分析器从-token-到-ast\">3. 手写 json 语法分析器：从 token 到 AST</h2>\n<p>语法分析阶段，接收词法分析阶段输出的token流，需要按照语法规则解析出正确的AST抽象语法树。<br />\n在json的AST中其实本质上只有三种类型的元素：</p>\n<ul>\n<li><code>JsonObject</code>：对象</li>\n<li><code>JsonArray</code>：数组</li>\n<li><code>JsonPrimitiveStr</code>：primitive基础类型（string/number/true/false/null）封装为字符串字面量</li>\n</ul>\n<h5 id=\"_-12\"></h5>\n<p>primitive基础类型是无法进行递归嵌套的类型，是AST中的叶节点，而object和array则是可以互相嵌套的(对象的一个属性可以是数组或者另一个对象，数组中的元素也可以是对象或者另一个数组)，其属于AST中的非叶子结点。</p>\n<h3 id=\"31-json-ast节点结构定义\">3.1 json AST节点结构定义</h3>\n<pre><code class=\"language-java\">public abstract class JsonElement {\n}\n</code></pre>\n<pre><code class=\"language-java\">/**\n * json AST的object类型节点\n * */\npublic class JsonObject extends JsonElement{\n\n    private final Map&lt;String,JsonElement&gt; objMap = new LinkedHashMap&lt;&gt;();\n\n    public void putKV(String key, JsonElement value) {\n        objMap.put(key, value);\n    }\n\n    public Map&lt;String, JsonElement&gt; getObjMap() {\n        return objMap;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">/**\n * json AST的array类型节点\n * */\npublic class JsonArray extends JsonElement{\n\n    private List&lt;JsonElement&gt; array = new ArrayList&lt;&gt;();\n\n    public void addElement(JsonElement element) {\n        array.add(element);\n    }\n\n    public List&lt;JsonElement&gt; getArray() {\n        return array;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">/**\n * json AST的primitive类型节点\n * */\npublic class JsonPrimitiveStr extends JsonElement{\n\n    /**\n     * 基础类型的字符串字面量\n     * */\n    private final String primitiveValueStr;\n\n    public JsonPrimitiveStr(String primitiveValueStr) {\n        this.primitiveValueStr = primitiveValueStr;\n    }\n\n    public String getPrimitiveValueStr() {\n        return primitiveValueStr;\n    }\n}\n</code></pre>\n<h5 id=\"_-13\"></h5>\n<ul>\n<li>jsonElement是所有AST节点的共同抽象父类</li>\n<li>json的object结构映射为java中是一个有序的k/v Map结构</li>\n<li>json的array结构映射为java中是一个List结构</li>\n<li>json的primitive结构映射为java中的一个简单字符串字面量</li>\n</ul>\n<h3 id=\"32-json根节点语法解析\">3.2 json根节点语法解析</h3>\n<pre><code>json\n    element\n    \nelement\n    ws value ws\n\nvalue\n    object\n    array\n    string\n    number\n    \"true\"\n    \"false\"\n    \"null\"\n\nobject\n    '{' ws '}'\n    '{' members '}'    \n\narray\n    '[' ws ']'\n    '[' elements ']'\n</code></pre>\n<h5 id=\"_-14\"></h5>\n<p>上述文法中，json是AST的根节点，其最终可以是object、array或者5种基本类型的一种。<br />\nobject类型的f(1)有且仅有'{'，而array类型的f(1)有且仅有'['，因此我们可以构造出一个简单的根节点解析的状态机来实现语法分析。</p>\n<ul>\n<li>若token流中的第一个 token 是 <code>{</code> → 解析为 <code>JsonObject</code>。</li>\n<li>若token流中的第一个 token 是 <code>[</code> → 解析为 <code>JsonArray</code>。</li>\n<li>若token流中的第一个 token 是基础类型 → 解析为 <code>JsonPrimitiveStr</code>。</li>\n<li>否则都是非法json。</li>\n</ul>\n<h5 id=\"json根节点语法解析状态自动机\">json根节点语法解析状态自动机</h5>\n<p><img alt=\"json_parser_root\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195937409-994915878.png\" /></p>\n<h5 id=\"json根节点解析状态自动机实现\">json根节点解析状态自动机实现</h5>\n<pre><code class=\"language-java\">/**\n * 基于递归实现的json解析器\n * */\npublic class RecursiveJsonParser extends JsonParser {\n\n    public RecursiveJsonParser(JsonTokenReader tokenReader) {\n        super(tokenReader);\n    }\n\n    @Override\n    public JsonElement doParse() {\n        JsonToken token = jsonTokenReader.peek();\n\n        if (token.getType() == JsonTokenTypeEnum.LEFT_BRACE) {\n            JsonObjectParseStatementMachine jsonObjectParseStatementMachine = new JsonObjectParseStatementMachine(jsonTokenReader);\n\n            return jsonObjectParseStatementMachine.parseJsonElement();\n        }\n\n        if (token.getType() == JsonTokenTypeEnum.LEFT_BRACKET) {\n            JsonArrayParseStatementMachine jsonArrayParseStatementMachine = new JsonArrayParseStatementMachine(jsonTokenReader);\n\n            return jsonArrayParseStatementMachine.parseJsonElement();\n        }\n\n        // 基础类型的value\n        if (token.getType().isPrimitiveValue()) {\n            return new JsonPrimitiveStr(token.getContent());\n        }\n\n        // 第一个token，不属于json规则的f(1)集合\n        throw new MuJsonParserException(\"unexpected start json token! token=\" + jsonTokenReader.currentIndex());\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">public enum JsonTokenTypeEnum {\n    // 省略了无关逻辑\n\n    /**\n     * 基础类型的value（string、number、true、false、null）\n     * */\n    public boolean isPrimitiveValue(){\n        return this == STRING || this == NUMBER || this == NULL ||this == TRUE || this == FALSE;\n    }\n}\n</code></pre>\n<h3 id=\"33-json-object对象结构解析\">3.3 json object对象结构解析</h3>\n<p>现在我们来研究json object对象的语法解析。object结构是以“{”开头，“}”结尾的结构，内部可以有0到N个kv键值对，其中key必须是string类型，而value则可以是嵌套的结构，key和value之间以冒号分隔，kv对之间以逗号分割。<br />\n因此，使用递归的方式来实现object对象的语法解析是很容易理解和实现的(尽管递归的实现效率不够高)。</p>\n<h5 id=\"json-object对象结构语法\">json object对象结构语法</h5>\n<pre><code>object\n    '{' ws '}'\n    '{' members '}'\n\nmembers\n    member\n    member ',' members\n\nmember\n    ws string ws ':' element\n\nelement\n    ws value ws    \n\nvalue\n    object\n    array\n    string\n    number\n    \"true\"\n    \"false\"\n    \"null\"\n</code></pre>\n<p><img alt=\"json_object_parser\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195946762-1722527366.png\" /></p>\n<h5 id=\"object结构解析状态自动机示意图\">object结构解析状态自动机示意图</h5>\n<p><img alt=\"json_object_state_machine\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211195955922-1227811677.png\" /></p>\n<h5 id=\"object结构解析状态自动机递归实现递归版本\">object结构解析状态自动机递归实现（递归版本）</h5>\n<p>语法分析与词法分析类似，也是使用状态自动机来实现的。实现的大致方式也是通过抽象出一个父类(AbstractJsonParseStatementMachine),在父类中通过持续不断的从token流中读取token来推进状态。在子类中定义相应的状态处理器来实现每个状态的处理</p>\n<pre><code class=\"language-java\">/**\n * 基于递归实现的 object类型语法解析状态自动机\n * */\npublic class JsonObjectParseStatementMachine extends AbstractJsonParseStatementMachine&lt;JsonObject&gt;{\n\n    public JsonObjectParseStatementMachine(JsonTokenReader jsonTokenReader) {\n        this.jsonTokenReader = jsonTokenReader;\n        this.targetJsonElement = new JsonObject();\n        this.recursiveDoParserContext = new RecursiveDoParserContext&lt;&gt;(this.targetJsonElement);\n        stateHandlers = new ParserStateHandler[]{\n            new ParserState0Handler(),new ParserState1Handler(),new ParserState2Handler(),new ParserState3Handler(),\n            new ParserState4Handler(),new ParserState5Handler(),new ParserState6Handler()\n        };\n    }\n\n    private static class ParserState0Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() != JsonTokenTypeEnum.LEFT_BRACE){\n                throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n            }\n\n            accept(jsonTokenReader);\n            return 1;\n        }\n    }\n\n    private static class ParserState1Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() == JsonTokenTypeEnum.RIGHT_BRACE){\n                accept(jsonTokenReader);\n                return 2;\n            }\n\n            if(token.getType() == JsonTokenTypeEnum.STRING){\n                // 把key先压入栈中，然后等构造kv对时弹出\n                recursiveDoParserContext.getTokenStack().push(token);\n                accept(jsonTokenReader);\n                return 3;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private static class ParserState2Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            // 终态，直接返回\n            return -1;\n        }\n    }\n\n    private static class ParserState3Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() == JsonTokenTypeEnum.COLON){\n                accept(jsonTokenReader);\n                return 4;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private static class ParserState4Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            JsonToken keyToken = recursiveDoParserContext.getTokenStack().pop();\n            Assert.assertTrue(keyToken != null &amp;&amp; keyToken.getType() == JsonTokenTypeEnum.STRING,\"parse object keyToken not match!\");\n\n            // 嵌套的jsonObject结构\n            if(token.getType() == JsonTokenTypeEnum.LEFT_BRACE){\n                JsonObjectParseStatementMachine jsonObjectParseStatementMachine = new JsonObjectParseStatementMachine(jsonTokenReader);\n\n                JsonObject subJsonObject = jsonObjectParseStatementMachine.parseJsonElement();\n\n                // 构造好了一个kv对（key : obj）\n                recursiveDoParserContext.getTargetJsonElement().putKV(keyToken.getContent(), subJsonObject);\n\n                return 5;\n            }\n\n            // 嵌套的jsonArray结构\n            if(token.getType() == JsonTokenTypeEnum.LEFT_BRACKET){\n                // jsonArray状态机\n                JsonArrayParseStatementMachine jsonArrayParseStatementMachine = new JsonArrayParseStatementMachine(jsonTokenReader);\n\n                JsonArray jsonArray = jsonArrayParseStatementMachine.parseJsonElement();\n                // 构造好了一个kv对 (key ：array)\n                recursiveDoParserContext.getTargetJsonElement().putKV(keyToken.getContent(), jsonArray);\n\n                return 5;\n            }\n\n            // 基础类型的value\n            if(token.getType().isPrimitiveValue()){\n                accept(jsonTokenReader);\n                recursiveDoParserContext.getTargetJsonElement().putKV(keyToken.getContent(), new JsonPrimitiveStr(token.getContent()));\n\n                return 5;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private static class ParserState5Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() == JsonTokenTypeEnum.RIGHT_BRACE){\n                accept(jsonTokenReader);\n                return 2;\n            }\n\n            if(token.getType() == JsonTokenTypeEnum.COMMA){\n                accept(jsonTokenReader);\n                return 6;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private static class ParserState6Handler implements ParserStateHandler&lt;JsonObject&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonObject&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() == JsonTokenTypeEnum.STRING){\n                // 把key先压入栈中，然后等构造kv对时弹出\n                recursiveDoParserContext.getTokenStack().push(token);\n                accept(jsonTokenReader);\n                return 3;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">public class AbstractJsonParseStatementMachine&lt;T extends JsonElement&gt; {\n\n    protected JsonTokenReader jsonTokenReader;\n\n    protected RecursiveDoParserContext&lt;T&gt; recursiveDoParserContext;\n\n    protected int currentState = 0;\n\n    protected T targetJsonElement;\n\n    protected ParserStateHandler[] stateHandlers;\n\n    public T parseJsonElement(){\n        while(jsonTokenReader.hasNextToken()){\n            if(currentState == -1){\n                // 遇到了合法的分隔符号，退出token解析\n                return targetJsonElement;\n            }\n\n            if(currentState &gt;= stateHandlers.length){\n                // 有bug\n                throw new MuJsonParserException(String.format(\"unknown state! currentState=%s\",currentState));\n            }\n            ParserStateHandler targetStateHandler = stateHandlers[currentState];\n            \n            currentState = targetStateHandler.processInState(jsonTokenReader, recursiveDoParserContext);\n        }\n\n        return targetJsonElement;\n    }\n\n    protected static void accept(JsonTokenReader jsonTokenReader){\n        jsonTokenReader.nextToken();\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">public class RecursiveDoParserContext&lt;T extends JsonElement&gt;  {\n\n    private Stack&lt;JsonToken&gt; tokenStack = new Stack&lt;&gt;();\n\n    private T targetJsonElement;\n\n    public RecursiveDoParserContext(T targetJsonElement) {\n        this.targetJsonElement = targetJsonElement;\n    }\n\n    public Stack&lt;JsonToken&gt; getTokenStack() {\n        return tokenStack;\n    }\n\n    public T getTargetJsonElement() {\n        return targetJsonElement;\n    }\n}\n</code></pre>\n<h5 id=\"_-15\"></h5>\n<ul>\n<li>在解析kv对时，需要先将string类型的key暂时缓存起来，等待后续的value类型结构(object、array或者primitive)也完成解析后，再一并的放入AST中(getTargetJsonElement().putKV)。</li>\n<li>解析kv对的value时，当前的实现是基于递归实现的。即当根据当前token的类型创建一个新的对应类型的状态机，去递归的解析更深一层的AST结构。<br />\n递归实现的好处是思路简单易懂，不用过多的考虑不同类型结构之间状态的互相转移，通过递归解析子AST的方式天然的屏蔽掉了大量的复杂度。<br />\n但缺点也同样明显，在解析层次非常深的json字符串时，递归的层次过深可能会导致当前线程栈溢出，解析失败。</li>\n</ul>\n<h3 id=\"34-json-array数组结构解析\">3.4 json array数组结构解析</h3>\n<p>array结构是以“[”开头，“]”结尾的结构，内部可以有0到N个value类型的元素,以逗号做分割，value同样是可以是嵌套的结构。与上面object结构的解析实现方式一样，同样是基于递归实现的。</p>\n<h5 id=\"json-array数组结构语法\">json array数组结构语法</h5>\n<pre><code>array\n    '[' ws ']'\n    '[' elements ']'\n\nelements\n    element\n    element ',' elements\n\nelement\n    ws value ws\n\nvalue\n    object\n    array\n    string\n    number\n    \"true\"\n    \"false\"\n    \"null\"\n</code></pre>\n<p><img alt=\"json_array_parser\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211200007327-1872691214.png\" /></p>\n<h5 id=\"array结构解析状态自动机示意图\">array结构解析状态自动机示意图</h5>\n<p><img alt=\"json_array_state_machine\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211200016319-1527985884.png\" /></p>\n<h5 id=\"array结构解析状态自动机递归实现递归版本\">array结构解析状态自动机递归实现（递归版本）</h5>\n<pre><code class=\"language-java\">/**\n * 基于递归实现的 array类型语法解析状态自动机\n * */\npublic class JsonArrayParseStatementMachine extends AbstractJsonParseStatementMachine&lt;JsonArray&gt; {\n\n    public JsonArrayParseStatementMachine(JsonTokenReader jsonTokenReader) {\n        this.jsonTokenReader = jsonTokenReader;\n        this.targetJsonElement = new JsonArray();\n        this.recursiveDoParserContext = new RecursiveDoParserContext&lt;&gt;(this.targetJsonElement);\n        stateHandlers = new ParserStateHandler[]{\n            new ParserState0Handler(),new ParserState1Handler(),new ParserState2Handler(),\n            new ParserState3Handler(), new ParserState4Handler()\n        };\n    }\n\n    private static class ParserState0Handler implements ParserStateHandler&lt;JsonArray&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonArray&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() != JsonTokenTypeEnum.LEFT_BRACKET){\n                throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n            }\n\n            accept(jsonTokenReader);\n            return 1;\n        }\n    }\n\n    private static class ParserState1Handler implements ParserStateHandler&lt;JsonArray&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonArray&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() == JsonTokenTypeEnum.RIGHT_BRACKET){\n                accept(jsonTokenReader);\n                return 2;\n            }\n\n            // 嵌套的jsonObject结构\n            if(token.getType() == JsonTokenTypeEnum.LEFT_BRACE){\n                JsonObjectParseStatementMachine jsonObjectParseStatementMachine = new JsonObjectParseStatementMachine(jsonTokenReader);\n\n                JsonObject subJsonObject = jsonObjectParseStatementMachine.parseJsonElement();\n\n                // add一个obj\n                recursiveDoParserContext.getTargetJsonElement().addElement(subJsonObject);\n\n                return 3;\n            }\n\n            // 嵌套的jsonArray结构\n            if(token.getType() == JsonTokenTypeEnum.LEFT_BRACKET){\n                // jsonArray状态机\n                JsonArrayParseStatementMachine jsonArrayParseStatementMachine = new JsonArrayParseStatementMachine(jsonTokenReader);\n\n                JsonArray jsonArray = jsonArrayParseStatementMachine.parseJsonElement();\n\n                // add一个array\n                recursiveDoParserContext.getTargetJsonElement().addElement(jsonArray);\n\n                return 3;\n            }\n\n            // 基础类型的value\n            if(token.getType().isPrimitiveValue()){\n                accept(jsonTokenReader);\n                recursiveDoParserContext.getTargetJsonElement().addElement(new JsonPrimitiveStr(token.getContent()));\n\n                return 3;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private static class ParserState2Handler implements ParserStateHandler&lt;JsonArray&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonArray&gt; recursiveDoParserContext) {\n            // 终态，直接返回\n            return -1;\n        }\n    }\n\n    private static class ParserState3Handler implements ParserStateHandler&lt;JsonArray&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonArray&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            if(token.getType() == JsonTokenTypeEnum.RIGHT_BRACKET){\n                accept(jsonTokenReader);\n                return 2;\n            }\n\n            if(token.getType() == JsonTokenTypeEnum.COMMA){\n                accept(jsonTokenReader);\n                return 4;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private static class ParserState4Handler implements ParserStateHandler&lt;JsonArray&gt;{\n\n        @Override\n        public int processInState(JsonTokenReader jsonTokenReader, RecursiveDoParserContext&lt;JsonArray&gt; recursiveDoParserContext) {\n            JsonToken token = jsonTokenReader.peek();\n\n            // 嵌套的jsonObject结构\n            if(token.getType() == JsonTokenTypeEnum.LEFT_BRACE){\n                JsonObjectParseStatementMachine jsonObjectParseStatementMachine = new JsonObjectParseStatementMachine(jsonTokenReader);\n\n                JsonObject subJsonObject = jsonObjectParseStatementMachine.parseJsonElement();\n\n                // add一个obj\n                recursiveDoParserContext.getTargetJsonElement().addElement(subJsonObject);\n\n                return 3;\n            }\n\n            // 嵌套的jsonArray结构\n            if(token.getType() == JsonTokenTypeEnum.LEFT_BRACKET){\n                // jsonArray状态机\n                JsonArrayParseStatementMachine jsonArrayParseStatementMachine = new JsonArrayParseStatementMachine(jsonTokenReader);\n\n                JsonArray jsonArray = jsonArrayParseStatementMachine.parseJsonElement();\n\n                // add一个array\n                recursiveDoParserContext.getTargetJsonElement().addElement(jsonArray);\n\n                return 3;\n            }\n\n            // 基础类型的value\n            if(token.getType().isPrimitiveValue()){\n                accept(jsonTokenReader);\n                recursiveDoParserContext.getTargetJsonElement().addElement(new JsonPrimitiveStr(token.getContent()));\n\n                return 3;\n            }\n\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n}\n</code></pre>\n<h5 id=\"_-16\"></h5>\n<ul>\n<li>相比object结构的状态自动机，array结构的状态自动机则显得比较简单。同样在遇到复杂类型的结构时，通过当前token的类型递归的创建一个新的状态机去构造出子AST(JsonElement)，然后加入到当前JsonArray中(getTargetJsonElement().addElement)。</li>\n</ul>\n<h2 id=\"4-基于ast生成beauty-json字符串\">4. 基于AST生成beauty json字符串</h2>\n<p>现在我们已经实现了json的词法解析和语法解析，可以将一个原始的合法的json字符串正确的转换成对应的AST了。<br />\n拿到AST之后理论上可以做很多事情，比如将json串反序列化为java对象。这里我们实现一个<strong>更简单也更直观的功能</strong>，即将原始的json字符串格式化成缩进良好，更美观，可读性更佳的beauty字符串。</p>\n<h5 id=\"生成格式化后的beauty-json字符串实现\">生成格式化后的beauty json字符串实现</h5>\n<pre><code class=\"language-java\">public abstract class JsonElement {\n\n    private static final String BEAUTY_INDENT = \"    \";  // 四个空格缩进\n    private static final String BEAUTY_KV_INDENT = \" \";  // kv多一个空格\n    private static final String BEAUTY_LINE_BREAK = \"\\n\"; // 换行分割\n\n    /**\n     * 生成美化后的beauty字符串\n     * */\n    public String buildBeautyJsonString(){\n        StringBuilder jsonStringBuilder = new StringBuilder();\n\n        buildJsonString(this,jsonStringBuilder,\"\",BEAUTY_LINE_BREAK,BEAUTY_INDENT,BEAUTY_KV_INDENT);\n\n        return jsonStringBuilder.toString();\n    }\n\n    private static void buildJsonString(JsonElement jsonElement, StringBuilder jsonStringBuilder, String currentIndent,\n                                        String lineBreak, String indent, String kvIndent){\n        if(jsonElement instanceof JsonPrimitiveStr){\n            jsonStringBuilder.append(jsonElement);\n            return;\n        }\n\n        if(jsonElement instanceof JsonArray){\n            JsonArray jsonArray  = (JsonArray) jsonElement;\n            jsonStringBuilder.append(\"[\").append(lineBreak);\n            List&lt;JsonElement&gt; jsonArrayList = jsonArray.getArray();\n            int i=0;\n            for(JsonElement arrayItem : jsonArrayList){\n                jsonStringBuilder.append(currentIndent).append(indent);\n                // 递归下去，currentIndent多缩进一层\n                buildJsonString(arrayItem,jsonStringBuilder,currentIndent + indent,lineBreak,indent,kvIndent);\n                if(i != jsonArrayList.size()-1){\n                    jsonStringBuilder.append(\",\");\n                }\n\n                jsonStringBuilder.append(lineBreak);\n                i++;\n            }\n\n            jsonStringBuilder.append(currentIndent).append(\"]\");\n        }\n\n        if(jsonElement instanceof JsonObject){\n            JsonObject jsonObject  = (JsonObject) jsonElement;\n            jsonStringBuilder.append(\"{\").append(lineBreak);\n\n            Map&lt;String, JsonElement&gt; objMap = jsonObject.getObjMap();\n\n            int i=0;\n            for(Map.Entry&lt;String, JsonElement&gt; entry : objMap.entrySet()){\n                String key = entry.getKey();\n                JsonElement value = entry.getValue();\n\n                // key是string类型的，字面量里自带双引号的\n                jsonStringBuilder.append(currentIndent).append(indent).append(key).append(kvIndent).append(\":\").append(kvIndent);\n                // 递归下去，currentIndent多缩进一层\n                buildJsonString(value,jsonStringBuilder,  currentIndent + indent, lineBreak,indent,kvIndent);\n\n                if(i != objMap.size()-1){\n                    jsonStringBuilder.append(\",\");\n                }\n\n                jsonStringBuilder.append(lineBreak);\n                i++;\n            }\n\n            jsonStringBuilder.append(currentIndent).append(\"}\");\n        }\n    }\n}\n</code></pre>\n<h5 id=\"_-17\"></h5>\n<ul>\n<li>从源码实现中可以看到，输出美化后的beauty字符串本质上就是一个针对AST树形结构的<strong>深度优先遍历</strong>，只需要注意随着递归深度动态调整缩进长度即可。</li>\n<li>格式化json的方式多种多样，像jackson这样成熟的json处理框架中提供了大量的配置参数允许用户以所想要的方式非常灵活的生成所需格式的json字符串。我们这里的实现不够灵活，性能也不够高效，仅仅是起到一个抛砖引玉的作用。</li>\n</ul>\n<h5 id=\"json-beauty示意图\">json beauty示意图</h5>\n<p><img alt=\"json_beauty_demo\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211200026283-104525624.png\" /></p>\n<h2 id=\"5-流式的json词法解析\">5. 流式的json词法解析</h2>\n<p>截止目前我们已经实现了json字符串的解析功能，但还存在两个严重的性能问题需要优化。</p>\n<ul>\n<li>首先是目前的词法分析器是一次性的解析出所有的token后，再交给语法分析去解析的。而这存在一个隐患，因为很多时候我们实际解析的并不总是一个合法的json字符串。<br />\n如果一个非常长的不合法的json字符串，在词法分析阶段看不出任何的问题(比如在合法的以<code>{</code>开头的 json字符串的前面误追加一个123)，而直到语法分析才发现存在语法错误，那么词法分析阶段花费的计算资源就统统浪费了。</li>\n<li>如果能够在完整的词法分析处理的过程中提前发现语法错误就能避免这个问题。但实现这个功能不需要将词法分析和语法分析的功能耦合在一起，而是将词法分析器改造成按需加载的流式解析即可。<br />\n流式的词法分析能够在语法解析器需要读取token时才触发词法分析，并且一次可以只按需的完整解析出一个完整的token交给parser。</li>\n<li>有了流式的词法分析，像上面举得例子，在合法的非常长的json字符串的前面误加一个123的场景，便能够很早的就发现语法错误，结束解析过程。</li>\n</ul>\n<h5 id=\"流式的词法分析解析实现\">流式的词法分析解析实现</h5>\n<pre><code class=\"language-java\">public class StreamJsonLexer extends AbstractJsonLexer{\n\n    public StreamJsonLexer(String jsonString) {\n        super(jsonString);\n    }\n\n    public JsonToken doLex(){\n        if(doLexContext.currentIndex &gt;= jsonStringArray.length){\n            return new JsonToken(JsonTokenTypeEnum.EOF);\n        }\n\n        while(true) {\n            char ch = jsonStringArray[doLexContext.currentIndex];\n\n            // 每一次尝试解析一个完整的token前，都是状态0\n            switch (ch) {\n                case '{':\n                    doLexContext.currentIndex++;\n                    return new JsonToken(JsonTokenTypeEnum.LEFT_BRACE);\n                case '}':\n                    doLexContext.currentIndex++;\n                    return new JsonToken(JsonTokenTypeEnum.RIGHT_BRACE);\n                case '[':\n                    doLexContext.currentIndex++;\n                    return new JsonToken(JsonTokenTypeEnum.LEFT_BRACKET);\n                case ']':\n                    doLexContext.currentIndex++;\n                    return new JsonToken(JsonTokenTypeEnum.RIGHT_BRACKET);\n                case ',':\n                    doLexContext.currentIndex++;\n                    return new JsonToken(JsonTokenTypeEnum.COMMA);\n                case ':':\n                    doLexContext.currentIndex++;\n                    return new JsonToken(JsonTokenTypeEnum.COLON);\n                case '\"':\n                    return parseString(jsonStringArray, doLexContext);\n                case 't':\n                    // 尝试解析true关键字\n                    return parseTrueKeyword(jsonStringArray, doLexContext);\n                case 'f':\n                    // 尝试解析false关键字\n                    return parseFalseKeyword(jsonStringArray, doLexContext);\n                case 'n':\n                    // 尝试解析null关键字\n                    return parseNullKeyword(jsonStringArray, doLexContext);\n                default:\n                    // 走其它case\n                    break;\n            }\n\n            // 其它case\n            if (CommonStringUtil.is0_9(ch) || ch == '-') {\n                // number解析\n                return parseNumber(jsonStringArray, doLexContext);\n            } else if (CommonStringUtil.isWhitespace(ch)) {\n                // whiteSpace 直接跳过\n                doLexContext.currentIndex++;\n            } else{\n                throw new MuJsonParserException(\"unexpected character: \" + ch + \",charIndex=\" + doLexContext.currentIndex);\n            }\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">public class StreamJsonTokenReader implements JsonTokenReader {\n\n    private int currentIndex;\n    private final StreamJsonLexer streamJsonLexer;\n\n    private JsonToken peekToken;\n    private boolean hasNextToken;\n\n    public StreamJsonTokenReader(String jsonString) {\n        this.currentIndex = 0;\n        this.hasNextToken = true;\n        this.streamJsonLexer = new StreamJsonLexer(jsonString);\n    }\n\n    @Override\n    public boolean hasNextToken() {\n        return hasNextToken;\n    }\n\n    @Override\n    public JsonToken nextToken() {\n        JsonToken nextToken = getNextToken();\n        if(nextToken.getType() == JsonTokenTypeEnum.EOF){\n            hasNextToken = false;\n        }\n\n        currentIndex++;\n        return nextToken;\n    }\n\n    private JsonToken getNextToken() {\n        if(peekToken != null){\n            JsonToken nextToken = peekToken;\n            this.peekToken = null;\n            return nextToken;\n        }\n\n        return streamJsonLexer.doLex();\n    }\n\n    @Override\n    public JsonToken peek() {\n        if(peekToken == null) {\n            peekToken = streamJsonLexer.doLex();\n        }\n\n        return peekToken;\n    }\n\n    @Override\n    public int currentIndex() {\n        return currentIndex;\n    }\n}\n</code></pre>\n<h5 id=\"_-18\"></h5>\n<ul>\n<li>流式的词法解析器StreamJsonLexer的核心工作原理与之前已经实现的静态的StaticJsonLexer别无二致，其底层依赖的代码都是相同的。<br />\n最大的区别在于解析出一个完整的token后，在维护当前字符流下标的同时提前终止了后续的词法分析。在StreamJsonTokenReader调用nextToken时，才会按需的惰性解析新的token并返回。</li>\n<li>流式的词法解析毫无疑问是性能更好的，主流的json解析器也都是流式的解析。但静态的词法解析更容易理解，也更容易调试，所以在一开始介绍词法分析原理时，我们先实现了静态的词法分析，将其作为基础，略微的改造后便实现了流式的词法解析。</li>\n</ul>\n<h2 id=\"6-基于堆栈实现的json语法解析\">6. 基于堆栈实现的json语法解析</h2>\n<p>第二个性能问题则是基于递归实现的json语法解析器受限于较小的线程栈空间，无法处理嵌套层级非常深的json串。</p>\n<ul>\n<li>我们知道，一个普通的java进程通常都含有大量的线程，因此给每个线程分配的线程栈通常都比较小，比如1m。而递归实现的语法解析器，在每深入一个层次的json子树时便会向栈上压入一些局部变量，当极端情况下要解析的json串层次过深时，则会出现StackOverflowError，导致解析失败。</li>\n<li>而内存的堆通常都是以GB为单位的，因此如果把递归中隐式压栈的解析逻辑转换为等价的显式基于内存堆的压栈，则可以很好的解决线程栈过小无法处理大深度json串的问题了。</li>\n</ul>\n<h5 id=\"基于堆栈的语法解析状态自动机示意图\">基于堆栈的语法解析状态自动机示意图</h5>\n<p><img alt=\"stack_base_json_parser_state_machine\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211200035364-62927704.png\" /></p>\n<ul>\n<li>为了尽可能的将状态转移与递归实现的逻辑保持一致，堆栈的状态自动机依然冗余了两个状态(obj-0和arr-0)。</li>\n<li>可以看到，基于堆栈的状态自动机会在array与object的解析状态中互相转移，相当于将之前递归实现的各个状态自动机的子状态图合并为了一个大而全的状态自动机。</li>\n<li>同时，由于还涉及了手动模拟的入栈与出栈处理(obj-2，obj-4，arr-1，arr-2)，因此整体的复杂度比起递归实现要高出一个量级。</li>\n</ul>\n<h5 id=\"json根节点解析状态自动机实现源码\">json根节点解析状态自动机实现源码</h5>\n<pre><code class=\"language-java\">/**\n * 基于堆栈的，非递归的json语法解析器\n * */\npublic class StackBaseJsonParser extends JsonParser {\n\n    private final JsonParseStack parseStack = new JsonParseStack();\n\n    private StackBaseJsonParserStatusEnum currentStatus;\n\n    public StackBaseJsonParser(JsonTokenReader tokenReader) {\n        super(tokenReader);\n\n        this.currentStatus = StackBaseJsonParserStatusEnum.START_PARSE;\n    }\n\n    private void accept(){\n        jsonTokenReader.nextToken();\n    }\n\n    @Override\n    public JsonElement doParse() {\n        while(jsonTokenReader.hasNextToken()){\n            JsonToken token = jsonTokenReader.peek();\n\n            if(currentStatus == StackBaseJsonParserStatusEnum.END_PARSE){\n                break;\n            }\n\n            switch (currentStatus){\n                case START_PARSE:\n                    processInStartParse(token);\n                    break;\n                case PARSE_OBJECT_0:\n                    processInParseObject0(token);\n                    break;\n                case PARSE_OBJECT_1:\n                    processInParseObject1(token);\n                    break;\n                case PARSE_OBJECT_2:\n                    processInParseObject2(token);\n                    break;\n                case PARSE_OBJECT_3:\n                    processInParseObject3(token);\n                    break;\n                case PARSE_OBJECT_4:\n                    processInParseObject4(token);\n                    break;\n                case PARSE_OBJECT_5:\n                    processInParseObject5(token);\n                    break;\n                case PARSE_OBJECT_6:\n                    processInParseObject6(token);\n                    break;\n                case PARSE_ARR_0:\n                    processInParseArr0(token);\n                    break;\n                case PARSE_ARR_1:\n                    processInParseArr1(token);\n                    break;\n                case PARSE_ARR_2:\n                    processInParseArr2(token);\n                    break;\n                case PARSE_ARR_3:\n                    processInParseArr3(token);\n                    break;\n                default:\n                    throw new MuJsonParserException(\"Unexpected currentStatus: \" + currentStatus);\n            }\n        }\n\n        // 如果json字符串是合法的，那么最后栈顶必然是有且唯一的一个JsonElement类型的对象\n        if(this.parseStack.size() != 1){\n            throw new MuJsonParserException(\"after parse，stack element size &gt; 1! stack=\" + this.parseStack);\n        }\n\n        JsonParseStackValue object = this.parseStack.pop();\n        return (JsonElement) object.getValue();\n    }\n\n    private void processInStartParse(JsonToken token){\n        if (token.getType() == JsonTokenTypeEnum.LEFT_BRACE) {\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_0;\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_OBJECT,new JsonObject()));\n            return;\n        }\n\n        if (token.getType() == JsonTokenTypeEnum.LEFT_BRACKET) {\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_0;\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_ARRAY,new JsonArray()));\n            return;\n        }\n\n        if (token.getType().isPrimitiveValue()) {\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.END_PARSE;\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_PRIMITIVE,new JsonPrimitiveStr(token.getContent())));\n            return;\n        }\n\n        // 第一个token，不属于json规则的f(1)集合\n        throw new MuJsonParserException(\"unexpected start json token! token=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseObject0(JsonToken token){\n        if(token.getType() != JsonTokenTypeEnum.LEFT_BRACE){\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n\n        accept();\n\n        this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_1;\n    }\n\n    private void processInParseObject1(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.RIGHT_BRACE){\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_2;\n            return;\n        }\n\n        if(token.getType() == JsonTokenTypeEnum.STRING){\n            // 把key先压入栈中，然后等构造kv对时弹出\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_KEY,token));\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_3;\n            return;\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseObject2(JsonToken token){\n        // 遇到'}'才会进来\n        if(token.getType() != JsonTokenTypeEnum.RIGHT_BRACE){\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }else{\n            accept();\n        }\n\n        // 当前栈顶必定是JsonObject，先将其弹出，然后看栈顶的元素类型判断\n        JsonParseStackValue currentJsonObjectStackValue = this.parseStack.popAndCheck(JsonParseStackValueTypeEnum.JSON_OBJECT);\n        if(this.parseStack.isEmpty()){\n            // 说明是root的JsonObject解析完了，再推回去直接返回\n            this.parseStack.push(currentJsonObjectStackValue);\n            this.currentStatus = StackBaseJsonParserStatusEnum.END_PARSE;\n            return;\n        }\n\n        JsonObject currentJsonObject = (JsonObject) currentJsonObjectStackValue.getValue();\n\n        JsonParseStackValueTypeEnum topObjType = this.parseStack.peekTopType();\n\n        if(topObjType == JsonParseStackValueTypeEnum.JSON_KEY){\n            // 如果是json_key，说明是当前jsonObject是父object的一个k/v项中的value。\n            JsonParseStackValue keyStackValue = this.parseStack.popAndCheck(JsonParseStackValueTypeEnum.JSON_KEY);\n            JsonToken keyJsonToken = (JsonToken) keyStackValue.getValue();\n            JsonParseStackValue parentObject = this.parseStack.peekAndCheck(JsonParseStackValueTypeEnum.JSON_OBJECT);\n\n            // 将当前k/v项附加在父object上\n            ((JsonObject)parentObject.getValue()).putKV(keyJsonToken.getContent(), currentJsonObject);\n\n            // 基于下一个token判断状态跳转\n            JsonToken nextJsonToken = this.jsonTokenReader.peek();\n            if(nextJsonToken.getType() == JsonTokenTypeEnum.COMMA){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_5;\n                return;\n            }else if (nextJsonToken.getType() == JsonTokenTypeEnum.RIGHT_BRACE){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_2;\n                return;\n            }else{\n                throw new MuJsonParserException(\"unexpected token! index=\" + (jsonTokenReader.currentIndex()+1));\n            }\n\n        }else if(topObjType == JsonParseStackValueTypeEnum.JSON_ARRAY){\n            // 说明当前jsonObject是jsonArray的一个元素\n\n            JsonParseStackValue parentArr = this.parseStack.peekAndCheck(JsonParseStackValueTypeEnum.JSON_ARRAY);\n            ((JsonArray)parentArr.getValue()).addElement(currentJsonObject);\n\n            // 基于下一个token判断状态跳转\n            JsonToken nextJsonToken = this.jsonTokenReader.peek();\n            if(nextJsonToken.getType() == JsonTokenTypeEnum.COMMA){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_3;\n                return;\n            }else if (nextJsonToken.getType() == JsonTokenTypeEnum.RIGHT_BRACKET){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_2;\n                return;\n            }else{\n                throw new MuJsonParserException(\"unexpected token! index=\" + (jsonTokenReader.currentIndex()+1));\n            }\n        }else{\n            // 别的情况都说明有问题，不是合法的json\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private void processInParseObject3(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.COLON){\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_4;\n            return;\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseObject4(JsonToken token){\n        // 嵌套的jsonObject结构\n        if(token.getType() == JsonTokenTypeEnum.LEFT_BRACE){\n            // 发现'{'，栈上推进一个JsonObject\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_OBJECT, new JsonObject()));\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_1;\n            return;\n        }\n\n        // 嵌套的jsonArray结构\n        if(token.getType() == JsonTokenTypeEnum.LEFT_BRACKET){\n            // 发现'['，栈上推进一个JsonArr\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_ARRAY, new JsonArray()));\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_1;\n            return;\n        }\n\n        // 基础类型的value\n        if(token.getType().isPrimitiveValue()){\n            JsonParseStackValue jsonKeyToken = this.parseStack.popAndCheck(JsonParseStackValueTypeEnum.JSON_KEY);\n\n            JsonToken keyToken  = (JsonToken) jsonKeyToken.getValue();\n            Assert.assertTrue(keyToken.getType() == JsonTokenTypeEnum.STRING,\"parse object keyToken not match!\");\n\n            // 获取栈顶的jsonObject对象，设置k/v\n            JsonParseStackValue topJsonObject = this.parseStack.peekAndCheck(JsonParseStackValueTypeEnum.JSON_OBJECT);\n\n            ((JsonObject) topJsonObject.getValue()).putKV(keyToken.getContent(), new JsonPrimitiveStr(token.getContent()));\n\n            accept();\n\n            // 基于下一个token判断状态跳转\n            JsonToken nextJsonToken = this.jsonTokenReader.peek();\n            if(nextJsonToken.getType() == JsonTokenTypeEnum.COMMA){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_5;\n                return;\n            }else if (nextJsonToken.getType() == JsonTokenTypeEnum.RIGHT_BRACE){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_2;\n                return;\n            }else{\n                throw new MuJsonParserException(\"unexpected token! index=\" + (jsonTokenReader.currentIndex()+1));\n            }\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseObject5(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.COMMA){\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_6;\n            return;\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseObject6(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.STRING){\n            // 把key先压入栈中，然后等构造kv对时弹出\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_KEY,token));\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_3;\n            return;\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseArr0(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.LEFT_BRACKET){\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_1;\n            return;\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseArr1(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.RIGHT_BRACKET){\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_2;\n            return;\n        }\n\n        // 嵌套的jsonObject结构\n        if(token.getType() == JsonTokenTypeEnum.LEFT_BRACE){\n            // 发现'{'，栈上推进一个JsonObject\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_OBJECT, new JsonObject()));\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_1;\n            return;\n        }\n\n        // 嵌套的jsonArray结构\n        if(token.getType() == JsonTokenTypeEnum.LEFT_BRACKET){\n            // 发现'['，栈上推进一个JsonArr\n            this.parseStack.push(new JsonParseStackValue(JsonParseStackValueTypeEnum.JSON_ARRAY, new JsonArray()));\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_1;\n            return;\n        }\n\n        // 基础类型的value\n        if(token.getType().isPrimitiveValue()){\n            // 获取栈顶的jsonArr对象，添加一个元素\n            JsonParseStackValue topJsonArr = this.parseStack.peekAndCheck(JsonParseStackValueTypeEnum.JSON_ARRAY);\n\n            ((JsonArray) topJsonArr.getValue()).addElement(new JsonPrimitiveStr(token.getContent()));\n\n            accept();\n\n            // 基于下一个token判断状态跳转\n            JsonToken nextJsonToken = this.jsonTokenReader.peek();\n            if(nextJsonToken.getType() == JsonTokenTypeEnum.COMMA){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_3;\n                return;\n            }else if (nextJsonToken.getType() == JsonTokenTypeEnum.RIGHT_BRACKET){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_2;\n                return;\n            }else{\n                throw new MuJsonParserException(\"unexpected token! index=\" + (jsonTokenReader.currentIndex()+1));\n            }\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n\n    private void processInParseArr2(JsonToken token){\n        // 遇到']'才会进来\n        if(token.getType() != JsonTokenTypeEnum.RIGHT_BRACKET){\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }else{\n            accept();\n        }\n\n        // 当前栈顶必定是JsonArray，先将其弹出，然后看栈顶的元素类型判断\n        JsonParseStackValue currentJsonObjectStackValue = this.parseStack.popAndCheck(JsonParseStackValueTypeEnum.JSON_ARRAY);\n        if(this.parseStack.isEmpty()){\n            // 说明是root的JsonArr解析完了，再推回去直接返回\n            this.parseStack.push(currentJsonObjectStackValue);\n            this.currentStatus = StackBaseJsonParserStatusEnum.END_PARSE;\n            return;\n        }\n\n        JsonArray jsonArray = (JsonArray) currentJsonObjectStackValue.getValue();\n\n        JsonParseStackValueTypeEnum topObjType = this.parseStack.peekTopType();\n\n        if(topObjType == JsonParseStackValueTypeEnum.JSON_KEY){\n            // 如果是json_key，说明是当前jsonArray是父object的一个k/v项中的value。\n            JsonParseStackValue keyStackValue = this.parseStack.popAndCheck(JsonParseStackValueTypeEnum.JSON_KEY);\n            JsonToken keyJsonToken = (JsonToken) keyStackValue.getValue();\n\n            JsonParseStackValue parentObject = this.parseStack.peekAndCheck(JsonParseStackValueTypeEnum.JSON_OBJECT);\n\n            // 将当前k/v项附加在父object上\n            ((JsonObject)parentObject.getValue()).putKV(keyJsonToken.getContent(), jsonArray);\n\n            // 基于下一个token判断状态跳转\n            JsonToken nextJsonToken = this.jsonTokenReader.peek();\n            if(nextJsonToken.getType() == JsonTokenTypeEnum.COMMA){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_5;\n                return;\n            }else if (nextJsonToken.getType() == JsonTokenTypeEnum.RIGHT_BRACE){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_OBJECT_2;\n                return;\n            }else{\n                throw new MuJsonParserException(\"unexpected token! index=\" + (jsonTokenReader.currentIndex()+1));\n            }\n\n        }else if(topObjType == JsonParseStackValueTypeEnum.JSON_ARRAY){\n            // 说明当前jsonObject是jsonArray的一个元素\n\n            JsonParseStackValue parentArr = this.parseStack.peekAndCheck(JsonParseStackValueTypeEnum.JSON_ARRAY);\n            ((JsonArray)parentArr.getValue()).addElement(jsonArray);\n\n            // 基于下一个token判断状态跳转\n            JsonToken nextJsonToken = this.jsonTokenReader.peek();\n            if(nextJsonToken.getType() == JsonTokenTypeEnum.COMMA){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_3;\n                return;\n            }else if (nextJsonToken.getType() == JsonTokenTypeEnum.RIGHT_BRACKET){\n                this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_2;\n                return;\n            }else{\n                throw new MuJsonParserException(\"unexpected token! index=\" + (jsonTokenReader.currentIndex()+1));\n            }\n        }else{\n            // 别的情况都说明有问题，不是合法的json\n            throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n        }\n    }\n\n    private void processInParseArr3(JsonToken token){\n        if(token.getType() == JsonTokenTypeEnum.COMMA){\n            accept();\n            this.currentStatus = StackBaseJsonParserStatusEnum.PARSE_ARR_1;\n            return;\n        }\n\n        throw new MuJsonParserException(\"unexpected token! index=\" + jsonTokenReader.currentIndex());\n    }\n}\n\n</code></pre>\n<h5 id=\"比较堆栈与递归实现性能差异的demo\">比较堆栈与递归实现性能差异的demo</h5>\n<p>我们可以很简单的构造出一个非常深嵌套层次的json串，即由连续N个“[”和连续N个“]”构成的json字符串。即根节点为数组，同时每个数组中都有且仅有一个子元素，子元素的类型依然是数组，依次类推。</p>\n<pre><code class=\"language-java\">public class TestHugeLevelJsonParse {\n\n    @Test\n    public void testHugeLevelJsonParse() {\n        int level = 3500;\n        String hugeLevelJson = TestUtil.buildHugeLevelJson(level);\n\n        // 3500层的深度，会StackOverflowError栈溢出\n        Error recursiveJsonParseEx = null;\n        try{\n            RecursiveJsonParser recursiveJsonParser = new RecursiveJsonParser(new StreamJsonTokenReader(hugeLevelJson));\n            JsonElement obj = recursiveJsonParser.doParse();\n        }catch (Error e){\n            recursiveJsonParseEx = e;\n        }\n\n        Assert.assertTrue(recursiveJsonParseEx instanceof StackOverflowError);\n        System.out.println(\"level = \" + level + \" recursiveJsonParseEx has StackOverflowError!\");\n\n        // jackson默认json深度为1000，超过了会报错\n        {\n            try {\n                Object obj = JackSonUtil.string2Obj(hugeLevelJson, Object.class);\n            }catch (Exception e){\n                // 会报错\n                System.out.println(\"jackson parse hugeLevelJson error!   \" + e.getCause().getMessage());\n            }\n        }\n\n        // 基于堆栈的能正确的解析出来，不会StackOverflowError栈溢出\n        {\n            StackBaseJsonParser stackBaseJsonParser = new StackBaseJsonParser(new StreamJsonTokenReader(hugeLevelJson));\n            JsonElement obj = stackBaseJsonParser.doParse();\n            int arrayLevel = TestUtil.getSpecialJsonArrayLevel(obj);\n            Assert.assertEquals(arrayLevel, level - 1);\n            System.out.println(\"stackBaseJsonParser parse，arrayLevel=\" + arrayLevel);\n        }\n    }\n}\n</code></pre>\n<p><img alt=\"test_huge_level_json_parse\" src=\"https://img2024.cnblogs.com/blog/1506329/202602/1506329-20260211200045678-964632399.png\" /></p>\n<h5 id=\"递归-vs-堆栈解析的取舍\">递归 vs 堆栈解析的取舍</h5>\n<ul>\n<li>基于递归的json语法解析器实现简单，思路更直观，但受限于线程栈大小，在极深层级下会出现StackOverflow。</li>\n<li>基于堆栈的json语法解析器状态机更庞大，实现起来更复杂，但将调用栈搬到堆上之后，能处理极深层级的json（只要堆内存足够）。</li>\n<li>Jackson等成熟的三方库即使同样基于堆栈实现，通常也会设置一个合理的深度上限，避免恶意或异常的json导致系统资源耗尽。</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>到这里，我们已经如开头所说的那般，一步一步的从零开始实现了一个简单的json解析器。<br />\n虽然网络上已经有着大量关于json解析器实现原理的博客，甚至利用ai都能帮你实现的大差不差。但是纸上得来终觉浅，绝知此事要躬行，想要更好的学习编译原理，去理解乃至实现更复杂的编译器、解释器，通过自己动手去体会那些晦涩抽象的原理也许是一种效率较低但长远看受益无穷的学习方式。</p>\n<h5 id=\"_-19\"></h5>\n<p>博客中展示的完整代码在我的github上：<a href=\"https://github.com/1399852153/MySimpleJsonParser\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/1399852153/MySimpleJsonParser</a> (main分支)。<br />\n希望能够帮助到对json解析或是编译原理感兴趣的读者，内容如有错误，还请多多指教。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-02-11 20:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xiaoxiongcanguan\">小熊餐馆</a>&nbsp;\n阅读(<span id=\"post_view_count\">16</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "类型擦除与部分异步编程",
      "link": "https://www.cnblogs.com/suiyuan129/p/19605836",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/suiyuan129/p/19605836\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 20:16\">\n    <span>类型擦除与部分异步编程</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"类型擦除与部分异步编程-消除差别统一使用\">类型擦除与部分异步编程: 消除差别，统一使用</h1>\n<p>C++ 中类型擦除最典型的实现思路分为两类——模板（编译期擦除）与多态（运行时擦除），这两种方式大家都比较熟悉。而标准库为我们封装了更易用的类型擦除工具，核心包括 <code>std::function</code>、<code>std::any</code>、<code>std::span</code> 和 <code>std::variant</code>，它们在不同场景下帮我们“消除类型差别，实现统一使用”；同时，类型擦除也是异步编程的核心基础，<code>std::function</code> 搭配相关组件可实现任意异步任务的统一调度，这也是我们将两者结合讲解的核心原因。</p>\n<h2 id=\"1-stdfunction可调用对象的统一调用接口\">1. std::function：可调用对象的“统一调用接口”</h2>\n<p><code>std::function</code> 是针对<strong>可调用对象</strong>的类型擦除工具，其底层实现核心是「抽象基类 + 模板子类」的多态模式，也是运行时类型擦除的典型应用：</p>\n<ul>\n<li>抽象基类：定义了与“函数签名”完全匹配的纯虚调用接口（比如 <code>virtual Ret call(Args...) = 0</code>），作为统一调用的基准；</li>\n<li>模板子类：存储具体的可调用对象（函数、lambda、仿函数、<code>std::bind</code> 结果等），并重写抽象基类的 <code>call</code> 方法，适配具体对象的调用逻辑。</li>\n</ul>\n<p>正因为 <code>std::function</code> 是通过调用<strong>抽象基类的统一接口</strong>，间接呼叫存入模板子类中的具体函数，所以我们<strong>必须提前明确告知 <code>std::function</code> 完整的函数签名（返回值类型、参数类型、参数个数）</strong> —— 这是抽象基类定义统一调用接口的前提，只有签名一致，所有被擦除类型的可调用对象，才能通过抽象基类的接口被正确调用。也正因运行时的多态派发（通过抽象基类指针调用子类的 <code>call</code> 方法），<code>std::function</code> 会产生一定的运行时开销。</p>\n<h3 id=\"测试代码stdfunction-统一调用不同可调用对象\">测试代码：std::function 统一调用不同可调用对象</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;string&gt;\n\n// 普通函数\nint add(int a, int b) { return a + b; }\n\n// 仿函数\nstruct Multiply {\n    int operator()(int a, int b) { return a * b; }\n};\n\nint main() {\n    // 定义函数签名：int(int, int)\n    std::function&lt;int(int, int)&gt; func;\n\n    // 存储普通函数\n    func = add;\n    std::cout &lt;&lt; \"add(3,4) = \" &lt;&lt; func(3, 4) &lt;&lt; std::endl; // 输出7\n\n    // 存储lambda表达式\n    func = [](int a, int b) { return a - b; };\n    std::cout &lt;&lt; \"sub(3,4) = \" &lt;&lt; func(3, 4) &lt;&lt; std::endl; // 输出-1\n\n    // 存储仿函数\n    func = Multiply{};\n    std::cout &lt;&lt; \"mul(3,4) = \" &lt;&lt; func(3, 4) &lt;&lt; std::endl; // 输出12\n\n    return 0;\n}\n</code></pre>\n<p>代码说明：无论存储的是普通函数、lambda还是仿函数，只要函数签名匹配 <code>int(int, int)</code>，就能通过 <code>std::function</code> 统一调用，体现了类型擦除“消除差别，统一使用”的核心。</p>\n<h2 id=\"2-stdany--stdvariant数据存储的类型擦除双雄\">2. std::any &amp; std::variant：数据存储的“类型擦除双雄”</h2>\n<p>两者均用于实现数据存储的类型擦除，但定位互补，<code>std::variant</code> 核心是弥补 <code>std::any</code> 的繁琐与低效问题。</p>\n<h3 id=\"stdany无约束的全类型擦除\">std::any：无约束的全类型擦除</h3>\n<p><code>std::any</code> 是经典的“全类型擦除”工具，它完全擦除编译期的类型信息，仅保留“数据本身 + 运行时类型ID（<code>std::type_info</code>）”，相当于一个“带类型标签的万能盒子”，能存储任意类型的数据。<br />\n和 <code>std::function</code> 类似，<code>std::any</code> 需在运行时通过类型ID识别内部数据类型，因此存在运行时开销；此外，<code>std::any</code> 对大类型会进行堆内存分配，进一步增加轻微的内存开销。其最大的特点是自由无约束，但这份自由也带来了操作繁琐的问题——使用时必须手动通过 <code>typeid</code> 检查类型，再用 <code>any_cast</code> 提取数据，且类型错误只能在运行时暴露（抛出 <code>std::bad_any_cast</code> 异常）。</p>\n<h3 id=\"stdvariant有限制的高效类型擦除\">std::variant：有限制的高效类型擦除</h3>\n<p><code>std::variant</code> 是为解决 <code>std::any</code> 的痛点而生，它通过<strong>编译期提前声明可存储的类型范围</strong>，实现了更高效、更安全的类型擦除，属于“有限类型擦除”：</p>\n<ul>\n<li>编译期兜底：写错类型（比如用 <code>std::get</code> 提取非活跃类型）会被编译器及时提醒，更早暴露问题，避免运行时异常难以调试；</li>\n<li>统一便捷处理：无需手写一堆 <code>if (typeid)</code> 判断分支，通过 <code>std::visit</code> 就能批量处理所有预定义类型，代码更简洁、不易漏分支；</li>\n<li>零堆开销：<code>std::variant</code> 的大小在编译期确定（等于所有预定义类型中最大类型的尺寸 + 类型标签尺寸），所有数据均存储在栈上，无堆分配开销；</li>\n<li>安全提取：提供 <code>std::holds_alternative</code>（判断是否为指定类型）、<code>std::get_if</code>（安全提取，不匹配返回 <code>nullptr</code>）等工具，无需捕获异常，类型检查和数据提取更直观、安全。</li>\n</ul>\n<p>简单来说，<code>std::any</code> 是“无拘无束但全靠手动”，<code>std::variant</code> 是“有限制但编译器帮你兜底”，这份限制恰恰是它简化操作、提升效率的核心。</p>\n<h3 id=\"测试代码stdany-与-stdvariant-对比\">测试代码：std::any 与 std::variant 对比</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;any&gt;\n#include &lt;variant&gt;\n#include &lt;string&gt;\n#include &lt;typeinfo&gt;\n\n// 处理std::any\nvoid process_any(std::any val) {\n    if (val.type() == typeid(int)) {\n        std::cout &lt;&lt; \"any存储int：\" &lt;&lt; std::any_cast&lt;int&gt;(val) &lt;&lt; std::endl;\n    } else if (val.type() == typeid(std::string)) {\n        std::cout &lt;&lt; \"any存储string：\" &lt;&lt; std::any_cast&lt;std::string&gt;(val) &lt;&lt; std::endl;\n    } else if (val.type() == typeid(double)) {\n        std::cout &lt;&lt; \"any存储double：\" &lt;&lt; std::any_cast&lt;double&gt;(val) &lt;&lt; std::endl;\n    }\n}\n\n// 处理std::variant\nusing MyVariant = std::variant&lt;int, std::string, double&gt;;\nvoid process_variant(const MyVariant&amp; val) {\n    // 无需手写if(typeid)，std::visit批量处理\n    std::visit([](const auto&amp; v) {\n        using T = std::decay_t&lt;decltype(v)&gt;;\n        if constexpr (std::is_same_v&lt;T, int&gt;) {\n            std::cout &lt;&lt; \"variant存储int：\" &lt;&lt; v &lt;&lt; std::endl;\n        } else if constexpr (std::is_same_v&lt;T, std::string&gt;) {\n            std::cout &lt;&lt; \"variant存储string：\" &lt;&lt; v &lt;&lt; std::endl;\n        } else if constexpr (std::is_same_v&lt;T, double&gt;) {\n            std::cout &lt;&lt; \"variant存储double：\" &lt;&lt; v &lt;&lt; std::endl;\n        }\n    }, val);\n}\n\nint main() {\n    // std::any测试\n    std::any a = 10;\n    process_any(a); // 输出any存储int：10\n    a = std::string(\"hello any\");\n    process_any(a); // 输出any存储string：hello any\n    a = 3.14;\n    process_any(a); // 输出any存储double：3.14\n\n    // std::variant测试\n    MyVariant v = 20;\n    process_variant(v); // 输出variant存储int：20\n    v = std::string(\"hello variant\");\n    process_variant(v); // 输出variant存储string：hello variant\n    v = 6.28;\n    process_variant(v); // 输出variant存储double：6.28\n\n    // std::variant安全提取示例\n    if (std::holds_alternative&lt;double&gt;(v)) {\n        auto p = std::get_if&lt;double&gt;(&amp;v);\n        std::cout &lt;&lt; \"安全提取double：\" &lt;&lt; *p &lt;&lt; std::endl; // 输出6.28\n    }\n\n    return 0;\n}\n</code></pre>\n<p>代码说明：</p>\n<ul>\n<li><code>std::any</code> 需手动写 <code>if (typeid)</code> 分支，新增类型时需手动扩展；</li>\n<li><code>std::variant</code> 借助 <code>std::visit</code> 批量处理所有预定义类型，代码更简洁，且 <code>holds_alternative</code>/<code>get_if</code> 让类型检查/提取更安全。</li>\n</ul>\n<h2 id=\"3-stdspan连续容器的零开销类型擦除\">3. std::span：连续容器的“零开销类型擦除”</h2>\n<p><code>std::span</code> 是针对<strong>连续内存容器</strong>的“特制类型擦除工具”，专门用于消除不同连续容器的类型差异，实现统一访问：<br />\n它会擦除 <code>std::vector</code>、<code>std::array</code>、C风格数组等连续容器的具体类型，仅保留“起始指针 + 元素长度”两个核心特征，相当于给所有连续内存容器提供了一个统一的“视图”。<br />\n<code>std::span</code> 的核心优势是<strong>零运行时开销</strong>——类型擦除在编译期完成，无需运行时额外计算或内存分配；但也有明确限制：仅支持连续内存容器，无法处理 <code>std::list</code> 等非连续内存容器。</p>\n<h3 id=\"测试代码stdspan-统一访问不同连续容器\">测试代码：std::span 统一访问不同连续容器</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;span&gt;\n#include &lt;vector&gt;\n#include &lt;array&gt;\n\n// 统一处理所有连续int容器\nvoid print_span(std::span&lt;int&gt; sp) {\n    std::cout &lt;&lt; \"容器长度：\" &lt;&lt; sp.size() &lt;&lt; \"，内容：\";\n    for (int val : sp) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n\nint main() {\n    // std::vector\n    std::vector&lt;int&gt; vec = {1, 2, 3};\n    print_span(vec); // 输出容器长度：3，内容：1 2 3\n\n    // std::array\n    std::array&lt;int, 4&gt; arr = {4, 5, 6, 7};\n    print_span(arr); // 输出容器长度：4，内容：4 5 6 7\n\n    // C风格数组\n    int c_arr[] = {8, 9, 10};\n    print_span(c_arr); // 输出容器长度：3，内容：8 9 10\n\n    // 切片访问（span的额外优势）\n    print_span(std::span(vec).subspan(1, 2)); // 输出容器长度：2，内容：2 3\n\n    return 0;\n}\n</code></pre>\n<p>代码说明：<code>print_span</code> 函数无需关心传入的是 <code>vector</code>、<code>array</code> 还是C数组，<code>std::span</code> 擦除了容器类型差异，实现统一访问，且无任何运行时开销。</p>\n<h2 id=\"4-类型擦除在异步编程中的核心应用\">4. 类型擦除在异步编程中的核心应用</h2>\n<p>为什么要将类型擦除与异步编程结合？因为 <code>std::function</code> 的类型擦除能力，是异步任务“统一管理”的核心，它常搭配 lambda 表达式、<code>std::packaged_task</code>、<code>std::bind</code> 实现任意异步任务的统一调度，核心逻辑是“擦除任务差异，统一管理，按需获取结果”：</p>\n<ol>\n<li>用 <code>std::bind</code> 将任务参数与可调用对象绑定，擦除不同任务的参数类型差异，让有参任务适配统一的调用形式；</li>\n<li>将绑定后的任务装入 <code>std::packaged_task</code>，通过 <code>std::packaged_task</code> 内置的 <code>std::promise</code>，获取 <code>std::future</code> 对象（用于后续接收异步任务的返回值）—— 此时任务的返回值类型未被擦除；</li>\n<li>通过 lambda 表达式封装 <code>std::packaged_task</code> 的执行逻辑，将“有返回值的任务”包装成无返回值的 <code>void()</code> 类型，从而擦除返回值差异；</li>\n<li>最终，所有异步任务均可统一装进 <code>std::function&lt;void()&gt;</code> 中进行管理，任务的返回值则在异步执行完成后，自动存入 <code>std::packaged_task</code> 内部的 <code>std::promise</code>，我们通过之前获取的 <code>std::future</code> 就能按需获取异步结果，实现“任务统一管理 + 结果按需获取”。</li>\n</ol>\n<h3 id=\"测试代码类型擦除实现异步任务统一管理\">测试代码：类型擦除实现异步任务统一管理</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;future&gt;\n#include &lt;thread&gt;\n#include &lt;queue&gt;\n#include &lt;mutex&gt;\n#include &lt;condition_variable&gt;\n#include &lt;string&gt;\n\n// 全局任务队列：存储统一的无返回值任务\nstd::queue&lt;std::function&lt;void()&gt;&gt; task_queue;\nstd::mutex mtx;\nstd::condition_variable cv;\nbool stop = false;\n\n// 工作线程：消费任务队列\nvoid worker() {\n    while (!stop) {\n        std::function&lt;void()&gt; task;\n        // 加锁取任务\n        {\n            std::unique_lock&lt;std::mutex&gt; lock(mtx);\n            cv.wait(lock, []() { return stop || !task_queue.empty(); });\n            if (stop &amp;&amp; task_queue.empty()) return;\n            task = std::move(task_queue.front());\n            task_queue.pop();\n        }\n        // 执行任务\n        task();\n    }\n}\n\n// 提交任务模板：擦除参数/返回值差异，统一存入队列\ntemplate&lt;typename F, typename... Args&gt;\nauto submit_task(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;decltype(f(args...))&gt; {\n    // 绑定参数，擦除参数差异\n    auto bound_task = std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);\n    // 定义packaged_task，保留返回值类型\n    using RetType = decltype(f(args...));\n    std::packaged_task&lt;RetType()&gt; pt(std::move(bound_task));\n    // 获取future用于接收结果\n    std::future&lt;RetType&gt; fut = pt.get_future();\n    // 封装成void()任务，擦除返回值差异\n    std::function&lt;void()&gt; wrapper = [pt = std::move(pt)]() mutable {\n        pt(); // 执行packaged_task，结果存入promise\n    };\n    // 存入任务队列\n    {\n        std::lock_guard&lt;std::mutex&gt; lock(mtx);\n        task_queue.push(std::move(wrapper));\n    }\n    cv.notify_one(); // 唤醒工作线程\n    return fut;\n}\n\n// 测试任务1：有参有返回值（计算平方）\nint square(int x) {\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    return x * x;\n}\n\n// 测试任务2：有参有返回值（拼接字符串）\nstd::string concat(const std::string&amp; a, const std::string&amp; b) {\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    return a + b;\n}\n\nint main() {\n    // 启动工作线程\n    std::thread t(worker);\n\n    // 提交任务1：计算5的平方\n    auto fut1 = submit_task(square, 5);\n    // 提交任务2：拼接字符串\n    auto fut2 = submit_task(concat, \"hello \", \"async\");\n\n    // 主线程等待结果\n    std::cout &lt;&lt; \"等待异步任务结果...\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"5的平方：\" &lt;&lt; fut1.get() &lt;&lt; std::endl; // 输出25\n    std::cout &lt;&lt; \"字符串拼接：\" &lt;&lt; fut2.get() &lt;&lt; std::endl; // 输出hello async\n\n    // 停止工作线程\n    stop = true;\n    cv.notify_one();\n    t.join();\n\n    return 0;\n}\n</code></pre>\n<p>代码说明：</p>\n<ul>\n<li><code>square</code> 和 <code>concat</code> 是不同签名的任务（参数/返回值均不同）；</li>\n<li>通过 <code>std::bind</code> 擦除参数差异，<code>std::packaged_task</code> 保留返回值并绑定 <code>future</code>，lambda 封装成 <code>void()</code> 擦除返回值差异；</li>\n<li>最终所有任务都能存入 <code>std::function&lt;void()&gt;</code> 队列，实现统一管理，体现了类型擦除在异步编程中的核心价值。</li>\n</ul>\n<h2 id=\"整体总结\">整体总结</h2>\n<p>标准库中的四种类型擦除工具，虽定位不同，但核心目标一致——<strong>消除类型差别，实现统一使用</strong>：</p>\n<ol>\n<li><code>std::function</code>：针对可调用对象，统一调用接口，依赖函数签名和多态实现，有运行时开销；</li>\n<li><code>std::any</code>：针对任意数据，全类型擦除，自由但繁琐、有运行时和堆内存开销；</li>\n<li><code>std::variant</code>：针对有限范围数据，弥补 <code>std::any</code> 不足，编译期兜底、高效便捷、零堆开销；</li>\n<li><code>std::span</code>：针对连续容器，零开销类型擦除，统一连续内存访问接口，仅支持连续容器。</li>\n</ol>\n<p>而类型擦除与异步编程的结合，核心是借助 <code>std::function</code> 的统一管理能力，搭配 lambda、<code>std::packaged_task</code>、<code>std::bind</code> 等组件，擦除不同异步任务的参数和返回值差异，实现任意异步任务的统一调度，这也是类型擦除在实际开发中最常用的场景之一。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 20:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/suiyuan129\">suiyuan129</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "打通OpenClaw与Telegram的超详细实操教程",
      "link": "https://www.cnblogs.com/weipo0105/p/19605771",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/weipo0105/p/19605771\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 19:52\">\n    <span>打通OpenClaw与Telegram的超详细实操教程</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"打通OpenClaw与Telegram的超详细实操教程\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1205021/202602/1205021-20260211195252126-719148591.png\" />\n        本文详细讲解如何在OpenClaw中接入Telegram：从BotFather获取Token，发送消息获取配对码，再到通过`openclaw config`完成配置与配对，最后测试成功。轻松实现Telegram与AI助手的无缝对接，延续飞书、Discord系列教程，一文学会。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>前面我写了两篇文章，详细讲解了如何安装 <code>openclaw</code> 并接入<strong>飞书</strong>和<strong>Discord</strong>：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/JGd4u8g-Fti4sRcJcSiOLQ\" rel=\"noopener nofollow\" target=\"_blank\">【保姆级教程】手把手教你安装OpenClaw并接入飞书，让AI在聊天软件里帮你干活</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/D-7QGk5ZNbxIWO6haimaWg\" rel=\"noopener nofollow\" target=\"_blank\">超详细教程：打通OpenClaw与Discord，用MiniMax 2.1打造你的超级AI助手</a></li>\n</ul>\n<p>关于 <code>openclaw</code> 的安装，上一篇已经讲得非常详细，还没装好的朋友可以翻看之前的文章。</p>\n<p>今天，我们继续推进，为大家带来<strong>在 <code>openclaw</code> 中接入 Telegram</strong> 的完整教程，图文并茂，一步步带你打通。</p>\n<hr />\n<h2 id=\"一获取-token-与配对码\">一、获取 Token 与配对码</h2>\n<ol>\n<li>\n<p><strong>创建 Bot 并获取 Token</strong><br />\n在 Telegram 中搜索 <code>@BotFather</code>，进入聊天界面。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>输入 <code>/newbot</code>，按提示设置机器人名称和用户名，完成后会收到一个 <strong>API Token</strong>，<strong>请务必保存好</strong>，后面配置时需要用到。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p><strong>获取配对码</strong><br />\n搜索你刚创建的 Bot 用户名，进入聊天界面，点击 <strong>Start</strong>。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>随便发送一条消息，Bot 会自动回复一个<strong>配对码（Pairing Code）</strong>，请复制保存，后面配对环节会用到。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n</li>\n</ol>\n<hr />\n<h2 id=\"二配置-openclaw\">二、配置 openclaw</h2>\n<ol>\n<li>\n<p>打开终端，输入以下命令开始配置：</p>\n<pre><code class=\"language-bash\">openclaw config\n</code></pre>\n<p>选择 <code>local</code>。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>进入 <code>channels</code> 配置项。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>选择 <strong>配置连接</strong>。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>在平台列表中选择 <strong>电报（Telegram）</strong>。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>粘贴刚刚保存的 Bot Token。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>确认无误后点击 <strong>完成</strong>。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p><strong>进入配对模式</strong><br />\n系统会询问安全策略，选择 <code>yes</code>，默认使用配对模式。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>选择 <strong>配对（Pairing）</strong>。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>点击 <strong>继续</strong>。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p><strong>完成配对</strong><br />\n在终端执行以下命令，将 <code>openclaw</code> 与你的 Bot 绑定：</p>\n<pre><code class=\"language-bash\">openclaw pairing approve telegram 你的配对码\n</code></pre>\n<p>看到成功提示即表示配对完成。<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n</li>\n</ol>\n<hr />\n<h2 id=\"三测试效果\">三、测试效果</h2>\n<p>现在回到 Telegram 中，向你的 Bot 发送任意消息。如果一切顺利，你会收到来自 <code>openclaw</code> 的回复，说明 Telegram 接入已成功生效！</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<hr />\n<h2 id=\"写在最后\">写在最后</h2>\n<p>至此，你已经完成了 <code>openclaw</code> 与 Telegram 的对接。加上之前的飞书和 Discord，现在你可以在这三个主流聊天平台上自由调用 AI 助手来帮你处理任务了。</p>\n<p>这套流程虽然步骤稍多，但胜在清晰可控，一次配置好后就可以长期使用。如果你在操作中遇到任何问题，欢迎留言交流，我会尽力协助。</p>\n<p>下一步，我们可以尝试为 <code>openclaw</code> 接入更多渠道，或是定制专属指令，让 AI 真正成为你的“数字员工”。敬请期待后续教程！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 19:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/weipo0105\">阿坡RPA</a>&nbsp;\n阅读(<span id=\"post_view_count\">23</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "简易的分布式kv设计",
      "link": "https://www.cnblogs.com/jackjavacpp/p/19605754",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jackjavacpp/p/19605754\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 19:47\">\n    <span>简易的分布式kv设计</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简易的分布式kv设计--一\">简易的分布式kv设计--(一)</h1>\n<p><strong>这篇文章目前只设计到集群启动，然后自动选主的功能。</strong></p>\n<p>地址：<a href=\"https://github.com/Jack-txf/easy-kv\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/Jack-txf/easy-kv</a></p>\n<p><strong>TIPS</strong>：此文章对应的分支版本是<strong>version0211</strong></p>\n<p>raft基础知识：<a href=\"https://mp.weixin.qq.com/s/DHO2CK87kI-clf4O96t5Cw\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/DHO2CK87kI-clf4O96t5Cw</a></p>\n<h1 id=\"1-前言\">1. 前言</h1>\n<p>在 Raft KV 系统中，每个节点（Node）都是对等的。一个典型的请求流向是： <code>Client</code> -&gt; <code>Leader Node</code> -&gt; <code>Raft 日志同步</code> -&gt; <code>大多数节点确认</code> -&gt; <code>应用到状态机 (KV Store)</code> -&gt; <code>返回 Client</code>。</p>\n<h1 id=\"2-设计步骤\">2. 设计步骤</h1>\n<p>Raft 核心组件包括：一致性结点模块，RPC 通信，日志模块。</p>\n<h2 id=\"21-日志\">2.1 日志</h2>\n<pre><code class=\"language-txt\">写日志 → 复制日志 → commit → apply 【leader应用顺序】\n\n细分一下的话就如下：\nClient\n   ↓\nLeader\n   ↓ append log (本地)\n   ↓\n发送 AppendEntries\n   ↓\nFollowers append log\n   ↓\n多数成功\n   ↓\nLeader commit\n   ↓\nLeader apply\n   ↓\n返回客户端成功\n   ↓\nLeader 下次心跳带 commitIndex\n   ↓\nFollowers apply\n</code></pre>\n<p>首先看一下，客户端发送一个请求，涉及到的大致东西有哪些：</p>\n<img src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194613207-412932482.png\" />\n<p>从后往前看，我们需要设计的就是如何写入日志文件，以及日志文件的格式该如何设计呢？此处我们就弄简单一点儿就好了</p>\n<table>\n<thead>\n<tr>\n<th>totalLength （int）</th>\n<th>term（long）</th>\n<th>index（long）</th>\n<th>commandLength（int）</th>\n<th>command（byte[]）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>整条log entry 长度</td>\n<td>Raft term</td>\n<td>日志 index</td>\n<td>命令长度</td>\n<td>真正命令，这个肯定是变长的</td>\n</tr>\n</tbody>\n</table>\n<p>totalLength = 8 (term) + 8 (index) + 4 (commandLength) + commandLength</p>\n<pre><code class=\"language-java\">public class LogEntry {\n    private final long term;\n    private final long index;\n    private final String command;\n    ....\n}\n</code></pre>\n<p>日志存储与管理</p>\n<pre><code class=\"language-java\">/**\n * @Description: 日志存储与管理\n * @Author: txf\n * @Date: 2026/2/9\n */\npublic class LogManager {\n    // 日志文件路径\n    private static final String LOG_FILE_PATH = \"easy_kv_log.dat\";\n    // 内存映射的分段大小（128MB，可根据内存调整）,这里先调整为两兆\n    private static final int MAPPED_SIZE = 2 * 1024 * 1024;\n    // 文件打开模式：rw = 读写\n    private static final String FILE_MODE = \"rw\";\n\n    private final File logFile;\n    private RandomAccessFile raf;\n    private FileChannel fileChannel;\n    // 当前映射的内存缓冲区\n    private MappedByteBuffer currentMappedBuffer;\n    // 当前映射段的起始偏移（文件偏移）\n    private long currentMappedOffset = 0;\n    // 当前写入的位置（相对于文件的总偏移）\n    private long writePosition = 0;\n\n    public LogManager() {\n        this.logFile = new File(LOG_FILE_PATH);\n        initFileChannel();\n        initMappedBuffer();\n        // 初始化时定位到文件末尾（继续追加写）\n        try {\n            this.writePosition = fileChannel.size();\n        } catch (IOException e) {\n            throw new RuntimeException(\"获取文件大小失败\", e);\n        }\n    }\n\n    /**\n     * 追加写入单条日志（核心高性能写入）\n     * @param term Raft任期\n     * @param index 日志索引\n     * @param command KV操作命令（如\"PUT key value\"）\n     */\n    public void appendLogEntry(long term, long index, String command) {\n        // 1. 准备命令字节数组\n        byte[] commandBytes = command.getBytes(StandardCharsets.UTF_8);\n        int commandLength = commandBytes.length;\n        // 2. 计算总长度\n        int totalLength = 4 + 8 + 8 + 4 + commandLength;\n\n        // 3. 准备直接缓冲区（堆外内存，避免拷贝）\n        ByteBuffer directBuffer = ByteBuffer.allocateDirect(totalLength);\n        // 按格式写入缓冲区 -- 这里是写入二进制的，文件内容我们人类就读不懂了\n        directBuffer.putInt(totalLength);\n        directBuffer.putLong(term);\n        directBuffer.putLong(index);\n        directBuffer.putInt(commandLength);\n        directBuffer.put(commandBytes);\n\n        // 这里是写入字符串的\n        // directBuffer.put((term + index + command).getBytes(StandardCharsets.UTF_8));\n\n        // 翻转缓冲区（从写模式转为读模式）\n        directBuffer.flip();\n        // 4. 写入到内存映射缓冲区（核心：零拷贝）\n        writeToMappedBuffer(directBuffer);        // 5. 更新全局写入位置\n        writePosition += totalLength;\n    }\n\n    /**\n     * 将缓冲区数据写入内存映射区（自动扩容映射段）\n     */\n    private void writeToMappedBuffer(ByteBuffer buffer) {\n        while (buffer.hasRemaining()) {\n            // 检查当前映射缓冲区是否有足够剩余空间\n            if (currentMappedBuffer.remaining() &lt; buffer.remaining()) {\n                // 先写入当前映射区的剩余空间\n                int remaining = currentMappedBuffer.remaining();\n                byte[] temp = new byte[remaining];\n                buffer.get(temp);\n                currentMappedBuffer.put(temp);\n                // 强制刷盘（将映射内存的数据同步到磁盘，可选：批量刷盘可提升性能）\n                currentMappedBuffer.force();\n                // 扩容映射段\n                initMappedBuffer();\n            } else {\n                // 直接写入映射缓冲区\n                currentMappedBuffer.put(buffer);\n            }\n        }\n    }\n\n    /**\n     * 读取指定索引的日志条目（高性能读取）\n     */\n    public LogEntry readLogEntry(long index) {\n        try {\n            // 使用FileChannel + 直接缓冲区读取\n            ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024 * 1024); // 1MB直接缓冲区\n            long fileOffset = 0;\n            long fileSize = fileChannel.size();\n\n            while (fileOffset &lt; fileSize) {\n                // 重置缓冲区\n                directBuffer.clear();\n                // 从文件指定偏移读取数据到缓冲区\n                int readBytes = fileChannel.read(directBuffer, fileOffset);\n                if (readBytes == -1) break;\n                directBuffer.flip();\n\n                // 解析缓冲区中的日志条目\n                while (directBuffer.hasRemaining()) {\n                    // 检查剩余字节是否足够读取固定头部（4+8+8+4=24字节）\n                    if (directBuffer.remaining() &lt; 24) break;\n                    // 读取固定字段\n                    int totalLength = directBuffer.getInt();\n                    long term = directBuffer.getLong();\n                    long currentIndex = directBuffer.getLong();\n                    int commandLength = directBuffer.getInt();\n                    // 检查剩余字节是否足够读取command\n                    if (directBuffer.remaining() &lt; commandLength) {\n                        // 回退缓冲区position，下次继续解析\n                        directBuffer.position(directBuffer.position() - 24);\n                        break;\n                    }\n                    // 读取command\n                    byte[] commandBytes = new byte[commandLength];\n                    directBuffer.get(commandBytes);\n                    String command = new String(commandBytes, StandardCharsets.UTF_8);\n                    // 校验总长度\n                    int actualLength = 4 + 8 + 8 + 4 + commandLength;\n                    if (totalLength != actualLength) {\n                        throw new RuntimeException(\"日志文件损坏：总长度不匹配\");\n                    }\n                    // 找到目标索引则返回\n                    if (currentIndex == index) {\n                        return new LogEntry(term, index, command);\n                    }\n                    // 更新文件偏移\n                    fileOffset += totalLength;\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"读取日志条目失败 [index=\" + index + \"]\", e);\n        }\n        return null;\n    }\n\n    /**\n     * 加载所有日志条目（节点启动时恢复）\n     */\n    public List&lt;LogEntry&gt; loadAllLogEntries() {\n        List&lt;LogEntry&gt; logEntries = new ArrayList&lt;&gt;();\n        try {\n            ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024 * 1024);\n            long fileOffset = 0;\n            long fileSize = fileChannel.size();\n\n            while (fileOffset &lt; fileSize) {\n                directBuffer.clear();\n                int readBytes = fileChannel.read(directBuffer, fileOffset);\n                if (readBytes == -1) break;\n                directBuffer.flip();\n\n                while (directBuffer.hasRemaining()) {\n                    if (directBuffer.remaining() &lt; 24) break;\n\n                    int totalLength = directBuffer.getInt();\n                    long term = directBuffer.getLong();\n                    long index = directBuffer.getLong();\n                    int commandLength = directBuffer.getInt();\n\n                    if (directBuffer.remaining() &lt; commandLength) {\n                        directBuffer.position(directBuffer.position() - 24);\n                        break;\n                    }\n\n                    byte[] commandBytes = new byte[commandLength];\n                    directBuffer.get(commandBytes);\n                    String command = new String(commandBytes, StandardCharsets.UTF_8);\n\n                    int actualLength = 4 + 8 + 8 + 4 + commandLength;\n                    if (totalLength != actualLength) {\n                        throw new RuntimeException(\"日志文件损坏：总长度不匹配\");\n                    }\n\n                    logEntries.add(new LogEntry(term, index, command));\n                    fileOffset += totalLength;\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"加载所有日志条目失败\", e);\n        }\n        return logEntries;\n    }\n\n    /**\n     * 强制刷盘（将映射内存的数据同步到磁盘）\n     */\n    public void forceFlush() {\n        if (currentMappedBuffer != null) {\n            currentMappedBuffer.force(); // 同步映射内存到磁盘\n        }\n        try {\n            fileChannel.force(true); // 强制刷盘（包含元数据）\n        } catch (IOException e) {\n            throw new RuntimeException(\"刷盘失败\", e);\n        }\n    }\n\n    /**\n     * 关闭资源（必须调用，否则会导致文件句柄泄漏）\n     */\n    public void close() {\n        try {\n            forceFlush();\n            if (fileChannel != null) {\n                fileChannel.close();\n            }\n            if (raf != null) {\n                raf.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"关闭资源失败\", e);\n        }\n    }\n    /**\n     * 初始化/扩容内存映射缓冲区\n     */\n    private void initMappedBuffer() {\n        try {\n            // 计算需要映射的起始位置和大小\n            long fileSize = fileChannel.size();\n            // 如果当前映射段已写满，或首次初始化，创建新的映射\n            if (currentMappedBuffer == null || writePosition &gt;= currentMappedOffset + MAPPED_SIZE) {\n                currentMappedOffset = (writePosition / MAPPED_SIZE) * MAPPED_SIZE;\n                // 映射文件的指定区间到内存（FileChannel.MapMode.READ_WRITE：读写模式）\n                currentMappedBuffer = fileChannel.map(\n                        FileChannel.MapMode.READ_WRITE,\n                        currentMappedOffset,\n                        MAPPED_SIZE\n                );\n                // 将缓冲区的position定位到当前写入位置相对于映射段的偏移\n                currentMappedBuffer.position((int) (writePosition - currentMappedOffset));\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"初始化内存映射缓冲区失败\", e);\n        }\n    }\n\n    /**\n     * 初始化FileChannel（核心高性能通道）\n     */\n    private void initFileChannel() {\n        try {\n            // 不存在则创建文件\n            if (!logFile.exists()) {\n                boolean newFile = logFile.createNewFile();\n                if (!newFile) {\n                    throw new RuntimeException(\"创建文件失败\");\n                }\n            }\n            this.raf = new RandomAccessFile(logFile, FILE_MODE);\n            this.fileChannel = raf.getChannel();\n        } catch (IOException e) {\n            throw new RuntimeException(\"初始化FileChannel失败\", e);\n        }\n    }\n}\n</code></pre>\n<h2 id=\"22-服务端设计\">2.2 服务端设计</h2>\n<h3 id=\"221-消息设计\">2.2.1 消息设计</h3>\n<p>日志设计好了之后，接下来看服务端如何设计。我们使用的是netty框架，要求有netty基础。然后序列化协议采用的是protobuf，读者可以参考这篇文章：<a href=\"https://mp.weixin.qq.com/s/kg_-AMHRn_DzFbfBnkK4VQ\" rel=\"noopener nofollow\" target=\"_blank\">https://mp.weixin.qq.com/s/kg_-AMHRn_DzFbfBnkK4VQ</a> 这篇文章大致讲解了一下该序列化协议，并且也是采用netty整合的。根据proto文件生成类的命令如下，也可以用idea的插件自动生成。</p>\n<pre><code class=\"language-proto\">protoc  --proto_path=xxxx目录  --java_out=xxx目录  具体的proto文件\n</code></pre>\n<p>消息模板如下：</p>\n<pre><code class=\"language-proto\">syntax = \"proto3\";\noption java_outer_classname = \"KvRaftProto\"; // 生成的外层类名\noption java_multiple_files = false; // 生成多个独立的Java类（而非内部类）\n\n// ===================== 1. 通用消息封装体（核心） =====================\n// Netty传输时只传这个消息，通过type识别具体消息类型\nmessage RaftKvMessage {\n  // 消息类型枚举（覆盖所有交互场景）\n  enum MessageType {\n    UNKNOWN = 0; // 未知类型（兜底）\n    // 客户端 ↔ 节点：KV操作\n    KV_REQUEST = 1;    // 客户端发起KV请求（PUT/GET/DELETE）\n    KV_RESPONSE = 2;   // 节点响应客户端KV请求\n    // 节点 ↔ 节点：Raft共识\n    VOTE_REQUEST = 3;  // 选举请求（Candidate→Follower）\n    VOTE_RESPONSE = 4; // 选举响应（Follower→Candidate）\n    APPEND_ENTRIES_REQUEST = 5;  // 日志追加/心跳（Leader→Follower）\n    APPEND_ENTRIES_RESPONSE = 6; // 日志追加响应（Follower→Leader）\n  }\n\n  MessageType type = 1; // 消息类型（必传）\n  string node_id = 2;   // 发送方节点ID（用于识别节点）\n\n  // 具体消息体（根据type选择其中一个）\n  KvRequest kv_request = 3;\n  KvResponse kv_response = 4;\n  VoteRequest vote_request = 5;\n  VoteResponse vote_response = 6;\n  AppendEntriesRequest append_entries_request = 7;\n  AppendEntriesResponse append_entries_response = 8;\n}\n\n// ===================== 2. 客户端KV操作相关 =====================\n// 客户端发起的KV请求（PUT/GET/DELETE）\nmessage KvRequest {\n  enum OpType {\n    PUT = 0;    // 写入/更新\n    GET = 1;    // 读取\n    DELETE = 2; // 删除\n  }\n  OpType op_type = 1; // 操作类型（必传）\n  string key = 2;     // KV的key（必传）\n  string value = 3;   // KV的value（仅PUT时传）\n  // 可选：请求ID，用于幂等性（防止重复请求）\n  string request_id = 4;\n}\n\n// 节点响应客户端的KV结果\nmessage KvResponse {\n  bool success = 1;    // 操作是否成功\n  string message = 2;  // 错误信息/提示（失败时必传）\n  string value = 3;    // 返回的value（仅GET成功时传）\n  string request_id = 4; // 对应请求的ID（幂等性）\n}\n\n// ===================== 3. Raft选举相关 =====================\n// Candidate向Follower发起的投票请求\nmessage VoteRequest {\n  int64 term = 1;                // Candidate的当前任期（必传）\n  string candidate_id = 2;       // Candidate的节点ID（必传）\n  int64 last_log_index = 3;      // Candidate最后一条日志的索引（用于日志一致性检查）\n  int64 last_log_term = 4;       // Candidate最后一条日志的任期（用于日志一致性检查）\n}\n\n// Follower响应Candidate的投票结果\nmessage VoteResponse {\n  int64 term = 1;                // Follower的当前任期（必传，用于更新Candidate的任期）\n  bool vote_granted = 2;         // 是否投赞成票（必传）\n}\n\n// ===================== 4. Raft日志追加/心跳相关 =====================\n// 日志条目（与你设计的日志格式对齐，序列化后可直接写入日志文件）\nmessage LogEntry {\n  int64 term = 1;        // Raft任期（对应你日志格式的term）\n  int64 index = 2;       // 日志索引（对应你日志格式的index）\n  string command = 3;    // KV操作命令（如\"PUT key1 value1\"，对应你日志格式的command）\n}\n\n// Leader向Follower发送的日志追加/心跳请求\nmessage AppendEntriesRequest {\n  int64 term = 1;                // Leader的当前任期（必传）\n  string leader_id = 2;          // Leader的节点ID（必传）\n  int64 prev_log_index = 3;      // 前一条日志的索引（用于日志一致性检查）\n  int64 prev_log_term = 4;       // 前一条日志的任期（用于日志一致性检查）\n  repeated LogEntry entries = 5; // 待追加的日志条目（心跳时为空）\n  int64 leader_commit = 6;       // Leader已提交的日志索引（Follower据此更新自己的提交索引）\n}\n\n// Follower响应Leader的日志追加结果\nmessage AppendEntriesResponse {\n  int64 term = 1;                // Follower的当前任期（必传，用于更新Leader的任期）\n  bool success = 2;              // 日志追加是否成功（必传）\n  int64 match_index = 3;         // Follower已匹配的日志索引（Leader据此更新nextIndex）\n}\n</code></pre>\n<p>上面是消息的大致格式。</p>\n<p>接下来看服务端的节点设计，我们从netty服务启动开始往下看：</p>\n<p>在kv-core的app包里面</p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n    int port = getPort(args);\n    RaftNettyServer raftNettyServer = new RaftNettyServer(port);\n    try {\n        raftNettyServer.start();\n    } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n    }\n}\n\nprivate static int getPort(String[] args) {\n    for (String arg : args) {\n        if (arg.startsWith(\"node.port=\")) {\n            return Integer.parseInt(arg.substring(10));\n        }\n    }\n    return 7777;\n}\n</code></pre>\n<p>从java程序启动的命令行读取结点的端口参数，我们可以用一台电脑开启多个应用，在idea中这样配置就可以了：如下图所示</p>\n<img src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194613557-847947640.png\" />\n<p>从上图中可以看到，配置了三个节点，然后本项目的jdk是采用的21这个版本。配置好了之后，在idea的services里面可以把这些配置一起加进去，然后就可以同时启动多个节点了。</p>\n<h3 id=\"222-连接设计\">2.2.2 连接设计</h3>\n<pre><code class=\"language-java\">RaftNettyServer raftNettyServer = new RaftNettyServer(port);\n...\nraftNettyServer.start();\n</code></pre>\n<p>从上一节的启动类看出来主要就是new了一个server对象，然后调用start方法。我们顺着这两个看就可以了。</p>\n<p>首先是构造方法：</p>\n<pre><code class=\"language-java\">public class RaftNettyServer {\n  \t....\n    private final int port;\n    private final RaftNode node;\n\n    public RaftNettyServer(int port) {\n        this.port = port;\n         // 这里创建了一个raft结点对象\n        this.node = new RaftNode(port);\n    }\n}\n\n// 这个是RaftNode类，\npublic RaftNode(int port) {\n    this.port = port;\n\n    // 从配置文件中找到自己\n    this.nodesConfig = new NodesConfig();\n    this.nodeId = nodesConfig.findSelf(port);\n\n    // 需要把自身结点\n    this.rpcPeers = nodesConfig.getNodeList().stream()\n        // node的格式是'ip:port'\n        .map(node -&gt; new RpcPeer(node, node.split(\":\")[0],\n                                 Integer.parseInt(node.split(\":\")[1]), this))\n        .toList();\n\n    this.logManager = new LogManager();\n    this.storage = new MemoryStorage();\n\n    // 把两个时间先初始化咯\n    this.electionTimeout = 8000 + ThreadLocalRandom.current().nextInt(4000);\n    this.lastHeartbeatTime = System.currentTimeMillis();\n    log.info(\"初始化选举超时：{}\", electionTimeout);\n\n    // 定时器\n    scheduler = Executors.newScheduledThreadPool(2);\n    scheduler.scheduleAtFixedRate(this::tick, 2, 2000, TimeUnit.MILLISECONDS);\n}\n</code></pre>\n<p>Raft类是最核心的一个类。上面的构造方法其实很简单。读者自行理解。需要说明一下的就是nodeId的格式：【ip:端口】</p>\n<pre><code class=\"language-java\">127.0.0.1:8888 // 就是这种字符串的格式\n</code></pre>\n<p>还有要说明的就是rpcPeers这个List的构建，可以看出来先是从配置文件读取到了集群节点列表，然后遍历这个列表创建了对象，这个具体是什么意思呢？</p>\n<p>首先看一下Netty的客户端发送请求到服务端，服务端处理后在返回给客户端，客户端根据响应结果进行逻辑处理。这样一个示意图：</p>\n<img src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194613912-363189595.png\" />\n<p>再看一下下面的连接示意图：</p>\n<img src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194614275-746707923.png\" />\n<p>NettyClient不仅仅是给客户用的，集群结点内部互相通信也要用到这个，rpcPeers就是集群节点内部通信使用的。如上图所示，每个节点都有一个NettyServer启动并监听着端口，同时Leader结点需要给所有的Follower结点发送心跳请求，此时这个Leader相当于其他两个Follower结点就相当于Client了，所以在结点一里面有client的部分，在项目归到了rpc的包下，也就是上面那个rpcPeers的由来了。</p>\n<p>在集群启动的时候，都是Follower结点，只有等到超时了才会开始选主，在此之前，每个节点都有成为Candidate的可能，也就是说每个节点都有向其他结点发送投票请求的可能（VoteRequest），那么每个节点里面都要有一套Netty Client及处理流程。就如下图所示：</p>\n<img src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194614720-1938302844.png\" />\n<p>这样就有一个问题了，三个节点，我就要六个tcp连接了，四个节点就要12个连接，十个节点呢，就要90个连接，这也太多了吧，那也确实是的。有一个思路是搞一个中间层叫做routeCenter，所有结点连向它，然后消息都经过这个路由中心来转发，这样连接数就会少很多了。</p>\n<p>还有一个思路，反正NettyClient + 一个NettyServer构建出一个Channel，理论上我只需要三个tcp连接就可以了啊。如下图所示：</p>\n<img src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194615069-208910434.png\" />\n<p>但是这样的话，节点间通信需要转发了，代码逻辑就太复杂了，况且还有一个问题，那就是如何确定这个tcp的连接顺序呢？这个可以按照nodeId的字典顺序来嘛。反正就是麻烦就完事儿了。。。</p>\n<p>综上所述，还是最开始的方案最简单直接了，反正这就是一个简易的案例，不要考虑太多了。如果有一些其他合适的思路，欢迎读者给出。</p>\n<p>节点之间的连接设计就是上面的样子了。</p>\n<p>接下来看RaftNode的设计。</p>\n<h3 id=\"223-raftnode设计\">2.2.3 RaftNode设计</h3>\n<p>那就从构造器开始看吧：</p>\n<pre><code class=\"language-java\">public RaftNode(int port) {\n    this.port = port;\n\n    // 从配置文件中找到自己\n    this.nodesConfig = new NodesConfig();\n    this.nodeId = nodesConfig.findSelf(port);\n\n    // 需要把自身结点\n    this.rpcPeers = nodesConfig.getNodeList().stream()\n        // node的格式是'ip:port'\n        .map(node -&gt; new RpcPeer(node, node.split(\":\")[0],\n                                 Integer.parseInt(node.split(\":\")[1]), this))\n        .toList();\n\n    this.logManager = new LogManager();\n    this.storage = new MemoryStorage();\n\n    // 把两个时间先初始化咯\n    this.electionTimeout = 8000 + ThreadLocalRandom.current().nextInt(4000);\n    this.lastHeartbeatTime = System.currentTimeMillis();\n    log.info(\"初始化选举超时：{}\", electionTimeout);\n\n    // 定时器\n    scheduler = Executors.newScheduledThreadPool(2);\n    scheduler.scheduleAtFixedRate(this::tick, 2, 2000, TimeUnit.MILLISECONDS);\n}\n</code></pre>\n<p>可以看到都是做一些初始化的工作，然后下面是开启了一个定时任务tick</p>\n<pre><code class=\"language-java\">private void tick() {\n    log.info(\"检查是否超时：{} 状态: {}\", nodeId, state);\n    try {\n        if (state != NodeState.LEADER &amp;&amp; isTimeout()) {\n            becomeCandidate();\n        } else if (state == NodeState.LEADER) {\n            // sendHeartbeats();\n        }\n    } catch ( Exception e ) {\n        log.error(\"{} 节点tick定时任务异常\", nodeId, e);\n    }\n}\nprivate void becomeCandidate() {\n    log.info(\"{} 选举超时，转为 Candidate，开始任期: {}\", nodeId, currentTerm.get() + 1);\n    state = NodeState.CANDIDATE;\n    currentTerm.getAndIncrement(); // 任期+1\n    votedFor = nodeId; // 给自己投一票\n    resetElectionTimeout();\n    // 集群发送投票请求\n    requestVotes();\n}\n private boolean isTimeout() {\n     return System.currentTimeMillis() - lastHeartbeatTime &gt; electionTimeout;\n }\nprivate void resetElectionTimeout() {\n    // 8000ms ~ 12000ms 随机超时，避免平票\n    this.electionTimeout = 8000 + ThreadLocalRandom.current().nextInt(4000);\n    log.info(\"重置 {} 节点选举时间，随机超时：{} ms\", nodeId, electionTimeout);\n    this.lastHeartbeatTime = System.currentTimeMillis();\n}\n</code></pre>\n<p>主要就是看becomeCandidate这个方法最后的向集群发送投票请求。</p>\n<pre><code class=\"language-java\">private void requestVotes() {\n    // 1. 初始化票数：自己的一票\n    AtomicInteger grantedVotes = new AtomicInteger(1);\n    long count = rpcPeers.stream().filter(peer -&gt; !peer.isSelf()).count(); // 不包含自己的结点数\n    int majority = (int) ((count + 1) / 2 + 1); // 总节点数(包含自己)的半数以上\n\n    // 2.构造投票消息\n    KvRaftProto.VoteRequest voteRequest = KvRaftProto.VoteRequest.newBuilder()\n        .setTerm(currentTerm.get())\n        .setCandidateId(nodeId)\n        .setLastLogIndex(logManager.getLastLogIndex())\n        .setLastLogTerm(logManager.getLastLogTerm())\n        .build();\n    // 3. 发送投票请求\n    // 构建一个对象，表示当前投票请求的状态\n    // String voteId = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n    // 这里为什么可以用term？因为 Raft 规定，一个节点在一个 term 内只能投一张票。\n    // 所以，只要 term 匹配，这个响应就一定是针对你当前发起的这一轮选举的。\n    GlobalVoteManager.setVoteState(currentTerm.get(), new VoteState(nodeId, currentTerm.get(), majority));\n\n    int countSend = 0;\n    for (RpcPeer peer : rpcPeers) {\n        if (!peer.isSelf()) { // 不是自身结点，就发送投票请求\n            // send方法就很简单了，请读者自行查看\n            boolean send = peer.send(KvRaftProto.RaftKvMessage.newBuilder()\n                                     .setType(KvRaftProto.RaftKvMessage.MessageType.VOTE_REQUEST)\n                                     .setVoteRequest(voteRequest)\n                                     .build());\n            if ( send ) countSend++;\n        }\n    }\n    log.info(\"发送投票请求：{}，已发送给了 {} 个结点..\", voteRequest, countSend);\n}\n</code></pre>\n<p>这样投票请求就发送出去了，此时结点是作为客户端发送给其他节点的，接下来的逻辑就是其他节点接收到voteRequest请求然后做逻辑处理，所以就要在server包下面去查看具体逻辑。</p>\n<pre><code class=\"language-java\">// 在kv-core的server包下面的KvBusinessHandler.java\n// 1.如果是投票请求\nif ( raftKvMessage.getType() == KvRaftProto.RaftKvMessage.MessageType.VOTE_REQUEST) {\n    log.info(\"receive vote request.........\");\n    KvRaftProto.VoteRequest voteRequest = raftKvMessage.getVoteRequest();\n    // 可以看到交给了node去处理\n    KvRaftProto.VoteResponse voteResponse = node.tackleVoteRequest(voteRequest);\n    ctx.writeAndFlush(KvRaftProto.RaftKvMessage.newBuilder()\n                      .setType(KvRaftProto.RaftKvMessage.MessageType.VOTE_RESPONSE)\n                      .setVoteResponse(voteResponse)\n                      .build());\n}\n\n// 又回到了RaftNode类了\npublic KvRaftProto.VoteResponse tackleVoteRequest(KvRaftProto.VoteRequest voteRequest) {\n    // 比较任期\n    if (voteRequest.getTerm() &lt; currentTerm.get()) {\n        log.info(\"{} 投票请求任期太小，拒绝投票\", nodeId);\n        return buildVoteResponse(false, currentTerm.get());\n    }\n    if ( votedFor != null &amp;&amp; !voteRequest.getCandidateId().equals(votedFor) ) {\n        log.info(\"{}已投给其他人，拒绝该投票请求\", nodeId);\n        return buildVoteResponse(false, currentTerm.get());\n    }\n    // 再比较日志情况\n    if ( voteRequest.getLastLogIndex() &gt;= logManager.getLastLogIndex() &amp;&amp;\n        voteRequest.getLastLogTerm() &gt;= logManager.getLastLogTerm() ) {\n        log.info(\"{} 投票请求ok，赞成投票\", nodeId);\n        currentTerm.set(voteRequest.getTerm()); // 更新自己的任期\n        votedFor = voteRequest.getCandidateId(); // 投票给该节点\n        return buildVoteResponse(true, voteRequest.getTerm());\n    }\n    log.info(\"{} 投票请求日志太旧，拒绝该投票请求\", nodeId);\n    return buildVoteResponse(false, currentTerm.get());\n}\n</code></pre>\n<p>其他节点收到了拉票请求，会返回response给candidate结点，candidate结点是作为Client发送的拉票请求，收到的响应肯定是在客户端的处理器handler，接下来的逻辑就要在rpc包下面的RpcClientHandler去查看了：</p>\n<pre><code class=\"language-java\">@Override\nprotected void channelRead0(ChannelHandlerContext ctx, KvRaftProto.RaftKvMessage msg) {\n    // 2.VOTE_RESPONSE 投票请求回来的响应【投票请求是结点作为客户端发出的，应该在客户端的handler处理响应】\n    if (msg.getType() == KvRaftProto.RaftKvMessage.MessageType.VOTE_RESPONSE) {\n        log.info(\"receive vote response.........\");\n        KvRaftProto.VoteResponse voteResponse = msg.getVoteResponse();\n        raftNode.tackleVoteResponse(voteResponse); // 又回到了RaftNode\n    }\n}\n\n// RaftNode.java\n// 投票结果处理,【投票请求是结点作为客户端发出的，要在客户端的handler处理响应】\npublic synchronized void tackleVoteResponse(KvRaftProto.VoteResponse voteResponse) {\n    long term = voteResponse.getTerm();\n    // 2. 发现更高任期，立即降级并更新\n    // 1. 任期检查：对方比我大，我立即认输\n    if (term &gt; currentTerm.get()) {\n        stepDown(term);\n        return;\n    }\n    // 2. 状态检查：如果我已经不是 Candidate 了（比如已经超时重选或收到心跳），忽略\n    if (state != NodeState.CANDIDATE) return;\n\n    // 3. 任期匹配检查：确保这是对“当前这一轮”选举的回复\n    // 如果收到的响应任期比当前小，说明是之前过期的选举回复，直接丢弃\n    if (term &lt; currentTerm.get()) {\n        return;\n    }\n\n    // 4. 从全局管理器获取当前选举的投票状态\n    VoteState voteState = GlobalVoteManager.getVoteState(term);\n    if (voteState == null) {\n        log.error(\"未找到任期 {} 的投票记录状态\", term);\n        return;\n    }\n\n    // 5. 如果对方投了赞成票\n    if (voteResponse.getVoteGranted()) {\n        // 增加票数（这里 AtomicInteger 在 VoteState 内部保证了线程安全，\n        // 但由于本方法加了 synchronized，其实双重保险）\n        int currentVotes = voteState.addVote();\n        int majority = voteState.getMajority();\n        log.info(\"赞成票，当前票数: {}/{}\", currentVotes, nodesConfig.getNodeList().size());\n\n        // 6. 检查是否达到多数派\n        if (currentVotes &gt;= majority) {\n            log.info(\"节点 {} 获得过半选票 ({})，准备晋升为 Leader\", nodeId, currentVotes);\n            becomeLeader();\n        }\n    } else {\n        log.info(\"拒绝了我的投票请求\");\n    }\n}\nprivate synchronized void becomeLeader() {\n    if (state != NodeState.CANDIDATE) return;\n    if (state == NodeState.LEADER) return;\n\n    this.state = NodeState.LEADER;\n    log.info(\"Node {} 赢得选举，即将成为 Leader, Term: {}\", nodeId, currentTerm.get());\n    // 1. 清理上一任期的残留状态\n    this.votedFor = null;\n\n    // 2. 立即发送第一波心跳，宣示主权 (防止其他节点又超时)\n    sendHeartbeats();\n\n    // 3. 启动定时心跳任务 (比如每 2 秒一次)\n    if (heartbeatTask != null) heartbeatTask.cancel(true);\n    heartbeatTask = scheduler.scheduleAtFixedRate(this::sendHeartbeats,\n                                                  0, 1000, TimeUnit.MILLISECONDS);\n    log.info(\"&lt;&lt;&lt;&lt;&lt; 节点 {} 正式成为 Term {} 的 Leader &gt;&gt;&gt;&gt;&gt;\", nodeId, currentTerm.get());\n}\n</code></pre>\n<h1 id=\"3启动测试选主\">3.启动测试选主</h1>\n<p>把配置好的三个节点启动一下看看结果</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194611564-1443963355.png\" /></p>\n<hr />\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194612379-843476723.png\" /></p>\n<hr />\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/2358057/202602/2358057-20260211194612841-1185877353.png\" /></p>\n<p>从上图可以看出，端口9999成为了Leader结点，然后向其他节点发送心跳数据了。</p>\n<p>接下来就是完善一下日志分发那些逻辑了。</p>\n<h1 id=\"end-参考\">end. 参考</h1>\n<ol>\n<li><a href=\"http://thinkinjava.cn/2019/01/12/2019/2019-01-12-lu-raft-kv/#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%89%88-Raft-%E5%88%86%E5%B8%83%E5%BC%8F-KV-%E5%AD%98%E5%82%A8\" rel=\"noopener nofollow\" target=\"_blank\">http://thinkinjava.cn/2019/01/12/2019/2019-01-12-lu-raft-kv/#什么是-Java-版-Raft-分布式-KV-存储</a></li>\n<li><a href=\"https://github.com/stateIs0/lu-raft-kv\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/stateIs0/lu-raft-kv</a></li>\n</ol>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 19:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jackjavacpp\">别来无恙✲</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "状压DP之子集枚举",
      "link": "https://www.cnblogs.com/sPERbEETLE/p/19605725",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sPERbEETLE/p/19605725\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 19:47\">\n    <span>状压DP之子集枚举</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"什么是子集枚举\">什么是子集枚举？</h1>\n<p>就是在状态压缩后，枚举该状态的子状态。</p>\n<h2 id=\"做法\">做法</h2>\n<h3 id=\"1-一个--做法直接枚举所有情况并判断两个集合--和--中-\">1. 一个 <span class=\"math inline\">\\(4^n\\)</span> 做法，直接枚举所有情况，并判断两个集合 <span class=\"math inline\">\\(S\\)</span> 和 <span class=\"math inline\">\\(T\\)</span> 中 <span class=\"math inline\">\\(T \\in S\\)</span>。</h3>\n<pre><code class=\"language-cpp\">for (int s = 0; s &lt; (1 &lt;&lt; n); s++) {\n\tfor (int t = 0; t &lt; (1 &lt;&lt; n); t++) {\n\t\tif ((s &amp; t) == t) {\n\t\t\t// t是s的子集\n\t\t}\n\t}\n}\n</code></pre>\n<h3 id=\"2---做法借助位运算降低复杂度\">2.  <span class=\"math inline\">\\(3^n\\)</span> 做法，借助位运算降低复杂度。</h3>\n<pre><code class=\"language-cpp\">for (int s = 0; s &lt; (1 &lt;&lt; n); s++) {\n\tfor (int t = s; t; t = (t - 1)&amp;s) {\n\t\t// t是s的子集\n\t}\n}\n</code></pre>\n<h4 id=\"复杂度证明\">复杂度证明</h4>\n<p>假设集合大小为 <span class=\"math inline\">\\(n\\)</span>。<br />\n对于一个特定的 <span class=\"math inline\">\\(mask\\)</span>，如果它包含 <span class=\"math inline\">\\(k\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>，那么它有 <span class=\"math inline\">\\(2^k\\)</span> 个子集。<br />\n<span class=\"math inline\">\\(mask\\)</span> 中包含 <span class=\"math inline\">\\(k\\)</span> 个 <span class=\"math inline\">\\(1\\)</span> 的情况共有 <span class=\"math inline\">\\(C_n^k\\)</span>（即组合数 $ {n \\choose k} $ ）种。</p>\n<p>因此总的操作次数为：</p>\n<p></p><div class=\"math display\">\\[\\sum_{k=0}^n {n \\choose k} 2 ^ k \n\\]</div><p></p><p>由二项式定理<span class=\"math inline\">\\((x + y) ^ n = \\sum {n \\choose k} x^k y^{n-k}\\)</span>可得：<br />\n代入 <span class=\"math inline\">\\(x = 2, y = 1\\)</span> 得 $$ \\sum_{k=0}^n {n \\choose k} 2^k 1^{n-k} = (2 + 1) ^ n = 3^n $$</p>\n<h1 id=\"简单例题cows-in-a-skyscraper-g\"><a href=\"https://www.luogu.com.cn/problem/P3052\" rel=\"noopener nofollow\" target=\"_blank\">简单例题：Cows in a Skyscraper G</a></h1>\n<h2 id=\"做法-1\">做法</h2>\n<p>两种做法。</p>\n<ol>\n<li>搜索</li>\n</ol>\n<p>用 <span class=\"math inline\">\\(sum\\)</span> 数组存下每个电梯所装的奶牛的重量。<br />\ndfs 中传入两个参数：<span class=\"math inline\">\\((r, cnt)\\)</span><br />\n分别表示：当前奶牛和电梯数量。<br />\n现在就简单了，在每一次 dfs 中，枚举每一个电梯。</p>\n<ul>\n<li>如果能装进此电梯，就装进去，并往下。</li>\n<li>枚举完了再 dfs 一次，表示增加一个电梯。</li>\n</ul>\n<p>最后记录最小值即可。</p>\n<p>有几个剪枝方案。</p>\n<ol>\n<li>如果当前的电梯数量已经大于了最小的数量，那么就不枚举了。</li>\n<li>在 dfs 前，将奶牛的重量从大到小的排序，这样就减少了可行方案。</li>\n</ol>\n<details>\n戳我看代码喵~\n<pre><code>int n, w;\nlint val[N];\nlint sum[N];\nint ans = 1e9;\nbool vis[N];\n\nvoid dfs(int r, int cnt) {\n\tif (cnt &gt; ans) return ;\n\tif (r == n) {\n\t\tans = min(ans, cnt);\n\t\treturn ;\n\t}\n\tfor (int i = 0; i &lt; cnt; i++) if (sum[i] + val[r] &lt;= w) {\n\t\tsum[i] += val[r];\n\t\tdfs(r + 1, cnt);\n\t\tsum[i] -= val[r];\n\t}\n\tsum[cnt] = val[r];\n\tdfs(r + 1, cnt + 1);\n\tsum[cnt] = 0;\n}\n\nint main() {\n\tn = re, w = re;\n\tfor (int i = 0; i &lt; n; i++) val[i] = re;\n\tsort(val, val + n, greater&lt;int&gt;());\n\tdfs(0, 1);\n\twr(ans), endl;\n}\n</code></pre>\n</details>\n<ol start=\"2\">\n<li>DP做法</li>\n</ol>\n<p>这种做法还要分两种做法。</p>\n<ol>\n<li>$O(3^n) $ 做法</li>\n</ol>\n<p><span class=\"math inline\">\\(dp_s\\)</span> 表示状态为 <span class=\"math inline\">\\(s\\)</span> 时，需要的最少电梯次数。</p>\n<p>转移式还是很简单</p>\n<p></p><div class=\"math display\">\\[dp_s = min(dp_{s \\oplus t}),{t \\subseteq s} \n\\]</div><p></p><details>\n戳我喵~\n<pre><code>int n, w;\nlint val[30], W[(1 &lt;&lt; 18) + 10];\nlint dp[(1 &lt;&lt; 18) + 10];\n\nsigned main() {\n\tIAKIOI;\n\tn = re, w = re;\n\tfor (int i = 0; i &lt; n; i++) val[i] = re;\n\tmemset(dp, 0x3f, sizeof dp);\n\tdp[0]=0;\n\tfor (int s = 1; s &lt; (1 &lt;&lt; n); s++) for (int i = 0; i &lt; n; i++) if ((s &gt;&gt; i) &amp; 1) W[s] += val[i];\n\tfor (int s = 1; s &lt; (1 &lt;&lt; n); s++) for (int t = s; t; t = (t - 1) &amp; s) if (W[t] &lt;= w) dp[s] = min(dp[s], dp[s ^ t] + 1);\n\twr(dp[(1 &lt;&lt; n) - 1]), endl;\n}\n</code></pre>\n</details>\n<ol start=\"2\">\n<li><span class=\"math inline\">\\(O(2 ^ n \\times n ^ 2)\\)</span> 做法</li>\n</ol>\n<p>$ dp_{i, s} $：表示当前已经开启了 <span class=\"math inline\">\\(i\\)</span> 架电梯, 且当前已下楼奶牛的状态为 <span class=\"math inline\">\\(s\\)</span> 的情况下，最后一架电梯当前的载重量。</p>\n<ul>\n<li>当前电梯还能装下，即不用新开电梯</li>\n</ul>\n<p>那么</p>\n<p></p><div class=\"math display\">\\[dp_{i, s | (1 &lt;&lt; k)} = min(dp_{i, s} + val_k) \n\\]</div><p></p><ul>\n<li>当前电梯不能装下，即需要新开电梯</li>\n</ul>\n<p>那么</p>\n<p></p><div class=\"math display\">\\[dp_{i + 1, s | (1 &lt;&lt; k)} = min(val_k) \n\\]</div><p></p><details>\n戳我喵~\n<pre><code>int n, w;\nint val[30];\nint dp[30][(1 &lt;&lt; 21) + 10];\n\nsigned main() {\n\tIAKIOI;\n\tn = re, w = re;\n\tfor (int i = 0; i &lt; n; i++) val[i] = re;\n\tmemset(dp, INF, sizeof dp);\n\tfor (int i = 0; i &lt; n; i++) dp[i + 1][1 &lt;&lt; i] = val[i];\n\tfor (int s = 1; s &lt; (1 &lt;&lt; n); s++) for (int i = 1; i &lt;= n; i++) if (dp[i][s] &lt;= w) for (int k = 0; k &lt; n; k++) if (!((s &gt;&gt; k) &amp; 1)) {\n\t\tif (dp[i][s] + val[k] &lt;= w) dp[i][s | (1 &lt;&lt; k)] = min(dp[i][s | (1 &lt;&lt; k)], dp[i][s] + val[k]);\n\t\telse dp[i + 1][s | (1 &lt;&lt; k)] = min(dp[i + 1][s | (1 &lt;&lt; k)], val[k]);\n\t}\n\tfor (int i = 1; i &lt;= n; i++) if (dp[i][(1 &lt;&lt; n) - 1] != INF) {\n\t\twr(i), endl;\n\t\treturn 0;\n\t}\n}\n</code></pre>\n</details>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 19:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sPERbEETLE\">cqbzcdr</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "总结各GPU的OpenCL子组洗牌支持情况",
      "link": "https://www.cnblogs.com/RainbowC0/p/19595783",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/RainbowC0/p/19595783\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 19:39\">\n    <span>总结各GPU的OpenCL子组洗牌支持情况</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#nvidia\" rel=\"noopener nofollow\">Nvidia</a></li><li><a href=\"#intel\" rel=\"noopener nofollow\">Intel</a></li><li><a href=\"#amd-rocm\" rel=\"noopener nofollow\">AMD ROCm</a></li><li><a href=\"#amd-palhsail\" rel=\"noopener nofollow\">AMD PAL/HSAIL</a></li><li><a href=\"#qualcommon-adreno\" rel=\"noopener nofollow\">Qualcommon Adreno</a></li><li><a href=\"#clvk\" rel=\"noopener nofollow\">CLVK</a></li><li><a href=\"#参见\" rel=\"noopener nofollow\">参见</a></li></ul></div><p></p>\n<p>子组(Sub-group)自 OpenCL 2.0 正式引入，是工作组(Work-group)内部更小的执行单位，通常直接映射到 GPU 的 SIMD/SIMT 执行单元（如 Nvidia Warp 和 AMD Wavefront），具有更好的数据共享与同步能力。</p>\n<p>OpenCL 2.0 通过扩展<code>cl_khr_subgroups</code>提供一些基础子组操作支持，包括获取子组 ID、组内 ID 等基本功能，组内断言(any/all)、广播(broadcast)、归约(reduce)、扫描(scan)等基本操作，同时允许一些可选扩展支持更丰富的子组操作（比如洗牌(shuffle)、投票(ballot)等）。其中子组内洗牌用于直接交换子组内寄存器值而不借助全局或本地内存（类比 CUDA 束内洗牌），经常用于一些算法优化，是比较有用的子组函数，但是大多数 GPU 都不支持官方的<code>cl_khr_subgroup_shuffle</code>扩展。当然一些厂商也可以通过厂商扩展、内联汇编(Inline Assembly)、内置函数(Intrinsics/Builtins)等途径支持子组洗牌。</p>\n<h2 id=\"nvidia\">Nvidia</h2>\n<p>通过内置函数<code>__nvvm_shfl_&lt;mode&gt;_&lt;type&gt;</code>(sm_70 以前)、<code>__nvvm_shfl_sync_&lt;mode&gt;_&lt;type&gt;</code>(sm_70+, ptx60+<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\" rel=\"noopener nofollow\">[1]</a></sup>)支持。CUDA 中的线程束洗牌原语也是通过这些内置函数实现的。</p>\n<table>\n<thead>\n<tr>\n<th>内置函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>gentype __nvvm_shfl_&lt;mode&gt;_&lt;type&gt;(gentype val, int offset, int clamp)</code></td>\n<td>按照<code>&lt;mode&gt;</code>定义规则将<code>offset</code>处车道的<code>val</code>传递到本车道，对<code>clamp</code>内源车道有效</td>\n</tr>\n<tr>\n<td><code>gentype __nvvm_shfl_sync_&lt;mode&gt;_&lt;type&gt;(uint mask, gentype val, int offset, int clamp)</code></td>\n<td>按照<code>&lt;mode&gt;</code>定义规则将<code>offset</code>处车道的<code>val</code>传递到本车道，并按照<code>mask</code>同步线程束，对<code>clamp</code>内源车道有效</td>\n</tr>\n</tbody>\n</table>\n<p>其中<code>&lt;type&gt;</code>可取<code>i32</code>、<code>f32</code>，对应<code>gentype</code>为<code>int</code>、<code>float</code>。</p>\n<p>其中<code>&lt;mode&gt;</code>取值如下：</p>\n<table>\n<thead>\n<tr>\n<th><code>&lt;mode&gt;</code></th>\n<th>目的车道</th>\n<th>对标 OpenCL 子组函数</th>\n<th>对应 OpenCL 子组扩展</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>idx</td>\n<td>offset</td>\n<td>sub_group_shuffle</td>\n<td>cl_khr_subgroup_shuffle</td>\n</tr>\n<tr>\n<td>bfly</td>\n<td>laneid ^ offset</td>\n<td>sub_group_shuffle_xor</td>\n<td>cl_khr_subgroup_shuffle</td>\n</tr>\n<tr>\n<td>up</td>\n<td>laneid - offset</td>\n<td>sub_group_shuffle_up</td>\n<td>cl_khr_subgroup_shuffle_relative</td>\n</tr>\n<tr>\n<td>down</td>\n<td>laneid + offset</td>\n<td>sub_group_shuffle_down</td>\n<td>cl_khr_subgroup_shuffle_relative</td>\n</tr>\n</tbody>\n</table>\n<p>Nvidia 的 OpenCL 驱动支持 PTX 内联汇编，因此可直接调用<code>shfl.&lt;mode&gt;.&lt;type&gt;</code>和<code>shfl.sync.&lt;mode&gt;.&lt;type&gt;</code>等汇编指令。</p>\n<h2 id=\"intel\">Intel</h2>\n<p>提供扩展<code>cl_intel_subgroups</code>支持多种子组洗牌操作。目前 Intel 是对 OpenCL 支持比较好的厂商，该扩展自 OpenCL 1.2 加入，并且直接实现了多种子组洗牌、投票函数。</p>\n<table>\n<thead>\n<tr>\n<th>扩展函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>gentype intel_sub_group_shuffle(gentype data, uint sub_group_local_id)</code></td>\n<td>将<code>sub_group_local_id</code>子组工作项的数据值传递给本子组工作项。</td>\n</tr>\n<tr>\n<td><code>gentype intel_sub_group_shuffle_down(gentype curr, gentype, gentype next, uint delta)</code></td>\n<td><p>将<code>sub_group_local_id</code>+<code>delta</code>作为目的子组索引。</p><p>若子组索引大于等于 0 且小于<code>max_sub_group_size</code>则传递<code>curr</code>。</p><p>若子组索引大于等于<code>max_sub_group_size</code>且小于<code>max_sub_group_size</code> * 2，则将目的子组索引减<code>max_sub_group_size</code>，传递<code>next</code>。</p></td>\n</tr>\n<tr>\n<td><code>gentype intel_sub_group_shuffle_up(gentype curr, gentype, gentype next, uint delta)</code></td>\n<td><p>将<code>sub_group_local_id</code>-<code>delta</code>作为目的子组索引。</p><p>若子组索引大于等于 0 且小于<code>max_sub_group_size</code>则传递<code>curr</code>。</p><p>若子组索引大于等于负<code>max_sub_group_size</code>且小于 0，则将目的子组索引加<code>max_sub_group_size</code>，传递<code>next</code>。</p></td>\n</tr>\n<tr>\n<td><code>gentype intel_sub_group_shuffle_xor(gentype data, uint val)</code></td>\n<td>将<code>sub_group_local_id</code> XOR <code>val</code>子组工作项的数据值传递给本子组工作项。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"amd-rocm\">AMD ROCm</h2>\n<p>有前缀为<code>__builtin_amdgcn_</code>的内置函数<code>ds_permute</code>、<code>ds_bpermute</code>，前者将数据从当前车道推送(Push)到目标车道，而后者从目标车道拉取(Pull)到当前车道，与 OpenCL 中的 <code>sub_group_shuffle</code> 定义类似。</p>\n<table>\n<thead>\n<tr>\n<th>内置函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>int __builtin_amdgcn_ds_permute(int offset, int val)</code></td>\n<td>将本车道的数据值传输到索引为<code>offset</code>的车道</td>\n</tr>\n<tr>\n<td><code>int __builtin_amdgcn_ds_bpermute(int offset, int val)</code></td>\n<td>将索引为<code>offset</code>的车道的数据值传输到本车道</td>\n</tr>\n</tbody>\n</table>\n<p>另外，AMD ROCm 还提供<code>ds_swizzle</code>(字节单位交换)、<code>dpp_mov</code>(数据并行移动)等内部函数实现更丰富的子组洗牌操作。</p>\n<p>AMD ROCm 的 OpenCL 驱动同样支持内联汇编，可以直接调用<code>ds.permute</code>、<code>ds.bpermute</code>等 AMDGCN 指令。</p>\n<h2 id=\"amd-palhsail\">AMD PAL/HSAIL</h2>\n<p>ROCm 不支持 Windows 集显，其默认驱动为 AMD PAL/HSAIL。AMD PAL/HSAIL 提供内置函数<code>gentype __hsail_activelanepermute_wavewidth_&lt;type&gt;(gentype src, uint lid, gentype ival, bool useival)</code>实现活跃车道交换（不同步）<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\" rel=\"noopener nofollow\">[2]</a></sup>。该函数将目的索引<code>lid</code>的车道的数据值交换到本车道。若<code>lid</code>非法，当<code>useival</code>为真时，返回<code>ival</code>，否则未定义。</p>\n<p>其中<code>&lt;w&gt;</code>可取<code>b1</code>、<code>b32</code>、<code>b64</code>，表示该指令进行交换的数据宽度，对应<code>gentype</code>为<code>uchar</code>、<code>uint</code>、<code>ulong</code>。</p>\n<blockquote>\n<p>使用<code>__hsail_activelanepermute_wavewidth_&lt;type&gt;</code>时需要在代码中声明该函数，否则编译时会报错找不到符号。参见<a href=\"https://github.com/HSAFoundation/builtins\" rel=\"noopener nofollow\" target=\"_blank\">HSAFoundation/builtins</a><sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\" rel=\"noopener nofollow\">[3]</a></sup>。</p>\n</blockquote>\n<p>另外，<code>sub_group_broadcast</code>是用该指令与<code>__hsail_wavebarrier()</code>实现的，因此也可用子组广播进行洗牌。</p>\n<h2 id=\"qualcommon-adreno\">Qualcommon Adreno</h2>\n<p>提供扩展<code>cl_qcom_subgroup_shuffle</code>支持子组洗牌操作，允许全组洗牌、宽 4 洗牌、宽 8 洗牌。</p>\n<p>扩展函数：</p>\n<pre><code class=\"language-c\">&lt;gentype&gt; qcom_sub_group_shuffle_&lt;op&gt;(\n            &lt;gentype&gt; source_value,\n            uint offset,\n            qcom_sub_group_shuffle_width_modes_t width,\n            &lt;gentype&gt; default_value);\n</code></pre>\n<p>其中<code>&lt;gentype&gt;</code>可为<code>uchar</code>、<code>char</code>、<code>ushort</code>、<code>short</code>、<code>uint</code>、<code>int</code>、<code>ulong</code>、<code>long</code>以及<code>float</code>，如果启用<code>cl_khr_fp16</code>扩展，则也可取<code>half</code>。</p>\n<p>其中<code>&lt;op&gt;</code>可为<code>up</code>、<code>down</code>、<code>rotate_up</code>、<code>rotate_down</code>、<code>xor</code>。</p>\n<p><code>qcom_sub_group_shuffle_width_modes_t</code>为枚举类型，取值如下：</p>\n<table>\n<thead>\n<tr>\n<th>子组洗牌宽度模式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>CLK_SUB_GROUP_SHUFFLE_WIDTH_WAVE_SIZE_QCOM</code></td>\n<td>子组内所有工作项参与洗牌</td>\n</tr>\n<tr>\n<td><code>CLK_SUB_GROUP_SHUFFLE_WIDTH_W4_QCOM</code></td>\n<td>子组内每4个工作项之间洗牌</td>\n</tr>\n<tr>\n<td><code>CLK_SUB_GROUP_SHUFFLE_WIDTH_W8_QCOM</code></td>\n<td>子组内每8个工作项之间洗牌</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"clvk\">CLVK</h2>\n<p><a href=\"https://github.com/kpet/clvk\" rel=\"noopener nofollow\" target=\"_blank\">CLVK</a> 是基于 Vulkan 的 OpenCL 3.0 实现，使用 <a href=\"https://www.google.com/clspv\" rel=\"noopener nofollow\" target=\"_blank\">clspv</a> 编译器将 OpenCL C 源码编译为 SPIR-V 二进制格式作为 Vulkan 计算着色器使用。CLVK 支持官方 <code>cl_khr_subgroup_shuffle</code> 扩展。</p>\n<hr />\n<h2 id=\"参见\">参见</h2>\n<ol>\n<li><a href=\"https://registry.khronos.org/OpenCL/specs/3.0-unified/html/OpenCL_C.html#sub-group-functions\" rel=\"noopener nofollow\" target=\"_blank\">https://registry.khronos.org/OpenCL/specs/3.0-unified/html/OpenCL_C.html#sub-group-functions</a></li>\n<li><a href=\"https://reviews.llvm.org/D38090\" rel=\"noopener nofollow\" target=\"_blank\">https://reviews.llvm.org/D38090</a></li>\n<li><a href=\"https://registry.khronos.org/OpenCL/extensions/intel/cl_intel_subgroups.html\" rel=\"noopener nofollow\" target=\"_blank\">https://registry.khronos.org/OpenCL/extensions/intel/cl_intel_subgroups.html</a></li>\n<li><a href=\"https://reviews.llvm.org/D17614\" rel=\"noopener nofollow\" target=\"_blank\">https://reviews.llvm.org/D17614</a></li>\n<li><a href=\"https://github.com/HSAFoundation/builtins\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/HSAFoundation/builtins</a></li>\n<li><a href=\"https://github.com/HSAFoundation/HLC-HSAIL-Development-LLVM/blob/hsail-review-v4/lib/Target/HSAIL/HSAILIntrinsics.td\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/HSAFoundation/HLC-HSAIL-Development-LLVM/blob/hsail-review-v4/lib/Target/HSAIL/HSAILIntrinsics.td</a></li>\n<li><a href=\"https://github.com/willhua/QualcommOpenCLSDKNote/blob/master/docs/extensions/cl_qcom_subgroup_shuffle.txt\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/willhua/QualcommOpenCLSDKNote/blob/master/docs/extensions/cl_qcom_subgroup_shuffle.txt</a></li>\n</ol>\n<hr />\n<p>原文连接 <a href=\"https://www.cnblogs.com/RainbowC0/p/19595783\" target=\"_blank\">https://www.cnblogs.com/RainbowC0/p/19595783</a>，未经作者许可禁止转载。</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li class=\"footnote-item\" id=\"fn1\"><p>架构可通过编译参数<code>-cl-nv-arch</code>指定，默认与设备架构一致；ptx60 需要通过编译参数<code>--Xclang -target-feature --Xclang +ptx60</code>指定。 <a class=\"footnote-backref\" href=\"#fnref1\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n<li class=\"footnote-item\" id=\"fn2\"><p>驱动程序中还可以看到<code>__gcn_ds_permute_&lt;type&gt;</code>、<code>__gcn_ds_bpermute_&lt;type&gt;</code>、<code>__gcn_dpp_mov_&lt;type&gt;</code>等内置函数，但实际编译时会报错<code>LLVM ERROR: cannot select: intrinsic</code>，GPU 本身是 GCN 架构，可能需要通过特定编译参数支持 GCN 扩展。 <a class=\"footnote-backref\" href=\"#fnref2\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n<li class=\"footnote-item\" id=\"fn3\"><p>目前的驱动程序内有字段<code>__hsail_activelanepermute_wavewidth</code>，而<a href=\"https://github.com/HSAFoundation/builtins\" rel=\"noopener nofollow\" target=\"_blank\">HSAFoundation/builtins</a>内给出的是<code>__hsail_activelaneshuffle_wavewidth</code>，应该有误。 <a class=\"footnote-backref\" href=\"#fnref3\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n</ol>\n</section>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 19:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/RainbowC0\">RainbowC0</a>&nbsp;\n阅读(<span id=\"post_view_count\">9</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "模型评估小册（1） ROC 曲线与 AUC",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19605705",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19605705\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 19:19\">\n    <span>模型评估小册（1） ROC 曲线与 AUC</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>一点前言：之前完成了吴恩达深度学习的相关内容，最近忙于毕设，更新可能没之前那么频繁。这个新开的分类关于<strong>模型评估的各种指标</strong>的详解，之前翻看书籍总是被一堆很官方化的概念和密密麻麻的符号搞的看不下去，因此，这次的中心思想是以尽可能<strong>通俗的语言、精简的篇幅</strong>来讲解这类概念并辅以实例。<br />\n不多废话，以下为正文。</p>\n<hr />\n<h1 id=\"1-检测问题中的两难情景\">1. 检测问题中的“两难情景”</h1>\n<p>假设我们在机场负责安检。任务很简单：<strong>把携带危险物品的人拦下来。</strong></p>\n<p>但现实远没有这么简单，如果我们把安检<strong>标准定得非常严格</strong>——一点可疑都不放过，那么确实可以拦下几乎所有危险人员。<br />\n但代价是，<strong>正常旅客也会被频繁拦下复检</strong>，队伍排到大厅外。</p>\n<p>而如果我们<strong>把标准放宽</strong>——只在非常明显的情况下才拦人，旅客通行效率会提高。<br />\n但显然，这就<strong>有更大可能漏掉真正的风险</strong>。</p>\n<p>这就是一个经典的两难：<strong>选择杀错还是放过</strong>？</p>\n<blockquote>\n<p><strong>抓得越多，错抓也越多。</strong><br />\n<strong>抓得越少，漏抓就越多。</strong></p>\n</blockquote>\n<p><img alt=\"f2bc31dc-fe19-439e-a7a0-4efb06659caf.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202602/3708248-20260211191745572-2075288255.png\" /></p>\n<p>目标检测问题本质上也是如此，在高光谱目标检测、雷达探测、异常检测等目标检测任务中，我们面对的不是“对或错”这么简单，而是<strong>在任务情景中，对“错报”和“漏报”的权衡选择</strong>：</p>\n<blockquote>\n<p><strong>我的模型，能检测出多少真实目标？但同时会误报多少背景？我的任务要求我更偏向哪边？在哪里二者较为均衡？</strong></p>\n</blockquote>\n<p>总之，在检测系统中，没有免费的午餐：提高检测率，往往要付出虚警率的代价。<br />\nROC 曲线描述的，正是这两者之间的关系。</p>\n<h1 id=\"2-rocreceiver-operating-characteristic\">2. ROC（Receiver Operating Characteristic）</h1>\n<p>ROC 的英文全称为 <strong>Receiver Operating Characteristic</strong> ，直译为受试者工作特征曲线，它来源于<strong>统计学中的检测理论</strong>，而最早的应用领域是<strong>雷达探测</strong>。</p>\n<p>不同于一些常见指标，<strong>ROC 刻画的是虚警概率和检测概率间的函数关系</strong>。<br />\n直接来看一个实例：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202602/3708248-20260211191746062-1023289789.png\" /><br />\n现在，假设一天有 <strong>100 个携带危险物品的旅客</strong>和 <strong>1000 个普通旅客</strong>：</p>\n<p>1.<strong>真阳性率（TPR / Pd）</strong>：系统能正确抓住真正危险旅客的比例，即“该抓的抓了多少”。<br />\n2.<strong>假阳性率（FPR / Fa）</strong>：系统把普通旅客误判为危险旅客的比例，即“不该抓的抓错了多少”。</p>\n<table>\n<thead>\n<tr>\n<th>普通旅客数量</th>\n<th>危险旅客数量</th>\n<th>通过 / 正常数量</th>\n<th>抓到数量</th>\n<th>指标及计算过程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>—</td>\n<td>100</td>\n<td>3 漏掉</td>\n<td>97  抓到</td>\n<td><strong>真阳性率 Pd = 97 / 100 = 0.97 (97%)</strong></td>\n</tr>\n<tr>\n<td>1000</td>\n<td>—</td>\n<td>800 正常通过</td>\n<td>200 误抓</td>\n<td><strong>假阳性率 Fa = 200 / 1000 = 0.2 (20%)</strong></td>\n</tr>\n</tbody>\n</table>\n<p>实际上二者的计算还是对四类基础统计量的应用。<br />\n这样，我们就得到了 ROC 曲线中的一个点：<span class=\"math inline\">\\((0.2,0.97)\\)</span> ，我们称之为<strong>Pd @ Fa 或 Pd / Fa</strong> ，它说明了<strong>在特定虚警率下能抓到多少目标</strong>，展开如下：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202602/3708248-20260211191743792-444019702.png\" /><br />\n到这里，就会发现： <strong>ROC 曲线中的一个点就是一种决策阈值下的模型表现。</strong><br />\n我们不断测试不同的阈值计算，最终就会得到 ROC 曲线，列举几种情况如下：</p>\n<table>\n<thead>\n<tr>\n<th>阈值 t</th>\n<th>判定规则</th>\n<th>危险旅客抓到情况 (Pd)</th>\n<th>普通旅客误抓情况 (Fa)</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0.8</td>\n<td>只有概率 ≥ 0.8 判为危险</td>\n<td>80 / 100 = 0.80</td>\n<td>50 / 1000 = 0.05</td>\n<td>严格判定，只抓最明显的危险旅客，虚警很少</td>\n</tr>\n<tr>\n<td>0.5</td>\n<td>概率 ≥ 0.5 判为危险</td>\n<td>95 / 100 = 0.95</td>\n<td>200 / 1000 = 0.20</td>\n<td>中等判定，抓到大部分危险旅客，虚警适中</td>\n</tr>\n<tr>\n<td>0.3</td>\n<td>概率 ≥ 0.3 判为危险</td>\n<td>99 / 100 = 0.99</td>\n<td>400 / 1000 = 0.40</td>\n<td>宽松判定，几乎抓到全部危险旅客，但虚警明显增加</td>\n</tr>\n<tr>\n<td>0.1</td>\n<td>概率 ≥ 0.1 判为危险</td>\n<td>100 / 100 = 1.00</td>\n<td>800 / 1000 = 0.80</td>\n<td>极度宽松，抓到全部危险旅客，但绝大部分普通旅客也被误抓</td>\n</tr>\n</tbody>\n</table>\n<p>观察下来，你会发现：<strong>误报率越高往往代表阈值越低。</strong><br />\n而到了这里，你可能会有一个问题：<strong>那在实际运行中，我总不能一个个阈值去试吧？要多少次才能拼出来完整曲线？</strong></p>\n<p>实际上，我们<strong>在真实运行中只需要运行一次模型就可以得到完整 ROC 曲线。</strong><br />\n<strong>用一句话概括其算法：存储模型对每个样本的输出概率并排序，从高到低依次确认为正类（抓捕）并计算 Pd @ Fa ，加入图像。</strong><br />\n来看个例子：</p>\n<table>\n<thead>\n<tr>\n<th>排名</th>\n<th>旅客 ID</th>\n<th>是否危险</th>\n<th>模型概率 p</th>\n<th>挨个抓</th>\n<th>累计 TP</th>\n<th>累计 FP</th>\n<th>Pd = TP / 3</th>\n<th>Fa = FP / 7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>A</td>\n<td>✅ 危险</td>\n<td>0.95</td>\n<td>抓</td>\n<td>1</td>\n<td>0</td>\n<td>0.33</td>\n<td>0</td>\n</tr>\n<tr>\n<td>2</td>\n<td>B</td>\n<td>❌ 普通</td>\n<td>0.90</td>\n<td>抓</td>\n<td>1</td>\n<td>1</td>\n<td>0.33</td>\n<td>0.14</td>\n</tr>\n<tr>\n<td>3</td>\n<td>C</td>\n<td>✅ 危险</td>\n<td>0.85</td>\n<td>抓</td>\n<td>2</td>\n<td>1</td>\n<td>0.67</td>\n<td>0.14</td>\n</tr>\n<tr>\n<td>4</td>\n<td>D</td>\n<td>❌ 普通</td>\n<td>0.70</td>\n<td>抓</td>\n<td>2</td>\n<td>2</td>\n<td>0.67</td>\n<td>0.29</td>\n</tr>\n<tr>\n<td>5</td>\n<td>E</td>\n<td>❌ 普通</td>\n<td>0.60</td>\n<td>抓</td>\n<td>2</td>\n<td>3</td>\n<td>0.67</td>\n<td>0.43</td>\n</tr>\n<tr>\n<td><strong>6</strong></td>\n<td><strong>F</strong></td>\n<td><strong>✅ 危险</strong></td>\n<td><strong>0.50</strong></td>\n<td><strong>抓</strong></td>\n<td><strong>3</strong></td>\n<td><strong>3</strong></td>\n<td><strong>1.00</strong></td>\n<td><strong>0.43</strong></td>\n</tr>\n<tr>\n<td>7</td>\n<td>G</td>\n<td>❌ 普通</td>\n<td>0.45</td>\n<td>抓</td>\n<td>3</td>\n<td>4</td>\n<td>1.00</td>\n<td>0.57</td>\n</tr>\n<tr>\n<td>8</td>\n<td>H</td>\n<td>❌ 普通</td>\n<td>0.30</td>\n<td>抓</td>\n<td>3</td>\n<td>5</td>\n<td>1.00</td>\n<td>0.71</td>\n</tr>\n<tr>\n<td>9</td>\n<td>I</td>\n<td>❌ 普通</td>\n<td>0.20</td>\n<td>抓</td>\n<td>3</td>\n<td>6</td>\n<td>1.00</td>\n<td>0.86</td>\n</tr>\n<tr>\n<td>10</td>\n<td>J</td>\n<td>❌ 普通</td>\n<td>0.10</td>\n<td>抓</td>\n<td>3</td>\n<td>7</td>\n<td>1.00</td>\n<td>1.00</td>\n</tr>\n</tbody>\n</table>\n<p>在这里，<strong>当把旅客F抓捕时，计算得到的 Pd @ Fa 较优，也就是说，其对应的模型概率 p=0.5 就是一个可能较优的决策阈值选择。</strong></p>\n<p>到这里 ROC 的内容就基本结束，但是你会发现：<strong>曲线里我光看不同阈值的情况了，那这个模型本身到底好不好？有多好？能不能给我一个明确的评估呢？</strong><br />\n这就是与 ROC 曲线相关联的内容：AUC 。</p>\n<h1 id=\"3-aucarea-under-curve\">3. AUC（Area Under Curve）</h1>\n<p>AUC 的全称是 Area Under Curve，直译就是ROC 曲线下面积。它用一个<strong>单一指标</strong>来衡量模型整体能力。<br />\n在得到 ROC 曲线后，AUC的计算非常简单：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202602/3708248-20260211191744270-1543306405.png\" /><br />\n显然，AUC面积越大，模型越能在低虚警率下实现高检测率，模型的检测效果就越好。<br />\n并且，我们不需要提前选定决策阈值，就可以知道模型整体的好坏。</p>\n<p>总结一句话：<strong>ROC 告诉我们在不同标准下模型表现如何，而 AUC 则给出一个整体评分，实现不用盯着每个阈值也能知道模型好不好，从而帮助相关任务的调优和部署。</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 19:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">13</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "“声”临其境网站分享",
      "link": "https://www.cnblogs.com/LXP-Never/p/19605364",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/LXP-Never/p/19605364\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 17:27\">\n    <span>“声”临其境网站分享</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>你是否也会有这样的感受：自己一个人在安静的家里反而没有工作的氛围，很难集中注意力</p>\n<p>你是否想念办公室里此起彼伏的键盘声？是否怀念图书馆里安静的翻书声？或是咖啡馆里温暖的喧嚣？当我们因为各种原因无法身处那些熟悉的空间时，这些声音成了我们最深的念想。下面为你分享一系列\"想念\"主题的环境音网站，让你随时随地重温那些记忆中的声音，找回那份熟悉的感觉。</p>\n<p>这个网站能怎么用呢：</p>\n<ol>\n<li>用于在家里给你身临其境的感觉</li>\n<li>用于音频设备测试，哈哈，不用满网站去找音频了</li>\n</ol>\n<h2 id=\"1\">办公室的声音</h2>\n<ul>\n<li>✨&nbsp;<a href=\"https://imisstheoffice.eu/\" rel=\"noopener nofollow\">I Miss The Office</a>: 当远程办公成为常态，你是否怀念办公室里同事的问候声、打印机的运转声、咖啡机的工作声？这个网站帮你重温那些熟悉的办公室背景音。</li>\n<li>🎧&nbsp;<a href=\"https://mynoise.net/NoiseMachines/openOfficeNoiseGenerator.php\" rel=\"noopener nofollow\">myNoise - Open Office Noise Generator</a>: 可自定义的开放式办公室音效，调节每一种声音的音量，重现记忆中那个有温度的办公室。&nbsp;</li>\n</ul>\n<p><img alt=\"image\" height=\"505\" src=\"https://img2024.cnblogs.com/blog/1433301/202602/1433301-20260211164437369-1038341926.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"608\" /></p>\n<p><img alt=\"\" src=\"https://knightyun.github.io/markdown-to-richtext/repository/image/%E2%80%9C%E5%A3%B0%E2%80%9D%E4%B8%B4%E5%85%B6%E5%A2%83%E7%BD%91%E7%AB%99%E5%88%86%E4%BA%AB/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20260211_164005.jpeg\" /></p>\n<h2>图书馆的声音</h2>\n<ul>\n<li>📚&nbsp;<a href=\"https://www.imissmylibrary.com/\" rel=\"noopener nofollow\">I Miss My Library</a>: 那个安静的角落、偶尔的翻书声、远处轻轻的脚步声——当你无法去图书馆时，让这个网站带你回到那个专注而平静的空间。&nbsp;</li>\n</ul>\n<p><img alt=\"file-20260211163544068\" height=\"518\" src=\"https://img2024.cnblogs.com/blog/1433301/202602/1433301-20260211165103664-1302666359.jpg\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"782\" /></p>\n<p><img alt=\"\" src=\"https://knightyun.github.io/markdown-to-richtext/repository/image/%EF%80%A2%E5%A3%B0%EF%80%A2%E4%B8%B4%E5%85%B6%E5%A2%83%E7%BD%91%E7%AB%99%E5%88%86%E4%BA%AB/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20260211_163402.jpeg\" /></p>\n<h2>咖啡馆的声音</h2>\n<ul>\n<li>☕&nbsp;<a href=\"https://imissmycafe.com/\" rel=\"noopener nofollow\">I Miss My Cafe</a>: 怀念那个常去的咖啡馆吗？轻柔的背景音乐、杯盘碰撞的声音、陌生人的交谈声……这些声音拼凑成记忆中最温暖的画面。</li>\n<li>🎶&nbsp;<a href=\"https://hipstersound.com/ambience.html\" rel=\"noopener nofollow\">Hipster Sound - Cafe Ambience</a>: 精心重现咖啡馆的氛围，让你仿佛又坐在那个熟悉的位置，重温惬意时光。</li>\n</ul>\n<p><img alt=\"cafe-ambience\" height=\"469\" src=\"https://img2024.cnblogs.com/blog/1433301/202602/1433301-20260211165307740-1452624381.jpg\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"703\" /></p>\n<h2>餐厅的声音</h2>\n<ul>\n<li>🍽️&nbsp;<a href=\"https://hipstersound.com/\" rel=\"noopener nofollow\">Hipster Sound - Restaurant Ambience</a>: 那些和朋友相聚的餐厅、热闹的氛围、欢快的谈笑声，这个网站帮你找回那些美好的聚餐时光。</li>\n</ul>\n<h2 id=\"2\">城市雨天</h2>\n<ul>\n<li>🌧️&nbsp;<a href=\"https://rainyscope.com/\" rel=\"noopener nofollow\">Rainyscope</a>: 还记得坐在窗边听雨的感觉吗？温柔的雨声敲打窗户，让人心静而温暖。这个网站带你重温那些雨天的美好时光。</li>\n</ul>\n<p><img alt=\"rain-window\" height=\"579\" src=\"https://img2024.cnblogs.com/blog/1433301/202602/1433301-20260211165336518-1364073062.jpg\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"386\" /></p>\n<h2>海边的声音</h2>\n<ul>\n<li>🌊 <a href=\"https://virtocean.com/\" rel=\"noopener nofollow\" target=\"_blank\">Virtocean</a>: 海浪拍打沙滩的声音、海风吹过的声音……当你无法去海边时，让这些声音带你回到那片蔚蓝。</li>\n</ul>\n<p><img alt=\"ocean-waves\" height=\"619\" src=\"https://img2024.cnblogs.com/blog/1433301/202602/1433301-20260211165354416-2008879966.jpg\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"348\" /></p>\n<h2>城市的声音</h2>\n<ul>\n<li>🚦&nbsp;<a href=\"https://mynoise.net/NoiseMachines/urbanRainSoundGenerator.php\" rel=\"noopener nofollow\">myNoise - Urban Rain Sound Generator</a>: 雨夜的城市、车流的声音、雨滴打在街道上的声音……这些声音构成了都市独特的韵律。</li>\n</ul>\n<p>希望这些网站能帮你找回那些想念的声音，在熟悉的音效中，重温记忆里那些温暖的时光。因为有些地方，即使不在身边，也永远在心里。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 17:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/LXP-Never\">凌逆战</a>&nbsp;\n阅读(<span id=\"post_view_count\">44</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}