{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "字符编码知多少(二)",
      "link": "https://www.cnblogs.com/lmy5215006/p/19567495",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lmy5215006/p/19567495\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 16:14\">\n    <span>字符编码知多少(二)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"bom头\">BOM头</h1>\n<p>BOM头全程Byte Order Mark (字节顺序标记), 是Unicode编码标准中，最早是用于UTF32/16中标识字节顺序的特殊字符，后来随着UTF-8的出现，为了兼容，又有了标识文本编码格式的作用。</p>\n<blockquote>\n<p>最初主要是为了解决UTF32/16编码方案中大小端的问题，(大端BE：高字节在前，小端LE：低字节在前)。所以需要在字符串前增加一个特殊标记，以方便识别解析。<br />\n随着UTF-8的出现，不再需要BOM头。但微软为了方便自家软件能快速区分UTF-8与ANSI编码，而额外引入了<code>非标准拓展</code>。因此有了独特的UTF-8 BOM 编码方式</p>\n</blockquote>\n<hr />\n<h2 id=\"不同unicode编码中的bom头表现\">不同Unicode编码中的BOM头表现</h2>\n<table>\n<thead>\n<tr>\n<th>编码格式</th>\n<th>BOM头字节序列</th>\n<th>长度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UTF-8 BOM (微软特色)</td>\n<td><strong>EF BB BF</strong></td>\n<td>3字节</td>\n<td>仅作编码标识，无字节顺序问题</td>\n</tr>\n<tr>\n<td>UTF-8</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>UTF-16 BE（大端）</td>\n<td><strong>FE FF</strong></td>\n<td>2字节</td>\n<td>表示高位字节在前</td>\n</tr>\n<tr>\n<td>UTF-16 LE（小端）</td>\n<td><strong>FF FE</strong></td>\n<td>2字节</td>\n<td>表示低位字节在前</td>\n</tr>\n<tr>\n<td>UTF-32 BE</td>\n<td><strong>00 00 FE FF</strong></td>\n<td>4字节</td>\n<td>表示高位字节在前</td>\n</tr>\n<tr>\n<td>UTF-32 LE</td>\n<td><strong>FF FE 00 00</strong></td>\n<td>4字节</td>\n<td>表示低位字节在前</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"眼见为实\">眼见为实</h2>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<blockquote>\n<p>使用文本编辑器，选择另存为，保存为不同的编码方案</p>\n</blockquote>\n<pre><code>        public static void Run()\n        {\n            var utf8_path = @\"C:\\Users\\liu\\Documents\\utf-8.txt\";\n            var utf8_bom_path = @\"C:\\Users\\liu\\Documents\\utf-8 bom.txt\";\n            var utf16_le_path = @\"C:\\Users\\liu\\Documents\\utf-16 be.txt\";\n            var utf16_be_path = @\"C:\\Users\\liu\\Documents\\utf-16 le.txt\";\n\n            var utf8= BitConverter.ToString(File.ReadAllBytes(utf8_path));\n            Console.WriteLine(\"utf8 无bom: \"+utf8 +\"\\n\");\n\n            var utf8_bom= BitConverter.ToString(File.ReadAllBytes(utf8_bom_path));\n            Console.WriteLine(\"utf8 有bom: \"+utf8_bom + \"\\n\");\n\n            var utf16_le= BitConverter.ToString(File.ReadAllBytes(utf16_le_path));\n            Console.WriteLine(\"utf-16 be大端: \"+utf16_le + \"\\n\");\n\n            var utf16_be = BitConverter.ToString(File.ReadAllBytes(utf16_be_path));\n            Console.WriteLine(\"utf-16 le小端: \"+utf16_be + \"\\n\");\n        }\n</code></pre>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h1 id=\"为什么utf-8不需要bom\">为什么UTF-8不需要BOM</h1>\n<p>BOM的本质是为了解决UTF-16/32大小端歧义的问题，而UTF8的编码特性<code>从根本上解决了BOM要处理问题</code>，所以BOM对UTF-8而言既无必要，而且还属于\"额外附加\"的内容。</p>\n<h2 id=\"utf-1632为什么需要\">UTF-16/32为什么需要</h2>\n<p>假如我要传输一个字符串“中“，Unicode编码：U+4E2D，在我传输给你的过程中，它可以是FE-FF-4E-2D（大端），也可以是FF-FE-2D-4E(小端)，如果我没有标识字节顺序，你如何解析？</p>\n<h2 id=\"utf-8-核心编码规则\">UTF-8 核心编码规则</h2>\n<p>要想知道为什么UTF-8不需要BOM，先从它的原理开始说起。</p>\n<ol>\n<li>可变长编码<br />\n用1-4个字节表示一个Unicode字符，码点越小，占用的字节数越小。</li>\n<li>标准的字节格式<br />\n每个字符的起始字节，会有一个<code>特殊标识</code>来表示该字符占用的总字节数，后续的字节用<code>固定格式</code>来表示，相当于有一个标准模板来定义UTF-8字符。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字符占用字节数</th>\n<th>起始字节二进制格式</th>\n<th>续字节二进制格式</th>\n<th>可表示的Unicode码点范围</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1字节</td>\n<td><code>0xxxxxxx</code></td>\n<td>无续字节</td>\n<td><code>U+0000</code> ~ <code>U+007F</code></td>\n<td>对应ASCII字符</td>\n</tr>\n<tr>\n<td>2字节</td>\n<td><code>110xxxxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td><code>U+0080</code> ~ <code>U+07FF</code></td>\n<td>欧洲、中东等字符</td>\n</tr>\n<tr>\n<td>3字节</td>\n<td><code>1110xxxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td><code>U+0800</code> ~ <code>U+FFFF</code></td>\n<td>中文、日文、韩文等常用字符</td>\n</tr>\n<tr>\n<td>4字节</td>\n<td><code>11110xxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td><code>U+10000</code> ~ <code>U+10FFFF</code></td>\n<td>罕见字符、emoji等</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"眼见为实以中举例\">眼见为实，以\"中\"举例</h3>\n<ol>\n<li>确定字节数<br />\n\"中\"这个字符的码点为<code>U+4E2D</code>，在<code>U+0800~U+FFFF</code>范围内，占用 3 字节。</li>\n<li>十六进制转换成二进制<br />\n<code>4E2D</code>转成二进制，得到<code>0100 1110 0010 1101</code><br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n<li>按照UTF-8模板格式填充<br />\n已知占用3字节，模板格式为：<code>1110xxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code> (起始字节+2个续字节)<br />\n-----------得到UTF-8编码<code>11100100</code> <code>10111000</code> <code>10101101</code></li>\n<li>二进制转换成十六进制<br />\n<code>11100100</code> =&gt; <code>0xE4</code><br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<code>10111000</code> =&gt; <code>0xB8</code><br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<code>10101101</code> =&gt; <code>0xAD</code><br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n</ol>\n<p>最终\"中\"这个字符的UTF-8编码序列是<code>E4 B8 AD</code> ，也就是我们日常中经常看到的UTF-8 十六进制表示<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"眼见为实以a举例\">眼见为实，以\"A\"举例</h3>\n<ol>\n<li>确定字节数<br />\n\"A\"的码点为<code>U+0041</code>，在<code>U+0000~U+007F</code>访问内，占用1字节。</li>\n<li>十六进制转换成二进制<br />\n<code>0041</code>转成二进制，得到<code>0100 0001</code><br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n<li>按照UTF-8模板格式填充<br />\n1字节的模板格式为:<code>0xxxxxxx</code> (起始字节)<br />\n----得到UTF-8编码:<code>01000001</code></li>\n<li>二进制转换成十六进制<br />\n实际上又转换回来，又变回了<code>0041</code>。</li>\n</ol>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<blockquote>\n<p>UTF-8 以一种很<code>偷鸡又巧妙</code>的办法 ，实现了与ASCII的兼容。<br />\n因为ASCII只占用7bit，最高位默认为0，而UTF-8，1字节的模板也是0xxxxxxx ，从而实现了与ASCII的兼容</p>\n</blockquote>\n<h2 id=\"回到主题\">回到主题</h2>\n<ol>\n<li>\n<p>UTF-8 不存在大小端问题<br />\n由于UTF-8的可变长编码与标准的字节格式，所以每个字符的格式是固定的，有明确的先后顺序。<br />\n比如\"中\"的U+4E2D，UTF-8编码是<code>E4-B8-AD</code>， 这三个字节的顺序是唯一且固定的，解析时如果顺序颠倒，就会解析失败，所以不用管大端还是小端，严格按照顺序解析即可。</p>\n</li>\n<li>\n<p>UTF-8能够自我解析/识别，无需BOM作为签名<br />\nBOM 还有一个附加作用：作为文件编码的 “签名”，帮助软件快速识别 Unicode 编码格式。但对于 UTF-8 而言，这种 “签名” 也是多余的。<br />\n因为解析软件可以通过扫描文本的二进制内容，根据UTF-8的格式规则，（上面提到的<code>0xxxxxxx</code>、<code>110xxxxx</code>等），直接判断文件是否为 UTF-8 编码，无需依赖文件开头的 BOM 标记</p>\n</li>\n</ol>\n<h1 id=\"为什么有utf-8-bom的存在\">为什么有UTF-8 BOM的存在？</h1>\n<p>UTF-8 BOM并非Unicode官方标准，而是微软为<code>解决兼容问题而留下的历史包袱</code>。<br />\n早期的Windows默认编码是 <strong>本地化ANSI</strong>，它是Windows早期为适配本地语言设计的历史编码方案，它千好万好，为windows全球化立下了汗马功劳，但有一个致命的缺点，<code>文件开头没有任何特殊标识</code>。</p>\n<blockquote>\n<p>比如中文系统默认 GBK/GB2312，英文系统默认 ISO-8859-1，日文系统默认 Shift_JIS—— 这些 ANSI 编码都是无标记的多字节编码，和 UTF-8 一样，文件开头没有任何特殊标识。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n</blockquote>\n<h2 id=\"眼见为实-1\">眼见为实</h2>\n<p>比如用户在记事本中写了字符\"中\"，保存为 UTF-8（无 BOM），下次打开时，记事本没有任何标记可以判断这是 UTF-8，可能会按照<strong>系统ANSI</strong> ，比如GBK来解析，导致出现乱码。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<h1 id=\"为什么中文在utf-16下占用2字节反而在utf-8中占用3字节了\">为什么中文在UTF-16下占用2字节，反而在UTF-8中占用3字节了？</h1>\n<p><strong>简单来说，就是运气问题，UTF-8 的字节数是按码点容量分层设计的，中文的码点大小决定了它只能落在 3 字节区间。</strong><br />\n我们日常使用的 99% 以上的中文，码点都在BMP 平面的<code>U+4E00（一）~U+9FA5（龥）</code> 区间，<br />\n而UTF-16的编码规则是，对BMP平面字符直接<code>用2字节编码</code>,对SMP平面<code>用4字节编码</code>。而<code>刚好落在BMP的中文码点</code>自然而然的就使用2字节编码<br />\n但UTF-8的编码规则是根据Unicode 码点的大小来决定字节数，而中文的<code>U+4E00~U+9FA5</code> 刚好落在了<code>U+0800 ~ U+FFFF</code>这个3字节码点的区间内，因此要遵守3字节编码的规则。</p>\n<h2 id=\"为什么utf-8不把中文设计为2字节\">为什么UTF-8不把中文设计为2字节？</h2>\n<p>主要是2字节的UTF-8区间<code>U+0080 ~ U+07FF</code>容量有限，装不下这么多中文。<br />\n2字节的UTF-8 去掉前面的110，10 标识位，只剩下5+6=11位的有效容量，只能表示2^11=2048个码点，容纳不下中文。只有3字节的有效容量是4+6+6=16 ，可以表示2^16=65536个码点，刚好覆盖整个 BMP 平面，足以容纳所有中文常用字。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 16:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lmy5215006\">叫我安不理</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "吴恩达深度学习课程五：自然语言处理  第三周：序列模型与注意力机制（四）语音识别和触发字检测",
      "link": "https://www.cnblogs.com/Goblinscholar/p/19569924",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Goblinscholar/p/19569924\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 16:03\">\n    <span>吴恩达深度学习课程五：自然语言处理  第三周：序列模型与注意力机制（四）语音识别和触发字检测</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>此分类用于记录吴恩达深度学习课程的学习笔记。<br />\n课程相关信息链接如下：</p>\n<ol>\n<li>原课程视频链接：<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?buvid=XU762317353676D786954061C192FE625463B&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=zqernykrmpf7XfIorMR%2FnA%3D%3D&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=ce0bc526-db69-428a-962e-c65ed8c267bc&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1713085655&amp;unique_k=DfBgvFW&amp;up_id=8654113&amp;vd_source=e035e9878d32f414b4354b839a4c31a4\" rel=\"noopener nofollow\" target=\"_blank\">[双语字幕]吴恩达深度学习deeplearning.ai</a></li>\n<li>github课程资料，含课件与笔记:<a href=\"https://github.com/robbertliu/deeplearning.ai-andrewNG\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习教学资料</a></li>\n<li>课程配套练习（中英）与答案：<a href=\"https://blog.csdn.net/u013733326/article/details/79827273\" rel=\"noopener nofollow\" target=\"_blank\">吴恩达深度学习课后习题与答案</a></li>\n</ol>\n<p>本篇为第五课第三周的内容，<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=181\" rel=\"noopener nofollow\" target=\"_blank\">3.9</a>到<a href=\"https://www.bilibili.com/video/BV1FT4y1E74V?spm_id_from=333.788.videopod.episodes&amp;vd_source=e035e9878d32f414b4354b839a4c31a4&amp;p=182\" rel=\"noopener nofollow\" target=\"_blank\">3.10</a>的内容，同时也是本周理论部分的最后一篇。</p>\n<hr />\n<p>本周为第五课的第三周内容，与 CV 相对应的，这一课所有内容的中心只有一个：<strong>自然语言处理（Natural Language Processing，NLP）</strong>。<br />\n应用在深度学习里，它是专门用来进行<strong>文本与序列信息建模</strong>的模型和技术，本质上是在全连接网络与统计语言模型基础上的一次“结构化特化”，也是人工智能中<strong>最贴近人类思维表达方式</strong>的重要研究方向之一。<br />\n<strong>这一整节课同样涉及大量需要反复消化的内容，横跨机器学习、概率统计、线性代数以及语言学直觉。</strong><br />\n语言不像图像那样“直观可见”，更多是抽象符号与上下文关系的组合，因此<strong>理解门槛反而更高</strong>。<br />\n因此，我同样会尽量补足必要的背景知识，尽可能用比喻和实例降低理解难度。<br />\n本周的内容关于<strong>序列模型和注意力机制</strong>，这里的序列模型其实是<strong>指多对多非等长模型</strong>，这类模型往往更加复杂，其应用领域也更加贴近工业和实际，自然也会衍生相关的模型和技术。而注意力机制则让模型在长序列中学会主动分配信息权重，而不是被动地一路传递。二者结合，为 Transformer 等现代架构奠定了基础。</p>\n<p>本篇的内容关于<strong>语音识别和触发字检测</strong>，是 seq2seq 模型在音频数据上的应用。</p>\n<h1 id=\"1-音频数据audio-data\">1. 音频数据（Audio data）</h1>\n<p>音频数据虽然和文本数据同样都为序列数据，但是如果我们希望实现相关的应用，所寻找到的数据集样本往往都是<strong>一段段连续的录音</strong>，无法直接输入模型。<br />\n因此，就像为文本数据构建词典一样，在使用 seq2seq 模型完成在语音领域的任务时，我们同样需要对音频数据进行预处理，而这就涉及到音频数据本身的特点。</p>\n<h2 id=\"11-音位phoneme\">1.1 音位（Phoneme）</h2>\n<p>在展开音频数据的预处理方式之前，有必要先引入一个语言学中的概念：<strong>音位（phoneme）</strong>。</p>\n<p>音位是一种<strong>抽象的语音单位</strong>，其定义并非基于声学相似性，而是基于<strong>是否能够区分词义</strong>。<br />\n在某一语言中，如果两个发音单元的替换会导致词义变化，它们就属于不同的音位；反之，即使在物理发音上存在差异，只要不影响词义，它们仍被视为同一音位。<br />\n换句话说，音位关心的是<strong>语言系统内部能区分意义的功能</strong>，而不是具体的发音表现。</p>\n<p>通过大量对比，语言学家逐步归纳出某一语言的音位系统。<strong>在英语中，音位通常借助音标来表示，但音标与音位又并不等同</strong>：音标只是描述发音的工具，而音位是一种功能性分类结果。同一个音位在不同语音环境中可能呈现略有不同的实际发音形式（如口音差异），但只要这些差异不承担区分语义的功能，它们仍被视为同一音位的不同实现。<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202602/3708248-20260203155945196-1250283629.png\" /><br />\n这便是音位的基本概念，到这里，一个自然而然的想法就是<strong>把音频数据处理为连续的音位序列</strong>，就像文本数据一样进行处理输入模型。<br />\n然而，我们刚刚也提到了，音位虽然可以代表语义，但是<strong>这是我们人为归纳的特征而不是音频本身的属性</strong>。因此，在实验中，<strong>音位并不是可以直接从连续的音频波形中观测得到的量</strong>。<br />\n其获取过程高度依赖<strong>人工标注</strong>、规则设计或复杂的对齐模型，这也在实践中限制了其作为模型直接输入的可行性。<br />\n这一现实，直接推动了后续更偏向信号层面的语音表示方法的发展，也为声谱图等特征形式的广泛应用奠定了背景。</p>\n<h2 id=\"12-声谱图spectrogram\">1.2 声谱图（Spectrogram）</h2>\n<p>由于音位是人为抽象的单位，无法直接从连续的音频波形中观测得到，因此在实际语音处理与建模中，我们更倾向于使用<strong>信号层面的连续特征表示</strong>，其中最常用的表示方式之一就是<strong>声谱图（spectrogram）</strong>。</p>\n<p>声谱图是一种将音频信号在<strong>时间与频率域</strong>上进行表示的二维图像。<br />\n简单来说，它将连续的音频波形分割为短时片段，并对每个片段计算频谱能量，从而得到<strong>时间-频率矩阵</strong>，矩阵中的每个值反映该时刻该频率成分的强度，就像这样：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202602/3708248-20260203155952737-472972628.png\" /></p>\n<p>通过这种方式，原本<strong>连续的波形被转换为一组能够揭示语音细节的特征</strong>，既保留了声音的动态变化，也便于计算机处理。<br />\n在计算机处理时，声谱图的每一列包含该时间片段所有频率的能量值，可以看作一个多维向量。因此，我们通常<strong>把声谱图的每一列视为一个时间步的输入向量</strong>。<br />\n这样，原本二维的时间-频率矩阵就被转化为<strong>时间序列的特征向量序列</strong>，与文本序列类似，使模型能够在连续语音中捕捉语义和声学模式。</p>\n<p>声谱图的关键优势在于<strong>无需人工标注音位的同时保留了丰富的声学信息，并且其二维矩阵形式可以直接作为模型输入</strong>，实现端到端语音识别、声学建模或语音生成。<br />\n了解了对音频数据的基本处理逻辑后，现在就来看看其应用：</p>\n<h1 id=\"2-语音识别speech-recognition\">2. 语音识别（Speech Recognition）</h1>\n<p>对音频数据最常见的应用领域就是语音识别。生活中，我们最常用的例子可能是微信的语音转文字，也包括语音助手、电话客服的语音输入等。<br />\n语音识别的核心任务是<strong>将连续的音频信号映射为文字序列</strong>。由于音频本身是连续信号，而文字序列是离散符号序列，因此，这一任务本质上也是一个 <strong>seq2seq 问题</strong>。<br />\n一个主流且常见的训练方式就是应用我们刚刚介绍的带<a href=\"https://www.cnblogs.com/Goblinscholar/p/19563950\" target=\"_blank\">注意力机制</a>的编码解码框架：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202602/3708248-20260203155927580-326667711.png\" /><br />\n此外，还存在一种独特的技术，我们称为 <strong>CTC（Connectionist Temporal Classification）</strong> 。<br />\nCTC 是一种<strong>专门用于处理输入输出长度不匹配的序列学习方法</strong>，非常适合语音识别这样的任务。它的核心思想是：<strong>允许模型在连续的时间步上输出“空白”或重复符号，从而自动对齐输入序列与输出序列</strong>。<br />\n它提出于 06 年的一篇论文：<a href=\"https://sferics.idsia.ch/pub/juergen/icml2006.pdf\" rel=\"noopener nofollow\" target=\"_blank\">Connectionist Temporal Classification: Labelling Unsegmented Sequence Data with Recurrent Neural Networks</a><br />\n可以发现，CTC 的提出较早，因此也并没有使用编码解码框架，而是<strong>等长多对多模型</strong>框架。不过如今 CTC 也并没有被完全淘汰，它仍常见于一些混合方案中。<br />\n我们简单展开如下：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202602/3708248-20260203155951242-1300096674.png\" /><br />\n再复述一下其核心思想： CTC 通过引入 <strong>blank（空白）符号</strong> 和 <strong>重复合并规则</strong> 来对齐输入与输出，来实现端到端训练，无需在标签中人工对齐每一帧。<br />\n当然，你也会发现它对长距离依赖建模能力有限，对长句子性能很大可能不如注意力机制，了解即可。</p>\n<h1 id=\"3-触发字检测trigger-word-detection--keyword-spotting\">3. 触发字检测（Trigger Word Detection / Keyword Spotting）</h1>\n<p>对于触发字检测我们也并不陌生，生活中最常见的例子包括语音助手的唤醒词“Hey Siri”“小爱同学”“Alexa”，只有检测到这些触发词后，设备才会进入完整语音识别流程。</p>\n<p>不同于语音识别，触发字检测任务更为精简，它在建模中关注的问题是：<strong>在连续语音流中，判断某个特定关键词是否被说出，以及它出现的大致时间位置。</strong><br />\n因此，一个关键点在于：<strong>触发字检测模型因其实时性更适合多对多等长模型，模型每个时间帧预测一个触发概率或二分类信号，表示当前帧是否属于触发词的一部分。</strong><br />\n简单展开如下：<br />\n<img alt=\"image.png\" src=\"https://img2024.cnblogs.com/blog/3708248/202602/3708248-20260203155928163-1676940697.png\" /><br />\n传播过程并不复杂，但有一点需要注意：<strong>触发字检测的任务特征决定了其数据往往是不平衡的</strong>，即绝大多数标签都为 0 ，这导致即使模型全部输出 0 ，也能得到较好的指标，从而导致错误判断和部署。<br />\n对此，一种常用缓解策略是<strong>扩展正样本标签</strong>：不仅将触发词对应的帧标记为 1，还将其之后若干帧也标记为 1，形成一个时间段的正样本窗口，这既平衡了样本，也符合实际触发的延迟容忍需求。</p>\n<p>总结来说，触发字检测本质是<strong>低延迟的序列二分类任务</strong>。建模逻辑为：<strong>先将音频转化为时间序列特征，再利用多对多等长模型预测每一帧的触发概率，也可通过平滑或滑窗处理得到最终触发决策</strong>。</p>\n<h1 id=\"4总结\">4.总结</h1>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>原理</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>音位（Phoneme）</strong></td>\n<td>语言学中的抽象单位，基于是否能区分词义进行分类；同一音位在不同环境下可有不同发音，但功能相同。</td>\n<td>就像文字中的字母，不同字母组合产生不同单词，但同一字母在不同字体中仍表示相同字母。</td>\n</tr>\n<tr>\n<td><strong>声谱图（Spectrogram）</strong></td>\n<td>将音频分帧并计算每帧的频谱能量，得到时间-频率矩阵；每列作为时间步输入向量，用于模型训练。</td>\n<td>好比把连续的声音切成一格格“照片”，每格显示不同频率的亮度，连续播放形成动态影像。</td>\n</tr>\n<tr>\n<td><strong>语音识别（Speech Recognition）</strong></td>\n<td>将连续音频信号映射为文字序列，可用注意力编码解码框架处理 seq2seq 问题，也可用 CTC 进行端到端训练。</td>\n<td>就像把一段连续的河流水流（声音波形）逐段翻译成文字，注意力机制像有导游指引每段对应文字，CTC像自动对齐标记。</td>\n</tr>\n<tr>\n<td><strong>CTC（Connectionist Temporal Classification）</strong></td>\n<td>输入为时间序列特征；允许输出空白符和重复符号，通过合并规则对齐输出序列；无需逐帧标注。</td>\n<td>好比在长河上放置浮标（空白符），只标记关键节点，最后整理成整段文字。</td>\n</tr>\n<tr>\n<td><strong>触发字检测（Trigger Word Detection / Keyword Spotting）</strong></td>\n<td>输入音频转时间序列特征；多对多等长模型预测每帧触发概率；可通过标签扩展、平滑或滑窗处理缓解数据不平衡。</td>\n<td>就像警报系统监测连续流水声，只在听到特定声响（触发词）后报警，而非逐秒记录每滴水。</td>\n</tr>\n</tbody>\n</table>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 16:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Goblinscholar\">哥布林学者</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Qt 技巧笔记 (五) Qt消息框（QMessageBox）的全面使用指南",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19569909",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19569909\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 15:55\">\n    <span>Qt 技巧笔记 (五) Qt消息框（QMessageBox）的全面使用指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"qt-技巧笔记-五---qt消息框qmessagebox的全面使用指南\">Qt 技巧笔记 (五)   Qt消息框（QMessageBox）的全面使用指南</h1>\n<p>​       在Qt框架开发中，消息框组件(QMessageBox) 是处理用户交互的核心工具。本笔记系统梳理了QMessageBox的6种预定义类型，静态调用与实例化调用的对比，自定义实现方法及常见问题解决方案，帮助开发者实现用户提示功能。</p>\n<p>​       <code>QMessageBox</code>是Qt中用于<strong>弹出对话框消息</strong>的类，继承于<span class=\"math inline\">\\(QDialog\\)</span>，常用于提示消息、警告、错误、确认等场景，是Qt GUI应用开发中非常常用的组件之一。用于弹出一个模式对话框（模态窗口），显示消息给用户，并等待用户点击按钮（如“确定”、\"取消\"、”是“、“否”等）后再继续程序执行。其核心特征是<strong>阻塞交互式</strong>，用户必须响应对话框（点击按钮）后，程序才会继续执行后续代码。</p>\n<p>​</p>\n<h2 id=\"11-预定义消息框类型\">1.1 预定义消息框类型</h2>\n<p>Qt提供6种标准消息类型，通过静态方法快速调用：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>调用方法</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>消息提示框</td>\n<td><code>QMessageBox::information()</code></td>\n<td>普通信息展示</td>\n</tr>\n<tr>\n<td>警告提示框</td>\n<td><code>QMessageBox::warning()</code></td>\n<td>操作风险警示</td>\n</tr>\n<tr>\n<td>错误提示框</td>\n<td><code>QMessageBox::critical()</code></td>\n<td>严重错误警示</td>\n</tr>\n<tr>\n<td>确认选择框</td>\n<td><code>QMessageBox::question()</code></td>\n<td>二选一决策</td>\n</tr>\n<tr>\n<td>关于对话框</td>\n<td>QMessageBox::about()</td>\n<td>应用信息扩展</td>\n</tr>\n<tr>\n<td>版本信息框</td>\n<td>QMessageBox::aboutQt()</td>\n<td>Qt版本说明</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>其典型调用案例：</p>\n<p>1.显示信息提示框（information）</p>\n<pre><code class=\"language-C++\">QMessageBox::information(this, \"标题\", \"这是一个信息提示框\");\n</code></pre>\n<p>2.警告窗（warning）</p>\n<pre><code class=\"language-C++\">QMessageBox::warning(this,\"警告\",\"这是一个警告框\");\n</code></pre>\n<p>3.错误框（critial）</p>\n<pre><code class=\"language-C++\">QMessageBox::critical(this,\"错误\",\"出现了严重的错误\");\n</code></pre>\n<p>4.提问框（question）</p>\n<pre><code class=\"language-C++\">    int ret = QMessageBox::question(nullptr, (\"MyNoteBook Notice:\"),\n                                    (\"The document has been modified.\\n\"\n                                     \"Do you want to save your changes?\"),\n                                    QMessageBox::Save | QMessageBox::Discard\n                                    | QMessageBox::Cancel, /*按钮的属性*/\n                                    QMessageBox::Save); /*默认按钮按下*/\n    switch (ret)\n    {\n    case QMessageBox::Save:\n        qDebug()&lt;&lt;\"QMessageBox::Save\";\n        break;\n    case QMessageBox::Discard:\n        qDebug()&lt;&lt;\"QMessageBox::Discard\";\n        break;\n    case QMessageBox::Cancel:\n        qDebug()&lt;&lt;\"QMessageBox::Cancel\";\n        break;\n     default:\n        break;\n    }\n</code></pre>\n<p>其中按钮类型（QMessage::StandardButton）</p>\n<table>\n<thead>\n<tr>\n<th>按钮枚举值</th>\n<th>显示内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>QMessageBox::Ok</code></td>\n<td>确定</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Cancel</code></td>\n<td>取消</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Yes</code></td>\n<td>是</td>\n</tr>\n<tr>\n<td><code>QMessageBox::No</code></td>\n<td>否</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Abort</code></td>\n<td>终止</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Retry</code></td>\n<td>重试</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Ignore</code></td>\n<td>忽略</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"12-静态调用与实例化调用对比\">1.2 静态调用与实例化调用对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>静态调用</th>\n<th>实例化调用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>语法形式</td>\n<td><code>QMessageBox::type(parent, ...)</code></td>\n<td><code>QMessageBox box; box.setXXX(...)</code></td>\n</tr>\n<tr>\n<td>定制能力</td>\n<td>仅支持预设按钮/图标</td>\n<td>支持完整UI定制</td>\n</tr>\n<tr>\n<td>线程阻塞</td>\n<td>自动模态显示</td>\n<td>需手动调用exec()</td>\n</tr>\n<tr>\n<td>典型场景</td>\n<td>快速实现简单提示</td>\n<td>复杂交互需求</td>\n</tr>\n</tbody>\n</table>\n<p>其中图标定制类型如下：</p>\n<table>\n<thead>\n<tr>\n<th>图标类型</th>\n<th>含   义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>QMessageBox::NoIcon</code></td>\n<td>无图标</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Information</code></td>\n<td>信息图标（ℹ️）</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Warning</code></td>\n<td>警告图标（⚠）</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Critical</code></td>\n<td>错误图标（❌）</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Question</code></td>\n<td>问号图标（❓）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"13-深度定制实现方案\">1.3 深度定制实现方案</h2>\n<p>对话框的关键定制方法：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>功能说明</th>\n<th>参数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>setWindowTitle()</code></td>\n<td>设置对话框标题</td>\n<td><code>QString</code></td>\n</tr>\n<tr>\n<td><code>setText()</code></td>\n<td>设置主提示文本</td>\n<td><code>QString</code></td>\n</tr>\n<tr>\n<td>setIconPixmap()</td>\n<td>设置自定义图标</td>\n<td>QPixmap</td>\n</tr>\n<tr>\n<td>addButton()</td>\n<td>添加自定义按钮</td>\n<td>(QString, ButtonRole)</td>\n</tr>\n<tr>\n<td>setStyleSheet()</td>\n<td>应用CSS样式</td>\n<td>QString</td>\n</tr>\n</tbody>\n</table>\n<p>完整自定义示例：</p>\n<pre><code class=\"language-C++\">#include &lt;QMessageBox&gt;\n#include &lt;QPushButton&gt;\n#include &lt;QDebug&gt;\n\nvoid showCustomMessageBox() {\n    QMessageBox box;\n    box.setWindowTitle(\"自定义对话框\");\n    box.setText(\"请确认操作：\");\n    \n    // 添加自定义按钮\n    QPushButton *confirmBtn = box.addButton(\"确认\", QMessageBox::AcceptRole);\n    QPushButton *cancelBtn = box.addButton(\"取消\", QMessageBox::RejectRole);\n    \n    // 设置图标（支持缩放）\n    box.setIconPixmap(QPixmap(\":/icons/warning.png\").scaled(64, 64));\n    \n    // 样式定制\n    box.setStyleSheet(\n        \"QMessageBox { background-color: #f0f0f0; font-size: 14px; }\"\n        \"QPushButton { min-width: 80px; min-height: 30px; }\"\n    );\n    \n    box.exec();\n    \n    if (box.clickedButton() == confirmBtn) {\n        qDebug() &lt;&lt; \"用户点击了确认\";\n    } else {\n        qDebug() &lt;&lt; \"用户点击了取消\";\n    }\n}\n</code></pre>\n<h2 id=\"14-高级应用场景\">1.4 高级应用场景</h2>\n<p><strong>动态内容切换</strong></p>\n<pre><code class=\"language-C++\">void showDynamicMessage(bool isSuccess) {\n    QMessageBox box;\n    box.setWindowTitle(isSuccess ? \"操作结果\" : \"错误提示\");\n    box.setText(isSuccess ? \"操作成功完成\" : \"操作失败，请重试\");\n    box.setIcon(isSuccess ? QMessageBox::Information : QMessageBox::Critical);\n    box.exec();\n}\n</code></pre>\n<p><strong>多语言支持</strong></p>\n<pre><code class=\"language-C++\">void showLocalizedMessage(QLocale locale) {\n    QMessageBox box;\n    if (locale == QLocale::Chinese) {\n        box.setWindowTitle(\"提示\");\n        box.setText(\"确定要执行此操作吗？\");\n    } else {\n        box.setWindowTitle(\"Warning\");\n        box.setText(\"Are you sure to proceed?\");\n    }\n    box.exec();\n}\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 15:55</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">34</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "asp.net core如何实现Controller热更新",
      "link": "https://www.cnblogs.com/kevin-Y/p/19569791",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kevin-Y/p/19569791\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 15:41\">\n    <span>asp.net core如何实现Controller热更新</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>可能是以往的习惯，我希望生产环境的服务可以热更新。有人会说Docker，可我希望能更简单一些。所以一直关注asp.net core如何热更新</p>\n<p>早前读过这文章，工作关系没有继续学习。今天遇到一个关键问题，还是这文章启发了我。</p>\n<p><a href=\"https://www.cnblogs.com/artech/p/dynamic-controllers.html\" target=\"_blank\">https://www.cnblogs.com/artech/p/dynamic-controllers.html</a></p>\n<p>第一步，dll需要在使用后，依然可以被修改和替换。我们需要一个继承自AssemblyLoadContext的类</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_358157ef-9bd8-48a3-99bd-62e649904895\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_358157ef-9bd8-48a3-99bd-62e649904895\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_358157ef-9bd8-48a3-99bd-62e649904895\">\n<pre><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 支持真正卸载的插件加载上下文\n</span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> CollectiblePluginLoadContext : AssemblyLoadContext\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> _pluginPath;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span>?<span style=\"color: rgba(0, 0, 0, 1);\"> _pluginDirectory;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> CollectiblePluginLoadContext(<span style=\"color: rgba(0, 0, 255, 1);\">string</span> pluginPath) : <span style=\"color: rgba(0, 0, 255, 1);\">base</span>(isCollectible: <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        _pluginPath </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> pluginPath;\n        _pluginDirectory </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Path.GetDirectoryName(pluginPath);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">protected</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> Assembly?<span style=\"color: rgba(0, 0, 0, 1);\"> Load(AssemblyName assemblyName)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 尝试从插件目录加载依赖项</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.IsNullOrEmpty(_pluginDirectory))\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> assemblyPath = Path.Combine(_pluginDirectory, assemblyName.Name + <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">.dll</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            \n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (File.Exists(assemblyPath))\n            {\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用流加载避免锁定依赖DLL文件</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span> fileStream = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> FileStream(assemblyPath, FileMode.Open, FileAccess.Read, FileShare.Read);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> LoadFromStream(fileStream);\n            }\n        }\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 如果在插件目录中找不到，则返回null，让默认上下文处理</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">protected</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> IntPtr LoadUnmanagedDll(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> unmanagedDllName)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 尝试从插件目录加载非托管DLL</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.IsNullOrEmpty(_pluginDirectory))\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> unmanagedDllPath = Path.Combine(_pluginDirectory, unmanagedDllName + <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">.dll</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            \n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (File.Exists(unmanagedDllPath))\n            {\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对于非托管DLL，仍然需要使用路径加载\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 但可以在加载后立即关闭句柄以减少锁定</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> LoadUnmanagedDllFromPath(unmanagedDllPath);\n            }\n        }\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 如果在插件目录中找不到，则返回零，让默认上下文处理</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> IntPtr.Zero;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> Assembly LoadPluginAssembly()\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用流加载避免锁定DLL文件</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span> fileStream = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> FileStream(_pluginPath, FileMode.Open, FileAccess.Read, FileShare.Read);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> LoadFromStream(fileStream);\n    }\n}</span></pre>\n</div>\n<span class=\"cnblogs_code_collapse\">CollectiblePluginLoadContext </span></div>\n<p>第二步，ApplicationPartManager添加动态加载的Assembly。</p>\n<p>一开始我以为加入前移除就能完整热加载</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 从应用部件管理器中移除程序集</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> partToRemove =<span style=\"color: rgba(0, 0, 0, 1);\"> _partManager.ApplicationParts\n    .OfType</span>&lt;AssemblyPart&gt;<span style=\"color: rgba(0, 0, 0, 1);\">()\n    .FirstOrDefault(p </span>=&gt; p.Assembly ==<span style=\"color: rgba(0, 0, 0, 1);\"> assembly);\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (partToRemove != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n{\n    _partManager.ApplicationParts.Remove(partToRemove);\n}<br /></span></pre>\n<pre>// 将程序集添加到应用部件管理器\nvar assemblyPart = new<span> AssemblyPart(assembly);\n_partManager.ApplicationParts.Add(assemblyPart);</span></pre>\n</div>\n<p>实际上不能，如一开头的文章说到的</p>\n<div class=\"cnblogs_code\">\n<pre>...但是MVC默认情况下对提供的ActionDescriptor对象进行了缓存。<br />如果框架能够使用新的ActionDescriptor对象，需要告诉它当前应用提供的ActionDescriptor列表发生了改变，而这可以利用自定义的IActionDescriptorChangeProvider来实现。<br />为此我们定义了如下这个DynamicChangeTokenProvider类型，该类型实现了IActionDescriptorChangeProvider接口，并利用GetChangeToken方法返回IChangeToken对象通知<br />MVC框架当前的ActionDescriptor已经发生改变。从实现实现代码可以看出，当我们调用NotifyChanges方法的时候，状态改变通知会被发出去。</pre>\n</div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> DynamicChangeTokenProvider : IActionDescriptorChangeProvider\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> CancellationTokenSource _source;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> CancellationChangeToken _token;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> DynamicChangeTokenProvider()\n    {\n        _source </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> CancellationTokenSource();\n        _token </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> CancellationChangeToken(_source.Token);\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> IChangeToken GetChangeToken() =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> _token;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> NotifyChanges()\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> old = Interlocked.Exchange(<span style=\"color: rgba(0, 0, 255, 1);\">ref</span> _source, <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> CancellationTokenSource());\n        _token </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> CancellationChangeToken(_source.Token);\n        old.Cancel();\n    }\n}</span></pre>\n</div>\n<p>有了蒋金楠（大内老A）的上面的代码，事情就好办了。以下是我的Program.cs的主要代码</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 添加MVC服务以支持动态控制器</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">builder.Services.AddControllers();\n\nbuilder.Services.AddSingleton</span>&lt;DynamicChangeTokenProvider&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\nbuilder.Services.AddSingleton</span>&lt;IActionDescriptorChangeProvider&gt;(provider =&gt; provider.GetRequiredService&lt;DynamicChangeTokenProvider&gt;<span style=\"color: rgba(0, 0, 0, 1);\">());\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> app =<span style=\"color: rgba(0, 0, 0, 1);\"> builder.Build();</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 初始化改进的插件管理器（支持真正卸载）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> partManager = app.Services.GetRequiredService&lt;ApplicationPartManager&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> tokenProvider = app.Services.GetRequiredService&lt;DynamicChangeTokenProvider&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> improvedPluginManager = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ImprovedPluginManager(partManager, tokenProvider);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 预加载已存在的插件</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> improvedPluginManager.LoadAllPluginsAsync();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 映射控制器路由</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">app.MapControllers();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 默认根路径</span>\napp.MapGet(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, () =&gt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Dynamic Controller Demo Running!</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 重新加载所有插件端点</span>\napp.MapPost(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/reload-plugins</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(0, 0, 255, 1);\">async</span> () =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> improvedPluginManager.LoadAllPluginsAsync();\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Plugins reloaded with true unloading</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n});\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取已加载插件列表</span>\napp.MapGet(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/loaded-plugins</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, () =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> improvedPluginManager.GetLoadedPlugins();\n});</span></pre>\n</div>\n<p>好了。程序跑起来。主程序没有Controller的实现。程序提供的WebApi，由plugin目录中的dll所包含Controller决定。至此期待的url正常响应了。将新的dll拷贝到plugin目录，替换旧的，post一下</p>\n<pre>/reload-plugins</pre>\n<p>WebApi也被新的程序响应了。当然我们也可以监视一下plugin目录，有文件修改时自动加载。</p>\n<p>附上ImprovedPluginManager.cs的源代码</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_c74a20f6-a571-4d10-be21-2a34e693262f\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_c74a20f6-a571-4d10-be21-2a34e693262f\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_c74a20f6-a571-4d10-be21-2a34e693262f\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">  1</span> <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> ImprovedPluginManager\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  2</span> <span style=\"color: rgba(0, 0, 0, 1);\">{\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  3</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> ApplicationPartManager _partManager;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  4</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> Dictionary&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>, (CollectiblePluginLoadContext context, Assembly assembly)&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> _loadedPlugins;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  5</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> List&lt;PluginInfo&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> _pluginInfos;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  6</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> _pluginsDirectory;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  7</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> DynamicChangeTokenProvider _tokenProvider;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  8</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">  9</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> ImprovedPluginManager(ApplicationPartManager partManager, DynamicChangeTokenProvider tokenProvider)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 10</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 11</span>         _tokenProvider =<span style=\"color: rgba(0, 0, 0, 1);\"> tokenProvider;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 12</span>         _partManager =<span style=\"color: rgba(0, 0, 0, 1);\"> partManager;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 13</span>         _loadedPlugins = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Dictionary&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>, (CollectiblePluginLoadContext, Assembly)&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 14</span>         _pluginInfos = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;PluginInfo&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 15</span>         \n<span style=\"color: rgba(0, 128, 128, 1);\"> 16</span>         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设置插件目录</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 17</span>         _pluginsDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Plugins</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 18</span>         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">Directory.Exists(_pluginsDirectory))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 19</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 20</span> <span style=\"color: rgba(0, 0, 0, 1);\">            Directory.CreateDirectory(_pluginsDirectory);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 21</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 22</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 23</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 24</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> Task&lt;<span style=\"color: rgba(0, 0, 255, 1);\">bool</span>&gt; LoadPluginAsync(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> pluginPath)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 25</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 26</span>         <span style=\"color: rgba(0, 0, 255, 1);\">try</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 27</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 28</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">File.Exists(pluginPath))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 29</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 30</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> FileNotFoundException($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Plugin file not found: {pluginPath}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 31</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 32</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 33</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 检查文件扩展名</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 34</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!pluginPath.EndsWith(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">.dll</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, StringComparison.OrdinalIgnoreCase))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 35</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 36</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> ArgumentException(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Plugin must be a .dll file</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 37</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 38</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 39</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建可收集的加载上下文</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 40</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> loadContext = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> CollectiblePluginLoadContext(pluginPath);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 41</span>             \n<span style=\"color: rgba(0, 128, 128, 1);\"> 42</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 加载程序集</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 43</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> assembly =<span style=\"color: rgba(0, 0, 0, 1);\"> loadContext.LoadPluginAssembly();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 44</span>             \n<span style=\"color: rgba(0, 128, 128, 1);\"> 45</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取所有控制器类型</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 46</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> controllerTypes =<span style=\"color: rgba(0, 0, 0, 1);\"> assembly.GetTypes()\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 47</span>                 .Where(t =&gt; t.IsSubclassOf(<span style=\"color: rgba(0, 0, 255, 1);\">typeof</span>(ControllerBase)) &amp;&amp; !<span style=\"color: rgba(0, 0, 0, 1);\">t.IsAbstract)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 48</span> <span style=\"color: rgba(0, 0, 0, 1);\">                .ToList();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 49</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 50</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">controllerTypes.Any())\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 51</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 52</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> InvalidOperationException($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">No controllers found in plugin: {pluginPath}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 53</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 54</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 55</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 检查是否已经加载了相同的程序集</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 56</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (_loadedPlugins.ContainsKey(assembly.FullName))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 57</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 58</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> UnloadPluginAsync(assembly.FullName);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 59</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 60</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 61</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将程序集添加到应用部件管理器</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 62</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> assemblyPart = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AssemblyPart(assembly);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 63</span> <span style=\"color: rgba(0, 0, 0, 1);\">            _partManager.ApplicationParts.Add(assemblyPart);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 64</span>             \n<span style=\"color: rgba(0, 128, 128, 1);\"> 65</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 记录已加载的插件和上下文</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 66</span>             _loadedPlugins[assembly.FullName] =<span style=\"color: rgba(0, 0, 0, 1);\"> (loadContext, assembly);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 67</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 68</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建插件信息</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 69</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> pluginInfo = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> PluginInfo\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 70</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 71</span>                 Name =<span style=\"color: rgba(0, 0, 0, 1);\"> Path.GetFileNameWithoutExtension(pluginPath),\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 72</span>                 Version = assembly.GetName().Version?.ToString() ?? <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Unknown</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 73</span>                 Description = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Dynamic controller plugin</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 74</span>                 FilePath =<span style=\"color: rgba(0, 0, 0, 1);\"> pluginPath,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 75</span>                 LoadedAt =<span style=\"color: rgba(0, 0, 0, 1);\"> DateTime.Now,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 76</span>                 ControllerTypes = controllerTypes.Select(t =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> t.Name).ToList()\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 77</span> <span style=\"color: rgba(0, 0, 0, 1);\">            };\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 78</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 79</span> <span style=\"color: rgba(0, 0, 0, 1);\">            _pluginInfos.Add(pluginInfo);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 80</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 81</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Successfully loaded plugin: {pluginPath}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 82</span>             <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> controller <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> controllerTypes)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 83</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 84</span>                 Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  - Controller: {controller.Name}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 85</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 86</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 87</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 88</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 89</span>         <span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (Exception ex)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 90</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 91</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Failed to load plugin: {ex.Message}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 92</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 93</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 94</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 95</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 96</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> Task&lt;<span style=\"color: rgba(0, 0, 255, 1);\">bool</span>&gt; UnloadPluginAsync(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> assemblyFullName)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 97</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 98</span>         <span style=\"color: rgba(0, 0, 255, 1);\">try</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 99</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">100</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">_loadedPlugins.ContainsKey(assemblyFullName))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">101</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">102</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">103</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">104</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">105</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> (loadContext, assembly) =<span style=\"color: rgba(0, 0, 0, 1);\"> _loadedPlugins[assemblyFullName];\n</span><span style=\"color: rgba(0, 128, 128, 1);\">106</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">107</span>             \n<span style=\"color: rgba(0, 128, 128, 1);\">108</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 从应用部件管理器中移除程序集</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">109</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> partToRemove =<span style=\"color: rgba(0, 0, 0, 1);\"> _partManager.ApplicationParts\n</span><span style=\"color: rgba(0, 128, 128, 1);\">110</span>                 .OfType&lt;AssemblyPart&gt;<span style=\"color: rgba(0, 0, 0, 1);\">()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">111</span>                 .FirstOrDefault(p =&gt; p.Assembly ==<span style=\"color: rgba(0, 0, 0, 1);\"> assembly);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">112</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">113</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (partToRemove != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">114</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">115</span> <span style=\"color: rgba(0, 0, 0, 1);\">                _partManager.ApplicationParts.Remove(partToRemove);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">116</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">117</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">118</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 从已加载插件列表中移除</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">119</span> <span style=\"color: rgba(0, 0, 0, 1);\">            _loadedPlugins.Remove(assemblyFullName);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">120</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">121</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 从插件信息列表中移除</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">122</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> pluginInfo = _pluginInfos.FirstOrDefault(p =&gt; p.FilePath ==<span style=\"color: rgba(0, 0, 0, 1);\"> assembly.Location);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">123</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (pluginInfo != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">124</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">125</span> <span style=\"color: rgba(0, 0, 0, 1);\">                _pluginInfos.Remove(pluginInfo);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">126</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">127</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">128</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 卸载加载上下文</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">129</span> <span style=\"color: rgba(0, 0, 0, 1);\">            loadContext.Unload();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">130</span>             \n<span style=\"color: rgba(0, 128, 128, 1);\">131</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 强制垃圾回收以释放程序集</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">132</span> <span style=\"color: rgba(0, 0, 0, 1);\">            GC.Collect();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">133</span> <span style=\"color: rgba(0, 0, 0, 1);\">            GC.WaitForPendingFinalizers();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">134</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">135</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">=== UNLOAD DIAGNOSTICS ===</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">136</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Successfully unloaded plugin: {assemblyFullName}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">137</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Assembly location: {assembly.Location}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">138</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Loaded plugins count after unload: {_loadedPlugins.Count}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">139</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Plugin infos count after unload: {_pluginInfos.Count}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">140</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Application parts count after unload: {_partManager.ApplicationParts.Count}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">141</span>             Console.WriteLine(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">========================</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">142</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">143</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">144</span>         <span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (Exception ex)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">145</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">146</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Failed to unload plugin: {ex.Message}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">147</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">148</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">149</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">150</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">151</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span> List&lt;PluginInfo&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GetLoadedPlugins()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">152</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">153</span>         <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> _pluginInfos.ToList();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">154</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">155</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">156</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> Task&lt;List&lt;FileInfo&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> ScanPluginFilesAsync()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">157</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">158</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> pluginDirInfo = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> DirectoryInfo(_pluginsDirectory);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">159</span>         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">pluginDirInfo.Exists)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">160</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">161</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;FileInfo&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">162</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">163</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">164</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> dllFiles = pluginDirInfo.GetFiles(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">*.dll</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, SearchOption.AllDirectories);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">165</span>         <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> dllFiles.ToList();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">166</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">167</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">168</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> Task&lt;<span style=\"color: rgba(0, 0, 255, 1);\">bool</span>&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> LoadAllPluginsAsync()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">169</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">170</span>         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 先卸载所有已加载的插件</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">171</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> assembliesToUnload =<span style=\"color: rgba(0, 0, 0, 1);\"> _loadedPlugins.Keys.ToList();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">172</span>         <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> assemblyName <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> assembliesToUnload)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">173</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">174</span>             <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> UnloadPluginAsync(assemblyName);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">175</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">176</span>         \n<span style=\"color: rgba(0, 128, 128, 1);\">177</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> pluginFiles = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> ScanPluginFilesAsync();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">178</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> successCount = <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">179</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">180</span>         <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> pluginFile <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> pluginFiles)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">181</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">182</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (<span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> LoadPluginAsync(pluginFile.FullName))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">183</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">184</span>                 successCount++<span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">185</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">186</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">187</span> <span style=\"color: rgba(0, 0, 0, 1);\">        _tokenProvider.NotifyChanges();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">188</span>         Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Loaded {successCount} out of {pluginFiles.Count} plugins</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">189</span>         <span style=\"color: rgba(0, 0, 255, 1);\">return</span> successCount &gt; <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">190</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">191</span> }</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">ImprovedPluginManager</span></div>\n<p>如有错误请指正。</p>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 15:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kevin-Y\">生命体验之kevin-Y</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "最新！银河麒麟v11 kubeadm部署k8s v1.35.0高可用集群",
      "link": "https://www.cnblogs.com/v-fan/p/19569414",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/v-fan/p/19569414\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 14:57\">\n    <span>最新！银河麒麟v11 kubeadm部署k8s v1.35.0高可用集群</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"银河麒麟v11-kubeadm部署k8s-v1350高可用集群\">银河麒麟v11 kubeadm部署k8s v1.35.0高可用集群</h1>\n<h2 id=\"系统环境\">系统环境</h2>\n<pre><code class=\"language-bash\"># nkvers \n############## Kylin Linux Version #################\nRelease:\nKylin Linux Advanced Server release V11 (Swan25)\n\nKernel:\n6.6.0-32.7.v2505.ky11.x86_64\n\nBuild:\nKylin Linux Advanced Server\nrelease V11 2503/(Swan25)-x86_64-Build20/20250715\n#################################################\n</code></pre>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">主机名</th>\n<th style=\"text-align: center;\">ip地址</th>\n<th style=\"text-align: center;\">配置</th>\n<th style=\"text-align: center;\">服务</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">demo-master-01</td>\n<td style=\"text-align: center;\">192.168.122.171</td>\n<td style=\"text-align: center;\">2c4g</td>\n<td style=\"text-align: center;\">k8s master、etcd、keepalived、haproxy、containerd</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">demo-master-02</td>\n<td style=\"text-align: center;\">192.168.122.172</td>\n<td style=\"text-align: center;\">2c4g</td>\n<td style=\"text-align: center;\">k8s master、etcd、keepalived、haproxy、containerd</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">demo-worker-01</td>\n<td style=\"text-align: center;\">192.168.122.173</td>\n<td style=\"text-align: center;\">2c4g</td>\n<td style=\"text-align: center;\">k8s worker、etcd</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"服务版本介绍\">服务版本介绍</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">服务名称</th>\n<th style=\"text-align: center;\">版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">kubernetes</td>\n<td style=\"text-align: center;\">1.35.0</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">containerd</td>\n<td style=\"text-align: center;\">2.2.1</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">etcd</td>\n<td style=\"text-align: center;\">3.6.7</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">cni-plugins</td>\n<td style=\"text-align: center;\">1.3.0</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">runc</td>\n<td style=\"text-align: center;\">1.4.0</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">keepalived</td>\n<td style=\"text-align: center;\">2.3.4</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">haproxy</td>\n<td style=\"text-align: center;\">3.2.10</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">cilium</td>\n<td style=\"text-align: center;\">1.18.6</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"前言\">前言</h2>\n<p>此文档主要用于演示使用二进制kubeadm部署Kubernetes高可用集群。</p>\n<p>此文档仅进行流程演示，后续用户可以使用ansible或编写Shell、Go脚本进行自动化配置，提高部署效率。</p>\n<p>v1.35.0版本较之前版本还是有些差异和特性的，再加上新发布的国产服务器操作系统银河麒麟v11，相信看完会有新的收获！</p>\n<h2 id=\"环境准备\">环境准备</h2>\n<p>此步骤主要将一些部署k8s前的前置条件配置好，每个主机都要进行操作。</p>\n<h3 id=\"配置主机名配置hosts解析\">配置主机名，配置hosts解析</h3>\n<pre><code class=\"language-bash\"># 主机名\nhostnamectl set-hostname demo-master-01\nhostnamectl set-hostname demo-master-02\nhostnamectl set-hostname demo-worker-01\n\n# /etc/hosts\n192.168.122.171 demo-master-01\n192.168.122.172 demo-master-02\n192.168.122.173 demo-worker-01\n</code></pre>\n<h3 id=\"关闭防火墙selinuxswap分区\">关闭防火墙，SElinux，swap分区</h3>\n<pre><code class=\"language-bash\"># 防火墙\nsystemctl stop firewalld.service\nsystemctl disable firewalld.service\n\n# SElinux，默认就是关闭状态，若是开启状态可执行以下命令\nsetenforce 0\nsed -i 's/^SELINUX=.*/SELINUX=disabled/' /etc/selinux/config\n\n# swap分区\nswapoff -a\nsed -ri 's/.*swap.*/#&amp;/' /etc/fstab\n</code></pre>\n<h3 id=\"配置时钟同步\">配置时钟同步</h3>\n<pre><code class=\"language-bash\"># 配置时区\ntimedatectl set-timezone Asia/Shanghai\n\n# 配置ntp服务器\nvim /etc/chrony.conf\n...\nserver ntp1.aliyun.com iburst\n...\n\n# 启动服务，并开启自启\nsystemctl enable --now chronyd.service\n\n# 检查同步服务、同步状态\nsystemctl status chronyd.service\ntimedatectl \nchronyc sources -v \n</code></pre>\n<h3 id=\"内核配置\">内核配置</h3>\n<p>由于银河麒麟V11自带内核已为6.6版本，故不需再进行大版本的升级，仅需进行某些内核参数配置即可。</p>\n<p>因为CNI插件准备采用cilium，直接替代kube-proxy，故不需加载ipvs模块，但由于k8s节点与keepalived服务在同一节点，故需加载ipvs模块。</p>\n<p>另外银河麒麟的sysctl内核参数加载顺序，可参考前文：<a href=\"https://www.cnblogs.com/v-fan/p/18849732\" target=\"_blank\">银河麒麟v10 sysctl内核参数加载顺序思考</a>。</p>\n<ol>\n<li><strong>配置CGroup版本为v2</strong></li>\n</ol>\n<p>由于k8s 1.35版本默认的cgroup版本就是v2，同时k8s官方也强烈建议使用cgroup v2，使用cgroup v2有以下几点要求：</p>\n<ul>\n<li>操作系统发行版启用 CGroup v2</li>\n<li>Linux 内核为 5.8 或更高版本</li>\n<li>容器运行时支持 CGroup v2。例如：<a href=\"https://containerd.io/\" rel=\"noopener nofollow\" target=\"_blank\">containerd</a> v1.4 和更高版本、<a href=\"https://cri-o.io/\" rel=\"noopener nofollow\" target=\"_blank\">cri-o</a> v1.20 和更高版本</li>\n<li>kubelet 和容器运行时被配置为使用 <a href=\"https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes#systemd-cgroup-driver\" rel=\"noopener nofollow\" target=\"_blank\">systemd CGroup 驱动</a></li>\n</ul>\n<p>查看当前默认cgroup版本：</p>\n<pre><code class=\"language-bash\">stat -fc %T /sys/fs/cgroup/\ntmpfs\n</code></pre>\n<blockquote>\n<p>tmpfs表示CGroup v1、cgroup2fs表示CGroup v2</p>\n</blockquote>\n<p>修改内核cmdline参数，重启，使其默认支持CGroup v2：</p>\n<p>vim /etc/default/grub</p>\n<pre><code class=\"language-bash\"># 最后添加systemd.unified_cgroup_hierarchy=1参数\nGRUB_CMDLINE_LINUX=\"... systemd.unified_cgroup_hierarchy=1\"\n</code></pre>\n<p>重新生成GRUB配置文件，并重启服务器：</p>\n<pre><code class=\"language-bash\">grub2-mkconfig -o /boot/grub2/grub.cfg\nreboot\n</code></pre>\n<p>再次验证cgroup版本：</p>\n<pre><code class=\"language-bash\">stat -fc %T /sys/fs/cgroup/\ncgroup2fs\n</code></pre>\n<ol start=\"2\">\n<li><strong>加载内核模块</strong></li>\n</ol>\n<pre><code class=\"language-bash\"># 配置模块\ncat &gt;/etc/modules-load.d/k8s.conf &lt;&lt; EOF\noverlay\nbr_netfilter\nip_vs\nip_vs_rr\nip_vs_wrr\nip_vs_sh\nnf_conntrack\nip_tables\nip_set\nxt_set\nipt_set\nipt_rpfilter\nipt_REJECT\nipip\nEOF\n\n# 将管理服务开机自启，并重新加载生效\nsystemctl enable --now systemd-modules-load\nsystemctl restart systemd-modules-load\n\n# 临时加载某模块\nmodprobe overlay \nmodprobe br_netfilter\n</code></pre>\n<ol start=\"3\">\n<li><strong>优化内核参数</strong></li>\n</ol>\n<p>将现有的<code>/etc/sysctl.conf</code>和<code>/etc/sysctl.d/99-sysctl.conf</code>文件中的<code>net.ipv4.ip_forward</code>配置都删除掉，统一配置到kubernetes的文件中：</p>\n<pre><code class=\"language-bash\"># 删除原配置\nsed -i '/net.ipv4.ip_forward/d' /etc/sysctl.conf /etc/sysctl.d/99-sysctl.conf\n\n# 添加新配置\ncat &gt; /etc/sysctl.d/99-kubernetes-cri.conf &lt;&lt; EOF\n# ========== 网络相关（K8S 网络插件/容器通信核心） ==========\n# 让桥接流量经过 iptables 规则（Calico/Flannel/CNI 插件必需）\nnet.bridge.bridge-nf-call-iptables = 1\nnet.bridge.bridge-nf-call-ip6tables = 1\n# 开启 IP 转发（Pod 跨节点通信、Service 转发必需）\nnet.ipv4.ip_forward = 1\n# 复用 TIME_WAIT 套接字，提升高并发网络性能\nnet.ipv4.tcp_tw_reuse = 1\n# 增大套接字监听队列上限（避免高并发下连接被拒绝）\nnet.core.somaxconn = 65535\n# 增大网络设备接收队列（提升网络吞吐）\nnet.core.netdev_max_backlog = 65535\n# 增大 TCP SYN 队列（抵御 SYN 洪水，提升连接建立效率）\nnet.ipv4.tcp_max_syn_backlog = 65535\n# 缩短 FIN_WAIT2 超时时间（快速释放资源）\nnet.ipv4.tcp_fin_timeout = 30\n# 优化 ARP 缓存（大规模集群减少缓存回收频率）\nnet.ipv4.neigh.default.gc_thresh1 = 8192\nnet.ipv4.neigh.default.gc_thresh2 = 32768\nnet.ipv4.neigh.default.gc_thresh3 = 65536\n\n# ========== Containerd/容器运行时相关 ==========\n# 增大 inotify 实例数/监控文件数（避免 containerd 监控容器文件时达到上限）\nfs.inotify.max_user_instances = 1048576\nfs.inotify.max_user_watches = 1048576\n# 增大系统最大文件句柄数（支持大规模容器，每个容器占用多个文件句柄）\nfs.file-max = 52706963\n# 增大单个进程最大打开文件数（配合 file-max）\nfs.nr_open = 52706963\n# 增大虚拟内存映射区数量（满足 containerd/容器内应用如 ES 的需求）\nvm.max_map_count = 262144\n# 禁用交换分区（K8S 要求，避免容器内存使用 swap 导致性能下降）\nvm.swappiness = 0\n# 增大最大 PID 数（支持大规模 Pod，每个 Pod 包含多个进程）\nkernel.pid_max = 4194304\n\n# ========== K8S 核心稳定性相关 ==========\n# 内核 panic 后 10 秒重启（提升集群自愈能力）\nkernel.panic = 10\n# 内核出错时触发 panic（避免节点僵死）\nkernel.panic_on_oops = 1\n# 检测到软锁死时触发 panic（避免节点无响应）\nkernel.softlockup_panic = 1\nEOF\n\n# 加载新配置\nsysctl --system\n\n# 检查配置是否生效\nsysctl -a | grep -E 'ip_forward|nr_open'\n</code></pre>\n<ol start=\"4\">\n<li><strong>其他：内核升级（v11跳过）</strong></li>\n</ol>\n<p>另外，若是KylinOS V10 SP3的版本，可先进行内核升级，再进行上述参数的修改（跳过设置cgroup v2的步骤）。</p>\n<p>KylinOS V10 SP3 2403默认的内核版本是4.19.90-89.15，目前此系统版本适配的内核最高版本是4.19.90-89.18，如有需求，可以进行升级，步骤如下。</p>\n<p>注：由于KylinOS的内核具有高度定制性，故不建议使用Linux Kernel官方提供高版本内核的rpm包或源码编译包直接安装到KylinOS中，以免导致一些非必要的问题。</p>\n<p><strong>下载内核包</strong></p>\n<pre><code># mkdir kernel_rpm &amp;&amp; cd kernel_rpm\n# for i in kernel kernel-core kernel-devel kernel-headers kernel-modules kernel-modules-extra kernel-modules-internal; do wget https://update.cs2c.com.cn/NS/V10/V10SP3-2403/os/adv/lic/updates/x86_64/Packages/${i}-4.19.90-89.18.v2401.ky10.x86_64.rpm ;done\n</code></pre>\n<p><strong>安装内核</strong></p>\n<pre><code># rpm -ivh kernel-4.19.90-89.18.v2401.ky10.x86_64.rpm kernel-core-4.19.90-89.18.v2401.ky10.x86_64.rpm  kernel-modules-4.19.90-89.18.v2401.ky10.x86_64.rpm kernel-modules-extra-4.19.90-89.18.v2401.ky10.x86_64.rpm kernel-modules-internal-4.19.90-89.18.v2401.ky10.x86_64.rpm\n# rpm -Uvh kernel-devel-4.19.90-89.18.v2401.ky10.x86_64.rpm\n# rpm -Uvh kernel-headers-4.19.90-89.18.v2401.ky10.x86_64.rpm\n</code></pre>\n<p><strong>设定默认启动</strong></p>\n<pre><code># grub2-set-default kernel-4.19.90-89.18.v2401.ky10.x86_64.rpm\n</code></pre>\n<p><strong>验证升级</strong></p>\n<pre><code># grub2-editenv list\n# reboot\n# nkvers\n</code></pre>\n<h2 id=\"开始部署k8s集群\">开始部署k8s集群</h2>\n<h3 id=\"containerd安装\">containerd安装</h3>\n<p>所有节点均需要操作安装。</p>\n<h4 id=\"cni插件安装\">cni插件安装</h4>\n<p>若服务器可代理上网，可直接执行以下脚本：</p>\n<pre><code class=\"language-bash\">CNI_PLUGINS_VERSION=\"v1.3.0\"\nARCH=\"amd64\"\nDEST=\"/opt/cni/bin\"\nsudo mkdir -p \"$DEST\"\ncurl -L \"https://github.com/containernetworking/plugins/releases/download/${CNI_PLUGINS_VERSION}/cni-plugins-linux-${ARCH}-${CNI_PLUGINS_VERSION}.tgz\" | sudo tar -C \"$DEST\" -xz\n</code></pre>\n<p>若不可代理上网，本文<strong>所需所有包及镜像均已上传至网盘</strong>，可到文末获取。</p>\n<p>将对应包上传至服务器中：<code>cni-plugins-linux-amd64-v1.3.0.tgz</code>，执行：</p>\n<pre><code class=\"language-bash\">mkdir -p /opt/cni/bin\ntar Cxzvf /opt/cni/bin cni-plugins-linux-amd64-v1.3.0.tgz\n</code></pre>\n<h4 id=\"runc安装\">runc安装</h4>\n<pre><code class=\"language-bash\">wget https://github.com/opencontainers/runc/releases/download/v1.4.0/runc.amd64\ninstall -m 755 runc.amd64 /usr/local/sbin/runc\n</code></pre>\n<h4 id=\"containerd运行时安装\">containerd运行时安装</h4>\n<pre><code class=\"language-bash\">wget https://github.com/containerd/containerd/releases/download/v2.2.1/containerd-2.2.1-linux-amd64.tar.gz\ntar Cxzvf /usr/local containerd-2.2.1-linux-amd64.tar.gz\n</code></pre>\n<p>配置systemd管理：<code>vim /usr/lib/systemd/system/containerd.service</code></p>\n<pre><code class=\"language-bash\"># Copyright The containerd Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[Unit]\nDescription=containerd container runtime\nDocumentation=https://containerd.io\nAfter=network.target dbus.service\n\n[Service]\nExecStartPre=-/sbin/modprobe overlay\nExecStart=/usr/local/bin/containerd\n\nType=notify\nDelegate=yes\nKillMode=process\nRestart=always\nRestartSec=5\n\n# Having non-zero Limit*s causes performance problems due to accounting overhead\n# in the kernel. We recommend using cgroups to do container-local accounting.\nLimitNPROC=infinity\nLimitCORE=infinity\n\n# Comment TasksMax if your systemd version does not supports it.\n# Only systemd 226 and above support this version.\nTasksMax=infinity\nOOMScoreAdjust=-999\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>\n<p>加载systemd，并启动containerd</p>\n<pre><code class=\"language-bash\">systemctl daemon-reload\nsystemctl enable --now containerd\nsystemctl status containerd.service\n</code></pre>\n<p>安装crictl客户端工具，配合管理containerd、k8s集群，可代理上网时，直接执行以下脚本：</p>\n<pre><code class=\"language-bash\">DOWNLOAD_DIR=\"/usr/local/bin\"\nCRICTL_VERSION=\"v1.31.0\"\nARCH=\"amd64\"\ncurl -L \"https://github.com/kubernetes-sigs/cri-tools/releases/download/${CRICTL_VERSION}/crictl-${CRICTL_VERSION}-linux-${ARCH}.tar.gz\" | sudo tar -C $DOWNLOAD_DIR -xz\n</code></pre>\n<p>否则，上传<code>crictl-v1.31.0-linux-amd64.tar.gz</code>，执行：</p>\n<pre><code class=\"language-bash\">tar Cxzvf /usr/local/bin crictl-v1.31.0-linux-amd64.tar.gz\n</code></pre>\n<p>配置crictl：</p>\n<pre><code class=\"language-bash\">cat &gt; /etc/crictl.yaml &lt;&lt;EOF\nruntime-endpoint: unix:///run/containerd/containerd.sock\nimage-endpoint: unix:///run/containerd/containerd.sock\ntimeout: 10\ndebug: true\npull-image-on-create: false\nEOF\n</code></pre>\n<p>安装nerdctl工具，用于containerd本身的容器管理更方便：</p>\n<pre><code class=\"language-bash\"># 下载\nwget https://github.com/containerd/nerdctl/releases/download/v2.2.1/nerdctl-2.2.1-linux-amd64.tar.gz\n# 解压\ntar xf nerdctl-2.2.1-linux-amd64.tar.gz -C /usr/local/bin/\n# 运行查看\nnerdctl images\n</code></pre>\n<p>配置<code>/etc/containerd/config.toml</code>：</p>\n<pre><code class=\"language-bash\">containerd config default &gt; /etc/containerd/config.toml\n\nvim /etc/containerd/config.toml\n# 配置 systemd cgroup 驱动\n[plugins.'io.containerd.cri.v1.runtime'.containerd.runtimes.runc]\n  ...\n  [plugins.'io.containerd.cri.v1.runtime'.containerd.runtimes.runc.options]\n    SystemdCgroup = true\n\n# 修改 sandbox 容器镜像仓库\n    [plugins.'io.containerd.cri.v1.images'.pinned_images]\n      sandbox = 'registry.aliyuncs.com/google_containers/pause:3.10.1'\n</code></pre>\n<p>配置完成，重启containerd服务：<code>systemctl restart containerd.service</code></p>\n<h3 id=\"kubeadmkubeletkubectl安装\">kubeadm/kubelet/kubectl安装</h3>\n<p>所有节点均需要操作安装。</p>\n<h4 id=\"kubeadmkubelet-install\">kubeadm/kubelet install</h4>\n<p>可代理上网，直接执行以下脚本：</p>\n<pre><code class=\"language-bash\">DOWNLOAD_DIR=\"/usr/local/bin\"\nRELEASE=\"v1.35.0\"\nARCH=\"amd64\"\ncd $DOWNLOAD_DIR\nsudo curl -L --remote-name-all https://dl.k8s.io/release/${RELEASE}/bin/linux/${ARCH}/{kubeadm,kubelet}\nsudo chmod +x {kubeadm,kubelet}\n\nRELEASE_VERSION=\"v0.16.2\"\ncurl -sSL \"https://raw.githubusercontent.com/kubernetes/release/${RELEASE_VERSION}/cmd/krel/templates/latest/kubelet/kubelet.service\" | sed \"s:/usr/bin:${DOWNLOAD_DIR}:g\" | sudo tee /usr/lib/systemd/system/kubelet.service\nsudo mkdir -p /usr/lib/systemd/system/kubelet.service.d\ncurl -sSL \"https://raw.githubusercontent.com/kubernetes/release/${RELEASE_VERSION}/cmd/krel/templates/latest/kubeadm/10-kubeadm.conf\" | sed \"s:/usr/bin:${DOWNLOAD_DIR}:g\" | sudo tee /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf\n</code></pre>\n<p>不可代理上网，上传<code>kubeadm</code>、<code>kubelet</code>文件至服务器，随后执行：</p>\n<pre><code class=\"language-bash\">chmod +x kubeadm kubelet \nmv kubeadm kubelet /usr/local/bin/\n</code></pre>\n<p>配置systemd：<code>vim /usr/lib/systemd/system/kubelet.service</code></p>\n<pre><code class=\"language-bash\">[Unit]\nDescription=kubelet: The Kubernetes Node Agent\nDocumentation=https://kubernetes.io/docs/\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nExecStart=/usr/local/bin/kubelet\nRestart=always\nStartLimitInterval=0\nRestartSec=10\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>\n<p>编辑kubelet管理配置文件：</p>\n<p><code>mkdir -p /usr/lib/systemd/system/kubelet.service.d</code></p>\n<p><code>vim /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</code></p>\n<pre><code class=\"language-bash\"># Note: This dropin only works with kubeadm and kubelet v1.11+\n[Service]\nEnvironment=\"KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf\"\nEnvironment=\"KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml\"\n# This is a file that \"kubeadm init\" and \"kubeadm join\" generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically\nEnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env\n# This is a file that the user can use for overrides of the kubelet args as a last resort. Preferably, the user should use\n# the .NodeRegistration.KubeletExtraArgs object in the configuration files instead. KUBELET_EXTRA_ARGS should be sourced from this file.\nEnvironmentFile=-/etc/sysconfig/kubelet\nExecStart=\nExecStart=/usr/local/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS\n</code></pre>\n<p>启动kubelet，查看状态：</p>\n<pre><code class=\"language-bash\">systemctl enable --now kubelet\nsystemctl status kubelet\n</code></pre>\n<h4 id=\"kubectl-install\">kubectl install</h4>\n<p>上传<code>kubectl</code>至服务器，并执行：</p>\n<pre><code class=\"language-bash\">install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl\nkubectl version --client\n</code></pre>\n<h4 id=\"配置命令补全\">配置命令补全</h4>\n<pre><code class=\"language-bash\">yum install bash-completion\nsource /usr/share/bash-completion/bash_completion\n\n# kubectl补全\nsource &lt;(kubectl completion bash)\nkubectl completion bash &gt;/etc/bash_completion.d/kubectl\n\n# crictl补全\nsource &lt;(crictl completion bash)\ncrictl completion bash &gt;/etc/bash_completion.d/crictl\n\n# nerctl补全\nsource &lt;(nerdctl completion bash)\nnerdctl completion bash &gt;/etc/bash_completion.d/nerdctl\n</code></pre>\n<h3 id=\"高可用etcd安装\">高可用etcd安装</h3>\n<blockquote>\n<p>本节安装3节点高可用集群</p>\n</blockquote>\n<ol>\n<li>运行以下脚本，为每个etcd主机创建kubeadm配置文件</li>\n</ol>\n<pre><code class=\"language-bash\"># 使用你的主机 IP 更新 HOST0、HOST1 和 HOST2 的 IP 地址\nexport HOST0=192.168.122.171\nexport HOST1=192.168.122.172\nexport HOST2=192.168.122.173\n\n# 使用你的主机名更新 NAME0、NAME1 和 NAME2\nexport NAME0=\"demo-master-01\"\nexport NAME1=\"demo-master-02\"\nexport NAME2=\"demo-worker-01\"\n\n# 创建临时目录来存储将被分发到其它主机上的文件\nmkdir -p /tmp/${HOST0}/ /tmp/${HOST1}/ /tmp/${HOST2}/\n\nHOSTS=(${HOST0} ${HOST1} ${HOST2})\nNAMES=(${NAME0} ${NAME1} ${NAME2})\n\nfor i in \"${!HOSTS[@]}\"; do\nHOST=${HOSTS[$i]}\nNAME=${NAMES[$i]}\ncat &lt;&lt; EOF &gt; /tmp/${HOST}/kubeadmcfg.yaml\n---\napiVersion: \"kubeadm.k8s.io/v1beta4\"\nkind: InitConfiguration\nnodeRegistration:\n    name: ${NAME}\nlocalAPIEndpoint:\n    advertiseAddress: ${HOST}\n---\napiVersion: \"kubeadm.k8s.io/v1beta4\"\nkind: ClusterConfiguration\netcd:\n    local:\n        serverCertSANs:\n        - \"${HOST}\"\n        peerCertSANs:\n        - \"${HOST}\"\n        extraArgs:\n        - name: initial-cluster\n          value: ${NAMES[0]}=https://${HOSTS[0]}:2380,${NAMES[1]}=https://${HOSTS[1]}:2380,${NAMES[2]}=https://${HOSTS[2]}:2380\n        - name: initial-cluster-state\n          value: new\n        - name: name\n          value: ${NAME}\n        - name: listen-peer-urls\n          value: https://${HOST}:2380\n        - name: listen-client-urls\n          value: https://${HOST}:2379\n        - name: advertise-client-urls\n          value: https://${HOST}:2379\n        - name: initial-advertise-peer-urls\n          value: https://${HOST}:2380\nEOF\ndone\n</code></pre>\n<ol start=\"2\">\n<li>生成CA证书</li>\n</ol>\n<pre><code class=\"language-bash\">kubeadm init phase certs etcd-ca\n\n# 会生成这两个文件\nls /etc/kubernetes/pki/etcd\nca.crt  ca.key\n</code></pre>\n<ol start=\"3\">\n<li>为每个etcd主机创建证书</li>\n</ol>\n<pre><code class=\"language-bash\"># 使用你的主机 IP 更新 HOST0、HOST1 和 HOST2 的 IP 地址\nexport HOST0=192.168.122.171\nexport HOST1=192.168.122.172\nexport HOST2=192.168.122.173\n\nkubeadm init phase certs etcd-server --config=/tmp/${HOST2}/kubeadmcfg.yaml\nkubeadm init phase certs etcd-peer --config=/tmp/${HOST2}/kubeadmcfg.yaml\nkubeadm init phase certs etcd-healthcheck-client --config=/tmp/${HOST2}/kubeadmcfg.yaml\nkubeadm init phase certs apiserver-etcd-client --config=/tmp/${HOST2}/kubeadmcfg.yaml\ncp -R /etc/kubernetes/pki /tmp/${HOST2}/\n# 清理不可重复使用的证书\nfind /etc/kubernetes/pki -not -name ca.crt -not -name ca.key -type f -delete\n\nkubeadm init phase certs etcd-server --config=/tmp/${HOST1}/kubeadmcfg.yaml\nkubeadm init phase certs etcd-peer --config=/tmp/${HOST1}/kubeadmcfg.yaml\nkubeadm init phase certs etcd-healthcheck-client --config=/tmp/${HOST1}/kubeadmcfg.yaml\nkubeadm init phase certs apiserver-etcd-client --config=/tmp/${HOST1}/kubeadmcfg.yaml\ncp -R /etc/kubernetes/pki /tmp/${HOST1}/\nfind /etc/kubernetes/pki -not -name ca.crt -not -name ca.key -type f -delete\n\nkubeadm init phase certs etcd-server --config=/tmp/${HOST0}/kubeadmcfg.yaml\nkubeadm init phase certs etcd-peer --config=/tmp/${HOST0}/kubeadmcfg.yaml\nkubeadm init phase certs etcd-healthcheck-client --config=/tmp/${HOST0}/kubeadmcfg.yaml\nkubeadm init phase certs apiserver-etcd-client --config=/tmp/${HOST0}/kubeadmcfg.yaml\n# 不需要移动 certs 因为它们是给 HOST0 使用的\n\n# 清理不应从此主机复制的证书\nfind /tmp/${HOST2} -name ca.key -type f -delete\nfind /tmp/${HOST1} -name ca.key -type f -delete\n</code></pre>\n<ol start=\"4\">\n<li>复制证书和 kubeadm 配置到目标主机</li>\n</ol>\n<pre><code class=\"language-bash\">USER=root\n\n# demo-master-02\nscp -r /tmp/${HOST1}/* ${USER}@${HOST1}:\nssh ${USER}@${HOST1}\nroot@HOST $ chown -R root:root pki\nroot@HOST $ mkdir /etc/kubernetes\nroot@HOST $ mv pki /etc/kubernetes/\n\n# demo-worker-01\nscp -r /tmp/${HOST2}/* ${USER}@${HOST2}:\nssh ${USER}@${HOST2}\nroot@HOST $ chown -R root:root pki\nroot@HOST $ mkdir /etc/kubernetes\nroot@HOST $ mv pki /etc/kubernetes/\n</code></pre>\n<ol start=\"5\">\n<li>检查目标主机证书</li>\n</ol>\n<pre><code class=\"language-bash\"># demo-master-01\ntree /tmp/192.168.122.171/ /etc/kubernetes/pki\n/tmp/192.168.122.171/\n└── kubeadmcfg.yaml\n/etc/kubernetes/pki\n├── apiserver-etcd-client.crt\n├── apiserver-etcd-client.key\n└── etcd\n    ├── ca.crt\n    ├── ca.key\n    ├── healthcheck-client.crt\n    ├── healthcheck-client.key\n    ├── peer.crt\n    ├── peer.key\n    ├── server.crt\n    └── server.key\n\n# demo-master-02\ntree /root/ /etc/kubernetes/pki\n/root/\n└── kubeadmcfg.yaml\n/etc/kubernetes/pki\n├── apiserver-etcd-client.crt\n├── apiserver-etcd-client.key\n└── etcd\n    ├── ca.crt\n    ├── healthcheck-client.crt\n    ├── healthcheck-client.key\n    ├── peer.crt\n    ├── peer.key\n    ├── server.crt\n    └── server.key\n\n# demo-worker-01\ntree /root/ /etc/kubernetes/pki\n/root/\n└── kubeadmcfg.yaml\n/etc/kubernetes/pki\n├── apiserver-etcd-client.crt\n├── apiserver-etcd-client.key\n└── etcd\n    ├── ca.crt\n    ├── healthcheck-client.crt\n    ├── healthcheck-client.key\n    ├── peer.crt\n    ├── peer.key\n    ├── server.crt\n    └── server.key\n</code></pre>\n<ol start=\"6\">\n<li>安装及配置etcd服务</li>\n</ol>\n<blockquote>\n<p>注：所有etcd主机均需操作，yum源自带etcd服务版本为3.4.14，而k8s1.35要求etcd不低于3.5.24-0。</p>\n</blockquote>\n<pre><code class=\"language-bash\"># 下载\nwget https://github.com/etcd-io/etcd/releases/download/v3.6.7/etcd-v3.6.7-linux-amd64.tar.gz\n# 解压缩\ntar xf etcd-v3.6.7-linux-amd64.tar.gz &amp;&amp; cd etcd-v3.6.7-linux-amd64\n# 编辑运行环境\ncp etcdctl etcdutl etcd /usr/bin/\nmkdir /var/lib/etcd /etc/etcd &amp;&amp; chown -R etcd:etcd /var/lib/etcd &amp;&amp; chmod 700 /var/lib/etcd/ &amp;&amp; chown -R etcd /etc/kubernetes/pki/etcd\n</code></pre>\n<p>vim /etc/etcd/etcd.conf</p>\n<pre><code class=\"language-bash\"># etcd节点名称，要和ETCD_INITIAL_CLUSTER中的名称一致\nETCD_NAME=demo-master-01\n\n#数据存储目录\nETCD_DATA_DIR=\"/var/lib/etcd\"\n\n# 服务的监听和通信地址与端口\nETCD_LISTEN_PEER_URLS=\"https://192.168.122.171:2380\"\nETCD_LISTEN_CLIENT_URLS=\"https://192.168.122.171:2379\"\nETCD_INITIAL_ADVERTISE_PEER_URLS=\"https://192.168.122.171:2380\"\nETCD_ADVERTISE_CLIENT_URLS=\"https://192.168.122.171:2379\"\n\n# 集群所有的成员\nETCD_INITIAL_CLUSTER=\"demo-master-01=https://192.168.122.171:2380,demo-master-02=https://192.168.122.172:2380,demo-worker-01=https://192.168.122.173:2380\"\nETCD_INITIAL_CLUSTER_STATE=\"new\"\nETCD_INITIAL_CLUSTER_TOKEN=\"etcd-cluster\"\n\n# 证书配置\nETCD_CERT_FILE=\"/etc/kubernetes/pki/etcd/server.crt\"\nETCD_KEY_FILE=\"/etc/kubernetes/pki/etcd/server.key\"\nETCD_CLIENT_CERT_AUTH=\"true\"\nETCD_TRUSTED_CA_FILE=\"/etc/kubernetes/pki/etcd/ca.crt\"\nETCD_AUTO_TLS=\"true\"\nETCD_PEER_CERT_FILE=\"/etc/kubernetes/pki/etcd/peer.crt\"\nETCD_PEER_KEY_FILE=\"/etc/kubernetes/pki/etcd/peer.key\"\nETCD_PEER_CLIENT_CERT_AUTH=\"true\"\nETCD_PEER_TRUSTED_CA_FILE=\"/etc/kubernetes/pki/etcd/ca.crt\"\nETCD_PEER_AUTO_TLS=\"true\"\n</code></pre>\n<blockquote>\n<p>3台etcd的配置文件主体内容相同，仅<code>ETCD_NAME</code>及监听的地址需要根据实际情况修改，例如demo-master-02主机需更改为<code>ETCD_NAME=demo-master-02</code>，并将所有ip地址更改为<code>192.168.122.172</code>。</p>\n</blockquote>\n<p>vim /usr/lib/systemd/system/etcd.service</p>\n<pre><code class=\"language-bash\">[Unit]\nDescription=Etcd Server\nAfter=network.target\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nType=notify\nWorkingDirectory=/var/lib/etcd/\nEnvironmentFile=-/etc/etcd/etcd.conf\nUser=etcd\n# set GOMAXPROCS to number of processors\nExecStart=/bin/bash -c \"GOMAXPROCS=$(nproc) /usr/bin/etcd\"\nRestart=on-failure\nLimitNOFILE=65536\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>\n<ol start=\"7\">\n<li>启动服务，并检查etcd集群状态</li>\n</ol>\n<pre><code class=\"language-bash\">systemctl daemon-reload\n# 所有节点，尽量同时间启动\nsystemctl enable --now etcd\n</code></pre>\n<p>检查集群状态：</p>\n<pre><code class=\"language-bash\">export HOST0=192.168.122.171\n\nETCDCTL_API=3 etcdctl \\\n--cert /etc/kubernetes/pki/etcd/peer.crt \\\n--key /etc/kubernetes/pki/etcd/peer.key \\\n--cacert /etc/kubernetes/pki/etcd/ca.crt \\\n--endpoints https://${HOST0}:2379 endpoint health\n</code></pre>\n<h3 id=\"配置高可用\">配置高可用</h3>\n<h4 id=\"配置keepalived-and-haproxy\">配置keepalived and haproxy</h4>\n<p>第1-4步在两台机器的操作是相同的，第5步需差异配置。</p>\n<ol>\n<li>下载源码到本地</li>\n</ol>\n<pre><code class=\"language-bash\">wget https://www.keepalived.org/software/keepalived-2.3.4.tar.gz\nwget https://www.haproxy.org/download/3.2/src/haproxy-3.2.10.tar.gz\n</code></pre>\n<ol start=\"2\">\n<li>编译安装keepalived</li>\n</ol>\n<pre><code class=\"language-bash\">tar xf keepalived-2.3.4.tar.gz &amp;&amp; cd keepalived-2.3.4\nyum -y install openssl-devel gcc \n./configure --prefix=/usr/local/keepalived-2.3.4\nmake &amp;&amp; make install\n\n# 配置软连接\nln -sv /usr/local/keepalived-2.3.4/sbin/keepalived /usr/sbin/\nln -sv /usr/local/keepalived-2.3.4/etc/keepalived /etc/keepalived\n</code></pre>\n<ol start=\"2\">\n<li>编译安装haproxy</li>\n</ol>\n<pre><code class=\"language-bash\">tar xf haproxy-3.2.10.tar.gz &amp;&amp; cd haproxy-3.2.10\nyum -y install zlib-devel\nmake -j 2 TARGET=generic USE_ZLIB=1 USE_OPENSSL=1\nmake install PREFIX=/usr/local/haproxy-3.2.10\n\n# 配置软连接\nln -sv /usr/local/haproxy-3.2.10/sbin/haproxy /usr/sbin/\nmkdir /usr/local/haproxy-3.2.10/conf &amp;&amp; ln -sv /usr/local/haproxy-3.2.10/conf /etc/haproxy &amp;&amp; mkdir /etc/haproxy/conf.d\n</code></pre>\n<ol start=\"3\">\n<li>配置systemd管理单元</li>\n</ol>\n<p>vim /usr/lib/systemd/system/haproxy.service</p>\n<pre><code class=\"language-bash\">[Unit]\nDescription=HAProxy Load Balancer\nAfter=network-online.target            \nWants=network-online.target\n\n[Service]\nEnvironmentFile=-/etc/sysconfig/haproxy\nEnvironment=\"HAPROXY_CONF=/etc/haproxy/haproxy.cfg\" \"PIDFILE=/run/haproxy.pid\" \"CFGDIR=/etc/haproxy/conf.d\"\nExecStartPre=/usr/sbin/haproxy -f $HAPROXY_CONF -f $CFGDIR -c\nExecStart=/usr/sbin/haproxy -Ws -f $HAPROXY_CONF -f $CFGDIR -p $PIDFILE\nExecReload=/usr/sbin/haproxy -f $HAPROXY_CONF -f $CFGDIR -c\nExecReload=/bin/kill -USR2 $MAINPID\nKillMode=mixed\nSuccessExitStatus=143\nType=notify\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>\n<p>vim /usr/lib/systemd/system/keepalived.service</p>\n<pre><code class=\"language-bash\">[Unit]\nDescription=LVS and VRRP High Availability Monitor\nAfter=network-online.target syslog.target\nWants=network-online.target\n\n[Service]\nType=forking\nPIDFile=/run/keepalived.pid\nKillMode=process\nEnvironmentFile=-/usr/local/keepalived-2.3.4/etc/sysconfig/keepalived\nExecStart=/usr/local/keepalived-2.3.4/sbin/keepalived $KEEPALIVED_OPTIONS\nExecReload=/bin/kill -HUP $MAINPID\nStartLimitBurst=1\nStartLimitInterval=1s\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>\n<p>加载管理单元配置文件：</p>\n<pre><code class=\"language-bash\">systemctl daemon-reload\n</code></pre>\n<ol start=\"4\">\n<li>配置haproxy的kube-apiserver负载均衡</li>\n</ol>\n<p>vim /etc/haproxy/haproxy.cfg</p>\n<pre><code class=\"language-bash\">#---------------------------------------------------------------------\n# Global settings\n#---------------------------------------------------------------------\nglobal\n    log stdout format raw local0\n    daemon\n\n#---------------------------------------------------------------------\n# common defaults that all the 'listen' and 'backend' sections will\n# use if not designated in their block\n#---------------------------------------------------------------------\ndefaults\n    mode                    http\n    log                     global\n    option                  httplog\n    option                  dontlognull\n    option http-server-close\n    option forwardfor       except 127.0.0.0/8\n    option                  redispatch\n    retries                 1\n    timeout http-request    10s\n    timeout queue           20s\n    timeout connect         5s\n    timeout client          35s\n    timeout server          35s\n    timeout http-keep-alive 10s\n    timeout check           10s\n\n#---------------------------------------------------------------------\n# apiserver frontend which proxys to the control plane nodes\n#---------------------------------------------------------------------\nfrontend apiserver\n    bind *:16443\n    mode tcp\n    option tcplog\n    default_backend apiserverbackend\n\n#---------------------------------------------------------------------\n# round robin balancing for apiserver\n#---------------------------------------------------------------------\nbackend apiserverbackend\n    option httpchk\n\n    http-check connect ssl\n    http-check send meth GET uri /healthz\n    http-check expect status 200\n\n    mode tcp\n    balance     roundrobin\n    \n    server apiserver1 192.168.122.171:6443 check verify none\n    server apiserver2 192.168.122.172:6443 check verify none\n    # [...]\n</code></pre>\n<ol start=\"5\">\n<li>配置keepalived的kube-apiserver高可用</li>\n</ol>\n<p>先在两台keepalived服务器将健康检测脚本准备好：<code>vim /etc/keepalived/check_apiserver.sh</code></p>\n<pre><code class=\"language-bash\">#!/bin/sh\n\nerrorExit() {\n    echo \"*** $*\" 1&gt;&amp;2\n    exit 1\n}\n\ncurl -sfk --max-time 2 https://localhost:16443/healthz -o /dev/null || errorExit \"Error GET https://localhost:16443/healthz\"\n</code></pre>\n<blockquote>\n<p><a href=\"https://localhost:16443/healthz%E5%9C%B0%E5%9D%80%E7%AB%AF%E5%8F%A3%E6%94%B9%E4%B8%BAhaproxy\" rel=\"noopener nofollow\" target=\"_blank\">https://localhost:16443/healthz地址端口改为haproxy</a> ip和监听的apiserver端口</p>\n</blockquote>\n<p>由于此时kube-apiserver还未进行部署，6443端口还未被监听，所以现在仅用<code>pgrep haproxy</code>检查进程存活，不检测 HAProxy 后端状态：</p>\n<p>demo-master-01下：<code>vim /etc/keepalived/keepalived.conf</code></p>\n<pre><code class=\"language-bash\">global_defs {\n    router_id LVS_DEVEL\n}\nvrrp_script check_apiserver {\n  script \"/etc/keepalived/check_apiserver.sh\"\n  interval 3\n  weight -2\n  fall 10\n  rise 2\n}\nvrrp_script check_haproxy {\n    script \"/usr/bin/pgrep haproxy\"  # 仅检查 haproxy 进程是否存在\n    interval 2                       # 每 2 秒检查一次\n    weight 2                         # 检查成功时权重+2（非必需，仅用于优先级调整）\n    fall 1                           # 1 次检查失败即判定进程异常\n    rise 1                           # 1 次检查成功即恢复\n}\n\nvrrp_instance VI_1 {\n    state MASTER\n    interface enp1s0\n    virtual_router_id 51\n    priority 101\n    authentication {\n        auth_type PASS\n        auth_pass 42\n    }\n    virtual_ipaddress {\n        192.168.122.170\n    }\n    track_script {\n        check_haproxy\n    }\n}\n</code></pre>\n<p>demo-master-02下：<code>vim /etc/keepalived/keepalived.conf</code></p>\n<pre><code class=\"language-bash\">global_defs {\n    router_id LVS_DEVEL\n}\nvrrp_script check_apiserver {\n  script \"/etc/keepalived/check_apiserver.sh\"\n  interval 3\n  weight -2\n  fall 10\n  rise 2\n}\nvrrp_script check_haproxy {\n    script \"/usr/bin/pgrep haproxy\"  # 仅检查 haproxy 进程是否存在\n    interval 2                       # 每 2 秒检查一次\n    weight 2                         # 检查成功时权重+2（非必需，仅用于优先级调整）\n    fall 1                           # 1 次检查失败即判定进程异常\n    rise 1                           # 1 次检查成功即恢复\n}\n\nvrrp_instance VI_1 {\n    state BACKUP\n    interface enp1s0\n    virtual_router_id 51\n    priority 100\n    authentication {\n        auth_type PASS\n        auth_pass 42\n    }\n    virtual_ipaddress {\n        192.168.122.170\n    }\n    track_script {\n        check_haproxy\n    }\n}\n</code></pre>\n<ol start=\"6\">\n<li>至此haproxy+keepalived的部署和配置完毕，可以暂时先不启动服务，待K8S控制节点部署完成后再进行启动。</li>\n<li>启动haproxy和keepalived，验证vip是否监听</li>\n</ol>\n<pre><code class=\"language-bash\">systemctl enable --now haproxy.service\nsystemctl enable --now keepalived.service\n\nip a\n2: enp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 52:54:00:20:d9:60 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.122.171/24 brd 192.168.122.255 scope global noprefixroute enp1s0\n       valid_lft forever preferred_lft forever\n    inet 192.168.122.170/32 scope global proto keepalived enp1s0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::5054:ff:fe20:d960/64 scope link noprefixroute \n       valid_lft forever preferred_lft forever\n</code></pre>\n<blockquote>\n<p>此时可在主节点看到VIP</p>\n</blockquote>\n<h3 id=\"部署集群\">部署集群</h3>\n<h4 id=\"拉取镜像\">拉取镜像</h4>\n<pre><code class=\"language-bash\">kubeadm config images pull --image-repository registry.aliyuncs.com/google_containers\n</code></pre>\n<pre><code class=\"language-bash\"># crictl images \nIMAGE                                                             TAG                 IMAGE ID            SIZE\nregistry.aliyuncs.com/google_containers/coredns                   v1.13.1             aa5e3ebc0dfed       23.6MB\nregistry.aliyuncs.com/google_containers/etcd                      3.6.6-0             0a108f7189562       23.6MB\nregistry.aliyuncs.com/google_containers/kube-apiserver            v1.35.0             5c6acd67e9cd1       27.7MB\nregistry.aliyuncs.com/google_containers/kube-controller-manager   v1.35.0             2c9a4b058bd7e       23.1MB\nregistry.aliyuncs.com/google_containers/kube-proxy                v1.35.0             32652ff1bbe6b       25.8MB\nregistry.aliyuncs.com/google_containers/kube-scheduler            v1.35.0             550794e3b12ac       17.2MB\nregistry.aliyuncs.com/google_containers/pause                     3.10.1              cd073f4c5f6a8       320kB\n</code></pre>\n<h4 id=\"初始化kubeadm配置\">初始化kubeadm配置</h4>\n<pre><code class=\"language-bash\">kubeadm config print init-defaults &gt; kubeadm-init.yaml\n</code></pre>\n<p>有些需要自定义更改的参数与值：</p>\n<pre><code class=\"language-bash\">apiVersion: kubeadm.k8s.io/v1beta4\nkind: InitConfiguration\n# apiserver的地址与端口\nlocalAPIEndpoint:\n  advertiseAddress: 192.168.122.171\n  bindPort: 6443\n# 节点名称\n  name: demo-master-01\n  taints: null\n---\napiVersion: kubeadm.k8s.io/v1beta4\n# 证书有效期，有需求可以改为10年\ncaCertificateValidityPeriod: 87600h0m0s\ncertificateValidityPeriod: 8760h0m0s\n# 外部etcd地址配置，若此处不指定，则k8s会自己创建单节点etcd\netcd:\n  external:\n    endpoints:\n    - https://192.168.122.171:2379\n    - https://192.168.122.172:2379\n    - https://192.168.122.173:2379\n    caFile: \"/etc/kubernetes/pki/etcd/ca.crt\"\n    certFile: \"/etc/kubernetes/pki/apiserver-etcd-client.crt\"\n    keyFile: \"/etc/kubernetes/pki/apiserver-etcd-client.key\"\n# 镜像仓库地址更改\nimageRepository: registry.aliyuncs.com/google_containers\nkind: ClusterConfiguration\nkubernetesVersion: 1.35.0\n# svc的网段与pod的网段指定，与CNI网络插件挂钩\nnetworking:\n  dnsDomain: cluster.local\n  serviceSubnet: 10.96.0.0/16\n  podSubnet: 10.98.0.0/16\n# 连接控制平面的地址，指定为vip地址和haproxy的监听端口\ncontrolPlaneEndpoint: \"192.168.122.170:16443\"\n</code></pre>\n<blockquote>\n<p>仅保留了需要注意且更改的字段。</p>\n</blockquote>\n<h4 id=\"kubeadm创建集群\">kubeadm创建集群</h4>\n<ol>\n<li>初始化集群</li>\n</ol>\n<pre><code class=\"language-bash\">kubeadm init --config=./kubeadm-init.yaml --upload-certs\n</code></pre>\n<blockquote>\n<p>kubeadm init --skip-phases=addon/kube-proxy，跳过kube-proxy组件的安装</p>\n</blockquote>\n<ol start=\"2\">\n<li>根据提示，执行kubeconfig配置</li>\n</ol>\n<pre><code class=\"language-bash\">To start administering your cluster from this node, you need to run the following as a regular user:\n\n        mkdir -p $HOME/.kube\n        sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\n        sudo chown $(id -u):$(id -g) $HOME/.kube/config\n</code></pre>\n<ol start=\"3\">\n<li>根据提示，加入新的控制节点，在demo-master-02执行</li>\n</ol>\n<pre><code class=\"language-bash\">kubeadm join 192.168.122.170:16443 --token abcdef.0123456789abcdef \\\n        --discovery-token-ca-cert-hash sha256:6d07b2c99b32777a816247f22bd36c52a9bba7a2547c9025f7be24073fdb6023 \\\n        --control-plane --certificate-key 0bbadf90b312676417c686ac4437800ca251a2e216f2aa9da02810bc66cf8325\n</code></pre>\n<ol start=\"4\">\n<li>根据提示，加入新的worker节点，在demo-worker-01执行</li>\n</ol>\n<pre><code class=\"language-bash\">kubeadm join 192.168.122.170:16443 --token abcdef.0123456789abcdef \\\n        --discovery-token-ca-cert-hash sha256:6d07b2c99b32777a816247f22bd36c52a9bba7a2547c9025f7be24073fdb6023\n</code></pre>\n<ol start=\"5\">\n<li>查看集群状态</li>\n</ol>\n<pre><code class=\"language-bash\"># kubectl get nodes \nNAME             STATUS     ROLES           AGE     VERSION\ndemo-master-01   NotReady   control-plane   4m30s   v1.35.0\ndemo-master-02   NotReady   control-plane   103s    v1.35.0\ndemo-worker-01   NotReady   &lt;none&gt;          30s     v1.35.0\n\n# kubectl get pod -n kube-system \nNAME                                     READY   STATUS    RESTARTS   AGE\ncoredns-bbdc5fdf6-8qmkt                  0/1     Pending   0          21m\ncoredns-bbdc5fdf6-k8qhn                  0/1     Pending   0          21m\nkube-apiserver-demo-master-01            1/1     Running   0          21m\nkube-apiserver-demo-master-02            1/1     Running   0          19m\nkube-controller-manager-demo-master-01   1/1     Running   0          21m\nkube-controller-manager-demo-master-02   1/1     Running   0          19m\nkube-proxy-f78gj                         1/1     Running   0          21m\nkube-proxy-hwf9q                         1/1     Running   0          19m\nkube-proxy-wxn5r                         1/1     Running   0          18m\nkube-scheduler-demo-master-01            1/1     Running   0          21m\nkube-scheduler-demo-master-02            1/1     Running   0          19m\n</code></pre>\n<blockquote>\n<p>未安装CNI插件，集群状态为NotReady</p>\n</blockquote>\n<h3 id=\"部署cni插件cilium\">部署CNI插件cilium</h3>\n<p>cilium是目前最流行的CNI插件之一，其基于eBPF，性能高，且支持网络负载、策略配置、可观测一体化，低耗高效，可替代kube-proxy组件。</p>\n<h4 id=\"部署helm工具\">部署helm工具</h4>\n<pre><code class=\"language-bash\">wget https://get.helm.sh/helm-v4.1.0-linux-amd64.tar.gz\nmv linux-amd64/helm /usr/bin/\n</code></pre>\n<pre><code class=\"language-bash\"># helm命令补全\nsource &lt;(helm completion bash)\nhelm completion bash &gt;/etc/bash_completion.d/helm\n</code></pre>\n<h4 id=\"部署cilium-chart\">部署cilium chart</h4>\n<ol>\n<li>添加cilium仓库</li>\n</ol>\n<pre><code class=\"language-bash\"># 添加repo\nhelm repo add cilium https://helm.cilium.io/\n\n# 查看版本\nhelm search repo cilium/cilium --versions | head\n</code></pre>\n<ol start=\"2\">\n<li>获取并编辑chart</li>\n</ol>\n<pre><code class=\"language-bash\">helm pull cilium/cilium --untar --version 1.18.6\n</code></pre>\n<p>修改几个关键变量值：</p>\n<p>vim cilium/values.yaml</p>\n<pre><code class=\"language-bash\"># 替换kube-Proxy组件\nkubeProxyReplacement: \"true\"\n# 指定apiserver地址，此处写VIP\nk8sServiceHost: \"192.168.122.170\"\n# 指定apiserver端口，此处写haproxy的负载端口\nk8sServicePort: \"16443\"\n# pod的ipam范围\nclusterPoolIPv4PodCIDRList: [\"10.98.0.0/16\"]\n# 每个node节点下pod网段的掩码位\nclusterPoolIPv4MaskSize: 24\n</code></pre>\n<ol start=\"3\">\n<li>提前拉取或准备所必须镜像</li>\n</ol>\n<pre><code class=\"language-bash\">quay.io/cilium/cilium:v1.18.6\nquay.io/cilium/cilium-envoy:v1.35.9-1767794330-db497dd19e346b39d81d7b5c0dedf6c812bcc5c9\nquay.io/cilium/operator-generic:v1.18.6\n</code></pre>\n<ol start=\"4\">\n<li>删除kube-proxy组件</li>\n</ol>\n<pre><code class=\"language-bash\">kubectl -n kube-system delete ds kube-proxy\nkubectl -n kube-system delete cm kube-proxy\n# Run on each node with root permissions:\niptables-save | grep -v KUBE | iptables-restore\n</code></pre>\n<blockquote>\n<p>kubeadm init --skip-phases=addon/kube-proxy可以在init阶段直接跳过安装kube-proxy。</p>\n</blockquote>\n<ol start=\"5\">\n<li>部署cilium chart</li>\n</ol>\n<pre><code class=\"language-bash\">helm install cilium cilium -f cilium/values.yaml --namespace kube-system\n</code></pre>\n<ol start=\"6\">\n<li>查看pod状态</li>\n</ol>\n<pre><code class=\"language-bash\"># kubectl get pod -n kube-system \nNAME                                     READY   STATUS    RESTARTS       AGE\ncilium-8lqwz                             2/2     Running   0              52s\ncilium-envoy-78rx5                       1/1     Running   0              52s\ncilium-envoy-8ssc8                       1/1     Running   0              52s\ncilium-envoy-sc92g                       1/1     Running   0              52s\ncilium-nnl6k                             2/2     Running   0              52s\ncilium-operator-698cfb64f9-d2p2n         1/1     Running   0              52s\ncilium-operator-698cfb64f9-smdvt         1/1     Running   0              52s\ncilium-vlx9m                             2/2     Running   0              52s\n</code></pre>\n<h4 id=\"安装cilium-cli工具\">安装cilium cli工具</h4>\n<pre><code class=\"language-bash\">wget https://github.com/cilium/cilium-cli/releases/download/v0.19.0/cilium-linux-amd64.tar.gz\ntar xzvfC cilium-linux-amd64.tar.gz /usr/local/bin\n</code></pre>\n<p>查看cilium集群状态：</p>\n<pre><code class=\"language-bash\"># cilium status --wait\n    /¯¯\\\n /¯¯\\__/¯¯\\    Cilium:             OK\n \\__/¯¯\\__/    Operator:           OK\n /¯¯\\__/¯¯\\    Envoy DaemonSet:    OK\n \\__/¯¯\\__/    Hubble Relay:       disabled\n    \\__/       ClusterMesh:        disabled\n\nDaemonSet              cilium                   Desired: 3, Ready: 3/3, Available: 3/3\nDaemonSet              cilium-envoy             Desired: 3, Ready: 3/3, Available: 3/3\nDeployment             cilium-operator          Desired: 2, Ready: 2/2, Available: 2/2\nContainers:            cilium                   Running: 3\n                       cilium-envoy             Running: 3\n                       cilium-operator          Running: 2\n                       clustermesh-apiserver    \n                       hubble-relay             \nCluster Pods:          2/2 managed by Cilium\n</code></pre>\n<h4 id=\"开启和管理hubble\">开启和管理hubble</h4>\n<ol>\n<li>开启hubble进行网络观测：</li>\n</ol>\n<pre><code class=\"language-bash\"># 开启hubble\ncilium hubble enable\n# 开启hubble ui\ncilium hubble enable --ui\n</code></pre>\n<blockquote>\n<p>也可以在chart value.yaml中修改：hubble.relay.enabled=true、hubble.ui.enabled=true</p>\n</blockquote>\n<ol start=\"2\">\n<li>pod启动完毕，修改svc暴露端口给外部访问</li>\n</ol>\n<pre><code class=\"language-bash\"># kubectl get pod -n kube-system | grep hubble\nhubble-relay-66495f87cb-78gpg            1/1     Running   0   16h\nhubble-ui-7bcb645fcd-g99rm               2/2     Running   0   16h\n\n# kubectl get svc -n kube-system | grep ui\nhubble-ui      NodePort    10.96.75.161   &lt;none&gt;        80:32000/TCP             16h\n</code></pre>\n<ol start=\"3\">\n<li>浏览器访问<code>http://192.168.122.171:32000/</code>就可以查看流量转发详情了！</li>\n</ol>\n<h3 id=\"检查k8s集群状态\">检查k8s集群状态</h3>\n<pre><code class=\"language-bash\"># kubectl get nodes \nNAME             STATUS   ROLES           AGE     VERSION\ndemo-master-01   Ready    control-plane   4d18h   v1.35.0\ndemo-master-02   Ready    control-plane   4d18h   v1.35.0\ndemo-worker-01   Ready    &lt;none&gt;          4d18h   v1.35.0\n</code></pre>\n<p>到此，k8s高可用集群已搭建完毕，实际生产环境中，etcd、keepalived、haproxy应尽可能的选择单独的服务器进行部署，且在集群规模较大时，根据实际情况进行优化。</p>\n<h2 id=\"结语\">结语</h2>\n<p>本文以k8s官方的kubeadm工具构建高可用集群，且基本所有服务都是二进制安装的方式，此种方式通用性较强，若您是arm架构机器则需下载对应服务的arm版本的二进制文件即可，步骤几乎相同。目前市面上大多k8s集群自动化部署工具都是采用此种方式安装的。</p>\n<p>本文的目的就是带领大家了解在国产的银河麒麟v11下部署高可用k8s的全过程，顺便理解自动化部署k8s工具的底层逻辑，当然，真正的生产环境大家肯定是优先选择自动化部署，银河麒麟v11官方也推出了自动化部署工具，大家可以尝试着使用一下~</p>\n<p>后续会针对网络插件cilium进行一波网络走向抓包分析，来深入了解一下其原理，欢迎感兴趣的朋友关注。</p>\n<p><strong>最后放一下本次部署所使用到的所有安装包和镜像，<a href=\"https://pan.baidu.com/s/1P-drNSFvcdXMtbEW-G_r5g?pwd=6ui8\" rel=\"noopener nofollow\" target=\"_blank\">点击这里</a>获取。</strong></p>\n<p><strong>参考链接：</strong></p>\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/architecture/cgroups/\" rel=\"noopener nofollow\" target=\"_blank\">关于cgroup v2使用与介绍</a></p>\n<p><a href=\"https://github.com/containerd/containerd/blob/main/docs/getting-started.md\" rel=\"noopener nofollow\" target=\"_blank\">containerd官方部署手册</a></p>\n<p><a href=\"https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\" rel=\"noopener nofollow\" target=\"_blank\">kubeadm、kubelet、kubectl官方部署手册</a></p>\n<p><a href=\"https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/\" rel=\"noopener nofollow\" target=\"_blank\">kubeadm集群安装官方引导手册</a></p>\n<p><a href=\"https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/\" rel=\"noopener nofollow\" target=\"_blank\">容器运行时cgroup驱动官方指导手册</a></p>\n<p><a href=\"https://docs.cilium.io/en/stable/#getting-started\" rel=\"noopener nofollow\" target=\"_blank\">cilium官方指导手册</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 14:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/v-fan\">塔克拉玛攻城狮</a>&nbsp;\n阅读(<span id=\"post_view_count\">69</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "深入理解傅里叶变换",
      "link": "https://www.cnblogs.com/zhaoweiwei/p/19522497/FFT",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zhaoweiwei/p/19522497/FFT\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 14:45\">\n    <span>深入理解傅里叶变换</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文详细介绍傅里叶变换的相关概念，并给出快速傅里叶变换的递归及迭代两种算法源码，最后给出了快速傅里叶变换在音频及图像领用的应用实例！\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>1 基础概念</h1>\n<h2>1.1 傅里叶级数</h2>\n<h3>1 周期函数</h3>\n<p>若函数f(x)满足：存在非零常数T，对任意x有<em>f(x+T) = f(x)</em>，则称<em>f(x)</em>为周期函数，T为其周期；最小正周期称为<strong>基本周期</strong>（记为T<sub>0</sub>）。傅里叶级数中，最常用以2π为周期的函数（T=2π），其他周期的函数可通过变量替换转化为2π周期，因此核心研究2π周期函数。</p>\n<h3>2 三角函数系的正交性</h3>\n<p>傅里叶级数的本质是<span>在三角函数系中对周期函数做正交分解，类似平面向量在x<span>、y轴上的分解，三角函数系就是周期函数空间的一组<span>正交基。</span></span></span></p>\n<p><span><span><span>（1）标准正交三角函数系（2π周期）<br /></span></span></span></p>\n<p><span><span><span><span><span><span>{1,cos<em>x</em>,sin<em>x,</em>cos<em>2x</em>,sin<em>2x</em>,…,cos<em>nx</em>,sin<em>nx</em>,…}</span></span></span></span></span></span></p>\n<div>其中n为正整数，1可以看作cos0x。</div>\n<div>（2）正交性的定义&nbsp;</div>\n<p><span><span><span>对上述三角函数系中<span>任意两个不同的函数<span><span>φ<sub>m</sub>​(x)和<span><span>φ<sub>n​</sub>(x)，满足：</span></span></span></span></span></span></span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123161629850-520864769.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>对同一个函数，积分结果非零：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123161705334-1222793239.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>（3）核心正交积分公式</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123161754523-450618120.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p><strong>正交性的意义</strong>：三角函数系中的各个基函数“互不干扰”，分解后的每个正余弦项的系数可独立计算，这是傅里叶级数能求解的关键。</p>\n<h3>3 傅里叶级数</h3>\n<p>法国数学家傅里叶认为，任何周期函数都可以用正弦函数和余弦函数构成的无穷级数来表示（选择正弦函数与余弦函数作为基函数是因为它们是正交的），后世称傅里叶级数为一种特殊的三角级数，根据欧拉公式，三角函数又能化成指数形式，也称傅立叶级数为一种指数级数。在数学中，三角级数是任何具有下述形式的级数：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123160454187-1477445403.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>当A<sub>n</sub>和B<sub>n</sub>具有以下形式时，该级数称为傅立叶级数：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123160641857-1444839643.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>其中f(x)是可积函数。下面给出2π周期函数的傅里叶级数定义：</p>\n<p>设f(x)是以2π为周期的函数，且在[-π,&nbsp;π]上可积，则其傅里叶级数为：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123162203699-209431809.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>符号说明：</p>\n<p>~：表示“展开为傅里叶级数”，而非严格相等（需满足收敛条件才相等）；</p>\n<p>a<sub>0</sub>/2：直流分量/零频项，是函数f(x)在一个周期内的平均值；</p>\n<p>a<sub>n</sub>cos<em>&nbsp;nx</em>：余弦项/偶次谐波，对应周期函数的偶函数分量；</p>\n<p>b<sub>n</sub>sin<em> nx</em>：正弦项/奇次谐波，对应周期函数的奇函数分量；</p>\n<p>a<sub>0</sub>, a<sub>n</sub>, b<sub>n</sub>：傅里叶系数，是唯一确定的常数，有f(x)决定。</p>\n<h2>1.2 傅里叶变换</h2>\n<h3>1 欧拉公式（Euler’s formula）</h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123163235634-1712793922.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>其中：e是自然常数，约等于2.71828，i是虚数单位满足i<sup>2</sup>=-1，θ是复指数的辐角∈R，对应复平面上的旋转角度。对于该公式当θ=π时，有e<sup>iπ</sup> + 1 = 0，这个公式在傅里叶变换中起到关键作用。</p>\n<h3>2 傅里叶变换（Fourier Transform, FT）</h3>\n<p>傅里叶变换是将时域的连续函数映射到频域连续函数的数学变换，是调和分析的核心工具，揭示了“任意连续周期/非周期函数均可分解为不同频率的正弦/余弦函数叠加”的本质。现给出连续傅里叶变换（Continuous Fourier Transform, CFT）相关定义，适用于定义域为全体实数R、满足狄利克雷条件（Dirichlet）的连续函数f(t)，其中t为时域自变量（通常表示时间），变换后得到频域函数F(ω)，ω为角频率（rad/s）。</p>\n<p>（1）正变换（时域→频域）</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123170719778-789709355.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>积分区间(−∞,+∞)对应非周期函数的时域是无限的，需对全体实数域积分，变换本质是：用所有频率的复指数函数作为“基函数”，对<span class=\"katex\"><span class=\"katex-mathml\">f(t)<span class=\"katex-html\"><span class=\"base\"><span class=\"strut\"><span class=\"mord mathnormal\"><span class=\"mopen\"><span class=\"mord mathnormal\"><span class=\"mclose\">做投影。</span></span></span></span></span></span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\"><span class=\"mord mathnormal\"><span class=\"mopen\"><span class=\"mord mathnormal\"><span class=\"mclose\">（2）逆变换（频域→时域）</span></span></span></span></span></span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\"><span class=\"mord mathnormal\"><span class=\"mopen\"><span class=\"mord mathnormal\"><span class=\"mclose\">傅里叶变换是可逆变换，从频域函数F(ω)还原时域f(t)的公式为：</span></span></span></span></span></span></span></span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123171313838-843336180.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>关键系数1/2π：该系数是为了满足“正逆变换的归一性”，也有教材将系数拆分为1/sqrt(<span><span>2π​)分别放在正、逆变换中（数学上更对称），两种形式等价。<br /></span></span></p>\n<h3><span><span>3 离散傅里叶变换（Discrete Fourier Transform，DFT）</span></span></h3>\n<p>DFT是一种线性变换，把一个有限长的离散序列，从“时间/系数域”变换到“频率/点值域”。其数学定义为给定长度为n的复数序列：<em>x=(x<sub>0</sub>, x<sub>1</sub>, ..., x<sub>n-1</sub>)</em>，令：<em>ω = e<sup>-2πi/n</sup></em>，定义其离散傅里叶变换（DFT）为序列：</p>\n<p><img alt=\"image\" height=\"70\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260128155659439-1976105299.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"321\" /></p>\n<p><em>x<sub>j</sub></em>是输入序列（时域信号），<em>X<sub>k</sub></em>是输出序列（频域信号），通过将时域信号与一系列不同频率的复指数函数进行内积，得到每个频率分量在原始信号中的“含量”。DFT是一个线性变换，本质是<em>X = F*x</em>，其中F是一个范德蒙德（Vandermonde）矩阵，即从线性代数角度看：DFT = Vandermonde变换。从矩阵运算可以看出，要得到每个频率分量，需要进行n次乘法和n-1次加法运算，完成整个变换需要n<sup>2</sup>次乘法和n(n-1)次加法运算，所以完整变换的复杂度是O(n<sup>2</sup>)，当序列长度n较大时，计算量会变得极其庞大，限制了DFT在实际应用中的效率。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260128155733599-751298943.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>以多项式<em>A(x)=a<sub>0</sub>+a<sub>1</sub>x+a<sub>2</sub>x<sup>2</sup>+...+a<sub>n-1</sub>x<sup>n-1</sup></em>为例，则上述离散序列可以看作是多项式系数表示法（coefficient form）中的系数，即<em>x = a = (a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n-1</sub>）</em>，选择特殊的“点”——n次单位根：<em>ω = e<sup>2πi/n</sup></em>，它满足：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260128124328491-889419062.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>以n=11为例，图中所有<em>ω<sup>i</sup></em>都是11次单位根：</p>\n<p><img alt=\"image\" height=\"314\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129102811489-1505291339.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"322\" /></p>\n<p>考虑n个互不相同的点：<em>1,&nbsp;ω,&nbsp;ω<sup>2</sup>, ...,&nbsp;ω<sup>n-1</sup></em>，将其代入<em>A(x)</em>多项式，则有：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260128125054218-1282377609.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可见<em>X<sub>k</sub> = A(ω<sup>-k</sup>)</em>，即DFT的计算结果，恰好等价于在单位根上的多项式求值（对应多项式的点值表示法）。</p>\n<p>逆离散傅里叶变换（IDFT）由以下公式给出：</p>\n<p><img alt=\"image\" height=\"77\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260128181138702-2110135213.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"162\" /></p>\n<p>傅里叶级数、傅里叶变换和DFT区别由下表给出：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260128171836655-1924902784.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h3>4 快速傅里叶变换（Fast Fourier Transform，FFT）</h3>\n<p>1965年，J.W.库利和T.W.图基提出了著名的Cooley-Tukey算法，即快速傅里叶变换（FFT）。FFT算法的核心是利用旋转因子的周期性、对称性和可约性，将长序列的DFT分解为短序列的DFT，从而大幅减少计算量。首先给出单位根的三个引理：</p>\n<p><img alt=\"image\" height=\"93\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129104718146-1091039001.png\" width=\"272\" /></p>\n<p>一句话概括FFT：利用n次单位根的周期性与对称性，把一个规模为n的DFT，拆成两个规模为N/2的DFT。在经典FFT算法（Cooley-Tukey算法）中假设n=2<sup>m</sup>，把序列拆成“偶数项+奇数项”：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129115917584-129576767.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>则可以将DFT拆开：</p>\n<p><img alt=\"image\" height=\"81\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129120821297-7172978.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"532\" /></p>\n<p>利用折半引理可将上式简化为：</p>\n<p><img alt=\"image\" height=\"34\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129122101594-403839310.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"196\" /></p>\n<p>其中：</p>\n<p><img alt=\"image\" height=\"172\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129122526097-623129615.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"213\" /></p>\n<p>以上将1个包含n次乘法的DFT分成两个n/2次乘法的DFT，另外由ω<sub>n</sub><sup>n/2+k</sup> = -ω<sub>n</sub><sup>k</sup>可以进一步得到迭代公式（1）：</p>\n<p><img alt=\"image\" height=\"78\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260130174113532-1641485917.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"376\" /></p>\n<p>以上就是所谓的蝶形运算（butterfly），一次算出两个输出。可见一个长度为n的DFT被拆成两个长度是n/2的DFT和n/2次蝶形合并，所以时间复杂度为：</p>\n<p><img alt=\"image\" height=\"29\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129143456252-107829582.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"237\" /></p>\n<p>这里<em>2T(n/2)</em>表示：要解决一个规模为<em>n</em>的问题，需要“调用两次”规模为<em>n/2</em>的同类问题，每一次的代价是<em>T(n/2)</em>；<em>cn</em>表示：当前这一层，为了把两个子FFT的结果“合并”所做的计算量。一个标准的radix-2蝶形：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129142325972-1041311975.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>需要：1次复数乘法<em>ωb</em>和2次复数加减法，都是常数级操作可记为O(1)，对于长度为n的FFT每一层有n/2个蝶形，所以每层蝶形计算量是n/2xO(1)=O(n)，可以记为cn，这里的c就是一个蝶形需要多少个“基础运算”的常数因子。所以随着层数递增有以下时间复杂度推导：</p>\n<p><img alt=\"image\" height=\"153\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129144210035-167113917.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"489\" /></p>\n<p>递归终止条件是当：<em>n/2<sup>k</sup>=1</em>，这时<em>k=log<sub>2</sub>n</em>，上述推导最终结果为：<em>T(n)=n*T(1)+cnlog<sub>2</sub>n</em>，忽略常数得最终复杂度公式<em>T(n)=O(nlog<sub>2</sub>n)</em>。</p>\n<p>以上给出了快速傅里叶变换，快速傅里叶逆变换（IFFT，Inverse FFT）定义及分析过程与正变换类似，为了公式简洁正变换分析过程取<em>ω = e<sup>-2πi/n</sup></em>，实际上在严格的数学定义中一般取<em>ω = e<sup>2πi/n</sup></em>（正向单位根），此时正变换和逆变换定义如下：</p>\n<p><img alt=\"image\" height=\"190\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129155724698-1691263367.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"412\" /></p>\n<p>正变换用于拆解信号，获取在正交基上的投影，逆变换用于合成信号，完成正交基投影的叠加。</p>\n<h2>1.3 NTT（Number Theoretic Transform）</h2>\n<p>NTT = 在有限域/模整数环中进行的FFT，即NTT是把FFT中的“复数单位根”换成了“模意义下的单位根”，结构完全一致，只是“数域”不同。FFT主要存在3方面问题：用的是复数、有浮点误差、在密码学/大整数/精确多项式运算中不可接受，而NTT正好可以解决这些问题。NTT工作空间是有限域，通常选F<em><sub>p</sub></em>，<em>p</em>是素数，所有运算都基于mod <em>p</em>，在NTT中，需要找ω（模p下的n次原始单位根），它满足：</p>\n<p><img alt=\"image\" height=\"34\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129161753182-2114601709.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"527\" /></p>\n<p>设模数p，n|(p-1)，ω是n次原始单位根，NTT相关定义如下：</p>\n<p><img alt=\"image\" height=\"201\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129162400466-958332138.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"473\" /></p>\n<p>和FFT相关对比如下：</p>\n<p><img alt=\"image\" height=\"229\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129162541142-569885544.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"668\" /></p>\n<h1>2 算法实现</h1>\n<p>理解了FFT的数学原理后，我们需要将其转化为可执行的代码。FFT算法有多种实现方式，包括递归实现、迭代实现和基于特定平台的优化实现。</p>\n<h2>2.1 递归实现FFT</h2>\n<p>递归实现是最直观的FFT实现方式，它直接对应Cooley-Tukey算法的分治思想。递归算法不断将问题分解为更小的子问题，直到达到基本情况（2点或1点DFT）。</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_ffe0d173-e88c-4224-89a8-11075c1c927d\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_ffe0d173-e88c-4224-89a8-11075c1c927d\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_ffe0d173-e88c-4224-89a8-11075c1c927d\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> numpy as np\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> matplotlib.pyplot as plt\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设置字体，确保中文显示</span>\nplt.rcParams[<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">font.sans-serif</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>] = [<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">SimHei</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">]\nplt.rcParams[</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">axes.unicode_minus</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>] =<span style=\"color: rgba(0, 0, 0, 1);\"> False\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> fft_recursive(x):\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\n    递归实现快速傅里叶变换\n    注意：输入向量x的长度必须是2的幂次\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    n </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> len(x)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> n == 1<span style=\"color: rgba(0, 0, 0, 1);\">:\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> x\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 分别计算偶数索引和奇数索引元素的FFT</span>\n    even_fft = fft_recursive(x[0::2])  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 偶数索引</span>\n    odd_fft = fft_recursive(x[1::2])   <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 奇数索引</span>\n    \n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算旋转因子</span>\n    w = [np.exp(-2j * np.pi * k / n) <span style=\"color: rgba(0, 0, 255, 1);\">for</span> k <span style=\"color: rgba(0, 0, 255, 1);\">in</span> range(n//2<span style=\"color: rgba(0, 0, 0, 1);\">)]\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 组合结果</span>\n    result = np.zeros(n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">complex)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> k <span style=\"color: rgba(0, 0, 255, 1);\">in</span> range(n//2<span style=\"color: rgba(0, 0, 0, 1);\">):\n        term </span>= w[k] *<span style=\"color: rgba(0, 0, 0, 1);\"> odd_fft[k]\n        result[k] </span>= even_fft[k] +<span style=\"color: rgba(0, 0, 0, 1);\"> term\n        result[k </span>+ n//2] = even_fft[k] -<span style=\"color: rgba(0, 0, 0, 1);\"> term\n        \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 测试递归FFT</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> test_fft_recursive():\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成测试信号：50Hz和120Hz正弦波的叠加</span>\n    fs = 1000  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 采样频率1000Hz</span>\n    t = np.linspace(0, 1, 1024)  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1秒时间，1024个点</span>\n    signal = np.sin(2 * np.pi * 50 * t) + 0.5 * np.sin(2 * np.pi * 120 *<span style=\"color: rgba(0, 0, 0, 1);\"> t)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算FFT</span>\n    fft_result =<span style=\"color: rgba(0, 0, 0, 1);\"> fft_recursive(signal)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算频率轴</span>\n    freqs = np.fft.fftfreq(len(signal), 1/<span style=\"color: rgba(0, 0, 0, 1);\">fs)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span><span style=\"color: rgba(0, 0, 0, 1);\">(len(freqs))\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 绘制结果</span>\n    plt.figure(figsize=(12, 4<span style=\"color: rgba(0, 0, 0, 1);\">))\n    \n    plt.subplot(</span>1, 2, 1<span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.plot(t, signal)\n    plt.title(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">原始信号</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.xlabel(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">时间 (s)</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.ylabel(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">幅度</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    plt.subplot(</span>1, 2, 2<span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.plot(freqs[:len(freqs)</span>//2], np.abs(fft_result[:len(fft_result)//2<span style=\"color: rgba(0, 0, 0, 1);\">]))\n    plt.title(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">频谱图</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.xlabel(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">频率 (Hz)</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.ylabel(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">幅度</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.xlim(0, </span>200<span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    plt.tight_layout()\n    plt.show()\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> <span style=\"color: rgba(128, 0, 128, 1);\">__name__</span> == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">__main__</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n    test_fft_recursive()</span></pre>\n</div>\n<span class=\"cnblogs_code_collapse\">递归FFT</span></div>\n<p>程序中以50Hz和120Hz正弦波叠加产生测试信号，通过FFT变换可以这两个信号快速的过滤出来：</p>\n<p><img alt=\"image\" height=\"364\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129174352141-1064981846.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"939\" /></p>\n<p>递归实现虽然直观，但存在一些缺点：</p>\n<p>1. 递归调用会产生额外的函数调用开销</p>\n<p>2. 需要不断创建新的子数组，内存使用不够高效</p>\n<p>3. 对于大数组，可能导致递归深度过大</p>\n<p>因此，在实际应用中，迭代实现通常更受青睐。</p>\n<h2>2.2 迭代实现FFT</h2>\n<p>迭代FFT算法通过循环而非递归实现计算，效率更高。迭代算法的核心是首先对输入数组进行位反序排列，然后通过多层循环实现蝶形运算。首先以n=8为例，看下<em>X<sub>0</sub></em>的重排序，由于ω<sup>0</sup>=1则根据DFT公式可知：</p>\n<p><img alt=\"image\" height=\"93\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260130173927906-1454035592.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"532\" /></p>\n<p>观察以下二进制下标，可知重排序后的二进制下标正是正序下标二进制的逆序，把这种序列叫做逆二进制序：</p>\n<div class=\"cnblogs_code\">\n<pre> 0   4   2   6   1   5   3   7\n000 100 010 110 001 101 011 111\n\n000 001 010 011 100 101 110 111<span style=\"color: rgba(0, 0, 0, 1);\">\n 0   </span>1   2   3   4   5   6   7</pre>\n</div>\n<p>同理可以给出<em>X<sub>1</sub></em>及<em>X<sub>4</sub></em>=<em>X<sub>0+8/2</sub></em>的迭代计算过程：</p>\n<p><img alt=\"image\" height=\"288\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260130173556716-1214216164.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"638\" /></p>\n<p><em>X<sub>0</sub></em>和<em>X<sub>4</sub></em>完全对应迭代公式（1），实际上所有<em>X<sub>k</sub></em>计算过程可以由以下二叉树给出：</p>\n<p><img alt=\"binary_tree\" height=\"214\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260130171140920-240111198.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"616\" /></p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_1cf16b4b-2e15-4529-ab65-a62ba19cd246\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_1cf16b4b-2e15-4529-ab65-a62ba19cd246\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_1cf16b4b-2e15-4529-ab65-a62ba19cd246\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">  1</span> <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> numpy as np\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  2</span> <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> matplotlib.pyplot as plt\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  3</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">  4</span> <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设置字体，确保中文显示</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">  5</span> plt.rcParams[<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">font.sans-serif</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>] = [<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">SimHei</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">]\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  6</span> plt.rcParams[<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">axes.unicode_minus</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>] =<span style=\"color: rgba(0, 0, 0, 1);\"> False\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  7</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">  8</span> <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> bit_reverse(n, num_bits):\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  9</span>     <span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">将n的二进制表示进行位反序</span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 10</span>     reversed_n =<span style=\"color: rgba(0, 0, 0, 1);\"> 0\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 11</span>     <span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(num_bits):\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 12</span>         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> n &amp; (1 &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> i):\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 13</span>             reversed_n |= (1 &lt;&lt; (num_bits - 1 -<span style=\"color: rgba(0, 0, 0, 1);\"> i))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 14</span>     <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> reversed_n\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 15</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 16</span> <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> fft_iterative(x):\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 17</span>     <span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 18</span> <span style=\"color: rgba(128, 0, 0, 1);\">    迭代实现快速傅里叶变换\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 19</span> <span style=\"color: rgba(128, 0, 0, 1);\">    输入x的长度必须是2的幂次\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 20</span>     <span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 21</span>     n =<span style=\"color: rgba(0, 0, 0, 1);\"> len(x)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 22</span>     num_bits =<span style=\"color: rgba(0, 0, 0, 1);\"> int(np.log2(n))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 23</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 24</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 位反序排列</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 25</span>     reversed_index = [bit_reverse(i, num_bits) <span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(n)]\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 26</span>     data =<span style=\"color: rgba(0, 0, 0, 1);\"> x[reversed_index].astype(complex)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 27</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 28</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 迭代计算FFT</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 29</span>     size = 2\n<span style=\"color: rgba(0, 128, 128, 1);\"> 30</span>     <span style=\"color: rgba(0, 0, 255, 1);\">while</span> size &lt;=<span style=\"color: rgba(0, 0, 0, 1);\"> n:\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 31</span>         half_size = size // 2\n<span style=\"color: rgba(0, 128, 128, 1);\"> 32</span>         <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算旋转因子</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 33</span>         w_m = np.exp(-2j * np.pi /<span style=\"color: rgba(0, 0, 0, 1);\"> size)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 34</span>         \n<span style=\"color: rgba(0, 128, 128, 1);\"> 35</span>         <span style=\"color: rgba(0, 0, 255, 1);\">for</span> k <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(0, n, size):\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 36</span>             w = 1\n<span style=\"color: rgba(0, 128, 128, 1);\"> 37</span>             <span style=\"color: rgba(0, 0, 255, 1);\">for</span> j <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(half_size):\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 38</span>                 t = w * data[k + j +<span style=\"color: rgba(0, 0, 0, 1);\"> half_size]\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 39</span>                 u = data[k +<span style=\"color: rgba(0, 0, 0, 1);\"> j]\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 40</span>                 data[k + j] = u +<span style=\"color: rgba(0, 0, 0, 1);\"> t\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 41</span>                 data[k + j + half_size] = u -<span style=\"color: rgba(0, 0, 0, 1);\"> t\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 42</span>                 w *=<span style=\"color: rgba(0, 0, 0, 1);\"> w_m\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 43</span>         size *= 2\n<span style=\"color: rgba(0, 128, 128, 1);\"> 44</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 45</span>     <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> data\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 46</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 47</span> <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 测试迭代FFT</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 48</span> <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> test_fft_iterative():\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 49</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成测试信号</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 50</span>     n = 256  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 数据点个数，必须是2的幂次</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 51</span>     fs = 1000  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 采样频率</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 52</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 53</span>     t = np.linspace(0, 1<span style=\"color: rgba(0, 0, 0, 1);\">, n)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 54</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成包含多个频率成分的信号</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 55</span>     signal = (np.sin(2 * np.pi * 50 * t) + \n<span style=\"color: rgba(0, 128, 128, 1);\"> 56</span>               0.5 * np.sin(2 * np.pi * 120 * t) + \n<span style=\"color: rgba(0, 128, 128, 1);\"> 57</span>               0.3 * np.sin(2 * np.pi * 200 *<span style=\"color: rgba(0, 0, 0, 1);\"> t))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 58</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 59</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 添加噪声</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 60</span>     noise = 0.2 * np.random.normal(size=<span style=\"color: rgba(0, 0, 0, 1);\">n)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 61</span>     signal +=<span style=\"color: rgba(0, 0, 0, 1);\"> noise\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 62</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 63</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算FFT</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 64</span>     fft_result =<span style=\"color: rgba(0, 0, 0, 1);\"> fft_iterative(signal)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 65</span>     freqs = np.fft.fftfreq(n, 1/<span style=\"color: rgba(0, 0, 0, 1);\">fs)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 66</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 67</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 与NumPy内置FFT对比</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 68</span>     np_fft =<span style=\"color: rgba(0, 0, 0, 1);\"> np.fft.fft(signal)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 69</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 70</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 绘制结果</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 71</span>     plt.figure(figsize=(15, 5<span style=\"color: rgba(0, 0, 0, 1);\">))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 72</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 73</span>     plt.subplot(1, 3, 1<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 74</span> <span style=\"color: rgba(0, 0, 0, 1);\">    plt.plot(t, signal)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 75</span>     plt.title(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">原始信号 (含噪声)</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 76</span>     plt.xlabel(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">时间 (s)</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 77</span>     plt.ylabel(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">幅度</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 78</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 79</span>     plt.subplot(1, 3, 2<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 80</span>     plt.plot(freqs[:n//2], np.abs(fft_result[:n//2]), label=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">自定义FFT</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 81</span>     plt.title(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">自定义FFT频谱</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 82</span>     plt.xlabel(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">频率 (Hz)</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 83</span>     plt.ylabel(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">幅度</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 84</span>     plt.xlim(0, 300<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 85</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 86</span>     plt.subplot(1, 3, 3<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 87</span>     plt.plot(freqs[:n//2], np.abs(np_fft[:n//2]), label=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">NumPy FFT</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, color=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">orange</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 88</span>     plt.title(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">NumPy FFT频谱</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 89</span>     plt.xlabel(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">频率 (Hz)</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 90</span>     plt.ylabel(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">幅度</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 91</span>     plt.xlim(0, 300<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 92</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 93</span> <span style=\"color: rgba(0, 0, 0, 1);\">    plt.tight_layout()\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 94</span> <span style=\"color: rgba(0, 0, 0, 1);\">    plt.show()\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 95</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 96</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算误差</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 97</span>     error = np.max(np.abs(fft_result -<span style=\"color: rgba(0, 0, 0, 1);\"> np_fft))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 98</span>     <span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">与NumPy FT的最大误差: {error}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 99</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">100</span> <span style=\"color: rgba(0, 0, 255, 1);\">if</span> <span style=\"color: rgba(128, 0, 128, 1);\">__name__</span> == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">__main__</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n</span><span style=\"color: rgba(0, 128, 128, 1);\">101</span>     test_fft_iterative()</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">迭代FFT</span></div>\n<p>仍以n=8为例，迭代算法中首先对输入进行二进制的逆序，然后进行3个阶段的蝶形计算，第1个阶段由相邻点产生下一级的输出，第2个阶段由间隔一个点的输入产生输出，第3个节点由间隔两个点的输出产生输出，蝴蝶由瘦变胖，如下图所示：</p>\n<p><img alt=\"image\" height=\"539\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260203124707004-1989410463.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"970\" /></p>\n<h1>3 应用实例</h1>\n<h2>3.1 音频处理中的应用</h2>\n<p>FFT（快速傅里叶变换）是音频领域的核心数字信号处理工具，本质是将音频的时域信号（随时间变化的声波振幅）转换为频域信号（不同频率的声音分量占比），而人耳对声音的感知本身就是基于频率的（如音调、音色），这使得 FFT 成为音频采集、分析、处理、合成全链路的基础。</p>\n<h3>1 音频基础分析</h3>\n<p>所有音频智能分析的前提，核心是将不可直接解读的时域波形，转换为可量化的频率特征。</p>\n<p><strong>核心逻辑</strong></p>\n<p>（1）音频在计算机中是采样率固定的时域离散数据（如44.1kHz采样率 = 1秒采集44100个振幅值），波形仅能反映声音的强弱变化，无法直接得到音调、音色等关键信息；</p>\n<p>（2）对时域音频段执行一维 FFT，得到频谱（横坐标为频率，纵坐标为对应频率的振幅/能量），频谱直接反映 “哪些频率的声音构成了当前音频”；</p>\n<p>（3）针对非平稳音频（声音频率随时间变化，如说话、唱歌、乐器演奏），采用STFT（短时傅里叶变换）：将音频切分为连续的短帧（如20ms/帧），对每帧独立做FFT，最终得到时频图（横轴时间，纵轴频率，颜色 / 亮度表示能量），实现 “时间-频率” 的二维分析。</p>\n<p><strong>典型应用</strong></p>\n<p>音频软件的频谱分析仪（如 Audition、Cool Edit）：实时显示音频的频率分布，帮助调音师判断声音的频率缺陷；</p>\n<p>基础音频特征提取：通过 FFT 计算基频（Fundamental Frequency，F0）（声音的基础音调，如男声基频 80-200Hz，女声 200-500Hz）、谐波（基频的整数倍频率，决定音色）、频谱能量（决定声音响度）。</p>\n<h3>2 音调检测与音高识别（Pitch Detection）</h3>\n<p>音调是音频最核心的感知特征之一，FFT是实现音高识别的经典算法基础，广泛用于K歌评分、乐器校音、语音识别。</p>\n<p><strong>核心逻辑</strong></p>\n<p>（1）纯音（如钢琴单键）的时域波形是周期性的，其频域频谱中能量最高的频率即为基频（F0），对应听觉上的音调；</p>\n<p>（2）对乐器/人声的混合音频，通过FFT得到频谱后，筛选出基频峰（主峰值）和其谐波峰，通过峰值检测算法确定实际音高；</p>\n<p>（3）工程中会结合自相关法优化FFT的基频检测，解决低信噪比、谐波干扰下的检测误差问题。</p>\n<p><strong>典型应用</strong></p>\n<p>（1）乐器校音软件（如吉他校音器、钢琴校音器）：实时采集乐器声音，通过FFT检测基频，对比标准音高（如 A4=440Hz）给出校音提示；</p>\n<p>（2）K歌APP的音高评分（如唱吧、全民K歌）：实时分析演唱声音的基频，与原唱基频对比，判断音准并打分；</p>\n<p>（3）音乐乐谱自动转写：将演奏音频转换为五线谱，核心是通过 FFT 逐帧检测音高并匹配对应音符。</p>\n<h3>3&nbsp;音频滤波：精准去除噪声/保留目标频率</h3>\n<p>音频滤波是FFT最常用的处理类应用，相比传统的模拟滤波，基于FFT的频域滤波更灵活、精准，可实现任意自定义的频率筛选，核心是 “频域修改，时域重构”。</p>\n<p><strong>核心逻辑（与图像 FFT 压缩原理同源）</strong></p>\n<p>（1）时域→频域：对音频帧执行 FFT，得到频域系数；</p>\n<p>（2）频域滤波：根据需求生成频率掩码，对频域系数做修改：&nbsp; &nbsp;</p>\n<p>&nbsp; &nbsp; 低通滤波：保留低频系数，置零高频系数（如去除音频中的高频嘶嘶噪声）；</p>\n<p>&nbsp; &nbsp; 高通滤波：保留高频系数，置零低频系数（如去除音频中的低频底噪、电流声）；</p>\n<p><em>&nbsp; &nbsp;&nbsp;</em>带通滤波：仅保留指定频率区间的系数（如提取人声音频，保留 300-3400Hz 的人声核心频率）；</p>\n<p>&nbsp; &nbsp; 带阻滤波 / 陷波滤波：置零指定频率区间的系数（如去除 50Hz/60Hz 的市电工频噪声）；</p>\n<p>（3）频域→时域：对滤波后的频域系数执行逆 FFT（IFFT），转换回时域音频，得到滤波后的声音。</p>\n<p><strong>典型应用</strong></p>\n<p>（1）语音降噪（如会议录音、麦克风降噪）：通过FFT去除背景中的低频底噪、高频环境噪声，保留人声；</p>\n<p>（2）音乐制作中的均衡器（EQ）：对音乐的低频、中频、高频分别做增益 / 衰减（本质是修改FFT后的频域系数振幅），调整音乐的音色层次；</p>\n<p>（3）广播/直播的音频处理：过滤掉人声外的无效频率，提升声音的清晰度。</p>\n<h3>4&nbsp;声音合成与音色模拟（加法合成 / 调频合成）</h3>\n<p>声音的音色由“基频+谐波的频率分布比例”决定，FFT为音色的量化和合成提供了基础，是电子音乐、语音合成的核心技术之一。</p>\n<p><strong>核心逻辑</strong></p>\n<p>（1）音色的频域本质：不同乐器的同一音调（基频相同），音色不同的原因是谐波的数量、振幅占比不同（如钢琴的谐波丰富且高频衰减快，小提琴的高频谐波更突出）；</p>\n<p>（2）加法合成：通过 FFT 分析目标乐器的频谱（基频 + 各谐波的能量比例），然后用多个正弦波（对应基频和各谐波）按该比例叠加，合成出与目标乐器相似的音色；</p>\n<p>（3）语音合成（TTS）：对真人语音做 FFT 分析，得到不同音节的频谱特征，合成时通过调整基频和频谱分布，生成自然的人工语音。</p>\n<p><strong>典型应用</strong></p>\n<p>（1）电子音乐合成器（如FL Studio、Ableton Live）：基于 FFT 的频谱分析，模拟钢琴、吉他、弦乐等传统乐器的音色，或制作自定义的电子音色；</p>\n<p>（2）语音合成引擎（如讯飞TTS、百度TTS）：通过 FFT 提取语音的频谱特征，提升合成语音的自然度；</p>\n<p>（3）声音特效制作：如将人声转换为机器人声（通过FFT修改频谱，压制谐波，保留基频）。</p>\n<h3>5&nbsp;音频特征提取与智能分析（AI / 机器学习基础）</h3>\n<p>当下的音频智能应用（如语音识别、声纹识别、音频分类），其核心特征均基于 FFT 的频域分析，FFT 是连接原始音频数据和 AI 模型的桥梁。</p>\n<p><strong>核心逻辑</strong></p>\n<p>（1）原始时域音频数据维度高、冗余大，无法直接输入AI模型；</p>\n<p>（2）通过 FFT/STFT 将音频转换为频域特征，再进一步提取梅尔频谱（Mel Spectrogram）、梅尔频率倒谱系数（MFCC） 等工程化特征：</p>\n<p>&nbsp; &nbsp; 梅尔频谱：将 FFT 得到的线性频谱转换为符合人耳听觉特性的梅尔刻度频谱（人耳对低频更敏感，对高频更迟钝）；</p>\n<p>&nbsp; &nbsp; MFCC：对梅尔频谱做离散余弦变换（DCT），提取的低维系数，是语音识别、声纹识别的经典核心特征；</p>\n<p>（3）这些频域特征维度低、辨识度高，是语音识别、音频分类模型的标准输入。</p>\n<p><strong>典型应用</strong></p>\n<p>（1）语音识别（ASR）：如微信语音转文字、讯飞听见，核心特征是MFCC，其提取基础是FFT/STFT；</p>\n<p>（2）声纹识别：如手机声纹解锁、银行语音验证，通过 FFT 分析不同人的语音频谱特征（声纹），实现身份识别；</p>\n<p>（3）音频分类：如短视频的背景音乐识别、环境声检测（如哭声、玻璃破碎声、汽车鸣笛声），基于梅尔频谱做模型训练，而梅尔频谱的基础是FFT；</p>\n<p>（4）音乐推荐：通过FFT分析歌曲的频谱特征（如低频能量占比、节奏对应的频率变化），对歌曲做分类，实现个性化推荐。</p>\n<h3>6&nbsp;音频同步与匹配（如音频指纹、音视频同步）</h3>\n<p>（1）音频指纹（Audio Fingerprint）</p>\n<p>核心是通过FFT对音频的时频特征做提取，生成唯一的 “音频指纹”，实现音乐识别、音频查重。如摇一摇识曲（QQ音乐、网易云音乐），通过FFT提取待识别音频的时频特征，与服务器中的音频指纹库匹配，快速识别歌曲名称。</p>\n<p>（2）音视频同步</p>\n<p>视频的画面帧与音频的时间轴易出现错位，通过FFT分析音频的频谱特征变化，与视频的画面特征变化做时间对齐，实现音视频同步校正。</p>\n<h2>3.2&nbsp;图像处理中的应用</h2>\n<p>FFT在图像处理中主要用于频域滤波、图像压缩、纹理分析等。接下来以图像压缩为例进行说明。</p>\n<p>图像在计算机中以像素矩阵存储，这是空间域表示：每个数值代表对应位置的亮度/颜色，直观描述图像的空间分布，但数据冗余度高。频域是通过傅里叶变换得到的另一种表示形式，将图像分解为不同频率的正弦/余弦波叠加，频率描述的是像素值的变化快慢：</p>\n<p><strong>低频分量：</strong>像素值变化缓慢，对应图像的整体轮廓、大面积平滑区域、主体结构（如人脸轮廓、天空背景）；</p>\n<p><strong>高频分量：</strong>像素值变化剧烈，对应图像的细节纹理、边缘、噪声、微小瑕疵（如发丝、文字边缘、噪点）。</p>\n<p>人眼的视觉特性与图像频域特性高度匹配：</p>\n<p>人眼对整体轮廓、大面积区域（低频信息）高度敏感，是识别图像的核心依据；</p>\n<p>人眼对精细纹理、微小噪声（高频信息）敏感度较低，适度舍弃后，肉眼难以察觉明显失真；</p>\n<p>结合这一特性，FFT 压缩可以在保证主观视觉质量的前提下，实现可观的数据压缩。举个例子：一张风景照，蓝天、山脉轮廓是低频核心信息，树叶纹理、水面波纹是高频信息，舍弃 80% 高频系数后，图像依然可清晰识别，仅会轻微模糊。</p>\n<p>图像是二维信号，需要使用二维离散傅里叶变换（2D-DFT）完成空间域到频域的转换，FFT图像压缩的本质是利用频域能量分布的不对称性，实现有损数据压缩，完整逻辑分为4个核心步骤：</p>\n<p><strong>步骤 1：空间域 → 频域转换（FFT）</strong></p>\n<p>对图像（或图像分块）执行二维FFT，将像素值转换为频域系数（复数形式，包含幅度和相位信息）。变换后，默认低频系数分布在频域矩阵的四角，高频在中心；通过fftshift中心化后，低频集中在矩阵中心，高频分布在四周，方便筛选处理。</p>\n<p><strong>步骤 2：频域系数量化与截断（核心压缩操作）</strong></p>\n<p>基于能量集中特性执行压缩操作：</p>\n<p>（1）保留携带绝大部分图像能量的低频系数；</p>\n<p>（2）直接舍弃/置零仅携带少量细节、噪声的高频系数；</p>\n<p>（3）舍弃的高频信息越多，压缩率越高，图像失真越明显。</p>\n<p>一般通过计算频域点到中心的欧式距离筛选低频系数，距离中心越近，频率越低，这是最常用的低频筛选方式。</p>\n<p><strong>步骤 3：逆变换重构图像（逆 FFT）</strong></p>\n<p>对处理后的频域系数执行逆移位（ifftshift）+ 逆FFT（ifft2），将频域信号转换回空间域，得到压缩重构后的图像。由于逆 FFT 结果会存在微小虚部（浮点计算误差），只需提取实部即可得到有效像素值。</p>\n<p><strong>步骤 4：数据存储优化</strong></p>\n<p>原始图像存储每个像素的空间域数据，而压缩后仅需存储少量保留的低频系数，大幅减少数据量，实现存储/传输的压缩效果。</p>\n<p>以下是源码：</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_564b0e2b-3c0a-40e5-9f1d-bc59a1cd04b7\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_564b0e2b-3c0a-40e5-9f1d-bc59a1cd04b7\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_564b0e2b-3c0a-40e5-9f1d-bc59a1cd04b7\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> numpy as np\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> matplotlib.pyplot as plt\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> matplotlib.image as mpimg\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> os\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> math <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> log10, sqrt\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> PIL <span style=\"color: rgba(0, 0, 255, 1);\">import</span> Image  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 新增：用PIL保存图像，兼容所有版本</span>\n\n<span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设置中文显示</span>\nplt.rcParams[<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">font.sans-serif</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>] = [<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">SimHei</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">]\nplt.rcParams[</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">axes.unicode_minus</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>] =<span style=\"color: rgba(0, 0, 0, 1);\"> False\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> psnr(original, compressed):\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">计算峰值信噪比（PSNR），兼容彩色/灰度图</span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 若原始图像是彩色图，先转为灰度图再计算PSNR</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> len(original.shape) == 3<span style=\"color: rgba(0, 0, 0, 1);\">:\n        original_gray </span>= np.mean(original, axis=2<span style=\"color: rgba(0, 0, 0, 1);\">).astype(np.uint8)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        original_gray </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> original.astype(np.uint8)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 确保压缩后图像是uint8类型</span>\n    compressed =<span style=\"color: rgba(0, 0, 0, 1);\"> compressed.astype(np.uint8)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算MSE（均方误差）</span>\n    mse = np.mean((original_gray - compressed) ** 2<span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> mse == 0:  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 无误差</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span> float(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">inf</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    max_pixel </span>= 255.0<span style=\"color: rgba(0, 0, 0, 1);\">\n    psnr_value </span>= 20 * log10(max_pixel /<span style=\"color: rgba(0, 0, 0, 1);\"> sqrt(mse))\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> psnr_value\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> fft_image_compress(image, block_size=8, keep_ratio=0.1<span style=\"color: rgba(0, 0, 0, 1);\">):\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">基于FFT的图像压缩（自动处理彩色/灰度图）</span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 彩色图转灰度图（压缩只处理灰度，保留核心逻辑）</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> len(image.shape) == 3<span style=\"color: rgba(0, 0, 0, 1);\">:\n        image_gray </span>= np.mean(image, axis=2<span style=\"color: rgba(0, 0, 0, 1);\">).astype(np.uint8)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        image_gray </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> image.astype(np.uint8)\n    \n    h, w </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> image_gray.shape\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2. 补零使图像尺寸为block_size的整数倍</span>\n    pad_h = (block_size - h % block_size) %<span style=\"color: rgba(0, 0, 0, 1);\"> block_size\n    pad_w </span>= (block_size - w % block_size) %<span style=\"color: rgba(0, 0, 0, 1);\"> block_size\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">h {} w {} pad_h {} pad_w {}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">.format(h, w, pad_h, pad_w))\n    image_padded </span>= np.pad(image_gray, ((0, pad_h), (0, pad_w)), mode=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">constant</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    h_pad, w_pad </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> image_padded.shape\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 初始化压缩后的频域数组</span>\n    fft_compressed = np.zeros_like(image_padded, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">np.complex128)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4. 分块FFT+高频截断</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(0, h_pad, block_size):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> j <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(0, w_pad, block_size):\n            block </span>= image_padded[i:i+block_size, j:j+<span style=\"color: rgba(0, 0, 0, 1);\">block_size]\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2D-FFT：空间域→频域（中心化，低频移到中心）</span>\n            fft_block = np.fft.fft2(block)                  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对图像块做二维 FFT，将空间域的像素值转换为频域的复数系数（低频默认在四角，高频在中心</span>\n            fft_block_shifted = np.fft.fftshift(fft_block)  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将频域系数 “中心化”，把低频系数移到频域矩阵的中心，高频系数分布在四周，方便后续筛选低频</span>\n            \n            <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算需要保留的低频系数数量</span>\n            total_coeffs = block_size * block_size          <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 单个图像块的总系数数（等于像素数）</span>\n            keep_coeffs = int(total_coeffs * keep_ratio)    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 预设的保留比例（如0.1表示保留10%的系数）</span>\n            keep_coeffs = max(keep_coeffs, 1)               <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 防止保留系数为0，保证至少保留1个低频系数，避免重构失败</span>\n            \n            <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成掩码：只保留低频系数，高频置0</span>\n            center = block_size // 2                        <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 频域矩阵的中心坐标（如 block_size=8 时，center=4）</span>\n            y, x = np.ogrid[:block_size, :block_size]       <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成网格坐标矩阵，对应每个系数在频域中的位置</span>\n            distance = np.sqrt((y - center)**2 + (x - center)**2)   <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算每个系数到中心的欧式距离（距离越小，频率越低）</span>\n            flat_distance = distance.flatten()              <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将距离矩阵展平为一维数组，方便排序</span>\n            idx = np.argsort(flat_distance)[:keep_coeffs]   <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对距离从小到大排序，取前keep_coeffs个索引（对应距离中心最近的低频系数）</span>\n            mask_flat = np.zeros(total_coeffs, dtype=bool)  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成布尔掩码mask：维度与图像块一致</span>\n            mask_flat[idx] = True                           <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> mask中True的位置对应保留的低频系数，False对应舍弃的高频系数</span>\n            mask =<span style=\"color: rgba(0, 0, 0, 1);\"> mask_flat.reshape((block_size, block_size))\n            \n            </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 应用掩码：高频系数置零</span>\n            fft_block_shifted[~mask] = 0    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> ~mask：取掩码的反（False变True，True变False），即高频系数的位置。</span>\n                                            <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将频域矩阵中高频系数的位置置为 0，只保留低频系数，实现 “压缩”（丢弃高频信息）</span>\n            \n            <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 逆移位+逆FFT：频域→空间域</span>\n            fft_block = np.fft.ifftshift(fft_block_shifted) <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 逆中心化，将频域系数恢复到 FFT 后的原始位置（低频回到四角）</span>\n            ifft_block = np.fft.ifft2(fft_block)            <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对处理后的频域系数做逆 FFT，转换回空间域（结果为复数）</span>\n            block_recon = np.real(ifft_block)               <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 取复数的实部（因舍入误差可能有微小虚部，需剔除），得到重构后的图像块像素值</span>\n            \n            <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 存入压缩后数组</span>\n            fft_compressed[i:i+block_size, j:j+block_size] = block_recon <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将重构后的图像块放回fft_compressed数组的对应位置，最终拼接成完整的压缩后图像</span>\n    \n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 5. 去除补零，恢复原始尺寸</span>\n    compressed_image =<span style=\"color: rgba(0, 0, 0, 1);\"> fft_compressed[:h, :w]\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 限制像素值范围（0~255），避免溢出</span>\n    compressed_image = np.clip(compressed_image, 0, 255<span style=\"color: rgba(0, 0, 0, 1);\">).astype(np.uint8)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 6. 计算压缩比（频域系数层面）</span>\n    total_original_coeffs = h_pad *<span style=\"color: rgba(0, 0, 0, 1);\"> w_pad\n    total_keep_coeffs </span>= (h_pad * w_pad) *<span style=\"color: rgba(0, 0, 0, 1);\"> keep_ratio\n    compression_ratio </span>= total_original_coeffs /<span style=\"color: rgba(0, 0, 0, 1);\"> total_keep_coeffs\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> compressed_image, compression_ratio\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> save_image_with_quality(image, path, quality=95<span style=\"color: rgba(0, 0, 0, 1);\">):\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\n    兼容所有版本的图像保存函数，支持设置JPG质量\n    :param image: 灰度图像数组（uint8，0~255）\n    :param path: 保存路径（如\"test.jpg\"）\n    :param quality: JPG质量（0~100，值越小压缩越狠）\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将numpy数组转为PIL Image对象</span>\n    pil_img =<span style=\"color: rgba(0, 0, 0, 1);\"> Image.fromarray(image)\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保存为JPG，设置质量参数</span>\n    pil_img.save(path, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">JPEG</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, quality=<span style=\"color: rgba(0, 0, 0, 1);\">quality)\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 主函数：测试FFT图像压缩</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">if</span> <span style=\"color: rgba(128, 0, 128, 1);\">__name__</span> == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">__main__</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 读取图像（替换为你的图像路径）</span>\n    image_path = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">1.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 支持彩色/灰度图</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        original_image </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> mpimg.imread(image_path)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 注意：matplotlib读取的图像像素值是0~1的浮点数，需转回0~255</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> original_image.dtype ==<span style=\"color: rgba(0, 0, 0, 1);\"> np.float32:\n            original_image </span>= (original_image * 255<span style=\"color: rgba(0, 0, 0, 1);\">).astype(np.uint8)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">except</span><span style=\"color: rgba(0, 0, 0, 1);\"> FileNotFoundError:\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">错误：未找到图像文件，自动生成测试灰度图...</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成512×512渐变灰度图作为测试</span>\n        original_image = np.linspace(0, 255, 512*512).reshape(512, 512<span style=\"color: rgba(0, 0, 0, 1);\">).astype(np.uint8)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2. 执行FFT压缩（调整keep_ratio控制压缩比）</span>\n    compressed_image, compress_ratio =<span style=\"color: rgba(0, 0, 0, 1);\"> fft_image_compress(\n        original_image, block_size</span>=8, keep_ratio=0.1<span style=\"color: rgba(0, 0, 0, 1);\">\n    )\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 计算PSNR（修复维度不匹配问题）</span>\n    psnr_value =<span style=\"color: rgba(0, 0, 0, 1);\"> psnr(original_image, compressed_image)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4. 保存图像（改用PIL，支持quality参数，兼容所有版本）</span>\n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保存原图（转灰度后保存，统一对比基准）</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> len(original_image.shape) == 3<span style=\"color: rgba(0, 0, 0, 1);\">:\n        original_gray </span>= np.mean(original_image, axis=2<span style=\"color: rgba(0, 0, 0, 1);\">).astype(np.uint8)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        original_gray </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> original_image\n    save_image_with_quality(original_gray, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">original_gray.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, quality=95<span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保存压缩后图像，设置JPG质量（值越小文件越小）</span>\n    save_image_with_quality(compressed_image, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">compressed_final.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, quality=50<span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 5. 计算实际文件大小（KB）</span>\n    original_size = os.path.getsize(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">original_gray.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>) / 1024 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> os.path.exists(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">original_gray.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>) <span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> 0\n    compressed_size </span>= os.path.getsize(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">compressed_final.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>) / 1024 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> os.path.exists(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">compressed_final.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>) <span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> 0\n    actual_compression_ratio </span>= original_size / compressed_size <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (compressed_size &gt; 0 <span style=\"color: rgba(0, 0, 255, 1);\">and</span> original_size &gt; 0) <span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> 0\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 6. 显示结果</span>\n    plt.figure(figsize=(12, 6<span style=\"color: rgba(0, 0, 0, 1);\">))\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 原图（彩色/灰度自适应显示）</span>\n    plt.subplot(1, 2, 1<span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> len(original_image.shape) == 3<span style=\"color: rgba(0, 0, 0, 1);\">:\n        plt.imshow(original_image)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        plt.imshow(original_image, cmap</span>=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">gray</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.title(f</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">原始图像\\n尺寸：{original_image.shape[1]}×{original_image.shape[0]}\\n大小：{original_size:.2f} KB</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.axis(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">off</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 压缩后图像（灰度）</span>\n    plt.subplot(1, 2, 2<span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.imshow(compressed_image, cmap</span>=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">gray</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.title(f</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">FFT压缩后图像\\n理论压缩比：{compress_ratio:.1f}:1\\n实际文件压缩比：{actual_compression_ratio:.1f}:1\\nPSNR：{psnr_value:.2f} dB</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.axis(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">off</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    plt.tight_layout()\n    plt.show()\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印详细信息</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">=== 压缩结果 ===</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">理论频域压缩比：{compress_ratio:.1f}:1</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">实际文件压缩比：{actual_compression_ratio:.1f}:1</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">原始文件大小：{original_size:.2f} KB</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">压缩后文件大小：{compressed_size:.2f} KB</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">PSNR（图像质量）：{psnr_value:.2f} dB</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>)</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">图像压缩</span></div>\n<p>程序运行效果如下：</p>\n<p><img alt=\"image\" height=\"510\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260203102142852-1233020511.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"762\" /></p>\n<p>因为运行结果分辨率不高，所以来看压缩后的图片并没有什么不同，但是将图片放大以后还是可以明显看出压缩后图片的失真：</p>\n<p><img alt=\"image\" height=\"354\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260203102615726-1795473578.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"503\" /></p>\n<h1>参考：</h1>\n<p>1&nbsp;<a href=\"https://zhuanlan.zhihu.com/p/19763358\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/19763358</a></p>\n<p>2&nbsp;<a href=\"https://www.cnblogs.com/xxeray/p/fast-fourier-transform.html\" target=\"_blank\">https://www.cnblogs.com/xxeray/p/fast-fourier-transform.html</a></p>\n<p>3&nbsp;<a href=\"https://blog.csdn.net/qq_42212808/article/details/156030009\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/qq_42212808/article/details/156030009</a></p>\n<p>4&nbsp;<a href=\"https://zhuanlan.zhihu.com/p/350616936\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/350616936</a></p>\n<p>5&nbsp;<a href=\"https://www.cnblogs.com/zwfymqz/p/8244902.html\" target=\"_blank\">https://www.cnblogs.com/zwfymqz/p/8244902.html</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 14:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zhaoweiwei\">weiwei22844</a>&nbsp;\n阅读(<span id=\"post_view_count\">105</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "前特斯拉 AI 总监：AI 编程最大的谎言，是 “提效”",
      "link": "https://www.cnblogs.com/yupi/p/19568098",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19568098\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 11:08\">\n    <span>前特斯拉 AI 总监：AI 编程最大的谎言，是 “提效”</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"前特斯拉 AI 总监：AI 编程最大的谎言，是 “提效”\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202602/2225420-20260203102512118-1547421356.png\" />\n        前两天，前特斯拉 AI 总监 Andrej Karpathy 在 X 上发了一条长帖子，内容是他最近几周大量使用 Claude 编程的感悟。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-heading\"><span class=\"md-plain\">大家好，我是程序员鱼皮。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">前两天，前特斯拉 AI 总监 Andrej Karpathy 在 X 上发了一条长帖子，内容是他最近几周大量使用 Claude 编程的感悟。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">结果这条帖子直接爆了，阅读量超过 600 万。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先简单介绍一下『卡帕西』这位大佬：斯坦福 AI 博士，师从李飞飞；OpenAI 创始成员之一；后来去特斯拉当了 AI 总监，负责自动驾驶的视觉系统。2024 年离开特斯拉后，他创办了 Eureka Labs，专注用 AI 做教育。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不夸张地说，他可能是全球最懂 AI、又最能写代码的人之一。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在 2023 年 1 月的时候，他就提出过：未来最热门的新编程语言是自然语言。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你现在回过头来看这句话，就知道这哥们有多牛皮了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">所以我每次看他分享的内容时，都会先沐浴更衣，让自己能够进入深度思考状态。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">进入正题，这条帖子里有很多干货，但让我印象最深的是这句话：</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我不太清楚如何衡量 AI 带来的加速。我感觉做事确实快了，<span class=\"md-pair-s \"><strong>但主要的效果是我做的比原计划多得多</strong><span class=\"md-plain\">。</span></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">卡帕西说，现在他可以随手写一些以前 “不值得写” 的小工具，也敢去碰以前因为技术栈不熟而不敢碰的代码了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>所以 AI 编程带来的核心变化不是加速，而是扩展。</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我觉得这个观察太准了！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">之前很多人问我：AI 编程能提效多少倍？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">其实这个问题本身就问错了。AI 带来的真正变化不是 “同一件事做得更快”，而是 “你开始做以前根本不会做的事”。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这就像你以前骑自行车，现在换了辆车。你不会说自己骑车快了 10 倍，而是会说自己能去更远的地方了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">人比不过 AI 的一点</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">帖子里还有几个点挺有意思的，跟大家分享一下。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">卡帕西说，看 AI 在一个 Bug 上死磕 30 分钟，不放弃、不气馁，最后真的搞定了 —— 这是他感受 AGI 的时刻。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我看到这段就想起自己大学刚学编程时改 Bug 的经历。已经是凌晨一两点，试了好几种方法都没用，我的心态已经崩了，甚至有点儿心绞痛，于是想着明天再说吧，狗命要紧……</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但 AI 不会这样，只要你的 Tokens 足够，它会一直跟 Bug 死磕。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>耐力这件事，正在从人类的瓶颈变成 AI 的优势。</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">当然，代价就是烧 Token。所以程序员的基本功还是很重要的，至少你得能判断这个 Bug 值不值得让 AI 花半小时去磕，怎么通过指引 AI 让它更快更省地解决问题。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">编程变得更有趣了？</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">卡帕西说：用 AI 编程之后，那些填空式的苦差事没了，剩下的都是创造性的部分。所以反而觉得更好玩了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但他也提到，有些程序员会觉得失去了乐趣。因为对他们来说，写代码本身就是快感来源。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这可能是一个分水岭：<span class=\"md-pair-s \"><strong>主要享受 “写代码” 的人，和主要享受 “造东西” 的人，体验会很不一样。</strong></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我看到一位 AI 圈的大 V 把这点称为 “程序员正在分裂成两个物种”。不过我倒觉得，这两类人其实一直都存在。有的人享受代码本身的优雅，追求技术的深度和细节，写出漂亮的代码会有成就感；有的人更在乎东西能不能跑起来、能不能解决问题，代码只是实现想法的工具。AI 只是把这个差异放大了而已 —— 前者可能会有点失落，后者则迎来了黄金时代。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">我正在失去写代码的能力，但是…</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">卡帕西说：自己手动写代码的能力正在慢慢退化。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但是从他的话中能感受到，他对此的态度是 “已经不太在乎了”。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">他给了一个有意思的视角，写代码（生成）和读代码（判别）是大脑里不同的能力。就像你可能写不出一首好诗，但能看出一首诗写得好不好。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">编程也是一样。其实想想看，以前没有 AI 的时候，那些语法细节、API 用法，我们不也是靠查文档、利用编辑器的提示吗？真正需要记在脑子里的从来就不多。现在 AI 把这部分接管了，但代码的设计思路对不对、架构合不合理，还是得靠你自己判断。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">所以未来程序员的角色，可能更像是 “技术导演” 而不是 “码农”。你负责把控方向、做出决策，AI 负责执行细节、填补空白。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">2026 年垃圾内容会爆发，但是…</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">卡帕西还提到了一个词：<span class=\"md-pair-s\"><code>Slopacolypse</code></span></span></p>\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain md-expand\">我搜了一下，发现这其实是最近 AI 圈流行起来的一个 “slop 系列” 造词。Slop 指的是那些用 AI 批量生成的低质量内容，Slopacolypse 就是 Slop + Apocalypse，我理解是 “垃圾内容末日” 的意思。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">他预测 2026 年，GitHub、各种社交媒体都会被 AI 生成的低质量内容淹没。当生产内容的门槛大幅降低，注意力反而会变得更稀缺。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但他也说，真正的改进也在同步发生。AI 的智能部分已经跑在前面了，现在反而是工具、流程、组织这些东西还没跟上。<span class=\"md-pair-s \"><strong>2026 年，整个行业会花大量精力去消化这波新能力。</strong></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">说到这里，我想起自己身边的情况。AI 领域几乎每天都有新工具、新模型、新玩法冒出来，但真正意识到这些变化、真正去用这些新东西的人，又有多少呢？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我经常听到有人说 “再等几个月，等出了更好的再学”、“现在的还不够成熟”。但问题是，在你等待的这几个月里，已经有人用 AI 做出了以前做不到的东西，拉开了差距。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">所以对于我们程序员来说，一方面必须要利用 AI 提升开发效率和优化工作流程。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">另外一方面，不妨打开思路，多想一想：<span class=\"md-pair-s \"><strong>有了 AI，你能做到哪些以前做不到的事？</strong></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">以前不敢碰的技术栈，现在敢试了；以前觉得不值得做的小工具，现在随手就能搞定；以前卡住就放弃的 bug，现在有个不知疲倦的助手帮你死磕。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这才是 AI 编程真正的红利 —— <span class=\"md-pair-s \"><strong>不是让你更快，是让你更大。</strong></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你还没开始用 AI 编程，或者想系统学习怎么用的更好，可以看看我最新免费开源的 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/liyupi/ai-guide\" rel=\"noopener nofollow\"><span class=\"md-plain\">《AI 编程零基础入门教程》</span></a><span class=\"md-plain\">，从 0 开始带你用 AI 编程做出项目，包含各种工具用法、实战技巧、编程资源、甚至是产品变现经验全都有。希望能帮你更快地拥抱这个新时代，一起变得更大、更强！</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c md-link\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 11:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">201</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "DTS按业务场景批量迁移阿里云MySQL库实战（上）：技术选型和API对接",
      "link": "https://www.cnblogs.com/wuyuegb2312/p/19566555",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuyuegb2312/p/19566555\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 22:16\">\n    <span>DTS按业务场景批量迁移阿里云MySQL库实战（上）：技术选型和API对接</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"背景\">背景</h1>\n<h2 id=\"概况\">概况</h2>\n<p>公司某项业务使用三个分库存放该业务的分表。为了保持单表的查询性能，基于业务场景按照公司维度分表，目前每个库都有数量达到10W级的分表。过多的表已经影响了日常的运维，元数据相关的操作如搜索表名等在线操作速度极慢。随着业务的发展，分表数量还会增加。</p>\n<h2 id=\"现状\">现状</h2>\n<ul>\n<li>\n<p>Springboot+阿里云RDS-MySQL8</p>\n</li>\n<li>\n<p>分库分表中间件：MybatisPlus+ShardingSphereDataSource</p>\n</li>\n<li>\n<p>分库方式，创建公司时使用公司id%3计算schemaId，创建完成后不变，各分表均有这一列</p>\n</li>\n<li>\n<p>分表方式，有三种，对应三种分表后缀：</p>\n<ul>\n<li>\n<p>公司维度，table_companyId</p>\n</li>\n<li>\n<p>公司+年份维度，table_company_year</p>\n</li>\n<li>\n<p>业务id维度，table_bizId，bizId在前置业务处理时生成，一般一个公司一年只有一个bizId</p>\n</li>\n</ul>\n</li>\n<li>\n<p>每个公司大概有15~50张分表，它们的结构不完全相同，但是对于前缀相同的表结构是相同的，比如table1_company_2024和table1_company_2025，或者table2_655和table2_656。</p>\n</li>\n<li>\n<p>不同的分表可能会做join查询</p>\n</li>\n</ul>\n<h2 id=\"预期\">预期</h2>\n<p>申请更多的分库，将现有的表迁移至新的分库中，降低原有库的表数量。</p>\n<h1 id=\"迁移方案选型\">迁移方案选型</h1>\n<h2 id=\"纯java实现\">纯Java实现</h2>\n<p>如果业务简单、数据量不多，只需要做一部分表的迁移，使用jdbc逐表复制创建对应的新表、复制数据，是完全够用的。但是在当前的业务场景下：</p>\n<ul>\n<li>\n<p>至少有20种不同结构的分表，针对每种结构写对应的迁移代码，工作量不小</p>\n</li>\n<li>\n<p>难以维护：当分表结构发生调整、增加新的结构的分表时，迁移代码也需要修改，也就是说，其他项目引入的变更，还要来修改迁移的代码</p>\n</li>\n<li>\n<p>开发者要自己控制迁移过程，比如大数据量的分片迁移、迁移过程中的失败重试等</p>\n</li>\n</ul>\n<h2 id=\"阿里云dts\">阿里云DTS</h2>\n<p>既然这部分业务跑在阿里云RDS上，使用现成的DTS中间件是更好的选择。虽然有一定的学习成本，但是它有两个明显优势：</p>\n<ul>\n<li>\n<p>阿里云RDS内部通过DTS做数据迁移是不收费的：<a href=\"https://help.aliyun.com/zh/dts/product-overview/billing-overview?spm=a2c4g.11186623.help-menu-26590.d_0_1_0.16066f40UD6JFk\" rel=\"noopener nofollow\" target=\"_blank\">计费概述</a></p>\n</li>\n<li>\n<p>数据迁移，只要指定好源库、目标库、待迁移的表，DTS会自动创建新表结构和数据同步，并确保迁移高可用与数据准确性</p>\n</li>\n</ul>\n<p>在做了简单的调研（包括写一个简单的DTS数据迁移demo）、确认DTS可以满足迁库表的需求后，我选择了DTS的，通过接入DTS API完成库表迁移。</p>\n<h1 id=\"确认迁移场景满足dts限制\">确认迁移场景满足DTS限制</h1>\n<p><a href=\"https://help.aliyun.com/zh/dts/product-overview/limits-and-notes-on-the-source-database?spm=a2c4g.11186623.help-menu-26590.d_0_0_2_0.29506ce8aBZ9s4\" rel=\"noopener nofollow\" target=\"_blank\">源库的注意事项及限制</a></p>\n<p><a href=\"https://help.aliyun.com/zh/dts/product-overview/limits-and-notes-on-the-destination-database?spm=a2c4g.11186623.help-menu-26590.d_0_0_2_1.5cb14fe3xzzIKO&amp;scm=20140722.H_2856380._.OR_help-T_cn~zh-V_1\" rel=\"noopener nofollow\" target=\"_blank\">目标库的注意事项及限制</a></p>\n<p><a href=\"https://help.aliyun.com/zh/dts/product-overview/limits-and-notes-on-the-dts-instance?spm=a2c4g.11186623.help-menu-26590.d_0_0_2_2.36374fe35M7F97&amp;scm=20140722.H_2857760._.OR_help-T_cn~zh-V_1\" rel=\"noopener nofollow\" target=\"_blank\">DTS实例的注意事项及限制</a></p>\n<p>（以上三篇文档实际上是同一篇文档不同小结）</p>\n<h1 id=\"dts准备\">DTS准备</h1>\n<p>如果你也要通过demo的形式做前期验证，也需要先做准备工作。由于我使用的不是阿里云主账号而是RAM账号，这部分准备工作只知道个大概，你可以参考官方文档进行配置。</p>\n<ul>\n<li>\n<p>购买DTS产品，由于是后付费的，并且我的迁移场景不会产生实际的付费项，费用实际为0。</p>\n</li>\n<li>\n<p><a href=\"https://help.aliyun.com/zh/dts/user-guide/authorize-dts-to-access-alibaba-cloud-resources?spm=a2c4g.11186623.help-menu-26590.d_2_2_0.6d972842N74EP9&amp;scm=20140722.H_47556._.OR_help-T_cn~zh-V_1\" rel=\"noopener nofollow\" target=\"_blank\">授予DTS访问云资源的权限</a></p>\n</li>\n<li>\n<p>创建DTS专用的独立RAM账号<a href=\"https://help.aliyun.com/zh/ram/user-guide/create-a-ram-user?spm=a2c4g.11186623.help-menu-28625.d_2_0_1_0.119141180Dhmg8\" rel=\"noopener nofollow\" target=\"_blank\">创建RAM用户</a>，此处使用【使用永久AccessKey访问】，并赋予其读写权限<a href=\"https://help.aliyun.com/zh/dts/user-guide/use-a-system-policy-to-authorize-a-ram-user-to-manage-dts-instances?spm=a2c4g.11186623.help-menu-26590.d_2_2_1.271b60fdyi0DVi&amp;scm=20140722.H_47568._.OR_help-T_cn~zh-V_1\" rel=\"noopener nofollow\" target=\"_blank\">通过系统策略授权子账号管理DTS</a></p>\n</li>\n<li>\n<p>将DTS服务器添加到数据库IP白名单（对于RDS Mysql不需要）</p>\n</li>\n</ul>\n<h1 id=\"dts-api对接\">DTS API对接</h1>\n<h2 id=\"sdk安装\">SDK安装</h2>\n<p>我使用的是同步版JavaSDK，同步版和异步版在文档上不区分，应该是通用的。文档：<a href=\"https://next.api.aliyun.com/api-tools/sdk/Dts?version=2020-01-01&amp;language=java-tea&amp;tab=primer-doc\" rel=\"noopener nofollow\" target=\"_blank\">数据传输_SDK中心-阿里云OpenAPI开发者门户</a></p>\n<h2 id=\"使用api\">使用API</h2>\n<p>整个迁移过程可以简化为：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/228024/202602/228024-20260202215115684-53010481.png\" /></p>\n<p>此处不贴详细的代码，可以参考官方文档。</p>\n<h3 id=\"官方数据同步demo\">官方数据同步demo</h3>\n<p><a href=\"https://next.api.aliyun.com/api-tools/demo/Dts/d3626a35-1657-4fa1-b4b4-3901ccff7d8b\" rel=\"noopener nofollow\" target=\"_blank\">DTS SDK新版API同步任务创建示例_数据传输_示例中心-阿里云OpenAPI开发者门户</a></p>\n<p>本例实例type是\"SYNC\"，代表数据同步，我使用的是\"MIGRATION\"，代表数据迁移。除了这个参数，其他参数设置基本一样。</p>\n<h3 id=\"创建实例\">创建实例</h3>\n<p><a href=\"https://next.api.aliyun.com/document/Dts/2020-01-01/CreateDtsInstance\" rel=\"noopener nofollow\" target=\"_blank\">CreateDtsInstance_数据传输_API文档-阿里云OpenAPI开发者门户</a></p>\n<h3 id=\"配置任务\">配置任务</h3>\n<p><a href=\"https://next.api.aliyun.com/document/Dts/2020-01-01/ConfigureDtsJob\" rel=\"noopener nofollow\" target=\"_blank\">ConfigureDtsJob_数据传输_API文档-阿里云OpenAPI开发者门户</a></p>\n<p>一个实例只能配置一个任务。</p>\n<h4 id=\"tableconfig配置\">TableConfig配置</h4>\n<p>想要只迁移指定的库表，需要配置TableConfig参数，文档见<a href=\"https://help.aliyun.com/zh/dts/developer-reference/objects-of-dts-tasks?spm=a2c4g.11186623.help-menu-26590.d_5_1_4_25_0.5cbb195aWUbdts\" rel=\"noopener nofollow\" target=\"_blank\">迁移、同步或订阅对象说明</a>。本次典型的单个DTS数据迁移任务的场景：</p>\n<ul>\n<li>\n<p>单个库到单个库</p>\n</li>\n<li>\n<p>一次性多张表（建议不超过1000）</p>\n</li>\n<li>\n<p>配置字符串长度不超过1MB</p>\n</li>\n</ul>\n<pre><code class=\"language-JSON\">{\n    \"待迁移的源库1的名称\": {\n        \"name\": \"迁移、同步或订阅的库1在目标实例中的名称\",\n        \"all\": false（表示迁移、同步或订阅对象为非整库）,\n        \"Table\": {\n            \"待迁移的表A的名称\": {\n                \"name\": \"迁移、同步或订阅的表A在目标实例中的名称\",\n                \"all\": true（表示迁移、同步或订阅对象为整表）\n             }\n        }\n    }\n}\n</code></pre>\n<h4 id=\"reserve配置\">Reserve配置</h4>\n<p>DTS可以通过ETL设置迁移后的表中某些列的值，即将旧的schemaId改成新库对应的值，在任务配置的Reserve参数中增加对应配置如下：</p>\n<pre><code class=\"language-JSON\">{\n        \"targetTableMode\": \"0\",\n        \"etlOperatorCtl\": \"Y\",\n        \"etlOperatorSetting\": \"e_set(schemaId, '%d', schema_id,'%d')\"\n}\n</code></pre>\n<p>ETL用法：<a href=\"https://help.aliyun.com/zh/dts/user-guide/configure-etl-in-a-data-migration-or-data-synchronization-task?spm=a2c4g.11186623.help-menu-26590.d_2_16_3.714737e6HMef47\" rel=\"noopener nofollow\" target=\"_blank\">在DTS迁移或同步任务中配置ETL</a></p>\n<p>Reserve参数用法：<a href=\"https://help.aliyun.com/zh/dts/developer-reference/reserve-parameter-description?spm=a2c4g.11186623.help-menu-26590.d_5_1_4_25_1.4d177bf37tuPzD\" rel=\"noopener nofollow\" target=\"_blank\">Reserve参数说明</a></p>\n<p>先购买后配置时autoStartModulesAfterConfig默认auto, <strong>配置完任务会立即启动。</strong></p>\n<h3 id=\"暂停dts任务\">暂停DTS任务</h3>\n<p><a href=\"https://next.api.aliyun.com/document/Dts/2020-01-01/SuspendDtsJob\" rel=\"noopener nofollow\" target=\"_blank\">SuspendDtsJob_数据传输_API文档-阿里云OpenAPI开发者门户</a></p>\n<h3 id=\"结束dts任务\">结束DTS任务</h3>\n<p><a href=\"https://next.api.aliyun.com/document/Dts/2020-01-01/StopDtsJob\" rel=\"noopener nofollow\" target=\"_blank\">StopDtsJob_数据传输_API文档-阿里云OpenAPI开发者门户</a></p>\n<h3 id=\"查询单个dts任务详情\">查询单个DTS任务详情</h3>\n<p><a href=\"https://next.api.aliyun.com/document/Dts/2020-01-01/DescribeDtsJobDetail\" rel=\"noopener nofollow\" target=\"_blank\">DescribeDtsJobDetail_数据传输_API文档-阿里云OpenAPI开发者门户</a></p>\n<h2 id=\"补充工作\">补充工作</h2>\n<p>除了通过DTS迁移表本身外，还有一些工作需要关注：</p>\n<ul>\n<li>\n<p>归档是阿里云RDS的一大功能。如果源表是归档的，迁移后的目标表也应该是归档的。如何判定表是否归档及变更归档状态参考<a href=\"https://help.aliyun.com/zh/rds/apsaradb-rds-for-mysql/rds-mysql-data-archiving-function?spm=a2c4g.11186623.0.0.313ad8aavQgy9H\" rel=\"noopener nofollow\" target=\"_blank\">数据归档功能</a></p>\n</li>\n<li>\n<p>DTS的日志需要关注，如果有失败，任务本身不会停止。你也可以校验迁移前后表个数、各表数据量是否一致来判断迁移是否完全成功。</p>\n</li>\n<li>\n<p>重试迁移前，前次迁移创建的表需要手动删除</p>\n</li>\n<li>\n<p>校验源表、新表的字段、表名的大小写是否发生了改变。测试阶段确认一次即可。</p>\n</li>\n</ul>\n<p>在下一篇文章中，我会详细介绍迁移功能模块的设计和实现。</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <div id=\"AllanboltSignature\">\n        <p id=\"PSignature\">\n            <br />\n            作者：<a href=\"http://www.cnblogs.com/wuyuegb2312\" target=\"_blank\">五岳</a>\n            <br />\n            出处：<a href=\"http://www.cnblogs.com/wuyuegb2312\" target=\"_blank\">http://www.cnblogs.com/wuyuegb2312</a>\n            <br />\n            对于标题未标注为“转载”的文章均为原创，其版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。\n        </p>\n    　</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 22:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wuyuegb2312\">五岳</a>&nbsp;\n阅读(<span id=\"post_view_count\">22</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从零学习Kafka：配置参数",
      "link": "https://www.cnblogs.com/Jackeyzhe/p/19566484",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Jackeyzhe/p/19566484\" id=\"cb_post_title_url\" title=\"发布于 2026-02-02 21:42\">\n    <span>从零学习Kafka：配置参数</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"从零学习Kafka：配置参数\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/1828322/202601/1828322-20260127214703996-2017510713.png\" />\n        前面我们对 Kafka 的整体架构和一些关键的概念有了一个基本的认知，本文主要介绍 Kafka 的一些配置参数。掌握这些参数的作用对我们的运维和调优工作还是非常有帮助的。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>前面我们对 Kafka 的整体架构和一些关键的概念有了一个基本的认知，本文主要介绍 Kafka 的一些配置参数。掌握这些参数的作用对我们的运维和调优工作还是非常有帮助的。</p>\n<h3 id=\"写在前面\">写在前面</h3>\n<p>Kafka 作为一个成熟的事件流平台，有非常多的配置参数。详细的参数列表可以查看<a href=\"https://kafka.apache.org/41/configuration/\" rel=\"noopener nofollow\" target=\"_blank\">官方文档</a>。本文我们列出一些个人认为比较重要的参数，并对其进行详细的介绍。</p>\n<h3 id=\"broker-端参数\">Broker 端参数</h3>\n<p>第一个要介绍的参数是 <code>log.dirs</code> 它是 Broker 的一个最基本的参数，用来指定数据存储的目录，多个目录之间用逗号分隔。这个参数是必填参数且没有默认值。因此必须要手动配置。在生产环境中，我们可以给这个目录配置挂载在多个不同磁盘的路径，这样既可以提升读写性能，又可以实现故障转移。Kafka 还提供了 <code>log.dir</code> 参数，作为 <code>log.dirs</code> 的补充，这个参数只能配置一个目录，默认值是 <code>/tmp/kafka-logs</code> ，通常情况下我们只需要配置 <code>log.dirs</code> 就好。</p>\n<p>第二个参数是 <code>process.roles</code>，它用来指定 broker 的角色，可以是 broker 或者 controller，也可以同时指定为 broker,controller。</p>\n<p>第三个参数是 <code>listeners</code>，它是 broker 的“耳朵”，指定了 broker 如何监听外部连接。连接的配置是一个三元组，包括&lt;协议名称，主机名，端口号&gt;。</p>\n<p>Kafka 目前支持四种安全协议：</p>\n<ul>\n<li>\n<p>PLAINTEXT：明文传输</p>\n</li>\n<li>\n<p>SSL/TLS：加密传输</p>\n</li>\n<li>\n<p>SASL_PLAINTEXT：认证+明文传输</p>\n</li>\n<li>\n<p>SASL_SSL：认证+加密传输，为最高安全级别</p>\n</li>\n</ul>\n<p>此外还可以自定义协议名称，但需要配置 <code>listener.security.protocol.map</code> 参数。</p>\n<p>主机名可以指定为一个确定的主机名，也可以是 0.0.0.0 ，这代表了 broker 会监听所有网卡。主机名也可以是空，代表监听默认接口。</p>\n<p>第四个参数是 <code>advertised.listeners</code> ，这组配置是 Broker 发布的监听，也就是告诉别人“怎么找到我”。它的配置格式和 listeners 相同。</p>\n<p>再来看几个集群稳定性和元数据管理相关的参数。</p>\n<p>第五个是 <code>auto.create.topics.enable</code>，表示是否允许自动创建 topic。在生产环境中一般设置为 false，需要用户手动创建 topic，方便管理。</p>\n<p>第六个是 <code>unclean.leader.election.enable</code>，表示是否允许 unclean leader 选举。unclean 就是落后太多的副本，如果允许这部分副本参与选举可能会造成数据丢失，因此最好手动设置 false。在最新版本中，它的默认值就是 false，为什么还要手动设置呢？因为不同的 Kafka 版本中这个参数的默认值是不一样的，最开始是 false，后来改成了 true，现在又改回了 false。为了避免数据丢失，我们还是手动设置成 false 比较放心。</p>\n<p>第七个参数是 <code>auto.leader.rebalance.enable</code>，表示是否允许定期选举 leader，这个参数最好也设置为 false，如果设置为 true 的话，即使当前 leader 一直运行的很稳定，Kafka 也会重新选举出一个新的 leader 来替代它。替换 leader 的成本还是非常高的，所有连接到旧 leader 的 client 都需要与新的 leader 重新建立连接。</p>\n<p>第八个参数是 <code>min.insync.replicas</code> ，表示最小同步副本数，它与生产者的 acks=all 配合。如果存活的副本数小于这个值，producer 在写入时会直接报错。这个配置可以保证我们在牺牲部分可用性的情况下确保数据的正确性。</p>\n<p>接下来我们再看几个数据生命周期相关的参数。</p>\n<p>第九个参数是 <code>log.retention.hours / minutes / ms</code>，这其实是三个参数，表示的意思一样，都是数据留存时长，只是时间单位不同。如果三个参数都配置了，优先级是 ms &gt; minutes &gt; hours。</p>\n<p>第十个参数 <code>log.retention.bytes</code>，它表示单个 broker 上存储的最大字节数，默认是 -1，也就是没有限制。在数据激增时，它可以是保护磁盘不溢出的最后防线。</p>\n<p>第十一个参数是 <code>log.segment.bytes</code>，它表示单个日志文件的大小，默认是 1GB。</p>\n<h3 id=\"topic-参数\">Topic 参数</h3>\n<p>Topic 级别的参数会覆盖 Broker 参数的值，它的主要作用针对不同的 topic 灵活的配置参数。最常见的是我们在生产环境中针对不同的 topic 会配置不同的数据保留时长。这也是我们要介绍的第一个参数 <code>retention.ms</code>，它对应的 broker 端的参数就是 <code>log.retention.ms</code>。</p>\n<p>第二个参数是 <code>retention.bytes</code> 它对应的是 <code>log.retention.bytes</code>。</p>\n<p>第三个参数是 <code>cleanup.policy</code>，它对应的是 broker 端的 <code>log.cleanup.policy</code>，这个参数代表了数据清理策略，默认值是 delete，即直接物理删除。也可以配置为 compact，对每个 key 只保留最新的值，这种策略比较适合一些状态保存的场景。</p>\n<p>第四个参数是 <code>segment.bytes</code> ，与之对应的 broker 参数是 <code>log.segment.bytes</code>，同样是控制 Log Segment 文件的大小，默认是 1GB。调小可以让 Kafka 更及时的回收磁盘空间，但容易产生大量小文件，增大索引压力。一般保持默认值就好。</p>\n<p>第五个参数是 <code>max.message.bytes</code> ，它限制了该 Topic 能接收的最大单条消息的大小，默认是 1MB，对个别业务可以适当调大。需要注意的是它和消费端参数 <code>fetch.max.bytes</code> 的大小应该合理配置。如果 <code>max.message.bytes</code> 设置为 10MB，<code>fetch.max.bytes</code> 设置为 5MB，当 Topic 中有超过 5MB 的消息时，就会导致无法消费的问题。</p>\n<h3 id=\"producer-参数\">Producer 参数</h3>\n<p>首先第一个参数是 <code>acks</code>，它有几个值：</p>\n<ul>\n<li>\n<p>0：不管是否写入成功</p>\n</li>\n<li>\n<p>1：Leader 写入成功即可</p>\n</li>\n<li>\n<p>all / -1：ISR 都要写入成功</p>\n</li>\n</ul>\n<p>默认值是 all，如果设置成 0 或 1 ，性能会提高，但有可能丢失数据。</p>\n<p>第二个参数是 <code>retries</code> ，它控制请求的重试次数，默认是 2147483647（约等于无限重试了）。</p>\n<p>第三个参数是 <code>batch.size</code>，默认是 16KB，调大会提升吞吐量，但是会增加内存占用。</p>\n<p>第四个参数是 <code>linger.ms</code>，它用来控制发送等待时间，也就是“攒批”的时间，Kafka 4.0 把它的默认值从 0 调成了 5。它可以和 <code>batch.size</code> 配合使用，同时调大会提高吞吐，但数据会有一定的延迟。在生产环境中，我们可以根据不同的场景对其进行调整，如果数据量极大，但对延迟要求不高，则可以考虑调大这两个参数。</p>\n<p>最后，第五个参数是 <code>compression.type</code> 生产端的压缩算法，默认不开启压缩，目前支持的值为：none、gzip、snappy、lz4、zstd。</p>\n<h3 id=\"consumer-参数\">Consumer 参数</h3>\n<p>最后我们再来看几个 Consumer 端的参数。</p>\n<p>第一个是 <code>group.id</code>，用来标识这个 consumer 属于哪个消费组。</p>\n<p>第二个是 <code>auto.offset.reset</code>，它用来标识 offset 的重置策略。支持以下几个值：</p>\n<ul>\n<li>\n<p>earliest：从最早的 offset 开始消费</p>\n</li>\n<li>\n<p>latest：从最新的 offset 开始消费</p>\n</li>\n<li>\n<p>by_duration：需要配置为 by_duration:ISO-8601 格式的时间，例如 by_duration:PT1H 即从 1 小时前的位移开始消费</p>\n</li>\n<li>\n<p>none：如果没找到消费组的 offset，就会抛出异常</p>\n</li>\n</ul>\n<p>第三个参数是 <code>enable.auto.commit</code>，是否自动提交 offset，默认是 true。在调用 poll 方法时，会提交上一批次的 offset。也可以设置为 false，这样就是手动提交，自己控制在什么时候提交，具体的细节我们以后再聊。</p>\n<p>第四个参数是 <code>max.poll.records</code> ，表示单次拉取的消息条数，默认是 500。如果单条数据的处理逻辑比较重，可以调小这个值，防止消费超时的情况。</p>\n<p>第五个参数是 <code>session.timeout.ms</code>，表示心跳超时时间，默认是 45000，即 45 秒。如果 Broker 超过 45 秒没收到 Consumer 的心跳，就认为这个 Consumer 挂了，会将它踢出消费组，然后进行 Rebalance。</p>\n<h3 id=\"总结\">总结</h3>\n<p>本文我们一起学习了涉及 Broker、Topic、Producer、Consumer 端的共 26 个配置参数，这些都是我认为比较重要的。掌握之后可以对生产环境的调优有比较大的帮助。除了上面提到的这些，你还知道有哪些比较重要的配置参数吗？</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-02 21:42</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Jackeyzhe\">Jackeyzhe</a>&nbsp;\n阅读(<span id=\"post_view_count\">34</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI开发-python-langchain框架（1-9 返回字符串列表-格式解析器）",
      "link": "https://www.cnblogs.com/yclh/p/19568812",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yclh/p/19568812\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 13:30\">\n    <span>AI开发-python-langchain框架（1-9 返回字符串列表-格式解析器）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span class=\"qwen-markdown-text\">&nbsp; &nbsp; &nbsp;大模型输出结果通常都是文本信息，如何让他按照你期望的格式输出？</span></p>\n<p><span class=\"qwen-markdown-text\">&nbsp; &nbsp; &nbsp;这段代码演示了如何使用LangChain将大语言模型的自由文本输出转换为结构化的字符串列表。核心目标是让模型返回逗号分隔的多个值，并通过专用解析器自动拆分为Python列表。</span></p>\n<div class=\"qwen-markdown-paragraph\"><span class=\"qwen-markdown-text\">&nbsp; &nbsp; &nbsp;CommaSeparatedListOutputParser专用于解析逗号分隔的文本，自动处理空格、引号等边界字符，输出类型为List[str]。与StrOutputParser返回纯字符串不同，它强制将响应拆分为离散元素，适用于多值提取场景。</span></div>\n<div class=\"qwen-markdown-space\">&nbsp;</div>\n<div class=\"qwen-markdown-paragraph\"><span class=\"qwen-markdown-text\">&nbsp; &nbsp; 提示词设计必须显式约束输出格式。通过partial_variables注入格式指令（如\"内容1, 内容2, 内容3\"），引导模型生成符合解析器要求的纯列表文本。若缺少格式约束，模型可能返回自然语言描述，导致解析器机械分割产生语义错误。</span></div>\n<div class=\"qwen-markdown-paragraph\">&nbsp;</div>\n<div class=\"qwen-markdown-paragraph\"><span class=\"qwen-markdown-text\">代码如下：</span></div>\n<div class=\"qwen-markdown-paragraph\">\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">from langchain.output_parsers import CommaSeparatedListOutputParser\nfrom langchain.prompts import PromptTemplate\nfrom langchain_openai import ChatOpenAI\nimport os\n\n#输出-字符串列表\noutput_parser = CommaSeparatedListOutputParser()\n\n#这里指定分隔符\nformat_instructions = \"您的响应应该是csv格式的逗号分隔值的列表，例如：'内容1, 内容2, 内容3'\"\n\n#构建提示词-给出样例，提高返回的准确率\nprompt = PromptTemplate(\n    template=\"{format_instructions}\\n请列出五个 {subject}.\",\n    input_variables=[\"subject\"],\n    partial_variables={\"format_instructions\": format_instructions},\n)\n\n#输出提示词\nprint('#######################')\nprint(prompt.invoke({\"subject\": \"宠物狗的品种\"}).text)\nprint('#######################')\n\nllm = ChatOpenAI(\n    api_key=os.getenv(\"DEEPSEEK_API_KEY\"),\n    base_url=os.getenv(\"<span style=\"color: rgba(106, 135, 89, 1);\">BASE_URL</span>\"),  # Deepseek 的 API 基础地址\n    model=\"deepseek-v3:671b\",  # Deepseek 对话模型（可选：deepseek-chat-pro 等高级模型）\n    temperature=0.7,  # 温度参数（0-1，越低越稳定）\n    max_tokens=1024  # 最大生成 tokens\n)\n\n\nchain = prompt | llm | output_parser\n\nresult = chain.invoke({\"subject\": \"宠物狗的品种\"})\nprint(result)\n</pre>\n</div>\n<p>&nbsp;输出结果如下：</p>\n<p>#######################<br />您的响应应该是csv格式的逗号分隔值的列表，例如：'内容1, 内容2, 内容3'<br />请列出五个 宠物狗的品种.<br />#######################<br />[\"'拉布拉多\", '金毛寻回犬', '德国牧羊犬', '贵宾犬', \"比格犬'\"]</p>\n\n</div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 13:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yclh\">万笑佛</a>&nbsp;\n阅读(<span id=\"post_view_count\">20</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}