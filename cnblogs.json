{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "如何保证mysql与redis双写一致性",
      "link": "https://www.cnblogs.com/aicc123/p/19552490",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aicc123/p/19552490\" id=\"cb_post_title_url\" title=\"发布于 2026-01-30 11:39\">\n    <span>如何保证mysql与redis双写一致性</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>MySQL 与 Redis 的双写一致性是缓存架构的核心难题。由于网络延迟、故障回滚、并发竞态等因素，两者只能追求最终一致性，无法保证强一致性（除非牺牲性能用分布式锁）。</p>\n<h3 id=\"什么是双写一致性\">什么是双写一致性</h3>\n<pre><code>在分布式系统中，双写一致性主要指在一个数据同时存在于缓存（如Redis）和持久化存储（如数据库）的情况下，\n任何一方的数据更新都必须确保另一方数据的同步更新，以保持双方数据的一致状态。\n这一问题的核心在于如何在并发环境下正确处理缓存与数据库的读写交互，防止数据出现不一致的情况。\n</code></pre>\n<h2 id=\"解决方式\">解决方式</h2>\n<h3 id=\"1旁路缓存-cache-aside最常用\">1.旁路缓存 （Cache-Aside）（最常用）</h3>\n<pre><code>读操作：先从缓存中查，若命中，则直接返回；若未命中，从数据库中查并放入缓存中。\n写操作：先更新数据库，然后删除缓存。\n优点：实现简单，适合大多是读多写少的场景。\n缺点：存在短暂数据不一致的场景。如刚更新数据库还未删除缓存时读取数据就会读到旧数据。\n优化：对热点数据使用读写锁或互斥锁。如redis的setnx。\n</code></pre>\n<h3 id=\"2延时双删\">2.延时双删</h3>\n<pre><code>延时双删主要用于解决高并发场景下，由于网络延迟，并发控制等原因造成的数据不一致的情况。\n第一次删除：更新数据库后删除缓存。\n第二次删除：隔一段设定好的暂停时间后再次删除。\n优点：解决脏数据概率。\n缺点：需维护定时任务，增加系统复杂度。\n</code></pre>\n<h3 id=\"3删除缓存重试机制\">3.删除缓存重试机制</h3>\n<pre><code>执行更新数据库操作之后删除缓存，若删除失败，系统进入重试逻辑，按照预先设定的策略进行多次尝试，\n直到删除成功或达到最大次数。\n优点：确保删除缓存成功。\n缺点：占用额外的系统资源和时间，重试次数过多可能阻塞其他操作。\n</code></pre>\n<h3 id=\"4消息队列异步同步\">4.消息队列异步同步</h3>\n<pre><code>写操作成功后发送消息到MQ，消费MQ，更新或删除缓存。\n通过MQ解耦数据库和缓存操作，保证最终一致性。\n支持异步重试。如RabbitMQ的死信队列。\n优点：高吞吐，解耦系统。\n缺点：依赖MQ可靠性，需处理消息积压和重复消费。\n</code></pre>\n<h3 id=\"5分布式锁\">5.分布式锁</h3>\n<pre><code>写操作前获取分布式锁（如redis的RedLock）\n更新数据库-&gt;删除缓存-&gt;释放锁\n串行化写操作，避免并发冲突。\n优点：保证强一致性。\n缺点：性能差，锁粒度控制困难。\n</code></pre>\n<h3 id=\"总结\">总结</h3>\n<pre><code>没有绝对完美的方案，根据不同的场景选择不同的方案\n强一致性：分布式锁\n最终一致性：Cache Aside或消息队列\n高并发：延时双删\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-30 11:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aicc123\">acccccccccc</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI开发-python-langchain框架（1-8-1 缓存机制——让 AI 应用“记住”高频问题）",
      "link": "https://www.cnblogs.com/yclh/p/19552322",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yclh/p/19552322\" id=\"cb_post_title_url\" title=\"发布于 2026-01-30 11:18\">\n    <span>AI开发-python-langchain框架（1-8-1 缓存机制——让 AI 应用“记住”高频问题）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>想象一下，你现在是一家大型电商平台的AI架构师。双十一期间，你的智能客服系统每天要处理<strong>千万级</strong>的用户咨询。每个问题都要调用昂贵的GPT-API，响应慢、成本高，用户投诉飙升……这时候，你会怎么做？\"</p>\n<p>\"我们会发现一个奇怪的现象——每天有30%的问题是完全相同的！用户都在问：'快递几天能到？'、'怎么退货？'、'商品有保修吗？'……每个问题都要调用GPT-4，每次花费0.03美元，一天就是数万美元！更糟的是，相同的回答，用户要等3-5秒才能看到……\"</p>\n<p>解决方案：引入缓存机制（如下使用sqlite当缓存数据库），当用户问道相同问题时，从缓存里直接给出答案不用将问题在送给大模型，既节约金钱成本也节约时间成本。</p>\n<p>直接看代码：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">from langchain_community.cache import SQLiteCache\nfrom langchain.globals import set_llm_cache\nfrom langchain_openai import ChatOpenAI\nimport os\n\n#指定缓存 对比提问同样的问题，返回时间\nset_llm_cache(SQLiteCache(database_path=\"langchain_demo.db\"))\n\nllm = ChatOpenAI(\n    api_key=os.getenv(\"DEEPSEEK_API_KEY\"),\n    base_url=os.getenv(\"DEEP_URL\"),  # Deepseek 的 API 基础地址\n    model=\"deepseek-v3:671b\",  # Deepseek 对话模型（可选：deepseek-chat-pro 等高级模型）\n    temperature=0.7,  # 温度参数（0-1，越低越稳定）\n    max_tokens=1024  # 最大生成 tokens\n)\n\n \n#这时会向数据库里插入一条数据\nresponse =llm.invoke(\"hello world\")\nprint(response.content)\n\n#再插入一条数据 注：是否插入要根据提示词和调用的模型（模型参数改变也会认为是不同）\nresponse =llm.invoke(\"how are you\")\nprint(response.content)\n\n#这时就会从缓存里直接出结果不会送往大模型，数据库里也不会新插入一条数据\nresponse =llm.invoke(\"hello world\")\nprint(response.content)\n</pre>\n</div>\n<p>&nbsp;运行结果：可以看到 第一次的回答和第三次的回答是完全一样的。</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">Hello! 🌍 How can I assist you today? Whether you have questions, need help with a task, or just want to chat, I'm here for you! 😊\n \n\nHey there! Thanks for asking! I'm functioning at full capacity and ready to help you out. While I don't experience feelings in the way humans do, I genuinely enjoy our conversations and am always excited to learn and assist. How can I support you today? I'm all ears! 🌟\n \n\nHello! 🌍 How can I assist you today? Whether you have questions, need help with a task, or just want to chat, I'm here for you! 😊\n</pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;我们可以看到，虽然我么提问了三次问题，但是缓存数据库里只有两条数据，说明第三次提问，回答是从缓存里走的。</p>\n<p><img alt=\"图片\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-30 11:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yclh\">万笑佛</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "springboot--pagehelper整合与日志处理",
      "link": "https://www.cnblogs.com/alineverstop/p/19552193",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/alineverstop/p/19552193\" id=\"cb_post_title_url\" title=\"发布于 2026-01-30 11:00\">\n    <span>springboot--pagehelper整合与日志处理</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"pagehelper整合\">pagehelper整合</h1>\n<h2 id=\"引入依赖\">引入依赖</h2>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;\n    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;2.1.0&lt;/version&gt;\n    &lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"编写代码\">编写代码</h2>\n<pre><code class=\"language-java\">@GetMapping(\"/list/{pageNo}\")\npublic PageInfo&lt;Vip&gt; findAll(@PathVariable int pageNo) {\n    // 设置当前页码和每页显示的条数\n    PageHelper.startPage(pageNo, 10);\n    // 查询数据\n    List&lt;Vip&gt; allVip = vipService.findAllVip();\n    // 将数据封装到pageinfo对象中\n    PageInfo&lt;Vip&gt; pageInfo = new PageInfo&lt;&gt;(allVip);\n    return pageInfo;\n}\n</code></pre>\n<h1 id=\"web层响应结果的封装\">web层响应结果的封装</h1>\n<p>对于前后端分离的系统来说，后端会返回json数据，一般会封装一个R对象来解决统一响应格式问题。</p>\n<pre><code class=\"language-java\">package com.ali.springboot3ssm.result;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder // 建造模式\npublic class R&lt;T&gt; {\n\n    // 响应状态码\n    private int code;\n    // 消息描述：成功或失败\n    private String msg;\n    // 响应对象：任意类型对象\n    private  T data;\n\n    public static &lt;T&gt; R&lt;T&gt; OK(T data) {\n        return R.&lt;T&gt;builder().code(200).msg(\"成功\").data(data).build();\n    }\n\n    // 成功的方法\n    public static &lt;T&gt; R&lt;T&gt; OK() {\n        return R.&lt;T&gt;builder().code(200).msg(\"成功\").build();\n    }\n\n    // 失败的方法\n    public static &lt;T&gt; R&lt;T&gt; FAIL(int code,String msg) {\n        return R.&lt;T&gt;builder().code(code).msg(msg).build();\n    }\n\n    public static &lt;T&gt; R&lt;T&gt; FAIL() {\n        return R.&lt;T&gt;builder().code(400).msg(\"失败\").build();\n    }\n}\n</code></pre>\n<p>controller中使用</p>\n<pre><code class=\"language-java\">@GetMapping(\"/list/{pageNo}\")\npublic R&lt; PageInfo&lt;Vip&gt;&gt; findAll(@PathVariable int pageNo) {\n    // 设置当前页码和每页显示的条数,设置后会自动为查询语句加limit\n    PageHelper.startPage(pageNo, 10);\n    // 查询数据\n    List&lt;Vip&gt; allVip = vipService.findAllVip();\n    // 将数据封装到pageinfo对象中\n    PageInfo&lt;Vip&gt; pageInfo = new PageInfo&lt;&gt;(allVip);\n    return R.OK(pageInfo);\n}\n</code></pre>\n<h2 id=\"改进r对象\">改进R对象</h2>\n<p>添加一个枚举类型</p>\n<pre><code class=\"language-java\">package com.ali.springboot3ssm.enums;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\n\n@NoArgsConstructor\n@AllArgsConstructor\npublic enum CodeEnum {\n    // 枚举的大括号一开始的位置必须有枚举值\n    //  枚举值下面如果没有代码，枚举值列表最后的“；”可以省略\n    //  枚举值下面如果有代码，枚举值列表最后的“；” 不可以省略\n    OK(200, \"OK\"),\n    FAIL(400, \"失败\"),\n    BAD_REQUEST(400, \"失败\"),\n    NOT_FOUND(400, \"失败\"),\n    INTERNAL_ERROR(400, \"失败\"),\n    MODIFICATION_ERROR(400, \"失败\"),\n    DELETION_ERROR(400, \"失败\"),\n    CREATE_ERROR(400, \"失败\");\n\n    @Getter\n    @Setter\n    private int code;\n    @Getter\n    @Setter\n    private String msg;\n}\n</code></pre>\n<p>重写R类</p>\n<pre><code class=\"language-java\">@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder // 建造模式\npublic class R&lt;T&gt; {\n\n    // 响应状态码\n    private int code;\n    // 消息描述：成功或失败\n    private String msg;\n    // 响应对象：任意类型对象\n    private  T data;\n\n    public static &lt;T&gt; R&lt;T&gt; OK(T data) {\n        return R.&lt;T&gt;builder().code(CodeEnum.OK.getCode()).msg(CodeEnum.OK.getMsg()).data(data).build();\n    }\n\n    // 成功的方法\n    public static &lt;T&gt; R&lt;T&gt; OK() {\n        return R.&lt;T&gt;builder().code(CodeEnum.OK.getCode()).msg(CodeEnum.OK.getMsg()).build();\n    }\n\n    // 失败的方法\n    public static &lt;T&gt; R&lt;T&gt; FAIL(CodeEnum codeEnum) {\n        return R.&lt;T&gt;builder().code(codeEnum.getCode()).msg(codeEnum.getMsg()).build();\n    }\n\n    public static &lt;T&gt; R&lt;T&gt; FAIL() {\n        return R.&lt;T&gt;builder().code(CodeEnum.FAIL.getCode()).msg(CodeEnum.FAIL.getMsg()).build();\n    }\n}\n</code></pre>\n<h1 id=\"事务管理\">事务管理</h1>\n<p>spring boot自动配置了事务管理器。只需要使用@Transactional注解标注需要事务控制的方法即可。</p>\n<p>就这么简单。</p>\n<h1 id=\"怎么打war包\">怎么打war包</h1>\n<p>修改pom文件</p>\n<pre><code class=\"language-xml\">&lt;!--    打包方式修改为war--&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n&lt;!--        排除tomcat--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n\n&lt;!--        添加tomcat依赖--&gt;\n  &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n&lt;!--            provided:表示这个依赖不会被打到war包中，只是编译时使用--&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>启动类继承SpringBootServletInitializer类并重写configure方法</p>\n<pre><code class=\"language-java\">@MapperScan(basePackages = \"com.ali.springboot3ssm.repository\")\n@SpringBootApplication\npublic class Springboot3SsmApplication extends SpringBootServletInitializer {\n\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {\n        return builder.sources(Springboot3SsmApplication.class);\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot3SsmApplication.class, args);\n    }\n\n}\n</code></pre>\n<h1 id=\"日志处理\">日志处理</h1>\n<h2 id=\"抽象的日志框架\">抽象的日志框架</h2>\n<p>什么时抽象的日志框架？编译阶段可以使用抽象的日志框架，能正常编译。但运行阶段必须提供具体的日志框架，目的是：具体的日志框架可灵活切换。</p>\n<p>抽象框架有SLF4J  、   Commons Logging。这2个都可以绑定具体的日志框架，如Log4j、Log4j2、Logback、JUL</p>\n<h2 id=\"具体的日志框架\">具体的日志框架</h2>\n<p>Log4j（已过时）、Log4j2（推荐）、Logback（推荐）、JUL（Java util Logging，功能有限，适合小型应用）</p>\n<p>spring boot默认集成log back</p>\n<h2 id=\"日志级别\">日志级别</h2>\n<p>日志级别由低到高：</p>\n<ol>\n<li>trace：级别最低。记录最详细信息，通常在调试时使用</li>\n<li>debug：记录程序运行时的详细信息，比如变量的值，进入或退出某个方法等，主要用于开发时调试</li>\n<li>info：记录一般信息，如系统启动、服务初始化完成等，表示程序运行正常。</li>\n<li>warn：警告信息</li>\n<li>error：错误信息</li>\n</ol>\n<p>生成环境中 通常把日志级别设为info或更高级别</p>\n<p>开发或测试环境中，设为debug或trace</p>\n<p>spring boot默认日志级别是info</p>\n<pre><code class=\"language-java\">@Slf4j // 这是lombok的一个注解，作用是为我们维护一个日志对象log\n@SpringBootApplication\npublic class Springboot3SsmApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot3SsmApplication.class, args);\n\n        // 直接使用log\n        log.info(\"日志信息\");\n    }\n}\n</code></pre>\n<h3 id=\"调整日志级别\">调整日志级别</h3>\n<pre><code class=\"language-properties\"># 调整日志级别\nlogging.level.root=debug\n</code></pre>\n<h2 id=\"日志的粗细粒度\">日志的粗细粒度</h2>\n<pre><code class=\"language-properties\"># 调整根日志级别（全局的，整个项目都是这个级别）\nlogging.level.root=debug\n# 为特定包设置日志级别\nlogging.level.com.ali.springboot3ssm.controller=debug\n# 为特定类设置日志级别\nlogging.level.com.ali.springboot3ssm.service.UserService=trace\n# 在控制台中打印sql (这个包是Mapper类所在的包)\nlogging.level.com.ali.springboot3ssm.repository=debug\n</code></pre>\n<h2 id=\"日志输出到文件\">日志输出到文件</h2>\n<p>有2种方式，这2种方式不能共存，如果同时存在，只有logging.file.name生效</p>\n<pre><code class=\"language-properties\"># 将日志文件输出到当前项目根目录下的log目录中。文件名默认spring.log  并且文件名不可修改\n# 路径可随便改。可以是硬盘上的任意有权限路径\nlogging.file.path=./log/\n# 日志文件输出到当前项目根目录下my.log文件。路径不可修改\nlogging.file.name=my.log\n</code></pre>\n<h2 id=\"滚动日志\">滚动日志</h2>\n<p>防止日志无线增长，将日志文件分割成多个文件，避免单个文件过大难以处理</p>\n<pre><code class=\"language-properties\"># 此策略仅适合logback\n# 日志文件达到多大时进行归档,打成一个压缩包\nlogging.logback.rollingpolicy.max-file-size=10MB\n# 归档日志文件总共达到多大时删除\nlogging.logback.rollingpolicy.total-size-cap=50GB\n# 归档日志文件最多保留几天\nlogging.logback.rollingpolicy.max-history=60\n#启动项目时是否清理归档日志文件\nlogging.logback.rollingpolicy.clean-history-on-start=false\n# 归档日志文件名格式\nlogging.logback.rollingpolicy.file-name-pattern=${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz\n</code></pre>\n<h2 id=\"日志框架切换\">日志框架切换</h2>\n<p>先排除log back 再引入新依赖</p>\n<pre><code class=\"language-properties\">&lt;!--                排除默认日志依赖--&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n&lt;!--        引入log4j依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n</code></pre>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/alineverstop/\" target=\"_blank\">NE_STOP</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/alineverstop/p/19552193\" target=\"_blank\">https://www.cnblogs.com/alineverstop/p/19552193</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-30 11:00</span>&nbsp;\n<a href=\"https://www.cnblogs.com/alineverstop\">NE_STOP</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2026年美赛F题——翻译及建模思路",
      "link": "https://www.cnblogs.com/ChenAI-TGF/p/19552100",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ChenAI-TGF/p/19552100\" id=\"cb_post_title_url\" title=\"发布于 2026-01-30 10:48\">\n    <span>2026年美赛F题——翻译及建模思路</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文摘要： 本研究探讨生成式AI对三类职业（STEM、技能型、艺术类）的影响及高等教育应对策略。通过构建职业AI影响评估矩阵，选取数据科学家、西餐主厨和视觉设计师作为代表性职业。建立数据驱动模型（多元线性回归+马尔可夫链），结合世界经济论坛等权威数据，预测各职业5-10年发展趋势。基于模型结果，为三类院校（综合性大学、职业技术学校、艺术院校）提出定制化建议：1）STEM领域加强AI技术融合课程；2）技能型职业注重人机协作实训；3）艺术类专业培养AI辅助创作能力。研究采用熵权法和层次分析法量化评估建议效果，并\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"f题拥抱生成式-ai抑或拒绝\">F题：拥抱生成式 AI，抑或拒绝？</h1>\n<p><img alt=\"在这里插入图片描述\" class=\"lazyload\" /></p>\n<p>短短数年间，生成式人工智能（生成式 AI）已从一款功能有限、仅为少数早期使用者所用的工具，发展为深度融入日常生活、功能强大且无处不在的资源。相关研究表明，生成式 AI 或将深刻影响未来的职场格局。例如，在部分领域，生成式 AI 可能取代人类工作（或大幅减少人力投入），而在另一些领域，其影响则微乎其微，甚至可能推动相关领域的人才需求增长。</p>\n<p>本赛题要求你探究各类高等教育机构应如何结合这一新技术，为未来的毕业生做好最充分的职业准备。具体而言，你需要完成以下任务：</p>\n<ol>\n<li>选取三个职业，三类职业分别对应以下不同领域，各选其一：\n<ul>\n<li>理工科职业：从事该类职业者通常持有理工科、工程学或数学相关专业的四年制大学本科学位；</li>\n<li>技能型职业：从事该类职业者通常接受过职业技术学校的专业培训和 / 或参与学徒制项目，如厨师、水管工、电工等；</li>\n<li>艺术类职业：从事该类职业者通常就读于艺术院校、音乐学院或文化中心并接受专业培养，如音乐家、舞蹈演员、画家等。</li>\n</ul>\n</li>\n<li>结合生成式 AI 当前的发展趋势与预期影响，设计一个<strong>数据驱动模型</strong>，探究你所选的三个职业的未来发展前景。请明确标注数据来源，并阐释你认为生成式 AI 会推动各职业发生变革的核心驱动因素及其背后的逻辑。注：你可参考现有关于未来职场发展的研究成果，但需注明引用来源，并说明如何将这些已有研究用于支撑你的分析。</li>\n<li>为你分析的每个职业各选定一所对应的高等教育机构及相关专业（一所综合性大学、一所职业技术学校、一所艺术院校各对应其一），并围绕这些院校和专业提出针对性建议。即你需要形成三组建议，每组建议均需回答核心问题：基于你的分析，你将为这些院校的管理者提供何种建议，使其能在对应职业的相关专业建设中，应对生成式 AI 带来的挑战与机遇？</li>\n</ol>\n<p>以下是一些可供参考的思考方向，参赛队伍无需逐一展开分析，可将其作为思路启发，开展连贯且深入的研究分析，各队伍的分析内容应具有独特性。</p>\n<ul>\n<li>受生成式 AI 引发的职业变革影响，相关专业的招生规模是否应扩大或缩减（即培养更多还是更少的专业人才）？若该领域的人才需求呈增长趋势，院校应如何扩大招生？若需求萎缩，院校是否有其他专业可扩大招生规模，吸纳原本就读该专业的学生？</li>\n<li>这三类不同专业的课程体系中，应设置哪些与生成式 AI 相关的教学内容？许多高等教育机构都提出了这一问题，目前仍在探索应对方案。部分院校直接禁止学生在各类作业中使用人工智能工具，也有院校将人工智能的应用列为课程核心内容；一些院校旨在培养能深耕该技术前沿、做出专业贡献的技术人才，也有院校聚焦于培养非技术领域中能熟练运用该技术的从业者；部分院校鼓励学生探索该新技术的各类应用场景，还有院校引导学生结合生成式 AI 所需的能源消耗、水资源需求，以及其存在的创意或内容溯源不充分（往往缺失或错误标注原创者）等风险，审慎权衡使用该技术的利弊。针对你选定的三所院校的三个专业，你能提出哪些建议，最大程度提升其毕业生的就业竞争力？请结合数学模型的分析结果为建议提供支撑。</li>\n<li>本赛题以生成式 AI 无处不在的背景下毕业生的就业竞争力为切入点展开探讨，但院校的相关政策是否成功，或许不能仅以就业市场的需求作为唯一衡量标准。你认为还应考虑哪些因素？当纳入这些因素后，你的模型和建议会做出哪些调整？</li>\n<li>若你认为自己提出的具体建议可推广至更多院校和 / 或专业，需明确说明推广的适用范围，并为这一推广思路提供合理依据。</li>\n</ul>\n<p>你需提交一份不超过 25 页的 PDF 格式解决方案，内容应包含：</p>\n<ul>\n<li>1 页摘要页</li>\n<li>目录</li>\n<li>完整的解决方案</li>\n<li>参考文献</li>\n<li>人工智能使用报告（若使用了生成式 AI，该报告不计入 25 页的页数限制）</li>\n</ul>\n<p>注：本次跨学科数学建模竞赛对参赛作品的最低页数无硬性要求。你可使用最多 25 页的篇幅呈现完整的解决方案，以及所有想要补充的内容（如图表、计算过程、表格等）。赛事接受部分完成的解决方案。参赛队伍可审慎使用 ChatGPT 等生成式人工智能工具，并非完成本赛题的必要手段。若选择使用生成式人工智能，必须遵守美国数学及其应用联合会的人工智能使用政策，且需在 PDF 解决方案末尾附加一份人工智能使用报告，该报告不计入 25 页的页数限制。</p>\n<h1 id=\"三大核心任务-基础思路--模型--步骤极简版\">三大核心任务 基础思路 + 模型 + 步骤（极简版）</h1>\n<h3 id=\"任务-1选取三类职业stem--技能型--艺术类各-1-个\">任务 1：选取三类职业（STEM / 技能型 / 艺术类各 1 个）</h3>\n<p><strong>基础思路</strong>：按 Gen-AI 对职业的</p>\n<p><strong>影响类型</strong>（替代 / 辅助 / 赋能）筛选，优先选行业数据充足、Gen-AI 影响特征显著的职业，避免选边界模糊的职业。</p>\n<p><strong>基础模型</strong>：职业 AI 影响评估矩阵（维度：AI 替代度、AI 赋能效率、实操 / 创意不可替代性）。</p>\n<p><strong>完成步骤</strong>：1. 梳理现有 Gen-AI 职场影响研究，提取三类领域候选职业；2. 用矩阵量化评分（1-5 分）；3. 选定评分特征差异化的 3 个职业（如 STEM 选数据科学家、技能型选西餐主厨、艺术类选视觉设计师）。</p>\n<h3 id=\"任务-2设计数据驱动模型分析-gen-ai-对-3-个职业的未来影响\">任务 2：设计数据驱动模型分析 Gen-AI 对 3 个职业的未来影响</h3>\n<p><strong>基础思路</strong>：多维度量化 Gen-AI 影响，结合行业趋势、就业数据、技术迭代，预测职业需求 / 技能要求变化，明确核心驱动因素，锚定权威数据来源。</p>\n<p><strong>基础模型</strong>：1. 定量核心：<strong>多元线性回归</strong>（分析 AI 指标对职业就业量的影响）+<strong>马尔可夫链</strong>（预测职业发展状态）；2. 辅助：德尔菲法（专家意见修正模型）、SWOT-AHP（量化职业发展优劣势 / 机遇威胁）。</p>\n<p><strong>完成步骤</strong>：1. 确定模型指标（替代率、赋能效率、行业增长率、技能更新率等）；2. 收集预处理数据（世界经济论坛、劳工统计局、AI 行业报告等）；3. 构建训练模型并验证精度；4. 预测 5-10 年职业趋势，提炼 Gen-AI 驱动职业变革的核心因素（如技术迭代速度、行业适配性）。</p>\n<h3 id=\"任务-3选对应院校专业--提三类定制化建议\">任务 3：选对应院校专业 + 提三类定制化建议</h3>\n<p><strong>基础思路</strong>：匹配职业与院校类型（大学 / 技校 / 艺术院校），结合模型预测的职业趋势（需求增 / 减、技能缺口），提</p>\n<p><strong>课程 / 招生 / 资源调配：</strong>建议，建议需用模型量化结果支撑，可补充非就业因素修正。</p>\n<p><strong>基础模型</strong>：1. 技能 - 课程匹配度量化模型（熵权法）；2. 招生规模优化模型（线性规划，基于职业需求预测）；3. 非就业因素评估模型（层次分析法，维度：学科传承、教育公平、社会价值）。</p>\n<p><strong>完成步骤</strong>：1. 为 3 个职业选定对应院校及专业（如大学数据科学、技校西餐烹饪、艺术院校视觉传达）；2. 量化现有专业课程与职业新技能需求的缺口；3. 分院校提定制化建议（课程融入 AI、调整招生规模、跨专业资源整合等）；4. 纳入非就业因素修正建议，验证建议的普适性并说明推广范围。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-30 10:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ChenAI-TGF\">TTGF</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FastAPI参数大全：从路径查询到请求体，一篇搞定所有传参方式",
      "link": "https://www.cnblogs.com/ymtianyu/p/19551637",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19551637\" id=\"cb_post_title_url\" title=\"发布于 2026-01-30 09:38\">\n    <span>FastAPI参数大全：从路径查询到请求体，一篇搞定所有传参方式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        你是不是经常纠结API接口里该用路径参数还是查询参数？参数验证怎么写才优雅？请求体里混着路径参数和嵌套模型又该如何处理？本文以一名老开发的经验，用餐厅点餐的比喻，带你系统梳理FastAPI中所有参数类型的使用场景、验证方法及避坑指南，附赠可直接套用的代码模板。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>你是不是经常为API里该用<code style=\"color: rgba(186, 55, 42, 1);\">路径参数</code>还是<code style=\"color: rgba(186, 55, 42, 1);\">查询参数</code>而头疼？又或者面对请求体、Cookie、Header一堆参数不知从何下手？</p>\n<p>我见过太多项目，接口参数设计得那叫一个随心所欲，路径里塞过滤条件，查询参数里传资源ID，后期维护和联调简直就是大型甩锅现场。今天，咱就用一个餐厅点餐的比喻，把FastAPI里这点参数事，掰开了、揉碎了讲清楚。保证你听完就能用，用了就不想换。🎯</p>\n<h2>📖 先唠两句：参数就像餐厅点单</h2>\n<p>把API想象成一家餐厅的“后厨系统”。</p>\n<div>\n<p><strong>🍽️ 路径参数</strong><span style=\"color: rgba(186, 55, 42, 1);\"><code> /dishes/{dish_id}</code></span> -&gt; 好比你要点“宫保鸡丁”这道具体的菜，它是菜单（资源路径）的一部分。</p>\n<p><strong>🔍 查询参数</strong><span style=\"color: rgba(186, 55, 42, 1);\"><code> /dishes?spicy=true&amp;type=Sichuan</code></span> -&gt; 好比你说“我要川菜，要辣的”。这是对结果的筛选和描述，不是特定资源。</p>\n<p><strong>📦 请求体</strong> -&gt; 你递进去的详细订单，包括要什么菜、口味、备注，内容可以很复杂。</p>\n<p><strong>🍪 Cookie / 📋 Header</strong> -&gt; 像是你的会员卡（自动带身份）或者你给服务员的口头特殊要求（如“快点上”）。</p>\n</div>\n<p>搞清楚这个，参数该放哪儿，基本就对了一半。另一半，在于怎么让后厨（你的代码）准确无误地理解这些“订单”。</p>\n<h2>🚀 第一部分：基础必知——路径与查询参数</h2>\n<p>好，咱们先来聊聊最常用的两个兄弟。</p>\n<h3>🎯 路径参数：锁定具体目标</h3>\n<p>用来<strong style=\"color: rgba(186, 55, 42, 1);\">唯一标识</strong>一个资源。想象一下，你要获取ID为42的用户信息，路径就是 <code style=\"color: rgba(186, 55, 42, 1);\">/users/42</code>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int): # FastAPI自动将路径中的item_id转换为int\n    return {\"item_id\": item_id}</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">关键点</strong>：参数类型声明（如<code style=\"color: rgba(186, 55, 42, 1);\">int</code>）至关重要，FastAPI会据此自动进行类型转换和验证。如果你传个“abc”进来，它会礼貌地返回一个错误，而不是让你的代码崩溃。</p>\n<p>这里千万别学我当初偷懒，所有参数都定义成字符串，到函数内部再转换。结果就是错误处理代码散落一地，调试起来想哭。</p>\n<h3>🎯 查询参数：提供筛选与选项</h3>\n<p>它不是路径的一部分，跟在<code style=\"color: rgba(186, 55, 42, 1);\">?</code>后面，用<code style=\"color: rgba(186, 55, 42, 1);\">&amp;</code>连接。比如 <code style=\"color: rgba(186, 55, 42, 1);\">/items/?skip=0&amp;limit=10</code>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.get(\"/items/\")\nasync def read_items(skip: int = 0, limit: int = 10):\n    return {\"skip\": skip, \"limit\": limit}</code></pre>\n<p>注意到<code style=\"color: rgba(186, 55, 42, 1);\">= 0</code>和<code style=\"color: rgba(186, 55, 42, 1);\">= 10</code>了吗？这给了它们默认值，让它们变成了<strong style=\"color: rgba(186, 55, 42, 1);\">可选参数</strong>。没有默认值的参数，就是必选查询参数。</p>\n<p>官方文档虽然把查询参数讲得很简单，但根据我们的线上经验，对于复杂的分页过滤接口，<strong style=\"color: rgba(186, 55, 42, 1);\">强烈建议用Pydantic模型来封装查询参数</strong>，而不是把一长串参数都列在函数定义里，维护起来简直是灾难。这个我们后面讲。</p>\n<h2>🛡️ 第二部分：进阶必备——参数验证与请求体</h2>\n<p>接下来重点来了，如何确保客人点的菜是合理的？比如“宫保鸡丁”要求加“草莓”，这得拦住。</p>\n<h3>🎯 用Query、Path、Body等工具精细控制</h3>\n<p>Fastapi提供了这些“工具函数”，让你能对参数进行更多描述。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Query, Path\n\n@app.get(\"/items/{item_id}\")\nasync def read_items(\n    item_id: int = Path(..., title=\"商品ID\", ge=1), # ...表示无默认值，必填。ge=1表示大于等于1\n    q: str = Query(None, min_length=3, max_length=50), # 可选参数，None是默认值\n    size: float = Query(1.0, gt=0, lt=10) # 可选，必须大于0小于10\n):\n    return {\"item_id\": item_id, \"q\": q, \"size\": size}</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">踩坑提醒</strong>：当同一个参数既可能是路径参数又可能是查询参数时（虽然设计上应避免），FastAPI默认会认为是查询参数。你必须显式使用<code style=\"color: rgba(186, 55, 42, 1);\">Path</code>来声明它是路径参数。</p>\n<h3>🎯 请求体（Body）：处理复杂数据</h3>\n<p>当数据复杂时（比如创建一篇博客文章），就用请求体，通常是POST/PUT。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">核心工具：Pydantic模型</strong>。这简直是FastAPI的“王牌搭档”，数据验证和序列化的神器。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n    price: float\n    tax: float | None = None\n\n@app.post(\"/items/\")\nasync def create_item(item: Item): # FastAPI会自动从请求体中识别`item`\n    return item</code></pre>\n<p>你可能会问，多个参数混着来怎么办？比如路径参数、查询参数和请求体模型一起？</p>\n<p>放心，FastAPI智能到令人发指。它会自动识别：</p>\n<div>\n<p>1️⃣ 参数在路径中或Path()声明 -&gt; <strong style=\"color: rgba(186, 55, 42, 1);\">路径参数</strong></p>\n<p>2️⃣ 单数类型（int, str等）且有/无默认值(必填/非必填)，或Query()声明等不在路径中 -&gt; <strong style=\"color: rgba(186, 55, 42, 1);\">查询参数</strong></p>\n<p>3️⃣ Pydantic模型类型 -&gt; <strong style=\"color: rgba(186, 55, 42, 1);\">请求体</strong></p>\n</div>\n<pre class=\"language-python highlighter-hljs\"><code>@app.put(\"/items/{item_id}\")\nasync def update_item(\n    item_id: int, # 路径参数\n    q: str | None = None, # 可选查询参数\n    item: Item, # 请求体\n    user: User # 第二个请求体！FastAPI会自动处理为多个请求体参数\n):\n    return {\"item_id\": item_id, \"q\": q, \"item\": item, \"user\": user}</code></pre>\n<h3>🎯 再说个容易翻车的点：嵌套模型与复杂验证</h3>\n<p>Pydantic模型可以嵌套，用来描述复杂数据结构，比如订单里有商品列表，每个商品又有自己的属性。</p>\n<pre class=\"language-python highlighter-hljs\"><code>class Image(BaseModel):\n    url: str\n    name: str\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    tags: list[str] = [] # 字符串列表\n    image: Image | None = None # 嵌套模型\n    \n@app.post(\"/items/\")\nasync def create_item(item: Item):\n    return item</code></pre>\n<p>这个工具的选择，好比选螺丝刀，不是最贵的就好，而是最趁手的。Pydantic就是FastAPI生态里最趁手的那把“瑞士军刀”，字段类型、默认值、自定义验证器（validator），一套全齐。</p>\n<h2>📌 第三部分：扩展知识——Cookie、Header与其他</h2>\n<p>是不是以为这样就完了？餐厅点单还有会员卡和特殊要求呢！</p>\n<h3>🎯 Cookie 和 Header 参数</h3>\n<p>它们通常用于元数据、身份认证等，不直接作为业务参数。在FastAPI中获取它们非常方便。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Cookie, Header\n\n@app.get(\"/\")\nasync def read_header_cookie(\n    user_agent: str | None = Header(None),\n    session_token: str | None = Cookie(None)\n):\n    return {\"user_agent\": user_agent, \"session_token\": session_token}</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">注意</strong>：Header会自动将参数名中的下划线<code style=\"color: rgba(186, 55, 42, 1);\">_</code>转换为连字符<code style=\"color: rgba(186, 55, 42, 1);\">-</code>。比如<code style=\"color: rgba(186, 55, 42, 1);\">user_agent</code>会读取<code style=\"color: rgba(186, 55, 42, 1);\">User-Agent</code>这个请求头，且不区分大小写哦。如果请求头本身就有连字符，直接用<code style=\"color: rgba(186, 55, 42, 1);\">Header(..., alias=\"...\")</code>指定别名。</p>\n<h3>🎯 表单数据（Form）和文件上传（File）</h3>\n<p>当需要接收HTML表单提交的数据或上传文件时使用。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from fastapi import Form, File, UploadFile\n\n@app.post(\"/login/\")\nasync def login(username: str = Form(...), password: str = Form(...)):\n    return {\"username\": username}\n\n@app.post(\"/upload/\")\nasync def upload_file(file: UploadFile = File(...)):\n    content = await file.read()\n    return {\"filename\": file.filename, \"size\": len(content)}</code></pre>\n<p>最后啰嗦一句：<strong style=\"color: rgba(186, 55, 42, 1);\">File和Form参数不能与纯JSON的Body模型混用</strong>，它们是不同的编码格式。接收文件记得用异步读写，大文件更要流式处理，别一股脑读到内存里。</p>\n<h2>✨ 总结与一张速查表</h2>\n<p>好了，咱们今天把FastAPI的参数系统彻底捋了一遍。最后送你一张我总结的“参数安置决策表”，下次设计接口时，拿出来看一眼，保准不迷糊：</p>\n<div style=\"background-color: rgba(248, 249, 250, 1); padding: 15px; border-radius: 5px;\">\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">📌 路径参数（Path）</strong>：用于<strong>唯一指定资源</strong>。如<span style=\"color: rgba(186, 55, 42, 1);\"><code> /users/{id}</code></span></p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">🔍 查询参数（Query）</strong>：用于<strong>过滤、排序、分页</strong>资源列表。如<span style=\"color: rgba(186, 55, 42, 1);\"><code> /users?role=admin&amp;page=2</code></span></p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">📦 请求体（Body）</strong>：用于<strong>创建或更新</strong>资源（复杂数据）。用<span style=\"color: rgba(186, 55, 42, 1);\"><code>Pydantic</code></span>模型。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">🍪 Cookie</strong>：用于<strong>自动携带的会话或身份信息</strong>。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">📋 Header</strong>：用于<strong>元数据、内容协商、认证令牌</strong>等。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">📝 表单（Form）</strong>：用于接收<strong>HTML表单提交</strong>的键值对数据。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">📎 文件（File）</strong>：用于<strong>上传文件</strong>。</p>\n</div>\n<p>技术这东西，底层原理就那些，但经验和最佳实践才是让你少加班的关键。希望这篇来自“踩坑前线”的总结，能让你在玩转FastAPI参数时，更加得心应手。</p>\n<hr />\n<p>我是【一名程序媛】，喜欢用故事讲技术。这篇近3000字的干货，是我想了好久，结合无数个线上真实case总结出来的。如果觉得对你有帮助，<strong style=\"color: rgba(186, 55, 42, 1);\">别忘了点赞、收藏</strong>。下次当你或同事再为参数放哪儿吵架时，就把这篇文章甩过去，能省下至少两杯咖啡的时间。</p>\n<p>还有什么具体想了解的FastAPI骚操作？评论区留言，咱们下回接着聊！</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-30 09:38</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">一名程序媛呀</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Moltbot的安装踩坑与初体验",
      "link": "https://www.cnblogs.com/xiangcaoacao/p/19550609",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiangcaoacao/p/19550609\" id=\"cb_post_title_url\" title=\"发布于 2026-01-30 07:51\">\n    <span>Moltbot的安装踩坑与初体验</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>本文介绍了安装和配置moltbot时踩过的一些坑，并提供了Moltbot接入百炼API的方法和使用飞书与Moltbot交互的方法</p>\n</blockquote>\n<h2 id=\"安装与配置\">安装与配置</h2>\n<p>安装整体还是比较简单的。首先安装一个node.js环境，然后执行<code>npm i -g moltbot@beta</code>就装好了。接着就是在终端中执行<code>moltbot onboard</code>命令，就会启动moltbot的配置向导。如果你刚好能看懂向导中的英文，整个配置流程不难。</p>\n<h2 id=\"踩坑\">踩坑</h2>\n<h3 id=\"npm-i--g-moltbotlatest后显示安装成功但运行moltbot命令失败\"><code>npm i -g moltbot@latest</code>后显示安装成功，但运行<code>moltbot</code>命令失败</h3>\n<h4 id=\"解决\">解决</h4>\n<p>你需要通过<code>npm i -g moltbot@beta</code>重新安装beta版的moltbot。</p>\n<h4 id=\"我的排障历程\">我的排障历程</h4>\n<p>我排障的时候，走了不少弯路。因为我在clawdbot更名成moltbot前一天安装的clawdbot，然后我在使用clawdbot的时候碰到了其他问题，所以选择升级clawdbot。但是我执行升级后，我的clawdbot并没有更名成moltbot，反而是当我在命令行中输入moltbot时，提示<code>command not found</code>。</p>\n<p>最后，我恼羞成怒，卸载clawdbot，然后重新安装moltbot。但是，这下clawdbot和moltbot都没了。这时我才意识到不对。在GitHub的Issue里翻了很久，终于找到了原因</p>\n<h4 id=\"原因\">原因</h4>\n<p>据<a href=\"https://github.com/moltbot/moltbot/issues/3275\" rel=\"noopener nofollow\" target=\"_blank\">Issue #3275</a>反馈，npm中的moltbot包并不是官方发布的moltbot，而是另外一个包。初步看下来像是某人传的一个空包用于占位。</p>\n<ul>\n<li><code>moltbot@latest</code>（默认安装版本）指向一个 <strong>283 字节的占位符包</strong>，由非官方用户 <code>consistent_lee</code> 上传</li>\n<li>真正的项目代码位于 <code>moltbot@beta</code>（版本 <code>2026.1.27-beta.1</code>），大小 41MB，由官方维护者 <code>steipete</code> 上传</li>\n<li>项目 README 仍指导用户执行 <code>npm install -g moltbot@latest</code>，导致用户实际安装的是空包而非真实软件</li>\n<li>此前相关 issue (#2775) 已被关闭并声称“已控制 npm 包”，但 <code>@latest</code> 标签仍未修正</li>\n<li>官方已拥有包所有权，但未通过发布新版本更新 <code>@latest</code> 标签</li>\n<li>存在潜在安全风险（用户无法确认 0.1.0 是否仅为占位符或含恶意代码）</li>\n</ul>\n<p><strong>当前安全安装方式</strong>：<code>npm install -g moltbot@beta</code></p>\n<h3 id=\"配置模型为openroutergooglegemini-20-flash-expfree后无回复\">配置模型为<code>openrouter/google/gemini-2.0-flash-exp:free</code>后无回复</h3>\n<p>本来想白嫖试试moltbot到底表现咋样，但是我配成了官方列表中可能是唯一一个支持免费模型供应商openrouter的免费模型gemini-2.0-flash-exp:free后，发送消息给远端，模型并无回复。<code>moltbot doctor</code> <code>moltbot status</code> 按烂之际，又在<a href=\"https://github.com/moltbot/moltbot/issues/2963\" rel=\"noopener nofollow\" target=\"_blank\">GitHub Issue</a>中找到了原因。</p>\n<h3 id=\"原因-1\">原因</h3>\n<p>注意到<a href=\"https://github.com/moltbot/moltbot/issues/2963\" rel=\"noopener nofollow\" target=\"_blank\">Issue #2963</a>同为发送消息后无回复，官方回复如下，目前issue已关闭：</p>\n<blockquote>\n<p>Tried to setup Kimi 2.5 model via OpenRouter provider. Getting \"not whitelisted\" even config is valid.<br />\n试试 <code>OpenRouter/Kimi 2.5</code>吧。<strong>即使配置有效，也收到“未列入白名单”的错误</strong></p>\n</blockquote>\n<p>实话说这句话我没看懂，不然我也不会贴英文原文了，但是原因肯定是moltbot对openrouter的支持不完全或有些其他的问题导致的。那就换个提供商。</p>\n<h2 id=\"让moltbot使用百炼大模型api\">让moltbot使用百炼大模型API</h2>\n<p>既然openrouter中免费的gemini-2.0无法使用，那么是否可以使用阿里百炼的API呢？新用户也赠送了很多免费的token，用来体验这玩意应该足够了吧。</p>\n<h3 id=\"获取百炼大模型api密钥\">获取百炼大模型API密钥</h3>\n<p><a href=\"https://bailian.console.aliyun.com/cn-beijing/?tab=model#/api-key\" rel=\"noopener nofollow\" target=\"_blank\">百炼大模型控制台</a>，复制API_KEY。</p>\n<p>我是Mac用户，默认的bash为zsh，所以，在终端中执行：</p>\n<pre><code class=\"language-zsh\">echo \"export DASHSCOPE_API_KEY='刚才复制的API_KEY'\" &gt;&gt; ~/.zshrc\nsource ~/.zshrc\necho $DASHSCOPE_API_KEY  # 若配置成功，则应输出刚才复制的API Key\n</code></pre>\n<p>如果是Linux用户，执行：</p>\n<pre><code class=\"language-bash\">echo \"export DASHSCOPE_API_KEY='刚才复制的API_KEY'\" &gt;&gt; ~/.bash_profile\nsource ~/.bash_profile\necho $DASHSCOPE_API_KEY  # 若配置成功，则应输出刚才复制的API Key\n</code></pre>\n<p>如果是Windows用户，执行：</p>\n<pre><code class=\"language-powershell\">echo \"export DASHSCOPE_API_KEY='刚才复制的API_KEY'\" &gt;&gt; ~/AppData/Roaming/Microsoft/Windows/Start\\ Menu/Programs/PowerShell/Microsoft\\ PowerShell/Microsoft\\ PowerShell_profile.ps1\nsource ~/.powershell_profile.ps1\necho $DASHSCOPE_API_KEY  # 若配置成功，则应输出刚才复制的API Key\n</code></pre>\n<p>（应该会在每次powershell启动时加载进环境变量吧？如果不行，后面在配置<code>~/.moltbot/moltbot.json</code>时自行将<code>${DASHSCOPE_API_KEY}</code>换成复制的API_KEY就好了）</p>\n<h3 id=\"修改配置文件\">修改配置文件</h3>\n<p>在这里，需要修改<code>~/.moltbot/moltbot.json</code>文件。首先，<strong>删除</strong><code>~/.moltbot/moltbot.json</code>文件中的<code>auth</code>配置，因为以下配置指向了openrouter的API，而不是阿里百炼的API。也就是说，下面这段直接删掉：</p>\n<pre><code class=\"language-diff\">  \"auth\": {\n    \"profiles\": {\n      \"openrouter:default\": {\n        \"provider\": \"openrouter\",\n        \"mode\": \"api_key\"\n      }\n    }\n  },\n</code></pre>\n<p>第二步，<strong>添加</strong><code>models.providers</code>配置。在<code>models</code>配置中添加下面这段定义百炼API接口的配置。这里新加了百炼的<code>provider</code>，配置了相应的<code>baseUrl</code>、<code>api</code>格式和<code>models</code>信息，并指定<code>apiKey</code> 为刚才在命令行里设置的<code>${DASHSCOPE_API_KEY}</code>。<code>models.providers.bailian.models</code>信息中定义了qwen3-max和qwen3-plus的相关配置。</p>\n<pre><code class=\"language-json\">  \"models\": {\n    \"mode\": \"merge\",\n    \"providers\": {\n      \"bailian\": {\n        \"baseUrl\": \"https://dashscope.aliyuncs.com/compatible-mode/v1\",\n        \"apiKey\": \"${DASHSCOPE_API_KEY}\",\n        \"api\": \"openai-completions\",\n        \"models\": [\n          {\n            \"id\": \"qwen3-max-2026-01-23\",\n            \"name\": \"通义千问 Max Thinking 版\",\n            \"reasoning\": false,\n            \"input\": [\n              \"text\"\n            ],\n            \"cost\": {\n              \"input\": 0.0025,\n              \"output\": 0.01,\n              \"cacheRead\": 0,\n              \"cacheWrite\": 0\n            },\n            \"contextWindow\": 262144,\n            \"maxTokens\": 65536\n          },\n          {\n            \"id\": \"qwen-plus\",\n            \"name\": \"通义千问 Plus\",\n            \"reasoning\": false,\n            \"input\": [\n              \"text\"\n            ],\n            \"cost\": {\n              \"input\": 0.008,\n              \"output\": 0.008,\n              \"cacheRead\": 0,\n              \"cacheWrite\": 0\n            },\n            \"contextWindow\": 1029000,\n            \"maxTokens\": 32000\n          }\n        ]\n      }\n    }\n  },\n</code></pre>\n<p>第三步，<strong>添加</strong><code>agents.defaults.models</code>配置。</p>\n<pre><code class=\"language-json\">  \"agents\": {\n    \"defaults\": {\n      \"models\": {\n        \"bailian/qwen3-max-2026-01-23\": {\n          \"alias\": \"通义千问 Max Thinking 版\"\n        },\n        \"bailian/qwen-plus\": {\n          \"alias\": \"通义千问 Plus\"\n        }\n      },\n</code></pre>\n<p>第四步，<strong>修改</strong><code>agents.default.model.primary</code>配置。因为先前已经配了百炼的API和models，所以这里只需要修改<code>agents.default.model.primary</code>配置为先前定义好的信息就行。<br />\n如果想配<code>qwen3-max</code>，就将值修改为<code>bailian/qwen3-max-2026-01-23</code>：</p>\n<pre><code class=\"language-json\">  \"agents\": {\n    \"defaults\": {\n      \"model\": {\n        \"primary\": \"bailian/qwen3-max-2026-01-23\"\n      },\n</code></pre>\n<p>如果想配<code>qwen3-plus</code>，就将值修改为<code>bailian/qwen3-plus-2026-01-23</code>：</p>\n<pre><code class=\"language-json\">  \"agents\": {\n    \"defaults\": {\n      \"model\": {\n        \"primary\": \"bailian/qwen3-max-2026-01-23\"\n      },\n</code></pre>\n<details>\n如果你没看懂到底要改些什么，可以点此展开，看看我改之前和改之后都有哪些变化\n<p>修改前，我的<code>moltbot.json</code>文件是：</p>\n<pre><code class=\"language-json\">{\n  \"meta\": {\n    \"lastTouchedVersion\": \"2026.1.27-beta.1\",\n    \"lastTouchedAt\": \"2026-01-28T13:56:43.490Z\"\n  },\n  \"wizard\": {\n    \"lastRunAt\": \"2026-01-28T13:56:43.489Z\",\n    \"lastRunVersion\": \"2026.1.27-beta.1\",\n    \"lastRunCommand\": \"doctor\",\n    \"lastRunMode\": \"local\"\n  },\n  \"auth\": {\n    \"profiles\": {\n      \"openrouter:default\": {\n        \"provider\": \"openrouter\",\n        \"mode\": \"api_key\"\n      }\n    }\n  },\n  \"agents\": {\n    \"defaults\": {\n      \"model\": {\n        \"primary\": \"openrouter/google/gemini-2.0-flash-exp:free\"\n      },\n      \"models\": {\n        \"openrouter/auto\": {\n          \"alias\": \"OpenRouter\"\n        },\n        \"openrouter/google/gemini-2.0-flash-exp:free\": {}\n      },\n      \"workspace\": \"~/clawd\",\n      \"compaction\": {\n        \"mode\": \"safeguard\"\n      },\n      \"maxConcurrent\": 4,\n      \"subagents\": {\n        \"maxConcurrent\": 8\n      }\n    }\n  },\n  \"messages\": {\n    \"ackReactionScope\": \"group-mentions\"\n  },\n  \"commands\": {\n    \"native\": \"auto\",\n    \"nativeSkills\": \"auto\"\n  },\n  \"hooks\": {\n    \"internal\": {\n      \"enabled\": true,\n      \"entries\": {\n        \"boot-md\": {\n          \"enabled\": true\n        },\n        \"command-logger\": {\n          \"enabled\": true\n        },\n        \"session-memory\": {\n          \"enabled\": true\n        }\n      }\n    }\n  },\n  \"gateway\": {\n    \"port\": 18789,\n    \"mode\": \"local\",\n    \"bind\": \"loopback\",\n    \"auth\": {\n      \"mode\": \"token\",\n      \"token\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n    },\n    \"tailscale\": {\n      \"mode\": \"off\",\n      \"resetOnExit\": false\n    },\n    \"http\": {\n      \"endpoints\": {\n        \"responses\": {\n          \"enabled\": true\n        }\n      }\n    }\n  },\n  \"skills\": {\n    \"install\": {\n      \"nodeManager\": \"npm\"\n    }\n  }\n}\n</code></pre>\n<p>修改后，我的<code>moltbot.json</code>文件是：</p>\n<pre><code class=\"language-json\">{\n  \"meta\": {\n    \"lastTouchedVersion\": \"2026.1.27-beta.1\",\n    \"lastTouchedAt\": \"2026-01-28T13:56:43.490Z\"\n  },\n  \"wizard\": {\n    \"lastRunAt\": \"2026-01-28T13:56:43.489Z\",\n    \"lastRunVersion\": \"2026.1.27-beta.1\",\n    \"lastRunCommand\": \"doctor\",\n    \"lastRunMode\": \"local\"\n  },\n  \"agents\": {\n    \"defaults\": {\n      \"model\": {\n        \"primary\": \"bailian/qwen3-max-2026-01-23\"\n      },\n      \"models\": {\n        \"bailian/qwen3-max-2026-01-23\": {\n          \"alias\": \"通义千问 Max Thinking 版\"\n        },\n        \"bailian/qwen-plus\": {\n          \"alias\": \"通义千问 Plus\"\n        }\n      },\n      \"workspace\": \"~/clawd\",\n      \"compaction\": {\n        \"mode\": \"safeguard\"\n      },\n      \"maxConcurrent\": 4,\n      \"subagents\": {\n        \"maxConcurrent\": 8\n      }\n    }\n  },\n  \"models\": {\n    \"mode\": \"merge\",\n    \"providers\": {\n      \"bailian\": {\n        \"baseUrl\": \"https://dashscope.aliyuncs.com/compatible-mode/v1\",\n        \"apiKey\": \"${DASHSCOPE_API_KEY}\",\n        \"api\": \"openai-completions\",\n        \"models\": [\n          {\n            \"id\": \"qwen3-max-2026-01-23\",\n            \"name\": \"通义千问 Max Thinking 版\",\n            \"reasoning\": false,\n            \"input\": [\n              \"text\"\n            ],\n            \"cost\": {\n              \"input\": 0.0025,\n              \"output\": 0.01,\n              \"cacheRead\": 0,\n              \"cacheWrite\": 0\n            },\n            \"contextWindow\": 262144,\n            \"maxTokens\": 65536\n          },\n          {\n            \"id\": \"qwen-plus\",\n            \"name\": \"通义千问 Plus\",\n            \"reasoning\": false,\n            \"input\": [\n              \"text\"\n            ],\n            \"cost\": {\n              \"input\": 0.008,\n              \"output\": 0.008,\n              \"cacheRead\": 0,\n              \"cacheWrite\": 0\n            },\n            \"contextWindow\": 1029000,\n            \"maxTokens\": 32000\n          }\n        ]\n      }\n    }\n  },\n  \"messages\": {\n    \"ackReactionScope\": \"group-mentions\"\n  },\n  \"commands\": {\n    \"native\": \"auto\",\n    \"nativeSkills\": \"auto\"\n  },\n  \"hooks\": {\n    \"internal\": {\n      \"enabled\": true,\n      \"entries\": {\n        \"boot-md\": {\n          \"enabled\": true\n        },\n        \"command-logger\": {\n          \"enabled\": true\n        },\n        \"session-memory\": {\n          \"enabled\": true\n        }\n      }\n    }\n  },\n  \"gateway\": {\n    \"port\": 18789,\n    \"mode\": \"local\",\n    \"bind\": \"loopback\",\n    \"auth\": {\n      \"mode\": \"token\",\n      \"token\": \"xxxxxxxxx\"\n    },\n    \"tailscale\": {\n      \"mode\": \"off\",\n      \"resetOnExit\": false\n    },\n    \"http\": {\n      \"endpoints\": {\n        \"responses\": {\n          \"enabled\": true\n        }\n      }\n    }\n  },\n  \"skills\": {\n    \"install\": {\n      \"nodeManager\": \"npm\"\n    }\n  }\n}\n</code></pre>\n</details>\n<p>第五步，应用新的配置文件。在终端中执行：</p>\n<pre><code class=\"language-bash\">moltbot gateway restart  # 重启网关\nmoltbot models status --probe  # 看看有哪些模型可用\n</code></pre>\n<p>此时输出中应有刚才配置的模型。例如我执行后输出为：</p>\n<pre><code class=\"language-text\">🦞 Moltbot 2026.1.27-beta.1 (7eb57b6)\n   Gateway online—please keep hands, feet, and appendages inside the shell at all times.\n\n│\n◇  \nConfig        : ~/.moltbot/moltbot.json\nAgent dir     : ~/.clawdbot/agents/main/agent\nDefault       : bailian/qwen3-max-2026-01-23\nFallbacks (0) : -\nImage model   : -\nImage fallbacks (0): -\nAliases (2)   : 通义千问 Max Thinking 版 -&gt; bailian/qwen3-max-2026-01-23, 通义千问 Plus -&gt; bailian/qwen-plus\nConfigured models (2): bailian/qwen3-max-2026-01-23, bailian/qwen-plus\n\nAuth overview\nAuth store    : ~/.clawdbot/agents/main/agent/auth-profiles.json\nShell env     : off\nProviders w/ OAuth/tokens (0): -\n- bailian effective=models.json:sk-f4b00...fd98280b | models.json=sk-f4b00...fd98280b | source=models.json: ~/.clawdbot/agents/main/agent/models.json\n- openrouter effective=profiles:~/.clawdbot/agents/main/agent/auth-profiles.json | profiles=1 (oauth=0, token=0, api_key=1) | openrouter:default=sk-or-v1...9a6633aa\n\nOAuth/token status\n- none\n\nAuth probes\n┌─────────────────────────────────┬──────────────────────────────┬────────────┐\n│ Model                           │ Profile                      │ Status     │\n├─────────────────────────────────┼──────────────────────────────┼────────────┤\n│ bailian/qwen3-max-2026-01-23    │ models.json (api_key)        │ ok · 5.7s  │\n│ openrouter/ai21/jamba-large-1.7 │ openrouter:default (api_key) │ ok · 2.2s  │\n└─────────────────────────────────┴──────────────────────────────┴────────────┘\nProbed 2 targets in 5.7s\n</code></pre>\n<h3 id=\"验证\">验证</h3>\n<p>运行以下命令进行对话，查看是否成功：</p>\n<pre><code class=\"language-bash\">clawdbot agent --agent main --message \"你是一只猫娘\"\n</code></pre>\n<p>输出为：</p>\n<pre><code class=\"language-text\">🦞 Moltbot 2026.1.27-beta.1 (7eb57b6)\n   Your terminal just grew claws—type something and let the bot pinch the busywork.\n\n│\n◇  \nGateway agent failed; falling back to embedded: Error: gateway closed (1006 abnormal closure (no close frame)): no close reason\nGateway target: ws://127.0.0.1:18789\nSource: local loopback\nConfig: ~/.clawdbot/moltbot.json\nBind: loopback\n我可不是猫娘哦！我是你的智能助手，可以帮你处理各种任务、提醒、查询和自动化操作。有什么我可以帮你的吗？\n</code></pre>\n<p>这样就是成功了。</p>\n<h2 id=\"接入飞书\">接入飞书</h2>\n<p>moltbot火起来的原因是它能通过telegram、discord等平台与用户交互。用户仅需在手机上发一些消息，比如“帮我炒股”之类的指令就能让LLM帮你完成相应的任务。但是因为moltbot是国外的软件，自然不会支持飞书，支持的其他平台也需要魔法才能访问。那么，有没有更简单的方法呢？这里给大家提供两个：</p>\n<ul>\n<li>对接飞书：<a href=\"https://github.com/AlexAnys/feishu-clawdbot-bridge\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/AlexAnys/feishu-clawdbot-bridge</a></li>\n<li>对接钉钉：<a href=\"https://github.com/soimy/clawdbot-channel-dingtalk\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/soimy/clawdbot-channel-dingtalk</a></li>\n</ul>\n<h3 id=\"配置飞书机器人第一部分\">配置飞书机器人（第一部分）</h3>\n<ol>\n<li>打开 <a href=\"https://open.feishu.cn/app\" rel=\"noopener nofollow\" target=\"_blank\">飞书开放平台</a>，登录</li>\n<li>点击 <strong>创建自建应用</strong></li>\n<li>填写应用名称（随意，比如 \"My AI Assistant\"）</li>\n<li>进入应用 → <strong>添加应用能力</strong> → 选择 <strong>机器人</strong></li>\n<li>进入 <strong>权限管理</strong>，开通以下权限：\n<ul>\n<li><code>im:message</code> — 获取与发送单聊、群聊消息</li>\n<li><code>im:message.group_at_msg</code> — 接收群聊中 @ 机器人的消息</li>\n<li><code>im:message.p2p_msg</code> — 接收机器人单聊消息</li>\n</ul>\n</li>\n<li>发布应用（创建版本 → 申请上线）</li>\n<li>记下 <strong>App ID</strong> 和 <strong>App Secret</strong>（在\"凭证与基础信息\"页面）</li>\n</ol>\n<p>还剩下一个添加事件回调的步骤，但是这个步骤会需要先建立长连接，所以先跳过，转而安装飞书桥接器。moltbot侧的飞书配置好后，长连接也就建立了，自然也就可以创建事件回调了。</p>\n<h3 id=\"安装并配置飞书桥接器\">安装并配置飞书桥接器</h3>\n<p>首先是安装：</p>\n<pre><code class=\"language-bash\">moltbot plugins install @m1heng-clawd/feishu\nmoltbot gateway restart\n</code></pre>\n<p>接下来是配置moltbot。你可以输入<code>moltbot channel add</code>通过TUI配置向导配置飞书，也可以使用以下命令进行。</p>\n<pre><code class=\"language-bash\">moltbot config set channels.feishu.appId \"cli_xxxxx\" \nmoltbot config set channels.feishu.appSecret \"your_app_secret\" \nmoltbot config set channels.feishu.enabled true \nmoltbot config set channels.feishu.connectionMode \"websocket\"\nmoltbot gateway restart\n</code></pre>\n<p>安装好并设置好appId和appSecret后，飞书长连接就已经建立了，现在可以继续配置飞书机器人了。</p>\n<h3 id=\"配置飞书机器人第二部分\">配置飞书机器人（第二部分）</h3>\n<ol>\n<li>进入 <strong>事件与回调</strong> → <strong>事件配置</strong>：</li>\n</ol>\n<ul>\n<li>请求方式选择：<strong>使用长连接接收事件</strong></li>\n<li>添加事件：<code>接收消息 im.message.receive_v1</code></li>\n</ul>\n<ol start=\"2\">\n<li>发布应用（创建版本 → 申请上线）</li>\n</ol>\n<h3 id=\"测试\">测试</h3>\n<p>现在，你可以在飞书中使用这个机器人了。在飞书上使用这个机器人才能做到体验接近于网上说的那么夸张。</p>\n<h2 id=\"参考内容\">参考内容</h2>\n<ul>\n<li><a href=\"https://github.com/moltbot/moltbot\" rel=\"noopener nofollow\" target=\"_blank\">moltbot GitHub Repo</a></li>\n<li><a href=\"https://docs.molt.bot/help/troubleshooting\" rel=\"noopener nofollow\" target=\"_blank\">moltbot官网</a></li>\n<li><a href=\"https://developer.aliyun.com/article/1709105\" rel=\"noopener nofollow\" target=\"_blank\">https://developer.aliyun.com/article/1709105</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2625073\" rel=\"noopener nofollow\" target=\"_blank\">https://cloud.tencent.com/developer/article/2625073</a></li>\n<li><a href=\"https://github.com/AlexAnys/feishu-moltbot-bridge\" rel=\"noopener nofollow\" target=\"_blank\">GitHub 飞书接入moltbot项目</a></li>\n<li><a href=\"https://github.com/soimy/clawdbot-channel-dingtalk\" rel=\"noopener nofollow\" target=\"_blank\">GitHub 钉钉接入moltbot项目</a></li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-30 07:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xiangcaoacao\">vanilla阿草</a>&nbsp;\n阅读(<span id=\"post_view_count\">227</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "ZL.ParamEditor：把WinForms配置从‘苦力活’变成‘享受’！",
      "link": "https://www.cnblogs.com/egreen/p/19545570",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/egreen/p/19545570\" id=\"cb_post_title_url\" title=\"发布于 2026-01-30 07:29\">\n    <span>ZL.ParamEditor：把WinForms配置从‘苦力活’变成‘享受’！</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span style=\"font-size: 14px;\">还在为WinForms应用的参数配置界面而心力交瘁吗？手动拖拽控件、写绑定、搞验证、调样式……每一个配置页都是重复的“苦力活”。</span></p>\n<p class=\"ds-markdown-paragraph\">是时候改变了。</p>\n<p class=\"ds-markdown-paragraph\">ZL.ParamEditor 是一个专为 WinForms 打造的高性能参数编辑器框架。它不是你熟悉的另一个控件库，而是一种声明式的开发范式——你只需描述“参数是什么”，框架自动为你生成“交互界面”。</p>\n<p class=\"ds-markdown-paragraph\"><span style=\"color: rgba(0, 0, 255, 1);\"><strong>姊妹篇（安利：WinForms 应用的 SOP（标准操作流程））：&nbsp;<a class=\"ng-star-inserted\" href=\"https://www.cnblogs.com/egreen/p/19545561\" rel=\"noopener\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">https://www.cnblogs.com/egreen/p/19545561</span></a></strong></span></p>\n<h2>痛点终结者：传统开发 vs. ZL.ParamEditor</h2>\n<div class=\"ds-scroll-area _1210dd7 c03cafe9\">\n<div class=\"ds-scroll-area__gutters\">&nbsp;</div>\n<table>\n<thead>\n<tr><th>你的传统困境</th><th>ZL.ParamEditor 的解决之道</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>效率低下：每个参数都需手动创建UI控件和事件逻辑。</td>\n<td>声明式开发：定义&nbsp;<code>ParameterDescriptor</code>&nbsp;列表，UI自动渲染，开发速度提升70%+。</td>\n</tr>\n<tr>\n<td>样式陈旧：WinForms默认界面老旧，实现主题切换困难。</td>\n<td>🎨 运行时主题系统：内置浅色、深色等多套专业主题，支持一键切换与完全自定义。</td>\n</tr>\n<tr>\n<td>验证繁琐：在各个控件的<code>Validating</code>事件中编写重复的验证逻辑。</td>\n<td>✔️ 强大验证框架：在参数描述中声明规则（必填、正则、范围），框架自动接管验证与错误提示。</td>\n</tr>\n<tr>\n<td>扩展性差：遇到特殊参数类型（如时间计划），需大改代码，侵入性强。</td>\n<td>🏭 编辑器工厂模式：轻松注册你的自定义编辑器，无缝集成特殊业务控件，不改动核心框架。</td>\n</tr>\n<tr>\n<td>权限混乱：用<code>if-else</code>控制控件的<code>Enabled</code>和<code>Visible</code>，逻辑分散。</td>\n<td>👥 角色权限系统：在参数描述中指定所需角色，框架自动根据当前用户角色控制UI状态。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2>核心优势：不只是控件，是生产力</h2>\n<ul>\n<li>\n<p class=\"ds-markdown-paragraph\">⚡ 极致效率：从“编码UI”到“描述参数”，解放生产力。</p>\n</li>\n<li>\n<p class=\"ds-markdown-paragraph\">🎨 颜值担当：提供现代化、可主题化的专业界面，提升产品质感。</p>\n</li>\n<li>\n<p class=\"ds-markdown-paragraph\">🛡️ 数据堡垒：内置验证与权限，从源头保障数据准确与安全。</p>\n</li>\n<li>\n<p class=\"ds-markdown-paragraph\">🚀 无限扩展：通过工厂模式，可轻松集成任何自定义控件，应对所有复杂场景。</p>\n</li>\n</ul>\n<h2>无限可能：你的编辑器，你做主</h2>\n<p class=\"ds-markdown-paragraph\">ZL.ParamEditor 的核心魔力在于&nbsp;<code>ControlEditorFactoryRegistry</code>。它让你可以轻松扩展任何类型的参数编辑器。</p>\n<div class=\"ds-scroll-area _1210dd7 c03cafe9\">\n<div class=\"ds-scroll-area__gutters\">&nbsp;</div>\n<table>\n<thead>\n<tr><th>编辑器类型</th><th>描述与内置能力</th><th>你的自定义扩展 (示例)</th></tr>\n</thead>\n<tbody>\n<tr>\n<td>文本输入</td>\n<td>单行、多行、密码框。</td>\n<td><code>TextEditorFactory</code>&nbsp;(内置)</td>\n</tr>\n<tr>\n<td>数值选择</td>\n<td>整型、浮点型数字输入。</td>\n<td><code>NumberEditorFactory</code>&nbsp;(内置)</td>\n</tr>\n<tr>\n<td>布尔选择</td>\n<td>复选框。</td>\n<td><code>CheckboxEditorFactory</code>&nbsp;(内置)</td>\n</tr>\n<tr>\n<td>选项选择</td>\n<td>下拉列表。</td>\n<td><code>DropdownEditorFactory</code>&nbsp;(内置)</td>\n</tr>\n<tr>\n<td>路径选择</td>\n<td>文件、文件夹选择对话框。</td>\n<td><code>FilePathEditorFactory</code>&nbsp;(内置)</td>\n</tr>\n<tr>\n<td>日期/颜色</td>\n<td>日期选择器、颜色选择器。</td>\n<td><code>DatePickerFactory</code>,&nbsp;<code>ColorPickerFactory</code>&nbsp;(内置)</td>\n</tr>\n<tr>\n<td>集合编辑</td>\n<td>编辑字符串列表、甚至数据表格。</td>\n<td><code>StringArrayEditorFactory</code>,&nbsp;<code>GridEditorFactory</code>&nbsp;(内置)</td>\n</tr>\n<tr>\n<td>💡 完全自定义</td>\n<td>集成任何WinForms UserControl。</td>\n<td><code>ScheduleEditorFactory</code>&nbsp;(用于时间计划)<br /><code>EnumRadioGroupEditorFactory</code>&nbsp;(用于单选按钮组)</td>\n\n\n\n\n</tr>\n\n\n\n\n</tbody>\n\n\n\n\n</table>\n\n\n\n\n</div>\n<p class=\"ds-markdown-paragraph\">这意味着什么？&nbsp;无论你的业务参数多么独特——一个复杂的时间排程器、一个带预览的图片选择器，或是一个动态公式编辑器——你都可以为其创建一个专用的<code>UserControl</code>，并通过简单的工厂注册，使其成为框架原生支持的一部分。</p>\n<h2>三行代码，开启高效之旅</h2>\n<p class=\"ds-markdown-paragraph\">告别繁琐，体验声明式开发的优雅。</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:csharp;gutter:true;\">// 1. 创建编辑器（选择主题）\nvar editor = GenericParameterEditorConfig.CreateDark();\n\n// 2. 定义你的参数结构（这才是业务逻辑！）\nvar descriptors = new List&lt;ParameterDescriptor&gt; {\n    new() { Key = \"SiteName\", DisplayName = \"站点名称\", Editor = EditorType.Text, IsRequired = true },\n    new() { Key = \"RetryCount\", DisplayName = \"重试次数\", Editor = EditorType.Number, DefaultValue = 3 },\n    new() { Key = \"DailySchedule\", DisplayName = \"每日计划\", Editor = EditorType.CustomSchedule } // 你的自定义编辑器！\n};\n\n// 3. 绑定数据与角色，完成！\nvar configData = LoadConfig();\neditor.Bind(configData, descriptors, UserRole.Admin);\n// 一个功能完整、美观、带验证和权限的配置界面已就绪！</pre>\n</div>\n<p class=\"ds-markdown-paragraph\">立即尝试 ZL.ParamEditor，你将再也回不去手动编写配置界面的时代。</p>\n<p class=\"ds-markdown-paragraph\">让框架处理重复的UI劳动，而你，专注于创造真正的业务价值。</p>\n<p>地址：<a href=\"https://gitee.com/qwdingyu/ZL.ParamEditor\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/qwdingyu/ZL.ParamEditor</a></p>\n<p>　　&nbsp; &nbsp;<a href=\"https://github.com/qwdingyu/ZL.ParamEditor\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/qwdingyu/ZL.ParamEditor</a></p>\n<p>&nbsp;</p>\n<p class=\"ds-markdown-paragraph\">两个简单的例子：</p>\n<ul>\n<li>JSON配置文件 维护</li>\n</ul>\n<p><img alt=\"image\" class=\"lazyload\" height=\"208\" width=\"1041\" /></p>\n<ul>\n<li>&nbsp;复杂步骤参数维护</li>\n</ul>\n<p><img alt=\"image\" class=\"lazyload\" height=\"334\" width=\"411\" /></p>\n<p>&nbsp;</p>\n\n</div>\n<div id=\"MySignature\">\n    <hr />\n<p>愿意一起学习的小伙伴，可以加qq: 285861181 ，共同交流。</p>\n<hr />\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/egreen/\" target=\"_blank\">egreen</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/egreen/p/19545570\" target=\"_blank\">https://www.cnblogs.com/egreen/p/19545570</a></p>\n<hr />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-30 07:29</span>&nbsp;\n<a href=\"https://www.cnblogs.com/egreen\">egreen</a>&nbsp;\n阅读(<span id=\"post_view_count\">257</span>)&nbsp;\n评论(<span id=\"post_comment_count\">5</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从0到1打造Skill：完整实战指南",
      "link": "https://www.cnblogs.com/deep-sky/p/19550524",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/deep-sky/p/19550524\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 21:44\">\n    <span>从0到1打造Skill：完整实战指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"引言\">引言</h3>\n<p>最近 Skill 可谓热度颇高，无论是微信公众号还是博客园，都能看到大量围绕 Skill 的开发实践、落地方式以及发展趋势的文章。既然如此，我也打算凑个热闹，从实战的角度写一篇关于 Skill 的实践分享。</p>\n<p>在展开之前，先简要说明一下什么是 Skill。Skills 的概念由 Anthropic 提出，本质上是一种更高层次的模块化能力封装，用于扩展智能体的功能边界。每一个 Skill 都封装了指令、元数据以及可选的资源（如脚本、模板等），智能体在执行任务时，会根据上下文相关性自动选择并调用合适的 Skill。</p>\n<h4 id=\"skills能提供什么\">Skills能提供什么？</h4>\n<ol>\n<li>专业工作流 - 特定领域的多步骤操作流程</li>\n<li>工具集成 - 使用特定文件格式或 API 的指导说明</li>\n<li>领域专长 - 企业特有知识、数据架构、业务规则</li>\n<li>资源包 - 处理复杂和重复任务所需的脚本、参考文档和相关资源</li>\n</ol>\n<p>对Skill不了解的同学可以看下我之前的一篇文章 <a href=\"https://www.cnblogs.com/deep-sky/p/19458519\" target=\"_blank\">Claude Skills是什么？为什么要引入Skills？</a></p>\n<h3 id=\"开发个什么skill呢\">开发个什么Skill呢？</h3>\n<p>通过 Skill，我们可以将某些能力进行模块化封装，从而实现特定的工作流编排、专家领域知识沉淀以及各类工具的集成。<br />\n这里我打算来一次“套娃式”的实践：创建一个用于自动生成 Skill 的 Skill，一是用来展示如何创建Skill，二是通过这种方式再深入理解下Skill的设计理念。在实际使用时，用户只需要输入该 Skill 的功能描述、使用场景以及示例用法，系统便可以自动生成对应的 Skill 说明文档、描述信息等配套内容。把这个自动生成Skill的Skill命名成：<code>skill-creator</code>。</p>\n<p>下面，我们按照步骤向<code>skill-creator</code>的SKILL.md文件中写入以下内容：</p>\n<h4 id=\"一定义skill-creator的描述信息\">一、定义<code>skill-creator</code>的描述信息</h4>\n<pre><code>---\nname: skill-creator\ndescription: 生成有效技能的指南。当用户想要创建新技能（或更新现有技能）时，应该使用此技能，该技能可以通过专业知识、工作流或工具集成来扩展Claude的能力。\n---\n</code></pre>\n<h4 id=\"二解释下skill和关于skill\">二、解释下Skill和关于Skill</h4>\n<p>技能是模块化的、自包含的软件包，通过提供专业知识、工作流程和工具来扩展 Claude 的能力。可以把它们想象成特定领域或任务的\"入职指南\"——它们将 Claude 从通用型智能体转变为专业型智能体，使其具备任何模型都无法完全拥有的程序性知识。</p>\n<h5 id=\"skills能提供什么-1\">Skills能提供什么？</h5>\n<ol>\n<li>专业工作流 - 特定领域的多步骤操作流程</li>\n<li>工具集成 - 使用特定文件格式或 API 的指导说明</li>\n<li>领域专长 - 企业特有知识、数据架构、业务规则</li>\n<li>资源包 - 处理复杂和重复任务所需的脚本、参考文档和相关资源</li>\n</ol>\n<h5 id=\"核心理念\">核心理念</h5>\n<h6 id=\"简洁至上\">简洁至上</h6>\n<p>上下文窗口是一种公共资源。技能与 Claude 所需的其他所有内容共享上下文窗口：系统提示词、对话历史、其他技能的元数据以及实际的用户请求。</p>\n<p><strong>基本前提：Claude 本身已经很聪明。</strong> 只需添加 Claude 还不知道的内容。对每条信息都要提出质疑：\"Claude 真的需要这个说明吗？\" 和 \"这段内容的 token 成本值得吗？\"</p>\n<p>优先使用简洁的示例而非冗长的解释。</p>\n<h6 id=\"给予恰当的自由度\">给予恰当的自由度</h6>\n<p>根据任务的脆弱性和可变性来匹配具体程度：</p>\n<p><strong>高自由度（基于文本的指令）</strong>：当存在多种有效方法、决策取决于上下文，或通过启发式方法指导时使用。</p>\n<p><strong>中等自由度（带参数的伪代码或脚本）</strong>：当存在首选模式、可接受一定程度的变化，或配置会影响行为时使用。</p>\n<p><strong>低自由度（特定脚本、少量参数）</strong>：当操作容易出错且脆弱、一致性至关重要，或必须遵循特定顺序时使用。</p>\n<p>可以把 Claude 想象成在探索一条路径：悬崖边的狭窄桥梁需要具体的护栏（低自由度），而开阔的田野则允许多条路线（高自由度）。</p>\n<h4 id=\"三生成的skill有哪些组成部分\">三、生成的Skill有哪些组成部分</h4>\n<p>每个技能都包含一个必需的 SKILL.md 文件和可选的捆绑资源：</p>\n<pre><code>skill-name/\n├── SKILL.md (required)\n│   ├── YAML frontmatter metadata (required)\n│   │   ├── name: (required)\n│   │   └── description: (required)\n│   └── Markdown instructions (required)\n└── Bundled Resources (optional)\n    ├── scripts/          - Executable code (Python/Bash/etc.)\n    ├── references/       - Documentation intended to be loaded into context as needed\n    └── assets/           - Files used in output (templates, icons, fonts, etc.)\n</code></pre>\n<h5 id=\"什么是skillmd\">什么是SKILL.md</h5>\n<p>每个SKILL.md包含：</p>\n<ul>\n<li><strong>头部元数据</strong>（YAML 格式）：包含 <code>name</code>（名称）和 <code>description</code>（描述）字段。这些是 Claude 判断何时使用技能的唯一依据，因此清晰、全面地描述技能的功能和使用场景非常重要。</li>\n<li><strong>主体内容</strong>（Markdown 格式）：关于如何使用该技能的说明和指引。只有在技能被触发后才会加载（如果被触发的话）。</li>\n</ul>\n<h5 id=\"可选的捆绑资源\">可选的捆绑资源</h5>\n<h6 id=\"脚本-scripts\">脚本 (<code>scripts/</code>)</h6>\n<p>可执行代码（Python/Bash 等），适用于需要确保可靠性或经常重复编写的任务。</p>\n<ul>\n<li><strong>何时使用</strong>：当同一段代码需要反复编写，或需要确定性的可靠执行时</li>\n<li><strong>举例</strong>：<code>scripts/rotate_pdf.py</code> 用于 PDF 旋转操作</li>\n<li><strong>优点</strong>：节省 token、结果确定、可能直接执行而无需加载到上下文</li>\n<li><strong>说明</strong>：Claude 仍可能需要读取脚本以进行修改或适配特定环境</li>\n</ul>\n<h6 id=\"参考资料-references\">参考资料 (<code>references/</code>)</h6>\n<p>文档和参考材料，按需加载到上下文中，用于指导 Claude 的工作流程和思考方式。</p>\n<ul>\n<li><strong>何时使用</strong>：当 Claude 工作时需要查阅的文档资料</li>\n<li><strong>举例</strong>：财务架构文档 <code>references/finance.md</code>、公司保密协议模板 <code>references/mnda.md</code>、公司制度 <code>references/policies.md</code>、API 规范 <code>references/api_docs.md</code></li>\n<li><strong>适用场景</strong>：数据库模式、API 文档、专业领域知识、企业政策、详细操作指南</li>\n<li><strong>优点</strong>：让 SKILL.md 保持简洁，只在 Claude 需要时才加载</li>\n<li><strong>最佳实践</strong>：如果文件很大（超过 1 万字），在 SKILL.md 中添加 grep 搜索模式</li>\n<li><strong>避免重复</strong>：信息应该只放在 SKILL.md 或参考文件的其中一处，不要两边都有。详细信息优先放在参考文件中，除非真的是技能核心——这样既能保持 SKILL.md 简洁，又能让信息易于查找而不会占满上下文窗口。SKILL.md 只保留关键的操作说明和流程指引；详细的参考资料、架构图和示例都移到参考文件里。</li>\n</ul>\n<h6 id=\"资源文件-assets\">资源文件 (<code>assets/</code>)</h6>\n<p>无需加载到上下文的文件，主要用于 Claude 产生的最终输出内容中。</p>\n<ul>\n<li><strong>何时使用</strong>：技能需要在最终成果中用到的文件</li>\n<li><strong>举例</strong>：品牌素材 <code>assets/logo.png</code>、PowerPoint 模板 <code>assets/slides.pptx</code>、HTML/React 脚手架 <code>assets/frontend-template/</code>、字体文件 <code>assets/font.ttf</code></li>\n<li><strong>适用场景</strong>：模板文件、图像、图标、样板代码、字体、需要复制或修改的样例文档</li>\n<li><strong>优点</strong>：把输出用的资源和说明文档分开，让 Claude 可以使用这些文件而不占用上下文空间</li>\n</ul>\n<h6 id=\"技能中不应包含的内容\">技能中不应包含的内容</h6>\n<p>技能应仅包含直接支持其功能的核心文件。不要创建无关的文档或辅助文件，例如：</p>\n<ul>\n<li>README.md</li>\n<li>INSTALLATION_GUIDE.md（安装指南）</li>\n<li>QUICK_REFERENCE.md（快速参考）</li>\n<li>CHANGELOG.md（变更日志）</li>\n<li>等等</li>\n</ul>\n<p>技能只应包含 AI 智能体执行任务所需的信息。不应包含创建过程的附加说明、安装测试步骤、用户使用文档等辅助内容。添加额外的文档文件只会造成混乱和干扰。</p>\n<h4 id=\"四渐进式展开设计原则\">四、渐进式展开设计原则</h4>\n<p>技能使用三级加载系统来高效管理上下文：</p>\n<ol>\n<li><strong>元数据（名称 + 描述）</strong> - 始终在上下文中（约100字）</li>\n<li><strong>SKILL.md 正文</strong> - 当技能触发时（&lt;五千字）</li>\n<li><strong>捆绑资源</strong> - 根据 Claude 需要（无限制，因为脚本可以在不读入上下文窗口的情况下执行）</li>\n</ol>\n<h5 id=\"渐进式展示模式\">渐进式展示模式</h5>\n<p>保持 SKILL.md 主体内容精简，控制在 500 行以内，避免上下文过度膨胀。接近这个限制时，应将内容拆分成独立文件。拆分内容时，务必在 SKILL.md 中引用这些文件，并明确说明何时查阅，确保技能使用者知道这些文件的存在及其使用时机。</p>\n<p><strong>核心原则：</strong> 当技能支持多种变体、框架或选项时，SKILL.md 中只保留核心工作流和选择指引。将各变体的具体细节（模式、示例、配置）移至独立的参考文件。</p>\n<h4 id=\"五skill创建流程\">五、Skill创建流程</h4>\n<p>技能创建包括以下步骤：</p>\n<ol>\n<li>通过具体示例理解技能</li>\n<li>规划可重用的技能内容（脚本、参考资料、资源文件）</li>\n<li>初始化技能（运行 init_skill.py）</li>\n<li>编辑技能（实现资源并编写 SKILL.md）</li>\n<li>打包技能（运行 package_skill.py）</li>\n<li>基于实际使用进行迭代</li>\n</ol>\n<p>按顺序遵循这些步骤，除非有明确理由说明某步骤不适用才可跳过。</p>\n<h5 id=\"步骤-1通过具体示例理解技能\">步骤 1：通过具体示例理解技能</h5>\n<p>仅当技能的使用模式已经非常清楚时才跳过此步骤。即使在处理现有技能时，这一步骤仍然很有价值。</p>\n<p>要创建有效的技能，需要清楚理解该技能将如何被使用的具体示例。这种理解可以来自用户直接提供的示例，或经过用户反馈验证的生成示例。</p>\n<p>例如，在构建图像编辑器技能时，相关问题包括：</p>\n<ul>\n<li>\"图像编辑器技能应该支持什么功能？编辑、旋转，还有其他吗？\"</li>\n<li>\"你能给出一些这个技能如何使用的示例吗？\"</li>\n<li>\"我可以想象用户会提出'去除这张图片的红眼'或'旋转这张图片'之类的请求。你还能想到这个技能的其他使用方式吗？\"</li>\n<li>\"用户会说什么来触发这个技能？\"</li>\n</ul>\n<p>为避免让用户不知所措，避免在单条消息中提出太多问题。从最重要的问题开始，根据需要跟进以提高效率。</p>\n<p>当对技能应支持的功能有了清晰认识时，即可结束此步骤。</p>\n<h5 id=\"步骤-2规划可重用的技能内容\">步骤 2：规划可重用的技能内容</h5>\n<p>要将具体示例转化为有效的技能，需要通过以下方式分析每个示例：</p>\n<ol>\n<li>考虑如何从零开始执行该示例</li>\n<li>识别在重复执行这些工作流程时哪些脚本、参考资料和资源文件会有帮助</li>\n</ol>\n<p>示例：在构建 <code>pdf-editor</code> 技能来处理\"帮我旋转这个 PDF\"之类的查询时，分析显示：</p>\n<ol>\n<li>旋转 PDF 每次都需要重写相同的代码</li>\n<li>将 <code>scripts/rotate_pdf.py</code> 脚本存储在技能中会很有帮助</li>\n</ol>\n<p>示例：在设计 <code>frontend-webapp-builder</code> 技能来处理\"给我做个待办事项应用\"或\"做个仪表板追踪我的步数\"之类的查询时，分析显示：</p>\n<ol>\n<li>编写前端网页应用每次都需要相同的样板 HTML/React 代码</li>\n<li>将包含样板 HTML/React 项目文件的 <code>assets/hello-world/</code> 模板存储在技能中会很有帮助</li>\n</ol>\n<p>示例：在构建 <code>big-query</code> 技能来处理\"今天有多少用户登录了？\"之类的查询时，分析显示：</p>\n<ol>\n<li>查询 BigQuery 每次都需要重新发现表结构和关系</li>\n<li>将记录表结构的 <code>references/schema.md</code> 文件存储在技能中会很有帮助</li>\n</ol>\n<p>要确定技能的内容，需要分析每个具体示例，创建要包含的可重用资源清单：脚本、参考资料和资源文件。</p>\n<h5 id=\"步骤-3初始化技能\">步骤 3：初始化技能</h5>\n<p>到这一步，就该真正创建技能了。</p>\n<p>仅当正在开发的技能已经存在，需要进行迭代或打包时才跳过此步骤。在这种情况下，继续下一步。</p>\n<p>从零开始创建新技能时，始终运行 <code>init_skill.py</code> 脚本。该脚本会方便地生成一个新的技能目录模板，自动包含技能所需的一切，使技能创建过程更加高效和可靠。</p>\n<p>用法：</p>\n<pre><code class=\"language-bash\">scripts/init_skill.py &lt;技能名称&gt; --path &lt;输出目录&gt;\n</code></pre>\n<p>该脚本会：</p>\n<ul>\n<li>在指定路径创建技能目录</li>\n<li>生成带有正确前言信息和待办事项占位符的 SKILL.md 模板</li>\n<li>创建示例资源目录：<code>scripts/</code>、<code>references/</code> 和 <code>assets/</code></li>\n<li>在每个目录中添加可以自定义或删除的示例文件</li>\n</ul>\n<p>初始化后，根据需要自定义或删除生成的 SKILL.md 和示例文件。</p>\n<h5 id=\"步骤-4编辑技能\">步骤 4：编辑技能</h5>\n<p>在编辑（新生成或现有的）技能时，请记住该技能是为另一个Claude实例使用而创建的。包含对Claude有益且不明显的信息。考虑哪些程序性知识、领域特定细节或可重用资源能帮助另一个Claude实例更有效地执行这些任务。</p>\n<h6 id=\"41-学习经过验证的设计模式\">4.1 学习经过验证的设计模式</h6>\n<p>根据技能需求，查阅以下有用的指南：</p>\n<ul>\n<li><strong>多步骤流程</strong>：参见 references/workflows.md 了解顺序工作流程和条件逻辑</li>\n<li><strong>特定输出格式或质量标准</strong>：参见 references/output-patterns.md 了解模板和示例模式</li>\n</ul>\n<p>这些文件包含了有效技能设计的成熟最佳实践。</p>\n<h6 id=\"42-从可重用的技能内容开始\">4.2 从可重用的技能内容开始</h6>\n<p>要开始实现，从上面识别的可重用资源开始：<code>scripts/</code>、<code>references/</code> 和 <code>assets/</code> 文件。请注意，此步骤可能需要用户输入。例如，在实现 <code>brand-guidelines</code> 技能时，用户可能需要提供品牌资源或模板存储在 <code>assets/</code> 中，或提供文档存储在 <code>references/</code> 中。</p>\n<p>添加的脚本必须通过实际运行来测试，以确保没有错误且输出符合预期。如果有许多类似的脚本，只需测试代表性样本即可确保它们都能工作，同时平衡完成时间。</p>\n<p>不需要用于该技能的任何示例文件和目录都应删除。初始化脚本会在 <code>scripts/</code>、<code>references/</code> 和 <code>assets/</code> 中创建示例文件来演示结构，但大多数技能不需要所有这些文件。</p>\n<h6 id=\"43-生成-skillmd文件\">4.3 生成 SKILL.md文件</h6>\n<p><strong>编写准则：</strong> 始终使用祈使句/不定式形式。</p>\n<ul>\n<li>前言信息</li>\n</ul>\n<p>编写包含 <code>name</code> 和 <code>description</code> 的 YAML 前言：</p>\n<ul>\n<li><code>name</code>：技能名称</li>\n<li><code>description</code>：这是技能的主要触发机制，帮助 Claude 理解何时使用该技能。\n<ul>\n<li>包含技能的功能和使用时机的具体触发条件/上下文。</li>\n<li>将所有\"何时使用\"的信息都包含在这里 - 不要放在正文中。正文只在触发后才加载，因此正文中的\"何时使用此技能\"部分对 Claude 没有帮助。</li>\n<li><code>docx</code> 技能的描述示例：\"全面的文档创建、编辑和分析功能，支持修订追踪、评论、格式保留和文本提取。当 Claude 需要处理专业文档（.docx 文件）时使用，包括：(1) 创建新文档，(2) 修改或编辑内容，(3) 处理修订追踪，(4) 添加评论，或任何其他文档任务\"。</li>\n</ul>\n</li>\n</ul>\n<p>不要在 YAML 前言中包含任何其他字段。</p>\n<ul>\n<li>正文</li>\n</ul>\n<p>编写使用该技能及其捆绑资源的说明。</p>\n<h4 id=\"六效果展示\">六、效果展示</h4>\n<p>在<code>cursor</code>和<code>claude code</code>对应的skills目录下新建 skill-creator 文件夹并将上述SKILL.md放在该文件夹下，在<code>cursor</code>和<code>claude code</code>中通过 /skill-creator唤起，例如在cursor中的效果是：<br />\n我想要生成一个为我拟定文章题目的Skill</p>\n<p><img alt=\"skill-creator-desc\" class=\"lazyload\" /></p>\n<p>使用效果：</p>\n<p><img alt=\"skill-creator-effect\" class=\"lazyload\" /></p>\n<p>生成后在skills目录下可以看到：</p>\n<p><img alt=\"tech-article-title-generator\" class=\"lazyload\" /></p>\n<p>在cursor中可以使用：</p>\n<p><img alt=\"tech\" class=\"lazyload\" /></p>\n<p>如果你已经使用过Skill，看到这里其实已经能明白：我实现的这个 skill-creator，本质上就是 开源的<a href=\"https://github.com/ComposioHQ/awesome-claude-skills/blob/master/skill-creator\" rel=\"noopener nofollow\" target=\"_blank\">Skill Creator</a>，只不过在这里对其做了一次翻译和封装。</p>\n<p>通过这种方式，一方面可以更直观地理解Skill的设计思路，另一方面也能在实践中加深对其使用方式和边界的认识。</p>\n<h4 id=\"一些好用的skills\">一些好用的Skills</h4>\n<p>下面是一些我觉得很好用的开源Skill是，分享给大家。</p>\n<h1 id=\"claude-skills-资源列表\">Claude Skills 资源列表</h1>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>用途</th>\n<th>下载链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docx</td>\n<td>用追踪修改、批注和格式化功能，轻松创建、编辑和分析 Word 文档。</td>\n<td><a href=\"https://github.com/anthropics/skills/tree/main/skills/docx\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/skills/tree/main/skills/docx</a></td>\n</tr>\n<tr>\n<td>pdf</td>\n<td>提取文本、表格、元数据，合并与标注 PDF 文件。</td>\n<td><a href=\"https://github.com/anthropics/skills/tree/main/skills/pdf\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/skills/tree/main/skills/pdf</a></td>\n</tr>\n<tr>\n<td>pptx</td>\n<td>读取、生成和调整幻灯片、布局与模板。</td>\n<td><a href=\"https://github.com/anthropics/skills/tree/main/skills/pptx\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/skills/tree/main/skills/pptx</a></td>\n</tr>\n<tr>\n<td>xlsx</td>\n<td>电子表格操作：公式、图表、数据转换。</td>\n<td><a href=\"https://github.com/anthropics/skills/tree/main/skills/xlsx\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/anthropics/skills/tree/main/skills/xlsx</a></td>\n</tr>\n<tr>\n<td>Markdown to EPUB Converter</td>\n<td>将 Markdown 文档和聊天摘要转换为专业的 EPUB 电子书文件。</td>\n<td><a href=\"https://github.com/smerchek/claude-epub-skill\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/smerchek/claude-epub-skill</a></td>\n</tr>\n<tr>\n<td>MCP Builder</td>\n<td>指导你用 Python 或 TypeScript 创建高质量的 MCP（模型上下文协议）服务器，轻松将外部 API 和服务集成到 LLM 中。</td>\n<td><a href=\"https://github.com/ComposioHQ/awesome-claude-skills/blob/master/mcp-builder\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ComposioHQ/awesome-claude-skills/blob/master/mcp-builder</a></td>\n</tr>\n<tr>\n<td>prompt-engineering</td>\n<td>教你那些经典的提示工程技巧和模式，包括 Anthropic 的最佳实践和智能体说服原则，让你的提示效果直接拉满！</td>\n<td><a href=\"https://github.com/NeoLabHQ/context-engineering-kit/tree/master/plugins/customaize-agent/skills/prompt-engineering\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/NeoLabHQ/context-engineering-kit/tree/master/plugins/customaize-agent/skills/prompt-engineering</a></td>\n</tr>\n<tr>\n<td>Skill Creator</td>\n<td>手把手教你打造高效的 Claude 技能，通过专业领域知识、工作流和工具集成。</td>\n<td><a href=\"https://github.com/ComposioHQ/awesome-claude-skills/blob/master/skill-creator\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ComposioHQ/awesome-claude-skills/blob/master/skill-creator</a></td>\n</tr>\n<tr>\n<td>software-architecture</td>\n<td>实现了包括 Clean Architecture、SOLID 原则以及全面的软件设计最佳实践在内的设计模式。</td>\n<td><a href=\"https://github.com/NeoLabHQ/context-engineering-kit/tree/master/plugins/ddd/skills/software-architecture\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/NeoLabHQ/context-engineering-kit/tree/master/plugins/ddd/skills/software-architecture</a></td>\n</tr>\n<tr>\n<td>article-extractor</td>\n<td>从网页中提取完整文章内容和元数据。</td>\n<td><a href=\"https://github.com/michalparkola/tapestry-skills-for-claude-code/tree/main/article-extractor\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/michalparkola/tapestry-skills-for-claude-code/tree/main/article-extractor</a></td>\n</tr>\n<tr>\n<td>Canvas Design</td>\n<td>通过设计哲学和美学原则，为海报、设计和静态作品创作精美的 PNG 和 PDF 视觉艺术。</td>\n<td><a href=\"https://github.com/ComposioHQ/awesome-claude-skills/blob/master/canvas-design\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ComposioHQ/awesome-claude-skills/blob/master/canvas-design</a></td>\n</tr>\n<tr>\n<td>Image Enhancer</td>\n<td>通过提升分辨率、清晰度和锐度，优化图像和截图质量。</td>\n<td><a href=\"https://github.com/ComposioHQ/awesome-claude-skills/blob/master/image-enhancer\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ComposioHQ/awesome-claude-skills/blob/master/image-enhancer</a></td>\n</tr>\n<tr>\n<td>Theme Factory</td>\n<td>一键为幻灯片、文档、报告和 HTML 首页等文件应用专业字体和配色主题，提供 10 种预设风格。</td>\n<td><a href=\"https://github.com/ComposioHQ/awesome-claude-skills/blob/master/theme-factory\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/ComposioHQ/awesome-claude-skills/blob/master/theme-factory</a></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"结语\">结语</h4>\n<p>从本质上看，Skills 仍然属于上下文工程的一部分，其核心目标在于缓解上下文长度受限和Token消耗过快的问题。同时，它也继承了优秀系统提示词所具备的设计原则——清晰、简洁、结构化，只不过是以文件系统目录结构的形式。</p>\n<p>希望本文的分享，能够对大家理解 Skills 的设计理念，以及在实际场景中的应用方式，提供一些参考与帮助。</p>\n<p>点击下载本文中的<a href=\"https://files.cnblogs.com/files/blogs/858241/SKILL.md.zip?t=1769695506&amp;download=true\" target=\"_blank\">SKILL.md </a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 21:44</span>&nbsp;\n<a href=\"https://www.cnblogs.com/deep-sky\">DeepSky丶</a>&nbsp;\n阅读(<span id=\"post_view_count\">248</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一款基于 .NET Avalonia 开源免费、快速、跨平台的图片查看器",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19550484",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19550484\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 21:16\">\n    <span>一款基于 .NET Avalonia 开源免费、快速、跨平台的图片查看器</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span class=\"content\">前言</span></h2>\n<p>今天大姚给大家分享一款基于 .NET Avalonia 开源免费、快速、可定制、跨平台的图片查看器：<strong>PicView</strong>。帮助大家享受干净、免费且快速的图片查看体验，没有烦人的弹窗。</p>\n<h2><span class=\"content\">工具介绍</span></h2>\n<p>PicView 是一款基于 .NET Avalonia 的开源免费、快速、可高度定制、跨平台的图片查看器，支持 macOS 和 Windows 10/11 操作系统。它支持几乎所有常见的图像文件类型，包括但不限于 (animated)WEBP、(animated)GIF、SVG、AVIF、HEIC、PSD 等，为用户提供了一个清洁、无干扰且高效的图片浏览体验。</p>\n<p><img alt=\"image\" height=\"577\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211408964-244803537.png\" width=\"864\" /></p>\n<h2><span class=\"content\">工具技术栈</span></h2>\n<p>PicView 是用 C# .NET 构建的，使用 Avalonia 跨平台的 XAML UI 框架。所有的构建版本都使用NativeAOT（附带修剪功能）进行编译，生成一个完全独立的本地可执行文件。</p>\n<p>PicView 利用 Cysharp 的 ZLinq 和 ZString 来实现零内存分配和高性能操作，同时使用R3来实现高性能的 ViewModel 绑定和事件流处理。</p>\n<h2><span class=\"content\">应用场景</span></h2>\n<ul>\n<li><strong>个人用户：</strong>&nbsp;需要快速查看、编辑和管理个人照片和图像收藏。</li>\n<li><strong>专业设计师：</strong>&nbsp;需要查看和预览多种格式的设计稿和图像文件。</li>\n</ul>\n<h2><span class=\"content\">文件类型支持</span></h2>\n<ul>\n<li><strong>常见类型：</strong>&nbsp;.jpg .jpeg .jpe .png .bmp .tif .tiff .gif .ico .jfif .webp .svg .svgz。</li>\n<li><strong>高级类型：</strong>&nbsp;.psd .psb .xcf .jxl .heic .heif .jp2 .hdr .tga .dds。</li>\n<li><strong>RAW类型：</strong>.3fr .arw .cr2 .cr3 .crw .dcr .dng .erf .kdc .mdc .mef .mos .mrw .nrw .orf .pef .raf .raw .rw2 .srf .x3f。</li>\n<li><strong>其他类型：</strong>&nbsp;.pgm .hdr .cut .exr .dib .emf.wmf .wpg .pcx .xbm .xpm .wbmp。</li>\n</ul>\n<h2><span class=\"content\">工具源代码</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211429178-1561826034.png\" /></p>\n<h2><span class=\"content\">功能演示</span></h2>\n<p><img alt=\"image\" height=\"663\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211408964-244803537.png\" width=\"993\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211446529-386230130.png\" /></p>\n<p><strong>图片信息窗口：</strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211521330-1639886864.png\" /></p>\n<p>你可以通过编辑宽度和/或高度文本框来更改图片大小。要按百分比调整大小，只需在数值后加上百分比符号即可。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211532989-1693189361.png\" /></p>\n<p><strong>图片集：</strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211543075-391351691.png\" /></p>\n<p><strong>裁剪图像：</strong></p>\n<div>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211554903-1720426709.png\" /></p>\n<p><strong>批量调整大小：</strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211606261-1842201979.png\" /></p>\n<p><strong>图片更名：</strong></p>\n<div>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260129211617312-1618992927.png\" /></p>\n<p>按 F2 或右键点击标题栏文件，可以重命名或移动文件。更改文件扩展名后，图片会被转换成相应格式。</p>\n<h2><span class=\"content\">项目源码地址</span></h2>\n<p>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</p>\n<ul>\n<li><strong>GitHub开源地址：</strong>&nbsp;<a href=\"https://github.com/Ruben2776/PicView\" rel=\"noopener nofollow\">https://github.com/Ruben2776/PicView</a></li>\n</ul>\n<h2><span class=\"content\">优秀项目和框架精选</span></h2>\n<p>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong>）。</p>\n<ul>\n<li><strong>GitHub开源地址：</strong>&nbsp;<a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\">https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</a></li>\n<li><strong>Gitee开源地址：</strong>&nbsp;<a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\">https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</a></li>\n</ul>\n</div>\n</div>\n\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 21:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">388</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI Agent 框架探秘：拆解 OpenHands（4）--- 服务",
      "link": "https://www.cnblogs.com/rossiXYZ/p/19530117",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/rossiXYZ/p/19530117\" id=\"cb_post_title_url\" title=\"发布于 2026-01-29 19:50\">\n    <span>AI Agent 框架探秘：拆解 OpenHands（4）--- 服务</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"ai-agent-框架探秘拆解-openhands4----服务\">AI Agent 框架探秘：拆解 OpenHands（4）--- 服务</h1>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#ai-agent-框架探秘拆解-openhands4----服务\" rel=\"noopener nofollow\">AI Agent 框架探秘：拆解 OpenHands（4）--- 服务</a><ul><li><a href=\"#0x00-概述\" rel=\"noopener nofollow\">0x00 概述</a></li><li><a href=\"#0x01-服务\" rel=\"noopener nofollow\">0x01 服务</a><ul><li><a href=\"#11-api-模式\" rel=\"noopener nofollow\">1.1 API 模式</a><ul><li><a href=\"#111-actions\" rel=\"noopener nofollow\">1.1.1 Actions</a></li><li><a href=\"#112-observation\" rel=\"noopener nofollow\">1.1.2 observation</a></li></ul></li><li><a href=\"#12-服务器组件\" rel=\"noopener nofollow\">1.2 服务器组件</a><ul><li><a href=\"#sessionpy\" rel=\"noopener nofollow\">session.py</a></li><li><a href=\"#sessionagent_sessionpy\" rel=\"noopener nofollow\">session/agent_session.py</a></li><li><a href=\"#sessionconversation_managerconversation_managerpy\" rel=\"noopener nofollow\">session/conversation_manager/conversation_manager.py</a></li><li><a href=\"#listenpy\" rel=\"noopener nofollow\">listen.py</a></li></ul></li><li><a href=\"#13-服务工作流程描述\" rel=\"noopener nofollow\">1.3 服务工作流程描述</a></li><li><a href=\"#14-listen_socketpy\" rel=\"noopener nofollow\">1.4 listen_socket.py</a><ul><li><a href=\"#141-核心特色\" rel=\"noopener nofollow\">1.4.1 核心特色</a></li><li><a href=\"#142-具体功能\" rel=\"noopener nofollow\">1.4.2 具体功能</a></li><li><a href=\"#143-流程图\" rel=\"noopener nofollow\">1.4.3 流程图</a></li><li><a href=\"#144-会话连接\" rel=\"noopener nofollow\">1.4.4 会话连接</a></li><li><a href=\"#145-代码\" rel=\"noopener nofollow\">1.4.5 代码</a></li></ul></li></ul></li><li><a href=\"#0xff-参考\" rel=\"noopener nofollow\">0xFF 参考</a></li></ul></li></ul></div><p></p>\n<h2 id=\"0x00-概述\">0x00 概述</h2>\n<p>本篇结合官方文档进行解读OpenHands的服务器，这是OpenHands系统的立身基础。</p>\n<p>因为本系列借鉴的文章过多，可能在参考文献中有遗漏的文章，如果有，还请大家指出。</p>\n<h2 id=\"0x01-服务\">0x01 服务</h2>\n<p>OpenHands提供了WebSocket服务器。</p>\n<p><img alt=\"openhands-server\" class=\"lazyload\" /></p>\n<h3 id=\"11-api-模式\">1.1 API 模式</h3>\n<p>可以发送或从服务器接收两种类型的消息：</p>\n<ul>\n<li>Actions</li>\n<li>Observations</li>\n</ul>\n<h4 id=\"111-actions\">1.1.1 Actions</h4>\n<p>一个action 包含三个部分：</p>\n<ul>\n<li><code>action</code>：要采取的动作</li>\n<li><code>args</code>：动作的参数</li>\n<li><code>message</code>：可以放在聊天记录中的友好消息</li>\n</ul>\n<p>有几种action 。它们的参数列在下面。 随着时间的推移，这个列表可能会增长。</p>\n<ul>\n<li>\n<p><code>initialize</code> - 初始化代理。仅由客户端发送。</p>\n<ul>\n<li><code>model</code> - 要使用的模型名称</li>\n<li><code>directory</code> - 工作空间的路径</li>\n<li><code>agent_cls</code> - 要使用的代理类</li>\n</ul>\n</li>\n<li>\n<p><code>start</code> - 开始一个新的开发任务。仅由客户端发送。</p>\n<ul>\n<li><code>task</code> - 要开始的任务</li>\n</ul>\n</li>\n<li>\n<p><code>read</code> - 读取文件内容。</p>\n<ul>\n<li><code>path</code> - 要读取的文件路径</li>\n</ul>\n</li>\n<li>\n<p><code>write</code> - 写入内容到文件。</p>\n<ul>\n<li><code>path</code> - 要写入的文件路径</li>\n<li><code>content</code> - 写入文件的内容</li>\n</ul>\n</li>\n<li>\n<p><code>run</code> - 运行命令。</p>\n<ul>\n<li><code>command</code> - 要运行的命令</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><code>browse</code> - 打开网页。\n<ul>\n<li><code>url</code> - 要打开的URL</li>\n</ul>\n</li>\n<li><code>think</code> - 允许代理制定计划、设定目标或记录想法\n<ul>\n<li><code>thought</code> - 要记录的想法</li>\n</ul>\n</li>\n<li><code>finish</code> - 代理发出任务完成的信号</li>\n</ul>\n<h4 id=\"112-observation\">1.1.2 observation</h4>\n<p>一个observation 包含四个部分：</p>\n<ul>\n<li><code>observation</code>：观察类型</li>\n<li><code>content</code>：表示观察数据的字符串</li>\n<li><code>extras</code>：额外的结构化数据</li>\n<li><code>message</code>：可以放在聊天记录中的友好消息</li>\n</ul>\n<p>有几种observation 。它们的额外信息列在下面。 随着时间的推移，这个列表可能会增长。</p>\n<ul>\n<li><code>read</code> - 文件内容\n<ul>\n<li><code>path</code> - 读取的文件路径</li>\n</ul>\n</li>\n<li><code>browse</code> - URL的HTML内容\n<ul>\n<li><code>url</code> - 打开的URL</li>\n</ul>\n</li>\n<li><code>run</code> - 命令的输出\n<ul>\n<li><code>command</code> - 运行的命令</li>\n<li><code>exit_code</code> - 命令的退出代码</li>\n</ul>\n</li>\n<li><code>chat</code> - 用户的消息</li>\n</ul>\n<h3 id=\"12-服务器组件\">1.2 服务器组件</h3>\n<p>以下部分描述了OpenHands项目的服务器端组件。</p>\n<h4 id=\"sessionpy\">session.py</h4>\n<p><code>session.py</code> 文件定义了<code>Session</code>类，它代表与客户端的WebSocket会话。关键特性包括：</p>\n<ul>\n<li>处理WebSocket连接和断开</li>\n<li>初始化和管理代理会话</li>\n<li>在客户端和代理之间分发事件</li>\n<li>向客户端发送消息和错误</li>\n</ul>\n<h4 id=\"sessionagent_sessionpy\">session/agent_session.py</h4>\n<p><code>agent_session.py</code> 文件包含<code>AgentSession</code>类，它管理会话内代理的生命周期。关键特性包括：</p>\n<ul>\n<li>创建和管理运行时环境</li>\n<li>初始化代理控制器</li>\n<li>处理安全分析</li>\n<li>管理事件流</li>\n</ul>\n<h4 id=\"sessionconversation_managerconversation_managerpy\">session/conversation_manager/conversation_manager.py</h4>\n<p><code>conversation_manager.py</code> 文件定义了<code>ConversationManager</code>类，它负责管理多个客户端会话。关键特性包括：</p>\n<ul>\n<li>添加和重启会话</li>\n<li>向特定会话发送消息</li>\n<li>清理非活动会话</li>\n</ul>\n<h4 id=\"listenpy\">listen.py</h4>\n<p><code>listen.py</code> 文件是主服务器文件，它设置FastAPI应用程序并定义各种API端点。关键特性包括：</p>\n<ul>\n<li>设置CORS中间件</li>\n<li>处理WebSocket连接</li>\n<li>管理文件上传</li>\n<li>提供代理交互、文件操作和安全分析的API端点</li>\n<li>为前端提供静态文件服务</li>\n</ul>\n<p>该脚本定义了服务接口，主要分为两个部分：</p>\n<ul>\n<li>一部分是通过<code>FastAPI</code>库实现的HTTP接口，其具体实现位于<code>openhands/server/routes</code>目录中；</li>\n<li>另一部分是利用<code>socketio</code>库实现的WebSocket接口，其代码实现在<code>openhands/server/listen_socket.py</code>文件中。用户与代理的交互通过WebSocket进行，连接初始化时会触发<code>connect</code>事件，用户发送消息时会触发<code>oh_user_action</code>事件，连接断开时会触发<code>disconnect</code>事件。因此，梳理代理交互逻辑的核心在于对这三个事件的处理流程进行整理。</li>\n</ul>\n<pre><code class=\"language-python\">import socketio\n\nfrom openhands.server.app import app as base_app\nfrom openhands.server.listen_socket import sio\nfrom openhands.server.middleware import (\n    CacheControlMiddleware,\n    InMemoryRateLimiter,\n    LocalhostCORSMiddleware,\n    RateLimitMiddleware,\n)\nfrom openhands.server.static import SPAStaticFiles\n\nif os.getenv('SERVE_FRONTEND', 'true').lower() == 'true':\n    base_app.mount(\n        '/', SPAStaticFiles(directory='./frontend/build', html=True), name='dist'\n    )\n\nbase_app.add_middleware(LocalhostCORSMiddleware)\nbase_app.add_middleware(CacheControlMiddleware)\nbase_app.add_middleware(\n    RateLimitMiddleware,\n    rate_limiter=InMemoryRateLimiter(requests=10, seconds=1),\n)\n\napp = socketio.ASGIApp(sio, other_asgi_app=base_app)\n</code></pre>\n<h3 id=\"13-服务工作流程描述\">1.3 服务工作流程描述</h3>\n<p>服务的工作流程如下：</p>\n<ol>\n<li><strong>服务器初始化</strong>：\n<ul>\n<li>FastAPI应用程序在<code>listen.py</code>中创建和配置。</li>\n<li>设置CORS中间件和静态文件服务。</li>\n<li>初始化<code>ConversationManager</code>。</li>\n</ul>\n</li>\n<li><strong>客户端连接</strong>：\n<ul>\n<li>当客户端通过WebSocket连接时，创建新的<code>Session</code>或重启现有一个。</li>\n<li><code>Session</code>初始化<code>AgentSession</code>，设置运行时环境和代理控制器。</li>\n</ul>\n</li>\n<li><strong>代理初始化</strong>：\n<ul>\n<li>客户端发送初始化请求。</li>\n<li>服务器根据提供的参数创建和配置代理。</li>\n<li>设置运行时环境，初始化代理控制器。</li>\n</ul>\n</li>\n<li><strong>事件处理</strong>：\n<ul>\n<li><code>Session</code>管理客户端和代理之间的事件流。</li>\n<li>客户端的事件分发到代理。</li>\n<li>代理的观察结果发送回客户端。</li>\n</ul>\n</li>\n<li><strong>文件操作</strong>：\n<ul>\n<li>服务器处理文件上传，确保它们符合大小和类型限制。</li>\n<li>通过运行时环境执行文件读取和写入操作。</li>\n</ul>\n</li>\n<li><strong>安全分析</strong>：\n<ul>\n<li>如果配置了，每个会话初始化安全分析器。</li>\n<li>安全相关的API请求转发到安全分析器。</li>\n</ul>\n</li>\n<li><strong>会话管理</strong>：\n<ul>\n<li><code>ConversationManager</code>定期清理非活动会话。</li>\n<li>它还在需要时处理向特定会话发送消息。</li>\n</ul>\n</li>\n<li><strong>API端点</strong>：\n<ul>\n<li>提供各种API端点，用于代理交互、文件操作和获取配置默认值。</li>\n</ul>\n</li>\n</ol>\n<p>这种服务器架构允许管理多个客户端会话，每个会话都有自己的代理实例、运行时环境和安全分析器。事件驱动设计促进了客户端和代理之间的实时通信，而模块化结构允许轻松扩展和维护不同组件。</p>\n<h3 id=\"14-listen_socketpy\">1.4 listen_socket.py</h3>\n<p>listen_socket.py是 OpenHands 服务器端的 Socket.IO 事件监听器，负责处理客户端和服务器之间的实时双向通信，包括连接建立、事件回放、用户行动转发和连接断开四大核心场景，是客户端与后端会话、代理系统交互的桥梁。</p>\n<h4 id=\"141-核心特色\">1.4.1 核心特色</h4>\n<p>listen_socket.py的核心特色如下：</p>\n<ol>\n<li>断点续传的事件回放：支持通过 <code>latest_event_id</code> 参数实现事件断点续传，客户端重连时仅回放未接收的事件，避免重复数据传输，提升连接效率。</li>\n<li>严格的身份与权限校验：连接建立时校验会话 ID、API 密钥、用户身份（通过 Cookie 和 Authorization 头），确保会话安全性，防止未授权访问。</li>\n<li>向后兼容的事件处理：保留 <code>oh_action</code> 处理器兼容旧版客户端，同时提供 <code>oh_user_action</code> 新版接口，平滑过渡不中断服务。</li>\n<li>有序的事件推送逻辑：代理状态变更事件（<code>AgentStateChangedObservation</code>）最后发送，确保客户端先接收历史事件，再同步最新状态，避免状态不一致。</li>\n<li>异步高效的事件处理：基于异步 IO（<code>async/await</code>）实现事件回放和转发，支持高并发连接，不阻塞主线程，提升系统吞吐量。</li>\n<li>完善的错误处理：连接失败时主动断开无效连接，记录详细日志，便于问题排查；过滤无效事件（如 <code>NullAction</code>），减少不必要的网络传输。</li>\n</ol>\n<h4 id=\"142-具体功能\">1.4.2 具体功能</h4>\n<p>listen_socket.py的具体功能如下：</p>\n<ul>\n<li>\n<p>连接管理（connect 事件）</p>\n<ul>\n<li>身份验证：验证连接参数中的 conversation_id 和 API 密钥</li>\n<li>用户认证：通过 conversation_validator 验证用户身份</li>\n<li>会话恢复：为已存在的会话重放事件流历史</li>\n<li>事件重播：向新连接的客户端发送历史事件，包括过滤特定事件类型</li>\n<li>会话加入：将客户端连接加入到对应的会话中</li>\n</ul>\n</li>\n<li>\n<p>动作处理（oh_user_action 和 oh_action 事件）</p>\n<ul>\n<li>用户动作接收：处理来自客户端的用户操作请求</li>\n<li>事件转发：将用户动作转发到会话管理器进行处理</li>\n<li>向后兼容：同时支持 oh_user_action 和 oh_action 事件处理（后者为兼容旧客户端保留）</li>\n</ul>\n</li>\n<li>\n<p>断开连接处理（disconnect 事件）</p>\n<ul>\n<li>连接清理：当客户端断开连接时，清理相关会话资源</li>\n<li>状态管理：通知会话管理器客户端已断开连接</li>\n</ul>\n</li>\n</ul>\n<p>listen_socket.py的核心工作流程为：</p>\n<ul>\n<li>连接建立：\n<ul>\n<li>解析查询参数（会话 ID、最新事件 ID等）</li>\n<li>验证会话和用户身份</li>\n<li>创建事件存储实例</li>\n</ul>\n</li>\n<li>事件历史重播：\n<ul>\n<li>为客户端重放会话历史事件</li>\n<li>过滤掉 NullAction、NullObservation、RecallAction 等特定事件</li>\n<li>确保 AgentStateChangedObservation 事件最后发送</li>\n</ul>\n</li>\n<li>会话加入：\n<ul>\n<li>将连接 ID 与会话关联</li>\n<li>初始化会话设置</li>\n</ul>\n</li>\n<li>安全机制\n<ul>\n<li>API密钥验证：检查 SESSION_API_KEY 环境变量与查询参数中的密钥是否匹配</li>\n<li>会话权限控制：通过 conversation_validator 验证用户是否有权访问定会话</li>\n</ul>\n</li>\n<li>错误处理\n<ul>\n<li>连接拒绝：在验证失败或出现错误时拒绝连接</li>\n<li>异常传播：使用ConnectionRefusedError处理连接错误</li>\n<li>异步清理：在连接被拒绝后异步断开连接</li>\n</ul>\n</li>\n</ul>\n<p>listen_socket.py 与其他组件关系</p>\n<ul>\n<li>与EventStream紧密配合，负责事件的传输和分发</li>\n<li>通过 connection_manager  管理会话状态</li>\n<li>使用  event_to_dict  进行事件序列化以便通过网络传输</li>\n</ul>\n<h4 id=\"143-流程图\">1.4.3 流程图</h4>\n<p><img alt=\"Openhands-服务\" class=\"lazyload\" /></p>\n<h4 id=\"144-会话连接\">1.4.4 会话连接</h4>\n<p>此处关键一步为与会话管理器 ConversationManager 建立连接。</p>\n<pre><code class=\"language-python\">        conversation_init_data = await setup_init_conversation_settings(\n            user_id, conversation_id, providers_set\n        )\n\n        agent_loop_info = await conversation_manager.join_conversation(\n            conversation_id,\n            connection_id,\n            conversation_init_data,\n            user_id,\n        )\n</code></pre>\n<h4 id=\"145-代码\">1.4.5 代码</h4>\n<p>listen_socket.py的代码举例如下：</p>\n<pre><code class=\"language-python\">@sio.event\nasync def connect(connection_id: str, environ: dict) -&gt; None:\n    \"\"\"\n    SocketIO连接事件处理器：客户端建立连接时触发，完成会话验证、事件回放、会话加入等初始化流程。\n    \n    参数：\n        connection_id: 客户端连接唯一标识（SocketIO分配）\n        environ: WSGI环境变量字典，包含请求头、查询参数等信息\n    \"\"\"\n    try:\n        logger.info(f\"SocketIO连接建立：connection_id={connection_id}\")\n        \n        # 解析查询参数（从WSGI环境变量中提取QUERY_STRING）\n        query_params = parse_qs(environ.get('QUERY_STRING', ''))\n        \n        # 解析最新事件ID（用于断点续传，默认-1表示从最开始回放）\n        latest_event_id_str = query_params.get('latest_event_id', [-1])[0]\n        try:\n            latest_event_id = int(latest_event_id_str)\n        except ValueError:\n            logger.debug(f\"无效的latest_event_id值：{latest_event_id_str}，默认设为-1\")\n            latest_event_id = -1\n        \n        # 解析会话ID（必需参数，用于关联特定对话）\n        conversation_id = query_params.get('conversation_id', [None])[0]\n        logger.info(f\"会话连接请求：conversation_id={conversation_id}, connection_id={connection_id}\")\n        \n        # 解析提供者集合（如支持的LLM提供商列表，用于限制可用资源）\n        raw_list = query_params.get('providers_set', [])\n        providers_list = []\n        for item in raw_list:\n            # 拆分逗号分隔的提供者名称，过滤空值\n            providers_list.extend(item.split(',') if isinstance(item, str) else [])\n        providers_list = [p for p in providers_list if p]\n        providers_set = [ProviderType(p) for p in providers_list]  # 转换为ProviderType枚举类型\n\n        # 校验会话ID是否存在\n        if not conversation_id:\n            logger.error(\"查询参数中缺少conversation_id\")\n            raise ConnectionRefusedError(\"缺少会话ID（conversation_id）\")\n\n        # 校验会话API密钥是否有效\n        if _invalid_session_api_key(query_params):\n            raise ConnectionRefusedError(\"无效的会话API密钥\")\n\n        # 提取请求中的Cookie和Authorization头（用于用户身份验证）\n        cookies_str = environ.get('HTTP_COOKIE', '')\n        # WSGI环境中，HTTP头会转为\"HTTP_前缀+下划线替换短横线\"格式\n        authorization_header = environ.get('HTTP_AUTHORIZATION', None)\n        \n        # 创建会话验证器，校验用户身份（关联会话ID、Cookie、授权头）\n        conversation_validator = create_conversation_validator()\n        user_id = await conversation_validator.validate(\n            conversation_id, cookies_str, authorization_header\n        )\n        \n        # 创建事件存储实例（用于读取会话历史事件）\n        try:\n            event_store = EventStore(\n                conversation_id, conversation_manager.file_store, user_id\n            )\n        except FileNotFoundError as e:\n            logger.error(f\"创建会话事件存储失败：conversation_id={conversation_id}, 错误={e}\")\n            raise ConnectionRefusedError(f\"无法访问会话事件：{e}\")\n\n        agent_state_changed = None  # 存储代理状态变更事件（最后单独发送）\n\n        # 创建异步事件存储包装器，从latest_event_id+1开始回放事件（避免重复）\n        async_store = AsyncEventStoreWrapper(event_store, latest_event_id + 1)\n\n        # 异步回放历史事件（向客户端推送未接收过的事件）\n        async for event in async_store:\n            logger.debug(f\"回放事件：{event.__class__.__name__}\")\n\n            # 跳过无效/召回类事件（无需推送给客户端）\n            if isinstance(\n                event,\n                (NullAction, NullObservation, RecallAction),\n            ):\n                continue\n            # 暂存代理状态变更事件（最后发送，确保客户端状态同步）\n            elif isinstance(event, AgentStateChangedObservation):\n                agent_state_changed = event\n            # 其他事件直接推送给客户端\n            else:\n                await sio.emit('oh_event', event_to_dict(event), to=connection_id)\n\n        # 最后发送代理状态变更事件（确保客户端获取最新状态）\n        if agent_state_changed:\n            await sio.emit(\n                'oh_event', event_to_dict(agent_state_changed), to=connection_id\n            )\n\n        logger.info(f\"会话事件回放完成：conversation_id={conversation_id}\")\n\n        # 初始化会话设置（用户偏好、提供者配置等）\n        conversation_init_data = await setup_init_conversation_settings(\n            user_id, conversation_id, providers_set\n        )\n\n        # 加入会话：关联connection_id与会话，启动代理循环\n        agent_loop_info = await conversation_manager.join_conversation(\n            conversation_id,\n            connection_id,\n            conversation_init_data,\n            user_id,\n        )\n\n        # 校验会话加入结果\n        if agent_loop_info is None:\n            raise ConnectionRefusedError(\"加入会话失败\")\n\n        logger.info(f\"会话加入成功：conversation_id={conversation_id}, connection_id={connection_id}\")\n        \n    except ConnectionRefusedError:\n        # 发送错误后断开无效连接\n        asyncio.create_task(sio.disconnect(connection_id))\n        raise\n\n\n@sio.event\nasync def oh_user_action(connection_id: str, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    处理客户端发送的用户行动事件（如用户输入、操作指令）。\n    \n    参数：\n        connection_id: 客户端连接ID\n        data: 用户行动数据（字典格式，包含行动类型、内容等）\n    \"\"\"\n    # 将用户行动转发到事件流，由会话管理器处理\n    await conversation_manager.send_to_event_stream(connection_id, data)\n\n\n@sio.event\nasync def oh_action(connection_id: str, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    兼容旧版客户端的行动事件处理器（保留用于向后兼容）。\n    \n    注意：待所有客户端升级为使用oh_user_action后，可移除该处理器\n    目前用于支持正在进行中的旧会话，避免中断服务\n    \"\"\"\n    await conversation_manager.send_to_event_stream(connection_id, data)\n\n\n@sio.event\nasync def disconnect(connection_id: str) -&gt; None:\n    \"\"\"\n    SocketIO断开连接事件处理器：客户端断开连接时触发。\n    \n    参数：\n        connection_id: 断开连接的客户端ID\n    \"\"\"\n    logger.info(f\"SocketIO连接断开：connection_id={connection_id}\")\n    # 通知会话管理器，断开该连接与会话的关联\n    await conversation_manager.disconnect_from_session(connection_id)\n</code></pre>\n<h2 id=\"0xff-参考\">0xFF 参考</h2>\n<p><a href=\"https://docs.all-hands.dev/openhands/usage/architecture/backend\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.all-hands.dev/openhands/usage/architecture/backend</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1936485868761257658\" rel=\"noopener nofollow\" target=\"_blank\">当AI Agent从“玩具”走向“工具”，我们该关注什么？Openhands架构解析【第二篇：Agent 相关核心概念】</a>  <a href=\"https://www.zhihu.com/people/dreamrenderx\" rel=\"noopener nofollow\" target=\"_blank\">克里</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1936175201323825087\" rel=\"noopener nofollow\" target=\"_blank\">当AI Agent从“玩具”走向“工具”，我们该关注什么？Openhands架构解析【第一篇：系列导读】</a> <a href=\"https://www.zhihu.com/people/dreamrenderx\" rel=\"noopener nofollow\" target=\"_blank\">克里</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1940436682949244630\" rel=\"noopener nofollow\" target=\"_blank\">Coding Agent之Openhands解析(含代码)</a>  <a href=\"https://www.zhihu.com/people/wu-long-ming-cha-56\" rel=\"noopener nofollow\" target=\"_blank\">Arrow</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/1940824548485347192\" rel=\"noopener nofollow\" target=\"_blank\">OpenHands 源码解读</a>  <a href=\"https://www.zhihu.com/people/xiao-hui-66-72\" rel=\"noopener nofollow\" target=\"_blank\">一力辉</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-29 19:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/rossiXYZ\">罗西的思考</a>&nbsp;\n阅读(<span id=\"post_view_count\">50</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}