{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "使用 NanUI 快速创建具有现代用户界面的 WinForm 应用程序",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19571766",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19571766\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 22:52\">\n    <span>使用 NanUI 快速创建具有现代用户界面的 WinForm 应用程序</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span class=\"content\">前言</span></h2>\n<p>今天大姚给大家分享一个强大的 .NET 开源框架，它利用 Web 技术（HTML5、CSS3、JavaScript）为 WinForm 应用程序构建现代化的用户界面：NanUI。</p>\n<p>如果你正在寻找一个用于创建具有现代用户界面的 WinForm 应用程序的框架，NanUI 是一个不错的选择。</p>\n<h2><span class=\"content\">项目介绍</span></h2>\n<p>NanUI 是一个基于 .NET 平台的开源（MIT License）框架，旨在帮助开发者使用 HTML5、CSS3 和 JavaScript 构建具有现代感的 WinForm 应用程序用户界面。它底层依托于 Xilium.CefGlue 这是 Chromium Embedded Framework（CEF）在 .NET 环境下的官方绑定实现，通过嵌入完整的 Chromium 渲染引擎，使 WinForm 应用能够呈现 Web 技术驱动的富交互界面。</p>\n<h2><span class=\"content\">基本原理</span></h2>\n<p><strong>官方介绍：</strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203224945896-1709690796.png\" /></p>\n<p><strong>基本原理概括：</strong></p>\n<ul>\n<li><strong>Chromium Embedded Framework (CEF)</strong>&nbsp;是一个开源项目，一个用于将基于 Chromium 的浏览器嵌入其他应用程序的简单框架。</li>\n<li>它提供稳定的 C/C++ API，支持多进程架构（Browser 进程 + Renderer/GPU 等子进程），具备完整的 HTML5 渲染、JavaScript 执行、网络请求、安全沙箱等能力。</li>\n<li>NanUI 并未直接调用 CEF 的 C 接口，而是基于&nbsp;<strong>Xilium.CefGlue</strong>&nbsp;这是一个高质量的 .NET 封装库，将 CEF 的 C++ API 转换为 C# 可调用的托管接口。</li>\n</ul>\n<h2><span class=\"content\">环境要求</span></h2>\n<h3><span class=\"content\">开发环境</span></h3>\n<ul>\n<li>Visual Studio 2019 或更高版本。</li>\n<li>NET Framework 4.6.2 或更高版本 / .NET 6.0 或更高版本。</li>\n</ul>\n<h3><span class=\"content\">部署环境</span></h3>\n<ul>\n<li>.NET Framework 4.6.2 或更高版本。</li>\n<li>.NET 6.0 需要 Windows 7 Service Pack 1 或更高版本。</li>\n<li>.NET 7.0/8.0/9.0 需要 Windows 10 或 Windows 11。</li>\n<li>Microsoft Windows 7 Service Pack 1 或更高版本。</li>\n</ul>\n<h2><span class=\"content\">项目源代码</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225000339-222340467.png\" /></p>\n<h2><span class=\"content\">快速使用</span></h2>\n<h3><span class=\"content\">创建一个 WinForm 应用程序</span></h3>\n<p>首先我们快速创建一个名为<code>NanUIExercise</code>&nbsp;Windows 窗体应用程序：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225039530-1668443758.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225044905-2091682107.png\" /></p>\n<p><img alt=\"image\" height=\"458\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225051053-201638939.png\" width=\"1075\" /></p>\n<h3><span class=\"content\">安装 NanUI NuGet 包</span></h3>\n<p>安装&nbsp;<code>NanUI</code>&nbsp;包&nbsp;<code>NetDimension.NanUI</code>&nbsp;：</p>\n<p><img alt=\"image\" height=\"607\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225112224-661517538.png\" width=\"1100\" /></p>\n<p>&nbsp;安装&nbsp;<code>NanUI</code>&nbsp;所依赖的&nbsp;<code>Chromium Embedded Framework</code>&nbsp;依赖包&nbsp;<code>NetDimension.NanUI.Runtime</code>：</p>\n<p><img alt=\"image\" height=\"607\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225122223-56769435.png\" width=\"1103\" /></p>\n<p>&nbsp;</p>\n<h3><span class=\"content\">创建一个基本的 NanUI 应用程序</span></h3>\n<p><strong>Program.cs：</strong></p>\n<pre class=\"custom\"><code class=\"hljs\"><span class=\"hljs-keyword\">using&nbsp;NetDimension.NanUI;<br /><br /><span class=\"hljs-keyword\">namespace&nbsp;<span class=\"hljs-title\">NanUIExercise<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">internal&nbsp;<span class=\"hljs-keyword\">static&nbsp;<span class=\"hljs-keyword\">class&nbsp;<span class=\"hljs-title\">Program<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\"><span class=\"hljs-doctag\">///&nbsp;<span class=\"hljs-doctag\">&lt;summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\"><span class=\"hljs-doctag\">///&nbsp;&nbsp;The&nbsp;main&nbsp;entry&nbsp;point&nbsp;for&nbsp;the&nbsp;application.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\"><span class=\"hljs-doctag\">///&nbsp;<span class=\"hljs-doctag\">&lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class=\"hljs-meta\">STAThread]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-function\"><span class=\"hljs-keyword\">static&nbsp;<span class=\"hljs-keyword\">void&nbsp;<span class=\"hljs-title\">Main(<span class=\"hljs-params\">)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">var&nbsp;builder&nbsp;=&nbsp;NanUIApp.CreateBuilder();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.UseNanUIApp&lt;MyFirstAPP&gt;();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">var&nbsp;app&nbsp;=&nbsp;builder.Build();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;app.Run();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>\n<p><strong>创建一个类继承 AppStartup 来配置应用程序：</strong></p>\n<pre class=\"custom\"><code class=\"hljs\">using&nbsp;Microsoft.Extensions.DependencyInjection;<br />using&nbsp;NetDimension.NanUI;<br /><br />namespace&nbsp;NanUIExercise<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;MyFirstAPP&nbsp;:&nbsp;AppStartup<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;override&nbsp;MainWindowCreationAction?&nbsp;UseMainWindow(MainWindowOptions&nbsp;opts)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;设置应用程序的主窗体<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\">return&nbsp;opts.UseMainFormium&lt;MyWindow&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;override&nbsp;void&nbsp;ProgramMain(string[]&nbsp;args)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Main函数中的代码应该在这里，该函数只在主进程中运行。这样可以防止子进程运行一些不正确的初始化代码。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ApplicationConfiguration.Initialize();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;override&nbsp;void&nbsp;ConfigurationChromiumEmbedded(ChromiumEnvironmentBuiler&nbsp;cef)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;在此处配置&nbsp;Chromium&nbsp;Embedded&nbsp;Framwork<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;override&nbsp;void&nbsp;ConfigureServices(IServiceCollection&nbsp;services)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;在这里配置该应用程序的服务<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /><br /></span></code></pre>\n<p><strong>创建一个类实现 Formium，用于配置应用程序的主窗口：</strong></p>\n<pre class=\"custom\"><code class=\"hljs\">using&nbsp;NetDimension.NanUI;<br />using&nbsp;NetDimension.NanUI.Forms;<br /><br />namespace&nbsp;NanUIExercise<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;MyWindow&nbsp;:&nbsp;Formium<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;<span class=\"hljs-function\"><span class=\"hljs-title\">MyWindow()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Url&nbsp;=&nbsp;<span class=\"hljs-string\">\"https://juejin.cn/\";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;override&nbsp;FormStyle&nbsp;ConfigureWindowStyle(WindowStyleBuilder&nbsp;builder)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;此处配置窗口的样式和属性，或留空以使用默认样式<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;style&nbsp;=&nbsp;builder.UseSystemForm();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style.TitleBar&nbsp;=&nbsp;<span class=\"hljs-literal\">false;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style.DefaultAppTitle&nbsp;=&nbsp;<span class=\"hljs-string\">\"My&nbsp;First&nbsp;NanUI&nbsp;App\";<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\">return&nbsp;style;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br /></span></span></span></span></span></span></code></pre>\n<p><strong>运行效果查看：</strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225205762-1526989538.png\" /></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202602/1336199-20260203225210743-1010420250.png\" /></p>\n<h2><span class=\"content\">项目源码地址</span></h2>\n<p>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</p>\n<ul>\n<li><strong>Gitee开源地址：</strong>&nbsp;<a href=\"https://gitee.com/dotnetchina/NanUI\" rel=\"noopener nofollow\">https://gitee.com/dotnetchina/NanUI</a></li>\n<li><strong>项目文档地址：</strong>&nbsp;<a href=\"https://gitee.com/dotnetchina/NanUI/blob/master/docs/README.md\" rel=\"noopener nofollow\">https://gitee.com/dotnetchina/NanUI/blob/master/docs/README.md</a></li>\n</ul>\n<h2><span class=\"content\">优秀项目和框架精选</span></h2>\n<p>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong>）。</p>\n<ul>\n<li><strong>GitHub开源地址：</strong>&nbsp;<a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\">https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</a></li>\n<li><strong>Gitee开源地址：</strong>&nbsp;<a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\">https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</a></li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 22:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[大模型实战 03预备] 云端炼丹房 1：Google Colab 上手指南",
      "link": "https://www.cnblogs.com/algieba/p/19571424",
      "published": "",
      "description": "<div class=\"postcontent\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"[大模型实战 03预备] 云端炼丹房 1：Google Colab 上手指南\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203202001276-892195093.png\" />\n        本地显卡跑不动大模型？本文手把手教学薅 Google 羊毛！从 Colab 基础操作、免费 T4 GPU 开启，到挂载 Google Drive 持久化存储 HuggingFace 模型，为云端炼丹做好全套准备。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"大模型实战-03预备-云端炼丹房-1google-colab-上手指南\">[大模型实战 03预备] 云端炼丹房 1：Google Colab 上手指南</h1>\n<blockquote>\n<p><strong>核心摘要 (TL;DR)</strong></p>\n<ul>\n<li><strong>痛点</strong>：本地电脑显存不足，跑不动 7B 以上的大模型，或者运行速度如蜗牛。</li>\n<li><strong>方案</strong>：利用 <strong>Google Colab</strong> 提供的免费 Tesla T4 GPU 算力。</li>\n<li><strong>技巧</strong>：通过挂载 <strong>Google Drive</strong>，解决 Colab 运行时重置导致模型文件丢失的问题。</li>\n<li><strong>目标</strong>：配置好云端环境，为下一篇“云端运行 RAG”打好地基。</li>\n</ul>\n</blockquote>\n<h2 id=\"前言\">前言</h2>\n<p>Ollama因为有llama.cpp库和量化技术的加成，是可以在cpu和更日常的电脑上运行的，但是性能是远比不上在专业的显存设备上的。<br />\n有高端显卡（NVIDIA 4090/5090/A100/H100），可以在自己的服务器上脱缰运行小规模的大模型。但是对于没有高端显卡设备的友人们也不用担心, 我们可以使用谷歌大善人带给我们的免费GPU算力：爱来自Google Colab。 本篇博文的主要目的就是提前带各位友人们从零上手Colab的核心操作，确保在我们后续的实战过程中的流畅操作。</p>\n<h2 id=\"1-google-colab\">1. Google Colab</h2>\n<p>一言概之，<a href=\"https://colab.research.google.com/\" rel=\"noopener nofollow\" target=\"_blank\">Google Colab</a> = <strong>Jupyter Notebook</strong> + <strong>云端服务器</strong></p>\n<ul>\n<li><strong>Jupyter Notebook</strong>：我们知道python是一门动态脚本语言，意味着我们可以一边编写，一边以交互式的方式看到当前结果，然后还能继续往下写。Jupyter Notebook就是一种可以一边写代码，一边写文档，还能实时看到代码运行结果的交互式笔记。</li>\n<li><strong>云端服务器</strong>：区别于在我们本地环境写代码时，代码在我们的本地电脑，换一台电脑就需要重新拉取代码运行，在云端服务器编码是在远程的服务器编码，我们通过自己的电脑，甚至手机或者任何能联网打开浏览器的设备，连接上远程的那台服务器进行代码编写和模型训练。会更为灵活，不受设备限制。</li>\n</ul>\n<h2 id=\"2-快速介绍\">2. 快速介绍</h2>\n<h3 id=\"21-访问与创建\">2.1 访问与创建</h3>\n<ol>\n<li>咱们确保有一个Google账户，并且登录</li>\n<li>访问<a href=\"https://colab.research.google.com/\" rel=\"noopener nofollow\" target=\"_blank\">Google Colab 官网</a>,就会进入到一个欢迎界面<br />\n<img alt=\"进入Colab的欢迎页面截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834576-1761513178.png\" /></li>\n<li>点击菜单栏上<strong>File</strong>-&gt;<strong>new notebook in drive</strong>创建新的笔记本<br />\n<img alt=\"Colab菜单栏打开File鼠标指向其下拉菜单new notebook in drive的截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834093-1639885746.png\" /><br />\n<img alt=\"创建新的notebook后的新notebook界面截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201835540-570983137.png\" /></li>\n</ol>\n<h3 id=\"22-界面介绍\">2.2 界面介绍</h3>\n<p>在新的notebook界面，我们可以看到</p>\n<ul>\n<li><strong>文件名</strong>：左上角“Untitled0.ipynb”的文件名,可以单击重命名,ipynb就是jupyter notebook的后缀名<br />\n<img alt=\"notebook界面重新重命名后的文件名截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201835718-558218591.png\" /></li>\n<li><strong>单元格</strong>：页面中心一长条带一个▶按钮的就说单元格，也叫Cell，是我们的核心编码区域, Jupyter notebook的逻辑是“一段一段”执行代码，而非我们平常写代码时候写完一整个文件再执行。<br />\n<img alt=\"notebook界面中心单元格的截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201835730-1829068104.png\" /></li>\n<li><strong>快捷操作栏</strong>：在单元格上方的位置有一条快捷菜单栏，支持我们添加新的代码块（Code Cell）和文本块（Text Cell），运行全部单元格（Run All）。<br />\n<img alt=\"在单元格上方的快捷操作栏的截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834893-14728608.png\" /></li>\n<li><strong>左侧工具栏</strong>： 包含目录速览，查找替换，密钥管理，数据查看等等工具。<br />\n<img alt=\"左侧工具栏的截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834216-1225871717.png\" /></li>\n<li><strong>变量和终端</strong>：这里的变量按钮可以查看执行到当前的变量信息，就不用去print变量了，很方便。终端按钮就和Linux终端一样，可以用来执行一些命令。<br />\n<img alt=\"最下方的变量按钮和终端按钮\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201835497-2041960710.png\" /></li>\n</ul>\n<h3 id=\"3-核心操作\">3. 核心操作</h3>\n<p>在界面介绍时，咱们快速介绍了一下两种单元格：<strong>代码块</strong>和<strong>文本块</strong>，接下来可以稍微多了解一点点这两种单元格</p>\n<h3 id=\"31-代码块\">3.1 代码块</h3>\n<p>就是我们的主力战场，编写Python代码的地方，可以快速体验一下使用流程</p>\n<ul>\n<li>直接输入python代码，然后点击运行（那个▶按钮或者使用快捷键 <strong><code>Shift + Enter</code></strong>）<br />\n<img alt=\"在代码块中写入代码后运行之后的界面截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834009-1869315854.png\" /></li>\n<li>可以看到代码块左侧有一个[1],一个绿色的√，代码块下方有输出的打印结果<br />\n前面的序号标明代码块的执行顺序，因为我们可以乱序执行，执行完下方代码块再回来执行前面的代码块</li>\n</ul>\n<h3 id=\"32-文本块\">3.2 文本块</h3>\n<p>jupyter notebook是支持直接渲染markdown格式的文档的，所以也有人直接用它当文档。相比于我们用注释去记录，markdown格式的文本块会更直观。</p>\n<ul>\n<li>点击上面的<strong>➕Text</strong>按钮（或者在当前单元格上方/下方中间浮现显示的快捷按钮）去新增一个文本块</li>\n<li><strong>Shift+Enter</strong>快捷键“运行/渲染”它，<br />\n<img alt=\"输入了# This is Title!!的文本块截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834557-224158255.png\" /><br />\n<img alt=\"渲染之后的文本块截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834523-54180414.png\" /></li>\n</ul>\n<h2 id=\"4-开启免费gpu算力\">4. <strong>开启免费GPU算力</strong></h2>\n<p>默认状态下Colab是使用的CPU，我们接下来去开启GPU</p>\n<ul>\n<li>点击顶部菜单栏的<strong>Runtime（运行时）</strong>下拉菜单中的<strong>Change runtime type（更改运行时类型）</strong><br />\n<img alt=\"点击Runtime下来菜单，鼠标指向Change runtime type的截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834973-1363298837.png\" /></li>\n<li>选择<strong>Hardware accelerator(硬件加速器)</strong>的<strong>T4 GPU</strong>.<br />\n<img alt=\"进入change runtime type后鼠标选择T4GPU的截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834344-277085401.png\" /></li>\n<li>弹出的窗口警告我们会断联当前运行时，切换到T4GPU的硬件，选择OK<br />\n<img alt=\"点击T4GPU后，弹出结束运行时的截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834739-555876133.png\" /></li>\n<li>保存，然后会发现之前运行过的代码块失活了（前面框框里的数字消失了，所有运行过的代码块需要重新运行）</li>\n<li>我们来输入以下代码验证</li>\n</ul>\n<pre><code class=\"language-python\">!nvidia-smi\n</code></pre>\n<p><img alt=\"nvidia-smi的运行结果截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834176-1231975840.png\" /><br />\n从返回的表格结果中，能看到咱们的设备是TeslaT4。</p>\n<p>在notebook代码块中以<code>!</code>开头即可运行命令，这里等效为在terminal中运行<code>nvidia-smi</code><br />\n<strong>PS:除了切换文件夹得用<code>%cd</code>而不是<code>!cd</code></strong></p>\n<h2 id=\"5-下载大模型\">5. <strong>下载大模型</strong></h2>\n<p>我们使用Colab主要是为了使用大模型以及训练大模型，对于Colab而言，模型的下载有个痛点：<strong>Colab是临时的</strong>，哪怕我们通过命令下载了好几个G的模型，甚至好几十G的模型，但是每次重置运行时的时候，这一切都会灰飞烟灭，消散如烟。为了避免每次都重新下载，浪费时间，我们可以通过挂在Google Drive来保存模型。</p>\n<h3 id=\"51-挂载google-drive\">5.1 挂载Google Drive</h3>\n<ol>\n<li>我们运行以下代码</li>\n</ol>\n<pre><code class=\"language-python\">from google.colab import drive\ndrive.mount('/content/drive')\n</code></pre>\n<ol start=\"2\">\n<li>然后在弹出授权窗口中授权<br />\n<img alt=\"运行完挂载代码后，弹出的授权提示截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834509-1760419411.png\" /></li>\n<li>就能在代码块下方看见已经成功挂载的打印信息<br />\n<img alt=\"成功挂载google drive后的打印信息截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834445-1089132265.png\" /></li>\n</ol>\n<h3 id=\"52-配置huggingface环境变量和token\">5.2 配置HuggingFace环境变量和Token</h3>\n<p>在下载受限模型（如 Llama 3）时，你需要 Hugging Face Token。</p>\n<ol>\n<li>去 <a href=\"https://huggingface.co/settings/tokens\" rel=\"noopener nofollow\" target=\"_blank\">Hugging Face Settings</a> 获取 Token。</li>\n<li>在 Colab 左侧钥匙图标（Secrets）里添加 <code>HF_TOKEN</code>。</li>\n</ol>\n<p><img alt=\"Colab 左侧 Secrets 面板配置 HF_TOKEN 的截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834471-1969164958.png\" /></p>\n<h3 id=\"53-指定缓存路径下载\">5.3 指定缓存路径下载</h3>\n<p>因为咱们在Colab环境，是国外的魔法环境，我们可以直接使用hugging face来下载模型，我们接下来指定一下模型下载的缓存路径到挂载的Google Drive。</p>\n<ol>\n<li>咱们先切回CPU环境，因为下载模型并不需要GPU,切回去可以节约一点咱们的额度。</li>\n<li>输入以下代码然后运行</li>\n</ol>\n<pre><code class=\"language-python\">from google.colab import drive\nimport os\n\n# 1. 挂载云盘\nif not os.path.exists('/content/drive'):\n    drive.mount('/content/drive')\n\n# 2. 准备目录\ncache_dir = \"/content/drive/MyDrive/huggingface_cache\"\nos.makedirs(cache_dir, exist_ok=True)\n\n# 3. 设置 Token (如果你在左侧 Secrets 设置了 HF_TOKEN，这里自动读取)\n# 如果没设置，请手动把下行代码引号里换成你的 token，或者留空试下（Qwen 有时不需要）\nmy_token = os.getenv('HF_TOKEN') or \"\"\n\nprint(\"屏幕可能会静止 5-10 分钟，请盯着左边的小圆圈转动即可。\")\n\ncmd = f\"huggingface-cli download Qwen/Qwen2.5-7B-Instruct --cache-dir {cache_dir} --quiet\"\nif my_token:\n    cmd += f\" --token {my_token}\"\n\n# 执行命令\nresult = os.system(cmd)\n\nif result == 0:\n    print(\"\\n 下载成功！\")\nelse:\n    print(\"\\n 下载失败，请检查网络或 Token。\")\n</code></pre>\n<ol start=\"3\">\n<li>然后运行下面的命令检验模型是否下载完毕</li>\n</ol>\n<pre><code class=\"language-python\"># check disk usage (查看磁盘占用)\n# -s: 汇总大小, -h: 人类可读格式 (GB/MB)\n!du -sh /content/drive/MyDrive/huggingface_cache/models--Qwen--Qwen2.5-7B-Instruct\n</code></pre>\n<p>看到的结果应该是15G大小的文件<br />\n<img alt=\"运行du -sh /content/drive/MyDrive/huggingface_cache/models--Qwen--Qwen2.5-7B-Instruct后的结果截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834031-689746531.png\" /></p>\n<p><strong>一般情况下，建议模型下载和数据处理都在CPU模式下进行，然后处理完毕存入云盘.</strong> 4. 然后新建代码块，运行如下代码，来确认模型是否能够被识别</p>\n<pre><code class=\"language-python\">import os\nimport glob\nfrom transformers import AutoConfig, AutoTokenizer\n\n# 1. 设置你的缓存根目录\nbase_cache_path = '/content/drive/MyDrive/huggingface_cache'\n\n# 2. 构造快照目录的通配符路径\n# 结构通常是: base / models--ID / snapshots / &lt;哈希值&gt;\nsnapshot_pattern = os.path.join(\n    base_cache_path,\n    \"models--Qwen--Qwen2.5-7B-Instruct\",\n    \"snapshots\",\n    \"*\"  # 这里用 * 匹配那个随机生成的哈希文件夹\n)\n\n# 3. 寻找真实的文件夹路径\nfound_folders = glob.glob(snapshot_pattern)\n\nif not found_folders:\n    print(\" 错误：找不到 snapshots 文件夹，请检查下载是否成功或路径是否正确。\")\nelse:\n    local_model_path = found_folders[0]\n\n    print(f\"锁定本地模型路径: {local_model_path}\")\n    print(\"正在尝试直接加载...\")\n\n    try:\n        config = AutoConfig.from_pretrained(local_model_path)\n        tokenizer = AutoTokenizer.from_pretrained(local_model_path)\n\n        print(\"\\n成功！模型可以被正确加载。\")\n        print(f\"模型隐藏层维度: {config.hidden_size}\")\n        print(f\"词表大小: {tokenizer.vocab_size}\")\n\n    except Exception as e:\n        print(f\"\\n加载依然失败。可能是 Google Drive 的软链接失效了。\")\n        print(f\"错误信息: {e}\")\n</code></pre>\n<p><img alt=\"通过运行模型加载命令，显示模型成功加载的截图\" src=\"https://img2024.cnblogs.com/blog/3169973/202602/3169973-20260203201834785-1187356910.png\" /></p>\n<h2 id=\"05-常见问题-qa\">05. 常见问题 (Q&amp;A)</h2>\n<p><strong>Q: CPU 和 GPU 跑大模型，性能差异到底有多大？</strong><br />\n<strong>A:</strong> 差异巨大，就像<strong>法拉利</strong>和<strong>拖拉机</strong>的区别。</p>\n<ul>\n<li><strong>CPU (中央处理器)</strong>：像一个知识渊博的教授，计算能力强但只能一个一个任务串行处理。推理大模型时，它需要逐个计算矩阵乘法，生成一个字可能需要好几秒。</li>\n<li><strong>GPU (图形处理器)</strong>：像一个由几千名小学生组成的方阵，虽然单人能力不如教授，但能同时进行大规模并行计算。大模型的本质是海量的矩阵运算，GPU 可以瞬间完成，生成速度通常是 CPU 的几十倍甚至上百倍。</li>\n</ul>\n<p><strong>Q: 那一台 RTX 4090 能运行多大的模型？能微调多大？</strong><br />\n<strong>A:</strong> RTX 4090 拥有 <strong>24GB 显存</strong>，这是核心瓶颈。</p>\n<ul>\n<li><strong>推理 (运行)</strong>：\n<ul>\n<li><strong>4-bit 量化</strong>：显存占用 ≈ 参数量 × 0.7。4090 极限可以跑 <strong>30B - 34B</strong> 参数的模型（如 Yi-34B-Chat-Int4）。</li>\n<li><strong>全精度 (FP16)</strong>：显存占用 ≈ 参数量 × 2。4090 最多跑 <strong>10B - 12B</strong> 参数的模型。</li>\n</ul>\n</li>\n<li><strong>微调 (训练)</strong>：\n<ul>\n<li><strong>全量微调</strong>：想都不要想，需要几百 GB 显存。</li>\n<li><strong>LoRA / QLoRA (轻量微调)</strong>：这是咱们个人玩家的主流。4090 可以轻松微调 <strong>7B - 10B</strong> 的模型。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Q: 动态脚本语言 (Python) 和常规预编译语言 (C++/Java) 有什么区别？</strong><br />\n<strong>A:</strong></p>\n<ul>\n<li><strong>预编译语言 (C++/Java)</strong>：像写书。写完一整本书（代码），送去印刷厂（编译），最后出来成品书（可执行文件）。执行速度快，但修改麻烦，改一个字要重新印刷。</li>\n<li><strong>动态脚本语言 (Python)</strong>：像聊天。你说一句（写一行代码），解释器就执行一句。虽然执行速度稍慢，但胜在<strong>交互性极强</strong>。在数据科学和 AI 领域，我们需要频繁查看数据的中间结果（比如查看模型输出的张量形状），Python 的这种特性让它成为了 AI 领域的霸主。</li>\n</ul>\n<p><strong>Q: Colab 里的 T4, A100, TPU 都有什么差别？</strong><br />\n<strong>A:</strong></p>\n<ul>\n<li><strong>T4 (免费版标配)</strong>：入门级推理卡，16GB 显存。跑 7B 模型推理没问题，微调 QLoRA 勉强够用。咱们薅羊毛主要就薅它。</li>\n<li><strong>A100 (付费版)</strong>：顶级计算卡，40GB/80GB 显存。速度极快，显存极大，适合跑大参数模型或进行严肃的训练任务。Colab Pro/Pro+ 才能刷到。</li>\n<li><strong>TPU (Tensor Processing Unit)</strong>：Google 专门为机器学习定制的芯片，处理矩阵运算比 GPU 更快，但生态和兼容性（PyTorch 支持）不如 Nvidia GPU 通用，上手门槛稍高。</li>\n</ul>\n<hr />\n<p><strong>本文作者：</strong> Algieba<br />\n<strong>本文链接：</strong> <a href=\"https://blog.algieba12.cn/llm02-1-online-environment-colab/\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.algieba12.cn/llm02-1-online-environment-colab/</a><br />\n<strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>\n<pre><code>\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"itemdesc\">\n\t\t\t发表于 \n<span id=\"post-date\">2026-02-03 20:20</span>&nbsp;\n<a href=\"https://www.cnblogs.com/algieba\">阿尔的代码屋</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</div>"
    },
    {
      "title": "操作教程 | 使用开源三件套（OpenClaw+Ollama+1Panel）部署7×24运行的个人AI助理",
      "link": "https://www.cnblogs.com/xiaobaiysf/p/19571167",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiaobaiysf/p/19571167\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 19:01\">\n    <span>操作教程 | 使用开源三件套（OpenClaw+Ollama+1Panel）部署7×24运行的个人AI助理</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>一、写在前面</strong><br />\n本次操作教程将以开源 Linux 服务器运维面板 1Panel 为基础，搭配 Ollama 本地大模型（无需担心 Token 消耗费用），手把手教你部署 OpenClaw 个人 AI 助理，实现 7×24 小时稳定运行，轻松拥有专属智能助手！</p>\n<p><strong>二、资源准备</strong><br />\n本次 OpenCalw 本地个人 AI 助理基于一台腾讯 GPU 云服务器构建，云服务器获取过程不做赘述，参见腾讯云官网。其中服务器的配置参见如下：</p>\n<ul>\n<li>操作系统：Ubuntu Server 24.04 LTS 64 位</li>\n<li>计算资源：20 核 80 G</li>\n<li>磁盘容量：100G</li>\n<li>GPU： 计算型 GN7 | GN7.5XLARGE80</li>\n<li>网络：绑定弹性公网IP</li>\n</ul>\n<p><img alt=\"image-2026-2-3_16-29-44\" class=\"lazyload\" /></p>\n<p><strong>三、操作过程</strong><br />\n本次基于 1Panel 服务器运维管理面板构建本地化 AI 助理大致需要以下几个步骤；</p>\n<ul>\n<li>第一步：1Panel 安装部署；</li>\n<li>第二步：GPU 资源调度配置；</li>\n<li>第三步：Ollama 的安装部署；</li>\n<li>第四步：Qwen3 模型加载；</li>\n<li>第五步：OpenClaw 安装部署及配置。</li>\n</ul>\n<p><strong>四、详细操作步骤说明</strong><br />\n4.1.&nbsp;<strong>1Panel 安装部署</strong><br />\n1Panel 的安装部署比较简单，可以参照官网在线安装：<a href=\"https://1panel.cn/docs/v2/installation/online_installation/\" rel=\"noopener nofollow\" target=\"_blank\">https://1panel.cn/docs/v2/installation/online_installation/</a></p>\n<p>步骤一：<strong>获取 root 权限</strong>，登录服务器后首先切换到 root 权限</p>\n<p><code>sudo su -</code><br />\n步骤二：<strong>输入命令安装</strong>，输入在线安装命令执行安装：</p>\n<p><code>bash&nbsp;-c&nbsp;\"$(curl&nbsp;-sSL&nbsp;https://resource.fit2cloud.com/1panel/package/v2/quick_start.sh)\"</code><br />\n步骤三：<strong>Docker 安装</strong>，指定安装目录并安装 Docker</p>\n<p><img alt=\"2\" class=\"lazyload\" /></p>\n<p>步骤四：<strong>镜像加速器配置</strong>，选择配置镜像加速器并设置 1Panel 面板访问参数。</p>\n<p><img alt=\"3\" class=\"lazyload\" /></p>\n<p>步骤五：<strong>获取 1Panel 面板登录信息</strong></p>\n<p><img alt=\"4\" class=\"lazyload\" /></p>\n<p>步骤六：<strong>验证 1Panel 部署成功：</strong>将外部地址输入浏览器进入登录页面，输入对应的面板用户以及面板密码，确认安装完成。</p>\n<p><img alt=\"5\" class=\"lazyload\" /></p>\n<p>步骤七：<strong>1Panel 访问地址设置：</strong>进入面板后，切换到「面板设置」中，将默认访问地址设置为1Panel访问的公网IP，方便后续部署的应用可以通过跳转快速跳转。</p>\n<p><img alt=\"6\" class=\"lazyload\" /></p>\n<p><strong>4.2、&nbsp;GPU 资源调度配置</strong><br />\n进入1Panel的「终端」管理完成 NVIDIA 容器镜像配置，最终让基于容器安装的模型能够调度 GPU 资源。</p>\n<p>步骤一：<strong>NVIDIA 显卡驱动确认：</strong>需要确保 NVIDIA 显卡驱动已正确安装，输入以下命令：</p>\n<p><code>nvidia-smi</code><br />\n如下图展示，则代表成功。如果没有安装则自行前往英伟达官网下载安装：</p>\n<p><a href=\"https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html#installing-with-apt\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html#installing-with-apt</a></p>\n<p><img alt=\"7\" class=\"lazyload\" /></p>\n<p>步骤二：<strong>安装 NVIDIA 容器镜像：</strong>为了在 docker 容器中使用 GPU 加速，我们需要安装 NVIDIA 的容器镜像，参照如下逐个命令行执行操作：</p>\n<p>命令行一：添加 NVIDIA 容器工具仓库与签名</p>\n<pre><code>curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \\\n&nbsp;&nbsp;&amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \\\n&nbsp;&nbsp;&nbsp;&nbsp;sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \\\n&nbsp;&nbsp;&nbsp;&nbsp;sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list\n</code></pre>\n<p>命令行二：启用仓库中的 experimental 组件（可选）</p>\n<p><code>sed -i -e '/experimental/ s/^#//g' /etc/apt/sources.list.d/nvidia-container-toolkit.list</code></p>\n<p>命令行三：更新软件源</p>\n<p><code>sudo apt-get update</code></p>\n<p>命令行四：安装 nvidia-container-toolkit</p>\n<p><code>sudo apt-get install -y nvidia-container-toolkit</code></p>\n<p>步骤三：<strong>配置 Docker 镜像使用 NVIDIA：</strong>安装完容器镜像后，需要配置 Docker 以使用 NVIDIA，并重启 Docker 服务。</p>\n<p>命令行一：配置 Docker 以使用 NVIDIA</p>\n<p><code>sudo nvidia-ctk runtime configure --runtime=docker</code></p>\n<p>命令行二：重启 docker</p>\n<p><code>sudo systemctl restart docker</code></p>\n<p><strong>4.3、Ollama 安装部署</strong><br />\n1Panel 安装以及服务器的 GPU 资源配置完成以后，我们就可以基于1Panel的运维管理面板进行个人助理的本地化安装部署了，一切就会变得非常简单，小白都能轻松上手。首先我们来安装Ollama，Ollama 是一个开源的大型语言模型服务，提供了类似 OpenAI 的 API 接口和聊天界面，可以非常方便地部署最新版本的 Qwen 模型并通过接口使用。</p>\n<p>步骤一： <strong>开始安装 Ollama 应用：</strong>首先我们进入1Panel 的应用商店，点击「AI」，然后选择 Ollama，直接点击安装。</p>\n<p><img alt=\"8\" class=\"lazyload\" /></p>\n<p>步骤二：<strong>设置 Ollama 安装参数：</strong>安装参数配置时需要确认版本号以及端口号，另外记得勾选「端口外部访问」，同时勾选「开启 GPU 支持」，确保后续我们可以正常访问 Ollama 且模型使用 GPU 资源，其他参数保持默认点击确认即可。</p>\n<p><img alt=\"9\" class=\"lazyload\" /></p>\n<p>步骤三：<strong>下载镜像并安装 Ollama：</strong>点击确认后，系统开始自动拉取镜像并安装应用，直到提醒安装应用「ollama」成功，则代表完成安装。</p>\n<p><img alt=\"10\" class=\"lazyload\" /></p>\n<p>步骤四：<strong>验证Ollama是否成功：</strong>进入已安装应用，找到 Ollama 应用，点击跳转，确认输出内容为“Ollama is running”，则代表部署成功。</p>\n<p><img alt=\"11\" class=\"lazyload\" /><br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p><strong>4.4、Qwen3 本地模型部署</strong><br />\n部署完成 Ollama 以后，我们继续基于 1Panel 来完成基于 Ollama 本地 qwen3:14b 模型加载部署，参照如下操作步骤逐步完成即可。</p>\n<p>步骤一：<strong>创建 Qwen3 模型：</strong>进入 「AI」 的模型管理页面，点击添加模型。</p>\n<p><img alt=\"12\" class=\"lazyload\" /></p>\n<p>步骤二：<strong>加载模型：</strong>根据引导到 Ollama 官网找到模型 ID，在名称中输入模型名称，点击添加开始加载模型文件。本次我们选择的是 qwen3:14b 的模型，这里模型加载大概需要 20-30 分钟</p>\n<p><img alt=\"13\" class=\"lazyload\" /><br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p>步骤三：<strong>模型运行确认：</strong>当模型列表中的「状态」更新为成功后，可以点击运行验证模型部署效果，如果能够正常对话则代表模型加载成功，如下图所示：</p>\n<p><img alt=\"14\" class=\"lazyload\" /></p>\n<p><strong>4.5、OpenClaw 安装部署</strong><br />\n基于以上步骤我们完成了本地模型的准备，然后我们再基于 1Panel 快速搭建个人 AI 助理 OpenClaw 。</p>\n<p>步骤一：<strong>开始安装 OpenClaw 应用</strong>，进入应用商店点击安装 OpenClaw 应用，如下图所示进入应用商店，点击「安装」，进入安装参数设置页面。</p>\n<p><img alt=\"15\" class=\"lazyload\" /></p>\n<p>步骤二：<strong>设置应用安装参数</strong>，如下图设置 OpenClaw 的版本号及端口、Ollama 本地模型以及是否外部访问等配置项，设置完成后点击确认开始安装，其中参数具体说明如下：</p>\n<ul>\n<li>版本：OpenClaw 版本默认为最新版本；</li>\n<li>端口：OpenClaw 应用访问端口默认为 18789、18790，如有占用自行调整变更，最终需要确保端口已开通，可外部访问；</li>\n<li>模型供应商：下拉选择 Ollama；</li>\n<li>模型：按照 Ollama/模型 ID 输入（即模型管理中添加的模型 ID），如：Ollama/qwen3:14b；</li>\n<li>模型API Key：本地模型输入任意字符即可；</li>\n<li>Base URL：输入上述步骤部署的 Ollama 应用的地址，即 <a href=\"http://IP:11434/v1\" rel=\"noopener nofollow\" target=\"_blank\">http://IP:11434/v1</a> 即可;</li>\n<li>端口外部访问：勾选端口外部访问，方便后续 OpenClaw 应用访问。</li>\n</ul>\n<p><img alt=\"16\" class=\"lazyload\" /></p>\n<p>步骤三：<strong>OpenClaw 应用安装</strong>，点击确认后系统自动开始拉取镜像，并安装应用，如下图所示则代表 OpenClaw 应用安装成功。</p>\n<p><img alt=\"17\" class=\"lazyload\" /></p>\n<p>步骤四：<strong>应用 token 获取</strong>，通过「已安装」应用如图点击进入目录，一路点击如图所示，进入 data/conf 文件，找到 openclaw.json 文件点击打开；找到 “gateway” 中的 “token” 复制其中的 token 值，如：9bfd07dd800a8c304b62bfac09f698cb7ad9f939d812021a，</p>\n<p><img alt=\"18\" class=\"lazyload\" /><br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p><img alt=\"18\" class=\"lazyload\" /></p>\n<p>步骤五：<strong>Web 应用访问设置</strong>，将获取到的 token 与 IP 地址以及端口号按照 <strong>IP:端口？token={token}</strong>具体值（如：</p>\n<p>139.186.147.190:18789?token=9bfd07dd800a8c304b62bfac09f698cb7ad9f939d812021a</p>\n<p>） 拼接起来 ，定义在参数中的 「Web 访问地址」中，如下图所示：</p>\n<p><img alt=\"18\" class=\"lazyload\" /></p>\n<p><img alt=\"18\" class=\"lazyload\" /></p>\n<p><strong>五、个人 AI 助理效果</strong><br />\n完成以上操作我们就基于 1Panel 完成了 OpenClaw 个人 AI 助理的搭建。直接进入应用商店已安装，点击跳转，选择带 token 的链接地址点击即可进入OpenClaw 体验了，具体参见如下图：</p>\n<p><img alt=\"19\" class=\"lazyload\" /></p>\n<p>我们输入可以输入一些简单的事情交给 AI 助理帮你完成，如下图所示：</p>\n<p><img alt=\"20\" class=\"lazyload\" /></p>\n<p><strong>六、总结</strong><br />\n通过上述完整步骤，我们能依托 1Panel 运维管理面板快速搭建 7X24 小时不间断运行的本地 AI 助理。最终只需通过浏览器访问 OpenClaw，即可畅享本地模型驱动的 AI 智能助理服务，无论是日常咨询还是轻量办公辅助都能轻松应对。</p>\n<p>全程操作以 1Panel 为核心载体，无需复杂的命令行功底，所有配置流程可视化、步骤化，即便是小白新手也能按指引快速完成部署。不过经实测发现，当前本地模型在工具调用的灵活性上仍存在些许局限，但随着 OpenClaw、Ollama 等开源项目的持续迭代优化，这些问题我们相信会很快得到优化改善，未来该 AI 助理的功能会愈发强大，为我们的生活和工作效率带来显著提升。</p>\n<p>最后在模型选择方面，经过多次实测验证，基于当前的硬件资源配置，Qwen3:14b、Qwen coder:30b 是兼顾性能与资源消耗的优选方案；若服务器配置充足（如更高显存、更强算力），也可尝试部署参数更大的模型以获得更优效果。</p>\n<p>这套本地化 AI 助理方案无需依赖外部 Token，数据隐私更有保障，诚邀大家动手实操体验，感受开源三件套工具带来的高效智能服务。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 19:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xiaobaiysf\">小白跃升坊</a>&nbsp;\n阅读(<span id=\"post_view_count\">76</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "字符编码知多少(二)",
      "link": "https://www.cnblogs.com/lmy5215006/p/19567495",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lmy5215006/p/19567495\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 16:14\">\n    <span>字符编码知多少(二)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"bom头\">BOM头</h1>\n<p>BOM头全程Byte Order Mark (字节顺序标记), 是Unicode编码标准中，最早是用于UTF32/16中标识字节顺序的特殊字符，后来随着UTF-8的出现，为了兼容，又有了标识文本编码格式的作用。</p>\n<blockquote>\n<p>最初主要是为了解决UTF32/16编码方案中大小端的问题，(大端BE：高字节在前，小端LE：低字节在前)。所以需要在字符串前增加一个特殊标记，以方便识别解析。<br />\n随着UTF-8的出现，不再需要BOM头。但微软为了方便自家软件能快速区分UTF-8与ANSI编码，而额外引入了<code>非标准拓展</code>。因此有了独特的UTF-8 BOM 编码方式</p>\n</blockquote>\n<hr />\n<h2 id=\"不同unicode编码中的bom头表现\">不同Unicode编码中的BOM头表现</h2>\n<table>\n<thead>\n<tr>\n<th>编码格式</th>\n<th>BOM头字节序列</th>\n<th>长度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UTF-8 BOM (微软特色)</td>\n<td><strong>EF BB BF</strong></td>\n<td>3字节</td>\n<td>仅作编码标识，无字节顺序问题</td>\n</tr>\n<tr>\n<td>UTF-8</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>UTF-16 BE（大端）</td>\n<td><strong>FE FF</strong></td>\n<td>2字节</td>\n<td>表示高位字节在前</td>\n</tr>\n<tr>\n<td>UTF-16 LE（小端）</td>\n<td><strong>FF FE</strong></td>\n<td>2字节</td>\n<td>表示低位字节在前</td>\n</tr>\n<tr>\n<td>UTF-32 BE</td>\n<td><strong>00 00 FE FF</strong></td>\n<td>4字节</td>\n<td>表示高位字节在前</td>\n</tr>\n<tr>\n<td>UTF-32 LE</td>\n<td><strong>FF FE 00 00</strong></td>\n<td>4字节</td>\n<td>表示低位字节在前</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"眼见为实\">眼见为实</h2>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<blockquote>\n<p>使用文本编辑器，选择另存为，保存为不同的编码方案</p>\n</blockquote>\n<pre><code>        public static void Run()\n        {\n            var utf8_path = @\"C:\\Users\\liu\\Documents\\utf-8.txt\";\n            var utf8_bom_path = @\"C:\\Users\\liu\\Documents\\utf-8 bom.txt\";\n            var utf16_le_path = @\"C:\\Users\\liu\\Documents\\utf-16 be.txt\";\n            var utf16_be_path = @\"C:\\Users\\liu\\Documents\\utf-16 le.txt\";\n\n            var utf8= BitConverter.ToString(File.ReadAllBytes(utf8_path));\n            Console.WriteLine(\"utf8 无bom: \"+utf8 +\"\\n\");\n\n            var utf8_bom= BitConverter.ToString(File.ReadAllBytes(utf8_bom_path));\n            Console.WriteLine(\"utf8 有bom: \"+utf8_bom + \"\\n\");\n\n            var utf16_le= BitConverter.ToString(File.ReadAllBytes(utf16_le_path));\n            Console.WriteLine(\"utf-16 be大端: \"+utf16_le + \"\\n\");\n\n            var utf16_be = BitConverter.ToString(File.ReadAllBytes(utf16_be_path));\n            Console.WriteLine(\"utf-16 le小端: \"+utf16_be + \"\\n\");\n        }\n</code></pre>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h1 id=\"为什么utf-8不需要bom\">为什么UTF-8不需要BOM</h1>\n<p>BOM的本质是为了解决UTF-16/32大小端歧义的问题，而UTF8的编码特性<code>从根本上解决了BOM要处理问题</code>，所以BOM对UTF-8而言既无必要，而且还属于\"额外附加\"的内容。</p>\n<h2 id=\"utf-1632为什么需要\">UTF-16/32为什么需要</h2>\n<p>假如我要传输一个字符串“中“，Unicode编码：U+4E2D，在我传输给你的过程中，它可以是FE-FF-4E-2D（大端），也可以是FF-FE-2D-4E(小端)，如果我没有标识字节顺序，你如何解析？</p>\n<h2 id=\"utf-8-核心编码规则\">UTF-8 核心编码规则</h2>\n<p>要想知道为什么UTF-8不需要BOM，先从它的原理开始说起。</p>\n<ol>\n<li>可变长编码<br />\n用1-4个字节表示一个Unicode字符，码点越小，占用的字节数越小。</li>\n<li>标准的字节格式<br />\n每个字符的起始字节，会有一个<code>特殊标识</code>来表示该字符占用的总字节数，后续的字节用<code>固定格式</code>来表示，相当于有一个标准模板来定义UTF-8字符。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字符占用字节数</th>\n<th>起始字节二进制格式</th>\n<th>续字节二进制格式</th>\n<th>可表示的Unicode码点范围</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1字节</td>\n<td><code>0xxxxxxx</code></td>\n<td>无续字节</td>\n<td><code>U+0000</code> ~ <code>U+007F</code></td>\n<td>对应ASCII字符</td>\n</tr>\n<tr>\n<td>2字节</td>\n<td><code>110xxxxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td><code>U+0080</code> ~ <code>U+07FF</code></td>\n<td>欧洲、中东等字符</td>\n</tr>\n<tr>\n<td>3字节</td>\n<td><code>1110xxxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td><code>U+0800</code> ~ <code>U+FFFF</code></td>\n<td>中文、日文、韩文等常用字符</td>\n</tr>\n<tr>\n<td>4字节</td>\n<td><code>11110xxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td><code>U+10000</code> ~ <code>U+10FFFF</code></td>\n<td>罕见字符、emoji等</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"眼见为实以中举例\">眼见为实，以\"中\"举例</h3>\n<ol>\n<li>确定字节数<br />\n\"中\"这个字符的码点为<code>U+4E2D</code>，在<code>U+0800~U+FFFF</code>范围内，占用 3 字节。</li>\n<li>十六进制转换成二进制<br />\n<code>4E2D</code>转成二进制，得到<code>0100 1110 0010 1101</code><br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n<li>按照UTF-8模板格式填充<br />\n已知占用3字节，模板格式为：<code>1110xxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code> (起始字节+2个续字节)<br />\n-----------得到UTF-8编码<code>11100100</code> <code>10111000</code> <code>10101101</code></li>\n<li>二进制转换成十六进制<br />\n<code>11100100</code> =&gt; <code>0xE4</code><br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<code>10111000</code> =&gt; <code>0xB8</code><br />\n<img alt=\"image\" class=\"lazyload\" /><br />\n<code>10101101</code> =&gt; <code>0xAD</code><br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n</ol>\n<p>最终\"中\"这个字符的UTF-8编码序列是<code>E4 B8 AD</code> ，也就是我们日常中经常看到的UTF-8 十六进制表示<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<h3 id=\"眼见为实以a举例\">眼见为实，以\"A\"举例</h3>\n<ol>\n<li>确定字节数<br />\n\"A\"的码点为<code>U+0041</code>，在<code>U+0000~U+007F</code>访问内，占用1字节。</li>\n<li>十六进制转换成二进制<br />\n<code>0041</code>转成二进制，得到<code>0100 0001</code><br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n<li>按照UTF-8模板格式填充<br />\n1字节的模板格式为:<code>0xxxxxxx</code> (起始字节)<br />\n----得到UTF-8编码:<code>01000001</code></li>\n<li>二进制转换成十六进制<br />\n实际上又转换回来，又变回了<code>0041</code>。</li>\n</ol>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<blockquote>\n<p>UTF-8 以一种很<code>偷鸡又巧妙</code>的办法 ，实现了与ASCII的兼容。<br />\n因为ASCII只占用7bit，最高位默认为0，而UTF-8，1字节的模板也是0xxxxxxx ，从而实现了与ASCII的兼容</p>\n</blockquote>\n<h2 id=\"回到主题\">回到主题</h2>\n<ol>\n<li>\n<p>UTF-8 不存在大小端问题<br />\n由于UTF-8的可变长编码与标准的字节格式，所以每个字符的格式是固定的，有明确的先后顺序。<br />\n比如\"中\"的U+4E2D，UTF-8编码是<code>E4-B8-AD</code>， 这三个字节的顺序是唯一且固定的，解析时如果顺序颠倒，就会解析失败，所以不用管大端还是小端，严格按照顺序解析即可。</p>\n</li>\n<li>\n<p>UTF-8能够自我解析/识别，无需BOM作为签名<br />\nBOM 还有一个附加作用：作为文件编码的 “签名”，帮助软件快速识别 Unicode 编码格式。但对于 UTF-8 而言，这种 “签名” 也是多余的。<br />\n因为解析软件可以通过扫描文本的二进制内容，根据UTF-8的格式规则，（上面提到的<code>0xxxxxxx</code>、<code>110xxxxx</code>等），直接判断文件是否为 UTF-8 编码，无需依赖文件开头的 BOM 标记</p>\n</li>\n</ol>\n<h1 id=\"为什么有utf-8-bom的存在\">为什么有UTF-8 BOM的存在？</h1>\n<p>UTF-8 BOM并非Unicode官方标准，而是微软为<code>解决兼容问题而留下的历史包袱</code>。<br />\n早期的Windows默认编码是 <strong>本地化ANSI</strong>，它是Windows早期为适配本地语言设计的历史编码方案，它千好万好，为windows全球化立下了汗马功劳，但有一个致命的缺点，<code>文件开头没有任何特殊标识</code>。</p>\n<blockquote>\n<p>比如中文系统默认 GBK/GB2312，英文系统默认 ISO-8859-1，日文系统默认 Shift_JIS—— 这些 ANSI 编码都是无标记的多字节编码，和 UTF-8 一样，文件开头没有任何特殊标识。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n</blockquote>\n<h2 id=\"眼见为实-1\">眼见为实</h2>\n<p>比如用户在记事本中写了字符\"中\"，保存为 UTF-8（无 BOM），下次打开时，记事本没有任何标记可以判断这是 UTF-8，可能会按照<strong>系统ANSI</strong> ，比如GBK来解析，导致出现乱码。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<h1 id=\"为什么中文在utf-16下占用2字节反而在utf-8中占用3字节了\">为什么中文在UTF-16下占用2字节，反而在UTF-8中占用3字节了？</h1>\n<p><strong>简单来说，就是运气问题，UTF-8 的字节数是按码点容量分层设计的，中文的码点大小决定了它只能落在 3 字节区间。</strong><br />\n我们日常使用的 99% 以上的中文，码点都在BMP 平面的<code>U+4E00（一）~U+9FA5（龥）</code> 区间，<br />\n而UTF-16的编码规则是，对BMP平面字符直接<code>用2字节编码</code>,对SMP平面<code>用4字节编码</code>。而<code>刚好落在BMP的中文码点</code>自然而然的就使用2字节编码<br />\n但UTF-8的编码规则是根据Unicode 码点的大小来决定字节数，而中文的<code>U+4E00~U+9FA5</code> 刚好落在了<code>U+0800 ~ U+FFFF</code>这个3字节码点的区间内，因此要遵守3字节编码的规则。</p>\n<h2 id=\"为什么utf-8不把中文设计为2字节\">为什么UTF-8不把中文设计为2字节？</h2>\n<p>主要是2字节的UTF-8区间<code>U+0080 ~ U+07FF</code>容量有限，装不下这么多中文。<br />\n2字节的UTF-8 去掉前面的110，10 标识位，只剩下5+6=11位的有效容量，只能表示2^11=2048个码点，容纳不下中文。只有3字节的有效容量是4+6+6=16 ，可以表示2^16=65536个码点，刚好覆盖整个 BMP 平面，足以容纳所有中文常用字。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 16:14</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lmy5215006\">叫我安不理</a>&nbsp;\n阅读(<span id=\"post_view_count\">82</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Qt 技巧笔记 (五) Qt消息框（QMessageBox）的全面使用指南",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19569909",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19569909\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 15:55\">\n    <span>Qt 技巧笔记 (五) Qt消息框（QMessageBox）的全面使用指南</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"qt-技巧笔记-五---qt消息框qmessagebox的全面使用指南\">Qt 技巧笔记 (五)   Qt消息框（QMessageBox）的全面使用指南</h1>\n<p>​       在Qt框架开发中，消息框组件(QMessageBox) 是处理用户交互的核心工具。本笔记系统梳理了QMessageBox的6种预定义类型，静态调用与实例化调用的对比，自定义实现方法及常见问题解决方案，帮助开发者实现用户提示功能。</p>\n<p>​       <code>QMessageBox</code>是Qt中用于<strong>弹出对话框消息</strong>的类，继承于<span class=\"math inline\">\\(QDialog\\)</span>，常用于提示消息、警告、错误、确认等场景，是Qt GUI应用开发中非常常用的组件之一。用于弹出一个模式对话框（模态窗口），显示消息给用户，并等待用户点击按钮（如“确定”、\"取消\"、”是“、“否”等）后再继续程序执行。其核心特征是<strong>阻塞交互式</strong>，用户必须响应对话框（点击按钮）后，程序才会继续执行后续代码。</p>\n<p>​</p>\n<h2 id=\"11-预定义消息框类型\">1.1 预定义消息框类型</h2>\n<p>Qt提供6种标准消息类型，通过静态方法快速调用：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>调用方法</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>消息提示框</td>\n<td><code>QMessageBox::information()</code></td>\n<td>普通信息展示</td>\n</tr>\n<tr>\n<td>警告提示框</td>\n<td><code>QMessageBox::warning()</code></td>\n<td>操作风险警示</td>\n</tr>\n<tr>\n<td>错误提示框</td>\n<td><code>QMessageBox::critical()</code></td>\n<td>严重错误警示</td>\n</tr>\n<tr>\n<td>确认选择框</td>\n<td><code>QMessageBox::question()</code></td>\n<td>二选一决策</td>\n</tr>\n<tr>\n<td>关于对话框</td>\n<td>QMessageBox::about()</td>\n<td>应用信息扩展</td>\n</tr>\n<tr>\n<td>版本信息框</td>\n<td>QMessageBox::aboutQt()</td>\n<td>Qt版本说明</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>其典型调用案例：</p>\n<p>1.显示信息提示框（information）</p>\n<pre><code class=\"language-C++\">QMessageBox::information(this, \"标题\", \"这是一个信息提示框\");\n</code></pre>\n<p>2.警告窗（warning）</p>\n<pre><code class=\"language-C++\">QMessageBox::warning(this,\"警告\",\"这是一个警告框\");\n</code></pre>\n<p>3.错误框（critial）</p>\n<pre><code class=\"language-C++\">QMessageBox::critical(this,\"错误\",\"出现了严重的错误\");\n</code></pre>\n<p>4.提问框（question）</p>\n<pre><code class=\"language-C++\">    int ret = QMessageBox::question(nullptr, (\"MyNoteBook Notice:\"),\n                                    (\"The document has been modified.\\n\"\n                                     \"Do you want to save your changes?\"),\n                                    QMessageBox::Save | QMessageBox::Discard\n                                    | QMessageBox::Cancel, /*按钮的属性*/\n                                    QMessageBox::Save); /*默认按钮按下*/\n    switch (ret)\n    {\n    case QMessageBox::Save:\n        qDebug()&lt;&lt;\"QMessageBox::Save\";\n        break;\n    case QMessageBox::Discard:\n        qDebug()&lt;&lt;\"QMessageBox::Discard\";\n        break;\n    case QMessageBox::Cancel:\n        qDebug()&lt;&lt;\"QMessageBox::Cancel\";\n        break;\n     default:\n        break;\n    }\n</code></pre>\n<p>其中按钮类型（QMessage::StandardButton）</p>\n<table>\n<thead>\n<tr>\n<th>按钮枚举值</th>\n<th>显示内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>QMessageBox::Ok</code></td>\n<td>确定</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Cancel</code></td>\n<td>取消</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Yes</code></td>\n<td>是</td>\n</tr>\n<tr>\n<td><code>QMessageBox::No</code></td>\n<td>否</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Abort</code></td>\n<td>终止</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Retry</code></td>\n<td>重试</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Ignore</code></td>\n<td>忽略</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"12-静态调用与实例化调用对比\">1.2 静态调用与实例化调用对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>静态调用</th>\n<th>实例化调用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>语法形式</td>\n<td><code>QMessageBox::type(parent, ...)</code></td>\n<td><code>QMessageBox box; box.setXXX(...)</code></td>\n</tr>\n<tr>\n<td>定制能力</td>\n<td>仅支持预设按钮/图标</td>\n<td>支持完整UI定制</td>\n</tr>\n<tr>\n<td>线程阻塞</td>\n<td>自动模态显示</td>\n<td>需手动调用exec()</td>\n</tr>\n<tr>\n<td>典型场景</td>\n<td>快速实现简单提示</td>\n<td>复杂交互需求</td>\n</tr>\n</tbody>\n</table>\n<p>其中图标定制类型如下：</p>\n<table>\n<thead>\n<tr>\n<th>图标类型</th>\n<th>含   义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>QMessageBox::NoIcon</code></td>\n<td>无图标</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Information</code></td>\n<td>信息图标（ℹ️）</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Warning</code></td>\n<td>警告图标（⚠）</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Critical</code></td>\n<td>错误图标（❌）</td>\n</tr>\n<tr>\n<td><code>QMessageBox::Question</code></td>\n<td>问号图标（❓）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"13-深度定制实现方案\">1.3 深度定制实现方案</h2>\n<p>对话框的关键定制方法：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>功能说明</th>\n<th>参数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>setWindowTitle()</code></td>\n<td>设置对话框标题</td>\n<td><code>QString</code></td>\n</tr>\n<tr>\n<td><code>setText()</code></td>\n<td>设置主提示文本</td>\n<td><code>QString</code></td>\n</tr>\n<tr>\n<td>setIconPixmap()</td>\n<td>设置自定义图标</td>\n<td>QPixmap</td>\n</tr>\n<tr>\n<td>addButton()</td>\n<td>添加自定义按钮</td>\n<td>(QString, ButtonRole)</td>\n</tr>\n<tr>\n<td>setStyleSheet()</td>\n<td>应用CSS样式</td>\n<td>QString</td>\n</tr>\n</tbody>\n</table>\n<p>完整自定义示例：</p>\n<pre><code class=\"language-C++\">#include &lt;QMessageBox&gt;\n#include &lt;QPushButton&gt;\n#include &lt;QDebug&gt;\n\nvoid showCustomMessageBox() {\n    QMessageBox box;\n    box.setWindowTitle(\"自定义对话框\");\n    box.setText(\"请确认操作：\");\n    \n    // 添加自定义按钮\n    QPushButton *confirmBtn = box.addButton(\"确认\", QMessageBox::AcceptRole);\n    QPushButton *cancelBtn = box.addButton(\"取消\", QMessageBox::RejectRole);\n    \n    // 设置图标（支持缩放）\n    box.setIconPixmap(QPixmap(\":/icons/warning.png\").scaled(64, 64));\n    \n    // 样式定制\n    box.setStyleSheet(\n        \"QMessageBox { background-color: #f0f0f0; font-size: 14px; }\"\n        \"QPushButton { min-width: 80px; min-height: 30px; }\"\n    );\n    \n    box.exec();\n    \n    if (box.clickedButton() == confirmBtn) {\n        qDebug() &lt;&lt; \"用户点击了确认\";\n    } else {\n        qDebug() &lt;&lt; \"用户点击了取消\";\n    }\n}\n</code></pre>\n<h2 id=\"14-高级应用场景\">1.4 高级应用场景</h2>\n<p><strong>动态内容切换</strong></p>\n<pre><code class=\"language-C++\">void showDynamicMessage(bool isSuccess) {\n    QMessageBox box;\n    box.setWindowTitle(isSuccess ? \"操作结果\" : \"错误提示\");\n    box.setText(isSuccess ? \"操作成功完成\" : \"操作失败，请重试\");\n    box.setIcon(isSuccess ? QMessageBox::Information : QMessageBox::Critical);\n    box.exec();\n}\n</code></pre>\n<p><strong>多语言支持</strong></p>\n<pre><code class=\"language-C++\">void showLocalizedMessage(QLocale locale) {\n    QMessageBox box;\n    if (locale == QLocale::Chinese) {\n        box.setWindowTitle(\"提示\");\n        box.setText(\"确定要执行此操作吗？\");\n    } else {\n        box.setWindowTitle(\"Warning\");\n        box.setText(\"Are you sure to proceed?\");\n    }\n    box.exec();\n}\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 15:55</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">76</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "asp.net core如何实现Controller热更新",
      "link": "https://www.cnblogs.com/kevin-Y/p/19569791",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kevin-Y/p/19569791\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 15:41\">\n    <span>asp.net core如何实现Controller热更新</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>可能是以往的习惯，我希望生产环境的服务可以热更新。有人会说Docker，可我希望能更简单一些。所以一直关注asp.net core如何热更新</p>\n<p>早前读过这文章，工作关系没有继续学习。今天遇到一个关键问题，还是这文章启发了我。</p>\n<p><a href=\"https://www.cnblogs.com/artech/p/dynamic-controllers.html\" target=\"_blank\">https://www.cnblogs.com/artech/p/dynamic-controllers.html</a></p>\n<p>第一步，dll需要在使用后，依然可以被修改和替换。我们需要一个继承自AssemblyLoadContext的类</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_358157ef-9bd8-48a3-99bd-62e649904895\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_358157ef-9bd8-48a3-99bd-62e649904895\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_358157ef-9bd8-48a3-99bd-62e649904895\">\n<pre><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 支持真正卸载的插件加载上下文\n</span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> CollectiblePluginLoadContext : AssemblyLoadContext\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> _pluginPath;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span>?<span style=\"color: rgba(0, 0, 0, 1);\"> _pluginDirectory;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> CollectiblePluginLoadContext(<span style=\"color: rgba(0, 0, 255, 1);\">string</span> pluginPath) : <span style=\"color: rgba(0, 0, 255, 1);\">base</span>(isCollectible: <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        _pluginPath </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> pluginPath;\n        _pluginDirectory </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Path.GetDirectoryName(pluginPath);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">protected</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> Assembly?<span style=\"color: rgba(0, 0, 0, 1);\"> Load(AssemblyName assemblyName)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 尝试从插件目录加载依赖项</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.IsNullOrEmpty(_pluginDirectory))\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> assemblyPath = Path.Combine(_pluginDirectory, assemblyName.Name + <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">.dll</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            \n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (File.Exists(assemblyPath))\n            {\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用流加载避免锁定依赖DLL文件</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span> fileStream = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> FileStream(assemblyPath, FileMode.Open, FileAccess.Read, FileShare.Read);\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> LoadFromStream(fileStream);\n            }\n        }\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 如果在插件目录中找不到，则返回null，让默认上下文处理</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">protected</span> <span style=\"color: rgba(0, 0, 255, 1);\">override</span> IntPtr LoadUnmanagedDll(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> unmanagedDllName)\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 尝试从插件目录加载非托管DLL</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\">.IsNullOrEmpty(_pluginDirectory))\n        {\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> unmanagedDllPath = Path.Combine(_pluginDirectory, unmanagedDllName + <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">.dll</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n            \n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (File.Exists(unmanagedDllPath))\n            {\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对于非托管DLL，仍然需要使用路径加载\n                </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 但可以在加载后立即关闭句柄以减少锁定</span>\n                <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> LoadUnmanagedDllFromPath(unmanagedDllPath);\n            }\n        }\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 如果在插件目录中找不到，则返回零，让默认上下文处理</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> IntPtr.Zero;\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> Assembly LoadPluginAssembly()\n    {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用流加载避免锁定DLL文件</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">var</span> fileStream = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> FileStream(_pluginPath, FileMode.Open, FileAccess.Read, FileShare.Read);\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> LoadFromStream(fileStream);\n    }\n}</span></pre>\n</div>\n<span class=\"cnblogs_code_collapse\">CollectiblePluginLoadContext </span></div>\n<p>第二步，ApplicationPartManager添加动态加载的Assembly。</p>\n<p>一开始我以为加入前移除就能完整热加载</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 从应用部件管理器中移除程序集</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> partToRemove =<span style=\"color: rgba(0, 0, 0, 1);\"> _partManager.ApplicationParts\n    .OfType</span>&lt;AssemblyPart&gt;<span style=\"color: rgba(0, 0, 0, 1);\">()\n    .FirstOrDefault(p </span>=&gt; p.Assembly ==<span style=\"color: rgba(0, 0, 0, 1);\"> assembly);\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (partToRemove != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n{\n    _partManager.ApplicationParts.Remove(partToRemove);\n}<br /></span></pre>\n<pre>// 将程序集添加到应用部件管理器\nvar assemblyPart = new<span> AssemblyPart(assembly);\n_partManager.ApplicationParts.Add(assemblyPart);</span></pre>\n</div>\n<p>实际上不能，如一开头的文章说到的</p>\n<div class=\"cnblogs_code\">\n<pre>...但是MVC默认情况下对提供的ActionDescriptor对象进行了缓存。<br />如果框架能够使用新的ActionDescriptor对象，需要告诉它当前应用提供的ActionDescriptor列表发生了改变，而这可以利用自定义的IActionDescriptorChangeProvider来实现。<br />为此我们定义了如下这个DynamicChangeTokenProvider类型，该类型实现了IActionDescriptorChangeProvider接口，并利用GetChangeToken方法返回IChangeToken对象通知<br />MVC框架当前的ActionDescriptor已经发生改变。从实现实现代码可以看出，当我们调用NotifyChanges方法的时候，状态改变通知会被发出去。</pre>\n</div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> DynamicChangeTokenProvider : IActionDescriptorChangeProvider\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> CancellationTokenSource _source;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">private</span><span style=\"color: rgba(0, 0, 0, 1);\"> CancellationChangeToken _token;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> DynamicChangeTokenProvider()\n    {\n        _source </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> CancellationTokenSource();\n        _token </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> CancellationChangeToken(_source.Token);\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> IChangeToken GetChangeToken() =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> _token;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> NotifyChanges()\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> old = Interlocked.Exchange(<span style=\"color: rgba(0, 0, 255, 1);\">ref</span> _source, <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> CancellationTokenSource());\n        _token </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> CancellationChangeToken(_source.Token);\n        old.Cancel();\n    }\n}</span></pre>\n</div>\n<p>有了蒋金楠（大内老A）的上面的代码，事情就好办了。以下是我的Program.cs的主要代码</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 添加MVC服务以支持动态控制器</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">builder.Services.AddControllers();\n\nbuilder.Services.AddSingleton</span>&lt;DynamicChangeTokenProvider&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\nbuilder.Services.AddSingleton</span>&lt;IActionDescriptorChangeProvider&gt;(provider =&gt; provider.GetRequiredService&lt;DynamicChangeTokenProvider&gt;<span style=\"color: rgba(0, 0, 0, 1);\">());\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> app =<span style=\"color: rgba(0, 0, 0, 1);\"> builder.Build();</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 初始化改进的插件管理器（支持真正卸载）</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> partManager = app.Services.GetRequiredService&lt;ApplicationPartManager&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> tokenProvider = app.Services.GetRequiredService&lt;DynamicChangeTokenProvider&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> improvedPluginManager = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ImprovedPluginManager(partManager, tokenProvider);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 预加载已存在的插件</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> improvedPluginManager.LoadAllPluginsAsync();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 映射控制器路由</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">app.MapControllers();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 默认根路径</span>\napp.MapGet(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, () =&gt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Dynamic Controller Demo Running!</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 重新加载所有插件端点</span>\napp.MapPost(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/reload-plugins</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, <span style=\"color: rgba(0, 0, 255, 1);\">async</span> () =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> improvedPluginManager.LoadAllPluginsAsync();\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Plugins reloaded with true unloading</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n});\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取已加载插件列表</span>\napp.MapGet(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">/loaded-plugins</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, () =&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> improvedPluginManager.GetLoadedPlugins();\n});</span></pre>\n</div>\n<p>好了。程序跑起来。主程序没有Controller的实现。程序提供的WebApi，由plugin目录中的dll所包含Controller决定。至此期待的url正常响应了。将新的dll拷贝到plugin目录，替换旧的，post一下</p>\n<pre>/reload-plugins</pre>\n<p>WebApi也被新的程序响应了。当然我们也可以监视一下plugin目录，有文件修改时自动加载。</p>\n<p>附上ImprovedPluginManager.cs的源代码</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_c74a20f6-a571-4d10-be21-2a34e693262f\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_c74a20f6-a571-4d10-be21-2a34e693262f\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_c74a20f6-a571-4d10-be21-2a34e693262f\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">  1</span> <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> ImprovedPluginManager\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  2</span> <span style=\"color: rgba(0, 0, 0, 1);\">{\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  3</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> ApplicationPartManager _partManager;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  4</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> Dictionary&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>, (CollectiblePluginLoadContext context, Assembly assembly)&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> _loadedPlugins;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  5</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> List&lt;PluginInfo&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> _pluginInfos;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  6</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> _pluginsDirectory;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  7</span>     <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">readonly</span><span style=\"color: rgba(0, 0, 0, 1);\"> DynamicChangeTokenProvider _tokenProvider;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  8</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">  9</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> ImprovedPluginManager(ApplicationPartManager partManager, DynamicChangeTokenProvider tokenProvider)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 10</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 11</span>         _tokenProvider =<span style=\"color: rgba(0, 0, 0, 1);\"> tokenProvider;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 12</span>         _partManager =<span style=\"color: rgba(0, 0, 0, 1);\"> partManager;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 13</span>         _loadedPlugins = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> Dictionary&lt;<span style=\"color: rgba(0, 0, 255, 1);\">string</span>, (CollectiblePluginLoadContext, Assembly)&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 14</span>         _pluginInfos = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;PluginInfo&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 15</span>         \n<span style=\"color: rgba(0, 128, 128, 1);\"> 16</span>         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设置插件目录</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 17</span>         _pluginsDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Plugins</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 18</span>         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">Directory.Exists(_pluginsDirectory))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 19</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 20</span> <span style=\"color: rgba(0, 0, 0, 1);\">            Directory.CreateDirectory(_pluginsDirectory);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 21</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 22</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 23</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 24</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> Task&lt;<span style=\"color: rgba(0, 0, 255, 1);\">bool</span>&gt; LoadPluginAsync(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> pluginPath)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 25</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 26</span>         <span style=\"color: rgba(0, 0, 255, 1);\">try</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 27</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 28</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">File.Exists(pluginPath))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 29</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 30</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> FileNotFoundException($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Plugin file not found: {pluginPath}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 31</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 32</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 33</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 检查文件扩展名</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 34</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!pluginPath.EndsWith(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">.dll</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, StringComparison.OrdinalIgnoreCase))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 35</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 36</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> ArgumentException(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Plugin must be a .dll file</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 37</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 38</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 39</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建可收集的加载上下文</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 40</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> loadContext = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> CollectiblePluginLoadContext(pluginPath);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 41</span>             \n<span style=\"color: rgba(0, 128, 128, 1);\"> 42</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 加载程序集</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 43</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> assembly =<span style=\"color: rgba(0, 0, 0, 1);\"> loadContext.LoadPluginAssembly();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 44</span>             \n<span style=\"color: rgba(0, 128, 128, 1);\"> 45</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 获取所有控制器类型</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 46</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> controllerTypes =<span style=\"color: rgba(0, 0, 0, 1);\"> assembly.GetTypes()\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 47</span>                 .Where(t =&gt; t.IsSubclassOf(<span style=\"color: rgba(0, 0, 255, 1);\">typeof</span>(ControllerBase)) &amp;&amp; !<span style=\"color: rgba(0, 0, 0, 1);\">t.IsAbstract)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 48</span> <span style=\"color: rgba(0, 0, 0, 1);\">                .ToList();\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 49</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 50</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">controllerTypes.Any())\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 51</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 52</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">throw</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> InvalidOperationException($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">No controllers found in plugin: {pluginPath}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 53</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 54</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 55</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 检查是否已经加载了相同的程序集</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 56</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (_loadedPlugins.ContainsKey(assembly.FullName))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 57</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 58</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> UnloadPluginAsync(assembly.FullName);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 59</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 60</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 61</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将程序集添加到应用部件管理器</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 62</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> assemblyPart = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> AssemblyPart(assembly);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 63</span> <span style=\"color: rgba(0, 0, 0, 1);\">            _partManager.ApplicationParts.Add(assemblyPart);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 64</span>             \n<span style=\"color: rgba(0, 128, 128, 1);\"> 65</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 记录已加载的插件和上下文</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 66</span>             _loadedPlugins[assembly.FullName] =<span style=\"color: rgba(0, 0, 0, 1);\"> (loadContext, assembly);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 67</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 68</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 创建插件信息</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 69</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> pluginInfo = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> PluginInfo\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 70</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 71</span>                 Name =<span style=\"color: rgba(0, 0, 0, 1);\"> Path.GetFileNameWithoutExtension(pluginPath),\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 72</span>                 Version = assembly.GetName().Version?.ToString() ?? <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Unknown</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 73</span>                 Description = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Dynamic controller plugin</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 74</span>                 FilePath =<span style=\"color: rgba(0, 0, 0, 1);\"> pluginPath,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 75</span>                 LoadedAt =<span style=\"color: rgba(0, 0, 0, 1);\"> DateTime.Now,\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 76</span>                 ControllerTypes = controllerTypes.Select(t =&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> t.Name).ToList()\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 77</span> <span style=\"color: rgba(0, 0, 0, 1);\">            };\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 78</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 79</span> <span style=\"color: rgba(0, 0, 0, 1);\">            _pluginInfos.Add(pluginInfo);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 80</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 81</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Successfully loaded plugin: {pluginPath}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 82</span>             <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> controller <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> controllerTypes)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 83</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 84</span>                 Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">  - Controller: {controller.Name}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 85</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 86</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 87</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 88</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 89</span>         <span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (Exception ex)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 90</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 91</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Failed to load plugin: {ex.Message}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 92</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 93</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 94</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 95</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 96</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> Task&lt;<span style=\"color: rgba(0, 0, 255, 1);\">bool</span>&gt; UnloadPluginAsync(<span style=\"color: rgba(0, 0, 255, 1);\">string</span><span style=\"color: rgba(0, 0, 0, 1);\"> assemblyFullName)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 97</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 98</span>         <span style=\"color: rgba(0, 0, 255, 1);\">try</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 99</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">100</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">_loadedPlugins.ContainsKey(assemblyFullName))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">101</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">102</span>                 <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">103</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">104</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">105</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> (loadContext, assembly) =<span style=\"color: rgba(0, 0, 0, 1);\"> _loadedPlugins[assemblyFullName];\n</span><span style=\"color: rgba(0, 128, 128, 1);\">106</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">107</span>             \n<span style=\"color: rgba(0, 128, 128, 1);\">108</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 从应用部件管理器中移除程序集</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">109</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> partToRemove =<span style=\"color: rgba(0, 0, 0, 1);\"> _partManager.ApplicationParts\n</span><span style=\"color: rgba(0, 128, 128, 1);\">110</span>                 .OfType&lt;AssemblyPart&gt;<span style=\"color: rgba(0, 0, 0, 1);\">()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">111</span>                 .FirstOrDefault(p =&gt; p.Assembly ==<span style=\"color: rgba(0, 0, 0, 1);\"> assembly);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">112</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">113</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (partToRemove != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">114</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">115</span> <span style=\"color: rgba(0, 0, 0, 1);\">                _partManager.ApplicationParts.Remove(partToRemove);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">116</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">117</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">118</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 从已加载插件列表中移除</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">119</span> <span style=\"color: rgba(0, 0, 0, 1);\">            _loadedPlugins.Remove(assemblyFullName);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">120</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">121</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 从插件信息列表中移除</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">122</span>             <span style=\"color: rgba(0, 0, 255, 1);\">var</span> pluginInfo = _pluginInfos.FirstOrDefault(p =&gt; p.FilePath ==<span style=\"color: rgba(0, 0, 0, 1);\"> assembly.Location);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">123</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (pluginInfo != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">124</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">125</span> <span style=\"color: rgba(0, 0, 0, 1);\">                _pluginInfos.Remove(pluginInfo);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">126</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">127</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">128</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 卸载加载上下文</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">129</span> <span style=\"color: rgba(0, 0, 0, 1);\">            loadContext.Unload();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">130</span>             \n<span style=\"color: rgba(0, 128, 128, 1);\">131</span>             <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 强制垃圾回收以释放程序集</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">132</span> <span style=\"color: rgba(0, 0, 0, 1);\">            GC.Collect();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">133</span> <span style=\"color: rgba(0, 0, 0, 1);\">            GC.WaitForPendingFinalizers();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">134</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">135</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">=== UNLOAD DIAGNOSTICS ===</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">136</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Successfully unloaded plugin: {assemblyFullName}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">137</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Assembly location: {assembly.Location}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">138</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Loaded plugins count after unload: {_loadedPlugins.Count}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">139</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Plugin infos count after unload: {_pluginInfos.Count}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">140</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Application parts count after unload: {_partManager.ApplicationParts.Count}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">141</span>             Console.WriteLine(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">========================</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">142</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">143</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">144</span>         <span style=\"color: rgba(0, 0, 255, 1);\">catch</span><span style=\"color: rgba(0, 0, 0, 1);\"> (Exception ex)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">145</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">146</span>             Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Failed to unload plugin: {ex.Message}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">147</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">148</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">149</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">150</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">151</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span> List&lt;PluginInfo&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> GetLoadedPlugins()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">152</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">153</span>         <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> _pluginInfos.ToList();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">154</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">155</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">156</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> Task&lt;List&lt;FileInfo&gt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> ScanPluginFilesAsync()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">157</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">158</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> pluginDirInfo = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> DirectoryInfo(_pluginsDirectory);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">159</span>         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1);\">pluginDirInfo.Exists)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">160</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">161</span>             <span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">new</span> List&lt;FileInfo&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">162</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">163</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">164</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> dllFiles = pluginDirInfo.GetFiles(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">*.dll</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, SearchOption.AllDirectories);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">165</span>         <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> dllFiles.ToList();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">166</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">167</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">168</span>     <span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">async</span> Task&lt;<span style=\"color: rgba(0, 0, 255, 1);\">bool</span>&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> LoadAllPluginsAsync()\n</span><span style=\"color: rgba(0, 128, 128, 1);\">169</span> <span style=\"color: rgba(0, 0, 0, 1);\">    {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">170</span>         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 先卸载所有已加载的插件</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">171</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> assembliesToUnload =<span style=\"color: rgba(0, 0, 0, 1);\"> _loadedPlugins.Keys.ToList();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">172</span>         <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> assemblyName <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> assembliesToUnload)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">173</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">174</span>             <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> UnloadPluginAsync(assemblyName);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">175</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">176</span>         \n<span style=\"color: rgba(0, 128, 128, 1);\">177</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> pluginFiles = <span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> ScanPluginFilesAsync();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">178</span>         <span style=\"color: rgba(0, 0, 255, 1);\">var</span> successCount = <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">179</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">180</span>         <span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> pluginFile <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> pluginFiles)\n</span><span style=\"color: rgba(0, 128, 128, 1);\">181</span> <span style=\"color: rgba(0, 0, 0, 1);\">        {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">182</span>             <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (<span style=\"color: rgba(0, 0, 255, 1);\">await</span><span style=\"color: rgba(0, 0, 0, 1);\"> LoadPluginAsync(pluginFile.FullName))\n</span><span style=\"color: rgba(0, 128, 128, 1);\">183</span> <span style=\"color: rgba(0, 0, 0, 1);\">            {\n</span><span style=\"color: rgba(0, 128, 128, 1);\">184</span>                 successCount++<span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">185</span> <span style=\"color: rgba(0, 0, 0, 1);\">            }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">186</span> <span style=\"color: rgba(0, 0, 0, 1);\">        }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">187</span> <span style=\"color: rgba(0, 0, 0, 1);\">        _tokenProvider.NotifyChanges();\n</span><span style=\"color: rgba(0, 128, 128, 1);\">188</span>         Console.WriteLine($<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">Loaded {successCount} out of {pluginFiles.Count} plugins</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n</span><span style=\"color: rgba(0, 128, 128, 1);\">189</span>         <span style=\"color: rgba(0, 0, 255, 1);\">return</span> successCount &gt; <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n</span><span style=\"color: rgba(0, 128, 128, 1);\">190</span> <span style=\"color: rgba(0, 0, 0, 1);\">    }\n</span><span style=\"color: rgba(0, 128, 128, 1);\">191</span> }</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">ImprovedPluginManager</span></div>\n<p>如有错误请指正。</p>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 15:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kevin-Y\">生命体验之kevin-Y</a>&nbsp;\n阅读(<span id=\"post_view_count\">198</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "深入理解傅里叶变换",
      "link": "https://www.cnblogs.com/zhaoweiwei/p/19522497/FFT",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zhaoweiwei/p/19522497/FFT\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 14:45\">\n    <span>深入理解傅里叶变换</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文详细介绍傅里叶变换的相关概念，并给出快速傅里叶变换的递归及迭代两种算法源码，最后给出了快速傅里叶变换在音频及图像领用的应用实例！\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>1 基础概念</h1>\n<h2>1.1 傅里叶级数</h2>\n<h3>1 周期函数</h3>\n<p>若函数f(x)满足：存在非零常数T，对任意x有<em>f(x+T) = f(x)</em>，则称<em>f(x)</em>为周期函数，T为其周期；最小正周期称为<strong>基本周期</strong>（记为T<sub>0</sub>）。傅里叶级数中，最常用以2π为周期的函数（T=2π），其他周期的函数可通过变量替换转化为2π周期，因此核心研究2π周期函数。</p>\n<h3>2 三角函数系的正交性</h3>\n<p>傅里叶级数的本质是<span>在三角函数系中对周期函数做正交分解，类似平面向量在x<span>、y轴上的分解，三角函数系就是周期函数空间的一组<span>正交基。</span></span></span></p>\n<p><span><span><span>（1）标准正交三角函数系（2π周期）<br /></span></span></span></p>\n<p><span><span><span><span><span><span>{1,cos<em>x</em>,sin<em>x,</em>cos<em>2x</em>,sin<em>2x</em>,…,cos<em>nx</em>,sin<em>nx</em>,…}</span></span></span></span></span></span></p>\n<div>其中n为正整数，1可以看作cos0x。</div>\n<div>（2）正交性的定义&nbsp;</div>\n<p><span><span><span>对上述三角函数系中<span>任意两个不同的函数<span><span>φ<sub>m</sub>​(x)和<span><span>φ<sub>n​</sub>(x)，满足：</span></span></span></span></span></span></span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123161629850-520864769.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>对同一个函数，积分结果非零：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123161705334-1222793239.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>（3）核心正交积分公式</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123161754523-450618120.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p><strong>正交性的意义</strong>：三角函数系中的各个基函数“互不干扰”，分解后的每个正余弦项的系数可独立计算，这是傅里叶级数能求解的关键。</p>\n<h3>3 傅里叶级数</h3>\n<p>法国数学家傅里叶认为，任何周期函数都可以用正弦函数和余弦函数构成的无穷级数来表示（选择正弦函数与余弦函数作为基函数是因为它们是正交的），后世称傅里叶级数为一种特殊的三角级数，根据欧拉公式，三角函数又能化成指数形式，也称傅立叶级数为一种指数级数。在数学中，三角级数是任何具有下述形式的级数：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123160454187-1477445403.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>当A<sub>n</sub>和B<sub>n</sub>具有以下形式时，该级数称为傅立叶级数：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123160641857-1444839643.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>其中f(x)是可积函数。下面给出2π周期函数的傅里叶级数定义：</p>\n<p>设f(x)是以2π为周期的函数，且在[-π,&nbsp;π]上可积，则其傅里叶级数为：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123162203699-209431809.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>符号说明：</p>\n<p>~：表示“展开为傅里叶级数”，而非严格相等（需满足收敛条件才相等）；</p>\n<p>a<sub>0</sub>/2：直流分量/零频项，是函数f(x)在一个周期内的平均值；</p>\n<p>a<sub>n</sub>cos<em>&nbsp;nx</em>：余弦项/偶次谐波，对应周期函数的偶函数分量；</p>\n<p>b<sub>n</sub>sin<em> nx</em>：正弦项/奇次谐波，对应周期函数的奇函数分量；</p>\n<p>a<sub>0</sub>, a<sub>n</sub>, b<sub>n</sub>：傅里叶系数，是唯一确定的常数，有f(x)决定。</p>\n<h2>1.2 傅里叶变换</h2>\n<h3>1 欧拉公式（Euler’s formula）</h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123163235634-1712793922.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>其中：e是自然常数，约等于2.71828，i是虚数单位满足i<sup>2</sup>=-1，θ是复指数的辐角∈R，对应复平面上的旋转角度。对于该公式当θ=π时，有e<sup>iπ</sup> + 1 = 0，这个公式在傅里叶变换中起到关键作用。</p>\n<h3>2 傅里叶变换（Fourier Transform, FT）</h3>\n<p>傅里叶变换是将时域的连续函数映射到频域连续函数的数学变换，是调和分析的核心工具，揭示了“任意连续周期/非周期函数均可分解为不同频率的正弦/余弦函数叠加”的本质。现给出连续傅里叶变换（Continuous Fourier Transform, CFT）相关定义，适用于定义域为全体实数R、满足狄利克雷条件（Dirichlet）的连续函数f(t)，其中t为时域自变量（通常表示时间），变换后得到频域函数F(ω)，ω为角频率（rad/s）。</p>\n<p>（1）正变换（时域→频域）</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123170719778-789709355.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>积分区间(−∞,+∞)对应非周期函数的时域是无限的，需对全体实数域积分，变换本质是：用所有频率的复指数函数作为“基函数”，对<span class=\"katex\"><span class=\"katex-mathml\">f(t)<span class=\"katex-html\"><span class=\"base\"><span class=\"strut\"><span class=\"mord mathnormal\"><span class=\"mopen\"><span class=\"mord mathnormal\"><span class=\"mclose\">做投影。</span></span></span></span></span></span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\"><span class=\"mord mathnormal\"><span class=\"mopen\"><span class=\"mord mathnormal\"><span class=\"mclose\">（2）逆变换（频域→时域）</span></span></span></span></span></span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\"><span class=\"mord mathnormal\"><span class=\"mopen\"><span class=\"mord mathnormal\"><span class=\"mclose\">傅里叶变换是可逆变换，从频域函数F(ω)还原时域f(t)的公式为：</span></span></span></span></span></span></span></span></span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260123171313838-843336180.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>关键系数1/2π：该系数是为了满足“正逆变换的归一性”，也有教材将系数拆分为1/sqrt(<span><span>2π​)分别放在正、逆变换中（数学上更对称），两种形式等价。<br /></span></span></p>\n<h3><span><span>3 离散傅里叶变换（Discrete Fourier Transform，DFT）</span></span></h3>\n<p>DFT是一种线性变换，把一个有限长的离散序列，从“时间/系数域”变换到“频率/点值域”。其数学定义为给定长度为n的复数序列：<em>x=(x<sub>0</sub>, x<sub>1</sub>, ..., x<sub>n-1</sub>)</em>，令：<em>ω = e<sup>-2πi/n</sup></em>，定义其离散傅里叶变换（DFT）为序列：</p>\n<p><img alt=\"image\" height=\"70\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260128155659439-1976105299.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"321\" /></p>\n<p><em>x<sub>j</sub></em>是输入序列（时域信号），<em>X<sub>k</sub></em>是输出序列（频域信号），通过将时域信号与一系列不同频率的复指数函数进行内积，得到每个频率分量在原始信号中的“含量”。DFT是一个线性变换，本质是<em>X = F*x</em>，其中F是一个范德蒙德（Vandermonde）矩阵，即从线性代数角度看：DFT = Vandermonde变换。从矩阵运算可以看出，要得到每个频率分量，需要进行n次乘法和n-1次加法运算，完成整个变换需要n<sup>2</sup>次乘法和n(n-1)次加法运算，所以完整变换的复杂度是O(n<sup>2</sup>)，当序列长度n较大时，计算量会变得极其庞大，限制了DFT在实际应用中的效率。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260128155733599-751298943.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>以多项式<em>A(x)=a<sub>0</sub>+a<sub>1</sub>x+a<sub>2</sub>x<sup>2</sup>+...+a<sub>n-1</sub>x<sup>n-1</sup></em>为例，则上述离散序列可以看作是多项式系数表示法（coefficient form）中的系数，即<em>x = a = (a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n-1</sub>）</em>，选择特殊的“点”——n次单位根：<em>ω = e<sup>2πi/n</sup></em>，它满足：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260128124328491-889419062.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>以n=11为例，图中所有<em>ω<sup>i</sup></em>都是11次单位根：</p>\n<p><img alt=\"image\" height=\"314\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129102811489-1505291339.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"322\" /></p>\n<p>考虑n个互不相同的点：<em>1,&nbsp;ω,&nbsp;ω<sup>2</sup>, ...,&nbsp;ω<sup>n-1</sup></em>，将其代入<em>A(x)</em>多项式，则有：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260128125054218-1282377609.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>可见<em>X<sub>k</sub> = A(ω<sup>-k</sup>)</em>，即DFT的计算结果，恰好等价于在单位根上的多项式求值（对应多项式的点值表示法）。</p>\n<p>逆离散傅里叶变换（IDFT）由以下公式给出：</p>\n<p><img alt=\"image\" height=\"77\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260128181138702-2110135213.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"162\" /></p>\n<p>傅里叶级数、傅里叶变换和DFT区别由下表给出：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260128171836655-1924902784.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h3>4 快速傅里叶变换（Fast Fourier Transform，FFT）</h3>\n<p>1965年，J.W.库利和T.W.图基提出了著名的Cooley-Tukey算法，即快速傅里叶变换（FFT）。FFT算法的核心是利用旋转因子的周期性、对称性和可约性，将长序列的DFT分解为短序列的DFT，从而大幅减少计算量。首先给出单位根的三个引理：</p>\n<p><img alt=\"image\" height=\"93\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129104718146-1091039001.png\" width=\"272\" /></p>\n<p>一句话概括FFT：利用n次单位根的周期性与对称性，把一个规模为n的DFT，拆成两个规模为N/2的DFT。在经典FFT算法（Cooley-Tukey算法）中假设n=2<sup>m</sup>，把序列拆成“偶数项+奇数项”：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129115917584-129576767.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>则可以将DFT拆开：</p>\n<p><img alt=\"image\" height=\"81\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129120821297-7172978.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"532\" /></p>\n<p>利用折半引理可将上式简化为：</p>\n<p><img alt=\"image\" height=\"34\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129122101594-403839310.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"196\" /></p>\n<p>其中：</p>\n<p><img alt=\"image\" height=\"172\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129122526097-623129615.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"213\" /></p>\n<p>以上将1个包含n次乘法的DFT分成两个n/2次乘法的DFT，另外由ω<sub>n</sub><sup>n/2+k</sup> = -ω<sub>n</sub><sup>k</sup>可以进一步得到迭代公式（1）：</p>\n<p><img alt=\"image\" height=\"78\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260130174113532-1641485917.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"376\" /></p>\n<p>以上就是所谓的蝶形运算（butterfly），一次算出两个输出。可见一个长度为n的DFT被拆成两个长度是n/2的DFT和n/2次蝶形合并，所以时间复杂度为：</p>\n<p><img alt=\"image\" height=\"29\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129143456252-107829582.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"237\" /></p>\n<p>这里<em>2T(n/2)</em>表示：要解决一个规模为<em>n</em>的问题，需要“调用两次”规模为<em>n/2</em>的同类问题，每一次的代价是<em>T(n/2)</em>；<em>cn</em>表示：当前这一层，为了把两个子FFT的结果“合并”所做的计算量。一个标准的radix-2蝶形：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129142325972-1041311975.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>需要：1次复数乘法<em>ωb</em>和2次复数加减法，都是常数级操作可记为O(1)，对于长度为n的FFT每一层有n/2个蝶形，所以每层蝶形计算量是n/2xO(1)=O(n)，可以记为cn，这里的c就是一个蝶形需要多少个“基础运算”的常数因子。所以随着层数递增有以下时间复杂度推导：</p>\n<p><img alt=\"image\" height=\"153\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129144210035-167113917.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"489\" /></p>\n<p>递归终止条件是当：<em>n/2<sup>k</sup>=1</em>，这时<em>k=log<sub>2</sub>n</em>，上述推导最终结果为：<em>T(n)=n*T(1)+cnlog<sub>2</sub>n</em>，忽略常数得最终复杂度公式<em>T(n)=O(nlog<sub>2</sub>n)</em>。</p>\n<p>以上给出了快速傅里叶变换，快速傅里叶逆变换（IFFT，Inverse FFT）定义及分析过程与正变换类似，为了公式简洁正变换分析过程取<em>ω = e<sup>-2πi/n</sup></em>，实际上在严格的数学定义中一般取<em>ω = e<sup>2πi/n</sup></em>（正向单位根），此时正变换和逆变换定义如下：</p>\n<p><img alt=\"image\" height=\"190\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129155724698-1691263367.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"412\" /></p>\n<p>正变换用于拆解信号，获取在正交基上的投影，逆变换用于合成信号，完成正交基投影的叠加。</p>\n<h2>1.3 NTT（Number Theoretic Transform）</h2>\n<p>NTT = 在有限域/模整数环中进行的FFT，即NTT是把FFT中的“复数单位根”换成了“模意义下的单位根”，结构完全一致，只是“数域”不同。FFT主要存在3方面问题：用的是复数、有浮点误差、在密码学/大整数/精确多项式运算中不可接受，而NTT正好可以解决这些问题。NTT工作空间是有限域，通常选F<em><sub>p</sub></em>，<em>p</em>是素数，所有运算都基于mod <em>p</em>，在NTT中，需要找ω（模p下的n次原始单位根），它满足：</p>\n<p><img alt=\"image\" height=\"34\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129161753182-2114601709.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"527\" /></p>\n<p>设模数p，n|(p-1)，ω是n次原始单位根，NTT相关定义如下：</p>\n<p><img alt=\"image\" height=\"201\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129162400466-958332138.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"473\" /></p>\n<p>和FFT相关对比如下：</p>\n<p><img alt=\"image\" height=\"229\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129162541142-569885544.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"668\" /></p>\n<h1>2 算法实现</h1>\n<p>理解了FFT的数学原理后，我们需要将其转化为可执行的代码。FFT算法有多种实现方式，包括递归实现、迭代实现和基于特定平台的优化实现。</p>\n<h2>2.1 递归实现FFT</h2>\n<p>递归实现是最直观的FFT实现方式，它直接对应Cooley-Tukey算法的分治思想。递归算法不断将问题分解为更小的子问题，直到达到基本情况（2点或1点DFT）。</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_ffe0d173-e88c-4224-89a8-11075c1c927d\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_ffe0d173-e88c-4224-89a8-11075c1c927d\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_ffe0d173-e88c-4224-89a8-11075c1c927d\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> numpy as np\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> matplotlib.pyplot as plt\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设置字体，确保中文显示</span>\nplt.rcParams[<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">font.sans-serif</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>] = [<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">SimHei</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">]\nplt.rcParams[</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">axes.unicode_minus</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>] =<span style=\"color: rgba(0, 0, 0, 1);\"> False\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> fft_recursive(x):\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\n    递归实现快速傅里叶变换\n    注意：输入向量x的长度必须是2的幂次\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    n </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> len(x)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> n == 1<span style=\"color: rgba(0, 0, 0, 1);\">:\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> x\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 分别计算偶数索引和奇数索引元素的FFT</span>\n    even_fft = fft_recursive(x[0::2])  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 偶数索引</span>\n    odd_fft = fft_recursive(x[1::2])   <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 奇数索引</span>\n    \n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算旋转因子</span>\n    w = [np.exp(-2j * np.pi * k / n) <span style=\"color: rgba(0, 0, 255, 1);\">for</span> k <span style=\"color: rgba(0, 0, 255, 1);\">in</span> range(n//2<span style=\"color: rgba(0, 0, 0, 1);\">)]\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 组合结果</span>\n    result = np.zeros(n, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">complex)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> k <span style=\"color: rgba(0, 0, 255, 1);\">in</span> range(n//2<span style=\"color: rgba(0, 0, 0, 1);\">):\n        term </span>= w[k] *<span style=\"color: rgba(0, 0, 0, 1);\"> odd_fft[k]\n        result[k] </span>= even_fft[k] +<span style=\"color: rgba(0, 0, 0, 1);\"> term\n        result[k </span>+ n//2] = even_fft[k] -<span style=\"color: rgba(0, 0, 0, 1);\"> term\n        \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> result\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 测试递归FFT</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> test_fft_recursive():\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成测试信号：50Hz和120Hz正弦波的叠加</span>\n    fs = 1000  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 采样频率1000Hz</span>\n    t = np.linspace(0, 1, 1024)  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1秒时间，1024个点</span>\n    signal = np.sin(2 * np.pi * 50 * t) + 0.5 * np.sin(2 * np.pi * 120 *<span style=\"color: rgba(0, 0, 0, 1);\"> t)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算FFT</span>\n    fft_result =<span style=\"color: rgba(0, 0, 0, 1);\"> fft_recursive(signal)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算频率轴</span>\n    freqs = np.fft.fftfreq(len(signal), 1/<span style=\"color: rgba(0, 0, 0, 1);\">fs)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span><span style=\"color: rgba(0, 0, 0, 1);\">(len(freqs))\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 绘制结果</span>\n    plt.figure(figsize=(12, 4<span style=\"color: rgba(0, 0, 0, 1);\">))\n    \n    plt.subplot(</span>1, 2, 1<span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.plot(t, signal)\n    plt.title(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">原始信号</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.xlabel(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">时间 (s)</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.ylabel(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">幅度</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    plt.subplot(</span>1, 2, 2<span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.plot(freqs[:len(freqs)</span>//2], np.abs(fft_result[:len(fft_result)//2<span style=\"color: rgba(0, 0, 0, 1);\">]))\n    plt.title(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">频谱图</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.xlabel(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">频率 (Hz)</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.ylabel(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">幅度</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.xlim(0, </span>200<span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    plt.tight_layout()\n    plt.show()\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> <span style=\"color: rgba(128, 0, 128, 1);\">__name__</span> == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">__main__</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n    test_fft_recursive()</span></pre>\n</div>\n<span class=\"cnblogs_code_collapse\">递归FFT</span></div>\n<p>程序中以50Hz和120Hz正弦波叠加产生测试信号，通过FFT变换可以这两个信号快速的过滤出来：</p>\n<p><img alt=\"image\" height=\"364\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260129174352141-1064981846.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"939\" /></p>\n<p>递归实现虽然直观，但存在一些缺点：</p>\n<p>1. 递归调用会产生额外的函数调用开销</p>\n<p>2. 需要不断创建新的子数组，内存使用不够高效</p>\n<p>3. 对于大数组，可能导致递归深度过大</p>\n<p>因此，在实际应用中，迭代实现通常更受青睐。</p>\n<h2>2.2 迭代实现FFT</h2>\n<p>迭代FFT算法通过循环而非递归实现计算，效率更高。迭代算法的核心是首先对输入数组进行位反序排列，然后通过多层循环实现蝶形运算。首先以n=8为例，看下<em>X<sub>0</sub></em>的重排序，由于ω<sup>0</sup>=1则根据DFT公式可知：</p>\n<p><img alt=\"image\" height=\"93\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260130173927906-1454035592.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"532\" /></p>\n<p>观察以下二进制下标，可知重排序后的二进制下标正是正序下标二进制的逆序，把这种序列叫做逆二进制序：</p>\n<div class=\"cnblogs_code\">\n<pre> 0   4   2   6   1   5   3   7\n000 100 010 110 001 101 011 111\n\n000 001 010 011 100 101 110 111<span style=\"color: rgba(0, 0, 0, 1);\">\n 0   </span>1   2   3   4   5   6   7</pre>\n</div>\n<p>同理可以给出<em>X<sub>1</sub></em>及<em>X<sub>4</sub></em>=<em>X<sub>0+8/2</sub></em>的迭代计算过程：</p>\n<p><img alt=\"image\" height=\"288\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260130173556716-1214216164.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"638\" /></p>\n<p><em>X<sub>0</sub></em>和<em>X<sub>4</sub></em>完全对应迭代公式（1），实际上所有<em>X<sub>k</sub></em>计算过程可以由以下二叉树给出：</p>\n<p><img alt=\"binary_tree\" height=\"214\" src=\"https://img2024.cnblogs.com/blog/465567/202601/465567-20260130171140920-240111198.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"616\" /></p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_1cf16b4b-2e15-4529-ab65-a62ba19cd246\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_1cf16b4b-2e15-4529-ab65-a62ba19cd246\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_1cf16b4b-2e15-4529-ab65-a62ba19cd246\">\n<pre><span style=\"color: rgba(0, 128, 128, 1);\">  1</span> <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> numpy as np\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  2</span> <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> matplotlib.pyplot as plt\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  3</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">  4</span> <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设置字体，确保中文显示</span>\n<span style=\"color: rgba(0, 128, 128, 1);\">  5</span> plt.rcParams[<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">font.sans-serif</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>] = [<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">SimHei</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">]\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  6</span> plt.rcParams[<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">axes.unicode_minus</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>] =<span style=\"color: rgba(0, 0, 0, 1);\"> False\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  7</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">  8</span> <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> bit_reverse(n, num_bits):\n</span><span style=\"color: rgba(0, 128, 128, 1);\">  9</span>     <span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">将n的二进制表示进行位反序</span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 10</span>     reversed_n =<span style=\"color: rgba(0, 0, 0, 1);\"> 0\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 11</span>     <span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(num_bits):\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 12</span>         <span style=\"color: rgba(0, 0, 255, 1);\">if</span> n &amp; (1 &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> i):\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 13</span>             reversed_n |= (1 &lt;&lt; (num_bits - 1 -<span style=\"color: rgba(0, 0, 0, 1);\"> i))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 14</span>     <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> reversed_n\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 15</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 16</span> <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> fft_iterative(x):\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 17</span>     <span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 18</span> <span style=\"color: rgba(128, 0, 0, 1);\">    迭代实现快速傅里叶变换\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 19</span> <span style=\"color: rgba(128, 0, 0, 1);\">    输入x的长度必须是2的幂次\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 20</span>     <span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 21</span>     n =<span style=\"color: rgba(0, 0, 0, 1);\"> len(x)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 22</span>     num_bits =<span style=\"color: rgba(0, 0, 0, 1);\"> int(np.log2(n))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 23</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 24</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 位反序排列</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 25</span>     reversed_index = [bit_reverse(i, num_bits) <span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(n)]\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 26</span>     data =<span style=\"color: rgba(0, 0, 0, 1);\"> x[reversed_index].astype(complex)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 27</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 28</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 迭代计算FFT</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 29</span>     size = 2\n<span style=\"color: rgba(0, 128, 128, 1);\"> 30</span>     <span style=\"color: rgba(0, 0, 255, 1);\">while</span> size &lt;=<span style=\"color: rgba(0, 0, 0, 1);\"> n:\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 31</span>         half_size = size // 2\n<span style=\"color: rgba(0, 128, 128, 1);\"> 32</span>         <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算旋转因子</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 33</span>         w_m = np.exp(-2j * np.pi /<span style=\"color: rgba(0, 0, 0, 1);\"> size)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 34</span>         \n<span style=\"color: rgba(0, 128, 128, 1);\"> 35</span>         <span style=\"color: rgba(0, 0, 255, 1);\">for</span> k <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(0, n, size):\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 36</span>             w = 1\n<span style=\"color: rgba(0, 128, 128, 1);\"> 37</span>             <span style=\"color: rgba(0, 0, 255, 1);\">for</span> j <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(half_size):\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 38</span>                 t = w * data[k + j +<span style=\"color: rgba(0, 0, 0, 1);\"> half_size]\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 39</span>                 u = data[k +<span style=\"color: rgba(0, 0, 0, 1);\"> j]\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 40</span>                 data[k + j] = u +<span style=\"color: rgba(0, 0, 0, 1);\"> t\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 41</span>                 data[k + j + half_size] = u -<span style=\"color: rgba(0, 0, 0, 1);\"> t\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 42</span>                 w *=<span style=\"color: rgba(0, 0, 0, 1);\"> w_m\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 43</span>         size *= 2\n<span style=\"color: rgba(0, 128, 128, 1);\"> 44</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 45</span>     <span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> data\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 46</span> \n<span style=\"color: rgba(0, 128, 128, 1);\"> 47</span> <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 测试迭代FFT</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 48</span> <span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> test_fft_iterative():\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 49</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成测试信号</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 50</span>     n = 256  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 数据点个数，必须是2的幂次</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 51</span>     fs = 1000  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 采样频率</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 52</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 53</span>     t = np.linspace(0, 1<span style=\"color: rgba(0, 0, 0, 1);\">, n)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 54</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成包含多个频率成分的信号</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 55</span>     signal = (np.sin(2 * np.pi * 50 * t) + \n<span style=\"color: rgba(0, 128, 128, 1);\"> 56</span>               0.5 * np.sin(2 * np.pi * 120 * t) + \n<span style=\"color: rgba(0, 128, 128, 1);\"> 57</span>               0.3 * np.sin(2 * np.pi * 200 *<span style=\"color: rgba(0, 0, 0, 1);\"> t))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 58</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 59</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 添加噪声</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 60</span>     noise = 0.2 * np.random.normal(size=<span style=\"color: rgba(0, 0, 0, 1);\">n)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 61</span>     signal +=<span style=\"color: rgba(0, 0, 0, 1);\"> noise\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 62</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 63</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算FFT</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 64</span>     fft_result =<span style=\"color: rgba(0, 0, 0, 1);\"> fft_iterative(signal)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 65</span>     freqs = np.fft.fftfreq(n, 1/<span style=\"color: rgba(0, 0, 0, 1);\">fs)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 66</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 67</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 与NumPy内置FFT对比</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 68</span>     np_fft =<span style=\"color: rgba(0, 0, 0, 1);\"> np.fft.fft(signal)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 69</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 70</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 绘制结果</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 71</span>     plt.figure(figsize=(15, 5<span style=\"color: rgba(0, 0, 0, 1);\">))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 72</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 73</span>     plt.subplot(1, 3, 1<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 74</span> <span style=\"color: rgba(0, 0, 0, 1);\">    plt.plot(t, signal)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 75</span>     plt.title(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">原始信号 (含噪声)</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 76</span>     plt.xlabel(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">时间 (s)</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 77</span>     plt.ylabel(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">幅度</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 78</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 79</span>     plt.subplot(1, 3, 2<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 80</span>     plt.plot(freqs[:n//2], np.abs(fft_result[:n//2]), label=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">自定义FFT</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 81</span>     plt.title(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">自定义FFT频谱</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 82</span>     plt.xlabel(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">频率 (Hz)</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 83</span>     plt.ylabel(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">幅度</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 84</span>     plt.xlim(0, 300<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 85</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 86</span>     plt.subplot(1, 3, 3<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 87</span>     plt.plot(freqs[:n//2], np.abs(np_fft[:n//2]), label=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">NumPy FFT</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>, color=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">orange</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 88</span>     plt.title(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">NumPy FFT频谱</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 89</span>     plt.xlabel(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">频率 (Hz)</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 90</span>     plt.ylabel(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">幅度</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 91</span>     plt.xlim(0, 300<span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 92</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 93</span> <span style=\"color: rgba(0, 0, 0, 1);\">    plt.tight_layout()\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 94</span> <span style=\"color: rgba(0, 0, 0, 1);\">    plt.show()\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 95</span>     \n<span style=\"color: rgba(0, 128, 128, 1);\"> 96</span>     <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算误差</span>\n<span style=\"color: rgba(0, 128, 128, 1);\"> 97</span>     error = np.max(np.abs(fft_result -<span style=\"color: rgba(0, 0, 0, 1);\"> np_fft))\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 98</span>     <span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">与NumPy FT的最大误差: {error}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n</span><span style=\"color: rgba(0, 128, 128, 1);\"> 99</span> \n<span style=\"color: rgba(0, 128, 128, 1);\">100</span> <span style=\"color: rgba(0, 0, 255, 1);\">if</span> <span style=\"color: rgba(128, 0, 128, 1);\">__name__</span> == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">__main__</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n</span><span style=\"color: rgba(0, 128, 128, 1);\">101</span>     test_fft_iterative()</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">迭代FFT</span></div>\n<p>仍以n=8为例，迭代算法中首先对输入进行二进制的逆序，然后进行3个阶段的蝶形计算，第1个阶段由相邻点产生下一级的输出，第2个阶段由间隔一个点的输入产生输出，第3个阶段由间隔两个点的输出产生输出，蝴蝶由瘦变胖，如下图所示：</p>\n<p><img alt=\"image\" height=\"539\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260203124707004-1989410463.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"970\" /></p>\n<h1>3 应用实例</h1>\n<h2>3.1 音频处理中的应用</h2>\n<p>FFT（快速傅里叶变换）是音频领域的核心数字信号处理工具，本质是将音频的时域信号（随时间变化的声波振幅）转换为频域信号（不同频率的声音分量占比），而人耳对声音的感知本身就是基于频率的（如音调、音色），这使得 FFT 成为音频采集、分析、处理、合成全链路的基础。</p>\n<h3>1 音频基础分析</h3>\n<p>所有音频智能分析的前提，核心是将不可直接解读的时域波形，转换为可量化的频率特征。</p>\n<p><strong>核心逻辑</strong></p>\n<p>（1）音频在计算机中是采样率固定的时域离散数据（如44.1kHz采样率 = 1秒采集44100个振幅值），波形仅能反映声音的强弱变化，无法直接得到音调、音色等关键信息；</p>\n<p>（2）对时域音频段执行一维 FFT，得到频谱（横坐标为频率，纵坐标为对应频率的振幅/能量），频谱直接反映 “哪些频率的声音构成了当前音频”；</p>\n<p>（3）针对非平稳音频（声音频率随时间变化，如说话、唱歌、乐器演奏），采用STFT（短时傅里叶变换）：将音频切分为连续的短帧（如20ms/帧），对每帧独立做FFT，最终得到时频图（横轴时间，纵轴频率，颜色 / 亮度表示能量），实现 “时间-频率” 的二维分析。</p>\n<p><strong>典型应用</strong></p>\n<p>音频软件的频谱分析仪（如 Audition、Cool Edit）：实时显示音频的频率分布，帮助调音师判断声音的频率缺陷；</p>\n<p>基础音频特征提取：通过 FFT 计算基频（Fundamental Frequency，F0）（声音的基础音调，如男声基频 80-200Hz，女声 200-500Hz）、谐波（基频的整数倍频率，决定音色）、频谱能量（决定声音响度）。</p>\n<h3>2 音调检测与音高识别（Pitch Detection）</h3>\n<p>音调是音频最核心的感知特征之一，FFT是实现音高识别的经典算法基础，广泛用于K歌评分、乐器校音、语音识别。</p>\n<p><strong>核心逻辑</strong></p>\n<p>（1）纯音（如钢琴单键）的时域波形是周期性的，其频域频谱中能量最高的频率即为基频（F0），对应听觉上的音调；</p>\n<p>（2）对乐器/人声的混合音频，通过FFT得到频谱后，筛选出基频峰（主峰值）和其谐波峰，通过峰值检测算法确定实际音高；</p>\n<p>（3）工程中会结合自相关法优化FFT的基频检测，解决低信噪比、谐波干扰下的检测误差问题。</p>\n<p><strong>典型应用</strong></p>\n<p>（1）乐器校音软件（如吉他校音器、钢琴校音器）：实时采集乐器声音，通过FFT检测基频，对比标准音高（如 A4=440Hz）给出校音提示；</p>\n<p>（2）K歌APP的音高评分（如唱吧、全民K歌）：实时分析演唱声音的基频，与原唱基频对比，判断音准并打分；</p>\n<p>（3）音乐乐谱自动转写：将演奏音频转换为五线谱，核心是通过 FFT 逐帧检测音高并匹配对应音符。</p>\n<h3>3&nbsp;音频滤波：精准去除噪声/保留目标频率</h3>\n<p>音频滤波是FFT最常用的处理类应用，相比传统的模拟滤波，基于FFT的频域滤波更灵活、精准，可实现任意自定义的频率筛选，核心是 “频域修改，时域重构”。</p>\n<p><strong>核心逻辑（与图像 FFT 压缩原理同源）</strong></p>\n<p>（1）时域→频域：对音频帧执行 FFT，得到频域系数；</p>\n<p>（2）频域滤波：根据需求生成频率掩码，对频域系数做修改：&nbsp; &nbsp;</p>\n<p>&nbsp; &nbsp; 低通滤波：保留低频系数，置零高频系数（如去除音频中的高频嘶嘶噪声）；</p>\n<p>&nbsp; &nbsp; 高通滤波：保留高频系数，置零低频系数（如去除音频中的低频底噪、电流声）；</p>\n<p><em>&nbsp; &nbsp;&nbsp;</em>带通滤波：仅保留指定频率区间的系数（如提取人声音频，保留 300-3400Hz 的人声核心频率）；</p>\n<p>&nbsp; &nbsp; 带阻滤波 / 陷波滤波：置零指定频率区间的系数（如去除 50Hz/60Hz 的市电工频噪声）；</p>\n<p>（3）频域→时域：对滤波后的频域系数执行逆 FFT（IFFT），转换回时域音频，得到滤波后的声音。</p>\n<p><strong>典型应用</strong></p>\n<p>（1）语音降噪（如会议录音、麦克风降噪）：通过FFT去除背景中的低频底噪、高频环境噪声，保留人声；</p>\n<p>（2）音乐制作中的均衡器（EQ）：对音乐的低频、中频、高频分别做增益 / 衰减（本质是修改FFT后的频域系数振幅），调整音乐的音色层次；</p>\n<p>（3）广播/直播的音频处理：过滤掉人声外的无效频率，提升声音的清晰度。</p>\n<h3>4&nbsp;声音合成与音色模拟（加法合成 / 调频合成）</h3>\n<p>声音的音色由“基频+谐波的频率分布比例”决定，FFT为音色的量化和合成提供了基础，是电子音乐、语音合成的核心技术之一。</p>\n<p><strong>核心逻辑</strong></p>\n<p>（1）音色的频域本质：不同乐器的同一音调（基频相同），音色不同的原因是谐波的数量、振幅占比不同（如钢琴的谐波丰富且高频衰减快，小提琴的高频谐波更突出）；</p>\n<p>（2）加法合成：通过 FFT 分析目标乐器的频谱（基频 + 各谐波的能量比例），然后用多个正弦波（对应基频和各谐波）按该比例叠加，合成出与目标乐器相似的音色；</p>\n<p>（3）语音合成（TTS）：对真人语音做 FFT 分析，得到不同音节的频谱特征，合成时通过调整基频和频谱分布，生成自然的人工语音。</p>\n<p><strong>典型应用</strong></p>\n<p>（1）电子音乐合成器（如FL Studio、Ableton Live）：基于 FFT 的频谱分析，模拟钢琴、吉他、弦乐等传统乐器的音色，或制作自定义的电子音色；</p>\n<p>（2）语音合成引擎（如讯飞TTS、百度TTS）：通过 FFT 提取语音的频谱特征，提升合成语音的自然度；</p>\n<p>（3）声音特效制作：如将人声转换为机器人声（通过FFT修改频谱，压制谐波，保留基频）。</p>\n<h3>5&nbsp;音频特征提取与智能分析（AI / 机器学习基础）</h3>\n<p>当下的音频智能应用（如语音识别、声纹识别、音频分类），其核心特征均基于 FFT 的频域分析，FFT 是连接原始音频数据和 AI 模型的桥梁。</p>\n<p><strong>核心逻辑</strong></p>\n<p>（1）原始时域音频数据维度高、冗余大，无法直接输入AI模型；</p>\n<p>（2）通过 FFT/STFT 将音频转换为频域特征，再进一步提取梅尔频谱（Mel Spectrogram）、梅尔频率倒谱系数（MFCC） 等工程化特征：</p>\n<p>&nbsp; &nbsp; 梅尔频谱：将 FFT 得到的线性频谱转换为符合人耳听觉特性的梅尔刻度频谱（人耳对低频更敏感，对高频更迟钝）；</p>\n<p>&nbsp; &nbsp; MFCC：对梅尔频谱做离散余弦变换（DCT），提取的低维系数，是语音识别、声纹识别的经典核心特征；</p>\n<p>（3）这些频域特征维度低、辨识度高，是语音识别、音频分类模型的标准输入。</p>\n<p><strong>典型应用</strong></p>\n<p>（1）语音识别（ASR）：如微信语音转文字、讯飞听见，核心特征是MFCC，其提取基础是FFT/STFT；</p>\n<p>（2）声纹识别：如手机声纹解锁、银行语音验证，通过 FFT 分析不同人的语音频谱特征（声纹），实现身份识别；</p>\n<p>（3）音频分类：如短视频的背景音乐识别、环境声检测（如哭声、玻璃破碎声、汽车鸣笛声），基于梅尔频谱做模型训练，而梅尔频谱的基础是FFT；</p>\n<p>（4）音乐推荐：通过FFT分析歌曲的频谱特征（如低频能量占比、节奏对应的频率变化），对歌曲做分类，实现个性化推荐。</p>\n<h3>6&nbsp;音频同步与匹配（如音频指纹、音视频同步）</h3>\n<p>（1）音频指纹（Audio Fingerprint）</p>\n<p>核心是通过FFT对音频的时频特征做提取，生成唯一的 “音频指纹”，实现音乐识别、音频查重。如摇一摇识曲（QQ音乐、网易云音乐），通过FFT提取待识别音频的时频特征，与服务器中的音频指纹库匹配，快速识别歌曲名称。</p>\n<p>（2）音视频同步</p>\n<p>视频的画面帧与音频的时间轴易出现错位，通过FFT分析音频的频谱特征变化，与视频的画面特征变化做时间对齐，实现音视频同步校正。</p>\n<h2>3.2&nbsp;图像处理中的应用</h2>\n<p>FFT在图像处理中主要用于频域滤波、图像压缩、纹理分析等。接下来以图像压缩为例进行说明。</p>\n<p>图像在计算机中以像素矩阵存储，这是空间域表示：每个数值代表对应位置的亮度/颜色，直观描述图像的空间分布，但数据冗余度高。频域是通过傅里叶变换得到的另一种表示形式，将图像分解为不同频率的正弦/余弦波叠加，频率描述的是像素值的变化快慢：</p>\n<p><strong>低频分量：</strong>像素值变化缓慢，对应图像的整体轮廓、大面积平滑区域、主体结构（如人脸轮廓、天空背景）；</p>\n<p><strong>高频分量：</strong>像素值变化剧烈，对应图像的细节纹理、边缘、噪声、微小瑕疵（如发丝、文字边缘、噪点）。</p>\n<p>人眼的视觉特性与图像频域特性高度匹配：</p>\n<p>人眼对整体轮廓、大面积区域（低频信息）高度敏感，是识别图像的核心依据；</p>\n<p>人眼对精细纹理、微小噪声（高频信息）敏感度较低，适度舍弃后，肉眼难以察觉明显失真；</p>\n<p>结合这一特性，FFT 压缩可以在保证主观视觉质量的前提下，实现可观的数据压缩。举个例子：一张风景照，蓝天、山脉轮廓是低频核心信息，树叶纹理、水面波纹是高频信息，舍弃 80% 高频系数后，图像依然可清晰识别，仅会轻微模糊。</p>\n<p>图像是二维信号，需要使用二维离散傅里叶变换（2D-DFT）完成空间域到频域的转换，FFT图像压缩的本质是利用频域能量分布的不对称性，实现有损数据压缩，完整逻辑分为4个核心步骤：</p>\n<p><strong>步骤 1：空间域 → 频域转换（FFT）</strong></p>\n<p>对图像（或图像分块）执行二维FFT，将像素值转换为频域系数（复数形式，包含幅度和相位信息）。变换后，默认低频系数分布在频域矩阵的四角，高频在中心；通过fftshift中心化后，低频集中在矩阵中心，高频分布在四周，方便筛选处理。</p>\n<p><strong>步骤 2：频域系数量化与截断（核心压缩操作）</strong></p>\n<p>基于能量集中特性执行压缩操作：</p>\n<p>（1）保留携带绝大部分图像能量的低频系数；</p>\n<p>（2）直接舍弃/置零仅携带少量细节、噪声的高频系数；</p>\n<p>（3）舍弃的高频信息越多，压缩率越高，图像失真越明显。</p>\n<p>一般通过计算频域点到中心的欧式距离筛选低频系数，距离中心越近，频率越低，这是最常用的低频筛选方式。</p>\n<p><strong>步骤 3：逆变换重构图像（逆 FFT）</strong></p>\n<p>对处理后的频域系数执行逆移位（ifftshift）+ 逆FFT（ifft2），将频域信号转换回空间域，得到压缩重构后的图像。由于逆 FFT 结果会存在微小虚部（浮点计算误差），只需提取实部即可得到有效像素值。</p>\n<p><strong>步骤 4：数据存储优化</strong></p>\n<p>原始图像存储每个像素的空间域数据，而压缩后仅需存储少量保留的低频系数，大幅减少数据量，实现存储/传输的压缩效果。</p>\n<p>以下是源码：</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_564b0e2b-3c0a-40e5-9f1d-bc59a1cd04b7\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_564b0e2b-3c0a-40e5-9f1d-bc59a1cd04b7\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_564b0e2b-3c0a-40e5-9f1d-bc59a1cd04b7\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> numpy as np\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> matplotlib.pyplot as plt\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> matplotlib.image as mpimg\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> os\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> math <span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> log10, sqrt\n</span><span style=\"color: rgba(0, 0, 255, 1);\">from</span> PIL <span style=\"color: rgba(0, 0, 255, 1);\">import</span> Image  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 新增：用PIL保存图像，兼容所有版本</span>\n\n<span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 设置中文显示</span>\nplt.rcParams[<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">font.sans-serif</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>] = [<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">SimHei</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">]\nplt.rcParams[</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">axes.unicode_minus</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span>] =<span style=\"color: rgba(0, 0, 0, 1);\"> False\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">def</span><span style=\"color: rgba(0, 0, 0, 1);\"> psnr(original, compressed):\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">计算峰值信噪比（PSNR），兼容彩色/灰度图</span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 若原始图像是彩色图，先转为灰度图再计算PSNR</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> len(original.shape) == 3<span style=\"color: rgba(0, 0, 0, 1);\">:\n        original_gray </span>= np.mean(original, axis=2<span style=\"color: rgba(0, 0, 0, 1);\">).astype(np.uint8)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        original_gray </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> original.astype(np.uint8)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 确保压缩后图像是uint8类型</span>\n    compressed =<span style=\"color: rgba(0, 0, 0, 1);\"> compressed.astype(np.uint8)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算MSE（均方误差）</span>\n    mse = np.mean((original_gray - compressed) ** 2<span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> mse == 0:  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 无误差</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span> float(<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">inf</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    max_pixel </span>= 255.0<span style=\"color: rgba(0, 0, 0, 1);\">\n    psnr_value </span>= 20 * log10(max_pixel /<span style=\"color: rgba(0, 0, 0, 1);\"> sqrt(mse))\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> psnr_value\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> fft_image_compress(image, block_size=8, keep_ratio=0.1<span style=\"color: rgba(0, 0, 0, 1);\">):\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">基于FFT的图像压缩（自动处理彩色/灰度图）</span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 彩色图转灰度图（压缩只处理灰度，保留核心逻辑）</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> len(image.shape) == 3<span style=\"color: rgba(0, 0, 0, 1);\">:\n        image_gray </span>= np.mean(image, axis=2<span style=\"color: rgba(0, 0, 0, 1);\">).astype(np.uint8)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        image_gray </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> image.astype(np.uint8)\n    \n    h, w </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> image_gray.shape\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2. 补零使图像尺寸为block_size的整数倍</span>\n    pad_h = (block_size - h % block_size) %<span style=\"color: rgba(0, 0, 0, 1);\"> block_size\n    pad_w </span>= (block_size - w % block_size) %<span style=\"color: rgba(0, 0, 0, 1);\"> block_size\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">h {} w {} pad_h {} pad_w {}</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">.format(h, w, pad_h, pad_w))\n    image_padded </span>= np.pad(image_gray, ((0, pad_h), (0, pad_w)), mode=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">constant</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    h_pad, w_pad </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> image_padded.shape\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 初始化压缩后的频域数组</span>\n    fft_compressed = np.zeros_like(image_padded, dtype=<span style=\"color: rgba(0, 0, 0, 1);\">np.complex128)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4. 分块FFT+高频截断</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">for</span> i <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(0, h_pad, block_size):\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> j <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> range(0, w_pad, block_size):\n            block </span>= image_padded[i:i+block_size, j:j+<span style=\"color: rgba(0, 0, 0, 1);\">block_size]\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2D-FFT：空间域→频域（中心化，低频移到中心）</span>\n            fft_block = np.fft.fft2(block)                  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对图像块做二维 FFT，将空间域的像素值转换为频域的复数系数（低频默认在四角，高频在中心</span>\n            fft_block_shifted = np.fft.fftshift(fft_block)  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将频域系数 “中心化”，把低频系数移到频域矩阵的中心，高频系数分布在四周，方便后续筛选低频</span>\n            \n            <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算需要保留的低频系数数量</span>\n            total_coeffs = block_size * block_size          <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 单个图像块的总系数数（等于像素数）</span>\n            keep_coeffs = int(total_coeffs * keep_ratio)    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 预设的保留比例（如0.1表示保留10%的系数）</span>\n            keep_coeffs = max(keep_coeffs, 1)               <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 防止保留系数为0，保证至少保留1个低频系数，避免重构失败</span>\n            \n            <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成掩码：只保留低频系数，高频置0</span>\n            center = block_size // 2                        <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 频域矩阵的中心坐标（如 block_size=8 时，center=4）</span>\n            y, x = np.ogrid[:block_size, :block_size]       <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成网格坐标矩阵，对应每个系数在频域中的位置</span>\n            distance = np.sqrt((y - center)**2 + (x - center)**2)   <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算每个系数到中心的欧式距离（距离越小，频率越低）</span>\n            flat_distance = distance.flatten()              <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将距离矩阵展平为一维数组，方便排序</span>\n            idx = np.argsort(flat_distance)[:keep_coeffs]   <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对距离从小到大排序，取前keep_coeffs个索引（对应距离中心最近的低频系数）</span>\n            mask_flat = np.zeros(total_coeffs, dtype=bool)  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成布尔掩码mask：维度与图像块一致</span>\n            mask_flat[idx] = True                           <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> mask中True的位置对应保留的低频系数，False对应舍弃的高频系数</span>\n            mask =<span style=\"color: rgba(0, 0, 0, 1);\"> mask_flat.reshape((block_size, block_size))\n            \n            </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 应用掩码：高频系数置零</span>\n            fft_block_shifted[~mask] = 0    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> ~mask：取掩码的反（False变True，True变False），即高频系数的位置。</span>\n                                            <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将频域矩阵中高频系数的位置置为 0，只保留低频系数，实现 “压缩”（丢弃高频信息）</span>\n            \n            <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 逆移位+逆FFT：频域→空间域</span>\n            fft_block = np.fft.ifftshift(fft_block_shifted) <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 逆中心化，将频域系数恢复到 FFT 后的原始位置（低频回到四角）</span>\n            ifft_block = np.fft.ifft2(fft_block)            <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 对处理后的频域系数做逆 FFT，转换回空间域（结果为复数）</span>\n            block_recon = np.real(ifft_block)               <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 取复数的实部（因舍入误差可能有微小虚部，需剔除），得到重构后的图像块像素值</span>\n            \n            <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 存入压缩后数组</span>\n            fft_compressed[i:i+block_size, j:j+block_size] = block_recon <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将重构后的图像块放回fft_compressed数组的对应位置，最终拼接成完整的压缩后图像</span>\n    \n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 5. 去除补零，恢复原始尺寸</span>\n    compressed_image =<span style=\"color: rgba(0, 0, 0, 1);\"> fft_compressed[:h, :w]\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 限制像素值范围（0~255），避免溢出</span>\n    compressed_image = np.clip(compressed_image, 0, 255<span style=\"color: rgba(0, 0, 0, 1);\">).astype(np.uint8)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 6. 计算压缩比（频域系数层面）</span>\n    total_original_coeffs = h_pad *<span style=\"color: rgba(0, 0, 0, 1);\"> w_pad\n    total_keep_coeffs </span>= (h_pad * w_pad) *<span style=\"color: rgba(0, 0, 0, 1);\"> keep_ratio\n    compression_ratio </span>= total_original_coeffs /<span style=\"color: rgba(0, 0, 0, 1);\"> total_keep_coeffs\n    \n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> compressed_image, compression_ratio\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">def</span> save_image_with_quality(image, path, quality=95<span style=\"color: rgba(0, 0, 0, 1);\">):\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\n    兼容所有版本的图像保存函数，支持设置JPG质量\n    :param image: 灰度图像数组（uint8，0~255）\n    :param path: 保存路径（如\"test.jpg\"）\n    :param quality: JPG质量（0~100，值越小压缩越狠）\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"\"\"</span>\n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将numpy数组转为PIL Image对象</span>\n    pil_img =<span style=\"color: rgba(0, 0, 0, 1);\"> Image.fromarray(image)\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保存为JPG，设置质量参数</span>\n    pil_img.save(path, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">JPEG</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, quality=<span style=\"color: rgba(0, 0, 0, 1);\">quality)\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 主函数：测试FFT图像压缩</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">if</span> <span style=\"color: rgba(128, 0, 128, 1);\">__name__</span> == <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">__main__</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 读取图像（替换为你的图像路径）</span>\n    image_path = <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">1.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>  <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 支持彩色/灰度图</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">try</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        original_image </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> mpimg.imread(image_path)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 注意：matplotlib读取的图像像素值是0~1的浮点数，需转回0~255</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> original_image.dtype ==<span style=\"color: rgba(0, 0, 0, 1);\"> np.float32:\n            original_image </span>= (original_image * 255<span style=\"color: rgba(0, 0, 0, 1);\">).astype(np.uint8)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">except</span><span style=\"color: rgba(0, 0, 0, 1);\"> FileNotFoundError:\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">错误：未找到图像文件，自动生成测试灰度图...</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 生成512×512渐变灰度图作为测试</span>\n        original_image = np.linspace(0, 255, 512*512).reshape(512, 512<span style=\"color: rgba(0, 0, 0, 1);\">).astype(np.uint8)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2. 执行FFT压缩（调整keep_ratio控制压缩比）</span>\n    compressed_image, compress_ratio =<span style=\"color: rgba(0, 0, 0, 1);\"> fft_image_compress(\n        original_image, block_size</span>=8, keep_ratio=0.1<span style=\"color: rgba(0, 0, 0, 1);\">\n    )\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 计算PSNR（修复维度不匹配问题）</span>\n    psnr_value =<span style=\"color: rgba(0, 0, 0, 1);\"> psnr(original_image, compressed_image)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 4. 保存图像（改用PIL，支持quality参数，兼容所有版本）</span>\n    <span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保存原图（转灰度后保存，统一对比基准）</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> len(original_image.shape) == 3<span style=\"color: rgba(0, 0, 0, 1);\">:\n        original_gray </span>= np.mean(original_image, axis=2<span style=\"color: rgba(0, 0, 0, 1);\">).astype(np.uint8)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        original_gray </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> original_image\n    save_image_with_quality(original_gray, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">original_gray.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, quality=95<span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 保存压缩后图像，设置JPG质量（值越小文件越小）</span>\n    save_image_with_quality(compressed_image, <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">compressed_final.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>, quality=50<span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 5. 计算实际文件大小（KB）</span>\n    original_size = os.path.getsize(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">original_gray.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>) / 1024 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> os.path.exists(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">original_gray.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>) <span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> 0\n    compressed_size </span>= os.path.getsize(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">compressed_final.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>) / 1024 <span style=\"color: rgba(0, 0, 255, 1);\">if</span> os.path.exists(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">compressed_final.jpg</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>) <span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> 0\n    actual_compression_ratio </span>= original_size / compressed_size <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (compressed_size &gt; 0 <span style=\"color: rgba(0, 0, 255, 1);\">and</span> original_size &gt; 0) <span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\"> 0\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 6. 显示结果</span>\n    plt.figure(figsize=(12, 6<span style=\"color: rgba(0, 0, 0, 1);\">))\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 原图（彩色/灰度自适应显示）</span>\n    plt.subplot(1, 2, 1<span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> len(original_image.shape) == 3<span style=\"color: rgba(0, 0, 0, 1);\">:\n        plt.imshow(original_image)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">else</span><span style=\"color: rgba(0, 0, 0, 1);\">:\n        plt.imshow(original_image, cmap</span>=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">gray</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.title(f</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">原始图像\\n尺寸：{original_image.shape[1]}×{original_image.shape[0]}\\n大小：{original_size:.2f} KB</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.axis(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">off</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 压缩后图像（灰度）</span>\n    plt.subplot(1, 2, 2<span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.imshow(compressed_image, cmap</span>=<span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">gray</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.title(f</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">FFT压缩后图像\\n理论压缩比：{compress_ratio:.1f}:1\\n实际文件压缩比：{actual_compression_ratio:.1f}:1\\nPSNR：{psnr_value:.2f} dB</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    plt.axis(</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(128, 0, 0, 1);\">off</span><span style=\"color: rgba(128, 0, 0, 1);\">'</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    \n    plt.tight_layout()\n    plt.show()\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">#</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印详细信息</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">=== 压缩结果 ===</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">理论频域压缩比：{compress_ratio:.1f}:1</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">实际文件压缩比：{actual_compression_ratio:.1f}:1</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">原始文件大小：{original_size:.2f} KB</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">压缩后文件大小：{compressed_size:.2f} KB</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">print</span>(f<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">PSNR（图像质量）：{psnr_value:.2f} dB</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>)</pre>\n</div>\n<span class=\"cnblogs_code_collapse\">图像压缩</span></div>\n<p>程序运行效果如下：</p>\n<p><img alt=\"image\" height=\"510\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260203102142852-1233020511.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"762\" /></p>\n<p>因为运行结果显示分辨率不高，看起来压缩后的图片和原图并没有太大的不同，但是将图片放大以后还是可以明显看出压缩后图片的失真：</p>\n<p><img alt=\"image\" height=\"354\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260203102615726-1795473578.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"503\" /></p>\n<h1>参考：</h1>\n<p>1&nbsp;<a href=\"https://zhuanlan.zhihu.com/p/19763358\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/19763358</a></p>\n<p>2&nbsp;<a href=\"https://www.cnblogs.com/xxeray/p/fast-fourier-transform.html\" target=\"_blank\">https://www.cnblogs.com/xxeray/p/fast-fourier-transform.html</a></p>\n<p>3&nbsp;<a href=\"https://blog.csdn.net/qq_42212808/article/details/156030009\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/qq_42212808/article/details/156030009</a></p>\n<p>4&nbsp;<a href=\"https://zhuanlan.zhihu.com/p/350616936\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/350616936</a></p>\n<p>5&nbsp;<a href=\"https://www.cnblogs.com/zwfymqz/p/8244902.html\" target=\"_blank\">https://www.cnblogs.com/zwfymqz/p/8244902.html</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 14:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zhaoweiwei\">weiwei22844</a>&nbsp;\n阅读(<span id=\"post_view_count\">162</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "前特斯拉 AI 总监：AI 编程最大的谎言，是 “提效”",
      "link": "https://www.cnblogs.com/yupi/p/19568098",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19568098\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 11:08\">\n    <span>前特斯拉 AI 总监：AI 编程最大的谎言，是 “提效”</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"前特斯拉 AI 总监：AI 编程最大的谎言，是 “提效”\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202602/2225420-20260203102512118-1547421356.png\" />\n        前两天，前特斯拉 AI 总监 Andrej Karpathy 在 X 上发了一条长帖子，内容是他最近几周大量使用 Claude 编程的感悟。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-heading\"><span class=\"md-plain\">大家好，我是程序员鱼皮。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">前两天，前特斯拉 AI 总监 Andrej Karpathy 在 X 上发了一条长帖子，内容是他最近几周大量使用 Claude 编程的感悟。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">结果这条帖子直接爆了，阅读量超过 600 万。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">先简单介绍一下『卡帕西』这位大佬：斯坦福 AI 博士，师从李飞飞；OpenAI 创始成员之一；后来去特斯拉当了 AI 总监，负责自动驾驶的视觉系统。2024 年离开特斯拉后，他创办了 Eureka Labs，专注用 AI 做教育。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不夸张地说，他可能是全球最懂 AI、又最能写代码的人之一。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在 2023 年 1 月的时候，他就提出过：未来最热门的新编程语言是自然语言。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你现在回过头来看这句话，就知道这哥们有多牛皮了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">所以我每次看他分享的内容时，都会先沐浴更衣，让自己能够进入深度思考状态。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">进入正题，这条帖子里有很多干货，但让我印象最深的是这句话：</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我不太清楚如何衡量 AI 带来的加速。我感觉做事确实快了，<span class=\"md-pair-s \"><strong>但主要的效果是我做的比原计划多得多</strong><span class=\"md-plain\">。</span></span></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">卡帕西说，现在他可以随手写一些以前 “不值得写” 的小工具，也敢去碰以前因为技术栈不熟而不敢碰的代码了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>所以 AI 编程带来的核心变化不是加速，而是扩展。</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我觉得这个观察太准了！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">之前很多人问我：AI 编程能提效多少倍？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">其实这个问题本身就问错了。AI 带来的真正变化不是 “同一件事做得更快”，而是 “你开始做以前根本不会做的事”。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这就像你以前骑自行车，现在换了辆车。你不会说自己骑车快了 10 倍，而是会说自己能去更远的地方了。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">人比不过 AI 的一点</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">帖子里还有几个点挺有意思的，跟大家分享一下。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">卡帕西说，看 AI 在一个 Bug 上死磕 30 分钟，不放弃、不气馁，最后真的搞定了 —— 这是他感受 AGI 的时刻。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我看到这段就想起自己大学刚学编程时改 Bug 的经历。已经是凌晨一两点，试了好几种方法都没用，我的心态已经崩了，甚至有点儿心绞痛，于是想着明天再说吧，狗命要紧……</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但 AI 不会这样，只要你的 Tokens 足够，它会一直跟 Bug 死磕。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>耐力这件事，正在从人类的瓶颈变成 AI 的优势。</strong></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">当然，代价就是烧 Token。所以程序员的基本功还是很重要的，至少你得能判断这个 Bug 值不值得让 AI 花半小时去磕，怎么通过指引 AI 让它更快更省地解决问题。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">编程变得更有趣了？</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">卡帕西说：用 AI 编程之后，那些填空式的苦差事没了，剩下的都是创造性的部分。所以反而觉得更好玩了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但他也提到，有些程序员会觉得失去了乐趣。因为对他们来说，写代码本身就是快感来源。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这可能是一个分水岭：<span class=\"md-pair-s \"><strong>主要享受 “写代码” 的人，和主要享受 “造东西” 的人，体验会很不一样。</strong></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我看到一位 AI 圈的大 V 把这点称为 “程序员正在分裂成两个物种”。不过我倒觉得，这两类人其实一直都存在。有的人享受代码本身的优雅，追求技术的深度和细节，写出漂亮的代码会有成就感；有的人更在乎东西能不能跑起来、能不能解决问题，代码只是实现想法的工具。AI 只是把这个差异放大了而已 —— 前者可能会有点失落，后者则迎来了黄金时代。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">我正在失去写代码的能力，但是…</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">卡帕西说：自己手动写代码的能力正在慢慢退化。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但是从他的话中能感受到，他对此的态度是 “已经不太在乎了”。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">他给了一个有意思的视角，写代码（生成）和读代码（判别）是大脑里不同的能力。就像你可能写不出一首好诗，但能看出一首诗写得好不好。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">编程也是一样。其实想想看，以前没有 AI 的时候，那些语法细节、API 用法，我们不也是靠查文档、利用编辑器的提示吗？真正需要记在脑子里的从来就不多。现在 AI 把这部分接管了，但代码的设计思路对不对、架构合不合理，还是得靠你自己判断。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">所以未来程序员的角色，可能更像是 “技术导演” 而不是 “码农”。你负责把控方向、做出决策，AI 负责执行细节、填补空白。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">2026 年垃圾内容会爆发，但是…</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">卡帕西还提到了一个词：<span class=\"md-pair-s\"><code>Slopacolypse</code></span></span></p>\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain md-expand\">我搜了一下，发现这其实是最近 AI 圈流行起来的一个 “slop 系列” 造词。Slop 指的是那些用 AI 批量生成的低质量内容，Slopacolypse 就是 Slop + Apocalypse，我理解是 “垃圾内容末日” 的意思。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">他预测 2026 年，GitHub、各种社交媒体都会被 AI 生成的低质量内容淹没。当生产内容的门槛大幅降低，注意力反而会变得更稀缺。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但他也说，真正的改进也在同步发生。AI 的智能部分已经跑在前面了，现在反而是工具、流程、组织这些东西还没跟上。<span class=\"md-pair-s \"><strong>2026 年，整个行业会花大量精力去消化这波新能力。</strong></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">说到这里，我想起自己身边的情况。AI 领域几乎每天都有新工具、新模型、新玩法冒出来，但真正意识到这些变化、真正去用这些新东西的人，又有多少呢？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我经常听到有人说 “再等几个月，等出了更好的再学”、“现在的还不够成熟”。但问题是，在你等待的这几个月里，已经有人用 AI 做出了以前做不到的东西，拉开了差距。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">所以对于我们程序员来说，一方面必须要利用 AI 提升开发效率和优化工作流程。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">另外一方面，不妨打开思路，多想一想：<span class=\"md-pair-s \"><strong>有了 AI，你能做到哪些以前做不到的事？</strong></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">以前不敢碰的技术栈，现在敢试了；以前觉得不值得做的小工具，现在随手就能搞定；以前卡住就放弃的 bug，现在有个不知疲倦的助手帮你死磕。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这才是 AI 编程真正的红利 —— <span class=\"md-pair-s \"><strong>不是让你更快，是让你更大。</strong></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果你还没开始用 AI 编程，或者想系统学习怎么用的更好，可以看看我最新免费开源的 <span class=\"md-meta-i-c  md-link\"><a href=\"https://github.com/liyupi/ai-guide\" rel=\"noopener nofollow\"><span class=\"md-plain\">《AI 编程零基础入门教程》</span></a><span class=\"md-plain\">，从 0 开始带你用 AI 编程做出项目，包含各种工具用法、实战技巧、编程资源、甚至是产品变现经验全都有。希望能帮你更快地拥抱这个新时代，一起变得更大、更强！</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c md-link\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 11:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">552</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "DTS按业务场景批量迁移阿里云MySQL表实战（下）：迁移管理平台设计与实现",
      "link": "https://www.cnblogs.com/wuyuegb2312/p/19571685",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wuyuegb2312/p/19571685\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 22:34\">\n    <span>DTS按业务场景批量迁移阿里云MySQL表实战（下）：迁移管理平台设计与实现</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>本文是 <a href=\"https://www.cnblogs.com/wuyuegb2312/p/19566555\" target=\"_blank\">DTS按业务场景批量迁移阿里云MySQL表实战（上）：技术选型和API对接</a>  的后续，应用状态模式，完成业务系统中的迁移模块。DTS的对接方式可参考前文。</p>\n<h1 id=\"迁移管理平台设计与实现\">迁移管理平台设计与实现</h1>\n<p>完成DTS API对接后，就需要考虑如何将DTS和业务系统有机结合实现整套的迁移流程。</p>\n<p>出于信息安全角度的考虑，本文删除了大量涉及实际业务的实现代码。</p>\n<h2 id=\"业务约束\">业务约束</h2>\n<p>从业务出发，最好的体验肯定是用户无感的，即迁移完成后，确认新旧表数据一致，直接切换到新表查询。</p>\n<p>显然过于理想化了，如果迁移期间，用户对旧表进行了写入，新表可能会少数据，不能贸然切换，要做数据的对比。如果用户一直在写入，就要一直反复的对比、确认，有增量数据就要删除新表重新迁移，流程复杂。</p>\n<p>和业务方沟通，得知对方可以禁止写入正在迁移的公司的表，等迁移完成后再恢复使用。这样流程就简单多了，开始迁移时，将旧表重命名增加特殊的后缀，就能防止用户操作，并确保旧表数据不发生变更。</p>\n<h2 id=\"技术校验\">技术校验</h2>\n<p>如何判断一个公司是否迁移成功？最严谨的方式是逐表逐行数据对比，但是在使用DTS的情况下并无必要。我采取的比较策略是，在迁移前后：</p>\n<ol>\n<li>\n<p>源表目标表数量相同</p>\n</li>\n<li>\n<p>对应表数据量相同、数据最后更新时间（如有此列）相同</p>\n</li>\n</ol>\n<p>只要满足以上要求，就认为数据是一致的。可以通过SELECT COUNT(*), MAX(updateTime) FROM table_name一次性获取。</p>\n<h2 id=\"迁移状态机\">迁移状态机</h2>\n<p>经过分析和简化，迁移状态机如下：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/228024/202602/228024-20260203223055533-1166349172.png\" /></p>\n<p>可以发现，每个状态都可以进行“推进”和“回滚”两个动作，很适合使用状态模式来实现。状态模式的实现先放一放，看看几个基本数据结构：</p>\n<h2 id=\"迁移任务\">迁移任务</h2>\n<pre><code class=\"language-Java\">@Data\npublic class TableMigrateTask {\n  // 主键\n  private Long id;\n  // 公司id\n  private Long companyId;\n  // 原始分库位\n  private Long oldSchemaId;\n  // 新分库位\n  private Long newSchemaId;\n  // 任务状态\n  private Integer state;\n  // DTS任务状态，和阿里云定义一致\n  private String dtsStatus;\n  // DTS任务已删除（释放）\n  private Boolean dtsDeleted;\n  // DTS实例id\n  private String dtsInstanceId;\n  // DTS任务id\n  private String dtsJobId;\n  // 失败原因\n  private String failedReason;\n  // 状态跳转时的信息，辅助排查问题\n  private String transitInfo;\n  // 迁移前表数据统计，json格式，表名、数据量、最后更新时间\n  private String tableStatisticsSrc;\n  // 迁移表结果统计，json格式kv结构，表名-数据量\n  private String tableStatisticsDest;\n}\n</code></pre>\n<h2 id=\"迁移上下文\">迁移上下文</h2>\n<p>迁移状态机实际处理的对象，封装了一些服务，可以视为领域对象（充血模型）。</p>\n<pre><code class=\"language-Java\">@Setter\npublic class TableMigrateExecuteContext {\n\n  // 持有的任务对象\n  @Getter\n  private TableMigrateTask tableMigrateTask;\n\n  // 当前的状态\n  @Getter\n  private TableMigrateState currentState;\n\n  private TableMigrateTaskRepository tableMigrateTaskRepository;\n\n  private TableMigrateQueryService tableMigrateQueryService;\n\n  private TableMigrateService tableMigrateService;\n\n  private TableArchiveService tableArchiveService;\n\n  private DataSourceHolder dataSourceHolder;\n\n  public void createInstanceAndConfigureDtsJob() {\n      // 调用DTS API创建任务\n  }\n\n  public DescribeDtsJobDetailResponse queryDtsMigJob() {\n      // 调用DTS API查询\n  }\n\n  public void switchRoute(long oldSchemaId, long newSchemaId) {\n      // 将分表以外的单表update为newSchemaId\n  }\n\n  public void stopDtsMigJob() {\n      // 调用DTS API停止\n  }\n\n  public void updateTableMigrateTask(TableMigrateTask modifiedTask) {\n       // 更新持有的任务(持久化)\n  }\n\n  /**\n   * 状态推进\n   *\n   * @return 返回信息，不成功时非空\n   */\n  public String forward() {\n    return currentState.forward(this);\n  }\n\n  /** 状态回滚 */\n  public String rollback() {\n    return currentState.rollback(this);\n  }\n\n  /**\n   * 重命名旧表\n   *\n   * @param forward true-迁移场景，加——migold，反之则不加\n   * @param ignoreExited 是否忽略已存在的表，仅在初始态的回滚场景可用\n   */\n  public void renameOldTableNames(boolean forward, boolean ignoreExited) {\n      // 注意要考虑源库中是否存在和旧表相同的同名表\n  }\n\n\n  public void updateDestTableInfo() {\n     // 更新目标表的统计信息\n  }\n\n  public void archiveNewTables(List&lt;String&gt; needArchiveTables) {\n      // 归档新表  \n  }\n\n  /**\n   * 删除表\n   *\n   * @param newTable true-新表，false-旧表\n   */\n  public void deleteTables(boolean newTable) {\n      // 批量执行DROP TABLE\n  }\n\n  public void deleteDtsInstanceAndJob() {\n      // 调用DTS API释放实例\n  }\n}\n</code></pre>\n<h3 id=\"工厂类\">工厂类</h3>\n<pre><code class=\"language-Java\">@Component\npublic class TableMigrateContextFactory {\n\n  @Resource private TableMigrateTaskRepository tableMigrateTaskRepository;\n  @Resource private TableMigrateQueryService tableMigrateQueryService;\n  @Resource private TableMigrateService tableMigrateService;\n  @Resource private TableArchiveService tableArchiveService;\n  @Resource private DataSourceHolder dataSourceHolder;\n\n  public TableMigrateExecuteContext buildContext(long taskId) {\n    TableMigrateTask task = tableMigrateTaskRepository.getById(taskId);\n    if (task == null || task.getStatus() == 0) {\n      throw new BizException(\"表迁移任务不存在或已被删除\");\n    }\n    TableMigrateExecuteContext context = new TableMigrateExecuteContext();\n    context.setTableMigrateTask(task);\n    context.setCurrentState(buildState(TableMigrateStateEnum.getByValue(task.getState())));\n\n    // 服务注入\n    context.setTableMigrateTaskRepository(tableMigrateTaskRepository);\n    context.setTableMigrateQueryService(tableMigrateQueryService);\n    context.setTableMigrateService(tableMigrateService);\n    context.setTableArchiveService(tableArchiveService);\n    context.setDataSourceHolder(dataSourceHolder);\n    return context;\n  }\n\n  private TableMigrateState buildState(TableMigrateStateEnum stateEnum) {\n    switch (stateEnum) {\n      case INIT:\n        return new MigrateInitState();\n      case FAILED:\n        return new MigrateFailedState();\n      case PROCESSING:\n        return new MigrateProcessingState();\n      case NEED_SWITCH:\n        return new MigrateNeedSwitchState();\n      case SWITCHED:\n        return new MigrateSwitchedState();\n      case FINISH:\n        return new MigrateFinishState();\n      default:\n        throw new BizException(\"迁移状态非法\");\n    }\n  }\n}\n</code></pre>\n<h2 id=\"迁移状态\">迁移状态</h2>\n<p>我在做本次的系统设计时，对状态模式做了一些回顾和参考。迁移状态是状态模式的核心，从设计模式的角度来看，状态模式“允许对象在其内部状态改变时动态调整自身行为，使得对象的表现形态如同修改了其所属类。”</p>\n<p>以下是各个类的继承关系：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/228024/202602/228024-20260203223122974-1126879955.png\" /></p>\n<p>对应的状态如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>类名</td>\n<td>含义</td>\n<td>说明</td>\n</tr>\n<tr>\n<td>TableMigrateState</td>\n<td>接口定义</td>\n<td></td>\n</tr>\n<tr>\n<td>AbstractMigrateState</td>\n<td>状态抽象类</td>\n<td></td>\n</tr>\n<tr>\n<td>AbstractFinalState</td>\n<td>终态抽象类</td>\n<td>终态很多操作都是不支持的，和AbstractMigrateState分开更简洁</td>\n</tr>\n<tr>\n<td>MigrateInitState</td>\n<td>初始</td>\n<td>记录要迁移的统计数据和配置</td>\n</tr>\n<tr>\n<td>MigrateProcessingState</td>\n<td>迁移中</td>\n<td>DTS进行迁移动作的状态</td>\n</tr>\n<tr>\n<td>MigrateNeedSwitchState</td>\n<td>迁移完成待切换分库位</td>\n<td>数据已同步在新表，但还不可以通过业务功能直接访问</td>\n</tr>\n<tr>\n<td>MigrateSwitchedState</td>\n<td>分库位已切换待删除旧表</td>\n<td>数据已同步在新表，且能通过业务功能直接访问</td>\n</tr>\n<tr>\n<td>MigrateFinishState</td>\n<td>迁移完成</td>\n<td>数据已同步在新表且能访问，旧表已删除</td>\n</tr>\n<tr>\n<td>MigrateFailedState</td>\n<td>迁移失败</td>\n<td>回滚，旧表恢复访问，新表如果有则删除</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"状态接口\">状态接口</h3>\n<pre><code class=\"language-Java\">public interface TableMigrateState {\n\n  /**\n   * 前进到下一状态\n   *\n   * @param context\n   * @return 失败的提示信息\n   */\n  String forward(TableMigrateExecuteContext context);\n\n  /**\n   * 回滚操作\n   *\n   * @param context\n   * @return 失败的提示信息\n   */\n  String rollback(TableMigrateExecuteContext context);\n\n  /**\n   * 获取当前的状态对应枚举\n   */\n  TableMigrateStateEnum getState();\n\n  /**\n   * 获取下一个状态\n   */\n  TableMigrateState getNextState();\n\n  /**\n   * 获取回滚的状态\n   */\n  TableMigrateState getRollbackState();\n}\n</code></pre>\n<h3 id=\"状态抽象类\">状态抽象类</h3>\n<pre><code class=\"language-TypeScript\">public abstract class AbstractMigrateState implements TableMigrateState {\n\n  @Override\n  public String forward(TableMigrateExecuteContext context) {\n    TableMigrateTask task = context.getTableMigrateTask();\n\n    // 1. 前置校验\n    // 根据校验结果，判断是留在当前状态，还是直接回滚到迁移失败状态\n\n    // 2. 实际动作，由实现类完成\n   // 简单起见，在实际动作里的异常都自动回滚\n\n    // 3. 状态跳转\n    transit(context, getNextState());\n    return null;\n  }\n\n  @Override\n  public String rollback(TableMigrateExecuteContext context) {\n    TableMigrateTask task = context.getTableMigrateTask();\n    // 1. 当前状态校验\n    checkCurrentState(context);\n\n    // 2. 回滚操作，如果发生异常，保持在当前状态\n\n    // 3. 状态跳转\n    transit(context, getRollbackState());\n    return null;\n  }\n\n  /**\n   * 前置校验\n   *\n   * @param context\n   */\n  protected PreCheckResult preCheck(TableMigrateExecuteContext context) {\n    return checkCurrentState(context);\n  }\n\n  protected PreCheckResult checkCurrentState(TableMigrateExecuteContext context) {\n      // 检查当前状态是否符合预期，构造检查结果\n  }\n\n  /**\n   * 改变当前执行上下文状态, 不做其他的业务操作\n   *\n   * @param context\n   * @param nextState\n   */\n  private void transit(TableMigrateExecuteContext context, TableMigrateState nextState) {\n    TableMigrateTask task = context.getTableMigrateTask();\n    task.setState(nextState.getState().getValue());\n    context.updateTableMigrateTask(task);\n    context.setCurrentState(nextState);\n  }\n  \n  protected abstract void doForward(TableMigrateExecuteContext context);\n\n  /**\n   * 回滚操作\n   *\n   * &lt;p&gt;需要保证幂等，如果单个回滚操作失败，可以重复执行\n   *\n   * @param context\n   */\n  protected abstract void doRollback(TableMigrateExecuteContext context);\n\n  /**\n   * 旧表更名\n   *\n   * @param context\n   * @param forward true-迁移场景，旧表加后缀; false-回滚场景，旧表删除后缀\n   */\n  protected void renameOldTableNames(\n      TableMigrateExecuteContext context, boolean forward, boolean ignoreExited) {\n    context.renameOldTableNames(forward, ignoreExited);\n  }\n\n  /**\n   * 删除新表\n   *\n   * &lt;p&gt;新表的删除，最好不要共用这个方法\n   *\n   * @param context\n   */\n  protected void deleteNewTables(TableMigrateExecuteContext context) {\n    context.deleteTables(true);\n  }\n\n  /** 前置校验结果 */\n  @Data\n  @AllArgsConstructor\n  public static class PreCheckResult {\n    /** 中断，需要回滚 */\n    public static final int ABORT = -1;\n\n    /** 校验通过 */\n    public static final int PASS = 0;\n\n    /** 校验不通过，保持原有状态 */\n    public static final int NOT_PASS = 1;\n\n    private int code;\n\n    private String msg;\n\n    public static PreCheckResult buildPass() {\n      return new PreCheckResult(PASS, null);\n    }\n\n    public boolean isPass() {\n      return this.code == PASS;\n    }\n  }\n}\n</code></pre>\n<h3 id=\"终态抽象类\">终态抽象类</h3>\n<pre><code class=\"language-TypeScript\">public abstract class AbstractFinalState implements TableMigrateState {\n  @Override\n  public String forward(TableMigrateExecuteContext context) {\n    return \"当前状态【\" + getState().getValue() + \" \" + getState().getDes() + \"】已是终态，不能进行下一步操作\";\n  }\n\n  @Override\n  public String rollback(TableMigrateExecuteContext context) {\n    return \"当前状态【\" + getState().getValue() + \" \" + getState().getDes() + \"】已是终态，不能进行撤销操作\";\n  }\n\n  @Override\n  public TableMigrateState getNextState() {\n    throw new BizException(\"当前状态\" + getState().getValue() + \"已是终态，没有后续状态可跳转\");\n  }\n\n  @Override\n  public TableMigrateState getRollbackState() {\n    throw new BizException(\"当前状态\" + getState().getValue() + \"已是终态，没有后续撤销态可跳转\");\n  }\n}\n</code></pre>\n<h3 id=\"初始\">初始</h3>\n<pre><code class=\"language-TypeScript\">public class MigrateInitState extends AbstractMigrateState {\n  @Override\n  protected void doForward(TableMigrateExecuteContext context) {\n    TableMigrateTask task = context.getTableMigrateTask();\n    if (task.getOldSchemaId().equals(task.getNewSchemaId())) {\n      throw new BizException(\"迁移前后的分库位id相同\");\n    }\n\n    // 1. 旧表更名, 直接阻止后续的变更\n    // 归档不影响RENAME\n    renameOldTableNames(context, true, false);\n\n    // 2. 创建DTS任务并回写到task字段\n    // 创建失败则直接抛异常，回滚\n    // 此处DTS任务是直接提交执行的，并不能确定当前实际是哪个状态，因此状态留空\n    context.createInstanceAndConfigureDtsJob();\n  }\n  \n  @Override\n  protected void doRollback(TableMigrateExecuteContext context) {\n    // 初始态回滚时，旧表可能还没有更名\n    renameOldTableNames(context, false, true);\n  }\n\n  @Override\n  public TableMigrateStateEnum getState() {\n    return TableMigrateStateEnum.INIT;\n  }\n\n  @Override\n  public TableMigrateState getNextState() {\n    return new MigrateProcessingState();\n  }\n\n  @Override\n  public TableMigrateState getRollbackState() {\n    return new MigrateFailedState();\n  }\n}\n</code></pre>\n<h3 id=\"迁移中\">迁移中</h3>\n<pre><code class=\"language-TypeScript\">public class MigrateProcessingState extends AbstractMigrateState {\n\n  /** DTS-未初始化的状态 */\n  private static final Set&lt;String&gt; DTS_NOT_INIT =\n      Sets.newHashSet(\n          DtsJobStatusEnum.NOT_STARTED.getCode(), DtsJobStatusEnum.NOT_CONFIGURED.getCode());\n\n  /** DTS-处理中的状态 */\n  private static final Set&lt;String&gt; DTS_PROCESSING =\n      Sets.newHashSet(\n          DtsJobStatusEnum.PRECHECKING.getCode(),\n          DtsJobStatusEnum.PRECHECK_PASS.getCode(),\n          DtsJobStatusEnum.INITIALIZING.getCode(),\n          DtsJobStatusEnum.SYNCHRONIZING.getCode(),\n          DtsJobStatusEnum.MIGRATING.getCode(),\n          DtsJobStatusEnum.SUSPENDING.getCode(),\n          DtsJobStatusEnum.MODIFYING.getCode(),\n          DtsJobStatusEnum.RETRYING.getCode(),\n          DtsJobStatusEnum.UPGRADING.getCode(),\n          DtsJobStatusEnum.DOWNGRADING.getCode(),\n          DtsJobStatusEnum.LOCKED.getCode());\n\n  /** DTS-失败的状态 */\n  private static final Set&lt;String&gt; DTS_FAILED =\n      Sets.newHashSet(\n          DtsJobStatusEnum.PRECHECK_FAILED.getCode(),\n          DtsJobStatusEnum.INITIALIZE_FAILED.getCode(),\n          DtsJobStatusEnum.FAILED.getCode(),\n          DtsJobStatusEnum.MIGRATION_FAILED.getCode());\n\n  @Override\n  public PreCheckResult preCheck(TableMigrateExecuteContext context) {\n    checkCurrentState(context);\n    // 校验DTS任务已完成\n    TableMigrateTask task = context.getTableMigrateTask();\n    DescribeDtsJobDetailResponse dtsJobDetailResponse = context.queryDtsMigJob();\n    if (dtsJobDetailResponse == null || dtsJobDetailResponse.getBody() == null) {\n      return new PreCheckResult(\n          PreCheckResult.NOT_PASS,\n          String.format(\n              \"DTS任务结果查询失败, 返回结果为空。instanceId=%s, jobId=%s\",\n              task.getDtsInstanceId(), task.getDtsJobId()));\n    }\n    DescribeDtsJobDetailResponseBody responseBody = dtsJobDetailResponse.getBody();\n    if (BooleanUtils.isNotTrue(responseBody.getSuccess())) {\n      return new PreCheckResult(\n          PreCheckResult.NOT_PASS,\n          String.format(\n              \"DTS任务结果查询失败, 接口调用结果为失败。instanceId=%s, jobId=%s\",\n              task.getDtsInstanceId(), task.getDtsJobId()));\n    }\n    DtsJobStatusEnum dtsJobStatusEnum = DtsJobStatusEnum.getByCode(responseBody.getStatus());\n    if (dtsJobStatusEnum == null) {\n      return new PreCheckResult(\n          PreCheckResult.NOT_PASS,\n          String.format(\n              \"DTS任务状态非法，请稍后重试。instanceId=%s, jobId=%s, 阿里云状态=%s\",\n              task.getDtsInstanceId(), task.getDtsJobId(), responseBody.getStatus()));\n    }\n    task.setDtsStatus(dtsJobStatusEnum.getCode());\n    if (DTS_NOT_INIT.contains(dtsJobStatusEnum.getCode())) {\n      return new PreCheckResult(\n          PreCheckResult.NOT_PASS,\n          String.format(\n              \"DTS任务状态异常，尚未初始化。instanceId=%s, jobId=%s, 阿里云状态=%s\",\n              task.getDtsInstanceId(), task.getDtsJobId(), responseBody.getStatus()));\n    }\n    if (DTS_PROCESSING.contains(dtsJobStatusEnum.getCode())) {\n      return new PreCheckResult(\n          PreCheckResult.NOT_PASS,\n          String.format(\n              \"DTS任务仍在处理中。instanceId=%s, jobId=%s, 阿里云状态=%s\",\n              task.getDtsInstanceId(), task.getDtsJobId(), responseBody.getStatus()));\n    }\n    if (DTS_FAILED.contains(dtsJobStatusEnum.getCode())) {\n      return new PreCheckResult(\n          PreCheckResult.ABORT,\n          String.format(\n              \"DTS任务执行失败。instanceId=%s, jobId=%s, 阿里云状态=%s\",\n              task.getDtsInstanceId(), task.getDtsJobId(), responseBody.getStatus()));\n    }\n    if (StringUtils.equals(DtsJobStatusEnum.FINISHED.getCode(), dtsJobStatusEnum.getCode())) {\n      return PreCheckResult.buildPass();\n    }\n    return new PreCheckResult(\n        PreCheckResult.NOT_PASS,\n        String.format(\n            \"DTS任务状态非法。instanceId=%s, jobId=%s, 阿里云状态=%s\",\n            task.getDtsInstanceId(), task.getDtsJobId(), responseBody.getStatus()));\n  }\n\n  @Override\n  protected void doForward(TableMigrateExecuteContext context) {\n    // 已在校验时更新任务状态，并根据DTS执行状态判断要不要回滚\n\n    // 1. 将迁移后的表，按照原表的状态进行归档\n\n    // 2. 写入迁移后的表统计信息\n    context.updateDestTableInfo();\n  }\n\n  @Override\n  protected void doRollback(TableMigrateExecuteContext context) {\n    // 1. 尝试中止DTS任务，对已完成的DTS任务调用不会抛异常\n\n    // 2. 新表删除\n    deleteNewTables(context);\n\n    // 3. 旧表名称还原\n    renameOldTableNames(context, false, false);\n  }\n\n  @Override\n  public TableMigrateStateEnum getState() {\n    return TableMigrateStateEnum.PROCESSING;\n  }\n\n  @Override\n  public TableMigrateState getNextState() {\n    return new MigrateNeedSwitchState();\n  }\n\n  @Override\n  public TableMigrateState getRollbackState() {\n    return new MigrateFailedState();\n  }\n}\n</code></pre>\n<h3 id=\"迁移完成待切换分库位\">迁移完成待切换分库位</h3>\n<pre><code class=\"language-TypeScript\">public class MigrateNeedSwitchState extends AbstractMigrateState {\n\n  @Override\n  protected void doForward(TableMigrateExecuteContext context) {\n    // 单表路由切换\n    context.switchRoute(\n        context.getTableMigrateTask().getOldSchemaId(),\n        context.getTableMigrateTask().getNewSchemaId());\n  }\n\n  @Override\n  protected void doRollback(TableMigrateExecuteContext context) {\n    // 1. 新表删除\n    deleteNewTables(context);\n\n    // 2. 旧表名称还原\n    renameOldTableNames(context, false, false);\n\n    // 3. 单表和路由恢复\n    // 可能已经在forward时做过，因此也做复原\n    context.switchRoute(\n        context.getTableMigrateTask().getNewSchemaId(),\n        context.getTableMigrateTask().getOldSchemaId());\n  }\n\n  @Override\n  public TableMigrateStateEnum getState() {\n    return TableMigrateStateEnum.NEED_SWITCH;\n  }\n\n  @Override\n  public TableMigrateState getNextState() {\n    return new MigrateSwitchedState();\n  }\n\n  @Override\n  public TableMigrateState getRollbackState() {\n    return new MigrateFailedState();\n  }\n}\n</code></pre>\n<h3 id=\"分库位已切换待删除旧表\">分库位已切换待删除旧表</h3>\n<pre><code class=\"language-TypeScript\">public class MigrateSwitchedState extends AbstractMigrateState {\n\n  @Override\n  protected void doForward(TableMigrateExecuteContext context) {\n    // 删除旧表\n    context.deleteTables(false);\n  }\n\n  @Override\n  protected void doRollback(TableMigrateExecuteContext context) {\n    // 1. 新表删除\n    deleteNewTables(context);\n\n    // 2. 旧表名称还原\n    renameOldTableNames(context, false, false);\n\n    // 3. 单表和路由恢复\n    context.switchRoute(\n        context.getTableMigrateTask().getNewSchemaId(),\n        context.getTableMigrateTask().getOldSchemaId());\n  }\n\n  @Override\n  public TableMigrateStateEnum getState() {\n    return TableMigrateStateEnum.SWITCHED;\n  }\n\n  @Override\n  public TableMigrateState getNextState() {\n    return new MigrateFinishState();\n  }\n\n  @Override\n  public TableMigrateState getRollbackState() {\n    return new MigrateFailedState();\n  }\n}\n</code></pre>\n<h3 id=\"迁移完成\">迁移完成</h3>\n<pre><code class=\"language-Java\">public class MigrateFinishState extends AbstractFinalState {\n  @Override\n  public TableMigrateStateEnum getState() {\n    return TableMigrateStateEnum.FINISH;\n  }\n}\n</code></pre>\n<h3 id=\"迁移失败\">迁移失败</h3>\n<pre><code class=\"language-Java\">public class MigrateFailedState extends AbstractFinalState {\n  @Override\n  public TableMigrateStateEnum getState() {\n    return TableMigrateStateEnum.FAILED;\n  }\n}\n</code></pre>\n<h2 id=\"操作流程\">操作流程</h2>\n<ol>\n<li>\n<p>创建迁移任务TableMigrateTask</p>\n</li>\n<li>\n<p>通过工厂类，使用任务id创建包含迁移任务TableMigrateTask的迁移上下文TableMigrateExecuteContext</p>\n</li>\n<li>\n<p>调用TableMigrateExecuteContext的forward()推进状态、rollback()回滚状态</p>\n</li>\n</ol>\n<h2 id=\"查询相关功能实现\">查询相关功能实现</h2>\n<h3 id=\"dts任务列表查询\">DTS任务列表查询</h3>\n<p>因为已经把DTS的相关字段持久化了，可以通过业务系统相关的迁移任务表实现分页查询。</p>\n<p>不过在“迁移中”跳转到“迁移完成待切换分库位”的过程中，DTS也会经历多个状态，典型的有Prechecking、Migrating、Finished等（见<a href=\"https://next.api.aliyun.com/document/Dts/2020-01-01/DescribeDtsJobDetail\" rel=\"noopener nofollow\" target=\"_blank\">DescribeDtsJobDetail_数据传输_API文档</a>的Status字段说明），可以通过接口获取最新的状态并写入迁移任务表。</p>\n<h3 id=\"如何查询待迁移的表\">如何查询待迁移的表？</h3>\n<p>回顾一下，要迁移的表分以下三种形式：</p>\n<ul>\n<li>\n<p>后缀是公司id，如table_companyId</p>\n</li>\n<li>\n<p>后缀是 公司_年份，如table_company_year</p>\n</li>\n<li>\n<p>后缀是业务id，如table_bizId</p>\n</li>\n</ul>\n<p>对于同一个前缀，以companyId=123为例，第一、三种表都可以精确匹配：</p>\n<ul>\n<li>\n<p>第一种表每个公司只有一张，比如table_a_123、table_b_123；</p>\n</li>\n<li>\n<p>第三种表每个bizId同一个公司只有一张，比如bizId可以取1、2，那么会存在table_c_1、table_c_2、table_d_1、table_d_2，并且，bizId是有限的，可以从一张bizId_table表获取所有可选值。</p>\n</li>\n<li>\n<p>对于第二种表year的取值范围，虽然可以类似bizId一样去找，但是并没有直接的关系表。</p>\n</li>\n</ul>\n<p>我想到了两种方案，最后选择了第二种。</p>\n<h4 id=\"show-tables-like查询指定前缀\">SHOW TABLES LIKE查询指定前缀</h4>\n<p>这是最先考虑到的方案，比较直接，而且在开发、测试环境中运行良好。但是在线上就不行了，将所有表查询一次要数分钟，调用早已超时。我想这应该和线上环境表数量过多导致元数据获取变慢有关，每次查询需要上百ms，累计耗时长达数分钟。</p>\n<h4 id=\"databasemetadata一次性获取所有表后过滤\">DatabaseMetaData一次性获取所有表后过滤</h4>\n<p>可以通过DataSource的元数据，一次性获取数据源对应库的所有的表，再将表名进行过滤。经过测试，10W级数据获取全部表的时间在3~7S之间，和方案一相比快很多。</p>\n<p>以下代码片段展示了如何获取所有表名，忽略异常处理。</p>\n<pre><code class=\"language-Java\">String physicalSchemaName = dataSourceHolder.getPhysicalSchemaName(logicalSchemaName);\nHikariDataSource dataSource = dataSourceHolder.getDataSourceByPhysicalSchemaName(physicalSchemaName);\ntry (Connection connection = dataSource.getConnection()) {\n    DatabaseMetaData metaData = connection.getMetaData();\n    ResultSet catalogs = metaData.getCatalogs();\n    while (catalogs.next()) {\n        String tableCat = catalogs.getString(\"TABLE_CAT\");\n        if (!StringUtils.equals(tableCat, physicalSchemaName)) {\n            // 判断库名是否一致。如果多个库实际上在同一个RDS实例，元数据实际上是这些库的，而非单个库的\n            continue;\n        }\n\n        // 获取指定数据库中的所有表名\n        ResultSet tableResultSet =\n            metaData.getTables(physicalSchemaName, null, \"%\", new String[] {\"TABLE\"});\n        int count = 0;\n        while (tableResultSet.next()) {\n          count++;\n          String physicalTableName = tableResultSet.getString(\"TABLE_NAME\");\n          // 确定是否是要查的表，判断逻辑此处省略【注1】\n         }\n        LoggerUtils.info(\"本次共查询了\" + count + \"个表的元数据\");\n      }\n      LoggerUtils.info(\n          \"获取\" + physicalSchemaName + \"库的所有表元数据总耗时：\" + (System.currentTimeMillis() - t1) + \"ms\");\n    } catch (SQLException e) {\n      LoggerUtils.error(\"获取分库元数据失败, 发生SQL异常\", e);\n      throw new BizException(\"获取分库元数据失败, 发生SQL异常\", e);\n    }\n}\n</code></pre>\n<p>对数据库中每个表判定它是否是当前公司的表，对于第一、三种表，可以将后者放到一个HashSet中，每次循环时对比；对于第二种表，字符串前缀匹配无疑要花大量的时间。</p>\n<p>为了加速前缀匹配，可以使用经典的数据结构——前缀匹配树。前缀匹配树的代码如下：</p>\n<pre><code class=\"language-Java\">public class StringPrefixTrie {\n  private final Node root = new Node();\n\n  static class Node {\n    boolean isEnd;\n    Map&lt;Character, Node&gt; children = new HashMap&lt;&gt;();\n  }\n\n  /**\n   * 增加一个待匹配的模式\n   *\n   * @param pattern\n   */\n  public void addPattern(String pattern) {\n    Node current = root;\n    for (char c : pattern.toCharArray()) {\n      current = current.children.computeIfAbsent(c, k -&gt; new Node());\n    }\n    current.isEnd = true;\n  }\n\n  /**\n   * 是否满足前缀匹配\n   *\n   * @param str\n   * @return\n   */\n  public String match(String str) {\n    Node current = root;\n    for (int i = 0; i &lt; str.length(); i++) {\n      current = current.children.get(str.charAt(i));\n      if (current == null) {\n        // 没有匹配到任何前缀\n        return null;\n      }\n      if (current.isEnd) {\n        // 返回匹配到的任意一个前缀\n        return str.substring(0, i + 1);\n      }\n    }\n    return null;\n  }\n}\n</code></pre>\n<p>对所有需要前缀匹配的表的前缀调用addPattern()，在循环中先判断是否满足前缀匹配，再判断精准匹配即可。</p>\n<h2 id=\"后续规划\">后续规划</h2>\n<ol>\n<li>\n<p>批量迁移功能，将迁移批量化、自动化：</p>\n<ol>\n<li>\n<p>批量捞取公司，判断是否需要迁移、迁移成本。理想情况下，数据量少但表多的公司，是迁移到其他库的最佳候选，大大降低源库的表量又节约了复制数据的时间</p>\n</li>\n<li>\n<p>多个公司id提交、创建任务、状态流转</p>\n</li>\n</ol>\n</li>\n<li>\n<p>自动校验迁移是否成功</p>\n</li>\n</ol>\n\n\n</div>\n<div id=\"MySignature\">\n    <div id=\"AllanboltSignature\">\n        <p id=\"PSignature\">\n            <br />\n            作者：<a href=\"http://www.cnblogs.com/wuyuegb2312\" target=\"_blank\">五岳</a>\n            <br />\n            出处：<a href=\"http://www.cnblogs.com/wuyuegb2312\" target=\"_blank\">http://www.cnblogs.com/wuyuegb2312</a>\n            <br />\n            对于标题未标注为“转载”的文章均为原创，其版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。\n        </p>\n    　</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 22:34</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wuyuegb2312\">五岳</a>&nbsp;\n阅读(<span id=\"post_view_count\">1</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一种多选项的高效存取（存储、查询）解决方案",
      "link": "https://www.cnblogs.com/hackyle/p/19530712",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hackyle/p/19530712\" id=\"cb_post_title_url\" title=\"发布于 2026-02-03 22:26\">\n    <span>一种多选项的高效存取（存储、查询）解决方案</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在项目开发中，如何保存多选项的值呢？\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><strong>本文主要内容</strong></p>\n<ul>\n<li>对于多选项的值，<span style=\"color: rgba(224, 62, 45, 1);\">如何保存</span>？本文提供了一种非常规的方案。</li>\n<li>对于记录在数据库中的多选项的值，如何<span style=\"color: rgba(224, 62, 45, 1);\">快速查询</span>那些记录是包含了某个（某些）选项？本文使用了“与位运算”解决查询问题。</li>\n<li><strong>源码地址：https://github.com/HackyleShawe/JavaBackEndDemos/tree/master/BusinessCommonSolution/multi-options-storage-query-demo</strong></li>\n</ul>\n<p><strong>文章前置知识：</strong>SpringBoot、JDBCTemplate、位运算（与运算）、jQuery</p>\n<p><strong>内容导览&nbsp;</strong></p>\n<div class=\"mce-toc\">\n<ul>\n<li><a href=\"#mcetoc_1h68ttla31tr7\" rel=\"noopener nofollow\">背景</a></li>\n<li><a href=\"#mcetoc_1h68ttla31tr8\" rel=\"noopener nofollow\">设计思想</a>\n<ul>\n<li><a href=\"#mcetoc_1h68ttla31tr9\" rel=\"noopener nofollow\">编码：将多选项转换为数字</a>\n<ul>\n<li><a href=\"#mcetoc_1h68ttla31tra\" rel=\"noopener nofollow\">例1</a></li>\n<li><a href=\"#mcetoc_1h68ttla31trb\" rel=\"noopener nofollow\">例2</a></li>\n</ul>\n</li>\n<li><a href=\"#mcetoc_1h68ttla31trc\" rel=\"noopener nofollow\">查询原理</a></li>\n</ul>\n</li>\n<li><a href=\"#mcetoc_1h68ttla31trd\" rel=\"noopener nofollow\">项目启动</a>\n<ul>\n<li><a href=\"#mcetoc_1h68ttla31tre\" rel=\"noopener nofollow\">新增数据演示</a></li>\n<li><a href=\"#mcetoc_1h68ttla31trf\" rel=\"noopener nofollow\">查询数据演示</a></li>\n</ul>\n</li>\n<li><a href=\"#mcetoc_1h68ttla31trg\" rel=\"noopener nofollow\">查询示例</a>\n<ul>\n<li><a href=\"#mcetoc_1h68ttla31trh\" rel=\"noopener nofollow\">构造数据</a></li>\n<li><a href=\"#mcetoc_1h68ttla31tri\" rel=\"noopener nofollow\">插入到数据库</a></li>\n<li><a href=\"#mcetoc_1h68ttla31trj\" rel=\"noopener nofollow\">查询选择了\"1-编程\"这个选项的记录</a></li>\n<li><a href=\"#mcetoc_1h68ttla31trk\" rel=\"noopener nofollow\">查询选择了\"2-听音乐唱歌，5-看电影\"这些选项的记录</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h1 class=\"md-end-block md-heading md-focus\" id=\"mcetoc_1h68ttla31tr7\"><span class=\"md-plain\">背景</span></h1>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">在项目开发中，如何保存多选项的值呢？</span></strong></span><span class=\"md-plain md-expand\">例如下图中的职业发展和兴趣爱好</span></p>\n<p><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"700\" /></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain md-expand\">最容易想到的就是，选择了哪些选项，就把该选项值存储起来。</span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain md-expand\">在数据库层面设置一个VARCHAR，例如选择了\"收入无上线、培训与发展、职业价值感\"，前端就传递\"收入无上线、培训与发展、职业价值感\"，数据库就保存为\"收入无上线、培训与发展、职业价值感\"。</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">可是这样存在一个问题</span></strong></span><span class=\"md-plain\">，我要查询那些人选择了其中的某个、某些选项，就很难实现。例如，查询那些人的兴趣爱好是\"编程、篮球\"，查询兴趣爱好是\"看书、写作\"的人数有多少。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">为了解决这种多选项的高效查询问题</span></strong></span><span class=\"md-plain\">，本人设计了一种方法，可以实现</span><span class=\"md-pair-s \"><strong><span class=\"md-plain\">快速、高效地查询</span></strong></span><span class=\"md-plain md-expand\">多选项中有某个、某些选项的所有记录。</span></p>\n<h1 class=\"md-end-block md-heading\" id=\"mcetoc_1h68ttla31tr8\"><span class=\"md-plain\">设计思想</span></h1>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><strong><span class=\"md-plain\">核心思路：</span></strong></span></p>\n<ol class=\"ol-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">编码</span></strong></span><span class=\"md-plain\">：将每个选项与特定的比特位上对应起来，选中为1，未选中为0</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><strong><span class=\"md-plain\">存储</span></strong></span><span class=\"md-plain\">：将比特位转换为Long型（64bit，最大支持64个多选项），数据库表字段为BIGINT</span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-pair-s\"><strong><span class=\"md-plain\">查询</span></strong></span><span class=\"md-plain md-expand\">：与（&amp;）位运算</span></p>\n</li>\n</ol>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">主要流程</span></strong></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span style=\"background-color: rgba(255, 255, 255, 1);\"><span class=\"md-plain\">编码：将多选项进行</span><span class=\"md-pair-s \"><strong><span class=\"md-plain\">编号</span></strong></span><span class=\"md-plain\">：</span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">例如：对职业发展的多选项进行编号为：1-收入无上限，2-培训与发展，3-职业价值感，4-行业稳定性，5-社交与人脉，6-塑造个人品牌，7-团队综合素质，8-终身学习；</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对兴趣爱好的多选项进行编号为：1-编程，2-听音乐唱歌，3-篮球，4-玩游戏，5-看电影，6-享美食，7-健身，8-旅游，9-看书，10-写作。</span></p>\n</li>\n</ul>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span style=\"background-color: rgba(255, 255, 255, 1);\"><span class=\"md-plain\">存储</span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span style=\"background-color: rgba(236, 202, 250, 1);\"><span class=\"md-plain\">前端：</span><span class=\"md-pair-s \"><strong><span class=\"md-plain\">选择了哪些选项，就传递哪些选项的编号</span></strong></span></span><span class=\"md-plain\"><span style=\"background-color: rgba(236, 202, 250, 1);\">。</span>例如：选择了\"编程、篮球\"，则传递的编号串为：\"1,3\"</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span style=\"background-color: rgba(191, 237, 210, 1);\"><span class=\"md-plain\">后端：将</span><span class=\"md-pair-s \"><strong><span class=\"md-plain\">编号串转换为二进制串</span></strong></span><span class=\"md-plain\">，再</span><span class=\"md-pair-s \"><strong><span class=\"md-plain\">转换为数字</span></strong></span><span class=\"md-plain\">，落库</span></span></p>\n</li>\n</ul>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">查询：前端还是只传选项编号；后端将其转换为数字；在数据库层面使用</span><span class=\"md-pair-s \"><strong><span class=\"md-plain\">位运算中的<span style=\"background-color: rgba(251, 238, 184, 1);\">与运算</span></span></strong></span><span class=\"md-plain\"><span style=\"background-color: rgba(251, 238, 184, 1);\">，匹配包含了参数选项的记录</span>。</span></p>\n</li>\n</ul>\n<h2 class=\"md-end-block md-heading md-focus\" id=\"mcetoc_1h68ttla31tr9\"><span class=\"md-plain md-expand\">编码：将多选项转换为数字</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">现以兴趣爱好为例，为其多选项定义编号：</span></strong></span><span class=\"md-plain\">1-编程，2-听音乐唱歌，3-篮球，4-玩游戏，5-看电影，6-享美食，7-健身，8-旅游，9-看书，10-写作</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><strong><span class=\"md-plain\">根据二进制位下标与十进制数的互转：</span></strong></span></p>\n<p><span class=\"md-plain md-expand\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"777\" /></span></p>\n<h3 class=\"md-end-block md-heading md-focus\" id=\"mcetoc_1h68ttla31tra\"><span class=\"md-plain md-expand\">例1</span></h3>\n<blockquote>\n<p>用户A勾选的兴趣爱好为：\"1-编程，2-听音乐唱歌，5-看电影，6-享美食\"<br />前端传递的串为：1,2,5,6<br />转换为二进制串：0011 0011<br />转换规则：在有选项编号出现的位下标的位置上填充1，其他位置填充0<br />转换为十进制后落库：51</p>\n</blockquote>\n<p><span class=\"md-plain md-expand\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"777\" /></span></p>\n<h3 class=\"md-end-block md-heading md-focus\" id=\"mcetoc_1h68ttla31trb\"><span class=\"md-plain md-expand\">例2</span></h3>\n<blockquote>\n<p><span class=\"md-plain md-expand\">用户B勾选的兴趣爱好为：\"3-篮球，4-玩游戏，6-享美食，7-健身，10-写作\"<br />前端传递的串为：3,4,6,7,10<br />转换为二进制串：0010 0110 1100<br />转换为十进制后落库：620</span></p>\n</blockquote>\n<p><span class=\"md-plain md-expand\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"777\" /></span></p>\n<h2 class=\"md-end-block md-heading\" id=\"mcetoc_1h68ttla31trc\"><span class=\"md-plain\">查询原理</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">查询的核心思想：与（&amp;）位运算</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\"><span style=\"color: rgba(224, 62, 45, 1);\"><strong>X &amp; Y = X</strong></span>，则说明X的所有值为\"1\"的二进制位、在Y中对应的二进制位也为\"1\"。</span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain\">也就是说，<span style=\"color: rgba(241, 196, 15, 1);\">Y为\"1\"的二进制位包含了X的所有为\"1\"的二进制位</span>。从而实现了，查询条件X，在Y中存在（包含）</span></p>\n</li>\n</ul>\n<p><span class=\"md-plain md-expand\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p><span class=\"md-plain md-expand\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"777\" /></span></p>\n<h1 class=\"md-end-block md-heading\" id=\"mcetoc_1h68ttla31trd\"><span class=\"md-plain\">项目启动</span></h1>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Step 1：在application.yml中修改数据库连接参数</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Step 2：执行resources/sql.sql下的SQL文件，初始化数据</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Step 3：从启动类App.java启动</span></p>\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain\">Step 4：启动成功后进入前端页面：</span><span class=\"md-link md-pair-s md-expand\"><a href=\"http://localhost:9898/person.html\" rel=\"noopener nofollow\">http://localhost:9898/person.html</a></span></p>\n<h2 class=\"md-end-block md-heading\" id=\"mcetoc_1h68ttla31tre\"><span class=\"md-plain\">新增数据演示</span></h2>\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">必要数据，多选项进行勾选：</span></strong></span></p>\n<p><span class=\"md-plain md-expand\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"777\" /></span></p>\n<p><span class=\"md-plain md-expand\"><strong><span class=\"md-plain\">去数据库查看刚刚新增的记录：</span></strong></span></p>\n<p><span class=\"md-plain md-expand\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"777\" /></span></p>\n<h2 class=\"md-end-block md-heading\" id=\"mcetoc_1h68ttla31trf\"><span class=\"md-plain\">查询数据演示</span></h2>\n<p class=\"md-end-block md-p md-focus md-expand\"><span class=\"md-pair-s md-expand\"><strong><span class=\"md-plain\">选择查询条件，点击“Query”进行查询：</span></strong></span></p>\n<p><span class=\"md-plain md-expand\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"777\" /></span></p>\n<p><span class=\"md-plain md-expand\"><strong><span class=\"md-plain\">查看运行日志，显示执行的SQL：</span></strong></span></p>\n<p><span class=\"md-plain md-expand\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"777\" /></span></p>\n<h1 class=\"md-end-block md-heading\" id=\"mcetoc_1h68ttla31trg\"><span class=\"md-plain md-expand\">查询示例</span></h1>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">以多选项”兴趣爱好“为例，展示查询的工作原理</span></p>\n<h2 class=\"md-end-block md-heading\" id=\"mcetoc_1h68ttla31trh\"><span class=\"md-plain\">构造数据</span></h2>\n<p>AA选择了\"1-编程，2-听音乐唱歌，5-看电影，6-享美食，7-健身，8-旅游\"<br />前端传递的编号串：1,2,5,6,7,8<br />转换为二进制串：0000 1111 0011<br />转换为数字：243</p>\n<p>BB选择了\"3-篮球，4-玩游戏，8-旅游，9-看书，10-写作\"<br />前端传递的编号串：3,4,8,9,10<br />转换为二进制串：0011 1000 1100<br />转换为数字：908</p>\n<p>CC选择了\"2-听音乐唱歌，3-篮球，5-看电影，6-享美食，7-健身，9-看书，10-写作\"<br />前端传递的编号串：2,3,5,6,7,9,10<br />转换为二进制串：0011 0111 0110<br />转换为数字：886</p>\n<p>DD选择了\"1-编程，3-篮球，4-玩游戏，6-享美食，7-健身，8-旅游，10-写作\"<br />前端传递的编号串：1,3,4,6,7,8,10<br />转换为二进制串：0010 0110 1101<br />转换为数字：749</p>\n<p>EE选择了\"2-听音乐唱歌，4-玩游戏，5-看电影，7-健身，8-旅游，10-写作\"<br />前端传递的编号串：2,4,5,7,8,10<br />转换为二进制串：0010 1101 1010<br />转换为数字：730</p>\n<p>FF选择了\"1-编程，2-听音乐唱歌，3-篮球，4-玩游戏，5-看电影，7-健身\"<br />前端传递的编号串：1,2,3,4,5,7<br />转换为二进制串：0000 0101 1111<br />转换为数字：95</p>\n<p>GG选择了\"1-编程，3-篮球，4-玩游戏，6-享美食，8-旅游，10-写作\"<br />前端传递的编号串：1,3,4,6,8,10<br />转换为二进制串：0010 1010 1101<br />转换为数字：685</p>\n<h2 class=\"md-end-block md-heading md-focus\" id=\"mcetoc_1h68ttla31tri\"><span class=\"md-plain\">插入到数据库</span></h2>\n<pre class=\"line-numbers language-sql highlighter-hljs\"><code>DROP TABLE IF EXISTS person;\nCREATE TABLE person (\n    id BIGINT AUTO_INCREMENT,\n    name VARCHAR(50) DEFAULT NULL COMMENT '姓名',\n    gender INT DEFAULT NULL COMMENT '性别，0-女，1-男',\n    address VARCHAR(128) DEFAULT NULL COMMENT '地址',\n    careers BIGINT DEFAULT NULL COMMENT '职业发展多选项',\n    -- 兴趣爱好多选项。可选项：1-编程，2-听音乐唱歌，3-篮球，4-玩游戏，5-看电影，6-享美食，7-健身，8-旅游，9-看书，10-写作。\n    -- 例如，全选：\"11 1111 1111\"，保存为十进制=1023，全不选：\"00 0000 0000\"，保存为十进制=0，只选择听音乐唱歌：\"0000 0010\"，保存为十进制=2\n    -- LONG最大支持64位，最多支持64个多选项的任意选择\n    interests BIGINT DEFAULT NULL COMMENT '兴趣爱好多选项',\n    create_time DATETIME DEFAULT NULL,\n    update_time DATETIME DEFAULT NULL,\n    deleted INT DEFAULT 0 COMMENT '是否删除：0-否，1-是',\n    PRIMARY KEY(id)\n);</code></pre>\n<pre class=\"line-numbers language-sql highlighter-hljs\"><code>-- 将上文中构造的数据，以SQL的形式插入到数据库中，只以多选项\"兴趣爱好\"为例\nINSERT INTO person(name, gender, address, careers, interests, create_time, update_time, deleted)\nVALUES ('AA', 1, 'SH CN', 1, 243, '2022-12-12','2023-12-12', 0),\n       ('BB', 1, 'SH CN', 1, 908, '2022-12-12','2023-12-12', 0),\n       ('CC', 1, 'SH CN', 1, 886, '2022-12-12','2023-12-12', 0),\n       ('DD', 1, 'SH CN', 1, 749, '2022-12-12','2023-12-12', 0),\n       ('EE', 1, 'SH CN', 1, 730, '2022-12-12','2023-12-12', 0),\n       ('FF', 1, 'SH CN', 1, 95, '2022-12-12','2023-12-12', 0),\n       ('GG', 1, 'SH CN', 1, 685, '2022-12-12','2023-12-12', 0);</code></pre>\n<h2 class=\"md-end-block md-heading\" id=\"mcetoc_1h68ttla31trj\"><span class=\"md-plain md-expand\">查询选择了\"1-编程\"这个选项的记录</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">目标：</span></strong></span><span class=\"md-plain\">在多选项中查询选择了\"1-编程\"这个选项的记录</span></p>\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">用户的\"兴趣爱好\"多选项（二进制形式）</span></strong></span></p>\n<blockquote>\n<p><span class=\"md-plain md-expand\">AA： 0000 1111 0011<br />BB： 0011 1000 1100<br />CC： 0011 0111 0110<br />DD： 0010 0110 1101<br />EE： &nbsp;0010 1101 1010<br />FF： &nbsp;0000 0101 1111<br />GG： 0010 1010 1101</span></p>\n</blockquote>\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-pair-s\"><strong><span class=\"md-plain\">将\"1-编程\"进行转换</span></strong></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">转换为二进制：0000 0000 0001</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">转换为十进制：1</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">查询原理：</span></strong></span><span class=\"md-plain md-expand\">将查询条件\"0000 0000 0001\"与AA~GG的二进制位进行与运算后，仍然为查询条件的记录，则是选择了\"1-编程\"这个选项的记录</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">查询过程</span></strong></span></p>\n<ul>\n<li><span class=\"md-plain md-expand\">将查询条件与AA的二进制位进行与运算：</span></li>\n</ul>\n<pre class=\"line-numbers language-properties highlighter-hljs\"><code>   0000 0000 0001\n&amp;  0000 1111 0011\n#--------------------------\n   0000 0000 0001  与运算结果仍为查询条件，说明这条记录包含了\"1-编程\"这个选项</code></pre>\n<ul>\n<li><span class=\"md-plain md-expand\">将查询条件与BB的二进制位进行与运算：</span></li>\n</ul>\n<pre class=\"line-numbers language-properties highlighter-hljs\"><code>   0000 0000 0001\n&amp;  0011 1000 1100\n#----------------------------\n   0000 0000 0000   与运算结果不为查询条件，说明这条记录不包含了\"1-编程\"这个选项</code></pre>\n<ul class=\"ul-list\">\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain md-expand\">其他记录运算同理</span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain md-expand\">最终发现只有AA、DD、FF、GG的运算结果符合条件，这四个记录就是满足\"选择了1-编程这个选项的所有记录\"</span></p>\n</li>\n</ul>\n<p><span class=\"md-plain md-expand\"><strong><span class=\"md-plain\">SQL实现</span></strong></span></p>\n<pre class=\"line-numbers language-sql highlighter-hljs\"><code>select * FROM person WHERE interests &amp; 1 = 1;</code></pre>\n<p><span class=\"md-plain md-expand\"><strong><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"777\" /></strong></span></p>\n<h2 class=\"md-end-block md-heading\" id=\"mcetoc_1h68ttla31trk\"><span class=\"md-plain\">查询选择了\"2-听音乐唱歌，5-看电影\"这些选项的记录</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">目标：</span></strong></span><span class=\"md-plain\">在多选项中查询选择了\"2-听音乐唱歌，5-看电影\"这些选项的记录</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">用户的\"兴趣爱好\"多选项（二进制形式）</span></strong></span></p>\n<blockquote>\n<p><span class=\"md-plain md-expand\"><strong>AA： 0000 1111 0011<br />BB： 0011 1000 1100<br />CC： 0011 0111 0110<br />DD： 0010 0110 1101<br />EE： &nbsp;0010 1101 1010<br />FF： &nbsp;0000 0101 1111<br />GG： 0010 1010 1101</strong></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s md-expand\"><strong><span class=\"md-plain\">将\"2-听音乐唱歌，5-看电影\"进行转换</span></strong></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">转换为二进制：0000 0001 0010</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">转换为十进制：18</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">查询原理：</span></strong></span><span class=\"md-plain\">将查询条件\"0000 0001 0010\"与AA~GG的二进制位进行与运算后，仍然为查询条件的记录，则是选择了\"2-听音乐唱歌，5-看电影\"这个选项的记录</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">查询过程</span></strong></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain\">将查询条件与AA的二进制位进行与运算：</span></p>\n</li>\n</ul>\n<pre class=\"line-numbers language-properties highlighter-hljs\"><code>  0000 0001 0010\n&amp; 0000 1111 0011\n#--------------------------\n   0000 0001 0010  与运算结果仍为查询条件，说明这条记录包含了\"2-听音乐唱歌，5-看电影\"这些选项</code></pre>\n<ul>\n<li><span class=\"md-plain md-expand\">将查询条件与BB的二进制位进行与运算：</span></li>\n</ul>\n<pre class=\"line-numbers language-properties highlighter-hljs\"><code>  0000 0001 0010\n&amp; 0011 1000 1100\n#----------------------------\n  0000 0000 0000   与运算结果不为查询条件，说明这条记录不包含了\"2-听音乐唱歌，5-看电影\"这些选项</code></pre>\n<ul class=\"ul-list\">\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain md-expand\">其他记录运算同理</span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain md-expand\">最终发现只有AA、CC、EE、FF的运算结果符合条件，这四个记录就是满足\"选择了2-听音乐唱歌，5-看电影这些选项的所有记录\"</span></p>\n</li>\n</ul>\n<p><span class=\"md-plain md-expand\"><strong><span class=\"md-plain\">SQL实现</span></strong></span></p>\n<pre class=\"line-numbers language-sql highlighter-hljs\"><code>select * FROM person WHERE interests &amp; 18 = 18;</code></pre>\n<p><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"777\" /></p>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-03 22:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hackyle\">ALGO阿狗</a>&nbsp;\n阅读(<span id=\"post_view_count\">1</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}