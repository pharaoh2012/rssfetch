{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "神秘序列——格雷码序列",
      "link": "https://www.cnblogs.com/reasa/p/19603721",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/reasa/p/19603721\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 12:17\">\n    <span>神秘序列——格雷码序列</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"背景\">背景</h1>\n<p>昨日写题的时候，偶遇一道神奇的构造题，题目是这样的：</p>\n<p>构造一个长度为<span class=\"math inline\">\\(2^n\\)</span>的序列<span class=\"math inline\">\\(p_0,p_1,…,p_{2^n−1}\\)</span>，使得相邻两项异或值之和最小。</p>\n<p>这道题很容易就可以看出，如果要构造一个使得相邻两项异或值之和最小的序列，就要保证每个元素与相邻元素间在二进制下仅有一位的差距，而这样的序列显然会按照有效二进制位数升序排列，因此我很快就想到了这样一个贪心策略：首先将0放进排列尾部，然后每次从小到大尝试改变尾部的二进制位，如果得到的是新数就更新排列，这里的从小到大尝试改变尾部的二进制位指的是：当数已经存在于生成的答案序列中时，尝试改变更高一位的二进制位。举个例子：</p>\n<pre><code class=\"language-txt\">0\n0 1\n(尝试改变0的倒数1位,得到1,成功)\n0 1 3\n(尝试改变1的倒数1位,得到0,但0在排列中,失败,尝试改变1的倒数第2位,得到3,成功)\n0 1 3 2\n(尝试改变3的倒数1位，得到2，成功)\n0 1 3 2 6\n(尝试改变2的倒数1位,得到3,失败,尝试改变2的倒数第2位,得到0,失败,尝试改变2的倒数第3位,得到6,成功)\n0 1 3 2 6 7 5 4 \n</code></pre>\n<p>这就是我所想到的贪心思路，它是正确的，代码如下：</p>\n<pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin &gt;&gt; n;\n    int m = 1 &lt;&lt; n;\n    vector&lt;int&gt; ans;\n    vector&lt;bool&gt; vis(m, false);\n    int cur = 0;\n    ans.push_back(cur);\n    vis[cur] = true;\n    while ((int)ans.size() &lt; m) {\n        for (int i = 0; i &lt; n; i++) {\n            int nxt = cur ^ (1 &lt;&lt; i);\n            if (!vis[nxt]) {\n                cur = nxt;\n                ans.push_back(cur);\n                vis[cur] = true;\n                break;\n            }\n        }\n    }\n    for (int i = 0; i &lt; m; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \" \\n\"[i == m - 1];\n    }\n    return 0;\n}\n</code></pre>\n<h1 id=\"转折\">转折</h1>\n<p>当我完成这道题后，还没来得及欣喜，就在看题解时发现了这道题原来另有说法，这道题目所要求构造的序列其实是一个非常经典的序列，该序列构造的规则是一个叫做格雷码的二进制数字系统，是由贝尔实验室的Frank Gray于20世纪40年代提出。它具有许多优点。</p>\n<h1 id=\"格雷码\">格雷码</h1>\n<h2 id=\"基本定义\">基本定义</h2>\n<p>在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code）</p>\n<h2 id=\"性质\">性质</h2>\n<h3 id=\"单位距离性\">单位距离性</h3>\n<p>相邻格雷码之间的二进制仅有一位不同</p>\n<h3 id=\"循环性\">循环性</h3>\n<p>任意连续<span class=\"math inline\">\\(2^k\\)</span>个格雷码其首尾仍符合单位距离性，即首位间二进制仅有一位不同</p>\n<h3 id=\"子立方体封闭性\">子立方体封闭性</h3>\n<p>在 n 维格雷码序列中，任意连续 <span class=\"math inline\">\\(2^k\\)</span> 项（从 <span class=\"math inline\">\\(2^k\\)</span> 的整数倍位置开始）恰好构成一个 k 维子立方体的格雷码。</p>\n<h2 id=\"构造\">构造</h2>\n<h3 id=\"手动构造\">手动构造</h3>\n<p><span class=\"math inline\">\\(k\\)</span> 位的格雷码可以通过以下方法构造．我们从全 <span class=\"math inline\">\\(0\\)</span> 格雷码开始，按照下面策略：</p>\n<ol>\n<li>翻转最低位得到下一个格雷码，（例如 <span class=\"math inline\">\\(000\\to 001\\)</span>）；</li>\n<li>把最右边的 <span class=\"math inline\">\\(1\\)</span> 的左边的位翻转得到下一个格雷码，（例如 <span class=\"math inline\">\\(001\\to 011\\)</span>）；</li>\n</ol>\n<p>交替按照上述策略生成 <span class=\"math inline\">\\(2^{k-1}\\)</span> 次，可得到 <span class=\"math inline\">\\(k\\)</span> 位的格雷码序列．</p>\n<h3 id=\"镜像构造\">镜像构造</h3>\n<p><span class=\"math inline\">\\(k\\)</span> 位的格雷码可以从 <span class=\"math inline\">\\(k-1\\)</span> 位的格雷码以上下镜射后加上新位的方式快速得到，如下图：</p>\n<p></p><div class=\"math display\">\\[\\begin{matrix}\nk=1\\\\\n0\\\\ 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\end{matrix}\n\\to \\begin{matrix}\\\\\n\\color{Red}0\\\\\\color{Red}1\\\\\\color{Blue}1\\\\\\color{Blue}0\\\\\\\\\\\\\\\\\\\\\n\\end{matrix}\n\\to \\begin{matrix}\nk=2\\\\\n{\\color{Red}0}0\\\\{\\color{Red}0}1\\\\{\\color{Blue}1}1\\\\{\\color{Blue}1}0\\\\\\\\\\\\\\\\\\\\\n\\end{matrix}\n\\to \\begin{matrix}\\\\\n\\color{Red}00\\\\\\color{Red}01\\\\\\color{Red}11\\\\\\color{Red}10\\\\\\color{Blue}10\\\\\\color{Blue}11\\\\\\color{Blue}01\\\\\\color{Blue}00\n\\end{matrix}\n\\to \\begin{matrix}\nk=3\\\\\n{\\color{Red}0}00\\\\{\\color{Red}0}01\\\\{\\color{Red}0}11\\\\{\\color{Red}0}10\\\\{\\color{Blue}1}10\\\\{\\color{Blue}1}11\\\\{\\color{Blue}1}01\\\\{\\color{Blue}1}00\n\\end{matrix}\n\\]</div><p></p><h3 id=\"贪心构造\">贪心构造</h3>\n<p>就是和我采用的策略一致，首先将0放进排列尾部，然后每次从小到大尝试改变尾部的二进制位，如果得到的是新数就更新排列</p>\n<h3 id=\"公式法\">公式法</h3>\n<p>先使用手搓的方式，构造一些小的格雷码，然后观察第 <span class=\"math inline\">\\(i\\)</span> 个格雷码与 <span class=\"math inline\">\\(i\\)</span> 之间的关系，我们可以发现：第 <span class=\"math inline\">\\(n\\)</span> 个格雷码的二进制第 <span class=\"math inline\">\\(i\\)</span> 位为 <span class=\"math inline\">\\(1\\)</span>，仅当 <span class=\"math inline\">\\(n\\)</span> 的二进制第 <span class=\"math inline\">\\(i\\)</span> 位为 <span class=\"math inline\">\\(1\\)</span>，第 <span class=\"math inline\">\\(i+1\\)</span> 位为 <span class=\"math inline\">\\(0\\)</span> 或者第 <span class=\"math inline\">\\(i\\)</span> 位为 <span class=\"math inline\">\\(0\\)</span>，第 <span class=\"math inline\">\\(i+1\\)</span> 位为 <span class=\"math inline\">\\(1\\)</span>，于是，我们能想到使用异或运算来构造这一个格雷码，其公式如下：</p>\n<p></p><div class=\"math display\">\\[Gray_i = i \\bigoplus (i&gt;&gt;1)\n\\]</div><p></p><h2 id=\"优点\">优点</h2>\n<p>有些人可能会说，自然二进制编码就能直接使用，为什么要拐弯抹角地使用另外一种二进制编码系统呢，这是因为格雷码是一种具有反射特性和循环特性的单步自补码，其循环和单步特性消除了随机取数时出现重大错误的可能，其反射和自补特性使得对其进行求反操作也非常方便，所以，格雷码相较于自然二进制编码更加可靠，同时，它是一种错误最小化的编码方式，格雷码每一次变动时，仅改变一位二进制位，而自然二进制编码每一次变动，有可能因为进位使得多位二进制位发生改变，更不容易出错。</p>\n<h2 id=\"应用\">应用</h2>\n<p>格雷码在多个领域有着巧妙且实用的应用：</p>\n<ul>\n<li>\n<p>在三维曲面量测中，可采用格雷码投射的非接触式光学投影方法，实现对微型曲面的精准测量</p>\n</li>\n<li>\n<p>在逻辑函数化简过程中，借助按格雷码规则排列的卡诺图，便能高效完成化简操作</p>\n</li>\n<li>\n<p>在汽车制动系统的角度传感器中，该传感器需通过数字值指示机械位置，其编码盘与触点的设计遵循格雷码逻辑——编码盘中的暗区与逻辑1的信号源相连，亮区则无连接，触点会将其识别为逻辑0，为3位二进制编码的编码盘采用格雷码编码后，能让连续码字之间仅有一个数位发生变化，有效避免因器件制造精度限制，触点转到边界位置时出现的编码错误问题</p>\n</li>\n<li>\n<p>格雷码可以用于解决汉诺塔问题：</p>\n<p>设盘的数量为 <span class=\"math inline\">\\(n\\)</span>．我们从 <span class=\"math inline\">\\(n\\)</span> 位全 <span class=\"math inline\">\\(0\\)</span> 的格雷码 <span class=\"math inline\">\\(G(0)\\)</span> 开始，依次移向下一个格雷码（<span class=\"math inline\">\\(G(i)\\)</span> 移向 <span class=\"math inline\">\\(G(i+1)\\)</span>）．当前格雷码的二进制第 <span class=\"math inline\">\\(i\\)</span> 位表示从小到大第 <span class=\"math inline\">\\(i\\)</span> 个盘子．</p>\n<p>由于每一次只有一个二进制位会改变，因此当第 <span class=\"math inline\">\\(i\\)</span> 位改变时，我们移动第 <span class=\"math inline\">\\(i\\)</span> 个盘子．在移动盘子的过程中，除了最小的盘子，其他任意一个盘子在移动的时侯，只能有一个放置选择．在移动第一个盘子的时侯，我们总是有两个放置选择．于是我们的策略如下：</p>\n<p>如果 <span class=\"math inline\">\\(n\\)</span>  是一个奇数，那么盘子的移动路径为 $$f\\to t\\to r\\to f\\to t\\to r\\to\\cdots$$ ，其中 <span class=\"math inline\">\\(f\\)</span> 是最开始的柱子，<span class=\"math inline\">\\(t\\)</span> 是最终我们把所有盘子放到的柱子，<span class=\"math inline\">\\(r\\)</span> 是中间的柱子．</p>\n<p>如果 <span class=\"math inline\">\\(n\\)</span> 是偶数：<span class=\"math inline\">\\(f \\to r \\to t \\to f \\to r \\to t \\to \\cdots\\)</span></p>\n</li>\n<li>\n<p>格雷码也在遗传算法理论中得到应用，格雷码的单位距离性使其每次改变仅改变一位二进制位，因此如果在变异时使用可以避免变异后与变异前的差异过大导致收敛不稳定，同时父代交叉时单点交叉会破坏连续性，使子代与父代差异过大，而使用格雷码则可以避免子代父代不像亲生的。</p>\n</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>从一道看似简单的“最小异或和”构造题，到深入探索格雷码的数学世界，我们不难发现算法之美往往隐藏在基础的数学性质之中。</p>\n<p>格雷码作为一个经典的二进制系统，其核心价值在于 <strong>“相邻即最小差异”</strong> 。这一特性不仅在算法竞赛中帮助我们解决构造类问题（如汉诺塔、哈密顿路径构造），更在工程领域（如传感器防抖、数据传输纠错）发挥着不可替代的作用。</p>\n<p>掌握格雷码，不仅仅是记住了 <code>i ^ (i &gt;&gt; 1)</code> 这个公式，更重要的是理解了它<strong>通过改变编码顺序来降低系统不确定性</strong>的思维方式。希望这篇博客能让你在下次遇到类似构造题或工程问题时，能敏锐地联想到这个神奇的序列。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 12:17</span>&nbsp;\n<a href=\"https://www.cnblogs.com/reasa\">reasa</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "别再傻等了，给 Claude Code 装个通知铃铛",
      "link": "https://www.cnblogs.com/crossoverJie/p/19603468",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/crossoverJie/p/19603468\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 11:32\">\n    <span>别再傻等了，给 Claude Code 装个通知铃铛</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"背景\">背景</h1>\n<p>最近用 Claude Code、Copilot CLI 这类 AI Agent 工具的时候，有一个挺烦人的问题：让 AI 在后台跑任务，我总是会忍不住去查看他的执行状态，有时候比较复杂的任务可能会耗时十来分钟，每次来回切换非常浪费时间。</p>\n<p>更惨的是有时候 AI 需要我授权某个操作（比如执行 shell 命令），我没注意到，它就一直卡在那里等。</p>\n<p>所以我一直想找一个靠谱的通知方案。</p>\n<p>灵感来源于播客「<a href=\"https://justinyan.me/post/6623\" rel=\"noopener nofollow\" target=\"_blank\">枫言枫语</a>」，主播自力提到可以用 Hook 来实现 Agent 通知。</p>\n<p>不过一开始我偷了个懒，让 AI 自己给方案。AI 给出的方案很\"AI\"：在 <code>~/.claude/CLAUDE.md</code> 里加一段系统提示词，指示 LLM 任务完成后用 <code>afplay</code> 播放一个提示音。</p>\n<pre><code class=\"language-markdown\">## Task Completion Sound\nWhen you complete a task, play a sound:\nafplay /System/Library/Sounds/Glass.aiff\n</code></pre>\n<p>测试了几次发现这玩意不靠谱——有时候响，有时候不响，完全看 LLM 心情。</p>\n<p>最终我还是回到了 Hook 方案，用各平台的 Hooks 系统实现确定性触发，并封装成了一个可复用的 <a href=\"https://github.com/crossoverJie/skills\" rel=\"noopener nofollow\" target=\"_blank\">SKILL</a>。</p>\n<p>最终的效果如下：</p>\n<p><img alt=\"SCR-20260210-iwpt\" class=\"lazyload\" height=\"363\" width=\"342\" /></p>\n\n<h1 id=\"问题分析\">问题分析</h1>\n<p>为什么 LLM 提示词方案不靠谱？主要三个原因：</p>\n<ol>\n<li><strong>LLM 不会 100% 遵循附带操作类指令</strong>：LLM 对\"生成文本\"以外的操作指令（比如\"运行 bash 命令\"）本来就不太可靠，它可能觉得当前场景\"不需要\"播放声音就跳过了</li>\n<li><strong>上下文压缩会丢失指令</strong>：长对话中，系统会自动压缩上下文，提示词的优先级会被降低甚至直接丢掉</li>\n<li><strong>LLM 对触发时机的判定不一致</strong>：什么算\"任务完成\"？LLM 每次的理解可能都不一样，导致触发行为不稳定</li>\n</ol>\n<p>本质上，这是一个\"软提示\" vs \"硬触发\"的问题。用提示词去控制 LLM 行为，就像是\"拜托你帮我做一件事\"；而用 Hooks 就是\"当这个事件发生时，自动执行这段代码\"——确定性完全不同。</p>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>提示词方案</th>\n<th>Hooks 方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>触发可靠性</td>\n<td>不确定，取决于 LLM 判断</td>\n<td>确定性 100% 触发</td>\n</tr>\n<tr>\n<td>上下文影响</td>\n<td>长对话会被压缩丢失</td>\n<td>不受上下文影响</td>\n</tr>\n<tr>\n<td>配置方式</td>\n<td>Markdown 文本</td>\n<td>JSON 配置 + 脚本</td>\n</tr>\n<tr>\n<td>可扩展性</td>\n<td>基本不可扩展</td>\n<td>支持多平台、多渠道</td>\n</tr>\n<tr>\n<td>维护成本</td>\n<td>每次换模型可能要调提示词</td>\n<td>一次配置，持续生效</td>\n</tr>\n</tbody>\n</table>\n<p>有点类似于现在的 LLM 和 Agent 的区别，Agent 是干活的，大模型是负责思考的。</p>\n<p>确定的事情还是要交给确定的 Agent 去做。</p>\n<h1 id=\"agent-notifier-介绍\">agent-notifier 介绍</h1>\n<p>基于以上分析，我开发了 <a href=\"https://github.com/crossoverJie/skills/tree/main/skills/agent-notifier\" rel=\"noopener nofollow\" target=\"_blank\">agent-notifier</a> 这个 SKILL，用 Hooks 实现确定性通知。</p>\n<h2 id=\"功能概览\">功能概览</h2>\n<p>支持的 AI Agent 平台：</p>\n<table>\n<thead>\n<tr>\n<th>平台</th>\n<th>Hook 机制</th>\n<th>触发事件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Claude Code</td>\n<td>settings.json hooks</td>\n<td><code>Notification</code>（idle_prompt, permission_prompt）</td>\n</tr>\n<tr>\n<td>GitHub Copilot CLI</td>\n<td>hooks.json</td>\n<td><code>sessionEnd</code>, <code>postToolUse</code></td>\n</tr>\n<tr>\n<td>Cursor</td>\n<td>hooks.json</td>\n<td><code>stop</code>, <code>afterFileEdit</code></td>\n</tr>\n<tr>\n<td>Codex（OpenAI）</td>\n<td>notify setting</td>\n<td><code>agent-turn-complete</code></td>\n</tr>\n<tr>\n<td>Aider</td>\n<td>CLI flag</td>\n<td><code>--notifications-command</code></td>\n</tr>\n</tbody>\n</table>\n<p>支持的通知渠道：</p>\n<table>\n<thead>\n<tr>\n<th>渠道</th>\n<th>默认状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Sound</td>\n<td>启用</td>\n<td>macOS 用 <code>afplay</code>，Linux 用 <code>paplay</code>/<code>aplay</code></td>\n</tr>\n<tr>\n<td>macOS 通知中心</td>\n<td>启用</td>\n<td>通过 <code>osascript</code> 弹出系统通知</td>\n</tr>\n<tr>\n<td>Telegram</td>\n<td>禁用</td>\n<td>需要 Bot Token + Chat ID</td>\n</tr>\n<tr>\n<td>Email</td>\n<td>禁用</td>\n<td>SMTP 发送</td>\n</tr>\n<tr>\n<td>Slack</td>\n<td>禁用</td>\n<td>Incoming Webhook</td>\n</tr>\n<tr>\n<td>Discord</td>\n<td>禁用</td>\n<td>Webhook URL</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"架构设计\">架构设计</h2>\n<p>核心思路是<strong>统一事件模型 + 并发多渠道分发</strong>：</p>\n<pre><code>各平台 Hook 触发\n       ↓\n  stdin JSON 输入（各平台格式不同）\n       ↓\n  notify.py 解析为统一事件：{platform, event, message}\n       ↓\n  读取 notify-config.json 配置\n       ↓\n  ThreadPoolExecutor 并发分发到所有启用的渠道\n</code></pre>\n<p>每个平台传过来的 JSON 格式不一样，比如 Claude Code 是 <code>{\"notification_type\": \"idle_prompt\", ...}</code>，Copilot CLI 是 <code>{\"hook_event_name\": \"sessionEnd\", ...}</code>。<code>notify.py</code> 会把这些不同的格式统一解析成 <code>{platform, event, message}</code> 三元组，然后根据配置分发到各个通知渠道。</p>\n<blockquote>\n<p>一个关键设计：单个渠道发送失败不影响其他渠道。比如 Telegram 网络超时了，Sound 和 macOS 通知该响还是响。错误信息只输出到 stderr，不会中断流程。</p>\n</blockquote>\n<h2 id=\"核心设计决策纯标准库零依赖\">核心设计决策：纯标准库、零依赖</h2>\n<p>整个 <code>notify.py</code> 只用了 Python 标准库，没有任何 <code>pip</code> 依赖：</p>\n<ul>\n<li>HTTP 请求用 <code>urllib.request</code>（发 Telegram、Slack、Discord）</li>\n<li>邮件用 <code>smtplib</code></li>\n<li>播放声音用 <code>subprocess</code> 调系统命令</li>\n<li>并发用 <code>concurrent.futures</code></li>\n</ul>\n<p>这意味着只要机器上有 Python，拿来就能用，不需要 <code>pip install</code> 任何东西。</p>\n<h1 id=\"开发过程\">开发过程</h1>\n<p>整个 SKILL 的开发也是和 AI 对话完成的，下面分阶段回顾。</p>\n<h2 id=\"阶段一核心通知脚本-notifypy\">阶段一：核心通知脚本 notify.py</h2>\n<p>这是最核心的部分，负责三件事：</p>\n<ol>\n<li><strong>解析输入</strong>：从 stdin 读取各平台传过来的 JSON，识别平台类型和事件</li>\n<li><strong>统一事件模型</strong>：不管哪个平台，统一解析为 <code>{platform, event, message}</code></li>\n<li><strong>多渠道发送</strong>：并发调用所有启用的通知渠道</li>\n</ol>\n<p>比如 Claude Code 的 Hook 会通过 stdin 传入：</p>\n<pre><code class=\"language-json\">{\"notification_type\": \"idle_prompt\", \"message\": \"Claude is waiting for your input\"}\n</code></pre>\n<p>脚本解析后生成通知：<strong>\"✅ Task completed — waiting for your input\"</strong>，然后同时发到 Sound、macOS 通知中心、Telegram 等所有启用的渠道。</p>\n<h2 id=\"阶段二配置与安装\">阶段二：配置与安装</h2>\n<p>光有核心脚本还不够，还需要让用户能方便地配置和安装。所以又搞了两个文件：</p>\n<p><strong>notify-config.json</strong>：配置模板，定义了所有渠道的开关和参数。默认只启用 Sound 和 macOS 通知，Telegram、Email 这些需要手动启用并填入凭据。</p>\n<p><strong>setup.py</strong>：交互式安装脚本，运行后会：</p>\n<ol>\n<li>自动检测你装了哪些 AI Agent 平台</li>\n<li>引导你配置通知渠道（要不要 Telegram？Bot Token 是什么？）</li>\n<li>自动在对应平台写入 Hook 配置</li>\n<li>发一条测试通知验证配置</li>\n</ol>\n<h2 id=\"阶段三集成测试\">阶段三：集成测试</h2>\n<p>代码写完了，关键是跑起来验证。</p>\n<p>首先在 Claude Code 的 <code>~/.claude/settings.json</code> 里配置 Hook：</p>\n<pre><code class=\"language-json\">{\n  \"hooks\": {\n    \"Notification\": [\n      {\n        \"matcher\": \"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"python3 ~/.claude/skills/agent-notifier/notify.py\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>\n<p>然后手动测试：</p>\n<pre><code class=\"language-bash\"># 模拟任务完成通知\necho '{\"notification_type\":\"idle_prompt\",\"message\":\"test\"}' | python3 notify.py\n\n# 模拟权限请求通知\necho '{\"notification_type\":\"permission_prompt\",\"message\":\"needs permission\"}' | python3 notify.py\n</code></pre>\n<p>Sound 和 macOS 通知都正常。接着启用 Telegram，配好 Bot Token 和 Chat ID，再跑一次——Telegram 也收到了消息。</p>\n<p>最后让 Claude Code 执行一个真实任务，然后等它跑完。果然，任务结束后 Telegram 弹出通知，Sound 也响了，搞定。</p>\n<h2 id=\"阶段四修-bug-改文案\">阶段四：修 bug 改文案</h2>\n<p>实际使用中发现一个问题：<code>idle_prompt</code> 的通知消息是 \"Claude is waiting for your input\"，但这个消息不够直观——我更想知道的是\"任务完成了\"，而不是\"在等你输入\"。</p>\n<p>虽然本质上 <code>idle_prompt</code> 就是任务完成后等待输入的信号，但消息文案会影响用户感知。于是改成了：</p>\n<ul>\n<li><code>idle_prompt</code> → <strong>\"✅ Task completed — waiting for your input\"</strong></li>\n<li><code>permission_prompt</code> → <strong>\"🔐 Permission required\"</strong></li>\n</ul>\n<p>改完之后再测，Telegram 消息一目了然，不用再猜它到底是什么状态了。</p>\n<h1 id=\"总结\">总结</h1>\n<p>这次开发最核心的观点就一句话：<strong>Hooks &gt; 提示词</strong>。</p>\n<p>凡是需要确定性执行的操作，都不应该用提示词去\"请求\"LLM 来做，而是应该用平台提供的 Hook 机制来保证。提示词适合控制生成内容的风格和方向，但不适合控制\"是否执行某个操作\"这类二元决策。</p>\n<p>另外，对话式开发的体验依然很好。从最初的想法到最终可用的 SKILL，整个过程就是不断对话、测试、修复的循环。像 Telegram 消息文案不够直观这种问题，也是在实测中才发现的。</p>\n<p>感兴趣的可以去 <a href=\"https://github.com/crossoverJie/skills\" rel=\"noopener nofollow\" target=\"_blank\">GitHub 仓库</a> 看看源码，<code>agent-notifier</code> 在 <code>skills/agent-notifier/</code> 目录下。</p>\n<h1 id=\"blog\">Blog</h1>\n\n\n</div>\n<div id=\"MySignature\">\n    <div style=\"font-size: small;\">\n\n<p>\n        作者： \n        <a href=\"https://crossoverjie.top/about/\">crossoverJie</a>\n</p>\n<p>\n        出处：\n        <a href=\"https://crossoverjie.top/\">https://crossoverjie.top</a>\n</p>\n<img src=\"https://i.loli.net/2019/05/19/5ce16dbc99cfa13989.jpg\" />\n<p>\n欢迎关注博主公众号与我交流。\n</p>\n<p>\n         本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出,\n            如有问题， 可邮件（crossoverJie#gmail.com）咨询。\n</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 11:32</span>&nbsp;\n<a href=\"https://www.cnblogs.com/crossoverJie\">crossoverJie</a>&nbsp;\n阅读(<span id=\"post_view_count\">25</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Sa-Token(一)之简介及入门：告别鉴权内耗，让每一位Java开发者都能轻松上手",
      "link": "https://www.cnblogs.com/philry/p/19602802",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/philry/p/19602802\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 09:58\">\n    <span>Sa-Token(一)之简介及入门：告别鉴权内耗，让每一位Java开发者都能轻松上手</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1><span><span><span>Sa-Token(一)之简介及入门：告别鉴权内耗，让每一位Java开发者都能轻松上手</span></span></span></h1>\n<p><span style=\"background-color: rgba(0, 204, 255, 1); font-size: 18px;\">可以点击文末的链接【<a href=\"https://mp.weixin.qq.com/s/JLQSMAgqK1U0vtrdtRsKlA\" rel=\"noopener nofollow\" target=\"_blank\" title=\"Sa-Token(一)之简介及入门：告别鉴权内耗，让每一位Java开发者都能轻松上手\"><span style=\"background-color: rgba(0, 204, 255, 1);\">阅读原文</span></a>】</span></p>\n<p><span style=\"font-size: 18px;\">创作不易，<span>还请家人们关注下公众下支持，小编不胜感激。</span></span></p>\n<p>&nbsp;</p>\n<p><span><span>写Java的这些年，无论是初入职场的新手，还是深耕多年的老兵，谁没在「鉴权」上栽过跟头？</span></span></p>\n<p><span><span>熬夜啃Spring Security的复杂配置，对着一堆过滤器链抓耳挠腮；用Shiro做前后端分离项目，为了适配Token模式改遍全局拦截器；甚至为了一个简单的“踢人下线”功能，自己手写Redis缓存、处理会话过期，最后还藏着一堆并发隐患。</span></span></p>\n<p><span><span>我走过10年的开发之路，见过太多开发者把本该花在业务逻辑上的精力，全部消耗在繁琐、冗余的鉴权代码里——明明是一个简单的后台管理系统，却要为了权限控制写几百行配置；明明是一个小程序接口，却要为了Token校验反复调试跨域、过期续期的问题。</span></span></p>\n<p><span><span>直到Sa-Token的出现，才彻底打破了“鉴权必复杂”的魔咒。它就像一位懂你的开发伙伴，不用你弯腰迁就复杂的概念，不用你熬夜拼凑繁琐的代码，只用最简单、最直接的方式，帮你搞定所有鉴权难题。今天，我就以过来人的身份，带着大家走进Sa-Token的世界，从对比到简介，再到手把手入门，每一步都贴合大家的真实开发痛点，让你看完就能上手，从此和鉴权内耗说再见。</span></span></p>\n<h2><span><span>一、Sa-Token和其他鉴权框架的对比：不吹不黑，懂你的痛点才是好框架</span></span></h2>\n<p><span><span>提到Java鉴权框架，大家最先想到的，大概率是Spring Security和Apache Shiro。这两款框架都是行业内的“老大哥”，成熟稳定、生态完善，在很多传统项目中都有广泛应用。但不可否认的是，它们诞生于JSP主导的时代，很多设计理念已经跟不上如今前后端分离、微服务盛行的开发节奏，这也成了很多开发者的“痛点来源”。</span></span></p>\n<p><span><span>先说说Spring Security，它的强大毋庸置疑——细粒度的权限控制、完善的OAuth2.0支持、与Spring生态的无缝集成，几乎能满足所有企业级项目的鉴权需求。但它的“强大”，也伴随着极高的学习成本。对于新手来说，光是搞懂过滤器链、认证管理器、权限决策器这些概念，就要花上几天甚至几周的时间；哪怕是有经验的开发者，要配置一套完整的、适配前后端分离的鉴权逻辑，也要写大量的自定义配置、重写多个接口，繁琐且容易出错。</span></span></p>\n<p><span><span>再说说Apache Shiro，它比Spring Security简洁很多，核心功能（认证、授权、会话管理）清晰易懂，学习成本相对较低，也能满足大多数中小型项目的需求。但它的短板也很明显：在前后端分离、微服务场景下，适配性很差——没有原生的Token支持，需要手动集成JWT；没有开箱即用的分布式会话方案，需要自己集成Redis；想要实现“踢人下线”“同端互斥登录”这些常见功能，都需要手动扩展，代码量不小，而且容易出现兼容性问题。</span></span></p>\n<p><span><span>而Sa-Token，恰好弥补了这两款框架的短板，同时保留了它们的优势，更贴合如今的开发场景。它不追求“大而全”，只追求“小而精”，所有设计都围绕“开发者痛点”展开，不引入复杂的概念，不添加冗余的功能，让鉴权回归本质——简单、高效、易用。</span></span></p>\n<p><span><span>为了让大家看得更直观，我整理了一份不吹不黑的对比，没有华丽的辞藻，只有真实的开发体验：</span></span></p>\n<p><span><strong><span><span>1. 学习成本</span></span></strong><span><span>：Spring Security（极高）&gt; Apache Shiro（中等）&gt; Sa-Token（极低）。Sa-Token可以零配置启动，不用懂复杂的架构设计，不用记繁琐的配置项，哪怕是新手，看一遍文档、写几行代码，就能快速上手。</span></span></span></p>\n<p><span><strong><span><span>2. 前后端分离适配</span></span></strong><span><span>：Sa-Token（原生支持）&gt; Spring Security（需大量自定义配置）&gt; Apache Shiro（需手动集成JWT）。Sa-Token内置多种Token读取策略，适配APP、小程序、SPA单页应用等所有前后端分离场景，不用你手动处理跨域、Token传递的问题。</span></span></span></p>\n<p><span><strong><span><span>3. 微服务适配</span></span></strong><span><span>：Sa-Token（开箱即用）&gt; Spring Security（需集成Spring Cloud Security）&gt; Apache Shiro（需大量自定义扩展）。Sa-Token提供分布式会话、网关统一鉴权、RPC调用鉴权等方案，多系统数据互通只需简单配置，重启数据不丢失。</span></span></span></p>\n<p><span><strong><span><span>4. 常用功能支持</span></span></strong><span><span>：Sa-Token（开箱即用）&gt; Spring Security（需配置/扩展）&gt; Apache Shiro（需扩展）。登录认证、权限校验、踢人下线、账号封禁、Token续期、同端互斥登录、单点登录等常见功能，Sa-Token全部内置，一行代码就能调用，不用你手动拼凑。</span></span></span></p>\n<p><span><strong><span><span>5. 扩展性</span></span></strong><span><span>：Spring Security（极高）&gt; Sa-Token（高）&gt; Apache Shiro（中等）。Sa-Token几乎所有组件都提供了扩展接口，90%以上的逻辑都可以按需重写，既能满足中小型项目的快速开发需求，也能适配大型项目的定制化需求。</span></span></span></p>\n<p><span><span>在这里，我不是要否定Spring Security和Shiro——它们依然是优秀的框架，在适合的场景下依然是首选。但对于大多数开发者来说，我们不需要那么“重”的框架，不需要为了一个简单的鉴权功能，去承担高额的学习成本和开发成本。我们想要的，是一个能快速上手、能解决痛点、能节省时间的工具，而Sa-Token，正是这样的工具。</span></span></p>\n<p><span><span>就像很多开发者说的：“用过Sa-Token之后，才知道鉴权原来可以这么简单——以前花一天配置的功能，现在一行代码就能搞定；以前熬夜调试的bug，现在根本不会出现。” 这不是夸张，而是无数开发者的真实体验，也是我用了这么多年Sa-Token，一直推荐它的原因。</span></span></p>\n<h2><span><span>二、Sa-Token简介：七年磨一剑，让鉴权变得简单、优雅</span></span></h2>\n<p><span><span>说了这么多对比，可能很多朋友会问：Sa-Token到底是什么？它为什么能做到“简单又强大”？</span></span></p>\n<p><span><span>官方对Sa-Token的定义是：一款开源、免费、轻量级的Java权限认证框架，专注于解决登录认证、权限控制、会话管理等一系列鉴权相关问题，让鉴权变得简单、优雅。但在我看来，Sa-Token的核心，不是“框架”，而是“懂开发者”——它知道我们不想写繁琐的配置，所以做到了零配置启动；它知道我们不想记复杂的API，所以设计了极简的调用方式；它知道我们开发中会遇到哪些痛点，所以提前内置了所有常用功能，让我们“拿来就用”。</span></span></p>\n<p><span><span>Sa-Token的作者说过一句话：“秉承着‘业务上需要什么，Sa-Token就做什么’的理念，拒绝引入复杂的概念，以实际业务需求为第一目标。” 这句话，正是Sa-Token的灵魂所在。它不追求“高大上”的架构，不炫耀“多强大”的功能，只专注于解决我们开发中最实际的问题——</span></span></p>\n<p><span><span>你需要登录认证？一行代码StpUtil.setLoginId(10001)就能标记登录，一行代码StpUtil.checkLogin()就能校验登录，不用自定义Realm，不用配置全局过滤器；</span></span></p>\n<p><span><span>你需要权限控制？一个注解@SaCheckPermission(\"user:add\")就能实现接口权限校验，一行代码StpUtil.hasRole(\"super-admin\")就能判断角色，不用手动查询权限表、拼接权限逻辑；</span></span></p>\n<p><span><span>你需要踢人下线？一行代码StpUtil.logoutByLoginId(10001)就能实现，不管对方在哪个端登录，下次访问都会自动退出，不用手动操作Redis、清理会话；</span></span></p>\n<p><span><span>你需要分布式会话？集成Redis只需简单配置，项目重启数据不丢失，多系统数据互通，不用自己手写分布式缓存逻辑；</span></span></p>\n<p><span><span>你需要同端互斥登录？一行代码StpUtil.setLoginId(10001, \"PC\")就能指定设备登录，踢掉同设备的其他登录会话，像QQ一样灵活，不用自己处理设备标识、会话冲突。</span></span></p>\n<p><span><span>除此之外，Sa-Token还支持OAuth2.0、单点登录、密码加密、临时身份切换、会话自动续期等几十项功能，涵盖了大部分业务场景的解决方案，真正做到了“一站式鉴权”。而且它的体积极小，依赖极少，引入项目后不会增加额外的负担，无论是中小型项目，还是大型微服务项目，都能完美适配。</span></span></p>\n<p><span><span>更难得的是，Sa-Token的文档非常完善，每一个功能都有详细的说明、代码示例，甚至还有常见问题的解决方案；社区也非常活跃，遇到问题能快速得到响应，作者也会持续更新，修复漏洞、新增功能——七年磨一剑，Sa-Token从最初的一个小工具，成长为如今国内最受欢迎的轻量级鉴权框架之一，靠的不是宣传，而是无数开发者的口碑积累。</span></span></p>\n<p><span><span>我从事Java开发10年，用过无数款框架，有的框架追求极致的强大，有的框架追求极致的灵活，但只有Sa-Token，追求极致的“懂你”。它不用你改变自己的开发习惯，不用你花费大量时间学习，只用最简单的方式，帮你搞定最复杂的鉴权难题，让你能把更多的精力放在业务逻辑上，放在自己真正想做的事情上——这，就是Sa-Token最动人的地方。</span></span></p>\n<h2><span><span>三、Sa-Token入门：手把手教学，新手也能一次上手</span></span></h2>\n<p><span><span>说了这么多，相信大家已经对Sa-Token充满了期待。接下来，我就带着大家手把手入门Sa-Token，全程贴合真实开发场景，不搞花里胡哨的操作，不讲晦涩难懂的概念，每一步都简单易懂，新手也能一次上手。（本次入门基于SpringBoot 2.x/3.x，这也是目前最主流的开发环境，适配绝大多数项目）</span></span></p>\n<h3><span><span>第一步：环境准备，30秒搞定依赖</span></span></h3>\n<p><span><span>Sa-Token的集成非常简单，不用配置复杂的环境，只要你的项目是SpringBoot项目，只需在pom.xml中添加一行依赖，就能完成集成——这也是Sa-Token“开箱即用”的体现。</span></span></p>\n<p><span><span>首先，确保你的项目是SpringBoot项目（如果不是，创建一个基础的SpringBoot项目即可，勾选Web依赖），然后在pom.xml中添加以下依赖：</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>cn.dev33<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">groupId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>sa-token-spring-boot-starter<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">artifactId</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span>1.44.0<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">version</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span> <span style=\"color: rgba(0, 128, 0, 1);\">&lt;!--</span><span style=\"color: rgba(0, 128, 0, 1);\"> 版本号可自行更新到最新 </span><span style=\"color: rgba(0, 128, 0, 1);\">--&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1);\">dependency</span><span style=\"color: rgba(0, 0, 255, 1);\">&gt;</span></pre>\n</div>\n<p><span><span>添加完依赖后，刷新Maven，依赖就会自动下载完成。这里不需要任何额外的配置，Sa-Token会自动进行零配置初始化，哪怕你什么都不写，也能正常使用核心功能——这一点，比Spring Security和Shiro简单太多。</span></span></p>\n<p><span><span>补充说明：如果你的项目需要分布式会话（比如微服务项目），可以额外集成Redis依赖，Sa-Token会自动适配，不用手动配置；如果是单体项目，不用集成Redis，Sa-Token会使用内存存储会话，足够满足日常开发需求。</span></span></p>\n<h3><span><span>第二步：核心API上手，5分钟搞定登录、授权</span></span></h3>\n<p><span><span>Sa-Token的核心API非常简洁，所有常用操作都封装在StpUtil工具类中，不用你记复杂的类名、方法名，只要记住几个核心方法，就能搞定80%的鉴权需求。下面，我们就结合最常见的“登录认证”和“权限控制”，手把手教大家使用。</span></span></p>\n<h4><span><span>1. 登录认证：一行代码搞定，不用任何配置</span></span></h4>\n<p><span><span>登录认证是鉴权的基础，无论是后台管理系统，还是小程序、APP接口，都离不开登录认证。在Sa-Token中，登录认证只需两行代码：一行标记登录，一行校验登录。</span></span></p>\n<p><span><span>首先，创建一个测试Controller，编写登录接口：</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> cn.dev33.satoken.stp.StpUtil;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.springframework.web.bind.annotation.GetMapping;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.springframework.web.bind.annotation.RestController;\n\n@RestController\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> LoginController {\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 登录接口：模拟用户登录，实际开发中需替换为数据库查询逻辑</span>\n    @GetMapping(\"/login\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> String login(String username, String password) {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 模拟数据库校验（实际开发中，这里需要查询数据库，比对用户名密码）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (\"admin\".equals(username) &amp;&amp; \"123456\"<span style=\"color: rgba(0, 0, 0, 1);\">.equals(password)) {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2. 一行代码标记当前会话登录，参数为用户ID（可以是数字、字符串等任意类型）</span>\n            StpUtil.setLoginId(10001); <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 这里的10001，就是当前登录用户的唯一标识</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">return</span> \"登录成功！欢迎回来，admin\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> \"用户名或密码错误！\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 校验登录接口：只有登录后才能访问</span>\n    @GetMapping(\"/info\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> String getInfo() {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 一行代码校验当前会话是否登录：未登录会抛出NotLoginException异常</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        StpUtil.checkLogin();\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2. 获取当前登录用户ID（与登录时传入的ID一致）</span>\n        Object loginId =<span style=\"color: rgba(0, 0, 0, 1);\"> StpUtil.getLoginId();\n        \n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 返回用户信息（实际开发中，这里需要根据loginId查询数据库，返回真实用户信息）</span>\n        <span style=\"color: rgba(0, 0, 255, 1);\">return</span> \"登录成功！当前登录用户ID：\" + loginId + \"，用户角色：超级管理员\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 退出登录接口</span>\n    @GetMapping(\"/logout\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> String logout() {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 一行代码标记当前会话退出登录</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">        StpUtil.logout();\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> \"退出登录成功！欢迎下次再来\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n    }\n}</span></pre>\n</div>\n<p><span><span>写到这里，很多朋友可能会有疑问：不用配置过滤器吗？不用自定义Realm吗？不用处理Token传递吗？</span></span></p>\n<p><span><span>答案是：不用！Sa-Token已经帮你全部处理好了。当你调用StpUtil.setLoginId(10001)时，Sa-Token会自动生成一个Token，并存入会话；当你访问需要校验登录的接口时，Sa-Token会自动从请求头、Cookie中读取Token，校验会话状态——你不用写一行额外的配置，不用处理任何细节，只用关注自己的业务逻辑即可。</span></span></p>\n<p><span><span>测试方法也很简单：启动项目后，用Postman或浏览器访问接口：</span></span></p>\n<ol class=\"list-paddingleft-1\">\n<li>\n<p><span><span>访问&nbsp;<span><span>http://localhost:8080/login?username=admin&amp;password=123456<span><span>&nbsp;，返回“登录成功”；</span></span></span></span></span></span></p>\n</li>\n<li>\n<p><span><span>访问&nbsp;<span><span>http://localhost:8080/info<span><span>&nbsp;，返回登录用户信息（说明校验成功）；</span></span></span></span></span></span></p>\n</li>\n<li>\n<p><span><span>访问&nbsp;<span><span>http://localhost:8080/logout<span><span>&nbsp;，返回“退出登录成功”；</span></span></span></span></span></span></p>\n</li>\n<li>\n<p><span><span>退出后再访问&nbsp;<span><span>http://localhost:8080/info<span><span>&nbsp;，会抛出未登录异常（说明校验生效）。</span></span></span></span></span></span></p>\n</li>\n</ol>\n<h4><span><span>2. 权限控制：一个注解搞定，优雅又高效</span></span></h4>\n<p><span><span>登录认证搞定后，接下来就是权限控制——比如，普通用户不能访问后台管理接口，只有超级管理员才能执行删除操作。在Sa-Token中，权限控制不用写复杂的逻辑判断，一个注解就能搞定。</span></span></p>\n<p><span><span>首先，我们需要告诉Sa-Token，当前登录用户拥有哪些角色、哪些权限。这里需要实现Sa-Token提供的StpInterface接口，重写两个方法（获取角色、获取权限）：</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> cn.dev33.satoken.stp.StpInterface;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.springframework.stereotype.Component;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.ArrayList;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> java.util.List;\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 必须加上@Component注解，让Spring扫描到，Sa-Token会自动调用</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">@Component\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span> StpInterfaceImpl <span style=\"color: rgba(0, 0, 255, 1);\">implements</span><span style=\"color: rgba(0, 0, 0, 1);\"> StpInterface {\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">/**</span><span style=\"color: rgba(0, 128, 0, 1);\">\n     * 返回当前登录用户拥有的角色（权限与角色可单独使用，也可结合使用）\n     * </span><span style=\"color: rgba(128, 128, 128, 1);\">@param</span><span style=\"color: rgba(0, 128, 0, 1);\"> loginId 当前登录用户ID\n     * </span><span style=\"color: rgba(128, 128, 128, 1);\">@param</span><span style=\"color: rgba(0, 128, 0, 1);\"> loginType 登录类型（默认值：login，多账号体系时会用到）\n     * </span><span style=\"color: rgba(128, 128, 128, 1);\">@return</span><span style=\"color: rgba(0, 128, 0, 1);\"> 角色列表（比如：[\"super-admin\", \"admin\"]）\n     </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    @Override\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> List&lt;String&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> getRoleList(Object loginId, String loginType) {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 实际开发中，这里需要根据loginId查询数据库，获取该用户的角色列表\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 这里模拟：用户ID=10001拥有超级管理员角色（super-admin）</span>\n        List&amp;lt;String&amp;gt; roleList = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> ArrayList&lt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (loginId.equals(10001<span style=\"color: rgba(0, 0, 0, 1);\">)) {\n            roleList.add(</span>\"super-admin\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> roleList;\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">/**</span><span style=\"color: rgba(0, 128, 0, 1);\">\n     * 返回当前登录用户拥有的权限\n     * </span><span style=\"color: rgba(128, 128, 128, 1);\">@param</span><span style=\"color: rgba(0, 128, 0, 1);\"> loginId 当前登录用户ID\n     * </span><span style=\"color: rgba(128, 128, 128, 1);\">@param</span><span style=\"color: rgba(0, 128, 0, 1);\"> loginType 登录类型\n     * </span><span style=\"color: rgba(128, 128, 128, 1);\">@return</span><span style=\"color: rgba(0, 128, 0, 1);\"> 权限列表（比如：[\"user:add\", \"user:delete\"]）\n     </span><span style=\"color: rgba(0, 128, 0, 1);\">*/</span><span style=\"color: rgba(0, 0, 0, 1);\">\n    @Override\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> List&lt;String&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> getPermissionList(Object loginId, String loginType) {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 实际开发中，这里需要根据loginId查询数据库，获取该用户的权限列表\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 这里模拟：用户ID=10001拥有用户添加、删除、查询的权限</span>\n        List&amp;lt;String&amp;gt; permissionList = <span style=\"color: rgba(0, 0, 255, 1);\">new</span> ArrayList&lt;&gt;<span style=\"color: rgba(0, 0, 0, 1);\">();\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (loginId.equals(10001<span style=\"color: rgba(0, 0, 0, 1);\">)) {\n            permissionList.add(</span>\"user:add\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n            permissionList.add(</span>\"user:delete\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n            permissionList.add(</span>\"user:select\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> permissionList;\n    }\n}</span></pre>\n</div>\n<p><span><span>实现完接口后，我们就可以在Controller中使用注解进行权限控制了，常用的注解有三个：</span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li>\n<p><span><span>@SaCheckLogin：校验当前会话是否登录（和StpUtil.checkLogin()功能一致）；</span></span></p>\n</li>\n<li>\n<p><span><span>@SaCheckRole(\"角色标识\")：校验当前用户是否拥有指定角色；</span></span></p>\n</li>\n<li>\n<p><span><span>@SaCheckPermission(\"权限标识\")：校验当前用户是否拥有指定权限。</span></span></p>\n</li>\n</ul>\n<p><span><span>下面，我们编写一个权限控制的测试接口：</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> cn.dev33.satoken.annotation.SaCheckPermission;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> cn.dev33.satoken.annotation.SaCheckRole;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.springframework.web.bind.annotation.GetMapping;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">import</span><span style=\"color: rgba(0, 0, 0, 1);\"> org.springframework.web.bind.annotation.RestController;\n\n@RestController\n</span><span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">class</span><span style=\"color: rgba(0, 0, 0, 1);\"> PermissionController {\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 1. 校验角色：只有拥有super-admin角色的用户才能访问</span>\n    @SaCheckRole(\"super-admin\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n    @GetMapping(</span>\"/admin/manager\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> String adminManager() {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> \"超级管理员专属接口：可以管理所有用户\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 2. 校验权限：只有拥有user:delete权限的用户才能访问</span>\n    @SaCheckPermission(\"user:delete\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n    @GetMapping(</span>\"/user/delete\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> String deleteUser() {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> \"权限校验通过：可以执行用户删除操作\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 3. 多重校验：拥有super-admin角色 或 user:add权限的用户才能访问</span>\n    @SaCheckRole(value = \"super-admin\", mode =<span style=\"color: rgba(0, 0, 0, 1);\"> SaMode.OR)\n    @SaCheckPermission(value </span>= \"user:add\", mode =<span style=\"color: rgba(0, 0, 0, 1);\"> SaMode.OR)\n    @GetMapping(</span>\"/user/add\"<span style=\"color: rgba(0, 0, 0, 1);\">)\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">public</span><span style=\"color: rgba(0, 0, 0, 1);\"> String addUser() {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> \"校验通过：可以执行用户添加操作\"<span style=\"color: rgba(0, 0, 0, 1);\">;\n    }\n}</span></pre>\n</div>\n<p><span><span>测试方法：登录成功后（用户ID=10001，拥有super-admin角色和对应的权限），访问以上三个接口，都会返回成功信息；如果我们模拟一个普通用户（没有super-admin角色、没有user:delete权限）登录，访问这些接口，就会抛出权限不足的异常——这就是Sa-Token注解式鉴权的魅力，优雅、简洁，且易于维护。</span></span></p>\n<h3><span><span>第三步：常用功能补充，搞定开发中高频场景</span></span></h3>\n<p><span><span>除了登录认证和权限控制，开发中还有很多高频的鉴权场景，比如踢人下线、Token续期、同端互斥登录等。这些功能在Sa-Token中，也都是一行代码就能搞定，下面给大家补充几个最常用的：</span></span></p>\n<h4><span><span>1. 踢人下线（强制注销）</span></span></h4>\n<p><span><span>场景：后台管理系统中，管理员发现某个用户异常登录，需要强制让该用户退出登录。</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 一行代码：强制让用户ID=10002的所有会话退出登录（踢人下线）\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 该用户下次访问任何需要登录的接口时，都会抛出未登录异常</span>\nStpUtil.logoutByLoginId(10002);</pre>\n</div>\n<h4><span><span>2. 同端互斥登录</span></span></h4>\n<p><span><span>场景：小程序中，一个账号只能在一个手机上登录，登录新手机后，旧手机会自动退出登录（类似QQ的同端互斥）。</span></span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 一行代码：指定设备标识登录，参数2为设备标识（比如PC、APP、WECHAT）</span>\nStpUtil.setLoginId(10001, \"WECHAT\"); <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 微信小程序端登录\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 一行代码：强制让用户ID=10001在WECHAT端的旧会话退出登录</span>\nStpUtil.logoutByLoginId(10001, \"WECHAT\");</pre>\n</div>\n<h4><span><span>3. Token自动续期</span></span></h4>\n<p><span><span>场景：用户长时间操作系统，Token过期后不需要重新登录，自动续期。</span></span></p>\n<p><span><span>Sa-Token默认支持Token自动续期，只需在application.yml中添加简单配置即可：</span></span></p>\n<div class=\"cnblogs_code\">\n<pre>sa-<span style=\"color: rgba(0, 0, 0, 1);\">token:\n  timeout: </span><span style=\"color: rgba(128, 0, 128, 1);\">86400</span><span style=\"color: rgba(0, 0, 0, 1);\"> # Token有效期（秒），默认24小时\n  active</span>-timeout: <span style=\"color: rgba(128, 0, 128, 1);\">3600</span><span style=\"color: rgba(0, 0, 0, 1);\"> #  Token活跃有效期（秒），默认1小时\n  # 说明：如果用户在1小时内有操作，Token自动续期24小时；如果1小时内无操作，Token过期</span></pre>\n</div>\n<p><span><span>以上就是Sa-Token的核心入门内容，其实还有很多强大的功能（比如单点登录、OAuth2.0、密码加密等），但对于大多数开发者来说，掌握上面的内容，已经能搞定日常开发中90%以上的鉴权需求了。而且这些功能的使用方式都非常简单，只要记住StpUtil工具类，就能灵活运用。</span></span></p>\n<h2><span><span>最后：致每一位正在和鉴权内耗的Java开发者</span></span></h2>\n<p><span><span>10年的开发之路，我见过太多开发者因为复杂的鉴权框架，消耗了大量的时间和精力，甚至磨灭了对开发的热情。我们做开发，本该是专注于业务逻辑、打造有价值的产品，而不是被繁琐的鉴权代码束缚手脚。</span></span></p>\n<p><span><span>Sa-Token的出现，不是为了取代任何一款框架，而是为了给大家多一个选择——一个简单、高效、易用的选择。它不要求你精通复杂的架构设计，不要求你拥有多年的开发经验，只要你会写简单的Java代码，就能用它搞定所有鉴权难题。</span></span></p>\n<p><span><span>我还记得，第一次用Sa-Token的时候，那种“豁然开朗”的感觉——以前花一天才能搞定的登录、权限逻辑，用Sa-Token只用了十几分钟；以前反复调试的跨域、Token过期问题，用Sa-Token后再也没有出现过。从那以后，我所有的项目，无论是中小型单体项目，还是大型微服务项目，都会优先选择Sa-Token。</span></span></p>\n<p><span><span>今天，我把Sa-Token推荐给大家，不是因为它有多“完美”，而是因为它懂你的痛点，能帮你节省时间，能让你从鉴权内耗中解脱出来，把更多的精力放在自己真正想做的事情上。</span></span></p>\n<p><span><span>如果你还在为Spring Security的复杂配置头疼，还在为Shiro的适配问题熬夜，不妨试试Sa-Token。相信我，它会给你带来惊喜——原来鉴权可以这么简单，原来开发可以这么轻松。</span></span></p>\n<p><span><span>后续，我还会分享Sa-Token的高级用法（单点登录、OAuth2.0、微服务鉴权等），如果大家有任何疑问，也可以在评论区留言，我会一一为大家解答。</span></span></p>\n<p><span><span>愿每一位Java开发者，都能摆脱鉴权内耗，专注业务，不负热爱，在开发的道路上越走越远。</span></span></p>\n<hr />\n<p><span style=\"background-color: rgba(0, 204, 255, 1); font-size: 18px;\">可以点击下面链接【<a href=\"https://mp.weixin.qq.com/s/JLQSMAgqK1U0vtrdtRsKlA\" rel=\"noopener nofollow\" target=\"_blank\" title=\"Sa-Token(一)之简介及入门：告别鉴权内耗，让每一位Java开发者都能轻松上手\"><span style=\"background-color: rgba(0, 204, 255, 1);\">阅读原文</span></a>】</span></p>\n<p><span style=\"font-size: 18px;\"><a href=\"https://mp.weixin.qq.com/s/JLQSMAgqK1U0vtrdtRsKlA\" rel=\"noopener nofollow\">Sa-Token(一)之简介及入门：告别鉴权内耗，让每一位Java开发者都能轻松上手</a><a class=\"ng-star-inserted\" href=\"https://www.cnblogs.com/philry/p/19534679\" rel=\"noopener\" target=\"_blank\"><br /></a></span></p>\n<p>&nbsp;</p>\n<p><em><strong><span style=\"font-size: 18px;\">创作不易，<span>还请家人们关注下公众下支持，小编不胜感激。</span></span></strong></em></p>\n<p><span style=\"background-color: rgba(0, 204, 255, 1); font-size: 18px;\"><strong>更多精彩关注微信公众号：</strong></span></p>\n<p><span style=\"background-color: rgba(0, 204, 255, 1); font-size: 18px;\"><strong>AI大芒果2.0</strong></span></p>\n<p><span style=\"font-size: 18px;\"><strong><strong>10年技术人：3年AI+7年java开发者的技术沉淀及人生感悟。</strong></strong></span></p>\n<p><img alt=\"微信公众号二维码\" class=\"lazyload\" height=\"374\" width=\"374\" /><img alt=\"群二维码\" class=\"lazyload\" height=\"523\" width=\"374\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 09:58</span>&nbsp;\n<a href=\"https://www.cnblogs.com/philry\">AI大芒果2点0</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【译】Visual Studio 一月更新 —— 增强的编辑器体验",
      "link": "https://www.cnblogs.com/MeteorSeed/p/19600128",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/MeteorSeed/p/19600128\" id=\"cb_post_title_url\" title=\"发布于 2026-02-11 09:56\">\n    <span>【译】Visual Studio 一月更新 —— 增强的编辑器体验</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1><span><span>生产力提升</span></span></h1>\n<p><span>　　本月，我们为您带来了一系列虽小但长期以来备受期待且广受欢迎的功能，让您能更好地控制和自定义您的编辑器。这些功能目前仅在 Insiders 可用，很快将在正式版中推出。</span></p>\n<p><span><span>　　<strong>- 快速滚动</strong>：在查看代码或阅读文档时，按住 Alt 键同时滚动鼠标滚轮可快速移动。您可以在 Tools &gt; Options &gt; Text Editor &gt; Advanced &gt; Touchpad and mouse wheel scrolling sensitivity 中调整快速滚动速度。</span></span></p>\n<p><span><span>　　<strong>- 中键滚动</strong>：按下滚轮并移动鼠标，可快速滚动浏览文档，便于查看大型文件。此功能默认处于关闭状态，需要通过 Tools &gt; Options &gt; Text Editor &gt; Advanced &gt; Middle click to scroll 来启用。</span></span></p>\n<p><span><span>　　<strong>- 富 HTML 格式的复制粘贴</strong>：Visual Studio 现在支持在从编辑器中剪切或复制代码时使用 HTML 剪贴板格式。您可以将带有颜色的代码粘贴到 Office 的网页版、Azure DevOps 工作项或其他基于 HTML 的控件中。此功能在最新的 Insiders 版本中可用，不久后将在 Release 发布。</span></span></p>\n<p><span><span>　　<strong>- 语法行压缩</strong>：不包含字母或数字的行将被压缩 25%，让您可以一次查看更多代码。常规行保持原高度不变。您可以通过依次点击 Tools &gt; Options &gt; Text Editor &gt; Advanced，勾选 Compress blank lines 和 Compress lines that do not have any alphanumeric characters 来启用此功能。</span></span></p>\n<p><span><span>　　<strong>- 更窄的左侧边距</strong>：我们听说您希望左侧边距更窄一些，以便为代码留出更多水平空间！为了节省额外的列宽，我们已将快速操作图标（灯泡或螺丝刀图标）从边距处移到了编辑器内，当有修复或重构建议时，该图标会与您的代码内联显示。要立即体验此功能，请前往 Tools &gt; Options &gt; Text Editor &gt; Advanced，然后勾选 Show Quick Actions icon inside the editor。</span></span></p>\n<p><span>　　我们还将推出更多自定义的边距控制功能，敬请期待！</span></p>\n<h1><span><span>彩色代码补全</span></span></h1>\n<p><span>　　代码补全现在采用语法高亮进行着色，帮助您快速区分建议代码中的变量、函数和其他元素！要体验此功能，请前往 Tools &gt; Options &gt; Text Editor &gt; Code Completions，并勾选 Use colorized text for code completions。该功能目前仅在 Insiders 中可用。</span></p>\n<p><span>　　为了区分建议内容和实际代码，彩色补全功能采用了较低的不透明度和斜体样式。如果您想进一步自定义外观，请前往 Tools &gt; Options &gt; Environment &gt; Fonts and Colors，然后在 Display 中选择 Code Completions。在那里，您可以自定义字体、大小、前景色/背景色以及样式（粗体、斜体等）。</span></p>\n<h1><span><span>点击部分接受代码补全</span></span></h1>\n<p><span>　　您是否曾经希望只需一次点击就能部分接受代码补全？有了这项新功能，您可以直接点击建议中的某处，接受光标位置之前的内容。当您将鼠标悬停在建议上时，每个片段都会高亮显示，确切地展示将要接受的内容。目前，这项功能仅在 Insiders 中可用。</span></p>\n<p><span><img alt=\"1\" src=\"https://img2024.cnblogs.com/blog/270073/202602/270073-20260210153029546-909619206.gif\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p><span>　　此功能让您能更好地控制想要接受的补全内容量。如果您更喜欢使用键盘，仍然可以按&nbsp;<span>Ctrl+右箭头&nbsp;一次接受一个单词，或按&nbsp;<span>Ctrl+下箭头&nbsp;一次接受一行。</span></span></span></p>\n<h1><span><span>精简的 Markdown 预览控制</span></span></h1>\n<p><span>　　Visual Studio Markdown 编辑器现在为您提供更快捷、更清晰的预览选项访问方式：</span></p>\n<p><span><span>　　- 在预览模式间切换：Split Preview 模式会将编辑器和预览窗口并排显示，Open Preview 模式仅显示预览窗口，而 Edit Markdown 模式则只显示编辑器。Preview-only 模式能帮助您专注于已渲染的内容，尤其是在查看大型图片或复杂的 Mermaid 图表时。</span></span></p>\n<p><span>　　- 预览 Mermaid 图表时，请使用左上角的缩放控件进行放大或缩小，以获得更好的可读性。</span></p>\n<p><span>　　- 当Copilot Chat 生成 markdown 内容时，点击聊天窗口右上角的 Preview 按钮即可查看渲染后的视图。之后，您可以直接编辑并保存内容，无需手动复制粘贴。</span></p>\n<p><span>　　想要体验所有这些最新的好功能，请定期更新您的 Visual Studio，如果还没有加入我们的 Insiders 频道，那就赶紧加入吧！（注意：本博客文章中分享的所有功能仅在 Visual Studio 2026 中可用。）请试用这些功能，并告诉我们您的任何反馈，以及您接下来希望看到的功能！</span></p>\n<p>&nbsp;</p>\n<p><span>原文链接：https://devblogs.microsoft.com/visualstudio/visual-studio-january-update-enhanced-editor-experience/</span></p>\n<p><span><img alt=\"me\" src=\"https://img2024.cnblogs.com/blog/270073/202509/270073-20250926105511928-738986494.webp\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p>&nbsp;</p>\n\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p><strong>作者：</strong><a href=\"http://www.cnblogs.com/MeteorSeed\">MeteorSeed</a></p>\n<p><strong>我希望您喜欢这篇博文，并一如既往地感谢您阅读并与朋友和同事分享我的博文。</strong></p>\n<p><strong>转载请注明出处。</strong></p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-11 09:56</span>&nbsp;\n<a href=\"https://www.cnblogs.com/MeteorSeed\">MeteorSeed</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大模型RAG实战，从被骂不靠谱到成为部门MVP，这是我的踩坑全记录",
      "link": "https://www.cnblogs.com/bu-huo/p/19601644",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/bu-huo/p/19601644\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 22:10\">\n    <span>大模型RAG实战，从被骂不靠谱到成为部门MVP，这是我的踩坑全记录</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"一切的起点是一顿臭骂\">一切的起点是一顿臭骂</h2>\n<p>上个月，我被领导叫进办公室骂了整整二十分钟。</p>\n<p>起因是这样的——我们部门负责维护一套内部知识库系统，里面沉淀了公司近五年的技术文档、故障处理手册、还有各种规范流程。问题是，这玩意儿除了当摆设，几乎没人用。为啥？因为搜索太烂了，关键词匹配的那种，你搜服务器宕机怎么办，它给你返回一堆包含服务器的文档，真正有用的那篇反而排在第三页。</p>\n<p>新同事入职问问题，老员工翻文档找答案，大家宁可在群里@人问，也不愿意去知识库里查。</p>\n<p>然后领导发话了：你不是天天研究什么大模型吗？能不能整个智能问答，让大家直接问问题就能得到答案？</p>\n<p>我当时脑子一热，拍胸脯说没问题。结果第一版上线三天就被骂下来了——用户问我们的MySQL主从切换流程是什么，大模型回答得头头是道，但内容完全是它自己编的！跟我们公司的实际流程八竿子打不着。</p>\n<p>这就是所谓的大模型幻觉问题，我当时对RAG的理解还停留在把文档丢进去就行的水平，太天真了。</p>\n<p>不过，后来的故事还算圆满。我花了将近三周时间重构了整个方案，现在这套系统已经成了部门的标配工具，月活跃用户从0涨到了200多，领导在季度会上还专门表扬了一回。今天这篇文章，我就把整个踩坑过程原原本本地记录下来，包括代码、架构设计、以及那些教科书上不会告诉你的实战细节。</p>\n<h2 id=\"一rag到底在解决什么问题\">一、RAG到底在解决什么问题</h2>\n<p>在动手之前，我想先聊聊RAG这个概念，因为很多刚接触的朋友容易搞混。<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>大模型很强，但它有两个致命弱点：</p>\n<p><strong>第一，知识有截止日期。</strong> GPT-4的训练数据截止到某个时间点，它不知道你们公司上周发布的新规范，也不知道你们昨天刚修复的那个bug是怎么解决的。</p>\n<p><strong>第二，会一本正经地胡说八道。</strong> 当大模型遇到它不知道的问题时，它不会老老实实说我不知道，而是会基于它学过的通用知识，给你编一个看起来很合理但其实是错的答案。这就是所谓的幻觉（Hallucination）。</p>\n<p>RAG（Retrieval-Augmented Generation，检索增强生成）的核心思路其实很简单：<strong>别让大模型靠想象力答题，先帮它把参考资料找出来，让它照着资料回答。</strong><br />\n<img alt=\"image.png\" class=\"lazyload\" /><br />\n具体来说分三步：</p>\n<ol>\n<li>把你的私有文档切成小块，转成向量存起来</li>\n<li>用户提问时，先根据问题检索出最相关的文档片段</li>\n<li>把问题和检索到的内容一起喂给大模型，让它基于这些材料生成答案</li>\n</ol>\n<p>听起来不复杂对吧？我当时也是这么想的，然后就踩了一堆坑。</p>\n<h2 id=\"二第一个大坑文档切分没那么简单\">二、第一个大坑：文档切分没那么简单</h2>\n<p>我最初的方案特别粗暴——用LangChain的RecursiveCharacterTextSplitter，设置chunk_size=500，overlap=50，直接把所有文档切成小块。<br />\n<img alt=\"image.png\" class=\"lazyload\" /><br />\n代码写起来确实很简单：</p>\n<pre><code class=\"language-python\">from langchain.text_splitter import RecursiveCharacterTextSplitter\n\ndef naive_split(text):\n    最初的简单切分方案——后来证明这是个坑\n    splitter = RecursiveCharacterTextSplitter(\n        chunk_size=500,\n        chunk_overlap=50,\n        separators=[\\n\\n, \\n, 。, ！, ？,  , ]\n    )\n    chunks = splitter.split_text(text)\n    return chunks\n\n# 测试一下\nsample_text = \n# MySQL主从切换操作手册\n\n## 1. 前置检查\n在执行主从切换之前，必须完成以下检查：\n- 确认从库同步状态正常（Seconds_Behind_Master = 0）\n- 确认没有正在执行的大事务\n- 通知相关业务方，确认切换时间窗口\n\n## 2. 切换步骤\n2.1 在主库执行只读设置\nSET GLOBAL read_only = 1;\n\n2.2 等待从库完全同步\n在从库执行 SHOW SLAVE STATUS，确认 Seconds_Behind_Master = 0\n\n2.3 停止从库复制\nSTOP SLAVE;\nRESET SLAVE ALL;\n\n## 3. 回滚方案\n如果切换失败，按以下步骤回滚...\n\n\nchunks = naive_split(sample_text)\nfor i, chunk in enumerate(chunks):\n    print(f Chunk {i+1} )\n    print(chunk[:100] + ... if len(chunk) &gt; 100 else chunk)\n</code></pre>\n<p>看起来没毛病是吧？但实际用起来问题大了。</p>\n<p>有一次用户问：MySQL切换前需要做哪些检查？系统返回的文档片段是这样的：</p>\n<pre><code>确认没有正在执行的大事务\n- 通知相关业务方，确认切换时间窗口\n\n## 2. 切换步骤\n2.1 在主库执行只读设置\nSET GLOBAL read_only = 1;\n</code></pre>\n<p>发现问题了吗？这个片段恰好从检查步骤的中间切开了！第一条检查项确认从库同步状态正常被切到了上一个chunk里。用户问的是需要做哪些检查，结果我们给大模型的参考资料里，第一条检查项就没包含进去。</p>\n<p><strong>核心教训：机械地按字数切分，会打断文档的语义完整性。</strong></p>\n<p>后来我改成了基于语义结构的切分策略：</p>\n<pre><code class=\"language-python\">import re\nfrom typing import List, Dict\n\nclass SmartDocumentSplitter:\n    \n    语义感知的文档切分器\n    核心思路：尊重文档的原有结构，按标题、段落等语义边界切分\n    \n    \n    def __init__(self, max_chunk_size=800, min_chunk_size=100):\n        self.max_chunk_size = max_chunk_size\n        self.min_chunk_size = min_chunk_size\n    \n    def split_markdown(self, text: str) -&gt; List[Dict]:\n        \n        针对Markdown文档的切分\n        保持标题层级结构，每个chunk都带上完整的上下文路径\n        \n        chunks = []\n        current_headers = {1: , 2: , 3: }  # 记录当前的标题层级\n        \n        # 按行处理，识别标题和内容\n        lines = text.split('\\n')\n        current_content = []\n        \n        for line in lines:\n            # 检测Markdown标题\n            header_match = re.match(r'^(#{1,3})\\s+(.+)$', line)\n            \n            if header_match:\n                # 遇到新标题，先保存之前的内容\n                if current_content:\n                    chunk_text = '\\n'.join(current_content).strip()\n                    if len(chunk_text) &gt;= self.min_chunk_size:\n                        chunks.append({\n                            'content': chunk_text,\n                            'headers': dict(current_headers),\n                            'context_path': self._build_context_path(current_headers)\n                        })\n                    current_content = []\n                \n                # 更新标题层级\n                level = len(header_match.group(1))\n                title = header_match.group(2)\n                current_headers[level] = title\n                \n                # 清除下级标题\n                for l in range(level + 1, 4):\n                    current_headers[l] = \n                \n                current_content.append(line)\n            else:\n                current_content.append(line)\n                \n                # 如果当前内容超过最大长度，强制切分（但尽量在段落边界）\n                content_so_far = '\\n'.join(current_content)\n                if len(content_so_far) &gt; self.max_chunk_size:\n                    chunk_text = content_so_far.strip()\n                    chunks.append({\n                        'content': chunk_text,\n                        'headers': dict(current_headers),\n                        'context_path': self._build_context_path(current_headers)\n                    })\n                    current_content = []\n        \n        # 别忘了最后一段\n        if current_content:\n            chunk_text = '\\n'.join(current_content).strip()\n            if len(chunk_text) &gt;= self.min_chunk_size:\n                chunks.append({\n                    'content': chunk_text,\n                    'headers': dict(current_headers),\n                    'context_path': self._build_context_path(current_headers)\n                })\n        \n        return chunks\n    \n    def _build_context_path(self, headers: Dict) -&gt; str:\n        构建层级路径，比如：MySQL主从切换 &gt; 前置检查\n        path_parts = [h for h in [headers[1], headers[2], headers[3]] if h]\n        return ' &gt; '.join(path_parts) if path_parts else '未分类'\n    \n    def enrich_chunk_with_context(self, chunk: Dict) -&gt; str:\n        \n        关键技巧：给每个chunk加上上下文前缀\n        这样即使单独看这个片段，也能知道它属于哪个章节\n        \n        context = f[文档路径：{chunk['context_path']}]\\n\\n\n        return context + chunk['content']\n\n\n# 实际使用示例\nsplitter = SmartDocumentSplitter(max_chunk_size=800)\nchunks = splitter.split_markdown(sample_text)\n\nprint(f切分后共 {len(chunks)} 个片段\\n)\nfor i, chunk in enumerate(chunks):\n    print(f=== Chunk {i+1} ===)\n    print(f路径：{chunk['context_path']})\n    print(f内容预览：{chunk['content'][:150]}...)\n    print()\n</code></pre>\n<p>这样切出来的效果就好多了。每个chunk开头都会带上它的位置信息，大模型在回答时能更准确地理解这段内容的上下文。</p>\n<p>不过说实话，这个方案也不是万能的。对于那些格式不规范的老文档（没有清晰的标题结构），切分效果依然一般。后来我又针对不同类型的文档做了差异化处理，这个我们后面再说。</p>\n<h2 id=\"三第二个大坑向量检索的语义鸿沟\">三、第二个大坑：向量检索的语义鸿沟</h2>\n<p>解决了切分问题，下一步就是向量化和检索了。我用的是开源的BGE模型做Embedding，用Milvus做向量数据库。</p>\n<p>第一版的检索代码很直白：</p>\n<pre><code class=\"language-python\">from sentence_transformers import SentenceTransformer\nfrom pymilvus import connections, Collection, FieldSchema, CollectionSchema, DataType, utility\nimport numpy as np\n\nclass VectorStore:\n    向量存储和检索\n    \n    def __init__(self, model_name='BAAI/bge-base-zh-v1.5'):\n        # 加载Embedding模型\n        self.model = SentenceTransformer(model_name)\n        self.dim = 768  # BGE base模型的向量维度\n        \n        # 连接Milvus\n        connections.connect(default, host=localhost, port=19530)\n        \n    def create_collection(self, collection_name: str):\n        创建集合\n        if utility.has_collection(collection_name):\n            utility.drop_collection(collection_name)\n        \n        fields = [\n            FieldSchema(name=id, dtype=DataType.INT64, is_primary=True, auto_id=True),\n            FieldSchema(name=content, dtype=DataType.VARCHAR, max_length=4096),\n            FieldSchema(name=context_path, dtype=DataType.VARCHAR, max_length=512),\n            FieldSchema(name=embedding, dtype=DataType.FLOAT_VECTOR, dim=self.dim)\n        ]\n        schema = CollectionSchema(fields, description=知识库文档)\n        collection = Collection(collection_name, schema)\n        \n        # 创建索引\n        index_params = {\n            metric_type: COSINE,\n            index_type: IVF_FLAT,\n            params: {nlist: 128}\n        }\n        collection.create_index(embedding, index_params)\n        return collection\n    \n    def insert_documents(self, collection_name: str, chunks: list):\n        插入文档\n        collection = Collection(collection_name)\n        \n        contents = [chunk['content'] for chunk in chunks]\n        context_paths = [chunk['context_path'] for chunk in chunks]\n        \n        # 批量生成Embedding\n        embeddings = self.model.encode(contents, normalize_embeddings=True)\n        \n        collection.insert([contents, context_paths, embeddings.tolist()])\n        collection.flush()\n        print(f成功插入 {len(chunks)} 条文档)\n    \n    def search(self, collection_name: str, query: str, top_k: int = 5):\n        基础检索\n        collection = Collection(collection_name)\n        collection.load()\n        \n        # 生成查询向量\n        query_embedding = self.model.encode([query], normalize_embeddings=True)\n        \n        results = collection.search(\n            data=query_embedding.tolist(),\n            anns_field=embedding,\n            param={metric_type: COSINE, params: {nprobe: 16}},\n            limit=top_k,\n            output_fields=[content, context_path]\n        )\n        \n        return results[0]\n</code></pre>\n<p>基本功能是没问题的。但实际跑起来，我发现了一个让人抓狂的现象——<strong>用户的口语化提问和文档的正式表述之间存在巨大的语义鸿沟</strong>。</p>\n<p>举个例子：</p>\n<ul>\n<li>用户问：数据库挂了怎么办</li>\n<li>文档标题是：MySQL服务异常恢复操作手册</li>\n</ul>\n<p>这两个在语义上是相关的，但向量相似度可能并不高。因为用户说的挂了和文档里的异常，用词差异很大。</p>\n<p>更坑的是，有时候检索出的Top 5结果里，真正相关的那篇可能只排在第3或第4位，但前两名是一些看起来相关但实际上文不对题的内容。如果我只取Top 3喂给大模型，可能就漏掉了最关键的信息。</p>\n<p>后来我采用了一个两阶段检索的策略：<strong>先用向量检索做粗筛，再用重排序模型做精排。</strong></p>\n<pre><code class=\"language-python\">from transformers import AutoModelForSequenceClassification, AutoTokenizer\nimport torch\n\nclass EnhancedRetriever:\n    增强版检索器：向量检索 + 重排序\n    \n    def __init__(self, vector_store: VectorStore):\n        self.vector_store = vector_store\n        \n        # 加载重排序模型（BGE Reranker效果不错）\n        self.reranker_tokenizer = AutoTokenizer.from_pretrained('BAAI/bge-reranker-base')\n        self.reranker_model = AutoModelForSequenceClassification.from_pretrained('BAAI/bge-reranker-base')\n        self.reranker_model.eval()\n    \n    def retrieve_with_rerank(self, collection_name: str, query: str, \n                             initial_top_k: int = 20, final_top_k: int = 5):\n        \n        两阶段检索：\n        1. 向量检索召回 initial_top_k 个候选\n        2. 用重排序模型精排，返回 final_top_k 个结果\n        \n        # 第一阶段：向量检索（召回更多候选）\n        initial_results = self.vector_store.search(collection_name, query, top_k=initial_top_k)\n        \n        if not initial_results:\n            return []\n        \n        # 准备重排序\n        candidates = []\n        for hit in initial_results:\n            candidates.append({\n                'content': hit.entity.get('content'),\n                'context_path': hit.entity.get('context_path'),\n                'vector_score': hit.score  # 保留向量检索得分，用于调试\n            })\n        \n        # 第二阶段：重排序\n        rerank_scores = self._compute_rerank_scores(query, [c['content'] for c in candidates])\n        \n        for i, score in enumerate(rerank_scores):\n            candidates[i]['rerank_score'] = score\n        \n        # 按重排序分数排序\n        candidates.sort(key=lambda x: x['rerank_score'], reverse=True)\n        \n        return candidates[:final_top_k]\n    \n    def _compute_rerank_scores(self, query: str, documents: list) -&gt; list:\n        计算query和每个文档的相关性分数\n        scores = []\n        \n        with torch.no_grad():\n            for doc in documents:\n                # Reranker的输入格式是 [query, document]\n                inputs = self.reranker_tokenizer(\n                    [[query, doc]], \n                    padding=True, \n                    truncation=True, \n                    max_length=512, \n                    return_tensors='pt'\n                )\n                outputs = self.reranker_model(**inputs)\n                score = outputs.logits.squeeze().item()\n                scores.append(score)\n        \n        return scores\n    \n    def retrieve_with_query_expansion(self, collection_name: str, query: str, \n                                       llm_client, top_k: int = 5):\n        \n        进阶技巧：查询扩展\n        用大模型改写用户问题，生成多个变体，再合并检索结果\n        \n        # 让大模型帮我们扩展查询\n        expansion_prompt = f请将下面这个问题改写成3个不同的表达方式，保持意思相同但用词不同。\n每行输出一个改写结果，不要序号，不要其他解释。\n\n原问题：{query}\n        \n        expanded_queries = llm_client.generate(expansion_prompt).strip().split('\\n')\n        expanded_queries = [q.strip() for q in expanded_queries if q.strip()]\n        \n        # 加上原始查询\n        all_queries = [query] + expanded_queries[:3]  # 最多取3个扩展查询\n        \n        print(f扩展后的查询：{all_queries})  # 调试用\n        \n        # 对每个查询分别检索\n        all_candidates = {}\n        for q in all_queries:\n            results = self.vector_store.search(collection_name, q, top_k=10)\n            for hit in results:\n                content = hit.entity.get('content')\n                if content not in all_candidates:\n                    all_candidates[content] = {\n                        'content': content,\n                        'context_path': hit.entity.get('context_path'),\n                        'best_score': hit.score,\n                        'hit_count': 1\n                    }\n                else:\n                    # 被多个查询命中的文档，增加权重\n                    all_candidates[content]['hit_count'] += 1\n                    all_candidates[content]['best_score'] = max(\n                        all_candidates[content]['best_score'], \n                        hit.score\n                    )\n        \n        # 综合评分：命中次数 * 最高得分\n        candidates = list(all_candidates.values())\n        for c in candidates:\n            c['combined_score'] = c['hit_count'] * c['best_score']\n        \n        candidates.sort(key=lambda x: x['combined_score'], reverse=True)\n        return candidates[:top_k]\n</code></pre>\n<p>查询扩展这招特别好用。比如用户问数据库挂了怎么办，大模型可能会扩展成：</p>\n<ul>\n<li>MySQL服务故障如何处理</li>\n<li>数据库无法连接的解决方案</li>\n<li>数据库宕机恢复步骤</li>\n</ul>\n<p>这几个查询一起检索，能覆盖更多的相关文档。</p>\n<h2 id=\"四第三个大坑prompt工程的门道比想象中深\">四、第三个大坑：Prompt工程的门道比想象中深</h2>\n<p>检索的问题解决了，接下来就是把检索到的内容和用户问题一起喂给大模型了。这一步我本以为最简单，没想到也踩了不少坑。</p>\n<p>最初的Prompt特别朴素：</p>\n<pre><code class=\"language-python\">def build_naive_prompt(query: str, context_docs: list) -&gt; str:\n    最初的简单Prompt——后来证明太天真了\n    context = \\n\\n.join([doc['content'] for doc in context_docs])\n    \n    prompt = f根据以下参考资料回答用户问题。\n\n参考资料：\n{context}\n\n用户问题：{query}\n\n请回答：\n    \n    return prompt\n</code></pre>\n<p>这个Prompt有几个严重问题：</p>\n<p><strong>问题一：大模型不知道什么时候该说不知道。</strong> 当参考资料里确实没有答案时，它还是会编一个出来。</p>\n<p><strong>问题二：没有引导大模型说明信息来源。</strong> 用户看到答案，不知道是从哪篇文档里来的，无法追溯和验证。</p>\n<p><strong>问题三：对于复杂问题，回答的结构不够清晰。</strong></p>\n<p>后来迭代了很多版，最终稳定下来的Prompt是这样的：</p>\n<pre><code class=\"language-python\">def build_rag_prompt(query: str, context_docs: list, \n                     include_sources: bool = True) -&gt; str:\n    \n    生产环境使用的Prompt模板\n    关键设计：明确角色定位、限制回答范围、要求标注来源\n    \n    \n    # 格式化上下文，每段都标注来源\n    context_parts = []\n    for i, doc in enumerate(context_docs, 1):\n        source = doc.get('context_path', '未知来源')\n        context_parts.append(f【资料{i}，来源：{source}】\\n{doc['content']})\n    \n    context = \\n\\n\\n\\n.join(context_parts)\n    \n    prompt = f你是一个企业内部知识库助手，专门帮助员工查找和理解公司内部文档。\n\n## 你的工作准则\n\n1. **只根据提供的参考资料回答问题**，不要使用你自己的知识。\n2. 如果参考资料中没有相关信息，请明确说根据现有资料，我无法找到关于这个问题的信息，并建议用户联系相关部门或换个关键词搜索。\n3. 回答时请标注信息来源，格式如【资料1】，方便用户追溯原文。\n4. 对于操作类问题，请按步骤清晰地列出；对于概念类问题，先给出简明定义再展开解释。\n5. 如果不同资料中的信息有冲突，请指出差异并说明各自的适用场景。\n\n## 参考资料\n\n{context}\n\n## 用户问题\n\n{query}\n\n## 回答要求\n\n请根据上述参考资料回答用户问题。记住：\n- 只使用参考资料中的信息\n- 标注信息来源\n- 没有把握的内容不要编造\n\n    \n    return prompt\n\n\ndef build_conversational_prompt(query: str, context_docs: list, \n                                 chat_history: list = None) -&gt; str:\n    \n    支持多轮对话的Prompt\n    需要带上历史对话记录，让大模型理解上下文\n    \n    \n    context_parts = []\n    for i, doc in enumerate(context_docs, 1):\n        source = doc.get('context_path', '未知来源')\n        context_parts.append(f【资料{i}，来源：{source}】\\n{doc['content']})\n    context = \\n\\n\\n\\n.join(context_parts)\n    \n    # 格式化历史对话\n    history_text = \n    if chat_history:\n        history_parts = []\n        for turn in chat_history[-5:]:  # 只保留最近5轮，避免太长\n            history_parts.append(f用户：{turn['user']})\n            history_parts.append(f助手：{turn['assistant']})\n        history_text = \\n.join(history_parts)\n    \n    prompt = f你是一个企业内部知识库助手。\n\n## 参考资料\n\n{context}\n\n## 对话历史\n\n{history_text if history_text else （这是对话的开始）}\n\n## 当前问题\n\n用户：{query}\n\n## 回答准则\n\n1. 优先根据参考资料回答，如无相关信息请明确说明\n2. 考虑对话历史的上下文（如用户说它可能指代之前提到的概念）\n3. 标注信息来源\n\n助手：\n    \n    return prompt\n</code></pre>\n<p>关于Prompt，我还想分享一个很重要的经验：<strong>不要试图在一个Prompt里塞太多指令</strong>。</p>\n<p>一开始我把各种要求都写进去：回答要准确、要简洁、要友好、要专业、要标注来源、要分步骤、遇到不确定要说不知道……结果发现模型反而被绕晕了，有时候顾了这个忘了那个。</p>\n<p>后来我的做法是：<strong>区分核心指令和优化指令，核心指令必须保留，优化指令可以根据问题类型动态调整。</strong></p>\n<pre><code class=\"language-python\">class PromptBuilder:\n    Prompt构建器：根据问题类型动态调整\n    \n    # 核心指令——任何情况都必须包含\n    CORE_INSTRUCTIONS = \n1. 只使用参考资料中的信息回答，不要编造\n2. 资料中没有的信息，明确说无法找到相关信息\n3. 标注信息来源【资料X】\n\n    \n    # 操作类问题的额外指令\n    PROCEDURE_INSTRUCTIONS = \n回答格式要求：\n- 按步骤编号列出（第一步、第二步...）\n- 每个步骤要明确操作对象和操作动作\n- 重要的警告或注意事项用⚠️标出\n\n    \n    # 概念解释类问题的额外指令\n    CONCEPT_INSTRUCTIONS = \n回答格式要求：\n- 先用一句话给出核心定义\n- 再详细解释关键点\n- 如有必要，举例说明\n\n    # 故障排查类问题的额外指令\n    TROUBLESHOOT_INSTRUCTIONS = \n回答格式要求：\n- 先列出可能的原因\n- 针对每个原因给出排查方法\n- 给出解决方案或规避建议\n\n    \n    @classmethod\n    def build(cls, query: str, context_docs: list, question_type: str = general) -&gt; str:\n        根据问题类型构建Prompt\n        \n        # 简单的问题分类逻辑（实际项目中可以用分类模型）\n        if question_type == auto:\n            question_type = cls._classify_question(query)\n        \n        extra_instructions = \n        if question_type == procedure:\n            extra_instructions = cls.PROCEDURE_INSTRUCTIONS\n        elif question_type == concept:\n            extra_instructions = cls.CONCEPT_INSTRUCTIONS\n        elif question_type == troubleshoot:\n            extra_instructions = cls.TROUBLESHOOT_INSTRUCTIONS\n        \n        context = cls._format_context(context_docs)\n        \n        prompt = f你是企业内部知识库助手。\n\n## 必须遵守的规则\n{cls.CORE_INSTRUCTIONS}\n\n{f## 回答格式{extra_instructions} if extra_instructions else }\n\n## 参考资料\n{context}\n\n## 用户问题\n{query}\n\n请回答：\n        \n        return prompt\n    \n    @classmethod\n    def _classify_question(cls, query: str) -&gt; str:\n        简单的问题分类（基于关键词）\n        procedure_keywords = [怎么做, 如何操作, 步骤, 流程, 怎样]\n        concept_keywords = [是什么, 什么是, 定义, 解释, 区别]\n        troubleshoot_keywords = [为什么, 报错, 失败, 异常, 问题, 故障]\n        \n        query_lower = query.lower()\n        \n        if any(kw in query_lower for kw in procedure_keywords):\n            return procedure\n        elif any(kw in query_lower for kw in concept_keywords):\n            return concept\n        elif any(kw in query_lower for kw in troubleshoot_keywords):\n            return troubleshoot\n        else:\n            return general\n    \n    @classmethod\n    def _format_context(cls, context_docs: list) -&gt; str:\n        parts = []\n        for i, doc in enumerate(context_docs, 1):\n            source = doc.get('context_path', '未知来源')\n            parts.append(f【资料{i}，来源：{source}】\\n{doc['content']})\n        return \\n\\n\\n\\n.join(parts)\n</code></pre>\n<h2 id=\"五串起来完整的rag-pipeline\">五、串起来：完整的RAG Pipeline</h2>\n<p>前面说了一堆细节，现在把它们串成一个完整的Pipeline：<br />\n<img alt=\"Mermaid Chart - Create complex, visual diagrams with text.-2026-01-13-113354.png\" class=\"lazyload\" /></p>\n<pre><code class=\"language-python\">from openai import OpenAI\nfrom typing import List, Dict, Optional\nimport json\n\nclass RAGPipeline:\n    \n    完整的RAG处理流程\n    文档切分 -&gt; 向量化存储 -&gt; 检索 -&gt; 重排序 -&gt; 生成回答\n    \n    \n    def __init__(self, \n                 llm_base_url: str = https://api.deepseek.com,\n                 llm_api_key: str = your-api-key,\n                 llm_model: str = deepseek-chat):\n        \n        # 初始化各个组件\n        self.splitter = SmartDocumentSplitter(max_chunk_size=800)\n        self.vector_store = VectorStore()\n        self.retriever = EnhancedRetriever(self.vector_store)\n        \n        # 初始化LLM客户端（这里用DeepSeek，也可以换成其他的）\n        self.llm_client = OpenAI(base_url=llm_base_url, api_key=llm_api_key)\n        self.llm_model = llm_model\n        \n        self.collection_name = knowledge_base\n    \n    def ingest_documents(self, documents: List[Dict]):\n        \n        文档入库\n        documents格式：[{title: 文档标题, content: 文档内容, source: 来源}]\n        \n        print(f开始处理 {len(documents)} 篇文档...)\n        \n        all_chunks = []\n        for doc in documents:\n            # 在内容前加上标题，帮助切分器识别结构\n            full_content = f# {doc['title']}\\n\\n{doc['content']}\n            \n            chunks = self.splitter.split_markdown(full_content)\n            \n            # 给每个chunk加上文档来源信息\n            for chunk in chunks:\n                chunk['source_doc'] = doc.get('source', doc['title'])\n            \n            all_chunks.extend(chunks)\n        \n        print(f切分后共 {len(all_chunks)} 个片段)\n        \n        # 创建集合并插入\n        self.vector_store.create_collection(self.collection_name)\n        self.vector_store.insert_documents(self.collection_name, all_chunks)\n        \n        print(文档入库完成！)\n    \n    def query(self, \n              question: str, \n              chat_history: Optional[List[Dict]] = None,\n              top_k: int = 5,\n              use_rerank: bool = True) -&gt; Dict:\n        \n        处理用户查询\n        返回：{answer: 回答内容, sources: [引用的来源], retrieved_docs: [检索到的文档]}\n        \n        \n        # 1. 检索相关文档\n        if use_rerank:\n            retrieved_docs = self.retriever.retrieve_with_rerank(\n                self.collection_name, question, \n                initial_top_k=20, final_top_k=top_k\n            )\n        else:\n            results = self.vector_store.search(self.collection_name, question, top_k=top_k)\n            retrieved_docs = [{\n                'content': hit.entity.get('content'),\n                'context_path': hit.entity.get('context_path'),\n                'score': hit.score\n            } for hit in results]\n        \n        if not retrieved_docs:\n            return {\n                answer: 抱歉，我没有找到与您问题相关的资料。您可以尝试换个关键词，或联系相关部门获取帮助。,\n                sources: [],\n                retrieved_docs: []\n            }\n        \n        # 2. 构建Prompt\n        if chat_history:\n            prompt = build_conversational_prompt(question, retrieved_docs, chat_history)\n        else:\n            prompt = PromptBuilder.build(question, retrieved_docs, question_type=auto)\n        \n        # 3. 调用LLM生成回答\n        response = self.llm_client.chat.completions.create(\n            model=self.llm_model,\n            messages=[{role: user, content: prompt}],\n            temperature=0.3,  # 知识库问答用较低的temperature\n            max_tokens=2000\n        )\n        \n        answer = response.choices[0].message.content\n        \n        # 4. 提取引用的来源\n        sources = list(set([doc.get('context_path', '未知来源') for doc in retrieved_docs]))\n        \n        return {\n            answer: answer,\n            sources: sources,\n            retrieved_docs: retrieved_docs\n        }\n    \n    def evaluate_response(self, question: str, answer: str, \n                          ground_truth: str = None) -&gt; Dict:\n        \n        回答质量评估（可选）\n        用LLM评估回答的质量，方便持续优化\n        \n        eval_prompt = f请评估以下问答的质量。\n\n问题：{question}\n\n回答：{answer}\n\n{f参考答案：{ground_truth} if ground_truth else }\n\n请从以下维度评分（1-5分）并说明理由：\n1. 相关性：回答是否切题\n2. 准确性：信息是否正确\n3. 完整性：是否完整解答了问题\n4. 可读性：表述是否清晰易懂\n\n请用JSON格式输出：{{relevance: 分数, accuracy: 分数, completeness: 分数, readability: 分数, comments: 评价说明}}\n        \n        response = self.llm_client.chat.completions.create(\n            model=self.llm_model,\n            messages=[{role: user, content: eval_prompt}],\n            temperature=0\n        )\n        \n        try:\n            eval_result = json.loads(response.choices[0].message.content)\n            return eval_result\n        except:\n            return {error: 评估结果解析失败}\n\n\n# 使用示例\nif __name__ == __main__:\n    # 初始化Pipeline\n    rag = RAGPipeline(\n        llm_base_url=https://api.deepseek.com,\n        llm_api_key=your-api-key,\n        llm_model=deepseek-chat\n    )\n    \n    # 准备测试文档\n    test_documents = [\n        {\n            title: MySQL主从切换操作手册,\n            content: \"\"\"\n\t\t\t\t## 1. 前置检查\n\t\t\t\t在执行主从切换之前，必须完成以下检查：\n\t\t\t\t- 确认从库同步状态正常（Seconds_Behind_Master = 0）\n\t\t\t\t- 确认没有正在执行的大事务\n\t\t\t\t- 通知相关业务方，确认切换时间窗口\n\n\t\t\t\t## 2. 切换步骤\n\t\t\t\t### 2.1 在主库执行只读设置\n\t\t\t\tSET GLOBAL read_only = 1;\n\t\t\t\t### 2.2 等待从库完全同步\n\t\t\t\t在从库执行 SHOW SLAVE STATUS，确认 Seconds_Behind_Master = 0\n\n\t\t\t\t### 2.3 停止从库复制并提升为主库\n\t\t\t\tSTOP SLAVE;\n\t\t\t\tRESET SLAVE ALL;\n\t\t\t\tSET GLOBAL read_only = 0;\n\n\t\t\t\t## 3. 切换后验证\n\t\t\t\t- 确认新主库可以正常写入\n\t\t\t\t- 确认应用连接已切换到新主库\n\t\t\t\t- 监控新主库的性能指标\n\t\t\t\t\"\"\",\n            source: DBA团队文档\n        }\n    ]\n    \n    # 入库\n    rag.ingest_documents(test_documents)\n    \n    # 测试查询\n    result = rag.query(MySQL切换前需要做哪些检查？)\n    \n    print(= * 50)\n    print(问题：MySQL切换前需要做哪些检查？)\n    print(= * 50)\n    print(f\\n回答：\\n{result['answer']})\n    print(f\\n参考来源：{result['sources']})\n\n</code></pre>\n<h2 id=\"六上线后的一些经验教训\">六、上线后的一些经验教训</h2>\n<p>系统上线到现在差不多两个月了，期间又踩了不少坑，这里挑几个印象最深的说说。</p>\n<h3 id=\"教训一用户的问题千奇百怪\">教训一：用户的问题千奇百怪</h3>\n<p>我们在设计时假设用户会问MySQL怎么做主从切换这种正常问题。但实际上呢？</p>\n<p>有人问：上次那个事故怎么处理的来着？——没有任何上下文，系统根本不知道那个事故是哪个。</p>\n<p>有人问：帮我写个SQL。——这根本不是知识库问答，这是让大模型帮写代码。</p>\n<p>还有人问：在吗？——我也不知道他想干啥。</p>\n<p>后来我加了一个意图识别层，先判断用户的问题是否属于知识库问答的范畴：</p>\n<pre><code class=\"language-python\">def classify_intent(self, query: str) -&gt; str:\n    \"\"\"识别用户意图\"\"\"\n    intent_prompt = f\"\"\"判断用户输入的意图类别，只输出类别名称：\n- knowledge_query：查询知识库信息（如询问流程、规范、操作方法）\n- code_request：请求生成代码\n- chitchat：闲聊或无明确意图\n- other：其他\n\n用户输入：{query}\n\n意图类别：\"\"\"\n    \n    response = self.llm_client.chat.completions.create(\n        model=self.llm_model,\n        messages=[{\"role\": \"user\", \"content\": intent_prompt}],\n        temperature=0,\n        max_tokens=20\n    )\n    \n    return response.choices[0].message.content.strip()\n</code></pre>\n<p>对于非知识库问答的意图，给用户一个友好的提示而不是硬着头皮检索。</p>\n<h3 id=\"教训二冷启动时的尴尬\">教训二：冷启动时的尴尬</h3>\n<p>系统刚上线时，知识库里的文档不多，覆盖的场景有限。用户问了几个问题都答不上来，体验特别差，于是就不来用了。</p>\n<p>后来的解决办法：</p>\n<ol>\n<li>上线前先梳理高频问题，确保至少这些问题能回答好</li>\n<li>搞了一个问题收集功能，对于答不上来的问题，记录下来反馈给内容团队，让他们补充相关文档</li>\n<li>做了一个兜底策略——如果检索不到高相关度的内容，就展示相关推荐，把一些相似度尚可的文档标题列出来，引导用户自己去看</li>\n</ol>\n<h3 id=\"教训三文档更新的同步问题\">教训三：文档更新的同步问题</h3>\n<p>知识库的文档是会更新的。老版本的操作手册废弃了，新版本发布了。但如果向量数据库里还存着老版本的内容，用户检索到的可能是过时信息。</p>\n<p>这个问题说起来简单，做起来挺麻烦的。我们最后的方案是：</p>\n<ol>\n<li>每个文档入库时记录版本号和更新时间</li>\n<li>定期全量重新入库（我们是每周一次）</li>\n<li>对于紧急更新的重要文档，支持手动触发单篇重入库</li>\n</ol>\n<h2 id=\"七性能优化让系统不那么慢\">七、性能优化：让系统不那么慢</h2>\n<p>RAG系统有个让人头疼的问题——慢。</p>\n<p>整个流程跑一遍：Embedding编码、向量检索、重排序、LLM生成，全部加起来可能要好几秒。用户体验就很差，问一个问题要等半天。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>几个优化措施：</p>\n<pre><code class=\"language-python\">import asyncio\nfrom functools import lru_cache\nimport hashlib\n\nclass OptimizedRAG:\n    性能优化版RAG\n    \n    def __init__(self):\n        # 缓存热门查询的结果\n        self.query_cache = {}\n        self.cache_ttl = 3600  # 1小时过期\n    \n    @lru_cache(maxsize=1000)\n    def _compute_query_embedding(self, query: str):\n        \n        Embedding结果缓存\n        同样的问题不用重复计算向量\n        \n        return self.model.encode([query], normalize_embeddings=True)[0]\n    \n    def _get_cache_key(self, query: str) -&gt; str:\n        生成缓存key\n        return hashlib.md5(query.lower().strip().encode()).hexdigest()\n    \n    async def stream_query(self, question: str):\n        \n        流式输出\n        不用等整个回答生成完，边生成边输出\n        \n        retrieved_docs = await asyncio.to_thread(\n            self.retriever.retrieve_with_rerank,\n            self.collection_name, question, 20, 5\n        )\n        \n        prompt = PromptBuilder.build(question, retrieved_docs, question_type=auto)\n        \n        # 使用流式API\n        stream = self.llm_client.chat.completions.create(\n            model=self.llm_model,\n            messages=[{role: user, content: prompt}],\n            temperature=0.3,\n            stream=True  # 开启流式\n        )\n        \n        for chunk in stream:\n            if chunk.choices[0].delta.content:\n                yield chunk.choices[0].delta.content\n</code></pre>\n<p>流式输出这一点特别重要。用户问完问题后，马上就能看到回答在打字，心理上就不会觉得那么慢了。</p>\n<h2 id=\"八回顾与思考\">八、回顾与思考</h2>\n<p>把这套系统从被骂下线到成为部门标配，前后折腾了将近一个月。趟过的坑挺多，但收获也很大。</p>\n<p>几点核心总结：</p>\n<p><strong>1. RAG不是万能的，选好适用场景</strong></p>\n<p>RAG适合有明确知识库、答案可追溯的场景。如果你的需求是让大模型发挥创造力（比如写文案、做创意），那RAG反而是个约束。</p>\n<p><strong>2. 切分和检索是根基</strong></p>\n<p>大家往往把注意力放在大模型本身，觉得用更强的模型就能解决问题。但实际上，如果前面的切分和检索做得不好，再强的模型也是巧妇难为无米之炊。</p>\n<p><strong>3. Prompt工程真的是门手艺</strong></p>\n<p>同样的检索结果，不同的Prompt可能带来天壤之别的回答效果。这个没什么捷径，就是多试、多看、多迭代。</p>\n<p><strong>4. 上线只是开始</strong></p>\n<p>真正的挑战在上线之后。用户的各种奇葩输入、文档的持续更新、性能的优化、效果的监控……每一项都是持续的工作。</p>\n<p><img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>最后，附上这套系统目前的一些核心指标：</p>\n<ul>\n<li>日均查询量：200+次</li>\n<li>平均响应时间：2.3秒（开启流式后首字符延迟约0.8秒）</li>\n<li>用户满意度（通过回答后的点赞/点踩收集）：约72%</li>\n<li>无法回答的比例：约22%（这部分会定期分析，推动补充文档）</li>\n</ul>\n<p>数字不算特别亮眼，但比起之前那个没人用的关键词搜索，已经是质的飞跃了。如果你也在做类似的项目，希望这篇文章能帮你少踩一些坑。有问题欢迎评论区交流！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-10 22:10</span>&nbsp;\n<a href=\"https://www.cnblogs.com/bu-huo\">张不惑</a>&nbsp;\n阅读(<span id=\"post_view_count\">409</span>)&nbsp;\n评论(<span id=\"post_comment_count\">3</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为什么 AI 服务器首选 Ubuntu？难道 OEL 和 RHEL 不香吗？",
      "link": "https://www.cnblogs.com/jyzhao/p/19601634/wei-shen-me-ai-fu-wu-qi-shou-xuan-ubuntu-nan-dao-o",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jyzhao/p/19601634/wei-shen-me-ai-fu-wu-qi-shou-xuan-ubuntu-nan-dao-o\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 22:06\">\n    <span>为什么 AI 服务器首选 Ubuntu？难道 OEL 和 RHEL 不香吗？</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2026-02-10 22:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jyzhao\">AlfredZhao</a>&nbsp;\n阅读(<span id=\"post_view_count\">196</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在 AI 圈子里，如果你去租一台 GPU 算力服务器，或者看大模型的部署教程，你会发现一个有趣的现象：<strong>Ubuntu 几乎是默认选项</strong>。</p>\n<p>很多习惯了企业级系统（如 RHEL、CentOS 或 OEL）的朋友可能会纳闷：既然 NVIDIA 驱动也支持红帽系系统，为什么大家偏偏对 Ubuntu 这种“社区感”十足的系统情有独钟？</p>\n<p>今天，笔者就带大家拆解这背后的逻辑。</p>\n<h2 id=\"01--兼容性错觉驱动不是门槛生态才是\">01 | 兼容性错觉：驱动不是门槛，生态才是</h2>\n<p>首先要纠正一个误区：并不是 NVIDIA 驱动不支持红帽系系统。事实上，NVIDIA 官方为 RHEL 和 OEL（Oracle Enterprise Linux）提供了详尽的安装包。</p>\n<h3 id=\"-代码能跑和环境好配是两回事\">① “代码能跑”和“环境好配”是两回事</h3>\n<p>在 AI 领域，很多开源项目（如 PyTorch、TensorFlow）在开发时，程序员桌面上跑的基本都是 Ubuntu。这意味着，几乎所有的 GitHub 项目 README 都会标注一行：<em>“Tested on Ubuntu 22.04”</em>。</p>\n<h3 id=\"-避坑成本的博弈\">② 避坑成本的博弈</h3>\n<p>如果使用 RHEL/OEL 安装大模型，可能会遇到 GLIBC 版本过低、动态链接库不匹配等问题。而在 Ubuntu 上，这些坑早就被全球开发者填平了。</p>\n<h2 id=\"02--速度与激情的碰撞包管理器的优势\">02 | 速度与激情的碰撞：包管理器的优势</h2>\n<p>AI 技术的发展日新月异，这就要求操作系统必须跟上节奏。</p>\n<h3 id=\"-更新策略的差异\">① 更新策略的差异</h3>\n<ul>\n<li><strong>RHEL/OEL</strong>：核心诉求是“极致稳定”，软件库更新保守。对于需要最新 GCC 编译器支持的 AI 框架来说，手动编译依赖包的过程极其痛苦。</li>\n<li><strong>Ubuntu</strong>：在稳定与新鲜感之间拿捏得极好。最新的 Python、CUDA Toolkit 往往能通过官方仓库或 PPA 快速获取。</li>\n</ul>\n<h3 id=\"-dkms-的自动化魔法\">② DKMS 的自动化魔法</h3>\n<p>Ubuntu 驱动安装通常配合 DKMS 技术。当你升级系统内核时，驱动会自动重新编译适配。而在红帽系系统上，内核升级后驱动失效是新手的“常客”问题。</p>\n<h2 id=\"03--容器化时代的必然底座的隐身\">03 | 容器化时代的必然：底座的“隐身”</h2>\n<p>现在的 GPU 任务，绝大多数都是跑在 Docker 里的。</p>\n<h3 id=\"-宿主机只需当好服务员\">① 宿主机只需当好“服务员”</h3>\n<p>在容器化架构下，宿主机操作系统只需要做两件事：提供稳定的内核和挂载好显卡驱动。</p>\n<h3 id=\"-镜像生态的统一\">② 镜像生态的统一</h3>\n<p>既然大多数 AI 镜像的底层（Base Image）都是基于 Ubuntu 的，为了减少宿主机内核与容器之间的微小摩擦，选择 Ubuntu 作为“大底座”自然成了性价比最高的方案。</p>\n<h2 id=\"04--什么时候该选-rhel-或-oel\">04 | 什么时候该选 RHEL 或 OEL？</h2>\n<p>在以下特定场景中，笔者依然建议选择企业级系统：</p>\n<ul>\n<li><strong>极致的安全合规</strong>：金融、政务等领域有严格的审计要求。</li>\n<li><strong>长期技术支持</strong>：如果你需要提供原厂工程师级别的商业保障。</li>\n</ul>\n<h2 id=\"05--笔者的总结\">05 | 笔者的总结</h2>\n<p><strong>驱动不是问题，生态才是关键。</strong> 就像玩游戏首选 Windows 一样，在 AI 领域，Ubuntu 已经成了事实上的“标准答案”。顺着生态走，能让你省下 80% 调环境的时间去跑模型。</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <a href=\"https://www.cnblogs.com/jyzhao/\" target=\"_blank\">AlfredZhao</a>©版权所有「从Oracle起航，领略精彩的IT技术。」<br />\n转载请注明原文链接：<a href=\"https://www.cnblogs.com/jyzhao/p/19601634/wei-shen-me-ai-fu-wu-qi-shou-xuan-ubuntu-nan-dao-o\" target=\"_blank\">https://www.cnblogs.com/jyzhao/p/19601634/wei-shen-me-ai-fu-wu-qi-shou-xuan-ubuntu-nan-dao-o</a>\n<hr />\n<div style=\"text-align: center; margin-top: 30px;\">\n  <p style=\"font-size: 14px; color: #555;\">\n    👋 感谢阅读，欢迎关注我的公众号 <b>「赵靖宇」</b>\n  </p>\n  <img src=\"https://images.cnblogs.com/cnblogs_com/jyzhao/824234/o_250208075013_qrcode-zjy.jpg\" style=\"border: 1px solid #ddd; border-radius: 8px;\" width=\"160\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "SEAL全同态加密CKKS方案入门详解",
      "link": "https://www.cnblogs.com/zhaoweiwei/p/19577832/CKKS",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zhaoweiwei/p/19577832/CKKS\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 18:22\">\n    <span>SEAL全同态加密CKKS方案入门详解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文以微软的开源全同态库SEAL中CKKS方案为参照，依次介绍了CKKS方案相关的核心原理，以及方案实施标准流程，最后给出了一个一个简单的SEAL库CKKS方案示例程序，并给出相应的运行结果。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p align=\"left\">CKKS（Cheon–Kim–Kim–Song）是2017年论文《Homomorphic Encryption for Arithmetic of Approximate Numbers》中提出的近似计算同态加密算法，论文的作者是Cheon等四位韩国研究者，如今该方案已经是面向浮点/复数近似同态计算的主流方案，广泛应用于密文机器学习、数值计算场景。不同于以往同态加密算法中所追求的解密结果和明文完全一致，CKKS算法的目标是做近似计算。这并不偏离需求，因为现实生活中大部分运算，面对的是实数（复数），而实数（复数）的运算，往往只需要保留一部分有效数字即可。此外，允许误差，放宽准确性的限制，使得CKKS对比于其他基于LWE/RLWE难题的同态方案，细节有了较大的简化，计算效率也有了很大提升。</p>\n<h1>1 核心原理</h1>\n<h2>1.1 编码与嵌入原理</h2>\n<p align=\"left\">CKKS的核心创新是规范嵌入（Canonical Embedding），将环R上的多项式与复数空间C<sup>N/2</sup>双向映射：</p>\n<p align=\"left\">（1）多项式<em>f(x)∈R</em>可通过分圆多项式的根映射为N/2维复数向量</p>\n<p align=\"left\">（2）复数向量可反向映射为环上多项式，实现向量数据与多项式的无损转换</p>\n<p align=\"left\">（3）结合缩放因子Δ=2<sup>k</sup>，将浮点数放大为整数，适配有限域运算</p>\n<p align=\"left\">槽位数量=N/2，例如N=8192时，单密文可打包4096个浮点数并行运算。R是分圆多项式环：</p>\n<p><img alt=\"image\" height=\"34\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209110608893-1701884716.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"353\" /></p>\n<p>环中的元素是系数是整数（严格来说是实数）的N次多项式。</p>\n<p align=\"left\">C<sup>N/2</sup>是N/2维复数向量构成的环，它里面的元素是N/2维复数向量。规范嵌入是环同构（保持环加法与乘法的双向一一映射）：</p>\n<p><img alt=\"image\" height=\"32\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209120035570-1372830017.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"150\" /></p>\n<p>设ζ<sub>j</sub> = e<sup>i(2j+1)π/N</sup>，j = 0,1,...,N-1是x<sup>N</sup> + 1 = 0，即x<sup>N</sup> = -1 = e<sup>iπ</sup>的N个元根，则σ从左到右表示为：</p>\n<p><img alt=\"image\" height=\"40\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209120224137-710695710.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"474\" /></p>\n<p>σ有以下关键性质：</p>\n<p>（1）加法映射为向量加法，即σ(f+g) =&nbsp;σ(f) +&nbsp;σ(g)</p>\n<p>（2）乘法映射为向量逐元素乘法（Hadamard积）σ(f•g) =&nbsp;σ(f)&nbsp;•&nbsp;σ(g)</p>\n<p>（3）双射（可逆）</p>\n<p>可以从向量还原多项式（逆映射），接下来以N=8为例，从正反两个方面进行分析。</p>\n<h3>1 正向映射（canomical embedding R-&gt;C<sup>4</sup>）</h3>\n<p>当N=8时，环表示为：</p>\n<p><img alt=\"image\" height=\"27\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209120812481-583938144.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"193\" /></p>\n<p>环中的元素为多项式：f(x)=a<sub>0</sub>+a<sub>1</sub>x+a<sub>2</sub>x<sup>2</sup>+...+a<sub>7</sub>x<sup>7</sup>，x<sup>8</sup>+1=0的元根为：x=e<sup>i(2k+1)π/8</sup>，k=0,1,...,7，由元根的共轭可知：</p>\n<p><img alt=\"image\" height=\"262\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210101831409-1941165188.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"270\" /></p>\n<p align=\"left\">则正向映射将多项式映射为复数向量，表示为：</p>\n<p><img alt=\"image\" height=\"35\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209121233176-213381444.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"445\" /></p>\n<p>以上只取前4个根，因为由于共轭有：</p>\n<p><img alt=\"image\" height=\"32\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209121546561-1996158330.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"333\" /></p>\n<p>以多项式f(x) = 1 + 2x + 3x2为例，计算第一个槽：</p>\n<p><img alt=\"image\" height=\"99\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209121709917-1592425942.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"571\" />同理可得4维向量的其他分量，从而完成多项式向复向量的映射，σ(f) = (z<sub>0</sub>,z<sub>1</sub>,z<sub>2</sub>,z<sub>3</sub>)∈C<sup>4</sup>。这一步本质上就是FFT的前半部分，𝑓(𝑥)有8个实自由度，而复向量看起来只有4个自由度，但是因为𝑧<sub>i</sub>是复数，它本身有2个实自由度，所以总体上来说复向量有4x2=8个实自由度。</p>\n<h3>2 逆向映射（C<sup>4</sup>-&gt;R）</h3>\n<p>逆向映射将复数向量映射为多项式，由(z<sub>0</sub>,z<sub>1</sub>,z<sub>2</sub>,z<sub>3</sub>)∈C<sup>4</sup>恢复一个多项式，构造长度为8的“频域向量”：</p>\n<p><img alt=\"image\" height=\"29\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209150228446-1761094550.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"298\" /></p>\n<p>唯一多项式f(x)满足：f(ζ<sub>k</sub>) = z<sub>k</sub>，k = 0,1,2,...,7，利用Lagrange插值（工程上对应inverse FFT）即可得到：</p>\n<p><img alt=\"image\" height=\"28\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209150615101-1539219155.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"351\" /></p>\n<p>其中所有a<sub>i</sub>∈R。这里的双向映射正是CKKS Encode/Decode在做的事：</p>\n<p><img alt=\"\" height=\"234\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209150904927-1228266632.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"637\" /></p>\n<h2>1.2 缩放因子（Scale）及近似计算</h2>\n<p>CKKS不追求绝对精确，解密结果与原始明文存在极小精度误差，误差可控且远低于机器学习/数值分析的容忍阈值，这是效率与实用性的平衡设计，为了实现该目标引入了缩放因子，缩放因子在“把实/复数嵌入整数多项式环”时，由“缩放+舍入”不可避免引入了精度误差：</p>\n<p><img alt=\"image\" height=\"29\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209151018659-2008326500.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"300\" /></p>\n<p>仍以N=8为例说明相应流程，原本映射</p>\n<p><img alt=\"image\" height=\"33\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209151905200-426056642.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"485\" /></p>\n<p>是一对零误差的严格双射，但是CKKS要做一件“非法的事”，逆向映射由实/复数转换成整系数多项式，就是：</p>\n<p><img alt=\"image\" height=\"34\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209152020759-2070476129.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"488\" /></p>\n<p>操作本身就不可能精确完成，原因很简单，左边是连续域，右边是离散格，CKKS的解决方案是进行“缩放+舍入（误差源头）”，首先引入一个scale Δ，在映射前对复向量进行缩放：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153919946-1630554091.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>这一步只是放大并没有引入误差，接下来进行逆embedding（IFFT）得到实系数多项式：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153919937-1690109536.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>理论上这一步仍然是精确的，但是在进行随后一步舍入到整系数时会产生误差：</p>\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153919914-412330373.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p align=\"left\">令：</p>\n<p><img alt=\"image\" height=\"33\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209152958825-135711869.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"225\" /></p>\n<p>其中e(x)的每个系数都满足|e<sub>i</sub>|≤1/2，当映射回slot空间时，会对m(x)再做canonical embedding：</p>\n<p><img alt=\"image\" height=\"29\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153222424-1033559120.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"186\" /></p>\n<p>而：</p>\n<p><img alt=\"image\" height=\"33\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153258782-1352680454.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"276\" /></p>\n<p>所以：</p>\n<p><img alt=\"image\" height=\"32\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153349080-2016492421.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"502\" /></p>\n<p>其中ε<sub>k</sub> = e(ζ<sub>k</sub>)，最后会除于scale Δ：</p>\n<p><img alt=\"image\" height=\"59\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260209153623063-989735394.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"440\" /></p>\n<p>这就是CKKS的“近似”，对比BFV中的“舍入”，他们的含义完全不同：</p>\n<p>BFV的舍入是：</p>\n<p align=\"left\">在模t意义下，向整数添加噪声，再把“整数+小噪声”映射回同一个整数，只要噪声受控该过程就是之前操作的精确逆操作。</p>\n<p align=\"left\">CKKS的舍入是：</p>\n<p align=\"left\">把“连续实数”映射到最近的整数，再把整数映射回实数，该过程并不是之前操作的精确逆操作，所以产生“近似”。</p>\n<p>一句话：BFV里round用于“纠错”，CKKS里round用于“近似”。在SEAL中常用2^40，精度与噪声达到平衡。</p>\n<h2>1.3 噪声管理</h2>\n<p>在CKKS中，噪声管理主要依靠Rescaling（重缩放）机制，它配合RNS链，实现了对噪声的“阶梯式”精准控制。</p>\n<h3>1 CKKS噪声的组成部分</h3>\n<p>CKKS的噪声e并不是单一来源，它是由三部分叠加而成的：</p>\n<p><strong>初始噪声（e<sub>rlwe</sub>）：</strong>加密时引入的离散高斯噪声，用于保障安全性。</p>\n<p><strong>编码误差（e<sub>enc</sub>）：</strong>将浮点数缩放并舍入到整数多项式时参数的损失。</p>\n<p><strong>计算误差（e<sub>comp</sub>）：</strong>同态乘法和重线性化引入的噪声。</p>\n<p>在CKKS中，我们不区分“噪声”和“误差”。缩放因子Δ<span class=\"math-inline\">决定了明文的精度，而噪声只要不侵蚀到Δ定义的有效位，计算就是可靠的。</span></p>\n<h3><span class=\"math-inline\">2 核心机制：Rescaling（重缩放）</span></h3>\n<p><span class=\"math-inline\">当我们做一次同态乘法：</span></p>\n<p><img alt=\"image\" height=\"23\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260211112226209-655796869.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"261\" /></p>\n<p><span class=\"math-inline\">如果不处理，连续乘法会导致数值迅速爆炸，超出模数q的范围。此时将密文除于一个RNS素数q<sub>l</sub>（通常设q<sub>l</sub>≈Δ），并进行舍入：</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210175745316-581058742.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>结果：</p>\n<p>（1）缩放因子回归：Δ<sup>2</sup>/q<sub>l</sub>&nbsp;≈ Δ，有效位回到了正确的位置。</p>\n<p>（2）噪声同步缩减：原本的噪声e也被除于了q<sub>l</sub>，新噪声为：e/q<sub>l</sub>+舍入误差</p>\n<p>可见Rescaling不仅把膨胀的数值拉回来，同时顺手把增长的噪声也按比例缩小了。</p>\n<h3><span class=\"math-inline\">3 RNS链与层（Levels）的噪声控制</span></h3>\n<p><span class=\"math-inline\">在实际实现中，模数Q是L个小模数之积Q=q<sub>0</sub>·q<sub>1</sub>·...·q<sub>L-1</sub></span><span class=\"math-inline\">，每一层计算都对应链中的一个素数，以L=4为例给出流程：</span></p>\n<p><img alt=\"image\" height=\"186\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210181153276-276909400.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"469\" /></p>\n<p>&nbsp;以上每一层Rescaling都会吃掉总模数Q的约p比特（假设Δ=2<sup>p</sup>），当RNS链只剩下最后一个素数q<sub>0</sub>时，无法再进行Rescaling，此时再做乘法，噪声将无法被缩小，会迅速覆盖掉有效明文位。假设Q为600bit，Δ为40bit，Q能支撑约600/40=15层乘法，算到第15层时，模数只剩40bit左右，此时噪声和明文混在一起，无法再分。与BFV的区别：BFV的噪声管理是为了保住“整数的绝对准确”；CKKS的噪声管理是为了保住“浮点数的有效精度”。</p>\n<h1>2 CKKS标准流程划分</h1>\n<p>以SEAL库为例，完整流程分为5个阶段。</p>\n<h2>2.1 系统初始化与参数生成</h2>\n<p><strong>输入参数：</strong></p>\n<p>多项式模次数N（2的整数幂）</p>\n<p>模数链系数{q<sub>1</sub>,q<sub>2</sub>,...,q<sub>L</sub>}（递减序列，决定运算深度）</p>\n<p>缩放因子Δ=2<sup>k</sup>（控制计算精度）</p>\n<p>高斯噪声分布χ（RLWE基础噪声）</p>\n<p><strong>输出参数：</strong></p>\n<p>合法的SEAL上下文</p>\n<h2>2.2 密钥生成</h2>\n<p>基于RLWE问题生成密钥组，私钥绝对保密，公钥/辅助密钥可公开分发。</p>\n<p>（1）私钥sk</p>\n<p>随机采样小范数多项式：sk∈R（系数仅为-1/0/1）</p>\n<p>（2）公钥<em>pk=(b,a)</em></p>\n<p>a：环上随机多项式</p>\n<p>b：b=-(a·sk + e<sub>pk</sub>)，其中e<sub>pk</sub>是高斯噪声多项式</p>\n<p>（3）重线性化密钥rlk</p>\n<p>&nbsp;用于密文乘法后的维度压缩，由私钥加密派生，服务器执行重线性化时使用。</p>\n<p>（4）旋转密钥rot_k（可选）</p>\n<p>用于密文槽位旋转，实现向量数据重排、求和等高阶运算。</p>\n<h2>2.3 编码与加密</h2>\n<h3><strong>步骤1 明文编码（浮点数/复数-&gt;多项式）</strong></h3>\n<p>该步会将实数/复数向量z∈C<sup>N/2</sup>转换为明文多项式。</p>\n<p>（1）构造对称向量（Symmetry Construction）</p>\n<p>在进行变换前，首先构造一个长度为N的向量Z：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210103120361-1359664060.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>向量的后部部分是前半部分的共轭，这种对称性保证了下一步IFFT出来的多项式系数全部是实浮点数。</p>\n<p>（2）正则嵌入逆变换（IFFT）</p>\n<p>将长度为N的对称向量Z进行逆变换，得到一个多项式p(x)，其系数a<sub>i</sub>理论上应该是实数（由于浮点数计算精度问题，可能会有极小的虚部，通常直接舍弃）。</p>\n<p>（3）缩放与舍入（Scaling &amp; Rounding）</p>\n<p>对实浮点数系数进行操作：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210103703414-337958342.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>由此得到了系数为实整数的多项式pt。</p>\n<p>以N=4为例，假设z=(3,4)，则首先对z进行扩展Z=(3,4,4,3)，因为3和4可以看作是虚部为零的复数，所以Z向量后半部分的共轭和前半部分完全相同。接下来目标是将Z映射为多项式p(x)=a<sub>0</sub>+a<sub>1</sub>x+a<sub>2</sub>x<sup>2</sup>+a<sub>3</sub>x<sup>3</sup>，即需要找到多项式的实系数a<sub>0</sub>，a<sub>1</sub>，a<sub>2</sub>，a<sub>3</sub>。在CKKS中，使用x<sup>4</sup>+1=0的单位根，它们是：ζ<sub>0</sub> = e<sup>iπ/4</sup>，ζ<sub>1</sub>&nbsp;= e<sup>i3π/4</sup>，ζ<sub>2</sub>&nbsp;= e<sup>i5π/4</sup>，ζ<sub>3</sub>&nbsp;= e<sup>i7π/4</sup>，ζ<sub>2</sub>和ζ<sub>3</sub>是ζ<sub>1</sub>和ζ<sub>0</sub>的共轭，则对于多项式p(x)满足：p(ζ<sub>0</sub>) = y<sub>0</sub> = 3，p(ζ<sub>1</sub>) = y<sub>1</sub> = 4，p(ζ<sub>2</sub>) = y<sub>2</sub> = 4，p(ζ<sub>3</sub>) = y<sub>3</sub> = 3，可以利用IFFT逆变换系数公式进行求解：</p>\n<p><img alt=\"image\" height=\"76\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210120409880-138792570.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"178\" /></p>\n<p>依次计算各个系数：</p>\n<p><strong>计算a<sub>0</sub>：</strong></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210120540550-839957814.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p><strong>计算a<sub>1</sub>：</strong></p>\n<p>由：</p>\n<p><img alt=\"image\" height=\"52\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210124216470-303321074.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"627\" /></p>\n<p>可知：</p>\n<p><img alt=\"image\" height=\"68\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210125922014-1456750365.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"766\" /></p>\n<p><strong>计算a<sub>2</sub>：</strong></p>\n<p>由于ζ<sub>0</sub><sup>-2</sup>&nbsp;= -i，ζ<sub>1</sub><sup>-2</sup>&nbsp;= i，ζ<sub>2</sub><sup>-2</sup>&nbsp;= -i，ζ<sub>3</sub><sup>-2</sup>&nbsp;= i，可知：</p>\n<p><img alt=\"image\" height=\"44\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210123340956-1412279352.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"371\" /></p>\n<p><strong>计算a<sub>3</sub>：</strong></p>\n<p>由：</p>\n<p><img alt=\"image\" height=\"50\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210140541152-203458374.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"628\" /></p>\n<p>可知：</p>\n<p><img alt=\"image\" height=\"70\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210140632043-718239368.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"760\" /></p>\n<p>以上多项式系数的计算过程可以看到，系数中的虚部会因为共轭对称完全抵消，只剩实部，得到多项式是p(x)=3.5-0.3535x+0.3535x<sup>3</sup>，后续将在此多项式的基础上对齐系数进行放大及舍入完成编码流程。</p>\n<h3>步骤2 明文加密（明文-&gt;密文）</h3>\n<p>编码后的明文多项式pt被转换为一个包含两个多项式的密文对(c<sub>0</sub>,c<sub>1</sub>)：</p>\n<p><img alt=\"image\" height=\"116\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210104930702-266110462.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"325\" /></p>\n<p>图中a，b是公钥对儿的两部分，u是小范数随机多项式，e<sub>0</sub>，e<sub>1</sub>是高斯噪声多项式，Q是密文大模数。</p>\n<h2>2.4 密文同态运算</h2>\n<p>支持加法、标量乘、密文乘、旋转、求和等运算，是CKKS的核心能力。</p>\n<h3>1 密文加法（同态加）</h3>\n<p>输入：两个同维度密文ct=(ct<sub>0</sub>,ct<sub>1</sub>)，ct'=(ct<sub>0</sub>',ct<sub>1</sub>')</p>\n<p>输出：ct<sub>add</sub>=(ct<sub>0</sub>+ct<sub>0</sub>',ct<sub>1</sub>+ct<sub>1</sub>')</p>\n<p>特性：无维度膨胀，无需重线性化，噪声线性叠加，运算后缩放因子保持不变。</p>\n<h3>2 密文乘法（同态乘）</h3>\n<p>原始乘法：两个二元组密文相乘，输出三元组密文ct<sub>mult</sub>=(c<sub>0</sub>,c<sub>1</sub>,c<sub>2</sub>)，其中c<sub>0</sub>=ct<sub>0</sub>•ct<sub>0</sub>'，c<sub>1</sub>=ct<sub>0</sub>•ct<sub>1</sub>'+ct<sub>1</sub>•ct<sub>0</sub>'，c<sub>2</sub>=ct<sub>1</sub>•ct<sub>1</sub>'。</p>\n<p>重线性化：使用重线性化密钥rlk，将三元组压缩回标准二元组，恢复密文结构</p>\n<p>重缩放：乘法后，缩放因子变成Δ<sup>2</sup>，为了防止数值爆炸，会将密文除于Δ并舍入</p>\n<p>模切换：降低模数，同步缩放数据，压缩噪声，保证后续运算可行性</p>\n<p>特性：噪声指数级增长，必须配合重线性化+模切换使用。</p>\n<h3>3 高阶运算</h3>\n<p align=\"left\">标量乘法：密文与公开常数相乘，无需密钥</p>\n<p align=\"left\">槽位旋转：移动单个槽位数据，配合旋转密钥使用</p>\n<p align=\"left\">槽位求和：批量数据聚合，适用于统计计算</p>\n<h2>2.5 解密与解码</h2>\n<h3>1 密文解密</h3>\n<p>输入：密文ct=(ct<sub>0</sub>,ct<sub>1</sub>)、私钥sk</p>\n<p>输出：解码前明文多项式</p>\n<p>解密公式：</p>\n<p><img alt=\"image\" height=\"137\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260211111217754-1008528333.png\" width=\"589\" /></p>\n<p>最后部分可以看作是总噪声，则有：<em>pt<sub>dec</sub> = pt + e<sub>total</sub></em>。</p>\n<h3>2 明文解码</h3>\n<p align=\"left\">（1）去除模数映射，将多项式转换为复数向量</p>\n<p align=\"left\">（2）除于缩放因子Δ，还原为原始尺度的浮点数</p>\n<p align=\"left\">（3）舍弃虚部（实数场景），得到最终计算结果</p>\n<h1>3 代码示例</h1>\n<p>以下是SEAL库CKKS同态加密方案示例代码：</p>\n<div class=\"cnblogs_code\"><img class=\"code_img_closed\" id=\"code_img_closed_9af04663-7ada-4354-b3f4-bb029e2f6e7d\" src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" /><img class=\"code_img_opened\" id=\"code_img_opened_9af04663-7ada-4354-b3f4-bb029e2f6e7d\" src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" style=\"display: none;\" />\n<div class=\"cnblogs_code_hide\" id=\"cnblogs_code_open_9af04663-7ada-4354-b3f4-bb029e2f6e7d\">\n<pre>#include <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">seal/seal.h</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;iostream&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;vector&gt;<span style=\"color: rgba(0, 0, 0, 1);\">\n#include </span>&lt;iomanip&gt;\n\n<span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">namespace</span><span style=\"color: rgba(0, 0, 0, 1);\"> seal;\n</span><span style=\"color: rgba(0, 0, 255, 1);\">using</span> <span style=\"color: rgba(0, 0, 255, 1);\">namespace</span><span style=\"color: rgba(0, 0, 0, 1);\"> std;\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 工具函数：打印浮点向量，格式化输出结果</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">void</span> print_vector(<span style=\"color: rgba(0, 0, 255, 1);\">const</span> vector&lt;<span style=\"color: rgba(0, 0, 255, 1);\">double</span>&gt;&amp; vec, <span style=\"color: rgba(0, 0, 255, 1);\">const</span> <span style=\"color: rgba(0, 0, 255, 1);\">string</span>&amp; title, size_t print_size = <span style=\"color: rgba(128, 0, 128, 1);\">5</span><span style=\"color: rgba(0, 0, 0, 1);\">) {\n    cout </span>&lt;&lt; title &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    size_t limit </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> min(print_size, vec.size());\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (size_t i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt; limit; ++<span style=\"color: rgba(0, 0, 0, 1);\">i) {\n        cout </span>&lt;&lt; <span style=\"color: rgba(0, 0, 255, 1);\">fixed</span> &lt;&lt; setprecision(<span style=\"color: rgba(128, 0, 128, 1);\">3</span>) &lt;&lt; vec[i] &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span> <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (vec.size() &gt; limit) cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">...</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    cout </span>&lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n}\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\"> main() {\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 1. CKKS 方案参数配置 =====================\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 多项式模次数：决定安全等级、槽位数量、计算性能，必须是2的幂</span>\n    size_t poly_modulus_degree = <span style=\"color: rgba(128, 0, 128, 1);\">8192</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n    EncryptionParameters </span><span style=\"color: rgba(0, 0, 255, 1);\">params</span><span style=\"color: rgba(0, 0, 0, 1);\">(scheme_type::ckks);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">params</span><span style=\"color: rgba(0, 0, 0, 1);\">.set_poly_modulus_degree(poly_modulus_degree);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 配置系数模数链：CKKS核心，通过模切换控制噪声和计算深度\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 60, 40, 40, 60 表示模数链分段，支持2层乘法运算</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">params</span><span style=\"color: rgba(0, 0, 0, 1);\">.set_coeff_modulus(CoeffModulus::Create(\n        poly_modulus_degree, { </span><span style=\"color: rgba(128, 0, 128, 1);\">60</span>, <span style=\"color: rgba(128, 0, 128, 1);\">40</span>, <span style=\"color: rgba(128, 0, 128, 1);\">40</span>, <span style=\"color: rgba(128, 0, 128, 1);\">60</span><span style=\"color: rgba(0, 0, 0, 1);\"> }\n    ));\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 初始化SEAL上下文，验证参数合法性</span>\n    SEALContext context(<span style=\"color: rgba(0, 0, 255, 1);\">params</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    cout </span>&lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">SEAL CKKS 参数初始化完成，多项式模次数: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; poly_modulus_degree &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n    cout </span>&lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">可用槽位数量（单密文可打包数据量）: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>\n        &lt;&lt; context.get_context_data(context.first_parms_id())-&gt;parms().poly_modulus_degree() / <span style=\"color: rgba(128, 0, 128, 1);\">2</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 2. 密钥生成 =====================\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 密钥生成器：基于上下文生成公私钥、重线性化密钥</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    KeyGenerator keygen(context);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 私钥（核心机密，仅客户端持有）</span>\n    SecretKey secret_key =<span style=\"color: rgba(0, 0, 0, 1);\"> keygen.secret_key();\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 公钥（公开分发，用于加密）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    PublicKey public_key;\n    keygen.create_public_key(public_key);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 重线性化密钥（密文乘法后压缩密文维度，必需）</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    RelinKeys relin_keys;\n    keygen.create_relin_keys(relin_keys);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 3. 核心组件初始化 =====================\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 加密器：使用公钥加密明文</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Encryptor encryptor(context, public_key, secret_key);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 解密器：使用私钥解密密文</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Decryptor decryptor(context, secret_key);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> CKKS编码器：实现浮点数 ↔ 明文多项式 转换</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    CKKSEncoder encoder(context);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 同态运算器：执行密文加减乘、重线性化等操作</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Evaluator evaluator(context);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 缩放因子：CKKS用于控制浮点计算精度的核心参数</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">double</span> scale = pow(<span style=\"color: rgba(128, 0, 128, 1);\">2.0</span>, <span style=\"color: rgba(128, 0, 128, 1);\">40</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    cout </span>&lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">CKKS 缩放因子: 2^40</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; endl &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 4. 构造明文浮点向量 =====================</span>\n    vector&lt;<span style=\"color: rgba(0, 0, 255, 1);\">double</span>&gt; x = { <span style=\"color: rgba(128, 0, 128, 1);\">1.1</span>, <span style=\"color: rgba(128, 0, 128, 1);\">2.2</span>, <span style=\"color: rgba(128, 0, 128, 1);\">3.3</span>, <span style=\"color: rgba(128, 0, 128, 1);\">4.4</span><span style=\"color: rgba(0, 0, 0, 1);\"> };\n    vector</span>&lt;<span style=\"color: rgba(0, 0, 255, 1);\">double</span>&gt; y = { <span style=\"color: rgba(128, 0, 128, 1);\">5.5</span>, <span style=\"color: rgba(128, 0, 128, 1);\">6.6</span>, <span style=\"color: rgba(128, 0, 128, 1);\">7.7</span>, <span style=\"color: rgba(128, 0, 128, 1);\">8.8</span><span style=\"color: rgba(0, 0, 0, 1);\"> };\n    print_vector(x, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">原始向量 x</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    print_vector(y, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">原始向量 y</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 5. 明文编码 + 加密 =====================</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Plaintext plain_x, plain_y;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 将浮点向量编码为CKKS明文格式，指定缩放因子</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    encoder.encode(x, scale, plain_x);\n    encoder.encode(y, scale, plain_y);\n\n    Ciphertext cipher_x, cipher_y;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 加密明文为密文</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    encryptor.encrypt(plain_x, cipher_x);\n    encryptor.encrypt(plain_y, cipher_y);\n    cout </span>&lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n明文编码、加密完成，密文x数据大小: </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt; cipher_x.size() &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 6. 密文同态运算 =====================\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 6.1 密文加法：cipher_add = x + y</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Ciphertext cipher_add;\n    evaluator.add(cipher_x, cipher_y, cipher_add);\n    cout </span>&lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文加法运算完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 6.2 密文乘法：cipher_mult = x * y</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Ciphertext cipher_mult;\n    evaluator.multiply(cipher_x, cipher_y, cipher_mult);\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 乘法后密文维度膨胀，执行重线性化压缩回标准格式</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    evaluator.relinearize_inplace(cipher_mult, relin_keys);\n    cout </span>&lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文乘法 + 重线性化完成</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 7. 密文解密 + 解码 =====================</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    Plaintext plain_add_result, plain_mult_result;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 解密运算结果密文</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    decryptor.decrypt(cipher_add, plain_add_result);\n    decryptor.decrypt(cipher_mult, plain_mult_result);\n\n    vector</span>&lt;<span style=\"color: rgba(0, 0, 255, 1);\">double</span>&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> result_add, result_mult;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 解码为浮点向量</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    encoder.decode(plain_add_result, result_add);\n    encoder.decode(plain_mult_result, result_mult);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> ===================== 8. 结果输出 =====================</span>\n    cout &lt;&lt; <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">\\n==================== 运算结果对比 ====================</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> &lt;&lt;<span style=\"color: rgba(0, 0, 0, 1);\"> endl;\n    print_vector(result_add, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文加法解密结果</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    print_vector(result_mult, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">密文乘法解密结果</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 计算明文基准值用于对比</span>\n    vector&lt;<span style=\"color: rgba(0, 0, 255, 1);\">double</span>&gt;<span style=\"color: rgba(0, 0, 0, 1);\"> true_add, true_mult;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (size_t i = <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; i &lt; x.size(); ++<span style=\"color: rgba(0, 0, 0, 1);\">i) {\n        true_add.push_back(x[i] </span>+<span style=\"color: rgba(0, 0, 0, 1);\"> y[i]);\n        true_mult.push_back(x[i] </span>*<span style=\"color: rgba(0, 0, 0, 1);\"> y[i]);\n    }\n    print_vector(true_add, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文加法基准值</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    print_vector(true_mult, </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">明文乘法基准值</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n}</span></pre>\n</div>\n<span class=\"cnblogs_code_collapse\">CKKS</span></div>\n<p>代码运行效果如下：</p>\n<p><img alt=\"image\" height=\"272\" src=\"https://img2024.cnblogs.com/blog/465567/202602/465567-20260210171421384-92773903.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"483\" /></p>\n<p>&nbsp;</p>\n<h1>4 参考</h1>\n<p>1&nbsp;<a href=\"https://zhuanlan.zhihu.com/p/366965077\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/366965077</a></p>\n<p>2&nbsp;<a href=\"https://blog.csdn.net/WaitMrAnt/article/details/140950613\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.csdn.net/WaitMrAnt/article/details/140950613</a></p>\n<p>3&nbsp;<a href=\"https://zhuanlan.zhihu.com/p/619856459\" rel=\"noopener nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/619856459</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-10 18:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zhaoweiwei\">weiwei22844</a>&nbsp;\n阅读(<span id=\"post_view_count\">48</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Avalonia.Controls.DataGrid自动合并列",
      "link": "https://www.cnblogs.com/kevin-Y/p/19600957",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/kevin-Y/p/19600957\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 17:59\">\n    <span>Avalonia.Controls.DataGrid自动合并列</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>Winform在用的DataGridView修改为通过线条和透明的方式实现了合并列的效果。一段时间也在留意Avalonia.Controls.DataGrid是否也有类似的做法。一直没有心思去看那些代码，水平有限，实在搞不懂XML/Content一类如何实现绘制内容的。借着AI的帮助终于能试着去修改了。</p>\n<p>让AI从DataGrid的以下方法入手</p>\n<div class=\"cnblogs_code\">\n<pre>        <span style=\"color: rgba(0, 0, 255, 1);\">private</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> AddNewCellPrivate(DataGridRow row, DataGridColumn column)\n        {\n            DataGridCell newCell </span>= <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> DataGridCell();\n            PopulateCellContent(\n                isCellEdited: </span><span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">,\n                dataGridColumn: column,\n                dataGridRow: row,\n                dataGridCell: newCell);\n            </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (row.OwningGrid != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n            {\n                newCell.OwningColumn </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> column;\n                newCell.IsVisible </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> column.IsVisible;\n                </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (row.OwningGrid.CellTheme <span style=\"color: rgba(0, 0, 255, 1);\">is</span><span style=\"color: rgba(0, 0, 0, 1);\"> {} cellTheme)\n                {\n                    newCell.SetValue(ThemeProperty, cellTheme, BindingPriority.Template);\n                }\n            }\n            row.Cells.Insert(column.Index, newCell);\n            \n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 智能AutoMerge逻辑：比较当前行和下一行的数据\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">ApplySmartAutoMerge(row, column, newCell);</span>\n        }</pre>\n</div>\n<p>最后发现，DataGrid并没有为每行数据创建DataGridRow/DataGridCell，且还会复用这些创建出来的DataGridCell显其他行的数据。就是说上面的方法只是开始的显示内容是可预测的。</p>\n<p>多次尝试后，发现绘制前都会调用DataGridCell的EnsureGridLine方法，于是将合并的代码主要放在其中</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> EnsureGridLine(DataGridColumn lastVisibleColumn)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (OwningGrid != <span style=\"color: rgba(0, 0, 255, 1);\">null</span> &amp;&amp; _rightGridLine != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (OwningGrid.VerticalGridLinesBrush != <span style=\"color: rgba(0, 0, 255, 1);\">null</span> &amp;&amp; OwningGrid.VerticalGridLinesBrush !=<span style=\"color: rgba(0, 0, 0, 1);\"> _rightGridLine.Fill)\n        {\n            _rightGridLine.Fill </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> OwningGrid.VerticalGridLinesBrush;\n        }\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">忽略其他代码<br />    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 调用DataGrid的CheckCellToMerge方法</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">var</span> (isSameAsPrevious, isSameAsNext) = OwningGrid?.CheckCellToMerge(<span style=\"color: rgba(0, 0, 255, 1);\">this</span>) ?? (<span style=\"color: rgba(0, 0, 255, 1);\">false</span>, <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">);    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 根据不同的组合情况处理底边框和透明度</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    HandleMergeResult(isSameAsPrevious, isSameAsNext);\n}</span></pre>\n</div>\n<p>至此，DataGrid决定如何合并，返回当前行与上一行和下一行的数据是否可以合并（现在只是简单的比较当前列的内容是否一致）。</p>\n<p><img alt=\"simplemerge\" height=\"551\" src=\"https://img2024.cnblogs.com/blog/12683/202602/12683-20260210174136165-1383757098.png\" width=\"704\" /></p>\n<p>有一个小小的问题，在滚动时合并列可能会显示空白。虽说在用的winform版的datagridview也有这个小问题。但新的东西多少有点改进，对吧。于是我向AI发出要求。最大的帮助就是判断是否是当前显示的第一列的方法了。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;summary&gt;</span>\n<span style=\"color: rgba(128, 128, 128, 1);\">///</span><span style=\"color: rgba(0, 128, 0, 1);\"> 判断指定行是否为可视区域的第一行\n</span><span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;/summary&gt;</span>\n<span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;param name=\"row\"&gt;</span><span style=\"color: rgba(0, 128, 0, 1);\">要检查的行</span><span style=\"color: rgba(128, 128, 128, 1);\">&lt;/param&gt;</span>\n<span style=\"color: rgba(128, 128, 128, 1);\">///</span> <span style=\"color: rgba(128, 128, 128, 1);\">&lt;returns&gt;</span><span style=\"color: rgba(0, 128, 0, 1);\">true表示是可视区域的第一行，false表示不是</span><span style=\"color: rgba(128, 128, 128, 1);\">&lt;/returns&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">public</span> <span style=\"color: rgba(0, 0, 255, 1);\">bool</span><span style=\"color: rgba(0, 0, 0, 1);\"> IsFirstVisibleRow(DataGridRow row)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (_rowsPresenter == <span style=\"color: rgba(0, 0, 255, 1);\">null</span> || row == <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(0, 0, 255, 1);\">false</span><span style=\"color: rgba(0, 0, 0, 1);\">;\n        \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 遍历可视区域的所有行，找到索引最小的行</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">int</span> firstVisibleRowIndex = <span style=\"color: rgba(0, 0, 255, 1);\">int</span><span style=\"color: rgba(0, 0, 0, 1);\">.MaxValue;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (Control element <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> _rowsPresenter.Children)\n    {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (element <span style=\"color: rgba(0, 0, 255, 1);\">is</span> DataGridRow visibleRow &amp;&amp;<span style=\"color: rgba(0, 0, 0, 1);\"> visibleRow.IsVisible)\n        {\n            firstVisibleRowIndex </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> Math.Min(firstVisibleRowIndex, visibleRow.Index);\n        }\n    }\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 如果指定行索引等于可视区域最小索引，则为第一行</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">return</span> row.Index ==<span style=\"color: rgba(0, 0, 0, 1);\"> firstVisibleRowIndex;\n}</span></pre>\n</div>\n<p>人工分析后发现，DataGridCell的EnsureGridLine不知为何只是lastVisibleColumn有调用，并不是行中的全部列。滚动的刷新由DataGridCellsPresenter发起，看以下方法</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">internal</span> <span style=\"color: rgba(0, 0, 255, 1);\">void</span><span style=\"color: rgba(0, 0, 0, 1);\"> EnsureFillerVisibility()\n{\n    DataGridFillerColumn fillerColumn </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> OwningGrid.ColumnsInternal.FillerColumn;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">忽略其他代码\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> This must be done after the Filler visibility is determined.  This also must be done\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> regardless of whether or not the filler visibility actually changed values because\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> we could scroll in a cell that didn't have EnsureGridLine called yet</span>\n    DataGridColumn lastVisibleColumn =<span style=\"color: rgba(0, 0, 0, 1);\"> OwningGrid.ColumnsInternal.LastVisibleColumn;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span> (lastVisibleColumn != <span style=\"color: rgba(0, 0, 255, 1);\">null</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n    {\n        DataGridCell cell </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> OwningRow.Cells[lastVisibleColumn.Index];\n        cell.EnsureGridLine(lastVisibleColumn);</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">不知道为什么只是最后一列需要执行。</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 检查是否为首行显示，如果是则清除合并单元格的透明度</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">bool</span> isFirstVisualRow = (OwningGrid?.IsFirstVisibleRow(OwningRow) == <span style=\"color: rgba(0, 0, 255, 1);\">true</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">foreach</span> (DataGridCell cell <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> OwningRow.Cells)\n    {\n        cell</span>?.ClearMergeOpacity(isFirstVisualRow);<span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">否的时候，可能需要恢复透明度</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    }\n}</span></pre>\n</div>\n<p>好了，这就是全部修改。代码在gitee</p>\n<p><a href=\"https://gitee.com/kevin2y/Avalonia.Controls.DataGrid/tree/feature/auto-merge-enhancement\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/kevin2y/Avalonia.Controls.DataGrid/tree/feature/auto-merge-enhancement</a></p>\n<p>&nbsp;</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-10 17:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/kevin-Y\">生命体验之kevin-Y</a>&nbsp;\n阅读(<span id=\"post_view_count\">100</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "记录一次bug：不可见字符/零宽字符",
      "link": "https://www.cnblogs.com/Az1r/p/19600679",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Az1r/p/19600679\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 16:59\">\n    <span>记录一次bug：不可见字符/零宽字符</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"1-现象\">1. 现象</h3>\n<p>在处理 CSV 文件导入时，你可能遇到过这种“灵异事件”：</p>\n<ul>\n<li>CSV 文件第一列叫 <code>tag_id</code>。</li>\n<li>程序用 <code>encoding/csv</code> 读进 Map 后，尝试用 <code>mp[\"tag_id\"]</code> 取值。</li>\n<li>结果： 永远返回空值，但打印整个 Map 时，肉眼看 Key 确实是 <code>tag_id</code>。</li>\n<li>而这其实是你遇到了<strong>零宽字符</strong>： 【ZWNBSP】。</li>\n</ul>\n<details>\n点击查看代码\n<pre><code>package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n)\n\n/*\n  [模拟 CSV 表格结构]\n  文件编码: UTF-8 with BOM (字节流开头包含 \\xef\\xbb\\xbf)\n\n  |  列名 (Header)   |  数据 (Row 1)  |\n  |-----------------|---------------|\n  | [ZWNBSP]tag_id  |      1        |\n  |      name       |    Popular    |\n\n  注：[ZWNBSP] 在编辑器和 Excel 中完全不可见，但在内存中占 3 个字节。\n*/\n\nfunc main() {\n\t// 1. 模拟 CSV 内容：手动在开头加入 UTF-8 BOM (\\xef\\xbb\\xbf)\n\tcontent := \"\\xef\\xbb\\xbf\" + \"tag_id,name\\n1,Gemini\"\n\n\t// 2. 解析 CSV\n\treader := csv.NewReader(bytes.NewBufferString(content))\n\trecords, _ := reader.ReadAll()\n\n\t// 3. 构建 Map\n\theader := records[0]\n\trow := records[1]\n\tmp := make(map[string]string)\n\tfor i, colName := range header {\n\t\tmp[colName] = row[i]\n\t}\n\n\t// 4. 尝试通过标准字符串 Key 读取\n\ttargetKey := \"tag_id\"\n\tval, exists := mp[targetKey]\n\n\t/*\n\t   [预计打印结果]\n\n\t   --- 结果演示 ---\n\t   直接打印 Map: map[tag_id:1 name:Gemini]  &lt;-- 肉眼看完全正常\n\t   尝试读取 Key [tag_id]: 成功? false, 值:     &lt;-- 实际上找不到，因为多出来的 3 字节在作祟\n\n\t   --- 真相揭秘 (十六进制对比) ---\n\t   Map 里的 Key (Hex): efbbbf7461675f6964  &lt;-- 前面多出了 efbbbf (ZWNBSP)\n\t   代码里的 Key (Hex): 7461675f6964        &lt;-- 纯净的 tag_id\n\t*/\n\n\tfmt.Println(\"--- 结果演示 ---\")\n\tfmt.Printf(\"直接打印 Map: %v\\n\", mp)\n\tfmt.Printf(\"尝试读取 Key [%s]: 成功? %v, 值: %s\\n\", targetKey, exists, val)\n\n\tfmt.Println(\"\\n--- 真相揭秘 (十六进制对比) ---\")\n\tfor k := range mp {\n\t\tif strings.Contains(k, \"tag_id\") {\n\t\t\tfmt.Printf(\"Map 里的 Key (Hex): %x\\n\", k)\n\t\t\tfmt.Printf(\"代码里的 Key (Hex): %x\\n\", targetKey)\n\t\t}\n\t}\n\n\t// 5. 使用清洗函数修复\n\tfmt.Println(\"\\n--- 修复后尝试 ---\")\n\tcleanMp := make(map[string]string)\n\tfor i, colName := range header {\n\t\tcleanMp[CleanString(colName)] = row[i]\n\t}\n\t_, existsNow := cleanMp[targetKey]\n\tfmt.Printf(\"清洗后读取 Key [%s]: 成功? %v\\n\", targetKey, existsNow)\n}\n\n// CleanString 是处理 CSV 列名的“强力去污剂”\nfunc CleanString(s string) string {\n\t// 移除 BOM 前缀并剔除所有不可见字符\n\treturn strings.Map(func(r rune) rune {\n\t\tif unicode.IsGraphic(r) {\n\t\t\treturn r\n\t\t}\n\t\treturn -1\n\t}, strings.TrimPrefix(s, \"\\xef\\xbb\\xbf\"))\n}\n</code></pre>\n</details>\n<p>零宽字符 = 看不见的字符,但它真的在文本里。</p>\n<h3 id=\"2-分析\">2. 分析</h3>\n<h4 id=\"为什么会有这种字符\"><strong>为什么会有这种字符？</strong></h4>\n<p>这类问题通常由 <strong>BOM (Byte Order Mark)</strong> 引起。</p>\n<ul>\n<li>\n<p><strong>来源：</strong> 当你使用 Windows Excel 另存为 UTF-8 格式时，或飞书表格保存为csv文件时，Excel 会在文件最开头自动添加 <code>0xEF 0xBB 0xBF</code> 三个字节。</p>\n</li>\n<li>\n<p><strong>本质：</strong> 在 Unicode 中，这被称为 <strong>ZWNBSP</strong>（Zero Width No-Break Space，零宽不换行空格，<code>U+FEFF</code>）。它的设计初衷是标记字节序，但在现代 UTF-8 环境下，它往往变成了“数据杂质”。</p>\n</li>\n</ul>\n<h4 id=\"为什么-go-无法匹配\"><strong>为什么 Go 无法匹配？</strong></h4>\n<p>Go 的 <code>map[string]string</code> 查找是基于<strong>字节流</strong>的精确匹配。</p>\n<ul>\n<li>\n<p><strong>预期 Key：</strong> <code>[116 97 103 95 105 100]</code> (即 <code>tag_id</code>)</p>\n</li>\n<li>\n<p><strong>实际的 Key：</strong> <code>[239 187 191 116 97 103 95 105 100]</code> (即 <code>\\ufefftag_id</code>)</p>\n</li>\n</ul>\n<p>常见的零宽字符：</p>\n<table>\n<thead>\n<tr>\n<th><strong>名称</strong></th>\n<th><strong>Unicode</strong></th>\n<th><strong>作用说明</strong></th>\n<th><strong>对程序的干扰</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>零宽无断行空格 (ZWNBSP/BOM)</strong></td>\n<td><code>\\uFEFF</code></td>\n<td>防止自动换行；在文件头作为 BOM 标记编码</td>\n<td><strong>最常见</strong>。导致 CSV 首列 Key 无法读取。</td>\n</tr>\n<tr>\n<td><strong>零宽空格 (ZWSP)</strong></td>\n<td><code>\\u200B</code></td>\n<td>用于分隔长单词以便在必要时换行</td>\n<td>插入在字符串中间，导致 <code>len()</code> 长度增加。</td>\n</tr>\n<tr>\n<td><strong>零宽连接符 (ZWJ)</strong></td>\n<td><code>\\u200D</code></td>\n<td>用于组合多个 Emoji（如 👨‍👩‍👧）或复杂文字</td>\n<td>强行过滤会导致组合 Emoji 被拆解。</td>\n</tr>\n<tr>\n<td><strong>零宽非连接符 (ZWNJ)</strong></td>\n<td><code>\\u200C</code></td>\n<td>打断字符连写（常见于阿拉伯语、印度文）</td>\n<td>改变文本的二进制表示。</td>\n</tr>\n<tr>\n<td><strong>左右文字方向符 (LRM/RLM)</strong></td>\n<td><code>\\u200E</code> / <code>\\u200F</code></td>\n<td>混合排版时控制文字从左往右或从右往左</td>\n<td>导致字符串比较逻辑失效。</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h3 id=\"3-解决\">3. 解决</h3>\n<pre><code>package main\n\nimport (\n\t\"regexp\"\n)\n\n// 用正则匹配常见的零宽字符区间\nvar reZeroWidth = regexp.MustCompile(`[\\u200B-\\u200D\\uFEFF\\u200E\\u200F]`)\n\nfunc SafeClean(s string) string {\n\treturn reZeroWidth.ReplaceAllString(strings.TrimSpace(s), \"\")\n}\n</code></pre>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/Az1r/\" target=\"_blank\">江水为竭</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/Az1r/p/19600679\" target=\"_blank\">https://www.cnblogs.com/Az1r/p/19600679</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-10 16:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Az1r\">江水为竭</a>&nbsp;\n阅读(<span id=\"post_view_count\">222</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "KMP模式匹配算法——详细讲解、清晰易懂",
      "link": "https://www.cnblogs.com/CodingCat-jiumi/p/19555666",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/CodingCat-jiumi/p/19555666\" id=\"cb_post_title_url\" title=\"发布于 2026-02-10 16:30\">\n    <span>KMP模式匹配算法——详细讲解、清晰易懂</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        KMP算法是由D.E. Knuth、J.H. Morris和V.R. Pratt(其中Knuth和Pratt共同研究, Mor-ris独立研究)发表一个模式匹配算法，KMP算法的最大特点使得它在处理大量文本匹配的问题时，比暴力枚举算法有更好的性能。\n关于字符串匹配，是字符串很重要的知识点，也是面试笔试的高频考点。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"kmp算法介绍\">KMP算法介绍</h2>\n<p>KMP算法是由D.E. Knuth、J.H. Morris和V.R. Pratt(其中Knuth和Pratt共同研究,  Mor-ris独立研究)发表一个模式匹配算法，KMP算法的最大特点使得它在处理大量文本匹配的问题时，比暴力枚举算法有更好的性能。</p>\n<p>关于字符串匹配，是字符串很重要的知识点，也是面试笔试的高频考点。Leetcode的第28题就是考查字符串匹配算法。另外本文是查看了《大话数据结构》这本书做的总结，同时next数组部分也参考了这篇博客<a href=\"https://blog.csdn.net/gmynebula/article/details/125239503\" rel=\"noopener nofollow\" target=\"_blank\">KMP算法中next数组的计算</a>。</p>\n<p>KMP是由基础的字符串匹配BF算法改进而来的</p>\n<h2 id=\"kmp模式匹配算法原理\">KMP模式匹配算法原理</h2>\n<p>目标串（主串） S = \"heloohello\", 模式串（子串） T = \"hello\"。我们要从主串 S 中找到子串 T 的位置。如果使用BF算法，步骤如下图所示。</p>\n<div align=\"center\">\n<img class=\"lazyload\" width=\"60%\" />\n</div>\n<p>在 ① 中当 S 和 T 不匹配时，BF算法的操作是主串 S 回退到 i-j+1（从本次匹配的初始位置后移一位，图中步骤②的位置），匹配串 T 回退到 j = 0 (初始位置）, 然后执行 ②③④⑤⑥ 步依次进行匹配，但所有这些步骤一定都是必需的吗？</p>\n<p>在步骤 ① 中，单看模式串 T，前三个字符均不相等（'h' != 'e' != 'l'），同时S 和 T 串前三个字符又相匹配，那么模式串 T 的首字符'h' 自然不可能和主串 S 的第二、三位字符相等。所以步骤②③都是多余的。这是KMP算法的关键所在，如果我们知道 T 串中哪些字符相等（也是关键点，后续会讲），那么有些步骤就可以省略。</p>\n<div align=\"center\">\n<img class=\"lazyload\" width=\"50%\" />\n</div>\n<p>因此只需要保留①④⑤⑥的步骤即可。从下图可以看出，指针 i 是不是一直没有回溯？这就是KMP的妙处所在。在KMP中，指针 i 永远不会回溯，只有指向模式串的指针 j 会发生回溯。在本例中 j 每次都回退到首元素，我们再举一个例子，看看 j 会怎么变化。</p>\n<div align=\"center\">\n<img class=\"lazyload\" width=\"60%\" />\n</div>\n<p>第二个例子：</p>\n<p>目标串（主串） S = \"abcababca\", 模式串（子串） T = \"abcabx\"。BF算法执行过程如下图所示，在步骤 ① 中前5个字符完全相等，根据上一个例子的经验，已知模式串T中第一位字符与第二位、第三位不等（后续会根据next[]数组计算得出），步骤 ②③ 都是多余的，直接省略。</p>\n<div align=\"center\">\n<img class=\"lazyload\" width=\"60%\" />\n</div>\n<p>与上个例子不同的是，这里的模式串 T 的首位字符 'a' 与 T 第四位的 'a' 相等，第二位的 'b' 与第五位的 'b' 相等，而在 ① 中,第四位的 'a' 第五位的 'b' 已经与主串 S 中的相应位置比较过了，是相等的。因此可以断定,T 的首字符 'a'、第二位的字符 'b' 与 S 的第四位字符和第五位字符肯定也是相等的，所以 ④⑤ 这两个比较得出字符相等的步骤也可以省略。</p>\n<div align=\"center\">\n<img class=\"lazyload\" width=\"60%\" />\n</div>\n<p>总结上面两个例子，在KMP算法中，<strong>主串的 i 值</strong>是<strong>不需要回溯</strong>的。所以我们只需要考虑变化的 j 值，模式串 j 值的变化通过观察可以发现，当主串和模式串不匹配时，下一步 j 该指向哪个元素<strong>只与模式串 T 本身有关系</strong>。当发现有相同的字符，j 的变化也就会不同。</p>\n<p>在KMP中，当主串和模式串不匹配时, 下一步 j 值的多少取决于当前字符之前的串的前后缀的相似度。</p>\n<h2 id=\"next数组\">next数组</h2>\n<h3 id=\"基础知识\">基础知识</h3>\n<p>在我们计算next数组之前，我们先讲解一些基础知识。</p>\n<ul>\n<li>前缀：字符串的开头，例如字符串abcd的前缀为a, ab, abc, abcd。在KMP算法中使用的前缀为真前缀，既不包括原字符串abcd的前缀。（真前缀：a, ab, abc）</li>\n<li>后缀：字符串的结尾，在KMP算法中同样使用的是真后缀(bcd,cd,d)。</li>\n<li>最长公共前后缀：最长的相等的前缀与后缀，例如字符串ABCxyzABC的最长公共前后缀为ABC\n<ul>\n<li>ABCXYABC的真前缀：A，AB, <strong>ABC</strong>, ABCx, ABCxy, ABCxyz, ABCxyzA, ABCxyzAB</li>\n<li>ABCXYABC的真后缀：BCxyzABC, CxyzABC, xyzABC, yzABC, zABC, <strong>ABC</strong>, BC, C</li>\n</ul>\n</li>\n<li>前缀表：存储每一个前缀的最长公共前后缀的长度。<br />\n举例：若模式串 T=\"abaaabaaca\"。</li>\n</ul>\n<div align=\"center\">\n<img class=\"lazyload\" width=\"50%\" />\n</div>\n<ul>\n<li>next数组：把 T 串各个位置的 j 的变化定义为数组 next，next 的长度就是 T 串的长度。主串和模式串不匹配时，下一步 j 的值由 next[j] 决定。例如目标串 S=\"abcaba\", T=\"aba\", 根据前缀表求出 next=[-1,0 0], 当 j=2 时发生不匹配, next[2]=0, 下一步 j 将等于 0 进行字符匹配。</li>\n</ul>\n<div align=\"center\">\n<img alt=\"绘图13.png\" class=\"lazyload\" width=\"50%\" />\n</div>\n<h3 id=\"前缀表和next数组的关系\">前缀表和next数组的关系</h3>\n<p>前缀表存储每一个前缀的最长公共前后缀的长度，next数组存储的是模式串向右移动到next值的位置，这个值与前缀的最长公共前后缀的长度有关，所以next数组是可以由前缀表生成的。<br />\n用前缀表生成一个next数组很容易，将前缀表每一位都向后移动1位（最后一位舍去）并在第一位补一个-1就得到了next数组。</p>\n<div align=\"center\">\n<img alt=\"绘图14.png\" class=\"lazyload\" width=\"50%\" />\n</div>\n<p>如果有同学不理解这个关系还可以看一下手动推理过程：<br />\nT=\"abaaabaaca\"</p>\n<ol>\n<li>位置0上的元素a前面没有子串，令next[0]=-1</li>\n<li>位置1上的元素b前面的字符串为\"a\"，字符串\"a\"没有最长公共前后缀，next[1]=0</li>\n<li>位置2上的元素a前面的字符串为\"ab\",\"ab\"没有最长公共前后缀，next[2]=0</li>\n<li>位置3上的元素a前面的字符串为\"aba\"，最长公共前后缀为\"a\"，next[3]=1</li>\n<li>位置4上的元素a前面的字符串为\"abaa\"，最长公共前后缀为\"a\"，next[4]=1</li>\n<li>位置5上的元素b前面的字符串为\"abaaa\"，最长公共前后缀为\"a\"，next[5]=1</li>\n<li>位置6上的元素a前面的字符串为\"abaaab\"，最长公共前后缀为\"ab\"，next[6]=2</li>\n<li>位置7上的元素a前面的字符串为\"abaaaba\"，最长公共前后缀为\"aba\"，next[7]=3</li>\n<li>位置8上的元素a前面的字符串为\"abaaabaa\"，最长公共前后缀为\"abaa\"，next8]=4</li>\n<li>位置9上的元素a前面的字符串为\"abaaabac\"，没有最长公共前后缀，next[9]=0</li>\n</ol>\n<p>同时在<a href=\"https://blog.csdn.net/gmynebula/article/details/125239503\" rel=\"noopener nofollow\" target=\"_blank\">KMP算法中next数组的计算</a>这篇博客中提到了一个地方：为什么有些next数组是0,1开头，而有些next数组是-1,0开头？</p>\n<blockquote>\n<p>-1,0开头与0, 1开头的next数组本质是一样的。实际上，以0, 1开头的next数组就是以-1,0开头的next数组每一项加1得到的。出现这种情况的原因在于模式串起始的索引值：在程序中，一个数组的索引的起始值为0；然而在考试和书中给的模式串起始值是多从1开始。所以在考试中遇到的next数组通常是以0, 1开头；而一些程序或教程中的next数组是以-1, 0开头。<br /><br />\n注：在考试中通常会给模式串的索引，或者会给next值的前两项，在答题时要按照题目中的要求写next数组。</p>\n</blockquote>\n<h2 id=\"代码实现\">代码实现</h2>\n<p>next数组的代码实现, 可以计算出当前匹配串 T 的 next 数组</p>\n<pre><code class=\"language-cpp\">void get_next(string T, int *next) {\n\tnext[0] = -1;\n\tint i = 0;\n\tint j = -1;\n\t\n\twhile(i &lt; T.size() - 1) {\n\t\t//T[i]表示后缀的单个字符\n\t\t//T[j]表示前缀的单个字符\n\t\tif(j == -1 || T[i] == T[j]){//\n\t\t\t++i;\n\t\t\t++j;\n\t\t\tnext[i] = j;\n\t\t} else {\n\t\t\t//如果字符不相同，则j值回溯\n\t\t\tj = next[j];\n\t\t}\n\t}\n}\n</code></pre>\n<p>KMP代码实现</p>\n<pre><code class=\"language-cpp\">int KMP(string S, string T) {\n    int ans = -1;\n    // i用于遍历主串S\n    int i = 0;\n    // j用于遍历匹配串T\n    int j = 0;\n    int next[255]; // 这里初始长度为255,需自行调整\n    // 对T做分析，得到next数组\n    get_next(T, next);\n    while (i &lt; S.size()) {\n        // 匹配成功则继续向下一个字符进行匹配\n        if (j == -1 || S[i] == T[j]) {\n            ++i;\n            ++j;\n        }\n        // 匹配失败进行回溯\n        else {\n            // j回溯到合适的位置\n            j = next[j];\n        }\n        if (j == T.size()) {\n            ans = i - T.size();\n            break;\n        }\n    }\n    return ans;\n}\n</code></pre>\n<h2 id=\"时间复杂度\">时间复杂度</h2>\n<p>令 n 为主串长度，m 为要匹配的子串长度。</p>\n<p>对于Get_next函数来说，时间复杂度为O(m)，因为i值不回溯，所以使得KMP算法效率得到提高，在KMP函数中while循环的时间复杂度为O(n)，因此整个算法的时间复杂度为O(n + m)。</p>\n<p>KMP算法仅当模式与主串之间存在许多“部分匹配”时，才会体现出它的优势，否则两者差异不明显。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-02-10 16:30</span>&nbsp;\n<a href=\"https://www.cnblogs.com/CodingCat-jiumi\">ctxIQ为0</a>&nbsp;\n阅读(<span id=\"post_view_count\">63</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    }
  ]
}