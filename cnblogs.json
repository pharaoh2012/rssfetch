{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "[拆解LangChain执行引擎] PregelProtocol——定义了\"LangChain执行体\"最小功能集",
      "link": "https://www.cnblogs.com/jaydenai/p/19619278/pregel-protocol",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jaydenai/p/19619278/pregel-protocol\" id=\"cb_post_title_url\" title=\"发布于 2026-02-16 07:22\">\n    <span>[拆解LangChain执行引擎] PregelProtocol——定义了\"LangChain执行体\"最小功能集</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Pregel是对PregelProtocol协议的实现，后者的引入标志着 LangGraph 从一个单一的库进化为了一个可插拔的图计算框架。图可以视为“LangGraph 执行体”，而PregelProtocol定义了它必须具备的最小功能集合\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>Pregel是对<code>PregelProtocol</code>协议的实现，后者的引入标志着 LangGraph 从一个单一的库进化为了一个可插拔的图计算框架。图可以视为“LangGraph 执行体”，而PregelProtocol定义了它必须具备的最小功能集合。我们从这协议的成员定义来看看这个功能集合包含哪些操作。</p>\n<h2 id=\"1-配置绑定\">1. 配置绑定</h2>\n<p>通过前面的内容我们会发现<code>RunnableConfig</code>这个对象几乎时无所不在，我们在调用Pregel对象的时候可以将它作为参数，用来提供用于控制其执行行为（比如迭代限制，并发控制等）的配置。执行引擎还将它作为容器用来下流流程传递一些组件和信号，所以前面的演示实例才可以在Node处理函数中从注入的RunnableConfig中提取像<code>Runtime</code>、<code>PregelScratchpad</code>、<code>Checkpoint命名空间</code>和<code>静态上下文</code>这样对象和信息。对于单纯Pregel的Node（不包括StateGraph的Node），RunnableConfig使唯一可以注入到处理函数中的参数，所以除了输入参数，其他所需的信息只能从它里面提取。</p>\n<p><code>with_config</code>方法赋予了这个 “执行体”与配置绑定的能力。除了提供RunnableConfig对象，我们还可以利用关键词参数提供待绑定的配置。由于RunnableConfig本质上就是一个TypedDict对象，提供的关键字参数组成的键值对可以直接转换成RunnableConfig对象。with_config方法会将两者合并，生成一个新的RunnableConfig对象绑定到执行体上。</p>\n<pre><code class=\"language-python\">class PregelProtocol(Runnable[InputT, Any], Generic[StateT, ContextT, InputT, OutputT]):\n    @abstractmethod\n    def with_config(\n        self, config: RunnableConfig | None = None, **kwargs: Any\n    ) -&gt; Self: ...\n</code></pre>\n<h2 id=\"2-可视化呈现\">2. 可视化呈现</h2>\n<p>PregelProtocol是LangGraph对 “图” 的抽象，这里的图是 “图论” 的概念，但是若真能将它的结构呈现在一张 “图片” 中，这无疑是非常有意义的。毕竟代码仅仅是面向程序员的语言，比不上图片，不但直观，还没有受众限制。LangGraph专门定义了如下这个Graph类型来表示面向 “可视化呈现” 的图。</p>\n<p>一个Graph对象标识的图依然由Node和Edge构成。它的每个Node都有一个唯一标识，我们可以调用<code>next_id</code>方法为下一个待添加的Node生成此标识。我们不仅可以调用<code>add_node</code>、<code>remove_node</code>和<code>add_edge</code>这样的方法以添加/移除Node和Edge来构建图，还可以调用<code>extend</code>方法将另一个Graph的所有Node和Edge添加进来。</p>\n<pre><code class=\"language-python\">@dataclass\nclass Graph:\n    nodes: dict[str, Node] = field(default_factory=dict)\n    edges: list[Edge] = field(default_factory=list)\n    \n    def next_id(self) -&gt; str\n    def add_node(\n        self,\n        data: type[BaseModel] | RunnableType | None,\n        id: str | None = None,\n        *,\n        metadata: dict[str, Any] | None = None,\n    ) -&gt; Node\n    def remove_node(self, node: Node) -&gt; None\n    def add_edge(\n        self,\n        source: Node,\n        target: Node,\n        data: Stringifiable | None = None,\n        conditional: bool = False,  # noqa: FBT001,FBT002\n    ) -&gt; Edge\n    def extend(\n        self, graph: Graph, *, prefix: str = \"\"\n    ) -&gt; tuple[Node | None, Node | None]:\n\n    def reid(self) -&gt; Graph:\n    def first_node(self) -&gt; Node | None\n    def last_node(self) -&gt; Node | None\n    def trim_first_node(self) -&gt; None\n    def trim_last_node(self) -&gt; None\n\n    def to_json(self, *, with_schemas: bool = False) -&gt; dict[str, list[dict[str, Any]]]\n    def draw_ascii(self) -&gt; str:\n    def print_ascii(self) -&gt; None:\n    @overload\n    def draw_png(\n        self,\n        output_file_path: str,\n        fontname: str | None = None,\n        labels: LabelsDict | None = None,\n    ) -&gt; None: ...\n    @overload\n    def draw_png(\n        self,\n        output_file_path: None,\n        fontname: str | None = None,\n        labels: LabelsDict | None = None,\n    ) -&gt; bytes: ...\n    def draw_png(\n        self,\n        output_file_path: str | None = None,\n        fontname: str | None = None,\n        labels: LabelsDict | None = None,\n    ) -&gt; bytes | None\n    def draw_mermaid(\n        self,\n        *,\n        with_styles: bool = True,\n        curve_style: CurveStyle = CurveStyle.LINEAR,\n        node_colors: NodeStyles | None = None,\n        wrap_label_n_words: int = 9,\n        frontmatter_config: dict[str, Any] | None = None,\n    ) -&gt; str\n    def draw_mermaid_png(\n        self,\n        *,\n        curve_style: CurveStyle = CurveStyle.LINEAR,\n        node_colors: NodeStyles | None = None,\n        wrap_label_n_words: int = 9,\n        output_file_path: str | None = None,\n        draw_method: MermaidDrawMethod = MermaidDrawMethod.API,\n        background_color: str = \"white\",\n        padding: int = 10,\n        max_retries: int = 1,\n        retry_delay: float = 1.0,\n        frontmatter_config: dict[str, Any] | None = None,\n        base_url: str | None = None,\n        proxies: dict[str, str] | None = None,\n    ) -&gt; bytes\n</code></pre>\n<p>调用<code>reid</code>方法可以返回一个新的Graph对象，它尽量保留途中可读性的元素，但是Node的ID会重新生成。Graph的<code>first_node</code>和<code>last_node</code>方法返回第一个和最后一个Node。如果我们希望删除第一个只有单一输出Edge或者最后一个只有单一输入Edge的Node，可以调用<code>trim_first_node</code>或者<code>trim_last_node</code>方法。</p>\n<p>构建好的Graph可以采用不同的呈现方式。Graph提供了五个“绘图”方法，其中<code>draw_ascii</code>和<code>print_ascii</code>采用ascii码字符的呈现方式，前者返回具体的ascii码字符串，后者则直接在终端将图绘制出来，这种方法不依赖其他的绘图相关的包。<code>draw_mermaid</code>和<code>draw_mermaid_png</code>采用Mermaid图表的呈现方式，Mermaid 是一种基于文本的流程图定义语言，广泛支持于 GitHub、Notion 和各种编辑器中。draw_mermaid返回图标文本，而<code>draw_mermaid_png</code>则直接将图表进一步渲染成PNG图片。Graph对象也可以通过调用<code>draw_png</code>方法渲染成PNG图片，该方法最终会Graphviz（一个开源的图可视化软件）来布局和渲染图片。</p>\n<p>再回到PregelProtocol类型的定义上，它定义了如下所示的<code>get_graph/aget_graph</code>方法，它们的返回类型DrawableGraph正是上述Graph类型的别名。该方法除了可以传入RunnableConfig对象作为可选配置外，还具有一个名为<code>xray</code>的参数。xray（X光）参数决定了你在查看图结构时，到底能看多深。它专门用于处理子图的展开显示。如果设置为False（默认值），图将以 “黑盒” 模式显式，如果你的图中包含子图，它只会显示为一个单一的节点。你看不见子图内部的任何节点、边或逻辑。反之将会采用 “全展开” 模式，它会像 X 光一样穿透所有层级，将所有嵌套子图内部的节点和连线全部平铺出来。</p>\n<pre><code class=\"language-python\">from langchain_core.runnables.graph import Graph as DrawableGraph\nclass PregelProtocol(Runnable[InputT, Any], Generic[StateT, ContextT, InputT, OutputT]):\n    @abstractmethod\n    def get_graph(\n        self,\n        config: RunnableConfig | None = None,\n        *,\n        xray: int | bool = False,\n    ) -&gt; DrawableGraph: ...\n\n    @abstractmethod\n    async def aget_graph(\n        self,\n        config: RunnableConfig | None = None,\n        *,\n        xray: int | bool = False,\n    ) -&gt; DrawableGraph: ...\n</code></pre>\n<p>在第一个演示实例中，我们创建了一个作为“笑话生成器”的Agent，现在我们将它简化，看看由它生成的Graph如何将图的结构以可视化的形式呈现出来。如下面的代码片段所示，我们利用StateGraph作为Builder，构建了一张由两个Node组成的图，它们和Start和End之间有四条边。</p>\n<pre><code class=\"language-python\">from langgraph.graph import StateGraph, START, END\nfrom langgraph.pregel.protocol import PregelProtocol\nfrom PIL import Image as PILImage\nimport io\nfrom langgraph.checkpoint.memory import MemorySaver\n\ndef generate_joke(state):\n    pass\n\ndef regenerate_joke(state):\n    pass\n\nbuilder = (\n    StateGraph(dict)\n    .add_node(\"generate_joke\", generate_joke)\n    .add_node(\"regenerate_joke\", regenerate_joke)\n)\n\nbuilder.add_edge(START, \"generate_joke\")\nbuilder.add_edge(\"regenerate_joke\", END)\nbuilder.add_conditional_edges(\n    \"generate_joke\", lambda _: \"bad\", {\"good\": END, \"bad\": \"regenerate_joke\"}\n)\n\napp: PregelProtocol = builder.compile(MemorySaver())\ngraph = app.get_graph()\ngraph.print_ascii()\n\nbytes = graph.draw_mermaid_png()\nPILImage.open(io.BytesIO(bytes)).show()\n</code></pre>\n<p>在将StateGraph编译成Pregel对象后，我们调用其get_graph方法得到对应的Graph对象。我们以两种形式呈现其结构，前者通过调用print_ascii方法以ASCII字符的形式输出图结构，后者调用draw_mermaid_png方法生成一张PNG图片。下图左右两部分分别展现了两种呈现方式的效果。</p>\n<h2 id=\"3-持久化\">3. 持久化</h2>\n<p>为了支持“中断/恢复”的执行方式，同时为“时间旅行”提供支持，图必须利用持久化的方式将执行过程的重要时刻的状态保存下来。LangGraph采用基于<code>Checkpoint</code>的持久化形式，对于指定的每个任务，不论是执行成功针对Channel的写入意图，还是抛出异常、人为中断或者Resume Value的提供，都会以Pending Write的形式被记录下来；当超步成功完成，针对Channel的写入被成功应用，这些Pending Write被丢弃，换来一个Checkpoint来描述当前的状态。</p>\n<p>作为“LangGraph 执行体”的抽象，PregelProtocol定义了<code>get_state/aget_state</code>方法用于读取在某个Superstep由Checkpoint（对于最后一个未完成的Superstep，还包括Pending Write）构建的状态快照，该快照体现为一个StateSnapshot对象。<code>get_state_history/aget_state_history</code>返回由这些快照谱写的一段历史。</p>\n<pre><code class=\"language-python\">class PregelProtocol(Runnable[InputT, Any], Generic[StateT, ContextT, InputT, OutputT]):\n    @abstractmethod\n    def get_state(\n        self, config: RunnableConfig, *, subgraphs: bool = False\n    ) -&gt; StateSnapshot: ...\n\n    @abstractmethod\n    async def aget_state(\n        self, config: RunnableConfig, *, subgraphs: bool = False\n    ) -&gt; StateSnapshot: ...\n\n    @abstractmethod\n    def get_state_history(\n        self,\n        config: RunnableConfig,\n        *,\n        filter: dict[str, Any] | None = None,\n        before: RunnableConfig | None = None,\n        limit: int | None = None,\n    ) -&gt; Iterator[StateSnapshot]: ...\n\n    @abstractmethod\n    def aget_state_history(\n        self,\n        config: RunnableConfig,\n        *,\n        filter: dict[str, Any] | None = None,\n        before: RunnableConfig | None = None,\n        limit: int | None = None,\n    ) -&gt; AsyncIterator[StateSnapshot]: ...\n\n    @abstractmethod\n    def bulk_update_state(\n        self,\n        config: RunnableConfig,\n        updates: Sequence[Sequence[StateUpdate]],\n    ) -&gt; RunnableConfig: ...\n\n    @abstractmethod\n    async def abulk_update_state(\n        self,\n        config: RunnableConfig,\n        updates: Sequence[Sequence[StateUpdate]],\n    ) -&gt; RunnableConfig: ...\n\n    @abstractmethod\n    def update_state(\n        self,\n        config: RunnableConfig,\n        values: dict[str, Any] | Any | None,\n        as_node: str | None = None,\n    ) -&gt; RunnableConfig: ...\n\n    @abstractmethod\n    async def aupdate_state(\n        self,\n        config: RunnableConfig,\n        values: dict[str, Any] | Any | None,\n        as_node: str | None = None,\n    ) -&gt; RunnableConfig: ...\n</code></pre>\n<p>持久化存储的Checkpoint不仅使我们可以回顾历史，还可以提供“时间旅行”，使我们可以从某个历史时刻重新执行后面的流程。不仅如此，PregelProtocol还提供了<code>update_state /bulk_update_state/abulk_update_state</code>可以直接修改状态。但是它们并非“篡改历史”，只是基于某个在某个历史时刻开启了另一段“平行宇宙”而已。持久化使LangGraph.Pregel作为核心和部分，我们将在后续部分对它进行专门的介绍。</p>\n<h2 id=\"4-两种调用方式\">4. 两种调用方式</h2>\n<p>PregelProtocol的<code>invoke/ainvoke</code>和<code>stream/astream</code>方法体现了针对 “LangGraph 执行体” 两种调用方式。前者采用简单的请求/回复消息交换模式，客户端需要等整个流程结束之后采用得到结果。如果整个处理流程比较复杂，或者涉及一些耗时的操作，过长的等待会带来糟糕的体验。后者采用流式处理使客户端可以实施得到处理的中间结果或者感知到处理的进度。我们将在后续部分对流式处理进行单独介绍。</p>\n<pre><code class=\"language-python\">class PregelProtocol(Runnable[InputT, Any], Generic[StateT, ContextT, InputT, OutputT]):\n    @abstractmethod\n    def stream(\n        self,\n        input: InputT | Command | None,\n        config: RunnableConfig | None = None,\n        *,\n        context: ContextT | None = None,\n        stream_mode: StreamMode | list[StreamMode] | None = None,\n        interrupt_before: All | Sequence[str] | None = None,\n        interrupt_after: All | Sequence[str] | None = None,\n        subgraphs: bool = False,\n    ) -&gt; Iterator[dict[str, Any] | Any]: ...\n\n    @abstractmethod\n    def astream(\n        self,\n        input: InputT | Command | None,\n        config: RunnableConfig | None = None,\n        *,\n        context: ContextT | None = None,\n        stream_mode: StreamMode | list[StreamMode] | None = None,\n        interrupt_before: All | Sequence[str] | None = None,\n        interrupt_after: All | Sequence[str] | None = None,\n        subgraphs: bool = False,\n    ) -&gt; AsyncIterator[dict[str, Any] | Any]: ...\n\n    @abstractmethod\n    def invoke(\n        self,\n        input: InputT | Command | None,\n        config: RunnableConfig | None = None,\n        *,\n        context: ContextT | None = None,\n        interrupt_before: All | Sequence[str] | None = None,\n        interrupt_after: All | Sequence[str] | None = None,\n    ) -&gt; dict[str, Any] | Any: ...\n\n    @abstractmethod\n    async def ainvoke(\n        self,\n        input: InputT | Command | None,\n        config: RunnableConfig | None = None,\n        *,\n        context: ContextT | None = None,\n        interrupt_before: All | Sequence[str] | None = None,\n        interrupt_after: All | Sequence[str] | None = None,\n    ) -&gt; dict[str, Any] | Any: ...\n</code></pre>\n<p>执行体支持中断/恢复（interrupt/resume）的方式执行，所以在中断时需要将当时的状态以 “Checkpoint（Checkpoint）” 的形式保存下来，恢复执行的时候利用它们将当时的 “执行线程” 复原。Checkpointing的机制也使 “时间旅行” 成为可能，我们可以从任一Checkpoint开始执行。也正是因为此持久化机制的存在，我们可以提取某一个Superstep的状态，还可以查看整个执行历史，这两个功能分别对应PregelProtocol的<code>get_state/aget_state</code>和<code>get_state_history/aget_state_history</code>方法。具体的状态以StateSnapshot对象描述的快照表示。</p>\n<p>执行体应该具有将执行结果作为新的状态进行保存的能力，所以PregelProtocol定义了<code>update_state/aupdate_state</code>和<code>bulk_update_state/abulk_update_state</code>方法，前者保存单一状态更新，后者对多个状态更新进行批量执行。单一状态更新通过如下这个名为StateUpdate的命名元组表示，我们不仅可以利用values字段得到以字典形式表示的状态值，还可以通过<code>as_node</code>和<code>task_id</code>字段的得到实施更新的Node和具体任务标识。</p>\n<pre><code class=\"language-python\">class StateUpdate(NamedTuple):\n    values: dict[str, Any] | None\n    as_node: str | None = None\n    task_id: str | None = None\n</code></pre>\n<p>执行体支持两种基本的操作，一种采用单纯的请求/响应消息交换模式，另一种以流的形式实时返回数据，它们分别对应<code>invoke/ainvoke</code>和<code>stream/astream</code>方法。</p>\n<h2 id=\"5-嵌套结构\">5. 嵌套结构</h2>\n<p>我们一直在强调图的“嵌套”结构，这种结构也可以从Pregel、PregelNode和PregelProtocol在三个类型的定义。一个Pregel是PregelProtocol的实现、作为其节点的PregelNode对象可以由一个或者多个PregelProtocol组成，对于表示 “子图” 的subgraphs字段，并且该字段返回一个PregelProtocol对象的序列。Pregel的subgraphs方法返回的子图就来源于组成它的Node。</p>\n<pre><code class=\"language-python\">class PregelNode:\n    subgraphs\t: Sequence[PregelProtocol]\n\nclass Pregel(\n    PregelProtocol[StateT, ContextT, InputT, OutputT],\n    Generic[StateT, ContextT, InputT, OutputT]):\n    def get_subgraphs(\n        self, *, namespace: str | None = None, recurse: bool = False\n    ) -&gt; Iterator[tuple[str, PregelProtocol]]\n\n    async def aget_subgraphs(\n        self, *, namespace: str | None = None, recurse: bool = False\n    ) -&gt; AsyncIterator[tuple[str, PregelProtocol]]\n</code></pre>\n<p>PregelNode的subgraphs字段提供了 “子图” 的静态注册，其实任何一个Pregel对象都可以在无需注册前提下被另一个Pregel的Node调用，而且反映当前执行上下文的一些执行配置会通过上下文变量（ContenxtVars） “流向” 作为子图的Pregel对象。前面我们演示子图调用涉及的Checkpoint命名空间的例子已经充分体现了这一点。但是这种显式的静态声明对于图的静态图分析与可视化有着积极的作用。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-16 07:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jaydenai\">JaydenAI</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "8、SequenceInputStream的源码和Vector.class的一些函数说明（windows操作系统，JDK8）",
      "link": "https://www.cnblogs.com/Carey-ccl/p/19618752",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Carey-ccl/p/19618752\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 22:25\">\n    <span>8、SequenceInputStream的源码和Vector.class的一些函数说明（windows操作系统，JDK8）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h4 id=\"一sequenceinputstream源码可以顺序读取多个输入stream的装饰器类\">一、SequenceInputStream源码——可以顺序读取多个输入Stream的装饰器类</h4>\n<p>  SequenceInputStream.class 的UML关系图，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>  SequenceInputStream.class的源码，如下所示：</p>\n<pre><code>package java.io;\nimport java.io.InputStream;\nimport java.util.Enumeration;\nimport java.util.Vector;\n\npublic\nclass SequenceInputStream extends InputStream {\n    //顺序（序列化）装载多个被装饰输入Stream的集合，一般是Vector实例\n    Enumeration&lt;? extends InputStream&gt; e;\n    InputStream in;//顺序（序列化）装载多个被装饰输入Stream的集合中当前正在被SequenceInputStream 对象使用的被装饰的输入Stream\n    \n    //构造函数，传入一个顺序（序列化）装载多个被装饰输入Stream的集合\n    public SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e) {\n        this.e = e;\n        try {\n            nextStream();\n        } catch (IOException ex) {\n            // This should never happen\n            throw new Error(\"panic\");\n        }\n    }\n    \n    //构造函数，可以将2个被装饰的输入Stream放入到集合中\n    public SequenceInputStream(InputStream s1, InputStream s2) {\n        Vector&lt;InputStream&gt; v = new Vector&lt;&gt;(2);\n\n        v.addElement(s1);\n        v.addElement(s2);\n        e = v.elements();\n        try {\n            nextStream();\n        } catch (IOException ex) {\n            // This should never happen\n            throw new Error(\"panic\");\n        }\n    }\n    //获取集合中下一个被装饰的输入Stream\n    final void nextStream() throws IOException {\n        if (in != null) {\n            in.close();//先关闭当前被装饰的输入Stream\n        }\n\n        if (e.hasMoreElements()) {//如果集合中还有被装饰的输入Stream\n            in = (InputStream) e.nextElement();//获取集合中下一个被装饰的输入Stream\n            if (in == null)\n                throw new NullPointerException();//如果集合中下一个被装饰的输入Stream为null，抛出一个NullPointerException\n        }\n        else in = null;//如果集合中没有了被装饰的输入Stream，将当前正在使用的被装饰的输入Stream置为null\n\n    }\n    \n    //判断当前正在使用的被装饰的输入Stream是否还有可以读取的字节数据\n    public int available() throws IOException {\n        if (in == null) {\n            return 0; // no way to signal EOF from available()\n        }\n        return in.available();\n    }\n    \n    //从SequenceInputStream 对象的集合（该集合放着多个被装饰的输入Stream）中读取1个字节\n    public int read() throws IOException {\n        while (in != null) {//如果in!=null，则说明当前这个SequenceInputStream 对象的集合中还有被装饰的输入Stream没有关闭\n            int c = in.read();//从当前正在使用的被装饰的被装饰输入Stream中读取1个字节\n            if (c != -1) {//c != -1说明从当前正在使用的被装饰输入Stream中读取到了字节\n                return c;//返回读取到的这个字节\n            }\n            nextStream();//如果c==-1说明当前正在使用的被装饰输入Stream中字节（byte）数据已经读完，获取SequenceInputStream 对象的集合中下一个被装饰的输入Stream\n        }\n        return -1;//如果SequenceInputStream 对象的集合中所有被装饰的输入Stream中的字节（byte）数据都已经读完，返回-1\n    }\n\n    //从SequenceInputStream 对象的集合（该集合放着多个被装饰的输入Stream）中读取len个字节，放入到byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置\n    public int read(byte b[], int off, int len) throws IOException {\n        if (in == null) {//如果in==null，则说明当前这个SequenceInputStream 对象的集合中所有被装饰的输入Stream都已经关闭\n            return -1;\n        } else if (b == null) {\n            throw new NullPointerException();//如果byte[]数组b==null，抛出一个NullPointerException\n        } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {//相当于off + len &gt; b.length（源码中这样写代码的好处我没看出来）\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;//要从SequenceInputStream 对象的集合（该集合放着至少2个被装饰的输入Stream）中读取的len个字节==0时，返回0\n        }\n        do {\n            int n = in.read(b, off, len);//从当前正在使用的被装饰的输入Stream中读取len个字节，放入到byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置\n            if (n &gt; 0) {\n                return n;//只要能从当前正在使用的被装饰的输入Stream中读取到字节，则返回读取的数量\n            }\n            nextStream();//此时n==-1，说明当前正在使用的被装饰的输入Stream中字节（byte）数据已经读完，获取SequenceInputStream 对象的集合中下一个被装饰的输入Stream\n        } while (in != null);//SequenceInputStream 对象的集合中下一个被装饰的输入Stream为null时，跳出循环，返回-1\n        return -1;\n    }\n    //顺序关闭SequenceInputStream 对象的集合中所有被装饰的输入Stream\n    public void close() throws IOException {\n        do {\n            nextStream();\n        } while (in != null);\n    }\n}\n</code></pre>\n<h5 id=\"11sequenceinputstream的read函数和nextstream函数\">1.1、SequenceInputStream的read()函数和nextStream()函数</h5>\n<pre><code>package java.io;\nimport java.io.InputStream;\nimport java.util.Enumeration;\nimport java.util.Vector;\n\npublic\nclass SequenceInputStream extends InputStream {\n    ...省略部分代码...\n    //顺序（序列化）存储多个被装饰的输入Stream的集合，一般是Vector实例\n    Enumeration&lt;? extends InputStream&gt; e;\n    InputStream in;//顺序（序列化）装载多个被装饰输入Stream的集合中当前正在被SequenceInputStream 对象使用的被装饰的输入Stream\n    //获取集合中下一个被装饰的输入Stream\n    final void nextStream() throws IOException {\n        if (in != null) {\n            in.close();//先关闭当前被装饰的输入Stream\n        }\n\n        if (e.hasMoreElements()) {//如果集合中还有被装饰的输入Stream\n            in = (InputStream) e.nextElement();//获取集合中下一个被装饰的输入Stream\n            if (in == null)\n                throw new NullPointerException();//如果集合中下一个被装饰的输入Stream为null，抛出一个NullPointerException\n        }\n        else in = null;//如果集合中没有了被装饰的输入Stream，将当前正在使用的被装饰的输入Stream置为null\n\n    }\n    \n    //从SequenceInputStream 对象的集合（该集合放着多个被装饰的输入Stream）中读取1个字节\n    public int read() throws IOException {\n        while (in != null) {//如果in!=null，则说明当前这个SequenceInputStream 对象的集合中还有被装饰的输入Stream没有关闭\n            int c = in.read();//从当前正在使用的被装饰的被装饰输入Stream中读取1个字节\n            if (c != -1) {//c != -1说明从当前正在使用的被装饰输入Stream中读取到了字节\n                return c;//返回读取到的这个字节\n            }\n            nextStream();//如果c==-1说明当前正在使用的被装饰输入Stream中字节（byte）数据已经读完，获取SequenceInputStream 对象的集合中下一个被装饰的输入Stream\n        }\n        return -1;//如果SequenceInputStream 对象的集合中所有被装饰的输入Stream中的字节（byte）数据都已经读完，返回-1\n    }\n    ...省略部分代码...\n}\n</code></pre>\n<p>如果使用者用的是2个被装饰的输入Stream（此处为FileInputStream），构造的SequenceInputStream的对象，如下所示（伪代码）：</p>\n<pre><code>is1 = new FileInputStream(\"D:\\\\data1.txt\");\nis2 = new FileInputStream(\"D:\\\\data2.txt\");\nsequenceInputStream = new SequenceInputStream(is1, is2);\n</code></pre>\n<p>那么，SequenceInputStream对象中Vector集合的容量是2，如果此时执行SequenceInputStream.class::read()函数。</p>\n<pre><code>//伪代码\nint readByte = -1;\nwhile ((readByte = sequenceInputStream.read()) != -1) {\n   System.out.print((char) readByte);\n}\n</code></pre>\n<p>过程如下（假设2个被装饰的输入Stream（此处为FileInputStream）中的字节数据如下）：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>①、先执行第1个被装饰的输入Stream（也是Vector集合的第1个元素）的read()函数，直到该函数返回-1，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、关闭第1个被装饰的输入Stream（也是Vector集合的第1个元素），再执行第2个被装饰的输入Stream（也是Vector集合的第2个元素）的read()函数，直到该函数返回-1，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h6 id=\"111使用举例\">1.1.1、使用举例</h6>\n<p>  下面这个例子就恰当的使用SequenceInputStream的read()函数；</p>\n<ul>\n<li>\n<p>我的windows操作系统的D盘根目录下有2个txt文件，一个是data1.txt，另一个是data2.txt文件，这2个文件中总共有30个字节，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>使用者可以用一个SequenceInputStream对象装饰2个被装饰的输入Stream（此处为FileInputStream），如下代码所示：</p>\n</li>\n</ul>\n<pre><code>package com.chelong.StreamAndReader;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.SequenceInputStream;\n\npublic class SequenceInputStreamTest {\n   public static void main(String[] args) {\n      InputStream is1 = null;\n      InputStream is2 = null;\n      SequenceInputStream sequenceInputStream = null;\n      try {\n         is1 = new FileInputStream(\"D:\\\\data1.txt\");\n         is2 = new FileInputStream(\"D:\\\\data2.txt\");\n         sequenceInputStream = new SequenceInputStream(is1, is2);\n         int readByte = -1;\n         while ((readByte = sequenceInputStream.read()) != -1) {\n            System.out.print((char) readByte);\n         }\n      } catch (IOException e) {\n         e.printStackTrace();\n      } finally {\n          //此处省略关闭所有的Stream的代码\n      }\n   }\n}\n</code></pre>\n<p>程序运行结果，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h5 id=\"12sequenceinputstream的readbyte-b-int-off-int-len函数和nextstream函数\">1.2、SequenceInputStream的read(byte b[], int off, int len)函数和nextStream()函数</h5>\n<pre><code>package java.io;\nimport java.io.InputStream;\nimport java.util.Enumeration;\nimport java.util.Vector;\n\npublic\nclass SequenceInputStream extends InputStream {\n    ...省略部分代码...\n    //顺序（序列化）装载多个被装饰输入Stream的集合，一般是Vector实例\n    Enumeration&lt;? extends InputStream&gt; e;\n    InputStream in;//顺序（序列化）装载多个被装饰输入Stream的集合中当前正在被SequenceInputStream 对象使用的被装饰的输入Stream\n    //获取集合中下一个被装饰的输入Stream\n    final void nextStream() throws IOException {\n        if (in != null) {\n            in.close();//先关闭当前被装饰的输入Stream\n        }\n\n        if (e.hasMoreElements()) {//如果集合中还有被装饰的输入Stream\n            in = (InputStream) e.nextElement();//获取集合中下一个被装饰的输入Stream\n            if (in == null)\n                throw new NullPointerException();//如果集合中下一个被装饰的输入Stream为null，抛出一个NullPointerException\n        }\n        else in = null;//如果集合中没有了被装饰的输入Stream，将当前正在使用的被装饰的输入Stream置为null\n\n    }\n    \n    //从SequenceInputStream 对象的集合（该集合放着多个被装饰的输入Stream）中读取len个字节，放入到byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置\n    public int read(byte b[], int off, int len) throws IOException {\n        if (in == null) {//如果in==null，则说明当前这个SequenceInputStream 对象的集合中所有被装饰的输入Stream都已经关闭\n            return -1;\n        } else if (b == null) {\n            throw new NullPointerException();//如果byte[]数组b==null，抛出一个NullPointerException\n        } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {//相当于off + len &gt; b.length（源码中这样写代码的好处我没看出来）\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;//要从SequenceInputStream 对象的集合（该集合放着至少2个被装饰的输入Stream）中读取的len个字节==0时，返回0\n        }\n        do {\n            int n = in.read(b, off, len);//从当前正在使用的被装饰的输入Stream中读取len个字节，放入到byte[]数组b的[off,off+len)（左闭右开，不包括off+len）索引位置\n            if (n &gt; 0) {\n                return n;//只要能从当前正在使用的被装饰的输入Stream中读取到字节，则返回读取的数量\n            }\n            nextStream();//此时n==-1，说明当前正在使用的被装饰的输入Stream中字节（byte）数据已经读完，获取SequenceInputStream 对象的集合中下一个被装饰的输入Stream\n        } while (in != null);//SequenceInputStream 对象的集合中下一个被装饰的输入Stream为null时，跳出循环，返回-1\n        return -1;\n    }\n    ...省略部分代码...\n}\n</code></pre>\n<p>如果使用者用的是2个被装饰的输入Stream（此处为FileInputStream），构造的SequenceInputStream的对象，如下所示（伪代码）：</p>\n<pre><code>is1 = new FileInputStream(\"D:\\\\data1.txt\");\nis2 = new FileInputStream(\"D:\\\\data2.txt\");\nsequenceInputStream = new SequenceInputStream(is1, is2);\n</code></pre>\n<p>那么，SequenceInputStream对象中Vector集合的容量是2，并且假设这2个被装饰的输入Stream（此处为FileInputStream）中的字节数据如下：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>如果此时执行SequenceInputStream.class::read()函数。接下来使用SequenceInputStream对象读取字节数据到使用者创建的byte[]数组，如果使用者创建的字节数组byte[]的长度&gt;=第1个被装饰的输入Stream中的所有字节个数，比如，使用者创建的byte[]数组的长度为12，如下所示（伪代码）：</p>\n<pre><code>int readByte = -1;\nbyte[] buff = new byte[12];\nwhile ((readByte = sequenceInputStream.read(buff, 0, buff.length)) != -1) {\n   for (int i = 0; i &lt; readByte; i++) {\n      System.out.print((char) buff[i]);\n   }\n}\n</code></pre>\n<p>整个执行过程如下：<br />\n①、第1次进入read()函数<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>②、第2次进入read()函数（<em><strong>重点是当前正在使用的被装饰的输入Stream中的字节数据已经读取完了时，再次读取，会返回-1，不会返回0</strong></em>）<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>③、第3次进入read()函数<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>④、第4次进入read()函数（<em><strong>重点是当前正在使用的被装饰的输入Stream中的字节数据已经读取完了时，再次读取，会返回-1，不会返回0</strong></em>）<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<p>最终使用者创建的byte[]数组中的字节（byte）数据，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h6 id=\"121使用举例\">1.2.1、使用举例</h6>\n<p>  下面这个例子就恰当的使用SequenceInputStream的read()函数；</p>\n<ul>\n<li>\n<p>我的windows操作系统的D盘根目录下有2个txt文件，一个是data1.txt，另一个是data2.txt文件，这2个文件中总共有30个字节，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /><br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n</li>\n<li>\n<p>使用者可以用一个SequenceInputStream对象装饰2个被装饰的输入Stream（此处为FileInputStream），如下代码所示：</p>\n</li>\n</ul>\n<pre><code>package com.chelong.StreamAndReader;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.SequenceInputStream;\nimport java.util.Vector;\n\npublic class SequenceInputStreamTest {\n   public static void main(String[] args) {\n      InputStream is1 = null;\n      InputStream is2 = null;\n      SequenceInputStream sequenceInputStream = null;\n      try {\n         is1 = new FileInputStream(\"D:\\\\data1.txt\");\n         is2 = new FileInputStream(\"D:\\\\data2.txt\");\n         Vector&lt;InputStream&gt; vector = new Vector&lt;InputStream&gt;();\n         vector.addElement(is1);\n         vector.addElement(is2);\n         sequenceInputStream = new SequenceInputStream(vector.elements());\n         int readByte = -1;\n         byte[] buff = new byte[12];\n         while ((readByte = sequenceInputStream.read(buff, 0, buff.length)) != -1) {\n            for (int i = 0; i &lt; readByte; i++) {\n               System.out.print((char) buff[i]);\n            }\n         }\n         System.out.println();\n         System.out.println(\"最终留在byte[]数组buff中的字节：\");\n         for (byte b : buff) {\n            System.out.print((char) b);\n         }\n      } catch (IOException e) {\n         e.printStackTrace();\n      } finally {\n         try {\n            if (is1 != null) is1.close();\n            if (is2 != null) is1.close();\n            if (sequenceInputStream != null) sequenceInputStream.close();\n         } catch (IOException e) {\n            e.printStackTrace();\n         }\n      }\n   }\n}\n</code></pre>\n<p>程序运行结果，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h4 id=\"二vectorclass的一些函数说明\">二、Vector.class的一些函数说明</h4>\n<p>  Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList慢。Vector的UML图，如下所示：<br />\n<img alt=\"clipboard\" class=\"lazyload\" /></p>\n<h5 id=\"21构造函数\">2.1、构造函数</h5>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">函数名</th>\n<th style=\"text-align: left;\">函数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">public Vector()</td>\n<td style=\"text-align: left;\">此构造函数创建的Vector中，Object[]数组的初始长度为10，capacityIncrement=0（capacityIncrement表示扩容时Object[]数组增加的长度，如果等于0的话，当Object[]数组需要扩容时，新的数组长度=2*旧数组的长度，但是新的数组长度最大为2^31-8）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">public Vector(int initialCapacity)</td>\n<td style=\"text-align: left;\">此构造函数创建的Vector中，Object[]数组的初始长度为initialCapacity，capacityIncrement=0（capacityIncrement表示扩容时Object[]数组增加的长度，如果等于0的话，当Object[]数组需要扩容时，新的数组长度=2*旧数组的长度，但是新的数组长度最大为2^31-8）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">public Vector(int initialCapacity, int capacityIncrement)</td>\n<td style=\"text-align: left;\">此构造函数创建的Vector中，Object[]数组的初始长度为initialCapacity，capacityIncrement=capacityIncrement（capacityIncrement表示扩容时Object[]数组增加的长度，如果等于0的话，当Object[]数组需要扩容时，新的数组长度=2*旧数组的长度，但是新的数组长度最大为2^31-8）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">public Vector(Collection&lt;? extends E&gt; c)</td>\n<td style=\"text-align: left;\">此构造函数创建的Vector中，Object[]数组的初始长度为传入集合Collection&lt;? extends E&gt; c的长度，capacityIncrement=0（capacityIncrement表示扩容时Object[]数组增加的长度，如果等于0的话，当Object[]数组需要扩容时，新的数组长度=2*旧数组的长度，但是新的数组长度最大为2^31-8）</td>\n</tr>\n</tbody>\n</table>\n<p>2.2、常用函数</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">函数名</th>\n<th style=\"text-align: left;\">函数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">boolean add(E o)</td>\n<td style=\"text-align: left;\">此函数将指定的元素追加到此Vector的末尾，该函数与addElement()函数的区别是，该()函数是List.interface接口规定的函数，addElement()函数是Vector自己实现的（接口中没有规定addElement()函数）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void add(int index, E element)</td>\n<td style=\"text-align: left;\">此函数将指定的元素插入此Vector中的指定索引位置</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean addAll(Collection&lt;? extends E&gt; c)</td>\n<td style=\"text-align: left;\">此函数将指定Collection中的所有元素追加到此Vector的末尾</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean addAll(int index, Collection&lt;? extends E&gt; c)</td>\n<td style=\"text-align: left;\">此函数将指定Collection中的所有元素插入到此Vector中的指定索引位置</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void addElement(E obj)</td>\n<td style=\"text-align: left;\">此函数将指定的元素追加到此Vector的末尾，这个函数与add()函数的区别是，add()函数是List.interface接口规定的函数，这个函数是Vector自己实现的（接口中没有规定该函数）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int capacity()</td>\n<td style=\"text-align: left;\">此函数返回此Vector的当前容量</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void clear()</td>\n<td style=\"text-align: left;\">此函数从此Vector中删除所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Object clone()</td>\n<td style=\"text-align: left;\">此函数返回此Vector的克隆对象</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean contains(Object elem)</td>\n<td style=\"text-align: left;\">如果此Vector包含指定的元素，则此函数返回true</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean containsAll(Collection&lt;?&gt; c)</td>\n<td style=\"text-align: left;\">如果此Vector包含指定Collection中的所有元素，则此函数返回true</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void copyInto(Object[] anArray)</td>\n<td style=\"text-align: left;\">此方法将此向量的组件复制到指定的数组中</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E elementAt(int index)</td>\n<td style=\"text-align: left;\">此函数返回Vector指定索引处的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Enumeration elements()</td>\n<td style=\"text-align: left;\">此函数返回此Vector中所包含的所有元素的枚举。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void ensureCapacity(int minCapacity)</td>\n<td style=\"text-align: left;\">此函数可增加此Vector的容量，以确保它至少可以保存最小容量元素个数</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean equals(Object o)</td>\n<td style=\"text-align: left;\">此函数将指定的Object与此Vector进行比较以获得相等性</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E firstElement()</td>\n<td style=\"text-align: left;\">返回此Vector的第一个元素（位于Object[]数组索引 0 处的元素）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E get(int index)</td>\n<td style=\"text-align: left;\">返回Vector中指定索引位置的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int indexOf(Object elem)</td>\n<td style=\"text-align: left;\">搜索给定参数的第一个匹配项，使用 equals ()函数测试相等性</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int indexOf(Object elem, int index)</td>\n<td style=\"text-align: left;\">搜索给定参数的第一个匹配项，从 index 处开始搜索，并使用 equals()函数测试其相等性</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void insertElementAt(E obj, int index)</td>\n<td style=\"text-align: left;\">将指定对象作为此Vector中的元素插入到指定的 索引位置</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean isEmpty()</td>\n<td style=\"text-align: left;\">测试此Vector中的是否不包含任何元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E lastElement()</td>\n<td style=\"text-align: left;\">返回此Vector的最后一个元素（位于Object[]数组索引 Object[].length-1 处的元素）</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int lastIndexOf(Object elem)</td>\n<td style=\"text-align: left;\">返回指定的对象在此Vector中最后一个匹配项的索引</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int lastIndexOf(Object elem, int index)</td>\n<td style=\"text-align: left;\">从指定的索引处开始向后搜索指定的对象，并返回搜索到的最后一个索引</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E remove(int index)</td>\n<td style=\"text-align: left;\">移除此Vector中指定索引位置的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean remove(Object o)</td>\n<td style=\"text-align: left;\">移除此Vector中指定元素的第一个匹配项，如果此Vector不包含该元素，则所有元素保持不变，并返回false</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean removeAll(Collection&lt;?&gt; c)</td>\n<td style=\"text-align: left;\">从此Vector中移除包含在指定 Collection 中的所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void removeAllElements()</td>\n<td style=\"text-align: left;\">从此Vector中移除全部元素，并设置elementCount=0（该变量表示此Vector对象中有效元素的数量），Object[]数组的长度不变。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void removeElementAt(int index)</td>\n<td style=\"text-align: left;\">删除指定索引处的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">protected void removeRange(int fromIndex, int toIndex)</td>\n<td style=\"text-align: left;\">从此 Vector 中移除索引位于 [fromIndex, toIndex)（左闭右开）之间的所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">boolean retainAll(Collection&lt;?&gt; c)</td>\n<td style=\"text-align: left;\">如果此Vector中包含指定 Collection 中的所有元素，此函数返回true</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">E set(int index, E element)</td>\n<td style=\"text-align: left;\">用指定的元素替换此Vector中指定索引处的元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void setElementAt(E obj, int index)</td>\n<td style=\"text-align: left;\">将此Vector指定 索引处的元素设置为指定的另一个元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">void setSize(int newSize)</td>\n<td style=\"text-align: left;\">设置此Vector的大小</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">int size()</td>\n<td style=\"text-align: left;\">返回此Vector中的元素数</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">List subList(int fromIndex, int toIndex)</td>\n<td style=\"text-align: left;\">返回此 Vector的子集，该子集的元素范围为 [fromIndex, toIndex)（左闭右开）索引位置的所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Object[] toArray()</td>\n<td style=\"text-align: left;\">返回一个Object[]数组，包含此Vector中以正确顺序存放的所有元素</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">String toString()</td>\n<td style=\"text-align: left;\">返回此Vector的字符串表示形式，其中包含每个元素的 String 表示形式</td>\n</tr>\n</tbody>\n</table>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 22:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Carey-ccl\">Carey_ccl</a>&nbsp;\n阅读(<span id=\"post_view_count\">18</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "C# .NET 周刊｜2026年1月3期",
      "link": "https://www.cnblogs.com/InCerry/p/-/dotnet_week_26_1_3",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/InCerry/p/-/dotnet_week_26_1_3\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 20:36\">\n    <span>C# .NET 周刊｜2026年1月3期</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"国内文章\">国内文章</h2>\n<h3 id=\"不服跑个分net-10-大整数计算对阵-java结果令人意外\">不服跑个分？.NET 10 大整数计算对阵 Java，结果令人意外</h3>\n<p><a href=\"https://www.cnblogs.com/sdcb/p/19484525/20261113-big-integer-dotnet-10-vs-java\" target=\"_blank\">https://www.cnblogs.com/sdcb/p/19484525/20261113-big-integer-dotnet-10-vs-java</a></p>\n<p>本文通过对比.NET 的 System.Numerics.BigInteger 和 Java 的 java.math.BigInteger，从性能角度深入分析大数运算的速度。作者探讨了在高精度计算和密码学场景下，两者的表现差异。实验涵盖了加法、乘法和模幂的运算，使用相同开发环境，并严格控制测试变量。文章指出.NET 的 BigInteger 在不可变特性下的公平性，探讨了其性能表现的原因，并附带代码示例。整体内容深入且富有思考，对开发者有实用价值。</p>\n<h3 id=\"一个高性能的-net-mqtt-客户端与服务器库\">一个高性能的 .NET MQTT 客户端与服务器库</h3>\n<p><a href=\"https://www.cnblogs.com/dotnet-org-cn/p/19473369\" target=\"_blank\">https://www.cnblogs.com/dotnet-org-cn/p/19473369</a></p>\n<p>这篇文章介绍了一个高性能的 MQTT 库，完全用 C#实现。它支持 MQTT 3.1.1 和 MQTT 5.0 协议，具备 Broker 桥接和集群功能。库的核心特性包括高性能异步实现、内存管理先进技术和支持 10,000+ 并发连接。文章深入探讨了内存管理技术如 Span、Memory等，以减少内存压力，并使用 async/await 优化 I/O 操作。适配.NET 6.0、8.0 和 10.0 版本，具有极佳的性能和实用性。文中还强调了库的灵活性与企业级特性，是物联网领域的重要工具。</p>\n<h3 id=\"2025-总结篇忙碌的日子里越过-35-岁开启下一个征程\">2025 总结篇，忙碌的日子里越过 35 岁，开启下一个征程</h3>\n<p><a href=\"https://www.cnblogs.com/SunSpring/p/19469874\" target=\"_blank\">https://www.cnblogs.com/SunSpring/p/19469874</a></p>\n<p>文章讲述了作者在 2024 年工作中的转变与挑战。由于部门重组，作者成为技术负责人，面临管理和开发双重任务。重新学习.NET 5+，并在 Java 系统中进行重构，实施微服务架构，使用 Spring Cloud 和 Nacos 等技术，解决系统复杂性与维护问题。实施项目管理工具提升团队效率，经过一年的努力，成功上线新系统并持续优化。作者从中获得了丰富的技术经验和管理心得，对过去经验有了新的认知。</p>\n<h3 id=\"让-winformnet-再次伟大一个专门设计用于帮助-winforms-应用程序迁移到-blazor-wasm-平台的项目\">让 WinForm.NET 再次伟大！一个专门设计用于帮助 WinForms 应用程序迁移到 Blazor WASM 平台的项目</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19470057\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19470057</a></p>\n<p>本文讨论了 MWGA 项目，该项目旨在帮助传统 WinForms 应用程序有效迁移至 Blazor WebAssembly(WASM)平台。结合 Blazor 的跨平台特性，MWGA 能够将使用 GDI+ 的应用程序修改量控制在 10% 以内，降低了现代化成本与风险。文章介绍了 WinForms 的背景和实际应用场景，说明了云集成和跨平台访问的需求。作者分享了演示项目的效果，并确认通过 MWGA 迁移后的代码在不同环境下运行逻辑一致。这一项目为企业现代化转型带来了希望，尽管仍需完善。</p>\n<h3 id=\"dbshadow-横空出世dappernet-的天花板盖不住了\">DBShadow 横空出世,Dapper.net 的天花板盖不住了</h3>\n<p><a href=\"https://www.cnblogs.com/xiangji/p/19485861\" target=\"_blank\">https://www.cnblogs.com/xiangji/p/19485861</a></p>\n<p>DBShadow 是一个高性能的.NET 开源 ORM，利用 ShadowSql 和 PocoEmit.Mapper 高效处理 SQL 拼接和映射。与 Dapper 对比，DBShadow 在速度和内存占用上表现更佳。在.NET 8 环境下，DBShadow 比 Dapper 快 10%，并且支持.NET 10，而 Dapper 不支持。使用 BenchmarkDotNet 进行的对比显示，DBShadow 在多种数据库(如 SQLite 和 MySQL)上均优于 Dapper。此文章详细介绍了两者代码实现和性能比较，为开发者提供了实用的参考和数据支持。</p>\n<h3 id=\"原创c开源一分钟使用-picoserver-打造日志服务器\">(原创)[C#]【开源】一分钟使用 PicoServer 打造日志服务器</h3>\n<p><a href=\"https://www.cnblogs.com/lesliexin/p/19475073\" target=\"_blank\">https://www.cnblogs.com/lesliexin/p/19475073</a></p>\n<p>本文介绍了 PicoServer 的使用，适合快速开发 WebAPI 原型。读者可以通过开源项目学习如何搭建日志服务器。文章简洁明了，提供了操作步骤，包括引用 NuGet 包、设计界面和使用说明。PicoServer 简单易用，且体积小，适合特定业务需求。作者强调其轻量级特性，相比 Asp.Net Core 更为便利。适合希望快速实现接口的开发者。</p>\n<h3 id=\"总结归纳net-10-中-minimal-apis-主要应用场景\">总结归纳.NET 10 中 Minimal APIs 主要应用场景</h3>\n<p><a href=\"https://www.cnblogs.com/tianqing/p/19467531\" target=\"_blank\">https://www.cnblogs.com/tianqing/p/19467531</a></p>\n<p>本文探讨了.NET 10 中的 Minimal APIs，主要应用场景包括高并发读接口、业务能力型 API 和平台级 API 模块化。Minimal APIs 在.NET 6 至 8 中实现了基础功能，并在.NET 9 至 10 中进一步强化，可维护性、可治理性、可扩展性和可工程化性显著提升。其中，Typed Results 消除了返回的模糊性，提高了 OpenAPI 文档的精确度。它还优化了中间件组合能力以及与依赖注入、验证和授权的整合，使得 API 的分层和模块化成为可能，推动企业级 API 的有效构建。</p>\n<h3 id=\"跨越技术鸿沟aspire-赋能-javascript-与-nodejs-开发者的深度生态融合\">跨越技术鸿沟：Aspire 赋能 JavaScript 与 Node.js 开发者的深度生态融合</h3>\n<p><a href=\"https://www.cnblogs.com/shanyou/p/19474912\" target=\"_blank\">https://www.cnblogs.com/shanyou/p/19474912</a></p>\n<p>本文探讨.NET Aspire 13.0 如何支持 JavaScript 与 Node.js 开发者，通过标准化基础设施解决传统开发中的摩擦。Aspire 引入代码化编排、全链路可观测性及标准化服务发现，简化前后端与微服务的整合。开发者不再需手动处理复杂配置与依赖关系，减少认知负担与操作复杂性。此文详细介绍了现代化 AddJavaScriptApp 的架构演进，并对生产部署与云原生对接提出建议，强调 Aspire 对于多语言生态的价值。整体提升了跨技术栈的开发效率。</p>\n<h3 id=\"wpf-使用-hlsl--clip-实现高亮歌词光照效果\">WPF 使用 HLSL + Clip 实现高亮歌词光照效果</h3>\n<p><a href=\"https://www.cnblogs.com/TwilightLemon/p/19497125\" target=\"_blank\">https://www.cnblogs.com/TwilightLemon/p/19497125</a></p>\n<p>本文讨论了使用 HLSL 编写文本高亮着色器，以增强歌词显示效果。作者受到 WPF 阳光效果的启发，探索了几种高亮实现方法，最终采用将着色器封装为用户控件的方案。文章介绍了可能遇到的问题，例如文本像素化和性能低下。此外，提供了高亮颜色自定义、宽度调整和模式切换的功能。作者展示了完整的 HLSL 代码及其参数作用，说明了光照强度与文本颜色的混合计算过程。这种方法显著提升了文本的光感效果。</p>\n<h3 id=\"并发并行与异步\">并发，并行与异步</h3>\n<p><a href=\"https://www.cnblogs.com/kklldog/p/19474533\" target=\"_blank\">https://www.cnblogs.com/kklldog/p/19474533</a></p>\n<p>本文深入剖析了并发、并行和异步三个核心概念，澄清了它们之间的区别。并发是一种处理多个任务的能力，强调任务的交替执行。并行则是真正意义上同一时间执行多个任务，依赖多核 CPU。异步是一种非阻塞的编程模型，主要用于 I/O 操作，避免浪费线程资源。文章通过实际例子和理论支持，使读者清楚理解这三者的定义和应用，指出异步并不等同于并发，同时强调了性能优化的重要性。整体内容结构清晰，便于读者理解。</p>\n<h3 id=\"pythoncsharpgonextjs不同框架的性能到底差多少\">Python、CSharp、Go、Nextjs，不同框架的性能到底差多少？</h3>\n<p><a href=\"https://www.cnblogs.com/deali/p/19498429\" target=\"_blank\">https://www.cnblogs.com/deali/p/19498429</a></p>\n<p>本文对不同框架和语言的性能进行了对比测试，特别关注了 ASP.NET Core 8.0 和 9.0 的性能表现。测试发现，ASP.NET Core 9.0 在吞吐量和内存使用方面表现卓越，适合高性能微服务。Go + Gin 虽然轻量，但吞吐量表现一般，适合小型服务。Next.js 在高并发场景下表现不佳。总体来看，ASP.NET Core 9.0 是未来项目的最佳选择，而传统 MVC 架构则显得过于臃肿，未来不推荐使用。</p>\n<h3 id=\"告别屎山代码gearnet专为-net-工业自动化打造的微编排框架\">告别“屎山”代码！Gear.NET：专为 .NET 工业自动化打造的微编排框架</h3>\n<p><a href=\"https://www.cnblogs.com/egreen/p/19498375\" target=\"_blank\">https://www.cnblogs.com/egreen/p/19498375</a></p>\n<p>Gear.NET 是一个专为 .NET 工业自动化设计的微编排框架，旨在解决工业软件开发中的痛点，如逻辑复杂、硬件耦合、数据丢失等问题。它采用洋葱架构，提供 MicroWorkflow 微流程引擎，支持优雅的流程编排和异步操作。此外，UniversalScpi 配置驱动解决了硬件更换时的代码重构问题，通过 JSON 配置驱动不同的标准 SCPI 仪器。相比以往，Gear.NET 提供了深度封装的 SqlSugar 存储解决方案，确保数据的安全性与可分析性，极大地提高了兼容性和可维护性，适合工业软件需求。整体上，Gear.NET 旨在简化开发过程、提高代码质量。</p>\n<h3 id=\"c实现包裹扣面单的几种方式\">c#实现包裹扣面单的几种方式</h3>\n<p><a href=\"https://www.cnblogs.com/axing/p/19483856\" target=\"_blank\">https://www.cnblogs.com/axing/p/19483856</a></p>\n<p>本文探讨了包裹流转过程中面单扣取的实现方案，包括使用 OpenCVSharp 进行轮廓、颜色和边缘检测，及 OCR 识别面单内容。文章重点介绍了 OpenCVSharp 在包裹和面单色差明显情况下的有效性，尽管在色差不明显时效果较差。提供了核心代码，展示了检测与处理过程，包括检测耗时和面单区域的信息。文中提到使用 YOLO 和 Labelme 可以训练模型以定位面单，为未来探讨做好铺垫。</p>\n<h3 id=\"cnetnet-core-技术前沿周刊--第-65-期2026-年-11-111\">C#/.NET/.NET Core 技术前沿周刊 | 第 65 期(2026 年 1.1-1.11)</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19479370\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19479370</a></p>\n<p>本文介绍了 C#/.NET/.NET Core 技术前沿的最新动态和实用资源。报道了 C#在 2025 年的 TIOBE 编程语言排名中再次获评、生成式人工智能的崛起及其与 C#的结合、以及 MongoDB EF Core 的可查询加密特性。此外，还推广了优质项目和迁移 WinForms 到 Blazor 的 MWGA 项目。这些内容为开发者提供了有价值的信息与资源，有助于他们掌握技术前沿动态。</p>\n<h3 id=\"译ai-是如何解决我的拖延症的\">【译】AI 是如何解决我的拖延症的</h3>\n<p><a href=\"https://www.cnblogs.com/MeteorSeed/p/19482001\" target=\"_blank\">https://www.cnblogs.com/MeteorSeed/p/19482001</a></p>\n<p>作者分享了使用 Visual Studio 和 Copilot 完成两个项目的经历，强调了克服拖延和高效开发的重要性。第一个项目是将其书籍《The Automated Home》转换为静态网站，虽然需要微调设计，但效率显著提高。第二个项目是开发一个简易编程语言 TOON 的解析器，利用 Copilot 和云智能体协助解决复杂的语法分析问题。作者鼓励读者利用闲暇时间启动拖延已久的项目。</p>\n<h3 id=\"开源自荐为-ai-短视频打造一个分镜管理平台\">【开源自荐】为 AI 短视频打造一个分镜管理平台</h3>\n<p><a href=\"https://www.cnblogs.com/Z7TS/p/19483978\" target=\"_blank\">https://www.cnblogs.com/Z7TS/p/19483978</a></p>\n<p>这篇文章讲述了作者在 2022 至 2026 年间，如何利用 AI 技术开发本地客户端项目 Storyboard，旨在为短视频创作者提供镜头管理功能。作者分享了开发过程中的感受，包括使用的工具和技术栈，遇到的管理混乱问题，以及通过 AI 提升视频制作效率的体验。文章描述了项目需求的整理和核心功能的实现，涵盖了视频导入、分镜生成、批量任务处理等功能，展现了 AI 在短视频领域的应用潜力。</p>\n<h3 id=\"如何一步步将-aspnet-mvc-升级为net\">如何一步步将 ASP.NET MVC 升级为.NET</h3>\n<p><a href=\"https://www.cnblogs.com/powertoolsteam/p/19486260\" target=\"_blank\">https://www.cnblogs.com/powertoolsteam/p/19486260</a></p>\n<p>将 ASP.NET MVC 应用从.NET Framework 迁移到现代.NET 需要考虑多个方面。该过程并非简单的版本提升，需关注多个架构和配置的变化。文中提供了实用的逐步策略，包括根据应用大小选择迁移路径、识别阻碍因素、建立安全基线、优先升级库及考虑迁移工具等步骤。这些步骤旨在帮助开发者有效降低风险，确保迁移顺利进行。文中还强调了 Microsoft 提供的工具和指导，以便进行兼容性检查和补救措施。此文适合有实际开发经验的开发者参考。</p>\n<h3 id=\"c-14-中的新增功能\">C# 14 中的新增功能</h3>\n<p><a href=\"https://www.cnblogs.com/net-kevin-li/p/19476883\" target=\"_blank\">https://www.cnblogs.com/net-kevin-li/p/19476883</a></p>\n<p>C# 14 引入重要更新，包括扩展成员、空条件赋值、支持未绑定泛型的 nameof、Span隐式转换、简单 lambda 参数修饰符、字段支持属性、partial 事件与构造函数、用户定义复合赋值运算符和基于文件的预处理器指令。开发环境要求.NET 10 SDK 或 Visual Studio 2026。某些功能需要开启编译器开关以启用。性能优化方面，Span隐式转换减少内存拷贝，适用于高性能场景。</p>\n<h3 id=\"wpf-新手村教程二---铁匠铺攻略如何给隔壁张铁匠带两块铁依赖属性\">WPF 新手村教程(二) - 铁匠铺攻略：如何给隔壁张铁匠带两块铁(依赖属性)</h3>\n<p><a href=\"https://www.cnblogs.com/leaf-7-scouts/p/19475414\" target=\"_blank\">https://www.cnblogs.com/leaf-7-scouts/p/19475414</a></p>\n<p>本文章探讨 WPF 中的依赖属性和附加属性。依赖属性是由 WPF 属性系统统一管理的，值由多种输入源计算得出。文章通过 C#普通属性与 WPF 依赖属性的对比，阐述了依赖属性的定义和实现方式。介绍了依赖属性标识符的重要性及其在 WPF 属性系统中的应用。通过示例代码，展示了如何定义和使用依赖属性，增强了对属性体系的理解。整体内容清晰，技术深度适中，具备实用价值。</p>\n<h3 id=\"netcorekevin-是一个基于net9-ai-时代的-saas-企业级-ai-架构专注于-ai-智能体开发与集成agentframework-和知识库为企业提供高效的-ai-应用开发框架\">NetCoreKevin 是一个基于.NET9 AI 时代的 SaaS 企业级 AI 架构，专注于 AI 智能体开发与集成,AgentFramework 和知识库，为企业提供高效的 AI 应用开发框架。</h3>\n<p><a href=\"https://www.cnblogs.com/net-kevin-li/p/19493371\" target=\"_blank\">https://www.cnblogs.com/net-kevin-li/p/19493371</a></p>\n<p>NetCoreKevin 是基于 .NET 的现代化 SaaS 企业级架构，专注 AI 智能体开发与集成。采用前后端分离设计，支持 AI 语义内核和 RAG 检索增强生成，提供高效的应用开发框架。核心组件包括模块化智能体框架、动态知识库与容器化部署。后端使用 .NET Core 9、Entity Framework Core，前端采用 Vue3。支持 Docker 和 Kubernetes，实现云原生架构，满足高并发需求。该架构降低企业 AI 实施门槛，助力智能化转型。</p>\n<h3 id=\"如何通过-c-将-ppt-文档转换为-pdf-格式\">如何通过 C# 将 PPT 文档转换为 PDF 格式</h3>\n<p><a href=\"https://www.cnblogs.com/jazz-z/p/19486170\" target=\"_blank\">https://www.cnblogs.com/jazz-z/p/19486170</a></p>\n<p>本文介绍如何使用 .NET 组件 Spire.Presentation 将 PowerPoint 文件转换为 PDF。首先，用户需通过 NuGet 安装该库。示例代码展示如何处理单个和批量 PPT 转 PDF 的流程，包括文件路径的定义、加载 PPT 文档、执行转换和资源释放等步骤。文章强调了异常处理的重要性，确保用户在遇到错误时能够清楚地获取反馈。该技术在开发和办公场景中具有很高的实用价值。</p>\n<h3 id=\"译使用-visual-studio-2026-简化您的-git-工作流程\">【译】使用 Visual Studio 2026 简化您的 Git 工作流程</h3>\n<p><a href=\"https://www.cnblogs.com/MeteorSeed/p/19460575\" target=\"_blank\">https://www.cnblogs.com/MeteorSeed/p/19460575</a></p>\n<p>本文讲述了 .NET 开发者如何使用 Visual Studio 和 Git 工具高效处理日常任务。通过具体示例，作者展示了如何创建分支、暂存未完成的变更并同步，保持代码库整洁。Visual Studio 的功能优化简化了分支切换和代码审查过程，提升了工作效率。文中还提到 Copilot 的代码审查功能，如何帮助开发者检测问题并获得建议，确保提交的安全性和质量。最后，作者介绍了创建拉取请求的简易流程，强调了团队协作的重要性。</p>\n<h3 id=\"基于net-和-c构建光伏-iot-物模型方案\">基于.NET 和 C#构建光伏 IoT 物模型方案</h3>\n<p><a href=\"https://www.cnblogs.com/tianqing/p/19490649\" target=\"_blank\">https://www.cnblogs.com/tianqing/p/19490649</a></p>\n<p>文章详细描述了国内光伏设备及华为逆变器的 Modbus TCP 通讯报文。它包括请求和响应的结构、数据解析及光伏设备物模型的组织。文章目标在于解耦协议、解析与物模型，方便后续多品牌适配器的配置化映射。提供了示例代码，展示 Modbus 请求报文构造和响应解析方法，具有较高的技术深度与实用性。内容清晰，结构合理，代码示例易于理解，具备创新性，并紧跟技术进展。引用情况适中，整体可读性良好。</p>\n<h3 id=\"net-aspire-概述\">.NET Aspire 概述</h3>\n<p><a href=\"https://www.cnblogs.com/powertoolsteam/p/19477015\" target=\"_blank\">https://www.cnblogs.com/powertoolsteam/p/19477015</a></p>\n<p>.NET Aspire 是微软在 Build 2024 推出的开源框架，旨在简化.NET 8 及以上版本的分布式云原生应用开发。它提供工具、模板和最佳实践，帮助开发者将重心从基础设施转向业务逻辑。Aspire 的核心功能包括 AppHost 中心编排、服务默认配置、快速设置模板及开发者仪表盘，支持灵活部署到多种容器平台。Aspire 通过抽象化基础设施，降低开发复杂性，提高开发效率，确保环境一致性并内置可观测性和弹性。</p>\n<h3 id=\"一款专为-winui-xaml-设计的快速原型设计工具生成的代码可轻松复制到-visual-studio-中\">一款专为 WinUI XAML 设计的快速原型设计工具，生成的代码可轻松复制到 Visual Studio 中！</h3>\n<p><a href=\"https://www.cnblogs.com/Can-daydayup/p/19494169\" target=\"_blank\">https://www.cnblogs.com/Can-daydayup/p/19494169</a></p>\n<p>XAML Studio 是专为 WinUI XAML 设计的快速原型工具，支持实时预览和互动，允许将生成的代码轻松复制到 Visual Studio。它提供界面调试、数据上下文编辑器和智能感知等功能，适合开发者学习和快速原型设计。WinUI 是一个现代 UI 框架，旨在构建动态和高性能的 Windows 应用。该项目为开源，开发者可以访问 GitHub 获取源代码，并关注 C#/.NET 的最佳实践。</p>\n<h3 id=\"基于-netcorepal-cloud-framework-的-ddd-架构管理系统实践\">基于 NetCorePal Cloud Framework 的 DDD 架构管理系统实践</h3>\n<p><a href=\"https://www.cnblogs.com/aishangyipiyema/p/19499381\" target=\"_blank\">https://www.cnblogs.com/aishangyipiyema/p/19499381</a></p>\n<p>本文介绍了基于 NetCorePal Cloud Framework 构建 DDD 架构的管理系统实践。项目采用了.NET 10 和 Vue 3，实现前后端分离。系统包含用户、角色、部门等基本功能，后端使用 EF Core 进行数据访问，FastEndpoints 替代传统 Controller，并通过 MediatR 实现 CQRS 模式，存储支持 MySQL 等数据库，集成 RabbitMQ、Redis 及云原生基础设施管理。项目采用经典三层架构，强调领域驱动设计(DDD)，确保领域层与基础设施层和表现层之间的单向依赖。文章提供了清晰的架构和技术选型参考，适合相关领域开发者学习。</p>\n<h2 id=\"话题\">话题</h2>\n<h3 id=\"net-和-net-framework-2026-年-1-月服务发布更新---net-博客\">.NET 和 .NET Framework 2026 年 1 月服务发布更新 - .NET 博客</h3>\n<p><a href=\"https://devblogs.microsoft.com/dotnet/dotnet-and-dotnet-framework-january-2026-servicing-updates/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/dotnet-and-dotnet-framework-january-2026-servicing-updates/</a></p>\n<p>关于 2026 年 1 月发布的.NET 和.NET Framework 服务。</p>\n<p>.NET 10、9 和 8 版本发布时，增加了非安全稳定性的改进和各种漏洞修复。 NET Framework。</p>\n<h3 id=\"aws-lambda-新增对-net-10---aws-的支持\">AWS Lambda 新增对 .NET 10 - AWS 的支持</h3>\n<p><a href=\"https://aws.amazon.com/jp/about-aws/whats-new/2026/01/aws-lambda-dot-net-10/\" rel=\"noopener nofollow\" target=\"_blank\">https://aws.amazon.com/jp/about-aws/whats-new/2026/01/aws-lambda-dot-net-10/</a></p>\n<p>AWS Lambda 现已支持 .NET 10。</p>\n<p>.NET 10 文件类应用、Lambda 管理实例以及 AWS Lambda 的 Powertools 也被支持以配合 .NET 10。 NET 10 运行时在所有地区均可用。</p>\n<h3 id=\"我们如何同步-net-的虚拟单点---net-博客\">我们如何同步。 NET 的虚拟单点 - .NET 博客</h3>\n<p><a href=\"https://devblogs.microsoft.com/dotnet/how-we-synchronize-dotnets-virtual-monorepo/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/how-we-synchronize-dotnets-virtual-monorepo/</a></p>\n<p>如何同步一个.NET 虚拟单仓库(<a href=\"https://github.com/dotnet/dotnet\" rel=\"noopener nofollow\" target=\"_blank\">dotnet/dotnet</a>))。</p>\n<p>在作一个将多个仓库(如 dotnet/runtime 和 dotnet/aspnetcore)视为构建源的仓库(VMR)时，本书详细解释了仓库间的同步问题及其解决方法。</p>\n<h2 id=\"发布\">发布</h2>\n<ul>\n<li><a href=\"https://github.com/AvaloniaUI/Avalonia\" rel=\"noopener nofollow\" target=\"_blank\">AvaloniaUI/Avalonia</a>\n<ul>\n<li><a href=\"https://github.com/AvaloniaUI/Avalonia/releases/tag/11.3.11%20%E5%B9%B4\" rel=\"noopener nofollow\" target=\"_blank\">2011 年 3 月 11 日</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/aws/aws-sdk-net\" rel=\"noopener nofollow\" target=\"_blank\">aws/aws-sdk-net</a>\n<ul>\n<li><a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1199.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1199.0</a>，<a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1200.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1200.0</a>，<a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1201.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1201。 0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1202.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1202.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/3.7.1203.0\" rel=\"noopener nofollow\" target=\"_blank\">3.7.1203. 0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.167.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.167.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.168.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.168.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.169.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.169.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.170.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.170.0</a>， <a href=\"https://github.com/aws/aws-sdk-net/releases/tag/4.0.171.0\" rel=\"noopener nofollow\" target=\"_blank\">4.0.171.0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/Azure/azure-sdk-for-net\" rel=\"noopener nofollow\" target=\"_blank\">Azure/azure-sdk-for-net</a>\n<ul>\n<li><a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Blobs_12.27.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Blobs_12.27.0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Blobs.Batch_12.24.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Blobs.Batch_12.24。 0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Common_12.26.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Common_12.26。 0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Files.DataLake_12.25.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Files.DataLake_12.25。 0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Files.Shares_12.25.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Files.Shares_12.25。 0</a>，<a href=\"https://github.com/Azure/azure-sdk-for-net/releases/tag/Azure.Storage.Queues_12.25.0\" rel=\"noopener nofollow\" target=\"_blank\">Azure.Storage.Queues_12.25。 0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/CommunityToolkit/Aspire\" rel=\"noopener nofollow\" target=\"_blank\">CommunityToolkit/Aspire</a>\n<ul>\n<li><a href=\"https://github.com/CommunityToolkit/Aspire/releases/tag/v13.1.0\" rel=\"noopener nofollow\" target=\"_blank\">v13.1.0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/DataDog/dd-trace-dotnet\" rel=\"noopener nofollow\" target=\"_blank\">DataDog/dd-trace-dotnet</a>\n<ul>\n<li><a href=\"https://github.com/DataDog/dd-trace-dotnet/releases/tag/v3.35.0\" rel=\"noopener nofollow\" target=\"_blank\">v3.35.0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/dotnet/maui\" rel=\"noopener nofollow\" target=\"_blank\">dotnet/maui</a>\n<ul>\n<li><a href=\"https://github.com/dotnet/maui/releases/tag/10.0.30\" rel=\"noopener nofollow\" target=\"_blank\">10.0.30</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/dotnet/orleans\" rel=\"noopener nofollow\" target=\"_blank\">dotnet/Orleans</a>\n<ul>\n<li><a href=\"https://github.com/dotnet/orleans/releases/tag/v3.8.0\" rel=\"noopener nofollow\" target=\"_blank\">v3.8.0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/dotnet/SqlClient\" rel=\"noopener nofollow\" target=\"_blank\">dotnet/SqlClient</a>\n<ul>\n<li><a href=\"https://github.com/dotnet/SqlClient/releases/tag/v5.1.9\" rel=\"noopener nofollow\" target=\"_blank\">v5.1.9</a>， <a href=\"https://github.com/dotnet/SqlClient/releases/tag/v6.1.4\" rel=\"noopener nofollow\" target=\"_blank\">v6.1.4</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/googleapis/google-cloud-dotnet\" rel=\"noopener nofollow\" target=\"_blank\">googleapis/google-cloud-dotnet</a>\n<ul>\n<li><a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.BackupDR.V1-2.7.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.BackupDR.V1-2.7.0</a>，<a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Compute.V1-3.22.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Compute.V1-3.22。 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Config.V1-1.11.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Config.V1-1.11. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.DevTools.ContainerAnalysis-3.12.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.DevTools.ContainerAnalysis-3.12. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.PubSub.V1-3.31.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.PubSub.V1-3.31. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Spanner-5.10.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Spanner-5.10. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Spanner-5.11.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Spanner-5.11. 0</a>， <a href=\"https://github.com/googleapis/google-cloud-dotnet/releases/tag/Google.Cloud.Speech.V2-1.7.0\" rel=\"noopener nofollow\" target=\"_blank\">Google.Cloud.Speech.V2-1.7. 0</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/microsoft/WindowsAppSDK\" rel=\"noopener nofollow\" target=\"_blank\">microsoft/WindowsAppSDK</a>\n<ul>\n<li><a href=\"https://github.com/microsoft/WindowsAppSDK/releases/tag/v1.7.7\" rel=\"noopener nofollow\" target=\"_blank\">v1.7.7</a>、<a href=\"https://github.com/microsoft/WindowsAppSDK/releases/tag/v1.8.4\" rel=\"noopener nofollow\" target=\"_blank\">v1.8.4</a>、<a href=\"https://github.com/microsoft/WindowsAppSDK/releases/tag/v2.0-exp4\" rel=\"noopener nofollow\" target=\"_blank\">v2. 0-exp4</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/newrelic/newrelic-dotnet-agent\" rel=\"noopener nofollow\" target=\"_blank\">newrelic/newrelic-dotnet-agent</a>    - <a href=\"https://github.com/newrelic/newrelic-dotnet-agent/releases/tag/v10.48.0\" rel=\"noopener nofollow\" target=\"_blank\">v10.48.0</a></li>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-dotnet-contrib\" rel=\"noopener nofollow\" target=\"_blank\">开放遥测/开放遥测点网贡献</a>\n<ul>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-dotnet-contrib/releases/tag/Instrumentation.AWS-1.14.2\" rel=\"noopener nofollow\" target=\"_blank\">Instrumentation.AWS-1.14.2</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/unoplatform/uno\" rel=\"noopener nofollow\" target=\"_blank\">unoplatform/uno</a>\n<ul>\n<li><a href=\"https://github.com/unoplatform/uno/releases/tag/6.4.242\" rel=\"noopener nofollow\" target=\"_blank\">6.4.242</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"文章幻灯片及更多内容\">文章、幻灯片及更多内容</h2>\n<h3 id=\"net-10-和-c-14-新增内容api-请求响应流水线的增强\">.NET 10 和 C# 14 新增内容：API 请求/响应流水线的增强</h3>\n<p><a href=\"https://blog.elmah.io/new-in-net-10-and-c-14-enhancements-in-apis-request-response-pipeline/\" rel=\"noopener nofollow\" target=\"_blank\">https://blog.elmah.io/new-in-net-10-and-c-14-enhancements-in-apis-request-response-pipeline/</a></p>\n<p>关于 ASP.NET Core 中 .NET 10 改进的 API 请求/响应流水线。</p>\n<h3 id=\"如何用-systemd-和-podman-部署-net-应用--红帽开发者\">如何用 systemd 和 Podman 部署 .NET 应用 | 红帽开发者</h3>\n<p><a href=\"https://developers.redhat.com/articles/2026/01/09/how-deploy-net-applications-systemd-and-podman\" rel=\"noopener nofollow\" target=\"_blank\">https://developers.redhat.com/articles/2026/01/09/how-deploy-net-applications-systemd-and-podman</a></p>\n<p>学习如何使用 systemd 和 Podman/Podman 四重组部署和运行 .NET 应用程序。</p>\n<h3 id=\"副驾驶回忆---visual-studio-博客\">副驾驶回忆 - Visual Studio 博客</h3>\n<p><a href=\"https://devblogs.microsoft.com/visualstudio/copilot-memories/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/visualstudio/copilot-memories/</a></p>\n<p>副驾驶记忆功能的简要介绍。</p>\n<ul>\n<li><a href=\"https://docs.github.com/en/copilot/how-tos/use-copilot-agents/copilot-memory\" rel=\"noopener nofollow\" target=\"_blank\">启用和管理 Copilot 内存 - GitHub 文档</a></li>\n</ul>\n<h3 id=\"关于-publishaot-设置和运行时功能isdynamiccode-已提交属性\">关于 PublishAot 设置和运行时功能。IsDynamicCode 已提交属性</h3>\n<p><a href=\"https://zenn.dev/prozolic/articles/43631043eeaeca\" rel=\"noopener nofollow\" target=\"_blank\">https://zenn.dev/prozolic/articles/43631043eeaeca</a></p>\n<p>解释了“PublishAot”设置中的“RuntimeFeature.IsDynamicCodeCompiled”属性如何影响构建时间和调试执行。</p>\n<h3 id=\"我应该使用-nuget-lock-files---techguitarrapccóm\">我应该使用 NuGet Lock Files - tech.guitarrapc.cóm</h3>\n<p><a href=\"https://tech.guitarrapc.com/entry/2026/01/11/230000\" rel=\"noopener nofollow\" target=\"_blank\">https://tech.guitarrapc.com/entry/2026/01/11/230000</a></p>\n<p>对 NuGet 锁文件的解释及其必要性。</p>\n<h3 id=\"-通过net-应用读取我的号码卡信息可在-linux-上使用qiita\">. 通过.NET 应用读取我的号码卡信息(可在 Linux 上使用)——Qiita。</h3>\n<p><a href=\"https://qiita.com/yamaokunousausa/items/503eb3ae1ec1f35d972d\" rel=\"noopener nofollow\" target=\"_blank\">https://qiita.com/yamaokunousausa/items/503eb3ae1ec1f35d972d</a></p>\n<p>如何在 .NET 应用程序中加载我的号码卡信息。 它还涉及了它在 Linux 上的工作方式。</p>\n<h3 id=\"aws-现支持基于文件的-c-lambda-函数---techguitarrapccóm\">AWS 现支持基于文件的 C# Lambda 函数 - tech.guitarrapc.cóm</h3>\n<p><a href=\"https://tech.guitarrapc.com/entry/2026/01/10/230000\" rel=\"noopener nofollow\" target=\"_blank\">https://tech.guitarrapc.com/entry/2026/01/10/230000</a></p>\n<p>关于 AWS Lambda 对基于 C#文件程序的支持以及对.NET 10 的支持。</p>\n<h3 id=\"windows-应用的-ui-开发难吗-这个问题你可以用-blazor--tailwind-css-解决\">Windows 应用的 UI 开发难吗？ 这个问题，你可以用 Blazor × Tailwind CSS 解决</h3>\n<p><a href=\"https://zenn.dev/wogo_techblog/articles/811ec4e5c7a0e4\" rel=\"noopener nofollow\" target=\"_blank\">https://zenn.dev/wogo_techblog/articles/811ec4e5c7a0e4</a></p>\n<p>学习如何在你的 BlazorWebView(Blazor 混合)应用中使用 Tailwind CSS。</p>\n<h3 id=\"如何用net-maui-构建-android-小部件---net-博客\">如何用.NET MAUI 构建 Android 小部件 - .NET 博客</h3>\n<p><a href=\"https://devblogs.microsoft.com/dotnet/how-to-build-android-widgets-with-dotnet-maui/\" rel=\"noopener nofollow\" target=\"_blank\">https://devblogs.microsoft.com/dotnet/how-to-build-android-widgets-with-dotnet-maui/</a></p>\n<p>如何在 .NET MAUI 中实现 Android 小部件。 文章解释了实现过程，包括与应用程序的交互。</p>\n<h3 id=\"在-azure-云swa--functions--cosmos-db中为您的网站实现旧公告板qiita\">在 Azure 云(SWA + Functions + Cosmos DB)中为您的网站实现“旧公告板”——Qiita</h3>\n<p><a href=\"https://qiita.com/RamTuckey/items/f8e50b038e8b24df9c26\" rel=\"noopener nofollow\" target=\"_blank\">https://qiita.com/RamTuckey/items/f8e50b038e8b24df9c26</a></p>\n<p>Azure Static Web Apps and Azure Functions (Managed Functions) 以及 Cosmos DB 来实现传统的公告板。</p>\n<h3 id=\"在-c模块初始化器被调用之前---qiita\">在 C#模块初始化器被调用之前 - Qiita。</h3>\n<p><a href=\"https://qiita.com/RyotaMurohoshi/items/83d92945e05c7dad90a0\" rel=\"noopener nofollow\" target=\"_blank\">https://qiita.com/RyotaMurohoshi/items/83d92945e05c7dad90a0</a></p>\n<p>关于用 ModuleInitializer 初始化模块初始化器和静态构造器，初始化静态字段的顺序。</p>\n<h3 id=\"从net-memorystream-创建零副本二进制数据---gérald-barré\">从.NET MemoryStream 创建零副本二进制数据 - Gérald Barré</h3>\n<p><a href=\"https://www.meziantou.net/zero-copy-binarydata-creation-from-memorystream-in-dotnet.htm\" rel=\"noopener nofollow\" target=\"_blank\">https://www.meziantou.net/zero-copy-binarydata-creation-from-memorystream-in-dotnet.htm</a></p>\n<p>如何在从内存流创建二进制数据时进行零复制。</p>\n<h3 id=\"wpf--opencvsharp-创建了一款发送带有面部手势的-pdf-页面的应用---qiita\">WPF + OpenCvSharp 创建了一款“发送带有面部手势的 PDF 页面”的应用 - Qiita</h3>\n<p><a href=\"https://qiita.com/kerobot/items/0f5bad24daf91958de50\" rel=\"noopener nofollow\" target=\"_blank\">https://qiita.com/kerobot/items/0f5bad24daf91958de50</a></p>\n<p>描述使用 WPF 和 OpenCvSharp 创建一个识别面部手势并发送关键动作的应用程序。</p>\n<h3 id=\"copilot-为--windows-应用开发工作本地编辑-安心与说明\">Copilot 为 × Windows 应用开发工作：本地编辑 安心与说明</h3>\n<p><a href=\"https://zenn.dev/suusanex/articles/f5a5ca188f957d\" rel=\"noopener nofollow\" target=\"_blank\">https://zenn.dev/suusanex/articles/f5a5ca188f957d</a></p>\n<p>介绍 Visual Studio Code 及在 Visual Studio 中使用 Copilot，以及一些快速使用技巧。</p>\n<h3 id=\"c14-化合物分配超载\">[C#14] 化合物分配超载</h3>\n<p><a href=\"https://zenn.dev/peacockanderson/articles/3f4fbc24420036\" rel=\"noopener nofollow\" target=\"_blank\">https://zenn.dev/peacockanderson/articles/3f4fbc24420036</a></p>\n<p>C# 14 中复赋值算子超载的解释。</p>\n<h2 id=\"库仓库工具等\">库、仓库、工具等</h2>\n<h3 id=\"jsakamotodnx-zipsrcdnx-zipsrc-是一个-net-全局工具利用-gitignore-模式从项目中的源文件创建压缩包排除伪影依赖及其他内容-非源文件\">jsakamoto/dnx-zipsrc：“dnx zipsrc” 是一个 .NET 全局工具，利用 .gitignore 模式从项目中的源文件创建压缩包，排除伪影、依赖及其他内容 非源文件。</h3>\n<p>.gitignore 工具用于过滤不必要的文件和 ZIP 源代码。</p>\n<ul>\n<li><a href=\"https://zenn.dev/j_sakamoto/articles/fd3a6d583474db\" rel=\"noopener nofollow\" target=\"_blank\">我创建了一个 CLI 工具，只压缩源代码，且不会无意中包含构建工件</a></li>\n</ul>\n<h3 id=\"mattparkerdevsharpdbgsharpdbg-是一个-net-托管代码调试器支持完全用-cnet-实现的调试适配器协议\">MattParkerDev/sharpdbg：SharpDbg 是一个 .NET 托管代码调试器，支持完全用 C#/.NET 实现的调试适配器协议</h3>\n<p><a href=\"https://github.com/MattParkerDev/sharpdbg\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/MattParkerDev/sharpdbg</a></p>\n<p>一个支持以 .NET(C#)实现的数据适配器协议的 .NET 调试器。</p>\n<p><a href=\"https://x.com/mattparkerdev/status/2006535935610221030?s=12\" rel=\"noopener nofollow\" target=\"_blank\">https://x.com/mattparkerdev/status/2006535935610221030?s=12</a></p>\n<h3 id=\"评论工作室---visual-studio-市场\">评论工作室 - Visual Studio 市场</h3>\n<p><a href=\"https://marketplace.visualstudio.com/items?itemName=MadsKristensen.commentsvs\" rel=\"noopener nofollow\" target=\"_blank\">https://marketplace.visualstudio.com/items?itemName=MadsKristensen.commentsvs</a></p>\n<p>一个 Visual Studio 扩展，可以将 XML、文档、注释等格式化并显示成易读格式。</p>\n<p><a href=\"https://x.com/mkristensen/status/2009296580688421049?s=12&amp;t=ggvrrZ7oLogHyNoIGNgjbw\" rel=\"noopener nofollow\" target=\"_blank\">https://x.com/mkristensen/status/2009296580688421049?s=12&amp;t=ggvrrZ7oLogHyNoIGNgjbw</a></p>\n<h3 id=\"精选空白\">精选空白</h3>\n<p><a href=\"https://www.vsixgallery.com/extension/SelectedWhitespace.63944e24-4aa2-4d0a-8161-4b7eb9f39831/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.vsixgallery.com/extension/SelectedWhitespace.63944e24-4aa2-4d0a-8161-4b7eb9f39831/</a></p>\n<p>Visual Studio 扩展，用于显示选定范围的空白字符。</p>\n<p><a href=\"https://x.com/mkristensen/status/2011164964372070798?s=12\" rel=\"noopener nofollow\" target=\"_blank\">https://x.com/mkristensen/status/2011164964372070798?s=12</a></p>\n<h2 id=\"今日人物\">今日人物</h2>\n<p><strong>肯尼斯·蓝·汤普逊</strong>（英语：Kenneth Lane Thompson，1943 年 2 月 4 日—），小名<strong>肯·汤普逊</strong>（英语：Ken Thompson），美国<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" rel=\"noopener nofollow\" target=\"_blank\">计算机科学</a>学者和工程师。<a href=\"https://zh.wikipedia.org/wiki/%E9%A7%AD%E5%AE%A2%E6%96%87%E5%8C%96\" rel=\"noopener nofollow\" target=\"_blank\">黑客文化</a>圈子通常称他为“ken”<a href=\"https://zh.wikipedia.org/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A#cite_note-1\" rel=\"noopener nofollow\" target=\"_blank\">[1]</a>。在<a href=\"https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E5%AE%9E%E9%AA%8C%E5%AE%A4\" rel=\"noopener nofollow\" target=\"_blank\">贝尔实验室</a>工作期间，汤普逊设计和实现了<a href=\"https://zh.wikipedia.org/wiki/Unix\" rel=\"noopener nofollow\" target=\"_blank\">Unix</a>操作系统。他创造了<a href=\"https://zh.wikipedia.org/wiki/B%E8%AF%AD%E8%A8%80\" rel=\"noopener nofollow\" target=\"_blank\">B 语言</a>——<a href=\"https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80\" rel=\"noopener nofollow\" target=\"_blank\">C 语言</a>的前身，而且他是<a href=\"https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%88%BE%E5%AF%A6%E9%A9%97%E5%AE%A4%E4%B9%9D%E8%99%9F%E8%A8%88%E7%95%AB\" rel=\"noopener nofollow\" target=\"_blank\">Plan 9</a>操作系统的创造者和开发者之一。2006 年，汤普逊进入<a href=\"https://zh.wikipedia.org/wiki/Google\" rel=\"noopener nofollow\" target=\"_blank\">Google</a>公司工作，与他人共同设计了<a href=\"https://zh.wikipedia.org/wiki/Go\" rel=\"noopener nofollow\" target=\"_blank\">Go 语言</a>。他与<a href=\"https://zh.wikipedia.org/wiki/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87\" rel=\"noopener nofollow\" target=\"_blank\">丹尼斯·里奇</a>同为 1983 年<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96\" rel=\"noopener nofollow\" target=\"_blank\">图灵奖</a>得主。</p>\n<p>此外，肯·汤普逊还参与过<a href=\"https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\" rel=\"noopener nofollow\" target=\"_blank\">正则表达式</a>和<a href=\"https://zh.wikipedia.org/wiki/UTF-8\" rel=\"noopener nofollow\" target=\"_blank\">UTF-8</a>编码的设计，改进了文本编辑器<a href=\"https://zh.wikipedia.org/w/index.php?title=QED_(%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8)&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">QED</a>，创造了<a href=\"https://zh.wikipedia.org/wiki/Ed_(%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8)\" rel=\"noopener nofollow\" target=\"_blank\">ed</a>编辑器。他曾制造过专门用于下<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B\" rel=\"noopener nofollow\" target=\"_blank\">国际象棋</a>的电脑“<a href=\"https://zh.wikipedia.org/w/index.php?title=Belle_(%E6%9C%BA%E5%99%A8)&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">Belle</a>”，并建立了<a href=\"https://zh.wikipedia.org/w/index.php?title=%E6%AE%8B%E5%B1%80%E6%95%B0%E6%8D%AE%E5%BA%93&amp;action=edit&amp;redlink=1\" rel=\"noopener nofollow\" target=\"_blank\">残局数据库</a>。</p>\n<p><img alt=\"肯尼斯·蓝·汤普逊\" src=\"https://img2024.cnblogs.com/blog/997046/202602/997046-20260215203042576-1304543210.jpg\" /></p>\n<h2 id=\"c-net-交流群\">C# .NET 交流群</h2>\n<p>相信大家在开发中经常会遇到一些性能问题，苦于没有有效的工具去发现性能瓶颈，或者是发现瓶颈以后不知道该如何优化。之前一直有读者朋友询问有没有技术交流群，但是由于各种原因一直都没创建，现在很高兴的在这里宣布，我创建了一个专门交流.NET 性能优化经验的群组，主题包括但不限于：</p>\n<ul>\n<li>如何找到.NET 性能瓶颈，如使用 APM、dotnet tools 等工具</li>\n<li>.NET 框架底层原理的实现，如垃圾回收器、JIT 等等</li>\n<li>如何编写高性能的.NET 代码，哪些地方存在性能陷阱</li>\n</ul>\n<p>希望能有更多志同道合朋友加入，分享一些工作中遇到的.NET 问题和宝贵的分析优化经验。<strong>目前一群已满，现在开放二群。</strong>可以加我 vx，我拉你进群: <strong>ls1075</strong> 另外也创建了 <strong>QQ Group</strong>: 687779078，欢迎大家加入。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 20:36</span>&nbsp;\n<a href=\"https://www.cnblogs.com/InCerry\">InCerry</a>&nbsp;\n阅读(<span id=\"post_view_count\">63</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "入门分享篇：一、工欲善其事，必先利其器",
      "link": "https://www.cnblogs.com/chenyouyuan/p/19618451",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chenyouyuan/p/19618451\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 18:23\">\n    <span>入门分享篇：一、工欲善其事，必先利其器</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本次分享，面向接触计算机 or 机器人软件开发 or 嵌入式软件开发 的程序员 学习过程中好用的工具\n如果大家还有其他好用的工具也欢迎分享\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"入门分享篇一工欲善其事必先利其器\">入门分享篇：一、工欲善其事，必先利其器</h1>\n<blockquote>\n<p>本次分享，面向接触计算机 or 机器人软件开发 or 嵌入式软件开发 的程序员 学习过程中好用的工具</p>\n<p>如果大家还有其他好用的工具也欢迎分享</p>\n</blockquote>\n<h2 id=\"磨刀不误砍柴功熟悉你的电脑问题检索思维工具\">磨刀不误砍柴功：熟悉你的电脑、问题检索、思维工具</h2>\n<h3 id=\"学会科学的解决问题和有效的问问题\">学会科学的解决问题和有效的问问题</h3>\n<p>虽然讲的是黑客的提问方法，但其实是相通的。</p>\n<p><a href=\"https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md\" rel=\"noopener nofollow\" target=\"_blank\">How-To-Ask-Questions-The-Smart-Way/README-zh_CN.md at main · ryanhanwu/How-To-Ask-Questions-The-Smart-Way</a></p>\n<h4 id=\"tips如何有效的使用ai工具\">tips:如何有效的使用ai工具？</h4>\n<p>时代在飞速的发展和变化，一切重复性的工作都在逐渐被ai所取代，我们应当做的是着重于利用ai去在ai难以替代的优化和创造性的工作上下功夫。</p>\n<p>在现代ai可以很轻松的帮我们解决从0到1的问题，那问题就集中在我们如何去突破这个1？</p>\n<p>首先基础仍然很重要，你能够创造出什么样的东西仍然取决于你对基础知识的了解程度，当然现在你开始一个项目也不一定需要提前把所有知识全部掌握，但至少你开始做你的项目之前得知道你需要用到一些什么东西，你需要先搭建起一个宏观的实现某一功能的认知框架。在项目开始之前务必做好一定程度的搜索调研</p>\n<p>第二是清晰表述你的需求的能力，可以多尝试通过思维导图的方式来捋清楚自己的需求和逻辑</p>\n<p>第三是独立检索和判断能力，ai不一定能够精确的搜索到你所需要的内容，给出的建议也不一定是最优解，谨慎使用ai托管！（甚至后续还有植入广告的风险）</p>\n<p>第四清晰的知道不同的ai工具擅长什么，比如豆包擅长语言方面的处理，claude擅长编程，那你就可以吧你的需求跟豆包交流，让它纠正你的措辞，再去和claude交流，或者你可以人claude使用项目制的方式，读取你的需求文档，和你对接需求，修正需求等等</p>\n<p>第五 及时记录你的想法和所学所思，ai时代虽然相当于你的外置大脑，但是如果你什么都需要依靠ai来辅助的话，效率会相当低下，每次忘记一个东西又得问一遍ai。</p>\n<h3 id=\"入门工具指南\">入门工具指南</h3>\n<ol>\n<li>\n<p>你可以使用cursor、copilot、codex等各种各样的直接交互的ai编程工具，这比你复制代码给对话式ai然后再粘贴回来高效的多</p>\n<p>这些大部分都有教育优惠或者教育免费的政策</p>\n<p>最方便的你可以只用下载一个vscode，在vscode的拓展插件中下载copilot，再去github的官网申请教育特权，你就能获得一年的免费使用copilot的权限（具体获得方法自行搜索，主要是你得用英文，你的学生证明全部都得是翻译成英文的，也可以手写）</p>\n</li>\n<li>\n<p>学会使用github，有时候你可能上不去github，你想要最简单不花钱，稳定的方法就是去微软商店下steam++（watt toolkit），魔法（会魔法的自然能学会就不多梭啦）</p>\n</li>\n<li>\n<p>建议你选一款适合自己的笔记软件（markdowm），比如obsidian、typora</p>\n<p>我是配合着使用的，obsidian有强大的搜索功能，typora可以有良好的书写体验（typora有非常多的主题可以选择，你也可以配置你的图床，自动上传你粘贴到typora的图片到云端，这样就能不用担心图片的分享问题啦</p>\n</li>\n<li>\n<p>建议你有一款合适的思维导图软件，project graph /Xmind都可以，尽量选界面脱俗一些，这在一些比赛要提交的报告中有很好绘图说明作用，在平时也可以给你提供思维向导</p>\n</li>\n<li>\n<p>建议你在博客园注册一个个人账户，发一发你的学习记录，可以当成一个知识网盘，也可以积累一定的粉丝和阅读量，可能有助于你后续找工作，tips:可以使用Cnblogs-Theme-SimpleMemory自定义你的博客页面噢</p>\n</li>\n<li>\n<p>git的学习相当重要！比赛/项目中的版本迭代很快，你如果没有git工具做版本管理，很容易丢失了原来的代码，喊天菩萨都没有用辣，学习教程在”参考书目/vscode_git本地代码版本管理及远程仓库保存“，你可以在vscode中安装git graph插件更直观的看到你的版本变化</p>\n</li>\n</ol>\n<h2 id=\"vscode-宇宙级ide\">vscode 宇宙级ide</h2>\n<p><a href=\"https://code.visualstudio.com/\" rel=\"noopener nofollow\" target=\"_blank\">Visual Studio Code - The open source AI code editor</a></p>\n<p>几乎所有热门的开发都可以在vscode上找到插件</p>\n<p>其自带的copilot也是十分方便的ai编程助手</p>\n<h2 id=\"git使用指南\">git使用指南</h2>\n<p><a href=\"https://bbs.robomaster.com/article/55660?source=4\" rel=\"noopener nofollow\" target=\"_blank\">【分享】如何使用VScode+git进行本地代码版本管理及远程仓库保存-RoboMaster 社区</a></p>\n<h2 id=\"笔记记录工具-typora\">笔记记录工具 typora</h2>\n<p>超级顺手的markdowm书写体验</p>\n<h3 id=\"markdowm语法的学习\">markdowm语法的学习</h3>\n<p><a href=\"https://markdown.com.cn/basic-syntax/\" rel=\"noopener nofollow\" target=\"_blank\">Markdown 基本语法 | Markdown 教程</a></p>\n<h3 id=\"typora配置图床\">typora配置图床</h3>\n<p><a href=\"https://zhuanlan.zhihu.com/p/346410333\" rel=\"noopener nofollow\" target=\"_blank\">(13 封私信 / 80 条消息) Typora+图床详解（小白都能学得会） - 知乎</a></p>\n<h2 id=\"笔记检索链接工具-obsidian\">笔记检索/链接工具 obsidian</h2>\n<p>强大的检索功能和链接反链接功能</p>\n<h3 id=\"自动同步和上传的git插件\">自动同步和上传的git插件</h3>\n<p><a href=\"https://www.bilibili.com/video/BV1qCh9zrEKq/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f553a12b04c16a678ddc0064cc04563c\" rel=\"noopener nofollow\" target=\"_blank\">obsidian使用git进行多平台同步_哔哩哔哩_bilibili</a></p>\n<h2 id=\"思维导图工具-project-graph\">思维导图工具 project graph</h2>\n<p><a href=\"https://www.bilibili.com/video/BV1y2xdzUEXa/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f553a12b04c16a678ddc0064cc04563c\" rel=\"noopener nofollow\" target=\"_blank\">project-graph 2.0更新介绍：prg文件/树形布局增强/连线增强/窗口新玩法_哔哩哔哩_bilibili</a></p>\n<p>强大的可视化和高度自定义的思维导图软件！</p>\n<h2 id=\"我们热血沸腾的组合技\">我们热血沸腾的组合技</h2>\n<p>typora + obsidian + project graph</p>\n<h2 id=\"博客园\">博客园</h2>\n<p><a href=\"https://www.cnblogs.com/\" target=\"_blank\">博客园 - 开发者的网上家园</a></p>\n<h3 id=\"创造独属于你的博客\">创造独属于你的博客！</h3>\n<p><a href=\"https://github.com/BNDong/Cnblogs-Theme-SimpleMemory\" rel=\"noopener nofollow\" target=\"_blank\">BNDong/Cnblogs-Theme-SimpleMemory: 🍭　Cnblogs theme _ Basic theme : SimpleMemory</a></p>\n<p><a href=\"https://www.cnblogs.com/lingyunvoid/p/beautify.html\" target=\"_blank\">博客园美化「详细教程+代码配置」 - 凌云_void - 博客园</a></p>\n<h2 id=\"edge浏览器\">edge浏览器</h2>\n<p>大多数浏览器都有插件功能，插件真的很好用！</p>\n<h3 id=\"青柠起始页\">青柠起始页</h3>\n<h3 id=\"沉浸式翻译\">沉浸式翻译</h3>\n<h3 id=\"global-speed\">global speed</h3>\n<blockquote>\n<p>路虽远，行则将至✨</p>\n</blockquote>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 18:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chenyouyuan\">ChenYY~</a>&nbsp;\n阅读(<span id=\"post_view_count\">58</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为什么在代理服务器上测试， http2 的转发性能比 http 1 更低？",
      "link": "https://www.cnblogs.com/ahfuzhang/p/19618259",
      "published": "",
      "description": "<div class=\"postcontent\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong><font color=\"gray\" size=\"1\">作者:张富春(ahfuzhang)，转载时请注明作者和引用链接，谢谢！</font></strong></p>\n<ul>\n<li><font color=\"gray\" size=\"1\"><a href=\"https://www.cnblogs.com/ahfuzhang/\" target=\"_blank\">cnblogs博客</a></font></li>\n<li><font color=\"gray\" size=\"1\"><a href=\"https://www.zhihu.com/people/ahfuzhang/posts\" rel=\"noopener nofollow\" target=\"_blank\">zhihu</a></font></li>\n<li><font color=\"gray\" size=\"1\"><a href=\"https://github.com/ahfuzhang\" rel=\"noopener nofollow\" target=\"_blank\">Github</a></font></li>\n<li><font color=\"gray\" size=\"1\">公众号:一本正经的瞎扯</font><br />\n<img alt=\"\" class=\"lazyload\" /></li>\n</ul>\n<hr />\n<p>我在测试 Http2 server 与 Http 1.1 server 的性能差异时，最高测试数据是 http2 比 http1 快 3.6 倍。<br />\n而 Carter 在测试 apisix 代理服务器的性能的时候，得到的数据是 http2 的性能只有 http 1 的 80%。<br />\n我们曾彼此质疑对方的数据，并觉得不可思议！<br />\n我的观点是：二进制协议一定快过文本协议，没理由在代理服务器上测试的数据会导致 http2 慢于 http 1。</p>\n<p>今天终于想明白了原因，其实我们都没错！<br />\n结论是：在代理服务器上，http2 的转发性能会低于 http 1。<br />\n导致这一项差异的关键是 <code>splice()</code> 系统调用，也就是代理服务器中实现<code>零拷贝</code>的关键。</p>\n<p>(后续大量引用 ChatGPT 的回答)</p>\n<h1 id=\"splice-是什么\">splice() 是什么？</h1>\n<p>splice() 是 Linux 的一个系统调用（C 里通过 splice(2) 暴露），用来在 两个文件描述符之间搬运数据，并且尽量走 零拷贝（zero-copy） 路径，减少用户态缓冲区参与。</p>\n<p>最典型的用途：文件 ↔ 管道、管道 ↔ socket，用它可以把数据从磁盘文件直接“送”到网络连接里，中间不需要 read() 到用户态再 write() 回内核。</p>\n<p>⸻</p>\n<p>它解决什么问题</p>\n<p>传统写法：</p>\n<pre><code class=\"language-c\">read(file_fd, user_buf, n);\nwrite(sock_fd, user_buf, n);\n</code></pre>\n<p>缺点：数据会在内核 ↔ 用户态之间拷贝（还可能污染 CPU cache、占用内存带宽）。</p>\n<p>splice() 的目标：让数据尽量在内核内部移动（比如从 page cache / pipe buffer 直接到 socket buffer），减少一次或多次拷贝。</p>\n<p>⸻</p>\n<p>它的基本形态（语义）</p>\n<pre><code class=\"language-c\">ssize_t splice(int fd_in,  loff_t *off_in,\n               int fd_out, loff_t *off_out,\n               size_t len, unsigned int flags);\n</code></pre>\n<pre><code>•\tfd_in / fd_out：输入/输出 fd\n•\toff_in / off_out：\n•\t传 NULL 表示使用 fd 当前偏移并推进（像普通读写那样）\n•\t非 NULL 则用你提供的偏移（类似 pread/pwrite 的味道），并且不一定修改 fd 的文件偏移（具体取决于对象类型）\n•\tlen：最多搬运多少字节\n•\tflags：控制阻塞/移动行为（例如 SPLICE_F_NONBLOCK 等）\n</code></pre>\n<p>返回值：实际搬运的字节数；0 通常表示 EOF；-1 表示出错（errno 说明原因）。</p>\n<p>⸻</p>\n<p>常见组合</p>\n<ol>\n<li>\n<p>file → pipe → socket（高性能“发送文件”）<br />\n•\tsplice(file_fd → pipe_write_end)<br />\n•\tsplice(pipe_read_end → sock_fd)<br />\n这类组合常用于实现“类似 sendfile 的效果”，但 splice 更通用（尤其适合你还要在中间做点别的内核态处理的场景）。</p>\n</li>\n<li>\n<p>pipe ↔ pipe</p>\n</li>\n</ol>\n<p>用于在管道之间转移数据（比如配合 tee() 做复制）。</p>\n<p>⸻</p>\n<p>适用限制（很重要）<br />\n•\t并不是任意 fd 都支持。splice 需要底层文件操作实现支持（VFS/驱动/协议栈）。<br />\n•\t在 Linux 上，pipe 经常是 splice 的“中转站”：很多场景要求 fd_in 或 fd_out 至少有一端是 pipe（或者最终在内核内部用 pipe buffer 做承载）。<br />\n•\t数据来源如果是普通文件，通常来自 page cache（因此能做到少拷贝或零拷贝）。</p>\n<p>⸻</p>\n<p>和 sendfile() 的关系<br />\n•\tsendfile()：更“专用”，通常是 文件 → socket 的快速路径。<br />\n•\tsplice()：更“通用”，可以在更多类型的 fd 之间搬运，常见用法是 通过 pipe 作为桥 来拼接成 file→socket 的零拷贝链路。</p>\n<h1 id=\"就算-splice-把内核中-socket-buffer-的数据转移到了-pipe-下面用户使用时也仍然要-read似乎并没有做到零拷贝\">就算 splice 把内核中 socket buffer 的数据转移到了 pipe 下面，用户使用时也仍然要 read()，似乎并没有做到零拷贝？</h1>\n<p>对，你理解得很准确：只要最终要在用户态“看见/处理”字节流，就绕不开一次 copy_to_user。splice(socket → pipe) 只是把“从 socket 读到用户缓冲区”这一步，换成了“从 socket 读到内核 pipe”，因此它不能消除“内核 → 用户态”的拷贝；你后面 read(pipefd, userbuf, …) 仍然会拷贝。</p>\n<p>更精确地说：<br />\n•\t传统路径（用户态消费）<br />\nrecv()/read(socket, userbuf)<br />\n→ 内核 socket 接收队列 → 用户态 userbuf（一次 copy_to_user）<br />\n•\tsplice 路径（用户态仍要消费）<br />\nsplice(socket → pipe)（内核内搬运/重挂页，避免 copy_to_user）<br />\n然后 read(pipe → userbuf)<br />\n→ pipe → 用户态 userbuf（还是一次 copy_to_user）</p>\n<p>所以：“用户态要拿到 payload”这一目标下，splice 不会减少总拷贝次数到 0。它可能减少的是：<br />\n•\t少一次“多余的中间 buffer 拷贝/搬运”（比如你原来先 read 到用户，再 write 到另一个 fd）<br />\n•\t或减少 CPU 开销（某些场景下从 socket 直接挂到 pipe、再 splice 到目标 fd）</p>\n<h1 id=\"什么时候-splice-真正有意义能把用户态拷贝降到-0\">什么时候 splice 真正有意义（能把用户态拷贝降到 0）？</h1>\n<ol>\n<li>纯转发（不解析数据）</li>\n</ol>\n<p>socket_in → pipe → socket_out / file<br />\n你不在用户态触碰数据，只做转发/落盘。典型：反向代理、L7 但不解包、录流到文件等。</p>\n<ol start=\"2\">\n<li>“只看少量头部 + 大量 body” 的混合</li>\n</ol>\n<p>比如 HTTP：你在用户态只 recv 一小段 header 做决策；body 用 splice 走零拷贝转发。<br />\n这类能显著减少 copy_to_user 的总量（因为大头 body 不进用户态）。</p>\n<p>⸻</p>\n<p>你真正关心的点：TCP 通讯里的拷贝到底能不能减少？<br />\n•\t应用层必须处理 payload（解码、压缩、JSON、protobuf…）：<br />\n至少一次内核→用户拷贝不可避免（把字节交给进程）。<br />\n•\t应用层不处理 payload，只转发：<br />\n可以做到 0 次进入用户态（splice/送 NIC 相关 offload 另说）。</p>\n<h1 id=\"对于代理服务器-是不是可以理解为-http-1-大部分都情况能做内核态的四层转发而-http-2-只能做用户态的七层转发\">对于代理服务器， 是不是可以理解为 http 1 大部分都情况能做内核态的四层转发，而 http 2 只能做用户态的七层转发?</h1>\n<p>不完全对，但你这个直觉抓到了一半：决定能不能“像 L4 那样内核态转发”的关键，不是 HTTP/1 vs HTTP/2，而是代理要不要理解协议语义、要不要“终止连接并重建连接”。 HTTP/2 因为多路复用 + 流控 + 头压缩，确实更容易把你“逼到”用户态 L7，但 HTTP/1 也不是天然就能内核态转发。</p>\n<p>把它拆成几种代理形态，你会更清楚：</p>\n<ol>\n<li>真·L4 代理（TCP/四层负载均衡）<br />\n•\t不看 HTTP，只转发字节流：客户端 TCP ↔ 后端 TCP。<br />\n•\t这对 HTTP/1 和 HTTP/2 都一样：都能做“内核友好”的转发（例如 splice/零拷贝路径、甚至内核里的 TPROXY/IPVS 等）。<br />\n•\t代价：你做不了按 URL/Host/Header 的路由、鉴权、限速等 L7 能力。</li>\n</ol>\n<p>✅ 结论：HTTP/2 也可以做 L4 转发，只是此时你根本不知道它是 HTTP/2。</p>\n<ol start=\"2\">\n<li>HTTP/1 的 L7 反代（常见 Nginx/Envoy 的那种）<br />\n•\t你要读请求行/headers，决定路由，可能改 header，可能缓存、压缩、重试等。<br />\n•\t这就已经是 用户态 L7 了，不是“内核态 L4”。</li>\n</ol>\n<p>不过 HTTP/1 有一个“容易优化”的点：<br />\n•\theader/body 分界清晰，且通常一个连接同一时刻服务一个请求（即便 keep-alive，也多是串行，管线化很少用）。<br />\n•\t所以可以做 “只在用户态读少量 header，然后 body 用 splice 直通”（大 body 上传/下载时很香）。</p>\n<p>✅ 结论：HTTP/1 不是“大部分都能内核态 L4 转发”，它只是 更容易做“半 L7 + 半零拷贝直通”。</p>\n<ol start=\"3\">\n<li>HTTP/2 的 L7 反代（stream 级路由、多路复用）<br />\n•\t同一条 TCP 连接里交错多个 stream 的 frames。<br />\n•\t你要按 stream 拆帧、调度、维护流控窗口、处理 HPACK。<br />\n•\t前后两端通常是两条独立连接（客户端一条 H2，后端另一条 H2 或 H1），stream id/窗口/HPACK 动态表都不可能原封不动“直通”。</li>\n</ol>\n<p>这使得 把大段 payload 当作连续字节“splice 过去”非常困难，因为你必须先在用户态把属于某个 stream 的 DATA 帧摘出来再发到后端（而且还可能要重排/限速/优先级）。</p>\n<p>✅ 结论：HTTP/2 做 L7 反代时，基本只能用户态为主（或者说，必须有“协议终止点”在用户态/实现层）。</p>\n<p>⸻</p>\n<p>更准确的一句话<br />\n•\tHTTP/1：更容易把“body”做成内核态直通（splice/sendfile），用户态只处理少量控制面（headers）。<br />\n•\tHTTP/2：只要你要做 L7（按 stream/headers 路由），就很难做到 body 完全内核态直通，因为 framing/mux/flow-control 迫使你参与数据分发。<br />\n•\t但 HTTP/2 依然可以做纯 L4 转发（只是你失去所有 L7 能力）。</p>\n<h1 id=\"总结\">总结</h1>\n<ul>\n<li>http 1.1 的协议特点：header 和 body 有明显的区分，body 的长度非常明确，一条 tcp 连接上同时只有一个请求响应 —— 因此，在代理服务器的场景， http 1 很容易使用 splice 这样零拷贝机制来优化。\n<ul>\n<li>特别是 body 部分这样更长的内容，直接在内核态就能够实现数据交换，完全不需要把数据拷贝到用户态，再从用户态发送出去。</li>\n</ul>\n</li>\n<li>http 2 在一条 tcp 连接上有多个流，每个流超出 <code>SETTINGS_MAX_FRAME_SIZE</code> 后还会分成多个 frame —— 由此决定了 http2 上通过 splice 实现零拷贝优化很困难，或者说能够真正零拷贝的场景变少了。</li>\n<li>对于服务器而言：\n<ul>\n<li>http 2 这样的二进制协议确实比 http 1 更快，特别是像 api server / rcp server 这样的数据包小+请求频繁的场景，http2 比 http1 快 3.6 倍就不奇怪了。</li>\n<li>如果是图片下载/文件下载/大吞吐量的数据传输，选择 http1 更好</li>\n</ul>\n</li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"itemdesc\">\n\t\t\t发表于 \n<span id=\"post-date\">2026-02-15 16:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ahfuzhang\">ahfuzhang</a>&nbsp;\n阅读(<span id=\"post_view_count\">47</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</div>"
    },
    {
      "title": "Go - slog使用入门",
      "link": "https://www.cnblogs.com/XY-Heruo/p/19618220",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/XY-Heruo/p/19618220\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 15:45\">\n    <span>Go - slog使用入门</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Go标准库slog使用入门\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"简介\">简介</h2>\n<p><code>slog</code> 是 Go 1.21 引入的官方结构化日志库（Structured Logging）。它结束了 Go 标准库只有简单 <code>log</code> 包的历史，让我们可以直接输出 <strong>JSON</strong> 或 <strong>Key-Value</strong> 格式的日志，非常适合对接 ELK、Grafana Loki 等日志分析系统。</p>\n<p>相较于第三方日志库如 <code>zap</code>、<code>logrus</code>，<code>slog</code> 的优势在于：</p>\n<ul>\n<li><strong>零依赖</strong>：作为标准库的一部分，无需引入第三方依赖</li>\n<li><strong>官方维护</strong>：长期稳定，API 变更有 Go 兼容性承诺保障</li>\n<li><strong>接口简洁</strong>：API 设计清晰，学习成本低</li>\n<li><strong>可扩展</strong>：通过自定义 Handler 可以实现各种定制需求</li>\n</ul>\n<h2 id=\"基本使用\">基本使用</h2>\n<p><code>slog</code> 用起来非常简单。默认输出到标准错误流（<code>os.Stderr</code>），格式为普通文本。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"fmt\"\n\t\"log/slog\"\n)\n\nfunc main() {\n\tslog.Debug(\"Hello world\")\n\tslog.Info(\"Hello world\")\n\tslog.Warn(\"Hello world\")\n\tslog.Error(\"Hello world\")\n\n\tslog.Info(\"this is a message\", \"name\", \"zhangsan\")\n\n\tage := 8\n\tslog.Warn(fmt.Sprintf(\"这是 %d 岁?\", age))\n}\n</code></pre>\n<p>运行输出：</p>\n<pre><code class=\"language-shell\">$ go run main.go\n2026/02/15 11:52:24 INFO Hello world\n2026/02/15 11:52:24 WARN Hello world\n2026/02/15 11:52:24 ERROR Hello world\n2026/02/15 11:52:24 INFO this is a message name=zhangsan\n2026/02/15 11:52:24 WARN 这是 8 岁?\n</code></pre>\n<blockquote>\n<p><strong>注意</strong>：默认的 <code>slog</code> logger 日志级别为 <code>INFO</code>，因此 <code>Debug</code> 级别的日志不会输出。</p>\n</blockquote>\n<h3 id=\"日志级别\">日志级别</h3>\n<p><code>slog</code> 定义了四个日志级别，从低到高依次为：</p>\n<table>\n<thead>\n<tr>\n<th>级别</th>\n<th>常量</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DEBUG</td>\n<td><code>slog.LevelDebug</code></td>\n<td>调试信息，开发环境使用</td>\n</tr>\n<tr>\n<td>INFO</td>\n<td><code>slog.LevelInfo</code></td>\n<td>常规信息</td>\n</tr>\n<tr>\n<td>WARN</td>\n<td><code>slog.LevelWarn</code></td>\n<td>警告信息</td>\n</tr>\n<tr>\n<td>ERROR</td>\n<td><code>slog.LevelError</code></td>\n<td>错误信息</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"输出-json-格式\">输出 JSON 格式</h2>\n<p><code>slog</code> 可以输出 JSON 格式，便于与 ELK、Grafana Loki 等日志系统集成。</p>\n<p>以下示例演示了如何修改默认的时间戳格式和调用源输出格式，并将其设置为默认 logger：</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tjsonLogger := slog.New(slog.NewJSONHandler(os.Stderr, &amp;slog.HandlerOptions{\n\t\tAddSource: true,            // 添加调用源信息\n\t\tLevel:     slog.LevelDebug, // 设置日志级别\n\t\tReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {\n\t\t\t// 自定义时间格式\n\t\t\tif a.Key == slog.TimeKey {\n\t\t\t\tif t, ok := a.Value.Any().(time.Time); ok {\n\t\t\t\t\ta.Value = slog.StringValue(t.Format(time.RFC3339))\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 简化调用源信息，只保留文件名和行号\n\t\t\tif a.Key == slog.SourceKey {\n\t\t\t\tsource := a.Value.Any().(*slog.Source)\n\t\t\t\tshortFile := source.File\n\t\t\t\tfor i := len(source.File) - 1; i &gt; 0; i-- {\n\t\t\t\t\tif source.File[i] == '/' {\n\t\t\t\t\t\tshortFile = source.File[i+1:]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn slog.String(\"source\", fmt.Sprintf(\"%s:%d\", shortFile, source.Line))\n\t\t\t}\n\t\t\treturn a\n\t\t},\n\t}))\n\n\tjsonLogger.Debug(\"Hello world\")\n\tjsonLogger.Info(\"Hello world\")\n\tjsonLogger.Warn(\"Hello world\")\n\tjsonLogger.Error(\"Hello world\")\n\n\tjsonLogger.Info(\"this is a message\", \"name\", \"zhangsan\")\n\n\tage := 8\n\tjsonLogger.Warn(fmt.Sprintf(\"这是 %d 岁?\", age))\n\n\t// 替换默认 logger\n\tslog.SetDefault(jsonLogger)\n\tslog.Debug(\"Hello world\")\n\tslog.Info(\"Hello world\")\n\tslog.Warn(\"Hello world\")\n\tslog.Error(\"Hello world\")\n\n\tslog.Info(\"this is a message\", \"name\", \"zhangsan\")\n\n\tage = 9\n\tslog.Warn(fmt.Sprintf(\"这是 %d 岁?\", age))\n}\n</code></pre>\n<p>运行输出：</p>\n<pre><code class=\"language-shell\">$ go run main.go\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"DEBUG\",\"source\":\"main.go:38\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"INFO\",\"source\":\"main.go:39\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"WARN\",\"source\":\"main.go:40\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"ERROR\",\"source\":\"main.go:41\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"INFO\",\"source\":\"main.go:43\",\"msg\":\"this is a message\",\"name\":\"zhangsan\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"WARN\",\"source\":\"main.go:46\",\"msg\":\"这是 8 岁?\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"DEBUG\",\"source\":\"main.go:50\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"INFO\",\"source\":\"main.go:51\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"WARN\",\"source\":\"main.go:52\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"ERROR\",\"source\":\"main.go:53\",\"msg\":\"Hello world\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"INFO\",\"source\":\"main.go:55\",\"msg\":\"this is a message\",\"name\":\"zhangsan\"}\n{\"time\":\"2026-02-15T12:07:32+08:00\",\"level\":\"WARN\",\"source\":\"main.go:58\",\"msg\":\"这是 9 岁?\"}\n</code></pre>\n<h3 id=\"handleroptions-详解\">HandlerOptions 详解</h3>\n<p><code>HandlerOptions</code> 提供了三个配置项：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>AddSource</code></td>\n<td><code>bool</code></td>\n<td>是否添加调用源信息（文件名和行号）</td>\n</tr>\n<tr>\n<td><code>Level</code></td>\n<td><code>slog.Leveler</code></td>\n<td>最低日志级别，低于此级别的日志将被忽略</td>\n</tr>\n<tr>\n<td><code>ReplaceAttr</code></td>\n<td><code>func([]string, slog.Attr) slog.Attr</code></td>\n<td>用于修改或替换属性的回调函数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"with-注入通用属性\">With 注入通用属性</h2>\n<p>创建 Logger 时，可以用 <code>With</code> 方法为 logger 添加通用属性。这些属性会自动附加到每条日志记录中，适合注入服务名、环境、版本等上下文信息。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tjsonLogger := slog.New(slog.NewJSONHandler(os.Stderr, &amp;slog.HandlerOptions{\n\t\tAddSource: true,\n\t\tLevel:     slog.LevelDebug,\n\t\tReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {\n\t\t\tif a.Key == slog.TimeKey {\n\t\t\t\tif t, ok := a.Value.Any().(time.Time); ok {\n\t\t\t\t\ta.Value = slog.StringValue(t.Format(time.RFC3339))\n\t\t\t\t}\n\t\t\t}\n\t\t\tif a.Key == slog.SourceKey {\n\t\t\t\tsource := a.Value.Any().(*slog.Source)\n\t\t\t\tshortFile := source.File\n\t\t\t\tfor i := len(source.File) - 1; i &gt; 0; i-- {\n\t\t\t\t\tif source.File[i] == '/' {\n\t\t\t\t\t\tshortFile = source.File[i+1:]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn slog.String(\"source\", fmt.Sprintf(\"%s:%d\", shortFile, source.Line))\n\t\t\t}\n\t\t\treturn a\n\t\t},\n\t})).With(\"logger\", \"json\", \"env\", \"production\")\n\n\tjsonLogger.Debug(\"Hello world\")\n\tjsonLogger.Info(\"Hello world\")\n\tjsonLogger.Warn(\"Hello world\")\n\tjsonLogger.Error(\"Hello world\")\n\n\tjsonLogger.Info(\"this is a message\", \"name\", \"zhangsan\")\n}\n</code></pre>\n<p>运行输出：</p>\n<pre><code class=\"language-shell\">$ go run main.go\n{\"time\":\"2026-02-15T13:24:38+08:00\",\"level\":\"DEBUG\",\"source\":\"main.go:42\",\"msg\":\"Hello world\",\"logger\":\"json\",\"env\":\"production\"}\n{\"time\":\"2026-02-15T13:24:38+08:00\",\"level\":\"INFO\",\"source\":\"main.go:43\",\"msg\":\"Hello world\",\"logger\":\"json\",\"env\":\"production\"}\n{\"time\":\"2026-02-15T13:24:38+08:00\",\"level\":\"WARN\",\"source\":\"main.go:44\",\"msg\":\"Hello world\",\"logger\":\"json\",\"env\":\"production\"}\n{\"time\":\"2026-02-15T13:24:38+08:00\",\"level\":\"ERROR\",\"source\":\"main.go:45\",\"msg\":\"Hello world\",\"logger\":\"json\",\"env\":\"production\"}\n{\"time\":\"2026-02-15T13:24:38+08:00\",\"level\":\"INFO\",\"source\":\"main.go:47\",\"msg\":\"this is a message\",\"logger\":\"json\",\"env\":\"production\",\"name\":\"zhangsan\"}\n</code></pre>\n<h2 id=\"使用-group-对属性分组\">使用 Group 对属性分组</h2>\n<p>当日志属性较多时，可以使用 <code>slog.Group</code> 将相关属性组织在一起，使输出结构更清晰：</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tjsonLogger := slog.New(slog.NewJSONHandler(os.Stderr, &amp;slog.HandlerOptions{\n\t\tAddSource: true,\n\t\tLevel:     slog.LevelDebug,\n\t\tReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {\n\t\t\tif a.Key == slog.TimeKey {\n\t\t\t\tif t, ok := a.Value.Any().(time.Time); ok {\n\t\t\t\t\ta.Value = slog.StringValue(t.Format(time.RFC3339))\n\t\t\t\t}\n\t\t\t}\n\t\t\tif a.Key == slog.SourceKey {\n\t\t\t\tsource := a.Value.Any().(*slog.Source)\n\t\t\t\tshortFile := source.File\n\t\t\t\tfor i := len(source.File) - 1; i &gt; 0; i-- {\n\t\t\t\t\tif source.File[i] == '/' {\n\t\t\t\t\t\tshortFile = source.File[i+1:]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn slog.String(\"source\", fmt.Sprintf(\"%s:%d\", shortFile, source.Line))\n\t\t\t}\n\t\t\treturn a\n\t\t},\n\t}))\n\n\tjsonLogger = jsonLogger.With(\"logger\", \"json\")\n\n\t// 使用 Group 组织相关属性\n\tjsonLogger.Info(\"系统状态\",\n\t\tslog.Group(\"metrics\",\n\t\t\tslog.Int(\"cpu\", 4),\n\t\t\tslog.Float64(\"memPercent\", 2.33),\n\t\t),\n\t\tslog.Group(\"request\",\n\t\t\tslog.String(\"method\", \"GET\"),\n\t\t\tslog.String(\"path\", \"/api/users\"),\n\t\t),\n\t)\n}\n</code></pre>\n<p>运行输出：</p>\n<pre><code class=\"language-shell\">$ go run main.go\n{\"time\":\"2026-02-15T13:30:08+08:00\",\"level\":\"INFO\",\"source\":\"main.go:43\",\"msg\":\"系统状态\",\"logger\":\"json\",\"metrics\":{\"cpu\":4,\"memPercent\":2.33},\"request\":{\"method\":\"GET\",\"path\":\"/api/users\"}}\n</code></pre>\n<h2 id=\"高性能场景使用-logattrs\">高性能场景使用 LogAttrs</h2>\n<p>如果需要在高性能循环中打印日志，建议使用 <code>LogAttrs</code> 方法。它使用强类型属性（<code>slog.Attr</code>），避免了反射带来的性能开销。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"context\"\n\t\"log/slog\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tjsonLogger := slog.New(slog.NewJSONHandler(os.Stderr, &amp;slog.HandlerOptions{\n\t\tAddSource: true,\n\t\tLevel:     slog.LevelDebug,\n\t\tReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {\n\t\t\tif a.Key == slog.TimeKey {\n\t\t\t\tif t, ok := a.Value.Any().(time.Time); ok {\n\t\t\t\t\ta.Value = slog.StringValue(t.Format(time.RFC3339))\n\t\t\t\t}\n\t\t\t}\n\t\t\tif a.Key == slog.SourceKey {\n\t\t\t\tsource := a.Value.Any().(*slog.Source)\n\t\t\t\tshortFile := source.File\n\t\t\t\tfor i := len(source.File) - 1; i &gt; 0; i-- {\n\t\t\t\t\tif source.File[i] == '/' {\n\t\t\t\t\t\tshortFile = source.File[i+1:]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn slog.String(\"source\", fmt.Sprintf(\"%s:%d\", shortFile, source.Line))\n\t\t\t}\n\t\t\treturn a\n\t\t},\n\t})).With(\"logger\", \"json\")\n\n\tfor i := range 5 {\n\t\tjsonLogger.LogAttrs(\n\t\t\tcontext.Background(),\n\t\t\tslog.LevelInfo,\n\t\t\t\"执行遍历\",\n\t\t\tslog.Int(\"round\", i),\n\t\t\tslog.String(\"task_name\", \"cleanup\"),\n\t\t\tslog.Duration(\"duration\", time.Second*time.Duration(i+1)),\n\t\t)\n\t}\n}\n</code></pre>\n<p>运行输出：</p>\n<pre><code class=\"language-shell\">$ go run main.go\n{\"time\":\"2026-02-15T13:38:21+08:00\",\"level\":\"INFO\",\"source\":\"main.go:45\",\"msg\":\"执行遍历\",\"logger\":\"json\",\"round\":0,\"task_name\":\"cleanup\",\"duration\":1000000000}\n{\"time\":\"2026-02-15T13:38:21+08:00\",\"level\":\"INFO\",\"source\":\"main.go:45\",\"msg\":\"执行遍历\",\"logger\":\"json\",\"round\":1,\"task_name\":\"cleanup\",\"duration\":2000000000}\n{\"time\":\"2026-02-15T13:38:21+08:00\",\"level\":\"INFO\",\"source\":\"main.go:45\",\"msg\":\"执行遍历\",\"logger\":\"json\",\"round\":2,\"task_name\":\"cleanup\",\"duration\":3000000000}\n{\"time\":\"2026-02-15T13:38:21+08:00\",\"level\":\"INFO\",\"source\":\"main.go:45\",\"msg\":\"执行遍历\",\"logger\":\"json\",\"round\":3,\"task_name\":\"cleanup\",\"duration\":4000000000}\n{\"time\":\"2026-02-15T13:38:21+08:00\",\"level\":\"INFO\",\"source\":\"main.go:45\",\"msg\":\"执行遍历\",\"logger\":\"json\",\"round\":4,\"task_name\":\"cleanup\",\"duration\":5000000000}\n</code></pre>\n<h3 id=\"性能对比\">性能对比</h3>\n<p>根据官方基准测试，<code>LogAttrs</code> 相比普通方法调用有约 30% 的性能提升：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>内存分配</th>\n<th>性能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>slog.Info(msg, \"key\", value)</code></td>\n<td>有额外分配</td>\n<td>基准</td>\n</tr>\n<tr>\n<td><code>slog.LogAttrs(ctx, level, msg, attrs...)</code></td>\n<td>零额外分配</td>\n<td>快约 30%</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"提取-context-中的链路信息\">提取 Context 中的链路信息</h2>\n<p><code>slog</code> 提供了 <code>InfoContext</code>、<code>WarnContext</code> 等方法，可以从 <code>context.Context</code> 中提取数据。默认情况下，这些方法不会自动提取 context 中的值，需要通过自定义 Handler 来实现。</p>\n<h3 id=\"自定义-contexthandler\">自定义 ContextHandler</h3>\n<p>以下示例实现了一个自定义 Handler，用于从 context 中提取 TraceID：</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"context\"\n\t\"log/slog\"\n\t\"os\"\n)\n\ntype contextKey string\n\nconst TraceIDKey contextKey = \"trace_id\"\n\n// ContextHandler 包装一个 slog.Handler，在处理日志时自动从 context 中提取 TraceID\ntype ContextHandler struct {\n\tslog.Handler\n}\n\nfunc (h *ContextHandler) Handle(ctx context.Context, record slog.Record) error {\n\tif ctx != nil {\n\t\tif traceID, ok := ctx.Value(TraceIDKey).(string); ok &amp;&amp; traceID != \"\" {\n\t\t\trecord.AddAttrs(slog.String(string(TraceIDKey), traceID))\n\t\t}\n\t}\n\treturn h.Handler.Handle(ctx, record)\n}\n\nfunc main() {\n\tbaseHandler := slog.NewJSONHandler(os.Stdout, nil)\n\thandler := &amp;ContextHandler{Handler: baseHandler}\n\tjsonLogger := slog.New(handler)\n\tslog.SetDefault(jsonLogger)\n\n\tctx := context.WithValue(context.Background(), TraceIDKey, \"abc123-def456\")\n\n\tslog.InfoContext(ctx, \"hello world\")\n\tslog.WarnContext(ctx, \"something happened\", \"user\", \"zhangsan\")\n}\n</code></pre>\n<p>运行输出：</p>\n<pre><code class=\"language-shell\">$ go run main.go | python3 -m json.tool\n{\n  \"time\": \"2026-02-15T13:56:43.086323769+08:00\",\n  \"level\": \"INFO\",\n  \"msg\": \"hello world\",\n  \"trace_id\": \"abc123-def456\"\n}\n{\n  \"time\": \"2026-02-15T13:56:43.086323769+08:00\",\n  \"level\": \"WARN\",\n  \"msg\": \"something happened\",\n  \"user\": \"zhangsan\",\n  \"trace_id\": \"abc123-def456\"\n}\n</code></pre>\n<h3 id=\"在-gin-框架中使用-slog\">在 Gin 框架中使用 slog</h3>\n<p>在 Gin 中使用 slog 的 context 能力，通常的做法是编写一个中间件来注入 TraceID，并配合自定义 <code>slog.Handler</code> 来提取它。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"context\"\n\t\"log/slog\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"os\"\n\t\"runtime/debug\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/google/uuid\"\n)\n\ntype contextKey string\n\nconst TraceIDKey contextKey = \"trace_id\"\n\n// ContextHandler 从 context 中提取 TraceID 并添加到日志中\ntype ContextHandler struct {\n\tslog.Handler\n}\n\nfunc (h *ContextHandler) Handle(ctx context.Context, record slog.Record) error {\n\tif ctx != nil {\n\t\tif traceID, ok := ctx.Value(TraceIDKey).(string); ok &amp;&amp; traceID != \"\" {\n\t\t\trecord.AddAttrs(slog.String(string(TraceIDKey), traceID))\n\t\t}\n\t}\n\treturn h.Handler.Handle(ctx, record)\n}\n\n// SlogMiddleware 是一个 Gin 中间件，用于注入 TraceID\nfunc SlogMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tstart := time.Now()\n\n\t\t// 优先从请求头获取 TraceID，没有则生成新的\n\t\ttraceID := c.GetHeader(\"X-Trace-ID\")\n\t\tif traceID == \"\" {\n\t\t\ttraceID = uuid.New().String()\n\t\t}\n\n\t\t// 将 TraceID 注入到标准的 context.Context 中\n\t\t// 注意：Gin 的 c.Set 只在 Gin 内部生效，slog 需要标准库的 Context\n\t\tctx := context.WithValue(c.Request.Context(), TraceIDKey, traceID)\n\t\tc.Request = c.Request.WithContext(ctx)\n\n\t\t// 将 TraceID 写入响应头，方便客户端追踪\n\t\tc.Header(\"X-Trace-ID\", traceID)\n\n\t\tc.Next()\n\n\t\t// 请求结束后的汇总日志\n\t\tslog.InfoContext(c.Request.Context(), \"Request completed\",\n\t\t\tslog.String(\"method\", c.Request.Method),\n\t\t\tslog.String(\"path\", c.Request.URL.Path),\n\t\t\tslog.Int(\"status\", c.Writer.Status()),\n\t\t\tslog.Int(\"body_size\", c.Writer.Size()),\n\t\t\tslog.Duration(\"latency\", time.Since(start)),\n\t\t)\n\t}\n}\n\n// SlogRecovery 是一个自定义的恢复中间件\n// 它会捕获 Panic，记录堆栈信息，并使用 slog.ErrorContext 输出\nfunc SlogRecovery() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\t// 检查是否是连接中断（broken pipe）\n\t\t\t\tvar brokenPipe bool\n\t\t\t\tif ne, ok := err.(*net.OpError); ok {\n\t\t\t\t\tif se, ok := ne.Err.(*os.SyscallError); ok {\n\t\t\t\t\t\tif strings.Contains(strings.ToLower(se.Error()), \"broken pipe\") ||\n\t\t\t\t\t\t\tstrings.Contains(strings.ToLower(se.Error()), \"connection reset by peer\") {\n\t\t\t\t\t\t\tbrokenPipe = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 获取堆栈信息\n\t\t\t\tstack := string(debug.Stack())\n\n\t\t\t\t// 获取原始请求内容\n\t\t\t\thttpRequest, _ := httputil.DumpRequest(c.Request, false)\n\n\t\t\t\tif brokenPipe {\n\t\t\t\t\tslog.ErrorContext(c.Request.Context(), \"网络连接中断\",\n\t\t\t\t\t\tslog.Any(\"error\", err),\n\t\t\t\t\t\tslog.String(\"request\", string(httpRequest)),\n\t\t\t\t\t)\n\t\t\t\t\tc.Error(err.(error))\n\t\t\t\t\tc.Abort()\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// 记录 Panic 详情\n\t\t\t\tslog.ErrorContext(c.Request.Context(), \"Recovery from panic\",\n\t\t\t\t\tslog.Any(\"error\", err),\n\t\t\t\t\tslog.String(\"stack\", stack),\n\t\t\t\t\tslog.String(\"request\", string(httpRequest)),\n\t\t\t\t)\n\n\t\t\t\tctx := c.Request.Context()\n\t\t\t\ttraceID, _ := ctx.Value(TraceIDKey).(string)\n\n\t\t\t\t// 返回 500 状态码\n\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\n\t\t\t\t\t\"code\":      http.StatusInternalServerError,\n\t\t\t\t\t\"msg\":       \"Internal Server Error\",\n\t\t\t\t\t\"data\":      nil,\n\t\t\t\t\t\"timestamp\": time.Now().Format(time.RFC3339),\n\t\t\t\t\t\"trace_id\":  traceID,\n\t\t\t\t})\n\t\t\t}\n\t\t}()\n\t\tc.Next()\n\t}\n}\n\nfunc main() {\n\t// 初始化 slog\n\tbaseHandler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{\n\t\tLevel: slog.LevelDebug,\n\t})\n\thandler := &amp;ContextHandler{Handler: baseHandler}\n\tjsonLogger := slog.New(handler)\n\tslog.SetDefault(jsonLogger)\n\n\t// 使用 gin.New() 而不是 gin.Default()，避免内置日志干扰\n\tr := gin.New()\n\tr.Use(SlogMiddleware())\n\tr.Use(SlogRecovery())\n\n\tr.GET(\"/ping\", func(c *gin.Context) {\n\t\tslog.InfoContext(c.Request.Context(), \"Processing /ping request\",\n\t\t\tslog.String(\"user\", \"zhangsan\"),\n\t\t)\n\n\t\ttime.Sleep(time.Second * 2)\n\t\tc.JSON(200, gin.H{\"msg\": \"pong\"})\n\t})\n\n\tr.GET(\"/panic\", func(c *gin.Context) {\n\t\tslog.InfoContext(c.Request.Context(), \"About to panic\")\n\t\tpanic(\"something went wrong\")\n\t})\n\n\tr.Run(\":8080\")\n}\n</code></pre>\n<p>运行后测试：</p>\n<pre><code class=\"language-shell\">$ curl http://localhost:8080/ping\n{\"msg\":\"pong\"}\n\n$ curl http://localhost:8080/panic\n{\"code\":500,\"msg\":\"Internal Server Error\",\"data\":null,\"timestamp\":\"2026-02-15T14:30:00+08:00\",\"trace_id\":\"xxx-xxx-xxx\"}\n</code></pre>\n<h2 id=\"日志输出文件\">日志输出文件</h2>\n<p>写日志文件一定要注意控制日志文件大小，建议配合系统的logrotate。如果服务运行在kubernetes，建议只输出控制台日志，由专门的日志收集平台去获取控制台日志。</p>\n<h3 id=\"基本实现\">基本实现</h3>\n<p>写到<code>app.log</code>中</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n)\n\nfunc main() {\n\tlogFile, err := os.OpenFile(\"app.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\thandler := slog.NewJSONHandler(logFile, nil)\n\tlogger := slog.New(handler)\n\tslog.SetDefault(logger)\n\n\tslog.Info(\"hello world\")\n\n}\n</code></pre>\n<p>配合logrotate。在 <code>/etc/logrotate.d/myapp</code> 创建配置文件</p>\n<pre><code>/path/to/app.log {\n    daily\n    rotate 7\n    compress\n    delaycompress\n    missingok\n    notifempty\n    copytruncate    # 复制后截断，不需要重启 Go 程序\n}\n</code></pre>\n<h3 id=\"使用lumberjack轮转日志文件\">使用lumberjack轮转日志文件</h3>\n<p>如果不想用系统的 <code>logrotate</code> ，可以使用 <code>lumberjack</code> 包，它提供了更灵活的日志轮转策略。</p>\n<pre><code class=\"language-go\">import \"gopkg.in/natefinch/lumberjack.v2\"\n\nfunc initLumberjack() {\n    rollingFile := &amp;lumberjack.Logger{\n        Filename:   \"./logs/app.log\",\n        MaxSize:    100, // 单位 MB\n        MaxBackups: 3,   // 保留旧文件的最大个数\n        MaxAge:     28,  // 保留旧文件的最大天数\n        Compress:   true, // 是否压缩\n    }\n\n    handler := slog.NewJSONHandler(rollingFile, nil)\n    slog.SetDefault(slog.New(handler))\n}\n</code></pre>\n<h3 id=\"同时输出控制台和日志文件\">同时输出控制台和日志文件</h3>\n<p>go1.26 版本后实现了<code>slog.NewMultiHandler</code>，1.26 前可使用<code>io.multiwriter</code>。</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n)\n\nfunc main() {\n\tlogFile, err := os.OpenFile(\"app.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfileHandler := slog.NewJSONHandler(logFile, nil)\n\tconsoleHandler := slog.NewTextHandler(os.Stdout, nil)\n\tmultiHandler := slog.NewMultiHandler(fileHandler, consoleHandler) // slog.NewMultiHandler 需要go1.26.0+版本\n\tlogger := slog.New(multiHandler)\n\tslog.SetDefault(logger)\n\n\tslog.Info(\"hello world\")\n\n}\n</code></pre>\n<h2 id=\"自定义日志级别\">自定义日志级别</h2>\n<p>除了四个内置级别，<code>slog</code> 还支持自定义日志级别 (一般来说默认的日志级别已经够用了)：</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n)\n\nfunc main() {\n\t// 定义自定义日志级别\n\tconst (\n\t\tLevelTrace   = slog.Level(-8) // 比 Debug 更低\n\t\tLevelNotice  = slog.Level(2)  // 介于 Info 和 Warn 之间\n\t\tLevelFatal   = slog.Level(12) // 比 Error 更高\n\t)\n\n\tlogger := slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{\n\t\tLevel: LevelTrace, // 设置最低级别\n\t}))\n\n\tlogger.Log(nil, LevelTrace, \"trace message\")\n\tlogger.Log(nil, LevelNotice, \"notice message\")\n\tlogger.Log(nil, LevelFatal, \"fatal message\")\n}\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p><code>slog</code> 作为 Go 官方的结构化日志库，用起来还是挺方便的。对于新项目，推荐直接使用 <code>slog</code>；对于已有项目，可以逐步迁移，<code>slog</code> 的 API 设计使得迁移成本很低。</p>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/XY-Heruo/\" target=\"_blank\">花酒锄作田</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/XY-Heruo/p/19618220\" target=\"_blank\">https://www.cnblogs.com/XY-Heruo/p/19618220</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 15:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/XY-Heruo\">花酒锄作田</a>&nbsp;\n阅读(<span id=\"post_view_count\">34</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "凸优化数学基础笔记（二）：二次型与正定矩阵",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19618211",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19618211\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 15:39\">\n    <span>凸优化数学基础笔记（二）：二次型与正定矩阵</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        二次型理论在凸优化问题设计中应用十分广泛。应用矩阵乘法运算，二次型与实对称矩阵紧密地联系在一起，从而二次型的基本问题又可以转换为实对称矩阵问题。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>​       为了便于学习最优化方法，本系列笔记的前几章部分将与优化方法密切相关的数学基础知识作一简要介绍，本系列介绍凸优化中常用矩阵概念：二次型与正定矩阵。</p>\n<p>​       二次型理论在凸优化问题设计中应用十分广泛。应用矩阵乘法运算，二次型与实对称矩阵紧密地联系在一起，从而二次型的基本问题又可以转换为实对称矩阵问题。</p>\n<h2 id=\"1-二次型\">1. 二次型</h2>\n<p>​        二次型理论问题起源于化二次曲线和二次曲面的方程为标准形式的问题。推广到<span class=\"math inline\">\\(n\\)</span>维空间中，二次超曲面的一般方程为：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\nf(x_1,x_2,x_3,...,x_n)=&amp;a_{11}x_1^2+a_{12}x_1x_2+...+a_{1n}x_1x_n+\\\\\n&amp;a_{21}x_1x_2+a_{22}x_2^{2}+...+a_{2n}x_2x_n+\\\\\n&amp;....\\\\\n&amp;a_{n1}x_nx_1+a_{n2}x_nx_2+...+a_{nn}x_n^2\\\\\n&amp;=\\sum_{i=1}^{n}\\sum_{j=1}^{n}a_{ij}x_ix_j\n\\end{aligned}\n\\tag{1}\n\\]</div><p></p><p>用矩阵表示可简记为：</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\nf(x_1,x_2,...,x_n)&amp;=(x_1,x_2,x_3,...x_n)\\left(\\begin{matrix}a_{11},a_{12},...a_{1n}\\\\ \na_{21},a_{22},...,a_{2n}\\\\\na_{n1},a_{n2},...,a_{nn}\n\\end{matrix}\\right)\\left(\\begin{matrix}x_1\\\\x_2\\\\...\\\\x_n\\end{matrix}\\right)\\\\\n&amp;=\\mathbf{x}^T\\mathbf{A}\\mathbf{x}\n\\end{aligned}\n\\tag{2}\n\\]</div><p></p><p>其中，<span class=\"math inline\">\\(x=[x_1,x_2,...,x_n]^{T}\\)</span>,矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的元素<span class=\"math inline\">\\(a_{ij}=a_{ji}\\)</span>正是二次型的<span class=\"math inline\">\\(x_ix_j\\)</span>项的系数的一半，因此二次型和它的矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 是相互唯一决定的，且<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{A}^{T}\\)</span>.</p>\n<h2 id=\"2-正定矩阵\">2. 正定矩阵</h2>\n<p><strong>定义1 正定矩阵的定义</strong></p>\n<p>​    如果二次型</p>\n<p></p><div class=\"math display\">\\[f(x_1,x_2,...,x_n)= \\sum_{i=1}^{n}\\sum_{j=1}^{n}a_{ij}x_ix_j=\\mathbf{x}^T\\mathbf{A}\\mathbf{x} \\tag{3}\n\\]</div><p></p><p>对于任何一组元素不全为0的向量<span class=\"math inline\">\\(\\mathbf{x}=[x_1,x_2,x_3,...,x_n]^T\\)</span>, 恒有<span class=\"math inline\">\\(f(x_1,x_2,x_3,...,x_n)=\\mathbf{x}^T\\mathbf{A}\\mathbf{x}&gt;0\\)</span> ,则称二次型<span class=\"math inline\">\\(f(x_1,x_2,...x_n)\\)</span>为<strong>正定</strong>，且称为二次型矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 也称为<strong>正定的</strong>，其简记为<span class=\"math inline\">\\(\\mathbf{A}\\succ0\\)</span>.</p>\n<p>​      简而言之，一个对称矩阵的<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 如果是正定的，则其二次型<span class=\"math inline\">\\(f(x_1,x_2,...x_n)=\\mathbf{x}^{T}\\mathbf{A}\\mathbf{x}\\)</span> 对于所有非零向量<span class=\"math inline\">\\(\\mathbf{x}\\)</span> 其值总为正。 类似地，可以给出定义，若二次型<span class=\"math inline\">\\(f(x_1,x_2,...,x_n)=\\mathbf{x}^T\\mathbf{A}\\mathbf{x}\\geq0\\)</span> ，则<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 为<strong>半正定矩阵</strong>，定义为<span class=\"math inline\">\\(\\mathbf{A}\\succeq{0}\\)</span> ; 若<span class=\"math inline\">\\(\\mathbf{x}^{T}\\mathbf{A}\\mathbf{x}\\leq0\\)</span>，则<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 为<strong>负定矩阵</strong>，简记为<span class=\"math inline\">\\(\\mathbf{A}\\preceq{0}\\)</span>；若二次型<span class=\"math inline\">\\(\\mathbf{x}^T\\mathbf{A}\\mathbf{x}\\)</span>  既不是半正定的，也不是半负定的，就称为矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 为<strong>不定的</strong>。</p>\n<p>​       矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span>为正定的的充要条件是它的行列式的 <span class=\"math inline\">\\(\\det(\\mathbf{A})\\)</span> 顺序主子式全部大于零，即：</p>\n<p></p><div class=\"math display\">\\[a_{11}&gt;0,\\left|\\begin{matrix}a_{11},a_{12}\\\\ a_{21},a_{22}\\end{matrix}\\right|&gt;0,\\left|\\begin{matrix}a_{11}，&amp;a_{12}，...,a_{1n}\\\\ a_{21},&amp;a_{22},...,a_{2n}\\\\ ...,&amp;...\\\\a_{n1},&amp;a_{n2},..., a_{nn}\\end{matrix}\\right|\n\\tag{4}\n\\]</div><p></p><p>由此可见，正定矩阵必然是非奇异的。 由此总结：对于实对称矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span>，下面几个命题之间是互相等价的：</p>\n<ol>\n<li><span class=\"math inline\">\\(\\mathbf{A}\\)</span>是正定矩阵；</li>\n<li><span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的所有主子式都是正数；</li>\n<li><span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的各级顺序主子式都是正数；</li>\n</ol>\n<p>下面我们简单讨论以下的正定矩阵的特征值性质：</p>\n<p><strong>性质1：</strong>实对称矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 是正定矩阵等价于<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的特征值全是正数。</p>\n<p>证明：记<span class=\"math inline\">\\(\\lambda\\)</span>为<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的一个特征值<span class=\"math inline\">\\(\\lambda\\)</span> , <span class=\"math inline\">\\(\\mathbf{v}\\)</span> 是对应于<span class=\"math inline\">\\(\\lambda\\)</span> 的一个特征向量，于是 <span class=\"math inline\">\\(\\mathbf{A}\\mathbf{v}=\\lambda\\mathbf{v}\\)</span> ，进而得到如下的</p>\n<p></p><div class=\"math display\">\\[\\lambda|\\mathbf{v}|^2=\\mathbf{v}^T\\mathbf{A}\\mathbf{v} \\tag{5}\n\\]</div><p></p><p>又因为 <span class=\"math inline\">\\(|\\alpha|^2&gt;0\\)</span>，于是 <span class=\"math inline\">\\(\\lambda&gt;0\\)</span>。</p>\n<p>若<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的任一特征值都是正数，则对于任一非零向量<span class=\"math inline\">\\(\\mathbf{v}\\)</span> ，均有<span class=\"math inline\">\\(\\mathbf{v}^T\\mathbf{A}\\mathbf{v}&gt;0\\)</span>, 于是<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 为正定矩阵。</p>\n<p><strong>性质2：</strong> 若实对称矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span>是正定矩阵，则存在唯一的正定矩阵<span class=\"math inline\">\\(\\mathbf{S}\\)</span>，是使得<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{S}^2\\)</span>。</p>\n<p>证明：存在性，由于<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 是正定矩阵，由此存在正交矩阵<span class=\"math inline\">\\(\\mathbf{Q}\\)</span> 使得：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}=\\mathbf{Q}\\mathbf{D}\\mathbf{Q}^T  \\tag{6}\n\\]</div><p></p><p>其中：<span class=\"math inline\">\\(\\mathbf{D}=dialog(\\lambda_1,\\lambda_2,....,\\lambda_n)\\)</span>，其中<span class=\"math inline\">\\(\\lambda_i\\)</span> 为矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的特征值，由于 <span class=\"math inline\">\\(\\lambda_i&gt;0\\)</span>，于是正定矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span>可以写为如下：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}=\\mathbf{Q}\\begin{bmatrix}&amp;\\sqrt\\lambda_1&amp; &amp; &amp;\\\\&amp; &amp;\\sqrt\\lambda_2 &amp; &amp;\\\\ &amp; &amp; &amp;\\cdots &amp; \\\\ &amp; &amp; &amp; &amp;\\sqrt\\lambda_n\\end{bmatrix}\\mathbf{Q}^T\\mathbf{Q}\\begin{bmatrix}&amp;\\sqrt\\lambda_1&amp; &amp; &amp;\\\\&amp; &amp;\\sqrt\\lambda_2 &amp; &amp;\\\\ &amp; &amp; &amp;\\cdots &amp; \\\\ &amp; &amp; &amp; &amp;\\sqrt\\lambda_n\\end{bmatrix}\\mathbf{Q}^T \\tag{7}\n\\]</div><p></p><p>记 <span class=\"math inline\">\\(\\mathbf{S}\\)</span>:</p>\n<p></p><div class=\"math display\">\\[\\mathbf{S}=\\mathbf{Q}\\begin{bmatrix}&amp;\\sqrt\\lambda_1&amp; &amp; &amp;\\\\&amp; &amp;\\sqrt\\lambda_2 &amp; &amp;\\\\ &amp; &amp; &amp;\\cdots &amp; \\\\ &amp; &amp; &amp; &amp;\\sqrt\\lambda_n\\end{bmatrix}\\mathbf{Q}^T  \\tag{8}\n\\]</div><p></p><p>即有<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{S}^2\\)</span> 。由于 <span class=\"math inline\">\\(\\mathbf{S}\\)</span>的特征值<span class=\"math inline\">\\(\\sqrt{\\lambda_i}\\)</span> 均为正数，因此<span class=\"math inline\">\\(\\mathbf{S}\\)</span> 也是正定矩阵。</p>\n<p>唯一性：假设存在两个正定矩阵<span class=\"math inline\">\\(\\mathbf{S}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{S}_2\\)</span> ，满足：</p>\n<p></p><div class=\"math display\">\\[\\mathbf{A}=\\mathbf{S}_1^2=\\mathbf{S}_2^2 \\tag{9}\n\\]</div><p></p><p>需要证明<span class=\"math inline\">\\(\\mathbf{S}_1=\\mathbf{S}_2\\)</span> 。这里采用特征值分解的几何意义来证明：</p>\n<ol>\n<li>特征值关系：设<span class=\"math inline\">\\(\\lambda\\)</span>是<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的任意一个特征值，<span class=\"math inline\">\\(\\mu\\)</span> 是<span class=\"math inline\">\\(\\mathbf{S}_1\\)</span> 的对应特征值，则 <span class=\"math inline\">\\(\\mu^2=\\lambda\\)</span>。由于正定矩阵的特征值均为正数，因此<span class=\"math inline\">\\(\\mu\\)</span> 必须取正值<span class=\"math inline\">\\(\\sqrt{\\lambda}\\)</span>。同理，<span class=\"math inline\">\\(\\mathbf{S}_2\\)</span>对应于同一特征值<span class=\"math inline\">\\(\\lambda\\)</span> 的特征值也必然是<span class=\"math inline\">\\(\\sqrt{\\lambda}\\)</span> 。因此，<span class=\"math inline\">\\(\\mathbf{S}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{S}_2\\)</span> 的特征值完全相同。</li>\n<li>特征值子空间关系：令<span class=\"math inline\">\\(\\{\\lambda_1,\\lambda_2,\\cdots,\\lambda_s\\}\\)</span> 为<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 的全体互异特征值，设 <span class=\"math inline\">\\(\\mathbf{V}_i\\)</span> 为<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 关于特征值<span class=\"math inline\">\\(\\lambda_i\\)</span> 的特征子空间。\n<ul>\n<li>因为 <span class=\"math inline\">\\(\\mathbf{S}_1^{2}=\\mathbf{A}\\)</span>，若<span class=\"math inline\">\\(\\mathbf{x}\\in{\\mathbf{V}_i}\\)</span> ，则<span class=\"math inline\">\\(\\mathbf{A}\\mathbf{x}=\\lambda_i\\mathbf{x}\\)</span>，代入得<span class=\"math inline\">\\(\\mathbf{S}_1^2\\mathbf{x}=\\lambda_i\\mathbf{x}\\)</span> 。这说明<span class=\"math inline\">\\(\\mathbf{x}\\)</span> 同时也是<span class=\"math inline\">\\(\\mathbf{S}_1^2\\)</span> 的特征向量。通过谱映射定理可知，<span class=\"math inline\">\\(\\mathbf{x}\\)</span> 属于<span class=\"math inline\">\\(\\mathbf{S}_1\\)</span> 关于特征值<span class=\"math inline\">\\(\\sqrt{\\lambda_i}\\)</span> 的特征子空间。</li>\n<li>即<span class=\"math inline\">\\(\\mathbf{A}\\)</span>的特征子空间<span class=\"math inline\">\\(\\mathbf{V}_i\\)</span> 恰好就是 <span class=\"math inline\">\\(\\mathbf{S}_1\\)</span> 关于特征值<span class=\"math inline\">\\(\\sqrt{\\lambda_i}\\)</span> 的特征子空间。</li>\n</ul>\n</li>\n<li>唯一确定：同样的推理也适用于<span class=\"math inline\">\\(\\mathbf{S}_2\\)</span>。因此，<span class=\"math inline\">\\(\\mathbf{S}_1\\)</span>和<span class=\"math inline\">\\(\\mathbf{S}_2\\)</span> 具有完全相同的特征值（都是<span class=\"math inline\">\\(\\sqrt{\\lambda_i}\\)</span>）和完全相同的特征子空间（都是<span class=\"math inline\">\\(\\mathbf{V}_i\\)</span>）。对于一个实对称矩阵的矩阵（可正交对角化），它的特征值和特征子空间唯一决定了矩阵本身。因此，<span class=\"math inline\">\\(\\mathbf{S}_1=\\mathbf{S}_2\\)</span>。</li>\n</ol>\n<p>综上所述，实对称正定矩阵<span class=\"math inline\">\\(\\mathbf{A}\\)</span> 存在唯一的正定平方根<span class=\"math inline\">\\(\\mathbf{S}\\)</span>，使得<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{S}^2\\)</span>。</p>\n<p><strong>性质2</strong>：若<span class=\"math inline\">\\(\\mathbf{A},\\mathbf{B}\\)</span> 都是<span class=\"math inline\">\\(n\\times{n}\\)</span>正定矩阵，则<span class=\"math inline\">\\(\\mathbf{AB}\\)</span> 的特征值都是正数。</p>\n<p>证明：由于<span class=\"math inline\">\\(\\mathbf{A},\\mathbf{B}\\)</span> 为正定矩阵，于是根据性质2可知，存在正定矩阵<span class=\"math inline\">\\(\\mathbf{C}\\)</span> 满足<span class=\"math inline\">\\(\\mathbf{A}=\\mathbf{C}^2\\)</span>。下面考虑矩阵<span class=\"math inline\">\\(\\mathbf{C}^{-1}\\mathbf{A}\\mathbf{B}\\mathbf{C}\\)</span>。注意到：</p>\n<p></p><div class=\"math display\">\\[(\\mathbf{C}^{-1}\\mathbf{AB}\\mathbf{C})^T=\\mathbf{CABC^{-1}}=\\mathbf{CBC}=\\mathbf{C}^{-1}\\mathbf{AB}\\mathbf{C} \\tag{10}\n\\]</div><p></p><p>于是<span class=\"math inline\">\\(\\mathbf{C}^{-1}\\mathbf{ABC}\\)</span> 是一个实对称矩阵，又因为存在正定矩阵<span class=\"math inline\">\\(\\mathbf{D}\\)</span> 满足<span class=\"math inline\">\\(\\mathbf{B}=\\mathbf{D}^2\\)</span>。于是对于任一个非零的向量<span class=\"math inline\">\\(\\boldsymbol{\\alpha}\\in\\mathbb{R}^n\\)</span>.</p>\n<p></p><div class=\"math display\">\\[\\boldsymbol{\\alpha}^T\\mathbf{C}^{-1}\\mathbf{ABC}\\boldsymbol{\\alpha}=\\boldsymbol{\\alpha}^T\\mathbf{C}\\mathbf{B}\\mathbf{C}\\boldsymbol{\\alpha}=(\\mathbf{DC}\\boldsymbol{\\alpha},\\mathbf{DC}\\boldsymbol{\\alpha})\\geq0\\tag{11}\n\\]</div><p></p><p>上面不等式的等号不成立，应为，<span class=\"math inline\">\\(\\mathbf{DC}\\)</span> 为满秩矩阵，进而 <span class=\"math inline\">\\(\\mathbf{DC}\\boldsymbol{\\alpha}\\neq{0}\\)</span>。因此，<span class=\"math inline\">\\(\\mathbf{C}^{-1}\\mathbf{ABC}\\)</span> 是正定矩阵，于是它的所有特征值也是正数。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 15:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">25</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "OpenEuler 20.03æž„å»ºzabbix8.0 rpmåŒ",
      "link": "https://www.cnblogs.com/virtualzzf/p/19617629",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/virtualzzf/p/19617629\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 10:46\">\n    <span>OpenEuler 20.03构建zabbix8.0 rpm包</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        OpenEuler 20.03自行构建zabbix8.0 rpm包\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"一说明\">一、说明</h1>\n<h2 id=\"为什么要自己构建\">为什么要自己构建？</h2>\n<p>由于centos从7版本之后改为stream，工作环境由centos转向OpenEuler。zabbix官网上有各大主流操作系统预编译的rpm包，但是Openeuler相对小众，自然没有制作好的包。即使是centos系统，7版本也过于陈旧了，从zabbix 6.0开始，centos 7已经不提供server的rpm包了，只剩下proxy和agent，到了7.0版本，连proxy都没有了。学会自己创建rpm包，以备操作系统环境发生改变是非常有必要的。</p>\n<h2 id=\"为什么不直接源代码编译\">为什么不直接源代码编译</h2>\n<ol>\n<li>由于采用的是sever-proxy-agent的多层架构，server只有一台，但是proxy有几十台，agent更是上千，每一台都用源代码编译工作量大大增加。</li>\n<li>源代码编译的软件，在一些例如配置文件、启停命令上与rpm版本有差异，如果混布增加了运维复杂度。</li>\n</ol>\n<h2 id=\"有没有预编译好的rpm包\">有没有预编译好的rpm包</h2>\n<p>在OpenEuler的官方社区的软件中心，有社区成员自行构建的rpm包，可以尝试找找有无符合自己要求的版本。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<h1 id=\"二准备工作\">二、准备工作</h1>\n<h2 id=\"21-添加repo源\">2.1 添加repo源</h2>\n<p>如果OpenEuler缺少默认的repo源，需要自己添加<br />\n在/etc/yum.repos.d/openEuler_x86_64.repo中添加如下内容：</p>\n<pre><code>[OS]\nname=openEuler-$releasever - OS\nbaseurl=https://repo.openeuler.openatom.cn/openEuler-20.03-LTS-SP4/OS/$basearch/\nenabled=1\ngpgcheck=1\ngpgkey=https://repo.openeuler.openatom.cn/openEuler-20.03-LTS-SP4/OS/$basearch/RPM-GPG-KEY-openEuler\n</code></pre>\n<p>另外再添加everything的源，可以提供更多的包。</p>\n<pre><code>dnf config-manager --add-repo https://repo.openeuler.org/openEuler-20.03-LTS/everything/x86_64\n</code></pre>\n<p>使用<code>dnf clean all &amp;&amp; dnf makecache</code>命令更新。</p>\n<h2 id=\"22-准备构建rpm包环境\">2.2 准备构建rpm包环境</h2>\n<p>之前的文章里已经介绍了构建rpm包的基本方法，这里不再赘述。root用户下运行命令如下：</p>\n<pre><code>dnf install -y rpm-build\ndnf install -y rpmdevtools\nrpmdev-setuptree\n</code></pre>\n<p>下载srpm包（ <a href=\"http://repo.zabbix.com/zabbix/7.0/rhel/8/SRPMS/zabbix-7.0.23-release1.el8.src.rpm\" rel=\"noopener nofollow\" target=\"_blank\">http://repo.zabbix.com/zabbix/7.0/rhel/8/SRPMS/zabbix-7.0.23-release1.el8.src.rpm</a> ） ，这里以rhel8版本的srpm文件为例：</p>\n<pre><code>rpm -ivh zabbix-7.0.23-release1.el8.src.rpm\n</code></pre>\n<p>此时，在/root/rpmbuild目录下的SOURCES目录下会产生源代码压缩包、补丁和配置文件，SPECS目录会产生spec文件。但是此spec文件是Centos8版本的，与OpenEuler不完全契合，需要修改一下。</p>\n<h1 id=\"三安装依赖包\">三、安装依赖包</h1>\n<h2 id=\"31-buildrequires要求的依赖包\">3.1 BuildRequires要求的依赖包</h2>\n<table>\n<thead>\n<tr>\n<th>依赖包</th>\n<th>要求的版本</th>\n<th>dnf安装的版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>make</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mariadb-connector-c-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>postgresql-devel</td>\n<td>&gt;= 12.0</td>\n<td>10.5</td>\n</tr>\n<tr>\n<td>sqlite-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>net-snmp-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>openldap-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>unixODBC-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>curl-devel</td>\n<td>&gt;= 7.13.1</td>\n<td>7.66.0</td>\n</tr>\n<tr>\n<td>OpenIPMI-devel</td>\n<td>&gt;= 2</td>\n<td>2.0.29</td>\n</tr>\n<tr>\n<td>libssh-devel</td>\n<td>&gt;= 0.9.0</td>\n<td>0.9.4</td>\n</tr>\n<tr>\n<td>java-devel（java-1.8.0-openjdk-devel）</td>\n<td>&gt;= 1.6.0</td>\n<td>1.8.0.392.b08</td>\n</tr>\n<tr>\n<td>libxml2-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>libevent-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pcre2-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>openssl-devel</td>\n<td>&gt;= 1.0.1</td>\n<td>1.1.1f</td>\n</tr>\n<tr>\n<td>systemd</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>policycoreutils-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>selinux-policy-devel</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>c-ares-devel</td>\n<td>&gt;= 1.19.0</td>\n<td>1.16.1</td>\n</tr>\n<tr>\n<td>安装全部依赖：</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<pre><code>dnf install -y make mariadb-connector-c-devel postgresql-devel sqlite-devel net-snmp-devel openldap-devel unixODBC-devel curl-devel OpenIPMI-devel libssh-devel java-1.8.0-openjdk-devel libxml2-devel libevent-devel pcre2-devel openssl-devel systemd policycoreutils-devel selinux-policy-devel c-ares-devel\n</code></pre>\n<h2 id=\"32-golang配置\">3.2 golang配置</h2>\n<h3 id=\"版本更新\">版本更新</h3>\n<p>zabbix agent2和web_service是使用GO语言编写的，并且使用的语法对版本还有要求，OpenEuler 20.03默认repo源的版本为1.15，需要安装一个较新版本的。<br />\n首先下载golang的压缩包并解压</p>\n<pre><code>tar -C /usr/local -xzf go1.24.8.linux-amd64.tar.gz\n</code></pre>\n<p>配置PATH变量并生效</p>\n<pre><code>tee /etc/profile.d/go.sh &lt;&lt;EOL\nexport GO_HOME=/usr/local/go\nexport PATH=\\$PATH:\\$GO_HOME/bin\nEOL\nsource /etc/profile\n</code></pre>\n<p>使用<code>go version</code>命令查看更新是否生效</p>\n<h3 id=\"配置代理\">配置代理</h3>\n<p>在构建中，会自动下载go的工具链（toolchain），但是由于网络缘故，无法访问默认的代理地址（proxy.golang.org），导致构建失败<br />\n使用命令<code>go env -w GOPROXY=https://goproxy.cn,direct</code>，改用七牛云的goproxy<br />\n使用命令<code>go env GOPROXY</code>测试是否生效。</p>\n<h1 id=\"四修改spec文件\">四、修改spec文件</h1>\n<p>修改好的spec文件见：<a href=\"https://files.cnblogs.com/files/blogs/745793/zabbix.zip?t=1771123185&amp;download=true\" target=\"_blank\">https://files.cnblogs.com/files/blogs/745793/zabbix.zip?t=1771123185&amp;download=true</a></p>\n<h2 id=\"41-删除rhel和amzn宏\">4.1 删除%{rhel}和%{?amzn}宏</h2>\n<p>%{rhel}和%{?amzn}两个宏分别标识了redhat和amazon系linux的大版本号，用于构建时一些配置方式的选择。由于这两个宏在OpenEuler中为空，在spec文件中会被全局定义为0，直接使用会影响构建，需要全部进行处理。<br />\n与OpenEuler相对接近的是Centos8，把%{?rhel}当做“8”处理，%{?amzn}直接删除。</p>\n<h3 id=\"示例1\">示例1</h3>\n<pre><code>%if ( 0%{?rhel} &gt;= 7 &amp;&amp; 0%{?amzn} == 0 ) || 0%{?amzn} &gt;= 2023\n%{!?build_agent2: %global build_agent2 1}\n%endif\n</code></pre>\n<p>由于08 &gt;= 7，修改为</p>\n<pre><code>%{!?build_agent2: %global build_agent2 1}\n</code></pre>\n<h3 id=\"示例2\">示例2</h3>\n<pre><code>%if 0%{rhel} &gt;= 9 || 0%{?amzn} &gt;= 2023\nBuildRequires: selinux-policy-devel\nBuildRequires: c-ares-devel &gt;= 1.19.0\n%endif\n</code></pre>\n<p>由于不满足 08 &gt;= 9 ，直接删除</p>\n<h2 id=\"42-修改buildrequires版本要求\">4.2 修改BuildRequires版本要求</h2>\n<p>官网repo源的postgresql-devel版本不达标，直接进行构建会报错。<br />\npostgresql官网没有OpenEuler的预编译rpm包，想要满足要求必须自行从源代码进行编译。<br />\n本文仅为演示，将<code>postgresql-devel &gt;= 12.0</code>修改为<code>postgresql-devel</code></p>\n<h1 id=\"五构建\">五、构建</h1>\n<p>使用<code>rpmbuild -bb zabbix.spec</code>命令进行构建，需要比较长的时间。<br />\n完成后在/root/rpmbuild/RPMS目录下就会生成编译好的rpm包。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 10:46</span>&nbsp;\n<a href=\"https://www.cnblogs.com/virtualzzf\">virtualzzf</a>&nbsp;\n阅读(<span id=\"post_view_count\">47</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为什么现代 C++ 库都用 PIMPL？一场关于封装、依赖与安全的演进",
      "link": "https://www.cnblogs.com/charlee44/p/19616660",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/charlee44/p/19616660\" id=\"cb_post_title_url\" title=\"发布于 2026-02-14 21:27\">\n    <span>为什么现代 C++ 库都用 PIMPL？一场关于封装、依赖与安全的演进</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        系统阐述了在 C++ 工程中如何通过 PIMPL 惯用法，在坚守 RAII 资源安全的前提下，有效解耦头文件依赖、提升编译效率并保持接口简洁。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>在 C++ 的工程实践中，如何在保证资源安全管理的同时，又避免头文件污染和不必要的编译依赖？这个问题贯穿了现代 C++ 库设计的核心。本文将沿着一条清晰的技术演进路径，探讨从 RAII 封装出发，历经值语义、裸指针、智能指针等阶段，最终走向 PIMPL（Pointer to Implementation） 这一成熟且优雅的解决方案。</p>\n</blockquote>\n<h1 id=\"1-raii资源管理的基石\">1. RAII——资源管理的基石</h1>\n<p>C++ 的核心哲学之一是 RAII（Resource Acquisition Is Initialization）：资源（内存、文件句柄、网络连接等）的生命周期应由对象的构造与析构自动管理。例如：</p>\n<pre><code class=\"language-cpp\">class FileHandle {\n    FILE* fp;\npublic:\n    FileHandle(const char* path) : fp(fopen(path, \"r\")) {}\n    ~FileHandle() { if (fp) fclose(fp); }\n};\n</code></pre>\n<p>RAII 让资源管理变得安全：利用类对象的生命周期，在构造函数中申请资源，在析构函数中释放资源。如果这个类对象是基于栈的值对象，那么就可以自动实现资源的管理。因此，在现代 C++ 中，相比传统的指针语义，更加提倡使用基于 RAII 的值语义。</p>\n<h1 id=\"2-值语义的诱惑与代价\">2. 值语义的诱惑与代价</h1>\n<p>但是，当我们把这种思想用于封装复杂组件（如 ONNX 模型会话、数据库连接池）时，问题出现了。理想情况下，我们希望像使用 std::string 一样，用“值语义”操作一个封装对象：</p>\n<pre><code class=\"language-cpp\">class Embedder {\n    Ort::Session session; // 值成员\npublic:\n    std::vector&lt;float&gt; embed(const std::string&amp; text);\n};\n</code></pre>\n<p>这看起来非常简洁、高效、符合现代 C++ 风格。但也有另外一个问题：破坏了封装，导致不必要的环境依赖。最直观的问题就是 <code>Ort::Session</code> 的完整定义必须出现在头文件中，这意味着使用者必须包含 onnxruntime ，而这个头文件可能重达数 MB ，依赖数十个系统库。这就会造成如下问题：</p>\n<ul>\n<li>编译时间暴增，微小的改动都需要编译很长的时间。</li>\n<li>头文件耦合严重，调用者使用不方便，甚至造成环境污染。</li>\n<li>ABI 极其脆弱，内部改动导致所有用户重编译。</li>\n</ul>\n<h1 id=\"3-指针语义的回退\">3. 指针语义的回退</h1>\n<p>为了解耦，一个比较好的办法就是使用前置声明 + 指针语义：</p>\n<pre><code class=\"language-cpp\">// header\nclass SessionImpl; // 前置声明\nclass Embedder {\n    SessionImpl* pimpl;\npublic:\n    Embedder();\n    ~Embedder(); // 必须手动 delete\n};\n</code></pre>\n<p>这样做确实切断了编译依赖，但也引入了新的问题。那就是需要按照 RAII 原则写好构造函数和析构函数。而一旦要写析构函数，也往往意味着需要写另外四个特殊的成员函数：</p>\n<ol>\n<li>拷贝构造函数（Copy Constructor）</li>\n<li>拷贝赋值运算符（Copy Assignment Operator）</li>\n<li>移动构造函数（Move Constructor）</li>\n<li>移动赋值运算符（Move Assignment Operator）</li>\n</ol>\n<p>这样做要写非常多的样板代码，而且也很容易出问题。为了封装牺牲安全，得不偿失。</p>\n<h1 id=\"4-使用智能指针\">4. 使用智能指针</h1>\n<p>使用裸指针又麻烦又不安全，那么就可以使用 C++11 引入的智能指针：std::unique_ptr 和 std::shared_ptr；智能指针同样是基于 RAII 的：</p>\n<pre><code class=\"language-cpp\">class SessionImpl;\nclass Embedder {\n    std::unique_ptr&lt;SessionImpl&gt; pimpl;\n};\n</code></pre>\n<p>这里为什么使用 <code>std::unique_ptr</code> 而不使用 <code>std::shared_ptr</code> 呢？其实也可以，不过在现代 C++ 中，更推荐使用 <code>std::unique_ptr</code> 。<code>std::shared_ptr</code> 是用来共享资源的所有权，会对引用资源进行计数，但是有可能会造成相互循环引用造成不能释放资源的问题；而<code>std::unique_ptr</code> 则表示独占资源的所有权，不仅开销更低（无引用计数），也更加安全（只能通过 <code>std::move</code> 转移所有权 ）。</p>\n<p>不过有一点需要注意：<code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 在处理不完整类型（incomplete type）时的行为截然不同。具体来说，当在头文件中使用前置声明（如 <code>class Impl;</code>）并用智能指针持有它时，<code>Impl</code> 是一个不完整类型。</p>\n<ul>\n<li><code>std::shared_ptr</code> 可以安全地在头文件中默认析构，因为它在构造时（通常在 <code>.cpp</code> 文件中）会捕获一个完整的删除器（deleter），即使析构发生在头文件上下文中，也能正确调用 <code>delete</code>。</li>\n<li>而 <code>std::unique_ptr</code> 的删除器是其类型的一部分（通常是默认的 <code>std::default_delete&lt;Impl&gt;</code>），它要求在析构点（即类的析构函数被实例化的地方）<code>Impl</code> 必须是完整类型。如果在头文件中写 <code>~Embedder() = default;</code>，此时 <code>Impl</code> 仍是不完整的，编译器可能不会报错，但会导致未定义行为（通常是链接失败或运行时崩溃）。</li>\n</ul>\n<p>因此，使用 <code>std::unique_ptr&lt;Impl&gt;</code> 时，必须将主类的析构函数定义移到 <code>.cpp</code> 文件中，确保 <code>Impl</code> 已被完整定义：</p>\n<pre><code class=\"language-cpp\">// Embedder.cpp\nclass Embedder::Impl {\n    // 完整定义...\n};\n\nEmbedder::~Embedder() = default; // ✅ 此时 Impl 完整，安全析构\n</code></pre>\n<h1 id=\"5-封装与效率的平衡pimpl\">5. 封装与效率的平衡：PIMPL</h1>\n<p>使用智能指针虽然好，但是总归是比不上值语义方便。当类中只有一个需要隐藏的成员还好，如果有很多个需要隐藏的成员，每一个都写前置声明，并用智能指针来管理，那就实在太繁琐了。并且，从编程品味上来说，C++ 智能指针的写法说不上优雅：智能指针是由传染性的，当满屏都是 <code>std::shared_ptr</code> 或者 <code>std::unique_ptr</code> 的时候，实在很影响阅读性。</p>\n<p>另外，作为对外的接口，最好是提供像 Java / C# 那样的接口，C++ 的纯虚函类也行，隐藏掉所有的细节，包括私有函数和数据成员。这样有非常多的好处：</p>\n<ol>\n<li>最小化依赖环境，提升编译速度。</li>\n<li>调用者使用方便，不会污染环境。</li>\n<li>ABI 稳定，可以只更新库而不用更新整个程序。</li>\n</ol>\n<p>那么要怎么进行优化呢？很简单，我们可以实现一个名为 <code>Impl</code> 的类中类 ，使用<code>std::unique_ptr</code>进行管理。<code>Impl</code> 是实现在 cpp 中的，可以将一切实现的细节，比说私有函数和数据成员，都放在这个 <code>Impl</code> 中。更重要的是，<code>Impl</code> 中的数据成员完全可以使用值类型！如下所示：</p>\n<pre><code class=\"language-cpp\">// 头文件\nclass Embedder {\n    class Impl;\n    std::unique_ptr&lt;Impl&gt; impl;\npublic:\n    Embedder(const std::string&amp; model);\n    ~Embedder(); // 声明但不在头文件定义！\n    std::vector&lt;float&gt; embed(std::string_view text) const;\n};\n</code></pre>\n<pre><code class=\"language-cpp\">// 源文件\nclass Embedder::Impl {\n    Ort::Session session;\n    hf::Tokenizer tokenizer;\n    int64_t dim;\npublic:\n    Impl(const std::string&amp; path, const hf::Tokenizer&amp; tok) \n        : session(...), tokenizer(tok) { /* init */ }\n    std::vector&lt;float&gt; embed(std::string_view text) const { /* ... */ }\n};\n\nEmbedder::Embedder(const std::string&amp; path) \n    : impl(std::make_unique&lt;Impl&gt;(path, global_tokenizer)) {}\n\nEmbedder::~Embedder() = default; // 此时 Impl 完整，安全！\n</code></pre>\n<p>这个实现，就是所谓的 PIMPL（Pointer to IMPLementation）惯用法，也常被称作 “编译防火墙”（Compilation Firewall） 或 “Opaque Pointer” 模式。不得不说，这种 PIMPL 设计模式确实精妙——它在安全性、封装性、编译效率与接口简洁性之间取得了近乎完美的平衡，既坚守了 RAII 的资源管理原则，又有效隔离了实现细节，堪称现代 C++ 工程实践中“高内聚、低耦合”的典范。</p>\n<h1 id=\"6-没有银弹只有权衡\">6. 没有银弹，只有权衡</h1>\n<p>PIMPL 使用了前置声明。是否使用前置声明一直是 C++ 中比较争议的一点，Qt 遵循前置声明的原则实现了非常强大、优雅且高效的 C++ 运行时框架。Google 则经历了从推荐使用前置声明到不推荐使用前置声明的转变。个人认为，PIMPL 解决的就是 C++ 中两个重要原则矛盾的问题：</p>\n<ul>\n<li>推荐使用值语义，但是会引入更多环境依赖</li>\n<li>封装需要尽可能隐藏不必要的细节</li>\n</ul>\n<p>如果两者只能选择其中一个，那么还是尽量使用值语义的原则更加重要，毕竟这涉及到安全问题，而资源管理的安全问题贯穿 C++ 程序的始终。事实上，如果不是提供对外接口，或者实现比较小，那么直接使用值语义即可（第2节中的内容）——值语义永远是最简洁安全的实现。</p>\n<p>另外，如果实现 C++20 Modules ，那么就不必要使用 PIMPL 了，完全可以回归值语义实现，因为 C++20 Modules 在语言层面已经实现了 PIMPL 的诸多优点。</p>\n<h1 id=\"7-示例代码\">7. 示例代码</h1>\n<p>最后放出笔者自己实现的基于 PIMPL 的嵌入器的完整代码供读者参考：</p>\n<pre><code class=\"language-cpp\">// BgeOnnxEmbedder.h\n#pragma once\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace embedding {\n\nnamespace hf {\nclass Tokenizer;\n}\n\nclass BgeOnnxEmbedder {\n public:\n  explicit BgeOnnxEmbedder(const std::string&amp; modelPath,\n                           const hf::Tokenizer&amp; tokenizer);\n  ~BgeOnnxEmbedder();\n\n  const int64_t&amp; EmbeddingDim() const;\n\n  std::vector&lt;float&gt; Embed(const std::string&amp; text) const;\n\n private:\n  class Impl;  // 前向声明\n  std::unique_ptr&lt;Impl&gt; impl;\n};\n\n}  // namespace embedding\n</code></pre>\n<pre><code class=\"language-cpp\">//BgeOnnxEmbedder.cpp\n#include \"BgeOnnxEmbedder.h\"\n\n#include &lt;onnxruntime_cxx_api.h&gt;\n\n#include \"HfTokenizer.h\"\n#include \"Util/StringEncode.h\"\n\nnamespace embedding {\n\nclass BgeOnnxEmbedder::Impl {\n public:\n  Ort::Env&amp; GetOrtEnv() {\n    static Ort::Env env(ORT_LOGGING_LEVEL_WARNING, \"BgeOnnxEmbedder\");\n    return env;\n  }\n\n  const int64_t&amp; EmbeddingDim() const { return embeddingDim; }\n\n  explicit Impl(const std::string&amp; modelPath, const hf::Tokenizer&amp; tokenizer)\n      : session{GetOrtEnv(),\n#ifdef _WIN32\n                util::StringEncode::Utf8StringToWideString(modelPath).c_str(),\n#else\n                modelPath.c_str(),\n#endif\n                Ort::SessionOptions()},\n        memInfo{Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeCPU)},\n        tokenizer(tokenizer),\n        embeddingDim(0) {\n\n    //\n    const auto&amp; outputInfo = session.GetOutputTypeInfo(0);\n    const auto&amp; tensorInfo = outputInfo.GetTensorTypeAndShapeInfo();\n    const auto&amp; shape = tensorInfo.GetShape();\n\n    // 假设输出是 [batch, seq, dim] 或 [batch, dim]\n    // 我们取最后一个非 -1 的维度\n    for (auto it = shape.rbegin(); it != shape.rend(); ++it) {\n      if (*it != -1) {\n        embeddingDim = *it;\n        break;\n      }\n    }\n\n    if (embeddingDim == 0) {\n      throw std::runtime_error(\n          \"Failed to infer embedding dimension from ONNX model.\");\n    }\n  }\n\n  std::vector&lt;float&gt; Embed(const std::string&amp; text) const {\n    hf::Tokenizer::ResultPtr result = tokenizer.Encode(text);\n    if (!result) {\n      throw std::runtime_error(\"tokenizer_encode failed\");\n    }\n\n    // 定义张量维度\n    int64_t seqLen = static_cast&lt;int64_t&gt;(result-&gt;length);\n    std::vector&lt;int64_t&gt; inputShape = {1, seqLen};\n    size_t dataByteCount = sizeof(int64_t) * seqLen;\n\n    Ort::Value inputIdsTensor = Ort::Value::CreateTensor(\n        memInfo.GetConst(), result-&gt;input_ids, dataByteCount, inputShape.data(),\n        inputShape.size(),\n        ONNXTensorElementDataType::ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64);\n\n    Ort::Value attentionMaskTensor = Ort::Value::CreateTensor(\n        memInfo.GetConst(), result-&gt;attention_mask, dataByteCount,\n        inputShape.data(), inputShape.size(),\n        ONNXTensorElementDataType::ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64);\n\n    Ort::Value tokenTypeIdsTensor = Ort::Value::CreateTensor(\n        memInfo.GetConst(), result-&gt;token_type_ids, dataByteCount,\n        inputShape.data(), inputShape.size(),\n        ONNXTensorElementDataType::ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64);\n\n    // 输入名必须与模型定义一致\n    const char* inputNames[] = {\"input_ids\", \"attention_mask\",\n                                \"token_type_ids\"};\n    const char* outputNames[] = {\"last_hidden_state\"};\n\n    // 把三个输入张量放进数组\n    std::vector&lt;Ort::Value&gt; inputs;\n    inputs.push_back(std::move(inputIdsTensor));\n    inputs.push_back(std::move(attentionMaskTensor));\n    inputs.push_back(std::move(tokenTypeIdsTensor));\n\n    // 执行推理\n    auto outputs = session.Run(Ort::RunOptions(),  // 运行选项（通常 nullptr）\n                               inputNames,         // 输入名数组\n                               inputs.data(),  // 输入张量数组\n                               inputs.size(),  // 输入数量（3）\n                               outputNames,    // 输出名数组\n                               1               // 输出数量（1）\n    );\n\n    // 获取输出信息\n    auto&amp; output_tensor = outputs[0];\n    auto output_shape = output_tensor.GetTensorTypeAndShapeInfo().GetShape();\n    if (output_shape.size() != 3 || output_shape[0] != 1) {\n      throw std::runtime_error(\"Unexpected output shape\");\n    }\n\n    // 获取输出张量的原始 float 指针\n    const float* outputData = outputs[0].GetTensorData&lt;float&gt;();\n\n    // 提取 [CLS] token 的 embedding（第0个token）\n    int64_t hiddenSize = output_shape[2];\n    std::vector&lt;float&gt; embedding(outputData, outputData + hiddenSize);\n\n    // L2 归一化（BGE 要求）\n    float norm = 0.0f;\n    for (float v : embedding) norm += v * v;\n    norm = std::sqrt(norm);\n    if (norm &gt; 1e-8) {\n      for (float&amp; v : embedding) v /= norm;\n    }\n\n    return embedding;\n  }\n\n private:\n  mutable Ort::Session session;\n  Ort::MemoryInfo memInfo;\n  const hf::Tokenizer&amp; tokenizer;\n  int64_t embeddingDim;\n};\n\nBgeOnnxEmbedder::BgeOnnxEmbedder(const std::string&amp; modelPath,\n                                 const hf::Tokenizer&amp; tokenizer)\n    : impl(std::make_unique&lt;Impl&gt;(modelPath, tokenizer)) {}\n\nBgeOnnxEmbedder::~BgeOnnxEmbedder() = default;  // 此时 Impl 已定义，可安全析构\n\nconst int64_t&amp; BgeOnnxEmbedder::EmbeddingDim() const {\n  return impl-&gt;EmbeddingDim();\n}\n\nstd::vector&lt;float&gt; BgeOnnxEmbedder::Embed(const std::string&amp; text) const {\n  return impl-&gt;Embed(text);\n}\n\n}  // namespace embedding\n</code></pre>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-14 21:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/charlee44\">charlee44</a>&nbsp;\n阅读(<span id=\"post_view_count\">82</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Claude Code配合Astro + GitHub Pages：为 sharelatex-ce 打造现代化的开源项目宣传页",
      "link": "https://www.cnblogs.com/xuhe2/p/19618589",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xuhe2/p/19618589\" id=\"cb_post_title_url\" title=\"发布于 2026-02-15 21:51\">\n    <span>Claude Code配合Astro + GitHub Pages：为 sharelatex-ce 打造现代化的开源项目宣传页</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"效果\">效果</h1>\n<p>开源项目宣传页: <a href=\"https://xuhe2.github.io/sharelatex-ce/\" rel=\"noopener nofollow\" target=\"_blank\">https://xuhe2.github.io/sharelatex-ce/</a></p>\n<blockquote>\n<p>因为自建协作环境不该比写论文本身还难，所以我做了 sharelatex-ce 来实现真正的“一键式” Overleaf 私有化部署体验。</p>\n</blockquote>\n<p>实现效果:<br />\n<img alt=\"PixPin_2026-02-15_21-33-47\" class=\"lazyload\" /></p>\n<h1 id=\"为什么需要一个好看的宣传页\">为什么需要一个好看的宣传页？</h1>\n<p>说实话，程序员眼里的“美”往往很纯粹：代码整洁、架构优雅、README 文档清晰。但现实是残酷的——如果你的开源项目只有一堆冷冰冰的代码和长篇累牍的 Markdown 说明，那它就像是一个穿着睡衣去参加晚宴的天才，即便满腹经纶，也很难在第一时间抓住别人的眼球。</p>\n<p>在这个“颜值即正义”的 GitHub 时代，宣传页（Landing Page）就是项目的脸面。 它不仅能让用户在 3 秒钟内明白你的项目是干什么的，更像是一种“专业背书”。一个精致的页面在无声地告诉访问者：“看，开发者连这种细枝末节都打磨得这么认真，代码质量肯定差不了。” <strong>毕竟，大家都很忙，比起啃文档，谁不希望能一眼看到那个闪闪发光的 Docker-compose up 按钮呢？</strong></p>\n<h1 id=\"技术选型-后端人ai-干-前端\">技术选型: 后端人+AI 干 前端</h1>\n<p>作为一名后端程序员，让我手写 CSS 布局简直是某种程度上的“酷刑”。但在 2026 年，如果你还觉得做网页得从 </p><div> 开始一行行抠代码，那可能真的错过了这个时代的红利。<p></p>\n<p>我的选型逻辑非常直接：<strong>AI擅长什么框架, 我选什么框架, 让专业的人干专业的事，让 AI 干累人的事</strong></p>\n<ul>\n<li>\n<p>Astro 框架： 为什么不选 React 或 Vue？因为我不需要一个沉重的单页应用。Astro 是为内容驱动型网站而生的，它极快、极简，生成的静态页面干净得像刚刚洗过的代码。最重要的是，它对 SEO 极其友好，且支持各种组件混合，“学术范儿”十足。</p>\n</li>\n<li>\n<p>Claude Code： 这才是本次部署的秘密武器。作为一个非前端程序员，我只需要把我的需求、项目定位、甚至是喜欢的配色方案(<strong>其实我压根没有审美, AI看着来就好了, AI味? 我会受着</strong>)丢给 Claude。它不仅帮我写出了像模像样的 UI，甚至连那些弯弯绕绕的 GitHub Actions 部署逻辑都安排得明明白白。</p>\n</li>\n<li>\n<p>AI 时代的开发范式, 现在的开发逻辑已经变了吗? 我压根不了解 Tailwind 类名，我只需要扮演好“产品经理”的角色，通过简短的提示词（Prompt）指挥 AI 进行构建(<strong>实现细节? 相信AI的审美, 反正肯定比我好</strong>)。“不是前端写不起，而是 Claude 更有性价比。”</p>\n</li>\n</ul>\n<h1 id=\"开启github-pages功能\">开启Github Pages功能</h1>\n<ol>\n<li>\n<p>进入设置：在项目仓库顶栏点击 Settings。</p>\n</li>\n<li>\n<p>定位功能：左侧侧边栏找到并点击 Pages 选项。</p>\n</li>\n<li>\n<p>配置来源：在 Build and deployment -&gt; Source 中选择 Deploy from a branch。</p>\n</li>\n<li>\n<p>选定路径：在 Branch 下拉菜单选择目标分支（如 gh-pages），路径保持 / (root)。</p>\n</li>\n<li>\n<p>生效访问：点击 Save。稍等片刻，页面顶部会出现绿色的访问 URL。</p>\n</li>\n</ol>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<blockquote>\n<p>点击<code>Settings</code></p>\n</blockquote>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h1 id=\"部署的宣传页出现了资源无法加载的问题\">部署的宣传页出现了资源无法加载的问题</h1>\n<h2 id=\"原因\">原因</h2>\n<p>GitHub Pages 默认使用 Jekyll 来构建网页。在 Jekyll 的规则中，任何以下划线 _ 开头的文件夹（例如 _astro/）都会被视为内部私有文件夹，不会被发布到服务器上。</p>\n<p>由于 Astro 默认将所有的 CSS 和 JS 文件放在 _astro/ 目录下，GitHub Pages 实际上并没有把这些文件部署出去，所以你的浏览器请求时会报 404。</p>\n<h2 id=\"解决方案1\">解决方案1</h2>\n<ul>\n<li>核心解决方法：添加 .nojekyll 文件</li>\n</ul>\n<blockquote>\n<p>你需要告诉 GitHub：“不要用 Jekyll 运行我的网站，直接把我的文件原样发出去”。</p>\n</blockquote>\n<p>操作步骤：</p>\n<ol>\n<li>在你的 gh-pages 分支的根目录下，创建一个名为 .nojekyll 的空文件（注意前面有一个点）。</li>\n<li>提交并推送。</li>\n</ol>\n<h2 id=\"解决方案2\">解决方案2</h2>\n<p>修改代码, 配置静态资源所在的位置, 修改<code>astro.config.mjs</code>文件内容:</p>\n<pre><code>diff --git a/landing-page/astro.config.mjs b/landing-page/astro.config.mjs\nindex 1ae7417..b1f04c3 100644\n--- a/landing-page/astro.config.mjs\n+++ b/landing-page/astro.config.mjs\n@@ -7,5 +7,6 @@ export default defineConfig({\n   site: 'https://xuhe2.github.io/sharelatex-ce/',\n   build: {\n     format: 'directory',\n+    assets: 'assets',\n   },\n });\n</code></pre>\n<h1 id=\"参考文献\">参考文献</h1>\n<p>官方文档: <a href=\"https://docs.github.com/en/pages/getting-started-with-github-pages/what-is-github-pages\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.github.com/en/pages/getting-started-with-github-pages/what-is-github-pages</a></p>\n</div>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-15 21:51</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xuhe2\">xuhe2</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}