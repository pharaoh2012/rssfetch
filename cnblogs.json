{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "Redis 为什么这么快？——「极速快递站」的故事",
      "link": "https://www.cnblogs.com/sun-10387834/p/19587846",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19587846\" id=\"cb_post_title_url\" title=\"发布于 2026-02-07 11:26\">\n    <span>Redis 为什么这么快？——「极速快递站」的故事</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>咱们先从一个真实场景切入：电商大促时，每秒几万用户查商品库存，<strong>MySQL（传统数据库）查一次要几百毫秒，甚至卡崩；但Redis查一次只要几微秒，扛住百万请求都不慌</strong>。</p>\n<p>为啥差距这么大？我把Redis比作一个<strong>「开在市中心的极速快递站」</strong>，把传统数据库（比如MySQL）比作<strong>「开在郊区的大型仓储超市」</strong>，用这个故事把Redis快的本质讲透——它的快，不是靠“堆硬件”，而是<strong>从底层设计到每一步操作，都在极致追求“少走路、少等待、少折腾”</strong>。</p>\n<h2 id=\"故事开场用户要查库存两个地方的不同表现\">故事开场：用户要查库存，两个地方的不同表现</h2>\n<p>用户（客户端）喊：“我要查iPhone 16的库存！”</p>\n<ul>\n<li>仓储超市（MySQL）：得派员工开车去郊区仓库（磁盘）找货，路上堵车、找货翻货架，来回要几十分钟（几百毫秒）；</li>\n<li>极速快递站（Redis）：员工站在市中心柜台（内存）前，伸手就拿到库存单，1秒都不到（几微秒）。</li>\n</ul>\n<p>这就是Redis快的<strong>第一个核心本质：纯内存操作，彻底绕开磁盘的慢</strong>。</p>\n<hr />\n<h2 id=\"一第一大绝招全在内存柜台干活绝不跑磁盘仓库最核心\">一、第一大绝招：全在「内存柜台」干活，绝不跑「磁盘仓库」（最核心）</h2>\n<h3 id=\"故事版\">故事版</h3>\n<p>快递站的老板很聪明：<strong>所有用户高频要查、要改的货（比如库存、用户会话、热点数据），全都摆在市中心的玻璃柜台（内存）上</strong>，员工不用跑郊区，伸手就拿、抬手就放。<br />\n而且柜台空间虽小，但存取速度极快——员工一秒能处理几百上千个请求，根本不耽误事。<br />\n只有极少数时候（比如晚上没人时），才会把柜台的货备份到郊区仓库（磁盘持久化），白天接单时绝不碰仓库。</p>\n<h3 id=\"本质剖析\">本质剖析</h3>\n<ol>\n<li><strong>内存 vs 磁盘的速度差，是天壤之别</strong>：<br />\n内存（RAM）的读写速度是<strong>纳秒/微秒级</strong>（1微秒=1000纳秒），磁盘（机械硬盘）是<strong>毫秒/秒级</strong>（1毫秒=1000微秒）。<br />\n简单说：<strong>内存比机械硬盘快10万<sub>100万倍，比固态硬盘（SSD）也快100</sub>1000倍</strong>。</li>\n<li><strong>Redis 99%的操作都在内存里完成</strong>：<br />\n它的核心数据（键值对）全存在内存中，读、写、删都是直接操作内存，没有磁盘IO的延迟。<br />\n哪怕做持久化（RDB/AOF），也是<strong>后台异步执行</strong>，绝不阻塞前台处理用户请求的主线程——白天接单、晚上备份，两不误。</li>\n</ol>\n<p>这是Redis快的<strong>根基</strong>，没有这一点，后面所有优化都是白搭。</p>\n<hr />\n<h2 id=\"二第二大绝招一个超级熟练工单干绝不搞多人内耗单线程设计\">二、第二大绝招：一个「超级熟练工」单干，绝不搞「多人内耗」（单线程设计）</h2>\n<h3 id=\"故事版-1\">故事版</h3>\n<p>快递站只有<strong>一个超级熟练的员工</strong>（单线程），所有用户请求都由他一个人处理：</p>\n<ul>\n<li>不用和其他员工抢柜台（无锁竞争）；</li>\n<li>不用频繁交接工作（无上下文切换）；</li>\n<li>不用等别人干完自己再干（无阻塞等待）。<br />\n他全程专注，一个请求接一个请求，手速快到飞起。<br />\n反观仓储超市，雇了十几个员工（多线程），大家抢货架、抢推车，还要排队等锁，反而越忙越乱，效率极低。</li>\n</ul>\n<h3 id=\"本质剖析-1\">本质剖析</h3>\n<ol>\n<li><strong>Redis是「单线程处理核心命令」</strong>：<br />\n注意：这里的单线程，是指<strong>处理用户读写命令的主线程是单线程</strong>（后台还有线程做持久化、集群同步，但不影响核心流程）。</li>\n<li><strong>单线程为什么反而更快？</strong>\n<ul>\n<li><strong>无锁竞争</strong>：多线程操作共享数据（比如库存），必须加锁（比如MySQL的行锁、表锁），加锁、解锁、等待锁释放，全是耗时开销；Redis单线程不用加锁，直接操作数据，零开销。</li>\n<li><strong>无上下文切换</strong>：多线程切换时，CPU要保存上一个线程的状态、加载下一个线程的状态，每次切换都要耗时；Redis单线程全程不切换，CPU利用率拉满。</li>\n<li><strong>逻辑极简</strong>：单线程不用处理复杂的线程同步、死锁问题，代码逻辑简单，执行效率极高。</li>\n</ul>\n</li>\n<li><strong>关键误区</strong>：单线程不代表“只能处理一个请求”，后面会讲它怎么同时扛百万请求。</li>\n</ol>\n<hr />\n<h2 id=\"三第三大绝招同时盯所有窗口绝不傻等一个客户io多路复用\">三、第三大绝招：同时盯「所有窗口」，绝不「傻等一个客户」（IO多路复用）</h2>\n<h3 id=\"故事版-2\">故事版</h3>\n<p>快递站的员工虽然只有一个，但他<strong>同时盯着几百个窗口（网络连接）</strong>：</p>\n<ul>\n<li>哪个窗口的客户喊“查库存”，他就立刻处理；</li>\n<li>哪个窗口的客户还在磨蹭（网络延迟），他就先不管，继续盯其他窗口；</li>\n<li>绝不站在一个窗口前傻等，浪费时间。<br />\n比如1000个客户同时来，他一秒内能轮着处理完999个，只有1个在磨蹭的，等他磨完再处理。</li>\n</ul>\n<h3 id=\"本质剖析-2\">本质剖析</h3>\n<ol>\n<li><strong>解决“网络等待”的痛点</strong>：<br />\n用户请求不是直接到Redis，要经过网络传输（比如从手机到服务器），这个过程有延迟（IO等待）。如果Redis傻等一个请求的网络数据，其他请求就会卡住。</li>\n<li><strong>IO多路复用：一个线程监听成千上万个网络连接</strong>：<br />\nRedis用了Linux系统的<strong>epoll</strong>（最先进的IO多路复用技术），单线程就能同时监听成千上万个客户端连接：\n<ul>\n<li>系统会告诉Redis：“哪个连接有数据来了，你去处理”；</li>\n<li>Redis只处理“有数据的连接”，对“没数据的连接”完全不浪费时间。</li>\n</ul>\n</li>\n<li><strong>结果</strong>：单线程+IO多路复用，让Redis能<strong>同时处理百万级客户端连接</strong>，而且每个请求的处理延迟都极低——这是它扛高并发的关键。</li>\n</ol>\n<hr />\n<h2 id=\"四第四大绝招货都摆进专属货架绝不乱堆乱放高效数据结构\">四、第四大绝招：货都「摆进专属货架」，绝不「乱堆乱放」（高效数据结构）</h2>\n<h3 id=\"故事版-3\">故事版</h3>\n<p>快递站的柜台不是乱堆货，而是<strong>按品类摆进专属货架</strong>：</p>\n<ul>\n<li>查库存（键值对）：直接看“库存货架”，编号一输就找到；</li>\n<li>查用户购物车（列表）：直接拉“购物车货架”，头尾都能快速取；</li>\n<li>查热门商品（集合）：直接看“热门货架”，去重、统计一秒搞定。<br />\n每个货架都设计得极合理，找货、放货、删货都不用翻找，伸手就到位。</li>\n</ul>\n<h3 id=\"本质剖析-3\">本质剖析</h3>\n<p>Redis没有用传统数据库的“表结构”，而是<strong>内置了6种极简、高效的底层数据结构</strong>：</p>\n<ol>\n<li><strong>简单动态字符串（SDS）</strong>：存普通字符串（比如用户名），比C语言原生字符串快，支持快速扩容、拼接；</li>\n<li><strong>哈希表（Hash）</strong>：存对象（比如用户信息、商品详情），查找是<strong>O(1)复杂度</strong>（一秒定位）；</li>\n<li><strong>列表（List）</strong>：双端链表，存有序数据（比如消息队列、购物车），头尾增删是<strong>O(1)</strong>；</li>\n<li><strong>集合（Set）</strong>：无序去重，存唯一数据（比如热门标签、用户点赞），查找、去重是<strong>O(1)</strong>；</li>\n<li><strong>有序集合（ZSet）</strong>：带权重的集合，存排序数据（比如排行榜、热门商品），查找、排序极快；</li>\n<li><strong>跳表（SkipList）</strong>：有序集合的底层实现，用“多层索引”替代平衡树，查找是<strong>O(logN)</strong>，比树结构简单快得多。</li>\n</ol>\n<p><strong>核心</strong>：这些数据结构的操作，全是<strong>常数级或对数级复杂度</strong>，没有传统数据库的“全表扫描”（O(N)），每一步操作都快到极致。</p>\n<hr />\n<h2 id=\"五第五大绝招只做核心活绝不瞎折腾极简协议无冗余\">五、第五大绝招：只做「核心活」，绝不「瞎折腾」（极简协议+无冗余）</h2>\n<h3 id=\"故事版-4\">故事版</h3>\n<p>快递站和客户沟通，用的是<strong>最简单的暗号</strong>：</p>\n<ul>\n<li>客户说：<code>GET iphone16</code>（查库存）；</li>\n<li>Redis回：<code>100</code>（库存100）。<br />\n没有多余的废话，没有复杂的格式，沟通一秒完成。<br />\n不像仓储超市，客户要填一堆表单、走一堆流程，沟通成本极高。</li>\n</ul>\n<h3 id=\"本质剖析-4\">本质剖析</h3>\n<ol>\n<li><strong>RESP协议：极简的文本协议</strong>：<br />\nRedis和客户端通信用的是<strong>RESP（Redis Serialization Protocol）</strong>，格式极简单（比如<code>+OK\\r\\n</code>、<code>$5\\r\\nhello\\r\\n</code>），解析速度极快——不用像HTTP、SQL那样解析复杂的语法，CPU几乎不花时间在协议解析上。</li>\n<li><strong>无冗余操作</strong>：<br />\nRedis只做“键值对的增删改查”，没有传统数据库的事务日志、外键约束、复杂索引维护等冗余操作，所有资源都集中在核心读写上。</li>\n</ol>\n<hr />\n<h2 id=\"故事总结redis快的本质是极致的减法设计\">故事总结：Redis快的本质，是「极致的减法设计」</h2>\n<p>把上面的绝招串起来，Redis快的<strong>核心本质</strong>就清晰了：<br />\n它没有像传统数据库那样“做加法”（加复杂功能、加磁盘依赖、加多线程锁），而是<strong>做了极致的减法</strong>：</p>\n<ol>\n<li><strong>减延迟</strong>：纯内存操作，绕开磁盘IO的万倍延迟；</li>\n<li><strong>减内耗</strong>：单线程处理核心命令，无锁、无切换、无竞争；</li>\n<li><strong>减等待</strong>：IO多路复用，同时处理百万连接，不傻等网络；</li>\n<li><strong>减复杂度</strong>：高效数据结构+极简协议，每一步操作都快到极致。</li>\n</ol>\n<p>简单说：<strong>Redis是为“快”而生的专用工具，而传统数据库是为“全功能”而生的通用工具</strong>——术业有专攻，自然速度天差地别。</p>\n<hr />\n<p>需要我用更直观的对比表，把Redis和MySQL的核心差异（速度、场景、数据结构）列出来，帮你快速判断什么时候该用Redis吗？</p>\n\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19587846\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19587846</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-07 11:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "决策树极简入门",
      "link": "https://www.cnblogs.com/wang_yb/p/19587107",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/wang_yb/p/19587107\" id=\"cb_post_title_url\" title=\"发布于 2026-02-07 08:06\">\n    <span>决策树极简入门</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>我们在学习机器学习算法时，往往会被各种枯燥的数学公式所劝退。</p>\n<p>今天，我将尝试用结合实际生活的方式，来介绍一个非常经典，而且可能是最“懂你心意”的算法——决策树 (Decision Tree)。。</p>\n<p>别被这个术语吓到了，其实你每天点外卖的时候都在用它。</p>\n<p>想象一下，下午三点，你站在奶茶店门口（或者打开了外卖App），面对眼花缭乱的菜单，你的大脑为了保护你的体重，立刻启动了一个“决策树”程序：</p>\n<ol>\n<li>这杯奶茶含糖吗？ -&gt; 如果是全糖 -&gt; 不喝，会胖死 ❌。</li>\n<li>-&gt; 如果是无糖 -&gt; 再看看。</li>\n<li>加没加小料？ -&gt; 没加？ -&gt; 没灵魂，不喝 ❌。</li>\n<li>-&gt; 加了波霸/珍珠？ -&gt; 完美！买它！ ✅</li>\n</ol>\n<p><img alt=\"画板\" src=\"https://img2024.cnblogs.com/blog/83005/202602/83005-20260207080350892-40837281.jpg\" /></p>\n<p>看，这就是一棵决策树！把你脑海里纠结的过程画下来，它就是一个倒立的树状流程图。</p>\n<p>但在机器学习里，我们不是自己画图，而是让计算机通过学习历史订单数据，自己总结出这套“点单秘籍”。</p>\n<p>它是怎么做到的？别急，我们要用几杯奶茶来教会你。🧋</p>\n<h1 id=\"-第一部分解剖决策树\">🌲 第一部分：解剖决策树</h1>\n<p>在深入之前，咱们先对齐一下 <strong>“行话”</strong>。虽然它叫树，但在计算机科学里，这棵树通常是倒着长的（根在上面，叶子在下面）。</p>\n<ul>\n<li><strong>根节点</strong> (<code>Root Node</code>): 树的最顶端。也就是最关键的那个问题（比如：甜度是多少？）。</li>\n<li><strong>决策节点</strong> (<code>Decision Node</code>): 中间的那些站点，负责根据某个特征（比如小料、冷热）把数据分流。</li>\n<li><strong>叶节点</strong> (<code>Leaf Node</code>): 树的末端。到了这里，不再问问题了，直接给出最终判决（比如：喝！ 或者 快逃！）。</li>\n</ul>\n<h1 id=\"-第二部分树是怎么长出来的\">🧠 第二部分：树是怎么“长”出来的？</h1>\n<p>这才是最迷人的地方。如果你给模型一堆奶茶数据，它怎么知道先看“甜度”还是先看“价格”？</p>\n<p>这就涉及到两个超级重要的概念：<strong>熵</strong> (<code>Entropy</code>) 和 <strong>信息增益</strong> (<code>Information Gain</code>)。</p>\n<h2 id=\"1-什么是熵-entropy\">1. 什么是熵 (Entropy)？</h2>\n<p>物理学里说<strong>熵</strong>代表<strong>混乱程度</strong>。在决策树里，<strong>熵</strong>代表数据的 <strong>“不纯度”</strong>（你也可以理解为** “纠结程度” **）。</p>\n<ul>\n<li><strong>场景 A</strong>: 你面前有10杯奶茶，全是无糖波霸奶茶。这数据太纯了，熵 = 0。你闭着眼拿一杯都是你想喝的，完全不用纠结。</li>\n<li><strong>场景 B:</strong> 你面前有10杯奶茶，5杯是你最爱的无糖，5杯是甜到齁的全糖，混在一起。这太混乱了，熵 = 1（最高）。你完全猜不到下一杯是不是“雷”。</li>\n</ul>\n<p>机器学习的目标就是：通过问问题（分裂），让数据的熵越来越小，直到变成 0（完全纯净）。</p>\n<h2 id=\"2-信息增益-information-gain\">2. 信息增益 (Information Gain)</h2>\n<p>这就是我们的 <strong>“筛选标准”</strong>。</p>\n<ul>\n<li><strong>信息增益</strong> = <strong>分裂前的熵</strong> - <strong>分裂后的熵</strong></li>\n</ul>\n<p>简单说：如果我按“甜度”分，能让这堆数据变得多“干净”？ 哪个问题能帮我排除掉最多的干扰项，我们就选哪个问题当老大（根节点）！</p>\n<h1 id=\"-第三部分手动算一算-奶茶案例\">📊 第三部分：手动算一算 (奶茶案例)</h1>\n<p>假设我们收集了你过去买的50次奶茶记录，你的口味偏好非常明显：只喝无糖。<br />\n数据分布如下：</p>\n<ul>\n<li><strong>全糖</strong>: <code>25</code>杯 -&gt; 结果全是 不喝 (❌)</li>\n<li><strong>无糖</strong>: <code>25</code>杯 -&gt; 结果是 喝 (✅)</li>\n</ul>\n<p>我们要决定：先按“甜度”分，还是先按“加没加冰”分？</p>\n<h2 id=\"方案一按甜度切一刀-\">方案一：按“甜度”切一刀 🔪</h2>\n<ul>\n<li>左边（<strong>全糖堆</strong>）: 25杯全是❌。完美！这堆数据的熵直接变成0了！（不用再问别的了，直接扔掉）。</li>\n<li>右边（<strong>无糖堆</strong>）: 25杯全是✅。完美！熵也是0！</li>\n</ul>\n<h2 id=\"方案二按加冰切一刀-\">方案二：按“加冰”切一刀 🧊</h2>\n<p>假设全糖和无糖里都有加冰和去冰的情况。</p>\n<ul>\n<li>左边（<strong>加冰堆</strong>）: 混杂着全糖(❌)和无糖(✅)。还是很乱，熵很高。</li>\n<li>右边（<strong>去冰堆</strong>）: 同样混杂。</li>\n</ul>\n<p>很明显，按<strong>甜度分</strong>的信息增益最大，因为它能帮我们瞬间把“绝对不喝”的那部分挑出来。</p>\n<p>所以，机器会选择 <strong>甜度</strong> 作为根节点！</p>\n<h1 id=\"-第四部分python-代码实战\">💻 第四部分：Python 代码实战</h1>\n<p>光说不练假把式。作为工程师，我们要用代码说话。我们会使用 Python 的 <code>scikit-learn</code> 库。</p>\n<p>假设我们整理好了数据 <code>milktea.csv</code>：</p>\n<table>\n<thead>\n<tr>\n<th>Sugar (甜度)</th>\n<th>Topping (小料)</th>\n<th>Decision (喝吗?)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Full (全糖)</td>\n<td>Pearls (珍珠)</td>\n<td>0 (No)</td>\n</tr>\n<tr>\n<td>Zero (无糖)</td>\n<td>None (无)</td>\n<td>0 (No - 太寡淡)</td>\n</tr>\n<tr>\n<td>Zero (无糖)</td>\n<td>Pearls (珍珠)</td>\n<td>1 (Yes)</td>\n</tr>\n<tr>\n<td>...</td>\n<td>...</td>\n<td>...</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"1-预处理与训练\">1. 预处理与训练</h2>\n<p>机器看不懂中文或单词，我们要把它翻译成数字。</p>\n<pre><code class=\"language-python\">import pandas as pd\nfrom sklearn import tree\nimport matplotlib.pyplot as plt\n\n# 1. 模拟一点奶茶数据\n# 假设我们的逻辑是：只有\"无糖(Zero)\"且\"加珍珠(Pearls)\"才喝\ndata = pd.DataFrame({\n    'Sugar':   ['Full', 'Zero', 'Full', 'Zero', 'Half', 'Zero'],\n    'Topping': ['Pearls', 'None', 'None', 'Pearls', 'Pearls', 'Pudding'],\n    'Drink':   [0, 0, 0, 1, 0, 1]  # 1=喝, 0=不喝 (假设只要是无糖且有小料就喝)\n})\n\n# 2. 数据预处理：把文字变成数字 (Mapping)\n# 甜度: Full=0, Zero=1, Half=2\n# 小料: Pearls=0, None=1, Pudding=2\ndata['Sugar_Code'] = data['Sugar'].map({'Full': 0, 'Zero': 1, 'Half': 2})\ndata['Topping_Code'] = data['Topping'].map({'Pearls': 0, 'None': 1, 'Pudding': 2})\n\nfeatures = ['Sugar_Code', 'Topping_Code']\nX = data[features]\nY = data['Drink']\n\n# 3. 训练模型\n# criterion='entropy' 表示我们使用“熵”来作为分裂标准\nclf = tree.DecisionTreeClassifier(criterion='entropy')\nclf = clf.fit(X, Y)\n\nprint(\"🤖 奶茶鉴定模型训练完毕！\")\n</code></pre>\n<h2 id=\"2-可视化这棵树\">2. 可视化这棵树</h2>\n<p>让我们看看机器脑子里想的图长什么样。</p>\n<pre><code class=\"language-python\"># 4. 画出决策树\nplt.figure(figsize=(10,6))\ntree.plot_tree(clf, \n               feature_names=['Sugar', 'Topping'],  \n               class_names=['Pass', 'Drink'], # Pass=不喝, Drink=喝\n               filled=True, # 颜色越深代表机器越确信\n               rounded=True)\nplt.show()\n</code></pre>\n\n<p><img alt=\"\" src=\"https://img2024.cnblogs.com/blog/83005/202602/83005-20260207080350764-430638444.png\" /></p>\n<h2 id=\"3-预测新数据\">3. 预测新数据</h2>\n<p>这时候，老板推出了一款新品：无糖 + 珍珠。你要不要尝尝？</p>\n<ul>\n<li>无糖 = 1</li>\n<li>珍珠 = 0</li>\n</ul>\n<pre><code class=\"language-python\"># 预测 [Sugar=1, Topping=0]\nnew_tea = [[1, 0]]\nprediction = clf.predict(new_tea)\n\nif prediction[0] == 1:\n    print(\"决策结果：买它！🧋😋\")\nelse:\n    print(\"决策结果：哒咩！❌\")\n\n## 运行结果：\n'''\n决策结果：买它！🧋😋\n'''\n</code></pre>\n<h1 id=\"-总结\">🚀 总结</h1>\n<p>今天我们通过一杯奶茶学习了：</p>\n<ol>\n<li><strong>决策树</strong>就是一套帮你做选择的“流程图”。</li>\n<li>机器利用<strong>熵</strong>（乱不乱）和<strong>信息增益</strong>（变干净了吗）来寻找最佳的筛选条件。</li>\n<li>用 <code>scikit-learn</code> 几行代码就能搞定。</li>\n</ol>\n<p>机器学习其实离生活很近。希望这棵“树”能帮你不仅选对模型，还能选对最适合你的那杯下午茶！</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-07 08:06</span>&nbsp;\n<a href=\"https://www.cnblogs.com/wang_yb\">wang_yb</a>&nbsp;\n阅读(<span id=\"post_view_count\">17</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Codex 5.3 与 Opus 4.6 同日升级，AI Agent今年要爆发了",
      "link": "https://www.cnblogs.com/haibindev/p/19586598",
      "published": "",
      "description": "<div class=\"postTitle\">\n\t\t<h1><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/haibindev/p/19586598\" id=\"cb_post_title_url\" title=\"发布于 2026-02-07 00:21\">\n    <span>Codex 5.3 与 Opus 4.6 同日升级，AI Agent今年要爆发了</span>\n    \n\n</a>\n</h1>\n\t</div>\n\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"Codex 5.3 与 Opus 4.6 同日升级，AI Agent今年要爆发了\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260207002057936-565238423.png\" />\n        2026真的是 AI Agent 爆发的一年。OpenAI 与 Anthropic 几乎前后脚发布新版本：`GPT-5.3-Codex` 与 `Claude Opus 4.6`。再叠加国内大模型在 1月到2月的密集动作，现在看来，智能体的发展速度，已经超出大多数人的预料了，我们都需要紧跟脚步。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"codex-53-与-opus-46-同日升级ai-编码竞争从会写转向能闭环\">Codex 5.3 与 Opus 4.6 同日升级，AI 编码竞争从“会写”转向“能闭环”</h1>\n<p>2026真的是 AI Agent 爆发的一年。OpenAI 与 Anthropic 几乎前后脚发布新版本：<code>GPT-5.3-Codex</code> 与 <code>Claude Opus 4.6</code>。再叠加国内大模型在 1月到2月的密集动作，现在看来，智能体的发展速度，已经超出大多数人的预料了，我们都需要紧跟脚步。</p>\n<h2 id=\"发生了什么\">发生了什么</h2>\n<p>2月5日，OpenAI 发布 GPT-5.3-Codex，定位是更强的 agentic coding 模型，覆盖 Codex App、CLI、IDE 扩展与 Web。<br />\n同一天，Anthropic 发布 Claude Opus 4.6，重点强调长任务、长上下文与工程稳定性。</p>\n<p><img alt=\"Sam Altman 在 X 发布 Codex 5.3 截图\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260207001843633-555515766.png\" /></p>\n<p><img alt=\"Anthropic 在 X 发布 Opus 4.6 截图\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260207001843660-1930590112.png\" /></p>\n<p>同日升级这件事本身就是信号：头部厂商已经把“开发者工作流”当成最核心战场。</p>\n<h2 id=\"有什么提升和改变\">有什么提升和改变</h2>\n<p>这一部分按官方披露口径展开。</p>\n<p>先看 OpenAI。官方给了比较明确的性能描述和对比数据：</p>\n<ul>\n<li>在 Codex 使用场景中，<code>GPT-5.3-Codex</code> 相比 <code>GPT-5-Codex</code>，官方称整体速度约提升 25%。</li>\n<li>在 <code>SWE-Bench Pro</code> 上，<code>GPT-5.3-Codex</code> 为 56.8，<code>GPT-5-Codex</code> 为 56.4，属于小幅提升。</li>\n<li>在 <code>Terminal-Bench 2.0</code> 上，<code>GPT-5.3-Codex</code> 为 77.3，<code>GPT-5-Codex</code> 为 64.0，提升更明显。</li>\n<li>在 <code>OSWorld Verified</code> 上，<code>GPT-5.3-Codex</code> 为 64.7，<code>GPT-5-Codex</code> 为 38.2，跨任务执行能力的提升幅度非常大。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th style=\"text-align: right;\">GPT-5.3-Codex</th>\n<th style=\"text-align: right;\">GPT-5-Codex</th>\n<th>变化解读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Codex 场景整体速度</td>\n<td style=\"text-align: right;\">+25%（官方口径）</td>\n<td style=\"text-align: right;\">基线</td>\n<td>交互和长任务执行节奏更快</td>\n</tr>\n<tr>\n<td>SWE-Bench Pro</td>\n<td style=\"text-align: right;\">56.8</td>\n<td style=\"text-align: right;\">56.4</td>\n<td>小幅提升，说明基础修复能力继续优化</td>\n</tr>\n<tr>\n<td>Terminal-Bench 2.0</td>\n<td style=\"text-align: right;\">77.3</td>\n<td style=\"text-align: right;\">64.0</td>\n<td>大幅提升，终端多步任务更稳</td>\n</tr>\n<tr>\n<td>OSWorld Verified</td>\n<td style=\"text-align: right;\">64.7</td>\n<td style=\"text-align: right;\">38.2</td>\n<td>显著提升，跨工具/跨环境任务能力加强</td>\n</tr>\n</tbody>\n</table>\n<p>换句话说，OpenAI 这次最关键的升级点，不是“写一段代码更优雅”，而是“在多步骤、多工具、多文件任务里更稳”。</p>\n<p>再看 Anthropic。Opus 4.6 的官方叙事重点有三点：</p>\n<ul>\n<li>首次把 Opus 系列推进到 <code>1M</code> 上下文窗口（测试能力），直接服务长文档和长链路任务。</li>\n<li>在官方展示中，<code>Terminal-Bench 2.0</code> 达到 65.4，<code>OSWorld</code> 达到 72.7，继续强化端到端任务执行能力。</li>\n<li>价格口径保持不变，意图很明确：在不提高使用门槛的前提下，拉高复杂任务成功率。</li>\n</ul>\n<p>所以这轮变化可以总结成一句话：模型厂商正在把“代码生成工具”升级为“软件工程执行代理”。</p>\n<h2 id=\"国内模型的最近动作\">国内模型的最近动作</h2>\n<p>国内阵营这段时间也很密集，而且都在往“工程化可用”方向卷。</p>\n<p>百度这边，2026年1月22日发布文心大模型 5.0。官方披露的关键词是“原生多模态、超大参数规模、综合能力升级”，并强调在多项公开基准上的竞争力。对企业用户来说，这意味着百度正在把文心从通用对话进一步推向多场景生产。</p>\n<p>阿里云通义这边，2026年1月23日版本号 <code>qwen3-max-2026-01-23</code> 已在模型服务侧上线，思考模式标识为 <code>Qwen3-Max-Thinking</code>。官方描述重点放在更强推理、更强 Agent 任务处理和工具调用能力，定位是可直接进入业务工作流的旗舰模型。</p>\n<p>DeepSeek 据说马上要发布 <code>DeepSeek V4</code>，主打编码能力。截至2026年2月6日，官方仍未给出 V4 正式发布公告。</p>\n<p>智谱这边，<code>GLM-5</code> 在2026年1月初有“将很快推出”的对外信息，但截至2026年2月6日，尚未看到完整官方发布页落地。</p>\n<p>如果做一个阶段性预估：国内大模型在2026年上半年很可能出现“旗舰扎堆发布 + 价格快速调整 + Agent 场景落地提速”的三连动。</p>\n<p>另外，阿里在千问上已经开始打通生活圈，包括电商、导航、旅游、支付，甚至是政务民生，要成为一个大帝国。这个能力恐怕全球独一份了</p>\n<p><img alt=\"千问生活圈生态示意图\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260207001843706-160854750.png\" /></p>\n<h2 id=\"ai-agent-智能体正在加速进化\">AI Agent 智能体正在加速进化</h2>\n<p>AI Agent 对所有人的影响，已经从“可选工具”变成“基础能力差距”。</p>\n<p>对程序员来说，变化是工作重心迁移。你写的纯代码会减少，但你定义任务、拆解需求、设计验证、管理上下文的能力会成为新核心。</p>\n<p>对产品和运营来说，变化是执行方式重构。过去要多人协作一周的内容整理、数据分析、方案迭代，未来可能由“人定方向 + Agent 连续执行”在一天内完成。</p>\n<p>对企业管理者来说，变化是组织效率和组织结构。很多岗位不会消失，但“人机协作比”会快速变化，团队将从按岗位分工转向按任务闭环分工。</p>\n<p>对普通用户来说，变化是信息处理门槛被拉平。未来的差距不再是“会不会用某个软件”，而是“会不会把目标描述清楚，并持续驱动 Agent 直到拿到可用结果”。</p>\n<p><img alt=\"AI Agent 进化路线图\" src=\"https://img2024.cnblogs.com/blog/254714/202602/254714-20260207001843691-1353541318.png\" /></p>\n<p>未来 6 到 12 个月，最现实的预估是：</p>\n<ul>\n<li>Agent 会先在高重复、可验证、可审计的场景里规模化。</li>\n<li>跨系统自动执行会增加，但权限治理和审计会成为刚需。</li>\n<li>个人生产力差距会被进一步放大，会“定义任务和验收结果”的人会显著领先。</li>\n</ul>\n<h2 id=\"小结\">小结</h2>\n<p>从2026年2月这轮更新看，AI 编码竞争的核心已经非常清晰：谁能更稳定地完成复杂任务，谁就能拿到下一阶段的话语权。<br />\nCodex 5.3 与 Opus 4.6 的同日升级，加上文心 5、Qwen3-Max-Thinking、DeepSeek V4、GLM-5 的连续动作，说明2026年的主线不是“模型会不会写代码”，而是“模型能不能作为可控的工程执行者进入真实生产”。</p>\n<hr />\n<p><strong>作者简介：</strong> 10年+视频技术、后端架构、AI应用开发经验，曾任某互联网大厂技术专家。对AI编程工具、云原生架构、视频处理技术有深入研究。</p>\n<p><img alt=\"\" src=\"https://img2023.cnblogs.com/blog/254714/202307/254714-20230701143418754-1351786962.jpg\" /></p>\n<p><strong>合作请加WX：hbstream</strong><br />\n<strong>（<a href=\"http://haibindev.cnblogs.com\" target=\"_blank\">http://haibindev.cnblogs.com</a>），转载请注明作者和出处</strong></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-02-07 00:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/haibindev\">haibindev</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从聊天框到动态助手：MCP Apps 如何重塑 AI 交互的未来",
      "link": "https://www.cnblogs.com/shanyou/p/19586390",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19586390\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 22:02\">\n    <span>从聊天框到动态助手：MCP Apps 如何重塑 AI 交互的未来</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>在人工智能向“自主智能体”演进的道路上，我们正见证一个关键的范式转移：大型语言模型（LLM）不再仅仅是文本生成器，而是逐渐成为能感知环境、调用工具并执行复杂任务的智能核心。然而，传统的“文本输入-文本输出”模式，在面对需要精密逻辑、实时数据可视化与复杂业务流操控的生产力场景时，其交互深度的局限性暴露无遗。为了连接模型与广阔的外部世界，<strong>模型上下文协议（Model Context Protocol, MCP）</strong> 应运而生，旨在标准化模型与工具之间的通信，降低生态适配成本。</span></p>\n<h5><span>一、MCP 的基石与交互瓶颈</span></h5>\n<p><span>MCP 通过宿主（Host）、客户端（Client）与服务器（Server）的三层架构，实现了关注点的分离与协议的标准化。在其基础模型中，工具（Tools）通常返回结构化数据或静态 Markdown 文本。虽然这解决了功能调用的问题，但在处理如多维财务报表、交互式工程图纸或实时监控仪表盘等任务时，用户体验出现了断层——智能体只能“描述”数据，用户无法直接“操作”数据。这种交互深度的缺失，成为提升 AI 生产力的主要障碍。</span></p>\n<h5><span>二、MCP Apps：交互式 UI 的引入</span></h5>\n<p><span>2025年底，由 Anthropic、OpenAI 及社区推动的 <strong>MCP Apps 扩展（代号 SEP-1865）</strong> 正式发布，旨在彻底突破这一瓶颈。其核心创新在于，允许 AI 对话线程内直接交付并运行完整的、交互式的 Web 应用程序。</span></p>\n<p><span><span style=\"font-size: medium;\"><strong>MCP Apps 的本质</strong>，是存在于 AI 对话中的沙箱化 HTML5 应用。它并非定义新的 UI 语言，而是拥抱成熟的 Web 技术栈（HTML/JS/CSS）。在 SEP-1865 框架下，工具定义可通过 _meta.ui 字段声明一个指向 UI 资源（使用 ui:// 协议）的引用。当 LLM 调用此类工具时，宿主便能识别该声明，并从服务器拉取对应的 UI 捆绑包进行渲染。</span></span></p>\n<p><span>与传统 MCP 工具相比，MCP Apps 带来了根本性的提升：</span></p>\n<ul>\n<li><span><span style=\"font-size: medium;\"><strong>输出介质</strong>：从静态文本/JSON 变为动态、可交互的应用程序。</span></span></li>\n</ul>\n<ul>\n<li><span><span style=\"font-size: medium;\"><strong>交互深度</strong>：从触发新一轮对话，扩展到支持点击、拖拽、表单校验等丰富的前端操作。</span></span></li>\n</ul>\n<ul>\n<li><span><span style=\"font-size: medium;\"><strong>通信模式</strong>：从单向的请求-响应，升级为基于 postMessage 的全双工 JSON-RPC 通道，实现实时双向通信。</span></span></li>\n</ul>\n<ul>\n<li><span><span style=\"font-size: medium;\"><strong>生命周期</strong>：从随工具执行结束而终止，变为可在整个对话上下文中持续存在并保持内部状态。</span></span></li>\n</ul>\n<h5><span>三、安全架构与核心技术流程</span></h5>\n<p><span>将不受信任的外部代码引入宿主环境，安全是首要考量。SEP-1865 为此构建了严密的多层防护：</span></p>\n<ol>\n<li><span><span style=\"font-size: medium;\"><strong>强制沙箱隔离</strong>：所有 App 必须运行在高度受限的 iframe 沙箱中，禁止直接访问父页面 DOM 或执行特权操作。</span></span></li>\n</ol><ol start=\"2\">\n<li><span><span style=\"font-size: medium;\"><strong>严格的内容安全策略（CSP）</strong>：服务器可通过元数据定义 App 允许加载的资源域名和发起的网络连接，有效防御 XSS 攻击和数据泄露。</span></span></li>\n</ol><ol start=\"3\">\n<li><span><span style=\"font-size: medium;\"><strong>显式权限授权</strong>：对于需要摄像头、麦克风等本地敏感权限的 App，宿主必须验证其声明，并征得用户二次确认，满足企业级隐私要求。</span></span></li>\n</ol>\n<p><span>一次完整的 MCP Apps 交互，遵循一个精密协同的四步工作流：</span></p>\n<ol>\n<li><span><span style=\"font-size: medium;\"><strong>发现与声明</strong>：LLM 调用的工具定义中，包含了指向 UI 资源的元数据。</span></span></li>\n</ol><ol start=\"2\">\n<li><span><span style=\"font-size: medium;\"><strong>资源获取</strong>：宿主主动从 MCP 服务器拉取 HTML、JS、CSS 等资源包。宿主具备预加载能力，可在 LLM 生成最终答案前启动加载，极大优化感知延迟。</span></span></li>\n</ol><ol start=\"3\">\n<li><span><span style=\"font-size: medium;\"><strong>沙箱化渲染</strong>：宿主创建配置了严格 CSP 和权限的 iframe ，并初始化渲染 UI。</span></span></li>\n</ol><ol start=\"4\">\n<li><span><span style=\"font-size: medium;\"><strong>实时通信</strong>：通过 postMessage 建立宿主与 App 间的 JSON-RPC 通道。App 可调用服务器工具（通过宿主转发），宿主也可将模型生成的新数据推送给 App，形成闭环交互。</span></span></li>\n</ol>\n<h5><span>四、设计哲学与未来意义</span></h5>\n<p><span>MCP Apps 的设计蕴含四大关键目标：<strong>上下文保留</strong>（任务在对话线程内无缝完成）、<strong>双向数据流</strong>（界面与模型逻辑实时同步）、<strong>宿主集成</strong>（可委托宿主执行如 OAuth 登录等重度操作）以及前述的<strong>安全性</strong>。</span></p>\n<p><span>这种架构巧妙地解耦了“表示层”（UI）与“逻辑层”（服务器工具）。它向我们展示了一个诱人的未来：AI 智能体将从一个被动的“聊天框”，蜕变为深度嵌入我们所有数字工具中的<strong>动态、交互式助手</strong>。通过 SEP-1865，MCP 补全了构建复杂生产级 AI 应用的最后一块拼图。</span></p>\n<h5><span>结语</span></h5>\n<p><span>对于开发者和技术决策者而言，拥抱 MCP 及其 Apps 生态已是一种必然趋势。基于 MCP 构建服务，意味着获得了跨平台的能力和进入“智能体原生”时代的标准入场券。尽管在延迟优化、复杂授权和语义理解一致性方面仍有挑战，但通过行业巨头与开源社区的协同推进，MCP 正稳步成为构建下一代<strong>自主、安全、高效</strong>的 AI 应用的坚实基石。未来，与 AI 的协作将不再是简单的问答，而是在一个共享的、可视化的交互空间中共同解决问题。</span></p>\n<p><span>相关链接：</span></p>\n<ul>\n<li>\n<p class=\"text-2xl sm:text-3xl font-bold text-gray-900 tracking-tight dark:text-gray-200 [overflow-wrap:anywhere]\" id=\"page-title\">MCP Apps：<span>https://modelcontextprotocol.io/docs/extensions/apps&nbsp;</span></p>\n</li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 22:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">85</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "基于 Clean Architecture + DDD 的轻量级工作流系统实践",
      "link": "https://www.cnblogs.com/aishangyipiyema/p/19585669",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aishangyipiyema/p/19585669\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 17:48\">\n    <span>基于 Clean Architecture + DDD 的轻量级工作流系统实践</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"基于-clean-architecture--ddd-的轻量级工作流系统实践\">基于 Clean Architecture + DDD 的轻量级工作流系统实践</h1>\n<blockquote>\n<p>本文介绍在一个 .NET 10 + Vue 3 的后台管理系统（Ncp.Admin）中，如何基于现有的 Clean Architecture + DDD 架构，从零构建一套轻量级审批工作流系统，涵盖后端领域建模、CQRS 命令查询、领域事件驱动的业务自动化，以及前端可视化流程节点设计器的完整实现。</p>\n</blockquote>\n<h2 id=\"一项目背景与技术栈\">一、项目背景与技术栈</h2>\n<p><strong>Ncp.Admin</strong> 是一套采用 Clean Architecture 分层架构的后台管理系统，技术栈如下：</p>\n<table>\n<thead>\n<tr>\n<th>层级</th>\n<th>技术选型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>前端</td>\n<td>Vue 3 + Vite + Ant Design Vue (Vben Admin)</td>\n</tr>\n<tr>\n<td>API 层</td>\n<td>ASP.NET Core + FastEndpoints</td>\n</tr>\n<tr>\n<td>应用层</td>\n<td>MediatR (CQRS)、FluentValidation</td>\n</tr>\n<tr>\n<td>领域层</td>\n<td>DDD 聚合根、领域事件、强类型 ID</td>\n</tr>\n<tr>\n<td>基础设施</td>\n<td>EF Core + Pomelo MySQL、Redis、CAP、Hangfire</td>\n</tr>\n</tbody>\n</table>\n<p>项目已经有完善的用户、角色、部门、权限管理模块。本次需求是在现有架构基础上，增加一套 <strong>审批工作流系统</strong>，支持流程定义、流程发起、多级审批、驳回、转办等能力，并实现 <strong>\"新增用户需走审批流程\"</strong> 的业务闭环。</p>\n<h2 id=\"二为什么不用-elsa-workflows\">二、为什么不用 Elsa Workflows？</h2>\n<p>在技术选型阶段，我们对比了 Elsa Workflows 和自建方案：</p>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Elsa Workflows</th>\n<th>自建方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>功能丰富度</td>\n<td>自带可视化设计器、条件分支、定时触发等</td>\n<td>按需实现，功能精简</td>\n</tr>\n<tr>\n<td>学习成本</td>\n<td>需理解 Elsa 活动模型、序列化机制</td>\n<td>复用现有 DDD 模式，团队零成本</td>\n</tr>\n<tr>\n<td>架构耦合</td>\n<td>引入独立的持久化层和运行时</td>\n<td>完全融入现有分层架构</td>\n</tr>\n<tr>\n<td>前端集成</td>\n<td>自带 Blazor/React 设计器，与 Vue 生态不匹配</td>\n<td>原生 Vue 3 + Ant Design Vue</td>\n</tr>\n<tr>\n<td>数据库</td>\n<td>默认 SQLite，MySQL 支持需额外配置</td>\n<td>复用现有 EF Core + MySQL</td>\n</tr>\n<tr>\n<td>.NET 版本</td>\n<td>Elsa 3.x 对 .NET 10 的兼容性需验证</td>\n<td>无兼容性风险</td>\n</tr>\n</tbody>\n</table>\n<p>最终选择了 <strong>自建方案</strong> —— 对于审批类工作流，核心逻辑并不复杂，而自建方案可以完美融入现有 DDD 架构，代码风格统一，维护成本更低。</p>\n<h2 id=\"三领域模型设计\">三、领域模型设计</h2>\n<h3 id=\"31-聚合根划分\">3.1 聚合根划分</h3>\n<p>工作流系统划分为两个聚合：</p>\n<pre><code>WorkflowDefinition (流程定义聚合)\n├── WorkflowDefinitionId    // 强类型 ID\n├── Name / Description / Category\n├── Status (Draft → Published → Archived)\n├── Version\n├── Nodes: ICollection&lt;WorkflowNode&gt;  // 流程节点（值对象集合）\n└── 领域方法: Publish(), Archive(), GetFirstApprovalNode(), GetNextApprovalNode()\n\nWorkflowInstance (流程实例聚合)\n├── WorkflowInstanceId      // 强类型 ID\n├── WorkflowDefinitionId    // 关联定义\n├── BusinessKey / BusinessType\n├── Status (Running → Completed/Rejected/Cancelled)\n├── Variables               // 业务数据 JSON\n├── Tasks: ICollection&lt;WorkflowTask&gt;   // 审批任务集合\n└── 领域方法: CreateTask(), ApproveTask(), RejectTask(), TransferTask(), Complete()\n</code></pre>\n<h3 id=\"32-强类型-id\">3.2 强类型 ID</h3>\n<p>与项目现有模式一致，所有聚合根使用强类型 ID：</p>\n<pre><code class=\"language-csharp\">public partial record WorkflowDefinitionId : IGuidStronglyTypedId;\npublic partial record WorkflowInstanceId : IGuidStronglyTypedId;\n</code></pre>\n<h3 id=\"33-流程定义聚合根\">3.3 流程定义聚合根</h3>\n<p><code>WorkflowDefinition</code> 是流程模板的聚合根，封装了状态管理和 <strong>流程流转的领域逻辑</strong>：</p>\n<pre><code class=\"language-csharp\">public class WorkflowDefinition : Entity&lt;WorkflowDefinitionId&gt;, IAggregateRoot\n{\n    public WorkflowDefinitionStatus Status { get; private set; }\n    public virtual ICollection&lt;WorkflowNode&gt; Nodes { get; init; } = [];\n\n    // 状态变更 + 领域事件\n    public void Publish()\n    {\n        if (Status == WorkflowDefinitionStatus.Published)\n            throw new KnownException(\"流程定义已经发布\", ErrorCodes.WorkflowDefinitionAlreadyPublished);\n\n        Status = WorkflowDefinitionStatus.Published;\n        AddDomainEvent(new WorkflowDefinitionPublishedDomainEvent(this));\n    }\n\n    // 流程流转逻辑下沉到聚合根（而非 Handler）\n    public WorkflowNode? GetFirstApprovalNode()\n        =&gt; GetOrderedApprovalNodes().FirstOrDefault();\n\n    public WorkflowNode? GetNextApprovalNode(string currentNodeName)\n    {\n        var orderedNodes = GetOrderedApprovalNodes();\n        var currentIndex = orderedNodes.ToList().FindIndex(n =&gt; n.NodeName == currentNodeName);\n        return (currentIndex &gt;= 0 &amp;&amp; currentIndex &lt; orderedNodes.Count - 1)\n            ? orderedNodes[currentIndex + 1]\n            : null;\n    }\n}\n</code></pre>\n<blockquote>\n<p><strong>DDD 要点</strong>：流转逻辑（获取首节点、下一节点）放在 <code>WorkflowDefinition</code> 聚合根而非 Command Handler 中。Handler 只负责编排调度，领域逻辑由聚合根保护。</p>\n</blockquote>\n<h3 id=\"34-流程实例聚合根\">3.4 流程实例聚合根</h3>\n<p><code>WorkflowInstance</code> 管理一次具体的审批流程执行：</p>\n<pre><code class=\"language-csharp\">public class WorkflowInstance : Entity&lt;WorkflowInstanceId&gt;, IAggregateRoot\n{\n    public string Variables { get; private set; } = \"{}\"; // 业务数据 JSON\n\n    public WorkflowTask CreateTask(string nodeName, WorkflowTaskType taskType,\n        UserId assigneeId, string assigneeName)\n    {\n        var task = new WorkflowTask(nodeName, taskType, assigneeId, assigneeName);\n        Tasks.Add(task);\n        CurrentNodeName = nodeName;\n        AddDomainEvent(new WorkflowTaskCreatedDomainEvent(this, task));\n        return task;\n    }\n\n    public void ApproveTask(WorkflowTaskId taskId, UserId operatorId, string comment)\n    {\n        var task = Tasks.FirstOrDefault(t =&gt; t.Id == taskId)\n            ?? throw new KnownException(\"未找到该任务\", ErrorCodes.WorkflowTaskNotFound);\n        task.Approve(comment);\n        AddDomainEvent(new WorkflowTaskCompletedDomainEvent(this, task));\n    }\n\n    public void Complete()\n    {\n        Status = WorkflowInstanceStatus.Completed;\n        CompletedAt = DateTimeOffset.UtcNow;\n        AddDomainEvent(new WorkflowInstanceCompletedDomainEvent(this));\n    }\n}\n</code></pre>\n<h2 id=\"四cqrs-命令与查询\">四、CQRS 命令与查询</h2>\n<h3 id=\"41-发起流程命令\">4.1 发起流程命令</h3>\n<p><code>StartWorkflowCommand</code> 演示了 Handler 如何 <strong>编排</strong> 聚合根交互：</p>\n<pre><code class=\"language-csharp\">public class StartWorkflowCommandHandler(\n    IWorkflowDefinitionRepository definitionRepository,\n    IWorkflowInstanceRepository instanceRepository)\n    : ICommandHandler&lt;StartWorkflowCommand, WorkflowInstanceId&gt;\n{\n    public async Task&lt;WorkflowInstanceId&gt; Handle(StartWorkflowCommand request, CancellationToken ct)\n    {\n        var definition = await definitionRepository.GetAsync(request.WorkflowDefinitionId, ct)\n            ?? throw new KnownException(\"未找到流程定义\");\n\n        // 创建实例\n        var instance = new WorkflowInstance(\n            request.WorkflowDefinitionId, definition.Name,\n            request.BusinessKey, request.BusinessType,\n            request.Title, request.InitiatorId, request.InitiatorName,\n            request.Variables, request.Remark);\n\n        await instanceRepository.AddAsync(instance, ct);\n\n        // 通过聚合根领域方法获取第一个审批节点（逻辑在 Definition 中）\n        var firstNode = definition.GetFirstApprovalNode();\n        if (firstNode != null &amp;&amp; long.TryParse(firstNode.AssigneeValue, out var id))\n        {\n            instance.CreateTask(firstNode.NodeName, WorkflowTaskType.Approval,\n                new UserId(id), string.Empty);\n        }\n\n        return instance.Id;\n    }\n}\n</code></pre>\n<h3 id=\"42-审批命令--自动流转\">4.2 审批命令 — 自动流转</h3>\n<pre><code class=\"language-csharp\">public class ApproveTaskCommandHandler(\n    IWorkflowInstanceRepository instanceRepository,\n    IWorkflowDefinitionRepository definitionRepository) : ICommandHandler&lt;ApproveTaskCommand&gt;\n{\n    public async Task Handle(ApproveTaskCommand request, CancellationToken ct)\n    {\n        var instance = await instanceRepository.GetAsync(request.WorkflowInstanceId, ct);\n        instance.ApproveTask(request.TaskId, request.OperatorId, request.Comment);\n\n        var definition = await definitionRepository.GetAsync(instance.WorkflowDefinitionId, ct);\n        var approvedTask = instance.Tasks.First(t =&gt; t.Id == request.TaskId);\n\n        // 领域方法：获取下一节点\n        var nextNode = definition.GetNextApprovalNode(approvedTask.NodeName);\n\n        if (nextNode != null)\n        {\n            // 创建下一个审批任务\n            instance.CreateTask(nextNode.NodeName, WorkflowTaskType.Approval, ...);\n        }\n        else\n        {\n            // 所有节点审批完毕，流程完成\n            instance.Complete();\n        }\n    }\n}\n</code></pre>\n<h2 id=\"五领域事件驱动的业务自动化\">五、领域事件驱动的业务自动化</h2>\n<h3 id=\"51-领域事件定义\">5.1 领域事件定义</h3>\n<pre><code class=\"language-csharp\">public record WorkflowDefinitionPublishedDomainEvent(WorkflowDefinition WorkflowDefinition) : IDomainEvent;\npublic record WorkflowInstanceStartedDomainEvent(WorkflowInstance WorkflowInstance) : IDomainEvent;\npublic record WorkflowInstanceCompletedDomainEvent(WorkflowInstance WorkflowInstance) : IDomainEvent;\npublic record WorkflowTaskCreatedDomainEvent(WorkflowInstance WorkflowInstance, WorkflowTask WorkflowTask) : IDomainEvent;\npublic record WorkflowTaskCompletedDomainEvent(WorkflowInstance WorkflowInstance, WorkflowTask WorkflowTask) : IDomainEvent;\n</code></pre>\n<h3 id=\"52-审批通过后自动执行业务操作\">5.2 审批通过后自动执行业务操作</h3>\n<p>这是整个系统的亮点设计 —— 通过领域事件实现 <strong>流程与业务的解耦</strong>：</p>\n<pre><code class=\"language-csharp\">public class WorkflowInstanceCompletedDomainEventHandler(IMediator mediator, RoleQuery roleQuery)\n    : IDomainEventHandler&lt;WorkflowInstanceCompletedDomainEvent&gt;\n{\n    public async Task Handle(WorkflowInstanceCompletedDomainEvent domainEvent, CancellationToken ct)\n    {\n        var instance = domainEvent.WorkflowInstance;\n        if (instance.Status != WorkflowInstanceStatus.Completed) return;\n\n        switch (instance.BusinessType)\n        {\n            case \"CreateUser\":\n                await HandleCreateUser(instance, ct);\n                break;\n            // 后续可扩展：case \"PurchaseOrder\": ...\n        }\n    }\n\n    private async Task HandleCreateUser(WorkflowInstance instance, CancellationToken ct)\n    {\n        // 从 Variables JSON 中反序列化用户数据\n        var userData = JsonSerializer.Deserialize&lt;CreateUserVariables&gt;(instance.Variables);\n\n        // 复用现有的 CreateUserCommand\n        var cmd = new CreateUserCommand(\n            userData.Name, userData.Email, userData.Password, ...);\n        await mediator.Send(cmd, ct);\n    }\n}\n</code></pre>\n<blockquote>\n<p><strong>设计思想</strong>：前端提交审批时，将完整的业务数据（如用户信息）序列化为 JSON 存入 <code>Variables</code> 字段。审批通过后，领域事件处理器从 <code>Variables</code> 中反序列化数据，调用对应的业务 Command 完成操作。这样 <strong>工作流引擎本身不需要了解任何业务细节</strong>，新增业务类型只需在 <code>switch</code> 中扩展即可。</p>\n</blockquote>\n<h2 id=\"六前端可视化节点设计器\">六、前端可视化节点设计器</h2>\n<h3 id=\"61-设计思路\">6.1 设计思路</h3>\n<p>传统的做法是让用户编辑 JSON 来配置流程节点，这显然不够友好。我们实现了一个 <strong>基于竖向流程图的可视化节点设计器</strong>：</p>\n<pre><code>    [▶ 开始]\n       │\n       ↓\n  ┌──────────────┐\n  │ ✓ 主管审批     │  ← 可编辑卡片\n  │ 类型: 审批     │\n  │ 处理人: 张三   │\n  └──────────────┘\n       │\n      (+)           ← 点击插入新节点\n       │\n  ┌──────────────┐\n  │ ✓ 总监审批     │\n  │ 类型: 审批     │\n  │ 处理人: 李四   │\n  └──────────────┘\n       │\n       ↓\n    [■ 结束]\n</code></pre>\n<h3 id=\"62-组件实现\">6.2 组件实现</h3>\n<p><code>node-designer.vue</code> 是一个完整的 Vue 3 组件，核心设计如下：</p>\n<p><strong>交互能力</strong>：</p>\n<ul>\n<li>添加节点（顶部、中间、底部均可插入）</li>\n<li>删除节点（带 Popconfirm 二次确认）</li>\n<li>上下移动节点（调整审批顺序）</li>\n<li>配置节点属性（名称、类型、处理人类型、处理人）</li>\n<li>已发布流程只读，不可编辑</li>\n</ul>\n<p><strong>视觉设计</strong>：</p>\n<ul>\n<li>开始/结束节点使用渐变色圆形标识</li>\n<li>节点卡片顶部彩色色条标识类型（蓝色=审批、绿色=抄送、橙色=通知）</li>\n<li>连接线带有方向箭头</li>\n<li>悬浮动效（卡片微浮、操作按钮渐显、添加按钮缩放高亮）</li>\n<li>表单双列布局节省空间</li>\n</ul>\n<p><strong>核心代码片段</strong>：</p>\n<pre><code class=\"language-typescript\">// 节点类型视觉配置\nconst nodeTypeConfig: Record&lt;number, { color: string; bg: string; icon: string }&gt; = {\n  1: { color: '#1677ff', bg: '#e6f4ff', icon: '✓' },  // 审批\n  2: { color: '#52c41a', bg: '#f6ffed', icon: '📋' },  // 抄送\n  3: { color: '#faad14', bg: '#fffbe6', icon: '🔔' },  // 通知\n};\n</code></pre>\n<h3 id=\"63-分类下拉选择\">6.3 分类下拉选择</h3>\n<p>流程定义的「分类」字段从自由文本输入改为下拉选择，统一维护枚举值：</p>\n<pre><code class=\"language-typescript\">export function useCategoryOptions() {\n  return [\n    { label: '用户管理', value: 'UserManagement' },\n    { label: '角色管理', value: 'RoleManagement' },\n    { label: '请假审批', value: 'LeaveRequest' },\n    { label: '采购审批', value: 'PurchaseOrder' },\n    { label: '报销审批', value: 'Reimbursement' },\n    { label: '通用流程', value: 'General' },\n  ];\n}\n</code></pre>\n<p>前端查找对应流程定义时使用枚举值精确匹配，不再依赖中文字符串：</p>\n<pre><code class=\"language-typescript\">const userCreateDef = definitions.find(\n  (d) =&gt; d.category === 'UserManagement',\n);\n</code></pre>\n<h2 id=\"七操作指南如何创建流程与审批\">七、操作指南：如何创建流程与审批</h2>\n<p>下面从使用角度说明：<strong>如何创建一条自定义工作流程</strong>，以及 <strong>审批人在哪里处理待办</strong>。</p>\n<h3 id=\"71-如何创建一个自定义工作流程\">7.1 如何创建一个自定义工作流程</h3>\n<ol>\n<li>进入 <strong>工作流管理 → 流程定义</strong>。</li>\n<li>点击 <strong>新增</strong>，打开流程定义表单。</li>\n<li>填写 <strong>流程名称</strong>、<strong>分类</strong>（从下拉选择，如「用户管理」「请假审批」等）、<strong>描述</strong>。</li>\n<li>在 <strong>流程节点设计</strong> 区域配置审批节点：\n<ul>\n<li>点击「+ 添加节点」或节点之间的「+」插入节点；</li>\n<li>为每个节点填写 <strong>节点名称</strong>，选择 <strong>节点类型</strong>（审批 / 抄送 / 通知）；</li>\n<li>选择 <strong>处理人类型</strong>（指定用户、指定角色、部门主管、发起人自选），若为指定用户或指定角色，再选择具体 <strong>处理人</strong>；</li>\n<li>通过 <strong>上移 / 下移</strong> 调整节点顺序，通过 <strong>删除</strong> 移除节点。</li>\n</ul>\n</li>\n<li>保存后，在列表中找到该流程，点击 <strong>发布</strong>。只有已发布的流程才能被发起。</li>\n</ol>\n<p><img alt=\"流程定义列表与编辑\" src=\"https://img2024.cnblogs.com/blog/553504/202602/553504-20260206174444280-259695173.png\" /></p>\n<p><em>流程定义列表：可新增、编辑、发布、归档；编辑时在下方进行流程节点设计。</em></p>\n<h3 id=\"72-在哪里审批\">7.2 在哪里审批</h3>\n<p>审批人的待办任务在 <strong>工作流管理 → 我的待办</strong> 中处理：</p>\n<ol>\n<li>登录后进入 <strong>工作流管理</strong> 菜单，点击 <strong>我的待办</strong>。</li>\n<li>列表中展示当前用户作为处理人的所有待审批任务（流程标题、流程名称、发起人、节点名称等）。</li>\n<li>点击 <strong>办理</strong> 进入详情，可查看流程信息与业务数据（如用户申请内容），进行 <strong>通过</strong>、<strong>驳回</strong> 或 <strong>转办</strong> 操作。</li>\n<li>已处理的任务可在 <strong>我的已办</strong> 中查看历史记录。</li>\n</ol>\n<p><img alt=\"我的待办\" src=\"https://img2024.cnblogs.com/blog/553504/202602/553504-20260206174503542-837619307.png\" /></p>\n<p><em>我的待办：审批人在此处理待审批任务。</em></p>\n<h2 id=\"八新增用户走审批流程--完整链路\">八、新增用户走审批流程 — 完整链路</h2>\n<p>这是一个典型的端到端示例，展示工作流如何与具体业务打通：</p>\n<h3 id=\"81-前端--提交审批\">8.1 前端 — 提交审批</h3>\n<p>在 <strong>系统管理 → 用户管理</strong> 的新增用户表单中，提供「提交审批」按钮。用户填写完账号、姓名、角色等信息后，可选择直接保存（若有权限）或 <strong>提交审批</strong>。点击「提交审批」后：</p>\n<ol>\n<li>验证表单数据</li>\n<li>查询已发布的流程定义，匹配分类为「用户管理」的定义</li>\n<li>将用户表单数据 JSON 序列化为 <code>variables</code></li>\n<li>调用 <code>startWorkflow</code> API 发起审批</li>\n</ol>\n<p><img alt=\"用户管理-提交审批\" src=\"https://img2024.cnblogs.com/blog/553504/202602/553504-20260206174554266-1617952302.png\" /></p>\n<p><em>新增用户时可选择「提交审批」，进入已配置的用户管理审批流程。</em></p>\n<pre><code class=\"language-typescript\">async function onSubmitForApproval() {\n  const { valid } = await formApi.validate();\n  if (!valid) return;\n\n  const definitions = await getPublishedDefinitions();\n  const userCreateDef = definitions.find(d =&gt; d.category === 'UserManagement');\n\n  const formValues = await formApi.getValues();\n  const variables = JSON.stringify({\n    name: formValues.name,\n    email: formValues.email,\n    password: formValues.password,\n    realName: formValues.realName,\n    roleIds: formValues.roleIds || [],\n    // ... 其他字段\n  });\n\n  await startWorkflow({\n    workflowDefinitionId: userCreateDef.id,\n    businessKey: `user-create-${Date.now()}`,\n    businessType: 'CreateUser',\n    title: `新增用户申请 - ${formValues.realName}`,\n    variables,\n  });\n}\n</code></pre>\n<h3 id=\"82-后端--审批流转\">8.2 后端 — 审批流转</h3>\n<pre><code>提交审批 → StartWorkflowCommand\n         → 创建 WorkflowInstance\n         → Definition.GetFirstApprovalNode() → 创建第一个 Task\n\n审批通过 → ApproveTaskCommand\n         → Instance.ApproveTask()\n         → Definition.GetNextApprovalNode()\n         → 有下一节点 → 创建新 Task\n         → 无下一节点 → Instance.Complete()\n                       → 触发 WorkflowInstanceCompletedDomainEvent\n\n领域事件 → WorkflowInstanceCompletedDomainEventHandler\n         → BusinessType == \"CreateUser\"\n         → 反序列化 Variables → CreateUserCommand → 用户创建成功\n</code></pre>\n<h3 id=\"83-流程图\">8.3 流程图</h3>\n<pre><code>[用户填写表单] → [提交审批] → [主管审批] → [总监审批] → [审批通过]\n                                                         ↓\n                                                   [领域事件触发]\n                                                         ↓\n                                                  [自动创建用户]\n</code></pre>\n<h2 id=\"九架构亮点总结\">九、架构亮点总结</h2>\n<h3 id=\"91-ddd-原则贯穿始终\">9.1 DDD 原则贯穿始终</h3>\n<table>\n<thead>\n<tr>\n<th>原则</th>\n<th>实践</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>聚合根封装</td>\n<td>状态变更、流转逻辑、业务规则校验均在聚合根内</td>\n</tr>\n<tr>\n<td>领域事件</td>\n<td>每个关键状态变更都发布对应领域事件</td>\n</tr>\n<tr>\n<td>强类型 ID</td>\n<td><code>WorkflowDefinitionId</code>、<code>WorkflowInstanceId</code> 避免 ID 误用</td>\n</tr>\n<tr>\n<td>值对象</td>\n<td><code>WorkflowNode</code> 作为 <code>WorkflowDefinition</code> 的子实体集合</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"92-cqrs-分离清晰\">9.2 CQRS 分离清晰</h3>\n<ul>\n<li><strong>Command 侧</strong>：<code>StartWorkflowCommand</code>、<code>ApproveTaskCommand</code>、<code>RejectTaskCommand</code> 等，Handler 只做编排</li>\n<li><strong>Query 侧</strong>：<code>WorkflowDefinitionQuery</code>、<code>WorkflowInstanceQuery</code>，使用 <code>AsNoTracking()</code> 优化性能，配合 <code>IMemoryCache</code> 缓存高频数据</li>\n</ul>\n<h3 id=\"93-业务与流程解耦\">9.3 业务与流程解耦</h3>\n<pre><code>工作流引擎（通用）          业务处理（特定）\n─────────────────         ─────────────────\nWorkflowInstance           ↗ CreateUserCommand\n  .Complete()              │\n  → DomainEvent  ──────→  EventHandler (switch BusinessType)\n                           │\n                           ↘ 其他业务 Command\n</code></pre>\n<p>新增业务类型时：</p>\n<ol>\n<li>前端新增提交入口，传入 <code>businessType</code> 和 <code>variables</code></li>\n<li>后端在 <code>WorkflowInstanceCompletedDomainEventHandler</code> 的 <code>switch</code> 中增加分支</li>\n<li>流程引擎本身无需任何修改</li>\n</ol>\n<h3 id=\"94-前端体验优化\">9.4 前端体验优化</h3>\n<ul>\n<li>可视化节点设计器替代 JSON 编辑，降低使用门槛</li>\n<li>分类枚举化，避免自由文本带来的匹配错误</li>\n<li>i18n 国际化支持中英文</li>\n<li>已发布流程自动锁定为只读模式</li>\n</ul>\n<h2 id=\"十后续规划\">十、后续规划</h2>\n<ol>\n<li><strong>条件分支节点</strong>：根据表单字段值走不同审批路径</li>\n<li><strong>会签/或签</strong>：一个节点可配置多个审批人</li>\n<li><strong>审批催办</strong>：基于 Hangfire 定时检查超时任务</li>\n<li><strong>流程统计看板</strong>：审批效率、瓶颈节点分析</li>\n<li><strong>移动端适配</strong>：审批任务推送 + 移动端快速审批</li>\n</ol>\n<h2 id=\"十一结语\">十一、结语</h2>\n<p>一套好的工作流系统，核心不在于功能有多丰富，而在于 <strong>与现有架构的融合度</strong> 和 <strong>业务扩展的便捷性</strong>。</p>\n<p>本次实践证明，在 Clean Architecture + DDD 的项目中，自建轻量级工作流是完全可行的。通过聚合根封装流转逻辑、领域事件驱动业务自动化、CQRS 分离读写关注点，我们用不到 2000 行后端代码就实现了一套 <strong>可用、可扩展、架构一致</strong> 的审批系统。</p>\n<p>前端方面，一个 600 行的 Vue 组件就搭建起了直观的可视化节点设计器，配合 Ant Design Vue 的组件库，用户体验也做到了开箱即用。</p>\n<p><strong>不是所有场景都需要引入重量级的工作流引擎，适合的才是最好的。</strong></p>\n<hr />\n<p>项目源码地址：<a href=\"https://github.com/zhouda1fu/Ncp.Admin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/zhouda1fu/Ncp.Admin</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 17:48</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aishangyipiyema\">红泥巴煮雪</a>&nbsp;\n阅读(<span id=\"post_view_count\">161</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为博客园注入现代 UI 体验：shadcn 皮肤上线",
      "link": "https://www.cnblogs.com/guangzan/p/19585389",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/guangzan/p/19585389\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 17:45\">\n    <span>为博客园注入现代 UI 体验：shadcn 皮肤上线</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"背景\">背景</h2>\n<p><em>tona-shadcn</em> 是基于 <a href=\"https://github.com/guangzan/tona\" rel=\"noopener nofollow\" target=\"_blank\">tona</a> 和现代 UI 组件系统 <strong>shadcn/ui</strong> 的博客园皮肤实现，它让传统博客园主题具备一致的设计语言、深色模式支持和响应式布局能力。其价值在于将成熟设计组件与博客园生态结合，为内容创作者提供既专业又现代的阅读体验。</p>\n<h2 id=\"使用方式\">使用方式</h2>\n<ol>\n<li>进入博客园后台「设置」页面；</li>\n<li>博客皮肤选择「Custom」；</li>\n<li>勾选「禁用模板默认CSS」，并填入此 <a href=\"https://files.cnblogs.com/files/guangzan/shadcn.css?t=1770367803&amp;download=true\" target=\"_blank\">CSS文件</a> 中的代码；</li>\n<li>在「页首 HTML」中填写以下内容（可根据自身需求修改），完成后保存即可生效。</li>\n</ol>\n<pre><code class=\"language-html\">&lt;script&gt;\n    const bio = `\n- 我是一名**前端工程师**，练习时长两年半！**，xxxxx。\n- 熟悉 **Next.js**、**Umi**、**React**、**TypeScript**​ 等前端技术，能够构建高质量、以用户为中心的应用。\n- [Tona](https://github.com/guangzan/tona) 的创建者：专为博客园设计的皮肤开发框架。\n  - 在 [Github](https://github.com/guangzan/tona) 上获得 **200+ stars**\n  - [文档](https://www.yuque.com/r/awescnb/books) 有 **180k+ 阅读量**\n- 为 [VueUse](https://vueuse.org/)、[Windi CSS](https://windicss.org/) 做过一点微小的贡献。\n`;\n\n  const BASE_URL = \"https://blog-static.cnblogs.com/files/guangzan/\";\n\n  const groups = [\n    {\n      group: \"技术栈\",\n      items: [\n        {\n          title: \"TypeScript\",\n          href: \"https://www.typescriptlang.org/\",\n          categories: [\"Language\"],\n          lightIcon: `${BASE_URL}typescript.svg`,\n        },\n      ],\n    },\n    {\n      group: \"我喜爱的工具\",\n      items: [\n        {\n          title: \"Git\",\n          href: \"https://git-scm.com/\",\n          categories: [\"Tools\"],\n          lightIcon: `${BASE_URL}git.svg`,\n        },\n      ],\n    },\n  ];\n\n  window.opts = {\n    theme: {\n      avatar: 'https://pic.cnblogs.com/avatar/1501373/20200819130243.png',\n    },\n    about: {\n      enable: true,\n      bio,\n      tags: [\n        'Frontend Engineer',\n        '热爱创造的用户体验工程师',\n      ]\n    },\n    itemGroups: {\n      enable: true,\n      groups,\n    },\n  };\n&lt;/script&gt;\n&lt;script src=\"https://blog-static.cnblogs.com/files/guangzan/shadcn.js?t=1770370892\" fetchpriority=\"high\" defer&gt;&lt;/script&gt;\n</code></pre>\n<h2 id=\"设计与实现\">设计与实现</h2>\n<p>Inspired by tailwindcss.com/ui.shadcn.com/voidzero.dev/chanhdai.com.</p>\n<ul>\n<li><strong>Preact</strong>：使用 Preact 轻量级视图库。</li>\n<li><strong>Tailwind CSS</strong>：使用 Tailwind CSS 编写样式。</li>\n<li><strong>Base UI</strong>：使用 Base UI 作为组件原语。</li>\n<li><strong>shadcn/ui</strong>：使用 shadcn/ui 设计体系。</li>\n</ul>\n<h2 id=\"参考资料\">参考资料</h2>\n<ul>\n<li><a href=\"https://github.com/guangzan/tona\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/guangzan/tona</a> Tona 源码仓库。</li>\n<li><a href=\"https://github.com/guangzan/tona/tree/main/themes/shadcn\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/guangzan/tona/tree/main/themes/shadcn</a> 皮肤源码目录。</li>\n</ul>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 17:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/guangzan\">guangzan</a>&nbsp;\n阅读(<span id=\"post_view_count\">316</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "双系统安装完整指南——以双Win11为例",
      "link": "https://www.cnblogs.com/yuanjiejie/p/19585584",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yuanjiejie/p/19585584\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 17:27\">\n    <span>双系统安装完整指南——以双Win11为例</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在一台电脑安装多个系统实现工作、生活使用的完全隔离，\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"双系统安装完整指南以双win11为例\">双系统安装完整指南——以双Win11为例</h1>\n<blockquote>\n<p>适用于：同一台电脑安装两个 Windows 11 系统<br />\n适合场景：<br />\n- 开发 / 测试 / 多环境隔离<br />\n- 工作系统与娱乐系统彻底分离<br />\n- 区别于 Windows 用户级隔离（软件路径、配置混乱）<br />\n- 区别于虚拟机 / 云桌面（无性能损耗）<br />\n- 系统级强隔离，互不干扰</p>\n</blockquote>\n<blockquote>\n<p>本文默认硬件支持 Windows 11（TPM 2.0、Secure Boot、UEFI）<br />\n关键步骤：制作启动盘、备份恢复驱动、磁盘分区、设置U盘启动、设置系统引导</p>\n</blockquote>\n<hr />\n<h2 id=\"一安装前的准备工作\">一、安装前的准备工作</h2>\n<h3 id=\"1-硬件与系统要求\">1. 硬件与系统要求</h3>\n<ul>\n<li>CPU：支持 Windows 11（Intel 8 代 / AMD Ryzen 2000 及以上）</li>\n<li>主板：\n<ul>\n<li>支持 <strong>UEFI</strong></li>\n<li>支持 <strong>TPM 2.0</strong></li>\n</ul>\n</li>\n<li>磁盘：\n<ul>\n<li>GPT 分区格式</li>\n<li>至少 <strong>120GB 空闲空间</strong>（建议每个系统 ≥ 80GB）</li>\n</ul>\n</li>\n<li>一个 ≥ 8GB 的 U 盘</li>\n</ul>\n<hr />\n<h3 id=\"2-制作-windows-启动-u-盘\">2. 制作 Windows 启动 U 盘</h3>\n<blockquote>\n<p>使用官方 Media Creation Tool 制作的启动盘默认支持 UEFI + GPT，<br />\n无需额外设置分区类型，兼容性和稳定性最高。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>工具</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>官方 Media Creation Tool（建议）</td>\n<td>制作系统安装启动盘</td>\n</tr>\n</tbody>\n</table>\n<p>系统安装启动U盘：<br />\n（微软官网）<a href=\"https://www.microsoft.com/zh-cn/software-download/windows11?3ffbea20-eb11-4a96-85d6-f356b820d828=True&amp;4cd9df4f-deef-4431-9497-a04303f34986=True\" rel=\"noopener nofollow\" target=\"_blank\">https://www.microsoft.com/zh-cn/software-download/windows11?3ffbea20-eb11-4a96-85d6-f356b820d828=True&amp;4cd9df4f-deef-4431-9497-a04303f34986=True</a></p>\n<p><img alt=\"image-20260206104451878\" src=\"https://img2024.cnblogs.com/blog/2871381/202602/2871381-20260206171736631-400678532.png\" /></p>\n<p>推荐使用官网的【创建Windows11安装媒体】下载Media Creation Tool工具，使用该工具制作系统启动安装U盘，也可以自行下载要安装的系统ISO镜像制作启动U盘，建议安装与已激活系统同版本的操作系统（家庭版/专业版）以便于免激活（系统许可证基于主板绑定）</p>\n<p>U 盘 ≥ 8GB（制作过程会清空数据！！！）</p>\n<hr />\n<h3 id=\"3-备份驱动重要\">3. 备份驱动（重要）</h3>\n<blockquote>\n<p>双系统安装后，新系统极易出现：<br />\n无线网卡不可用<br />\n有线网卡驱动缺失<br />\n声卡、触控板异常</p>\n</blockquote>\n<p>提前备份 = 安装后 1 分钟恢复</p>\n<table>\n<thead>\n<tr>\n<th>工具</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>驱动精灵/厂商驱动</td>\n<td>驱动丢失时还原驱动</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"31-方式一使用第三方工具备份操作简单\">3.1 方式一：使用第三方工具备份（操作简单）</h4>\n<p>(驱动管理软件 驱动精灵)<a href=\"https://www.drivergenius.com/zhuangji/\" rel=\"noopener nofollow\" target=\"_blank\">https://www.drivergenius.com/zhuangji/</a></p>\n<p>需备份当前系统驱动以还原或在电脑厂商官网下载驱动安装程序，推荐使用驱动备份软件（驱动精灵）一键将本系统驱动备份，拷贝备份目录到安装U盘以便于恢复</p>\n<h4 id=\"32-方式二使用-dism-备份所有驱动最稳强烈推荐\">3.2 方式二：使用 DISM 备份所有驱动（最稳，强烈推荐）</h4>\n<blockquote>\n<p>该方式无需联网，适合新系统无网卡驱动的场景</p>\n</blockquote>\n<p>在当前正常系统中，以管理员身份打开 CMD / PowerShell：</p>\n<pre><code class=\"language-powershell\">mkdir D:\\DriverBackup\ndism /online /export-driver /destination:D:\\DriverBackup\n\n</code></pre>\n<p>说明：<br />\nD:\\DriverBackup 建议放在 非系统分区<br />\n会备份：网卡 声卡 芯片组 触控板等 OEM 驱动</p>\n<p>安装完新系统后：</p>\n<pre><code class=\"language-powershell\">dism /online /add-driver /driver:D:\\DriverBackup /recurse\n\n</code></pre>\n<h4 id=\"33-方式三使用电脑品牌厂商的官方驱动安装软件兜底方案\">3.3 方式三：使用电脑品牌厂商的官方驱动安装软件（兜底方案）</h4>\n<blockquote>\n<p>恢复安装驱动时需联网，在网卡驱动丢失的情况下可能无法使用，建议搭配前两种方案食用，优先恢复网卡驱动，保证能联网再说</p>\n</blockquote>\n<p>官网（以【联想】为例）：<a href=\"https://newsupport.lenovo.com.cn/driveDownloads_index.html?ltv_source=L0000000788T0004&amp;pmf_source=Z00045291T004\" rel=\"noopener nofollow\" target=\"_blank\">https://newsupport.lenovo.com.cn/driveDownloads_index.html?ltv_source=L0000000788T0004&amp;pmf_source=Z00045291T004</a></p>\n<p><img alt=\"image-20260206113344878\" src=\"https://img2024.cnblogs.com/blog/2871381/202602/2871381-20260206171830148-1975446772.png\" /></p>\n<h3 id=\"4-磁盘分区重要步骤\">4. 磁盘分区（重要步骤）</h3>\n<p><img alt=\"image-20260206110747115\" src=\"https://img2024.cnblogs.com/blog/2871381/202602/2871381-20260206171932799-1515427475.png\" /></p>\n<p>开始菜单右击-&gt;磁盘管理，选中一块大的分区-&gt;压缩卷，留出给新系统的空间（建议至少120G）</p>\n<hr />\n<h2 id=\"二开始安装\">二、开始安装</h2>\n<h3 id=\"1-bios-设置为-u-盘启动\">1. BIOS 设置为 U 盘启动</h3>\n<h4 id=\"11-进入-bios--boot-menu\">1.1 进入 BIOS / Boot Menu</h4>\n<p>常见按键（开机瞬间连续按）：部分笔记本需搭配Fn键，自行百度</p>\n<table>\n<thead>\n<tr>\n<th>品牌</th>\n<th>BIOS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>联想</td>\n<td>F2</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"12设置-u-盘为第一启动项\">1.2设置 U 盘为第一启动项</h4>\n<blockquote>\n<p>⚠ 注意：</p>\n<ul>\n<li>不要开启 Legacy / CSM 模式</li>\n<li>不要随意修改 SATA Mode（AHCI / RAID）</li>\n<li>不确定的选项保持默认</li>\n</ul>\n</blockquote>\n<p>设置启动优先级Boot Priority 中将 U 盘启动方式选项置顶</p>\n<p>保存并退出（F10）</p>\n<h3 id=\"2-系统安装程序运行\">2. 系统安装程序运行</h3>\n<p>根据安装程序指引进行，选择之前磁盘分区时压缩卷留出的空间进行安装，注意：务必选择正确的分区安装系统，不要对EFI等其他重要分区进行任何操作！！！</p>\n<p>安装分区选择判断方法：</p>\n<ul>\n<li>通过分区大小识别</li>\n<li>通过“未分配空间 / 新创建分区”识别</li>\n</ul>\n<p>⚠ 强调：</p>\n<ul>\n<li>不要删除 EFI 分区</li>\n<li>不要新建 EFI 分区</li>\n<li>双系统只共享一个 EFI 分区</li>\n</ul>\n<p>⏰安装程序中提示的将清空所有数据是针对你选择的安装分区而言，保证选择的安装分区正确不会丢失数据</p>\n<h2 id=\"三安装完成后处理\">三、安装完成后处理</h2>\n<blockquote>\n<p>⚠安装完成重启后并没有出现选择系统的界面，可能是系统引导时间未设置默认为0的原因，使用msconfig打开系统引导设置界面调整即可；也可以直接通过命令修改</p>\n</blockquote>\n<h3 id=\"1-设置系统引导程序\">1. 设置系统引导程序</h3>\n<h4 id=\"11-方式一系统gui-工具无法重命名\">1.1 方式一：系统GUI 工具（无法重命名）</h4>\n<p><img alt=\"image-20260206153049367\" src=\"https://img2024.cnblogs.com/blog/2871381/202602/2871381-20260206172005379-503308437.png\" /></p>\n<p>Win + R → msconfig → 引导 -&gt;  超时<br />\n设置系统引导时间为10s左右</p>\n<h4 id=\"12-方式二通过命令\">1.2 方式二：通过命令</h4>\n<p>使用管理员权限打开命令提示符，查看当前引导配置：</p>\n<pre><code class=\"language-powershell\">bcdedit\n</code></pre>\n<p><img alt=\"image-20260206153846680\" src=\"https://img2024.cnblogs.com/blog/2871381/202602/2871381-20260206172106105-1002287630.png\" /></p>\n<p>设置启动菜单等待时间（超时）修改为 10 秒：</p>\n<pre><code class=\"language-powershell\">bcdedit /timeout 10\n</code></pre>\n<p>设置默认启动系统</p>\n<pre><code class=\"language-powershell\">bcdedit /default {current}\n</code></pre>\n<p>修改启动菜单名称<br />\n假设其中一个标识符为 {current}：</p>\n<pre><code class=\"language-powershell\">bcdedit /set {current} description \"Windows 11 - Main\"\n</code></pre>\n<p>另一个：</p>\n<pre><code class=\"language-powershell\">bcdedit /set {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} description \"Windows 11 - Backup\"\n</code></pre>\n<h4 id=\"13-方式三第三方工具easybcd\">1.3 方式三：第三方工具（EasyBCD）</h4>\n<blockquote>\n<p>EasyBCD是由NeoSmart Technologies开发的系统引导配置工具，主要用于管理Windows操作系统的启动配置数据（BCD），解决多系统引导兼容性问题；<br />\n建议仅用于引导配置查看与临时调整；<br />\n日常维护推荐使用系统自带工具（bcdedit / msconfig）。</p>\n</blockquote>\n<p>官网下载：<a href=\"https://neosmart.net/EasyBCD/\" rel=\"noopener nofollow\" target=\"_blank\">https://neosmart.net/EasyBCD/</a><br />\n<img alt=\"image-20260206152950078\" src=\"https://img2024.cnblogs.com/blog/2871381/202602/2871381-20260206172142727-381961332.png\" /></p>\n<h3 id=\"2-恢复驱动\">2. 恢复驱动</h3>\n<blockquote>\n<p>此时进入新安装的系统，网络和声音等设置可能无法使用，别担心，这是驱动未完成安装的表现，还原恢复驱动即可</p>\n</blockquote>\n<p>根据安装前准备工作中备份驱动的操作还原系统驱动</p>\n<h3 id=\"3-隐藏盘符建议\">3. 隐藏盘符（建议）</h3>\n<blockquote>\n<p>此时旧系统和新安装的系统中均可以看到所有的盘符，为了便于理解和防止误操作，建议在对应系统下隐藏其他的盘符，这样每个系统只管理各自的空间，隐藏非本系统盘符可避免：<br />\n- 误删对方系统文件<br />\n- 系统更新写入其他系统分区<br />\n- 快速启动导致的 NTFS 锁盘问题</p>\n</blockquote>\n<blockquote>\n<p>不建议修改新系统中C：盘符的名称，是系统和第三方工具等的默认选择路径，删除其他盘符保留C：即可</p>\n</blockquote>\n<p>步骤：</p>\n<ul>\n<li>删除旧系统中【此电脑】界面中新出现的盘符</li>\n<li>删除新系统中除C：以外的盘符</li>\n</ul>\n<p>操作：<br />\n开始菜单右击-&gt; 磁盘管理-&gt; 列表中选择对应的卷右击-&gt; 更改驱动器号和路径-&gt; 删除<br />\n⚠不是直接右击选择删除卷，将造成数据丢失<br />\n⚠务必确认选择的卷是否正确</p>\n<h3 id=\"4-完成\">4. 完成</h3>\n<blockquote>\n<p>至此，双系统在同一台物理设备上实现了真正的系统级隔离🎉🎉🎉🎉🎉<br />\n合理规划分区、引导与驱动，是双系统长期稳定运行的关键。</p>\n</blockquote>\n\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/yuanjiejie/\" target=\"_blank\">杰哥来了</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/yuanjiejie/p/19585584\" target=\"_blank\">https://www.cnblogs.com/yuanjiejie/p/19585584</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 17:27</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yuanjiejie\">杰哥来了</a>&nbsp;\n阅读(<span id=\"post_view_count\">103</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "长上下文模型是否会取代 RAG？以 Claude Opus 4.6 为例的架构思考",
      "link": "https://www.cnblogs.com/poloapi/p/19585448",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/poloapi/p/19585448\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 17:07\">\n    <span>长上下文模型是否会取代 RAG？以 Claude Opus 4.6 为例的架构思考</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近在测试 Anthropic 发布的 Claude Opus 4.6 时，一个问题反复出现：</p>\n<blockquote>\n<p>当模型支持百万级上下文窗口后，我们还需要 RAG 吗？</p>\n</blockquote>\n<p>这个问题并不只是技术好奇心，而是一个真实的架构选择问题。</p>\n<p>如果长上下文能力足够强，是否可以直接“全文喂给模型”？<br />\nRAG（Retrieval-Augmented Generation）是否会逐渐失去意义？</p>\n<p>本文从工程角度聊聊这个问题。</p>\n<hr />\n<p><strong>一、RAG 解决的到底是什么问题？</strong></p>\n<p>RAG 本质上解决的是两个问题：</p>\n<ol>\n<li>\n<p>模型上下文窗口有限</p>\n</li>\n<li>\n<p>模型缺乏外部知识</p>\n</li>\n</ol>\n<p>传统做法是：</p>\n<ul>\n<li>\n<p>文档切片</p>\n</li>\n<li>\n<p>向量化</p>\n</li>\n<li>\n<p>相似度检索</p>\n</li>\n<li>\n<p>拼接上下文</p>\n</li>\n<li>\n<p>再交给模型推理</p>\n</li>\n</ul>\n<p>这个流程的优点是：</p>\n<ul>\n<li>\n<p>成本可控</p>\n</li>\n<li>\n<p>延迟可控</p>\n</li>\n<li>\n<p>可扩展性强</p>\n</li>\n</ul>\n<p>但缺点也很明显：</p>\n<ul>\n<li>\n<p>切片破坏语义完整性</p>\n</li>\n<li>\n<p>跨段逻辑容易丢失</p>\n</li>\n<li>\n<p>全局一致性难以保证</p>\n</li>\n</ul>\n<hr />\n<p><strong>二、长上下文能力带来了什么变化？</strong></p>\n<p>Claude Opus 4.6 强调的“百万级上下文窗口”，本质是：</p>\n<blockquote>\n<p>允许一次性输入更大规模文本，并保持推理能力。</p>\n</blockquote>\n<p>理论上，这意味着：</p>\n<ul>\n<li>\n<p>可以直接 ingest 整份合同</p>\n</li>\n<li>\n<p>可以直接 ingest 整本技术手册</p>\n</li>\n<li>\n<p>可以直接 ingest 长序列日志</p>\n</li>\n</ul>\n<p>这似乎绕过了“检索 + 拼接”的流程。</p>\n<p>但工程问题在于：</p>\n<blockquote>\n<p>是否所有场景都值得这么做？</p>\n</blockquote>\n<hr />\n<p><strong>三、长上下文是否等于不需要检索？</strong></p>\n<p>很多人第一反应是：</p>\n<p>“既然能装下，就全部放进去。”</p>\n<p>但从工程角度看，有几个现实问题：</p>\n<p>1️⃣ 计算成本</p>\n<p>输入越长：</p>\n<ul>\n<li>\n<p>Token 成本线性增长</p>\n</li>\n<li>\n<p>推理延迟上升</p>\n</li>\n<li>\n<p>并发能力下降</p>\n</li>\n</ul>\n<p>如果是高 QPS 场景，直接使用超长窗口会迅速放大成本。</p>\n<p>2️⃣ 注意力分布问题</p>\n<p>即使模型支持百万上下文，也并不意味着：</p>\n<ul>\n<li>\n<p>每个 token 都被均匀关注</p>\n</li>\n<li>\n<p>所有信息都等权参与推理</p>\n</li>\n</ul>\n<p>在极长文本中，模型仍然存在“关注分布偏移”。</p>\n<p>换句话说：</p>\n<p>长窗口 ≠ 完美全局理解。</p>\n<p>3️⃣ 可维护性</p>\n<p>RAG 的优势在于：</p>\n<ul>\n<li>\n<p>文档可单独更新</p>\n</li>\n<li>\n<p>向量库可独立维护</p>\n</li>\n<li>\n<p>结构清晰</p>\n</li>\n</ul>\n<p>而“全文输入”方案：</p>\n<ul>\n<li>\n<p>文档版本变化会直接影响推理</p>\n</li>\n<li>\n<p>成本难以预估</p>\n</li>\n<li>\n<p>缺乏局部优化能力</p>\n</li>\n</ul>\n<hr />\n<p><strong>四、一个更现实的架构趋势：混合模式</strong></p>\n<p>在测试 Claude Opus 4.6 的过程中，更合理的模式其实是：</p>\n<blockquote>\n<p>RAG + 长上下文 的混合架构。</p>\n</blockquote>\n<p>具体做法：</p>\n<ol>\n<li>\n<p>先通过检索缩小范围</p>\n</li>\n<li>\n<p>在必要场景下使用长窗口增强全局一致性</p>\n</li>\n<li>\n<p>对关键任务进行全文级推理</p>\n</li>\n</ol>\n<p>也就是说：</p>\n<p>长上下文不是替代 RAG，而是补强 RAG。</p>\n<hr />\n<p><strong>五、什么时候可以考虑弱化 RAG？</strong></p>\n<p>存在一些场景，确实可以降低对 RAG 的依赖：</p>\n<ul>\n<li>\n<p>法律合同全局一致性校验</p>\n</li>\n<li>\n<p>长日志因果链分析</p>\n</li>\n<li>\n<p>大型代码库整体结构理解</p>\n</li>\n</ul>\n<p>这些任务强调“全局逻辑”，而不是“局部检索”。</p>\n<p>在这种情况下，Claude Opus 4.6 的优势会更明显。</p>\n<hr />\n<p><strong>六、真正的关键不在模型，而在架构抽象层</strong></p>\n<p>无论使用 RAG 还是长上下文，都有一个前提：</p>\n<blockquote>\n<p>模型调用必须被抽象出来。</p>\n</blockquote>\n<p>如果业务逻辑直接绑定某个模型接口，一旦：</p>\n<ul>\n<li>\n<p>成本上涨</p>\n</li>\n<li>\n<p>性能变化</p>\n</li>\n<li>\n<p>模型替换</p>\n</li>\n</ul>\n<p>整个系统就会受到影响。</p>\n<p>更合理的做法是：</p>\n<ul>\n<li>\n<p>设计模型调用层</p>\n</li>\n<li>\n<p>支持模型切换</p>\n</li>\n<li>\n<p>支持任务分级路由</p>\n</li>\n</ul>\n<p>在这种架构下，Claude Opus 4.6 只是一个能力选项，而不是架构核心。</p>\n<hr />\n<p><strong>七、结论：长上下文不会取代 RAG</strong></p>\n<p>从工程角度看：</p>\n<ul>\n<li>\n<p>RAG 解决的是“知识获取效率问题”</p>\n</li>\n<li>\n<p>长上下文解决的是“全局一致性问题”</p>\n</li>\n</ul>\n<p>两者不是竞争关系，而是互补关系。</p>\n<p>Claude Opus 4.6 的百万上下文能力确实扩展了模型边界，但它并不会让 RAG 消失。</p>\n<p>更可能的未来是：</p>\n<ul>\n<li>\n<p>轻量任务 → 检索增强</p>\n</li>\n<li>\n<p>高复杂度任务 → 长窗口增强</p>\n</li>\n<li>\n<p>架构层面保持可替换性</p>\n</li>\n</ul>\n<p>模型能力在进步，但架构设计仍然决定系统上限。</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 17:07</span>&nbsp;\n<a href=\"https://www.cnblogs.com/poloapi\">路过的旁听生</a>&nbsp;\n阅读(<span id=\"post_view_count\">103</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "用 10 行 Java8 代码，开发一个自己的 ClaudeCodeCLI？你信吗？",
      "link": "https://www.cnblogs.com/noear/p/19585413",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/noear/p/19585413\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 17:01\">\n    <span>用 10 行 Java8 代码，开发一个自己的 ClaudeCodeCLI？你信吗？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        最近 Anthropic 推出的 Claude Code 席卷了开发者圈子，其强大的终端交互和“自动驾驶”般的编程能力令人惊叹。那么，在 Java 生态中，我们能否快速构建一个同样强大且高度可控的应用？\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>最近 Anthropic 推出的 Claude Code 席卷了开发者圈子，其强大的终端交互和“自动驾驶”般的编程能力令人惊叹。那么，在 Java 生态中，我们能否快速构建一个同样强大且高度可控的应用？</p>\n<p>答案是肯定的。基于 <strong>Solon AI</strong> 的 <code>CliSkill</code> 组件，你只需要 10 行核心代码，就能对接海量的开源技能生态，打造一个属于自己的智能终端（Agent CLI）。</p>\n<h3 id=\"1什么是-solon-ai-cliskill能干什么\">1、什么是 Solon AI CliSkill？能干什么？</h3>\n<p>Solon AI CliSkill 是一个基于 <strong>Pool-Box（池盒）模型</strong> 设计的 AI 综合技能插件。它充当了 AI 智能体（Agent）与操作系统之间的“手”和“眼”。兼容 <strong>Claude Code Agent Skills</strong> 规范。</p>\n<ul>\n<li>对接海量生态：</li>\n</ul>\n<p>直接兼容 Claude Code Agent Skills 规范。只需挂载含有 <code>SKILL.md</code> 的技能包，Agent 就能秒变“剪辑师”、“架构师”或“运维专家”。</p>\n<ul>\n<li>精细化文件管理：</li>\n</ul>\n<p>Agent 不再只是胡乱生成代码，它能像人类工程师一样进行 <code>ls</code> 浏览目录、<code>cat</code> 读取规范、<code>grep</code> 检索逻辑，并使用 <code>edit</code> 工具进行精准的行级代码修改。</p>\n<ul>\n<li>安全环境隔离：</li>\n</ul>\n<p>Box（工作盒）：Agent 的受限活动空间。它在这里写代码、跑测试，确保不会误删你的系统根目录，不过仍要小心（它可能会自动安装需要的东西。比如：你要生成视步它会安装 ffmpeg）。Pool（技能池）：外部共享的工具库（只读）。你可以挂载一个专门处理视频的池，或者一个专门处理 K8s 部署的池。</p>\n<h3 id=\"2核心代码10-行-java8-代码开启智能终端\">2、核心代码：10 行 Java8 代码开启智能终端</h3>\n<p>借助 Solon AI 的高度集成，你的 Java 程序可以极简地驱动这一切：</p>\n<pre><code class=\"language-java\">public class DemoApp {\n    public static void main(String[] args) {\n        // 1. 设置工作空间（Agent 将在此目录下进行创作）\n        String workDir = \"/WORK/projects/my-ai-task\";\n\n        // 2. 构建 Agent 并挂载 CliSkill (核心逻辑)\n        ReActAgent agent = ReActAgent.of(LlmUtil.getChatModel())\n                .name(\"SolonCodeAgent\")\n                .instruction(\"严格遵守挂载技能中的【规范协议】执行任务\")\n                .defaultSkillAdd(new CliSkill(workDir)) // 注入 CliSkill 核心能力\n                .maxSteps(100)                         // 允许 Agent 进行复杂的链式思考\n                .build();\n\n        // 3. 驱动任务：Agent 会自动扫描 workDir 下的技能规范并执行\n        agent.prompt(\"帮我生成一个 solon web 项目，实现经典的权限管理系统，包含 Vue3 前端和 Java8 后端\");\n    }\n}\n</code></pre>\n<h4 id=\"更进一步使用内置的-soloncodecli\">更进一步：使用内置的 SolonCodeCLI</h4>\n<p>如果你想直接构建一个交互式命令行工具，Solon AI 还提供了一个高度封装的参考实现 SolonCodeCLI（你可以直接 copy 代码进行定制改造）。</p>\n<p>它不仅内置了交互循环和多技能池管理，还具备 <strong>Web 能力</strong>，可以轻松与 <strong>钉钉、企业微信、飞书等 IM 工具</strong> 对接互动，让 AI 落地到具体的业务流程中：</p>\n<pre><code>public class DemoApp {\n    public static void main(String[] args) {\n        SolonCodeCLI solonCodeCLI = new SolonCodeCLI(LlmUtil.getChatModel())\n                .name(\"小花\")\n                .workDir(\"./app\")\n                .mountPool(\"@shared\", \"/path/to/opencode-skills\")\n                .enableWeb(true)\n                .config(agent -&gt; {\n                    agent.maxSteps(100);\n                });\n\n        solonCodeCLI.run();\n    }\n}\n</code></pre>\n<h3 id=\"3能力进阶多技能池挂载\">3、能力进阶：多技能池挂载</h3>\n<p>如果你希望你的 Agent 是一个“全能天才”，你可以通过 mountPool 隔离挂载不同领域的专家技能包：</p>\n<pre><code class=\"language-java\">CliSkill cli = new CliSkill(\"my-box\", workDir)\n        .mountPool(\"@shared\", \"/path/to/opencode-skills\") //共享技能\n        .mountPool(\"@media\", \"/path/to/ffmpeg-skills\")  // 处理音视频的专家\n        .mountPool(\"@media\", \"/path/to/ffmpeg-skills\")  // 处理音视频的专家\n        .mountPool(\"@ops\", \"/path/to/deploy-scripts\")   // 负责自动部署的专家\n        .mountPool(\"@doc\", \"/path/to/pdf-gen-skills\");  // 负责生成文档的专家\n</code></pre>\n<p>Agent 在执行时，会通过虚拟路径（如 <code>@media/extract.sh</code>）安全地调用这些只读工具。</p>\n<h3 id=\"4真实交互场景体验\">4、真实交互场景体验</h3>\n<p>当你配置好相应的技能包（这里有不错的技能库： <a href=\"https://github.com/zrt-ai-lab/opencode-skills\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/zrt-ai-lab/opencode-skills</a> ）后，你可以体验到如下“科幻”操作：</p>\n<ul>\n<li>自动化重构：</li>\n</ul>\n<p>“检查当前项目的 pom.xml，把所有过时的依赖升级到最新版本，并确保编译通过。”</p>\n<ul>\n<li>全栈项目生成：</li>\n</ul>\n<p>“帮我生成一个基于 Solon 的管理系统。前端要用 Vue3 + ElementPlus，后端要符合 RESTful 规范，带上简单的权限校验逻辑。”</p>\n<ul>\n<li>多媒体联动：</li>\n</ul>\n<p>“先在网上调查一下 Solon AI 的分布式 Skills 架构，写一篇 500 字的总结存为 README.md，然后根据这些内容生成一个 30 秒的视频介绍。”</p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-02-06 17:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/noear\">带刺的坐椅</a>&nbsp;\n阅读(<span id=\"post_view_count\">93</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "精灵潜入C++,莲花咒语显神奇",
      "link": "https://www.cnblogs.com/lixingqiu/p/19585352",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lixingqiu/p/19585352\" id=\"cb_post_title_url\" title=\"发布于 2026-02-06 16:53\">\n    <span>精灵潜入C++,莲花咒语显神奇</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>看视频在这里:https://www.douyin.com/video/7603656116593052963</p>\n<p>看看这一行长长的C++代码：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">while</span>(<span style=\"color: rgba(128, 0, 128, 1);\">1</span>)r.bgcolor(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">black</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).pensize(<span style=\"color: rgba(128, 0, 128, 1);\">5</span>).speed(<span style=\"color: rgba(128, 0, 128, 1);\">0</span>).color(r.heading()).circle(<span style=\"color: rgba(128, 0, 128, 1);\">100</span>,<span style=\"color: rgba(128, 0, 128, 1);\">90</span>).left(<span style=\"color: rgba(128, 0, 128, 1);\">90</span>).circle(<span style=\"color: rgba(128, 0, 128, 1);\">100</span>,<span style=\"color: rgba(128, 0, 128, 1);\">90</span>).left(<span style=\"color: rgba(128, 0, 128, 1);\">90</span>).right(<span style=\"color: rgba(128, 0, 128, 1);\">20</span>);</pre>\n</div>\n<p>主要就是这一行代码，画了一幅美妙的莲花图案。下面是完整的，C++精灵库画莲花的代码：</p>\n<div class=\"cnblogs_code\">\n<pre>#include <span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">sprites.h</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span> <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">包含C++精灵库</span>\nSprite r; <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">建立角色叫r</span>\n\n<span style=\"color: rgba(0, 0, 255, 1);\">int</span> main(){ <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">主功能块</span>\n\n<span style=\"color: rgba(0, 0, 255, 1);\">while</span>(<span style=\"color: rgba(128, 0, 128, 1);\">1</span>)r.bgcolor(<span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">black</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span>).pensize(<span style=\"color: rgba(128, 0, 128, 1);\">5</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n.speed(</span><span style=\"color: rgba(128, 0, 128, 1);\">0</span><span style=\"color: rgba(0, 0, 0, 1);\">).color(r.heading())\n.circle(</span><span style=\"color: rgba(128, 0, 128, 1);\">100</span>,<span style=\"color: rgba(128, 0, 128, 1);\">90</span>).left(<span style=\"color: rgba(128, 0, 128, 1);\">90</span><span style=\"color: rgba(0, 0, 0, 1);\">)\n.circle(</span><span style=\"color: rgba(128, 0, 128, 1);\">100</span>,<span style=\"color: rgba(128, 0, 128, 1);\">90</span>).left(<span style=\"color: rgba(128, 0, 128, 1);\">90</span>).right(<span style=\"color: rgba(128, 0, 128, 1);\">20</span><span style=\"color: rgba(0, 0, 0, 1);\">);\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">return</span> <span style=\"color: rgba(128, 0, 128, 1);\">0</span>; <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">返回0</span>\n}</pre>\n</div>\n<h2>神仙对话泄天机</h2>\n<p>哪吒（手持乾坤圈）：“俺是哪吒三太子，刚刚听闻有位小魔法师用几行代码画出了一朵美轮美奂的莲花。那莲花的花瓣颜色还会随他的笔转向而不断变换，真是神奇！你可知道他是如何做到的？”</p>\n<p>太上老君（手持拂尘）：“此乃C++精灵库的妙用也。那小魔法师创建了一个名为r的角色，就像我身边的童子一样，然后在main函数里用了一个永不停歇的while循环，让r不停地舞动乾坤。”</p>\n<p>哪吒：“你这葫芦里卖的什么药？快讲讲r是怎么画莲花的？”</p>\n<p>太上老君：“那小魔法师在循环里让r做了好多动作。他先把r的背景色设为黑色，就像天庭的黑夜一样深邃。接着把笔画粗细调粗到5个单位，笔速设为0，意味着笔走如飞，一点都不拖沓。”</p>\n<p>哪吒：“嘿嘿，俺这乾坤圈也重达千斤，画笔画粗些倒也般配。那他还做了什么？”</p>\n<p>太上老君：“他把画笔的颜色设置为r.heading()，也就是根据r当前的方向来取颜色。这就好比r在不停地旋转，每转一个角度，颜色就变一变，仿佛r的心情在变，颜色也跟着变。”</p>\n<p>哪吒：“这颜色还会变？那r是怎么转的呢？”</p>\n<p>太上老君：“r画了两个半径100的圆弧，每次转90度。具体来说，先画了一个90度的圆弧，然后左转90度，再画另一个90度的圆弧，又左转90度，然后右转20度。如此循环往复，就像你在打旋子一样，一圈一圈地转。”</p>\n<p>哪吒：“这不是和我用乾坤圈画圈一样吗？那最后r会不会停下来？”</p>\n<p>太上老君：“那小魔法师在循环里没有停下来的意思，while(1)就是无限循环。”</p>\n<p>哪吒：“原来如此！这C++精灵库真像一位多才多艺的画匠，寥寥数笔就能画出五彩斑斓的莲花。而且它的命令和Python的turtle库差不多，对于喜欢Python的孩子来说，学这个C++库就像换了个平台继续玩耍，真是一举两得！”</p>\n<p>太上老君：“哈哈，哪吒你说得对！C++精灵库让孩子们在学习编程时，既可以延续熟悉的图形命令，又能领略C++的强大功能，确实是非常值得学习的库。”</p>\n<p>哪吒：“俺这就回去告诉师傅，让他也教教我C++精灵库，说不定俺也能画出更漂亮的莲花呢！”</p>\n<p>太上老君：“好啊，希望你早日成为C++小能手，画出属于你自己的绚丽莲花！”</p>\n<p><img alt=\"2026-02-06_154409\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<h2>代码解析学咒语</h2>\n<p>下面的逐行解释了main函数中while循环内的代码，并说明其作用：</p>\n<p>代码行&nbsp; &nbsp; 作用<br />r.bgcolor(\"black\")&nbsp; &nbsp;设置画笔背景色为黑色。<br />.pensize(5)&nbsp; &nbsp;设置画笔粗细为5个像素单位。<br />.speed(0)&nbsp; &nbsp; 设置画笔移动速度为0（最快速度）。<br />.color(r.heading())\t根据画笔当前方向heading()获取颜色值，并设置画笔颜色。方向值会被转换为色相，从而实现颜色随方向变化。<br />.circle(100, 90)&nbsp; &nbsp;以当前位置为圆心，半径100逆时针绘制一个90度的圆弧。<br />.left(90)&nbsp; &nbsp;画笔向左旋转90度。<br />.circle(100, 90)&nbsp; &nbsp;再次向左绘制一个90度的圆弧。<br />.left(90)&nbsp; &nbsp; 画笔再次向左旋转90度。<br />.right(20)\t画笔向右旋转20度（调整方向，使下次循环继续）。<br />上述代码通过链式调用的方式组合了一系列绘图命令，在无限循环中不断重复执行。每次循环中，画笔都会以黑色背景、粗线条、动态颜色绘制两个圆弧，然后旋转方向，如此往复，形成了莲花形状的图案。</p>\n<h2>&nbsp;始作俑者详剖析</h2>\n<p><em id=\"__mceDel\">C++精灵库（Sprite库）是一个基于SDL2库的少儿C++编程教学库，提供了类似Python turtle库的简洁命令，通过绘制图形和制作动画或小游戏创意C++作品来让少年儿童学习C++。它具有以下几个特点和优势：</em></p>\n<p><strong>简单易学</strong>： 库中的命令与Python turtle的命令非常相似，用法绝大多数一模一样。这使得熟悉Python绘图的用户可以快速上手C++编程。对于少年儿童来说，使用熟悉的命令可以降低学习门槛，激发他们对编程的兴趣。<br />功能强大： 虽然命令简单，但C++精灵库基于SDL2库，同时具备C++的强大性能和灵活性。用户可以利用C++的高级特性，如对象、函数和循环，实现更复杂的图形和动画效果。<br /><strong>丰富的图形效果</strong>： 库支持设置画笔颜色、粗细、速度，以及绘制各种图形（直线、圆圈、圆点、圆弧、椭圆等）并且增强了对画笔颜色的一些更精细的控制。比如让颜色渐变的coloradd命令。实际是逐步增加颜色的色相。比如设定颜色的饱和度命令(pensat)，还有设定颜色的明度命令(penvalue) 及洪水填充命令fill等。用户通过组合这些命令，用户可以创造出丰富多彩的图形和动画效果。例如，本示例中通过动态改变画笔颜色，实现了颜色随方向变化的绚丽图案。<br /><strong>拓展与互动性强</strong>： C++精灵库的底痤基于SDL2库，可以完美融入SDL2库的命令，从而方便地响应用户输入（如鼠标点击、键盘按键等）。这使得用该库开发的程序具有更强的交互性，也可以用于游戏和教育应用的开发制作。<br />综上所述，C++精灵库是一个非常适合少年儿童学习编程的工具。它将Python turtle的易用性与C++的强大功能相结合，使孩子们在享受编程乐趣的同时，也能逐步掌握C++语言的基本概念和编程技巧。对于培养少年儿童的逻辑思维和创造力，C++精灵库无疑是一个“一箭双雕”的选择。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-02-06 16:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lixingqiu\">李兴球</a>&nbsp;\n阅读(<span id=\"post_view_count\">51</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}