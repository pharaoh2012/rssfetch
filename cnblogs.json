{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "最近关于运维的一些感想",
      "link": "https://www.cnblogs.com/jindongyan666/p/19523500",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jindongyan666/p/19523500\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 17:47\">\n    <span>最近关于运维的一些感想</span>\n    \n\n</a>\n</h1>\n\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"最近关于运维的一些感想\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3760167/202601/3760167-20260123174305175-83770174.png\" />\n        一些关于Linux运维的思考\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><strong>运维不只是\"救火队员\"，而是系统的守护者</strong></p>\n<p>最近在和几位老运维聊起职业发展，他们不约而同地提到一个词：\"运维是系统稳定性最后的防线\"。这句话让我陷入了思考。作为IT行业中最容易被忽视的岗位之一，运维真的只是\"救火队员\"吗？还是说，我们正在经历一场静悄悄的变革？</p>\n<p>从\"消防员\"到\"守护者\"的转变</p>\n<p>记得刚入行那会儿，运维被戏称为\"救火队员\"。系统一出问题，运维就成为\"救火队长\"，半夜被叫醒处理故障是家常便饭。那时的我，每天盯着监控系统，生怕哪个指标爆了，然后就手忙脚乱地处理。</p>\n<p>但现在的运维，已经不再是单纯的\"救火\"了。运维角色从被动响应到主动预防的转变，让我开始思考：运维到底是什么？</p>\n<p>一位资深运维同事曾对我说：\"运维工程师和医生的职业更接近。医生也分各种科室，也有急症室，需要先判断病人的问题，对症下药。\"这句话让我豁然开朗。运维不是简单地处理故障，而是要理解系统，预见问题，提前预防。</p>\n<p>我见过一位同事，他每天的工作不是在处理故障，而是在思考如何预防故障。他会定期分析历史故障数据，找出规律，然后提前优化系统架构。他说：\"运维的最高境界不是故障发生时能快速解决，而是让故障不再发生。\"</p>\n<p><strong>云时代下的运维新挑战</strong></p>\n<p>随着云计算的普及，运维的挑战也在升级。从传统的物理服务器迁移到云平台，运维人员不仅要熟悉新的技术栈，还要面对多租户环境、分布式计算等复杂性。</p>\n<p>我曾经在一次技术分享会上听到一位云平台运维专家说：\"以前运维是'守'，现在是'用'。\"这句话让我深有感触。以前我们守着几台物理服务器，现在我们是在管理一个动态的、弹性的云环境，需要随时调整资源，优化成本。</p>\n<p>更让我惊讶的是，成本控制也是云运维不可忽视的方面。以前我们只关注系统是否稳定，现在还要考虑\"如何用最少的资源实现最大的效益\"。这让我意识到，运维已经从单纯的技术岗位，变成了一个需要兼顾技术、成本、效率的复合型角色。</p>\n<p><strong>运维的核心价值：不只是技术，更是思考</strong></p>\n<p>运维工程师的职责是\"保障并不断提升服务的可用性，确保用户数据安全，提升用户体验\"。这让我思考，运维的价值到底在哪里？</p>\n<p>在一次和产品经理的交流中，我提到我们最近优化了一个服务的响应时间。产品经理惊讶地问：\"这么小的优化，能带来什么价值？\"我解释说，\"平均响应时间从200ms降到150ms，虽然看起来微不足道，但对用户来说，每秒的体验提升都可能带来更高的留存率。\"</p>\n<p>那一刻我突然明白，运维的价值不在于技术有多高深，而在于我们是否能从用户角度思考问题。从系统的稳定性和可运维性的角度，提出开发需求，正是这个道理。</p>\n<p><strong>未来运维：从\"运维\"到\"运维+\"的进化</strong></p>\n<p>当前，运维正在经历一场深刻的变革。随着技术的发展，运维的角色正在从\"技术执行者\"向\"价值创造者\"转变。</p>\n<p>我最近在研究AIOps，发现它正在改变运维的面貌。通过机器学习分析日志数据，我们可以预测潜在的故障，而不是等待故障发生后再去处理。这就像医生通过体检数据预测疾病，而不是等到病人病重才去治疗。</p>\n<p>知识库中提到的\"新一代运维整合机器学习与云边协同技术，通过AIOps实现故障预测、智能告警及自动化修复\"，正是我正在学习和实践的方向。</p>\n<p>云计算的普及也带来了新的机遇。初级运维岗位已明确细分出云运维工程师方向，要求掌握云平台基础架构管理能力。而更高级的运维人员，正在向AI应用开发、智能系统运维等新兴领域扩展职业路径。</p>\n<p><strong>运维的未来：运维+业务的深度融合</strong></p>\n<p>我观察到，未来的运维人员将不再局限于技术层面，而是需要更深入地理解业务。一位架构师曾对我说：\"运维人员不能只懂技术，要懂业务，这样才能真正理解系统为什么需要这样设计。\"</p>\n<p>这意味着，运维工程师需要从\"解决问题\"的角色，转变为\"价值创造\"的角色。我们需要理解业务目标，用技术手段实现业务目标，而不仅仅是确保系统\"能用\"。</p>\n<p>在一次跨部门会议上，我提出了一套优化方案，不仅提升了系统性能，还降低了20%的云资源成本。当产品经理告诉我这个优化带来了2%的用户留存率提升时，我真正体会到了运维的价值——不只是技术上的优化，更是业务上的价值。</p>\n<p><strong>运维人员的思维转变：从\"救火\"到\"防火\"</strong></p>\n<p>我曾以为运维就是\"救火\"，现在我明白，真正的运维是\"防火\"。这需要我们从被动响应转变为主动预防，从技术视角转变到业务视角。</p>\n<p>我开始每天花30分钟分析系统日志，寻找潜在的问题；每周与开发团队进行一次技术交流，了解产品设计的初衷；每月总结一次故障案例，找出系统设计的不足。</p>\n<p>这种思维转变让我从一个\"救火队员\"，逐渐成为系统的\"守护者\"。运维不是简单的技术工作，而是一种思维方式，一种对系统稳定性的责任担当。</p>\n<p><strong>个人思考：运维人员需要培养的思维</strong></p>\n<ol>\n<li>\n<p>业务思维：不要只盯着技术，要理解业务。运维的价值在于支持业务目标的实现，而不仅仅是让系统运行。</p>\n</li>\n<li>\n<p>预防思维：运维不是\"救火\"，而是\"防火\"。要养成分析问题、思考根本原因的习惯，而不是只关注表面现象。</p>\n</li>\n<li>\n<p>数据思维：通过数据驱动决策，而不是凭经验判断。系统性能、用户行为、业务指标都是重要的决策依据。</p>\n</li>\n<li>\n<p>成本思维：在保证系统稳定性的前提下，考虑资源利用效率。云计算让资源可以弹性伸缩，但也要考虑成本效益。</p>\n</li>\n<li>\n<p>协作思维：运维不是一个人的工作，需要和开发、产品、测试等多部门协作。沟通和协作能力与技术能力同样重要。</p>\n</li>\n</ol>\n<p><strong>最后我想说：运维，是一场关于责任的修行</strong></p>\n<p>运维工作，表面看是技术活，背后却是责任。每一次系统稳定运行，背后都有运维人员默默的付出。</p>\n<p>在技术日新月异的今天，运维的角色正在从\"技术执行者\"向\"价值创造者\"转变。我们不再是简单的\"救火队员\"，而是系统稳定性的守护者，是用户体验的保障者，是业务价值的贡献者。</p>\n<p>运维这条路，没有捷径，只有不断学习、不断思考、不断实践。正如一位资深运维所说：\"运维不是一门技术，而是一种责任。\"</p>\n<p>运维，不只是一个职业，更是一场关于责任的修行。在这个过程中，我们不仅守护着系统，也在守护着自己的职业信仰。</p>\n<p>未来已来，运维的未来，是\"运维+\"的未来。我们不是在等待技术变革，而是在推动技术变革。不是在被动应对问题，而是在主动创造价值。这，才是运维的真正价值。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-23 17:47</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jindongyan666\">爱喝可乐的北极熊</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "技术面：如何让你的系统抗住高并发的流量？",
      "link": "https://www.cnblogs.com/jimoer/p/19523255",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jimoer/p/19523255\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 17:01\">\n    <span>技术面：如何让你的系统抗住高并发的流量？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        高并发架构设计无外乎“拆、缓、防”三板斧：先通过业务分治、数据分片、集群化部署把系统横向扩展到极致；再以多级缓存与消息队列将瞬时峰值削平成可线性增长的消息流；最后用限流、熔断、降级以及异地多活等多维防护手段，为系统守住最后的容量边界。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>如何能让系统抗住高并发流量，要考虑的因素有很多，但是真的让你讲一下都有哪些，很多人肯定就会说，用Redis缓存啦，用MQ做解耦啦，总之就是想起来这一块儿就说一嘴，想起来那一块儿也说一嘴，总之就是说的不能成体系一些。<br />\n一般面试官问这种问题的时候，是想看你怎么回答，有没有从架构的思想去思考这个问题，就算有一些具体技术你记得可能不是很熟练了，面试官也会相信你是能够解决问题的。</p>\n<p>这一次就整体来说一下如何让你的系统抗住高并发流量。</p>\n<h2 id=\"第一步拆\">第一步“拆”</h2>\n<p>在面对高并发的时候，第一步永远是<strong>拆核心</strong>，思想就是分而治之。</p>\n<h3 id=\"那具体怎么样拆呢\">那具体怎么样拆呢？</h3>\n<h4 id=\"服务的拆分与治理\">服务的拆分与治理</h4>\n<h5 id=\"服务拆分\">服务拆分</h5>\n<p>我们可以把庞大的单体架构，根据业务拆分成多个不同的服务，这样哪个服务遇到瓶颈了，可以单独拎出来进行扩容和优化，也不会因为某一个阶段出问题导致整个系统都瘫了。</p>\n<p>例如：一个电商系统按照业务领域拆分成用户、订单、支付、库存这些独立的服务。</p>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/121162/6cf681b9-9d57-4606-9e1e-374fbcfd7478.png\" /></p>\n<p><strong>这样拆分主要是使用分布式架构来降低单点故障的风险，提高系统的可伸缩性和性能。</strong></p>\n<h5 id=\"服务集群部署\">服务集群部署</h5>\n<p>虽然说，将单体系统拆分成多个系统，来分摊了单体架构下容易出现的故障风险，但实际上这样的操作只是将单点故障风险分摊到了各个子系统上，这样还是存在单点故障风险的。因此需要进行<strong>集群部署:将一个服务通过集群进行部署，来提升系统整体的吞吐量及响应速度，并使用负载均衡技术将请求均衡分配给多个服务器，以提高系统的性能和可用性。</strong></p>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/121162/3977742e-67bc-4838-86d5-70a69b2172e0.png\" /></p>\n<p>这样集群部署后，让每个服务器都承担一部分的并发和流量，提升整体系统的并发能力。</p>\n<h5 id=\"服务治理\">服务治理</h5>\n<p>拆服务和集群部署后，原先的单体系统变成了多服务多节点的分布式架构了，那么如果服务A想调用服务B，怎么找到服务B呢？当有几十个服务，上百个节点，并且每个节点的IP变来变去的，该怎么治理这些服务呢？这就需要一个通讯录，用来专门记录，每个服务的地址信息，也就是注册中心。</p>\n<p>下面是一些常见的注册中心的对比</p>\n<table>\n<thead>\n<tr>\n<th>注册中心</th>\n<th>CAP 模型</th>\n<th>健康检查方式</th>\n<th>多数据中心</th>\n<th>Spring Cloud 集成</th>\n<th>典型特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Eureka</strong></td>\n<td>AP（可用性优先）</td>\n<td>客户端心跳（30s）</td>\n<td>不支持</td>\n<td>原生支持</td>\n<td>轻量、与 Spring Cloud 无缝集成，适合入门和中小型项目</td>\n</tr>\n<tr>\n<td><strong>Consul</strong></td>\n<td>CP（一致性优先）</td>\n<td>TCP/HTTP/gRPC 主动探测</td>\n<td>原生支持</td>\n<td>支持</td>\n<td>功能最全，支持 KV 存储、ACL、DNS 服务等，适合多语言、多数据中心场景</td>\n</tr>\n<tr>\n<td><strong>Zookeeper</strong></td>\n<td>CP</td>\n<td>临时节点存活监听</td>\n<td>需额外配置</td>\n<td>支持</td>\n<td>成熟稳定，强一致性，适合与 Dubbo 等框架配合使用</td>\n</tr>\n<tr>\n<td><strong>Nacos</strong></td>\n<td>AP/CP 可切换</td>\n<td>TCP/HTTP/MySQL/自定义</td>\n<td>支持</td>\n<td>原生支持</td>\n<td>阿里开源，集成注册中心+配置中心 + 动态 DNS，适合云原生和 Spring Cloud 项目</td>\n</tr>\n</tbody>\n</table>\n<p><strong>那么它们是怎么工作的呢？</strong><br />\n这里可以以Nacos为例：服务启动时，后端服务自动把自己的 ip、端口注册到 Nacos。调用方通过 Nacos 获取健康实例列表，再配合 Ribbon 或者 Loadbalancer 做负载均衡。提到 Nacos 时，可以说一下的动态配置管理。高并发下，需要动态调整线程参数或者日志级别，不用重启服务。Nacos 配置一改，全量下发。</p>\n<blockquote>\n<p>Nacos 的“动态配置”指的是：在应用运行期，无需重启服务，即可实时推送并生效配置变更的能力。它把“配置”从代码/包内解耦出来，集中存储在 Nacos Server，并通过 长轮询（Long-Polling）+ 版本号对比 机制，让客户端在毫秒级感知到变化，进而触发本地回调或 Bean 重新绑定，实现“热更新”。</p>\n</blockquote>\n<h4 id=\"数据的拆分读写分离分片\">数据的拆分（读写分离、分片）</h4>\n<h5 id=\"读写分离\">读写分离</h5>\n<p>服务进行了拆分，如果数据库还是用一个，那么瓶颈肯定很容易出现在数据库，所以我们可以根据业务场景（读多写少/读少写多）将数据库进行读写分离，这样当读流量大了的时候，也不会影响写的效率。</p>\n<p><strong>读场景（商品详情、评论）走只读副本，写场景（下单、支付）走主库。</strong> 但是要做好监控，当主从延迟过高时，要及时处理。</p>\n<h5 id=\"垂直拆分\">垂直拆分</h5>\n<p>服务进行了拆分，如果数据库还是用一个，那么瓶颈肯定很容易出现在数据库，所以垂直分库是必须的，要做到专库专用，这样可以解决服务太多，数据库连接数太多的问题，减少数据库的压力。</p>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/121162/ed4db48d-7eb7-4817-80b0-5b10689f4fc7.png\" /></p>\n<h5 id=\"水平拆分\">水平拆分</h5>\n<p>但是如果有的表一年产生上亿条数据，并且保持持续增加。数据量真的太大了，就不要再总纠结什么索引优化、事务优化这种小打小闹的了，这个时候就得上水平分表了，落地工具现在首选是 shardingsphere，再加上一些自己的实现细节。比如我们利用 shardingjdbc 配置好分片键，再通过一致性哈希算法把一张大表拆成一千零二十四张小表，均匀分布在不同的物理磁盘上，这样就把集中的<code>I/O</code> 压力分散了。</p>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/121162/c91317bd-11a8-4751-9b51-398f0ffa6295.png\" /></p>\n<p>当涉及到分库分表，就有一个绕不过去的问题，那就是分布式事务。在单体服务架构下，一个<code>@Transaction</code>注解就能解决的问题，但是在分布式场景下如何解决，这里如果能说明白也是一个加分项。</p>\n<p><strong>因为使用了shardingsphere，可以使用数据库的 XA 协议或者引入 Seata，用 AT 模式或者 TCC 模式来解决跨库的事务问题。</strong></p>\n<h2 id=\"第二步缓\">第二步“缓”</h2>\n<p>缓也可以说是缓冲，服务和数据库的拆分只是解决了扩展性的问题，但如果流量瞬间爆发，比如秒杀，节日大促，数据库还是容易会被打挂。<br />\n这时候我们就需要第二招，<strong>缓冲</strong>。</p>\n<p>具体点说就是流量来了，我们要挡和削，当流量进来的时候，可以通过前置措施先挡住一部分，然后再将大量的并发请求变成有序的排队请求将服务的压力降下来。</p>\n<h3 id=\"读流量处理\">读流量处理</h3>\n<p>当读流量很大时，我们可以先做一些前置缓存，也就是Redis。这一层的核心目标就是过滤无效请求，读取热点数据。请求进来之后，先别去查库，先查 Redis。<br />\n比如说秒杀场景，库存没了，直接在 redis 层返回已经售罄，数据库根本感觉不到压力。</p>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/121162/91f681bb-6e05-458a-b4a2-50652b46db3d.png\" /></p>\n<p>因为加了Redis，这个时候，就很容易会被问到，如果Redis挂了怎么办呢？或者有的直接问，缓存穿透、缓存击穿、缓存雪崩怎么处理呢？</p>\n<ul>\n<li>缓存穿透\n<ul>\n<li>大量的垃圾请求数据，缓存中没有、DB中也没有，查询缓存不存在，则流量直接打到DB。</li>\n<li>解决方案：缓存空值，对不存在的数据也缓存一个较短时间；使用布隆过滤器过滤不存在的数据。</li>\n</ul>\n</li>\n<li>缓存击穿\n<ul>\n<li>高频热点突然过期，大量请求击穿缓存，请求到DB。</li>\n<li>解决方案：一些热点缓存数据可以不设置过期时间或访问后延长过期时间；用一些互斥锁来锁住数据，缓存失效时先锁住，当从DB中加载完新缓存数据后再释放锁。</li>\n</ul>\n</li>\n<li>缓存雪崩\n<ul>\n<li>大量数据同时失效或缓存出问题了挂掉了。</li>\n<li>解决方案：可以给缓存数据分散的设置过期时间，防止同一时间失效；热点数据可以不设置过期时间；缓存出问题时，不能直接打到DB，做降级处理；缓存集群部署，提升可用性，降低雪崩风险。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"写流量处理\">写流量处理</h3>\n<p>有了第Redis的缓冲，接下来就是第二层MQ的缓冲了，因为如果是大量的读请求可以用Redis抗住，但是如果是大量的写请呢？例如：下单请求，你如果直接给打到数据库，那不但数据库会崩了，连请求也都得丢了。</p>\n<p>这时就可以引入MQ（消息队列），引入MQ后的逻辑就变成了，用户下单后发出一个消息给MQ，然后立马返回给客户正在排队，这样响应就变快了，用户也能及时看到状态变化。</p>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/121162/85f48926-10ff-4b5d-b867-f7e20c8ab6d0.png\" /></p>\n<p>订单服务根据自己的消费能力，慢慢的从MQ中拉取消息来进行处理，这就把高并发变成了低并发。实际落地选型通常来说比较建议 <code>Kafka</code> 或者是 <code>Rocketmq</code>。但 <code>Kafka</code> 它更加适合像日志采集这些吞吐量极高的场景，更多场景我们会习惯用 <code>Rocketmq</code>，它比较适合金融交易，而且它支持事务消息，可靠性非常的好。</p>\n<p>这里在讲到MQ的时候，也有时会被问，MQ消息如何不丢？如何保证不重复消费？</p>\n<ul>\n<li>如何不丢消息？发送方只要保证MQ 消息发送成功即可，剩下的由MQ自身保证，MQ会有持久化以及分片副本机制，消息接收方也要保证在真正处理成功消息后再提交offset。</li>\n<li>如何不重复消费，可以在发送方发消息时进行一些防止重复发送的处理，消息接收方也要做幂等处理，例如用Redis记录消息ID。</li>\n</ul>\n<h2 id=\"第三步防\">第三步“防”</h2>\n<p>前面两步是进攻，最后这一步就是防守了。<br />\n如果流量真的超过了系统的物理极限或者某个服务代码写的烂报错了怎么办？<br />\n我们就需要建立一套多维的防御体系，核心思路就是层层设防，丢卒保帅。</p>\n<h3 id=\"第一道防线网关层\">第一道防线：网关层</h3>\n<p>这是系统的大门，我们在这里可以做一些 ip 维度的限流，比如用 nginx 限流模块限制同一个 ip 每秒只能访问五次，这就能把大部分恶意的爬虫脚本攻击直接挡在门外，根本不让他们消耗后端的资源。</p>\n<h3 id=\"第二道防线应用层\">第二道防线：应用层</h3>\n<p>这就是系统的内功了，流量进了微服务内部，现在推荐可以使用阿里的 Sentinel，它比以前的 Hystrix 更强大，可以支持控制台的可视化配置。<br />\n在这里主要做三件事情：<strong>限流、熔断、降级</strong>。</p>\n<ul>\n<li>限流：设置当QPS 超过一千直接拒绝，保护服务不被压垮。</li>\n<li>熔断：下游支付服务挂了，上游订单服务千万别死等，直接熔断，防止雪崩。</li>\n<li>降级：大促高峰期把查看历史订单、商品推荐这些非核心业务直接降级，返回降级提示或缓存数据，把 CPU 和内存全让给下单和支付这些核心业务。</li>\n</ul>\n<h4 id=\"限流-使用sentinel说出来常用的两种限流模式\">限流 使用Sentinel，说出来常用的两种限流模式</h4>\n<ul>\n<li>线程数模式：秒杀接口最大 300 并发，超了直接返回“售罄”。</li>\n<li>QPS 模式：短信接口 1000/s，令牌桶匀速通过。</li>\n</ul>\n<h4 id=\"熔断使用sentinel\">熔断使用Sentinel</h4>\n<p>Sentinel 把“<strong>统计窗口 + 三态熔断器（CLOSE、OPEN、HALF_OPEN）</strong>”做成可插拔的 Slot；业务侧只需定义资源和 fallback，其余<strong>状态流转、阈值判断、超时恢复全部由框架完成，真正做到了“零侵入”的熔断保护</strong>。</p>\n<p>在应用层其实还有一招就是异地多活，为了保证更极端的情况，例如：某城市大面积停电或者网络光缆被挖断了。</p>\n<h4 id=\"异地多活\">异地多活</h4>\n<ul>\n<li>三地五机房，每个库至少两副本，Paxos/Raft 保证一致性。</li>\n<li>任何城市级光纤断，30 s 内完成 Leader 重新选主，RPO=0，RTO&lt;30 s。</li>\n</ul>\n<h3 id=\"复盘\">复盘</h3>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/121162/4ee16cc7-26fa-4166-a5e6-16c0ba49f3da.png\" /></p>\n<p>高并发架构设计无外乎“<strong>拆、缓、防</strong>”三板斧：<strong>先通过业务分治、数据分片、集群化部署把系统横向扩展到极致</strong>；<strong>再以多级缓存与消息队列将瞬时峰值削平成可线性增长的消息流</strong>；<strong>最后用限流、熔断、降级以及异地多活等多维防护手段，为系统守住最后的容量边界</strong>。<br />\n三步环环相扣，层层递进，既展示了架构思维的体系化，也体现了在成本、复杂度与可靠性之间的权衡艺术。真正落地时，还需结合业务场景、团队成熟度与运维能力，在“理想设计”与“务实交付”之间找到最适合自己公司的平衡点。</p>\n\n</div>\n<div id=\"MySignature\">\n    <div style=\"float: left; letter-spacing: 1px; font-size: 13px;\"><p><strong>作者：</strong><a href=\"http://www.cnblogs.com/jimoer/\">纪莫</a>\n<br />欢迎任何形式的转载，但请务必注明出处。<br />\n限于本人水平，如果文章和代码有表述不当之处，还请不吝赐教。</p>\n<!-- 分享图标开始 -->\n<p>欢迎扫描二维码关注公众号：<strong>Jimoer</strong></p>\n<p>文章会同步到公众号上面，大家一起成长，共同提升技术能力。</p>\n<p><strong>声援博主：</strong>如果您觉得文章对您有帮助，可以点击文章右下角【<a href=\"\" style=\"font-size: 14pt;\">推荐</a>】一下。</p>\n<p>您的鼓励是博主的最大动力！</p>\n</div>\n<div style=\"float: right;\">\n<img alt=\"微信公众号\" src=\"https://img2018.cnblogs.com/blog/772743/201909/772743-20190904004009398-659676330.png\" /></div>\n<!-- 分享图标结束 -->\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-23 17:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jimoer\">纪莫</a>&nbsp;\n阅读(<span id=\"post_view_count\">105</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "langchain 快速入门（二）：chain链的应用",
      "link": "https://www.cnblogs.com/ClownLMe/p/19523156",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ClownLMe/p/19523156\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 16:52\">\n    <span>langchain 快速入门（二）：chain链的应用</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"简介\">简介</h1>\n<p>langchain中提供的chain链组件，能够帮助我门快速的实现各个组件的流水线式的调用，和模型的问答</p>\n<h1 id=\"chain链的组成\">Chain链的组成</h1>\n<p>根据查阅的资料，langchain的chain链结构如下：</p>\n<p>$$Input \\rightarrow Prompt \\rightarrow Model \\rightarrow Output$$<br />\n其中langchain框架提供了几个常用构建chain链的工具：</p>\n<table>\n<thead>\n<tr>\n<th>工具名称</th>\n<th>作用</th>\n<th>流程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RunnablePassthrough</td>\n<td>传递<strong>原本</strong>的数据或<strong>添加</strong>新的字段</td>\n<td>$$A-&gt;B$$</td>\n</tr>\n<tr>\n<td>RunnableParallel</td>\n<td>并发输出结果并将结果<strong>同时</strong>传递</td>\n<td>$$A,B-&gt;C$$</td>\n</tr>\n<tr>\n<td>RunnableLambda</td>\n<td><strong>自定义</strong>传递工具</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>乍一看很疑惑，我接下来用案例来解释各种用法。</p>\n<h1 id=\"构建较为复杂的chain链\">构建较为复杂的chain链</h1>\n<p>这个案例几乎用了上面所有工具，用于演示用法</p>\n<h3 id=\"案例\">案例</h3>\n<p>案例描述：输入论文的话题，写一篇950字的高中论文。</p>\n<pre><code class=\"language-python\">import os\nfrom langchain_community.chat_models.tongyi import ChatTongyi\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain_core.runnables import RunnablePassthrough, RunnableParallel\n\n#你的qwen模型apikey\nos.environ[\"DASHSCOPE_API_KEY\"] = \"apikey\"\nmodel = ChatTongyi(model=\"qwen-max\")\n\noutline_prompt = ChatPromptTemplate.from_template(\n&nbsp; &nbsp; \"请给主题为 {topic} 的议论文写一个 总-递进-总 的简短大纲，一共分为5段。\"\n)\noutline_chain = outline_prompt | model | StrOutputParser()\n\ndef mock_search(input_data):\n&nbsp; &nbsp; return \"\"\"\n&nbsp; &nbsp; 1. 利：Google Health AI 筛查乳腺癌准确率超人类。\n&nbsp; &nbsp; 2. 利：AlphaFold 预测蛋白质结构，缩短科研周期。\n&nbsp; &nbsp; 3. 弊：GPT-4 普及导致初级文案、原画设计岗位萎缩。\n&nbsp; &nbsp; 4. 弊：Deepfake 技术被用于电信诈骗和虚假视频。\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; \noutput_prompt = ChatPromptTemplate.from_template(\n&nbsp; &nbsp; \"你是一位高考作文专家。请基于大纲：\\n{outline}\\n并结合以下案例素材：\\n{data}\\n\"\n&nbsp; &nbsp; \"就主题【{topic}】写一篇高考论文。要求：950字左右，论证严密，文采斐然。\"\n)\noutput_chain = output_prompt | model | StrOutputParser()\n\ncomplex_chain = (\n&nbsp; &nbsp; RunnableParallel({\n&nbsp; &nbsp; &nbsp; &nbsp; \"outline\": outline_chain, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; \"data\": mock_search, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; \"topic\": RunnablePassthrough() &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; })\n&nbsp; &nbsp; | output_chain\n)\n\ntopic_input = \"AI 进步的利与弊：在智能时代保持人类的温度\"\nprint(f\"正在为您撰写关于《{topic_input}》的论文...\\n\")\n\nfinal_essay = complex_chain.invoke({\"topic\": topic_input})\nprint(final_essay)\n</code></pre>\n<h3 id=\"代码解释\">代码解释</h3>\n<p>其他的代码我上期解释了，这里就不废话了，我着重讲chain链的构建，总体chain链的流程如下：</p>\n<pre><code>输入话题-&gt;获取写作的大纲 ──╮\n                        ├─▶ 根据大纲和示例写一篇论文\n         查询相关的示例 ──╯\n</code></pre>\n<p>根据输入流程图流程，我们个以分解成一个个相关的链，再将各个链串起来。</p>\n<h4 id=\"构建各部分的链\">构建各部分的链</h4>\n<h5 id=\"1获取写作大纲\">1.获取写作大纲</h5>\n<pre><code class=\"language-python\">outline_prompt = ChatPromptTemplate.from_template(\n&nbsp; &nbsp; \"请给主题为 {topic} 的议论文写一个 总-递进-总 的简短大纲，一共分为5段。\"\n)\noutline_chain = outline_prompt | model | StrOutputParser()\n</code></pre>\n<p><strong>流程描述</strong>：构建prompt-&gt;喂给ai-&gt;将返回解析成文本</p>\n<blockquote>\n<p>这里用的<code>ChatPromptTemplate.from_template</code>和上的<code>ChatPromptTemplate.from_messages</code>不同，区别在于前者比较简单，相当于后者直接用<code>user</code>字典的形式，后者<code>from_messages</code>有langchain框架提供的prompt模板</p>\n</blockquote>\n<h5 id=\"2查询相关的示例\">2.查询相关的示例</h5>\n<p>这里就直接用Gemini，mock一些模拟数据（不保证真），用于完成案例，实际情况可以自己完善搜索逻辑。</p>\n<pre><code class=\"language-python\">def mock_search(input_data):\n&nbsp; &nbsp; return \"\"\"\n&nbsp; &nbsp; 1. 利：Google Health AI 筛查乳腺癌准确率超人类。\n&nbsp; &nbsp; 2. 利：AlphaFold 预测蛋白质结构，缩短科研周期。\n&nbsp; &nbsp; 3. 弊：GPT-4 普及导致初级文案、原画设计岗位萎缩。\n&nbsp; &nbsp; 4. 弊：Deepfake 技术被用于电信诈骗和虚假视频。\n&nbsp; &nbsp; \"\"\"\n</code></pre>\n<blockquote>\n<p>这个相当于<code>RanableLamda</code>,后面可以不用显示调用<code>RanableLamda(mock_search)</code></p>\n</blockquote>\n<h5 id=\"3-根据大纲和示例写一篇论文\">3. 根据大纲和示例写一篇论文</h5>\n<pre><code class=\"language-python\">output_prompt = ChatPromptTemplate.from_template(\n&nbsp; &nbsp; \"你是一位高考作文专家。请基于大纲：\\n{outline}\\n并结合以下案例素材：\\n{data}\\n\"\n&nbsp; &nbsp; \"就主题【{topic}】写一篇高考论文。要求：950字左右，论证严密，文采斐然。\"\n)\noutput_chain = output_prompt | model | StrOutputParser()\n</code></pre>\n<p><strong>流程描述</strong>：构建prompt-&gt;喂给ai-&gt;将返回解析成文本</p>\n<h4 id=\"将各个链连起来\">将各个链连起来</h4>\n<pre><code class=\"language-python\">complex_chain = (\n&nbsp; &nbsp; RunnableParallel({\n&nbsp; &nbsp; &nbsp; &nbsp; \"outline\": outline_chain, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; \"data\": mock_search, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; \"topic\": RunnablePassthrough() &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; })\n&nbsp; &nbsp; | output_chain\n)\n</code></pre>\n<p>这里利用<code>RunnableParallel</code>将<code>获取写作的大纲</code>和<code>查询相关的示例</code>两个流程并列运行后一起输出到后面，传递给output_chain继续处理。</p>\n<h1 id=\"问题\">问题</h1>\n<ol>\n<li><strong>我不想利用RunnableParallel行不行？</strong> 当然可以，可以用线性来代替，先查资料，后写大纲，然后再进行文章输出，但是效率可能会比较慢。</li>\n<li><strong>我希望看到输出的data和outline字段怎么办？</strong> ，可以利用<code>RunnablePassthrough().assign</code>将生成的文本保存在新的字段中，调用时根据<strong>字典</strong>的方式定位各个文本，如下：</li>\n</ol>\n<pre><code class=\"language-python\">complex_chain = (\n&nbsp; &nbsp; RunnableParallel({\n&nbsp; &nbsp; &nbsp; &nbsp; \"outline\": outline_chain, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; \"data\": mock_search, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; \"topic\": RunnablePassthrough() &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; })\n&nbsp; &nbsp; | RunnablePassthrough().assign(essay=output_chain)\n)\n\nprint(response['essay'])\nprint(response['data'])\n......\n</code></pre>\n<p><strong>如果❤喜欢❤本系列教程，就点个关注吧，后续不定期更新~</strong></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-23 16:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ClownLMe\">ClownLMe</a>&nbsp;\n阅读(<span id=\"post_view_count\">14</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "DBShadow.net之性能优化的坎坷路",
      "link": "https://www.cnblogs.com/xiangji/p/19522084",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiangji/p/19522084\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 14:08\">\n    <span>DBShadow.net之性能优化的坎坷路</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"postText\"><div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"一mysql参数的成本\">一、mysql参数的成本</h2>\n<blockquote>\n<ul>\n<li>使用BenchmarkDotNet测试</li>\n</ul>\n</blockquote>\n<h3 id=\"1-测试代码如下\">1. 测试代码如下</h3>\n<blockquote>\n<ul>\n<li>CreateParameter直接构造参数</li>\n<li>Clone预先构造参数名和类型,复制后只设置参数值</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">private static readonly MySqlCommand _command = new();\nprivate static MySqlParameter _idParameter;\n\n[Benchmark(Baseline = true)]\npublic DbParameter CreateParameter()\n{\n    var id = _command.CreateParameter();\n    id.ParameterName = \"Id\";\n    id.DbType = System.Data.DbType.Int64;\n    id.Value = 1L;\n    return id;\n}\n[Benchmark]\npublic DbParameter Clone()\n{\n    var id = _idParameter.Clone();\n    id.Value = 1L;\n    return id;\n}\n\n[GlobalSetup]\npublic void Setup()\n{\n    _idParameter = _command.CreateParameter();\n    _idParameter.ParameterName = \"Id\";\n    _idParameter.DbType = System.Data.DbType.Int64;\n}\n</code></pre>\n<h3 id=\"2-测试结果如下\">2. 测试结果如下</h3>\n<blockquote>\n<ul>\n<li>通过复制方式节省了80%的时间</li>\n<li>感觉有搞头,所以希望把复制参数的功能加入到DBShadow.net中用来提高性能</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th style=\"text-align: right;\">Mean</th>\n<th style=\"text-align: right;\">Error</th>\n<th style=\"text-align: right;\">StdDev</th>\n<th style=\"text-align: right;\">Ratio</th>\n<th style=\"text-align: right;\">Gen0</th>\n<th style=\"text-align: right;\">Allocated</th>\n<th style=\"text-align: right;\">Alloc Ratio</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CreateParameter</td>\n<td style=\"text-align: right;\">58.60 ns</td>\n<td style=\"text-align: right;\">0.185 ns</td>\n<td style=\"text-align: right;\">0.213 ns</td>\n<td style=\"text-align: right;\">1.00</td>\n<td style=\"text-align: right;\">0.0064</td>\n<td style=\"text-align: right;\">112 B</td>\n<td style=\"text-align: right;\">1.00</td>\n</tr>\n<tr>\n<td>Clone</td>\n<td style=\"text-align: right;\">11.01 ns</td>\n<td style=\"text-align: right;\">0.387 ns</td>\n<td style=\"text-align: right;\">0.431 ns</td>\n<td style=\"text-align: right;\">0.19</td>\n<td style=\"text-align: right;\">0.0064</td>\n<td style=\"text-align: right;\">112 B</td>\n<td style=\"text-align: right;\">1.00</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二clone重写参数预编译\">二、Clone重写参数预编译</h2>\n<h3 id=\"1-生成的代码如下\">1. 生成的代码如下</h3>\n<blockquote>\n<ul>\n<li>预编译反射command和参数类型,以便生成更原生更快的代码</li>\n<li>其中cached是预先构造好的参数缓存作为常量</li>\n<li>cached含有参数名和类型信息</li>\n<li>Clone后只需要设置参数值即可</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">(DbCommand command, Todo param) =&gt;\n{\n    MySqlParameterCollection parameters = ((MySqlCommand)command).Parameters;\n    MySqlParameter t = cached.Clone();\n    t.Value = param.Id;\n    // MySqlParameter Add(MySqlParameter parameter)\n    return parameters.Add(t);\n}\n</code></pre>\n<h3 id=\"2-选择更合适的原生方法\">2. 选择更合适的原生方法</h3>\n<blockquote>\n<ul>\n<li>MySqlParameterCollection有两个Add方法</li>\n<li>很明显重载Add(MySqlParameter parameter)更合适</li>\n<li>调用重载Add(object value)需要做多次类型转换</li>\n<li>既然生成的代码可以控制,就需要选用更合适的重载</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">public MySqlParameter Add(MySqlParameter parameter);\npublic override int Add(object value);\n</code></pre>\n<h3 id=\"3-类型嗅探\">3. 类型嗅探</h3>\n<blockquote>\n<ul>\n<li>预编译是ShadowBuilder负责,基于ADO.net(DbCommand)</li>\n<li>为了生成更原生的代码,需要知道具体的Command类型</li>\n<li>所以ShadowBuilder需要更多实际的类型信息</li>\n<li>为此本来ShadowExecutor才需要的数据源信息,现在ShadowBuilder也需要</li>\n</ul>\n</blockquote>\n<h4 id=\"31-shadowbuilder以前的代码\">3.1 ShadowBuilder以前的代码</h4>\n<pre><code class=\"language-csharp\">class ShadowBuilder(ISqlEngine engine, IMapperOptions options);\n</code></pre>\n<h4 id=\"32-shadowbuilder现在的代码\">3.2 ShadowBuilder现在的代码</h4>\n<blockquote>\n<ul>\n<li>其中CommandBuilder可以通过DbDataSourcet推导出来</li>\n<li>也就是实际只增加了DbDataSource</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">class ShadowBuilder(IMapperOptions options, ISqlEngine engine, DbDataSource dataSource, CommandBuilder commandBuilder);\n</code></pre>\n<pre><code class=\"language-csharp\">var command = dataSource.CreateConnection().CreateCommand();\nvar parameterType = command.CreateParameter().GetType();\nCommandBuilder commandBuilder = CommandBuilder.Create(command, parameterType);\n</code></pre>\n<h4 id=\"33-嗅探的过程\">3.3 嗅探的过程</h4>\n<blockquote>\n<ul>\n<li>通过DbDataSource推导出CommandBuilder</li>\n<li>其中CreateConnection、CreateCommand和CreateParameter等方法并不实际执行数据库IO操作,只是用来嗅探类型信息</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">var command = dataSource.CreateConnection().CreateCommand();\nvar commandType = command.GetType();\nvar parametersProperty = commandType.GetProperty(\"Parameters\", BindingFlags.Instance | BindingFlags.DeclaredOnly);\nvar parametersType = parametersProperty.PropertyType;\nvar parameterType = command.CreateParameter().GetType();\nvar addParameterMethod = parametersType.GetMethod(\"Add\", [parameterType]);\n</code></pre>\n<h3 id=\"4-shadowexecutor变化比较小\">4. ShadowExecutor变化比较小</h3>\n<blockquote>\n<ul>\n<li>只是把类ShadowBuilder改为IShadowBuilder接口</li>\n<li>实际还是ShadowBuilder变化</li>\n</ul>\n</blockquote>\n<h4 id=\"41-shadowexecutor以前的代码\">4.1 ShadowExecutor以前的代码</h4>\n<pre><code class=\"language-csharp\">class ShadowExecutor(ShadowBuilder builder, SqlSource source);\n</code></pre>\n<h4 id=\"42-shadowexecutor现在的代码\">4.2 ShadowExecutor现在的代码</h4>\n<pre><code class=\"language-csharp\">class ShadowExecutor(IShadowBuilder builder, SqlSource source);\n</code></pre>\n<h3 id=\"5-shadowbuilder和shadowcachedbuilder的关系\">5. ShadowBuilder和ShadowCachedBuilder的关系</h3>\n<h4 id=\"51-shadowcachedbuilder以前是shadowbuilder的子类\">5.1 ShadowCachedBuilder以前是ShadowBuilder的子类</h4>\n<pre><code class=\"language-csharp\">class ShadowCachedBuilder : ShadowBuilder;\n</code></pre>\n<h4 id=\"52-shadowcachedbuilder现在是shadowbuilder的包装类\">5.2 ShadowCachedBuilder现在是ShadowBuilder的包装类</h4>\n<blockquote>\n<ul>\n<li>通过接口IShadowBuilder来实现</li>\n<li>通过original成员调用原有的ShadowBuilder功能</li>\n<li>这样避免ShadowBuilder的复杂度增加影响到ShadowCachedBuilder</li>\n<li>ShadowCachedBuilder只负责缓存编译好的对象</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">class ShadowCachedBuilder(ShadowBuilder original)\n    : IShadowBuilder;\n</code></pre>\n<h2 id=\"三复杂的现实世界\">三、复杂的现实世界</h2>\n<h3 id=\"1-sqliteparameter不支持复制\">1. SqliteParameter不支持复制</h3>\n<blockquote>\n<ul>\n<li>SqliteParameter没有实现ICloneable接口</li>\n<li>SqliteParameter也没有Clone方法</li>\n</ul>\n</blockquote>\n<h3 id=\"2-sqlparameter可以复制但性能不佳\">2. SqlParameter可以复制,但性能不佳</h3>\n<blockquote>\n<ul>\n<li>SqlParameter(Mssql)实现了ICloneable接口</li>\n</ul>\n</blockquote>\n<h4 id=\"21-测试代码如下\">2.1 测试代码如下</h4>\n<pre><code class=\"language-csharp\">private readonly SqlCommand _command = new(); \nprivate ICloneable _idParameter;\n\n[Benchmark(Baseline = true)]\npublic DbParameter CreateParameter()\n{\n    var id = _command.CreateParameter();\n    id.ParameterName = \"Id\";\n    id.DbType = System.Data.DbType.Int64;\n    id.Value = 1L;\n    return id;\n}\n[Benchmark]\npublic DbParameter Clone()\n{\n    var id = (SqlParameter)_idParameter.Clone();\n    id.Value = 1L;\n    return id;\n}\n[GlobalSetup]\npublic void Setup()\n{\n    var idParameter = _command.CreateParameter();\n    idParameter.ParameterName = \"Id\";\n    idParameter.DbType = System.Data.DbType.Int64;\n    _idParameter = idParameter;\n}\n</code></pre>\n<h4 id=\"22-测试结果如下\">2.2 测试结果如下</h4>\n<blockquote>\n<ul>\n<li>Clone方式比直接CreateParameter方式还慢</li>\n<li>这就是为什么CommandBuilder可以推导出来还要作为ShadowBuilder参数的原因</li>\n<li>现在只能把选择权交给用户,让用户决定是否启用Clone方式</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th style=\"text-align: right;\">Mean</th>\n<th style=\"text-align: right;\">Error</th>\n<th style=\"text-align: right;\">StdDev</th>\n<th style=\"text-align: right;\">Median</th>\n<th style=\"text-align: right;\">Ratio</th>\n<th style=\"text-align: right;\">RatioSD</th>\n<th style=\"text-align: right;\">Gen0</th>\n<th style=\"text-align: right;\">Allocated</th>\n<th style=\"text-align: right;\">Alloc Ratio</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CreateParameter</td>\n<td style=\"text-align: right;\">15.38 ns</td>\n<td style=\"text-align: right;\">0.942 ns</td>\n<td style=\"text-align: right;\">0.967 ns</td>\n<td style=\"text-align: right;\">14.53 ns</td>\n<td style=\"text-align: right;\">1.00</td>\n<td style=\"text-align: right;\">0.09</td>\n<td style=\"text-align: right;\">0.0106</td>\n<td style=\"text-align: right;\">184 B</td>\n<td style=\"text-align: right;\">1.00</td>\n</tr>\n<tr>\n<td>Clone</td>\n<td style=\"text-align: right;\">24.84 ns</td>\n<td style=\"text-align: right;\">0.169 ns</td>\n<td style=\"text-align: right;\">0.194 ns</td>\n<td style=\"text-align: right;\">24.81 ns</td>\n<td style=\"text-align: right;\">1.62</td>\n<td style=\"text-align: right;\">0.10</td>\n<td style=\"text-align: right;\">0.0106</td>\n<td style=\"text-align: right;\">184 B</td>\n<td style=\"text-align: right;\">1.00</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"四parameterbuilder\">四、ParameterBuilder</h2>\n<blockquote>\n<ul>\n<li>ParameterBuilder负责反射参数实际类型和方法,用于生成更高效的代码</li>\n<li>ParameterBuilder是抽象类,有3个具体实现</li>\n</ul>\n</blockquote>\n<h3 id=\"1-buildbynamedconstructor\">1. BuildByNamedConstructor</h3>\n<blockquote>\n<ul>\n<li>通过含参数名构造函数创建参数</li>\n</ul>\n</blockquote>\n<h3 id=\"2-buildbydefaultconstructor\">2. BuildByDefaultConstructor</h3>\n<blockquote>\n<ul>\n<li>通过默认构造函数创建参数,然后设置参数名</li>\n</ul>\n</blockquote>\n<h3 id=\"3-buildbymethod\">3. BuildByMethod</h3>\n<blockquote>\n<ul>\n<li>通过command的CreateParameter方法创建参数,然后设置参数名</li>\n</ul>\n</blockquote>\n<h3 id=\"4-parameterbuilder的成员\">4. ParameterBuilder的成员</h3>\n<blockquote>\n<ul>\n<li>New方法用于创建参数实例</li>\n<li>SetParameterName方法用于设置参数的ParameterName属性</li>\n<li>SetDbType方法用于设置参数的DbType属性</li>\n<li>SetValue方法用于设置参数的Value属性</li>\n<li>GetParameterName方法用于生成集合参数的子参数名</li>\n</ul>\n</blockquote>\n<h3 id=\"5-集合参数\">5. 集合参数</h3>\n<blockquote>\n<ul>\n<li>大部分数据库并不支持集合参数</li>\n<li>因此需要生成多个单独的子参数来实际执行</li>\n<li>eg: IN @Ids 需要转化为 IN (@Ids0, @Ids1, @Ids2),Ids为集合参数</li>\n<li>集合参数很特殊,需要实际执行的时候才确定实际子参数的个数</li>\n<li>通过预编译可以生成遍历实参集合生成子参数的代码</li>\n</ul>\n</blockquote>\n<h2 id=\"五iparameterfactory\">五、IParameterFactory</h2>\n<blockquote>\n<ul>\n<li>IParameterFactory就是参数处理的抽象</li>\n<li>ParameterFactory是默认实现</li>\n<li>CloneParameterFactory是Clone方式实现</li>\n<li>而IParameterFactory作为CommandBuilder的成员,处理参数部分的逻辑</li>\n</ul>\n</blockquote>\n<h3 id=\"1-parameterfactory\">1. ParameterFactory</h3>\n<blockquote>\n<ul>\n<li>默认的参数处理实现</li>\n<li>ParameterFactory包含ParameterBuilder,用于生成更高效的参数处理代码</li>\n<li>CloneParameterFactory也需要调用ParameterFactory的功能</li>\n</ul>\n</blockquote>\n<h4 id=\"11-数据库类型处理\">1.1 数据库类型处理</h4>\n<blockquote>\n<ul>\n<li>可以通过重写CheckDbTypeCore方法来处理特殊的数据库类型映射需求</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 处理数据库类型(预留扩展处理特殊需求)\n/// &lt;/summary&gt;\n/// &lt;param name=\"valueType\"&gt;&lt;/param&gt;\nprotected virtual DbType CheckDbTypeCore(Type valueType)\n    =&gt; CheckDbType(valueType);\n/// &lt;summary&gt;\n/// 默认数据库类型\n/// &lt;/summary&gt;\n/// &lt;param name=\"valueType\"&gt;&lt;/param&gt;\n/// &lt;returns&gt;&lt;/returns&gt;\npublic static DbType CheckDbType(Type valueType)\n{\n    if (valueType.IsArray)\n        return DbType.Binary;\n    var typeCode = Type.GetTypeCode(valueType);\n    return typeCode switch\n    {\n        TypeCode.Byte =&gt; DbType.Byte,\n        TypeCode.SByte =&gt; DbType.SByte,\n        TypeCode.Int16 =&gt; DbType.Int16,\n        TypeCode.UInt16 =&gt; DbType.UInt16,\n        TypeCode.Int32 =&gt; DbType.Int32,\n        TypeCode.UInt32 =&gt; DbType.UInt32,\n        TypeCode.Int64 =&gt; DbType.Int64,\n        TypeCode.UInt64 =&gt; DbType.UInt64,\n        TypeCode.Single =&gt; DbType.Single,\n        TypeCode.Double =&gt; DbType.Double,\n        TypeCode.Decimal =&gt; DbType.Decimal,\n        TypeCode.Boolean =&gt; DbType.Boolean,\n        TypeCode.String =&gt; DbType.String,\n        TypeCode.Char =&gt; DbType.StringFixedLength,\n        TypeCode.DateTime =&gt; DbType.DateTime,\n        _ =&gt; DbType.Object,\n    };\n}\n</code></pre>\n<h4 id=\"12-createparameter方法\">1.2 CreateParameter方法</h4>\n<blockquote>\n<ul>\n<li>实际CreateParameter专用于CloneParameterFactory</li>\n<li>用于创建参数原型,以便后续Clone使用</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 构造参数\n/// &lt;/summary&gt;\n/// &lt;param name=\"valueType\"&gt;&lt;/param&gt;\n/// &lt;returns&gt;&lt;/returns&gt;\nDbParameter CreateParameter(Type valueType);\n/// &lt;summary&gt;\n/// 构造参数\n/// &lt;/summary&gt;\n/// &lt;param name=\"name\"&gt;&lt;/param&gt;\n/// &lt;param name=\"valueType\"&gt;&lt;/param&gt;\n/// &lt;returns&gt;&lt;/returns&gt;\nDbParameter CreateParameter(string name, Type valueType);\n</code></pre>\n<h4 id=\"13-实现接口iparameterbuilder\">1.3 实现接口IParameterBuilder</h4>\n<blockquote>\n<ul>\n<li>以下Create方法实际用于构造参数表达式</li>\n<li>其中_parameterBuilder就是ParameterBuilder实例,前面有介绍</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">public Expression Create(IEmitBuilder builder, string name, Expression value)\n    =&gt; Create(builder, Expression.Constant(name), value);\n/// &lt;summary&gt;\n/// 构造参数\n/// &lt;/summary&gt;\n/// &lt;param name=\"builder\"&gt;&lt;/param&gt;\n/// &lt;param name=\"parameterName\"&gt;&lt;/param&gt;\n/// &lt;param name=\"value\"&gt;&lt;/param&gt;\n/// &lt;returns&gt;&lt;/returns&gt;\npublic Expression Create(IEmitBuilder builder, Expression parameterName, Expression value)\n{\n    // var parameter = command.CreateParameter();\n    // parameter.ParameterName = parameterName;\n    var parameter = _parameterBuilder.New(builder, parameterName);\n    // parameter.DbType = dbType;\n    _parameterBuilder.SetDbType(builder, parameter, CheckDbTypeCore(value.Type));\n    // parameter.Value = value;\n    _parameterBuilder.SetValue(builder, parameter, value);\n    return parameter;\n}\n</code></pre>\n<h4 id=\"14-实现接口icollectparameterbuilder\">1.4 实现接口ICollectParameterBuilder</h4>\n<blockquote>\n<ul>\n<li>ICollectParameterBuilder用于处理集合参数的子参数</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">public Expression CreateIndex(IEmitBuilder builder, Expression prefix, Expression index, Expression value)\n    =&gt; Create(builder, ParameterBuilder.GetParameterName(prefix, index), value);\n</code></pre>\n<h3 id=\"2-cloneparameterfactory\">2. CloneParameterFactory</h3>\n<blockquote>\n<ul>\n<li>CloneParameterFactory由CloneParameterBuilder和CloneCollectParameterBuilder组成</li>\n<li>CloneParameterBuilder通过Clone方式创建参数</li>\n<li>CloneCollectParameterBuilder通过Clone方式创建集合参数</li>\n</ul>\n</blockquote>\n<h4 id=\"3-cloneparameterbuilder\">3. CloneParameterBuilder</h4>\n<h4 id=\"31-cloneparameterbuilder包含parameterbuilderparameterfactory和iemitconverter成员\">3.1 CloneParameterBuilder包含ParameterBuilder、ParameterFactory和IEmitConverter成员</h4>\n<blockquote>\n<ul>\n<li>ParameterBuilder用于处理参数值</li>\n<li>ParameterFactory用于生成参数原型,以便Clone使用</li>\n<li>IEmitConverter用于复制参数</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">class CloneParameterBuilder(ParameterBuilder original, ParameterFactory factory, IEmitConverter cloneConverter);\n</code></pre>\n<h4 id=\"32-getprototype方法\">3.2 GetProtoType方法</h4>\n<blockquote>\n<ul>\n<li>用于生成参数原型并缓存</li>\n<li>调用ParameterFactory的CreateParameter方法生成参数原型</li>\n<li>按参数名和类型缓存</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">    /// &lt;summary&gt;\n    /// 获取原型缓存\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"name\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"valueType\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public DbParameter GetProtoType(string name, Type valueType)\n    {\n        var key = new NameTypedCacheKey(name, valueType);\n        if (_protoTypes.TryGetValue(key, out var cached))\n            return cached;\n#if NET9_0_OR_GREATER\n        lock (_lock)\n#else\n        lock (_protoTypes)\n#endif\n        {\n            if (_protoTypes.TryGetValue(key, out cached))\n                return cached;\n            return _protoTypes[key] = _factory.CreateParameter(name, valueType);\n        }\n    }\n</code></pre>\n<h4 id=\"33-create方法\">3.3 Create方法</h4>\n<blockquote>\n<ul>\n<li>Create用于构造参数表达式</li>\n<li>先调用GetProtoType方法获取参数原型</li>\n<li>该过程发生在预编译阶段,不会影响运行时性能</li>\n<li>通过缓存避免不同方法相同参数原型的重复创建</li>\n<li>通过cloneConverter生成Clone调用表达式</li>\n<li>最后调用ParameterBuilder设置参数值</li>\n</ul>\n</blockquote>\n<h3 id=\"4-clonecollectparameterbuilder\">4. CloneCollectParameterBuilder</h3>\n<blockquote>\n<ul>\n<li>CloneCollectParameterBuilder用于处理集合参数</li>\n</ul>\n</blockquote>\n<h4 id=\"31-clonecollectparameterbuilder也是包含parameterbuilderparameterfactory和iemitconverter成员\">3.1 CloneCollectParameterBuilder也是包含ParameterBuilder、ParameterFactory和IEmitConverter成员</h4>\n<blockquote>\n<ul>\n<li>ParameterBuilder用于处理参数值</li>\n<li>ParameterFactory用于生成参数原型,以便Clone使用</li>\n<li>IEmitConverter用于复制参数</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">class CloneCollectParameterBuilder(ParameterBuilder original, ParameterFactory factory, IEmitConverter cloneConverter);\n</code></pre>\n<h4 id=\"32-getprototype方法-1\">3.2 GetProtoType方法</h4>\n<blockquote>\n<ul>\n<li>用于生成集合参数原型并缓存</li>\n<li>调用ParameterFactory的CreateParameter方法生成参数原型</li>\n<li>按类型缓存</li>\n<li>CollectParameterPrototype(集合参数原型)用于实际处理集合参数的子参数</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">    /// &lt;summary&gt;\n    /// 获取原型缓存\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"valueType\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public CollectParameterPrototype GetProtoType(Type valueType)\n    {\n        if (_protoTypes.TryGetValue(valueType, out var protoType))\n            return protoType;\n#if NET9_0_OR_GREATER\n        lock (_lock)\n#else\n        lock (_protoTypes)\n#endif\n        {\n            if (_protoTypes.TryGetValue(valueType, out protoType))\n                return protoType;\n            var parameter = _factory.CreateParameter(valueType);\n            return _protoTypes[valueType] = new(_original, parameter, _cloneConverter);\n        }\n    }\n</code></pre>\n<h3 id=\"4-collectparameterprototype\">4. CollectParameterPrototype</h3>\n<blockquote>\n<ul>\n<li>集合参数原型</li>\n</ul>\n</blockquote>\n<h4 id=\"41-包含parameterbuilderiemitconverter和原型缓存\">4.1 包含ParameterBuilder、IEmitConverter和原型缓存</h4>\n<pre><code class=\"language-csharp\">class CollectParameterPrototype(ParameterBuilder original, ConstantExpression cached, IEmitConverter cloneConverter);\n</code></pre>\n<h4 id=\"42-createindex方法\">4.2 CreateIndex方法</h4>\n<blockquote>\n<ul>\n<li>CreateIndex用于构造集合参数的子参数</li>\n<li>通过cloneConverter生成Clone调用表达式</li>\n<li>最后调用ParameterBuilder设置参数名和参数值</li>\n</ul>\n</blockquote>\n<h2 id=\"六toexecutor\">六、ToExecutor</h2>\n<blockquote>\n<ul>\n<li>由于ShadowBuilder包含数据源可以很方便转化为ShadowExecutor</li>\n<li>增加ToExecutor方法简化操作</li>\n<li>ToExecutor是IShadowBuilder的方法,所以ShadowCachedBuilder也支持</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 转化为执行器\n/// &lt;/summary&gt;\n/// &lt;param name=\"commandTimeout\"&gt;&lt;/param&gt;\n/// &lt;returns&gt;&lt;/returns&gt;\nShadowExecutor ToExecutor(int? commandTimeout = null);\n</code></pre>\n<h2 id=\"七总结\">七、总结</h2>\n<blockquote>\n<ul>\n<li>通过嗅探实际类型生成更高效的参数处理代码</li>\n<li>不同数据库差异为此带来了复杂性</li>\n<li>部分数据库可以通过Clone方式创建参数提高性能</li>\n</ul>\n</blockquote>\n<h3 id=\"1-一般使用示例\">1. 一般使用示例</h3>\n<blockquote>\n<ul>\n<li>一般使用CreateCache方法创建ShadowBuilder</li>\n<li>如果是一次性使用无需缓存可以使用Create方法代替</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">var engine = new MySqlEngine();\nvar dataSource = new MySqlDataSource(ConnectionString);\nvar builder = ShadowBuilder.CreateCache(Mapper.Default, engine, dataSource);\nvar select = table.ToQuery()\n    .And(table.Id.Equal())\n    .ToSelect()\n    .SelectSelfColumns();\nvar compiled = select.BuildQuery&lt;Todo, Todo&gt;(builder);\n</code></pre>\n<h4 id=\"11-参数处理生成如下代码\">1.1 参数处理生成如下代码</h4>\n<pre><code class=\"language-csharp\">(DbCommand command, Todo param) =&gt;\n{\n    var parameters = ((MySqlCommand)command).Parameters;\n    var t = new MySqlParameter();\n    t.ParameterName = \"Id\";\n    t.DbType = DbType.Int64;\n    t.Value = param.Id;\n\n    return parameters.Add(t);\n}\n</code></pre>\n<h3 id=\"2-启用clone方式示例\">2. 启用Clone方式示例</h3>\n<blockquote>\n<ul>\n<li>启用Clone要复杂一点</li>\n<li>需要通过CloneParameter生成一个ParameterFactory</li>\n<li>然后传入ShadowBuilder的CreateCache方法中</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">var engine = new MySqlEngine();\nvar dataSource = new MySqlDataSource(ConnectionString);\nvar parameterFactory = ParameterFactory.CloneParameter(new MySqlCommand())\nvar builder = ShadowBuilder.CreateCache(Mapper.Default, engine, dataSource, parameterFactory);\nvar select = table.ToQuery()\n    .And(table.Id.Equal())\n    .ToSelect()\n    .SelectSelfColumns();\nvar compiled = select.BuildQuery&lt;Todo, Todo&gt;(builder);\n</code></pre>\n<h4 id=\"21-参数处理生成如下代码\">2.1 参数处理生成如下代码</h4>\n<blockquote>\n<ul>\n<li>cached是预先构造好作为常量的参数缓存</li>\n<li>很明显如果Clone比new更快的话,这个代码会更高效</li>\n<li>Mysql下此方法耗时为原来的20%(也就是性能提高4倍)</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">(DbCommand command, Todo param) =&gt;\n{\n    var parameters = ((MySqlCommand)command).Parameters;\n    var t = cached.Clone();\n    t.Value = param.Id;\n\n    return parameters.Add(t);\n}\n</code></pre>\n<p>另外源码托管地址: <a href=\"https://github.com/donetsoftwork/DBShadow.net\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/donetsoftwork/DBShadow.net</a> ，欢迎大家直接查看源码。<br />\ngitee同步更新:<a href=\"https://gitee.com/donetsoftwork/DBShadow.net\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/donetsoftwork/DBShadow.net</a></p>\n<p>如果大家喜欢请动动您发财的小手手帮忙点一下Star,谢谢！！！</p>\n\n</div>\n<div class=\"clear\"></div>\n</div>\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-01-23 14:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xiangji\">xiangji</a>&nbsp;\n阅读(<span id=\"post_view_count\">101</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "TCP三次握手与四次挥手：两个“社恐”程序的破冰与告别仪式",
      "link": "https://www.cnblogs.com/sun-10387834/p/19521814",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19521814\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 13:24\">\n    <span>TCP三次握手与四次挥手：两个“社恐”程序的破冰与告别仪式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在网络世界里，TCP协议绝对是“严谨派”代表——不像UDP那样“发完就跑”，TCP要让两个设备传数据，非得先走一套“确认三连”的破冰流程；而聊完收场时，也得按规矩来一套“告别四步走”，绝不敷衍离场。这两套流程，就是咱们今天要扒透的<strong>TCP三次握手（建立连接）</strong>与<strong>四次挥手（关闭连接）</strong>。</p>\n<p>其实说白了，三次握手是客户端和服务器的“破冰仪式”，就像两个社恐网友第一次打电话，反复确认信号通不通才敢开唠；而四次挥手则是“体面告别”，好比聊天结束后，双方要反复确认“你说完了吗”“我说完了，你可以挂了”，生怕挂早了漏了重要内容。前面咱们用生活化场景拆解了三次握手的实际流程，接下来就顺着节奏，把四次挥手的通俗逻辑和底层原理一并讲透。</p>\n<h2 id=\"先回顾三次握手建立连接核心流程实际版\">先回顾：三次握手（建立连接）核心流程（实际版）</h2>\n<p>为了让挥手流程衔接更顺畅，咱们先快速回顾三次握手的实际核心，避免上下文脱节：</p>\n<ul>\n<li>\n<p>第一步（客户端→服务器）：客户端发SYN报文发起连接，内核分配临时端口、创建TCB，状态从CLOSED→SYN-SENT；</p>\n</li>\n<li>\n<p>第二步（服务器→客户端）：服务器收SYN后发SYN+ACK报文回应，创建TCB，状态从LISTEN→SYN-RCVD；</p>\n</li>\n<li>\n<p>第三步（客户端→服务器）：客户端收SYN+ACK后发ACK报文（可带数据），状态从SYN-SENT→ESTABLISHED；服务器收ACK后状态→ESTABLISHED，连接正式建立。</p>\n</li>\n</ul>\n<p>连接建立后，双方就可以愉快传输数据了。而当数据传完要关闭连接时，因为TCP是“全双工通信”（双方可同时发数据），不能像建立连接那样简化为三次，必须通过四次交互确认双方都不再发数据，这就是四次挥手的由来。</p>\n<h2 id=\"前置补充四次挥手的核心前提与关键概念\">前置补充：四次挥手的核心前提与关键概念</h2>\n<p>挥手前先明确两个核心点，避免理解偏差：</p>\n<h3 id=\"1-全双工通信与关闭逻辑\">1. 全双工通信与关闭逻辑</h3>\n<p>TCP是全双工协议，客户端和服务器可同时发送数据。因此关闭连接时，要分别确认“客户端→服务器”和“服务器→客户端”两个方向的数据流都已终止，不能一次性关闭双向连接。</p>\n<h3 id=\"2-新增标记位fin与状态\">2. 新增标记位（FIN）与状态</h3>\n<p>挥手过程除了用到ACK标记位，还会用到新的标记位FIN（Finish，结束），同时涉及几个新的TCP状态，核心如下：</p>\n<ul>\n<li>\n<p>【FIN=1】：表示发送方已无数据要发，请求关闭自己这边的数据流；</p>\n</li>\n<li>\n<p>【FIN-WAIT-1】：发送FIN后等待对方ACK的状态；</p>\n</li>\n<li>\n<p>【CLOSE-WAIT】：收到对方FIN后，确认关闭请求，等待自己这边数据发完再发FIN；</p>\n</li>\n<li>\n<p>【TIME-WAIT】：客户端最后发完ACK后，等待2MSL（报文最大生存时间），确保对方收到FIN的ACK，避免报文丢失导致重发。</p>\n</li>\n</ul>\n<h2 id=\"四次挥手全流程社恐式告别实际底层交互\">四次挥手全流程：社恐式告别+实际底层交互</h2>\n<p>咱们依然以“手机退出微信”为例，一边用通俗对话理解逻辑，一边补充操作系统内核、报文交互等实际细节，兼顾易懂性与技术深度。</p>\n<h3 id=\"第一步主动方发起告别请求finack报文主动关闭\">第一步：主动方发起告别请求（FIN+ACK报文，主动关闭）</h3>\n<p><strong>场景</strong>：你点击微信退出登录，客户端（手机）作为主动关闭方，告知服务器“我这边数据发完了，要关连接了”。</p>\n<p><strong>实际行为</strong>：微信客户端程序调用close()接口，通知内核关闭连接。客户端内核做两件事：</p>\n<ol>\n<li>\n<p>停止发送新数据，将未发完的数据一次性发完，然后构造FIN+ACK报文（FIN=1表示关闭自身数据流，ACK=1确认之前收到的服务器数据），序号seq=u（u是客户端最后一次发数据的序号+1），确认号ack=v（v是服务器最后一次发数据的序号+1）；</p>\n</li>\n<li>\n<p>发送报文后，释放部分资源，仅保留接收数据的能力（防止服务器还有数据要发）。</p>\n</li>\n</ol>\n<p><strong>拟人对话</strong>：客户端（温和）：“服务器大佬，我这边数据都发完了，要关我这边的连接了（FIN=1），你之前发的内容我都收到了（ACK=1），你还有要发的吗？”</p>\n<p><strong>状态变化</strong>：客户端TCP状态从ESTABLISHED→FIN-WAIT-1，开始计时，等待服务器的ACK回应。</p>\n<h3 id=\"第二步被动方确认告别请求ack报文等待自身数据发完\">第二步：被动方确认告别请求（ACK报文，等待自身数据发完）</h3>\n<p><strong>场景</strong>：微信服务器收到客户端的告别请求，先确认“收到了”，同时继续处理自己这边未发完的数据（比如最后的登录状态同步）。</p>\n<p><strong>实际行为</strong>：服务器内核收到FIN+ACK报文后，校验序号、确认号无误，然后：</p>\n<ol>\n<li>\n<p>构造ACK报文（ACK=1），序号seq=v，确认号ack=u+1（告知客户端“你的FIN我收到了，你可以不用等我回应了”）；</p>\n</li>\n<li>\n<p>发送ACK后，服务器不会立即关闭连接，而是继续发送自身未完成的数据，此时服务器仅关闭“客户端→服务器”的数据流，自身仍可向客户端发数据。</p>\n</li>\n</ol>\n<p><strong>拟人对话</strong>：服务器（沉稳）：“收到你的告别请求了（ACK=1），我这边还有点数据没发完，你先等我一下，发完了我再告诉你。”</p>\n<p><strong>状态变化</strong>：服务器TCP状态从ESTABLISHED→CLOSE-WAIT；客户端收到ACK后，状态从FIN-WAIT-1→FIN-WAIT-2，等待服务器发完数据后发起的FIN报文。</p>\n<h3 id=\"第三步被动方发起告别请求finack报文被动关闭\">第三步：被动方发起告别请求（FIN+ACK报文，被动关闭）</h3>\n<p><strong>场景</strong>：服务器发完所有数据，告知客户端“我这边也发完了，咱们可以彻底关连接了”。</p>\n<p><strong>实际行为</strong>：服务器发完剩余数据后，内核构造FIN+ACK报文（FIN=1表示关闭自身数据流，ACK=1确认之前的交互），序号seq=w（w是服务器最后一次发数据的序号+1），确认号ack=u+1（与第二步的ack一致，因为客户端此时已无数据发送），发送给客户端。</p>\n<p><strong>拟人对话</strong>：服务器（完成收尾）：“我这边数据也发完了，要关我这边的连接了（FIN=1），你之前的消息我都收到了（ACK=1），咱们可以告别了。”</p>\n<p><strong>状态变化</strong>：服务器TCP状态从CLOSE-WAIT→LAST-ACK，开始计时，等待客户端的最终ACK确认。</p>\n<h3 id=\"第四步主动方最终确认告别ack报文等待超时\">第四步：主动方最终确认告别（ACK报文，等待超时）</h3>\n<p><strong>场景</strong>：客户端收到服务器的告别请求，确认双方都无数据要发，给出最终回应，同时等待一段时间确保服务器收到回应。</p>\n<p><strong>实际行为</strong>：客户端内核收到FIN+ACK报文后，校验无误，然后：</p>\n<ol>\n<li>\n<p>构造ACK报文（ACK=1），序号seq=u+1，确认号ack=w+1（告知服务器“你的FIN我收到了，你可以安全关闭了”），发送给服务器；</p>\n</li>\n<li>\n<p>发送ACK后，客户端不立即关闭连接，而是进入TIME-WAIT状态，等待2MSL（通常是2分钟左右），确保服务器能收到ACK（若服务器没收到，会重发FIN，客户端可再次回应）。等待超时后，释放所有资源和TCB。</p>\n</li>\n</ol>\n<p><strong>拟人对话</strong>：客户端（放心）：“收到你的告别了（ACK=1），我等一会儿再挂，确保你能收到我的回应，咱们下次见～”</p>\n<p><strong>状态变化</strong>：客户端TCP状态从FIN-WAIT-2→TIME-WAIT（等待2MSL）→CLOSED；服务器收到ACK后，状态从LAST-ACK→CLOSED，释放所有资源，至此双向连接完全关闭。</p>\n<h2 id=\"可视化流程图三次握手四次挥手全链路版\">可视化流程图：三次握手+四次挥手全链路版</h2>\n<p>结合连接建立、数据传输、连接关闭的完整链路，用Mermaid图还原内核状态、报文交互全流程：</p>\n<p>暂时无法在豆包文档外展示此内容</p>\n<h2 id=\"关键差异与核心疑问解答\">关键差异与核心疑问解答</h2>\n<h3 id=\"1-为啥挥手要四次握手却只要三次\">1. 为啥挥手要四次，握手却只要三次？</h3>\n<p>核心原因是“全双工通信”与“连接阶段的特殊性”：</p>\n<ul>\n<li>\n<p>三次握手时，服务器的SYN（同步连接）和ACK（确认客户端）可以合并为一个SYN+ACK报文——因为此时服务器还没有数据要发，同步和确认可以一次性完成；</p>\n</li>\n<li>\n<p>四次挥手时，服务器收到客户端的FIN后，不能立即发FIN（可能还有数据要发），只能先回一个ACK确认；等数据发完后，再单独发FIN，因此ACK和FIN无法合并，必须分成两步，导致总次数变为四次。</p>\n</li>\n</ul>\n<h3 id=\"2-time-wait状态为啥要等2msl\">2. TIME-WAIT状态为啥要等2MSL？</h3>\n<p>主要是两个目的，避免连接残留问题：</p>\n<ul>\n<li>\n<p>确保服务器收到最终ACK：若第四步的ACK丢失，服务器会在超时后重发FIN，2MSL的时间足够客户端收到重发的FIN并再次回应；</p>\n</li>\n<li>\n<p>避免旧报文干扰新连接：2MSL是报文在网络中的最大生存时间，等待超时后，网络中该连接的所有旧报文都会失效，后续新连接用相同端口也不会被干扰。</p>\n</li>\n</ul>\n<h3 id=\"3-常见坑点实际场景补充\">3. 常见坑点（实际场景补充）</h3>\n<ul>\n<li>\n<p>【CLOSE-WAIT累积】：服务器处于CLOSE-WAIT状态时，若应用程序未及时调用close()发FIN，会导致连接资源泄露，大量CLOSE-WAIT状态会耗尽服务器端口；</p>\n</li>\n<li>\n<p>【TIME-WAIT过多】：高并发场景下，客户端频繁关闭连接会产生大量TIME-WAIT状态，可通过调整内核参数（如缩短2MSL时间、开启端口复用）优化；</p>\n</li>\n<li>\n<p>【半关闭连接】：若一方发了FIN但另一方还在发数据，发FIN的一方会拒绝接收数据，导致数据丢失，因此关闭连接前需确保双方都无数据要发。</p>\n</li>\n</ul>\n<h2 id=\"总结tcp连接的始与终核心都是可靠\">总结：TCP连接的“始”与“终”，核心都是“可靠”</h2>\n<p>TCP三次握手与四次挥手，本质都是围绕“可靠传输”设计的流程：三次握手通过双向确认，确保双方通信能力正常，为数据传输铺路；四次挥手通过分步确认，确保双向数据流都已终止，避免数据丢失或残留。</p>\n<p>从社恐式的破冰到体面的告别，TCP用看似繁琐的步骤，弥补了网络传输的不可靠性。实际应用中遇到的“连接超时”“连接重置”“端口耗尽”等问题，本质都和这两套流程的某个环节异常有关——看懂了握手与挥手的底层逻辑，就能快速定位问题根源，再也不是只知现象不知本质的“调包侠”啦～</p>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19521814\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19521814</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-23 13:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">38</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "算竞一题中的代码设计与技巧解析",
      "link": "https://www.cnblogs.com/Reisentyan/p/19521805",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Reisentyan/p/19521805\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 13:21\">\n    <span>算竞一题中的代码设计与技巧解析</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><em>本文使用了ai辅助，旨在更好的帮助大家理解一些技巧</em></p>\n<p><a href=\"https://www.nowcoder.com/practice/2b0c636cf77d441fa96d40ac64290d39?channelPut=tracker2\" rel=\"noopener nofollow\" target=\"_blank\">邮递员送信_牛客题霸_牛客网</a></p>\n<p>以这一题为例，需要对节点 1 求 两次 dijkstra，怎么使得代码写的简洁？<br />\nac 代码如下，我们来一一解析：</p>\n<pre><code>void solve()\n{\n\tint n(q_), m(q_);\n\tusing ED = array&lt;int, 2&gt;;\n\tusing GRAPH = vector&lt;vector&lt;ED&gt;&gt;;\n\n\tGRAPH tr(n + 1);\n\tGRAPH rtr(n + 1);\n\tffp(i, 1, m)\n\t{\n\t\tint u(q_), v(q_), w(q_);\n\t\ttr[u].push_back({ w,v });//tr是树边，本人的习惯\n\t\trtr[v].push_back({ w,u });//rtr是反图\n\t}\n\n\tauto dij = [&amp;](int st, GRAPH&amp; gp)-&gt;ll\n\t\t{\n\t\t\tpriority_queue&lt;ED, vector&lt;ED&gt;, greater&lt;ED&gt;&gt;dui;\n\t\t\tvector&lt;int&gt;dis(n + 1, iINF); dis[st] = 0;\n\n\t\t\tdui.push({ 0,st });\n\t\t\twhile (dui.size())\n\t\t\t{\n\t\t\t\tauto [w, now] = dui.top();\n\t\t\t\tdui.pop();\n\t\t\t\tif (dis[now] &lt; w)continue;\n\t\t\t\tfor (auto [nxtw, nxt] : gp[now])\n\t\t\t\t{\n\t\t\t\t\tif (nxtw + dis[now] &gt;= dis[nxt])continue;\n\t\t\t\t\tdis[nxt] = nxtw + dis[now];\n\t\t\t\t\tdui.push({ nxtw + dis[now],nxt });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn accumulate(dis.begin() + 1, dis.end(), 0ll);\n\t\t};\n\tcout &lt;&lt; dij(1, tr) + dij(1, rtr) &lt;&lt; endl;\n\treturn;\n}\n</code></pre>\n<p><strong>【初始化与快读】</strong> 首先，我们使用 <code>n(q_), m(q_)</code> 对变量进行初始化。这里的 <code>q_</code> 是封装好的快读对象（Fast I/O），用于高效读取整数。值得一提的是，<code>n(q_)</code> 使用的是<strong>直接初始化（Direct Initialization）</strong>，而我们常见的 <code>n = q_</code> 属于<strong>复制初始化（Copy Initialization）</strong>。虽然在基础类型上二者生成的汇编指令并无差异，但直接初始化更具 Modern C++ 的风格。</p>\n<p><strong>【类型别名优化】</strong> 为了提升代码的可读性与编写效率，我们使用 <code>using ED = array&lt;int, 2&gt;</code> 为边的存储结构定义别名，同理定义了 <code>GRAPH</code>。这样不仅减少了冗余代码，也便于后续维护。</p>\n<p><strong>【存图细节】</strong> 在读入边权并建图时，有一个关键细节：<code>tr[u].push_back({ w, v })</code>。请注意，我们将 <strong>权值 w</strong> 放在了 <code>array</code> 的首位。 这是为了配合后续的 <code>priority_queue</code>。由于 STL 的容器默认按字典序比较（即先比较第一个元素），将权值置于首位，可以直接利用默认的比较规则实现“按权值排序”，无需额外编写比较函数。</p>\n<p><strong>【Dijkstra 的封装】</strong> 我们使用 Lambda 表达式封装了 Dijkstra 算法。在传参时，图结构 <code>GRAPH</code> 必须使用<strong>引用传递</strong>（建议为 <code>const</code> 引用），以避免在函数调用时发生巨大的内存拷贝开销，防止 TLE（超时）。</p>\n<p><strong>【累加器的陷阱】</strong> 计算最终结果时，我使用了 <code>&lt;numeric&gt;</code> 库中的 <code>accumulate</code> 函数。这里潜藏着一个常见的<strong>溢出陷阱</strong>：<code>accumulate</code> 的第三个参数决定了累加过程的数据类型。 如果传入 <code>0</code>，编译器会将其推导为 <code>int</code> 类型进行累加，这在处理大数时会导致溢出。因此，必须显式传入 <code>0ll</code>（即 <code>long long</code> 类型的 0），以确保计算过程使用长整型。</p>\n<p><strong>【I/O 细节】</strong> 最后，输出时使用 <code>\\n</code> 替代 <code>endl</code>。<code>endl</code> 会强制刷新缓冲区，在大规模输出场景下可能导致显著的性能损耗。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-23 13:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Reisentyan\">粉紫系超人气月兔铃仙</a>&nbsp;\n阅读(<span id=\"post_view_count\">37</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "从0构建WAV文件：读懂计算机文件的本质",
      "link": "https://www.cnblogs.com/reasa/p/19521361",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/reasa/p/19521361\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 12:56\">\n    <span>从0构建WAV文件：读懂计算机文件的本质</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"从0构建wav文件读懂计算机文件的本质\">从0构建WAV文件：读懂计算机文件的本质</h1>\n<p>虽然接触计算机有一段时间了，但是我的视野一直局限于一个较小的范围之内，往往只能看到于算法竞赛相关的内容，计算机各种文件在我看来十分复杂，认为构建他们并能达到目的是一件困难的事情，然而近期我观看了油管上Magicalbat大神的<a href=\"https://www.youtube.com/watch?v=JqJPBu7GXvw\" rel=\"noopener nofollow\" target=\"_blank\">视频</a>，发现其实它们的本质都惊人地简单：<strong>所有计算机文件，都是按特定规则组织的二进制数据</strong>，是人为规定好格式再由计算机解析，对于我们来说，只要根据规定格式进行编辑，就能够成功构建。</p>\n<p>今天，我们就从最朴素的方式入手，通过手动构建一个WAV音频文件，拆解WAV格式的底层逻辑，同时理解一个核心认知：只要掌握了文件的格式规范，任何类型的文件都能像搭积木一样，一行行代码“拼”出来。</p>\n<h2 id=\"先认识wavwav文件的格式\">先认识WAV：WAV文件的格式</h2>\n<p>WAV是微软开发的无损音频格式，相比于压缩后的MP3，它的结构更直白，没有复杂的编码压缩，因此我们能够通过C++文件写入的方式直接完成wav文件的构建，wav文件的核心由三个关键的“数据块(Chunk)”组成：</p>\n<ul>\n<li><strong>RIFF块</strong>：文件的“身份卡”，告诉计算机“我是一个WAV文件”；</li>\n<li><strong>fmt块</strong>：音频的“参数说明”，记录采样率、声道数、位深等核心参数；</li>\n<li><strong>data块</strong>：真正的音频数据，存储着声音的数字信号。</li>\n</ul>\n<p>而每个块的内容又如下图所示：</p>\n<p><img alt=\"\" src=\"https://i.postimg.cc/d06jVWRx/wavstruct.jpg\" /></p>\n<p><strong>RIFF:</strong></p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>字节数</th>\n<th>数据类型</th>\n<th>固定值/计算规则</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ChunkID</td>\n<td>4</td>\n<td>ASCII字符</td>\n<td>固定为\"RIFF\"（无终止符，严格4字节）</td>\n</tr>\n<tr>\n<td>ChunkSize</td>\n<td>4</td>\n<td>32位无符号整数</td>\n<td>取值 = 整个WAV文件大小 - 8字节（减去ChunkID和ChunkSize自身的8字节）</td>\n</tr>\n<tr>\n<td>Format</td>\n<td>4</td>\n<td>ASCII字符</td>\n<td>固定为\"WAVE\"（无终止符，严格4字节）</td>\n</tr>\n</tbody>\n</table>\n<p><strong>fmt:</strong></p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>字节数</th>\n<th>数据类型</th>\n<th>固定值/计算规则</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ChunkID</td>\n<td>4</td>\n<td>ASCII字符</td>\n<td>固定为\"fmt \"（末尾空格，无终止符）</td>\n</tr>\n<tr>\n<td>ChunkSize</td>\n<td>4</td>\n<td>32位无符号整数</td>\n<td>PCM编码（最常用）下固定为16（代表后续字段的总字节数，不含ChunkID和ChunkSize）</td>\n</tr>\n<tr>\n<td>AudioFormat（代码中Tag）</td>\n<td>2</td>\n<td>16位无符号整数</td>\n<td>编码格式：1=PCM（无压缩，通用）；3=IEEE浮点；6=μ律；7=A律等</td>\n</tr>\n<tr>\n<td>NumChannels（代码中Chnnels，拼写笔误）</td>\n<td>2</td>\n<td>16位无符号整数</td>\n<td>声道数：1=单声道；2=立体声；&gt;2=多声道</td>\n</tr>\n<tr>\n<td>SampleRate</td>\n<td>4</td>\n<td>32位无符号整数</td>\n<td>采样率（每秒采样次数）：常见44100Hz（CD音质）、48000Hz、22050Hz等</td>\n</tr>\n<tr>\n<td>ByteRate</td>\n<td>4</td>\n<td>32位无符号整数</td>\n<td>每秒音频数据字节数 = SampleRate × NumChannels × BitsPerSample / 8</td>\n</tr>\n<tr>\n<td>BlockAlign（代码中BloclAlign，拼写笔误）</td>\n<td>2</td>\n<td>16位无符号整数</td>\n<td>每个“采样帧”的字节数 = NumChannels × BitsPerSample / 8（播放器一次读取的最小单位）</td>\n</tr>\n<tr>\n<td>BitsPerSample（代码中BitsperSample）</td>\n<td>2</td>\n<td>16位无符号整数</td>\n<td>采样位深（每个采样点的比特数）：8/16/24/32，16位最常用</td>\n</tr>\n</tbody>\n</table>\n<p><strong>data:</strong></p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>字节数</th>\n<th>数据类型</th>\n<th>固定值/计算规则</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ChunkID（代码中DataId）</td>\n<td>4</td>\n<td>ASCII字符</td>\n<td>固定为\"data\"（无终止符，严格4字节）</td>\n</tr>\n<tr>\n<td>DataSize</td>\n<td>4</td>\n<td>32位无符号整数</td>\n<td>音频数据总字节数 = 采样总数 × BlockAlign；采样总数 = SampleRate × 音频时长</td>\n</tr>\n<tr>\n<td>音频数据区</td>\n<td>可变</td>\n<td>二进制流</td>\n<td>PCM编码下为线性整数/浮点数：16位位深对应int16_t，8位对应uint8_t，32位浮点对应float</td>\n</tr>\n</tbody>\n</table>\n<p>我们接下来的代码，就是严格按照这个模板，把每个部分的二进制数据“写”进文件里。</p>\n<h2 id=\"从零构建wav一行代码拆解核心逻辑\">从零构建WAV：一行代码拆解核心逻辑</h2>\n<p>下面是完整的C++代码（新手也能看懂），我们逐段拆解，看如何从0生成一个能播放的440Hz正弦波WAV文件：</p>\n<pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// 类型别名：让代码更易读，明确数据的字节长度\n#define u32 uint32_t  // 32位无符号整数（4字节）\n#define u16 uint16_t  // 16位无符号整数（2字节）\n#define f32 float     // 32位浮点数（4字节）\n#define i16 int16_t   // 16位有符号整数（2字节）\n#define HZ 44100      // 采样率：每秒采集44100个声音样本（标准音频采样率）\n#define DURATION 5    // 音频时长：5秒\n\n// 1. 定义WAV的三个核心数据块结构（对应格式规范）\n// RIFF块：文件整体标识\nstruct chunk1{\n    char ChunkID[4];   // 块标识，固定为\"RIFF\"\n    u32 ChunkSize;     // 从该字段到文件末尾的字节数（总字节数-8）\n    char Format[4];    // 格式类型，固定为\"WAVE\"\n}RIFF;\n\n// fmt块：音频参数配置\nstruct chunk2{\n    char ChunkID[4];   // 块标识，固定为\"fmt \"（注意末尾有空格）\n    u16 Tag;           // 编码格式，1代表PCM（无压缩）\n    u32 ChunkSize;     // fmt块的大小，PCM格式固定为16\n    u16 Chnnels;       // 声道数：1=单声道，2=立体声\n    u32 SampleRate;    // 采样率\n    u32 ByteRate;      // 每秒数据量 = 采样率×声道数×位深/8\n    u16 BloclAlign;    // 每个采样的总字节数 = 声道数×位深/8\n    u16 BitsperSample; // 每个采样的位深：16位（常见）\n}Fmt;\n\n// data块：音频数据存储区\nstruct chunk3{\n    char DataId[4];    // 块标识，固定为\"data\"\n    u32 DataSize;      // 音频数据的总字节数\n}Data;\n\nsigned main(int argc,char* argv[]){\n    // 打开文件：\"wb\"表示以二进制模式写入（关键！文件本质是二进制）\n    FILE *fp = fopen(\"test.wav\",\"wb\");\n    // 计算总采样数：采样率×时长（5秒×44100=220500个样本）\n    u32 NumSamples = HZ * DURATION;\n\n    // 2. 填充RIFF块并写入文件\n    memcpy(RIFF.ChunkID,\"RIFF\",4);          // 写入块标识\n    RIFF.ChunkSize = NumSamples*sizeof(u16)+36; // 计算块大小\n    memcpy(RIFF.Format,\"WAVE\",4);           // 声明为WAVE格式\n    fwrite(RIFF.ChunkID,sizeof(char),4,fp); // 写入4个字符的ChunkID\n    fwrite(&amp;RIFF.ChunkSize,sizeof(u32),1,fp); // 写入4字节的ChunkSize\n    fwrite(RIFF.Format,sizeof(char),4,fp); // 写入4个字符的Format\n\n    // 3. 填充fmt块并写入文件\n    memcpy(Fmt.ChunkID,\"fmt \",4);\n    Fmt.ChunkSize = 16;          // PCM格式下fmt块固定16字节\n    Fmt.Tag = 1;                 // PCM无压缩编码\n    Fmt.Chnnels = 1;             // 单声道\n    Fmt.SampleRate = HZ;         // 44100Hz采样率\n    Fmt.ByteRate = HZ*sizeof(u16); // 每秒字节数：44100×2=88200\n    Fmt.BloclAlign = Fmt.Chnnels * sizeof(u16); // 每个采样2字节\n    Fmt.BitsperSample = 16;      // 16位位深\n    // 按顺序写入fmt块的所有参数（严格遵循格式规范）\n    fwrite(&amp;Fmt.ChunkID,sizeof(char),4,fp);\n    fwrite(&amp;Fmt.ChunkSize,sizeof(u32),1,fp);\n    fwrite(&amp;Fmt.Tag,sizeof(u16),1,fp);\n    fwrite(&amp;Fmt.Chnnels,sizeof(u16),1,fp);\n    fwrite(&amp;Fmt.SampleRate,sizeof(u32),1,fp);\n    fwrite(&amp;Fmt.ByteRate,sizeof(u32),1,fp);\n    fwrite(&amp;Fmt.BloclAlign,sizeof(u16),1,fp);\n    fwrite(&amp;Fmt.BitsperSample,sizeof(u16),1,fp);\n\n    // 4. 填充data块并写入文件\n    memcpy(Data.DataId,\"data\",4);\n    Data.DataSize = NumSamples * sizeof(u16); // 音频数据总字节数\n    fwrite(&amp;Data.DataId,sizeof(char),4,fp);\n    fwrite(&amp;Data.DataSize,sizeof(u32),1,fp);\n\n    // 5. 生成音频数据并写入（440Hz正弦波，标准A调）\n    for(int i=0;i&lt;NumSamples;i++){\n        f32 t = (f32)i/HZ; // 计算当前时间点（秒）\n        // 生成440Hz正弦波的数值（声音的本质是振动，正弦波模拟声波）\n        f32 y =sinf(t*440.0f*2.0f*3.1415926f);\n        // 转换为16位整数（适配16位位深的音频）\n        i16 sample = (i16)(y*INT16_MAX);\n        // 写入单个音频样本（2字节）\n        fwrite(&amp;sample,sizeof(i16),1,fp);\n    }\n\n    fclose(fp); // 关闭文件\n    return 0;\n}\n</code></pre>\n<h2 id=\"所有文件都是按规则写二进制的产物\">所有文件，都是“按规则写二进制”的产物</h2>\n<p>写完这段代码，你可能会发现：生成WAV文件的过程，就是“按格式规范往文件里写二进制数据”的过程。而这个逻辑，适用于<strong>所有计算机文件</strong>：</p>\n<ul>\n<li><strong>TXT文档</strong>：本质是字符的ASCII/UTF-8编码（比如字符'A'对应二进制01000001），我们按顺序写入这些编码，就成了TXT文件；</li>\n<li><strong>BMP图片</strong>：由文件头（记录宽、高、位深）+ 像素数据（每个像素的RGB值）组成，按BMP格式写这些数据，就能生成图片；</li>\n<li><strong>MP4视频</strong>：哪怕是压缩过的视频，也是按MP4的格式规范，把编码后的视频帧、音频帧组织成二进制数据；</li>\n<li><strong>EXE可执行文件</strong>：遵循PE格式，把指令、数据、资源按规则写入，操作系统就能识别并运行。</li>\n</ul>\n<p>计算机之所以能“看懂”不同的文件，不是因为文件有“魔法”，而是因为程序员提前约定了“格式规范”——就像我们约定“RIFF”开头的是WAV文件，播放器读到这个标识，就按WAV的规则解析后续数据。</p>\n<h2 id=\"计算机的本质是朴素的规则\">计算机的本质是“朴素的规则”</h2>\n<p>对刚接触计算机的人来说，各种文件、软件、系统看似复杂，但拆解到最底层，都是“数据+规则”的组合，<br />\n只要我们对着格式手册，即便使用最朴素的方式，也能够成功构建出可以使用的音频文件。计算机的世界没有想象中那般复杂，计算机只在乎那最终排好队的 0 和 1。</p>\n<h2 id=\"进一步思考从文件到软件\">进一步思考：从文件到软件</h2>\n<p>了解了各类文件本质，我们自然能理解计算机中各个编辑软件的原理是什么了，就比如今天举的wav的例子，如果我们将示例程序改进一下，加入输入，那么这是否就成了一个简单的音频编辑软件了呢，所有的复杂软件（如 Photoshop、Premiere），底层逻辑都是如此：读取特定规则的二进制 -&gt; 在内存中加工处理 -&gt; 按规则写回二进制。当你不再把文件看作“黑盒”，你便拥有了重塑数字世界的能力。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-23 12:56</span>&nbsp;\n<a href=\"https://www.cnblogs.com/reasa\">reasa</a>&nbsp;\n阅读(<span id=\"post_view_count\">37</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "微软新利器！winapp CLI：一键打包、调试、集成 Windows 原生能力",
      "link": "https://www.cnblogs.com/chingho/p/19521120",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/chingho/p/19521120\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 11:19\">\n    <span>微软新利器！winapp CLI：一键打包、调试、集成 Windows 原生能力</span>\n    \n\n</a>\n\n\t\t</h1>\n\t\t<div class=\"clear\"></div>\n\t\t<div class=\"postBody\">\n\t\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        大家好，我是编程乐趣。好消息来了，微软官方发布 winapp 开源命令行工具：可以一键初始化开发环境、一键打包，让我们从繁琐的环境搭建中解脱出来，从而将更多精力集中在代码编写与产品创新上。## 📌 项目简介\n\n**winapp CLI** 是微软推出的一个**命令行工具**，旨在为 Windows 应用开发者提供统一、简洁的开发体验。它整合了 Windows SDK、App SDK、应用打包（M...\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>大家好，我是编程乐趣。好消息来了，微软官方发布 winapp 开源命令行工具：可以一键初始化开发环境、一键打包，让我们从繁琐的环境搭建中解脱出来，从而将更多精力集中在代码编写与产品创新上。## 📌 项目简介</p>\n<p><strong>winapp CLI</strong> 是微软推出的一个<strong>命令行工具</strong>，旨在为 Windows 应用开发者提供统一、简洁的开发体验。它整合了 Windows SDK、App SDK、应用打包（MSIX）、证书管理、清单生成、调试身份配置等核心功能，适用于各种开发框架（如 Electron、.NET、C++、Rust、Tauri、Python 等）。</p>\n<p><img alt=\"图片\" src=\"https://img2024.cnblogs.com/blog/93789/202601/93789-20260123111157464-1128359569.webp\" />##</p>\n<h2 id=\"-核心功能\">🎯 核心功能</h2>\n<p>winapp CLI 主要解决以下几类开发痛点：</p>\n<h3 id=\"1-跨平台开发者接入-windows-原生能力\">1. <strong>跨平台开发者接入 Windows 原生能力</strong></h3>\n<p>即使你使用的是 Electron、Tauri 或 Python 等跨平台技术栈，也能轻松调用 <strong>Windows App SDK</strong> 和 <strong>现代 Windows API</strong>（如通知、窗口管理、AI 接口等）。</p>\n<h3 id=\"2-快速添加应用身份app-identity\">2. <strong>快速添加“应用身份”（App Identity****）</strong></h3>\n<p>某些 Windows API（如后台任务、推送通知）要求应用具有“包身份”（Package Identity）。winapp CLI 可通过 <code>create-debug-identity</code> 命令<strong>无需完整打包</strong>即可为开发中的 EXE 添加临时身份，极大简化调试流程。</p>\n<h3 id=\"3-msix-打包与签名\">3. <strong>MSIX 打包与签名</strong></h3>\n<p>一键生成符合 Microsoft Store 要求的 <strong>MSIX 安装包</strong>。内置开发证书生成（<code>cert</code>）和签名工具（<code>sign</code>），支持自动化部署。</p>\n<h3 id=\"4-自动生成清单与资源\">4. <strong>自动生成清单与资源</strong></h3>\n<p>自动生成 <code>AppxManifest.xml</code>、应用图标、资源文件等。</p>\n<p>支持自定义配置，适配不同框架需求。### 5. <strong>集成开发工具链</strong></p>\n<p>提供对 Windows SDK 工具（如 MakeAppx、SignTool）的封装，通过 <code>winapp tool</code> 直接调用。</p>\n<h2 id=\"️-安装方式\">🛠️ 安装方式</h2>\n<ul>\n<li><strong>推荐（Windows 用户）</strong>：使用 WinGet</li>\n</ul>\n<p><code>winget install Microsoft.winappcli --source winget</code></p>\n<ul>\n<li>通过 NPM 安装 Electron 项目的 CLI：</li>\n</ul>\n<p><code>npm install @microsoft/winappcli --save-dev</code>-</p>\n<ul>\n<li><strong>CI/CD 环境</strong>：使用官方 GitHub Action <code>setup-WinAppCli</code></li>\n<li>手动下载：从 GitHub Releases 获取最新版本。</li>\n</ul>\n<h2 id=\"-支持的开发框架\">🧪 支持的开发框架</h2>\n<p>winapp CLI 官方提供了多个示例项目，涵盖：</p>\n<p>框架示例内容<br />\nElectron含 C++/C# 原生插件、AI 集成（Windows ML）<br />\n.NET / WPF控制台应用、桌面应用打包<br />\nC++ (Win32/CMake)原生 Windows<br />\n应用Rust调用 Windows API<br />\nTauri跨平台 Rust 应用打包为 MSIX<br />\nPython / CLI 工具将普通 EXE 打包为 MSIX</p>\n<h2 id=\"️-使用示例\">🛠️ 使用示例</h2>\n<h3 id=\"第一步创建-net-应用\">第一步：创建 .NET 应用</h3>\n<p><code>dotnet new console -n MyDotNetApp``cd MyDotNetApp</code></p>\n<h3 id=\"第二步初始化-winapp-配置\">第二步：初始化 winapp 配置</h3>\n<p>在项目根目录运行：</p>\n<p><code>winapp init</code>该命令会生成 <code>winapp.json</code> 配置文件，用于定义应用名称、版本、入口点（EXE 路径）、图标等元数据。</p>\n<p>示例 <code>winapp.json</code> 片段：</p>\n<p><code>{``  \"appName\": \"MyDotNetApp\",``  \"version\": \"1.0.0\",``  \"exePath\": \"bin/Debug/net8.0/MyDotNetApp.exe\",``  \"publisher\": \"CN=YourName\"``}</code></p>\n<h3 id=\"第三步创建调试身份关键\">第三步：创建调试身份（关键！）</h3>\n<p>许多 Windows API（如发送通知）要求应用具有“包身份”（Package Identity）。传统方式需完整打包 MSIX 才能调试，极其低效。</p>\n<p>而 winapp CLI 提供了革命性的解决方案：</p>\n<p><code>winapp create-debug-identity</code>这条命令会在不打包的情况下，为你的 EXE 注入临时身份，使其在开发阶段就能调用受保护的 Windows API！</p>\n<p>✅ 无需修改代码</p>\n<p>✅ 无需重新编译</p>\n<p>✅ 即时生效</p>\n<h3 id=\"第四步打包为-msix\">第四步：打包为 MSIX</h3>\n<p>准备发布？只需一条命令：</p>\n<p><code>winapp pack .\\bin\\Release\\net10.0-windows10.0.26100.0 --manifest .\\appxmanifest.xml --cert .\\devcert.pfx </code>它会自动：</p>\n<ul>\n<li>\n<p>生成 <code>AppxManifest.xml</code></p>\n</li>\n<li>\n<p>创建 MSIX 包</p>\n</li>\n<li>\n<p>使用开发证书签名（可通过 <code>winapp cert</code> 管理）</p>\n</li>\n</ul>\n<p>最终输出 <code>.msix</code> 文件，可直接安装、分发，甚至提交到 Microsoft Store！</p>\n<h2 id=\"-开源项目\">🔗 开源项目</h2>\n<p>GitHub：<a href=\"https://github.com/microsoft/winappCli\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/microsoft/winappCli</a></p>\n<h2 id=\"-总结\">✅ 总结</h2>\n<p><strong>winapp CLI 是微软为现代化 Windows 应用开发打造的一站式 CLI 工具</strong>，尤其适合：</p>\n<ul>\n<li>\n<p>想在跨平台项目中使用 Windows 原生功能的开发者</p>\n</li>\n<li>\n<p>需要快速调试“包身份”相关 API 的团队</p>\n</li>\n<li>\n<p>希望自动化 MSIX 打包和签名的 DevOps 流程</p>\n</li>\n</ul>\n<h3 id=\"--end--\">- End -</h3>\n<p>文章首发于公众号【编程乐趣】，欢迎大家关注。<br />\n<img alt=\"图片\" src=\"https://img2020.cnblogs.com/blog/93789/202105/93789-20210520132522800-1532644404.jpg\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t</div>\n\t\t<div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-23 11:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/chingho\">chingho</a>&nbsp;\n阅读(<span id=\"post_view_count\">220</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "AI开发-python-langchain框架（1-5 使用 Few-Shot Prompting 实现多跳推理问答：以历史人物寿命比较为例）",
      "link": "https://www.cnblogs.com/yclh/p/19521069",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yclh/p/19521069\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 10:57\">\n    <span>AI开发-python-langchain框架（1-5 使用 Few-Shot Prompting 实现多跳推理问答：以历史人物寿命比较为例）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span style=\"font-size: 18px;\">&nbsp; &nbsp;想让大模型回答问题具有推理步骤如何实现？比如问大模型&nbsp;<span style=\"color: rgba(106, 135, 89, 1);\"><span style=\"color: rgba(255, 0, 0, 1);\">李白和白居易谁活得的更久？</span><span style=\"color: rgba(0, 0, 0, 1);\">这个问题，我们期望他按照如下这种格式回答：</span></span></span></p>\n<pre><span style=\"color: rgba(0, 0, 255, 1); font-size: 16px;\">问：李白去世时的年龄是多少？</span><br /><span style=\"color: rgba(0, 0, 255, 1); font-size: 16px;\">答案：李白去世时61岁。</span><br /><span style=\"color: rgba(0, 0, 255, 1); font-size: 16px;\">问：白居易去世时的年龄是多少？</span><br /><span style=\"color: rgba(0, 0, 255, 1); font-size: 16px;\">答案：白居易去世时74岁。</span><br /><span style=\"color: rgba(0, 0, 255, 1); font-size: 16px;\">所以最终答案是：白居易</span><br /><br /><span style=\"font-size: 18px;\">首先我们直接问大模型看他如何回答<br /></span></pre>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">from langchain_openai import ChatOpenAI\nimport os\nfrom dotenv import load_dotenv\n\n\nllm = ChatOpenAI(\n    api_key=os.getenv(\"DEEPSEEK_API_KEY\"),\n    base_url=os.getenv(\"DEEP_URL\"),  # Deepseek 的 API 基础地址\n    model=\"deepseek-v3:671b\",  # Deepseek 对话模型（可选：deepseek-chat-pro 等高级模型）\n    temperature=0.7,  # 温度参数（0-1，越低越稳定）\n    max_tokens=1024  # 最大生成 tokens\n)\n\nresponse = llm.invoke('李白和白居易谁活得的更久？')\nprint(response.content)\n</pre>\n</div>\n<p>&nbsp;结果如下：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">李白和白居易的寿命对比如下：\n\n1. **李白（701年－762年）**  \n   - 享年约61岁（虚岁62岁）。  \n   - 去世原因：普遍认为是病逝，但也有“醉后捞月溺亡”的民间传说。  \n\n2. **白居易（772年－846年）**  \n   - 享年74岁（虚岁75岁），在唐代诗人中属长寿。  \n   - 晚年生活：辞官隐居洛阳，笃信佛教，生活闲适。  \n\n**结论**：白居易比李白多活约13年，寿命更长。两人虽同属唐代，但白居易出生时李白已去世10年，二者并无交集。\n</pre>\n</div>\n<p>&nbsp;那么如何引导大模型按照我们期望的结果输出呢？代码如下：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:python;gutter:true;\">from langchain.prompts.few_shot import FewShotPromptTemplate\nfrom langchain.prompts.prompt import PromptTemplate\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.output_parsers import StrOutputParser\nimport os\n\n# 定义少样本学习（Few-Shot Learning）中的示例列表\n# 每个示例包含一个复杂问题及其结构化的多步推理答案\n# 目的是教会模型：面对需要多跳推理的问题时，应如何分解问题、逐步追问并整合答案\nexamples = [\n    {\n        \"question\": \"乾隆和曹操谁活得更久?\",\n        \"answer\": \"\"\"\n这里是否需要跟进问题：是的。\n追问：乾隆去世时几岁？\n中间答案：乾隆去世时87岁。\n追问：曹操去世时几岁？\n中间答案：曹操去世时66岁。\n所以最终答案是：乾隆\n\"\"\",\n    },\n    {\n        \"question\": \"小米手机的创始人什么时候出生?\",\n        \"answer\": \"\"\"\n这里是否需要跟进问题：是的。\n追问：小米手机的创始人是谁？\n中间答案：小米手机 由 雷军 创立。\n跟进：雷军什么时候出生？\n中间答案：雷军出生于 1969 年 12 月 16 日。\n所以最终的答案是：1969 年 12 月 16 日\n\"\"\",\n    },\n    {\n        \"question\": \"乔治·华盛顿的外祖父是谁？\",\n        \"answer\": \"\"\"\n这里是否需要跟进问题：是的。\n追问：乔治·华盛顿的母亲是谁？\n中间答案：乔治·华盛顿的母亲是玛丽·鲍尔·华盛顿。\n追问：玛丽·鲍尔·华盛顿的父亲是谁？\n中间答案：玛丽·鲍尔·华盛顿的父亲是约瑟夫·鲍尔。\n所以最终答案是：约瑟夫·鲍尔\n\"\"\",\n    },\n    {\n        \"question\": \"《大白鲨》和《皇家赌场》的导演是同一个国家的吗？\",\n        \"answer\": \"\"\"\n这里是否需要跟进问题：是的。\n追问：《大白鲨》的导演是谁？\n中间答案：《大白鲨》的导演是史蒂文·斯皮尔伯格。\n追问：史蒂文·斯皮尔伯格来自哪里？\n中间答案：美国。\n追问：皇家赌场的导演是谁？\n中间答案：《皇家赌场》的导演是马丁·坎贝尔。\n跟进：马丁·坎贝尔来自哪里？\n中间答案：新西兰。\n所以最终的答案是：不会\n\"\"\",\n    },\n]\n\n# 定义单个示例的格式模板\n# 将每个 example 中的 question 和 answer 按照指定格式拼接\nexample_prompt = PromptTemplate(\n    input_variables=[\"question\", \"answer\"],  # 声明模板中使用的变量名\n    template=\"Question: {question}\\n{answer}\"  # 实际的文本模板\n)\n\nprint('---------')\n\n# 构建完整的少样本提示模板（Few-Shot Prompt Template）\n# 该模板会自动将 examples 按 example_prompt 格式拼接，并在末尾追加用户输入的问题\nprompt = FewShotPromptTemplate(\n    examples=examples,              # 提供的示例列表\n    example_prompt=example_prompt,  # 单个示例的格式\n    suffix=\"Question: {input}\",     # 用户实际输入问题的位置（占位符为 {input}）\n    input_variables=[\"input\"],      # 声明整个提示模板接收的输入变量名\n)\n\n# 打印生成的完整提示词，用于调试或查看模型实际看到的上下文\nprint('--------提示词begin--------')\nprint(prompt.format(input=\"李白和白居易谁活得的更久？\"))\nprint('--------提示词end--------')\n\n\n# 配置大语言模型（LLM）参数，使用 DeepSeek 的 API（兼容 OpenAI 接口）\nllm = ChatOpenAI(\n    api_key=os.getenv(\"DEEPSEEK_API_KEY\"),   # 从环境变量读取 API 密钥（更安全）\n    base_url=os.getenv(\"DEEP_URL\"),          # 从环境变量读取 DeepSeek 的 API 基础地址\n    model=\"deepseek-v3:671b\",                # 指定使用的模型名称\n    temperature=0.7,                         # 控制生成文本的随机性（0~1，值越高越有创造性）\n    max_tokens=1024                          # 限制模型最大输出长度（以 token 为单位）\n)\n\n# 创建输出解析器，将模型返回的 AIMessage 对象解析为纯字符串\noutput_parser = StrOutputParser()\n\n# 使用 LangChain 的管道操作符（|）构建处理链：\n# 输入 → 提示模板 → 大模型 → 输出解析 → 最终字符串结果\nchain = prompt | llm | output_parser\n\n# 调用链式流程，传入用户问题：“李白和白居易谁活得的更久？”\nresponse = chain.invoke({\"input\": \"李白和白居易谁活得的更久？\"})\n\n# 打印模型生成的最终回答\nprint('--------最终回答--------')\nprint(response)\n</pre>\n</div>\n<p>&nbsp;--------最终回答--------<br />这里是否需要跟进问题：是的。<br />追问：李白去世时几岁？<br />中间答案：李白去世时61岁。<br />追问：白居易去世时几岁？<br />中间答案：白居易去世时75岁。<br />所以最终答案是：白居易</p>\n<p>&nbsp;</p>\n<h3 class=\"qwen-markdown-heading\"><span class=\"qwen-markdown-text\">一、核心目标</span></h3>\n<p class=\"qwen-markdown-paragraph\"><span class=\"qwen-markdown-text\">教会大语言模型（LLM）如何<strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">分步思考</span></strong><span class=\"qwen-markdown-text\">，解决需要<strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">多步推理</span></strong><span class=\"qwen-markdown-text\">（Multi-hop Reasoning）的复杂问题</span></span></span></p>\n<h3 class=\"qwen-markdown-heading\"><span class=\"qwen-markdown-text\">二、关键技术点</span></h3>\n<h4 class=\"qwen-markdown-heading\"><span class=\"qwen-markdown-text\">1. <strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">少样本提示（Few-Shot Prompting）</span></strong></span></h4>\n<ul class=\"qwen-markdown-list\" dir=\"auto\">\n<li><strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">概念</span></strong><span class=\"qwen-markdown-text\">：在提示词中提供几个“输入-输出”示例，引导模型模仿回答格式和推理逻辑。</span></li>\n<li><strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">作用</span></strong><span class=\"qwen-markdown-text\">：无需微调模型，仅通过提示工程（Prompt Engineering）提升复杂任务表现。</span></li>\n<li><strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">实现工具</span></strong><span class=\"qwen-markdown-text\">：<code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">langchain.prompts.few_shot.FewShotPromptTemplate</code></span></li>\n\n</ul>\n<div class=\"qwen-markdown-space\">&nbsp;</div>\n<h4 class=\"qwen-markdown-heading\"><span class=\"qwen-markdown-text\">2. <strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">结构化推理模板设计</span></strong></span></h4>\n<ul class=\"qwen-markdown-list\" dir=\"auto\">\n<li><span class=\"qwen-markdown-text\"><span class=\"qwen-markdown-text\">每个示例包含清晰的推理链条：</span></span>\n<ul class=\"qwen-markdown-list\" dir=\"auto\">\n<li><span class=\"qwen-markdown-text\">判断是否需要追问（“这里是否需要跟进问题：是的。”）</span></li>\n<li><span class=\"qwen-markdown-text\">分步提出子问题（“追问：...”）</span></li>\n<li><span class=\"qwen-markdown-text\">给出中间答案（“中间答案：...”）</span></li>\n<li><span class=\"qwen-markdown-text\">最终整合结论（“所以最终答案是：...”）</span></li>\n\n</ul>\n\n</li>\n<li><strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">目的</span></strong><span class=\"qwen-markdown-text\">：让模型学会“先分解问题 → 再逐步求解 → 最后综合答案”的思维模式。</span></li>\n\n</ul>\n<div class=\"qwen-markdown-space\">&nbsp;</div>\n<h4 class=\"qwen-markdown-heading\"><span class=\"qwen-markdown-text\">3. <strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">LangChain 提示模板组合</span></strong></span></h4>\n<ul class=\"qwen-markdown-list\" dir=\"auto\">\n<li><code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">PromptTemplate</code><span class=\"qwen-markdown-text\">：定义单个示例的格式（如 <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">\"Question: {question}\\n{answer}\"</code><span class=\"qwen-markdown-text\">）</span></span></li>\n<li><code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">FewShotPromptTemplate</code><span class=\"qwen-markdown-text\">：自动拼接多个示例 + 用户问题，生成完整提示</span></li>\n<li><span class=\"qwen-markdown-text\">支持动态插入用户输入（通过 <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">{input}</code><span class=\"qwen-markdown-text\"> 占位符）</span></span></li>\n\n</ul>\n<div class=\"qwen-markdown-space\">&nbsp;</div>\n<h4 class=\"qwen-markdown-heading\"><span class=\"qwen-markdown-text\">4. <strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">大模型调用与安全配置</span></strong></span></h4>\n<ul class=\"qwen-markdown-list\" dir=\"auto\">\n<li><span class=\"qwen-markdown-text\">使用 <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">ChatOpenAI</code><span class=\"qwen-markdown-text\"> 调用兼容 OpenAI API 的第三方模型（如 DeepSeek）</span></span></li>\n<li><strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">关键参数</span></strong><span class=\"qwen-markdown-text\"><span class=\"qwen-markdown-text\">：</span></span>\n<ul class=\"qwen-markdown-list\" dir=\"auto\">\n<li><code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">temperature=0.7</code><span class=\"qwen-markdown-text\">：平衡创造性与稳定性</span></li>\n<li><code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">max_tokens=1024</code><span class=\"qwen-markdown-text\">：控制输出长度</span></li>\n\n</ul>\n\n</li>\n<li><strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">安全实践</span></strong><span class=\"qwen-markdown-text\">：通过 <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">os.getenv()</code><span class=\"qwen-markdown-text\"> 从环境变量读取 API 密钥，避免硬编码</span></span></li>\n\n</ul>\n<div class=\"qwen-markdown-space\">&nbsp;</div>\n<h4 class=\"qwen-markdown-heading\"><span class=\"qwen-markdown-text\">5. <strong class=\"qwen-markdown-strong\"><span class=\"qwen-markdown-text\">链式处理（Chain）与输出解析</span></strong></span></h4>\n<ul class=\"qwen-markdown-list\" dir=\"auto\">\n<ul class=\"qwen-markdown-list\" dir=\"auto\">\n<li><span class=\"qwen-markdown-text\">构建数据流管道：<br /><code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">输入 → 提示模板 → 大模型 → 字符串解析 → 最终结果</code></span></li>\n<li><span class=\"qwen-markdown-text\">使用 <code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">|</code><span class=\"qwen-markdown-text\"> 操作符连接组件（LangChain 的函数式风格）</span></span></li>\n<li><code class=\"qwen-markdown-codespan\" style=\"cursor: pointer;\">StrOutputParser()</code><span class=\"qwen-markdown-text\">：将模型返回的结构化消息（如 AIMessage）转为纯文本</span></li>\n\n\n</ul>\n\n</ul>\n<pre><span style=\"font-size: 18px;\">到这大家应该感觉到，大模型就是玩提示词（因为大模型本生我们个人是无法左右他的能力，都依赖于大厂，他们发布什么我们用什么），<br />提示词如何写决定了你AI应用的能力，后面我们会继续玩提示词，敬请期待。<br /><br /></span></pre>\n<p>&nbsp;</p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-23 10:57</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yclh\">万笑佛</a>&nbsp;\n阅读(<span id=\"post_view_count\">37</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "32岁程序员猝死背后，我的一些真实感受",
      "link": "https://www.cnblogs.com/HaiJun-Aion/p/19521040",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/HaiJun-Aion/p/19521040\" id=\"cb_post_title_url\" title=\"发布于 2026-01-23 10:52\">\n    <span>32岁程序员猝死背后，我的一些真实感受</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>上午刷到32岁程序员周末猝死这条消息，其实我并不陌生。</p>\n<p>这几年，程序员猝死、倒下、出事的新闻隔一段时间就会出现一次，圈子里的人早就麻木了。刷到的时候，最多叹口气，继续干活，很少真的往心里去。</p>\n<p>看到他长期加班的细节时，我突然愣住了，因为太像了。</p>\n<p>我也经常这样。</p>\n<p>下午刷到他的妻子和对他的聊天记录，真的感觉很无奈，可惜，他再也回不来了......</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<hr />\n<p>我到不是加班，我是下班后干自己的事情，我比较卷。只有下班后的时间是真正属于自己的时间才刚开始。没有人打扰，安静下来，我会干自己的事情、学习、写代码，一不留神就到了凌晨两点。</p>\n<p>那一刻，我才真正能进入自己的状态。</p>\n<p>学习也好，干活也好，哪怕只是安静地敲键盘，都让我觉得踏实。</p>\n<p>于是，凌晨两点成了常态</p>\n<p>通过他这件事，我看到我也在里面，看见了自己。</p>\n<hr />\n<p>我上一次写代码写到很晚是前几周，老大让我开发一个知识库RAG系统。</p>\n<p>给我了我一周的时间，其实对于我是有难度的，因为接触这块不久，一周时间的话肯定弄不好。</p>\n<p>后来那天，我连夜和AI 一些协作搞了6个小时左右，搞到了凌晨3点多，初版搞的差不多，那会心率也有点高了， 有点难受，就赶快休息了...</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<hr />\n<p><strong>我们这一代程序员，真的太累了。</strong></p>\n<p>这种累，不只是加班，而是<strong>一种长期被推着往前，却不敢停下来的状态</strong>。</p>\n<p>房贷在那儿。<br />\n家庭在那儿。<br />\n<strong>未来的不确定性在那儿</strong>。</p>\n<p>我们很清楚，一旦慢下来，就意味着风险。</p>\n<p>于是我们学会了忍。<br />\n忍困、忍累、忍身体发出的各种提醒。</p>\n<hr />\n<p>程序员这个职业有个很危险的地方。</p>\n<p>身体开始出问题的时候，<strong>能力往往还在线</strong>。</p>\n<p>我们还能写代码，还能解决问题，还能在群里回一句：“好的，我看看”</p>\n<p>所以你会误以为自己没事。</p>\n<p>可身体不是系统，没有明显的报错提示。<br />\n等它真正崩的时候，往往没有给你回滚的机会。</p>\n<p>今天刷到这个新闻消息对我来说，更像是一次提醒。我现在体检去，估计都是全红状态，我经常熬夜，现在锻炼的也少了....</p>\n<p>我们这一代人，很努力。</p>\n<p>努力工作，努力赚钱，努力让生活往前走。</p>\n<p>可如果连身体都开始透支，那这条路，真的值得重新想一想。</p>\n<p>不是他倒下了。<br />\n是我们这一代，真的太累了。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-23 10:52</span>&nbsp;\n<a href=\"https://www.cnblogs.com/HaiJun-Aion\">程序员海军</a>&nbsp;\n阅读(<span id=\"post_view_count\">1192</span>)&nbsp;\n评论(<span id=\"post_comment_count\">21</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}