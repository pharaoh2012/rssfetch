{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "20250702 - FPC Token 攻击事件：严格的限制，灵活的黑客",
      "link": "https://www.cnblogs.com/ACaiGarden/p/19458550",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ACaiGarden/p/19458550\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 19:56\">\n    <span>20250702 - FPC Token 攻击事件：严格的限制，灵活的黑客</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"背景\">背景</h1>\n<p>FPC 是 BPE-20 项目，实现了复杂的交易机制，包括<strong>买卖手续费、流动性池燃烧机制、限制交易频率、限制交易数量</strong>等功能。漏洞产生的原因是当用户卖出代币时，<strong>合约会从流动性池中燃烧代币（而非从卖出者余额中燃烧）</strong>，导致池子中 FPC 代币数量减少，价格抬高。</p>\n<blockquote>\n<p>项目方应该是为了加上流动性池燃烧机制，发现直接加上这不行呀，这个会被利用去套利的。然后打了限制交易频率和限制交易数量两个补丁。希望以此来限制代币持有者通过机制进行获利。</p>\n</blockquote>\n<p>攻击交易</p>\n<ul>\n<li><strong>攻击交易哈希</strong>: <code>0x3a9dd216fb6314c013fa8c4f85bfbbe0ed0a73209f54c57c1aab02ba989f5937</code></li>\n<li><strong>攻击者地址</strong>: <code>0xbf6e706d505e81ad1f73bbc0babfe2b414ba3eb3</code></li>\n</ul>\n<p>漏洞合约</p>\n<ul>\n<li><strong>FPC代币合约</strong>: <code>0xb192d4a737430aa61cea4ce9bfb6432f7d42592f</code></li>\n<li><strong>主要流动性池</strong>: <code>0xa1e08e10eb09857a8c6f2ef6cca297c1a081ed6b</code></li>\n</ul>\n<h1 id=\"trace-分析\">Trace 分析</h1>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195418546-1108887978.png\" /></p>\n<ol>\n<li>\n<p>攻击者通过闪电贷获得大量的 USDT</p>\n</li>\n<li>\n<p>在 [FPC, USDT] 池子中购买大量的 FPC</p>\n</li>\n<li>\n<p>把 FPC 转移到新的地址中</p>\n</li>\n<li>\n<p>出售所有的 FPC：先触发<strong>流动性池燃烧机制</strong>，推高了 FPC 的价格，然后再计算出售获得的 USDT，从而获得超额的利润。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195438039-1592352059.png\" /></p>\n</li>\n</ol>\n<h1 id=\"代码分析\">代码分析</h1>\n<p>在背景介绍了 FPC 代币实现了<strong>流动性池燃烧机制、限制交易频率、限制交易数量</strong>等功能，接下来将会通过代码实现以及攻击者的手法向读者展示。</p>\n<h2 id=\"在-fpc-usdt-池子中购买大量的-fpc\">在 [FPC, USDT] 池子中购买大量的 FPC</h2>\n<p>在黑客购买 FPC 的操作中，黑客没有通过 router 进行兑换，而是直接调用 pool 进行兑换。</p>\n<pre><code class=\"language-markdown\">CALLCake-LP.swap(**amount0Out=1,000,000,000,000,000,000**, amount1Out=790,178,970,489,172,772,916,652)\n</code></pre>\n<p>并且在购买大量 FPC 代币的同时，还换出了 1 USDT。很反常的操作，如果只是为了购买 FPC，这个amount0Out 的值应为为 0。</p>\n<blockquote>\n<p>黑客这样做的目的是为了绕开最大购买数量的限制</p>\n</blockquote>\n<p>在直接通过 pool 大量购买 FPC 时同时换出 1 个 USDT，目的就为了欺骗 _isLiquidity 函数的检查，伪装成移除流动性的操作，使得 isDel 的值为 true。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195457477-1676036854.png\" /></p>\n<p>如果  isDel 的值为 true，就会绕过 <code>value &lt;= _maxBuyAmount()</code> 的限额检查了。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195511387-780783212.png\" /></p>\n<h2 id=\"把-fpc-转移到新的地址中\">把 FPC 转移到新的地址中</h2>\n<p>在 FPC 代币中，如果用户进行 swap 操作，会被记录下操作的区块号，并且限制 3 个区块内不允许再次交易。但是它没有对转账操作进行限制，所以攻击者可以通过把 FPC 转移到没有进行过 swap 的地址进行出售，从而绕过这个限制。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195529422-1735776335.png\" /></p>\n<h2 id=\"出售所有的-fpc触发流动性池燃烧机制\">出售所有的 FPC：触发<strong>流动性池燃烧机制</strong></h2>\n<p>这一步是关键的步骤，卖出 FPC 代币，触发合约的燃烧机制</p>\n<pre><code class=\"language-markdown\">CALLPancakeSwap: Router v2.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n  amountIn=247,441,170,766,403,071,054,109)\n</code></pre>\n<p>在 sell 的逻辑分支中，会调用 burnLpToken 函数按照出售的数量 value 来销毁 FPC 代币。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195542694-2016383265.png\" /></p>\n<p>而在 burnLpToken 函数函数中，燃烧的是 pool 中的代币（不是燃烧 seller 提供的代币，而是直接燃烧 pool 中的代币）。这样会使得 pool 中 FPC 的价格被推高。使得黑客在卖出 FPC 代币时能够获取到更多的利润。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1483609/202601/1483609-20260108195628531-1501728881.png\" /></p>\n<h1 id=\"后记\">后记</h1>\n<p>这个代币在添加流动性池燃烧机制的初衷应该是希望在用户出售代币的时候，啊把池子里面的代币取出来一点，一个是收归项目方所有，第二个是抬高一点币价不要跌的这么快。</p>\n<p>但是，但是在 Pancake 和 Uniswap 的 V2/V3 版本中，都是遵循着“先转账，后结算”的模式去进行 swap 的。而代币设置的各种机制只能在转账的过程中触发，这就使得了这个燃烧机制始终都是发生在结算前的，这就给了黑客套利的空间。如果想要实现这种特殊机制，可以考虑一下通过 Uniswap V4 的 Hook 去实现，但是会对开发的技术与质量要求更高（不得不说后续更新的版本都不如 V2 的 x * y = k 来得简单直接，叽里咕噜又集中流动性又 Hook 说啥呢，我 V2 一把加完流动性就能用。也是为什么直至现在很多代币的发行方都钟爱在 V2 上部署池子）。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 19:56</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ACaiGarden\">ACai_sec</a>&nbsp;\n阅读(<span id=\"post_view_count\">5</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "云原生AI算力平台的架构解读",
      "link": "https://www.cnblogs.com/JulianHuang/p/19458390",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/JulianHuang/p/19458390\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 18:41\">\n    <span>云原生AI算力平台的架构解读</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<blockquote>\n<p>给近半年做的云原生AI算力平台做一个回顾， 思考和实践参考了云溪大会上的分享：<a href=\"https://developer.aliyun.com/article/1414573\" rel=\"noopener nofollow\" target=\"_blank\" title=\"为大模型工程提效，基于阿里云 ACK 的云原生 AI 工程化实践\">为大模型工程提效，基于阿里云 ACK 的云原生 AI 工程化实践</a>，全文很长，我这边做一个牵引和解读。</p>\n</blockquote>\n<h2 id=\"1-云计算迎来智算时代\">1. 云计算迎来“智算”时代</h2>\n<p>云计算是一种<strong>通过互联网的方式按需提供计算资源（如服务器、存储、数据库、网络、软件等）</strong>的服务模式， 用户可以像使用水电气一样,按需购买、灵活付费，无需购买和维护物理设备。</p>\n<p>特征是① 按需自助服务 ② 广泛的网络访问 ③ 资源池化  ④ 快速弹性伸缩  ⑤ 使用量计费</p>\n<blockquote>\n<p>为什么叫“云计算”？<br />\n在冯诺依曼体系中，计算资源是CPU，但我们还是以“计算机”来指代包含计算、存储、网络、软件形成的完整服务器；<br />\n在云计算领域，“计算”一次被沿用，将传统计算机核心组件拆开虚拟化、池化，并提供了“用于信息处理所有软硬件要素的总和抽象”。</p>\n</blockquote>\n<p>今天的云计算已经承载了web应用、数据库、大数据、机器学习和高性能计算等计算负载。</p>\n<p>面对LLM和GAI这类对算力和数据都有极高需求的新负载，云计算也迎来了“智算”时代，<br />\n一方面以服务化资源池的概念提供万卡算力、PB级存储、和单机TB级高速网络互联，另一方面以云原生标准化交付算力给大模型的生产者和使用者。</p>\n<h2 id=\"2-大模型带来的挑战\">2. 大模型带来的挑战</h2>\n<p>AI有工程化的要求，同时也对基础设施提出挑战。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108183944896-1604958658.png\" /><br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108183950488-1199602426.png\" /></p>\n<h2 id=\"3-云原生ai的能力\">3. 云原生AI的能力</h2>\n<p>最近在做的“AI大模型基础设施”， 宏观目标也是帮助AI工程从小作坊向端到端云原生解决方案演进。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108183959371-1234056611.png\" /></p>\n<h3 id=\"统一管理异构资源提供资源利用率\">统一管理异构资源，提供资源利用率</h3>\n<p>对idc内各种异构计算（GPU、CPU、NPU等）、存储（OSS、NAS、CPFS、HDFS）、网络（TCP、RDMA）资源进行抽象，统一管理和运维和分配，通过软硬协同优化，提供资源利用率。</p>\n<h3 id=\"通过统一工作流--统一调度-实现ai大数据等复杂任务的高效管理\">通过①统一工作流 ② 统一调度， 实现AI/大数据等复杂任务的高效管理</h3>\n<ul>\n<li>\n<p>从异构资源管理的角度，可一键部署、操作各种异构资源，在运维过程中，需要多维度的异构资源可观测性： 监控、健康检查、告警、自愈等自动化运维能力</p>\n</li>\n<li>\n<p>对于宝贵的GPU/NPU算力资源，使用各种调度、隔离、共享的方式提供资源利用率</p>\n</li>\n<li>\n<p>分钟级准备好开发和测试环境，帮助算法工程师把 ①执行深度学习任务②产出/评测模型③模型部署 以端到端的工作流串起来， 天然支持主流框架 tensorflow/pytorchjob/mpi<br />\n--  对于分布式任务，提供丰富的任务调度策略，如Gang scheduling、Capacity scheduling、Topology aware scheduling、优先级队列等。</p>\n</li>\n<li>\n<p>提供弹性训练和弹性推理服务， 建立统一的数据集管理，模型生命周期管理， 优化模型访问性能，通过标准API使推理能力易于被业务应用集成。</p>\n</li>\n</ul>\n<h2 id=\"4-云原生ai的架构实践\">4. 云原生AI的架构实践</h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184015761-1427603173.png\" /></p>\n<p>我们的云原生AI算力平台， 有参考上面的实践，针对企业业务的现状和侧重， 技术调研上做了调整和裁剪。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184025350-220307939.png\" /></p>\n<p>没有从0到1的使用kubeflow全家桶，使用了arena、 kubeflow  trainer。</p>\n<blockquote>\n<p><a href=\"https://www.kubeflow.org/docs/started/architecture/\" rel=\"noopener nofollow\" target=\"_blank\" title=\"kubeflow\">kubeflow</a>是一个包含多个开源项目的AI生态组合， kubeflow以Kubernetes为底座，目标是成为部署、扩展和管理AI平台的系统。</p>\n</blockquote>\n<p>在平台侧，我们统一纳管了集群资源，实现了统一调度能力和模型生命周期管理，关联了公司自有的数据存储（涉及数据集预热、模型存储），<br />\n这里有一个技术点：Go动态感知资源变更的技术实践，你指定用过！</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184044867-660442933.png\" /></p>\n<p>用户行为的触发点是arena， 我们使用arena提交了训练任务。 ref:  Golang 文本模板，你指定没用过!</p>\n<p>在调度侧，使用tranning operator和kerve组件，tranning operator 提供统一的训练工作流， kserve提供了将模型以云原生方式部署、扩缩容的能力。</p>\n<p>arena产生训练任务/部署动作---&gt; 内部helm形成对应的CRD（pytorchjob、InferenceService)---&gt;控制器监听CRD的变更---&gt; 生成底层资源（deploy/service/network)</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184107591-1084626310.png\" /></p>\n<p>各算法团队天然对应租户概念，也就是k8s命名空间， 我们给租户下面每一个用户颁发了一个<a href=\"https://blog.miniasp.com/post/2022/08/24/Understanding-Service-Account-in-Kubernetes-through-MicroK8s\" rel=\"noopener nofollow\" target=\"_blank\" title=\"serviceAccount\">serviceAccount</a>作为登录和操作凭据。</p>\n<p>为实现自动任务调度，我们引入了kueue这样的任务队列组件，在任务被k8s调度器调度之前做准入，kueue成为了异构资源池化多租户配额、任务排队的技术支撑。</p>\n<p>有关kueue的使用，请参考：🎉在k8s调度的花园里面挖呀挖 。<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184122928-1792259600.png\" /></p>\n<p>为适配AI工程化的调度要求，我们使用Koordinator调度器支持了binpack装箱调度。</p>\n<p>什么叫binpack， 为什么AI训练需要binpack， 请参考:🎉卷不过AI算法， AI工程化或许是一个出路？<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184133179-1065900826.png\" /></p>\n<p>最后平台需要管控多渠道的任务，我们使用 informer机制监听了多渠道任务并回显到页面， 这里有个技术点，值得参考。</p>\n<p>🚀糟糕，我实现的k8s informer好像是依托答辩<br />\n<img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/587720/202601/587720-20260108184141433-1556621842.png\" /></p>\n<p><img alt=\"\" src=\"https://files.mdnice.com/user/4236/528d857f-9d29-4937-8275-20accf704f4e.png\" /></p>\n\n</div>\n<div id=\"MySignature\">\n    <hr color=\"#987cb9\" size=\"3\" width=\"80%\" />\n<div style=\"text-align: center;\">\n<p>本文来自博客园，作者：{有态度的马甲}，转载请注明原文链接：<a href=\"https://www.cnblogs.com/JulianHuang/p/19458390\" target=\"_blank\">https://www.cnblogs.com/JulianHuang/p/19458390</a></p>\n<strong style=\"color: red;\">欢迎关注我的原创技术、职场公众号， 加好友谈天说地，一起进化</strong>\n<div><img src=\"https://blog-static.cnblogs.com/files/JulianHuang/QR.gif\" style=\"width: 250px; height: 250px;\" /> </div>\n\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 18:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/JulianHuang\">码甲哥不卷</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "JVM 堆内存分代",
      "link": "https://www.cnblogs.com/yanshajiuzhou/p/19458321",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yanshajiuzhou/p/19458321\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 18:25\">\n    <span>JVM 堆内存分代</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        不同存活周期的对象放在不同区域，用不同算法回收，保证 GC 效率，这就是&nbsp;\"分代回收\" 的核心思想。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span>​</span>今天我们一起来聊一聊 <strong>JVM 堆内存</strong>。</p>\n<p><img alt=\"Java Heap1\" src=\"https://img2024.cnblogs.com/blog/1171560/202601/1171560-20260108182258403-1042762825.png\" /></p>\n<p><strong>Java Heap</strong>（堆内存）由 <strong>Young Generation</strong>（新生代，约占 <strong>1/3&nbsp;</strong>）和&nbsp;<strong>Old Generation</strong>（老年代，约占 <strong>2/3</strong> ）组成。</p>\n<p><strong>Young Generation </strong>又由&nbsp;<strong>Eden Space</strong>（伊甸园区，占新生代 <strong>80%&nbsp;</strong>）、<strong>Survivor Space 0</strong>（幸存者区0，占新生代 <strong>10%&nbsp;</strong>）和 <strong>Survivor Space 1</strong>（幸存者区1，占新生代 <strong>10%&nbsp;</strong>）组成。</p>\n<p><strong>对象的生命周期</strong>：</p>\n<p><img alt=\"对象生命周期\" src=\"https://img2024.cnblogs.com/blog/1171560/202601/1171560-20260108182353974-1428015339.png\" /></p>\n<p><strong>Young Generation</strong>（新生代）：</p>\n<ul>\n<li>存储 <strong>新创建</strong>、<strong>存活周期极短</strong> 的对象，比如方法内的局部变量、临时对象。默认占堆总容量 <strong>1/3 </strong>。</li>\n<li>触发 <strong>Minor GC</strong>（新生代 GC），频率极高（毫秒 / 秒级），但耗时极短（几十毫秒）。</li>\n<li>Eden 区是 Minor GC 的 \"触发源头\"，调大 Eden 区可减少 Minor GC 次数。</li>\n</ul>\n<p><strong>Eden Space</strong>（伊甸园区）：新对象的 \"默认出生地\"，<strong>99% 的新对象&nbsp;</strong>都会优先分配到 Eden 区（除非是超大对象直接进入老年代）。占新生代 <strong>80%&nbsp;</strong>。</p>\n<p><strong>Survivor Space 0/1</strong>（幸存者区 0/1，简称 S0/S1，也叫 From 区 / To 区）：</p>\n<ul>\n<li>新生代 GC 后存活对象的 <strong>\"临时中转站\"</strong>，避免存活对象直接进入老年代。<strong>两个区会动态互换角色</strong>。各占新生代 <strong>10%</strong>，合计 20%。</li>\n<li>S0 和 S1&nbsp;<strong>永远有一个是空的</strong>（这是 JVM 的设计巧思）。</li>\n<li>每经历一次 Minor GC，存活对象的 <strong>\"年龄 + 1\"</strong>。</li>\n</ul>\n<p><strong>S0/S1 的交互</strong> 示例：</p>\n<ul>\n<li>① 初始状态：Eden 有对象，S0 有对象，S1 为空；</li>\n<li>② Eden 触发 Minor GC → 回收 Eden+S0 的垃圾对象，存活对象复制到 S1，清空 Eden+S0；</li>\n<li>③ 此时 S1 非空、S0 为空，两者角色互换（S0=To 区，S1=From 区）；</li>\n<li>④ 下次 Minor GC 重复上述过程，存活对象在 S0/S1 之间 <strong>\"来回复制\"</strong>。</li>\n</ul>\n<p><strong>Old Generation</strong>（老年代）：</p>\n<ul>\n<li>存储&nbsp;<strong>长期存活、体积较大&nbsp;</strong>的对象，比如单例对象、缓存对象、经历多次 Minor GC 仍存活的对象。默认占堆总容量 <strong>2/3</strong>。</li>\n<li>触发&nbsp;<strong>Major GC / Full GC</strong>，频率极低，但耗时极长。</li>\n<li>老年代大小决定 Full GC 频率 —— 老年代越大，Full GC 频率越低，但单次 Full GC 耗时越长。</li>\n</ul>\n<p><strong>对象进入老年代的条件</strong>：</p>\n<ul>\n<li><strong>年龄达标</strong>：对象在 S0/S1 之间复制次数达到阈值（默认 15 次，<code>-XX:MaxTenuringThreshold</code>调整）；</li>\n<li><strong>大对象</strong>：超过阈值的对象（<code>-XX:PretenureSizeThreshold</code>）直接进入老年代；</li>\n<li><strong>空间担保失败</strong>：Minor GC 后 Survivor 区放不下存活对象，多余对象直接晋升老年代；</li>\n<li><strong>动态年龄判断</strong>：Survivor 区中相同年龄对象总和超过 50%，该年龄及以上对象直接进入老年代。</li>\n</ul>\n<p>不同存活周期的对象放在不同区域，用不同算法回收，保证 <strong>GC</strong> 效率，这就是&nbsp;<strong>\"分代回收\" </strong>的核心思想。</p>\n<p style=\"text-align: right;\"><span style=\"color: rgba(53, 152, 219, 1);\">努力的意义，不在于追逐别人的高度，而是拼尽全力，为自己创造一个绝地反击的故事。-- 烟沙九洲</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 18:25</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yanshajiuzhou\">烟沙九洲</a>&nbsp;\n阅读(<span id=\"post_view_count\">3</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "你们如何运行Agent生成的代码？或许你也需要一个Agent-Sandbox，Agent-Sandbox开源首发",
      "link": "https://www.cnblogs.com/xguo/p/19457007",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xguo/p/19457007\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 15:41\">\n    <span>你们如何运行Agent生成的代码？或许你也需要一个Agent-Sandbox，Agent-Sandbox开源首发</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"你们如何运行Agent生成的代码？或许你也需要一个Agent-Sandbox，Agent-Sandbox开源首发\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108145436183-1755523701.png\" />\n        Manus的高价出售，让Sandbox再次进入人们的视野，它之前用的Sandbox是E2B，这是一个非常强大的Sandbox工具，它可以帮助Agent执行代码或命令，但它不方便我们使用，之前我们的办法是部署一个Python的执行代码的服务，或着部署一个Playwright的服务，各自提供MCP或普通API，来满足需求，但是遇到的问题也是显而易见的，那就是无法实现多次访问的隔离，例如一个Agent访问了A网站，另一个Agent访问了B网站，就会相互干扰，性能也是问题，除非你部署很多实例，那也浪费。那我们的选择是什么？\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<div style=\"text-align: center;\">\n\n<img height=\"381px\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144423805-386973583.png\" width=\"255px\" />\n\n</div>\n<h2 id=\"开源地址\">开源地址：</h2>\n<p><strong>Agent-Sandbox</strong> <a href=\"https://github.com/agent-sandbox/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/agent-sandbox/agent-sandbox</a></p>\n<h2 id=\"效果预演\">效果预演：</h2>\n<p><img alt=\"gitdemo\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144402352-314698307.gif\" /></p>\n<h2 id=\"1为什么需要agent-sandbox\">1，为什么需要Agent-Sandbox？</h2>\n<p>在我们的业务中，经常需要让Agent执行一些代码或者访问网站等，例如用户提供了一个excel文件，处理里面的一些数据，最终生成报告，或者用户提供了一个网站，让Agent访问网站，然后获取一些数据，最终生成报告。</p>\n<p>这些都是很常见的场景，例如最近非常受关注的Manus，卖了很多钱的那个（羡慕啊～）,它就是利用了各种工具来完成用户的复杂任务，你们知道的。</p>\n<p>但问题来了，我们如何让Agent执行这些代码或者访问网站呢？</p>\n<p>因此Manus把E2B带火了，E2B是一个非常强大的Sandbox工具，它可以帮助Agent执行代码或命令，但是E2B基本上是个商业的，不方便我们使用，之前我们的办法是部署一个Python的执行代码的服务，或着部署一个Playwright的服务，各自提供MCP或普通API，来满足需求，但是遇到的问题也是显而易见的，那就是无法实现多次访问的隔离，例如一个Agent访问了A网站，另一个Agent访问了B网站，就会相互干扰，性能也是问题，除非你部署很多实例，那也浪费。</p>\n<p>这个问题你们是怎么解决的？</p>\n<h2 id=\"2agent-sandbox\">2，Agent-Sandbox</h2>\n<p><img alt=\"sbarch\" height=\"649\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108203145347-977491529.jpg\" width=\"1071\" /></p>\n<p>没有选择，只能自己搞了，上半年我们拉了几个兄弟，按照以上的痛点，开发了一个Agent-Sandbox，是的，名字就叫<strong>Agent-Sandbox</strong>，是不是很技术流，</p>\n<p>目前已经在生产环境使用了，效果还不错，支持MCP和REST API，Agent可以在任何需要的时候创建一个Sandbox，然后执行代码，访问网站等，完事儿后自己删除Sandbox，非常方便。</p>\n<p>不过最近也发现市面上出现很多关于Agent Sandbox的工具和讨论，开源的包括<a href=\"https://github.com/kubernetes-sigs/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">kubernetes-sigs/agent-sandbox</a> 、 <a href=\"https://github.com/agent-infra/sandbox\" rel=\"noopener nofollow\" target=\"_blank\">AIO Sandbox</a> 等，说明大家也在解决这个问题，AIO Sandbox这个是火山的，只提供一个集成化的Sandbox环境，也就是一个Docker的Image，里面有各种工具，包括执行代码、浏览器、文件系统等，而kubernetes-sigs/agent-sandbox是个部署工具，可以部署各种Sandbox环境，例如他就支持部署AIO Sandbox，可以通过它拉起很多AIO Sandbox的实例，但功能还是太基础了，无法直接给Agent使用，安装也麻烦，要求的Kubernetes版本比较高，目前大家生产用的K8S的版本都比较滞后。</p>\n<p>像我们这样开源的Sandbox还是没有看到，我们就决定把我们这个开源给大家，也许大家跟我们希望的一样，那就可以用得上了。</p>\n<h2 id=\"3agent-sandbox有哪些特点\">3，Agent-Sandbox有哪些特点？</h2>\n<p>目前实现了主要的功能，包括通过MCP或REST API来CRUD Sandbox，指定Sandbox的Image等，后续会支持更多场景的Sandbox运行环境，支持各种SDK，来满足编程场景的Sandbox控制，更多Sandbox的管理功能，包括TTL回收、无调用回收等，以及管理UI，可以看到在创建的全部Sandbox和相关操作，也可以通过这个UI来创建Sandbox等，方便与治理。</p>\n<p><img alt=\"full-lifecycle-demo\" height=\"601\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144446225-906065250.png\" width=\"1129\" /></p>\n<h3 id=\"特性\">特性：</h3>\n<ol>\n<li>Ai使用友好，可以直接让Agent控制Sandbox的全生命周期，而不一定得提前创建好，在给Agent去使用，Agent按需创建和回收；</li>\n<li>生态开放，部署的Sandbox运行环境可以与社区的兼容，列如可以直接拉起前面提到的AIO Sandbox、Code Server或Playwright等，方便大家利用现有的资源，当然，可以自定义运行环境；</li>\n<li>企业生产可用，当然，考虑前面提到的痛点，基于K8S开发，支持规模化使用，根据需要，可以大量创建Sandbox，相互之间隔离使用；</li>\n<li>轻量化，就一个组件，没有采用K8S的CRD来开发，这个后续用户按照和升级都比较麻烦，用户得接受一种新的资源类型，我们采用RS+Label的方式，尽量依赖K8S现有的特性来快速实现。</li>\n</ol>\n<h2 id=\"4如何使用agent-sandbox\">4，如何使用Agent-Sandbox？</h2>\n<p>所以怎么使用呢，过程非常简单，主要分两步：</p>\n<h3 id=\"1部署agent-sandbox\">1，部署Agent-Sandbox</h3>\n<p>要求 <strong>Kubernetes version 1.26</strong> 或以上， 在 <code>https://github.com/agent-sandbox/agent-sandbox</code> 下载 <code>install.yaml</code> 后，</p>\n<pre><code class=\"language-bash\">kubectl create namespace agent-sandbox\nkubectl apply -nagent-sandbox -f install.yaml\n</code></pre>\n<p>里面会安装deployment、service等，之后你应该是需要配置一个ingress，如：</p>\n<pre><code class=\"language-yaml\">apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: agent-sandbox\n  namespace: agent-sandbox\nspec:\n  ingressClassName: ingress-nginx\n  rules:\n    - host: agent-sandbox.your-host.com\n      http:\n        paths:\n          - backend:\n              service:\n                name: agent-sandbox\n                port:\n                  number: 80\n            path: /(.*)\n</code></pre>\n<p>主要是 <code>host</code> 需要你给出，其他可以直接使用。</p>\n<h3 id=\"2使用agent-sandbox\">2，使用Agent-Sandbox</h3>\n<h4 id=\"21通过agent-sandbox-mcp-server\">2.1，通过Agent-Sandbox MCP Server</h4>\n<p>Agent-Sandbox MCP Server 地址： <code>http://agent-sandbox.your-host.com/mcp</code> ，提供了Sandbox的CURD等Tools。</p>\n<p><strong>效果测试：</strong></p>\n<p>一个简单的Demo，Agent 写个斐波那契额函数，然后通过MCP Server创建一个Sandbox，来计算，最后删除Sandbox。<br />\n<em>是个Gif动画，如果不播放，可以新窗口打开。</em></p>\n<p><img alt=\"gitdemo\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144402352-314698307.gif\" /></p>\n<h4 id=\"22通过agent-sandbox-restful-api\">2.2，通过Agent-Sandbox RESTful API</h4>\n<p>Agent-Sandbox提供RESTful API来管理Sandbox，典型的工作流程包括创建Sandbox、访问Sandbox、删除Sandbox。</p>\n<p><strong>a，创建一个Sandbox</strong></p>\n<pre><code class=\"language-shell\">curl --location '/api/v1/sandbox' \\\n--header 'Content-Type: application/json' \\\n--data '{\"name\":\"sandbox-01\"}'\n</code></pre>\n<p>默认会拉起AIO Sandbox，可以通过以下方式，指定国内镜像，</p>\n<pre><code class=\"language-shell\">curl --location '/api/v1/sandbox' \\\n--header 'Content-Type: application/json' \\\n--data '{\"name\":\"sandbox-01\",\"image\":\"enterprise-public-cn-beijing.cr.volces.com/vefaas-public/all-in-one-sandbox:latest\"}'\n</code></pre>\n<p><strong>b，访问Sandbox</strong><br />\n<code>/sandbox/{sandbox_name}</code> 通过这个地址可以访问Sandbox,</p>\n<p>例如刚才创建的 <strong>sandbox-01</strong> 访问地址是： <code>/sandbox/sandbox-01</code>.</p>\n<p>访问后你应该会看到：</p>\n<p><img alt=\"aio-demo\" height=\"956\" src=\"https://img2024.cnblogs.com/blog/57355/202601/57355-20260108144513435-1606524670.jpg\" width=\"1464\" /></p>\n<p>访问这个Sandbox的MCP地址是： <code>http://agent-sandbox.your-host.com/sandbox/sandbox-01/mcp</code> ，这种场景是先创建好Sandbox，然后让Agent去访问这个Sandbox。</p>\n<p><strong>c，删除Sandbox</strong></p>\n<p>删除API： <code>/api/v1/sandbox/{sandbox_name}</code> . 例如删除Sandbox <code>sandbox-01</code> :<br />\n<strong>Shell</strong></p>\n<pre><code class=\"language-shell\">curl --location --request DELETE '/api/v1/sandbox/sandbox-01'\n</code></pre>\n<p><strong>结果:</strong></p>\n<pre><code class=\"language-json\">{\n  \"code\": \"0\",\n  \"data\": \"Sandbox sandbox-01 deleted successfully\"\n}\n</code></pre>\n<h2 id=\"结尾\">结尾</h2>\n<p>以上就是Agent-Sandbox的简单介绍和使用方法，更多内容请关注<a href=\"https://github.com/agent-sandbox/agent-sandbox\" rel=\"noopener nofollow\" target=\"_blank\">Agent-Sandbox</a>项目，后续我们会持续更新更多功能和特性，包括提到的支持更多场景的Sandbox运行环境，支持各种SDK来满足编程场景的Sandbox控制，更多Sandbox的管理功能，包括TTL回收、无调用回收，并发弹性伸缩等，以及管理UI，可以看到和管理创建的全部Sandbox，也可以通过这个UI来创建和操作Sandbox，例如上传下载文件、查看日志、执行命令、查看状态等。</p>\n<p>最后欢迎大家Star、Issue和PR~</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 15:41</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xguo\">i'm老土豆</a>&nbsp;\n阅读(<span id=\"post_view_count\">101</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "为什么很多伟大的作品都是诞生在一些不起眼的地方",
      "link": "https://www.cnblogs.com/lixingqiu/p/19457141",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lixingqiu/p/19457141\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 15:23\">\n    <span>为什么很多伟大的作品都是诞生在一些不起眼的地方</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>在历史的长河中，我们不难发现，许多震撼人心、改变世界的伟大作品，往往并非出自繁华喧嚣的大都市，而是诞生于一些看似平凡甚至有些偏僻的角落。</p>\n<p>比如，梵高的许多传世画作，是在法国南部那个宁静的小村庄阿尔勒创作出来的。那里没有巴黎的灯红酒绿与艺术圈的纷繁复杂，有的只是质朴的田园风光和淳朴的村民。正是在这样相对安静的环境中，梵高得以全身心地投入到绘画创作中，用他那独特的笔触和色彩，描绘出一幅幅充满生命力的作品，给后世留下了无尽的艺术瑰宝。</p>\n<p>再比如，美国作家马克·吐温，他的许多经典文学作品，灵感来源于他童年生活的密西西比河畔小镇。那个远离城市喧嚣的地方，有着独特的风土人情和社会风貌，为他的写作提供了丰富的素材。他在那片土地上，观察着形形色色的人物，体验着生活的酸甜苦辣，从而创作出了《汤姆·索亚历险记》《哈克贝利·费恩历险记》等不朽之作。</p>\n<p>还有，著名的数学家陈景润，在一个并不起眼小县城里，默默钻研哥德巴赫猜想。在那个条件相对艰苦的环境中，他凭借着对数学的热爱和执着，克服了重重困难，最终取得了举世瞩目的成就，为数学领域的发展做出了巨大贡献。</p>\n<p>而如今，我们要说的<strong>C++精灵库</strong>，它的诞生地同样是一个毫不起眼的地方——江西省萍乡市。这里曾经是江南煤都，然而随着煤炭资源的枯竭，这座城市逐渐失去了往日的辉煌。人口不断流出，街头巷尾充斥着麻将声和抖音里各种喧闹的声音。想象一下，在这样的五线小城市里，年轻人大多选择逃离，前往长沙、南昌、杭州等大城市，甚至是一线城市去追寻自己的梦想，留下的大多是一些安于现状或者因各种原因无法离开的人。</p>\n<p>但是，就是在这样的环境中，却诞生了如此优秀的<strong>C++精灵库</strong>。它的背后，有一位了不起的人物——李兴球老师。李老师可是上世纪的学霸，年轻时曾在充满机遇与挑战的一线城市深圳闯荡了7年。自2010年发现Scratch图形化计算机语言以来，他便扎根在萍乡，从事青少儿编程教育长达10多年。</p>\n<p>时间来到2019年末，这是一个具有特殊意义的节点。李老师开始着手Python精灵模块的开发。为什么要开发这个模块呢？这源于李老师那颗始终充满好奇的心。在教学过程中，他敏锐地发现了Python turtle功能上的不足。比如说，想要让角色的造型图片进行缩放，或者是进行像素级别的碰撞检测，这些功能在Python turtle中都没有。于是，李老师便深入研究python turtle库的源文件turtle.py，经过不懈的努力，最终成功编写出了Python精灵模块。这一段经历，其实为后来C++精灵库的诞生埋下了深厚的根基，因为任何伟大的创新都不是凭空而来的，都需要有前期的积累和探索。</p>\n<p>岁月流转，到了2025年8月，暑假课程结束了。李老师那颗探索的心再次萌动起来。在人们的传统观念中，C++是一门非常难学的编程语言，似乎只有那些所谓的“小天才”才能掌握。这种观念流传至今，几乎已经固化。但李老师却不这么想，他一直思考着如何降低C++的教学门槛。一个大胆的想法在他脑海中浮现：能不能把Python turtle的命令移植到C++中呢？这样一来，学生们在学习了Python turtle之后再学习C++，岂不是会容易很多？</p>\n<p>为了实现这个想法，李老师进行了多方面的调研。他深入研究底层技术，了解现有的库是否能够满足需求。经过深思熟虑，李老师最终决定采用SDL2库进行全新编写。这样做的好处是显而易见的，基于工业级别的SDL2库，不仅底层代码可以全程掌握，而且拓展性极强，为后续的开发和完善提供了广阔的空间。</p>\n<p>在这个小城市里，李老师已经实现了生活无忧，并且能够完全掌控自己的时间，没有绩效考核等繁琐的压力。所以，暑假过后，从周一到周五，他每天都全身心地投入到C++精灵库的开发与调试工作中。有时候，一个小小的问题可能需要花费好几天的时间来解决。如果是在一线城市，这样的时间和人力成本无疑是巨大的，但在五线小城市，相对来说就显得微不足道了。也许，只有在这种相对“休闲”的状态中，人才能静下心来，专注于一件事情，从而做出伟大的、革命性的产品。</p>\n<p>如今，C++精灵库已经实现了超越。就拿它的链式调用来说，这种设计让代码更加优雅，更接近自然语言，大大降低了学习和使用的难度。李老师还精心设计了许多画笔颜色的调节命令，如penshade、pentone、pensat以及penhsv等，这些在Python turtle中都是没有的。这些独特的命令，为美术生的艺术创造打开了方便之门，让他们能够在编程的世界里更加自由地发挥想象力和创造力。</p>\n<p>让我们来看下面的C++代码：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:cpp;gutter:true;\">#include \"sprites.h\"  //包含C++精灵库 \nSprite turtle;       //建立角色叫turtle \n\nint main(){        //主功能块 \n   turtle.bgcolor(\"black\");\n   turtle.pensize(4).speed(0);\n   for(int i=0;i&lt;36;i++)\n       turtle.fd(10).left(10);\n   for(int i=0;i&lt;36;i++)\n       turtle.fd(10).right(10); \n    \n   turtle.ht(); \n   turtle.done();  \n   return 0;\n}\n</pre>\n</div>\n<p>　　再看下对应的Python turtle代码：</p>\n<div class=\"cnblogs_Highlighter\">\n<pre class=\"brush:php;gutter:true;\">import turtle\nturtle.bgcolor(\"black\")\nturtle.pensize(4)\nturtle.speed(0)\nfor i in range(36):\n    turtle.fd(10)\n    turtle.left(10)\nfor i in range(36):\n    turtle.fd(10)\n    turtle.right(10)\n</pre>\n</div>\n<p>　　</p>\n<p>它们的本质是一样的！C++版本的核心逻辑代码，只需稍加修改，将C++的链式调用改成Python的单个命令调用，复制到Python IDLE中就能运行。不过，这一改，倒是把原本优雅的C++代码换成了传统的Python书写方式。</p>\n<p>所以说，为什么很多伟大的作品都是诞生在一些不起眼的地方呢？因为在这里，人们可以摆脱外界的干扰和压力，以最低的成本去追求自己的理想，同时又能将自己的价值最大化。就像C++精灵库一样，它在萍乡这个小城市里诞生，却有可能为整个编程教育领域带来深远的影响。</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-08 15:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lixingqiu\">李兴球</a>&nbsp;\n阅读(<span id=\"post_view_count\">184</span>)&nbsp;\n评论(<span id=\"post_comment_count\">3</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "自适应可变速率ID生成器的设计与实践(视频)",
      "link": "https://www.cnblogs.com/Zongsoft/p/19457036/sequence",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Zongsoft/p/19457036/sequence\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 15:03\">\n    <span>自适应可变速率ID生成器的设计与实践(视频)</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2026-01-08 15:03</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Zongsoft\">Zongsoft</a>&nbsp;\n阅读(<span id=\"post_view_count\">60</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n            <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        在分布式系统架构中，全局唯一ID生成器是支撑高并发、高可用系统的基石。市面上的常见方案（如Snowflake-ID、UUID、Redis自增）各有优劣，但往往难以兼顾高性能、无中心化与灵活的业务需求。\n本系列视频将带你深入剖析一个开源项目中的核心组件，重点解析如何设计一款能智能适应流量波动、兼顾全局唯一与趋势递增特性的高性能ID生成器。我们将从理论设计、性能压测到源码实现，全方位解读这套算法如何在保证极高吞吐量的同时，实现毫秒级的自适应与可变速率调节。\n无论你是架构师、后端开发工程师，还是对高性能算法感兴趣的爱好者，这个系列都将为你提供宝贵的实战经验和深度的技术洞察。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在分布式系统设计中，ID生成器 <em>(<strong>S</strong>equence)</em> 是看似基础却至关重要的组件。然而，一些常用解决方案 <em>(如 Snowflake-ID 算法)</em> 在高并发、弹性伸缩场景下，常面临机器节点分配、时钟回拨、序列号耗尽、跨机房容错等挑战。你是否也曾为这些问题困扰？</p>\n<p><a href=\"http://zongsoft.com\" rel=\"noopener nofollow\" target=\"_blank\"><em><strong>Z</strong>ongsoft</em></a> 开源项目中的 <a href=\"https://github.com/Zongsoft/framework/blob/master/Zongsoft.Core/src/Common/Sequence.cs\" rel=\"noopener nofollow\" target=\"_blank\"><em>自适应可变速率ID生成器</em></a>，或许能为你提供一种新的思路。</p>\n<p>我强烈推荐大家关注近期上线的 <strong>视频系列</strong>：《<a href=\"https://space.bilibili.com/20995572\" rel=\"noopener nofollow\" target=\"_blank\">自适应可变速率ID生成器的设计与实践</a>》。</p>\n<p>系列视频采取 “<strong>理论</strong>-<strong>实验</strong>-<strong>源码</strong>” 三层递进结构，涵盖从设计理念到性能验证再到实现细节的完整知识链，展示了如何设计并实现一个智能适应流量波动、兼顾全局唯一与高信息密度、高性能的解决方案。无论是分布式系统初学者还是资深工程师都能从中获益。其亮点在于：</p>\n<ol>\n<li>\n<p><strong>直面痛点，突破传统局限​</strong></p>\n<p>视频中对比了 Snowflake-ID、UUID、数据库自增等方案的优劣，并重点解析了如何通过动态速率调整和时钟回拨容错机制，避免序列号争用与时间同步问题。这种设计尤其适合流量突增场景 <em>（如秒杀、日志高频写入）</em>，显著提升系统的稳定性。</p>\n</li>\n<li>\n<p><strong>实验驱动，数据说话​</strong></p>\n<p>系列中通过 <strong>6</strong> 组严谨实验，验证了算法在性能、正确性、稳定性方面的表现，并与原生 Redis 生成器进行对比。结果清晰展示了其在高压下的吞吐量优势，为技术选型提供了可靠依据。</p>\n</li>\n<li>\n<p><strong>开源实战，源码级解读​</strong></p>\n<p>视频直接基于 <a href=\"https://github.com/Zongsoft/framework\" rel=\"noopener nofollow\" target=\"_blank\"><em><strong>Z</strong>ongsoft</em></a> 开源项目代码解析，从位运算设计到异常处理逻辑，逐行拆解实现细节。无论是学习分布式系统设计，还是需要二次开发，都具有极高参考价值。</p>\n</li>\n</ol>\n<blockquote>\n<p>无论你是架构师、后端开发工程师，还是对高性能算法感兴趣的爱好者，这个系列都将为你提供宝贵的实战经验和深度的技术洞察。又或者你正在构建高并发系统，或对分布式基础组件有深入探索的兴趣，这一系列视频将是不可多得的学习资源。<br />\n它不仅能帮助你理解ID生成器的本质，更能拓宽解决复杂问题的思路。</p>\n</blockquote>\n<hr />\n<h3 id=\"-视频-1自适应可变速率id生成器设计与实践上\">🎥 视频 1：自适应可变速率ID生成器设计与实践(上)</h3>\n<blockquote>\n<p>副标题： 从理论到架构：为什么我们需要新的ID生成方案？<br /><br />\n视频地址：<a href=\"https://www.bilibili.com/video/BV15fiSBXEW5\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV15fiSBXEW5</a></p>\n</blockquote>\n<p>在本系列的第一部分，我们将首先对现有的常见分布式ID生成方案进行深度的横向对比与剖析。</p>\n<p>深入探讨 Snowflake ID 的机器节点分配和时钟回拨、时钟漂移问题、UUID 的无序性、时钟问题与存储浪费、数据库自增ID的性能瓶颈与各种限制，以及 Redis 递增方案的优缺点。</p>\n<p>详细阐述本算法的设计初衷与核心理念；在此基础上，视频深入阐述自适应可变速率ID生成器的设计目标与核心理念，重点讲解如何通过动态速率调整、时钟回拨容错等机制，解决传统方案在高并发场景下的序列号耗尽、时钟同步等痛点问题。该视频为理解后续实验与源码实现奠定理论基础。</p>\n<h3 id=\"-视频-2自适应可变速率id生成器设计与实践中\">🎥 视频 2：自适应可变速率ID生成器设计与实践(中)</h3>\n<blockquote>\n<p>副标题： 数据说话：性能、稳定性与正确性的硬核实测<br /><br />\n视频地址：<a href=\"https://www.bilibili.com/video/BV1EQiSBtE38\" rel=\"noopener nofollow\" target=\"_blank\">https://www.bilibili.com/video/BV1EQiSBtE38</a></p>\n</blockquote>\n<p>光有理论不够，数据才是硬道理。在本集中，我们将通过 <strong>6</strong> 个精心设计的实验，对算法进行全方位的压力测试与验证：</p>\n<ul>\n<li>核心指标：验证生成器在高并发场景下的吞吐量（TPS）与响应延迟。</li>\n<li>稳定性测试：模拟延迟环境中，算法在长时间高并发运行下的稳定性与正确性。</li>\n<li>横向对比：我们将本算法与原生 Redis 生成器进行同场景下的性能对比，直观展示其在资源消耗与生成效率上的优势。</li>\n</ul>\n<blockquote>\n<p>通过这些实验，你将看到这套算法在实际应用中表现出的卓越性能。</p>\n</blockquote>\n<p>视频特别设置了与原生 Redis 生成器的对比测试，通过量化数据展现自适应算法在可变负载场景下的性能优势。例如，在流量突增时，传统生成器可能因序列号快速耗尽而导致ID生成延迟或阻塞，而自适应算法能动态调整生成策略，保持高性能与稳定性。这些实验为开发者提供了客观的评估依据，帮助他们在技术选型时做出明智决策。</p>\n<h3 id=\"-视频-3自适应可变速率id生成器设计与实践下\">🎥 视频 3：自适应可变速率ID生成器设计与实践(下)</h3>\n<blockquote>\n<p>副标题： 源码深潜：揭秘核心逻辑与环境配置<br /><br />\n视频地址：即将发布，请关注微信公众号(<code>Zongsoft</code>)以获得及时发布通知。</p>\n</blockquote>\n<p>最后一集，我们将带你潜入代码深处，直面该算法的核心实现以及如何快速搭建开发与测试环境。</p>\n<p>逐行剖析 <a href=\"https://github.com/Zongsoft/framework/blob/master/Zongsoft.Core/src/Common/Sequence.cs\" rel=\"noopener nofollow\" target=\"_blank\">Sequence</a> 类的关键逻辑，解读代理模式封装、动态步长调整、本地无锁递增、边界保障机制、时序感知优化等核心代码块。<br />\n详细介绍算法运行所需的环境依赖与配置参数，帮助你快速将这套高性能组件集成到自己的项目中。</p>\n<p>通过本集，你将掌握从源码到部署的全链路能力——不仅 <em>“用得上”</em>，更能 <em>“懂透原理”</em>，在实际项目中快速构建出自适应、高可靠、零运维的ID生成服务，为高并发系统筑牢基石。</p>\n<hr />\n<ul>\n<li>Bilibili\n<blockquote>\n<p><a href=\"https://space.bilibili.com/20995572\" rel=\"noopener nofollow\" target=\"_blank\">https://space.bilibili.com/20995572</a></p>\n</blockquote>\n</li>\n<li>抖音\n<blockquote>\n<p><a href=\"https://www.douyin.com/user/MS4wLjABAAAA9NmpuYVoLopaB6XdHoQ1CcmDF5DIb5YgwKzBLjZZdyU\" rel=\"noopener nofollow\" target=\"_blank\">https://www.douyin.com/user/MS4wLjABAAAA9NmpuYVoLopaB6XdHoQ1CcmDF5DIb5YgwKzBLjZZdyU</a></p>\n</blockquote>\n</li>\n<li>微信公众号\n<blockquote>\n<p><img alt=\"Zongsoft 微信公众号\" class=\"lazyload\" /></p>\n</blockquote>\n</li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    <div style=\"text-align: center;\">\n\t<img src=\"https://raw.githubusercontent.com/Zongsoft/Guidelines/master/zongsoft-qrcode%28wechat%29.png\" />\n</div>\n\n<hr style=\"margin-top: 2em; margin-bottom: 2em; margin-left: 0; margin-right: 0; padding: 0; height: 2px; border: 0; background-color: #e8e8e8;\" />\n\n<div id=\"license\">\n\t<img src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" width=\"\" />\n\t<p style=\"margin-top: 4px;\">\n本作品采用 <a class=\"bi-link\" href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" target=\"_blank\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a> 进行许可。欢迎转载、使用、重新发布，但必须保留本文的署名 <a class=\"bi-link\" href=\"https://github.com/zongsoft\" target=\"_blank\">钟峰</a>（包含链接：<a class=\"bi-link\" href=\"http://zongsoft.github.io/\" target=\"_blank\">http://zongsoft.github.io</a>），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问或授权方面的协商，请致信给我 (zongsoft@qq.com)。\n\t</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "强烈推荐 | 阿里开源的这10个神级项目",
      "link": "https://www.cnblogs.com/12lisu/p/19456855",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19456855\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 14:35\">\n    <span>强烈推荐 | 阿里开源的这10个神级项目</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>最近趁着放假休息，特地整理了一下，阿里巴巴开源的10款神级项目。</p>\n<p>这些开源项目中的绝大多数，我都在实际工作中用过，或者有同事用过。确实挺不错，挺有价值的，现在推荐给大家。</p>\n<h2 id=\"1-druid\">1. Druid</h2>\n<p>Druid自称是Java语言中最好的数据库连接池，它能够提供强大的监控和扩展功能。监控后台如下图所示：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>Druid的主要优点如下：</p>\n<ul>\n<li>它能监控数据库访问性能。</li>\n<li>它提供了WallFilter，它是基于SQL语义分析来实现防御SQL注入攻击的。</li>\n<li>它提供了多种监测连接泄漏的手段。</li>\n<li>它提供了数据库密码加密的功能。</li>\n<li>它能打印SQL执行日志。</li>\n</ul>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/druid\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/druid</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba/druid\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba/druid</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n\t\t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;druid&lt;/artifactId&gt;\n\t\t&lt;version&gt;${druid-version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"2-fastjson\">2. fastjson</h2>\n<p><code>fastjson</code>是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p>\n<p>fastjson的主要优点如下：</p>\n<ul>\n<li>速度快，fastjson相对其他JSON库的特点是快，从2011年fastjson发布1.1.x版本之后，其性能从未被其他Java实现的JSON库超越。</li>\n<li>使用广泛，fastjson在阿里巴巴大规模使用，在数万台服务器上部署，fastjson在业界被广泛接受。在2012年被开源中国评选为最受欢迎的国产开源软件之一。</li>\n<li>使用简单，fastjson的API十分简洁。</li>\n</ul>\n<pre><code class=\"language-java\">//序列化\nString text = JSON.toJSONString(obj); \n//反序列化\nVO vo = JSON.parseObject(\"{...}\", VO.class); \n</code></pre>\n<ul>\n<li>功能完备，支持泛型，支持流处理超大文本，支持枚举，支持序列化和反序列化扩展。</li>\n</ul>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/fastjson\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/fastjson</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba/fastjson\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba/fastjson</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n    &lt;version&gt;1.2.76&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"3-dubbo\">3. Dubbo</h2>\n<p>Apache Dubbo 是一款微服务开发框架，它提供了 RPC通信 与 微服务治理 两大关键能力。这意味着，使用 Dubbo 开发的微服务，将具备相互之间的远程发现与通信能力， 同时利用 Dubbo 提供的丰富服务治理能力，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。</p>\n<p>同时 Dubbo 是高度可扩展的，用户几乎可以在任意功能点去定制自己的实现，以改变框架的默认行为来满足自己的业务需求。它目前已交给Apache管理和维护。</p>\n<p>架构图如下：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>Dubbo的主要优点如下：</p>\n<ul>\n<li>基于透明接口的RPC</li>\n<li>智能负载均衡</li>\n<li>自动服务注册和发现</li>\n<li>高扩展性</li>\n<li>运行时流量路由</li>\n<li>可视化服务治理</li>\n<li>云原生友好</li>\n</ul>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/apache/dubbo\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/apache/dubbo</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba/dubbo/\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba/dubbo/</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;properties&gt;\n    &lt;dubbo.version&gt;3.0.3&lt;/dubbo.version&gt;\n&lt;/properties&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;\n        &lt;artifactId&gt;dubbo&lt;/artifactId&gt;\n        &lt;version&gt;${dubbo.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;\n        &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;\n        &lt;version&gt;${dubbo.version}&lt;/version&gt;\n        &lt;type&gt;pom&lt;/type&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<h2 id=\"4-rocketmq\">4. Rocketmq</h2>\n<p>Apache RocketMQ是一个分布式消息和流媒体平台，具有低延迟、高性能和可靠性、万亿级容量和灵活的可扩展性。</p>\n<p>它提供了多种功能：</p>\n<ul>\n<li>消息传递模式，包括发布/订阅、请求/回复和流媒体</li>\n<li>金融级交易消息</li>\n<li>基于DLedger的内置容错和高可用配置选项</li>\n<li>多种跨语言客户端，如Java、C/C++、Python、Go</li>\n<li>可插拔传输协议，例如 TCP、SSL、AIO</li>\n<li>内置消息追踪能力，也支持opentracing</li>\n<li>多功能大数据和流媒体生态系统集成</li>\n<li>按时间或偏移量的消息追溯</li>\n<li>可靠的 FIFO 和同一队列中的严格有序消息传递</li>\n<li>高效的拉推式消费模式</li>\n<li>单个队列百万级消息累积能力</li>\n<li>多种消息传递协议，如 JMS 和 OpenMessaging</li>\n<li>灵活的分布式横向扩展部署架构</li>\n<li>闪电般的批量消息交换系统</li>\n<li>各种消息过滤机制，例如 SQL 和 Tag</li>\n<li>用于隔离测试和云隔离集群的 Docker 镜像</li>\n<li>用于配置、指标和监控的功能丰富的管理仪表板</li>\n<li>认证和授权</li>\n<li>免费的开源连接器，用于源和接收器</li>\n</ul>\n<p>rocketmq后台管理界面：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/apache/rocketmq\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/apache/rocketmq</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/org.apache.rocketmq/rocketmq-spring-boot-starter\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/org.apache.rocketmq/rocketmq-spring-boot-starter</a></p>\n</blockquote>\n<p>rocketmq包含：服务端和客户端，在我们的项目中主要关注客户端的代码即可。</p>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;\n    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;\n    &lt;version&gt;4.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"4-arthas\">4. Arthas</h2>\n<p>Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。</p>\n<p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>\n<ul>\n<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>\n<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>\n<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>\n<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li>\n<li>是否有一个全局视角来查看系统的运行状况？</li>\n<li>有什么办法可以监控到JVM的实时运行状态？</li>\n<li>怎么快速定位应用的热点，生成火焰图？</li>\n<li>怎样直接从JVM内查找某个类的实例？</li>\n</ul>\n<p>分析代码消耗时间：<br />\n<img alt=\"\" class=\"lazyload\" /><br />\nArthas支持JDK 6+，能够运行在多种操作系统上，比如：Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。</p>\n<blockquote>\n<p>github地址: <a href=\"https://alibaba.github.io/arthas/\" rel=\"noopener nofollow\" target=\"_blank\">https://alibaba.github.io/arthas/</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.taobao.arthas/arthas-spring-boot-starter\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.taobao.arthas/arthas-spring-boot-starter</a></p>\n</blockquote>\n<p>在目标机器执行如下命令即可启动arthas：</p>\n<pre><code class=\"language-java\">curl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n</code></pre>\n<h2 id=\"5-nacos\">5. Nacos</h2>\n<p>Nacos是一个易于使用的平台，专为动态服务发现和配置以及服务管理而设计。它可以帮助您轻松构建云原生应用程序和微服务平台。</p>\n<p>服务是Nacos的一等公民。Nacos 支持几乎所有类型的服务，例如Dubbo/gRPC 服务、Spring Cloud RESTFul 服务或Kubernetes 服务。</p>\n<p>Nacos 提供了四大功能。</p>\n<ul>\n<li><code>服务发现和服务健康检查</code>。Nacos 使服务通过 DNS 或 HTTP 接口注册自己和发现其他服务变得简单。Nacos 还提供服务的实时健康检查，以防止向不健康的主机或服务实例发送请求。</li>\n<li><code>动态配置管理</code>。动态配置服务允许您在所有环境中以集中和动态的方式管理所有服务的配置。Nacos 无需在更新配置时重新部署应用程序和服务，这使得配置更改更加高效和敏捷。</li>\n<li><code>动态 DNS 服务</code>。Nacos 支持加权路由，让您更容易在数据中心内的生产环境中实现中层负载均衡、灵活的路由策略、流量控制和简单的 DNS 解析服务。它可以帮助您轻松实现基于 DNS 的服务发现，并防止应用程序耦合到特定于供应商的服务发现 API。</li>\n<li><code>服务和元数据管理</code>。Nacos 提供了一个易于使用的服务仪表板，帮助您管理您的服务元数据、配置、kubernetes DNS、服务健康和指标统计。</li>\n</ul>\n<p>Nacos 地图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>Nacos 生态图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/nacos\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/nacos</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-discovery\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-discovery</a></p>\n</blockquote>\n<h2 id=\"6-easyexcel\">6. easyexcel</h2>\n<p>Java解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。</p>\n<p>easyexcel重写了poi对07版Excel的解析，一个3M的excel用POI sax解析依然需要100M左右内存，改用easyexcel可以降低到几M，并且再大的excel也不会出现内存溢出；03版依赖POI的sax模式，在上层做了模型转换的封装，让使用者更加简单方便。</p>\n<p>64M内存1分钟内读取75M(46W行25列)的Excel</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/easyexcel\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/easyexcel</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba/easyexcel\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba/easyexcel</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;\n    &lt;version&gt;2.2.6&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"7-sentinel\">7. Sentinel</h2>\n<p>随着分布式系统变得越来越流行，服务之间的可靠性变得比以往任何时候都更加重要。</p>\n<p>Sentinel以“流量”为切入点，在流量控制、 流量整形、熔断、系统自适应保护等多个领域开展工作，保障微服务的可靠性和弹性。</p>\n<p>Sentinel具有以下特点：</p>\n<ul>\n<li><code>丰富的适用场景</code>：Sentinel在阿里巴巴得到了广泛的应用，几乎覆盖了近10年双11（11.11）购物节的所有核心场景，比如需要限制突发流量的“秒杀”满足系统容量、消息削峰填谷、下游不可靠业务断路、集群流量控制等。</li>\n<li><code>实时监控</code>：Sentinel 还提供实时监控能力。可以实时查看单台机器的运行时信息，以及500个节点以下集群的运行时信息汇总。</li>\n<li><code>广泛的开源生态系统</code>：Sentinel 提供与 Spring Cloud、Dubbo 和 gRPC 等常用框架和库的开箱即用集成。您只需将适配器依赖项添加到您的服务即可轻松使用 Sentinel。</li>\n<li><code>多语言支持</code>：Sentinel 为 Java、Go和C++提供了本机支持。</li>\n<li><code>丰富的SPI扩展</code>：Sentinel提供简单易用的SPI扩展接口，可以让您快速自定义逻辑，例如自定义规则管理、适配数据源等。</li>\n</ul>\n<p>功能概述：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>生态系统景观：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/Sentinel\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/Sentinel</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba.csp/sentinel-core\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba.csp/sentinel-core</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;\n    &lt;artifactId&gt;sentinel-core&lt;/artifactId&gt;\n    &lt;version&gt;1.8.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"8-otter\">8. otter</h2>\n<p>阿里巴巴B2B公司，因为业务的特性，卖家主要集中在国内，买家主要集中在国外，所以衍生出了杭州和美国异地机房的需求，同时为了提升用户体验，整个机房的架构为双A，两边均可写，由此诞生了otter这样一个产品。</p>\n<p>otter第一版本可追溯到04~05年，此次外部开源的版本为第4版，开发时间从2011年7月份一直持续到现在，目前阿里巴巴B2B内部的本地/异地机房的同步需求基本全上了otte4。</p>\n<p>目前同步规模：</p>\n<ul>\n<li>同步数据量6亿</li>\n<li>文件同步1.5TB(2000w张图片)</li>\n<li>涉及200+个数据库实例之间的同步</li>\n<li>80+台机器的集群规模</li>\n</ul>\n<p>otter能解决什么？</p>\n<ul>\n<li>\n<p><code>异构库同步</code>。 mysql -&gt; mysql/oracle. (目前开源版本只支持mysql增量，目标库可以是mysql或者oracle，取决于canal的功能)</p>\n</li>\n<li>\n<p><code>单机房同步</code> (数据库之间RTT &lt; 1ms)</p>\n<p>a. 数据库版本升级</p>\n<p>b. 数据表迁移</p>\n<p>c. 异步二级索引</p>\n</li>\n<li>\n<p><code>异地机房同步</code> (比如阿里巴巴国际站就是杭州和美国机房的数据库同步，RTT &gt; 200ms，亮点)</p>\n<p>a. 机房容灾</p>\n</li>\n<li>\n<p><code>双向同步</code></p>\n<p>a. 避免回环算法 (通用的解决方案，支持大部分关系型数据库)</p>\n<p>b. 数据一致性算法 (保证双A机房模式下，数据保证最终一致性，亮点)</p>\n</li>\n<li>\n<p><code>文件同步</code><br />\n站点镜像 (进行数据复制的同时，复制关联的图片，比如复制产品数据，同时复制产品图片).</p>\n</li>\n</ul>\n<p>工作原理图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>单机房复制示意图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>异地机房复制示意图：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/otter\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/otter</a></p>\n</blockquote>\n<blockquote>\n<p>maven中央仓库: <a href=\"https://mvnrepository.com/artifact/com.alibaba.otter/canal.client\" rel=\"noopener nofollow\" target=\"_blank\">https://mvnrepository.com/artifact/com.alibaba.otter/canal.client</a></p>\n</blockquote>\n<h2 id=\"9-p3c\">9. P3C</h2>\n<p>P3C插件呈现了阿里巴巴 Java 编码指南，它整合了阿里巴巴集团技术团队多年来的最佳编程实践。由于我们鼓励重用和更好地理解彼此的程序，因此大量 Java 编程团队对跨项目的代码质量提出了苛刻的要求。</p>\n<p>阿里巴巴过去见过很多编程问题。例如，有缺陷的数据库表结构和索引设计可能会导致软件架构缺陷和性能风险。另一个例子是混乱的代码结构难以维护。此外，未经身份验证的易受攻击的代码容易受到黑客的攻击。为了解决这些问题，我们为阿里巴巴的Java开发人员编写了这份文档。</p>\n<p>更多信息请参考阿里巴巴Java编码指南：</p>\n<ul>\n<li>中文版：阿里巴巴Java开发手册</li>\n<li>英文版：Alibaba Java Coding Guidelines</li>\n</ul>\n<p>该项目由3部分组成：</p>\n<ul>\n<li>PMD 实现</li>\n<li>IntelliJ IDEA 插件</li>\n<li>Eclipse 插件</li>\n</ul>\n<p>四十九条规则是基于PMD实现的，更多详细信息请参考P3C-PMD文档。IDE 插件（IDEA 和 Eclipse）中实现的四个规则如下：</p>\n<ul>\n<li>\n<p>[Mandatory]禁止使用已弃用的类或方法。<br />\n注意：例如，应该使用 decode(String source, String encode) 而不是不推荐使用的方法 decode(String encodeStr)。一旦接口被弃用，接口提供者就有义务提供一个新的接口。同时，客户端程序员有义务检查它的新实现是什么。</p>\n</li>\n<li>\n<p>[Mandatory]来自接口或抽象类的重写方法必须用 @Override 注释标记。反例：对于 getObject() 和 get0bject()，第一个是字母“O”，第二个是数字“0”。为了准确判断覆盖是否成功，需要一个@Override注解。同时，一旦抽象类中的方法签名发生变化，实现类将立即报告编译时错误。</p>\n</li>\n<li>\n<p>[Mandatory] 静态字段或方法应直接通过其类名而不是其对应的对象名来引用。</p>\n</li>\n<li>\n<p>[Mandatory] hashCode 和 equals 的用法应该遵循：</p>\n</li>\n</ul>\n<ol>\n<li>如果 equals 被覆盖，则覆盖 hashCode。</li>\n<li>这两个方法必须为 Set 重写，因为它们用于确保不会在 Set 中插入重复的对象。</li>\n<li>如果使用自定义对象作为 Map 的键，则必须覆盖这两个方法。注意：String 可以用作 Map 的键，因为这两个方法已经被重写。</li>\n</ol>\n<p>使用p3c插件的效果：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>最新版阿里巴巴Java开发手册下载地址：<br />\n<a href=\"https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/p3c/blob/master/Java开发手册（嵩山版）.pdf</a></p>\n<blockquote>\n<p>github地址:<a href=\"https://github.com/alibaba/p3c/tree/master/idea-plugin\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/p3c/tree/master/idea-plugin</a></p>\n</blockquote>\n<h2 id=\"10-spring-cloud-alibaba\">10. Spring Cloud Alibaba</h2>\n<p>Spring Cloud Alibaba 为分布式应用开发提供一站式解决方案。它包含开发分布式应用程序所需的所有组件，使您可以轻松地使用 Spring Cloud 开发应用程序。</p>\n<p>使用Spring Cloud Alibaba，您只需添加一些注解和少量配置，即可将Spring Cloud应用连接到阿里巴巴的分布式解决方案，并通过阿里巴巴中间件构建分布式应用系统。</p>\n<p>主要功能如下：</p>\n<ul>\n<li><code>流量控制和服务降级</code>：默认支持 HTTP 服务的流量控制。您还可以使用注释自定义流量控制和服务降级规则。规则可以动态更改。</li>\n<li><code>服务注册和发现</code>：可以注册服务，客户端可以使用 Spring 管理的 bean，自动集成 Ribbon 来发现实例。</li>\n<li><code>分布式配置</code>：支持分布式系统中的外化配置，配置变化时自动刷新。</li>\n<li><code>事件驱动</code>：支持构建与共享消息系统连接的高度可扩展的事件驱动微服务。</li>\n<li><code>分布式事务</code>：支持高性能、易用的分布式事务解决方案。</li>\n<li><code>阿里云对象存储</code>：海量、安全、低成本、高可靠的云存储服务。支持随时随地在任何应用程序中存储和访问任何类型的数据。</li>\n<li><code>阿里云SchedulerX</code>：精准、高可靠、高可用的定时作业调度服务，响应时间秒级。</li>\n<li><code>阿里云短信</code>：覆盖全球的短信服务，阿里短信提供便捷、高效、智能的通讯能力，帮助企业快速联系客户。</li>\n</ul>\n<p>主要包含如下组件：</p>\n<ul>\n<li><code>Sentinel</code>：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li>\n<li><code>Nacos</code>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li>\n<li><code>RocketMQ</code>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li>\n<li><code>Dubbo</code>：Apache Dubbo™ 是一款高性能 Java RPC 框架。</li>\n<li><code>Seata</code>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li>\n<li><code>Alibaba Cloud OSS</code>: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>\n<li><code>Alibaba Cloud SchedulerX</code>: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li>\n<li><code>Alibaba Cloud SMS</code>: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>\n</ul>\n<blockquote>\n<p>github地址: <a href=\"https://github.com/alibaba/spring-cloud-alibaba\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/alibaba/spring-cloud-alibaba</a></p>\n</blockquote>\n<p>配置maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n</code></pre>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n<p>更多项目实战在我的技术网站：<a href=\"http://www.susan.net.cn/project\" rel=\"noopener nofollow\" target=\"_blank\">http://www.susan.net.cn/project</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 14:35</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">361</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2026 年 PHP 的三大优势 这门\"老将\"为何依然重要",
      "link": "https://www.cnblogs.com/catchadmin/p/19454737",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19454737\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 08:16\">\n    <span>2026 年 PHP 的三大优势 这门\"老将\"为何依然重要</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"2026-年-php-的三大优势-这门老将为何依然重要\">2026 年 PHP 的三大优势 这门\"老将\"为何依然重要</h1>\n<p>PHP \"快死了\"这句话喊了这么多年，如果真有来世，它的简历应该已经相当可观了。</p>\n<p>你大概见过这些论调：\"PHP 过时了\"、\"现在没人用 PHP 做正经系统了\"、\"只有老项目还在用\"。这些说法也不算全错——确实有大量遗留 PHP 代码在运行。但还有另一个现实很少被提及：PHP 仍然在驱动大量生产环境的后端系统，新的 PHP 项目也在不断出现，因为团队想要的东西和五年、十年前一样：</p>\n<ul>\n<li>可预测的部署流程</li>\n<li>快速迭代</li>\n<li>成熟的生态</li>\n<li>能够经受多人协作、多年维护的可读代码</li>\n</ul>\n<p>我喜欢这类问题，因为它逼你把话说清楚。不是\"我喜欢用\"，不是\"它很流行\"，而是你在生产代码中能实际指出的工程优势。</p>\n<p>下面是我的回答，写给两类读者：</p>\n<ul>\n<li><strong>如果你刚接触后端开发</strong>：你会得到一个清晰的心智模型，理解 PHP 为何仍然适合 Web 系统。</li>\n<li><strong>如果你经验丰富</strong>：你会看到现代 PHP 实践（类型、静态分析、清晰边界、务实的 API 模式）如何把\"PHP 容易上手\"变成\"PHP 可靠\"。</li>\n</ul>\n<p>我会尽量用平实的语言，但不会回避技术细节。真实的系统本来就是技术性的。目标是让这些技术内容变得易懂且实用。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/php-3-biggest-strengths-2026\" rel=\"noopener nofollow\" target=\"_blank\">原文 2026 年 PHP 的三大优势 这门\"老将\"为何依然重要</a></p>\n<h2 id=\"什么是优势在真实后端工作中的定义\">什么是\"优势\"：在真实后端工作中的定义</h2>\n<p>开发者比较语言时，讨论经常跑偏到性能基准、语法偏好或者互联网文化。但当你在构建 API 或 Web 后端时，\"优势\"通常意味着一些更无聊——也更重要的东西：</p>\n<ul>\n<li>能否快速交付功能而不埋下维护陷阱？</li>\n<li>能否集成数据库、队列和第三方 API 而不从头造轮子？</li>\n<li>能否处理混乱的数据和边缘情况而不把代码变成鬼屋？</li>\n</ul>\n<p>这就是 PHP 最擅长的领域。不是因为它最优雅，而是因为它的形状刚好契合大多数 Web 后端。</p>\n<p>带着这个思路，来看 PHP 在 2026 年的三大优势。</p>\n<h2 id=\"优势一web-原生的生产力php-天然契合-http-世界\">优势一：Web 原生的生产力（PHP 天然契合 HTTP 世界）</h2>\n<p>大多数后端都是 HTTP 机器。这不是比喻，而是日常工作：</p>\n<ul>\n<li>请求进来</li>\n<li>校验并规范化</li>\n<li>调用服务 / 数据库 / 外部 API</li>\n<li>返回 JSON</li>\n<li>记录日志和追踪</li>\n<li>循环</li>\n</ul>\n<p>PHP 的第一个优势是它在这个循环里感觉很自然。你不需要在处理请求之前\"搭建世界\"。PHP 的默认模型就是面向 Web 的，这一点往往被低估了。</p>\n<h3 id=\"经典的-php-执行模型为何仍然有用\">经典的 PHP 执行模型为何仍然有用</h3>\n<p>PHP 传统的请求生命周期很简单：</p>\n<ol>\n<li>开始请求</li>\n<li>运行代码</li>\n<li>返回响应</li>\n<li>结束请求</li>\n</ol>\n<p>然后下一个请求从头开始。</p>\n<p>有人把这当成相对于长驻服务器的劣势，但在实践中它往往是优势：</p>\n<ul>\n<li>内存泄漏不会那么致命，因为进程会回收。</li>\n<li>每个请求天然隔离。</li>\n<li>不太可能意外依赖内存状态。</li>\n<li>调试往往更简单，因为每个请求有清晰的边界。</li>\n</ul>\n<p>你也可以用长驻模式跑 PHP（RoadRunner、Swoole 等），它们在特定场景下确实很好。但经典模型对许多 API 仍然是可靠的默认选择，因为它稳定且对运维友好。</p>\n<h3 id=\"一个纯-php的-api-入口展示基本形态\">一个\"纯 PHP\"的 API 入口（展示基本形态）</h3>\n<p>即使你在生产环境使用 Laravel 或 Symfony（大多数正经应用确实该用），看看 PHP 为何在 Web 工作中高效还是有帮助的。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\nrequire __DIR__ . '/../vendor/autoload.php';\nheader('Content-Type: application/json; charset=utf-8');\n$method = $_SERVER['REQUEST_METHOD'] ?? 'GET';\n$path = parse_url($_SERVER['REQUEST_URI'] ?? '/', PHP_URL_PATH) ?: '/';\nfunction jsonResponse(array $payload, int $status = 200): void {\n    http_response_code($status);\n    echo json_encode($payload, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);\n    exit;\n}\nfunction readJsonBody(): array {\n    $raw = file_get_contents('php://input') ?: '';\n    $data = json_decode($raw, true);\n    return is_array($data) ? $data : [];\n}\nif ($method === 'GET' &amp;&amp; $path === '/health') {\n    jsonResponse(['ok' =&gt; true, 'time' =&gt; date(DATE_ATOM)]);\n}\nif ($method === 'POST' &amp;&amp; $path === '/users') {\n    $body = readJsonBody();\n    $email = strtolower(trim((string)($body['email'] ?? '')));\n    $name  = trim((string)($body['name'] ?? ''));\n    if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {\n        jsonResponse(['error' =&gt; 'Invalid email'], 422);\n    }\n    if ($name === '') {\n        jsonResponse(['error' =&gt; 'Name is required'], 422);\n    }\n    $id = random_int(1000, 9999);\n    jsonResponse(['id' =&gt; $id, 'email' =&gt; $email, 'name' =&gt; $name], 201);\n}\njsonResponse(['error' =&gt; 'Not found'], 404);\n</code></pre>\n<p>这不是\"最佳实践架构\"，但它演示了核心思想：PHP 的 Web 循环直接且易懂。这就是基础的生产力优势。</p>\n<h3 id=\"快与乱的区别薄-handler真服务\">\"快\"与\"乱\"的区别：薄 handler，真服务</h3>\n<p>PHP 的 Web 生产力要成为长期优势，前提是保持边界清晰。最容易失去这个优势的方式就是把所有东西都塞进控制器。</p>\n<p>一个可扩展的模式：</p>\n<ul>\n<li><strong>Handler / 控制器</strong>：解码请求、调用服务、编码响应</li>\n<li><strong>服务</strong>：业务逻辑 + 编排</li>\n<li><strong>Repository / Client</strong>：存储 + 外部 API 调用</li>\n</ul>\n<p>这是一个与框架无关的小例子：</p>\n<pre><code class=\"language-php\">final class CreateUserHandler\n{\n    public function __construct(\n        private readonly UserService $service\n    ) {}\n    public function __invoke(array $body): array\n    {\n        $input = CreateUserInput::fromArray($body);\n        $user  = $this-&gt;service-&gt;create($input);\n        return UserResource::toArray($user);\n    }\n}\n</code></pre>\n<p>Handler 读起来像一段叙述。这就对了。</p>\n<p>现在服务来做真正的决策：</p>\n<pre><code class=\"language-php\">final class UserService\n{\n    public function __construct(\n        private readonly UserRepository $users\n    ) {}\n    public function create(CreateUserInput $input): User\n    {\n        if ($this-&gt;users-&gt;existsByEmail($input-&gt;email)) {\n            throw new DomainException('Email already registered');\n        }\n        $user = User::register($input-&gt;email, $input-&gt;name);\n        $this-&gt;users-&gt;save($user);\n        return $user;\n    }\n}\n</code></pre>\n<p>这个结构并不花哨，但它能防止代码库在六个月内变成意大利面。</p>\n<h3 id=\"真实世界的-api-工作超时和重试是功能的一部分\">真实世界的 API 工作：超时和重试是功能的一部分</h3>\n<p>PHP 保持实用的一个原因是，做 PHP 后端的团队往往很早就被迫面对 Web 的现实。不是因为 PHP 特殊，而是因为 Web 本身就不宽容。</p>\n<p>如果你调用外部 API 却不设超时、不设重试策略，你就是在埋下未来的事故。</p>\n<p>下面是一个用 Guzzle 写的封装，在生产环境中能正经干活：</p>\n<pre><code class=\"language-php\">use GuzzleHttp\\Client;\nuse GuzzleHttp\\Exception\\GuzzleException;\nfinal class ShippingClient\n{\n    private Client $http;\n    public function __construct(string $baseUrl, string $token)\n    {\n        $this-&gt;http = new Client([\n            'base_uri' =&gt; rtrim($baseUrl, '/') . '/',\n            'timeout' =&gt; 3.0,\n            'connect_timeout' =&gt; 1.0,\n            'headers' =&gt; [\n                'Authorization' =&gt; \"Bearer {$token}\",\n                'Accept' =&gt; 'application/json',\n            ],\n        ]);\n    }\n    public function createLabel(array $payload): array\n    {\n        $attempts = 0;\n        while (true) {\n            $attempts++;\n            try {\n                $resp = $this-&gt;http-&gt;post('labels', ['json' =&gt; $payload]);\n                $data = json_decode((string)$resp-&gt;getBody(), true);\n                return is_array($data) ? $data : [];\n            } catch (GuzzleException $e) {\n                if ($attempts &gt;= 3) {\n                    throw new RuntimeException('Shipping API failed after retries', 0, $e);\n                }\n                // small exponential backoff + jitter\n                usleep((int)(100_000 * $attempts) + random_int(0, 50_000));\n            }\n        }\n    }\n}\n</code></pre>\n<p>当互联网本身是你的依赖时，这种代码是必须的——而 PHP 很适应这个场景。</p>\n<p><strong>为什么这是优势一</strong>：PHP 契合 HTTP 工作的形状，让团队能快速构建功能而不用与平台对抗。</p>\n<h2 id=\"优势二生态成熟度composer--框架--标准降低风险\">优势二：生态成熟度（Composer + 框架 + 标准降低风险）</h2>\n<p>PHP 的第二个优势是杠杆。</p>\n<p>很多语言都能做 Web 开发。但能让\"无聊的部分\"以可复用的方式被解决、让团队能招到已经熟悉这些模式的人，这样的成熟生态并不多。</p>\n<p>当你选择 PHP，你选择的不只是语法，还有：</p>\n<ul>\n<li>Composer + Packagist</li>\n<li>Laravel / Symfony（以及其他框架）</li>\n<li>PSR 标准（互操作性）</li>\n<li>稳定的工具链（测试、静态分析、格式化、重构）</li>\n</ul>\n<p>生态的成熟度能降低风险。风险才是真正花钱的地方。</p>\n<h3 id=\"composer让结构化成为常态的安静基石\">Composer：让结构化成为常态的安静基石</h3>\n<p>Composer 不只是依赖管理——它推动你走向模块化的代码库，用自动加载和命名空间。</p>\n<p>一个最小的例子：</p>\n<pre><code class=\"language-json\">{\n  \"require\": {\n    \"php\": \"^8.2\",\n    \"monolog/monolog\": \"^3.0\",\n    \"guzzlehttp/guzzle\": \"^7.0\"\n  },\n  \"autoload\": {\n    \"psr-4\": {\n      \"App\\\\\": \"src/\"\n    }\n  }\n}\n</code></pre>\n<p>一旦你采用 PSR-4 自动加载，你的代码就不再是\"文件\"，而开始变成\"模块\"。这个转变是现代 PHP 比老刻板印象更易维护的重要原因。</p>\n<h3 id=\"框架用无聊的方案解决无聊的问题这正是重点\">框架：用无聊的方案解决无聊的问题（这正是重点）</h3>\n<p>框架可能被过度使用，但\"不用框架\"的做法在应用增长后往往更糟。</p>\n<p>Laravel 和 Symfony 为你不想重新发明的东西提供了可靠的默认方案：</p>\n<ul>\n<li>路由和中间件</li>\n<li>校验和请求处理</li>\n<li>DI 容器模式</li>\n<li>缓存和队列</li>\n<li>数据库迁移</li>\n<li>结构化的错误处理</li>\n</ul>\n<p>大多数生产事故不是来自精妙的业务逻辑，而是来自胶水代码：超时、重试、不一致的校验、部分失败、意外的 payload、不一致的错误响应。</p>\n<p>框架默认方案减少这些事故，因为你建立在已经经历过成千上万个生产系统考验的模式之上。</p>\n<h3 id=\"psr-标准让你的代码不再被锁死\">PSR 标准：让你的代码不再被锁死</h3>\n<p>标准在你集成库或者超出最初决策时最为重要。</p>\n<p>例如：PSR-3 日志。</p>\n<pre><code class=\"language-php\">use Psr\\Log\\LoggerInterface;\nfinal class BillingService\n{\n    public function __construct(private readonly LoggerInterface $logger) {}\n    public function charge(int $userId, int $amountCents): void\n    {\n        $this-&gt;logger-&gt;info('Charge request', [\n            'userId' =&gt; $userId,\n            'amountCents' =&gt; $amountCents,\n        ]);\n        // ...\n    }\n}\n</code></pre>\n<p>这个类不在乎你今天用 Monolog 还是明天换成别的日志库。这种解耦才能让系统演进。</p>\n<h3 id=\"工具链和-2015-年相比现代-php-像换了一门语言\">工具链：和 2015 年相比，现代 PHP 像换了一门语言</h3>\n<p>很多\"PHP 黑\"来自于对老代码库的体验：弱类型、不一致的模式、\"先上线再说\"的文化。</p>\n<p>现代 PHP 团队通常会用一套简单的质量工具链：</p>\n<ul>\n<li>严格类型</li>\n<li>静态分析（PHPStan / Psalm）</li>\n<li>测试（PHPUnit / Pest）</li>\n<li>格式化（PHP-CS-Fixer）</li>\n<li>自动重构（Rector）</li>\n</ul>\n<p>这套组合会改变你写代码的方式。目标不是完美，而是尽早暴露问题，让代码在迭代中保持可读。</p>\n<p>下面是一个小例子，静态分析帮你避免一个运行时 bug：</p>\n<pre><code class=\"language-php\">final class UserRepository\n{\n    public function findByEmail(string $email): User\n    {\n        // DB lookup...\n        return null; // bug\n    }\n}\n</code></pre>\n<p>配置好静态分析后，这会立即被标记出来。</p>\n<p>PHP 的测试也不必很重。一个聚焦的测试可以读起来像文档：</p>\n<pre><code class=\"language-php\">final class MoneyTest extends TestCase\n{\n    public function testItAddsMoneyInSameCurrency(): void\n    {\n        $a = Money::usd(1000);\n        $b = Money::usd(250);\n        $sum = $a-&gt;add($b);\n        $this-&gt;assertSame(1250, $sum-&gt;cents());\n        $this-&gt;assertSame('USD', $sum-&gt;currency());\n    }\n}\n</code></pre>\n<p><strong>为什么这是优势二</strong>：PHP 的生态让你能快速交付并安全构建，因为工具链和惯例都已成熟。</p>\n<h2 id=\"优势三务实的数据管道php-擅长乱进干净出\">优势三：务实的数据管道（PHP 擅长\"乱进、干净出\"）</h2>\n<p>如果你做过一段时间后端，你就知道真相：这份工作就是数据转换。</p>\n<p>请求进来格式奇怪。数据库行取出来格式奇怪。外部 API 返回的是\"差不多是你期望的\"。Webhook 在不方便的时候重试。边缘情况在周五发生。</p>\n<p>PHP 在这类工作上特别强，因为它在两种模式下都很自如：</p>\n<ul>\n<li>快速操作（字符串、数组、JSON）</li>\n<li>结构化代码（DTO、值对象、枚举、readonly 属性）</li>\n</ul>\n<p>为了说明我的意思，来构建一个现实的管道：处理来自支付提供商的 webhook。</p>\n<p>这是一个很好的测试，因为它结合了：</p>\n<ul>\n<li>安全验证</li>\n<li>幂等性（重试）</li>\n<li>载荷规范化</li>\n<li>状态变更</li>\n<li>优雅处理未知事件类型</li>\n</ul>\n<h3 id=\"步骤一保持载荷边界显式化dto-优于原始数组\">步骤一：保持载荷边界显式化（DTO 优于原始数组）</h3>\n<p>数组在边界处没问题，但在整个应用中传递原始数组会变得痛苦。所以：尽早解析，尽早结构化。</p>\n<pre><code class=\"language-php\">final class WebhookEvent\n{\n    public function __construct(\n        public readonly string $id,\n        public readonly string $type,\n        public readonly int $createdAtEpoch,\n        public readonly array $data\n    ) {}\n    public static function fromArray(array $payload): self\n    {\n        return new self(\n            id: (string)($payload['id'] ?? ''),\n            type: (string)($payload['type'] ?? ''),\n            createdAtEpoch: (int)($payload['created_at'] ?? 0),\n            data: is_array($payload['data'] ?? null) ? $payload['data'] : []\n        );\n    }\n}\n</code></pre>\n<p>这是务实的做法：我们依赖的字段用强类型，原始数据留着灵活性，新字段加进来也不会炸。</p>\n<h3 id=\"步骤二验证签名不要信任-json\">步骤二：验证签名（不要\"信任 JSON\"）</h3>\n<pre><code class=\"language-php\">final class WebhookSignatureVerifier\n{\n    public function __construct(private readonly string $secret) {}\n    public function verify(string $rawBody, string $signatureHeader): bool\n    {\n        $expected = hash_hmac('sha256', $rawBody, $this-&gt;secret);\n        return hash_equals($expected, $signatureHeader);\n    }\n}\n</code></pre>\n<p>这里 <code>hash_equals</code> 很重要，用于避免时序攻击。这是个小细节，但这类习惯正是区分业余代码和生产代码的地方。</p>\n<h3 id=\"步骤三幂等性因为-webhook-会重试\">步骤三：幂等性（因为 webhook 会重试）</h3>\n<p>如果你处理同一个事件两次，你可能会：</p>\n<ul>\n<li>重复更新订阅</li>\n<li>重复发送邮件</li>\n<li>重复给账户加款</li>\n</ul>\n<p>所以要存储已处理的事件 ID。</p>\n<pre><code class=\"language-php\">final class WebhookIdempotencyStore\n{\n    public function __construct(private readonly PDO $pdo) {}\n    public function hasProcessed(string $eventId): bool\n    {\n        $stmt = $this-&gt;pdo-&gt;prepare(\"SELECT 1 FROM processed_webhooks WHERE event_id = :id\");\n        $stmt-&gt;execute([':id' =&gt; $eventId]);\n        return (bool)$stmt-&gt;fetchColumn();\n    }\n    public function markProcessed(string $eventId): void\n    {\n        $stmt = $this-&gt;pdo-&gt;prepare(\n            \"INSERT INTO processed_webhooks (event_id, processed_at)\n             VALUES (:id, NOW())\"\n        );\n        $stmt-&gt;execute([':id' =&gt; $eventId]);\n    }\n}\n</code></pre>\n<h3 id=\"步骤四干净地映射事件类型枚举很有帮助\">步骤四：干净地映射事件类型（枚举很有帮助）</h3>\n<pre><code class=\"language-php\">enum PaymentEventType: string\n{\n    case PaymentSucceeded = 'payment.succeeded';\n    case PaymentFailed = 'payment.failed';\n}\n</code></pre>\n<h3 id=\"步骤五用事务型-handler-把它们组合起来\">步骤五：用事务型 handler 把它们组合起来</h3>\n<pre><code class=\"language-php\">final class PaymentWebhookHandler\n{\n    public function __construct(\n        private readonly WebhookSignatureVerifier $verifier,\n        private readonly WebhookIdempotencyStore $idem,\n        private readonly PaymentService $payments,\n        private readonly PDO $pdo\n    ) {}\n    public function handle(string $rawBody, string $signatureHeader): void\n    {\n        if (!$this-&gt;verifier-&gt;verify($rawBody, $signatureHeader)) {\n            throw new RuntimeException('Invalid webhook signature');\n        }\n        $payload = json_decode($rawBody, true);\n        if (!is_array($payload)) {\n            throw new RuntimeException('Invalid JSON');\n        }\n        $event = WebhookEvent::fromArray($payload);\n        if ($event-&gt;id === '' || $event-&gt;type === '') {\n            throw new RuntimeException('Missing event fields');\n        }\n        if ($this-&gt;idem-&gt;hasProcessed($event-&gt;id)) {\n            return; // safe no-op\n        }\n        $this-&gt;pdo-&gt;beginTransaction();\n        try {\n            $this-&gt;dispatch($event);\n            $this-&gt;idem-&gt;markProcessed($event-&gt;id);\n            $this-&gt;pdo-&gt;commit();\n        } catch (Throwable $e) {\n            $this-&gt;pdo-&gt;rollBack();\n            throw $e;\n        }\n    }\n    private function dispatch(WebhookEvent $event): void\n    {\n        $type = PaymentEventType::tryFrom($event-&gt;type);\n        if ($type === null) {\n            // unknown event type: ignore or log\n            return;\n        }\n        $paymentId = (string)($event-&gt;data['payment_id'] ?? '');\n        if ($paymentId === '') return;\n        match ($type) {\n            PaymentEventType::PaymentSucceeded =&gt; $this-&gt;payments-&gt;markSucceeded($paymentId),\n            PaymentEventType::PaymentFailed    =&gt; $this-&gt;payments-&gt;markFailed($paymentId),\n        };\n    }\n}\n</code></pre>\n<p>这是一个干净的管道：</p>\n<ol>\n<li>验证真实性</li>\n<li>解析载荷</li>\n<li>规范化为 DTO</li>\n<li>强制幂等性</li>\n<li>事务</li>\n<li>分发领域动作</li>\n<li>容忍未知事件</li>\n</ol>\n<p>这就是 PHP 擅长的\"Web 现实\"代码：处理那些真正重要的脏活，同时保持可读。</p>\n<p><strong>为什么这是优势三</strong>：大多数后端都是数据管道，而 PHP 在真实世界约束下构建可理解的管道方面很强。</p>\n<h2 id=\"额外内容游标分页的实践深入因为它把三个优势串在一起\">额外内容：游标分页的实践深入（因为它把三个优势串在一起）</h2>\n<p>分页是那种看起来简单、等用户翻到深页才暴露问题的功能。它也是个好例子，能说明 PHP 为何还没过时：它同时涉及 HTTP、SQL 性能和响应设计。</p>\n<h3 id=\"为什么-offset-会伤害你\">为什么 OFFSET 会伤害你</h3>\n<p>Offset 分页（<code>LIMIT 20 OFFSET 100000</code>）迫使数据库扫描并丢弃大量行。在大表上，深页会变慢。</p>\n<p>它在并发写入时也可能不一致：插入/删除可能导致\"窗口\"移动时出现跳过或重复。</p>\n<p>游标分页（keyset/seek）通过使用稳定的排序和代表\"你上次停在哪里\"的游标来避免这些问题。</p>\n<h3 id=\"规则一游标逻辑必须匹配排序方向\">规则一：游标逻辑必须匹配排序方向</h3>\n<p>如果你按最新优先排序：</p>\n<pre><code class=\"language-sql\">ORDER BY created_at DESC, id DESC\n</code></pre>\n<ul>\n<li>下一页应该获取\"更早\"的行</li>\n<li>所以条件用 <code>&lt;</code></li>\n</ul>\n<p>如果你的数据库支持元组比较：</p>\n<pre><code class=\"language-sql\">SELECT id, created_at, total_cents\nFROM orders\nWHERE (created_at, id) &lt; (?, ?)\nORDER BY created_at DESC, id DESC\nLIMIT ?\n</code></pre>\n<p>如果不支持，用显式逻辑：</p>\n<pre><code class=\"language-sql\">SELECT id, created_at, total_cents\nFROM orders\nWHERE created_at &lt; ?\n   OR (created_at = ? AND id &lt; ?)\nORDER BY created_at DESC, id DESC\nLIMIT ?\n</code></pre>\n<h3 id=\"规则二游标应该是不透明的且防篡改\">规则二：游标应该是不透明的且防篡改</h3>\n<p>游标通常是一个类似 <code>(created_at, id)</code> 的对，序列化给客户端。Base64 编码在传输时没问题——但不是安全措施。如果你想防止客户端伪造游标，就签名它。</p>\n<pre><code class=\"language-php\">final class Cursor\n{\n    public function __construct(\n        public readonly string $createdAtIso,\n        public readonly int $id\n    ) {}\n}\nfinal class CursorCodec\n{\n    public function __construct(private readonly string $secret) {}\n    public function encode(Cursor $cursor): string\n    {\n        $json = json_encode([\n            'created_at' =&gt; $cursor-&gt;createdAtIso,\n            'id' =&gt; $cursor-&gt;id\n        ], JSON_UNESCAPED_SLASHES);\n        $b64 = rtrim(strtr(base64_encode($json), '+/', '-_'), '=');\n        $sig = hash_hmac('sha256', $b64, $this-&gt;secret);\n        return $b64 . '.' . $sig;\n    }\n    public function decode(string $token): Cursor\n    {\n        $parts = explode('.', $token, 2);\n        if (count($parts) !== 2) {\n            throw new InvalidArgumentException('Invalid cursor');\n        }\n        [$b64, $sig] = $parts;\n        $expected = hash_hmac('sha256', $b64, $this-&gt;secret);\n        if (!hash_equals($expected, $sig)) {\n            throw new InvalidArgumentException('Cursor signature mismatch');\n        }\n        $json = base64_decode(strtr($b64, '-_', '+/'), true);\n        if ($json === false) {\n            throw new InvalidArgumentException('Invalid cursor encoding');\n        }\n        $data = json_decode($json, true);\n        if (!is_array($data)) {\n            throw new InvalidArgumentException('Invalid cursor payload');\n        }\n        return new Cursor(\n            createdAtIso: (string)($data['created_at'] ?? ''),\n            id: (int)($data['id'] ?? 0)\n        );\n    }\n}\n</code></pre>\n<h3 id=\"repository-方法返回条目--下一个游标\">Repository 方法：返回条目 + 下一个游标</h3>\n<pre><code class=\"language-php\">final class OrderRepository\n{\n    public function __construct(private readonly PDO $pdo) {}\n    /**\n     * @return array{items: list&lt;array&gt;, next: ?Cursor}\n     */\n    public function listPage(?Cursor $after, int $limit): array\n    {\n        $limit = max(1, min($limit, 100));\n        if ($after === null) {\n            $sql = \"SELECT id, created_at, total_cents\n                    FROM orders\n                    ORDER BY created_at DESC, id DESC\n                    LIMIT :limit\";\n            $stmt = $this-&gt;pdo-&gt;prepare($sql);\n            $stmt-&gt;bindValue(':limit', $limit, PDO::PARAM_INT);\n        } else {\n            $sql = \"SELECT id, created_at, total_cents\n                    FROM orders\n                    WHERE created_at &lt; :created_at\n                       OR (created_at = :created_at AND id &lt; :id)\n                    ORDER BY created_at DESC, id DESC\n                    LIMIT :limit\";\n            $stmt = $this-&gt;pdo-&gt;prepare($sql);\n            $stmt-&gt;bindValue(':created_at', $after-&gt;createdAtIso);\n            $stmt-&gt;bindValue(':id', $after-&gt;id, PDO::PARAM_INT);\n            $stmt-&gt;bindValue(':limit', $limit, PDO::PARAM_INT);\n        }\n        $stmt-&gt;execute();\n        $rows = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC);\n        $items = array_map(fn($r) =&gt; [\n            'id' =&gt; (int)$r['id'],\n            'created_at' =&gt; (string)$r['created_at'],\n            'total_cents' =&gt; (int)$r['total_cents'],\n        ], $rows);\n        $next = null;\n        if ($items !== []) {\n            $last = $items[count($items) - 1];\n            $next = new Cursor($last['created_at'], $last['id']);\n        }\n        return ['items' =&gt; $items, 'next' =&gt; $next];\n    }\n}\n</code></pre>\n<p>现在你的 handler 可以解码 <code>after</code>、获取结果、编码 <code>next_cursor</code>——一个横跨 HTTP + SQL + JSON 响应的干净端到端管道。</p>\n<p>这就是实践中的最佳平衡点：PHP 的 Web 原生特性、生态工具和数据处理能力在这里汇合。</p>\n<h2 id=\"php-不是最佳默认选择的场景以及好团队怎么做\">PHP 不是最佳默认选择的场景（以及好团队怎么做）</h2>\n<p>PHP 不是万能的最佳工具：</p>\n<ul>\n<li>CPU 密集型工作负载（视频处理、大规模数值计算）</li>\n<li>将极高并发的 socket 服务器作为默认架构</li>\n<li>要求前后端用同一门语言共享严格类型的组织</li>\n</ul>\n<p>但大多数成功的团队不会把这当成重写一切的理由。他们做的是 Web 一直鼓励的事：组合系统。</p>\n<ul>\n<li>在 PHP 强的地方保留 API 表面。</li>\n<li>把重计算卸载给 worker 或专门的服务。</li>\n<li>用队列处理后台任务。</li>\n<li>在怪罪语言之前先优化数据库查询和缓存。</li>\n</ul>\n<p>这不是什么\"PHP 用户的自我安慰\"，这就是正常的系统设计。</p>\n<h2 id=\"结论\">结论</h2>\n<p>回到最初的问题——PHP 的三大优势：</p>\n<ul>\n<li><strong>Web 原生的生产力</strong>：PHP 天然契合 HTTP 工作，保持构建循环快速。</li>\n<li><strong>生态成熟度</strong>：Composer + 框架 + 标准 + 工具链给你杠杆并降低风险。</li>\n<li><strong>务实的数据管道</strong>：PHP 擅长把混乱的真实世界数据转换成干净、稳定的输出——同时不让代码变得不可读。</li>\n</ul>\n<p>如果你想让 PHP 感觉现代（而不是像那些刻板印象），方法始终如一：</p>\n<ul>\n<li>保持 handler/控制器薄</li>\n<li>用 DTO/值对象建模边界</li>\n<li>把超时、重试和幂等性当作一等功能</li>\n<li>按读取方式建索引（尤其是分页）</li>\n<li>用测试 + 静态分析保护重构</li>\n</ul>\n<p>PHP 不需要追热点。它只要继续做它擅长的事就够了：跑那些实用、好维护、能稳定上线的 Web 系统。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 08:16</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">462</span>)&nbsp;\n评论(<span id=\"post_comment_count\">6</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一文学习和实践 当今互联网安全的基石  -  TLS/SSL",
      "link": "https://www.cnblogs.com/dddy/p/19453911",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/dddy/p/19453911\" id=\"cb_post_title_url\" title=\"发布于 2026-01-07 21:18\">\n    <span>一文学习和实践 当今互联网安全的基石  -  TLS/SSL</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>[[N_OSI 模型.TCP 协议.封包]]<br />\n[[Java TLS Socket]]<br />\n[[TLS&amp;SSL协议]]</p>\n<h1 id=\"what-is-ssltls-\">What is SSL/TLS ?</h1>\n<p>TLS（Transport Layer Security）即传输层安全协议，SSL（Secure Sockets Layer）即安全套接层协议。它们都是用于在网络通信中保障数据安全和隐私的加密协议。</p>\n<h2 id=\"tlstransport-layer-security传输层安全协议\">TLS（Transport Layer Security）传输层安全协议</h2>\n<ol>\n<li><strong>发展历程</strong></li>\n</ol>\n<ul>\n<li>TLS 是 SSL 协议的继任者。由于 SSL 协议存在一些安全漏洞，并且随着网络安全需求的不断提高，IETF（Internet Engineering Task Force）对 SSL 3.0 进行了改进，推出了 TLS 1.0 协议，于 1999 年发布。TLS 协议在后续又不断更新版本，如 TLS 1.1、TLS 1.2 和 TLS 1.3，每一个新版本都在安全性和性能等方面有所提升。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<ul>\n<li>TLS 的工作原理与 SSL 类似，也包括握手阶段。在 TLS 握手过程中，客户端和服务器会协商协议版本、加密算法套件、交换密钥等。TLS 1.3 相比之前的版本，简化了握手过程，减少了握手消息的往返次数，从而提高了连接建立的速度，并且增强了安全性，如加强了密钥交换的安全性。</li>\n<li>例如，TLS 1.3 使用了更安全的密钥交换算法，如基于椭圆曲线的 Diffie - Hellman 密钥交换（ECDHE），这种算法能够有效抵抗中间人攻击等安全威胁。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>应用场景</strong></li>\n</ol>\n<ul>\n<li>TLS 的应用范围非常广泛。它不仅用于 Web 安全，还用于电子邮件安全（如 IMAP、POP3 和 SMTP 协议的安全版本）、虚拟专用网络（VPN）等众多网络通信场景。在现代互联网中，几乎所有需要安全通信的地方都会优先考虑使用 TLS 协议。</li>\n</ul>\n<h2 id=\"ssl-secure-sockets-layer安全套接层协议\">SSL （Secure Sockets Layer）安全套接层协议</h2>\n<ol>\n<li><strong>发展历程</strong></li>\n</ol>\n<ul>\n<li>SSL 最初是由网景公司（Netscape）在 1994 年开发的，目的是为了保障网络通信的安全，特别是在 Web 浏览器和服务器之间的通信安全。SSL 1.0 由于存在安全漏洞从未发布，SSL 2.0 在 1995 年发布，但也有安全问题。SSL 3.0 于 1996 年发布，它修复了许多 SSL 2.0 的问题，成为当时比较流行的安全协议。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<ul>\n<li>SSL 协议在应用层和传输层之间工作。它通过使用公钥和私钥加密技术来保证通信的保密性。当客户端（如浏览器）与服务器建立连接时，首先会进行 SSL 握手过程。</li>\n<li>在握手阶段，客户端向服务器发送客户端支持的加密算法列表等信息。服务器从列表中选择一种加密算法，并将服务器的证书发送给客户端。客户端验证服务器证书的合法性，例如检查证书是否由可信任的证书颁发机构（CA）颁发，证书是否过期等。</li>\n<li>如果证书验证通过，客户端和服务器就会协商出一个对称加密密钥。之后的数据传输就使用这个对称密钥进行加密，这样可以保证数据在传输过程中的保密性，因为只有客户端和服务器知道这个对称密钥。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>应用场景</strong></li>\n</ol>\n<ul>\n<li>SSL 主要应用于 Web 安全。例如，在早期的 https（Hypertext Transfer Protocol Secure）网站访问中，就是通过 SSL 协议来加密浏览器和服务器之间的数据传输。这使得用户在网站上输入的敏感信息，如登录密码、信用卡信息等在传输过程中不会被窃取。</li>\n</ul>\n<h2 id=\"两者关系和区别\">两者关系和区别</h2>\n<ol>\n<li><strong>关系</strong></li>\n</ol>\n<ul>\n<li>TLS 可以看作是 SSL 的升级版。TLS 协议在设计上借鉴了 SSL 协议的很多理念，并且在 SSL 的基础上进行了改进和扩展，以应对不断出现的新的安全威胁和网络通信需求。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>区别</strong></li>\n</ol>\n<ul>\n<li><strong>安全性</strong>：TLS 在安全性能上比 SSL 更优越。例如，SSL 3.0 存在 POODLE（Padding Oracle On Downgraded Legacy Encryption）攻击漏洞，而 TLS 协议通过不断更新版本来修复类似的安全漏洞。TLS 1.3 更是在密钥交换等关键环节采用了更先进的加密技术，提供了更强的安全性。</li>\n<li><strong>兼容性</strong>：SSL 是比较早期的协议，在一些旧的系统和软件中有应用。但随着网络安全标准的提高，现代的应用和系统更倾向于使用 TLS 协议。TLS 在兼容性方面也在不断扩展，能够更好地与各种新的网络技术和应用场景相结合。</li>\n</ul>\n<blockquote>\n<p>目前常用的是 TLS 1.2 和 TLS 1.3;  SSL不多见了</p>\n</blockquote>\n<h2 id=\"https-工作流程\">HTTPS 工作流程</h2>\n<ol>\n<li>Client 发起请求（端口443）</li>\n<li>Server 返回公钥证书</li>\n<li>Client 验证证书</li>\n<li>Client 生成对称密钥，用公钥加密后发给Server</li>\n<li>Server使用私钥解密，得到对称密钥</li>\n<li>C/S双方使用对称密钥：\n<ul>\n<li>加密明文并发送</li>\n<li>解密密文得到明文</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"for-tls-12\">For TLS 1.2</h3>\n<p><img alt=\"Pasted image 20241218204449\" class=\"lazyload\" /><br />\n<img alt=\"Pasted image 20241218211322\" class=\"lazyload\" /></p>\n<h3 id=\"for-tls-13\">For TLS 1.3</h3>\n<p><img alt=\"Pasted image 20241218204507\" class=\"lazyload\" /></p>\n<p><img alt=\"Pasted image 20241218203919\" class=\"lazyload\" /></p>\n<h1 id=\"tls\">TLS</h1>\n<p><img alt=\"Pasted image 20231116112623\" class=\"lazyload\" /></p>\n<h2 id=\"证书签名与验证\">证书签名与验证</h2>\n<p>颁发证书的过程</p>\n<ol>\n<li>撰写<strong>证书元数据</strong>: 包括 <code>签发人(Issuer)</code>, 地址, 签发时间, 有效期 等, 还包括<code>证书持有者(Owner)</code>基本信息, 比如 DN(DNS Name, 即证书生效的域名), <strong>Owner 公钥</strong> 等信息</li>\n<li>使用通用的 Hash 算法（如SHA-256）对证书元数据计算生成<strong>数字摘要</strong></li>\n<li>使用 <strong>签发人 Issuer (CA)的私钥</strong>  对该<strong>数字摘要</strong>进行加密, 生成一个<strong>加密的数字摘要</strong>, 也就是<strong>Issuer的数字签名</strong></li>\n<li>将<strong>数字签名</strong>附加到数字证书上, 变成一个<strong>签过名的数字证书</strong><br />\n将<strong>签过名的数字证书</strong>与 <strong>Issuer (CA)的公钥</strong>, 一同发给证书使用者（注意, 将公钥主动发给使用者是一个形象的说法, 通常系统或者浏览器都内置 Issuer (CA)的公钥 为可信任的根证书）</li>\n</ol>\n<blockquote>\n<p>所以 CA的私钥是绝对不能被泄露, 它作为互联网被信任的基础</p>\n</blockquote>\n<h2 id=\"验证证书的过程\">验证证书的过程</h2>\n<ol>\n<li>证书使用者获通过某种途径（如浏览器访问）获取到该数字证书, 解压后分别获得<strong>证书元数据</strong> 和<strong>数字签名</strong>,<strong>(Owner)的公钥</strong>等</li>\n<li>使用同样的Hash算法计算证书元数据的<strong>数字摘要</strong></li>\n<li>使用 <strong>签发人 Issuer (CA)的公钥</strong> 对数字签名进行解密, 得到 解密后的数字摘要</li>\n</ol>\n<p>从第1步获得的数字摘要值,  再对比 2 和 3 两个步骤得到的数字摘要值; 如果相同, 则说明这个数字证书确实是被 签发人Issuer 验证过合法证书, 证书中的信息</p>\n<blockquote>\n<p>最主要的是确定 Owner 的公钥是可信的, 此后通信 信任使用该公钥解密对方私钥加密的数据</p>\n</blockquote>\n<p><strong>in short 握手时服务端需要提供自己的公钥 和被 ca签发过的数字摘要;  关键在与客户端需要一个可信任 Issuer(CA)</strong></p>\n<h3 id=\"证书链\">证书链</h3>\n<p>在 chrome 证书信息-&gt; 证书路径,  可以看到证书的签发链.</p>\n<p>例, 百度的网站:</p>\n<p><code>GlobalSign Root CA -&gt; GlobalSign Organization Validation CA -&gt; baidu.com</code><br />\n<img alt=\"Pasted image 20231116113047\" class=\"lazyload\" /></p>\n<p>这个路径可以抽象为三个级别:</p>\n<p><code>end-user</code>: 即 baidu.com, 该证书包含百度的公钥, 访问者就是使用该公钥将数据加密后再传输给百度, 即在 HTTPS 中使用的证书</p>\n<p><code>intermediates</code>: 即上文提到的 签发人 Issuer, 用来认证公钥持有者身份的证书, 负责确认 HTTPS 使用的 end-user 证书确实是来源于百度; 这类 intermediates 证书可以有很多级, 也就是说 签发人 Issuer 可能会有有很多级</p>\n<p><code>root</code>: 可以理解为<strong>最高级别的签发人 Issuer, 负责认证<code> intermediates 身份的</code>合法性</strong></p>\n<p><strong>in short 其实就是一个可信任的链条, 最终的目的就是为了保证 end-user 证书是可信的, 该证书的公钥也就是可信的.</strong></p>\n<blockquote>\n<p>参考: <a href=\"https://www.jianshu.com/p/fcd0572c4765\" rel=\"noopener nofollow\" target=\"_blank\">关于证书链的一点认知</a></p>\n</blockquote>\n<h2 id=\"tls-握手步骤\">TLS 握手步骤</h2>\n<p>(0) Client 与 <code>Server</code> 之间建立 (TCP 三次握手) 连接</p>\n<p>(1) Client 向 <code>Server</code> 发送 \"client hello\" 消息, 里面包含了安全相关的信息, 例如<strong>SSL/TLS 版本号</strong>, Client 支持的加密套件 (CipherSuite); \"client hello\" 消息<strong>还包含了一个随机数client random</strong>, 用于通信密钥的计算;<br />\n(可选)SSL/TLS 协议还允许 \"client hello\" 消息包含 Client 所支持的压缩算法</p>\n<p>(2) <code>Server</code> 回复一条 \"server hello\" 消息, 里面包含了加密套件<strong>(Server 从 \"client hello\" 消息的 CipherSuites 列表中选择其中一个)</strong>,<strong>session id</strong> 和 另一个随机数<strong>server random</strong>; Server 还会在消息中<strong>附带自己的数字证书</strong>;</p>\n<p>(可选)<strong>如果 Server 需要 Client 的数字证书进行客户端认证</strong>, 会向 Client 发送 \"client certificate request\" 请求消息, 里面包含了<strong>Server 所支持的证书类型</strong>和<strong>认可的证书颁发机构 CA</strong> (<strong>双向认证</strong>, 同认证客户端同理)</p>\n<p>(3) Client 收到 \"server hello\",<strong>验证 Server 端的数字证书</strong>, 并得到证书中<strong>Server 端的公钥</strong><br />\n<strong>(关键这里客户端有可信任的证书签发者<code>Issuer</code>, 验证服务端的证书)</strong></p>\n<p>(4) Client 向 <code>Server</code> 发送<strong>第三个随机数 pre-master secret</strong>; 与之前不同,<strong>这次的随机数使用了 Server 的公钥加密</strong> (非对称加密); 现在双方同时拥有这三个随机数client random,server random,premaster secret, 可以用来计算生成共同的通信密钥 master secret 用于加密后面传输的业务数据;</p>\n<p>(5 - 可选) 如果收到 <code>Server</code> 端发来的 \"client certificate request\" 请求消息, Client 会向 Server 发送一个使用 Client 自己的私钥加密过的随机数 (暂时记作 secret-A), 附带 Client 的数字证书; 或者发送一个 \"no digital certificate alert\" 无证书警告, 这种情况下基本可以认为 SSL/TLS 握手失败;</p>\n<p>(6 - 可选) <code>Server</code> 验证 Client 发送过来的数字证书, 并得到证书中公钥对 Client 进行身份认证 (通过公钥解密上面那个 secret-A);</p>\n<p>(7) Client 向 <code>Server</code> 发送 \"finished\" 消息, 使用<strong>第 4 步中计算出来的密钥进行加密传输 (对称加密)</strong>, 这表示 Client 端握手阶段已经完成;</p>\n<p>(8) <code>Server</code> 也向 Client 发送 \"finished\" 消息, 使用<strong>第 4 步中计算出来的密钥进行加密传输 (对称加密)</strong>, 这表示 Server 端握手阶段完成;</p>\n<p>(9) SSL/TLS 握手阶段完成, 接下来双方通信的消息都会使用协商出来的密钥进行加密 (对称加密)<br />\nContent Type: Handshake (22)</p>\n<p><img alt=\"SLLhandshanke\" class=\"lazyload\" /></p>\n<p><a href=\"https://www.cnblogs.com/piyeyong/archive/2010/07/02/1770208.html\" target=\"_blank\">证书的应用之一 —— TCP&amp;SSL通信实例及协议分析(中)</a></p>\n<p>每一条消息都会包含有ContentType,Version,HandshakeType等信息;</p>\n<p>ContentType 指示SSL通信处于哪个阶段, 是握手(Handshake), 开始加密传输(ChangeCipherSpec)还是正常通信(Application)等, 见下表</p>\n<table>\n<thead>\n<tr>\n<th>Hex</th>\n<th>Dec</th>\n<th>Type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0x14</td>\n<td>20</td>\n<td>ChangeCipherSpec</td>\n</tr>\n<tr>\n<td>0x15</td>\n<td>21</td>\n<td>Alert</td>\n</tr>\n<tr>\n<td>0x16</td>\n<td>22</td>\n<td>Handshake</td>\n</tr>\n<tr>\n<td>0x17</td>\n<td>23</td>\n<td>Application</td>\n</tr>\n</tbody>\n</table>\n<p>Handshake Type是在handshanke阶段中的具体哪一步, 见下表</p>\n<table>\n<thead>\n<tr>\n<th>Code</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>HelloRequest</td>\n</tr>\n<tr>\n<td>1</td>\n<td>ClientHello</td>\n</tr>\n<tr>\n<td>2</td>\n<td>ServerHello</td>\n</tr>\n<tr>\n<td>11</td>\n<td>Certificate</td>\n</tr>\n<tr>\n<td>12</td>\n<td>ServerKeyExchange</td>\n</tr>\n<tr>\n<td>13</td>\n<td>CertificateRequest</td>\n</tr>\n<tr>\n<td>14</td>\n<td>ServerHelloDone</td>\n</tr>\n<tr>\n<td>15</td>\n<td>CertificateVerify</td>\n</tr>\n<tr>\n<td>16</td>\n<td>ClientKeyExchange</td>\n</tr>\n<tr>\n<td>20</td>\n<td>Finished</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"关于双向认证\">关于双向认证</h3>\n<p>所有通信中，涉及两个端点，即浏览器和它所连接的网站（即客户端和服务器）。 在单向SSL身份认证过程中，仅验证一个端点（服务器）的身份。<br />\n双向认证是指在SSL握手过程中将同时验证客户端和服务器的身份，所以双向认证SSL证书至少包括两个或两个以上的证书，一个是服务器证书，另一个或多个是客户端证书（即个人认证证书）。</p>\n<h1 id=\"主流的证书格式\">主流的证书格式</h1>\n<p><strong>主流的SSL证书格式:</strong><br />\nDER、CER，文件是二进制格式，只保存证书，不保存私钥。</p>\n<p>PEM，一般是文本格式，可保存证书，可保存私钥。<br />\nPrivacy Enhanced Mail，一般为文本格式，以 -----BEGIN... 开头，以 -----END... 结尾。中间的内容是 BASE64 编码。这种格式可以保存证书和私钥，有时我们也把PEM 格式的私钥的后缀改为 .key 以区别证书与私钥</p>\n<p>CRT，可以是二进制格式，可以是文本格式，与 DER 格式相同，不保存私钥。<br />\nPFX P12，二进制格式，同时包含证书和私钥，一般有密码保护。<br />\nJKS，二进制格式，同时包含证书和私钥，一般有密码保护。</p>\n<p><strong>各服务器平台使用的证书格式:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Nginx</th>\n<th>pem</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Apache</td>\n<td>pem</td>\n</tr>\n<tr>\n<td>IIS</td>\n<td>pfx/pkcs12</td>\n</tr>\n<tr>\n<td>Tomcat</td>\n<td>jks</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"netty-for-tls-实例\">Netty For TLS 实例</h1>\n<h2 id=\"证书生成\">证书生成</h2>\n<h3 id=\"ca-根证书生成\">CA 根证书生成</h3>\n<p>或者称为 Issuer , 它可以签发证书, 作为客户端和服务端共同信任者</p>\n<ol>\n<li><strong>创建一个私钥</strong><br />\n生成一个安全的私钥。这个私钥将用于签署根证书以及将来由该根CA签发的所有其他证书。为了确保安全性，使用足够长的密钥长度。</li>\n</ol>\n<pre><code class=\"language-sh\">openssl genpkey -algorithm RSA -out root_ca.key -aes256 -pkeyopt rsa_keygen_bits:4096\n# 不加密\n# openssl genpkey -algorithm RSA -out root_ca.key -pkeyopt rsa_keygen_bits:2048\n</code></pre>\n<blockquote>\n<p>输入私钥密码</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>创建自签名的根证书</strong><br />\n使用刚刚生成的私钥来创建一个自签名的根证书。这一步骤不仅会生成证书本身，还会收集有关颁发者的详细信息，这些信息将嵌入到证书中。</li>\n</ol>\n<pre><code class=\"language-sh\">openssl req -x509 -new -nodes -key root_ca.key -sha256 -days 36500 -out root_ca.crt\n</code></pre>\n<ul>\n<li><code>req</code>&nbsp;是用来处理证书请求的命令。</li>\n<li><code>-x509</code>&nbsp;表示要创建一个X.509格式的自签名证书。</li>\n<li><code>-new</code>&nbsp;表示这是一个新的证书请求。</li>\n<li><code>-nodes</code>&nbsp;表示不加密私钥（仅适用于这次命令，因为私钥已经加密）。</li>\n<li><code>-key root_ca.key</code>&nbsp;指定了用于签名的私钥。</li>\n<li><code>-sha256</code>&nbsp;指定了哈希算法。</li>\n<li><code>-days 3650</code>&nbsp;指定了证书的有效期为10年。</li>\n<li><code>-out root_ca.crt</code>&nbsp;指定了输出文件名为&nbsp;<code>root_ca.crt</code>。</li>\n</ul>\n<p>在运行该命令时，你会被要求填写一系列问题，这些问题的答案将作为证书的主题字段（Subject）的一部分。例如：</p>\n<ul>\n<li><strong>Country Name (2 letter code)</strong>: 输入国家代码，如&nbsp;<code>CN</code>。</li>\n<li><strong>State or Province Name (full name)</strong>: 输入省份或州的全名。</li>\n<li><strong>Locality Name (eg, city)</strong>: 输入城市名。</li>\n<li><strong>Organization Name (eg, company)</strong>: 输入组织名称。</li>\n<li><strong>Organizational Unit Name (eg, section)</strong>: 输入部门名称。</li>\n<li><strong>Common Name (e.g. server FQDN or YOUR name)</strong>: (注意这个) 输入通用名称，通常是组织的域名或描述性名称，对于根证书而言，可以是类似于&nbsp;<code>Root CA</code>&nbsp;的字符串。</li>\n<li><strong>Email Address</strong>: 可选，可以留空。</li>\n</ul>\n<ol start=\"3\">\n<li>验证其内容</li>\n</ol>\n<pre><code class=\"language-sh\">openssl x509 -in root_ca.crt -text -noout\n</code></pre>\n<ol start=\"4\">\n<li>客户端信任</li>\n</ol>\n<p>至此</p>\n<ul>\n<li><code>root_ca.crt</code> 是CA 自签名的带公钥的证书</li>\n<li><code>root_ca.key</code> 是CA的私钥(绝对不能泄露)</li>\n</ul>\n<p>为了让客户端信任这个新创建的根证书，需要将CA公钥安装到目标系统的受信任根证书存储中。<br />\n例如，在Windows上，你可以双击 <code>root_ca.crt</code> 文件，然后按照提示选择“安装证书”，并将安装位置设置为“受信任的根证书颁发机构</p>\n<h3 id=\"ca-签署颁发服务端证书\">CA 签署/颁发服务端证书</h3>\n<ol>\n<li>生成目标实体的私钥</li>\n</ol>\n<pre><code class=\"language-sh\">openssl genpkey -algorithm RSA -out server.key -aes256 -pkeyopt rsa_keygen_bits:2048\n</code></pre>\n<ol start=\"2\">\n<li>生成目标实体的签发请求 (CSR)<br />\n使用刚刚生成的私钥来创建一个证书签名请求（CSR）。CSR包含了申请者的公钥以及一些识别信息，如组织名称、域名等。</li>\n</ol>\n<pre><code class=\"language-sh\">openssl req -new -key server.key -out server.csr\n\n# openssl req -newkey rsa:2048 -nodes -keyout server.key -out server.csr -subj \"/C=CN/ST=State/L=City/O=Organization/CN=your.server.domain\"\n</code></pre>\n<ol start=\"3\">\n<li>使用CA根证书的<strong>私钥</strong> 签署CSR</li>\n</ol>\n<pre><code class=\"language-sh\">openssl x509 -req -in server.csr -CA root_ca.crt -CAkey root_ca.key -CAcreateserial -out server.crt -days 7300 -sha256\n# openssl x509 -req -in server.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out server.crt -days 500 -sha256\n</code></pre>\n<h3 id=\"各文件说明\">各文件说明</h3>\n<p>至此有6个文件分别是:<br />\n1.&nbsp;<strong>root_ca.crt (根CA证书公钥) - 自签名 公开 双方信任</strong></p>\n<ul>\n<li><strong>描述</strong>：这是由CA自身创建并签署的自签名证书，作为信任链的起点。根证书通常包含CA的公钥、名称和其他元数据，并且是由CA私钥签名的</li>\n<li><strong>用途</strong>：根证书用于验证由该CA签发的所有下级证书的真实性。它通常被预装在操作系统、浏览器或其他应用程序的信任库中，作为受信任的根证书机构</li>\n</ul>\n<p>2.&nbsp;<strong>root_ca.key (根CA证书私钥)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是与根CA证书配对的私钥，用于签署其他证书。私钥是高度敏感的信息，不应公开或共享。</li>\n<li><strong>用途</strong>：根CA私钥用于签署中间CA证书、服务器证书、客户端证书等。它是建立信任链的基础。</li>\n<li><strong>安全性</strong>：私钥应存储在安全的地方，最好是在离线环境中，只有在需要签署新证书时才连接到网络。 它一旦被攻破，所有依赖它的证书都将失去信任。</li>\n</ul>\n<p>3.&nbsp;<strong>root_ca.srl (序列号文件)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是一个包含十六进制正整数的文件，用于记录已签发证书的序列号。每次签署新证书时，OpenSSL会从这个文件中读取当前的最大序列号，并为新证书分配一个递增的序列号。</li>\n</ul>\n<p>4.&nbsp;<strong>server.crt (服务器公钥)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是由CA签署的服务器证书，包含服务器的公钥以及关于证书的一些信息，如版本、序列号、签名算法、颁发者、持有者、有效期等。服务器证书用于加密客户端与服务器之间的通信，确保数据传输的安全性。</li>\n<li><strong>用途</strong>：服务器证书安装在Web服务器上，用于HTTPS协议下的安全通信。客户端通过验证服务器证书的有效性来确认服务器的身份，并使用证书中的公钥进行加密通信。</li>\n<li><strong>格式</strong>：常见的格式包括PEM（以&nbsp;<code>-----BEGIN CERTIFICATE-----</code>&nbsp;开头，<code>-----END CERTIFICATE-----</code>&nbsp;结尾）和DER（二进制格式）。Linux系统通常使用&nbsp;<code>.crt</code>&nbsp;文件扩展名，而Windows系统可能使用&nbsp;<code>.cer</code></li>\n</ul>\n<p>5.&nbsp;<strong>server.csr (证书签名请求)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是证书申请者在申请数字证书时生成的文件，包含了公钥和标识名称（Distinguished Name, DN），如国家、省份、城市、组织名称、通用名称（通常是域名）等。CSR是以&nbsp;<code>-----BEGIN CERTIFICATE REQUEST-----</code>&nbsp;开头，<code>-----END CERTIFICATE REQUEST-----</code>&nbsp;结尾的Base64编码格式。</li>\n<li><strong>用途</strong>：CSR文件提交给CA后，CA会使用其根证书私钥对CSR中的信息进行签名，生成正式的数字证书。CSR文件本身不是证书，而是申请证书的请求。</li>\n<li><strong>生成</strong>：CSR文件通常由服务器管理员使用OpenSSL等工具生成，同时生成相应的私钥。生成CSR时，必须确保私钥的安全性，因为CSR文件中不包含私钥</li>\n</ul>\n<p>6.&nbsp;<strong>server.key (服务器私钥)</strong></p>\n<ul>\n<li><strong>描述</strong>：这是与服务器证书配对的私钥，用于解密客户端发送的加密信息。私钥是高度敏感的信息，不应公开或共享。</li>\n<li><strong>用途</strong>：服务器私钥用于解密通过TLS/SSL协议传输的数据。在HTTPS通信中，客户端使用服务器证书中的公钥加密数据，服务器则使用私钥解密这些数据。</li>\n<li><strong>格式</strong>：常见的格式包括PEM（以&nbsp;<code>-----BEGIN RSA PRIVATE KEY-----</code>&nbsp;或&nbsp;<code>-----BEGIN PRIVATE KEY-----</code>&nbsp;开头，<code>-----END RSA PRIVATE KEY-----</code>&nbsp;或&nbsp;<code>-----END PRIVATE KEY-----</code>&nbsp;结尾）和DER（二进制格式）。Linux系统通常使用&nbsp;<code>.key</code>&nbsp;文件扩展名</li>\n</ul>\n<h4 id=\"每个角色验证需要\">每个角色验证需要</h4>\n<ol>\n<li>**客户端需要</li>\n</ol>\n<ul>\n<li><strong><code>root_ca.crt</code></strong>：根 CA 的公钥证书。客户端将使用此证书来验证服务器的证书是否由可信的 CA 签发。</li>\n</ul>\n<ol>\n<li>**服务端端需要</li>\n</ol>\n<ul>\n<li><strong><code>server.key</code></strong>：服务器的私钥。服务器将使用此私钥来解密客户端发送的加密数据，并签署响应。</li>\n<li><strong><code>server.crt</code></strong>：服务器的公钥证书，由根 CA 签发。服务器将使用此证书向客户端证明其身份。</li>\n<li><strong><code>root_ca.crt</code></strong>（可选, 双向验证必选）：如果你的服务器证书是由中间 CA 签发的，你可以将根 CA 证书或中间 CA 证书链一起加载到服务器的信任库中，以便客户端可以验证整个证书链。</li>\n</ul>\n<h2 id=\"在netty-使用\">在Netty 使用</h2>\n<h3 id=\"证书的加载\">证书的加载</h3>\n<ol>\n<li>\n<p>公钥加载  <code>.pem, .crt, .cer</code>  : 通常以&nbsp;<code>-----BEGIN CERTIFICATE-----</code>&nbsp;开头，以&nbsp;<code>-----END CERTIFICATE-----</code>&nbsp;结尾。它既可以包含公钥证书，也可以包含私钥。<strong>Java本身支持 pem</strong></p>\n</li>\n<li>\n<p>私钥加载 <code>.key</code>:  openssl 默认给私钥加密了 , 将其转为不加密的, 可使用 bouncycastle加载之</p>\n</li>\n</ol>\n<pre><code># **转换为 PKCS#8 格式 (PEM 编码)**\nopenssl pkcs8 -topk8 -inform PEM -in server.key -outform PEM -nocrypt -out server_pkcs8.key\n\n# **转换为 PKCS#8 格式 (DER 编码)** 二进制格式\nopenssl pkcs8 -topk8 -inform PEM -in server.key -outform DER -nocrypt -out server_pkcs8.der\n</code></pre>\n<ul>\n<li>使用 bouncycastle 加载 pkcs8 私钥</li>\n</ul>\n<pre><code>implementation(\"cn.hutool:hutool-all:5.8.16\")\nimplementation(\"org.bouncycastle:bcprov-jdk15on:1.70\")\nimplementation(\"org.bouncycastle:bcpkix-jdk15on:1.70\")\n</code></pre>\n<pre><code class=\"language-java\">\n\npublic static void main(String[] args) throws Exception {\n\n\tfinal String ca_cet = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\root_ca.crt\";\n\tfinal String server_crt = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server.crt\";\n\n\tfinal String server_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server.key\";\n\tfinal String server_pkcs8_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server_pkcs8.key\";\n\t\n\tPublicKey root_caKey = PemUtil.readPemPublicKey(FileUtil.getInputStream(ca_cet));\n\tSystem.out.println(\"root_caKey  ==&gt; \"+root_caKey );\n\tCertificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(server_crt));\n\tSystem.out.println(\"X509C  ==&gt; \"+root_caKey );\n\t\n\tPublicKey server_crtKey = PemUtil.readPemPublicKey(FileUtil.getInputStream(server_crt));\n\tSystem.out.println(\"server_crtKey  ==&gt; \"+server_crtKey );\n\n\tPrivateKey privateKey = PemUtil.readPemPrivateKey(FileUtil.getInputStream(server_pkcs8_key));\n\tSystem.out.println(\"server_pkcs8  ==&gt; \"+privateKey );\n}\n</code></pre>\n<ul>\n<li>使用 bouncycastle 如何 加载默认 openssl 加密的 <code>server.key</code> ?</li>\n</ul>\n<pre><code class=\"language-java\">public static PrivateKey loadEncryptedPrivateKeyFromPem(String pemFile, char[] password) throws Exception {\n\ttry (Reader reader = new FileReader(pemFile);\n\t\t PEMParser pemParser = new PEMParser(reader)) {\n\n\t\tObject object = pemParser.readObject();\n\t\tJcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n\n\t\tif (object instanceof PEMEncryptedKeyPair) {\n\t\t\tPEMEncryptedKeyPair encryptedKeyPair = (PEMEncryptedKeyPair) object;\n\t\t\tInputDecryptorProvider decryptorProvider = new JceOpenSSLPKCS8DecryptorProviderBuilder().build(password);\n\t\t\tKeyPair kp = converter.getKeyPair(encryptedKeyPair.decryptKeyPair(decryptorProvider));\n\t\t\treturn kp.getPrivate();\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"Unsupported encrypted key type: \" + object.getClass().getName());\n\t\t}\n\t}\n}\n\n\n</code></pre>\n<h3 id=\"单向验证的tls\">单向验证的TLS</h3>\n<p>客户端单向了验证服务端</p>\n<h4 id=\"服务端\">服务端</h4>\n<pre><code class=\"language-java\">public static void main(String[] args) throws Exception {\n\n\tNioEventLoopGroup boosGroup = new NioEventLoopGroup();\n\tfinal ServerBootstrap serverBootstrap = new ServerBootstrap();\n\tint port = 19977;\n\t// 1. 加载 PEM 私钥,  2.  加载 证书\n\tfinal String server_crt = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server.crt\";\n\tfinal String server_pkcs8_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server_pkcs8.key\";\n\n\tCertificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(server_crt));\n\tPrivateKey privateKey = PemUtil.readPemPrivateKey(FileUtil.getInputStream(server_pkcs8_key));\n\t// 3. 创建 KeyStore 并将私钥和证书添加到其中\n\tKeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n\tkeyStore.load(null, null);\n\tkeyStore.setKeyEntry(\"alias\", privateKey, \"password\".toCharArray(), new Certificate[]{certificate});\n\n\t// 4. 创建 KeyManagerFactory 并初始化\n\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n\tkmf.init(keyStore, \"password\".toCharArray());\n\n\t// 5. 构建 SslContext\n\tfinal SslContext sslContext = SslContextBuilder.forServer(kmf)\n\t\t\t.build();\n\n\tserverBootstrap\n\t\t\t.group(boosGroup)\n\t\t\t.channel(NioServerSocketChannel.class)\n\t\t\t.option(ChannelOption.SO_BACKLOG, 1024)\n\t\t\t.childOption(ChannelOption.SO_KEEPALIVE, true)\n\t\t\t.childOption(ChannelOption.TCP_NODELAY, true)\n\t\t\t.childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() {\n\t\t\t\t@Override\n\t\t\t\tprotected void initChannel(NioSocketChannel ch) {\n\t\t\t\t\t// 添加 SSL/TLS 处理器\n\t\t\t\t\tch.pipeline().addLast(sslContext.newHandler(ch.alloc()));\n\t\t\t\t\tch.pipeline().addLast(new StringDecoder())\n\t\t\t\t\t\t\t.addLast(new StringEncoder())\n\t\t\t\t\t\t\t.addLast(new ServerHandler());\n\t\t\t\t}\n\t\t\t});\n\tChannelFuture f = serverBootstrap.bind(port).addListener(future -&gt; {\n\t\tif (future.isSuccess()) {\n\t\t\tSystem.out.println(new Date() + \": 端口[\" + port + \"]绑定成功!\");\n\t\t} else {\n\t\t\tSystem.err.println(\"端口[\" + port + \"]绑定失败!\");\n\t\t}\n\t});\n\t//下面会进行阻塞, 等待服务器连接关闭之后 main 方法退出, 程序结束;\n\tf.channel().closeFuture().sync();\n}\n</code></pre>\n<h4 id=\"客户端\">客户端</h4>\n<pre><code class=\"language-java\"> public static void main(String[] args) throws Exception {\n \n\tBootstrap bootstrap = new Bootstrap();\n\tNioEventLoopGroup group = new NioEventLoopGroup();\n\n\tString host = \"192.168.20.130\";\n\tint port = 19977;\n\n\t// 1. 加载 CA 证书\n\tfinal String ca_cet = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\root_ca.crt\";\n\tCertificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(ca_cet));\n\n\t// 2. 创建 KeyStore 并将 CA 证书添加到信任库中\n\tKeyStore trustStore = KeyStore.getInstance(\"JKS\");\n\ttrustStore.load(null, null);\n\ttrustStore.setCertificateEntry(\"ca\", certificate);\n\n\t// 3. 创建 TrustManagerFactory 并初始化\n\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\ttmf.init(trustStore);\n\n\t// 4. 构建 SslContext\n\tSslContext build = SslContextBuilder.forClient()\n\t\t\t.trustManager(tmf)\n\t\t\t.build();\n\n\tbootstrap.group(group)\n\t\t\t.channel(NioSocketChannel.class)\n\t\t\t.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 30000)\n\t\t\t.option(ChannelOption.SO_KEEPALIVE, true)\n\t\t\t.handler( new SimpleChannelInboundHandler&lt;String&gt;() {\n\t\t\t\t@Override\n\t\t\t\tprotected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n\t\t\t\t\tSystem.out.println(\"客户端接收: \"+msg);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.connect(host, port).addListener(new ChannelFutureListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void operationComplete(ChannelFuture future) throws Exception {\n\t\t\t\t\tfuture.channel().pipeline()\n\t\t\t\t\t\t\t.addFirst(new StringEncoder())\n\t\t\t\t\t\t\t.addFirst(new StringDecoder())\n\t\t\t\t\t\t\t.addFirst( build.newHandler(future.channel().alloc() ));\n\t\t\t\t\tfinal String helloToServer = \"珠玉买歌笑，糟糠养贤才。方知黄鹄举，千里独徘徊。\"+System.currentTimeMillis();\n\t\t\t\t\tfuture.channel().writeAndFlush(helloToServer);\n\t\t\t\t}\n\t\t\t});\n//        group.shutdownGracefully();\n    }\n\n</code></pre>\n<p>Android 上使用 java.security.KeyStore 时，可能会遇到 KeyStoreException: JKS not found 的错误。这是因为 Android 的安全框架与标准 Java 不同，Android 并不支持 JKS（Java KeyStore）格式。相反，Android 支持其他类型的密钥库，如 BKS（Bouncy Castle KeyStore）和 PKCS12。</p>\n<pre><code class=\"language-java\">private SslContext getSslContext() throws Exception {\n\tCertificate caCert = CertificateUtils.getCertificate();\n\tKeyStore trustStore = KeyStore.getInstance(\"BKS\");  // 使用 BKS 或 PKCS12\n\ttrustStore.load(null, null);\n\ttrustStore.setCertificateEntry(\"ca\", caCert);\n\n\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\ttmf.init(trustStore);\n\n\tSslContext build = SslContextBuilder.forClient()\n\t\t\t.trustManager(tmf)\n\t\t\t.build();\n\treturn build;\n}\n</code></pre>\n<p>抓包看看</p>\n<p><img alt=\"Pasted image 20241219145126\" class=\"lazyload\" /></p>\n<h3 id=\"双向验证的tls\">双向验证的TLS</h3>\n<p>其实同服务端一样的逻辑 1.生成客户端私钥, 2.生成客户端CRS, 3.用CA根证书签发客户端的公钥</p>\n<h4 id=\"客户端证书准备\">客户端证书准备</h4>\n<h5 id=\"生成客户端私钥\"><strong>生成客户端私钥</strong></h5>\n<pre><code>openssl genpkey -algorithm RSA -out client.key -aes256 -pkeyopt rsa_keygen_bits:2048\n</code></pre>\n<p>转换为pkcs#8 格式</p>\n<pre><code>openssl pkcs8 -topk8 -inform PEM -in client.key -outform PEM -nocrypt -out client_pkcs8.key\n</code></pre>\n<h5 id=\"创建客户端的证书签名请求-csr\"><strong>创建客户端的证书签名请求 (CSR)</strong></h5>\n<pre><code>openssl req -new -key client.key -out client.csr\n</code></pre>\n<h5 id=\"使用根-ca-签名客户端的-csr\"><strong>使用根 CA 签名客户端的 CSR</strong></h5>\n<pre><code>openssl x509 -req -in client.csr -CA root_ca.crt -CAkey root_ca.key -CAcreateserial -out client.crt -days 7300 -sha256\n\n</code></pre>\n<h4 id=\"服务端-1\">服务端</h4>\n<pre><code class=\"language-java\">public static void main(String[] args) throws Exception {\n        NioEventLoopGroup boosGroup = new NioEventLoopGroup();\n        final ServerBootstrap serverBootstrap = new ServerBootstrap();\n        int port = 19977;\n        // 1. 加载 PEM 私钥,  2.  加载 证书\n        final String server_crt = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server.crt\";\n        final String server_pkcs8_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\server_pkcs8.key\";\n\n        Certificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(server_crt));\n        PrivateKey privateKey = PemUtil.readPemPrivateKey(FileUtil.getInputStream(server_pkcs8_key));\n        // 3. 创建 KeyStore 并将私钥和证书添加到其中\n        KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n        keyStore.load(null, null);\n        keyStore.setKeyEntry(\"alias\", privateKey, \"password\".toCharArray(), new Certificate[]{certificate});\n\n        // 4. 创建 KeyManagerFactory 并初始化\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        kmf.init(keyStore, \"password\".toCharArray());\n\n        //双向认证 CA根证书\n        final String root_ca = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\root_ca.crt\";\n        X509Certificate caCertificate = (X509Certificate) SecureUtil.readX509Certificate(FileUtil.getInputStream(root_ca));\n\n        // 5. 构建 SslContext\n        final SslContext sslContext = SslContextBuilder.forServer(kmf)\n                .trustManager(caCertificate)\n                .clientAuth(io.netty.handler.ssl.ClientAuth.REQUIRE)//双向认证 &gt; 配置要求客户端也认证\n                .build();\n\n        serverBootstrap\n                .group(boosGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) {\n                        // 添加 SSL/TLS 处理器\n                        ch.pipeline().addLast(sslContext.newHandler(ch.alloc()));\n                        ch.pipeline().addLast(new StringDecoder())\n                                .addLast(new StringEncoder())\n                                .addLast(new ServerHandler());\n                    }\n                });\n        ChannelFuture f = serverBootstrap.bind(port).addListener(future -&gt; {\n            if (future.isSuccess()) {\n                System.out.println(new Date() + \": 端口[\" + port + \"]绑定成功!\");\n            } else {\n                System.err.println(\"端口[\" + port + \"]绑定失败!\");\n            }\n        });\n        //下面会进行阻塞, 等待服务器连接关闭之后 main 方法退出, 程序结束;\n        f.channel().closeFuture().sync();\n    }\n</code></pre>\n<h4 id=\"客户端-1\">客户端</h4>\n<pre><code class=\"language-java\">public static void main(String[] args) throws Exception {\n        Bootstrap bootstrap = new Bootstrap();\n        NioEventLoopGroup group = new NioEventLoopGroup();\n\n        String host = \"192.168.20.130\";\n        int port = 19977;\n\n        // 1. 加载 CA 证书\n        final String ca_cet = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\root_ca.crt\";\n        Certificate certificate = SecureUtil.readX509Certificate(FileUtil.getInputStream(ca_cet));\n\n        // 2. 创建 KeyStore 并将 CA 证书添加到信任库中\n        KeyStore trustStore = KeyStore.getInstance(\"JKS\");\n        trustStore.load(null, null);\n        trustStore.setCertificateEntry(\"ca\", certificate);\n\n        // 3. 创建 TrustManagerFactory 并初始化\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        tmf.init(trustStore);\n\n        // 双向认证 &gt; 客户端证书\n        final String client_crt = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\client.crt\";\n        final String client_pkcs8_key = \"E:\\\\content-for-work\\\\2024-12XXXXAPP\\\\tls_test\\\\client_pkcs8.key\";\n\n        // 4. 构建 SslContext\n        SslContext build = SslContextBuilder.forClient()\n                .keyManager(FileUtil.file(client_crt), FileUtil.file(client_pkcs8_key))\n                .trustManager(tmf)\n                .build();\n\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 30000)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .handler( new SimpleChannelInboundHandler&lt;String&gt;() {\n                    @Override\n                    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n                        System.out.println(\"客户端接收: \"+msg);\n                    }\n                })\n                .connect(host, port).addListener(new ChannelFutureListener() {\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        future.channel().pipeline()\n                                .addFirst(new StringEncoder())\n                                .addFirst(new StringDecoder())\n                                .addFirst( build.newHandler(future.channel().alloc() ));\n                        final String helloToServer = \"珠玉买歌笑，糟糠养贤才。方知黄鹄举，千里独徘徊。\"+System.currentTimeMillis();\n                        future.channel().writeAndFlush(helloToServer);\n                    }\n                });\n//        group.shutdownGracefully();\n    }\n</code></pre>\n<p>最后, 抓包看看</p>\n<p><img alt=\"Pasted image 20241220115443\" class=\"lazyload\" /></p>\n\n</div>\n<div id=\"MySignature\">\n    预防老年痴呆，保持终身学习!    —— <a href=\"https://www.cnblogs.com/dddy/\" target=\"_blank\">daidaidaiyu</a>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-07 21:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/dddy\">daidaidaiyu</a>&nbsp;\n阅读(<span id=\"post_view_count\">139</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "NIVIDIA高性能计算CUDA笔记（四）cuDNN深度神经网络计算库简介及卷积操作示例",
      "link": "https://www.cnblogs.com/GeophysicsWorker/p/19458299",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/GeophysicsWorker/p/19458299\" id=\"cb_post_title_url\" title=\"发布于 2026-01-08 18:18\">\n    <span>NIVIDIA高性能计算CUDA笔记（四）cuDNN深度神经网络计算库简介及卷积操作示例</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        cuDNN，全称为NIVIDIA  CUDA  Deep Neural  Network Library，是深度神经网络算子层级GPU加速库集合，提供了深度学习算法中常见算子的高效实现，\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"nividia高性能计算cuda笔记四\">NIVIDIA高性能计算CUDA笔记（四）</h1>\n<h1 id=\"cudnn深度神经网络计算库简介及卷积操作示例\">cuDNN深度神经网络计算库简介及卷积操作示例</h1>\n<p>​        <span class=\"math inline\">\\(cuDNN\\)</span>，全称为NIVIDIA  CUDA  Deep Neural  Network Library，是深度神经网络算子层级GPU加速库集合，提供了深度学习算法中常见算子的高效实现，专门为深度学习框架（如<span class=\"math inline\">\\(TensorFlow\\)</span>,<span class=\"math inline\">\\(PyTorch\\)</span>,<span class=\"math inline\">\\(Caffe\\)</span>, <span class=\"math inline\">\\(MXNet\\)</span>等）实现常见的神经网络层提供极致的优化的实现 ,所以也直接成为了很多上层推理引擎底层调优的算子备选实现，比如<span class=\"math inline\">\\(TensorRT\\)</span>，比如<span class=\"math inline\">\\(TVM\\)</span>。再换个角度理解，之前在该系列笔记的第一篇提到宗旨“解读介绍英伟达软件生态之CUDA”中介绍了GPU的编程语言<span class=\"math inline\">\\(\\text{CUDA}\\)</span> C“，调用<span class=\"math inline\">\\(\\text{CUDA}\\)</span> C其实就是为了写一些kernel，而这里的<span class=\"math inline\">\\(cuDNN\\)</span> 则是提供一些写好的高效的CUDA C kernel的集合。正如，该系列笔记介绍的<span class=\"math inline\">\\(cuFFT\\)</span>，<span class=\"math inline\">\\(cuBLAS\\)</span> ，区别就在于它们面向的应用场景不同，这里的<span class=\"math inline\">\\(cuDNN\\)</span>就是面向深度神经网络算子的高效实现。</p>\n<p>​</p>\n<h2 id=\"1cudnn的句柄与描述子\">1.cuDNN的句柄与描述子</h2>\n<p>在<span class=\"math inline\">\\(\\text{cuDNN}\\)</span>里，几乎所有操作都需要以下几个基本对象，我们这些基本对象进行描述：</p>\n<h3 id=\"a句柄cudnnhandle_t\">A.句柄（cudnnHandle_t）</h3>\n<p>​        在使用cuDNN进行任何操作之前，需要初始化cuDNN上下文。可以使用<code>cudnnCreate()</code>函数来创建一个cuDNN上下文句柄，后续的所有cuDNN操作都将基于这个句柄进行。句柄(<code>cudnnHandle_t</code>)是cuDNN中一个非常重要的概念，它本质是一个指向<span class=\"math inline\">\\(cuDNN\\)</span>内部状态数据数据结构的指针，句柄的作用类似于“会化ID”，cuDNN通过它识别并管理当前的计算环境，确保所有操作在正确的上下文（如特定GPU设备、资源分配状态等）中执行。</p>\n<p>​       handle是cudnnHandle_t类型的变量的指针。<code>cudnCreate</code> 函数接收这个地址后，就能在函数内部将创建的上下文句柄直接赋值到<code>cudnn</code>变量所在的内存空间，这样在函数调用结束后，外部的<code>handle</code>变量就保存了有效的上下文句柄，供后续操作使用。</p>\n<pre><code class=\"language-C++\">cudnnStatus_t cudnnCreate(cudnnHandle_t *handle);\ncudnnStatus_t cudnnDestroy(cudnnHandle_t handle);\n</code></pre>\n<ul>\n<li><strong>作用</strong>：创建<span class=\"math inline\">\\(\\text{cuDNN}\\)</span>上下文句柄，类似于<span class=\"math inline\">\\(\\text{CUDA runtime}\\)</span>的<span class=\"math inline\">\\(cudaStream\\)</span>。所有操作都依赖它；</li>\n<li><strong>参数</strong>：<span class=\"math inline\">\\(handle\\)</span> 是<span class=\"math inline\">\\(\\text{cuDNN}\\)</span>运行环境的句柄;</li>\n<li><strong>创建与销毁</strong>：句柄通过<code>cudnnCreate()</code>函数创建，在使用完成后，必须通过<code>cudnnDestroy()</code>函数进行销毁，以释放句柄所占用的资源，避免内存泄漏；</li>\n<li><strong>线性安全性</strong>：cuDNN句柄不是线性安全的，每个线程应该使用独立的句柄对象。如果在多个线程环境中使用同一个句柄，可能导致不可预测的错误。因此，在多线程编程时，需要为每个线程单独创建和管理句柄。</li>\n<li><strong>与CUDA上下文的关联</strong>：cuDNN句柄通常是管理GPU资源的基础，cuDNN句柄通过关联的CUDA上下文来访问GPU硬件资源，进行数据传输和计算操作。</li>\n</ul>\n<p><code>cudnnStatus_t</code>是cuDNN所有函数调用的返回状态类型，理解它非常重要，因为它决定了你能否成功调用<span class=\"math inline\">\\(\\text{cuDNN API}\\)</span> 。</p>\n<pre><code class=\"language-c++\">\ntypedef enum {\n    CUDNN_STATUS_SUCCESS = 0,\n    CUDNN_STATUS_NOT_INITIALIZED = 1,\n    CUDNN_STATUS_ALLOC_FAILED = 2,\n    CUDNN_STATUS_BAD_PARAM = 3,\n    CUDNN_STATUS_INTERNAL_ERROR = 4,\n    CUDNN_STATUS_INVALID_VALUE = 5,\n    CUDNN_STATUS_ARCH_MISMATCH = 6,\n    CUDNN_STATUS_MAPPING_ERROR = 7,\n    CUDNN_STATUS_EXECUTION_FAILED = 8,\n    CUDNN_STATUS_NOT_SUPPORTED = 9,\n    CUDNN_STATUS_LICENSE_ERROR = 10,\n    CUDNN_STATUS_RUNTIME_PREREQUISITE_MISSING = 11\n} cudnnStatus_t;\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>枚举值</th>\n<th>含义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>CUDNN_STATUS_SUCCESS</strong></td>\n<td>成功</td>\n<td>调用成功，没有错误</td>\n</tr>\n<tr>\n<td><strong>CUDNN_STATUS_NOT_INITIALIZED</strong></td>\n<td>未初始化</td>\n<td>cuDNN handle 未创建或初始化失败</td>\n</tr>\n<tr>\n<td><strong>CUDNN_STATUS_ALLOC_FAILED</strong></td>\n<td>内存分配失败</td>\n<td>GPU 内存不足，cudaMalloc 失败</td>\n</tr>\n<tr>\n<td><strong>CUDNN_STATUS_BAD_PARAM</strong></td>\n<td>参数错误</td>\n<td>函数参数有误，类型或维度不匹配</td>\n</tr>\n<tr>\n<td><strong>CUDNN_STATUS_INTERNAL_ERROR</strong></td>\n<td>内部错误</td>\n<td>cuDNN 内部执行错误，不是你传的参数问题</td>\n</tr>\n<tr>\n<td><strong>CUDNN_STATUS_INVALID_VALUE</strong></td>\n<td>数值错误</td>\n<td>数值超出范围，例如 stride、padding 不合理</td>\n</tr>\n<tr>\n<td><strong>CUDNN_STATUS_ARCH_MISMATCH</strong></td>\n<td>架构不匹配</td>\n<td>当前 GPU 架构不支持所选算法</td>\n</tr>\n<tr>\n<td><strong>CUDNN_STATUS_MAPPING_ERROR</strong></td>\n<td>内存映射错误</td>\n<td>GPU 内存映射出错</td>\n</tr>\n<tr>\n<td><strong>CUDNN_STATUS_EXECUTION_FAILED</strong></td>\n<td>执行失败</td>\n<td>kernel 执行失败，例如溢出或 cuda kernel 错误</td>\n</tr>\n<tr>\n<td><strong>CUDNN_STATUS_NOT_SUPPORTED</strong></td>\n<td>不支持</td>\n<td>该功能或数据类型不被支持</td>\n</tr>\n<tr>\n<td><strong>CUDNN_STATUS_LICENSE_ERROR</strong></td>\n<td>许可错误</td>\n<td>需要授权许可，但未满足条件</td>\n</tr>\n<tr>\n<td><strong>CUDNN_STATUS_RUNTIME_PREREQUISITE_MISSING</strong></td>\n<td>依赖缺失</td>\n<td>运行时依赖库缺失或版本不匹配</td>\n</tr>\n</tbody>\n</table>\n<p>​     描述符是<span class=\"math inline\">\\(cuDNN\\)</span> 中用于描述各种对象属性的<strong>数据结构</strong>，它为cuDNN函数提供了执行操作所需的元数据信息。cuDNN中存在多种类型的描述符，如张量描述符(<code>cudnnTensorDescriptor_t</code>)，卷积描述符(<code>cudnnConvolutionDescriptor_t</code>)，池化描述符（<code>cudnnPoolingDescriptor_t</code>）等不同类型的描述符用于描述不同的操作。</p>\n<p>​</p>\n<h3 id=\"b张量描述子cudnntensordescriptor_t\">B.张量描述子（cudnnTensorDescriptor_t）</h3>\n<p>​       张量描述符(<code>cudnnTensorDescriptor_t</code>) 用于描述各种对象属性的数据结构，它为cuDNN函数提供了执行操作所需的元数据信息。包括数据张量的（如批量大小、通道数、高度、宽度等）、数据类型（如<code>CUDNN_DATA_FLOAT</code>表示32位浮点数）、张量布局（如<code>CUDNN_TENSOR_NCHW</code>表示数据批量-通道-高度-宽度的布局）。通过<code>cudnnCreateTensorDescriptor()</code> 创建，<code>cudnnSetTensor4dDescriptor()</code>等函数设置属性，<code>cudnnDestroyDescriptor()</code>销毁。</p>\n<pre><code class=\"language-C++\">cudnnStatus_t cudnnCreateTensorDescriptor(cudnnTensorDescriptor_t *tensorDesc);\ncudnnStatus_t cudnnSetTensor4dDescriptor(\n    cudnnTensorDescriptor_t tensorDesc,\n    cudnnTensorFormat_t format,   // NCHW 或 NHWC\n    cudnnDataType_t dataType,     // float, half, double...\n    int n, int c, int h, int w    // 维度\n);\ncudnnStatus_t cudnnDestroyTensorDescriptor(cudnnTensorDescriptor_t tensorDesc);\n</code></pre>\n<p>作用：描述输入、输出张量的维度和数据类型。</p>\n<p>张量在<span class=\"math inline\">\\(cuDNN\\)</span>中通常按照<span class=\"math inline\">\\(\\text{4D格式(N,C,H,W)}\\)</span>（假设NCHW格式）存储：</p>\n<ul>\n<li>N：batch size，代表一批量输入样本的数量；</li>\n<li>C：通道数（例如<span class=\"math inline\">\\(RGB\\)</span>图像就是3个通道；灰度图就是1个通道）；</li>\n<li>H：图像的行数，高度</li>\n<li>W： 图像的列数，宽度</li>\n</ul>\n<p><code>cudnnTensorFormat_t</code>代表张量的格式</p>\n<pre><code class=\"language-C++\">typedef enum {\n    CUDNN_TENSOR_NCHW = 0,      // [batch, channels, height, width]\n    CUDNN_TENSOR_NHWC = 1,      // [batch, height, width, channels]\n    CUDNN_TENSOR_NCHW_VECT_C = 2  // 向量化通道格式 (主要用于部分卷积加速)\n} cudnnTensorFormat_t;\n</code></pre>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\"><strong>枚举值</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>CUDNN_TENSOR_NCHW</strong></td>\n<td>最常用格式，张量按 <code>[N, C, H, W]</code> 存储，适合大多数卷积、批量计算。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>CUDNN_TENSOR_NHWC</strong></td>\n<td>张量按 <code>[N, H, W, C]</code> 存储，在某些 GPU 架构（如 Tensor Core）上可能更快</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>CUDNN_TENSOR_NCHW_VECT_C</strong></td>\n<td>向量化通道存储格式，一般用于卷积加速，通道数必须是 4 的倍数</td>\n</tr>\n</tbody>\n</table>\n<p><code>cudnnDataType_t</code> 是<span class=\"math inline\">\\(\\text{cuDNN}\\)</span>库中用于指定张量数据类型的枚举类型，它定义了深度学习操作中支持的数据格式，包括精度和存储方式。</p>\n<pre><code class=\"language-c\">typedef enum {\n    CUDNN_DATA_FLOAT = 0,       // 32-bit float\n    CUDNN_DATA_DOUBLE = 1,      // 64-bit double\n    CUDNN_DATA_HALF = 2,        // 16-bit float (FP16)\n    CUDNN_DATA_INT8 = 3,        // 8-bit integer\n    CUDNN_DATA_INT32 = 4,       // 32-bit integer\n    CUDNN_DATA_INT8x4 = 5,      // 8-bit integer pack of 4\n    CUDNN_DATA_UINT8 = 6,       // 8-bit unsigned integer\n    CUDNN_DATA_INT8x32 = 7      // 8-bit integer pack of 32\n} cudnnDataType_t;\n</code></pre>\n<p>其枚举值的含义如下：</p>\n<table>\n<thead>\n<tr>\n<th>cudnnDataType_t枚举值</th>\n<th>数据类型</th>\n<th>参数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>CUDNN_DATA_FLOAT</strong></td>\n<td>float32</td>\n<td>最常用数据类型，精度高</td>\n</tr>\n<tr>\n<td><strong>CUDNN_DATA_DOUBLE</strong></td>\n<td>float64</td>\n<td>双精度，GPU 上使用少，性能低</td>\n</tr>\n<tr>\n<td><strong>CUDNN_DATA_HALF</strong></td>\n<td>float16</td>\n<td>半精度，适合 Tensor Core 加速</td>\n</tr>\n<tr>\n<td><strong>CUDNN_DATA_INT8</strong></td>\n<td>int8</td>\n<td>量化神经网络使用</td>\n</tr>\n<tr>\n<td><strong>CUDNN_DATA_INT32</strong></td>\n<td>int32</td>\n<td>常用于累加或输出量化后的结果</td>\n</tr>\n<tr>\n<td><strong>CUDNN_DATA_INT8x4 / INT8x32</strong></td>\n<td>int8 pack</td>\n<td>8-bit 数据打包存储，加速卷积</td>\n</tr>\n<tr>\n<td><strong>CUDNN_DATA_UINT8</strong></td>\n<td>uint8</td>\n<td>无符号 8-bit 数据</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"c卷积描述子cudnnconvolutiondescriptor_t\">C.卷积描述子(cudnnConvolutionDescriptor_t)</h3>\n<p>​     <strong>卷积描述符（cudaConvolutionDescriptor_t)</strong> 用于描述卷积张量操作的参数，如填充大小(pad_h,pad_w)，步长（stride_h,stride_w），dilation（用于空洞卷积）、卷积模式（如<code>CUDNN_CROSS_CORRELATION</code>表示互相关模式，在深度学习中通常等同于卷积操作)。由<code>cudnnCreateConvolutionDescriptor()</code>创建、<code>cudnnSetConvolution2dDescriptor()</code>设置属性，<code>cudnnDestroyConvolutionDescriptor()</code> 销毁。</p>\n<pre><code class=\"language-C\">\ncudnnStatus_t cudnnCreateConvolutionDescriptor(cudnnConvolutionDescriptor_t *convDesc);\ncudnnStatus_t cudnnSetConvolution2dDescriptor(\n    cudnnConvolutionDescriptor_t convDesc,\n    int pad_h, int pad_w,         // 填充\n    int u, int v,                 // 步长 (stride)\n    int dilation_h, int dilation_w,\n    cudnnConvolutionMode_t mode,  // CUDNN_CONVOLUTION or CUDNN_CROSS_CORRELATION\n    cudnnDataType_t computeType   // 计算精度\n);\ncudnnStatus_t cudnnDestroyConvolutionDescriptor(cudnnConvolutionDescriptor_t convDesc);\n</code></pre>\n<p><code>cudnnConvolutionMode_t</code>  是cuDNN库中用于指定卷积操作类型的枚举类型，主要定义两种模式：<strong>标准卷积</strong>和<strong>互相关</strong>。</p>\n<pre><code class=\"language-C++\">typedef enum {\n    CUDNN_CONVOLUTION = 0,           // 标准卷积\n    CUDNN_CROSS_CORRELATION = 1      // 互相关 (默认)\n} cudnnConvolutionMode_t;\n</code></pre>\n<p>其枚举值含义：</p>\n<table>\n<thead>\n<tr>\n<th>枚举值</th>\n<th><strong>含义</strong></th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>CUDNN_CONVOLUTION</strong></td>\n<td>卷积</td>\n<td>卷积核会翻转 180° 再做滑动窗口求和。数学上是标准卷积公式。</td>\n</tr>\n<tr>\n<td><strong>CUDNN_CROSS_CORRELATION</strong></td>\n<td>互相关</td>\n<td>卷积核不翻转，直接在输入上做滑动窗口求和。cuDNN 默认使用这个模式。</td>\n</tr>\n</tbody>\n</table>\n<p>注意：大多数深度学习框架（PyTorch、TensorFlow）默认使用互相关，所以<span class=\"math inline\">\\(\\text{cuDNN}\\)</span>也默认使用<code>CUDNN_CROSS_CORRELATION</code> 。</p>\n<p>​     <strong>过滤器（卷积核）描述子(cudnnFilterDescriptor_t)</strong> 是cuDNN中用于描述卷积滤波器(权重)张量的核心数据类型。它是cuDNN卷积操作中不同或缺的组成部分。由cudnnCreateConvolutionDescriptor()来创建，cudnnSetFilter4dDescriptor()来设置卷积算子，cudnnDestroyFilterDescriptor() 销毁；</p>\n<pre><code class=\"language-C\">cudnnStatus_t cudnnCreateFilterDescriptor(cudnnFilterDescriptor_t *filterDesc);\ncudnnStatus_t cudnnSetFilter4dDescriptor(\n    cudnnFilterDescriptor_t filterDesc,\n    cudnnDataType_t dataType, cudnnTensorFormat_t format,\n    int k, int c, int h, int w\n);\ncudnnStatus_t cudnnDestroyFilterDescriptor(cudnnFilterDescriptor_t filterDesc);\n</code></pre>\n<h3 id=\"d-卷积操作算子cudnnconvolutionforward\">D. 卷积操作算子（cudnnConvolutionForward）</h3>\n<p>计算卷积算子的输出尺寸；</p>\n<pre><code class=\"language-C\">cudnnStatus_t cudnnGetConvolution2dForwardOutputDim(\n    const cudnnConvolutionDescriptor_t convDesc, // 卷积描述子\n    const cudnnTensorDescriptor_t inputTensorDesc, // 输入张量描述子\n    const cudnnFilterDescriptor_t filterDesc,      // 卷积核描述子\n    int* n, int* c, int* h, int* w                 // 输出张量尺寸\n);\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>convDesc</strong></td>\n<td><code>cudnnConvolutionDescriptor_t</code></td>\n<td>卷积参数描述子，包括 padding、stride、dilation、卷积模式等</td>\n</tr>\n<tr>\n<td><strong>inputTensorDesc</strong></td>\n<td><code>cudnnTensorDescriptor_t</code></td>\n<td>输入张量描述子，包含 N、C、H、W 以及数据类型、存储格式</td>\n</tr>\n<tr>\n<td><strong>filterDesc</strong></td>\n<td><code>cudnnFilterDescriptor_t</code></td>\n<td>卷积核描述子，包含 K、C、R、S</td>\n</tr>\n<tr>\n<td><strong>n, c, h, w</strong></td>\n<td><code>int*</code></td>\n<td>输出张量的 <strong>N、C、H、W</strong>，由函数计算后返回</td>\n</tr>\n</tbody>\n</table>\n<p>对于输入尺寸<span class=\"math inline\">\\(H_{in}\\times W_{in}\\)</span> 和卷积核<span class=\"math inline\">\\(R\\times{S}\\)</span>:</p>\n<p></p><div class=\"math display\">\\[\\begin{aligned}\n&amp;H_{out}=\\left[\\frac{H_{in}+2\\cdot pad_h-dilation_h\\cdot(R-1)-1}{2}+1\\right]\\\\\n&amp;W_{out}=\\left[\\frac{W_{out}+2\\cdot pad_h-dilation_w\\cdot(S-1)-1}{2}+1\\right]\n\\end{aligned}\n\\]</div><p></p><p>选择卷积算法：</p>\n<p>调用 cuDNN 核心 API，在 GPU 上执行 3D 卷积计算，结果存储到 GPU 输出内存 d_output 中。</p>\n<pre><code class=\"language-C++\">float alpha = 1.0f, beta = 0.0f;\nCHECK_CUDNN(cudnnConvolutionForward(cudnn, &amp;alpha, inputDesc, d_input, filterDesc, d_filter,convDesc, perfResults.algo, d_workspace, workspace_bytes, &amp;beta, outputDesc, d_output));\n</code></pre>\n<p>alpha=1.0f、beta=0.0f：卷积计算的系数，对应公式：output=α×conv(input,kernel)+β×output</p>\n<p>cudnnConvolutionForward：cuDNN 前向卷积核心 API，参数依次是：<br />\ncuDNN 句柄 → 系数 α → 输入描述符 → GPU 输入数据 → 卷积核描述符 → GPU 卷积核 → 卷积规则描述符 → 最优算法 → 工作空间 → 工作空间大小 → 系数 β → 输出描述符 → GPU 输出数据。</p>\n<h2 id=\"2卷积案例\">2.卷积案例</h2>\n<pre><code class=\"language-c++\">void compute_stride(const int* size, int* stride) {\n    for (int i = 4; i &gt;= 0; i--)\n        stride[i] = (i == 4) ? 1 : size[i + 1] * stride[i + 1];\n}\n\nvoid cudnn_conv_3d(const float* input, const float* kernel,\n    float* output, const int input_dims[3],\n    const int kernel_dims[3]) {\n    // -------------------------- 1. 初始化CUDNN句柄 --------------------------\n    cudnnHandle_t cudnn;\n    CHECK_CUDNN(cudnnCreate(&amp;cudnn));\n\n    // -------------------------- 2. 构造输入张量描述符 --------------------------\n    int inputDims[5] = { 1, 1, input_dims[0], input_dims[1], input_dims[2] }; // N=1, C=1, D/H/W\n    int input_stride[5];\n    compute_stride(inputDims, input_stride);\n\n    cudnnTensorDescriptor_t inputDesc;\n    CHECK_CUDNN(cudnnCreateTensorDescriptor(&amp;inputDesc));\n    CHECK_CUDNN(cudnnSetTensorNdDescriptor(inputDesc, CUDNN_DATA_FLOAT, 5, inputDims, input_stride));\n\n\n    // -------------------------- 3. 构造卷积核描述符 --------------------------\n    int filterDims[5] = { 1, 1, kernel_dims[0], kernel_dims[1], kernel_dims[2] }; // 输出通道=1, 输入通道=1, 核尺寸\n    cudnnFilterDescriptor_t filterDesc;\n    CHECK_CUDNN(cudnnCreateFilterDescriptor(&amp;filterDesc));\n    CHECK_CUDNN(cudnnSetFilterNdDescriptor(filterDesc, CUDNN_DATA_FLOAT, CUDNN_TENSOR_NCHW, 5, filterDims));\n\n    // -------------------------- 4. 计算SAME填充并构造卷积描述符 --------------------------\n    int conmv_padA[3];\n    for (int i = 0; i &lt; 3; i++) {\n        conmv_padA[i] = (kernel_dims[i] - 1) / 2; // 计算SAME填充\n    }\n    int conv_filterStrideA[3] = { 1, 1, 1 };       // 步长=1\n    int conv_dilationA[3] = { 1, 1, 1 };           // 膨胀=1\n\n    cudnnConvolutionDescriptor_t convDesc;\n    CHECK_CUDNN(cudnnCreateConvolutionDescriptor(&amp;convDesc));\n    CHECK_CUDNN(cudnnSetConvolutionNdDescriptor(convDesc, 3, conmv_padA, conv_filterStrideA,\n        conv_dilationA, CUDNN_CROSS_CORRELATION, CUDNN_DATA_FLOAT));\n\n\n    // -------------------------- 5. 计算输出张量尺寸并构造描述符 --------------------------\n    int outputDims[5];\n    CHECK_CUDNN(cudnnGetConvolutionNdForwardOutputDim(convDesc, inputDesc, filterDesc, 5, outputDims));\n    int output_stride[5];\n    compute_stride(outputDims, output_stride);\n\n    cudnnTensorDescriptor_t outputDesc;\n    CHECK_CUDNN(cudnnCreateTensorDescriptor(&amp;outputDesc));\n    CHECK_CUDNN(cudnnSetTensorNdDescriptor(outputDesc, CUDNN_DATA_FLOAT, 5, outputDims, output_stride));\n\n    // -------------------------- 6. 选取最优卷积算法 --------------------------\n    size_t in_bytes, out_bytes;\n    CHECK_CUDNN(cudnnGetTensorSizeInBytes(inputDesc, &amp;in_bytes));\n    CHECK_CUDNN(cudnnGetTensorSizeInBytes(outputDesc, &amp;out_bytes));\n\n    size_t filt_bytes = 1;\n    for (int i = 0; i &lt; 5; i++) filt_bytes *= filterDims[i];\n    filt_bytes *= sizeof(float);\n\n    // 获取最优卷积算法\n    int returnedAlgoCount = 0;\n    cudnnConvolutionFwdAlgoPerf_t perfResults;\n    CHECK_CUDNN(cudnnGetConvolutionForwardAlgorithm_v7(cudnn, inputDesc, filterDesc, convDesc, outputDesc,\n        1, &amp;returnedAlgoCount, &amp;perfResults));\n\n    // 计算工作空间大小\n    size_t workspace_bytes = 0;\n    CHECK_CUDNN(cudnnGetConvolutionForwardWorkspaceSize(cudnn, inputDesc, filterDesc, convDesc, outputDesc,\n        perfResults.algo, &amp;workspace_bytes));\n\n\n    // -------------------------- 7. 分配设备内存并拷贝数据 --------------------------\n    float* d_input = nullptr, * d_filter = nullptr, * d_output = nullptr;\n    void* d_workspace = nullptr;\n\n    CHECK_CUDA(cudaMalloc((void**)&amp;d_input, in_bytes));\n    CHECK_CUDA(cudaMalloc((void**)&amp;d_filter, filt_bytes));\n    CHECK_CUDA(cudaMalloc((void**)&amp;d_output, out_bytes));\n\n\n    if (workspace_bytes &gt; 0) {\n        CHECK_CUDA(cudaMalloc((void**)&amp;d_workspace, workspace_bytes));\n    }\n\n    // 主机到设备拷贝\n    CHECK_CUDA(cudaMemcpy(d_input, input, in_bytes, cudaMemcpyHostToDevice));\n    CHECK_CUDA(cudaMemcpy(d_filter, kernel, filt_bytes, cudaMemcpyHostToDevice));\n\n    // -------------------------- 8. 执行卷积计算 --------------------------\n    float alpha = 1.0f, beta = 0.0f;\n    CHECK_CUDNN(cudnnConvolutionForward(cudnn, &amp;alpha, inputDesc, d_input, filterDesc, d_filter,\n        convDesc, perfResults.algo, d_workspace, workspace_bytes,\n        &amp;beta, outputDesc, d_output));\n\n    // -------------------------- 9. 设备到主机拷贝输出 --------------------------\n    CHECK_CUDA(cudaMemcpy(output, d_output, out_bytes, cudaMemcpyDeviceToHost));\n\n    // -------------------------- 10. 资源释放 --------------------------\n    CHECK_CUDA(cudaFree(d_input));\n    CHECK_CUDA(cudaFree(d_filter));\n    CHECK_CUDA(cudaFree(d_output));\n    CHECK_CUDA(cudaFree(d_workspace));\n\n    CHECK_CUDNN(cudnnDestroyTensorDescriptor(outputDesc));\n    CHECK_CUDNN(cudnnDestroyConvolutionDescriptor(convDesc));\n    CHECK_CUDNN(cudnnDestroyFilterDescriptor(filterDesc));\n    CHECK_CUDNN(cudnnDestroyTensorDescriptor(inputDesc));\n    CHECK_CUDNN(cudnnDestroy(cudnn));\n}\n</code></pre>\n<pre><code class=\"language-C++\">#define _CRT_SECURE_NO_WARNINGS\n\n#include \"rscudaalgo.h\"\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n#include \"fundamental.h\"\n#include \"segy.h\"\n#include \"alloc.h\"\n#include \"qdebug.h\"\n\n//测试三维卷积\nvoid test_conv3d() {\n\n\tconst char* filename_input = \"smallCube.sgy\";   //输入文件名\n\tconst char* filename_output = \"conv_small.sgy\";            //输出文件名\n\n\tFILE* fp_input = nullptr;                                 //输入文件的文件指针\n\tFILE* fp_output = nullptr;                                 //输出文件的文件指针\n\n\tbhed fileheader;                                           //定义文件头\n\tsegy* traceheader_array = nullptr;                                 //道头数组指针\n\n\tfloat* datacube_input = nullptr;                        //输入地震数据的三维指针\n\tfloat* datacube_output = nullptr;                       //输出地震数据的三维指针\n\n\tunsigned int size_fileheader = sizeof(fileheader);\n\tunsigned int size_traceheader = sizeof(segy);\n\n\tunsigned int nline = 0;                                        //三维地震数据的测线数\n\tunsigned int ncdp = 0;                                        //三维地震数据的CDP数\n\tunsigned int nt = 0;                                         //三维地震数据的时间采样数\n\tlong long ntrace = 0;\n\tlong long size_inputcube = 0;\n\tlong long size_trace = 0;\n\t\n\tnline = 100;\n\tncdp = 500;\n\n\tfp_input = fopen(filename_input, \"rb\");\n\tif (fp_input == nullptr) {\n\t\tprintf(\"Cannot open this input file!!!\\n\");\n\t\tqDebug() &lt;&lt; \"Cannot open this input file!!!\\n\";\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}//end if(fp_input==nullptr)\n\n\tfp_output = fopen(filename_output, \"wb\");\n\tif (fp_output == nullptr) {\n\t\tprintf(\"Cannot open\\create this output file!!!\\n\");\n        qDebug() &lt;&lt; \"Cannot open\\create this output file!!!\\n\";\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}//end if(fp_output==nullptr)\n\n\t/*判断地震数据是否为规则的*/\n\tfread(&amp;fileheader, size_fileheader, 1, fp_input);\n\tnt = fileheader.hns;\n\n\tsize_trace = size_traceheader + nt * sizeof(float);\n\t_fseeki64(fp_input, 0, SEEK_END);\n\tsize_inputcube = _ftelli64(fp_input);\n\tntrace = (size_inputcube - size_fileheader) / (size_trace);\n\t_fseeki64(fp_input, size_fileheader, SEEK_SET);\n\n\tif (ntrace != (nline * ncdp)) {\n\t\tprintf(\"Cube is not regularized!!!\\n\");\n\t\treturn;\n\t}\n\n\t/*读取规则的地震数据体及处理，输出*/\n\tint input_dims[3] = { nline, ncdp, nt };\n\tint nAllSize = input_dims[0] * input_dims[1] * input_dims[2];\n\tdatacube_input = new float[nAllSize];\n\tmemset(datacube_input, 0, nAllSize * sizeof(float));\n\ttraceheader_array = (segy*)calloc(nline * ncdp, size_traceheader);\n\tdatacube_output = new float[nAllSize];\n\tmemset(datacube_output, 0, nline * ncdp * nt * sizeof(float));\n\n\tfor (int iline = 0; iline &lt; nline; iline++) {   //读取三维地震属性体\n\t\tfor (int icdp = 0; icdp &lt; ncdp; icdp++) {\n\t\t\tint nIndex = (iline * ncdp + icdp) * nt;\n\t\t\t//printf(\"iline=%d,icdp=%d,nIndex=%d\\n\", iline, icdp, nIndex);\n\t\t\tfread(&amp;traceheader_array[iline * ncdp + icdp], size_traceheader, 1, fp_input);\n\t\t\tfread(&amp;datacube_input[nIndex], nt * sizeof(float), 1, fp_input);\n\t\t}//end for(int icdp = 0; icdp &lt; ncdp;icdp++)\n\t}//end for(int iline = 0; iline &lt; nline; iline++)\n\n\tint cube2_dims[3] = { 21,21,21 };\n\tint nCube2Size = cube2_dims[0] * cube2_dims[1] * cube2_dims[2];\n\tfloat* pCube2 = new float[nCube2Size];\n\tmemset(pCube2, 0, sizeof(float) * nCube2Size);\n\tgetCube2(cube2_dims[0], cube2_dims[1], cube2_dims[2], pCube2);\n\n\t//开始计时\n\tclock_t start_clock, end_clock;\n\tstart_clock = clock();\n\n\t// 初始化输入数据（主机到设备）\n\t// -------------------------- 8. 执行卷积并计时 --------------------------\n\tcudnn_conv_3d(datacube_input, pCube2, datacube_output, input_dims, cube2_dims);\n\n\t//结束计时\n\tend_clock = clock();\n\tdouble endtime = (double)(end_clock - start_clock) / CLOCKS_PER_SEC;\n\tstd::cout &lt;&lt; \"Total time:\" &lt;&lt; endtime &lt;&lt; \" s\" &lt;&lt; std::endl;\t//ms为单位\n\tqDebug() &lt;&lt; \"Total time:\" &lt;&lt; endtime &lt;&lt; \" s\" &lt;&lt; endl;\n\n\tfwrite(&amp;fileheader, size_fileheader, 1, fp_output);\n\tfor (int iline = 0; iline &lt; nline; iline++) {   //写出三维地震属性体\n\t\tfor (int icdp = 0; icdp &lt; ncdp; icdp++) {\n\t\t\tint nIndex = (iline * ncdp + icdp) * nt;\n\t\t\tfwrite(&amp;traceheader_array[iline * ncdp + icdp], size_traceheader, 1, fp_output);\n\t\t\tfwrite(&amp;datacube_output[nIndex], nt * sizeof(float), 1, fp_output);\n\t\t}//end for(int icdp = 0; icdp &lt; ncdp;icdp++)\n\t}//end for(int iline = 0; iline &lt; nline; iline++)\n\n\t// -------------------------- 9. 释放资源 --------------------------\n\tfclose(fp_input);\n\tfclose(fp_output);\n\n\tdelete[]datacube_input;\n\tdelete[]datacube_output;\n\n\tfree(traceheader_array);\n}\n\nint main() {\n\n\ttest_conv3d();\n\n    return 0;\n}\n\n</code></pre>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-08 18:18</span>&nbsp;\n<a href=\"https://www.cnblogs.com/GeophysicsWorker\">GeoFXR</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}