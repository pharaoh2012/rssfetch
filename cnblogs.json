{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "从0构建 3D GIF动画，看清计算机运行机制",
      "link": "https://www.cnblogs.com/reasa/p/19529889",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/reasa/p/19529889\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 15:39\">\n    <span>从0构建 3D GIF动画，看清计算机运行机制</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"从0构建-3d-gif动画看清计算机运行机制\">从0构建 3D GIF动画，看清计算机运行机制</h1>\n<p>在<a href=\"https://www.cnblogs.com/reasa/p/19521361\" target=\"_blank\">《从 0 构建 WAV 文件》</a>中，我们通过了解wav文件的结构与格式，学会了如何用朴素的方式构建声音文件；在<a href=\"https://www.cnblogs.com/reasa/p/19525923\" target=\"_blank\">《从 2D 转 3D 的本质》</a>中，我们领悟了游戏中所谓三维世界，不过是简单的投影。</p>\n<p>今天我们将了解一个更加复杂但有趣的文件格式-GIF，在了解其本质的同时，我们将不依赖任何庞大的图形库（如 OpenGL、DirectX）或图像库（如 OpenCV、ImageMagick），仅凭 <strong>C++ 标准库</strong>，完成上一篇文章用python实现的旋转立方体并以GIF文件的方式呈现出来。</p>\n<p>我们将进一步加深对计算机本质的理解：<strong>一切复杂的表象，归根结底都是“数学计算”与“数据存储”的结合。</strong></p>\n<h2 id=\"1-gif文件结构\">1. GIF文件结构</h2>\n<p>相比于 WAV 文件的简单粗暴，GIF 的结构要精密得多，因为它天生是为了网络传输而设计的（包含了压缩机制）。</p>\n<p>当我们用二进制视角观察 GIF 时，它是由一个个 <strong>数据块（Block）</strong> 组成的：</p>\n<p><img alt=\"\" src=\"https://www.techug.com/wordpress/wp-content/uploads/2017/06/680728-641be6583b65382d.png\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">数据块 (Block Name)</th>\n<th style=\"text-align: left;\">中文名称</th>\n<th style=\"text-align: left;\">字节数 (Bytes)</th>\n<th style=\"text-align: left;\">作用与核心逻辑</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><strong>Header</strong></td>\n<td style=\"text-align: left;\">头标识</td>\n<td style=\"text-align: left;\">6</td>\n<td style=\"text-align: left;\">一般为 <code>GIF89a</code>，当然也有<code>GIF87a</code>,用于声明这是一个GIF文件，采用xx标准。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Logical Screen Descriptor</strong></td>\n<td style=\"text-align: left;\">逻辑屏幕描述符</td>\n<td style=\"text-align: left;\">7</td>\n<td style=\"text-align: left;\"><strong>画布设定</strong>：定义图像总宽高、背景色索引及是否使用全局调色板。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Global Color Table</strong></td>\n<td style=\"text-align: left;\">全局颜色表</td>\n<td style=\"text-align: left;\">3 × N</td>\n<td style=\"text-align: left;\"><strong>颜料盘</strong>：存储 RGB 颜色（如 <code>00 FF 00</code>），N 为颜色数（最大256）。 默认使用RGB颜色时，每个颜色均采用3个字节存储</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Application Extension</strong></td>\n<td style=\"text-align: left;\">应用程序扩展</td>\n<td style=\"text-align: left;\">19 (通常)</td>\n<td style=\"text-align: left;\">最常用的是 Netscape 扩展，用于“循环播放次数”。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Graphic Control Extension</strong></td>\n<td style=\"text-align: left;\">图形控制扩展</td>\n<td style=\"text-align: left;\">8</td>\n<td style=\"text-align: left;\"><strong>播放控制</strong>：定义每一帧的<strong>延迟时间</strong>（动画快慢）和透明色。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Image Descriptor</strong></td>\n<td style=\"text-align: left;\">图像描述符</td>\n<td style=\"text-align: left;\">10</td>\n<td style=\"text-align: left;\"><strong>帧属性</strong>：定义当前这一帧在画布上的位置（x, y）和尺寸。</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Image Data</strong></td>\n<td style=\"text-align: left;\">图像数据</td>\n<td style=\"text-align: left;\">可变</td>\n<td style=\"text-align: left;\">用处如其名</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Trailer</strong></td>\n<td style=\"text-align: left;\">结束标识</td>\n<td style=\"text-align: left;\">1</td>\n<td style=\"text-align: left;\"><strong>终点</strong>：固定为 <code>0x3B</code> (分号)，标志文件彻底结束。</td>\n</tr>\n</tbody>\n</table>\n<p>其中，最重要的就是图像数据了，其他的块用于规定这些图像数据应当如何呈现到我们眼中或是告知文件的开始结束，因此对于我们来说，其他块基本上都有固定模板，只有图像数据需要我们自己定义。</p>\n<h2 id=\"2lzw-gif强制使用的图像压缩算法\">2.LZW-GIF强制使用的图像压缩算法</h2>\n<p>搞定了GIF的文件结构，接下来就需要我们解决另一个拦路虎，LZW——一个经典的无损图像压缩算法，为了解决他，我们可以从他的原理入手。</p>\n<p>LZW通过为复杂数据构建简单索引来减少存储的数据量，这一点是朴素的哈希算法，当然，这一算法的发明者通过一套特殊的规则使得其他人可以直接通过索引数据反推出复杂数据，而在GIF中，则是GIF发明公司将他所规定的规则写好，编写GIF的人根据这一套规则构建数据，然后其他人直接使用套用了这一套规则的解码器解码，便能将数据还原成原来的样子。</p>\n<p>GIF的解码器又是如何读取数据的呢？解码器初始时一次性读取9位数据，然后从字典中添加这一对应关系，根据GIF规范，一旦字典里的条目达到 512 个，解码器就会自动将读取位宽从 9 位增加到 10 位。如果我们直接存放数据，那么结果就是数据读取错位，解码出来的内容就会与我们想象中的不一样，如果我们想要让他的数据读取正常，通常做法就是：我们构建一个同步状态机，即模拟GIF解码器读取数据的过程写入数据，构建一个字典，以相同的标准增加写入位宽，从而让解码器读取时能正确读取。但是这一过程看着就十分繁琐，能不能用一个简单的方法来让解码器正常读取数据呢？</p>\n<h2 id=\"3解决方案\">3.解决方案</h2>\n<p>GIF 协议中有一个特殊的指令叫 <strong>Clear Code（清除代码，值为256）</strong>。它的作用是告诉解码器：“嘿，把之前的字典都忘了吧，我们重新开始。”</p>\n<p>利用这一点，我们可以在代码中采用了一种偷鸡的策略：</p>\n<ol>\n<li>我们不尝试去寻找复杂的重复模式。</li>\n<li>我们每写入一小段像素（例如 125 个），就立刻发送一个 <strong>Clear Code</strong>。</li>\n<li>这强制让 LZW 字典始终处于“初始状态”。在初始状态下，LZW 的编码就等同于直接输出像素的颜色索引值。</li>\n</ol>\n<p>现在，让我们来实现他</p>\n<h2 id=\"4-构建3d立方体\">4. 构建3d立方体</h2>\n<p>在上一篇关于 3D 本质的文章中，我们推导出了两个核心公式。在这个程序中，我们将直接把它们转化为 C++ 代码。</p>\n<h3 id=\"旋转公式\">旋转公式</h3>\n<p>为了让立方体动起来，我们需要每一帧都改变顶点的 <span class=\"math inline\">\\((x, y, z)\\)</span> 坐标。这里使用旋转矩阵的简化版：</p>\n<pre><code class=\"language-cpp\">Point3D rotate(Point3D p, float angle) {\n    // 绕 Y 轴旋转\n    float nx = p.x * cos(angle) - p.z * sin(angle);\n    float nz = p.x * sin(angle) + p.z * cos(angle);\n    // 绕 X 轴微调旋转，让旋转看起来更立体\n    float ny = p.y * cos(angle * 0.8f) - nz * sin(angle * 0.8f);\n    nz = p.y * sin(angle * 0.8f) + nz * cos(angle * 0.8f);\n    return {nx, ny, nz};\n}\n</code></pre>\n<h3 id=\"投影公式透视\">投影公式（透视）</h3>\n<p>如何把 3D 坐标变成屏幕上的像素点？记得那个核心法则吗？<strong>“近大远小，本质就是除以 Z”。</strong></p>\n<pre><code class=\"language-cpp\">pair&lt;int, int&gt; project(Point3D p, int W, int H) {\n    float fov = 160.0f;        // 视野系数\n    float viewer_dist = 4.0f;  // 眼睛离物体的距离\n    // 核心逻辑：除以 (z + dist)\n    float factor = fov / (viewer_dist + p.z);\n    return { (int)(p.x * factor + W / 2), (int)(p.y * factor + H / 2) };\n}\n</code></pre>\n<p>有了这两个函数，我们就能在内存里的一个二维数组（<code>vector&lt;u8&gt; pixels</code>）上画线了。</p>\n<h3 id=\"手写-gif-编码器\">手写 GIF 编码器</h3>\n<p>我们实现了一个极简的编码器（<code>struct GifBitStream</code>）。它的工作是把像素点的颜色索引（0或1）打包成变长的二进制码流。</p>\n<pre><code class=\"language-cpp\">// GIF 的数据存储不仅是字节，还需要处理“位操作”\n// 比如写入一个 9-bit 的代码，可能跨越两个字节\nstruct GifBitStream {\n    vector&lt;u8&gt; byteData;\n    u32 bitBuffer = 0;\n    int bitCount = 0;\n\n    void writeCode(u32 code, int size) {\n        // 将数据移位并存入缓冲区...\n        // 凑够8位就写入 byteData\n    }\n    // ...\n};\n</code></pre>\n<h3 id=\"特别说明绕过lzw的问题\">特别说明：绕过LZW的问题</h3>\n<p>生成的GIF没有压缩，体积较为大</p>\n<h2 id=\"4-完整代码\">4. 完整代码</h2>\n<p>下面是完整的 C++ 代码：</p>\n<ol>\n<li><strong>计算</strong>：旋转 3D 点 -&gt; 投影成 2D 点。</li>\n<li><strong>绘图</strong>：在内存的黑板上画线（Bresenham 直线算法）。</li>\n<li><strong>编码</strong>：将内存的黑板按照 GIF 协议压缩并写入文件。</li>\n</ol>\n<p><em>(代码较长，建议直接复制编译运行，感受生成的快感)</em></p>\n<pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define u8 uint8_t\n#define u16 uint16_t\n#define u32 uint32_t\nstruct Point3D { \n    float x, y, z; \n};\nstruct Edge { \n    int u, v; \n};\nPoint3D rotate(Point3D p, float angle) {\n    float nx = p.x * cos(angle) - p.z * sin(angle);\n    float nz = p.x * sin(angle) + p.z * cos(angle);\n    float ny = p.y * cos(angle * 0.8f) - nz * sin(angle * 0.8f);\n    nz = p.y * sin(angle * 0.8f) + nz * cos(angle * 0.8f);\n    return {nx, ny, nz};\n}\npair&lt;int, int&gt; project(Point3D p, int W, int H) {\n    float fov = 160.0f; \n    float viewer_dist = 4.0f;\n    float factor = fov / (viewer_dist + p.z);\n    return { (int)(p.x * factor + W / 2), (int)(p.y * factor + H / 2) };\n}\n\ninline void drawLine(vector&lt;u8&gt;&amp; buffer, int W, int H, int x0, int y0, int x1, int y1) {\n    int dx = abs(x1 - x0), sx = x0 &lt; x1 ? 1 : -1;\n    int dy = -abs(y1 - y0), sy = y0 &lt; y1 ? 1 : -1;\n    int err = dx + dy;\n    while (true) {\n        if (x0 &gt;= 0 &amp;&amp; x0 &lt; W &amp;&amp; y0 &gt;= 0 &amp;&amp; y0 &lt; H) buffer[y0 * W + x0] = 1;\n        if (x0 == x1 &amp;&amp; y0 == y1) break;\n        int e2 = 2 * err;\n        if (e2 &gt;= dy) { err += dy; x0 += sx; }\n        if (e2 &lt;= dx) { err += dx; y0 += sy; }\n    }\n}\n// --- GIF 二进制协议部分 ---\nstruct GifBitStream {\n    vector&lt;u8&gt; byteData;\n    u32 bitBuffer = 0;\n    int bitCount = 0;\n\n    // 写入指定位宽的代码\n    inline void writeCode(u32 code, int size) {\n        bitBuffer |= (code &lt;&lt; bitCount);\n        bitCount += size;\n        while (bitCount &gt;= 8) {\n            byteData.push_back(bitBuffer &amp; 0xFF);\n            bitBuffer &gt;&gt;= 8;\n            bitCount -= 8;\n        }\n    }\n    inline void flush(ofstream&amp; f) {\n        if (bitCount &gt; 0) byteData.push_back(bitBuffer &amp; 0xFF);\n        // GIF 规定：数据必须切成每块最大 255 字节的小块\n        for (size_t i = 0; i &lt; byteData.size(); i += 255) {\n            u8 blockSize = (u8)min((size_t)255, byteData.size() - i);\n            f.put(blockSize);\n            f.write((char*)&amp;byteData[i], blockSize);\n        }\n        f.put(0); // 块结束\n    }\n};\ninline void writeWord(ofstream&amp; f, u16 v) { \n    f.put(v &amp; 0xFF); \n    f.put((v &gt;&gt; 8) &amp; 0xFF); \n}\ninline void writeGifFrame(ofstream&amp; f, const vector&lt;u8&gt;&amp; pixels, int W, int H) {\n    // 1. 图形控制扩展 (帧间隔)\n    f.put(0x21); \n    f.put(0xF9); \n    f.put(0x04);\n    f.put(0x09);       // 属性：还原背景，不使用透明\n    writeWord(f, 4);   // 延迟 40ms (1/25 FPS)\n    f.put(0); \n    f.put(0);\n\n    // 2. 图像描述符\n    f.put(0x2C);\n\n    // 偏移\n    writeWord(f, 0); \n    writeWord(f, 0); \n\n    // 宽高\n    writeWord(f, W); \n    writeWord(f, H); \n    f.put(0x00);\n\n    // 3. 数据\n    f.put(0x08); // 8位色\n    GifBitStream stream;\n\n    const int ClearCode = 256; //清空指令\n    const int EOICode = 257;\n    stream.writeCode(ClearCode, 9); // 清空解码器字典\n    int pixCount = 0;\n    for (u8 p : pixels) {\n        stream.writeCode(p, 9);\n        pixCount++;\n        //每 125 个像素重置一次字典，保证位宽不变，不会提前读取到下一个字节\n        if (pixCount == 125) {\n            stream.writeCode(ClearCode, 9); \n            pixCount = 0;\n        }\n    }\n    stream.writeCode(EOICode, 9); // 结束\n    stream.flush(f);\n}\nsigned main(int argc,char* argv[]){\n    const int W = 200, H = 200;\n    ofstream f(\"cube_perfect.gif\", ios::binary); //以二进制方式写入GIF文件\n\n    // [Header] \n    f &lt;&lt; \"GIF89a\";//89a 标准\n\n    // [Logical Screen Descriptor]\n    writeWord(f, W); writeWord(f, H);\n    f.put(0xF7); // 开启全局调色板 (256色)\n    f.put(0); \n    f.put(0);\n\n    // [Global Color Table]全局调色板\n\n    // 0: 背景黑\n    f.put(0); \n    f.put(0); \n    f.put(0);    \n\n    // 1: 极客绿\n    f.put(0); \n    f.put(255); \n    f.put(0);     \n\n    //只用到两种颜色，其余填充黑色\n    for(int i = 2; i &lt; 256; i++){ \n        f.put(0); f.put(0); f.put(0); \n    }\n\n    // [Netscape Loop] 循环动画扩展\n    f.put(0x21); // Netscape块标识\n    f.put(0xFF); // 扩展类型标识\n    f.put(0x0B); // 信息长度\n    f &lt;&lt; \"NETSCAPE2.0\"; //应用程序信息\n    f.put(0x03); // 数据长度，到结束符前\n    f.put(0x01); //索引\n    writeWord(f, 0);  //无限循环，不停止\n    f.put(0); //结束符\n\n    // 3D 立方体点数据\n    vector&lt;Point3D&gt; verts = {\n        {-1,-1,1}, {1,-1,1}, {1,1,1}, {-1,1,1},\n        {-1,-1,-1}, {1,-1,-1}, {1,1,-1}, {-1,1,-1}\n    };\n    vector&lt;Edge&gt; edges = {\n        {0,1},{1,2},{2,3},{3,0}, {4,5},{5,6},{6,7},{7,4}, {0,4},{1,5},{2,6},{3,7}\n    };\n\n    cout &lt;&lt; \"Encoding 3D Cube to GIF...\" &lt;&lt; endl;\n    for (int i = 0; i &lt; 60; i++) { // 60帧动画\n        vector&lt;u8&gt; pixels(W * H, 0); // 黑色背景\n        float angle = i * 0.12f; // 每1/60s旋转角度\n\n        vector&lt;pair&lt;int, int&gt;&gt; p2d; \n        for (auto v : verts) \n            p2d.push_back(project(rotate(v, angle), W, H)); // 3D-&gt;2D投影\n        for (auto e : edges) \n            drawLine(pixels, W, H, p2d[e.u].first, p2d[e.u].second, p2d[e.v].first, p2d[e.v].second); // 画边\n\n        writeGifFrame(f, pixels, W, H); // 写入帧数据\n        cout &lt;&lt; \".\";\n    }\n\n    f.put(0x3B); // 文件结束符\n    f.close(); //关闭\n\n    cout &lt;&lt; \"\\nSuccess! Open 'cube_perfect.gif' in Chrome/Edge.\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>运行这段代码，你会惊讶地发现目录下多了一个 <code>cube_perfect.gif</code>。用浏览器打开它，一个绿色的线框立方体正在黑色的背景中流畅地旋转。</p>\n<h2 id=\"5-打通认知的任督二脉\">5. 打通认知的“任督二脉”</h2>\n<p>回顾这个系列的三篇文章，我们其实只做了一件事：<strong>祛魅（Demystification）</strong>。</p>\n<ol>\n<li><strong>WAV 篇</strong>：我们发现声音文件只是记录振幅的二进制队列，没有任何魔法。</li>\n<li><strong>3D 篇</strong>：我们发现那些酷炫的 3D 游戏，底层只是初中几何的“相似三角形”运算。</li>\n<li><strong>GIF 篇（本文）</strong>：我们将数学运算的结果（3D），按照文件协议（二进制），封装成了人类可见的动画。</li>\n</ol>\n<p>这就是计算机科学最迷人的地方。无论是生成一段 440Hz 的正弦波，还是渲染《黑神话：悟空》中复杂的场景，其本质都是一样的：</p>\n<p><strong>Input（数据） + Rules（算法/格式） = Output（数字世界）</strong></p>\n<p>当你能够徒手写出一个 WAV，徒手推导出一个 3D 投影，徒手拼装出一个 GIF 时，你就不再只是一个 API 的调用者，你开始成为一个真正的创造者。代码的荒原上，只要你掌握了规则，你就是上帝。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 15:39</span>&nbsp;\n<a href=\"https://www.cnblogs.com/reasa\">reasa</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(不成功方案的分析)",
      "link": "https://www.cnblogs.com/lulight/p/19529821",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19529821\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 15:26\">\n    <span>【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(不成功方案的分析)</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>问题描述</h1>\n<p>在先前的四篇博文</p>\n<p>1：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19523829\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-23 19:12\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案三)</a>&nbsp;</p>\n<p>2：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19514101\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-21 21:19\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案二)</a>&nbsp;</p>\n<p>3：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19503730\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-19 21:09\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案一)&nbsp;</a>&nbsp;</p>\n<p>4：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19495544\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-17 11:54\">【Azure APIM】如何解决后端API服务配置自签名证书时APIM请求报错500：Error occured while calling backend service</a>&nbsp;</p>\n<p>5：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19479238\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-13 21:08\">【Azure 环境】在Windows环境中使用OpenSSL生成自签名证书链步骤分享</a></p>\n<p>我们分别介绍了使用OpenSSL生成自签名证书，然后解决APIM服务对自签名证书的信任问题。不论是APIM托管的网关，还是自建的网关都可以通过安装证书后使得请求受信任，通过配置API跳过证书验证环节。</p>\n<p>在方案三中，开始从自建网关本身AKS POD”方面入手，通过配置 SSL_CERT_FILE 环境变量，来安装自签名证书 （根证书和中间证书）到POD中解决问题。</p>\n<p>除了以上三种方案的情况下：在AKS集群的官方文档中，说可以直接更新集群，把自定义证书颁发机构（CA）向节点的信任存储添加多达 10 个 base64 编码的证书。</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"340\" width=\"666\" /></p>\n<p>所以，基于这个文档，本文尝试了第四种方案：使用&nbsp;az aks update&nbsp;&nbsp;--custom-ca-trust-certificates 证书命令</p>\n<p>&nbsp;</p>\n<h1>方案步骤</h1>\n<h2>准备步骤：准备好中间证书和根证书合并一起的 .crt 内容</h2>\n<p>导出方法：通过浏览器导出中间证书+根证书的 crt 文件，其内容是 Base64 编码</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"289\" width=\"666\" /></p>\n<p>&nbsp;</p>\n<h2>第一步：把准备好的证书传递到AKS集群</h2>\n<p>因aks集群已经创建好，所以使用 az aks update 指令</p>\n<blockquote>\n<pre><code class=\"code-line\" dir=\"auto\">az aks update \\\n    --resource-group &lt;resource-group-name&gt; \\\n    --name &lt;cluster-name&gt; \\\n    --custom-ca-trust-certificates &lt;path-to-certificate-file&gt;</code></pre>\n</blockquote>\n<p>执行截图</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"285\" width=\"666\" /></p>\n<h2>第二步：验证自签名CA证书是否在节点中正常工作</h2>\n<div>\n<div>1：使用&nbsp;kubectl get nodes ，列出节点名称</div>\n<div>2：进入节点debug模式：使用&nbsp;kubectl debug node/&lt;节点名&gt; -it --image=mcr.azk8s.cn/aks/fundamental/base-ubuntu:v0.0.11， 如：kubectl debug node/<em>aks-agentpool-20066971-vmss00000j</em> -it --image=mcr.azk8s.cn/aks/fundamental/base-ubuntu:v0.0.11</div>\n<div>3：使用 chroot /host 命令，把操作目录从当前容器环境 切换到 节点操作环境</div>\n<div>4：对比访问两个不同自签名CA证书的URL</div>\n<div>&nbsp;</div>\n<div>操作结果截图：</div>\n<div>\n<p><img alt=\"image\" class=\"lazyload\" height=\"256\" width=\"666\" /></p>\n<p>&nbsp;</p>\n</div>\n<h2>第三步：访问APIM的自建网关请求，自签名证书依旧不被信任。</h2>\n<p>&nbsp;</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"271\" width=\"666\" /></p>\n<p>为什么呢？把自签名的根证书，中间证书都安装到AKS集群中了，为何使用debug模式就可以信任这个自签名证书，而 APIM Self-hosted gateway pod却不可以呢？</p>\n</div>\n<h1>疑问解答</h1>\n<p>Debug pod 之所以能信任，是因为它用的是通用 Ubuntu 基础镜像，走的是系统 CA bundle；</p>\n<p>APIM Self‑hosted Gateway 用的是微软封装的网关容器 + .NET TLS 验证路径，完全不看 node 的 CA。</p>\n<p>这一点在 AKS 官方文档中是明确写清楚的：“Certificates added to the AKS node trust store aren’t available to containers running in pods.”&nbsp;</p>\n<p>AKS Node 安装 CA，只对 Node 生效，对 Pod 无效。 这一点，在文章开头的官方文档截图中，也特别提醒。只是，最开始没有正确理解这句话的意义！</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"334\" width=\"666\" /></p>\n<p>&nbsp;</p>\n<p>所以，如果要解决APIM 中自签名CA证书的信任问题。目前验证下来，只有三种方式：</p>\n<p>1：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19503730\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-19 21:09\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案一)&nbsp;</a>&nbsp;</p>\n<p>2：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19514101\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-21 21:19\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案二)</a>&nbsp;</p>\n<p>3：<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19523829\" id=\"cb_post_title_url\" target=\"_blank\" title=\"发布于 2026-01-23 19:12\">【Azure APIM】APIM的自建网关如何解决自签名证书的受信任问题呢？(方案三)</a>&nbsp;</p>\n<p>&nbsp;</p>\n<p><em>[完]&nbsp;</em></p>\n<p>&nbsp;</p>\n<h1>参考资料</h1>\n<p id=\"use-custom-certificate-authorities-cas-in-azure-kubernetes-service-aks\">在 Azure Kubernetes 服务（AKS）中使用自定义证书颁发机构（CA） ：<a href=\"https://docs.azure.cn/zh-cn/aks/custom-certificate-authority\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.azure.cn/zh-cn/aks/custom-certificate-authority</a></p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\">\n    <div style=\"background: #1c5f55; height: 36px; width: 618px; padding: 14px 5px 0px 3px;\">\n  <p style=\"font-weight: bold; color: white;\">当在复杂的环境中面临问题，格物之道需：浊而静之徐清，安以动之徐生。 云中，恰是如此!</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 15:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lulight\">编码者卢布</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "如何使用 GitHub Actions + image-syncer 实现 Docker Hub 到 Azure ACR 的自动化镜像同步",
      "link": "https://www.cnblogs.com/newbe36524/p/19529772",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/newbe36524/p/19529772\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 15:12\">\n    <span>如何使用 GitHub Actions + image-syncer 实现 Docker Hub 到 Azure ACR 的自动化镜像同步</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"实现-docker-hub-到-azure-acr-的自动化镜像同步\">实现 Docker Hub 到 Azure ACR 的自动化镜像同步</h1>\n<blockquote>\n<p>本文介绍了如何使用 GitHub Actions 和 image-syncer 工具，实现 Docker Hub 镜像到 Azure Container Registry 的自动化同步，解决了国内及部分 Azure 区域访问 Docker Hub 速度慢的问题，提升了镜像的可用性和 Azure 环境的部署效率。</p>\n</blockquote>\n\n<h2 id=\"背景引言\">背景/引言</h2>\n<p>HagiCode 项目使用 Docker 镜像作为核心运行时组件，主要镜像托管在 Docker Hub。随着项目发展和 Azure 环境部署需求的增加，我们遇到了以下痛点：</p>\n<ul>\n<li>镜像拉取速度慢，Docker Hub 在国内及部分 Azure 区域访问受限</li>\n<li>依赖单一镜像源存在单点故障风险</li>\n<li>Azure 环境下使用 Azure Container Registry 能获得更好的网络性能和集成体验</li>\n</ul>\n<p>为解决这些问题，我们需要建立一个自动化的镜像同步机制，将 Docker Hub 的镜像定期同步到 Azure ACR，确保用户能够在 Azure 环境中获得更快的镜像拉取速度和更高的可用性。</p>\n<h2 id=\"关于-hagicode\">关于 HagiCode</h2>\n<p>我们正在开发 HagiCode——一款 AI 驱动的代码智能助手，让开发体验变得更智能、更便捷、更有趣。</p>\n<p>智能——AI 全程辅助，从想法到代码，让编码效率提升数倍。便捷——多线程并发操作，充分利用资源，开发流程顺畅无阻。有趣——游戏化机制和成就系统，让编码不再枯燥，充满成就感。</p>\n<p>项目正在快速迭代中，如果你对技术写作、知识管理或者 AI 辅助开发感兴趣，欢迎来 GitHub 看看。</p>\n<h2 id=\"技术方案对比\">技术方案对比</h2>\n<p>在制定解决方案时，我们对比了多种技术方案：</p>\n<h3 id=\"1-image-syncer最终选择\">1. image-syncer（最终选择）</h3>\n<ul>\n<li>增量同步：仅同步变更的镜像层，显著减少网络传输</li>\n<li>断点续传：网络中断后可恢复同步</li>\n<li>并发控制：支持配置并发线程数，提升大镜像同步效率</li>\n<li>完善的错误处理：内置失败重试机制（默认 3 次）</li>\n<li>轻量级部署：单二进制文件，无依赖</li>\n<li>多仓库支持：兼容 Docker Hub、Azure ACR、Harbor 等</li>\n</ul>\n<h3 id=\"2-docker-cli\">2. Docker CLI</h3>\n<ul>\n<li>不支持增量同步：每次都需要拉取完整的镜像内容</li>\n<li>效率较低：网络传输量大，时间长</li>\n<li>简单易用：使用熟悉的 docker pull/push 命令</li>\n</ul>\n<h3 id=\"3-azure-cli\">3. Azure CLI</h3>\n<ul>\n<li>复杂度高：需要配置 Azure CLI 认证</li>\n<li>功能限制：az acr import 功能相对单一</li>\n<li>原生集成：与 Azure 服务集成良好</li>\n</ul>\n<h2 id=\"架构设计决策\">架构设计决策</h2>\n<h3 id=\"决策-1同步频率设置为每日-utc-0000\">决策 1：同步频率设置为每日 UTC 00:00</h3>\n<ul>\n<li>平衡镜像新鲜度和资源消耗</li>\n<li>避开业务高峰期，减少对其他操作的影响</li>\n<li>Docker Hub 镜像通常在每日构建后更新</li>\n</ul>\n<h3 id=\"决策-2同步所有镜像标签\">决策 2：同步所有镜像标签</h3>\n<ul>\n<li>保持与 Docker Hub 的完全一致性</li>\n<li>为用户提供灵活的版本选择</li>\n<li>简化同步逻辑，避免复杂的标签过滤规则</li>\n</ul>\n<h3 id=\"决策-3使用-github-secrets-存储认证信息\">决策 3：使用 GitHub Secrets 存储认证信息</h3>\n<ul>\n<li>GitHub Actions 原生支持，安全性高</li>\n<li>配置简单，易于管理和维护</li>\n<li>支持仓库级别的访问控制</li>\n</ul>\n<h2 id=\"风险评估与缓解\">风险评估与缓解</h2>\n<h3 id=\"风险-1azure-acr-认证信息泄露\">风险 1：Azure ACR 认证信息泄露</h3>\n<ul>\n<li>使用 GitHub Secrets 加密存储</li>\n<li>定期轮换 ACR 密码</li>\n<li>限制 ACR 用户权限为仅推送</li>\n<li>监控 ACR 访问日志</li>\n</ul>\n<h3 id=\"风险-2同步失败导致镜像不一致\">风险 2：同步失败导致镜像不一致</h3>\n<ul>\n<li>image-syncer 内置增量同步机制</li>\n<li>自动失败重试（默认 3 次）</li>\n<li>详细的错误日志和失败通知</li>\n<li>断点续传功能</li>\n</ul>\n<h3 id=\"风险-3资源消耗过大\">风险 3：资源消耗过大</h3>\n<ul>\n<li>增量同步减少网络传输</li>\n<li>可配置并发线程数（当前设置为 10）</li>\n<li>监控同步的镜像数量和大小</li>\n<li>在非高峰时段运行同步</li>\n</ul>\n<h2 id=\"核心解决方案\">核心解决方案</h2>\n<p>我们采用 GitHub Actions + image-syncer 的自动化方案，实现从 Docker Hub 到 Azure ACR 的镜像同步。</p>\n<h2 id=\"实施步骤\">实施步骤</h2>\n<h3 id=\"1-准备阶段\">1. 准备阶段</h3>\n<ul>\n<li>在 Azure Portal 中创建或确认 Azure Container Registry</li>\n<li>创建 ACR 访问密钥（用户名和密码）</li>\n<li>确认 Docker Hub 镜像仓库访问权限</li>\n</ul>\n<h3 id=\"2-配置-github-secrets\">2. 配置 GitHub Secrets</h3>\n<p>在 GitHub 仓库设置中添加以下 Secrets：</p>\n<ul>\n<li>AZURE_ACR_USERNAME: Azure ACR 用户名</li>\n<li>AZURE_ACR_PASSWORD: Azure ACR 密码</li>\n</ul>\n<h3 id=\"3-创建-github-actions-工作流\">3. 创建 GitHub Actions 工作流</h3>\n<p>在 .github/workflows/sync-docker-acr.yml 中配置工作流：</p>\n<ul>\n<li>定时触发：每天 UTC 00:00</li>\n<li>手动触发：支持 workflow_dispatch</li>\n<li>额外触发：publish 分支推送时触发（用于快速同步）</li>\n</ul>\n<h3 id=\"4-工作流执行流程\">4. 工作流执行流程</h3>\n<div class=\"mermaid\">sequenceDiagram\n    participant GH as GitHub Actions\n    participant IS as image-syncer\n    participant DH as Docker Hub\n    participant ACR as Azure ACR\n\n    Note over GH: 触发工作流\n    GH-&gt;&gt;IS: 下载并执行 image-syncer\n    IS-&gt;&gt;DH: 获取镜像 manifest 和标签列表\n    DH--&gt;&gt;IS: 返回镜像元数据\n    IS-&gt;&gt;ACR: 获取已存在的镜像信息\n    ACR--&gt;&gt;IS: 返回目标镜像信息\n    IS-&gt;&gt;IS: 对比差异，识别变更的镜像层\n    Note over IS: 增量同步：仅传输变更的镜像层\n    IS-&gt;&gt;DH: 拉取变更的镜像层\n    DH--&gt;&gt;IS: 返回镜像层内容\n    IS-&gt;&gt;ACR: 推送变更的镜像层到 ACR\n    ACR--&gt;&gt;IS: 返回推送结果\n    IS--&gt;&gt;GH: 返回同步统计信息\n    GH-&gt;&gt;GH: 记录同步日志并上传 artifact\n</div><h2 id=\"github-actions-工作流实现\">GitHub Actions 工作流实现</h2>\n<p>以下是实际运行的工作流配置（.github/workflows/sync-docker-acr.yml）：</p>\n<pre><code class=\"language-yaml\">name: Sync Docker Image to Azure ACR\n\non:\n  schedule:\n    - cron: \"0 0 * * *\" # 每天 UTC 00:00\n  workflow_dispatch: # 手动触发\n  push:\n    branches: [publish]\n\npermissions:\n  contents: read\n\njobs:\n  sync:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Download image-syncer\n        run: |\n          # 下载 image-syncer 二进制文件\n          wget https://github.com/AliyunContainerService/image-syncer/releases/download/v1.5.5/image-syncer-v1.5.5-linux-amd64.tar.gz\n          tar -zxvf image-syncer-v1.5.5-linux-amd64.tar.gz\n          chmod +x image-syncer\n\n      - name: Create auth config\n        run: |\n          # 生成认证配置文件 (YAML 格式)\n          cat &gt; auth.yaml &lt;&lt;EOF\n          hagicode.azurecr.io:\n            username: \"${{ secrets.AZURE_ACR_USERNAME }}\"\n            password: \"${{ secrets.AZURE_ACR_PASSWORD }}\"\n          EOF\n\n      - name: Create images config\n        run: |\n          # 生成镜像同步配置文件 (YAML 格式)\n          cat &gt; images.yaml &lt;&lt;EOF\n          docker.io/newbe36524/hagicode: hagicode.azurecr.io/hagicode\n          EOF\n\n      - name: Run image-syncer\n        run: |\n          # 执行同步 (使用新版 --auth 和 --images 参数)\n          ./image-syncer --auth=./auth.yaml --images=./images.yaml --proc=10 --retries=3\n\n      - name: Upload logs\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: sync-logs\n          path: image-syncer-*.log\n          retention-days: 7\n</code></pre>\n<h2 id=\"配置说明\">配置说明</h2>\n<h3 id=\"1-触发条件\">1. 触发条件</h3>\n<ul>\n<li>定时触发：cron: \"0 0 * * *\" - 每天 UTC 00:00 执行</li>\n<li>手动触发：workflow_dispatch - 允许用户在 GitHub UI 手动运行</li>\n<li>推送触发：push: branches: [publish] - 发布分支推送时触发（用于快速同步）</li>\n</ul>\n<h3 id=\"2-认证配置-authyaml\">2. 认证配置 (auth.yaml)</h3>\n<pre><code class=\"language-yaml\">hagicode.azurecr.io:\n  username: \"${{ secrets.AZURE_ACR_USERNAME }}\"\n  password: \"${{ secrets.AZURE_ACR_PASSWORD }}\"\n</code></pre>\n<h3 id=\"3-镜像同步配置\">3. 镜像同步配置</h3>\n<pre><code class=\"language-yaml\">docker.io/newbe36524/hagicode: hagicode.azurecr.io/hagicode\n</code></pre>\n<p>此配置表示将 docker.io/newbe36524/hagicode 的所有标签同步到 hagicode.azurecr.io/hagicode</p>\n<h3 id=\"4-image-syncer-参数\">4. image-syncer 参数</h3>\n<ul>\n<li>--auth=./auth.yaml: 认证配置文件路径</li>\n<li>--images=./images.yaml: 镜像同步配置文件路径</li>\n<li>--proc=10: 并发线程数为 10</li>\n<li>--retries=3: 失败重试 3 次</li>\n</ul>\n<h2 id=\"github-secrets-配置清单\">GitHub Secrets 配置清单</h2>\n<p>在 GitHub 仓库的 Settings → Secrets and variables → Actions 中配置：</p>\n<table>\n<thead>\n<tr>\n<th>Secret 名称</th>\n<th>描述</th>\n<th>示例值</th>\n<th>获取方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AZURE_ACR_USERNAME</td>\n<td>Azure ACR 用户名</td>\n<td>hagicode</td>\n<td>Azure Portal → ACR → Access keys</td>\n</tr>\n<tr>\n<td>AZURE_ACR_PASSWORD</td>\n<td>Azure ACR 密码</td>\n<td>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</td>\n<td>Azure Portal → ACR → Access keys → Password</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"使用说明\">使用说明</h2>\n<h3 id=\"1-手动触发同步\">1. 手动触发同步</h3>\n<ol>\n<li>访问 GitHub 仓库的 Actions 标签页</li>\n<li>选择 Sync Docker Image to Azure ACR 工作流</li>\n<li>点击 Run workflow 按钮</li>\n<li>选择分支并点击 Run workflow 确认</li>\n</ol>\n<h3 id=\"2-查看同步日志\">2. 查看同步日志</h3>\n<ol>\n<li>在 Actions 页面点击具体的工作流运行记录</li>\n<li>查看各个步骤的执行日志</li>\n<li>在页面底部的 Artifacts 区域下载 sync-logs 文件</li>\n</ol>\n<h3 id=\"3-验证同步结果\">3. 验证同步结果</h3>\n<pre><code class=\"language-bash\"># 登录到 Azure ACR\naz acr login --name hagicode\n\n# 列出镜像及其标签\naz acr repository show-tags --name hagicode --repository hagicode --output table\n</code></pre>\n<h2 id=\"注意事项和最佳实践\">注意事项和最佳实践</h2>\n<h3 id=\"1-安全建议\">1. 安全建议</h3>\n<ul>\n<li>定期轮换 Azure ACR 密码（建议每 90 天）</li>\n<li>使用专用的 ACR 服务账户，限制权限为仅推送</li>\n<li>监控 ACR 的访问日志，及时发现异常访问</li>\n<li>不要在日志中输出认证信息</li>\n<li>不要将认证信息提交到代码仓库</li>\n</ul>\n<h3 id=\"2-性能优化\">2. 性能优化</h3>\n<ul>\n<li>调整 --proc 参数：根据网络带宽调整并发数（建议 5-20）</li>\n<li>监控同步时间：如果同步时间过长，考虑减少并发数</li>\n<li>定期清理日志：设置合理的 retention-days（当前为 7 天）</li>\n</ul>\n<h3 id=\"3-故障排查\">3. 故障排查</h3>\n<h4 id=\"问题-1认证失败\">问题 1：认证失败</h4>\n<pre><code>Error: failed to authenticate to hagicode.azurecr.io\n</code></pre>\n<p>解决方案：</p>\n<ol>\n<li>检查 GitHub Secrets 是否正确配置</li>\n<li>验证 Azure ACR 密码是否过期</li>\n<li>确认 ACR 服务账户权限是否正确</li>\n</ol>\n<h4 id=\"问题-2网络超时\">问题 2：网络超时</h4>\n<pre><code>Error: timeout waiting for response\n</code></pre>\n<p>解决方案：</p>\n<ol>\n<li>检查网络连接</li>\n<li>减少并发线程数（--proc 参数）</li>\n<li>等待网络恢复后重新触发工作流</li>\n</ol>\n<h4 id=\"问题-3镜像同步不完整\">问题 3：镜像同步不完整</h4>\n<pre><code>Warning: some tags failed to sync\n</code></pre>\n<p>解决方案：</p>\n<ol>\n<li>检查同步日志，识别失败的标签</li>\n<li>手动触发工作流重新同步</li>\n<li>验证 Docker Hub 源镜像是否正常</li>\n</ol>\n<h3 id=\"4-监控和告警\">4. 监控和告警</h3>\n<ul>\n<li>定期检查 Actions 页面，确认工作流运行状态</li>\n<li>设置 GitHub 通知，及时获取工作流失败通知</li>\n<li>监控 Azure ACR 的存储使用情况</li>\n<li>定期验证镜像标签一致性</li>\n</ul>\n<h2 id=\"常见问题和解决方案\">常见问题和解决方案</h2>\n<h3 id=\"q1-如何同步特定标签而不是所有标签\">Q1: 如何同步特定标签而不是所有标签？</h3>\n<p>修改 images.yaml 配置文件：</p>\n<pre><code class=\"language-yaml\"># 仅同步 latest 和 v1.0 标签\ndocker.io/newbe36524/hagicode:latest: hagicode.azurecr.io/hagicode:latest\ndocker.io/newbe36524/hagicode:v1.0: hagicode.azurecr.io/hagicode:v1.0\n</code></pre>\n<h3 id=\"q2-如何同步多个镜像仓库\">Q2: 如何同步多个镜像仓库？</h3>\n<p>在 images.yaml 中添加多行配置：</p>\n<pre><code class=\"language-yaml\">docker.io/newbe36524/hagicode: hagicode.azurecr.io/hagicode\ndocker.io/newbe36524/another-image: hagicode.azurecr.io/another-image\n</code></pre>\n<h3 id=\"q3-同步失败后如何重试\">Q3: 同步失败后如何重试？</h3>\n<ul>\n<li>自动重试：image-syncer 内置重试机制（默认 3 次）</li>\n<li>手动重试：在 GitHub Actions 页面点击 Re-run all jobs</li>\n</ul>\n<h3 id=\"q4-如何查看同步的详细进度\">Q4: 如何查看同步的详细进度？</h3>\n<ul>\n<li>在 Actions 页面查看实时日志</li>\n<li>下载 sync-logs artifact 查看完整日志文件</li>\n<li>日志文件包含每个标签的同步状态和传输速度</li>\n</ul>\n<h3 id=\"q5-同步需要多长时间\">Q5: 同步需要多长时间？</h3>\n<ul>\n<li>首次全量同步：根据镜像大小，通常需要 10-30 分钟</li>\n<li>增量同步：如果镜像变更小，通常 2-5 分钟</li>\n<li>时间取决于网络带宽、镜像大小和并发设置</li>\n</ul>\n<h2 id=\"扩展功能建议\">扩展功能建议</h2>\n<h3 id=\"1-添加同步通知\">1. 添加同步通知</h3>\n<p>在工作流中添加通知步骤：</p>\n<pre><code class=\"language-yaml\">- name: Notify on success\n  if: success()\n  run: |\n    echo \"Docker images synced successfully to Azure ACR\"\n</code></pre>\n<h3 id=\"2-实现镜像标签过滤\">2. 实现镜像标签过滤</h3>\n<p>在工作流中添加标签过滤逻辑：</p>\n<pre><code class=\"language-yaml\">- name: Filter tags\n  run: |\n    # 仅同步以 v 开头的标签\n    echo \"docker.io/newbe36524/hagicode:v* : hagicode.azurecr.io/hagicode:v*\" &gt; images.yaml\n</code></pre>\n<h3 id=\"3-添加同步统计报告\">3. 添加同步统计报告</h3>\n<pre><code class=\"language-yaml\">- name: Generate report\n  if: always()\n  run: |\n    echo \"## Sync Report\" &gt;&gt; $GITHUB_STEP_SUMMARY\n    echo \"- Total tags: $(grep -c 'synced' image-syncer-*.log)\" &gt;&gt; $GITHUB_STEP_SUMMARY\n    echo \"- Sync time: ${{ steps.sync.outputs.duration }}\" &gt;&gt; $GITHUB_STEP_SUMMARY\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>通过本文介绍的方法，我们成功实现了从 Docker Hub 到 Azure ACR 的自动化镜像同步。这个方案利用 GitHub Actions 的定时触发和手动触发功能，结合 image-syncer 的增量同步和错误处理机制，确保了镜像的及时同步和一致性。</p>\n<p>我们还讨论了安全最佳实践、性能优化、故障排查等方面的内容，帮助用户更好地管理和维护这个同步机制。希望本文能够为需要在 Azure 环境中部署 Docker 镜像的开发者提供有价值的参考。</p>\n<h2 id=\"参考资料\">参考资料</h2>\n<ul>\n<li><a href=\"https://github.com/HagiCode-org/site\" rel=\"noopener nofollow\" target=\"_blank\">HagiCode 项目 GitHub 仓库</a></li>\n<li><a href=\"https://github.com/AliyunContainerService/image-syncer\" rel=\"noopener nofollow\" target=\"_blank\">image-syncer 官方文档</a></li>\n<li><a href=\"https://learn.microsoft.com/zh-cn/azure/container-registry/\" rel=\"noopener nofollow\" target=\"_blank\">Azure Container Registry 官方文档</a></li>\n<li><a href=\"https://docs.github.com/zh-cn/actions\" rel=\"noopener nofollow\" target=\"_blank\">GitHub Actions 官方文档</a></li>\n</ul>\n<hr />\n<h2 id=\"互动引导\">互动引导</h2>\n<p>感谢您的阅读,如果您觉得本文有用,快点击下方点赞按钮👍,让更多的人看到本文。</p>\n<h2 id=\"ai-辅助声明\">AI 辅助声明</h2>\n<p>本内容采用人工智能辅助协作,经本人审核,符合本人观点与立场。</p>\n<h2 id=\"元信息\">元信息</h2>\n<ul>\n<li><strong>本文作者:</strong> <a href=\"https://www.newbe.pro\" rel=\"noopener nofollow\" target=\"_blank\">newbe36524</a></li>\n<li><strong>本文链接:</strong> <a href=\"https://hagicode-org.github.io/site/blog/2026/01/25/how-to-sync-docker-hub-to-azure-acr-with-github\" rel=\"noopener nofollow\" target=\"_blank\">https://hagicode-org.github.io/site/blog/2026/01/25/how-to-sync-docker-hub-to-azure-acr-with-github</a></li>\n<li><strong>版权声明:</strong> 本博客所有文章除特别声明外,均采用 BY-NC-SA 许可协议。转载请注明出处!</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 15:12</span>&nbsp;\n<a href=\"https://www.cnblogs.com/newbe36524\">Newbe36524</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "将分散的Pytest测试脚本统一接入测试平台：FastAPI改造方案详解",
      "link": "https://www.cnblogs.com/lfr0123/p/19529690",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lfr0123/p/19529690\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 14:46\">\n    <span>将分散的Pytest测试脚本统一接入测试平台：FastAPI改造方案详解</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>在上一篇文章<a href=\"https://www.cnblogs.com/lfr0123/p/19378880\" target=\"_blank\">《Pytest 测试用例自动生成：接口自动化进阶实践》</a>中，我们已经解决了<strong>“如何高效编写和维护接口自动化用例”</strong>的问题。</p>\n<p>然而，随着业务的发展和团队规模的扩大，很多公司会选择开发自己的测试平台，以实现更高效、更统一的管理。</p>\n<p>企业接口自动化通常会经历如下过程：</p>\n<ol>\n<li>初期：测试人员本地用 Pytest 写脚本（即脚本项目）</li>\n<li>中期：接入 Jenkins，定时跑一跑</li>\n<li>后期：公司开始建设<strong>统一测试平台</strong></li>\n</ol>\n<h2 id=\"一-为什么需要将脚本项目接入测试平台\">一. 为什么需要将脚本项目接入测试平台</h2>\n<h3 id=\"1-当前面临的挑战\">1. 当前面临的挑战</h3>\n<ul>\n<li><strong>用例复用难</strong>：已有的大量 Pytest 测试用例无法直接在平台上运行，重新编写成本高。</li>\n<li><strong>管理复杂</strong>：多个脚本项目分散管理，执行效率低、维护困难。</li>\n<li><strong>报告分散</strong>：测试报告散落在各个项目中，难以统一查看和分析。</li>\n</ul>\n<p>因此，需要考虑<strong>在【不重写、不侵入、不破坏】现有 Pytest 脚本项目的前提下，让它具备“测试平台可接入能力”</strong>。</p>\n<h3 id=\"2-两种可选方案\">2. 两种可选方案</h3>\n<p>我们考虑以下两种方案将脚本项目接入测试平台：</p>\n<ul>\n<li><strong>方案一</strong>：将脚本项目直接集成到测试平台目录中。</li>\n<li><strong>方案二</strong>：使用 FastAPI 改造脚本项目，提供接口供平台调用。</li>\n</ul>\n<p><strong>为什么选择方案二？</strong></p>\n<ul>\n<li>脚本项目经常需要修改和更新，若集成到平台中，每次修改都需要重新发布平台代码，繁琐且易出错。</li>\n<li>FastAPI 轻量、高性能，适合快速构建RESTful接口，实现脚本与平台的解耦。</li>\n</ul>\n<h2 id=\"二-使用-fastapi-框架改造脚本项目\">二. 使用 FastAPI 框架改造脚本项目</h2>\n<h3 id=\"1-核心思路\">1. 核心思路</h3>\n<p>我们的目标是：<strong>不改动原有Pytest脚本逻辑，仅通过\"封装+接口\"的方式，让脚本项目具备平台接入能力</strong>。</p>\n<p>实现原则：</p>\n<ol>\n<li><strong>不重写</strong>：保持原有 <code>testcases/</code>、<code>utils/</code> 目录结构不变</li>\n<li><strong>不侵入</strong>：原有脚本文件无需修改任何代码</li>\n<li><strong>不解耦</strong>：仅新增API层，不改变原有执行逻辑</li>\n</ol>\n<h3 id=\"2-目录改造\">2. 目录改造</h3>\n<p>原有脚本项目核心目录保留不变，改造后新增「API 层、配置层」，确保原有脚本无需修改即可复用。</p>\n<ul>\n<li>\n<p>改造前目录（即脚本项目原始目录）示例如下：</p>\n<pre><code>SUPER-API-AUTO-TEST/          # 接口自动化测试项目根目录\n├── auth.py                    # 鉴权相关\n├── case_generator.py          # 用例生成逻辑\n├── config.yaml                # 项目配置\n├── conftest.py                # Pytest夹具\n├── runner.py                  # 用例执行入口\n├── reports/                   # 测试报告目录\n├── logs/                      # 日志目录\n├── testcases/                 # 测试用例脚本（Python）\n├── testcases_data/            # 测试用例数据（YAML）\n└── utils/                     # 通用工具类\n</code></pre>\n</li>\n<li>\n<p>Fastapi 改造后目录结构示例如下：</p>\n<pre><code>FASTAPI-SUPER-API-AUTO-TEST/  # 基于FastAPI的改造后目录\n├── auth.py                    \n├── case_generator.py          \n├── conftest.py                \n├── main.py                   # FastAPI应用入口（核心新增）\n├── pytest.ini                \n├── runner.py                  \n├── api/                      # API层（核心新增）\n│   ├── testcase_route.py     # 接口路由定义（URL、请求参数）\n│   ├── testcase_service.py   # 接口业务逻辑（与原有脚本交互）\n│   └── __init__.py           \n├── configs/                  # 配置目录（拆分原有config.yaml）\n│   └── config.yaml           \n├── logs/                     \n├── reports/                  \n├── testcases/                # 完全复用原有目录\n├── testcases_data/           # 完全复用原有目录\n└── utils/                    # 完全复用原有目录\n</code></pre>\n</li>\n</ul>\n<p>改造后，新增了 Fastapi 路由层 <code>api/</code>、配置层 <code>configs/</code>，以及 FastAPI 应用入口 <code>main.py</code>。</p>\n<h2 id=\"三-核心接口设计与实现\">三. 核心接口设计与实现</h2>\n<h3 id=\"1-接口设计示例\">1. 接口设计示例</h3>\n<p>我们设计了以下关键接口供测试平台调用：</p>\n<p>① 获取项目与模块信息</p>\n<ul>\n<li><code>GET /api_test/testcases/projects</code>：获取所有项目列表</li>\n<li><code>GET /api_test/testcases/modules</code>：获取指定项目下的模块列表</li>\n</ul>\n<p>② 获取用例列表</p>\n<ul>\n<li><code>GET /api_test/testcases/list</code>：支持按项目/模块筛选测试用例</li>\n</ul>\n<p>③ 生成测试用例</p>\n<ul>\n<li><code>POST /api_test/testcases/generate</code>：根据YAML用例文件生成Python测试脚本</li>\n</ul>\n<p>④ 执行测试任务</p>\n<ul>\n<li><code>POST /api_test/testcases/run</code>：后台执行指定测试用例，支持环境选择、报告类型、回调通知等</li>\n</ul>\n<p>⑤ 获取测试报告</p>\n<ul>\n<li><code>GET /api_test/reports/get_by_task</code>：根据任务ID获取报告访问地址</li>\n</ul>\n<h3 id=\"2-代码示例\">2. 代码示例</h3>\n<p><code>testcase_service.py</code></p>\n<pre><code class=\"language-python\"># @author:  xiaoqq\n\nimport os, re\nfrom datetime import datetime\nfrom typing import List, Optional, Dict\nfrom pathlib import Path\n\nTESTCASE_ROOT = \"testcases\"\n\ndef get_abs_root_path(root_path: str) -&gt; Path:\n    \"\"\"\n    使用当前文件相对路径构造 testcases/ 的绝对路径\n    :param root_path: 目录名\n    :return:\n    \"\"\"\n    base_dir = Path(__file__).resolve().parent  # 当前文件所在目录\n    abs_root_path = (base_dir.parent / root_path).resolve()\n    return abs_root_path\n\ndef get_all_testcases(project: Optional[str] = None,\n                  module: Optional[str] = None,\n                  root_path: str = TESTCASE_ROOT) -&gt; List[Dict]:\n    \"\"\"\n    获取所有测试用例（支持通过 project/module 筛选）\n    返回字段包括 filename（无后缀）、path（绝对路径字符串）、Allure 元信息等\n    \"\"\"\n    abs_root_path = get_abs_root_path(root_path)\n    if not abs_root_path.exists():\n       return []\n    \n    # 路径校验\n    if module and not project:\n       raise ValueError(\"传入 module 前必须先传入 project\")\n    \n    # 构造起始目录路径\n    search_path = abs_root_path\n    if project:\n       search_path = search_path / project\n    if module:\n       search_path = search_path / module\n    \n    if not search_path.exists():\n       return []\n    \n    testcases = []\n    \n    for dirpath, _, filenames in os.walk(search_path):\n       for file in filenames:\n          if file.startswith(\"test_\") and file.endswith(\".py\"):\n             full_path = os.path.join(dirpath, file)\n             rel_path = os.path.relpath(full_path, abs_root_path)  # 相对路径，如 merchant/device/test_xxx.py\n             path_parts = Path(rel_path).parts  # 使用 pathlib 安全拆解路径\n             \n             if len(path_parts ) &lt; 2:\n                continue  # 至少要有 project/filename 结构\n             \n             _project = path_parts [0]\n             _filename = path_parts [-1]\n             _module = path_parts [1] if len(path_parts ) &gt; 2 else None  # module 可选\n             \n             # 按传参过滤\n             if project and _project != project:\n                continue\n             if module and _module != module:\n                continue\n             \n             filename = os.path.splitext(_filename)[0]  # 去掉 .py 后缀\n             last_modified = datetime.fromtimestamp(os.path.getmtime(full_path)).isoformat()\n             \n             # 提取用例元信息\n             try:\n                case_name, epic, feature, story = extract_case_info(full_path)\n             except Exception as e:\n                case_name, epic, feature, story = None, None, None, None\n                \n             # 拼接最终 path 字段为 TESTCASE_ROOT/... 形式\n             full_case_path = str(Path(root_path) / rel_path).replace(\"\\\\\", \"/\")\n             \n             # 构造 external_id：project|module|filename|path\n             external_id = f\"{_project}|{_module or 'nomodule'}|{filename}|{full_case_path}\"\n             \n             testcases.append({\n                \"project\": _project,\n                \"module\": _module,  # None 表示无 module 层级\n                \"file\": _filename,\n                \"filename\": filename,\n                \"path\": full_case_path,\n                \"last_modified\": last_modified,\n                \"case_name\": case_name or filename,\n                \"allure_epic\": epic,\n                \"allure_feature\": feature,\n                \"allure_story\": story,\n                \"external_id\": external_id # 加入唯一标识\n             })\n    \n    return testcases\n\ndef extract_case_info(file_path):\n    \"\"\"\n    解析测试用例文件，获取相应信息\n    :param file_path:\n    :return:\n    \"\"\"\n    with open(file_path, 'r', encoding='utf-8') as file:\n       content = file.read()\n       \n       case_name_match = re.search(\n          r'def setup_class.*?\\(.*?\\):.*?log\\.info\\(\\'========== 开始执行测试用例：(.+?) ==========\\'',\n          content, re.DOTALL\n       )\n       case_name = case_name_match.group(1).strip() if case_name_match else \\\n       os.path.splitext(os.path.basename(file_path))[0]\n       \n       allure_epic_match = re.search(r'@allure\\.epic\\(\\'(.+?)\\'\\)', content)\n       allure_feature_match = re.search(r'@allure\\.feature\\(\\'(.+?)\\'\\)', content)\n       allure_story_match = re.search(r'@allure\\.story\\(\\'(.+?)\\'\\)', content)\n       \n       allure_epic = allure_epic_match.group(1).strip() if allure_epic_match else None\n       allure_feature = allure_feature_match.group(1).strip() if allure_feature_match else None\n       allure_story = allure_story_match.group(1).strip() if allure_story_match else None\n       \n       return case_name, allure_epic, allure_feature, allure_story\n\n\n\ndef get_all_projects(root_path: str = TESTCASE_ROOT) -&gt; List[Dict[str, str]]:\n    \"\"\"\n    获取 testcases/ 下所有项目名、相对路径及创建时间（倒序排序）\n    \"\"\"\n    abs_root_path = get_abs_root_path(root_path)\n    if not abs_root_path.exists():\n       return []\n    \n    projects = []\n    for d in abs_root_path.iterdir():\n       if d.is_dir():\n          created_time = datetime.fromtimestamp(d.stat().st_ctime)\n          projects.append({\n             \"name\": d.name,\n             \"path\": str(Path(root_path) / d.name).replace(\"\\\\\", \"/\"),\n             \"created_time\": created_time.isoformat()\n          })\n    \n    # 按创建时间倒序\n    return sorted(projects, key=lambda x: x[\"created_time\"], reverse=True)\n\n\ndef get_all_projects_and_modules(\n    project: Optional[str] = None,\n    root_path: str = TESTCASE_ROOT\n) -&gt; List[Dict]:\n    \"\"\"\n    获取所有项目和模块结构（支持指定项目）。包含路径、创建时间，按项目时间倒序。\n    \"\"\"\n    abs_root_path = get_abs_root_path(root_path)\n    if not abs_root_path.exists():\n       return []\n    \n    result = []\n    \n    for proj_dir in abs_root_path.iterdir():\n       if not proj_dir.is_dir():\n          continue\n       \n       proj_name = proj_dir.name\n       if project and proj_name != project:\n          continue\n       \n       proj_created_time = datetime.fromtimestamp(proj_dir.stat().st_ctime)\n       modules = []\n       \n       # 遍历模块目录时需要忽略的子目录\n       EXCLUDE_DIRS = {\"__pycache__\", \".pytest_cache\", \".git\", \".idea\"}\n       for mod_dir in proj_dir.iterdir():\n          if mod_dir.is_dir() and mod_dir.name not in EXCLUDE_DIRS:\n             mod_created_time = datetime.fromtimestamp(mod_dir.stat().st_ctime)\n             modules.append({\n                \"name\": mod_dir.name,\n                \"path\": str(Path(root_path) / proj_name / mod_dir.name).replace(\"\\\\\", \"/\"),\n                \"created_time\": mod_created_time.isoformat()\n             })\n       \n       # 模块也可以排序（如有需求）\n       modules.sort(key=lambda x: x[\"created_time\"], reverse=True)\n       \n       result.append({\n          \"project\": proj_name,\n          \"path\": str(Path(root_path) / proj_name).replace(\"\\\\\", \"/\"),\n          \"created_time\": proj_created_time.isoformat(),\n          \"modules\": modules\n       })\n       \n       if project:\n          break\n    \n    # 项目排序\n    return sorted(result, key=lambda x: x[\"created_time\"], reverse=True)\n\n\ndef generate_testcase(case_yaml_list: list = None):\n    \"\"\"\n    生成测试用例\n    :return:\n    \"\"\"\n    from case_generator import CaseGenerator\n    CG = CaseGenerator()\n    CG.generate_testcases(project_yaml_list=case_yaml_list)\n\n\nif __name__ == '__main__':\n    # print(get_all_testcases())\n    # print(get_all_projects())\n    print(get_all_projects_and_modules(project=\"merchant\"))\n</code></pre>\n<p><code>testcase_route.py </code>示例如下：</p>\n<pre><code class=\"language-python\"># @author:  xiaoqq\n\nfrom pathlib import Path\nfrom fastapi import APIRouter, BackgroundTasks, Query, Body\nfrom pydantic import BaseModel\nfrom typing import List, Optional\nfrom runner import run_tests\nfrom api.testcase_service import (\n\tget_all_testcases,\n\tget_all_projects,\n\tget_all_projects_and_modules,\n\tgenerate_testcase,\n)\n\nrouter = APIRouter()\n\nclass TestExecutionRequest(BaseModel):\n\ttestcases: Optional[List[str]] = ['testcases/']  # 默认运行所有目录\n\tenv: Optional[str] = 'pre'\n\treport_type: Optional[str] = 'pytest-html'\n\tdingtalk_notify: Optional[bool] = True\n\ttask_id: Optional[str]\n\tcallback_url: Optional[str]\n\tauth_token: Optional[str] = None  # 新增字段：从平台传入的 token\n\n# 执行测试用例\n@router.post(\"/testcases/run\")\ndef run_testcases(request: TestExecutionRequest, background_tasks: BackgroundTasks):\n\ttry:\n\t\tbackground_tasks.add_task(\n\t\t\trun_tests,\n\t\t\ttestcases=request.testcases,\n\t\t\tenv=request.env,\n\t\t\treport_type=request.report_type,\n\t\t\tdingtalk_notify=request.dingtalk_notify,\n\t\t\ttask_id=request.task_id,\n\t\t\tcallback_url=request.callback_url,\n\t\t\tauth_token=request.auth_token,  # 测试平台回调 auth_token\n\t\t)\n\t\treturn {\n\t\t\t\"code\": 0,\n\t\t\t\"msg\": \"测试任务已提交后台执行\",\n\t\t\t\"task_id\": request.task_id\n\t\t}\n\texcept Exception as e:\n\t\treturn {\"code\":1, \"msg\": f\"测试任务失败：{str(e)}\"}\n\n# 获取测试用例\n@router.get(\"/testcases/list\")\ndef list_testcases(project: str = Query(None), module: str = Query(None)):\n\ttry:\n\t\ttestcases = get_all_testcases(project, module)\n\t\treturn {\n\t\t\t\"code\": 0,\n\t\t\t\"msg\": \"success\",\n\t\t\t\"testcases\": testcases\n\t\t}\n\texcept Exception as e:\n\t\treturn {\"code\": 1, \"msg\": f\"获取测试用例失败：{str(e)}\"}\n\n\n# 获取 testcases/ 中的所有测试项目\n@router.get(\"/testcases/projects\")\ndef list_projects():\n\ttry:\n\t\tprojects = get_all_projects()\n\t\treturn {\"code\": 0, \"msg\": \"success\", \"projects\": projects}\n\texcept Exception as e:\n\t\treturn {\"code\": 1, \"msg\": f\"获取测试项目失败：{str(e)}\"}\n\t\n\n# 获取 testcases/ 中的所有测试项目及模块\n@router.get(\"/testcases/modules\")\ndef list_modules(project: str = Query(None)):\n\ttry:\n\t\tmodules = get_all_projects_and_modules(project)\n\t\treturn {\"code\": 0, \"msg\": \"success\", \"modules\": modules}\n\texcept Exception as e:\n\t\treturn {\"code\": 1, \"msg\": f\"获取测试项目-模块失败：{str(e)}\"}\n\n\n\nclass GenerateCaseRequest(BaseModel):\n\tcase_yaml_list: Optional[List[str]] = None\n\n# 根据 testcases_data/ 中的测试数据生成测试用例文件\n@router.post(\"/testcases/generate\")\ndef generate_testcase_route(req: GenerateCaseRequest):\n\ttry:\n\t\tgenerate_testcase(req.case_yaml_list)\n\t\treturn {\"code\": 0, \"msg\": \"success\"}\n\texcept Exception as e:\n\t\treturn {\"code\": 1, \"msg\": f\"获取测试项目-模块失败：{str(e)}\"}\n\n\n@router.get(\"/reports/get_by_task\")\ndef get_report_by_task(\n\t\ttask_id: str,\n\t\treport_type: str,\n\t\tcreated_at: str  # 格式: \"20250814\"\n):\n\t\"\"\"\n\t根据 task_id + 创建时间 + report_type 获取报告 URL\n\t\"\"\"\n\tif not created_at:\n\t\treturn {\"code\": 1, \"msg\": \"created_at 必填\", \"url\": None}\n\t\n\tbase_path = Path(__file__).resolve().parent.parent / \"reports\" / created_at\n\t\n\tif report_type == \"pytest-html\":\n\t\treport_file = base_path / f\"report_{task_id}.html\"\n\telif report_type == \"allure\":\n\t\treport_file = base_path / f\"report_{task_id}_allure/html/index.html\"\n\telse:\n\t\treturn {\"code\": 1, \"msg\": \"未知 report_type\", \"url\": None}\n\t\n\tif not report_file.exists():\n\t\treturn {\"code\": 1, \"msg\": \"报告文件不存在\", \"url\": None}\n\t\n\trelative_url = str(report_file.relative_to(Path(__file__).resolve().parent.parent)).replace(\"\\\\\", \"/\")\n\treturn {\"code\": 0, \"msg\": \"success\", \"url\": f\"/{relative_url}\"}\n</code></pre>\n<p><code>mian.py</code></p>\n<pre><code class=\"language-python\">from fastapi import FastAPI\nfrom api import testcase_route\nfrom pathlib import Path\nfrom fastapi.staticfiles import StaticFiles\n\napp = FastAPI(title=\"接口自动化测试服务\")\n\n# 挂载测试用例路由\napp.include_router(testcase_route.router, prefix=\"/api_test\", tags=[\"测试任务\"])\n\n# 挂载 reports 目录为静态文件目录\nreports_dir = Path(__file__).parent / \"reports\"\nreports_dir.mkdir(exist_ok=True)  # 确保目录存在\napp.mount(\"/reports\", StaticFiles(directory=reports_dir), name=\"reports\")\n\nif __name__ == \"__main__\":\n    from utils.log_manager import LogManager\n    LogManager.setup_logging()  # 启动时显式初始化日志\n    \n    import uvicorn\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=8000,\n        # reload=True,\n        reload_excludes=[\"testcases/*\", \"logs/*\", \"reports/*\"]  # 排除这些目录的文件变更\n    )\n</code></pre>\n<h2 id=\"四-测试平台调用\">四. 测试平台调用</h2>\n<p>执行<code>mian.py</code>，启动 Fastapi 项目后，便可在测试平台通过调用相关接口来管理该脚本测试项目（平台调用代码不具体提供）。</p>\n<h3 id=\"1-调用示意图\">1. 调用示意图</h3>\n<pre><code class=\"language-reStructuredText\">测试平台\n   │\n   │ HTTP 调用\n   ▼\nFastAPI 测试服务\n   │\n   │ pytest 执行\n   ▼\n测试报告生成\n   │\n   │ 回调结果\n   ▼\n测试平台展示\n</code></pre>\n<p>这样，职责边界非常清晰：</p>\n<ul>\n<li>测试平台：调度、记录、展示，</li>\n<li>改造后的测试服务：执行、产出报告</li>\n</ul>\n<h3 id=\"2-测试平台界面\">2. 测试平台界面</h3>\n<p>平台测试用例列表：</p>\n<p><img alt=\"image-20260120134215814\" /></p>\n<p>测试报告列表：</p>\n<p><img alt=\"image-20260122143715247\" /></p>\n<h2 id=\"五-总结\">五. 总结</h2>\n<p>方案优势总结如下：</p>\n<ol>\n<li>\n<p><strong>解耦与复用</strong>：脚本项目独立维护，平台通过接口调用，互不影响</p>\n</li>\n<li>\n<p><strong>灵活执行</strong>：支持按项目、模块、用例筛选执行，适应不同测试场景。</p>\n</li>\n<li>\n<p><strong>异步处理</strong>：长时间任务后台执行，平台可实时获取状态与报告。</p>\n</li>\n<li>\n<p><strong>报告统一管理</strong>：所有报告集中存储，支持在线统一查看。</p>\n</li>\n</ol>\n<p>当然，示例代码还可以进行优化扩展，如加入用户认证机制来保障接口安全等。</p>\n<p>当接口自动化发展到一定规模，<code>单机脚本</code> 或 <code>Jenkins Job</code> 都会成为瓶颈，而<strong>“脚本服务化 + 平台调度”</strong>，几乎是所有成熟团队最终都会走到的一步。</p>\n<p>如果你：</p>\n<ul>\n<li>正在做接口自动化</li>\n<li>或正在参与测试平台建设</li>\n<li>或正在被“脚本怎么接平台”折磨</li>\n</ul>\n<p>那么，希望这篇文章能少让你走一点弯路。</p>\n\n</div>\n<div id=\"MySignature\">\n    <div style=\"font-size: 13px; border: 1px dashed rgb(45, 161, 45); padding: 10px 15px; background-color: rgb(248, 248, 248);\">\n\t<div>\n        <label style=\"font-weight: bold;\">&nbsp;&nbsp;&nbsp;&nbsp;\n            <label style=\"font-weight: bold; color: red; font-size: 15px;\">左边二维码</label>\n            为博主\n            <label style=\"font-weight: bold; color: red; font-size: 15px;\">个人微信</label>\n            ，\n            <label style=\"font-weight: bold; color: red; font-size: 15px;\">扫码添加微信后可加入测试学习交流群</label>\n            （添加时请务必备注：加入测试学习交流群）。\n            <label style=\"font-weight: bold; color: red; font-size: 15px;\">右边二维码</label>\n            为博主\n            <label style=\"font-weight: bold; color: red; font-size: 15px;\">微信公众号</label>\n            ，专注于自动化测试、测试开发技术分享，欢迎关注。\n            书山有路勤为径，学海无涯苦做舟。希望通过分享学习交流，大家能够朝着\n            <label style=\"font-weight: bold; color: red; font-size: 15px;\">最朴实的愿望--成长、加薪、升职</label>\n            更进一步。\n        </label>\n    </div>\n    <!-- <div align=\"center\">\n        <img style=\"height: 160px; width: 160px;\" alt=\"个人微信\" src=\"https://images.cnblogs.com/cnblogs_com/lfr0123/2106623/t_220220120615_wechat_black.png\">\n    </div> -->\n    <div style=\"text-align: center; margin-top: 10px;\">\n        <img alt=\"个人微信\" src=\"https://images.cnblogs.com/cnblogs_com/lfr0123/2106623/o_220303134143_WeChat_with_logo.png\" style=\"width: 180px; padding-right: 20%;\" />\n        <img alt=\"个人微信公众号\" src=\"https://images.cnblogs.com/cnblogs_com/lfr0123/2106623/o_220303134126_gzh_with_ps.png\" style=\"width: 180px;\" />\n    </div>\n    <div><b>本文作者</b>：<a href=\"https://www.cnblogs.com/lfr0123/\">给你一页白纸</a></div>\n\t<div><b>版权申明</b>：本博客所有文章除特殊声明外，均采用<a href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\">BY-NC-SA\n\t</a> 许可协议。转载请注明出处！</div>\n\t<div><b>声援博主</b>：如果觉得这篇文章对您有帮助，请点一下右下角的\n\t\t<a id=\"recommend\" style=\"font-weight: bold; color: red; font-size: 15px; text-decoration: underline;\">“推荐”</a>\n\t\t图标哦，您的\n\t\t<a id=\"recommend\" style=\"font-weight: bold; color: red; font-size: 15px; text-decoration: underline;\">“推荐”</a>\n\t\t是我写作的最大动力。您也可以点击下方的\n        <a id=\"recommend\" style=\"font-weight: bold; color: red; font-size: 15px; text-decoration: underline;\">【关注我】</a>\n        按钮，关注博主不迷路。\n\t</div>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 14:46</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lfr0123\">给你一页白纸</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "DBShadow.net之化繁为简",
      "link": "https://www.cnblogs.com/xiangji/p/19529688",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xiangji/p/19529688\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 14:44\">\n    <span>DBShadow.net之化繁为简</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t<div class=\"postText\">    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        DBShadow.net支持化繁为简\n只有一个参数的时候支持直接按参数值来操作\nIN查询的集合参数也支持简化\n泛型的参数和返回值类型可以定义更通用的服务\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"一简化查询\">一、简化查询</h2>\n<h3 id=\"1-先看一下查询的例子\">1. 先看一下查询的例子</h3>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 账户获取服务\n/// &lt;/summary&gt;\n/// &lt;param name=\"table\"&gt;&lt;/param&gt;\n/// &lt;param name=\"builder\"&gt;&lt;/param&gt;\npublic class AccountGetService(AccountTable table, IShadowBuilder builder)\n{\n    private readonly SqlSource _source = new(builder.DataSource);\n    private readonly IParamQuery&lt;Account, Account&gt; _accountQuery\n        = builder.BuildResult&lt;Account, Account&gt;(\n            table.ToQuery()\n                .And(account =&gt; account.Id.Equal())\n                .ToSelect()\n                .SelectSelfColumns()\n        );\n    /// &lt;summary&gt;\n    /// 获取账户\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"param\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"token\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public Task&lt;Account?&gt; GetAsync(Account param, CancellationToken token = default)\n        =&gt; _accountQuery.GetFirstAsync(_source, param, token);\n}\n</code></pre>\n<h3 id=\"2-调用方式如下\">2. 调用方式如下</h3>\n<pre><code class=\"language-csharp\">var account = await accountGetService.GetAsync(new Account { Id = 1L });\n</code></pre>\n<h3 id=\"3-这个例子我们可以简化一下\">3. 这个例子我们可以简化一下</h3>\n<blockquote>\n<ul>\n<li>参数直接使用Id(类型由Account简化为long)</li>\n<li>很大一部分数据库操作都只有一个参数(GetById、GetByName等)</li>\n<li>为此定义一个含单个属性类有点浪费</li>\n<li>按上面的例子使用实体类作为参数也感觉怪怪的</li>\n<li>DBShadow.net支持这种简化操作</li>\n<li>单个参数无需封装,直接使用参数类型即可</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">public class AccountGetService(AccountTable table, IShadowBuilder builder)\n{\n    private readonly SqlSource _source = new(builder.DataSource);\n    private readonly IParamQuery&lt;long, Account&gt; _accountQuery\n        = builder.BuildResult&lt;long, Account&gt;(\n            table.ToQuery()\n                .And(account =&gt; account.Id.Equal())\n                .ToSelect()\n                .SelectSelfColumns()\n        );\n    public Task&lt;Account?&gt; GetAsync(long accountId, CancellationToken token = default)\n        =&gt; _accountQuery.GetFirstAsync(_source, param, token);\n}\nvar account = await accountGetService.GetAsync(1L);\n</code></pre>\n<h3 id=\"4-特别注意不要在dapper中这样使用\">4. 特别注意不要在Dapper中这样使用</h3>\n<blockquote>\n<ul>\n<li>Dapper是不支持这种简化操作</li>\n<li>以下Dapper错误示例会抛出异常</li>\n<li>System.InvalidOperationException:“Must add values for the following parameters: @Id”</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">await using var conn = _dataSource.CreateConnection();\nvar sql = \"SELECT \\\"Id\\\",\\\"Title\\\",\\\"Content\\\",\\\"Done\\\",\\\"LastTime\\\" FROM \\\"Todo\\\" WHERE \\\"Id\\\"=@Id\";\nvar first = await conn.QueryFirstOrDefaultAsync&lt;Todo&gt;(sql, 1L);\n</code></pre>\n<h2 id=\"二-集合参数也支持简化操作\">二、 集合参数也支持简化操作</h2>\n<h3 id=\"1-in查询简化的例子\">1. IN查询简化的例子</h3>\n<blockquote>\n<ul>\n<li>In的参数名是可选和前面例子的Equal是一样的,默认字段名</li>\n<li>In查询的实参支持数组、集合及字典</li>\n<li>只有In一个集合参数是支持直接传数组、集合或字典</li>\n<li>这时参数名(eg: AccountIds)就无所谓取什么名了</li>\n<li>因为不需要反射获取属性值了</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 批量账户获取服务\n/// &lt;/summary&gt;\n/// &lt;param name=\"table\"&gt;&lt;/param&gt;\n/// &lt;param name=\"builder\"&gt;&lt;/param&gt;\npublic class AccountBatchService(AccountTable table, IShadowBuilder builder)\n{\n    private readonly SqlSource _source = new(builder.DataSource);\n    private readonly IParamQuery&lt;long[], Account&gt; _accountQuery\n        = builder.BuildResult&lt;long[], Account&gt;(\n            table.ToQuery()\n                .And(account =&gt; account.Id.In(\"AccountIds\"))\n                .ToSelect()\n                .SelectSelfColumns()\n        );\n    /// &lt;summary&gt;\n    /// 批量获取账户\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"accountIds\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"token\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public IAsyncEnumerable&lt;Account&gt; GetAsync(long[] accountIds, CancellationToken token = default)\n        =&gt; _accountQuery.QueryAsync(_source, accountIds, token);\n}\n</code></pre>\n<h3 id=\"2-以上调用的例子如下\">2. 以上调用的例子如下</h3>\n<pre><code class=\"language-csharp\">[Fact]\npublic async Task Batch()\n{\n    var count = 0;\n    var service = new AccountBatchService(table, builder);\n    var list = service.GetAsync([1L, 2L, 3L]);\n    await foreach (var item in list)\n    {\n        _output.WriteLine($\"{item.Id}:{item.Amount}\");\n        count++;\n    }\n    Assert.Equal(3, count);\n}\n// 1:100\n// 2:200\n// 3:300\n</code></pre>\n<h2 id=\"三泛型查询\">三、泛型查询</h2>\n<h3 id=\"1-泛型服务类代码\">1. 泛型服务类代码</h3>\n<blockquote>\n<ul>\n<li>该服务用来按字段Id查询表Account</li>\n<li>参数TParam是泛型,这样可以直接使用DTO参数来查询,减少类型转化的开销</li>\n<li>返回值TAccount也是泛型,这样就可以直接返回视图模型或者领域模型</li>\n<li>这样的泛型服务类就非常的通用</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-csharp\">/// &lt;summary&gt;\n/// 账户获取泛型服务\n/// &lt;/summary&gt;\n/// &lt;param name=\"table\"&gt;&lt;/param&gt;\n/// &lt;param name=\"builder\"&gt;&lt;/param&gt;\npublic class AccountGetService&lt;TParam, TAccount&gt;(AccountTable table, IShadowBuilder builder)\n{\n    private readonly SqlSource _source = new(builder.DataSource);\n    private readonly IParamQuery&lt;TParam, TAccount&gt; _accountQuery\n        = builder.BuildResult&lt;TParam, TAccount&gt;(\n            table.ToQuery()\n                .And(account =&gt; account.Id.Equal())\n                .ToSelect()\n                .SelectSelfColumns()\n        );\n    /// &lt;summary&gt;\n    /// 获取账户\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"param\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"token\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public Task&lt;TAccount?&gt; GetAsync(TParam param, CancellationToken token = default)\n        =&gt; _accountQuery.GetFirstAsync(_source, param, token);\n}\n</code></pre>\n<h3 id=\"2-中规中矩的调用方式\">2. 中规中矩的调用方式</h3>\n<pre><code class=\"language-csharp\">var service = new AccountGetService&lt;Account, Account&gt;(_table, _builder);\nvar account = await service.GetAsync(new Account { Id = 1L });\nAssert.NotNull(account);\n</code></pre>\n<h3 id=\"3-支持简单调用方式\">3. 支持简单调用方式</h3>\n<pre><code class=\"language-csharp\">var service = new AccountGetService&lt;long, Account&gt;(_table, _builder);\nvar account = await service.GetAsync(1L);\nAssert.NotNull(account);\n</code></pre>\n<h2 id=\"四总结\">四、总结</h2>\n<blockquote>\n<ul>\n<li>DBShadow.net预编译比较智能</li>\n<li>只有1个参数时支持化繁为简,支持直接传值做为参数值</li>\n<li>这样可以节约定义只有一个属性的参数类</li>\n<li>参数和返回值类型还可以定义为泛型,可以做到更加灵活</li>\n</ul>\n</blockquote>\n<p>另外源码托管地址: <a href=\"https://github.com/donetsoftwork/DBShadow.net\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/donetsoftwork/DBShadow.net</a> ，欢迎大家直接查看源码。<br />\ngitee同步更新:<a href=\"https://gitee.com/donetsoftwork/DBShadow.net\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/donetsoftwork/DBShadow.net</a></p>\n<p>如果大家喜欢请动动您发财的小手手帮忙点一下Star,谢谢！！！</p>\n\n</div>\n<div class=\"clear\"></div>\n</div>\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-01-25 14:44</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xiangji\">xiangji</a>&nbsp;\n阅读(<span id=\"post_view_count\">20</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "技术问题记录20260125",
      "link": "https://www.cnblogs.com/grey-wolf/p/19529664",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/grey-wolf/p/19529664\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 14:37\">\n    <span>技术问题记录20260125</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"问题1http报文转curl\">问题1：http报文转curl</h1>\n<h2 id=\"背景\">背景</h2>\n<p>处理线上问题时，偶尔是需要进行网络抓包的（如tcpdump），用wireshark分析抓包文件时，一般能看到http请求的报文。</p>\n<p>如下面这样：</p>\n<p><img alt=\"image-20260125135624273\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125135624273.png\" /></p>\n<p>有时候需要用postman这类工具来调用，进行复现，简单来说，需求就是：将上面图里的报文转换为postman这类工具里的请求。</p>\n<p>有时候请求比较复杂，header也多，手工搞比较麻烦，而且线上问题处理都比较赶时间，如果能快速转换的话，是最好不过了。</p>\n<p>我的方案是：分两步。先想办法，将上述报文转换为标准的curl命令，再将curl命令转换为postman请求。</p>\n<h2 id=\"报文转curl\">报文转curl</h2>\n<p>经过搜索，发现有这么一个在线网站：可以用这个在线网站： <a href=\"https://curl.se/h2c/\" rel=\"noopener nofollow\" target=\"_blank\">https://curl.se/h2c/</a></p>\n<p><img alt=\"image-20260125140012663\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125140012663.png\" /></p>\n<p>上面这个网站就是curl这个项目的官网，算是官方背景了。大家可以直接用这个，方便。</p>\n<p><img alt=\"image-20260125140131349\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125140131349.png\" /></p>\n<p>不过我发现，在转换content-type为：application/x-www-form-urlencoded 这种的时候，结果中会缺失这个header，如下：</p>\n<p><img alt=\"image-20260125140247867\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125140247867.png\" /></p>\n<p>我自己想办法修复了一下，我找到了这个工具的源码：</p>\n<p><a href=\"https://github.com/curl/h2c\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/curl/h2c</a></p>\n<p>源码仓库里还有linux命令行版本h2c，不过一样存在上述的bug。</p>\n<p><img alt=\"image-20260125140453271\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125140453271.png\" /></p>\n<p>我看了下源码，是perl语言写的，我当时想着，现在大模型也厉害，直接让他给我转换成java语言吧。</p>\n<p>最后我就转了个java版本，修复了那个bug，并且让大模型用javafx弄了个图形界面的版本（javafx代码我也看不懂，也懒得看，能用就行了）。</p>\n<p>源码我放在了：</p>\n<p><a href=\"https://gitee.com/dumpcao/http-to-curl-converter\" rel=\"noopener nofollow\" target=\"_blank\">https://gitee.com/dumpcao/http-to-curl-converter</a></p>\n<p>自己mvn package打个包就能用，或者直接用我仓库里提交的jar包，下下来双击运行就能用：</p>\n<p><img alt=\"image-20260125140657277\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125140657277.png\" /></p>\n<h2 id=\"curl转请求\">curl转请求</h2>\n<p>postman可以直接导入。</p>\n<p><img alt=\"image-20260125141145134\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125141145134.png\" /></p>\n<p>我用了apifox也支持curl导入，不过要繁琐一点，可自行搜索。</p>\n<h1 id=\"问题2集合比较工具\">问题2：集合比较工具</h1>\n<p>有时候，临时要对两个集合（如两个list、set）进行比较，数据可能来源于不懂技术的同事发给你的两个excel，比如看看到底有哪些差异，多了什么，少了什么等等。</p>\n<p>以前我有时候会用excel排序后对比，有时候也会写个临时代码来弄，但还是比较麻烦。</p>\n<p>发现了有这类在线工具，可网上搜索：集合比较。</p>\n<p>推荐1个我找到的：</p>\n<p><a href=\"https://jsons.top/menus.html\" rel=\"noopener nofollow\" target=\"_blank\">https://jsons.top/menus.html</a></p>\n<p><img alt=\"image-20260125141545909\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125141545909.png\" /></p>\n<p>或者现在也可以让大模型帮忙写一个，打成jar，随时可以本地执行。</p>\n<h1 id=\"问题3数据库序列设置\">问题3：数据库序列设置</h1>\n<p>我们现在用的国产数据库，是基于postgresql的，表的主键不是mysql那一套，都是从序列中获取。</p>\n<p>有时候我们会直接用insert语句插入数据库，且是手动指定了id值的：</p>\n<p><img alt=\"image-20260125141909399\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125141909399.png\" /></p>\n<p>这种sql执行完成后，由于是手动设置的id值，没从序列中获取，所以序列中的id值可能还是旧的，比如上述图片中，设置的id值都到4了。假设序列的最新值还是3，下一次有人从序列里取值，就会取到4，然后插入的话，就会报主键冲突。</p>\n<p>所以，我们自己得记得，执行了手动指定了id的sql后，要把序列值同步更新：</p>\n<p>就可以执行如下sql：</p>\n<pre><code class=\"language-sql\">-- 手动更新序列的值。设置序列table_config_id_seq的最新值为table_config中的最大值\nSELECT setval('table_config_id_seq', (SELECT max(id) FROM table_config));   \n\n-- 查看序列的当前值\nselect currval('table_config_id_seq');\t\n</code></pre>\n<h1 id=\"问题4dbeaver离线环境下下载驱动失败\">问题4：dbeaver离线环境下下载驱动失败</h1>\n<p>在没有互联网的机器上，安装了dbeaver，也会发现真正去连接数据库的时候，竟然还要联网去下载驱动，此时就会报错。</p>\n<p>我们可以这样，先在能联网的机器上，找到对应的数据库驱动（就是各种驱动jar包）：</p>\n<p><img alt=\"image-20260125142804539\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125142804539.png\" /></p>\n<p><img alt=\"image-20260125142835353\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125142835353.png\" /></p>\n<p><img alt=\"image-20260125142851236\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125142851236.png\" /></p>\n<p>拿到这个jar包后，拷贝到离线环境中，同样是在上述窗口中，删除全部的老的记录，再add file添加jar包，重连即可：</p>\n<p><img alt=\"image-20260125143005996\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260125143005996.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 14:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/grey-wolf\">三国梦回</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "构建基于 cc-switch 与 sdcb/chats 的AI 编程基础设施",
      "link": "https://www.cnblogs.com/shanyou/p/19527405",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/shanyou/p/19527405\" id=\"cb_post_title_url\" title=\"发布于 2026-01-25 09:24\">\n    <span>构建基于 cc-switch 与 sdcb/chats 的AI 编程基础设施</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        通过将&nbsp;cc-switch&nbsp;的客户端编排能力与&nbsp;sdcb/chats&nbsp;的网关处理能力相结合，我们构建了一个强大、灵活且安全可控的本地 AI 开发环境。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>1. 摘要</h1>\n<p><span>在生成式人工智能（Generative AI）技术从实验室走向生产环境的过程中，企业与开发者面临着前所未有的基础设施挑战。随着大型语言模型（LLM）能力的指数级增长，特别是具备长上下文窗口和复杂推理能力的模型（如 Claude 4.5 Sonnet、GPT-5.2）的普及，传统的 API 直接调用模式已难以满足安全合规、成本控制及多环境管理的复杂需求。当前，一种“客户端-网关-模型”的三层架构正在成为业界构建本地化 AI 开发环境的标准范式。本文将深入剖析这一架构的具体实现，重点阐述如何利用 <strong>cc-switch</strong> 作为客户端配置编排中枢，通过统一的自定义协议连接至 <strong>sdcb/chats</strong> 这一高性能自托管 AI 网关，从而构建出一套既具备极高灵活性又能确保数据主权的完整生态系统。</span></p>\n<p><span>本文的核心价值在于解决了当前 AI 辅助编程（Agentic Coding）领域的一大痛点：工具链的碎片化。开发者常用的 CLI 工具（如 Claude Code、Codex）往往绑定特定的云端接入点，导致在内网环境、中转加速或多模型切换场景下配置繁琐且易出错。<strong>cc-switch</strong> 的出现，特别是其 v3.8.0 版本引入的 SQLite 持久化架构，为管理复杂的环境变量注入提供了原子级的稳定性保障。与此同时，<strong>sdcb/chats</strong> 在 v1.9.0 版本中对 Anthropic Messages API 的原生级支持（包括 Thinking 区块与签名验证），使其成为不仅是 UI 前端，更是企业级 API 网关的理想选择。 </span></p>\n<h1><span>2. 客户端架构深度解析：cc-switch 的演进与机制</span></h1>\n<p><span>作为整个链路的入口，客户端配置管理工具的稳定性直接决定了开发体验的流畅度。<strong>cc-switch</strong>（Claude Configuration Switch）并非简单的 Shell 脚本封装，而是一个基于 Rust 和 Tauri 构建的跨平台桌面应用，其设计哲学是在不侵入用户系统全局环境的前提下，实现应用级的上下文切换。</span></p>\n<h2><span>2.1 技术栈与架构选型</span></h2>\n<p><span><strong>cc-switch</strong> 采用了 Tauri 框架，这是一种追求极致轻量化和安全性的架构选择。与 Electron 动辄数百兆的内存占用不同，Tauri 利用操作系统的原生 WebView（macOS 上的 WebKit，Windows 上的 WebView2，Linux 上的 WebKitGTK）进行渲染，而后端逻辑则由高性能的 Rust 语言处理。这种架构使得 cc-switch 能够常驻系统托盘而几乎不消耗系统资源，这对于需要在后台静默监控环境变量冲突的工具至关重要。</span></p>\n<p><span>在 v3.8.0 版本之前，cc-switch 依赖于单一的 config.json 文件进行数据存储。随着用户对多端同步和复杂配置（如自定义 MCP 服务器、Prompt 模板）需求的增加，JSON 文件的局限性日益凸显——缺乏事务支持、并发写入风险以及查询效率低下。v3.8.0 引入的 <strong>SQLite + JSON 双层持久化架构</strong> 是其发展史上的重要里程碑 <sup>1</sup>。</span></p>\n<h6><span>表 2.1 cc-switch 双层持久化架构对比分析</span></h6>\n<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"104\">\n<p><strong><span>特性维度</span></strong></p>\n</td>\n<td valign=\"top\" width=\"158\">\n<p><span><strong>JSON </strong><strong>层 (Device-Level)</strong></span></p>\n</td>\n<td valign=\"top\" width=\"145\">\n<p><span><strong>SQLite </strong><strong>层 (Syncable Data)</strong></span></p>\n</td>\n<td valign=\"top\" width=\"217\">\n<p><strong><span>架构意义</span></strong></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"104\">\n<p><strong><span>存储内容</span></strong></p>\n</td>\n<td valign=\"top\" width=\"158\">\n<p><span>窗口位置、本地路径覆盖、当前选中 ID</span></p>\n</td>\n<td valign=\"top\" width=\"145\">\n<p><span>供应商配置、MCP 服务器、Prompts、Skills</span></p>\n</td>\n<td valign=\"top\" width=\"217\">\n<p><span>实现“数据跟随账户，状态跟随设备”的分离策略</span></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"104\">\n<p><strong><span>同步策略</span></strong></p>\n</td>\n<td valign=\"top\" width=\"158\">\n<p><span>本地保留，不参与云同步</span></p>\n</td>\n<td valign=\"top\" width=\"145\">\n<p><span>支持全量/增量同步（未来规划）</span></p>\n</td>\n<td valign=\"top\" width=\"217\">\n<p><span>解决多设备间路径不一致（如 Windows vs macOS）导致的配置冲突</span></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"104\">\n<p><strong><span>事务支持</span></strong></p>\n</td>\n<td valign=\"top\" width=\"158\">\n<p><span>无（依赖文件锁）</span></p>\n</td>\n<td valign=\"top\" width=\"145\">\n<p><span>ACID 事务支持</span></p>\n</td>\n<td valign=\"top\" width=\"217\">\n<p><span>防止在配置切换过程中因进程崩溃导致的数据损坏</span></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"104\">\n<p><strong><span>迁移机制</span></strong></p>\n</td>\n<td valign=\"top\" width=\"158\">\n<p><span>无</span></p>\n</td>\n<td valign=\"top\" width=\"145\">\n<p><span>自动迁移引擎 (Auto Migration)</span></p>\n</td>\n<td valign=\"top\" width=\"217\">\n<p><span>首次启动自动将旧版 config.json 数据导入 SQLite，保证无缝升级</span></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"104\">\n<p><strong><span>查询性能</span></strong></p>\n</td>\n<td valign=\"top\" width=\"158\">\n<p><span>全量加载解析</span></p>\n</td>\n<td valign=\"top\" width=\"145\">\n<p><span>索引查询</span></p>\n</td>\n<td valign=\"top\" width=\"217\">\n<p><span>极大提升了在拥有数百个 Prompt 或几十个 Provider 时的加载速度</span></p>\n</td>\n</tr>\n</tbody>\n</table>\n<h2>2.2 环境变量注入与冲突检测机制</h2>\n<p><span>cc-switch 的核心职能是充当“配置代理”。当用户在 UI 中激活某个供应商（Provider）时，它并不会修改操作系统的全局环境变量（这需要管理员权限且不仅即时生效），而是通过修改目标应用（如 Claude Code CLI）特定的配置文件或钩子脚本来实现。</span></p>\n<p><span>对于 <strong>Claude Code</strong>，cc-switch 主要管控以下核心变量：</span></p>\n<p><span>● <strong>ANTHROPIC_BASE_URL</strong>：这是实现自定义网关连接的关键。默认情况下，Claude CLI 指向 https://api.anthropic.com。cc-switch 将此值覆写为用户配置的网关地址（例如 http://localhost:8080/v1）。</span></p>\n<p><span>● <strong>ANTHROPIC_API_KEY</strong>：注入由网关颁发或管理的 API 密钥。</span></p>\n<p><span>● <strong>ANTHROPIC_DEFAULT_MODEL</strong>：虽然 Claude Code 自身具备模型协商能力，但在某些企业场景下，管理员可能强制指定模型版本（如锁定为 claude-3-5-sonnet-20240620 以控制成本）。</span></p>\n<p><span>v3.6 版本引入了 <strong>环境变量冲突检测（Environment Variable Conflict Detection）</strong> 功能。由于开发者的机器上可能同时安装了 Codex、OpenCode 和 Gemini CLI，这些工具可能通过 .env 文件或 shell profile 设定了相互冲突的变量。cc-switch 能够扫描进程树和常见的配置文件路径，识别出可能导致路由失效的“影子配置”，并向用户发出可视化警告。这种防御性编程设计极大降低了排查网络连接问题的时间成本。</span></p>\n<h5><span>2.3 Deep Link 协议与配置分发</span></h5>\n<p><span>为了便于团队内部快速分发统一的网关配置，cc-switch 实现了自定义 URL Scheme 协议 ccswitch://。这一机制允许管理员生成一个包含网关地址、加密后的 API Key 占位符以及必要参数的链接。 当开发者点击该链接时，操作系统唤起 cc-switch，并自动触发 <strong>Import Provider</strong> 流程。这不仅简化了入职配置流程，还确保了所有团队成员连接的是同一个服务端点，避免了手动输入 URL 带来的拼写错误风险。结合 SQLite 的结构化存储，这些导入的配置被安全地存入 providers 表中，并通过 atomic writes 机制防止写入中断。</span></p>\n<h1>3. 服务端架构深度解析：sdcb/chats 的网关哲学</h1>\n<p><span>如果说 cc-switch 是精密的指挥官，那么 <strong>sdcb/chats</strong> 就是强大的重型机械。作为一个基于.NET 10 构建的自托管 AI 网关与前端，它在性能、兼容性和扩展性上展现出了企业级的水准。</span></p>\n<h2><span>3.1.NET 10 高性能运行时</span></h2>\n<p><span>选择.NET 10（及之前的.NET 8/9 迭代）作为运行时环境，赋予了 sdcb/chats 显著的性能优势。相较于 Python 编写的网关（受限于 GIL 全局解释器锁）或 Node.js 网关（在高计算密集型任务下的瓶颈），C# 的强类型系统和先进的 JIT（Just-In-Time）编译器使得 sdcb/chats 能够在处理大量并发 WebSocket 连接和流式（Server-Sent Events, SSE）转发时保持极低的延迟。</span></p>\n<p><span>特别是在处理 <strong>Token 计数</strong> 和 <strong>流式响应解析</strong> 时，sdcb/chats 利用了.NET 的 Span&lt;T&gt; 和 Memory&lt;T&gt; 等零拷贝技术，大幅减少了内存分配，这对于需要长时间维持会话状态的 AI Agent 场景至关重要。</span></p>\n<h2>3.2 协议兼容性：Anthropic Messages API 的逆向与重构</h2>\n<p><span>在 v1.9.0 版本之前，大多数开源网关仅支持 OpenAI 的 Chat Completions API (/v1/chat/completions)。然而，随着 Claude 3.5 的发布及其配套工具 Claude Code 的流行，仅支持 OpenAI 协议已无法满足需求。Claude Code 严格依赖 Anthropic 的原生协议格式，特别是其独特的 <strong>Messages API</strong> (/v1/messages)。</span></p>\n<p><span>sdcb/chats 在 v1.9.0 中实现了一个里程碑式的突破：<strong>全栈兼容 Anthropic 协议</strong>。这不仅仅是 URL 路由的映射，更涉及深层的数据结构转换 ：</span></p>\n<p><span>● <strong>Thinking Block</strong><strong>（思维链）支持</strong>：Claude 的推理模型（如 Claude 3.7 Sonnet）在输出最终代码前，会先输出一段 &lt;thinking&gt; 标签包裹的思维过程。普通的 OpenAI 兼容网关往往会将其视为普通文本直接返回，或者错误地截断。sdcb/chats 引入了 StepContentThink 数据库表，专门用于存储和结构化展示这一过程，确保客户端能正确渲染“思考中...”的状态，而不是展示一堆乱码。</span></p>\n<p><span>● <strong>Signature</strong><strong>（签名）验证</strong>：Anthropic 的 API 在某些高安全模式下会返回签名字段以验证内容的完整性。sdcb/chats 的后端架构重构了 ChatService，支持这一签名流的透传与存储，确保了与官方 API 的行为一致性。</span></p>\n<p><span>● <strong>原生 HttpClient 重写</strong>：为了适配 Claude 的流式传输特性，后端核心组件 AnthropicChatService 使用原生 HttpClient 进行了重写（涉及约 969 行代码变动），摒弃了可能存在兼容性问题的第三方 SDK 封装，从而支持了 JsonPolymorphic 属性来精确处理各种流式事件 <sup><ins datetime=\"2026-01-24T19:37\">3</ins></sup>。</span></p>\n<h2>3.3 数据持久化与多数据库支持</h2>\n<p><span>作为企业级网关，数据的可靠性是底线。sdcb/chats 提供了极其灵活的数据库适配方案：</span></p>\n<p><span>● <strong>SQLite</strong>：默认配置，适合个人开发者或小团队快速部署。无需安装额外服务，数据库仅为一个 .db 文件，备份极其方便 <sup>7</sup>。</span></p>\n<p><span>● <strong>PostgreSQL / SQL Server</strong>：针对需要高并发写入、读写分离或高级报表功能的企业环境。sdcb/chats 的 ORM 层设计允许通过简单的环境变量 DBType 切换底层存储引擎，而无需修改代码 <sup>8</sup>。 这种灵活性使得从个人笔记本上的验证原型（PoC）平滑迁移到基于 Kubernetes 的生产集群成为可能。</span></p>\n<h1><span>4. 集成实施指南：从部署到联调</span></h1>\n<p><span>本节将提供详尽的分步操作指南，指导如何将 cc-switch 连接到 sdcb/chats。我们将假设读者具备基本的 Docker 和命令行操作能力。</span></p>\n<h2>4.1 第一阶段：部署网关 (sdcb/chats)</h2>\n<p><span>由于 sdcb/chats 提供了官方 Docker 镜像，这是最推荐的部署方式，能够屏蔽不同操作系统（Linux/Windows/macOS）带来的环境差异。</span></p>\n<h3><span>4.1.1 Docker Compose 编排</span></h3>\n<p><span>为了确保配置的可维护性，建议使用 docker-compose.yml 而非单行 docker run 命令。以下是一个经过生产环境验证的配置模板：</span></p>\n<p><span>services:</span></p>\n<p><span>sqlserver:</span></p>\n<p><span>image: mcr.microsoft.com/mssql/server:2025-latest</span></p>\n<p><span>container_name: chats-sqlserver</span></p>\n<p><span>environment:</span></p>\n<p><span>ACCEPT_EULA: \"Y\"</span></p>\n<p><span>MSSQL_SA_PASSWORD: \"xxxxxx\"</span></p>\n<p><span>MSSQL_PID: \"Developer\"</span></p>\n<p><span>ports:</span></p>\n<p><span>- \"1433:1433\"</span></p>\n<p><span>volumes:</span></p>\n<p><span>- sqlserver_data:/var/opt/mssql</span></p>\n<p><span>restart: unless-stopped</span></p>\n<p><span>chats:</span></p>\n<p><span>image: sdcb/chats:1.10</span></p>\n<p><span>container_name: sdcb-chats</span></p>\n<p><span>depends_on:</span></p>\n<p><span>- sqlserver</span></p>\n<p><span>environment:</span></p>\n<p><span>DBType: \"sqlserver\"</span></p>\n<p><span>ConnectionStrings__ChatsDB: \"Server=sqlserver;Database=ChatsDB;User Id=sa;Password=xxxxxx;TrustServerCertificate=True;Encrypt=False\"</span></p>\n<p><span>ports:</span></p>\n<p><span>- \"8080:8080\"</span></p>\n<p><span>volumes:</span></p>\n<p><span>- ./AppData:/app/AppData</span></p>\n<p><span>restart: unless-stopped</span></p>\n<p><span>volumes:</span></p>\n<p><span>sqlserver_data:</span></p>\n<p><strong><span>关键配置解析：</span></strong></p>\n<p><span>● <strong>端口映射</strong>：80:8080。注意，容器内部通常监听 8080 端口，而我们将外部访问端口设为 8080。这个 <strong>8080</strong> 就是后续在 cc-switch 中配置的端口 。</span></p>\n<p><span>● <strong>数据卷</strong>：./app_data:/app/AppData。这是必须的配置。如果不挂载此卷，容器重启后，所有的 API Key、用户数据和聊天记录将全部丢失。</span></p>\n<p><span>● <strong>数据库类型</strong>：显式指定 DBType=sqlserver 能够避免程序在启动时猜测数据库类型，加快启动速度。</span></p>\n<p><span>启动服务：</span></p>\n<p><span>docker-compose up -d</span></p>\n<p><span>启动后，通过浏览器访问 http://localhost:8080，如果能看到登录界面，说明网关已正常运行。</span></p>\n<h3>4.1.2 API 密钥生成与权限管控</h3>\n<p><span>在将网关暴露给客户端之前，必须配置鉴权机制。sdcb/chats v1.9.0 引入了专门的 <strong>Build（开发者）</strong> 模块 。</span></p>\n<p><span>1. <strong>管理员登录</strong>：使用初始账号登录系统。</span></p>\n<p><span>2. <strong>进入开发者中心</strong>：点击导航栏的“API” 菜单。</span></p>\n<p><span>3. <strong>密钥管理</strong>：选择“API Key”。</span></p>\n<p><span>4. <strong>创建密钥</strong>：点击“Create New Key”。建议为每个客户端（如“Laptop-Claude-Code”）创建一个独立的 Key，并设置合理的过期时间（如 90 天）。</span></p>\n<p><span>5. <strong>复制密钥</strong>：系统生成的密钥（例如 sk-sdcb-8f7a...）仅在创建时显示一次，务必妥善保存。该密钥将用于 cc-switch 的鉴权。</span></p>\n<h2>4.2 第二阶段：配置客户端 (cc-switch)</h2>\n<p><span>回到客户端机器，我们将利用 cc-switch 的自定义提供商功能来接入刚刚搭建的网关。</span></p>\n<h3>4.2.1 添加自定义提供商 (Custom Provider)</h3>\n<p><span>打开 cc-switch 主界面：</span></p>\n<p><span>1. 点击右上角的 <strong>Add Provider (+)</strong> 按钮。</span></p>\n<p><span>2. 在弹出的配置窗口中，<strong>Schema</strong> 类型的选择至关重要。</span></p>\n<p><span>○ <strong>Provider Name</strong>: 输入易于识别的名称，例如 Local-Gateway 或 Sdcb-Dev。</span></p>\n<p><span>○ <strong>API Key</strong>: 粘贴在 4.1.2 步骤中生成的 sk-sdcb-... 密钥。</span></p>\n<p><span>○ <strong>API URL (Base URL)</strong>: 这是最容易出错的环节。</span></p>\n<p><span>■ 根据 sdcb/chats 的文档和 Anthropic SDK 的规范，Base URL 通常指向 API 的根路径。</span></p>\n<p><span>■ <strong>推荐配置</strong>: http://localhost:8080</span></p>\n<p><span>■ <strong>原理解析</strong>: Claude Code 的 SDK 会自动在 Base URL 后追加 /v1/messages。如果你配置成 http://localhost:8080/v1，SDK 可能会请求 http://localhost:8080/v1/v1/messages 导致 404 错误。反之，如果 SDK 较为“智能”地去除了末尾斜杠，配置为 http://localhost:8080/v1 也是可行的。建议先尝试根路径。</span></p>\n<p><span><del datetime=\"2026-01-24T19:37\"><img alt=\"表格\n\nAI 生成的内容可能不正确。\" height=\"341\" src=\"https://img2024.cnblogs.com/blog/510/202601/510-20260125092333153-1660708092.png\" width=\"624\" /></del><del datetime=\"2026-01-24T19:37\"></del></span></p>\n<h3>4.2.2 连通性测试 (Speed Test)</h3>\n<p><span>配置完成后，不要急于启用。在 Provider 列表中找到新建的 Local-Gateway：</span></p>\n<p><span>1. 点击条目右侧的 <strong>Speed Test（测速）</strong> 图标（通常是一个闪电或仪表盘图标）。</span></p>\n<p><span>2. cc-switch 会向该 URL 发送一个轻量级的 HEAD 或 GET 请求（通常是查询模型列表 /v1/models 或 /models）。</span></p>\n<p><span>3. <strong>绿色指标</strong>：表示 TCP 连接建立成功，且 HTTP 状态码正常（200 OK）。</span></p>\n<p><span>4. <strong>红色指标</strong>：表示连接失败。常见原因包括：</span></p>\n<p><span>○ Docker 容器未启动。</span></p>\n<p><span>○ 防火墙拦截了 8080 端口。</span></p>\n<p><span>○ URL 拼写错误（如多余的空格）。</span></p>\n<h2>4.3 第三阶段：全链路联调与验证</h2>\n<h6><span>4.3.1 激活与环境注入</span></h6>\n<p><span>在 cc-switch 中选中 Local-Gateway 并点击 <strong>Enable</strong>。此时，cc-switch 会将以下变量写入当前用户的 Shell 配置文件或临时的 session 变量中：<ins datetime=\"2026-01-24T19:37\"></ins></span></p>\n<p><span>export ANTHROPIC_BASE_URL=\"http://localhost:8080\"<br />export ANTHROPIC_API_KEY=\"sk-sdcb-...<ins datetime=\"2026-01-24T19:37\">\"</ins></span></p>\n<p><span><strong>注意</strong>：为了确保变量生效，建议重启终端窗口，或者在当前终端执行 source ~/.zshrc (或 .bashrc)。</span></p>\n<h6><span>4.3.2 运行 Claude Code</span></h6>\n<p><span>在终端中启动 Claude Code：<ins datetime=\"2026-01-24T19:37\"></ins></span></p>\n<p><span>claude</span></p>\n<p><span>或者使用诊断命令：<ins datetime=\"2026-01-24T19:37\"></ins></span></p>\n<p><span>claude doctor</span></p>\n<p><span>如果集成成功，doctor 命令的输出中应包含：</span></p>\n<p><span>● <strong>API Endpoint</strong>: http://localhost:8080 (Override detected)</span></p>\n<p><span>● <strong>Connection Status</strong>: OK</span></p>\n<p><span>尝试发送一个简单的指令，例如“Hello, who are you?”。</span></p>\n<p><span>● 请求路径：Claude CLI -&gt; cc-switch Env -&gt; http://localhost:8080/v1/messages</span></p>\n<p><span>● 处理逻辑：sdcb/chats 接收请求 -&gt; 鉴权通过 -&gt; 转发至后台配置的模型（如 OpenAI GPT-4o 经转换后） -&gt; 返回响应。</span></p>\n<p><span>● 响应路径：sdcb/chats 将响应转换为 Anthropic 格式（包含 content, role, id 等字段） -&gt; Claude CLI 渲染输出。</span></p>\n<h1>5. 高级特性与企业级应用场景</h1>\n<p><span>基础连接打通后，我们可以利用这一架构实现更多高级功能，充分发挥本地网关的潜力。</span></p>\n<h2>5.1 协议转换：用 OpenAI 模型驱动 Claude 工具链</h2>\n<p><span>这是一个极具吸引力的场景。由于 sdcb/chats 具备协议转换能力，我们可以在后端配置一个 OpenAI 的模型（如 gpt-4o-mini），但在前端（Claude Code）看来，它仍然是在与一个 Anthropic 模型对话。</span></p>\n<p><span><strong>实现原理</strong>：</span></p>\n<p><span>1. 在 sdcb/chats 后台，添加一个 OpenAI 提供商，并添加模型 gpt-5.2-chat，模型显示名称anthropic/claude-sonnet-4.5，让Claude Code 认为他调用的是claude-4-5-sonnet。</span></p>\n<p><span>2. 当 Claude Code 发出请求指定 model: </span><a name=\"OLE_LINK1\"></a><span>claude-</span><span>4-5-sonnet 时，网关拦截该请求，将其翻译为 OpenAI 的 Chat Completions 格式，发送给 OpenAI，收到回复后，再将 OpenAI 的 Delta 响应翻译回 Anthropic 的 Message Delta 格式。<br /><strong>价值</strong>：这允许开发者利用 Claude Code 优秀的代码交互体验（Agentic Workflow），同时利用 OpenAI 模型在某些特定任务上的优势或更低廉的价格。</span></p>\n<p><span><img alt=\"图形用户界面\n\nAI 生成的内容可能不正确。\" height=\"777\" src=\"https://img2024.cnblogs.com/blog/510/202601/510-20260125092333349-1800839900.png\" width=\"624\" /></span></p>\n<h2><span>5.2 集中化管理 MCP 服务器</span></h2>\n<p><span>Model Context Protocol (MCP) 是连接 AI 与本地数据的桥梁。在 cc-switch v3.8.0 的 SQLite 架构中，MCP 服务器的配置被集中管理 <sup>1</sup>。 <strong>工作流</strong>：</span></p>\n<p><span>1. 在 cc-switch 的 <strong>MCP Servers</strong> 标签页中，添加本地的数据库连接工具（如 sqlite-mcp）或文件系统工具。</span></p>\n<p><span>2. 这些配置被存储在 cc-switch.db 中。</span></p>\n<p><span>3. 当启用 Local-Gateway 时，cc-switch 不仅注入 API URL，还会生成对应的 claude_desktop_config.json 文件。</span></p>\n<p><span>4. <strong>关键点</strong>：sdcb/chats 网关本身<strong>不</strong>直接执行 MCP 工具。MCP 的执行仍然发生在客户端（Claude CLI）。网关的作用是传递 Tool Definition（工具定义）和 Tool Call（工具调用请求）。</span></p>\n<p><span>5. 这意味着，即使是通过网关连接，你依然可以安全地使用本地的 MCP 工具，网关只是负责文本推理，数据的实际读写由本地 CLI 进程控制，这在安全性上是一个巨大的优势。</span></p>\n<h2>5.3 审计与合规 (DLP)</h2>\n<p><span>对于企业而言，直接允许开发者连接公有云 API 存在数据泄露风险。通过 sdcb/chats 网关，企业可以实施：</span></p>\n<p><span>● <strong>敏感数据拦截</strong>：在网关层集成 PII（个人身份信息）扫描插件，阻止包含信用卡号或私钥的代码片段发送到上游模型。</span></p>\n<p><span>● <strong>成本配额</strong>：为不同部门设置不同的 Token 使用上限，防止意外的高额账单。</span></p>\n<h1>6. 故障排查与性能调优</h1>\n<p><span>在复杂的分布式系统中，故障在所难免。以下是针对该架构的深度故障排查指南。</span></p>\n<h2>6.1 常见错误代码解析</h2>\n<h6><span>404 Not Found</span></h6>\n<p><span>● <strong>现象</strong>：cc-switch 测速失败，或 Claude 提示 API 端点不可达。</span></p>\n<p><span>● <strong>原因分析</strong>：</span></p>\n<p><span>1. <strong>URL </strong><strong>路径错误</strong>：最常见。用户填写了 .../v1/messages，导致最终请求变成 .../v1/messages/v1/messages。</span></p>\n<p><span>2. <strong>网关未启动</strong>：Docker 容器挂了。</span></p>\n<p><span>● <strong>解决方案</strong>：</span></p>\n<p><span>○ 检查 cc-switch 中的 Base URL 是否精简为 http://host:port。</span></p>\n<p><span>○ 使用 docker logs sdcb-chats 查看容器日志，确认监听端口。</span></p>\n<h6><span>401 Unauthorized</span></h6>\n<p><span>● <strong>现象</strong>：连接成功，但请求被拒绝。</span></p>\n<p><span>● <strong>原因分析</strong>：</span></p>\n<p><span>1. <strong>API Key </strong><strong>错误</strong>：复制了错误的 Key，或 Key 已过期。</span></p>\n<p><span>2. <strong>Header </strong><strong>缺失</strong>：某些中间代理（Nginx）过滤掉了 x-api-key 或 anthropic-api-key 头。</span></p>\n<p><span>● <strong>解决方案</strong>：</span></p>\n<p><span>○ 在 sdcb/chats 后台重新生成 Key。</span></p>\n<p><span>○ 检查中间代理配置，确保透传所有自定义 Header。</span></p>\n<h6><span>Stream Interrupted / Thinking Block Missing</span></h6>\n<p><span>● <strong>现象</strong>：回复中断，或者明明使用的是推理模型，却看不到思考过程。</span></p>\n<p><span>● <strong>原因分析</strong>：</span></p>\n<p><span>1. <strong>网关版本过低</strong>：使用 v1.9.0 之前的版本，不支持 Thinking 字段解析。</span></p>\n<p><span>2. <strong>缓冲区配置</strong>：Nginx 等反向代理开启了 Response Buffering，导致流式数据无法实时到达客户端，直到超时。</span></p>\n<p><span>● <strong>解决方案</strong>：</span></p>\n<p><span>1. 升级 sdcb/chats 至最新版。</span></p>\n<p><span>2. 在 Nginx 配置中关闭缓冲：proxy_buffering off;。</span></p>\n<h2><span>6.2 性能调优建议</span></h2>\n<p><span>● <strong>数据库优化</strong>：如果使用 SQLite 且并发量较大，可能会遇到 database is locked 错误。建议迁移至 PostgreSQL/SQLServer。</span></p>\n<p><span>● <strong>网络延迟</strong>：尽量确保 cc-switch 和 sdcb/chats 部署在低延迟的网络环境中（如局域网）。每一毫秒的延迟在流式传输中都会被放大，影响“打字机”效果的流畅度。</span></p>\n<h4>&nbsp;</h4>\n<h1>7. 结论与展望</h1>\n<p><span>通过将 <strong>cc-switch</strong> 的客户端编排能力与 <strong>sdcb/chats</strong> 的网关处理能力相结合，我们构建了一个强大、灵活且安全可控的本地 AI 开发环境。这一架构不仅解决了 API 管理的碎片化问题，还通过中间层的引入，为未来的功能扩展（如私有模型微调接入、统一的知识库检索增强 RAG）预留了接口。</span></p>\n<p><span>随着 AI 技术的演进，<strong>“瘦客户端（CLI）+ 胖网关（Gateway）+ 强模型（Model）”</strong> 的架构将日益成为主流。<strong>cc-switch</strong> 和 <strong>sdcb/chats</strong> 作为各自领域的佼佼者，其深度集成不仅是技术上的互补，更是开源生态协作精神的体现。对于追求极致效率和数据安全的开发者与企业而言，这套方案无疑是当前最佳的实践路径之一。</span></p>\n<h2>引用的文章</h2>\n<p><span>1. cc-switch/docs/release-note-v3.8.0-en.md， </span><a href=\"https://github.com/farion1231/cc-switch/blob/main/docs/release-note-v3.8.0-en.md\" rel=\"noopener nofollow\"><span>https://github.com/farion1231/cc-switch/blob/main/docs/release-note-v3.8.0-en.md</span></a></p>\n<p><span>2. cc-switch/docs/release-note-v3.8.0-zh.md </span><a href=\"https://github.com/farion1231/cc-switch/blob/main/docs/release-note-v3.8.0-zh.md\" rel=\"noopener nofollow\"><span>https://github.com/farion1231/cc-switch/blob/main/docs/release-note-v3.8.0-zh.md</span></a></p>\n<p><span>3. chats/doc/en-US/release-notes/1.9.0.md at main， </span><a href=\"https://github.com/sdcb/chats/blob/main/doc/en-US/release-notes/1.9.0.md\" rel=\"noopener nofollow\"><span>https://github.com/sdcb/chats/blob/main/doc/en-US/release-notes/1.9.0.md</span></a></p>\n<p><span>4. README.md - farion1231/cc-switch  </span><a href=\"https://github.com/farion1231/cc-switch/blob/main/README.md\" rel=\"noopener nofollow\"><span>https://github.com/farion1231/cc-switch/blob/main/README.md</span></a></p>\n<p><span>5. CHANGELOG.md - farion1231/cc-switch， </span><a href=\"https://github.com/farion1231/cc-switch/blob/main/CHANGELOG.md\" rel=\"noopener nofollow\"><span>https://github.com/farion1231/cc-switch/blob/main/CHANGELOG.md</span></a></p>\n<p><span>6. I just released Sdcb.Chats v1.9.0, a major update to my open-source .NET AI Gateway: adds full support for Claude 4.5 (Opus/Sonnet), OpenAI Image APIs, and is now built on .NET 10 : r/dotnet - Reddit, </span><a href=\"https://www.reddit.com/r/dotnet/comments/1pc1nxd/i_just_released_sdcbchats_v190_a_major_update_to/\" rel=\"noopener nofollow\"><span>https://www.reddit.com/r/dotnet/comments/1pc1nxd/i_just_released_sdcbchats_v190_a_major_update_to/</span></a></p>\n<p><span>7. README.md - sdcb/chats， </span><a href=\"https://github.com/sdcb/chats/blob/main/README.md\" rel=\"noopener nofollow\"><span>https://github.com/sdcb/chats/blob/main/README.md</span></a></p>\n<p><span>8. sdcb/chats: User-friendly Enterprise Ready AI Interface (Supports Ollama, OpenAI API, DeepSeek...) </span><a href=\"https://github.com/sdcb/chats\" rel=\"noopener nofollow\"><span>https://github.com/sdcb/chats</span></a></p>\n<p><span>9. Publishing and exposing ports | Docker Docs </span><a href=\"https://docs.docker.com/get-started/docker-concepts/running-containers/publishing-ports/\" rel=\"noopener nofollow\"><span>https://docs.docker.com/get-started/docker-concepts/running-containers/publishing-ports/</span></a></p>\n<p><span>10. farion1231/cc-switch: A cross-platform desktop All-in-One .. </span><a href=\"https://github.com/farion1231/cc-switch\" rel=\"noopener nofollow\"><span>https://github.com/farion1231/cc-switch</span></a></p>\n<p><span>11. cc-switch/docs/release-note-v3.9.0-en.md at main </span><a href=\"https://github.com/farion1231/cc-switch/blob/main/docs/release-note-v3.9.0-en.md\" rel=\"noopener nofollow\"><span>https://github.com/farion1231/cc-switch/blob/main/docs/release-note-v3.9.0-en.md</span></a></p>\n</div>\n<div id=\"MySignature\">\n    <p>欢迎大家扫描下面二维码成为我的客户，扶你上云</p>\n<img src=\"https://images.cnblogs.com/cnblogs_com/shanyou/57459/o_220125090408_%E9%82%80%E8%AF%B7%E4%BA%8C%E7%BB%B4%E7%A0%81-258px.jpeg\" width=\"170\" />\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-25 09:24</span>&nbsp;\n<a href=\"https://www.cnblogs.com/shanyou\">张善友</a>&nbsp;\n阅读(<span id=\"post_view_count\">38</span>)&nbsp;\n评论(<span id=\"post_comment_count\">3</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "STM32之控制变量与函数的存储位置",
      "link": "https://www.cnblogs.com/lsksp/p/19527780",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lsksp/p/19527780\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 23:01\">\n    <span>STM32之控制变量与函数的存储位置</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        STM32 内存定位是优化系统性能、解决硬件兼容性问题的核心技巧，可解决 Cache 与 DMA 冲突、利用 ITCM/DTCM 提升访问速度、固定 DMA 缓冲区到合规的连续物理内存。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"stm32之控制变量与函数的存储位置\">STM32之控制变量与函数的存储位置</h1>\n<p>STM32 内存定位是优化系统性能、解决硬件兼容性问题的核心技巧，可解决 Cache 与 DMA 冲突、利用 ITCM/DTCM 提升访问速度、固定 DMA 缓冲区到合规的连续物理内存。</p>\n<h2 id=\"一变量定位方法\">一、变量定位方法</h2>\n<p>变量定位分两种方式，适配「单个变量精准定位」和「批量变量管理」场景。</p>\n<h3 id=\"方法-1attribute--内存地址单个变量\">方法 1：<strong>attribute</strong> + 内存地址（单个变量）</h3>\n<p>利用编译器<code>__attribute__((at(address)))</code>属性，直接绑定变量到指定地址，简单高效。</p>\n<pre><code class=\"language-c\">// 示例：uint32_t数组定位到0x20001000（4字节对齐）\n__ALIGNED(4) __attribute__((at(0x20001000))) uint32_t dma_buffer[1024] = {0};\n</code></pre>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>地址需在芯片有效内存范围，否则触发硬件故障；</li>\n<li>满足数据对齐要求（char=1 字节、short=2 字节、int/float=4 字节、double=8 字节）；</li>\n<li>避免与系统变量 / 栈 / 堆地址重叠（可查.map 文件确认）。</li>\n</ul>\n<h3 id=\"方法-2attribute--段名--分散加载文件批量变量\">方法 2：<strong>attribute</strong> + 段名 + 分散加载文件（批量变量）</h3>\n<p>批量定位多变量时，通过「自定义段名 + 分散加载文件」实现统一管理。</p>\n<h4 id=\"1-定义带自定义段名的变量\">1. 定义带自定义段名的变量</h4>\n<pre><code class=\"language-c\">// 多DMA缓冲区归类到\"MY_DMA_BUFFER\"段\n__attribute__((section(\"MY_DMA_BUFFER\"))) uint32_t uart_dma_buf[512] = {0};\n__attribute__((section(\"MY_DMA_BUFFER\"))) uint8_t i2c_dma_buf[256] = {0};\n</code></pre>\n<h4 id=\"2-修改分散加载文件sct\">2. 修改分散加载文件（.sct）</h4>\n<pre><code class=\"language-assembly\">; STM32内存定位示例 - 分散加载文件\nLR_IROM1 0x08000000 0x00020000  {      ; Flash加载区：0x08000000~0x08020000\n    ER_IROM1 0x08000000 0x00020000  {  ; Flash执行区\n        *.o (RESET, +First)\n        *(InRoot$$Sections)\n        .ANY (+RO)\n        .ANY (+XO)\n    }\n    RW_IRAM1 0x20000000 0x00020000  {  ; 普通SRAM数据区：0x20000000~0x20020000\n        .ANY (+RW +ZI)\n    }\n    ; 自定义DMA缓冲区段：0x20005000~0x20008000（12KB）\n    RW_DMA_BUFFER 0x20005000 0x00003000  {\n        *.o (MY_DMA_BUFFER)            ; 映射MY_DMA_BUFFER段到该区域\n    }\n}\n</code></pre>\n<h2 id=\"二函数定位方法\">二、函数定位方法</h2>\n<p>核心是将高频函数放到 ITCM 等高速内存提升执行速度，逻辑与变量类似，需映射到「执行区域」。</p>\n<h3 id=\"1-单个函数定位\">1. 单个函数定位</h3>\n<p>通过<code>__attribute__((section(\"段名\")))</code>标注函数，修改分散加载文件映射到 ITCM（以 STM32H7 的 ITCM=0x00000000 为例）。</p>\n<h4 id=\"1定义带段名的函数\">（1）定义带段名的函数</h4>\n<pre><code class=\"language-c\">// PID函数归类到MY_FUNC_SECTION段\n__attribute__((section(\"MY_FUNC_SECTION\"))) float pid_calc(float target, float current)\n{\n    static float err = 0, err_last = 0;\n    float kp = 1.2, ki = 0.1, kd = 0.05;\n    err = target - current;\n    float output = kp*err + ki*(err+err_last) + kd*(err-err_last);\n    err_last = err;\n    return output;\n}\n</code></pre>\n<h4 id=\"2修改分散加载文件\">（2）修改分散加载文件</h4>\n<pre><code class=\"language-assembly\">; 含函数定位的分散加载文件\nLR_IROM1 0x08000000 0x00020000  {      ; Flash加载区\n    ER_IROM1 0x08000000 0x00020000  {  ; Flash执行区\n        *.o (RESET, +First)\n        *(InRoot$$Sections)\n        .ANY (+RO)\n        .ANY (+XO)\n    }\n    RW_IRAM1 0x20000000 0x00020000  {  ; 普通SRAM数据区\n        .ANY (+RW +ZI)\n    }\n    ; ITCM执行区：0x00000000~0x00010000（64KB）\n    ER_ITCM 0x00000000 0x00010000  {\n        *.o (MY_FUNC_SECTION)          ; 映射函数段到ITCM\n    }\n}\n</code></pre>\n<h3 id=\"2-批量函数定位\">2. 批量函数定位</h3>\n<p>将整个.c 文件的函数定位到指定区域，两种方式：</p>\n<ul>\n<li>\n<p>编译器选项（ARMCC）：添加<code>--section=.text:MY_FUNC_SECTION</code>；</p>\n</li>\n<li>\n<p>分散加载文件直接指定文件：</p>\n<pre><code class=\"language-assembly\">ER_ITCM 0x00000000 0x00010000  {\n    pid.o (+XO)  ; pid.c所有可执行代码放到ITCM\n}\n</code></pre>\n</li>\n</ul>\n<h3 id=\"3-验证方法\">3. 验证方法</h3>\n<p>编译后打开工程<code>Output</code>文件夹的.map 文件，搜索函数名（如<code>pid_calc</code>），查看<code>Base Address</code>是否为 ITCM 起始地址（如 0x00000000 开头），确认定位成功。</p>\n<h2 id=\"三实战技巧与注意事项\">三、实战技巧与注意事项</h2>\n<h3 id=\"1-内存区域选择策略\">1. 内存区域选择策略</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">内存类型</th>\n<th style=\"text-align: center;\">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">DTCM</td>\n<td style=\"text-align: center;\">高频访问的全局变量（零等待周期）</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">ITCM</td>\n<td style=\"text-align: center;\">关键函数、中断服务程序</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">AXI SRAM</td>\n<td style=\"text-align: center;\">大容量 DMA 缓冲区</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">普通 SRAM</td>\n<td style=\"text-align: center;\">通用变量存储</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"2-缓存一致性处理\">2. 缓存一致性处理</h3>\n<p>使用 Cache 时，DMA 操作需保证缓存一致性：</p>\n<pre><code class=\"language-c\">// DMA发送前清理缓存\nSCB_CleanDCache_by_Addr(dma_buffer, sizeof(dma_buffer));\n\n// DMA接收后失效缓存\nSCB_InvalidateDCache_by_Addr(dma_buffer, sizeof(dma_buffer));\n</code></pre>\n<h3 id=\"3-核心注意事项\">3. 核心注意事项</h3>\n<ul>\n<li>地址越界：定位地址需匹配芯片内存范围，否则程序跑飞（核对芯片手册）；</li>\n<li>对齐错误：函数入口地址需 4 字节对齐，否则触发 HardFault 中断；</li>\n<li>Cache 一致性：Cache 区数据 / DMA 访问前需刷新缓存，避免数据错乱；</li>\n<li>段冲突：自定义段勿与系统段重叠，编译溢出需调整分散加载文件地址 / 大小。</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>STM32 内存定位是解决性能与兼容性问题的关键技能：</p>\n<ol>\n<li>变量可通过<code>__attribute__((at(地址)))</code>（单个）或段名 + 分散加载文件（批量）定位；</li>\n<li>函数需标注自定义段名，映射到 ITCM 等高速内存，通过.map 文件验证；</li>\n<li>需规避地址越界、对齐错误等问题，合理选择内存区域并处理缓存一致性。</li>\n</ol>\n<p>掌握该技术可显著提升 STM32 系统性能与可靠性，是嵌入式开发者进阶的必备技能。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 23:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lsksp\">比特向阳</a>&nbsp;\n阅读(<span id=\"post_view_count\">23</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一天一个Python库：charset-normalizer - 自动化字符编码检测与规范化",
      "link": "https://www.cnblogs.com/min2k/p/19527462",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/min2k/p/19527462\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 20:28\">\n    <span>一天一个Python库：charset-normalizer - 自动化字符编码检测与规范化</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"charset-normalizer---自动化字符编码检测与规范化\">charset-normalizer - 自动化字符编码检测与规范化</h1>\n<h2 id=\"一什么是charset-normalizer\">一、什么是charset-normalizer？</h2>\n<p><strong>charset-normalizer</strong> 是一个用于可靠检测各种文本文件或数据块的字符编码的 Python 库。<br />\n它可以帮助你：</p>\n<ul>\n<li>自动识别未知编码的文本。</li>\n<li>规范化文本，使其在不同系统间或应用程序中保持一致，避免乱码问题。</li>\n<li>处理因编码错误导致的数据解析问题。</li>\n</ul>\n<h2 id=\"二应用场景\">二、应用场景</h2>\n<p><strong>charset-normalizer</strong> 广泛应用于以下实际场景：</p>\n<ul>\n<li><strong>数据清洗</strong>: 在处理从不同来源（如网页抓取、文件导入）获取的数据时，自动检测并统一字符编码，解决乱码问题。</li>\n<li><strong>文本处理工具</strong>: 开发文本编辑器、日志分析器或其他需要处理多种编码文本的工具时，提供强大的编码识别能力。</li>\n<li><strong>国际化应用</strong>: 确保应用程序能够正确处理和显示来自全球各地的用户输入和内容，避免因编码不兼容而出现乱码。</li>\n</ul>\n<h2 id=\"三如何安装\">三、如何安装</h2>\n<ol>\n<li>使用 pip 安装</li>\n</ol>\n<pre><code class=\"language-bash\">pip install charset-normalizer\n\n# 如果安装慢的话，推荐使用国内镜像源\npip install charset-normalizer -i https://www.python64.cn/pypi/simple/\n</code></pre>\n<ol start=\"2\">\n<li>使用 <a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行代码（无需本地安装）</li>\n</ol>\n<h2 id=\"四示例代码\">四、示例代码</h2>\n<p>检测一个未知编码的字符串的编码，并进行解码。</p>\n<pre><code class=\"language-python\">from charset_normalizer import from_bytes\n\n# 尝试检测这个可能是乱码的字节串\nunknown_bytes = b'\\xc3\\xa9l\\xc3\\xa9phant'  # 这是一个UTF-8编码的'éléphant'\n\n# 使用 from_bytes 进行编码检测和规范化\ndetection_result = from_bytes(unknown_bytes)\n\n# 获取最佳匹配的字符编码\nif detection_result:\n    best_encoding = detection_result.best().encoding\n    decoded_string = str(detection_result) # 转换为字符串，默认使用最佳编码\n    print(f\"检测到的最佳编码是: {best_encoding}\")\n    print(f\"解码后的字符串是: {decoded_string}\")\nelse:\n    print(\"未能检测到合适的编码。\")\n\n# 另外一个例子：一个简单的ASCII字符串\nascii_bytes = b'hello world'\nascii_detection = from_bytes(ascii_bytes)\n\nif ascii_detection:\n    print(f\"\\n'hello world' 的最佳编码是: {ascii_detection.best().encoding}\")\n    print(f\"'hello world' 解码后: {str(ascii_detection)}\")\nelse:\n    print(\"\\n未能检测到 'hello world' 的编码。\")\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/python-run/?code=from%20charset_normalizer%20import%20from_bytes%0A%0A%23%20%E5%B0%9D%E8%AF%95%E6%A3%80%E6%B5%8B%E8%BF%99%E4%B8%AA%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B9%B1%E7%A0%81%E7%9A%84%E5%AD%97%E8%8A%82%E4%B8%B2%0Aunknown_bytes%20%3D%20b'%5Cxc3%5Cxa9l%5Cxc3%5Cxa9phant'%20%20%23%20%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AAUTF-8%E7%BC%96%E7%A0%81%E7%9A%84'%C3%A9l%C3%A9phant'%0A%0A%23%20%E4%BD%BF%E7%94%A8%20from_bytes%20%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%84%E8%8C%83%E5%8C%96%0Adetection_result%20%3D%20from_bytes%28unknown_bytes%29%0A%0A%23%20%E8%8E%B7%E5%8F%96%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%0Aif%20detection_result%3A%0A%20%20%20%20best_encoding%20%3D%20detection_result.best%28%29.encoding%0A%20%20%20%20decoded_string%20%3D%20str%28detection_result%29%20%23%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%0A%20%20%20%20print%28f%22%E6%A3%80%E6%B5%8B%E5%88%B0%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E6%98%AF%3A%20%7Bbest_encoding%7D%22%29%0A%20%20%20%20print%28f%22%E8%A7%A3%E7%A0%81%E5%90%8E%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%3A%20%7Bdecoded_string%7D%22%29%0Aelse%3A%0A%20%20%20%20print%28%22%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84%E7%BC%96%E7%A0%81%E3%80%82%22%29%0A%0A%23%20%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ASCII%E5%AD%97%E7%AC%A6%E4%B8%B2%0Aascii_bytes%20%3D%20b'hello%20world'%0Aascii_detection%20%3D%20from_bytes%28ascii_bytes%29%0A%0Aif%20ascii_detection%3A%0A%20%20%20%20print%28f%22%5Cn'hello%20world'%20%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E6%98%AF%3A%20%7Bascii_detection.best%28%29.encoding%7D%22%29%0A%20%20%20%20print%28f%22'hello%20world'%20%E8%A7%A3%E7%A0%81%E5%90%8E%3A%20%7Bstr%28ascii_detection%29%7D%22%29%0Aelse%3A%0A%20%20%20%20print%28%22%5Cn%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%20'hello%20world'%20%E7%9A%84%E7%BC%96%E7%A0%81%E3%80%82%22%29\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a> 在线运行这段代码，结果如下：</p>\n<pre><code class=\"language-text\">检测到的最佳编码是: utf_8\n解码后的字符串是: &lt;charset_normalizer.models.CharsetMatches object at 0x7fea543bdb40&gt;\n\n'hello world' 的最佳编码是: ascii\n'hello world' 解码后: &lt;charset_normalizer.models.CharsetMatches object at 0x7fea543bda80&gt;\n</code></pre>\n<p>使用 <a href=\"https://www.min2k.com/tools/mermaid/?code=flowchart%20TB%0A%20%20A%5B%E5%BC%80%E5%A7%8B%5D%20--%3E%20B%7B%E5%AE%9A%E4%B9%89%E5%AD%97%E8%8A%82%E4%B8%B2%20unknown_bytes%7D%3B%0A%20%20B%20--%3E%20C%5B%E8%B0%83%E7%94%A8%20from_bytes%28unknown_bytes%29%5D%3B%0A%20%20C%20--%3E%20D%7B%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C%20detection_result%20%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%3F%7D%3B%0A%20%20D%20--%20%E6%98%AF%20--%3E%20E%5B%E8%8E%B7%E5%8F%96%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%20best_encoding%5D%3B%0A%20%20E%20--%3E%20F%5B%E8%A7%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%20decoded_string%5D%3B%0A%20%20F%20--%3E%20G%5B%E6%89%93%E5%8D%B0%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%5D%3B%0A%20%20D%20--%20%E5%90%A6%20--%3E%20H%5B%E6%89%93%E5%8D%B0%22%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E7%BC%96%E7%A0%81%22%E6%B6%88%E6%81%AF%5D%3B%0A%20%20G%20--%3E%20I%7B%E5%AE%9A%E4%B9%89%E5%AD%97%E8%8A%82%E4%B8%B2%20ascii_bytes%7D%3B%0A%20%20H%20--%3E%20I%3B%0A%20%20I%20--%3E%20J%5B%E8%B0%83%E7%94%A8%20from_bytes%28ascii_bytes%29%5D%3B%0A%20%20J%20--%3E%20K%7B%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C%20ascii_detection%20%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%3F%7D%3B%0A%20%20K%20--%20%E6%98%AF%20--%3E%20L%5B%E6%89%93%E5%8D%B0%20ascii_bytes%20%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E5%90%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%5D%3B%0A%20%20K%20--%20%E5%90%A6%20--%3E%20M%5B%E6%89%93%E5%8D%B0%22%E6%9C%AA%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%20'hello%20world'%20%E7%9A%84%E7%BC%96%E7%A0%81%22%E6%B6%88%E6%81%AF%5D%3B%0A%20%20L%20--%3E%20N%5B%E7%BB%93%E6%9D%9F%5D%3B%0A%20%20M%20--%3E%20N%3B%0A\" rel=\"noopener nofollow\" target=\"_blank\">MermaidGo</a> 绘制示例代码的流程图，结果如下：</p>\n<p><img alt=\"MermerGo的charset-normalize的流程图\" class=\"lazyload\" /></p>\n<h2 id=\"五学习资源\">五、学习资源</h2>\n<ol>\n<li>开源项目：<a href=\"https://github.com/Ousret/charset_normalizer\" rel=\"noopener nofollow\" target=\"_blank\">charset-normalizer</a></li>\n<li>中文自述：<a href=\"https://www.python64.cn/readme/charset-normalizer/\" rel=\"noopener nofollow\" target=\"_blank\">REMDME</a></li>\n<li>在线运行：<a href=\"https://www.min2k.com/tools/python-run/\" rel=\"noopener nofollow\" target=\"_blank\">PythonRun</a></li>\n</ol>\n<blockquote>\n<p>如果这篇文章对你有帮助，欢迎点赞、收藏、转发！<br />\n学习过程中有任何问题，欢迎在评论区留言交流～</p>\n</blockquote>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 20:28</span>&nbsp;\n<a href=\"https://www.cnblogs.com/min2k\">敏编程</a>&nbsp;\n阅读(<span id=\"post_view_count\">42</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "MAF快速入门（13）常见智能体编排模式",
      "link": "https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper13",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper13\" id=\"cb_post_title_url\" title=\"发布于 2026-01-24 19:53\">\n    <span>MAF快速入门（13）常见智能体编排模式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"MAF快速入门（13）常见智能体编排模式\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124195158983-724601081.png\" />\n        事实上，在构建AI应用解决业务问题时，单个Agent往往无法胜任所有任务，常常需要我们将多个Agent组合起来系统工作。而这种组合与协调的方式，就被称为 Agent Orchestration 即 Agent编排。MAF支持多种多Agent编排流程模式，每个模式都针对不同的协作方案而设计。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><span><span>大家好，我是Edison。</span></span></p>\n<p><span><span>最近我一直在跟着圣杰的《<a class=\"normal_text_link mp_article_text_link\" href=\"https://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;mid=2651744458&amp;idx=1&amp;sn=139f7584e81aeecd0945133bdc2b4791&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\"><span>.NET+AI智能体开发进阶</span></a><span>》课程学习MAF开发多智能体工作流，我强烈推荐你也上车跟我一起出发！</span></span></span></p>\n<p><span><a class=\"normal_text_link mp_article_text_link\" href=\"https://www.cnblogs.com/edisontalk/p/-/quick-start-on-maf-chatper12\" target=\"_blank\"><span>上一篇</span></a><span>，我们学习了MAF中如何进行子工作流<span>。本篇，我们来了解下在MAF中如何快速实现一些常见的智能体编排模式。</span></span></span></p>\n<h1><span><span><span><strong>1 智能体编排模式介绍</strong></span></span></span></h1>\n<p>传统的单Agent系统在处理复杂多面任务的能力方面受到较多限制，因此我们会有多Agent编排协作完成任务的需求。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124091613961-245103765.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>事实上，在构建AI应用解决业务问题时，单个Agent往往无法胜任所有任务，常常需要我们将多个Agent组合起来系统工作。而这种组合与协调的方式，就被称为&nbsp;<strong>Agent Orchestration</strong>&nbsp;即&nbsp;Agent编排。</p>\n<p>MAF支持多种多Agent编排流程模式，每个模式都针对不同的协作方案而设计。这些模式作为框架的一部分提供出来，我们可以自己扩展。</p>\n<p><span><span><span>在MAF中，常见的Agent编排模式如下：</span></span></span></p>\n<ul class=\"list-paddingleft-1\">\n<li><span><span><span>Sequential 顺序编排：<span>即各个Agent依次处理并传递给下一个Agent执行；</span></span></span></span></li>\n<li><span><span><span>Concurrent 并发编排：<span>即多个Agent并行处理同一个任务，然后汇聚结果；</span></span></span></span></li>\n<li><span><span><span>Handoffs 移交编排：<span>即每个Agent都可以将对话移交给另一个Agent，确保每个Agent处理任务的某个部分；</span></span></span></span></li>\n<li><span><span><span>GroupChat 群聊编排：<span>即多个Agent加入了同一个微信群，通过群聊对话形成一些决策；</span></span></span></span></li>\n</ul>\n<p><span><span><span>对应到MAF中，<span><span>AgentWorkflowBuilder&nbsp;<span>类提供了这些编排模式的具体实现，我们开发者可以直接使用对应的接口即可快速完成有一次编排 而无需 自行实现Edge连接。</span></span></span></span></span></span></p>\n<h1><strong><span>2&nbsp;<strong><span>智能体编排模式详解</span></strong></span></strong></h1>\n<h3><strong><span><span>2.1 顺序编排</span></span></strong></h3>\n<p>在顺序编排模式中，各个Agent被组成一个流程，每个Agent都会处理任务，并将执行结果输出传递给下一个待执行的Agent。可以看出，对于每个基于上一步骤构建的工作流<span>（Workflow）来说，这是比较适合的模式。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124091657384-365298595.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>目前，像文档审阅、工作流、数据处理管道、多阶段推理等，是比较常见的应用场景。</p>\n<p>下面的代码展示了在MAF中的顺序编排实现：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">var</span> analyst = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> writer = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> editor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Build a Workflow</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> AgentWorkflowBuilder.BuildSequential(\n    </span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(128, 0, 0, 1);\">content-team-workflow</span><span style=\"color: rgba(128, 0, 0, 1);\">\"</span><span style=\"color: rgba(0, 0, 0, 1);\">, \n    [analyst, writer, editor]);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Test the Workflow</span>\n......</pre>\n</div>\n<p>可以看到，通过BuildSequential方法即可快速完成一次顺序编排。</p>\n<h3><span><span>2.2 并发编排</span></span></h3>\n<p>并发模式使用多个Agent并行处理同一个任务，每个Agent都可以独立处理输入，并收集并聚合结果。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124194638071-182220484.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p>此模式比较适合多种观点或解决方案很有价值的场景，比如集思广益、群体推理以及其他投票系统。</p>\n<p>下面的代码展示了在MAF中的代码实现：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step1. Create Agents</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> sensitiveWordAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> adDetectionAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> sentimentAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step2. Build a Workflow</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> AgentWorkflowBuilder.BuildConcurrent(\n    agents: </span><span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\">[] { sensitiveWordAgent, adDetectionAgent, sentimentAgent },\n    aggregator: auditAggregator\n);\n\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step3. Test the workflow</span>\n......</pre>\n</div>\n<h3><span><span>2.3 移交编排</span></span></h3>\n<p>在移交（也可以叫做交接）编排模式中，允许各个Agent根据上下文或用户请求相互转移控制权，每个Agent都可以通过适当的专业知识将对话“移交”给另一个Agent，确保每个Agent处理任务的某个指定部分。</p>\n<p><img alt=\"image\" height=\"556\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124194802065-1054226946.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"707\" /></p>\n<p>这种模式非常适合于客户支持（客服）、专家系统或需要动态委派类型的任务场景。</p>\n<p><span>下面的代码展示了在MAF的代码实现</span>：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step1. Create Agents</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> triageAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> historyTutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> mathTutor = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step2. Build a Workflow</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> AgentWorkflowBuilder.CreateHandoffBuilderWith(triageAgent)\n    .WithHandoffs(triageAgent, [mathTutor, historyTutor]) </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Triage can route to either specialist</span>\n    .WithHandoffs([mathTutor, historyTutor], triageAgent) <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Math or History tutor can return to triage</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    .Build();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step3. Test the workflow</span>\n.....</pre>\n</div>\n<h3><span><span>2.4 群聊编排</span></span></h3>\n<p>在群聊编排模式中，各个Agent就像加入了一个微信群，由群管理员协调进行群聊对话。这种模式非常适合于模拟会议、辩论或协作解决问题的会议类型场景。</p>\n<p>下图展示了一个讨论业务建议的用例，由一个Chat Manager负责主持对话，依次让三个参与对话的Agent进行建议发表。这个Chat Manager就像是群管理员，它不仅负责主持对话，也会在必要时引入人工干预。</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124194919639-675664209.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<p><span>下面的代码展示了在MAF的代码实现：</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step1. Create Agents</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> researchAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> writerAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> criticAgent = <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> ChatClientAgent(...);\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step2. Build a Workflow</span>\n<span style=\"color: rgba(0, 0, 255, 1);\">var</span> workflow =<span style=\"color: rgba(0, 0, 0, 1);\"> AgentWorkflowBuilder.CreateGroupChatBuilderWith(\n  agents </span>=&gt; <span style=\"color: rgba(0, 0, 255, 1);\">new</span><span style=\"color: rgba(0, 0, 0, 1);\"> RoundRobinGropuChatManager(agents))\n      .AddParticipants(researchAgent, writerAgent, criticAgent)\n      .Build();\n</span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Step3. Test the workflow</span>\n.....</pre>\n</div>\n<h1><strong><span>3 小结</span></strong></h1>\n<p>本文介绍了MAF中常见的Agent编排模式，并详细介绍了顺序编排、并发编排、移交编排 和 群聊编排 的适用场景 和 代码实现。</p>\n<p>这几种模式的对比分析如下：</p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/381412/202601/381412-20260124195004594-1977355623.png\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></p>\n<h1>示例源码</h1>\n<p>GitHub:&nbsp;<a href=\"https://github.com/EdisonTalk/MAFD\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/EdisonTalk/MAFD</a></p>\n<h1>参考资料</h1>\n<p><span><span>圣杰，《<a href=\"https://www.cnblogs.com/sheng-jie/p/19200934\" target=\"_blank\">.NET + AI 智能体开发进阶</a>》（推荐指数：★★★★★）</span></span></p>\n<p><span><span>Microsoft Learn，<span>《<a href=\"https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview?wt.mc_id=MVP_397012\" rel=\"noopener nofollow\" target=\"_blank\">Agent Framework Tutorials</a>》</span></span></span></p>\n<div><span><span>&nbsp;</span></span></div>\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://images.cnblogs.com/cnblogs_com/edisonchou/1647700/o_200902144330EdisonTalk-Footer.jpg\" /></p>\n<div id=\"Copyright\">\n<p>作者：<span style=\"text-decoration: underline;\">爱迪生</span></p>\n<p>出处：<a href=\"https://edisontalk.cnblogs.com\" target=\"_blank\" title=\"from\">https://edisontalk.cnblogs.com</a></p>\n<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。</p>\n</div>\n</div>\n<div id=\"MySignature\">\n    <div align=\"center\"><a href=\"https://weibo.com/u/2068032061?s=6uyXnP\" target=\"_blank\"><img border=\"0\" src=\"http://service.t.sina.com.cn/widget/qmd/2068032061/d643d182/10.png\" /></a></div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-24 19:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/edisontalk\">EdisonZhou</a>&nbsp;\n阅读(<span id=\"post_view_count\">35</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}