{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "一篇基于AWS服务搭建的全球服务架构",
      "link": "https://www.cnblogs.com/linnuo/p/19388428",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/linnuo/p/19388428\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 19:37\">\n    <span>一篇基于AWS服务搭建的全球服务架构</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p>一、背景</p>\n<p>　　当我们在做全球业务时，例如网站/机器/游戏，为了支撑全球用户，我们会在不同的位置搭建节点，以满足业务功能和响应实效。</p>\n<p>我们会搭建一个这样的架构满足初步的使用。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　能用是ok的了，会有什么问题呢？</p>\n<p>　　1、因为服务独立，上架1个SKU需要多次发布到不同的服务。</p>\n<p>　　2、因为域名过多，发布时需要频繁的退出、登录切换不同的二级域名，非常繁琐不说，还可能会遗漏。</p>\n<p>　　3、后期处理数据统计、报表、看板、设备地图，耗时费力。</p>\n<p>　　4、这还是单节点，未考虑高可用的情况下，多区域、多节点部署服务器导致运维难度增加、过多的财务开支。</p>\n<div>\n<div>　　5、各个节点各玩各的。</div>\n<div>&nbsp;</div>\n<div>　　有什么方式可以解决这些问题？</div>\n<div>　　AWS服务组件很好支持。</div>\n<div>&nbsp;</div>\n<div>二、AWS架构</div>\n<div>　　AWS提供了非常丰富的组件，列几个常用的：</div>\n<div>　　1、Route 53 负责域名解析流量管理健康检查，高可用可以用到它。</div>\n<div>　　2、VPC 虚拟私有网络，可将同一区域的服务器、数据库置于同一内网段，提升访问速度。</div>\n<div>　　3、CloudFront CDN加速，可以给访问请求、对象存储加速。函数功能极其强大，可配置HTTP、HTTPS的请求跨域，可识别全球流量来源，根据来源分发到不同区域的节点。</div>\n<div>　　4、EC2 服务器，内含了负载均衡器ELB、目标组，可实现同一地区的服务器的负载均衡和高可用。结合CloudFront可将流量分发到就近的服务。</div>\n<div>　　5、Aurora and RDS 数据库，Aurora 作为全球数据库，已实现主从备份，可在1s内实现全球数据同步，结合Route 53的短域名实现读写分离。</div>\n<div>　　6、S3 对象存储，OSS存储图片、视频、文档、音频等。</div>\n<div>　　7、Certificate Manager 安全凭证管理，可申请和管理证书。</div>\n<div>&nbsp;</div>\n<div>　　架构完是这样的。&nbsp;</div>\n<div>&nbsp;\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<p>三、干活，简单的一笔带过</p>\n<p>　　1、将外部域名解析到Route 53。</p>\n<p>　　2、在Certificate Manager申请证书。</p>\n<p>　　3、在拟定的区域创建VPC内网。</p>\n<p>　　4、购买服务器和数据库时选择上面的创建的VPC内网。</p>\n<p>　　5、在创建Aurora数据库时需要选确认某一个区域为主集群，主集群下会创建写入器实例、读取器实例。</p>\n<p>　　　　再创建其它区域的读取实例，如下图：</p>\n<p><img alt=\"f9edbdf666a249221b20525d951cdf3b\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　6、在Route 53创建一个私有的短域名，用于数据库连接，无需在域名供应商购买。我这里用&nbsp;db.com</p>\n<p><img alt=\"402ddedc223507ba4f2e187ad161cc2c\" class=\"lazyload\" /></p>\n<p>&nbsp;　</p>\n<p>　　7、将二级域名指向到Aurora的写域名指向到Aurora的写入器实例的DNS（路由策略：简单），</p>\n<p>　　　　读域名指向到多个读取器实例的DNS（路由策略：延迟）。数据写入到主库后，1s内可同步到所有的从库</p>\n<p><img alt=\"fe4075fd22ed2a0e1e2919b9d2e47b5b\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　8、在EC2购买服务器后，新建目标组，将服务器添加到目标组中</p>\n</div>\n<div>\n<p><img alt=\"b9e98fda4ad55cabc5a3bd5d55ff112f\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　9、在EC2创建负载均衡器，这里分NLB（服务器之间用）和ELB（服务器内部服务之间用），层级和颗粒度不同。</p>\n<p>　　　　这里创建NLB，添加转发到的目标组到侦听器，注意选择VPC。创建完即可通过DNS访问。</p>\n<p><img alt=\"5baa9287044b30796f6ebb020436d6f6\" class=\"lazyload\" /></p>\n<p>&nbsp;　　</p>\n<p>　　10、创建CloudFront，将需要经过CDN加速的域名添加到备用域名，添加第2步创建的证书，源添加到访问目标的DNS。成功后CloudFront会分配域名。</p>\n<p><img alt=\"aeaa7964-4abc-47f7-965c-b70c4dee3682\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<p>　　11、在Route 53将经过CloudFront加速的域名指向到CloudFront分配域名上。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<p>　　12、在Route 53创建NLB的健康检查，成功后生成ID。</p>\n<p>　　13、在Route 53添加故障转移域名，用于服务区域之间的高可用，无需额外采购服务器</p>\n<p><img alt=\"98eb6d3e-2d4c-4a8f-97f9-6261ccbfc409\" class=\"lazyload\" /></p>\n<p>&nbsp;</p>\n<p>　　14、在CloudFront创建函数，将请求按照国家和地区分发到相应的服务器。</p>\n<p><img alt=\"5b4907ff50b14eae080e4168c566cd54\" class=\"lazyload\" /></p>\n<p>&nbsp;　　代码如下：</p>\n<div class=\"cnblogs_code\">\n<pre>import cf from 'cloudfront'<span style=\"color: rgba(0, 0, 0, 1);\">;\n\n</span><span style=\"color: rgba(0, 0, 255, 1);\">function</span><span style=\"color: rgba(0, 0, 0, 1);\"> handler(event) {\n    const request </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> event.request;\n    const headers </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> request.headers;\n    const country </span>= headers['cloudfront-viewer-country'] &amp;&amp; headers['cloudfront-viewer-country'<span style=\"color: rgba(0, 0, 0, 1);\">].value;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> List of countries to ALB endpoints</span>\n    const countryToContinent =<span style=\"color: rgba(0, 0, 0, 1);\"> {\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 亚太地区 (Asia-Pacific) -&gt; Asia</span>\n        'AF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AZ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BD': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BN': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BT': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CC': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CX': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GE': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ID': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IN': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IO': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'JP': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KG': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KH': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KR': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KZ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LA': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MN': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MO': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MP': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MV': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MY': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NC': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NP': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NR': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NU': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NZ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PH': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PN': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SB': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SG': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TH': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TJ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TL': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TO': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TV': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TW': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UZ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VU': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'WF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'WS': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'YE': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 大洋洲 (Oceania) - 通常归类为亚太地区</span>\n        'AS': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AU': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FJ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GU': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KI': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MH': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PW': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PG': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TK': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 南极洲 (Antarctica) - 通常单独处理，这里暂时归入亚太</span>\n        'AQ': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BV': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GS': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HM': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TF': 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 欧洲、非洲、中东 -&gt; Europe</span>\n        'AL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AX': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BY': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CY': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DK': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'EE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ES': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'FR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HU': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'JE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LU': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LV': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MC': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ME': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MK': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RU': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SJ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SK': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GB': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BJ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BF': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CV': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CF': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CI': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DJ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'EG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GQ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ER': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ET': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GN': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LY': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ML': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MU': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'YT': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'RE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SN': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SC': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ZA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SD': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ST': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TN': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TZ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UG': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'EH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ZM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'ZW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AE': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BH': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IQ': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'IL': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'JO': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KW': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LB': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'OM': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PS': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'QA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SA': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SY': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TR': 'Europe'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 美洲 -&gt; America</span>\n        'AI': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AG': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'AW': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BS': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BB': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BZ': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BQ': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CA': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KY': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CR': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CU': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'CW': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'DO': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SV': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GD': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GL': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GP': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'GT': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HT': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'HN': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'JM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MQ': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MX': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MS': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'NI': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PA': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PR': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'BL': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'KN': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'LC': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'MF': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'PM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VC': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'SX': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TT': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'TC': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'US': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UM': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'UY': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VE': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VG': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>'VI': 'America'<span style=\"color: rgba(0, 0, 0, 1);\">\n    };\n\n    const continentToRegion </span>=<span style=\"color: rgba(0, 0, 0, 1);\"> {\n        </span>'Asia': 'asia.autovxxxxxx.com',         <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 亚洲故障转移域名</span>\n        'Europe': 'europu.autovxxxxxx.com',     <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 欧洲故障转移域名</span>\n        'America': 'america.autovxxxxxxx.com'    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 美洲故障转移域名</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    };\n\n    const DEFAULT_REGION </span>= 'NLB-Asia-Singapore-5e42xxxxxxxx4853.elb.ap-southeast-1.amazonaws.com'; <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\">改为自己的默认alb 域名</span>\n    const targetContinent = (country &amp;&amp; countryToContinent[country]) || 'Asia'<span style=\"color: rgba(0, 0, 0, 1);\">;\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> const targetContinent = 'Asia';</span>\n    const targetOrigin = (targetContinent &amp;&amp; continentToRegion[targetContinent]) ||<span style=\"color: rgba(0, 0, 0, 1);\"> DEFAULT_REGION;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 打印所有请求头</span>\n    console.log(\"=== 所有请求头信息 ===\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">for</span> (<span style=\"color: rgba(0, 0, 255, 1);\">var</span> headerName <span style=\"color: rgba(0, 0, 255, 1);\">in</span><span style=\"color: rgba(0, 0, 0, 1);\"> headers) {\n        </span><span style=\"color: rgba(0, 0, 255, 1);\">if</span><span style=\"color: rgba(0, 0, 0, 1);\"> (headers.hasOwnProperty(headerName)) {\n            </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> headers 对象的值是一个包含 'value' 属性的对象</span>\n            <span style=\"color: rgba(0, 0, 255, 1);\">var</span> headerValue =<span style=\"color: rgba(0, 0, 0, 1);\"> headers[headerName].value;\n            console.log(headerName </span>+ \": \" +<span style=\"color: rgba(0, 0, 0, 1);\"> headerValue);\n        }\n    }\n    console.log(</span>'targetOrigin: ' +<span style=\"color: rgba(0, 0, 0, 1);\"> targetOrigin);\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 使用CloudFront 2.0 API修改origin</span>\n<span style=\"color: rgba(0, 0, 0, 1);\">    cf.updateRequestOrigin({\n        </span>\"domainName\"<span style=\"color: rgba(0, 0, 0, 1);\">: targetOrigin,\n        </span>\"port\": 80<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>\"protocol\": 'http'<span style=\"color: rgba(0, 0, 0, 1);\">,\n        </span>\"timeouts\"<span style=\"color: rgba(0, 0, 0, 1);\">: {\n            </span>\"readTimeout\": 30<span style=\"color: rgba(0, 0, 0, 1);\">,\n            </span>\"connectionTimeout\": 5<span style=\"color: rgba(0, 0, 0, 1);\">\n        }\n    });\n    \n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> 添加调试信息 - 确保值是字符串</span>\n    request.headers['x-debug-country'] = { value: String(country || 'unknown'<span style=\"color: rgba(0, 0, 0, 1);\">) };\n    request.headers[</span>'x-debug-targetorigin'] =<span style=\"color: rgba(0, 0, 0, 1);\"> { value: String(targetOrigin) };\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> request;\n}</span></pre>\n</div>\n<p>　　解决跨域问题，函数代码如下：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 255, 1);\">function</span><span style=\"color: rgba(0, 0, 0, 1);\"> handler(event)  {\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> response  =<span style=\"color: rgba(0, 0, 0, 1);\"> event.response;\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">var</span> headers  =<span style=\"color: rgba(0, 0, 0, 1);\"> response.headers;\n\n    </span><span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> If Access-Control-Allow-Origin CORS header is missing, add it.</span>\n    <span style=\"color: rgba(0, 128, 0, 1);\">//</span><span style=\"color: rgba(0, 128, 0, 1);\"> Since JavaScript doesn't allow for hyphens in variable names, we use the dict[\"key\"] notation.</span>\n    <span style=\"color: rgba(0, 0, 255, 1);\">if</span> (!headers['access-control-allow-origin'<span style=\"color: rgba(0, 0, 0, 1);\">]) {\n        headers[</span>'access-control-allow-origin'] = {value: \"*\"<span style=\"color: rgba(0, 0, 0, 1);\">};\n        console.log(</span>\"Access-Control-Allow-Origin was missing, adding it now.\"<span style=\"color: rgba(0, 0, 0, 1);\">);\n        headers[</span>'access-control-allow-headers'] = {value: \"Origin, X-Requested-With, Content-Type, Accept\"<span style=\"color: rgba(0, 0, 0, 1);\">};\n        headers[</span>'access-control-allow-methods'] = {value: \"GET,POST,PUT, OPTIONS\"<span style=\"color: rgba(0, 0, 0, 1);\">};\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1);\">return</span><span style=\"color: rgba(0, 0, 0, 1);\"> response;\n}</span></pre>\n</div>\n<p>　　</p>\n<p>　　ok，完事儿</p>\n<p>　　</p>\n<p>&nbsp;</p>\n&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n<div>&nbsp;</div>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 19:37</span>&nbsp;\n<a href=\"https://www.cnblogs.com/linnuo\">ooLeo</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "高并发下如何防止商品超卖？",
      "link": "https://www.cnblogs.com/12lisu/p/19406444",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/12lisu/p/19406444\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 19:21\">\n    <span>高并发下如何防止商品超卖？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>\"快看我们的秒杀系统！库存显示-500了！\"</p>\n<p>3年前的这个电话让我记忆犹新。</p>\n<p>当时某电商大促，我们自认为完美的分布式架构，在0点整瞬间被击穿。</p>\n<p>数据库连接池耗尽，库存表出现负数，客服电话被打爆...</p>\n<p>今天这篇文章跟大家一起聊聊商品超卖的问题，希望对你会有所帮助。</p>\n<h2 id=\"1-为什么会发生超卖\">1 为什么会发生超卖？</h2>\n<p>首先我们一起看看为什么会发送超卖？</p>\n<h3 id=\"11-数据库的最后防线漏洞\">1.1 数据库的\"最后防线\"漏洞</h3>\n<p>我们用下面的列子，给大家介绍一下商品超卖是如何发生的。</p>\n<pre><code class=\"language-java\">public boolean buy(int goodsId) {\n    // 1. 查询库存\n    int stock = getStockFromDatabase(goodsId);\n    if (stock &gt; 0) {\n        // 2. 扣减库存\n        updateStock(goodsId, stock - 1);\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<p>在并发场景下可能变成下图这样的：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p>请求1和请求2都将库存更新成9。</p>\n<p><strong>根本原因</strong>：数据库的查询和更新操作，不是原子性校验，多个事务可能同时通过stock&gt;0的条件检查。</p>\n<h3 id=\"12-超卖的本质\">1.2 超卖的本质</h3>\n<p><strong>商品超卖的本质是</strong>：多个请求同时穿透缓存，同一时刻读取到相同库存值，最终在数据库层发生覆盖。</p>\n<p>就像100个人同时看上一件衣服，都去试衣间前看了眼牌子，出来时都觉得自己应该拿到那件衣服。</p>\n<h2 id=\"2-防止超卖的方案\">2 防止超卖的方案</h2>\n<h3 id=\"21-数据库乐观锁\">2.1 数据库乐观锁</h3>\n<p>数据库乐观锁的核心原理是通过版本号控制并发。</p>\n<p>例如下面这样的：</p>\n<pre><code class=\"language-sql\">UPDATE product \nSET stock = stock -1, version=version+1 \nWHERE id=123 AND version=#{currentVersion};\n</code></pre>\n<p>Java的实现代码如下：</p>\n<pre><code class=\"language-java\">@Transactional\npublic boolean deductStock(Long productId) {\n    Product product = productDao.selectForUpdate(productId);\n    if (product.getStock() &lt;= 0) return false;\n    \n    int affected = productDao.updateWithVersion(\n        productId, \n        product.getVersion(),\n        product.getStock()-1\n    );\n    return affected &gt; 0;\n}\n</code></pre>\n<p>基于数据库乐观锁方案的架构图如下：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>优缺点分析</strong>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\"><strong>优点</strong></th>\n<th style=\"text-align: center;\"><strong>缺点</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">无需额外中间件</td>\n<td style=\"text-align: center;\">高并发时DB压力大</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">实现简单</td>\n<td style=\"text-align: center;\">可能出现大量更新失败</td>\n</tr>\n</tbody>\n</table>\n<p><strong>适用场景</strong>：日订单量1万以下的中小系统。</p>\n<h3 id=\"22-redis原子操作\">2.2 Redis原子操作</h3>\n<p>Redis原子操作的核心原理是使用：Redis + Lua脚本。</p>\n<p>核心代码如下：</p>\n<pre><code class=\"language-java\">// Lua脚本保证原子性\nString lua = \"if redis.call('get', KEYS &gt;= ARGV[1] then \" +\n             \"return redis.call('decrby', KEYS[1], ARGV \" +\n             \"else return -1 end\";\n\npublic boolean preDeduct(String itemId, int count) {\n    RedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;(lua, Long.class);\n    Long result = redisTemplate.execute(script, \n        Collections.singletonList(itemId), count);\n    return result != null &amp;&amp; result &gt;= 0;\n}\n</code></pre>\n<p>该方案的架构图如下：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>性能对比</strong>：</p>\n<ul>\n<li>单节点QPS：数据库方案500 vs Redis方案8万</li>\n<li>响应时间：&lt;1ms vs 50ms+</li>\n</ul>\n<h3 id=\"23-分布式锁\">2.3 分布式锁</h3>\n<p>目前最常用的分布式锁的方案是Redisson。</p>\n<p>下面是Redisson的实现：</p>\n<pre><code class=\"language-java\">RLock lock = redisson.getLock(\"stock_lock:\"+productId);\ntry {\n    if (lock.tryLock(1, 10, TimeUnit.SECONDS)) {\n        // 执行库存操作\n    }\n} finally {\n    lock.unlock();\n}\n</code></pre>\n<h4 id=\"注意事项\">注意事项</h4>\n<ol>\n<li>1.锁粒度要细化到商品级别</li>\n<li>2.必须设置等待时间和自动释放</li>\n<li>3.配合异步队列使用效果更佳</li>\n</ol>\n<p>该方案的架构图如下：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<h3 id=\"24-消息队列削峰\">2.4 消息队列削峰</h3>\n<p>可以使用 RocketMQ的事务消息。</p>\n<p>核心代码如下：</p>\n<pre><code class=\"language-java\">// RocketMQ事务消息示例\nTransactionMQProducer producer = new TransactionMQProducer(\"stock_group\");\nproducer.setExecutor(new TransactionListener() {\n    @Override\n    public LocalTransactionState executeLocalTransaction(Message msg) {\n        // 扣减数据库库存\n        return LocalTransactionState.COMMIT_MESSAGE;\n    }\n});\n</code></pre>\n<p>该方案的架构图如下：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>技术指标</strong>：</p>\n<ul>\n<li>削峰能力：10万QPS → 2万TPS</li>\n<li>订单处理延迟：&lt;1秒（正常时段）</li>\n</ul>\n<h3 id=\"25-预扣库存\">2.5 预扣库存</h3>\n<p>预扣库存是防止商品超卖的终极方案。</p>\n<p>核心算法如下：</p>\n<pre><code class=\"language-java\">// Guava RateLimiter限流\nRateLimiter limiter = RateLimiter.create(1000); // 每秒1000个令牌\n\npublic boolean preDeduct(Long itemId) {\n    if (!limiter.tryAcquire()) return false;\n    \n    // 写入预扣库存表\n    preStockDao.insert(itemId, userId);\n    return true;\n}\n</code></pre>\n<p>该方案的架构图如下：</p>\n<p><img alt=\"\" class=\"lazyload\" /></p>\n<p><strong>性能数据</strong>：</p>\n<ul>\n<li>百万级并发支撑能力</li>\n<li>库存准确率99.999%</li>\n<li>订单处理耗时200ms内</li>\n</ul>\n<h2 id=\"3-避坑指南\">3 避坑指南</h2>\n<h3 id=\"31-缓存与数据库不一致\">3.1 缓存与数据库不一致</h3>\n<p>某次大促因缓存未及时失效，导致超卖1.2万单。</p>\n<p>错误示例如下：</p>\n<pre><code class=\"language-java\">// 错误示例：先删缓存再写库\nredisTemplate.delete(\"stock:\"+productId);\nproductDao.updateStock(productId, newStock); // 存在并发写入窗口\n</code></pre>\n<h3 id=\"32-未考虑库存回滚\">3.2 未考虑库存回滚</h3>\n<p>秒杀取消后，忘记恢复库存，引发后续超卖。</p>\n<p>正确做法是使用事务补偿。</p>\n<p>例如下面这样的：</p>\n<pre><code class=\"language-java\">@Transactional\npublic void cancelOrder(Order order) {\n    stockDao.restock(order.getItemId(), order.getCount());\n    orderDao.delete(order.getId());\n}\n</code></pre>\n<p>库存回滚和订单删除，在同一个事务中。</p>\n<h3 id=\"33-锁粒度过大\">3.3 锁粒度过大</h3>\n<p>锁粒度过大，全局限流导致10%的请求被误杀。</p>\n<p>错误示例如下：</p>\n<pre><code class=\"language-java\">// 错误示例：全局限锁\nRLock globalLock = redisson.getLock(\"global_stock_lock\");\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>其实在很多大厂中，一般会将防止商品超卖的多种方案组合使用。</p>\n<p>架构图如下：<br />\n<img alt=\"\" class=\"lazyload\" /></p>\n<p>通过组合使用：</p>\n<ol>\n<li>Redis做第一道防线（承受80%流量）</li>\n<li>分布式锁控制核心业务逻辑</li>\n<li>预扣库存+消息队列保证最终一致性</li>\n</ol>\n<p><strong>实战经验</strong>：某电商在2023年双11中：</p>\n<ul>\n<li>Redis集群承载98%请求</li>\n<li>分布式锁拦截异常流量</li>\n<li>预扣库存保证最终准确性</li>\n</ul>\n<p>系统平稳支撑了每秒12万次秒杀请求，0超卖事故发生！</p>\n<p><strong>记住：没有银弹方案，只有适合场景的组合拳！</strong></p>\n<h2 id=\"最后说一句求关注别白嫖我\">最后说一句(求关注，别白嫖我)</h2>\n<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>\n<p>求一键三连：点赞、转发、在看。</p>\n<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>\n<p>更多项目实战在我的技术网站：<a href=\"http://www.susan.net.cn/project\" rel=\"noopener nofollow\" target=\"_blank\">http://www.susan.net.cn/project</a></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 19:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/12lisu\">苏三说技术</a>&nbsp;\n阅读(<span id=\"post_view_count\">11</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "GitFlow",
      "link": "https://www.cnblogs.com/NobodyCares/p/19406442",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/NobodyCares/p/19406442\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 19:21\">\n    <span>GitFlow</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"GitFlow\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3471133/202512/3471133-20251226192106963-300045909.png\" />\n        GitFlow是一种成熟的Git分支管理策略，包含五大核心分支：Master(生产代码)、Develop(开发集成)、Feature(功能开发)、Release(版本发布)和Hotfix(紧急修复)。详细介绍了各分支职责、命名规范、工作流程示例、Git回退操作、Stash暂存、Cherry-Pick选择提交、Fetch/Pull获取更新以及Merge/Rebase合并策略，为团队协作提供了完整的版本管理规范。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"gitflow-分支管理模型\">GitFlow 分支管理模型</h1>\n<h2 id=\"一什么是-gitflow\">一、什么是 GitFlow？</h2>\n<p>GitFlow 是一种成熟的 Git 分支管理策略,用于规范团队协作中的代码版本管理流程。</p>\n<ul>\n<li><a href=\"https://nvie.com/posts/a-successful-git-branching-model/\" rel=\"noopener nofollow\" target=\"_blank\">GitFlow 官方文档</a></li>\n</ul>\n<h2 id=\"二核心分支概念\">二、核心分支概念</h2>\n<p>GitFlow 模型包含五大核心分支，每个分支都有明确的职责和使用场景：</p>\n<h3 id=\"1-master-分支主分支\">1. Master 分支（主分支）</h3>\n<ul>\n<li><strong>用途</strong>：存放稳定的生产代码</li>\n<li><strong>特性</strong>：始终保持可部署的稳定状态</li>\n<li><strong>管理</strong>：只接受来自 Release 分支或 Hotfix 分支的合并</li>\n<li><strong>版本标记</strong>：每个提交都应该添加版本标签（如 v1.0.0）</li>\n</ul>\n<h3 id=\"2-develop-分支开发分支\">2. Develop 分支（开发分支）</h3>\n<ul>\n<li><strong>用途</strong>：集成所有正在开发的功能</li>\n<li><strong>来源</strong>：基于 Master 分支创建</li>\n<li><strong>特性</strong>：包含下一个版本要发布的所有功能</li>\n<li><strong>管理</strong>：所有 Feature 分支开发完成后都合并到 Develop 分支</li>\n</ul>\n<h3 id=\"3-feature-分支功能分支\">3. Feature 分支（功能分支）</h3>\n<ul>\n<li><strong>用途</strong>：开发新功能或改进</li>\n<li><strong>来源</strong>：基于 Develop 分支创建</li>\n<li><strong>命名规范</strong>：<code>feature/功能名称</code>（如 <code>feature/user-authentication</code>）</li>\n<li><strong>管理</strong>：\n<ul>\n<li>功能开发完成后合并回 Develop 分支</li>\n<li>永远不会直接与 Master 分支交互</li>\n<li>push到远程仓库,发起 Pull Request/Merge Request 请求合并回 Develop 分支</li>\n<li>经过 Code Review（代码审核）通过后方可合并</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-release-分支发布分支\">4. Release 分支（发布分支）</h3>\n<ul>\n<li><strong>用途</strong>：准备新版本发布</li>\n<li><strong>来源</strong>：基于 Develop 分支创建</li>\n<li><strong>命名规范</strong>：<code>release/x.y.z</code>（如 <code>release/1.2.0</code>，x.y.z为版本号）</li>\n<li><strong>管理</strong>：\n<ul>\n<li>用于修复发布前的 bug</li>\n<li>不添加新功能，只处理 bug 修复和版本准备</li>\n<li>测试通过后同时合并回 Master 分支和 Develop 分支</li>\n<li>合并到 Master 分支后需要打版本标签</li>\n<li>发布完成后应及时删除</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-hotfix-分支热修复分支\">5. Hotfix 分支（热修复分支）</h3>\n<ul>\n<li><strong>用途</strong>：紧急修复生产环境中的问题</li>\n<li><strong>来源</strong>：基于 Master 分支创建</li>\n<li><strong>命名规范</strong>：<code>hotfix/x.y.z</code>（如 <code>hotfix/1.2.1</code>，x.y.z 为版本号）</li>\n<li><strong>管理</strong>：\n<ul>\n<li>仅用于紧急修复，不处理新功能</li>\n<li>修复完成后同时合并回 Master 分支和 Develop 分支</li>\n<li>合并到 Master 分支后需要打版本标签</li>\n<li>修复完成后立即删除</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"初始化仓库\">初始化仓库</h3>\n<pre><code class=\"language-bash\"># 1. 初始化本地仓库\ngit init\n\n# 2. 添加远程仓库连接\ngit remote add origin &lt;远程仓库URL&gt;\n\n# 3. 创建 Master 分支的首次提交\ngit add .\ngit commit --allow-empty -m \"Initial commit\"\n\n# 4. 创建 Develop 分支\ngit checkout -b develop\n\n# 5. 推送两个核心分支到远程\ngit push -u origin master\ngit push -u origin develop\n\n# 6. 设置远程仓库的默认分支（可选但推荐）\ngit remote set-head origin master\n</code></pre>\n<blockquote>\n<p>--allow-empty 允许创建空提交</p>\n</blockquote>\n<h2 id=\"三工作流程示例\">三、工作流程示例</h2>\n<blockquote>\n<p>展示适用于单人开发或无 PR 强制要求的场景流程示例<br />\n<strong>标准的现代流程为：推送功能分支到远程 -&gt; 在平台上创建 PR -&gt; 审核通过后在网页端点击合并。</strong></p>\n</blockquote>\n<h3 id=\"1-功能开发流程\">1. 功能开发流程</h3>\n<ol>\n<li>从 Develop 分支创建 Feature 分支</li>\n</ol>\n<pre><code class=\"language-bash\"># 切换到 Develop 分支并确保是最新状态\ngit checkout develop\ngit pull origin develop\n\ngit checkout -b feature/xxx develop\n</code></pre>\n<ol start=\"2\">\n<li>在 Feature 分支上进行功能开发</li>\n<li>开发完成后，将 Feature 分支合并回 Develop 分支</li>\n</ol>\n<pre><code class=\"language-bash\">git checkout develop\n# 采用--no-ff参数，表示强制创建合并提交\n# 合并时会创建一个新的合并提交，保留分支历史\ngit merge --no-ff feature/xxx\ngit push\n</code></pre>\n<ol start=\"4\">\n<li>删除本地 Feature 分支</li>\n</ol>\n<pre><code class=\"language-bash\">git branch -d feature/xxx\n# 如果之前推送了 Feature 分支，则需要删除远程分支\n# git push origin --delete feature/xxx\n</code></pre>\n<h3 id=\"2-版本发布流程\">2. 版本发布流程</h3>\n<ol>\n<li>从 Develop 分支创建 Release 分支</li>\n</ol>\n<pre><code class=\"language-bash\"># 切换到 Develop 分支并确保是最新状态\ngit checkout develop\ngit pull origin develop\n\ngit checkout -b release/x.y.z develop\n</code></pre>\n<ol start=\"2\">\n<li>在 Release 分支上进行 bug 修复和版本准备</li>\n<li>测试通过后，将 Release 分支合并回 Master 分支并打版本标签</li>\n</ol>\n<pre><code class=\"language-bash\">git checkout master\ngit merge --no-ff release/x.y.z\ngit tag -a tagName -m \"Release x.y.z\"\n# 推送标签到远程仓库\ngit push origin tagName\n# 推送代码到远程仓库\ngit push \n</code></pre>\n<ol start=\"4\">\n<li>同时将 Release 分支合并回 Develop 分支，确保开发分支包含所有修复</li>\n</ol>\n<pre><code class=\"language-bash\">git checkout develop\ngit merge --no-ff release/x.y.z\ngit push\n</code></pre>\n<ol start=\"5\">\n<li>删除 Release 分支</li>\n</ol>\n<pre><code class=\"language-bash\">git branch -d release/x.y.z\n# 如果之前推送了 Release 分支，则需要删除远程分支\n# git push origin --delete release/x.y.z\n</code></pre>\n<h3 id=\"3-热修复流程\">3. 热修复流程</h3>\n<ol>\n<li>从 Master 分支创建 Hotfix 分支</li>\n</ol>\n<pre><code class=\"language-bash\"># 切换到 Master 分支并确保是最新状态\ngit checkout master\ngit pull origin master\n\ngit checkout -b hotfix/x.y.z master\n</code></pre>\n<ol start=\"2\">\n<li>在 Hotfix 分支上修复问题</li>\n<li>测试通过后，将 Hotfix 分支合并回 Master 分支并打版本标签</li>\n</ol>\n<pre><code class=\"language-bash\">git checkout master\ngit merge --no-ff hotfix/x.y.z\ngit tag -a tagName -m \"Hotfix x.y.z\"\n# 推送标签到远程仓库\ngit push origin tagName\n# 推送代码到远程仓库\ngit push \n</code></pre>\n<ol start=\"4\">\n<li>同时将 Hotfix 分支合并回 Develop 分支，确保开发分支包含修复</li>\n</ol>\n<pre><code class=\"language-bash\">git checkout develop\ngit merge --no-ff hotfix/x.y.z\ngit push\n</code></pre>\n<ol start=\"5\">\n<li>删除 Hotfix 分支</li>\n</ol>\n<pre><code class=\"language-bash\">git branch -d hotfix/x.y.z\n# 如果之前推送了 Hotfix 分支，则需要删除远程分支\n# git push origin --delete hotfix/x.y.z\n</code></pre>\n<h2 id=\"四git回退操作\">四、Git回退操作</h2>\n<h3 id=\"有改动无add无commit\">有改动,无add,无commit</h3>\n<blockquote>\n<p>撤销工作区改动<br />\n<code>git checkout -- filename</code></p>\n</blockquote>\n<h3 id=\"有改动有add无commit\">有改动,有add,无commit</h3>\n<blockquote>\n<p>撤销暂存区的改动<br />\n<code>git reset HEAD filename</code></p>\n</blockquote>\n<h3 id=\"有改动有add有commit\">有改动,有add,有commit</h3>\n<blockquote>\n<p>从本地库回退（已commit，未push）</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">操作描述</th>\n<th style=\"text-align: center;\">命令</th>\n<th style=\"text-align: center;\">效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">撤销提交，但保留改动在工作区</td>\n<td style=\"text-align: center;\">git reset --mixed HEAD^</td>\n<td style=\"text-align: center;\">提交消失，改动还在工作区</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">撤销提交，但保留改动在暂存区</td>\n<td style=\"text-align: center;\">git reset --soft HEAD^</td>\n<td style=\"text-align: center;\">提交消失，改动还在暂存区</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">彻底丢弃（真的不要了）</td>\n<td style=\"text-align: center;\">git reset --hard HEAD^</td>\n<td style=\"text-align: center;\">全部消失，慎用！</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"有改动有add有commit有push\">有改动,有add,有commit,有push</h3>\n<blockquote>\n<p>撤销已推送的提交<br />\n创建一个新提交，用于撤销指定提交<br />\n提交的新提交用来\"抵消\"（逆向操作）指定提交的更改。<br />\nrevert后需要再次 git push 才能同步到远程</p>\n</blockquote>\n<p><code>git revert &lt;commit-hash&gt;</code></p>\n<h3 id=\"reset-vs-revert\">reset VS revert</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">操作</th>\n<th style=\"text-align: center;\">描述</th>\n<th style=\"text-align: center;\">影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">reset</td>\n<td style=\"text-align: center;\">通过移动分支指针来回退到指定提交</td>\n<td style=\"text-align: center;\">直接改变历史</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">revert</td>\n<td style=\"text-align: center;\">创建一个新提交，用于来\"抵消\"（逆向操作）指定提交的更改</td>\n<td style=\"text-align: center;\">不改变历史,而是在历史记录中增加一个新的,反向的提交</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五git-stash暂存区域\">五、Git Stash（暂存区域）</h2>\n<blockquote>\n<p>临时保存工作进度，快速切换上下文，而不需要创建临时提交。</p>\n</blockquote>\n<h3 id=\"紧急修复bug时的上下文切换\">紧急修复bug时的上下文切换</h3>\n<pre><code class=\"language-bash\"># 正在功能分支开发，突然需要修复生产bug\n$ git status\n# 修改：src/feature.js\n# 修改：src/feature.css\n\n# 最佳实践：使用描述性消息\n$ git stash push -m \"WIP: 用户头像上传功能开发中\"\n\n# 切换到主分支修复bug\n$ git checkout main\n$ git pull origin main\n$ git checkout -b hotfix/login-bug\n# ... 修复工作 ...\n\n# 返回后继续开发\n$ git checkout feature/user-avatar\n$ git stash list\n# stash@{0}: WIP: 用户头像上传功能开发中\n\n$ git stash pop\n# 恢复工作进度\n</code></pre>\n<blockquote>\n<p>默认情况下，git stash 只能暂存已跟踪文件（tracked files）的修改，但可以通过参数<code>-u</code>显式包含未跟踪文件。</p>\n</blockquote>\n<pre><code class=\"language-bash\">git stash push -u -m \"描述\"\n</code></pre>\n<ul>\n<li>始终使用 -m 添加描述性消息</li>\n<li>git stash apply（仅恢复）</li>\n<li>git stash pop（恢复并删除）</li>\n<li>定期清理过期的 stash：git stash drop stash@</li>\n<li>git stash clear（清空所有 stash）</li>\n<li>可以跨分支使用 stash</li>\n</ul>\n<h2 id=\"六git-cherry-pick\">六、Git Cherry-Pick</h2>\n<blockquote>\n<p>将特定提交从一个分支复制到另一个分支，而不合并整个分支历史。</p>\n</blockquote>\n<ul>\n<li>涉及单个提交</li>\n</ul>\n<pre><code class=\"language-bash\">git cherry-pick -x &lt;commit-hash&gt;\n</code></pre>\n<blockquote>\n<p>-x 参数表示在提交信息中添加\"cherry picked from commit\"说明</p>\n</blockquote>\n<ul>\n<li>涉及多个提交</li>\n</ul>\n<pre><code class=\"language-bash\">git cherry-pick -x &lt;commit-hash1&gt;..&lt;commit-hash2&gt; # 不包含起始提交\ngit cherry-pick -x &lt;commit-hash1&gt;^..&lt;commit-hash2&gt; # 包含起始提交\n</code></pre>\n<ul>\n<li>冲突处理</li>\n<li>git cherry-pick --continue  # 继续完成cherry-pick</li>\n<li>git cherry-pick --abort  # 撤销并回到初始状态</li>\n</ul>\n<h2 id=\"七git-fetch--git-pull\">七、Git Fetch &amp; Git Pull</h2>\n<h3 id=\"fetch-vs-pull\">fetch VS pull</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">操作</th>\n<th style=\"text-align: center;\">本质</th>\n<th style=\"text-align: center;\">对本地代码的影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">fetch</td>\n<td style=\"text-align: center;\">仅下载远程更新</td>\n<td style=\"text-align: center;\">不改变工作目录和当前分支</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">pull</td>\n<td style=\"text-align: center;\">下载+自动合并(git fetch + git merge 的自动执行)</td>\n<td style=\"text-align: center;\">改变工作目录和当前分支</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"决策树\">决策树</h3>\n<div class=\"mermaid\">flowchart TD\n    A[本地有未提交修改？] --&gt;|是| B[必须用 git stash 或 commit]\n    A --&gt;|否| C[需要查看远程更新？]\n    \n    C --&gt;|是| D[git fetch + 手动merge/rebase]\n    C --&gt;|否| E[追求简洁操作？]\n    \n    E --&gt;|是| F[git pull --rebase]\n    E --&gt;|否| G[需要保留合并历史？]\n    \n    G --&gt;|是| H[git pull 默认merge]\n    G --&gt;|否| I[git pull --rebase]\n    \n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style B fill:#bbf,stroke:#333,stroke-width:1px\n    style C fill:#f9f,stroke:#333,stroke-width:2px\n    style D fill:#bbf,stroke:#333,stroke-width:1px\n    style E fill:#f9f,stroke:#333,stroke-width:2px\n    style F fill:#bbf,stroke:#333,stroke-width:1px\n    style G fill:#f9f,stroke:#333,stroke-width:2px\n    style H fill:#bbf,stroke:#333,stroke-width:1px\n    style I fill:#bbf,stroke:#333,stroke-width:1px\n</div><ul>\n<li>默认 git pull = git fetch + git merge (产生合并提交)</li>\n<li>git pull --rebase = git fetch + git rebase (历史变平)</li>\n</ul>\n<blockquote>\n<p>git pull --rebase<br />\n获取远程更新,将本地提交\"嫁接\"到远程最新提交之上</p>\n</blockquote>\n<h2 id=\"八git-merge--git-rebase\">八、Git Merge &amp; Git Rebase</h2>\n<h3 id=\"merge-vs-rebase\">merge VS rebase</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">操作</th>\n<th style=\"text-align: center;\">本质</th>\n<th style=\"text-align: center;\">对本地代码的影响</th>\n<th style=\"text-align: center;\">应用</th>\n<th style=\"text-align: center;\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">merge</td>\n<td style=\"text-align: center;\">合并两个分支</td>\n<td style=\"text-align: center;\">改变工作目录和当前分支</td>\n<td style=\"text-align: center;\">在「接收合并的目标分支」上执行</td>\n<td style=\"text-align: center;\">站在目标分支，合并进来</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">rebase</td>\n<td style=\"text-align: center;\">将指定分支的提交历史，应用到当前分支</td>\n<td style=\"text-align: center;\">改变工作目录和当前分支</td>\n<td style=\"text-align: center;\">在「被变基的分支」上执行</td>\n<td style=\"text-align: center;\">站在被变基分支，基于基准变</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>⚠️ 黄金法则：<strong>永远不要对位于公共仓库之外的提交（即已经 push 到远程并被他人使用的提交）执行 Rebase。</strong><br />\n只对尚未推送或仅属于你个人的本地提交使用 Rebase。对公共历史 Rebase 会导致团队成员协作时产生混乱和代码丢失。</p>\n</blockquote>\n<h3 id=\"可视化对比\">可视化对比</h3>\n<p><strong>分支初始状态</strong></p>\n<div class=\"mermaid\">graph TD\n    A[提交 A] --&gt; B[提交 B]\n    B --&gt; C[提交 C]\n    C --&gt; D[提交 D]\n    D --&gt; E[提交 E]\n    \n    C --&gt; F[提交 F]\n    F --&gt; G[提交 G]\n    \n    classDef mainBranch fill:#4CAF50,stroke:#333,stroke-width:2px;\n    classDef featureBranch fill:#2196F3,stroke:#333,stroke-width:2px;\n    \n    class A,B,C,D,E mainBranch;\n    class F,G featureBranch;\n    \n    subgraph main 分支\n        A\n        B\n        C\n        D\n        E\n    end\n    \n    subgraph feature 分支\n        F\n        G\n    end\n</div><h4 id=\"git-merge-可视化\">Git Merge 可视化</h4>\n<p><code>git checkout main</code><br />\n<code>git merge feature</code>后状态</p>\n<div class=\"mermaid\">graph TD\n    A[提交 A] --&gt; B[提交 B]\n    B --&gt; C[提交 C]\n    C --&gt; D[提交 D]\n    D --&gt; E[提交 E]\n    E --&gt; H[合并提交 H]\n    \n    C --&gt; F[提交 F]\n    F --&gt; G[提交 G]\n    G --&gt; H\n    \n    classDef mainBranch fill:#4CAF50,stroke:#333,stroke-width:2px;\n    classDef featureBranch fill:#2196F3,stroke:#333,stroke-width:2px;\n    classDef mergeCommit fill:#FF9800,stroke:#333,stroke-width:2px;\n    \n    class A,B,C,D,E,H mainBranch;\n    class F,G featureBranch;\n    class H mergeCommit;\n    \n    subgraph main 分支\n        A\n        B\n        C\n        D\n        E\n        H\n    end\n    \n    subgraph feature 分支\n        F\n        G\n    end\n    \n    %% note right of H: 合并提交保留完整历史\n</div><ul>\n<li>main 分支：指针移到新的合并提交 H，历史新增合并记录；</li>\n<li>feature 分支：指针位置不变（仍指向 G），分支本身毫发无损；</li>\n</ul>\n<h4 id=\"git-rebase-可视化\">Git Rebase 可视化</h4>\n<p><code>git checkout feature</code><br />\n<code>git rebase main</code>后状态</p>\n<div class=\"mermaid\">graph TD\n    A[提交 A] --&gt; B[提交 B]\n    B --&gt; C[提交 C]\n    C --&gt; D[提交 D]\n    D --&gt; E[提交 E]\n    \n    %% Rebase 后，main 分支依然在 E，feature 分支移动到了 F' 和 G'\n    E --&gt; FPrime[提交 F']\n    FPrime --&gt; GPrime[提交 G']\n    \n    classDef mainBranch fill:#4CAF50,stroke:#333,stroke-width:2px;\n    classDef featureBranch fill:#2196F3,stroke:#333,stroke-width:2px;\n    classDef rebasedCommit fill:#9C27B0,stroke:#333,stroke-width:2px;\n    \n    class A,B,C,D,E mainBranch;\n    class FPrime,GPrime featureBranch;\n    class FPrime,GPrime rebasedCommit;\n    \n    subgraph main 分支\n        A\n        B\n        C\n        D\n        E\n    end\n    \n    subgraph feature 分支\n        FPrime\n        GPrime\n    end\n</div><ul>\n<li>main 分支：完全不受影响，指针仍指向 E；</li>\n<li>feature 分支：指针从原来的 G 移到新的 G'（提交历史被重写）</li>\n</ul>\n<h2 id=\"附录\">附录</h2>\n<ul>\n<li>缺少 CI/CD 配置</li>\n</ul>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/NobodyCares/\" target=\"_blank\">Nobody_Cares</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/NobodyCares/p/19406442\" target=\"_blank\">https://www.cnblogs.com/NobodyCares/p/19406442</a></p>\n<span id=\"jinrishici-sentence\">正在加载今日诗词....</span>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 19:21</span>&nbsp;\n<a href=\"https://www.cnblogs.com/NobodyCares\">Nobody_Cares</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "什么是 RESTful API？凭什么能流行 20 多年？",
      "link": "https://www.cnblogs.com/yupi/p/19406314",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/yupi/p/19406314\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 18:22\">\n    <span>什么是 RESTful API？凭什么能流行 20 多年？</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"什么是 RESTful API？凭什么能流行 20 多年？\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2225420/202512/2225420-20251226173923485-981509675.png\" />\n        你是小阿巴，刚入职的后端程序员，负责给前端的阿花提供 API 接口。结果一周后，你被阿花揍得鼻青脸肿。\n阿花：你是我这辈子见过接口写的最烂的程序员！\n你：接口不是能跑就行吗？\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p class=\"md-end-block md-heading\"><span class=\"md-plain\">你是小阿巴，刚入职的后端程序员，负责给前端的阿花提供 API 接口。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">结果一周后，你被阿花揍得鼻青脸肿。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">阿花：你是我这辈子见过接口写的最烂的程序员！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你一脸委屈找到号称 “开发之狗” 的鱼皮诉苦：接口不是能跑就行吗？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮嘲笑道：小阿巴，你必须得学学 <span class=\"md-pair-s \"><strong>RESTful API</strong><span class=\"md-plain\"> 了。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你挠挠头：阿巴阿巴，什么玩意，没听说过！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">⭐️ 推荐观看视频版，动画更生动：<span class=\"md-link md-pair-s\"><a href=\"https://bilibili.com/video/BV1WFBXBmExs\" rel=\"noopener nofollow\">https://bilibili.com/video/BV1WFBXBmExs</a></span></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">什么是 RESTful API？</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：首先，REST 的全称是 <span class=\"md-pair-s \"><strong>REpresentational State Transfer</strong><span class=\"md-plain\">，翻译过来叫 “表现层状态转移”。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你一脸懵：鱼皮 gie gie，能说人话吗？我是傻子，听不太懂。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：别急，我给你拆开来讲，保证你理解。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>RE（Representational）</strong><span class=\"md-plain\"> 表现层，是指 <span class=\"md-pair-s \"><strong>资源（Resource）</strong><span class=\"md-plain\"> 的表现形式。</span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你好奇了：什么是资源？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：资源就是 <span class=\"md-pair-s \"><strong>你想要操作的数据对象</strong><span class=\"md-plain\">。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如用户、商品、文章，这些都是资源。用户列表是一个资源，某个具体的用户也是一个资源。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">表现层是指资源呈现出来的具体格式，比如同一个用户资源，可以用 JSON 格式返回给客户端，也可以用 XML 格式返回，这就是不同的 “表现形式”。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>S（State）</strong><span class=\"md-plain\"> 是指 “状态”。</span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你：啥是状态？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：比如你登录网站后，服务器会在内存中记住 “你是谁”，之后在网站上操作就不用再次登录了，这就是 <span class=\"md-pair-s \"><strong>有状态</strong><span class=\"md-plain\">。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">而 <span class=\"md-pair-s \"><strong>无状态（Stateless）</strong><span class=\"md-plain\"> 呢，就是服务器不记录客户端的任何信息，每次请求都是独立的。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你：哦哦哦，就像一个人去餐厅吃饭，服务员不记得他上次点了什么，每次都要重新点单，这就是无状态。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">反过来，服务员记得他爱吃鱼皮，这就是有状态。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：没错，接下来是 <span class=\"md-pair-s \"><strong>T（Transfer）</strong><span class=\"md-plain\"> 转移。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">要注意，转移是 <span class=\"md-pair-s \"><strong>双向</strong><span class=\"md-plain\"> 的：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）当你用 GET 请求时，服务器把资源的状态（比如用户信息的 JSON 数据）转移给客户端。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）当你用 POST/PUT 请求时，客户端把资源的新状态（比如新用户的信息）转移给服务器，从而改变服务器上资源的状态。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">组合起来，<span class=\"md-pair-s \"><strong>REST（Representational State Transfer）</strong><span class=\"md-plain\"> 是一种 <span class=\"md-pair-s \"><strong>软件架构风格</strong><span class=\"md-plain\">，让客户端和服务器通过统一的接口，以无状态的方式，互相传递资源的表现层数据（比如 JSON），来查询或者变更资源状态。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">而 <span class=\"md-pair-s \"><strong>ful</strong><span class=\"md-plain\"> 是个后缀，就像 powerful（充满力量的）一样，表示 “充满...特性的”。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">因此，<span class=\"md-pair-s \"><strong>RESTful API 是指符合 REST 架构风格的 API</strong><span class=\"md-plain\">，也就是遵循 REST 原则设计出来的接口。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">注意，它 <span class=\"md-pair-s \"><strong>不是协议、不是标准、不是强制规范</strong><span class=\"md-plain\">，只是一种建议的设计风格。你可以遵循，也可以不遵循。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你挠了挠头：说了一大堆，RESTful API 到底长啥样啊？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：举个例子，比如你要做个用户管理系统，对用户信息进行增删改查，用 RESTful 风格的 API 就长这样：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>GET /users/123 &nbsp; &nbsp; &nbsp; 获取 ID 为 123 的用户<br /><span>POST /users &nbsp; &nbsp; &nbsp; &nbsp; 创建新用户<br /><span>PUT /users/123 &nbsp; &nbsp; &nbsp; 更新用户 123<br /><span>DELETE /users/123 &nbsp; 删除用户 123</span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你眼前一亮：哇，比我写的整齐多了！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">快带我学一下 RESTful 的写法吧，我要让前端阿花刮目相看！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">RESTful API 写法</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：好，很有志气！接下来我会带你一步步构造一个完整的 RESTful API。分为两部分，<span class=\"md-pair-s \"><strong>客户端发送请求</strong><span class=\"md-plain\"> 和 <span class=\"md-pair-s \"><strong>服务端给出响应</strong><span class=\"md-plain\">。</span></span></span></span></span></p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">客户端请求</span></h3>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">第一步：确定资源</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">资源用 URI（统一资源标识符）来表示。核心原则是：<span class=\"md-pair-s \"><strong>用名词来表示资源，不用动词</strong><span class=\"md-plain\">。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">具体来说，<span class=\"md-pair-s \"><strong>推荐用名词复数表示资源集合</strong><span class=\"md-plain\">，比如 <span class=\"md-pair-s\"><code>/users</code><span class=\"md-plain\"> 表示用户列表、<span class=\"md-pair-s\"><code>/products</code><span class=\"md-plain\"> 表示商品列表。</span></span></span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果要操作 <span class=\"md-pair-s \"><strong>具体某个资源，就加上 ID</strong><span class=\"md-plain\">，比如 <span class=\"md-pair-s\"><code>/users/123</code><span class=\"md-plain\"> 表示 ID 为 123 的用户。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">资源还 <span class=\"md-pair-s \"><strong>支持嵌套</strong><span class=\"md-plain\">，比如 <span class=\"md-pair-s\"><code>/users/123/orders</code><span class=\"md-plain\"> 表示用户 123 的所有订单。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你想了想：那还可以更深层级么？比如 <span class=\"md-pair-s\"><code>/users/123/orders/456</code><span class=\"md-plain\"> 表示用户 123 的订单 456。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮点点头：你的理解完全正确，但不建议嵌套层级太深。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">第二步：选择动作</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">确定了资源后，接下来要选择 <span class=\"md-pair-s \"><strong>动作</strong><span class=\"md-plain\">，也就是你想怎么处理这个资源。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">RESTful API 主要通过不同的 HTTP 方法来表示增删改查操作：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">1）GET：查询资源</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>GET /users</code><span class=\"md-plain\"> 查询所有用户</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>GET /users/123</code><span class=\"md-plain\"> 查询 ID 为 123 的用户</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">2）POST：创建资源</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>POST /users</code><span class=\"md-plain\"> 创建新用户</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">3）PUT：完整更新资源，需要提供资源的所有字段，多次执行结果相同（幂等性）</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>PUT /users/123</code><span class=\"md-plain\"> 完整更新用户 123</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">4）PATCH：部分更新资源，通常用于更精细的操作</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>PATCH /users/123</code><span class=\"md-plain\"> 只更新用户 123 的某些字段</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">5）DELETE：删除资源</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>DELETE /users/123</code><span class=\"md-plain\"> 删除用户 123</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：到这里，一个基本的 RESTful API 请求就构造完成了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你：就这么简单？我不满足，还有更高级的写法吗？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：当然~</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">第三步：添加查询条件（可选）</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有时候我们需要更精确地筛选数据，这时候可以加查询参数，比如：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">分页：<span class=\"md-pair-s\"><code>/users?page=2&amp;limit=10</code><span class=\"md-plain\"> 查询第 2 页，每页 10 条用户数据</span></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">过滤：<span class=\"md-pair-s\"><code>/users?gender=male&amp;age=25</code><span class=\"md-plain\"> 查询性别为男、年龄 25 的用户</span></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">排序：<span class=\"md-pair-s\"><code>/users?sort=created_at&amp;order=desc</code><span class=\"md-plain\"> 按创建时间倒序排列用户</span></span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你：等等，这查询参数跟 RESTful 有啥关系？正常的请求不都是这么写吗？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：确实，查询参数本身不是 RESTful 特有的。但 RESTful 风格强调 <span class=\"md-pair-s \"><strong>把筛选、排序、分页这些操作，都通过 URL 参数来表达</strong><span class=\"md-plain\">：</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">而不是在请求体里传一堆复杂的 JSON 对象：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这样一来，URL 更清晰，而且浏览器、CDN、代理服务器都能直接根据 URL 来缓存响应结果。比如 <span class=\"md-pair-s\"><code>/users?page=1</code><span class=\"md-plain\"> 和 <span class=\"md-pair-s\"><code>/users?page=2</code><span class=\"md-plain\"> 是两个不同的 URL，可以分别缓存。但如果把参数放在请求体里，URL 都是 <span class=\"md-pair-s\"><code>/users</code><span class=\"md-plain\">，缓存就没法区分了。</span></span></span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">第四步：版本控制（可选）</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">随着业务发展，接口可能需要升级。为了不影响老用户，可以在 URI 中标明版本：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>/v1/users</code><span class=\"md-plain\"> 第一版用户接口</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><code>/v2/users</code><span class=\"md-plain\"> 第二版用户接口</span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这样，老用户继续用 v1，新用户用 v2，互不影响。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">第五步：保持无状态</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，还记得我们前面讲 REST 里的 <span class=\"md-pair-s \"><strong>ST（State Transfer）</strong><span class=\"md-plain\"> 吗？</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">RESTful 的核心原则之一是 <span class=\"md-pair-s \"><strong>无状态（Stateless）</strong><span class=\"md-plain\">，客户端每次请求必须包含所有必要信息，服务器不记录客户端状态。</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如用户登录后，不是让服务器记住 “你已经登录了”，而是每次请求都要带上身份凭证（Token），像这样：</span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>GET /orders<br /><span>Header: Authorization: Bearer xxx</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这么做的好处是，服务器不用记录谁登录了、谁没登录，每个请求都是独立的。这样一来，你想加多少台服务器都行，任何一台都能处理请求，轻松实现负载均衡和横向扩展。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你点头如捣蒜：怪不得我调用 AI 大模型 API 的时候，就要传这个 Token！</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">服务端响应</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：讲完客户端请求，再来看服务器收到请求后，该怎么响应？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">主要注意 2 点：</span></p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">1、统一响应格式</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">目前大多数 RESTful API 基本都用 <span class=\"md-pair-s \"><strong>JSON</strong><span class=\"md-plain\"> 格式，因为轻量、容易解析。</span></span></span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>{<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"id\":&nbsp;<span class=\"cm-number\">123,<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"name\":&nbsp;<span class=\"cm-string\">\"小阿巴\",<br /><span>&nbsp;<span class=\"cm-string cm-property\">\"email\":&nbsp;<span class=\"cm-string\">\"aba@codefather.cn\"<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但这并不是强制的，也可以用 XML、HTML 等格式。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2、返回合适的 HTTP 状态码</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">响应要带上合适的状态码，让客户端一眼看懂发生了什么。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">HTTP 状态码有很多，大体可以分为 5 类：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>1xx 系列</strong><span class=\"md-plain\">：信息提示（用得少，了解即可）</span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>2xx 系列</strong><span class=\"md-plain\">：成功</span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">200 OK：请求成功，正常返回数据（用于 GET、PUT、PATCH）</span></p>\n</li>\n</ul>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>3xx 系列</strong><span class=\"md-plain\">：重定向</span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">301 Moved Permanently：资源永久移动到新位置</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">302 Found：资源临时移动</span></p>\n</li>\n</ul>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>4xx 系列</strong><span class=\"md-plain\">：客户端错误</span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">400 Bad Request：请求参数格式错误</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">401 Unauthorized：未验证身份，需要登录</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">403 Forbidden：已认证但没有权限访问</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">404 Not Found：资源不存在</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">405 Method Not Allowed：请求方法不被允许</span></p>\n</li>\n</ul>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong>5xx 系列</strong><span class=\"md-plain\">：服务器错误</span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">500 Internal Server Error：服务器内部错误</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">502 Bad Gateway：网关错误</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">503 Service Unavailable：服务暂时不可用</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">504 Gateway Timeout：网关超时</span></p>\n</li>\n</ul>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你恍然大悟：懂了，以后前端看到 500，就知道是我后端的锅；看到 400，就知道是她自己传参传错了。谁也别想甩锅！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮点点头：不错，以上这些，就是 RESTful API 的基本写法。你学会了吗？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你：学废了，学废了！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：那我来考考你，下面哪个是标准的 RESTful API？</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">A. <span class=\"md-pair-s\"><code>GET /getUsers</code></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">B. <span class=\"md-pair-s\"><code>GET /user/list</code></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">C. <span class=\"md-pair-s\"><code>POST /users/query</code></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">D. <span class=\"md-pair-s\"><code>GET /users/delete/123</code></span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你开心地怪叫起来：阿巴，肯定是 C 啊！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：错，<span class=\"md-pair-s \"><strong>4 个全都不标准</strong><span class=\"md-plain\">！</span></span></span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">A 用了动词 <span class=\"md-pair-s\"><code>getUsers</code></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">B 用了单数 <span class=\"md-pair-s\"><code>user</code><span class=\"md-plain\"> 和动词 <span class=\"md-pair-s\"><code>list</code></span></span></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">C 用 POST 查询，还带了动词 <span class=\"md-pair-s\"><code>query</code></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">D 用 GET 删除，还带了动词 <span class=\"md-pair-s\"><code>delete</code></span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你掉了根头发：原来这么严格！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">等等，你说 RESTful 不能用动词，但有些操作不是标准的增删改查啊，比如用户要支付订单，该怎么设计接口呢？是要用 <span class=\"md-pair-s\"><code>POST /orders/123/pay</code><span class=\"md-plain\">？</span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮摇头：你已经很努力了，但 pay 是动词。更标准的设计是把 “支付” 行为看作 <span class=\"md-pair-s \"><strong>创建</strong><span class=\"md-plain\"> 一个支付记录，用名词而不是动词。</span></span></span></p>\n<pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\"><span>POST /orders/123/payments</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如这个请求，表示为订单 123 创建一笔支付记录。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你又掉了根头发：妙啊，怪不得说英语对学编程有帮助呢，我悟了，我悟了！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">RESTful 的六大约束</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：不错，学到这里你已经掌握了 RESTful 的 80%，能够实际应用了。接下来的知识，你只需简单了解一下，就能拿去和面试官吹牛皮了。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如很多同学都不知道，RESTful 其实有 6 个约束条件：</span></p>\n<ol class=\"ol-list\" start=\"\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Client-Server（客户端-服务器分离）：前后端各干各的活，前端负责展示，后端负责数据处理，互不干扰。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Stateless（无状态）：每次请求都是独立的，服务器不保存客户端的会话信息，所有必要信息都在请求中携带。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Cacheable（可缓存）：服务器的响应可以被标记为可缓存或不可缓存，客户端可以重用缓存数据，减少服务器压力，提升性能。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Layered System（分层系统）：客户端不需要知道直接连的是服务器还是中间层，系统可以灵活地加代理、网关、负载均衡器等。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Uniform Interface（统一接口）：所有资源都通过统一的接口访问，降低理解成本，提高可维护性。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Code-On-Demand（按需代码）：可选项，服务器可以返回可执行代码（比如 JavaScript）给客户端执行，但实际工作中很少用。</span></p>\n</li>\n</ol>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你直接听懵了：阿巴阿巴，这么多约束，我必须全遵守吗？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：可以不用，RESTful 只是一种 API 的 <span class=\"md-pair-s \"><strong>建议风格</strong><span class=\"md-plain\">。在实际工作中，很少有 API 能完美符合所有约束，大家可以灵活调整，甚至什么接口都用 <span class=\"md-pair-s \"><strong>POST + 动词</strong><span class=\"md-plain\"> 一把梭。只要团队达成一致、用得舒服就行。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">就像刚才那个支付订单的例子，<span class=\"md-pair-s\"><code>POST /orders/123/payments</code><span class=\"md-plain\"> 虽然符合 RESTful 规范，但有同学会觉得 <span class=\"md-pair-s\"><code>POST /orders/123/pay</code><span class=\"md-plain\"> 更直观易懂，也没问题。</span></span></span></span></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不过现阶段，我建议你先养成遵循 RESTful 的好习惯，等积累了经验，再根据实际情况灵活调整。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">怎么快速实现 RESTful API？</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你：呜呜，但我只是个小阿巴，背不下来这些写法，我怕自己写着写着就不规范了，怎么办啊？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮：别担心，有很多方法可以帮你快速实现和检查 RESTful API。</span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">1、使用开发框架</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">几乎所有主流开发框架都支持 RESTful API 的开发，它们能帮你自动处理很多细节，比如：</span></p>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Java 的 Spring Boot：通过 <span class=\"md-pair-s\"><code>@GetMapping(\"/users\")</code><span class=\"md-plain\">、<span class=\"md-pair-s\"><code>@PostMapping(\"/users\")</code><span class=\"md-plain\"> 等注解，你只需要写一行代码就能定义符合 RESTful 风格的路由。框架会自动把对象转成 JSON、设置正确的 HTTP 状态码，你都不用操心。</span></span></span></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Python 的 Django REST Framework：你只需要定义一个数据模型（比如 User 类），框架就能自动生成 <span class=\"md-pair-s\"><code>GET /users</code><span class=\"md-plain\">、<span class=\"md-pair-s\"><code>POST /users</code><span class=\"md-plain\">、<span class=\"md-pair-s\"><code>PUT /users/123</code><span class=\"md-plain\">、<span class=\"md-pair-s\"><code>DELETE /users/123</code><span class=\"md-plain\"> 这一整套 RESTful 接口，大幅减少代码量。</span></span></span></span></span></span></span></span></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">Go 的 Gin ：专门为 RESTful API 设计，语法非常简洁。比如 <span class=\"md-pair-s\"><code>router.GET(\"/users/:id\", getUser)</code><span class=\"md-plain\"> 就能绑定一个 GET 请求，自动从 URL 中提取 ID 参数，还能通过路由分组把 <span class=\"md-pair-s\"><code>/api/v1/users</code><span class=\"md-plain\"> 和 <span class=\"md-pair-s\"><code>/api/v2/users</code><span class=\"md-plain\"> 轻松分开管理。</span></span></span></span></span></span></span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这些框架虽然不强制你遵循 RESTful，但用它们的特性，开发起来既轻松又规范，帮你省掉大量重复代码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2、使用 IDE 插件</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如 IDEA 的 RESTful Toolkit 插件，可以快速查看和测试接口。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">还有 VSCode 的 REST Client 插件，可以直接在编辑器里测试接口。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">3、利用 AI 生成</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">RESTful 有明确的设计规范，而 AI 最擅长处理这种有章可循的东西！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">比如直接让 Cursor 帮你用 Spring Boot 写一个用户管理的 RESTful API：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你只需要阿巴阿巴几下，它就能生成规范的代码。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">4、生成接口文档</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">写完接口后，还可以用 Swagger 这类工具自动生成漂亮的接口文档，直接甩给前端，对方一看就懂，还能在线测试接口，省去大量沟通成本。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你笑得像个孩子：这么一看，RESTful API 不仅让接口规范统一，还能提高开发效率，降低团队沟通成本，前后端都舒服！爽爽爽！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">鱼皮点点头：没错，这也是为什么 RESTful 能成为业界主流的原因。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你：学会了学会了，我这就去重构所有接口，让前端阿花刮目相看！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">结尾</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">一周后，你把所有接口重构成了 RESTful 风格。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">前端阿花打开新的接口文档，眼睛亮了：小阿巴，你居然开窍了？！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你得意地笑了：那是，我可是学过 RESTful 的男人~ 阿花，晚上要不要一起？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">阿花朝你吐了口唾沫：呸，你只不过学了一种 API 风格就得意洋洋。阿坤哥哥不仅精通 RESTful，还能手撕 GraphQL 和 gRPC 呢，你行么？</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你难受得不行：啥啥啥，这都是啥啊…… 鱼皮 gie gie 快来救我！</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\"><img class=\"lazyload\" style=\"display: block; margin-left: auto; margin-right: auto;\" /></span></p>\n<p class=\"md-end-block md-p\">&nbsp;</p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">更多编程学习资源</span></h2>\n<ul class=\"ul-list\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course\" rel=\"noopener nofollow\"><span class=\"md-plain\">Java前端程序员必做项目实战教程+毕设网站</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费编程学习交流社区（自学必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/course/cv\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员保姆级求职写简历指南（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.mianshiya.com/\" rel=\"noopener nofollow\"><span class=\"md-plain\">程序员免费面试刷题网站工具（找工作必备）</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640584449888772098\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Java零基础入门学习路线 + Java教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586673306091521\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Python零基础入门学习路线 + Python教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586014108303362\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新前端零基础入门学习路线 + 前端教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586867363954689\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据结构和算法零基础入门学习路线 + 算法教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1644279832026075138\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新C++零基础入门学习路线、C++教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641797333479903234\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新数据库零基础入门学习路线 + 数据库教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640589994284695553\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Redis零基础入门学习路线 + Redis教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641035880439271426\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机基础入门学习路线 + 计算机基础教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1641366118197153793\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新小程序入门学习路线 + 小程序开发教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"http://sqlmother.yupi.icu/\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新SQL零基础入门学习路线 + SQL教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640586295529324545\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Linux零基础入门学习路线 + Linux教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588753362108417\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新Git/GitHub零基础入门学习路线 + Git教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640587909942099969\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新操作系统零基础入门学习路线 + 操作系统教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588119619551233\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新计算机网络零基础入门学习路线 + 计算机网络教程</span></a></span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://www.code-nav.cn/post/1640588392073150465\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新设计模式零基础入门学习路线 + 设计模式教程</span></a></span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-meta-i-c md-link md-expand\"><a href=\"https://www.code-nav.cn/post/1640648711119892481\" rel=\"noopener nofollow\"><span class=\"md-plain\">最新软件工程零基础入门学习路线 + 软件工程教程</span></a></span></p>\n</li>\n</ul>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 18:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/yupi\">程序员鱼皮</a>&nbsp;\n阅读(<span id=\"post_view_count\">15</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "选框架选到头秃？别让“技术赌博”毁了你的项目",
      "link": "https://www.cnblogs.com/huizhudev/p/19406245",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/huizhudev/p/19406245\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 18:09\">\n    <span>选框架选到头秃？别让“技术赌博”毁了你的项目</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"选框架选到头秃？别让“技术赌博”毁了你的项目\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/3695776/202512/3695776-20251226180832229-1607943278.png\" />\n        面对复杂的技术栈选择，单纯靠经验容易陷入误区。本文提供了一套“技术选型分析 AI 指令”，将 AI 化身为 15 年经验的架构师，通过多维度加权评分和风险评估，帮助技术决策者做出客观、数据驱动的架构决策，避免为错误的选型买单。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>打开 CNCF 的云原生全景图，是不是感觉像在看一张只有天文望远镜才能解析的星图？<br />\n站在 2024 年的尾巴上，作为技术决策者，我们面临的挑战早已不是“怎么实现功能”，而是<strong>“用什么实现功能”</strong>。</p>\n<p>是坚守 Java 的稳重，还是拥抱 Go 的高效？<br />\n是继续在 React 的生态里深耕，还是去 Vue 3 的舒适区躺平，亦或是尝尝 Svelte 的鲜？<br />\n数据库是用老牌的 MySQL，还是时髦的 TiDB，或者干脆上云原生数据库？</p>\n<p>每一个选择背后，都潜藏着巨大的<strong>“机会成本”</strong>。<br />\n选对了，风生水起，扩展如丝般顺滑；<br />\n选错了，就是给自己和团队挖了一个深不见底的坑，未来的无数个通宵都在为今天的草率买单。</p>\n<p>我们往往习惯于：</p>\n<ul>\n<li><strong>凭经验</strong>：“以前用过这个，稳。”（但可能已过时）</li>\n<li><strong>跟风口</strong>：“大厂都在用，肯定没错。”（但你的业务规模匹配吗？）</li>\n<li><strong>拍脑袋</strong>：“我觉得这个 Logo 挺好看。”（纯粹的赌徒心态）</li>\n</ul>\n<p><strong>在这个技术爆炸的时代，单纯依靠个人的经验半径来做决策，已经越来越危险了。</strong><br />\n你需要一个绝对客观、视野无限、且精通权衡之道的“外脑”。</p>\n<p><img alt=\"选框架选到头秃？别让“技术赌博”毁了你的项目\" class=\"lazyload\" /></p>\n<h2 id=\"-把-ai-变成你的首席架构师\">🧭 把 AI 变成你的“首席架构师”</h2>\n<p>人类架构师有偏见，有知识盲区，有情感倾向。但 AI 没有。<br />\n只要你给它设定好正确的<strong>“人设”</strong>和<strong>“评估框架”</strong>，它就能化身为一位拥有 15 年经验的资深技术顾问，为你提供不带感情色彩、只有数据和逻辑的决策支持。</p>\n<p>为此，我打磨了一套<strong>「技术选型分析 AI 指令」</strong>。<br />\n它不是让你问 AI “哪个框架好”，而是要求 AI 进行一场<strong>系统化的可行性研究</strong>。它强制 AI 从<strong>业务场景、团队能力、长期 TCO（总拥有成本）、风险评估</strong>等多个维度，输出一份能够直接拿到 CTO 办公会上汇报的分析报告。</p>\n<h3 id=\"-复制这个指令让决策有据可依\">📋 复制这个指令，让决策有据可依</h3>\n<p>这套指令的核心在于<strong>“多维度加权评分”</strong>。它强迫 AI 量化每一个指标，而不是给出模棱两可的建议。</p>\n<pre><code class=\"language-markdown\"># 角色定义\n你是一位资深的技术架构顾问，拥有15年以上的系统架构设计和技术选型经验。你熟悉主流的技术栈、框架和云服务，擅长从业务需求、技术可行性、成本效益、团队能力等多维度进行综合分析。你的决策风格是数据驱动、证据优先，始终保持客观中立，不偏袒任何特定技术阵营。\n\n# 核心能力\n- **多维度评估**: 能从性能、安全、成本、可维护性、生态成熟度等维度全面评估\n- **风险识别**: 善于识别技术债务、供应商锁定、技术过时等潜在风险\n- **落地指导**: 能提供从选型到实施的完整路径指导\n- **证据支撑**: 所有结论都有数据、案例或权威来源支撑\n\n# 任务描述\n请基于以下信息，进行全面系统的技术选型分析，帮助我做出最优的技术决策。\n\n**技术选型需求**:\n- **选型主题**: [需要选型的技术领域，如：前端框架/数据库/消息队列/容器编排等]\n- **业务场景**: [具体的业务需求和使用场景]\n- **候选技术**: [已初步筛选的候选技术列表，可选]\n- **关键约束**: [团队技术栈/预算/时间/合规等约束条件]\n\n**补充信息**（可选）:\n- **团队情况**: [团队规模、技术背景、现有技能储备]\n- **现有架构**: [当前系统架构、技术债务情况]\n- **非功能需求**: [性能指标、可用性要求、安全合规要求]\n- **决策权重**: [最看重的因素，如成本优先/性能优先/稳定性优先]\n\n# 输出要求\n\n## 1. 内容结构\n\n### 📊 第一部分：选型背景分析\n- 需求场景深度解读\n- 核心问题识别\n- 选型目标明确化\n- 约束条件梳理\n\n### 🔍 第二部分：候选技术评估\n- 候选技术识别与筛选（若未提供）\n- 技术能力矩阵对比表\n- 各技术方案优劣势深度分析\n- 技术成熟度与生态评估\n\n### 📈 第三部分：多维度对比分析\n提供以下维度的对比评分（1-5分制）：\n| 评估维度 | 技术A | 技术B | 技术C | 权重 |\n|---------|-------|-------|-------|------|\n| 性能表现 | - | - | - | - |\n| 学习成本 | - | - | - | - |\n| 社区生态 | - | - | - | - |\n| 运维成本 | - | - | - | - |\n| 扩展性 | - | - | - | - |\n| 安全性 | - | - | - | - |\n| 供应商锁定风险 | - | - | - | - |\n| **加权总分** | - | - | - | - |\n\n### ⚠️ 第四部分：风险评估\n- 技术风险识别\n- 实施风险评估\n- 长期维护风险\n- 风险缓解策略\n\n### 🎯 第五部分：选型建议\n- 最终推荐方案及理由\n- 备选方案说明\n- 关键决策因素分析\n- 不建议方案及原因\n\n### 🛠️ 第六部分：实施路径\n- 概念验证（POC）建议\n- 分阶段实施计划\n- 关键里程碑定义\n- 回滚预案设计\n\n## 2. 质量标准\n- **客观性**: 不带主观偏见，基于事实和数据分析\n- **完整性**: 覆盖所有关键决策维度，无重大遗漏\n- **可执行性**: 建议具体可落地，有明确的下一步行动\n- **证据性**: 重要结论有数据、案例或权威来源支撑\n- **风险意识**: 充分识别并评估潜在风险\n\n## 3. 格式要求\n- 使用表格呈现对比数据\n- 使用列表呈现优缺点\n- 关键结论使用**加粗**标注\n- 风险项使用⚠️标识\n- 推荐项使用✅标识\n- 不推荐项使用❌标识\n- 总字数：3000-5000字\n\n## 4. 风格约束\n- **语言风格**: 专业严谨，但避免过度使用晦涩术语\n- **表达方式**: 客观第三人称，数据优先\n- **专业程度**: 面向资深技术人员，可使用专业概念但需适当解释\n- **决策态度**: 给出明确建议，但保留灵活性，尊重决策者最终判断\n\n# 质量检查清单\n\n在完成输出后，请自我检查：\n- [ ] 是否充分理解了业务需求和约束条件？\n- [ ] 是否全面评估了所有合理的候选技术？\n- [ ] 对比维度是否覆盖了关键决策因素？\n- [ ] 评分和权重设置是否合理有依据？\n- [ ] 风险识别是否充分，缓解策略是否可行？\n- [ ] 最终建议是否明确且有充分理由支撑？\n- [ ] 实施路径是否具体可执行？\n- [ ] 是否考虑了长期维护和演进成本？\n\n# 注意事项\n- 避免技术偏见：不要因个人喜好而偏袒特定技术\n- 重视团队因素：优秀的技术不一定是最适合的技术\n- 考虑长期成本：不仅看短期实施成本，也要评估长期维护成本\n- 警惕\"银弹思维\"：没有完美的技术方案，只有适合场景的方案\n- 保持技术中立：对于有争议的技术，呈现多方观点\n- 数据支撑：尽量使用benchmark数据、案例研究而非主观判断\n\n# 输出格式\n请按照上述结构，输出一份完整的技术选型分析报告，包含清晰的章节标题、结构化的对比表格、明确的建议结论和可执行的实施路径。\n</code></pre>\n<h2 id=\"️-拒绝拍脑袋用数据说话\">⚖️ 拒绝“拍脑袋”，用数据说话</h2>\n<p>这套指令最强大的地方，在于它能帮你<strong>“看见”</strong>那些容易被忽视的隐性成本。</p>\n<p>以前我们做决定：</p>\n<blockquote>\n<p>“选 MongoDB 吧，开发快，大家都在用。”</p>\n</blockquote>\n<p>现在 AI 帮你做决定：</p>\n<blockquote>\n<p>“虽然 MongoDB 开发初期效率高（5分），但针对你描述的强事务金融场景（权重 40%），其 ACID 保证和数据一致性维护成本（2分）将成为后期瓶颈。相比之下，虽然 PostgreSQL 学习曲线稍陡（3分），但在数据完整性和复杂查询性能（5分）上更匹配你的业务需求。<strong>综合加权评分：PG (4.2) &gt; Mongo (3.5)。</strong>”</p>\n</blockquote>\n<p>这不只是一次技术推荐，更是一次<strong>思维风暴</strong>。<br />\n它会逼问你：</p>\n<ul>\n<li>你的团队真的 hold 得住 Kubernetes 的运维复杂度吗？</li>\n<li>你现在的预算能支撑这个商业数据库三年的 License 费用吗？</li>\n<li>如果这个开源项目明年停更了，你有 Plan B 吗？</li>\n</ul>\n<h2 id=\"️-怎么用好这把瑞士军刀\">🛠️ 怎么用好这把“瑞士军刀”？</h2>\n<p><strong>1. 明确约束，越细越好</strong><br />\n不要只说“我要选个数据库”。要说：“我要选个时序数据库，处理 IoT 设备数据，每秒写入 10万点，查询主要是最近 24 小时数据，运维团队只有 2 人，预算每月 5000 块。”<br />\n<strong>约束越具体，AI 的推荐就越精准。</strong></p>\n<p><strong>2. 调整权重，量体裁衣</strong><br />\n如果是创业公司的 MVP 阶段，把“开发效率”和“学习成本”的权重调高；<br />\n如果是银行的核心交易系统，把“安全性”和“稳定性”的权重拉满。<br />\n<strong>没有最好的技术，只有最适合当下的技术。</strong></p>\n<p><strong>3. 把它当做“蓝军”</strong><br />\n即使你心里已经有了答案，也不妨用这个指令跑一遍。让 AI 站在客观的角度，去挑战你的预设，看看能不能找出你忽略的风险点。<br />\n<strong>能够经得起 AI 深度拷问的架构，才是真正健壮的架构。</strong></p>\n<p>技术选型是一场没有标准答案的考试，但至少，我们可以不交白卷，也不乱蒙答案。<br />\n带上这个 AI 顾问，让你的每一次 <code>git init</code> 都有据可依，底气十足。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 18:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/huizhudev\">realhuizhu</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "STM32F4xxx系列 - DAC生成噪声波",
      "link": "https://www.cnblogs.com/marshmallows/p/19404051",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/marshmallows/p/19404051\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 16:19\">\n    <span>STM32F4xxx系列 - DAC生成噪声波</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>目标：利用定时器5（周期为5ms），从DAC1通道产生一个噪声波。<br />\n涉及知识：DAC原理、stm32中的DAC、定时器、DAC输出IO配置</p>\n<h1 id=\"1-dac原理\">1. DAC原理</h1>\n<p>DAC，是将数字输入转换成模拟输出，主要有两种实现方式：</p>\n<ol>\n<li>电阻-电位器网络 ：通过开关控制不同的电阻分压，生成对应的模拟电压。</li>\n<li>电容-二进制加权 ：<font color=\"red\">利用电容的充放电特性，快速生成模拟信号。</font></li>\n</ol>\n<h1 id=\"2-二进制加权算法\">2. 二进制加权算法</h1>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<h1 id=\"3-stm32f407zg中的dac特性\">3. STM32F407ZG中的DAC特性</h1>\n<p>有2个12位的DAC模块，对应输出引脚为PA4、PA5，各2个通道。<br />\n1、可选择8/12模式，向左还是向右对齐<br />\n2、单通道模式或双通道模式<br />\n<img alt=\"{B098A18D-7151-4DF9-81BC-FA783917067D}\" class=\"lazyload\" /><br />\n3、触发方式：<br />\n自动触发、定时器触发、外部中断触发<br />\n<img alt=\"{B10CE36A-B554-45E8-9F3B-2756984D1D43}\" class=\"lazyload\" /></p>\n<p>3、输出计算方式<br />\n<img alt=\"{AB969A4A-21A6-4E2D-9A7F-CE972FC0D3B2}\" class=\"lazyload\" /></p>\n<h1 id=\"4-定时器\">4. 定时器</h1>\n<p>根据时钟树:<br />\n（1）高级定时器timer1, timer8以及通用定时器timer9, timer10, timer11 ----- APB2总线<br />\n（2）通用定时器timer2-timer5，timer12-timer14以及基本定时器timer6,timer7 ----- APB1总线</p>\n<p>（3）当APB1和APB2分频数为1，时钟频率=原频率</p>\n<p>（4）当APB1和APB2分频数不为1，时钟频率=原频率x2</p>\n<p>核心计算方式：<br />\nTout = ((arr+1)*(psc+1))/Tclk，arr为预载值，psc为分频值，Tout为时钟频率</p>\n<p>本实验使用的tim5挂载在APB1上，16位。</p>\n<h1 id=\"4-程序配置\">4. 程序配置</h1>\n<h2 id=\"41dac配置\">4.1DAC配置</h2>\n<p>在DAC.c文件中创建配置函数<br />\n1、DAC输出IO配置<br />\n为了避免寄生电流消耗，应首先将 PA4 或 PA5 引脚配置为模拟模式 (AIN)。<br />\n2、DAC转换配置<br />\n1）使能DAC时钟<br />\n2）选择DAC触发方式为timer5触发:<br />\nCR-TENx 控制位置 1，可通过外部事件<br />\nCR-TSELx[2:0] 决定通过哪一个来触发转换<br />\n<img alt=\"{23331BD1-41C3-4DC1-AD72-B12B3DD5F02D}\" class=\"lazyload\" /><br />\n<code>DAC_InitStructure.DAC_Trigger=DAC_Trigger_T5_TRGO;</code><br />\n3)选择在转换后的信号上加上伪噪声<br />\n使用 LFSR（线性反馈移位寄存器）。将 WAVEx[1:0] 置为<br />\n“01”即可选择生成噪声。<br />\n<code>DAC_InitStructure.DAC_WaveGeneration=DAC_WaveGeneration_Noise;</code><br />\n4）设置噪声的最大幅值<br />\n最大就是12位，拉满3.3v<br />\n<code>DAC_InitStructure.DAC_LFSRUnmask_TriangleAmplitude=DAC_LFSRUnmask_Bits11_0;</code><br />\n5）关闭输出缓冲<br />\n如果不需要驱动外部<br />\n6）初始化，将相应寄存器设置好<br />\n7）使能打开<br />\n完整代码：</p>\n<pre><code class=\"language-c\">void DAC1_Init(void)\n{\n\tGPIO_InitTypeDef  GPIO_InitStructure;\n\tDAC_InitTypeDef DAC_InitStructure;\n\t\n\tRCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);//使能GPIOA时钟\n\tRCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);//使能DAC时钟\n\t\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;//模拟输入\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t//GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;//浮空\n\tGPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化\n\tGPIO_SetBits(GPIOA,GPIO_Pin_4);\n\t\n\tDAC_InitStructure.DAC_Trigger=DAC_Trigger_T5_TRGO;\t//不使用触发功能 TEN1=0\n\tDAC_InitStructure.DAC_WaveGeneration=DAC_WaveGeneration_Noise;//不使用波形发生\n\tDAC_InitStructure.DAC_LFSRUnmask_TriangleAmplitude=DAC_LFSRUnmask_Bits11_0;//屏蔽、幅值设置\n\tDAC_InitStructure.DAC_OutputBuffer=DAC_OutputBuffer_Disable ;\t//DAC1输出缓存关闭 BOFF1=1\n\tDAC_Init(DAC_Channel_1,&amp;DAC_InitStructure);\t //初始化DAC通道1\n\t\n\t\n\t\n\t\n\tDAC_Cmd(DAC_Channel_1, ENABLE);  //使能DAC通道1\n\tDAC_SetChannel1Data(DAC_Align_12b_R, 0);  //12位右对齐数据格式设置DAC值\n\t\n}\n\n</code></pre>\n<h2 id=\"42定时器配置\">4.2定时器配置</h2>\n<p>1）使能时钟<br />\n2）设置装载值：arr(不得超过16位无符号)=500-1<br />\n3）设置分频值：psc（不得超过16位无符号值）=8400-1<br />\n4）计数方式：向上计数<br />\n5）初始化<br />\n6）打开使能</p>\n<p>完整代码：</p>\n<pre><code class=\"language-c\">void Tim5_Init(uint16_t arr, uint16_t psc)\n{\n\n    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;\n\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);\n\n    TIM_TimeBaseInitStructure.TIM_Period = arr;\n\n    TIM_TimeBaseInitStructure.TIM_Prescaler = psc;\n    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;\n    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;\n\n    TIM_TimeBaseInit(TIM5, &amp;TIM_TimeBaseInitStructure);\n\n    TIM_Cmd(TIM5, ENABLE);\n\n}\n\n</code></pre>\n<h2 id=\"43定时器触发\">4.3定时器触发</h2>\n<p>定时器的框图中有一个TRGO信号输出，此信号可以用来触发ADC、DAC、其他定时器等。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p><code>TIM_SelectOutputTrigger</code><br />\n这个函数TIMx_CR2寄存器的位6到位4赋值，位6到位4是MMS[2:0]，</p>\n<p>完整代码：</p>\n<pre><code class=\"language-c\">void TIM5_TriggerInit(void)\n{\t\n\t// 定时器TIMx初始化\n\t// TIM5_Int_Init 函数已经设置好了主模式定时器TIMx的周期arr\n\t\n\t// TIMx触发其他模块的功能设置\n\t// TIM_SelectMasterSlaveMode(TIM5, TIM_MasterSlaveMode_Enable);    // 设置定时器的主从模式\n\t                                                                // 设置定时器5为主模式\n\tTIM_SelectOutputTrigger(TIM5, TIM_TRGOSource_Update);    //设置TIME输出触发为更新模式\n}\n\n\n</code></pre>\n<p>实验1：bits11_0<br />\n<img alt=\"_cgi-bin_mmwebwx-bin_webwxgetmsgimg__&amp;MsgID=295027844866752088&amp;skey=@crypt_cb51e609_53f6db05b7ce21f5871ecbd847e61b63&amp;mmweb_appid=wx_webfilehelper\" class=\"lazyload\" /></p>\n<p>实验2：bits5_0<br />\n<img alt=\"_cgi-bin_mmwebwx-bin_webwxgetmsgimg__&amp;MsgID=7788708451097938682&amp;skey=@crypt_cb51e609_53f6db05b7ce21f5871ecbd847e61b63&amp;mmweb_appid=wx_webfilehelper\" class=\"lazyload\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 16:19</span>&nbsp;\n<a href=\"https://www.cnblogs.com/marshmallows\">树上掉下一只鱼</a>&nbsp;\n阅读(<span id=\"post_view_count\">52</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Flask页面跳转实战指南：五种方式与不同应用场景下的最佳选择",
      "link": "https://www.cnblogs.com/ymtianyu/p/19404968",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/ymtianyu/p/19404968\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 15:11\">\n    <span>Flask页面跳转实战指南：五种方式与不同应用场景下的最佳选择</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Flask页面跳转是Web开发中的基础但关键技能，本文系统讲解了五种常用跳转方式：后端redirect、前端a标签、form表单提交、JS fetch API交互，并重点对比了后端redirect与前端window.location.href的区别与适用场景。通过实际代码示例帮助开发者根据具体需求选择最合适的跳转策略，提升应用性能和用户体验。\n    </div>\n<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<div>\n<p>你在Flask开发中是否经常为页面跳转逻辑混乱而头疼？<strong style=\"color: rgba(186, 55, 42, 1);\">据统计，70%的Web应用性能问题源于不当的跳转处理</strong>，导致页面加载慢、用户体验差甚至安全漏洞！</p>\n<div style=\"background-color: rgba(248, 249, 250, 1); padding: 15px; margin: 20px 0; font-size: 14px;\">\n<p style=\"margin: 0; font-style: italic;\">本文带你深入理解Flask中的五种核心跳转方式，从基础到进阶，帮你彻底理清跳转逻辑。你将掌握：后端redirect的适用场景、前端a标签和form表单的经典用法、JS fetch API的现代交互方式，以及最关键的选择策略——什么情况下该用后端redirect，什么情况下该用前端window.location.href。</p>\n<br />\n<p style=\"margin: 0; font-weight: bold;\">目录一览：</p>\n<p style=\"margin: 5px 0;\">- ✨ Flask页面跳转为什么重要</p>\n<p style=\"margin: 5px 0;\">- 🔄 后端redirect跳转：Flask的核心武器</p>\n<p style=\"margin: 5px 0;\">- 🏷️ 前端a标签跳转：最简单的导航方式</p>\n<p style=\"margin: 5px 0;\">- 📝 前端form表单跳转：传统但有效的提交方式</p>\n<p style=\"margin: 5px 0;\">- ⚡ JS fetch访问API后的跳转：现代Web应用的选择</p>\n<p style=\"margin: 5px 0;\">- 🤔 关键对比：redirect vs window.location.href</p>\n<p style=\"margin: 5px 0;\">- 💻 完整实战代码示例</p>\n</div>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">✨ Flask页面跳转为什么重要</h2>\n<p>页面跳转是Web应用的“导航系统”，它决定了用户如何在不同页面间流动。在Flask中，跳转逻辑不仅影响用户体验，还关系到<strong style=\"color: rgba(186, 55, 42, 1);\">数据流、安全性、性能和后端负载</strong>。一个合理的跳转策略能让应用如丝般顺滑，而混乱的跳转则会让用户迷失在加载圈中。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🔄 后端redirect跳转：Flask的核心武器</h2>\n<p>这是Flask中最经典的跳转方式，通过<code>redirect()</code>函数实现。当后端处理完请求后，<strong style=\"color: rgba(186, 55, 42, 1);\">服务器会返回一个302重定向响应</strong>，告诉浏览器“请去另一个地址”。</p>\n<pre class=\"language-python highlighter-hljs\"><code>from flask import Flask, redirect, url_for\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    # 验证用户逻辑\n    if login_success:\n        # 重定向到主页\n        return redirect(url_for('home'))\n    else:\n        return redirect(url_for('login_page'))</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">适用场景：</strong>表单提交后的页面跳转、用户认证后的定向、URL规范化等。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">优点：</strong>完全由服务器控制，安全可靠，能处理复杂业务逻辑。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">缺点：</strong>需要完整的页面刷新，用户体验可能不够流畅。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🏷️ 前端a标签跳转：最简单的导航方式</h2>\n<p>这是最基础的前端跳转，直接在HTML中使用<code>&lt;a&gt;</code>标签。当用户点击链接时，<strong style=\"color: rgba(186, 55, 42, 1);\">浏览器会直接发起GET请求并加载新页面</strong>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>&lt;!-- 在Flask模板中 --&gt;\n&lt;a href=\"{{ url_for('about') }}\"&gt;关于我们&lt;/a&gt;\n&lt;a href=\"/contact\"&gt;联系我们&lt;/a&gt;</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">适用场景：</strong>普通导航链接、静态页面跳转。</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">注意：</strong>这是<strong style=\"color: rgba(186, 55, 42, 1);\">客户端行为</strong>，不经过后端逻辑处理。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">📝 前端form表单跳转：传统但有效的提交方式</h2>\n<p>通过form的<code>action</code>属性指定提交地址，<code>method</code>决定请求类型（GET或POST）。提交后，<strong style=\"color: rgba(186, 55, 42, 1);\">浏览器会加载action指定的页面</strong>。</p>\n<pre class=\"language-python highlighter-hljs\"><code>&lt;form action=\"{{ url_for('submit_form') }}\" method=\"POST\"&gt;\n    &lt;input type=\"text\" name=\"username\"&gt;\n    &lt;button type=\"submit\"&gt;提交&lt;/button&gt;\n&lt;/form&gt;</code></pre>\n<p>在Flask后端，你可以这样处理：</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.route('/submit', methods=['POST'])\ndef submit_form():\n    username = request.form.get('username')\n    # 处理数据...\n    return redirect(url_for('result_page'))  # 通常配合redirect使用</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">适用场景：</strong>数据提交、搜索功能、传统多步骤表单。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">⚡ JS fetch访问API后的跳转：现代Web应用的选择</h2>\n<p>这是现代单页应用（SPA）或富交互应用的常见模式：<strong style=\"color: rgba(186, 55, 42, 1);\">前端通过fetch（或axios）调用后端API，根据返回结果决定是否跳转</strong>。</p>\n<p>前端JavaScript代码：</p>\n<pre class=\"language-python highlighter-hljs\"><code>// 使用fetch调用登录API\nfetch('/api/login', {\n    method: 'POST',\n    headers: {'Content-Type': 'application/json'},\n    body: JSON.stringify({username: 'user', password: 'pass'})\n})\n.then(response =&gt; response.json())\n.then(data =&gt; {\n    if (data.success) {\n        // 前端控制跳转\n        window.location.href = '/dashboard';\n    } else {\n        alert('登录失败');\n    }\n});</code></pre>\n<p>后端Flask API：</p>\n<pre class=\"language-python highlighter-hljs\"><code>@app.route('/api/login', methods=['POST'])\ndef api_login():\n    data = request.get_json()\n    # 验证逻辑\n    if valid_user(data):\n        return jsonify({'success': True, 'message': '登录成功'})\n    else:\n        return jsonify({'success': False, 'message': '验证失败'}), 401</code></pre>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">关键点：</strong>这里API返回的是JSON数据，<strong style=\"color: rgba(186, 55, 42, 1);\">而不是redirect响应</strong>。跳转逻辑完全由前端JavaScript控制。</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">🤔 关键对比：redirect vs window.location.href</h2>\n<p>这是本文最核心的部分！很多人混淆这两种方式，其实它们有本质区别：</p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">1. 后端redirect（在Flask API中调用redirect）：</strong></p>\n<p>- 服务器返回的是<code>302重定向响应</code>，浏览器会自动跳转</p>\n<p>- 跳转地址在HTTP响应头中（Location字段）</p>\n<p>- 适用于传统的同步请求，如form提交</p>\n<p>- 示例：<code>return redirect(url_for('home'))</code></p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">2. 前端window.location.href（在JavaScript中控制）：</strong></p>\n<p>- 服务器返回的是<code>正常响应（如JSON）</code>，浏览器不自动跳转</p>\n<p>- 前端JS根据响应内容<strong style=\"color: rgba(186, 55, 42, 1);\">主动执行</strong>跳转</p>\n<p>- 适用于异步请求（AJAX/fetch），实现无刷新交互</p>\n<p>- 示例：<code>window.location.href = '/dashboard'</code></p>\n<p><strong style=\"color: rgba(186, 55, 42, 1);\">选择策略：</strong></p>\n<p>- 如果你的应用是<strong style=\"color: rgba(186, 55, 42, 1);\">传统多页面应用</strong>，使用form+redirect组合</p>\n<p>- 如果你需要<strong style=\"color: rgba(186, 55, 42, 1);\">无刷新交互</strong>（如部分更新、实时验证），使用fetch+window.location.href</p>\n<p>- 如果跳转<strong style=\"color: rgba(186, 55, 42, 1);\">依赖复杂后端逻辑</strong>（如权限检查），优先考虑后端redirect</p>\n<p>- 如果追求<strong style=\"color: rgba(186, 55, 42, 1);\">最佳用户体验和性能</strong>，现代应用倾向于前端控制跳转</p>\n<h2 style=\"color: rgba(44, 62, 80, 1); padding-bottom: 5px;\">💻 完整实战代码示例</h2>\n<p>下面是一个完整的Flask应用，演示了所有跳转方式：</p>\n<pre class=\"language-python highlighter-hljs\"><code>from flask import Flask, render_template, request, redirect, url_for, jsonify\n\napp = Flask(__name__)\n\n# 1. 基础页面\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/about')\ndef about():\n    return '关于页面'\n\n# 2. 传统form提交 + redirect\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        # 简单的验证逻辑\n        if request.form.get('username') == 'admin':\n            return redirect(url_for('dashboard'))  # 后端redirect\n        else:\n            return redirect(url_for('login'))\n    return render_template('login.html')\n\n# 3. API端点 + 前端控制跳转\n@app.route('/api/checkout', methods=['POST'])\ndef api_checkout():\n    data = request.get_json()\n    # 处理订单逻辑\n    if data.get('confirmed'):\n        return jsonify({\n            'success': True,\n            'redirect_url': url_for('order_success')\n        })\n    else:\n        return jsonify({'success': False}), 400\n\n@app.route('/dashboard')\ndef dashboard():\n    return '用户仪表板'\n\n@app.route('/order-success')\ndef order_success():\n    return '订单成功页面'\n\nif __name__ == '__main__':\n    app.run(debug=True)</code></pre>\n<p>对应的HTML模板（index.html）示例：</p>\n<pre class=\"language-html highlighter-hljs\"><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Flask跳转演示&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;跳转方式演示&lt;/h1&gt;\n    \n    &lt;!-- 1. a标签跳转 --&gt;\n    &lt;p&gt;&lt;a href=\"/about\"&gt;关于我们（a标签）&lt;/a&gt;&lt;/p&gt;\n    \n    &lt;!-- 2. form表单跳转 --&gt;\n    &lt;form action=\"/login\" method=\"POST\"&gt;\n        &lt;input type=\"text\" name=\"username\" placeholder=\"用户名\"&gt;\n        &lt;button type=\"submit\"&gt;传统登录&lt;/button&gt;\n    &lt;/form&gt;\n    \n    &lt;!-- 3. JS fetch + 前端跳转 --&gt;\n    &lt;button onclick=\"checkout()\"&gt;API下单（无刷新）&lt;/button&gt;\n    \n    &lt;script&gt;\n    function checkout() {\n        fetch('/api/checkout', {\n            method: 'POST',\n            headers: {'Content-Type': 'application/json'},\n            body: JSON.stringify({confirmed: true})\n        })\n        .then(res =&gt; res.json())\n        .then(data =&gt; {\n            if (data.success) {\n                // 前端控制跳转\n                window.location.href = data.redirect_url;\n            }\n        });\n    }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>通过这个完整示例，你可以清楚地看到每种跳转方式在实际项目中的应用场景和代码写法。</p>\n<div style=\"text-align: center; margin: 40px 0;\"><hr style=\"border-right: none; border-bottom: none; border-left: none; width: 80%; margin: 0 auto;\" /></div>\n<div style=\"text-align: center; font-size: 14px; color: rgba(127, 140, 141, 1); margin-top: 30px;\">\n<p>喜欢本文？不要错过✨，点赞👍收藏⭐关注我👆，一起学习更多有用的知识，完善你我的技能树！</p>\n</div>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 15:11</span>&nbsp;\n<a href=\"https://www.cnblogs.com/ymtianyu\">曲幽</a>&nbsp;\n阅读(<span id=\"post_view_count\">33</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "APEX实战第8篇：ORDS连库报错574？一招根治用户过期问题",
      "link": "https://www.cnblogs.com/jyzhao/p/19404888/apex-shi-zhan-di8pianords-lian-ku-bao-cuo574-yi-zh",
      "published": "",
      "description": "<a name=\"top\"></a>\n    <h2><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jyzhao/p/19404888/apex-shi-zhan-di8pianords-lian-ku-bao-cuo574-yi-zh\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 15:08\">\n    <span>APEX实战第8篇：ORDS连库报错574？一招根治用户过期问题</span>\n    \n\n</a>\n</h2>\n    <small>\n<span id=\"post-date\">2025-12-26 15:08</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jyzhao\">AlfredZhao</a>&nbsp;\n阅读(<span id=\"post_view_count\">27</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</small>\n    <div class=\"entry\">\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>作为 APEX 应用开发工程师，笔者发现很多同行在使用 APEX + ORDS 架构时，都会遇到数据库凭证错误相关的问题。之前大家普遍知道 APEX_PUBLIC_USER 需要设置密码永不过期，但往往会忽略另一个关键用户——ORDS_PUBLIC_USER，这也是导致 Database Credential Error 和 HTTP Status Code: 574 问题反复出现的核心原因。</p>\n<p>今天笔者就结合自己的踩坑经历，把 ORDS_PUBLIC_USER 相关的问题解决流程完整分享出来，帮大家快速解决问题，避免重复踩坑。</p>\n<h2 id=\"01--先明确问题ords-连不上数据库报错到底啥意思\">01 | 先明确问题：ORDS 连不上数据库，报错到底啥意思？</h2>\n<p>当你启动 ORDS 后，访问 APEX 应用或 ORDS 接口时，可能会遇到这样的错误提示：</p>\n<blockquote>\n<p>ORDS was unable to make a connection to the database. The database user specified by db.username configuration setting is expired. The connection pool named: |default|lo| had the following error(s): UCP-29: Failed to get a connection</p>\n</blockquote>\n<p><img alt=\"ords1\" src=\"https://img2024.cnblogs.com/blog/635610/202512/635610-20251226145736856-1853445170.jpg\" /></p>\n<p>简单说，就是 ORDS 配置的数据库用户过期了，导致连接池拿不到连接。这里的关键用户，就是我们今天的主角——ORDS_PUBLIC_USER。</p>\n<p>很多同学之前只关注了 APEX_PUBLIC_USER，却不知道 ORDS 正常运行也依赖专属的 ORDS_PUBLIC_USER，这个用户默认使用数据库的 DEFAULT 密码策略，一旦密码过期，就会触发上述错误。</p>\n<h2 id=\"02--解决步骤从定位问题到彻底解决一步都不能少\">02 | 解决步骤：从定位问题到彻底解决，一步都不能少</h2>\n<p>下面笔者就把完整的解决流程拆解开，每个步骤都讲清楚操作方法和注意事项，小白也能跟着做。</p>\n<h3 id=\"-第一步定位问题用户确认是-ords_public_user-过期\">① 第一步：定位问题用户，确认是 ORDS_PUBLIC_USER 过期</h3>\n<p>首先我们需要通过 ORDS 命令，确认配置的数据库用户到底是谁，避免操作错用户。</p>\n<p>在命令行执行以下命令：</p>\n<pre><code class=\"language-bash\">ords config list\n</code></pre>\n<p>这个命令会列出 ORDS 的所有配置信息，找到<code>db.username</code> 对应的 value 值，不出意外的话，会显示<code>ORDS_PUBLIC_USER</code>，这就确认了是这个用户过期导致的问题。</p>\n<h3 id=\"-第二步给-ords_public_user-配置永不过期策略\">② 第二步：给 ORDS_PUBLIC_USER 配置永不过期策略</h3>\n<p>既然是密码过期问题，核心就是给 ORDS_PUBLIC_USER 设置密码永不过期的策略。这里笔者假设你已经创建好了名为 <code>PASSWORD_UNLIMITED</code> 的永不过期配置文件（如果没有，可先执行 <code>CREATE PROFILE PASSWORD_UNLIMITED LIMIT PASSWORD_LIFE_TIME UNLIMITED PASSWORD_GRACE_TIME UNLIMITED;</code> 创建）。</p>\n<p>以 SYSDBA 身份登录数据库，执行以下 SQL 命令：</p>\n<pre><code class=\"language-sql\">alter user ORDS_PUBLIC_USER profile PASSWORD_UNLIMITED;\n</code></pre>\n<p>这一步的作用是把 ORDS_PUBLIC_USER 关联到永不过期的配置文件，从根源上避免后续再次过期。</p>\n<h3 id=\"-第三步重启-ords-测试发现新问题\">③ 第三步：重启 ORDS 测试，发现新问题</h3>\n<p>配置完永不过期策略后，我们重启 ORDS 看看效果，执行命令：</p>\n<pre><code class=\"language-bash\"># 1. 查找 ORDS 进程并终止\nps -ef | grep ords\n# 找到进程号（第二列数字），执行 kill 命令终止进程\nkill -9 进程号\n\n# 2. 后台启动 ORDS 并将日志输出到 ords.log 文件\nnohup ords serve &gt; ords.log &amp;\n</code></pre>\n<p>此时大概率会发现，错误变了！新错误提示为：</p>\n<blockquote>\n<p>ORA-28001: The account has expired.</p>\n</blockquote>\n<p>这是因为我们虽然修改了密码策略，但已经过期的账号状态不会自动恢复。这时候有同学会尝试用 <code>ALTER USER ORDS_PUBLIC_USER ACCOUNT UNLOCK;</code>命令解锁，但笔者亲测，这个命令对已经过期的账号状态无效，无法将其从 expired 改为 open。</p>\n<h3 id=\"-第四步重置-ords_public_user-密码恢复账号状态\">④ 第四步：重置 ORDS_PUBLIC_USER 密码，恢复账号状态</h3>\n<p>要彻底解除 expired 状态，必须重置 ORDS_PUBLIC_USER 的密码。以 SYSDBA 身份登录数据库，执行以下 SQL 命令：</p>\n<pre><code class=\"language-sql\">ALTER USER ORDS_PUBLIC_USER identified by \"newpassword\";\n</code></pre>\n<p>注意：这里的 <code>newpassword</code> 替换成你自己的密码，建议设置一个复杂度高、不容易忘记的密码，比如 <code>Ords_2025@Pub</code>（包含大小写、数字和特殊字符）。</p>\n<p>执行完这个命令后，ORDS_PUBLIC_USER 的账号状态就会恢复为 open，过期问题就解决了。</p>\n<h3 id=\"-第五步关键坑点用正确命令同步-ords-密码配置\">⑤ 第五步：关键坑点！用正确命令同步 ORDS 密码配置</h3>\n<p>重置完数据库用户密码后，很多同学会直接重启 ORDS，但此时会遇到新的错误：</p>\n<blockquote>\n<p>The connection pool named: |default|lo| had the following error(s): ORA-01017: invalid credential or not authorized; logon denied</p>\n</blockquote>\n<p>这是因为 ORDS 配置里的密码还是旧的，没有同步我们刚重置的新密码。这里要重点提醒大家，不同 ORDS 版本设置密码的命令不一样！</p>\n<p>笔者使用的是 ORDS 25.1 版本，这个版本及以后的新版本，敏感配置（比如密码）必须用 <code>secret</code> 子命令设置，普通的 <code>ords config set db.password</code> 命令会失效。</p>\n<p>正确的操作是在命令行执行：</p>\n<pre><code class=\"language-bash\">ords config secret db.password\n</code></pre>\n<p>执行后会提示你输入密码，直接输入我们刚才重置的 <code>newpassword</code> 即可（交互式输入更安全，避免密码暴露在命令行历史记录中）。</p>\n<p>如果你的 ORDS 版本较低（比如 21 之前），可能需要用 <code>ords config set db.password \"newpassword\"</code>，但建议优先用 <code>secret</code> 命令，更符合安全规范。</p>\n<h3 id=\"-第六步最终测试确认问题解决\">⑥ 第六步：最终测试，确认问题解决</h3>\n<p>完成密码同步后，我们再次重启 ORDS：</p>\n<pre><code class=\"language-bash\"># 1. 查找 ORDS 进程并终止\nps -ef | grep ords\nkill -9 进程号\n\n# 2. 后台启动 ORDS\nnohup ords serve &gt; ords.log &amp;\n</code></pre>\n<p>此时访问 APEX 应用或 ORDS 接口，就不会再出现之前的数据库连接错误了。为了确保万无一失，也可以通过以下方式验证 ORDS 状态：</p>\n<pre><code class=\"language-bash\"># 方式1：查看 ORDS 进程是否存在（确认启动成功）\nps -ef | grep ords\n\n# 方式2：查看 ORDS 日志，确认无报错\ntail -f ords.log\n\n# 方式3：查看 ORDS 配置信息，确认核心配置正确\nords config list\n</code></pre>\n<p>如果通过 ps 命令能看到 ORDS 进程，且日志中无数据库连接相关报错，就说明 ORDS 正常运行，问题彻底解决。</p>\n<h2 id=\"03--避坑指南这些关键要点帮你避免重复踩坑\">03 | 避坑指南：这些关键要点，帮你避免重复踩坑</h2>\n<p>在解决问题的过程中，笔者踩了几个坑，这里总结出来，帮大家少走弯路：</p>\n<h3 id=\"-不要只关注-apex_public_user忽略-ords_public_user\">① 不要只关注 APEX_PUBLIC_USER，忽略 ORDS_PUBLIC_USER</h3>\n<p>APEX_PUBLIC_USER 是 APEX 应用的核心用户，ORDS_PUBLIC_USER 是 ORDS 服务的核心用户，两者缺一不可。建议在安装配置初期，就同时给这两个用户设置永不过期策略，一劳永逸。</p>\n<h3 id=\"-账号过期后仅解锁无效必须重置密码\">② 账号过期后，仅解锁无效，必须重置密码</h3>\n<p>很多同学误以为 <code>ALTER USER ... ACCOUNT UNLOCK</code> 能解决过期问题，但实际上这个命令只能解决账号锁定问题，无法解除过期状态。过期状态必须通过重置密码才能恢复，这一步不能省。</p>\n<h3 id=\"-注意-ords-版本差异密码配置命令要选对\">③ 注意 ORDS 版本差异，密码配置命令要选对</h3>\n<p>ORDS 21 版本及以后，敏感配置必须用<code>ords config secret</code> 命令设置，普通的 <code>set</code> 命令无效；另外要注意，ORDS 没有 <code>status</code> 命令，无法直接查看运行状态，需通过查看进程、日志或配置信息验证。如果设置密码后仍报错，先检查自己的 ORDS 版本和配置是否正确。</p>\n<h3 id=\"-密码要保持一致数据库用户密码--ords-配置密码\">④ 密码要保持一致：数据库用户密码 ≡ ORDS 配置密码</h3>\n<p>重置 ORDS_PUBLIC_USER 的数据库密码后，一定要同步更新 ORDS 配置里的密码，两者必须完全一致（包括大小写、特殊字符），否则会报 ORA-01017 认证失败错误。</p>\n<h2 id=\"04--总结一劳永逸的核心方案\">04 | 总结：一劳永逸的核心方案</h2>\n<p>其实解决这个问题的核心很简单：给 ORDS_PUBLIC_USER 配置永不过期的密码策略，同时确保 ORDS 配置里的密码与数据库用户密码一致。</p>\n<p>完整流程可以简化为：定位用户 → 配置永不过期策略 → 重置密码 → 同步 ORDS 密码配置 → 重启 ORDS。</p>\n<p>建议大家在搭建 APEX + ORDS 环境时，就提前完成这两个用户（APEX_PUBLIC_USER、ORDS_PUBLIC_USER）的永不过期配置，避免后续运行中突然出现问题，影响业务使用。</p>\n<p>如果大家在操作过程中遇到其他问题，欢迎在评论区留言交流，笔者会尽力为大家解答～</p>\n\n</div>\n<div id=\"MySignature\">\n    <a href=\"https://www.cnblogs.com/jyzhao/\" target=\"_blank\">AlfredZhao</a>©版权所有「从Oracle起航，领略精彩的IT技术。」<br />\n转载请注明原文链接：<a href=\"https://www.cnblogs.com/jyzhao/p/19404888/apex-shi-zhan-di8pianords-lian-ku-bao-cuo574-yi-zh\" target=\"_blank\">https://www.cnblogs.com/jyzhao/p/19404888/apex-shi-zhan-di8pianords-lian-ku-bao-cuo574-yi-zh</a>\n<hr />\n<div style=\"text-align: center; margin-top: 30px;\">\n  <p style=\"font-size: 14px; color: #555;\">\n    👋 感谢阅读，欢迎关注我的公众号 <b>「赵靖宇」</b>\n  </p>\n  <img src=\"https://images.cnblogs.com/cnblogs_com/jyzhao/824234/o_250208075013_qrcode-zjy.jpg\" style=\"border: 1px solid #ddd; border-radius: 8px;\" width=\"160\" />\n</div>\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"clear\"></div>\n        \n</div>\n    <ul class=\"postmetadata\">\n        \n    </ul>"
    },
    {
      "title": "LaTeX学习笔记：开场白与索引",
      "link": "https://www.cnblogs.com/owlman/p/19404057",
      "published": "",
      "description": "<h2 class=\"post-title\">\n            <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/owlman/p/19404057\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 11:59\">\n    <span>LaTeX学习笔记：开场白与索引</span>\n    \n\n</a>\n\n        </h2>\n        <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"开场白\">开场白</h2>\n<p>从这里开始，我将会陆续记录自己在学习 <span class=\"math inline\">\\(\\LaTeX\\)</span> 语言过程中所累积的心得体会，目的是帮助自己和读者更好地掌握基于这门语言（及排版系统）的学术写作技巧。下面，让我们先来简单了解一下 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的前世今生。</p>\n<h3 id=\"latex-的前世今生\">LaTeX 的前世今生</h3>\n<p>事情得先从 <span class=\"math inline\">\\(\\TeX\\)</span> 说起，众所周知，<span class=\"math inline\">\\(\\TeX\\)</span> 是美国著名的计算机教授高德纳（Donald Ervin Knuth）<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\" rel=\"noopener nofollow\">[1]</a></sup>为撰写其伟大著作《计算机程序设计艺术》专门开发的一套排版系统语言。由于《计算机程序设计艺术》是一部讨论计算机算法的鸿篇巨作，其中涉及了大量的数学问题，所以为其开发的排版系统自然就在编辑复杂的数学公式方面具备了与生俱来的优势，这种先天优势使得它在数学、物理学和计算机科学等与数学表述密切相关的学术领域中非常流行，甚至很多人学习 <span class=\"math inline\">\\(\\TeX\\)</span> 就是为了使用它在数学领域中的强大表述能力。</p>\n<p>但 <span class=\"math inline\">\\(\\TeX\\)</span> 的功能过于强大，它会要求我们在排版过程中精确描述到每一个细节，有时甚至是一个字母或标点也要照顾到。这对于大多数人来说，可能就学习成本太高，并且用起来太过繁琐和费时了。于是在上个世纪八十年代，美国计算机科学家莱斯利·兰伯特（Leslie Lamport）<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\" rel=\"noopener nofollow\">[2]</a></sup>在 <span class=\"math inline\">\\(\\TeX\\)</span> 的基础上开发出了 <span class=\"math inline\">\\(\\LaTeX\\)</span> 这个新的排版系统（截至 2025 年，<span class=\"math inline\">\\(\\LaTeX2e\\)</span> 目前仍为主流版本，但官方已在逐步过渡到 <span class=\"math inline\">\\(LaTeX3\\)</span>）。从本质上来说，该排版系统其实就是一组封装了 <span class=\"math inline\">\\(\\TeX\\)</span> 处理细节的宏，它可以让那些不了解排版和程序设计相关知识的人们也能使用 <span class=\"math inline\">\\(\\TeX\\)</span> 所提供的强大功能，并在几天甚至几个小时之内就能排版出具有专业质感的印刷品，而不必深陷于琐碎的排版细节中。</p>\n<p>在中文支持方面，现代 LaTeX 通常使用 XeTeX 或 LuaTeX 排版引擎。二者都支持 UTF-8 编码和系统字体，其中 XeTeX 在中文社区中应用更广，该引擎支持 UTF-8 编码和现代字体，可以直接使用本地计算机中安装的字体，这大大降低了 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的使用难度。</p>\n<h3 id=\"为什么要学习-latex\">为什么要学习 LaTeX？</h3>\n<p>或许很多人都会问：在已经有那么多所见即所得（WYSIWYG）的文档编辑器（例如 Microsoft Word、WPS Office）的今天，我们为什么还要学习这种看起来古老又复杂的排版工具呢？在我个人看来，这个问题的答案不仅关乎写作工具的选择，更反映出我们对“学术写作”这一工作的理解。就我个人而言，选择学习 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的原因主要如下：</p>\n<ul>\n<li>\n<p><strong>可专注于写作的结构化思维</strong>。与传统的文档编辑器不同，<span class=\"math inline\">\\(\\LaTeX\\)</span> 并不要求我们在写作的同时关心每个段落、字体、间距的具体样式，而是让我们先将注意力放在文档的内容及其逻辑结构（即标题、摘要、公式、图表、参考文献等）上，然后再通过命令和标记告诉它这些内容“是什么”，而不是“看起来像什么”。这种写作方式与程序员使用编程语言时的思维是相通的：可以很好地实现内容与形式的分离，表达与排版的解耦。这意味着，一旦文档结构清晰，格式就可以自动保持统一与专业。</p>\n</li>\n<li>\n<p><strong>这是在学习一种项目管理思维</strong>。当我们使用它写作时，我们不只是“编辑文字”，而是在构建一个可复现、可维护、可自动生成的文本系统系统。它让学术写作拥有了版本控制、可移植性与长期可读性——这正是科学研究所追求的严谨与可验证性。对于科研工作者来说，<span class=\"math inline\">\\(\\LaTeX\\)</span> 不仅是一种工具，更是一种思维方式：一旦掌握，你会发现它带来的不仅是排版的优雅，更是思考方式的变化。</p>\n</li>\n<li>\n<p><strong>学术界公认的排版标准</strong>。世界上绝大多数顶级学术期刊与会议模板都是基于 <span class=\"math inline\">\\(\\LaTeX\\)</span> 实现的，从《Nature》《IEEE Transactions》到 ACM、Springer 的论文集，几乎无一例外。它在数学公式、交叉引用、自动编号、参考文献管理等方面的表现，至今没有任何图形化编辑器能够完全替代。特别是在数学、物理、计算机科学、工程学等领域，<span class=\"math inline\">\\(\\LaTeX\\)</span> 已经成为一种“默认语言”。随着国内外高校和出版社对 <span class=\"math inline\">\\(\\LaTeX\\)</span> 支持的日益完善，越来越多的中文论文、学位论文模板、科研报告乃至书籍排版都已经提供了相应的 <span class=\"math inline\">\\(\\LaTeX\\)</span> 模板。对于想要从事学术研究、技术写作、教材编辑或科研出版的人而言，掌握 <span class=\"math inline\">\\(\\LaTeX\\)</span> 不仅是技能，更是一种职业素养的体现。</p>\n</li>\n</ul>\n<p>或许还会有人问，那么 <span class=\"math inline\">\\(\\LaTeX\\)</span> 和我们日常写博客与技术文档的 Markdown 有什么区别呢？其实，其中的区别就在于“日常”与“学术”，Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 页面。Markdown 的语法简单，易于上手，非常适合快速编写和分享文档。然而，Markdown 并不能像 <span class=\"math inline\">\\(\\LaTeX\\)</span> 那样处理复杂的数学公式，也不能像 LaTeX 那样生成高质量的 PDF 文档。因此，如果我们需要进行更为专业的学术写作，特别是涉及到数学公式和参考文献管理时，<span class=\"math inline\">\\(\\LaTeX\\)</span> 是一个更好的选择。</p>\n<p>总之，学习 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的过程，既是掌握一种排版工具的过程，也是训练逻辑表达与抽象思维的过程。它让我们在文字的世界中，以科学的方式组织思想，以优雅的方式表达知识。</p>\n<h2 id=\"笔记索引\">笔记索引</h2>\n<p>这一系列的笔记的内容将包括介绍它的前世今生，基本使用方式，以及在数学公式编辑、专业文献排版等方面的具体应用。下面是这一系列笔记的索引：</p>\n<ul>\n<li>[[LaTeX学习笔记：快速上手指南]]：<a href=\"https://www.cnblogs.com/owlman/p/19202175\" target=\"_blank\">博客园链接</a>；</li>\n<li>[[LaTeX学习笔记：文档排版基础]]：<a href=\"https://www.cnblogs.com/owlman/p/19256216\" target=\"_blank\">博客园链接</a>；</li>\n<li>[[LaTeX学习笔记：数学公式编辑]]：<a href=\"https://www.cnblogs.com/owlman/p/19199330\" target=\"_blank\">博客园链接</a>；</li>\n<li>[[LaTeX学习笔记：学术文档排版]]：<a href=\"https://www.cnblogs.com/owlman/p/19348573\" target=\"_blank\">博客园链接</a>；</li>\n</ul>\n<p>除我的个人博客之外，上述笔记将陆续更新在我于 github 上的<a href=\"https://github.com/owlman/CS_StudyNotes\" rel=\"noopener nofollow\" target=\"_blank\">计算机学习笔记库</a>中，并予以长期维护，欢迎读者随时参考。</p>\n<h2 id=\"学习资源\">学习资源</h2>\n<ul>\n<li>参考书籍：\n<ul>\n<li><a href=\"https://book.douban.com/subject/24703731/\" rel=\"noopener nofollow\" target=\"_blank\">《LaTeX 入门》</a>：作者是刘海洋，电子工业出版社于2013年出版，适合初学入门。</li>\n<li><a href=\"https://book.douban.com/subject/1418351/\" rel=\"noopener nofollow\" target=\"_blank\">《The TeXbook》</a>：作者是高德纳本人，系 <span class=\"math inline\">\\(\\TeX\\)</span> 领域最权威的参考书籍。这虽并不是 <span class=\"math inline\">\\(\\LaTeX\\)</span> 直接相关的教材，但如果想更好地理解 <span class=\"math inline\">\\(\\LaTeX\\)</span> 的工作原理，以及掌握其底层的排版机制，回头去读一下这本书，系统性地学习一下 <span class=\"math inline\">\\(\\TeX\\)</span> 是一个非常好的选择。</li>\n</ul>\n</li>\n<li>网络资源：\n<ul>\n<li><a href=\"https://www.latex-project.org/\" rel=\"noopener nofollow\" target=\"_blank\">LaTeX 官方网站</a>：官方文档和教程。</li>\n<li><a href=\"http://www.ctex.org/\" rel=\"noopener nofollow\" target=\"_blank\">CTeX 官方网站</a>：中文 <span class=\"math inline\">\\(\\LaTeX\\)</span> 社区，提供中文文档和教程。</li>\n<li><a href=\"https://www.tug.org/texlive/\" rel=\"noopener nofollow\" target=\"_blank\">TeX Live 官方网站</a>：最完整的跨平台 <span class=\"math inline\">\\(\\TeX\\)</span> 发行版，包含 LaTeX、XeTeX、LuaTeX 等编译器与宏包集合。</li>\n<li><a href=\"https://www.overleaf.com/\" rel=\"noopener nofollow\" target=\"_blank\">Overleaf</a>：在线的 <span class=\"math inline\">\\(\\LaTeX\\)</span> 编辑器，支持实时预览和协作编辑。</li>\n<li><a href=\"https://www.ctan.org/\" rel=\"noopener nofollow\" target=\"_blank\">CTAN</a>：<span class=\"math inline\">\\(\\LaTeX\\)</span> 的官方包仓库，提供了大量的宏包和模板。</li>\n<li><a href=\"https://en.wikibooks.org/wiki/LaTeX\" rel=\"noopener nofollow\" target=\"_blank\">LaTeX wikibook</a>：一个详细的 <span class=\"math inline\">\\(\\LaTeX\\)</span> 学习指南，适合初学者。</li>\n</ul>\n</li>\n</ul>\n\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li class=\"footnote-item\" id=\"fn1\"><p>高德纳教授是现代计算机科学的先驱人物，他创立了算法分析理论，并在数个计算机理论分支上都做出了犹如基石一般的贡献，于1974年荣获图灵奖。 <a class=\"footnote-backref\" href=\"#fnref1\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n<li class=\"footnote-item\" id=\"fn2\"><p>莱斯利·兰伯特是来自纽约的一位计算机科学家，LaTeX排版系统的开发者，2013年荣获图灵奖。 <a class=\"footnote-backref\" href=\"#fnref2\" rel=\"noopener nofollow\">↩︎</a></p>\n</li>\n</ol>\n</section>\n\n</div>\n<div class=\"clear\"></div>\n\n        <p class=\"postfoot\">\n            posted on \n<span id=\"post-date\">2025-12-26 11:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/owlman\">凌杰</a>&nbsp;\n阅读(<span id=\"post_view_count\">84</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n        </p>"
    },
    {
      "title": "【面试题】MySQL B+树索引高度计算",
      "link": "https://www.cnblogs.com/sun-10387834/p/19381299",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19381299\" id=\"cb_post_title_url\" title=\"发布于 2025-12-26 11:53\">\n    <span>【面试题】MySQL B+树索引高度计算</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"mysql-b树索引高度计算与性能阈值探讨\">MySQL B+树索引高度计算与性能阈值探讨</h1>\n<h3 id=\"一mysql-b树索引高度计算\">一、MySQL B+树索引高度计算</h3>\n<p>MySQL中InnoDB的主键索引采用B+树结构，索引高度（树的层数）决定了查询时磁盘IO的次数（高度=IO次数），核心计算逻辑围绕<strong>B+树的节点容量</strong>和<strong>数据行数</strong>展开。</p>\n<h4 id=\"1-核心前提innodb默认配置\">1. 核心前提（InnoDB默认配置）</h4>\n<ul>\n<li>\n<p><strong>页大小</strong>：默认16KB（16384字节），B+树的每个节点对应一个InnoDB页。</p>\n</li>\n<li>\n<p><strong>主键类型</strong>：影响索引项大小（如INT=4字节，BIGINT=8字节，VARCHAR(32)=32+2字节）。</p>\n</li>\n<li>\n<p><strong>指针大小</strong>：InnoDB中页指针固定为6字节（指向子节点页的地址）。</p>\n</li>\n<li>\n<p><strong>B+树结构</strong>：</p>\n<ul>\n<li>\n<p>非叶子节点：仅存储「主键值 + 页指针」，按主键排序，无数据行；</p>\n</li>\n<li>\n<p>叶子节点：存储「完整主键 + 行数据（或行数据指针）」，且叶子节点通过双向链表连接。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-计算步骤\">2. 计算步骤</h4>\n<h5 id=\"步骤1计算非叶子节点的单页容量能存多少个索引项\">步骤1：计算非叶子节点的单页容量（能存多少个索引项）</h5>\n<p>非叶子节点的索引项大小 = 主键字节数 + 指针字节数</p>\n<p>单页可存储索引项数 = 页大小 / 索引项大小（向下取整，需预留少量空间给页头/页尾，实际按90%可用计算）</p>\n<p><strong>示例</strong>：主键为INT（4字节），指针6字节 → 索引项=10字节</p>\n<p>单页可用空间≈16384 * 90% = 14745字节</p>\n<p>单页索引项数≈14745 / 10 ≈ 1474个</p>\n<h5 id=\"步骤2计算叶子节点的单页容量能存多少行数据\">步骤2：计算叶子节点的单页容量（能存多少行数据）</h5>\n<p>叶子节点行大小 = 主键字节数 + 其他列总字节数（或行指针大小，InnoDB聚簇索引直接存数据）</p>\n<p>单页可存储行数 = 页大小 / 行大小（向下取整，同样预留页结构空间）</p>\n<p><strong>示例</strong>：主键INT（4字节），行数据总大小≈100字节 → 单行大小≈104字节</p>\n<p>单页行数≈14745 / 104 ≈ 141行</p>\n<h5 id=\"步骤3计算b树高度对应的总数据量\">步骤3：计算B+树高度对应的总数据量</h5>\n<p>B+树是多叉树，高度h的总数据量公式：</p>\n<p><code>总行数 = 非叶子节点分支数^(h-1) * 叶子节点单页行数</code></p>\n<ul>\n<li>\n<p>高度1：仅根节点（叶子节点）→ 行数≈141行</p>\n</li>\n<li>\n<p>高度2：根节点（非叶子）+ 叶子节点 → 1474 * 141 ≈ 20.8万行</p>\n</li>\n<li>\n<p>高度3：根→中间节点→叶子 → 1474 * 1474 * 141 ≈ 3060万行</p>\n</li>\n<li>\n<p>高度4：1474³ * 141 ≈ 45亿行</p>\n</li>\n</ul>\n<h4 id=\"3-实际验证方式\">3. 实际验证方式</h4>\n<p>可通过InnoDB的系统表查询索引高度：</p>\n<pre><code class=\"language-SQL\">-- 查询表的主键索引高度（TABLE_ID需先查）\nSELECT \n  b.name AS index_name,\n  a.HEIGHT AS index_height\nFROM \n  information_schema.INNODB_SYS_INDEXES a\nJOIN \n  information_schema.INNODB_SYS_TABLES b ON a.TABLE_ID = b.TABLE_ID\nWHERE \n  b.NAME = '数据库名/表名' -- 如test/user\n  AND a.NAME = 'PRIMARY'; -- 主键索引\n</code></pre>\n<ul>\n<li>生产环境中，99%的表索引高度为3（少量小表为2），高度4极少（超亿级数据才会出现）。</li>\n</ul>\n<h3 id=\"二mysql单表不影响性能的最大记录数\">二、MySQL单表不影响性能的最大记录数</h3>\n<p><strong>结论先行</strong>：没有绝对数值，但业界通用经验是「千万级（1000万~1亿行）」，核心影响因素不是行数，而是<strong>索引高度、数据页缓存命中率、磁盘IO能力</strong>。</p>\n<h4 id=\"1-性能阈值的核心逻辑\">1. 性能阈值的核心逻辑</h4>\n<ul>\n<li>\n<p>索引高度≤3时：查询只需2~3次磁盘IO（根节点、中间节点常驻内存），性能基本无衰减；</p>\n</li>\n<li>\n<p>索引高度=4时：需4次IO，且中间节点可能无法全部缓存，性能开始明显下降；</p>\n</li>\n<li>\n<p>数据页缓存命中率：InnoDB缓冲池能缓存的热数据页越多，性能越好（千万级数据的热页基本可全缓存，亿级后缓存命中率骤降）。</p>\n</li>\n</ul>\n<h4 id=\"2-不同场景的阈值参考\">2. 不同场景的阈值参考</h4>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>场景</td>\n<td>不影响性能的最大行数</td>\n<td>核心限制因素</td>\n</tr>\n<tr>\n<td>主键查询+热数据</td>\n<td>1亿行</td>\n<td>缓冲池大小（≥32GB）</td>\n</tr>\n<tr>\n<td>普通索引查询+分页</td>\n<td>1000万行</td>\n<td>索引回表IO、分页排序开销</td>\n</tr>\n<tr>\n<td>频繁更新+多索引</td>\n<td>500万行</td>\n<td>索引维护开销、锁竞争</td>\n</tr>\n<tr>\n<td>机械硬盘（HDD）</td>\n<td>500万行</td>\n<td>随机IO速度慢（≈100 IOPS）</td>\n</tr>\n<tr>\n<td>固态硬盘（SSD）</td>\n<td>1亿行</td>\n<td>随机IO速度快（≈10万 IOPS）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-突破阈值的优化方案\">3. 突破阈值的优化方案</h4>\n<p>若数据量超阈值，需通过架构优化而非单表优化：</p>\n<ul>\n<li>\n<p>分库分表：水平分表（按主键哈希/范围），使单表行数回到千万级以内；</p>\n</li>\n<li>\n<p>冷热数据分离：将冷数据归档到只读库，热数据保留在主库；</p>\n</li>\n<li>\n<p>索引优化：减少冗余索引，使用覆盖索引避免回表，优化查询语句（如避免SELECT *）；</p>\n</li>\n<li>\n<p>硬件升级：SSD替代HDD，增大缓冲池（innodb_buffer_pool_size=物理内存的50%~70%）。</p>\n</li>\n</ul>\n<h3 id=\"三总结\">三、总结</h3>\n<ol>\n<li>\n<p>B+树索引高度计算：核心是「非叶子节点单页分支数^高度-1 × 叶子节点单页行数」，生产环境中高度基本为2~3；</p>\n</li>\n<li>\n<p>单表性能阈值：千万级（1000万~1亿）是通用的无性能衰减阈值，核心看索引高度和IO能力，而非绝对行数；</p>\n</li>\n<li>\n<p>性能优化的核心：保持索引高度≤3，提升缓冲池缓存命中率，超阈值后优先分库分表。</p>\n</li>\n</ol>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19381299\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19381299</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2025-12-26 11:53</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">81</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}