{
  "title": "主页 - 博客园",
  "link": "https://www.cnblogs.com/",
  "description": "主页 - 博客园 RSS",
  "entries": [
    {
      "title": "一个致力于为 C# 程序员提供更佳的编码体验和效率的 Visual Studio 扩展插件",
      "link": "https://www.cnblogs.com/Can-daydayup/p/19484740",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/Can-daydayup/p/19484740\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 12:26\">\n    <span>一个致力于为 C# 程序员提供更佳的编码体验和效率的 Visual Studio 扩展插件</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<h2><span>前言</span></h2>\n<p><span>今天大姚给大家分享一个致力于为 C# 程序员提供更佳的编码体验和效率的 Visual Studio 扩展插件：<strong>Codist</strong><span>。</span></span></p>\n<h2><span>Codist 插件介绍</span></h2>\n<p><span>Codist 是一个使用 .NET 编写、开源免费的 Visual Studio 扩展插件，致力于为 C# 程序员提供更好的编程体验和生产效率。它不仅强化了语法高亮、快速信息提示、导航栏、滚动条和显示质量，还集成了自动版本号更新、括号自动补全、支持高级编辑功能的智能工具栏、代码分析等功能。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260115004425943-1474585464.png\" /></p>\n<h2><span>支持 Visual Studio 版本</span></h2>\n<ul class=\"list-paddingleft-1\">\n<li><span>Visual Studio 2026 (amd64)、2022 (amd64)、2019、2017</span></li>\n</ul>\n<h2><span>插件安装</span></h2>\n<h3><span>插件市场下载安装</span></h3>\n<ul class=\"list-paddingleft-1\">\n<li><span>插件市场地址：https://marketplace.visualstudio.com/items?itemName=wmj.Codist</span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260115004446637-2018658633.png\" /></p>\n<h3><span>Visual Studio 管理拓展器安装</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260115004505880-1645148207.png\" /></p>\n<h2><span>插件功能</span></h2>\n<h3><span>高级语法高亮</span></h3>\n<p><span>高级语法高亮（支持任意语言），以及注释标记器可高亮显示类 TODO 风格的注释。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260115004518457-35609180.png\" /></p>\n<h3><span>超强快速信息提示</span></h3>\n<p><span>超强快速信息提示，支持扩展的 XML 文档、符号工具提示、可选中内容、外观自定义等功能。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260115004530893-1971174501.png\" /></p>\n<h3><span>带拖放功能和可筛选成员列表的导航栏</span></h3>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260115004545792-1193961150.png\" /></p>\n<h3><span>智能工具栏</span></h3>\n<p><span>智能工具栏，集成常用编辑命令、C# 代码重构功能及符号引用分析器。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260115004558272-1303793799.png\" /></p>\n<h3><span>滚动条标记功能</span></h3>\n<p><span>滚动条标记绘制强大的迷你代码地图。</span></p>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260115004610512-1926042791.png\" /></p>\n<h2><span>插件源代码</span></h2>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260115004622965-362211103.png\" /></p>\n<h2><span>项目源码地址</span></h2>\n<p><span>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</span></p>\n<ul class=\"list-paddingleft-1\">\n<li><strong>GitHub开源地址：</strong>&nbsp;<span style=\"color: rgba(0, 0, 255, 1);\"><a href=\"https://github.com/wmjordan/Codist\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">https://github.com/wmjordan/Codist</span></a></span></li>\n</ul>\n<h2><span>优秀项目和框架精选</span></h2>\n<p><span>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong><span>）。</span></span></p>\n<ul>\n<li><strong>GitHub开源地址：</strong><span style=\"color: rgba(0, 0, 255, 1);\"><a href=\"https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></span></li>\n<li><strong>Gitee开源地址：</strong><span style=\"color: rgba(0, 0, 255, 1);\"><a href=\"https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md</span></a></span></li>\n</ul>\n<h2><span style=\"color: rgba(0, 0, 0, 1);\">更多 Visual Studio 实用技巧</span></h2>\n<ul>\n<li><span style=\"color: rgba(0, 0, 255, 1);\"><a href=\"https://github.com/YSGStudyHards/DotNetGuide\" rel=\"noopener nofollow\" target=\"_blank\"><span style=\"color: rgba(0, 0, 255, 1);\">https://github.com/YSGStudyHards/DotNetGuide</span></a></span></li>\n</ul>\n<p><img alt=\"image\" src=\"https://img2024.cnblogs.com/blog/1336199/202601/1336199-20260116214814557-1494741457.png\" /></p>\n</div>\n<div id=\"MySignature\">\n    <blockquote>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者名称：</span><a href=\"https://www.cnblogs.com/Can-daydayup/\" target=\"_blank\">追逐时光者</a></p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\"><span style=\"font-size: 17px;\">作者简介：</span>一个热爱编程、善于分享、喜欢学习、探索、尝试新事物和新技术的全栈软件工程师。</p>\n<p style=\"font-family: YouYuan; font-size: 16px; margin: 0 auto 0.01em auto;\">\n本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。如果该篇文章对您有帮助的话，可以点一下右下角的<a href=\"\" style=\"color: red;\">【♥推荐♥】</a>，希望能够持续的为大家带来好的技术文章，文中可能存在描述不正确的地方，欢迎指正或补充，不胜感激。\n</p>\n</blockquote>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 12:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/Can-daydayup\">追逐时光者</a>&nbsp;\n阅读(<span id=\"post_view_count\">0</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "2026 年 PHP 函数式编程 优势与实际应用",
      "link": "https://www.cnblogs.com/catchadmin/p/19497758",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19497758\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 08:26\">\n    <span>2026 年 PHP 函数式编程 优势与实际应用</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"2026-年-php-函数式编程-优势与实际应用\">2026 年 PHP 函数式编程 优势与实际应用</h1>\n<p>函数式编程（FP）已经存在几十年了，但近年来在实际开发中用得越来越多。这篇文章整理一下 FP 的核心概念和实际应用场景。</p>\n<h2 id=\"什么是函数式编程\">什么是函数式编程</h2>\n<p>在深入优势和应用之前，先快速回顾一下函数式编程是什么。</p>\n<p>函数式编程的核心是把计算当作数学函数的求值。它是一种声明式编程风格，描述的是\"要什么\"，而不是\"怎么做\"。在 FP 中，函数是一等公民，可以作为参数传递给其他函数，可以从函数返回，也可以赋值给变量。</p>\n<p>FP 的一个核心原则是不可变性——一旦给变量赋值，就不能再改变。这消除了副作用，让代码更可预测、更容易调试。另一个基本概念是纯函数，对于相同的输入总是产生相同的输出，不会修改任何外部状态。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/functional-programming-paradigms-2026\" rel=\"noopener nofollow\" target=\"_blank\">原文 2026 年 PHP 函数式编程 优势与实际应用</a></p>\n<h2 id=\"为什么开发者应该关注函数式编程\">为什么开发者应该关注函数式编程</h2>\n<h3 id=\"更简洁更易维护的代码\">更简洁、更易维护的代码</h3>\n<p>函数式编程鼓励编写模块化、易于理解的代码。因为函数是纯的（不修改状态），意外行为的空间更小，代码库更干净。这让调试、测试和后续修改都更容易。</p>\n<p>假设你在做一个 PHP 项目。使用函数式技术可以减少副作用，确保应用逻辑被隔离成更小的、可复用的代码片段。这也让后续更新或重构更容易，因为函数式代码的依赖通常更少。</p>\n<h3 id=\"并发和并行\">并发和并行</h3>\n<p>现代软件的一个挑战是处理并发和并行。随着多核处理器和分布式系统的普及，编写能高效处理多任务的代码比以往更重要。</p>\n<p>函数式编程在这方面有明显优势：因为函数避免修改共享状态，它们天生是线程安全的。这让编写并发应用更容易，不用担心竞态条件或死锁。</p>\n<p>比如一个需要处理大数据集的 PHP 应用。使用不可变数据结构和并行处理技术，可以确保应用的不同部分并发运行而不互相干扰。</p>\n<h3 id=\"更好的抽象和复用\">更好的抽象和复用</h3>\n<p>函数式编程促进高层抽象的创建。函数可以轻松组合、传递，在应用的不同部分复用。</p>\n<p>比如在 PHP 中，与其写重复的代码处理某些操作，不如写小的纯函数，然后灵活地组合起来。这减少了代码重复，更好地遵循 DRY（Don't Repeat Yourself）原则。</p>\n<h3 id=\"php-中的函数式工具\">PHP 中的函数式工具</h3>\n<p>PHP 不是纯函数式语言，但内置的 <code>array_map()</code>、<code>array_filter()</code>、<code>array_reduce()</code> 等函数提供了基本的函数式操作能力。第三方库如 Ramda、Lodash 也可以用。</p>\n<h2 id=\"函数式编程的核心原则\">函数式编程的核心原则</h2>\n<p>下面探讨函数式编程的一些核心原则，以及它们在实际编程中的应用。</p>\n<h3 id=\"不可变性\">不可变性</h3>\n<p>在函数式编程中，数据是不可变的。一旦设置了值，就不能改变。这个概念减少了与可变状态变化相关的 bug，简化了对程序行为的理解。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function addItemToList($list, $item) {\n    // 创建一个包含新元素的新列表\n    return array_merge($list, [$item]);\n}\n\n$list = [1, 2, 3];\n$newList = addItemToList($list, 4);\n\nprint_r($list);     // 输出: [1, 2, 3]（原列表不变）\nprint_r($newList);  // 输出: [1, 2, 3, 4]（包含新元素的新列表）\n</code></pre>\n<p>这个例子中，原始的 <code>$list</code> 保持不变，因为 PHP 数组是按值传递的。这展示了不可变性——原始数据结构被保留，返回的是包含新元素的新结构。</p>\n<h3 id=\"纯函数\">纯函数</h3>\n<p>纯函数对于相同的输入总是产生相同的输出，不会产生任何副作用。这让纯函数可预测且易于测试。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function square($number) {\n    return $number * $number;\n}\n\necho square(4); // 输出: 16\n</code></pre>\n<p><code>square()</code> 函数是纯的，因为对于相同的输入（4）总是产生相同的输出（16），而且不修改任何外部状态。</p>\n<h3 id=\"高阶函数\">高阶函数</h3>\n<p>高阶函数是可以接受其他函数作为参数或返回函数的函数。这实现了强大的抽象和代码复用。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function applyFunction($func, $value) {\n    return $func($value);\n}\n\nfunction double($x) {\n    return $x * 2;\n}\n\necho applyFunction('double', 5); // 输出: 10\n</code></pre>\n<p>这个例子中，<code>applyFunction()</code> 是一个高阶函数，因为它接受另一个函数（<code>double()</code>）作为参数并应用到一个值上。</p>\n<h3 id=\"函数组合\">函数组合</h3>\n<p>函数组合是把简单函数组合成更复杂函数的过程。这让你可以从更小的、可复用的组件构建复杂行为。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">function add($x, $y) {\n    return $x + $y;\n}\n\nfunction multiply($x, $y) {\n    return $x * $y;\n}\n\nfunction addThenMultiply($x, $y, $z) {\n    return multiply(add($x, $y), $z);\n}\n\necho addThenMultiply(2, 3, 4); // 输出: 20（add(2, 3) = 5, multiply(5, 4) = 20）\n</code></pre>\n<p>这里，<code>addThenMultiply()</code> 函数展示了如何把更小的函数组合起来创建新功能。这鼓励代码复用和模块化。</p>\n<h2 id=\"函数式编程的实际应用\">函数式编程的实际应用</h2>\n<p>函数式编程不只是理论概念——它正在实际应用中使用。下面看看函数式编程在不同领域的一些实际例子。</p>\n<h3 id=\"数据转换和-etl-流程\">数据转换和 ETL 流程</h3>\n<p>在数据密集型应用中，比如数据转换或 ETL（Extract, Transform, Load）流程，函数式编程表现出色。它让开发者可以不可变地操作大数据集，使用高层抽象进行转换。</p>\n<p>PHP 示例：</p>\n<pre><code class=\"language-php\">$data = [1, 2, 3, 4, 5];\n\n// 使用函数式方法处理数据\n$result = array_map(fn($x) =&gt; $x * 2, $data);  // 每个值翻倍\n$result = array_filter($result, fn($x) =&gt; $x &gt; 5); // 只保留大于 5 的值\n\nprint_r($result);  // 输出: [6, 8, 10]\n</code></pre>\n<p>这个例子中，我们使用 <code>array_map()</code> 和 <code>array_filter()</code> 不可变地转换和过滤数据集，这是函数式编程中的常见模式。</p>\n<h3 id=\"分布式系统中的并发\">分布式系统中的并发</h3>\n<p>函数式编程对不可变性和纯函数的强调，使它成为并发和并行处理任务的理想选择。你可以放心地编写并发应用，不用担心竞态条件。</p>\n<p>比如，在 PHP 中构建一个并发处理用户请求的分布式系统时，可以确保数据完整性，而不会引入与可变共享状态相关的 bug。</p>\n<h3 id=\"构建-api-端点和微服务\">构建 API 端点和微服务</h3>\n<p>构建微服务或 API 时，函数式编程可以帮助创建简洁、易维护的端点。通过确保每个函数处理特定任务且是纯的、确定性的，可以让每个微服务更容易测试和扩展。</p>\n<h2 id=\"小结\">小结</h2>\n<p>函数式编程的核心是不可变性、纯函数和高阶函数。这些概念在并发处理、数据转换等场景下比较实用。PHP 虽然不是纯函数式语言，但内置函数和第三方库已经提供了足够的支持。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 08:26</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">36</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大数据技术领域发展与Spark的性能优化",
      "link": "https://www.cnblogs.com/zzq6032010/p/19497421",
      "published": "",
      "description": "<h1 class=\"postTitle\"><a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/zzq6032010/p/19497421\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 23:59\">\n    <span>大数据技术领域发展与Spark的性能优化</span>\n    \n\n</a>\n</h1>\n\t<div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<p><strong><span style=\"font-size: 15px;\">一、大数据技术领域发展方向</span></strong></p>\n<p>随着AI时代的到来，大数据技术领域逐渐退居二线，再也没有了前些年的重视程度。博主近期结合从业多年经验，对大数据技术领域的技术演进路线做下梳理。</p>\n<p>当前大数据领域发展已经进入深水区，随着各种成熟大数据框架的应用普及，难点已经从存不下、算不出，变为了如何高质量、高效计算数据并增加数据与价值的转换率，这就涉及到针对价值变现场景的数据设计和全生命周期的管理。这部分根据具体业务场景的差异，设计实现千差万别，本文以Spark On Yarn经典大数据集群场景为例，讲一讲如何高效计算数据。</p>\n<p>&nbsp;</p>\n<p><strong><span style=\"font-size: 15px;\">二、Spark On Yarn性能优化思路</span></strong></p>\n<p><strong><span style=\"font-size: 14px;\">1、Spark调参</span></strong></p>\n<p>Spark开放了众多过程参数，来控制集群运行过程中各个维度的设置。常用来参数调优的有：</p>\n<p>spark.default.parallelism：并行度</p>\n<p>spark.sql.shuffle.partitions：shuffle分区数（常为集群Executor核心数的2-3倍）</p>\n<p>spark.executor.memoryOverhead：调节shuffle过程中内存溢出阈值</p>\n<p>spark.dynamicAllocation.enabled=true：启用动态资源分配，任务负载高时可自行增加对资源的申请</p>\n<p>spark.sql.adaptive.enabled=true：开启AQE，自动调节最优分区数，还可改善数据倾斜问题</p>\n<p>上面只是例举其中一小部分，参数调参配合SparkUI使用，方便观测调整效果。</p>\n<p><strong>2、代码端优化</strong></p>\n<p>手段很多，包括但不限于：增加缓存、减少udf的使用、走dataframe或sparksql最大化利用spark原生的引擎优化、使用broadcast等，核心原则是多利用spark优化机制，做好数据缓存。</p>\n<p><strong>3、数据端优化</strong></p>\n<p>数据端优化主要是两部分：</p>\n<p>第一是读取、存储时，采用高效存储格式，如parquet、ORC等，天然适配spark的分区计算模式，会减少很多无谓的操作。</p>\n<p>第二是采用高效序列化方式，减少shuffle过程中的序列化耗时，这部分时间可在SparkUI的Stage处查看task的timeline中的对应耗时。</p>\n<p><strong>4、架构层优化</strong></p>\n<p>上述措施都做完之后，基本就进入了性能优化的深水区，当前业界成熟做法有两大类，均能进一步突破数据计算瓶颈可带来较大幅度提升。</p>\n<p><span style=\"color: rgba(0, 0, 255, 1);\"><strong>第一是利用向量化技术，大幅提升计算效率。</strong></span></p>\n<p>向量化技术能有效果的基础，在于现代计算机对SIMD指令的支持。</p>\n<p>SIMD指令，即单指令流多数据流 Single Instruction Multiple Data，在计算机中可以使用一条指令，传递多个数据进去（即向量），而后CPU仅需对这一个向量进行一次运算（比如当前要进行加法运算），即可得到结果，相比传统CPU一个加法调用一次指令的方式，快了N（N为向量的长度）倍。</p>\n<p>所以向量化改造是一条理论上具备高效提效能力的技术方向。具体实操的话，开源组件推荐使用Gluten，小米技术团队去年做过实践分享，改造之后时间耗时平均降低30%。</p>\n<p><strong><span style=\"color: rgba(0, 0, 255, 1);\">第二是在并行计算路上继续狂奔，引入异构的GPU</span></strong>（注意不是NPU，NPU仅为支持AI训练推理加速，对通用数据计算增益效果并不好，且缺少配套）。</p>\n<p>在GPU计算提效这块，英伟达专门为Spark无缝使用开发了RAPIDS加速器插件。它可以以插件的方式集成到spark客户端中，通过参数开关指定启用。在spark的物理计划生成之后，会被该加速器插件拦截，将其中的CPU算子替换为GPU算子（若评估加速效果不好还可退回成CPU算子），而后在Task执行阶段，RAPIDS会接过该任务进行执行。</p>\n<p>大体，就这些了。单纯的大数据技术领域，可做的新技术演进已经不多了，后面更多的是如何精细化价值转换，给AI给行业赋能。</p>\n<p>后续将沿着AI的方向，进行博文的更新和学习。</p>\n</div>\n<div class=\"clear\"></div>\n\n\t<div class=\"postDesc\">posted on \n<span id=\"post-date\">2026-01-17 23:59</span>&nbsp;\n<a href=\"https://www.cnblogs.com/zzq6032010\">淡墨痕</a>&nbsp;\n阅读(<span id=\"post_view_count\">52</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "最近遇到的两个技术问题记录",
      "link": "https://www.cnblogs.com/grey-wolf/p/19495709",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/grey-wolf/p/19495709\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 12:23\">\n    <span>最近遇到的两个技术问题记录</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"问题1\">问题1</h1>\n<h2 id=\"背景\">背景</h2>\n<p>有个供内部员工使用的后台管理系统，每天会从上游的一个oa系统的接口同步员工数据，oa系统侧维护了每个员工的id、名称、工作城市等等各类信息，接口响应如下：</p>\n<p><img alt=\"image-20260117104211631\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117104211631.png\" /></p>\n<p>这个id就算是员工的唯一标识，就像工号一样，不会变的那种。因此，我们把接口数据拿到后，就直接落地到我们本地数据库的表中，表的主键虽然设定为自增主键，但是在程序里，我们会直接用oa系统给我们的这个id来设置本地表id的值后再插入。</p>\n<p><img alt=\"image-20260117105119562\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105119562.png\" /></p>\n<p>表结构：</p>\n<p><img alt=\"image-20260117122224831\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117122224831.png\" /></p>\n<p>sql如下：这个sql是自动生成的，默认生成出来的是不带id这种主键字段的，我们手动加了一下：</p>\n<p><img alt=\"image-20260117105019010\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105019010.png\" /></p>\n<p>手动加上id字段：</p>\n<p><img alt=\"image-20260117104906664\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117104906664.png\" /></p>\n<p>结果，最近弄了一个员工报商业保险的活动，简单来说，就是存储一下数据：用户id 、对应的商业保险id。</p>\n<p>报保险的过程中，发现用户表缺了些数据没同步，如用户证件号（报保险需要）、城市等，所以就加了一下这几个字段。</p>\n<p><img alt=\"image-20260117105522469\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105522469.png\" /></p>\n<p>新增完字段后，mapper.xml代码自动生成，也没仔细看，结果就把之前手动加的id字段给冲掉了：</p>\n<p><img alt=\"image-20260117105645320\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117105645320.png\" /></p>\n<p>这个上线后，由于在程序中没有指定id字段，就导致本地表中的id变成了使用自增的方式（postgresql，从序列中获取下一个id的值，类似mysql中自增）。</p>\n<p>而且，从oa系统同步员工信息到我方系统，每天都是靠一个定时任务在跑，每天跑的时候：</p>\n<pre><code class=\"language-shell\">1、从oa侧获取员工列表数据\n2、清空本地表\n3、批量插入从oa侧获取的员工数据\n</code></pre>\n<p>这就导致，员工的id，上线后，每天都在变，每天都在变。</p>\n<p>当时我查问题看到这个问题的时候，吓了一跳，当时员工报商业保险正如火如荼呢，我一想：难道得赶紧通知全公司的人，重新报了？而且，当时业务的人和保险公司约定的提供保险人员名单的时间也没几天了。。。</p>\n<p>后面我又仔细看了下，发现问题还没有那么大。</p>\n<p>就是在数据先落地到t_user_sync这个表（这个表和上游oa侧数据保持一模一样，只读不写，便于定位问题）后，还有个定时任务，将数据从t_user_sync转移到我们实际的用户表（sy_user），这个表我们会进行增删改查等等。</p>\n<p><img alt=\"image-20260117110408095\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117110408095.png\" /></p>\n<p>这个定时任务，在将t_user_sync转移到sy_user的过程中，是增量同步的。如，发现zhangsan这个用户时，先查一下sy_user里有没有，没有才插入，插入时，sy_user的id也是用的t_user_sync的id（也就是oa侧的id），有就更新。</p>\n<p>这个增量同步机制，救了我，导致的结果是，虽然t_user_sync中id错了，且每天都在变；但sy_user中的id虽然也是错的，但是不会每天变，而是用到第一次同步t_user_sync时的id。</p>\n<p>只要sy_user表中的id不变，错的也影响不大，至少员工报保险的相关表中的关联关系是没问题的：</p>\n<p>员工id          员工名称    保险名称</p>\n<p>11111(错的)  张三         xxx商业保险</p>\n<p>而我们这个系统中，其他地方也有用到这个用户id的，虽然由于用户id变化导致了关联关系错乱，但是影响毕竟业务影响没那么大，到时候再修复即可。</p>\n<h2 id=\"总结\">总结</h2>\n<p>其实，这个问题就是粗心造成的，当然，客观上，现在手里系统太多，精力分散也是一个原因。</p>\n<p>另外，这个自动生成代码的机制，后期看看这块是否可以优化吧，能把id字段一起生成到xml中是最好。</p>\n<p>如果实在不行的话，也应该考虑，这种表的id字段，就设置为非自增、非空，必须让程序手动设置，也能及时发现问题。</p>\n<h2 id=\"问题2\">问题2</h2>\n<h2 id=\"etl\">etl</h2>\n<p>介绍背景前，先讲讲etl吧：</p>\n<p>在我从业没几年的时候，当时由于接触的都是mysql这种oltp这类业务为主，有时候看到一些招聘岗位写etl，不知道是啥意思。也是这几年才大概了解：</p>\n<pre><code class=\"language-shell\">将企业中分散的数据，集中的输入到数据仓库中的过程，就是 ETL。\n\nExtract（提取）： 从多个异构数据源（如数据库、文件系统、API等）中提取原始数据。数据源可以是关系型数据库（如MySQL、PostgreSQL）、非关系型数据库（如MongoDB、Cassandra）、文件（如CSV、JSON）、API或流式数据源。\n\nTransform（转换）： 对提取的数据进行清洗、标准化、聚合、去重等操作，以满足业务需求或数据分析的要求。这一步可能涉及数据类型转换、格式转换、业务规则应用、数据聚合、数据质量校验等。\n\nLoad（加载）： 将转换后的数据加载到目标存储系统中，通常是数据仓库或数据湖中，供后续的数据分析、报表或机器学习等用途。加载的方式可以是全量加载、增量加载或实时加载。\n</code></pre>\n<p><img alt=\"image-20260117113327615\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117113327615.png\" /></p>\n<p>像我们公司，数据库种类又多（oracle、mysql、pg、国产），系统又多，好多系统还是买的，你想要某个系统的数据，要么走接口，要么通过人家的表。一方面，好多买的系统，不喜欢对外提供接口（商业上的考虑，毕竟数据是无价的，让你难以迁移，也就是这几年，感觉新的软件系统才开始注重对外提供api）；另一方面，有时候表很多，有些表也很大，自己写接口去每天同步，工作量也不小，还要申请api key/api secret，还要开通网络，也是挺麻烦的，最终就慢慢习惯了、妥协了，通过数仓etl同步，还是能省一些事吧。</p>\n<h2 id=\"背景-1\">背景</h2>\n<p>另一个c端系统，重要性比上面那个系统重要多了，这两天也出了一个问题。</p>\n<p>这个系统，本来是一个外包同事在维护，由于他所在的公司和我们公司不再合作了，他也就跟着离职了（其实可以和新外包公司签约，不过他说新外包公司不太喜欢）。他开发完成了最后一个功能并完成测试后，还没来得及系统上线，所以上线的事就我来弄。</p>\n<p>我整理了一下上线的各种变更，如sql、nacos配置、xxljob、版本jar包、前端包等等一大堆，写了个文档就提交变更流程了。</p>\n<p>其中一个sql，是给某个数仓同步表加id字段（并新建了序列，设置id字段通过序列来自增），我当时还专门研究了一下：</p>\n<p>我们有两个表，jy_sync_h_logasset （当前表）、jy_sync_h_logasset_history（历史表），两个表的结构类似，只是一个存储最近几个月的数据（jy_sync_h_logasset ），一个存储几个人前的数据（jy_sync_h_logasset_history）。系统会定期把几个月前的数据，从当前表，转移到历史表里去，保证当前表的数据量不要太大，影响查询速度。</p>\n<p>这两个表，有一个问题，就是表没有设置id这种主键，为啥没主键呢，因为jy_sync_h_logasset 这个表的数据，是通过数仓的etl操作，从其他上游数据库搬运过来的。</p>\n<p>jy_sync_h_logasset 对应的上游的话，不一定是一个表，可能是一个视图，或者是一个sql，比如select name,oa_account from employee这种，它的sql中，就没有查询id字段，或者是多表join那种（一对多），就是算有id，也会导致id重复。</p>\n<p>所以，我猜测是这个原因，导致我方的这个表，是没有id字段的，也没弄主键。</p>\n<p>一个表，没有主键，据我所知，在分页查询时，容易不稳定，某一条记录可能会在这一页出现，在下一页继续出现，一般我们解决这种分页查询不稳定的问题，都是会按照某个字段排序，而一般首选就是id字段。</p>\n<p>对于这个没有id字段的表来说，分页查询应该是容易出问题的，所以我猜测，这就是本次sql变更（加id字段，创建序列，设置id字段从序列取值）的原因。</p>\n<p><img alt=\"image-20260117115053690\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117115053690.png\" /></p>\n<p>我当时为啥注意这个sql呢，我发现他只建了一个序列，然后两个表都用了这个序列，我当时多看了两眼，只是有点奇怪，一般来说，每个表会设置一个自己的序列。后来我看到，在将jy_sync_h_logasset表中几个月前的数据转移到jy_sync_h_logasset_history的定时任务中，代码里设置了jy_sync_h_logasset_history的id就直接使用jy_sync_h_logasset中的id，也就是说，jy_sync_h_logasset_history实际并不会使用序列中的值作为id，我也就没管了。当然，出事的确实也不是这个问题。</p>\n<p>周四下午，和运维一块，看着他做完上线变更，想着又了了一个事。结果周五早上，8点多，就给我发消息，说有个xxljob的定时任务失败了。</p>\n<p>我赶紧吃完饭，抱着电脑去找他，看了下，发现报错的原因是：</p>\n<p>一个etl_status的表中，没有查到当天的记录，这个表的用途是：数仓在给我们推送完各个表的数据后，会在etl_status中写入一条成功记录。</p>\n<p>既然这次报错是没查到数仓写的成功记录，是不是数据推送失败了呢，我们赶紧联系了数仓的同事，数仓同事过了会告诉我们说，是数仓在往jy_sync_h_logasset写记录时，报错了，提示对jy_sync_h_logasset_pk这个序列的权限不足。然后我过去找他，仔细聊了下，比如，他那边的一次数仓etl任务，总共要推10个表过来，如果其中一个表失败了，就会导致：不写入etl_status成功记录。但已经推送成功的表（如这里成功了9个表）的数据并不会回退。</p>\n<p>问题是搞清楚了，还是粗心导致的，我当时完全没有想起来序列要给数仓用户授权这个事。</p>\n<p>但这个问题看起来小，导致的影响还是比较大的，由于我们定位这个问题及修复（给数仓用户增加权限，数仓重新推送）花了一些时间，修复时已经过了某个特定的时点了，导致我方已经没有时间再来跑xxljob了（某个xxljob任务由于下游系统的限制，要求必须在某个时点之前跑才行），只能是让业务同事去通知客户道歉。</p>\n<p>部门的领导也介入了这个事情，下周就得系统梳理下现状，再看看有没有在这种异常情况下进行补救的措施，当然，我们这边其实是可以补救的（数仓重新推送数据后，我方也重新执行xxljob相关任务），但是我们系统还有下游（现在就是下游系统不支持过了某个时间点后进行补救），这块还得再看看怎么弄。</p>\n<h2 id=\"总结-1\">总结</h2>\n<p>小小的问题，大大的影响，出了问题再来处理，一般成本是最高的，也会带来更多的工作，如事故汇报、针对事故的改进措施等。还是得防患于未然，治未病。</p>\n<p>当然，我简单看了下，希望postgresql可以做到：新增的序列，不用每次单独授权，而是在数据库级别进行授权。</p>\n<p><img alt=\"image-20260117122000029\" src=\"https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/image-20260117122000029.png\" /></p>\n<p>下周再研究下吧，和dba沟通下，避免现在权限管的太细导致的问题。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 12:23</span>&nbsp;\n<a href=\"https://www.cnblogs.com/grey-wolf\">三国梦回</a>&nbsp;\n阅读(<span id=\"post_view_count\">162</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "FFmpeg开发笔记（九十九）基于Kotlin的国产开源播放器DKVideoPlayer",
      "link": "https://www.cnblogs.com/aqi00/p/19379646",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/aqi00/p/19379646\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 12:15\">\n    <span>FFmpeg开发笔记（九十九）基于Kotlin的国产开源播放器DKVideoPlayer</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body blogpost-body-html\" id=\"cnblogs_post_body\">\n<span id=\"cke_bm_197S\">在Android平台上，基于FFmpeg的国产播放器开源框架也有很多了，前有哔哩哔哩的ijkplayer，后有小红书的RedPlayer，参见之前的文章《使用国产的ijkplayer播放器观看网络视频》和《使用国产的RedPlayer播放器观看网络视频》。</span>\n<p><span id=\"cke_bm_197S\"> 除此以外，DKVideoPlayer也是一款优秀的国产Android视频播放器，它基于Kotlin编写，不但集成了Android原生的MediaPlayer，还集成了Jetpack的ExoPlayer，甚至集成了国产的ijkplayer。DKVideoPlayer既支持播放本地视频，也支持播放网络视频，甚至支持播放直播链接，可谓功能强大。<br />\nDKVideoPlayer的源码托管地址为https://github.com/Doikki/DKVideoPlayer（星星数5.3k），国内的镜像地址为https://gitcode.com/gh_mirrors/dk/DKVideoPlayer，最新版本是2022年7月发布的v3.3.7，可见该框架的源码更新十分及时，该版本的源码下载地址为https://github.com/Doikki/DKVideoPlayer/archive/refs/tags/3.3.7.tar.gz。<br />\nDKVideoPlayer提供了两种集成方式，引用在线库、直接导入源码，分别说明如下：</span></p>\n<h1>一、引用DKVideoPlayer在线库</h1>\n<p>Android工程引用DKVideoPlayer在线库时，需要修改以下两个配置：<br />\n1、打开模块级别的build.gradle，给dependencies节点补充下面几行配置，表示引入3.3.7版本的DKVideoPlayer库：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\"># 必选，内部默认使用系统mediaplayer进行解码\nimplementation 'xyz.doikki.android.dkplayer:dkplayer-java:3.3.7'\n# 可选，包含StandardVideoController的实现\nimplementation 'xyz.doikki.android.dkplayer:dkplayer-ui:3.3.7'\n# 可选，使用exoplayer进行解码\nimplementation 'xyz.doikki.android.dkplayer:player-exo:3.3.7'\n# 可选，使用ijkplayer进行解码\nimplementation 'xyz.doikki.android.dkplayer:player-ijk:3.3.7'\n# 可选，如需要缓存或者抖音预加载功能请引入此库\nimplementation 'xyz.doikki.android.dkplayer:videocache:3.3.7'</code></pre>\n</div>\n<p>2、打开App模块的src/main/AndroidManifest.xml，给manifest节点补充下面几行权限配置，表示声明悬浮窗、存储空间和网络等权限：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\">&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" /&gt;\n&lt;uses-permission android:name=\"android.permission.SYSTEM_OVERLAY_WINDOW\" /&gt;\n&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;\n&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;</code></pre>\n</div>\n<h1>二、直接导入DKVideoPlayer源码</h1>\n<p>DKVideoPlayer的源码已经适配Android Studio Dolphin（小海豚版本），仅需在项目级别的build.gradle补充国内仓库即可。也就是在repositories节点内部补充以下配置：</p>\n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected\">\n<pre class=\"cke_widget_element\"><code class=\"hljs\">// 以下四行添加阿里云的仓库地址，方便国内开发者下载相关插件\nmaven { url = uri(\"https://maven.aliyun.com/repository/jcenter\") }\nmaven { url = uri(\"https://maven.aliyun.com/repository/google\")}\nmaven { url = uri(\"https://maven.aliyun.com/repository/gradle-plugin\")}\nmaven { url = uri(\"https://maven.aliyun.com/repository/public\")}\n// 以下添加清华大学的仓库地址\nmaven { url = uri(\"https://mirrors.tuna.tsinghua.edu.cn/repository/maven-central/\") }</code></pre>\n</div>\n<p>增加以上配置的目的是引入国内的仓库地址，以便加快相关依赖包的下载速度。</p>\n<p>等待DKVideoPlayer工程编译通过，把主入口的dkplayer-sample模块安装到手机上，启动之后的App界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"dkplayer1\" class=\"lazyload\" height=\"468\" width=\"410\" /></span></span></span></span></p>\n<p>点击【点播】按钮，打开网络视频的播放界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"dkplayer2\" class=\"lazyload\" height=\"609\" width=\"403\" /></span></span></span></span></p>\n<p>或者点击【直播】按钮，打开直播链接的播放界面如下图所示：</p>\n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\"><span class=\"cke_reset cke_widget_drag_handler_container\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\"><img alt=\"dkplayer3\" class=\"lazyload\" height=\"608\" width=\"403\" /></span></span></span></span></p>\n<p>可见DKVideoPlayer支持调整播放窗口大小、调整播放速度，以及旋转、截图、裁剪等功能，可谓将常见的播放操作一网打尽。</p>\n<p>更多详细的FFmpeg开发知识参见<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\"><a class=\"cke_widget_editable cke_widget_element\" href=\"https://item.jd.com/14020415.html\" rel=\"noopener nofollow\" title=\"《FFmpeg开发实战：从零基础到短视频上线》\">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</span></p>\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 12:15</span>&nbsp;\n<a href=\"https://www.cnblogs.com/aqi00\">aqi00</a>&nbsp;\n阅读(<span id=\"post_view_count\">123</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "大模型榜单周报（2026/1/17）",
      "link": "https://www.cnblogs.com/xjk15082/p/19495655",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/xjk15082/p/19495655\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 12:01\">\n    <span>大模型榜单周报（2026/1/17）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h3 id=\"1-本周概览\">1. 本周概览</h3>\n<p>本周大模型领域继续保持快速发展态势，各大厂商在医疗AI、视频生成、代码能力等多个领域取得显著进展。OpenRouter模型调用量排名发生重要变化，Claude系列模型表现抢眼，百度新模型ERNIE-5.0-0110在全球LMArena文本排行榜上排名第八，展现了中国模型的强劲实力。</p>\n<h3 id=\"2-重点关注事件\">2. 重点关注事件</h3>\n<ul>\n<li>DeepSeek与北京大学合作发表关于条件记忆（conditional memory）的新论文，提出Engram模块，有望提升模型检索效率</li>\n<li>Anthropic推出工作场景智能体Claude Cowork，由Claude Code自主开发，体现了AGI在实际应用中的潜力</li>\n<li>谷歌发布新一代开源医疗AI模型MedGemma 1.5及MedASR语音识别模型，进一步扩展在医疗AI领域的布局</li>\n<li>谷歌Veo 3.1更新支持9:16竖屏视频和4K分辨率，视频生成能力持续提升</li>\n<li>智谱与华为合作开源图像生成模型GLM-Image，登顶复杂视觉文字生成和长文本渲染双榜首</li>\n<li>阿里千问APP上线超400项AI办事功能，接入阿里生态，成为全球首个能完成真实生活复杂任务的AI助手</li>\n<li>OpenAI推出独立翻译页面ChatGPT Translate，拓展应用场景</li>\n<li>百度ERNIE-5.0-0110在全球LMArena文本排行榜上排名第八，超越多个领先模型</li>\n</ul>\n<h3 id=\"3-榜单变化\">3. 榜单变化</h3>\n<ul>\n<li>\n<p><strong>OpenRouter模型调用量排名</strong>：</p>\n<ul>\n<li>整体调用量方面，Claude Opus 4.5超越上周榜首Claude Sonnet 4.5，位列第1；MiMo-V2-Flash(free)上升两名，排名第3；Gemini 3 Flash Preview由第4名下降至第5名</li>\n<li>模型市占率方面，Google保持第1；Anthropic市占率上升4.2%（17.2% → 21.5%），连续两周上升8.5%；OpenAI市占率上升3.1%（8.0% → 11.1%）；Qwen上升至第8名，替代了上周MiniMax的位置</li>\n<li>编程调用量方面，Claude Opus 4.5保持第1；Claude Sonnet 4.5排名上升2名，排名第3；DeepSeek V3.2重回前十，排名第8</li>\n</ul>\n</li>\n<li>\n<p><strong>大语言模型榜单</strong>：ERNIE-5.0-0110新上榜，排名第8，超过GPT-5.1（high），相比ERNIE-5.0-preview-1203版本上升了6名，该模型基于预发布测试，评分可能随着公开发布后的反馈而变化</p>\n</li>\n<li>\n<p><strong>图像编辑能力榜单</strong>：flux-2-max和flux-2-pro新上榜，分别排名第8、第9</p>\n</li>\n<li>\n<p><strong>文生图能力榜单</strong>：FLUX.2 [dev]Turbo新上榜，排名第10</p>\n</li>\n<li>\n<p><strong>GAIA榜单</strong>：JoinAI V2.2登顶榜首，得分达90.7%</p>\n</li>\n</ul>\n<h3 id=\"4-排行榜\">4. 排行榜</h3>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>第一名</th>\n<th>第二名</th>\n<th>第三名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模型调用量</td>\n<td>Claude Opus 4.5</td>\n<td>Claude Sonnet 4.5</td>\n<td>MiMo-V2-Flash(free)</td>\n</tr>\n<tr>\n<td>公司市占率</td>\n<td>Google</td>\n<td>Anthropic</td>\n<td>OpenAI</td>\n</tr>\n<tr>\n<td>编程模型调用量</td>\n<td>Claude Opus 4.5</td>\n<td>Grok Code Fast 1</td>\n<td>Claude Sonnet 4.5</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"各公司按不同能力领域排名汇总\">各公司按不同能力领域排名汇总</h4>\n<table>\n<thead>\n<tr>\n<th>测评类型</th>\n<th>领先公司</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>大语言模型 Text Arena</td>\n<td>Google、xAI、Anthropic、百度、OpenAI、智谱、阿里巴巴、月之暗面</td>\n</tr>\n<tr>\n<td>编程能力 LMArena</td>\n<td>Anthropic、OpenAI、Google、智谱、MiniMax</td>\n</tr>\n<tr>\n<td>编程能力 LiveCodeBench</td>\n<td>OpenAI、Anthropic、Google</td>\n</tr>\n<tr>\n<td>代码工程任务能力 SWE-benchLite</td>\n<td>基于Claude、Gemini、GPT、Qwen、DeepSeek开发的开源系统</td>\n</tr>\n<tr>\n<td>图像编辑和生成能力 Image Edit Arena</td>\n<td>OpenAI、Google、字节、Black Forest Labs、Reve</td>\n</tr>\n<tr>\n<td>文生图能力 Text-to-Image Arena</td>\n<td>OpenAI、Google、Black Forest Labs、腾讯、字节</td>\n</tr>\n<tr>\n<td>文生图能力 Text to Image Leaderboard</td>\n<td>OpenAI、Google、Black Forest Labs、字节、ImagineArt</td>\n</tr>\n<tr>\n<td>GPQA</td>\n<td>OpenAI、Google、xAI、Anthropic、阿里巴巴</td>\n</tr>\n<tr>\n<td>FrontierMath</td>\n<td>OpenAI、Google、DeepSeek、月之暗面、Anthropic、xAI</td>\n</tr>\n<tr>\n<td>Humanity's Last Exam</td>\n<td>Google、OpenAI、Anthropic</td>\n</tr>\n<tr>\n<td>GAIA</td>\n<td>JoinAI、Nvidia、Suzhou AI Lab&amp;Shuqian Tech、Microsoft AI Asia -Ads</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<p>关注我，第一时间掌握更多AI前沿资讯！</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 12:01</span>&nbsp;\n<a href=\"https://www.cnblogs.com/xjk15082\">KAI智习</a>&nbsp;\n阅读(<span id=\"post_view_count\">150</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "PHP 8.5 闭包和一等可调用对象进入常量表达式",
      "link": "https://www.cnblogs.com/catchadmin/p/19494966",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/catchadmin/p/19494966\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 08:09\">\n    <span>PHP 8.5 闭包和一等可调用对象进入常量表达式</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"php-85-闭包和一等可调用对象进入常量表达式\">PHP 8.5 闭包和一等可调用对象进入常量表达式</h1>\n<h2 id=\"当配置变成运行时胶水代码\">当\"配置\"变成运行时胶水代码</h2>\n<p>PHP 配置一直有个矛盾：</p>\n<ul>\n<li>你想要声明式配置：简单的数组、常量值、属性。</li>\n<li>但你也需要一点逻辑：\"验证这个字段\"、\"选择这个处理器\"、\"格式化这个值\"、\"过滤这个列表\"。</li>\n</ul>\n<p>以前，一旦你需要在\"配置类\"的地方加逻辑，就会碰壁。PHP 故意把很多结构限制在常量表达式——基本上就是不可变的值。属性参数是最明显的例子：你可以放整数、字符串、标量数组……但不能放闭包。</p>\n<p>所以我们用各种变通方案：</p>\n<ul>\n<li>存字符串如 <code>\"App\\\\Handler::handle\"</code>，然后用 <code>call_user_func</code> 调用。</li>\n<li>在属性里用\"迷你语言\"，比如表达式字符串。</li>\n<li>用可空回调，在运行时设置默认值。</li>\n<li>在引导文件里建注册表，而不是直接在该放的地方表达。</li>\n</ul>\n<p>PHP 8.5 改变了这个局面：静态闭包和一等可调用对象现在可以出现在常量表达式中，包括：</p>\n<ul>\n<li>属性参数</li>\n<li>属性和参数的默认值</li>\n<li>常量和类常量</li>\n</ul>\n<p>这听起来像编译器特性。实际上是个\"生活质量\"升级：让你把配置放在它配置的代码旁边，不用魔术字符串或运行时初始化 hack。</p>\n<p>这篇文章会讲\"为什么\"、具体规则（有重要限制），然后深入实际模式：路由映射、处理器注册表、策略/格式化器注册表。也会讲哪些场景不适合——因为如果不小心，可调用配置确实能搞出一团乱。</p>\n<p><a href=\"https://catchadmin.com/post/2026-01/php85-closures-callables-constant-expressions\" rel=\"noopener nofollow\" target=\"_blank\">原文 PHP 8.5 闭包和一等可调用对象进入常量表达式</a></p>\n<h2 id=\"旧痛点常量太受限逻辑只能塞进运行时初始化\">旧痛点：常量太受限，逻辑只能塞进运行时初始化</h2>\n<p>PHP 8.5 之前，限制不是你不能创建闭包——而是你不能在某些\"配置槽\"里用它们。</p>\n<p>三个常见痛点：</p>\n<h3 id=\"痛点-a回调默认值参数强制运行时初始化\">痛点 A：\"回调默认值\"参数强制运行时初始化</h3>\n<p>如果你想写一个接受可选回调的函数，并且想要一个合理的默认回调，通常这样做：</p>\n<pre><code class=\"language-php\">function my_filter(array $items, ?Closure $predicate = null): array\n{\n    $predicate ??= static function ($v): bool { return !empty($v); };\n    $out = [];\n    foreach ($items as $item) {\n        if ($predicate($item)) {\n            $out[] = $item;\n        }\n    }\n    return $out;\n}\n</code></pre>\n<p>这能用……但是样板代码，而且不是\"声明式\"的。</p>\n<p>PHP 8.5 的 RFC 明确提到这个用例：允许直接声明默认回调闭包，不用可空参数的变通方案。</p>\n<h3 id=\"痛点-b属性参数不能包含真正的逻辑\">痛点 B：属性参数不能包含真正的逻辑</h3>\n<p>属性是表达规则的自然场所：</p>\n<ul>\n<li>授权检查</li>\n<li>验证</li>\n<li>序列化行为</li>\n<li>测试用例生成</li>\n</ul>\n<p>但属性参数只能是常量表达式，所以人们用字符串或表达式对象。</p>\n<p>PHP 8.5 发布公告展示了一个典型的\"之前\"模式，访问控制属性接受字符串表达式。在 PHP 8.5 中你可以直接传静态闭包。</p>\n<h3 id=\"痛点-c注册表和路由映射变成运行时引导\">痛点 C：注册表和路由映射变成运行时引导</h3>\n<p>任何时候你想要从\"键\"到\"处理器\"的映射，你可能在运行时构建它：</p>\n<pre><code class=\"language-php\">$handlers = [\n    'json' =&gt; [JsonFormatter::class, 'format'],\n    'text' =&gt; [TextFormatter::class, 'format'],\n];\n</code></pre>\n<p>这能用，但很脆弱：</p>\n<ul>\n<li>IDE 重命名重构不能可靠地跟踪字符串方法名。</li>\n<li>静态分析更难理解什么是可调用的。</li>\n<li>你需要运行时代码来组装概念上是静态配置的东西。</li>\n</ul>\n<p>PHP 8.5 的常量表达式改进让你可以把这些注册表表达为常量——并且让处理器重构安全。</p>\n<h2 id=\"什么是常量表达式为什么重要\">什么是常量表达式，为什么重要</h2>\n<p>\"常量表达式\"是 PHP 内部术语，指在必须不依赖运行时状态就能计算的上下文中允许的表达式——可以理解为\"不可变值\"。</p>\n<p>这些上下文包括：</p>\n<ul>\n<li>属性参数</li>\n<li>参数和属性的默认值</li>\n<li>（类）常量</li>\n</ul>\n<p>闭包 RFC 总结旧规则为：常量表达式被限制在实际上是\"不可变值\"的操作，闭包不包括在内——尽管闭包本质上是编译后的代码（操作码），在约束下可以被视为不可变。</p>\n<p>为什么这很重要？</p>\n<p>因为这些上下文是你想放配置的地方：</p>\n<ul>\n<li>属性是你的元数据/配置层。</li>\n<li>默认参数/属性值表达预期行为，不需要样板代码。</li>\n<li>常量表达\"这个映射不会变\"。</li>\n</ul>\n<p>换句话说：常量表达式是 PHP 引导你走向声明式代码的地方。PHP 8.5 扩展了\"声明式\"的含义。</p>\n<h2 id=\"常量中的闭包安全可读的模式和硬性规则\">常量中的闭包：安全可读的模式（和硬性规则）</h2>\n<p>PHP 8.5 允许常量表达式中的闭包——但有严格约束：</p>\n<ul>\n<li>必须是静态的（没有 <code>$this</code>）。</li>\n<li>不能通过 <code>use(...)</code> 捕获外部变量。</li>\n<li>箭头函数在常量表达式中不支持，因为它们隐式捕获变量。</li>\n</ul>\n<p>这些规则是编译时强制的。</p>\n<p>这听起来有限制，但实际上这正是这个特性安全的原因：它防止意外把\"运行时状态\"偷渡进常量。</p>\n<h3 id=\"默认回调参数不需要可空样板\">默认回调参数，不需要可空样板</h3>\n<p>这是之前过滤器示例的干净 PHP 8.5 版本：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfunction my_filter(\n    array $items,\n    Closure $predicate = static function ($v): bool { return !empty($v); },\n): array {\n    $out = [];\n    foreach ($items as $item) {\n        if ($predicate($item)) {\n            $out[] = $item;\n        }\n    }\n    return $out;\n}\n</code></pre>\n<p>这正是闭包 RFC 强调的动机：你可以声明一个真正的默认回调，不需要\"可空 + 运行时默认\"。</p>\n<p>实际上，这也改善了工具支持：</p>\n<ul>\n<li>参数正确地类型化为 <code>Closure</code>，不是 <code>?Closure</code></li>\n<li>调用者不需要猜测 <code>null</code> 是否有特殊含义</li>\n<li>你去掉了一个分支和一行初始化噪音</li>\n</ul>\n<h3 id=\"包含可调用行为的类常量\">包含可调用行为的类常量</h3>\n<p>你可以在常量或类常量中存储闭包，把它们当作\"可调用配置\"。</p>\n<p>一个简单例子：格式化器注册表。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Formatters\n{\n    public const MAP = [\n        'trim_lower' =&gt; static function (string $s): string {\n            return strtolower(trim($s));\n        },\n        'digits_only' =&gt; static function (string $s): string {\n            return preg_replace('/\\D+/', '', $s) ?? '';\n        },\n    ];\n}\n</code></pre>\n<p>使用：</p>\n<pre><code class=\"language-php\">$input = \"  +62 (812) 345-678  \";\n$normalized = (Formatters::MAP['digits_only'])($input);\n</code></pre>\n<p>这读起来像配置，但不是\"字符串类型\"。它是真正的 PHP，编译过的，有类型的，可重构的。</p>\n<h3 id=\"属性默认值可调用行为作为默认策略\">属性默认值：可调用行为作为默认策略</h3>\n<p>因为常量表达式中的闭包可以用作属性默认值，你可以在属性声明处定义默认策略——同样不需要运行时初始化。</p>\n<p>例子：可配置的规范化器。</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Normalizer\n{\n    public Closure $normalize = static function (string $s): string {\n        return trim($s);\n    };\n\n    public function run(string $value): string\n    {\n        return ($this-&gt;normalize)($value);\n    }\n}\n</code></pre>\n<p><strong>重要细节</strong>：常量表达式中的闭包必须是静态的，这意味着闭包本身不能用 <code>$this</code>。</p>\n<p>这是故意的权衡：常量表达式只求值一次，而 <code>$this</code> 只有在闭包为每个对象实例重新创建时才有意义（这不是常量表达式的行为方式）。</p>\n<h3 id=\"作用域闭包在正确的上下文中仍然能看到私有成员\">作用域：闭包在正确的上下文中仍然能看到私有成员</h3>\n<p>尽管闭包必须是静态的（没有 <code>$this</code>），在这些常量上下文中创建的闭包仍然遵循正常的作用域规则。RFC 说明：</p>\n<ul>\n<li>属性默认值中的闭包可以访问所在类的私有属性/方法/常量</li>\n<li>属性参数中的闭包可以访问所在类的私有成员</li>\n</ul>\n<p>这启用了一个好模式：把复杂逻辑放在私有静态辅助方法中，把闭包作为配置暴露出来。</p>\n<h2 id=\"常量中的一等可调用对象重构安全的引用不用字符串\">常量中的一等可调用对象：重构安全的引用，不用字符串</h2>\n<p>闭包适合\"内联逻辑\"。但有时候你不想要内联逻辑——你想指向一个现有的函数或静态方法。</p>\n<p>这就是一等可调用对象（FCC）的用武之地。</p>\n<p>一等可调用对象看起来像：</p>\n<pre><code class=\"language-php\">strrev(...)\nMyClass::myMethod(...)\n</code></pre>\n<p>它们产生一个转发到函数/方法的 <code>Closure</code>。</p>\n<p>PHP 8.5 现在允许常量表达式中的 FCC 语法，旨在\"完善\"常量中闭包的特性。</p>\n<h3 id=\"为什么-fcc-比字符串可调用更好\">为什么 FCC 比字符串可调用更好</h3>\n<p>比较这两个：</p>\n<pre><code class=\"language-php\">// 旧方式\npublic const HANDLERS = [\n    'reverse' =&gt; 'strrev',\n    'slug' =&gt; 'App\\\\Slugger::slugify',\n];\n</code></pre>\n<p>对比：</p>\n<pre><code class=\"language-php\">// PHP 8.5\npublic const HANDLERS = [\n    'reverse' =&gt; strrev(...),\n    'slug' =&gt; Slugger::slugify(...),\n];\n</code></pre>\n<p>第二个版本更好，因为：</p>\n<ul>\n<li>可重构：重命名和移动更可靠</li>\n<li>静态分析可以理解它是可调用的</li>\n<li>你避免了魔术字符串和运行时可调用解析</li>\n</ul>\n<h3 id=\"常量表达式中-fcc-的约束\">常量表达式中 FCC 的约束</h3>\n<p>FCC RFC 添加了一些重要限制（除了正常的 FCC 规则）：</p>\n<ul>\n<li>只支持独立函数和静态方法（<code>::</code>）。</li>\n<li>只支持 <code>function_name(...)</code> 和 <code>ClassName::methodName(...)</code> 语法。</li>\n<li>你不能用表达式构建名称（<code>($fn)(...)</code>）、数组（<code>[ClassName::class, 'method'](...)</code>），或依赖 <code>__callStatic()</code> 魔术方法。</li>\n</ul>\n<p>这是好事：它让常量表达式中的 FCC 用法清晰且可分析。</p>\n<h2 id=\"实际用例\">实际用例</h2>\n<h3 id=\"用例路由映射作为常量\">用例：路由映射作为常量</h3>\n<p>传统方式，路由映射是运行时构建的：</p>\n<pre><code class=\"language-php\">$routes = [\n    'GET /health' =&gt; [HealthController::class, 'check'],\n    'GET /posts'  =&gt; [PostsController::class, 'index'],\n];\n</code></pre>\n<p>这能用，但不是重构安全的。</p>\n<p>在 PHP 8.5 中你可以用 FCC 或静态闭包定义路由映射，作为常量：</p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare(strict_types=1);\n\nfinal class Routes\n{\n    public const MAP = [\n        'GET /health' =&gt; HealthController::check(...),\n        'GET /posts'  =&gt; PostsController::index(...),\n        // 快速端点的内联处理器\n        'GET /version' =&gt; static function (Request $req): Response {\n            return Response::text('ok');\n        },\n    ];\n}\n</code></pre>\n<p>现在你可以实现一个简单的分发器：</p>\n<pre><code class=\"language-php\">final class Dispatcher\n{\n    public function dispatch(Request $req): Response\n    {\n        $key = $req-&gt;method . ' ' . $req-&gt;path;\n        $handler = Routes::MAP[$key] ?? null;\n        if ($handler === null) {\n            return Response::text('Not found', 404);\n        }\n        return $handler($req);\n    }\n}\n</code></pre>\n<p>这个模式有几个好处：</p>\n<ul>\n<li>路由映射是真正的常量配置。</li>\n<li>处理器是真正的可调用对象，不是字符串。</li>\n<li>重构更安全（特别是静态方法处理器）。</li>\n</ul>\n<p>实际的路由器需要路径参数；但即使这样，\"处理器注册表\"部分通常保持静态。</p>\n<h3 id=\"用例消息总线的处理器注册表\">用例：消息总线的处理器注册表</h3>\n<p>想象一个简单的消息总线：消息类映射到处理器。</p>\n<p>旧方式：</p>\n<pre><code class=\"language-php\">$handlers = [\n    UserRegistered::class =&gt; 'App\\\\Handlers\\\\SendWelcomeEmail::handle',\n];\n</code></pre>\n<p>现在，用 PHP 8.5 FCC：</p>\n<pre><code class=\"language-php\">final class MessageHandlers\n{\n    public const MAP = [\n        UserRegistered::class =&gt; SendWelcomeEmail::handle(...),\n        OrderPaid::class      =&gt; CreateInvoice::handle(...),\n    ];\n}\n</code></pre>\n<p>分发器：</p>\n<pre><code class=\"language-php\">final class Bus\n{\n    public function __construct(private Container $container) {}\n\n    public function handle(object $message): void\n    {\n        $handler = MessageHandlers::MAP[$message::class] ?? null;\n        if ($handler === null) {\n            throw new RuntimeException('No handler registered for ' . $message::class);\n        }\n        // 如果处理器是静态的，它们可以显式接受依赖，\n        // 或者你可以调整这个模式（见下面的 DI 说明）。\n        $handler($message, $this-&gt;container);\n    }\n}\n</code></pre>\n<p>关键概念：常量表达式让你把映射保持在常量中，但你仍然控制依赖如何注入——通过签名设计。</p>\n<h3 id=\"用例策略格式化器注册表switch-语句的干净替代\">用例：策略/格式化器注册表（switch 语句的干净替代）</h3>\n<p>这是我最喜欢的实际用途：替换一个不断增长的 switch。</p>\n<pre><code class=\"language-php\">function format(string $type, mixed $value): string\n{\n    return match ($type) {\n        'json' =&gt; json_encode($value),\n        'text' =&gt; (string) $value,\n        'upper' =&gt; strtoupper((string) $value),\n        default =&gt; throw new InvalidArgumentException('Unknown formatter'),\n    };\n}\n</code></pre>\n<p>现在想象这增长到 15-30 个策略。你最终得到一个大 match 和一个 diff 磁铁。</p>\n<p>用可调用常量：</p>\n<pre><code class=\"language-php\">final class FormatterRegistry\n{\n    public const FORMATTERS = [\n        'json' =&gt; static function (mixed $v): string {\n            return json_encode($v, JSON_THROW_ON_ERROR);\n        },\n        'text' =&gt; static function (mixed $v): string {\n            return (string) $v;\n        },\n        // FCC 到原生函数\n        'reverse' =&gt; strrev(...),\n    ];\n\n    public static function format(string $type, mixed $value): string\n    {\n        $fn = self::FORMATTERS[$type] ?? null;\n        if ($fn === null) {\n            throw new InvalidArgumentException(\"Unknown formatter: {$type}\");\n        }\n        return $fn($value);\n    }\n}\n</code></pre>\n<p>现在添加策略只需要改一行。</p>\n<h2 id=\"测试和依赖注入什么该放常量什么该放容器\">测试和依赖注入：什么该放常量，什么该放容器</h2>\n<p>这个特性引导你走向\"代码即配置\"。这很好——直到你开始把运行时状态注入到应该是静态的东西里。</p>\n<p>一个好的心智模型：</p>\n<ul>\n<li><strong>常量应该包含稳定的接线</strong>：映射、策略、不依赖运行时状态的小逻辑片段。</li>\n<li><strong>DI 容器应该包含运行时组装</strong>：需要环境相关接线的对象、IO 资源、凭证、连接等。</li>\n</ul>\n<h3 id=\"好的常量可调用用法纯粹的转换和策略\">好的常量可调用用法：纯粹的转换和策略</h3>\n<p>这些在常量表达式中是安全的：</p>\n<ul>\n<li>规范化函数（trim、canonicalize）</li>\n<li>路由/分发选择逻辑</li>\n<li>只依赖输入值的验证器</li>\n<li>格式化器和映射器</li>\n</ul>\n<h3 id=\"di-的用武之地当你需要依赖时\">DI 的用武之地：当你需要依赖时</h3>\n<p>你仍然可以通过设计可调用对象显式接受依赖来混合可调用配置和 DI。</p>\n<p>例子：注册表返回一个接受 <code>(Message $m, Container $c)</code> 的可调用对象：</p>\n<pre><code class=\"language-php\">final class Handlers\n{\n    public const MAP = [\n        UserRegistered::class =&gt; static function (UserRegistered $m, Container $c): void {\n            $mailer = $c-&gt;get(Mailer::class);\n            $mailer-&gt;sendWelcome($m-&gt;email);\n        },\n    ];\n}\n</code></pre>\n<p>这保持在约束内，因为闭包是静态的且不捕获状态。\"依赖解析\"在调用时发生，容器被传入。</p>\n<p>这总是理想的吗？不是。但它是一个干净、显式的桥梁。</p>\n<h3 id=\"测试影响更好的默认值更容易覆盖\">测试影响：更好的默认值，更容易覆盖</h3>\n<p>常量表达式闭包让默认值更干净：</p>\n<ul>\n<li>函数可以有默认闭包参数（不用可空）。</li>\n<li>属性可以有默认闭包策略。</li>\n</ul>\n<p>对于测试，你仍然可以通过传递不同的闭包参数或给对象属性赋值不同的策略来覆盖行为（如果该属性设计上是可变的）。主要改进是默认行为在它该在的地方表达，你不需要运行时初始化胶水代码来创建默认闭包。</p>\n<h2 id=\"陷阱捕获状态副作用和团队可读性\">陷阱：捕获状态、副作用和团队可读性</h2>\n<p>这个特性给你在\"配置上下文\"中更多能力。能力带来新的搬起石头砸自己脚的方式。</p>\n<h3 id=\"陷阱-a试图捕获状态不会编译这是好事\">陷阱 A：试图捕获状态（不会编译——这是好事）</h3>\n<p>你不能这样做：</p>\n<pre><code class=\"language-php\">$prefix = \"prod_\";\nconst FN = static function (string $s) use ($prefix): string {\n    return $prefix . $s;\n};\n</code></pre>\n<p>常量表达式中的闭包不能通过 <code>use(...)</code> 捕获变量。</p>\n<p>这是硬性约束，它强迫你采用更好的设计：</p>\n<ul>\n<li>把值作为参数传递</li>\n<li>使用常量/类常量</li>\n<li>或者做运行时配置，而不是假装它是常量</li>\n</ul>\n<p>类似地，箭头函数在常量表达式中被阻止，因为它们隐式捕获变量。</p>\n<h3 id=\"陷阱-b在配置里隐藏副作用\">陷阱 B：在\"配置\"里隐藏副作用</h3>\n<p>如果你的\"注册表\"闭包开始做 IO、访问数据库、读取环境变量等，你就让配置变得不可预测了。</p>\n<p>一个好规则：</p>\n<p>如果可调用对象做的不只是\"计算并返回\"，考虑把它移到真正的服务中，通过静态方法引用它（或容器接线）。</p>\n<h3 id=\"陷阱-c在纯数据更清晰的地方用可调用配置\">陷阱 C：在纯数据更清晰的地方用可调用配置</h3>\n<p>仅仅因为你能在属性里放代码，不意味着你应该这样做。</p>\n<p>如果你的规则可以表达为简单数据——用数据。例子：</p>\n<ul>\n<li>允许的角色</li>\n<li>数字范围</li>\n<li>枚举集合</li>\n</ul>\n<p>可调用配置应该是你的工具，用于数据本身变得笨拙的情况（或者你否则会发明一个字符串表达式 DSL）。</p>\n<h3 id=\"陷阱-d团队间的可读性和一致性\">陷阱 D：团队间的可读性和一致性</h3>\n<p>可调用配置仍然是代码。如果你的团队经验水平不一，你需要约定：</p>\n<ul>\n<li>保持常量表达式闭包简短。</li>\n<li>当闭包超过约 10 行时，倾向于命名逻辑并通过 FCC 引用它（<code>SomeClass::somePolicy(...)</code>）。</li>\n<li>避免花哨写法（特别是嵌套匿名函数）。</li>\n</ul>\n<h2 id=\"指南什么时候配置应该保持数据什么时候可调用配置是合理的\">指南：什么时候配置应该保持\"数据\"，什么时候\"可调用配置\"是合理的</h2>\n<p>这是一套在实际代码库中通常效果不错的实用指南。</p>\n<p><strong>在以下情况倾向于纯数据配置：</strong></p>\n<ul>\n<li>规则是静态且小的（标志、列表、阈值）</li>\n<li>你想要容易序列化（比如导出配置）</li>\n<li>你想让非开发者可以编辑配置（在某些组织中）</li>\n</ul>\n<p>例子：</p>\n<pre><code class=\"language-php\">final class Limits\n{\n    public const MAX_TITLE_LENGTH = 120;\n    public const ALLOWED_SORTS = ['newest', 'popular', 'discussed'];\n}\n</code></pre>\n<p><strong>在以下情况使用可调用配置：</strong></p>\n<ul>\n<li>规则简单但不能很好地映射到数据（比如谓词）</li>\n<li>使用数据会把你推向自定义 DSL</li>\n<li>你想通过属性让配置靠近类/方法</li>\n<li>你想要重构安全的可调用对象而不是字符串</li>\n</ul>\n<p>这正是 PHP 8.5 在属性、默认值和常量中启用的。</p>\n<p><strong>保持可调用配置安全且可维护：</strong></p>\n<ul>\n<li>让闭包静态（反正是必须的）。</li>\n<li>不要试图捕获外部变量（<code>use(...)</code> 不允许）。</li>\n<li>当逻辑增长时：把它移到命名的静态方法并用 FCC 引用它，PHP 8.5 现在在常量表达式中允许这样做。</li>\n<li>只在支持的形式中使用 FCC：<code>function_name(...)</code> 和 <code>ClassName::methodName(...)</code>（不支持数组可调用语法）。</li>\n</ul>\n<h3 id=\"关于性能和-opcache-的说明\">关于性能和 opcache 的说明</h3>\n<p>如果你想知道这是否\"免费\"，两个 RFC 都提到 opcache 需要调整才能正确地在共享内存中存储这些闭包/可调用对象。</p>\n<p>换句话说：这个特性的实现考虑了真实世界的运行时环境（opcache/JIT）。目标不是微优化——而是表达力和安全性。</p>\n<h2 id=\"小结\">小结</h2>\n<p>PHP 8.5 支持常量表达式中的静态闭包和一等可调用对象，这是那种在更新日志上看起来很小、然后悄悄改善你设计 API 方式的特性：</p>\n<ul>\n<li>默认回调变得干净且类型正确（不用可空样板）。</li>\n<li>属性可以携带真正的可执行策略逻辑——不用字符串 DSL。</li>\n<li>注册表和路由映射可以定义为常量，使用重构安全的可调用对象。</li>\n</ul>\n<p>约束就是护栏：不能捕获变量、没有 <code>$this</code>、常量表达式中没有箭头函数。</p>\n<p>如果你接受这些护栏，你会得到一个真正更好的\"编译时风格\"配置层——接线是静态的、可读的、重构更安全。</p>\n<p>用它来移除胶水代码，而不是隐藏复杂性。保持可调用配置简短，给重的东西命名，让你的常量描述\"发生什么\"，而不是把它们变成迷你应用程序。</p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 08:09</span>&nbsp;\n<a href=\"https://www.cnblogs.com/catchadmin\">JaguarJack</a>&nbsp;\n阅读(<span id=\"post_view_count\">50</span>)&nbsp;\n评论(<span id=\"post_comment_count\">1</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "编写一个Buildroot 驱动",
      "link": "https://www.cnblogs.com/tianwuyvlianshui/p/19494280",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/tianwuyvlianshui/p/19494280\" id=\"cb_post_title_url\" title=\"发布于 2026-01-16 22:45\">\n    <span>编写一个Buildroot 驱动</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"编写一个buildroot-驱动模块\">编写一个Buildroot 驱动模块</h1>\n<p>由于Buildroot 不支持ssh</p>\n<p>故采用adb调试</p>\n<h2 id=\"adb连接\">adb连接</h2>\n<h3 id=\"列出设备\">列出设备</h3>\n<pre><code>adb devices\n</code></pre>\n<p><img alt=\"image-20260116202202616\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224244254-2021753310.png\" /></p>\n<h3 id=\"连接设备\">连接设备</h3>\n<pre><code>adb shell\n</code></pre>\n<p><img alt=\"image-20260116202213317\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224245370-1464333835.png\" /></p>\n<h2 id=\"驱动模块编译交叉编译\">驱动模块编译(交叉编译)</h2>\n<h3 id=\"驱动模块源码\">驱动模块源码</h3>\n<pre><code class=\"language-c\">#include &lt;linux/module.h&gt;     /* 模块相关宏和函数 */\n#include &lt;linux/kernel.h&gt;     /* printk日志函数 */\n\n/* 加载函数（驱动入口），当驱动被 insmod 加载时自动执行 */\nstatic int __init helloworld_init(void)\n{\n    printk(\"helloworld_init\\r\\n\"); // 内核日志打印\n    return 0; // 返回0代表加载成功\n}\n\n/* 卸载函数（驱动出口），当驱动被 rmmod 卸载时自动执行 */\nstatic void __exit helloworld_exit(void)\n{\n    printk(\"helloworld_exit\\r\\n\");\n}\n\n/* 下面这两行，告诉内核入口和出口分别是哪两个函数 */\nmodule_init(helloworld_init);\nmodule_exit(helloworld_exit);\n\n/* 这3个是模块信息声明 */\nMODULE_LICENSE(\"GPL v2\");               /* 模块许可证 */\nMODULE_VERSION(\"1.0\");                  /* 模块版本，可选 */\nMODULE_DESCRIPTION(\"helloworld Driver\");/* 模块描述，可选，一般用于 lsmod 时显示 */\n</code></pre>\n<p>功能简单解释就是</p>\n<blockquote>\n<p>加载驱动：打印<strong>helloworld_init</strong></p>\n<p>卸载驱动：打印<strong>helloworld_exit</strong></p>\n</blockquote>\n<p>找到交叉编译工具路径</p>\n<pre><code>find prebuilts -name \"*gcc\" -type f\n</code></pre>\n<p><img alt=\"image-20260116221419705\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224245922-1390693708.png\" /></p>\n<p>一般在SDK路径下找</p>\n<h3 id=\"配置makefile\">配置Makefile</h3>\n<pre><code class=\"language-makefile\"># 目标架构\n# RK3566 是 ARM64 架构\nARCH ?= arm64\n\n# 交叉编译工具链前缀\n# 最终会使用：aarch64-linux-gnu-gcc / ld / objcopy 等\nCROSS_COMPILE ?= aarch64-linux-gnu-\n\n# Linux 内核源码目录\n# 必须是已经配置并且执行过 prepare/modules_prepare 的内核\n#作用：告诉 Makefile 用哪个内核版本的源码和头文件进行编译链接。\nKDIR := $(HOME)/Desktop/SDK/kernel\n\n# 当前外部模块源码所在目录\n# 内核会在这个目录下查找 obj-m 指定的模块源码\nPWD  := $(shell pwd)\n\n# 要编译的外部内核模块\n# hello_world.c  →  hello_world.ko\nobj-m += hello_world.o\n\n# 默认目标：编译内核模块\nall:\n\t# 调用内核源码目录下的 Makefile\n\t# M=$(PWD) 表示这是一个“外部模块”\n\t# ARCH / CROSS_COMPILE 指定目标架构和交叉编译器\n\t$(MAKE) -C $(KDIR) M=$(PWD) \\\n\t\tARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules\n\n# 清理编译生成的中间文件\nclean:\n\t$(MAKE) -C $(KDIR) M=$(PWD) clean\n\n</code></pre>\n<p>PS：主要寻找配置</p>\n<blockquote>\n<p>交叉编译工具链前缀：aarch64-linux-gnu-</p>\n<p>Linux 内核源码目录路径：$(HOME)/Desktop/SDK/kernel</p>\n</blockquote>\n<h3 id=\"编译\">编译</h3>\n<pre><code>make\n</code></pre>\n<p>模块输出路径</p>\n<p><img alt=\"image-20260116222818781\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224246555-359569486.png\" /></p>\n<h2 id=\"驱动测试\">驱动测试</h2>\n<h3 id=\"将驱动复制进rk3566板卡\">将驱动复制进rk3566板卡</h3>\n<h4 id=\"使用adb\">使用ADB</h4>\n<p>如果ADB已经连上板卡，则先断开连接</p>\n<pre><code>exit\n</code></pre>\n<p>寻找板卡设备</p>\n<pre><code>adb devices\n</code></pre>\n<p><img alt=\"image-20260116223436138\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224247234-648064983.png\" /></p>\n<p>将本地的驱动模块文件发送到板卡</p>\n<pre><code>adb -s 6c392aca38ad7c4b push F:\\Desktop\\SSH_Ubuntu18\\hello_world.ko /data/local/tmp/hello_world.ko\n</code></pre>\n<p><img alt=\"image-20260116223652779\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224248167-2138743187.png\" /></p>\n<h3 id=\"加载驱动模块\">加载驱动模块：</h3>\n<pre><code>insmod hello_world.ko\t\n</code></pre>\n<p>查看 驱动 相关日志</p>\n<pre><code>dmesg | grep -E 'hello'\t\n</code></pre>\n<p><img alt=\"image-20260116223813105\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224248958-58986670.png\" /></p>\n<h3 id=\"卸载模块驱动\">卸载模块驱动</h3>\n<pre><code>rmmod hello_world.ko\n</code></pre>\n<p>查看 驱动 相关日志</p>\n<pre><code>dmesg | grep -E 'hello'\t\n</code></pre>\n<p><img alt=\"image-20260116223939679\" src=\"https://img2024.cnblogs.com/blog/3281938/202601/3281938-20260116224249850-1462602200.png\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-16 22:45</span>&nbsp;\n<a href=\"https://www.cnblogs.com/tianwuyvlianshui\">沁拒离</a>&nbsp;\n阅读(<span id=\"post_view_count\">84</span>)&nbsp;\n评论(<span id=\"post_comment_count\">2</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "Apache 详解（在 Ubuntu 24 中安装和配置 Apache，超详细）",
      "link": "https://www.cnblogs.com/jeanwaljean/p/19497993",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/jeanwaljean/p/19497993\" id=\"cb_post_title_url\" title=\"发布于 2026-01-18 10:58\">\n    <span>Apache 详解（在 Ubuntu 24 中安装和配置 Apache，超详细）</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                <div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<h1 id=\"零散知识讲解\">零散知识讲解</h1>\n<p></p><div class=\"toc\"><div class=\"toc-container-header\">目录</div><ul><li><a href=\"#零散知识讲解\" rel=\"noopener nofollow\">零散知识讲解</a><ul><li><a href=\"#站点配置和全局配置的区别\" rel=\"noopener nofollow\">站点配置和全局配置的区别</a></li><li><a href=\"#www-data-用户介绍\" rel=\"noopener nofollow\">www-data 用户介绍</a></li><li><a href=\"#什么是进程的上下文切换\" rel=\"noopener nofollow\">什么是进程的上下文切换？</a></li><li><a href=\"#tcp-连接的三个阶段\" rel=\"noopener nofollow\">TCP 连接的三个阶段</a><ul><li><a href=\"#客户端和服务器通信的过程\" rel=\"noopener nofollow\">客户端和服务器通信的过程</a></li><li><a href=\"#开启-acceptfilter-和关闭-acceptfilter的区别\" rel=\"noopener nofollow\">开启 AcceptFilter 和关闭 AcceptFilter的区别</a></li></ul></li></ul></li><li><a href=\"#在-ubuntu-24-中安装和配置-apache\" rel=\"noopener nofollow\">在 Ubuntu 24 中安装和配置 Apache</a><ul><li><a href=\"#安装-apache\" rel=\"noopener nofollow\">安装 Apache</a></li><li><a href=\"#为开发-drupal-项目而配置-apache\" rel=\"noopener nofollow\">为开发 Drupal 项目而配置 Apache</a><ul><li><a href=\"#解决-apache-经常出现的连接延迟和超时问题\" rel=\"noopener nofollow\">解决 Apache 经常出现的连接延迟和超时问题</a></li><li><a href=\"#开启-apache-的简洁链接功能\" rel=\"noopener nofollow\">开启 Apache 的简洁链接功能</a></li><li><a href=\"#修改-apache-的默认站点根目录\" rel=\"noopener nofollow\">修改 Apache 的默认站点根目录</a><ul><li><a href=\"#补充知识\" rel=\"noopener nofollow\">补充知识</a></li><li><a href=\"#配置过程\" rel=\"noopener nofollow\">配置过程</a><ul><li><a href=\"#第一步修改-apache-站点配置文件指定新根目录\" rel=\"noopener nofollow\">第一步：修改 Apache 站点配置文件（指定新根目录）</a></li><li><a href=\"#第二步修改-huagai-的父目录的访问权限\" rel=\"noopener nofollow\">第二步：修改 huagai 的父目录的访问权限</a></li><li><a href=\"#第三步设置huagai目录及其子目录和文件的权限\" rel=\"noopener nofollow\">第三步：设置huagai目录及其子目录和文件的权限</a></li><li><a href=\"#第四步验证上述配置的语法是否正确\" rel=\"noopener nofollow\">第四步：验证上述配置的语法是否正确</a></li><li><a href=\"#第五步检查-apache-状态看配置是否有误\" rel=\"noopener nofollow\">第五步：检查 Apache 状态，看配置是否有误</a></li><li><a href=\"#第六步验证配置是否成功\" rel=\"noopener nofollow\">第六步：验证配置是否成功</a></li></ul></li></ul></li></ul></li></ul></li></ul></div><p></p>\n<hr />\n<h2 id=\"站点配置和全局配置的区别\">站点配置和全局配置的区别</h2>\n<p>全局配置文件（例如：/etc/apache2/apache2.conf）。<br />\n站点配置文件（例如：/etc/apache2/sites-available/000-default.conf）。</p>\n<p><em>二者的区别</em></p>\n<ol>\n<li>全局配置是 Apache 的 \"全局基准\"，管所有站点，核心参数不轻易动；</li>\n<li>站点配置是单个站点的 \"专属配置\"，管单个站点，灵活修改无副作用；</li>\n<li><strong>作用域和优先级是两者最核心的区别，站点配置可覆盖全局配置的局部规则</strong>，例如：当全局配置和站点配置中出现相同类型的配置项（比如都配置了/home/jean/personal/huagai的访问权限）时，站点配置的优先级高于全局配置。实际操作中，<strong>推荐优先修改站点配置</strong>（不污染全局规则，风险更低）。</li>\n<li>实际运维中，遵循 \"<strong>全局配置少改，站点配置按需改</strong>\" 的原则，更安全、更易维护。</li>\n</ol>\n<h2 id=\"www-data-用户介绍\">www-data 用户介绍</h2>\n<p>即使你已经设置了目标目录 /home/jean/personal/huagai 的权限，如果其父目录（如 /home/jean/personal 和 /home/jean）没有适当的权限，Apache 也无法访问最终的目标目录。 这是因为：Apache 使用用户 www-data 对网站进行访问，这个用户既不是/home/jean目录的所有者（所有者是jean），也不属于 jean 的用户组，而是属于其他用户，这个用户不具备访问父目录的权限。</p>\n<p>额外补充： 所有对www-data的权限配置，都要针对o来设置，o是Other的简写；x是excute的简写，代表执行某个文件或进入某个目录的权限。</p>\n<h2 id=\"什么是进程的上下文切换\">什么是进程的上下文切换？</h2>\n<ul>\n<li>进程从运行状态切换到睡眠状态</li>\n<li>保存当前 CPU 寄存器、内存映射等</li>\n<li>恢复另一个进程的状态</li>\n<li><strong>开销很大：</strong> 通常需要几千个 CPU 周期</li>\n</ul>\n<h2 id=\"tcp-连接的三个阶段\">TCP 连接的三个阶段</h2>\n<h3 id=\"客户端和服务器通信的过程\">客户端和服务器通信的过程</h3>\n<p>客户端：SYN → SYN-ACK → ACK → 数据<br />\n服务器：监听 → 接受连接 → 读取数据</p>\n<p>当客户端连接到服务器时：</p>\n<ol>\n<li><strong>三次握手</strong>（SYN, SYN-ACK, ACK）在<strong>内核</strong>中完成</li>\n<li>连接进入服务器的 <strong>“等待接受队列”</strong></li>\n<li>服务器应用程序（如 Apache）需要<strong>接受</strong>这个连接</li>\n<li>然后才能<strong>读取</strong>数据</li>\n</ol>\n<h3 id=\"开启-acceptfilter-和关闭-acceptfilter的区别\">开启 AcceptFilter 和关闭 AcceptFilter的区别</h3>\n<p><em>一、启用 AcceptFilter 时</em><br />\nAcceptFilter 默认是开启状态。在这种情况下：<br />\n在支持 AcceptFilter 的系统上（如 FreeBSD、Linux 的某些版本）：内核会等待客户端发送数据后才将连接交给 Apache 进程，这样可以过滤掉大量的空连接、端口扫描、DDoS攻击连接。</p>\n<p>工作原理：</p>\n<ol>\n<li>客户端发送 SYN</li>\n<li>内核完成三次握手</li>\n<li><strong>连接进入特殊队列（不是等待接受队列）</strong></li>\n<li>客户端发送第一个数据包（如 HTTP 请求的 \"GET /\"）</li>\n<li>内核收到数据后，<strong>才</strong>将连接放入等待接受队列</li>\n<li>这时 Apache 调用 accept() 才会收到这个连接</li>\n</ol>\n<p><em>二、关闭 AcceptFilter 时</em><br />\n设置为 none 后，系统使用传统的 accept() 系统调用，工作原理是：</p>\n<ol>\n<li>客户端发送 SYN（开始连接）</li>\n<li>内核完成三次握手</li>\n<li>连接进入等待队列</li>\n<li>Apache 调用 accept()</li>\n<li>内核返回连接给 Apache</li>\n<li>Apache 调用 recv() 等待数据</li>\n</ol>\n<p><strong>使用传统的 accept() 系统调用的特点：</strong></p>\n<ul>\n<li>立即接受：禁用内核级别的连接过滤，连接建立后立即交给 Apache。</li>\n<li>立即接受所有 TCP 连接，即使连接上没有数据。</li>\n<li>阻塞等待：如果没有连接，进程会<strong>休眠</strong></li>\n<li>一对一处理：每个连接都需要单独的 accept() 调用</li>\n</ul>\n<p>禁用 AcceptFilter（设置为 none）的好处：</p>\n<ol>\n<li>立即接受所有连接。</li>\n<li>兼容性最好</li>\n<li>延迟最低</li>\n</ol>\n<p>注意： 在 Windows 系统中，不支持 AcceptFilter，配置会被忽略。</p>\n<h1 id=\"在-ubuntu-24-中安装和配置-apache\">在 Ubuntu 24 中安装和配置 Apache</h1>\n<h2 id=\"安装-apache\">安装 Apache</h2>\n<p>说明： 这个安装过程对于在Ubuntu 24 系统中安装Apache、在 Windows 系统上的WSL2中的Ubuntu 24系统中安装Apache，都适用。</p>\n<ul>\n<li>\n<p>第一步：先更新软件仓库、升级软件模块。打开 Ubuntu 终端，更新软件源并升级现有包，确保系统处于最新状态：sudo apt update -y &amp;&amp; sudo apt upgrade -y</p>\n</li>\n<li>\n<p>第二步：安装 Apache 服务器：sudo apt install apache2 -y</p>\n</li>\n<li>\n<p>第三步：查看安装的 Apache 的版本：apache2 -v</p>\n</li>\n</ul>\n<p>第四步：启动 Apache 服务：sudo systemctl start apache2</p>\n<p>第五步：设置开机自动启动 Apache 服务：sudo systemctl enable apache2</p>\n<p>第六步：验证 Apache 是否安装成功：</p>\n<ul>\n<li>方法一：在 Windows 浏览器中访问 <a href=\"http://localhost\" rel=\"noopener nofollow\" target=\"_blank\">http://localhost</a>。</li>\n<li>方法二：通过检查Apache状态：sudo systemctl status apache2【若显示 active (running)，则代表 Apache 已启动】</li>\n</ul>\n<h2 id=\"为开发-drupal-项目而配置-apache\">为开发 Drupal 项目而配置 Apache</h2>\n<h3 id=\"解决-apache-经常出现的连接延迟和超时问题\">解决 Apache 经常出现的连接延迟和超时问题</h3>\n<p>在 Ubuntu 中输入命令：sudo nano /etc/apache2/apache2.conf（Apache 的全局配置文件），在文件中添加如下参数：</p>\n<pre><code>\tAcceptFilter https none\n\tAcceptFilter http none\n</code></pre>\n<ul>\n<li><strong>AcceptFilter 指令是什么？</strong><br />\n详见本文的“TCP 连接的三个阶段”部分，同时在此处进行简要介绍。\n<ul>\n<li><strong>用途：</strong> 配置操作系统内核如何处理新的网络连接</li>\n<li><strong>目的：</strong> 提高服务器性能，减少进程上下文切换开销</li>\n<li><strong>原理：</strong> 让内核在连接真正有数据到达时才唤醒 Apache 进程</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"开启-apache-的简洁链接功能\">开启 Apache 的简洁链接功能</h3>\n<p>说明：</p>\n<ol>\n<li>对于 Drupal 开发来说，必须要开启 Apache 的 URL 重写模块，才能开启 Apache 的简洁链接功能。</li>\n<li>默认情况下，Apache 没有开启该模块。可以通过命令 apache2ctl -M 或 apachectl -M，查看Apache当前已经加载的模块，看是否有rewrite_module 模块。</li>\n</ol>\n<p><em>具体开启步骤：</em></p>\n<ul>\n<li>启用 rewrite_module  模块：sudo a2enmod rewrite【a2enmod是 Apache 2 enable module 的缩写】</li>\n<li>重启 Apache，激活新的配置：sudo systemctl restart apache2</li>\n<li>检查 Apache 配置是否有误：sudo apache2ctl configtest（语法正确的话会返回Syntax OK）</li>\n<li>给 Apache 启用简洁链接功能：在Ubuntu系统中，执行命令 sudo nano /etc/apache2/apache2.conf，把其中的 AllowOverride None 改为 AllowOverride All，如图：<br />\n<img alt=\"\" class=\"lazyload\" /><img class=\"cke_reset cke_widget_drag_handler jop-noMdConv lazyload\" draggable=\"true\" height=\"15\" title=\"点击并拖拽以移动\" width=\"15\" /></li>\n<li>重启 Apache 使配置生效：sudo systemctl restart apache2</li>\n</ul>\n<h3 id=\"修改-apache-的默认站点根目录\">修改 Apache 的默认站点根目录</h3>\n<h4 id=\"补充知识\">补充知识</h4>\n<ul>\n<li>Apache 的默认根目录是：<code>/var/www/html</code></li>\n<li>修改目标：把 Apache 的默认根目录改为：<code>/home/jean/personal/huagai</code></li>\n</ul>\n<h4 id=\"配置过程\">配置过程</h4>\n<h5 id=\"第一步修改-apache-站点配置文件指定新根目录\">第一步：修改 Apache 站点配置文件（指定新根目录）</h5>\n<ul>\n<li>\n<p>先备份原始的站点配置文件：<code>sudo cp /etc/apache2/sites-available/000-default.conf /etc/apache2/sites-available/000-default.conf.bak</code></p>\n</li>\n<li>\n<p>用文本编辑器打开默认站点配置文件：<code>sudo nano /etc/apache2/sites-available/000-default.conf</code></p>\n</li>\n<li>\n<p>找到 DocumentRoot 配置项，将其默认值（通常是/var/www/html）修改为你的目标目录：</p>\n<pre><code># 原配置\n# DocumentRoot /var/www/html\n# 新配置\nDocumentRoot /home/jean/personal/huagai\n</code></pre>\n</li>\n<li>\n<p>找到或新建（若没有则手动添加）对应的 配置块，该配置块的作用是配置目录访问权限（允许 Apache 读取该目录）：</p>\n<pre><code>&lt;Directory /home/jean/personal/huagai&gt;\n    # 允许目录索引\n    Options Indexes FollowSymLinks\n    # 允许使用.htaccess文件\n    AllowOverride All\n    # 核心：授权所有客户端访问该目录（Apache 2.4+ 语法）\n    Require all granted\n&lt;/Directory&gt;\n</code></pre>\n</li>\n<li>\n<p>保存并退出（在 nano 中按 Ctrl+O，回车，再按 Ctrl+X）。以上几步操作后的完整代码如下：</p>\n<pre><code>&lt;VirtualHost *:80&gt;\n    ServerAdmin webmaster@localhost\n    DocumentRoot /home/jean/personal/huagai\n\n    &lt;Directory /home/jean/personal/huagai&gt;\n        Options Indexes FollowSymLinks\n        AllowOverride All\n        Require all granted\n    &lt;/Directory&gt;\n\n    ErrorLog ${APACHE_LOG_DIR}/error.log\n    CustomLog ${APACHE_LOG_DIR}/access.log combined\n&lt;/VirtualHost&gt;\n</code></pre>\n</li>\n</ul>\n<h5 id=\"第二步修改-huagai-的父目录的访问权限\">第二步：修改 huagai 的父目录的访问权限</h5>\n<p>Apache 进程默认以www-data用户（组）运行站点，而目标目录/home/jean/personal/huagai属于用户jean和用户组jean，需要赋予www-data足够的读取权限，或者将www-data加入到用户组jean中。在这步操作中，我们选择”将www-data加入到用户组jean中“。</p>\n<p><strong>方法一：把用户www-data加入到用户组jean中（推荐）</strong></p>\n<pre><code>    sudo usermod -a -G jean www-data\n</code></pre>\n<p><strong>方法二：赋予其他用户（也包括了www-data用户）进入目录的权限（不推荐）</strong></p>\n<ul>\n<li>对必要的父目录设置合适的权限，允许 Apache 进入这些目录但不读取它们的内容：给 /home/jean/ 和 /home/jean/personal 目录的「其他用户（包含 www-data）」，新增「进入 / 搜索目录的权限」，让 Apache 能从/home/进入/home/jean/，再继续进入personal/，最终访问到huagai/。</li>\n</ul>\n<pre><code>    chmod o+x /home/jean\n    chmod o+x /home/jean/personal\n</code></pre>\n<h5 id=\"第三步设置huagai目录及其子目录和文件的权限\">第三步：设置huagai目录及其子目录和文件的权限</h5>\n<p>现在，www-data用户可以进入到 personal 目录了，但还无法操作 huagai 目录。下一步，以管理员权限，递归地将 /home/jean/personal/huagai 目录本身、以及该目录下的所有子目录和文件的所有者设置为 jean，所属用户组设置为 jean。<br />\n<code>sudo chown -R jean:jean /home/jean/personal/huagai</code></p>\n<ul>\n<li>以管理员权限，递归地为 /home/jean/personal/huagai 目录及其所有子目录、文件设置权限：所有者和所属组拥有完整的读、写、执行权限，其他用户仅拥有读和执行权限，无写入权限。<br />\n<code>sudo chmod -R 775 /home/jean/personal/huagai</code></li>\n</ul>\n<p>因为之前设置了 www-data 在用户组 jean 中，因此，www-data 现在可以操作（读、写、执行）huagai目录及其所有子目录、文件了。</p>\n<h5 id=\"第四步验证上述配置的语法是否正确\">第四步：验证上述配置的语法是否正确</h5>\n<ul>\n<li>先验证配置语法是否正确（避免配置错误导致服务无法启动）：<code>sudo apache2ctl configtest</code>，若输出 Syntax OK 则说明配置无误；若有报错，根据提示修正配置文件。</li>\n<li>重启 Apache 服务使配置生效：<code>sudo systemctl restart apache2</code></li>\n</ul>\n<h5 id=\"第五步检查-apache-状态看配置是否有误\">第五步：检查 Apache 状态，看配置是否有误</h5>\n<pre><code>    sudo systemctl status apache2\n    sudo tail -f /var/log/apache2/error.log\n</code></pre>\n<h5 id=\"第六步验证配置是否成功\">第六步：验证配置是否成功</h5>\n<p>在浏览器中输入：<code>http://localhost</code>。</p>\n<p><em>补充说明</em></p>\n<ul>\n<li>若出现 403 Forbidden 错误，大概率是权限问题，优先检查目标目录及其上级目录的权限是否配置正确，以及www-data是否有访问权限。</li>\n</ul>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-18 10:58</span>&nbsp;\n<a href=\"https://www.cnblogs.com/jeanwaljean\">宁静的舞者</a>&nbsp;\n阅读(<span id=\"post_view_count\">4</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    },
    {
      "title": "【小记】解决校园网中单播互通的不同子网间的 LocalSend 发现问题",
      "link": "https://www.cnblogs.com/somebottle/p/19497343/simple_report_of_localsend_switch",
      "published": "",
      "description": "<h1 class=\"postTitle\">\n                <a class=\"postTitle2 vertical-middle\" href=\"https://www.cnblogs.com/somebottle/p/19497343/simple_report_of_localsend_switch\" id=\"cb_post_title_url\" title=\"发布于 2026-01-17 23:05\">\n    <span>【小记】解决校园网中单播互通的不同子网间的 LocalSend 发现问题</span>\n    \n\n</a>\n\n            </h1>\n            <div class=\"clear\"></div>\n            <div class=\"postBody\">\n                    <div id=\"cnblogs_post_description\" style=\"display: none;\">\n        <img alt=\"【小记】解决校园网中单播互通的不同子网间的 LocalSend 发现问题\" class=\"desc_img\" src=\"https://img2024.cnblogs.com/blog/2588810/202601/2588810-20260117230317162-937114161.png\" />\n        这回来折腾一下怎么在多播隔离、单播允许的局域网（比如校园网）子网之间实现 LocalSend 客户端的互相发现。\n    </div>\n<div class=\"blogpost-body cnblogs-markdown\" id=\"cnblogs_post_body\">\n<p>各位好久不见~下半年又是忙论文又是忙项目的，实在是没什么时间更新笔记了。趁着今天有点空闲，咱来写写最近抽空解决的一个小网络问题叭（゜ー゜）。</p>\n<h2 id=\"0-问题背景\">0. 问题背景</h2>\n<p>咱实验室有一台连接着打印机的计算机，我们在这台机器上挂了一个专门注册的 QQ 账号，需要打印文件时把文件发送到这个 QQ 账号上，在打印机计算机上下载下来就行了。</p>\n<p>但是吧，像是比较机密文件的话，如果这样过一道别人的服务器感觉不太好，正好咱当时也找到了局域网文件传输工具 LocalSend，遂试了试。</p>\n<p>结果我发现，打印机计算机上的 LocalSend 客户端无法发现我笔记本上的 LocalSend 端，反之亦然。我还得到打印机计算机上手动输入笔记本电脑被分配的 IP 地址才能传输文件，略显麻烦。</p>\n<ul>\n<li>更不提校园网这有线网和无线网给设备分配的全是动态 IP，可能过一段时间就会变。</li>\n</ul>\n<p><img alt=\"Analyzing\" src=\"https://serv.xbottle.top/i/https://raw.githubusercontent.com/cat-note/bottleassets/main/img/BDE19D9F629D18E59D1752BDB5FDBFDE-2026-01-17.jpg\" /></p>\n<p>分析了一下发现：</p>\n<ol>\n<li>\n<p>没有办法互相发现是因为，我的笔记本接入的是校园网无线网络，而打印机计算机接入的是有线网络，两个主机在<strong>不同的子网段</strong>内，这阻隔了 LocalSend 发出的组播包 (可以参考 <a href=\"https://github.com/localsend/protocol\" rel=\"noopener nofollow\" target=\"_blank\">LocalSend 协议</a>)。</p>\n</li>\n<li>\n<p>可以手动输入 IP 地址来指定客户端传输文件，是因为 LocalSend 实际的传输等请求是<strong>单播</strong>的，而校园网在三层设备上有配置路由转发，所以单播包是可以互通的。</p>\n</li>\n</ol>\n<p>于是咱要解决的问题就是，如何在这种<strong>多播 (组播) 隔离但是单播互通</strong>的不同局域子网间实现 LocalSend 的发现功能。</p>\n<h2 id=\"1-问题描述\">1. 问题描述</h2>\n<p><img alt=\"Issue Illustration\" src=\"https://serv.xbottle.top/i/https://raw.githubusercontent.com/SomeBottle/localsend-switch/refs/heads/main/pics/issue_illustration.drawio.png\" /></p>\n<blockquote>\n<p>Figure 1: 问题示意图。 可以看到 VLAN 0 中的 LocalSend 客户端无法成功发现 VLAN 2 中的 LocalSend 客户端，反之亦然。</p>\n</blockquote>\n<p>LocalSend 客户端采用 UDP 组播来把自己的存在通告给局域网中其他客户端。然而，像校园网这种大型局域网，通常为了管理和减小广播域规模等目的，会将网络划分为多个 VLAN（虚拟局域网），对应多个子网，即使是现实中距离很近的两个设备，也有可能在不同的 VLAN 中。</p>\n<ul>\n<li>比如我连接到校园网 WiFi 的笔记本电脑和连接有线校园网的实验室打印机电脑，虽然在同一间屋子，但就是处于不同网段的网络中。</li>\n</ul>\n<p>不同子网之间的数据转发依赖于第三层路由设备来实现，不幸的是，LocalSend 向 <code>224.0.0.x</code> 组播地址及应用端口发送的 UDP 报文段是不会被三层设备转发的，而且其 TTL 值为 <code>1</code>，Wireshark 抓包如下：</p>\n<p><img alt=\"Wireshark Capture\" src=\"https://serv.xbottle.top/i/https://raw.githubusercontent.com/SomeBottle/localsend-switch/refs/heads/main/pics/wireshark_captured.png\" /></p>\n<blockquote>\n<p>Figure 2: Wireshark 抓包显示 LocalSend 发送的组播 UDP 报文段的 TTL 值为 1。</p>\n</blockquote>\n<p>因此就有了明明两台设备近在咫尺，但是却没法互相发现对方 LocalSend 客户端的尴尬局面 ㄟ( ▔, ▔ )ㄏ。</p>\n<h2 id=\"2-解决问题\">2. 解决问题</h2>\n<h3 id=\"20-思路\">2.0. 思路</h3>\n<p>尽管多播被隔离了，但是办公区校园网在三层配置上是会转发单播包的，我可以通过单播和不同的 VLAN 中的主机进行通信。</p>\n<p>一个 LocalSend 客户端在尝试发现局域网内其他客户端时，会发送组播 UDP 包来声明自己的存在，其他客户端收到组播包后会通过<strong>单播的 HTTP 请求</strong>来在这个客户端上进行注册。因为单播可以跨 VLAN，所以这个注册操作是可以实现的，我可以<strong>替 LocalSend 客户端向局域网内的其他 LocalSend 客户端发送注册请求</strong>，从而实现跨 VLAN 的发现和注册。</p>\n<p>从官方的协议文档可以看到 LocalSend 的通告包和注册请求的负载中都只有端口信息，没有源 IP 信息，<strong>客户端在处理到来的请求时实际上是从网络层分组头部获取到源 IP 地址</strong>的，因此这个请求必须从 LocalSend 客户端所处的主机上发出。为了实现这点，我可以<strong>在每台有 LocalSend 的主机上都额外运行一个工具进程来代发注册请求</strong>。</p>\n<p>关键的问题来了，这些工具进程怎么知道局域网内其他 LocalSend 客户端的存在呢？其实我可以借助单播传输来实现这些工具进程之间的通信，从而让它们<strong>互相交换</strong>各自了解的 LocalSend 客户端信息。</p>\n<p>为了解决动态 IP 的问题，我可以把其中一个或多个工具进程作为交换节点<strong>部署在拥有静态 IP 的服务器</strong>上（内网和外网的均可），然后让其他工具进程连接到这些交换节点，当交换过程收敛时，这些工具进程就能互相了解对方所处主机上的 LocalSend 客户端信息了（也让 LocalSend 客户端互相知晓了对方的存在）。</p>\n<p>正好最近学了 Go 语言，照着上面这个思路实现下来，LocalSend Switch 这个工具就诞生辣！٩(&gt;௰&lt;)و</p>\n<ul>\n<li>简单来说 LocalSend Switch 充当的角色就有点类似于 BT 下载中的 Tracker 服务器了，但同时也会帮忙发送单播的注册请求，用于辅助<strong>组播隔离、单播允许</strong>的局域网子网之间的 LocalSend 客户端互相发现。</li>\n</ul>\n<h3 id=\"21-工作原理\">2.1. 工作原理</h3>\n<p><img alt=\"Switch Strategy Illustration\" src=\"https://serv.xbottle.top/i/https://raw.githubusercontent.com/SomeBottle/localsend-switch/refs/heads/main/pics/switch_strategy_illustration.drawio.png\" /></p>\n<blockquote>\n<p>Figure 3: LocalSend Switch 的工作原理示意图。实线表示的是单播分组的传播路径，虚线表示的是 TCP 逻辑连接；虚线上的箭头对应数据在逻辑上的传播方向。LocalSend 客户端和 Switch 进程的旁边标记了连接端口，只有 VLAN 1 中的 Switch 进程监听了服务端口 <code>7761</code>，其余两个 Switch 进程的均为 OS 分配的临时端口；LocalSend 客户端默认服务端口是 <code>53317</code>。</p>\n</blockquote>\n<p>Fig.3 为 LocalSend Switch 的工作原理示意图，展示了单次的客户端信息传播以及注册请求代发的过程。图中，首先 <code>10.84.0.0/15</code> 网段中 <code>10.84.123.223</code> 这台主机上的 LocalSend 客户端发送了组播包，通告自己的存在，被同一台机器上的 LocalSend Switch 捕获到，Switch 进程随后将该通告信息通过单播发送 (图中标记为 <code>CLIENT ANNOUNCE</code>，传播路径为蓝色) 给它所连接的所有 Switch 节点 (图中只有 <code>192.168.232.47:7761</code> 这一个)。</p>\n<ul>\n<li>发送的数据中封装了 LocalSend <strong>客户端的 IP 和端口</strong>，无论被转发多少次，这部分数据都不会变，指向<strong>最初发出</strong>这条通告信息的 LocalSend 客户端。</li>\n</ul>\n<p><code>47</code> 主机上 Switch 节点接收到通告的客户端信息后，会将该信息转发至它所连接的<strong>其他</strong> Switch 节点（图中只有 <code>10.94.23.114:52341</code>），图中标记为 <code>FORWARD ANNOUNCE</code>，传播路径为紫色。因为这台主机上没有 LocalSend 客户端，所以不会有注册请求的代发操作。</p>\n<p><code>114</code> 主机上的 Switch 节点接收到通告信息后，会将该信息发送给它所连接的其他所有 Switch 节点（图中没有其他节点了）；因为这台主机上有 LocalSend 客户端，所以 Switch 节点随后会向通告信息中携带的 LocalSend 客户端地址 (图中为 <code>10.84.123.223:53317</code> ) 发送 HTTP(S) 注册请求（图中标记为 <code>REGISTER CLIENT</code>，传播路径为棕色），告知对方本地客户端的 IP 和地址 (图中为 <code>10.94.23.114:53317</code>)，完成注册请求的代发操作。注意这个注册请求是直接由 Switch 发送给 LocalSend 客户端的。</p>\n<p>实际上每个 Switch 节点都有这样的转发功能，甚至可以在逻辑上串联或者组成树形、星型、网状、混合等拓扑结构。</p>\n<h2 id=\"3-更进一步\">3. 更进一步</h2>\n<p>解决了 LocalSend 互相发现的问题后，我又考虑并解决了以下几个问题：</p>\n<ol>\n<li>传输安全性问题。</li>\n<li>交换信息的环路问题。</li>\n<li>自启动问题。</li>\n</ol>\n<blockquote>\n<p>注：这节的 \"Switch\" 均指 LocalSend Switch 工具。</p>\n</blockquote>\n<h3 id=\"30-传输安全性问题\">3.0. 传输安全性问题</h3>\n<p>Switch 节点间的数据传输在 TCP 连接上进行，默认情况下是<strong>明文</strong>的，其中主要是 LocalSend 客户端的主机的地址、设备型号等信息。</p>\n<p>尽管在校园网这种较为可信的局域网中不用担心遭到中间人攻击，而且传输的数据本身也没有那么敏感，但如果中间有的 Switch 节点在外网上，就还是有一定风险的，如中间人可以伪造 LocalSend 客户端信息，诱导其他 Switch 节点向恶意构造的内网客户端地址发送注册请求，从而造成拒绝服务攻击 (DoS)。</p>\n<p>为此咱考虑过 <strong>TLS</strong> 加密传输，但是考虑到配置和证书管理的复杂性，最终选择了<strong>预共享密钥</strong> (PSK) 方式来对传输的数据进行简单的对称加密，即持有相同密钥的 Switch 节点才能互相通信，传输的是密文。</p>\n<ul>\n<li>\n<p>另外为了防止接收到恶意构造的 LocalSend 客户端信息，限制每个 Switch 节点<strong>仅可向私有 IP 地址发送</strong> HTTP(S) 注册请求，避免主机被利用向公网地址发送请求。</p>\n</li>\n<li>\n<p>这个工具的使用场景实际上挺简单的，因此这个程度的安全性应该已经足够了 (*￣０￣)ノ。</p>\n</li>\n</ul>\n<h3 id=\"31-交换信息的环路问题\">3.1. 交换信息的环路问题</h3>\n<p>本科学计算机网络时，在网络层这一块就听老师讲过环路问题。而本工具如果不加以限制也会导致同一条 LocalSend 客户端信息被疯狂重复转发，浪费带宽和计算资源。</p>\n<p>为了解决这点咱采用了两个措施：</p>\n<ol>\n<li>\n<p><strong>经典的 TTL 机制</strong>。给每条消息都设置一个 TTL 字段，每经过一个 Switch 节点 TTL 则减 <code>1</code>，当其减到 <code>0</code> 时该消息就不再被转发。</p>\n</li>\n<li>\n<p><strong>唯一 ID 缓存机制</strong>。每条信息都有一个唯一 ID，由 Switch 节点的<em>临时随机标识</em>以及<em>消息的递增编号</em>组成。每个 Switch 节点都会避免重复把相同 ID 的客户端信息重复加入转发缓冲区，也就不会重复转发已经转发过的 LocalSend 客户端信息。</p>\n<ul>\n<li>这个唯一 ID 缓存是有过期时间的，咱默认设置为了 <code>5</code> 分钟，以防止内存无限增长。</li>\n<li><em>临时随机标识</em>是在 Switch 启动时生成的，重启后会改变，因此重启后的 Switch 节点会被认为是一个新的节点。</li>\n<li><strong>唯一 ID 机制</strong>还能一定程度上防止重放攻击。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"32-自启动问题\">3.2. 自启动问题</h3>\n<p>如果每次使用 LocalSend Switch 都需要手动启动的话，多少还是有些麻烦，因此咱特地还写了开机 (登录后) 自启的相关配置模块，目前支持了 Windows 和 Linux (带桌面)。</p>\n<ul>\n<li>Windows 下是参考了 LocalSend 的自启动实现，往注册表里写入了开机自启项。</li>\n<li>Linux 下则是依照 FreeDesktop 的 <a href=\"https://specifications.freedesktop.org/desktop-entry/latest/recognized-keys.html\" rel=\"noopener nofollow\" target=\"_blank\">Desktop Entry</a> 规范，写入了 <code>~/.config/autostart/</code> 目录下。</li>\n<li>MacOS...咳咳，咱还没苹果电脑呢，暂时没法测试和实现 Or2...</li>\n</ul>\n<h2 id=\"4-项目地址--总结\">4. 项目地址 &amp; 总结</h2>\n<p>✨ 项目地址: <a href=\"https://github.com/SomeBottle/localsend-switch\" rel=\"noopener nofollow\" target=\"_blank\">https://github.com/SomeBottle/localsend-switch</a></p>\n<p>一顿折腾下来，咱又花了好多时间写了这样一个使用场景其实挺小众的工具...不过总的来说还是挺有趣的，一方面熟悉了 Go 语言程序的基本思想和编写规范，另一方面也复习复习了一下计算机网络和基本的网络编程知识（像是手动去搭个 TCP 服务，实现简单的连接维护等等）。</p>\n<ul>\n<li>复习归复习，个人学艺不精，难免有疏漏之处，请各位多指教！</li>\n</ul>\n<p>动手去解决些实际问题，总归是个不错的学习途径呢 (๑•̀ㅂ•́)و✧</p>\n<p>转眼也 2026 了，祝各位新年快乐，事业顺利！咱们下一篇文章再会~ (づ￣ ³￣)づ</p>\n<p><img alt=\"drink_coffee-2026-01-17\" src=\"https://serv.xbottle.top/i/https://raw.githubusercontent.com/cat-note/bottleassets/main/img/drink_coffee-2026-01-17.gif\" /></p>\n\n</div>\n<div class=\"clear\"></div>\n\n            </div>\n            <div class=\"postDesc\">posted @ \n<span id=\"post-date\">2026-01-17 23:05</span>&nbsp;\n<a href=\"https://www.cnblogs.com/somebottle\">SomeBottle</a>&nbsp;\n阅读(<span id=\"post_view_count\">12</span>)&nbsp;\n评论(<span id=\"post_comment_count\">0</span>)&nbsp;\n&nbsp;\n<a href=\"\">收藏</a>&nbsp;\n<a href=\"\">举报</a>\n</div>"
    }
  ]
}